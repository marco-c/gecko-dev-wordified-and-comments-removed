#
include
"
frontend
/
BytecodeEmitter
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
<
string
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
ds
/
Nestable
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
#
include
"
frontend
/
BytecodeControlStructures
.
h
"
#
include
"
frontend
/
CallOrNewEmitter
.
h
"
#
include
"
frontend
/
CForEmitter
.
h
"
#
include
"
frontend
/
DefaultEmitter
.
h
"
#
include
"
frontend
/
DoWhileEmitter
.
h
"
#
include
"
frontend
/
ElemOpEmitter
.
h
"
#
include
"
frontend
/
EmitterScope
.
h
"
#
include
"
frontend
/
ExpressionStatementEmitter
.
h
"
#
include
"
frontend
/
ForInEmitter
.
h
"
#
include
"
frontend
/
ForOfEmitter
.
h
"
#
include
"
frontend
/
ForOfLoopControl
.
h
"
#
include
"
frontend
/
FunctionEmitter
.
h
"
#
include
"
frontend
/
IfEmitter
.
h
"
#
include
"
frontend
/
LabelEmitter
.
h
"
#
include
"
frontend
/
LexicalScopeEmitter
.
h
"
#
include
"
frontend
/
ModuleSharedContext
.
h
"
#
include
"
frontend
/
NameAnalysisTypes
.
h
"
#
include
"
frontend
/
NameFunctions
.
h
"
#
include
"
frontend
/
NameOpEmitter
.
h
"
#
include
"
frontend
/
ObjectEmitter
.
h
"
#
include
"
frontend
/
OptionalEmitter
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
Parser
.
h
"
#
include
"
frontend
/
ParserAtom
.
h
"
#
include
"
frontend
/
PrivateOpEmitter
.
h
"
#
include
"
frontend
/
PropOpEmitter
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
frontend
/
SwitchEmitter
.
h
"
#
include
"
frontend
/
TaggedParserAtomIndexHasher
.
h
"
#
include
"
frontend
/
TDZCheckCache
.
h
"
#
include
"
frontend
/
TryEmitter
.
h
"
#
include
"
frontend
/
WhileEmitter
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
friend
/
StackLimits
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
AsyncFunctionResolveKind
.
h
"
#
include
"
vm
/
BytecodeUtil
.
h
"
#
include
"
vm
/
FunctionPrefixKind
.
h
"
#
include
"
vm
/
GeneratorObject
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
#
include
"
vm
/
PropMap
.
h
"
#
include
"
vm
/
Scope
.
h
"
#
include
"
vm
/
SharedStencil
.
h
"
#
include
"
vm
/
ThrowMsgKind
.
h
"
#
include
"
vm
/
WellKnownAtom
.
h
"
#
include
"
wasm
/
AsmJS
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
using
mozilla
:
:
AssertedCast
;
using
mozilla
:
:
AsVariant
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
NumberEqualsInt32
;
using
mozilla
:
:
NumberIsInt32
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
Some
;
static
bool
ParseNodeRequiresSpecialLineNumberNotes
(
ParseNode
*
pn
)
{
ParseNodeKind
kind
=
pn
-
>
getKind
(
)
;
return
kind
=
=
ParseNodeKind
:
:
WhileStmt
|
|
kind
=
=
ParseNodeKind
:
:
ForStmt
|
|
kind
=
=
ParseNodeKind
:
:
Function
;
}
static
bool
NeedsFieldInitializer
(
ParseNode
*
member
bool
inStaticContext
)
{
return
(
member
-
>
is
<
StaticClassBlock
>
(
)
&
&
inStaticContext
)
|
|
(
member
-
>
is
<
ClassField
>
(
)
&
&
member
-
>
as
<
ClassField
>
(
)
.
isStatic
(
)
=
=
inStaticContext
)
;
}
static
bool
NeedsAccessorInitializer
(
ParseNode
*
member
bool
isStatic
)
{
if
(
isStatic
)
{
return
false
;
}
return
member
-
>
is
<
ClassMethod
>
(
)
&
&
member
-
>
as
<
ClassMethod
>
(
)
.
name
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
&
&
!
member
-
>
as
<
ClassMethod
>
(
)
.
isStatic
(
)
&
&
member
-
>
as
<
ClassMethod
>
(
)
.
accessorType
(
)
!
=
AccessorType
:
:
None
;
}
static
bool
ShouldSuppressBreakpointsAndSourceNotes
(
SharedContext
*
sc
BytecodeEmitter
:
:
EmitterMode
emitterMode
)
{
if
(
emitterMode
=
=
BytecodeEmitter
:
:
EmitterMode
:
:
SelfHosting
)
{
return
true
;
}
if
(
sc
-
>
isFunctionBox
(
)
)
{
FunctionBox
*
funbox
=
sc
-
>
asFunctionBox
(
)
;
return
funbox
-
>
isSyntheticFunction
(
)
&
&
funbox
-
>
isClassConstructor
(
)
;
}
return
false
;
}
BytecodeEmitter
:
:
BytecodeEmitter
(
BytecodeEmitter
*
parent
SharedContext
*
sc
CompilationState
&
compilationState
EmitterMode
emitterMode
)
:
sc
(
sc
)
cx
(
sc
-
>
cx_
)
parent
(
parent
)
bytecodeSection_
(
cx
sc
-
>
extent
(
)
.
lineno
sc
-
>
extent
(
)
.
column
)
perScriptData_
(
cx
compilationState
)
compilationState
(
compilationState
)
suppressBreakpointsAndSourceNotes
(
ShouldSuppressBreakpointsAndSourceNotes
(
sc
emitterMode
)
)
emitterMode
(
emitterMode
)
{
}
BytecodeEmitter
:
:
BytecodeEmitter
(
BytecodeEmitter
*
parent
BCEParserHandle
*
handle
SharedContext
*
sc
CompilationState
&
compilationState
EmitterMode
emitterMode
)
:
BytecodeEmitter
(
parent
sc
compilationState
emitterMode
)
{
parser
=
handle
;
}
BytecodeEmitter
:
:
BytecodeEmitter
(
BytecodeEmitter
*
parent
const
EitherParser
&
parser
SharedContext
*
sc
CompilationState
&
compilationState
EmitterMode
emitterMode
)
:
BytecodeEmitter
(
parent
sc
compilationState
emitterMode
)
{
ep_
.
emplace
(
parser
)
;
this
-
>
parser
=
ep_
.
ptr
(
)
;
}
void
BytecodeEmitter
:
:
initFromBodyPosition
(
TokenPos
bodyPosition
)
{
setScriptStartOffsetIfUnset
(
bodyPosition
.
begin
)
;
setFunctionBodyEndPos
(
bodyPosition
.
end
)
;
}
bool
BytecodeEmitter
:
:
init
(
)
{
if
(
!
parent
)
{
if
(
!
compilationState
.
prepareSharedDataStorage
(
cx
)
)
{
return
false
;
}
}
return
perScriptData_
.
init
(
cx
)
;
}
bool
BytecodeEmitter
:
:
init
(
TokenPos
bodyPosition
)
{
initFromBodyPosition
(
bodyPosition
)
;
return
init
(
)
;
}
template
<
typename
T
>
T
*
BytecodeEmitter
:
:
findInnermostNestableControl
(
)
const
{
return
NestableControl
:
:
findNearest
<
T
>
(
innermostNestableControl
)
;
}
template
<
typename
T
typename
Predicate
>
T
*
BytecodeEmitter
:
:
findInnermostNestableControl
(
Predicate
predicate
)
const
{
return
NestableControl
:
:
findNearest
<
T
>
(
innermostNestableControl
predicate
)
;
}
NameLocation
BytecodeEmitter
:
:
lookupName
(
TaggedParserAtomIndex
name
)
{
return
innermostEmitterScope
(
)
-
>
lookup
(
this
name
)
;
}
bool
BytecodeEmitter
:
:
lookupPrivate
(
TaggedParserAtomIndex
name
NameLocation
&
loc
Maybe
<
NameLocation
>
&
brandLoc
)
{
return
innermostEmitterScope
(
)
-
>
lookupPrivate
(
this
name
loc
brandLoc
)
;
}
Maybe
<
NameLocation
>
BytecodeEmitter
:
:
locationOfNameBoundInScope
(
TaggedParserAtomIndex
name
EmitterScope
*
target
)
{
return
innermostEmitterScope
(
)
-
>
locationBoundInScope
(
name
target
)
;
}
template
<
typename
T
>
Maybe
<
NameLocation
>
BytecodeEmitter
:
:
locationOfNameBoundInScopeType
(
TaggedParserAtomIndex
name
EmitterScope
*
source
)
{
EmitterScope
*
aScope
=
source
;
while
(
!
aScope
-
>
scope
(
this
)
.
is
<
T
>
(
)
)
{
aScope
=
aScope
-
>
enclosingInFrame
(
)
;
}
return
source
-
>
locationBoundInScope
(
name
aScope
)
;
}
bool
BytecodeEmitter
:
:
markStepBreakpoint
(
)
{
if
(
skipBreakpointSrcNotes
(
)
)
{
return
true
;
}
if
(
!
newSrcNote
(
SrcNoteType
:
:
StepSep
)
)
{
return
false
;
}
if
(
!
newSrcNote
(
SrcNoteType
:
:
Breakpoint
)
)
{
return
false
;
}
bytecodeSection
(
)
.
updateSeparatorPosition
(
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
markSimpleBreakpoint
(
)
{
if
(
skipBreakpointSrcNotes
(
)
)
{
return
true
;
}
if
(
!
bytecodeSection
(
)
.
isDuplicateLocation
(
)
)
{
if
(
!
newSrcNote
(
SrcNoteType
:
:
Breakpoint
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitCheck
(
JSOp
op
ptrdiff_t
delta
BytecodeOffset
*
offset
)
{
size_t
oldLength
=
bytecodeSection
(
)
.
code
(
)
.
length
(
)
;
*
offset
=
BytecodeOffset
(
oldLength
)
;
size_t
newLength
=
oldLength
+
size_t
(
delta
)
;
if
(
MOZ_UNLIKELY
(
newLength
>
MaxBytecodeLength
)
)
{
ReportAllocationOverflow
(
cx
)
;
return
false
;
}
if
(
!
bytecodeSection
(
)
.
code
(
)
.
growByUninitialized
(
delta
)
)
{
return
false
;
}
if
(
BytecodeOpHasIC
(
op
)
)
{
static_assert
(
MaxBytecodeLength
+
1
+
ARGC_LIMIT
<
=
UINT32_MAX
"
numICEntries
must
not
overflow
"
)
;
bytecodeSection
(
)
.
incrementNumICEntries
(
)
;
}
return
true
;
}
#
ifdef
DEBUG
bool
BytecodeEmitter
:
:
checkStrictOrSloppy
(
JSOp
op
)
{
if
(
IsCheckStrictOp
(
op
)
&
&
!
sc
-
>
strict
(
)
)
{
return
false
;
}
if
(
IsCheckSloppyOp
(
op
)
&
&
sc
-
>
strict
(
)
)
{
return
false
;
}
return
true
;
}
#
endif
bool
BytecodeEmitter
:
:
emit1
(
JSOp
op
)
{
MOZ_ASSERT
(
checkStrictOrSloppy
(
op
)
)
;
BytecodeOffset
offset
;
if
(
!
emitCheck
(
op
1
&
offset
)
)
{
return
false
;
}
jsbytecode
*
code
=
bytecodeSection
(
)
.
code
(
offset
)
;
code
[
0
]
=
jsbytecode
(
op
)
;
bytecodeSection
(
)
.
updateDepth
(
offset
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emit2
(
JSOp
op
uint8_t
op1
)
{
MOZ_ASSERT
(
checkStrictOrSloppy
(
op
)
)
;
BytecodeOffset
offset
;
if
(
!
emitCheck
(
op
2
&
offset
)
)
{
return
false
;
}
jsbytecode
*
code
=
bytecodeSection
(
)
.
code
(
offset
)
;
code
[
0
]
=
jsbytecode
(
op
)
;
code
[
1
]
=
jsbytecode
(
op1
)
;
bytecodeSection
(
)
.
updateDepth
(
offset
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emit3
(
JSOp
op
jsbytecode
op1
jsbytecode
op2
)
{
MOZ_ASSERT
(
checkStrictOrSloppy
(
op
)
)
;
MOZ_ASSERT
(
!
IsArgOp
(
op
)
)
;
MOZ_ASSERT
(
!
IsLocalOp
(
op
)
)
;
BytecodeOffset
offset
;
if
(
!
emitCheck
(
op
3
&
offset
)
)
{
return
false
;
}
jsbytecode
*
code
=
bytecodeSection
(
)
.
code
(
offset
)
;
code
[
0
]
=
jsbytecode
(
op
)
;
code
[
1
]
=
op1
;
code
[
2
]
=
op2
;
bytecodeSection
(
)
.
updateDepth
(
offset
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitN
(
JSOp
op
size_t
extra
BytecodeOffset
*
offset
)
{
MOZ_ASSERT
(
checkStrictOrSloppy
(
op
)
)
;
ptrdiff_t
length
=
1
+
ptrdiff_t
(
extra
)
;
BytecodeOffset
off
;
if
(
!
emitCheck
(
op
length
&
off
)
)
{
return
false
;
}
jsbytecode
*
code
=
bytecodeSection
(
)
.
code
(
off
)
;
code
[
0
]
=
jsbytecode
(
op
)
;
if
(
CodeSpec
(
op
)
.
nuses
>
=
0
)
{
bytecodeSection
(
)
.
updateDepth
(
off
)
;
}
if
(
offset
)
{
*
offset
=
off
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitJumpTargetOp
(
JSOp
op
BytecodeOffset
*
off
)
{
MOZ_ASSERT
(
BytecodeIsJumpTarget
(
op
)
)
;
uint32_t
numEntries
=
bytecodeSection
(
)
.
numICEntries
(
)
;
size_t
n
=
GetOpLength
(
op
)
-
1
;
MOZ_ASSERT
(
GetOpLength
(
op
)
>
=
1
+
ICINDEX_LEN
)
;
if
(
!
emitN
(
op
n
off
)
)
{
return
false
;
}
SET_ICINDEX
(
bytecodeSection
(
)
.
code
(
*
off
)
numEntries
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitJumpTarget
(
JumpTarget
*
target
)
{
BytecodeOffset
off
=
bytecodeSection
(
)
.
offset
(
)
;
if
(
bytecodeSection
(
)
.
lastTargetOffset
(
)
.
valid
(
)
&
&
off
=
=
bytecodeSection
(
)
.
lastTargetOffset
(
)
+
BytecodeOffsetDiff
(
JSOpLength_JumpTarget
)
)
{
target
-
>
offset
=
bytecodeSection
(
)
.
lastTargetOffset
(
)
;
return
true
;
}
target
-
>
offset
=
off
;
bytecodeSection
(
)
.
setLastTargetOffset
(
off
)
;
BytecodeOffset
opOff
;
return
emitJumpTargetOp
(
JSOp
:
:
JumpTarget
&
opOff
)
;
}
bool
BytecodeEmitter
:
:
emitJumpNoFallthrough
(
JSOp
op
JumpList
*
jump
)
{
BytecodeOffset
offset
;
if
(
!
emitCheck
(
op
5
&
offset
)
)
{
return
false
;
}
jsbytecode
*
code
=
bytecodeSection
(
)
.
code
(
offset
)
;
code
[
0
]
=
jsbytecode
(
op
)
;
MOZ_ASSERT
(
!
jump
-
>
offset
.
valid
(
)
|
|
(
0
<
=
jump
-
>
offset
.
value
(
)
&
&
jump
-
>
offset
<
offset
)
)
;
jump
-
>
push
(
bytecodeSection
(
)
.
code
(
BytecodeOffset
(
0
)
)
offset
)
;
bytecodeSection
(
)
.
updateDepth
(
offset
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitJump
(
JSOp
op
JumpList
*
jump
)
{
if
(
!
emitJumpNoFallthrough
(
op
jump
)
)
{
return
false
;
}
if
(
BytecodeFallsThrough
(
op
)
)
{
JumpTarget
fallthrough
;
if
(
!
emitJumpTarget
(
&
fallthrough
)
)
{
return
false
;
}
}
return
true
;
}
void
BytecodeEmitter
:
:
patchJumpsToTarget
(
JumpList
jump
JumpTarget
target
)
{
MOZ_ASSERT
(
!
jump
.
offset
.
valid
(
)
|
|
(
0
<
=
jump
.
offset
.
value
(
)
&
&
jump
.
offset
<
=
bytecodeSection
(
)
.
offset
(
)
)
)
;
MOZ_ASSERT
(
0
<
=
target
.
offset
.
value
(
)
&
&
target
.
offset
<
=
bytecodeSection
(
)
.
offset
(
)
)
;
MOZ_ASSERT_IF
(
jump
.
offset
.
valid
(
)
&
&
target
.
offset
+
BytecodeOffsetDiff
(
4
)
<
=
bytecodeSection
(
)
.
offset
(
)
BytecodeIsJumpTarget
(
JSOp
(
*
bytecodeSection
(
)
.
code
(
target
.
offset
)
)
)
)
;
jump
.
patchAll
(
bytecodeSection
(
)
.
code
(
BytecodeOffset
(
0
)
)
target
)
;
}
bool
BytecodeEmitter
:
:
emitJumpTargetAndPatch
(
JumpList
jump
)
{
if
(
!
jump
.
offset
.
valid
(
)
)
{
return
true
;
}
JumpTarget
target
;
if
(
!
emitJumpTarget
(
&
target
)
)
{
return
false
;
}
patchJumpsToTarget
(
jump
target
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitCall
(
JSOp
op
uint16_t
argc
const
Maybe
<
uint32_t
>
&
sourceCoordOffset
)
{
if
(
sourceCoordOffset
.
isSome
(
)
)
{
if
(
!
updateSourceCoordNotes
(
*
sourceCoordOffset
)
)
{
return
false
;
}
}
return
emit3
(
op
ARGC_LO
(
argc
)
ARGC_HI
(
argc
)
)
;
}
bool
BytecodeEmitter
:
:
emitCall
(
JSOp
op
uint16_t
argc
ParseNode
*
pn
)
{
return
emitCall
(
op
argc
pn
?
Some
(
pn
-
>
pn_pos
.
begin
)
:
Nothing
(
)
)
;
}
bool
BytecodeEmitter
:
:
emitDupAt
(
unsigned
slotFromTop
unsigned
count
)
{
MOZ_ASSERT
(
slotFromTop
<
unsigned
(
bytecodeSection
(
)
.
stackDepth
(
)
)
)
;
MOZ_ASSERT
(
slotFromTop
+
1
>
=
count
)
;
if
(
slotFromTop
=
=
0
&
&
count
=
=
1
)
{
return
emit1
(
JSOp
:
:
Dup
)
;
}
if
(
slotFromTop
=
=
1
&
&
count
=
=
2
)
{
return
emit1
(
JSOp
:
:
Dup2
)
;
}
if
(
slotFromTop
>
=
Bit
(
24
)
)
{
reportError
(
nullptr
JSMSG_TOO_MANY_LOCALS
)
;
return
false
;
}
for
(
unsigned
i
=
0
;
i
<
count
;
i
+
+
)
{
BytecodeOffset
off
;
if
(
!
emitN
(
JSOp
:
:
DupAt
3
&
off
)
)
{
return
false
;
}
jsbytecode
*
pc
=
bytecodeSection
(
)
.
code
(
off
)
;
SET_UINT24
(
pc
slotFromTop
)
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitPopN
(
unsigned
n
)
{
MOZ_ASSERT
(
n
!
=
0
)
;
if
(
n
=
=
1
)
{
return
emit1
(
JSOp
:
:
Pop
)
;
}
if
(
n
=
=
2
)
{
return
emit1
(
JSOp
:
:
Pop
)
&
&
emit1
(
JSOp
:
:
Pop
)
;
}
return
emitUint16Operand
(
JSOp
:
:
PopN
n
)
;
}
bool
BytecodeEmitter
:
:
emitPickN
(
uint8_t
n
)
{
MOZ_ASSERT
(
n
!
=
0
)
;
if
(
n
=
=
1
)
{
return
emit1
(
JSOp
:
:
Swap
)
;
}
return
emit2
(
JSOp
:
:
Pick
n
)
;
}
bool
BytecodeEmitter
:
:
emitUnpickN
(
uint8_t
n
)
{
MOZ_ASSERT
(
n
!
=
0
)
;
if
(
n
=
=
1
)
{
return
emit1
(
JSOp
:
:
Swap
)
;
}
return
emit2
(
JSOp
:
:
Unpick
n
)
;
}
bool
BytecodeEmitter
:
:
emitCheckIsObj
(
CheckIsObjectKind
kind
)
{
return
emit2
(
JSOp
:
:
CheckIsObj
uint8_t
(
kind
)
)
;
}
bool
BytecodeEmitter
:
:
emitBuiltinObject
(
BuiltinObjectKind
kind
)
{
return
emit2
(
JSOp
:
:
BuiltinObject
uint8_t
(
kind
)
)
;
}
bool
BytecodeEmitter
:
:
updateLineNumberNotes
(
uint32_t
offset
)
{
if
(
skipLocationSrcNotes
(
)
)
{
return
true
;
}
ErrorReporter
*
er
=
&
parser
-
>
errorReporter
(
)
;
bool
onThisLine
;
if
(
!
er
-
>
isOnThisLine
(
offset
bytecodeSection
(
)
.
currentLine
(
)
&
onThisLine
)
)
{
er
-
>
errorNoOffset
(
JSMSG_OUT_OF_MEMORY
)
;
return
false
;
}
if
(
!
onThisLine
)
{
unsigned
line
=
er
-
>
lineAt
(
offset
)
;
unsigned
delta
=
line
-
bytecodeSection
(
)
.
currentLine
(
)
;
unsigned
initialLine
=
sc
-
>
extent
(
)
.
lineno
;
MOZ_ASSERT
(
line
>
=
initialLine
)
;
bytecodeSection
(
)
.
setCurrentLine
(
line
offset
)
;
if
(
delta
>
=
SrcNote
:
:
SetLine
:
:
lengthFor
(
line
initialLine
)
)
{
if
(
!
newSrcNote2
(
SrcNoteType
:
:
SetLine
SrcNote
:
:
SetLine
:
:
toOperand
(
line
initialLine
)
)
)
{
return
false
;
}
}
else
{
do
{
if
(
!
newSrcNote
(
SrcNoteType
:
:
NewLine
)
)
{
return
false
;
}
}
while
(
-
-
delta
!
=
0
)
;
}
bytecodeSection
(
)
.
updateSeparatorPositionIfPresent
(
)
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
updateSourceCoordNotes
(
uint32_t
offset
)
{
if
(
!
updateLineNumberNotes
(
offset
)
)
{
return
false
;
}
if
(
skipLocationSrcNotes
(
)
)
{
return
true
;
}
uint32_t
columnIndex
=
parser
-
>
errorReporter
(
)
.
columnAt
(
offset
)
;
MOZ_ASSERT
(
columnIndex
<
=
ColumnLimit
)
;
static_assert
(
(
0
-
ptrdiff_t
(
ColumnLimit
)
)
>
=
SrcNote
:
:
ColSpan
:
:
MinColSpan
)
;
static_assert
(
(
ptrdiff_t
(
ColumnLimit
)
-
0
)
<
=
SrcNote
:
:
ColSpan
:
:
MaxColSpan
)
;
ptrdiff_t
colspan
=
ptrdiff_t
(
columnIndex
)
-
ptrdiff_t
(
bytecodeSection
(
)
.
lastColumn
(
)
)
;
if
(
colspan
!
=
0
)
{
if
(
!
newSrcNote2
(
SrcNoteType
:
:
ColSpan
SrcNote
:
:
ColSpan
:
:
toOperand
(
colspan
)
)
)
{
return
false
;
}
bytecodeSection
(
)
.
setLastColumn
(
columnIndex
offset
)
;
bytecodeSection
(
)
.
updateSeparatorPositionIfPresent
(
)
;
}
return
true
;
}
Maybe
<
uint32_t
>
BytecodeEmitter
:
:
getOffsetForLoop
(
ParseNode
*
nextpn
)
{
if
(
!
nextpn
)
{
return
Nothing
(
)
;
}
if
(
nextpn
-
>
is
<
LexicalScopeNode
>
(
)
)
{
nextpn
=
nextpn
-
>
as
<
LexicalScopeNode
>
(
)
.
scopeBody
(
)
;
}
if
(
nextpn
-
>
isKind
(
ParseNodeKind
:
:
StatementList
)
)
{
if
(
ParseNode
*
firstStatement
=
nextpn
-
>
as
<
ListNode
>
(
)
.
head
(
)
)
{
nextpn
=
firstStatement
;
}
}
return
Some
(
nextpn
-
>
pn_pos
.
begin
)
;
}
bool
BytecodeEmitter
:
:
emitUint16Operand
(
JSOp
op
uint32_t
operand
)
{
MOZ_ASSERT
(
operand
<
=
UINT16_MAX
)
;
if
(
!
emit3
(
op
UINT16_LO
(
operand
)
UINT16_HI
(
operand
)
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitUint32Operand
(
JSOp
op
uint32_t
operand
)
{
BytecodeOffset
off
;
if
(
!
emitN
(
op
4
&
off
)
)
{
return
false
;
}
SET_UINT32
(
bytecodeSection
(
)
.
code
(
off
)
operand
)
;
return
true
;
}
namespace
{
class
NonLocalExitControl
{
public
:
enum
Kind
{
Throw
Continue
Break
Return
}
;
private
:
BytecodeEmitter
*
bce_
;
const
uint32_t
savedScopeNoteIndex_
;
const
int
savedDepth_
;
uint32_t
openScopeNoteIndex_
;
Kind
kind_
;
NonLocalExitControl
(
const
NonLocalExitControl
&
)
=
delete
;
[
[
nodiscard
]
]
bool
leaveScope
(
EmitterScope
*
scope
)
;
public
:
NonLocalExitControl
(
BytecodeEmitter
*
bce
Kind
kind
)
:
bce_
(
bce
)
savedScopeNoteIndex_
(
bce
-
>
bytecodeSection
(
)
.
scopeNoteList
(
)
.
length
(
)
)
savedDepth_
(
bce
-
>
bytecodeSection
(
)
.
stackDepth
(
)
)
openScopeNoteIndex_
(
bce
-
>
innermostEmitterScope
(
)
-
>
noteIndex
(
)
)
kind_
(
kind
)
{
}
~
NonLocalExitControl
(
)
{
for
(
uint32_t
n
=
savedScopeNoteIndex_
;
n
<
bce_
-
>
bytecodeSection
(
)
.
scopeNoteList
(
)
.
length
(
)
;
n
+
+
)
{
bce_
-
>
bytecodeSection
(
)
.
scopeNoteList
(
)
.
recordEnd
(
n
bce_
-
>
bytecodeSection
(
)
.
offset
(
)
)
;
}
bce_
-
>
bytecodeSection
(
)
.
setStackDepth
(
savedDepth_
)
;
}
[
[
nodiscard
]
]
bool
prepareForNonLocalJump
(
NestableControl
*
target
)
;
[
[
nodiscard
]
]
bool
prepareForNonLocalJumpToOutermost
(
)
{
return
prepareForNonLocalJump
(
nullptr
)
;
}
}
;
bool
NonLocalExitControl
:
:
leaveScope
(
EmitterScope
*
es
)
{
if
(
!
es
-
>
leave
(
bce_
true
)
)
{
return
false
;
}
GCThingIndex
enclosingScopeIndex
=
ScopeNote
:
:
NoScopeIndex
;
if
(
es
-
>
enclosingInFrame
(
)
)
{
enclosingScopeIndex
=
es
-
>
enclosingInFrame
(
)
-
>
index
(
)
;
}
if
(
!
bce_
-
>
bytecodeSection
(
)
.
scopeNoteList
(
)
.
append
(
enclosingScopeIndex
bce_
-
>
bytecodeSection
(
)
.
offset
(
)
openScopeNoteIndex_
)
)
{
return
false
;
}
openScopeNoteIndex_
=
bce_
-
>
bytecodeSection
(
)
.
scopeNoteList
(
)
.
length
(
)
-
1
;
return
true
;
}
bool
NonLocalExitControl
:
:
prepareForNonLocalJump
(
NestableControl
*
target
)
{
EmitterScope
*
es
=
bce_
-
>
innermostEmitterScope
(
)
;
int
npops
=
0
;
AutoCheckUnstableEmitterScope
cues
(
bce_
)
;
bool
emitIteratorClose
=
kind_
=
=
Continue
|
|
kind_
=
=
Break
|
|
kind_
=
=
Return
;
bool
emitIteratorCloseAtTarget
=
emitIteratorClose
&
&
kind_
!
=
Continue
;
auto
flushPops
=
[
&
npops
]
(
BytecodeEmitter
*
bce
)
{
if
(
npops
&
&
!
bce
-
>
emitPopN
(
npops
)
)
{
return
false
;
}
npops
=
0
;
return
true
;
}
;
Vector
<
BytecodeOffset
4
>
forOfIterCloseScopeStarts
(
bce_
-
>
cx
)
;
for
(
NestableControl
*
control
=
bce_
-
>
innermostNestableControl
;
control
!
=
target
;
control
=
control
-
>
enclosing
(
)
)
{
for
(
;
es
!
=
control
-
>
emitterScope
(
)
;
es
=
es
-
>
enclosingInFrame
(
)
)
{
if
(
!
leaveScope
(
es
)
)
{
return
false
;
}
}
switch
(
control
-
>
kind
(
)
)
{
case
StatementKind
:
:
Finally
:
{
TryFinallyControl
&
finallyControl
=
control
-
>
as
<
TryFinallyControl
>
(
)
;
if
(
finallyControl
.
emittingSubroutine
(
)
)
{
npops
+
=
3
;
}
else
{
if
(
!
flushPops
(
bce_
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emitGoSub
(
&
finallyControl
.
gosubs
)
)
{
return
false
;
}
}
break
;
}
case
StatementKind
:
:
ForOfLoop
:
if
(
emitIteratorClose
)
{
if
(
!
flushPops
(
bce_
)
)
{
return
false
;
}
BytecodeOffset
tryNoteStart
;
ForOfLoopControl
&
loopinfo
=
control
-
>
as
<
ForOfLoopControl
>
(
)
;
if
(
!
loopinfo
.
emitPrepareForNonLocalJumpFromScope
(
bce_
*
es
false
&
tryNoteStart
)
)
{
return
false
;
}
if
(
!
forOfIterCloseScopeStarts
.
append
(
tryNoteStart
)
)
{
return
false
;
}
}
else
{
npops
+
=
3
;
}
break
;
case
StatementKind
:
:
ForInLoop
:
if
(
!
flushPops
(
bce_
)
)
{
return
false
;
}
if
(
!
bce_
-
>
emit1
(
JSOp
:
:
EndIter
)
)
{
return
false
;
}
break
;
default
:
break
;
}
}
if
(
!
flushPops
(
bce_
)
)
{
return
false
;
}
if
(
target
&
&
emitIteratorCloseAtTarget
&
&
target
-
>
is
<
ForOfLoopControl
>
(
)
)
{
BytecodeOffset
tryNoteStart
;
ForOfLoopControl
&
loopinfo
=
target
-
>
as
<
ForOfLoopControl
>
(
)
;
if
(
!
loopinfo
.
emitPrepareForNonLocalJumpFromScope
(
bce_
*
es
true
&
tryNoteStart
)
)
{
return
false
;
}
if
(
!
forOfIterCloseScopeStarts
.
append
(
tryNoteStart
)
)
{
return
false
;
}
}
EmitterScope
*
targetEmitterScope
=
target
?
target
-
>
emitterScope
(
)
:
bce_
-
>
varEmitterScope
;
for
(
;
es
!
=
targetEmitterScope
;
es
=
es
-
>
enclosingInFrame
(
)
)
{
if
(
!
leaveScope
(
es
)
)
{
return
false
;
}
}
BytecodeOffset
end
=
bce_
-
>
bytecodeSection
(
)
.
offset
(
)
;
for
(
BytecodeOffset
start
:
forOfIterCloseScopeStarts
)
{
if
(
!
bce_
-
>
addTryNote
(
TryNoteKind
:
:
ForOfIterClose
0
start
end
)
)
{
return
false
;
}
}
return
true
;
}
}
bool
BytecodeEmitter
:
:
emitGoto
(
NestableControl
*
target
JumpList
*
jumplist
GotoKind
kind
)
{
NonLocalExitControl
nle
(
this
kind
=
=
GotoKind
:
:
Continue
?
NonLocalExitControl
:
:
Continue
:
NonLocalExitControl
:
:
Break
)
;
if
(
!
nle
.
prepareForNonLocalJump
(
target
)
)
{
return
false
;
}
return
emitJump
(
JSOp
:
:
Goto
jumplist
)
;
}
AbstractScopePtr
BytecodeEmitter
:
:
innermostScope
(
)
const
{
return
innermostEmitterScope
(
)
-
>
scope
(
this
)
;
}
ScopeIndex
BytecodeEmitter
:
:
innermostScopeIndex
(
)
const
{
return
*
innermostEmitterScope
(
)
-
>
scopeIndex
(
this
)
;
}
bool
BytecodeEmitter
:
:
emitGCIndexOp
(
JSOp
op
GCThingIndex
index
)
{
MOZ_ASSERT
(
checkStrictOrSloppy
(
op
)
)
;
constexpr
size_t
OpLength
=
1
+
GCTHING_INDEX_LEN
;
MOZ_ASSERT
(
GetOpLength
(
op
)
=
=
OpLength
)
;
BytecodeOffset
offset
;
if
(
!
emitCheck
(
op
OpLength
&
offset
)
)
{
return
false
;
}
jsbytecode
*
code
=
bytecodeSection
(
)
.
code
(
offset
)
;
code
[
0
]
=
jsbytecode
(
op
)
;
SET_GCTHING_INDEX
(
code
index
)
;
bytecodeSection
(
)
.
updateDepth
(
offset
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitAtomOp
(
JSOp
op
TaggedParserAtomIndex
atom
)
{
MOZ_ASSERT
(
atom
)
;
MOZ_ASSERT_IF
(
op
=
=
JSOp
:
:
GetName
|
|
op
=
=
JSOp
:
:
GetGName
atom
!
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotGenerator
(
)
)
;
GCThingIndex
index
;
if
(
!
makeAtomIndex
(
atom
&
index
)
)
{
return
false
;
}
return
emitAtomOp
(
op
index
)
;
}
bool
BytecodeEmitter
:
:
emitAtomOp
(
JSOp
op
GCThingIndex
atomIndex
)
{
MOZ_ASSERT
(
JOF_OPTYPE
(
op
)
=
=
JOF_ATOM
)
;
return
emitGCIndexOp
(
op
atomIndex
)
;
}
bool
BytecodeEmitter
:
:
emitInternedScopeOp
(
GCThingIndex
index
JSOp
op
)
{
MOZ_ASSERT
(
JOF_OPTYPE
(
op
)
=
=
JOF_SCOPE
)
;
MOZ_ASSERT
(
index
<
perScriptData
(
)
.
gcThingList
(
)
.
length
(
)
)
;
return
emitGCIndexOp
(
op
index
)
;
}
bool
BytecodeEmitter
:
:
emitInternedObjectOp
(
GCThingIndex
index
JSOp
op
)
{
MOZ_ASSERT
(
JOF_OPTYPE
(
op
)
=
=
JOF_OBJECT
)
;
MOZ_ASSERT
(
index
<
perScriptData
(
)
.
gcThingList
(
)
.
length
(
)
)
;
return
emitGCIndexOp
(
op
index
)
;
}
bool
BytecodeEmitter
:
:
emitObjectPairOp
(
GCThingIndex
index1
GCThingIndex
index2
JSOp
op
)
{
MOZ_ASSERT
(
index1
+
1
=
=
index2
"
object
pair
indices
must
be
adjacent
"
)
;
return
emitInternedObjectOp
(
index1
op
)
;
}
bool
BytecodeEmitter
:
:
emitRegExp
(
GCThingIndex
index
)
{
return
emitGCIndexOp
(
JSOp
:
:
RegExp
index
)
;
}
bool
BytecodeEmitter
:
:
emitLocalOp
(
JSOp
op
uint32_t
slot
)
{
MOZ_ASSERT
(
JOF_OPTYPE
(
op
)
!
=
JOF_ENVCOORD
)
;
MOZ_ASSERT
(
IsLocalOp
(
op
)
)
;
BytecodeOffset
off
;
if
(
!
emitN
(
op
LOCALNO_LEN
&
off
)
)
{
return
false
;
}
SET_LOCALNO
(
bytecodeSection
(
)
.
code
(
off
)
slot
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitArgOp
(
JSOp
op
uint16_t
slot
)
{
MOZ_ASSERT
(
IsArgOp
(
op
)
)
;
BytecodeOffset
off
;
if
(
!
emitN
(
op
ARGNO_LEN
&
off
)
)
{
return
false
;
}
SET_ARGNO
(
bytecodeSection
(
)
.
code
(
off
)
slot
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitEnvCoordOp
(
JSOp
op
EnvironmentCoordinate
ec
)
{
MOZ_ASSERT
(
JOF_OPTYPE
(
op
)
=
=
JOF_ENVCOORD
|
|
JOF_OPTYPE
(
op
)
=
=
JOF_DEBUGCOORD
)
;
constexpr
size_t
N
=
ENVCOORD_HOPS_LEN
+
ENVCOORD_SLOT_LEN
;
MOZ_ASSERT
(
GetOpLength
(
op
)
=
=
1
+
N
)
;
BytecodeOffset
off
;
if
(
!
emitN
(
op
N
&
off
)
)
{
return
false
;
}
jsbytecode
*
pc
=
bytecodeSection
(
)
.
code
(
off
)
;
SET_ENVCOORD_HOPS
(
pc
ec
.
hops
(
)
)
;
pc
+
=
ENVCOORD_HOPS_LEN
;
SET_ENVCOORD_SLOT
(
pc
ec
.
slot
(
)
)
;
pc
+
=
ENVCOORD_SLOT_LEN
;
return
true
;
}
JSOp
BytecodeEmitter
:
:
strictifySetNameOp
(
JSOp
op
)
{
switch
(
op
)
{
case
JSOp
:
:
SetName
:
if
(
sc
-
>
strict
(
)
)
{
op
=
JSOp
:
:
StrictSetName
;
}
break
;
case
JSOp
:
:
SetGName
:
if
(
sc
-
>
strict
(
)
)
{
op
=
JSOp
:
:
StrictSetGName
;
}
break
;
default
:
;
}
return
op
;
}
bool
BytecodeEmitter
:
:
checkSideEffects
(
ParseNode
*
pn
bool
*
answer
)
{
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
check
(
cx
)
)
{
return
false
;
}
restart
:
switch
(
pn
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
EmptyStmt
:
case
ParseNodeKind
:
:
TrueExpr
:
case
ParseNodeKind
:
:
FalseExpr
:
case
ParseNodeKind
:
:
NullExpr
:
case
ParseNodeKind
:
:
RawUndefinedExpr
:
case
ParseNodeKind
:
:
Elision
:
case
ParseNodeKind
:
:
Generator
:
MOZ_ASSERT
(
pn
-
>
is
<
NullaryNode
>
(
)
)
;
*
answer
=
false
;
return
true
;
case
ParseNodeKind
:
:
ObjectPropertyName
:
case
ParseNodeKind
:
:
PrivateName
:
case
ParseNodeKind
:
:
StringExpr
:
case
ParseNodeKind
:
:
TemplateStringExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
NameNode
>
(
)
)
;
*
answer
=
false
;
return
true
;
case
ParseNodeKind
:
:
RegExpExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
RegExpLiteral
>
(
)
)
;
*
answer
=
false
;
return
true
;
case
ParseNodeKind
:
:
NumberExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
NumericLiteral
>
(
)
)
;
*
answer
=
false
;
return
true
;
case
ParseNodeKind
:
:
BigIntExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
BigIntLiteral
>
(
)
)
;
*
answer
=
false
;
return
true
;
case
ParseNodeKind
:
:
ThisExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
UnaryNode
>
(
)
)
;
*
answer
=
sc
-
>
needsThisTDZChecks
(
)
;
return
true
;
case
ParseNodeKind
:
:
NewTargetExpr
:
case
ParseNodeKind
:
:
ImportMetaExpr
:
{
MOZ_ASSERT
(
pn
-
>
as
<
BinaryNode
>
(
)
.
left
(
)
-
>
isKind
(
ParseNodeKind
:
:
PosHolder
)
)
;
MOZ_ASSERT
(
pn
-
>
as
<
BinaryNode
>
(
)
.
right
(
)
-
>
isKind
(
ParseNodeKind
:
:
PosHolder
)
)
;
*
answer
=
false
;
return
true
;
}
case
ParseNodeKind
:
:
BreakStmt
:
MOZ_ASSERT
(
pn
-
>
is
<
BreakStatement
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
ContinueStmt
:
MOZ_ASSERT
(
pn
-
>
is
<
ContinueStatement
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
DebuggerStmt
:
MOZ_ASSERT
(
pn
-
>
is
<
DebuggerStatement
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
OptionalDotExpr
:
case
ParseNodeKind
:
:
DotExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
BinaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
TypeOfExpr
:
case
ParseNodeKind
:
:
VoidExpr
:
case
ParseNodeKind
:
:
NotExpr
:
return
checkSideEffects
(
pn
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
answer
)
;
case
ParseNodeKind
:
:
ComputedName
:
MOZ_ASSERT
(
pn
-
>
is
<
UnaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
TypeOfNameExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
UnaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
MutateProto
:
return
checkSideEffects
(
pn
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
answer
)
;
case
ParseNodeKind
:
:
PreIncrementExpr
:
case
ParseNodeKind
:
:
PostIncrementExpr
:
case
ParseNodeKind
:
:
PreDecrementExpr
:
case
ParseNodeKind
:
:
PostDecrementExpr
:
case
ParseNodeKind
:
:
ThrowStmt
:
MOZ_ASSERT
(
pn
-
>
is
<
UnaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
BitNotExpr
:
case
ParseNodeKind
:
:
PosExpr
:
case
ParseNodeKind
:
:
NegExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
UnaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
Spread
:
MOZ_ASSERT
(
pn
-
>
is
<
UnaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
InitialYield
:
case
ParseNodeKind
:
:
YieldStarExpr
:
case
ParseNodeKind
:
:
YieldExpr
:
case
ParseNodeKind
:
:
AwaitExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
UnaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
DeleteNameExpr
:
case
ParseNodeKind
:
:
DeletePropExpr
:
case
ParseNodeKind
:
:
DeleteElemExpr
:
case
ParseNodeKind
:
:
DeleteOptionalChainExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
UnaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
DeleteExpr
:
{
ParseNode
*
expr
=
pn
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
;
return
checkSideEffects
(
expr
answer
)
;
}
case
ParseNodeKind
:
:
ExpressionStmt
:
return
checkSideEffects
(
pn
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
answer
)
;
case
ParseNodeKind
:
:
InitExpr
:
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
AssignExpr
:
case
ParseNodeKind
:
:
AddAssignExpr
:
case
ParseNodeKind
:
:
SubAssignExpr
:
case
ParseNodeKind
:
:
CoalesceAssignExpr
:
case
ParseNodeKind
:
:
OrAssignExpr
:
case
ParseNodeKind
:
:
AndAssignExpr
:
case
ParseNodeKind
:
:
BitOrAssignExpr
:
case
ParseNodeKind
:
:
BitXorAssignExpr
:
case
ParseNodeKind
:
:
BitAndAssignExpr
:
case
ParseNodeKind
:
:
LshAssignExpr
:
case
ParseNodeKind
:
:
RshAssignExpr
:
case
ParseNodeKind
:
:
UrshAssignExpr
:
case
ParseNodeKind
:
:
MulAssignExpr
:
case
ParseNodeKind
:
:
DivAssignExpr
:
case
ParseNodeKind
:
:
ModAssignExpr
:
case
ParseNodeKind
:
:
PowAssignExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
AssignmentNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
SetThis
:
MOZ_ASSERT
(
pn
-
>
is
<
BinaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
StatementList
:
case
ParseNodeKind
:
:
CoalesceExpr
:
case
ParseNodeKind
:
:
OrExpr
:
case
ParseNodeKind
:
:
AndExpr
:
case
ParseNodeKind
:
:
StrictEqExpr
:
case
ParseNodeKind
:
:
StrictNeExpr
:
case
ParseNodeKind
:
:
CommaExpr
:
MOZ_ASSERT
(
!
pn
-
>
as
<
ListNode
>
(
)
.
empty
(
)
)
;
[
[
fallthrough
]
]
;
case
ParseNodeKind
:
:
ArrayExpr
:
case
ParseNodeKind
:
:
ObjectExpr
:
for
(
ParseNode
*
item
:
pn
-
>
as
<
ListNode
>
(
)
.
contents
(
)
)
{
if
(
!
checkSideEffects
(
item
answer
)
)
{
return
false
;
}
if
(
*
answer
)
{
return
true
;
}
}
return
true
;
case
ParseNodeKind
:
:
BitOrExpr
:
case
ParseNodeKind
:
:
BitXorExpr
:
case
ParseNodeKind
:
:
BitAndExpr
:
case
ParseNodeKind
:
:
EqExpr
:
case
ParseNodeKind
:
:
NeExpr
:
case
ParseNodeKind
:
:
LtExpr
:
case
ParseNodeKind
:
:
LeExpr
:
case
ParseNodeKind
:
:
GtExpr
:
case
ParseNodeKind
:
:
GeExpr
:
case
ParseNodeKind
:
:
InstanceOfExpr
:
case
ParseNodeKind
:
:
InExpr
:
case
ParseNodeKind
:
:
PrivateInExpr
:
case
ParseNodeKind
:
:
LshExpr
:
case
ParseNodeKind
:
:
RshExpr
:
case
ParseNodeKind
:
:
UrshExpr
:
case
ParseNodeKind
:
:
AddExpr
:
case
ParseNodeKind
:
:
SubExpr
:
case
ParseNodeKind
:
:
MulExpr
:
case
ParseNodeKind
:
:
DivExpr
:
case
ParseNodeKind
:
:
ModExpr
:
case
ParseNodeKind
:
:
PowExpr
:
MOZ_ASSERT
(
pn
-
>
as
<
ListNode
>
(
)
.
count
(
)
>
=
2
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
PropertyDefinition
:
case
ParseNodeKind
:
:
Case
:
{
BinaryNode
*
node
=
&
pn
-
>
as
<
BinaryNode
>
(
)
;
if
(
!
checkSideEffects
(
node
-
>
left
(
)
answer
)
)
{
return
false
;
}
if
(
*
answer
)
{
return
true
;
}
return
checkSideEffects
(
node
-
>
right
(
)
answer
)
;
}
case
ParseNodeKind
:
:
ElemExpr
:
case
ParseNodeKind
:
:
OptionalElemExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
BinaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
PrivateMemberExpr
:
case
ParseNodeKind
:
:
OptionalPrivateMemberExpr
:
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
ImportDecl
:
case
ParseNodeKind
:
:
ExportFromStmt
:
case
ParseNodeKind
:
:
ExportDefaultStmt
:
MOZ_ASSERT
(
pn
-
>
is
<
BinaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
ExportStmt
:
MOZ_ASSERT
(
pn
-
>
is
<
UnaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
CallImportExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
BinaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
DoWhileStmt
:
case
ParseNodeKind
:
:
WhileStmt
:
case
ParseNodeKind
:
:
ForStmt
:
MOZ_ASSERT
(
pn
-
>
is
<
BinaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
VarStmt
:
case
ParseNodeKind
:
:
ConstDecl
:
case
ParseNodeKind
:
:
LetDecl
:
MOZ_ASSERT
(
pn
-
>
is
<
ListNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
IfStmt
:
case
ParseNodeKind
:
:
ConditionalExpr
:
{
TernaryNode
*
node
=
&
pn
-
>
as
<
TernaryNode
>
(
)
;
if
(
!
checkSideEffects
(
node
-
>
kid1
(
)
answer
)
)
{
return
false
;
}
if
(
*
answer
)
{
return
true
;
}
if
(
!
checkSideEffects
(
node
-
>
kid2
(
)
answer
)
)
{
return
false
;
}
if
(
*
answer
)
{
return
true
;
}
if
(
(
pn
=
node
-
>
kid3
(
)
)
)
{
goto
restart
;
}
return
true
;
}
case
ParseNodeKind
:
:
NewExpr
:
case
ParseNodeKind
:
:
CallExpr
:
case
ParseNodeKind
:
:
OptionalCallExpr
:
case
ParseNodeKind
:
:
TaggedTemplateExpr
:
case
ParseNodeKind
:
:
SuperCallExpr
:
MOZ_ASSERT
(
pn
-
>
is
<
BinaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
Arguments
:
MOZ_ASSERT
(
pn
-
>
is
<
ListNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
OptionalChain
:
MOZ_ASSERT
(
pn
-
>
is
<
UnaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
ClassDecl
:
MOZ_ASSERT
(
pn
-
>
is
<
ClassNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
WithStmt
:
MOZ_ASSERT
(
pn
-
>
is
<
BinaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
ReturnStmt
:
MOZ_ASSERT
(
pn
-
>
is
<
BinaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
Name
:
MOZ_ASSERT
(
pn
-
>
is
<
NameNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
Shorthand
:
MOZ_ASSERT
(
pn
-
>
is
<
BinaryNode
>
(
)
)
;
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
Function
:
MOZ_ASSERT
(
pn
-
>
is
<
FunctionNode
>
(
)
)
;
*
answer
=
false
;
return
true
;
case
ParseNodeKind
:
:
Module
:
*
answer
=
false
;
return
true
;
case
ParseNodeKind
:
:
TryStmt
:
{
TryNode
*
tryNode
=
&
pn
-
>
as
<
TryNode
>
(
)
;
if
(
!
checkSideEffects
(
tryNode
-
>
body
(
)
answer
)
)
{
return
false
;
}
if
(
*
answer
)
{
return
true
;
}
if
(
LexicalScopeNode
*
catchScope
=
tryNode
-
>
catchScope
(
)
)
{
if
(
!
checkSideEffects
(
catchScope
answer
)
)
{
return
false
;
}
if
(
*
answer
)
{
return
true
;
}
}
if
(
ParseNode
*
finallyBlock
=
tryNode
-
>
finallyBlock
(
)
)
{
if
(
!
checkSideEffects
(
finallyBlock
answer
)
)
{
return
false
;
}
}
return
true
;
}
case
ParseNodeKind
:
:
Catch
:
{
BinaryNode
*
catchClause
=
&
pn
-
>
as
<
BinaryNode
>
(
)
;
if
(
ParseNode
*
name
=
catchClause
-
>
left
(
)
)
{
if
(
!
checkSideEffects
(
name
answer
)
)
{
return
false
;
}
if
(
*
answer
)
{
return
true
;
}
}
return
checkSideEffects
(
catchClause
-
>
right
(
)
answer
)
;
}
case
ParseNodeKind
:
:
SwitchStmt
:
{
SwitchStatement
*
switchStmt
=
&
pn
-
>
as
<
SwitchStatement
>
(
)
;
if
(
!
checkSideEffects
(
&
switchStmt
-
>
discriminant
(
)
answer
)
)
{
return
false
;
}
return
*
answer
|
|
checkSideEffects
(
&
switchStmt
-
>
lexicalForCaseList
(
)
answer
)
;
}
case
ParseNodeKind
:
:
LabelStmt
:
return
checkSideEffects
(
pn
-
>
as
<
LabeledStatement
>
(
)
.
statement
(
)
answer
)
;
case
ParseNodeKind
:
:
LexicalScope
:
return
checkSideEffects
(
pn
-
>
as
<
LexicalScopeNode
>
(
)
.
scopeBody
(
)
answer
)
;
case
ParseNodeKind
:
:
TemplateStringListExpr
:
{
ListNode
*
list
=
&
pn
-
>
as
<
ListNode
>
(
)
;
MOZ_ASSERT
(
!
list
-
>
empty
(
)
)
;
MOZ_ASSERT
(
(
list
-
>
count
(
)
%
2
)
=
=
1
"
template
strings
must
alternate
template
and
substitution
"
"
parts
"
)
;
*
answer
=
list
-
>
count
(
)
>
1
;
return
true
;
}
case
ParseNodeKind
:
:
ParamsBody
:
*
answer
=
true
;
return
true
;
case
ParseNodeKind
:
:
ForIn
:
case
ParseNodeKind
:
:
ForOf
:
case
ParseNodeKind
:
:
ForHead
:
case
ParseNodeKind
:
:
DefaultConstructor
:
case
ParseNodeKind
:
:
ClassBodyScope
:
case
ParseNodeKind
:
:
ClassMethod
:
case
ParseNodeKind
:
:
ClassField
:
case
ParseNodeKind
:
:
ClassNames
:
case
ParseNodeKind
:
:
StaticClassBlock
:
case
ParseNodeKind
:
:
ClassMemberList
:
case
ParseNodeKind
:
:
ImportSpecList
:
case
ParseNodeKind
:
:
ImportSpec
:
case
ParseNodeKind
:
:
ImportNamespaceSpec
:
case
ParseNodeKind
:
:
ExportBatchSpecStmt
:
case
ParseNodeKind
:
:
ExportSpecList
:
case
ParseNodeKind
:
:
ExportSpec
:
case
ParseNodeKind
:
:
ExportNamespaceSpec
:
case
ParseNodeKind
:
:
CallSiteObj
:
case
ParseNodeKind
:
:
PosHolder
:
case
ParseNodeKind
:
:
SuperBase
:
case
ParseNodeKind
:
:
PropertyNameExpr
:
MOZ_CRASH
(
"
handled
by
parent
nodes
"
)
;
case
ParseNodeKind
:
:
LastUnused
:
case
ParseNodeKind
:
:
Limit
:
MOZ_CRASH
(
"
invalid
node
kind
"
)
;
}
MOZ_CRASH
(
"
invalid
unenumerated
ParseNodeKind
value
encountered
in
"
"
BytecodeEmitter
:
:
checkSideEffects
"
)
;
}
bool
BytecodeEmitter
:
:
isInLoop
(
)
{
return
findInnermostNestableControl
<
LoopControl
>
(
)
;
}
bool
BytecodeEmitter
:
:
checkSingletonContext
(
)
{
MOZ_ASSERT_IF
(
sc
-
>
treatAsRunOnce
(
)
sc
-
>
isTopLevelContext
(
)
)
;
return
sc
-
>
treatAsRunOnce
(
)
&
&
!
isInLoop
(
)
;
}
bool
BytecodeEmitter
:
:
needsImplicitThis
(
)
{
if
(
sc
-
>
inWith
(
)
)
{
return
true
;
}
for
(
EmitterScope
*
es
=
innermostEmitterScope
(
)
;
es
;
es
=
es
-
>
enclosingInFrame
(
)
)
{
if
(
es
-
>
scope
(
this
)
.
kind
(
)
=
=
ScopeKind
:
:
With
)
{
return
true
;
}
}
return
false
;
}
size_t
BytecodeEmitter
:
:
countThisEnvironmentHops
(
)
{
unsigned
numHops
=
0
;
for
(
BytecodeEmitter
*
current
=
this
;
current
;
current
=
current
-
>
parent
)
{
for
(
EmitterScope
*
es
=
current
-
>
innermostEmitterScope
(
)
;
es
;
es
=
es
-
>
enclosingInFrame
(
)
)
{
if
(
es
-
>
scope
(
current
)
.
is
<
FunctionScope
>
(
)
)
{
if
(
!
es
-
>
scope
(
current
)
.
isArrow
(
)
)
{
MOZ_ASSERT
(
es
-
>
scope
(
current
)
.
hasEnvironment
(
)
)
;
return
numHops
;
}
}
if
(
es
-
>
scope
(
current
)
.
hasEnvironment
(
)
)
{
numHops
+
+
;
}
}
}
MOZ_ASSERT
(
sc
-
>
allowSuperProperty
(
)
)
;
numHops
+
=
compilationState
.
scopeContext
.
enclosingThisEnvironmentHops
;
return
numHops
;
}
bool
BytecodeEmitter
:
:
emitThisEnvironmentCallee
(
)
{
if
(
sc
-
>
isFunctionBox
(
)
&
&
!
sc
-
>
asFunctionBox
(
)
-
>
isArrow
(
)
)
{
return
emit1
(
JSOp
:
:
Callee
)
;
}
size_t
numHops
=
countThisEnvironmentHops
(
)
;
static_assert
(
ENVCOORD_HOPS_LIMIT
-
1
<
=
UINT8_MAX
"
JSOp
:
:
EnvCallee
operand
size
should
match
ENVCOORD_HOPS_LIMIT
"
)
;
MOZ_ASSERT
(
numHops
<
ENVCOORD_HOPS_LIMIT
-
1
)
;
return
emit2
(
JSOp
:
:
EnvCallee
numHops
)
;
}
bool
BytecodeEmitter
:
:
emitSuperBase
(
)
{
if
(
!
emitThisEnvironmentCallee
(
)
)
{
return
false
;
}
return
emit1
(
JSOp
:
:
SuperBase
)
;
}
void
BytecodeEmitter
:
:
reportNeedMoreArgsError
(
ParseNode
*
pn
const
char
*
errorName
const
char
*
requiredArgs
const
char
*
pluralizer
const
ListNode
*
argsList
)
{
char
actualArgsStr
[
40
]
;
SprintfLiteral
(
actualArgsStr
"
%
u
"
argsList
-
>
count
(
)
)
;
reportError
(
pn
JSMSG_MORE_ARGS_NEEDED
errorName
requiredArgs
pluralizer
actualArgsStr
)
;
}
void
BytecodeEmitter
:
:
reportError
(
ParseNode
*
pn
unsigned
errorNumber
.
.
.
)
{
uint32_t
offset
=
pn
?
pn
-
>
pn_pos
.
begin
:
*
scriptStartOffset
;
va_list
args
;
va_start
(
args
errorNumber
)
;
parser
-
>
errorReporter
(
)
.
errorWithNotesAtVA
(
nullptr
AsVariant
(
offset
)
errorNumber
&
args
)
;
va_end
(
args
)
;
}
void
BytecodeEmitter
:
:
reportError
(
const
Maybe
<
uint32_t
>
&
maybeOffset
unsigned
errorNumber
.
.
.
)
{
uint32_t
offset
=
maybeOffset
?
*
maybeOffset
:
*
scriptStartOffset
;
va_list
args
;
va_start
(
args
errorNumber
)
;
parser
-
>
errorReporter
(
)
.
errorWithNotesAtVA
(
nullptr
AsVariant
(
offset
)
errorNumber
&
args
)
;
va_end
(
args
)
;
}
bool
BytecodeEmitter
:
:
addObjLiteralData
(
ObjLiteralWriter
&
writer
GCThingIndex
*
outIndex
)
{
if
(
!
writer
.
checkForDuplicatedNames
(
cx
)
)
{
return
false
;
}
size_t
len
=
writer
.
getCode
(
)
.
size
(
)
;
auto
*
code
=
compilationState
.
alloc
.
newArrayUninitialized
<
uint8_t
>
(
len
)
;
if
(
!
code
)
{
js
:
:
ReportOutOfMemory
(
cx
)
;
return
false
;
}
memcpy
(
code
writer
.
getCode
(
)
.
data
(
)
len
)
;
ObjLiteralIndex
objIndex
(
compilationState
.
objLiteralData
.
length
(
)
)
;
if
(
uint32_t
(
objIndex
)
>
=
TaggedScriptThingIndex
:
:
IndexLimit
)
{
ReportAllocationOverflow
(
cx
)
;
return
false
;
}
if
(
!
compilationState
.
objLiteralData
.
emplaceBack
(
code
len
writer
.
getFlags
(
)
writer
.
getPropertyCount
(
)
)
)
{
js
:
:
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
perScriptData
(
)
.
gcThingList
(
)
.
append
(
objIndex
outIndex
)
;
}
bool
BytecodeEmitter
:
:
iteratorResultShape
(
GCThingIndex
*
outShape
)
{
ObjLiteralFlags
flags
;
ObjLiteralWriter
writer
;
writer
.
beginObject
(
flags
)
;
writer
.
setPropNameNoDuplicateCheck
(
parserAtoms
(
)
TaggedParserAtomIndex
:
:
WellKnown
:
:
value
(
)
)
;
if
(
!
writer
.
propWithUndefinedValue
(
cx
)
)
{
return
false
;
}
writer
.
setPropNameNoDuplicateCheck
(
parserAtoms
(
)
TaggedParserAtomIndex
:
:
WellKnown
:
:
done
(
)
)
;
if
(
!
writer
.
propWithUndefinedValue
(
cx
)
)
{
return
false
;
}
return
addObjLiteralData
(
writer
outShape
)
;
}
bool
BytecodeEmitter
:
:
emitPrepareIteratorResult
(
)
{
GCThingIndex
shape
;
if
(
!
iteratorResultShape
(
&
shape
)
)
{
return
false
;
}
return
emitGCIndexOp
(
JSOp
:
:
NewObject
shape
)
;
}
bool
BytecodeEmitter
:
:
emitFinishIteratorResult
(
bool
done
)
{
if
(
!
emitAtomOp
(
JSOp
:
:
InitProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
value
(
)
)
)
{
return
false
;
}
if
(
!
emit1
(
done
?
JSOp
:
:
True
:
JSOp
:
:
False
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
InitProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
done
(
)
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitGetNameAtLocation
(
TaggedParserAtomIndex
name
const
NameLocation
&
loc
)
{
NameOpEmitter
noe
(
this
name
loc
NameOpEmitter
:
:
Kind
:
:
Get
)
;
if
(
!
noe
.
emitGet
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitGetName
(
NameNode
*
name
)
{
MOZ_ASSERT
(
name
-
>
isKind
(
ParseNodeKind
:
:
Name
)
)
;
return
emitGetName
(
name
-
>
name
(
)
)
;
}
bool
BytecodeEmitter
:
:
emitGetPrivateName
(
NameNode
*
name
)
{
MOZ_ASSERT
(
name
-
>
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
return
emitGetPrivateName
(
name
-
>
name
(
)
)
;
}
bool
BytecodeEmitter
:
:
emitGetPrivateName
(
TaggedParserAtomIndex
nameAtom
)
{
NameLocation
location
=
lookupName
(
nameAtom
)
;
MOZ_ASSERT
(
location
.
kind
(
)
=
=
NameLocation
:
:
Kind
:
:
FrameSlot
|
|
location
.
kind
(
)
=
=
NameLocation
:
:
Kind
:
:
EnvironmentCoordinate
|
|
location
.
kind
(
)
=
=
NameLocation
:
:
Kind
:
:
Dynamic
|
|
location
.
kind
(
)
=
=
NameLocation
:
:
Kind
:
:
Global
)
;
return
emitGetNameAtLocation
(
nameAtom
location
)
;
}
bool
BytecodeEmitter
:
:
emitTDZCheckIfNeeded
(
TaggedParserAtomIndex
name
const
NameLocation
&
loc
ValueIsOnStack
isOnStack
)
{
MOZ_ASSERT
(
loc
.
hasKnownSlot
(
)
)
;
MOZ_ASSERT
(
loc
.
isLexical
(
)
|
|
loc
.
isPrivateMethod
(
)
|
|
loc
.
isSynthetic
(
)
)
;
if
(
parserAtoms
(
)
.
isPrivateName
(
name
)
)
{
return
true
;
}
Maybe
<
MaybeCheckTDZ
>
check
=
innermostTDZCheckCache
-
>
needsTDZCheck
(
this
name
)
;
if
(
!
check
)
{
return
false
;
}
if
(
*
check
=
=
DontCheckTDZ
)
{
return
true
;
}
if
(
isOnStack
=
=
ValueIsOnStack
:
:
No
)
{
if
(
loc
.
kind
(
)
=
=
NameLocation
:
:
Kind
:
:
FrameSlot
)
{
if
(
!
emitLocalOp
(
JSOp
:
:
GetLocal
loc
.
frameSlot
(
)
)
)
{
return
false
;
}
}
else
{
if
(
!
emitEnvCoordOp
(
JSOp
:
:
GetAliasedVar
loc
.
environmentCoordinate
(
)
)
)
{
return
false
;
}
}
}
if
(
loc
.
kind
(
)
=
=
NameLocation
:
:
Kind
:
:
FrameSlot
)
{
if
(
!
emitLocalOp
(
JSOp
:
:
CheckLexical
loc
.
frameSlot
(
)
)
)
{
return
false
;
}
}
else
{
if
(
!
emitEnvCoordOp
(
JSOp
:
:
CheckAliasedLexical
loc
.
environmentCoordinate
(
)
)
)
{
return
false
;
}
}
if
(
isOnStack
=
=
ValueIsOnStack
:
:
No
)
{
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
return
innermostTDZCheckCache
-
>
noteTDZCheck
(
this
name
DontCheckTDZ
)
;
}
bool
BytecodeEmitter
:
:
emitPropLHS
(
PropertyAccess
*
prop
)
{
MOZ_ASSERT
(
!
prop
-
>
isSuper
(
)
)
;
ParseNode
*
expr
=
&
prop
-
>
expression
(
)
;
if
(
!
expr
-
>
is
<
PropertyAccess
>
(
)
|
|
expr
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
{
return
emitTree
(
expr
)
;
}
PropertyAccess
*
pndot
=
&
expr
-
>
as
<
PropertyAccess
>
(
)
;
ParseNode
*
pnup
=
nullptr
;
ParseNode
*
pndown
;
for
(
;
;
)
{
pndown
=
&
pndot
-
>
expression
(
)
;
pndot
-
>
setExpression
(
pnup
)
;
if
(
!
pndown
-
>
is
<
PropertyAccess
>
(
)
|
|
pndown
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
{
break
;
}
pnup
=
pndot
;
pndot
=
&
pndown
-
>
as
<
PropertyAccess
>
(
)
;
}
if
(
!
emitTree
(
pndown
)
)
{
return
false
;
}
while
(
true
)
{
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
pndot
-
>
key
(
)
.
atom
(
)
)
)
{
return
false
;
}
pnup
=
pndot
-
>
maybeExpression
(
)
;
pndot
-
>
setExpression
(
pndown
)
;
pndown
=
pndot
;
if
(
!
pnup
)
{
break
;
}
pndot
=
&
pnup
-
>
as
<
PropertyAccess
>
(
)
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitPropIncDec
(
UnaryNode
*
incDec
)
{
PropertyAccess
*
prop
=
&
incDec
-
>
kid
(
)
-
>
as
<
PropertyAccess
>
(
)
;
bool
isSuper
=
prop
-
>
isSuper
(
)
;
ParseNodeKind
kind
=
incDec
-
>
getKind
(
)
;
PropOpEmitter
poe
(
this
kind
=
=
ParseNodeKind
:
:
PostIncrementExpr
?
PropOpEmitter
:
:
Kind
:
:
PostIncrement
:
kind
=
=
ParseNodeKind
:
:
PreIncrementExpr
?
PropOpEmitter
:
:
Kind
:
:
PreIncrement
:
kind
=
=
ParseNodeKind
:
:
PostDecrementExpr
?
PropOpEmitter
:
:
Kind
:
:
PostDecrement
:
PropOpEmitter
:
:
Kind
:
:
PreDecrement
isSuper
?
PropOpEmitter
:
:
ObjKind
:
:
Super
:
PropOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
poe
.
prepareForObj
(
)
)
{
return
false
;
}
if
(
isSuper
)
{
UnaryNode
*
base
=
&
prop
-
>
expression
(
)
.
as
<
UnaryNode
>
(
)
;
if
(
!
emitGetThisForSuperBase
(
base
)
)
{
return
false
;
}
}
else
{
if
(
!
emitPropLHS
(
prop
)
)
{
return
false
;
}
}
if
(
!
poe
.
emitIncDec
(
prop
-
>
key
(
)
.
atom
(
)
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitNameIncDec
(
UnaryNode
*
incDec
)
{
MOZ_ASSERT
(
incDec
-
>
kid
(
)
-
>
isKind
(
ParseNodeKind
:
:
Name
)
)
;
ParseNodeKind
kind
=
incDec
-
>
getKind
(
)
;
NameNode
*
name
=
&
incDec
-
>
kid
(
)
-
>
as
<
NameNode
>
(
)
;
NameOpEmitter
noe
(
this
name
-
>
atom
(
)
kind
=
=
ParseNodeKind
:
:
PostIncrementExpr
?
NameOpEmitter
:
:
Kind
:
:
PostIncrement
:
kind
=
=
ParseNodeKind
:
:
PreIncrementExpr
?
NameOpEmitter
:
:
Kind
:
:
PreIncrement
:
kind
=
=
ParseNodeKind
:
:
PostDecrementExpr
?
NameOpEmitter
:
:
Kind
:
:
PostDecrement
:
NameOpEmitter
:
:
Kind
:
:
PreDecrement
)
;
if
(
!
noe
.
emitIncDec
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitObjAndKey
(
ParseNode
*
exprOrSuper
ParseNode
*
key
ElemOpEmitter
&
eoe
)
{
if
(
exprOrSuper
-
>
isKind
(
ParseNodeKind
:
:
SuperBase
)
)
{
if
(
!
eoe
.
prepareForObj
(
)
)
{
return
false
;
}
UnaryNode
*
base
=
&
exprOrSuper
-
>
as
<
UnaryNode
>
(
)
;
if
(
!
emitGetThisForSuperBase
(
base
)
)
{
return
false
;
}
if
(
!
eoe
.
prepareForKey
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
key
)
)
{
return
false
;
}
return
true
;
}
if
(
!
eoe
.
prepareForObj
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
exprOrSuper
)
)
{
return
false
;
}
if
(
!
eoe
.
prepareForKey
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
key
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitElemOpBase
(
JSOp
op
)
{
if
(
!
emit1
(
op
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitElemObjAndKey
(
PropertyByValue
*
elem
bool
isSuper
ElemOpEmitter
&
eoe
)
{
MOZ_ASSERT
(
isSuper
=
=
elem
-
>
expression
(
)
.
isKind
(
ParseNodeKind
:
:
SuperBase
)
)
;
return
emitObjAndKey
(
&
elem
-
>
expression
(
)
&
elem
-
>
key
(
)
eoe
)
;
}
static
ElemOpEmitter
:
:
Kind
ConvertIncDecKind
(
ParseNodeKind
kind
)
{
switch
(
kind
)
{
case
ParseNodeKind
:
:
PostIncrementExpr
:
return
ElemOpEmitter
:
:
Kind
:
:
PostIncrement
;
case
ParseNodeKind
:
:
PreIncrementExpr
:
return
ElemOpEmitter
:
:
Kind
:
:
PreIncrement
;
case
ParseNodeKind
:
:
PostDecrementExpr
:
return
ElemOpEmitter
:
:
Kind
:
:
PostDecrement
;
case
ParseNodeKind
:
:
PreDecrementExpr
:
return
ElemOpEmitter
:
:
Kind
:
:
PreDecrement
;
default
:
MOZ_CRASH
(
"
unexpected
inc
/
dec
node
kind
"
)
;
}
}
static
PrivateOpEmitter
:
:
Kind
PrivateConvertIncDecKind
(
ParseNodeKind
kind
)
{
switch
(
kind
)
{
case
ParseNodeKind
:
:
PostIncrementExpr
:
return
PrivateOpEmitter
:
:
Kind
:
:
PostIncrement
;
case
ParseNodeKind
:
:
PreIncrementExpr
:
return
PrivateOpEmitter
:
:
Kind
:
:
PreIncrement
;
case
ParseNodeKind
:
:
PostDecrementExpr
:
return
PrivateOpEmitter
:
:
Kind
:
:
PostDecrement
;
case
ParseNodeKind
:
:
PreDecrementExpr
:
return
PrivateOpEmitter
:
:
Kind
:
:
PreDecrement
;
default
:
MOZ_CRASH
(
"
unexpected
inc
/
dec
node
kind
"
)
;
}
}
bool
BytecodeEmitter
:
:
emitElemIncDec
(
UnaryNode
*
incDec
)
{
PropertyByValue
*
elemExpr
=
&
incDec
-
>
kid
(
)
-
>
as
<
PropertyByValue
>
(
)
;
bool
isSuper
=
elemExpr
-
>
isSuper
(
)
;
MOZ_ASSERT
(
!
elemExpr
-
>
key
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
ParseNodeKind
kind
=
incDec
-
>
getKind
(
)
;
ElemOpEmitter
eoe
(
this
ConvertIncDecKind
(
kind
)
isSuper
?
ElemOpEmitter
:
:
ObjKind
:
:
Super
:
ElemOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
emitElemObjAndKey
(
elemExpr
isSuper
eoe
)
)
{
return
false
;
}
if
(
!
eoe
.
emitIncDec
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitCallIncDec
(
UnaryNode
*
incDec
)
{
MOZ_ASSERT
(
incDec
-
>
isKind
(
ParseNodeKind
:
:
PreIncrementExpr
)
|
|
incDec
-
>
isKind
(
ParseNodeKind
:
:
PostIncrementExpr
)
|
|
incDec
-
>
isKind
(
ParseNodeKind
:
:
PreDecrementExpr
)
|
|
incDec
-
>
isKind
(
ParseNodeKind
:
:
PostDecrementExpr
)
)
;
ParseNode
*
call
=
incDec
-
>
kid
(
)
;
MOZ_ASSERT
(
call
-
>
isKind
(
ParseNodeKind
:
:
CallExpr
)
)
;
if
(
!
emitTree
(
call
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
ToNumeric
)
)
{
return
false
;
}
return
emit2
(
JSOp
:
:
ThrowMsg
uint8_t
(
ThrowMsgKind
:
:
AssignToCall
)
)
;
}
bool
BytecodeEmitter
:
:
emitPrivateIncDec
(
UnaryNode
*
incDec
)
{
PrivateMemberAccess
*
privateExpr
=
&
incDec
-
>
kid
(
)
-
>
as
<
PrivateMemberAccess
>
(
)
;
ParseNodeKind
kind
=
incDec
-
>
getKind
(
)
;
PrivateOpEmitter
xoe
(
this
PrivateConvertIncDecKind
(
kind
)
privateExpr
-
>
privateName
(
)
.
name
(
)
)
;
if
(
!
emitTree
(
&
privateExpr
-
>
expression
(
)
)
)
{
return
false
;
}
if
(
!
xoe
.
emitReference
(
)
)
{
return
false
;
}
if
(
!
xoe
.
emitIncDec
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDouble
(
double
d
)
{
BytecodeOffset
offset
;
if
(
!
emitCheck
(
JSOp
:
:
Double
9
&
offset
)
)
{
return
false
;
}
jsbytecode
*
code
=
bytecodeSection
(
)
.
code
(
offset
)
;
code
[
0
]
=
jsbytecode
(
JSOp
:
:
Double
)
;
SET_INLINE_VALUE
(
code
DoubleValue
(
d
)
)
;
bytecodeSection
(
)
.
updateDepth
(
offset
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitNumberOp
(
double
dval
)
{
int32_t
ival
;
if
(
NumberIsInt32
(
dval
&
ival
)
)
{
if
(
ival
=
=
0
)
{
return
emit1
(
JSOp
:
:
Zero
)
;
}
if
(
ival
=
=
1
)
{
return
emit1
(
JSOp
:
:
One
)
;
}
if
(
(
int
)
(
int8_t
)
ival
=
=
ival
)
{
return
emit2
(
JSOp
:
:
Int8
uint8_t
(
int8_t
(
ival
)
)
)
;
}
uint32_t
u
=
uint32_t
(
ival
)
;
if
(
u
<
Bit
(
16
)
)
{
if
(
!
emitUint16Operand
(
JSOp
:
:
Uint16
u
)
)
{
return
false
;
}
}
else
if
(
u
<
Bit
(
24
)
)
{
BytecodeOffset
off
;
if
(
!
emitN
(
JSOp
:
:
Uint24
3
&
off
)
)
{
return
false
;
}
SET_UINT24
(
bytecodeSection
(
)
.
code
(
off
)
u
)
;
}
else
{
BytecodeOffset
off
;
if
(
!
emitN
(
JSOp
:
:
Int32
4
&
off
)
)
{
return
false
;
}
SET_INT32
(
bytecodeSection
(
)
.
code
(
off
)
ival
)
;
}
return
true
;
}
return
emitDouble
(
dval
)
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitSwitch
(
SwitchStatement
*
switchStmt
)
{
LexicalScopeNode
&
lexical
=
switchStmt
-
>
lexicalForCaseList
(
)
;
MOZ_ASSERT
(
lexical
.
isKind
(
ParseNodeKind
:
:
LexicalScope
)
)
;
ListNode
*
cases
=
&
lexical
.
scopeBody
(
)
-
>
as
<
ListNode
>
(
)
;
MOZ_ASSERT
(
cases
-
>
isKind
(
ParseNodeKind
:
:
StatementList
)
)
;
SwitchEmitter
se
(
this
)
;
if
(
!
se
.
emitDiscriminant
(
Some
(
switchStmt
-
>
discriminant
(
)
.
pn_pos
.
begin
)
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
&
switchStmt
-
>
discriminant
(
)
)
)
{
return
false
;
}
if
(
!
lexical
.
isEmptyScope
(
)
)
{
if
(
!
se
.
emitLexical
(
lexical
.
scopeBindings
(
)
)
)
{
return
false
;
}
if
(
cases
-
>
hasTopLevelFunctionDeclarations
(
)
)
{
for
(
ParseNode
*
item
:
cases
-
>
contents
(
)
)
{
CaseClause
*
caseClause
=
&
item
-
>
as
<
CaseClause
>
(
)
;
ListNode
*
statements
=
caseClause
-
>
statementList
(
)
;
if
(
statements
-
>
hasTopLevelFunctionDeclarations
(
)
)
{
if
(
!
emitHoistedFunctionsInList
(
statements
)
)
{
return
false
;
}
}
}
}
}
else
{
MOZ_ASSERT
(
!
cases
-
>
hasTopLevelFunctionDeclarations
(
)
)
;
}
SwitchEmitter
:
:
TableGenerator
tableGen
(
this
)
;
uint32_t
caseCount
=
cases
-
>
count
(
)
-
(
switchStmt
-
>
hasDefault
(
)
?
1
:
0
)
;
if
(
caseCount
=
=
0
)
{
tableGen
.
finish
(
0
)
;
}
else
{
for
(
ParseNode
*
item
:
cases
-
>
contents
(
)
)
{
CaseClause
*
caseClause
=
&
item
-
>
as
<
CaseClause
>
(
)
;
if
(
caseClause
-
>
isDefault
(
)
)
{
continue
;
}
ParseNode
*
caseValue
=
caseClause
-
>
caseExpression
(
)
;
if
(
caseValue
-
>
getKind
(
)
!
=
ParseNodeKind
:
:
NumberExpr
)
{
tableGen
.
setInvalid
(
)
;
break
;
}
int32_t
i
;
if
(
!
NumberEqualsInt32
(
caseValue
-
>
as
<
NumericLiteral
>
(
)
.
value
(
)
&
i
)
)
{
tableGen
.
setInvalid
(
)
;
break
;
}
if
(
!
tableGen
.
addNumber
(
i
)
)
{
return
false
;
}
}
tableGen
.
finish
(
caseCount
)
;
}
if
(
!
se
.
validateCaseCount
(
caseCount
)
)
{
return
false
;
}
bool
isTableSwitch
=
tableGen
.
isValid
(
)
;
if
(
isTableSwitch
)
{
if
(
!
se
.
emitTable
(
tableGen
)
)
{
return
false
;
}
}
else
{
if
(
!
se
.
emitCond
(
)
)
{
return
false
;
}
for
(
ParseNode
*
item
:
cases
-
>
contents
(
)
)
{
CaseClause
*
caseClause
=
&
item
-
>
as
<
CaseClause
>
(
)
;
if
(
caseClause
-
>
isDefault
(
)
)
{
continue
;
}
if
(
!
se
.
prepareForCaseValue
(
)
)
{
return
false
;
}
ParseNode
*
caseValue
=
caseClause
-
>
caseExpression
(
)
;
if
(
!
emitTree
(
caseValue
ValueUsage
:
:
WantValue
caseValue
-
>
isLiteral
(
)
?
SUPPRESS_LINENOTE
:
EMIT_LINENOTE
)
)
{
return
false
;
}
if
(
!
se
.
emitCaseJump
(
)
)
{
return
false
;
}
}
}
for
(
ParseNode
*
item
:
cases
-
>
contents
(
)
)
{
CaseClause
*
caseClause
=
&
item
-
>
as
<
CaseClause
>
(
)
;
if
(
caseClause
-
>
isDefault
(
)
)
{
if
(
!
se
.
emitDefaultBody
(
)
)
{
return
false
;
}
}
else
{
if
(
isTableSwitch
)
{
ParseNode
*
caseValue
=
caseClause
-
>
caseExpression
(
)
;
MOZ_ASSERT
(
caseValue
-
>
isKind
(
ParseNodeKind
:
:
NumberExpr
)
)
;
NumericLiteral
*
literal
=
&
caseValue
-
>
as
<
NumericLiteral
>
(
)
;
#
ifdef
DEBUG
int32_t
v
;
MOZ_ASSERT
(
mozilla
:
:
NumberEqualsInt32
(
literal
-
>
value
(
)
&
v
)
)
;
#
endif
int32_t
i
=
int32_t
(
literal
-
>
value
(
)
)
;
if
(
!
se
.
emitCaseBody
(
i
tableGen
)
)
{
return
false
;
}
}
else
{
if
(
!
se
.
emitCaseBody
(
)
)
{
return
false
;
}
}
}
if
(
!
emitTree
(
caseClause
-
>
statementList
(
)
)
)
{
return
false
;
}
}
if
(
!
se
.
emitEnd
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
allocateResumeIndex
(
BytecodeOffset
offset
uint32_t
*
resumeIndex
)
{
static
constexpr
uint32_t
MaxResumeIndex
=
BitMask
(
24
)
;
static_assert
(
MaxResumeIndex
<
uint32_t
(
AbstractGeneratorObject
:
:
RESUME_INDEX_RUNNING
)
"
resumeIndex
should
not
include
magic
AbstractGeneratorObject
"
"
resumeIndex
values
"
)
;
static_assert
(
MaxResumeIndex
<
=
INT32_MAX
/
sizeof
(
uintptr_t
)
"
resumeIndex
*
sizeof
(
uintptr_t
)
must
fit
in
an
int32
.
JIT
code
relies
"
"
on
this
when
loading
resume
entries
from
BaselineScript
"
)
;
*
resumeIndex
=
bytecodeSection
(
)
.
resumeOffsetList
(
)
.
length
(
)
;
if
(
*
resumeIndex
>
MaxResumeIndex
)
{
reportError
(
nullptr
JSMSG_TOO_MANY_RESUME_INDEXES
)
;
return
false
;
}
return
bytecodeSection
(
)
.
resumeOffsetList
(
)
.
append
(
offset
.
value
(
)
)
;
}
bool
BytecodeEmitter
:
:
allocateResumeIndexRange
(
mozilla
:
:
Span
<
BytecodeOffset
>
offsets
uint32_t
*
firstResumeIndex
)
{
*
firstResumeIndex
=
0
;
for
(
size_t
i
=
0
len
=
offsets
.
size
(
)
;
i
<
len
;
i
+
+
)
{
uint32_t
resumeIndex
;
if
(
!
allocateResumeIndex
(
offsets
[
i
]
&
resumeIndex
)
)
{
return
false
;
}
if
(
i
=
=
0
)
{
*
firstResumeIndex
=
resumeIndex
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitYieldOp
(
JSOp
op
)
{
if
(
op
=
=
JSOp
:
:
FinalYieldRval
)
{
return
emit1
(
JSOp
:
:
FinalYieldRval
)
;
}
MOZ_ASSERT
(
op
=
=
JSOp
:
:
InitialYield
|
|
op
=
=
JSOp
:
:
Yield
|
|
op
=
=
JSOp
:
:
Await
)
;
BytecodeOffset
off
;
if
(
!
emitN
(
op
3
&
off
)
)
{
return
false
;
}
if
(
op
=
=
JSOp
:
:
InitialYield
|
|
op
=
=
JSOp
:
:
Yield
)
{
bytecodeSection
(
)
.
addNumYields
(
)
;
}
uint32_t
resumeIndex
;
if
(
!
allocateResumeIndex
(
bytecodeSection
(
)
.
offset
(
)
&
resumeIndex
)
)
{
return
false
;
}
SET_RESUMEINDEX
(
bytecodeSection
(
)
.
code
(
off
)
resumeIndex
)
;
BytecodeOffset
unusedOffset
;
return
emitJumpTargetOp
(
JSOp
:
:
AfterYield
&
unusedOffset
)
;
}
bool
BytecodeEmitter
:
:
emitPushResumeKind
(
GeneratorResumeKind
kind
)
{
return
emit2
(
JSOp
:
:
ResumeKind
uint8_t
(
kind
)
)
;
}
bool
BytecodeEmitter
:
:
emitSetThis
(
BinaryNode
*
setThisNode
)
{
MOZ_ASSERT
(
setThisNode
-
>
isKind
(
ParseNodeKind
:
:
SetThis
)
)
;
MOZ_ASSERT
(
setThisNode
-
>
left
(
)
-
>
isKind
(
ParseNodeKind
:
:
Name
)
)
;
auto
name
=
setThisNode
-
>
left
(
)
-
>
as
<
NameNode
>
(
)
.
name
(
)
;
NameLocation
loc
=
lookupName
(
name
)
;
NameLocation
lexicalLoc
;
if
(
loc
.
kind
(
)
=
=
NameLocation
:
:
Kind
:
:
FrameSlot
)
{
lexicalLoc
=
NameLocation
:
:
FrameSlot
(
BindingKind
:
:
Let
loc
.
frameSlot
(
)
)
;
}
else
if
(
loc
.
kind
(
)
=
=
NameLocation
:
:
Kind
:
:
EnvironmentCoordinate
)
{
EnvironmentCoordinate
coord
=
loc
.
environmentCoordinate
(
)
;
uint8_t
hops
=
AssertedCast
<
uint8_t
>
(
coord
.
hops
(
)
)
;
lexicalLoc
=
NameLocation
:
:
EnvironmentCoordinate
(
BindingKind
:
:
Let
hops
coord
.
slot
(
)
)
;
}
else
{
MOZ_ASSERT
(
loc
.
kind
(
)
=
=
NameLocation
:
:
Kind
:
:
Dynamic
)
;
lexicalLoc
=
loc
;
}
NameOpEmitter
noe
(
this
name
lexicalLoc
NameOpEmitter
:
:
Kind
:
:
Initialize
)
;
if
(
!
noe
.
prepareForRhs
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
setThisNode
-
>
right
(
)
)
)
{
return
false
;
}
if
(
!
emitGetName
(
name
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
CheckThisReinit
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
noe
.
emitAssignment
(
)
)
{
return
false
;
}
if
(
!
emitInitializeInstanceMembers
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
defineHoistedTopLevelFunctions
(
ParseNode
*
body
)
{
MOZ_ASSERT
(
inPrologue
(
)
)
;
MOZ_ASSERT
(
sc
-
>
isGlobalContext
(
)
|
|
(
sc
-
>
isEvalContext
(
)
&
&
!
sc
-
>
strict
(
)
)
)
;
MOZ_ASSERT
(
body
-
>
is
<
LexicalScopeNode
>
(
)
|
|
body
-
>
is
<
ListNode
>
(
)
)
;
if
(
body
-
>
is
<
LexicalScopeNode
>
(
)
)
{
body
=
body
-
>
as
<
LexicalScopeNode
>
(
)
.
scopeBody
(
)
;
MOZ_ASSERT
(
body
-
>
is
<
ListNode
>
(
)
)
;
}
if
(
!
body
-
>
as
<
ListNode
>
(
)
.
hasTopLevelFunctionDeclarations
(
)
)
{
return
true
;
}
return
emitHoistedFunctionsInList
(
&
body
-
>
as
<
ListNode
>
(
)
)
;
}
bool
BytecodeEmitter
:
:
emitDeclarationInstantiation
(
ParseNode
*
body
)
{
if
(
sc
-
>
isModuleContext
(
)
)
{
return
true
;
}
if
(
sc
-
>
isEvalContext
(
)
&
&
sc
-
>
strict
(
)
)
{
return
true
;
}
if
(
sc
-
>
isGlobalContext
(
)
)
{
if
(
!
sc
-
>
asGlobalContext
(
)
-
>
bindings
)
{
return
true
;
}
}
else
{
MOZ_ASSERT
(
sc
-
>
isEvalContext
(
)
)
;
if
(
!
sc
-
>
asEvalContext
(
)
-
>
bindings
)
{
return
true
;
}
}
#
if
DEBUG
for
(
const
auto
&
thing
:
perScriptData
(
)
.
gcThingList
(
)
.
objects
(
)
)
{
MOZ_ASSERT
(
thing
.
isEmptyGlobalScope
(
)
|
|
thing
.
isScope
(
)
)
;
}
#
endif
if
(
!
defineHoistedTopLevelFunctions
(
body
)
)
{
return
false
;
}
MOZ_ASSERT
(
perScriptData
(
)
.
gcThingList
(
)
.
length
(
)
>
0
)
;
GCThingIndex
lastFun
=
GCThingIndex
(
perScriptData
(
)
.
gcThingList
(
)
.
length
(
)
-
1
)
;
#
if
DEBUG
for
(
const
auto
&
thing
:
perScriptData
(
)
.
gcThingList
(
)
.
objects
(
)
)
{
MOZ_ASSERT
(
thing
.
isEmptyGlobalScope
(
)
|
|
thing
.
isScope
(
)
|
|
thing
.
isFunction
(
)
)
;
}
#
endif
if
(
emitterMode
=
=
BytecodeEmitter
:
:
EmitterMode
:
:
Normal
)
{
if
(
!
emitGCIndexOp
(
JSOp
:
:
GlobalOrEvalDeclInstantiation
lastFun
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitScript
(
ParseNode
*
body
)
{
AutoFrontendTraceLog
traceLog
(
cx
TraceLogger_BytecodeEmission
parser
-
>
errorReporter
(
)
body
)
;
setScriptStartOffsetIfUnset
(
body
-
>
pn_pos
.
begin
)
;
MOZ_ASSERT
(
inPrologue
(
)
)
;
TDZCheckCache
tdzCache
(
this
)
;
EmitterScope
emitterScope
(
this
)
;
Maybe
<
AsyncEmitter
>
topLevelAwait
;
if
(
sc
-
>
isGlobalContext
(
)
)
{
if
(
!
emitterScope
.
enterGlobal
(
this
sc
-
>
asGlobalContext
(
)
)
)
{
return
false
;
}
}
else
if
(
sc
-
>
isEvalContext
(
)
)
{
if
(
!
emitterScope
.
enterEval
(
this
sc
-
>
asEvalContext
(
)
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
sc
-
>
isModuleContext
(
)
)
;
if
(
!
emitterScope
.
enterModule
(
this
sc
-
>
asModuleContext
(
)
)
)
{
return
false
;
}
if
(
sc
-
>
asModuleContext
(
)
-
>
isAsync
(
)
)
{
topLevelAwait
.
emplace
(
this
)
;
}
}
setFunctionBodyEndPos
(
body
-
>
pn_pos
.
end
)
;
bool
isSloppyEval
=
sc
-
>
isEvalContext
(
)
&
&
!
sc
-
>
strict
(
)
;
if
(
isSloppyEval
&
&
body
-
>
is
<
LexicalScopeNode
>
(
)
&
&
!
body
-
>
as
<
LexicalScopeNode
>
(
)
.
isEmptyScope
(
)
)
{
EmitterScope
lexicalEmitterScope
(
this
)
;
LexicalScopeNode
*
scope
=
&
body
-
>
as
<
LexicalScopeNode
>
(
)
;
if
(
!
lexicalEmitterScope
.
enterLexical
(
this
ScopeKind
:
:
Lexical
scope
-
>
scopeBindings
(
)
)
)
{
return
false
;
}
if
(
!
emitDeclarationInstantiation
(
scope
-
>
scopeBody
(
)
)
)
{
return
false
;
}
switchToMain
(
)
;
ParseNode
*
scopeBody
=
scope
-
>
scopeBody
(
)
;
if
(
!
emitLexicalScopeBody
(
scopeBody
EMIT_LINENOTE
)
)
{
return
false
;
}
if
(
!
updateSourceCoordNotes
(
scopeBody
-
>
pn_pos
.
end
)
)
{
return
false
;
}
if
(
!
lexicalEmitterScope
.
leave
(
this
)
)
{
return
false
;
}
}
else
{
if
(
!
emitDeclarationInstantiation
(
body
)
)
{
return
false
;
}
if
(
topLevelAwait
)
{
if
(
!
topLevelAwait
-
>
prepareForModule
(
)
)
{
return
false
;
}
}
switchToMain
(
)
;
if
(
topLevelAwait
)
{
if
(
!
topLevelAwait
-
>
prepareForBody
(
)
)
{
return
false
;
}
}
if
(
!
emitTree
(
body
)
)
{
return
false
;
}
if
(
!
updateSourceCoordNotes
(
body
-
>
pn_pos
.
end
)
)
{
return
false
;
}
}
if
(
topLevelAwait
)
{
if
(
!
topLevelAwait
-
>
emitEnd
(
)
)
{
return
false
;
}
}
if
(
!
markSimpleBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitReturnRval
(
)
)
{
return
false
;
}
if
(
!
emitterScope
.
leave
(
this
)
)
{
return
false
;
}
if
(
!
NameFunctions
(
cx
parserAtoms
(
)
body
)
)
{
return
false
;
}
return
intoScriptStencil
(
CompilationStencil
:
:
TopLevelIndex
)
;
}
js
:
:
UniquePtr
<
ImmutableScriptData
>
BytecodeEmitter
:
:
createImmutableScriptData
(
JSContext
*
cx
)
{
uint32_t
nslots
;
if
(
!
getNslots
(
&
nslots
)
)
{
return
nullptr
;
}
bool
isFunction
=
sc
-
>
isFunctionBox
(
)
;
uint16_t
funLength
=
isFunction
?
sc
-
>
asFunctionBox
(
)
-
>
length
(
)
:
0
;
return
ImmutableScriptData
:
:
new_
(
cx
mainOffset
(
)
maxFixedSlots
nslots
bodyScopeIndex
bytecodeSection
(
)
.
numICEntries
(
)
isFunction
funLength
bytecodeSection
(
)
.
code
(
)
bytecodeSection
(
)
.
notes
(
)
bytecodeSection
(
)
.
resumeOffsetList
(
)
.
span
(
)
bytecodeSection
(
)
.
scopeNoteList
(
)
.
span
(
)
bytecodeSection
(
)
.
tryNoteList
(
)
.
span
(
)
)
;
}
bool
BytecodeEmitter
:
:
getNslots
(
uint32_t
*
nslots
)
{
uint64_t
nslots64
=
maxFixedSlots
+
static_cast
<
uint64_t
>
(
bytecodeSection
(
)
.
maxStackDepth
(
)
)
;
if
(
nslots64
>
UINT32_MAX
)
{
reportError
(
nullptr
JSMSG_NEED_DIET
js_script_str
)
;
return
false
;
}
*
nslots
=
nslots64
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitFunctionScript
(
FunctionNode
*
funNode
)
{
MOZ_ASSERT
(
inPrologue
(
)
)
;
ListNode
*
paramsBody
=
&
funNode
-
>
body
(
)
-
>
as
<
ListNode
>
(
)
;
MOZ_ASSERT
(
paramsBody
-
>
isKind
(
ParseNodeKind
:
:
ParamsBody
)
)
;
FunctionBox
*
funbox
=
sc
-
>
asFunctionBox
(
)
;
AutoFrontendTraceLog
traceLog
(
cx
TraceLogger_BytecodeEmission
parser
-
>
errorReporter
(
)
funbox
)
;
setScriptStartOffsetIfUnset
(
paramsBody
-
>
pn_pos
.
begin
)
;
FunctionScriptEmitter
fse
(
this
funbox
Some
(
paramsBody
-
>
pn_pos
.
begin
)
Some
(
paramsBody
-
>
pn_pos
.
end
)
)
;
if
(
!
fse
.
prepareForParameters
(
)
)
{
return
false
;
}
if
(
!
emitFunctionFormalParameters
(
paramsBody
)
)
{
return
false
;
}
if
(
!
fse
.
prepareForBody
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
paramsBody
-
>
last
(
)
)
)
{
return
false
;
}
if
(
!
fse
.
emitEndBody
(
)
)
{
return
false
;
}
if
(
funbox
-
>
index
(
)
=
=
CompilationStencil
:
:
TopLevelIndex
)
{
if
(
!
NameFunctions
(
cx
parserAtoms
(
)
funNode
)
)
{
return
false
;
}
}
return
fse
.
intoStencil
(
)
;
}
bool
BytecodeEmitter
:
:
emitDestructuringLHSRef
(
ParseNode
*
target
size_t
*
emitted
)
{
*
emitted
=
0
;
if
(
target
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
target
=
target
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
;
}
else
if
(
target
-
>
isKind
(
ParseNodeKind
:
:
AssignExpr
)
)
{
target
=
target
-
>
as
<
AssignmentNode
>
(
)
.
left
(
)
;
}
if
(
target
-
>
isKind
(
ParseNodeKind
:
:
Name
)
|
|
target
-
>
isKind
(
ParseNodeKind
:
:
ArrayExpr
)
|
|
target
-
>
isKind
(
ParseNodeKind
:
:
ObjectExpr
)
)
{
return
true
;
}
#
ifdef
DEBUG
int
depth
=
bytecodeSection
(
)
.
stackDepth
(
)
;
#
endif
switch
(
target
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
DotExpr
:
{
PropertyAccess
*
prop
=
&
target
-
>
as
<
PropertyAccess
>
(
)
;
bool
isSuper
=
prop
-
>
isSuper
(
)
;
PropOpEmitter
poe
(
this
PropOpEmitter
:
:
Kind
:
:
SimpleAssignment
isSuper
?
PropOpEmitter
:
:
ObjKind
:
:
Super
:
PropOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
poe
.
prepareForObj
(
)
)
{
return
false
;
}
if
(
isSuper
)
{
UnaryNode
*
base
=
&
prop
-
>
expression
(
)
.
as
<
UnaryNode
>
(
)
;
if
(
!
emitGetThisForSuperBase
(
base
)
)
{
return
false
;
}
*
emitted
=
2
;
}
else
{
if
(
!
emitTree
(
&
prop
-
>
expression
(
)
)
)
{
return
false
;
}
*
emitted
=
1
;
}
if
(
!
poe
.
prepareForRhs
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
ElemExpr
:
{
PropertyByValue
*
elem
=
&
target
-
>
as
<
PropertyByValue
>
(
)
;
bool
isSuper
=
elem
-
>
isSuper
(
)
;
MOZ_ASSERT
(
!
elem
-
>
key
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
ElemOpEmitter
eoe
(
this
ElemOpEmitter
:
:
Kind
:
:
SimpleAssignment
isSuper
?
ElemOpEmitter
:
:
ObjKind
:
:
Super
:
ElemOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
emitElemObjAndKey
(
elem
isSuper
eoe
)
)
{
return
false
;
}
if
(
isSuper
)
{
*
emitted
=
3
;
}
else
{
*
emitted
=
2
;
}
if
(
!
eoe
.
prepareForRhs
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
PrivateMemberExpr
:
{
PrivateMemberAccess
*
privateExpr
=
&
target
-
>
as
<
PrivateMemberAccess
>
(
)
;
PrivateOpEmitter
xoe
(
this
PrivateOpEmitter
:
:
Kind
:
:
SimpleAssignment
privateExpr
-
>
privateName
(
)
.
name
(
)
)
;
if
(
!
emitTree
(
&
privateExpr
-
>
expression
(
)
)
)
{
return
false
;
}
if
(
!
xoe
.
emitReference
(
)
)
{
return
false
;
}
*
emitted
=
xoe
.
numReferenceSlots
(
)
;
break
;
}
case
ParseNodeKind
:
:
CallExpr
:
MOZ_ASSERT_UNREACHABLE
(
"
Parser
:
:
reportIfNotValidSimpleAssignmentTarget
"
"
rejects
function
calls
as
assignment
"
"
targets
in
destructuring
assignments
"
)
;
break
;
default
:
MOZ_CRASH
(
"
emitDestructuringLHSRef
:
bad
lhs
kind
"
)
;
}
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
=
=
depth
+
int
(
*
emitted
)
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitSetOrInitializeDestructuring
(
ParseNode
*
target
DestructuringFlavor
flav
)
{
if
(
target
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
target
=
target
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
;
}
else
if
(
target
-
>
isKind
(
ParseNodeKind
:
:
AssignExpr
)
)
{
target
=
target
-
>
as
<
AssignmentNode
>
(
)
.
left
(
)
;
}
switch
(
target
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
ArrayExpr
:
case
ParseNodeKind
:
:
ObjectExpr
:
if
(
!
emitDestructuringOps
(
&
target
-
>
as
<
ListNode
>
(
)
flav
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
Name
:
{
auto
name
=
target
-
>
as
<
NameNode
>
(
)
.
name
(
)
;
NameLocation
loc
=
lookupName
(
name
)
;
NameOpEmitter
:
:
Kind
kind
;
switch
(
flav
)
{
case
DestructuringFlavor
:
:
Declaration
:
kind
=
NameOpEmitter
:
:
Kind
:
:
Initialize
;
break
;
case
DestructuringFlavor
:
:
Assignment
:
kind
=
NameOpEmitter
:
:
Kind
:
:
SimpleAssignment
;
break
;
}
NameOpEmitter
noe
(
this
name
loc
kind
)
;
if
(
!
noe
.
prepareForRhs
(
)
)
{
return
false
;
}
if
(
noe
.
emittedBindOp
(
)
)
{
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
}
else
{
}
if
(
!
noe
.
emitAssignment
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
DotExpr
:
{
PropertyAccess
*
prop
=
&
target
-
>
as
<
PropertyAccess
>
(
)
;
bool
isSuper
=
prop
-
>
isSuper
(
)
;
PropOpEmitter
poe
(
this
PropOpEmitter
:
:
Kind
:
:
SimpleAssignment
isSuper
?
PropOpEmitter
:
:
ObjKind
:
:
Super
:
PropOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
poe
.
skipObjAndRhs
(
)
)
{
return
false
;
}
if
(
!
poe
.
emitAssignment
(
prop
-
>
key
(
)
.
atom
(
)
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
ElemExpr
:
{
PropertyByValue
*
elem
=
&
target
-
>
as
<
PropertyByValue
>
(
)
;
bool
isSuper
=
elem
-
>
isSuper
(
)
;
MOZ_ASSERT
(
!
elem
-
>
key
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
ElemOpEmitter
eoe
(
this
ElemOpEmitter
:
:
Kind
:
:
SimpleAssignment
isSuper
?
ElemOpEmitter
:
:
ObjKind
:
:
Super
:
ElemOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
eoe
.
skipObjAndKeyAndRhs
(
)
)
{
return
false
;
}
if
(
!
eoe
.
emitAssignment
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
PrivateMemberExpr
:
{
PrivateMemberAccess
*
privateExpr
=
&
target
-
>
as
<
PrivateMemberAccess
>
(
)
;
PrivateOpEmitter
xoe
(
this
PrivateOpEmitter
:
:
Kind
:
:
SimpleAssignment
privateExpr
-
>
privateName
(
)
.
name
(
)
)
;
if
(
!
xoe
.
skipReference
(
)
)
{
return
false
;
}
if
(
!
xoe
.
emitAssignment
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
CallExpr
:
MOZ_ASSERT_UNREACHABLE
(
"
Parser
:
:
reportIfNotValidSimpleAssignmentTarget
"
"
rejects
function
calls
as
assignment
"
"
targets
in
destructuring
assignments
"
)
;
break
;
default
:
MOZ_CRASH
(
"
emitSetOrInitializeDestructuring
:
bad
lhs
kind
"
)
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitIteratorNext
(
const
Maybe
<
uint32_t
>
&
callSourceCoordOffset
IteratorKind
iterKind
bool
allowSelfHosted
)
{
MOZ_ASSERT
(
allowSelfHosted
|
|
emitterMode
!
=
BytecodeEmitter
:
:
SelfHosting
|
|
(
sc
-
>
isModuleContext
(
)
&
&
sc
-
>
asModuleContext
(
)
-
>
isAsync
(
)
)
"
.
next
(
)
iteration
is
prohibited
in
non
-
module
self
-
hosted
code
"
"
because
it
"
"
can
run
user
-
modifiable
iteration
code
"
)
;
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
>
=
2
)
;
if
(
!
emitCall
(
JSOp
:
:
Call
0
callSourceCoordOffset
)
)
{
return
false
;
}
if
(
iterKind
=
=
IteratorKind
:
:
Async
)
{
if
(
!
emitAwaitInInnermostScope
(
)
)
{
return
false
;
}
}
if
(
!
emitCheckIsObj
(
CheckIsObjectKind
:
:
IteratorNext
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitPushNotUndefinedOrNull
(
)
{
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
>
0
)
;
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
StrictNe
)
)
{
return
false
;
}
JumpList
undefinedOrNullJump
;
if
(
!
emitJump
(
JSOp
:
:
And
&
undefinedOrNullJump
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Null
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
StrictNe
)
)
{
return
false
;
}
if
(
!
emitJumpTargetAndPatch
(
undefinedOrNullJump
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitIteratorCloseInScope
(
EmitterScope
&
currentScope
IteratorKind
iterKind
CompletionKind
completionKind
bool
allowSelfHosted
)
{
MOZ_ASSERT
(
allowSelfHosted
|
|
emitterMode
!
=
BytecodeEmitter
:
:
SelfHosting
"
.
close
(
)
on
iterators
is
prohibited
in
self
-
hosted
code
because
it
"
"
can
run
user
-
modifiable
iteration
code
"
)
;
Maybe
<
TryEmitter
>
tryCatch
;
if
(
completionKind
=
=
CompletionKind
:
:
Throw
)
{
tryCatch
.
emplace
(
this
TryEmitter
:
:
Kind
:
:
TryCatch
TryEmitter
:
:
ControlKind
:
:
NonSyntactic
)
;
if
(
!
tryCatch
-
>
emitTry
(
)
)
{
return
false
;
}
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
return_
(
)
)
)
{
return
false
;
}
InternalIfEmitter
ifReturnMethodIsDefined
(
this
)
;
if
(
!
emitPushNotUndefinedOrNull
(
)
)
{
return
false
;
}
if
(
!
ifReturnMethodIsDefined
.
emitThenElse
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
if
(
!
emitCall
(
JSOp
:
:
Call
0
)
)
{
return
false
;
}
if
(
iterKind
=
=
IteratorKind
:
:
Async
)
{
if
(
completionKind
!
=
CompletionKind
:
:
Throw
)
{
if
(
!
emit1
(
JSOp
:
:
GetRval
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
}
if
(
!
emitAwaitInScope
(
currentScope
)
)
{
return
false
;
}
if
(
completionKind
!
=
CompletionKind
:
:
Throw
)
{
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
SetRval
)
)
{
return
false
;
}
}
}
if
(
completionKind
!
=
CompletionKind
:
:
Throw
)
{
if
(
!
emitCheckIsObj
(
CheckIsObjectKind
:
:
IteratorReturn
)
)
{
return
false
;
}
}
if
(
!
ifReturnMethodIsDefined
.
emitElse
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
ifReturnMethodIsDefined
.
emitEnd
(
)
)
{
return
false
;
}
if
(
completionKind
=
=
CompletionKind
:
:
Throw
)
{
if
(
!
tryCatch
-
>
emitCatch
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
tryCatch
-
>
emitEnd
(
)
)
{
return
false
;
}
}
return
emit1
(
JSOp
:
:
Pop
)
;
}
template
<
typename
InnerEmitter
>
bool
BytecodeEmitter
:
:
wrapWithDestructuringTryNote
(
int32_t
iterDepth
InnerEmitter
emitter
)
{
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
>
=
iterDepth
)
;
if
(
!
emit1
(
JSOp
:
:
TryDestructuring
)
)
{
return
false
;
}
BytecodeOffset
start
=
bytecodeSection
(
)
.
offset
(
)
;
if
(
!
emitter
(
this
)
)
{
return
false
;
}
BytecodeOffset
end
=
bytecodeSection
(
)
.
offset
(
)
;
if
(
start
!
=
end
)
{
return
addTryNote
(
TryNoteKind
:
:
Destructuring
iterDepth
start
end
)
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDefault
(
ParseNode
*
defaultExpr
ParseNode
*
pattern
)
{
DefaultEmitter
de
(
this
)
;
if
(
!
de
.
prepareForDefault
(
)
)
{
return
false
;
}
if
(
!
emitInitializer
(
defaultExpr
pattern
)
)
{
return
false
;
}
if
(
!
de
.
emitEnd
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitAnonymousFunctionWithName
(
ParseNode
*
node
TaggedParserAtomIndex
name
)
{
MOZ_ASSERT
(
node
-
>
isDirectRHSAnonFunction
(
)
)
;
if
(
node
-
>
is
<
FunctionNode
>
(
)
)
{
if
(
!
setFunName
(
node
-
>
as
<
FunctionNode
>
(
)
.
funbox
(
)
name
)
)
{
return
false
;
}
return
emitTree
(
node
)
;
}
MOZ_ASSERT
(
node
-
>
is
<
ClassNode
>
(
)
)
;
return
emitClass
(
&
node
-
>
as
<
ClassNode
>
(
)
ClassNameKind
:
:
InferredName
name
)
;
}
bool
BytecodeEmitter
:
:
emitAnonymousFunctionWithComputedName
(
ParseNode
*
node
FunctionPrefixKind
prefixKind
)
{
MOZ_ASSERT
(
node
-
>
isDirectRHSAnonFunction
(
)
)
;
if
(
node
-
>
is
<
FunctionNode
>
(
)
)
{
if
(
!
emitTree
(
node
)
)
{
return
false
;
}
if
(
!
emitDupAt
(
1
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
SetFunName
uint8_t
(
prefixKind
)
)
)
{
return
false
;
}
return
true
;
}
MOZ_ASSERT
(
node
-
>
is
<
ClassNode
>
(
)
)
;
MOZ_ASSERT
(
prefixKind
=
=
FunctionPrefixKind
:
:
None
)
;
return
emitClass
(
&
node
-
>
as
<
ClassNode
>
(
)
ClassNameKind
:
:
ComputedName
)
;
}
bool
BytecodeEmitter
:
:
setFunName
(
FunctionBox
*
funbox
TaggedParserAtomIndex
name
)
{
if
(
funbox
-
>
hasInferredName
(
)
)
{
MOZ_ASSERT
(
!
funbox
-
>
emitBytecode
)
;
MOZ_ASSERT
(
funbox
-
>
displayAtom
(
)
=
=
name
)
;
return
true
;
}
funbox
-
>
setInferredName
(
name
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitInitializer
(
ParseNode
*
initializer
ParseNode
*
pattern
)
{
if
(
initializer
-
>
isDirectRHSAnonFunction
(
)
)
{
MOZ_ASSERT
(
!
pattern
-
>
isInParens
(
)
)
;
auto
name
=
pattern
-
>
as
<
NameNode
>
(
)
.
name
(
)
;
if
(
!
emitAnonymousFunctionWithName
(
initializer
name
)
)
{
return
false
;
}
}
else
{
if
(
!
emitTree
(
initializer
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDestructuringOpsArray
(
ListNode
*
pattern
DestructuringFlavor
flav
)
{
MOZ_ASSERT
(
pattern
-
>
isKind
(
ParseNodeKind
:
:
ArrayExpr
)
)
;
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
!
=
0
)
;
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emitIterator
(
)
)
{
return
false
;
}
if
(
!
pattern
-
>
head
(
)
)
{
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
return
emitIteratorCloseInInnermostScope
(
)
;
}
if
(
!
emit1
(
JSOp
:
:
False
)
)
{
return
false
;
}
int32_t
tryNoteDepth
=
bytecodeSection
(
)
.
stackDepth
(
)
;
for
(
ParseNode
*
member
:
pattern
-
>
contents
(
)
)
{
bool
isFirst
=
member
=
=
pattern
-
>
head
(
)
;
DebugOnly
<
bool
>
hasNext
=
!
!
member
-
>
pn_next
;
size_t
emitted
=
0
;
ParseNode
*
lhsPattern
=
member
;
if
(
lhsPattern
-
>
isKind
(
ParseNodeKind
:
:
AssignExpr
)
)
{
lhsPattern
=
lhsPattern
-
>
as
<
AssignmentNode
>
(
)
.
left
(
)
;
}
bool
isElision
=
lhsPattern
-
>
isKind
(
ParseNodeKind
:
:
Elision
)
;
if
(
!
isElision
)
{
auto
emitLHSRef
=
[
lhsPattern
&
emitted
]
(
BytecodeEmitter
*
bce
)
{
return
bce
-
>
emitDestructuringLHSRef
(
lhsPattern
&
emitted
)
;
}
;
if
(
!
wrapWithDestructuringTryNote
(
tryNoteDepth
emitLHSRef
)
)
{
return
false
;
}
}
if
(
emitted
)
{
if
(
!
emitPickN
(
emitted
)
)
{
return
false
;
}
}
if
(
isFirst
)
{
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
if
(
member
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
InternalIfEmitter
ifThenElse
(
this
)
;
if
(
!
isFirst
)
{
if
(
!
ifThenElse
.
emitThenElse
(
)
)
{
return
false
;
}
if
(
!
emitUint32Operand
(
JSOp
:
:
NewArray
0
)
)
{
return
false
;
}
if
(
!
ifThenElse
.
emitElse
(
)
)
{
return
false
;
}
}
if
(
!
emitDupAt
(
emitted
+
1
2
)
)
{
return
false
;
}
if
(
!
emitUint32Operand
(
JSOp
:
:
NewArray
0
)
)
{
return
false
;
}
if
(
!
emitNumberOp
(
0
)
)
{
return
false
;
}
if
(
!
emitSpread
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
isFirst
)
{
if
(
!
ifThenElse
.
emitEnd
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
ifThenElse
.
pushed
(
)
=
=
1
)
;
}
if
(
!
emit1
(
JSOp
:
:
True
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Unpick
emitted
+
1
)
)
{
return
false
;
}
auto
emitAssignment
=
[
member
flav
]
(
BytecodeEmitter
*
bce
)
{
return
bce
-
>
emitSetOrInitializeDestructuring
(
member
flav
)
;
}
;
if
(
!
wrapWithDestructuringTryNote
(
tryNoteDepth
emitAssignment
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
hasNext
)
;
break
;
}
ParseNode
*
pndefault
=
nullptr
;
if
(
member
-
>
isKind
(
ParseNodeKind
:
:
AssignExpr
)
)
{
pndefault
=
member
-
>
as
<
AssignmentNode
>
(
)
.
right
(
)
;
}
MOZ_ASSERT
(
!
member
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
;
InternalIfEmitter
ifAlreadyDone
(
this
)
;
if
(
!
isFirst
)
{
if
(
!
ifAlreadyDone
.
emitThenElse
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
NopDestructuring
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
True
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Unpick
emitted
+
1
)
)
{
return
false
;
}
if
(
!
ifAlreadyDone
.
emitElse
(
)
)
{
return
false
;
}
}
if
(
!
emitDupAt
(
emitted
+
1
2
)
)
{
return
false
;
}
if
(
!
emitIteratorNext
(
Some
(
pattern
-
>
pn_pos
.
begin
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
done
(
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Unpick
emitted
+
2
)
)
{
return
false
;
}
InternalIfEmitter
ifDone
(
this
)
;
if
(
!
ifDone
.
emitThenElse
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
NopDestructuring
)
)
{
return
false
;
}
if
(
!
ifDone
.
emitElse
(
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
value
(
)
)
)
{
return
false
;
}
if
(
!
ifDone
.
emitEnd
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
ifDone
.
pushed
(
)
=
=
0
)
;
if
(
!
isFirst
)
{
if
(
!
ifAlreadyDone
.
emitEnd
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
ifAlreadyDone
.
pushed
(
)
=
=
2
)
;
}
if
(
pndefault
)
{
auto
emitDefault
=
[
pndefault
lhsPattern
]
(
BytecodeEmitter
*
bce
)
{
return
bce
-
>
emitDefault
(
pndefault
lhsPattern
)
;
}
;
if
(
!
wrapWithDestructuringTryNote
(
tryNoteDepth
emitDefault
)
)
{
return
false
;
}
}
if
(
!
isElision
)
{
auto
emitAssignment
=
[
lhsPattern
flav
]
(
BytecodeEmitter
*
bce
)
{
return
bce
-
>
emitSetOrInitializeDestructuring
(
lhsPattern
flav
)
;
}
;
if
(
!
wrapWithDestructuringTryNote
(
tryNoteDepth
emitAssignment
)
)
{
return
false
;
}
}
else
{
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
}
InternalIfEmitter
ifDone
(
this
)
;
if
(
!
ifDone
.
emitThenElse
(
)
)
{
return
false
;
}
if
(
!
emitPopN
(
2
)
)
{
return
false
;
}
if
(
!
ifDone
.
emitElse
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
emitIteratorCloseInInnermostScope
(
)
)
{
return
false
;
}
if
(
!
ifDone
.
emitEnd
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitComputedPropertyName
(
UnaryNode
*
computedPropName
)
{
MOZ_ASSERT
(
computedPropName
-
>
isKind
(
ParseNodeKind
:
:
ComputedName
)
)
;
return
emitTree
(
computedPropName
-
>
kid
(
)
)
&
&
emit1
(
JSOp
:
:
ToPropertyKey
)
;
}
bool
BytecodeEmitter
:
:
emitDestructuringOpsObject
(
ListNode
*
pattern
DestructuringFlavor
flav
)
{
MOZ_ASSERT
(
pattern
-
>
isKind
(
ParseNodeKind
:
:
ObjectExpr
)
)
;
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
>
0
)
;
if
(
!
emit1
(
JSOp
:
:
CheckObjCoercible
)
)
{
return
false
;
}
bool
needsRestPropertyExcludedSet
=
pattern
-
>
count
(
)
>
1
&
&
pattern
-
>
last
(
)
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
;
if
(
needsRestPropertyExcludedSet
)
{
if
(
!
emitDestructuringObjRestExclusionSet
(
pattern
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
}
for
(
ParseNode
*
member
:
pattern
-
>
contents
(
)
)
{
ParseNode
*
subpattern
;
if
(
member
-
>
isKind
(
ParseNodeKind
:
:
MutateProto
)
|
|
member
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
subpattern
=
member
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
;
}
else
{
MOZ_ASSERT
(
member
-
>
isKind
(
ParseNodeKind
:
:
PropertyDefinition
)
|
|
member
-
>
isKind
(
ParseNodeKind
:
:
Shorthand
)
)
;
subpattern
=
member
-
>
as
<
BinaryNode
>
(
)
.
right
(
)
;
}
ParseNode
*
lhs
=
subpattern
;
MOZ_ASSERT_IF
(
member
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
!
lhs
-
>
isKind
(
ParseNodeKind
:
:
AssignExpr
)
)
;
if
(
lhs
-
>
isKind
(
ParseNodeKind
:
:
AssignExpr
)
)
{
lhs
=
lhs
-
>
as
<
AssignmentNode
>
(
)
.
left
(
)
;
}
size_t
emitted
;
if
(
!
emitDestructuringLHSRef
(
lhs
&
emitted
)
)
{
return
false
;
}
if
(
!
emitDupAt
(
emitted
)
)
{
return
false
;
}
if
(
member
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
if
(
!
updateSourceCoordNotes
(
member
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
NewInit
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Pick
2
)
)
{
return
false
;
}
if
(
needsRestPropertyExcludedSet
)
{
if
(
!
emit2
(
JSOp
:
:
Pick
emitted
+
4
)
)
{
return
false
;
}
}
CopyOption
option
=
needsRestPropertyExcludedSet
?
CopyOption
:
:
Filtered
:
CopyOption
:
:
Unfiltered
;
if
(
!
emitCopyDataProperties
(
option
)
)
{
return
false
;
}
if
(
!
emitSetOrInitializeDestructuring
(
lhs
flav
)
)
{
return
false
;
}
MOZ_ASSERT
(
member
=
=
pattern
-
>
last
(
)
"
Rest
property
is
always
last
"
)
;
break
;
}
bool
needsGetElem
=
true
;
if
(
member
-
>
isKind
(
ParseNodeKind
:
:
MutateProto
)
)
{
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
proto
(
)
)
)
{
return
false
;
}
needsGetElem
=
false
;
}
else
{
MOZ_ASSERT
(
member
-
>
isKind
(
ParseNodeKind
:
:
PropertyDefinition
)
|
|
member
-
>
isKind
(
ParseNodeKind
:
:
Shorthand
)
)
;
ParseNode
*
key
=
member
-
>
as
<
BinaryNode
>
(
)
.
left
(
)
;
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
NumberExpr
)
)
{
if
(
!
emitNumberOp
(
key
-
>
as
<
NumericLiteral
>
(
)
.
value
(
)
)
)
{
return
false
;
}
}
else
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
BigIntExpr
)
)
{
if
(
!
emitBigIntOp
(
&
key
-
>
as
<
BigIntLiteral
>
(
)
)
)
{
return
false
;
}
}
else
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
ObjectPropertyName
)
|
|
key
-
>
isKind
(
ParseNodeKind
:
:
StringExpr
)
)
{
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
key
-
>
as
<
NameNode
>
(
)
.
atom
(
)
)
)
{
return
false
;
}
needsGetElem
=
false
;
}
else
{
if
(
!
emitComputedPropertyName
(
&
key
-
>
as
<
UnaryNode
>
(
)
)
)
{
return
false
;
}
if
(
needsRestPropertyExcludedSet
)
{
if
(
!
emitDupAt
(
emitted
+
3
)
)
{
return
false
;
}
if
(
!
emitDupAt
(
1
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
InitElem
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
}
}
if
(
needsGetElem
&
&
!
emitElemOpBase
(
JSOp
:
:
GetElem
)
)
{
return
false
;
}
if
(
subpattern
-
>
isKind
(
ParseNodeKind
:
:
AssignExpr
)
)
{
if
(
!
emitDefault
(
subpattern
-
>
as
<
AssignmentNode
>
(
)
.
right
(
)
lhs
)
)
{
return
false
;
}
}
if
(
!
emitSetOrInitializeDestructuring
(
subpattern
flav
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
IsDestructuringRestExclusionSetObjLiteralCompatible
(
ListNode
*
pattern
)
{
uint32_t
propCount
=
0
;
for
(
ParseNode
*
member
:
pattern
-
>
contents
(
)
)
{
if
(
member
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
MOZ_ASSERT
(
!
member
-
>
pn_next
"
unexpected
trailing
element
after
spread
"
)
;
break
;
}
propCount
+
+
;
if
(
member
-
>
isKind
(
ParseNodeKind
:
:
MutateProto
)
)
{
continue
;
}
ParseNode
*
key
=
member
-
>
as
<
BinaryNode
>
(
)
.
left
(
)
;
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
ObjectPropertyName
)
|
|
key
-
>
isKind
(
ParseNodeKind
:
:
StringExpr
)
)
{
continue
;
}
MOZ_ASSERT
(
key
-
>
isKind
(
ParseNodeKind
:
:
NumberExpr
)
|
|
key
-
>
isKind
(
ParseNodeKind
:
:
BigIntExpr
)
|
|
key
-
>
isKind
(
ParseNodeKind
:
:
ComputedName
)
)
;
return
false
;
}
if
(
propCount
>
SharedPropMap
:
:
MaxPropsForNonDictionary
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDestructuringObjRestExclusionSet
(
ListNode
*
pattern
)
{
MOZ_ASSERT
(
pattern
-
>
isKind
(
ParseNodeKind
:
:
ObjectExpr
)
)
;
MOZ_ASSERT
(
pattern
-
>
last
(
)
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
;
if
(
IsDestructuringRestExclusionSetObjLiteralCompatible
(
pattern
)
)
{
if
(
!
emitDestructuringRestExclusionSetObjLiteral
(
pattern
)
)
{
return
false
;
}
}
else
{
if
(
!
emit1
(
JSOp
:
:
NewInit
)
)
{
return
false
;
}
}
TaggedParserAtomIndex
pnatom
;
for
(
ParseNode
*
member
:
pattern
-
>
contents
(
)
)
{
if
(
member
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
MOZ_ASSERT
(
!
member
-
>
pn_next
"
unexpected
trailing
element
after
spread
"
)
;
break
;
}
bool
isIndex
=
false
;
if
(
member
-
>
isKind
(
ParseNodeKind
:
:
MutateProto
)
)
{
pnatom
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
proto
(
)
;
}
else
{
ParseNode
*
key
=
member
-
>
as
<
BinaryNode
>
(
)
.
left
(
)
;
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
NumberExpr
)
)
{
if
(
!
emitNumberOp
(
key
-
>
as
<
NumericLiteral
>
(
)
.
value
(
)
)
)
{
return
false
;
}
isIndex
=
true
;
}
else
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
BigIntExpr
)
)
{
if
(
!
emitBigIntOp
(
&
key
-
>
as
<
BigIntLiteral
>
(
)
)
)
{
return
false
;
}
isIndex
=
true
;
}
else
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
ObjectPropertyName
)
|
|
key
-
>
isKind
(
ParseNodeKind
:
:
StringExpr
)
)
{
pnatom
=
key
-
>
as
<
NameNode
>
(
)
.
atom
(
)
;
}
else
{
MOZ_ASSERT
(
key
-
>
isKind
(
ParseNodeKind
:
:
ComputedName
)
)
;
continue
;
}
}
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
if
(
isIndex
)
{
if
(
!
emit1
(
JSOp
:
:
InitElem
)
)
{
return
false
;
}
}
else
{
if
(
!
emitAtomOp
(
JSOp
:
:
InitProp
pnatom
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDestructuringOps
(
ListNode
*
pattern
DestructuringFlavor
flav
)
{
if
(
pattern
-
>
isKind
(
ParseNodeKind
:
:
ArrayExpr
)
)
{
return
emitDestructuringOpsArray
(
pattern
flav
)
;
}
return
emitDestructuringOpsObject
(
pattern
flav
)
;
}
bool
BytecodeEmitter
:
:
emitTemplateString
(
ListNode
*
templateString
)
{
bool
pushedString
=
false
;
for
(
ParseNode
*
item
:
templateString
-
>
contents
(
)
)
{
bool
isString
=
(
item
-
>
getKind
(
)
=
=
ParseNodeKind
:
:
StringExpr
|
|
item
-
>
getKind
(
)
=
=
ParseNodeKind
:
:
TemplateStringExpr
)
;
if
(
isString
&
&
item
-
>
as
<
NameNode
>
(
)
.
atom
(
)
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
empty
(
)
)
{
continue
;
}
if
(
!
isString
)
{
if
(
!
updateSourceCoordNotes
(
item
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
}
if
(
!
emitTree
(
item
)
)
{
return
false
;
}
if
(
!
isString
)
{
if
(
!
emit1
(
JSOp
:
:
ToString
)
)
{
return
false
;
}
}
if
(
pushedString
)
{
if
(
!
emit1
(
JSOp
:
:
Add
)
)
{
return
false
;
}
}
else
{
pushedString
=
true
;
}
}
if
(
!
pushedString
)
{
if
(
!
emitAtomOp
(
JSOp
:
:
String
TaggedParserAtomIndex
:
:
WellKnown
:
:
empty
(
)
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDeclarationList
(
ListNode
*
declList
)
{
for
(
ParseNode
*
decl
:
declList
-
>
contents
(
)
)
{
ParseNode
*
pattern
;
ParseNode
*
initializer
;
if
(
decl
-
>
isKind
(
ParseNodeKind
:
:
Name
)
)
{
pattern
=
decl
;
initializer
=
nullptr
;
}
else
{
AssignmentNode
*
assignNode
=
&
decl
-
>
as
<
AssignmentNode
>
(
)
;
pattern
=
assignNode
-
>
left
(
)
;
initializer
=
assignNode
-
>
right
(
)
;
}
if
(
pattern
-
>
isKind
(
ParseNodeKind
:
:
Name
)
)
{
if
(
!
emitSingleDeclaration
(
declList
&
pattern
-
>
as
<
NameNode
>
(
)
initializer
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
pattern
-
>
isKind
(
ParseNodeKind
:
:
ArrayExpr
)
|
|
pattern
-
>
isKind
(
ParseNodeKind
:
:
ObjectExpr
)
)
;
MOZ_ASSERT
(
initializer
!
=
nullptr
)
;
if
(
!
updateSourceCoordNotes
(
initializer
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
initializer
)
)
{
return
false
;
}
if
(
!
emitDestructuringOps
(
&
pattern
-
>
as
<
ListNode
>
(
)
DestructuringFlavor
:
:
Declaration
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitSingleDeclaration
(
ListNode
*
declList
NameNode
*
decl
ParseNode
*
initializer
)
{
MOZ_ASSERT
(
decl
-
>
isKind
(
ParseNodeKind
:
:
Name
)
)
;
if
(
!
initializer
&
&
declList
-
>
isKind
(
ParseNodeKind
:
:
VarStmt
)
)
{
return
true
;
}
auto
nameAtom
=
decl
-
>
name
(
)
;
NameOpEmitter
noe
(
this
nameAtom
NameOpEmitter
:
:
Kind
:
:
Initialize
)
;
if
(
!
noe
.
prepareForRhs
(
)
)
{
return
false
;
}
if
(
!
initializer
)
{
MOZ_ASSERT
(
declList
-
>
isKind
(
ParseNodeKind
:
:
LetDecl
)
"
var
declarations
without
initializers
handled
above
"
"
and
const
declarations
must
have
initializers
"
)
;
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
initializer
)
;
if
(
!
updateSourceCoordNotes
(
initializer
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitInitializer
(
initializer
decl
)
)
{
return
false
;
}
}
if
(
!
noe
.
emitAssignment
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitAssignmentRhs
(
ParseNode
*
rhs
TaggedParserAtomIndex
anonFunctionName
)
{
if
(
rhs
-
>
isDirectRHSAnonFunction
(
)
)
{
if
(
anonFunctionName
)
{
return
emitAnonymousFunctionWithName
(
rhs
anonFunctionName
)
;
}
return
emitAnonymousFunctionWithComputedName
(
rhs
FunctionPrefixKind
:
:
None
)
;
}
return
emitTree
(
rhs
)
;
}
bool
BytecodeEmitter
:
:
emitAssignmentRhs
(
uint8_t
offset
)
{
if
(
offset
!
=
1
)
{
return
emitPickN
(
offset
-
1
)
;
}
return
true
;
}
static
inline
JSOp
CompoundAssignmentParseNodeKindToJSOp
(
ParseNodeKind
pnk
)
{
switch
(
pnk
)
{
case
ParseNodeKind
:
:
InitExpr
:
return
JSOp
:
:
Nop
;
case
ParseNodeKind
:
:
AssignExpr
:
return
JSOp
:
:
Nop
;
case
ParseNodeKind
:
:
AddAssignExpr
:
return
JSOp
:
:
Add
;
case
ParseNodeKind
:
:
SubAssignExpr
:
return
JSOp
:
:
Sub
;
case
ParseNodeKind
:
:
BitOrAssignExpr
:
return
JSOp
:
:
BitOr
;
case
ParseNodeKind
:
:
BitXorAssignExpr
:
return
JSOp
:
:
BitXor
;
case
ParseNodeKind
:
:
BitAndAssignExpr
:
return
JSOp
:
:
BitAnd
;
case
ParseNodeKind
:
:
LshAssignExpr
:
return
JSOp
:
:
Lsh
;
case
ParseNodeKind
:
:
RshAssignExpr
:
return
JSOp
:
:
Rsh
;
case
ParseNodeKind
:
:
UrshAssignExpr
:
return
JSOp
:
:
Ursh
;
case
ParseNodeKind
:
:
MulAssignExpr
:
return
JSOp
:
:
Mul
;
case
ParseNodeKind
:
:
DivAssignExpr
:
return
JSOp
:
:
Div
;
case
ParseNodeKind
:
:
ModAssignExpr
:
return
JSOp
:
:
Mod
;
case
ParseNodeKind
:
:
PowAssignExpr
:
return
JSOp
:
:
Pow
;
case
ParseNodeKind
:
:
CoalesceAssignExpr
:
case
ParseNodeKind
:
:
OrAssignExpr
:
case
ParseNodeKind
:
:
AndAssignExpr
:
[
[
fallthrough
]
]
;
default
:
MOZ_CRASH
(
"
unexpected
compound
assignment
op
"
)
;
}
}
bool
BytecodeEmitter
:
:
emitAssignmentOrInit
(
ParseNodeKind
kind
ParseNode
*
lhs
ParseNode
*
rhs
)
{
JSOp
compoundOp
=
CompoundAssignmentParseNodeKindToJSOp
(
kind
)
;
bool
isCompound
=
compoundOp
!
=
JSOp
:
:
Nop
;
bool
isInit
=
kind
=
=
ParseNodeKind
:
:
InitExpr
;
MOZ_ASSERT_IF
(
isInit
lhs
-
>
isKind
(
ParseNodeKind
:
:
DotExpr
)
|
|
lhs
-
>
isKind
(
ParseNodeKind
:
:
ElemExpr
)
|
|
lhs
-
>
isKind
(
ParseNodeKind
:
:
PrivateMemberExpr
)
)
;
TaggedParserAtomIndex
name
;
Maybe
<
NameOpEmitter
>
noe
;
Maybe
<
PropOpEmitter
>
poe
;
Maybe
<
ElemOpEmitter
>
eoe
;
Maybe
<
PrivateOpEmitter
>
xoe
;
uint8_t
offset
=
1
;
TaggedParserAtomIndex
anonFunctionName
;
switch
(
lhs
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
Name
:
{
name
=
lhs
-
>
as
<
NameNode
>
(
)
.
name
(
)
;
anonFunctionName
=
name
;
noe
.
emplace
(
this
name
isCompound
?
NameOpEmitter
:
:
Kind
:
:
CompoundAssignment
:
NameOpEmitter
:
:
Kind
:
:
SimpleAssignment
)
;
break
;
}
case
ParseNodeKind
:
:
DotExpr
:
{
PropertyAccess
*
prop
=
&
lhs
-
>
as
<
PropertyAccess
>
(
)
;
bool
isSuper
=
prop
-
>
isSuper
(
)
;
poe
.
emplace
(
this
isCompound
?
PropOpEmitter
:
:
Kind
:
:
CompoundAssignment
:
isInit
?
PropOpEmitter
:
:
Kind
:
:
PropInit
:
PropOpEmitter
:
:
Kind
:
:
SimpleAssignment
isSuper
?
PropOpEmitter
:
:
ObjKind
:
:
Super
:
PropOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
poe
-
>
prepareForObj
(
)
)
{
return
false
;
}
anonFunctionName
=
prop
-
>
name
(
)
;
if
(
isSuper
)
{
UnaryNode
*
base
=
&
prop
-
>
expression
(
)
.
as
<
UnaryNode
>
(
)
;
if
(
!
emitGetThisForSuperBase
(
base
)
)
{
return
false
;
}
offset
+
=
2
;
}
else
{
if
(
!
emitTree
(
&
prop
-
>
expression
(
)
)
)
{
return
false
;
}
offset
+
=
1
;
}
break
;
}
case
ParseNodeKind
:
:
ElemExpr
:
{
PropertyByValue
*
elem
=
&
lhs
-
>
as
<
PropertyByValue
>
(
)
;
bool
isSuper
=
elem
-
>
isSuper
(
)
;
MOZ_ASSERT
(
!
elem
-
>
key
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
eoe
.
emplace
(
this
isCompound
?
ElemOpEmitter
:
:
Kind
:
:
CompoundAssignment
:
isInit
?
ElemOpEmitter
:
:
Kind
:
:
PropInit
:
ElemOpEmitter
:
:
Kind
:
:
SimpleAssignment
isSuper
?
ElemOpEmitter
:
:
ObjKind
:
:
Super
:
ElemOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
emitElemObjAndKey
(
elem
isSuper
*
eoe
)
)
{
return
false
;
}
if
(
isSuper
)
{
offset
+
=
3
;
}
else
{
offset
+
=
2
;
}
break
;
}
case
ParseNodeKind
:
:
PrivateMemberExpr
:
{
PrivateMemberAccess
*
privateExpr
=
&
lhs
-
>
as
<
PrivateMemberAccess
>
(
)
;
xoe
.
emplace
(
this
isCompound
?
PrivateOpEmitter
:
:
Kind
:
:
CompoundAssignment
:
isInit
?
PrivateOpEmitter
:
:
Kind
:
:
PropInit
:
PrivateOpEmitter
:
:
Kind
:
:
SimpleAssignment
privateExpr
-
>
privateName
(
)
.
name
(
)
)
;
if
(
!
emitTree
(
&
privateExpr
-
>
expression
(
)
)
)
{
return
false
;
}
if
(
!
xoe
-
>
emitReference
(
)
)
{
return
false
;
}
offset
+
=
xoe
-
>
numReferenceSlots
(
)
;
break
;
}
case
ParseNodeKind
:
:
ArrayExpr
:
case
ParseNodeKind
:
:
ObjectExpr
:
break
;
case
ParseNodeKind
:
:
CallExpr
:
if
(
!
emitTree
(
lhs
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
ThrowMsg
uint8_t
(
ThrowMsgKind
:
:
AssignToCall
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
break
;
default
:
MOZ_ASSERT
(
0
)
;
}
if
(
isCompound
)
{
MOZ_ASSERT
(
rhs
)
;
switch
(
lhs
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
DotExpr
:
{
PropertyAccess
*
prop
=
&
lhs
-
>
as
<
PropertyAccess
>
(
)
;
if
(
!
poe
-
>
emitGet
(
prop
-
>
key
(
)
.
atom
(
)
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
ElemExpr
:
{
if
(
!
eoe
-
>
emitGet
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
PrivateMemberExpr
:
{
if
(
!
xoe
-
>
emitGet
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
CallExpr
:
if
(
!
emit1
(
JSOp
:
:
Null
)
)
{
return
false
;
}
break
;
default
:
;
}
}
switch
(
lhs
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
Name
:
if
(
!
noe
-
>
prepareForRhs
(
)
)
{
return
false
;
}
offset
+
=
noe
-
>
emittedBindOp
(
)
;
break
;
case
ParseNodeKind
:
:
DotExpr
:
if
(
!
poe
-
>
prepareForRhs
(
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ElemExpr
:
if
(
!
eoe
-
>
prepareForRhs
(
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
PrivateMemberExpr
:
break
;
default
:
break
;
}
if
(
rhs
)
{
if
(
!
emitAssignmentRhs
(
rhs
anonFunctionName
)
)
{
return
false
;
}
}
else
{
if
(
!
emitAssignmentRhs
(
offset
)
)
{
return
false
;
}
}
if
(
isCompound
)
{
if
(
!
newSrcNote
(
SrcNoteType
:
:
AssignOp
)
)
{
return
false
;
}
if
(
!
emit1
(
compoundOp
)
)
{
return
false
;
}
}
switch
(
lhs
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
Name
:
{
if
(
!
noe
-
>
emitAssignment
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
DotExpr
:
{
PropertyAccess
*
prop
=
&
lhs
-
>
as
<
PropertyAccess
>
(
)
;
if
(
!
poe
-
>
emitAssignment
(
prop
-
>
key
(
)
.
atom
(
)
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
CallExpr
:
break
;
case
ParseNodeKind
:
:
ElemExpr
:
{
if
(
!
eoe
-
>
emitAssignment
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
PrivateMemberExpr
:
if
(
!
xoe
-
>
emitAssignment
(
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ArrayExpr
:
case
ParseNodeKind
:
:
ObjectExpr
:
if
(
!
emitDestructuringOps
(
&
lhs
-
>
as
<
ListNode
>
(
)
DestructuringFlavor
:
:
Assignment
)
)
{
return
false
;
}
break
;
default
:
MOZ_ASSERT
(
0
)
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitShortCircuitAssignment
(
AssignmentNode
*
node
)
{
TDZCheckCache
tdzCache
(
this
)
;
JSOp
op
;
switch
(
node
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
CoalesceAssignExpr
:
op
=
JSOp
:
:
Coalesce
;
break
;
case
ParseNodeKind
:
:
OrAssignExpr
:
op
=
JSOp
:
:
Or
;
break
;
case
ParseNodeKind
:
:
AndAssignExpr
:
op
=
JSOp
:
:
And
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
ParseNodeKind
"
)
;
}
ParseNode
*
lhs
=
node
-
>
left
(
)
;
ParseNode
*
rhs
=
node
-
>
right
(
)
;
TaggedParserAtomIndex
name
;
Maybe
<
NameOpEmitter
>
noe
;
Maybe
<
PropOpEmitter
>
poe
;
Maybe
<
ElemOpEmitter
>
eoe
;
Maybe
<
PrivateOpEmitter
>
xoe
;
int32_t
depth
=
bytecodeSection
(
)
.
stackDepth
(
)
;
int32_t
numPushed
;
switch
(
lhs
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
Name
:
{
name
=
lhs
-
>
as
<
NameNode
>
(
)
.
name
(
)
;
noe
.
emplace
(
this
name
NameOpEmitter
:
:
Kind
:
:
CompoundAssignment
)
;
if
(
!
noe
-
>
prepareForRhs
(
)
)
{
return
false
;
}
numPushed
=
noe
-
>
emittedBindOp
(
)
;
break
;
}
case
ParseNodeKind
:
:
DotExpr
:
{
PropertyAccess
*
prop
=
&
lhs
-
>
as
<
PropertyAccess
>
(
)
;
bool
isSuper
=
prop
-
>
isSuper
(
)
;
poe
.
emplace
(
this
PropOpEmitter
:
:
Kind
:
:
CompoundAssignment
isSuper
?
PropOpEmitter
:
:
ObjKind
:
:
Super
:
PropOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
poe
-
>
prepareForObj
(
)
)
{
return
false
;
}
if
(
isSuper
)
{
UnaryNode
*
base
=
&
prop
-
>
expression
(
)
.
as
<
UnaryNode
>
(
)
;
if
(
!
emitGetThisForSuperBase
(
base
)
)
{
return
false
;
}
}
else
{
if
(
!
emitTree
(
&
prop
-
>
expression
(
)
)
)
{
return
false
;
}
}
if
(
!
poe
-
>
emitGet
(
prop
-
>
key
(
)
.
atom
(
)
)
)
{
return
false
;
}
if
(
!
poe
-
>
prepareForRhs
(
)
)
{
return
false
;
}
numPushed
=
1
+
isSuper
;
break
;
}
case
ParseNodeKind
:
:
ElemExpr
:
{
PropertyByValue
*
elem
=
&
lhs
-
>
as
<
PropertyByValue
>
(
)
;
bool
isSuper
=
elem
-
>
isSuper
(
)
;
MOZ_ASSERT
(
!
elem
-
>
key
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
eoe
.
emplace
(
this
ElemOpEmitter
:
:
Kind
:
:
CompoundAssignment
isSuper
?
ElemOpEmitter
:
:
ObjKind
:
:
Super
:
ElemOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
emitElemObjAndKey
(
elem
isSuper
*
eoe
)
)
{
return
false
;
}
if
(
!
eoe
-
>
emitGet
(
)
)
{
return
false
;
}
if
(
!
eoe
-
>
prepareForRhs
(
)
)
{
return
false
;
}
numPushed
=
2
+
isSuper
;
break
;
}
case
ParseNodeKind
:
:
PrivateMemberExpr
:
{
PrivateMemberAccess
*
privateExpr
=
&
lhs
-
>
as
<
PrivateMemberAccess
>
(
)
;
xoe
.
emplace
(
this
PrivateOpEmitter
:
:
Kind
:
:
CompoundAssignment
privateExpr
-
>
privateName
(
)
.
name
(
)
)
;
if
(
!
emitTree
(
&
privateExpr
-
>
expression
(
)
)
)
{
return
false
;
}
if
(
!
xoe
-
>
emitReference
(
)
)
{
return
false
;
}
if
(
!
xoe
-
>
emitGet
(
)
)
{
return
false
;
}
numPushed
=
xoe
-
>
numReferenceSlots
(
)
;
break
;
}
default
:
MOZ_CRASH
(
)
;
}
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
=
=
depth
+
numPushed
+
1
)
;
JumpList
jump
;
if
(
!
emitJump
(
op
&
jump
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
emitAssignmentRhs
(
rhs
name
)
)
{
return
false
;
}
switch
(
lhs
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
Name
:
{
if
(
!
noe
-
>
emitAssignment
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
DotExpr
:
{
PropertyAccess
*
prop
=
&
lhs
-
>
as
<
PropertyAccess
>
(
)
;
if
(
!
poe
-
>
emitAssignment
(
prop
-
>
key
(
)
.
atom
(
)
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
ElemExpr
:
{
if
(
!
eoe
-
>
emitAssignment
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
PrivateMemberExpr
:
if
(
!
xoe
-
>
emitAssignment
(
)
)
{
return
false
;
}
break
;
default
:
MOZ_CRASH
(
)
;
}
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
=
=
depth
+
1
)
;
if
(
numPushed
>
0
)
{
JumpList
jumpAroundPop
;
if
(
!
emitJump
(
JSOp
:
:
Goto
&
jumpAroundPop
)
)
{
return
false
;
}
if
(
!
emitJumpTargetAndPatch
(
jump
)
)
{
return
false
;
}
bytecodeSection
(
)
.
setStackDepth
(
depth
+
1
+
numPushed
)
;
if
(
!
emitUnpickN
(
numPushed
)
)
{
return
false
;
}
if
(
!
emitPopN
(
numPushed
)
)
{
return
false
;
}
if
(
!
emitJumpTargetAndPatch
(
jumpAroundPop
)
)
{
return
false
;
}
}
else
{
if
(
!
emitJumpTargetAndPatch
(
jump
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
=
=
depth
+
1
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitCallSiteObjectArray
(
ListNode
*
cookedOrRaw
GCThingIndex
*
outArrayIndex
)
{
uint32_t
count
=
cookedOrRaw
-
>
count
(
)
;
ParseNode
*
pn
=
cookedOrRaw
-
>
head
(
)
;
if
(
cookedOrRaw
-
>
isKind
(
ParseNodeKind
:
:
CallSiteObj
)
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
ParseNodeKind
:
:
ArrayExpr
)
)
;
pn
=
pn
-
>
pn_next
;
count
-
-
;
}
else
{
MOZ_ASSERT
(
cookedOrRaw
-
>
isKind
(
ParseNodeKind
:
:
ArrayExpr
)
)
;
}
ObjLiteralWriter
writer
;
ObjLiteralFlags
flags
(
{
ObjLiteralFlag
:
:
Array
}
)
;
writer
.
beginObject
(
flags
)
;
writer
.
beginDenseArrayElements
(
)
;
size_t
idx
;
for
(
idx
=
0
;
pn
;
idx
+
+
pn
=
pn
-
>
pn_next
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
ParseNodeKind
:
:
TemplateStringExpr
)
|
|
pn
-
>
isKind
(
ParseNodeKind
:
:
RawUndefinedExpr
)
)
;
if
(
!
emitObjLiteralValue
(
writer
pn
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
idx
=
=
count
)
;
return
addObjLiteralData
(
writer
outArrayIndex
)
;
}
bool
BytecodeEmitter
:
:
emitCallSiteObject
(
CallSiteNode
*
callSiteObj
)
{
GCThingIndex
cookedIndex
;
if
(
!
emitCallSiteObjectArray
(
callSiteObj
&
cookedIndex
)
)
{
return
false
;
}
GCThingIndex
rawIndex
;
if
(
!
emitCallSiteObjectArray
(
callSiteObj
-
>
rawNodes
(
)
&
rawIndex
)
)
{
return
false
;
}
MOZ_ASSERT
(
sc
-
>
hasCallSiteObj
(
)
)
;
return
emitObjectPairOp
(
cookedIndex
rawIndex
JSOp
:
:
CallSiteObj
)
;
}
bool
BytecodeEmitter
:
:
emitCatch
(
BinaryNode
*
catchClause
)
{
MOZ_ASSERT
(
innermostNestableControl
-
>
is
<
TryFinallyControl
>
(
)
)
;
ParseNode
*
param
=
catchClause
-
>
left
(
)
;
if
(
!
param
)
{
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
else
{
switch
(
param
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
ArrayExpr
:
case
ParseNodeKind
:
:
ObjectExpr
:
if
(
!
emitDestructuringOps
(
&
param
-
>
as
<
ListNode
>
(
)
DestructuringFlavor
:
:
Declaration
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
Name
:
if
(
!
emitLexicalInitialization
(
&
param
-
>
as
<
NameNode
>
(
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
break
;
default
:
MOZ_ASSERT
(
0
)
;
}
}
return
emitTree
(
catchClause
-
>
right
(
)
)
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitTry
(
TryNode
*
tryNode
)
{
LexicalScopeNode
*
catchScope
=
tryNode
-
>
catchScope
(
)
;
ParseNode
*
finallyNode
=
tryNode
-
>
finallyBlock
(
)
;
TryEmitter
:
:
Kind
kind
;
if
(
catchScope
)
{
if
(
finallyNode
)
{
kind
=
TryEmitter
:
:
Kind
:
:
TryCatchFinally
;
}
else
{
kind
=
TryEmitter
:
:
Kind
:
:
TryCatch
;
}
}
else
{
MOZ_ASSERT
(
finallyNode
)
;
kind
=
TryEmitter
:
:
Kind
:
:
TryFinally
;
}
TryEmitter
tryCatch
(
this
kind
TryEmitter
:
:
ControlKind
:
:
Syntactic
)
;
if
(
!
tryCatch
.
emitTry
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
tryNode
-
>
body
(
)
)
)
{
return
false
;
}
if
(
catchScope
)
{
if
(
!
tryCatch
.
emitCatch
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
catchScope
)
)
{
return
false
;
}
}
if
(
finallyNode
)
{
if
(
!
tryCatch
.
emitFinally
(
Some
(
finallyNode
-
>
pn_pos
.
begin
)
)
)
{
return
false
;
}
if
(
!
emitTree
(
finallyNode
)
)
{
return
false
;
}
}
if
(
!
tryCatch
.
emitEnd
(
)
)
{
return
false
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
BytecodeEmitter
:
:
emitGoSub
(
JumpList
*
jump
)
{
if
(
!
emit1
(
JSOp
:
:
False
)
)
{
return
false
;
}
BytecodeOffset
off
;
if
(
!
emitN
(
JSOp
:
:
ResumeIndex
3
&
off
)
)
{
return
false
;
}
if
(
!
emitJumpNoFallthrough
(
JSOp
:
:
Gosub
jump
)
)
{
return
false
;
}
uint32_t
resumeIndex
;
if
(
!
allocateResumeIndex
(
bytecodeSection
(
)
.
offset
(
)
&
resumeIndex
)
)
{
return
false
;
}
SET_RESUMEINDEX
(
bytecodeSection
(
)
.
code
(
off
)
resumeIndex
)
;
JumpTarget
target
;
return
emitJumpTarget
(
&
target
)
;
}
bool
BytecodeEmitter
:
:
emitIf
(
TernaryNode
*
ifNode
)
{
IfEmitter
ifThenElse
(
this
)
;
if
(
!
ifThenElse
.
emitIf
(
Some
(
ifNode
-
>
kid1
(
)
-
>
pn_pos
.
begin
)
)
)
{
return
false
;
}
if_again
:
ParseNode
*
testNode
=
ifNode
-
>
kid1
(
)
;
auto
conditionKind
=
IfEmitter
:
:
ConditionKind
:
:
Positive
;
if
(
testNode
-
>
isKind
(
ParseNodeKind
:
:
NotExpr
)
)
{
testNode
=
testNode
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
;
conditionKind
=
IfEmitter
:
:
ConditionKind
:
:
Negative
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
testNode
)
)
{
return
false
;
}
ParseNode
*
elseNode
=
ifNode
-
>
kid3
(
)
;
if
(
elseNode
)
{
if
(
!
ifThenElse
.
emitThenElse
(
conditionKind
)
)
{
return
false
;
}
}
else
{
if
(
!
ifThenElse
.
emitThen
(
conditionKind
)
)
{
return
false
;
}
}
if
(
!
emitTree
(
ifNode
-
>
kid2
(
)
)
)
{
return
false
;
}
if
(
elseNode
)
{
if
(
elseNode
-
>
isKind
(
ParseNodeKind
:
:
IfStmt
)
)
{
ifNode
=
&
elseNode
-
>
as
<
TernaryNode
>
(
)
;
if
(
!
ifThenElse
.
emitElseIf
(
Some
(
ifNode
-
>
kid1
(
)
-
>
pn_pos
.
begin
)
)
)
{
return
false
;
}
goto
if_again
;
}
if
(
!
ifThenElse
.
emitElse
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
elseNode
)
)
{
return
false
;
}
}
if
(
!
ifThenElse
.
emitEnd
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitHoistedFunctionsInList
(
ListNode
*
stmtList
)
{
MOZ_ASSERT
(
stmtList
-
>
hasTopLevelFunctionDeclarations
(
)
)
;
if
(
stmtList
-
>
emittedTopLevelFunctionDeclarations
(
)
)
{
return
true
;
}
stmtList
-
>
setEmittedTopLevelFunctionDeclarations
(
)
;
for
(
ParseNode
*
stmt
:
stmtList
-
>
contents
(
)
)
{
ParseNode
*
maybeFun
=
stmt
;
if
(
!
sc
-
>
strict
(
)
)
{
while
(
maybeFun
-
>
isKind
(
ParseNodeKind
:
:
LabelStmt
)
)
{
maybeFun
=
maybeFun
-
>
as
<
LabeledStatement
>
(
)
.
statement
(
)
;
}
}
if
(
maybeFun
-
>
is
<
FunctionNode
>
(
)
&
&
maybeFun
-
>
as
<
FunctionNode
>
(
)
.
functionIsHoisted
(
)
)
{
if
(
!
emitTree
(
maybeFun
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitLexicalScopeBody
(
ParseNode
*
body
EmitLineNumberNote
emitLineNote
)
{
if
(
body
-
>
isKind
(
ParseNodeKind
:
:
StatementList
)
&
&
body
-
>
as
<
ListNode
>
(
)
.
hasTopLevelFunctionDeclarations
(
)
)
{
if
(
!
emitHoistedFunctionsInList
(
&
body
-
>
as
<
ListNode
>
(
)
)
)
{
return
false
;
}
}
return
emitTree
(
body
ValueUsage
:
:
WantValue
emitLineNote
)
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitLexicalScope
(
LexicalScopeNode
*
lexicalScope
)
{
LexicalScopeEmitter
lse
(
this
)
;
ParseNode
*
body
=
lexicalScope
-
>
scopeBody
(
)
;
if
(
lexicalScope
-
>
isEmptyScope
(
)
)
{
if
(
!
lse
.
emitEmptyScope
(
)
)
{
return
false
;
}
if
(
!
emitLexicalScopeBody
(
body
)
)
{
return
false
;
}
if
(
!
lse
.
emitEnd
(
)
)
{
return
false
;
}
return
true
;
}
if
(
!
ParseNodeRequiresSpecialLineNumberNotes
(
body
)
)
{
if
(
!
updateSourceCoordNotes
(
lexicalScope
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
}
ScopeKind
kind
;
if
(
body
-
>
isKind
(
ParseNodeKind
:
:
Catch
)
)
{
BinaryNode
*
catchNode
=
&
body
-
>
as
<
BinaryNode
>
(
)
;
kind
=
(
!
catchNode
-
>
left
(
)
|
|
catchNode
-
>
left
(
)
-
>
isKind
(
ParseNodeKind
:
:
Name
)
)
?
ScopeKind
:
:
SimpleCatch
:
ScopeKind
:
:
Catch
;
}
else
{
kind
=
lexicalScope
-
>
kind
(
)
;
}
if
(
!
lse
.
emitScope
(
kind
lexicalScope
-
>
scopeBindings
(
)
)
)
{
return
false
;
}
if
(
body
-
>
isKind
(
ParseNodeKind
:
:
ForStmt
)
)
{
if
(
!
emitFor
(
&
body
-
>
as
<
ForNode
>
(
)
&
lse
.
emitterScope
(
)
)
)
{
return
false
;
}
}
else
{
if
(
!
emitLexicalScopeBody
(
body
SUPPRESS_LINENOTE
)
)
{
return
false
;
}
}
if
(
!
lse
.
emitEnd
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitWith
(
BinaryNode
*
withNode
)
{
if
(
!
updateSourceCoordNotes
(
withNode
-
>
left
(
)
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
withNode
-
>
left
(
)
)
)
{
return
false
;
}
EmitterScope
emitterScope
(
this
)
;
if
(
!
emitterScope
.
enterWith
(
this
)
)
{
return
false
;
}
if
(
!
emitTree
(
withNode
-
>
right
(
)
)
)
{
return
false
;
}
return
emitterScope
.
leave
(
this
)
;
}
bool
BytecodeEmitter
:
:
emitCopyDataProperties
(
CopyOption
option
)
{
DebugOnly
<
int32_t
>
depth
=
bytecodeSection
(
)
.
stackDepth
(
)
;
uint32_t
argc
;
if
(
option
=
=
CopyOption
:
:
Filtered
)
{
MOZ_ASSERT
(
depth
>
2
)
;
argc
=
3
;
if
(
!
emitAtomOp
(
JSOp
:
:
GetIntrinsic
TaggedParserAtomIndex
:
:
WellKnown
:
:
CopyDataProperties
(
)
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
depth
>
1
)
;
argc
=
2
;
if
(
!
emitAtomOp
(
JSOp
:
:
GetIntrinsic
TaggedParserAtomIndex
:
:
WellKnown
:
:
CopyDataPropertiesUnfiltered
(
)
)
)
{
return
false
;
}
}
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Pick
argc
+
1
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Pick
argc
+
1
)
)
{
return
false
;
}
if
(
option
=
=
CopyOption
:
:
Filtered
)
{
if
(
!
emit2
(
JSOp
:
:
Pick
argc
+
1
)
)
{
return
false
;
}
}
if
(
!
emitCall
(
JSOp
:
:
CallIgnoresRv
argc
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
MOZ_ASSERT
(
depth
-
int
(
argc
)
=
=
bytecodeSection
(
)
.
stackDepth
(
)
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitBigIntOp
(
BigIntLiteral
*
bigint
)
{
GCThingIndex
index
;
if
(
!
perScriptData
(
)
.
gcThingList
(
)
.
append
(
bigint
&
index
)
)
{
return
false
;
}
return
emitGCIndexOp
(
JSOp
:
:
BigInt
index
)
;
}
bool
BytecodeEmitter
:
:
emitIterator
(
)
{
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Symbol
uint8_t
(
JS
:
:
SymbolCode
:
:
iterator
)
)
)
{
return
false
;
}
if
(
!
emitElemOpBase
(
JSOp
:
:
GetElem
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
if
(
!
emitCall
(
JSOp
:
:
CallIter
0
)
)
{
return
false
;
}
if
(
!
emitCheckIsObj
(
CheckIsObjectKind
:
:
GetIterator
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
next
(
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitAsyncIterator
(
)
{
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Symbol
uint8_t
(
JS
:
:
SymbolCode
:
:
asyncIterator
)
)
)
{
return
false
;
}
if
(
!
emitElemOpBase
(
JSOp
:
:
GetElem
)
)
{
return
false
;
}
InternalIfEmitter
ifAsyncIterIsUndefined
(
this
)
;
if
(
!
emitPushNotUndefinedOrNull
(
)
)
{
return
false
;
}
if
(
!
ifAsyncIterIsUndefined
.
emitThenElse
(
IfEmitter
:
:
ConditionKind
:
:
Negative
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Symbol
uint8_t
(
JS
:
:
SymbolCode
:
:
iterator
)
)
)
{
return
false
;
}
if
(
!
emitElemOpBase
(
JSOp
:
:
GetElem
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
if
(
!
emitCall
(
JSOp
:
:
CallIter
0
)
)
{
return
false
;
}
if
(
!
emitCheckIsObj
(
CheckIsObjectKind
:
:
GetIterator
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
next
(
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
ToAsyncIter
)
)
{
return
false
;
}
if
(
!
ifAsyncIterIsUndefined
.
emitElse
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
if
(
!
emitCall
(
JSOp
:
:
CallIter
0
)
)
{
return
false
;
}
if
(
!
emitCheckIsObj
(
CheckIsObjectKind
:
:
GetIterator
)
)
{
return
false
;
}
if
(
!
ifAsyncIterIsUndefined
.
emitEnd
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
next
(
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitSpread
(
bool
allowSelfHosted
)
{
LoopControl
loopInfo
(
this
StatementKind
:
:
Spread
)
;
if
(
!
loopInfo
.
emitLoopHead
(
this
Nothing
(
)
)
)
{
return
false
;
}
{
#
ifdef
DEBUG
auto
loopDepth
=
bytecodeSection
(
)
.
stackDepth
(
)
;
#
endif
if
(
!
emitDupAt
(
3
2
)
)
{
return
false
;
}
if
(
!
emitIteratorNext
(
Nothing
(
)
IteratorKind
:
:
Sync
allowSelfHosted
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
done
(
)
)
)
{
return
false
;
}
if
(
!
emitJump
(
JSOp
:
:
JumpIfTrue
&
loopInfo
.
breaks
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
value
(
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
InitElemInc
)
)
{
return
false
;
}
if
(
!
loopInfo
.
emitLoopEnd
(
this
JSOp
:
:
Goto
TryNoteKind
:
:
ForOf
)
)
{
return
false
;
}
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
=
=
loopDepth
)
;
}
bytecodeSection
(
)
.
setStackDepth
(
bytecodeSection
(
)
.
stackDepth
(
)
+
1
)
;
MOZ_ASSERT
(
!
loopInfo
.
continues
.
offset
.
valid
(
)
)
;
if
(
!
emit2
(
JSOp
:
:
Pick
4
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Pick
4
)
)
{
return
false
;
}
return
emitPopN
(
3
)
;
}
bool
BytecodeEmitter
:
:
emitInitializeForInOrOfTarget
(
TernaryNode
*
forHead
)
{
MOZ_ASSERT
(
forHead
-
>
isKind
(
ParseNodeKind
:
:
ForIn
)
|
|
forHead
-
>
isKind
(
ParseNodeKind
:
:
ForOf
)
)
;
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
>
=
1
"
must
have
a
per
-
iteration
value
for
initializing
"
)
;
ParseNode
*
target
=
forHead
-
>
kid1
(
)
;
MOZ_ASSERT
(
!
forHead
-
>
kid2
(
)
)
;
if
(
!
parser
-
>
astGenerator
(
)
.
isDeclarationList
(
target
)
)
{
return
emitAssignmentOrInit
(
ParseNodeKind
:
:
AssignExpr
target
nullptr
)
;
}
if
(
!
updateSourceCoordNotes
(
target
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
MOZ_ASSERT
(
target
-
>
isForLoopDeclaration
(
)
)
;
target
=
parser
-
>
astGenerator
(
)
.
singleBindingFromDeclaration
(
&
target
-
>
as
<
ListNode
>
(
)
)
;
NameNode
*
nameNode
=
nullptr
;
if
(
target
-
>
isKind
(
ParseNodeKind
:
:
Name
)
)
{
nameNode
=
&
target
-
>
as
<
NameNode
>
(
)
;
}
else
if
(
target
-
>
isKind
(
ParseNodeKind
:
:
AssignExpr
)
|
|
target
-
>
isKind
(
ParseNodeKind
:
:
InitExpr
)
)
{
BinaryNode
*
assignNode
=
&
target
-
>
as
<
BinaryNode
>
(
)
;
if
(
assignNode
-
>
left
(
)
-
>
is
<
NameNode
>
(
)
)
{
nameNode
=
&
assignNode
-
>
left
(
)
-
>
as
<
NameNode
>
(
)
;
}
}
if
(
nameNode
)
{
auto
nameAtom
=
nameNode
-
>
name
(
)
;
NameOpEmitter
noe
(
this
nameAtom
NameOpEmitter
:
:
Kind
:
:
Initialize
)
;
if
(
!
noe
.
prepareForRhs
(
)
)
{
return
false
;
}
if
(
noe
.
emittedBindOp
(
)
)
{
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
>
=
2
)
;
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
>
=
1
)
;
}
if
(
!
noe
.
emitAssignment
(
)
)
{
return
false
;
}
return
true
;
}
MOZ_ASSERT
(
!
target
-
>
isKind
(
ParseNodeKind
:
:
AssignExpr
)
&
&
!
target
-
>
isKind
(
ParseNodeKind
:
:
InitExpr
)
"
for
-
in
/
of
loop
destructuring
declarations
can
'
t
have
initializers
"
)
;
MOZ_ASSERT
(
target
-
>
isKind
(
ParseNodeKind
:
:
ArrayExpr
)
|
|
target
-
>
isKind
(
ParseNodeKind
:
:
ObjectExpr
)
)
;
return
emitDestructuringOps
(
&
target
-
>
as
<
ListNode
>
(
)
DestructuringFlavor
:
:
Declaration
)
;
}
bool
BytecodeEmitter
:
:
emitForOf
(
ForNode
*
forOfLoop
const
EmitterScope
*
headLexicalEmitterScope
)
{
MOZ_ASSERT
(
forOfLoop
-
>
isKind
(
ParseNodeKind
:
:
ForStmt
)
)
;
TernaryNode
*
forOfHead
=
forOfLoop
-
>
head
(
)
;
MOZ_ASSERT
(
forOfHead
-
>
isKind
(
ParseNodeKind
:
:
ForOf
)
)
;
unsigned
iflags
=
forOfLoop
-
>
iflags
(
)
;
IteratorKind
iterKind
=
(
iflags
&
JSITER_FORAWAITOF
)
?
IteratorKind
:
:
Async
:
IteratorKind
:
:
Sync
;
MOZ_ASSERT_IF
(
iterKind
=
=
IteratorKind
:
:
Async
sc
-
>
isSuspendableContext
(
)
)
;
MOZ_ASSERT_IF
(
iterKind
=
=
IteratorKind
:
:
Async
sc
-
>
asSuspendableContext
(
)
-
>
isAsync
(
)
)
;
ParseNode
*
forHeadExpr
=
forOfHead
-
>
kid3
(
)
;
ForOfEmitter
forOf
(
this
headLexicalEmitterScope
allowSelfHostedIter
(
forHeadExpr
)
iterKind
)
;
if
(
!
forOf
.
emitIterated
(
)
)
{
return
false
;
}
if
(
!
updateSourceCoordNotes
(
forHeadExpr
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
forHeadExpr
)
)
{
return
false
;
}
if
(
headLexicalEmitterScope
)
{
DebugOnly
<
ParseNode
*
>
forOfTarget
=
forOfHead
-
>
kid1
(
)
;
MOZ_ASSERT
(
forOfTarget
-
>
isKind
(
ParseNodeKind
:
:
LetDecl
)
|
|
forOfTarget
-
>
isKind
(
ParseNodeKind
:
:
ConstDecl
)
)
;
}
if
(
!
forOf
.
emitInitialize
(
Some
(
forOfHead
-
>
pn_pos
.
begin
)
)
)
{
return
false
;
}
if
(
!
emitInitializeForInOrOfTarget
(
forOfHead
)
)
{
return
false
;
}
if
(
!
forOf
.
emitBody
(
)
)
{
return
false
;
}
ParseNode
*
forBody
=
forOfLoop
-
>
body
(
)
;
if
(
!
emitTree
(
forBody
)
)
{
return
false
;
}
if
(
!
forOf
.
emitEnd
(
Some
(
forHeadExpr
-
>
pn_pos
.
begin
)
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitForIn
(
ForNode
*
forInLoop
const
EmitterScope
*
headLexicalEmitterScope
)
{
TernaryNode
*
forInHead
=
forInLoop
-
>
head
(
)
;
MOZ_ASSERT
(
forInHead
-
>
isKind
(
ParseNodeKind
:
:
ForIn
)
)
;
ForInEmitter
forIn
(
this
headLexicalEmitterScope
)
;
ParseNode
*
forInTarget
=
forInHead
-
>
kid1
(
)
;
if
(
parser
-
>
astGenerator
(
)
.
isDeclarationList
(
forInTarget
)
)
{
ParseNode
*
decl
=
parser
-
>
astGenerator
(
)
.
singleBindingFromDeclaration
(
&
forInTarget
-
>
as
<
ListNode
>
(
)
)
;
if
(
decl
-
>
isKind
(
ParseNodeKind
:
:
AssignExpr
)
|
|
decl
-
>
isKind
(
ParseNodeKind
:
:
InitExpr
)
)
{
BinaryNode
*
assignNode
=
&
decl
-
>
as
<
BinaryNode
>
(
)
;
if
(
assignNode
-
>
left
(
)
-
>
is
<
NameNode
>
(
)
)
{
NameNode
*
nameNode
=
&
assignNode
-
>
left
(
)
-
>
as
<
NameNode
>
(
)
;
ParseNode
*
initializer
=
assignNode
-
>
right
(
)
;
MOZ_ASSERT
(
forInTarget
-
>
isKind
(
ParseNodeKind
:
:
VarStmt
)
"
for
-
in
initializers
are
only
permitted
for
|
var
|
declarations
"
)
;
if
(
!
updateSourceCoordNotes
(
decl
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
auto
nameAtom
=
nameNode
-
>
name
(
)
;
NameOpEmitter
noe
(
this
nameAtom
NameOpEmitter
:
:
Kind
:
:
Initialize
)
;
if
(
!
noe
.
prepareForRhs
(
)
)
{
return
false
;
}
if
(
!
emitInitializer
(
initializer
nameNode
)
)
{
return
false
;
}
if
(
!
noe
.
emitAssignment
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
}
}
if
(
!
forIn
.
emitIterated
(
)
)
{
return
false
;
}
ParseNode
*
expr
=
forInHead
-
>
kid3
(
)
;
if
(
!
updateSourceCoordNotes
(
expr
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
expr
)
)
{
return
false
;
}
MOZ_ASSERT
(
forInLoop
-
>
iflags
(
)
=
=
0
)
;
MOZ_ASSERT_IF
(
headLexicalEmitterScope
forInTarget
-
>
isKind
(
ParseNodeKind
:
:
LetDecl
)
|
|
forInTarget
-
>
isKind
(
ParseNodeKind
:
:
ConstDecl
)
)
;
if
(
!
forIn
.
emitInitialize
(
)
)
{
return
false
;
}
if
(
!
emitInitializeForInOrOfTarget
(
forInHead
)
)
{
return
false
;
}
if
(
!
forIn
.
emitBody
(
)
)
{
return
false
;
}
ParseNode
*
forBody
=
forInLoop
-
>
body
(
)
;
if
(
!
emitTree
(
forBody
)
)
{
return
false
;
}
if
(
!
forIn
.
emitEnd
(
Some
(
forInHead
-
>
pn_pos
.
begin
)
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitCStyleFor
(
ForNode
*
forNode
const
EmitterScope
*
headLexicalEmitterScope
)
{
TernaryNode
*
forHead
=
forNode
-
>
head
(
)
;
ParseNode
*
forBody
=
forNode
-
>
body
(
)
;
ParseNode
*
init
=
forHead
-
>
kid1
(
)
;
ParseNode
*
cond
=
forHead
-
>
kid2
(
)
;
ParseNode
*
update
=
forHead
-
>
kid3
(
)
;
bool
isLet
=
init
&
&
init
-
>
isKind
(
ParseNodeKind
:
:
LetDecl
)
;
CForEmitter
cfor
(
this
isLet
?
headLexicalEmitterScope
:
nullptr
)
;
if
(
!
cfor
.
emitInit
(
init
?
Some
(
init
-
>
pn_pos
.
begin
)
:
Nothing
(
)
)
)
{
return
false
;
}
if
(
init
)
{
if
(
init
-
>
isForLoopDeclaration
(
)
)
{
if
(
!
emitTree
(
init
)
)
{
return
false
;
}
}
else
{
if
(
!
updateSourceCoordNotes
(
init
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
init
ValueUsage
:
:
IgnoreValue
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
}
if
(
!
cfor
.
emitCond
(
cond
?
Some
(
cond
-
>
pn_pos
.
begin
)
:
Nothing
(
)
)
)
{
return
false
;
}
if
(
cond
)
{
if
(
!
updateSourceCoordNotes
(
cond
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
cond
)
)
{
return
false
;
}
}
if
(
!
cfor
.
emitBody
(
cond
?
CForEmitter
:
:
Cond
:
:
Present
:
CForEmitter
:
:
Cond
:
:
Missing
)
)
{
return
false
;
}
if
(
!
emitTree
(
forBody
)
)
{
return
false
;
}
if
(
!
cfor
.
emitUpdate
(
update
?
CForEmitter
:
:
Update
:
:
Present
:
CForEmitter
:
:
Update
:
:
Missing
update
?
Some
(
update
-
>
pn_pos
.
begin
)
:
Nothing
(
)
)
)
{
return
false
;
}
if
(
update
)
{
if
(
!
updateSourceCoordNotes
(
update
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
update
ValueUsage
:
:
IgnoreValue
)
)
{
return
false
;
}
}
if
(
!
cfor
.
emitEnd
(
Some
(
forNode
-
>
pn_pos
.
begin
)
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitFor
(
ForNode
*
forNode
const
EmitterScope
*
headLexicalEmitterScope
)
{
if
(
forNode
-
>
head
(
)
-
>
isKind
(
ParseNodeKind
:
:
ForHead
)
)
{
return
emitCStyleFor
(
forNode
headLexicalEmitterScope
)
;
}
if
(
!
updateLineNumberNotes
(
forNode
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
forNode
-
>
head
(
)
-
>
isKind
(
ParseNodeKind
:
:
ForIn
)
)
{
return
emitForIn
(
forNode
headLexicalEmitterScope
)
;
}
MOZ_ASSERT
(
forNode
-
>
head
(
)
-
>
isKind
(
ParseNodeKind
:
:
ForOf
)
)
;
return
emitForOf
(
forNode
headLexicalEmitterScope
)
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitFunction
(
FunctionNode
*
funNode
bool
needsProto
)
{
FunctionBox
*
funbox
=
funNode
-
>
funbox
(
)
;
FunctionEmitter
fe
(
this
funbox
funNode
-
>
syntaxKind
(
)
funNode
-
>
functionIsHoisted
(
)
?
FunctionEmitter
:
:
IsHoisted
:
:
Yes
:
FunctionEmitter
:
:
IsHoisted
:
:
No
)
;
if
(
funbox
-
>
wasEmittedByEnclosingScript
(
)
)
{
if
(
!
fe
.
emitAgain
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
funNode
-
>
functionIsHoisted
(
)
)
;
}
else
if
(
funbox
-
>
isInterpreted
(
)
)
{
if
(
!
funbox
-
>
emitBytecode
)
{
return
fe
.
emitLazy
(
)
;
}
if
(
!
fe
.
prepareForNonLazy
(
)
)
{
return
false
;
}
BytecodeEmitter
bce2
(
this
parser
funbox
compilationState
emitterMode
)
;
if
(
!
bce2
.
init
(
funNode
-
>
pn_pos
)
)
{
return
false
;
}
if
(
!
bce2
.
emitFunctionScript
(
funNode
)
)
{
return
false
;
}
if
(
!
fe
.
emitNonLazyEnd
(
)
)
{
return
false
;
}
}
else
{
if
(
!
fe
.
emitAsmJSModule
(
)
)
{
return
false
;
}
}
if
(
emitterMode
=
=
EmitterMode
:
:
SelfHosting
)
{
if
(
sc
-
>
isTopLevelContext
(
)
)
{
MOZ_ASSERT
(
!
funbox
-
>
isLambda
(
)
)
;
MOZ_ASSERT
(
funbox
-
>
explicitName
(
)
)
;
prevSelfHostedTopLevelFunction
=
funbox
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDo
(
BinaryNode
*
doNode
)
{
ParseNode
*
bodyNode
=
doNode
-
>
left
(
)
;
DoWhileEmitter
doWhile
(
this
)
;
if
(
!
doWhile
.
emitBody
(
Some
(
doNode
-
>
pn_pos
.
begin
)
getOffsetForLoop
(
bodyNode
)
)
)
{
return
false
;
}
if
(
!
emitTree
(
bodyNode
)
)
{
return
false
;
}
if
(
!
doWhile
.
emitCond
(
)
)
{
return
false
;
}
ParseNode
*
condNode
=
doNode
-
>
right
(
)
;
if
(
!
updateSourceCoordNotes
(
condNode
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
condNode
)
)
{
return
false
;
}
if
(
!
doWhile
.
emitEnd
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitWhile
(
BinaryNode
*
whileNode
)
{
ParseNode
*
bodyNode
=
whileNode
-
>
right
(
)
;
WhileEmitter
wh
(
this
)
;
ParseNode
*
condNode
=
whileNode
-
>
left
(
)
;
if
(
!
wh
.
emitCond
(
Some
(
whileNode
-
>
pn_pos
.
begin
)
getOffsetForLoop
(
condNode
)
Some
(
whileNode
-
>
pn_pos
.
end
)
)
)
{
return
false
;
}
if
(
!
updateSourceCoordNotes
(
condNode
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
condNode
)
)
{
return
false
;
}
if
(
!
wh
.
emitBody
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
bodyNode
)
)
{
return
false
;
}
if
(
!
wh
.
emitEnd
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitBreak
(
TaggedParserAtomIndex
label
)
{
BreakableControl
*
target
;
if
(
label
)
{
auto
hasSameLabel
=
[
label
]
(
LabelControl
*
labelControl
)
{
return
labelControl
-
>
label
(
)
=
=
label
;
}
;
target
=
findInnermostNestableControl
<
LabelControl
>
(
hasSameLabel
)
;
}
else
{
auto
isNotLabel
=
[
]
(
BreakableControl
*
control
)
{
return
!
control
-
>
is
<
LabelControl
>
(
)
;
}
;
target
=
findInnermostNestableControl
<
BreakableControl
>
(
isNotLabel
)
;
}
return
emitGoto
(
target
&
target
-
>
breaks
GotoKind
:
:
Break
)
;
}
bool
BytecodeEmitter
:
:
emitContinue
(
TaggedParserAtomIndex
label
)
{
LoopControl
*
target
=
nullptr
;
if
(
label
)
{
NestableControl
*
control
=
innermostNestableControl
;
while
(
!
control
-
>
is
<
LabelControl
>
(
)
|
|
control
-
>
as
<
LabelControl
>
(
)
.
label
(
)
!
=
label
)
{
if
(
control
-
>
is
<
LoopControl
>
(
)
)
{
target
=
&
control
-
>
as
<
LoopControl
>
(
)
;
}
control
=
control
-
>
enclosing
(
)
;
}
}
else
{
target
=
findInnermostNestableControl
<
LoopControl
>
(
)
;
}
return
emitGoto
(
target
&
target
-
>
continues
GotoKind
:
:
Continue
)
;
}
bool
BytecodeEmitter
:
:
emitGetFunctionThis
(
NameNode
*
thisName
)
{
MOZ_ASSERT
(
sc
-
>
hasFunctionThisBinding
(
)
)
;
MOZ_ASSERT
(
thisName
-
>
isName
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotThis
(
)
)
)
;
return
emitGetFunctionThis
(
Some
(
thisName
-
>
pn_pos
.
begin
)
)
;
}
bool
BytecodeEmitter
:
:
emitGetFunctionThis
(
const
mozilla
:
:
Maybe
<
uint32_t
>
&
offset
)
{
if
(
offset
)
{
if
(
!
updateLineNumberNotes
(
*
offset
)
)
{
return
false
;
}
}
if
(
!
emitGetName
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotThis
(
)
)
)
{
return
false
;
}
if
(
sc
-
>
needsThisTDZChecks
(
)
)
{
if
(
!
emit1
(
JSOp
:
:
CheckThis
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitGetThisForSuperBase
(
UnaryNode
*
superBase
)
{
MOZ_ASSERT
(
superBase
-
>
isKind
(
ParseNodeKind
:
:
SuperBase
)
)
;
NameNode
*
nameNode
=
&
superBase
-
>
kid
(
)
-
>
as
<
NameNode
>
(
)
;
return
emitGetFunctionThis
(
nameNode
)
;
}
bool
BytecodeEmitter
:
:
emitThisLiteral
(
ThisLiteral
*
pn
)
{
if
(
ParseNode
*
kid
=
pn
-
>
kid
(
)
)
{
NameNode
*
thisName
=
&
kid
-
>
as
<
NameNode
>
(
)
;
return
emitGetFunctionThis
(
thisName
)
;
}
if
(
sc
-
>
thisBinding
(
)
=
=
ThisBinding
:
:
Module
)
{
return
emit1
(
JSOp
:
:
Undefined
)
;
}
MOZ_ASSERT
(
sc
-
>
thisBinding
(
)
=
=
ThisBinding
:
:
Global
)
;
return
emit1
(
JSOp
:
:
GlobalThis
)
;
}
bool
BytecodeEmitter
:
:
emitCheckDerivedClassConstructorReturn
(
)
{
MOZ_ASSERT
(
lookupName
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotThis
(
)
)
.
hasKnownSlot
(
)
)
;
if
(
!
emitGetName
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotThis
(
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
CheckReturn
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
SetRval
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitReturn
(
UnaryNode
*
returnNode
)
{
if
(
!
updateSourceCoordNotes
(
returnNode
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
bool
needsIteratorResult
=
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
needsIteratorResult
(
)
;
if
(
needsIteratorResult
)
{
if
(
!
emitPrepareIteratorResult
(
)
)
{
return
false
;
}
}
if
(
!
updateSourceCoordNotes
(
returnNode
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
ParseNode
*
expr
=
returnNode
-
>
kid
(
)
)
{
if
(
!
emitTree
(
expr
)
)
{
return
false
;
}
if
(
sc
-
>
asSuspendableContext
(
)
-
>
isAsync
(
)
&
&
sc
-
>
asSuspendableContext
(
)
-
>
isGenerator
(
)
)
{
if
(
!
emitAwaitInInnermostScope
(
)
)
{
return
false
;
}
}
}
else
{
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
}
if
(
needsIteratorResult
)
{
if
(
!
emitFinishIteratorResult
(
true
)
)
{
return
false
;
}
}
if
(
!
updateSourceCoordNotes
(
*
functionBodyEndPos
)
)
{
return
false
;
}
BytecodeOffset
top
=
bytecodeSection
(
)
.
offset
(
)
;
bool
needsFinalYield
=
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
needsFinalYield
(
)
;
bool
isDerivedClassConstructor
=
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
isDerivedClassConstructor
(
)
;
if
(
!
emit1
(
(
needsFinalYield
|
|
isDerivedClassConstructor
)
?
JSOp
:
:
SetRval
:
JSOp
:
:
Return
)
)
{
return
false
;
}
NonLocalExitControl
nle
(
this
NonLocalExitControl
:
:
Return
)
;
if
(
!
nle
.
prepareForNonLocalJumpToOutermost
(
)
)
{
return
false
;
}
if
(
needsFinalYield
)
{
NameLocation
loc
=
*
locationOfNameBoundInScopeType
<
FunctionScope
>
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotGenerator
(
)
varEmitterScope
)
;
if
(
sc
-
>
asFunctionBox
(
)
-
>
needsPromiseResult
(
)
)
{
if
(
!
emit1
(
JSOp
:
:
GetRval
)
)
{
return
false
;
}
if
(
!
emitGetNameAtLocation
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotGenerator
(
)
loc
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
AsyncResolve
uint8_t
(
AsyncFunctionResolveKind
:
:
Fulfill
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
SetRval
)
)
{
return
false
;
}
}
if
(
!
emitGetNameAtLocation
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotGenerator
(
)
loc
)
)
{
return
false
;
}
if
(
!
emitYieldOp
(
JSOp
:
:
FinalYieldRval
)
)
{
return
false
;
}
}
else
if
(
isDerivedClassConstructor
)
{
MOZ_ASSERT
(
JSOp
(
bytecodeSection
(
)
.
code
(
)
[
top
.
value
(
)
]
)
=
=
JSOp
:
:
SetRval
)
;
if
(
!
emitJump
(
JSOp
:
:
Goto
&
endOfDerivedClassConstructorBody
)
)
{
return
false
;
}
}
else
if
(
top
+
BytecodeOffsetDiff
(
JSOpLength_Return
)
!
=
bytecodeSection
(
)
.
offset
(
)
)
{
bytecodeSection
(
)
.
code
(
)
[
top
.
value
(
)
]
=
jsbytecode
(
JSOp
:
:
SetRval
)
;
if
(
!
emitReturnRval
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitGetDotGeneratorInScope
(
EmitterScope
&
currentScope
)
{
if
(
!
sc
-
>
isFunction
(
)
&
&
sc
-
>
isModuleContext
(
)
&
&
sc
-
>
asModuleContext
(
)
-
>
isAsync
(
)
)
{
NameLocation
loc
=
*
locationOfNameBoundInScopeType
<
ModuleScope
>
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotGenerator
(
)
&
currentScope
)
;
return
emitGetNameAtLocation
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotGenerator
(
)
loc
)
;
}
NameLocation
loc
=
*
locationOfNameBoundInScopeType
<
FunctionScope
>
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotGenerator
(
)
&
currentScope
)
;
return
emitGetNameAtLocation
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotGenerator
(
)
loc
)
;
}
bool
BytecodeEmitter
:
:
emitInitialYield
(
UnaryNode
*
yieldNode
)
{
if
(
!
emitTree
(
yieldNode
-
>
kid
(
)
)
)
{
return
false
;
}
if
(
!
emitYieldOp
(
JSOp
:
:
InitialYield
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
CheckResumeKind
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitYield
(
UnaryNode
*
yieldNode
)
{
MOZ_ASSERT
(
sc
-
>
isFunctionBox
(
)
)
;
MOZ_ASSERT
(
sc
-
>
asFunctionBox
(
)
-
>
isGenerator
(
)
)
;
MOZ_ASSERT
(
yieldNode
-
>
isKind
(
ParseNodeKind
:
:
YieldExpr
)
)
;
bool
needsIteratorResult
=
sc
-
>
asFunctionBox
(
)
-
>
needsIteratorResult
(
)
;
if
(
needsIteratorResult
)
{
if
(
!
emitPrepareIteratorResult
(
)
)
{
return
false
;
}
}
if
(
ParseNode
*
expr
=
yieldNode
-
>
kid
(
)
)
{
if
(
!
emitTree
(
expr
)
)
{
return
false
;
}
}
else
{
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
}
if
(
sc
-
>
asSuspendableContext
(
)
-
>
isAsync
(
)
)
{
MOZ_ASSERT
(
!
needsIteratorResult
)
;
if
(
!
emitAwaitInInnermostScope
(
)
)
{
return
false
;
}
}
if
(
needsIteratorResult
)
{
if
(
!
emitFinishIteratorResult
(
false
)
)
{
return
false
;
}
}
if
(
!
emitGetDotGeneratorInInnermostScope
(
)
)
{
return
false
;
}
if
(
!
emitYieldOp
(
JSOp
:
:
Yield
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
CheckResumeKind
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitAwaitInInnermostScope
(
UnaryNode
*
awaitNode
)
{
MOZ_ASSERT
(
sc
-
>
isSuspendableContext
(
)
)
;
MOZ_ASSERT
(
awaitNode
-
>
isKind
(
ParseNodeKind
:
:
AwaitExpr
)
)
;
if
(
!
emitTree
(
awaitNode
-
>
kid
(
)
)
)
{
return
false
;
}
return
emitAwaitInInnermostScope
(
)
;
}
bool
BytecodeEmitter
:
:
emitAwaitInScope
(
EmitterScope
&
currentScope
)
{
if
(
!
emit1
(
JSOp
:
:
CanSkipAwait
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
MaybeExtractAwaitValue
)
)
{
return
false
;
}
InternalIfEmitter
ifCanSkip
(
this
)
;
if
(
!
ifCanSkip
.
emitThen
(
IfEmitter
:
:
ConditionKind
:
:
Negative
)
)
{
return
false
;
}
if
(
sc
-
>
asSuspendableContext
(
)
-
>
needsPromiseResult
(
)
)
{
if
(
!
emitGetDotGeneratorInScope
(
currentScope
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
AsyncAwait
)
)
{
return
false
;
}
}
if
(
!
emitGetDotGeneratorInScope
(
currentScope
)
)
{
return
false
;
}
if
(
!
emitYieldOp
(
JSOp
:
:
Await
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
CheckResumeKind
)
)
{
return
false
;
}
if
(
!
ifCanSkip
.
emitEnd
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
ifCanSkip
.
popped
(
)
=
=
0
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitYieldStar
(
ParseNode
*
iter
)
{
MOZ_ASSERT
(
sc
-
>
isSuspendableContext
(
)
)
;
MOZ_ASSERT
(
sc
-
>
asSuspendableContext
(
)
-
>
isGenerator
(
)
)
;
IteratorKind
iterKind
=
sc
-
>
asSuspendableContext
(
)
-
>
isAsync
(
)
?
IteratorKind
:
:
Async
:
IteratorKind
:
:
Sync
;
bool
needsIteratorResult
=
sc
-
>
asSuspendableContext
(
)
-
>
needsIteratorResult
(
)
;
if
(
!
emitTree
(
iter
)
)
{
return
false
;
}
if
(
iterKind
=
=
IteratorKind
:
:
Async
)
{
if
(
!
emitAsyncIterator
(
)
)
{
return
false
;
}
}
else
{
if
(
!
emitIterator
(
)
)
{
return
false
;
}
}
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
if
(
!
emitPushResumeKind
(
GeneratorResumeKind
:
:
Next
)
)
{
return
false
;
}
const
int32_t
startDepth
=
bytecodeSection
(
)
.
stackDepth
(
)
;
MOZ_ASSERT
(
startDepth
>
=
4
)
;
LoopControl
loopInfo
(
this
StatementKind
:
:
YieldStar
)
;
if
(
!
loopInfo
.
emitLoopHead
(
this
Nothing
(
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emitPushResumeKind
(
GeneratorResumeKind
:
:
Next
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
StrictEq
)
)
{
return
false
;
}
InternalIfEmitter
ifKind
(
this
)
;
if
(
!
ifKind
.
emitThenElse
(
)
)
{
return
false
;
}
{
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Unpick
2
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup2
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Pick
4
)
)
{
return
false
;
}
if
(
!
emitCall
(
JSOp
:
:
Call
1
iter
)
)
{
return
false
;
}
if
(
iterKind
=
=
IteratorKind
:
:
Async
)
{
if
(
!
emitAwaitInInnermostScope
(
)
)
{
return
false
;
}
}
if
(
!
emitCheckIsObj
(
CheckIsObjectKind
:
:
IteratorNext
)
)
{
return
false
;
}
}
if
(
!
ifKind
.
emitElseIf
(
Nothing
(
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emitPushResumeKind
(
GeneratorResumeKind
:
:
Throw
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
StrictEq
)
)
{
return
false
;
}
if
(
!
ifKind
.
emitThenElse
(
)
)
{
return
false
;
}
{
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
emitDupAt
(
1
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
throw_
(
)
)
)
{
return
false
;
}
InternalIfEmitter
ifThrowMethodIsNotDefined
(
this
)
;
if
(
!
emitPushNotUndefinedOrNull
(
)
)
{
return
false
;
}
if
(
!
ifThrowMethodIsNotDefined
.
emitThenElse
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Pick
2
)
)
{
return
false
;
}
if
(
!
emitCall
(
JSOp
:
:
Call
1
iter
)
)
{
return
false
;
}
if
(
iterKind
=
=
IteratorKind
:
:
Async
)
{
if
(
!
emitAwaitInInnermostScope
(
)
)
{
return
false
;
}
}
if
(
!
emitCheckIsObj
(
CheckIsObjectKind
:
:
IteratorThrow
)
)
{
return
false
;
}
if
(
!
ifThrowMethodIsNotDefined
.
emitElse
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
emitIteratorCloseInInnermostScope
(
iterKind
CompletionKind
:
:
Normal
allowSelfHostedIter
(
iter
)
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
ThrowMsg
uint8_t
(
ThrowMsgKind
:
:
IteratorNoThrow
)
)
)
{
return
false
;
}
if
(
!
ifThrowMethodIsNotDefined
.
emitEnd
(
)
)
{
return
false
;
}
}
if
(
!
ifKind
.
emitElse
(
)
)
{
return
false
;
}
{
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
emitDupAt
(
1
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
return_
(
)
)
)
{
return
false
;
}
InternalIfEmitter
ifReturnMethodIsDefined
(
this
)
;
if
(
!
emitPushNotUndefinedOrNull
(
)
)
{
return
false
;
}
if
(
!
ifReturnMethodIsDefined
.
emitThenElse
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Pick
2
)
)
{
return
false
;
}
if
(
needsIteratorResult
)
{
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
value
(
)
)
)
{
return
false
;
}
}
if
(
!
emitCall
(
JSOp
:
:
Call
1
)
)
{
return
false
;
}
if
(
iterKind
=
=
IteratorKind
:
:
Async
)
{
if
(
!
emitAwaitInInnermostScope
(
)
)
{
return
false
;
}
}
if
(
!
emitCheckIsObj
(
CheckIsObjectKind
:
:
IteratorReturn
)
)
{
return
false
;
}
InternalIfEmitter
ifReturnDone
(
this
)
;
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
done
(
)
)
)
{
return
false
;
}
if
(
!
ifReturnDone
.
emitThenElse
(
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
value
(
)
)
)
{
return
false
;
}
if
(
needsIteratorResult
)
{
if
(
!
emitPrepareIteratorResult
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
if
(
!
emitFinishIteratorResult
(
true
)
)
{
return
false
;
}
}
if
(
!
ifReturnDone
.
emitElse
(
)
)
{
return
false
;
}
if
(
!
emitJump
(
JSOp
:
:
Goto
&
loopInfo
.
continues
)
)
{
return
false
;
}
if
(
!
ifReturnDone
.
emitEnd
(
)
)
{
return
false
;
}
if
(
!
ifReturnMethodIsDefined
.
emitElse
(
)
)
{
return
false
;
}
if
(
!
emitPopN
(
2
)
)
{
return
false
;
}
if
(
iterKind
=
=
IteratorKind
:
:
Async
)
{
if
(
!
emitAwaitInInnermostScope
(
)
)
{
return
false
;
}
}
if
(
!
ifReturnMethodIsDefined
.
emitEnd
(
)
)
{
return
false
;
}
if
(
!
emitGetDotGeneratorInInnermostScope
(
)
)
{
return
false
;
}
if
(
!
emitPushResumeKind
(
GeneratorResumeKind
:
:
Return
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
CheckResumeKind
)
)
{
return
false
;
}
}
if
(
!
ifKind
.
emitEnd
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
done
(
)
)
)
{
return
false
;
}
if
(
!
emitJump
(
JSOp
:
:
JumpIfTrue
&
loopInfo
.
breaks
)
)
{
return
false
;
}
if
(
!
loopInfo
.
emitContinueTarget
(
this
)
)
{
return
false
;
}
if
(
iterKind
=
=
IteratorKind
:
:
Async
)
{
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
value
(
)
)
)
{
return
false
;
}
if
(
!
emitAwaitInInnermostScope
(
)
)
{
return
false
;
}
}
if
(
!
emitGetDotGeneratorInInnermostScope
(
)
)
{
return
false
;
}
if
(
!
emitYieldOp
(
JSOp
:
:
Yield
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Swap
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
loopInfo
.
emitLoopEnd
(
this
JSOp
:
:
Goto
TryNoteKind
:
:
Loop
)
)
{
return
false
;
}
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
=
=
startDepth
)
;
bytecodeSection
(
)
.
setStackDepth
(
startDepth
-
1
)
;
if
(
!
emit2
(
JSOp
:
:
Unpick
2
)
)
{
return
false
;
}
if
(
!
emitPopN
(
2
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetProp
TaggedParserAtomIndex
:
:
WellKnown
:
:
value
(
)
)
)
{
return
false
;
}
MOZ_ASSERT
(
bytecodeSection
(
)
.
stackDepth
(
)
=
=
startDepth
-
3
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitStatementList
(
ListNode
*
stmtList
)
{
for
(
ParseNode
*
stmt
:
stmtList
-
>
contents
(
)
)
{
if
(
!
emitTree
(
stmt
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitExpressionStatement
(
UnaryNode
*
exprStmt
)
{
MOZ_ASSERT
(
exprStmt
-
>
isKind
(
ParseNodeKind
:
:
ExpressionStmt
)
)
;
bool
wantval
=
false
;
bool
useful
=
false
;
if
(
sc
-
>
isTopLevelContext
(
)
)
{
useful
=
wantval
=
!
sc
-
>
noScriptRval
(
)
;
}
ParseNode
*
expr
=
exprStmt
-
>
kid
(
)
;
if
(
!
useful
)
{
if
(
!
checkSideEffects
(
expr
&
useful
)
)
{
return
false
;
}
if
(
innermostNestableControl
&
&
innermostNestableControl
-
>
is
<
LabelControl
>
(
)
&
&
innermostNestableControl
-
>
as
<
LabelControl
>
(
)
.
startOffset
(
)
>
=
bytecodeSection
(
)
.
offset
(
)
)
{
useful
=
true
;
}
}
if
(
useful
)
{
ValueUsage
valueUsage
=
wantval
?
ValueUsage
:
:
WantValue
:
ValueUsage
:
:
IgnoreValue
;
ExpressionStatementEmitter
ese
(
this
valueUsage
)
;
if
(
!
ese
.
prepareForExpr
(
Some
(
exprStmt
-
>
pn_pos
.
begin
)
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
expr
valueUsage
)
)
{
return
false
;
}
if
(
!
ese
.
emitEnd
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDeleteName
(
UnaryNode
*
deleteNode
)
{
MOZ_ASSERT
(
deleteNode
-
>
isKind
(
ParseNodeKind
:
:
DeleteNameExpr
)
)
;
NameNode
*
nameExpr
=
&
deleteNode
-
>
kid
(
)
-
>
as
<
NameNode
>
(
)
;
MOZ_ASSERT
(
nameExpr
-
>
isKind
(
ParseNodeKind
:
:
Name
)
)
;
return
emitAtomOp
(
JSOp
:
:
DelName
nameExpr
-
>
atom
(
)
)
;
}
bool
BytecodeEmitter
:
:
emitDeleteProperty
(
UnaryNode
*
deleteNode
)
{
MOZ_ASSERT
(
deleteNode
-
>
isKind
(
ParseNodeKind
:
:
DeletePropExpr
)
)
;
PropertyAccess
*
propExpr
=
&
deleteNode
-
>
kid
(
)
-
>
as
<
PropertyAccess
>
(
)
;
PropOpEmitter
poe
(
this
PropOpEmitter
:
:
Kind
:
:
Delete
propExpr
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
?
PropOpEmitter
:
:
ObjKind
:
:
Super
:
PropOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
propExpr
-
>
isSuper
(
)
)
{
UnaryNode
*
base
=
&
propExpr
-
>
expression
(
)
.
as
<
UnaryNode
>
(
)
;
if
(
!
emitGetThisForSuperBase
(
base
)
)
{
return
false
;
}
}
else
{
if
(
!
poe
.
prepareForObj
(
)
)
{
return
false
;
}
if
(
!
emitPropLHS
(
propExpr
)
)
{
return
false
;
}
}
if
(
!
poe
.
emitDelete
(
propExpr
-
>
key
(
)
.
atom
(
)
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDeleteElement
(
UnaryNode
*
deleteNode
)
{
MOZ_ASSERT
(
deleteNode
-
>
isKind
(
ParseNodeKind
:
:
DeleteElemExpr
)
)
;
PropertyByValue
*
elemExpr
=
&
deleteNode
-
>
kid
(
)
-
>
as
<
PropertyByValue
>
(
)
;
bool
isSuper
=
elemExpr
-
>
isSuper
(
)
;
DebugOnly
<
bool
>
isPrivate
=
elemExpr
-
>
key
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
;
MOZ_ASSERT
(
!
isPrivate
)
;
ElemOpEmitter
eoe
(
this
ElemOpEmitter
:
:
Kind
:
:
Delete
isSuper
?
ElemOpEmitter
:
:
ObjKind
:
:
Super
:
ElemOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
isSuper
)
{
if
(
!
eoe
.
prepareForObj
(
)
)
{
return
false
;
}
UnaryNode
*
base
=
&
elemExpr
-
>
expression
(
)
.
as
<
UnaryNode
>
(
)
;
if
(
!
emitGetThisForSuperBase
(
base
)
)
{
return
false
;
}
if
(
!
eoe
.
prepareForKey
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
&
elemExpr
-
>
key
(
)
)
)
{
return
false
;
}
}
else
{
if
(
!
emitElemObjAndKey
(
elemExpr
false
eoe
)
)
{
return
false
;
}
}
if
(
!
eoe
.
emitDelete
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDeleteExpression
(
UnaryNode
*
deleteNode
)
{
MOZ_ASSERT
(
deleteNode
-
>
isKind
(
ParseNodeKind
:
:
DeleteExpr
)
)
;
ParseNode
*
expression
=
deleteNode
-
>
kid
(
)
;
bool
useful
=
false
;
if
(
!
checkSideEffects
(
expression
&
useful
)
)
{
return
false
;
}
if
(
useful
)
{
if
(
!
emitTree
(
expression
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
return
emit1
(
JSOp
:
:
True
)
;
}
bool
BytecodeEmitter
:
:
emitDeleteOptionalChain
(
UnaryNode
*
deleteNode
)
{
MOZ_ASSERT
(
deleteNode
-
>
isKind
(
ParseNodeKind
:
:
DeleteOptionalChainExpr
)
)
;
OptionalEmitter
oe
(
this
bytecodeSection
(
)
.
stackDepth
(
)
)
;
ParseNode
*
kid
=
deleteNode
-
>
kid
(
)
;
switch
(
kid
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
ElemExpr
:
case
ParseNodeKind
:
:
OptionalElemExpr
:
{
auto
*
elemExpr
=
&
kid
-
>
as
<
PropertyByValueBase
>
(
)
;
if
(
!
emitDeleteElementInOptChain
(
elemExpr
oe
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
DotExpr
:
case
ParseNodeKind
:
:
OptionalDotExpr
:
{
auto
*
propExpr
=
&
kid
-
>
as
<
PropertyAccessBase
>
(
)
;
if
(
!
emitDeletePropertyInOptChain
(
propExpr
oe
)
)
{
return
false
;
}
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
optional
delete
ParseNodeKind
"
)
;
}
if
(
!
oe
.
emitOptionalJumpTarget
(
JSOp
:
:
True
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDeletePropertyInOptChain
(
PropertyAccessBase
*
propExpr
OptionalEmitter
&
oe
)
{
MOZ_ASSERT_IF
(
propExpr
-
>
is
<
PropertyAccess
>
(
)
!
propExpr
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
;
PropOpEmitter
poe
(
this
PropOpEmitter
:
:
Kind
:
:
Delete
PropOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
poe
.
prepareForObj
(
)
)
{
return
false
;
}
if
(
!
emitOptionalTree
(
&
propExpr
-
>
expression
(
)
oe
)
)
{
return
false
;
}
if
(
propExpr
-
>
isKind
(
ParseNodeKind
:
:
OptionalDotExpr
)
)
{
if
(
!
oe
.
emitJumpShortCircuit
(
)
)
{
return
false
;
}
}
if
(
!
poe
.
emitDelete
(
propExpr
-
>
key
(
)
.
atom
(
)
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDeleteElementInOptChain
(
PropertyByValueBase
*
elemExpr
OptionalEmitter
&
oe
)
{
MOZ_ASSERT_IF
(
elemExpr
-
>
is
<
PropertyByValue
>
(
)
!
elemExpr
-
>
as
<
PropertyByValue
>
(
)
.
isSuper
(
)
)
;
ElemOpEmitter
eoe
(
this
ElemOpEmitter
:
:
Kind
:
:
Delete
ElemOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
eoe
.
prepareForObj
(
)
)
{
return
false
;
}
if
(
!
emitOptionalTree
(
&
elemExpr
-
>
expression
(
)
oe
)
)
{
return
false
;
}
if
(
elemExpr
-
>
isKind
(
ParseNodeKind
:
:
OptionalElemExpr
)
)
{
if
(
!
oe
.
emitJumpShortCircuit
(
)
)
{
return
false
;
}
}
if
(
!
eoe
.
prepareForKey
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
&
elemExpr
-
>
key
(
)
)
)
{
return
false
;
}
if
(
!
eoe
.
emitDelete
(
)
)
{
return
false
;
}
return
true
;
}
static
const
char
*
SelfHostedCallFunctionName
(
TaggedParserAtomIndex
name
JSContext
*
cx
)
{
if
(
name
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
callFunction
(
)
)
{
return
"
callFunction
"
;
}
if
(
name
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
callContentFunction
(
)
)
{
return
"
callContentFunction
"
;
}
if
(
name
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
constructContentFunction
(
)
)
{
return
"
constructContentFunction
"
;
}
MOZ_CRASH
(
"
Unknown
self
-
hosted
call
function
name
"
)
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedCallFunction
(
CallNode
*
callNode
)
{
NameNode
*
calleeNode
=
&
callNode
-
>
left
(
)
-
>
as
<
NameNode
>
(
)
;
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
const
char
*
errorName
=
SelfHostedCallFunctionName
(
calleeNode
-
>
name
(
)
cx
)
;
if
(
argsList
-
>
count
(
)
<
2
)
{
reportNeedMoreArgsError
(
calleeNode
errorName
"
2
"
"
s
"
argsList
)
;
return
false
;
}
JSOp
callOp
=
callNode
-
>
callOp
(
)
;
if
(
callOp
!
=
JSOp
:
:
Call
)
{
reportError
(
callNode
JSMSG_NOT_CONSTRUCTOR
errorName
)
;
return
false
;
}
bool
constructing
=
calleeNode
-
>
name
(
)
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
constructContentFunction
(
)
;
ParseNode
*
funNode
=
argsList
-
>
head
(
)
;
if
(
constructing
)
{
callOp
=
JSOp
:
:
New
;
}
else
if
(
funNode
-
>
isName
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
std_Function_apply
(
)
)
)
{
callOp
=
JSOp
:
:
FunApply
;
}
if
(
!
emitTree
(
funNode
)
)
{
return
false
;
}
#
ifdef
DEBUG
if
(
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
&
&
calleeNode
-
>
name
(
)
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
callFunction
(
)
)
{
if
(
!
emit1
(
JSOp
:
:
DebugCheckSelfHosted
)
)
{
return
false
;
}
}
#
endif
ParseNode
*
thisOrNewTarget
=
funNode
-
>
pn_next
;
if
(
constructing
)
{
if
(
!
emit1
(
JSOp
:
:
IsConstructing
)
)
{
return
false
;
}
}
else
{
if
(
!
emitTree
(
thisOrNewTarget
)
)
{
return
false
;
}
}
for
(
ParseNode
*
argpn
=
thisOrNewTarget
-
>
pn_next
;
argpn
;
argpn
=
argpn
-
>
pn_next
)
{
if
(
!
emitTree
(
argpn
)
)
{
return
false
;
}
}
if
(
constructing
)
{
if
(
!
emitTree
(
thisOrNewTarget
)
)
{
return
false
;
}
}
uint32_t
argc
=
argsList
-
>
count
(
)
-
2
;
if
(
!
emitCall
(
callOp
argc
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedResumeGenerator
(
BinaryNode
*
callNode
)
{
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
if
(
argsList
-
>
count
(
)
!
=
3
)
{
reportNeedMoreArgsError
(
callNode
"
resumeGenerator
"
"
3
"
"
s
"
argsList
)
;
return
false
;
}
ParseNode
*
genNode
=
argsList
-
>
head
(
)
;
if
(
!
emitTree
(
genNode
)
)
{
return
false
;
}
ParseNode
*
valNode
=
genNode
-
>
pn_next
;
if
(
!
emitTree
(
valNode
)
)
{
return
false
;
}
ParseNode
*
kindNode
=
valNode
-
>
pn_next
;
MOZ_ASSERT
(
kindNode
-
>
isKind
(
ParseNodeKind
:
:
StringExpr
)
)
;
GeneratorResumeKind
kind
=
ParserAtomToResumeKind
(
cx
kindNode
-
>
as
<
NameNode
>
(
)
.
atom
(
)
)
;
MOZ_ASSERT
(
!
kindNode
-
>
pn_next
)
;
if
(
!
emitPushResumeKind
(
kind
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Resume
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedForceInterpreter
(
)
{
MOZ_ASSERT
(
bytecodeSection
(
)
.
code
(
)
.
empty
(
)
)
;
if
(
!
emit1
(
JSOp
:
:
ForceInterpreter
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedAllowContentIter
(
BinaryNode
*
callNode
)
{
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
if
(
argsList
-
>
count
(
)
!
=
1
)
{
reportNeedMoreArgsError
(
callNode
"
allowContentIter
"
"
1
"
"
"
argsList
)
;
return
false
;
}
return
emitTree
(
argsList
-
>
head
(
)
)
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedDefineDataProperty
(
BinaryNode
*
callNode
)
{
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
MOZ_ASSERT
(
argsList
-
>
count
(
)
=
=
3
)
;
ParseNode
*
objNode
=
argsList
-
>
head
(
)
;
if
(
!
emitTree
(
objNode
)
)
{
return
false
;
}
ParseNode
*
idNode
=
objNode
-
>
pn_next
;
if
(
!
emitTree
(
idNode
)
)
{
return
false
;
}
ParseNode
*
valNode
=
idNode
-
>
pn_next
;
if
(
!
emitTree
(
valNode
)
)
{
return
false
;
}
return
emit1
(
JSOp
:
:
InitElem
)
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedHasOwn
(
BinaryNode
*
callNode
)
{
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
if
(
argsList
-
>
count
(
)
!
=
2
)
{
reportNeedMoreArgsError
(
callNode
"
hasOwn
"
"
2
"
"
s
"
argsList
)
;
return
false
;
}
ParseNode
*
idNode
=
argsList
-
>
head
(
)
;
if
(
!
emitTree
(
idNode
)
)
{
return
false
;
}
ParseNode
*
objNode
=
idNode
-
>
pn_next
;
if
(
!
emitTree
(
objNode
)
)
{
return
false
;
}
return
emit1
(
JSOp
:
:
HasOwn
)
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedGetPropertySuper
(
BinaryNode
*
callNode
)
{
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
if
(
argsList
-
>
count
(
)
!
=
3
)
{
reportNeedMoreArgsError
(
callNode
"
getPropertySuper
"
"
3
"
"
s
"
argsList
)
;
return
false
;
}
ParseNode
*
objNode
=
argsList
-
>
head
(
)
;
ParseNode
*
idNode
=
objNode
-
>
pn_next
;
ParseNode
*
receiverNode
=
idNode
-
>
pn_next
;
if
(
!
emitTree
(
receiverNode
)
)
{
return
false
;
}
if
(
!
emitTree
(
idNode
)
)
{
return
false
;
}
if
(
!
emitTree
(
objNode
)
)
{
return
false
;
}
return
emitElemOpBase
(
JSOp
:
:
GetElemSuper
)
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedToNumeric
(
BinaryNode
*
callNode
)
{
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
if
(
argsList
-
>
count
(
)
!
=
1
)
{
reportNeedMoreArgsError
(
callNode
"
ToNumeric
"
"
1
"
"
"
argsList
)
;
return
false
;
}
ParseNode
*
argNode
=
argsList
-
>
head
(
)
;
if
(
!
emitTree
(
argNode
)
)
{
return
false
;
}
return
emit1
(
JSOp
:
:
ToNumeric
)
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedToString
(
BinaryNode
*
callNode
)
{
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
if
(
argsList
-
>
count
(
)
!
=
1
)
{
reportNeedMoreArgsError
(
callNode
"
ToString
"
"
1
"
"
"
argsList
)
;
return
false
;
}
ParseNode
*
argNode
=
argsList
-
>
head
(
)
;
if
(
!
emitTree
(
argNode
)
)
{
return
false
;
}
return
emit1
(
JSOp
:
:
ToString
)
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedGetBuiltinConstructorOrPrototype
(
BinaryNode
*
callNode
bool
isConstructor
)
{
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
if
(
argsList
-
>
count
(
)
!
=
1
)
{
const
char
*
name
=
isConstructor
?
"
GetBuiltinConstructor
"
:
"
GetBuiltinPrototype
"
;
reportNeedMoreArgsError
(
callNode
name
"
1
"
"
"
argsList
)
;
return
false
;
}
ParseNode
*
argNode
=
argsList
-
>
head
(
)
;
if
(
!
argNode
-
>
isKind
(
ParseNodeKind
:
:
StringExpr
)
)
{
reportError
(
callNode
JSMSG_UNEXPECTED_TYPE
"
built
-
in
name
"
"
not
a
string
constant
"
)
;
return
false
;
}
auto
name
=
argNode
-
>
as
<
NameNode
>
(
)
.
atom
(
)
;
BuiltinObjectKind
kind
;
if
(
isConstructor
)
{
kind
=
BuiltinConstructorForName
(
name
)
;
}
else
{
kind
=
BuiltinPrototypeForName
(
name
)
;
}
if
(
kind
=
=
BuiltinObjectKind
:
:
None
)
{
reportError
(
callNode
JSMSG_UNEXPECTED_TYPE
"
built
-
in
name
"
"
not
a
valid
built
-
in
"
)
;
return
false
;
}
return
emitBuiltinObject
(
kind
)
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedGetBuiltinConstructor
(
BinaryNode
*
callNode
)
{
return
emitSelfHostedGetBuiltinConstructorOrPrototype
(
callNode
true
)
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedGetBuiltinPrototype
(
BinaryNode
*
callNode
)
{
return
emitSelfHostedGetBuiltinConstructorOrPrototype
(
callNode
false
)
;
}
JS
:
:
SymbolCode
ParserAtomToSymbolCode
(
TaggedParserAtomIndex
atom
)
{
#
define
MATCH_WELL_KNOWN_SYMBOL
(
NAME
)
\
if
(
atom
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
NAME
(
)
)
{
\
return
JS
:
:
SymbolCode
:
:
NAME
;
\
}
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
MATCH_WELL_KNOWN_SYMBOL
)
#
undef
MATCH_WELL_KNOWN_SYMBOL
return
JS
:
:
SymbolCode
:
:
Limit
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedGetBuiltinSymbol
(
BinaryNode
*
callNode
)
{
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
if
(
argsList
-
>
count
(
)
!
=
1
)
{
reportNeedMoreArgsError
(
callNode
"
GetBuiltinSymbol
"
"
1
"
"
"
argsList
)
;
return
false
;
}
ParseNode
*
argNode
=
argsList
-
>
head
(
)
;
if
(
!
argNode
-
>
isKind
(
ParseNodeKind
:
:
StringExpr
)
)
{
reportError
(
callNode
JSMSG_UNEXPECTED_TYPE
"
built
-
in
name
"
"
not
a
string
constant
"
)
;
return
false
;
}
auto
name
=
argNode
-
>
as
<
NameNode
>
(
)
.
atom
(
)
;
JS
:
:
SymbolCode
code
=
ParserAtomToSymbolCode
(
name
)
;
if
(
code
=
=
JS
:
:
SymbolCode
:
:
Limit
)
{
reportError
(
callNode
JSMSG_UNEXPECTED_TYPE
"
built
-
in
name
"
"
not
a
valid
built
-
in
"
)
;
return
false
;
}
return
emit2
(
JSOp
:
:
Symbol
uint8_t
(
code
)
)
;
}
#
ifdef
DEBUG
bool
BytecodeEmitter
:
:
checkSelfHostedExpectedTopLevel
(
BinaryNode
*
callNode
ParseNode
*
node
)
{
if
(
!
node
-
>
isKind
(
ParseNodeKind
:
:
Name
)
)
{
reportError
(
callNode
JSMSG_UNEXPECTED_TYPE
"
function
argument
"
"
not
a
binding
name
"
)
;
return
false
;
}
TaggedParserAtomIndex
targetName
=
node
-
>
as
<
NameNode
>
(
)
.
name
(
)
;
MOZ_ASSERT
(
prevSelfHostedTopLevelFunction
)
;
if
(
prevSelfHostedTopLevelFunction
-
>
explicitName
(
)
!
=
targetName
)
{
reportError
(
callNode
JSMSG_SELFHOST_DECORATOR_MUST_FOLLOW
)
;
return
false
;
}
return
true
;
}
#
endif
bool
BytecodeEmitter
:
:
emitSelfHostedSetIsInlinableLargeFunction
(
BinaryNode
*
callNode
)
{
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
if
(
argsList
-
>
count
(
)
!
=
1
)
{
reportNeedMoreArgsError
(
callNode
"
SetIsInlinableLargeFunction
"
"
1
"
"
"
argsList
)
;
return
false
;
}
#
ifdef
DEBUG
if
(
!
checkSelfHostedExpectedTopLevel
(
callNode
argsList
-
>
head
(
)
)
)
{
return
false
;
}
#
endif
MOZ_ASSERT
(
prevSelfHostedTopLevelFunction
-
>
isInitialCompilation
)
;
prevSelfHostedTopLevelFunction
-
>
setIsInlinableLargeFunction
(
)
;
return
emit1
(
JSOp
:
:
Undefined
)
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedSetCanonicalName
(
BinaryNode
*
callNode
)
{
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
if
(
argsList
-
>
count
(
)
!
=
2
)
{
reportNeedMoreArgsError
(
callNode
"
SetCanonicalName
"
"
2
"
"
s
"
argsList
)
;
return
false
;
}
#
ifdef
DEBUG
if
(
!
checkSelfHostedExpectedTopLevel
(
callNode
argsList
-
>
head
(
)
)
)
{
return
false
;
}
#
endif
ParseNode
*
nameNode
=
argsList
-
>
last
(
)
;
MOZ_ASSERT
(
nameNode
-
>
isKind
(
ParseNodeKind
:
:
StringExpr
)
)
;
TaggedParserAtomIndex
specName
=
nameNode
-
>
as
<
NameNode
>
(
)
.
atom
(
)
;
compilationState
.
parserAtoms
.
markUsedByStencil
(
specName
)
;
prevSelfHostedTopLevelFunction
-
>
functionStencil
(
)
.
setSelfHostedCanonicalName
(
specName
)
;
return
emit1
(
JSOp
:
:
Undefined
)
;
}
#
ifdef
DEBUG
bool
BytecodeEmitter
:
:
checkSelfHostedUnsafeGetReservedSlot
(
BinaryNode
*
callNode
)
{
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
if
(
argsList
-
>
count
(
)
!
=
2
)
{
reportNeedMoreArgsError
(
callNode
"
UnsafeGetReservedSlot
"
"
2
"
"
"
argsList
)
;
return
false
;
}
ParseNode
*
objNode
=
argsList
-
>
head
(
)
;
ParseNode
*
slotNode
=
objNode
-
>
pn_next
;
if
(
!
slotNode
-
>
isKind
(
ParseNodeKind
:
:
NumberExpr
)
)
{
reportError
(
callNode
JSMSG_UNEXPECTED_TYPE
"
slot
argument
"
"
not
a
constant
"
)
;
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
checkSelfHostedUnsafeSetReservedSlot
(
BinaryNode
*
callNode
)
{
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
if
(
argsList
-
>
count
(
)
!
=
3
)
{
reportNeedMoreArgsError
(
callNode
"
UnsafeSetReservedSlot
"
"
3
"
"
"
argsList
)
;
return
false
;
}
ParseNode
*
objNode
=
argsList
-
>
head
(
)
;
ParseNode
*
slotNode
=
objNode
-
>
pn_next
;
if
(
!
slotNode
-
>
isKind
(
ParseNodeKind
:
:
NumberExpr
)
)
{
reportError
(
callNode
JSMSG_UNEXPECTED_TYPE
"
slot
argument
"
"
not
a
constant
"
)
;
return
false
;
}
return
true
;
}
#
endif
bool
BytecodeEmitter
:
:
isOptimizableSpreadArgument
(
ParseNode
*
expr
)
{
if
(
expr
-
>
isKind
(
ParseNodeKind
:
:
Name
)
)
{
return
true
;
}
return
allowSelfHostedIter
(
expr
)
&
&
isOptimizableSpreadArgument
(
expr
-
>
as
<
BinaryNode
>
(
)
.
right
(
)
-
>
as
<
ListNode
>
(
)
.
head
(
)
)
;
}
bool
BytecodeEmitter
:
:
emitOptionalCalleeAndThis
(
ParseNode
*
callee
CallNode
*
call
CallOrNewEmitter
&
cone
OptionalEmitter
&
oe
)
{
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
check
(
cx
)
)
{
return
false
;
}
switch
(
ParseNodeKind
kind
=
callee
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
Name
:
{
auto
name
=
callee
-
>
as
<
NameNode
>
(
)
.
name
(
)
;
if
(
!
cone
.
emitNameCallee
(
name
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
OptionalDotExpr
:
{
MOZ_ASSERT
(
emitterMode
!
=
BytecodeEmitter
:
:
SelfHosting
)
;
OptionalPropertyAccess
*
prop
=
&
callee
-
>
as
<
OptionalPropertyAccess
>
(
)
;
bool
isSuper
=
false
;
PropOpEmitter
&
poe
=
cone
.
prepareForPropCallee
(
isSuper
)
;
if
(
!
emitOptionalDotExpression
(
prop
poe
isSuper
oe
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
DotExpr
:
{
MOZ_ASSERT
(
emitterMode
!
=
BytecodeEmitter
:
:
SelfHosting
)
;
PropertyAccess
*
prop
=
&
callee
-
>
as
<
PropertyAccess
>
(
)
;
bool
isSuper
=
prop
-
>
isSuper
(
)
;
PropOpEmitter
&
poe
=
cone
.
prepareForPropCallee
(
isSuper
)
;
if
(
!
emitOptionalDotExpression
(
prop
poe
isSuper
oe
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
OptionalElemExpr
:
{
OptionalPropertyByValue
*
elem
=
&
callee
-
>
as
<
OptionalPropertyByValue
>
(
)
;
bool
isSuper
=
false
;
MOZ_ASSERT
(
!
elem
-
>
key
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
ElemOpEmitter
&
eoe
=
cone
.
prepareForElemCallee
(
isSuper
)
;
if
(
!
emitOptionalElemExpression
(
elem
eoe
isSuper
oe
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
ElemExpr
:
{
PropertyByValue
*
elem
=
&
callee
-
>
as
<
PropertyByValue
>
(
)
;
bool
isSuper
=
elem
-
>
isSuper
(
)
;
MOZ_ASSERT
(
!
elem
-
>
key
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
ElemOpEmitter
&
eoe
=
cone
.
prepareForElemCallee
(
isSuper
)
;
if
(
!
emitOptionalElemExpression
(
elem
eoe
isSuper
oe
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
PrivateMemberExpr
:
case
ParseNodeKind
:
:
OptionalPrivateMemberExpr
:
{
PrivateMemberAccessBase
*
privateExpr
=
&
callee
-
>
as
<
PrivateMemberAccessBase
>
(
)
;
PrivateOpEmitter
&
xoe
=
cone
.
prepareForPrivateCallee
(
privateExpr
-
>
privateName
(
)
.
name
(
)
)
;
if
(
!
emitOptionalPrivateExpression
(
privateExpr
xoe
oe
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
Function
:
if
(
!
cone
.
prepareForFunctionCallee
(
)
)
{
return
false
;
}
if
(
!
emitOptionalTree
(
callee
oe
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
OptionalChain
:
{
return
emitCalleeAndThisForOptionalChain
(
&
callee
-
>
as
<
UnaryNode
>
(
)
call
cone
)
;
}
default
:
MOZ_RELEASE_ASSERT
(
kind
!
=
ParseNodeKind
:
:
SuperBase
)
;
if
(
!
cone
.
prepareForOtherCallee
(
)
)
{
return
false
;
}
if
(
!
emitOptionalTree
(
callee
oe
)
)
{
return
false
;
}
break
;
}
if
(
!
cone
.
emitThis
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitCalleeAndThis
(
ParseNode
*
callee
ParseNode
*
call
CallOrNewEmitter
&
cone
)
{
switch
(
callee
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
Name
:
{
auto
name
=
callee
-
>
as
<
NameNode
>
(
)
.
name
(
)
;
if
(
!
cone
.
emitNameCallee
(
name
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
DotExpr
:
{
MOZ_ASSERT
(
emitterMode
!
=
BytecodeEmitter
:
:
SelfHosting
)
;
PropertyAccess
*
prop
=
&
callee
-
>
as
<
PropertyAccess
>
(
)
;
bool
isSuper
=
prop
-
>
isSuper
(
)
;
PropOpEmitter
&
poe
=
cone
.
prepareForPropCallee
(
isSuper
)
;
if
(
!
poe
.
prepareForObj
(
)
)
{
return
false
;
}
if
(
isSuper
)
{
UnaryNode
*
base
=
&
prop
-
>
expression
(
)
.
as
<
UnaryNode
>
(
)
;
if
(
!
emitGetThisForSuperBase
(
base
)
)
{
return
false
;
}
}
else
{
if
(
!
emitPropLHS
(
prop
)
)
{
return
false
;
}
}
if
(
!
poe
.
emitGet
(
prop
-
>
key
(
)
.
atom
(
)
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
ElemExpr
:
{
MOZ_ASSERT
(
emitterMode
!
=
BytecodeEmitter
:
:
SelfHosting
)
;
PropertyByValue
*
elem
=
&
callee
-
>
as
<
PropertyByValue
>
(
)
;
bool
isSuper
=
elem
-
>
isSuper
(
)
;
MOZ_ASSERT
(
!
elem
-
>
key
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
ElemOpEmitter
&
eoe
=
cone
.
prepareForElemCallee
(
isSuper
)
;
if
(
!
emitElemObjAndKey
(
elem
isSuper
eoe
)
)
{
return
false
;
}
if
(
!
eoe
.
emitGet
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
PrivateMemberExpr
:
{
MOZ_ASSERT
(
emitterMode
!
=
BytecodeEmitter
:
:
SelfHosting
)
;
PrivateMemberAccessBase
*
privateExpr
=
&
callee
-
>
as
<
PrivateMemberAccessBase
>
(
)
;
PrivateOpEmitter
&
xoe
=
cone
.
prepareForPrivateCallee
(
privateExpr
-
>
privateName
(
)
.
name
(
)
)
;
if
(
!
emitTree
(
&
privateExpr
-
>
expression
(
)
)
)
{
return
false
;
}
if
(
!
xoe
.
emitReference
(
)
)
{
return
false
;
}
if
(
!
xoe
.
emitGetForCallOrNew
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
Function
:
if
(
!
cone
.
prepareForFunctionCallee
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
callee
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
SuperBase
:
MOZ_ASSERT
(
call
-
>
isKind
(
ParseNodeKind
:
:
SuperCallExpr
)
)
;
MOZ_ASSERT
(
parser
-
>
astGenerator
(
)
.
isSuperBase
(
callee
)
)
;
if
(
!
cone
.
emitSuperCallee
(
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
OptionalChain
:
{
return
emitCalleeAndThisForOptionalChain
(
&
callee
-
>
as
<
UnaryNode
>
(
)
&
call
-
>
as
<
CallNode
>
(
)
cone
)
;
}
default
:
if
(
!
cone
.
prepareForOtherCallee
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
callee
)
)
{
return
false
;
}
break
;
}
if
(
!
cone
.
emitThis
(
)
)
{
return
false
;
}
return
true
;
}
ParseNode
*
BytecodeEmitter
:
:
getCoordNode
(
ParseNode
*
callNode
ParseNode
*
calleeNode
JSOp
op
ListNode
*
argsList
)
{
ParseNode
*
coordNode
=
callNode
;
if
(
op
=
=
JSOp
:
:
Call
|
|
op
=
=
JSOp
:
:
SpreadCall
|
|
op
=
=
JSOp
:
:
FunCall
|
|
op
=
=
JSOp
:
:
FunApply
)
{
coordNode
=
argsList
;
switch
(
calleeNode
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
DotExpr
:
coordNode
=
&
calleeNode
-
>
as
<
PropertyAccess
>
(
)
.
key
(
)
;
break
;
case
ParseNodeKind
:
:
Name
:
{
if
(
argsList
-
>
empty
(
)
|
|
!
bytecodeSection
(
)
.
atSeparator
(
calleeNode
-
>
pn_pos
.
begin
)
)
{
coordNode
=
calleeNode
;
}
break
;
}
default
:
break
;
}
}
return
coordNode
;
}
bool
BytecodeEmitter
:
:
emitArguments
(
ListNode
*
argsList
bool
isCall
bool
isSpread
CallOrNewEmitter
&
cone
)
{
uint32_t
argc
=
argsList
-
>
count
(
)
;
if
(
argc
>
=
ARGC_LIMIT
)
{
reportError
(
argsList
isCall
?
JSMSG_TOO_MANY_FUN_ARGS
:
JSMSG_TOO_MANY_CON_ARGS
)
;
return
false
;
}
if
(
!
isSpread
)
{
if
(
!
cone
.
prepareForNonSpreadArguments
(
)
)
{
return
false
;
}
for
(
ParseNode
*
arg
:
argsList
-
>
contents
(
)
)
{
if
(
!
emitTree
(
arg
)
)
{
return
false
;
}
}
}
else
{
if
(
cone
.
wantSpreadOperand
(
)
)
{
UnaryNode
*
spreadNode
=
&
argsList
-
>
head
(
)
-
>
as
<
UnaryNode
>
(
)
;
if
(
!
emitTree
(
spreadNode
-
>
kid
(
)
)
)
{
return
false
;
}
}
if
(
!
cone
.
emitSpreadArgumentsTest
(
)
)
{
return
false
;
}
if
(
cone
.
wantSpreadIteration
(
)
)
{
if
(
!
emitArray
(
argsList
-
>
head
(
)
argc
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitOptionalCall
(
CallNode
*
callNode
OptionalEmitter
&
oe
ValueUsage
valueUsage
)
{
ParseNode
*
calleeNode
=
callNode
-
>
left
(
)
;
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
bool
isSpread
=
IsSpreadOp
(
callNode
-
>
callOp
(
)
)
;
JSOp
op
=
callNode
-
>
callOp
(
)
;
uint32_t
argc
=
argsList
-
>
count
(
)
;
bool
isOptimizableSpread
=
isSpread
&
&
argc
=
=
1
&
&
isOptimizableSpreadArgument
(
argsList
-
>
head
(
)
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
)
;
CallOrNewEmitter
cone
(
this
op
isOptimizableSpread
?
CallOrNewEmitter
:
:
ArgumentsKind
:
:
SingleSpread
:
CallOrNewEmitter
:
:
ArgumentsKind
:
:
Other
valueUsage
)
;
ParseNode
*
coordNode
=
getCoordNode
(
callNode
calleeNode
op
argsList
)
;
if
(
!
emitOptionalCalleeAndThis
(
calleeNode
callNode
cone
oe
)
)
{
return
false
;
}
if
(
callNode
-
>
isKind
(
ParseNodeKind
:
:
OptionalCallExpr
)
)
{
if
(
!
oe
.
emitJumpShortCircuitForCall
(
)
)
{
return
false
;
}
}
if
(
!
emitArguments
(
argsList
true
isSpread
cone
)
)
{
return
false
;
}
if
(
!
cone
.
emitEnd
(
argc
Some
(
coordNode
-
>
pn_pos
.
begin
)
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitCallOrNew
(
CallNode
*
callNode
ValueUsage
valueUsage
)
{
bool
isCall
=
callNode
-
>
isKind
(
ParseNodeKind
:
:
CallExpr
)
|
|
callNode
-
>
isKind
(
ParseNodeKind
:
:
TaggedTemplateExpr
)
;
ParseNode
*
calleeNode
=
callNode
-
>
left
(
)
;
ListNode
*
argsList
=
&
callNode
-
>
right
(
)
-
>
as
<
ListNode
>
(
)
;
bool
isSpread
=
IsSpreadOp
(
callNode
-
>
callOp
(
)
)
;
if
(
calleeNode
-
>
isKind
(
ParseNodeKind
:
:
Name
)
&
&
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
&
&
!
isSpread
)
{
auto
calleeName
=
calleeNode
-
>
as
<
NameNode
>
(
)
.
name
(
)
;
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
callFunction
(
)
|
|
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
callContentFunction
(
)
|
|
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
constructContentFunction
(
)
)
{
return
emitSelfHostedCallFunction
(
callNode
)
;
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
resumeGenerator
(
)
)
{
return
emitSelfHostedResumeGenerator
(
callNode
)
;
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
forceInterpreter
(
)
)
{
return
emitSelfHostedForceInterpreter
(
)
;
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
allowContentIter
(
)
)
{
return
emitSelfHostedAllowContentIter
(
callNode
)
;
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
defineDataPropertyIntrinsic
(
)
&
&
argsList
-
>
count
(
)
=
=
3
)
{
return
emitSelfHostedDefineDataProperty
(
callNode
)
;
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
hasOwn
(
)
)
{
return
emitSelfHostedHasOwn
(
callNode
)
;
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
getPropertySuper
(
)
)
{
return
emitSelfHostedGetPropertySuper
(
callNode
)
;
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
ToNumeric
(
)
)
{
return
emitSelfHostedToNumeric
(
callNode
)
;
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
ToString
(
)
)
{
return
emitSelfHostedToString
(
callNode
)
;
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
GetBuiltinConstructor
(
)
)
{
return
emitSelfHostedGetBuiltinConstructor
(
callNode
)
;
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
GetBuiltinPrototype
(
)
)
{
return
emitSelfHostedGetBuiltinPrototype
(
callNode
)
;
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
GetBuiltinSymbol
(
)
)
{
return
emitSelfHostedGetBuiltinSymbol
(
callNode
)
;
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
SetIsInlinableLargeFunction
(
)
)
{
return
emitSelfHostedSetIsInlinableLargeFunction
(
callNode
)
;
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
SetCanonicalName
(
)
)
{
return
emitSelfHostedSetCanonicalName
(
callNode
)
;
}
#
ifdef
DEBUG
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
UnsafeGetReservedSlot
(
)
|
|
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
UnsafeGetObjectFromReservedSlot
(
)
|
|
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
UnsafeGetInt32FromReservedSlot
(
)
|
|
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
UnsafeGetStringFromReservedSlot
(
)
|
|
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
UnsafeGetBooleanFromReservedSlot
(
)
)
{
if
(
!
checkSelfHostedUnsafeGetReservedSlot
(
callNode
)
)
{
return
false
;
}
}
if
(
calleeName
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
UnsafeSetReservedSlot
(
)
)
{
if
(
!
checkSelfHostedUnsafeSetReservedSlot
(
callNode
)
)
{
return
false
;
}
}
#
endif
}
JSOp
op
=
callNode
-
>
callOp
(
)
;
uint32_t
argc
=
argsList
-
>
count
(
)
;
bool
isOptimizableSpread
=
isSpread
&
&
argc
=
=
1
&
&
isOptimizableSpreadArgument
(
argsList
-
>
head
(
)
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
)
;
bool
isDefaultDerivedClassConstructor
=
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
isDerivedClassConstructor
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
isSyntheticFunction
(
)
;
MOZ_ASSERT_IF
(
isDefaultDerivedClassConstructor
isOptimizableSpread
)
;
CallOrNewEmitter
cone
(
this
op
isOptimizableSpread
?
isDefaultDerivedClassConstructor
?
CallOrNewEmitter
:
:
ArgumentsKind
:
:
PassthroughRest
:
CallOrNewEmitter
:
:
ArgumentsKind
:
:
SingleSpread
:
CallOrNewEmitter
:
:
ArgumentsKind
:
:
Other
valueUsage
)
;
if
(
!
emitCalleeAndThis
(
calleeNode
callNode
cone
)
)
{
return
false
;
}
if
(
!
emitArguments
(
argsList
isCall
isSpread
cone
)
)
{
return
false
;
}
ParseNode
*
coordNode
=
getCoordNode
(
callNode
calleeNode
op
argsList
)
;
if
(
!
cone
.
emitEnd
(
argc
Some
(
coordNode
-
>
pn_pos
.
begin
)
)
)
{
return
false
;
}
return
true
;
}
static
const
JSOp
ParseNodeKindToJSOp
[
]
=
{
JSOp
:
:
Coalesce
JSOp
:
:
Or
JSOp
:
:
And
JSOp
:
:
BitOr
JSOp
:
:
BitXor
JSOp
:
:
BitAnd
JSOp
:
:
StrictEq
JSOp
:
:
Eq
JSOp
:
:
StrictNe
JSOp
:
:
Ne
JSOp
:
:
Lt
JSOp
:
:
Le
JSOp
:
:
Gt
JSOp
:
:
Ge
JSOp
:
:
Instanceof
JSOp
:
:
In
JSOp
:
:
Nop
JSOp
:
:
Lsh
JSOp
:
:
Rsh
JSOp
:
:
Ursh
JSOp
:
:
Add
JSOp
:
:
Sub
JSOp
:
:
Mul
JSOp
:
:
Div
JSOp
:
:
Mod
JSOp
:
:
Pow
}
;
static
inline
JSOp
BinaryOpParseNodeKindToJSOp
(
ParseNodeKind
pnk
)
{
MOZ_ASSERT
(
pnk
>
=
ParseNodeKind
:
:
BinOpFirst
)
;
MOZ_ASSERT
(
pnk
<
=
ParseNodeKind
:
:
BinOpLast
)
;
int
parseNodeFirst
=
size_t
(
ParseNodeKind
:
:
BinOpFirst
)
;
#
ifdef
DEBUG
int
jsopArraySize
=
std
:
:
size
(
ParseNodeKindToJSOp
)
;
int
parseNodeKindListSize
=
size_t
(
ParseNodeKind
:
:
BinOpLast
)
-
parseNodeFirst
+
1
;
MOZ_ASSERT
(
jsopArraySize
=
=
parseNodeKindListSize
)
;
MOZ_ASSERT
(
ParseNodeKindToJSOp
[
size_t
(
pnk
)
-
parseNodeFirst
]
!
=
JSOp
:
:
Nop
)
;
#
endif
return
ParseNodeKindToJSOp
[
size_t
(
pnk
)
-
parseNodeFirst
]
;
}
bool
BytecodeEmitter
:
:
emitRightAssociative
(
ListNode
*
node
)
{
MOZ_ASSERT
(
node
-
>
isKind
(
ParseNodeKind
:
:
PowExpr
)
)
;
for
(
ParseNode
*
subexpr
:
node
-
>
contents
(
)
)
{
if
(
!
emitTree
(
subexpr
)
)
{
return
false
;
}
}
for
(
uint32_t
i
=
0
;
i
<
node
-
>
count
(
)
-
1
;
i
+
+
)
{
if
(
!
emit1
(
JSOp
:
:
Pow
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitLeftAssociative
(
ListNode
*
node
)
{
if
(
!
emitTree
(
node
-
>
head
(
)
)
)
{
return
false
;
}
JSOp
op
=
BinaryOpParseNodeKindToJSOp
(
node
-
>
getKind
(
)
)
;
ParseNode
*
nextExpr
=
node
-
>
head
(
)
-
>
pn_next
;
do
{
if
(
!
emitTree
(
nextExpr
)
)
{
return
false
;
}
if
(
!
emit1
(
op
)
)
{
return
false
;
}
}
while
(
(
nextExpr
=
nextExpr
-
>
pn_next
)
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitPrivateInExpr
(
ListNode
*
node
)
{
MOZ_ASSERT
(
node
-
>
head
(
)
-
>
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
NameNode
&
privateNameNode
=
node
-
>
head
(
)
-
>
as
<
NameNode
>
(
)
;
TaggedParserAtomIndex
privateName
=
privateNameNode
.
name
(
)
;
PrivateOpEmitter
xoe
(
this
PrivateOpEmitter
:
:
Kind
:
:
ErgonomicBrandCheck
privateName
)
;
ParseNode
*
valueNode
=
node
-
>
head
(
)
-
>
pn_next
;
MOZ_ASSERT
(
valueNode
-
>
pn_next
=
=
nullptr
)
;
if
(
!
emitTree
(
valueNode
)
)
{
return
false
;
}
if
(
!
xoe
.
emitReference
(
)
)
{
return
false
;
}
if
(
!
xoe
.
emitBrandCheck
(
)
)
{
return
false
;
}
if
(
!
emitUnpickN
(
2
)
)
{
return
false
;
}
if
(
!
emitPopN
(
2
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitOptionalTree
(
ParseNode
*
pn
OptionalEmitter
&
oe
ValueUsage
valueUsage
)
{
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
check
(
cx
)
)
{
return
false
;
}
ParseNodeKind
kind
=
pn
-
>
getKind
(
)
;
switch
(
kind
)
{
case
ParseNodeKind
:
:
OptionalDotExpr
:
{
OptionalPropertyAccess
*
prop
=
&
pn
-
>
as
<
OptionalPropertyAccess
>
(
)
;
bool
isSuper
=
false
;
PropOpEmitter
poe
(
this
PropOpEmitter
:
:
Kind
:
:
Get
PropOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
emitOptionalDotExpression
(
prop
poe
isSuper
oe
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
DotExpr
:
{
PropertyAccess
*
prop
=
&
pn
-
>
as
<
PropertyAccess
>
(
)
;
bool
isSuper
=
prop
-
>
isSuper
(
)
;
PropOpEmitter
poe
(
this
PropOpEmitter
:
:
Kind
:
:
Get
isSuper
?
PropOpEmitter
:
:
ObjKind
:
:
Super
:
PropOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
emitOptionalDotExpression
(
prop
poe
isSuper
oe
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
OptionalElemExpr
:
{
OptionalPropertyByValue
*
elem
=
&
pn
-
>
as
<
OptionalPropertyByValue
>
(
)
;
bool
isSuper
=
false
;
MOZ_ASSERT
(
!
elem
-
>
key
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
ElemOpEmitter
eoe
(
this
ElemOpEmitter
:
:
Kind
:
:
Get
ElemOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
emitOptionalElemExpression
(
elem
eoe
isSuper
oe
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
ElemExpr
:
{
PropertyByValue
*
elem
=
&
pn
-
>
as
<
PropertyByValue
>
(
)
;
bool
isSuper
=
elem
-
>
isSuper
(
)
;
MOZ_ASSERT
(
!
elem
-
>
key
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
ElemOpEmitter
eoe
(
this
ElemOpEmitter
:
:
Kind
:
:
Get
isSuper
?
ElemOpEmitter
:
:
ObjKind
:
:
Super
:
ElemOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
emitOptionalElemExpression
(
elem
eoe
isSuper
oe
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
PrivateMemberExpr
:
case
ParseNodeKind
:
:
OptionalPrivateMemberExpr
:
{
PrivateMemberAccessBase
*
privateExpr
=
&
pn
-
>
as
<
PrivateMemberAccessBase
>
(
)
;
PrivateOpEmitter
xoe
(
this
PrivateOpEmitter
:
:
Kind
:
:
Get
privateExpr
-
>
privateName
(
)
.
name
(
)
)
;
if
(
!
emitOptionalPrivateExpression
(
privateExpr
xoe
oe
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
CallExpr
:
case
ParseNodeKind
:
:
OptionalCallExpr
:
if
(
!
emitOptionalCall
(
&
pn
-
>
as
<
CallNode
>
(
)
oe
valueUsage
)
)
{
return
false
;
}
break
;
default
:
#
ifdef
DEBUG
bool
isPrimaryExpression
=
kind
=
=
ParseNodeKind
:
:
ThisExpr
|
|
kind
=
=
ParseNodeKind
:
:
Name
|
|
kind
=
=
ParseNodeKind
:
:
PrivateName
|
|
kind
=
=
ParseNodeKind
:
:
NullExpr
|
|
kind
=
=
ParseNodeKind
:
:
TrueExpr
|
|
kind
=
=
ParseNodeKind
:
:
FalseExpr
|
|
kind
=
=
ParseNodeKind
:
:
NumberExpr
|
|
kind
=
=
ParseNodeKind
:
:
BigIntExpr
|
|
kind
=
=
ParseNodeKind
:
:
StringExpr
|
|
kind
=
=
ParseNodeKind
:
:
ArrayExpr
|
|
kind
=
=
ParseNodeKind
:
:
ObjectExpr
|
|
kind
=
=
ParseNodeKind
:
:
Function
|
|
kind
=
=
ParseNodeKind
:
:
ClassDecl
|
|
kind
=
=
ParseNodeKind
:
:
RegExpExpr
|
|
kind
=
=
ParseNodeKind
:
:
TemplateStringExpr
|
|
kind
=
=
ParseNodeKind
:
:
TemplateStringListExpr
|
|
kind
=
=
ParseNodeKind
:
:
RawUndefinedExpr
|
|
pn
-
>
isInParens
(
)
;
bool
isMemberExpression
=
isPrimaryExpression
|
|
kind
=
=
ParseNodeKind
:
:
TaggedTemplateExpr
|
|
kind
=
=
ParseNodeKind
:
:
NewExpr
|
|
kind
=
=
ParseNodeKind
:
:
NewTargetExpr
|
|
kind
=
=
ParseNodeKind
:
:
ImportMetaExpr
;
bool
isCallExpression
=
kind
=
=
ParseNodeKind
:
:
SetThis
|
|
kind
=
=
ParseNodeKind
:
:
CallImportExpr
;
MOZ_ASSERT
(
isMemberExpression
|
|
isCallExpression
"
Unknown
ParseNodeKind
for
OptionalChain
"
)
;
#
endif
return
emitTree
(
pn
)
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitCalleeAndThisForOptionalChain
(
UnaryNode
*
optionalChain
CallNode
*
callNode
CallOrNewEmitter
&
cone
)
{
ParseNode
*
calleeNode
=
optionalChain
-
>
kid
(
)
;
OptionalEmitter
oe
(
this
bytecodeSection
(
)
.
stackDepth
(
)
)
;
if
(
!
emitOptionalCalleeAndThis
(
calleeNode
callNode
cone
oe
)
)
{
return
false
;
}
if
(
!
oe
.
emitOptionalJumpTarget
(
JSOp
:
:
Undefined
OptionalEmitter
:
:
Kind
:
:
Reference
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitOptionalChain
(
UnaryNode
*
optionalChain
ValueUsage
valueUsage
)
{
ParseNode
*
expr
=
optionalChain
-
>
kid
(
)
;
OptionalEmitter
oe
(
this
bytecodeSection
(
)
.
stackDepth
(
)
)
;
if
(
!
emitOptionalTree
(
expr
oe
valueUsage
)
)
{
return
false
;
}
if
(
!
oe
.
emitOptionalJumpTarget
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitOptionalDotExpression
(
PropertyAccessBase
*
prop
PropOpEmitter
&
poe
bool
isSuper
OptionalEmitter
&
oe
)
{
if
(
!
poe
.
prepareForObj
(
)
)
{
return
false
;
}
if
(
isSuper
)
{
UnaryNode
*
base
=
&
prop
-
>
expression
(
)
.
as
<
UnaryNode
>
(
)
;
if
(
!
emitGetThisForSuperBase
(
base
)
)
{
return
false
;
}
}
else
{
if
(
!
emitOptionalTree
(
&
prop
-
>
expression
(
)
oe
)
)
{
return
false
;
}
}
if
(
prop
-
>
isKind
(
ParseNodeKind
:
:
OptionalDotExpr
)
)
{
MOZ_ASSERT
(
!
isSuper
)
;
if
(
!
oe
.
emitJumpShortCircuit
(
)
)
{
return
false
;
}
}
if
(
!
poe
.
emitGet
(
prop
-
>
key
(
)
.
atom
(
)
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitOptionalElemExpression
(
PropertyByValueBase
*
elem
ElemOpEmitter
&
eoe
bool
isSuper
OptionalEmitter
&
oe
)
{
if
(
!
eoe
.
prepareForObj
(
)
)
{
return
false
;
}
if
(
isSuper
)
{
UnaryNode
*
base
=
&
elem
-
>
expression
(
)
.
as
<
UnaryNode
>
(
)
;
if
(
!
emitGetThisForSuperBase
(
base
)
)
{
return
false
;
}
}
else
{
if
(
!
emitOptionalTree
(
&
elem
-
>
expression
(
)
oe
)
)
{
return
false
;
}
}
if
(
elem
-
>
isKind
(
ParseNodeKind
:
:
OptionalElemExpr
)
)
{
MOZ_ASSERT
(
!
isSuper
)
;
if
(
!
oe
.
emitJumpShortCircuit
(
)
)
{
return
false
;
}
}
if
(
!
eoe
.
prepareForKey
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
&
elem
-
>
key
(
)
)
)
{
return
false
;
}
if
(
!
eoe
.
emitGet
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitOptionalPrivateExpression
(
PrivateMemberAccessBase
*
privateExpr
PrivateOpEmitter
&
xoe
OptionalEmitter
&
oe
)
{
if
(
!
emitOptionalTree
(
&
privateExpr
-
>
expression
(
)
oe
)
)
{
return
false
;
}
if
(
privateExpr
-
>
isKind
(
ParseNodeKind
:
:
OptionalPrivateMemberExpr
)
)
{
if
(
!
oe
.
emitJumpShortCircuit
(
)
)
{
return
false
;
}
}
if
(
!
xoe
.
emitReference
(
)
)
{
return
false
;
}
if
(
!
xoe
.
emitGet
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitShortCircuit
(
ListNode
*
node
)
{
MOZ_ASSERT
(
node
-
>
isKind
(
ParseNodeKind
:
:
OrExpr
)
|
|
node
-
>
isKind
(
ParseNodeKind
:
:
CoalesceExpr
)
|
|
node
-
>
isKind
(
ParseNodeKind
:
:
AndExpr
)
)
;
TDZCheckCache
tdzCache
(
this
)
;
ParseNode
*
expr
=
node
-
>
head
(
)
;
if
(
!
emitTree
(
expr
)
)
{
return
false
;
}
JSOp
op
;
switch
(
node
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
OrExpr
:
op
=
JSOp
:
:
Or
;
break
;
case
ParseNodeKind
:
:
CoalesceExpr
:
op
=
JSOp
:
:
Coalesce
;
break
;
case
ParseNodeKind
:
:
AndExpr
:
op
=
JSOp
:
:
And
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
ParseNodeKind
"
)
;
}
JumpList
jump
;
if
(
!
emitJump
(
op
&
jump
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
while
(
(
expr
=
expr
-
>
pn_next
)
-
>
pn_next
)
{
if
(
!
emitTree
(
expr
)
)
{
return
false
;
}
if
(
!
emitJump
(
op
&
jump
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
if
(
!
emitTree
(
expr
)
)
{
return
false
;
}
if
(
!
emitJumpTargetAndPatch
(
jump
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitSequenceExpr
(
ListNode
*
node
ValueUsage
valueUsage
)
{
for
(
ParseNode
*
child
=
node
-
>
head
(
)
;
;
child
=
child
-
>
pn_next
)
{
if
(
!
updateSourceCoordNotes
(
child
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
emitTree
(
child
child
-
>
pn_next
?
ValueUsage
:
:
IgnoreValue
:
valueUsage
)
)
{
return
false
;
}
if
(
!
child
-
>
pn_next
)
{
break
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
return
true
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitIncOrDec
(
UnaryNode
*
incDec
)
{
switch
(
incDec
-
>
kid
(
)
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
DotExpr
:
return
emitPropIncDec
(
incDec
)
;
case
ParseNodeKind
:
:
ElemExpr
:
return
emitElemIncDec
(
incDec
)
;
case
ParseNodeKind
:
:
PrivateMemberExpr
:
return
emitPrivateIncDec
(
incDec
)
;
case
ParseNodeKind
:
:
CallExpr
:
return
emitCallIncDec
(
incDec
)
;
default
:
return
emitNameIncDec
(
incDec
)
;
}
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitLabeledStatement
(
const
LabeledStatement
*
labeledStmt
)
{
auto
name
=
labeledStmt
-
>
label
(
)
;
LabelEmitter
label
(
this
)
;
label
.
emitLabel
(
name
)
;
if
(
!
emitTree
(
labeledStmt
-
>
statement
(
)
)
)
{
return
false
;
}
if
(
!
label
.
emitEnd
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitConditionalExpression
(
ConditionalExpression
&
conditional
ValueUsage
valueUsage
)
{
CondEmitter
cond
(
this
)
;
if
(
!
cond
.
emitCond
(
)
)
{
return
false
;
}
ParseNode
*
conditionNode
=
&
conditional
.
condition
(
)
;
auto
conditionKind
=
IfEmitter
:
:
ConditionKind
:
:
Positive
;
if
(
conditionNode
-
>
isKind
(
ParseNodeKind
:
:
NotExpr
)
)
{
conditionNode
=
conditionNode
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
;
conditionKind
=
IfEmitter
:
:
ConditionKind
:
:
Negative
;
}
if
(
!
emitTree
(
conditionNode
)
)
{
return
false
;
}
if
(
!
cond
.
emitThenElse
(
conditionKind
)
)
{
return
false
;
}
if
(
!
emitTree
(
&
conditional
.
thenExpression
(
)
valueUsage
)
)
{
return
false
;
}
if
(
!
cond
.
emitElse
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
&
conditional
.
elseExpression
(
)
valueUsage
)
)
{
return
false
;
}
if
(
!
cond
.
emitEnd
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
cond
.
pushed
(
)
=
=
1
)
;
return
true
;
}
void
BytecodeEmitter
:
:
isPropertyListObjLiteralCompatible
(
ListNode
*
obj
bool
*
withValues
bool
*
withoutValues
)
{
bool
keysOK
=
true
;
bool
valuesOK
=
true
;
uint32_t
propCount
=
0
;
for
(
ParseNode
*
propdef
:
obj
-
>
contents
(
)
)
{
if
(
!
propdef
-
>
is
<
BinaryNode
>
(
)
)
{
keysOK
=
false
;
break
;
}
propCount
+
+
;
BinaryNode
*
prop
=
&
propdef
-
>
as
<
BinaryNode
>
(
)
;
ParseNode
*
key
=
prop
-
>
left
(
)
;
ParseNode
*
value
=
prop
-
>
right
(
)
;
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
ComputedName
)
)
{
keysOK
=
false
;
break
;
}
MOZ_ASSERT
(
!
key
-
>
isKind
(
ParseNodeKind
:
:
BigIntExpr
)
)
;
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
NumberExpr
)
)
{
double
numValue
=
key
-
>
as
<
NumericLiteral
>
(
)
.
value
(
)
;
int32_t
i
=
0
;
if
(
!
NumberIsInt32
(
numValue
&
i
)
)
{
keysOK
=
false
;
break
;
}
if
(
!
ObjLiteralWriter
:
:
arrayIndexInRange
(
i
)
)
{
keysOK
=
false
;
break
;
}
}
MOZ_ASSERT
(
key
-
>
isKind
(
ParseNodeKind
:
:
ObjectPropertyName
)
|
|
key
-
>
isKind
(
ParseNodeKind
:
:
StringExpr
)
|
|
key
-
>
isKind
(
ParseNodeKind
:
:
NumberExpr
)
)
;
AccessorType
accessorType
=
prop
-
>
is
<
PropertyDefinition
>
(
)
?
prop
-
>
as
<
PropertyDefinition
>
(
)
.
accessorType
(
)
:
AccessorType
:
:
None
;
if
(
accessorType
!
=
AccessorType
:
:
None
)
{
keysOK
=
false
;
break
;
}
if
(
!
isRHSObjLiteralCompatible
(
value
)
)
{
valuesOK
=
false
;
}
}
if
(
propCount
>
SharedPropMap
:
:
MaxPropsForNonDictionary
)
{
keysOK
=
false
;
}
*
withValues
=
keysOK
&
&
valuesOK
;
*
withoutValues
=
keysOK
;
}
bool
BytecodeEmitter
:
:
isArrayObjLiteralCompatible
(
ParseNode
*
arrayHead
)
{
for
(
ParseNode
*
elem
=
arrayHead
;
elem
;
elem
=
elem
-
>
pn_next
)
{
if
(
elem
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
return
false
;
}
if
(
!
isRHSObjLiteralCompatible
(
elem
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitPropertyList
(
ListNode
*
obj
PropertyEmitter
&
pe
PropListType
type
)
{
size_t
curFieldKeyIndex
=
0
;
size_t
curStaticFieldKeyIndex
=
0
;
for
(
ParseNode
*
propdef
:
obj
-
>
contents
(
)
)
{
if
(
propdef
-
>
is
<
ClassField
>
(
)
)
{
MOZ_ASSERT
(
type
=
=
ClassBody
)
;
ClassField
*
field
=
&
propdef
-
>
as
<
ClassField
>
(
)
;
if
(
field
-
>
name
(
)
.
getKind
(
)
=
=
ParseNodeKind
:
:
ComputedName
)
{
auto
fieldKeys
=
field
-
>
isStatic
(
)
?
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotStaticFieldKeys
(
)
:
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotFieldKeys
(
)
;
if
(
!
emitGetName
(
fieldKeys
)
)
{
return
false
;
}
ParseNode
*
nameExpr
=
field
-
>
name
(
)
.
as
<
UnaryNode
>
(
)
.
kid
(
)
;
if
(
!
emitTree
(
nameExpr
ValueUsage
:
:
WantValue
EMIT_LINENOTE
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
ToPropertyKey
)
)
{
return
false
;
}
size_t
fieldKeysIndex
;
if
(
field
-
>
isStatic
(
)
)
{
fieldKeysIndex
=
curStaticFieldKeyIndex
+
+
;
}
else
{
fieldKeysIndex
=
curFieldKeyIndex
+
+
;
}
if
(
!
emitUint32Operand
(
JSOp
:
:
InitElemArray
fieldKeysIndex
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
continue
;
}
if
(
propdef
-
>
isKind
(
ParseNodeKind
:
:
StaticClassBlock
)
)
{
continue
;
}
if
(
propdef
-
>
is
<
LexicalScopeNode
>
(
)
)
{
MOZ_ASSERT
(
propdef
-
>
as
<
LexicalScopeNode
>
(
)
.
scopeBody
(
)
-
>
is
<
ClassMethod
>
(
)
)
;
continue
;
}
if
(
propdef
-
>
isKind
(
ParseNodeKind
:
:
MutateProto
)
)
{
MOZ_ASSERT
(
type
=
=
ObjectLiteral
)
;
if
(
!
pe
.
prepareForProtoValue
(
Some
(
propdef
-
>
pn_pos
.
begin
)
)
)
{
return
false
;
}
if
(
!
emitTree
(
propdef
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
)
)
{
return
false
;
}
if
(
!
pe
.
emitMutateProto
(
)
)
{
return
false
;
}
continue
;
}
if
(
propdef
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
MOZ_ASSERT
(
type
=
=
ObjectLiteral
)
;
if
(
!
pe
.
prepareForSpreadOperand
(
Some
(
propdef
-
>
pn_pos
.
begin
)
)
)
{
return
false
;
}
if
(
!
emitTree
(
propdef
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
)
)
{
return
false
;
}
if
(
!
pe
.
emitSpread
(
)
)
{
return
false
;
}
continue
;
}
BinaryNode
*
prop
=
&
propdef
-
>
as
<
BinaryNode
>
(
)
;
ParseNode
*
key
=
prop
-
>
left
(
)
;
ParseNode
*
propVal
=
prop
-
>
right
(
)
;
AccessorType
accessorType
;
if
(
prop
-
>
is
<
ClassMethod
>
(
)
)
{
ClassMethod
&
method
=
prop
-
>
as
<
ClassMethod
>
(
)
;
accessorType
=
method
.
accessorType
(
)
;
if
(
!
method
.
isStatic
(
)
&
&
key
-
>
isKind
(
ParseNodeKind
:
:
PrivateName
)
&
&
accessorType
!
=
AccessorType
:
:
None
)
{
continue
;
}
}
else
if
(
prop
-
>
is
<
PropertyDefinition
>
(
)
)
{
accessorType
=
prop
-
>
as
<
PropertyDefinition
>
(
)
.
accessorType
(
)
;
}
else
{
accessorType
=
AccessorType
:
:
None
;
}
auto
emitValue
=
[
this
&
key
&
propVal
accessorType
&
pe
]
(
)
{
if
(
propVal
-
>
isDirectRHSAnonFunction
(
)
)
{
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
NumberExpr
)
)
{
MOZ_ASSERT
(
accessorType
=
=
AccessorType
:
:
None
)
;
auto
keyAtom
=
key
-
>
as
<
NumericLiteral
>
(
)
.
toAtom
(
cx
parserAtoms
(
)
)
;
if
(
!
keyAtom
)
{
return
false
;
}
if
(
!
emitAnonymousFunctionWithName
(
propVal
keyAtom
)
)
{
return
false
;
}
}
else
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
ObjectPropertyName
)
|
|
key
-
>
isKind
(
ParseNodeKind
:
:
StringExpr
)
)
{
MOZ_ASSERT
(
accessorType
=
=
AccessorType
:
:
None
)
;
auto
keyAtom
=
key
-
>
as
<
NameNode
>
(
)
.
atom
(
)
;
if
(
!
emitAnonymousFunctionWithName
(
propVal
keyAtom
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
key
-
>
isKind
(
ParseNodeKind
:
:
ComputedName
)
|
|
key
-
>
isKind
(
ParseNodeKind
:
:
BigIntExpr
)
)
;
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
BigIntExpr
)
)
{
MOZ_ASSERT
(
accessorType
=
=
AccessorType
:
:
None
)
;
if
(
!
emit1
(
JSOp
:
:
ToString
)
)
{
return
false
;
}
}
FunctionPrefixKind
prefix
=
accessorType
=
=
AccessorType
:
:
None
?
FunctionPrefixKind
:
:
None
:
accessorType
=
=
AccessorType
:
:
Getter
?
FunctionPrefixKind
:
:
Get
:
FunctionPrefixKind
:
:
Set
;
if
(
!
emitAnonymousFunctionWithComputedName
(
propVal
prefix
)
)
{
return
false
;
}
}
}
else
{
if
(
!
emitTree
(
propVal
)
)
{
return
false
;
}
}
if
(
propVal
-
>
is
<
FunctionNode
>
(
)
&
&
propVal
-
>
as
<
FunctionNode
>
(
)
.
funbox
(
)
-
>
needsHomeObject
(
)
)
{
if
(
!
pe
.
emitInitHomeObject
(
)
)
{
return
false
;
}
}
return
true
;
}
;
PropertyEmitter
:
:
Kind
kind
=
(
type
=
=
ClassBody
&
&
propdef
-
>
as
<
ClassMethod
>
(
)
.
isStatic
(
)
)
?
PropertyEmitter
:
:
Kind
:
:
Static
:
PropertyEmitter
:
:
Kind
:
:
Prototype
;
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
NumberExpr
)
|
|
key
-
>
isKind
(
ParseNodeKind
:
:
BigIntExpr
)
)
{
if
(
!
pe
.
prepareForIndexPropKey
(
Some
(
propdef
-
>
pn_pos
.
begin
)
kind
)
)
{
return
false
;
}
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
NumberExpr
)
)
{
if
(
!
emitNumberOp
(
key
-
>
as
<
NumericLiteral
>
(
)
.
value
(
)
)
)
{
return
false
;
}
}
else
{
if
(
!
emitBigIntOp
(
&
key
-
>
as
<
BigIntLiteral
>
(
)
)
)
{
return
false
;
}
}
if
(
!
pe
.
prepareForIndexPropValue
(
)
)
{
return
false
;
}
if
(
!
emitValue
(
)
)
{
return
false
;
}
if
(
!
pe
.
emitInitIndexOrComputed
(
accessorType
)
)
{
return
false
;
}
continue
;
}
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
ObjectPropertyName
)
|
|
key
-
>
isKind
(
ParseNodeKind
:
:
StringExpr
)
)
{
if
(
type
=
=
ClassBody
&
&
key
-
>
as
<
NameNode
>
(
)
.
atom
(
)
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
constructor
(
)
&
&
!
propdef
-
>
as
<
ClassMethod
>
(
)
.
isStatic
(
)
)
{
continue
;
}
if
(
!
pe
.
prepareForPropValue
(
Some
(
propdef
-
>
pn_pos
.
begin
)
kind
)
)
{
return
false
;
}
if
(
!
emitValue
(
)
)
{
return
false
;
}
auto
keyAtom
=
key
-
>
as
<
NameNode
>
(
)
.
atom
(
)
;
if
(
!
pe
.
emitInit
(
accessorType
keyAtom
)
)
{
return
false
;
}
continue
;
}
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
PrivateName
)
&
&
!
prop
-
>
as
<
ClassMethod
>
(
)
.
isStatic
(
)
)
{
MOZ_ASSERT
(
accessorType
=
=
AccessorType
:
:
None
)
;
if
(
!
pe
.
prepareForPrivateMethod
(
)
)
{
return
false
;
}
NameOpEmitter
noe
(
this
key
-
>
as
<
NameNode
>
(
)
.
atom
(
)
NameOpEmitter
:
:
Kind
:
:
SimpleAssignment
)
;
if
(
!
noe
.
prepareForRhs
(
)
)
{
return
false
;
}
if
(
!
emitValue
(
)
)
{
return
false
;
}
if
(
!
noe
.
emitAssignment
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
pe
.
skipInit
(
)
)
{
return
false
;
}
continue
;
}
MOZ_ASSERT
(
key
-
>
isKind
(
ParseNodeKind
:
:
ComputedName
)
|
|
key
-
>
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
if
(
!
pe
.
prepareForComputedPropKey
(
Some
(
propdef
-
>
pn_pos
.
begin
)
kind
)
)
{
return
false
;
}
if
(
key
-
>
is
<
NameNode
>
(
)
)
{
if
(
!
emitGetPrivateName
(
&
key
-
>
as
<
NameNode
>
(
)
)
)
{
return
false
;
}
}
else
{
if
(
!
emitTree
(
key
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
)
)
{
return
false
;
}
}
if
(
!
pe
.
prepareForComputedPropValue
(
)
)
{
return
false
;
}
if
(
!
emitValue
(
)
)
{
return
false
;
}
if
(
!
pe
.
emitInitIndexOrComputed
(
accessorType
)
)
{
return
false
;
}
if
(
key
-
>
isKind
(
ParseNodeKind
:
:
PrivateName
)
&
&
key
-
>
as
<
NameNode
>
(
)
.
privateNameKind
(
)
=
=
PrivateNameKind
:
:
Setter
)
{
if
(
!
emitGetPrivateName
(
&
key
-
>
as
<
NameNode
>
(
)
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
GetIntrinsic
TaggedParserAtomIndex
:
:
WellKnown
:
:
NoPrivateGetter
(
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
InitHiddenElemGetter
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitPropertyListObjLiteral
(
ListNode
*
obj
ObjLiteralFlags
flags
bool
useObjLiteralValues
)
{
ObjLiteralWriter
writer
;
#
ifdef
DEBUG
mozilla
:
:
Maybe
<
mozilla
:
:
HashSet
<
frontend
:
:
TaggedParserAtomIndex
frontend
:
:
TaggedParserAtomIndexHasher
>
>
selfHostedPropNames
;
if
(
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
)
{
selfHostedPropNames
.
emplace
(
)
;
}
#
endif
writer
.
beginObject
(
flags
)
;
bool
singleton
=
flags
.
hasFlag
(
ObjLiteralFlag
:
:
Singleton
)
;
for
(
ParseNode
*
propdef
:
obj
-
>
contents
(
)
)
{
BinaryNode
*
prop
=
&
propdef
-
>
as
<
BinaryNode
>
(
)
;
ParseNode
*
key
=
prop
-
>
left
(
)
;
if
(
key
-
>
is
<
NameNode
>
(
)
)
{
if
(
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
)
{
auto
propName
=
key
-
>
as
<
NameNode
>
(
)
.
atom
(
)
;
#
ifdef
DEBUG
auto
p
=
selfHostedPropNames
-
>
lookupForAdd
(
propName
)
;
MOZ_ASSERT
(
!
p
)
;
if
(
!
selfHostedPropNames
-
>
add
(
p
propName
)
)
{
js
:
:
ReportOutOfMemory
(
cx
)
;
return
false
;
}
#
endif
writer
.
setPropNameNoDuplicateCheck
(
parserAtoms
(
)
propName
)
;
}
else
{
if
(
!
writer
.
setPropName
(
cx
parserAtoms
(
)
key
-
>
as
<
NameNode
>
(
)
.
atom
(
)
)
)
{
return
false
;
}
}
}
else
{
double
numValue
=
key
-
>
as
<
NumericLiteral
>
(
)
.
value
(
)
;
int32_t
i
=
0
;
DebugOnly
<
bool
>
numIsInt
=
NumberIsInt32
(
numValue
&
i
)
;
MOZ_ASSERT
(
numIsInt
)
;
MOZ_ASSERT
(
ObjLiteralWriter
:
:
arrayIndexInRange
(
i
)
)
;
writer
.
setPropIndex
(
i
)
;
}
if
(
useObjLiteralValues
)
{
MOZ_ASSERT
(
singleton
)
;
ParseNode
*
value
=
prop
-
>
right
(
)
;
if
(
!
emitObjLiteralValue
(
writer
value
)
)
{
return
false
;
}
}
else
{
if
(
!
writer
.
propWithUndefinedValue
(
cx
)
)
{
return
false
;
}
}
}
GCThingIndex
index
;
if
(
!
addObjLiteralData
(
writer
&
index
)
)
{
return
false
;
}
MOZ_ASSERT_IF
(
singleton
sc
-
>
isTopLevelContext
(
)
&
&
sc
-
>
treatAsRunOnce
(
)
)
;
JSOp
op
=
singleton
?
JSOp
:
:
Object
:
JSOp
:
:
NewObject
;
if
(
!
emitGCIndexOp
(
op
index
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDestructuringRestExclusionSetObjLiteral
(
ListNode
*
pattern
)
{
ObjLiteralFlags
flags
;
ObjLiteralWriter
writer
;
writer
.
beginObject
(
flags
)
;
for
(
ParseNode
*
member
:
pattern
-
>
contents
(
)
)
{
if
(
member
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
MOZ_ASSERT
(
!
member
-
>
pn_next
"
unexpected
trailing
element
after
spread
"
)
;
break
;
}
TaggedParserAtomIndex
atom
;
if
(
member
-
>
isKind
(
ParseNodeKind
:
:
MutateProto
)
)
{
atom
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
proto
(
)
;
}
else
{
ParseNode
*
key
=
member
-
>
as
<
BinaryNode
>
(
)
.
left
(
)
;
atom
=
key
-
>
as
<
NameNode
>
(
)
.
atom
(
)
;
}
if
(
!
writer
.
setPropName
(
cx
parserAtoms
(
)
atom
)
)
{
return
false
;
}
if
(
!
writer
.
propWithUndefinedValue
(
cx
)
)
{
return
false
;
}
}
GCThingIndex
index
;
if
(
!
addObjLiteralData
(
writer
&
index
)
)
{
return
false
;
}
if
(
!
emitGCIndexOp
(
JSOp
:
:
NewObject
index
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitObjLiteralArray
(
ParseNode
*
arrayHead
)
{
MOZ_ASSERT
(
checkSingletonContext
(
)
)
;
ObjLiteralWriter
writer
;
ObjLiteralFlags
flags
(
{
ObjLiteralFlag
:
:
Array
ObjLiteralFlag
:
:
Singleton
}
)
;
writer
.
beginObject
(
flags
)
;
writer
.
beginDenseArrayElements
(
)
;
for
(
ParseNode
*
elem
=
arrayHead
;
elem
;
elem
=
elem
-
>
pn_next
)
{
if
(
!
emitObjLiteralValue
(
writer
elem
)
)
{
return
false
;
}
}
GCThingIndex
index
;
if
(
!
addObjLiteralData
(
writer
&
index
)
)
{
return
false
;
}
if
(
!
emitGCIndexOp
(
JSOp
:
:
Object
index
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
isRHSObjLiteralCompatible
(
ParseNode
*
value
)
{
return
value
-
>
isKind
(
ParseNodeKind
:
:
NumberExpr
)
|
|
value
-
>
isKind
(
ParseNodeKind
:
:
TrueExpr
)
|
|
value
-
>
isKind
(
ParseNodeKind
:
:
FalseExpr
)
|
|
value
-
>
isKind
(
ParseNodeKind
:
:
NullExpr
)
|
|
value
-
>
isKind
(
ParseNodeKind
:
:
RawUndefinedExpr
)
|
|
value
-
>
isKind
(
ParseNodeKind
:
:
StringExpr
)
|
|
value
-
>
isKind
(
ParseNodeKind
:
:
TemplateStringExpr
)
;
}
bool
BytecodeEmitter
:
:
emitObjLiteralValue
(
ObjLiteralWriter
&
writer
ParseNode
*
value
)
{
MOZ_ASSERT
(
isRHSObjLiteralCompatible
(
value
)
)
;
if
(
value
-
>
isKind
(
ParseNodeKind
:
:
NumberExpr
)
)
{
double
numValue
=
value
-
>
as
<
NumericLiteral
>
(
)
.
value
(
)
;
int32_t
i
=
0
;
js
:
:
Value
v
;
if
(
NumberIsInt32
(
numValue
&
i
)
)
{
v
.
setInt32
(
i
)
;
}
else
{
v
.
setDouble
(
numValue
)
;
}
if
(
!
writer
.
propWithConstNumericValue
(
cx
v
)
)
{
return
false
;
}
}
else
if
(
value
-
>
isKind
(
ParseNodeKind
:
:
TrueExpr
)
)
{
if
(
!
writer
.
propWithTrueValue
(
cx
)
)
{
return
false
;
}
}
else
if
(
value
-
>
isKind
(
ParseNodeKind
:
:
FalseExpr
)
)
{
if
(
!
writer
.
propWithFalseValue
(
cx
)
)
{
return
false
;
}
}
else
if
(
value
-
>
isKind
(
ParseNodeKind
:
:
NullExpr
)
)
{
if
(
!
writer
.
propWithNullValue
(
cx
)
)
{
return
false
;
}
}
else
if
(
value
-
>
isKind
(
ParseNodeKind
:
:
RawUndefinedExpr
)
)
{
if
(
!
writer
.
propWithUndefinedValue
(
cx
)
)
{
return
false
;
}
}
else
if
(
value
-
>
isKind
(
ParseNodeKind
:
:
StringExpr
)
|
|
value
-
>
isKind
(
ParseNodeKind
:
:
TemplateStringExpr
)
)
{
if
(
!
writer
.
propWithAtomValue
(
cx
parserAtoms
(
)
value
-
>
as
<
NameNode
>
(
)
.
atom
(
)
)
)
{
return
false
;
}
}
else
{
MOZ_CRASH
(
"
Unexpected
parse
node
"
)
;
}
return
true
;
}
static
bool
NeedsPrivateBrand
(
ParseNode
*
member
)
{
return
member
-
>
is
<
ClassMethod
>
(
)
&
&
member
-
>
as
<
ClassMethod
>
(
)
.
name
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
&
&
!
member
-
>
as
<
ClassMethod
>
(
)
.
isStatic
(
)
;
}
mozilla
:
:
Maybe
<
MemberInitializers
>
BytecodeEmitter
:
:
setupMemberInitializers
(
ListNode
*
classMembers
FieldPlacement
placement
)
{
bool
isStatic
=
placement
=
=
FieldPlacement
:
:
Static
;
size_t
numFields
=
0
;
size_t
numPrivateInitializers
=
0
;
bool
hasPrivateBrand
=
false
;
for
(
ParseNode
*
member
:
classMembers
-
>
contents
(
)
)
{
if
(
NeedsFieldInitializer
(
member
isStatic
)
)
{
numFields
+
+
;
}
else
if
(
NeedsAccessorInitializer
(
member
isStatic
)
)
{
numPrivateInitializers
+
+
;
hasPrivateBrand
=
true
;
}
else
if
(
NeedsPrivateBrand
(
member
)
)
{
hasPrivateBrand
=
true
;
}
}
if
(
numFields
+
numPrivateInitializers
>
MemberInitializers
:
:
MaxInitializers
)
{
return
Nothing
(
)
;
}
return
Some
(
MemberInitializers
(
hasPrivateBrand
numFields
+
numPrivateInitializers
)
)
;
}
bool
BytecodeEmitter
:
:
emitCreateFieldKeys
(
ListNode
*
obj
FieldPlacement
placement
)
{
bool
isStatic
=
placement
=
=
FieldPlacement
:
:
Static
;
auto
isFieldWithComputedName
=
[
isStatic
]
(
ParseNode
*
propdef
)
{
return
propdef
-
>
is
<
ClassField
>
(
)
&
&
propdef
-
>
as
<
ClassField
>
(
)
.
isStatic
(
)
=
=
isStatic
&
&
propdef
-
>
as
<
ClassField
>
(
)
.
name
(
)
.
getKind
(
)
=
=
ParseNodeKind
:
:
ComputedName
;
}
;
size_t
numFieldKeys
=
std
:
:
count_if
(
obj
-
>
contents
(
)
.
begin
(
)
obj
-
>
contents
(
)
.
end
(
)
isFieldWithComputedName
)
;
if
(
numFieldKeys
=
=
0
)
{
return
true
;
}
auto
fieldKeys
=
isStatic
?
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotStaticFieldKeys
(
)
:
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotFieldKeys
(
)
;
NameOpEmitter
noe
(
this
fieldKeys
NameOpEmitter
:
:
Kind
:
:
Initialize
)
;
if
(
!
noe
.
prepareForRhs
(
)
)
{
return
false
;
}
if
(
!
emitUint32Operand
(
JSOp
:
:
NewArray
numFieldKeys
)
)
{
return
false
;
}
if
(
!
noe
.
emitAssignment
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
return
true
;
}
static
bool
HasInitializer
(
ParseNode
*
node
bool
isStaticContext
)
{
return
(
node
-
>
is
<
ClassField
>
(
)
&
&
node
-
>
as
<
ClassField
>
(
)
.
isStatic
(
)
=
=
isStaticContext
)
|
|
(
isStaticContext
&
&
node
-
>
is
<
StaticClassBlock
>
(
)
)
;
}
static
FunctionNode
*
GetInitializer
(
ParseNode
*
node
bool
isStaticContext
)
{
MOZ_ASSERT
(
HasInitializer
(
node
isStaticContext
)
)
;
MOZ_ASSERT_IF
(
!
node
-
>
is
<
ClassField
>
(
)
isStaticContext
)
;
return
node
-
>
is
<
ClassField
>
(
)
?
node
-
>
as
<
ClassField
>
(
)
.
initializer
(
)
:
node
-
>
as
<
StaticClassBlock
>
(
)
.
function
(
)
;
}
bool
BytecodeEmitter
:
:
emitCreateMemberInitializers
(
ClassEmitter
&
ce
ListNode
*
obj
FieldPlacement
placement
)
{
mozilla
:
:
Maybe
<
MemberInitializers
>
memberInitializers
=
setupMemberInitializers
(
obj
placement
)
;
if
(
!
memberInitializers
)
{
ReportAllocationOverflow
(
cx
)
;
return
false
;
}
size_t
numInitializers
=
memberInitializers
-
>
numMemberInitializers
;
if
(
numInitializers
=
=
0
)
{
return
true
;
}
bool
isStatic
=
placement
=
=
FieldPlacement
:
:
Static
;
if
(
!
ce
.
prepareForMemberInitializers
(
numInitializers
isStatic
)
)
{
return
false
;
}
if
(
!
isStatic
)
{
if
(
!
emitPrivateMethodInitializers
(
ce
obj
)
)
{
return
false
;
}
}
for
(
ParseNode
*
propdef
:
obj
-
>
contents
(
)
)
{
if
(
!
HasInitializer
(
propdef
isStatic
)
)
{
continue
;
}
FunctionNode
*
initializer
=
GetInitializer
(
propdef
isStatic
)
;
if
(
!
ce
.
prepareForMemberInitializer
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
initializer
)
)
{
return
false
;
}
if
(
initializer
-
>
funbox
(
)
-
>
needsHomeObject
(
)
)
{
MOZ_ASSERT
(
initializer
-
>
funbox
(
)
-
>
allowSuperProperty
(
)
)
;
if
(
!
ce
.
emitMemberInitializerHomeObject
(
isStatic
)
)
{
return
false
;
}
}
if
(
!
ce
.
emitStoreMemberInitializer
(
)
)
{
return
false
;
}
}
if
(
!
ce
.
emitMemberInitializersEnd
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitPrivateMethodInitializers
(
ClassEmitter
&
ce
ListNode
*
obj
)
{
for
(
ParseNode
*
propdef
:
obj
-
>
contents
(
)
)
{
if
(
!
propdef
-
>
is
<
ClassMethod
>
(
)
|
|
propdef
-
>
as
<
ClassMethod
>
(
)
.
isStatic
(
)
)
{
continue
;
}
ParseNode
*
propName
=
&
propdef
-
>
as
<
ClassMethod
>
(
)
.
name
(
)
;
if
(
!
propName
-
>
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
{
continue
;
}
AccessorType
accessorType
=
propdef
-
>
as
<
ClassMethod
>
(
)
.
accessorType
(
)
;
if
(
accessorType
=
=
AccessorType
:
:
None
)
{
continue
;
}
if
(
!
ce
.
prepareForMemberInitializer
(
)
)
{
return
false
;
}
StringBuffer
storedMethodName
(
cx
)
;
if
(
!
storedMethodName
.
append
(
parserAtoms
(
)
propName
-
>
as
<
NameNode
>
(
)
.
atom
(
)
)
)
{
return
false
;
}
if
(
!
storedMethodName
.
append
(
accessorType
=
=
AccessorType
:
:
Getter
?
"
.
getter
"
:
"
.
setter
"
)
)
{
return
false
;
}
auto
storedMethodAtom
=
storedMethodName
.
finishParserAtom
(
parserAtoms
(
)
)
;
if
(
!
emitFunction
(
&
propdef
-
>
as
<
ClassMethod
>
(
)
.
method
(
)
)
)
{
return
false
;
}
if
(
!
ce
.
emitMemberInitializerHomeObject
(
false
)
)
{
return
false
;
}
if
(
!
emitLexicalInitialization
(
storedMethodAtom
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
emitPrivateMethodInitializer
(
ce
propdef
propName
storedMethodAtom
accessorType
)
)
{
return
false
;
}
if
(
!
ce
.
emitStoreMemberInitializer
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitPrivateMethodInitializer
(
ClassEmitter
&
ce
ParseNode
*
prop
ParseNode
*
propName
TaggedParserAtomIndex
storedMethodAtom
AccessorType
accessorType
)
{
FunctionNode
*
funNode
=
prop
-
>
as
<
ClassMethod
>
(
)
.
initializerIfPrivate
(
)
;
MOZ_ASSERT
(
funNode
)
;
FunctionBox
*
funbox
=
funNode
-
>
funbox
(
)
;
FunctionEmitter
fe
(
this
funbox
funNode
-
>
syntaxKind
(
)
FunctionEmitter
:
:
IsHoisted
:
:
No
)
;
if
(
!
fe
.
prepareForNonLazy
(
)
)
{
return
false
;
}
BytecodeEmitter
bce2
(
this
parser
funbox
compilationState
emitterMode
)
;
if
(
!
bce2
.
init
(
funNode
-
>
pn_pos
)
)
{
return
false
;
}
ListNode
*
paramsBody
=
&
funNode
-
>
body
(
)
-
>
as
<
ListNode
>
(
)
;
FunctionScriptEmitter
fse
(
&
bce2
funbox
Nothing
(
)
Nothing
(
)
)
;
if
(
!
fse
.
prepareForParameters
(
)
)
{
return
false
;
}
if
(
!
bce2
.
emitFunctionFormalParameters
(
paramsBody
)
)
{
return
false
;
}
if
(
!
fse
.
prepareForBody
(
)
)
{
return
false
;
}
if
(
!
bce2
.
emit1
(
JSOp
:
:
FunctionThis
)
)
{
return
false
;
}
if
(
!
bce2
.
emitGetPrivateName
(
&
propName
-
>
as
<
NameNode
>
(
)
)
)
{
return
false
;
}
if
(
!
bce2
.
emitGetName
(
storedMethodAtom
)
)
{
return
false
;
}
PrivateNameKind
kind
=
propName
-
>
as
<
NameNode
>
(
)
.
privateNameKind
(
)
;
switch
(
kind
)
{
case
PrivateNameKind
:
:
Method
:
if
(
!
bce2
.
emit1
(
JSOp
:
:
InitLockedElem
)
)
{
return
false
;
}
break
;
case
PrivateNameKind
:
:
Setter
:
if
(
!
bce2
.
emit1
(
JSOp
:
:
InitHiddenElemSetter
)
)
{
return
false
;
}
if
(
!
bce2
.
emitGetPrivateName
(
&
propName
-
>
as
<
NameNode
>
(
)
)
)
{
return
false
;
}
if
(
!
bce2
.
emitAtomOp
(
JSOp
:
:
GetIntrinsic
TaggedParserAtomIndex
:
:
WellKnown
:
:
NoPrivateGetter
(
)
)
)
{
return
false
;
}
if
(
!
bce2
.
emit1
(
JSOp
:
:
InitHiddenElemGetter
)
)
{
return
false
;
}
break
;
case
PrivateNameKind
:
:
Getter
:
case
PrivateNameKind
:
:
GetterSetter
:
if
(
accessorType
=
=
AccessorType
:
:
Getter
)
{
if
(
!
bce2
.
emit1
(
JSOp
:
:
InitHiddenElemGetter
)
)
{
return
false
;
}
}
else
{
if
(
!
bce2
.
emit1
(
JSOp
:
:
InitHiddenElemSetter
)
)
{
return
false
;
}
}
break
;
default
:
MOZ_CRASH
(
"
Invalid
op
"
)
;
}
if
(
!
bce2
.
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
fse
.
emitEndBody
(
)
)
{
return
false
;
}
if
(
!
fse
.
intoStencil
(
)
)
{
return
false
;
}
if
(
!
fe
.
emitNonLazyEnd
(
)
)
{
return
false
;
}
return
true
;
}
const
MemberInitializers
&
BytecodeEmitter
:
:
findMemberInitializersForCall
(
)
{
for
(
BytecodeEmitter
*
current
=
this
;
current
;
current
=
current
-
>
parent
)
{
if
(
current
-
>
sc
-
>
isFunctionBox
(
)
)
{
FunctionBox
*
funbox
=
current
-
>
sc
-
>
asFunctionBox
(
)
;
if
(
funbox
-
>
isArrow
(
)
)
{
continue
;
}
MOZ_RELEASE_ASSERT
(
funbox
-
>
isClassConstructor
(
)
)
;
return
funbox
-
>
useMemberInitializers
(
)
?
funbox
-
>
memberInitializers
(
)
:
MemberInitializers
:
:
Empty
(
)
;
}
}
MOZ_RELEASE_ASSERT
(
compilationState
.
scopeContext
.
memberInitializers
)
;
return
*
compilationState
.
scopeContext
.
memberInitializers
;
}
bool
BytecodeEmitter
:
:
emitInitializeInstanceMembers
(
)
{
const
MemberInitializers
&
memberInitializers
=
findMemberInitializersForCall
(
)
;
MOZ_ASSERT
(
memberInitializers
.
valid
)
;
if
(
memberInitializers
.
hasPrivateBrand
)
{
if
(
!
emitGetName
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotThis
(
)
)
)
{
return
false
;
}
if
(
!
emitGetName
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotPrivateBrand
(
)
)
)
{
return
false
;
}
if
(
!
emitCheckPrivateField
(
ThrowCondition
:
:
ThrowHas
ThrowMsgKind
:
:
PrivateBrandDoubleInit
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
if
(
!
emitBuiltinObject
(
BuiltinObjectKind
:
:
FunctionPrototype
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
InitHiddenElemGetter
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
size_t
numInitializers
=
memberInitializers
.
numMemberInitializers
;
if
(
numInitializers
=
=
0
)
{
return
true
;
}
if
(
!
emitGetName
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotInitializers
(
)
)
)
{
return
false
;
}
for
(
size_t
index
=
0
;
index
<
numInitializers
;
index
+
+
)
{
if
(
index
<
numInitializers
-
1
)
{
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
}
if
(
!
emitNumberOp
(
index
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
GetElem
)
)
{
return
false
;
}
if
(
!
emitGetName
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotThis
(
)
)
)
{
return
false
;
}
if
(
!
emitCall
(
JSOp
:
:
CallIgnoresRv
0
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitInitializeStaticFields
(
ListNode
*
classMembers
)
{
auto
isStaticField
=
[
]
(
ParseNode
*
propdef
)
{
return
HasInitializer
(
propdef
true
)
;
}
;
size_t
numFields
=
std
:
:
count_if
(
classMembers
-
>
contents
(
)
.
begin
(
)
classMembers
-
>
contents
(
)
.
end
(
)
isStaticField
)
;
if
(
numFields
=
=
0
)
{
return
true
;
}
if
(
!
emitGetName
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotStaticInitializers
(
)
)
)
{
return
false
;
}
for
(
size_t
fieldIndex
=
0
;
fieldIndex
<
numFields
;
fieldIndex
+
+
)
{
bool
hasNext
=
fieldIndex
<
numFields
-
1
;
if
(
hasNext
)
{
if
(
!
emit1
(
JSOp
:
:
Dup
)
)
{
return
false
;
}
}
if
(
!
emitNumberOp
(
fieldIndex
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
GetElem
)
)
{
return
false
;
}
if
(
!
emitDupAt
(
1
+
hasNext
)
)
{
return
false
;
}
if
(
!
emitCall
(
JSOp
:
:
CallIgnoresRv
0
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
auto
clearStaticFieldSlot
=
[
&
]
(
TaggedParserAtomIndex
name
)
{
NameOpEmitter
noe
(
this
name
NameOpEmitter
:
:
Kind
:
:
SimpleAssignment
)
;
if
(
!
noe
.
prepareForRhs
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
if
(
!
noe
.
emitAssignment
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
return
true
;
}
;
if
(
!
clearStaticFieldSlot
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotStaticInitializers
(
)
)
)
{
return
false
;
}
auto
isStaticFieldWithComputedName
=
[
]
(
ParseNode
*
propdef
)
{
return
propdef
-
>
is
<
ClassField
>
(
)
&
&
propdef
-
>
as
<
ClassField
>
(
)
.
isStatic
(
)
&
&
propdef
-
>
as
<
ClassField
>
(
)
.
name
(
)
.
getKind
(
)
=
=
ParseNodeKind
:
:
ComputedName
;
}
;
if
(
std
:
:
any_of
(
classMembers
-
>
contents
(
)
.
begin
(
)
classMembers
-
>
contents
(
)
.
end
(
)
isStaticFieldWithComputedName
)
)
{
if
(
!
clearStaticFieldSlot
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotStaticFieldKeys
(
)
)
)
{
return
false
;
}
}
return
true
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitObject
(
ListNode
*
objNode
)
{
bool
useObjLiteral
=
false
;
bool
useObjLiteralValues
=
false
;
isPropertyListObjLiteralCompatible
(
objNode
&
useObjLiteralValues
&
useObjLiteral
)
;
ObjectEmitter
oe
(
this
)
;
if
(
useObjLiteral
)
{
bool
singleton
=
checkSingletonContext
(
)
&
&
!
objNode
-
>
hasNonConstInitializer
(
)
&
&
objNode
-
>
head
(
)
;
ObjLiteralFlags
flags
;
if
(
singleton
)
{
flags
.
setFlag
(
ObjLiteralFlag
:
:
Singleton
)
;
}
else
{
useObjLiteralValues
=
false
;
}
if
(
!
emitPropertyListObjLiteral
(
objNode
flags
useObjLiteralValues
)
)
{
return
false
;
}
if
(
!
oe
.
emitObjectWithTemplateOnStack
(
)
)
{
return
false
;
}
if
(
!
useObjLiteralValues
)
{
if
(
!
emitPropertyList
(
objNode
oe
ObjectLiteral
)
)
{
return
false
;
}
}
}
else
{
if
(
!
oe
.
emitObject
(
objNode
-
>
count
(
)
)
)
{
return
false
;
}
if
(
!
emitPropertyList
(
objNode
oe
ObjectLiteral
)
)
{
return
false
;
}
}
if
(
!
oe
.
emitEnd
(
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitArrayLiteral
(
ListNode
*
array
)
{
if
(
checkSingletonContext
(
)
&
&
!
array
-
>
hasNonConstInitializer
(
)
&
&
array
-
>
head
(
)
&
&
isArrayObjLiteralCompatible
(
array
-
>
head
(
)
)
)
{
return
emitObjLiteralArray
(
array
-
>
head
(
)
)
;
}
return
emitArray
(
array
-
>
head
(
)
array
-
>
count
(
)
)
;
}
bool
BytecodeEmitter
:
:
emitArray
(
ParseNode
*
arrayHead
uint32_t
count
)
{
uint32_t
nspread
=
0
;
for
(
ParseNode
*
elem
=
arrayHead
;
elem
;
elem
=
elem
-
>
pn_next
)
{
if
(
elem
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
nspread
+
+
;
}
}
static_assert
(
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
<
=
INT32_MAX
"
array
literals
'
maximum
length
must
not
exceed
limits
"
"
required
by
BaselineCompiler
:
:
emit_NewArray
"
"
BaselineCompiler
:
:
emit_InitElemArray
"
"
and
DoSetElemFallback
'
s
handling
of
JSOp
:
:
InitElemArray
"
)
;
MOZ_ASSERT
(
count
>
=
nspread
)
;
MOZ_ASSERT
(
count
<
=
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
"
the
parser
must
throw
an
error
if
the
array
exceeds
maximum
"
"
length
"
)
;
if
(
!
emitUint32Operand
(
JSOp
:
:
NewArray
count
-
nspread
)
)
{
return
false
;
}
ParseNode
*
elem
=
arrayHead
;
uint32_t
index
;
bool
afterSpread
=
false
;
for
(
index
=
0
;
elem
;
index
+
+
elem
=
elem
-
>
pn_next
)
{
if
(
!
afterSpread
&
&
elem
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
afterSpread
=
true
;
if
(
!
emitNumberOp
(
index
)
)
{
return
false
;
}
}
if
(
!
updateSourceCoordNotes
(
elem
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
bool
allowSelfHostedIterFlag
=
false
;
if
(
elem
-
>
isKind
(
ParseNodeKind
:
:
Elision
)
)
{
if
(
!
emit1
(
JSOp
:
:
Hole
)
)
{
return
false
;
}
}
else
{
ParseNode
*
expr
;
if
(
elem
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
expr
=
elem
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
;
allowSelfHostedIterFlag
=
allowSelfHostedIter
(
expr
)
;
}
else
{
expr
=
elem
;
}
if
(
!
emitTree
(
expr
ValueUsage
:
:
WantValue
EMIT_LINENOTE
)
)
{
return
false
;
}
}
if
(
elem
-
>
isKind
(
ParseNodeKind
:
:
Spread
)
)
{
if
(
!
emitIterator
(
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Pick
3
)
)
{
return
false
;
}
if
(
!
emit2
(
JSOp
:
:
Pick
3
)
)
{
return
false
;
}
if
(
!
emitSpread
(
allowSelfHostedIterFlag
)
)
{
return
false
;
}
}
else
if
(
afterSpread
)
{
if
(
!
emit1
(
JSOp
:
:
InitElemInc
)
)
{
return
false
;
}
}
else
{
if
(
!
emitUint32Operand
(
JSOp
:
:
InitElemArray
index
)
)
{
return
false
;
}
}
}
MOZ_ASSERT
(
index
=
=
count
)
;
if
(
afterSpread
)
{
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
return
true
;
}
static
inline
JSOp
UnaryOpParseNodeKindToJSOp
(
ParseNodeKind
pnk
)
{
switch
(
pnk
)
{
case
ParseNodeKind
:
:
ThrowStmt
:
return
JSOp
:
:
Throw
;
case
ParseNodeKind
:
:
VoidExpr
:
return
JSOp
:
:
Void
;
case
ParseNodeKind
:
:
NotExpr
:
return
JSOp
:
:
Not
;
case
ParseNodeKind
:
:
BitNotExpr
:
return
JSOp
:
:
BitNot
;
case
ParseNodeKind
:
:
PosExpr
:
return
JSOp
:
:
Pos
;
case
ParseNodeKind
:
:
NegExpr
:
return
JSOp
:
:
Neg
;
default
:
MOZ_CRASH
(
"
unexpected
unary
op
"
)
;
}
}
bool
BytecodeEmitter
:
:
emitUnary
(
UnaryNode
*
unaryNode
)
{
if
(
!
updateSourceCoordNotes
(
unaryNode
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
emitTree
(
unaryNode
-
>
kid
(
)
)
)
{
return
false
;
}
return
emit1
(
UnaryOpParseNodeKindToJSOp
(
unaryNode
-
>
getKind
(
)
)
)
;
}
bool
BytecodeEmitter
:
:
emitTypeof
(
UnaryNode
*
typeofNode
JSOp
op
)
{
MOZ_ASSERT
(
op
=
=
JSOp
:
:
Typeof
|
|
op
=
=
JSOp
:
:
TypeofExpr
)
;
if
(
!
updateSourceCoordNotes
(
typeofNode
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
emitTree
(
typeofNode
-
>
kid
(
)
)
)
{
return
false
;
}
return
emit1
(
op
)
;
}
bool
BytecodeEmitter
:
:
emitFunctionFormalParameters
(
ListNode
*
paramsBody
)
{
ParseNode
*
funBody
=
paramsBody
-
>
last
(
)
;
FunctionBox
*
funbox
=
sc
-
>
asFunctionBox
(
)
;
bool
hasRest
=
funbox
-
>
hasRest
(
)
;
FunctionParamsEmitter
fpe
(
this
funbox
)
;
for
(
ParseNode
*
arg
=
paramsBody
-
>
head
(
)
;
arg
!
=
funBody
;
arg
=
arg
-
>
pn_next
)
{
ParseNode
*
bindingElement
=
arg
;
ParseNode
*
initializer
=
nullptr
;
if
(
arg
-
>
isKind
(
ParseNodeKind
:
:
AssignExpr
)
|
|
arg
-
>
isKind
(
ParseNodeKind
:
:
InitExpr
)
)
{
bindingElement
=
arg
-
>
as
<
BinaryNode
>
(
)
.
left
(
)
;
initializer
=
arg
-
>
as
<
BinaryNode
>
(
)
.
right
(
)
;
}
bool
hasInitializer
=
!
!
initializer
;
bool
isRest
=
hasRest
&
&
arg
-
>
pn_next
=
=
funBody
;
bool
isDestructuring
=
!
bindingElement
-
>
isKind
(
ParseNodeKind
:
:
Name
)
;
MOZ_ASSERT
(
bindingElement
-
>
isKind
(
ParseNodeKind
:
:
Name
)
|
|
bindingElement
-
>
isKind
(
ParseNodeKind
:
:
ArrayExpr
)
|
|
bindingElement
-
>
isKind
(
ParseNodeKind
:
:
ObjectExpr
)
)
;
auto
emitDefaultInitializer
=
[
this
&
initializer
&
bindingElement
]
(
)
{
if
(
!
this
-
>
emitInitializer
(
initializer
bindingElement
)
)
{
return
false
;
}
return
true
;
}
;
auto
emitDestructuring
=
[
this
&
bindingElement
]
(
)
{
if
(
!
this
-
>
emitDestructuringOps
(
&
bindingElement
-
>
as
<
ListNode
>
(
)
DestructuringFlavor
:
:
Declaration
)
)
{
return
false
;
}
return
true
;
}
;
if
(
isRest
)
{
if
(
isDestructuring
)
{
if
(
!
fpe
.
prepareForDestructuringRest
(
)
)
{
return
false
;
}
if
(
!
emitDestructuring
(
)
)
{
return
false
;
}
if
(
!
fpe
.
emitDestructuringRestEnd
(
)
)
{
return
false
;
}
}
else
{
auto
paramName
=
bindingElement
-
>
as
<
NameNode
>
(
)
.
name
(
)
;
if
(
!
fpe
.
emitRest
(
paramName
)
)
{
return
false
;
}
}
continue
;
}
if
(
isDestructuring
)
{
if
(
hasInitializer
)
{
if
(
!
fpe
.
prepareForDestructuringDefaultInitializer
(
)
)
{
return
false
;
}
if
(
!
emitDefaultInitializer
(
)
)
{
return
false
;
}
if
(
!
fpe
.
prepareForDestructuringDefault
(
)
)
{
return
false
;
}
if
(
!
emitDestructuring
(
)
)
{
return
false
;
}
if
(
!
fpe
.
emitDestructuringDefaultEnd
(
)
)
{
return
false
;
}
}
else
{
if
(
!
fpe
.
prepareForDestructuring
(
)
)
{
return
false
;
}
if
(
!
emitDestructuring
(
)
)
{
return
false
;
}
if
(
!
fpe
.
emitDestructuringEnd
(
)
)
{
return
false
;
}
}
continue
;
}
if
(
hasInitializer
)
{
if
(
!
fpe
.
prepareForDefault
(
)
)
{
return
false
;
}
if
(
!
emitDefaultInitializer
(
)
)
{
return
false
;
}
auto
paramName
=
bindingElement
-
>
as
<
NameNode
>
(
)
.
name
(
)
;
if
(
!
fpe
.
emitDefaultEnd
(
paramName
)
)
{
return
false
;
}
continue
;
}
auto
paramName
=
bindingElement
-
>
as
<
NameNode
>
(
)
.
name
(
)
;
if
(
!
fpe
.
emitSimple
(
paramName
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitInitializeFunctionSpecialNames
(
)
{
FunctionBox
*
funbox
=
sc
-
>
asFunctionBox
(
)
;
auto
emitInitializeFunctionSpecialName
=
[
]
(
BytecodeEmitter
*
bce
TaggedParserAtomIndex
name
JSOp
op
)
{
MOZ_ASSERT
(
bce
-
>
lookupName
(
name
)
.
hasKnownSlot
(
)
)
;
NameOpEmitter
noe
(
bce
name
NameOpEmitter
:
:
Kind
:
:
Initialize
)
;
if
(
!
noe
.
prepareForRhs
(
)
)
{
return
false
;
}
if
(
!
bce
-
>
emit1
(
op
)
)
{
return
false
;
}
if
(
!
noe
.
emitAssignment
(
)
)
{
return
false
;
}
if
(
!
bce
-
>
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
return
true
;
}
;
if
(
funbox
-
>
needsArgsObj
(
)
)
{
if
(
!
emitInitializeFunctionSpecialName
(
this
TaggedParserAtomIndex
:
:
WellKnown
:
:
arguments
(
)
JSOp
:
:
Arguments
)
)
{
return
false
;
}
}
if
(
funbox
-
>
functionHasThisBinding
(
)
)
{
if
(
!
emitInitializeFunctionSpecialName
(
this
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotThis
(
)
JSOp
:
:
FunctionThis
)
)
{
return
false
;
}
}
if
(
funbox
-
>
needsPromiseResult
(
)
)
{
if
(
!
emitInitializeFunctionSpecialName
(
this
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotGenerator
(
)
JSOp
:
:
Generator
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitLexicalInitialization
(
NameNode
*
name
)
{
return
emitLexicalInitialization
(
name
-
>
name
(
)
)
;
}
bool
BytecodeEmitter
:
:
emitLexicalInitialization
(
TaggedParserAtomIndex
name
)
{
NameOpEmitter
noe
(
this
name
NameOpEmitter
:
:
Kind
:
:
Initialize
)
;
if
(
!
noe
.
prepareForRhs
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
noe
.
loc
(
)
.
isLexical
(
)
|
|
noe
.
loc
(
)
.
isSynthetic
(
)
|
|
noe
.
loc
(
)
.
isPrivateMethod
(
)
)
;
MOZ_ASSERT
(
!
noe
.
emittedBindOp
(
)
)
;
if
(
!
noe
.
emitAssignment
(
)
)
{
return
false
;
}
return
true
;
}
static
MOZ_ALWAYS_INLINE
ParseNode
*
FindConstructor
(
JSContext
*
cx
ListNode
*
classMethods
)
{
for
(
ParseNode
*
classElement
:
classMethods
-
>
contents
(
)
)
{
ParseNode
*
unwrappedElement
=
classElement
;
if
(
unwrappedElement
-
>
is
<
LexicalScopeNode
>
(
)
)
{
unwrappedElement
=
unwrappedElement
-
>
as
<
LexicalScopeNode
>
(
)
.
scopeBody
(
)
;
}
if
(
unwrappedElement
-
>
is
<
ClassMethod
>
(
)
)
{
ClassMethod
&
method
=
unwrappedElement
-
>
as
<
ClassMethod
>
(
)
;
ParseNode
&
methodName
=
method
.
name
(
)
;
if
(
!
method
.
isStatic
(
)
&
&
(
methodName
.
isKind
(
ParseNodeKind
:
:
ObjectPropertyName
)
|
|
methodName
.
isKind
(
ParseNodeKind
:
:
StringExpr
)
)
&
&
methodName
.
as
<
NameNode
>
(
)
.
atom
(
)
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
constructor
(
)
)
{
return
classElement
;
}
}
}
return
nullptr
;
}
bool
BytecodeEmitter
:
:
emitNewPrivateName
(
TaggedParserAtomIndex
bindingName
TaggedParserAtomIndex
symbolName
)
{
if
(
!
emitAtomOp
(
JSOp
:
:
GetIntrinsic
TaggedParserAtomIndex
:
:
WellKnown
:
:
NewPrivateName
(
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
if
(
!
emitAtomOp
(
JSOp
:
:
String
symbolName
)
)
{
return
false
;
}
int
argc
=
1
;
if
(
!
emitCall
(
JSOp
:
:
Call
argc
)
)
{
return
false
;
}
if
(
!
emitLexicalInitialization
(
bindingName
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitNewPrivateNames
(
TaggedParserAtomIndex
privateBrandName
ListNode
*
classMembers
)
{
bool
hasPrivateBrand
=
false
;
for
(
ParseNode
*
classElement
:
classMembers
-
>
contents
(
)
)
{
ParseNode
*
elementName
;
if
(
classElement
-
>
is
<
ClassMethod
>
(
)
)
{
elementName
=
&
classElement
-
>
as
<
ClassMethod
>
(
)
.
name
(
)
;
}
else
if
(
classElement
-
>
is
<
ClassField
>
(
)
)
{
elementName
=
&
classElement
-
>
as
<
ClassField
>
(
)
.
name
(
)
;
}
else
{
continue
;
}
if
(
!
elementName
-
>
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
{
continue
;
}
bool
isOptimized
=
false
;
if
(
classElement
-
>
is
<
ClassMethod
>
(
)
&
&
!
classElement
-
>
as
<
ClassMethod
>
(
)
.
isStatic
(
)
)
{
hasPrivateBrand
=
true
;
if
(
classElement
-
>
as
<
ClassMethod
>
(
)
.
accessorType
(
)
=
=
AccessorType
:
:
None
)
{
isOptimized
=
true
;
}
}
if
(
!
isOptimized
)
{
auto
privateName
=
elementName
-
>
as
<
NameNode
>
(
)
.
name
(
)
;
if
(
!
emitNewPrivateName
(
privateName
privateName
)
)
{
return
false
;
}
}
}
if
(
hasPrivateBrand
)
{
if
(
!
emitNewPrivateName
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotPrivateBrand
(
)
privateBrandName
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitClass
(
ClassNode
*
classNode
ClassNameKind
nameKind
TaggedParserAtomIndex
nameForAnonymousClass
)
{
MOZ_ASSERT
(
(
nameKind
=
=
ClassNameKind
:
:
InferredName
)
=
=
bool
(
nameForAnonymousClass
)
)
;
ParseNode
*
heritageExpression
=
classNode
-
>
heritage
(
)
;
ListNode
*
classMembers
=
classNode
-
>
memberList
(
)
;
ParseNode
*
constructor
=
FindConstructor
(
cx
classMembers
)
;
ClassEmitter
ce
(
this
)
;
TaggedParserAtomIndex
innerName
;
ClassEmitter
:
:
Kind
kind
=
ClassEmitter
:
:
Kind
:
:
Expression
;
if
(
ClassNames
*
names
=
classNode
-
>
names
(
)
)
{
MOZ_ASSERT
(
nameKind
=
=
ClassNameKind
:
:
BindingName
)
;
innerName
=
names
-
>
innerBinding
(
)
-
>
name
(
)
;
MOZ_ASSERT
(
innerName
)
;
if
(
names
-
>
outerBinding
(
)
)
{
MOZ_ASSERT
(
names
-
>
outerBinding
(
)
-
>
name
(
)
)
;
MOZ_ASSERT
(
names
-
>
outerBinding
(
)
-
>
name
(
)
=
=
innerName
)
;
kind
=
ClassEmitter
:
:
Kind
:
:
Declaration
;
}
}
if
(
LexicalScopeNode
*
scopeBindings
=
classNode
-
>
scopeBindings
(
)
)
{
if
(
!
ce
.
emitScope
(
scopeBindings
-
>
scopeBindings
(
)
)
)
{
return
false
;
}
}
bool
isDerived
=
!
!
heritageExpression
;
if
(
isDerived
)
{
if
(
!
updateSourceCoordNotes
(
classNode
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitTree
(
heritageExpression
)
)
{
return
false
;
}
}
if
(
ClassBodyScopeNode
*
bodyScopeBindings
=
classNode
-
>
bodyScopeBindings
(
)
)
{
if
(
!
ce
.
emitBodyScope
(
bodyScopeBindings
-
>
scopeBindings
(
)
)
)
{
return
false
;
}
auto
privateBrandName
=
innerName
;
if
(
!
innerName
)
{
privateBrandName
=
nameForAnonymousClass
?
nameForAnonymousClass
:
TaggedParserAtomIndex
:
:
WellKnown
:
:
anonymous
(
)
;
}
if
(
!
emitNewPrivateNames
(
privateBrandName
classMembers
)
)
{
return
false
;
}
}
bool
hasNameOnStack
=
nameKind
=
=
ClassNameKind
:
:
ComputedName
;
if
(
isDerived
)
{
if
(
!
ce
.
emitDerivedClass
(
innerName
nameForAnonymousClass
hasNameOnStack
)
)
{
return
false
;
}
}
else
{
if
(
!
ce
.
emitClass
(
innerName
nameForAnonymousClass
hasNameOnStack
)
)
{
return
false
;
}
}
Maybe
<
LexicalScopeEmitter
>
lse
;
FunctionNode
*
ctor
;
if
(
constructor
-
>
is
<
LexicalScopeNode
>
(
)
)
{
LexicalScopeNode
*
constructorScope
=
&
constructor
-
>
as
<
LexicalScopeNode
>
(
)
;
MOZ_ASSERT
(
!
constructorScope
-
>
isEmptyScope
(
)
)
;
MOZ_ASSERT
(
constructorScope
-
>
scopeBindings
(
)
-
>
length
=
=
1
)
;
MOZ_ASSERT
(
GetScopeDataTrailingNames
(
constructorScope
-
>
scopeBindings
(
)
)
[
0
]
.
name
(
)
=
=
TaggedParserAtomIndex
:
:
WellKnown
:
:
dotInitializers
(
)
)
;
auto
needsInitializer
=
[
]
(
ParseNode
*
propdef
)
{
return
NeedsFieldInitializer
(
propdef
false
)
|
|
NeedsAccessorInitializer
(
propdef
false
)
;
}
;
bool
needsInitializers
=
std
:
:
any_of
(
classMembers
-
>
contents
(
)
.
begin
(
)
classMembers
-
>
contents
(
)
.
end
(
)
needsInitializer
)
;
if
(
needsInitializers
)
{
lse
.
emplace
(
this
)
;
if
(
!
lse
-
>
emitScope
(
ScopeKind
:
:
Lexical
constructorScope
-
>
scopeBindings
(
)
)
)
{
return
false
;
}
if
(
!
emitCreateMemberInitializers
(
ce
classMembers
FieldPlacement
:
:
Instance
)
)
{
return
false
;
}
}
ctor
=
&
constructorScope
-
>
scopeBody
(
)
-
>
as
<
ClassMethod
>
(
)
.
method
(
)
;
}
else
{
MOZ_ASSERT
(
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
)
;
ctor
=
&
constructor
-
>
as
<
ClassMethod
>
(
)
.
method
(
)
;
}
bool
needsHomeObject
=
ctor
-
>
funbox
(
)
-
>
needsHomeObject
(
)
;
if
(
nameKind
=
=
ClassNameKind
:
:
InferredName
)
{
if
(
!
setFunName
(
ctor
-
>
funbox
(
)
nameForAnonymousClass
)
)
{
return
false
;
}
}
if
(
!
emitFunction
(
ctor
isDerived
)
)
{
return
false
;
}
if
(
lse
.
isSome
(
)
)
{
if
(
!
lse
-
>
emitEnd
(
)
)
{
return
false
;
}
lse
.
reset
(
)
;
}
if
(
!
ce
.
emitInitConstructor
(
needsHomeObject
)
)
{
return
false
;
}
if
(
!
emitCreateFieldKeys
(
classMembers
FieldPlacement
:
:
Instance
)
)
{
return
false
;
}
if
(
!
emitCreateMemberInitializers
(
ce
classMembers
FieldPlacement
:
:
Static
)
)
{
return
false
;
}
if
(
!
emitCreateFieldKeys
(
classMembers
FieldPlacement
:
:
Static
)
)
{
return
false
;
}
if
(
!
emitPropertyList
(
classMembers
ce
ClassBody
)
)
{
return
false
;
}
if
(
!
ce
.
emitBinding
(
)
)
{
return
false
;
}
if
(
!
emitInitializeStaticFields
(
classMembers
)
)
{
return
false
;
}
if
(
!
ce
.
emitEnd
(
kind
)
)
{
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitExportDefault
(
BinaryNode
*
exportNode
)
{
MOZ_ASSERT
(
exportNode
-
>
isKind
(
ParseNodeKind
:
:
ExportDefaultStmt
)
)
;
ParseNode
*
valueNode
=
exportNode
-
>
left
(
)
;
if
(
valueNode
-
>
isDirectRHSAnonFunction
(
)
)
{
MOZ_ASSERT
(
exportNode
-
>
right
(
)
)
;
if
(
!
emitAnonymousFunctionWithName
(
valueNode
TaggedParserAtomIndex
:
:
WellKnown
:
:
default_
(
)
)
)
{
return
false
;
}
}
else
{
if
(
!
emitTree
(
valueNode
)
)
{
return
false
;
}
}
if
(
ParseNode
*
binding
=
exportNode
-
>
right
(
)
)
{
if
(
!
emitLexicalInitialization
(
&
binding
-
>
as
<
NameNode
>
(
)
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Pop
)
)
{
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitTree
(
ParseNode
*
pn
ValueUsage
valueUsage
EmitLineNumberNote
emitLineNote
)
{
AutoCheckRecursionLimit
recursion
(
cx
)
;
if
(
!
recursion
.
check
(
cx
)
)
{
return
false
;
}
if
(
emitLineNote
=
=
EMIT_LINENOTE
&
&
!
ParseNodeRequiresSpecialLineNumberNotes
(
pn
)
)
{
if
(
!
updateLineNumberNotes
(
pn
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
}
switch
(
pn
-
>
getKind
(
)
)
{
case
ParseNodeKind
:
:
Function
:
if
(
!
emitFunction
(
&
pn
-
>
as
<
FunctionNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ParamsBody
:
MOZ_ASSERT_UNREACHABLE
(
"
ParamsBody
should
be
handled
in
emitFunctionScript
.
"
)
;
break
;
case
ParseNodeKind
:
:
IfStmt
:
if
(
!
emitIf
(
&
pn
-
>
as
<
TernaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
SwitchStmt
:
if
(
!
emitSwitch
(
&
pn
-
>
as
<
SwitchStatement
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
WhileStmt
:
if
(
!
emitWhile
(
&
pn
-
>
as
<
BinaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
DoWhileStmt
:
if
(
!
emitDo
(
&
pn
-
>
as
<
BinaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ForStmt
:
if
(
!
emitFor
(
&
pn
-
>
as
<
ForNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
BreakStmt
:
if
(
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitBreak
(
pn
-
>
as
<
BreakStatement
>
(
)
.
label
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ContinueStmt
:
if
(
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emitContinue
(
pn
-
>
as
<
ContinueStatement
>
(
)
.
label
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
WithStmt
:
if
(
!
emitWith
(
&
pn
-
>
as
<
BinaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
TryStmt
:
if
(
!
emitTry
(
&
pn
-
>
as
<
TryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
Catch
:
if
(
!
emitCatch
(
&
pn
-
>
as
<
BinaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
VarStmt
:
if
(
!
emitDeclarationList
(
&
pn
-
>
as
<
ListNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ReturnStmt
:
if
(
!
emitReturn
(
&
pn
-
>
as
<
UnaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
YieldStarExpr
:
if
(
!
emitYieldStar
(
pn
-
>
as
<
UnaryNode
>
(
)
.
kid
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
Generator
:
if
(
!
emit1
(
JSOp
:
:
Generator
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
InitialYield
:
if
(
!
emitInitialYield
(
&
pn
-
>
as
<
UnaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
YieldExpr
:
if
(
!
emitYield
(
&
pn
-
>
as
<
UnaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
AwaitExpr
:
if
(
!
emitAwaitInInnermostScope
(
&
pn
-
>
as
<
UnaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
StatementList
:
if
(
!
emitStatementList
(
&
pn
-
>
as
<
ListNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
EmptyStmt
:
break
;
case
ParseNodeKind
:
:
ExpressionStmt
:
if
(
!
emitExpressionStatement
(
&
pn
-
>
as
<
UnaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
LabelStmt
:
if
(
!
emitLabeledStatement
(
&
pn
-
>
as
<
LabeledStatement
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
CommaExpr
:
if
(
!
emitSequenceExpr
(
&
pn
-
>
as
<
ListNode
>
(
)
valueUsage
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
InitExpr
:
case
ParseNodeKind
:
:
AssignExpr
:
case
ParseNodeKind
:
:
AddAssignExpr
:
case
ParseNodeKind
:
:
SubAssignExpr
:
case
ParseNodeKind
:
:
BitOrAssignExpr
:
case
ParseNodeKind
:
:
BitXorAssignExpr
:
case
ParseNodeKind
:
:
BitAndAssignExpr
:
case
ParseNodeKind
:
:
LshAssignExpr
:
case
ParseNodeKind
:
:
RshAssignExpr
:
case
ParseNodeKind
:
:
UrshAssignExpr
:
case
ParseNodeKind
:
:
MulAssignExpr
:
case
ParseNodeKind
:
:
DivAssignExpr
:
case
ParseNodeKind
:
:
ModAssignExpr
:
case
ParseNodeKind
:
:
PowAssignExpr
:
{
BinaryNode
*
assignNode
=
&
pn
-
>
as
<
BinaryNode
>
(
)
;
if
(
!
emitAssignmentOrInit
(
assignNode
-
>
getKind
(
)
assignNode
-
>
left
(
)
assignNode
-
>
right
(
)
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
CoalesceAssignExpr
:
case
ParseNodeKind
:
:
OrAssignExpr
:
case
ParseNodeKind
:
:
AndAssignExpr
:
if
(
!
emitShortCircuitAssignment
(
&
pn
-
>
as
<
AssignmentNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ConditionalExpr
:
if
(
!
emitConditionalExpression
(
pn
-
>
as
<
ConditionalExpression
>
(
)
valueUsage
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
OrExpr
:
case
ParseNodeKind
:
:
CoalesceExpr
:
case
ParseNodeKind
:
:
AndExpr
:
if
(
!
emitShortCircuit
(
&
pn
-
>
as
<
ListNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
AddExpr
:
case
ParseNodeKind
:
:
SubExpr
:
case
ParseNodeKind
:
:
BitOrExpr
:
case
ParseNodeKind
:
:
BitXorExpr
:
case
ParseNodeKind
:
:
BitAndExpr
:
case
ParseNodeKind
:
:
StrictEqExpr
:
case
ParseNodeKind
:
:
EqExpr
:
case
ParseNodeKind
:
:
StrictNeExpr
:
case
ParseNodeKind
:
:
NeExpr
:
case
ParseNodeKind
:
:
LtExpr
:
case
ParseNodeKind
:
:
LeExpr
:
case
ParseNodeKind
:
:
GtExpr
:
case
ParseNodeKind
:
:
GeExpr
:
case
ParseNodeKind
:
:
InExpr
:
case
ParseNodeKind
:
:
InstanceOfExpr
:
case
ParseNodeKind
:
:
LshExpr
:
case
ParseNodeKind
:
:
RshExpr
:
case
ParseNodeKind
:
:
UrshExpr
:
case
ParseNodeKind
:
:
MulExpr
:
case
ParseNodeKind
:
:
DivExpr
:
case
ParseNodeKind
:
:
ModExpr
:
if
(
!
emitLeftAssociative
(
&
pn
-
>
as
<
ListNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
PrivateInExpr
:
if
(
!
emitPrivateInExpr
(
&
pn
-
>
as
<
ListNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
PowExpr
:
if
(
!
emitRightAssociative
(
&
pn
-
>
as
<
ListNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
TypeOfNameExpr
:
if
(
!
emitTypeof
(
&
pn
-
>
as
<
UnaryNode
>
(
)
JSOp
:
:
Typeof
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
TypeOfExpr
:
if
(
!
emitTypeof
(
&
pn
-
>
as
<
UnaryNode
>
(
)
JSOp
:
:
TypeofExpr
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ThrowStmt
:
if
(
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
[
[
fallthrough
]
]
;
case
ParseNodeKind
:
:
VoidExpr
:
case
ParseNodeKind
:
:
NotExpr
:
case
ParseNodeKind
:
:
BitNotExpr
:
case
ParseNodeKind
:
:
PosExpr
:
case
ParseNodeKind
:
:
NegExpr
:
if
(
!
emitUnary
(
&
pn
-
>
as
<
UnaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
PreIncrementExpr
:
case
ParseNodeKind
:
:
PreDecrementExpr
:
case
ParseNodeKind
:
:
PostIncrementExpr
:
case
ParseNodeKind
:
:
PostDecrementExpr
:
if
(
!
emitIncOrDec
(
&
pn
-
>
as
<
UnaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
DeleteNameExpr
:
if
(
!
emitDeleteName
(
&
pn
-
>
as
<
UnaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
DeletePropExpr
:
if
(
!
emitDeleteProperty
(
&
pn
-
>
as
<
UnaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
DeleteElemExpr
:
if
(
!
emitDeleteElement
(
&
pn
-
>
as
<
UnaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
DeleteExpr
:
if
(
!
emitDeleteExpression
(
&
pn
-
>
as
<
UnaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
DeleteOptionalChainExpr
:
if
(
!
emitDeleteOptionalChain
(
&
pn
-
>
as
<
UnaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
OptionalChain
:
if
(
!
emitOptionalChain
(
&
pn
-
>
as
<
UnaryNode
>
(
)
valueUsage
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
DotExpr
:
{
PropertyAccess
*
prop
=
&
pn
-
>
as
<
PropertyAccess
>
(
)
;
bool
isSuper
=
prop
-
>
isSuper
(
)
;
PropOpEmitter
poe
(
this
PropOpEmitter
:
:
Kind
:
:
Get
isSuper
?
PropOpEmitter
:
:
ObjKind
:
:
Super
:
PropOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
poe
.
prepareForObj
(
)
)
{
return
false
;
}
if
(
isSuper
)
{
UnaryNode
*
base
=
&
prop
-
>
expression
(
)
.
as
<
UnaryNode
>
(
)
;
if
(
!
emitGetThisForSuperBase
(
base
)
)
{
return
false
;
}
}
else
{
if
(
!
emitPropLHS
(
prop
)
)
{
return
false
;
}
}
if
(
!
poe
.
emitGet
(
prop
-
>
key
(
)
.
atom
(
)
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
ElemExpr
:
{
PropertyByValue
*
elem
=
&
pn
-
>
as
<
PropertyByValue
>
(
)
;
bool
isSuper
=
elem
-
>
isSuper
(
)
;
MOZ_ASSERT
(
!
elem
-
>
key
(
)
.
isKind
(
ParseNodeKind
:
:
PrivateName
)
)
;
ElemOpEmitter
eoe
(
this
ElemOpEmitter
:
:
Kind
:
:
Get
isSuper
?
ElemOpEmitter
:
:
ObjKind
:
:
Super
:
ElemOpEmitter
:
:
ObjKind
:
:
Other
)
;
if
(
!
emitElemObjAndKey
(
elem
isSuper
eoe
)
)
{
return
false
;
}
if
(
!
eoe
.
emitGet
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
PrivateMemberExpr
:
{
PrivateMemberAccess
*
privateExpr
=
&
pn
-
>
as
<
PrivateMemberAccess
>
(
)
;
PrivateOpEmitter
xoe
(
this
PrivateOpEmitter
:
:
Kind
:
:
Get
privateExpr
-
>
privateName
(
)
.
name
(
)
)
;
if
(
!
emitTree
(
&
privateExpr
-
>
expression
(
)
)
)
{
return
false
;
}
if
(
!
xoe
.
emitReference
(
)
)
{
return
false
;
}
if
(
!
xoe
.
emitGet
(
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
NewExpr
:
case
ParseNodeKind
:
:
TaggedTemplateExpr
:
case
ParseNodeKind
:
:
CallExpr
:
case
ParseNodeKind
:
:
SuperCallExpr
:
if
(
!
emitCallOrNew
(
&
pn
-
>
as
<
CallNode
>
(
)
valueUsage
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
LexicalScope
:
if
(
!
emitLexicalScope
(
&
pn
-
>
as
<
LexicalScopeNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ConstDecl
:
case
ParseNodeKind
:
:
LetDecl
:
if
(
!
emitDeclarationList
(
&
pn
-
>
as
<
ListNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ImportDecl
:
MOZ_ASSERT
(
sc
-
>
isModuleContext
(
)
)
;
break
;
case
ParseNodeKind
:
:
ExportStmt
:
{
MOZ_ASSERT
(
sc
-
>
isModuleContext
(
)
)
;
UnaryNode
*
node
=
&
pn
-
>
as
<
UnaryNode
>
(
)
;
ParseNode
*
decl
=
node
-
>
kid
(
)
;
if
(
decl
-
>
getKind
(
)
!
=
ParseNodeKind
:
:
ExportSpecList
)
{
if
(
!
emitTree
(
decl
)
)
{
return
false
;
}
}
break
;
}
case
ParseNodeKind
:
:
ExportDefaultStmt
:
MOZ_ASSERT
(
sc
-
>
isModuleContext
(
)
)
;
if
(
!
emitExportDefault
(
&
pn
-
>
as
<
BinaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ExportFromStmt
:
MOZ_ASSERT
(
sc
-
>
isModuleContext
(
)
)
;
break
;
case
ParseNodeKind
:
:
CallSiteObj
:
if
(
!
emitCallSiteObject
(
&
pn
-
>
as
<
CallSiteNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ArrayExpr
:
if
(
!
emitArrayLiteral
(
&
pn
-
>
as
<
ListNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ObjectExpr
:
if
(
!
emitObject
(
&
pn
-
>
as
<
ListNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
Name
:
if
(
!
emitGetName
(
&
pn
-
>
as
<
NameNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
PrivateName
:
if
(
!
emitGetPrivateName
(
&
pn
-
>
as
<
NameNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
TemplateStringListExpr
:
if
(
!
emitTemplateString
(
&
pn
-
>
as
<
ListNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
TemplateStringExpr
:
case
ParseNodeKind
:
:
StringExpr
:
if
(
!
emitAtomOp
(
JSOp
:
:
String
pn
-
>
as
<
NameNode
>
(
)
.
atom
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
NumberExpr
:
if
(
!
emitNumberOp
(
pn
-
>
as
<
NumericLiteral
>
(
)
.
value
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
BigIntExpr
:
if
(
!
emitBigIntOp
(
&
pn
-
>
as
<
BigIntLiteral
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
RegExpExpr
:
{
GCThingIndex
index
;
if
(
!
perScriptData
(
)
.
gcThingList
(
)
.
append
(
&
pn
-
>
as
<
RegExpLiteral
>
(
)
&
index
)
)
{
return
false
;
}
if
(
!
emitRegExp
(
index
)
)
{
return
false
;
}
break
;
}
case
ParseNodeKind
:
:
TrueExpr
:
if
(
!
emit1
(
JSOp
:
:
True
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
FalseExpr
:
if
(
!
emit1
(
JSOp
:
:
False
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
NullExpr
:
if
(
!
emit1
(
JSOp
:
:
Null
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
RawUndefinedExpr
:
if
(
!
emit1
(
JSOp
:
:
Undefined
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ThisExpr
:
if
(
!
emitThisLiteral
(
&
pn
-
>
as
<
ThisLiteral
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
DebuggerStmt
:
if
(
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
begin
)
)
{
return
false
;
}
if
(
!
markStepBreakpoint
(
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOp
:
:
Debugger
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ClassDecl
:
if
(
!
emitClass
(
&
pn
-
>
as
<
ClassNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
NewTargetExpr
:
if
(
!
emit1
(
JSOp
:
:
NewTarget
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
ImportMetaExpr
:
if
(
!
emit1
(
JSOp
:
:
ImportMeta
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
CallImportExpr
:
if
(
!
emitTree
(
pn
-
>
as
<
BinaryNode
>
(
)
.
right
(
)
)
|
|
!
emit1
(
JSOp
:
:
DynamicImport
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
SetThis
:
if
(
!
emitSetThis
(
&
pn
-
>
as
<
BinaryNode
>
(
)
)
)
{
return
false
;
}
break
;
case
ParseNodeKind
:
:
PropertyNameExpr
:
case
ParseNodeKind
:
:
PosHolder
:
MOZ_FALLTHROUGH_ASSERT
(
"
Should
never
try
to
emit
ParseNodeKind
:
:
PosHolder
or
:
:
Property
"
)
;
default
:
MOZ_ASSERT
(
0
)
;
}
return
true
;
}
static
bool
AllocSrcNote
(
JSContext
*
cx
SrcNotesVector
&
notes
unsigned
size
unsigned
*
index
)
{
size_t
oldLength
=
notes
.
length
(
)
;
if
(
MOZ_UNLIKELY
(
oldLength
+
size
>
MaxSrcNotesLength
)
)
{
ReportAllocationOverflow
(
cx
)
;
return
false
;
}
if
(
!
notes
.
growByUninitialized
(
size
)
)
{
return
false
;
}
*
index
=
oldLength
;
return
true
;
}
bool
BytecodeEmitter
:
:
addTryNote
(
TryNoteKind
kind
uint32_t
stackDepth
BytecodeOffset
start
BytecodeOffset
end
)
{
MOZ_ASSERT
(
!
inPrologue
(
)
)
;
return
bytecodeSection
(
)
.
tryNoteList
(
)
.
append
(
kind
stackDepth
start
end
)
;
}
bool
BytecodeEmitter
:
:
newSrcNote
(
SrcNoteType
type
unsigned
*
indexp
)
{
MOZ_ASSERT_IF
(
skipLocationSrcNotes
(
)
|
|
skipBreakpointSrcNotes
(
)
type
<
=
SrcNoteType
:
:
LastGettable
)
;
SrcNotesVector
&
notes
=
bytecodeSection
(
)
.
notes
(
)
;
unsigned
index
;
BytecodeOffset
offset
=
bytecodeSection
(
)
.
offset
(
)
;
ptrdiff_t
delta
=
(
offset
-
bytecodeSection
(
)
.
lastNoteOffset
(
)
)
.
value
(
)
;
bytecodeSection
(
)
.
setLastNoteOffset
(
offset
)
;
auto
allocator
=
[
&
]
(
unsigned
size
)
-
>
SrcNote
*
{
if
(
!
AllocSrcNote
(
cx
notes
size
&
index
)
)
{
return
nullptr
;
}
return
&
notes
[
index
]
;
}
;
if
(
!
SrcNoteWriter
:
:
writeNote
(
type
delta
allocator
)
)
{
return
false
;
}
if
(
indexp
)
{
*
indexp
=
index
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
newSrcNote2
(
SrcNoteType
type
ptrdiff_t
offset
unsigned
*
indexp
)
{
unsigned
index
;
if
(
!
newSrcNote
(
type
&
index
)
)
{
return
false
;
}
if
(
!
newSrcNoteOperand
(
offset
)
)
{
return
false
;
}
if
(
indexp
)
{
*
indexp
=
index
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
newSrcNoteOperand
(
ptrdiff_t
operand
)
{
if
(
!
SrcNote
:
:
isRepresentableOperand
(
operand
)
)
{
reportError
(
nullptr
JSMSG_NEED_DIET
js_script_str
)
;
return
false
;
}
SrcNotesVector
&
notes
=
bytecodeSection
(
)
.
notes
(
)
;
auto
allocator
=
[
&
]
(
unsigned
size
)
-
>
SrcNote
*
{
unsigned
index
;
if
(
!
AllocSrcNote
(
cx
notes
size
&
index
)
)
{
return
nullptr
;
}
return
&
notes
[
index
]
;
}
;
return
SrcNoteWriter
:
:
writeOperand
(
operand
allocator
)
;
}
bool
BytecodeEmitter
:
:
intoScriptStencil
(
ScriptIndex
scriptIndex
)
{
js
:
:
UniquePtr
<
ImmutableScriptData
>
immutableScriptData
=
createImmutableScriptData
(
cx
)
;
if
(
!
immutableScriptData
)
{
return
false
;
}
MOZ_ASSERT
(
outermostScope
(
)
.
hasNonSyntacticScopeOnChain
(
)
=
=
sc
-
>
hasNonSyntacticScope
(
)
)
;
auto
&
things
=
perScriptData
(
)
.
gcThingList
(
)
.
objects
(
)
;
if
(
!
compilationState
.
appendGCThings
(
cx
scriptIndex
things
)
)
{
return
false
;
}
auto
*
sharedData
=
SharedImmutableScriptData
:
:
createWith
(
cx
std
:
:
move
(
immutableScriptData
)
)
;
if
(
!
sharedData
)
{
return
false
;
}
if
(
!
compilationState
.
sharedData
.
addAndShare
(
cx
scriptIndex
sharedData
)
)
{
return
false
;
}
ScriptStencil
&
script
=
compilationState
.
scriptData
[
scriptIndex
]
;
script
.
setHasSharedData
(
)
;
if
(
sc
-
>
isFunctionBox
(
)
)
{
FunctionBox
*
funbox
=
sc
-
>
asFunctionBox
(
)
;
MOZ_ASSERT
(
&
script
=
=
&
funbox
-
>
functionStencil
(
)
)
;
funbox
-
>
copyUpdatedImmutableFlags
(
)
;
MOZ_ASSERT
(
script
.
isFunction
(
)
)
;
}
else
{
ScriptStencilExtra
&
scriptExtra
=
compilationState
.
scriptExtra
[
scriptIndex
]
;
sc
-
>
copyScriptExtraFields
(
scriptExtra
)
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
allowSelfHostedIter
(
ParseNode
*
parseNode
)
{
return
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
&
&
parseNode
-
>
isKind
(
ParseNodeKind
:
:
CallExpr
)
&
&
parseNode
-
>
as
<
BinaryNode
>
(
)
.
left
(
)
-
>
isName
(
TaggedParserAtomIndex
:
:
WellKnown
:
:
allowContentIter
(
)
)
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_JITSPEW
)
void
BytecodeEmitter
:
:
dumpAtom
(
TaggedParserAtomIndex
index
)
const
{
parserAtoms
(
)
.
dump
(
index
)
;
}
#
endif
