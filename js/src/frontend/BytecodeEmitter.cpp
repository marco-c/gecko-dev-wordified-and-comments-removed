#
include
"
frontend
/
BytecodeEmitter
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
<
string
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
jsatom
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jsfun
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
jsopcode
.
h
"
#
include
"
jsscript
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
jsutil
.
h
"
#
include
"
asmjs
/
AsmJS
.
h
"
#
include
"
frontend
/
Parser
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
vm
/
Debugger
.
h
"
#
include
"
vm
/
GeneratorObject
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
jsatominlines
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
jsscriptinlines
.
h
"
#
include
"
frontend
/
ParseMaps
-
inl
.
h
"
#
include
"
frontend
/
ParseNode
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
#
include
"
vm
/
ScopeObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
namespace
js
:
:
frontend
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Some
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
NumberIsInt32
;
using
mozilla
:
:
PodCopy
;
struct
frontend
:
:
StmtInfoBCE
:
public
StmtInfoBase
{
StmtInfoBCE
*
enclosing
;
StmtInfoBCE
*
enclosingScope
;
JumpTarget
update
;
JumpList
breaks
;
JumpList
continues
;
uint32_t
blockScopeIndex
;
explicit
StmtInfoBCE
(
ExclusiveContext
*
cx
)
:
StmtInfoBase
(
cx
)
{
}
void
setTop
(
JumpTarget
top
)
{
update
=
top
;
breaks
=
JumpList
(
)
;
continues
=
JumpList
(
)
;
}
JumpList
&
gosubs
(
)
{
MOZ_ASSERT
(
type
=
=
StmtType
:
:
FINALLY
)
;
return
breaks
;
}
JumpList
&
guardJump
(
)
{
MOZ_ASSERT
(
type
=
=
StmtType
:
:
TRY
|
|
type
=
=
StmtType
:
:
FINALLY
)
;
return
continues
;
}
}
;
struct
frontend
:
:
LoopStmtInfo
:
public
StmtInfoBCE
{
int32_t
stackDepth
;
uint32_t
loopDepth
;
bool
canIonOsr
;
explicit
LoopStmtInfo
(
ExclusiveContext
*
cx
)
:
StmtInfoBCE
(
cx
)
{
}
static
LoopStmtInfo
*
fromStmtInfo
(
StmtInfoBCE
*
stmt
)
{
MOZ_ASSERT
(
stmt
-
>
isLoop
(
)
)
;
return
static_cast
<
LoopStmtInfo
*
>
(
stmt
)
;
}
}
;
BytecodeEmitter
:
:
BytecodeEmitter
(
BytecodeEmitter
*
parent
Parser
<
FullParseHandler
>
*
parser
SharedContext
*
sc
HandleScript
script
Handle
<
LazyScript
*
>
lazyScript
bool
insideEval
HandleScript
evalCaller
bool
insideNonGlobalEval
uint32_t
lineNum
EmitterMode
emitterMode
)
:
sc
(
sc
)
cx
(
sc
-
>
context
)
parent
(
parent
)
script
(
cx
script
)
lazyScript
(
cx
lazyScript
)
prologue
(
cx
lineNum
)
main
(
cx
lineNum
)
current
(
&
main
)
parser
(
parser
)
evalCaller
(
evalCaller
)
stmtStack
(
cx
)
atomIndices
(
cx
)
firstLine
(
lineNum
)
localsToFrameSlots_
(
cx
)
stackDepth
(
0
)
maxStackDepth
(
0
)
arrayCompDepth
(
0
)
emitLevel
(
0
)
constList
(
cx
)
tryNoteList
(
cx
)
blockScopeList
(
cx
)
yieldOffsetList
(
cx
)
typesetCount
(
0
)
hasSingletons
(
false
)
hasTryFinally
(
false
)
emittingForInit
(
false
)
emittingRunOnceLambda
(
false
)
insideEval
(
insideEval
)
insideNonGlobalEval
(
insideNonGlobalEval
)
insideModule
(
false
)
emitterMode
(
emitterMode
)
functionBodyEndPosSet
(
false
)
{
MOZ_ASSERT_IF
(
evalCaller
insideEval
)
;
MOZ_ASSERT_IF
(
emitterMode
=
=
LazyFunction
lazyScript
)
;
}
BytecodeEmitter
:
:
BytecodeEmitter
(
BytecodeEmitter
*
parent
Parser
<
FullParseHandler
>
*
parser
SharedContext
*
sc
HandleScript
script
Handle
<
LazyScript
*
>
lazyScript
bool
insideEval
HandleScript
evalCaller
bool
insideNonGlobalEval
TokenPos
bodyPosition
EmitterMode
emitterMode
)
:
BytecodeEmitter
(
parent
parser
sc
script
lazyScript
insideEval
evalCaller
insideNonGlobalEval
parser
-
>
tokenStream
.
srcCoords
.
lineNum
(
bodyPosition
.
begin
)
emitterMode
)
{
setFunctionBodyEndPos
(
bodyPosition
)
;
}
bool
BytecodeEmitter
:
:
init
(
)
{
return
atomIndices
.
ensureMap
(
cx
)
;
}
bool
BytecodeEmitter
:
:
updateLocalsToFrameSlots
(
)
{
if
(
localsToFrameSlots_
.
length
(
)
=
=
script
-
>
bindings
.
numLocals
(
)
)
{
return
true
;
}
localsToFrameSlots_
.
clear
(
)
;
if
(
!
localsToFrameSlots_
.
reserve
(
script
-
>
bindings
.
numLocals
(
)
)
)
return
false
;
uint32_t
slot
=
0
;
for
(
BindingIter
bi
(
script
)
;
!
bi
.
done
(
)
;
bi
+
+
)
{
if
(
bi
-
>
kind
(
)
=
=
Binding
:
:
ARGUMENT
)
continue
;
if
(
bi
-
>
aliased
(
)
)
localsToFrameSlots_
.
infallibleAppend
(
UINT32_MAX
)
;
else
localsToFrameSlots_
.
infallibleAppend
(
slot
+
+
)
;
}
for
(
size_t
i
=
0
;
i
<
script
-
>
bindings
.
numBlockScoped
(
)
;
i
+
+
)
localsToFrameSlots_
.
infallibleAppend
(
slot
+
+
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitCheck
(
ptrdiff_t
delta
ptrdiff_t
*
offset
)
{
*
offset
=
code
(
)
.
length
(
)
;
if
(
code
(
)
.
capacity
(
)
=
=
0
&
&
!
code
(
)
.
reserve
(
1024
)
)
return
false
;
if
(
!
code
(
)
.
growBy
(
delta
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
void
BytecodeEmitter
:
:
updateDepth
(
ptrdiff_t
target
)
{
jsbytecode
*
pc
=
code
(
target
)
;
int
nuses
=
StackUses
(
nullptr
pc
)
;
int
ndefs
=
StackDefs
(
nullptr
pc
)
;
stackDepth
-
=
nuses
;
MOZ_ASSERT
(
stackDepth
>
=
0
)
;
stackDepth
+
=
ndefs
;
if
(
(
uint32_t
)
stackDepth
>
maxStackDepth
)
maxStackDepth
=
stackDepth
;
}
#
ifdef
DEBUG
bool
BytecodeEmitter
:
:
checkStrictOrSloppy
(
JSOp
op
)
{
if
(
IsCheckStrictOp
(
op
)
&
&
!
sc
-
>
strict
(
)
)
return
false
;
if
(
IsCheckSloppyOp
(
op
)
&
&
sc
-
>
strict
(
)
)
return
false
;
return
true
;
}
#
endif
bool
BytecodeEmitter
:
:
emit1
(
JSOp
op
)
{
MOZ_ASSERT
(
checkStrictOrSloppy
(
op
)
)
;
ptrdiff_t
offset
;
if
(
!
emitCheck
(
1
&
offset
)
)
return
false
;
jsbytecode
*
code
=
this
-
>
code
(
offset
)
;
code
[
0
]
=
jsbytecode
(
op
)
;
updateDepth
(
offset
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emit2
(
JSOp
op
uint8_t
op1
)
{
MOZ_ASSERT
(
checkStrictOrSloppy
(
op
)
)
;
ptrdiff_t
offset
;
if
(
!
emitCheck
(
2
&
offset
)
)
return
false
;
jsbytecode
*
code
=
this
-
>
code
(
offset
)
;
code
[
0
]
=
jsbytecode
(
op
)
;
code
[
1
]
=
jsbytecode
(
op1
)
;
updateDepth
(
offset
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emit3
(
JSOp
op
jsbytecode
op1
jsbytecode
op2
)
{
MOZ_ASSERT
(
checkStrictOrSloppy
(
op
)
)
;
MOZ_ASSERT
(
!
IsArgOp
(
op
)
)
;
MOZ_ASSERT
(
!
IsLocalOp
(
op
)
)
;
ptrdiff_t
offset
;
if
(
!
emitCheck
(
3
&
offset
)
)
return
false
;
jsbytecode
*
code
=
this
-
>
code
(
offset
)
;
code
[
0
]
=
jsbytecode
(
op
)
;
code
[
1
]
=
op1
;
code
[
2
]
=
op2
;
updateDepth
(
offset
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitN
(
JSOp
op
size_t
extra
ptrdiff_t
*
offset
)
{
MOZ_ASSERT
(
checkStrictOrSloppy
(
op
)
)
;
ptrdiff_t
length
=
1
+
ptrdiff_t
(
extra
)
;
ptrdiff_t
off
;
if
(
!
emitCheck
(
length
&
off
)
)
return
false
;
jsbytecode
*
code
=
this
-
>
code
(
off
)
;
code
[
0
]
=
jsbytecode
(
op
)
;
if
(
CodeSpec
[
op
]
.
nuses
>
=
0
)
updateDepth
(
off
)
;
if
(
offset
)
*
offset
=
off
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitJumpTarget
(
JumpTarget
*
target
)
{
ptrdiff_t
off
=
offset
(
)
;
if
(
off
=
=
current
-
>
lastTarget
.
offset
+
ptrdiff_t
(
JSOP_JUMPTARGET_LENGTH
)
)
{
target
-
>
offset
=
current
-
>
lastTarget
.
offset
;
return
true
;
}
target
-
>
offset
=
off
;
current
-
>
lastTarget
.
offset
=
off
;
if
(
!
emit1
(
JSOP_JUMPTARGET
)
)
return
false
;
return
true
;
}
void
JumpList
:
:
push
(
jsbytecode
*
code
ptrdiff_t
jumpOffset
)
{
SET_JUMP_OFFSET
(
&
code
[
jumpOffset
]
offset
-
jumpOffset
)
;
offset
=
jumpOffset
;
}
void
JumpList
:
:
patchAll
(
jsbytecode
*
code
JumpTarget
target
)
{
ptrdiff_t
delta
;
for
(
ptrdiff_t
jumpOffset
=
offset
;
jumpOffset
!
=
-
1
;
jumpOffset
+
=
delta
)
{
jsbytecode
*
pc
=
&
code
[
jumpOffset
]
;
MOZ_ASSERT
(
IsJumpOpcode
(
JSOp
(
*
pc
)
)
|
|
JSOp
(
*
pc
)
=
=
JSOP_LABEL
)
;
delta
=
GET_JUMP_OFFSET
(
pc
)
;
MOZ_ASSERT
(
delta
<
0
)
;
ptrdiff_t
span
=
target
.
offset
-
jumpOffset
;
SET_JUMP_OFFSET
(
pc
span
)
;
}
}
bool
BytecodeEmitter
:
:
emitJumpNoFallthrough
(
JSOp
op
JumpList
*
jump
)
{
ptrdiff_t
offset
;
if
(
!
emitCheck
(
5
&
offset
)
)
return
false
;
jsbytecode
*
code
=
this
-
>
code
(
offset
)
;
code
[
0
]
=
jsbytecode
(
op
)
;
MOZ_ASSERT
(
-
1
<
=
jump
-
>
offset
&
&
jump
-
>
offset
<
offset
)
;
jump
-
>
push
(
this
-
>
code
(
0
)
offset
)
;
updateDepth
(
offset
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitJump
(
JSOp
op
JumpList
*
jump
)
{
if
(
!
emitJumpNoFallthrough
(
op
jump
)
)
return
false
;
if
(
BytecodeFallsThrough
(
op
)
)
{
JumpTarget
fallthrough
;
if
(
!
emitJumpTarget
(
&
fallthrough
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitBackwardJump
(
JSOp
op
JumpTarget
target
JumpList
*
jump
JumpTarget
*
fallthrough
)
{
if
(
!
emitJumpNoFallthrough
(
op
jump
)
)
return
false
;
patchJumpsToTarget
(
*
jump
target
)
;
if
(
!
emitJumpTarget
(
fallthrough
)
)
return
false
;
return
true
;
}
void
BytecodeEmitter
:
:
patchJumpsToTarget
(
JumpList
jump
JumpTarget
target
)
{
MOZ_ASSERT
(
-
1
<
=
jump
.
offset
&
&
jump
.
offset
<
=
offset
(
)
)
;
MOZ_ASSERT
(
0
<
=
target
.
offset
&
&
target
.
offset
<
=
offset
(
)
)
;
MOZ_ASSERT_IF
(
jump
.
offset
!
=
-
1
&
&
target
.
offset
+
4
<
=
offset
(
)
BytecodeIsJumpTarget
(
JSOp
(
*
code
(
target
.
offset
)
)
)
)
;
jump
.
patchAll
(
code
(
0
)
target
)
;
}
bool
BytecodeEmitter
:
:
emitJumpTargetAndPatch
(
JumpList
jump
)
{
if
(
jump
.
offset
=
=
-
1
)
return
true
;
JumpTarget
target
;
if
(
!
emitJumpTarget
(
&
target
)
)
return
false
;
patchJumpsToTarget
(
jump
target
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitCall
(
JSOp
op
uint16_t
argc
ParseNode
*
pn
)
{
if
(
pn
&
&
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
begin
)
)
return
false
;
return
emit3
(
op
ARGC_HI
(
argc
)
ARGC_LO
(
argc
)
)
;
}
bool
BytecodeEmitter
:
:
emitDupAt
(
unsigned
slotFromTop
)
{
MOZ_ASSERT
(
slotFromTop
<
unsigned
(
stackDepth
)
)
;
if
(
slotFromTop
>
=
JS_BIT
(
24
)
)
{
reportError
(
nullptr
JSMSG_TOO_MANY_LOCALS
)
;
return
false
;
}
ptrdiff_t
off
;
if
(
!
emitN
(
JSOP_DUPAT
3
&
off
)
)
return
false
;
jsbytecode
*
pc
=
code
(
off
)
;
SET_UINT24
(
pc
slotFromTop
)
;
return
true
;
}
static
const
char
*
StatementName
(
StmtInfoBCE
*
stmt
)
{
if
(
!
stmt
)
return
js_script_str
;
static
const
char
*
const
statementName
[
]
=
{
#
define
STATEMENT_TYPE_NAME
(
name
desc
)
desc
FOR_EACH_STATEMENT_TYPE
(
STATEMENT_TYPE_NAME
)
#
undef
STATEMENT_TYPE_NAME
}
;
static_assert
(
MOZ_ARRAY_LENGTH
(
statementName
)
=
=
uint16_t
(
StmtType
:
:
LIMIT
)
"
statementName
array
and
StmtType
enum
must
be
consistent
"
)
;
return
statementName
[
uint16_t
(
stmt
-
>
type
)
]
;
}
static
void
ReportStatementTooLarge
(
TokenStream
&
ts
StmtInfoBCE
*
stmt
)
{
ts
.
reportError
(
JSMSG_NEED_DIET
StatementName
(
stmt
)
)
;
}
static
inline
unsigned
LengthOfSetLine
(
unsigned
line
)
{
return
1
+
(
line
>
SN_4BYTE_OFFSET_MASK
?
4
:
1
)
;
}
bool
BytecodeEmitter
:
:
updateLineNumberNotes
(
uint32_t
offset
)
{
TokenStream
*
ts
=
&
parser
-
>
tokenStream
;
bool
onThisLine
;
if
(
!
ts
-
>
srcCoords
.
isOnThisLine
(
offset
currentLine
(
)
&
onThisLine
)
)
return
ts
-
>
reportError
(
JSMSG_OUT_OF_MEMORY
)
;
if
(
!
onThisLine
)
{
unsigned
line
=
ts
-
>
srcCoords
.
lineNum
(
offset
)
;
unsigned
delta
=
line
-
currentLine
(
)
;
current
-
>
currentLine
=
line
;
current
-
>
lastColumn
=
0
;
if
(
delta
>
=
LengthOfSetLine
(
line
)
)
{
if
(
!
newSrcNote2
(
SRC_SETLINE
ptrdiff_t
(
line
)
)
)
return
false
;
}
else
{
do
{
if
(
!
newSrcNote
(
SRC_NEWLINE
)
)
return
false
;
}
while
(
-
-
delta
!
=
0
)
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
updateSourceCoordNotes
(
uint32_t
offset
)
{
if
(
!
updateLineNumberNotes
(
offset
)
)
return
false
;
uint32_t
columnIndex
=
parser
-
>
tokenStream
.
srcCoords
.
columnIndex
(
offset
)
;
ptrdiff_t
colspan
=
ptrdiff_t
(
columnIndex
)
-
ptrdiff_t
(
current
-
>
lastColumn
)
;
if
(
colspan
!
=
0
)
{
if
(
!
SN_REPRESENTABLE_COLSPAN
(
colspan
)
)
return
true
;
if
(
!
newSrcNote2
(
SRC_COLSPAN
SN_COLSPAN_TO_OFFSET
(
colspan
)
)
)
return
false
;
current
-
>
lastColumn
=
columnIndex
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitLoopHead
(
ParseNode
*
nextpn
JumpTarget
*
top
)
{
if
(
nextpn
)
{
MOZ_ASSERT_IF
(
nextpn
-
>
isKind
(
PNK_STATEMENTLIST
)
nextpn
-
>
isArity
(
PN_LIST
)
)
;
if
(
nextpn
-
>
isKind
(
PNK_STATEMENTLIST
)
&
&
nextpn
-
>
pn_head
)
nextpn
=
nextpn
-
>
pn_head
;
if
(
!
updateSourceCoordNotes
(
nextpn
-
>
pn_pos
.
begin
)
)
return
false
;
}
*
top
=
{
offset
(
)
}
;
return
emit1
(
JSOP_LOOPHEAD
)
;
}
bool
BytecodeEmitter
:
:
emitLoopEntry
(
ParseNode
*
nextpn
JumpList
entryJump
)
{
if
(
nextpn
)
{
MOZ_ASSERT_IF
(
nextpn
-
>
isKind
(
PNK_STATEMENTLIST
)
nextpn
-
>
isArity
(
PN_LIST
)
)
;
if
(
nextpn
-
>
isKind
(
PNK_STATEMENTLIST
)
&
&
nextpn
-
>
pn_head
)
nextpn
=
nextpn
-
>
pn_head
;
if
(
!
updateSourceCoordNotes
(
nextpn
-
>
pn_pos
.
begin
)
)
return
false
;
}
JumpTarget
entry
{
offset
(
)
}
;
patchJumpsToTarget
(
entryJump
entry
)
;
LoopStmtInfo
*
loop
=
LoopStmtInfo
:
:
fromStmtInfo
(
innermostStmt
(
)
)
;
MOZ_ASSERT
(
loop
-
>
loopDepth
>
0
)
;
uint8_t
loopDepthAndFlags
=
PackLoopEntryDepthHintAndFlags
(
loop
-
>
loopDepth
loop
-
>
canIonOsr
)
;
return
emit2
(
JSOP_LOOPENTRY
loopDepthAndFlags
)
;
}
void
BytecodeEmitter
:
:
setContinueTarget
(
StmtInfoBCE
*
stmt
JumpTarget
target
)
{
do
{
stmt
-
>
update
=
target
;
stmt
=
stmt
-
>
enclosing
;
}
while
(
stmt
!
=
nullptr
&
&
stmt
-
>
type
=
=
StmtType
:
:
LABEL
)
;
}
void
BytecodeEmitter
:
:
setContinueHere
(
StmtInfoBCE
*
stmt
)
{
JumpTarget
continues
{
offset
(
)
}
;
setContinueTarget
(
stmt
continues
)
;
}
void
BytecodeEmitter
:
:
checkTypeSet
(
JSOp
op
)
{
if
(
CodeSpec
[
op
]
.
format
&
JOF_TYPESET
)
{
if
(
typesetCount
<
UINT16_MAX
)
typesetCount
+
+
;
}
}
bool
BytecodeEmitter
:
:
emitUint16Operand
(
JSOp
op
uint32_t
operand
)
{
MOZ_ASSERT
(
operand
<
=
UINT16_MAX
)
;
if
(
!
emit3
(
op
UINT16_HI
(
operand
)
UINT16_LO
(
operand
)
)
)
return
false
;
checkTypeSet
(
op
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitUint32Operand
(
JSOp
op
uint32_t
operand
)
{
ptrdiff_t
off
;
if
(
!
emitN
(
op
4
&
off
)
)
return
false
;
SET_UINT32
(
code
(
off
)
operand
)
;
checkTypeSet
(
op
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
flushPops
(
int
*
npops
)
{
MOZ_ASSERT
(
*
npops
!
=
0
)
;
if
(
!
emitUint16Operand
(
JSOP_POPN
*
npops
)
)
return
false
;
*
npops
=
0
;
return
true
;
}
namespace
{
class
NonLocalExitScope
{
BytecodeEmitter
*
bce
;
const
uint32_t
savedScopeIndex
;
const
int
savedDepth
;
uint32_t
openScopeIndex
;
NonLocalExitScope
(
const
NonLocalExitScope
&
)
=
delete
;
public
:
explicit
NonLocalExitScope
(
BytecodeEmitter
*
bce_
)
:
bce
(
bce_
)
savedScopeIndex
(
bce
-
>
blockScopeList
.
length
(
)
)
savedDepth
(
bce
-
>
stackDepth
)
openScopeIndex
(
UINT32_MAX
)
{
if
(
StmtInfoBCE
*
stmt
=
bce
-
>
innermostScopeStmt
(
)
)
openScopeIndex
=
stmt
-
>
blockScopeIndex
;
}
~
NonLocalExitScope
(
)
{
for
(
uint32_t
n
=
savedScopeIndex
;
n
<
bce
-
>
blockScopeList
.
length
(
)
;
n
+
+
)
bce
-
>
blockScopeList
.
recordEnd
(
n
bce
-
>
offset
(
)
bce
-
>
inPrologue
(
)
)
;
bce
-
>
stackDepth
=
savedDepth
;
}
bool
popScopeForNonLocalExit
(
uint32_t
blockScopeIndex
)
{
uint32_t
scopeObjectIndex
=
bce
-
>
blockScopeList
.
findEnclosingScope
(
blockScopeIndex
)
;
uint32_t
parent
=
openScopeIndex
;
if
(
!
bce
-
>
blockScopeList
.
append
(
scopeObjectIndex
bce
-
>
offset
(
)
bce
-
>
inPrologue
(
)
parent
)
)
return
false
;
openScopeIndex
=
bce
-
>
blockScopeList
.
length
(
)
-
1
;
return
true
;
}
bool
prepareForNonLocalJump
(
StmtInfoBCE
*
toStmt
)
;
}
;
bool
NonLocalExitScope
:
:
prepareForNonLocalJump
(
StmtInfoBCE
*
toStmt
)
{
int
npops
=
0
;
#
define
FLUSH_POPS
(
)
if
(
npops
&
&
!
bce
-
>
flushPops
(
&
npops
)
)
return
false
for
(
StmtInfoBCE
*
stmt
=
bce
-
>
innermostStmt
(
)
;
stmt
!
=
toStmt
;
stmt
=
stmt
-
>
enclosing
)
{
switch
(
stmt
-
>
type
)
{
case
StmtType
:
:
FINALLY
:
FLUSH_POPS
(
)
;
if
(
!
bce
-
>
emitJump
(
JSOP_GOSUB
&
stmt
-
>
gosubs
(
)
)
)
return
false
;
break
;
case
StmtType
:
:
WITH
:
if
(
!
bce
-
>
emit1
(
JSOP_LEAVEWITH
)
)
return
false
;
MOZ_ASSERT
(
stmt
-
>
linksScope
(
)
)
;
if
(
!
popScopeForNonLocalExit
(
stmt
-
>
blockScopeIndex
)
)
return
false
;
break
;
case
StmtType
:
:
FOR_OF_LOOP
:
npops
+
=
2
;
break
;
case
StmtType
:
:
FOR_IN_LOOP
:
npops
+
=
1
;
FLUSH_POPS
(
)
;
if
(
!
bce
-
>
emit1
(
JSOP_ENDITER
)
)
return
false
;
break
;
case
StmtType
:
:
SPREAD
:
MOZ_ASSERT_UNREACHABLE
(
"
can
'
t
break
/
continue
/
return
from
inside
a
spread
"
)
;
break
;
case
StmtType
:
:
SUBROUTINE
:
npops
+
=
3
;
break
;
default
:
;
}
if
(
stmt
-
>
isBlockScope
)
{
StaticBlockScope
&
blockScope
=
stmt
-
>
staticBlock
(
)
;
if
(
blockScope
.
needsClone
(
)
)
{
if
(
!
bce
-
>
emit1
(
JSOP_POPBLOCKSCOPE
)
)
return
false
;
}
else
{
if
(
!
bce
-
>
emit1
(
JSOP_DEBUGLEAVEBLOCK
)
)
return
false
;
}
if
(
!
popScopeForNonLocalExit
(
stmt
-
>
blockScopeIndex
)
)
return
false
;
}
}
FLUSH_POPS
(
)
;
return
true
;
#
undef
FLUSH_POPS
}
}
bool
BytecodeEmitter
:
:
emitGoto
(
StmtInfoBCE
*
toStmt
JumpList
*
jumplist
SrcNoteType
noteType
)
{
NonLocalExitScope
nle
(
this
)
;
if
(
!
nle
.
prepareForNonLocalJump
(
toStmt
)
)
return
false
;
if
(
noteType
!
=
SRC_NULL
)
{
if
(
!
newSrcNote
(
noteType
)
)
return
false
;
}
return
emitJump
(
JSOP_GOTO
jumplist
)
;
}
void
BytecodeEmitter
:
:
pushStatementInner
(
StmtInfoBCE
*
stmt
StmtType
type
JumpTarget
top
)
{
stmt
-
>
setTop
(
top
)
;
stmtStack
.
push
(
stmt
type
)
;
}
void
BytecodeEmitter
:
:
pushStatement
(
StmtInfoBCE
*
stmt
StmtType
type
JumpTarget
top
)
{
pushStatementInner
(
stmt
type
top
)
;
MOZ_ASSERT
(
!
stmt
-
>
isLoop
(
)
)
;
}
void
BytecodeEmitter
:
:
pushLoopStatement
(
LoopStmtInfo
*
stmt
StmtType
type
JumpTarget
top
)
{
pushStatementInner
(
stmt
type
top
)
;
MOZ_ASSERT
(
stmt
-
>
isLoop
(
)
)
;
LoopStmtInfo
*
enclosingLoop
=
nullptr
;
for
(
StmtInfoBCE
*
outer
=
stmt
-
>
enclosing
;
outer
;
outer
=
outer
-
>
enclosing
)
{
if
(
outer
-
>
isLoop
(
)
)
{
enclosingLoop
=
LoopStmtInfo
:
:
fromStmtInfo
(
outer
)
;
break
;
}
}
stmt
-
>
stackDepth
=
this
-
>
stackDepth
;
stmt
-
>
loopDepth
=
enclosingLoop
?
enclosingLoop
-
>
loopDepth
+
1
:
1
;
int
loopSlots
;
if
(
type
=
=
StmtType
:
:
SPREAD
)
loopSlots
=
3
;
else
if
(
type
=
=
StmtType
:
:
FOR_IN_LOOP
|
|
type
=
=
StmtType
:
:
FOR_OF_LOOP
)
loopSlots
=
2
;
else
loopSlots
=
0
;
MOZ_ASSERT
(
loopSlots
<
=
stmt
-
>
stackDepth
)
;
if
(
enclosingLoop
)
{
stmt
-
>
canIonOsr
=
(
enclosingLoop
-
>
canIonOsr
&
&
stmt
-
>
stackDepth
=
=
enclosingLoop
-
>
stackDepth
+
loopSlots
)
;
}
else
{
stmt
-
>
canIonOsr
=
stmt
-
>
stackDepth
=
=
loopSlots
;
}
}
JSObject
*
BytecodeEmitter
:
:
innermostStaticScope
(
)
const
{
if
(
StmtInfoBCE
*
stmt
=
innermostScopeStmt
(
)
)
return
stmt
-
>
staticScope
;
return
sc
-
>
staticScope
(
)
;
}
#
ifdef
DEBUG
static
bool
AllLocalsAliased
(
StaticBlockScope
&
obj
)
{
for
(
unsigned
i
=
0
;
i
<
obj
.
numVariables
(
)
;
i
+
+
)
if
(
!
obj
.
isAliased
(
i
)
)
return
false
;
return
true
;
}
#
endif
bool
BytecodeEmitter
:
:
computeAliasedSlots
(
Handle
<
StaticBlockScope
*
>
blockScope
)
{
uint32_t
numAliased
=
script
-
>
bindings
.
numAliasedBodyLevelLocals
(
)
;
for
(
unsigned
i
=
0
;
i
<
blockScope
-
>
numVariables
(
)
;
i
+
+
)
{
Definition
*
dn
=
blockScope
-
>
definitionParseNode
(
i
)
;
MOZ_ASSERT
(
dn
-
>
isDefn
(
)
)
;
uint32_t
index
=
dn
-
>
pn_scopecoord
.
slot
(
)
;
uint32_t
slot
;
if
(
isAliasedName
(
this
dn
)
)
{
slot
=
blockScope
-
>
blockIndexToSlot
(
index
)
;
blockScope
-
>
setAliased
(
i
true
)
;
}
else
{
slot
=
numAliased
+
blockScope
-
>
blockIndexToLocalIndex
(
index
)
;
blockScope
-
>
setAliased
(
i
false
)
;
}
if
(
!
dn
-
>
pn_scopecoord
.
setSlot
(
parser
-
>
tokenStream
slot
)
)
return
false
;
#
ifdef
DEBUG
for
(
ParseNode
*
pnu
=
dn
-
>
dn_uses
;
pnu
;
pnu
=
pnu
-
>
pn_link
)
{
MOZ_ASSERT
(
pnu
-
>
pn_lexdef
=
=
dn
)
;
MOZ_ASSERT
(
!
(
pnu
-
>
pn_dflags
&
PND_BOUND
)
)
;
MOZ_ASSERT
(
pnu
-
>
pn_scopecoord
.
isFree
(
)
)
;
}
#
endif
}
MOZ_ASSERT_IF
(
sc
-
>
allLocalsAliased
(
)
AllLocalsAliased
(
*
blockScope
)
)
;
return
true
;
}
void
BytecodeEmitter
:
:
computeLocalOffset
(
Handle
<
StaticBlockScope
*
>
blockScope
)
{
unsigned
nbodyfixed
=
!
sc
-
>
isGlobalContext
(
)
?
script
-
>
bindings
.
numUnaliasedBodyLevelLocals
(
)
:
0
;
unsigned
localOffset
=
nbodyfixed
;
if
(
StmtInfoBCE
*
stmt
=
innermostScopeStmt
(
)
)
{
Rooted
<
NestedStaticScope
*
>
outer
(
cx
stmt
-
>
staticScope
)
;
for
(
;
outer
;
outer
=
outer
-
>
enclosingNestedScope
(
)
)
{
if
(
outer
-
>
is
<
StaticBlockScope
>
(
)
&
&
!
IsStaticGlobalLexicalScope
(
outer
)
)
{
StaticBlockScope
&
outerBlock
=
outer
-
>
as
<
StaticBlockScope
>
(
)
;
localOffset
=
outerBlock
.
localOffset
(
)
+
outerBlock
.
numVariables
(
)
;
break
;
}
}
}
MOZ_ASSERT
(
localOffset
+
blockScope
-
>
numVariables
(
)
<
=
nbodyfixed
+
script
-
>
bindings
.
numBlockScoped
(
)
)
;
blockScope
-
>
setLocalOffset
(
localOffset
)
;
}
bool
BytecodeEmitter
:
:
enterNestedScope
(
StmtInfoBCE
*
stmt
ObjectBox
*
objbox
StmtType
stmtType
)
{
Rooted
<
NestedStaticScope
*
>
scope
(
cx
&
objbox
-
>
object
-
>
as
<
NestedStaticScope
>
(
)
)
;
uint32_t
scopeObjectIndex
=
objectList
.
add
(
objbox
)
;
switch
(
stmtType
)
{
case
StmtType
:
:
BLOCK
:
{
Rooted
<
StaticBlockScope
*
>
blockScope
(
cx
&
scope
-
>
as
<
StaticBlockScope
>
(
)
)
;
computeLocalOffset
(
blockScope
)
;
if
(
!
computeAliasedSlots
(
blockScope
)
)
return
false
;
if
(
blockScope
-
>
needsClone
(
)
)
{
if
(
!
emitInternedObjectOp
(
scopeObjectIndex
JSOP_PUSHBLOCKSCOPE
)
)
return
false
;
}
if
(
!
blockScope
-
>
makeNonExtensible
(
cx
)
)
return
false
;
break
;
}
case
StmtType
:
:
WITH
:
MOZ_ASSERT
(
scope
-
>
is
<
StaticWithScope
>
(
)
)
;
if
(
!
emitInternedObjectOp
(
scopeObjectIndex
JSOP_ENTERWITH
)
)
return
false
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
scope
statement
"
)
;
}
uint32_t
parent
=
BlockScopeNote
:
:
NoBlockScopeIndex
;
if
(
StmtInfoBCE
*
stmt
=
innermostScopeStmt
(
)
)
parent
=
stmt
-
>
blockScopeIndex
;
stmt
-
>
blockScopeIndex
=
blockScopeList
.
length
(
)
;
if
(
!
blockScopeList
.
append
(
scopeObjectIndex
offset
(
)
inPrologue
(
)
parent
)
)
return
false
;
JumpTarget
top
{
offset
(
)
}
;
pushStatement
(
stmt
stmtType
top
)
;
scope
-
>
initEnclosingScope
(
innermostStaticScope
(
)
)
;
stmtStack
.
linkAsInnermostScopeStmt
(
stmt
*
scope
)
;
MOZ_ASSERT
(
stmt
-
>
linksScope
(
)
)
;
stmt
-
>
isBlockScope
=
(
stmtType
=
=
StmtType
:
:
BLOCK
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
popStatement
(
)
{
if
(
!
innermostStmt
(
)
-
>
isTrying
(
)
)
{
if
(
!
emitJumpTargetAndPatch
(
innermostStmt
(
)
-
>
breaks
)
)
return
false
;
patchJumpsToTarget
(
innermostStmt
(
)
-
>
continues
innermostStmt
(
)
-
>
update
)
;
}
stmtStack
.
pop
(
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
leaveNestedScope
(
StmtInfoBCE
*
stmt
)
{
MOZ_ASSERT
(
stmt
=
=
innermostScopeStmt
(
)
)
;
MOZ_ASSERT
(
stmt
-
>
isBlockScope
=
=
!
(
stmt
-
>
type
=
=
StmtType
:
:
WITH
)
)
;
uint32_t
blockScopeIndex
=
stmt
-
>
blockScopeIndex
;
#
ifdef
DEBUG
MOZ_ASSERT
(
blockScopeList
.
list
[
blockScopeIndex
]
.
length
=
=
0
)
;
uint32_t
blockIndex
=
blockScopeList
.
list
[
blockScopeIndex
]
.
index
;
ObjectBox
*
blockObjBox
=
objectList
.
find
(
blockIndex
)
;
NestedStaticScope
*
staticScope
=
&
blockObjBox
-
>
object
-
>
as
<
NestedStaticScope
>
(
)
;
MOZ_ASSERT
(
stmt
-
>
staticScope
=
=
staticScope
)
;
MOZ_ASSERT_IF
(
!
stmt
-
>
isBlockScope
staticScope
-
>
is
<
StaticWithScope
>
(
)
)
;
#
endif
if
(
!
popStatement
(
)
)
return
false
;
if
(
stmt
-
>
isBlockScope
)
{
if
(
stmt
-
>
staticScope
-
>
as
<
StaticBlockScope
>
(
)
.
needsClone
(
)
)
{
if
(
!
emit1
(
JSOP_POPBLOCKSCOPE
)
)
return
false
;
}
else
{
if
(
!
emit1
(
JSOP_DEBUGLEAVEBLOCK
)
)
return
false
;
}
}
else
{
if
(
!
emit1
(
JSOP_LEAVEWITH
)
)
return
false
;
}
blockScopeList
.
recordEnd
(
blockScopeIndex
offset
(
)
inPrologue
(
)
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitIndex32
(
JSOp
op
uint32_t
index
)
{
MOZ_ASSERT
(
checkStrictOrSloppy
(
op
)
)
;
const
size_t
len
=
1
+
UINT32_INDEX_LEN
;
MOZ_ASSERT
(
len
=
=
size_t
(
CodeSpec
[
op
]
.
length
)
)
;
ptrdiff_t
offset
;
if
(
!
emitCheck
(
len
&
offset
)
)
return
false
;
jsbytecode
*
code
=
this
-
>
code
(
offset
)
;
code
[
0
]
=
jsbytecode
(
op
)
;
SET_UINT32_INDEX
(
code
index
)
;
updateDepth
(
offset
)
;
checkTypeSet
(
op
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitIndexOp
(
JSOp
op
uint32_t
index
)
{
MOZ_ASSERT
(
checkStrictOrSloppy
(
op
)
)
;
const
size_t
len
=
CodeSpec
[
op
]
.
length
;
MOZ_ASSERT
(
len
>
=
1
+
UINT32_INDEX_LEN
)
;
ptrdiff_t
offset
;
if
(
!
emitCheck
(
len
&
offset
)
)
return
false
;
jsbytecode
*
code
=
this
-
>
code
(
offset
)
;
code
[
0
]
=
jsbytecode
(
op
)
;
SET_UINT32_INDEX
(
code
index
)
;
updateDepth
(
offset
)
;
checkTypeSet
(
op
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitAtomOp
(
JSAtom
*
atom
JSOp
op
)
{
MOZ_ASSERT
(
atom
)
;
MOZ_ASSERT
(
JOF_OPTYPE
(
op
)
=
=
JOF_ATOM
)
;
MOZ_ASSERT_IF
(
op
=
=
JSOP_GETNAME
|
|
op
=
=
JSOP_GETGNAME
!
sc
-
>
isDotVariable
(
atom
)
|
|
atom
=
=
cx
-
>
names
(
)
.
dotThis
)
;
if
(
op
=
=
JSOP_GETPROP
&
&
atom
=
=
cx
-
>
names
(
)
.
length
)
{
op
=
JSOP_LENGTH
;
}
jsatomid
index
;
if
(
!
makeAtomIndex
(
atom
&
index
)
)
return
false
;
return
emitIndexOp
(
op
index
)
;
}
bool
BytecodeEmitter
:
:
emitAtomOp
(
ParseNode
*
pn
JSOp
op
)
{
MOZ_ASSERT
(
pn
-
>
pn_atom
!
=
nullptr
)
;
return
emitAtomOp
(
pn
-
>
pn_atom
op
)
;
}
bool
BytecodeEmitter
:
:
emitInternedObjectOp
(
uint32_t
index
JSOp
op
)
{
MOZ_ASSERT
(
JOF_OPTYPE
(
op
)
=
=
JOF_OBJECT
)
;
MOZ_ASSERT
(
index
<
objectList
.
length
)
;
return
emitIndex32
(
op
index
)
;
}
bool
BytecodeEmitter
:
:
emitObjectOp
(
ObjectBox
*
objbox
JSOp
op
)
{
return
emitInternedObjectOp
(
objectList
.
add
(
objbox
)
op
)
;
}
bool
BytecodeEmitter
:
:
emitObjectPairOp
(
ObjectBox
*
objbox1
ObjectBox
*
objbox2
JSOp
op
)
{
uint32_t
index
=
objectList
.
add
(
objbox1
)
;
objectList
.
add
(
objbox2
)
;
return
emitInternedObjectOp
(
index
op
)
;
}
bool
BytecodeEmitter
:
:
emitRegExp
(
uint32_t
index
)
{
return
emitIndex32
(
JSOP_REGEXP
index
)
;
}
bool
BytecodeEmitter
:
:
emitLocalOp
(
JSOp
op
uint32_t
slot
)
{
MOZ_ASSERT
(
JOF_OPTYPE
(
op
)
!
=
JOF_SCOPECOORD
)
;
MOZ_ASSERT
(
IsLocalOp
(
op
)
)
;
ptrdiff_t
off
;
if
(
!
emitN
(
op
LOCALNO_LEN
&
off
)
)
return
false
;
SET_LOCALNO
(
code
(
off
)
slot
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitUnaliasedVarOp
(
JSOp
op
uint32_t
slot
MaybeCheckLexical
checkLexical
)
{
MOZ_ASSERT
(
JOF_OPTYPE
(
op
)
!
=
JOF_SCOPECOORD
)
;
if
(
IsLocalOp
(
op
)
)
{
MOZ_ASSERT
(
localsToFrameSlots_
[
slot
]
<
=
slot
)
;
slot
=
localsToFrameSlots_
[
slot
]
;
if
(
checkLexical
)
{
MOZ_ASSERT
(
op
!
=
JSOP_INITLEXICAL
)
;
if
(
!
emitLocalOp
(
JSOP_CHECKLEXICAL
slot
)
)
return
false
;
}
return
emitLocalOp
(
op
slot
)
;
}
MOZ_ASSERT
(
IsArgOp
(
op
)
)
;
ptrdiff_t
off
;
if
(
!
emitN
(
op
ARGNO_LEN
&
off
)
)
return
false
;
SET_ARGNO
(
code
(
off
)
slot
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitScopeCoordOp
(
JSOp
op
ScopeCoordinate
sc
)
{
MOZ_ASSERT
(
JOF_OPTYPE
(
op
)
=
=
JOF_SCOPECOORD
)
;
unsigned
n
=
SCOPECOORD_HOPS_LEN
+
SCOPECOORD_SLOT_LEN
;
MOZ_ASSERT
(
int
(
n
)
+
1
=
=
CodeSpec
[
op
]
.
length
)
;
ptrdiff_t
off
;
if
(
!
emitN
(
op
n
&
off
)
)
return
false
;
jsbytecode
*
pc
=
code
(
off
)
;
SET_SCOPECOORD_HOPS
(
pc
sc
.
hops
(
)
)
;
pc
+
=
SCOPECOORD_HOPS_LEN
;
SET_SCOPECOORD_SLOT
(
pc
sc
.
slot
(
)
)
;
pc
+
=
SCOPECOORD_SLOT_LEN
;
checkTypeSet
(
op
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitAliasedVarOp
(
JSOp
op
ScopeCoordinate
sc
MaybeCheckLexical
checkLexical
)
{
if
(
checkLexical
)
{
MOZ_ASSERT
(
op
!
=
JSOP_INITALIASEDLEXICAL
)
;
if
(
!
emitScopeCoordOp
(
JSOP_CHECKALIASEDLEXICAL
sc
)
)
return
false
;
}
return
emitScopeCoordOp
(
op
sc
)
;
}
bool
BytecodeEmitter
:
:
lookupAliasedName
(
HandleScript
script
PropertyName
*
name
uint32_t
*
pslot
ParseNode
*
pn
)
{
LazyScript
:
:
FreeVariable
*
freeVariables
=
nullptr
;
uint32_t
lexicalBegin
=
0
;
uint32_t
numFreeVariables
=
0
;
if
(
emitterMode
=
=
BytecodeEmitter
:
:
LazyFunction
)
{
freeVariables
=
lazyScript
-
>
freeVariables
(
)
;
lexicalBegin
=
script
-
>
bindings
.
lexicalBegin
(
)
;
numFreeVariables
=
lazyScript
-
>
numFreeVariables
(
)
;
}
uint32_t
bindingIndex
=
0
;
uint32_t
slot
=
CallObject
:
:
RESERVED_SLOTS
;
for
(
BindingIter
bi
(
script
)
;
!
bi
.
done
(
)
;
bi
+
+
)
{
if
(
bi
-
>
aliased
(
)
)
{
if
(
bi
-
>
name
(
)
=
=
name
)
{
if
(
freeVariables
)
{
for
(
uint32_t
i
=
0
;
i
<
numFreeVariables
;
i
+
+
)
{
if
(
freeVariables
[
i
]
.
atom
(
)
=
=
name
)
{
if
(
freeVariables
[
i
]
.
isHoistedUse
(
)
&
&
bindingIndex
>
=
lexicalBegin
)
{
MOZ_ASSERT
(
pn
)
;
MOZ_ASSERT
(
pn
-
>
isUsed
(
)
)
;
pn
-
>
pn_dflags
|
=
PND_LEXICAL
;
}
break
;
}
}
}
*
pslot
=
slot
;
return
true
;
}
slot
+
+
;
}
bindingIndex
+
+
;
}
return
false
;
}
bool
BytecodeEmitter
:
:
lookupAliasedNameSlot
(
PropertyName
*
name
ScopeCoordinate
*
sc
)
{
uint32_t
slot
;
if
(
!
lookupAliasedName
(
script
name
&
slot
)
)
return
false
;
sc
-
>
setSlot
(
slot
)
;
return
true
;
}
static
inline
MaybeCheckLexical
NodeNeedsCheckLexical
(
ParseNode
*
pn
)
{
return
pn
-
>
isHoistedLexicalUse
(
)
?
CheckLexical
:
DontCheckLexical
;
}
static
inline
JSOp
UnaliasedVarOpToAliasedVarOp
(
JSOp
op
)
{
switch
(
op
)
{
case
JSOP_GETARG
:
case
JSOP_GETLOCAL
:
return
JSOP_GETALIASEDVAR
;
case
JSOP_SETARG
:
case
JSOP_SETLOCAL
:
return
JSOP_SETALIASEDVAR
;
case
JSOP_INITLEXICAL
:
return
JSOP_INITALIASEDLEXICAL
;
default
:
MOZ_CRASH
(
"
unexpected
var
op
"
)
;
}
}
static
inline
JSOp
CheckSetConstOp
(
JSOp
op
ParseNode
*
pn
)
{
if
(
pn
-
>
resolve
(
)
-
>
isConst
(
)
)
{
switch
(
op
)
{
case
JSOP_GETLOCAL
:
case
JSOP_GETALIASEDVAR
:
break
;
case
JSOP_INITLEXICAL
:
case
JSOP_INITALIASEDLEXICAL
:
break
;
case
JSOP_SETLOCAL
:
return
JSOP_THROWSETCONST
;
case
JSOP_SETALIASEDVAR
:
return
JSOP_THROWSETALIASEDCONST
;
default
:
MOZ_CRASH
(
"
unexpected
set
var
op
"
)
;
}
}
return
op
;
}
bool
BytecodeEmitter
:
:
emitVarOp
(
ParseNode
*
pn
JSOp
op
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_FUNCTION
)
|
|
pn
-
>
isKind
(
PNK_NAME
)
)
;
MOZ_ASSERT
(
!
pn
-
>
pn_scopecoord
.
isFree
(
)
)
;
if
(
pn
-
>
isDefn
(
)
)
{
if
(
pn
-
>
pn_scopecoord
.
isHopsUnknown
(
)
)
{
BytecodeEmitter
*
bceOfDef
;
uint32_t
hops
=
computeHops
(
pn
&
bceOfDef
)
;
MOZ_ASSERT
(
bceOfDef
=
=
this
)
;
if
(
!
pn
-
>
pn_scopecoord
.
setHops
(
parser
-
>
tokenStream
hops
)
)
return
false
;
}
#
ifdef
DEBUG
BytecodeEmitter
*
bceOfDef
;
uint32_t
hops
=
computeHops
(
pn
&
bceOfDef
)
;
MOZ_ASSERT
(
bceOfDef
=
=
this
)
;
MOZ_ASSERT
(
hops
=
=
pn
-
>
pn_scopecoord
.
hops
(
)
)
;
#
endif
if
(
!
computeDefinitionIsAliased
(
this
pn
-
>
resolve
(
)
&
op
)
)
return
false
;
}
if
(
IsAliasedVarOp
(
op
)
)
{
ScopeCoordinate
sc
;
sc
.
setHops
(
pn
-
>
pn_scopecoord
.
hops
(
)
)
;
sc
.
setSlot
(
pn
-
>
pn_scopecoord
.
slot
(
)
)
;
return
emitAliasedVarOp
(
CheckSetConstOp
(
op
pn
)
sc
NodeNeedsCheckLexical
(
pn
)
)
;
}
#
ifdef
DEBUG
BytecodeEmitter
*
bceOfDef
;
(
void
)
computeHops
(
pn
&
bceOfDef
)
;
MOZ_ASSERT
(
!
isAliasedName
(
bceOfDef
pn
)
)
;
#
endif
MOZ_ASSERT_IF
(
pn
-
>
isKind
(
PNK_NAME
)
IsArgOp
(
op
)
|
|
IsLocalOp
(
op
)
)
;
MOZ_ASSERT
(
pn
-
>
isUsed
(
)
|
|
pn
-
>
isDefn
(
)
)
;
return
emitUnaliasedVarOp
(
CheckSetConstOp
(
op
pn
)
pn
-
>
pn_scopecoord
.
slot
(
)
NodeNeedsCheckLexical
(
pn
)
)
;
}
static
JSOp
GetIncDecInfo
(
ParseNodeKind
kind
bool
*
post
)
{
MOZ_ASSERT
(
kind
=
=
PNK_POSTINCREMENT
|
|
kind
=
=
PNK_PREINCREMENT
|
|
kind
=
=
PNK_POSTDECREMENT
|
|
kind
=
=
PNK_PREDECREMENT
)
;
*
post
=
kind
=
=
PNK_POSTINCREMENT
|
|
kind
=
=
PNK_POSTDECREMENT
;
return
(
kind
=
=
PNK_POSTINCREMENT
|
|
kind
=
=
PNK_PREINCREMENT
)
?
JSOP_ADD
:
JSOP_SUB
;
}
bool
BytecodeEmitter
:
:
emitVarIncDec
(
ParseNode
*
pn
)
{
JSOp
op
=
pn
-
>
pn_kid
-
>
getOp
(
)
;
MOZ_ASSERT
(
IsArgOp
(
op
)
|
|
IsLocalOp
(
op
)
|
|
IsAliasedVarOp
(
op
)
)
;
MOZ_ASSERT
(
pn
-
>
pn_kid
-
>
isKind
(
PNK_NAME
)
)
;
MOZ_ASSERT
(
!
pn
-
>
pn_kid
-
>
pn_scopecoord
.
isFree
(
)
)
;
bool
post
;
JSOp
binop
=
GetIncDecInfo
(
pn
-
>
getKind
(
)
&
post
)
;
JSOp
getOp
setOp
;
if
(
IsLocalOp
(
op
)
)
{
getOp
=
JSOP_GETLOCAL
;
setOp
=
JSOP_SETLOCAL
;
}
else
if
(
IsArgOp
(
op
)
)
{
getOp
=
JSOP_GETARG
;
setOp
=
JSOP_SETARG
;
}
else
{
getOp
=
JSOP_GETALIASEDVAR
;
setOp
=
JSOP_SETALIASEDVAR
;
}
if
(
!
emitVarOp
(
pn
-
>
pn_kid
getOp
)
)
return
false
;
if
(
!
emit1
(
JSOP_POS
)
)
return
false
;
if
(
post
&
&
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emit1
(
JSOP_ONE
)
)
return
false
;
if
(
!
emit1
(
binop
)
)
return
false
;
if
(
!
emitVarOp
(
pn
-
>
pn_kid
setOp
)
)
return
false
;
if
(
post
&
&
!
emit1
(
JSOP_POP
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
atBodyLevel
(
StmtInfoBCE
*
stmt
)
const
{
if
(
sc
-
>
staticScope
(
)
-
>
is
<
StaticEvalScope
>
(
)
)
{
bool
bl
=
!
stmt
-
>
enclosing
;
MOZ_ASSERT_IF
(
bl
stmt
-
>
type
=
=
StmtType
:
:
BLOCK
)
;
MOZ_ASSERT_IF
(
bl
stmt
-
>
staticScope
-
>
as
<
StaticBlockScope
>
(
)
.
enclosingStaticScope
(
)
=
=
sc
-
>
staticScope
(
)
)
;
return
bl
;
}
return
!
stmt
;
}
uint32_t
BytecodeEmitter
:
:
computeHops
(
ParseNode
*
pn
BytecodeEmitter
*
*
bceOfDefOut
)
{
Definition
*
dn
=
pn
-
>
resolve
(
)
;
MOZ_ASSERT
(
dn
-
>
isDefn
(
)
)
;
MOZ_ASSERT
(
!
dn
-
>
isPlaceholder
(
)
)
;
MOZ_ASSERT
(
dn
-
>
isBound
(
)
)
;
uint32_t
hops
=
0
;
BytecodeEmitter
*
bceOfDef
=
this
;
StaticScopeIter
<
NoGC
>
ssi
(
innermostStaticScope
(
)
)
;
JSObject
*
defScope
=
blockScopeOfDef
(
dn
)
;
while
(
ssi
.
staticScope
(
)
!
=
defScope
)
{
if
(
ssi
.
hasSyntacticDynamicScopeObject
(
)
)
hops
+
+
;
if
(
ssi
.
type
(
)
=
=
StaticScopeIter
<
NoGC
>
:
:
Function
)
{
MOZ_ASSERT
(
dn
-
>
isClosed
(
)
)
;
bceOfDef
=
bceOfDef
-
>
parent
;
}
ssi
+
+
;
}
*
bceOfDefOut
=
bceOfDef
;
return
hops
;
}
uint32_t
BytecodeEmitter
:
:
computeHopsToEnclosingFunction
(
)
{
StaticScopeIter
<
NoGC
>
ssi
(
innermostStaticScope
(
)
)
;
uint32_t
hops
=
0
;
while
(
ssi
.
type
(
)
!
=
StaticScopeIter
<
NoGC
>
:
:
Function
)
{
if
(
ssi
.
hasSyntacticDynamicScopeObject
(
)
)
hops
+
+
;
ssi
+
+
;
}
return
hops
;
}
bool
BytecodeEmitter
:
:
isAliasedName
(
BytecodeEmitter
*
bceOfDef
ParseNode
*
pn
)
{
if
(
bceOfDef
!
=
this
)
return
true
;
Definition
*
dn
=
pn
-
>
resolve
(
)
;
switch
(
dn
-
>
kind
(
)
)
{
case
Definition
:
:
LET
:
case
Definition
:
:
CONSTANT
:
return
dn
-
>
isClosed
(
)
|
|
sc
-
>
allLocalsAliased
(
)
;
case
Definition
:
:
ARG
:
return
script
-
>
formalIsAliased
(
pn
-
>
pn_scopecoord
.
slot
(
)
)
;
case
Definition
:
:
VAR
:
MOZ_ASSERT_IF
(
sc
-
>
allLocalsAliased
(
)
script
-
>
localIsAliased
(
pn
-
>
pn_scopecoord
.
slot
(
)
)
)
;
return
script
-
>
localIsAliased
(
pn
-
>
pn_scopecoord
.
slot
(
)
)
;
case
Definition
:
:
PLACEHOLDER
:
case
Definition
:
:
NAMED_LAMBDA
:
case
Definition
:
:
MISSING
:
case
Definition
:
:
IMPORT
:
MOZ_CRASH
(
"
unexpected
dn
-
>
kind
"
)
;
}
return
false
;
}
bool
BytecodeEmitter
:
:
computeDefinitionIsAliased
(
BytecodeEmitter
*
bceOfDef
Definition
*
dn
JSOp
*
op
)
{
if
(
dn
-
>
isKnownAliased
(
)
)
{
*
op
=
UnaliasedVarOpToAliasedVarOp
(
*
op
)
;
}
else
if
(
isAliasedName
(
bceOfDef
dn
)
)
{
uint32_t
slot
=
dn
-
>
pn_scopecoord
.
slot
(
)
;
if
(
blockScopeOfDef
(
dn
)
-
>
is
<
JSFunction
>
(
)
|
|
blockScopeOfDef
(
dn
)
-
>
is
<
ModuleObject
>
(
)
)
{
MOZ_ASSERT
(
IsArgOp
(
*
op
)
|
|
slot
<
bceOfDef
-
>
script
-
>
bindings
.
numBodyLevelLocals
(
)
)
;
MOZ_ALWAYS_TRUE
(
bceOfDef
-
>
lookupAliasedName
(
bceOfDef
-
>
script
dn
-
>
name
(
)
&
slot
)
)
;
}
if
(
!
dn
-
>
pn_scopecoord
.
setSlot
(
parser
-
>
tokenStream
slot
)
)
return
false
;
*
op
=
UnaliasedVarOpToAliasedVarOp
(
*
op
)
;
dn
-
>
pn_dflags
|
=
PND_KNOWNALIASED
;
}
return
true
;
}
JSOp
BytecodeEmitter
:
:
strictifySetNameOp
(
JSOp
op
)
{
switch
(
op
)
{
case
JSOP_SETNAME
:
if
(
sc
-
>
strict
(
)
)
op
=
JSOP_STRICTSETNAME
;
break
;
case
JSOP_SETGNAME
:
if
(
sc
-
>
strict
(
)
)
op
=
JSOP_STRICTSETGNAME
;
break
;
default
:
;
}
return
op
;
}
void
BytecodeEmitter
:
:
strictifySetNameNode
(
ParseNode
*
pn
)
{
pn
-
>
setOp
(
strictifySetNameOp
(
pn
-
>
getOp
(
)
)
)
;
}
bool
BytecodeEmitter
:
:
tryConvertFreeName
(
ParseNode
*
pn
)
{
if
(
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
)
{
JSOp
op
;
switch
(
pn
-
>
getOp
(
)
)
{
case
JSOP_GETNAME
:
op
=
JSOP_GETINTRINSIC
;
break
;
case
JSOP_SETNAME
:
op
=
JSOP_SETINTRINSIC
;
break
;
default
:
MOZ_CRASH
(
"
intrinsic
"
)
;
}
pn
-
>
setOp
(
op
)
;
return
true
;
}
if
(
emitterMode
=
=
BytecodeEmitter
:
:
LazyFunction
)
{
for
(
StmtInfoBCE
*
stmt
=
innermostStmt
(
)
;
stmt
;
stmt
=
stmt
-
>
enclosing
)
{
if
(
stmt
-
>
type
=
=
StmtType
:
:
CATCH
)
return
true
;
}
uint32_t
hops
=
0
;
Maybe
<
uint32_t
>
slot
;
FunctionBox
*
funbox
=
sc
-
>
asFunctionBox
(
)
;
PropertyName
*
name
=
pn
-
>
pn_atom
-
>
asPropertyName
(
)
;
for
(
StaticScopeIter
<
NoGC
>
ssi
(
funbox
-
>
staticScope
(
)
)
;
!
ssi
.
done
(
)
;
ssi
+
+
)
{
if
(
ssi
.
type
(
)
=
=
StaticScopeIter
<
NoGC
>
:
:
Eval
)
{
if
(
ssi
.
eval
(
)
.
isNonGlobal
(
)
)
return
false
;
MOZ_ASSERT
(
!
slot
.
isSome
(
)
)
;
break
;
}
if
(
!
ssi
.
hasSyntacticDynamicScopeObject
(
)
)
continue
;
if
(
ssi
.
type
(
)
=
=
StaticScopeIter
<
NoGC
>
:
:
Function
)
{
RootedScript
funScript
(
cx
ssi
.
funScript
(
)
)
;
if
(
funScript
-
>
funHasExtensibleScope
(
)
|
|
ssi
.
fun
(
)
.
name
(
)
=
=
pn
-
>
pn_atom
)
return
false
;
if
(
script
!
=
funScript
)
{
uint32_t
slot_
;
if
(
lookupAliasedName
(
funScript
name
&
slot_
pn
)
)
{
slot
=
Some
(
slot_
)
;
break
;
}
}
}
else
if
(
ssi
.
type
(
)
=
=
StaticScopeIter
<
NoGC
>
:
:
Module
)
{
RootedScript
moduleScript
(
cx
ssi
.
moduleScript
(
)
)
;
uint32_t
slot_
;
if
(
lookupAliasedName
(
moduleScript
name
&
slot_
pn
)
)
{
slot
=
Some
(
slot_
)
;
break
;
}
RootedModuleEnvironmentObject
env
(
cx
&
ssi
.
module
(
)
.
initialEnvironment
(
)
)
;
RootedPropertyName
propName
(
cx
name
)
;
MOZ_ASSERT
(
env
)
;
if
(
env
-
>
hasImportBinding
(
propName
)
)
{
if
(
pn
-
>
getOp
(
)
=
=
JSOP_GETNAME
)
{
pn
-
>
setOp
(
JSOP_GETIMPORT
)
;
return
true
;
}
return
false
;
}
}
else
if
(
ssi
.
type
(
)
=
=
StaticScopeIter
<
NoGC
>
:
:
Block
)
{
RootedShape
shape
(
cx
ssi
.
block
(
)
.
lookupAliasedName
(
name
)
)
;
if
(
shape
)
{
if
(
!
shape
-
>
writable
(
)
&
&
pn
-
>
getOp
(
)
=
=
JSOP_SETNAME
)
return
false
;
slot
=
Some
(
shape
-
>
slot
(
)
)
;
pn
-
>
pn_dflags
|
=
PND_LEXICAL
;
break
;
}
}
else
{
MOZ_ASSERT
(
ssi
.
type
(
)
!
=
StaticScopeIter
<
NoGC
>
:
:
With
)
;
}
hops
+
+
;
}
if
(
slot
.
isSome
(
)
)
{
JSOp
op
;
switch
(
pn
-
>
getOp
(
)
)
{
case
JSOP_GETNAME
:
op
=
JSOP_GETALIASEDVAR
;
break
;
case
JSOP_SETNAME
:
op
=
JSOP_SETALIASEDVAR
;
break
;
default
:
return
false
;
}
pn
-
>
setOp
(
op
)
;
MOZ_ALWAYS_TRUE
(
pn
-
>
pn_scopecoord
.
set
(
parser
-
>
tokenStream
hops
*
slot
)
)
;
return
true
;
}
}
if
(
insideNonGlobalEval
)
return
false
;
if
(
insideModule
)
return
false
;
if
(
script
-
>
hasNonSyntacticScope
(
)
)
return
false
;
if
(
pn
-
>
isDeoptimized
(
)
)
return
false
;
if
(
sc
-
>
isFunctionBox
(
)
)
{
FunctionBox
*
funbox
=
sc
-
>
asFunctionBox
(
)
;
if
(
funbox
-
>
mightAliasLocals
(
)
)
return
false
;
}
if
(
insideEval
&
&
sc
-
>
strict
(
)
)
return
false
;
JSOp
op
;
switch
(
pn
-
>
getOp
(
)
)
{
case
JSOP_GETNAME
:
op
=
JSOP_GETGNAME
;
break
;
case
JSOP_SETNAME
:
op
=
strictifySetNameOp
(
JSOP_SETGNAME
)
;
break
;
default
:
MOZ_CRASH
(
"
gname
"
)
;
}
pn
-
>
setOp
(
op
)
;
MOZ_ASSERT_IF
(
op
=
=
JSOP_INITGLEXICAL
IsStaticGlobalLexicalScope
(
blockScopeOfDef
(
pn
-
>
resolve
(
)
)
)
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
bindNameToSlotHelper
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_NAME
)
)
;
if
(
pn
-
>
isBound
(
)
|
|
pn
-
>
isDeoptimized
(
)
)
return
true
;
JSOp
op
=
pn
-
>
getOp
(
)
;
MOZ_ASSERT
(
op
!
=
JSOP_CALLEE
)
;
MOZ_ASSERT
(
JOF_OPTYPE
(
op
)
=
=
JOF_ATOM
)
;
Definition
*
dn
;
if
(
pn
-
>
isUsed
(
)
)
{
MOZ_ASSERT
(
pn
-
>
pn_scopecoord
.
isFree
(
)
)
;
dn
=
pn
-
>
pn_lexdef
;
MOZ_ASSERT
(
dn
-
>
isDefn
(
)
)
;
pn
-
>
pn_dflags
|
=
(
dn
-
>
pn_dflags
&
PND_CONST
)
;
}
else
if
(
pn
-
>
isDefn
(
)
)
{
dn
=
&
pn
-
>
as
<
Definition
>
(
)
;
}
else
{
return
true
;
}
if
(
dn
-
>
pn_scopecoord
.
isFree
(
)
)
{
if
(
evalCaller
)
{
MOZ_ASSERT
(
script
-
>
treatAsRunOnce
(
)
|
|
sc
-
>
isFunctionBox
(
)
)
;
if
(
emittingForInit
)
return
true
;
if
(
!
evalCaller
-
>
functionOrCallerFunction
(
)
&
&
tryConvertFreeName
(
pn
)
)
{
pn
-
>
pn_dflags
|
=
PND_BOUND
;
return
true
;
}
return
true
;
}
if
(
!
tryConvertFreeName
(
pn
)
)
return
true
;
pn
-
>
pn_dflags
|
=
PND_BOUND
;
return
true
;
}
MOZ_ASSERT
(
!
pn
-
>
isDefn
(
)
)
;
MOZ_ASSERT
(
pn
-
>
isUsed
(
)
)
;
MOZ_ASSERT
(
pn
-
>
pn_lexdef
)
;
MOZ_ASSERT
(
pn
-
>
pn_scopecoord
.
isFree
(
)
)
;
switch
(
dn
-
>
kind
(
)
)
{
case
Definition
:
:
ARG
:
switch
(
op
)
{
case
JSOP_GETNAME
:
op
=
JSOP_GETARG
;
break
;
case
JSOP_SETNAME
:
case
JSOP_STRICTSETNAME
:
op
=
JSOP_SETARG
;
break
;
default
:
MOZ_CRASH
(
"
arg
"
)
;
}
MOZ_ASSERT
(
!
pn
-
>
isConst
(
)
)
;
break
;
case
Definition
:
:
VAR
:
case
Definition
:
:
CONSTANT
:
case
Definition
:
:
LET
:
switch
(
op
)
{
case
JSOP_GETNAME
:
op
=
JSOP_GETLOCAL
;
break
;
case
JSOP_SETNAME
:
case
JSOP_STRICTSETNAME
:
op
=
JSOP_SETLOCAL
;
break
;
default
:
MOZ_CRASH
(
"
local
"
)
;
}
break
;
case
Definition
:
:
NAMED_LAMBDA
:
{
MOZ_ASSERT
(
dn
-
>
isOp
(
JSOP_CALLEE
)
)
;
MOZ_ASSERT
(
op
!
=
JSOP_CALLEE
)
;
JSFunction
*
fun
=
sc
-
>
asFunctionBox
(
)
-
>
function
(
)
;
if
(
blockScopeOfDef
(
dn
)
!
=
fun
)
return
true
;
MOZ_ASSERT
(
fun
-
>
isLambda
(
)
)
;
MOZ_ASSERT
(
pn
-
>
pn_atom
=
=
fun
-
>
name
(
)
)
;
if
(
!
sc
-
>
asFunctionBox
(
)
-
>
needsCallObject
(
)
)
{
op
=
JSOP_CALLEE
;
pn
-
>
pn_dflags
|
=
PND_CONST
;
}
pn
-
>
setOp
(
op
)
;
pn
-
>
pn_dflags
|
=
PND_BOUND
;
return
true
;
}
case
Definition
:
:
PLACEHOLDER
:
return
true
;
case
Definition
:
:
IMPORT
:
if
(
op
=
=
JSOP_GETNAME
)
pn
-
>
setOp
(
JSOP_GETIMPORT
)
;
return
true
;
case
Definition
:
:
MISSING
:
MOZ_CRASH
(
"
unexpected
definition
kind
"
)
;
}
BytecodeEmitter
*
bceOfDef
;
uint32_t
slot
=
dn
-
>
pn_scopecoord
.
slot
(
)
;
uint32_t
hops
=
computeHops
(
pn
&
bceOfDef
)
;
if
(
dn
-
>
kind
(
)
=
=
Definition
:
:
LET
|
|
dn
-
>
kind
(
)
=
=
Definition
:
:
CONSTANT
)
{
if
(
IsStaticGlobalLexicalScope
(
blockScopeOfDef
(
dn
)
)
)
return
true
;
}
else
if
(
bceOfDef
!
=
this
&
&
bceOfDef
-
>
sc
-
>
isGlobalContext
(
)
)
{
return
true
;
}
if
(
!
pn
-
>
pn_scopecoord
.
set
(
parser
-
>
tokenStream
hops
slot
)
)
return
false
;
if
(
!
computeDefinitionIsAliased
(
bceOfDef
dn
&
op
)
)
return
false
;
if
(
IsAliasedVarOp
(
op
)
)
{
MOZ_ASSERT
(
dn
-
>
isKnownAliased
(
)
)
;
if
(
!
pn
-
>
pn_scopecoord
.
setSlot
(
parser
-
>
tokenStream
dn
-
>
pn_scopecoord
.
slot
(
)
)
)
return
false
;
}
MOZ_ASSERT
(
!
pn
-
>
isOp
(
op
)
)
;
pn
-
>
setOp
(
op
)
;
pn
-
>
pn_dflags
|
=
PND_BOUND
;
return
true
;
}
bool
BytecodeEmitter
:
:
bindNameToSlot
(
ParseNode
*
pn
)
{
if
(
!
bindNameToSlotHelper
(
pn
)
)
return
false
;
strictifySetNameNode
(
pn
)
;
if
(
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
&
&
!
pn
-
>
isBound
(
)
)
{
reportError
(
pn
JSMSG_SELFHOSTED_UNBOUND_NAME
)
;
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
checkSideEffects
(
ParseNode
*
pn
bool
*
answer
)
{
JS_CHECK_RECURSION
(
cx
return
false
)
;
restart
:
switch
(
pn
-
>
getKind
(
)
)
{
case
PNK_NOP
:
case
PNK_STRING
:
case
PNK_TEMPLATE_STRING
:
case
PNK_REGEXP
:
case
PNK_TRUE
:
case
PNK_FALSE
:
case
PNK_NULL
:
case
PNK_ELISION
:
case
PNK_GENERATOR
:
case
PNK_NUMBER
:
case
PNK_OBJECT_PROPERTY_NAME
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_NULLARY
)
)
;
*
answer
=
false
;
return
true
;
case
PNK_THIS
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_UNARY
)
)
;
*
answer
=
sc
-
>
needsThisTDZChecks
(
)
;
return
true
;
case
PNK_NEWTARGET
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_BINARY
)
)
;
MOZ_ASSERT
(
pn
-
>
pn_left
-
>
isKind
(
PNK_POSHOLDER
)
)
;
MOZ_ASSERT
(
pn
-
>
pn_right
-
>
isKind
(
PNK_POSHOLDER
)
)
;
*
answer
=
false
;
return
true
;
case
PNK_BREAK
:
case
PNK_CONTINUE
:
case
PNK_DEBUGGER
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_NULLARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_DOT
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_NAME
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_TYPEOFEXPR
:
case
PNK_VOID
:
case
PNK_NOT
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_UNARY
)
)
;
return
checkSideEffects
(
pn
-
>
pn_kid
answer
)
;
case
PNK_COMPUTED_NAME
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_UNARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_TYPEOFNAME
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_UNARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_MUTATEPROTO
:
case
PNK_ARRAYPUSH
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_UNARY
)
)
;
return
checkSideEffects
(
pn
-
>
pn_kid
answer
)
;
case
PNK_PREINCREMENT
:
case
PNK_POSTINCREMENT
:
case
PNK_PREDECREMENT
:
case
PNK_POSTDECREMENT
:
case
PNK_THROW
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_UNARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_BITNOT
:
case
PNK_POS
:
case
PNK_NEG
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_UNARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_SPREAD
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_UNARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_YIELD_STAR
:
case
PNK_YIELD
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_BINARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_DELETENAME
:
case
PNK_DELETEPROP
:
case
PNK_DELETEELEM
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_UNARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_DELETEEXPR
:
{
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_UNARY
)
)
;
ParseNode
*
expr
=
pn
-
>
pn_kid
;
return
checkSideEffects
(
expr
answer
)
;
}
case
PNK_SEMI
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_UNARY
)
)
;
if
(
ParseNode
*
expr
=
pn
-
>
pn_kid
)
return
checkSideEffects
(
expr
answer
)
;
*
answer
=
false
;
return
true
;
case
PNK_ASSIGN
:
case
PNK_ADDASSIGN
:
case
PNK_SUBASSIGN
:
case
PNK_BITORASSIGN
:
case
PNK_BITXORASSIGN
:
case
PNK_BITANDASSIGN
:
case
PNK_LSHASSIGN
:
case
PNK_RSHASSIGN
:
case
PNK_URSHASSIGN
:
case
PNK_MULASSIGN
:
case
PNK_DIVASSIGN
:
case
PNK_MODASSIGN
:
case
PNK_POWASSIGN
:
case
PNK_SETTHIS
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_BINARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_STATEMENTLIST
:
case
PNK_CATCHLIST
:
case
PNK_OR
:
case
PNK_AND
:
case
PNK_STRICTEQ
:
case
PNK_STRICTNE
:
case
PNK_COMMA
:
MOZ_ASSERT
(
pn
-
>
pn_count
>
0
)
;
MOZ_FALLTHROUGH
;
case
PNK_ARRAY
:
case
PNK_OBJECT
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_LIST
)
)
;
for
(
ParseNode
*
item
=
pn
-
>
pn_head
;
item
;
item
=
item
-
>
pn_next
)
{
if
(
!
checkSideEffects
(
item
answer
)
)
return
false
;
if
(
*
answer
)
return
true
;
}
return
true
;
case
PNK_BITOR
:
case
PNK_BITXOR
:
case
PNK_BITAND
:
case
PNK_EQ
:
case
PNK_NE
:
case
PNK_LT
:
case
PNK_LE
:
case
PNK_GT
:
case
PNK_GE
:
case
PNK_INSTANCEOF
:
case
PNK_IN
:
case
PNK_LSH
:
case
PNK_RSH
:
case
PNK_URSH
:
case
PNK_ADD
:
case
PNK_SUB
:
case
PNK_STAR
:
case
PNK_DIV
:
case
PNK_MOD
:
case
PNK_POW
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_LIST
)
)
;
MOZ_ASSERT
(
pn
-
>
pn_count
>
=
2
)
;
*
answer
=
true
;
return
true
;
case
PNK_COLON
:
case
PNK_CASE
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_BINARY
)
)
;
if
(
!
checkSideEffects
(
pn
-
>
pn_left
answer
)
)
return
false
;
if
(
*
answer
)
return
true
;
return
checkSideEffects
(
pn
-
>
pn_right
answer
)
;
case
PNK_ELEM
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_BINARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_IMPORT
:
case
PNK_EXPORT_FROM
:
case
PNK_EXPORT_DEFAULT
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_BINARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_EXPORT
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_UNARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_DOWHILE
:
case
PNK_WHILE
:
case
PNK_FOR
:
case
PNK_COMPREHENSIONFOR
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_BINARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_VAR
:
case
PNK_CONST
:
case
PNK_LET
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_LIST
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_IF
:
case
PNK_CONDITIONAL
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_TERNARY
)
)
;
if
(
!
checkSideEffects
(
pn
-
>
pn_kid1
answer
)
)
return
false
;
if
(
*
answer
)
return
true
;
if
(
!
checkSideEffects
(
pn
-
>
pn_kid2
answer
)
)
return
false
;
if
(
*
answer
)
return
true
;
if
(
(
pn
=
pn
-
>
pn_kid3
)
)
goto
restart
;
return
true
;
case
PNK_NEW
:
case
PNK_CALL
:
case
PNK_TAGGED_TEMPLATE
:
case
PNK_SUPERCALL
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_LIST
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_CLASS
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_TERNARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_WITH
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_BINARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_RETURN
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_BINARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_NAME
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_NAME
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_SHORTHAND
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_BINARY
)
)
;
*
answer
=
true
;
return
true
;
case
PNK_FUNCTION
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_CODE
)
)
;
*
answer
=
false
;
return
true
;
case
PNK_MODULE
:
*
answer
=
false
;
return
true
;
case
PNK_GENEXP
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_LIST
)
)
;
*
answer
=
false
;
return
true
;
case
PNK_TRY
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_TERNARY
)
)
;
if
(
!
checkSideEffects
(
pn
-
>
pn_kid1
answer
)
)
return
false
;
if
(
*
answer
)
return
true
;
if
(
ParseNode
*
catchList
=
pn
-
>
pn_kid2
)
{
MOZ_ASSERT
(
catchList
-
>
isKind
(
PNK_CATCHLIST
)
)
;
if
(
!
checkSideEffects
(
catchList
answer
)
)
return
false
;
if
(
*
answer
)
return
true
;
}
if
(
ParseNode
*
finallyBlock
=
pn
-
>
pn_kid3
)
{
if
(
!
checkSideEffects
(
finallyBlock
answer
)
)
return
false
;
}
return
true
;
case
PNK_CATCH
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_TERNARY
)
)
;
if
(
!
checkSideEffects
(
pn
-
>
pn_kid1
answer
)
)
return
false
;
if
(
*
answer
)
return
true
;
if
(
ParseNode
*
cond
=
pn
-
>
pn_kid2
)
{
if
(
!
checkSideEffects
(
cond
answer
)
)
return
false
;
if
(
*
answer
)
return
true
;
}
return
checkSideEffects
(
pn
-
>
pn_kid3
answer
)
;
case
PNK_SWITCH
:
case
PNK_LETBLOCK
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_BINARY
)
)
;
if
(
!
checkSideEffects
(
pn
-
>
pn_left
answer
)
)
return
false
;
return
*
answer
|
|
checkSideEffects
(
pn
-
>
pn_right
answer
)
;
case
PNK_LABEL
:
case
PNK_LEXICALSCOPE
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_NAME
)
)
;
return
checkSideEffects
(
pn
-
>
expr
(
)
answer
)
;
case
PNK_TEMPLATE_STRING_LIST
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_LIST
)
)
;
MOZ_ASSERT
(
pn
-
>
pn_count
>
0
)
;
MOZ_ASSERT
(
(
pn
-
>
pn_count
%
2
)
=
=
1
"
template
strings
must
alternate
template
and
substitution
"
"
parts
"
)
;
*
answer
=
pn
-
>
pn_count
>
1
;
return
true
;
case
PNK_ARRAYCOMP
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_LIST
)
)
;
MOZ_ASSERT
(
pn
-
>
pn_count
=
=
1
)
;
return
checkSideEffects
(
pn
-
>
pn_head
answer
)
;
case
PNK_ANNEXB_FUNCTION
:
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_BINARY
)
)
;
if
(
pn
-
>
pn_left
-
>
isKind
(
PNK_NOP
)
)
{
*
answer
=
false
;
return
true
;
}
return
checkSideEffects
(
pn
-
>
pn_left
answer
)
;
case
PNK_ARGSBODY
:
*
answer
=
true
;
return
true
;
case
PNK_FORIN
:
case
PNK_FOROF
:
case
PNK_FORHEAD
:
case
PNK_CLASSMETHOD
:
case
PNK_CLASSNAMES
:
case
PNK_CLASSMETHODLIST
:
case
PNK_IMPORT_SPEC_LIST
:
case
PNK_IMPORT_SPEC
:
case
PNK_EXPORT_BATCH_SPEC
:
case
PNK_EXPORT_SPEC_LIST
:
case
PNK_EXPORT_SPEC
:
case
PNK_CALLSITEOBJ
:
case
PNK_POSHOLDER
:
case
PNK_SUPERBASE
:
MOZ_CRASH
(
"
handled
by
parent
nodes
"
)
;
case
PNK_LIMIT
:
MOZ_CRASH
(
"
invalid
node
kind
"
)
;
}
MOZ_CRASH
(
"
invalid
unenumerated
ParseNodeKind
value
encountered
in
"
"
BytecodeEmitter
:
:
checkSideEffects
"
)
;
}
bool
BytecodeEmitter
:
:
isInLoop
(
)
{
for
(
StmtInfoBCE
*
stmt
=
innermostStmt
(
)
;
stmt
;
stmt
=
stmt
-
>
enclosing
)
{
if
(
stmt
-
>
isLoop
(
)
)
return
true
;
}
return
false
;
}
bool
BytecodeEmitter
:
:
checkSingletonContext
(
)
{
if
(
!
script
-
>
treatAsRunOnce
(
)
|
|
sc
-
>
isFunctionBox
(
)
|
|
isInLoop
(
)
)
return
false
;
hasSingletons
=
true
;
return
true
;
}
bool
BytecodeEmitter
:
:
checkRunOnceContext
(
)
{
return
checkSingletonContext
(
)
|
|
(
!
isInLoop
(
)
&
&
isRunOnceLambda
(
)
)
;
}
bool
BytecodeEmitter
:
:
needsImplicitThis
(
)
{
if
(
sc
-
>
inWith
(
)
)
return
true
;
for
(
StmtInfoBCE
*
stmt
=
innermostStmt
(
)
;
stmt
;
stmt
=
stmt
-
>
enclosing
)
{
if
(
stmt
-
>
type
=
=
StmtType
:
:
WITH
)
return
true
;
}
return
false
;
}
void
BytecodeEmitter
:
:
tellDebuggerAboutCompiledScript
(
ExclusiveContext
*
cx
)
{
if
(
!
cx
-
>
isJSContext
(
)
)
return
;
if
(
emitterMode
!
=
LazyFunction
&
&
!
parent
)
{
Debugger
:
:
onNewScript
(
cx
-
>
asJSContext
(
)
script
)
;
}
}
inline
TokenStream
*
BytecodeEmitter
:
:
tokenStream
(
)
{
return
&
parser
-
>
tokenStream
;
}
bool
BytecodeEmitter
:
:
reportError
(
ParseNode
*
pn
unsigned
errorNumber
.
.
.
)
{
TokenPos
pos
=
pn
?
pn
-
>
pn_pos
:
tokenStream
(
)
-
>
currentToken
(
)
.
pos
;
va_list
args
;
va_start
(
args
errorNumber
)
;
bool
result
=
tokenStream
(
)
-
>
reportCompileErrorNumberVA
(
pos
.
begin
JSREPORT_ERROR
errorNumber
args
)
;
va_end
(
args
)
;
return
result
;
}
bool
BytecodeEmitter
:
:
reportStrictWarning
(
ParseNode
*
pn
unsigned
errorNumber
.
.
.
)
{
TokenPos
pos
=
pn
?
pn
-
>
pn_pos
:
tokenStream
(
)
-
>
currentToken
(
)
.
pos
;
va_list
args
;
va_start
(
args
errorNumber
)
;
bool
result
=
tokenStream
(
)
-
>
reportStrictWarningErrorNumberVA
(
pos
.
begin
errorNumber
args
)
;
va_end
(
args
)
;
return
result
;
}
bool
BytecodeEmitter
:
:
reportStrictModeError
(
ParseNode
*
pn
unsigned
errorNumber
.
.
.
)
{
TokenPos
pos
=
pn
?
pn
-
>
pn_pos
:
tokenStream
(
)
-
>
currentToken
(
)
.
pos
;
va_list
args
;
va_start
(
args
errorNumber
)
;
bool
result
=
tokenStream
(
)
-
>
reportStrictModeErrorNumberVA
(
pos
.
begin
sc
-
>
strict
(
)
errorNumber
args
)
;
va_end
(
args
)
;
return
result
;
}
bool
BytecodeEmitter
:
:
emitNewInit
(
JSProtoKey
key
)
{
const
size_t
len
=
1
+
UINT32_INDEX_LEN
;
ptrdiff_t
offset
;
if
(
!
emitCheck
(
len
&
offset
)
)
return
false
;
jsbytecode
*
code
=
this
-
>
code
(
offset
)
;
code
[
0
]
=
JSOP_NEWINIT
;
code
[
1
]
=
jsbytecode
(
key
)
;
code
[
2
]
=
0
;
code
[
3
]
=
0
;
code
[
4
]
=
0
;
updateDepth
(
offset
)
;
checkTypeSet
(
JSOP_NEWINIT
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
iteratorResultShape
(
unsigned
*
shape
)
{
gc
:
:
AllocKind
kind
=
gc
:
:
GetGCObjectKind
(
2
)
;
RootedPlainObject
obj
(
cx
NewBuiltinClassInstance
<
PlainObject
>
(
cx
kind
TenuredObject
)
)
;
if
(
!
obj
)
return
false
;
Rooted
<
jsid
>
value_id
(
cx
AtomToId
(
cx
-
>
names
(
)
.
value
)
)
;
Rooted
<
jsid
>
done_id
(
cx
AtomToId
(
cx
-
>
names
(
)
.
done
)
)
;
if
(
!
NativeDefineProperty
(
cx
obj
value_id
UndefinedHandleValue
nullptr
nullptr
JSPROP_ENUMERATE
)
)
{
return
false
;
}
if
(
!
NativeDefineProperty
(
cx
obj
done_id
UndefinedHandleValue
nullptr
nullptr
JSPROP_ENUMERATE
)
)
{
return
false
;
}
ObjectBox
*
objbox
=
parser
-
>
newObjectBox
(
obj
)
;
if
(
!
objbox
)
return
false
;
*
shape
=
objectList
.
add
(
objbox
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitPrepareIteratorResult
(
)
{
unsigned
shape
;
if
(
!
iteratorResultShape
(
&
shape
)
)
return
false
;
return
emitIndex32
(
JSOP_NEWOBJECT
shape
)
;
}
bool
BytecodeEmitter
:
:
emitFinishIteratorResult
(
bool
done
)
{
jsatomid
value_id
;
if
(
!
makeAtomIndex
(
cx
-
>
names
(
)
.
value
&
value_id
)
)
return
false
;
jsatomid
done_id
;
if
(
!
makeAtomIndex
(
cx
-
>
names
(
)
.
done
&
done_id
)
)
return
false
;
if
(
!
emitIndex32
(
JSOP_INITPROP
value_id
)
)
return
false
;
if
(
!
emit1
(
done
?
JSOP_TRUE
:
JSOP_FALSE
)
)
return
false
;
if
(
!
emitIndex32
(
JSOP_INITPROP
done_id
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitNameOp
(
ParseNode
*
pn
bool
callContext
)
{
if
(
!
bindNameToSlot
(
pn
)
)
return
false
;
JSOp
op
=
pn
-
>
getOp
(
)
;
if
(
op
=
=
JSOP_CALLEE
)
{
if
(
!
emit1
(
op
)
)
return
false
;
}
else
{
if
(
!
pn
-
>
pn_scopecoord
.
isFree
(
)
)
{
MOZ_ASSERT
(
JOF_OPTYPE
(
op
)
!
=
JOF_ATOM
)
;
if
(
!
emitVarOp
(
pn
op
)
)
return
false
;
}
else
{
if
(
!
emitAtomOp
(
pn
op
)
)
return
false
;
}
}
if
(
callContext
)
{
if
(
op
=
=
JSOP_GETNAME
|
|
op
=
=
JSOP_GETGNAME
)
{
JSOp
thisOp
=
needsImplicitThis
(
)
?
JSOP_IMPLICITTHIS
:
JSOP_GIMPLICITTHIS
;
if
(
!
emitAtomOp
(
pn
thisOp
)
)
return
false
;
}
else
{
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitPropLHS
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_DOT
)
)
;
MOZ_ASSERT
(
!
pn
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
;
ParseNode
*
pn2
=
pn
-
>
maybeExpr
(
)
;
if
(
pn2
-
>
isKind
(
PNK_DOT
)
&
&
!
pn2
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
{
ParseNode
*
pndot
=
pn2
;
ParseNode
*
pnup
=
nullptr
;
ParseNode
*
pndown
;
for
(
;
;
)
{
MOZ_ASSERT
(
!
pndot
-
>
isUsed
(
)
)
;
pndown
=
pndot
-
>
pn_expr
;
pndot
-
>
pn_expr
=
pnup
;
if
(
!
pndown
-
>
isKind
(
PNK_DOT
)
|
|
pndown
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
break
;
pnup
=
pndot
;
pndot
=
pndown
;
}
if
(
!
emitTree
(
pndown
)
)
return
false
;
do
{
if
(
!
emitAtomOp
(
pndot
JSOP_GETPROP
)
)
return
false
;
pnup
=
pndot
-
>
pn_expr
;
pndot
-
>
pn_expr
=
pndown
;
pndown
=
pndot
;
}
while
(
(
pndot
=
pnup
)
!
=
nullptr
)
;
return
true
;
}
return
emitTree
(
pn2
)
;
}
bool
BytecodeEmitter
:
:
emitSuperPropLHS
(
ParseNode
*
superBase
bool
isCall
)
{
if
(
!
emitGetThisForSuperBase
(
superBase
)
)
return
false
;
if
(
isCall
&
&
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emit1
(
JSOP_SUPERBASE
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitPropOp
(
ParseNode
*
pn
JSOp
op
)
{
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_NAME
)
)
;
if
(
!
emitPropLHS
(
pn
)
)
return
false
;
if
(
op
=
=
JSOP_CALLPROP
&
&
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitAtomOp
(
pn
op
)
)
return
false
;
if
(
op
=
=
JSOP_CALLPROP
&
&
!
emit1
(
JSOP_SWAP
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitSuperPropOp
(
ParseNode
*
pn
JSOp
op
bool
isCall
)
{
ParseNode
*
base
=
&
pn
-
>
as
<
PropertyAccess
>
(
)
.
expression
(
)
;
if
(
!
emitSuperPropLHS
(
base
isCall
)
)
return
false
;
if
(
!
emitAtomOp
(
pn
op
)
)
return
false
;
if
(
isCall
&
&
!
emit1
(
JSOP_SWAP
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitPropIncDec
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
pn_kid
-
>
isKind
(
PNK_DOT
)
)
;
bool
post
;
bool
isSuper
=
pn
-
>
pn_kid
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
;
JSOp
binop
=
GetIncDecInfo
(
pn
-
>
getKind
(
)
&
post
)
;
if
(
isSuper
)
{
ParseNode
*
base
=
&
pn
-
>
pn_kid
-
>
as
<
PropertyAccess
>
(
)
.
expression
(
)
;
if
(
!
emitSuperPropLHS
(
base
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP2
)
)
return
false
;
}
else
{
if
(
!
emitPropLHS
(
pn
-
>
pn_kid
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
}
if
(
!
emitAtomOp
(
pn
-
>
pn_kid
isSuper
?
JSOP_GETPROP_SUPER
:
JSOP_GETPROP
)
)
return
false
;
if
(
!
emit1
(
JSOP_POS
)
)
return
false
;
if
(
post
&
&
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emit1
(
JSOP_ONE
)
)
return
false
;
if
(
!
emit1
(
binop
)
)
return
false
;
if
(
post
)
{
if
(
!
emit2
(
JSOP_PICK
2
+
isSuper
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
if
(
isSuper
)
{
if
(
!
emit2
(
JSOP_PICK
3
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
}
}
JSOp
setOp
=
isSuper
?
sc
-
>
strict
(
)
?
JSOP_STRICTSETPROP_SUPER
:
JSOP_SETPROP_SUPER
:
sc
-
>
strict
(
)
?
JSOP_STRICTSETPROP
:
JSOP_SETPROP
;
if
(
!
emitAtomOp
(
pn
-
>
pn_kid
setOp
)
)
return
false
;
if
(
post
&
&
!
emit1
(
JSOP_POP
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitNameIncDec
(
ParseNode
*
pn
)
{
const
JSCodeSpec
*
cs
=
&
CodeSpec
[
pn
-
>
pn_kid
-
>
getOp
(
)
]
;
bool
global
=
(
cs
-
>
format
&
JOF_GNAME
)
;
bool
post
;
JSOp
binop
=
GetIncDecInfo
(
pn
-
>
getKind
(
)
&
post
)
;
if
(
!
emitAtomOp
(
pn
-
>
pn_kid
global
?
JSOP_BINDGNAME
:
JSOP_BINDNAME
)
)
return
false
;
if
(
!
emitAtomOp
(
pn
-
>
pn_kid
global
?
JSOP_GETGNAME
:
JSOP_GETNAME
)
)
return
false
;
if
(
!
emit1
(
JSOP_POS
)
)
return
false
;
if
(
post
&
&
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emit1
(
JSOP_ONE
)
)
return
false
;
if
(
!
emit1
(
binop
)
)
return
false
;
if
(
post
)
{
if
(
!
emit2
(
JSOP_PICK
2
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
}
JSOp
setOp
=
strictifySetNameOp
(
global
?
JSOP_SETGNAME
:
JSOP_SETNAME
)
;
if
(
!
emitAtomOp
(
pn
-
>
pn_kid
setOp
)
)
return
false
;
if
(
post
&
&
!
emit1
(
JSOP_POP
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitElemOperands
(
ParseNode
*
pn
EmitElemOption
opts
)
{
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_BINARY
)
)
;
if
(
!
emitTree
(
pn
-
>
pn_left
)
)
return
false
;
if
(
opts
=
=
EmitElemOption
:
:
IncDec
)
{
if
(
!
emit1
(
JSOP_CHECKOBJCOERCIBLE
)
)
return
false
;
}
else
if
(
opts
=
=
EmitElemOption
:
:
Call
)
{
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
}
if
(
!
emitTree
(
pn
-
>
pn_right
)
)
return
false
;
if
(
opts
=
=
EmitElemOption
:
:
Set
)
{
if
(
!
emit2
(
JSOP_PICK
2
)
)
return
false
;
}
else
if
(
opts
=
=
EmitElemOption
:
:
IncDec
|
|
opts
=
=
EmitElemOption
:
:
CompoundAssign
)
{
if
(
!
emit1
(
JSOP_TOID
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitSuperElemOperands
(
ParseNode
*
pn
EmitElemOption
opts
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_ELEM
)
&
&
pn
-
>
as
<
PropertyByValue
>
(
)
.
isSuper
(
)
)
;
if
(
!
emitTree
(
pn
-
>
pn_right
)
)
return
false
;
if
(
opts
=
=
EmitElemOption
:
:
IncDec
|
|
opts
=
=
EmitElemOption
:
:
CompoundAssign
)
{
if
(
!
emit1
(
JSOP_TOID
)
)
return
false
;
}
if
(
!
emitGetThisForSuperBase
(
pn
-
>
pn_left
)
)
return
false
;
if
(
opts
=
=
EmitElemOption
:
:
Call
)
{
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
if
(
!
emitDupAt
(
1
)
)
return
false
;
}
if
(
!
emit1
(
JSOP_SUPERBASE
)
)
return
false
;
if
(
opts
=
=
EmitElemOption
:
:
Set
&
&
!
emit2
(
JSOP_PICK
3
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitElemOpBase
(
JSOp
op
)
{
if
(
!
emit1
(
op
)
)
return
false
;
checkTypeSet
(
op
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitElemOp
(
ParseNode
*
pn
JSOp
op
)
{
EmitElemOption
opts
=
EmitElemOption
:
:
Get
;
if
(
op
=
=
JSOP_CALLELEM
)
opts
=
EmitElemOption
:
:
Call
;
else
if
(
op
=
=
JSOP_SETELEM
|
|
op
=
=
JSOP_STRICTSETELEM
)
opts
=
EmitElemOption
:
:
Set
;
return
emitElemOperands
(
pn
opts
)
&
&
emitElemOpBase
(
op
)
;
}
bool
BytecodeEmitter
:
:
emitSuperElemOp
(
ParseNode
*
pn
JSOp
op
bool
isCall
)
{
EmitElemOption
opts
=
EmitElemOption
:
:
Get
;
if
(
isCall
)
opts
=
EmitElemOption
:
:
Call
;
else
if
(
op
=
=
JSOP_SETELEM_SUPER
|
|
op
=
=
JSOP_STRICTSETELEM_SUPER
)
opts
=
EmitElemOption
:
:
Set
;
if
(
!
emitSuperElemOperands
(
pn
opts
)
)
return
false
;
if
(
!
emitElemOpBase
(
op
)
)
return
false
;
if
(
isCall
&
&
!
emit1
(
JSOP_SWAP
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitElemIncDec
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
pn_kid
-
>
isKind
(
PNK_ELEM
)
)
;
bool
isSuper
=
pn
-
>
pn_kid
-
>
as
<
PropertyByValue
>
(
)
.
isSuper
(
)
;
if
(
isSuper
)
{
if
(
!
emitSuperElemOperands
(
pn
-
>
pn_kid
EmitElemOption
:
:
IncDec
)
)
return
false
;
}
else
{
if
(
!
emitElemOperands
(
pn
-
>
pn_kid
EmitElemOption
:
:
IncDec
)
)
return
false
;
}
bool
post
;
JSOp
binop
=
GetIncDecInfo
(
pn
-
>
getKind
(
)
&
post
)
;
JSOp
getOp
;
if
(
isSuper
)
{
if
(
!
emitDupAt
(
2
)
)
return
false
;
if
(
!
emitDupAt
(
2
)
)
return
false
;
if
(
!
emitDupAt
(
2
)
)
return
false
;
getOp
=
JSOP_GETELEM_SUPER
;
}
else
{
if
(
!
emit1
(
JSOP_DUP2
)
)
return
false
;
getOp
=
JSOP_GETELEM
;
}
if
(
!
emitElemOpBase
(
getOp
)
)
return
false
;
if
(
!
emit1
(
JSOP_POS
)
)
return
false
;
if
(
post
&
&
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emit1
(
JSOP_ONE
)
)
return
false
;
if
(
!
emit1
(
binop
)
)
return
false
;
if
(
post
)
{
if
(
isSuper
)
{
if
(
!
emit2
(
JSOP_PICK
4
)
)
return
false
;
}
if
(
!
emit2
(
JSOP_PICK
3
+
isSuper
)
)
return
false
;
if
(
!
emit2
(
JSOP_PICK
3
+
isSuper
)
)
return
false
;
if
(
!
emit2
(
JSOP_PICK
2
+
isSuper
)
)
return
false
;
}
JSOp
setOp
=
isSuper
?
(
sc
-
>
strict
(
)
?
JSOP_STRICTSETELEM_SUPER
:
JSOP_SETELEM_SUPER
)
:
(
sc
-
>
strict
(
)
?
JSOP_STRICTSETELEM
:
JSOP_SETELEM
)
;
if
(
!
emitElemOpBase
(
setOp
)
)
return
false
;
if
(
post
&
&
!
emit1
(
JSOP_POP
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitNumberOp
(
double
dval
)
{
int32_t
ival
;
if
(
NumberIsInt32
(
dval
&
ival
)
)
{
if
(
ival
=
=
0
)
return
emit1
(
JSOP_ZERO
)
;
if
(
ival
=
=
1
)
return
emit1
(
JSOP_ONE
)
;
if
(
(
int
)
(
int8_t
)
ival
=
=
ival
)
return
emit2
(
JSOP_INT8
uint8_t
(
int8_t
(
ival
)
)
)
;
uint32_t
u
=
uint32_t
(
ival
)
;
if
(
u
<
JS_BIT
(
16
)
)
{
if
(
!
emitUint16Operand
(
JSOP_UINT16
u
)
)
return
false
;
}
else
if
(
u
<
JS_BIT
(
24
)
)
{
ptrdiff_t
off
;
if
(
!
emitN
(
JSOP_UINT24
3
&
off
)
)
return
false
;
SET_UINT24
(
code
(
off
)
u
)
;
}
else
{
ptrdiff_t
off
;
if
(
!
emitN
(
JSOP_INT32
4
&
off
)
)
return
false
;
SET_INT32
(
code
(
off
)
ival
)
;
}
return
true
;
}
if
(
!
constList
.
append
(
DoubleValue
(
dval
)
)
)
return
false
;
return
emitIndex32
(
JSOP_DOUBLE
constList
.
length
(
)
-
1
)
;
}
bool
BytecodeEmitter
:
:
pushInitialConstants
(
JSOp
op
unsigned
n
)
{
MOZ_ASSERT
(
op
=
=
JSOP_UNDEFINED
|
|
op
=
=
JSOP_UNINITIALIZED
)
;
for
(
unsigned
i
=
0
;
i
<
n
;
+
+
i
)
{
if
(
!
emit1
(
op
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
initializeBlockScopedLocalsFromStack
(
Handle
<
StaticBlockScope
*
>
blockScope
)
{
for
(
unsigned
i
=
blockScope
-
>
numVariables
(
)
;
i
>
0
;
-
-
i
)
{
if
(
blockScope
-
>
isAliased
(
i
-
1
)
)
{
ScopeCoordinate
sc
;
sc
.
setHops
(
0
)
;
sc
.
setSlot
(
ClonedBlockObject
:
:
RESERVED_SLOTS
+
i
-
1
)
;
if
(
!
emitAliasedVarOp
(
JSOP_INITALIASEDLEXICAL
sc
DontCheckLexical
)
)
return
false
;
}
else
{
uint32_t
numAliased
=
script
-
>
bindings
.
numAliasedBodyLevelLocals
(
)
;
unsigned
local
=
blockScope
-
>
blockIndexToLocalIndex
(
i
-
1
)
+
numAliased
;
if
(
!
emitUnaliasedVarOp
(
JSOP_INITLEXICAL
local
DontCheckLexical
)
)
return
false
;
}
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
enterBlockScope
(
StmtInfoBCE
*
stmtInfo
ObjectBox
*
objbox
JSOp
initialValueOp
unsigned
alreadyPushed
)
{
bool
isEvalBodyLexicalScope
=
sc
-
>
staticScope
(
)
-
>
is
<
StaticEvalScope
>
(
)
&
&
!
innermostStmt
(
)
;
if
(
isEvalBodyLexicalScope
)
{
MOZ_ASSERT
(
code
(
)
.
length
(
)
=
=
0
)
;
switchToPrologue
(
)
;
}
if
(
!
enterNestedScope
(
stmtInfo
objbox
StmtType
:
:
BLOCK
)
)
return
false
;
Rooted
<
StaticBlockScope
*
>
blockScope
(
cx
&
objbox
-
>
object
-
>
as
<
StaticBlockScope
>
(
)
)
;
if
(
!
pushInitialConstants
(
initialValueOp
blockScope
-
>
numVariables
(
)
-
alreadyPushed
)
)
return
false
;
if
(
!
initializeBlockScopedLocalsFromStack
(
blockScope
)
)
return
false
;
if
(
isEvalBodyLexicalScope
)
switchToMain
(
)
;
return
true
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitSwitch
(
ParseNode
*
pn
)
{
ParseNode
*
cases
=
pn
-
>
pn_right
;
MOZ_ASSERT
(
cases
-
>
isKind
(
PNK_LEXICALSCOPE
)
|
|
cases
-
>
isKind
(
PNK_STATEMENTLIST
)
)
;
if
(
!
emitTree
(
pn
-
>
pn_left
)
)
return
false
;
StmtInfoBCE
stmtInfo
(
cx
)
;
JumpTarget
top
;
if
(
cases
-
>
isKind
(
PNK_LEXICALSCOPE
)
)
{
if
(
!
enterBlockScope
(
&
stmtInfo
cases
-
>
pn_objbox
JSOP_UNINITIALIZED
0
)
)
return
false
;
cases
=
cases
-
>
expr
(
)
;
if
(
cases
-
>
pn_xflags
&
PNX_FUNCDEFS
)
{
for
(
ParseNode
*
caseNode
=
cases
-
>
pn_head
;
caseNode
;
caseNode
=
caseNode
-
>
pn_next
)
{
if
(
caseNode
-
>
pn_right
-
>
pn_xflags
&
PNX_FUNCDEFS
)
{
if
(
!
emitHoistedFunctionsInList
(
caseNode
-
>
pn_right
)
)
return
false
;
}
}
}
stmtInfo
.
type
=
StmtType
:
:
SWITCH
;
stmtInfo
.
update
=
top
=
{
offset
(
)
}
;
}
else
{
MOZ_ASSERT
(
cases
-
>
isKind
(
PNK_STATEMENTLIST
)
)
;
top
=
{
offset
(
)
}
;
pushStatement
(
&
stmtInfo
StmtType
:
:
SWITCH
top
)
;
}
uint32_t
caseCount
=
cases
-
>
pn_count
;
if
(
caseCount
>
JS_BIT
(
16
)
)
{
parser
-
>
tokenStream
.
reportError
(
JSMSG_TOO_MANY_CASES
)
;
return
false
;
}
JSOp
switchOp
=
JSOP_TABLESWITCH
;
uint32_t
tableLength
=
0
;
int32_t
low
high
;
bool
hasDefault
=
false
;
CaseClause
*
firstCase
=
cases
-
>
pn_head
?
&
cases
-
>
pn_head
-
>
as
<
CaseClause
>
(
)
:
nullptr
;
if
(
caseCount
=
=
0
|
|
(
caseCount
=
=
1
&
&
(
hasDefault
=
firstCase
-
>
isDefault
(
)
)
)
)
{
caseCount
=
0
;
low
=
0
;
high
=
-
1
;
}
else
{
Vector
<
jsbitmap
128
SystemAllocPolicy
>
intmap
;
int32_t
intmapBitLength
=
0
;
low
=
JSVAL_INT_MAX
;
high
=
JSVAL_INT_MIN
;
for
(
CaseClause
*
caseNode
=
firstCase
;
caseNode
;
caseNode
=
caseNode
-
>
next
(
)
)
{
if
(
caseNode
-
>
isDefault
(
)
)
{
hasDefault
=
true
;
caseCount
-
-
;
continue
;
}
if
(
switchOp
=
=
JSOP_CONDSWITCH
)
continue
;
MOZ_ASSERT
(
switchOp
=
=
JSOP_TABLESWITCH
)
;
ParseNode
*
caseValue
=
caseNode
-
>
caseExpression
(
)
;
if
(
caseValue
-
>
getKind
(
)
!
=
PNK_NUMBER
)
{
switchOp
=
JSOP_CONDSWITCH
;
continue
;
}
int32_t
i
;
if
(
!
NumberIsInt32
(
caseValue
-
>
pn_dval
&
i
)
)
{
switchOp
=
JSOP_CONDSWITCH
;
continue
;
}
if
(
unsigned
(
i
+
int
(
JS_BIT
(
15
)
)
)
>
=
unsigned
(
JS_BIT
(
16
)
)
)
{
switchOp
=
JSOP_CONDSWITCH
;
continue
;
}
if
(
i
<
low
)
low
=
i
;
if
(
i
>
high
)
high
=
i
;
if
(
i
<
0
)
i
+
=
JS_BIT
(
16
)
;
if
(
i
>
=
intmapBitLength
)
{
size_t
newLength
=
(
i
/
JS_BITMAP_NBITS
)
+
1
;
if
(
!
intmap
.
resize
(
newLength
)
)
return
false
;
intmapBitLength
=
newLength
*
JS_BITMAP_NBITS
;
}
if
(
JS_TEST_BIT
(
intmap
i
)
)
{
switchOp
=
JSOP_CONDSWITCH
;
continue
;
}
JS_SET_BIT
(
intmap
i
)
;
}
if
(
switchOp
=
=
JSOP_TABLESWITCH
)
{
tableLength
=
uint32_t
(
high
-
low
+
1
)
;
if
(
tableLength
>
=
JS_BIT
(
16
)
|
|
tableLength
>
2
*
caseCount
)
switchOp
=
JSOP_CONDSWITCH
;
}
}
unsigned
noteIndex
;
size_t
switchSize
;
if
(
switchOp
=
=
JSOP_CONDSWITCH
)
{
switchSize
=
0
;
if
(
!
newSrcNote3
(
SRC_CONDSWITCH
0
0
&
noteIndex
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
switchOp
=
=
JSOP_TABLESWITCH
)
;
switchSize
=
size_t
(
JUMP_OFFSET_LEN
*
(
3
+
tableLength
)
)
;
if
(
!
newSrcNote2
(
SRC_TABLESWITCH
0
&
noteIndex
)
)
return
false
;
}
MOZ_ASSERT
(
top
.
offset
=
=
offset
(
)
)
;
if
(
!
emitN
(
switchOp
switchSize
)
)
return
false
;
Vector
<
CaseClause
*
32
SystemAllocPolicy
>
table
;
JumpList
condSwitchDefaultOff
;
if
(
switchOp
=
=
JSOP_CONDSWITCH
)
{
unsigned
caseNoteIndex
;
bool
beforeCases
=
true
;
ptrdiff_t
lastCaseOffset
=
-
1
;
for
(
CaseClause
*
caseNode
=
firstCase
;
caseNode
;
caseNode
=
caseNode
-
>
next
(
)
)
{
ParseNode
*
caseValue
=
caseNode
-
>
caseExpression
(
)
;
if
(
caseValue
)
{
if
(
!
emitTree
(
caseValue
caseValue
-
>
isLiteral
(
)
?
SUPPRESS_LINENOTE
:
EMIT_LINENOTE
)
)
{
return
false
;
}
}
if
(
!
beforeCases
)
{
if
(
!
setSrcNoteOffset
(
caseNoteIndex
0
offset
(
)
-
lastCaseOffset
)
)
return
false
;
}
if
(
!
caseValue
)
{
continue
;
}
if
(
!
newSrcNote2
(
SRC_NEXTCASE
0
&
caseNoteIndex
)
)
return
false
;
JumpList
caseJump
;
if
(
!
emitJump
(
JSOP_CASE
&
caseJump
)
)
return
false
;
caseNode
-
>
setOffset
(
caseJump
.
offset
)
;
lastCaseOffset
=
caseJump
.
offset
;
if
(
beforeCases
)
{
unsigned
noteCount
=
notes
(
)
.
length
(
)
;
if
(
!
setSrcNoteOffset
(
noteIndex
1
lastCaseOffset
-
top
.
offset
)
)
return
false
;
unsigned
noteCountDelta
=
notes
(
)
.
length
(
)
-
noteCount
;
if
(
noteCountDelta
!
=
0
)
caseNoteIndex
+
=
noteCountDelta
;
beforeCases
=
false
;
}
}
if
(
!
hasDefault
&
&
!
beforeCases
&
&
!
setSrcNoteOffset
(
caseNoteIndex
0
offset
(
)
-
lastCaseOffset
)
)
{
return
false
;
}
if
(
!
emitJump
(
JSOP_DEFAULT
&
condSwitchDefaultOff
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
switchOp
=
=
JSOP_TABLESWITCH
)
;
jsbytecode
*
pc
=
code
(
top
.
offset
+
JUMP_OFFSET_LEN
)
;
SET_JUMP_OFFSET
(
pc
low
)
;
pc
+
=
JUMP_OFFSET_LEN
;
SET_JUMP_OFFSET
(
pc
high
)
;
pc
+
=
JUMP_OFFSET_LEN
;
if
(
tableLength
!
=
0
)
{
if
(
!
table
.
growBy
(
tableLength
)
)
return
false
;
for
(
CaseClause
*
caseNode
=
firstCase
;
caseNode
;
caseNode
=
caseNode
-
>
next
(
)
)
{
if
(
ParseNode
*
caseValue
=
caseNode
-
>
caseExpression
(
)
)
{
MOZ_ASSERT
(
caseValue
-
>
isKind
(
PNK_NUMBER
)
)
;
int32_t
i
=
int32_t
(
caseValue
-
>
pn_dval
)
;
MOZ_ASSERT
(
double
(
i
)
=
=
caseValue
-
>
pn_dval
)
;
i
-
=
low
;
MOZ_ASSERT
(
uint32_t
(
i
)
<
tableLength
)
;
MOZ_ASSERT
(
!
table
[
i
]
)
;
table
[
i
]
=
caseNode
;
}
}
}
}
JumpTarget
defaultOffset
{
-
1
}
;
for
(
CaseClause
*
caseNode
=
firstCase
;
caseNode
;
caseNode
=
caseNode
-
>
next
(
)
)
{
if
(
switchOp
=
=
JSOP_CONDSWITCH
&
&
!
caseNode
-
>
isDefault
(
)
)
{
JumpList
caseCond
;
caseCond
.
offset
=
caseNode
-
>
offset
(
)
;
if
(
!
emitJumpTargetAndPatch
(
caseCond
)
)
return
false
;
}
JumpTarget
here
;
if
(
!
emitJumpTarget
(
&
here
)
)
return
false
;
if
(
caseNode
-
>
isDefault
(
)
)
defaultOffset
=
here
;
caseNode
-
>
setOffset
(
here
.
offset
)
;
if
(
!
emitTree
(
caseNode
-
>
statementList
(
)
)
)
return
false
;
}
if
(
!
hasDefault
)
{
if
(
!
emitJumpTarget
(
&
defaultOffset
)
)
return
false
;
}
MOZ_ASSERT
(
defaultOffset
.
offset
!
=
-
1
)
;
jsbytecode
*
pc
;
if
(
switchOp
=
=
JSOP_CONDSWITCH
)
{
pc
=
nullptr
;
patchJumpsToTarget
(
condSwitchDefaultOff
defaultOffset
)
;
}
else
{
MOZ_ASSERT
(
switchOp
=
=
JSOP_TABLESWITCH
)
;
pc
=
code
(
top
.
offset
)
;
SET_JUMP_OFFSET
(
pc
defaultOffset
.
offset
-
top
.
offset
)
;
pc
+
=
JUMP_OFFSET_LEN
;
}
if
(
!
setSrcNoteOffset
(
noteIndex
0
lastNonJumpTargetOffset
(
)
-
top
.
offset
)
)
return
false
;
if
(
switchOp
=
=
JSOP_TABLESWITCH
)
{
pc
+
=
2
*
JUMP_OFFSET_LEN
;
for
(
uint32_t
i
=
0
;
i
<
tableLength
;
i
+
+
)
{
CaseClause
*
caseNode
=
table
[
i
]
;
ptrdiff_t
off
=
caseNode
?
caseNode
-
>
offset
(
)
-
top
.
offset
:
0
;
SET_JUMP_OFFSET
(
pc
off
)
;
pc
+
=
JUMP_OFFSET_LEN
;
}
}
if
(
pn
-
>
pn_right
-
>
isKind
(
PNK_LEXICALSCOPE
)
)
{
if
(
!
leaveNestedScope
(
&
stmtInfo
)
)
return
false
;
}
else
{
if
(
!
popStatement
(
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
isRunOnceLambda
(
)
{
if
(
!
(
parent
&
&
parent
-
>
emittingRunOnceLambda
)
&
&
(
emitterMode
!
=
LazyFunction
|
|
!
lazyScript
-
>
treatAsRunOnce
(
)
)
)
{
return
false
;
}
FunctionBox
*
funbox
=
sc
-
>
asFunctionBox
(
)
;
return
!
funbox
-
>
argumentsHasLocalBinding
(
)
&
&
!
funbox
-
>
isGenerator
(
)
&
&
!
funbox
-
>
function
(
)
-
>
name
(
)
;
}
bool
BytecodeEmitter
:
:
emitYieldOp
(
JSOp
op
)
{
if
(
op
=
=
JSOP_FINALYIELDRVAL
)
return
emit1
(
JSOP_FINALYIELDRVAL
)
;
MOZ_ASSERT
(
op
=
=
JSOP_INITIALYIELD
|
|
op
=
=
JSOP_YIELD
)
;
ptrdiff_t
off
;
if
(
!
emitN
(
op
3
&
off
)
)
return
false
;
uint32_t
yieldIndex
=
yieldOffsetList
.
length
(
)
;
if
(
yieldIndex
>
=
JS_BIT
(
24
)
)
{
reportError
(
nullptr
JSMSG_TOO_MANY_YIELDS
)
;
return
false
;
}
SET_UINT24
(
code
(
off
)
yieldIndex
)
;
if
(
!
yieldOffsetList
.
append
(
offset
(
)
)
)
return
false
;
return
emit1
(
JSOP_DEBUGAFTERYIELD
)
;
}
bool
BytecodeEmitter
:
:
emitCreateFunctionThis
(
)
{
if
(
!
sc
-
>
asFunctionBox
(
)
-
>
hasThisBinding
(
)
)
return
true
;
switchToPrologue
(
)
;
if
(
!
emit1
(
JSOP_FUNCTIONTHIS
)
)
return
false
;
BindingIter
bi
=
Bindings
:
:
thisBinding
(
cx
script
)
;
if
(
!
emitStoreToEnclosingFunctionScope
(
bi
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
switchToMain
(
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitSetThis
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_SETTHIS
)
)
;
ParseNode
*
name
=
pn
-
>
pn_left
;
MOZ_ASSERT
(
name
-
>
isKind
(
PNK_NAME
)
)
;
if
(
!
emitTree
(
pn
-
>
pn_right
)
)
return
false
;
if
(
!
bindNameToSlot
(
name
)
)
return
false
;
JSOp
setOp
=
name
-
>
getOp
(
)
;
if
(
setOp
=
=
JSOP_STRICTSETNAME
)
{
if
(
!
emitAtomOp
(
name
JSOP_GETNAME
)
)
return
false
;
if
(
!
emit1
(
JSOP_CHECKTHISREINIT
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
if
(
!
emitAtomOp
(
name
JSOP_BINDNAME
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
return
emitAtomOp
(
name
setOp
)
;
}
JSOp
getOp
;
switch
(
setOp
)
{
case
JSOP_SETLOCAL
:
getOp
=
JSOP_GETLOCAL
;
setOp
=
JSOP_INITLEXICAL
;
break
;
case
JSOP_SETALIASEDVAR
:
getOp
=
JSOP_GETALIASEDVAR
;
setOp
=
JSOP_INITALIASEDLEXICAL
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
op
"
)
;
}
if
(
!
emitVarOp
(
name
getOp
)
)
return
false
;
if
(
!
emit1
(
JSOP_CHECKTHISREINIT
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
return
emitVarOp
(
name
setOp
)
;
}
static
bool
IsModuleOnScopeChain
(
JSObject
*
obj
)
{
for
(
StaticScopeIter
<
NoGC
>
ssi
(
obj
)
;
!
ssi
.
done
(
)
;
ssi
+
+
)
{
if
(
ssi
.
type
(
)
=
=
StaticScopeIter
<
NoGC
>
:
:
Module
)
return
true
;
}
return
false
;
}
bool
BytecodeEmitter
:
:
emitFunctionScript
(
ParseNode
*
body
)
{
if
(
!
updateLocalsToFrameSlots
(
)
)
return
false
;
FunctionBox
*
funbox
=
sc
-
>
asFunctionBox
(
)
;
JSScript
:
:
linkToFunctionFromEmitter
(
cx
script
funbox
)
;
insideModule
=
IsModuleOnScopeChain
(
sc
-
>
staticScope
(
)
)
;
if
(
funbox
-
>
argumentsHasLocalBinding
(
)
)
{
MOZ_ASSERT
(
offset
(
)
=
=
0
)
;
switchToPrologue
(
)
;
if
(
!
emit1
(
JSOP_ARGUMENTS
)
)
return
false
;
BindingIter
bi
=
Bindings
:
:
argumentsBinding
(
cx
script
)
;
if
(
!
emitStoreToEnclosingFunctionScope
(
bi
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
switchToMain
(
)
;
}
if
(
!
emitCreateFunctionThis
(
)
)
return
false
;
bool
runOnce
=
isRunOnceLambda
(
)
;
if
(
runOnce
)
{
switchToPrologue
(
)
;
if
(
!
emit1
(
JSOP_RUNONCE
)
)
return
false
;
switchToMain
(
)
;
}
setFunctionBodyEndPos
(
body
-
>
pn_pos
)
;
if
(
!
emitTree
(
body
)
)
return
false
;
if
(
!
updateSourceCoordNotes
(
body
-
>
pn_pos
.
end
)
)
return
false
;
if
(
sc
-
>
isFunctionBox
(
)
)
{
if
(
sc
-
>
asFunctionBox
(
)
-
>
isGenerator
(
)
)
{
if
(
sc
-
>
asFunctionBox
(
)
-
>
isStarGenerator
(
)
&
&
!
emitPrepareIteratorResult
(
)
)
return
false
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
if
(
sc
-
>
asFunctionBox
(
)
-
>
isStarGenerator
(
)
&
&
!
emitFinishIteratorResult
(
true
)
)
return
false
;
if
(
!
emit1
(
JSOP_SETRVAL
)
)
return
false
;
ScopeCoordinate
sc
;
sc
.
setHops
(
0
)
;
MOZ_ALWAYS_TRUE
(
lookupAliasedNameSlot
(
cx
-
>
names
(
)
.
dotGenerator
&
sc
)
)
;
if
(
!
emitAliasedVarOp
(
JSOP_GETALIASEDVAR
sc
DontCheckLexical
)
)
return
false
;
if
(
!
emitYieldOp
(
JSOP_FINALYIELDRVAL
)
)
return
false
;
}
else
{
if
(
hasTryFinally
)
{
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
if
(
!
emit1
(
JSOP_SETRVAL
)
)
return
false
;
}
}
}
if
(
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
isDerivedClassConstructor
(
)
)
{
BindingIter
bi
=
Bindings
:
:
thisBinding
(
cx
script
)
;
if
(
!
emitLoadFromEnclosingFunctionScope
(
bi
)
)
return
false
;
if
(
!
emit1
(
JSOP_CHECKRETURN
)
)
return
false
;
}
if
(
!
emit1
(
JSOP_RETRVAL
)
)
return
false
;
if
(
sc
-
>
allLocalsAliased
(
)
)
script
-
>
bindings
.
setAllLocalsAliased
(
)
;
if
(
!
JSScript
:
:
fullyInitFromEmitter
(
cx
script
this
)
)
return
false
;
if
(
runOnce
)
{
script
-
>
setTreatAsRunOnce
(
)
;
MOZ_ASSERT
(
!
script
-
>
hasRunOnce
(
)
)
;
}
tellDebuggerAboutCompiledScript
(
cx
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitModuleScript
(
ParseNode
*
body
)
{
insideModule
=
true
;
if
(
!
updateLocalsToFrameSlots
(
)
)
return
false
;
ModuleBox
*
modulebox
=
sc
-
>
asModuleBox
(
)
;
MOZ_ASSERT
(
modulebox
)
;
JSScript
:
:
linkToModuleFromEmitter
(
cx
script
modulebox
)
;
setFunctionBodyEndPos
(
body
-
>
pn_pos
)
;
if
(
!
emitTree
(
body
)
)
return
false
;
if
(
!
emit1
(
JSOP_RETRVAL
)
)
return
false
;
if
(
sc
-
>
allLocalsAliased
(
)
)
script
-
>
bindings
.
setAllLocalsAliased
(
)
;
if
(
!
JSScript
:
:
fullyInitFromEmitter
(
cx
script
this
)
)
return
false
;
script
-
>
setTreatAsRunOnce
(
)
;
MOZ_ASSERT
(
!
script
-
>
hasRunOnce
(
)
)
;
tellDebuggerAboutCompiledScript
(
cx
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
maybeEmitVarDecl
(
JSOp
prologueOp
ParseNode
*
pn
jsatomid
*
result
)
{
jsatomid
atomIndex
;
if
(
!
pn
-
>
pn_scopecoord
.
isFree
(
)
)
{
atomIndex
=
pn
-
>
pn_scopecoord
.
slot
(
)
;
}
else
{
if
(
!
makeAtomIndex
(
pn
-
>
pn_atom
&
atomIndex
)
)
return
false
;
}
if
(
JOF_OPTYPE
(
pn
-
>
getOp
(
)
)
=
=
JOF_ATOM
&
&
(
!
sc
-
>
isFunctionBox
(
)
|
|
sc
-
>
asFunctionBox
(
)
-
>
needsCallObject
(
)
)
)
{
switchToPrologue
(
)
;
if
(
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
begin
)
)
return
false
;
if
(
!
emitIndexOp
(
prologueOp
atomIndex
)
)
return
false
;
switchToMain
(
)
;
}
if
(
result
)
*
result
=
atomIndex
;
return
true
;
}
template
<
BytecodeEmitter
:
:
DestructuringDeclEmitter
EmitName
>
bool
BytecodeEmitter
:
:
emitDestructuringDeclsWithEmitter
(
JSOp
prologueOp
ParseNode
*
pattern
)
{
if
(
pattern
-
>
isKind
(
PNK_ARRAY
)
)
{
for
(
ParseNode
*
element
=
pattern
-
>
pn_head
;
element
;
element
=
element
-
>
pn_next
)
{
if
(
element
-
>
isKind
(
PNK_ELISION
)
)
continue
;
ParseNode
*
target
=
element
;
if
(
element
-
>
isKind
(
PNK_SPREAD
)
)
{
target
=
element
-
>
pn_kid
;
}
if
(
target
-
>
isKind
(
PNK_ASSIGN
)
)
target
=
target
-
>
pn_left
;
if
(
target
-
>
isKind
(
PNK_NAME
)
)
{
if
(
!
EmitName
(
this
prologueOp
target
)
)
return
false
;
}
else
{
if
(
!
emitDestructuringDeclsWithEmitter
<
EmitName
>
(
prologueOp
target
)
)
return
false
;
}
}
return
true
;
}
MOZ_ASSERT
(
pattern
-
>
isKind
(
PNK_OBJECT
)
)
;
for
(
ParseNode
*
member
=
pattern
-
>
pn_head
;
member
;
member
=
member
-
>
pn_next
)
{
MOZ_ASSERT
(
member
-
>
isKind
(
PNK_MUTATEPROTO
)
|
|
member
-
>
isKind
(
PNK_COLON
)
|
|
member
-
>
isKind
(
PNK_SHORTHAND
)
)
;
ParseNode
*
target
=
member
-
>
isKind
(
PNK_MUTATEPROTO
)
?
member
-
>
pn_kid
:
member
-
>
pn_right
;
if
(
target
-
>
isKind
(
PNK_ASSIGN
)
)
target
=
target
-
>
pn_left
;
if
(
target
-
>
isKind
(
PNK_NAME
)
)
{
if
(
!
EmitName
(
this
prologueOp
target
)
)
return
false
;
}
else
{
if
(
!
emitDestructuringDeclsWithEmitter
<
EmitName
>
(
prologueOp
target
)
)
return
false
;
}
}
return
true
;
}
static
bool
EmitDestructuringDecl
(
BytecodeEmitter
*
bce
JSOp
prologueOp
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_NAME
)
)
;
if
(
!
bce
-
>
bindNameToSlot
(
pn
)
)
return
false
;
MOZ_ASSERT
(
!
pn
-
>
isOp
(
JSOP_CALLEE
)
)
;
return
bce
-
>
maybeEmitVarDecl
(
prologueOp
pn
nullptr
)
;
}
bool
BytecodeEmitter
:
:
emitDestructuringDecls
(
JSOp
prologueOp
ParseNode
*
pattern
)
{
return
emitDestructuringDeclsWithEmitter
<
EmitDestructuringDecl
>
(
prologueOp
pattern
)
;
}
static
bool
EmitInitializeDestructuringDecl
(
BytecodeEmitter
*
bce
JSOp
prologueOp
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_NAME
)
)
;
MOZ_ASSERT
(
pn
-
>
isBound
(
)
)
;
return
bce
-
>
emitVarOp
(
pn
pn
-
>
getOp
(
)
)
;
}
bool
BytecodeEmitter
:
:
emitInitializeDestructuringDecls
(
JSOp
prologueOp
ParseNode
*
pattern
)
{
return
emitDestructuringDeclsWithEmitter
<
EmitInitializeDestructuringDecl
>
(
prologueOp
pattern
)
;
}
bool
BytecodeEmitter
:
:
emitDestructuringLHS
(
ParseNode
*
target
VarEmitOption
emitOption
)
{
MOZ_ASSERT
(
emitOption
!
=
DefineVars
)
;
if
(
target
-
>
isKind
(
PNK_SPREAD
)
)
target
=
target
-
>
pn_kid
;
else
if
(
target
-
>
isKind
(
PNK_ASSIGN
)
)
target
=
target
-
>
pn_left
;
if
(
target
-
>
isKind
(
PNK_ARRAY
)
|
|
target
-
>
isKind
(
PNK_OBJECT
)
)
{
if
(
!
emitDestructuringOpsHelper
(
target
emitOption
)
)
return
false
;
if
(
emitOption
=
=
InitializeVars
)
{
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
}
else
if
(
emitOption
=
=
PushInitialValues
)
{
MOZ_ASSERT
(
target
-
>
getOp
(
)
=
=
JSOP_SETLOCAL
|
|
target
-
>
getOp
(
)
=
=
JSOP_INITLEXICAL
)
;
MOZ_ASSERT
(
target
-
>
pn_dflags
&
PND_BOUND
)
;
}
else
{
switch
(
target
-
>
getKind
(
)
)
{
case
PNK_NAME
:
if
(
!
bindNameToSlot
(
target
)
)
return
false
;
switch
(
target
-
>
getOp
(
)
)
{
case
JSOP_SETNAME
:
case
JSOP_STRICTSETNAME
:
case
JSOP_SETGNAME
:
case
JSOP_STRICTSETGNAME
:
case
JSOP_INITGLEXICAL
:
{
jsatomid
atomIndex
;
if
(
!
makeAtomIndex
(
target
-
>
pn_atom
&
atomIndex
)
)
return
false
;
if
(
!
target
-
>
isOp
(
JSOP_INITGLEXICAL
)
)
{
bool
global
=
target
-
>
isOp
(
JSOP_SETGNAME
)
|
|
target
-
>
isOp
(
JSOP_STRICTSETGNAME
)
;
JSOp
bindOp
=
global
?
JSOP_BINDGNAME
:
JSOP_BINDNAME
;
if
(
!
emitIndex32
(
bindOp
atomIndex
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
}
if
(
!
emitIndexOp
(
target
-
>
getOp
(
)
atomIndex
)
)
return
false
;
break
;
}
case
JSOP_SETLOCAL
:
case
JSOP_SETARG
:
case
JSOP_SETALIASEDVAR
:
case
JSOP_INITLEXICAL
:
case
JSOP_INITALIASEDLEXICAL
:
if
(
!
emitVarOp
(
target
target
-
>
getOp
(
)
)
)
return
false
;
break
;
default
:
MOZ_CRASH
(
"
emitDestructuringLHS
:
bad
name
op
"
)
;
}
break
;
case
PNK_DOT
:
{
JSOp
setOp
;
if
(
target
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
{
if
(
!
emitSuperPropLHS
(
&
target
-
>
as
<
PropertyAccess
>
(
)
.
expression
(
)
)
)
return
false
;
if
(
!
emit2
(
JSOP_PICK
2
)
)
return
false
;
setOp
=
sc
-
>
strict
(
)
?
JSOP_STRICTSETPROP_SUPER
:
JSOP_SETPROP_SUPER
;
}
else
{
if
(
!
emitTree
(
target
-
>
pn_expr
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
setOp
=
sc
-
>
strict
(
)
?
JSOP_STRICTSETPROP
:
JSOP_SETPROP
;
}
if
(
!
emitAtomOp
(
target
setOp
)
)
return
false
;
break
;
}
case
PNK_ELEM
:
{
if
(
target
-
>
as
<
PropertyByValue
>
(
)
.
isSuper
(
)
)
{
JSOp
setOp
=
sc
-
>
strict
(
)
?
JSOP_STRICTSETELEM_SUPER
:
JSOP_SETELEM_SUPER
;
if
(
!
emitSuperElemOp
(
target
setOp
)
)
return
false
;
}
else
{
JSOp
setOp
=
sc
-
>
strict
(
)
?
JSOP_STRICTSETELEM
:
JSOP_SETELEM
;
if
(
!
emitElemOp
(
target
setOp
)
)
return
false
;
}
break
;
}
case
PNK_CALL
:
MOZ_ASSERT
(
target
-
>
pn_xflags
&
PNX_SETCALL
)
;
if
(
!
emitTree
(
target
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
break
;
default
:
MOZ_CRASH
(
"
emitDestructuringLHS
:
bad
lhs
kind
"
)
;
}
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitIteratorNext
(
ParseNode
*
pn
bool
allowSelfHosted
)
{
MOZ_ASSERT
(
allowSelfHosted
|
|
emitterMode
!
=
BytecodeEmitter
:
:
SelfHosting
"
.
next
(
)
iteration
is
prohibited
in
self
-
hosted
code
because
it
"
"
can
run
user
-
modifiable
iteration
code
"
)
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
next
JSOP_CALLPROP
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
if
(
!
emitCall
(
JSOP_CALL
0
pn
)
)
return
false
;
checkTypeSet
(
JSOP_CALL
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitDefault
(
ParseNode
*
defaultExpr
)
{
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
if
(
!
emit1
(
JSOP_STRICTEQ
)
)
return
false
;
if
(
!
newSrcNote
(
SRC_IF
)
)
return
false
;
JumpList
jump
;
if
(
!
emitJump
(
JSOP_IFEQ
&
jump
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
if
(
!
emitTree
(
defaultExpr
)
)
return
false
;
if
(
!
emitJumpTargetAndPatch
(
jump
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitDestructuringOpsArrayHelper
(
ParseNode
*
pattern
VarEmitOption
emitOption
)
{
MOZ_ASSERT
(
pattern
-
>
isKind
(
PNK_ARRAY
)
)
;
MOZ_ASSERT
(
pattern
-
>
isArity
(
PN_LIST
)
)
;
MOZ_ASSERT
(
this
-
>
stackDepth
!
=
0
)
;
if
(
emitOption
=
=
InitializeVars
)
{
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
}
if
(
!
emitIterator
(
)
)
return
false
;
bool
needToPopIterator
=
true
;
for
(
ParseNode
*
member
=
pattern
-
>
pn_head
;
member
;
member
=
member
-
>
pn_next
)
{
ParseNode
*
pndefault
=
nullptr
;
ParseNode
*
elem
=
member
;
if
(
elem
-
>
isKind
(
PNK_ASSIGN
)
)
{
pndefault
=
elem
-
>
pn_right
;
elem
=
elem
-
>
pn_left
;
}
if
(
elem
-
>
isKind
(
PNK_SPREAD
)
)
{
if
(
!
emitUint32Operand
(
JSOP_NEWARRAY
0
)
)
return
false
;
if
(
!
emitNumberOp
(
0
)
)
return
false
;
if
(
!
emitSpread
(
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
needToPopIterator
=
false
;
}
else
{
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitIteratorNext
(
pattern
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
done
JSOP_GETPROP
)
)
return
false
;
unsigned
noteIndex
;
if
(
!
newSrcNote
(
SRC_COND
&
noteIndex
)
)
return
false
;
JumpList
beq
;
if
(
!
emitJump
(
JSOP_IFEQ
&
beq
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
if
(
!
emit1
(
JSOP_NOP_DESTRUCTURING
)
)
return
false
;
JumpList
jmp
;
if
(
!
emitJump
(
JSOP_GOTO
&
jmp
)
)
return
false
;
if
(
!
emitJumpTargetAndPatch
(
beq
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
value
JSOP_GETPROP
)
)
return
false
;
if
(
!
emitJumpTargetAndPatch
(
jmp
)
)
return
false
;
if
(
!
setSrcNoteOffset
(
noteIndex
0
jmp
.
offset
-
beq
.
offset
)
)
return
false
;
}
if
(
pndefault
&
&
!
emitDefault
(
pndefault
)
)
return
false
;
ParseNode
*
subpattern
=
elem
;
if
(
subpattern
-
>
isKind
(
PNK_ELISION
)
)
{
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
continue
;
}
int32_t
depthBefore
=
this
-
>
stackDepth
;
if
(
!
emitDestructuringLHS
(
subpattern
emitOption
)
)
return
false
;
if
(
emitOption
=
=
PushInitialValues
&
&
needToPopIterator
)
{
MOZ_ASSERT
(
(
this
-
>
stackDepth
-
this
-
>
stackDepth
)
>
=
-
1
)
;
uint32_t
pickDistance
=
uint32_t
(
(
this
-
>
stackDepth
+
1
)
-
depthBefore
)
;
if
(
pickDistance
>
0
)
{
if
(
pickDistance
>
UINT8_MAX
)
{
reportError
(
subpattern
JSMSG_TOO_MANY_LOCALS
)
;
return
false
;
}
if
(
!
emit2
(
JSOP_PICK
(
uint8_t
)
pickDistance
)
)
return
false
;
}
}
}
if
(
needToPopIterator
&
&
!
emit1
(
JSOP_POP
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitComputedPropertyName
(
ParseNode
*
computedPropName
)
{
MOZ_ASSERT
(
computedPropName
-
>
isKind
(
PNK_COMPUTED_NAME
)
)
;
return
emitTree
(
computedPropName
-
>
pn_kid
)
&
&
emit1
(
JSOP_TOID
)
;
}
bool
BytecodeEmitter
:
:
emitDestructuringOpsObjectHelper
(
ParseNode
*
pattern
VarEmitOption
emitOption
)
{
MOZ_ASSERT
(
pattern
-
>
isKind
(
PNK_OBJECT
)
)
;
MOZ_ASSERT
(
pattern
-
>
isArity
(
PN_LIST
)
)
;
MOZ_ASSERT
(
this
-
>
stackDepth
>
0
)
;
if
(
!
emitRequireObjectCoercible
(
)
)
return
false
;
for
(
ParseNode
*
member
=
pattern
-
>
pn_head
;
member
;
member
=
member
-
>
pn_next
)
{
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
bool
needsGetElem
=
true
;
ParseNode
*
subpattern
;
if
(
member
-
>
isKind
(
PNK_MUTATEPROTO
)
)
{
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
proto
JSOP_GETPROP
)
)
return
false
;
needsGetElem
=
false
;
subpattern
=
member
-
>
pn_kid
;
}
else
{
MOZ_ASSERT
(
member
-
>
isKind
(
PNK_COLON
)
|
|
member
-
>
isKind
(
PNK_SHORTHAND
)
)
;
ParseNode
*
key
=
member
-
>
pn_left
;
if
(
key
-
>
isKind
(
PNK_NUMBER
)
)
{
if
(
!
emitNumberOp
(
key
-
>
pn_dval
)
)
return
false
;
}
else
if
(
key
-
>
isKind
(
PNK_OBJECT_PROPERTY_NAME
)
|
|
key
-
>
isKind
(
PNK_STRING
)
)
{
PropertyName
*
name
=
key
-
>
pn_atom
-
>
asPropertyName
(
)
;
jsid
id
=
NameToId
(
name
)
;
if
(
id
!
=
IdToTypeId
(
id
)
)
{
if
(
!
emitTree
(
key
)
)
return
false
;
}
else
{
if
(
!
emitAtomOp
(
name
JSOP_GETPROP
)
)
return
false
;
needsGetElem
=
false
;
}
}
else
{
if
(
!
emitComputedPropertyName
(
key
)
)
return
false
;
}
subpattern
=
member
-
>
pn_right
;
}
if
(
needsGetElem
&
&
!
emitElemOpBase
(
JSOP_GETELEM
)
)
return
false
;
if
(
subpattern
-
>
isKind
(
PNK_ASSIGN
)
)
{
if
(
!
emitDefault
(
subpattern
-
>
pn_right
)
)
return
false
;
subpattern
=
subpattern
-
>
pn_left
;
}
int32_t
depthBefore
=
this
-
>
stackDepth
;
if
(
!
emitDestructuringLHS
(
subpattern
emitOption
)
)
return
false
;
if
(
emitOption
=
=
InitializeVars
)
continue
;
MOZ_ASSERT
(
emitOption
=
=
PushInitialValues
)
;
MOZ_ASSERT
(
(
this
-
>
stackDepth
-
this
-
>
stackDepth
)
>
=
-
1
)
;
uint32_t
pickDistance
=
uint32_t
(
(
this
-
>
stackDepth
+
1
)
-
depthBefore
)
;
if
(
pickDistance
>
0
)
{
if
(
pickDistance
>
UINT8_MAX
)
{
reportError
(
subpattern
JSMSG_TOO_MANY_LOCALS
)
;
return
false
;
}
if
(
!
emit2
(
JSOP_PICK
(
uint8_t
)
pickDistance
)
)
return
false
;
}
}
if
(
emitOption
=
=
PushInitialValues
)
{
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDestructuringOpsHelper
(
ParseNode
*
pattern
VarEmitOption
emitOption
)
{
MOZ_ASSERT
(
emitOption
!
=
DefineVars
)
;
if
(
pattern
-
>
isKind
(
PNK_ARRAY
)
)
return
emitDestructuringOpsArrayHelper
(
pattern
emitOption
)
;
return
emitDestructuringOpsObjectHelper
(
pattern
emitOption
)
;
}
bool
BytecodeEmitter
:
:
emitDestructuringOps
(
ParseNode
*
pattern
bool
isLet
)
{
VarEmitOption
emitOption
=
isLet
?
PushInitialValues
:
InitializeVars
;
return
emitDestructuringOpsHelper
(
pattern
emitOption
)
;
}
bool
BytecodeEmitter
:
:
emitTemplateString
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_LIST
)
)
;
bool
pushedString
=
false
;
for
(
ParseNode
*
pn2
=
pn
-
>
pn_head
;
pn2
!
=
NULL
;
pn2
=
pn2
-
>
pn_next
)
{
bool
isString
=
(
pn2
-
>
getKind
(
)
=
=
PNK_STRING
|
|
pn2
-
>
getKind
(
)
=
=
PNK_TEMPLATE_STRING
)
;
if
(
isString
&
&
pn2
-
>
pn_atom
-
>
empty
(
)
)
continue
;
if
(
!
isString
)
{
if
(
!
updateSourceCoordNotes
(
pn2
-
>
pn_pos
.
begin
)
)
return
false
;
}
if
(
!
emitTree
(
pn2
)
)
return
false
;
if
(
!
isString
)
{
if
(
!
emit1
(
JSOP_TOSTRING
)
)
return
false
;
}
if
(
pushedString
)
{
if
(
!
emit1
(
JSOP_ADD
)
)
return
false
;
}
else
{
pushedString
=
true
;
}
}
if
(
!
pushedString
)
{
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
empty
JSOP_STRING
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitVariables
(
ParseNode
*
pn
VarEmitOption
emitOption
)
{
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_LIST
)
)
;
ParseNode
*
next
;
for
(
ParseNode
*
binding
=
pn
-
>
pn_head
;
binding
;
binding
=
next
)
{
if
(
!
updateSourceCoordNotes
(
binding
-
>
pn_pos
.
begin
)
)
return
false
;
next
=
binding
-
>
pn_next
;
if
(
binding
-
>
isKind
(
PNK_ARRAY
)
|
|
binding
-
>
isKind
(
PNK_OBJECT
)
)
{
MOZ_ASSERT
(
pn
-
>
pn_count
=
=
1
)
;
if
(
emitOption
=
=
DefineVars
)
{
if
(
!
emitDestructuringDecls
(
pn
-
>
getOp
(
)
binding
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
emitOption
=
=
InitializeVars
)
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
if
(
!
emitInitializeDestructuringDecls
(
pn
-
>
getOp
(
)
binding
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
}
else
if
(
binding
-
>
isKind
(
PNK_ASSIGN
)
)
{
MOZ_ASSERT
(
binding
-
>
isOp
(
JSOP_NOP
)
)
;
MOZ_ASSERT
(
emitOption
!
=
DefineVars
)
;
MOZ_ASSERT_IF
(
emitOption
=
=
AnnexB
binding
-
>
pn_left
-
>
isKind
(
PNK_NAME
)
)
;
if
(
binding
-
>
pn_left
-
>
isKind
(
PNK_NAME
)
)
{
if
(
!
emitSingleVariable
(
pn
binding
-
>
pn_left
binding
-
>
pn_right
emitOption
)
)
return
false
;
}
else
{
ParseNode
*
initializer
=
binding
-
>
pn_left
;
if
(
!
emitDestructuringDecls
(
pn
-
>
getOp
(
)
initializer
)
)
return
false
;
if
(
!
emitTree
(
binding
-
>
pn_right
)
)
return
false
;
if
(
!
emitDestructuringOpsHelper
(
initializer
emitOption
)
)
return
false
;
if
(
emitOption
=
=
InitializeVars
)
{
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
}
}
else
{
if
(
!
emitSingleVariable
(
pn
binding
binding
-
>
maybeExpr
(
)
emitOption
)
)
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitSingleVariable
(
ParseNode
*
pn
ParseNode
*
binding
ParseNode
*
initializer
VarEmitOption
emitOption
)
{
MOZ_ASSERT
(
binding
-
>
isKind
(
PNK_NAME
)
)
;
if
(
!
bindNameToSlot
(
binding
)
)
return
false
;
JSOp
op
=
binding
-
>
getOp
(
)
;
MOZ_ASSERT
(
op
!
=
JSOP_CALLEE
)
;
MOZ_ASSERT
(
!
binding
-
>
pn_scopecoord
.
isFree
(
)
|
|
!
pn
-
>
isOp
(
JSOP_NOP
)
)
;
jsatomid
atomIndex
;
if
(
!
maybeEmitVarDecl
(
pn
-
>
getOp
(
)
binding
&
atomIndex
)
)
return
false
;
if
(
initializer
)
{
MOZ_ASSERT
(
emitOption
!
=
DefineVars
)
;
if
(
op
=
=
JSOP_SETNAME
|
|
op
=
=
JSOP_STRICTSETNAME
|
|
op
=
=
JSOP_SETGNAME
|
|
op
=
=
JSOP_STRICTSETGNAME
)
{
MOZ_ASSERT
(
emitOption
!
=
PushInitialValues
)
;
if
(
op
=
=
JSOP_SETGNAME
|
|
op
=
=
JSOP_STRICTSETGNAME
)
{
if
(
!
emitIndex32
(
JSOP_BINDGNAME
atomIndex
)
)
return
false
;
}
else
if
(
emitOption
=
=
AnnexB
)
{
if
(
!
emit1
(
JSOP_BINDVAR
)
)
return
false
;
}
else
{
if
(
!
emitIndex32
(
JSOP_BINDNAME
atomIndex
)
)
return
false
;
}
}
bool
oldEmittingForInit
=
emittingForInit
;
emittingForInit
=
false
;
if
(
!
emitTree
(
initializer
)
)
return
false
;
emittingForInit
=
oldEmittingForInit
;
}
else
if
(
op
=
=
JSOP_INITLEXICAL
|
|
op
=
=
JSOP_INITGLEXICAL
|
|
emitOption
=
=
PushInitialValues
)
{
MOZ_ASSERT
(
emitOption
!
=
DefineVars
)
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
}
else
{
return
true
;
}
if
(
emitOption
=
=
InitializeVars
|
|
emitOption
=
=
AnnexB
)
{
MOZ_ASSERT_IF
(
binding
-
>
isDefn
(
)
initializer
=
=
binding
-
>
pn_expr
)
;
if
(
!
binding
-
>
pn_scopecoord
.
isFree
(
)
)
{
if
(
!
emitVarOp
(
binding
op
)
)
return
false
;
}
else
{
if
(
!
emitIndexOp
(
op
atomIndex
)
)
return
false
;
}
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitAssignment
(
ParseNode
*
lhs
JSOp
op
ParseNode
*
rhs
)
{
jsatomid
atomIndex
=
(
jsatomid
)
-
1
;
uint8_t
offset
=
1
;
switch
(
lhs
-
>
getKind
(
)
)
{
case
PNK_NAME
:
if
(
!
bindNameToSlot
(
lhs
)
)
return
false
;
if
(
lhs
-
>
pn_scopecoord
.
isFree
(
)
)
{
if
(
!
makeAtomIndex
(
lhs
-
>
pn_atom
&
atomIndex
)
)
return
false
;
JSOp
bindOp
;
if
(
lhs
-
>
isOp
(
JSOP_SETNAME
)
|
|
lhs
-
>
isOp
(
JSOP_STRICTSETNAME
)
)
{
bindOp
=
JSOP_BINDNAME
;
}
else
if
(
lhs
-
>
isOp
(
JSOP_SETGNAME
)
|
|
lhs
-
>
isOp
(
JSOP_STRICTSETGNAME
)
)
{
bindOp
=
JSOP_BINDGNAME
;
}
else
{
MOZ_ASSERT
(
lhs
-
>
isOp
(
JSOP_SETINTRINSIC
)
)
;
break
;
}
if
(
!
emitIndex32
(
bindOp
atomIndex
)
)
return
false
;
offset
+
+
;
}
break
;
case
PNK_DOT
:
if
(
lhs
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
{
if
(
!
emitSuperPropLHS
(
&
lhs
-
>
as
<
PropertyAccess
>
(
)
.
expression
(
)
)
)
return
false
;
offset
+
=
2
;
}
else
{
if
(
!
emitTree
(
lhs
-
>
expr
(
)
)
)
return
false
;
offset
+
=
1
;
}
if
(
!
makeAtomIndex
(
lhs
-
>
pn_atom
&
atomIndex
)
)
return
false
;
break
;
case
PNK_ELEM
:
{
MOZ_ASSERT
(
lhs
-
>
isArity
(
PN_BINARY
)
)
;
EmitElemOption
opt
=
op
=
=
JSOP_NOP
?
EmitElemOption
:
:
Get
:
EmitElemOption
:
:
CompoundAssign
;
if
(
lhs
-
>
as
<
PropertyByValue
>
(
)
.
isSuper
(
)
)
{
if
(
!
emitSuperElemOperands
(
lhs
opt
)
)
return
false
;
offset
+
=
3
;
}
else
{
if
(
!
emitElemOperands
(
lhs
opt
)
)
return
false
;
offset
+
=
2
;
}
break
;
}
case
PNK_ARRAY
:
case
PNK_OBJECT
:
break
;
case
PNK_CALL
:
MOZ_ASSERT
(
lhs
-
>
pn_xflags
&
PNX_SETCALL
)
;
if
(
!
emitTree
(
lhs
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
break
;
default
:
MOZ_ASSERT
(
0
)
;
}
if
(
op
!
=
JSOP_NOP
)
{
MOZ_ASSERT
(
rhs
)
;
switch
(
lhs
-
>
getKind
(
)
)
{
case
PNK_NAME
:
if
(
lhs
-
>
isConst
(
)
&
&
lhs
-
>
isOp
(
JSOP_CALLEE
)
)
{
if
(
!
emit1
(
JSOP_CALLEE
)
)
return
false
;
}
else
if
(
lhs
-
>
isConst
(
)
&
&
(
lhs
-
>
isOp
(
JSOP_GETNAME
)
|
|
lhs
-
>
isOp
(
JSOP_GETGNAME
)
)
)
{
if
(
!
emitIndex32
(
lhs
-
>
getOp
(
)
atomIndex
)
)
return
false
;
}
else
if
(
lhs
-
>
isOp
(
JSOP_SETNAME
)
|
|
lhs
-
>
isOp
(
JSOP_STRICTSETNAME
)
)
{
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitIndex32
(
JSOP_GETXPROP
atomIndex
)
)
return
false
;
}
else
if
(
lhs
-
>
isOp
(
JSOP_SETGNAME
)
|
|
lhs
-
>
isOp
(
JSOP_STRICTSETGNAME
)
)
{
MOZ_ASSERT
(
lhs
-
>
pn_scopecoord
.
isFree
(
)
)
;
if
(
!
emitAtomOp
(
lhs
JSOP_GETGNAME
)
)
return
false
;
}
else
if
(
lhs
-
>
isOp
(
JSOP_SETINTRINSIC
)
)
{
MOZ_ASSERT
(
lhs
-
>
pn_scopecoord
.
isFree
(
)
)
;
if
(
!
emitAtomOp
(
lhs
JSOP_GETINTRINSIC
)
)
return
false
;
}
else
{
JSOp
op
;
switch
(
lhs
-
>
getOp
(
)
)
{
case
JSOP_SETARG
:
op
=
JSOP_GETARG
;
break
;
case
JSOP_SETLOCAL
:
op
=
JSOP_GETLOCAL
;
break
;
case
JSOP_SETALIASEDVAR
:
op
=
JSOP_GETALIASEDVAR
;
break
;
default
:
MOZ_CRASH
(
"
Bad
op
"
)
;
}
if
(
!
emitVarOp
(
lhs
op
)
)
return
false
;
}
break
;
case
PNK_DOT
:
{
JSOp
getOp
;
if
(
lhs
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
{
if
(
!
emit1
(
JSOP_DUP2
)
)
return
false
;
getOp
=
JSOP_GETPROP_SUPER
;
}
else
{
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
bool
isLength
=
(
lhs
-
>
pn_atom
=
=
cx
-
>
names
(
)
.
length
)
;
getOp
=
isLength
?
JSOP_LENGTH
:
JSOP_GETPROP
;
}
if
(
!
emitIndex32
(
getOp
atomIndex
)
)
return
false
;
break
;
}
case
PNK_ELEM
:
{
JSOp
elemOp
;
if
(
lhs
-
>
as
<
PropertyByValue
>
(
)
.
isSuper
(
)
)
{
if
(
!
emitDupAt
(
2
)
)
return
false
;
if
(
!
emitDupAt
(
2
)
)
return
false
;
if
(
!
emitDupAt
(
2
)
)
return
false
;
elemOp
=
JSOP_GETELEM_SUPER
;
}
else
{
if
(
!
emit1
(
JSOP_DUP2
)
)
return
false
;
elemOp
=
JSOP_GETELEM
;
}
if
(
!
emitElemOpBase
(
elemOp
)
)
return
false
;
break
;
}
case
PNK_CALL
:
MOZ_ASSERT
(
lhs
-
>
pn_xflags
&
PNX_SETCALL
)
;
if
(
!
emit1
(
JSOP_NULL
)
)
return
false
;
break
;
default
:
;
}
}
if
(
rhs
)
{
if
(
!
emitTree
(
rhs
)
)
return
false
;
}
else
{
if
(
offset
!
=
1
&
&
!
emit2
(
JSOP_PICK
offset
-
1
)
)
return
false
;
}
if
(
op
!
=
JSOP_NOP
)
{
if
(
!
lhs
-
>
isKind
(
PNK_NAME
)
)
{
if
(
!
newSrcNote
(
SRC_ASSIGNOP
)
)
return
false
;
}
if
(
!
emit1
(
op
)
)
return
false
;
}
switch
(
lhs
-
>
getKind
(
)
)
{
case
PNK_NAME
:
if
(
lhs
-
>
isOp
(
JSOP_SETARG
)
|
|
lhs
-
>
isOp
(
JSOP_SETLOCAL
)
|
|
lhs
-
>
isOp
(
JSOP_SETALIASEDVAR
)
)
{
if
(
!
emitVarOp
(
lhs
lhs
-
>
getOp
(
)
)
)
return
false
;
}
else
{
if
(
!
emitIndexOp
(
lhs
-
>
getOp
(
)
atomIndex
)
)
return
false
;
}
break
;
case
PNK_DOT
:
{
JSOp
setOp
=
lhs
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
?
(
sc
-
>
strict
(
)
?
JSOP_STRICTSETPROP_SUPER
:
JSOP_SETPROP_SUPER
)
:
(
sc
-
>
strict
(
)
?
JSOP_STRICTSETPROP
:
JSOP_SETPROP
)
;
if
(
!
emitIndexOp
(
setOp
atomIndex
)
)
return
false
;
break
;
}
case
PNK_CALL
:
MOZ_ASSERT
(
lhs
-
>
pn_xflags
&
PNX_SETCALL
)
;
break
;
case
PNK_ELEM
:
{
JSOp
setOp
=
lhs
-
>
as
<
PropertyByValue
>
(
)
.
isSuper
(
)
?
sc
-
>
strict
(
)
?
JSOP_STRICTSETELEM_SUPER
:
JSOP_SETELEM_SUPER
:
sc
-
>
strict
(
)
?
JSOP_STRICTSETELEM
:
JSOP_SETELEM
;
if
(
!
emit1
(
setOp
)
)
return
false
;
break
;
}
case
PNK_ARRAY
:
case
PNK_OBJECT
:
if
(
!
emitDestructuringOps
(
lhs
)
)
return
false
;
break
;
default
:
MOZ_ASSERT
(
0
)
;
}
return
true
;
}
bool
ParseNode
:
:
getConstantValue
(
ExclusiveContext
*
cx
AllowConstantObjects
allowObjects
MutableHandleValue
vp
Value
*
compare
size_t
ncompare
NewObjectKind
newKind
)
{
MOZ_ASSERT
(
newKind
=
=
TenuredObject
|
|
newKind
=
=
SingletonObject
)
;
switch
(
getKind
(
)
)
{
case
PNK_NUMBER
:
vp
.
setNumber
(
pn_dval
)
;
return
true
;
case
PNK_TEMPLATE_STRING
:
case
PNK_STRING
:
vp
.
setString
(
pn_atom
)
;
return
true
;
case
PNK_TRUE
:
vp
.
setBoolean
(
true
)
;
return
true
;
case
PNK_FALSE
:
vp
.
setBoolean
(
false
)
;
return
true
;
case
PNK_NULL
:
vp
.
setNull
(
)
;
return
true
;
case
PNK_CALLSITEOBJ
:
case
PNK_ARRAY
:
{
unsigned
count
;
ParseNode
*
pn
;
if
(
allowObjects
=
=
DontAllowObjects
)
{
vp
.
setMagic
(
JS_GENERIC_MAGIC
)
;
return
true
;
}
ObjectGroup
:
:
NewArrayKind
arrayKind
=
ObjectGroup
:
:
NewArrayKind
:
:
Normal
;
if
(
allowObjects
=
=
ForCopyOnWriteArray
)
{
arrayKind
=
ObjectGroup
:
:
NewArrayKind
:
:
CopyOnWrite
;
allowObjects
=
DontAllowObjects
;
}
if
(
getKind
(
)
=
=
PNK_CALLSITEOBJ
)
{
count
=
pn_count
-
1
;
pn
=
pn_head
-
>
pn_next
;
}
else
{
MOZ_ASSERT
(
isOp
(
JSOP_NEWINIT
)
&
&
!
(
pn_xflags
&
PNX_NONCONST
)
)
;
count
=
pn_count
;
pn
=
pn_head
;
}
AutoValueVector
values
(
cx
)
;
if
(
!
values
.
appendN
(
MagicValue
(
JS_ELEMENTS_HOLE
)
count
)
)
return
false
;
size_t
idx
;
for
(
idx
=
0
;
pn
;
idx
+
+
pn
=
pn
-
>
pn_next
)
{
if
(
!
pn
-
>
getConstantValue
(
cx
allowObjects
values
[
idx
]
values
.
begin
(
)
idx
)
)
return
false
;
if
(
values
[
idx
]
.
isMagic
(
JS_GENERIC_MAGIC
)
)
{
vp
.
setMagic
(
JS_GENERIC_MAGIC
)
;
return
true
;
}
}
MOZ_ASSERT
(
idx
=
=
count
)
;
JSObject
*
obj
=
ObjectGroup
:
:
newArrayObject
(
cx
values
.
begin
(
)
values
.
length
(
)
newKind
arrayKind
)
;
if
(
!
obj
)
return
false
;
if
(
!
CombineArrayElementTypes
(
cx
obj
compare
ncompare
)
)
return
false
;
vp
.
setObject
(
*
obj
)
;
return
true
;
}
case
PNK_OBJECT
:
{
MOZ_ASSERT
(
isOp
(
JSOP_NEWINIT
)
)
;
MOZ_ASSERT
(
!
(
pn_xflags
&
PNX_NONCONST
)
)
;
if
(
allowObjects
=
=
DontAllowObjects
)
{
vp
.
setMagic
(
JS_GENERIC_MAGIC
)
;
return
true
;
}
MOZ_ASSERT
(
allowObjects
=
=
AllowObjects
)
;
Rooted
<
IdValueVector
>
properties
(
cx
IdValueVector
(
cx
)
)
;
RootedValue
value
(
cx
)
idvalue
(
cx
)
;
for
(
ParseNode
*
pn
=
pn_head
;
pn
;
pn
=
pn
-
>
pn_next
)
{
if
(
!
pn
-
>
pn_right
-
>
getConstantValue
(
cx
allowObjects
&
value
)
)
return
false
;
if
(
value
.
isMagic
(
JS_GENERIC_MAGIC
)
)
{
vp
.
setMagic
(
JS_GENERIC_MAGIC
)
;
return
true
;
}
ParseNode
*
pnid
=
pn
-
>
pn_left
;
if
(
pnid
-
>
isKind
(
PNK_NUMBER
)
)
{
idvalue
=
NumberValue
(
pnid
-
>
pn_dval
)
;
}
else
{
MOZ_ASSERT
(
pnid
-
>
isKind
(
PNK_OBJECT_PROPERTY_NAME
)
|
|
pnid
-
>
isKind
(
PNK_STRING
)
)
;
MOZ_ASSERT
(
pnid
-
>
pn_atom
!
=
cx
-
>
names
(
)
.
proto
)
;
idvalue
=
StringValue
(
pnid
-
>
pn_atom
)
;
}
RootedId
id
(
cx
)
;
if
(
!
ValueToId
<
CanGC
>
(
cx
idvalue
&
id
)
)
return
false
;
if
(
!
properties
.
append
(
IdValuePair
(
id
value
)
)
)
return
false
;
}
JSObject
*
obj
=
ObjectGroup
:
:
newPlainObject
(
cx
properties
.
begin
(
)
properties
.
length
(
)
newKind
)
;
if
(
!
obj
)
return
false
;
if
(
!
CombinePlainObjectPropertyTypes
(
cx
obj
compare
ncompare
)
)
return
false
;
vp
.
setObject
(
*
obj
)
;
return
true
;
}
default
:
MOZ_CRASH
(
"
Unexpected
node
"
)
;
}
return
false
;
}
bool
BytecodeEmitter
:
:
emitSingletonInitialiser
(
ParseNode
*
pn
)
{
NewObjectKind
newKind
=
(
pn
-
>
getKind
(
)
=
=
PNK_OBJECT
)
?
SingletonObject
:
TenuredObject
;
RootedValue
value
(
cx
)
;
if
(
!
pn
-
>
getConstantValue
(
cx
ParseNode
:
:
AllowObjects
&
value
nullptr
0
newKind
)
)
return
false
;
MOZ_ASSERT_IF
(
newKind
=
=
SingletonObject
value
.
toObject
(
)
.
isSingleton
(
)
)
;
ObjectBox
*
objbox
=
parser
-
>
newObjectBox
(
&
value
.
toObject
(
)
)
;
if
(
!
objbox
)
return
false
;
return
emitObjectOp
(
objbox
JSOP_OBJECT
)
;
}
bool
BytecodeEmitter
:
:
emitCallSiteObject
(
ParseNode
*
pn
)
{
RootedValue
value
(
cx
)
;
if
(
!
pn
-
>
getConstantValue
(
cx
ParseNode
:
:
AllowObjects
&
value
)
)
return
false
;
MOZ_ASSERT
(
value
.
isObject
(
)
)
;
ObjectBox
*
objbox1
=
parser
-
>
newObjectBox
(
&
value
.
toObject
(
)
)
;
if
(
!
objbox1
)
return
false
;
if
(
!
pn
-
>
as
<
CallSiteNode
>
(
)
.
getRawArrayValue
(
cx
&
value
)
)
return
false
;
MOZ_ASSERT
(
value
.
isObject
(
)
)
;
ObjectBox
*
objbox2
=
parser
-
>
newObjectBox
(
&
value
.
toObject
(
)
)
;
if
(
!
objbox2
)
return
false
;
return
emitObjectPairOp
(
objbox1
objbox2
JSOP_CALLSITEOBJ
)
;
}
JS_STATIC_ASSERT
(
JSOP_NOP_LENGTH
=
=
1
)
;
JS_STATIC_ASSERT
(
JSOP_POP_LENGTH
=
=
1
)
;
namespace
{
class
EmitLevelManager
{
BytecodeEmitter
*
bce
;
public
:
explicit
EmitLevelManager
(
BytecodeEmitter
*
bce
)
:
bce
(
bce
)
{
bce
-
>
emitLevel
+
+
;
}
~
EmitLevelManager
(
)
{
bce
-
>
emitLevel
-
-
;
}
}
;
}
bool
BytecodeEmitter
:
:
emitCatch
(
ParseNode
*
pn
)
{
StmtInfoBCE
*
stmt
=
innermostStmt
(
)
;
MOZ_ASSERT
(
stmt
-
>
type
=
=
StmtType
:
:
BLOCK
&
&
stmt
-
>
isBlockScope
)
;
stmt
-
>
type
=
StmtType
:
:
CATCH
;
stmt
-
>
staticBlock
(
)
.
setIsForCatchParameters
(
)
;
stmt
=
stmt
-
>
enclosing
;
MOZ_ASSERT
(
stmt
-
>
type
=
=
StmtType
:
:
TRY
|
|
stmt
-
>
type
=
=
StmtType
:
:
FINALLY
)
;
if
(
!
emit1
(
JSOP_EXCEPTION
)
)
return
false
;
if
(
pn
-
>
pn_kid2
&
&
!
emit1
(
JSOP_DUP
)
)
return
false
;
ParseNode
*
pn2
=
pn
-
>
pn_kid1
;
switch
(
pn2
-
>
getKind
(
)
)
{
case
PNK_ARRAY
:
case
PNK_OBJECT
:
if
(
!
emitDestructuringOps
(
pn2
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
break
;
case
PNK_NAME
:
MOZ_ASSERT
(
!
pn2
-
>
pn_scopecoord
.
isFree
(
)
)
;
if
(
!
emitVarOp
(
pn2
JSOP_INITLEXICAL
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
break
;
default
:
MOZ_ASSERT
(
0
)
;
}
if
(
pn
-
>
pn_kid2
)
{
if
(
!
emitTree
(
pn
-
>
pn_kid2
)
)
return
false
;
JumpList
guardCheck
;
if
(
!
emitJump
(
JSOP_IFNE
&
guardCheck
)
)
return
false
;
{
NonLocalExitScope
nle
(
this
)
;
if
(
!
emit1
(
JSOP_THROWING
)
)
return
false
;
if
(
!
nle
.
prepareForNonLocalJump
(
stmt
)
)
return
false
;
JumpList
guardJump
;
if
(
!
emitJump
(
JSOP_GOTO
&
guardJump
)
)
return
false
;
stmt
-
>
guardJump
(
)
=
guardJump
;
}
if
(
!
emitJumpTargetAndPatch
(
guardCheck
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
return
emitTree
(
pn
-
>
pn_kid3
)
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitTry
(
ParseNode
*
pn
)
{
StmtInfoBCE
stmtInfo
(
cx
)
;
JumpTarget
top
{
-
1
}
;
pushStatement
(
&
stmtInfo
pn
-
>
pn_kid3
?
StmtType
:
:
FINALLY
:
StmtType
:
:
TRY
top
)
;
int
depth
=
stackDepth
;
unsigned
noteIndex
;
if
(
!
newSrcNote
(
SRC_TRY
&
noteIndex
)
)
return
false
;
if
(
!
emit1
(
JSOP_TRY
)
)
return
false
;
ptrdiff_t
tryStart
=
offset
(
)
;
if
(
!
emitTree
(
pn
-
>
pn_kid1
)
)
return
false
;
MOZ_ASSERT
(
depth
=
=
stackDepth
)
;
if
(
pn
-
>
pn_kid3
)
{
if
(
!
emitJump
(
JSOP_GOSUB
&
stmtInfo
.
gosubs
(
)
)
)
return
false
;
}
if
(
!
setSrcNoteOffset
(
noteIndex
0
offset
(
)
-
tryStart
+
JSOP_TRY_LENGTH
)
)
return
false
;
JumpList
catchJump
;
if
(
!
emitJump
(
JSOP_GOTO
&
catchJump
)
)
return
false
;
JumpTarget
tryEnd
;
if
(
!
emitJumpTarget
(
&
tryEnd
)
)
return
false
;
ParseNode
*
catchList
=
pn
-
>
pn_kid2
;
if
(
catchList
)
{
MOZ_ASSERT
(
catchList
-
>
isKind
(
PNK_CATCHLIST
)
)
;
for
(
ParseNode
*
pn3
=
catchList
-
>
pn_head
;
pn3
;
pn3
=
pn3
-
>
pn_next
)
{
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
depth
)
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
if
(
!
emit1
(
JSOP_SETRVAL
)
)
return
false
;
MOZ_ASSERT
(
pn3
-
>
isKind
(
PNK_LEXICALSCOPE
)
)
;
if
(
!
emitTree
(
pn3
)
)
return
false
;
if
(
pn
-
>
pn_kid3
)
{
if
(
!
emitJump
(
JSOP_GOSUB
&
stmtInfo
.
gosubs
(
)
)
)
return
false
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
depth
)
;
}
if
(
!
emitJump
(
JSOP_GOTO
&
catchJump
)
)
return
false
;
if
(
stmtInfo
.
guardJump
(
)
.
offset
!
=
-
1
)
{
if
(
!
emitJumpTargetAndPatch
(
stmtInfo
.
guardJump
(
)
)
)
return
false
;
stmtInfo
.
guardJump
(
)
.
offset
=
-
1
;
if
(
!
pn3
-
>
pn_next
)
{
if
(
!
emit1
(
JSOP_EXCEPTION
)
)
return
false
;
if
(
!
emit1
(
JSOP_THROW
)
)
return
false
;
}
}
}
}
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
depth
)
;
JumpTarget
finallyStart
{
0
}
;
if
(
pn
-
>
pn_kid3
)
{
if
(
!
emitJumpTarget
(
&
finallyStart
)
)
return
false
;
patchJumpsToTarget
(
stmtInfo
.
gosubs
(
)
finallyStart
)
;
stmtInfo
.
type
=
StmtType
:
:
SUBROUTINE
;
if
(
!
updateSourceCoordNotes
(
pn
-
>
pn_kid3
-
>
pn_pos
.
begin
)
)
return
false
;
if
(
!
emit1
(
JSOP_FINALLY
)
)
return
false
;
if
(
!
emit1
(
JSOP_GETRVAL
)
)
return
false
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
if
(
!
emit1
(
JSOP_SETRVAL
)
)
return
false
;
if
(
!
emitTree
(
pn
-
>
pn_kid3
)
)
return
false
;
if
(
!
emit1
(
JSOP_SETRVAL
)
)
return
false
;
if
(
!
emit1
(
JSOP_RETSUB
)
)
return
false
;
hasTryFinally
=
true
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
depth
)
;
}
if
(
!
popStatement
(
)
)
return
false
;
if
(
!
emit1
(
JSOP_NOP
)
)
return
false
;
if
(
!
emitJumpTargetAndPatch
(
catchJump
)
)
return
false
;
if
(
catchList
&
&
!
tryNoteList
.
append
(
JSTRY_CATCH
depth
tryStart
tryEnd
.
offset
)
)
return
false
;
if
(
pn
-
>
pn_kid3
&
&
!
tryNoteList
.
append
(
JSTRY_FINALLY
depth
tryStart
finallyStart
.
offset
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitIf
(
ParseNode
*
pn
)
{
StmtInfoBCE
stmtInfo
(
cx
)
;
stmtInfo
.
type
=
StmtType
:
:
IF
;
JumpList
beq
;
JumpList
jmp
;
unsigned
noteIndex
=
-
1
;
if_again
:
if
(
!
emitTree
(
pn
-
>
pn_kid1
)
)
return
false
;
JumpTarget
top
{
offset
(
)
}
;
if
(
stmtInfo
.
type
=
=
StmtType
:
:
IF
)
{
pushStatement
(
&
stmtInfo
StmtType
:
:
IF
top
)
;
}
else
{
MOZ_ASSERT
(
stmtInfo
.
type
=
=
StmtType
:
:
ELSE
)
;
stmtInfo
.
type
=
StmtType
:
:
IF
;
stmtInfo
.
update
=
top
;
if
(
!
setSrcNoteOffset
(
noteIndex
0
jmp
.
offset
-
beq
.
offset
)
)
return
false
;
}
ParseNode
*
pn3
=
pn
-
>
pn_kid3
;
if
(
!
newSrcNote
(
pn3
?
SRC_IF_ELSE
:
SRC_IF
&
noteIndex
)
)
return
false
;
beq
=
JumpList
(
)
;
if
(
!
emitJump
(
JSOP_IFEQ
&
beq
)
)
return
false
;
if
(
!
emitTree
(
pn
-
>
pn_kid2
)
)
return
false
;
if
(
pn3
)
{
stmtInfo
.
type
=
StmtType
:
:
ELSE
;
if
(
!
emitGoto
(
&
stmtInfo
&
stmtInfo
.
breaks
)
)
return
false
;
jmp
=
stmtInfo
.
breaks
;
if
(
!
emitJumpTargetAndPatch
(
beq
)
)
return
false
;
if
(
pn3
-
>
isKind
(
PNK_IF
)
)
{
pn
=
pn3
;
goto
if_again
;
}
if
(
!
emitTree
(
pn3
)
)
return
false
;
if
(
!
setSrcNoteOffset
(
noteIndex
0
jmp
.
offset
-
beq
.
offset
)
)
return
false
;
}
else
{
if
(
!
emitJumpTargetAndPatch
(
beq
)
)
return
false
;
}
if
(
!
popStatement
(
)
)
return
false
;
return
true
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitLetBlock
(
ParseNode
*
pnLet
)
{
MOZ_ASSERT
(
pnLet
-
>
isArity
(
PN_BINARY
)
)
;
ParseNode
*
varList
=
pnLet
-
>
pn_left
;
MOZ_ASSERT
(
varList
-
>
isArity
(
PN_LIST
)
)
;
ParseNode
*
letBody
=
pnLet
-
>
pn_right
;
MOZ_ASSERT
(
letBody
-
>
isLexical
(
)
&
&
letBody
-
>
isKind
(
PNK_LEXICALSCOPE
)
)
;
int
letHeadDepth
=
this
-
>
stackDepth
;
if
(
!
emitVariables
(
varList
PushInitialValues
)
)
return
false
;
uint32_t
valuesPushed
=
this
-
>
stackDepth
-
letHeadDepth
;
StmtInfoBCE
stmtInfo
(
cx
)
;
if
(
!
enterBlockScope
(
&
stmtInfo
letBody
-
>
pn_objbox
JSOP_UNINITIALIZED
valuesPushed
)
)
return
false
;
if
(
!
emitTree
(
letBody
-
>
pn_expr
)
)
return
false
;
if
(
!
leaveNestedScope
(
&
stmtInfo
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitHoistedFunctionsInList
(
ParseNode
*
list
)
{
MOZ_ASSERT
(
list
-
>
pn_xflags
&
PNX_FUNCDEFS
)
;
for
(
ParseNode
*
pn
=
list
-
>
pn_head
;
pn
;
pn
=
pn
-
>
pn_next
)
{
ParseNode
*
maybeFun
=
pn
;
if
(
!
sc
-
>
strict
(
)
)
{
while
(
maybeFun
-
>
isKind
(
PNK_LABEL
)
)
maybeFun
=
maybeFun
-
>
as
<
LabeledStatement
>
(
)
.
statement
(
)
;
}
if
(
maybeFun
-
>
isKind
(
PNK_ANNEXB_FUNCTION
)
|
|
(
maybeFun
-
>
isKind
(
PNK_FUNCTION
)
&
&
maybeFun
-
>
functionIsHoisted
(
)
)
)
{
if
(
!
emitTree
(
maybeFun
)
)
return
false
;
}
}
return
true
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitLexicalScope
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_LEXICALSCOPE
)
)
;
StmtInfoBCE
stmtInfo
(
cx
)
;
if
(
!
enterBlockScope
(
&
stmtInfo
pn
-
>
pn_objbox
JSOP_UNINITIALIZED
0
)
)
return
false
;
ParseNode
*
body
=
pn
-
>
pn_expr
;
if
(
body
-
>
isKind
(
PNK_STATEMENTLIST
)
&
&
body
-
>
pn_xflags
&
PNX_FUNCDEFS
)
{
if
(
!
emitHoistedFunctionsInList
(
body
)
)
return
false
;
}
if
(
!
emitTree
(
body
)
)
return
false
;
if
(
!
leaveNestedScope
(
&
stmtInfo
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitWith
(
ParseNode
*
pn
)
{
StmtInfoBCE
stmtInfo
(
cx
)
;
if
(
!
emitTree
(
pn
-
>
pn_left
)
)
return
false
;
if
(
!
enterNestedScope
(
&
stmtInfo
pn
-
>
pn_binary_obj
StmtType
:
:
WITH
)
)
return
false
;
if
(
!
emitTree
(
pn
-
>
pn_right
)
)
return
false
;
if
(
!
leaveNestedScope
(
&
stmtInfo
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitRequireObjectCoercible
(
)
{
#
ifdef
DEBUG
auto
depth
=
this
-
>
stackDepth
;
#
endif
MOZ_ASSERT
(
depth
>
0
)
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
RequireObjectCoercible
JSOP_GETINTRINSIC
)
)
{
return
false
;
}
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
if
(
!
emit2
(
JSOP_PICK
2
)
)
return
false
;
if
(
!
emitCall
(
JSOP_CALL
1
)
)
return
false
;
checkTypeSet
(
JSOP_CALL
)
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
MOZ_ASSERT
(
depth
=
=
this
-
>
stackDepth
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitIterator
(
)
{
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emit2
(
JSOP_SYMBOL
uint8_t
(
JS
:
:
SymbolCode
:
:
iterator
)
)
)
return
false
;
if
(
!
emitElemOpBase
(
JSOP_CALLELEM
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
if
(
!
emitCall
(
JSOP_CALLITER
0
)
)
return
false
;
checkTypeSet
(
JSOP_CALLITER
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitForInOrOfVariables
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_VAR
)
|
|
pn
-
>
isKind
(
PNK_LET
)
)
;
emittingForInit
=
true
;
if
(
pn
-
>
isKind
(
PNK_VAR
)
)
{
if
(
!
emitVariables
(
pn
DefineVars
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_LET
)
)
;
if
(
!
emitVariables
(
pn
InitializeVars
)
)
return
false
;
}
emittingForInit
=
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitSpread
(
bool
allowSelfHosted
)
{
LoopStmtInfo
stmtInfo
(
cx
)
;
JumpTarget
top
{
-
1
}
;
pushLoopStatement
(
&
stmtInfo
StmtType
:
:
SPREAD
top
)
;
unsigned
noteIndex
;
if
(
!
newSrcNote
(
SRC_FOR_OF
&
noteIndex
)
)
return
false
;
JumpList
initialJump
;
if
(
!
emitJump
(
JSOP_GOTO
&
initialJump
)
)
return
false
;
if
(
!
emitLoopHead
(
nullptr
&
top
)
)
return
false
;
stmtInfo
.
setTop
(
top
)
;
this
-
>
stackDepth
+
+
;
JumpList
beq
;
JumpTarget
brk
{
-
1
}
;
{
#
ifdef
DEBUG
auto
loopDepth
=
this
-
>
stackDepth
;
#
endif
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
value
JSOP_GETPROP
)
)
return
false
;
if
(
!
emit1
(
JSOP_INITELEM_INC
)
)
return
false
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
loopDepth
-
1
)
;
if
(
!
emitLoopEntry
(
nullptr
initialJump
)
)
return
false
;
if
(
!
emitDupAt
(
2
)
)
return
false
;
if
(
!
emitIteratorNext
(
nullptr
allowSelfHosted
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
done
JSOP_GETPROP
)
)
return
false
;
if
(
!
emitBackwardJump
(
JSOP_IFEQ
top
&
beq
&
brk
)
)
return
false
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
loopDepth
)
;
}
if
(
!
setSrcNoteOffset
(
noteIndex
0
beq
.
offset
-
initialJump
.
offset
)
)
return
false
;
if
(
!
popStatement
(
)
)
return
false
;
if
(
!
tryNoteList
.
append
(
JSTRY_FOR_OF
stackDepth
top
.
offset
brk
.
offset
)
)
return
false
;
if
(
!
emit2
(
JSOP_PICK
3
)
)
return
false
;
return
emitUint16Operand
(
JSOP_POPN
2
)
;
}
bool
BytecodeEmitter
:
:
emitForOf
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
pn_left
-
>
isKind
(
PNK_FOROF
)
)
;
JumpTarget
top
{
-
1
}
;
ParseNode
*
forHead
=
pn
-
>
pn_left
;
if
(
ParseNode
*
loopDecl
=
forHead
-
>
pn_kid1
)
{
if
(
!
emitForInOrOfVariables
(
loopDecl
)
)
return
false
;
}
ParseNode
*
forHeadExpr
=
forHead
-
>
pn_kid3
;
if
(
!
emitTree
(
forHeadExpr
)
)
return
false
;
if
(
!
emitIterator
(
)
)
return
false
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
LoopStmtInfo
stmtInfo
(
cx
)
;
pushLoopStatement
(
&
stmtInfo
StmtType
:
:
FOR_OF_LOOP
top
)
;
unsigned
noteIndex
;
if
(
!
newSrcNote
(
SRC_FOR_OF
&
noteIndex
)
)
return
false
;
JumpList
jmp
;
if
(
!
emitJump
(
JSOP_GOTO
&
jmp
)
)
return
false
;
if
(
!
emitLoopHead
(
nullptr
&
top
)
)
return
false
;
stmtInfo
.
setTop
(
top
)
;
JumpList
beq
;
JumpTarget
brk
{
-
1
}
;
{
#
ifdef
DEBUG
auto
loopDepth
=
this
-
>
stackDepth
;
#
endif
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
value
JSOP_GETPROP
)
)
return
false
;
ParseNode
*
forTarget
=
forHead
-
>
pn_kid2
;
if
(
!
emitAssignment
(
forTarget
JSOP_NOP
nullptr
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
loopDepth
"
the
stack
must
be
balanced
around
the
assignment
"
"
operation
"
)
;
ParseNode
*
forBody
=
pn
-
>
pn_right
;
if
(
!
emitTree
(
forBody
)
)
return
false
;
setContinueHere
(
&
stmtInfo
)
;
if
(
!
emitLoopEntry
(
forHeadExpr
jmp
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitIteratorNext
(
forHead
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
done
JSOP_GETPROP
)
)
return
false
;
if
(
!
emitBackwardJump
(
JSOP_IFEQ
top
&
beq
&
brk
)
)
return
false
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
loopDepth
)
;
}
if
(
!
setSrcNoteOffset
(
noteIndex
0
beq
.
offset
-
jmp
.
offset
)
)
return
false
;
if
(
!
popStatement
(
)
)
return
false
;
if
(
!
tryNoteList
.
append
(
JSTRY_FOR_OF
stackDepth
top
.
offset
brk
.
offset
)
)
return
false
;
return
emitUint16Operand
(
JSOP_POPN
2
)
;
}
bool
BytecodeEmitter
:
:
emitForIn
(
ParseNode
*
pn
)
{
JumpTarget
top
{
-
1
}
;
ParseNode
*
forHead
=
pn
-
>
pn_left
;
ParseNode
*
forBody
=
pn
-
>
pn_right
;
ParseNode
*
loopDecl
=
forHead
-
>
pn_kid1
;
if
(
loopDecl
&
&
!
emitForInOrOfVariables
(
loopDecl
)
)
return
false
;
if
(
!
emitTree
(
forHead
-
>
pn_kid3
)
)
return
false
;
MOZ_ASSERT
(
pn
-
>
isOp
(
JSOP_ITER
)
)
;
if
(
!
emit2
(
JSOP_ITER
(
uint8_t
)
pn
-
>
pn_iflags
)
)
return
false
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
LoopStmtInfo
stmtInfo
(
cx
)
;
pushLoopStatement
(
&
stmtInfo
StmtType
:
:
FOR_IN_LOOP
top
)
;
unsigned
noteIndex
;
if
(
!
newSrcNote
(
SRC_FOR_IN
&
noteIndex
)
)
return
false
;
JumpList
jmp
;
if
(
!
emitJump
(
JSOP_GOTO
&
jmp
)
)
return
false
;
if
(
!
emitLoopHead
(
nullptr
&
top
)
)
return
false
;
stmtInfo
.
setTop
(
top
)
;
#
ifdef
DEBUG
int
loopDepth
=
this
-
>
stackDepth
;
#
endif
if
(
!
emitAssignment
(
forHead
-
>
pn_kid2
JSOP_NOP
nullptr
)
)
return
false
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
loopDepth
)
;
if
(
!
emitTree
(
forBody
)
)
return
false
;
setContinueHere
(
&
stmtInfo
)
;
if
(
!
emitLoopEntry
(
nullptr
jmp
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
if
(
!
emit1
(
JSOP_MOREITER
)
)
return
false
;
if
(
!
emit1
(
JSOP_ISNOITER
)
)
return
false
;
JumpList
beq
;
JumpTarget
brk
{
-
1
}
;
if
(
!
emitBackwardJump
(
JSOP_IFEQ
top
&
beq
&
brk
)
)
return
false
;
if
(
!
setSrcNoteOffset
(
noteIndex
0
beq
.
offset
-
jmp
.
offset
)
)
return
false
;
if
(
!
popStatement
(
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
if
(
!
tryNoteList
.
append
(
JSTRY_FOR_IN
this
-
>
stackDepth
top
.
offset
offset
(
)
)
)
return
false
;
if
(
!
emit1
(
JSOP_ENDITER
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitCStyleFor
(
ParseNode
*
pn
)
{
LoopStmtInfo
stmtInfo
(
cx
)
;
JumpTarget
top
{
-
1
}
;
pushLoopStatement
(
&
stmtInfo
StmtType
:
:
FOR_LOOP
top
)
;
ParseNode
*
forHead
=
pn
-
>
pn_left
;
ParseNode
*
forBody
=
pn
-
>
pn_right
;
bool
forLoopRequiresFreshening
=
false
;
if
(
ParseNode
*
init
=
forHead
-
>
pn_kid1
)
{
forLoopRequiresFreshening
=
init
-
>
isKind
(
PNK_LET
)
;
emittingForInit
=
true
;
if
(
!
updateSourceCoordNotes
(
init
-
>
pn_pos
.
begin
)
)
return
false
;
if
(
!
emitTree
(
init
)
)
return
false
;
emittingForInit
=
false
;
if
(
!
init
-
>
isKind
(
PNK_VAR
)
&
&
!
init
-
>
isKind
(
PNK_LET
)
&
&
!
init
-
>
isKind
(
PNK_CONST
)
)
{
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
}
unsigned
noteIndex
;
if
(
!
newSrcNote
(
SRC_FOR
&
noteIndex
)
)
return
false
;
if
(
!
emit1
(
JSOP_NOP
)
)
return
false
;
ptrdiff_t
tmp
=
offset
(
)
;
JumpList
jmp
;
if
(
forHead
-
>
pn_kid2
)
{
if
(
!
emitJump
(
JSOP_GOTO
&
jmp
)
)
return
false
;
}
if
(
!
emitLoopHead
(
forBody
&
top
)
)
return
false
;
stmtInfo
.
setTop
(
top
)
;
if
(
jmp
.
offset
=
=
-
1
&
&
!
emitLoopEntry
(
forBody
jmp
)
)
return
false
;
if
(
!
emitTree
(
forBody
)
)
return
false
;
JumpTarget
continues
;
if
(
!
emitJumpTarget
(
&
continues
)
)
return
false
;
setContinueTarget
(
&
stmtInfo
continues
)
;
if
(
forLoopRequiresFreshening
)
{
StmtInfoBCE
*
enclosing
=
stmtInfo
.
enclosing
;
MOZ_ASSERT
(
enclosing
-
>
type
=
=
StmtType
:
:
BLOCK
)
;
MOZ_ASSERT
(
enclosing
-
>
isBlockScope
)
;
if
(
enclosing
-
>
staticScope
-
>
as
<
StaticBlockScope
>
(
)
.
needsClone
(
)
)
{
if
(
!
emit1
(
JSOP_FRESHENBLOCKSCOPE
)
)
return
false
;
}
}
if
(
ParseNode
*
update
=
forHead
-
>
pn_kid3
)
{
if
(
!
updateSourceCoordNotes
(
update
-
>
pn_pos
.
begin
)
)
return
false
;
if
(
!
emitTree
(
update
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
uint32_t
lineNum
=
parser
-
>
tokenStream
.
srcCoords
.
lineNum
(
pn
-
>
pn_pos
.
end
)
;
if
(
currentLine
(
)
!
=
lineNum
)
{
if
(
!
newSrcNote2
(
SRC_SETLINE
ptrdiff_t
(
lineNum
)
)
)
return
false
;
current
-
>
currentLine
=
lineNum
;
current
-
>
lastColumn
=
0
;
}
}
ptrdiff_t
tmp3
=
offset
(
)
;
if
(
forHead
-
>
pn_kid2
)
{
MOZ_ASSERT
(
jmp
.
offset
>
=
0
)
;
if
(
!
emitLoopEntry
(
forHead
-
>
pn_kid2
jmp
)
)
return
false
;
if
(
!
emitTree
(
forHead
-
>
pn_kid2
)
)
return
false
;
}
else
if
(
!
forHead
-
>
pn_kid3
)
{
if
(
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
begin
)
)
return
false
;
}
if
(
!
setSrcNoteOffset
(
noteIndex
0
tmp3
-
tmp
)
)
return
false
;
if
(
!
setSrcNoteOffset
(
noteIndex
1
continues
.
offset
-
tmp
)
)
return
false
;
JumpList
beq
;
JumpTarget
brk
{
-
1
}
;
if
(
!
emitBackwardJump
(
forHead
-
>
pn_kid2
?
JSOP_IFNE
:
JSOP_GOTO
top
&
beq
&
brk
)
)
return
false
;
if
(
!
setSrcNoteOffset
(
noteIndex
2
beq
.
offset
-
tmp
)
)
return
false
;
if
(
!
tryNoteList
.
append
(
JSTRY_LOOP
stackDepth
top
.
offset
brk
.
offset
)
)
return
false
;
if
(
!
popStatement
(
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitFor
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_FOR
)
)
;
if
(
pn
-
>
pn_left
-
>
isKind
(
PNK_FORHEAD
)
)
return
emitCStyleFor
(
pn
)
;
if
(
!
updateLineNumberNotes
(
pn
-
>
pn_pos
.
begin
)
)
return
false
;
if
(
pn
-
>
pn_left
-
>
isKind
(
PNK_FORIN
)
)
return
emitForIn
(
pn
)
;
MOZ_ASSERT
(
pn
-
>
pn_left
-
>
isKind
(
PNK_FOROF
)
)
;
return
emitForOf
(
pn
)
;
}
bool
BytecodeEmitter
:
:
emitComprehensionForInOrOfVariables
(
ParseNode
*
pn
bool
*
letBlockScope
)
{
*
letBlockScope
=
pn
-
>
isKind
(
PNK_LEXICALSCOPE
)
;
if
(
*
letBlockScope
)
{
MOZ_ASSERT
(
pn
-
>
isLexical
(
)
)
;
}
else
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_LET
)
)
;
MOZ_ASSERT
(
pn
-
>
pn_count
=
=
1
)
;
emittingForInit
=
true
;
if
(
!
emitVariables
(
pn
InitializeVars
)
)
return
false
;
emittingForInit
=
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitComprehensionForOf
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_COMPREHENSIONFOR
)
)
;
ParseNode
*
forHead
=
pn
-
>
pn_left
;
MOZ_ASSERT
(
forHead
-
>
isKind
(
PNK_FOROF
)
)
;
ParseNode
*
forHeadExpr
=
forHead
-
>
pn_kid3
;
ParseNode
*
forBody
=
pn
-
>
pn_right
;
JumpTarget
top
{
-
1
}
;
ParseNode
*
loopDecl
=
forHead
-
>
pn_kid1
;
bool
letBlockScope
=
false
;
if
(
loopDecl
&
&
!
emitComprehensionForInOrOfVariables
(
loopDecl
&
letBlockScope
)
)
return
false
;
if
(
!
emitTree
(
forHeadExpr
)
)
return
false
;
if
(
!
emitIterator
(
)
)
return
false
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
StmtInfoBCE
letStmt
(
cx
)
;
if
(
letBlockScope
)
{
if
(
!
enterBlockScope
(
&
letStmt
loopDecl
-
>
pn_objbox
JSOP_UNDEFINED
0
)
)
return
false
;
}
LoopStmtInfo
stmtInfo
(
cx
)
;
pushLoopStatement
(
&
stmtInfo
StmtType
:
:
FOR_OF_LOOP
top
)
;
unsigned
noteIndex
;
if
(
!
newSrcNote
(
SRC_FOR_OF
&
noteIndex
)
)
return
false
;
JumpList
jmp
;
if
(
!
emitJump
(
JSOP_GOTO
&
jmp
)
)
return
false
;
if
(
!
emitLoopHead
(
nullptr
&
top
)
)
return
false
;
stmtInfo
.
setTop
(
top
)
;
#
ifdef
DEBUG
int
loopDepth
=
this
-
>
stackDepth
;
#
endif
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
value
JSOP_GETPROP
)
)
return
false
;
if
(
!
emitAssignment
(
forHead
-
>
pn_kid2
JSOP_NOP
nullptr
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
loopDepth
)
;
if
(
!
emitTree
(
forBody
)
)
return
false
;
setContinueHere
(
&
stmtInfo
)
;
if
(
!
emitLoopEntry
(
forHeadExpr
jmp
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitIteratorNext
(
forHead
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
done
JSOP_GETPROP
)
)
return
false
;
JumpList
beq
;
JumpTarget
brk
{
-
1
}
;
if
(
!
emitBackwardJump
(
JSOP_IFEQ
top
&
beq
&
brk
)
)
return
false
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
loopDepth
)
;
if
(
!
setSrcNoteOffset
(
noteIndex
0
beq
.
offset
-
jmp
.
offset
)
)
return
false
;
if
(
!
popStatement
(
)
)
return
false
;
if
(
!
tryNoteList
.
append
(
JSTRY_FOR_OF
stackDepth
top
.
offset
brk
.
offset
)
)
return
false
;
if
(
letBlockScope
)
{
if
(
!
leaveNestedScope
(
&
letStmt
)
)
return
false
;
}
return
emitUint16Operand
(
JSOP_POPN
2
)
;
}
bool
BytecodeEmitter
:
:
emitComprehensionForIn
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_COMPREHENSIONFOR
)
)
;
JumpTarget
top
{
-
1
}
;
ParseNode
*
forHead
=
pn
-
>
pn_left
;
MOZ_ASSERT
(
forHead
-
>
isKind
(
PNK_FORIN
)
)
;
ParseNode
*
forBody
=
pn
-
>
pn_right
;
ParseNode
*
loopDecl
=
forHead
-
>
pn_kid1
;
bool
letBlockScope
=
false
;
if
(
loopDecl
&
&
!
emitComprehensionForInOrOfVariables
(
loopDecl
&
letBlockScope
)
)
return
false
;
if
(
!
emitTree
(
forHead
-
>
pn_kid3
)
)
return
false
;
MOZ_ASSERT
(
pn
-
>
isOp
(
JSOP_ITER
)
)
;
if
(
!
emit2
(
JSOP_ITER
(
uint8_t
)
pn
-
>
pn_iflags
)
)
return
false
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
StmtInfoBCE
letStmt
(
cx
)
;
if
(
letBlockScope
)
{
if
(
!
enterBlockScope
(
&
letStmt
loopDecl
-
>
pn_objbox
JSOP_UNDEFINED
0
)
)
return
false
;
}
LoopStmtInfo
stmtInfo
(
cx
)
;
pushLoopStatement
(
&
stmtInfo
StmtType
:
:
FOR_IN_LOOP
top
)
;
unsigned
noteIndex
;
if
(
!
newSrcNote
(
SRC_FOR_IN
&
noteIndex
)
)
return
false
;
JumpList
jmp
;
if
(
!
emitJump
(
JSOP_GOTO
&
jmp
)
)
return
false
;
if
(
!
emitLoopHead
(
nullptr
&
top
)
)
return
false
;
stmtInfo
.
setTop
(
top
)
;
#
ifdef
DEBUG
int
loopDepth
=
this
-
>
stackDepth
;
#
endif
if
(
!
emitAssignment
(
forHead
-
>
pn_kid2
JSOP_NOP
nullptr
)
)
return
false
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
loopDepth
)
;
if
(
!
emitTree
(
forBody
)
)
return
false
;
setContinueHere
(
&
stmtInfo
)
;
if
(
!
emitLoopEntry
(
nullptr
jmp
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
if
(
!
emit1
(
JSOP_MOREITER
)
)
return
false
;
if
(
!
emit1
(
JSOP_ISNOITER
)
)
return
false
;
JumpList
beq
;
JumpTarget
brk
{
-
1
}
;
if
(
!
emitBackwardJump
(
JSOP_IFEQ
top
&
beq
&
brk
)
)
return
false
;
if
(
!
setSrcNoteOffset
(
noteIndex
0
beq
.
offset
-
jmp
.
offset
)
)
return
false
;
if
(
!
popStatement
(
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
JumpTarget
endIter
{
offset
(
)
}
;
if
(
!
tryNoteList
.
append
(
JSTRY_FOR_IN
this
-
>
stackDepth
top
.
offset
endIter
.
offset
)
)
return
false
;
if
(
!
emit1
(
JSOP_ENDITER
)
)
return
false
;
if
(
letBlockScope
)
{
if
(
!
leaveNestedScope
(
&
letStmt
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitComprehensionFor
(
ParseNode
*
compFor
)
{
MOZ_ASSERT
(
compFor
-
>
pn_left
-
>
isKind
(
PNK_FORIN
)
|
|
compFor
-
>
pn_left
-
>
isKind
(
PNK_FOROF
)
)
;
if
(
!
updateLineNumberNotes
(
compFor
-
>
pn_pos
.
begin
)
)
return
false
;
return
compFor
-
>
pn_left
-
>
isKind
(
PNK_FORIN
)
?
emitComprehensionForIn
(
compFor
)
:
emitComprehensionForOf
(
compFor
)
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitFunction
(
ParseNode
*
pn
bool
needsProto
)
{
ParseNode
*
assignmentForAnnexB
=
nullptr
;
if
(
pn
-
>
isKind
(
PNK_ANNEXB_FUNCTION
)
)
{
assignmentForAnnexB
=
pn
-
>
pn_right
;
pn
=
pn
-
>
pn_left
;
}
FunctionBox
*
funbox
=
pn
-
>
pn_funbox
;
RootedFunction
fun
(
cx
funbox
-
>
function
(
)
)
;
MOZ_ASSERT_IF
(
fun
-
>
isInterpretedLazy
(
)
fun
-
>
lazyScript
(
)
)
;
if
(
funbox
-
>
wasEmitted
)
{
if
(
assignmentForAnnexB
)
{
if
(
assignmentForAnnexB
-
>
isKind
(
PNK_VAR
)
)
{
if
(
!
emitVariables
(
assignmentForAnnexB
AnnexB
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
assignmentForAnnexB
-
>
isKind
(
PNK_ASSIGN
)
)
;
if
(
!
emitTree
(
assignmentForAnnexB
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
}
MOZ_ASSERT_IF
(
fun
-
>
hasScript
(
)
fun
-
>
nonLazyScript
(
)
)
;
MOZ_ASSERT
(
pn
-
>
functionIsHoisted
(
)
)
;
return
true
;
}
funbox
-
>
wasEmitted
=
true
;
if
(
fun
-
>
isInterpreted
(
)
)
{
bool
singleton
=
checkRunOnceContext
(
)
;
if
(
!
JSFunction
:
:
setTypeForScriptedFunction
(
cx
fun
singleton
)
)
return
false
;
SharedContext
*
outersc
=
sc
;
if
(
fun
-
>
isInterpretedLazy
(
)
)
{
ScriptSourceObject
*
source
=
&
script
-
>
sourceObject
(
)
-
>
as
<
ScriptSourceObject
>
(
)
;
JSObject
*
scope
=
innermostStaticScope
(
)
;
fun
-
>
lazyScript
(
)
-
>
setEnclosingScopeAndSource
(
scope
source
)
;
if
(
emittingRunOnceLambda
)
fun
-
>
lazyScript
(
)
-
>
setTreatAsRunOnce
(
)
;
}
else
{
if
(
outersc
-
>
isFunctionBox
(
)
&
&
outersc
-
>
asFunctionBox
(
)
-
>
mightAliasLocals
(
)
)
funbox
-
>
setMightAliasLocals
(
)
;
MOZ_ASSERT_IF
(
outersc
-
>
strict
(
)
funbox
-
>
strictScript
)
;
Rooted
<
JSScript
*
>
parent
(
cx
script
)
;
MOZ_ASSERT
(
parent
-
>
getVersion
(
)
=
=
parser
-
>
options
(
)
.
version
)
;
MOZ_ASSERT
(
parent
-
>
mutedErrors
(
)
=
=
parser
-
>
options
(
)
.
mutedErrors
(
)
)
;
const
TransitiveCompileOptions
&
transitiveOptions
=
parser
-
>
options
(
)
;
CompileOptions
options
(
cx
transitiveOptions
)
;
Rooted
<
JSObject
*
>
enclosingScope
(
cx
innermostStaticScope
(
)
)
;
Rooted
<
JSObject
*
>
sourceObject
(
cx
script
-
>
sourceObject
(
)
)
;
Rooted
<
JSScript
*
>
script
(
cx
JSScript
:
:
Create
(
cx
enclosingScope
false
options
sourceObject
funbox
-
>
bufStart
funbox
-
>
bufEnd
)
)
;
if
(
!
script
)
return
false
;
script
-
>
bindings
=
funbox
-
>
bindings
;
BytecodeEmitter
bce2
(
this
parser
funbox
script
nullptr
insideEval
evalCaller
insideNonGlobalEval
pn
-
>
pn_pos
emitterMode
)
;
if
(
!
bce2
.
init
(
)
)
return
false
;
if
(
!
bce2
.
emitFunctionScript
(
pn
-
>
pn_body
)
)
return
false
;
if
(
funbox
-
>
isLikelyConstructorWrapper
(
)
)
script
-
>
setLikelyConstructorWrapper
(
)
;
}
if
(
outersc
-
>
isFunctionBox
(
)
)
outersc
-
>
asFunctionBox
(
)
-
>
function
(
)
-
>
nonLazyScript
(
)
-
>
setHasInnerFunctions
(
true
)
;
}
else
{
MOZ_ASSERT
(
IsAsmJSModule
(
fun
)
)
;
}
unsigned
index
=
objectList
.
add
(
pn
-
>
pn_funbox
)
;
if
(
!
pn
-
>
functionIsHoisted
(
)
)
{
MOZ_ASSERT
(
fun
-
>
isArrow
(
)
=
=
(
pn
-
>
getOp
(
)
=
=
JSOP_LAMBDA_ARROW
)
)
;
if
(
fun
-
>
isArrow
(
)
)
{
if
(
sc
-
>
allowNewTarget
(
)
)
{
if
(
!
emit1
(
JSOP_NEWTARGET
)
)
return
false
;
}
else
{
if
(
!
emit1
(
JSOP_NULL
)
)
return
false
;
}
}
if
(
needsProto
)
{
MOZ_ASSERT
(
pn
-
>
getOp
(
)
=
=
JSOP_LAMBDA
)
;
pn
-
>
setOp
(
JSOP_FUNWITHPROTO
)
;
}
return
emitIndex32
(
pn
-
>
getOp
(
)
index
)
;
}
MOZ_ASSERT
(
!
needsProto
)
;
bool
blockScopedFunction
=
!
atBodyLevel
(
)
;
if
(
!
sc
-
>
strict
(
)
&
&
blockScopedFunction
)
{
StmtInfoBCE
*
stmt
=
innermostStmt
(
)
;
while
(
stmt
&
&
stmt
-
>
type
=
=
StmtType
:
:
LABEL
)
stmt
=
stmt
-
>
enclosing
;
blockScopedFunction
=
!
atBodyLevel
(
stmt
)
;
}
if
(
blockScopedFunction
)
{
if
(
!
emitIndexOp
(
JSOP_LAMBDA
index
)
)
return
false
;
MOZ_ASSERT
(
pn
-
>
getOp
(
)
=
=
JSOP_INITLEXICAL
)
;
if
(
!
emitVarOp
(
pn
pn
-
>
getOp
(
)
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
else
if
(
sc
-
>
isGlobalContext
(
)
)
{
MOZ_ASSERT
(
pn
-
>
pn_scopecoord
.
isFree
(
)
)
;
MOZ_ASSERT
(
pn
-
>
getOp
(
)
=
=
JSOP_NOP
)
;
switchToPrologue
(
)
;
if
(
!
emitIndex32
(
JSOP_DEFFUN
index
)
)
return
false
;
if
(
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
begin
)
)
return
false
;
switchToMain
(
)
;
}
else
if
(
sc
-
>
isFunctionBox
(
)
)
{
#
ifdef
DEBUG
BindingIter
bi
(
script
)
;
while
(
bi
-
>
name
(
)
!
=
fun
-
>
name
(
)
)
bi
+
+
;
MOZ_ASSERT
(
bi
-
>
kind
(
)
=
=
Binding
:
:
VARIABLE
|
|
bi
-
>
kind
(
)
=
=
Binding
:
:
CONSTANT
|
|
bi
-
>
kind
(
)
=
=
Binding
:
:
ARGUMENT
)
;
MOZ_ASSERT
(
bi
.
argOrLocalIndex
(
)
<
JS_BIT
(
20
)
)
;
#
endif
if
(
!
emitIndexOp
(
JSOP_LAMBDA
index
)
)
return
false
;
MOZ_ASSERT
(
pn
-
>
getOp
(
)
=
=
JSOP_GETLOCAL
|
|
pn
-
>
getOp
(
)
=
=
JSOP_GETARG
)
;
JSOp
setOp
=
pn
-
>
getOp
(
)
=
=
JSOP_GETLOCAL
?
JSOP_SETLOCAL
:
JSOP_SETARG
;
if
(
!
emitVarOp
(
pn
setOp
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
else
{
RootedModuleObject
module
(
cx
sc
-
>
asModuleBox
(
)
-
>
module
(
)
)
;
RootedAtom
name
(
cx
fun
-
>
name
(
)
)
;
if
(
!
module
-
>
noteFunctionDeclaration
(
cx
name
fun
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDo
(
ParseNode
*
pn
)
{
unsigned
noteIndex
;
if
(
!
newSrcNote
(
SRC_WHILE
&
noteIndex
)
)
return
false
;
if
(
!
emit1
(
JSOP_NOP
)
)
return
false
;
unsigned
noteIndex2
;
if
(
!
newSrcNote
(
SRC_WHILE
&
noteIndex2
)
)
return
false
;
JumpTarget
top
;
if
(
!
emitLoopHead
(
pn
-
>
pn_left
&
top
)
)
return
false
;
LoopStmtInfo
stmtInfo
(
cx
)
;
pushLoopStatement
(
&
stmtInfo
StmtType
:
:
DO_LOOP
top
)
;
JumpList
empty
;
if
(
!
emitLoopEntry
(
nullptr
empty
)
)
return
false
;
if
(
!
emitTree
(
pn
-
>
pn_left
)
)
return
false
;
JumpTarget
continues
;
if
(
!
emitJumpTarget
(
&
continues
)
)
return
false
;
setContinueTarget
(
&
stmtInfo
continues
)
;
if
(
!
emitTree
(
pn
-
>
pn_right
)
)
return
false
;
JumpList
beq
;
JumpTarget
brk
{
-
1
}
;
if
(
!
emitBackwardJump
(
JSOP_IFNE
top
&
beq
&
brk
)
)
return
false
;
if
(
!
tryNoteList
.
append
(
JSTRY_LOOP
stackDepth
top
.
offset
brk
.
offset
)
)
return
false
;
if
(
!
setSrcNoteOffset
(
noteIndex2
0
beq
.
offset
-
top
.
offset
)
)
return
false
;
if
(
!
setSrcNoteOffset
(
noteIndex
0
1
+
(
continues
.
offset
-
top
.
offset
)
)
)
return
false
;
if
(
!
popStatement
(
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitWhile
(
ParseNode
*
pn
)
{
if
(
parser
-
>
tokenStream
.
srcCoords
.
lineNum
(
pn
-
>
pn_pos
.
begin
)
=
=
parser
-
>
tokenStream
.
srcCoords
.
lineNum
(
pn
-
>
pn_pos
.
end
)
&
&
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
begin
)
)
return
false
;
LoopStmtInfo
stmtInfo
(
cx
)
;
JumpTarget
top
;
if
(
!
emitJumpTarget
(
&
top
)
)
return
false
;
pushLoopStatement
(
&
stmtInfo
StmtType
:
:
WHILE_LOOP
top
)
;
unsigned
noteIndex
;
if
(
!
newSrcNote
(
SRC_WHILE
&
noteIndex
)
)
return
false
;
JumpList
jmp
;
if
(
!
emitJump
(
JSOP_GOTO
&
jmp
)
)
return
false
;
if
(
!
emitLoopHead
(
pn
-
>
pn_right
&
top
)
)
return
false
;
if
(
!
emitTree
(
pn
-
>
pn_right
)
)
return
false
;
if
(
!
emitLoopEntry
(
pn
-
>
pn_left
jmp
)
)
return
false
;
if
(
!
emitTree
(
pn
-
>
pn_left
)
)
return
false
;
JumpList
beq
;
JumpTarget
brk
{
-
1
}
;
if
(
!
emitBackwardJump
(
JSOP_IFNE
top
&
beq
&
brk
)
)
return
false
;
if
(
!
tryNoteList
.
append
(
JSTRY_LOOP
stackDepth
top
.
offset
brk
.
offset
)
)
return
false
;
if
(
!
setSrcNoteOffset
(
noteIndex
0
beq
.
offset
-
jmp
.
offset
)
)
return
false
;
if
(
!
popStatement
(
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitBreak
(
PropertyName
*
label
)
{
StmtInfoBCE
*
stmt
=
innermostStmt
(
)
;
SrcNoteType
noteType
;
if
(
label
)
{
while
(
stmt
-
>
type
!
=
StmtType
:
:
LABEL
|
|
stmt
-
>
label
!
=
label
)
stmt
=
stmt
-
>
enclosing
;
noteType
=
SRC_BREAK2LABEL
;
}
else
{
while
(
!
stmt
-
>
isLoop
(
)
&
&
stmt
-
>
type
!
=
StmtType
:
:
SWITCH
)
stmt
=
stmt
-
>
enclosing
;
noteType
=
(
stmt
-
>
type
=
=
StmtType
:
:
SWITCH
)
?
SRC_SWITCHBREAK
:
SRC_BREAK
;
}
return
emitGoto
(
stmt
&
stmt
-
>
breaks
noteType
)
;
}
bool
BytecodeEmitter
:
:
emitContinue
(
PropertyName
*
label
)
{
StmtInfoBCE
*
stmt
=
innermostStmt
(
)
;
if
(
label
)
{
StmtInfoBCE
*
loop
=
nullptr
;
while
(
stmt
-
>
type
!
=
StmtType
:
:
LABEL
|
|
stmt
-
>
label
!
=
label
)
{
if
(
stmt
-
>
isLoop
(
)
)
loop
=
stmt
;
stmt
=
stmt
-
>
enclosing
;
}
stmt
=
loop
;
}
else
{
while
(
!
stmt
-
>
isLoop
(
)
)
stmt
=
stmt
-
>
enclosing
;
}
return
emitGoto
(
stmt
&
stmt
-
>
continues
SRC_CONTINUE
)
;
}
bool
BytecodeEmitter
:
:
emitGetFunctionThis
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
sc
-
>
thisBinding
(
)
=
=
ThisBinding
:
:
Function
)
;
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_NAME
)
)
;
MOZ_ASSERT
(
pn
-
>
name
(
)
=
=
cx
-
>
names
(
)
.
dotThis
)
;
if
(
!
emitTree
(
pn
)
)
return
false
;
if
(
sc
-
>
needsThisTDZChecks
(
)
&
&
!
emit1
(
JSOP_CHECKTHIS
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitGetThisForSuperBase
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_SUPERBASE
)
)
;
return
emitGetFunctionThis
(
pn
-
>
pn_kid
)
;
}
bool
BytecodeEmitter
:
:
emitThisLiteral
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_THIS
)
)
;
if
(
ParseNode
*
thisName
=
pn
-
>
pn_kid
)
return
emitGetFunctionThis
(
thisName
)
;
if
(
sc
-
>
thisBinding
(
)
=
=
ThisBinding
:
:
Module
)
return
emit1
(
JSOP_UNDEFINED
)
;
MOZ_ASSERT
(
sc
-
>
thisBinding
(
)
=
=
ThisBinding
:
:
Global
)
;
return
emit1
(
JSOP_GLOBALTHIS
)
;
}
bool
BytecodeEmitter
:
:
emitLoadFromEnclosingFunctionScope
(
BindingIter
&
bi
)
{
if
(
script
-
>
bindingIsAliased
(
bi
)
)
{
ScopeCoordinate
sc
;
sc
.
setHops
(
computeHopsToEnclosingFunction
(
)
)
;
sc
.
setSlot
(
0
)
;
MOZ_ALWAYS_TRUE
(
lookupAliasedNameSlot
(
bi
-
>
name
(
)
&
sc
)
)
;
return
emitAliasedVarOp
(
JSOP_GETALIASEDVAR
sc
DontCheckLexical
)
;
}
return
emitUnaliasedVarOp
(
JSOP_GETLOCAL
bi
.
localIndex
(
)
DontCheckLexical
)
;
}
bool
BytecodeEmitter
:
:
emitStoreToEnclosingFunctionScope
(
BindingIter
&
bi
)
{
if
(
script
-
>
bindingIsAliased
(
bi
)
)
{
ScopeCoordinate
sc
;
sc
.
setHops
(
computeHopsToEnclosingFunction
(
)
)
;
sc
.
setSlot
(
0
)
;
MOZ_ALWAYS_TRUE
(
lookupAliasedNameSlot
(
bi
-
>
name
(
)
&
sc
)
)
;
return
emitAliasedVarOp
(
JSOP_SETALIASEDVAR
sc
DontCheckLexical
)
;
}
return
emitUnaliasedVarOp
(
JSOP_SETLOCAL
bi
.
localIndex
(
)
DontCheckLexical
)
;
}
bool
BytecodeEmitter
:
:
emitReturn
(
ParseNode
*
pn
)
{
if
(
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
begin
)
)
return
false
;
if
(
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
isStarGenerator
(
)
)
{
if
(
!
emitPrepareIteratorResult
(
)
)
return
false
;
}
if
(
ParseNode
*
pn2
=
pn
-
>
pn_kid
)
{
if
(
!
emitTree
(
pn2
)
)
return
false
;
}
else
{
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
}
if
(
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
isStarGenerator
(
)
)
{
if
(
!
emitFinishIteratorResult
(
true
)
)
return
false
;
}
MOZ_ASSERT
(
functionBodyEndPosSet
)
;
if
(
!
updateSourceCoordNotes
(
functionBodyEndPos
)
)
return
false
;
ptrdiff_t
top
=
offset
(
)
;
bool
isGenerator
=
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
isGenerator
(
)
;
bool
isDerivedClassConstructor
=
sc
-
>
isFunctionBox
(
)
&
&
sc
-
>
asFunctionBox
(
)
-
>
isDerivedClassConstructor
(
)
;
if
(
!
emit1
(
(
isGenerator
|
|
isDerivedClassConstructor
)
?
JSOP_SETRVAL
:
JSOP_RETURN
)
)
return
false
;
if
(
isDerivedClassConstructor
)
{
BindingIter
bi
=
Bindings
:
:
thisBinding
(
cx
script
)
;
if
(
!
emitLoadFromEnclosingFunctionScope
(
bi
)
)
return
false
;
if
(
!
emit1
(
JSOP_CHECKRETURN
)
)
return
false
;
}
NonLocalExitScope
nle
(
this
)
;
if
(
!
nle
.
prepareForNonLocalJump
(
nullptr
)
)
return
false
;
if
(
isGenerator
)
{
ScopeCoordinate
sc
;
sc
.
setHops
(
0
)
;
MOZ_ALWAYS_TRUE
(
lookupAliasedNameSlot
(
cx
-
>
names
(
)
.
dotGenerator
&
sc
)
)
;
if
(
!
emitAliasedVarOp
(
JSOP_GETALIASEDVAR
sc
DontCheckLexical
)
)
return
false
;
if
(
!
emitYieldOp
(
JSOP_FINALYIELDRVAL
)
)
return
false
;
}
else
if
(
isDerivedClassConstructor
)
{
MOZ_ASSERT
(
code
(
)
[
top
]
=
=
JSOP_SETRVAL
)
;
if
(
!
emit1
(
JSOP_RETRVAL
)
)
return
false
;
}
else
if
(
top
+
static_cast
<
ptrdiff_t
>
(
JSOP_RETURN_LENGTH
)
!
=
offset
(
)
)
{
code
(
)
[
top
]
=
JSOP_SETRVAL
;
if
(
!
emit1
(
JSOP_RETRVAL
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitYield
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
sc
-
>
isFunctionBox
(
)
)
;
if
(
pn
-
>
getOp
(
)
=
=
JSOP_YIELD
)
{
if
(
sc
-
>
asFunctionBox
(
)
-
>
isStarGenerator
(
)
)
{
if
(
!
emitPrepareIteratorResult
(
)
)
return
false
;
}
if
(
pn
-
>
pn_left
)
{
if
(
!
emitTree
(
pn
-
>
pn_left
)
)
return
false
;
}
else
{
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
}
if
(
sc
-
>
asFunctionBox
(
)
-
>
isStarGenerator
(
)
)
{
if
(
!
emitFinishIteratorResult
(
false
)
)
return
false
;
}
}
else
{
MOZ_ASSERT
(
pn
-
>
getOp
(
)
=
=
JSOP_INITIALYIELD
)
;
}
if
(
!
emitTree
(
pn
-
>
pn_right
)
)
return
false
;
if
(
!
emitYieldOp
(
pn
-
>
getOp
(
)
)
)
return
false
;
if
(
pn
-
>
getOp
(
)
=
=
JSOP_INITIALYIELD
&
&
!
emit1
(
JSOP_POP
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitYieldStar
(
ParseNode
*
iter
ParseNode
*
gen
)
{
MOZ_ASSERT
(
sc
-
>
isFunctionBox
(
)
)
;
MOZ_ASSERT
(
sc
-
>
asFunctionBox
(
)
-
>
isStarGenerator
(
)
)
;
if
(
!
emitTree
(
iter
)
)
return
false
;
if
(
!
emitIterator
(
)
)
return
false
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
int
depth
=
stackDepth
;
MOZ_ASSERT
(
depth
>
=
2
)
;
JumpList
send
;
if
(
!
emitJump
(
JSOP_GOTO
&
send
)
)
return
false
;
StmtInfoBCE
stmtInfo
(
cx
)
;
JumpTarget
top
{
-
1
}
;
pushStatement
(
&
stmtInfo
StmtType
:
:
TRY
top
)
;
unsigned
noteIndex
;
if
(
!
newSrcNote
(
SRC_TRY
&
noteIndex
)
)
return
false
;
JumpTarget
tryStart
{
offset
(
)
}
;
if
(
!
emit1
(
JSOP_TRY
)
)
return
false
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
depth
)
;
if
(
!
emitTree
(
gen
)
)
return
false
;
if
(
!
emitYieldOp
(
JSOP_YIELD
)
)
return
false
;
if
(
!
setSrcNoteOffset
(
noteIndex
0
offset
(
)
-
tryStart
.
offset
)
)
return
false
;
if
(
!
emitJump
(
JSOP_GOTO
&
send
)
)
return
false
;
JumpTarget
tryEnd
;
if
(
!
emitJumpTarget
(
&
tryEnd
)
)
return
false
;
stackDepth
=
uint32_t
(
depth
)
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
if
(
!
emit1
(
JSOP_EXCEPTION
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
throw_
JSOP_STRING
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
if
(
!
emit1
(
JSOP_IN
)
)
return
false
;
JumpList
checkThrow
;
if
(
!
emitJump
(
JSOP_IFNE
&
checkThrow
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
if
(
!
emit1
(
JSOP_THROW
)
)
return
false
;
if
(
!
emitJumpTargetAndPatch
(
checkThrow
)
)
return
false
;
stackDepth
=
uint32_t
(
depth
)
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
throw_
JSOP_CALLPROP
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
if
(
!
emit2
(
JSOP_PICK
3
)
)
return
false
;
if
(
!
emitCall
(
JSOP_CALL
1
iter
)
)
return
false
;
checkTypeSet
(
JSOP_CALL
)
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
depth
)
;
JumpList
checkResult
;
if
(
!
emitJump
(
JSOP_GOTO
&
checkResult
)
)
return
false
;
if
(
!
popStatement
(
)
)
return
false
;
if
(
!
emit1
(
JSOP_NOP
)
)
return
false
;
if
(
!
tryNoteList
.
append
(
JSTRY_CATCH
depth
tryStart
.
offset
+
JSOP_TRY_LENGTH
tryEnd
.
offset
)
)
return
false
;
if
(
!
emitJumpTargetAndPatch
(
send
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
next
JSOP_CALLPROP
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
if
(
!
emit2
(
JSOP_PICK
3
)
)
return
false
;
if
(
!
emitCall
(
JSOP_CALL
1
iter
)
)
return
false
;
checkTypeSet
(
JSOP_CALL
)
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
depth
)
;
if
(
!
emitJumpTargetAndPatch
(
checkResult
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
done
JSOP_GETPROP
)
)
return
false
;
JumpList
beq
;
JumpTarget
brk
{
-
1
}
;
if
(
!
emitBackwardJump
(
JSOP_IFEQ
tryStart
&
beq
&
brk
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
value
JSOP_GETPROP
)
)
return
false
;
MOZ_ASSERT
(
this
-
>
stackDepth
=
=
depth
-
1
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitStatementList
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_LIST
)
)
;
for
(
ParseNode
*
pn2
=
pn
-
>
pn_head
;
pn2
;
pn2
=
pn2
-
>
pn_next
)
{
if
(
!
emitTree
(
pn2
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitStatement
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_SEMI
)
)
;
ParseNode
*
pn2
=
pn
-
>
pn_kid
;
if
(
!
pn2
)
return
true
;
if
(
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
begin
)
)
return
false
;
bool
wantval
=
false
;
bool
useful
=
false
;
if
(
sc
-
>
isFunctionBox
(
)
)
MOZ_ASSERT
(
!
script
-
>
noScriptRval
(
)
)
;
else
useful
=
wantval
=
!
script
-
>
noScriptRval
(
)
;
if
(
!
useful
)
{
if
(
!
checkSideEffects
(
pn2
&
useful
)
)
return
false
;
if
(
innermostStmt
(
)
&
&
innermostStmt
(
)
-
>
type
=
=
StmtType
:
:
LABEL
&
&
innermostStmt
(
)
-
>
update
.
offset
>
=
offset
(
)
)
{
useful
=
true
;
}
}
if
(
useful
)
{
JSOp
op
=
wantval
?
JSOP_SETRVAL
:
JSOP_POP
;
MOZ_ASSERT_IF
(
pn2
-
>
isKind
(
PNK_ASSIGN
)
pn2
-
>
isOp
(
JSOP_NOP
)
)
;
if
(
!
emitTree
(
pn2
)
)
return
false
;
if
(
!
emit1
(
op
)
)
return
false
;
}
else
if
(
pn
-
>
isDirectivePrologueMember
(
)
)
{
}
else
{
if
(
JSAtom
*
atom
=
pn
-
>
isStringExprStatement
(
)
)
{
const
char
*
directive
=
nullptr
;
if
(
atom
=
=
cx
-
>
names
(
)
.
useStrict
)
{
if
(
!
sc
-
>
strictScript
)
directive
=
js_useStrict_str
;
}
else
if
(
atom
=
=
cx
-
>
names
(
)
.
useAsm
)
{
if
(
sc
-
>
isFunctionBox
(
)
)
{
if
(
IsAsmJSModule
(
sc
-
>
asFunctionBox
(
)
-
>
function
(
)
)
)
directive
=
js_useAsm_str
;
}
}
if
(
directive
)
{
if
(
!
reportStrictWarning
(
pn2
JSMSG_CONTRARY_NONDIRECTIVE
directive
)
)
return
false
;
}
}
else
{
current
-
>
currentLine
=
parser
-
>
tokenStream
.
srcCoords
.
lineNum
(
pn2
-
>
pn_pos
.
begin
)
;
current
-
>
lastColumn
=
0
;
if
(
!
reportStrictWarning
(
pn2
JSMSG_USELESS_EXPR
)
)
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitDeleteName
(
ParseNode
*
node
)
{
MOZ_ASSERT
(
node
-
>
isKind
(
PNK_DELETENAME
)
)
;
MOZ_ASSERT
(
node
-
>
isArity
(
PN_UNARY
)
)
;
ParseNode
*
nameExpr
=
node
-
>
pn_kid
;
MOZ_ASSERT
(
nameExpr
-
>
isKind
(
PNK_NAME
)
)
;
if
(
!
bindNameToSlot
(
nameExpr
)
)
return
false
;
MOZ_ASSERT
(
nameExpr
-
>
isOp
(
JSOP_DELNAME
)
)
;
return
emitAtomOp
(
nameExpr
JSOP_DELNAME
)
;
}
bool
BytecodeEmitter
:
:
emitDeleteProperty
(
ParseNode
*
node
)
{
MOZ_ASSERT
(
node
-
>
isKind
(
PNK_DELETEPROP
)
)
;
MOZ_ASSERT
(
node
-
>
isArity
(
PN_UNARY
)
)
;
ParseNode
*
propExpr
=
node
-
>
pn_kid
;
MOZ_ASSERT
(
propExpr
-
>
isKind
(
PNK_DOT
)
)
;
if
(
propExpr
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
{
if
(
!
emit1
(
JSOP_SUPERBASE
)
)
return
false
;
return
emitUint16Operand
(
JSOP_THROWMSG
JSMSG_CANT_DELETE_SUPER
)
;
}
JSOp
delOp
=
sc
-
>
strict
(
)
?
JSOP_STRICTDELPROP
:
JSOP_DELPROP
;
return
emitPropOp
(
propExpr
delOp
)
;
}
bool
BytecodeEmitter
:
:
emitDeleteElement
(
ParseNode
*
node
)
{
MOZ_ASSERT
(
node
-
>
isKind
(
PNK_DELETEELEM
)
)
;
MOZ_ASSERT
(
node
-
>
isArity
(
PN_UNARY
)
)
;
ParseNode
*
elemExpr
=
node
-
>
pn_kid
;
MOZ_ASSERT
(
elemExpr
-
>
isKind
(
PNK_ELEM
)
)
;
if
(
elemExpr
-
>
as
<
PropertyByValue
>
(
)
.
isSuper
(
)
)
{
if
(
!
emitTree
(
elemExpr
-
>
pn_right
)
)
return
false
;
if
(
!
emit1
(
JSOP_SUPERBASE
)
)
return
false
;
if
(
!
emitUint16Operand
(
JSOP_THROWMSG
JSMSG_CANT_DELETE_SUPER
)
)
return
false
;
return
emit1
(
JSOP_POP
)
;
}
JSOp
delOp
=
sc
-
>
strict
(
)
?
JSOP_STRICTDELELEM
:
JSOP_DELELEM
;
return
emitElemOp
(
elemExpr
delOp
)
;
}
bool
BytecodeEmitter
:
:
emitDeleteExpression
(
ParseNode
*
node
)
{
MOZ_ASSERT
(
node
-
>
isKind
(
PNK_DELETEEXPR
)
)
;
MOZ_ASSERT
(
node
-
>
isArity
(
PN_UNARY
)
)
;
ParseNode
*
expression
=
node
-
>
pn_kid
;
bool
useful
=
false
;
if
(
!
checkSideEffects
(
expression
&
useful
)
)
return
false
;
if
(
useful
)
{
MOZ_ASSERT_IF
(
expression
-
>
isKind
(
PNK_CALL
)
!
(
expression
-
>
pn_xflags
&
PNX_SETCALL
)
)
;
if
(
!
emitTree
(
expression
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
return
emit1
(
JSOP_TRUE
)
;
}
bool
BytecodeEmitter
:
:
emitDebugOnlyCheckSelfHosted
(
)
{
#
ifdef
DEBUG
if
(
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
)
{
if
(
!
emit1
(
JSOP_DEBUGCHECKSELFHOSTED
)
)
return
false
;
}
#
endif
return
true
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedCallFunction
(
ParseNode
*
pn
)
{
ParseNode
*
pn2
=
pn
-
>
pn_head
;
const
char
*
errorName
=
pn2
-
>
name
(
)
=
=
cx
-
>
names
(
)
.
callFunction
?
"
callFunction
"
:
"
callContentFunction
"
;
if
(
pn
-
>
pn_count
<
3
)
{
reportError
(
pn
JSMSG_MORE_ARGS_NEEDED
errorName
"
2
"
"
s
"
)
;
return
false
;
}
JSOp
callOp
=
pn
-
>
getOp
(
)
;
if
(
callOp
!
=
JSOP_CALL
)
{
reportError
(
pn
JSMSG_NOT_CONSTRUCTOR
errorName
)
;
return
false
;
}
ParseNode
*
funNode
=
pn2
-
>
pn_next
;
if
(
funNode
-
>
getKind
(
)
=
=
PNK_NAME
&
&
funNode
-
>
name
(
)
=
=
cx
-
>
names
(
)
.
std_Function_apply
)
callOp
=
JSOP_FUNAPPLY
;
if
(
!
emitTree
(
funNode
)
)
return
false
;
if
(
pn2
-
>
name
(
)
!
=
cx
-
>
names
(
)
.
callContentFunction
)
{
if
(
!
emitDebugOnlyCheckSelfHosted
(
)
)
return
false
;
}
ParseNode
*
thisArg
=
funNode
-
>
pn_next
;
if
(
!
emitTree
(
thisArg
)
)
return
false
;
bool
oldEmittingForInit
=
emittingForInit
;
emittingForInit
=
false
;
for
(
ParseNode
*
argpn
=
thisArg
-
>
pn_next
;
argpn
;
argpn
=
argpn
-
>
pn_next
)
{
if
(
!
emitTree
(
argpn
)
)
return
false
;
}
emittingForInit
=
oldEmittingForInit
;
uint32_t
argc
=
pn
-
>
pn_count
-
3
;
if
(
!
emitCall
(
callOp
argc
)
)
return
false
;
checkTypeSet
(
callOp
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedResumeGenerator
(
ParseNode
*
pn
)
{
if
(
pn
-
>
pn_count
!
=
4
)
{
reportError
(
pn
JSMSG_MORE_ARGS_NEEDED
"
resumeGenerator
"
"
1
"
"
s
"
)
;
return
false
;
}
ParseNode
*
funNode
=
pn
-
>
pn_head
;
ParseNode
*
genNode
=
funNode
-
>
pn_next
;
if
(
!
emitTree
(
genNode
)
)
return
false
;
ParseNode
*
valNode
=
genNode
-
>
pn_next
;
if
(
!
emitTree
(
valNode
)
)
return
false
;
ParseNode
*
kindNode
=
valNode
-
>
pn_next
;
MOZ_ASSERT
(
kindNode
-
>
isKind
(
PNK_STRING
)
)
;
uint16_t
operand
=
GeneratorObject
:
:
getResumeKind
(
cx
kindNode
-
>
pn_atom
)
;
MOZ_ASSERT
(
!
kindNode
-
>
pn_next
)
;
if
(
!
emitCall
(
JSOP_RESUME
operand
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedForceInterpreter
(
ParseNode
*
pn
)
{
if
(
!
emit1
(
JSOP_FORCEINTERPRETER
)
)
return
false
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitSelfHostedAllowContentSpread
(
ParseNode
*
pn
)
{
if
(
pn
-
>
pn_count
!
=
2
)
{
reportError
(
pn
JSMSG_MORE_ARGS_NEEDED
"
allowContentSpread
"
"
1
"
"
"
)
;
return
false
;
}
return
emitTree
(
pn
-
>
pn_head
-
>
pn_next
)
;
}
bool
BytecodeEmitter
:
:
isRestParameter
(
ParseNode
*
pn
bool
*
result
)
{
if
(
!
sc
-
>
isFunctionBox
(
)
)
{
*
result
=
false
;
return
true
;
}
RootedFunction
fun
(
cx
sc
-
>
asFunctionBox
(
)
-
>
function
(
)
)
;
if
(
!
fun
-
>
hasRest
(
)
)
{
*
result
=
false
;
return
true
;
}
if
(
!
pn
-
>
isKind
(
PNK_NAME
)
)
{
if
(
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
&
&
pn
-
>
isKind
(
PNK_CALL
)
)
{
ParseNode
*
pn2
=
pn
-
>
pn_head
;
if
(
pn2
-
>
getKind
(
)
=
=
PNK_NAME
&
&
pn2
-
>
name
(
)
=
=
cx
-
>
names
(
)
.
allowContentSpread
)
return
isRestParameter
(
pn2
-
>
pn_next
result
)
;
}
*
result
=
false
;
return
true
;
}
if
(
!
bindNameToSlot
(
pn
)
)
return
false
;
*
result
=
pn
-
>
getOp
(
)
=
=
JSOP_GETARG
&
&
pn
-
>
pn_scopecoord
.
slot
(
)
=
=
fun
-
>
nargs
(
)
-
1
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitOptimizeSpread
(
ParseNode
*
arg0
JumpList
*
jmp
bool
*
emitted
)
{
bool
result
=
false
;
if
(
!
isRestParameter
(
arg0
&
result
)
)
return
false
;
if
(
!
result
)
{
*
emitted
=
false
;
return
true
;
}
if
(
!
emitTree
(
arg0
)
)
return
false
;
if
(
!
emit1
(
JSOP_OPTIMIZE_SPREADCALL
)
)
return
false
;
if
(
!
emitJump
(
JSOP_IFNE
jmp
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
*
emitted
=
true
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitCallOrNew
(
ParseNode
*
pn
)
{
bool
callop
=
pn
-
>
isKind
(
PNK_CALL
)
|
|
pn
-
>
isKind
(
PNK_TAGGED_TEMPLATE
)
;
uint32_t
argc
=
pn
-
>
pn_count
-
1
;
if
(
argc
>
=
ARGC_LIMIT
)
{
parser
-
>
tokenStream
.
reportError
(
callop
?
JSMSG_TOO_MANY_FUN_ARGS
:
JSMSG_TOO_MANY_CON_ARGS
)
;
return
false
;
}
ParseNode
*
pn2
=
pn
-
>
pn_head
;
bool
spread
=
JOF_OPTYPE
(
pn
-
>
getOp
(
)
)
=
=
JOF_BYTE
;
switch
(
pn2
-
>
getKind
(
)
)
{
case
PNK_NAME
:
if
(
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
&
&
!
spread
)
{
MOZ_ASSERT
(
!
(
pn
-
>
pn_xflags
&
PNX_SETCALL
)
)
;
if
(
pn2
-
>
name
(
)
=
=
cx
-
>
names
(
)
.
callFunction
|
|
pn2
-
>
name
(
)
=
=
cx
-
>
names
(
)
.
callContentFunction
)
{
return
emitSelfHostedCallFunction
(
pn
)
;
}
if
(
pn2
-
>
name
(
)
=
=
cx
-
>
names
(
)
.
resumeGenerator
)
return
emitSelfHostedResumeGenerator
(
pn
)
;
if
(
pn2
-
>
name
(
)
=
=
cx
-
>
names
(
)
.
forceInterpreter
)
return
emitSelfHostedForceInterpreter
(
pn
)
;
if
(
pn2
-
>
name
(
)
=
=
cx
-
>
names
(
)
.
allowContentSpread
)
return
emitSelfHostedAllowContentSpread
(
pn
)
;
}
if
(
!
emitNameOp
(
pn2
callop
)
)
return
false
;
break
;
case
PNK_DOT
:
if
(
pn2
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
{
if
(
!
emitSuperPropOp
(
pn2
JSOP_GETPROP_SUPER
callop
)
)
return
false
;
}
else
{
if
(
!
emitPropOp
(
pn2
callop
?
JSOP_CALLPROP
:
JSOP_GETPROP
)
)
return
false
;
}
if
(
!
emitDebugOnlyCheckSelfHosted
(
)
)
return
false
;
break
;
case
PNK_ELEM
:
if
(
pn2
-
>
as
<
PropertyByValue
>
(
)
.
isSuper
(
)
)
{
if
(
!
emitSuperElemOp
(
pn2
JSOP_GETELEM_SUPER
callop
)
)
return
false
;
}
else
{
if
(
!
emitElemOp
(
pn2
callop
?
JSOP_CALLELEM
:
JSOP_GETELEM
)
)
return
false
;
if
(
callop
)
{
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
}
}
if
(
!
emitDebugOnlyCheckSelfHosted
(
)
)
return
false
;
break
;
case
PNK_FUNCTION
:
MOZ_ASSERT
(
!
emittingRunOnceLambda
)
;
if
(
checkRunOnceContext
(
)
)
{
emittingRunOnceLambda
=
true
;
if
(
!
emitTree
(
pn2
)
)
return
false
;
emittingRunOnceLambda
=
false
;
}
else
{
if
(
!
emitTree
(
pn2
)
)
return
false
;
}
callop
=
false
;
break
;
case
PNK_SUPERBASE
:
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_SUPERCALL
)
)
;
MOZ_ASSERT
(
parser
-
>
handler
.
isSuperBase
(
pn2
)
)
;
if
(
!
emit1
(
JSOP_SUPERFUN
)
)
return
false
;
break
;
default
:
if
(
!
emitTree
(
pn2
)
)
return
false
;
callop
=
false
;
break
;
}
if
(
!
callop
)
{
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
}
bool
isNewOp
=
pn
-
>
getOp
(
)
=
=
JSOP_NEW
|
|
pn
-
>
getOp
(
)
=
=
JSOP_SPREADNEW
|
|
pn
-
>
getOp
(
)
=
=
JSOP_SUPERCALL
|
|
pn
-
>
getOp
(
)
=
=
JSOP_SPREADSUPERCALL
;
;
bool
oldEmittingForInit
=
emittingForInit
;
emittingForInit
=
false
;
if
(
!
spread
)
{
for
(
ParseNode
*
pn3
=
pn2
-
>
pn_next
;
pn3
;
pn3
=
pn3
-
>
pn_next
)
{
if
(
!
emitTree
(
pn3
)
)
return
false
;
}
if
(
isNewOp
)
{
if
(
pn
-
>
isKind
(
PNK_SUPERCALL
)
)
{
if
(
!
emit1
(
JSOP_NEWTARGET
)
)
return
false
;
}
else
{
if
(
!
emitDupAt
(
argc
+
1
)
)
return
false
;
}
}
}
else
{
ParseNode
*
args
=
pn2
-
>
pn_next
;
JumpList
jmp
;
bool
optCodeEmitted
=
false
;
if
(
argc
=
=
1
)
{
if
(
!
emitOptimizeSpread
(
args
-
>
pn_kid
&
jmp
&
optCodeEmitted
)
)
return
false
;
}
if
(
!
emitArray
(
args
argc
JSOP_SPREADCALLARRAY
)
)
return
false
;
if
(
optCodeEmitted
)
{
if
(
!
emitJumpTargetAndPatch
(
jmp
)
)
return
false
;
}
if
(
isNewOp
)
{
if
(
pn
-
>
isKind
(
PNK_SUPERCALL
)
)
{
if
(
!
emit1
(
JSOP_NEWTARGET
)
)
return
false
;
}
else
{
if
(
!
emitDupAt
(
2
)
)
return
false
;
}
}
}
emittingForInit
=
oldEmittingForInit
;
if
(
!
spread
)
{
if
(
!
emitCall
(
pn
-
>
getOp
(
)
argc
pn
)
)
return
false
;
}
else
{
if
(
!
emit1
(
pn
-
>
getOp
(
)
)
)
return
false
;
}
checkTypeSet
(
pn
-
>
getOp
(
)
)
;
if
(
pn
-
>
isOp
(
JSOP_EVAL
)
|
|
pn
-
>
isOp
(
JSOP_STRICTEVAL
)
|
|
pn
-
>
isOp
(
JSOP_SPREADEVAL
)
|
|
pn
-
>
isOp
(
JSOP_STRICTSPREADEVAL
)
)
{
uint32_t
lineNum
=
parser
-
>
tokenStream
.
srcCoords
.
lineNum
(
pn
-
>
pn_pos
.
begin
)
;
if
(
!
emitUint32Operand
(
JSOP_LINENO
lineNum
)
)
return
false
;
}
if
(
pn
-
>
pn_xflags
&
PNX_SETCALL
)
{
if
(
!
emitUint16Operand
(
JSOP_THROWMSG
JSMSG_BAD_LEFTSIDE_OF_ASS
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitRightAssociative
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_POW
)
)
;
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_LIST
)
)
;
for
(
ParseNode
*
subexpr
=
pn
-
>
pn_head
;
subexpr
;
subexpr
=
subexpr
-
>
pn_next
)
{
if
(
!
emitTree
(
subexpr
)
)
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
pn
-
>
pn_count
-
1
;
i
+
+
)
{
if
(
!
emit1
(
JSOP_POW
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitLeftAssociative
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_LIST
)
)
;
if
(
!
emitTree
(
pn
-
>
pn_head
)
)
return
false
;
JSOp
op
=
pn
-
>
getOp
(
)
;
ParseNode
*
nextExpr
=
pn
-
>
pn_head
-
>
pn_next
;
do
{
if
(
!
emitTree
(
nextExpr
)
)
return
false
;
if
(
!
emit1
(
op
)
)
return
false
;
}
while
(
(
nextExpr
=
nextExpr
-
>
pn_next
)
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitLogical
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isArity
(
PN_LIST
)
)
;
ParseNode
*
pn2
=
pn
-
>
pn_head
;
if
(
!
emitTree
(
pn2
)
)
return
false
;
JSOp
op
=
pn
-
>
getOp
(
)
;
JumpList
jump
;
if
(
!
emitJump
(
op
&
jump
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
while
(
(
pn2
=
pn2
-
>
pn_next
)
-
>
pn_next
)
{
if
(
!
emitTree
(
pn2
)
)
return
false
;
if
(
!
emitJump
(
op
&
jump
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
if
(
!
emitTree
(
pn2
)
)
return
false
;
if
(
!
emitJumpTargetAndPatch
(
jump
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitSequenceExpr
(
ParseNode
*
pn
)
{
for
(
ParseNode
*
child
=
pn
-
>
pn_head
;
;
child
=
child
-
>
pn_next
)
{
if
(
!
updateSourceCoordNotes
(
child
-
>
pn_pos
.
begin
)
)
return
false
;
if
(
!
emitTree
(
child
)
)
return
false
;
if
(
!
child
-
>
pn_next
)
break
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
return
true
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitIncOrDec
(
ParseNode
*
pn
)
{
ParseNode
*
pn2
=
pn
-
>
pn_kid
;
switch
(
pn2
-
>
getKind
(
)
)
{
case
PNK_DOT
:
if
(
!
emitPropIncDec
(
pn
)
)
return
false
;
break
;
case
PNK_ELEM
:
if
(
!
emitElemIncDec
(
pn
)
)
return
false
;
break
;
case
PNK_CALL
:
MOZ_ASSERT
(
pn2
-
>
pn_xflags
&
PNX_SETCALL
)
;
if
(
!
emitTree
(
pn2
)
)
return
false
;
break
;
default
:
MOZ_ASSERT
(
pn2
-
>
isKind
(
PNK_NAME
)
)
;
pn2
-
>
setOp
(
JSOP_SETNAME
)
;
if
(
!
bindNameToSlot
(
pn2
)
)
return
false
;
JSOp
op
=
pn2
-
>
getOp
(
)
;
bool
maySet
;
switch
(
op
)
{
case
JSOP_SETLOCAL
:
case
JSOP_SETARG
:
case
JSOP_SETALIASEDVAR
:
case
JSOP_SETNAME
:
case
JSOP_STRICTSETNAME
:
case
JSOP_SETGNAME
:
case
JSOP_STRICTSETGNAME
:
maySet
=
true
;
break
;
default
:
maySet
=
false
;
}
if
(
op
=
=
JSOP_CALLEE
)
{
if
(
!
emit1
(
op
)
)
return
false
;
}
else
if
(
!
pn2
-
>
pn_scopecoord
.
isFree
(
)
)
{
if
(
maySet
)
{
if
(
!
emitVarIncDec
(
pn
)
)
return
false
;
}
else
{
if
(
!
emitVarOp
(
pn2
op
)
)
return
false
;
}
}
else
{
MOZ_ASSERT
(
JOF_OPTYPE
(
op
)
=
=
JOF_ATOM
)
;
if
(
maySet
)
{
if
(
!
emitNameIncDec
(
pn
)
)
return
false
;
}
else
{
if
(
!
emitAtomOp
(
pn2
op
)
)
return
false
;
}
break
;
}
if
(
pn2
-
>
isConst
(
)
)
{
if
(
!
emit1
(
JSOP_POS
)
)
return
false
;
bool
post
;
JSOp
binop
=
GetIncDecInfo
(
pn
-
>
getKind
(
)
&
post
)
;
if
(
!
post
)
{
if
(
!
emit1
(
JSOP_ONE
)
)
return
false
;
if
(
!
emit1
(
binop
)
)
return
false
;
}
}
}
return
true
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitLabeledStatement
(
const
LabeledStatement
*
pn
)
{
jsatomid
index
;
if
(
!
makeAtomIndex
(
pn
-
>
label
(
)
&
index
)
)
return
false
;
JumpList
top
;
if
(
!
emitJump
(
JSOP_LABEL
&
top
)
)
return
false
;
StmtInfoBCE
stmtInfo
(
cx
)
;
JumpTarget
stmtStart
{
offset
(
)
}
;
pushStatement
(
&
stmtInfo
StmtType
:
:
LABEL
stmtStart
)
;
stmtInfo
.
label
=
pn
-
>
label
(
)
;
if
(
!
emitTree
(
pn
-
>
statement
(
)
)
)
return
false
;
JumpTarget
brk
{
lastNonJumpTargetOffset
(
)
}
;
patchJumpsToTarget
(
top
brk
)
;
if
(
!
popStatement
(
)
)
return
false
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitConditionalExpression
(
ConditionalExpression
&
conditional
)
{
if
(
!
emitTree
(
&
conditional
.
condition
(
)
)
)
return
false
;
unsigned
noteIndex
;
if
(
!
newSrcNote
(
SRC_COND
&
noteIndex
)
)
return
false
;
JumpList
beq
;
if
(
!
emitJump
(
JSOP_IFEQ
&
beq
)
)
return
false
;
if
(
!
emitTree
(
&
conditional
.
thenExpression
(
)
)
)
return
false
;
JumpList
jmp
;
if
(
!
emitJump
(
JSOP_GOTO
&
jmp
)
)
return
false
;
if
(
!
emitJumpTargetAndPatch
(
beq
)
)
return
false
;
MOZ_ASSERT
(
stackDepth
>
0
)
;
stackDepth
-
-
;
if
(
!
emitTree
(
&
conditional
.
elseExpression
(
)
)
)
return
false
;
if
(
!
emitJumpTargetAndPatch
(
jmp
)
)
return
false
;
return
setSrcNoteOffset
(
noteIndex
0
jmp
.
offset
-
beq
.
offset
)
;
}
bool
BytecodeEmitter
:
:
emitPropertyList
(
ParseNode
*
pn
MutableHandlePlainObject
objp
PropListType
type
)
{
for
(
ParseNode
*
propdef
=
pn
-
>
pn_head
;
propdef
;
propdef
=
propdef
-
>
pn_next
)
{
if
(
!
updateSourceCoordNotes
(
propdef
-
>
pn_pos
.
begin
)
)
return
false
;
if
(
propdef
-
>
isKind
(
PNK_MUTATEPROTO
)
)
{
MOZ_ASSERT
(
type
=
=
ObjectLiteral
)
;
if
(
!
emitTree
(
propdef
-
>
pn_kid
)
)
return
false
;
objp
.
set
(
nullptr
)
;
if
(
!
emit1
(
JSOP_MUTATEPROTO
)
)
return
false
;
continue
;
}
bool
extraPop
=
false
;
if
(
type
=
=
ClassBody
&
&
propdef
-
>
as
<
ClassMethod
>
(
)
.
isStatic
(
)
)
{
extraPop
=
true
;
if
(
!
emit1
(
JSOP_DUP2
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
ParseNode
*
key
=
propdef
-
>
pn_left
;
bool
isIndex
=
false
;
if
(
key
-
>
isKind
(
PNK_NUMBER
)
)
{
if
(
!
emitNumberOp
(
key
-
>
pn_dval
)
)
return
false
;
isIndex
=
true
;
}
else
if
(
key
-
>
isKind
(
PNK_OBJECT_PROPERTY_NAME
)
|
|
key
-
>
isKind
(
PNK_STRING
)
)
{
if
(
type
=
=
ClassBody
&
&
key
-
>
pn_atom
=
=
cx
-
>
names
(
)
.
constructor
&
&
!
propdef
-
>
as
<
ClassMethod
>
(
)
.
isStatic
(
)
)
{
continue
;
}
jsid
id
=
NameToId
(
key
-
>
pn_atom
-
>
asPropertyName
(
)
)
;
if
(
id
!
=
IdToTypeId
(
id
)
)
{
if
(
!
emitTree
(
key
)
)
return
false
;
isIndex
=
true
;
}
}
else
{
if
(
!
emitComputedPropertyName
(
key
)
)
return
false
;
isIndex
=
true
;
}
if
(
!
emitTree
(
propdef
-
>
pn_right
)
)
return
false
;
JSOp
op
=
propdef
-
>
getOp
(
)
;
MOZ_ASSERT
(
op
=
=
JSOP_INITPROP
|
|
op
=
=
JSOP_INITPROP_GETTER
|
|
op
=
=
JSOP_INITPROP_SETTER
)
;
if
(
op
=
=
JSOP_INITPROP_GETTER
|
|
op
=
=
JSOP_INITPROP_SETTER
)
objp
.
set
(
nullptr
)
;
if
(
propdef
-
>
pn_right
-
>
isKind
(
PNK_FUNCTION
)
&
&
propdef
-
>
pn_right
-
>
pn_funbox
-
>
needsHomeObject
(
)
)
{
MOZ_ASSERT
(
propdef
-
>
pn_right
-
>
pn_funbox
-
>
function
(
)
-
>
allowSuperProperty
(
)
)
;
if
(
!
emit2
(
JSOP_INITHOMEOBJECT
isIndex
)
)
return
false
;
}
if
(
type
=
=
ClassBody
)
{
switch
(
op
)
{
case
JSOP_INITPROP
:
op
=
JSOP_INITHIDDENPROP
;
break
;
case
JSOP_INITPROP_GETTER
:
op
=
JSOP_INITHIDDENPROP_GETTER
;
break
;
case
JSOP_INITPROP_SETTER
:
op
=
JSOP_INITHIDDENPROP_SETTER
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
op
"
)
;
}
}
if
(
isIndex
)
{
objp
.
set
(
nullptr
)
;
switch
(
op
)
{
case
JSOP_INITPROP
:
op
=
JSOP_INITELEM
;
break
;
case
JSOP_INITHIDDENPROP
:
op
=
JSOP_INITHIDDENELEM
;
break
;
case
JSOP_INITPROP_GETTER
:
op
=
JSOP_INITELEM_GETTER
;
break
;
case
JSOP_INITHIDDENPROP_GETTER
:
op
=
JSOP_INITHIDDENELEM_GETTER
;
break
;
case
JSOP_INITPROP_SETTER
:
op
=
JSOP_INITELEM_SETTER
;
break
;
case
JSOP_INITHIDDENPROP_SETTER
:
op
=
JSOP_INITHIDDENELEM_SETTER
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
op
"
)
;
}
if
(
!
emit1
(
op
)
)
return
false
;
}
else
{
MOZ_ASSERT
(
key
-
>
isKind
(
PNK_OBJECT_PROPERTY_NAME
)
|
|
key
-
>
isKind
(
PNK_STRING
)
)
;
jsatomid
index
;
if
(
!
makeAtomIndex
(
key
-
>
pn_atom
&
index
)
)
return
false
;
if
(
objp
)
{
MOZ_ASSERT
(
type
=
=
ObjectLiteral
)
;
MOZ_ASSERT
(
!
IsHiddenInitOp
(
op
)
)
;
MOZ_ASSERT
(
!
objp
-
>
inDictionaryMode
(
)
)
;
Rooted
<
jsid
>
id
(
cx
AtomToId
(
key
-
>
pn_atom
)
)
;
RootedValue
undefinedValue
(
cx
UndefinedValue
(
)
)
;
if
(
!
NativeDefineProperty
(
cx
objp
id
undefinedValue
nullptr
nullptr
JSPROP_ENUMERATE
)
)
{
return
false
;
}
if
(
objp
-
>
inDictionaryMode
(
)
)
objp
.
set
(
nullptr
)
;
}
if
(
!
emitIndex32
(
op
index
)
)
return
false
;
}
if
(
extraPop
)
{
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
}
return
true
;
}
MOZ_NEVER_INLINE
bool
BytecodeEmitter
:
:
emitObject
(
ParseNode
*
pn
)
{
if
(
!
(
pn
-
>
pn_xflags
&
PNX_NONCONST
)
&
&
pn
-
>
pn_head
&
&
checkSingletonContext
(
)
)
return
emitSingletonInitialiser
(
pn
)
;
ptrdiff_t
offset
=
this
-
>
offset
(
)
;
if
(
!
emitNewInit
(
JSProto_Object
)
)
return
false
;
RootedPlainObject
obj
(
cx
)
;
gc
:
:
AllocKind
kind
=
gc
:
:
GetGCObjectKind
(
pn
-
>
pn_count
)
;
obj
=
NewBuiltinClassInstance
<
PlainObject
>
(
cx
kind
TenuredObject
)
;
if
(
!
obj
)
return
false
;
if
(
!
emitPropertyList
(
pn
&
obj
ObjectLiteral
)
)
return
false
;
if
(
obj
)
{
ObjectBox
*
objbox
=
parser
-
>
newObjectBox
(
obj
)
;
if
(
!
objbox
)
return
false
;
static_assert
(
JSOP_NEWINIT_LENGTH
=
=
JSOP_NEWOBJECT_LENGTH
"
newinit
and
newobject
must
have
equal
length
to
edit
in
-
place
"
)
;
uint32_t
index
=
objectList
.
add
(
objbox
)
;
jsbytecode
*
code
=
this
-
>
code
(
offset
)
;
code
[
0
]
=
JSOP_NEWOBJECT
;
code
[
1
]
=
jsbytecode
(
index
>
>
24
)
;
code
[
2
]
=
jsbytecode
(
index
>
>
16
)
;
code
[
3
]
=
jsbytecode
(
index
>
>
8
)
;
code
[
4
]
=
jsbytecode
(
index
)
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitArrayComp
(
ParseNode
*
pn
)
{
if
(
!
emitNewInit
(
JSProto_Array
)
)
return
false
;
MOZ_ASSERT
(
stackDepth
>
0
)
;
uint32_t
saveDepth
=
arrayCompDepth
;
arrayCompDepth
=
(
uint32_t
)
(
stackDepth
-
1
)
;
if
(
!
emitTree
(
pn
-
>
pn_head
)
)
return
false
;
arrayCompDepth
=
saveDepth
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitArrayLiteral
(
ParseNode
*
pn
)
{
if
(
!
(
pn
-
>
pn_xflags
&
PNX_NONCONST
)
&
&
pn
-
>
pn_head
)
{
if
(
checkSingletonContext
(
)
)
{
return
emitSingletonInitialiser
(
pn
)
;
}
if
(
emitterMode
!
=
BytecodeEmitter
:
:
SelfHosting
&
&
pn
-
>
pn_count
!
=
0
)
{
RootedValue
value
(
cx
)
;
if
(
!
pn
-
>
getConstantValue
(
cx
ParseNode
:
:
ForCopyOnWriteArray
&
value
)
)
return
false
;
if
(
!
value
.
isMagic
(
JS_GENERIC_MAGIC
)
)
{
JSObject
*
obj
=
&
value
.
toObject
(
)
;
MOZ_ASSERT
(
obj
-
>
is
<
ArrayObject
>
(
)
&
&
obj
-
>
as
<
ArrayObject
>
(
)
.
denseElementsAreCopyOnWrite
(
)
)
;
ObjectBox
*
objbox
=
parser
-
>
newObjectBox
(
obj
)
;
if
(
!
objbox
)
return
false
;
return
emitObjectOp
(
objbox
JSOP_NEWARRAY_COPYONWRITE
)
;
}
}
}
return
emitArray
(
pn
-
>
pn_head
pn
-
>
pn_count
JSOP_NEWARRAY
)
;
}
bool
BytecodeEmitter
:
:
emitArray
(
ParseNode
*
pn
uint32_t
count
JSOp
op
)
{
MOZ_ASSERT
(
op
=
=
JSOP_NEWARRAY
|
|
op
=
=
JSOP_SPREADCALLARRAY
)
;
uint32_t
nspread
=
0
;
for
(
ParseNode
*
elt
=
pn
;
elt
;
elt
=
elt
-
>
pn_next
)
{
if
(
elt
-
>
isKind
(
PNK_SPREAD
)
)
nspread
+
+
;
}
static_assert
(
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
<
=
INT32_MAX
"
array
literals
'
maximum
length
must
not
exceed
limits
"
"
required
by
BaselineCompiler
:
:
emit_JSOP_NEWARRAY
"
"
BaselineCompiler
:
:
emit_JSOP_INITELEM_ARRAY
"
"
and
DoSetElemFallback
'
s
handling
of
JSOP_INITELEM_ARRAY
"
)
;
MOZ_ASSERT
(
count
>
=
nspread
)
;
MOZ_ASSERT
(
count
<
=
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
"
the
parser
must
throw
an
error
if
the
array
exceeds
maximum
"
"
length
"
)
;
if
(
!
emitUint32Operand
(
op
count
-
nspread
)
)
return
false
;
ParseNode
*
pn2
=
pn
;
uint32_t
index
;
bool
afterSpread
=
false
;
for
(
index
=
0
;
pn2
;
index
+
+
pn2
=
pn2
-
>
pn_next
)
{
if
(
!
afterSpread
&
&
pn2
-
>
isKind
(
PNK_SPREAD
)
)
{
afterSpread
=
true
;
if
(
!
emitNumberOp
(
index
)
)
return
false
;
}
if
(
!
updateSourceCoordNotes
(
pn2
-
>
pn_pos
.
begin
)
)
return
false
;
bool
allowSelfHostedSpread
=
false
;
if
(
pn2
-
>
isKind
(
PNK_ELISION
)
)
{
if
(
!
emit1
(
JSOP_HOLE
)
)
return
false
;
}
else
{
ParseNode
*
expr
;
if
(
pn2
-
>
isKind
(
PNK_SPREAD
)
)
{
expr
=
pn2
-
>
pn_kid
;
if
(
emitterMode
=
=
BytecodeEmitter
:
:
SelfHosting
&
&
expr
-
>
isKind
(
PNK_CALL
)
&
&
expr
-
>
pn_head
-
>
name
(
)
=
=
cx
-
>
names
(
)
.
allowContentSpread
)
{
allowSelfHostedSpread
=
true
;
}
}
else
{
expr
=
pn2
;
}
if
(
!
emitTree
(
expr
)
)
return
false
;
}
if
(
pn2
-
>
isKind
(
PNK_SPREAD
)
)
{
if
(
!
emitIterator
(
)
)
return
false
;
if
(
!
emit2
(
JSOP_PICK
2
)
)
return
false
;
if
(
!
emit2
(
JSOP_PICK
2
)
)
return
false
;
if
(
!
emitSpread
(
allowSelfHostedSpread
)
)
return
false
;
}
else
if
(
afterSpread
)
{
if
(
!
emit1
(
JSOP_INITELEM_INC
)
)
return
false
;
}
else
{
if
(
!
emitUint32Operand
(
JSOP_INITELEM_ARRAY
index
)
)
return
false
;
}
}
MOZ_ASSERT
(
index
=
=
count
)
;
if
(
afterSpread
)
{
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitUnary
(
ParseNode
*
pn
)
{
if
(
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
begin
)
)
return
false
;
JSOp
op
=
pn
-
>
getOp
(
)
;
ParseNode
*
pn2
=
pn
-
>
pn_kid
;
bool
oldEmittingForInit
=
emittingForInit
;
emittingForInit
=
false
;
if
(
!
emitTree
(
pn2
)
)
return
false
;
emittingForInit
=
oldEmittingForInit
;
return
emit1
(
op
)
;
}
bool
BytecodeEmitter
:
:
emitTypeof
(
ParseNode
*
node
JSOp
op
)
{
MOZ_ASSERT
(
op
=
=
JSOP_TYPEOF
|
|
op
=
=
JSOP_TYPEOFEXPR
)
;
if
(
!
updateSourceCoordNotes
(
node
-
>
pn_pos
.
begin
)
)
return
false
;
bool
oldEmittingForInit
=
emittingForInit
;
emittingForInit
=
false
;
if
(
!
emitTree
(
node
-
>
pn_kid
)
)
return
false
;
emittingForInit
=
oldEmittingForInit
;
return
emit1
(
op
)
;
}
bool
BytecodeEmitter
:
:
emitArgsBody
(
ParseNode
*
pn
)
{
RootedFunction
fun
(
cx
sc
-
>
asFunctionBox
(
)
-
>
function
(
)
)
;
ParseNode
*
pnlast
=
pn
-
>
last
(
)
;
bool
hasDefaults
=
sc
-
>
asFunctionBox
(
)
-
>
hasDefaults
(
)
;
ParseNode
*
rest
=
nullptr
;
bool
restIsDefn
=
false
;
if
(
fun
-
>
hasRest
(
)
&
&
hasDefaults
)
{
rest
=
pn
-
>
pn_head
;
while
(
rest
-
>
pn_next
!
=
pnlast
)
rest
=
rest
-
>
pn_next
;
restIsDefn
=
rest
-
>
isDefn
(
)
;
if
(
!
emit1
(
JSOP_REST
)
)
return
false
;
checkTypeSet
(
JSOP_REST
)
;
if
(
restIsDefn
)
{
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
if
(
!
bindNameToSlot
(
rest
)
)
return
false
;
if
(
!
emitVarOp
(
rest
JSOP_SETARG
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
}
if
(
!
emitDefaultsAndDestructuring
(
pn
)
)
return
false
;
if
(
fun
-
>
hasRest
(
)
&
&
hasDefaults
)
{
if
(
restIsDefn
&
&
!
emitVarOp
(
rest
JSOP_SETARG
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
for
(
ParseNode
*
pn2
=
pn
-
>
pn_head
;
pn2
!
=
pnlast
;
pn2
=
pn2
-
>
pn_next
)
{
if
(
!
pn2
-
>
isDefn
(
)
)
continue
;
if
(
!
bindNameToSlot
(
pn2
)
)
return
false
;
if
(
pn2
-
>
pn_next
=
=
pnlast
&
&
fun
-
>
hasRest
(
)
&
&
!
hasDefaults
)
{
switchToPrologue
(
)
;
if
(
!
emit1
(
JSOP_REST
)
)
return
false
;
checkTypeSet
(
JSOP_REST
)
;
if
(
!
emitVarOp
(
pn2
JSOP_SETARG
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
switchToMain
(
)
;
}
}
if
(
pnlast
-
>
pn_xflags
&
PNX_FUNCDEFS
)
{
if
(
!
emitHoistedFunctionsInList
(
pnlast
)
)
return
false
;
}
return
emitTree
(
pnlast
)
;
}
bool
BytecodeEmitter
:
:
emitDefaultsAndDestructuring
(
ParseNode
*
pn
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_ARGSBODY
)
)
;
ParseNode
*
pnlast
=
pn
-
>
last
(
)
;
for
(
ParseNode
*
arg
=
pn
-
>
pn_head
;
arg
!
=
pnlast
;
arg
=
arg
-
>
pn_next
)
{
MOZ_ASSERT
(
arg
-
>
isKind
(
PNK_NAME
)
|
|
arg
-
>
isKind
(
PNK_ASSIGN
)
)
;
ParseNode
*
argName
=
nullptr
;
ParseNode
*
defNode
=
nullptr
;
ParseNode
*
destruct
=
nullptr
;
if
(
arg
-
>
isKind
(
PNK_ASSIGN
)
)
{
argName
=
arg
-
>
pn_left
;
defNode
=
arg
-
>
pn_right
;
}
else
if
(
arg
-
>
pn_atom
=
=
cx
-
>
names
(
)
.
empty
)
{
argName
=
arg
;
destruct
=
arg
-
>
expr
(
)
;
MOZ_ASSERT
(
destruct
)
;
if
(
destruct
-
>
isKind
(
PNK_ASSIGN
)
)
{
defNode
=
destruct
-
>
pn_right
;
destruct
=
destruct
-
>
pn_left
;
}
}
if
(
defNode
)
{
if
(
!
bindNameToSlot
(
argName
)
)
return
false
;
if
(
!
emitVarOp
(
argName
JSOP_GETARG
)
)
return
false
;
if
(
!
emit1
(
JSOP_UNDEFINED
)
)
return
false
;
if
(
!
emit1
(
JSOP_STRICTEQ
)
)
return
false
;
if
(
!
newSrcNote
(
SRC_IF
)
)
return
false
;
JumpList
jump
;
if
(
!
emitJump
(
JSOP_IFEQ
&
jump
)
)
return
false
;
if
(
!
emitTree
(
defNode
)
)
return
false
;
if
(
!
emitVarOp
(
argName
JSOP_SETARG
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
if
(
!
emitJumpTargetAndPatch
(
jump
)
)
return
false
;
}
if
(
destruct
)
{
if
(
!
emitTree
(
argName
)
)
return
false
;
if
(
!
emitDestructuringOps
(
destruct
false
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitLexicalInitialization
(
ParseNode
*
pn
JSOp
globalDefOp
)
{
MOZ_ASSERT
(
pn
-
>
isKind
(
PNK_NAME
)
)
;
if
(
!
bindNameToSlot
(
pn
)
)
return
false
;
jsatomid
atomIndex
;
if
(
!
maybeEmitVarDecl
(
globalDefOp
pn
&
atomIndex
)
)
return
false
;
if
(
!
pn
-
>
pn_scopecoord
.
isFree
(
)
)
{
if
(
!
emitVarOp
(
pn
pn
-
>
getOp
(
)
)
)
return
false
;
}
else
{
if
(
!
emitIndexOp
(
pn
-
>
getOp
(
)
atomIndex
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
emitClass
(
ParseNode
*
pn
)
{
ClassNode
&
classNode
=
pn
-
>
as
<
ClassNode
>
(
)
;
ClassNames
*
names
=
classNode
.
names
(
)
;
ParseNode
*
heritageExpression
=
classNode
.
heritage
(
)
;
ParseNode
*
classMethods
=
classNode
.
methodList
(
)
;
ParseNode
*
constructor
=
nullptr
;
for
(
ParseNode
*
mn
=
classMethods
-
>
pn_head
;
mn
;
mn
=
mn
-
>
pn_next
)
{
ClassMethod
&
method
=
mn
-
>
as
<
ClassMethod
>
(
)
;
ParseNode
&
methodName
=
method
.
name
(
)
;
if
(
!
method
.
isStatic
(
)
&
&
methodName
.
isKind
(
PNK_OBJECT_PROPERTY_NAME
)
&
&
methodName
.
pn_atom
=
=
cx
-
>
names
(
)
.
constructor
)
{
constructor
=
&
method
.
method
(
)
;
break
;
}
}
bool
savedStrictness
=
sc
-
>
setLocalStrictMode
(
true
)
;
StmtInfoBCE
stmtInfo
(
cx
)
;
if
(
names
)
{
if
(
!
enterBlockScope
(
&
stmtInfo
classNode
.
scopeObjectBox
(
)
JSOP_UNINITIALIZED
)
)
return
false
;
}
if
(
heritageExpression
)
{
if
(
!
emitTree
(
heritageExpression
)
)
return
false
;
if
(
!
emit1
(
JSOP_CLASSHERITAGE
)
)
return
false
;
if
(
!
emit1
(
JSOP_OBJWITHPROTO
)
)
return
false
;
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
}
else
{
if
(
!
emitNewInit
(
JSProto_Object
)
)
return
false
;
}
if
(
constructor
)
{
if
(
!
emitFunction
(
constructor
!
!
heritageExpression
)
)
return
false
;
if
(
constructor
-
>
pn_funbox
-
>
needsHomeObject
(
)
)
{
if
(
!
emit2
(
JSOP_INITHOMEOBJECT
0
)
)
return
false
;
}
}
else
{
JSAtom
*
name
=
names
?
names
-
>
innerBinding
(
)
-
>
pn_atom
:
cx
-
>
names
(
)
.
empty
;
if
(
heritageExpression
)
{
if
(
!
emitAtomOp
(
name
JSOP_DERIVEDCONSTRUCTOR
)
)
return
false
;
}
else
{
if
(
!
emitAtomOp
(
name
JSOP_CLASSCONSTRUCTOR
)
)
return
false
;
}
}
if
(
!
emit1
(
JSOP_SWAP
)
)
return
false
;
if
(
!
emit1
(
JSOP_DUP2
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
prototype
JSOP_INITLOCKEDPROP
)
)
return
false
;
if
(
!
emitAtomOp
(
cx
-
>
names
(
)
.
constructor
JSOP_INITHIDDENPROP
)
)
return
false
;
RootedPlainObject
obj
(
cx
)
;
if
(
!
emitPropertyList
(
classMethods
&
obj
ClassBody
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
if
(
names
)
{
ParseNode
*
innerName
=
names
-
>
innerBinding
(
)
;
if
(
!
emitLexicalInitialization
(
innerName
JSOP_DEFCONST
)
)
return
false
;
if
(
!
leaveNestedScope
(
&
stmtInfo
)
)
return
false
;
ParseNode
*
outerName
=
names
-
>
outerBinding
(
)
;
if
(
outerName
)
{
if
(
!
emitLexicalInitialization
(
outerName
JSOP_DEFLET
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
}
MOZ_ALWAYS_TRUE
(
sc
-
>
setLocalStrictMode
(
savedStrictness
)
)
;
return
true
;
}
bool
BytecodeEmitter
:
:
emitTree
(
ParseNode
*
pn
EmitLineNumberNote
emitLineNote
)
{
JS_CHECK_RECURSION
(
cx
return
false
)
;
EmitLevelManager
elm
(
this
)
;
if
(
emitLineNote
=
=
EMIT_LINENOTE
&
&
pn
-
>
getKind
(
)
!
=
PNK_WHILE
&
&
pn
-
>
getKind
(
)
!
=
PNK_FOR
&
&
!
updateLineNumberNotes
(
pn
-
>
pn_pos
.
begin
)
)
return
false
;
switch
(
pn
-
>
getKind
(
)
)
{
case
PNK_FUNCTION
:
if
(
!
emitFunction
(
pn
)
)
return
false
;
break
;
case
PNK_ANNEXB_FUNCTION
:
if
(
pn
-
>
pn_left
-
>
isKind
(
PNK_NOP
)
)
break
;
if
(
!
emitFunction
(
pn
)
)
return
false
;
break
;
case
PNK_ARGSBODY
:
if
(
!
emitArgsBody
(
pn
)
)
return
false
;
break
;
case
PNK_IF
:
if
(
!
emitIf
(
pn
)
)
return
false
;
break
;
case
PNK_SWITCH
:
if
(
!
emitSwitch
(
pn
)
)
return
false
;
break
;
case
PNK_WHILE
:
if
(
!
emitWhile
(
pn
)
)
return
false
;
break
;
case
PNK_DOWHILE
:
if
(
!
emitDo
(
pn
)
)
return
false
;
break
;
case
PNK_FOR
:
if
(
!
emitFor
(
pn
)
)
return
false
;
break
;
case
PNK_COMPREHENSIONFOR
:
if
(
!
emitComprehensionFor
(
pn
)
)
return
false
;
break
;
case
PNK_BREAK
:
if
(
!
emitBreak
(
pn
-
>
as
<
BreakStatement
>
(
)
.
label
(
)
)
)
return
false
;
break
;
case
PNK_CONTINUE
:
if
(
!
emitContinue
(
pn
-
>
as
<
ContinueStatement
>
(
)
.
label
(
)
)
)
return
false
;
break
;
case
PNK_WITH
:
if
(
!
emitWith
(
pn
)
)
return
false
;
break
;
case
PNK_TRY
:
if
(
!
emitTry
(
pn
)
)
return
false
;
break
;
case
PNK_CATCH
:
if
(
!
emitCatch
(
pn
)
)
return
false
;
break
;
case
PNK_VAR
:
if
(
!
emitVariables
(
pn
InitializeVars
)
)
return
false
;
break
;
case
PNK_RETURN
:
if
(
!
emitReturn
(
pn
)
)
return
false
;
break
;
case
PNK_YIELD_STAR
:
if
(
!
emitYieldStar
(
pn
-
>
pn_left
pn
-
>
pn_right
)
)
return
false
;
break
;
case
PNK_GENERATOR
:
if
(
!
emit1
(
JSOP_GENERATOR
)
)
return
false
;
break
;
case
PNK_YIELD
:
if
(
!
emitYield
(
pn
)
)
return
false
;
break
;
case
PNK_STATEMENTLIST
:
if
(
!
emitStatementList
(
pn
)
)
return
false
;
break
;
case
PNK_SEMI
:
if
(
!
emitStatement
(
pn
)
)
return
false
;
break
;
case
PNK_LABEL
:
if
(
!
emitLabeledStatement
(
&
pn
-
>
as
<
LabeledStatement
>
(
)
)
)
return
false
;
break
;
case
PNK_COMMA
:
if
(
!
emitSequenceExpr
(
pn
)
)
return
false
;
break
;
case
PNK_ASSIGN
:
case
PNK_ADDASSIGN
:
case
PNK_SUBASSIGN
:
case
PNK_BITORASSIGN
:
case
PNK_BITXORASSIGN
:
case
PNK_BITANDASSIGN
:
case
PNK_LSHASSIGN
:
case
PNK_RSHASSIGN
:
case
PNK_URSHASSIGN
:
case
PNK_MULASSIGN
:
case
PNK_DIVASSIGN
:
case
PNK_MODASSIGN
:
case
PNK_POWASSIGN
:
if
(
!
emitAssignment
(
pn
-
>
pn_left
pn
-
>
getOp
(
)
pn
-
>
pn_right
)
)
return
false
;
break
;
case
PNK_CONDITIONAL
:
if
(
!
emitConditionalExpression
(
pn
-
>
as
<
ConditionalExpression
>
(
)
)
)
return
false
;
break
;
case
PNK_OR
:
case
PNK_AND
:
if
(
!
emitLogical
(
pn
)
)
return
false
;
break
;
case
PNK_ADD
:
case
PNK_SUB
:
case
PNK_BITOR
:
case
PNK_BITXOR
:
case
PNK_BITAND
:
case
PNK_STRICTEQ
:
case
PNK_EQ
:
case
PNK_STRICTNE
:
case
PNK_NE
:
case
PNK_LT
:
case
PNK_LE
:
case
PNK_GT
:
case
PNK_GE
:
case
PNK_IN
:
case
PNK_INSTANCEOF
:
case
PNK_LSH
:
case
PNK_RSH
:
case
PNK_URSH
:
case
PNK_STAR
:
case
PNK_DIV
:
case
PNK_MOD
:
if
(
!
emitLeftAssociative
(
pn
)
)
return
false
;
break
;
case
PNK_POW
:
if
(
!
emitRightAssociative
(
pn
)
)
return
false
;
break
;
case
PNK_TYPEOFNAME
:
if
(
!
emitTypeof
(
pn
JSOP_TYPEOF
)
)
return
false
;
break
;
case
PNK_TYPEOFEXPR
:
if
(
!
emitTypeof
(
pn
JSOP_TYPEOFEXPR
)
)
return
false
;
break
;
case
PNK_THROW
:
case
PNK_VOID
:
case
PNK_NOT
:
case
PNK_BITNOT
:
case
PNK_POS
:
case
PNK_NEG
:
if
(
!
emitUnary
(
pn
)
)
return
false
;
break
;
case
PNK_PREINCREMENT
:
case
PNK_PREDECREMENT
:
case
PNK_POSTINCREMENT
:
case
PNK_POSTDECREMENT
:
if
(
!
emitIncOrDec
(
pn
)
)
return
false
;
break
;
case
PNK_DELETENAME
:
if
(
!
emitDeleteName
(
pn
)
)
return
false
;
break
;
case
PNK_DELETEPROP
:
if
(
!
emitDeleteProperty
(
pn
)
)
return
false
;
break
;
case
PNK_DELETEELEM
:
if
(
!
emitDeleteElement
(
pn
)
)
return
false
;
break
;
case
PNK_DELETEEXPR
:
if
(
!
emitDeleteExpression
(
pn
)
)
return
false
;
break
;
case
PNK_DOT
:
if
(
pn
-
>
as
<
PropertyAccess
>
(
)
.
isSuper
(
)
)
{
if
(
!
emitSuperPropOp
(
pn
JSOP_GETPROP_SUPER
)
)
return
false
;
}
else
{
if
(
!
emitPropOp
(
pn
JSOP_GETPROP
)
)
return
false
;
}
break
;
case
PNK_ELEM
:
if
(
pn
-
>
as
<
PropertyByValue
>
(
)
.
isSuper
(
)
)
{
if
(
!
emitSuperElemOp
(
pn
JSOP_GETELEM_SUPER
)
)
return
false
;
}
else
{
if
(
!
emitElemOp
(
pn
JSOP_GETELEM
)
)
return
false
;
}
break
;
case
PNK_NEW
:
case
PNK_TAGGED_TEMPLATE
:
case
PNK_CALL
:
case
PNK_GENEXP
:
case
PNK_SUPERCALL
:
if
(
!
emitCallOrNew
(
pn
)
)
return
false
;
break
;
case
PNK_LEXICALSCOPE
:
if
(
!
emitLexicalScope
(
pn
)
)
return
false
;
break
;
case
PNK_LETBLOCK
:
if
(
!
emitLetBlock
(
pn
)
)
return
false
;
break
;
case
PNK_CONST
:
case
PNK_LET
:
if
(
!
emitVariables
(
pn
InitializeVars
)
)
return
false
;
break
;
case
PNK_IMPORT
:
MOZ_ASSERT
(
sc
-
>
isModuleBox
(
)
)
;
break
;
case
PNK_EXPORT
:
MOZ_ASSERT
(
sc
-
>
isModuleBox
(
)
)
;
if
(
pn
-
>
pn_kid
-
>
getKind
(
)
!
=
PNK_EXPORT_SPEC_LIST
)
{
if
(
!
emitTree
(
pn
-
>
pn_kid
)
)
return
false
;
}
break
;
case
PNK_EXPORT_DEFAULT
:
MOZ_ASSERT
(
sc
-
>
isModuleBox
(
)
)
;
if
(
!
emitTree
(
pn
-
>
pn_kid
)
)
return
false
;
if
(
pn
-
>
pn_right
)
{
if
(
!
emitLexicalInitialization
(
pn
-
>
pn_right
JSOP_DEFCONST
)
)
return
false
;
if
(
!
emit1
(
JSOP_POP
)
)
return
false
;
}
break
;
case
PNK_EXPORT_FROM
:
MOZ_ASSERT
(
sc
-
>
isModuleBox
(
)
)
;
break
;
case
PNK_ARRAYPUSH
:
if
(
!
emitTree
(
pn
-
>
pn_kid
)
)
return
false
;
if
(
!
emitDupAt
(
this
-
>
stackDepth
-
1
-
arrayCompDepth
)
)
return
false
;
if
(
!
emit1
(
JSOP_ARRAYPUSH
)
)
return
false
;
break
;
case
PNK_CALLSITEOBJ
:
if
(
!
emitCallSiteObject
(
pn
)
)
return
false
;
break
;
case
PNK_ARRAY
:
if
(
!
emitArrayLiteral
(
pn
)
)
return
false
;
break
;
case
PNK_ARRAYCOMP
:
if
(
!
emitArrayComp
(
pn
)
)
return
false
;
break
;
case
PNK_OBJECT
:
if
(
!
emitObject
(
pn
)
)
return
false
;
break
;
case
PNK_NAME
:
if
(
!
emitNameOp
(
pn
false
)
)
return
false
;
break
;
case
PNK_TEMPLATE_STRING_LIST
:
if
(
!
emitTemplateString
(
pn
)
)
return
false
;
break
;
case
PNK_TEMPLATE_STRING
:
case
PNK_STRING
:
if
(
!
emitAtomOp
(
pn
JSOP_STRING
)
)
return
false
;
break
;
case
PNK_NUMBER
:
if
(
!
emitNumberOp
(
pn
-
>
pn_dval
)
)
return
false
;
break
;
case
PNK_REGEXP
:
if
(
!
emitRegExp
(
objectList
.
add
(
pn
-
>
as
<
RegExpLiteral
>
(
)
.
objbox
(
)
)
)
)
return
false
;
break
;
case
PNK_TRUE
:
case
PNK_FALSE
:
case
PNK_NULL
:
if
(
!
emit1
(
pn
-
>
getOp
(
)
)
)
return
false
;
break
;
case
PNK_THIS
:
if
(
!
emitThisLiteral
(
pn
)
)
return
false
;
break
;
case
PNK_DEBUGGER
:
if
(
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
begin
)
)
return
false
;
if
(
!
emit1
(
JSOP_DEBUGGER
)
)
return
false
;
break
;
case
PNK_NOP
:
MOZ_ASSERT
(
pn
-
>
getArity
(
)
=
=
PN_NULLARY
)
;
break
;
case
PNK_CLASS
:
if
(
!
emitClass
(
pn
)
)
return
false
;
break
;
case
PNK_NEWTARGET
:
if
(
!
emit1
(
JSOP_NEWTARGET
)
)
return
false
;
break
;
case
PNK_SETTHIS
:
if
(
!
emitSetThis
(
pn
)
)
return
false
;
break
;
case
PNK_POSHOLDER
:
MOZ_FALLTHROUGH_ASSERT
(
"
Should
never
try
to
emit
PNK_POSHOLDER
"
)
;
default
:
MOZ_ASSERT
(
0
)
;
}
if
(
emitLevel
=
=
1
)
{
if
(
!
updateSourceCoordNotes
(
pn
-
>
pn_pos
.
end
)
)
return
false
;
}
return
true
;
}
static
bool
AllocSrcNote
(
ExclusiveContext
*
cx
SrcNotesVector
&
notes
unsigned
*
index
)
{
if
(
notes
.
capacity
(
)
=
=
0
&
&
!
notes
.
reserve
(
256
)
)
return
false
;
if
(
!
notes
.
growBy
(
1
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
*
index
=
notes
.
length
(
)
-
1
;
return
true
;
}
bool
BytecodeEmitter
:
:
newSrcNote
(
SrcNoteType
type
unsigned
*
indexp
)
{
SrcNotesVector
&
notes
=
this
-
>
notes
(
)
;
unsigned
index
;
if
(
!
AllocSrcNote
(
cx
notes
&
index
)
)
return
false
;
ptrdiff_t
offset
=
this
-
>
offset
(
)
;
ptrdiff_t
delta
=
offset
-
lastNoteOffset
(
)
;
current
-
>
lastNoteOffset
=
offset
;
if
(
delta
>
=
SN_DELTA_LIMIT
)
{
do
{
ptrdiff_t
xdelta
=
Min
(
delta
SN_XDELTA_MASK
)
;
SN_MAKE_XDELTA
(
&
notes
[
index
]
xdelta
)
;
delta
-
=
xdelta
;
if
(
!
AllocSrcNote
(
cx
notes
&
index
)
)
return
false
;
}
while
(
delta
>
=
SN_DELTA_LIMIT
)
;
}
SN_MAKE_NOTE
(
&
notes
[
index
]
type
delta
)
;
for
(
int
n
=
(
int
)
js_SrcNoteSpec
[
type
]
.
arity
;
n
>
0
;
n
-
-
)
{
if
(
!
newSrcNote
(
SRC_NULL
)
)
return
false
;
}
if
(
indexp
)
*
indexp
=
index
;
return
true
;
}
bool
BytecodeEmitter
:
:
newSrcNote2
(
SrcNoteType
type
ptrdiff_t
offset
unsigned
*
indexp
)
{
unsigned
index
;
if
(
!
newSrcNote
(
type
&
index
)
)
return
false
;
if
(
!
setSrcNoteOffset
(
index
0
offset
)
)
return
false
;
if
(
indexp
)
*
indexp
=
index
;
return
true
;
}
bool
BytecodeEmitter
:
:
newSrcNote3
(
SrcNoteType
type
ptrdiff_t
offset1
ptrdiff_t
offset2
unsigned
*
indexp
)
{
unsigned
index
;
if
(
!
newSrcNote
(
type
&
index
)
)
return
false
;
if
(
!
setSrcNoteOffset
(
index
0
offset1
)
)
return
false
;
if
(
!
setSrcNoteOffset
(
index
1
offset2
)
)
return
false
;
if
(
indexp
)
*
indexp
=
index
;
return
true
;
}
bool
BytecodeEmitter
:
:
addToSrcNoteDelta
(
jssrcnote
*
sn
ptrdiff_t
delta
)
{
MOZ_ASSERT
(
current
=
=
&
main
)
;
MOZ_ASSERT
(
(
unsigned
)
delta
<
(
unsigned
)
SN_XDELTA_LIMIT
)
;
ptrdiff_t
base
=
SN_DELTA
(
sn
)
;
ptrdiff_t
limit
=
SN_IS_XDELTA
(
sn
)
?
SN_XDELTA_LIMIT
:
SN_DELTA_LIMIT
;
ptrdiff_t
newdelta
=
base
+
delta
;
if
(
newdelta
<
limit
)
{
SN_SET_DELTA
(
sn
newdelta
)
;
}
else
{
jssrcnote
xdelta
;
SN_MAKE_XDELTA
(
&
xdelta
delta
)
;
if
(
!
main
.
notes
.
insert
(
sn
xdelta
)
)
return
false
;
}
return
true
;
}
bool
BytecodeEmitter
:
:
setSrcNoteOffset
(
unsigned
index
unsigned
which
ptrdiff_t
offset
)
{
if
(
!
SN_REPRESENTABLE_OFFSET
(
offset
)
)
{
ReportStatementTooLarge
(
parser
-
>
tokenStream
innermostStmt
(
)
)
;
return
false
;
}
SrcNotesVector
&
notes
=
this
-
>
notes
(
)
;
jssrcnote
*
sn
=
&
notes
[
index
]
;
MOZ_ASSERT
(
SN_TYPE
(
sn
)
!
=
SRC_XDELTA
)
;
MOZ_ASSERT
(
(
int
)
which
<
js_SrcNoteSpec
[
SN_TYPE
(
sn
)
]
.
arity
)
;
for
(
sn
+
+
;
which
;
sn
+
+
which
-
-
)
{
if
(
*
sn
&
SN_4BYTE_OFFSET_FLAG
)
sn
+
=
3
;
}
if
(
offset
>
(
ptrdiff_t
)
SN_4BYTE_OFFSET_MASK
|
|
(
*
sn
&
SN_4BYTE_OFFSET_FLAG
)
)
{
if
(
!
(
*
sn
&
SN_4BYTE_OFFSET_FLAG
)
)
{
jssrcnote
dummy
=
0
;
if
(
!
(
sn
=
notes
.
insert
(
sn
dummy
)
)
|
|
!
(
sn
=
notes
.
insert
(
sn
dummy
)
)
|
|
!
(
sn
=
notes
.
insert
(
sn
dummy
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
*
sn
+
+
=
(
jssrcnote
)
(
SN_4BYTE_OFFSET_FLAG
|
(
offset
>
>
24
)
)
;
*
sn
+
+
=
(
jssrcnote
)
(
offset
>
>
16
)
;
*
sn
+
+
=
(
jssrcnote
)
(
offset
>
>
8
)
;
}
*
sn
=
(
jssrcnote
)
offset
;
return
true
;
}
bool
BytecodeEmitter
:
:
finishTakingSrcNotes
(
uint32_t
*
out
)
{
MOZ_ASSERT
(
current
=
=
&
main
)
;
unsigned
prologueCount
=
prologue
.
notes
.
length
(
)
;
if
(
prologueCount
&
&
prologue
.
currentLine
!
=
firstLine
)
{
switchToPrologue
(
)
;
if
(
!
newSrcNote2
(
SRC_SETLINE
ptrdiff_t
(
firstLine
)
)
)
return
false
;
switchToMain
(
)
;
}
else
{
ptrdiff_t
offset
=
prologueOffset
(
)
-
prologue
.
lastNoteOffset
;
MOZ_ASSERT
(
offset
>
=
0
)
;
if
(
offset
>
0
&
&
main
.
notes
.
length
(
)
!
=
0
)
{
jssrcnote
*
sn
=
main
.
notes
.
begin
(
)
;
ptrdiff_t
delta
=
SN_IS_XDELTA
(
sn
)
?
SN_XDELTA_MASK
-
(
*
sn
&
SN_XDELTA_MASK
)
:
SN_DELTA_MASK
-
(
*
sn
&
SN_DELTA_MASK
)
;
if
(
offset
<
delta
)
delta
=
offset
;
for
(
;
;
)
{
if
(
!
addToSrcNoteDelta
(
sn
delta
)
)
return
false
;
offset
-
=
delta
;
if
(
offset
=
=
0
)
break
;
delta
=
Min
(
offset
SN_XDELTA_MASK
)
;
sn
=
main
.
notes
.
begin
(
)
;
}
}
}
*
out
=
prologue
.
notes
.
length
(
)
+
main
.
notes
.
length
(
)
+
1
;
return
true
;
}
void
BytecodeEmitter
:
:
copySrcNotes
(
jssrcnote
*
destination
uint32_t
nsrcnotes
)
{
unsigned
prologueCount
=
prologue
.
notes
.
length
(
)
;
unsigned
mainCount
=
main
.
notes
.
length
(
)
;
unsigned
totalCount
=
prologueCount
+
mainCount
;
MOZ_ASSERT
(
totalCount
=
=
nsrcnotes
-
1
)
;
if
(
prologueCount
)
PodCopy
(
destination
prologue
.
notes
.
begin
(
)
prologueCount
)
;
PodCopy
(
destination
+
prologueCount
main
.
notes
.
begin
(
)
mainCount
)
;
SN_MAKE_TERMINATOR
(
&
destination
[
totalCount
]
)
;
}
void
CGConstList
:
:
finish
(
ConstArray
*
array
)
{
MOZ_ASSERT
(
length
(
)
=
=
array
-
>
length
)
;
for
(
unsigned
i
=
0
;
i
<
length
(
)
;
i
+
+
)
array
-
>
vector
[
i
]
=
list
[
i
]
;
}
unsigned
CGObjectList
:
:
add
(
ObjectBox
*
objbox
)
{
MOZ_ASSERT
(
!
objbox
-
>
emitLink
)
;
objbox
-
>
emitLink
=
lastbox
;
lastbox
=
objbox
;
return
length
+
+
;
}
unsigned
CGObjectList
:
:
indexOf
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
length
>
0
)
;
unsigned
index
=
length
-
1
;
for
(
ObjectBox
*
box
=
lastbox
;
box
-
>
object
!
=
obj
;
box
=
box
-
>
emitLink
)
index
-
-
;
return
index
;
}
void
CGObjectList
:
:
finish
(
ObjectArray
*
array
)
{
MOZ_ASSERT
(
length
<
=
INDEX_LIMIT
)
;
MOZ_ASSERT
(
length
=
=
array
-
>
length
)
;
js
:
:
GCPtrObject
*
cursor
=
array
-
>
vector
+
array
-
>
length
;
ObjectBox
*
objbox
=
lastbox
;
do
{
-
-
cursor
;
MOZ_ASSERT
(
!
*
cursor
)
;
MOZ_ASSERT
(
objbox
-
>
object
-
>
isTenured
(
)
)
;
*
cursor
=
objbox
-
>
object
;
}
while
(
(
objbox
=
objbox
-
>
emitLink
)
!
=
nullptr
)
;
MOZ_ASSERT
(
cursor
=
=
array
-
>
vector
)
;
}
ObjectBox
*
CGObjectList
:
:
find
(
uint32_t
index
)
{
MOZ_ASSERT
(
index
<
length
)
;
ObjectBox
*
box
=
lastbox
;
for
(
unsigned
n
=
length
-
1
;
n
>
index
;
n
-
-
)
box
=
box
-
>
emitLink
;
return
box
;
}
bool
CGTryNoteList
:
:
append
(
JSTryNoteKind
kind
uint32_t
stackDepth
size_t
start
size_t
end
)
{
MOZ_ASSERT
(
start
<
=
end
)
;
MOZ_ASSERT
(
size_t
(
uint32_t
(
start
)
)
=
=
start
)
;
MOZ_ASSERT
(
size_t
(
uint32_t
(
end
)
)
=
=
end
)
;
JSTryNote
note
;
note
.
kind
=
kind
;
note
.
stackDepth
=
stackDepth
;
note
.
start
=
uint32_t
(
start
)
;
note
.
length
=
uint32_t
(
end
-
start
)
;
return
list
.
append
(
note
)
;
}
void
CGTryNoteList
:
:
finish
(
TryNoteArray
*
array
)
{
MOZ_ASSERT
(
length
(
)
=
=
array
-
>
length
)
;
for
(
unsigned
i
=
0
;
i
<
length
(
)
;
i
+
+
)
array
-
>
vector
[
i
]
=
list
[
i
]
;
}
bool
CGBlockScopeList
:
:
append
(
uint32_t
scopeObjectIndex
uint32_t
offset
bool
inPrologue
uint32_t
parent
)
{
CGBlockScopeNote
note
;
mozilla
:
:
PodZero
(
&
note
)
;
note
.
index
=
scopeObjectIndex
;
note
.
start
=
offset
;
note
.
parent
=
parent
;
note
.
startInPrologue
=
inPrologue
;
return
list
.
append
(
note
)
;
}
uint32_t
CGBlockScopeList
:
:
findEnclosingScope
(
uint32_t
index
)
{
MOZ_ASSERT
(
index
<
length
(
)
)
;
MOZ_ASSERT
(
list
[
index
]
.
index
!
=
BlockScopeNote
:
:
NoBlockScopeIndex
)
;
DebugOnly
<
bool
>
inPrologue
=
list
[
index
]
.
startInPrologue
;
DebugOnly
<
uint32_t
>
pos
=
list
[
index
]
.
start
;
while
(
index
-
-
)
{
MOZ_ASSERT_IF
(
inPrologue
=
=
list
[
index
]
.
startInPrologue
list
[
index
]
.
start
<
=
pos
)
;
if
(
list
[
index
]
.
end
=
=
0
)
{
return
list
[
index
]
.
index
;
}
MOZ_ASSERT_IF
(
inPrologue
=
=
list
[
index
]
.
endInPrologue
list
[
index
]
.
end
<
=
pos
)
;
}
return
BlockScopeNote
:
:
NoBlockScopeIndex
;
}
void
CGBlockScopeList
:
:
recordEnd
(
uint32_t
index
uint32_t
offset
bool
inPrologue
)
{
MOZ_ASSERT
(
index
<
length
(
)
)
;
MOZ_ASSERT
(
offset
>
=
list
[
index
]
.
start
)
;
MOZ_ASSERT
(
list
[
index
]
.
length
=
=
0
)
;
list
[
index
]
.
end
=
offset
;
list
[
index
]
.
endInPrologue
=
inPrologue
;
}
void
CGBlockScopeList
:
:
finish
(
BlockScopeArray
*
array
uint32_t
prologueLength
)
{
MOZ_ASSERT
(
length
(
)
=
=
array
-
>
length
)
;
for
(
unsigned
i
=
0
;
i
<
length
(
)
;
i
+
+
)
{
if
(
!
list
[
i
]
.
startInPrologue
)
list
[
i
]
.
start
+
=
prologueLength
;
if
(
!
list
[
i
]
.
endInPrologue
)
list
[
i
]
.
end
+
=
prologueLength
;
list
[
i
]
.
length
=
list
[
i
]
.
end
-
list
[
i
]
.
start
;
array
-
>
vector
[
i
]
=
list
[
i
]
;
}
}
void
CGYieldOffsetList
:
:
finish
(
YieldOffsetArray
&
array
uint32_t
prologueLength
)
{
MOZ_ASSERT
(
length
(
)
=
=
array
.
length
(
)
)
;
for
(
unsigned
i
=
0
;
i
<
length
(
)
;
i
+
+
)
array
[
i
]
=
prologueLength
+
list
[
i
]
;
}
const
JSSrcNoteSpec
js_SrcNoteSpec
[
]
=
{
#
define
DEFINE_SRC_NOTE_SPEC
(
sym
name
arity
)
{
name
arity
}
FOR_EACH_SRC_NOTE_TYPE
(
DEFINE_SRC_NOTE_SPEC
)
#
undef
DEFINE_SRC_NOTE_SPEC
}
;
static
int
SrcNoteArity
(
jssrcnote
*
sn
)
{
MOZ_ASSERT
(
SN_TYPE
(
sn
)
<
SRC_LAST
)
;
return
js_SrcNoteSpec
[
SN_TYPE
(
sn
)
]
.
arity
;
}
JS_FRIEND_API
(
unsigned
)
js
:
:
SrcNoteLength
(
jssrcnote
*
sn
)
{
unsigned
arity
;
jssrcnote
*
base
;
arity
=
SrcNoteArity
(
sn
)
;
for
(
base
=
sn
+
+
;
arity
;
sn
+
+
arity
-
-
)
{
if
(
*
sn
&
SN_4BYTE_OFFSET_FLAG
)
sn
+
=
3
;
}
return
sn
-
base
;
}
JS_FRIEND_API
(
ptrdiff_t
)
js
:
:
GetSrcNoteOffset
(
jssrcnote
*
sn
unsigned
which
)
{
MOZ_ASSERT
(
SN_TYPE
(
sn
)
!
=
SRC_XDELTA
)
;
MOZ_ASSERT
(
(
int
)
which
<
SrcNoteArity
(
sn
)
)
;
for
(
sn
+
+
;
which
;
sn
+
+
which
-
-
)
{
if
(
*
sn
&
SN_4BYTE_OFFSET_FLAG
)
sn
+
=
3
;
}
if
(
*
sn
&
SN_4BYTE_OFFSET_FLAG
)
{
return
(
ptrdiff_t
)
(
(
(
uint32_t
)
(
sn
[
0
]
&
SN_4BYTE_OFFSET_MASK
)
<
<
24
)
|
(
sn
[
1
]
<
<
16
)
|
(
sn
[
2
]
<
<
8
)
|
sn
[
3
]
)
;
}
return
(
ptrdiff_t
)
*
sn
;
}
