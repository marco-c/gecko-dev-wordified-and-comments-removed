#
ifndef
frontend_SourceNotes_h
#
define
frontend_SourceNotes_h
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
typedef
uint8_t
jssrcnote
;
namespace
js
{
class
SrcNote
{
public
:
class
Try
{
public
:
enum
Fields
{
EndOfTryJumpOffset
Count
}
;
}
;
class
ColSpan
{
public
:
enum
Fields
{
Span
Count
}
;
}
;
class
SetLine
{
public
:
enum
Fields
{
Line
Count
}
;
}
;
}
;
#
define
FOR_EACH_SRC_NOTE_TYPE
(
M
)
\
M
(
SRC_NULL
"
null
"
0
)
/
*
Terminates
a
note
vector
.
*
/
\
M
(
SRC_ASSIGNOP
"
assignop
"
0
)
/
*
+
=
or
another
assign
-
op
follows
.
*
/
\
M
(
SRC_CLASS_SPAN
"
class
"
2
)
/
*
The
starting
and
ending
offsets
for
the
class
used
\
for
toString
correctness
for
default
ctors
.
*
/
\
M
(
SRC_TRY
"
try
"
SrcNote
:
:
Try
:
:
Count
)
\
/
*
All
notes
above
here
are
"
gettable
"
.
See
SN_IS_GETTABLE
below
.
*
/
\
M
(
SRC_COLSPAN
"
colspan
"
SrcNote
:
:
ColSpan
:
:
Count
)
\
M
(
SRC_NEWLINE
"
newline
"
0
)
/
*
Bytecode
follows
a
source
newline
.
*
/
\
M
(
SRC_SETLINE
"
setline
"
SrcNote
:
:
SetLine
:
:
Count
)
\
M
(
SRC_BREAKPOINT
"
breakpoint
"
0
)
/
*
Bytecode
is
a
recommended
breakpoint
.
*
/
\
M
(
SRC_STEP_SEP
"
step
-
sep
"
0
)
/
*
Bytecode
is
the
first
in
a
new
steppable
area
.
*
/
\
M
(
SRC_UNUSED9
"
unused
"
0
)
\
M
(
SRC_UNUSED10
"
unused
"
0
)
\
M
(
SRC_UNUSED11
"
unused
"
0
)
\
M
(
SRC_UNUSED12
"
unused
"
0
)
\
M
(
SRC_UNUSED13
"
unused
"
0
)
\
M
(
SRC_UNUSED14
"
unused
"
0
)
\
M
(
SRC_UNUSED15
"
unused
"
0
)
\
M
(
SRC_UNUSED16
"
unused
"
0
)
\
M
(
SRC_UNUSED17
"
unused
"
0
)
\
M
(
SRC_UNUSED18
"
unused
"
0
)
\
M
(
SRC_UNUSED19
"
unused
"
0
)
\
M
(
SRC_UNUSED20
"
unused
"
0
)
\
M
(
SRC_UNUSED21
"
unused
"
0
)
\
M
(
SRC_UNUSED22
"
unused
"
0
)
\
M
(
SRC_UNUSED23
"
unused
"
0
)
\
M
(
SRC_XDELTA
"
xdelta
"
0
)
/
*
24
-
31
are
for
extended
delta
notes
.
*
/
enum
SrcNoteType
{
#
define
DEFINE_SRC_NOTE_TYPE
(
sym
name
arity
)
sym
FOR_EACH_SRC_NOTE_TYPE
(
DEFINE_SRC_NOTE_TYPE
)
#
undef
DEFINE_SRC_NOTE_TYPE
SRC_LAST
SRC_LAST_GETTABLE
=
SRC_TRY
}
;
static_assert
(
SRC_XDELTA
=
=
24
"
SRC_XDELTA
should
be
24
"
)
;
inline
void
SN_MAKE_TERMINATOR
(
jssrcnote
*
sn
)
{
*
sn
=
SRC_NULL
;
}
inline
bool
SN_IS_TERMINATOR
(
jssrcnote
*
sn
)
{
return
*
sn
=
=
SRC_NULL
;
}
}
#
define
SN_TYPE_BITS
5
#
define
SN_DELTA_BITS
3
#
define
SN_XDELTA_BITS
6
#
define
SN_TYPE_MASK
(
js
:
:
BitMask
(
SN_TYPE_BITS
)
<
<
SN_DELTA_BITS
)
#
define
SN_DELTA_MASK
(
(
ptrdiff_t
)
js
:
:
BitMask
(
SN_DELTA_BITS
)
)
#
define
SN_XDELTA_MASK
(
(
ptrdiff_t
)
js
:
:
BitMask
(
SN_XDELTA_BITS
)
)
#
define
SN_MAKE_NOTE
(
sn
t
d
)
\
(
*
(
sn
)
=
(
jssrcnote
)
(
(
(
t
)
<
<
SN_DELTA_BITS
)
|
(
(
d
)
&
SN_DELTA_MASK
)
)
)
#
define
SN_MAKE_XDELTA
(
sn
d
)
\
(
*
(
sn
)
=
(
jssrcnote
)
(
(
SRC_XDELTA
<
<
SN_DELTA_BITS
)
|
(
(
d
)
&
SN_XDELTA_MASK
)
)
)
#
define
SN_IS_XDELTA
(
sn
)
(
(
*
(
sn
)
>
>
SN_DELTA_BITS
)
>
=
SRC_XDELTA
)
#
define
SN_TYPE
(
sn
)
\
(
(
js
:
:
SrcNoteType
)
(
SN_IS_XDELTA
(
sn
)
?
SRC_XDELTA
:
*
(
sn
)
>
>
SN_DELTA_BITS
)
)
#
define
SN_SET_TYPE
(
sn
type
)
SN_MAKE_NOTE
(
sn
type
SN_DELTA
(
sn
)
)
#
define
SN_IS_GETTABLE
(
sn
)
(
SN_TYPE
(
sn
)
<
=
SRC_LAST_GETTABLE
)
#
define
SN_DELTA
(
sn
)
\
(
(
ptrdiff_t
)
(
SN_IS_XDELTA
(
sn
)
?
*
(
sn
)
&
SN_XDELTA_MASK
:
*
(
sn
)
&
SN_DELTA_MASK
)
)
#
define
SN_SET_DELTA
(
sn
delta
)
\
(
SN_IS_XDELTA
(
sn
)
?
SN_MAKE_XDELTA
(
sn
delta
)
\
:
SN_MAKE_NOTE
(
sn
SN_TYPE
(
sn
)
delta
)
)
#
define
SN_DELTA_LIMIT
(
(
ptrdiff_t
)
js
:
:
Bit
(
SN_DELTA_BITS
)
)
#
define
SN_XDELTA_LIMIT
(
(
ptrdiff_t
)
js
:
:
Bit
(
SN_XDELTA_BITS
)
)
#
define
SN_4BYTE_OFFSET_FLAG
0x80
#
define
SN_4BYTE_OFFSET_MASK
0x7f
#
define
SN_OFFSET_BITS
31
#
define
SN_MAX_OFFSET
(
(
(
size_t
)
1
<
<
SN_OFFSET_BITS
)
-
1
)
inline
bool
SN_REPRESENTABLE_OFFSET
(
ptrdiff_t
offset
)
{
return
0
<
=
offset
&
&
size_t
(
offset
)
<
=
SN_MAX_OFFSET
;
}
#
define
SN_COLSPAN_SIGN_BIT
(
1
<
<
(
SN_OFFSET_BITS
-
1
)
)
#
define
SN_MIN_COLSPAN
(
-
SN_COLSPAN_SIGN_BIT
)
#
define
SN_MAX_COLSPAN
(
SN_COLSPAN_SIGN_BIT
-
1
)
inline
bool
SN_REPRESENTABLE_COLSPAN
(
ptrdiff_t
colspan
)
{
return
SN_MIN_COLSPAN
<
=
colspan
&
&
colspan
<
=
SN_MAX_COLSPAN
;
}
inline
ptrdiff_t
SN_OFFSET_TO_COLSPAN
(
ptrdiff_t
offset
)
{
MOZ_ASSERT
(
!
(
offset
&
~
(
(
1U
<
<
SN_OFFSET_BITS
)
-
1
)
)
)
;
return
(
offset
^
SN_COLSPAN_SIGN_BIT
)
-
SN_COLSPAN_SIGN_BIT
;
}
inline
ptrdiff_t
SN_COLSPAN_TO_OFFSET
(
ptrdiff_t
colspan
)
{
ptrdiff_t
offset
=
colspan
&
(
(
1U
<
<
SN_OFFSET_BITS
)
-
1
)
;
MOZ_ASSERT
(
SN_OFFSET_TO_COLSPAN
(
offset
)
=
=
colspan
)
;
return
offset
;
}
#
define
SN_LENGTH
(
sn
)
\
(
(
js_SrcNoteSpec
[
SN_TYPE
(
sn
)
]
.
arity
=
=
0
)
?
1
:
js
:
:
SrcNoteLength
(
sn
)
)
#
define
SN_NEXT
(
sn
)
(
(
sn
)
+
SN_LENGTH
(
sn
)
)
struct
JSSrcNoteSpec
{
const
char
*
name
;
int8_t
arity
;
}
;
extern
JS_FRIEND_DATA
const
JSSrcNoteSpec
js_SrcNoteSpec
[
]
;
namespace
js
{
extern
JS_FRIEND_API
unsigned
SrcNoteLength
(
jssrcnote
*
sn
)
;
extern
JS_FRIEND_API
ptrdiff_t
GetSrcNoteOffset
(
jssrcnote
*
sn
unsigned
which
)
;
}
#
endif
