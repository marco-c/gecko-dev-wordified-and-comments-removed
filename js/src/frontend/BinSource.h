#
ifndef
frontend_BinSource_h
#
define
frontend_BinSource_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
frontend
/
BCEParserHandle
.
h
"
#
include
"
frontend
/
BinToken
.
h
"
#
include
"
frontend
/
BinTokenReaderMultipart
.
h
"
#
include
"
frontend
/
BinTokenReaderTester
.
h
"
#
include
"
frontend
/
FullParseHandler
.
h
"
#
include
"
frontend
/
ParseContext
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
Result
.
h
"
namespace
js
{
namespace
frontend
{
class
BinASTParserBase
:
private
JS
:
:
AutoGCRooter
{
public
:
BinASTParserBase
(
JSContext
*
cx
LifoAlloc
&
alloc
UsedNameTracker
&
usedNames
)
;
~
BinASTParserBase
(
)
;
public
:
bool
hasUsedName
(
HandlePropertyName
name
)
;
void
trace
(
JSTracer
*
trc
)
{
ObjectBox
:
:
TraceList
(
trc
traceListHead_
)
;
}
public
:
ParseNode
*
allocParseNode
(
size_t
size
)
{
MOZ_ASSERT
(
size
=
=
sizeof
(
ParseNode
)
)
;
return
static_cast
<
ParseNode
*
>
(
nodeAlloc_
.
allocNode
(
)
)
;
}
JS_DECLARE_NEW_METHODS
(
new_
allocParseNode
inline
)
friend
void
TraceBinParser
(
JSTracer
*
trc
JS
:
:
AutoGCRooter
*
parser
)
;
protected
:
JSContext
*
cx_
;
protected
:
LifoAlloc
&
alloc_
;
ObjectBox
*
traceListHead_
;
UsedNameTracker
&
usedNames_
;
private
:
LifoAlloc
:
:
Mark
tempPoolMark_
;
ParseNodeAllocator
nodeAlloc_
;
protected
:
AutoKeepAtoms
keepAtoms_
;
ParseContext
*
parseContext_
;
FullParseHandler
factory_
;
friend
class
BinParseContext
;
}
;
template
<
typename
Tok
>
class
BinASTParser
:
public
BinASTParserBase
public
ErrorReporter
public
BCEParserHandle
{
public
:
using
Tokenizer
=
Tok
;
using
AutoList
=
typename
Tokenizer
:
:
AutoList
;
using
AutoTaggedTuple
=
typename
Tokenizer
:
:
AutoTaggedTuple
;
using
AutoTuple
=
typename
Tokenizer
:
:
AutoTuple
;
using
BinFields
=
typename
Tokenizer
:
:
BinFields
;
using
Chars
=
typename
Tokenizer
:
:
Chars
;
public
:
BinASTParser
(
JSContext
*
cx
LifoAlloc
&
alloc
UsedNameTracker
&
usedNames
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
:
BinASTParserBase
(
cx
alloc
usedNames
)
options_
(
options
)
variableDeclarationKind_
(
VariableDeclarationKind
:
:
Var
)
{
}
~
BinASTParser
(
)
{
}
JS
:
:
Result
<
ParseNode
*
>
parse
(
GlobalSharedContext
*
globalsc
const
uint8_t
*
start
const
size_t
length
)
;
JS
:
:
Result
<
ParseNode
*
>
parse
(
GlobalSharedContext
*
globalsc
const
Vector
<
uint8_t
>
&
data
)
;
private
:
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseAux
(
GlobalSharedContext
*
globalsc
const
uint8_t
*
start
const
size_t
length
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseUndeclaredCapture
(
JSAtom
*
name
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseInvalidClosedVar
(
JSAtom
*
name
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseMissingVariableInAssertedScope
(
JSAtom
*
name
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseMissingDirectEvalInAssertedScope
(
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseInvalidKind
(
const
char
*
superKind
const
BinKind
kind
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseInvalidVariant
(
const
char
*
kind
const
BinVariant
value
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseMissingField
(
const
char
*
kind
const
BinField
field
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseEmpty
(
const
char
*
description
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseOOM
(
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseError
(
const
char
*
description
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseError
(
BinKind
kind
const
char
*
description
)
;
void
poison
(
)
;
enum
class
AssertedScopeKind
{
Block
Catch
Global
Parameter
Var
}
;
#
include
"
frontend
/
BinSource
-
auto
.
h
"
JS
:
:
Result
<
ParseNode
*
>
buildFunction
(
const
size_t
start
const
BinKind
kind
ParseNode
*
name
ListNode
*
params
ParseNode
*
body
FunctionBox
*
funbox
)
;
JS
:
:
Result
<
FunctionBox
*
>
buildFunctionBox
(
GeneratorKind
generatorKind
FunctionAsyncKind
functionAsyncKind
FunctionSyntaxKind
syntax
ParseNode
*
name
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
addScopeName
(
AssertedScopeKind
scopeKind
HandleAtom
name
ParseContext
:
:
Scope
*
scope
DeclarationKind
declKind
bool
isCaptured
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
getDeclaredScope
(
AssertedScopeKind
scopeKind
AssertedDeclaredKind
kind
ParseContext
:
:
Scope
*
&
scope
DeclarationKind
&
declKind
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
getBoundScope
(
AssertedScopeKind
scopeKind
ParseContext
:
:
Scope
*
&
scope
DeclarationKind
&
declKind
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
checkBinding
(
JSAtom
*
name
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
checkClosedVars
(
ParseContext
:
:
Scope
&
scope
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
checkFunctionClosedVars
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
appendDirectivesToBody
(
ListNode
*
body
ListNode
*
directives
)
;
private
:
const
JS
:
:
ReadOnlyCompileOptions
&
options_
;
const
JS
:
:
ReadOnlyCompileOptions
&
options
(
)
const
override
{
return
this
-
>
options_
;
}
public
:
virtual
ObjectBox
*
newObjectBox
(
JSObject
*
obj
)
override
{
MOZ_ASSERT
(
obj
)
;
ObjectBox
*
objbox
=
alloc_
.
new_
<
ObjectBox
>
(
obj
traceListHead_
)
;
if
(
!
objbox
)
{
ReportOutOfMemory
(
cx_
)
;
return
nullptr
;
}
traceListHead_
=
objbox
;
return
objbox
;
}
virtual
ErrorReporter
&
errorReporter
(
)
override
{
return
*
this
;
}
virtual
const
ErrorReporter
&
errorReporter
(
)
const
override
{
return
*
this
;
}
virtual
FullParseHandler
&
astGenerator
(
)
override
{
return
factory_
;
}
virtual
void
lineAndColumnAt
(
size_t
offset
uint32_t
*
line
uint32_t
*
column
)
const
override
{
*
line
=
lineAt
(
offset
)
;
*
column
=
columnAt
(
offset
)
;
}
virtual
uint32_t
lineAt
(
size_t
offset
)
const
override
{
return
0
;
}
virtual
uint32_t
columnAt
(
size_t
offset
)
const
override
{
return
offset
;
}
virtual
bool
isOnThisLine
(
size_t
offset
uint32_t
lineNum
bool
*
isOnSameLine
)
const
override
{
if
(
lineNum
!
=
0
)
{
return
false
;
}
*
isOnSameLine
=
true
;
return
true
;
}
virtual
void
currentLineAndColumn
(
uint32_t
*
line
uint32_t
*
column
)
const
override
{
*
line
=
0
;
*
column
=
offset
(
)
;
}
size_t
offset
(
)
const
{
if
(
tokenizer_
.
isSome
(
)
)
{
return
tokenizer_
-
>
offset
(
)
;
}
return
0
;
}
virtual
bool
hasTokenizationStarted
(
)
const
override
{
return
tokenizer_
.
isSome
(
)
;
}
virtual
void
reportErrorNoOffsetVA
(
unsigned
errorNumber
va_list
args
)
override
;
virtual
void
errorAtVA
(
uint32_t
offset
unsigned
errorNumber
va_list
*
args
)
override
;
virtual
bool
reportExtraWarningErrorNumberVA
(
UniquePtr
<
JSErrorNotes
>
notes
uint32_t
offset
unsigned
errorNumber
va_list
*
args
)
override
;
virtual
const
char
*
getFilename
(
)
const
override
{
return
this
-
>
options_
.
filename
(
)
;
}
private
:
mozilla
:
:
Maybe
<
Tokenizer
>
tokenizer_
;
VariableDeclarationKind
variableDeclarationKind_
;
friend
class
BinParseContext
;
friend
class
AutoVariableDeclarationKind
;
class
MOZ_RAII
AutoVariableDeclarationKind
{
public
:
explicit
AutoVariableDeclarationKind
(
BinASTParser
<
Tok
>
*
parser
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
parser_
(
parser
)
kind
(
parser
-
>
variableDeclarationKind_
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoVariableDeclarationKind
(
)
{
parser_
-
>
variableDeclarationKind_
=
kind
;
}
private
:
BinASTParser
<
Tok
>
*
parser_
;
BinASTParser
<
Tok
>
:
:
VariableDeclarationKind
kind
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
}
;
class
BinParseContext
:
public
ParseContext
{
public
:
template
<
typename
Tok
>
BinParseContext
(
JSContext
*
cx
BinASTParser
<
Tok
>
*
parser
SharedContext
*
sc
Directives
*
newDirectives
)
:
ParseContext
(
cx
parser
-
>
parseContext_
sc
*
parser
parser
-
>
usedNames_
newDirectives
true
)
{
}
}
;
extern
template
class
BinASTParser
<
BinTokenReaderMultipart
>
;
extern
template
class
BinASTParser
<
BinTokenReaderTester
>
;
}
}
#
endif
