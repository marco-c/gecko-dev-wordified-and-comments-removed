#
ifndef
frontend_BinSource_h
#
define
frontend_BinSource_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
frontend
/
BinTokenReaderTester
.
h
"
#
include
"
frontend
/
FullParseHandler
.
h
"
#
include
"
frontend
/
ParseContext
.
h
"
#
include
"
frontend
/
ParseNode
.
h
"
#
include
"
frontend
/
SharedContext
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
Result
.
h
"
namespace
js
{
namespace
frontend
{
class
BinASTParser
;
class
BinASTParser
:
private
JS
:
:
AutoGCRooter
public
ErrorReporter
{
using
Names
=
JS
:
:
GCVector
<
JSString
*
8
>
;
using
Tokenizer
=
BinTokenReaderTester
;
using
Chars
=
Tokenizer
:
:
Chars
;
public
:
BinASTParser
(
JSContext
*
cx
LifoAlloc
&
alloc
UsedNameTracker
&
usedNames
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
:
AutoGCRooter
(
cx
BINPARSER
)
traceListHead_
(
nullptr
)
options_
(
options
)
cx_
(
cx
)
alloc_
(
alloc
)
nodeAlloc_
(
cx
alloc
)
keepAtoms_
(
cx
)
parseContext_
(
nullptr
)
usedNames_
(
usedNames
)
factory_
(
cx
alloc
nullptr
SourceKind
:
:
Binary
)
{
cx_
-
>
frontendCollectionPool
(
)
.
addActiveCompilation
(
)
;
tempPoolMark_
=
alloc
.
mark
(
)
;
}
~
BinASTParser
(
)
{
alloc_
.
release
(
tempPoolMark_
)
;
alloc_
.
freeAllIfHugeAndUnused
(
)
;
cx_
-
>
frontendCollectionPool
(
)
.
removeActiveCompilation
(
)
;
}
JS
:
:
Result
<
ParseNode
*
>
parse
(
const
uint8_t
*
start
const
size_t
length
)
;
JS
:
:
Result
<
ParseNode
*
>
parse
(
const
Vector
<
uint8_t
>
&
data
)
;
private
:
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseAux
(
const
uint8_t
*
start
const
size_t
length
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseInvalidKind
(
const
char
*
superKind
const
BinKind
kind
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseInvalidField
(
const
char
*
kind
const
BinField
field
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseInvalidEnum
(
const
char
*
kind
const
Chars
&
value
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseMissingField
(
const
char
*
kind
const
BinField
field
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseEmpty
(
const
char
*
description
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseOOM
(
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseError
(
const
char
*
description
)
;
MOZ_MUST_USE
mozilla
:
:
GenericErrorResult
<
JS
:
:
Error
&
>
raiseError
(
BinKind
kind
const
char
*
description
)
;
void
poison
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseBlockStatement
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseCatchClause
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseExpression
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseForInit
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseForInInit
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseIdentifier
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseObjectPropertyName
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseObjectMember
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parsePattern
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parsePropertyName
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseProgram
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseStatement
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseSwitchCase
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseVariableDeclarator
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseArgumentList
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseDirectiveList
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseExpressionList
(
bool
acceptElisions
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseObjectMemberList
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseStatementList
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseSwitchCaseList
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseArrayExpressionAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseBreakOrContinueStatementAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseBlockStatementAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseExpressionStatementAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseExpressionAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseFunctionAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseIdentifierAux
(
const
BinKind
const
Tokenizer
:
:
BinFields
&
fields
const
bool
expectObjectPropertyName
=
false
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseMemberExpressionAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseNumericLiteralAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseObjectExpressionAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parsePatternAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseStringLiteralAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseStatementAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
parseVariableDeclarationAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
checkEmptyTuple
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
parseElisionAux
(
const
BinKind
kind
const
Tokenizer
:
:
BinFields
&
fields
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
parseAndUpdateCurrentScope
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
parseAndUpdateScope
(
ParseContext
:
:
Scope
&
varScope
ParseContext
:
:
Scope
&
letScope
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
parseAndUpdateScopeNames
(
ParseContext
:
:
Scope
&
scope
DeclarationKind
kind
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
parseStringList
(
MutableHandle
<
Maybe
<
Names
>
>
out
)
;
MOZ_MUST_USE
JS
:
:
Result
<
ParseNode
*
>
appendDirectivesToBody
(
ParseNode
*
body
ParseNode
*
directives
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readString
(
Maybe
<
Chars
>
&
out
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readString
(
MutableHandleAtom
out
)
;
MOZ_MUST_USE
JS
:
:
Result
<
bool
>
readBool
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
double
>
readNumber
(
)
;
const
ReadOnlyCompileOptions
&
options
(
)
const
override
{
return
this
-
>
options_
;
}
bool
hasUsedName
(
HandlePropertyName
name
)
;
void
trace
(
JSTracer
*
trc
)
{
ObjectBox
:
:
TraceList
(
trc
traceListHead_
)
;
}
public
:
ObjectBox
*
newObjectBox
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
obj
)
;
ObjectBox
*
objbox
=
alloc_
.
new_
<
ObjectBox
>
(
obj
traceListHead_
)
;
if
(
!
objbox
)
{
ReportOutOfMemory
(
cx_
)
;
return
nullptr
;
}
traceListHead_
=
objbox
;
return
objbox
;
}
ParseNode
*
allocParseNode
(
size_t
size
)
{
MOZ_ASSERT
(
size
=
=
sizeof
(
ParseNode
)
)
;
return
static_cast
<
ParseNode
*
>
(
nodeAlloc_
.
allocNode
(
)
)
;
}
JS_DECLARE_NEW_METHODS
(
new_
allocParseNode
inline
)
private
:
virtual
void
lineAndColumnAt
(
size_t
offset
uint32_t
*
line
uint32_t
*
column
)
const
override
{
*
line
=
0
;
*
column
=
offset
;
}
virtual
void
currentLineAndColumn
(
uint32_t
*
line
uint32_t
*
column
)
const
override
{
*
line
=
0
;
*
column
=
offset
(
)
;
}
size_t
offset
(
)
const
{
if
(
tokenizer_
.
isSome
(
)
)
return
tokenizer_
-
>
offset
(
)
;
return
0
;
}
virtual
bool
hasTokenizationStarted
(
)
const
override
{
return
tokenizer_
.
isSome
(
)
;
}
virtual
void
reportErrorNoOffsetVA
(
unsigned
errorNumber
va_list
args
)
override
;
virtual
const
char
*
getFilename
(
)
const
override
{
return
this
-
>
options_
.
filename
(
)
;
}
ObjectBox
*
traceListHead_
;
const
ReadOnlyCompileOptions
&
options_
;
JSContext
*
cx_
;
LifoAlloc
&
alloc_
;
LifoAlloc
:
:
Mark
tempPoolMark_
;
ParseNodeAllocator
nodeAlloc_
;
AutoKeepAtoms
keepAtoms_
;
ParseContext
*
parseContext_
;
UsedNameTracker
&
usedNames_
;
Maybe
<
Tokenizer
>
tokenizer_
;
FullParseHandler
factory_
;
friend
class
BinParseContext
;
friend
void
TraceBinParser
(
JSTracer
*
trc
AutoGCRooter
*
parser
)
;
}
;
class
BinParseContext
:
public
ParseContext
{
public
:
BinParseContext
(
JSContext
*
cx
BinASTParser
*
parser
SharedContext
*
sc
Directives
*
newDirectives
)
:
ParseContext
(
cx
parser
-
>
parseContext_
sc
*
parser
parser
-
>
usedNames_
newDirectives
true
)
{
}
}
;
}
}
#
endif
