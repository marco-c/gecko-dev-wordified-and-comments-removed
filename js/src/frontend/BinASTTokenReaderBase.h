#
ifndef
frontend_BinASTTokenReaderBase_h
#
define
frontend_BinASTTokenReaderBase_h
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
string
.
h
>
#
include
"
frontend
/
BinASTToken
.
h
"
#
include
"
frontend
/
ErrorReporter
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
js
{
namespace
frontend
{
extern
const
uint64_t
NULL_FLOAT_REPRESENTATION
;
class
MOZ_STACK_CLASS
BinASTTokenReaderBase
{
public
:
template
<
typename
T
>
using
ErrorResult
=
mozilla
:
:
GenericErrorResult
<
T
>
;
struct
RootContext
{
}
;
struct
ListContext
{
const
BinASTInterfaceAndField
position_
;
const
BinASTList
content_
;
ListContext
(
const
BinASTInterfaceAndField
position
const
BinASTList
content
)
:
position_
(
position
)
content_
(
content
)
{
}
}
;
struct
FieldContext
{
const
BinASTInterfaceAndField
position_
;
explicit
FieldContext
(
const
BinASTInterfaceAndField
position
)
:
position_
(
position
)
{
}
}
;
using
FieldOrRootContext
=
mozilla
:
:
Variant
<
FieldContext
RootContext
>
;
using
FieldOrListContext
=
mozilla
:
:
Variant
<
FieldContext
ListContext
>
;
#
ifdef
DEBUG
struct
ContextPrinter
{
static
void
print
(
const
char
*
text
const
FieldOrRootContext
&
context
)
{
fprintf
(
stderr
"
%
s
"
text
)
;
context
.
match
(
ContextPrinter
(
)
)
;
fprintf
(
stderr
"
\
n
"
)
;
}
static
void
print
(
const
char
*
text
const
FieldOrListContext
&
context
)
{
fprintf
(
stderr
"
%
s
"
text
)
;
context
.
match
(
ContextPrinter
(
)
)
;
fprintf
(
stderr
"
\
n
"
)
;
}
void
operator
(
)
(
const
RootContext
&
)
{
fprintf
(
stderr
"
<
Root
context
>
"
)
;
}
void
operator
(
)
(
const
ListContext
&
context
)
{
fprintf
(
stderr
"
<
List
context
>
:
%
s
=
>
%
s
"
describeBinASTInterfaceAndField
(
context
.
position_
)
describeBinASTList
(
context
.
content_
)
)
;
}
void
operator
(
)
(
const
FieldContext
&
context
)
{
fprintf
(
stderr
"
<
Field
context
>
:
%
s
"
describeBinASTInterfaceAndField
(
context
.
position_
)
)
;
}
}
;
#
endif
class
SkippableSubTree
{
public
:
SkippableSubTree
(
const
size_t
startOffset
const
size_t
length
)
:
startOffset_
(
startOffset
)
length_
(
length
)
{
}
size_t
startOffset
(
)
const
{
return
startOffset_
;
}
size_t
length
(
)
const
{
return
length_
;
}
private
:
const
size_t
startOffset_
;
const
size_t
length_
;
}
;
TokenPos
pos
(
)
;
TokenPos
pos
(
size_t
startOffset
)
;
size_t
offset
(
)
const
{
return
current_
-
start_
;
}
void
seek
(
size_t
offset
)
;
void
poison
(
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseError
(
const
char
*
description
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseOOM
(
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidNumberOfFields
(
const
BinASTKind
kind
const
uint32_t
expected
const
uint32_t
got
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidField
(
const
char
*
kind
const
BinASTField
field
)
;
protected
:
BinASTTokenReaderBase
(
JSContext
*
cx
ErrorReporter
*
er
const
uint8_t
*
start
const
size_t
length
)
:
cx_
(
cx
)
errorReporter_
(
er
)
poisoned_
(
false
)
start_
(
start
)
current_
(
start
)
stop_
(
start
+
length
)
latestKnownGoodPos_
(
0
)
{
MOZ_ASSERT
(
errorReporter_
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
uint8_t
>
readByte
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readBuf
(
uint8_t
*
bytes
uint32_t
len
)
;
template
<
size_t
N
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readConst
(
const
char
(
&
value
)
[
N
]
)
{
updateLatestKnownGood
(
)
;
if
(
MOZ_UNLIKELY
(
!
matchConst
(
value
false
)
)
)
{
return
raiseError
(
"
Could
not
find
expected
literal
"
)
;
}
return
Ok
(
)
;
}
template
<
size_t
N
>
MOZ_MUST_USE
bool
matchConst
(
const
char
(
&
value
)
[
N
]
bool
expectNul
)
{
MOZ_ASSERT
(
N
>
0
)
;
MOZ_ASSERT
(
value
[
N
-
1
]
=
=
0
)
;
MOZ_ASSERT
(
!
hasRaisedError
(
)
)
;
if
(
MOZ_UNLIKELY
(
current_
+
N
-
1
>
stop_
)
)
{
return
false
;
}
#
ifndef
FUZZING
if
(
memcmp
(
current_
value
N
+
(
expectNul
?
0
:
-
1
)
)
!
=
0
)
{
return
false
;
}
#
endif
current_
+
=
N
+
(
expectNul
?
0
:
-
1
)
;
updateLatestKnownGood
(
)
;
return
true
;
}
void
updateLatestKnownGood
(
)
;
bool
hasRaisedError
(
)
const
;
JSContext
*
cx_
;
ErrorReporter
*
errorReporter_
;
bool
poisoned_
;
const
uint8_t
*
start_
;
const
uint8_t
*
current_
;
const
uint8_t
*
stop_
;
size_t
latestKnownGoodPos_
;
private
:
BinASTTokenReaderBase
(
const
BinASTTokenReaderBase
&
)
=
delete
;
BinASTTokenReaderBase
(
BinASTTokenReaderBase
&
&
)
=
delete
;
BinASTTokenReaderBase
&
operator
=
(
BinASTTokenReaderBase
&
)
=
delete
;
}
;
}
}
#
endif
