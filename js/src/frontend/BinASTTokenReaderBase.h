#
ifndef
frontend_BinASTTokenReaderBase_h
#
define
frontend_BinASTTokenReaderBase_h
#
include
"
frontend
/
BinASTToken
.
h
"
#
include
"
frontend
/
ErrorReporter
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
js
/
Result
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
js
{
namespace
frontend
{
extern
const
uint64_t
NULL_FLOAT_REPRESENTATION
;
class
MOZ_STACK_CLASS
BinASTTokenReaderBase
{
public
:
template
<
typename
T
>
using
ErrorResult
=
mozilla
:
:
GenericErrorResult
<
T
>
;
struct
Context
{
constexpr
static
Context
topLevel
(
)
{
return
Context
(
BinASTKind
:
:
_Null
0
ElementOf
:
:
TaggedTuple
)
;
}
Context
arrayElement
(
)
const
{
return
Context
(
kind
fieldIndex
ElementOf
:
:
Array
)
;
}
constexpr
static
Context
firstField
(
BinASTKind
kind
)
{
return
Context
(
kind
0
ElementOf
:
:
TaggedTuple
)
;
}
const
Context
operator
+
+
(
int
)
{
MOZ_ASSERT
(
elementOf
=
=
ElementOf
:
:
TaggedTuple
)
;
Context
result
=
*
this
;
fieldIndex
+
+
;
return
result
;
}
BinASTKind
kind
;
uint8_t
fieldIndex
;
enum
class
ElementOf
{
Array
TaggedTuple
}
;
ElementOf
elementOf
;
Context
(
)
=
delete
;
private
:
constexpr
Context
(
BinASTKind
kind_
uint8_t
fieldIndex_
ElementOf
elementOf_
)
:
kind
(
kind_
)
fieldIndex
(
fieldIndex_
)
elementOf
(
elementOf_
)
{
}
}
;
class
SkippableSubTree
{
public
:
SkippableSubTree
(
const
size_t
startOffset
const
size_t
length
)
:
startOffset_
(
startOffset
)
length_
(
length
)
{
}
size_t
startOffset
(
)
const
{
return
startOffset_
;
}
size_t
length
(
)
const
{
return
length_
;
}
private
:
const
size_t
startOffset_
;
const
size_t
length_
;
}
;
TokenPos
pos
(
)
;
TokenPos
pos
(
size_t
startOffset
)
;
size_t
offset
(
)
const
;
void
seek
(
size_t
offset
)
;
void
poison
(
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseError
(
const
char
*
description
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseOOM
(
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidNumberOfFields
(
const
BinASTKind
kind
const
uint32_t
expected
const
uint32_t
got
)
;
MOZ_MUST_USE
ErrorResult
<
JS
:
:
Error
&
>
raiseInvalidField
(
const
char
*
kind
const
BinASTField
field
)
;
protected
:
BinASTTokenReaderBase
(
JSContext
*
cx
ErrorReporter
*
er
const
uint8_t
*
start
const
size_t
length
)
:
cx_
(
cx
)
errorReporter_
(
er
)
poisoned_
(
false
)
start_
(
start
)
current_
(
start
)
stop_
(
start
+
length
)
latestKnownGoodPos_
(
0
)
{
MOZ_ASSERT
(
errorReporter_
)
;
}
MOZ_MUST_USE
JS
:
:
Result
<
uint8_t
>
readByte
(
)
;
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readBuf
(
uint8_t
*
bytes
uint32_t
len
)
;
template
<
size_t
N
>
MOZ_MUST_USE
JS
:
:
Result
<
Ok
>
readConst
(
const
char
(
&
value
)
[
N
]
)
{
updateLatestKnownGood
(
)
;
if
(
!
matchConst
(
value
false
)
)
{
return
raiseError
(
"
Could
not
find
expected
literal
"
)
;
}
return
Ok
(
)
;
}
template
<
size_t
N
>
MOZ_MUST_USE
bool
matchConst
(
const
char
(
&
value
)
[
N
]
bool
expectNul
)
{
MOZ_ASSERT
(
N
>
0
)
;
MOZ_ASSERT
(
value
[
N
-
1
]
=
=
0
)
;
MOZ_ASSERT
(
!
hasRaisedError
(
)
)
;
if
(
current_
+
N
-
1
>
stop_
)
{
return
false
;
}
#
ifndef
FUZZING
if
(
!
std
:
:
equal
(
current_
current_
+
N
+
(
expectNul
?
0
:
-
1
)
value
)
)
{
return
false
;
}
#
endif
current_
+
=
N
+
(
expectNul
?
0
:
-
1
)
;
updateLatestKnownGood
(
)
;
return
true
;
}
void
updateLatestKnownGood
(
)
;
bool
hasRaisedError
(
)
const
;
JSContext
*
cx_
;
ErrorReporter
*
errorReporter_
;
bool
poisoned_
;
const
uint8_t
*
start_
;
const
uint8_t
*
current_
;
const
uint8_t
*
stop_
;
size_t
latestKnownGoodPos_
;
private
:
BinASTTokenReaderBase
(
const
BinASTTokenReaderBase
&
)
=
delete
;
BinASTTokenReaderBase
(
BinASTTokenReaderBase
&
&
)
=
delete
;
BinASTTokenReaderBase
&
operator
=
(
BinASTTokenReaderBase
&
)
=
delete
;
}
;
}
}
#
endif
