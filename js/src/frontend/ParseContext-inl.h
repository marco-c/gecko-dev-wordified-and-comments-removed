#
ifndef
frontend_ParseContext_inl_h
#
define
frontend_ParseContext_inl_h
#
include
"
frontend
/
ParseContext
.
h
"
namespace
js
{
namespace
frontend
{
template
<
>
inline
bool
ParseContext
:
:
Statement
:
:
is
<
ParseContext
:
:
LabelStatement
>
(
)
const
{
return
kind_
=
=
StatementKind
:
:
Label
;
}
template
<
>
inline
bool
ParseContext
:
:
Statement
:
:
is
<
ParseContext
:
:
ClassStatement
>
(
)
const
{
return
kind_
=
=
StatementKind
:
:
Class
;
}
inline
JS
:
:
Result
<
Ok
ParseContext
:
:
BreakStatementError
>
ParseContext
:
:
checkBreakStatement
(
PropertyName
*
label
)
{
if
(
label
)
{
auto
hasSameLabel
=
[
&
label
]
(
ParseContext
:
:
LabelStatement
*
stmt
)
{
MOZ_ASSERT
(
stmt
)
;
return
stmt
-
>
label
(
)
=
=
label
;
}
;
if
(
!
findInnermostStatement
<
ParseContext
:
:
LabelStatement
>
(
hasSameLabel
)
)
{
return
mozilla
:
:
Err
(
ParseContext
:
:
BreakStatementError
:
:
LabelNotFound
)
;
}
}
else
{
auto
isBreakTarget
=
[
]
(
ParseContext
:
:
Statement
*
stmt
)
{
return
StatementKindIsUnlabeledBreakTarget
(
stmt
-
>
kind
(
)
)
;
}
;
if
(
!
findInnermostStatement
(
isBreakTarget
)
)
{
return
mozilla
:
:
Err
(
ParseContext
:
:
BreakStatementError
:
:
ToughBreak
)
;
}
}
return
Ok
(
)
;
}
inline
JS
:
:
Result
<
Ok
ParseContext
:
:
ContinueStatementError
>
ParseContext
:
:
checkContinueStatement
(
PropertyName
*
label
)
{
auto
isLoop
=
[
]
(
ParseContext
:
:
Statement
*
stmt
)
{
MOZ_ASSERT
(
stmt
)
;
return
StatementKindIsLoop
(
stmt
-
>
kind
(
)
)
;
}
;
if
(
!
label
)
{
if
(
!
findInnermostStatement
(
isLoop
)
)
{
return
mozilla
:
:
Err
(
ParseContext
:
:
ContinueStatementError
:
:
NotInALoop
)
;
}
return
Ok
(
)
;
}
ParseContext
:
:
Statement
*
stmt
=
innermostStatement
(
)
;
bool
foundLoop
=
false
;
for
(
;
;
)
{
stmt
=
ParseContext
:
:
Statement
:
:
findNearest
(
stmt
isLoop
)
;
if
(
!
stmt
)
{
return
foundLoop
?
mozilla
:
:
Err
(
ParseContext
:
:
ContinueStatementError
:
:
LabelNotFound
)
:
mozilla
:
:
Err
(
ParseContext
:
:
ContinueStatementError
:
:
NotInALoop
)
;
}
foundLoop
=
true
;
stmt
=
stmt
-
>
enclosing
(
)
;
while
(
stmt
&
&
stmt
-
>
is
<
ParseContext
:
:
LabelStatement
>
(
)
)
{
if
(
stmt
-
>
as
<
ParseContext
:
:
LabelStatement
>
(
)
.
label
(
)
=
=
label
)
{
return
Ok
(
)
;
}
stmt
=
stmt
-
>
enclosing
(
)
;
}
}
}
}
}
#
endif
