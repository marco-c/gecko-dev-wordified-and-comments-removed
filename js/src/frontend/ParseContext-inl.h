#
ifndef
frontend_ParseContext_inl_h
#
define
frontend_ParseContext_inl_h
#
include
"
frontend
/
ParseContext
.
h
"
#
include
"
frontend
/
Parser
.
h
"
#
include
"
vm
/
JSContext
.
h
"
namespace
js
{
namespace
frontend
{
template
<
>
inline
bool
ParseContext
:
:
Statement
:
:
is
<
ParseContext
:
:
LabelStatement
>
(
)
const
{
return
kind_
=
=
StatementKind
:
:
Label
;
}
template
<
>
inline
bool
ParseContext
:
:
Statement
:
:
is
<
ParseContext
:
:
ClassStatement
>
(
)
const
{
return
kind_
=
=
StatementKind
:
:
Class
;
}
template
<
typename
T
>
inline
T
&
ParseContext
:
:
Statement
:
:
as
(
)
{
MOZ_ASSERT
(
is
<
T
>
(
)
)
;
return
static_cast
<
T
&
>
(
*
this
)
;
}
inline
ParseContext
:
:
Scope
:
:
BindingIter
ParseContext
:
:
Scope
:
:
bindings
(
ParseContext
*
pc
)
{
return
BindingIter
(
*
this
pc
-
>
varScope_
=
=
this
|
|
pc
-
>
functionScope_
.
ptrOr
(
nullptr
)
=
=
this
)
;
}
inline
ParseContext
:
:
Scope
:
:
Scope
(
ParserBase
*
parser
)
:
Nestable
<
Scope
>
(
&
parser
-
>
pc_
-
>
innermostScope_
)
declared_
(
parser
-
>
fc_
-
>
nameCollectionPool
(
)
)
possibleAnnexBFunctionBoxes_
(
parser
-
>
fc_
-
>
nameCollectionPool
(
)
)
id_
(
parser
-
>
usedNames_
.
nextScopeId
(
)
)
{
}
inline
ParseContext
:
:
Scope
:
:
Scope
(
FrontendContext
*
fc
ParseContext
*
pc
UsedNameTracker
&
usedNames
)
:
Nestable
<
Scope
>
(
&
pc
-
>
innermostScope_
)
declared_
(
fc
-
>
nameCollectionPool
(
)
)
possibleAnnexBFunctionBoxes_
(
fc
-
>
nameCollectionPool
(
)
)
id_
(
usedNames
.
nextScopeId
(
)
)
{
}
inline
ParseContext
:
:
VarScope
:
:
VarScope
(
ParserBase
*
parser
)
:
Scope
(
parser
)
{
useAsVarScope
(
parser
-
>
pc_
)
;
}
inline
ParseContext
:
:
VarScope
:
:
VarScope
(
FrontendContext
*
fc
ParseContext
*
pc
UsedNameTracker
&
usedNames
)
:
Scope
(
fc
pc
usedNames
)
{
useAsVarScope
(
pc
)
;
}
inline
JS
:
:
Result
<
Ok
ParseContext
:
:
BreakStatementError
>
ParseContext
:
:
checkBreakStatement
(
TaggedParserAtomIndex
label
)
{
if
(
label
)
{
auto
hasSameLabel
=
[
&
label
]
(
ParseContext
:
:
LabelStatement
*
stmt
)
{
MOZ_ASSERT
(
stmt
)
;
return
stmt
-
>
label
(
)
=
=
label
;
}
;
if
(
!
findInnermostStatement
<
ParseContext
:
:
LabelStatement
>
(
hasSameLabel
)
)
{
return
mozilla
:
:
Err
(
ParseContext
:
:
BreakStatementError
:
:
LabelNotFound
)
;
}
}
else
{
auto
isBreakTarget
=
[
]
(
ParseContext
:
:
Statement
*
stmt
)
{
return
StatementKindIsUnlabeledBreakTarget
(
stmt
-
>
kind
(
)
)
;
}
;
if
(
!
findInnermostStatement
(
isBreakTarget
)
)
{
return
mozilla
:
:
Err
(
ParseContext
:
:
BreakStatementError
:
:
ToughBreak
)
;
}
}
return
Ok
(
)
;
}
inline
JS
:
:
Result
<
Ok
ParseContext
:
:
ContinueStatementError
>
ParseContext
:
:
checkContinueStatement
(
TaggedParserAtomIndex
label
)
{
auto
isLoop
=
[
]
(
ParseContext
:
:
Statement
*
stmt
)
{
MOZ_ASSERT
(
stmt
)
;
return
StatementKindIsLoop
(
stmt
-
>
kind
(
)
)
;
}
;
if
(
!
label
)
{
if
(
!
findInnermostStatement
(
isLoop
)
)
{
return
mozilla
:
:
Err
(
ParseContext
:
:
ContinueStatementError
:
:
NotInALoop
)
;
}
return
Ok
(
)
;
}
ParseContext
:
:
Statement
*
stmt
=
innermostStatement
(
)
;
bool
foundLoop
=
false
;
for
(
;
;
)
{
stmt
=
ParseContext
:
:
Statement
:
:
findNearest
(
stmt
isLoop
)
;
if
(
!
stmt
)
{
return
foundLoop
?
mozilla
:
:
Err
(
ParseContext
:
:
ContinueStatementError
:
:
LabelNotFound
)
:
mozilla
:
:
Err
(
ParseContext
:
:
ContinueStatementError
:
:
NotInALoop
)
;
}
foundLoop
=
true
;
stmt
=
stmt
-
>
enclosing
(
)
;
while
(
stmt
&
&
stmt
-
>
is
<
ParseContext
:
:
LabelStatement
>
(
)
)
{
if
(
stmt
-
>
as
<
ParseContext
:
:
LabelStatement
>
(
)
.
label
(
)
=
=
label
)
{
return
Ok
(
)
;
}
stmt
=
stmt
-
>
enclosing
(
)
;
}
}
}
template
<
typename
DeclaredNamePtrT
>
inline
void
RedeclareVar
(
DeclaredNamePtrT
ptr
DeclarationKind
kind
)
{
#
ifdef
DEBUG
DeclarationKind
declaredKind
=
ptr
-
>
value
(
)
-
>
kind
(
)
;
MOZ_ASSERT
(
DeclarationKindIsVar
(
declaredKind
)
)
;
#
endif
if
(
kind
=
=
DeclarationKind
:
:
BodyLevelFunction
)
{
MOZ_ASSERT
(
declaredKind
!
=
DeclarationKind
:
:
VarForAnnexBLexicalFunction
)
;
ptr
-
>
value
(
)
-
>
alterKind
(
kind
)
;
}
}
}
}
#
endif
