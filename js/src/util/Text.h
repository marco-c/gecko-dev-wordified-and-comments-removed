#
ifndef
util_Text_h
#
define
util_Text_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Latin1
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
<
algorithm
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
NamespaceImports
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
util
/
Unicode
.
h
"
#
include
"
vm
/
Printer
.
h
"
class
JSLinearString
;
static
MOZ_ALWAYS_INLINE
size_t
js_strlen
(
const
char16_t
*
s
)
{
return
std
:
:
char_traits
<
char16_t
>
:
:
length
(
s
)
;
}
template
<
typename
CharT
>
extern
const
CharT
*
js_strchr_limit
(
const
CharT
*
s
char16_t
c
const
CharT
*
limit
)
;
template
<
typename
CharT
>
static
MOZ_ALWAYS_INLINE
size_t
js_strnlen
(
const
CharT
*
s
size_t
maxlen
)
{
for
(
size_t
i
=
0
;
i
<
maxlen
;
+
+
i
)
{
if
(
s
[
i
]
=
=
'
\
0
'
)
{
return
i
;
}
}
return
maxlen
;
}
extern
int32_t
js_fputs
(
const
char16_t
*
s
FILE
*
f
)
;
namespace
js
{
class
StringBuffer
;
template
<
typename
CharT
>
constexpr
uint8_t
AsciiDigitToNumber
(
CharT
c
)
{
using
UnsignedCharT
=
std
:
:
make_unsigned_t
<
CharT
>
;
auto
uc
=
static_cast
<
UnsignedCharT
>
(
c
)
;
return
uc
-
'
0
'
;
}
template
<
typename
CharT
>
static
constexpr
bool
IsAsciiPrintable
(
CharT
c
)
{
using
UnsignedCharT
=
std
:
:
make_unsigned_t
<
CharT
>
;
auto
uc
=
static_cast
<
UnsignedCharT
>
(
c
)
;
return
'
'
<
=
uc
&
&
uc
<
=
'
~
'
;
}
template
<
typename
Char1
typename
Char2
>
inline
bool
EqualChars
(
const
Char1
*
s1
const
Char2
*
s2
size_t
len
)
{
return
mozilla
:
:
ArrayEqual
(
s1
s2
len
)
;
}
template
<
typename
Char1
typename
Char2
>
inline
int32_t
CompareChars
(
const
Char1
*
s1
size_t
len1
const
Char2
*
s2
size_t
len2
)
{
size_t
n
=
std
:
:
min
(
len1
len2
)
;
for
(
size_t
i
=
0
;
i
<
n
;
i
+
+
)
{
if
(
int32_t
cmp
=
s1
[
i
]
-
s2
[
i
]
)
{
return
cmp
;
}
}
return
int32_t
(
len1
-
len2
)
;
}
template
<
typename
CharT
>
static
inline
const
CharT
*
SkipSpace
(
const
CharT
*
s
const
CharT
*
end
)
{
MOZ_ASSERT
(
s
<
=
end
)
;
while
(
s
<
end
&
&
unicode
:
:
IsSpace
(
*
s
)
)
{
s
+
+
;
}
return
s
;
}
extern
UniqueChars
DuplicateStringToArena
(
arena_id_t
destArenaId
JSContext
*
cx
const
char
*
s
)
;
extern
UniqueChars
DuplicateStringToArena
(
arena_id_t
destArenaId
JSContext
*
cx
const
char
*
s
size_t
n
)
;
extern
UniqueTwoByteChars
DuplicateStringToArena
(
arena_id_t
destArenaId
JSContext
*
cx
const
char16_t
*
s
)
;
extern
UniqueTwoByteChars
DuplicateStringToArena
(
arena_id_t
destArenaId
JSContext
*
cx
const
char16_t
*
s
size_t
n
)
;
extern
UniqueChars
DuplicateStringToArena
(
arena_id_t
destArenaId
const
char
*
s
)
;
extern
UniqueChars
DuplicateStringToArena
(
arena_id_t
destArenaId
const
char
*
s
size_t
n
)
;
extern
UniqueTwoByteChars
DuplicateStringToArena
(
arena_id_t
destArenaId
const
char16_t
*
s
)
;
extern
UniqueTwoByteChars
DuplicateStringToArena
(
arena_id_t
destArenaId
const
char16_t
*
s
size_t
n
)
;
extern
UniqueChars
DuplicateString
(
JSContext
*
cx
const
char
*
s
)
;
extern
UniqueChars
DuplicateString
(
JSContext
*
cx
const
char
*
s
size_t
n
)
;
extern
UniqueTwoByteChars
DuplicateString
(
JSContext
*
cx
const
char16_t
*
s
)
;
extern
UniqueTwoByteChars
DuplicateString
(
JSContext
*
cx
const
char16_t
*
s
size_t
n
)
;
extern
UniqueChars
DuplicateString
(
const
char
*
s
)
;
extern
UniqueChars
DuplicateString
(
const
char
*
s
size_t
n
)
;
extern
UniqueTwoByteChars
DuplicateString
(
const
char16_t
*
s
)
;
extern
UniqueTwoByteChars
DuplicateString
(
const
char16_t
*
s
size_t
n
)
;
extern
char16_t
*
InflateString
(
JSContext
*
cx
const
char
*
bytes
size_t
length
)
;
inline
void
CopyAndInflateChars
(
char16_t
*
dst
const
char
*
src
size_t
srclen
)
{
mozilla
:
:
ConvertLatin1toUtf16
(
mozilla
:
:
MakeSpan
(
src
srclen
)
mozilla
:
:
MakeSpan
(
dst
srclen
)
)
;
}
inline
void
CopyAndInflateChars
(
char16_t
*
dst
const
JS
:
:
Latin1Char
*
src
size_t
srclen
)
{
mozilla
:
:
ConvertLatin1toUtf16
(
mozilla
:
:
AsChars
(
mozilla
:
:
MakeSpan
(
src
srclen
)
)
mozilla
:
:
MakeSpan
(
dst
srclen
)
)
;
}
extern
uint32_t
OneUcs4ToUtf8Char
(
uint8_t
*
utf8Buffer
uint32_t
ucs4Char
)
;
extern
size_t
PutEscapedStringImpl
(
char
*
buffer
size_t
size
GenericPrinter
*
out
JSLinearString
*
str
uint32_t
quote
)
;
template
<
typename
CharT
>
extern
size_t
PutEscapedStringImpl
(
char
*
buffer
size_t
bufferSize
GenericPrinter
*
out
const
CharT
*
chars
size_t
length
uint32_t
quote
)
;
inline
size_t
PutEscapedString
(
char
*
buffer
size_t
size
JSLinearString
*
str
uint32_t
quote
)
{
size_t
n
=
PutEscapedStringImpl
(
buffer
size
nullptr
str
quote
)
;
MOZ_ASSERT
(
n
!
=
size_t
(
-
1
)
)
;
return
n
;
}
template
<
typename
CharT
>
inline
size_t
PutEscapedString
(
char
*
buffer
size_t
bufferSize
const
CharT
*
chars
size_t
length
uint32_t
quote
)
{
size_t
n
=
PutEscapedStringImpl
(
buffer
bufferSize
nullptr
chars
length
quote
)
;
MOZ_ASSERT
(
n
!
=
size_t
(
-
1
)
)
;
return
n
;
}
inline
bool
EscapedStringPrinter
(
GenericPrinter
&
out
JSLinearString
*
str
uint32_t
quote
)
{
return
PutEscapedStringImpl
(
nullptr
0
&
out
str
quote
)
!
=
size_t
(
-
1
)
;
}
inline
bool
EscapedStringPrinter
(
GenericPrinter
&
out
const
char
*
chars
size_t
length
uint32_t
quote
)
{
return
PutEscapedStringImpl
(
nullptr
0
&
out
chars
length
quote
)
!
=
size_t
(
-
1
)
;
}
inline
bool
FileEscapedString
(
FILE
*
fp
JSLinearString
*
str
uint32_t
quote
)
{
Fprinter
out
(
fp
)
;
bool
res
=
EscapedStringPrinter
(
out
str
quote
)
;
out
.
finish
(
)
;
return
res
;
}
inline
bool
FileEscapedString
(
FILE
*
fp
const
char
*
chars
size_t
length
uint32_t
quote
)
{
Fprinter
out
(
fp
)
;
bool
res
=
EscapedStringPrinter
(
out
chars
length
quote
)
;
out
.
finish
(
)
;
return
res
;
}
JSString
*
EncodeURI
(
JSContext
*
cx
const
char
*
chars
size_t
length
)
;
bool
ContainsFlag
(
const
char
*
str
const
char
*
flag
)
;
namespace
unicode
{
extern
size_t
CountCodePoints
(
const
mozilla
:
:
Utf8Unit
*
begin
const
mozilla
:
:
Utf8Unit
*
end
)
;
extern
size_t
CountCodePoints
(
const
char16_t
*
begin
const
char16_t
*
end
)
;
}
}
#
endif
