#
include
"
util
/
NativeStack
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
ifdef
XP_WIN
#
include
"
util
/
WindowsWrapper
.
h
"
#
elif
defined
(
__wasi__
)
#
elif
defined
(
XP_DARWIN
)
|
|
defined
(
DARWIN
)
|
|
defined
(
XP_UNIX
)
#
include
<
pthread
.
h
>
#
if
defined
(
__FreeBSD__
)
|
|
defined
(
__OpenBSD__
)
|
|
defined
(
__DragonFly__
)
#
include
<
pthread_np
.
h
>
#
endif
#
if
defined
(
SOLARIS
)
|
|
defined
(
AIX
)
#
include
<
ucontext
.
h
>
#
endif
#
if
defined
(
ANDROID
)
&
&
!
defined
(
__aarch64__
)
#
include
<
sys
/
types
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
if
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
&
&
defined
(
__GLIBC__
)
#
include
<
dlfcn
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
unistd
.
h
>
#
define
gettid
(
)
static_cast
<
pid_t
>
(
syscall
(
__NR_gettid
)
)
#
endif
#
else
#
error
"
Unsupported
platform
"
#
endif
#
include
"
js
/
friend
/
StackLimits
.
h
"
#
if
defined
(
XP_WIN
)
void
*
js
:
:
GetNativeStackBaseImpl
(
)
{
PNT_TIB
pTib
=
reinterpret_cast
<
PNT_TIB
>
(
NtCurrentTeb
(
)
)
;
return
static_cast
<
void
*
>
(
pTib
-
>
StackBase
)
;
}
#
elif
defined
(
SOLARIS
)
static_assert
(
JS_STACK_GROWTH_DIRECTION
<
0
)
;
void
*
js
:
:
GetNativeStackBaseImpl
(
)
{
stack_t
st
;
stack_getbounds
(
&
st
)
;
return
static_cast
<
char
*
>
(
st
.
ss_sp
)
+
st
.
ss_size
;
}
#
elif
defined
(
AIX
)
static_assert
(
JS_STACK_GROWTH_DIRECTION
<
0
)
;
void
*
js
:
:
GetNativeStackBaseImpl
(
)
{
ucontext_t
context
;
getcontext
(
&
context
)
;
return
static_cast
<
char
*
>
(
context
.
uc_stack
.
ss_sp
)
+
context
.
uc_stack
.
ss_size
;
}
#
elif
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
&
&
defined
(
__GLIBC__
)
void
*
js
:
:
GetNativeStackBaseImpl
(
)
{
if
(
gettid
(
)
=
=
getpid
(
)
)
{
void
*
*
pLibcStackEnd
=
(
void
*
*
)
dlsym
(
RTLD_DEFAULT
"
__libc_stack_end
"
)
;
MOZ_RELEASE_ASSERT
(
pLibcStackEnd
"
__libc_stack_end
unavailable
unable
to
setup
stack
range
for
JS
"
)
;
void
*
stackBase
=
*
pLibcStackEnd
;
MOZ_RELEASE_ASSERT
(
stackBase
"
invalid
stack
base
unable
to
setup
stack
range
for
JS
"
)
;
return
stackBase
;
}
pthread_t
thread
=
pthread_self
(
)
;
pthread_attr_t
sattr
;
pthread_attr_init
(
&
sattr
)
;
int
rc
=
pthread_getattr_np
(
thread
&
sattr
)
;
MOZ_RELEASE_ASSERT
(
rc
=
=
0
"
pthread_getattr_np
failed
"
)
;
void
*
stackBase
=
nullptr
;
size_t
stackSize
=
0
;
rc
=
pthread_attr_getstack
(
&
sattr
&
stackBase
&
stackSize
)
;
MOZ_RELEASE_ASSERT
(
rc
=
=
0
"
call
to
pthread_attr_getstack
failed
unable
to
setup
"
"
stack
range
for
JS
"
)
;
MOZ_RELEASE_ASSERT
(
stackBase
"
invalid
stack
base
unable
to
setup
stack
range
for
JS
"
)
;
pthread_attr_destroy
(
&
sattr
)
;
#
if
JS_STACK_GROWTH_DIRECTION
>
0
return
stackBase
;
#
else
return
static_cast
<
char
*
>
(
stackBase
)
+
stackSize
;
#
endif
}
#
elif
defined
(
__wasi__
)
static
void
*
const
NativeStackBase
=
__builtin_frame_address
(
0
)
;
void
*
js
:
:
GetNativeStackBaseImpl
(
)
{
MOZ_ASSERT
(
JS_STACK_GROWTH_DIRECTION
<
0
)
;
return
NativeStackBase
;
}
#
else
void
*
js
:
:
GetNativeStackBaseImpl
(
)
{
pthread_t
thread
=
pthread_self
(
)
;
#
if
defined
(
XP_DARWIN
)
|
|
defined
(
DARWIN
)
return
pthread_get_stackaddr_np
(
thread
)
;
#
else
pthread_attr_t
sattr
;
pthread_attr_init
(
&
sattr
)
;
#
if
defined
(
__OpenBSD__
)
stack_t
ss
;
#
elif
defined
(
PTHREAD_NP_H
)
|
|
defined
(
_PTHREAD_NP_H_
)
|
|
defined
(
NETBSD
)
pthread_attr_get_np
(
thread
&
sattr
)
;
#
else
MOZ_RELEASE_ASSERT
(
pthread_getattr_np
(
thread
&
sattr
)
=
=
0
"
pthread_getattr_np
failed
"
)
;
#
endif
void
*
stackBase
=
0
;
size_t
stackSize
=
0
;
int
rc
;
#
if
defined
(
__OpenBSD__
)
rc
=
pthread_stackseg_np
(
pthread_self
(
)
&
ss
)
;
stackBase
=
(
void
*
)
(
(
size_t
)
ss
.
ss_sp
-
ss
.
ss_size
)
;
stackSize
=
ss
.
ss_size
;
#
elif
defined
(
ANDROID
)
&
&
!
defined
(
__aarch64__
)
if
(
gettid
(
)
=
=
getpid
(
)
)
{
rc
=
-
1
;
volatile
char
path
[
]
=
"
/
proc
/
self
/
maps
"
;
FILE
*
fs
=
fopen
(
(
const
char
*
)
path
"
r
"
)
;
if
(
fs
)
{
char
line
[
100
]
;
unsigned
long
stackAddr
=
(
unsigned
long
)
&
sattr
;
while
(
fgets
(
line
sizeof
(
line
)
fs
)
!
=
nullptr
)
{
unsigned
long
stackStart
;
unsigned
long
stackEnd
;
if
(
sscanf
(
line
"
%
lx
-
%
lx
"
&
stackStart
&
stackEnd
)
=
=
2
&
&
stackAddr
>
=
stackStart
&
&
stackAddr
<
stackEnd
)
{
stackBase
=
(
void
*
)
stackStart
;
stackSize
=
stackEnd
-
stackStart
;
rc
=
0
;
break
;
}
}
fclose
(
fs
)
;
}
}
else
{
rc
=
pthread_attr_getstack
(
&
sattr
&
stackBase
&
stackSize
)
;
}
#
else
rc
=
pthread_attr_getstack
(
&
sattr
&
stackBase
&
stackSize
)
;
#
endif
if
(
rc
)
{
MOZ_CRASH
(
)
;
}
MOZ_ASSERT
(
stackBase
)
;
pthread_attr_destroy
(
&
sattr
)
;
#
if
JS_STACK_GROWTH_DIRECTION
>
0
return
stackBase
;
#
else
return
static_cast
<
char
*
>
(
stackBase
)
+
stackSize
;
#
endif
#
endif
}
#
endif
