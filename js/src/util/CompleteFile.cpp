#
include
"
util
/
CompleteFile
.
h
"
#
include
<
cstring
>
#
include
<
stdio
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
bool
js
:
:
ReadCompleteFile
(
JSContext
*
cx
FILE
*
fp
FileContents
&
buffer
)
{
struct
stat
st
;
int
ok
=
fstat
(
fileno
(
fp
)
&
st
)
;
if
(
ok
!
=
0
)
{
JS_ReportErrorLatin1
(
cx
"
error
reading
file
:
%
s
"
strerror
(
errno
)
)
;
errno
=
0
;
return
false
;
}
if
(
(
st
.
st_mode
&
S_IFDIR
)
!
=
0
)
{
JS_ReportErrorLatin1
(
cx
"
error
reading
file
:
%
s
"
strerror
(
EISDIR
)
)
;
return
false
;
}
if
(
st
.
st_size
>
0
)
{
if
(
!
buffer
.
reserve
(
st
.
st_size
)
)
{
return
false
;
}
}
auto
fast_getc
=
#
if
defined
(
HAVE_GETC_UNLOCKED
)
getc_unlocked
#
elif
defined
(
HAVE__GETC_NOLOCK
)
_getc_nolock
#
else
getc
#
endif
;
for
(
;
;
)
{
int
c
=
fast_getc
(
fp
)
;
if
(
c
=
=
EOF
)
{
break
;
}
if
(
!
buffer
.
append
(
c
)
)
{
return
false
;
}
}
if
(
ferror
(
fp
)
)
{
JS_ReportErrorLatin1
(
cx
"
error
reading
file
:
%
s
"
strerror
(
errno
)
)
;
errno
=
0
;
return
false
;
}
return
true
;
}
bool
js
:
:
AutoFile
:
:
open
(
JSContext
*
cx
const
char
*
filename
)
{
if
(
!
filename
|
|
std
:
:
strcmp
(
filename
"
-
"
)
=
=
0
)
{
fp_
=
stdin
;
}
else
{
fp_
=
fopen
(
filename
"
r
"
)
;
if
(
!
fp_
)
{
JS_ReportErrorNumberLatin1
(
cx
GetErrorMessage
nullptr
JSMSG_CANT_OPEN
filename
"
No
such
file
or
directory
"
)
;
return
false
;
}
}
return
true
;
}
