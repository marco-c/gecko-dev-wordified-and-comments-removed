#
include
"
util
/
CompleteFile
.
h
"
#
include
<
cstring
>
#
include
<
stdio
.
h
>
#
include
<
sys
/
stat
.
h
>
#
ifdef
__wasi__
#
include
"
js
/
Vector
.
h
"
#
endif
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
bool
js
:
:
ReadCompleteFile
(
JSContext
*
cx
FILE
*
fp
FileContents
&
buffer
)
{
struct
stat
st
;
int
ok
=
fstat
(
fileno
(
fp
)
&
st
)
;
if
(
ok
!
=
0
)
{
JS_ReportErrorLatin1
(
cx
"
error
reading
file
:
%
s
"
strerror
(
errno
)
)
;
errno
=
0
;
return
false
;
}
if
(
(
st
.
st_mode
&
S_IFDIR
)
!
=
0
)
{
JS_ReportErrorLatin1
(
cx
"
error
reading
file
:
%
s
"
strerror
(
EISDIR
)
)
;
return
false
;
}
if
(
st
.
st_size
>
0
)
{
if
(
!
buffer
.
reserve
(
st
.
st_size
)
)
{
return
false
;
}
}
auto
fast_getc
=
#
if
defined
(
HAVE_GETC_UNLOCKED
)
getc_unlocked
#
elif
defined
(
HAVE__GETC_NOLOCK
)
_getc_nolock
#
else
getc
#
endif
;
for
(
;
;
)
{
int
c
=
fast_getc
(
fp
)
;
if
(
c
=
=
EOF
)
{
break
;
}
if
(
!
buffer
.
append
(
c
)
)
{
return
false
;
}
}
if
(
ferror
(
fp
)
)
{
JS_ReportErrorLatin1
(
cx
"
error
reading
file
:
%
s
"
strerror
(
errno
)
)
;
errno
=
0
;
return
false
;
}
return
true
;
}
#
ifdef
__wasi__
static
bool
NormalizeWASIPath
(
const
char
*
filename
js
:
:
Vector
<
char
>
*
normalized
JSContext
*
cx
)
{
for
(
const
char
*
cur
=
filename
;
*
cur
;
+
+
cur
)
{
if
(
std
:
:
strncmp
(
cur
"
/
.
.
/
"
4
)
=
=
0
)
{
do
{
if
(
normalized
-
>
empty
(
)
)
{
JS_ReportErrorASCII
(
cx
"
Path
processing
error
"
)
;
return
false
;
}
}
while
(
normalized
-
>
popCopy
(
)
!
=
'
/
'
)
;
cur
+
=
2
;
continue
;
}
if
(
!
normalized
-
>
append
(
*
cur
)
)
{
return
false
;
}
}
if
(
!
normalized
-
>
append
(
'
\
0
'
)
)
{
return
false
;
}
return
true
;
}
#
endif
static
FILE
*
OpenFile
(
JSContext
*
cx
const
char
*
filename
)
{
#
ifdef
XP_WIN
JS
:
:
UniqueWideChars
wideFilename
=
JS
:
:
EncodeUtf8ToWide
(
cx
filename
)
;
if
(
!
wideFilename
)
{
return
nullptr
;
}
return
_wfopen
(
wideFilename
.
get
(
)
L
"
r
"
)
;
#
else
JS
:
:
UniqueChars
narrowFilename
=
JS
:
:
EncodeUtf8ToNarrow
(
cx
filename
)
;
if
(
!
narrowFilename
)
{
return
nullptr
;
}
return
fopen
(
narrowFilename
.
get
(
)
"
r
"
)
;
#
endif
}
bool
js
:
:
AutoFile
:
:
open
(
JSContext
*
cx
const
char
*
filename
)
{
if
(
!
filename
|
|
std
:
:
strcmp
(
filename
"
-
"
)
=
=
0
)
{
fp_
=
stdin
;
}
else
{
#
ifdef
__wasi__
js
:
:
Vector
<
char
>
normalized
(
cx
)
;
if
(
!
NormalizeWASIPath
(
filename
&
normalized
cx
)
)
{
return
false
;
}
fp_
=
OpenFile
(
cx
normalized
.
begin
(
)
)
;
#
else
fp_
=
OpenFile
(
cx
filename
)
;
#
endif
if
(
!
fp_
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_CANT_OPEN
filename
"
No
such
file
or
directory
"
)
;
return
false
;
}
}
return
true
;
}
