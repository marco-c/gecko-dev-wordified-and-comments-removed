#
ifndef
util_EnumFlags_h
#
define
util_EnumFlags_h
#
include
<
initializer_list
>
#
include
<
type_traits
>
namespace
js
{
template
<
typename
EnumType
>
class
EnumFlags
{
protected
:
static_assert
(
std
:
:
is_enum_v
<
EnumType
>
)
;
using
FieldType
=
std
:
:
underlying_type_t
<
EnumType
>
;
static_assert
(
std
:
:
is_unsigned_v
<
FieldType
>
)
;
FieldType
flags_
=
0
;
explicit
constexpr
EnumFlags
(
FieldType
rawFlags
)
:
flags_
(
rawFlags
)
{
}
public
:
constexpr
EnumFlags
(
)
=
default
;
constexpr
MOZ_IMPLICIT
EnumFlags
(
std
:
:
initializer_list
<
EnumType
>
list
)
{
for
(
EnumType
flag
:
list
)
{
setFlag
(
flag
)
;
}
}
constexpr
bool
hasFlag
(
EnumType
flag
)
const
{
return
flags_
&
static_cast
<
FieldType
>
(
flag
)
;
}
constexpr
void
setFlag
(
EnumType
flag
)
{
flags_
|
=
static_cast
<
FieldType
>
(
flag
)
;
}
constexpr
void
clearFlag
(
EnumType
flag
)
{
flags_
&
=
~
static_cast
<
FieldType
>
(
flag
)
;
}
constexpr
void
setFlag
(
EnumType
flag
bool
b
)
{
if
(
b
)
{
setFlag
(
flag
)
;
}
else
{
clearFlag
(
flag
)
;
}
}
constexpr
bool
isEmpty
(
)
const
{
return
flags_
=
=
0
;
}
constexpr
FieldType
toRaw
(
)
const
{
return
flags_
;
}
void
setRaw
(
FieldType
flag
)
{
flags_
=
flag
;
}
constexpr
bool
operator
=
=
(
const
EnumFlags
&
other
)
const
{
return
flags_
=
=
other
.
flags_
;
}
constexpr
bool
operator
!
=
(
const
EnumFlags
&
other
)
const
{
return
flags_
!
=
other
.
flags_
;
}
}
;
}
#
endif
