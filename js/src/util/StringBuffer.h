#
ifndef
util_StringBuffer_h
#
define
util_StringBuffer_h
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
MaybeOneOf
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
frontend
/
FrontendContext
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
StringType
.
h
"
namespace
js
{
class
FrontendContext
;
namespace
frontend
{
class
ParserAtomsTable
;
class
TaggedParserAtomIndex
;
}
namespace
detail
{
static
constexpr
size_t
AggressiveLimit
=
128
<
<
20
;
template
<
size_t
EltSize
>
inline
size_t
GrowEltsAggressively
(
size_t
aOldElts
size_t
aIncr
)
{
mozilla
:
:
CheckedInt
<
size_t
>
required
=
mozilla
:
:
CheckedInt
<
size_t
>
(
aOldElts
)
+
aIncr
;
if
(
!
(
required
*
2
)
.
isValid
(
)
)
{
return
0
;
}
required
=
mozilla
:
:
RoundUpPow2
(
required
.
value
(
)
)
;
required
*
=
8
;
if
(
!
(
required
*
EltSize
)
.
isValid
(
)
|
|
required
.
value
(
)
>
AggressiveLimit
)
{
return
mozilla
:
:
detail
:
:
GrowEltsByDoubling
<
EltSize
>
(
aOldElts
aIncr
)
;
}
return
required
.
value
(
)
;
}
;
}
class
StringBufferAllocPolicy
{
TempAllocPolicy
impl_
;
const
arena_id_t
&
arenaId_
;
public
:
StringBufferAllocPolicy
(
FrontendContext
*
fc
const
arena_id_t
&
arenaId
)
:
impl_
(
fc
)
arenaId_
(
arenaId
)
{
}
template
<
typename
T
>
T
*
maybe_pod_malloc
(
size_t
numElems
)
{
return
impl_
.
maybe_pod_arena_malloc
<
T
>
(
arenaId_
numElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_calloc
(
size_t
numElems
)
{
return
impl_
.
maybe_pod_arena_calloc
<
T
>
(
arenaId_
numElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_realloc
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
return
impl_
.
maybe_pod_arena_realloc
<
T
>
(
arenaId_
p
oldSize
newSize
)
;
}
template
<
typename
T
>
T
*
pod_malloc
(
size_t
numElems
)
{
return
impl_
.
pod_arena_malloc
<
T
>
(
arenaId_
numElems
)
;
}
template
<
typename
T
>
T
*
pod_calloc
(
size_t
numElems
)
{
return
impl_
.
pod_arena_calloc
<
T
>
(
arenaId_
numElems
)
;
}
template
<
typename
T
>
T
*
pod_realloc
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
return
impl_
.
pod_arena_realloc
<
T
>
(
arenaId_
p
oldSize
newSize
)
;
}
template
<
typename
T
>
void
free_
(
T
*
p
size_t
numElems
=
0
)
{
impl_
.
free_
(
p
numElems
)
;
}
void
reportAllocOverflow
(
)
const
{
impl_
.
reportAllocOverflow
(
)
;
}
bool
checkSimulatedOOM
(
)
const
{
return
impl_
.
checkSimulatedOOM
(
)
;
}
template
<
size_t
EltSize
>
static
size_t
computeGrowth
(
size_t
aOldElts
size_t
aIncr
)
{
return
detail
:
:
GrowEltsAggressively
<
EltSize
>
(
aOldElts
aIncr
)
;
}
}
;
class
StringBuffer
{
protected
:
template
<
typename
CharT
>
using
BufferType
=
Vector
<
CharT
64
/
sizeof
(
CharT
)
StringBufferAllocPolicy
>
;
using
Latin1CharBuffer
=
BufferType
<
Latin1Char
>
;
using
TwoByteCharBuffer
=
BufferType
<
char16_t
>
;
JSContext
*
cx_
;
FrontendContext
*
fc_
;
const
arena_id_t
&
arenaId_
;
mozilla
:
:
MaybeOneOf
<
Latin1CharBuffer
TwoByteCharBuffer
>
cb
;
size_t
reserved_
;
StringBuffer
(
const
StringBuffer
&
other
)
=
delete
;
void
operator
=
(
const
StringBuffer
&
other
)
=
delete
;
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
bool
isCharType
(
)
const
{
return
cb
.
constructed
<
BufferType
<
CharT
>
>
(
)
;
}
MOZ_ALWAYS_INLINE
bool
isLatin1
(
)
const
{
return
isCharType
<
Latin1Char
>
(
)
;
}
MOZ_ALWAYS_INLINE
bool
isTwoByte
(
)
const
{
return
isCharType
<
char16_t
>
(
)
;
}
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
BufferType
<
CharT
>
&
chars
(
)
{
MOZ_ASSERT
(
isCharType
<
CharT
>
(
)
)
;
return
cb
.
ref
<
BufferType
<
CharT
>
>
(
)
;
}
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
const
BufferType
<
CharT
>
&
chars
(
)
const
{
MOZ_ASSERT
(
isCharType
<
CharT
>
(
)
)
;
return
cb
.
ref
<
BufferType
<
CharT
>
>
(
)
;
}
MOZ_ALWAYS_INLINE
TwoByteCharBuffer
&
twoByteChars
(
)
{
return
chars
<
char16_t
>
(
)
;
}
MOZ_ALWAYS_INLINE
const
TwoByteCharBuffer
&
twoByteChars
(
)
const
{
return
chars
<
char16_t
>
(
)
;
}
MOZ_ALWAYS_INLINE
Latin1CharBuffer
&
latin1Chars
(
)
{
return
chars
<
Latin1Char
>
(
)
;
}
MOZ_ALWAYS_INLINE
const
Latin1CharBuffer
&
latin1Chars
(
)
const
{
return
chars
<
Latin1Char
>
(
)
;
}
[
[
nodiscard
]
]
bool
inflateChars
(
)
;
template
<
typename
CharT
>
JSLinearString
*
finishStringInternal
(
JSContext
*
cx
)
;
public
:
explicit
StringBuffer
(
JSContext
*
cx
FrontendContext
*
fc
const
arena_id_t
&
arenaId
=
js
:
:
MallocArena
)
:
cx_
(
cx
)
fc_
(
fc
)
arenaId_
(
arenaId
)
reserved_
(
0
)
{
cb
.
construct
<
Latin1CharBuffer
>
(
StringBufferAllocPolicy
{
fc_
arenaId_
}
)
;
}
void
clear
(
)
{
if
(
isLatin1
(
)
)
{
latin1Chars
(
)
.
clear
(
)
;
}
else
{
twoByteChars
(
)
.
clear
(
)
;
}
}
[
[
nodiscard
]
]
bool
reserve
(
size_t
len
)
{
if
(
len
>
reserved_
)
{
reserved_
=
len
;
}
return
isLatin1
(
)
?
latin1Chars
(
)
.
reserve
(
len
)
:
twoByteChars
(
)
.
reserve
(
len
)
;
}
[
[
nodiscard
]
]
bool
resize
(
size_t
len
)
{
return
isLatin1
(
)
?
latin1Chars
(
)
.
resize
(
len
)
:
twoByteChars
(
)
.
resize
(
len
)
;
}
[
[
nodiscard
]
]
bool
growByUninitialized
(
size_t
incr
)
{
return
isLatin1
(
)
?
latin1Chars
(
)
.
growByUninitialized
(
incr
)
:
twoByteChars
(
)
.
growByUninitialized
(
incr
)
;
}
void
shrinkTo
(
size_t
newLength
)
{
return
isLatin1
(
)
?
latin1Chars
(
)
.
shrinkTo
(
newLength
)
:
twoByteChars
(
)
.
shrinkTo
(
newLength
)
;
}
bool
empty
(
)
const
{
return
isLatin1
(
)
?
latin1Chars
(
)
.
empty
(
)
:
twoByteChars
(
)
.
empty
(
)
;
}
size_t
length
(
)
const
{
return
isLatin1
(
)
?
latin1Chars
(
)
.
length
(
)
:
twoByteChars
(
)
.
length
(
)
;
}
char16_t
getChar
(
size_t
idx
)
const
{
return
isLatin1
(
)
?
latin1Chars
(
)
[
idx
]
:
twoByteChars
(
)
[
idx
]
;
}
[
[
nodiscard
]
]
bool
ensureTwoByteChars
(
)
{
return
isTwoByte
(
)
|
|
inflateChars
(
)
;
}
[
[
nodiscard
]
]
bool
append
(
const
char16_t
c
)
{
if
(
isLatin1
(
)
)
{
if
(
c
<
=
JSString
:
:
MAX_LATIN1_CHAR
)
{
return
latin1Chars
(
)
.
append
(
Latin1Char
(
c
)
)
;
}
if
(
!
inflateChars
(
)
)
{
return
false
;
}
}
return
twoByteChars
(
)
.
append
(
c
)
;
}
[
[
nodiscard
]
]
bool
append
(
Latin1Char
c
)
{
return
isLatin1
(
)
?
latin1Chars
(
)
.
append
(
c
)
:
twoByteChars
(
)
.
append
(
c
)
;
}
[
[
nodiscard
]
]
bool
append
(
char
c
)
{
return
append
(
Latin1Char
(
c
)
)
;
}
[
[
nodiscard
]
]
inline
bool
append
(
const
char16_t
*
begin
const
char16_t
*
end
)
;
[
[
nodiscard
]
]
bool
append
(
const
char16_t
*
chars
size_t
len
)
{
return
append
(
chars
chars
+
len
)
;
}
[
[
nodiscard
]
]
bool
append
(
const
Latin1Char
*
begin
const
Latin1Char
*
end
)
{
return
isLatin1
(
)
?
latin1Chars
(
)
.
append
(
begin
end
)
:
twoByteChars
(
)
.
append
(
begin
end
)
;
}
[
[
nodiscard
]
]
bool
append
(
const
Latin1Char
*
chars
size_t
len
)
{
return
append
(
chars
chars
+
len
)
;
}
[
[
nodiscard
]
]
bool
append
(
const
mozilla
:
:
Utf8Unit
*
units
size_t
len
)
;
[
[
nodiscard
]
]
bool
append
(
const
JS
:
:
ConstCharPtr
chars
size_t
len
)
{
return
append
(
chars
.
get
(
)
chars
.
get
(
)
+
len
)
;
}
[
[
nodiscard
]
]
bool
appendN
(
Latin1Char
c
size_t
n
)
{
return
isLatin1
(
)
?
latin1Chars
(
)
.
appendN
(
c
n
)
:
twoByteChars
(
)
.
appendN
(
c
n
)
;
}
[
[
nodiscard
]
]
inline
bool
append
(
JSString
*
str
)
;
[
[
nodiscard
]
]
inline
bool
append
(
JSLinearString
*
str
)
;
[
[
nodiscard
]
]
inline
bool
appendSubstring
(
JSString
*
base
size_t
off
size_t
len
)
;
[
[
nodiscard
]
]
inline
bool
appendSubstring
(
JSLinearString
*
base
size_t
off
size_t
len
)
;
[
[
nodiscard
]
]
bool
append
(
const
frontend
:
:
ParserAtomsTable
&
parserAtoms
frontend
:
:
TaggedParserAtomIndex
atom
)
;
[
[
nodiscard
]
]
bool
append
(
const
char
*
chars
size_t
len
)
{
return
append
(
reinterpret_cast
<
const
Latin1Char
*
>
(
chars
)
len
)
;
}
template
<
size_t
ArrayLength
>
[
[
nodiscard
]
]
bool
append
(
const
char
(
&
array
)
[
ArrayLength
]
)
{
return
append
(
array
ArrayLength
-
1
)
;
}
void
infallibleAppend
(
Latin1Char
c
)
{
if
(
isLatin1
(
)
)
{
latin1Chars
(
)
.
infallibleAppend
(
c
)
;
}
else
{
twoByteChars
(
)
.
infallibleAppend
(
c
)
;
}
}
void
infallibleAppend
(
char
c
)
{
infallibleAppend
(
Latin1Char
(
c
)
)
;
}
void
infallibleAppend
(
const
Latin1Char
*
chars
size_t
len
)
{
if
(
isLatin1
(
)
)
{
latin1Chars
(
)
.
infallibleAppend
(
chars
len
)
;
}
else
{
twoByteChars
(
)
.
infallibleAppend
(
chars
len
)
;
}
}
void
infallibleAppend
(
const
char
*
chars
size_t
len
)
{
infallibleAppend
(
reinterpret_cast
<
const
Latin1Char
*
>
(
chars
)
len
)
;
}
void
infallibleAppendSubstring
(
JSLinearString
*
base
size_t
off
size_t
len
)
;
void
infallibleAppend
(
const
char16_t
*
chars
size_t
len
)
{
twoByteChars
(
)
.
infallibleAppend
(
chars
len
)
;
}
void
infallibleAppend
(
char16_t
c
)
{
twoByteChars
(
)
.
infallibleAppend
(
c
)
;
}
bool
isUnderlyingBufferLatin1
(
)
const
{
return
isLatin1
(
)
;
}
template
<
typename
CharT
>
CharT
*
begin
(
)
{
return
chars
<
CharT
>
(
)
.
begin
(
)
;
}
template
<
typename
CharT
>
CharT
*
end
(
)
{
return
chars
<
CharT
>
(
)
.
end
(
)
;
}
template
<
typename
CharT
>
const
CharT
*
begin
(
)
const
{
return
chars
<
CharT
>
(
)
.
begin
(
)
;
}
template
<
typename
CharT
>
const
CharT
*
end
(
)
const
{
return
chars
<
CharT
>
(
)
.
end
(
)
;
}
char16_t
*
rawTwoByteBegin
(
)
{
return
begin
<
char16_t
>
(
)
;
}
char16_t
*
rawTwoByteEnd
(
)
{
return
end
<
char16_t
>
(
)
;
}
const
char16_t
*
rawTwoByteBegin
(
)
const
{
return
begin
<
char16_t
>
(
)
;
}
const
char16_t
*
rawTwoByteEnd
(
)
const
{
return
end
<
char16_t
>
(
)
;
}
Latin1Char
*
rawLatin1Begin
(
)
{
return
begin
<
Latin1Char
>
(
)
;
}
Latin1Char
*
rawLatin1End
(
)
{
return
end
<
Latin1Char
>
(
)
;
}
const
Latin1Char
*
rawLatin1Begin
(
)
const
{
return
begin
<
Latin1Char
>
(
)
;
}
const
Latin1Char
*
rawLatin1End
(
)
const
{
return
end
<
Latin1Char
>
(
)
;
}
JSAtom
*
finishAtom
(
)
;
frontend
:
:
TaggedParserAtomIndex
finishParserAtom
(
frontend
:
:
ParserAtomsTable
&
parserAtoms
FrontendContext
*
fc
)
;
char16_t
*
stealChars
(
)
;
}
;
class
JSStringBuilder
:
public
StringBuffer
{
FrontendContext
fc_
;
#
ifdef
DEBUG
bool
handled_
=
false
;
#
endif
public
:
explicit
JSStringBuilder
(
JSContext
*
cx
)
:
StringBuffer
(
cx
&
fc_
js
:
:
StringBufferArena
)
{
fc_
.
setCurrentJSContext
(
cx
)
;
}
~
JSStringBuilder
(
)
{
MOZ_ASSERT
(
handled_
)
;
}
void
failure
(
)
{
#
ifdef
DEBUG
handled_
=
true
;
#
endif
fc_
.
convertToRuntimeError
(
cx_
)
;
}
void
ok
(
)
{
#
ifdef
DEBUG
handled_
=
true
;
#
endif
}
JSLinearString
*
finishString
(
)
;
}
;
inline
bool
StringBuffer
:
:
append
(
const
char16_t
*
begin
const
char16_t
*
end
)
{
MOZ_ASSERT
(
begin
<
=
end
)
;
if
(
isLatin1
(
)
)
{
while
(
true
)
{
if
(
begin
>
=
end
)
{
return
true
;
}
if
(
*
begin
>
JSString
:
:
MAX_LATIN1_CHAR
)
{
break
;
}
if
(
!
latin1Chars
(
)
.
append
(
*
begin
)
)
{
return
false
;
}
+
+
begin
;
}
if
(
!
inflateChars
(
)
)
{
return
false
;
}
}
return
twoByteChars
(
)
.
append
(
begin
end
)
;
}
inline
bool
StringBuffer
:
:
append
(
JSLinearString
*
str
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
isLatin1
(
)
)
{
if
(
str
-
>
hasLatin1Chars
(
)
)
{
return
latin1Chars
(
)
.
append
(
str
-
>
latin1Chars
(
nogc
)
str
-
>
length
(
)
)
;
}
if
(
!
inflateChars
(
)
)
{
return
false
;
}
}
return
str
-
>
hasLatin1Chars
(
)
?
twoByteChars
(
)
.
append
(
str
-
>
latin1Chars
(
nogc
)
str
-
>
length
(
)
)
:
twoByteChars
(
)
.
append
(
str
-
>
twoByteChars
(
nogc
)
str
-
>
length
(
)
)
;
}
inline
void
StringBuffer
:
:
infallibleAppendSubstring
(
JSLinearString
*
base
size_t
off
size_t
len
)
{
MOZ_ASSERT
(
off
+
len
<
=
base
-
>
length
(
)
)
;
MOZ_ASSERT_IF
(
base
-
>
hasTwoByteChars
(
)
isTwoByte
(
)
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
base
-
>
hasLatin1Chars
(
)
)
{
infallibleAppend
(
base
-
>
latin1Chars
(
nogc
)
+
off
len
)
;
}
else
{
infallibleAppend
(
base
-
>
twoByteChars
(
nogc
)
+
off
len
)
;
}
}
inline
bool
StringBuffer
:
:
appendSubstring
(
JSLinearString
*
base
size_t
off
size_t
len
)
{
MOZ_ASSERT
(
off
+
len
<
=
base
-
>
length
(
)
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
isLatin1
(
)
)
{
if
(
base
-
>
hasLatin1Chars
(
)
)
{
return
latin1Chars
(
)
.
append
(
base
-
>
latin1Chars
(
nogc
)
+
off
len
)
;
}
if
(
!
inflateChars
(
)
)
{
return
false
;
}
}
return
base
-
>
hasLatin1Chars
(
)
?
twoByteChars
(
)
.
append
(
base
-
>
latin1Chars
(
nogc
)
+
off
len
)
:
twoByteChars
(
)
.
append
(
base
-
>
twoByteChars
(
nogc
)
+
off
len
)
;
}
inline
bool
StringBuffer
:
:
appendSubstring
(
JSString
*
base
size_t
off
size_t
len
)
{
JSLinearString
*
linear
=
base
-
>
ensureLinear
(
cx_
)
;
if
(
!
linear
)
{
return
false
;
}
return
appendSubstring
(
linear
off
len
)
;
}
inline
bool
StringBuffer
:
:
append
(
JSString
*
str
)
{
JSLinearString
*
linear
=
str
-
>
ensureLinear
(
cx_
)
;
if
(
!
linear
)
{
return
false
;
}
return
append
(
linear
)
;
}
extern
bool
ValueToStringBufferSlow
(
JSContext
*
cx
const
Value
&
v
StringBuffer
&
sb
)
;
inline
bool
ValueToStringBuffer
(
JSContext
*
cx
const
Value
&
v
StringBuffer
&
sb
)
{
if
(
v
.
isString
(
)
)
{
return
sb
.
append
(
v
.
toString
(
)
)
;
}
return
ValueToStringBufferSlow
(
cx
v
sb
)
;
}
inline
bool
BooleanToStringBuffer
(
bool
b
StringBuffer
&
sb
)
{
return
b
?
sb
.
append
(
"
true
"
)
:
sb
.
append
(
"
false
"
)
;
}
}
#
endif
