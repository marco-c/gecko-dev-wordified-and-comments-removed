#
ifndef
util_Memory_h
#
define
util_Memory_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
static
MOZ_ALWAYS_INLINE
void
*
js_memcpy
(
void
*
dst_
const
void
*
src_
size_t
len
)
{
char
*
dst
=
(
char
*
)
dst_
;
const
char
*
src
=
(
const
char
*
)
src_
;
MOZ_ASSERT_IF
(
dst
>
=
src
(
size_t
)
(
dst
-
src
)
>
=
len
)
;
MOZ_ASSERT_IF
(
src
>
=
dst
(
size_t
)
(
src
-
dst
)
>
=
len
)
;
return
memcpy
(
dst
src
len
)
;
}
namespace
js
{
template
<
typename
T
typename
U
>
static
constexpr
U
ComputeByteAlignment
(
T
bytes
U
alignment
)
{
static_assert
(
mozilla
:
:
IsUnsigned
<
U
>
:
:
value
"
alignment
amount
must
be
unsigned
"
)
;
return
(
alignment
-
(
bytes
%
alignment
)
)
%
alignment
;
}
template
<
typename
T
typename
U
>
static
constexpr
T
AlignBytes
(
T
bytes
U
alignment
)
{
static_assert
(
mozilla
:
:
IsUnsigned
<
U
>
:
:
value
"
alignment
amount
must
be
unsigned
"
)
;
return
bytes
+
ComputeByteAlignment
(
bytes
alignment
)
;
}
template
<
typename
T
>
static
void
DefaultInitializeElements
(
void
*
arrayPtr
size_t
length
)
{
uintptr_t
elem
=
reinterpret_cast
<
uintptr_t
>
(
arrayPtr
)
;
MOZ_ASSERT
(
elem
%
alignof
(
T
)
=
=
0
)
;
for
(
size_t
i
=
0
;
i
<
length
;
+
+
i
)
{
new
(
reinterpret_cast
<
void
*
>
(
elem
)
)
T
;
elem
+
=
sizeof
(
T
)
;
}
}
}
#
endif
