#
include
"
jsopcodeinlines
.
h
"
#
define
__STDC_FORMAT_MACROS
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
SizePrintfMacros
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
<
algorithm
>
#
include
<
ctype
.
h
>
#
include
<
inttypes
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
jsatom
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jscompartment
.
h
"
#
include
"
jsfun
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
jsobj
.
h
"
#
include
"
jsprf
.
h
"
#
include
"
jsscript
.
h
"
#
include
"
jsstr
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
jsutil
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
frontend
/
SourceNotes
.
h
"
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
vm
/
CodeCoverage
.
h
"
#
include
"
vm
/
EnvironmentObject
.
h
"
#
include
"
vm
/
Opcodes
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
StringBuffer
.
h
"
#
include
"
jscntxtinlines
.
h
"
#
include
"
jscompartmentinlines
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
jsscriptinlines
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
JS
:
:
AutoCheckCannotGC
;
using
js
:
:
frontend
:
:
IsIdentifier
;
JS_STATIC_ASSERT
(
sizeof
(
uint32_t
)
*
JS_BITS_PER_BYTE
>
=
INDEX_LIMIT_LOG2
+
1
)
;
const
JSCodeSpec
js
:
:
CodeSpec
[
]
=
{
#
define
MAKE_CODESPEC
(
op
val
name
token
length
nuses
ndefs
format
)
{
length
nuses
ndefs
format
}
FOR_EACH_OPCODE
(
MAKE_CODESPEC
)
#
undef
MAKE_CODESPEC
}
;
const
unsigned
js
:
:
NumCodeSpecs
=
JS_ARRAY_LENGTH
(
CodeSpec
)
;
static
const
char
*
const
CodeToken
[
]
=
{
#
define
TOKEN
(
op
val
name
token
.
.
.
)
token
FOR_EACH_OPCODE
(
TOKEN
)
#
undef
TOKEN
}
;
const
char
*
const
js
:
:
CodeName
[
]
=
{
#
define
OPNAME
(
op
val
name
.
.
.
)
name
FOR_EACH_OPCODE
(
OPNAME
)
#
undef
OPNAME
}
;
#
define
COUNTS_LEN
16
size_t
js
:
:
GetVariableBytecodeLength
(
jsbytecode
*
pc
)
{
JSOp
op
=
JSOp
(
*
pc
)
;
MOZ_ASSERT
(
CodeSpec
[
op
]
.
length
=
=
-
1
)
;
switch
(
op
)
{
case
JSOP_TABLESWITCH
:
{
pc
+
=
JUMP_OFFSET_LEN
;
int32_t
low
=
GET_JUMP_OFFSET
(
pc
)
;
pc
+
=
JUMP_OFFSET_LEN
;
int32_t
high
=
GET_JUMP_OFFSET
(
pc
)
;
unsigned
ncases
=
unsigned
(
high
-
low
+
1
)
;
return
1
+
3
*
JUMP_OFFSET_LEN
+
ncases
*
JUMP_OFFSET_LEN
;
}
default
:
MOZ_CRASH
(
"
Unexpected
op
"
)
;
}
}
unsigned
js
:
:
StackUses
(
JSScript
*
script
jsbytecode
*
pc
)
{
JSOp
op
=
(
JSOp
)
*
pc
;
const
JSCodeSpec
&
cs
=
CodeSpec
[
op
]
;
if
(
cs
.
nuses
>
=
0
)
return
cs
.
nuses
;
MOZ_ASSERT
(
CodeSpec
[
op
]
.
nuses
=
=
-
1
)
;
switch
(
op
)
{
case
JSOP_POPN
:
return
GET_UINT16
(
pc
)
;
case
JSOP_NEW
:
case
JSOP_SUPERCALL
:
return
2
+
GET_ARGC
(
pc
)
+
1
;
default
:
MOZ_ASSERT
(
op
=
=
JSOP_CALL
|
|
op
=
=
JSOP_EVAL
|
|
op
=
=
JSOP_CALLITER
|
|
op
=
=
JSOP_STRICTEVAL
|
|
op
=
=
JSOP_FUNCALL
|
|
op
=
=
JSOP_FUNAPPLY
)
;
return
2
+
GET_ARGC
(
pc
)
;
}
}
unsigned
js
:
:
StackDefs
(
JSScript
*
script
jsbytecode
*
pc
)
{
JSOp
op
=
(
JSOp
)
*
pc
;
const
JSCodeSpec
&
cs
=
CodeSpec
[
op
]
;
MOZ_ASSERT
(
cs
.
ndefs
>
=
0
)
;
return
cs
.
ndefs
;
}
const
char
*
PCCounts
:
:
numExecName
=
"
interp
"
;
static
MOZ_MUST_USE
bool
DumpIonScriptCounts
(
Sprinter
*
sp
HandleScript
script
jit
:
:
IonScriptCounts
*
ionCounts
)
{
if
(
!
sp
-
>
jsprintf
(
"
IonScript
[
%
lu
blocks
]
:
\
n
"
ionCounts
-
>
numBlocks
(
)
)
)
return
false
;
for
(
size_t
i
=
0
;
i
<
ionCounts
-
>
numBlocks
(
)
;
i
+
+
)
{
const
jit
:
:
IonBlockCounts
&
block
=
ionCounts
-
>
block
(
i
)
;
unsigned
lineNumber
=
0
columnNumber
=
0
;
lineNumber
=
PCToLineNumber
(
script
script
-
>
offsetToPC
(
block
.
offset
(
)
)
&
columnNumber
)
;
if
(
!
sp
-
>
jsprintf
(
"
BB
#
%
lu
[
%
05u
%
u
%
u
]
"
block
.
id
(
)
block
.
offset
(
)
lineNumber
columnNumber
)
)
{
return
false
;
}
if
(
block
.
description
(
)
)
{
if
(
!
sp
-
>
jsprintf
(
"
[
inlined
%
s
]
"
block
.
description
(
)
)
)
return
false
;
}
for
(
size_t
j
=
0
;
j
<
block
.
numSuccessors
(
)
;
j
+
+
)
{
if
(
!
sp
-
>
jsprintf
(
"
-
>
#
%
lu
"
block
.
successor
(
j
)
)
)
return
false
;
}
if
(
!
sp
-
>
jsprintf
(
"
:
:
%
llu
hits
\
n
"
block
.
hitCount
(
)
)
)
return
false
;
if
(
!
sp
-
>
jsprintf
(
"
%
s
\
n
"
block
.
code
(
)
)
)
return
false
;
}
return
true
;
}
static
MOZ_MUST_USE
bool
DumpPCCounts
(
JSContext
*
cx
HandleScript
script
Sprinter
*
sp
)
{
MOZ_ASSERT
(
script
-
>
hasScriptCounts
(
)
)
;
#
ifdef
DEBUG
jsbytecode
*
pc
=
script
-
>
code
(
)
;
while
(
pc
<
script
-
>
codeEnd
(
)
)
{
jsbytecode
*
next
=
GetNextPc
(
pc
)
;
if
(
!
Disassemble1
(
cx
script
pc
script
-
>
pcToOffset
(
pc
)
true
sp
)
)
return
false
;
if
(
sp
-
>
put
(
"
{
"
)
<
0
)
return
false
;
PCCounts
*
counts
=
script
-
>
maybeGetPCCounts
(
pc
)
;
if
(
double
val
=
counts
?
counts
-
>
numExec
(
)
:
0
.
0
)
{
if
(
!
sp
-
>
jsprintf
(
"
\
"
%
s
\
"
:
%
.
0f
"
PCCounts
:
:
numExecName
val
)
)
return
false
;
}
if
(
sp
-
>
put
(
"
}
\
n
"
)
<
0
)
return
false
;
pc
=
next
;
}
#
endif
jit
:
:
IonScriptCounts
*
ionCounts
=
script
-
>
getIonCounts
(
)
;
while
(
ionCounts
)
{
if
(
!
DumpIonScriptCounts
(
sp
script
ionCounts
)
)
return
false
;
ionCounts
=
ionCounts
-
>
previous
(
)
;
}
return
true
;
}
bool
js
:
:
DumpCompartmentPCCounts
(
JSContext
*
cx
)
{
Rooted
<
GCVector
<
JSScript
*
>
>
scripts
(
cx
GCVector
<
JSScript
*
>
(
cx
)
)
;
for
(
auto
iter
=
cx
-
>
zone
(
)
-
>
cellIter
<
JSScript
>
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
JSScript
*
script
=
iter
;
if
(
script
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
continue
;
if
(
script
-
>
hasScriptCounts
(
)
)
{
if
(
!
scripts
.
append
(
script
)
)
return
false
;
}
}
for
(
uint32_t
i
=
0
;
i
<
scripts
.
length
(
)
;
i
+
+
)
{
HandleScript
script
=
scripts
[
i
]
;
Sprinter
sprinter
(
cx
)
;
if
(
!
sprinter
.
init
(
)
)
return
false
;
fprintf
(
stdout
"
-
-
-
SCRIPT
%
s
:
%
"
PRIuSIZE
"
-
-
-
\
n
"
script
-
>
filename
(
)
script
-
>
lineno
(
)
)
;
if
(
!
DumpPCCounts
(
cx
script
&
sprinter
)
)
return
false
;
fputs
(
sprinter
.
string
(
)
stdout
)
;
fprintf
(
stdout
"
-
-
-
END
SCRIPT
%
s
:
%
"
PRIuSIZE
"
-
-
-
\
n
"
script
-
>
filename
(
)
script
-
>
lineno
(
)
)
;
}
return
true
;
}
namespace
{
class
BytecodeParser
{
class
Bytecode
{
public
:
Bytecode
(
)
{
mozilla
:
:
PodZero
(
this
)
;
}
bool
parsed
:
1
;
uint32_t
stackDepth
;
uint32_t
*
offsetStack
;
bool
captureOffsetStack
(
LifoAlloc
&
alloc
const
uint32_t
*
stack
uint32_t
depth
)
{
stackDepth
=
depth
;
offsetStack
=
alloc
.
newArray
<
uint32_t
>
(
stackDepth
)
;
if
(
!
offsetStack
)
return
false
;
if
(
stackDepth
)
{
for
(
uint32_t
n
=
0
;
n
<
stackDepth
;
n
+
+
)
offsetStack
[
n
]
=
stack
[
n
]
;
}
return
true
;
}
void
mergeOffsetStack
(
const
uint32_t
*
stack
uint32_t
depth
)
{
MOZ_ASSERT
(
depth
=
=
stackDepth
)
;
for
(
uint32_t
n
=
0
;
n
<
stackDepth
;
n
+
+
)
{
if
(
stack
[
n
]
=
=
SpecialOffsets
:
:
IgnoreOffset
)
continue
;
if
(
offsetStack
[
n
]
=
=
SpecialOffsets
:
:
IgnoreOffset
)
offsetStack
[
n
]
=
stack
[
n
]
;
if
(
offsetStack
[
n
]
!
=
stack
[
n
]
)
offsetStack
[
n
]
=
SpecialOffsets
:
:
UnknownOffset
;
}
}
}
;
JSContext
*
cx_
;
LifoAllocScope
allocScope_
;
RootedScript
script_
;
Bytecode
*
*
codeArray_
;
struct
SpecialOffsets
{
static
const
uint32_t
UnknownOffset
=
UINT32_MAX
;
static
const
uint32_t
IgnoreOffset
=
UINT32_MAX
-
1
;
static
const
uint32_t
FirstSpecialOffset
=
IgnoreOffset
;
}
;
public
:
BytecodeParser
(
JSContext
*
cx
JSScript
*
script
)
:
cx_
(
cx
)
allocScope_
(
&
cx
-
>
tempLifoAlloc
(
)
)
script_
(
cx
script
)
codeArray_
(
nullptr
)
{
}
bool
parse
(
)
;
#
ifdef
DEBUG
bool
isReachable
(
uint32_t
offset
)
{
return
maybeCode
(
offset
)
;
}
bool
isReachable
(
const
jsbytecode
*
pc
)
{
return
maybeCode
(
pc
)
;
}
#
endif
uint32_t
stackDepthAtPC
(
uint32_t
offset
)
{
return
getCode
(
offset
)
.
stackDepth
;
}
uint32_t
stackDepthAtPC
(
const
jsbytecode
*
pc
)
{
return
stackDepthAtPC
(
script_
-
>
pcToOffset
(
pc
)
)
;
}
uint32_t
offsetForStackOperand
(
uint32_t
offset
int
operand
)
{
Bytecode
&
code
=
getCode
(
offset
)
;
if
(
operand
<
0
)
{
operand
+
=
code
.
stackDepth
;
MOZ_ASSERT
(
operand
>
=
0
)
;
}
MOZ_ASSERT
(
uint32_t
(
operand
)
<
code
.
stackDepth
)
;
return
code
.
offsetStack
[
operand
]
;
}
jsbytecode
*
pcForStackOperand
(
jsbytecode
*
pc
int
operand
)
{
uint32_t
offset
=
offsetForStackOperand
(
script_
-
>
pcToOffset
(
pc
)
operand
)
;
if
(
offset
>
=
SpecialOffsets
:
:
FirstSpecialOffset
)
return
nullptr
;
return
script_
-
>
offsetToPC
(
offsetForStackOperand
(
script_
-
>
pcToOffset
(
pc
)
operand
)
)
;
}
private
:
LifoAlloc
&
alloc
(
)
{
return
allocScope_
.
alloc
(
)
;
}
void
reportOOM
(
)
{
allocScope_
.
releaseEarly
(
)
;
ReportOutOfMemory
(
cx_
)
;
}
uint32_t
numSlots
(
)
{
return
1
+
script_
-
>
nfixed
(
)
+
(
script_
-
>
functionNonDelazifying
(
)
?
script_
-
>
functionNonDelazifying
(
)
-
>
nargs
(
)
:
0
)
;
}
uint32_t
maximumStackDepth
(
)
{
return
script_
-
>
nslots
(
)
-
script_
-
>
nfixed
(
)
;
}
Bytecode
&
getCode
(
uint32_t
offset
)
{
MOZ_ASSERT
(
offset
<
script_
-
>
length
(
)
)
;
MOZ_ASSERT
(
codeArray_
[
offset
]
)
;
return
*
codeArray_
[
offset
]
;
}
Bytecode
&
getCode
(
const
jsbytecode
*
pc
)
{
return
getCode
(
script_
-
>
pcToOffset
(
pc
)
)
;
}
Bytecode
*
maybeCode
(
uint32_t
offset
)
{
MOZ_ASSERT
(
offset
<
script_
-
>
length
(
)
)
;
return
codeArray_
[
offset
]
;
}
Bytecode
*
maybeCode
(
const
jsbytecode
*
pc
)
{
return
maybeCode
(
script_
-
>
pcToOffset
(
pc
)
)
;
}
uint32_t
simulateOp
(
JSOp
op
uint32_t
offset
uint32_t
*
offsetStack
uint32_t
stackDepth
)
;
inline
bool
recordBytecode
(
uint32_t
offset
const
uint32_t
*
offsetStack
uint32_t
stackDepth
)
;
inline
bool
addJump
(
uint32_t
offset
uint32_t
*
currentOffset
uint32_t
stackDepth
const
uint32_t
*
offsetStack
)
;
}
;
}
uint32_t
BytecodeParser
:
:
simulateOp
(
JSOp
op
uint32_t
offset
uint32_t
*
offsetStack
uint32_t
stackDepth
)
{
uint32_t
nuses
=
GetUseCount
(
script_
offset
)
;
uint32_t
ndefs
=
GetDefCount
(
script_
offset
)
;
MOZ_ASSERT
(
stackDepth
>
=
nuses
)
;
stackDepth
-
=
nuses
;
MOZ_ASSERT
(
stackDepth
+
ndefs
<
=
maximumStackDepth
(
)
)
;
switch
(
op
)
{
default
:
for
(
uint32_t
n
=
0
;
n
!
=
ndefs
;
+
+
n
)
offsetStack
[
stackDepth
+
n
]
=
offset
;
break
;
case
JSOP_NOP_DESTRUCTURING
:
offsetStack
[
stackDepth
-
1
]
=
SpecialOffsets
:
:
IgnoreOffset
;
break
;
case
JSOP_CASE
:
MOZ_ASSERT
(
ndefs
=
=
1
)
;
break
;
case
JSOP_DUP
:
MOZ_ASSERT
(
ndefs
=
=
2
)
;
if
(
offsetStack
)
offsetStack
[
stackDepth
+
1
]
=
offsetStack
[
stackDepth
]
;
break
;
case
JSOP_DUP2
:
MOZ_ASSERT
(
ndefs
=
=
4
)
;
if
(
offsetStack
)
{
offsetStack
[
stackDepth
+
2
]
=
offsetStack
[
stackDepth
]
;
offsetStack
[
stackDepth
+
3
]
=
offsetStack
[
stackDepth
+
1
]
;
}
break
;
case
JSOP_DUPAT
:
{
MOZ_ASSERT
(
ndefs
=
=
1
)
;
jsbytecode
*
pc
=
script_
-
>
offsetToPC
(
offset
)
;
unsigned
n
=
GET_UINT24
(
pc
)
;
MOZ_ASSERT
(
n
<
stackDepth
)
;
if
(
offsetStack
)
offsetStack
[
stackDepth
]
=
offsetStack
[
stackDepth
-
1
-
n
]
;
break
;
}
case
JSOP_SWAP
:
MOZ_ASSERT
(
ndefs
=
=
2
)
;
if
(
offsetStack
)
{
uint32_t
tmp
=
offsetStack
[
stackDepth
+
1
]
;
offsetStack
[
stackDepth
+
1
]
=
offsetStack
[
stackDepth
]
;
offsetStack
[
stackDepth
]
=
tmp
;
}
break
;
}
stackDepth
+
=
ndefs
;
return
stackDepth
;
}
bool
BytecodeParser
:
:
recordBytecode
(
uint32_t
offset
const
uint32_t
*
offsetStack
uint32_t
stackDepth
)
{
MOZ_ASSERT
(
offset
<
script_
-
>
length
(
)
)
;
Bytecode
*
&
code
=
codeArray_
[
offset
]
;
if
(
!
code
)
{
code
=
alloc
(
)
.
new_
<
Bytecode
>
(
)
;
if
(
!
code
|
|
!
code
-
>
captureOffsetStack
(
alloc
(
)
offsetStack
stackDepth
)
)
{
reportOOM
(
)
;
return
false
;
}
}
else
{
code
-
>
mergeOffsetStack
(
offsetStack
stackDepth
)
;
}
return
true
;
}
bool
BytecodeParser
:
:
addJump
(
uint32_t
offset
uint32_t
*
currentOffset
uint32_t
stackDepth
const
uint32_t
*
offsetStack
)
{
if
(
!
recordBytecode
(
offset
offsetStack
stackDepth
)
)
return
false
;
Bytecode
*
&
code
=
codeArray_
[
offset
]
;
if
(
offset
<
*
currentOffset
&
&
!
code
-
>
parsed
)
{
*
currentOffset
=
offset
;
}
return
true
;
}
bool
BytecodeParser
:
:
parse
(
)
{
MOZ_ASSERT
(
!
codeArray_
)
;
uint32_t
length
=
script_
-
>
length
(
)
;
codeArray_
=
alloc
(
)
.
newArray
<
Bytecode
*
>
(
length
)
;
if
(
!
codeArray_
)
{
reportOOM
(
)
;
return
false
;
}
mozilla
:
:
PodZero
(
codeArray_
length
)
;
Bytecode
*
startcode
=
alloc
(
)
.
new_
<
Bytecode
>
(
)
;
if
(
!
startcode
)
{
reportOOM
(
)
;
return
false
;
}
uint32_t
*
offsetStack
=
alloc
(
)
.
newArray
<
uint32_t
>
(
maximumStackDepth
(
)
)
;
if
(
maximumStackDepth
(
)
&
&
!
offsetStack
)
{
reportOOM
(
)
;
return
false
;
}
startcode
-
>
stackDepth
=
0
;
codeArray_
[
0
]
=
startcode
;
uint32_t
offset
nextOffset
=
0
;
while
(
nextOffset
<
length
)
{
offset
=
nextOffset
;
Bytecode
*
code
=
maybeCode
(
offset
)
;
jsbytecode
*
pc
=
script_
-
>
offsetToPC
(
offset
)
;
JSOp
op
=
(
JSOp
)
*
pc
;
MOZ_ASSERT
(
op
<
JSOP_LIMIT
)
;
uint32_t
successorOffset
=
offset
+
GetBytecodeLength
(
pc
)
;
nextOffset
=
successorOffset
;
if
(
!
code
)
{
continue
;
}
if
(
BytecodeIsJumpTarget
(
op
)
)
{
for
(
uint32_t
n
=
0
;
n
<
code
-
>
stackDepth
;
+
+
n
)
offsetStack
[
n
]
=
code
-
>
offsetStack
[
n
]
;
}
if
(
code
-
>
parsed
)
{
continue
;
}
code
-
>
parsed
=
true
;
uint32_t
stackDepth
=
simulateOp
(
op
offset
offsetStack
code
-
>
stackDepth
)
;
switch
(
op
)
{
case
JSOP_TABLESWITCH
:
{
uint32_t
defaultOffset
=
offset
+
GET_JUMP_OFFSET
(
pc
)
;
jsbytecode
*
pc2
=
pc
+
JUMP_OFFSET_LEN
;
int32_t
low
=
GET_JUMP_OFFSET
(
pc2
)
;
pc2
+
=
JUMP_OFFSET_LEN
;
int32_t
high
=
GET_JUMP_OFFSET
(
pc2
)
;
pc2
+
=
JUMP_OFFSET_LEN
;
if
(
!
addJump
(
defaultOffset
&
nextOffset
stackDepth
offsetStack
)
)
return
false
;
for
(
int32_t
i
=
low
;
i
<
=
high
;
i
+
+
)
{
uint32_t
targetOffset
=
offset
+
GET_JUMP_OFFSET
(
pc2
)
;
if
(
targetOffset
!
=
offset
)
{
if
(
!
addJump
(
targetOffset
&
nextOffset
stackDepth
offsetStack
)
)
return
false
;
}
pc2
+
=
JUMP_OFFSET_LEN
;
}
break
;
}
case
JSOP_TRY
:
{
JSTryNote
*
tn
=
script_
-
>
trynotes
(
)
-
>
vector
;
JSTryNote
*
tnlimit
=
tn
+
script_
-
>
trynotes
(
)
-
>
length
;
for
(
;
tn
<
tnlimit
;
tn
+
+
)
{
uint32_t
startOffset
=
script_
-
>
mainOffset
(
)
+
tn
-
>
start
;
if
(
startOffset
=
=
offset
+
1
)
{
uint32_t
catchOffset
=
startOffset
+
tn
-
>
length
;
if
(
tn
-
>
kind
=
=
JSTRY_CATCH
|
|
tn
-
>
kind
=
=
JSTRY_FINALLY
)
{
if
(
!
addJump
(
catchOffset
&
nextOffset
stackDepth
offsetStack
)
)
return
false
;
}
}
}
break
;
}
default
:
break
;
}
if
(
IsJumpOpcode
(
op
)
)
{
uint32_t
newStackDepth
=
stackDepth
;
if
(
op
=
=
JSOP_CASE
)
newStackDepth
-
-
;
uint32_t
targetOffset
=
offset
+
GET_JUMP_OFFSET
(
pc
)
;
if
(
!
addJump
(
targetOffset
&
nextOffset
newStackDepth
offsetStack
)
)
return
false
;
}
if
(
BytecodeFallsThrough
(
op
)
)
{
if
(
!
recordBytecode
(
successorOffset
offsetStack
stackDepth
)
)
return
false
;
}
}
return
true
;
}
#
ifdef
DEBUG
bool
js
:
:
ReconstructStackDepth
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
uint32_t
*
depth
bool
*
reachablePC
)
{
BytecodeParser
parser
(
cx
script
)
;
if
(
!
parser
.
parse
(
)
)
return
false
;
*
reachablePC
=
parser
.
isReachable
(
pc
)
;
if
(
*
reachablePC
)
*
depth
=
parser
.
stackDepthAtPC
(
pc
)
;
return
true
;
}
static
MOZ_MUST_USE
bool
DisassembleAtPC
(
JSContext
*
cx
JSScript
*
scriptArg
bool
lines
jsbytecode
*
pc
bool
showAll
Sprinter
*
sp
)
{
RootedScript
script
(
cx
scriptArg
)
;
BytecodeParser
parser
(
cx
script
)
;
if
(
showAll
)
{
if
(
!
parser
.
parse
(
)
)
return
false
;
if
(
!
sp
-
>
jsprintf
(
"
%
s
:
%
u
\
n
"
script
-
>
filename
(
)
unsigned
(
script
-
>
lineno
(
)
)
)
)
return
false
;
}
if
(
pc
!
=
nullptr
)
{
if
(
sp
-
>
put
(
"
"
)
<
0
)
return
false
;
}
if
(
showAll
)
{
if
(
sp
-
>
put
(
"
sn
stack
"
)
<
0
)
return
false
;
}
if
(
sp
-
>
put
(
"
loc
"
)
<
0
)
return
false
;
if
(
lines
)
{
if
(
sp
-
>
put
(
"
line
"
)
<
0
)
return
false
;
}
if
(
sp
-
>
put
(
"
op
\
n
"
)
<
0
)
return
false
;
if
(
pc
!
=
nullptr
)
{
if
(
sp
-
>
put
(
"
"
)
<
0
)
return
false
;
}
if
(
showAll
)
{
if
(
sp
-
>
put
(
"
-
-
-
-
-
-
-
"
)
<
0
)
return
false
;
}
if
(
sp
-
>
put
(
"
-
-
-
-
-
"
)
<
0
)
return
false
;
if
(
lines
)
{
if
(
sp
-
>
put
(
"
-
-
-
-
"
)
<
0
)
return
false
;
}
if
(
sp
-
>
put
(
"
-
-
\
n
"
)
<
0
)
return
false
;
jsbytecode
*
next
=
script
-
>
code
(
)
;
jsbytecode
*
end
=
script
-
>
codeEnd
(
)
;
while
(
next
<
end
)
{
if
(
next
=
=
script
-
>
main
(
)
)
{
if
(
sp
-
>
put
(
"
main
:
\
n
"
)
<
0
)
return
false
;
}
if
(
pc
!
=
nullptr
)
{
if
(
sp
-
>
put
(
pc
=
=
next
?
"
-
-
>
"
:
"
"
)
<
0
)
return
false
;
}
if
(
showAll
)
{
jssrcnote
*
sn
=
GetSrcNote
(
cx
script
next
)
;
if
(
sn
)
{
MOZ_ASSERT
(
!
SN_IS_TERMINATOR
(
sn
)
)
;
jssrcnote
*
next
=
SN_NEXT
(
sn
)
;
while
(
!
SN_IS_TERMINATOR
(
next
)
&
&
SN_DELTA
(
next
)
=
=
0
)
{
if
(
!
sp
-
>
jsprintf
(
"
%
02u
\
n
"
SN_TYPE
(
sn
)
)
)
return
false
;
sn
=
next
;
next
=
SN_NEXT
(
sn
)
;
}
if
(
!
sp
-
>
jsprintf
(
"
%
02u
"
SN_TYPE
(
sn
)
)
)
return
false
;
}
else
{
if
(
sp
-
>
put
(
"
"
)
<
0
)
return
false
;
}
if
(
parser
.
isReachable
(
next
)
)
{
if
(
!
sp
-
>
jsprintf
(
"
%
05u
"
parser
.
stackDepthAtPC
(
next
)
)
)
return
false
;
}
else
{
if
(
sp
-
>
put
(
"
"
)
<
0
)
return
false
;
}
}
unsigned
len
=
Disassemble1
(
cx
script
next
script
-
>
pcToOffset
(
next
)
lines
sp
)
;
if
(
!
len
)
return
false
;
next
+
=
len
;
}
return
true
;
}
bool
js
:
:
Disassemble
(
JSContext
*
cx
HandleScript
script
bool
lines
Sprinter
*
sp
)
{
return
DisassembleAtPC
(
cx
script
lines
nullptr
false
sp
)
;
}
JS_FRIEND_API
(
bool
)
js
:
:
DumpPC
(
JSContext
*
cx
FILE
*
fp
)
{
gc
:
:
AutoSuppressGC
suppressGC
(
cx
)
;
Sprinter
sprinter
(
cx
)
;
if
(
!
sprinter
.
init
(
)
)
return
false
;
ScriptFrameIter
iter
(
cx
)
;
if
(
iter
.
done
(
)
)
{
fprintf
(
fp
"
Empty
stack
.
\
n
"
)
;
return
true
;
}
RootedScript
script
(
cx
iter
.
script
(
)
)
;
bool
ok
=
DisassembleAtPC
(
cx
script
true
iter
.
pc
(
)
false
&
sprinter
)
;
fprintf
(
fp
"
%
s
"
sprinter
.
string
(
)
)
;
return
ok
;
}
JS_FRIEND_API
(
bool
)
js
:
:
DumpScript
(
JSContext
*
cx
JSScript
*
scriptArg
FILE
*
fp
)
{
gc
:
:
AutoSuppressGC
suppressGC
(
cx
)
;
Sprinter
sprinter
(
cx
)
;
if
(
!
sprinter
.
init
(
)
)
return
false
;
RootedScript
script
(
cx
scriptArg
)
;
bool
ok
=
Disassemble
(
cx
script
true
&
sprinter
)
;
fprintf
(
fp
"
%
s
"
sprinter
.
string
(
)
)
;
return
ok
;
}
static
bool
ToDisassemblySource
(
JSContext
*
cx
HandleValue
v
JSAutoByteString
*
bytes
)
{
if
(
v
.
isString
(
)
)
{
Sprinter
sprinter
(
cx
)
;
if
(
!
sprinter
.
init
(
)
)
return
false
;
char
*
nbytes
=
QuoteString
(
&
sprinter
v
.
toString
(
)
'
"
'
)
;
if
(
!
nbytes
)
return
false
;
nbytes
=
JS_sprintf_append
(
nullptr
"
%
s
"
nbytes
)
;
if
(
!
nbytes
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
bytes
-
>
initBytes
(
nbytes
)
;
return
true
;
}
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
if
(
rt
-
>
isHeapBusy
(
)
|
|
!
rt
-
>
gc
.
isAllocAllowed
(
)
)
{
char
*
source
=
JS_sprintf_append
(
nullptr
"
<
value
>
"
)
;
if
(
!
source
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
bytes
-
>
initBytes
(
source
)
;
return
true
;
}
if
(
v
.
isObject
(
)
)
{
JSObject
&
obj
=
v
.
toObject
(
)
;
if
(
obj
.
is
<
JSFunction
>
(
)
)
{
RootedFunction
fun
(
cx
&
obj
.
as
<
JSFunction
>
(
)
)
;
JSString
*
str
=
JS_DecompileFunction
(
cx
fun
JS_DONT_PRETTY_PRINT
)
;
if
(
!
str
)
return
false
;
return
bytes
-
>
encodeLatin1
(
cx
str
)
;
}
if
(
obj
.
is
<
RegExpObject
>
(
)
)
{
JSString
*
source
=
obj
.
as
<
RegExpObject
>
(
)
.
toString
(
cx
)
;
if
(
!
source
)
return
false
;
return
bytes
-
>
encodeLatin1
(
cx
source
)
;
}
}
return
!
!
ValueToPrintable
(
cx
v
bytes
true
)
;
}
static
bool
ToDisassemblySource
(
JSContext
*
cx
HandleScope
scope
JSAutoByteString
*
bytes
)
{
char
*
source
=
JS_sprintf_append
(
nullptr
"
%
s
{
"
ScopeKindString
(
scope
-
>
kind
(
)
)
)
;
if
(
!
source
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
for
(
Rooted
<
BindingIter
>
bi
(
cx
BindingIter
(
scope
)
)
;
bi
;
bi
+
+
)
{
JSAutoByteString
nameBytes
;
if
(
!
AtomToPrintableString
(
cx
bi
.
name
(
)
&
nameBytes
)
)
return
false
;
source
=
JS_sprintf_append
(
source
"
%
s
:
"
nameBytes
.
ptr
(
)
)
;
if
(
!
source
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
BindingLocation
loc
=
bi
.
location
(
)
;
switch
(
loc
.
kind
(
)
)
{
case
BindingLocation
:
:
Kind
:
:
Global
:
source
=
JS_sprintf_append
(
source
"
global
"
)
;
break
;
case
BindingLocation
:
:
Kind
:
:
Frame
:
source
=
JS_sprintf_append
(
source
"
frame
slot
%
u
"
loc
.
slot
(
)
)
;
break
;
case
BindingLocation
:
:
Kind
:
:
Environment
:
source
=
JS_sprintf_append
(
source
"
env
slot
%
u
"
loc
.
slot
(
)
)
;
break
;
case
BindingLocation
:
:
Kind
:
:
Argument
:
source
=
JS_sprintf_append
(
source
"
arg
slot
%
u
"
loc
.
slot
(
)
)
;
break
;
case
BindingLocation
:
:
Kind
:
:
NamedLambdaCallee
:
source
=
JS_sprintf_append
(
source
"
named
lambda
callee
"
)
;
break
;
case
BindingLocation
:
:
Kind
:
:
Import
:
source
=
JS_sprintf_append
(
source
"
import
"
)
;
break
;
}
if
(
!
source
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
if
(
!
bi
.
isLast
(
)
)
{
source
=
JS_sprintf_append
(
source
"
"
)
;
if
(
!
source
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
}
source
=
JS_sprintf_append
(
source
"
}
"
)
;
if
(
!
source
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
bytes
-
>
initBytes
(
source
)
;
return
true
;
}
unsigned
js
:
:
Disassemble1
(
JSContext
*
cx
HandleScript
script
jsbytecode
*
pc
unsigned
loc
bool
lines
Sprinter
*
sp
)
{
JSOp
op
=
(
JSOp
)
*
pc
;
if
(
op
>
=
JSOP_LIMIT
)
{
char
numBuf1
[
12
]
numBuf2
[
12
]
;
SprintfLiteral
(
numBuf1
"
%
d
"
op
)
;
SprintfLiteral
(
numBuf2
"
%
d
"
JSOP_LIMIT
)
;
JS_ReportErrorNumber
(
cx
GetErrorMessage
nullptr
JSMSG_BYTECODE_TOO_BIG
numBuf1
numBuf2
)
;
return
0
;
}
const
JSCodeSpec
*
cs
=
&
CodeSpec
[
op
]
;
ptrdiff_t
len
=
(
ptrdiff_t
)
cs
-
>
length
;
if
(
!
sp
-
>
jsprintf
(
"
%
05u
:
"
loc
)
)
return
0
;
if
(
lines
)
{
if
(
!
sp
-
>
jsprintf
(
"
%
4u
"
PCToLineNumber
(
script
pc
)
)
)
return
0
;
}
if
(
!
sp
-
>
jsprintf
(
"
%
s
"
CodeName
[
op
]
)
)
return
0
;
int
i
;
switch
(
JOF_TYPE
(
cs
-
>
format
)
)
{
case
JOF_BYTE
:
if
(
op
=
=
JSOP_TRY
)
{
TryNoteArray
*
trynotes
=
script
-
>
trynotes
(
)
;
uint32_t
i
;
for
(
i
=
0
;
i
<
trynotes
-
>
length
;
i
+
+
)
{
JSTryNote
note
=
trynotes
-
>
vector
[
i
]
;
if
(
note
.
kind
=
=
JSTRY_CATCH
&
&
note
.
start
=
=
loc
+
1
)
{
if
(
!
sp
-
>
jsprintf
(
"
%
u
(
%
+
d
)
"
unsigned
(
loc
+
note
.
length
+
1
)
int
(
note
.
length
+
1
)
)
)
{
return
0
;
}
break
;
}
}
}
break
;
case
JOF_JUMP
:
{
ptrdiff_t
off
=
GET_JUMP_OFFSET
(
pc
)
;
if
(
!
sp
-
>
jsprintf
(
"
%
u
(
%
+
d
)
"
unsigned
(
loc
+
int
(
off
)
)
int
(
off
)
)
)
return
0
;
break
;
}
case
JOF_SCOPE
:
{
RootedScope
scope
(
cx
script
-
>
getScope
(
GET_UINT32_INDEX
(
pc
)
)
)
;
JSAutoByteString
bytes
;
if
(
!
ToDisassemblySource
(
cx
scope
&
bytes
)
)
return
0
;
if
(
!
sp
-
>
jsprintf
(
"
%
s
"
bytes
.
ptr
(
)
)
)
return
0
;
break
;
}
case
JOF_ENVCOORD
:
{
RootedValue
v
(
cx
StringValue
(
EnvironmentCoordinateName
(
cx
-
>
caches
.
envCoordinateNameCache
script
pc
)
)
)
;
JSAutoByteString
bytes
;
if
(
!
ToDisassemblySource
(
cx
v
&
bytes
)
)
return
0
;
EnvironmentCoordinate
ec
(
pc
)
;
if
(
!
sp
-
>
jsprintf
(
"
%
s
(
hops
=
%
u
slot
=
%
u
)
"
bytes
.
ptr
(
)
ec
.
hops
(
)
ec
.
slot
(
)
)
)
return
0
;
break
;
}
case
JOF_ATOM
:
{
RootedValue
v
(
cx
StringValue
(
script
-
>
getAtom
(
GET_UINT32_INDEX
(
pc
)
)
)
)
;
JSAutoByteString
bytes
;
if
(
!
ToDisassemblySource
(
cx
v
&
bytes
)
)
return
0
;
if
(
!
sp
-
>
jsprintf
(
"
%
s
"
bytes
.
ptr
(
)
)
)
return
0
;
break
;
}
case
JOF_DOUBLE
:
{
RootedValue
v
(
cx
script
-
>
getConst
(
GET_UINT32_INDEX
(
pc
)
)
)
;
JSAutoByteString
bytes
;
if
(
!
ToDisassemblySource
(
cx
v
&
bytes
)
)
return
0
;
if
(
!
sp
-
>
jsprintf
(
"
%
s
"
bytes
.
ptr
(
)
)
)
return
0
;
break
;
}
case
JOF_OBJECT
:
{
if
(
script
-
>
zone
(
)
-
>
types
.
activeAnalysis
)
{
if
(
!
sp
-
>
jsprintf
(
"
object
"
)
)
return
0
;
break
;
}
JSObject
*
obj
=
script
-
>
getObject
(
GET_UINT32_INDEX
(
pc
)
)
;
{
JSAutoByteString
bytes
;
RootedValue
v
(
cx
ObjectValue
(
*
obj
)
)
;
if
(
!
ToDisassemblySource
(
cx
v
&
bytes
)
)
return
0
;
if
(
!
sp
-
>
jsprintf
(
"
%
s
"
bytes
.
ptr
(
)
)
)
return
0
;
}
break
;
}
case
JOF_REGEXP
:
{
js
:
:
RegExpObject
*
obj
=
script
-
>
getRegExp
(
pc
)
;
JSAutoByteString
bytes
;
RootedValue
v
(
cx
ObjectValue
(
*
obj
)
)
;
if
(
!
ToDisassemblySource
(
cx
v
&
bytes
)
)
return
0
;
if
(
!
sp
-
>
jsprintf
(
"
%
s
"
bytes
.
ptr
(
)
)
)
return
0
;
break
;
}
case
JOF_TABLESWITCH
:
{
int32_t
i
low
high
;
ptrdiff_t
off
=
GET_JUMP_OFFSET
(
pc
)
;
jsbytecode
*
pc2
=
pc
+
JUMP_OFFSET_LEN
;
low
=
GET_JUMP_OFFSET
(
pc2
)
;
pc2
+
=
JUMP_OFFSET_LEN
;
high
=
GET_JUMP_OFFSET
(
pc2
)
;
pc2
+
=
JUMP_OFFSET_LEN
;
if
(
!
sp
-
>
jsprintf
(
"
defaultOffset
%
d
low
%
d
high
%
d
"
int
(
off
)
low
high
)
)
return
0
;
for
(
i
=
low
;
i
<
=
high
;
i
+
+
)
{
off
=
GET_JUMP_OFFSET
(
pc2
)
;
if
(
!
sp
-
>
jsprintf
(
"
\
n
\
t
%
d
:
%
d
"
i
int
(
off
)
)
)
return
0
;
pc2
+
=
JUMP_OFFSET_LEN
;
}
len
=
1
+
pc2
-
pc
;
break
;
}
case
JOF_QARG
:
if
(
!
sp
-
>
jsprintf
(
"
%
u
"
GET_ARGNO
(
pc
)
)
)
return
0
;
break
;
case
JOF_LOCAL
:
if
(
!
sp
-
>
jsprintf
(
"
%
u
"
GET_LOCALNO
(
pc
)
)
)
return
0
;
break
;
case
JOF_UINT32
:
if
(
!
sp
-
>
jsprintf
(
"
%
u
"
GET_UINT32
(
pc
)
)
)
return
0
;
break
;
case
JOF_UINT16
:
i
=
(
int
)
GET_UINT16
(
pc
)
;
goto
print_int
;
case
JOF_UINT24
:
MOZ_ASSERT
(
len
=
=
4
)
;
i
=
(
int
)
GET_UINT24
(
pc
)
;
goto
print_int
;
case
JOF_UINT8
:
i
=
GET_UINT8
(
pc
)
;
goto
print_int
;
case
JOF_INT8
:
i
=
GET_INT8
(
pc
)
;
goto
print_int
;
case
JOF_INT32
:
MOZ_ASSERT
(
op
=
=
JSOP_INT32
)
;
i
=
GET_INT32
(
pc
)
;
print_int
:
if
(
!
sp
-
>
jsprintf
(
"
%
d
"
i
)
)
return
0
;
break
;
default
:
{
char
numBuf
[
12
]
;
SprintfLiteral
(
numBuf
"
%
x
"
cs
-
>
format
)
;
JS_ReportErrorNumber
(
cx
GetErrorMessage
nullptr
JSMSG_UNKNOWN_FORMAT
numBuf
)
;
return
0
;
}
}
sp
-
>
put
(
"
\
n
"
)
;
return
len
;
}
#
endif
namespace
{
struct
ExpressionDecompiler
{
JSContext
*
cx
;
RootedScript
script
;
BytecodeParser
parser
;
Sprinter
sprinter
;
ExpressionDecompiler
(
JSContext
*
cx
JSScript
*
script
)
:
cx
(
cx
)
script
(
cx
script
)
parser
(
cx
script
)
sprinter
(
cx
)
{
}
bool
init
(
)
;
bool
decompilePCForStackOperand
(
jsbytecode
*
pc
int
i
)
;
bool
decompilePC
(
jsbytecode
*
pc
)
;
JSAtom
*
getArg
(
unsigned
slot
)
;
JSAtom
*
loadAtom
(
jsbytecode
*
pc
)
;
bool
quote
(
JSString
*
s
uint32_t
quote
)
;
bool
write
(
const
char
*
s
)
;
bool
write
(
JSString
*
str
)
;
bool
getOutput
(
char
*
*
out
)
;
}
;
bool
ExpressionDecompiler
:
:
decompilePCForStackOperand
(
jsbytecode
*
pc
int
i
)
{
pc
=
parser
.
pcForStackOperand
(
pc
i
)
;
if
(
!
pc
)
return
write
(
"
(
intermediate
value
)
"
)
;
return
decompilePC
(
pc
)
;
}
bool
ExpressionDecompiler
:
:
decompilePC
(
jsbytecode
*
pc
)
{
MOZ_ASSERT
(
script
-
>
containsPC
(
pc
)
)
;
JSOp
op
=
(
JSOp
)
*
pc
;
if
(
const
char
*
token
=
CodeToken
[
op
]
)
{
switch
(
CodeSpec
[
op
]
.
nuses
)
{
case
2
:
{
jssrcnote
*
sn
=
GetSrcNote
(
cx
script
pc
)
;
if
(
!
sn
|
|
SN_TYPE
(
sn
)
!
=
SRC_ASSIGNOP
)
return
write
(
"
(
"
)
&
&
decompilePCForStackOperand
(
pc
-
2
)
&
&
write
(
"
"
)
&
&
write
(
token
)
&
&
write
(
"
"
)
&
&
decompilePCForStackOperand
(
pc
-
1
)
&
&
write
(
"
)
"
)
;
break
;
}
case
1
:
return
write
(
token
)
&
&
write
(
"
(
"
)
&
&
decompilePCForStackOperand
(
pc
-
1
)
&
&
write
(
"
)
"
)
;
default
:
break
;
}
}
switch
(
op
)
{
case
JSOP_GETGNAME
:
case
JSOP_GETNAME
:
case
JSOP_GETINTRINSIC
:
return
write
(
loadAtom
(
pc
)
)
;
case
JSOP_GETARG
:
{
unsigned
slot
=
GET_ARGNO
(
pc
)
;
JSAtom
*
atom
=
getArg
(
slot
)
;
if
(
!
atom
)
return
false
;
return
write
(
atom
)
;
}
case
JSOP_GETLOCAL
:
{
JSAtom
*
atom
=
FrameSlotName
(
script
pc
)
;
MOZ_ASSERT
(
atom
)
;
return
write
(
atom
)
;
}
case
JSOP_GETALIASEDVAR
:
{
JSAtom
*
atom
=
EnvironmentCoordinateName
(
cx
-
>
caches
.
envCoordinateNameCache
script
pc
)
;
MOZ_ASSERT
(
atom
)
;
return
write
(
atom
)
;
}
case
JSOP_LENGTH
:
case
JSOP_GETPROP
:
case
JSOP_CALLPROP
:
{
RootedAtom
prop
(
cx
(
op
=
=
JSOP_LENGTH
)
?
cx
-
>
names
(
)
.
length
:
loadAtom
(
pc
)
)
;
if
(
!
decompilePCForStackOperand
(
pc
-
1
)
)
return
false
;
if
(
IsIdentifier
(
prop
)
)
{
return
write
(
"
.
"
)
&
&
quote
(
prop
'
\
0
'
)
;
}
return
write
(
"
[
"
)
&
&
quote
(
prop
'
\
'
'
)
&
&
write
(
"
]
"
)
;
}
case
JSOP_GETPROP_SUPER
:
{
RootedAtom
prop
(
cx
loadAtom
(
pc
)
)
;
return
write
(
"
super
.
"
)
&
&
quote
(
prop
'
\
0
'
)
;
}
case
JSOP_GETELEM
:
case
JSOP_CALLELEM
:
return
decompilePCForStackOperand
(
pc
-
2
)
&
&
write
(
"
[
"
)
&
&
decompilePCForStackOperand
(
pc
-
1
)
&
&
write
(
"
]
"
)
;
case
JSOP_GETELEM_SUPER
:
return
write
(
"
super
[
"
)
&
&
decompilePCForStackOperand
(
pc
-
3
)
&
&
write
(
"
]
"
)
;
case
JSOP_NULL
:
return
write
(
js_null_str
)
;
case
JSOP_TRUE
:
return
write
(
js_true_str
)
;
case
JSOP_FALSE
:
return
write
(
js_false_str
)
;
case
JSOP_ZERO
:
case
JSOP_ONE
:
case
JSOP_INT8
:
case
JSOP_UINT16
:
case
JSOP_UINT24
:
case
JSOP_INT32
:
return
sprinter
.
printf
(
"
%
d
"
GetBytecodeInteger
(
pc
)
)
>
=
0
;
case
JSOP_STRING
:
return
quote
(
loadAtom
(
pc
)
'
"
'
)
;
case
JSOP_SYMBOL
:
{
unsigned
i
=
uint8_t
(
pc
[
1
]
)
;
MOZ_ASSERT
(
i
<
JS
:
:
WellKnownSymbolLimit
)
;
if
(
i
<
JS
:
:
WellKnownSymbolLimit
)
return
write
(
cx
-
>
names
(
)
.
wellKnownSymbolDescriptions
(
)
[
i
]
)
;
break
;
}
case
JSOP_UNDEFINED
:
return
write
(
js_undefined_str
)
;
case
JSOP_GLOBALTHIS
:
return
write
(
js_this_str
)
;
case
JSOP_NEWTARGET
:
return
write
(
"
new
.
target
"
)
;
case
JSOP_CALL
:
case
JSOP_CALLITER
:
case
JSOP_FUNCALL
:
return
decompilePCForStackOperand
(
pc
-
int32_t
(
GET_ARGC
(
pc
)
+
2
)
)
&
&
write
(
"
(
.
.
.
)
"
)
;
case
JSOP_SPREADCALL
:
return
decompilePCForStackOperand
(
pc
-
3
)
&
&
write
(
"
(
.
.
.
)
"
)
;
case
JSOP_NEWARRAY
:
return
write
(
"
[
]
"
)
;
case
JSOP_REGEXP
:
case
JSOP_OBJECT
:
case
JSOP_NEWARRAY_COPYONWRITE
:
{
JSObject
*
obj
=
script
-
>
getObject
(
GET_UINT32_INDEX
(
pc
)
)
;
RootedValue
objv
(
cx
ObjectValue
(
*
obj
)
)
;
JSString
*
str
=
ValueToSource
(
cx
objv
)
;
if
(
!
str
)
return
false
;
return
write
(
str
)
;
}
case
JSOP_CHECKISOBJ
:
return
decompilePCForStackOperand
(
pc
-
1
)
;
case
JSOP_VOID
:
return
write
(
"
void
"
)
&
&
decompilePCForStackOperand
(
pc
-
1
)
;
default
:
break
;
}
return
write
(
"
(
intermediate
value
)
"
)
;
}
bool
ExpressionDecompiler
:
:
init
(
)
{
assertSameCompartment
(
cx
script
)
;
if
(
!
sprinter
.
init
(
)
)
return
false
;
if
(
!
parser
.
parse
(
)
)
return
false
;
return
true
;
}
bool
ExpressionDecompiler
:
:
write
(
const
char
*
s
)
{
return
sprinter
.
put
(
s
)
>
=
0
;
}
bool
ExpressionDecompiler
:
:
write
(
JSString
*
str
)
{
if
(
str
=
=
cx
-
>
names
(
)
.
dotThis
)
return
write
(
"
this
"
)
;
return
sprinter
.
putString
(
str
)
>
=
0
;
}
bool
ExpressionDecompiler
:
:
quote
(
JSString
*
s
uint32_t
quote
)
{
return
QuoteString
(
&
sprinter
s
quote
)
!
=
nullptr
;
}
JSAtom
*
ExpressionDecompiler
:
:
loadAtom
(
jsbytecode
*
pc
)
{
return
script
-
>
getAtom
(
GET_UINT32_INDEX
(
pc
)
)
;
}
JSAtom
*
ExpressionDecompiler
:
:
getArg
(
unsigned
slot
)
{
MOZ_ASSERT
(
script
-
>
functionNonDelazifying
(
)
)
;
MOZ_ASSERT
(
slot
<
script
-
>
numArgs
(
)
)
;
for
(
PositionalFormalParameterIter
fi
(
script
)
;
fi
;
fi
+
+
)
{
if
(
fi
.
argumentSlot
(
)
=
=
slot
)
{
if
(
!
fi
.
isDestructured
(
)
)
return
fi
.
name
(
)
;
static
const
char
destructuredParam
[
]
=
"
(
destructured
parameter
)
"
;
return
Atomize
(
cx
destructuredParam
strlen
(
destructuredParam
)
)
;
}
}
MOZ_CRASH
(
"
No
binding
"
)
;
}
bool
ExpressionDecompiler
:
:
getOutput
(
char
*
*
res
)
{
ptrdiff_t
len
=
sprinter
.
stringEnd
(
)
-
sprinter
.
stringAt
(
0
)
;
*
res
=
cx
-
>
pod_malloc
<
char
>
(
len
+
1
)
;
if
(
!
*
res
)
return
false
;
js_memcpy
(
*
res
sprinter
.
stringAt
(
0
)
len
)
;
(
*
res
)
[
len
]
=
0
;
return
true
;
}
}
static
bool
FindStartPC
(
JSContext
*
cx
const
FrameIter
&
iter
int
spindex
int
skipStackHits
Value
v
jsbytecode
*
*
valuepc
)
{
jsbytecode
*
current
=
*
valuepc
;
if
(
spindex
=
=
JSDVG_IGNORE_STACK
)
return
true
;
if
(
iter
.
isIon
(
)
)
return
true
;
*
valuepc
=
nullptr
;
BytecodeParser
parser
(
cx
iter
.
script
(
)
)
;
if
(
!
parser
.
parse
(
)
)
return
false
;
if
(
spindex
<
0
&
&
spindex
+
int
(
parser
.
stackDepthAtPC
(
current
)
)
<
0
)
spindex
=
JSDVG_SEARCH_STACK
;
if
(
spindex
=
=
JSDVG_SEARCH_STACK
)
{
size_t
index
=
iter
.
numFrameSlots
(
)
;
if
(
index
<
size_t
(
parser
.
stackDepthAtPC
(
current
)
)
)
return
true
;
int
stackHits
=
0
;
Value
s
;
do
{
if
(
!
index
)
return
true
;
s
=
iter
.
frameSlotValue
(
-
-
index
)
;
}
while
(
s
!
=
v
|
|
stackHits
+
+
!
=
skipStackHits
)
;
jsbytecode
*
pc
=
nullptr
;
if
(
index
<
size_t
(
parser
.
stackDepthAtPC
(
current
)
)
)
pc
=
parser
.
pcForStackOperand
(
current
index
)
;
*
valuepc
=
pc
?
pc
:
current
;
}
else
{
jsbytecode
*
pc
=
parser
.
pcForStackOperand
(
current
spindex
)
;
*
valuepc
=
pc
?
pc
:
current
;
}
return
true
;
}
static
bool
DecompileExpressionFromStack
(
JSContext
*
cx
int
spindex
int
skipStackHits
HandleValue
v
char
*
*
res
)
{
MOZ_ASSERT
(
spindex
<
0
|
|
spindex
=
=
JSDVG_IGNORE_STACK
|
|
spindex
=
=
JSDVG_SEARCH_STACK
)
;
*
res
=
nullptr
;
#
ifdef
JS_MORE_DETERMINISTIC
return
true
;
#
endif
FrameIter
frameIter
(
cx
)
;
if
(
frameIter
.
done
(
)
|
|
!
frameIter
.
hasScript
(
)
|
|
frameIter
.
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
return
true
;
RootedScript
script
(
cx
frameIter
.
script
(
)
)
;
jsbytecode
*
valuepc
=
frameIter
.
pc
(
)
;
MOZ_ASSERT
(
script
-
>
containsPC
(
valuepc
)
)
;
if
(
valuepc
<
script
-
>
main
(
)
)
return
true
;
if
(
!
FindStartPC
(
cx
frameIter
spindex
skipStackHits
v
&
valuepc
)
)
return
false
;
if
(
!
valuepc
)
return
true
;
ExpressionDecompiler
ed
(
cx
script
)
;
if
(
!
ed
.
init
(
)
)
return
false
;
if
(
!
ed
.
decompilePC
(
valuepc
)
)
return
false
;
return
ed
.
getOutput
(
res
)
;
}
UniqueChars
js
:
:
DecompileValueGenerator
(
JSContext
*
cx
int
spindex
HandleValue
v
HandleString
fallbackArg
int
skipStackHits
)
{
RootedString
fallback
(
cx
fallbackArg
)
;
{
char
*
result
;
if
(
!
DecompileExpressionFromStack
(
cx
spindex
skipStackHits
v
&
result
)
)
return
nullptr
;
if
(
result
)
{
if
(
strcmp
(
result
"
(
intermediate
value
)
"
)
)
return
UniqueChars
(
result
)
;
js_free
(
result
)
;
}
}
if
(
!
fallback
)
{
if
(
v
.
isUndefined
(
)
)
return
UniqueChars
(
JS_strdup
(
cx
js_undefined_str
)
)
;
fallback
=
ValueToSource
(
cx
v
)
;
if
(
!
fallback
)
return
UniqueChars
(
nullptr
)
;
}
return
UniqueChars
(
JS_EncodeString
(
cx
fallback
)
)
;
}
static
bool
DecompileArgumentFromStack
(
JSContext
*
cx
int
formalIndex
char
*
*
res
)
{
MOZ_ASSERT
(
formalIndex
>
=
0
)
;
*
res
=
nullptr
;
#
ifdef
JS_MORE_DETERMINISTIC
return
true
;
#
endif
FrameIter
frameIter
(
cx
)
;
MOZ_ASSERT
(
!
frameIter
.
done
(
)
)
;
MOZ_ASSERT
(
frameIter
.
script
(
)
-
>
selfHosted
(
)
)
;
+
+
frameIter
;
if
(
frameIter
.
done
(
)
|
|
!
frameIter
.
hasScript
(
)
|
|
frameIter
.
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
return
true
;
RootedScript
script
(
cx
frameIter
.
script
(
)
)
;
jsbytecode
*
current
=
frameIter
.
pc
(
)
;
MOZ_ASSERT
(
script
-
>
containsPC
(
current
)
)
;
if
(
current
<
script
-
>
main
(
)
)
return
true
;
if
(
JSOp
(
*
current
)
!
=
JSOP_CALL
|
|
static_cast
<
unsigned
>
(
formalIndex
)
>
=
GET_ARGC
(
current
)
)
return
true
;
BytecodeParser
parser
(
cx
script
)
;
if
(
!
parser
.
parse
(
)
)
return
false
;
int
formalStackIndex
=
parser
.
stackDepthAtPC
(
current
)
-
GET_ARGC
(
current
)
+
formalIndex
;
MOZ_ASSERT
(
formalStackIndex
>
=
0
)
;
if
(
uint32_t
(
formalStackIndex
)
>
=
parser
.
stackDepthAtPC
(
current
)
)
return
true
;
ExpressionDecompiler
ed
(
cx
script
)
;
if
(
!
ed
.
init
(
)
)
return
false
;
if
(
!
ed
.
decompilePCForStackOperand
(
current
formalStackIndex
)
)
return
false
;
return
ed
.
getOutput
(
res
)
;
}
char
*
js
:
:
DecompileArgument
(
JSContext
*
cx
int
formalIndex
HandleValue
v
)
{
{
char
*
result
;
if
(
!
DecompileArgumentFromStack
(
cx
formalIndex
&
result
)
)
return
nullptr
;
if
(
result
)
{
if
(
strcmp
(
result
"
(
intermediate
value
)
"
)
)
return
result
;
js_free
(
result
)
;
}
}
if
(
v
.
isUndefined
(
)
)
return
JS_strdup
(
cx
js_undefined_str
)
;
RootedString
fallback
(
cx
ValueToSource
(
cx
v
)
)
;
if
(
!
fallback
)
return
nullptr
;
return
JS_EncodeString
(
cx
fallback
)
;
}
bool
js
:
:
CallResultEscapes
(
jsbytecode
*
pc
)
{
if
(
*
pc
=
=
JSOP_CALL
)
pc
+
=
JSOP_CALL_LENGTH
;
else
if
(
*
pc
=
=
JSOP_SPREADCALL
)
pc
+
=
JSOP_SPREADCALL_LENGTH
;
else
return
true
;
if
(
*
pc
=
=
JSOP_POP
)
return
false
;
if
(
*
pc
=
=
JSOP_NOT
)
pc
+
=
JSOP_NOT_LENGTH
;
return
*
pc
!
=
JSOP_IFEQ
;
}
extern
bool
js
:
:
IsValidBytecodeOffset
(
JSContext
*
cx
JSScript
*
script
size_t
offset
)
{
for
(
BytecodeRange
r
(
cx
script
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
size_t
here
=
r
.
frontOffset
(
)
;
if
(
here
>
=
offset
)
return
here
=
=
offset
;
}
return
false
;
}
static
void
ReleaseScriptCounts
(
FreeOp
*
fop
)
{
JSRuntime
*
rt
=
fop
-
>
runtime
(
)
;
MOZ_ASSERT
(
rt
-
>
scriptAndCountsVector
)
;
fop
-
>
delete_
(
rt
-
>
scriptAndCountsVector
)
;
rt
-
>
scriptAndCountsVector
=
nullptr
;
}
JS_FRIEND_API
(
void
)
js
:
:
StartPCCountProfiling
(
JSContext
*
cx
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
if
(
rt
-
>
profilingScripts
)
return
;
if
(
rt
-
>
scriptAndCountsVector
)
ReleaseScriptCounts
(
rt
-
>
defaultFreeOp
(
)
)
;
ReleaseAllJITCode
(
rt
-
>
defaultFreeOp
(
)
)
;
rt
-
>
profilingScripts
=
true
;
}
JS_FRIEND_API
(
void
)
js
:
:
StopPCCountProfiling
(
JSContext
*
cx
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
if
(
!
rt
-
>
profilingScripts
)
return
;
MOZ_ASSERT
(
!
rt
-
>
scriptAndCountsVector
)
;
ReleaseAllJITCode
(
rt
-
>
defaultFreeOp
(
)
)
;
auto
*
vec
=
cx
-
>
new_
<
PersistentRooted
<
ScriptAndCountsVector
>
>
(
cx
ScriptAndCountsVector
(
SystemAllocPolicy
(
)
)
)
;
if
(
!
vec
)
return
;
for
(
ZonesIter
zone
(
rt
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
auto
script
=
zone
-
>
cellIter
<
JSScript
>
(
)
;
!
script
.
done
(
)
;
script
.
next
(
)
)
{
if
(
script
-
>
hasScriptCounts
(
)
&
&
script
-
>
types
(
)
)
{
if
(
!
vec
-
>
append
(
script
)
)
return
;
}
}
}
rt
-
>
profilingScripts
=
false
;
rt
-
>
scriptAndCountsVector
=
vec
;
}
JS_FRIEND_API
(
void
)
js
:
:
PurgePCCounts
(
JSContext
*
cx
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
if
(
!
rt
-
>
scriptAndCountsVector
)
return
;
MOZ_ASSERT
(
!
rt
-
>
profilingScripts
)
;
ReleaseScriptCounts
(
rt
-
>
defaultFreeOp
(
)
)
;
}
JS_FRIEND_API
(
size_t
)
js
:
:
GetPCCountScriptCount
(
JSContext
*
cx
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
if
(
!
rt
-
>
scriptAndCountsVector
)
return
0
;
return
rt
-
>
scriptAndCountsVector
-
>
length
(
)
;
}
enum
MaybeComma
{
NO_COMMA
COMMA
}
;
static
MOZ_MUST_USE
bool
AppendJSONProperty
(
StringBuffer
&
buf
const
char
*
name
MaybeComma
comma
=
COMMA
)
{
if
(
comma
&
&
!
buf
.
append
(
'
'
)
)
return
false
;
return
buf
.
append
(
'
\
"
'
)
&
&
buf
.
append
(
name
strlen
(
name
)
)
&
&
buf
.
append
(
"
\
"
:
"
2
)
;
}
JS_FRIEND_API
(
JSString
*
)
js
:
:
GetPCCountScriptSummary
(
JSContext
*
cx
size_t
index
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
if
(
!
rt
-
>
scriptAndCountsVector
|
|
index
>
=
rt
-
>
scriptAndCountsVector
-
>
length
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BUFFER_TOO_SMALL
)
;
return
nullptr
;
}
const
ScriptAndCounts
&
sac
=
(
*
rt
-
>
scriptAndCountsVector
)
[
index
]
;
RootedScript
script
(
cx
sac
.
script
)
;
StringBuffer
buf
(
cx
)
;
if
(
!
buf
.
append
(
'
{
'
)
)
return
nullptr
;
if
(
!
AppendJSONProperty
(
buf
"
file
"
NO_COMMA
)
)
return
nullptr
;
JSString
*
str
=
JS_NewStringCopyZ
(
cx
script
-
>
filename
(
)
)
;
if
(
!
str
|
|
!
(
str
=
StringToSource
(
cx
str
)
)
)
return
nullptr
;
if
(
!
buf
.
append
(
str
)
)
return
nullptr
;
if
(
!
AppendJSONProperty
(
buf
"
line
"
)
)
return
nullptr
;
if
(
!
NumberValueToStringBuffer
(
cx
Int32Value
(
script
-
>
lineno
(
)
)
buf
)
)
{
return
nullptr
;
}
if
(
script
-
>
functionNonDelazifying
(
)
)
{
JSAtom
*
atom
=
script
-
>
functionNonDelazifying
(
)
-
>
displayAtom
(
)
;
if
(
atom
)
{
if
(
!
AppendJSONProperty
(
buf
"
name
"
)
)
return
nullptr
;
if
(
!
(
str
=
StringToSource
(
cx
atom
)
)
)
return
nullptr
;
if
(
!
buf
.
append
(
str
)
)
return
nullptr
;
}
}
uint64_t
total
=
0
;
jsbytecode
*
codeEnd
=
script
-
>
codeEnd
(
)
;
for
(
jsbytecode
*
pc
=
script
-
>
code
(
)
;
pc
<
codeEnd
;
pc
=
GetNextPc
(
pc
)
)
{
const
PCCounts
*
counts
=
sac
.
maybeGetPCCounts
(
pc
)
;
if
(
!
counts
)
continue
;
total
+
=
counts
-
>
numExec
(
)
;
}
if
(
!
AppendJSONProperty
(
buf
"
totals
"
)
)
return
nullptr
;
if
(
!
buf
.
append
(
'
{
'
)
)
return
nullptr
;
if
(
!
AppendJSONProperty
(
buf
PCCounts
:
:
numExecName
NO_COMMA
)
)
return
nullptr
;
if
(
!
NumberValueToStringBuffer
(
cx
DoubleValue
(
total
)
buf
)
)
return
nullptr
;
uint64_t
ionActivity
=
0
;
jit
:
:
IonScriptCounts
*
ionCounts
=
sac
.
getIonCounts
(
)
;
while
(
ionCounts
)
{
for
(
size_t
i
=
0
;
i
<
ionCounts
-
>
numBlocks
(
)
;
i
+
+
)
ionActivity
+
=
ionCounts
-
>
block
(
i
)
.
hitCount
(
)
;
ionCounts
=
ionCounts
-
>
previous
(
)
;
}
if
(
ionActivity
)
{
if
(
!
AppendJSONProperty
(
buf
"
ion
"
COMMA
)
)
return
nullptr
;
if
(
!
NumberValueToStringBuffer
(
cx
DoubleValue
(
ionActivity
)
buf
)
)
return
nullptr
;
}
if
(
!
buf
.
append
(
'
}
'
)
)
return
nullptr
;
if
(
!
buf
.
append
(
'
}
'
)
)
return
nullptr
;
MOZ_ASSERT
(
!
cx
-
>
isExceptionPending
(
)
)
;
return
buf
.
finishString
(
)
;
}
static
bool
GetPCCountJSON
(
JSContext
*
cx
const
ScriptAndCounts
&
sac
StringBuffer
&
buf
)
{
RootedScript
script
(
cx
sac
.
script
)
;
if
(
!
buf
.
append
(
'
{
'
)
)
return
false
;
if
(
!
AppendJSONProperty
(
buf
"
text
"
NO_COMMA
)
)
return
false
;
JSString
*
str
=
JS_DecompileScript
(
cx
script
nullptr
0
)
;
if
(
!
str
|
|
!
(
str
=
StringToSource
(
cx
str
)
)
)
return
false
;
if
(
!
buf
.
append
(
str
)
)
return
false
;
if
(
!
AppendJSONProperty
(
buf
"
line
"
)
)
return
false
;
if
(
!
NumberValueToStringBuffer
(
cx
Int32Value
(
script
-
>
lineno
(
)
)
buf
)
)
return
false
;
if
(
!
AppendJSONProperty
(
buf
"
opcodes
"
)
)
return
false
;
if
(
!
buf
.
append
(
'
[
'
)
)
return
false
;
bool
comma
=
false
;
SrcNoteLineScanner
scanner
(
script
-
>
notes
(
)
script
-
>
lineno
(
)
)
;
uint64_t
hits
=
0
;
jsbytecode
*
end
=
script
-
>
codeEnd
(
)
;
for
(
jsbytecode
*
pc
=
script
-
>
code
(
)
;
pc
<
end
;
pc
=
GetNextPc
(
pc
)
)
{
size_t
offset
=
script
-
>
pcToOffset
(
pc
)
;
JSOp
op
=
JSOp
(
*
pc
)
;
const
PCCounts
*
counts
=
sac
.
maybeGetPCCounts
(
pc
)
;
if
(
counts
)
hits
=
counts
-
>
numExec
(
)
;
if
(
comma
&
&
!
buf
.
append
(
'
'
)
)
return
false
;
comma
=
true
;
if
(
!
buf
.
append
(
'
{
'
)
)
return
false
;
if
(
!
AppendJSONProperty
(
buf
"
id
"
NO_COMMA
)
)
return
false
;
if
(
!
NumberValueToStringBuffer
(
cx
Int32Value
(
offset
)
buf
)
)
return
false
;
scanner
.
advanceTo
(
offset
)
;
if
(
!
AppendJSONProperty
(
buf
"
line
"
)
)
return
false
;
if
(
!
NumberValueToStringBuffer
(
cx
Int32Value
(
scanner
.
getLine
(
)
)
buf
)
)
return
false
;
{
const
char
*
name
=
CodeName
[
op
]
;
if
(
!
AppendJSONProperty
(
buf
"
name
"
)
)
return
false
;
if
(
!
buf
.
append
(
'
\
"
'
)
)
return
false
;
if
(
!
buf
.
append
(
name
strlen
(
name
)
)
)
return
false
;
if
(
!
buf
.
append
(
'
\
"
'
)
)
return
false
;
}
{
ExpressionDecompiler
ed
(
cx
script
)
;
if
(
!
ed
.
init
(
)
)
return
false
;
if
(
!
ed
.
decompilePC
(
pc
)
)
return
false
;
char
*
text
;
if
(
!
ed
.
getOutput
(
&
text
)
)
return
false
;
JSString
*
str
=
JS_NewStringCopyZ
(
cx
text
)
;
js_free
(
text
)
;
if
(
!
AppendJSONProperty
(
buf
"
text
"
)
)
return
false
;
if
(
!
str
|
|
!
(
str
=
StringToSource
(
cx
str
)
)
)
return
false
;
if
(
!
buf
.
append
(
str
)
)
return
false
;
}
if
(
!
AppendJSONProperty
(
buf
"
counts
"
)
)
return
false
;
if
(
!
buf
.
append
(
'
{
'
)
)
return
false
;
if
(
hits
>
0
)
{
if
(
!
AppendJSONProperty
(
buf
PCCounts
:
:
numExecName
NO_COMMA
)
)
return
false
;
if
(
!
NumberValueToStringBuffer
(
cx
DoubleValue
(
hits
)
buf
)
)
return
false
;
}
if
(
!
buf
.
append
(
'
}
'
)
)
return
false
;
if
(
!
buf
.
append
(
'
}
'
)
)
return
false
;
counts
=
sac
.
maybeGetThrowCounts
(
pc
)
;
if
(
counts
)
hits
-
=
counts
-
>
numExec
(
)
;
}
if
(
!
buf
.
append
(
'
]
'
)
)
return
false
;
jit
:
:
IonScriptCounts
*
ionCounts
=
sac
.
getIonCounts
(
)
;
if
(
ionCounts
)
{
if
(
!
AppendJSONProperty
(
buf
"
ion
"
)
)
return
false
;
if
(
!
buf
.
append
(
'
[
'
)
)
return
false
;
bool
comma
=
false
;
while
(
ionCounts
)
{
if
(
comma
&
&
!
buf
.
append
(
'
'
)
)
return
false
;
comma
=
true
;
if
(
!
buf
.
append
(
'
[
'
)
)
return
false
;
for
(
size_t
i
=
0
;
i
<
ionCounts
-
>
numBlocks
(
)
;
i
+
+
)
{
if
(
i
&
&
!
buf
.
append
(
'
'
)
)
return
false
;
const
jit
:
:
IonBlockCounts
&
block
=
ionCounts
-
>
block
(
i
)
;
if
(
!
buf
.
append
(
'
{
'
)
)
return
false
;
if
(
!
AppendJSONProperty
(
buf
"
id
"
NO_COMMA
)
)
return
false
;
if
(
!
NumberValueToStringBuffer
(
cx
Int32Value
(
block
.
id
(
)
)
buf
)
)
return
false
;
if
(
!
AppendJSONProperty
(
buf
"
offset
"
)
)
return
false
;
if
(
!
NumberValueToStringBuffer
(
cx
Int32Value
(
block
.
offset
(
)
)
buf
)
)
return
false
;
if
(
!
AppendJSONProperty
(
buf
"
successors
"
)
)
return
false
;
if
(
!
buf
.
append
(
'
[
'
)
)
return
false
;
for
(
size_t
j
=
0
;
j
<
block
.
numSuccessors
(
)
;
j
+
+
)
{
if
(
j
&
&
!
buf
.
append
(
'
'
)
)
return
false
;
if
(
!
NumberValueToStringBuffer
(
cx
Int32Value
(
block
.
successor
(
j
)
)
buf
)
)
return
false
;
}
if
(
!
buf
.
append
(
'
]
'
)
)
return
false
;
if
(
!
AppendJSONProperty
(
buf
"
hits
"
)
)
return
false
;
if
(
!
NumberValueToStringBuffer
(
cx
DoubleValue
(
block
.
hitCount
(
)
)
buf
)
)
return
false
;
if
(
!
AppendJSONProperty
(
buf
"
code
"
)
)
return
false
;
JSString
*
str
=
JS_NewStringCopyZ
(
cx
block
.
code
(
)
)
;
if
(
!
str
|
|
!
(
str
=
StringToSource
(
cx
str
)
)
)
return
false
;
if
(
!
buf
.
append
(
str
)
)
return
false
;
if
(
!
buf
.
append
(
'
}
'
)
)
return
false
;
}
if
(
!
buf
.
append
(
'
]
'
)
)
return
false
;
ionCounts
=
ionCounts
-
>
previous
(
)
;
}
if
(
!
buf
.
append
(
'
]
'
)
)
return
false
;
}
if
(
!
buf
.
append
(
'
}
'
)
)
return
false
;
MOZ_ASSERT
(
!
cx
-
>
isExceptionPending
(
)
)
;
return
true
;
}
JS_FRIEND_API
(
JSString
*
)
js
:
:
GetPCCountScriptContents
(
JSContext
*
cx
size_t
index
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
if
(
!
rt
-
>
scriptAndCountsVector
|
|
index
>
=
rt
-
>
scriptAndCountsVector
-
>
length
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BUFFER_TOO_SMALL
)
;
return
nullptr
;
}
const
ScriptAndCounts
&
sac
=
(
*
rt
-
>
scriptAndCountsVector
)
[
index
]
;
JSScript
*
script
=
sac
.
script
;
StringBuffer
buf
(
cx
)
;
{
AutoCompartment
ac
(
cx
&
script
-
>
global
(
)
)
;
if
(
!
GetPCCountJSON
(
cx
sac
buf
)
)
return
nullptr
;
}
return
buf
.
finishString
(
)
;
}
static
bool
GenerateLcovInfo
(
JSContext
*
cx
JSCompartment
*
comp
GenericPrinter
&
out
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
{
js
:
:
gc
:
:
AutoPrepareForTracing
apft
(
cx
SkipAtoms
)
;
}
Rooted
<
ScriptVector
>
topScripts
(
cx
ScriptVector
(
cx
)
)
;
for
(
ZonesIter
zone
(
rt
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
auto
script
=
zone
-
>
cellIter
<
JSScript
>
(
)
;
!
script
.
done
(
)
;
script
.
next
(
)
)
{
if
(
script
-
>
compartment
(
)
!
=
comp
|
|
!
script
-
>
isTopLevel
(
)
|
|
!
script
-
>
filename
(
)
)
{
continue
;
}
if
(
!
topScripts
.
append
(
script
)
)
return
false
;
}
}
if
(
topScripts
.
length
(
)
=
=
0
)
return
true
;
coverage
:
:
LCovCompartment
compCover
;
for
(
JSScript
*
topLevel
:
topScripts
)
{
RootedScript
topScript
(
cx
topLevel
)
;
compCover
.
collectSourceFile
(
comp
&
topScript
-
>
scriptSourceUnwrap
(
)
)
;
Rooted
<
ScriptVector
>
queue
(
cx
ScriptVector
(
cx
)
)
;
if
(
!
queue
.
append
(
topLevel
)
)
return
false
;
RootedScript
script
(
cx
)
;
do
{
script
=
queue
.
popCopy
(
)
;
compCover
.
collectCodeCoverageInfo
(
comp
script
-
>
sourceObject
(
)
script
)
;
if
(
!
script
-
>
hasObjects
(
)
)
continue
;
size_t
idx
=
script
-
>
objects
(
)
-
>
length
;
while
(
idx
-
-
)
{
JSObject
*
obj
=
script
-
>
getObject
(
idx
)
;
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
)
continue
;
JSFunction
&
fun
=
obj
-
>
as
<
JSFunction
>
(
)
;
if
(
!
fun
.
isInterpreted
(
)
)
continue
;
JSScript
*
childScript
=
fun
.
getOrCreateScript
(
cx
)
;
if
(
!
childScript
|
|
!
queue
.
append
(
childScript
)
)
return
false
;
}
}
while
(
!
queue
.
empty
(
)
)
;
}
bool
isEmpty
=
true
;
compCover
.
exportInto
(
out
&
isEmpty
)
;
if
(
out
.
hadOutOfMemory
(
)
)
return
false
;
return
true
;
}
JS_FRIEND_API
(
char
*
)
js
:
:
GetCodeCoverageSummary
(
JSContext
*
cx
size_t
*
length
)
{
Sprinter
out
(
cx
)
;
if
(
!
out
.
init
(
)
)
return
nullptr
;
if
(
!
GenerateLcovInfo
(
cx
cx
-
>
compartment
(
)
out
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
if
(
out
.
hadOutOfMemory
(
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
ptrdiff_t
len
=
out
.
stringEnd
(
)
-
out
.
string
(
)
;
char
*
res
=
cx
-
>
pod_malloc
<
char
>
(
len
+
1
)
;
if
(
!
res
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
js_memcpy
(
res
out
.
string
(
)
len
)
;
res
[
len
]
=
0
;
if
(
length
)
*
length
=
len
;
return
res
;
}
