#
ifndef
jsgc_h
#
define
jsgc_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
threading
/
ConditionVariable
.
h
"
#
include
"
threading
/
Thread
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
namespace
gcstats
{
struct
Statistics
;
}
class
Nursery
;
namespace
gc
{
#
define
GCSTATES
(
D
)
\
D
(
NotActive
)
\
D
(
MarkRoots
)
\
D
(
Mark
)
\
D
(
Sweep
)
\
D
(
Finalize
)
\
D
(
Compact
)
\
D
(
Decommit
)
enum
class
State
{
#
define
MAKE_STATE
(
name
)
name
GCSTATES
(
MAKE_STATE
)
#
undef
MAKE_STATE
}
;
#
define
GC_ABORT_REASONS
(
D
)
\
D
(
None
)
\
D
(
NonIncrementalRequested
)
\
D
(
AbortRequested
)
\
D
(
Unused1
)
\
D
(
IncrementalDisabled
)
\
D
(
ModeChange
)
\
D
(
MallocBytesTrigger
)
\
D
(
GCBytesTrigger
)
\
D
(
ZoneChange
)
\
D
(
CompartmentRevived
)
enum
class
AbortReason
{
#
define
MAKE_REASON
(
name
)
name
GC_ABORT_REASONS
(
MAKE_REASON
)
#
undef
MAKE_REASON
}
;
template
<
typename
T
>
struct
MapTypeToFinalizeKind
{
}
;
#
define
EXPAND_MAPTYPETOFINALIZEKIND
(
allocKind
traceKind
type
sizedType
)
\
template
<
>
struct
MapTypeToFinalizeKind
<
type
>
{
\
static
const
AllocKind
kind
=
AllocKind
:
:
allocKind
;
\
}
;
FOR_EACH_NONOBJECT_ALLOCKIND
(
EXPAND_MAPTYPETOFINALIZEKIND
)
#
undef
EXPAND_MAPTYPETOFINALIZEKIND
template
<
typename
T
>
struct
ParticipatesInCC
{
}
;
#
define
EXPAND_PARTICIPATES_IN_CC
(
_
type
addToCCKind
)
\
template
<
>
struct
ParticipatesInCC
<
type
>
{
static
const
bool
value
=
addToCCKind
;
}
;
JS_FOR_EACH_TRACEKIND
(
EXPAND_PARTICIPATES_IN_CC
)
#
undef
EXPAND_PARTICIPATES_IN_CC
static
inline
bool
IsNurseryAllocable
(
AllocKind
kind
)
{
MOZ_ASSERT
(
IsValidAllocKind
(
kind
)
)
;
static
const
bool
map
[
]
=
{
true
true
false
true
false
true
false
true
false
true
false
true
false
true
false
false
false
false
false
false
false
false
false
false
false
false
false
false
false
}
;
JS_STATIC_ASSERT
(
JS_ARRAY_LENGTH
(
map
)
=
=
size_t
(
AllocKind
:
:
LIMIT
)
)
;
return
map
[
size_t
(
kind
)
]
;
}
static
inline
bool
IsBackgroundFinalized
(
AllocKind
kind
)
{
MOZ_ASSERT
(
IsValidAllocKind
(
kind
)
)
;
static
const
bool
map
[
]
=
{
true
true
false
true
false
true
false
true
false
true
false
true
false
true
false
true
true
true
true
true
true
true
true
true
true
true
false
true
true
}
;
JS_STATIC_ASSERT
(
JS_ARRAY_LENGTH
(
map
)
=
=
size_t
(
AllocKind
:
:
LIMIT
)
)
;
return
map
[
size_t
(
kind
)
]
;
}
static
inline
bool
CanBeFinalizedInBackground
(
AllocKind
kind
const
Class
*
clasp
)
{
MOZ_ASSERT
(
IsObjectAllocKind
(
kind
)
)
;
return
(
!
IsBackgroundFinalized
(
kind
)
&
&
(
!
clasp
-
>
hasFinalize
(
)
|
|
(
clasp
-
>
flags
&
JSCLASS_BACKGROUND_FINALIZE
)
)
)
;
}
const
size_t
SLOTS_TO_THING_KIND_LIMIT
=
17
;
extern
const
AllocKind
slotsToThingKind
[
]
;
static
inline
AllocKind
GetGCObjectKind
(
size_t
numSlots
)
{
if
(
numSlots
>
=
SLOTS_TO_THING_KIND_LIMIT
)
return
AllocKind
:
:
OBJECT16
;
return
slotsToThingKind
[
numSlots
]
;
}
static
inline
AllocKind
GetGCArrayKind
(
size_t
numElements
)
{
JS_STATIC_ASSERT
(
ObjectElements
:
:
VALUES_PER_HEADER
=
=
2
)
;
if
(
numElements
>
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
|
|
numElements
+
ObjectElements
:
:
VALUES_PER_HEADER
>
=
SLOTS_TO_THING_KIND_LIMIT
)
{
return
AllocKind
:
:
OBJECT2
;
}
return
slotsToThingKind
[
numElements
+
ObjectElements
:
:
VALUES_PER_HEADER
]
;
}
static
inline
AllocKind
GetGCObjectFixedSlotsKind
(
size_t
numFixedSlots
)
{
MOZ_ASSERT
(
numFixedSlots
<
SLOTS_TO_THING_KIND_LIMIT
)
;
return
slotsToThingKind
[
numFixedSlots
]
;
}
static
inline
AllocKind
GetGCObjectKindForBytes
(
size_t
nbytes
)
{
MOZ_ASSERT
(
nbytes
<
=
JSObject
:
:
MAX_BYTE_SIZE
)
;
if
(
nbytes
<
=
sizeof
(
NativeObject
)
)
return
AllocKind
:
:
OBJECT0
;
nbytes
-
=
sizeof
(
NativeObject
)
;
size_t
dataSlots
=
AlignBytes
(
nbytes
sizeof
(
Value
)
)
/
sizeof
(
Value
)
;
MOZ_ASSERT
(
nbytes
<
=
dataSlots
*
sizeof
(
Value
)
)
;
return
GetGCObjectKind
(
dataSlots
)
;
}
static
inline
AllocKind
GetBackgroundAllocKind
(
AllocKind
kind
)
{
MOZ_ASSERT
(
!
IsBackgroundFinalized
(
kind
)
)
;
MOZ_ASSERT
(
IsObjectAllocKind
(
kind
)
)
;
return
AllocKind
(
size_t
(
kind
)
+
1
)
;
}
static
inline
size_t
GetGCKindSlots
(
AllocKind
thingKind
)
{
switch
(
thingKind
)
{
case
AllocKind
:
:
FUNCTION
:
case
AllocKind
:
:
OBJECT0
:
case
AllocKind
:
:
OBJECT0_BACKGROUND
:
return
0
;
case
AllocKind
:
:
FUNCTION_EXTENDED
:
case
AllocKind
:
:
OBJECT2
:
case
AllocKind
:
:
OBJECT2_BACKGROUND
:
return
2
;
case
AllocKind
:
:
OBJECT4
:
case
AllocKind
:
:
OBJECT4_BACKGROUND
:
return
4
;
case
AllocKind
:
:
OBJECT8
:
case
AllocKind
:
:
OBJECT8_BACKGROUND
:
return
8
;
case
AllocKind
:
:
OBJECT12
:
case
AllocKind
:
:
OBJECT12_BACKGROUND
:
return
12
;
case
AllocKind
:
:
OBJECT16
:
case
AllocKind
:
:
OBJECT16_BACKGROUND
:
return
16
;
default
:
MOZ_CRASH
(
"
Bad
object
alloc
kind
"
)
;
}
}
static
inline
size_t
GetGCKindSlots
(
AllocKind
thingKind
const
Class
*
clasp
)
{
size_t
nslots
=
GetGCKindSlots
(
thingKind
)
;
if
(
clasp
-
>
flags
&
JSCLASS_HAS_PRIVATE
)
{
MOZ_ASSERT
(
nslots
>
0
)
;
nslots
-
-
;
}
if
(
clasp
=
=
FunctionClassPtr
)
nslots
=
0
;
return
nslots
;
}
static
inline
size_t
GetGCKindBytes
(
AllocKind
thingKind
)
{
return
sizeof
(
JSObject_Slots0
)
+
GetGCKindSlots
(
thingKind
)
*
sizeof
(
Value
)
;
}
const
size_t
MAX_EMPTY_CHUNK_AGE
=
4
;
extern
bool
InitializeStaticData
(
)
;
}
class
InterpreterFrame
;
extern
void
TraceRuntime
(
JSTracer
*
trc
)
;
extern
void
ReleaseAllJITCode
(
FreeOp
*
op
)
;
extern
void
PrepareForDebugGC
(
JSRuntime
*
rt
)
;
extern
void
DelayCrossCompartmentGrayMarking
(
JSObject
*
src
)
;
extern
void
NotifyGCNukeWrapper
(
JSObject
*
o
)
;
extern
unsigned
NotifyGCPreSwap
(
JSObject
*
a
JSObject
*
b
)
;
extern
void
NotifyGCPostSwap
(
JSObject
*
a
JSObject
*
b
unsigned
preResult
)
;
typedef
void
(
*
IterateChunkCallback
)
(
JSRuntime
*
rt
void
*
data
gc
:
:
Chunk
*
chunk
)
;
typedef
void
(
*
IterateZoneCallback
)
(
JSRuntime
*
rt
void
*
data
JS
:
:
Zone
*
zone
)
;
typedef
void
(
*
IterateArenaCallback
)
(
JSRuntime
*
rt
void
*
data
gc
:
:
Arena
*
arena
JS
:
:
TraceKind
traceKind
size_t
thingSize
)
;
typedef
void
(
*
IterateCellCallback
)
(
JSRuntime
*
rt
void
*
data
void
*
thing
JS
:
:
TraceKind
traceKind
size_t
thingSize
)
;
extern
void
IterateHeapUnbarriered
(
JSContext
*
cx
void
*
data
IterateZoneCallback
zoneCallback
JSIterateCompartmentCallback
compartmentCallback
IterateArenaCallback
arenaCallback
IterateCellCallback
cellCallback
)
;
extern
void
IterateHeapUnbarrieredForZone
(
JSContext
*
cx
Zone
*
zone
void
*
data
IterateZoneCallback
zoneCallback
JSIterateCompartmentCallback
compartmentCallback
IterateArenaCallback
arenaCallback
IterateCellCallback
cellCallback
)
;
extern
void
IterateChunks
(
JSContext
*
cx
void
*
data
IterateChunkCallback
chunkCallback
)
;
typedef
void
(
*
IterateScriptCallback
)
(
JSRuntime
*
rt
void
*
data
JSScript
*
script
)
;
extern
void
IterateScripts
(
JSContext
*
cx
JSCompartment
*
compartment
void
*
data
IterateScriptCallback
scriptCallback
)
;
extern
void
FinalizeStringRT
(
JSRuntime
*
rt
JSString
*
str
)
;
JSCompartment
*
NewCompartment
(
JSContext
*
cx
JSPrincipals
*
principals
const
JS
:
:
CompartmentOptions
&
options
)
;
namespace
gc
{
void
MergeCompartments
(
JSCompartment
*
source
JSCompartment
*
target
)
;
class
RelocationOverlay
{
static
const
uintptr_t
Relocated
=
uintptr_t
(
0xbad0bad1
)
;
uintptr_t
magic_
;
Cell
*
newLocation_
;
RelocationOverlay
*
next_
;
public
:
static
RelocationOverlay
*
fromCell
(
Cell
*
cell
)
{
return
reinterpret_cast
<
RelocationOverlay
*
>
(
cell
)
;
}
bool
isForwarded
(
)
const
{
return
magic_
=
=
Relocated
;
}
Cell
*
forwardingAddress
(
)
const
{
MOZ_ASSERT
(
isForwarded
(
)
)
;
return
newLocation_
;
}
void
forwardTo
(
Cell
*
cell
)
;
RelocationOverlay
*
&
nextRef
(
)
{
MOZ_ASSERT
(
isForwarded
(
)
)
;
return
next_
;
}
RelocationOverlay
*
next
(
)
const
{
MOZ_ASSERT
(
isForwarded
(
)
)
;
return
next_
;
}
static
bool
isCellForwarded
(
Cell
*
cell
)
{
return
fromCell
(
cell
)
-
>
isForwarded
(
)
;
}
}
;
template
<
typename
T
>
inline
bool
IsForwarded
(
T
*
t
)
;
inline
bool
IsForwarded
(
const
JS
:
:
Value
&
value
)
;
template
<
typename
T
>
inline
T
*
Forwarded
(
T
*
t
)
;
inline
Value
Forwarded
(
const
JS
:
:
Value
&
value
)
;
template
<
typename
T
>
inline
T
MaybeForwarded
(
T
t
)
;
#
ifdef
JSGC_HASH_TABLE_CHECKS
template
<
typename
T
>
inline
bool
IsGCThingValidAfterMovingGC
(
T
*
t
)
;
template
<
typename
T
>
inline
void
CheckGCThingAfterMovingGC
(
T
*
t
)
;
template
<
typename
T
>
inline
void
CheckGCThingAfterMovingGC
(
const
ReadBarriered
<
T
*
>
&
t
)
;
inline
void
CheckValueAfterMovingGC
(
const
JS
:
:
Value
&
value
)
;
#
endif
#
define
JS_FOR_EACH_ZEAL_MODE
(
D
)
\
D
(
RootsChange
1
)
\
D
(
Alloc
2
)
\
D
(
FrameGC
3
)
\
D
(
VerifierPre
4
)
\
D
(
FrameVerifierPre
5
)
\
D
(
GenerationalGC
7
)
\
D
(
IncrementalRootsThenFinish
8
)
\
D
(
IncrementalMarkAllThenFinish
9
)
\
D
(
IncrementalMultipleSlices
10
)
\
D
(
IncrementalMarkingValidator
11
)
\
D
(
ElementsBarrier
12
)
\
D
(
CheckHashTablesOnMinorGC
13
)
\
D
(
Compact
14
)
\
D
(
CheckHeapAfterGC
15
)
\
D
(
CheckNursery
16
)
\
D
(
IncrementalSweepThenFinish
17
)
enum
class
ZealMode
{
#
define
ZEAL_MODE
(
name
value
)
name
=
value
JS_FOR_EACH_ZEAL_MODE
(
ZEAL_MODE
)
#
undef
ZEAL_MODE
Limit
=
17
}
;
enum
VerifierType
{
PreBarrierVerifier
}
;
#
ifdef
JS_GC_ZEAL
extern
const
char
*
ZealModeHelpText
;
void
VerifyBarriers
(
JSRuntime
*
rt
VerifierType
type
)
;
void
MaybeVerifyBarriers
(
JSContext
*
cx
bool
always
=
false
)
;
void
DumpArenaInfo
(
)
;
#
else
static
inline
void
VerifyBarriers
(
JSRuntime
*
rt
VerifierType
type
)
{
}
static
inline
void
MaybeVerifyBarriers
(
JSContext
*
cx
bool
always
=
false
)
{
}
#
endif
class
MOZ_RAII
JS_HAZ_GC_SUPPRESSED
AutoSuppressGC
{
int32_t
&
suppressGC_
;
public
:
explicit
AutoSuppressGC
(
JSContext
*
cx
)
;
~
AutoSuppressGC
(
)
{
suppressGC_
-
-
;
}
}
;
JSObject
*
NewMemoryStatisticsObject
(
JSContext
*
cx
)
;
const
char
*
StateName
(
State
state
)
;
inline
bool
IsOOMReason
(
JS
:
:
gcreason
:
:
Reason
reason
)
{
return
reason
=
=
JS
:
:
gcreason
:
:
LAST_DITCH
|
|
reason
=
=
JS
:
:
gcreason
:
:
MEM_PRESSURE
;
}
}
class
MOZ_RAII
AutoDisableProxyCheck
{
public
:
#
ifdef
DEBUG
AutoDisableProxyCheck
(
)
;
~
AutoDisableProxyCheck
(
)
;
#
else
AutoDisableProxyCheck
(
)
{
}
#
endif
}
;
struct
MOZ_RAII
AutoDisableCompactingGC
{
explicit
AutoDisableCompactingGC
(
JSContext
*
cx
)
;
~
AutoDisableCompactingGC
(
)
;
private
:
JSContext
*
cx
;
}
;
bool
UninlinedIsInsideNursery
(
const
gc
:
:
Cell
*
cell
)
;
}
#
endif
