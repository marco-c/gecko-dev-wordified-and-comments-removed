#
ifndef
jsgc_h
#
define
jsgc_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
threading
/
ConditionVariable
.
h
"
#
include
"
threading
/
Thread
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
namespace
gcstats
{
struct
Statistics
;
}
class
Nursery
;
namespace
gc
{
#
define
GCSTATES
(
D
)
\
D
(
NotActive
)
\
D
(
MarkRoots
)
\
D
(
Mark
)
\
D
(
Sweep
)
\
D
(
Finalize
)
\
D
(
Compact
)
\
D
(
Decommit
)
enum
class
State
{
#
define
MAKE_STATE
(
name
)
name
GCSTATES
(
MAKE_STATE
)
#
undef
MAKE_STATE
}
;
#
define
GC_ABORT_REASONS
(
D
)
\
D
(
None
)
\
D
(
NonIncrementalRequested
)
\
D
(
AbortRequested
)
\
D
(
Unused1
)
\
D
(
IncrementalDisabled
)
\
D
(
ModeChange
)
\
D
(
MallocBytesTrigger
)
\
D
(
GCBytesTrigger
)
\
D
(
ZoneChange
)
\
D
(
CompartmentRevived
)
enum
class
AbortReason
{
#
define
MAKE_REASON
(
name
)
name
GC_ABORT_REASONS
(
MAKE_REASON
)
#
undef
MAKE_REASON
}
;
template
<
typename
T
>
struct
MapTypeToFinalizeKind
{
}
;
#
define
EXPAND_MAPTYPETOFINALIZEKIND
(
allocKind
traceKind
type
sizedType
)
\
template
<
>
struct
MapTypeToFinalizeKind
<
type
>
{
\
static
const
AllocKind
kind
=
AllocKind
:
:
allocKind
;
\
}
;
FOR_EACH_NONOBJECT_ALLOCKIND
(
EXPAND_MAPTYPETOFINALIZEKIND
)
#
undef
EXPAND_MAPTYPETOFINALIZEKIND
template
<
typename
T
>
struct
ParticipatesInCC
{
}
;
#
define
EXPAND_PARTICIPATES_IN_CC
(
_
type
addToCCKind
)
\
template
<
>
struct
ParticipatesInCC
<
type
>
{
static
const
bool
value
=
addToCCKind
;
}
;
JS_FOR_EACH_TRACEKIND
(
EXPAND_PARTICIPATES_IN_CC
)
#
undef
EXPAND_PARTICIPATES_IN_CC
const
size_t
MAX_EMPTY_CHUNK_AGE
=
4
;
extern
bool
InitializeStaticData
(
)
;
}
class
InterpreterFrame
;
extern
void
TraceRuntime
(
JSTracer
*
trc
)
;
extern
void
ReleaseAllJITCode
(
FreeOp
*
op
)
;
extern
void
PrepareForDebugGC
(
JSRuntime
*
rt
)
;
extern
void
DelayCrossCompartmentGrayMarking
(
JSObject
*
src
)
;
extern
void
NotifyGCNukeWrapper
(
JSObject
*
o
)
;
extern
unsigned
NotifyGCPreSwap
(
JSObject
*
a
JSObject
*
b
)
;
extern
void
NotifyGCPostSwap
(
JSObject
*
a
JSObject
*
b
unsigned
preResult
)
;
typedef
void
(
*
IterateChunkCallback
)
(
JSRuntime
*
rt
void
*
data
gc
:
:
Chunk
*
chunk
)
;
typedef
void
(
*
IterateZoneCallback
)
(
JSRuntime
*
rt
void
*
data
JS
:
:
Zone
*
zone
)
;
typedef
void
(
*
IterateArenaCallback
)
(
JSRuntime
*
rt
void
*
data
gc
:
:
Arena
*
arena
JS
:
:
TraceKind
traceKind
size_t
thingSize
)
;
typedef
void
(
*
IterateCellCallback
)
(
JSRuntime
*
rt
void
*
data
void
*
thing
JS
:
:
TraceKind
traceKind
size_t
thingSize
)
;
extern
void
IterateHeapUnbarriered
(
JSContext
*
cx
void
*
data
IterateZoneCallback
zoneCallback
JSIterateCompartmentCallback
compartmentCallback
IterateArenaCallback
arenaCallback
IterateCellCallback
cellCallback
)
;
extern
void
IterateHeapUnbarrieredForZone
(
JSContext
*
cx
Zone
*
zone
void
*
data
IterateZoneCallback
zoneCallback
JSIterateCompartmentCallback
compartmentCallback
IterateArenaCallback
arenaCallback
IterateCellCallback
cellCallback
)
;
extern
void
IterateChunks
(
JSContext
*
cx
void
*
data
IterateChunkCallback
chunkCallback
)
;
typedef
void
(
*
IterateScriptCallback
)
(
JSRuntime
*
rt
void
*
data
JSScript
*
script
)
;
extern
void
IterateScripts
(
JSContext
*
cx
JSCompartment
*
compartment
void
*
data
IterateScriptCallback
scriptCallback
)
;
extern
void
FinalizeStringRT
(
JSRuntime
*
rt
JSString
*
str
)
;
JSCompartment
*
NewCompartment
(
JSContext
*
cx
JSPrincipals
*
principals
const
JS
:
:
CompartmentOptions
&
options
)
;
namespace
gc
{
void
MergeCompartments
(
JSCompartment
*
source
JSCompartment
*
target
)
;
class
RelocationOverlay
{
static
const
uintptr_t
Relocated
=
uintptr_t
(
0xbad0bad1
)
;
uintptr_t
magic_
;
Cell
*
newLocation_
;
RelocationOverlay
*
next_
;
public
:
static
RelocationOverlay
*
fromCell
(
Cell
*
cell
)
{
return
reinterpret_cast
<
RelocationOverlay
*
>
(
cell
)
;
}
bool
isForwarded
(
)
const
{
return
magic_
=
=
Relocated
;
}
Cell
*
forwardingAddress
(
)
const
{
MOZ_ASSERT
(
isForwarded
(
)
)
;
return
newLocation_
;
}
void
forwardTo
(
Cell
*
cell
)
;
RelocationOverlay
*
&
nextRef
(
)
{
MOZ_ASSERT
(
isForwarded
(
)
)
;
return
next_
;
}
RelocationOverlay
*
next
(
)
const
{
MOZ_ASSERT
(
isForwarded
(
)
)
;
return
next_
;
}
static
bool
isCellForwarded
(
Cell
*
cell
)
{
return
fromCell
(
cell
)
-
>
isForwarded
(
)
;
}
}
;
template
<
typename
T
>
inline
bool
IsForwarded
(
T
*
t
)
;
inline
bool
IsForwarded
(
const
JS
:
:
Value
&
value
)
;
template
<
typename
T
>
inline
T
*
Forwarded
(
T
*
t
)
;
inline
Value
Forwarded
(
const
JS
:
:
Value
&
value
)
;
template
<
typename
T
>
inline
T
MaybeForwarded
(
T
t
)
;
#
ifdef
JSGC_HASH_TABLE_CHECKS
template
<
typename
T
>
inline
bool
IsGCThingValidAfterMovingGC
(
T
*
t
)
;
template
<
typename
T
>
inline
void
CheckGCThingAfterMovingGC
(
T
*
t
)
;
template
<
typename
T
>
inline
void
CheckGCThingAfterMovingGC
(
const
ReadBarriered
<
T
*
>
&
t
)
;
inline
void
CheckValueAfterMovingGC
(
const
JS
:
:
Value
&
value
)
;
#
endif
#
define
JS_FOR_EACH_ZEAL_MODE
(
D
)
\
D
(
RootsChange
1
)
\
D
(
Alloc
2
)
\
D
(
FrameGC
3
)
\
D
(
VerifierPre
4
)
\
D
(
FrameVerifierPre
5
)
\
D
(
GenerationalGC
7
)
\
D
(
IncrementalRootsThenFinish
8
)
\
D
(
IncrementalMarkAllThenFinish
9
)
\
D
(
IncrementalMultipleSlices
10
)
\
D
(
IncrementalMarkingValidator
11
)
\
D
(
ElementsBarrier
12
)
\
D
(
CheckHashTablesOnMinorGC
13
)
\
D
(
Compact
14
)
\
D
(
CheckHeapAfterGC
15
)
\
D
(
CheckNursery
16
)
\
D
(
IncrementalSweepThenFinish
17
)
enum
class
ZealMode
{
#
define
ZEAL_MODE
(
name
value
)
name
=
value
JS_FOR_EACH_ZEAL_MODE
(
ZEAL_MODE
)
#
undef
ZEAL_MODE
Limit
=
17
}
;
enum
VerifierType
{
PreBarrierVerifier
}
;
#
ifdef
JS_GC_ZEAL
extern
const
char
*
ZealModeHelpText
;
void
VerifyBarriers
(
JSRuntime
*
rt
VerifierType
type
)
;
void
MaybeVerifyBarriers
(
JSContext
*
cx
bool
always
=
false
)
;
void
DumpArenaInfo
(
)
;
#
else
static
inline
void
VerifyBarriers
(
JSRuntime
*
rt
VerifierType
type
)
{
}
static
inline
void
MaybeVerifyBarriers
(
JSContext
*
cx
bool
always
=
false
)
{
}
#
endif
class
MOZ_RAII
JS_HAZ_GC_SUPPRESSED
AutoSuppressGC
{
int32_t
&
suppressGC_
;
public
:
explicit
AutoSuppressGC
(
JSContext
*
cx
)
;
~
AutoSuppressGC
(
)
{
suppressGC_
-
-
;
}
}
;
JSObject
*
NewMemoryStatisticsObject
(
JSContext
*
cx
)
;
const
char
*
StateName
(
State
state
)
;
inline
bool
IsOOMReason
(
JS
:
:
gcreason
:
:
Reason
reason
)
{
return
reason
=
=
JS
:
:
gcreason
:
:
LAST_DITCH
|
|
reason
=
=
JS
:
:
gcreason
:
:
MEM_PRESSURE
;
}
}
class
MOZ_RAII
AutoDisableProxyCheck
{
public
:
#
ifdef
DEBUG
AutoDisableProxyCheck
(
)
;
~
AutoDisableProxyCheck
(
)
;
#
else
AutoDisableProxyCheck
(
)
{
}
#
endif
}
;
struct
MOZ_RAII
AutoDisableCompactingGC
{
explicit
AutoDisableCompactingGC
(
JSContext
*
cx
)
;
~
AutoDisableCompactingGC
(
)
;
private
:
JSContext
*
cx
;
}
;
bool
UninlinedIsInsideNursery
(
const
gc
:
:
Cell
*
cell
)
;
}
#
endif
