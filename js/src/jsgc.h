#
ifndef
jsgc_h
#
define
jsgc_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
threading
/
ConditionVariable
.
h
"
#
include
"
threading
/
Thread
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
class
AutoLockHelperThreadState
;
unsigned
GetCPUCount
(
)
;
namespace
gcstats
{
struct
Statistics
;
}
class
Nursery
;
namespace
gc
{
struct
FinalizePhase
;
#
define
GCSTATES
(
D
)
\
D
(
NotActive
)
\
D
(
MarkRoots
)
\
D
(
Mark
)
\
D
(
Sweep
)
\
D
(
Finalize
)
\
D
(
Compact
)
\
D
(
Decommit
)
enum
class
State
{
#
define
MAKE_STATE
(
name
)
name
GCSTATES
(
MAKE_STATE
)
#
undef
MAKE_STATE
}
;
template
<
typename
T
>
struct
MapTypeToFinalizeKind
{
}
;
#
define
EXPAND_MAPTYPETOFINALIZEKIND
(
allocKind
traceKind
type
sizedType
)
\
template
<
>
struct
MapTypeToFinalizeKind
<
type
>
{
\
static
const
AllocKind
kind
=
AllocKind
:
:
allocKind
;
\
}
;
FOR_EACH_NONOBJECT_ALLOCKIND
(
EXPAND_MAPTYPETOFINALIZEKIND
)
#
undef
EXPAND_MAPTYPETOFINALIZEKIND
template
<
typename
T
>
struct
ParticipatesInCC
{
}
;
#
define
EXPAND_PARTICIPATES_IN_CC
(
_
type
addToCCKind
)
\
template
<
>
struct
ParticipatesInCC
<
type
>
{
static
const
bool
value
=
addToCCKind
;
}
;
JS_FOR_EACH_TRACEKIND
(
EXPAND_PARTICIPATES_IN_CC
)
#
undef
EXPAND_PARTICIPATES_IN_CC
static
inline
bool
IsNurseryAllocable
(
AllocKind
kind
)
{
MOZ_ASSERT
(
IsValidAllocKind
(
kind
)
)
;
static
const
bool
map
[
]
=
{
true
true
false
true
false
true
false
true
false
true
false
true
false
true
false
false
false
false
false
false
false
false
false
false
false
false
}
;
JS_STATIC_ASSERT
(
JS_ARRAY_LENGTH
(
map
)
=
=
size_t
(
AllocKind
:
:
LIMIT
)
)
;
return
map
[
size_t
(
kind
)
]
;
}
static
inline
bool
IsBackgroundFinalized
(
AllocKind
kind
)
{
MOZ_ASSERT
(
IsValidAllocKind
(
kind
)
)
;
static
const
bool
map
[
]
=
{
true
true
false
true
false
true
false
true
false
true
false
true
false
true
false
true
true
true
true
true
true
true
false
true
false
true
}
;
JS_STATIC_ASSERT
(
JS_ARRAY_LENGTH
(
map
)
=
=
size_t
(
AllocKind
:
:
LIMIT
)
)
;
return
map
[
size_t
(
kind
)
]
;
}
static
inline
bool
CanBeFinalizedInBackground
(
AllocKind
kind
const
Class
*
clasp
)
{
MOZ_ASSERT
(
IsObjectAllocKind
(
kind
)
)
;
return
(
!
IsBackgroundFinalized
(
kind
)
&
&
(
!
clasp
-
>
hasFinalize
(
)
|
|
(
clasp
-
>
flags
&
JSCLASS_BACKGROUND_FINALIZE
)
)
)
;
}
const
size_t
SLOTS_TO_THING_KIND_LIMIT
=
17
;
extern
const
AllocKind
slotsToThingKind
[
]
;
static
inline
AllocKind
GetGCObjectKind
(
size_t
numSlots
)
{
if
(
numSlots
>
=
SLOTS_TO_THING_KIND_LIMIT
)
return
AllocKind
:
:
OBJECT16
;
return
slotsToThingKind
[
numSlots
]
;
}
static
inline
AllocKind
GetGCArrayKind
(
size_t
numElements
)
{
JS_STATIC_ASSERT
(
ObjectElements
:
:
VALUES_PER_HEADER
=
=
2
)
;
if
(
numElements
>
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
|
|
numElements
+
ObjectElements
:
:
VALUES_PER_HEADER
>
=
SLOTS_TO_THING_KIND_LIMIT
)
{
return
AllocKind
:
:
OBJECT2
;
}
return
slotsToThingKind
[
numElements
+
ObjectElements
:
:
VALUES_PER_HEADER
]
;
}
static
inline
AllocKind
GetGCObjectFixedSlotsKind
(
size_t
numFixedSlots
)
{
MOZ_ASSERT
(
numFixedSlots
<
SLOTS_TO_THING_KIND_LIMIT
)
;
return
slotsToThingKind
[
numFixedSlots
]
;
}
static
inline
AllocKind
GetGCObjectKindForBytes
(
size_t
nbytes
)
{
MOZ_ASSERT
(
nbytes
<
=
JSObject
:
:
MAX_BYTE_SIZE
)
;
if
(
nbytes
<
=
sizeof
(
NativeObject
)
)
return
AllocKind
:
:
OBJECT0
;
nbytes
-
=
sizeof
(
NativeObject
)
;
size_t
dataSlots
=
AlignBytes
(
nbytes
sizeof
(
Value
)
)
/
sizeof
(
Value
)
;
MOZ_ASSERT
(
nbytes
<
=
dataSlots
*
sizeof
(
Value
)
)
;
return
GetGCObjectKind
(
dataSlots
)
;
}
static
inline
AllocKind
GetBackgroundAllocKind
(
AllocKind
kind
)
{
MOZ_ASSERT
(
!
IsBackgroundFinalized
(
kind
)
)
;
MOZ_ASSERT
(
IsObjectAllocKind
(
kind
)
)
;
return
AllocKind
(
size_t
(
kind
)
+
1
)
;
}
static
inline
size_t
GetGCKindSlots
(
AllocKind
thingKind
)
{
switch
(
thingKind
)
{
case
AllocKind
:
:
FUNCTION
:
case
AllocKind
:
:
OBJECT0
:
case
AllocKind
:
:
OBJECT0_BACKGROUND
:
return
0
;
case
AllocKind
:
:
FUNCTION_EXTENDED
:
case
AllocKind
:
:
OBJECT2
:
case
AllocKind
:
:
OBJECT2_BACKGROUND
:
return
2
;
case
AllocKind
:
:
OBJECT4
:
case
AllocKind
:
:
OBJECT4_BACKGROUND
:
return
4
;
case
AllocKind
:
:
OBJECT8
:
case
AllocKind
:
:
OBJECT8_BACKGROUND
:
return
8
;
case
AllocKind
:
:
OBJECT12
:
case
AllocKind
:
:
OBJECT12_BACKGROUND
:
return
12
;
case
AllocKind
:
:
OBJECT16
:
case
AllocKind
:
:
OBJECT16_BACKGROUND
:
return
16
;
default
:
MOZ_CRASH
(
"
Bad
object
alloc
kind
"
)
;
}
}
static
inline
size_t
GetGCKindSlots
(
AllocKind
thingKind
const
Class
*
clasp
)
{
size_t
nslots
=
GetGCKindSlots
(
thingKind
)
;
if
(
clasp
-
>
flags
&
JSCLASS_HAS_PRIVATE
)
{
MOZ_ASSERT
(
nslots
>
0
)
;
nslots
-
-
;
}
if
(
clasp
=
=
FunctionClassPtr
)
nslots
=
0
;
return
nslots
;
}
static
inline
size_t
GetGCKindBytes
(
AllocKind
thingKind
)
{
return
sizeof
(
JSObject_Slots0
)
+
GetGCKindSlots
(
thingKind
)
*
sizeof
(
Value
)
;
}
class
AutoMaybeStartBackgroundAllocation
;
struct
SortedArenaListSegment
{
Arena
*
head
;
Arena
*
*
tailp
;
void
clear
(
)
{
head
=
nullptr
;
tailp
=
&
head
;
}
bool
isEmpty
(
)
const
{
return
tailp
=
=
&
head
;
}
void
append
(
Arena
*
arena
)
{
MOZ_ASSERT
(
arena
)
;
MOZ_ASSERT_IF
(
head
head
-
>
getAllocKind
(
)
=
=
arena
-
>
getAllocKind
(
)
)
;
*
tailp
=
arena
;
tailp
=
&
arena
-
>
next
;
}
void
linkTo
(
Arena
*
arena
)
{
*
tailp
=
arena
;
}
}
;
class
ArenaList
{
Arena
*
head_
;
Arena
*
*
cursorp_
;
void
copy
(
const
ArenaList
&
other
)
{
other
.
check
(
)
;
head_
=
other
.
head_
;
cursorp_
=
other
.
isCursorAtHead
(
)
?
&
head_
:
other
.
cursorp_
;
check
(
)
;
}
public
:
ArenaList
(
)
{
clear
(
)
;
}
ArenaList
(
const
ArenaList
&
other
)
{
copy
(
other
)
;
}
ArenaList
&
operator
=
(
const
ArenaList
&
other
)
{
copy
(
other
)
;
return
*
this
;
}
explicit
ArenaList
(
const
SortedArenaListSegment
&
segment
)
{
head_
=
segment
.
head
;
cursorp_
=
segment
.
isEmpty
(
)
?
&
head_
:
segment
.
tailp
;
check
(
)
;
}
void
check
(
)
const
{
#
ifdef
DEBUG
MOZ_ASSERT_IF
(
!
head_
cursorp_
=
=
&
head_
)
;
Arena
*
cursor
=
*
cursorp_
;
MOZ_ASSERT_IF
(
cursor
cursor
-
>
hasFreeThings
(
)
)
;
#
endif
}
void
clear
(
)
{
head_
=
nullptr
;
cursorp_
=
&
head_
;
check
(
)
;
}
ArenaList
copyAndClear
(
)
{
ArenaList
result
=
*
this
;
clear
(
)
;
return
result
;
}
bool
isEmpty
(
)
const
{
check
(
)
;
return
!
head_
;
}
Arena
*
head
(
)
const
{
check
(
)
;
return
head_
;
}
bool
isCursorAtHead
(
)
const
{
check
(
)
;
return
cursorp_
=
=
&
head_
;
}
bool
isCursorAtEnd
(
)
const
{
check
(
)
;
return
!
*
cursorp_
;
}
Arena
*
arenaAfterCursor
(
)
const
{
check
(
)
;
return
*
cursorp_
;
}
Arena
*
takeNextArena
(
)
{
check
(
)
;
Arena
*
arena
=
*
cursorp_
;
if
(
!
arena
)
return
nullptr
;
cursorp_
=
&
arena
-
>
next
;
check
(
)
;
return
arena
;
}
void
insertAtCursor
(
Arena
*
a
)
{
check
(
)
;
a
-
>
next
=
*
cursorp_
;
*
cursorp_
=
a
;
if
(
!
a
-
>
hasFreeThings
(
)
)
cursorp_
=
&
a
-
>
next
;
check
(
)
;
}
void
insertBeforeCursor
(
Arena
*
a
)
{
check
(
)
;
a
-
>
next
=
*
cursorp_
;
*
cursorp_
=
a
;
cursorp_
=
&
a
-
>
next
;
check
(
)
;
}
ArenaList
&
insertListWithCursorAtEnd
(
const
ArenaList
&
other
)
{
check
(
)
;
other
.
check
(
)
;
MOZ_ASSERT
(
other
.
isCursorAtEnd
(
)
)
;
if
(
other
.
isCursorAtHead
(
)
)
return
*
this
;
*
other
.
cursorp_
=
*
cursorp_
;
*
cursorp_
=
other
.
head_
;
cursorp_
=
other
.
cursorp_
;
check
(
)
;
return
*
this
;
}
Arena
*
removeRemainingArenas
(
Arena
*
*
arenap
)
;
Arena
*
*
pickArenasToRelocate
(
size_t
&
arenaTotalOut
size_t
&
relocTotalOut
)
;
Arena
*
relocateArenas
(
Arena
*
toRelocate
Arena
*
relocated
SliceBudget
&
sliceBudget
gcstats
:
:
Statistics
&
stats
)
;
}
;
class
SortedArenaList
{
public
:
static
const
size_t
MinThingSize
=
16
;
static_assert
(
ArenaSize
<
=
4096
"
When
increasing
the
Arena
size
please
consider
how
"
\
"
this
will
affect
the
size
of
a
SortedArenaList
.
"
)
;
static_assert
(
MinThingSize
>
=
16
"
When
decreasing
the
minimum
thing
size
please
consider
"
\
"
how
this
will
affect
the
size
of
a
SortedArenaList
.
"
)
;
private
:
static
const
size_t
MaxThingsPerArena
=
(
ArenaSize
-
ArenaHeaderSize
)
/
MinThingSize
;
size_t
thingsPerArena_
;
SortedArenaListSegment
segments
[
MaxThingsPerArena
+
1
]
;
Arena
*
headAt
(
size_t
n
)
{
return
segments
[
n
]
.
head
;
}
Arena
*
*
tailAt
(
size_t
n
)
{
return
segments
[
n
]
.
tailp
;
}
public
:
explicit
SortedArenaList
(
size_t
thingsPerArena
=
MaxThingsPerArena
)
{
reset
(
thingsPerArena
)
;
}
void
setThingsPerArena
(
size_t
thingsPerArena
)
{
MOZ_ASSERT
(
thingsPerArena
&
&
thingsPerArena
<
=
MaxThingsPerArena
)
;
thingsPerArena_
=
thingsPerArena
;
}
void
reset
(
size_t
thingsPerArena
=
MaxThingsPerArena
)
{
setThingsPerArena
(
thingsPerArena
)
;
for
(
size_t
i
=
0
;
i
<
=
thingsPerArena
;
+
+
i
)
segments
[
i
]
.
clear
(
)
;
}
void
insertAt
(
Arena
*
arena
size_t
nfree
)
{
MOZ_ASSERT
(
nfree
<
=
thingsPerArena_
)
;
segments
[
nfree
]
.
append
(
arena
)
;
}
void
extractEmpty
(
Arena
*
*
empty
)
{
SortedArenaListSegment
&
segment
=
segments
[
thingsPerArena_
]
;
if
(
segment
.
head
)
{
*
segment
.
tailp
=
*
empty
;
*
empty
=
segment
.
head
;
segment
.
clear
(
)
;
}
}
ArenaList
toArenaList
(
)
{
size_t
tailIndex
=
0
;
for
(
size_t
headIndex
=
1
;
headIndex
<
=
thingsPerArena_
;
+
+
headIndex
)
{
if
(
headAt
(
headIndex
)
)
{
segments
[
tailIndex
]
.
linkTo
(
headAt
(
headIndex
)
)
;
tailIndex
=
headIndex
;
}
}
segments
[
tailIndex
]
.
linkTo
(
nullptr
)
;
return
ArenaList
(
segments
[
0
]
)
;
}
}
;
class
ArenaLists
{
JSRuntime
*
runtime_
;
AllAllocKindArray
<
FreeSpan
*
>
freeLists
;
static
FreeSpan
placeholder
;
AllAllocKindArray
<
ArenaList
>
arenaLists
;
enum
BackgroundFinalizeStateEnum
{
BFS_DONE
BFS_RUN
}
;
typedef
mozilla
:
:
Atomic
<
BackgroundFinalizeStateEnum
mozilla
:
:
SequentiallyConsistent
>
BackgroundFinalizeState
;
AllAllocKindArray
<
BackgroundFinalizeState
>
backgroundFinalizeState
;
AllAllocKindArray
<
Arena
*
>
arenaListsToSweep
;
AllocKind
incrementalSweptArenaKind
;
ArenaList
incrementalSweptArenas
;
Arena
*
gcShapeArenasToUpdate
;
Arena
*
gcAccessorShapeArenasToUpdate
;
Arena
*
gcScriptArenasToUpdate
;
Arena
*
gcObjectGroupArenasToUpdate
;
ObjectAllocKindArray
<
ArenaList
>
savedObjectArenas
;
Arena
*
savedEmptyObjectArenas
;
public
:
explicit
ArenaLists
(
JSRuntime
*
rt
)
:
runtime_
(
rt
)
{
for
(
auto
i
:
AllAllocKinds
(
)
)
freeLists
[
i
]
=
&
placeholder
;
for
(
auto
i
:
AllAllocKinds
(
)
)
backgroundFinalizeState
[
i
]
=
BFS_DONE
;
for
(
auto
i
:
AllAllocKinds
(
)
)
arenaListsToSweep
[
i
]
=
nullptr
;
incrementalSweptArenaKind
=
AllocKind
:
:
LIMIT
;
gcShapeArenasToUpdate
=
nullptr
;
gcAccessorShapeArenasToUpdate
=
nullptr
;
gcScriptArenasToUpdate
=
nullptr
;
gcObjectGroupArenasToUpdate
=
nullptr
;
savedEmptyObjectArenas
=
nullptr
;
}
~
ArenaLists
(
)
;
const
void
*
addressOfFreeList
(
AllocKind
thingKind
)
const
{
return
reinterpret_cast
<
const
void
*
>
(
&
freeLists
[
thingKind
]
)
;
}
Arena
*
getFirstArena
(
AllocKind
thingKind
)
const
{
return
arenaLists
[
thingKind
]
.
head
(
)
;
}
Arena
*
getFirstArenaToSweep
(
AllocKind
thingKind
)
const
{
return
arenaListsToSweep
[
thingKind
]
;
}
Arena
*
getFirstSweptArena
(
AllocKind
thingKind
)
const
{
if
(
thingKind
!
=
incrementalSweptArenaKind
)
return
nullptr
;
return
incrementalSweptArenas
.
head
(
)
;
}
Arena
*
getArenaAfterCursor
(
AllocKind
thingKind
)
const
{
return
arenaLists
[
thingKind
]
.
arenaAfterCursor
(
)
;
}
bool
arenaListsAreEmpty
(
)
const
{
for
(
auto
i
:
AllAllocKinds
(
)
)
{
if
(
backgroundFinalizeState
[
i
]
!
=
BFS_DONE
)
return
false
;
if
(
!
arenaLists
[
i
]
.
isEmpty
(
)
)
return
false
;
}
return
true
;
}
void
unmarkAll
(
)
{
for
(
auto
i
:
AllAllocKinds
(
)
)
{
MOZ_ASSERT
(
backgroundFinalizeState
[
i
]
=
=
BFS_DONE
)
;
for
(
Arena
*
arena
=
arenaLists
[
i
]
.
head
(
)
;
arena
;
arena
=
arena
-
>
next
)
arena
-
>
unmarkAll
(
)
;
}
}
bool
doneBackgroundFinalize
(
AllocKind
kind
)
const
{
return
backgroundFinalizeState
[
kind
]
=
=
BFS_DONE
;
}
bool
needBackgroundFinalizeWait
(
AllocKind
kind
)
const
{
return
backgroundFinalizeState
[
kind
]
!
=
BFS_DONE
;
}
void
purge
(
)
{
for
(
auto
i
:
AllAllocKinds
(
)
)
freeLists
[
i
]
=
&
placeholder
;
}
inline
void
prepareForIncrementalGC
(
JSRuntime
*
rt
)
;
bool
arenaIsInUse
(
Arena
*
arena
AllocKind
kind
)
const
{
MOZ_ASSERT
(
arena
)
;
return
arena
=
=
freeLists
[
kind
]
-
>
getArenaUnchecked
(
)
;
}
MOZ_ALWAYS_INLINE
TenuredCell
*
allocateFromFreeList
(
AllocKind
thingKind
size_t
thingSize
)
{
return
freeLists
[
thingKind
]
-
>
allocate
(
thingSize
)
;
}
void
adoptArenas
(
JSRuntime
*
runtime
ArenaLists
*
fromArenaLists
)
;
bool
containsArena
(
JSRuntime
*
runtime
Arena
*
arena
)
;
void
checkEmptyFreeLists
(
)
{
#
ifdef
DEBUG
for
(
auto
i
:
AllAllocKinds
(
)
)
checkEmptyFreeList
(
i
)
;
#
endif
}
bool
checkEmptyArenaLists
(
)
{
bool
empty
=
true
;
#
ifdef
DEBUG
for
(
auto
i
:
AllAllocKinds
(
)
)
{
if
(
!
checkEmptyArenaList
(
i
)
)
empty
=
false
;
}
#
endif
return
empty
;
}
void
checkEmptyFreeList
(
AllocKind
kind
)
{
MOZ_ASSERT
(
freeLists
[
kind
]
-
>
isEmpty
(
)
)
;
}
bool
checkEmptyArenaList
(
AllocKind
kind
)
;
bool
relocateArenas
(
Zone
*
zone
Arena
*
&
relocatedListOut
JS
:
:
gcreason
:
:
Reason
reason
SliceBudget
&
sliceBudget
gcstats
:
:
Statistics
&
stats
)
;
void
queueForegroundObjectsForSweep
(
FreeOp
*
fop
)
;
void
queueForegroundThingsForSweep
(
FreeOp
*
fop
)
;
void
mergeForegroundSweptObjectArenas
(
)
;
bool
foregroundFinalize
(
FreeOp
*
fop
AllocKind
thingKind
SliceBudget
&
sliceBudget
SortedArenaList
&
sweepList
)
;
static
void
backgroundFinalize
(
FreeOp
*
fop
Arena
*
listHead
Arena
*
*
empty
)
;
enum
KeepArenasEnum
{
RELEASE_ARENAS
KEEP_ARENAS
}
;
private
:
inline
void
finalizeNow
(
FreeOp
*
fop
const
FinalizePhase
&
phase
)
;
inline
void
queueForForegroundSweep
(
FreeOp
*
fop
const
FinalizePhase
&
phase
)
;
inline
void
queueForBackgroundSweep
(
FreeOp
*
fop
const
FinalizePhase
&
phase
)
;
inline
void
finalizeNow
(
FreeOp
*
fop
AllocKind
thingKind
KeepArenasEnum
keepArenas
Arena
*
*
empty
=
nullptr
)
;
inline
void
forceFinalizeNow
(
FreeOp
*
fop
AllocKind
thingKind
KeepArenasEnum
keepArenas
Arena
*
*
empty
=
nullptr
)
;
inline
void
queueForForegroundSweep
(
FreeOp
*
fop
AllocKind
thingKind
)
;
inline
void
queueForBackgroundSweep
(
FreeOp
*
fop
AllocKind
thingKind
)
;
inline
void
mergeSweptArenas
(
AllocKind
thingKind
)
;
TenuredCell
*
allocateFromArena
(
JS
:
:
Zone
*
zone
AllocKind
thingKind
AutoMaybeStartBackgroundAllocation
&
maybeStartBGAlloc
)
;
inline
TenuredCell
*
allocateFromArenaInner
(
JS
:
:
Zone
*
zone
Arena
*
arena
AllocKind
kind
)
;
inline
void
normalizeBackgroundFinalizeState
(
AllocKind
thingKind
)
;
friend
class
GCRuntime
;
friend
class
js
:
:
Nursery
;
friend
class
js
:
:
TenuringTracer
;
}
;
const
size_t
MAX_EMPTY_CHUNK_AGE
=
4
;
}
class
InterpreterFrame
;
extern
void
MarkCompartmentActive
(
js
:
:
InterpreterFrame
*
fp
)
;
extern
void
TraceRuntime
(
JSTracer
*
trc
)
;
extern
void
ReleaseAllJITCode
(
FreeOp
*
op
)
;
extern
void
PrepareForDebugGC
(
JSRuntime
*
rt
)
;
extern
void
DelayCrossCompartmentGrayMarking
(
JSObject
*
src
)
;
extern
void
NotifyGCNukeWrapper
(
JSObject
*
o
)
;
extern
unsigned
NotifyGCPreSwap
(
JSObject
*
a
JSObject
*
b
)
;
extern
void
NotifyGCPostSwap
(
JSObject
*
a
JSObject
*
b
unsigned
preResult
)
;
class
GCHelperState
{
enum
State
{
IDLE
SWEEPING
}
;
JSRuntime
*
const
rt
;
js
:
:
ConditionVariable
done
;
State
state_
;
mozilla
:
:
Maybe
<
Thread
:
:
Id
>
thread
;
void
startBackgroundThread
(
State
newState
const
AutoLockGC
&
lock
const
AutoLockHelperThreadState
&
helperLock
)
;
void
waitForBackgroundThread
(
js
:
:
AutoLockGC
&
lock
)
;
State
state
(
const
AutoLockGC
&
)
;
void
setState
(
State
state
const
AutoLockGC
&
)
;
friend
class
js
:
:
gc
:
:
ArenaLists
;
static
void
freeElementsAndArray
(
void
*
*
array
void
*
*
end
)
{
MOZ_ASSERT
(
array
<
=
end
)
;
for
(
void
*
*
p
=
array
;
p
!
=
end
;
+
+
p
)
js_free
(
*
p
)
;
js_free
(
array
)
;
}
void
doSweep
(
AutoLockGC
&
lock
)
;
public
:
explicit
GCHelperState
(
JSRuntime
*
rt
)
:
rt
(
rt
)
done
(
)
state_
(
IDLE
)
{
}
void
finish
(
)
;
void
work
(
)
;
void
maybeStartBackgroundSweep
(
const
AutoLockGC
&
lock
const
AutoLockHelperThreadState
&
helperLock
)
;
void
startBackgroundShrink
(
const
AutoLockGC
&
lock
)
;
void
waitBackgroundSweepEnd
(
)
;
bool
onBackgroundThread
(
)
;
bool
isBackgroundSweeping
(
)
const
{
return
state_
=
=
SWEEPING
;
}
}
;
class
GCParallelTask
{
enum
TaskState
{
NotStarted
Dispatched
Finished
}
state
;
uint64_t
duration_
;
explicit
GCParallelTask
(
const
GCParallelTask
&
)
=
delete
;
protected
:
mozilla
:
:
Atomic
<
bool
>
cancel_
;
virtual
void
run
(
)
=
0
;
public
:
GCParallelTask
(
)
:
state
(
NotStarted
)
duration_
(
0
)
{
}
GCParallelTask
(
GCParallelTask
&
&
other
)
:
state
(
other
.
state
)
duration_
(
0
)
cancel_
(
false
)
{
}
virtual
~
GCParallelTask
(
)
;
int64_t
duration
(
)
const
{
return
duration_
;
}
bool
start
(
)
;
void
join
(
)
;
bool
startWithLockHeld
(
AutoLockHelperThreadState
&
locked
)
;
void
joinWithLockHeld
(
AutoLockHelperThreadState
&
locked
)
;
void
runFromMainThread
(
JSRuntime
*
rt
)
;
enum
CancelMode
{
CancelNoWait
CancelAndWait
}
;
void
cancel
(
CancelMode
mode
=
CancelNoWait
)
{
cancel_
=
true
;
if
(
mode
=
=
CancelAndWait
)
join
(
)
;
}
bool
isRunningWithLockHeld
(
const
AutoLockHelperThreadState
&
locked
)
const
;
bool
isRunning
(
)
const
;
public
:
virtual
void
runFromHelperThread
(
AutoLockHelperThreadState
&
locked
)
;
}
;
typedef
void
(
*
IterateChunkCallback
)
(
JSRuntime
*
rt
void
*
data
gc
:
:
Chunk
*
chunk
)
;
typedef
void
(
*
IterateZoneCallback
)
(
JSRuntime
*
rt
void
*
data
JS
:
:
Zone
*
zone
)
;
typedef
void
(
*
IterateArenaCallback
)
(
JSRuntime
*
rt
void
*
data
gc
:
:
Arena
*
arena
JS
:
:
TraceKind
traceKind
size_t
thingSize
)
;
typedef
void
(
*
IterateCellCallback
)
(
JSRuntime
*
rt
void
*
data
void
*
thing
JS
:
:
TraceKind
traceKind
size_t
thingSize
)
;
extern
void
IterateZonesCompartmentsArenasCells
(
JSContext
*
cx
void
*
data
IterateZoneCallback
zoneCallback
JSIterateCompartmentCallback
compartmentCallback
IterateArenaCallback
arenaCallback
IterateCellCallback
cellCallback
)
;
extern
void
IterateZoneCompartmentsArenasCells
(
JSContext
*
cx
Zone
*
zone
void
*
data
IterateZoneCallback
zoneCallback
JSIterateCompartmentCallback
compartmentCallback
IterateArenaCallback
arenaCallback
IterateCellCallback
cellCallback
)
;
extern
void
IterateChunks
(
JSContext
*
cx
void
*
data
IterateChunkCallback
chunkCallback
)
;
typedef
void
(
*
IterateScriptCallback
)
(
JSRuntime
*
rt
void
*
data
JSScript
*
script
)
;
extern
void
IterateScripts
(
JSContext
*
cx
JSCompartment
*
compartment
void
*
data
IterateScriptCallback
scriptCallback
)
;
extern
void
FinalizeStringRT
(
JSRuntime
*
rt
JSString
*
str
)
;
JSCompartment
*
NewCompartment
(
JSContext
*
cx
JS
:
:
Zone
*
zone
JSPrincipals
*
principals
const
JS
:
:
CompartmentOptions
&
options
)
;
namespace
gc
{
void
MergeCompartments
(
JSCompartment
*
source
JSCompartment
*
target
)
;
class
RelocationOverlay
{
static
const
uintptr_t
Relocated
=
uintptr_t
(
0xbad0bad1
)
;
uintptr_t
magic_
;
Cell
*
newLocation_
;
RelocationOverlay
*
next_
;
public
:
static
RelocationOverlay
*
fromCell
(
Cell
*
cell
)
{
return
reinterpret_cast
<
RelocationOverlay
*
>
(
cell
)
;
}
bool
isForwarded
(
)
const
{
return
magic_
=
=
Relocated
;
}
Cell
*
forwardingAddress
(
)
const
{
MOZ_ASSERT
(
isForwarded
(
)
)
;
return
newLocation_
;
}
void
forwardTo
(
Cell
*
cell
)
;
RelocationOverlay
*
&
nextRef
(
)
{
MOZ_ASSERT
(
isForwarded
(
)
)
;
return
next_
;
}
RelocationOverlay
*
next
(
)
const
{
MOZ_ASSERT
(
isForwarded
(
)
)
;
return
next_
;
}
static
bool
isCellForwarded
(
Cell
*
cell
)
{
return
fromCell
(
cell
)
-
>
isForwarded
(
)
;
}
}
;
template
<
typename
T
>
struct
MightBeForwarded
{
static_assert
(
mozilla
:
:
IsBaseOf
<
Cell
T
>
:
:
value
"
T
must
derive
from
Cell
"
)
;
static_assert
(
!
mozilla
:
:
IsSame
<
Cell
T
>
:
:
value
&
&
!
mozilla
:
:
IsSame
<
TenuredCell
T
>
:
:
value
"
T
must
not
be
Cell
or
TenuredCell
"
)
;
static
const
bool
value
=
mozilla
:
:
IsBaseOf
<
JSObject
T
>
:
:
value
|
|
mozilla
:
:
IsBaseOf
<
Shape
T
>
:
:
value
|
|
mozilla
:
:
IsBaseOf
<
BaseShape
T
>
:
:
value
|
|
mozilla
:
:
IsBaseOf
<
JSString
T
>
:
:
value
|
|
mozilla
:
:
IsBaseOf
<
JSScript
T
>
:
:
value
|
|
mozilla
:
:
IsBaseOf
<
js
:
:
LazyScript
T
>
:
:
value
|
|
mozilla
:
:
IsBaseOf
<
js
:
:
Scope
T
>
:
:
value
;
}
;
template
<
typename
T
>
inline
bool
IsForwarded
(
T
*
t
)
{
RelocationOverlay
*
overlay
=
RelocationOverlay
:
:
fromCell
(
t
)
;
if
(
!
MightBeForwarded
<
T
>
:
:
value
)
{
MOZ_ASSERT
(
!
overlay
-
>
isForwarded
(
)
)
;
return
false
;
}
return
overlay
-
>
isForwarded
(
)
;
}
struct
IsForwardedFunctor
:
public
BoolDefaultAdaptor
<
Value
false
>
{
template
<
typename
T
>
bool
operator
(
)
(
T
*
t
)
{
return
IsForwarded
(
t
)
;
}
}
;
inline
bool
IsForwarded
(
const
JS
:
:
Value
&
value
)
{
return
DispatchTyped
(
IsForwardedFunctor
(
)
value
)
;
}
template
<
typename
T
>
inline
T
*
Forwarded
(
T
*
t
)
{
RelocationOverlay
*
overlay
=
RelocationOverlay
:
:
fromCell
(
t
)
;
MOZ_ASSERT
(
overlay
-
>
isForwarded
(
)
)
;
return
reinterpret_cast
<
T
*
>
(
overlay
-
>
forwardingAddress
(
)
)
;
}
struct
ForwardedFunctor
:
public
IdentityDefaultAdaptor
<
Value
>
{
template
<
typename
T
>
inline
Value
operator
(
)
(
T
*
t
)
{
return
js
:
:
gc
:
:
RewrapTaggedPointer
<
Value
T
>
:
:
wrap
(
Forwarded
(
t
)
)
;
}
}
;
inline
Value
Forwarded
(
const
JS
:
:
Value
&
value
)
{
return
DispatchTyped
(
ForwardedFunctor
(
)
value
)
;
}
template
<
typename
T
>
inline
T
MaybeForwarded
(
T
t
)
{
if
(
IsForwarded
(
t
)
)
t
=
Forwarded
(
t
)
;
MakeAccessibleAfterMovingGC
(
t
)
;
return
t
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
template
<
typename
T
>
inline
bool
IsGCThingValidAfterMovingGC
(
T
*
t
)
{
return
!
IsInsideNursery
(
t
)
&
&
!
RelocationOverlay
:
:
isCellForwarded
(
t
)
;
}
template
<
typename
T
>
inline
void
CheckGCThingAfterMovingGC
(
T
*
t
)
{
if
(
t
)
MOZ_RELEASE_ASSERT
(
IsGCThingValidAfterMovingGC
(
t
)
)
;
}
template
<
typename
T
>
inline
void
CheckGCThingAfterMovingGC
(
const
ReadBarriered
<
T
*
>
&
t
)
{
CheckGCThingAfterMovingGC
(
t
.
unbarrieredGet
(
)
)
;
}
struct
CheckValueAfterMovingGCFunctor
:
public
VoidDefaultAdaptor
<
Value
>
{
template
<
typename
T
>
void
operator
(
)
(
T
*
t
)
{
CheckGCThingAfterMovingGC
(
t
)
;
}
}
;
inline
void
CheckValueAfterMovingGC
(
const
JS
:
:
Value
&
value
)
{
DispatchTyped
(
CheckValueAfterMovingGCFunctor
(
)
value
)
;
}
#
endif
#
define
JS_FOR_EACH_ZEAL_MODE
(
D
)
\
D
(
Poke
1
)
\
D
(
Alloc
2
)
\
D
(
FrameGC
3
)
\
D
(
VerifierPre
4
)
\
D
(
FrameVerifierPre
5
)
\
D
(
StackRooting
6
)
\
D
(
GenerationalGC
7
)
\
D
(
IncrementalRootsThenFinish
8
)
\
D
(
IncrementalMarkAllThenFinish
9
)
\
D
(
IncrementalMultipleSlices
10
)
\
D
(
IncrementalMarkingValidator
11
)
\
D
(
ElementsBarrier
12
)
\
D
(
CheckHashTablesOnMinorGC
13
)
\
D
(
Compact
14
)
\
D
(
CheckHeapAfterGC
15
)
\
D
(
CheckNursery
16
)
enum
class
ZealMode
{
#
define
ZEAL_MODE
(
name
value
)
name
=
value
JS_FOR_EACH_ZEAL_MODE
(
ZEAL_MODE
)
#
undef
ZEAL_MODE
Limit
=
16
}
;
enum
VerifierType
{
PreBarrierVerifier
}
;
#
ifdef
JS_GC_ZEAL
extern
const
char
*
ZealModeHelpText
;
void
VerifyBarriers
(
JSRuntime
*
rt
VerifierType
type
)
;
void
MaybeVerifyBarriers
(
JSContext
*
cx
bool
always
=
false
)
;
#
else
static
inline
void
VerifyBarriers
(
JSRuntime
*
rt
VerifierType
type
)
{
}
static
inline
void
MaybeVerifyBarriers
(
JSContext
*
cx
bool
always
=
false
)
{
}
#
endif
class
MOZ_RAII
JS_HAZ_GC_SUPPRESSED
AutoSuppressGC
{
int32_t
&
suppressGC_
;
public
:
explicit
AutoSuppressGC
(
ExclusiveContext
*
cx
)
;
explicit
AutoSuppressGC
(
JSCompartment
*
comp
)
;
explicit
AutoSuppressGC
(
JSContext
*
cx
)
;
~
AutoSuppressGC
(
)
{
suppressGC_
-
-
;
}
}
;
class
ZoneList
{
static
Zone
*
const
End
;
Zone
*
head
;
Zone
*
tail
;
public
:
ZoneList
(
)
;
~
ZoneList
(
)
;
bool
isEmpty
(
)
const
;
Zone
*
front
(
)
const
;
void
append
(
Zone
*
zone
)
;
void
transferFrom
(
ZoneList
&
other
)
;
void
removeFront
(
)
;
void
clear
(
)
;
private
:
explicit
ZoneList
(
Zone
*
singleZone
)
;
void
check
(
)
const
;
ZoneList
(
const
ZoneList
&
other
)
=
delete
;
ZoneList
&
operator
=
(
const
ZoneList
&
other
)
=
delete
;
}
;
JSObject
*
NewMemoryStatisticsObject
(
JSContext
*
cx
)
;
struct
MOZ_RAII
AutoAssertNoNurseryAlloc
{
#
ifdef
DEBUG
explicit
AutoAssertNoNurseryAlloc
(
JSRuntime
*
rt
)
;
~
AutoAssertNoNurseryAlloc
(
)
;
private
:
gc
:
:
GCRuntime
&
gc
;
#
else
explicit
AutoAssertNoNurseryAlloc
(
JSRuntime
*
rt
)
{
}
#
endif
}
;
class
MOZ_RAII
AutoAssertHeapBusy
{
protected
:
JSRuntime
*
rt
;
void
checkCondition
(
JSRuntime
*
rt
)
;
AutoAssertHeapBusy
(
)
:
rt
(
nullptr
)
{
}
public
:
explicit
AutoAssertHeapBusy
(
JSRuntime
*
rt
)
{
checkCondition
(
rt
)
;
}
~
AutoAssertHeapBusy
(
)
{
MOZ_ASSERT
(
rt
)
;
checkCondition
(
rt
)
;
}
}
;
class
MOZ_RAII
AutoAssertEmptyNursery
{
protected
:
JSRuntime
*
rt
;
mozilla
:
:
Maybe
<
AutoAssertNoNurseryAlloc
>
noAlloc
;
void
checkCondition
(
JSRuntime
*
rt
)
;
AutoAssertEmptyNursery
(
)
:
rt
(
nullptr
)
{
}
public
:
explicit
AutoAssertEmptyNursery
(
JSRuntime
*
rt
)
:
rt
(
nullptr
)
{
checkCondition
(
rt
)
;
}
AutoAssertEmptyNursery
(
const
AutoAssertEmptyNursery
&
other
)
:
AutoAssertEmptyNursery
(
other
.
rt
)
{
}
}
;
class
MOZ_RAII
AutoEmptyNursery
:
public
AutoAssertEmptyNursery
{
public
:
explicit
AutoEmptyNursery
(
JSRuntime
*
rt
)
;
}
;
const
char
*
StateName
(
State
state
)
;
inline
bool
IsOOMReason
(
JS
:
:
gcreason
:
:
Reason
reason
)
{
return
reason
=
=
JS
:
:
gcreason
:
:
LAST_DITCH
|
|
reason
=
=
JS
:
:
gcreason
:
:
MEM_PRESSURE
;
}
}
#
ifdef
DEBUG
class
MOZ_RAII
AutoDisableProxyCheck
{
gc
:
:
GCRuntime
&
gc
;
public
:
explicit
AutoDisableProxyCheck
(
JSRuntime
*
rt
)
;
~
AutoDisableProxyCheck
(
)
;
}
;
#
else
struct
MOZ_RAII
AutoDisableProxyCheck
{
explicit
AutoDisableProxyCheck
(
JSRuntime
*
rt
)
{
}
}
;
#
endif
struct
MOZ_RAII
AutoDisableCompactingGC
{
explicit
AutoDisableCompactingGC
(
JSContext
*
cx
)
;
~
AutoDisableCompactingGC
(
)
;
private
:
gc
:
:
GCRuntime
&
gc
;
}
;
void
PurgeJITCaches
(
JS
:
:
Zone
*
zone
)
;
bool
UninlinedIsInsideNursery
(
const
gc
:
:
Cell
*
cell
)
;
}
#
endif
