#
include
"
jsdate
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
<
algorithm
>
#
include
<
cstring
>
#
include
<
iterator
>
#
include
<
math
.
h
>
#
include
<
string
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsnum
.
h
"
#
include
"
jstypes
.
h
"
#
ifdef
JS_HAS_TEMPORAL_API
#
include
"
builtin
/
temporal
/
Instant
.
h
"
#
endif
#
include
"
js
/
CallAndConstruct
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
Date
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
LocaleSensitive
.
h
"
#
include
"
js
/
Object
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
util
/
DifferentialTesting
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
DateObject
.
h
"
#
include
"
vm
/
DateTime
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
Time
.
h
"
#
include
"
vm
/
Warnings
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
GeckoProfiler
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
namespace
js
;
using
mozilla
:
:
Atomic
;
using
mozilla
:
:
BitwiseCast
;
using
mozilla
:
:
IsAsciiAlpha
;
using
mozilla
:
:
IsAsciiDigit
;
using
mozilla
:
:
IsAsciiLowercaseAlpha
;
using
mozilla
:
:
NumbersAreIdentical
;
using
mozilla
:
:
Relaxed
;
using
JS
:
:
AutoCheckCannotGC
;
using
JS
:
:
ClippedTime
;
using
JS
:
:
GenericNaN
;
using
JS
:
:
GetBuiltinClass
;
using
JS
:
:
TimeClip
;
using
JS
:
:
ToInteger
;
static
Atomic
<
uint32_t
Relaxed
>
sResolutionUsec
;
static
Atomic
<
bool
Relaxed
>
sJitter
;
static
Atomic
<
JS
:
:
ReduceMicrosecondTimePrecisionCallback
Relaxed
>
sReduceMicrosecondTimePrecisionCallback
;
namespace
{
class
DateTimeHelper
{
private
:
#
if
JS_HAS_INTL_API
static
double
localTZA
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
t
DateTimeInfo
:
:
TimeZoneOffset
offset
)
;
#
else
static
int
equivalentYearForDST
(
int
year
)
;
static
bool
isRepresentableAsTime32
(
double
t
)
;
static
double
daylightSavingTA
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
t
)
;
static
double
adjustTime
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
date
)
;
static
PRMJTime
toPRMJTime
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
localTime
double
utcTime
)
;
#
endif
public
:
static
double
localTime
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
t
)
;
static
double
UTC
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
t
)
;
static
JSString
*
timeZoneComment
(
JSContext
*
cx
DateTimeInfo
:
:
ForceUTC
forceUTC
const
char
*
locale
double
utcTime
double
localTime
)
;
#
if
!
JS_HAS_INTL_API
static
size_t
formatTime
(
DateTimeInfo
:
:
ForceUTC
forceUTC
char
*
buf
size_t
buflen
const
char
*
fmt
double
utcTime
double
localTime
)
;
#
endif
}
;
}
static
DateTimeInfo
:
:
ForceUTC
ForceUTC
(
const
Realm
*
realm
)
{
return
realm
-
>
creationOptions
(
)
.
forceUTC
(
)
?
DateTimeInfo
:
:
ForceUTC
:
:
Yes
:
DateTimeInfo
:
:
ForceUTC
:
:
No
;
}
static
inline
double
PositiveModulo
(
double
dividend
double
divisor
)
{
MOZ_ASSERT
(
divisor
>
0
)
;
MOZ_ASSERT
(
std
:
:
isfinite
(
divisor
)
)
;
double
result
=
fmod
(
dividend
divisor
)
;
if
(
result
<
0
)
{
result
+
=
divisor
;
}
return
result
+
(
+
0
.
0
)
;
}
static
inline
double
Day
(
double
t
)
{
return
floor
(
t
/
msPerDay
)
;
}
static
double
TimeWithinDay
(
double
t
)
{
return
PositiveModulo
(
t
msPerDay
)
;
}
static
inline
bool
IsLeapYear
(
double
year
)
{
MOZ_ASSERT
(
ToInteger
(
year
)
=
=
year
)
;
return
fmod
(
year
4
)
=
=
0
&
&
(
fmod
(
year
100
)
!
=
0
|
|
fmod
(
year
400
)
=
=
0
)
;
}
static
inline
double
DayFromYear
(
double
y
)
{
return
365
*
(
y
-
1970
)
+
floor
(
(
y
-
1969
)
/
4
.
0
)
-
floor
(
(
y
-
1901
)
/
100
.
0
)
+
floor
(
(
y
-
1601
)
/
400
.
0
)
;
}
static
inline
double
TimeFromYear
(
double
y
)
{
return
DayFromYear
(
y
)
*
msPerDay
;
}
namespace
{
struct
YearMonthDay
{
int32_t
year
;
uint32_t
month
;
uint32_t
day
;
}
;
}
static
YearMonthDay
ToYearMonthDay
(
double
t
)
{
MOZ_ASSERT
(
ToInteger
(
t
)
=
=
t
)
;
constexpr
uint32_t
cycleInYears
=
400
;
constexpr
uint32_t
cycleInDays
=
cycleInYears
*
365
+
(
cycleInYears
/
4
)
-
(
cycleInYears
/
100
)
+
(
cycleInYears
/
400
)
;
static_assert
(
cycleInDays
=
=
146097
"
Wrong
calculation
of
cycleInDays
.
"
)
;
constexpr
uint32_t
rataDie1970Jan1
=
719468
;
constexpr
uint32_t
maxU32
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
constexpr
uint32_t
s
=
3670
;
constexpr
uint32_t
K
=
rataDie1970Jan1
+
s
*
cycleInDays
;
constexpr
uint32_t
L
=
s
*
cycleInYears
;
constexpr
int32_t
minDays
=
-
int32_t
(
K
)
;
constexpr
int32_t
maxDays
=
(
maxU32
-
3
)
/
4
-
K
;
static_assert
(
minDays
=
=
-
536
'
895
'
458
"
Wrong
calculation
of
minDays
or
K
.
"
)
;
static_assert
(
maxDays
=
=
536
'
846
'
365
"
Wrong
calculation
of
maxDays
or
K
.
"
)
;
constexpr
int64_t
minTime
=
minDays
*
int64_t
(
msPerDay
)
;
[
[
maybe_unused
]
]
constexpr
int64_t
maxTime
=
maxDays
*
int64_t
(
msPerDay
)
;
MOZ_ASSERT
(
double
(
minTime
)
<
=
t
&
&
t
<
=
double
(
maxTime
)
)
;
const
int64_t
time
=
int64_t
(
t
)
;
const
uint64_t
u
=
uint64_t
(
time
-
minTime
)
;
const
int32_t
N_U
=
int32_t
(
u
/
uint64_t
(
msPerDay
)
)
+
minDays
;
MOZ_ASSERT
(
minDays
<
=
N_U
&
&
N_U
<
=
maxDays
)
;
const
uint32_t
N
=
uint32_t
(
N_U
)
+
K
;
const
uint32_t
N_1
=
4
*
N
+
3
;
const
uint32_t
C
=
N_1
/
146097
;
const
uint32_t
N_C
=
N_1
%
146097
/
4
;
const
uint32_t
N_2
=
4
*
N_C
+
3
;
const
uint64_t
P_2
=
uint64_t
(
2939745
)
*
N_2
;
const
uint32_t
Z
=
uint32_t
(
P_2
/
4294967296
)
;
const
uint32_t
N_Y
=
uint32_t
(
P_2
%
4294967296
)
/
2939745
/
4
;
const
uint32_t
Y
=
100
*
C
+
Z
;
const
uint32_t
N_3
=
2141
*
N_Y
+
132377
;
const
uint32_t
M
=
N_3
/
65536
;
const
uint32_t
D
=
N_3
%
65536
/
2141
;
constexpr
uint32_t
daysFromMar01ToJan01
=
306
;
const
uint32_t
J
=
N_Y
>
=
daysFromMar01ToJan01
;
const
int32_t
Y_G
=
int32_t
(
(
Y
-
L
)
+
J
)
;
const
uint32_t
M_G
=
J
?
M
-
12
:
M
;
const
uint32_t
D_G
=
D
+
1
;
return
{
Y_G
M_G
D_G
}
;
}
static
double
YearFromTime
(
double
t
)
{
if
(
!
std
:
:
isfinite
(
t
)
)
{
return
GenericNaN
(
)
;
}
auto
const
year
=
ToYearMonthDay
(
t
)
.
year
;
return
double
(
year
)
;
}
static
double
DayWithinYear
(
double
t
double
year
)
{
MOZ_ASSERT_IF
(
std
:
:
isfinite
(
t
)
YearFromTime
(
t
)
=
=
year
)
;
return
Day
(
t
)
-
DayFromYear
(
year
)
;
}
static
double
MonthFromTime
(
double
t
)
{
if
(
!
std
:
:
isfinite
(
t
)
)
{
return
GenericNaN
(
)
;
}
const
auto
month
=
ToYearMonthDay
(
t
)
.
month
;
return
double
(
month
)
;
}
static
double
DateFromTime
(
double
t
)
{
if
(
!
std
:
:
isfinite
(
t
)
)
{
return
GenericNaN
(
)
;
}
const
auto
day
=
ToYearMonthDay
(
t
)
.
day
;
return
double
(
day
)
;
}
static
int
WeekDay
(
double
t
)
{
MOZ_ASSERT
(
ToInteger
(
t
)
=
=
t
)
;
int
result
=
(
int
(
Day
(
t
)
)
+
4
)
%
7
;
if
(
result
<
0
)
{
result
+
=
7
;
}
return
result
;
}
static
inline
int
DayFromMonth
(
int
month
bool
isLeapYear
)
{
static
const
int
firstDayOfMonth
[
2
]
[
13
]
=
{
{
0
31
59
90
120
151
181
212
243
273
304
334
365
}
{
0
31
60
91
121
152
182
213
244
274
305
335
366
}
}
;
MOZ_ASSERT
(
0
<
=
month
&
&
month
<
=
12
)
;
return
firstDayOfMonth
[
isLeapYear
]
[
month
]
;
}
template
<
typename
T
>
static
inline
int
DayFromMonth
(
T
month
bool
isLeapYear
)
=
delete
;
static
double
MakeDay
(
double
year
double
month
double
date
)
{
if
(
!
std
:
:
isfinite
(
year
)
|
|
!
std
:
:
isfinite
(
month
)
|
|
!
std
:
:
isfinite
(
date
)
)
{
return
GenericNaN
(
)
;
}
double
y
=
ToInteger
(
year
)
;
double
m
=
ToInteger
(
month
)
;
double
dt
=
ToInteger
(
date
)
;
double
ym
=
y
+
floor
(
m
/
12
)
;
int
mn
=
int
(
PositiveModulo
(
m
12
)
)
;
bool
leap
=
IsLeapYear
(
ym
)
;
double
yearday
=
floor
(
TimeFromYear
(
ym
)
/
msPerDay
)
;
double
monthday
=
DayFromMonth
(
mn
leap
)
;
return
yearday
+
monthday
+
dt
-
1
;
}
static
inline
double
MakeDate
(
double
day
double
time
)
{
if
(
!
std
:
:
isfinite
(
day
)
|
|
!
std
:
:
isfinite
(
time
)
)
{
return
GenericNaN
(
)
;
}
return
day
*
msPerDay
+
time
;
}
JS_PUBLIC_API
double
JS
:
:
MakeDate
(
double
year
unsigned
month
unsigned
day
)
{
MOZ_ASSERT
(
month
<
=
11
)
;
MOZ_ASSERT
(
day
>
=
1
&
&
day
<
=
31
)
;
return
:
:
MakeDate
(
MakeDay
(
year
month
day
)
0
)
;
}
JS_PUBLIC_API
double
JS
:
:
MakeDate
(
double
year
unsigned
month
unsigned
day
double
time
)
{
MOZ_ASSERT
(
month
<
=
11
)
;
MOZ_ASSERT
(
day
>
=
1
&
&
day
<
=
31
)
;
return
:
:
MakeDate
(
MakeDay
(
year
month
day
)
time
)
;
}
JS_PUBLIC_API
double
JS
:
:
YearFromTime
(
double
time
)
{
const
auto
clipped
=
TimeClip
(
time
)
;
if
(
!
clipped
.
isValid
(
)
)
{
return
GenericNaN
(
)
;
}
return
:
:
YearFromTime
(
clipped
.
toDouble
(
)
)
;
}
JS_PUBLIC_API
double
JS
:
:
MonthFromTime
(
double
time
)
{
const
auto
clipped
=
TimeClip
(
time
)
;
if
(
!
clipped
.
isValid
(
)
)
{
return
GenericNaN
(
)
;
}
return
:
:
MonthFromTime
(
clipped
.
toDouble
(
)
)
;
}
JS_PUBLIC_API
double
JS
:
:
DayFromTime
(
double
time
)
{
const
auto
clipped
=
TimeClip
(
time
)
;
if
(
!
clipped
.
isValid
(
)
)
{
return
GenericNaN
(
)
;
}
return
DateFromTime
(
clipped
.
toDouble
(
)
)
;
}
JS_PUBLIC_API
double
JS
:
:
DayFromYear
(
double
year
)
{
return
:
:
DayFromYear
(
year
)
;
}
JS_PUBLIC_API
double
JS
:
:
DayWithinYear
(
double
time
double
year
)
{
const
auto
clipped
=
TimeClip
(
time
)
;
if
(
!
clipped
.
isValid
(
)
)
{
return
GenericNaN
(
)
;
}
return
:
:
DayWithinYear
(
clipped
.
toDouble
(
)
year
)
;
}
JS_PUBLIC_API
void
JS
:
:
SetReduceMicrosecondTimePrecisionCallback
(
JS
:
:
ReduceMicrosecondTimePrecisionCallback
callback
)
{
sReduceMicrosecondTimePrecisionCallback
=
callback
;
}
JS_PUBLIC_API
JS
:
:
ReduceMicrosecondTimePrecisionCallback
JS
:
:
GetReduceMicrosecondTimePrecisionCallback
(
)
{
return
sReduceMicrosecondTimePrecisionCallback
;
}
JS_PUBLIC_API
void
JS
:
:
SetTimeResolutionUsec
(
uint32_t
resolution
bool
jitter
)
{
sResolutionUsec
=
resolution
;
sJitter
=
jitter
;
}
#
if
JS_HAS_INTL_API
double
DateTimeHelper
:
:
localTZA
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
t
DateTimeInfo
:
:
TimeZoneOffset
offset
)
{
MOZ_ASSERT
(
std
:
:
isfinite
(
t
)
)
;
int64_t
milliseconds
=
static_cast
<
int64_t
>
(
t
)
;
int32_t
offsetMilliseconds
=
DateTimeInfo
:
:
getOffsetMilliseconds
(
forceUTC
milliseconds
offset
)
;
return
static_cast
<
double
>
(
offsetMilliseconds
)
;
}
double
DateTimeHelper
:
:
localTime
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
t
)
{
if
(
!
std
:
:
isfinite
(
t
)
)
{
return
GenericNaN
(
)
;
}
MOZ_ASSERT
(
StartOfTime
<
=
t
&
&
t
<
=
EndOfTime
)
;
return
t
+
localTZA
(
forceUTC
t
DateTimeInfo
:
:
TimeZoneOffset
:
:
UTC
)
;
}
double
DateTimeHelper
:
:
UTC
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
t
)
{
if
(
!
std
:
:
isfinite
(
t
)
)
{
return
GenericNaN
(
)
;
}
if
(
t
<
(
StartOfTime
-
msPerDay
)
|
|
t
>
(
EndOfTime
+
msPerDay
)
)
{
return
GenericNaN
(
)
;
}
return
t
-
localTZA
(
forceUTC
t
DateTimeInfo
:
:
TimeZoneOffset
:
:
Local
)
;
}
#
else
int
DateTimeHelper
:
:
equivalentYearForDST
(
int
year
)
{
static
const
int
pastYearStartingWith
[
2
]
[
7
]
=
{
{
1978
1973
1974
1975
1981
1971
1977
}
{
1984
1996
1980
1992
1976
1988
1972
}
}
;
static
const
int
futureYearStartingWith
[
2
]
[
7
]
=
{
{
2034
2035
2030
2031
2037
2027
2033
}
{
2012
2024
2036
2020
2032
2016
2028
}
}
;
int
day
=
int
(
DayFromYear
(
year
)
+
4
)
%
7
;
if
(
day
<
0
)
{
day
+
=
7
;
}
const
auto
&
yearStartingWith
=
year
<
1970
?
pastYearStartingWith
:
futureYearStartingWith
;
return
yearStartingWith
[
IsLeapYear
(
year
)
]
[
day
]
;
}
bool
DateTimeHelper
:
:
isRepresentableAsTime32
(
double
t
)
{
return
0
.
0
<
=
t
&
&
t
<
2145916800000
.
0
;
}
double
DateTimeHelper
:
:
daylightSavingTA
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
t
)
{
if
(
!
std
:
:
isfinite
(
t
)
)
{
return
GenericNaN
(
)
;
}
if
(
!
isRepresentableAsTime32
(
t
)
)
{
int
year
=
equivalentYearForDST
(
int
(
YearFromTime
(
t
)
)
)
;
double
day
=
MakeDay
(
year
MonthFromTime
(
t
)
DateFromTime
(
t
)
)
;
t
=
MakeDate
(
day
TimeWithinDay
(
t
)
)
;
}
int64_t
utcMilliseconds
=
static_cast
<
int64_t
>
(
t
)
;
int32_t
offsetMilliseconds
=
DateTimeInfo
:
:
getDSTOffsetMilliseconds
(
forceUTC
utcMilliseconds
)
;
return
static_cast
<
double
>
(
offsetMilliseconds
)
;
}
double
DateTimeHelper
:
:
adjustTime
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
date
)
{
double
localTZA
=
DateTimeInfo
:
:
localTZA
(
forceUTC
)
;
double
t
=
daylightSavingTA
(
forceUTC
date
)
+
localTZA
;
t
=
(
localTZA
>
=
0
)
?
fmod
(
t
msPerDay
)
:
-
fmod
(
msPerDay
-
t
msPerDay
)
;
return
t
;
}
double
DateTimeHelper
:
:
localTime
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
t
)
{
return
t
+
adjustTime
(
forceUTC
t
)
;
}
double
DateTimeHelper
:
:
UTC
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
t
)
{
return
t
-
adjustTime
(
forceUTC
t
-
DateTimeInfo
:
:
localTZA
(
forceUTC
)
-
msPerHour
)
;
}
#
endif
static
double
LocalTime
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
t
)
{
return
DateTimeHelper
:
:
localTime
(
forceUTC
t
)
;
}
static
double
UTC
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
t
)
{
return
DateTimeHelper
:
:
UTC
(
forceUTC
t
)
;
}
static
double
HourFromTime
(
double
t
)
{
return
PositiveModulo
(
floor
(
t
/
msPerHour
)
HoursPerDay
)
;
}
static
double
MinFromTime
(
double
t
)
{
return
PositiveModulo
(
floor
(
t
/
msPerMinute
)
MinutesPerHour
)
;
}
static
double
SecFromTime
(
double
t
)
{
return
PositiveModulo
(
floor
(
t
/
msPerSecond
)
SecondsPerMinute
)
;
}
static
double
msFromTime
(
double
t
)
{
return
PositiveModulo
(
t
msPerSecond
)
;
}
static
double
MakeTime
(
double
hour
double
min
double
sec
double
ms
)
{
if
(
!
std
:
:
isfinite
(
hour
)
|
|
!
std
:
:
isfinite
(
min
)
|
|
!
std
:
:
isfinite
(
sec
)
|
|
!
std
:
:
isfinite
(
ms
)
)
{
return
GenericNaN
(
)
;
}
double
h
=
ToInteger
(
hour
)
;
double
m
=
ToInteger
(
min
)
;
double
s
=
ToInteger
(
sec
)
;
double
milli
=
ToInteger
(
ms
)
;
return
h
*
msPerHour
+
m
*
msPerMinute
+
s
*
msPerSecond
+
milli
;
}
static
bool
date_UTC
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSMethodProfilerEntry
pseudoFrame
(
cx
"
Date
"
"
UTC
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
double
y
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
y
)
)
{
return
false
;
}
double
m
;
if
(
args
.
length
(
)
>
=
2
)
{
if
(
!
ToNumber
(
cx
args
[
1
]
&
m
)
)
{
return
false
;
}
}
else
{
m
=
0
;
}
double
dt
;
if
(
args
.
length
(
)
>
=
3
)
{
if
(
!
ToNumber
(
cx
args
[
2
]
&
dt
)
)
{
return
false
;
}
}
else
{
dt
=
1
;
}
double
h
;
if
(
args
.
length
(
)
>
=
4
)
{
if
(
!
ToNumber
(
cx
args
[
3
]
&
h
)
)
{
return
false
;
}
}
else
{
h
=
0
;
}
double
min
;
if
(
args
.
length
(
)
>
=
5
)
{
if
(
!
ToNumber
(
cx
args
[
4
]
&
min
)
)
{
return
false
;
}
}
else
{
min
=
0
;
}
double
s
;
if
(
args
.
length
(
)
>
=
6
)
{
if
(
!
ToNumber
(
cx
args
[
5
]
&
s
)
)
{
return
false
;
}
}
else
{
s
=
0
;
}
double
milli
;
if
(
args
.
length
(
)
>
=
7
)
{
if
(
!
ToNumber
(
cx
args
[
6
]
&
milli
)
)
{
return
false
;
}
}
else
{
milli
=
0
;
}
double
yr
=
y
;
if
(
!
std
:
:
isnan
(
y
)
)
{
double
yint
=
ToInteger
(
y
)
;
if
(
0
<
=
yint
&
&
yint
<
=
99
)
{
yr
=
1900
+
yint
;
}
}
ClippedTime
time
=
TimeClip
(
MakeDate
(
MakeDay
(
yr
m
dt
)
MakeTime
(
h
min
s
milli
)
)
)
;
args
.
rval
(
)
.
set
(
TimeValue
(
time
)
)
;
return
true
;
}
template
<
typename
CharT
>
static
bool
ParseDigits
(
size_t
*
result
const
CharT
*
s
size_t
*
i
size_t
limit
)
{
size_t
init
=
*
i
;
*
result
=
0
;
while
(
*
i
<
limit
&
&
(
'
0
'
<
=
s
[
*
i
]
&
&
s
[
*
i
]
<
=
'
9
'
)
)
{
*
result
*
=
10
;
*
result
+
=
(
s
[
*
i
]
-
'
0
'
)
;
+
+
(
*
i
)
;
}
return
*
i
!
=
init
;
}
template
<
typename
CharT
>
static
bool
ParseFractional
(
int
*
result
const
CharT
*
s
size_t
*
i
size_t
limit
)
{
int
factor
=
100
;
size_t
init
=
*
i
;
*
result
=
0
;
for
(
;
*
i
<
limit
&
&
(
'
0
'
<
=
s
[
*
i
]
&
&
s
[
*
i
]
<
=
'
9
'
)
;
+
+
(
*
i
)
)
{
if
(
*
i
-
init
>
=
3
)
{
continue
;
}
*
result
+
=
(
s
[
*
i
]
-
'
0
'
)
*
factor
;
factor
/
=
10
;
}
return
*
i
!
=
init
;
}
template
<
typename
CharT
>
static
bool
ParseDigitsN
(
size_t
n
size_t
*
result
const
CharT
*
s
size_t
*
i
size_t
limit
)
{
size_t
init
=
*
i
;
if
(
ParseDigits
(
result
s
i
std
:
:
min
(
limit
init
+
n
)
)
)
{
return
(
*
i
-
init
)
=
=
n
;
}
*
i
=
init
;
return
false
;
}
template
<
typename
CharT
>
static
bool
ParseDigitsNOrLess
(
size_t
n
size_t
*
result
const
CharT
*
s
size_t
*
i
size_t
limit
)
{
size_t
init
=
*
i
;
if
(
ParseDigits
(
result
s
i
std
:
:
min
(
limit
init
+
n
)
)
)
{
return
(
(
*
i
-
init
)
>
0
)
&
&
(
(
*
i
-
init
)
<
=
n
)
;
}
*
i
=
init
;
return
false
;
}
template
<
typename
CharT
>
static
bool
ParseISOStyleDate
(
DateTimeInfo
:
:
ForceUTC
forceUTC
const
CharT
*
s
size_t
length
ClippedTime
*
result
)
{
size_t
i
=
0
;
int
tzMul
=
1
;
int
dateMul
=
1
;
size_t
year
=
1970
;
size_t
month
=
1
;
size_t
day
=
1
;
size_t
hour
=
0
;
size_t
min
=
0
;
size_t
sec
=
0
;
int
msec
=
0
;
bool
isLocalTime
=
false
;
size_t
tzHour
=
0
;
size_t
tzMin
=
0
;
#
define
PEEK
(
ch
)
(
i
<
length
&
&
s
[
i
]
=
=
ch
)
#
define
NEED
(
ch
)
\
if
(
i
>
=
length
|
|
s
[
i
]
!
=
ch
)
{
\
return
false
;
\
}
else
{
\
+
+
i
;
\
}
#
define
DONE_DATE_UNLESS
(
ch
)
\
if
(
i
>
=
length
|
|
s
[
i
]
!
=
ch
)
{
\
goto
done_date
;
\
}
else
{
\
+
+
i
;
\
}
#
define
DONE_UNLESS
(
ch
)
\
if
(
i
>
=
length
|
|
s
[
i
]
!
=
ch
)
{
\
goto
done
;
\
}
else
{
\
+
+
i
;
\
}
#
define
NEED_NDIGITS
(
n
field
)
\
if
(
!
ParseDigitsN
(
n
&
field
s
&
i
length
)
)
{
\
return
false
;
\
}
if
(
PEEK
(
'
+
'
)
|
|
PEEK
(
'
-
'
)
)
{
if
(
PEEK
(
'
-
'
)
)
{
dateMul
=
-
1
;
}
+
+
i
;
NEED_NDIGITS
(
6
year
)
;
if
(
year
=
=
0
&
&
dateMul
=
=
-
1
)
{
return
false
;
}
}
else
{
NEED_NDIGITS
(
4
year
)
;
}
DONE_DATE_UNLESS
(
'
-
'
)
;
NEED_NDIGITS
(
2
month
)
;
DONE_DATE_UNLESS
(
'
-
'
)
;
NEED_NDIGITS
(
2
day
)
;
done_date
:
if
(
PEEK
(
'
T
'
)
)
{
+
+
i
;
}
else
{
goto
done
;
}
NEED_NDIGITS
(
2
hour
)
;
NEED
(
'
:
'
)
;
NEED_NDIGITS
(
2
min
)
;
if
(
PEEK
(
'
:
'
)
)
{
+
+
i
;
NEED_NDIGITS
(
2
sec
)
;
if
(
PEEK
(
'
.
'
)
)
{
+
+
i
;
if
(
!
ParseFractional
(
&
msec
s
&
i
length
)
)
{
return
false
;
}
}
}
if
(
PEEK
(
'
Z
'
)
)
{
+
+
i
;
}
else
if
(
PEEK
(
'
+
'
)
|
|
PEEK
(
'
-
'
)
)
{
if
(
PEEK
(
'
-
'
)
)
{
tzMul
=
-
1
;
}
+
+
i
;
NEED_NDIGITS
(
2
tzHour
)
;
if
(
PEEK
(
'
:
'
)
)
{
+
+
i
;
}
NEED_NDIGITS
(
2
tzMin
)
;
}
else
{
isLocalTime
=
true
;
}
done
:
if
(
year
>
275943
|
|
month
=
=
0
|
|
month
>
12
|
|
day
=
=
0
|
|
day
>
31
|
|
hour
>
24
|
|
(
hour
=
=
24
&
&
(
min
>
0
|
|
sec
>
0
|
|
msec
>
0
)
)
|
|
min
>
59
|
|
sec
>
59
|
|
tzHour
>
23
|
|
tzMin
>
59
)
{
return
false
;
}
if
(
i
!
=
length
)
{
return
false
;
}
month
-
=
1
;
double
date
=
MakeDate
(
MakeDay
(
dateMul
*
double
(
year
)
month
day
)
MakeTime
(
hour
min
sec
msec
)
)
;
if
(
isLocalTime
)
{
date
=
UTC
(
forceUTC
date
)
;
}
else
{
date
-
=
tzMul
*
(
tzHour
*
msPerHour
+
tzMin
*
msPerMinute
)
;
}
*
result
=
TimeClip
(
date
)
;
return
NumbersAreIdentical
(
date
result
-
>
toDouble
(
)
)
;
#
undef
PEEK
#
undef
NEED
#
undef
DONE_UNLESS
#
undef
NEED_NDIGITS
}
int
FixupNonFullYear
(
int
year
)
{
if
(
year
<
50
)
{
year
+
=
2000
;
}
else
if
(
year
>
=
50
&
&
year
<
100
)
{
year
+
=
1900
;
}
return
year
;
}
template
<
typename
CharT
>
bool
IsPrefixOfKeyword
(
const
CharT
*
s
size_t
len
const
char
*
keyword
)
{
while
(
len
>
0
&
&
*
keyword
)
{
MOZ_ASSERT
(
IsAsciiAlpha
(
*
s
)
)
;
MOZ_ASSERT
(
IsAsciiLowercaseAlpha
(
*
keyword
)
)
;
if
(
unicode
:
:
ToLowerCase
(
static_cast
<
Latin1Char
>
(
*
s
)
)
!
=
*
keyword
)
{
break
;
}
s
+
+
keyword
+
+
;
len
-
-
;
}
return
len
=
=
0
;
}
template
<
typename
CharT
>
bool
MatchesKeyword
(
const
CharT
*
s
size_t
len
const
char
*
keyword
)
{
while
(
len
>
0
)
{
MOZ_ASSERT
(
IsAsciiAlpha
(
*
s
)
)
;
MOZ_ASSERT
(
IsAsciiLowercaseAlpha
(
*
keyword
)
|
|
*
keyword
=
=
'
\
0
'
)
;
if
(
unicode
:
:
ToLowerCase
(
static_cast
<
Latin1Char
>
(
*
s
)
)
!
=
*
keyword
)
{
return
false
;
}
+
+
s
+
+
keyword
;
-
-
len
;
}
return
*
keyword
=
=
'
\
0
'
;
}
static
constexpr
const
char
*
const
month_prefixes
[
]
=
{
"
jan
"
"
feb
"
"
mar
"
"
apr
"
"
may
"
"
jun
"
"
jul
"
"
aug
"
"
sep
"
"
oct
"
"
nov
"
"
dec
"
}
;
template
<
typename
CharT
>
bool
StartsWithMonthPrefix
(
const
CharT
*
s
const
char
*
prefix
)
{
MOZ_ASSERT
(
strlen
(
prefix
)
=
=
3
)
;
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
MOZ_ASSERT
(
IsAsciiAlpha
(
*
s
)
)
;
MOZ_ASSERT
(
IsAsciiLowercaseAlpha
(
*
prefix
)
)
;
if
(
unicode
:
:
ToLowerCase
(
static_cast
<
Latin1Char
>
(
*
s
)
)
!
=
*
prefix
)
{
return
false
;
}
+
+
s
+
+
prefix
;
}
return
true
;
}
template
<
typename
CharT
>
bool
IsMonthName
(
const
CharT
*
s
size_t
len
int
*
mon
)
{
if
(
len
<
3
)
{
return
false
;
}
for
(
size_t
m
=
0
;
m
<
std
:
:
size
(
month_prefixes
)
;
+
+
m
)
{
if
(
StartsWithMonthPrefix
(
s
month_prefixes
[
m
]
)
)
{
*
mon
=
m
+
1
;
return
true
;
}
}
return
false
;
}
template
<
typename
CharT
>
static
bool
TryParseDashedDatePrefix
(
const
CharT
*
s
size_t
length
size_t
*
indexOut
int
*
yearOut
int
*
monOut
int
*
mdayOut
)
{
size_t
i
=
*
indexOut
;
size_t
pre
=
i
;
size_t
mday
;
if
(
!
ParseDigitsNOrLess
(
6
&
mday
s
&
i
length
)
)
{
return
false
;
}
size_t
mdayDigits
=
i
-
pre
;
if
(
i
>
=
length
|
|
s
[
i
]
!
=
'
-
'
)
{
return
false
;
}
+
+
i
;
int
mon
=
0
;
if
(
*
monOut
=
=
-
1
)
{
size_t
start
=
i
;
for
(
;
i
<
length
;
i
+
+
)
{
if
(
!
IsAsciiAlpha
(
s
[
i
]
)
)
{
break
;
}
}
if
(
!
IsMonthName
(
s
+
start
i
-
start
&
mon
)
)
{
return
false
;
}
if
(
i
>
=
length
|
|
s
[
i
]
!
=
'
-
'
)
{
return
false
;
}
+
+
i
;
}
pre
=
i
;
size_t
year
;
if
(
!
ParseDigitsNOrLess
(
6
&
year
s
&
i
length
)
)
{
return
false
;
}
size_t
yearDigits
=
i
-
pre
;
if
(
i
<
length
&
&
IsAsciiDigit
(
s
[
i
]
)
)
{
return
false
;
}
if
(
mday
>
31
&
&
year
<
=
31
&
&
yearDigits
<
4
)
{
std
:
:
swap
(
mday
year
)
;
std
:
:
swap
(
mdayDigits
yearDigits
)
;
}
if
(
mday
>
31
|
|
mdayDigits
>
2
)
{
return
false
;
}
if
(
yearDigits
<
4
)
{
year
=
FixupNonFullYear
(
year
)
;
}
*
indexOut
=
i
;
*
yearOut
=
year
;
if
(
*
monOut
=
=
-
1
)
{
*
monOut
=
mon
;
}
*
mdayOut
=
mday
;
return
true
;
}
template
<
typename
CharT
>
static
bool
TryParseDashedNumericDatePrefix
(
const
CharT
*
s
size_t
length
size_t
*
indexOut
int
*
yearOut
int
*
monOut
int
*
mdayOut
)
{
size_t
i
=
*
indexOut
;
size_t
first
;
if
(
!
ParseDigitsNOrLess
(
6
&
first
s
&
i
length
)
)
{
return
false
;
}
if
(
i
>
=
length
|
|
s
[
i
]
!
=
'
-
'
)
{
return
false
;
}
+
+
i
;
size_t
second
;
if
(
!
ParseDigitsNOrLess
(
2
&
second
s
&
i
length
)
)
{
return
false
;
}
if
(
i
>
=
length
|
|
s
[
i
]
!
=
'
-
'
)
{
return
false
;
}
+
+
i
;
size_t
third
;
if
(
!
ParseDigitsNOrLess
(
6
&
third
s
&
i
length
)
)
{
return
false
;
}
int
year
;
int
mon
=
-
1
;
int
mday
=
-
1
;
if
(
first
>
=
1
&
&
first
<
=
12
)
{
mon
=
first
;
}
else
if
(
first
=
=
0
|
|
first
>
31
)
{
year
=
first
;
}
else
{
return
false
;
}
if
(
mon
<
0
)
{
mon
=
second
;
}
else
{
mday
=
second
;
}
if
(
mday
<
0
)
{
mday
=
third
;
}
else
{
year
=
third
;
}
if
(
mon
<
1
|
|
mon
>
12
|
|
mday
<
1
|
|
mday
>
31
)
{
return
false
;
}
if
(
year
<
100
)
{
year
=
FixupNonFullYear
(
year
)
;
}
*
indexOut
=
i
;
*
yearOut
=
year
;
*
monOut
=
mon
;
*
mdayOut
=
mday
;
return
true
;
}
struct
CharsAndAction
{
const
char
*
chars
;
int
action
;
}
;
static
constexpr
const
char
*
const
days_of_week
[
]
=
{
"
monday
"
"
tuesday
"
"
wednesday
"
"
thursday
"
"
friday
"
"
saturday
"
"
sunday
"
}
;
static
constexpr
CharsAndAction
keywords
[
]
=
{
{
"
am
"
-
1
}
{
"
pm
"
-
2
}
{
"
gmt
"
10000
+
0
}
{
"
z
"
10000
+
0
}
{
"
ut
"
10000
+
0
}
{
"
utc
"
10000
+
0
}
{
"
est
"
10000
+
5
*
60
}
{
"
edt
"
10000
+
4
*
60
}
{
"
cst
"
10000
+
6
*
60
}
{
"
cdt
"
10000
+
5
*
60
}
{
"
mst
"
10000
+
7
*
60
}
{
"
mdt
"
10000
+
6
*
60
}
{
"
pst
"
10000
+
8
*
60
}
{
"
pdt
"
10000
+
7
*
60
}
}
;
template
<
size_t
N
>
constexpr
size_t
MinKeywordLength
(
const
CharsAndAction
(
&
keywords
)
[
N
]
)
{
size_t
min
=
size_t
(
-
1
)
;
for
(
const
CharsAndAction
&
keyword
:
keywords
)
{
min
=
std
:
:
min
(
min
std
:
:
char_traits
<
char
>
:
:
length
(
keyword
.
chars
)
)
;
}
return
min
;
}
template
<
typename
CharT
>
static
bool
ParseDate
(
DateTimeInfo
:
:
ForceUTC
forceUTC
const
CharT
*
s
size_t
length
ClippedTime
*
result
bool
*
countLateWeekday
)
{
if
(
length
=
=
0
)
{
return
false
;
}
if
(
ParseISOStyleDate
(
forceUTC
s
length
result
)
)
{
return
true
;
}
size_t
index
=
0
;
int
mon
=
-
1
;
bool
seenMonthName
=
false
;
for
(
;
index
<
length
;
index
+
+
)
{
int
c
=
s
[
index
]
;
if
(
strchr
(
"
.
-
/
"
c
)
)
{
continue
;
}
if
(
!
IsAsciiAlpha
(
c
)
)
{
break
;
}
size_t
start
=
index
;
index
+
+
;
for
(
;
index
<
length
;
index
+
+
)
{
if
(
!
IsAsciiAlpha
(
s
[
index
]
)
)
{
break
;
}
}
if
(
index
>
=
length
)
{
return
false
;
}
if
(
IsMonthName
(
s
+
start
index
-
start
&
mon
)
)
{
seenMonthName
=
true
;
if
(
IsAsciiDigit
(
s
[
index
]
)
)
{
break
;
}
}
else
{
if
(
IsAsciiDigit
(
s
[
index
]
)
&
&
IsAsciiAlpha
(
s
[
index
-
1
]
)
)
{
return
false
;
}
}
}
int
year
=
-
1
;
int
mday
=
-
1
;
int
hour
=
-
1
;
int
min
=
-
1
;
int
sec
=
-
1
;
int
msec
=
0
;
int
tzOffset
=
-
1
;
int
prevc
=
0
;
bool
seenPlusMinus
=
false
;
bool
seenFullYear
=
false
;
bool
negativeYear
=
false
;
bool
seenGmtAbbr
=
false
;
bool
seenLateWeekday
=
false
;
bool
isDashedDate
=
TryParseDashedDatePrefix
(
s
length
&
index
&
year
&
mon
&
mday
)
|
|
TryParseDashedNumericDatePrefix
(
s
length
&
index
&
year
&
mon
&
mday
)
;
if
(
isDashedDate
&
&
index
<
length
&
&
strchr
(
"
T
:
+
"
s
[
index
]
)
)
{
return
false
;
}
while
(
index
<
length
)
{
int
c
=
s
[
index
]
;
index
+
+
;
if
(
c
=
=
0x202F
)
{
c
=
'
'
;
}
if
(
(
c
=
=
'
+
'
|
|
c
=
=
'
-
'
)
&
&
(
(
seenPlusMinus
&
&
year
!
=
-
1
)
|
|
(
year
!
=
-
1
&
&
hour
=
=
-
1
&
&
!
seenGmtAbbr
&
&
!
IsAsciiDigit
(
s
[
index
-
2
]
)
)
)
)
{
return
false
;
}
if
(
c
<
=
'
'
|
|
c
=
=
'
.
'
|
|
c
=
=
'
'
)
{
continue
;
}
if
(
c
=
=
'
/
'
|
|
c
=
=
'
:
'
|
|
c
=
=
'
+
'
)
{
prevc
=
c
;
continue
;
}
if
(
c
=
=
'
-
'
)
{
if
(
index
<
length
&
&
IsAsciiDigit
(
s
[
index
]
)
)
{
prevc
=
c
;
}
continue
;
}
if
(
c
=
=
'
(
'
)
{
int
depth
=
1
;
while
(
index
<
length
)
{
c
=
s
[
index
]
;
index
+
+
;
if
(
c
=
=
'
(
'
)
{
depth
+
+
;
}
else
if
(
c
=
=
'
)
'
)
{
if
(
-
-
depth
<
=
0
)
{
break
;
}
}
}
continue
;
}
if
(
IsAsciiDigit
(
c
)
)
{
size_t
partStart
=
index
-
1
;
uint32_t
u
=
c
-
'
0
'
;
while
(
index
<
length
)
{
c
=
s
[
index
]
;
if
(
!
IsAsciiDigit
(
c
)
)
{
break
;
}
u
=
u
*
10
+
(
c
-
'
0
'
)
;
index
+
+
;
}
size_t
partLength
=
index
-
partStart
;
if
(
c
=
=
0x202F
)
{
c
=
'
'
;
}
int
n
=
int
(
u
)
;
if
(
prevc
=
=
'
-
'
&
&
(
tzOffset
!
=
0
|
|
seenPlusMinus
)
&
&
partLength
>
=
4
&
&
year
<
0
)
{
year
=
n
;
seenFullYear
=
true
;
negativeYear
=
true
;
}
else
if
(
(
prevc
=
=
'
+
'
|
|
prevc
=
=
'
-
'
)
&
&
(
seenGmtAbbr
|
|
hour
!
=
-
1
)
)
{
seenPlusMinus
=
true
;
if
(
n
<
24
&
&
partLength
<
=
2
)
{
n
=
n
*
60
;
}
else
{
n
=
n
%
100
+
n
/
100
*
60
;
}
if
(
prevc
=
=
'
+
'
)
n
=
-
n
;
if
(
tzOffset
!
=
0
&
&
tzOffset
!
=
-
1
)
{
return
false
;
}
tzOffset
=
n
;
}
else
if
(
prevc
=
=
'
/
'
&
&
mon
>
=
0
&
&
mday
>
=
0
&
&
year
<
0
)
{
if
(
c
<
=
'
'
|
|
c
=
=
'
'
|
|
c
=
=
'
/
'
|
|
index
>
=
length
)
{
year
=
n
;
}
else
{
return
false
;
}
}
else
if
(
c
=
=
'
:
'
)
{
if
(
hour
<
0
)
{
hour
=
n
;
}
else
if
(
min
<
0
)
{
min
=
n
;
}
else
{
return
false
;
}
}
else
if
(
c
=
=
'
/
'
)
{
if
(
mon
<
0
)
{
mon
=
n
;
}
else
if
(
mday
<
0
)
{
mday
=
n
;
}
else
{
return
false
;
}
}
else
if
(
index
<
length
&
&
c
!
=
'
'
&
&
c
>
'
'
&
&
c
!
=
'
-
'
&
&
c
!
=
'
(
'
&
&
(
c
!
=
'
.
'
|
|
sec
!
=
-
1
)
&
&
!
(
hour
!
=
-
1
&
&
strchr
(
"
Zz
+
"
c
)
)
&
&
(
!
IsAsciiAlpha
(
c
)
|
|
(
mon
!
=
-
1
&
&
!
(
strchr
(
"
AaPp
"
c
)
&
&
index
<
length
-
1
&
&
strchr
(
"
Mm
"
s
[
index
+
1
]
)
)
)
)
)
{
return
false
;
}
else
if
(
seenPlusMinus
&
&
n
<
60
)
{
if
(
tzOffset
<
0
)
{
tzOffset
-
=
n
;
}
else
{
tzOffset
+
=
n
;
}
}
else
if
(
hour
>
=
0
&
&
min
<
0
)
{
min
=
n
;
}
else
if
(
prevc
=
=
'
:
'
&
&
min
>
=
0
&
&
sec
<
0
)
{
sec
=
n
;
if
(
c
=
=
'
.
'
)
{
index
+
+
;
if
(
!
ParseFractional
(
&
msec
s
&
index
length
)
)
{
return
false
;
}
}
}
else
if
(
mon
<
0
)
{
mon
=
n
;
}
else
if
(
mon
>
=
0
&
&
mday
<
0
)
{
mday
=
n
;
}
else
if
(
mon
>
=
0
&
&
mday
>
=
0
&
&
year
<
0
)
{
year
=
n
;
seenFullYear
=
partLength
>
=
4
;
}
else
{
return
false
;
}
prevc
=
0
;
continue
;
}
if
(
IsAsciiAlpha
(
c
)
)
{
size_t
start
=
index
-
1
;
while
(
index
<
length
)
{
c
=
s
[
index
]
;
if
(
!
IsAsciiAlpha
(
c
)
)
{
break
;
}
index
+
+
;
}
constexpr
size_t
MinLength
=
MinKeywordLength
(
keywords
)
;
if
(
index
-
start
<
MinLength
)
{
return
false
;
}
bool
isLateWeekday
=
false
;
for
(
const
char
*
weekday
:
days_of_week
)
{
if
(
IsPrefixOfKeyword
(
s
+
start
index
-
start
weekday
)
)
{
isLateWeekday
=
true
;
seenLateWeekday
=
true
;
break
;
}
}
if
(
isLateWeekday
)
{
prevc
=
0
;
continue
;
}
int
tryMonth
;
if
(
IsMonthName
(
s
+
start
index
-
start
&
tryMonth
)
)
{
if
(
seenMonthName
)
{
mon
=
tryMonth
;
prevc
=
0
;
continue
;
}
seenMonthName
=
true
;
if
(
mon
<
0
)
{
mon
=
tryMonth
;
}
else
if
(
mday
<
0
)
{
mday
=
mon
;
mon
=
tryMonth
;
}
else
if
(
year
<
0
)
{
if
(
mday
>
0
)
{
year
=
mday
;
mday
=
mon
;
}
else
{
year
=
mon
;
}
mon
=
tryMonth
;
}
else
{
return
false
;
}
prevc
=
0
;
continue
;
}
size_t
k
=
std
:
:
size
(
keywords
)
;
while
(
k
-
-
>
0
)
{
const
CharsAndAction
&
keyword
=
keywords
[
k
]
;
if
(
!
MatchesKeyword
(
s
+
start
index
-
start
keyword
.
chars
)
)
{
continue
;
}
int
action
=
keyword
.
action
;
if
(
action
=
=
10000
)
{
seenGmtAbbr
=
true
;
}
if
(
action
<
0
)
{
MOZ_ASSERT
(
action
=
=
-
1
|
|
action
=
=
-
2
)
;
if
(
hour
>
12
|
|
hour
<
0
)
{
return
false
;
}
if
(
action
=
=
-
1
&
&
hour
=
=
12
)
{
hour
=
0
;
}
else
if
(
action
=
=
-
2
&
&
hour
!
=
12
)
{
hour
+
=
12
;
}
break
;
}
MOZ_ASSERT
(
action
>
=
10000
)
;
tzOffset
=
action
-
10000
;
break
;
}
if
(
k
=
=
size_t
(
-
1
)
)
{
return
false
;
}
prevc
=
0
;
continue
;
}
return
false
;
}
if
(
mon
!
=
-
1
&
&
year
<
0
&
&
mday
<
0
)
{
if
(
mon
>
=
13
&
&
mon
<
=
31
)
{
return
false
;
}
mday
=
1
;
if
(
mon
>
=
1
&
&
mon
<
=
12
)
{
year
=
2001
;
}
else
{
year
=
FixupNonFullYear
(
mon
)
;
mon
=
1
;
}
}
if
(
year
<
0
|
|
mon
<
0
|
|
mday
<
0
)
{
return
false
;
}
if
(
!
isDashedDate
)
{
if
(
seenMonthName
)
{
if
(
mday
>
=
100
&
&
mon
>
=
100
)
{
return
false
;
}
if
(
year
>
0
&
&
(
mday
=
=
0
|
|
mday
>
31
)
&
&
!
seenFullYear
)
{
int
temp
=
year
;
year
=
mday
;
mday
=
temp
;
}
if
(
mday
<
=
0
|
|
mday
>
31
)
{
return
false
;
}
}
else
if
(
0
<
mon
&
&
mon
<
=
12
&
&
0
<
mday
&
&
mday
<
=
31
)
{
}
else
{
if
(
mon
>
31
&
&
mday
<
=
12
&
&
year
<
=
31
&
&
!
seenFullYear
)
{
int
temp
=
year
;
year
=
mon
;
mon
=
mday
;
mday
=
temp
;
}
else
{
return
false
;
}
}
if
(
!
seenFullYear
)
{
year
=
FixupNonFullYear
(
year
)
;
}
if
(
negativeYear
)
{
year
=
-
year
;
}
}
mon
-
=
1
;
if
(
sec
<
0
)
{
sec
=
0
;
}
if
(
min
<
0
)
{
min
=
0
;
}
if
(
hour
<
0
)
{
hour
=
0
;
}
double
date
=
MakeDate
(
MakeDay
(
year
mon
mday
)
MakeTime
(
hour
min
sec
msec
)
)
;
if
(
tzOffset
=
=
-
1
)
{
date
=
UTC
(
forceUTC
date
)
;
}
else
{
date
+
=
tzOffset
*
msPerMinute
;
}
if
(
seenLateWeekday
)
{
*
countLateWeekday
=
true
;
}
*
result
=
TimeClip
(
date
)
;
return
true
;
}
static
bool
ParseDate
(
DateTimeInfo
:
:
ForceUTC
forceUTC
JSLinearString
*
s
ClippedTime
*
result
JSContext
*
cx
)
{
bool
countLateWeekday
=
false
;
bool
success
;
{
AutoCheckCannotGC
nogc
;
success
=
s
-
>
hasLatin1Chars
(
)
?
ParseDate
(
forceUTC
s
-
>
latin1Chars
(
nogc
)
s
-
>
length
(
)
result
&
countLateWeekday
)
:
ParseDate
(
forceUTC
s
-
>
twoByteChars
(
nogc
)
s
-
>
length
(
)
result
&
countLateWeekday
)
;
}
if
(
countLateWeekday
)
{
cx
-
>
runtime
(
)
-
>
setUseCounter
(
cx
-
>
global
(
)
JSUseCounter
:
:
LATE_WEEKDAY
)
;
if
(
!
cx
-
>
realm
(
)
-
>
warnedAboutDateLateWeekday
)
{
if
(
!
WarnNumberASCII
(
cx
JSMSG_DEPRECATED_LATE_WEEKDAY
)
)
{
if
(
cx
-
>
isExceptionPending
(
)
)
{
cx
-
>
clearPendingException
(
)
;
}
}
cx
-
>
realm
(
)
-
>
warnedAboutDateLateWeekday
=
true
;
}
}
return
success
;
}
static
bool
date_parse
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSMethodProfilerEntry
pseudoFrame
(
cx
"
Date
"
"
parse
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
args
.
length
(
)
=
=
0
)
{
args
.
rval
(
)
.
setNaN
(
)
;
return
true
;
}
JSString
*
str
=
ToString
<
CanGC
>
(
cx
args
[
0
]
)
;
if
(
!
str
)
{
return
false
;
}
JSLinearString
*
linearStr
=
str
-
>
ensureLinear
(
cx
)
;
if
(
!
linearStr
)
{
return
false
;
}
ClippedTime
result
;
if
(
!
ParseDate
(
ForceUTC
(
cx
-
>
realm
(
)
)
linearStr
&
result
cx
)
)
{
args
.
rval
(
)
.
setNaN
(
)
;
return
true
;
}
args
.
rval
(
)
.
set
(
TimeValue
(
result
)
)
;
return
true
;
}
static
ClippedTime
NowAsMillis
(
JSContext
*
cx
)
{
if
(
js
:
:
SupportDifferentialTesting
(
)
)
{
return
TimeClip
(
0
)
;
}
double
now
=
PRMJ_Now
(
)
;
bool
clampAndJitter
=
cx
-
>
realm
(
)
-
>
behaviors
(
)
.
clampAndJitterTime
(
)
;
if
(
clampAndJitter
&
&
sReduceMicrosecondTimePrecisionCallback
)
{
now
=
sReduceMicrosecondTimePrecisionCallback
(
now
cx
-
>
realm
(
)
-
>
behaviors
(
)
.
reduceTimerPrecisionCallerType
(
)
.
value
(
)
cx
)
;
}
else
if
(
clampAndJitter
&
&
sResolutionUsec
)
{
double
clamped
=
floor
(
now
/
sResolutionUsec
)
*
sResolutionUsec
;
if
(
sJitter
)
{
uint64_t
midpoint
=
BitwiseCast
<
uint64_t
>
(
clamped
)
;
midpoint
^
=
0x0F00DD1E2BAD2DED
;
midpoint
^
=
midpoint
>
>
33
;
midpoint
*
=
uint64_t
{
0xFF51AFD7ED558CCD
}
;
midpoint
^
=
midpoint
>
>
33
;
midpoint
*
=
uint64_t
{
0xC4CEB9FE1A85EC53
}
;
midpoint
^
=
midpoint
>
>
33
;
midpoint
%
=
sResolutionUsec
;
if
(
now
>
clamped
+
midpoint
)
{
now
=
clamped
+
sResolutionUsec
;
}
else
{
now
=
clamped
;
}
}
else
{
now
=
clamped
;
}
}
return
TimeClip
(
now
/
PRMJ_USEC_PER_MSEC
)
;
}
JS
:
:
ClippedTime
js
:
:
DateNow
(
JSContext
*
cx
)
{
return
NowAsMillis
(
cx
)
;
}
bool
js
:
:
date_now
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSMethodProfilerEntry
pseudoFrame
(
cx
"
Date
"
"
now
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
set
(
TimeValue
(
NowAsMillis
(
cx
)
)
)
;
return
true
;
}
DateTimeInfo
:
:
ForceUTC
DateObject
:
:
forceUTC
(
)
const
{
return
ForceUTC
(
realm
(
)
)
;
}
void
DateObject
:
:
setUTCTime
(
ClippedTime
t
)
{
for
(
size_t
ind
=
COMPONENTS_START_SLOT
;
ind
<
RESERVED_SLOTS
;
ind
+
+
)
{
setReservedSlot
(
ind
UndefinedValue
(
)
)
;
}
setFixedSlot
(
UTC_TIME_SLOT
TimeValue
(
t
)
)
;
}
void
DateObject
:
:
setUTCTime
(
ClippedTime
t
MutableHandleValue
vp
)
{
setUTCTime
(
t
)
;
vp
.
set
(
TimeValue
(
t
)
)
;
}
void
DateObject
:
:
fillLocalTimeSlots
(
)
{
const
int32_t
utcTZOffset
=
DateTimeInfo
:
:
utcToLocalStandardOffsetSeconds
(
forceUTC
(
)
)
;
if
(
!
getReservedSlot
(
LOCAL_TIME_SLOT
)
.
isUndefined
(
)
&
&
getReservedSlot
(
UTC_TIME_ZONE_OFFSET_SLOT
)
.
toInt32
(
)
=
=
utcTZOffset
)
{
return
;
}
setReservedSlot
(
UTC_TIME_ZONE_OFFSET_SLOT
Int32Value
(
utcTZOffset
)
)
;
double
utcTime
=
UTCTime
(
)
.
toNumber
(
)
;
if
(
!
std
:
:
isfinite
(
utcTime
)
)
{
for
(
size_t
ind
=
COMPONENTS_START_SLOT
;
ind
<
RESERVED_SLOTS
;
ind
+
+
)
{
setReservedSlot
(
ind
DoubleValue
(
utcTime
)
)
;
}
return
;
}
double
localTime
=
LocalTime
(
forceUTC
(
)
utcTime
)
;
setReservedSlot
(
LOCAL_TIME_SLOT
DoubleValue
(
localTime
)
)
;
const
auto
[
year
month
day
]
=
ToYearMonthDay
(
localTime
)
;
setReservedSlot
(
LOCAL_YEAR_SLOT
Int32Value
(
year
)
)
;
setReservedSlot
(
LOCAL_MONTH_SLOT
Int32Value
(
int32_t
(
month
)
)
)
;
setReservedSlot
(
LOCAL_DATE_SLOT
Int32Value
(
int32_t
(
day
)
)
)
;
int
weekday
=
WeekDay
(
localTime
)
;
setReservedSlot
(
LOCAL_DAY_SLOT
Int32Value
(
weekday
)
)
;
double
yearStartTime
=
TimeFromYear
(
year
)
;
uint64_t
yearTime
=
uint64_t
(
localTime
-
yearStartTime
)
;
int32_t
yearSeconds
=
int32_t
(
yearTime
/
1000
)
;
setReservedSlot
(
LOCAL_SECONDS_INTO_YEAR_SLOT
Int32Value
(
yearSeconds
)
)
;
}
MOZ_ALWAYS_INLINE
bool
IsDate
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
DateObject
>
(
)
;
}
static
bool
date_getTime
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getTime
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
unwrapped
-
>
UTCTime
(
)
)
;
return
true
;
}
static
bool
date_getYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getYear
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
unwrapped
-
>
fillLocalTimeSlots
(
)
;
Value
yearVal
=
unwrapped
-
>
localYear
(
)
;
if
(
yearVal
.
isInt32
(
)
)
{
int
year
=
yearVal
.
toInt32
(
)
-
1900
;
args
.
rval
(
)
.
setInt32
(
year
)
;
}
else
{
args
.
rval
(
)
.
set
(
yearVal
)
;
}
return
true
;
}
static
bool
date_getFullYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getFullYear
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
unwrapped
-
>
fillLocalTimeSlots
(
)
;
args
.
rval
(
)
.
set
(
unwrapped
-
>
localYear
(
)
)
;
return
true
;
}
static
bool
date_getUTCFullYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getUTCFullYear
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
result
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
if
(
std
:
:
isfinite
(
result
)
)
{
result
=
YearFromTime
(
result
)
;
}
args
.
rval
(
)
.
setNumber
(
result
)
;
return
true
;
}
static
bool
date_getMonth
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getMonth
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
unwrapped
-
>
fillLocalTimeSlots
(
)
;
args
.
rval
(
)
.
set
(
unwrapped
-
>
localMonth
(
)
)
;
return
true
;
}
static
bool
date_getUTCMonth
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getUTCMonth
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
d
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
args
.
rval
(
)
.
setNumber
(
MonthFromTime
(
d
)
)
;
return
true
;
}
static
bool
date_getDate
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getDate
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
unwrapped
-
>
fillLocalTimeSlots
(
)
;
args
.
rval
(
)
.
set
(
unwrapped
-
>
localDate
(
)
)
;
return
true
;
}
static
bool
date_getUTCDate
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getUTCDate
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
result
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
if
(
std
:
:
isfinite
(
result
)
)
{
result
=
DateFromTime
(
result
)
;
}
args
.
rval
(
)
.
setNumber
(
result
)
;
return
true
;
}
static
bool
date_getDay
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getDay
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
unwrapped
-
>
fillLocalTimeSlots
(
)
;
args
.
rval
(
)
.
set
(
unwrapped
-
>
localDay
(
)
)
;
return
true
;
}
static
bool
date_getUTCDay
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getUTCDay
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
result
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
if
(
std
:
:
isfinite
(
result
)
)
{
result
=
WeekDay
(
result
)
;
}
args
.
rval
(
)
.
setNumber
(
result
)
;
return
true
;
}
static
bool
date_getHours
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getHours
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
unwrapped
-
>
fillLocalTimeSlots
(
)
;
Value
yearSeconds
=
unwrapped
-
>
localSecondsIntoYear
(
)
;
if
(
yearSeconds
.
isDouble
(
)
)
{
MOZ_ASSERT
(
std
:
:
isnan
(
yearSeconds
.
toDouble
(
)
)
)
;
args
.
rval
(
)
.
set
(
yearSeconds
)
;
}
else
{
args
.
rval
(
)
.
setInt32
(
(
yearSeconds
.
toInt32
(
)
/
int
(
SecondsPerHour
)
)
%
int
(
HoursPerDay
)
)
;
}
return
true
;
}
static
bool
date_getUTCHours
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getUTCHours
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
result
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
if
(
std
:
:
isfinite
(
result
)
)
{
result
=
HourFromTime
(
result
)
;
}
args
.
rval
(
)
.
setNumber
(
result
)
;
return
true
;
}
static
bool
date_getMinutes
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getMinutes
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
unwrapped
-
>
fillLocalTimeSlots
(
)
;
Value
yearSeconds
=
unwrapped
-
>
localSecondsIntoYear
(
)
;
if
(
yearSeconds
.
isDouble
(
)
)
{
MOZ_ASSERT
(
std
:
:
isnan
(
yearSeconds
.
toDouble
(
)
)
)
;
args
.
rval
(
)
.
set
(
yearSeconds
)
;
}
else
{
args
.
rval
(
)
.
setInt32
(
(
yearSeconds
.
toInt32
(
)
/
int
(
SecondsPerMinute
)
)
%
int
(
MinutesPerHour
)
)
;
}
return
true
;
}
static
bool
date_getUTCMinutes
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getUTCMinutes
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
result
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
if
(
std
:
:
isfinite
(
result
)
)
{
result
=
MinFromTime
(
result
)
;
}
args
.
rval
(
)
.
setNumber
(
result
)
;
return
true
;
}
static
bool
date_getSeconds
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getSeconds
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
unwrapped
-
>
fillLocalTimeSlots
(
)
;
Value
yearSeconds
=
unwrapped
-
>
localSecondsIntoYear
(
)
;
if
(
yearSeconds
.
isDouble
(
)
)
{
MOZ_ASSERT
(
std
:
:
isnan
(
yearSeconds
.
toDouble
(
)
)
)
;
args
.
rval
(
)
.
set
(
yearSeconds
)
;
}
else
{
args
.
rval
(
)
.
setInt32
(
yearSeconds
.
toInt32
(
)
%
int
(
SecondsPerMinute
)
)
;
}
return
true
;
}
static
bool
date_getUTCSeconds
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getUTCSeconds
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
result
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
if
(
std
:
:
isfinite
(
result
)
)
{
result
=
SecFromTime
(
result
)
;
}
args
.
rval
(
)
.
setNumber
(
result
)
;
return
true
;
}
static
bool
getMilliseconds
(
JSContext
*
cx
unsigned
argc
Value
*
vp
const
char
*
methodName
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
methodName
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
result
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
if
(
std
:
:
isfinite
(
result
)
)
{
result
=
msFromTime
(
result
)
;
}
args
.
rval
(
)
.
setNumber
(
result
)
;
return
true
;
}
static
bool
date_getMilliseconds
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
return
getMilliseconds
(
cx
argc
vp
"
getMilliseconds
"
)
;
}
static
bool
date_getUTCMilliseconds
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
return
getMilliseconds
(
cx
argc
vp
"
getUTCMilliseconds
"
)
;
}
static
bool
date_getTimezoneOffset
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
getTimezoneOffset
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
unwrapped
-
>
fillLocalTimeSlots
(
)
;
double
utctime
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
double
localtime
=
unwrapped
-
>
localTime
(
)
.
toDouble
(
)
;
double
result
=
(
utctime
-
localtime
)
/
msPerMinute
;
args
.
rval
(
)
.
setNumber
(
result
)
;
return
true
;
}
static
bool
date_setTime
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setTime
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
if
(
args
.
length
(
)
=
=
0
)
{
unwrapped
-
>
setUTCTime
(
ClippedTime
:
:
invalid
(
)
args
.
rval
(
)
)
;
return
true
;
}
double
result
;
if
(
!
ToNumber
(
cx
args
[
0
]
&
result
)
)
{
return
false
;
}
unwrapped
-
>
setUTCTime
(
TimeClip
(
result
)
args
.
rval
(
)
)
;
return
true
;
}
static
bool
GetMsecsOrDefault
(
JSContext
*
cx
const
CallArgs
&
args
unsigned
i
double
t
double
*
millis
)
{
if
(
args
.
length
(
)
<
=
i
)
{
*
millis
=
msFromTime
(
t
)
;
return
true
;
}
return
ToNumber
(
cx
args
[
i
]
millis
)
;
}
static
bool
GetSecsOrDefault
(
JSContext
*
cx
const
CallArgs
&
args
unsigned
i
double
t
double
*
sec
)
{
if
(
args
.
length
(
)
<
=
i
)
{
*
sec
=
SecFromTime
(
t
)
;
return
true
;
}
return
ToNumber
(
cx
args
[
i
]
sec
)
;
}
static
bool
GetMinsOrDefault
(
JSContext
*
cx
const
CallArgs
&
args
unsigned
i
double
t
double
*
mins
)
{
if
(
args
.
length
(
)
<
=
i
)
{
*
mins
=
MinFromTime
(
t
)
;
return
true
;
}
return
ToNumber
(
cx
args
[
i
]
mins
)
;
}
static
bool
date_setMilliseconds
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setMilliseconds
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
LocalTime
(
unwrapped
-
>
forceUTC
(
)
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
)
;
double
ms
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
ms
)
)
{
return
false
;
}
double
time
=
MakeTime
(
HourFromTime
(
t
)
MinFromTime
(
t
)
SecFromTime
(
t
)
ms
)
;
ClippedTime
u
=
TimeClip
(
UTC
(
unwrapped
-
>
forceUTC
(
)
MakeDate
(
Day
(
t
)
time
)
)
)
;
unwrapped
-
>
setUTCTime
(
u
args
.
rval
(
)
)
;
return
true
;
}
static
bool
date_setUTCMilliseconds
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setUTCMilliseconds
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
double
milli
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
milli
)
)
{
return
false
;
}
double
time
=
MakeTime
(
HourFromTime
(
t
)
MinFromTime
(
t
)
SecFromTime
(
t
)
milli
)
;
ClippedTime
v
=
TimeClip
(
MakeDate
(
Day
(
t
)
time
)
)
;
unwrapped
-
>
setUTCTime
(
v
args
.
rval
(
)
)
;
return
true
;
}
static
bool
date_setSeconds
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setSeconds
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
LocalTime
(
unwrapped
-
>
forceUTC
(
)
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
)
;
double
s
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
s
)
)
{
return
false
;
}
double
milli
;
if
(
!
GetMsecsOrDefault
(
cx
args
1
t
&
milli
)
)
{
return
false
;
}
double
date
=
MakeDate
(
Day
(
t
)
MakeTime
(
HourFromTime
(
t
)
MinFromTime
(
t
)
s
milli
)
)
;
ClippedTime
u
=
TimeClip
(
UTC
(
unwrapped
-
>
forceUTC
(
)
date
)
)
;
unwrapped
-
>
setUTCTime
(
u
args
.
rval
(
)
)
;
return
true
;
}
static
bool
date_setUTCSeconds
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setUTCSeconds
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
double
s
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
s
)
)
{
return
false
;
}
double
milli
;
if
(
!
GetMsecsOrDefault
(
cx
args
1
t
&
milli
)
)
{
return
false
;
}
double
date
=
MakeDate
(
Day
(
t
)
MakeTime
(
HourFromTime
(
t
)
MinFromTime
(
t
)
s
milli
)
)
;
ClippedTime
v
=
TimeClip
(
date
)
;
unwrapped
-
>
setUTCTime
(
v
args
.
rval
(
)
)
;
return
true
;
}
static
bool
date_setMinutes
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setMinutes
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
LocalTime
(
unwrapped
-
>
forceUTC
(
)
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
)
;
double
m
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
m
)
)
{
return
false
;
}
double
s
;
if
(
!
GetSecsOrDefault
(
cx
args
1
t
&
s
)
)
{
return
false
;
}
double
milli
;
if
(
!
GetMsecsOrDefault
(
cx
args
2
t
&
milli
)
)
{
return
false
;
}
double
date
=
MakeDate
(
Day
(
t
)
MakeTime
(
HourFromTime
(
t
)
m
s
milli
)
)
;
ClippedTime
u
=
TimeClip
(
UTC
(
unwrapped
-
>
forceUTC
(
)
date
)
)
;
unwrapped
-
>
setUTCTime
(
u
args
.
rval
(
)
)
;
return
true
;
}
static
bool
date_setUTCMinutes
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setUTCMinutes
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
double
m
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
m
)
)
{
return
false
;
}
double
s
;
if
(
!
GetSecsOrDefault
(
cx
args
1
t
&
s
)
)
{
return
false
;
}
double
milli
;
if
(
!
GetMsecsOrDefault
(
cx
args
2
t
&
milli
)
)
{
return
false
;
}
double
date
=
MakeDate
(
Day
(
t
)
MakeTime
(
HourFromTime
(
t
)
m
s
milli
)
)
;
ClippedTime
v
=
TimeClip
(
date
)
;
unwrapped
-
>
setUTCTime
(
v
args
.
rval
(
)
)
;
return
true
;
}
static
bool
date_setHours
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setHours
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
LocalTime
(
unwrapped
-
>
forceUTC
(
)
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
)
;
double
h
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
h
)
)
{
return
false
;
}
double
m
;
if
(
!
GetMinsOrDefault
(
cx
args
1
t
&
m
)
)
{
return
false
;
}
double
s
;
if
(
!
GetSecsOrDefault
(
cx
args
2
t
&
s
)
)
{
return
false
;
}
double
milli
;
if
(
!
GetMsecsOrDefault
(
cx
args
3
t
&
milli
)
)
{
return
false
;
}
double
date
=
MakeDate
(
Day
(
t
)
MakeTime
(
h
m
s
milli
)
)
;
ClippedTime
u
=
TimeClip
(
UTC
(
unwrapped
-
>
forceUTC
(
)
date
)
)
;
unwrapped
-
>
setUTCTime
(
u
args
.
rval
(
)
)
;
return
true
;
}
static
bool
date_setUTCHours
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setUTCHours
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
double
h
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
h
)
)
{
return
false
;
}
double
m
;
if
(
!
GetMinsOrDefault
(
cx
args
1
t
&
m
)
)
{
return
false
;
}
double
s
;
if
(
!
GetSecsOrDefault
(
cx
args
2
t
&
s
)
)
{
return
false
;
}
double
milli
;
if
(
!
GetMsecsOrDefault
(
cx
args
3
t
&
milli
)
)
{
return
false
;
}
double
newDate
=
MakeDate
(
Day
(
t
)
MakeTime
(
h
m
s
milli
)
)
;
ClippedTime
v
=
TimeClip
(
newDate
)
;
unwrapped
-
>
setUTCTime
(
v
args
.
rval
(
)
)
;
return
true
;
}
static
bool
date_setDate
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setDate
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
LocalTime
(
unwrapped
-
>
forceUTC
(
)
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
)
;
double
date
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
double
newDate
=
MakeDate
(
MakeDay
(
YearFromTime
(
t
)
MonthFromTime
(
t
)
date
)
TimeWithinDay
(
t
)
)
;
ClippedTime
u
=
TimeClip
(
UTC
(
unwrapped
-
>
forceUTC
(
)
newDate
)
)
;
unwrapped
-
>
setUTCTime
(
u
args
.
rval
(
)
)
;
return
true
;
}
static
bool
date_setUTCDate
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setUTCDate
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
double
date
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
date
)
)
{
return
false
;
}
double
newDate
=
MakeDate
(
MakeDay
(
YearFromTime
(
t
)
MonthFromTime
(
t
)
date
)
TimeWithinDay
(
t
)
)
;
ClippedTime
v
=
TimeClip
(
newDate
)
;
unwrapped
-
>
setUTCTime
(
v
args
.
rval
(
)
)
;
return
true
;
}
static
bool
GetDateOrDefault
(
JSContext
*
cx
const
CallArgs
&
args
unsigned
i
double
t
double
*
date
)
{
if
(
args
.
length
(
)
<
=
i
)
{
*
date
=
DateFromTime
(
t
)
;
return
true
;
}
return
ToNumber
(
cx
args
[
i
]
date
)
;
}
static
bool
GetMonthOrDefault
(
JSContext
*
cx
const
CallArgs
&
args
unsigned
i
double
t
double
*
month
)
{
if
(
args
.
length
(
)
<
=
i
)
{
*
month
=
MonthFromTime
(
t
)
;
return
true
;
}
return
ToNumber
(
cx
args
[
i
]
month
)
;
}
static
bool
date_setMonth
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setMonth
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
LocalTime
(
unwrapped
-
>
forceUTC
(
)
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
)
;
double
m
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
m
)
)
{
return
false
;
}
double
date
;
if
(
!
GetDateOrDefault
(
cx
args
1
t
&
date
)
)
{
return
false
;
}
double
newDate
=
MakeDate
(
MakeDay
(
YearFromTime
(
t
)
m
date
)
TimeWithinDay
(
t
)
)
;
ClippedTime
u
=
TimeClip
(
UTC
(
unwrapped
-
>
forceUTC
(
)
newDate
)
)
;
unwrapped
-
>
setUTCTime
(
u
args
.
rval
(
)
)
;
return
true
;
}
static
bool
date_setUTCMonth
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setUTCMonth
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
double
m
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
m
)
)
{
return
false
;
}
double
date
;
if
(
!
GetDateOrDefault
(
cx
args
1
t
&
date
)
)
{
return
false
;
}
double
newDate
=
MakeDate
(
MakeDay
(
YearFromTime
(
t
)
m
date
)
TimeWithinDay
(
t
)
)
;
ClippedTime
v
=
TimeClip
(
newDate
)
;
unwrapped
-
>
setUTCTime
(
v
args
.
rval
(
)
)
;
return
true
;
}
static
double
ThisLocalTimeOrZero
(
DateTimeInfo
:
:
ForceUTC
forceUTC
Handle
<
DateObject
*
>
dateObj
)
{
double
t
=
dateObj
-
>
UTCTime
(
)
.
toNumber
(
)
;
if
(
std
:
:
isnan
(
t
)
)
{
return
+
0
;
}
return
LocalTime
(
forceUTC
t
)
;
}
static
double
ThisUTCTimeOrZero
(
Handle
<
DateObject
*
>
dateObj
)
{
double
t
=
dateObj
-
>
as
<
DateObject
>
(
)
.
UTCTime
(
)
.
toNumber
(
)
;
return
std
:
:
isnan
(
t
)
?
+
0
:
t
;
}
static
bool
date_setFullYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setFullYear
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
ThisLocalTimeOrZero
(
unwrapped
-
>
forceUTC
(
)
unwrapped
)
;
double
y
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
y
)
)
{
return
false
;
}
double
m
;
if
(
!
GetMonthOrDefault
(
cx
args
1
t
&
m
)
)
{
return
false
;
}
double
date
;
if
(
!
GetDateOrDefault
(
cx
args
2
t
&
date
)
)
{
return
false
;
}
double
newDate
=
MakeDate
(
MakeDay
(
y
m
date
)
TimeWithinDay
(
t
)
)
;
ClippedTime
u
=
TimeClip
(
UTC
(
unwrapped
-
>
forceUTC
(
)
newDate
)
)
;
unwrapped
-
>
setUTCTime
(
u
args
.
rval
(
)
)
;
return
true
;
}
static
bool
date_setUTCFullYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setUTCFullYear
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
ThisUTCTimeOrZero
(
unwrapped
)
;
double
y
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
y
)
)
{
return
false
;
}
double
m
;
if
(
!
GetMonthOrDefault
(
cx
args
1
t
&
m
)
)
{
return
false
;
}
double
date
;
if
(
!
GetDateOrDefault
(
cx
args
2
t
&
date
)
)
{
return
false
;
}
double
newDate
=
MakeDate
(
MakeDay
(
y
m
date
)
TimeWithinDay
(
t
)
)
;
ClippedTime
v
=
TimeClip
(
newDate
)
;
unwrapped
-
>
setUTCTime
(
v
args
.
rval
(
)
)
;
return
true
;
}
static
bool
date_setYear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
DateObject
*
>
unwrapped
(
cx
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
setYear
"
)
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
t
=
ThisLocalTimeOrZero
(
unwrapped
-
>
forceUTC
(
)
unwrapped
)
;
double
y
;
if
(
!
ToNumber
(
cx
args
.
get
(
0
)
&
y
)
)
{
return
false
;
}
if
(
std
:
:
isnan
(
y
)
)
{
unwrapped
-
>
setUTCTime
(
ClippedTime
:
:
invalid
(
)
args
.
rval
(
)
)
;
return
true
;
}
double
yint
=
ToInteger
(
y
)
;
if
(
0
<
=
yint
&
&
yint
<
=
99
)
{
yint
+
=
1900
;
}
double
day
=
MakeDay
(
yint
MonthFromTime
(
t
)
DateFromTime
(
t
)
)
;
double
u
=
UTC
(
unwrapped
-
>
forceUTC
(
)
MakeDate
(
day
TimeWithinDay
(
t
)
)
)
;
unwrapped
-
>
setUTCTime
(
TimeClip
(
u
)
args
.
rval
(
)
)
;
return
true
;
}
static
const
char
*
const
days
[
]
=
{
"
Sun
"
"
Mon
"
"
Tue
"
"
Wed
"
"
Thu
"
"
Fri
"
"
Sat
"
}
;
static
const
char
*
const
months
[
]
=
{
"
Jan
"
"
Feb
"
"
Mar
"
"
Apr
"
"
May
"
"
Jun
"
"
Jul
"
"
Aug
"
"
Sep
"
"
Oct
"
"
Nov
"
"
Dec
"
}
;
static
bool
date_toUTCString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSMethodProfilerEntry
pseudoFrame
(
cx
"
Date
.
prototype
"
"
toUTCString
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
toUTCString
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
utctime
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
if
(
!
std
:
:
isfinite
(
utctime
)
)
{
args
.
rval
(
)
.
setString
(
cx
-
>
names
(
)
.
Invalid_Date_
)
;
return
true
;
}
char
buf
[
100
]
;
SprintfLiteral
(
buf
"
%
s
%
.
2d
%
s
%
.
4d
%
.
2d
:
%
.
2d
:
%
.
2d
GMT
"
days
[
int
(
WeekDay
(
utctime
)
)
]
int
(
DateFromTime
(
utctime
)
)
months
[
int
(
MonthFromTime
(
utctime
)
)
]
int
(
YearFromTime
(
utctime
)
)
int
(
HourFromTime
(
utctime
)
)
int
(
MinFromTime
(
utctime
)
)
int
(
SecFromTime
(
utctime
)
)
)
;
JSString
*
str
=
NewStringCopyZ
<
CanGC
>
(
cx
buf
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
date_toISOString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSMethodProfilerEntry
pseudoFrame
(
cx
"
Date
.
prototype
"
"
toISOString
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
toISOString
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
utctime
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
if
(
!
std
:
:
isfinite
(
utctime
)
)
{
JS_ReportErrorNumberASCII
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_DATE
)
;
return
false
;
}
char
buf
[
100
]
;
int
year
=
int
(
YearFromTime
(
utctime
)
)
;
if
(
year
<
0
|
|
year
>
9999
)
{
SprintfLiteral
(
buf
"
%
+
.
6d
-
%
.
2d
-
%
.
2dT
%
.
2d
:
%
.
2d
:
%
.
2d
.
%
.
3dZ
"
int
(
YearFromTime
(
utctime
)
)
int
(
MonthFromTime
(
utctime
)
)
+
1
int
(
DateFromTime
(
utctime
)
)
int
(
HourFromTime
(
utctime
)
)
int
(
MinFromTime
(
utctime
)
)
int
(
SecFromTime
(
utctime
)
)
int
(
msFromTime
(
utctime
)
)
)
;
}
else
{
SprintfLiteral
(
buf
"
%
.
4d
-
%
.
2d
-
%
.
2dT
%
.
2d
:
%
.
2d
:
%
.
2d
.
%
.
3dZ
"
int
(
YearFromTime
(
utctime
)
)
int
(
MonthFromTime
(
utctime
)
)
+
1
int
(
DateFromTime
(
utctime
)
)
int
(
HourFromTime
(
utctime
)
)
int
(
MinFromTime
(
utctime
)
)
int
(
SecFromTime
(
utctime
)
)
int
(
msFromTime
(
utctime
)
)
)
;
}
JSString
*
str
=
NewStringCopyZ
<
CanGC
>
(
cx
buf
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
static
bool
date_toJSON
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSMethodProfilerEntry
pseudoFrame
(
cx
"
Date
.
prototype
"
"
toJSON
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedObject
obj
(
cx
ToObject
(
cx
args
.
thisv
(
)
)
)
;
if
(
!
obj
)
{
return
false
;
}
RootedValue
tv
(
cx
ObjectValue
(
*
obj
)
)
;
if
(
!
ToPrimitive
(
cx
JSTYPE_NUMBER
&
tv
)
)
{
return
false
;
}
if
(
tv
.
isDouble
(
)
&
&
!
std
:
:
isfinite
(
tv
.
toDouble
(
)
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
RootedValue
toISO
(
cx
)
;
if
(
!
GetProperty
(
cx
obj
obj
cx
-
>
names
(
)
.
toISOString
&
toISO
)
)
{
return
false
;
}
if
(
!
IsCallable
(
toISO
)
)
{
JS_ReportErrorNumberASCII
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_BAD_TOISOSTRING_PROP
)
;
return
false
;
}
return
Call
(
cx
toISO
obj
args
.
rval
(
)
)
;
}
#
if
JS_HAS_INTL_API
JSString
*
DateTimeHelper
:
:
timeZoneComment
(
JSContext
*
cx
DateTimeInfo
:
:
ForceUTC
forceUTC
const
char
*
locale
double
utcTime
double
localTime
)
{
if
(
!
locale
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_DEFAULT_LOCALE_ERROR
)
;
return
nullptr
;
}
char16_t
tzbuf
[
100
]
;
tzbuf
[
0
]
=
'
'
;
tzbuf
[
1
]
=
'
(
'
;
char16_t
*
timeZoneStart
=
tzbuf
+
2
;
constexpr
size_t
remainingSpace
=
std
:
:
size
(
tzbuf
)
-
2
-
1
;
int64_t
utcMilliseconds
=
static_cast
<
int64_t
>
(
utcTime
)
;
if
(
!
DateTimeInfo
:
:
timeZoneDisplayName
(
forceUTC
timeZoneStart
remainingSpace
utcMilliseconds
locale
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
size_t
len
=
js_strlen
(
timeZoneStart
)
;
if
(
len
=
=
0
)
{
return
cx
-
>
names
(
)
.
empty_
;
}
timeZoneStart
[
len
]
=
'
)
'
;
return
NewStringCopyN
<
CanGC
>
(
cx
tzbuf
2
+
len
+
1
)
;
}
#
else
PRMJTime
DateTimeHelper
:
:
toPRMJTime
(
DateTimeInfo
:
:
ForceUTC
forceUTC
double
localTime
double
utcTime
)
{
double
year
=
YearFromTime
(
localTime
)
;
PRMJTime
prtm
;
prtm
.
tm_usec
=
int32_t
(
msFromTime
(
localTime
)
)
*
1000
;
prtm
.
tm_sec
=
int8_t
(
SecFromTime
(
localTime
)
)
;
prtm
.
tm_min
=
int8_t
(
MinFromTime
(
localTime
)
)
;
prtm
.
tm_hour
=
int8_t
(
HourFromTime
(
localTime
)
)
;
prtm
.
tm_mday
=
int8_t
(
DateFromTime
(
localTime
)
)
;
prtm
.
tm_mon
=
int8_t
(
MonthFromTime
(
localTime
)
)
;
prtm
.
tm_wday
=
int8_t
(
WeekDay
(
localTime
)
)
;
prtm
.
tm_year
=
year
;
prtm
.
tm_yday
=
int16_t
(
DayWithinYear
(
localTime
year
)
)
;
prtm
.
tm_isdst
=
(
daylightSavingTA
(
forceUTC
utcTime
)
!
=
0
)
;
return
prtm
;
}
size_t
DateTimeHelper
:
:
formatTime
(
DateTimeInfo
:
:
ForceUTC
forceUTC
char
*
buf
size_t
buflen
const
char
*
fmt
double
utcTime
double
localTime
)
{
PRMJTime
prtm
=
toPRMJTime
(
forceUTC
localTime
utcTime
)
;
int
timeZoneYear
=
isRepresentableAsTime32
(
utcTime
)
?
prtm
.
tm_year
:
equivalentYearForDST
(
prtm
.
tm_year
)
;
int
offsetInSeconds
=
(
int
)
floor
(
(
localTime
-
utcTime
)
/
msPerSecond
)
;
return
PRMJ_FormatTime
(
buf
buflen
fmt
&
prtm
timeZoneYear
offsetInSeconds
)
;
}
JSString
*
DateTimeHelper
:
:
timeZoneComment
(
JSContext
*
cx
DateTimeInfo
:
:
ForceUTC
forceUTC
const
char
*
locale
double
utcTime
double
localTime
)
{
char
tzbuf
[
100
]
;
size_t
tzlen
=
formatTime
(
forceUTC
tzbuf
sizeof
tzbuf
"
(
%
Z
)
"
utcTime
localTime
)
;
if
(
tzlen
!
=
0
)
{
bool
usetz
=
true
;
for
(
size_t
i
=
0
;
i
<
tzlen
;
i
+
+
)
{
char16_t
c
=
tzbuf
[
i
]
;
if
(
!
IsAsciiPrintable
(
c
)
)
{
usetz
=
false
;
break
;
}
}
if
(
tzbuf
[
0
]
!
=
'
'
|
|
tzbuf
[
1
]
!
=
'
(
'
|
|
tzbuf
[
2
]
=
=
'
)
'
)
{
usetz
=
false
;
}
if
(
usetz
)
{
return
NewStringCopyN
<
CanGC
>
(
cx
tzbuf
tzlen
)
;
}
}
return
cx
-
>
names
(
)
.
empty_
;
}
#
endif
enum
class
FormatSpec
{
DateTime
Date
Time
}
;
static
bool
FormatDate
(
JSContext
*
cx
DateTimeInfo
:
:
ForceUTC
forceUTC
const
char
*
locale
double
utcTime
FormatSpec
format
MutableHandleValue
rval
)
{
if
(
!
std
:
:
isfinite
(
utcTime
)
)
{
rval
.
setString
(
cx
-
>
names
(
)
.
Invalid_Date_
)
;
return
true
;
}
MOZ_ASSERT
(
NumbersAreIdentical
(
TimeClip
(
utcTime
)
.
toDouble
(
)
utcTime
)
)
;
double
localTime
=
LocalTime
(
forceUTC
utcTime
)
;
int
offset
=
0
;
RootedString
timeZoneComment
(
cx
)
;
if
(
format
=
=
FormatSpec
:
:
DateTime
|
|
format
=
=
FormatSpec
:
:
Time
)
{
int
minutes
=
(
int
)
trunc
(
(
localTime
-
utcTime
)
/
msPerMinute
)
;
offset
=
(
minutes
/
60
)
*
100
+
minutes
%
60
;
timeZoneComment
=
DateTimeHelper
:
:
timeZoneComment
(
cx
forceUTC
locale
utcTime
localTime
)
;
if
(
!
timeZoneComment
)
{
return
false
;
}
}
char
buf
[
100
]
;
switch
(
format
)
{
case
FormatSpec
:
:
DateTime
:
SprintfLiteral
(
buf
"
%
s
%
s
%
.
2d
%
.
4d
%
.
2d
:
%
.
2d
:
%
.
2d
GMT
%
+
.
4d
"
days
[
int
(
WeekDay
(
localTime
)
)
]
months
[
int
(
MonthFromTime
(
localTime
)
)
]
int
(
DateFromTime
(
localTime
)
)
int
(
YearFromTime
(
localTime
)
)
int
(
HourFromTime
(
localTime
)
)
int
(
MinFromTime
(
localTime
)
)
int
(
SecFromTime
(
localTime
)
)
offset
)
;
break
;
case
FormatSpec
:
:
Date
:
SprintfLiteral
(
buf
"
%
s
%
s
%
.
2d
%
.
4d
"
days
[
int
(
WeekDay
(
localTime
)
)
]
months
[
int
(
MonthFromTime
(
localTime
)
)
]
int
(
DateFromTime
(
localTime
)
)
int
(
YearFromTime
(
localTime
)
)
)
;
break
;
case
FormatSpec
:
:
Time
:
SprintfLiteral
(
buf
"
%
.
2d
:
%
.
2d
:
%
.
2d
GMT
%
+
.
4d
"
int
(
HourFromTime
(
localTime
)
)
int
(
MinFromTime
(
localTime
)
)
int
(
SecFromTime
(
localTime
)
)
offset
)
;
break
;
}
RootedString
str
(
cx
NewStringCopyZ
<
CanGC
>
(
cx
buf
)
)
;
if
(
!
str
)
{
return
false
;
}
if
(
timeZoneComment
&
&
!
timeZoneComment
-
>
empty
(
)
)
{
str
=
js
:
:
ConcatStrings
<
CanGC
>
(
cx
str
timeZoneComment
)
;
if
(
!
str
)
{
return
false
;
}
}
rval
.
setString
(
str
)
;
return
true
;
}
#
if
!
JS_HAS_INTL_API
static
bool
ToLocaleFormatHelper
(
JSContext
*
cx
DateObject
*
unwrapped
const
char
*
format
MutableHandleValue
rval
)
{
DateTimeInfo
:
:
ForceUTC
forceUTC
=
unwrapped
-
>
forceUTC
(
)
;
const
char
*
locale
=
unwrapped
-
>
realm
(
)
-
>
getLocale
(
)
;
double
utcTime
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
char
buf
[
100
]
;
if
(
!
std
:
:
isfinite
(
utcTime
)
)
{
strcpy
(
buf
"
InvalidDate
"
)
;
}
else
{
double
localTime
=
LocalTime
(
forceUTC
utcTime
)
;
size_t
result_len
=
DateTimeHelper
:
:
formatTime
(
forceUTC
buf
sizeof
buf
format
utcTime
localTime
)
;
if
(
result_len
=
=
0
)
{
return
FormatDate
(
cx
forceUTC
locale
utcTime
FormatSpec
:
:
DateTime
rval
)
;
}
if
(
strcmp
(
format
"
%
x
"
)
=
=
0
&
&
result_len
>
=
6
&
&
!
IsAsciiDigit
(
buf
[
result_len
-
3
]
)
&
&
IsAsciiDigit
(
buf
[
result_len
-
2
]
)
&
&
IsAsciiDigit
(
buf
[
result_len
-
1
]
)
&
&
!
(
IsAsciiDigit
(
buf
[
0
]
)
&
&
IsAsciiDigit
(
buf
[
1
]
)
&
&
IsAsciiDigit
(
buf
[
2
]
)
&
&
IsAsciiDigit
(
buf
[
3
]
)
)
)
{
int
year
=
int
(
YearFromTime
(
localTime
)
)
;
snprintf
(
buf
+
(
result_len
-
2
)
(
sizeof
buf
)
-
(
result_len
-
2
)
"
%
d
"
year
)
;
}
}
if
(
cx
-
>
runtime
(
)
-
>
localeCallbacks
&
&
cx
-
>
runtime
(
)
-
>
localeCallbacks
-
>
localeToUnicode
)
{
return
cx
-
>
runtime
(
)
-
>
localeCallbacks
-
>
localeToUnicode
(
cx
buf
rval
)
;
}
JSString
*
str
=
NewStringCopyZ
<
CanGC
>
(
cx
buf
)
;
if
(
!
str
)
{
return
false
;
}
rval
.
setString
(
str
)
;
return
true
;
}
static
bool
date_toLocaleString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSMethodProfilerEntry
pseudoFrame
(
cx
"
Date
.
prototype
"
"
toLocaleString
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
toLocaleString
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
static
const
char
format
[
]
=
#
if
defined
(
_WIN32
)
"
%
#
c
"
#
else
"
%
c
"
#
endif
;
return
ToLocaleFormatHelper
(
cx
unwrapped
format
args
.
rval
(
)
)
;
}
static
bool
date_toLocaleDateString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSMethodProfilerEntry
pseudoFrame
(
cx
"
Date
.
prototype
"
"
toLocaleDateString
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
toLocaleDateString
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
static
const
char
format
[
]
=
#
if
defined
(
_WIN32
)
"
%
#
x
"
#
else
"
%
x
"
#
endif
;
return
ToLocaleFormatHelper
(
cx
unwrapped
format
args
.
rval
(
)
)
;
}
static
bool
date_toLocaleTimeString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSMethodProfilerEntry
pseudoFrame
(
cx
"
Date
.
prototype
"
"
toLocaleTimeString
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
toLocaleTimeString
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
return
ToLocaleFormatHelper
(
cx
unwrapped
"
%
X
"
args
.
rval
(
)
)
;
}
#
endif
static
bool
date_toTimeString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSMethodProfilerEntry
pseudoFrame
(
cx
"
Date
.
prototype
"
"
toTimeString
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
toTimeString
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
return
FormatDate
(
cx
unwrapped
-
>
forceUTC
(
)
unwrapped
-
>
realm
(
)
-
>
getLocale
(
)
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
FormatSpec
:
:
Time
args
.
rval
(
)
)
;
}
static
bool
date_toDateString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSMethodProfilerEntry
pseudoFrame
(
cx
"
Date
.
prototype
"
"
toDateString
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
toDateString
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
return
FormatDate
(
cx
unwrapped
-
>
forceUTC
(
)
unwrapped
-
>
realm
(
)
-
>
getLocale
(
)
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
FormatSpec
:
:
Date
args
.
rval
(
)
)
;
}
static
bool
date_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSMethodProfilerEntry
pseudoFrame
(
cx
"
Date
.
prototype
"
"
toSource
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
toSource
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
JSStringBuilder
sb
(
cx
)
;
if
(
!
sb
.
append
(
"
(
new
Date
(
"
)
|
|
!
NumberValueToStringBuffer
(
unwrapped
-
>
UTCTime
(
)
sb
)
|
|
!
sb
.
append
(
"
)
)
"
)
)
{
return
false
;
}
JSString
*
str
=
sb
.
finishString
(
)
;
if
(
!
str
)
{
return
false
;
}
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
bool
date_toString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSMethodProfilerEntry
pseudoFrame
(
cx
"
Date
.
prototype
"
"
toString
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
toString
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
return
FormatDate
(
cx
unwrapped
-
>
forceUTC
(
)
unwrapped
-
>
realm
(
)
-
>
getLocale
(
)
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
FormatSpec
:
:
DateTime
args
.
rval
(
)
)
;
}
bool
js
:
:
date_valueOf
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
valueOf
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
unwrapped
-
>
UTCTime
(
)
)
;
return
true
;
}
static
bool
date_toPrimitive
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
thisv
(
)
.
isObject
(
)
)
{
ReportIncompatible
(
cx
args
)
;
return
false
;
}
JSType
hint
;
if
(
!
GetFirstArgumentAsTypeHint
(
cx
args
&
hint
)
)
{
return
false
;
}
if
(
hint
=
=
JSTYPE_UNDEFINED
)
{
hint
=
JSTYPE_STRING
;
}
args
.
rval
(
)
.
set
(
args
.
thisv
(
)
)
;
RootedObject
obj
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
)
;
return
OrdinaryToPrimitive
(
cx
obj
hint
args
.
rval
(
)
)
;
}
#
if
JS_HAS_TEMPORAL_API
static
bool
date_toTemporalInstant
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
auto
*
unwrapped
=
UnwrapAndTypeCheckThis
<
DateObject
>
(
cx
args
"
toTemporalInstant
"
)
;
if
(
!
unwrapped
)
{
return
false
;
}
double
utctime
=
unwrapped
-
>
UTCTime
(
)
.
toNumber
(
)
;
if
(
!
std
:
:
isfinite
(
utctime
)
)
{
JS_ReportErrorNumberASCII
(
cx
js
:
:
GetErrorMessage
nullptr
JSMSG_INVALID_DATE
)
;
return
false
;
}
MOZ_ASSERT
(
IsInteger
(
utctime
)
)
;
auto
instant
=
temporal
:
:
Instant
:
:
fromMilliseconds
(
int64_t
(
utctime
)
)
;
MOZ_ASSERT
(
temporal
:
:
IsValidEpochInstant
(
instant
)
)
;
auto
*
result
=
temporal
:
:
CreateTemporalInstant
(
cx
instant
)
;
if
(
!
result
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
result
)
;
return
true
;
}
#
endif
static
const
JSFunctionSpec
date_static_methods
[
]
=
{
JS_FN
(
"
UTC
"
date_UTC
7
0
)
JS_FN
(
"
parse
"
date_parse
1
0
)
JS_FN
(
"
now
"
date_now
0
0
)
JS_FS_END
}
;
static
const
JSFunctionSpec
date_methods
[
]
=
{
JS_FN
(
"
getTime
"
date_getTime
0
0
)
JS_FN
(
"
getTimezoneOffset
"
date_getTimezoneOffset
0
0
)
JS_FN
(
"
getYear
"
date_getYear
0
0
)
JS_FN
(
"
getFullYear
"
date_getFullYear
0
0
)
JS_FN
(
"
getUTCFullYear
"
date_getUTCFullYear
0
0
)
JS_FN
(
"
getMonth
"
date_getMonth
0
0
)
JS_FN
(
"
getUTCMonth
"
date_getUTCMonth
0
0
)
JS_FN
(
"
getDate
"
date_getDate
0
0
)
JS_FN
(
"
getUTCDate
"
date_getUTCDate
0
0
)
JS_FN
(
"
getDay
"
date_getDay
0
0
)
JS_FN
(
"
getUTCDay
"
date_getUTCDay
0
0
)
JS_FN
(
"
getHours
"
date_getHours
0
0
)
JS_FN
(
"
getUTCHours
"
date_getUTCHours
0
0
)
JS_FN
(
"
getMinutes
"
date_getMinutes
0
0
)
JS_FN
(
"
getUTCMinutes
"
date_getUTCMinutes
0
0
)
JS_FN
(
"
getSeconds
"
date_getSeconds
0
0
)
JS_FN
(
"
getUTCSeconds
"
date_getUTCSeconds
0
0
)
JS_FN
(
"
getMilliseconds
"
date_getMilliseconds
0
0
)
JS_FN
(
"
getUTCMilliseconds
"
date_getUTCMilliseconds
0
0
)
JS_FN
(
"
setTime
"
date_setTime
1
0
)
JS_FN
(
"
setYear
"
date_setYear
1
0
)
JS_FN
(
"
setFullYear
"
date_setFullYear
3
0
)
JS_FN
(
"
setUTCFullYear
"
date_setUTCFullYear
3
0
)
JS_FN
(
"
setMonth
"
date_setMonth
2
0
)
JS_FN
(
"
setUTCMonth
"
date_setUTCMonth
2
0
)
JS_FN
(
"
setDate
"
date_setDate
1
0
)
JS_FN
(
"
setUTCDate
"
date_setUTCDate
1
0
)
JS_FN
(
"
setHours
"
date_setHours
4
0
)
JS_FN
(
"
setUTCHours
"
date_setUTCHours
4
0
)
JS_FN
(
"
setMinutes
"
date_setMinutes
3
0
)
JS_FN
(
"
setUTCMinutes
"
date_setUTCMinutes
3
0
)
JS_FN
(
"
setSeconds
"
date_setSeconds
2
0
)
JS_FN
(
"
setUTCSeconds
"
date_setUTCSeconds
2
0
)
JS_FN
(
"
setMilliseconds
"
date_setMilliseconds
1
0
)
JS_FN
(
"
setUTCMilliseconds
"
date_setUTCMilliseconds
1
0
)
JS_FN
(
"
toUTCString
"
date_toUTCString
0
0
)
#
if
JS_HAS_TEMPORAL_API
JS_FN
(
"
toTemporalInstant
"
date_toTemporalInstant
0
0
)
#
endif
#
if
JS_HAS_INTL_API
JS_SELF_HOSTED_FN
(
"
toLocaleString
"
"
Date_toLocaleString
"
0
0
)
JS_SELF_HOSTED_FN
(
"
toLocaleDateString
"
"
Date_toLocaleDateString
"
0
0
)
JS_SELF_HOSTED_FN
(
"
toLocaleTimeString
"
"
Date_toLocaleTimeString
"
0
0
)
#
else
JS_FN
(
"
toLocaleString
"
date_toLocaleString
0
0
)
JS_FN
(
"
toLocaleDateString
"
date_toLocaleDateString
0
0
)
JS_FN
(
"
toLocaleTimeString
"
date_toLocaleTimeString
0
0
)
#
endif
JS_FN
(
"
toDateString
"
date_toDateString
0
0
)
JS_FN
(
"
toTimeString
"
date_toTimeString
0
0
)
JS_FN
(
"
toISOString
"
date_toISOString
0
0
)
JS_FN
(
"
toJSON
"
date_toJSON
1
0
)
JS_FN
(
"
toSource
"
date_toSource
0
0
)
JS_FN
(
"
toString
"
date_toString
0
0
)
JS_FN
(
"
valueOf
"
date_valueOf
0
0
)
JS_SYM_FN
(
toPrimitive
date_toPrimitive
1
JSPROP_READONLY
)
JS_FS_END
}
;
static
bool
NewDateObject
(
JSContext
*
cx
const
CallArgs
&
args
ClippedTime
t
)
{
MOZ_ASSERT
(
args
.
isConstructing
(
)
)
;
RootedObject
proto
(
cx
)
;
if
(
!
GetPrototypeFromBuiltinConstructor
(
cx
args
JSProto_Date
&
proto
)
)
{
return
false
;
}
JSObject
*
obj
=
NewDateObjectMsec
(
cx
t
proto
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
setObject
(
*
obj
)
;
return
true
;
}
static
bool
ToDateString
(
JSContext
*
cx
const
CallArgs
&
args
ClippedTime
t
)
{
return
FormatDate
(
cx
ForceUTC
(
cx
-
>
realm
(
)
)
cx
-
>
realm
(
)
-
>
getLocale
(
)
t
.
toDouble
(
)
FormatSpec
:
:
DateTime
args
.
rval
(
)
)
;
}
static
bool
DateNoArguments
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
args
.
length
(
)
=
=
0
)
;
ClippedTime
now
=
NowAsMillis
(
cx
)
;
if
(
args
.
isConstructing
(
)
)
{
return
NewDateObject
(
cx
args
now
)
;
}
return
ToDateString
(
cx
args
now
)
;
}
static
bool
DateOneArgument
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
args
.
length
(
)
=
=
1
)
;
if
(
args
.
isConstructing
(
)
)
{
if
(
args
[
0
]
.
isObject
(
)
)
{
RootedObject
obj
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
ESClass
cls
;
if
(
!
GetBuiltinClass
(
cx
obj
&
cls
)
)
{
return
false
;
}
if
(
cls
=
=
ESClass
:
:
Date
)
{
RootedValue
unboxed
(
cx
)
;
if
(
!
Unbox
(
cx
obj
&
unboxed
)
)
{
return
false
;
}
return
NewDateObject
(
cx
args
TimeClip
(
unboxed
.
toNumber
(
)
)
)
;
}
}
if
(
!
ToPrimitive
(
cx
args
[
0
]
)
)
{
return
false
;
}
ClippedTime
t
;
if
(
args
[
0
]
.
isString
(
)
)
{
JSLinearString
*
linearStr
=
args
[
0
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
linearStr
)
{
return
false
;
}
if
(
!
ParseDate
(
ForceUTC
(
cx
-
>
realm
(
)
)
linearStr
&
t
cx
)
)
{
t
=
ClippedTime
:
:
invalid
(
)
;
}
}
else
{
double
d
;
if
(
!
ToNumber
(
cx
args
[
0
]
&
d
)
)
{
return
false
;
}
t
=
TimeClip
(
d
)
;
}
return
NewDateObject
(
cx
args
t
)
;
}
return
ToDateString
(
cx
args
NowAsMillis
(
cx
)
)
;
}
static
bool
DateMultipleArguments
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
args
.
length
(
)
>
=
2
)
;
if
(
args
.
isConstructing
(
)
)
{
double
y
;
if
(
!
ToNumber
(
cx
args
[
0
]
&
y
)
)
{
return
false
;
}
double
m
;
if
(
!
ToNumber
(
cx
args
[
1
]
&
m
)
)
{
return
false
;
}
double
dt
;
if
(
args
.
length
(
)
>
=
3
)
{
if
(
!
ToNumber
(
cx
args
[
2
]
&
dt
)
)
{
return
false
;
}
}
else
{
dt
=
1
;
}
double
h
;
if
(
args
.
length
(
)
>
=
4
)
{
if
(
!
ToNumber
(
cx
args
[
3
]
&
h
)
)
{
return
false
;
}
}
else
{
h
=
0
;
}
double
min
;
if
(
args
.
length
(
)
>
=
5
)
{
if
(
!
ToNumber
(
cx
args
[
4
]
&
min
)
)
{
return
false
;
}
}
else
{
min
=
0
;
}
double
s
;
if
(
args
.
length
(
)
>
=
6
)
{
if
(
!
ToNumber
(
cx
args
[
5
]
&
s
)
)
{
return
false
;
}
}
else
{
s
=
0
;
}
double
milli
;
if
(
args
.
length
(
)
>
=
7
)
{
if
(
!
ToNumber
(
cx
args
[
6
]
&
milli
)
)
{
return
false
;
}
}
else
{
milli
=
0
;
}
double
yr
=
y
;
if
(
!
std
:
:
isnan
(
y
)
)
{
double
yint
=
ToInteger
(
y
)
;
if
(
0
<
=
yint
&
&
yint
<
=
99
)
{
yr
=
1900
+
yint
;
}
}
double
finalDate
=
MakeDate
(
MakeDay
(
yr
m
dt
)
MakeTime
(
h
min
s
milli
)
)
;
return
NewDateObject
(
cx
args
TimeClip
(
UTC
(
ForceUTC
(
cx
-
>
realm
(
)
)
finalDate
)
)
)
;
}
return
ToDateString
(
cx
args
NowAsMillis
(
cx
)
)
;
}
static
bool
DateConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
AutoJSConstructorProfilerEntry
pseudoFrame
(
cx
"
Date
"
)
;
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
args
.
length
(
)
=
=
0
)
{
return
DateNoArguments
(
cx
args
)
;
}
if
(
args
.
length
(
)
=
=
1
)
{
return
DateOneArgument
(
cx
args
)
;
}
return
DateMultipleArguments
(
cx
args
)
;
}
static
bool
FinishDateClassInit
(
JSContext
*
cx
HandleObject
ctor
HandleObject
proto
)
{
RootedValue
toUTCStringFun
(
cx
)
;
RootedId
toUTCStringId
(
cx
NameToId
(
cx
-
>
names
(
)
.
toUTCString
)
)
;
RootedId
toGMTStringId
(
cx
NameToId
(
cx
-
>
names
(
)
.
toGMTString
)
)
;
return
NativeGetProperty
(
cx
proto
.
as
<
NativeObject
>
(
)
toUTCStringId
&
toUTCStringFun
)
&
&
NativeDefineDataProperty
(
cx
proto
.
as
<
NativeObject
>
(
)
toGMTStringId
toUTCStringFun
0
)
;
}
static
const
ClassSpec
DateObjectClassSpec
=
{
GenericCreateConstructor
<
DateConstructor
7
gc
:
:
AllocKind
:
:
FUNCTION
>
GenericCreatePrototype
<
DateObject
>
date_static_methods
nullptr
date_methods
nullptr
FinishDateClassInit
}
;
const
JSClass
DateObject
:
:
class_
=
{
"
Date
"
JSCLASS_HAS_RESERVED_SLOTS
(
RESERVED_SLOTS
)
|
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Date
)
JS_NULL_CLASS_OPS
&
DateObjectClassSpec
}
;
const
JSClass
DateObject
:
:
protoClass_
=
{
"
Date
.
prototype
"
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Date
)
JS_NULL_CLASS_OPS
&
DateObjectClassSpec
}
;
JSObject
*
js
:
:
NewDateObjectMsec
(
JSContext
*
cx
ClippedTime
t
HandleObject
proto
)
{
DateObject
*
obj
=
NewObjectWithClassProto
<
DateObject
>
(
cx
proto
)
;
if
(
!
obj
)
{
return
nullptr
;
}
obj
-
>
setUTCTime
(
t
)
;
return
obj
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
NewDateObject
(
JSContext
*
cx
ClippedTime
time
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
return
NewDateObjectMsec
(
cx
time
)
;
}
JS_PUBLIC_API
JSObject
*
js
:
:
NewDateObject
(
JSContext
*
cx
int
year
int
mon
int
mday
int
hour
int
min
int
sec
)
{
MOZ_ASSERT
(
mon
<
12
)
;
double
msec_time
=
MakeDate
(
MakeDay
(
year
mon
mday
)
MakeTime
(
hour
min
sec
0
.
0
)
)
;
return
NewDateObjectMsec
(
cx
TimeClip
(
UTC
(
ForceUTC
(
cx
-
>
realm
(
)
)
msec_time
)
)
)
;
}
JS_PUBLIC_API
bool
js
:
:
DateIsValid
(
JSContext
*
cx
HandleObject
obj
bool
*
isValid
)
{
ESClass
cls
;
if
(
!
GetBuiltinClass
(
cx
obj
&
cls
)
)
{
return
false
;
}
if
(
cls
!
=
ESClass
:
:
Date
)
{
*
isValid
=
false
;
return
true
;
}
RootedValue
unboxed
(
cx
)
;
if
(
!
Unbox
(
cx
obj
&
unboxed
)
)
{
return
false
;
}
*
isValid
=
!
std
:
:
isnan
(
unboxed
.
toNumber
(
)
)
;
return
true
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
NewDateObject
(
JSContext
*
cx
int
year
int
mon
int
mday
int
hour
int
min
int
sec
)
{
AssertHeapIsIdle
(
)
;
CHECK_THREAD
(
cx
)
;
return
js
:
:
NewDateObject
(
cx
year
mon
mday
hour
min
sec
)
;
}
JS_PUBLIC_API
bool
JS
:
:
ObjectIsDate
(
JSContext
*
cx
Handle
<
JSObject
*
>
obj
bool
*
isDate
)
{
cx
-
>
check
(
obj
)
;
ESClass
cls
;
if
(
!
GetBuiltinClass
(
cx
obj
&
cls
)
)
{
return
false
;
}
*
isDate
=
cls
=
=
ESClass
:
:
Date
;
return
true
;
}
JS_PUBLIC_API
bool
js
:
:
DateGetMsecSinceEpoch
(
JSContext
*
cx
HandleObject
obj
double
*
msecsSinceEpoch
)
{
ESClass
cls
;
if
(
!
GetBuiltinClass
(
cx
obj
&
cls
)
)
{
return
false
;
}
if
(
cls
!
=
ESClass
:
:
Date
)
{
*
msecsSinceEpoch
=
0
;
return
true
;
}
RootedValue
unboxed
(
cx
)
;
if
(
!
Unbox
(
cx
obj
&
unboxed
)
)
{
return
false
;
}
*
msecsSinceEpoch
=
unboxed
.
toNumber
(
)
;
return
true
;
}
JS_PUBLIC_API
bool
JS
:
:
IsISOStyleDate
(
JSContext
*
cx
const
JS
:
:
Latin1Chars
&
str
)
{
ClippedTime
result
;
return
ParseISOStyleDate
(
ForceUTC
(
cx
-
>
realm
(
)
)
str
.
begin
(
)
.
get
(
)
str
.
length
(
)
&
result
)
;
}
