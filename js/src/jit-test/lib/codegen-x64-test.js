var
SPACEDEBUG
=
false
;
var
HEXES
=
[
0
-
9a
-
fA
-
F
]
+
;
var
RIPR
=
0x
{
HEXES
}
;
var
x64_prefix
=
48
8b
ec
mov
%
rsp
%
rbp
var
x64_suffix
=
5d
pop
%
rbp
;
function
codegenTestX64_v128xv128_v128
(
inputs
options
=
{
}
)
{
for
(
let
[
op
expected
]
of
inputs
)
{
codegenTestX64BinopInternal
(
op
expected
options
'
v128
'
'
v128
'
'
v128
'
'
0
'
'
1
'
)
;
}
}
function
codegenTestX64_v128xPTYPE_v128
(
inputs
options
=
{
}
)
{
for
(
let
[
op
p1type
expected
]
of
inputs
)
{
codegenTestX64BinopInternal
(
op
expected
options
'
v128
'
p1type
'
v128
'
'
0
'
'
1
'
)
;
}
}
function
codegenTestX64_v128xLITERAL_v128
(
inputs
options
=
{
}
)
{
for
(
let
[
op
literal
expected
]
of
inputs
)
{
codegenTestX64_adhoc
(
wrap
(
options
(
func
(
export
"
f
"
)
(
param
v128
)
(
result
v128
)
(
{
op
}
(
local
.
get
0
)
{
literal
}
)
)
)
'
f
'
expected
options
)
}
}
function
codegenTestX64_v128xv128_v128_reversed
(
inputs
options
=
{
}
)
{
for
(
let
[
op
expected
]
of
inputs
)
{
codegenTestX64BinopInternal
(
op
expected
options
'
v128
'
'
v128
'
'
v128
'
'
1
'
'
0
'
)
;
}
}
function
codegenTestX64_v128_v128
(
inputs
options
=
{
}
)
{
for
(
let
[
op
expected
]
of
inputs
)
{
codegenTestX64_adhoc
(
wrap
(
options
(
func
(
export
"
f
"
)
(
param
v128
)
(
result
v128
)
(
{
op
}
(
local
.
get
0
)
)
)
)
'
f
'
expected
options
)
;
}
}
function
codegenTestX64_PTYPE_v128
(
inputs
options
=
{
}
)
{
for
(
let
[
op
ptype
expected
]
of
inputs
)
{
codegenTestX64_adhoc
(
wrap
(
options
(
func
(
export
"
f
"
)
(
param
{
ptype
}
)
(
result
v128
)
(
{
op
}
(
local
.
get
0
)
)
)
)
'
f
'
expected
options
)
;
}
}
function
codegenTestX64_IGNOREDxv128_v128
(
inputs
options
=
{
}
)
{
for
(
let
[
op
expected
]
of
inputs
)
{
codegenTestX64_adhoc
(
wrap
(
options
(
func
(
export
"
f
"
)
(
param
v128
)
(
param
v128
)
(
result
v128
)
(
{
op
}
(
local
.
get
1
)
)
)
)
'
f
'
expected
options
)
;
}
}
function
codegenTestX64_unit_v128
(
inputs
options
=
{
}
)
{
for
(
let
[
op
expected
]
of
inputs
)
{
codegenTestX64_adhoc
(
wrap
(
options
(
func
(
export
"
f
"
)
(
result
v128
)
(
{
op
}
)
)
)
'
f
'
expected
options
)
;
}
}
function
codegenTestX64_adhoc
(
module_text
export_name
expected
options
=
{
}
)
{
assertEq
(
hasDisassembler
(
)
true
)
;
let
ins
=
wasmEvalText
(
module_text
)
;
let
output
=
wasmDis
(
ins
.
exports
[
export_name
]
"
ion
"
true
)
;
if
(
!
options
.
no_prefix
)
expected
=
x64_prefix
+
'
\
n
'
+
expected
;
if
(
!
options
.
no_suffix
)
expected
=
expected
+
'
\
n
'
+
x64_suffix
;
expected
=
fixlines
(
expected
)
;
if
(
options
.
log
)
{
print
(
output
)
;
print
(
expected
)
;
}
assertEq
(
output
.
match
(
new
RegExp
(
expected
)
)
!
=
null
true
)
;
}
function
codegenTestX64BinopInternal
(
op
expected
options
p0type
p1type
restype
arg0
arg1
)
{
codegenTestX64_adhoc
(
wrap
(
options
(
func
(
export
"
f
"
)
(
param
{
p0type
}
)
(
param
{
p1type
}
)
(
result
{
restype
}
)
(
{
op
}
(
local
.
get
{
arg0
}
)
(
local
.
get
{
arg1
}
)
)
)
)
'
f
'
expected
options
)
;
}
function
wrap
(
options
funcs
)
{
if
(
'
memory
'
in
options
)
return
(
module
(
memory
{
options
.
memory
}
)
{
funcs
}
)
;
return
(
module
{
funcs
}
)
;
}
function
fixlines
(
s
)
{
return
s
.
split
(
/
\
n
+
/
)
.
map
(
strip
)
.
filter
(
x
=
>
x
.
length
>
0
)
.
map
(
x
=
>
x
.
charAt
(
0
)
=
=
'
*
'
?
x
.
substring
(
1
)
:
(
HEXES
+
'
'
+
x
)
)
.
map
(
spaces
)
.
join
(
'
\
n
'
)
;
}
function
strip
(
s
)
{
while
(
s
.
length
>
0
&
&
isspace
(
s
.
charAt
(
0
)
)
)
s
=
s
.
substring
(
1
)
;
while
(
s
.
length
>
0
&
&
isspace
(
s
.
charAt
(
s
.
length
-
1
)
)
)
s
=
s
.
substring
(
0
s
.
length
-
1
)
;
return
s
;
}
function
spaces
(
s
)
{
let
t
=
'
'
;
let
i
=
0
;
while
(
i
<
s
.
length
)
{
if
(
isspace
(
s
.
charAt
(
i
)
)
)
{
t
+
=
SPACEDEBUG
?
'
+
'
:
'
\
\
s
+
'
;
i
+
+
;
while
(
i
<
s
.
length
&
&
isspace
(
s
.
charAt
(
i
)
)
)
i
+
+
;
}
else
{
t
+
=
s
.
charAt
(
i
+
+
)
;
}
}
return
t
;
}
function
isspace
(
c
)
{
return
c
=
=
'
'
|
|
c
=
=
'
\
t
'
;
}
