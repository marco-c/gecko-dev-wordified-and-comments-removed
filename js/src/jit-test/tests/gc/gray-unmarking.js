gczeal
(
0
)
;
gc
(
)
;
assertEq
(
grayBitsValid
(
)
true
)
;
let
g1
=
newGlobal
(
{
newCompartment
:
true
}
)
;
let
g2
=
newGlobal
(
{
newCompartment
:
true
}
)
;
let
g3
=
newGlobal
(
{
newCompartment
:
true
}
)
;
g1
.
eval
(
'
var
a
=
{
}
'
)
;
g2
.
eval
(
'
var
b
=
{
}
'
)
;
g3
.
eval
(
'
var
c
=
{
}
'
)
;
g1
.
a
.
next
=
g2
.
b
;
g2
.
b
.
next
=
g3
.
c
;
g1
.
eval
(
'
addMarkObservers
(
[
a
]
)
'
)
;
g2
.
eval
(
'
addMarkObservers
(
[
b
]
)
'
)
;
g3
.
eval
(
'
addMarkObservers
(
[
c
]
)
'
)
;
g2
.
b
=
undefined
;
g3
.
c
=
undefined
;
function
checkMarks
(
a
b
c
)
{
assertEq
(
getMarks
(
)
.
join
(
"
"
)
[
a
b
c
]
.
join
(
"
"
)
)
;
}
gc
(
)
;
checkMarks
(
"
black
"
"
black
"
"
black
"
)
;
g1
.
eval
(
'
grayRoot
(
)
[
0
]
=
a
'
)
;
g1
.
a
=
undefined
;
gc
(
)
;
checkMarks
(
"
gray
"
"
gray
"
"
gray
"
)
;
g1
.
eval
(
'
grayRoot
(
)
[
0
]
'
)
;
checkMarks
(
"
black
"
"
black
"
"
black
"
)
;
gc
(
)
;
checkMarks
(
"
gray
"
"
gray
"
"
gray
"
)
;
schedulezone
(
g2
)
;
startgc
(
10
)
;
while
(
gcstate
(
)
=
=
=
"
Prepare
"
|
|
gcstate
(
)
=
=
=
"
MarkRoots
"
)
{
gcslice
(
10
)
;
}
assertEq
(
gcstate
(
)
"
Mark
"
)
;
assertEq
(
gcstate
(
g1
)
"
NoGC
"
)
;
assertEq
(
gcstate
(
g2
)
"
MarkBlackOnly
"
)
;
assertEq
(
gcstate
(
g3
)
"
NoGC
"
)
;
checkMarks
(
"
gray
"
"
unmarked
"
"
gray
"
)
;
g1
.
eval
(
'
grayRoot
(
)
[
0
]
'
)
;
checkMarks
(
"
black
"
"
black
"
"
gray
"
)
;
finishgc
(
)
;
assertEq
(
grayBitsValid
(
)
true
)
;
checkMarks
(
"
black
"
"
black
"
"
black
"
)
;
gc
(
)
;
checkMarks
(
"
gray
"
"
gray
"
"
gray
"
)
;
schedulezone
(
g2
)
;
startgc
(
10
)
;
while
(
gcstate
(
)
=
=
=
"
Prepare
"
|
|
gcstate
(
)
=
=
=
"
MarkRoots
"
)
{
gcslice
(
10
)
;
}
assertEq
(
gcstate
(
)
"
Mark
"
)
;
checkMarks
(
"
gray
"
"
unmarked
"
"
gray
"
)
;
g1
.
eval
(
'
grayRoot
(
)
[
0
]
'
)
;
assertEq
(
grayBitsValid
(
)
true
)
;
abortgc
(
)
;
assertEq
(
grayBitsValid
(
)
false
)
;
checkMarks
(
"
black
"
"
black
"
"
gray
"
)
;
gc
(
)
;
checkMarks
(
"
gray
"
"
gray
"
"
gray
"
)
;
