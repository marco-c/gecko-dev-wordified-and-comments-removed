function
checkPropertyDescriptor
(
obj
property
writable
enumerable
configurable
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
obj
property
)
;
assertEq
(
typeof
desc
"
object
"
)
;
assertEq
(
desc
.
writable
writable
)
;
assertEq
(
desc
.
enumerable
enumerable
)
;
assertEq
(
desc
.
configurable
configurable
)
;
}
function
assertThrowsTypeError
(
thunk
)
{
let
error
;
try
{
thunk
(
)
;
}
catch
(
e
)
{
error
=
e
;
}
assertEq
(
error
instanceof
TypeError
true
)
;
}
assertEq
(
typeof
this
.
FinalizationGroup
"
function
"
)
;
assertThrowsTypeError
(
(
)
=
>
new
FinalizationGroup
(
)
)
;
assertThrowsTypeError
(
(
)
=
>
new
FinalizationGroup
(
1
)
)
;
new
FinalizationGroup
(
x
=
>
0
)
;
assertEq
(
Object
.
getPrototypeOf
(
FinalizationGroup
)
Function
.
prototype
)
;
checkPropertyDescriptor
(
FinalizationGroup
'
prototype
'
false
false
false
)
;
let
proto
=
FinalizationGroup
.
prototype
;
assertEq
(
Object
.
getPrototypeOf
(
proto
)
Object
.
prototype
)
;
assertEq
(
proto
.
constructor
FinalizationGroup
)
;
assertEq
(
proto
.
hasOwnProperty
(
'
register
'
)
true
)
;
assertEq
(
typeof
proto
.
register
'
function
'
)
;
assertEq
(
proto
.
hasOwnProperty
(
'
unregister
'
)
true
)
;
assertEq
(
typeof
proto
.
unregister
'
function
'
)
;
assertEq
(
proto
.
hasOwnProperty
(
'
cleanupSome
'
)
true
)
;
assertEq
(
typeof
proto
.
cleanupSome
'
function
'
)
;
assertEq
(
proto
[
Symbol
.
toStringTag
]
"
FinalizationGroup
"
)
;
checkPropertyDescriptor
(
proto
Symbol
.
toStringTag
false
false
true
)
;
let
group
=
new
FinalizationGroup
(
x
=
>
0
)
;
assertEq
(
Object
.
getPrototypeOf
(
group
)
proto
)
;
assertEq
(
Object
.
getOwnPropertyNames
(
group
)
.
length
0
)
;
let
iterator
;
new
FinalizationGroup
(
it
=
>
iterator
=
it
)
.
register
(
{
}
0
)
;
gc
(
)
;
drainJobQueue
(
)
;
assertEq
(
typeof
iterator
'
object
'
)
;
let
arrayIterator
=
[
]
[
Symbol
.
iterator
]
(
)
;
let
iteratorProto
=
arrayIterator
.
__proto__
.
__proto__
;
proto
=
iterator
.
__proto__
;
assertEq
(
typeof
proto
"
object
"
)
;
assertEq
(
proto
.
__proto__
iteratorProto
)
;
assertEq
(
proto
.
hasOwnProperty
(
"
next
"
)
true
)
;
assertEq
(
typeof
proto
.
next
"
function
"
)
;
assertEq
(
proto
[
Symbol
.
toStringTag
]
"
FinalizationGroup
Cleanup
Iterator
"
)
;
checkPropertyDescriptor
(
proto
Symbol
.
toStringTag
false
false
true
)
;
assertEq
(
Object
.
getOwnPropertyNames
(
iterator
)
.
length
0
)
;
let
heldValues
=
[
]
;
group
=
new
FinalizationGroup
(
iterator
=
>
{
for
(
const
heldValue
of
iterator
)
{
heldValues
.
push
(
heldValue
)
;
}
}
)
;
heldValues
=
[
]
;
group
.
register
(
{
}
42
)
;
gc
(
)
;
drainJobQueue
(
)
;
assertEq
(
heldValues
.
length
1
)
;
assertEq
(
heldValues
[
0
]
42
)
;
heldValues
=
[
]
;
for
(
let
i
=
0
;
i
<
100
;
i
+
+
)
{
group
.
register
(
{
}
i
)
;
}
gc
(
)
;
drainJobQueue
(
)
;
assertEq
(
heldValues
.
length
100
)
;
heldValues
=
heldValues
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
for
(
let
i
=
0
;
i
<
100
;
i
+
+
)
{
assertEq
(
heldValues
[
i
]
i
)
;
}
heldValues
=
[
]
;
let
heldValues2
=
[
]
;
let
group2
=
new
FinalizationGroup
(
iterator
=
>
{
for
(
const
heldValue
of
iterator
)
{
heldValues2
.
push
(
heldValue
)
;
}
}
)
;
{
let
object
=
{
}
;
group
.
register
(
object
1
)
;
group2
.
register
(
object
2
)
;
object
=
null
;
}
gc
(
)
;
drainJobQueue
(
)
;
assertEq
(
heldValues
.
length
1
)
;
assertEq
(
heldValues
[
0
]
1
)
;
assertEq
(
heldValues2
.
length
1
)
;
assertEq
(
heldValues2
[
0
]
2
)
;
heldValues
=
[
]
;
let
token
=
{
}
;
group
.
register
(
{
}
1
token
)
;
group
.
unregister
(
token
)
;
gc
(
)
;
drainJobQueue
(
)
;
assertEq
(
heldValues
.
length
0
)
;
heldValues
=
[
]
;
let
token2
=
{
}
;
group
.
register
(
{
}
1
token
)
;
group
.
register
(
{
}
2
token2
)
;
group
.
register
(
{
}
3
token
)
;
group
.
register
(
{
}
4
token2
)
;
group
.
unregister
(
token
)
;
gc
(
)
;
drainJobQueue
(
)
;
assertEq
(
heldValues
.
length
2
)
;
heldValues
=
heldValues
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
assertEq
(
heldValues
[
0
]
2
)
;
assertEq
(
heldValues
[
1
]
4
)
;
let
other
=
newGlobal
(
{
newCompartment
:
true
}
)
;
heldValues
=
[
]
;
group
.
register
(
evalcx
(
'
(
{
}
)
'
other
)
1
)
;
gc
(
)
;
drainJobQueue
(
)
;
assertEq
(
heldValues
.
length
1
)
;
assertEq
(
heldValues
[
0
]
1
)
;
let
heldValue
=
evalcx
(
'
{
}
'
other
)
;
heldValues
=
[
]
;
group
.
register
(
{
}
heldValue
)
;
gc
(
)
;
drainJobQueue
(
)
;
assertEq
(
heldValues
.
length
1
)
;
assertEq
(
heldValues
[
0
]
heldValue
)
;
token
=
evalcx
(
'
(
{
}
)
'
other
)
;
heldValues
=
[
]
;
group
.
register
(
{
}
1
token
)
;
gc
(
)
;
drainJobQueue
(
)
;
assertEq
(
heldValues
.
length
1
)
;
assertEq
(
heldValues
[
0
]
1
)
;
heldValues
=
[
]
;
group
.
register
(
{
}
1
token
)
;
group
.
unregister
(
token
)
;
gc
(
)
;
drainJobQueue
(
)
;
assertEq
(
heldValues
.
length
0
)
;
class
MyGroup
extends
FinalizationGroup
{
constructor
(
callback
)
{
super
(
callback
)
;
}
}
let
g2
=
new
MyGroup
(
iterator
=
>
{
for
(
const
heldValue
of
iterator
)
{
heldValues
.
push
(
heldValue
)
;
}
}
)
;
heldValues
=
[
]
;
g2
.
register
(
{
}
42
)
;
gc
(
)
;
drainJobQueue
(
)
;
assertEq
(
heldValues
.
length
1
)
;
assertEq
(
heldValues
[
0
]
42
)
;
iterator
=
undefined
;
let
g3
=
new
FinalizationGroup
(
i
=
>
iterator
=
i
)
;
g3
.
register
(
{
}
1
)
;
gc
(
)
;
drainJobQueue
(
)
;
assertEq
(
typeof
iterator
'
object
'
)
;
assertThrowsTypeError
(
(
)
=
>
iterator
.
next
(
)
)
;
let
g4
=
new
FinalizationGroup
(
x
=
>
{
assertThrowsTypeError
(
(
)
=
>
iterator
.
next
(
)
)
;
}
)
;
g4
.
register
(
{
}
1
)
;
gc
(
)
;
drainJobQueue
(
)
;
heldValues
=
[
]
;
let
g5
=
new
FinalizationGroup
(
i
=
>
heldValues
=
[
.
.
.
i
]
)
;
g5
.
register
(
{
}
1
)
;
g5
.
register
(
{
}
2
)
;
g5
.
register
(
{
}
3
)
;
gc
(
)
;
g5
.
cleanupSome
(
)
;
assertEq
(
heldValues
.
length
3
)
;
heldValues
=
heldValues
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
assertEq
(
heldValues
[
0
]
1
)
;
assertEq
(
heldValues
[
1
]
2
)
;
assertEq
(
heldValues
[
2
]
3
)
;
let
g6
=
new
FinalizationGroup
(
x
=
>
{
assertThrowsTypeError
(
(
)
=
>
g6
.
cleanupSome
(
)
)
;
}
)
;
g6
.
register
(
{
}
1
)
;
gc
(
)
;
drainJobQueue
(
)
;
