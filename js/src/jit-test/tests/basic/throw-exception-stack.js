function
testTestingFunction
(
)
{
let
vals
=
[
{
}
1
"
foo
"
null
undefined
]
;
for
(
let
v
of
vals
)
{
let
thrower
=
(
)
=
>
{
throw
v
;
}
;
let
info
=
getExceptionInfo
(
thrower
)
;
assertEq
(
info
.
exception
v
)
;
assertEq
(
info
.
stack
.
includes
(
"
thrower
"
)
true
)
;
}
assertEq
(
getExceptionInfo
(
(
)
=
>
123
)
null
)
;
let
info
=
getExceptionInfo
(
throwOutOfMemory
)
;
assertEq
(
info
.
exception
"
out
of
memory
"
)
;
assertEq
(
info
.
stack
null
)
;
}
testTestingFunction
(
)
;
function
assertStacksCount
(
global
expectedStacksCount
)
{
global
.
evaluate
(
"
(
"
+
function
(
_expectedStacksCount
)
{
let
thrower
=
(
)
=
>
{
throw
123
;
}
;
for
(
let
i
=
0
;
i
<
100
;
i
+
+
)
{
let
info
=
getExceptionInfo
(
thrower
)
;
assertEq
(
info
.
exception
123
)
;
if
(
i
<
=
_expectedStacksCount
)
{
assertEq
(
info
.
stack
.
includes
(
"
thrower
"
)
true
)
;
}
else
{
assertEq
(
info
.
stack
null
)
;
}
}
}
+
)
(
{
expectedStacksCount
}
)
)
;
}
function
testDebuggee
(
)
{
let
g
=
newGlobal
(
{
newCompartment
:
true
}
)
;
let
dbg
=
new
Debugger
(
g
)
;
assertStacksCount
(
g
100
)
;
}
testDebuggee
(
)
;
function
testTrustedPrincipals
(
)
{
let
g
=
newGlobal
(
{
newCompartment
:
true
systemPrincipal
:
true
}
)
;
assertStacksCount
(
g
100
)
;
}
testTrustedPrincipals
(
)
;
function
testNormal
(
)
{
let
g
=
newGlobal
(
)
;
assertStacksCount
(
g
50
)
;
}
testNormal
(
)
;
function
testEnableUnlimitedStacksCapturing
(
)
{
let
dbg
=
new
Debugger
(
)
;
let
g
=
newGlobal
(
)
;
dbg
.
enableUnlimitedStacksCapturing
(
g
)
;
assertStacksCount
(
g
100
)
;
dbg
.
disableUnlimitedStacksCapturing
(
g
)
;
assertStacksCount
(
g
50
)
;
dbg
.
enableUnlimitedStacksCapturing
(
g
)
;
assertStacksCount
(
g
100
)
;
}
testEnableUnlimitedStacksCapturing
(
)
;
