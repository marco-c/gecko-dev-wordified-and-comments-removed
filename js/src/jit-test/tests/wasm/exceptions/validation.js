load
(
libdir
+
"
wasm
-
binary
.
js
"
)
;
function
wasmValid
(
mod
)
{
assertEq
(
WebAssembly
.
validate
(
mod
)
true
)
;
}
function
wasmInvalid
(
mod
pattern
)
{
assertEq
(
WebAssembly
.
validate
(
mod
)
false
)
;
assertErrorMessage
(
(
)
=
>
new
WebAssembly
.
Module
(
mod
)
WebAssembly
.
CompileError
pattern
)
;
}
const
emptyType
=
{
args
:
[
]
ret
:
VoidCode
}
;
const
i32Type
=
{
args
:
[
I32Code
]
ret
:
VoidCode
}
;
const
toi32Type
=
{
args
:
[
]
ret
:
I32Code
}
;
const
i32Toi32Type
=
{
args
:
[
I32Code
]
ret
:
I32Code
}
;
const
i32Toi64Type
=
{
args
:
[
I32Code
]
ret
:
I64Code
}
;
const
i32i32Toi32Type
=
{
args
:
[
I32Code
I32Code
]
ret
:
I32Code
}
;
function
testValidateDecode
(
)
{
wasmInvalid
(
moduleWithSections
(
[
sigSection
(
[
emptyType
]
)
declSection
(
[
0
]
)
eventSection
(
[
{
type
:
0
}
]
)
bodySection
(
[
funcBody
(
{
locals
:
[
]
body
:
[
TryCode
I32ConstCode
0x01
CatchCode
0x00
EndCode
DropCode
ReturnCode
]
}
)
]
)
]
)
/
bad
type
/
)
;
wasmInvalid
(
moduleWithSections
(
[
sigSection
(
[
emptyType
]
)
declSection
(
[
0
]
)
eventSection
(
[
{
type
:
0
}
]
)
bodySection
(
[
funcBody
(
{
locals
:
[
]
body
:
[
TryCode
I32Code
I32ConstCode
0x01
CatchCode
]
}
(
withEndCode
=
false
)
)
]
)
]
)
/
expected
event
index
/
)
;
wasmInvalid
(
moduleWithSections
(
[
sigSection
(
[
emptyType
]
)
declSection
(
[
0
]
)
eventSection
(
[
{
type
:
0
}
]
)
bodySection
(
[
funcBody
(
{
locals
:
[
]
body
:
[
TryCode
I32Code
I32ConstCode
0x01
EndCode
DropCode
ReturnCode
]
}
)
]
)
]
)
/
try
without
catch
or
unwind
not
allowed
/
)
;
}
function
testValidateThrow
(
)
{
valid
=
(
module
(
type
(
func
(
param
i32
)
)
)
(
func
exn
-
zero
i32
.
const
0
throw
exn1
)
(
event
exn1
(
type
0
)
)
)
;
invalid0
=
(
module
(
type
(
func
(
param
i32
)
)
)
(
func
exn
-
zero
throw
exn1
)
(
event
exn1
(
type
0
)
)
)
;
error0
=
/
popping
value
from
empty
stack
/
;
invalid1
=
(
module
(
type
(
func
(
param
i32
)
)
)
(
func
exn
-
zero
i64
.
const
0
throw
exn1
)
(
event
exn1
(
type
0
)
)
)
;
error1
=
/
expression
has
type
i64
but
expected
i32
/
;
invalid2
=
(
module
(
type
(
func
(
param
i32
)
)
)
(
func
exn
-
zero
i32
.
const
0
throw
1
)
(
event
exn1
(
type
0
)
)
)
;
error2
=
/
event
index
out
of
range
/
;
wasmValidateText
(
valid
)
;
wasmFailValidateText
(
invalid0
error0
)
;
wasmFailValidateText
(
invalid1
error1
)
;
wasmFailValidateText
(
invalid2
error2
)
;
}
function
testValidateTryCatch
(
)
{
function
mod_with
(
fbody
)
{
return
moduleWithSections
(
[
sigSection
(
[
emptyType
i32Type
i32i32Toi32Type
]
)
declSection
(
[
0
]
)
eventSection
(
[
{
type
:
0
}
{
type
:
1
}
]
)
bodySection
(
[
funcBody
(
{
locals
:
[
]
body
:
fbody
}
)
]
)
]
)
;
}
const
body1
=
[
TryCode
I32Code
I32ConstCode
varU32
(
1
)
CatchCode
varU32
(
1
)
]
;
const
valid1
=
mod_with
(
body1
.
concat
(
[
EndCode
DropCode
ReturnCode
]
)
)
;
const
invalid1
=
mod_with
(
body1
.
concat
(
[
I32ConstCode
varU32
(
2
)
EndCode
DropCode
ReturnCode
]
)
)
;
const
valid2
=
mod_with
(
[
I32ConstCode
varU32
(
0
)
I32ConstCode
varU32
(
0
)
TryCode
varS32
(
2
)
DropCode
DropCode
I32ConstCode
varU32
(
1
)
CatchCode
varU32
(
0
)
I32ConstCode
varU32
(
2
)
EndCode
DropCode
ReturnCode
]
)
;
wasmValid
(
valid1
)
;
wasmInvalid
(
invalid1
/
unused
values
not
explicitly
dropped
/
)
;
wasmValid
(
valid2
)
;
}
function
testValidateCatch
(
)
{
wasmInvalid
(
moduleWithSections
(
[
sigSection
(
[
emptyType
]
)
declSection
(
[
0
]
)
bodySection
(
[
funcBody
(
{
locals
:
[
]
body
:
[
TryCode
VoidCode
CatchCode
varU32
(
0
)
EndCode
]
}
)
]
)
]
)
/
event
index
out
of
range
/
)
;
}
function
testValidateExnPayload
(
)
{
valid0
=
moduleWithSections
(
[
sigSection
(
[
i32Type
i32Toi32Type
]
)
declSection
(
[
1
]
)
eventSection
(
[
{
type
:
0
}
]
)
bodySection
(
[
funcBody
(
{
locals
:
[
]
body
:
[
TryCode
I32Code
LocalGetCode
varU32
(
0
)
ThrowCode
varU32
(
0
)
I32ConstCode
varU32
(
1
)
CatchCode
varU32
(
0
)
I32ConstCode
varU32
(
1
)
I32AddCode
EndCode
]
}
)
]
)
]
)
;
valid1
=
moduleWithSections
(
[
sigSection
(
[
i32Type
toi32Type
]
)
declSection
(
[
1
]
)
eventSection
(
[
{
type
:
0
}
]
)
bodySection
(
[
funcBody
(
{
locals
:
[
]
body
:
[
TryCode
I32Code
I32ConstCode
varU32
(
0
)
I32ConstCode
varU32
(
1
)
ThrowCode
varU32
(
0
)
DropCode
CatchCode
varU32
(
0
)
DropCode
I32ConstCode
varU32
(
2
)
EndCode
]
}
)
]
)
]
)
;
invalid0
=
moduleWithSections
(
[
sigSection
(
[
i32Type
i32Toi64Type
]
)
declSection
(
[
1
]
)
eventSection
(
[
{
type
:
0
}
]
)
bodySection
(
[
funcBody
(
{
locals
:
[
]
body
:
[
TryCode
I64Code
LocalGetCode
varU32
(
0
)
ThrowCode
varU32
(
0
)
I64ConstCode
varU32
(
0
)
CatchCode
varU32
(
0
)
EndCode
]
}
)
]
)
]
)
;
invalid1
=
moduleWithSections
(
[
sigSection
(
[
emptyType
]
)
declSection
(
[
0
]
)
eventSection
(
[
{
type
:
0
}
]
)
bodySection
(
[
funcBody
(
{
locals
:
[
]
body
:
[
TryCode
VoidCode
CatchCode
varU32
(
1
)
EndCode
]
}
)
]
)
]
)
;
wasmValid
(
valid0
)
;
wasmValid
(
valid1
)
;
wasmInvalid
(
invalid0
/
has
type
i32
but
expected
i64
/
)
;
wasmInvalid
(
invalid1
/
event
index
out
of
range
/
)
;
}
function
testValidateExnWithRef
(
)
{
invalid0
=
(
module
(
event
exn
(
param
externref
)
)
(
func
try
nop
catch
exn
drop
end
)
)
;
error0
=
/
exception
with
reference
types
not
supported
/
;
invalid1
=
(
module
(
event
exn
(
param
externref
)
)
(
func
(
param
externref
)
(
local
.
get
0
)
(
throw
exn
)
)
)
;
error1
=
/
exception
with
reference
types
not
supported
/
;
invalid2
=
(
module
(
event
exn
(
param
funcref
)
)
(
func
try
nop
catch
exn
drop
end
)
)
;
error2
=
/
exception
with
reference
types
not
supported
/
;
invalid3
=
(
module
(
event
exn
(
param
funcref
)
)
(
func
(
param
funcref
)
(
local
.
get
0
)
(
throw
exn
)
)
)
;
error3
=
/
exception
with
reference
types
not
supported
/
;
wasmFailValidateText
(
invalid0
error0
)
;
wasmFailValidateText
(
invalid1
error1
)
;
wasmFailValidateText
(
invalid2
error2
)
;
wasmFailValidateText
(
invalid3
error3
)
;
}
testValidateDecode
(
)
;
testValidateThrow
(
)
;
testValidateTryCatch
(
)
;
testValidateCatch
(
)
;
testValidateExnPayload
(
)
;
testValidateExnWithRef
(
)
;
