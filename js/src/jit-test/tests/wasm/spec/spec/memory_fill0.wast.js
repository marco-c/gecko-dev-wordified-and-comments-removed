let
0
=
instantiate
(
(
module
(
memory
\
mem0
0
)
(
memory
\
mem1
0
)
(
memory
\
mem2
1
)
(
func
(
export
"
fill
"
)
(
param
i32
i32
i32
)
(
memory
.
fill
\
mem2
(
local
.
get
0
)
(
local
.
get
1
)
(
local
.
get
2
)
)
)
(
func
(
export
"
load8_u
"
)
(
param
i32
)
(
result
i32
)
(
i32
.
load8_u
\
mem2
(
local
.
get
0
)
)
)
)
)
;
invoke
(
0
fill
[
1
255
3
]
)
;
assert_return
(
(
)
=
>
invoke
(
0
load8_u
[
0
]
)
[
value
(
"
i32
"
0
)
]
)
;
assert_return
(
(
)
=
>
invoke
(
0
load8_u
[
1
]
)
[
value
(
"
i32
"
255
)
]
)
;
assert_return
(
(
)
=
>
invoke
(
0
load8_u
[
2
]
)
[
value
(
"
i32
"
255
)
]
)
;
assert_return
(
(
)
=
>
invoke
(
0
load8_u
[
3
]
)
[
value
(
"
i32
"
255
)
]
)
;
assert_return
(
(
)
=
>
invoke
(
0
load8_u
[
4
]
)
[
value
(
"
i32
"
0
)
]
)
;
invoke
(
0
fill
[
0
48042
2
]
)
;
assert_return
(
(
)
=
>
invoke
(
0
load8_u
[
0
]
)
[
value
(
"
i32
"
170
)
]
)
;
assert_return
(
(
)
=
>
invoke
(
0
load8_u
[
1
]
)
[
value
(
"
i32
"
170
)
]
)
;
invoke
(
0
fill
[
0
0
65536
]
)
;
assert_trap
(
(
)
=
>
invoke
(
0
fill
[
65280
1
257
]
)
out
of
bounds
memory
access
)
;
assert_return
(
(
)
=
>
invoke
(
0
load8_u
[
65280
]
)
[
value
(
"
i32
"
0
)
]
)
;
assert_return
(
(
)
=
>
invoke
(
0
load8_u
[
65535
]
)
[
value
(
"
i32
"
0
)
]
)
;
invoke
(
0
fill
[
65536
0
0
]
)
;
assert_trap
(
(
)
=
>
invoke
(
0
fill
[
65537
0
0
]
)
out
of
bounds
memory
access
)
;
