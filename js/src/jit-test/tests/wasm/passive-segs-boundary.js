function
do_test
(
insn1
insn2
errKind
errText
isMem
haveMemOrTable
)
{
let
preamble
;
if
(
isMem
)
{
let
mem_def
=
haveMemOrTable
?
"
(
memory
1
1
)
"
:
"
"
;
let
mem_init
=
haveMemOrTable
?
(
data
(
i32
.
const
2
)
"
\
\
03
\
\
01
\
\
04
\
\
01
"
)
(
data
passive
"
\
\
02
\
\
07
\
\
01
\
\
08
"
)
(
data
(
i32
.
const
12
)
"
\
\
07
\
\
05
\
\
02
\
\
03
\
\
06
"
)
(
data
passive
"
\
\
05
\
\
09
\
\
02
\
\
07
\
\
06
"
)
:
"
"
;
preamble
=
;
;
-
-
-
-
-
-
-
-
Memories
-
-
-
-
-
-
-
-
{
mem_def
}
;
;
-
-
-
-
-
-
-
-
Memory
initialisers
-
-
-
-
-
-
-
-
{
mem_init
}
;
}
else
{
let
tab_def
=
haveMemOrTable
?
"
(
table
30
30
anyfunc
)
"
:
"
"
;
let
tab_init
=
haveMemOrTable
?
(
elem
(
i32
.
const
2
)
3
1
4
1
)
(
elem
passive
2
7
1
8
)
(
elem
(
i32
.
const
12
)
7
5
2
3
6
)
(
elem
passive
5
9
2
7
6
)
:
"
"
;
preamble
=
;
;
-
-
-
-
-
-
-
-
Tables
-
-
-
-
-
-
-
-
{
tab_def
}
;
;
-
-
-
-
-
-
-
-
Table
initialisers
-
-
-
-
-
-
-
-
{
tab_init
}
;
;
-
-
-
-
-
-
Functions
(
0
.
.
9
)
referred
by
the
table
/
esegs
-
-
-
-
-
-
(
func
(
result
i32
)
(
i32
.
const
0
)
)
(
func
(
result
i32
)
(
i32
.
const
1
)
)
(
func
(
result
i32
)
(
i32
.
const
2
)
)
(
func
(
result
i32
)
(
i32
.
const
3
)
)
(
func
(
result
i32
)
(
i32
.
const
4
)
)
(
func
(
result
i32
)
(
i32
.
const
5
)
)
(
func
(
result
i32
)
(
i32
.
const
6
)
)
(
func
(
result
i32
)
(
i32
.
const
7
)
)
(
func
(
result
i32
)
(
i32
.
const
8
)
)
(
func
(
result
i32
)
(
i32
.
const
9
)
)
;
}
let
txt
=
"
(
module
\
n
"
+
preamble
+
;
;
-
-
-
-
-
-
-
-
testfn
-
-
-
-
-
-
-
-
(
func
(
export
"
testfn
"
)
{
insn1
}
{
insn2
}
)
)
;
if
(
!
!
errKind
)
{
assertErrorMessage
(
(
)
=
>
{
let
inst
=
wasmEvalText
(
txt
)
;
inst
.
exports
.
testfn
(
)
;
}
errKind
errText
)
;
}
else
{
let
inst
=
wasmEvalText
(
txt
)
;
assertEq
(
undefined
inst
.
exports
.
testfn
(
)
)
;
}
}
function
mem_test
(
insn1
insn2
errKind
errText
haveMem
=
true
)
{
do_test
(
insn1
insn2
errKind
errText
true
haveMem
)
;
}
function
mem_test_nofail
(
insn1
insn2
)
{
do_test
(
insn1
insn2
undefined
undefined
true
true
)
;
}
function
tab_test
(
insn1
insn2
errKind
errText
haveTab
=
true
)
{
do_test
(
insn1
insn2
errKind
errText
false
haveTab
)
;
}
function
tab_test_nofail
(
insn1
insn2
)
{
do_test
(
insn1
insn2
undefined
undefined
false
true
)
;
}
mem_test
(
"
data
.
drop
3
"
"
"
WebAssembly
.
CompileError
/
can
'
t
touch
memory
without
memory
/
false
)
;
mem_test
(
"
(
memory
.
init
1
(
i32
.
const
1234
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
"
"
WebAssembly
.
CompileError
/
can
'
t
touch
memory
without
memory
/
false
)
;
mem_test
(
"
data
.
drop
4
"
"
"
WebAssembly
.
CompileError
/
data
.
drop
segment
index
out
of
range
/
)
;
mem_test
(
"
(
memory
.
init
4
(
i32
.
const
1234
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
"
"
WebAssembly
.
CompileError
/
memory
.
init
segment
index
out
of
range
/
)
;
mem_test
(
"
data
.
drop
2
"
"
"
WebAssembly
.
RuntimeError
/
use
of
dropped
data
segment
/
)
;
mem_test
(
"
(
memory
.
init
2
(
i32
.
const
1234
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
"
"
WebAssembly
.
RuntimeError
/
use
of
dropped
data
segment
/
)
;
mem_test_nofail
(
"
(
memory
.
init
1
(
i32
.
const
1234
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
"
(
memory
.
init
1
(
i32
.
const
4321
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
)
;
mem_test
(
"
data
.
drop
1
"
"
data
.
drop
1
"
WebAssembly
.
RuntimeError
/
use
of
dropped
data
segment
/
)
;
mem_test
(
"
data
.
drop
1
"
"
(
memory
.
init
1
(
i32
.
const
1234
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
WebAssembly
.
RuntimeError
/
use
of
dropped
data
segment
/
)
;
mem_test
(
"
"
"
(
memory
.
init
1
(
i32
.
const
1234
)
(
i32
.
const
0
)
(
i32
.
const
5
)
)
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
mem_test
(
"
"
"
(
memory
.
init
1
(
i32
.
const
1234
)
(
i32
.
const
2
)
(
i32
.
const
3
)
)
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
mem_test
(
"
"
"
(
memory
.
init
1
(
i32
.
const
0xFFFE
)
(
i32
.
const
1
)
(
i32
.
const
3
)
)
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
mem_test
(
"
"
"
(
memory
.
init
1
(
i32
.
const
1234
)
(
i32
.
const
4
)
(
i32
.
const
0
)
)
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
mem_test
(
"
"
"
(
memory
.
init
1
(
i32
.
const
0x10000
)
(
i32
.
const
2
)
(
i32
.
const
0
)
)
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
mem_test
(
"
data
.
drop
1
(
i32
.
const
42
)
"
"
"
WebAssembly
.
CompileError
/
unused
values
not
explicitly
dropped
by
end
of
block
/
)
;
mem_test
(
"
(
memory
.
init
1
(
i32
.
const
1
)
(
i32
.
const
1
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
"
"
SyntaxError
/
parsing
wasm
text
at
/
)
;
mem_test
(
"
(
memory
.
init
1
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
"
"
WebAssembly
.
CompileError
/
popping
value
from
empty
stack
/
)
;
{
const
tys
=
[
'
i32
'
'
f32
'
'
i64
'
'
f64
'
]
;
for
(
let
ty1
of
tys
)
{
for
(
let
ty2
of
tys
)
{
for
(
let
ty3
of
tys
)
{
if
(
ty1
=
=
'
i32
'
&
&
ty2
=
=
'
i32
'
&
&
ty3
=
=
'
i32
'
)
continue
;
let
i1
=
(
memory
.
init
1
(
{
ty1
}
.
const
1
)
(
{
ty2
}
.
const
1
)
(
{
ty3
}
.
const
1
)
)
;
mem_test
(
i1
"
"
WebAssembly
.
CompileError
/
type
mismatch
/
)
;
}
}
}
}
const
PAGESIZE
=
65536
;
function
mem_fill
(
min
max
shared
backup
write
=
backup
*
2
)
{
let
ins
=
wasmEvalText
(
(
module
(
memory
(
export
"
mem
"
)
{
min
}
{
max
}
{
shared
}
)
(
func
(
export
"
run
"
)
(
param
offs
i32
)
(
param
val
i32
)
(
param
len
i32
)
(
memory
.
fill
(
get_local
offs
)
(
get_local
val
)
(
get_local
len
)
)
)
)
)
;
let
offs
=
min
*
PAGESIZE
-
backup
;
let
val
=
37
;
assertErrorMessage
(
(
)
=
>
ins
.
exports
.
run
(
offs
val
write
)
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
let
v
=
new
Uint8Array
(
ins
.
exports
.
mem
.
buffer
)
;
for
(
let
i
=
0
;
i
<
backup
;
i
+
+
)
assertEq
(
v
[
offs
+
i
]
val
)
;
for
(
let
i
=
0
;
i
<
offs
;
i
+
+
)
assertEq
(
v
[
i
]
0
)
;
}
mem_fill
(
1
1
"
"
256
)
;
mem_fill
(
1
1
"
"
257
)
;
mem_fill
(
1
1
"
"
257
0xFFFFFFFF
)
;
mem_fill
(
2
4
"
shared
"
256
)
;
mem_fill
(
2
4
"
shared
"
257
)
;
mem_fill
(
2
4
"
shared
"
257
0xFFFFFFFF
)
;
const
mem_init_len
=
16
;
function
mem_init
(
min
max
shared
backup
write
)
{
let
ins
=
wasmEvalText
(
(
module
(
memory
(
export
"
mem
"
)
{
min
}
{
max
}
{
shared
}
)
(
data
passive
"
\
\
42
\
\
42
\
\
42
\
\
42
\
\
42
\
\
42
\
\
42
\
\
42
\
\
42
\
\
42
\
\
42
\
\
42
\
\
42
\
\
42
\
\
42
\
\
42
"
)
(
func
(
export
"
run
"
)
(
param
offs
i32
)
(
param
len
i32
)
(
memory
.
init
0
(
get_local
offs
)
(
i32
.
const
0
)
(
get_local
len
)
)
)
)
)
;
let
offs
=
min
*
PAGESIZE
-
backup
;
assertErrorMessage
(
(
)
=
>
ins
.
exports
.
run
(
offs
write
)
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
let
v
=
new
Uint8Array
(
ins
.
exports
.
mem
.
buffer
)
;
for
(
let
i
=
0
;
i
<
Math
.
min
(
backup
mem_init_len
)
;
i
+
+
)
assertEq
(
v
[
offs
+
i
]
0x42
)
;
for
(
let
i
=
Math
.
min
(
backup
mem_init_len
)
;
i
<
backup
;
i
+
+
)
assertEq
(
v
[
offs
+
i
]
0
)
;
for
(
let
i
=
0
;
i
<
offs
;
i
+
+
)
assertEq
(
v
[
i
]
0
)
;
}
mem_init
(
1
1
"
"
mem_init_len
/
2
mem_init_len
)
;
mem_init
(
1
1
"
"
mem_init_len
/
2
+
1
mem_init_len
)
;
mem_init
(
2
4
"
shared
"
mem_init_len
/
2
mem_init_len
)
;
mem_init
(
2
4
"
shared
"
mem_init_len
/
2
+
1
mem_init_len
)
;
mem_init
(
1
1
"
"
mem_init_len
*
4
mem_init_len
*
2
-
2
)
;
mem_init
(
1
1
"
"
mem_init_len
*
4
-
1
mem_init_len
*
2
-
1
)
;
mem_init
(
2
4
"
shared
"
mem_init_len
*
4
mem_init_len
*
2
-
2
)
;
mem_init
(
2
4
"
shared
"
mem_init_len
*
4
-
1
mem_init_len
*
2
-
1
)
;
mem_init
(
1
"
"
"
"
mem_init_len
/
2
0xFFFFFF00
)
;
mem_init
(
1
"
"
"
"
PAGESIZE
0xFFFFFFFC
)
;
function
mem_copy
(
min
max
shared
srcOffs
targetOffs
len
copyDown
=
false
)
{
let
ins
=
wasmEvalText
(
(
module
(
memory
(
export
"
mem
"
)
{
min
}
{
max
}
{
shared
}
)
(
func
(
export
"
run
"
)
(
param
targetOffs
i32
)
(
param
srcOffs
i32
)
(
param
len
i32
)
(
memory
.
copy
(
get_local
targetOffs
)
(
get_local
srcOffs
)
(
get_local
len
)
)
)
)
)
;
let
v
=
new
Uint8Array
(
ins
.
exports
.
mem
.
buffer
)
;
let
targetAvail
=
v
.
length
-
targetOffs
;
let
srcAvail
=
v
.
length
-
srcOffs
;
let
targetLim
=
targetOffs
+
Math
.
min
(
len
targetAvail
srcAvail
)
;
let
srcLim
=
srcOffs
+
Math
.
min
(
len
targetAvail
srcAvail
)
;
let
immediateOOB
=
copyDown
&
&
(
srcOffs
+
len
>
v
.
length
|
|
targetOffs
+
len
>
v
.
length
)
;
for
(
let
i
=
srcOffs
j
=
0
;
i
<
srcLim
;
i
+
+
j
+
+
)
v
[
i
]
=
j
;
assertErrorMessage
(
(
)
=
>
ins
.
exports
.
run
(
targetOffs
srcOffs
len
)
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
var
t
=
0
;
var
s
=
0
;
var
i
=
0
;
function
checkTarget
(
)
{
if
(
i
>
=
targetOffs
&
&
i
<
targetLim
)
{
assertEq
(
v
[
i
]
(
t
+
+
)
&
0xFF
)
;
if
(
i
>
=
srcOffs
&
&
i
<
srcLim
)
s
+
+
;
return
true
;
}
return
false
;
}
function
checkSource
(
)
{
if
(
i
>
=
srcOffs
&
&
i
<
srcLim
)
{
assertEq
(
v
[
i
]
(
s
+
+
)
&
0xFF
)
;
if
(
i
>
=
targetOffs
&
&
i
<
targetLim
)
t
+
+
;
return
true
;
}
return
false
;
}
for
(
i
=
0
;
i
<
v
.
length
;
i
+
+
)
{
if
(
immediateOOB
)
{
if
(
checkSource
(
)
)
continue
;
}
else
{
if
(
copyDown
&
&
(
checkSource
(
)
|
|
checkTarget
(
)
)
)
continue
;
if
(
!
copyDown
&
&
(
checkTarget
(
)
|
|
checkSource
(
)
)
)
continue
;
}
assertEq
(
v
[
i
]
0
)
;
}
}
mem_copy
(
1
1
"
"
0
PAGESIZE
-
20
40
)
;
mem_copy
(
1
1
"
"
0
PAGESIZE
-
21
39
)
;
mem_copy
(
2
4
"
shared
"
0
2
*
PAGESIZE
-
20
40
)
;
mem_copy
(
2
4
"
shared
"
0
2
*
PAGESIZE
-
21
39
)
;
mem_copy
(
1
1
"
"
PAGESIZE
-
20
0
40
)
;
mem_copy
(
1
1
"
"
PAGESIZE
-
21
0
39
)
;
mem_copy
(
2
4
"
shared
"
2
*
PAGESIZE
-
20
0
40
)
;
mem_copy
(
2
4
"
shared
"
2
*
PAGESIZE
-
21
0
39
)
;
mem_copy
(
1
1
"
"
PAGESIZE
-
50
PAGESIZE
-
20
40
true
)
;
mem_copy
(
1
1
"
"
PAGESIZE
-
20
PAGESIZE
-
50
40
)
;
mem_copy
(
1
1
"
"
PAGESIZE
-
30
PAGESIZE
-
20
40
true
)
;
mem_copy
(
1
1
"
"
PAGESIZE
-
20
PAGESIZE
-
30
40
)
;
mem_copy
(
1
1
"
"
PAGESIZE
-
20
PAGESIZE
-
20
40
)
;
mem_copy
(
1
"
"
"
"
PAGESIZE
-
20
0
0xFFFFF000
)
;
mem_copy
(
1
1
"
"
PAGESIZE
-
0x1000
PAGESIZE
-
20
0xFFFFFF00
true
)
;
tab_test
(
"
elem
.
drop
3
"
"
"
WebAssembly
.
CompileError
/
can
'
t
elem
.
drop
without
a
table
/
false
)
;
tab_test
(
"
(
table
.
init
1
(
i32
.
const
12
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
"
"
WebAssembly
.
CompileError
/
table
index
out
of
range
/
false
)
;
tab_test
(
"
elem
.
drop
4
"
"
"
WebAssembly
.
CompileError
/
element
segment
index
out
of
range
for
elem
.
drop
/
)
;
tab_test
(
"
(
table
.
init
4
(
i32
.
const
12
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
"
"
WebAssembly
.
CompileError
/
table
.
init
segment
index
out
of
range
/
)
;
tab_test
(
"
elem
.
drop
2
"
"
"
WebAssembly
.
RuntimeError
/
use
of
dropped
element
segment
/
)
;
tab_test
(
"
(
table
.
init
2
(
i32
.
const
12
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
"
"
WebAssembly
.
RuntimeError
/
use
of
dropped
element
segment
/
)
;
tab_test_nofail
(
"
(
table
.
init
1
(
i32
.
const
12
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
"
(
table
.
init
1
(
i32
.
const
21
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
)
;
tab_test
(
"
elem
.
drop
1
"
"
elem
.
drop
1
"
WebAssembly
.
RuntimeError
/
use
of
dropped
element
segment
/
)
;
tab_test
(
"
elem
.
drop
1
"
"
(
table
.
init
1
(
i32
.
const
12
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
WebAssembly
.
RuntimeError
/
use
of
dropped
element
segment
/
)
;
tab_test
(
"
"
"
(
table
.
init
1
(
i32
.
const
12
)
(
i32
.
const
0
)
(
i32
.
const
5
)
)
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
tab_test
(
"
"
"
(
table
.
init
1
(
i32
.
const
12
)
(
i32
.
const
2
)
(
i32
.
const
3
)
)
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
tab_test
(
"
"
"
(
table
.
init
1
(
i32
.
const
28
)
(
i32
.
const
1
)
(
i32
.
const
3
)
)
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
tab_test
(
"
"
"
(
table
.
init
1
(
i32
.
const
12
)
(
i32
.
const
4
)
(
i32
.
const
0
)
)
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
tab_test
(
"
"
"
(
table
.
init
1
(
i32
.
const
30
)
(
i32
.
const
2
)
(
i32
.
const
0
)
)
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
tab_test
(
"
elem
.
drop
1
(
i32
.
const
42
)
"
"
"
WebAssembly
.
CompileError
/
unused
values
not
explicitly
dropped
by
end
of
block
/
)
;
tab_test
(
"
(
table
.
init
1
(
i32
.
const
1
)
(
i32
.
const
1
)
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
"
"
SyntaxError
/
parsing
wasm
text
at
/
)
;
tab_test
(
"
(
table
.
init
1
(
i32
.
const
1
)
(
i32
.
const
1
)
)
"
"
"
WebAssembly
.
CompileError
/
popping
value
from
empty
stack
/
)
;
{
const
tys
=
[
'
i32
'
'
f32
'
'
i64
'
'
f64
'
]
;
const
ops
=
[
'
table
.
init
1
'
'
table
.
copy
'
]
;
for
(
let
ty1
of
tys
)
{
for
(
let
ty2
of
tys
)
{
for
(
let
ty3
of
tys
)
{
for
(
let
op
of
ops
)
{
if
(
ty1
=
=
'
i32
'
&
&
ty2
=
=
'
i32
'
&
&
ty3
=
=
'
i32
'
)
continue
;
let
i1
=
(
{
op
}
(
{
ty1
}
.
const
1
)
(
{
ty2
}
.
const
1
)
(
{
ty3
}
.
const
1
)
)
;
tab_test
(
i1
"
"
WebAssembly
.
CompileError
/
type
mismatch
/
)
;
}
}
}
}
}
tab_test
(
"
(
table
.
copy
(
i32
.
const
28
)
(
i32
.
const
1
)
(
i32
.
const
3
)
)
"
"
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
tab_test
(
"
(
table
.
copy
(
i32
.
const
0xFFFFFFFE
)
(
i32
.
const
1
)
(
i32
.
const
2
)
)
"
"
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
tab_test
(
"
(
table
.
copy
(
i32
.
const
15
)
(
i32
.
const
25
)
(
i32
.
const
6
)
)
"
"
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
tab_test
(
"
(
table
.
copy
(
i32
.
const
15
)
(
i32
.
const
0xFFFFFFFE
)
(
i32
.
const
2
)
)
"
"
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
tab_test_nofail
(
"
(
table
.
copy
(
i32
.
const
15
)
(
i32
.
const
25
)
(
i32
.
const
0
)
)
"
"
"
)
;
tab_test
(
"
(
table
.
copy
(
i32
.
const
30
)
(
i32
.
const
15
)
(
i32
.
const
0
)
)
"
"
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
tab_test
(
"
(
table
.
copy
(
i32
.
const
15
)
(
i32
.
const
30
)
(
i32
.
const
0
)
)
"
"
"
WebAssembly
.
RuntimeError
/
index
out
of
bounds
/
)
;
