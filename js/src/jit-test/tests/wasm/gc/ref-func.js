load
(
libdir
+
"
wasm
-
binary
.
js
"
)
;
const
v2vSig
=
{
args
:
[
]
ret
:
VoidCode
}
;
const
v2vSigSection
=
sigSection
(
[
v2vSig
]
)
;
wasmFullPass
(
(
module
(
elem
declare
run
)
(
func
run
(
result
i32
)
ref
.
func
run
ref
.
is_null
)
(
export
"
run
"
(
func
run
)
)
)
0
)
;
{
let
{
f1
}
=
wasmEvalText
(
(
module
(
elem
declare
f1
)
(
func
f1
(
result
funcref
)
ref
.
func
f1
)
(
export
"
f1
"
(
func
f1
)
)
)
)
.
exports
;
assertEq
(
f1
(
)
f1
)
;
}
{
let
{
f1
f2
}
=
wasmEvalText
(
(
module
(
elem
declare
f1
)
(
func
f1
)
(
func
f2
(
result
funcref
)
ref
.
func
f1
)
(
export
"
f1
"
(
func
f1
)
)
(
export
"
f2
"
(
func
f2
)
)
)
)
.
exports
;
assertEq
(
f2
(
)
f1
)
;
}
{
let
i1
=
wasmEvalText
(
(
module
(
elem
declare
f1
)
(
func
f1
)
(
export
"
f1
"
(
func
f1
)
)
)
)
;
let
i2
=
wasmEvalText
(
(
module
(
import
"
"
"
f1
"
(
func
f1
)
)
(
elem
declare
f1
)
(
func
f2
(
result
funcref
)
ref
.
func
f1
)
(
export
"
f1
"
(
func
f1
)
)
(
export
"
f2
"
(
func
f2
)
)
)
{
"
"
:
i1
.
exports
}
)
;
let
f1
=
i1
.
exports
.
f1
;
let
f2
=
i2
.
exports
.
f2
;
assertEq
(
f2
(
)
f1
)
;
}
assertErrorMessage
(
(
)
=
>
{
wasmEvalText
(
(
module
(
func
(
result
funcref
)
ref
.
func
10
)
)
)
;
}
WebAssembly
.
CompileError
/
function
index
out
of
range
/
)
;
function
validFuncRefText
(
forwardDeclare
tbl_type
)
{
return
wasmEvalText
(
(
module
(
table
1
{
tbl_type
}
)
(
func
test
(
result
funcref
)
ref
.
func
referenced
)
(
func
referenced
)
{
forwardDeclare
}
)
)
;
}
assertErrorMessage
(
(
)
=
>
validFuncRefText
(
'
'
'
funcref
'
)
WebAssembly
.
CompileError
/
function
index
is
not
in
an
element
segment
/
)
;
assertEq
(
validFuncRefText
(
'
(
elem
0
(
i32
.
const
0
)
func
referenced
)
'
'
funcref
'
)
instanceof
WebAssembly
.
Instance
true
)
;
assertEq
(
validFuncRefText
(
'
(
elem
func
referenced
)
'
'
funcref
'
)
instanceof
WebAssembly
.
Instance
true
)
;
assertEq
(
validFuncRefText
(
'
(
elem
declare
referenced
)
'
'
funcref
'
)
instanceof
WebAssembly
.
Instance
true
)
;
assertEq
(
validFuncRefText
(
'
(
elem
0
(
i32
.
const
0
)
anyref
(
ref
.
func
referenced
)
)
'
'
anyref
'
)
instanceof
WebAssembly
.
Instance
true
)
;
assertEq
(
validFuncRefText
(
'
(
elem
anyref
(
ref
.
func
referenced
)
)
'
'
anyref
'
)
instanceof
WebAssembly
.
Instance
true
)
;
assertErrorMessage
(
(
)
=
>
validFuncRefText
(
'
(
start
referenced
)
'
'
funcref
'
)
WebAssembly
.
CompileError
/
function
index
is
not
in
an
element
segment
/
)
;
assertErrorMessage
(
(
)
=
>
validFuncRefText
(
'
(
export
"
referenced
"
(
func
referenced
)
)
'
'
funcref
'
)
WebAssembly
.
CompileError
/
function
index
is
not
in
an
element
segment
/
)
;
assertErrorMessage
(
(
)
=
>
new
WebAssembly
.
Module
(
moduleWithSections
(
[
generalElemSection
(
[
{
flag
:
PassiveElemExpr
typeCode
:
I32Code
elems
:
[
]
}
]
)
]
)
)
WebAssembly
.
CompileError
/
segments
with
element
expressions
can
only
contain
references
/
)
;
assertErrorMessage
(
(
)
=
>
new
WebAssembly
.
Module
(
moduleWithSections
(
[
generalElemSection
(
[
{
flag
:
DeclaredElemExpr
typeCode
:
AnyrefCode
elems
:
[
]
}
]
)
]
)
)
WebAssembly
.
CompileError
/
declared
segment
'
s
element
type
must
be
subtype
of
funcref
/
)
;
var
ins
=
new
WebAssembly
.
Instance
(
new
WebAssembly
.
Module
(
wasmTextToBinary
(
(
module
(
import
"
m
"
"
f
"
(
func
f
(
param
i32
)
(
result
i32
)
)
)
(
elem
declare
f
)
(
table
1
funcref
)
(
func
(
export
"
f
"
)
(
table
.
set
0
(
i32
.
const
0
)
(
ref
.
func
f
)
)
)
)
)
)
{
m
:
{
f
:
(
x
)
=
>
37
+
x
}
}
)
;
ins
.
exports
.
f
(
)
;
function
checkPassiveElemSegment
(
mangle
err
)
{
let
bin
=
moduleWithSections
(
[
v2vSigSection
declSection
(
[
0
]
)
tableSection
(
1
)
{
name
:
elemId
body
:
(
function
(
)
{
let
body
=
[
]
;
body
.
push
(
1
)
;
body
.
push
(
0x1
|
0x4
)
;
body
.
push
(
AnyFuncCode
+
(
mangle
=
=
"
type
"
?
1
:
0
)
)
;
body
.
push
(
1
)
;
body
.
push
(
RefFuncCode
+
(
mangle
=
=
"
ref
.
func
"
?
1
:
0
)
)
;
body
.
push
(
0
)
;
body
.
push
(
EndCode
+
(
mangle
=
=
"
end
"
?
1
:
0
)
)
;
return
body
;
}
)
(
)
}
bodySection
(
[
funcBody
(
{
locals
:
[
]
body
:
[
]
}
)
]
)
]
)
;
if
(
err
)
{
assertErrorMessage
(
(
)
=
>
new
WebAssembly
.
Module
(
bin
)
WebAssembly
.
CompileError
err
)
;
}
else
{
new
WebAssembly
.
Module
(
bin
)
;
}
}
checkPassiveElemSegment
(
"
"
)
;
checkPassiveElemSegment
(
"
type
"
/
segments
with
element
expressions
can
only
contain
references
/
)
;
checkPassiveElemSegment
(
"
ref
.
func
"
/
failed
to
read
initializer
operation
/
)
;
checkPassiveElemSegment
(
"
end
"
/
failed
to
read
end
of
initializer
expression
/
)
;
{
let
txt
=
(
module
(
table
(
export
"
t
"
)
10
funcref
)
(
elem
(
i32
.
const
1
)
m
)
(
elem
(
i32
.
const
3
)
m
)
(
elem
(
i32
.
const
6
)
m
)
(
elem
(
i32
.
const
8
)
m
)
(
elem
funcref
(
ref
.
func
f
)
(
ref
.
null
)
(
ref
.
func
g
)
(
ref
.
null
)
(
ref
.
func
h
)
)
(
func
m
)
(
func
f
)
(
func
g
)
(
func
h
)
(
func
(
export
"
doit
"
)
(
param
idx
i32
)
(
table
.
init
4
(
local
.
get
idx
)
(
i32
.
const
0
)
(
i32
.
const
5
)
)
)
)
;
let
ins
=
wasmEvalText
(
txt
)
;
ins
.
exports
.
doit
(
0
)
;
ins
.
exports
.
doit
(
5
)
;
assertEq
(
typeof
ins
.
exports
.
t
.
get
(
0
)
"
function
"
)
;
assertEq
(
ins
.
exports
.
t
.
get
(
1
)
null
)
;
assertEq
(
typeof
ins
.
exports
.
t
.
get
(
2
)
"
function
"
)
;
assertEq
(
ins
.
exports
.
t
.
get
(
0
)
=
=
ins
.
exports
.
t
.
get
(
2
)
false
)
;
assertEq
(
ins
.
exports
.
t
.
get
(
3
)
null
)
;
assertEq
(
typeof
ins
.
exports
.
t
.
get
(
4
)
"
function
"
)
;
assertEq
(
typeof
ins
.
exports
.
t
.
get
(
5
)
"
function
"
)
;
assertEq
(
ins
.
exports
.
t
.
get
(
6
)
null
)
;
assertEq
(
typeof
ins
.
exports
.
t
.
get
(
7
)
"
function
"
)
;
assertEq
(
ins
.
exports
.
t
.
get
(
8
)
null
)
;
assertEq
(
typeof
ins
.
exports
.
t
.
get
(
9
)
"
function
"
)
;
}
for
(
let
mutable
of
[
true
false
]
)
{
for
(
let
imported
of
[
true
false
]
)
{
for
(
let
exported
of
[
true
false
]
)
{
let
globalType
=
mutable
?
(
mut
funcref
)
:
funcref
;
let
imports
=
{
}
;
if
(
imported
)
{
imports
=
wasmEvalText
(
(
module
(
global
g
(
export
"
g
"
)
{
globalType
}
(
ref
.
func
f
)
)
(
func
f
(
export
"
f
"
)
(
result
i32
)
i32
.
const
42
)
)
)
.
exports
;
}
let
exports
=
wasmEvalText
(
(
module
(
global
g
{
exported
?
(
export
"
g
"
)
:
}
{
imported
?
(
import
"
"
"
g
"
)
:
}
{
globalType
}
{
imported
?
:
(
ref
.
func
f
)
}
)
{
exported
?
:
(
func
(
export
"
get_g
"
)
(
result
funcref
)
global
.
get
g
)
}
(
func
f
(
export
"
f
"
)
(
result
i32
)
i32
.
const
42
)
)
{
"
"
:
imports
}
)
.
exports
;
let
targetFunc
=
imported
?
imports
.
f
:
exports
.
f
;
let
globalVal
=
exported
?
exports
.
g
.
value
:
exports
.
get_g
(
)
;
assertEq
(
targetFunc
(
)
42
)
;
assertEq
(
globalVal
(
)
42
)
;
assertEq
(
targetFunc
globalVal
)
;
if
(
imported
&
&
exported
)
{
assertEq
(
imports
.
g
exports
.
g
)
;
}
}
}
}
