load
(
libdir
+
"
wasm
-
binary
.
js
"
)
;
wasmFullPass
(
(
module
(
elem
declared
run
)
(
func
run
(
result
i32
)
ref
.
func
run
ref
.
is_null
)
(
export
"
run
"
run
)
)
0
)
;
{
let
{
f1
}
=
wasmEvalText
(
(
module
(
elem
declared
f1
)
(
func
f1
(
result
funcref
)
ref
.
func
f1
)
(
export
"
f1
"
f1
)
)
)
.
exports
;
assertEq
(
f1
(
)
f1
)
;
}
{
let
{
f1
f2
}
=
wasmEvalText
(
(
module
(
elem
declared
f1
)
(
func
f1
)
(
func
f2
(
result
funcref
)
ref
.
func
f1
)
(
export
"
f1
"
f1
)
(
export
"
f2
"
f2
)
)
)
.
exports
;
assertEq
(
f2
(
)
f1
)
;
}
{
let
i1
=
wasmEvalText
(
(
module
(
elem
declared
f1
)
(
func
f1
)
(
export
"
f1
"
f1
)
)
)
;
let
i2
=
wasmEvalText
(
(
module
(
import
f1
"
"
"
f1
"
(
func
)
)
(
elem
declared
f1
)
(
func
f2
(
result
funcref
)
ref
.
func
f1
)
(
export
"
f1
"
f1
)
(
export
"
f2
"
f2
)
)
{
"
"
:
i1
.
exports
}
)
;
let
f1
=
i1
.
exports
.
f1
;
let
f2
=
i2
.
exports
.
f2
;
assertEq
(
f2
(
)
f1
)
;
}
assertErrorMessage
(
(
)
=
>
{
wasmEvalText
(
(
module
(
func
(
result
funcref
)
ref
.
func
10
)
)
)
;
}
WebAssembly
.
CompileError
/
function
index
out
of
range
/
)
;
function
validFuncRefText
(
forwardDeclare
tbl_type
)
{
return
wasmEvalText
(
(
module
(
table
1
{
tbl_type
}
)
(
func
test
(
result
funcref
)
ref
.
func
referenced
)
(
func
referenced
)
{
forwardDeclare
}
)
)
;
}
assertErrorMessage
(
(
)
=
>
validFuncRefText
(
'
'
'
funcref
'
)
WebAssembly
.
CompileError
/
function
index
is
not
in
an
element
segment
/
)
;
assertEq
(
validFuncRefText
(
'
(
elem
0
(
i32
.
const
0
)
func
referenced
)
'
'
funcref
'
)
instanceof
WebAssembly
.
Instance
true
)
;
assertEq
(
validFuncRefText
(
'
(
elem
func
referenced
)
'
'
funcref
'
)
instanceof
WebAssembly
.
Instance
true
)
;
assertEq
(
validFuncRefText
(
'
(
elem
declared
referenced
)
'
'
funcref
'
)
instanceof
WebAssembly
.
Instance
true
)
;
assertEq
(
validFuncRefText
(
'
(
elem
0
(
i32
.
const
0
)
anyref
(
ref
.
func
referenced
)
)
'
'
anyref
'
)
instanceof
WebAssembly
.
Instance
true
)
;
assertEq
(
validFuncRefText
(
'
(
elem
anyref
(
ref
.
func
referenced
)
)
'
'
anyref
'
)
instanceof
WebAssembly
.
Instance
true
)
;
assertErrorMessage
(
(
)
=
>
validFuncRefText
(
'
(
start
referenced
)
'
'
funcref
'
)
WebAssembly
.
CompileError
/
function
index
is
not
in
an
element
segment
/
)
;
assertErrorMessage
(
(
)
=
>
validFuncRefText
(
'
(
export
"
referenced
"
referenced
)
'
'
funcref
'
)
WebAssembly
.
CompileError
/
function
index
is
not
in
an
element
segment
/
)
;
assertErrorMessage
(
(
)
=
>
new
WebAssembly
.
Module
(
moduleWithSections
(
[
generalElemSection
(
[
{
flag
:
PassiveElemExpr
typeCode
:
I32Code
elems
:
[
]
}
]
)
]
)
)
WebAssembly
.
CompileError
/
segments
with
element
expressions
can
only
contain
references
/
)
;
assertErrorMessage
(
(
)
=
>
new
WebAssembly
.
Module
(
moduleWithSections
(
[
generalElemSection
(
[
{
flag
:
DeclaredElemExpr
typeCode
:
AnyrefCode
elems
:
[
]
}
]
)
]
)
)
WebAssembly
.
CompileError
/
declared
segment
'
s
element
type
must
be
subtype
of
funcref
/
)
;
assertErrorMessage
(
(
)
=
>
new
WebAssembly
.
Module
(
moduleWithSections
(
[
generalElemSection
(
[
{
flag
:
DeclaredElemExpr
typeCode
:
AnyFuncCode
elems
:
[
[
RefNullCode
]
]
}
]
)
]
)
)
WebAssembly
.
CompileError
/
declared
element
segments
cannot
contain
ref
.
null
/
)
;
var
ins
=
new
WebAssembly
.
Instance
(
new
WebAssembly
.
Module
(
wasmTextToBinary
(
(
module
(
import
f
"
m
"
"
f
"
(
func
(
param
i32
)
(
result
i32
)
)
)
(
elem
declared
f
)
(
table
1
funcref
)
(
func
(
export
"
f
"
)
(
table
.
set
0
(
i32
.
const
0
)
(
ref
.
func
f
)
)
)
)
)
)
{
m
:
{
f
:
(
x
)
=
>
37
+
x
}
}
)
;
ins
.
exports
.
f
(
)
;
