load
(
libdir
+
"
wasm
-
binary
.
js
"
)
;
const
specificTest
=
'
'
;
const
preamble
=
(
type
s1
(
sub
(
struct
)
)
)
(
type
s2
(
sub
s1
(
struct
(
field
i32
)
)
)
)
(
type
a1
(
sub
(
array
(
ref
null
s1
)
)
)
)
(
type
a2
(
sub
a1
(
array
(
ref
null
s2
)
)
)
)
(
type
f1
(
func
)
)
(
func
f
(
type
f1
)
)
(
elem
declare
func
f
)
;
;
allow
f
to
be
ref
.
func
'
d
;
const
preambleTypesV5
=
[
{
kind
:
StructCode
fields
:
[
]
}
{
kind
:
StructCode
sub
:
0
fields
:
[
I32Code
]
}
{
kind
:
ArrayCode
elem
:
[
OptRefCode
.
.
.
varU32
(
0
)
]
}
{
kind
:
ArrayCode
sub
:
2
elem
:
[
OptRefCode
.
.
.
varU32
(
1
)
]
}
]
const
subtypes
=
[
[
'
s2
'
'
s1
'
]
[
'
a2
'
'
a1
'
]
]
;
const
s1
=
{
index
:
0
name
:
'
s1
'
make
:
'
struct
.
new_default
s1
'
makeV5
:
[
0xfb
0x08
.
.
.
varU32
(
0
)
]
}
;
const
s2
=
{
index
:
1
name
:
'
s2
'
make
:
'
struct
.
new_default
s2
'
makeV5
:
[
0xfb
0x08
.
.
.
varU32
(
1
)
]
}
;
const
a1
=
{
index
:
2
name
:
'
a1
'
make
:
'
(
array
.
new_default
a1
(
i32
.
const
10
)
)
'
makeV5
:
[
I32ConstCode
.
.
.
varS32
(
10
)
0xfb
0x1c
.
.
.
varU32
(
2
)
]
}
;
const
a2
=
{
index
:
3
name
:
'
a2
'
make
:
'
(
array
.
new_default
a2
(
i32
.
const
10
)
)
'
makeV5
:
[
I32ConstCode
.
.
.
varS32
(
10
)
0xfb
0x1c
.
.
.
varU32
(
3
)
]
}
;
const
typeSets
=
[
[
{
name
:
'
any
'
}
{
name
:
'
eq
'
}
{
name
:
'
struct
'
}
s1
s2
{
name
:
'
none
'
none
:
true
}
]
[
{
name
:
'
any
'
}
{
name
:
'
eq
'
}
{
name
:
'
array
'
}
a1
a2
{
name
:
'
none
'
none
:
true
}
]
[
{
name
:
'
any
'
}
{
name
:
'
eq
'
}
s1
s2
a1
a2
{
name
:
'
none
'
none
:
true
}
]
]
;
const
nullables
=
[
[
true
true
true
]
[
true
true
false
]
[
true
false
true
]
[
true
false
false
]
[
false
true
true
]
[
false
true
false
]
[
false
false
true
]
[
false
false
false
]
]
function
isSubtype
(
src
dest
)
{
if
(
src
.
name
=
=
=
dest
.
name
)
{
return
true
;
}
for
(
const
[
src2
dest2
]
of
subtypes
)
{
if
(
src
.
name
=
=
=
src2
&
&
dest
.
name
=
=
=
dest2
)
{
return
true
;
}
}
return
false
;
}
let
numCases
=
0
;
for
(
const
typeSet
of
typeSets
)
{
for
(
const
start
of
typeSet
)
{
for
(
const
middle
of
typeSet
)
{
for
(
const
end
of
typeSet
)
{
for
(
const
[
nullable0
nullable1
nullable2
]
of
nullables
)
{
for
(
const
makeNull
of
[
true
false
]
)
{
const
concrete0
=
!
!
start
.
make
;
const
concrete1
=
!
!
middle
.
make
;
const
concrete2
=
!
!
end
.
make
;
if
(
!
concrete0
&
&
!
makeNull
)
{
continue
;
}
if
(
!
nullable0
&
&
makeNull
)
{
continue
;
}
numCases
+
=
1
;
let
good1
=
true
;
let
good2
=
true
;
if
(
makeNull
)
{
if
(
!
nullable1
)
{
good1
=
false
;
}
if
(
!
nullable2
)
{
good2
=
false
;
}
}
if
(
!
makeNull
)
{
if
(
middle
.
none
)
{
good1
=
false
;
}
if
(
end
.
none
)
{
good2
=
false
;
}
}
if
(
!
makeNull
)
{
if
(
concrete1
&
&
!
isSubtype
(
start
middle
)
)
{
good1
=
false
;
}
if
(
concrete2
&
&
!
isSubtype
(
start
end
)
)
{
good2
=
false
;
}
}
let
doV5
=
concrete0
&
&
concrete1
&
&
concrete2
;
if
(
(
nullable0
&
&
!
nullable1
)
|
|
(
nullable1
&
&
!
nullable2
)
)
{
doV5
=
false
;
}
let
emoji1
=
good1
?
'
'
:
'
'
;
let
emoji2
=
good2
?
'
'
:
'
'
;
if
(
!
good1
)
{
good2
=
false
;
emoji2
=
'
'
;
}
const
name
=
{
makeNull
?
'
null
'
:
'
non
-
null
'
}
(
ref
{
nullable0
?
'
null
'
:
'
'
}
{
start
.
name
}
)
-
>
(
ref
{
nullable1
?
'
null
'
:
'
'
}
{
middle
.
name
}
)
-
>
(
ref
{
nullable2
?
'
null
'
:
'
'
}
{
end
.
name
}
)
;
if
(
specificTest
&
&
name
!
=
specificTest
)
{
continue
;
}
print
(
{
emoji1
}
{
emoji2
}
{
name
}
)
;
const
make
=
makeNull
?
ref
.
null
{
start
.
name
}
:
start
.
make
;
const
type1
=
(
ref
{
nullable1
?
'
null
'
:
'
'
}
{
middle
.
name
}
)
;
const
type2
=
(
ref
{
nullable2
?
'
null
'
:
'
'
}
{
end
.
name
}
)
;
const
moduleText
=
(
module
{
preamble
}
(
func
(
export
"
cast1
"
)
(
result
{
type1
}
)
{
make
}
ref
.
cast
{
type1
}
)
(
func
(
export
"
cast2
"
)
(
param
{
type1
}
)
(
result
{
type2
}
)
local
.
get
0
ref
.
cast
{
type2
}
)
(
func
(
export
"
test1
"
)
(
result
i32
)
{
make
}
ref
.
test
{
type1
}
)
(
func
(
export
"
test2
"
)
(
param
{
type1
}
)
(
result
i32
)
local
.
get
0
ref
.
test
{
type2
}
)
;
;
these
are
basically
ref
.
test
but
with
branches
(
func
(
export
"
branch1
"
)
(
result
i32
)
(
block
(
result
{
type1
}
)
{
make
}
br_on_cast
0
anyref
{
type1
}
drop
(
return
(
i32
.
const
0
)
)
)
drop
(
return
(
i32
.
const
1
)
)
)
(
func
(
export
"
branch2
"
)
(
param
{
type1
}
)
(
result
i32
)
(
block
(
result
{
type2
}
)
local
.
get
0
br_on_cast
0
anyref
{
type2
}
drop
(
return
(
i32
.
const
0
)
)
)
drop
(
return
(
i32
.
const
1
)
)
)
(
func
(
export
"
branchfail1
"
)
(
result
i32
)
(
block
(
result
anyref
)
{
make
}
br_on_cast_fail
0
anyref
{
type1
}
drop
(
return
(
i32
.
const
1
)
)
)
drop
(
return
(
i32
.
const
0
)
)
)
(
func
(
export
"
branchfail2
"
)
(
param
{
type1
}
)
(
result
i32
)
(
block
(
result
anyref
)
local
.
get
0
br_on_cast_fail
0
anyref
{
type2
}
drop
(
return
(
i32
.
const
1
)
)
)
drop
(
return
(
i32
.
const
0
)
)
)
)
;
let
v5ModuleBytes
;
if
(
doV5
)
{
const
makeV5
=
makeNull
?
[
RefNullCode
.
.
.
varS32
(
start
.
index
)
]
:
start
.
makeV5
;
const
type1v5
=
[
nullable1
?
OptRefCode
:
RefCode
.
.
.
varS32
(
middle
.
index
)
]
;
const
type2v5
=
[
nullable2
?
OptRefCode
:
RefCode
.
.
.
varS32
(
end
.
index
)
]
;
print
(
"
t2
"
type2v5
)
v5ModuleBytes
=
moduleWithSections
(
[
typeSection
(
[
.
.
.
preambleTypesV5
{
kind
:
FuncCode
args
:
[
]
ret
:
[
type1v5
]
}
{
kind
:
FuncCode
args
:
[
type1v5
]
ret
:
[
type2v5
]
}
{
kind
:
FuncCode
args
:
[
]
ret
:
[
I32Code
]
}
{
kind
:
FuncCode
args
:
[
type1v5
]
ret
:
[
I32Code
]
}
]
)
declSection
(
[
4
5
6
7
]
)
exportSection
(
[
{
funcIndex
:
0
name
:
"
cast1V5
"
}
{
funcIndex
:
1
name
:
"
cast2V5
"
}
{
funcIndex
:
2
name
:
"
test1V5
"
}
{
funcIndex
:
3
name
:
"
test2V5
"
}
]
)
bodySection
(
[
funcBody
(
{
locals
:
[
]
body
:
[
.
.
.
makeV5
0xfb
0x45
.
.
.
varU32
(
middle
.
index
)
]
}
)
funcBody
(
{
locals
:
[
]
body
:
[
LocalGetCode
.
.
.
varU32
(
0
)
0xfb
0x45
.
.
.
varU32
(
end
.
index
)
]
}
)
funcBody
(
{
locals
:
[
]
body
:
[
.
.
.
makeV5
0xfb
0x44
.
.
.
varU32
(
middle
.
index
)
]
}
)
funcBody
(
{
locals
:
[
]
body
:
[
LocalGetCode
.
.
.
varU32
(
0
)
0xfb
0x44
.
.
.
varU32
(
end
.
index
)
]
}
)
]
)
]
)
;
}
function
assertCast
(
func
good
)
{
if
(
good
)
{
return
[
func
(
)
true
]
;
}
else
{
assertErrorMessage
(
func
WebAssembly
.
RuntimeError
/
bad
cast
/
)
;
return
[
null
false
]
;
}
}
try
{
const
{
cast1
cast2
test1
test2
branch1
branch2
branchfail1
branchfail2
}
=
wasmEvalText
(
moduleText
)
.
exports
;
const
[
res1
ok1
]
=
assertCast
(
cast1
good1
)
;
assertEq
(
test1
(
)
good1
?
1
:
0
)
;
assertEq
(
branch1
(
)
good1
?
1
:
0
)
;
assertEq
(
branchfail1
(
)
good1
?
1
:
0
)
;
if
(
ok1
)
{
assertCast
(
(
)
=
>
cast2
(
res1
)
good2
)
;
assertEq
(
test2
(
res1
)
good2
?
1
:
0
)
;
assertEq
(
branch2
(
res1
)
good2
?
1
:
0
)
;
assertEq
(
branchfail2
(
res1
)
good2
?
1
:
0
)
;
}
}
catch
(
e
)
{
print
(
"
Failed
!
Module
text
was
:
"
)
;
print
(
moduleText
)
;
throw
e
;
}
if
(
doV5
)
{
try
{
const
{
cast1V5
cast2V5
test1V5
test2V5
}
=
new
WebAssembly
.
Instance
(
new
WebAssembly
.
Module
(
v5ModuleBytes
)
)
.
exports
;
const
[
res1
ok1
]
=
assertCast
(
cast1V5
good1
)
;
assertEq
(
test1V5
(
)
(
good1
&
&
!
makeNull
)
?
1
:
0
)
;
if
(
ok1
)
{
assertCast
(
(
)
=
>
cast2V5
(
res1
)
good2
)
;
assertEq
(
test2V5
(
res1
)
(
good2
&
&
!
makeNull
)
?
1
:
0
)
;
}
}
catch
(
e
)
{
print
(
"
Failed
v5
encoding
test
!
Sadly
we
have
no
module
text
for
you
but
here
are
the
bytes
:
"
)
;
print
(
v5ModuleBytes
)
;
throw
e
;
}
}
}
}
}
}
}
}
print
(
we
hope
you
have
enjoyed
these
{
numCases
}
test
cases
)
;
