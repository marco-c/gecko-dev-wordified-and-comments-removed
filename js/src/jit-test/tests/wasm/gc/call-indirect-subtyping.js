const
TESTS
=
[
{
type
:
(
type
(
sub
(
func
)
)
)
subtypeOf
:
[
0
1
]
}
{
type
:
(
rec
(
type
(
sub
(
func
)
)
)
)
subtypeOf
:
[
0
1
]
}
{
type
:
(
rec
(
type
(
sub
(
func
)
)
)
(
type
(
sub
(
func
)
)
)
)
subtypeOf
:
[
2
]
}
{
type
:
undefined
subtypeOf
:
[
3
]
}
{
type
:
(
type
(
sub
0
(
func
)
)
)
subtypeOf
:
[
0
1
4
7
]
}
{
type
:
(
type
(
sub
4
(
func
)
)
)
subtypeOf
:
[
0
1
4
5
7
8
]
}
{
type
:
(
type
(
sub
5
(
func
)
)
)
subtypeOf
:
[
0
1
4
5
6
7
8
]
}
{
type
:
(
type
(
sub
0
(
func
)
)
)
subtypeOf
:
[
0
1
4
7
]
}
{
type
:
(
type
(
sub
7
(
func
)
)
)
subtypeOf
:
[
0
1
4
5
7
8
]
}
{
type
:
(
type
(
func
)
)
subtypeOf
:
[
9
]
}
]
;
let
typeSection
=
'
'
;
let
importedFuncs
=
'
'
;
let
definedFuncs
=
'
'
;
let
callIndirectFuncs
=
'
'
;
let
returnCallIndirectFuncs
=
'
'
;
let
i
=
0
;
for
(
let
{
type
}
of
TESTS
)
{
if
(
type
)
{
typeSection
+
=
type
+
'
\
n
'
;
}
importedFuncs
+
=
(
func
\
import
{
i
}
(
import
"
"
"
import
{
i
}
"
)
(
type
{
i
}
)
)
\
n
;
definedFuncs
+
=
(
func
\
define
{
i
}
(
export
"
define
{
i
}
"
)
(
type
{
i
}
)
)
\
n
;
callIndirectFuncs
+
=
(
func
(
export
"
call_indirect
{
i
}
"
)
(
param
i32
)
(
drop
(
ref
.
cast
(
ref
{
i
}
)
(
table
.
get
local
.
get
0
)
)
)
(
call_indirect
(
type
{
i
}
)
local
.
get
0
)
)
\
n
;
if
(
wasmTailCallsEnabled
(
)
)
{
returnCallIndirectFuncs
+
=
(
func
(
export
"
return_call_indirect
{
i
}
"
)
(
param
i32
)
(
drop
(
ref
.
cast
(
ref
{
i
}
)
(
table
.
get
local
.
get
0
)
)
)
(
return_call_indirect
(
type
{
i
}
)
local
.
get
0
)
)
\
n
;
}
i
+
+
;
}
let
moduleText
=
(
module
{
typeSection
}
{
importedFuncs
}
{
definedFuncs
}
{
callIndirectFuncs
}
{
returnCallIndirectFuncs
}
(
table
(
export
"
table
"
)
funcref
(
elem
{
TESTS
.
map
(
(
x
i
)
=
>
\
import
{
i
}
\
define
{
i
}
)
.
join
(
"
"
)
}
)
)
)
;
let
imports
=
{
"
"
:
Object
.
fromEntries
(
TESTS
.
map
(
(
x
i
)
=
>
[
import
{
i
}
(
)
=
>
{
}
]
)
)
}
;
let
exports
=
wasmEvalText
(
moduleText
imports
)
.
exports
;
for
(
let
callerTypeIndex
=
0
;
callerTypeIndex
<
TESTS
.
length
;
callerTypeIndex
+
+
)
{
for
(
let
calleeTypeIndex
=
0
;
calleeTypeIndex
<
TESTS
.
length
;
calleeTypeIndex
+
+
)
{
let
calleeType
=
TESTS
[
calleeTypeIndex
]
;
let
shouldPass
=
calleeType
.
subtypeOf
.
includes
(
callerTypeIndex
)
;
let
calleeImportFuncIndex
=
calleeTypeIndex
*
2
;
let
calleeDefinedFuncIndex
=
calleeTypeIndex
*
2
+
1
;
let
test
=
(
)
=
>
{
exports
[
call_indirect
{
callerTypeIndex
}
]
(
calleeImportFuncIndex
)
exports
[
call_indirect
{
callerTypeIndex
}
]
(
calleeDefinedFuncIndex
)
if
(
wasmTailCallsEnabled
(
)
)
{
exports
[
return_call_indirect
{
callerTypeIndex
}
]
(
calleeImportFuncIndex
)
exports
[
return_call_indirect
{
callerTypeIndex
}
]
(
calleeDefinedFuncIndex
)
}
}
;
if
(
shouldPass
)
{
test
(
)
;
}
else
{
assertErrorMessage
(
test
WebAssembly
.
RuntimeError
/
mismatch
|
cast
/
)
;
}
}
}
