load
(
libdir
+
'
wasm
.
js
'
)
;
load
(
libdir
+
'
asserts
.
js
'
)
;
const
textToBinary
=
str
=
>
wasmTextToBinary
(
str
'
new
-
format
'
)
;
const
emptyModule
=
textToBinary
(
'
(
module
)
'
)
;
const
wasmDesc
=
Object
.
getOwnPropertyDescriptor
(
this
'
WebAssembly
'
)
;
assertEq
(
typeof
wasmDesc
.
value
"
object
"
)
;
assertEq
(
wasmDesc
.
writable
true
)
;
assertEq
(
wasmDesc
.
enumerable
false
)
;
assertEq
(
wasmDesc
.
configurable
true
)
;
assertEq
(
WebAssembly
wasmDesc
.
value
)
;
assertEq
(
String
(
WebAssembly
)
"
[
object
WebAssembly
]
"
)
;
const
moduleDesc
=
Object
.
getOwnPropertyDescriptor
(
WebAssembly
'
Module
'
)
;
assertEq
(
typeof
moduleDesc
.
value
"
function
"
)
;
assertEq
(
moduleDesc
.
writable
true
)
;
assertEq
(
moduleDesc
.
enumerable
false
)
;
assertEq
(
moduleDesc
.
configurable
true
)
;
const
Module
=
WebAssembly
.
Module
;
assertEq
(
Module
moduleDesc
.
value
)
;
assertEq
(
Module
.
length
1
)
;
assertEq
(
Module
.
name
"
Module
"
)
;
assertErrorMessage
(
(
)
=
>
Module
(
)
TypeError
/
constructor
without
new
is
forbidden
/
)
;
assertErrorMessage
(
(
)
=
>
new
Module
(
1
)
TypeError
"
first
argument
must
be
an
ArrayBuffer
or
typed
array
object
"
)
;
assertErrorMessage
(
(
)
=
>
new
Module
(
{
}
)
TypeError
"
first
argument
must
be
an
ArrayBuffer
or
typed
array
object
"
)
;
assertErrorMessage
(
(
)
=
>
new
Module
(
new
Uint8Array
(
)
)
TypeError
/
compile
error
/
)
;
assertErrorMessage
(
(
)
=
>
new
Module
(
new
ArrayBuffer
(
)
)
TypeError
/
compile
error
/
)
;
assertEq
(
new
Module
(
emptyModule
)
instanceof
Module
true
)
;
assertEq
(
new
Module
(
emptyModule
.
buffer
)
instanceof
Module
true
)
;
const
moduleProtoDesc
=
Object
.
getOwnPropertyDescriptor
(
Module
'
prototype
'
)
;
assertEq
(
typeof
moduleProtoDesc
.
value
"
object
"
)
;
assertEq
(
moduleProtoDesc
.
writable
false
)
;
assertEq
(
moduleProtoDesc
.
enumerable
false
)
;
assertEq
(
moduleProtoDesc
.
configurable
false
)
;
const
moduleProto
=
Module
.
prototype
;
assertEq
(
moduleProto
moduleProtoDesc
.
value
)
;
assertEq
(
String
(
moduleProto
)
"
[
object
Object
]
"
)
;
assertEq
(
Object
.
getPrototypeOf
(
moduleProto
)
Object
.
prototype
)
;
const
m1
=
new
Module
(
emptyModule
)
;
assertEq
(
typeof
m1
"
object
"
)
;
assertEq
(
String
(
m1
)
"
[
object
WebAssembly
.
Module
]
"
)
;
assertEq
(
Object
.
getPrototypeOf
(
m1
)
moduleProto
)
;
const
instanceDesc
=
Object
.
getOwnPropertyDescriptor
(
WebAssembly
'
Instance
'
)
;
assertEq
(
typeof
instanceDesc
.
value
"
function
"
)
;
assertEq
(
instanceDesc
.
writable
true
)
;
assertEq
(
instanceDesc
.
enumerable
false
)
;
assertEq
(
instanceDesc
.
configurable
true
)
;
const
Instance
=
WebAssembly
.
Instance
;
assertEq
(
Instance
instanceDesc
.
value
)
;
assertEq
(
Instance
.
length
1
)
;
assertEq
(
Instance
.
name
"
Instance
"
)
;
assertErrorMessage
(
(
)
=
>
Instance
(
)
TypeError
/
constructor
without
new
is
forbidden
/
)
;
assertErrorMessage
(
(
)
=
>
new
Instance
(
1
)
TypeError
"
first
argument
must
be
a
WebAssembly
.
Module
"
)
;
assertErrorMessage
(
(
)
=
>
new
Instance
(
{
}
)
TypeError
"
first
argument
must
be
a
WebAssembly
.
Module
"
)
;
assertErrorMessage
(
(
)
=
>
new
Instance
(
m1
null
)
TypeError
"
second
argument
if
present
must
be
an
object
"
)
;
assertEq
(
new
Instance
(
m1
)
instanceof
Instance
true
)
;
assertEq
(
new
Instance
(
m1
{
}
)
instanceof
Instance
true
)
;
const
instanceProtoDesc
=
Object
.
getOwnPropertyDescriptor
(
Instance
'
prototype
'
)
;
assertEq
(
typeof
instanceProtoDesc
.
value
"
object
"
)
;
assertEq
(
instanceProtoDesc
.
writable
false
)
;
assertEq
(
instanceProtoDesc
.
enumerable
false
)
;
assertEq
(
instanceProtoDesc
.
configurable
false
)
;
const
instanceProto
=
Instance
.
prototype
;
assertEq
(
instanceProto
instanceProtoDesc
.
value
)
;
assertEq
(
String
(
instanceProto
)
"
[
object
Object
]
"
)
;
assertEq
(
Object
.
getPrototypeOf
(
instanceProto
)
Object
.
prototype
)
;
const
i1
=
new
Instance
(
m1
)
;
assertEq
(
typeof
i1
"
object
"
)
;
assertEq
(
String
(
i1
)
"
[
object
WebAssembly
.
Instance
]
"
)
;
assertEq
(
Object
.
getPrototypeOf
(
i1
)
instanceProto
)
;
const
exportsDesc
=
Object
.
getOwnPropertyDescriptor
(
i1
'
exports
'
)
;
assertEq
(
typeof
exportsDesc
.
value
"
object
"
)
;
assertEq
(
exportsDesc
.
writable
true
)
;
assertEq
(
exportsDesc
.
enumerable
true
)
;
assertEq
(
exportsDesc
.
configurable
true
)
;
const
memoryDesc
=
Object
.
getOwnPropertyDescriptor
(
WebAssembly
'
Memory
'
)
;
assertEq
(
typeof
memoryDesc
.
value
"
function
"
)
;
assertEq
(
memoryDesc
.
writable
true
)
;
assertEq
(
memoryDesc
.
enumerable
false
)
;
assertEq
(
memoryDesc
.
configurable
true
)
;
const
Memory
=
WebAssembly
.
Memory
;
assertEq
(
Memory
memoryDesc
.
value
)
;
assertEq
(
Memory
.
length
1
)
;
assertEq
(
Memory
.
name
"
Memory
"
)
;
assertErrorMessage
(
(
)
=
>
Memory
(
)
TypeError
/
constructor
without
new
is
forbidden
/
)
;
assertErrorMessage
(
(
)
=
>
new
Memory
(
1
)
TypeError
"
first
argument
must
be
a
memory
descriptor
"
)
;
assertErrorMessage
(
(
)
=
>
new
Memory
(
{
initial
:
{
valueOf
(
)
{
throw
new
Error
(
"
here
"
)
}
}
}
)
Error
"
here
"
)
;
assertErrorMessage
(
(
)
=
>
new
Memory
(
{
initial
:
-
1
}
)
TypeError
/
bad
Memory
initial
size
/
)
;
assertErrorMessage
(
(
)
=
>
new
Memory
(
{
initial
:
Math
.
pow
(
2
32
)
}
)
TypeError
/
bad
Memory
initial
size
/
)
;
assertEq
(
new
Memory
(
{
initial
:
1
}
)
instanceof
Memory
true
)
;
assertEq
(
new
Memory
(
{
initial
:
1
.
5
}
)
.
buffer
.
byteLength
64
*
1024
)
;
const
memoryProtoDesc
=
Object
.
getOwnPropertyDescriptor
(
Memory
'
prototype
'
)
;
assertEq
(
typeof
memoryProtoDesc
.
value
"
object
"
)
;
assertEq
(
memoryProtoDesc
.
writable
false
)
;
assertEq
(
memoryProtoDesc
.
enumerable
false
)
;
assertEq
(
memoryProtoDesc
.
configurable
false
)
;
const
memoryProto
=
Memory
.
prototype
;
assertEq
(
memoryProto
memoryProtoDesc
.
value
)
;
assertEq
(
String
(
memoryProto
)
"
[
object
Object
]
"
)
;
assertEq
(
Object
.
getPrototypeOf
(
memoryProto
)
Object
.
prototype
)
;
const
mem1
=
new
Memory
(
{
initial
:
1
}
)
;
assertEq
(
typeof
mem1
"
object
"
)
;
assertEq
(
String
(
mem1
)
"
[
object
WebAssembly
.
Memory
]
"
)
;
assertEq
(
Object
.
getPrototypeOf
(
mem1
)
memoryProto
)
;
const
bufferDesc
=
Object
.
getOwnPropertyDescriptor
(
memoryProto
'
buffer
'
)
;
assertEq
(
typeof
bufferDesc
.
get
"
function
"
)
;
assertEq
(
bufferDesc
.
set
undefined
)
;
assertEq
(
bufferDesc
.
enumerable
false
)
;
assertEq
(
bufferDesc
.
configurable
true
)
;
const
bufferGetter
=
bufferDesc
.
get
;
assertErrorMessage
(
(
)
=
>
bufferGetter
.
call
(
)
TypeError
/
called
on
incompatible
undefined
/
)
;
assertErrorMessage
(
(
)
=
>
bufferGetter
.
call
(
{
}
)
TypeError
/
called
on
incompatible
Object
/
)
;
assertEq
(
bufferGetter
.
call
(
mem1
)
instanceof
ArrayBuffer
true
)
;
assertEq
(
bufferGetter
.
call
(
mem1
)
.
byteLength
64
*
1024
)
;
const
tableDesc
=
Object
.
getOwnPropertyDescriptor
(
WebAssembly
'
Table
'
)
;
assertEq
(
typeof
tableDesc
.
value
"
function
"
)
;
assertEq
(
tableDesc
.
writable
true
)
;
assertEq
(
tableDesc
.
enumerable
false
)
;
assertEq
(
tableDesc
.
configurable
true
)
;
const
Table
=
WebAssembly
.
Table
;
assertEq
(
Table
tableDesc
.
value
)
;
assertEq
(
Table
.
length
1
)
;
assertEq
(
Table
.
name
"
Table
"
)
;
assertErrorMessage
(
(
)
=
>
Table
(
)
TypeError
/
constructor
without
new
is
forbidden
/
)
;
assertErrorMessage
(
(
)
=
>
new
Table
(
1
)
TypeError
"
first
argument
must
be
a
table
descriptor
"
)
;
assertErrorMessage
(
(
)
=
>
new
Table
(
{
initial
:
{
valueOf
(
)
{
throw
new
Error
(
"
here
"
)
}
}
}
)
Error
"
here
"
)
;
assertErrorMessage
(
(
)
=
>
new
Table
(
{
initial
:
-
1
}
)
TypeError
/
bad
Table
initial
size
/
)
;
assertErrorMessage
(
(
)
=
>
new
Table
(
{
initial
:
Math
.
pow
(
2
32
)
}
)
TypeError
/
bad
Table
initial
size
/
)
;
assertEq
(
new
Table
(
{
initial
:
1
}
)
instanceof
Table
true
)
;
assertEq
(
new
Table
(
{
initial
:
1
.
5
}
)
instanceof
Table
true
)
;
const
tableProtoDesc
=
Object
.
getOwnPropertyDescriptor
(
Table
'
prototype
'
)
;
assertEq
(
typeof
tableProtoDesc
.
value
"
object
"
)
;
assertEq
(
tableProtoDesc
.
writable
false
)
;
assertEq
(
tableProtoDesc
.
enumerable
false
)
;
assertEq
(
tableProtoDesc
.
configurable
false
)
;
const
tableProto
=
Table
.
prototype
;
assertEq
(
tableProto
tableProtoDesc
.
value
)
;
assertEq
(
String
(
tableProto
)
"
[
object
Object
]
"
)
;
assertEq
(
Object
.
getPrototypeOf
(
tableProto
)
Object
.
prototype
)
;
const
tbl1
=
new
Table
(
{
initial
:
1
}
)
;
assertEq
(
typeof
tbl1
"
object
"
)
;
assertEq
(
String
(
tbl1
)
"
[
object
WebAssembly
.
Table
]
"
)
;
assertEq
(
Object
.
getPrototypeOf
(
tbl1
)
tableProto
)
;
const
lengthDesc
=
Object
.
getOwnPropertyDescriptor
(
tableProto
'
length
'
)
;
assertEq
(
typeof
lengthDesc
.
get
"
function
"
)
;
assertEq
(
lengthDesc
.
set
undefined
)
;
assertEq
(
lengthDesc
.
enumerable
false
)
;
assertEq
(
lengthDesc
.
configurable
true
)
;
const
lengthGetter
=
lengthDesc
.
get
;
assertErrorMessage
(
(
)
=
>
lengthGetter
.
call
(
)
TypeError
/
called
on
incompatible
undefined
/
)
;
assertErrorMessage
(
(
)
=
>
lengthGetter
.
call
(
{
}
)
TypeError
/
called
on
incompatible
Object
/
)
;
assertEq
(
typeof
lengthGetter
.
call
(
tbl1
)
"
number
"
)
;
assertEq
(
lengthGetter
.
call
(
tbl1
)
1
)
;
