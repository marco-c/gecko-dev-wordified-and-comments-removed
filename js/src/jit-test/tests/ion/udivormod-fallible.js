function
umod_by_constant
(
x
)
{
return
(
x
>
>
>
0
)
%
3
;
}
function
umod_by_constant_pow_two
(
x
)
{
return
(
x
>
>
>
0
)
%
4
;
}
function
umod
(
dividend
divisor
)
{
divisor
=
Math
.
min
(
Math
.
max
(
divisor
1
)
10
)
;
return
(
dividend
>
>
>
0
)
%
(
divisor
>
>
>
0
)
;
}
function
umod_by_constant_no_ursh
(
dividend
divisor
)
{
dividend
=
Math
.
max
(
dividend
0
)
;
return
dividend
%
5
;
}
function
umod_no_ursh
(
dividend
divisor
)
{
dividend
=
Math
.
max
(
dividend
0
)
;
divisor
=
Math
.
min
(
Math
.
max
(
divisor
1
)
10
)
;
return
dividend
%
divisor
;
}
function
umod_truncate
(
dividend
divisor
)
{
dividend
=
Math
.
max
(
dividend
0
)
;
divisor
=
Math
.
max
(
divisor
0
)
;
return
(
(
dividend
>
>
>
0
)
%
(
divisor
>
>
>
0
)
)
|
0
;
}
function
udiv_by_constant
(
dividend
)
{
dividend
=
Math
.
max
(
dividend
0
)
;
return
(
(
dividend
>
>
>
0
)
/
3
)
|
0
;
}
function
udiv_by_constant_pow_two
(
dividend
)
{
dividend
=
Math
.
max
(
dividend
0
)
;
return
(
(
dividend
>
>
>
0
)
/
8
)
|
0
;
}
function
udiv
(
dividend
divisor
)
{
dividend
=
Math
.
max
(
dividend
0
)
;
divisor
=
Math
.
max
(
divisor
0
)
;
return
(
(
dividend
>
>
>
0
)
/
(
divisor
>
>
>
0
)
)
|
0
;
}
with
(
{
}
)
;
for
(
let
i
=
0
;
i
<
100
;
+
+
i
)
{
assertEq
(
umod_by_constant
(
i
)
i
%
3
)
;
assertEq
(
umod_by_constant_pow_two
(
i
)
i
%
4
)
;
assertEq
(
umod
(
i
1
)
i
%
1
)
;
assertEq
(
umod
(
i
3
)
i
%
3
)
;
assertEq
(
umod
(
i
5
)
i
%
5
)
;
assertEq
(
umod_by_constant_no_ursh
(
i
)
i
%
5
)
;
assertEq
(
umod_no_ursh
(
i
1
)
i
%
1
)
;
assertEq
(
umod_no_ursh
(
i
7
)
i
%
7
)
;
assertEq
(
umod_no_ursh
(
i
9
)
i
%
9
)
;
assertEq
(
umod_truncate
(
i
1
)
i
%
1
)
;
assertEq
(
umod_truncate
(
i
6
)
i
%
6
)
;
assertEq
(
umod_truncate
(
i
11
)
i
%
11
)
;
assertEq
(
udiv_by_constant
(
i
*
3
)
i
)
;
assertEq
(
udiv_by_constant_pow_two
(
i
*
8
)
i
)
;
assertEq
(
udiv
(
i
*
1
1
)
i
)
;
assertEq
(
udiv
(
i
*
3
3
)
i
)
;
assertEq
(
udiv
(
i
*
5
5
)
i
)
;
}
