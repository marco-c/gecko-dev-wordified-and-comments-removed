class
A
{
#
x
=
10
x
(
)
{
return
this
.
#
x
;
}
ix
(
)
{
this
.
#
x
+
+
;
}
static
readx
(
o
)
{
return
o
.
#
x
;
}
#
y
=
(
)
=
>
'
hi
'
;
invoke
(
)
{
return
this
.
#
y
(
)
;
}
static
#
z
=
'
static
'
;
gz
(
)
{
return
A
.
#
z
;
}
sz
(
o
)
{
A
.
#
z
=
o
;
}
static
sgz
(
)
{
return
this
.
#
z
;
}
static
ssz
(
o
)
{
this
.
#
z
=
o
;
}
}
;
for
(
var
i
=
0
;
i
<
1000
;
i
+
+
)
{
var
a
=
new
A
(
)
;
assertEq
(
a
.
x
(
)
10
)
;
a
.
ix
(
)
;
assertEq
(
a
.
x
(
)
11
)
;
assertEq
(
A
.
readx
(
a
)
11
)
;
assertEq
(
a
.
invoke
(
)
'
hi
'
)
;
assertEq
(
a
.
gz
(
)
'
static
'
)
;
assertEq
(
A
.
sgz
(
)
'
static
'
)
;
A
.
ssz
(
i
)
;
assertEq
(
A
.
sgz
(
)
i
)
;
a
.
sz
(
i
+
1
)
;
assertEq
(
A
.
sgz
(
)
i
+
1
)
;
A
.
ssz
(
'
static
'
)
;
}
function
assertThrows
(
fun
errorType
)
{
try
{
fun
(
)
;
assertEq
(
true
false
'
Expected
error
but
none
was
thrown
'
)
;
}
catch
(
e
)
{
assertEq
(
e
instanceof
errorType
true
'
Wrong
error
type
thrown
'
)
;
}
}
assertThrows
(
(
)
=
>
A
.
readx
(
)
TypeError
)
;
assertThrows
(
(
)
=
>
A
.
readx
(
{
}
)
TypeError
)
;
assertThrows
(
(
)
=
>
A
.
readx
(
1
)
TypeError
)
;
assertThrows
(
(
)
=
>
eval
(
'
class
B
extends
class
{
#
x
;
}
{
g
(
)
{
return
super
.
#
x
;
}
}
'
)
SyntaxError
)
;
assertThrows
(
(
)
=
>
eval
(
'
class
C
{
#
x
=
10
;
static
#
x
=
14
;
}
'
)
SyntaxError
)
;
class
B
extends
class
{
constructor
(
o
)
{
return
o
;
}
}
{
#
x
=
12
;
static
gx
(
o
)
{
return
o
.
#
x
;
}
static
sx
(
o
)
{
o
.
#
x
+
+
;
}
}
var
bn
=
new
B
(
1
)
;
var
bu
=
new
B
(
undefined
)
;
class
Outer
{
#
outer
=
3
;
test
(
)
{
let
outerThis
=
this
;
class
Inner
{
#
inner
=
2
;
test
(
)
{
return
outerThis
.
#
outer
;
}
}
return
new
Inner
(
)
.
test
(
)
;
}
}
var
o
=
new
Outer
;
assertEq
(
o
.
test
(
)
3
)
;
var
alreadyConstructedB
=
new
B
(
)
;
assertEq
(
B
.
gx
(
alreadyConstructedB
)
12
)
;
function
initIC
(
o
)
{
new
B
(
o
)
;
}
var
array
=
[
]
;
for
(
var
i
=
1
;
i
<
1000
;
i
+
+
)
{
var
newB
=
{
}
;
initIC
(
newB
)
;
}
assertThrows
(
(
)
=
>
initIC
(
alreadyConstructedB
)
TypeError
)
;
var
elements
=
[
]
;
for
(
var
i
=
0
;
i
<
999
;
i
+
+
)
{
elements
.
push
(
new
B
)
;
}
elements
.
push
(
{
}
)
;
function
getterCheck
(
e
)
{
assertEq
(
B
.
gx
(
e
)
12
)
;
}
function
setterCheck
(
e
)
{
B
.
sx
(
e
)
;
}
var
checksPassed
=
0
;
try
{
for
(
var
e
of
elements
)
{
getterCheck
(
e
)
;
checksPassed
+
+
;
}
assertEq
(
true
false
'
Shouldnt
arrive
here
'
)
;
}
catch
(
e
)
{
assertEq
(
e
instanceof
TypeError
true
)
assertEq
(
checksPassed
elements
.
length
-
1
)
;
}
checksPassed
=
0
;
try
{
for
(
var
e
of
elements
)
{
setterCheck
(
e
)
;
checksPassed
+
+
;
}
assertEq
(
true
false
'
Shouldnt
arrive
here
'
)
;
}
catch
(
e
)
{
assertEq
(
e
instanceof
TypeError
true
)
assertEq
(
checksPassed
elements
.
length
-
1
)
;
}
for
(
var
index
in
elements
)
{
if
(
index
<
elements
.
length
-
1
)
{
assertEq
(
B
.
gx
(
elements
[
index
]
)
13
)
;
}
}
