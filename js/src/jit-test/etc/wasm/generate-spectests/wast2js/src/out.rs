pub
const
LINE_WIDTH
:
usize
=
80
;
pub
const
NOWRAP
:
usize
=
1000
;
pub
enum
JSNode
{
Assert
{
name
:
String
exec
:
Box
<
JSNode
>
expected
:
Box
<
JSNode
>
}
Invoke
{
instance
:
String
name
:
String
body
:
Box
<
JSNode
>
}
Call
{
name
:
String
args
:
Vec
<
Box
<
JSNode
>
>
}
Array
(
Vec
<
Box
<
JSNode
>
>
)
Raw
(
String
)
}
impl
JSNode
{
pub
fn
output
(
&
self
line_remaining
:
usize
)
-
>
String
{
let
line_remaining
=
if
line_remaining
=
=
0
{
LINE_WIDTH
}
else
{
line_remaining
}
;
match
self
{
Self
:
:
Assert
{
name
exec
expected
}
=
>
{
if
self
.
len
(
)
>
line_remaining
{
format
!
(
"
{
}
(
\
n
{
}
\
n
)
"
name
indent
(
format
!
(
"
(
)
=
>
{
}
\
n
{
}
"
exec
.
output
(
line_remaining
-
8
)
expected
.
output
(
line_remaining
-
2
)
)
)
)
}
else
{
format
!
(
"
{
}
(
(
)
=
>
{
}
{
}
)
"
name
exec
.
output
(
NOWRAP
)
expected
.
output
(
NOWRAP
)
)
}
}
Self
:
:
Invoke
{
instance
name
body
}
=
>
{
let
len_before_body
=
"
invoke
"
.
len
(
)
+
instance
.
len
(
)
+
name
.
len
(
)
;
if
len_before_body
>
line_remaining
{
format
!
(
"
invoke
(
{
}
\
n
{
}
\
n
)
"
instance
indent
(
format
!
(
"
{
}
\
n
{
}
"
name
body
.
output
(
line_remaining
-
2
)
)
)
)
}
else
{
let
body_string
=
body
.
output
(
line_remaining
-
len_before_body
)
;
format
!
(
"
invoke
(
{
}
{
}
{
}
)
"
instance
name
body_string
)
}
}
Self
:
:
Call
{
name
args
}
=
>
{
if
self
.
len
(
)
>
line_remaining
{
let
arg_strings
:
Vec
<
String
>
=
args
.
iter
(
)
.
map
(
|
arg
|
arg
.
output
(
line_remaining
-
2
)
)
.
collect
(
)
;
format
!
(
"
{
}
(
\
n
{
}
\
n
)
"
name
indent
(
arg_strings
.
join
(
"
\
n
"
)
)
)
}
else
{
let
arg_strings
:
Vec
<
String
>
=
args
.
iter
(
)
.
map
(
|
arg
|
arg
.
output
(
NOWRAP
)
)
.
collect
(
)
;
format
!
(
"
{
}
(
{
}
)
"
name
arg_strings
.
join
(
"
"
)
)
}
}
Self
:
:
Array
(
values
)
=
>
{
if
self
.
len
(
)
>
line_remaining
{
let
value_strings
=
output_nodes
(
&
values
70
)
;
format
!
(
"
[
\
n
{
}
\
n
]
"
indent
(
value_strings
.
join
(
"
\
n
"
)
)
)
}
else
{
let
value_strings
=
output_nodes
(
&
values
80
)
;
format
!
(
"
[
{
}
]
"
value_strings
.
join
(
"
"
)
)
}
}
Self
:
:
Raw
(
val
)
=
>
val
.
to_string
(
)
}
}
fn
len
(
&
self
)
-
>
usize
{
match
self
{
Self
:
:
Assert
{
name
exec
expected
}
=
>
name
.
len
(
)
+
exec
.
len
(
)
+
expected
.
len
(
)
Self
:
:
Invoke
{
instance
name
body
}
=
>
instance
.
len
(
)
+
name
.
len
(
)
+
body
.
len
(
)
Self
:
:
Call
{
name
args
}
=
>
{
let
mut
args_len
:
usize
=
0
;
for
node
in
args
{
args_len
+
=
node
.
len
(
)
+
"
"
.
len
(
)
;
}
name
.
len
(
)
+
args_len
}
Self
:
:
Array
(
nodes
)
=
>
{
let
mut
content_len
:
usize
=
0
;
for
node
in
nodes
{
content_len
+
=
node
.
len
(
)
+
"
"
.
len
(
)
;
}
content_len
}
Self
:
:
Raw
(
s
)
=
>
s
.
len
(
)
}
}
}
pub
fn
output_nodes
(
nodes
:
&
Vec
<
Box
<
JSNode
>
>
line_width_per_node
:
usize
)
-
>
Vec
<
String
>
{
nodes
.
iter
(
)
.
map
(
|
node
|
node
.
output
(
line_width_per_node
)
)
.
collect
(
)
}
pub
fn
strings_to_raws
(
strs
:
Vec
<
String
>
)
-
>
Vec
<
Box
<
JSNode
>
>
{
let
mut
res
:
Vec
<
Box
<
JSNode
>
>
=
vec
!
[
]
;
for
s
in
strs
{
res
.
push
(
Box
:
:
new
(
JSNode
:
:
Raw
(
s
)
)
)
;
}
res
}
fn
indent
(
s
:
String
)
-
>
String
{
let
mut
result
=
String
:
:
new
(
)
;
let
mut
do_indent
=
true
;
for
(
i
line
)
in
s
.
lines
(
)
.
enumerate
(
)
{
if
i
>
0
{
result
.
push
(
'
\
n
'
)
;
}
if
line
.
chars
(
)
.
any
(
|
c
|
!
c
.
is_whitespace
(
)
)
{
if
do_indent
{
result
.
push_str
(
"
"
)
;
}
result
.
push_str
(
line
)
;
if
line
.
matches
(
"
"
)
.
count
(
)
%
2
=
=
1
{
do_indent
=
!
do_indent
}
}
}
result
}
