#
ifndef
jsweakmap_h
#
define
jsweakmap_h
#
include
"
mozilla
/
Move
.
h
"
#
include
"
jscompartment
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsobj
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
gc
/
StoreBuffer
.
h
"
#
include
"
js
/
HashTable
.
h
"
namespace
js
{
static
WeakMapBase
*
const
WeakMapNotInList
=
reinterpret_cast
<
WeakMapBase
*
>
(
1
)
;
typedef
HashSet
<
WeakMapBase
*
DefaultHasher
<
WeakMapBase
*
>
SystemAllocPolicy
>
WeakMapSet
;
class
WeakMapBase
{
friend
void
js
:
:
GCMarker
:
:
enterWeakMarkingMode
(
)
;
public
:
WeakMapBase
(
JSObject
*
memOf
JSCompartment
*
c
)
;
virtual
~
WeakMapBase
(
)
;
void
trace
(
JSTracer
*
tracer
)
;
static
void
unmarkCompartment
(
JSCompartment
*
c
)
;
static
void
markAll
(
JSCompartment
*
c
JSTracer
*
tracer
)
;
static
bool
markCompartmentIteratively
(
JSCompartment
*
c
JSTracer
*
tracer
)
;
static
bool
findZoneEdgesForCompartment
(
JSCompartment
*
c
)
;
static
void
sweepCompartment
(
JSCompartment
*
c
)
;
static
void
traceAllMappings
(
WeakMapTracer
*
tracer
)
;
bool
isInList
(
)
{
return
next
!
=
WeakMapNotInList
;
}
static
bool
saveCompartmentMarkedWeakMaps
(
JSCompartment
*
c
WeakMapSet
&
markedWeakMaps
)
;
static
void
restoreMarkedWeakMaps
(
WeakMapSet
&
markedWeakMaps
)
;
static
void
removeWeakMapFromList
(
WeakMapBase
*
weakmap
)
;
virtual
void
maybeMarkEntry
(
JSTracer
*
trc
gc
:
:
Cell
*
markedCell
JS
:
:
GCCellPtr
l
)
=
0
;
virtual
void
markEphemeronEntries
(
JSTracer
*
trc
)
=
0
;
protected
:
virtual
void
nonMarkingTraceKeys
(
JSTracer
*
tracer
)
=
0
;
virtual
void
nonMarkingTraceValues
(
JSTracer
*
tracer
)
=
0
;
virtual
bool
markIteratively
(
JSTracer
*
tracer
)
=
0
;
virtual
bool
findZoneEdges
(
)
=
0
;
virtual
void
sweep
(
)
=
0
;
virtual
void
traceMappings
(
WeakMapTracer
*
tracer
)
=
0
;
virtual
void
finish
(
)
=
0
;
HeapPtrObject
memberOf
;
JSCompartment
*
compartment
;
WeakMapBase
*
next
;
bool
marked
;
}
;
template
<
typename
T
>
static
T
extractUnbarriered
(
BarrieredBase
<
T
>
v
)
{
return
v
.
get
(
)
;
}
template
<
typename
T
>
static
T
*
extractUnbarriered
(
T
*
v
)
{
return
v
;
}
template
<
class
Key
class
Value
class
HashPolicy
=
DefaultHasher
<
Key
>
>
class
WeakMap
:
public
HashMap
<
Key
Value
HashPolicy
RuntimeAllocPolicy
>
public
WeakMapBase
{
public
:
typedef
HashMap
<
Key
Value
HashPolicy
RuntimeAllocPolicy
>
Base
;
typedef
typename
Base
:
:
Enum
Enum
;
typedef
typename
Base
:
:
Lookup
Lookup
;
typedef
typename
Base
:
:
Range
Range
;
typedef
typename
Base
:
:
Ptr
Ptr
;
typedef
typename
Base
:
:
AddPtr
AddPtr
;
explicit
WeakMap
(
JSContext
*
cx
JSObject
*
memOf
=
nullptr
)
:
Base
(
cx
-
>
runtime
(
)
)
WeakMapBase
(
memOf
cx
-
>
compartment
(
)
)
{
}
bool
init
(
uint32_t
len
=
16
)
{
if
(
!
Base
:
:
init
(
len
)
)
return
false
;
next
=
compartment
-
>
gcWeakMapList
;
compartment
-
>
gcWeakMapList
=
this
;
marked
=
JS
:
:
IsIncrementalGCInProgress
(
compartment
-
>
runtimeFromMainThread
(
)
)
;
return
true
;
}
Ptr
lookup
(
const
Lookup
&
l
)
const
{
Ptr
p
=
Base
:
:
lookup
(
l
)
;
if
(
p
)
exposeGCThingToActiveJS
(
p
-
>
value
(
)
)
;
return
p
;
}
AddPtr
lookupForAdd
(
const
Lookup
&
l
)
const
{
AddPtr
p
=
Base
:
:
lookupForAdd
(
l
)
;
if
(
p
)
exposeGCThingToActiveJS
(
p
-
>
value
(
)
)
;
return
p
;
}
Ptr
lookupWithDefault
(
const
Key
&
k
const
Value
&
defaultValue
)
{
Ptr
p
=
Base
:
:
lookupWithDefault
(
k
defaultValue
)
;
if
(
p
)
exposeGCThingToActiveJS
(
p
-
>
value
(
)
)
;
return
p
;
}
void
maybeMarkEntry
(
JSTracer
*
trc
gc
:
:
Cell
*
markedCell
JS
:
:
GCCellPtr
origKey
)
override
{
MOZ_ASSERT
(
marked
)
;
gc
:
:
Cell
*
l
=
origKey
.
asCell
(
)
;
Ptr
p
=
Base
:
:
lookup
(
reinterpret_cast
<
Lookup
&
>
(
l
)
)
;
MOZ_ASSERT
(
p
.
found
(
)
)
;
Key
key
(
p
-
>
key
(
)
)
;
if
(
gc
:
:
IsMarked
(
&
key
)
)
{
TraceEdge
(
trc
&
p
-
>
value
(
)
"
ephemeron
value
"
)
;
}
else
if
(
keyNeedsMark
(
key
)
)
{
TraceEdge
(
trc
&
p
-
>
value
(
)
"
WeakMap
ephemeron
value
"
)
;
TraceEdge
(
trc
&
key
"
proxy
-
preserved
WeakMap
ephemeron
key
"
)
;
MOZ_ASSERT
(
key
=
=
p
-
>
key
(
)
)
;
}
key
.
unsafeSet
(
nullptr
)
;
}
protected
:
static
void
addWeakEntry
(
JSTracer
*
trc
JS
:
:
GCCellPtr
key
gc
:
:
WeakMarkable
markable
)
{
GCMarker
&
marker
=
*
static_cast
<
GCMarker
*
>
(
trc
)
;
auto
p
=
marker
.
weakKeys
.
get
(
key
)
;
if
(
p
)
{
gc
:
:
WeakEntryVector
&
weakEntries
=
p
-
>
value
;
if
(
!
weakEntries
.
append
(
Move
(
markable
)
)
)
marker
.
abortLinearWeakMarking
(
)
;
}
else
{
gc
:
:
WeakEntryVector
weakEntries
;
MOZ_ALWAYS_TRUE
(
weakEntries
.
append
(
Move
(
markable
)
)
)
;
if
(
!
marker
.
weakKeys
.
put
(
JS
:
:
GCCellPtr
(
key
)
Move
(
weakEntries
)
)
)
marker
.
abortLinearWeakMarking
(
)
;
}
}
void
markEphemeronEntries
(
JSTracer
*
trc
)
override
{
MOZ_ASSERT
(
marked
)
;
for
(
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Key
key
(
e
.
front
(
)
.
key
(
)
)
;
if
(
gc
:
:
IsMarked
(
&
key
)
)
{
(
void
)
markValue
(
trc
&
e
.
front
(
)
.
value
(
)
)
;
MOZ_ASSERT
(
key
=
=
e
.
front
(
)
.
key
(
)
)
;
}
else
if
(
keyNeedsMark
(
key
)
)
{
TraceEdge
(
trc
&
e
.
front
(
)
.
value
(
)
"
WeakMap
entry
value
"
)
;
TraceEdge
(
trc
&
key
"
proxy
-
preserved
WeakMap
entry
key
"
)
;
MOZ_ASSERT
(
key
=
=
e
.
front
(
)
.
key
(
)
)
;
}
else
if
(
trc
-
>
isWeakMarkingTracer
(
)
)
{
JS
:
:
GCCellPtr
weakKey
(
extractUnbarriered
(
key
)
)
;
gc
:
:
WeakMarkable
markable
(
this
weakKey
)
;
addWeakEntry
(
trc
weakKey
markable
)
;
if
(
JSObject
*
delegate
=
getDelegate
(
key
)
)
addWeakEntry
(
trc
JS
:
:
GCCellPtr
(
delegate
)
markable
)
;
}
key
.
unsafeSet
(
nullptr
)
;
}
}
private
:
void
exposeGCThingToActiveJS
(
const
JS
:
:
Value
&
v
)
const
{
JS
:
:
ExposeValueToActiveJS
(
v
)
;
}
void
exposeGCThingToActiveJS
(
JSObject
*
obj
)
const
{
JS
:
:
ExposeObjectToActiveJS
(
obj
)
;
}
bool
markValue
(
JSTracer
*
trc
Value
*
x
)
{
if
(
gc
:
:
IsMarked
(
x
)
)
return
false
;
TraceEdge
(
trc
x
"
WeakMap
entry
value
"
)
;
MOZ_ASSERT
(
gc
:
:
IsMarked
(
x
)
)
;
return
true
;
}
void
nonMarkingTraceKeys
(
JSTracer
*
trc
)
override
{
for
(
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Key
key
(
e
.
front
(
)
.
key
(
)
)
;
TraceEdge
(
trc
&
key
"
WeakMap
entry
key
"
)
;
if
(
key
!
=
e
.
front
(
)
.
key
(
)
)
entryMoved
(
e
key
)
;
}
}
void
nonMarkingTraceValues
(
JSTracer
*
trc
)
override
{
for
(
Range
r
=
Base
:
:
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
TraceEdge
(
trc
&
r
.
front
(
)
.
value
(
)
"
WeakMap
entry
value
"
)
;
}
JSObject
*
getDelegate
(
JSObject
*
key
)
const
{
JSWeakmapKeyDelegateOp
op
=
key
-
>
getClass
(
)
-
>
ext
.
weakmapKeyDelegateOp
;
return
op
?
op
(
key
)
:
nullptr
;
}
JSObject
*
getDelegate
(
gc
:
:
Cell
*
cell
)
const
{
return
nullptr
;
}
bool
keyNeedsMark
(
JSObject
*
key
)
const
{
JSObject
*
delegate
=
getDelegate
(
key
)
;
return
delegate
&
&
gc
:
:
IsMarkedUnbarriered
(
&
delegate
)
;
}
bool
keyNeedsMark
(
gc
:
:
Cell
*
cell
)
const
{
return
false
;
}
bool
markIteratively
(
JSTracer
*
trc
)
override
{
bool
markedAny
=
false
;
for
(
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Key
key
(
e
.
front
(
)
.
key
(
)
)
;
if
(
gc
:
:
IsMarked
(
const_cast
<
Key
*
>
(
&
key
)
)
)
{
if
(
markValue
(
trc
&
e
.
front
(
)
.
value
(
)
)
)
markedAny
=
true
;
if
(
e
.
front
(
)
.
key
(
)
!
=
key
)
entryMoved
(
e
key
)
;
}
else
if
(
keyNeedsMark
(
key
)
)
{
TraceEdge
(
trc
&
e
.
front
(
)
.
value
(
)
"
WeakMap
entry
value
"
)
;
TraceEdge
(
trc
&
key
"
proxy
-
preserved
WeakMap
entry
key
"
)
;
if
(
e
.
front
(
)
.
key
(
)
!
=
key
)
entryMoved
(
e
key
)
;
markedAny
=
true
;
}
key
.
unsafeSet
(
nullptr
)
;
}
return
markedAny
;
}
bool
findZoneEdges
(
)
override
{
return
true
;
}
void
sweep
(
)
override
{
for
(
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Key
k
(
e
.
front
(
)
.
key
(
)
)
;
if
(
gc
:
:
IsAboutToBeFinalized
(
&
k
)
)
e
.
removeFront
(
)
;
else
if
(
k
!
=
e
.
front
(
)
.
key
(
)
)
entryMoved
(
e
k
)
;
}
assertEntriesNotAboutToBeFinalized
(
)
;
}
void
finish
(
)
override
{
Base
:
:
finish
(
)
;
}
void
traceMappings
(
WeakMapTracer
*
tracer
)
override
{
for
(
Range
r
=
Base
:
:
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
gc
:
:
Cell
*
key
=
gc
:
:
ToMarkable
(
r
.
front
(
)
.
key
(
)
)
;
gc
:
:
Cell
*
value
=
gc
:
:
ToMarkable
(
r
.
front
(
)
.
value
(
)
)
;
if
(
key
&
&
value
)
{
tracer
-
>
trace
(
memberOf
JS
:
:
GCCellPtr
(
r
.
front
(
)
.
key
(
)
.
get
(
)
)
JS
:
:
GCCellPtr
(
r
.
front
(
)
.
value
(
)
.
get
(
)
)
)
;
}
}
}
void
entryMoved
(
Enum
&
e
const
Key
&
k
)
{
e
.
rekeyFront
(
k
)
;
}
protected
:
void
assertEntriesNotAboutToBeFinalized
(
)
{
#
if
DEBUG
for
(
Range
r
=
Base
:
:
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
Key
k
(
r
.
front
(
)
.
key
(
)
)
;
MOZ_ASSERT
(
!
gc
:
:
IsAboutToBeFinalized
(
&
k
)
)
;
MOZ_ASSERT
(
!
gc
:
:
IsAboutToBeFinalized
(
&
r
.
front
(
)
.
value
(
)
)
)
;
MOZ_ASSERT
(
k
=
=
r
.
front
(
)
.
key
(
)
)
;
}
#
endif
}
}
;
extern
JSObject
*
InitBareWeakMapCtor
(
JSContext
*
cx
js
:
:
HandleObject
obj
)
;
extern
bool
WeakMap_has
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
WeakMap_get
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
WeakMap_set
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
WeakMap_delete
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
WeakMap_clear
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
JSObject
*
InitWeakMapClass
(
JSContext
*
cx
HandleObject
obj
)
;
}
#
endif
