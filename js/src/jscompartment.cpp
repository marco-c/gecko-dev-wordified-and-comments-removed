#
include
"
jscompartmentinlines
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsgc
.
h
"
#
include
"
jsiter
.
h
"
#
include
"
jswatchpoint
.
h
"
#
include
"
jswrapper
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
jit
/
JitCompartment
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
#
include
"
js
/
Date
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
proxy
/
DeadObjectProxy
.
h
"
#
include
"
vm
/
Debugger
.
h
"
#
include
"
vm
/
StopIterationObject
.
h
"
#
include
"
vm
/
WrapperObject
.
h
"
#
include
"
jsatominlines
.
h
"
#
include
"
jsfuninlines
.
h
"
#
include
"
jsgcinlines
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
jsscriptinlines
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
PodArrayZero
;
JSCompartment
:
:
JSCompartment
(
Zone
*
zone
const
JS
:
:
CompartmentOptions
&
options
=
JS
:
:
CompartmentOptions
(
)
)
:
creationOptions_
(
options
.
creationOptions
(
)
)
behaviors_
(
options
.
behaviors
(
)
)
zone_
(
zone
)
runtime_
(
zone
-
>
runtimeFromMainThread
(
)
)
principals_
(
nullptr
)
isSystem_
(
false
)
isSelfHosting
(
false
)
marked
(
true
)
warnedAboutExprClosure
(
false
)
warnedAboutForEach
(
false
)
#
ifdef
DEBUG
firedOnNewGlobalObject
(
false
)
#
endif
global_
(
nullptr
)
enterCompartmentDepth
(
0
)
performanceMonitoring
(
runtime_
)
data
(
nullptr
)
allocationMetadataBuilder
(
nullptr
)
lastAnimationTime
(
0
)
regExps
(
runtime_
)
globalWriteBarriered
(
0
)
detachedTypedObjects
(
0
)
objectMetadataState
(
ImmediateMetadata
(
)
)
selfHostingScriptSource
(
nullptr
)
objectMetadataTable
(
nullptr
)
innerViews
(
zone
InnerViewTable
(
)
)
lazyArrayBuffers
(
nullptr
)
wasm
(
zone
)
nonSyntacticLexicalEnvironments_
(
nullptr
)
gcIncomingGrayPointers
(
nullptr
)
debugModeBits
(
0
)
watchpointMap
(
nullptr
)
scriptCountsMap
(
nullptr
)
debugScriptMap
(
nullptr
)
debugEnvs
(
nullptr
)
enumerators
(
nullptr
)
lastCachedNativeIterator
(
nullptr
)
compartmentStats_
(
nullptr
)
scheduledForDestruction
(
false
)
maybeAlive
(
true
)
jitCompartment_
(
nullptr
)
mappedArgumentsTemplate_
(
nullptr
)
unmappedArgumentsTemplate_
(
nullptr
)
lcovOutput
(
)
{
PodArrayZero
(
sawDeprecatedLanguageExtension
)
;
runtime_
-
>
numCompartments
+
+
;
MOZ_ASSERT_IF
(
creationOptions_
.
mergeable
(
)
creationOptions_
.
invisibleToDebugger
(
)
)
;
}
JSCompartment
:
:
~
JSCompartment
(
)
{
reportTelemetry
(
)
;
JSRuntime
*
rt
=
runtimeFromMainThread
(
)
;
if
(
rt
-
>
lcovOutput
.
isEnabled
(
)
)
rt
-
>
lcovOutput
.
writeLCovResult
(
lcovOutput
)
;
js_delete
(
jitCompartment_
)
;
js_delete
(
watchpointMap
)
;
js_delete
(
scriptCountsMap
)
;
js_delete
(
debugScriptMap
)
;
js_delete
(
debugEnvs
)
;
js_delete
(
objectMetadataTable
)
;
js_delete
(
lazyArrayBuffers
)
;
js_delete
(
nonSyntacticLexicalEnvironments_
)
js_free
(
enumerators
)
;
runtime_
-
>
numCompartments
-
-
;
}
bool
JSCompartment
:
:
init
(
JSContext
*
maybecx
)
{
JS
:
:
ResetTimeZone
(
)
;
if
(
!
crossCompartmentWrappers
.
init
(
0
)
)
{
if
(
maybecx
)
ReportOutOfMemory
(
maybecx
)
;
return
false
;
}
if
(
!
regExps
.
init
(
maybecx
)
)
return
false
;
enumerators
=
NativeIterator
:
:
allocateSentinel
(
maybecx
)
;
if
(
!
enumerators
)
return
false
;
if
(
!
savedStacks_
.
init
(
)
|
|
!
varNames_
.
init
(
)
)
{
if
(
maybecx
)
ReportOutOfMemory
(
maybecx
)
;
return
false
;
}
return
true
;
}
jit
:
:
JitRuntime
*
JSRuntime
:
:
createJitRuntime
(
JSContext
*
cx
)
{
AutoLockForExclusiveAccess
atomsLock
(
cx
)
;
MOZ_ASSERT
(
!
jitRuntime_
)
;
jit
:
:
JitRuntime
*
jrt
=
cx
-
>
new_
<
jit
:
:
JitRuntime
>
(
cx
-
>
runtime
(
)
)
;
if
(
!
jrt
)
return
nullptr
;
JitRuntime
:
:
AutoPreventBackedgePatching
apbp
(
cx
-
>
runtime
(
)
jrt
)
;
jitRuntime_
=
jrt
;
AutoEnterOOMUnsafeRegion
noOOM
;
if
(
!
jitRuntime_
-
>
initialize
(
cx
atomsLock
)
)
{
noOOM
.
crash
(
"
OOM
in
createJitRuntime
"
)
;
}
return
jitRuntime_
;
}
bool
JSCompartment
:
:
ensureJitCompartmentExists
(
JSContext
*
cx
)
{
using
namespace
js
:
:
jit
;
if
(
jitCompartment_
)
return
true
;
if
(
!
zone
(
)
-
>
getJitZone
(
cx
)
)
return
false
;
jitCompartment_
=
cx
-
>
new_
<
JitCompartment
>
(
)
;
if
(
!
jitCompartment_
)
return
false
;
if
(
!
jitCompartment_
-
>
initialize
(
cx
)
)
{
js_delete
(
jitCompartment_
)
;
jitCompartment_
=
nullptr
;
return
false
;
}
return
true
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
namespace
{
struct
CheckGCThingAfterMovingGCFunctor
{
template
<
class
T
>
void
operator
(
)
(
T
*
t
)
{
CheckGCThingAfterMovingGC
(
*
t
)
;
}
}
;
}
void
JSCompartment
:
:
checkWrapperMapAfterMovingGC
(
)
{
for
(
WrapperMap
:
:
Enum
e
(
crossCompartmentWrappers
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
e
.
front
(
)
.
mutableKey
(
)
.
applyToWrapped
(
CheckGCThingAfterMovingGCFunctor
(
)
)
;
e
.
front
(
)
.
mutableKey
(
)
.
applyToDebugger
(
CheckGCThingAfterMovingGCFunctor
(
)
)
;
WrapperMap
:
:
Ptr
ptr
=
crossCompartmentWrappers
.
lookup
(
e
.
front
(
)
.
key
(
)
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
e
.
front
(
)
)
;
}
}
#
endif
bool
JSCompartment
:
:
putWrapper
(
JSContext
*
cx
const
CrossCompartmentKey
&
wrapped
const
js
:
:
Value
&
wrapper
)
{
MOZ_ASSERT
(
wrapped
.
is
<
JSString
*
>
(
)
=
=
wrapper
.
isString
(
)
)
;
MOZ_ASSERT_IF
(
!
wrapped
.
is
<
JSString
*
>
(
)
wrapper
.
isObject
(
)
)
;
if
(
!
crossCompartmentWrappers
.
put
(
wrapped
wrapper
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
static
JSString
*
CopyStringPure
(
JSContext
*
cx
JSString
*
str
)
{
size_t
len
=
str
-
>
length
(
)
;
JSString
*
copy
;
if
(
str
-
>
isLinear
(
)
)
{
if
(
str
-
>
hasLatin1Chars
(
)
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
copy
=
NewStringCopyN
<
NoGC
>
(
cx
str
-
>
asLinear
(
)
.
latin1Chars
(
nogc
)
len
)
;
}
else
{
JS
:
:
AutoCheckCannotGC
nogc
;
copy
=
NewStringCopyNDontDeflate
<
NoGC
>
(
cx
str
-
>
asLinear
(
)
.
twoByteChars
(
nogc
)
len
)
;
}
if
(
copy
)
return
copy
;
AutoStableStringChars
chars
(
cx
)
;
if
(
!
chars
.
init
(
cx
str
)
)
return
nullptr
;
return
chars
.
isLatin1
(
)
?
NewStringCopyN
<
CanGC
>
(
cx
chars
.
latin1Range
(
)
.
start
(
)
.
get
(
)
len
)
:
NewStringCopyNDontDeflate
<
CanGC
>
(
cx
chars
.
twoByteRange
(
)
.
start
(
)
.
get
(
)
len
)
;
}
if
(
str
-
>
hasLatin1Chars
(
)
)
{
ScopedJSFreePtr
<
Latin1Char
>
copiedChars
;
if
(
!
str
-
>
asRope
(
)
.
copyLatin1CharsZ
(
cx
copiedChars
)
)
return
nullptr
;
return
NewString
<
CanGC
>
(
cx
copiedChars
.
forget
(
)
len
)
;
}
ScopedJSFreePtr
<
char16_t
>
copiedChars
;
if
(
!
str
-
>
asRope
(
)
.
copyTwoByteCharsZ
(
cx
copiedChars
)
)
return
nullptr
;
return
NewStringDontDeflate
<
CanGC
>
(
cx
copiedChars
.
forget
(
)
len
)
;
}
bool
JSCompartment
:
:
wrap
(
JSContext
*
cx
MutableHandleString
strp
)
{
MOZ_ASSERT
(
!
cx
-
>
runtime
(
)
-
>
isAtomsCompartment
(
this
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
JSString
*
str
=
strp
;
if
(
str
-
>
zoneFromAnyThread
(
)
=
=
zone
(
)
)
return
true
;
if
(
str
-
>
isAtom
(
)
)
{
MOZ_ASSERT
(
str
-
>
isPermanentAtom
(
)
|
|
str
-
>
zone
(
)
-
>
isAtomsZone
(
)
)
;
return
true
;
}
RootedValue
key
(
cx
StringValue
(
str
)
)
;
if
(
WrapperMap
:
:
Ptr
p
=
crossCompartmentWrappers
.
lookup
(
CrossCompartmentKey
(
key
)
)
)
{
strp
.
set
(
p
-
>
value
(
)
.
get
(
)
.
toString
(
)
)
;
return
true
;
}
JSString
*
copy
=
CopyStringPure
(
cx
str
)
;
if
(
!
copy
)
return
false
;
if
(
!
putWrapper
(
cx
CrossCompartmentKey
(
key
)
StringValue
(
copy
)
)
)
return
false
;
strp
.
set
(
copy
)
;
return
true
;
}
bool
JSCompartment
:
:
getNonWrapperObjectForCurrentCompartment
(
JSContext
*
cx
MutableHandleObject
obj
)
{
MOZ_ASSERT
(
cx
-
>
global
(
)
)
;
MOZ_ASSERT
(
!
cx
-
>
runtime
(
)
-
>
isSelfHostingGlobal
(
cx
-
>
global
(
)
)
)
;
MOZ_ASSERT
(
!
cx
-
>
runtime
(
)
-
>
isSelfHostingGlobal
(
&
obj
-
>
global
(
)
)
)
;
if
(
obj
-
>
compartment
(
)
=
=
this
)
{
obj
.
set
(
ToWindowProxyIfWindow
(
obj
)
)
;
return
true
;
}
RootedObject
objectPassedToWrap
(
cx
obj
)
;
obj
.
set
(
UncheckedUnwrap
(
obj
true
)
)
;
if
(
obj
-
>
compartment
(
)
=
=
this
)
{
MOZ_ASSERT
(
!
IsWindow
(
obj
)
)
;
return
true
;
}
if
(
obj
-
>
is
<
StopIterationObject
>
(
)
)
{
RootedObject
stopIteration
(
cx
)
;
if
(
!
GetBuiltinConstructor
(
cx
JSProto_StopIteration
&
stopIteration
)
)
return
false
;
obj
.
set
(
stopIteration
)
;
return
true
;
}
auto
preWrap
=
cx
-
>
runtime
(
)
-
>
wrapObjectCallbacks
-
>
preWrap
;
JS_CHECK_SYSTEM_RECURSION
(
cx
return
false
)
;
if
(
preWrap
)
{
preWrap
(
cx
cx
-
>
global
(
)
obj
objectPassedToWrap
obj
)
;
if
(
!
obj
)
return
false
;
}
MOZ_ASSERT
(
!
IsWindow
(
obj
)
)
;
return
true
;
}
bool
JSCompartment
:
:
getOrCreateWrapper
(
JSContext
*
cx
HandleObject
existing
MutableHandleObject
obj
)
{
RootedValue
key
(
cx
ObjectValue
(
*
obj
)
)
;
if
(
WrapperMap
:
:
Ptr
p
=
crossCompartmentWrappers
.
lookup
(
CrossCompartmentKey
(
key
)
)
)
{
obj
.
set
(
&
p
-
>
value
(
)
.
get
(
)
.
toObject
(
)
)
;
MOZ_ASSERT
(
obj
-
>
is
<
CrossCompartmentWrapperObject
>
(
)
)
;
return
true
;
}
auto
wrap
=
cx
-
>
runtime
(
)
-
>
wrapObjectCallbacks
-
>
wrap
;
RootedObject
wrapper
(
cx
wrap
(
cx
existing
obj
)
)
;
if
(
!
wrapper
)
return
false
;
MOZ_ASSERT
(
Wrapper
:
:
wrappedObject
(
wrapper
)
=
=
&
key
.
get
(
)
.
toObject
(
)
)
;
if
(
!
putWrapper
(
cx
CrossCompartmentKey
(
key
)
ObjectValue
(
*
wrapper
)
)
)
{
if
(
wrapper
-
>
is
<
CrossCompartmentWrapperObject
>
(
)
)
NukeCrossCompartmentWrapper
(
cx
wrapper
)
;
return
false
;
}
obj
.
set
(
wrapper
)
;
return
true
;
}
bool
JSCompartment
:
:
wrap
(
JSContext
*
cx
MutableHandleObject
obj
)
{
MOZ_ASSERT
(
!
cx
-
>
runtime
(
)
-
>
isAtomsCompartment
(
this
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
if
(
!
obj
)
return
true
;
AutoDisableProxyCheck
adpc
(
cx
-
>
runtime
(
)
)
;
MOZ_ASSERT
(
!
ObjectIsMarkedGray
(
obj
)
)
;
if
(
!
getNonWrapperObjectForCurrentCompartment
(
cx
obj
)
)
return
false
;
if
(
obj
-
>
compartment
(
)
!
=
this
)
{
if
(
!
getOrCreateWrapper
(
cx
nullptr
obj
)
)
return
false
;
}
ExposeObjectToActiveJS
(
obj
)
;
return
true
;
}
bool
JSCompartment
:
:
rewrap
(
JSContext
*
cx
MutableHandleObject
obj
HandleObject
existingArg
)
{
MOZ_ASSERT
(
!
cx
-
>
runtime
(
)
-
>
isAtomsCompartment
(
this
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
MOZ_ASSERT
(
obj
)
;
MOZ_ASSERT
(
existingArg
)
;
MOZ_ASSERT
(
existingArg
-
>
compartment
(
)
=
=
cx
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
IsDeadProxyObject
(
existingArg
)
)
;
AutoDisableProxyCheck
adpc
(
cx
-
>
runtime
(
)
)
;
RootedObject
existing
(
cx
existingArg
)
;
if
(
existing
-
>
hasStaticPrototype
(
)
|
|
existing
-
>
isCallable
(
)
|
|
obj
-
>
isCallable
(
)
)
{
existing
.
set
(
nullptr
)
;
}
if
(
!
getNonWrapperObjectForCurrentCompartment
(
cx
obj
)
)
return
false
;
if
(
obj
-
>
compartment
(
)
=
=
this
)
return
true
;
return
getOrCreateWrapper
(
cx
existing
obj
)
;
}
bool
JSCompartment
:
:
wrap
(
JSContext
*
cx
MutableHandle
<
PropertyDescriptor
>
desc
)
{
if
(
!
wrap
(
cx
desc
.
object
(
)
)
)
return
false
;
if
(
desc
.
hasGetterObject
(
)
)
{
if
(
!
wrap
(
cx
desc
.
getterObject
(
)
)
)
return
false
;
}
if
(
desc
.
hasSetterObject
(
)
)
{
if
(
!
wrap
(
cx
desc
.
setterObject
(
)
)
)
return
false
;
}
return
wrap
(
cx
desc
.
value
(
)
)
;
}
bool
JSCompartment
:
:
wrap
(
JSContext
*
cx
MutableHandle
<
GCVector
<
Value
>
>
vec
)
{
for
(
size_t
i
=
0
;
i
<
vec
.
length
(
)
;
+
+
i
)
{
if
(
!
wrap
(
cx
vec
[
i
]
)
)
return
false
;
}
return
true
;
}
LexicalEnvironmentObject
*
JSCompartment
:
:
getOrCreateNonSyntacticLexicalEnvironment
(
JSContext
*
cx
HandleObject
enclosing
)
{
if
(
!
nonSyntacticLexicalEnvironments_
)
{
nonSyntacticLexicalEnvironments_
=
cx
-
>
new_
<
ObjectWeakMap
>
(
cx
)
;
if
(
!
nonSyntacticLexicalEnvironments_
|
|
!
nonSyntacticLexicalEnvironments_
-
>
init
(
)
)
return
nullptr
;
}
MOZ_ASSERT
(
!
enclosing
-
>
as
<
WithEnvironmentObject
>
(
)
.
isSyntactic
(
)
)
;
RootedObject
key
(
cx
&
enclosing
-
>
as
<
WithEnvironmentObject
>
(
)
.
object
(
)
)
;
RootedObject
lexicalEnv
(
cx
nonSyntacticLexicalEnvironments_
-
>
lookup
(
key
)
)
;
if
(
!
lexicalEnv
)
{
lexicalEnv
=
LexicalEnvironmentObject
:
:
createNonSyntactic
(
cx
enclosing
)
;
if
(
!
lexicalEnv
)
return
nullptr
;
if
(
!
nonSyntacticLexicalEnvironments_
-
>
add
(
cx
key
lexicalEnv
)
)
return
nullptr
;
}
return
&
lexicalEnv
-
>
as
<
LexicalEnvironmentObject
>
(
)
;
}
LexicalEnvironmentObject
*
JSCompartment
:
:
getNonSyntacticLexicalEnvironment
(
JSObject
*
enclosing
)
const
{
if
(
!
nonSyntacticLexicalEnvironments_
)
return
nullptr
;
if
(
!
enclosing
-
>
is
<
WithEnvironmentObject
>
(
)
)
return
nullptr
;
JSObject
*
key
=
&
enclosing
-
>
as
<
WithEnvironmentObject
>
(
)
.
object
(
)
;
JSObject
*
lexicalEnv
=
nonSyntacticLexicalEnvironments_
-
>
lookup
(
key
)
;
if
(
!
lexicalEnv
)
return
nullptr
;
return
&
lexicalEnv
-
>
as
<
LexicalEnvironmentObject
>
(
)
;
}
bool
JSCompartment
:
:
addToVarNames
(
JSContext
*
cx
JS
:
:
Handle
<
JSAtom
*
>
name
)
{
if
(
varNames_
.
put
(
name
.
get
(
)
)
)
return
true
;
ReportOutOfMemory
(
cx
)
;
return
false
;
}
void
JSCompartment
:
:
traceOutgoingCrossCompartmentWrappers
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
trc
-
>
runtime
(
)
-
>
isHeapMajorCollecting
(
)
)
;
MOZ_ASSERT
(
!
zone
(
)
-
>
isCollecting
(
)
|
|
trc
-
>
runtime
(
)
-
>
gc
.
isHeapCompacting
(
)
)
;
for
(
WrapperMap
:
:
Enum
e
(
crossCompartmentWrappers
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Value
v
=
e
.
front
(
)
.
value
(
)
.
unbarrieredGet
(
)
;
if
(
e
.
front
(
)
.
key
(
)
.
is
<
JSObject
*
>
(
)
)
{
ProxyObject
*
wrapper
=
&
v
.
toObject
(
)
.
as
<
ProxyObject
>
(
)
;
TraceEdge
(
trc
wrapper
-
>
slotOfPrivate
(
)
"
cross
-
compartment
wrapper
"
)
;
}
}
}
void
JSCompartment
:
:
traceIncomingCrossCompartmentEdgesForZoneGC
(
JSTracer
*
trc
)
{
gcstats
:
:
AutoPhase
ap
(
trc
-
>
runtime
(
)
-
>
gc
.
stats
gcstats
:
:
PHASE_MARK_CCWS
)
;
MOZ_ASSERT
(
trc
-
>
runtime
(
)
-
>
isHeapMajorCollecting
(
)
)
;
for
(
CompartmentsIter
c
(
trc
-
>
runtime
(
)
SkipAtoms
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
if
(
!
c
-
>
zone
(
)
-
>
isCollecting
(
)
)
c
-
>
traceOutgoingCrossCompartmentWrappers
(
trc
)
;
}
Debugger
:
:
markIncomingCrossCompartmentEdges
(
trc
)
;
}
void
JSCompartment
:
:
trace
(
JSTracer
*
trc
)
{
savedStacks_
.
trace
(
trc
)
;
if
(
!
trc
-
>
runtime
(
)
-
>
isHeapMinorCollecting
(
)
)
varNames_
.
trace
(
trc
)
;
}
void
JSCompartment
:
:
traceRoots
(
JSTracer
*
trc
js
:
:
gc
:
:
GCRuntime
:
:
TraceOrMarkRuntime
traceOrMark
)
{
if
(
objectMetadataState
.
is
<
PendingMetadata
>
(
)
)
{
TraceRoot
(
trc
&
objectMetadataState
.
as
<
PendingMetadata
>
(
)
"
on
-
stack
object
pending
metadata
"
)
;
}
if
(
!
trc
-
>
runtime
(
)
-
>
isHeapMinorCollecting
(
)
)
{
if
(
jitCompartment_
)
jitCompartment_
-
>
mark
(
trc
this
)
;
if
(
enterCompartmentDepth
&
&
global_
.
unbarrieredGet
(
)
)
TraceRoot
(
trc
global_
.
unsafeUnbarrieredForTracing
(
)
"
on
-
stack
compartment
global
"
)
;
}
if
(
traceOrMark
=
=
js
:
:
gc
:
:
GCRuntime
:
:
MarkRuntime
&
&
!
zone
(
)
-
>
isCollecting
(
)
)
return
;
if
(
traceOrMark
=
=
js
:
:
gc
:
:
GCRuntime
:
:
TraceRuntime
)
{
if
(
watchpointMap
)
watchpointMap
-
>
markAll
(
trc
)
;
}
if
(
debugEnvs
)
debugEnvs
-
>
mark
(
trc
)
;
if
(
lazyArrayBuffers
)
lazyArrayBuffers
-
>
trace
(
trc
)
;
if
(
objectMetadataTable
)
objectMetadataTable
-
>
trace
(
trc
)
;
if
(
scriptCountsMap
&
&
trc
-
>
runtime
(
)
-
>
profilingScripts
&
&
!
trc
-
>
runtime
(
)
-
>
isHeapMinorCollecting
(
)
)
{
MOZ_ASSERT_IF
(
!
trc
-
>
runtime
(
)
-
>
isBeingDestroyed
(
)
collectCoverage
(
)
)
;
for
(
ScriptCountsMap
:
:
Range
r
=
scriptCountsMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSScript
*
script
=
const_cast
<
JSScript
*
>
(
r
.
front
(
)
.
key
(
)
)
;
MOZ_ASSERT
(
script
-
>
hasScriptCounts
(
)
)
;
TraceRoot
(
trc
&
script
"
profilingScripts
"
)
;
MOZ_ASSERT
(
script
=
=
r
.
front
(
)
.
key
(
)
"
const_cast
is
only
a
work
-
around
"
)
;
}
}
if
(
nonSyntacticLexicalEnvironments_
)
nonSyntacticLexicalEnvironments_
-
>
trace
(
trc
)
;
wasm
.
trace
(
trc
)
;
}
void
JSCompartment
:
:
finishRoots
(
)
{
if
(
watchpointMap
)
watchpointMap
-
>
clear
(
)
;
if
(
debugEnvs
)
debugEnvs
-
>
finish
(
)
;
if
(
lazyArrayBuffers
)
lazyArrayBuffers
-
>
clear
(
)
;
if
(
objectMetadataTable
)
objectMetadataTable
-
>
clear
(
)
;
clearScriptCounts
(
)
;
if
(
nonSyntacticLexicalEnvironments_
)
nonSyntacticLexicalEnvironments_
-
>
clear
(
)
;
}
void
JSCompartment
:
:
sweepAfterMinorGC
(
JSTracer
*
trc
)
{
globalWriteBarriered
=
0
;
if
(
innerViews
.
needsSweepAfterMinorGC
(
)
)
innerViews
.
sweepAfterMinorGC
(
)
;
crossCompartmentWrappers
.
sweepAfterMinorGC
(
trc
)
;
}
void
JSCompartment
:
:
sweepSavedStacks
(
)
{
savedStacks_
.
sweep
(
)
;
}
void
JSCompartment
:
:
sweepGlobalObject
(
FreeOp
*
fop
)
{
if
(
global_
&
&
IsAboutToBeFinalized
(
&
global_
)
)
{
if
(
isDebuggee
(
)
)
Debugger
:
:
detachAllDebuggersFromGlobal
(
fop
global_
.
unbarrieredGet
(
)
)
;
global_
.
set
(
nullptr
)
;
}
}
void
JSCompartment
:
:
sweepSelfHostingScriptSource
(
)
{
if
(
selfHostingScriptSource
.
unbarrieredGet
(
)
&
&
IsAboutToBeFinalized
(
&
selfHostingScriptSource
)
)
{
selfHostingScriptSource
.
set
(
nullptr
)
;
}
}
void
JSCompartment
:
:
sweepJitCompartment
(
FreeOp
*
fop
)
{
if
(
jitCompartment_
)
jitCompartment_
-
>
sweep
(
fop
this
)
;
}
void
JSCompartment
:
:
sweepRegExps
(
)
{
regExps
.
sweep
(
runtimeFromAnyThread
(
)
)
;
}
void
JSCompartment
:
:
sweepDebugEnvironments
(
)
{
JSRuntime
*
rt
=
runtimeFromAnyThread
(
)
;
if
(
debugEnvs
)
debugEnvs
-
>
sweep
(
rt
)
;
}
void
JSCompartment
:
:
sweepNativeIterators
(
)
{
NativeIterator
*
ni
=
enumerators
-
>
next
(
)
;
while
(
ni
!
=
enumerators
)
{
JSObject
*
iterObj
=
ni
-
>
iterObj
(
)
;
NativeIterator
*
next
=
ni
-
>
next
(
)
;
if
(
gc
:
:
IsAboutToBeFinalizedUnbarriered
(
&
iterObj
)
)
ni
-
>
unlink
(
)
;
ni
=
next
;
}
}
void
JSCompartment
:
:
sweepCrossCompartmentWrappers
(
)
{
crossCompartmentWrappers
.
sweep
(
)
;
}
namespace
{
struct
TraceRootFunctor
{
JSTracer
*
trc
;
const
char
*
name
;
TraceRootFunctor
(
JSTracer
*
trc
const
char
*
name
)
:
trc
(
trc
)
name
(
name
)
{
}
template
<
class
T
>
void
operator
(
)
(
T
*
t
)
{
return
TraceRoot
(
trc
t
name
)
;
}
}
;
struct
NeedsSweepUnbarrieredFunctor
{
template
<
class
T
>
bool
operator
(
)
(
T
*
t
)
const
{
return
IsAboutToBeFinalizedUnbarriered
(
t
)
;
}
}
;
}
void
CrossCompartmentKey
:
:
trace
(
JSTracer
*
trc
)
{
applyToWrapped
(
TraceRootFunctor
(
trc
"
CrossCompartmentKey
:
:
wrapped
"
)
)
;
applyToDebugger
(
TraceRootFunctor
(
trc
"
CrossCompartmentKey
:
:
debugger
"
)
)
;
}
bool
CrossCompartmentKey
:
:
needsSweep
(
)
{
return
applyToWrapped
(
NeedsSweepUnbarrieredFunctor
(
)
)
|
|
applyToDebugger
(
NeedsSweepUnbarrieredFunctor
(
)
)
;
}
void
JSCompartment
:
:
sweepTemplateObjects
(
)
{
if
(
mappedArgumentsTemplate_
&
&
IsAboutToBeFinalized
(
&
mappedArgumentsTemplate_
)
)
mappedArgumentsTemplate_
.
set
(
nullptr
)
;
if
(
unmappedArgumentsTemplate_
&
&
IsAboutToBeFinalized
(
&
unmappedArgumentsTemplate_
)
)
unmappedArgumentsTemplate_
.
set
(
nullptr
)
;
}
void
JSCompartment
:
:
fixupCrossCompartmentWrappersAfterMovingGC
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
trc
-
>
runtime
(
)
-
>
gc
.
isHeapCompacting
(
)
)
;
for
(
CompartmentsIter
comp
(
trc
-
>
runtime
(
)
SkipAtoms
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
comp
-
>
sweepCrossCompartmentWrappers
(
)
;
comp
-
>
traceOutgoingCrossCompartmentWrappers
(
trc
)
;
}
}
void
JSCompartment
:
:
fixupAfterMovingGC
(
)
{
purge
(
)
;
fixupGlobal
(
)
;
objectGroups
.
fixupTablesAfterMovingGC
(
)
;
fixupScriptMapsAfterMovingGC
(
)
;
}
void
JSCompartment
:
:
fixupGlobal
(
)
{
GlobalObject
*
global
=
*
global_
.
unsafeGet
(
)
;
if
(
global
)
global_
.
set
(
MaybeForwarded
(
global
)
)
;
}
void
JSCompartment
:
:
fixupScriptMapsAfterMovingGC
(
)
{
if
(
scriptCountsMap
)
{
for
(
ScriptCountsMap
:
:
Enum
e
(
*
scriptCountsMap
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
JSScript
*
script
=
e
.
front
(
)
.
key
(
)
;
if
(
!
IsAboutToBeFinalizedUnbarriered
(
&
script
)
&
&
script
!
=
e
.
front
(
)
.
key
(
)
)
e
.
rekeyFront
(
script
)
;
}
}
if
(
debugScriptMap
)
{
for
(
DebugScriptMap
:
:
Enum
e
(
*
debugScriptMap
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
JSScript
*
script
=
e
.
front
(
)
.
key
(
)
;
if
(
!
IsAboutToBeFinalizedUnbarriered
(
&
script
)
&
&
script
!
=
e
.
front
(
)
.
key
(
)
)
e
.
rekeyFront
(
script
)
;
}
}
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
JSCompartment
:
:
checkScriptMapsAfterMovingGC
(
)
{
if
(
scriptCountsMap
)
{
for
(
auto
r
=
scriptCountsMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSScript
*
script
=
r
.
front
(
)
.
key
(
)
;
CheckGCThingAfterMovingGC
(
script
)
;
auto
ptr
=
scriptCountsMap
-
>
lookup
(
script
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
if
(
debugScriptMap
)
{
for
(
auto
r
=
debugScriptMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSScript
*
script
=
r
.
front
(
)
.
key
(
)
;
CheckGCThingAfterMovingGC
(
script
)
;
DebugScript
*
ds
=
r
.
front
(
)
.
value
(
)
;
for
(
uint32_t
i
=
0
;
i
<
ds
-
>
numSites
;
i
+
+
)
{
BreakpointSite
*
site
=
ds
-
>
breakpoints
[
i
]
;
if
(
site
)
CheckGCThingAfterMovingGC
(
site
-
>
script
)
;
}
auto
ptr
=
debugScriptMap
-
>
lookup
(
script
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
}
#
endif
void
JSCompartment
:
:
purge
(
)
{
dtoaCache
.
purge
(
)
;
lastCachedNativeIterator
=
nullptr
;
}
void
JSCompartment
:
:
clearTables
(
)
{
global_
.
set
(
nullptr
)
;
MOZ_ASSERT
(
crossCompartmentWrappers
.
empty
(
)
)
;
MOZ_ASSERT
(
!
jitCompartment_
)
;
MOZ_ASSERT
(
!
debugEnvs
)
;
MOZ_ASSERT
(
enumerators
-
>
next
(
)
=
=
enumerators
)
;
MOZ_ASSERT
(
regExps
.
empty
(
)
)
;
objectGroups
.
clearTables
(
)
;
if
(
savedStacks_
.
initialized
(
)
)
savedStacks_
.
clear
(
)
;
if
(
varNames_
.
initialized
(
)
)
varNames_
.
clear
(
)
;
}
void
JSCompartment
:
:
setAllocationMetadataBuilder
(
const
js
:
:
AllocationMetadataBuilder
*
builder
)
{
ReleaseAllJITCode
(
runtime_
-
>
defaultFreeOp
(
)
)
;
allocationMetadataBuilder
=
builder
;
}
void
JSCompartment
:
:
clearObjectMetadata
(
)
{
js_delete
(
objectMetadataTable
)
;
objectMetadataTable
=
nullptr
;
}
void
JSCompartment
:
:
setNewObjectMetadata
(
JSContext
*
cx
HandleObject
obj
)
{
assertSameCompartment
(
cx
this
obj
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
JSObject
*
metadata
=
allocationMetadataBuilder
-
>
build
(
cx
obj
oomUnsafe
)
)
{
assertSameCompartment
(
cx
metadata
)
;
if
(
!
objectMetadataTable
)
{
objectMetadataTable
=
cx
-
>
new_
<
ObjectWeakMap
>
(
cx
)
;
if
(
!
objectMetadataTable
|
|
!
objectMetadataTable
-
>
init
(
)
)
oomUnsafe
.
crash
(
"
setNewObjectMetadata
"
)
;
}
if
(
!
objectMetadataTable
-
>
add
(
cx
obj
metadata
)
)
oomUnsafe
.
crash
(
"
setNewObjectMetadata
"
)
;
}
}
static
bool
AddInnerLazyFunctionsFromScript
(
JSScript
*
script
AutoObjectVector
&
lazyFunctions
)
{
if
(
!
script
-
>
hasObjects
(
)
)
return
true
;
ObjectArray
*
objects
=
script
-
>
objects
(
)
;
for
(
size_t
i
=
0
;
i
<
objects
-
>
length
;
i
+
+
)
{
JSObject
*
obj
=
objects
-
>
vector
[
i
]
;
if
(
obj
-
>
is
<
JSFunction
>
(
)
&
&
obj
-
>
as
<
JSFunction
>
(
)
.
isInterpretedLazy
(
)
)
{
if
(
!
lazyFunctions
.
append
(
obj
)
)
return
false
;
}
}
return
true
;
}
static
bool
AddLazyFunctionsForCompartment
(
JSContext
*
cx
AutoObjectVector
&
lazyFunctions
AllocKind
kind
)
{
for
(
auto
i
=
cx
-
>
zone
(
)
-
>
cellIter
<
JSObject
>
(
kind
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
JSFunction
*
fun
=
&
i
-
>
as
<
JSFunction
>
(
)
;
if
(
gc
:
:
IsAboutToBeFinalizedUnbarriered
(
&
fun
)
|
|
fun
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
{
continue
;
}
if
(
fun
-
>
isInterpretedLazy
(
)
)
{
LazyScript
*
lazy
=
fun
-
>
lazyScriptOrNull
(
)
;
if
(
lazy
&
&
lazy
-
>
sourceObject
(
)
&
&
!
lazy
-
>
hasUncompiledEnclosingScript
(
)
)
{
if
(
!
lazyFunctions
.
append
(
fun
)
)
return
false
;
}
}
}
return
true
;
}
static
bool
CreateLazyScriptsForCompartment
(
JSContext
*
cx
)
{
AutoObjectVector
lazyFunctions
(
cx
)
;
if
(
!
AddLazyFunctionsForCompartment
(
cx
lazyFunctions
AllocKind
:
:
FUNCTION
)
)
return
false
;
if
(
!
AddLazyFunctionsForCompartment
(
cx
lazyFunctions
AllocKind
:
:
FUNCTION_EXTENDED
)
)
return
false
;
for
(
size_t
i
=
0
;
i
<
lazyFunctions
.
length
(
)
;
i
+
+
)
{
JSFunction
*
fun
=
&
lazyFunctions
[
i
]
-
>
as
<
JSFunction
>
(
)
;
if
(
!
fun
-
>
isInterpretedLazy
(
)
)
continue
;
LazyScript
*
lazy
=
fun
-
>
lazyScript
(
)
;
bool
lazyScriptHadNoScript
=
!
lazy
-
>
maybeScript
(
)
;
JSScript
*
script
=
fun
-
>
getOrCreateScript
(
cx
)
;
if
(
!
script
)
return
false
;
if
(
lazyScriptHadNoScript
&
&
!
AddInnerLazyFunctionsFromScript
(
script
lazyFunctions
)
)
return
false
;
}
return
true
;
}
bool
JSCompartment
:
:
ensureDelazifyScriptsForDebugger
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
if
(
needsDelazificationForDebugger
(
)
&
&
!
CreateLazyScriptsForCompartment
(
cx
)
)
return
false
;
debugModeBits
&
=
~
DebuggerNeedsDelazification
;
return
true
;
}
void
JSCompartment
:
:
updateDebuggerObservesFlag
(
unsigned
flag
)
{
MOZ_ASSERT
(
isDebuggee
(
)
)
;
MOZ_ASSERT
(
flag
=
=
DebuggerObservesAllExecution
|
|
flag
=
=
DebuggerObservesCoverage
|
|
flag
=
=
DebuggerObservesAsmJS
)
;
GlobalObject
*
global
=
zone
(
)
-
>
runtimeFromMainThread
(
)
-
>
gc
.
isForegroundSweeping
(
)
?
unsafeUnbarrieredMaybeGlobal
(
)
:
maybeGlobal
(
)
;
const
GlobalObject
:
:
DebuggerVector
*
v
=
global
-
>
getDebuggers
(
)
;
for
(
auto
p
=
v
-
>
begin
(
)
;
p
!
=
v
-
>
end
(
)
;
p
+
+
)
{
Debugger
*
dbg
=
*
p
;
if
(
flag
=
=
DebuggerObservesAllExecution
?
dbg
-
>
observesAllExecution
(
)
:
flag
=
=
DebuggerObservesCoverage
?
dbg
-
>
observesCoverage
(
)
:
dbg
-
>
observesAsmJS
(
)
)
{
debugModeBits
|
=
flag
;
return
;
}
}
debugModeBits
&
=
~
flag
;
}
void
JSCompartment
:
:
unsetIsDebuggee
(
)
{
if
(
isDebuggee
(
)
)
{
debugModeBits
&
=
~
DebuggerObservesMask
;
DebugEnvironments
:
:
onCompartmentUnsetIsDebuggee
(
this
)
;
}
}
void
JSCompartment
:
:
updateDebuggerObservesCoverage
(
)
{
bool
previousState
=
debuggerObservesCoverage
(
)
;
updateDebuggerObservesFlag
(
DebuggerObservesCoverage
)
;
if
(
previousState
=
=
debuggerObservesCoverage
(
)
)
return
;
if
(
debuggerObservesCoverage
(
)
)
{
for
(
ActivationIterator
iter
(
runtimeFromMainThread
(
)
)
;
!
iter
.
done
(
)
;
+
+
iter
)
{
if
(
iter
-
>
isInterpreter
(
)
)
iter
-
>
asInterpreter
(
)
-
>
enableInterruptsUnconditionally
(
)
;
}
return
;
}
if
(
collectCoverage
(
)
)
return
;
clearScriptCounts
(
)
;
}
bool
JSCompartment
:
:
collectCoverage
(
)
const
{
return
collectCoverageForPGO
(
)
|
|
collectCoverageForDebug
(
)
;
}
bool
JSCompartment
:
:
collectCoverageForPGO
(
)
const
{
return
!
JitOptions
.
disablePgo
;
}
bool
JSCompartment
:
:
collectCoverageForDebug
(
)
const
{
return
debuggerObservesCoverage
(
)
|
|
runtimeFromAnyThread
(
)
-
>
profilingScripts
|
|
runtimeFromAnyThread
(
)
-
>
lcovOutput
.
isEnabled
(
)
;
}
void
JSCompartment
:
:
clearScriptCounts
(
)
{
if
(
!
scriptCountsMap
)
return
;
for
(
ScriptCountsMap
:
:
Range
r
=
scriptCountsMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
ScriptCounts
*
value
=
r
.
front
(
)
.
value
(
)
;
r
.
front
(
)
.
key
(
)
-
>
takeOverScriptCountsMapEntry
(
value
)
;
js_delete
(
value
)
;
}
js_delete
(
scriptCountsMap
)
;
scriptCountsMap
=
nullptr
;
}
void
JSCompartment
:
:
clearBreakpointsIn
(
FreeOp
*
fop
js
:
:
Debugger
*
dbg
HandleObject
handler
)
{
for
(
auto
script
=
zone
(
)
-
>
cellIter
<
JSScript
>
(
)
;
!
script
.
done
(
)
;
script
.
next
(
)
)
{
if
(
script
-
>
compartment
(
)
=
=
this
&
&
script
-
>
hasAnyBreakpointsOrStepMode
(
)
)
script
-
>
clearBreakpointsIn
(
fop
dbg
handler
)
;
}
}
void
JSCompartment
:
:
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
tiAllocationSiteTables
size_t
*
tiArrayTypeTables
size_t
*
tiObjectTypeTables
size_t
*
compartmentObject
size_t
*
compartmentTables
size_t
*
innerViewsArg
size_t
*
lazyArrayBuffersArg
size_t
*
objectMetadataTablesArg
size_t
*
crossCompartmentWrappersArg
size_t
*
regexpCompartment
size_t
*
savedStacksSet
size_t
*
varNamesSet
size_t
*
nonSyntacticLexicalEnvironmentsArg
size_t
*
jitCompartment
size_t
*
privateData
)
{
*
compartmentObject
+
=
mallocSizeOf
(
this
)
;
objectGroups
.
addSizeOfExcludingThis
(
mallocSizeOf
tiAllocationSiteTables
tiArrayTypeTables
tiObjectTypeTables
compartmentTables
)
;
wasm
.
addSizeOfExcludingThis
(
mallocSizeOf
compartmentTables
)
;
*
innerViewsArg
+
=
innerViews
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
if
(
lazyArrayBuffers
)
*
lazyArrayBuffersArg
+
=
lazyArrayBuffers
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
if
(
objectMetadataTable
)
*
objectMetadataTablesArg
+
=
objectMetadataTable
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
*
crossCompartmentWrappersArg
+
=
crossCompartmentWrappers
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
*
regexpCompartment
+
=
regExps
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
*
savedStacksSet
+
=
savedStacks_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
*
varNamesSet
+
=
varNames_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
if
(
nonSyntacticLexicalEnvironments_
)
*
nonSyntacticLexicalEnvironmentsArg
+
=
nonSyntacticLexicalEnvironments_
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
if
(
jitCompartment_
)
*
jitCompartment
+
=
jitCompartment_
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
auto
callback
=
runtime_
-
>
sizeOfIncludingThisCompartmentCallback
;
if
(
callback
)
*
privateData
+
=
callback
(
mallocSizeOf
this
)
;
}
void
JSCompartment
:
:
reportTelemetry
(
)
{
if
(
isSystem_
)
return
;
JS
:
:
AutoSuppressGCAnalysis
nogc
;
int
id
=
creationOptions_
.
addonIdOrNull
(
)
?
JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_ADDONS
:
JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_CONTENT
;
for
(
size_t
i
=
0
;
i
<
DeprecatedLanguageExtensionCount
;
i
+
+
)
{
if
(
sawDeprecatedLanguageExtension
[
i
]
)
runtime_
-
>
addTelemetry
(
id
i
)
;
}
}
void
JSCompartment
:
:
addTelemetry
(
const
char
*
filename
DeprecatedLanguageExtension
e
)
{
if
(
isSystem_
)
return
;
if
(
!
creationOptions_
.
addonIdOrNull
(
)
&
&
(
!
filename
|
|
strncmp
(
filename
"
http
"
4
)
!
=
0
)
)
return
;
sawDeprecatedLanguageExtension
[
e
]
=
true
;
}
AutoSetNewObjectMetadata
:
:
AutoSetNewObjectMetadata
(
ExclusiveContext
*
ecx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL
)
:
CustomAutoRooter
(
ecx
)
cx_
(
ecx
-
>
maybeJSContext
(
)
)
prevState_
(
ecx
-
>
compartment
(
)
-
>
objectMetadataState
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
cx_
)
cx_
-
>
compartment
(
)
-
>
objectMetadataState
=
NewObjectMetadataState
(
DelayMetadata
(
)
)
;
}
AutoSetNewObjectMetadata
:
:
~
AutoSetNewObjectMetadata
(
)
{
if
(
!
cx_
)
return
;
if
(
!
cx_
-
>
isExceptionPending
(
)
&
&
cx_
-
>
compartment
(
)
-
>
hasObjectPendingMetadata
(
)
)
{
AutoSuppressGC
autoSuppressGC
(
cx_
)
;
JSObject
*
obj
=
cx_
-
>
compartment
(
)
-
>
objectMetadataState
.
as
<
PendingMetadata
>
(
)
;
cx_
-
>
compartment
(
)
-
>
objectMetadataState
=
prevState_
;
obj
=
SetNewObjectMetadata
(
cx_
obj
)
;
}
else
{
cx_
-
>
compartment
(
)
-
>
objectMetadataState
=
prevState_
;
}
}
