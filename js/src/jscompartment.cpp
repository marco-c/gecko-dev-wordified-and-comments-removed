#
include
"
jscompartmentinlines
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsgc
.
h
"
#
include
"
jsiter
.
h
"
#
include
"
jswatchpoint
.
h
"
#
include
"
jswrapper
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
jit
/
JitCompartment
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
#
include
"
js
/
Date
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
proxy
/
DeadObjectProxy
.
h
"
#
include
"
vm
/
Debugger
.
h
"
#
include
"
vm
/
StopIterationObject
.
h
"
#
include
"
vm
/
WrapperObject
.
h
"
#
include
"
jsatominlines
.
h
"
#
include
"
jsfuninlines
.
h
"
#
include
"
jsgcinlines
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
jsscriptinlines
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
namespace
js
:
:
jit
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
PodArrayZero
;
JSCompartment
:
:
JSCompartment
(
Zone
*
zone
const
JS
:
:
CompartmentOptions
&
options
=
JS
:
:
CompartmentOptions
(
)
)
:
creationOptions_
(
options
.
creationOptions
(
)
)
behaviors_
(
options
.
behaviors
(
)
)
zone_
(
zone
)
runtime_
(
zone
-
>
runtimeFromMainThread
(
)
)
principals_
(
nullptr
)
isSystem_
(
false
)
isSelfHosting
(
false
)
marked
(
true
)
warnedAboutFlagsArgument
(
false
)
warnedAboutExprClosure
(
false
)
warnedAboutRegExpMultiline
(
false
)
#
ifdef
DEBUG
firedOnNewGlobalObject
(
false
)
#
endif
global_
(
nullptr
)
enterCompartmentDepth
(
0
)
performanceMonitoring
(
runtime_
)
data
(
nullptr
)
objectMetadataCallback
(
nullptr
)
lastAnimationTime
(
0
)
regExps
(
runtime_
)
globalWriteBarriered
(
false
)
detachedTypedObjects
(
0
)
objectMetadataState
(
ImmediateMetadata
(
)
)
propertyTree
(
thisForCtor
(
)
)
selfHostingScriptSource
(
nullptr
)
objectMetadataTable
(
nullptr
)
lazyArrayBuffers
(
nullptr
)
nonSyntacticLexicalScopes_
(
nullptr
)
gcIncomingGrayPointers
(
nullptr
)
debugModeBits
(
0
)
watchpointMap
(
nullptr
)
scriptCountsMap
(
nullptr
)
debugScriptMap
(
nullptr
)
debugScopes
(
nullptr
)
enumerators
(
nullptr
)
compartmentStats
(
nullptr
)
scheduledForDestruction
(
false
)
maybeAlive
(
true
)
jitCompartment_
(
nullptr
)
mappedArgumentsTemplate_
(
nullptr
)
unmappedArgumentsTemplate_
(
nullptr
)
lcovOutput
(
)
{
PodArrayZero
(
sawDeprecatedLanguageExtension
)
;
runtime_
-
>
numCompartments
+
+
;
MOZ_ASSERT_IF
(
creationOptions_
.
mergeable
(
)
creationOptions_
.
invisibleToDebugger
(
)
)
;
}
JSCompartment
:
:
~
JSCompartment
(
)
{
reportTelemetry
(
)
;
JSRuntime
*
rt
=
runtimeFromMainThread
(
)
;
if
(
rt
-
>
lcovOutput
.
isEnabled
(
)
)
rt
-
>
lcovOutput
.
writeLCovResult
(
lcovOutput
)
;
js_delete
(
jitCompartment_
)
;
js_delete
(
watchpointMap
)
;
js_delete
(
scriptCountsMap
)
;
js_delete
(
debugScriptMap
)
;
js_delete
(
debugScopes
)
;
js_delete
(
objectMetadataTable
)
;
js_delete
(
lazyArrayBuffers
)
;
js_delete
(
nonSyntacticLexicalScopes_
)
js_free
(
enumerators
)
;
runtime_
-
>
numCompartments
-
-
;
}
bool
JSCompartment
:
:
init
(
JSContext
*
maybecx
)
{
JS
:
:
ResetTimeZone
(
)
;
if
(
!
crossCompartmentWrappers
.
init
(
0
)
)
{
if
(
maybecx
)
ReportOutOfMemory
(
maybecx
)
;
return
false
;
}
if
(
!
regExps
.
init
(
maybecx
)
)
return
false
;
enumerators
=
NativeIterator
:
:
allocateSentinel
(
maybecx
)
;
if
(
!
enumerators
)
return
false
;
if
(
!
savedStacks_
.
init
(
)
)
{
if
(
maybecx
)
ReportOutOfMemory
(
maybecx
)
;
return
false
;
}
return
true
;
}
jit
:
:
JitRuntime
*
JSRuntime
:
:
createJitRuntime
(
JSContext
*
cx
)
{
AutoLockForExclusiveAccess
atomsLock
(
cx
)
;
MOZ_ASSERT
(
!
jitRuntime_
)
;
jit
:
:
JitRuntime
*
jrt
=
cx
-
>
new_
<
jit
:
:
JitRuntime
>
(
cx
-
>
runtime
(
)
)
;
if
(
!
jrt
)
return
nullptr
;
JitRuntime
:
:
AutoPreventBackedgePatching
apbp
(
cx
-
>
runtime
(
)
jrt
)
;
jitRuntime_
=
jrt
;
AutoEnterOOMUnsafeRegion
noOOM
;
if
(
!
jitRuntime_
-
>
initialize
(
cx
)
)
{
noOOM
.
crash
(
"
OOM
in
createJitRuntime
"
)
;
}
return
jitRuntime_
;
}
bool
JSCompartment
:
:
ensureJitCompartmentExists
(
JSContext
*
cx
)
{
using
namespace
js
:
:
jit
;
if
(
jitCompartment_
)
return
true
;
if
(
!
zone
(
)
-
>
getJitZone
(
cx
)
)
return
false
;
jitCompartment_
=
cx
-
>
new_
<
JitCompartment
>
(
)
;
if
(
!
jitCompartment_
)
return
false
;
if
(
!
jitCompartment_
-
>
initialize
(
cx
)
)
{
js_delete
(
jitCompartment_
)
;
jitCompartment_
=
nullptr
;
return
false
;
}
return
true
;
}
class
WrapperMapRef
:
public
BufferableRef
{
WrapperMap
*
map
;
CrossCompartmentKey
key
;
public
:
WrapperMapRef
(
WrapperMap
*
map
const
CrossCompartmentKey
&
key
)
:
map
(
map
)
key
(
key
)
{
}
void
trace
(
JSTracer
*
trc
)
override
{
CrossCompartmentKey
prior
=
key
;
if
(
key
.
debugger
)
TraceManuallyBarrieredEdge
(
trc
&
key
.
debugger
"
CCW
debugger
"
)
;
if
(
key
.
kind
=
=
CrossCompartmentKey
:
:
ObjectWrapper
|
|
key
.
kind
=
=
CrossCompartmentKey
:
:
DebuggerObject
|
|
key
.
kind
=
=
CrossCompartmentKey
:
:
DebuggerEnvironment
|
|
key
.
kind
=
=
CrossCompartmentKey
:
:
DebuggerSource
)
{
MOZ_ASSERT
(
IsInsideNursery
(
key
.
wrapped
)
|
|
key
.
wrapped
-
>
asTenured
(
)
.
getTraceKind
(
)
=
=
JS
:
:
TraceKind
:
:
Object
)
;
TraceManuallyBarrieredEdge
(
trc
reinterpret_cast
<
JSObject
*
*
>
(
&
key
.
wrapped
)
"
CCW
wrapped
object
"
)
;
}
if
(
key
.
debugger
=
=
prior
.
debugger
&
&
key
.
wrapped
=
=
prior
.
wrapped
)
return
;
WrapperMap
:
:
Ptr
p
=
map
-
>
lookup
(
prior
)
;
if
(
!
p
)
return
;
map
-
>
rekeyAs
(
prior
key
key
)
;
}
}
;
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
JSCompartment
:
:
checkWrapperMapAfterMovingGC
(
)
{
for
(
WrapperMap
:
:
Enum
e
(
crossCompartmentWrappers
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
CrossCompartmentKey
key
=
e
.
front
(
)
.
key
(
)
;
CheckGCThingAfterMovingGC
(
key
.
debugger
)
;
CheckGCThingAfterMovingGC
(
key
.
wrapped
)
;
CheckGCThingAfterMovingGC
(
static_cast
<
Cell
*
>
(
e
.
front
(
)
.
value
(
)
.
unbarrieredGet
(
)
.
toGCThing
(
)
)
)
;
WrapperMap
:
:
Ptr
ptr
=
crossCompartmentWrappers
.
lookup
(
key
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
e
.
front
(
)
)
;
}
}
#
endif
bool
JSCompartment
:
:
putWrapper
(
JSContext
*
cx
const
CrossCompartmentKey
&
wrapped
const
js
:
:
Value
&
wrapper
)
{
MOZ_ASSERT
(
wrapped
.
wrapped
)
;
MOZ_ASSERT_IF
(
wrapped
.
kind
=
=
CrossCompartmentKey
:
:
StringWrapper
wrapper
.
isString
(
)
)
;
MOZ_ASSERT_IF
(
wrapped
.
kind
!
=
CrossCompartmentKey
:
:
StringWrapper
wrapper
.
isObject
(
)
)
;
MOZ_ASSERT
(
!
IsInsideNursery
(
static_cast
<
gc
:
:
Cell
*
>
(
wrapper
.
toGCThing
(
)
)
)
)
;
if
(
!
crossCompartmentWrappers
.
put
(
wrapped
ReadBarriered
<
Value
>
(
wrapper
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
if
(
IsInsideNursery
(
wrapped
.
wrapped
)
|
|
IsInsideNursery
(
wrapped
.
debugger
)
)
{
WrapperMapRef
ref
(
&
crossCompartmentWrappers
wrapped
)
;
cx
-
>
runtime
(
)
-
>
gc
.
storeBuffer
.
putGeneric
(
ref
)
;
}
return
true
;
}
static
JSString
*
CopyStringPure
(
JSContext
*
cx
JSString
*
str
)
{
size_t
len
=
str
-
>
length
(
)
;
JSString
*
copy
;
if
(
str
-
>
isLinear
(
)
)
{
if
(
str
-
>
hasLatin1Chars
(
)
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
copy
=
NewStringCopyN
<
NoGC
>
(
cx
str
-
>
asLinear
(
)
.
latin1Chars
(
nogc
)
len
)
;
}
else
{
JS
:
:
AutoCheckCannotGC
nogc
;
copy
=
NewStringCopyNDontDeflate
<
NoGC
>
(
cx
str
-
>
asLinear
(
)
.
twoByteChars
(
nogc
)
len
)
;
}
if
(
copy
)
return
copy
;
AutoStableStringChars
chars
(
cx
)
;
if
(
!
chars
.
init
(
cx
str
)
)
return
nullptr
;
return
chars
.
isLatin1
(
)
?
NewStringCopyN
<
CanGC
>
(
cx
chars
.
latin1Range
(
)
.
start
(
)
.
get
(
)
len
)
:
NewStringCopyNDontDeflate
<
CanGC
>
(
cx
chars
.
twoByteRange
(
)
.
start
(
)
.
get
(
)
len
)
;
}
if
(
str
-
>
hasLatin1Chars
(
)
)
{
ScopedJSFreePtr
<
Latin1Char
>
copiedChars
;
if
(
!
str
-
>
asRope
(
)
.
copyLatin1CharsZ
(
cx
copiedChars
)
)
return
nullptr
;
return
NewString
<
CanGC
>
(
cx
copiedChars
.
forget
(
)
len
)
;
}
ScopedJSFreePtr
<
char16_t
>
copiedChars
;
if
(
!
str
-
>
asRope
(
)
.
copyTwoByteCharsZ
(
cx
copiedChars
)
)
return
nullptr
;
return
NewStringDontDeflate
<
CanGC
>
(
cx
copiedChars
.
forget
(
)
len
)
;
}
bool
JSCompartment
:
:
wrap
(
JSContext
*
cx
MutableHandleString
strp
)
{
MOZ_ASSERT
(
!
cx
-
>
runtime
(
)
-
>
isAtomsCompartment
(
this
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
JSString
*
str
=
strp
;
if
(
str
-
>
zoneFromAnyThread
(
)
=
=
zone
(
)
)
return
true
;
if
(
str
-
>
isAtom
(
)
)
{
MOZ_ASSERT
(
str
-
>
isPermanentAtom
(
)
|
|
str
-
>
zone
(
)
-
>
isAtomsZone
(
)
)
;
return
true
;
}
RootedValue
key
(
cx
StringValue
(
str
)
)
;
if
(
WrapperMap
:
:
Ptr
p
=
crossCompartmentWrappers
.
lookup
(
CrossCompartmentKey
(
key
)
)
)
{
strp
.
set
(
p
-
>
value
(
)
.
get
(
)
.
toString
(
)
)
;
return
true
;
}
JSString
*
copy
=
CopyStringPure
(
cx
str
)
;
if
(
!
copy
)
return
false
;
if
(
!
putWrapper
(
cx
CrossCompartmentKey
(
key
)
StringValue
(
copy
)
)
)
return
false
;
strp
.
set
(
copy
)
;
return
true
;
}
bool
JSCompartment
:
:
wrap
(
JSContext
*
cx
MutableHandleObject
obj
HandleObject
existingArg
)
{
MOZ_ASSERT
(
!
cx
-
>
runtime
(
)
-
>
isAtomsCompartment
(
this
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
MOZ_ASSERT_IF
(
existingArg
existingArg
-
>
compartment
(
)
=
=
cx
-
>
compartment
(
)
)
;
MOZ_ASSERT_IF
(
existingArg
IsDeadProxyObject
(
existingArg
)
)
;
if
(
!
obj
)
return
true
;
AutoDisableProxyCheck
adpc
(
cx
-
>
runtime
(
)
)
;
HandleObject
global
=
cx
-
>
global
(
)
;
RootedObject
objGlobal
(
cx
&
obj
-
>
global
(
)
)
;
MOZ_ASSERT
(
global
)
;
MOZ_ASSERT
(
objGlobal
)
;
const
JSWrapObjectCallbacks
*
cb
=
cx
-
>
runtime
(
)
-
>
wrapObjectCallbacks
;
if
(
obj
-
>
compartment
(
)
=
=
this
)
{
obj
.
set
(
ToWindowProxyIfWindow
(
obj
)
)
;
return
true
;
}
MOZ_ASSERT
(
!
cx
-
>
runtime
(
)
-
>
isSelfHostingGlobal
(
global
)
&
&
!
cx
-
>
runtime
(
)
-
>
isSelfHostingGlobal
(
objGlobal
)
)
;
RootedObject
objectPassedToWrap
(
cx
obj
)
;
obj
.
set
(
UncheckedUnwrap
(
obj
true
)
)
;
if
(
obj
-
>
compartment
(
)
=
=
this
)
{
MOZ_ASSERT
(
!
IsWindow
(
obj
)
)
;
return
true
;
}
if
(
obj
-
>
is
<
StopIterationObject
>
(
)
)
{
RootedObject
stopIteration
(
cx
)
;
if
(
!
GetBuiltinConstructor
(
cx
JSProto_StopIteration
&
stopIteration
)
)
return
false
;
obj
.
set
(
stopIteration
)
;
return
true
;
}
JS_CHECK_SYSTEM_RECURSION
(
cx
return
false
)
;
if
(
cb
-
>
preWrap
)
{
obj
.
set
(
cb
-
>
preWrap
(
cx
global
obj
objectPassedToWrap
)
)
;
if
(
!
obj
)
return
false
;
}
MOZ_ASSERT
(
!
IsWindow
(
obj
)
)
;
if
(
obj
-
>
compartment
(
)
=
=
this
)
return
true
;
RootedValue
key
(
cx
ObjectValue
(
*
obj
)
)
;
if
(
WrapperMap
:
:
Ptr
p
=
crossCompartmentWrappers
.
lookup
(
CrossCompartmentKey
(
key
)
)
)
{
obj
.
set
(
&
p
-
>
value
(
)
.
get
(
)
.
toObject
(
)
)
;
MOZ_ASSERT
(
obj
-
>
is
<
CrossCompartmentWrapperObject
>
(
)
)
;
return
true
;
}
RootedObject
existing
(
cx
existingArg
)
;
if
(
existing
)
{
if
(
!
existing
-
>
getTaggedProto
(
)
.
isLazy
(
)
|
|
existing
-
>
isCallable
(
)
|
|
obj
-
>
isCallable
(
)
)
{
existing
=
nullptr
;
}
}
RootedObject
wrapper
(
cx
cb
-
>
wrap
(
cx
existing
obj
)
)
;
if
(
!
wrapper
)
return
false
;
MOZ_ASSERT
(
Wrapper
:
:
wrappedObject
(
wrapper
)
=
=
&
key
.
get
(
)
.
toObject
(
)
)
;
if
(
!
putWrapper
(
cx
CrossCompartmentKey
(
key
)
ObjectValue
(
*
wrapper
)
)
)
{
if
(
wrapper
-
>
is
<
CrossCompartmentWrapperObject
>
(
)
)
NukeCrossCompartmentWrapper
(
cx
wrapper
)
;
return
false
;
}
obj
.
set
(
wrapper
)
;
return
true
;
}
bool
JSCompartment
:
:
wrap
(
JSContext
*
cx
MutableHandle
<
PropertyDescriptor
>
desc
)
{
if
(
!
wrap
(
cx
desc
.
object
(
)
)
)
return
false
;
if
(
desc
.
hasGetterObject
(
)
)
{
if
(
!
wrap
(
cx
desc
.
getterObject
(
)
)
)
return
false
;
}
if
(
desc
.
hasSetterObject
(
)
)
{
if
(
!
wrap
(
cx
desc
.
setterObject
(
)
)
)
return
false
;
}
return
wrap
(
cx
desc
.
value
(
)
)
;
}
ClonedBlockObject
*
JSCompartment
:
:
getOrCreateNonSyntacticLexicalScope
(
JSContext
*
cx
HandleObject
enclosingStatic
HandleObject
enclosingScope
)
{
if
(
!
nonSyntacticLexicalScopes_
)
{
nonSyntacticLexicalScopes_
=
cx
-
>
new_
<
ObjectWeakMap
>
(
cx
)
;
if
(
!
nonSyntacticLexicalScopes_
|
|
!
nonSyntacticLexicalScopes_
-
>
init
(
)
)
return
nullptr
;
}
MOZ_ASSERT
(
!
enclosingScope
-
>
as
<
DynamicWithObject
>
(
)
.
isSyntactic
(
)
)
;
RootedObject
key
(
cx
&
enclosingScope
-
>
as
<
DynamicWithObject
>
(
)
.
object
(
)
)
;
RootedObject
lexicalScope
(
cx
nonSyntacticLexicalScopes_
-
>
lookup
(
key
)
)
;
if
(
!
lexicalScope
)
{
lexicalScope
=
ClonedBlockObject
:
:
createNonSyntactic
(
cx
enclosingStatic
enclosingScope
)
;
if
(
!
lexicalScope
)
return
nullptr
;
if
(
!
nonSyntacticLexicalScopes_
-
>
add
(
cx
key
lexicalScope
)
)
return
nullptr
;
}
return
&
lexicalScope
-
>
as
<
ClonedBlockObject
>
(
)
;
}
ClonedBlockObject
*
JSCompartment
:
:
getNonSyntacticLexicalScope
(
JSObject
*
enclosingScope
)
const
{
if
(
!
nonSyntacticLexicalScopes_
)
return
nullptr
;
if
(
!
enclosingScope
-
>
is
<
DynamicWithObject
>
(
)
)
return
nullptr
;
JSObject
*
key
=
&
enclosingScope
-
>
as
<
DynamicWithObject
>
(
)
.
object
(
)
;
JSObject
*
lexicalScope
=
nonSyntacticLexicalScopes_
-
>
lookup
(
key
)
;
if
(
!
lexicalScope
)
return
nullptr
;
return
&
lexicalScope
-
>
as
<
ClonedBlockObject
>
(
)
;
}
void
JSCompartment
:
:
traceOutgoingCrossCompartmentWrappers
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
trc
-
>
runtime
(
)
-
>
isHeapMajorCollecting
(
)
)
;
MOZ_ASSERT
(
!
zone
(
)
-
>
isCollecting
(
)
|
|
trc
-
>
runtime
(
)
-
>
gc
.
isHeapCompacting
(
)
)
;
for
(
WrapperMap
:
:
Enum
e
(
crossCompartmentWrappers
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Value
v
=
e
.
front
(
)
.
value
(
)
.
unbarrieredGet
(
)
;
if
(
e
.
front
(
)
.
key
(
)
.
kind
=
=
CrossCompartmentKey
:
:
ObjectWrapper
)
{
ProxyObject
*
wrapper
=
&
v
.
toObject
(
)
.
as
<
ProxyObject
>
(
)
;
TraceEdge
(
trc
wrapper
-
>
slotOfPrivate
(
)
"
cross
-
compartment
wrapper
"
)
;
}
}
}
void
JSCompartment
:
:
traceIncomingCrossCompartmentEdgesForZoneGC
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
trc
-
>
runtime
(
)
-
>
isHeapMajorCollecting
(
)
)
;
for
(
CompartmentsIter
c
(
trc
-
>
runtime
(
)
SkipAtoms
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
if
(
!
c
-
>
zone
(
)
-
>
isCollecting
(
)
)
c
-
>
traceOutgoingCrossCompartmentWrappers
(
trc
)
;
}
Debugger
:
:
markIncomingCrossCompartmentEdges
(
trc
)
;
}
void
JSCompartment
:
:
trace
(
JSTracer
*
trc
)
{
savedStacks_
.
trace
(
trc
)
;
}
void
JSCompartment
:
:
traceRoots
(
JSTracer
*
trc
js
:
:
gc
:
:
GCRuntime
:
:
TraceOrMarkRuntime
traceOrMark
)
{
if
(
objectMetadataState
.
is
<
PendingMetadata
>
(
)
)
{
TraceRoot
(
trc
objectMetadataState
.
as
<
PendingMetadata
>
(
)
.
unsafeUnbarrieredForTracing
(
)
"
on
-
stack
object
pending
metadata
"
)
;
}
if
(
!
trc
-
>
runtime
(
)
-
>
isHeapMinorCollecting
(
)
)
{
if
(
jitCompartment_
)
jitCompartment_
-
>
mark
(
trc
this
)
;
if
(
enterCompartmentDepth
&
&
global_
.
unbarrieredGet
(
)
)
TraceRoot
(
trc
global_
.
unsafeUnbarrieredForTracing
(
)
"
on
-
stack
compartment
global
"
)
;
}
if
(
traceOrMark
=
=
js
:
:
gc
:
:
GCRuntime
:
:
MarkRuntime
&
&
!
zone
(
)
-
>
isCollecting
(
)
)
return
;
if
(
traceOrMark
=
=
js
:
:
gc
:
:
GCRuntime
:
:
TraceRuntime
)
{
if
(
watchpointMap
)
watchpointMap
-
>
markAll
(
trc
)
;
}
if
(
debugScopes
)
debugScopes
-
>
mark
(
trc
)
;
if
(
lazyArrayBuffers
)
lazyArrayBuffers
-
>
trace
(
trc
)
;
if
(
objectMetadataTable
)
objectMetadataTable
-
>
trace
(
trc
)
;
if
(
scriptCountsMap
&
&
trc
-
>
runtime
(
)
-
>
profilingScripts
&
&
!
trc
-
>
runtime
(
)
-
>
isHeapMinorCollecting
(
)
)
{
MOZ_ASSERT_IF
(
!
trc
-
>
runtime
(
)
-
>
isBeingDestroyed
(
)
collectCoverage
(
)
)
;
for
(
ScriptCountsMap
:
:
Range
r
=
scriptCountsMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSScript
*
script
=
const_cast
<
JSScript
*
>
(
r
.
front
(
)
.
key
(
)
)
;
MOZ_ASSERT
(
script
-
>
hasScriptCounts
(
)
)
;
TraceRoot
(
trc
&
script
"
profilingScripts
"
)
;
MOZ_ASSERT
(
script
=
=
r
.
front
(
)
.
key
(
)
"
const_cast
is
only
a
work
-
around
"
)
;
}
}
if
(
nonSyntacticLexicalScopes_
)
nonSyntacticLexicalScopes_
-
>
trace
(
trc
)
;
}
void
JSCompartment
:
:
sweepAfterMinorGC
(
)
{
globalWriteBarriered
=
false
;
if
(
innerViews
.
needsSweepAfterMinorGC
(
)
)
innerViews
.
sweepAfterMinorGC
(
)
;
}
void
JSCompartment
:
:
sweepInnerViews
(
)
{
innerViews
.
sweep
(
)
;
}
void
JSCompartment
:
:
sweepSavedStacks
(
)
{
savedStacks_
.
sweep
(
runtimeFromAnyThread
(
)
)
;
}
void
JSCompartment
:
:
sweepGlobalObject
(
FreeOp
*
fop
)
{
if
(
global_
&
&
IsAboutToBeFinalized
(
&
global_
)
)
{
if
(
isDebuggee
(
)
)
Debugger
:
:
detachAllDebuggersFromGlobal
(
fop
global_
.
unbarrieredGet
(
)
)
;
global_
.
set
(
nullptr
)
;
}
}
void
JSCompartment
:
:
sweepObjectPendingMetadata
(
)
{
if
(
objectMetadataState
.
is
<
PendingMetadata
>
(
)
)
{
MOZ_ALWAYS_TRUE
(
!
IsAboutToBeFinalized
(
&
objectMetadataState
.
as
<
PendingMetadata
>
(
)
)
)
;
}
}
void
JSCompartment
:
:
sweepSelfHostingScriptSource
(
)
{
if
(
selfHostingScriptSource
.
unbarrieredGet
(
)
&
&
IsAboutToBeFinalized
(
&
selfHostingScriptSource
)
)
{
selfHostingScriptSource
.
set
(
nullptr
)
;
}
}
void
JSCompartment
:
:
sweepJitCompartment
(
FreeOp
*
fop
)
{
if
(
jitCompartment_
)
jitCompartment_
-
>
sweep
(
fop
this
)
;
}
void
JSCompartment
:
:
sweepRegExps
(
)
{
regExps
.
sweep
(
runtimeFromAnyThread
(
)
)
;
}
void
JSCompartment
:
:
sweepDebugScopes
(
)
{
JSRuntime
*
rt
=
runtimeFromAnyThread
(
)
;
if
(
debugScopes
)
debugScopes
-
>
sweep
(
rt
)
;
}
void
JSCompartment
:
:
sweepNativeIterators
(
)
{
NativeIterator
*
ni
=
enumerators
-
>
next
(
)
;
while
(
ni
!
=
enumerators
)
{
JSObject
*
iterObj
=
ni
-
>
iterObj
(
)
;
NativeIterator
*
next
=
ni
-
>
next
(
)
;
if
(
gc
:
:
IsAboutToBeFinalizedUnbarriered
(
&
iterObj
)
)
ni
-
>
unlink
(
)
;
ni
=
next
;
}
}
void
JSCompartment
:
:
sweepCrossCompartmentWrappers
(
)
{
crossCompartmentWrappers
.
sweep
(
)
;
}
bool
CrossCompartmentKey
:
:
needsSweep
(
)
{
bool
keyDying
;
switch
(
kind
)
{
case
CrossCompartmentKey
:
:
ObjectWrapper
:
case
CrossCompartmentKey
:
:
DebuggerObject
:
case
CrossCompartmentKey
:
:
DebuggerEnvironment
:
case
CrossCompartmentKey
:
:
DebuggerSource
:
MOZ_ASSERT
(
IsInsideNursery
(
wrapped
)
|
|
wrapped
-
>
asTenured
(
)
.
getTraceKind
(
)
=
=
JS
:
:
TraceKind
:
:
Object
)
;
keyDying
=
IsAboutToBeFinalizedUnbarriered
(
reinterpret_cast
<
JSObject
*
*
>
(
&
wrapped
)
)
;
break
;
case
CrossCompartmentKey
:
:
StringWrapper
:
MOZ_ASSERT
(
wrapped
-
>
asTenured
(
)
.
getTraceKind
(
)
=
=
JS
:
:
TraceKind
:
:
String
)
;
keyDying
=
IsAboutToBeFinalizedUnbarriered
(
reinterpret_cast
<
JSString
*
*
>
(
&
wrapped
)
)
;
break
;
case
CrossCompartmentKey
:
:
DebuggerScript
:
MOZ_ASSERT
(
wrapped
-
>
asTenured
(
)
.
getTraceKind
(
)
=
=
JS
:
:
TraceKind
:
:
Script
)
;
keyDying
=
IsAboutToBeFinalizedUnbarriered
(
reinterpret_cast
<
JSScript
*
*
>
(
&
wrapped
)
)
;
break
;
default
:
MOZ_CRASH
(
"
Unknown
key
kind
"
)
;
}
bool
dbgDying
=
debugger
&
&
IsAboutToBeFinalizedUnbarriered
(
&
debugger
)
;
MOZ_ASSERT_IF
(
keyDying
|
|
dbgDying
kind
!
=
CrossCompartmentKey
:
:
StringWrapper
)
;
return
keyDying
|
|
dbgDying
;
}
void
JSCompartment
:
:
sweepTemplateObjects
(
)
{
if
(
mappedArgumentsTemplate_
&
&
IsAboutToBeFinalized
(
&
mappedArgumentsTemplate_
)
)
mappedArgumentsTemplate_
.
set
(
nullptr
)
;
if
(
unmappedArgumentsTemplate_
&
&
IsAboutToBeFinalized
(
&
unmappedArgumentsTemplate_
)
)
unmappedArgumentsTemplate_
.
set
(
nullptr
)
;
}
void
JSCompartment
:
:
fixupCrossCompartmentWrappersAfterMovingGC
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
trc
-
>
runtime
(
)
-
>
gc
.
isHeapCompacting
(
)
)
;
for
(
CompartmentsIter
comp
(
trc
-
>
runtime
(
)
SkipAtoms
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
comp
-
>
sweepCrossCompartmentWrappers
(
)
;
comp
-
>
traceOutgoingCrossCompartmentWrappers
(
trc
)
;
}
}
void
JSCompartment
:
:
fixupAfterMovingGC
(
)
{
fixupGlobal
(
)
;
fixupInitialShapeTable
(
)
;
objectGroups
.
fixupTablesAfterMovingGC
(
)
;
#
ifdef
DEBUG
if
(
scriptCountsMap
)
{
for
(
ScriptCountsMap
:
:
Range
r
=
scriptCountsMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
MOZ_ASSERT
(
!
IsForwarded
(
r
.
front
(
)
.
key
(
)
)
)
;
}
#
endif
}
void
JSCompartment
:
:
fixupGlobal
(
)
{
GlobalObject
*
global
=
*
global_
.
unsafeGet
(
)
;
if
(
global
)
global_
.
set
(
MaybeForwarded
(
global
)
)
;
}
void
JSCompartment
:
:
purge
(
)
{
dtoaCache
.
purge
(
)
;
}
void
JSCompartment
:
:
clearTables
(
)
{
global_
.
set
(
nullptr
)
;
MOZ_ASSERT
(
crossCompartmentWrappers
.
empty
(
)
)
;
MOZ_ASSERT
(
!
jitCompartment_
)
;
MOZ_ASSERT
(
!
debugScopes
)
;
MOZ_ASSERT
(
enumerators
-
>
next
(
)
=
=
enumerators
)
;
MOZ_ASSERT
(
regExps
.
empty
(
)
)
;
objectGroups
.
clearTables
(
)
;
if
(
baseShapes
.
initialized
(
)
)
baseShapes
.
clear
(
)
;
if
(
initialShapes
.
initialized
(
)
)
initialShapes
.
clear
(
)
;
if
(
savedStacks_
.
initialized
(
)
)
savedStacks_
.
clear
(
)
;
}
void
JSCompartment
:
:
setObjectMetadataCallback
(
js
:
:
ObjectMetadataCallback
callback
)
{
ReleaseAllJITCode
(
runtime_
-
>
defaultFreeOp
(
)
)
;
objectMetadataCallback
=
callback
;
}
void
JSCompartment
:
:
clearObjectMetadata
(
)
{
js_delete
(
objectMetadataTable
)
;
objectMetadataTable
=
nullptr
;
}
void
JSCompartment
:
:
setNewObjectMetadata
(
JSContext
*
cx
JSObject
*
obj
)
{
assertSameCompartment
(
cx
this
obj
)
;
if
(
JSObject
*
metadata
=
objectMetadataCallback
(
cx
obj
)
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
assertSameCompartment
(
cx
metadata
)
;
if
(
!
objectMetadataTable
)
{
objectMetadataTable
=
cx
-
>
new_
<
ObjectWeakMap
>
(
cx
)
;
if
(
!
objectMetadataTable
|
|
!
objectMetadataTable
-
>
init
(
)
)
oomUnsafe
.
crash
(
"
setNewObjectMetadata
"
)
;
}
if
(
!
objectMetadataTable
-
>
add
(
cx
obj
metadata
)
)
oomUnsafe
.
crash
(
"
setNewObjectMetadata
"
)
;
}
}
static
bool
AddInnerLazyFunctionsFromScript
(
JSScript
*
script
AutoObjectVector
&
lazyFunctions
)
{
if
(
!
script
-
>
hasObjects
(
)
)
return
true
;
ObjectArray
*
objects
=
script
-
>
objects
(
)
;
for
(
size_t
i
=
script
-
>
innerObjectsStart
(
)
;
i
<
objects
-
>
length
;
i
+
+
)
{
JSObject
*
obj
=
objects
-
>
vector
[
i
]
;
if
(
obj
-
>
is
<
JSFunction
>
(
)
&
&
obj
-
>
as
<
JSFunction
>
(
)
.
isInterpretedLazy
(
)
)
{
if
(
!
lazyFunctions
.
append
(
obj
)
)
return
false
;
}
}
return
true
;
}
static
bool
AddLazyFunctionsForCompartment
(
JSContext
*
cx
AutoObjectVector
&
lazyFunctions
AllocKind
kind
)
{
for
(
gc
:
:
ZoneCellIter
i
(
cx
-
>
zone
(
)
kind
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
JSFunction
*
fun
=
&
i
.
get
<
JSObject
>
(
)
-
>
as
<
JSFunction
>
(
)
;
if
(
gc
:
:
IsAboutToBeFinalizedUnbarriered
(
&
fun
)
|
|
fun
-
>
compartment
(
)
!
=
cx
-
>
compartment
(
)
)
{
continue
;
}
if
(
fun
-
>
isInterpretedLazy
(
)
)
{
LazyScript
*
lazy
=
fun
-
>
lazyScriptOrNull
(
)
;
if
(
lazy
&
&
lazy
-
>
sourceObject
(
)
&
&
!
lazy
-
>
hasUncompiledEnclosingScript
(
)
)
{
if
(
!
lazyFunctions
.
append
(
fun
)
)
return
false
;
}
}
}
return
true
;
}
static
bool
CreateLazyScriptsForCompartment
(
JSContext
*
cx
)
{
AutoObjectVector
lazyFunctions
(
cx
)
;
if
(
!
AddLazyFunctionsForCompartment
(
cx
lazyFunctions
AllocKind
:
:
FUNCTION
)
)
return
false
;
if
(
!
AddLazyFunctionsForCompartment
(
cx
lazyFunctions
AllocKind
:
:
FUNCTION_EXTENDED
)
)
return
false
;
for
(
size_t
i
=
0
;
i
<
lazyFunctions
.
length
(
)
;
i
+
+
)
{
JSFunction
*
fun
=
&
lazyFunctions
[
i
]
-
>
as
<
JSFunction
>
(
)
;
if
(
!
fun
-
>
isInterpretedLazy
(
)
)
continue
;
LazyScript
*
lazy
=
fun
-
>
lazyScript
(
)
;
bool
lazyScriptHadNoScript
=
!
lazy
-
>
maybeScript
(
)
;
JSScript
*
script
=
fun
-
>
getOrCreateScript
(
cx
)
;
if
(
!
script
)
return
false
;
if
(
lazyScriptHadNoScript
&
&
!
AddInnerLazyFunctionsFromScript
(
script
lazyFunctions
)
)
return
false
;
}
return
true
;
}
bool
JSCompartment
:
:
ensureDelazifyScriptsForDebugger
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
this
)
;
if
(
needsDelazificationForDebugger
(
)
&
&
!
CreateLazyScriptsForCompartment
(
cx
)
)
return
false
;
debugModeBits
&
=
~
DebuggerNeedsDelazification
;
return
true
;
}
void
JSCompartment
:
:
updateDebuggerObservesFlag
(
unsigned
flag
)
{
MOZ_ASSERT
(
isDebuggee
(
)
)
;
MOZ_ASSERT
(
flag
=
=
DebuggerObservesAllExecution
|
|
flag
=
=
DebuggerObservesCoverage
|
|
flag
=
=
DebuggerObservesAsmJS
)
;
GlobalObject
*
global
=
zone
(
)
-
>
runtimeFromMainThread
(
)
-
>
gc
.
isForegroundSweeping
(
)
?
unsafeUnbarrieredMaybeGlobal
(
)
:
maybeGlobal
(
)
;
const
GlobalObject
:
:
DebuggerVector
*
v
=
global
-
>
getDebuggers
(
)
;
for
(
Debugger
*
const
*
p
=
v
-
>
begin
(
)
;
p
!
=
v
-
>
end
(
)
;
p
+
+
)
{
Debugger
*
dbg
=
*
p
;
if
(
flag
=
=
DebuggerObservesAllExecution
?
dbg
-
>
observesAllExecution
(
)
:
flag
=
=
DebuggerObservesCoverage
?
dbg
-
>
observesCoverage
(
)
:
dbg
-
>
observesAsmJS
(
)
)
{
debugModeBits
|
=
flag
;
return
;
}
}
debugModeBits
&
=
~
flag
;
}
void
JSCompartment
:
:
unsetIsDebuggee
(
)
{
if
(
isDebuggee
(
)
)
{
debugModeBits
&
=
~
DebuggerObservesMask
;
DebugScopes
:
:
onCompartmentUnsetIsDebuggee
(
this
)
;
}
}
void
JSCompartment
:
:
updateDebuggerObservesCoverage
(
)
{
bool
previousState
=
debuggerObservesCoverage
(
)
;
updateDebuggerObservesFlag
(
DebuggerObservesCoverage
)
;
if
(
previousState
=
=
debuggerObservesCoverage
(
)
)
return
;
if
(
debuggerObservesCoverage
(
)
)
{
for
(
ActivationIterator
iter
(
runtimeFromMainThread
(
)
)
;
!
iter
.
done
(
)
;
+
+
iter
)
{
if
(
iter
-
>
isInterpreter
(
)
)
iter
-
>
asInterpreter
(
)
-
>
enableInterruptsUnconditionally
(
)
;
}
return
;
}
if
(
collectCoverage
(
)
)
return
;
clearScriptCounts
(
)
;
}
bool
JSCompartment
:
:
collectCoverage
(
)
const
{
return
!
JitOptions
.
disablePgo
|
|
debuggerObservesCoverage
(
)
|
|
runtimeFromAnyThread
(
)
-
>
profilingScripts
|
|
runtimeFromAnyThread
(
)
-
>
lcovOutput
.
isEnabled
(
)
;
}
void
JSCompartment
:
:
clearScriptCounts
(
)
{
if
(
!
scriptCountsMap
)
return
;
for
(
ScriptCountsMap
:
:
Range
r
=
scriptCountsMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
ScriptCounts
*
value
=
&
r
.
front
(
)
.
value
(
)
;
r
.
front
(
)
.
key
(
)
-
>
takeOverScriptCountsMapEntry
(
value
)
;
}
js_delete
(
scriptCountsMap
)
;
scriptCountsMap
=
nullptr
;
}
void
JSCompartment
:
:
clearBreakpointsIn
(
FreeOp
*
fop
js
:
:
Debugger
*
dbg
HandleObject
handler
)
{
for
(
gc
:
:
ZoneCellIter
i
(
zone
(
)
gc
:
:
AllocKind
:
:
SCRIPT
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
JSScript
*
script
=
i
.
get
<
JSScript
>
(
)
;
if
(
script
-
>
compartment
(
)
=
=
this
&
&
script
-
>
hasAnyBreakpointsOrStepMode
(
)
)
script
-
>
clearBreakpointsIn
(
fop
dbg
handler
)
;
}
}
void
JSCompartment
:
:
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
tiAllocationSiteTables
size_t
*
tiArrayTypeTables
size_t
*
tiObjectTypeTables
size_t
*
compartmentObject
size_t
*
compartmentTables
size_t
*
innerViewsArg
size_t
*
lazyArrayBuffersArg
size_t
*
objectMetadataTablesArg
size_t
*
crossCompartmentWrappersArg
size_t
*
regexpCompartment
size_t
*
savedStacksSet
size_t
*
nonSyntacticLexicalScopesArg
)
{
*
compartmentObject
+
=
mallocSizeOf
(
this
)
;
objectGroups
.
addSizeOfExcludingThis
(
mallocSizeOf
tiAllocationSiteTables
tiArrayTypeTables
tiObjectTypeTables
compartmentTables
)
;
*
compartmentTables
+
=
baseShapes
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
initialShapes
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
*
innerViewsArg
+
=
innerViews
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
if
(
lazyArrayBuffers
)
*
lazyArrayBuffersArg
+
=
lazyArrayBuffers
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
if
(
objectMetadataTable
)
*
objectMetadataTablesArg
+
=
objectMetadataTable
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
*
crossCompartmentWrappersArg
+
=
crossCompartmentWrappers
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
*
regexpCompartment
+
=
regExps
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
*
savedStacksSet
+
=
savedStacks_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
if
(
nonSyntacticLexicalScopes_
)
*
nonSyntacticLexicalScopesArg
+
=
nonSyntacticLexicalScopes_
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
void
JSCompartment
:
:
reportTelemetry
(
)
{
if
(
isSystem_
)
return
;
JS
:
:
AutoSuppressGCAnalysis
nogc
;
int
id
=
creationOptions_
.
addonIdOrNull
(
)
?
JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_ADDONS
:
JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_CONTENT
;
for
(
size_t
i
=
0
;
i
<
DeprecatedLanguageExtensionCount
;
i
+
+
)
{
if
(
sawDeprecatedLanguageExtension
[
i
]
)
runtime_
-
>
addTelemetry
(
id
i
)
;
}
}
void
JSCompartment
:
:
addTelemetry
(
const
char
*
filename
DeprecatedLanguageExtension
e
)
{
if
(
isSystem_
)
return
;
if
(
!
creationOptions_
.
addonIdOrNull
(
)
&
&
(
!
filename
|
|
strncmp
(
filename
"
http
"
4
)
!
=
0
)
)
return
;
sawDeprecatedLanguageExtension
[
e
]
=
true
;
}
AutoSetNewObjectMetadata
:
:
AutoSetNewObjectMetadata
(
ExclusiveContext
*
ecx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL
)
:
CustomAutoRooter
(
ecx
)
cx_
(
ecx
-
>
maybeJSContext
(
)
)
prevState_
(
ecx
-
>
compartment
(
)
-
>
objectMetadataState
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
cx_
)
cx_
-
>
compartment
(
)
-
>
objectMetadataState
=
NewObjectMetadataState
(
DelayMetadata
(
)
)
;
}
AutoSetNewObjectMetadata
:
:
~
AutoSetNewObjectMetadata
(
)
{
if
(
!
cx_
)
return
;
if
(
!
cx_
-
>
isExceptionPending
(
)
&
&
cx_
-
>
compartment
(
)
-
>
hasObjectPendingMetadata
(
)
)
{
JSObject
*
obj
=
cx_
-
>
compartment
(
)
-
>
objectMetadataState
.
as
<
PendingMetadata
>
(
)
;
cx_
-
>
compartment
(
)
-
>
objectMetadataState
=
prevState_
;
SetNewObjectMetadata
(
cx_
obj
)
;
}
else
{
cx_
-
>
compartment
(
)
-
>
objectMetadataState
=
prevState_
;
}
}
