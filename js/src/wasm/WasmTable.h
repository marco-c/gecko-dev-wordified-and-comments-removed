#
ifndef
wasm_table_h
#
define
wasm_table_h
#
include
"
gc
/
Policy
.
h
"
#
include
"
wasm
/
WasmCode
.
h
"
namespace
js
{
namespace
wasm
{
using
TableAnyRefVector
=
GCVector
<
HeapPtr
<
AnyRef
>
0
SystemAllocPolicy
>
;
class
Table
:
public
ShareableBase
<
Table
>
{
using
InstanceSet
=
JS
:
:
WeakCache
<
GCHashSet
<
WeakHeapPtr
<
WasmInstanceObject
*
>
StableCellHasher
<
WeakHeapPtr
<
WasmInstanceObject
*
>
>
SystemAllocPolicy
>
>
;
using
FuncRefVector
=
Vector
<
FunctionTableElem
0
SystemAllocPolicy
>
;
WeakHeapPtr
<
WasmTableObject
*
>
maybeObject_
;
InstanceSet
observers_
;
FuncRefVector
functions_
;
TableAnyRefVector
objects_
;
const
IndexType
indexType_
;
const
RefType
elemType_
;
const
bool
isAsmJS_
;
uint32_t
length_
;
const
mozilla
:
:
Maybe
<
uint64_t
>
maximum_
;
template
<
class
>
friend
struct
js
:
:
MallocProvider
;
Table
(
JSContext
*
cx
const
TableDesc
&
desc
Handle
<
WasmTableObject
*
>
maybeObject
FuncRefVector
&
&
functions
)
;
Table
(
JSContext
*
cx
const
TableDesc
&
desc
Handle
<
WasmTableObject
*
>
maybeObject
TableAnyRefVector
&
&
objects
)
;
void
tracePrivate
(
JSTracer
*
trc
)
;
friend
class
js
:
:
WasmTableObject
;
public
:
static
RefPtr
<
Table
>
create
(
JSContext
*
cx
const
TableDesc
&
desc
Handle
<
WasmTableObject
*
>
maybeObject
)
;
~
Table
(
)
;
void
trace
(
JSTracer
*
trc
)
;
IndexType
indexType
(
)
const
{
return
indexType_
;
}
RefType
elemType
(
)
const
{
return
elemType_
;
}
TableRepr
repr
(
)
const
{
return
elemType_
.
tableRepr
(
)
;
}
bool
isAsmJS
(
)
const
{
MOZ_ASSERT
(
elemType_
.
isFuncHierarchy
(
)
)
;
return
isAsmJS_
;
}
bool
isFunction
(
)
const
{
return
elemType
(
)
.
isFuncHierarchy
(
)
;
}
uint32_t
length
(
)
const
{
return
length_
;
}
mozilla
:
:
Maybe
<
uint64_t
>
maximum
(
)
const
{
return
maximum_
;
}
uint8_t
*
instanceElements
(
)
const
;
const
FunctionTableElem
&
getFuncRef
(
uint32_t
index
)
const
;
[
[
nodiscard
]
]
bool
getFuncRef
(
JSContext
*
cx
uint32_t
index
MutableHandleFunction
fun
)
const
;
void
setFuncRef
(
uint32_t
index
JSFunction
*
func
)
;
void
setFuncRef
(
uint32_t
index
void
*
code
Instance
*
instance
)
;
void
fillFuncRef
(
uint32_t
index
uint32_t
fillCount
FuncRef
ref
JSContext
*
cx
)
;
AnyRef
getAnyRef
(
uint32_t
index
)
const
;
void
setAnyRef
(
uint32_t
index
AnyRef
ref
)
;
void
fillAnyRef
(
uint32_t
index
uint32_t
fillCount
AnyRef
ref
)
;
void
setRef
(
uint32_t
index
AnyRef
ref
)
;
[
[
nodiscard
]
]
bool
getValue
(
JSContext
*
cx
uint32_t
index
MutableHandleValue
result
)
const
;
void
setNull
(
uint32_t
index
)
;
[
[
nodiscard
]
]
bool
copy
(
JSContext
*
cx
const
Table
&
srcTable
uint32_t
dstIndex
uint32_t
srcIndex
)
;
[
[
nodiscard
]
]
uint32_t
grow
(
uint32_t
delta
)
;
[
[
nodiscard
]
]
bool
movingGrowable
(
)
const
;
[
[
nodiscard
]
]
bool
addMovingGrowObserver
(
JSContext
*
cx
WasmInstanceObject
*
instance
)
;
void
fillUninitialized
(
uint32_t
index
uint32_t
fillCount
HandleAnyRef
ref
JSContext
*
cx
)
;
#
ifdef
DEBUG
void
assertRangeNull
(
uint32_t
index
uint32_t
length
)
const
;
void
assertRangeNotNull
(
uint32_t
index
uint32_t
length
)
const
;
#
endif
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
gcMallocBytes
(
)
const
;
}
;
using
SharedTable
=
RefPtr
<
Table
>
;
using
SharedTableVector
=
Vector
<
SharedTable
0
SystemAllocPolicy
>
;
}
}
#
endif
