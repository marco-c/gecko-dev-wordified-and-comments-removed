#
ifndef
wasm_pages_h
#
define
wasm_pages_h
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
<
stdint
.
h
>
namespace
js
{
namespace
wasm
{
enum
class
IndexType
:
uint8_t
{
I32
I64
}
;
extern
bool
ToIndexType
(
JSContext
*
cx
HandleValue
value
IndexType
*
indexType
)
;
extern
const
char
*
ToString
(
IndexType
indexType
)
;
struct
Pages
{
private
:
uint64_t
value_
;
public
:
constexpr
Pages
(
)
:
value_
(
0
)
{
}
constexpr
explicit
Pages
(
uint64_t
value
)
:
value_
(
value
)
{
}
uint64_t
value
(
)
const
{
return
value_
;
}
static
Pages
fromByteLengthExact
(
size_t
byteLength
)
{
MOZ_ASSERT
(
byteLength
%
PageSize
=
=
0
)
;
return
Pages
(
byteLength
/
PageSize
)
;
}
bool
hasByteLength
(
)
const
{
mozilla
:
:
CheckedInt
<
size_t
>
length
(
value_
)
;
length
*
=
PageSize
;
return
length
.
isValid
(
)
;
}
size_t
byteLength
(
)
const
{
mozilla
:
:
CheckedInt
<
size_t
>
length
(
value_
)
;
length
*
=
PageSize
;
return
length
.
value
(
)
;
}
bool
checkedIncrement
(
Pages
delta
)
{
mozilla
:
:
CheckedInt
<
uint64_t
>
newValue
=
value_
;
newValue
+
=
delta
.
value_
;
if
(
!
newValue
.
isValid
(
)
)
{
return
false
;
}
value_
=
newValue
.
value
(
)
;
return
true
;
}
bool
operator
=
=
(
Pages
other
)
const
{
return
value_
=
=
other
.
value_
;
}
bool
operator
!
=
(
Pages
other
)
const
{
return
value_
!
=
other
.
value_
;
}
bool
operator
<
=
(
Pages
other
)
const
{
return
value_
<
=
other
.
value_
;
}
bool
operator
<
(
Pages
other
)
const
{
return
value_
<
other
.
value_
;
}
bool
operator
>
=
(
Pages
other
)
const
{
return
value_
>
=
other
.
value_
;
}
bool
operator
>
(
Pages
other
)
const
{
return
value_
>
other
.
value_
;
}
}
;
}
}
#
endif
