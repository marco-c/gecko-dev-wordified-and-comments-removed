#
ifndef
wasm_gc_h
#
define
wasm_gc_h
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
jit
/
ABIArgGenerator
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
util
/
Memory
.
h
"
#
include
"
wasm
/
WasmBuiltins
.
h
"
#
include
"
wasm
/
WasmFrame
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
namespace
js
{
namespace
jit
{
class
Label
;
class
MacroAssembler
;
}
namespace
wasm
{
class
ArgTypeVector
;
class
BytecodeOffset
;
using
jit
:
:
Label
;
using
jit
:
:
MIRType
;
using
jit
:
:
Register
;
using
ExitStubMapVector
=
Vector
<
bool
32
SystemAllocPolicy
>
;
struct
StackMapHeader
{
explicit
StackMapHeader
(
uint32_t
numMappedWords
=
0
)
:
numMappedWords
(
numMappedWords
)
numExitStubWords
(
0
)
frameOffsetFromTop
(
0
)
hasDebugFrameWithLiveRefs
(
0
)
{
}
static
constexpr
size_t
MappedWordsBits
=
30
;
uint32_t
numMappedWords
:
MappedWordsBits
;
static
constexpr
size_t
ExitStubWordsBits
=
6
;
uint32_t
numExitStubWords
:
ExitStubWordsBits
;
static
constexpr
size_t
FrameOffsetBits
=
12
;
uint32_t
frameOffsetFromTop
:
FrameOffsetBits
;
uint32_t
hasDebugFrameWithLiveRefs
:
1
;
WASM_CHECK_CACHEABLE_POD
(
numMappedWords
numExitStubWords
frameOffsetFromTop
hasDebugFrameWithLiveRefs
)
;
static
constexpr
uint32_t
maxMappedWords
=
(
1
<
<
MappedWordsBits
)
-
1
;
static
constexpr
uint32_t
maxExitStubWords
=
(
1
<
<
ExitStubWordsBits
)
-
1
;
static
constexpr
uint32_t
maxFrameOffsetFromTop
=
(
1
<
<
FrameOffsetBits
)
-
1
;
static
constexpr
size_t
MaxParamSize
=
std
:
:
max
(
sizeof
(
jit
:
:
FloatRegisters
:
:
RegisterContent
)
sizeof
(
jit
:
:
Registers
:
:
RegisterContent
)
)
;
static_assert
(
FrameWithInstances
:
:
sizeOf
(
)
/
sizeof
(
void
*
)
<
=
8
)
;
static_assert
(
maxFrameOffsetFromTop
>
=
(
MaxParams
*
MaxParamSize
/
sizeof
(
void
*
)
)
+
16
"
limited
size
of
the
offset
field
"
)
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
StackMapHeader
)
;
static_assert
(
sizeof
(
StackMapHeader
)
=
=
8
"
wasm
:
:
StackMapHeader
has
unexpected
size
"
)
;
struct
StackMap
final
{
StackMapHeader
header
;
private
:
uint32_t
bitmap
[
1
]
;
explicit
StackMap
(
uint32_t
numMappedWords
)
:
header
(
numMappedWords
)
{
const
uint32_t
nBitmap
=
calcNBitmap
(
header
.
numMappedWords
)
;
memset
(
bitmap
0
nBitmap
*
sizeof
(
bitmap
[
0
]
)
)
;
}
explicit
StackMap
(
const
StackMapHeader
&
header
)
:
header
(
header
)
{
const
uint32_t
nBitmap
=
calcNBitmap
(
header
.
numMappedWords
)
;
memset
(
bitmap
0
nBitmap
*
sizeof
(
bitmap
[
0
]
)
)
;
}
public
:
static
StackMap
*
create
(
uint32_t
numMappedWords
)
{
size_t
size
=
allocationSizeInBytes
(
numMappedWords
)
;
char
*
buf
=
(
char
*
)
js_malloc
(
size
)
;
if
(
!
buf
)
{
return
nullptr
;
}
return
:
:
new
(
buf
)
StackMap
(
numMappedWords
)
;
}
static
StackMap
*
create
(
const
StackMapHeader
&
header
)
{
size_t
size
=
allocationSizeInBytes
(
header
.
numMappedWords
)
;
char
*
buf
=
(
char
*
)
js_malloc
(
size
)
;
if
(
!
buf
)
{
return
nullptr
;
}
return
:
:
new
(
buf
)
StackMap
(
header
)
;
}
void
destroy
(
)
{
js_free
(
(
char
*
)
this
)
;
}
static
size_t
allocationSizeInBytes
(
uint32_t
numMappedWords
)
{
uint32_t
nBitmap
=
calcNBitmap
(
numMappedWords
)
;
return
sizeof
(
StackMap
)
+
(
nBitmap
-
1
)
*
sizeof
(
bitmap
[
0
]
)
;
}
size_t
allocationSizeInBytes
(
)
const
{
return
allocationSizeInBytes
(
header
.
numMappedWords
)
;
}
void
setExitStubWords
(
uint32_t
nWords
)
{
MOZ_ASSERT
(
header
.
numExitStubWords
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
nWords
<
=
header
.
maxExitStubWords
)
;
MOZ_ASSERT
(
nWords
<
=
header
.
numMappedWords
)
;
header
.
numExitStubWords
=
nWords
;
}
void
setFrameOffsetFromTop
(
uint32_t
nWords
)
{
MOZ_ASSERT
(
header
.
frameOffsetFromTop
=
=
0
)
;
MOZ_RELEASE_ASSERT
(
nWords
<
=
StackMapHeader
:
:
maxFrameOffsetFromTop
)
;
MOZ_ASSERT
(
header
.
frameOffsetFromTop
<
header
.
numMappedWords
)
;
header
.
frameOffsetFromTop
=
nWords
;
}
void
setHasDebugFrameWithLiveRefs
(
)
{
MOZ_ASSERT
(
header
.
hasDebugFrameWithLiveRefs
=
=
0
)
;
header
.
hasDebugFrameWithLiveRefs
=
1
;
}
inline
void
setBit
(
uint32_t
bitIndex
)
{
MOZ_ASSERT
(
bitIndex
<
header
.
numMappedWords
)
;
uint32_t
wordIndex
=
bitIndex
/
wordsPerBitmapElem
;
uint32_t
wordOffset
=
bitIndex
%
wordsPerBitmapElem
;
bitmap
[
wordIndex
]
|
=
(
1
<
<
wordOffset
)
;
}
inline
uint32_t
getBit
(
uint32_t
bitIndex
)
const
{
MOZ_ASSERT
(
bitIndex
<
header
.
numMappedWords
)
;
uint32_t
wordIndex
=
bitIndex
/
wordsPerBitmapElem
;
uint32_t
wordOffset
=
bitIndex
%
wordsPerBitmapElem
;
return
(
bitmap
[
wordIndex
]
>
>
wordOffset
)
&
1
;
}
inline
uint8_t
*
rawBitmap
(
)
{
return
(
uint8_t
*
)
&
bitmap
;
}
inline
const
uint8_t
*
rawBitmap
(
)
const
{
return
(
const
uint8_t
*
)
&
bitmap
;
}
inline
size_t
rawBitmapLengthInBytes
(
)
const
{
return
calcNBitmap
(
header
.
numMappedWords
)
*
sizeof
(
uint32_t
)
;
}
private
:
static
constexpr
uint32_t
wordsPerBitmapElem
=
sizeof
(
bitmap
[
0
]
)
*
8
;
static
uint32_t
calcNBitmap
(
uint32_t
numMappedWords
)
{
MOZ_RELEASE_ASSERT
(
numMappedWords
<
=
StackMapHeader
:
:
maxMappedWords
)
;
uint32_t
nBitmap
=
(
numMappedWords
+
wordsPerBitmapElem
-
1
)
/
wordsPerBitmapElem
;
return
nBitmap
=
=
0
?
1
:
nBitmap
;
}
}
;
static_assert
(
sizeof
(
StackMap
)
=
=
12
"
wasm
:
:
StackMap
has
unexpected
size
"
)
;
class
StackMaps
{
public
:
struct
Maplet
{
const
uint8_t
*
nextInsnAddr
;
StackMap
*
map
;
Maplet
(
const
uint8_t
*
nextInsnAddr
StackMap
*
map
)
:
nextInsnAddr
(
nextInsnAddr
)
map
(
map
)
{
}
void
offsetBy
(
uintptr_t
delta
)
{
nextInsnAddr
+
=
delta
;
}
bool
operator
<
(
const
Maplet
&
other
)
const
{
return
uintptr_t
(
nextInsnAddr
)
<
uintptr_t
(
other
.
nextInsnAddr
)
;
}
}
;
private
:
bool
sorted_
;
Vector
<
Maplet
0
SystemAllocPolicy
>
mapping_
;
public
:
StackMaps
(
)
:
sorted_
(
false
)
{
}
~
StackMaps
(
)
{
for
(
auto
&
maplet
:
mapping_
)
{
maplet
.
map
-
>
destroy
(
)
;
maplet
.
map
=
nullptr
;
}
}
[
[
nodiscard
]
]
bool
add
(
const
uint8_t
*
nextInsnAddr
StackMap
*
map
)
{
MOZ_ASSERT
(
!
sorted_
)
;
return
mapping_
.
append
(
Maplet
(
nextInsnAddr
map
)
)
;
}
[
[
nodiscard
]
]
bool
add
(
const
Maplet
&
maplet
)
{
return
add
(
maplet
.
nextInsnAddr
maplet
.
map
)
;
}
void
clear
(
)
{
for
(
auto
&
maplet
:
mapping_
)
{
maplet
.
nextInsnAddr
=
nullptr
;
maplet
.
map
=
nullptr
;
}
mapping_
.
clear
(
)
;
}
bool
empty
(
)
const
{
return
mapping_
.
empty
(
)
;
}
size_t
length
(
)
const
{
return
mapping_
.
length
(
)
;
}
Maplet
*
getRef
(
size_t
i
)
{
return
&
mapping_
[
i
]
;
}
Maplet
get
(
size_t
i
)
const
{
return
mapping_
[
i
]
;
}
Maplet
move
(
size_t
i
)
{
Maplet
m
=
mapping_
[
i
]
;
mapping_
[
i
]
.
map
=
nullptr
;
return
m
;
}
void
offsetBy
(
uintptr_t
delta
)
{
for
(
auto
&
maplet
:
mapping_
)
maplet
.
offsetBy
(
delta
)
;
}
void
finishAndSort
(
)
{
MOZ_ASSERT
(
!
sorted_
)
;
std
:
:
sort
(
mapping_
.
begin
(
)
mapping_
.
end
(
)
)
;
sorted_
=
true
;
}
void
finishAlreadySorted
(
)
{
MOZ_ASSERT
(
!
sorted_
)
;
MOZ_ASSERT
(
std
:
:
is_sorted
(
mapping_
.
begin
(
)
mapping_
.
end
(
)
)
)
;
sorted_
=
true
;
}
const
StackMap
*
findMap
(
const
uint8_t
*
nextInsnAddr
)
const
{
struct
Comparator
{
int
operator
(
)
(
Maplet
aVal
)
const
{
if
(
uintptr_t
(
mTarget
)
<
uintptr_t
(
aVal
.
nextInsnAddr
)
)
{
return
-
1
;
}
if
(
uintptr_t
(
mTarget
)
>
uintptr_t
(
aVal
.
nextInsnAddr
)
)
{
return
1
;
}
return
0
;
}
explicit
Comparator
(
const
uint8_t
*
aTarget
)
:
mTarget
(
aTarget
)
{
}
const
uint8_t
*
mTarget
;
}
;
size_t
result
;
if
(
mozilla
:
:
BinarySearchIf
(
mapping_
0
mapping_
.
length
(
)
Comparator
(
nextInsnAddr
)
&
result
)
)
{
return
mapping_
[
result
]
.
map
;
}
return
nullptr
;
}
}
;
template
<
class
T
>
static
inline
size_t
StackArgAreaSizeUnaligned
(
const
T
&
argTypes
)
{
jit
:
:
WasmABIArgIter
<
const
T
>
i
(
argTypes
)
;
while
(
!
i
.
done
(
)
)
{
i
+
+
;
}
return
i
.
stackBytesConsumedSoFar
(
)
;
}
static
inline
size_t
StackArgAreaSizeUnaligned
(
const
SymbolicAddressSignature
&
saSig
)
{
class
MOZ_STACK_CLASS
ItemsAndLength
{
const
MIRType
*
items_
;
size_t
length_
;
public
:
ItemsAndLength
(
const
MIRType
*
items
size_t
length
)
:
items_
(
items
)
length_
(
length
)
{
}
size_t
length
(
)
const
{
return
length_
;
}
MIRType
operator
[
]
(
size_t
i
)
const
{
return
items_
[
i
]
;
}
}
;
MOZ_ASSERT
(
saSig
.
numArgs
<
sizeof
(
saSig
.
argTypes
)
/
sizeof
(
saSig
.
argTypes
[
0
]
)
)
;
MOZ_ASSERT
(
saSig
.
argTypes
[
saSig
.
numArgs
]
=
=
MIRType
:
:
None
)
;
ItemsAndLength
itemsAndLength
(
saSig
.
argTypes
saSig
.
numArgs
)
;
return
StackArgAreaSizeUnaligned
(
itemsAndLength
)
;
}
static
inline
size_t
AlignStackArgAreaSize
(
size_t
unalignedSize
)
{
return
AlignBytes
(
unalignedSize
jit
:
:
WasmStackAlignment
)
;
}
using
StackMapBoolVector
=
Vector
<
bool
128
SystemAllocPolicy
>
;
wasm
:
:
StackMap
*
ConvertStackMapBoolVectorToStackMap
(
const
StackMapBoolVector
&
vec
bool
hasRefs
)
;
[
[
nodiscard
]
]
bool
CreateStackMapForFunctionEntryTrap
(
const
ArgTypeVector
&
argTypes
const
jit
:
:
RegisterOffsets
&
trapExitLayout
size_t
trapExitLayoutWords
size_t
nBytesReservedBeforeTrap
size_t
nInboundStackArgBytes
wasm
:
:
StackMap
*
*
result
)
;
[
[
nodiscard
]
]
bool
GenerateStackmapEntriesForTrapExit
(
const
ArgTypeVector
&
args
const
jit
:
:
RegisterOffsets
&
trapExitLayout
const
size_t
trapExitLayoutNumWords
ExitStubMapVector
*
extras
)
;
void
EmitWasmPreBarrierGuard
(
jit
:
:
MacroAssembler
&
masm
Register
instance
Register
scratch
Register
valueAddr
size_t
valueOffset
Label
*
skipBarrier
BytecodeOffset
*
trapOffset
)
;
void
EmitWasmPreBarrierCall
(
jit
:
:
MacroAssembler
&
masm
Register
instance
Register
scratch
Register
valueAddr
size_t
valueOffset
)
;
void
EmitWasmPostBarrierGuard
(
jit
:
:
MacroAssembler
&
masm
const
mozilla
:
:
Maybe
<
Register
>
&
object
Register
otherScratch
Register
setValue
Label
*
skipBarrier
)
;
#
ifdef
DEBUG
bool
IsValidStackMapKey
(
bool
debugEnabled
const
uint8_t
*
nextPC
)
;
#
endif
}
}
#
endif
