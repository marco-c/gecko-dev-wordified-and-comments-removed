#
ifndef
wasm_gc_h
#
define
wasm_gc_h
#
include
"
jit
/
MacroAssembler
.
h
"
namespace
js
{
namespace
wasm
{
using
namespace
js
:
:
jit
;
template
<
class
T
>
static
inline
size_t
StackArgAreaSizeUnaligned
(
const
T
&
argTypes
)
{
ABIArgIter
<
const
T
>
i
(
argTypes
)
;
while
(
!
i
.
done
(
)
)
{
i
+
+
;
}
return
i
.
stackBytesConsumedSoFar
(
)
;
}
static
inline
size_t
StackArgAreaSizeUnaligned
(
const
SymbolicAddressSignature
&
saSig
)
{
class
MOZ_STACK_CLASS
ItemsAndLength
{
const
MIRType
*
items_
;
size_t
length_
;
public
:
ItemsAndLength
(
const
MIRType
*
items
size_t
length
)
:
items_
(
items
)
length_
(
length
)
{
}
size_t
length
(
)
const
{
return
length_
;
}
MIRType
operator
[
]
(
size_t
i
)
const
{
return
items_
[
i
]
;
}
}
;
MOZ_ASSERT
(
saSig
.
numArgs
<
sizeof
(
saSig
.
argTypes
)
/
sizeof
(
saSig
.
argTypes
[
0
]
)
)
;
MOZ_ASSERT
(
saSig
.
argTypes
[
saSig
.
numArgs
]
=
=
MIRType
:
:
None
)
;
ItemsAndLength
itemsAndLength
(
saSig
.
argTypes
saSig
.
numArgs
)
;
ABIArgIter
<
ItemsAndLength
>
i
(
itemsAndLength
)
;
while
(
!
i
.
done
(
)
)
{
i
+
+
;
}
return
i
.
stackBytesConsumedSoFar
(
)
;
}
static
inline
size_t
AlignStackArgAreaSize
(
size_t
unalignedSize
)
{
return
AlignBytes
(
unalignedSize
16u
)
;
}
template
<
class
T
>
static
inline
size_t
StackArgAreaSizeAligned
(
const
T
&
argTypes
)
{
return
AlignStackArgAreaSize
(
StackArgAreaSizeUnaligned
(
argTypes
)
)
;
}
void
EmitWasmPreBarrierGuard
(
MacroAssembler
&
masm
Register
tls
Register
scratch
Register
valueAddr
Label
*
skipBarrier
)
;
void
EmitWasmPreBarrierCall
(
MacroAssembler
&
masm
Register
tls
Register
scratch
Register
valueAddr
)
;
void
EmitWasmPostBarrierGuard
(
MacroAssembler
&
masm
const
Maybe
<
Register
>
&
object
Register
otherScratch
Register
setValue
Label
*
skipBarrier
)
;
}
}
#
endif
