#
ifndef
wasm_serialize_h
#
define
wasm_serialize_h
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
MacroForEach
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
type_traits
>
namespace
js
{
namespace
wasm
{
struct
OutOfMemory
{
}
;
using
CoderResult
=
mozilla
:
:
Result
<
mozilla
:
:
Ok
OutOfMemory
>
;
enum
CoderMode
{
MODE_SIZE
MODE_ENCODE
MODE_DECODE
}
;
template
<
CoderMode
mode
typename
V
>
struct
CoderArgT
;
template
<
typename
V
>
struct
CoderArgT
<
MODE_SIZE
V
>
{
using
T
=
const
V
*
;
}
;
template
<
typename
V
>
struct
CoderArgT
<
MODE_DECODE
V
>
{
using
T
=
V
*
;
}
;
template
<
typename
V
>
struct
CoderArgT
<
MODE_ENCODE
V
>
{
using
T
=
const
V
*
;
}
;
template
<
CoderMode
mode
typename
T
>
using
CoderArg
=
typename
CoderArgT
<
mode
T
>
:
:
T
;
template
<
CoderMode
mode
>
struct
Coder
;
template
<
>
struct
Coder
<
MODE_SIZE
>
{
Coder
(
)
:
size_
(
0
)
{
}
mozilla
:
:
CheckedInt
<
size_t
>
size_
;
CoderResult
writeBytes
(
const
void
*
unusedSrc
size_t
length
)
;
}
;
template
<
>
struct
Coder
<
MODE_ENCODE
>
{
Coder
(
uint8_t
*
start
size_t
length
)
:
buffer_
(
start
)
end_
(
start
+
length
)
{
}
uint8_t
*
buffer_
;
const
uint8_t
*
end_
;
CoderResult
writeBytes
(
const
void
*
src
size_t
length
)
;
}
;
template
<
>
struct
Coder
<
MODE_DECODE
>
{
Coder
(
const
uint8_t
*
start
size_t
length
)
:
buffer_
(
start
)
end_
(
start
+
length
)
{
}
const
uint8_t
*
buffer_
;
const
uint8_t
*
end_
;
CoderResult
readBytes
(
void
*
dest
size_t
length
)
;
}
;
#
define
WASM_DECLARE_FRIEND_SERIALIZE
(
TYPE
)
\
template
<
CoderMode
mode
>
\
friend
CoderResult
Code
#
#
TYPE
(
Coder
<
mode
>
&
CoderArg
<
mode
TYPE
>
)
;
#
define
WASM_DECLARE_FRIEND_SERIALIZE_ARGS
(
TYPE
ARGS
.
.
.
)
\
template
<
CoderMode
mode
>
\
friend
CoderResult
Code
#
#
TYPE
(
Coder
<
mode
>
&
CoderArg
<
mode
TYPE
>
ARGS
)
;
template
<
typename
T
>
struct
IsCacheablePod
:
public
std
:
:
conditional_t
<
std
:
:
is_arithmetic_v
<
T
>
|
|
std
:
:
is_enum_v
<
T
>
std
:
:
true_type
std
:
:
false_type
>
{
}
;
template
<
typename
T
>
struct
IsCacheablePod
<
mozilla
:
:
Maybe
<
T
>
>
:
public
std
:
:
conditional_t
<
IsCacheablePod
<
T
>
:
:
value
std
:
:
true_type
std
:
:
false_type
>
{
}
;
template
<
typename
T
size_t
N
>
struct
IsCacheablePod
<
T
[
N
]
>
:
public
std
:
:
conditional_t
<
IsCacheablePod
<
T
>
:
:
value
std
:
:
true_type
std
:
:
false_type
>
{
}
;
template
<
class
T
>
inline
constexpr
bool
is_cacheable_pod
=
IsCacheablePod
<
T
>
:
:
value
;
#
define
WASM_DECLARE_CACHEABLE_POD
(
Type
)
\
static_assert
(
!
std
:
:
is_polymorphic_v
<
Type
>
\
#
Type
"
must
not
have
virtual
methods
"
)
;
\
}
/
*
namespace
wasm
*
/
\
}
/
*
namespace
js
*
/
\
template
<
>
\
struct
js
:
:
wasm
:
:
IsCacheablePod
<
js
:
:
wasm
:
:
Type
>
:
public
std
:
:
true_type
{
}
;
\
namespace
js
{
\
namespace
wasm
{
#
define
WASM_CHECK_CACHEABLE_POD_FIELD_
(
Field
)
\
static_assert
(
js
:
:
wasm
:
:
IsCacheablePod
<
decltype
(
Field
)
>
:
:
value
\
#
Field
"
must
be
cacheable
pod
"
)
;
#
define
WASM_CHECK_CACHEABLE_POD
(
Fields
.
.
.
)
\
MOZ_FOR_EACH
(
WASM_CHECK_CACHEABLE_POD_FIELD_
(
)
(
Fields
)
)
#
define
WASM_CHECK_CACHEABLE_POD_WITH_PARENT
(
Parent
Fields
.
.
.
)
\
static_assert
(
js
:
:
wasm
:
:
IsCacheablePod
<
Parent
>
:
:
value
\
#
Parent
"
must
be
cacheable
pod
"
)
;
\
MOZ_FOR_EACH
(
WASM_CHECK_CACHEABLE_POD_FIELD_
(
)
(
Fields
)
)
#
define
WASM_ALLOW_NON_CACHEABLE_POD_FIELD
(
Field
Reason
)
\
static_assert
(
!
js
:
:
wasm
:
:
IsCacheablePod
<
decltype
(
Field
)
>
:
:
value
\
#
Field
"
is
not
cacheable
due
to
"
Reason
)
;
}
}
#
endif
