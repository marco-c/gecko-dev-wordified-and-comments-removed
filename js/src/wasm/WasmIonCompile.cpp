#
include
"
wasm
/
WasmIonCompile
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
<
algorithm
>
#
include
"
jit
/
ABIArgGenerator
.
h
"
#
include
"
jit
/
CodeGenerator
.
h
"
#
include
"
jit
/
CompileInfo
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
jit
/
IonOptimizationLevels
.
h
"
#
include
"
jit
/
MIR
-
wasm
.
h
"
#
include
"
jit
/
MIR
.
h
"
#
include
"
jit
/
ShuffleAnalysis
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
ScalarType
.
h
"
#
include
"
util
/
DifferentialTesting
.
h
"
#
include
"
wasm
/
WasmBaselineCompile
.
h
"
#
include
"
wasm
/
WasmBuiltinModule
.
h
"
#
include
"
wasm
/
WasmBuiltins
.
h
"
#
include
"
wasm
/
WasmCodegenTypes
.
h
"
#
include
"
wasm
/
WasmGC
.
h
"
#
include
"
wasm
/
WasmGcObject
.
h
"
#
include
"
wasm
/
WasmGenerator
.
h
"
#
include
"
wasm
/
WasmOpIter
.
h
"
#
include
"
wasm
/
WasmSignalHandlers
.
h
"
#
include
"
wasm
/
WasmStubs
.
h
"
#
include
"
wasm
/
WasmValidate
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
using
mozilla
:
:
IsPowerOfTwo
;
using
mozilla
:
:
Nothing
;
namespace
{
using
UniqueCompileInfo
=
UniquePtr
<
CompileInfo
>
;
using
UniqueCompileInfoVector
=
Vector
<
UniqueCompileInfo
1
SystemAllocPolicy
>
;
using
BlockVector
=
Vector
<
MBasicBlock
*
8
SystemAllocPolicy
>
;
using
DefVector
=
Vector
<
MDefinition
*
8
SystemAllocPolicy
>
;
using
ControlInstructionVector
=
Vector
<
MControlInstruction
*
8
SystemAllocPolicy
>
;
struct
TryControl
{
ControlInstructionVector
landingPadPatches
;
TryTableCatchVector
catches
;
MDefinition
*
pendingException
;
MDefinition
*
pendingExceptionTag
;
bool
inBody
;
TryControl
(
)
:
pendingException
(
nullptr
)
pendingExceptionTag
(
nullptr
)
inBody
(
false
)
{
}
void
reset
(
)
{
landingPadPatches
.
clearAndFree
(
)
;
catches
.
clearAndFree
(
)
;
inBody
=
false
;
}
}
;
using
UniqueTryControl
=
UniquePtr
<
TryControl
>
;
using
VectorUniqueTryControl
=
Vector
<
UniqueTryControl
2
SystemAllocPolicy
>
;
struct
ControlFlowPatch
{
MControlInstruction
*
ins
;
uint32_t
index
;
ControlFlowPatch
(
MControlInstruction
*
ins
uint32_t
index
)
:
ins
(
ins
)
index
(
index
)
{
}
}
;
using
ControlFlowPatchVector
=
Vector
<
ControlFlowPatch
0
SystemAllocPolicy
>
;
struct
PendingBlockTarget
{
ControlFlowPatchVector
patches
;
BranchHint
hint
=
BranchHint
:
:
Invalid
;
}
;
using
PendingBlockTargetVector
=
Vector
<
PendingBlockTarget
0
SystemAllocPolicy
>
;
struct
PendingInlineReturn
{
PendingInlineReturn
(
MGoto
*
jump
DefVector
&
&
results
)
:
jump
(
jump
)
results
(
std
:
:
move
(
results
)
)
{
}
MGoto
*
jump
;
DefVector
results
;
}
;
using
PendingInlineReturnVector
=
Vector
<
PendingInlineReturn
1
SystemAllocPolicy
>
;
struct
CallCompileState
{
ABIArgGenerator
abi
;
bool
hardFP
=
true
;
ABIKind
abiKind
;
MWasmCallBase
:
:
Args
regArgs
;
ABIArg
instanceArg
;
MWasmStackResultArea
*
stackResultArea
=
nullptr
;
bool
returnCall
=
false
;
ControlInstructionVector
*
tryLandingPadPatches
=
nullptr
;
uint32_t
tryNoteIndex
=
UINT32_MAX
;
MBasicBlock
*
fallthroughBlock
=
nullptr
;
MBasicBlock
*
prePadBlock
=
nullptr
;
explicit
CallCompileState
(
ABIKind
abiKind
)
:
abi
(
abiKind
)
abiKind
(
abiKind
)
{
if
(
abiKind
=
=
ABIKind
:
:
System
)
{
#
if
defined
(
JS_CODEGEN_ARM
)
hardFP
=
ARMFlags
:
:
UseHardFpABI
(
)
;
abi
.
setUseHardFp
(
hardFP
)
;
#
endif
}
else
{
#
if
defined
(
JS_CODEGEN_ARM
)
MOZ_ASSERT
(
hardFP
"
The
WASM
ABI
passes
FP
arguments
in
registers
"
)
;
#
endif
}
}
bool
isCatchable
(
)
const
{
return
tryLandingPadPatches
!
=
nullptr
;
}
}
;
struct
Control
{
MBasicBlock
*
block
;
UniqueTryControl
tryControl
;
Control
(
)
:
block
(
nullptr
)
tryControl
(
nullptr
)
{
}
Control
(
Control
&
&
)
=
default
;
Control
(
const
Control
&
)
=
delete
;
}
;
struct
IonCompilePolicy
{
using
Value
=
MDefinition
*
;
using
ValueVector
=
DefVector
;
using
ControlItem
=
Control
;
}
;
using
IonOpIter
=
OpIter
<
IonCompilePolicy
>
;
struct
InliningStats
{
size_t
inlinedDirectBytecodeSize
=
0
;
size_t
inlinedDirectFunctions
=
0
;
size_t
inlinedCallRefBytecodeSize
=
0
;
size_t
inlinedCallRefFunctions
=
0
;
bool
largeFunctionBackoff
=
false
;
}
;
class
RootCompiler
{
const
CompilerEnvironment
&
compilerEnv_
;
const
CodeMetadata
&
codeMeta_
;
const
CodeTailMetadata
*
codeTailMeta_
;
const
ValTypeVector
&
locals_
;
const
FuncCompileInput
&
func_
;
Decoder
&
decoder_
;
FeatureUsage
observedFeatures_
;
CompileInfo
compileInfo_
;
const
JitCompileOptions
options_
;
TempAllocator
&
alloc_
;
MIRGraph
mirGraph_
;
MIRGenerator
mirGen_
;
uint32_t
loopDepth_
;
BytecodeOffsetVector
inlinedCallerOffsets_
;
InlinedCallerOffsetIndex
inlinedCallerOffsetsIndex_
;
CompileStats
funcStats_
;
InliningStats
inliningStats_
;
int64_t
localInliningBudget_
;
UniqueCompileInfoVector
compileInfos_
;
VectorUniqueTryControl
tryControlCache_
;
wasm
:
:
TryNoteVector
&
tryNotes_
;
wasm
:
:
InliningContext
&
inliningContext_
;
public
:
RootCompiler
(
const
CompilerEnvironment
&
compilerEnv
const
CodeMetadata
&
codeMeta
const
CodeTailMetadata
*
codeTailMeta
TempAllocator
&
alloc
const
ValTypeVector
&
locals
const
FuncCompileInput
&
func
Decoder
&
decoder
wasm
:
:
TryNoteVector
&
tryNotes
wasm
:
:
InliningContext
&
inliningContext
)
:
compilerEnv_
(
compilerEnv
)
codeMeta_
(
codeMeta
)
codeTailMeta_
(
codeTailMeta
)
locals_
(
locals
)
func_
(
func
)
decoder_
(
decoder
)
observedFeatures_
(
FeatureUsage
:
:
None
)
compileInfo_
(
locals
.
length
(
)
)
alloc_
(
alloc
)
mirGraph_
(
&
alloc
)
mirGen_
(
nullptr
options_
&
alloc_
&
mirGraph_
&
compileInfo_
IonOptimizations
.
get
(
OptimizationLevel
:
:
Wasm
)
&
codeMeta
)
loopDepth_
(
0
)
localInliningBudget_
(
0
)
tryNotes_
(
tryNotes
)
inliningContext_
(
inliningContext
)
{
}
const
CompilerEnvironment
&
compilerEnv
(
)
const
{
return
compilerEnv_
;
}
const
CodeMetadata
&
codeMeta
(
)
const
{
return
codeMeta_
;
}
const
CodeTailMetadata
*
codeTailMeta
(
)
const
{
return
codeTailMeta_
;
}
const
FuncCompileInput
&
func
(
)
const
{
return
func_
;
}
TempAllocator
&
alloc
(
)
{
return
alloc_
;
}
MIRGraph
&
mirGraph
(
)
{
return
mirGraph_
;
}
MIRGenerator
&
mirGen
(
)
{
return
mirGen_
;
}
int64_t
inliningBudget
(
)
const
{
return
localInliningBudget_
;
}
FeatureUsage
observedFeatures
(
)
const
{
return
observedFeatures_
;
}
const
CompileStats
&
funcStats
(
)
const
{
return
funcStats_
;
}
void
noteLargeFunctionBackoffWasApplied
(
)
{
inliningStats_
.
largeFunctionBackoff
=
true
;
}
uint32_t
loopDepth
(
)
const
{
return
loopDepth_
;
}
void
startLoop
(
)
{
loopDepth_
+
+
;
}
void
closeLoop
(
)
{
loopDepth_
-
-
;
}
[
[
nodiscard
]
]
bool
generate
(
)
;
InlinedCallerOffsetIndex
inlinedCallerOffsetsIndex
(
)
const
{
return
inlinedCallerOffsetsIndex_
;
}
[
[
nodiscard
]
]
CompileInfo
*
startInlineCall
(
uint32_t
callerFuncIndex
BytecodeOffset
callerOffset
uint32_t
calleeFuncIndex
uint32_t
numLocals
size_t
inlineeBytecodeSize
InliningHeuristics
:
:
CallKind
callKind
)
;
void
finishInlineCall
(
)
;
[
[
nodiscard
]
]
bool
addTryNote
(
uint32_t
*
tryNoteIndex
)
{
if
(
!
tryNotes_
.
append
(
wasm
:
:
TryNote
(
)
)
)
{
return
false
;
}
*
tryNoteIndex
=
tryNotes_
.
length
(
)
-
1
;
return
true
;
}
[
[
nodiscard
]
]
UniqueTryControl
newTryControl
(
)
{
if
(
tryControlCache_
.
empty
(
)
)
{
return
UniqueTryControl
(
js_new
<
TryControl
>
(
)
)
;
}
UniqueTryControl
tryControl
=
std
:
:
move
(
tryControlCache_
.
back
(
)
)
;
tryControlCache_
.
popBack
(
)
;
return
tryControl
;
}
void
freeTryControl
(
UniqueTryControl
&
&
tryControl
)
{
tryControl
-
>
reset
(
)
;
(
void
)
tryControlCache_
.
append
(
std
:
:
move
(
tryControl
)
)
;
}
}
;
class
FunctionCompiler
{
RootCompiler
&
rootCompiler_
;
const
FunctionCompiler
*
callerCompiler_
;
const
uint32_t
inliningDepth_
;
IonOpIter
iter_
;
uint32_t
functionBodyOffset_
;
const
FuncCompileInput
&
func_
;
const
ValTypeVector
&
locals_
;
size_t
lastReadCallSite_
;
size_t
numCallRefs_
;
size_t
numAllocSites_
;
const
jit
:
:
CompileInfo
&
info_
;
MBasicBlock
*
curBlock_
;
uint32_t
maxStackArgBytes_
;
uint32_t
pendingBlockDepth_
;
PendingBlockTargetVector
pendingBlocks_
;
ControlInstructionVector
bodyRethrowPadPatches_
;
PendingInlineReturnVector
pendingInlineReturns_
;
MBasicBlock
*
pendingInlineCatchBlock_
;
MWasmParameter
*
instancePointer_
;
MWasmParameter
*
stackResultPointer_
;
public
:
FunctionCompiler
(
RootCompiler
&
rootCompiler
Decoder
&
decoder
const
FuncCompileInput
&
func
const
ValTypeVector
&
locals
const
CompileInfo
&
compileInfo
)
:
rootCompiler_
(
rootCompiler
)
callerCompiler_
(
nullptr
)
inliningDepth_
(
0
)
iter_
(
rootCompiler
.
codeMeta
(
)
decoder
locals
)
functionBodyOffset_
(
decoder
.
beginOffset
(
)
)
func_
(
func
)
locals_
(
locals
)
lastReadCallSite_
(
0
)
numCallRefs_
(
0
)
numAllocSites_
(
0
)
info_
(
compileInfo
)
curBlock_
(
nullptr
)
maxStackArgBytes_
(
0
)
pendingBlockDepth_
(
0
)
pendingInlineCatchBlock_
(
nullptr
)
instancePointer_
(
nullptr
)
stackResultPointer_
(
nullptr
)
{
}
FunctionCompiler
(
const
FunctionCompiler
*
callerCompiler
Decoder
&
decoder
const
FuncCompileInput
&
func
const
ValTypeVector
&
locals
const
CompileInfo
&
compileInfo
)
:
rootCompiler_
(
callerCompiler
-
>
rootCompiler_
)
callerCompiler_
(
callerCompiler
)
inliningDepth_
(
callerCompiler_
-
>
inliningDepth
(
)
+
1
)
iter_
(
rootCompiler_
.
codeMeta
(
)
decoder
locals
)
functionBodyOffset_
(
decoder
.
beginOffset
(
)
)
func_
(
func
)
locals_
(
locals
)
lastReadCallSite_
(
0
)
numCallRefs_
(
0
)
numAllocSites_
(
0
)
info_
(
compileInfo
)
curBlock_
(
nullptr
)
maxStackArgBytes_
(
0
)
pendingBlockDepth_
(
0
)
pendingInlineCatchBlock_
(
nullptr
)
instancePointer_
(
callerCompiler_
-
>
instancePointer_
)
stackResultPointer_
(
nullptr
)
{
}
RootCompiler
&
rootCompiler
(
)
{
return
rootCompiler_
;
}
const
CodeMetadata
&
codeMeta
(
)
const
{
return
rootCompiler_
.
codeMeta
(
)
;
}
const
CodeTailMetadata
*
codeTailMeta
(
)
const
{
return
rootCompiler_
.
codeTailMeta
(
)
;
}
IonOpIter
&
iter
(
)
{
return
iter_
;
}
uint32_t
relativeBytecodeOffset
(
)
{
return
readBytecodeOffset
(
)
-
functionBodyOffset_
;
}
TempAllocator
&
alloc
(
)
const
{
return
rootCompiler_
.
alloc
(
)
;
}
uint32_t
funcIndex
(
)
const
{
return
func_
.
index
;
}
const
FuncType
&
funcType
(
)
const
{
return
codeMeta
(
)
.
getFuncType
(
func_
.
index
)
;
}
bool
isInlined
(
)
const
{
return
callerCompiler_
!
=
nullptr
;
}
uint32_t
inliningDepth
(
)
const
{
return
inliningDepth_
;
}
MBasicBlock
*
getCurBlock
(
)
const
{
return
curBlock_
;
}
BytecodeOffset
bytecodeOffset
(
)
const
{
return
iter_
.
bytecodeOffset
(
)
;
}
TrapSiteDesc
trapSiteDesc
(
)
{
return
TrapSiteDesc
(
wasm
:
:
BytecodeOffset
(
bytecodeOffset
(
)
)
rootCompiler_
.
inlinedCallerOffsetsIndex
(
)
)
;
}
TrapSiteDesc
trapSiteDescWithCallSiteLineNumber
(
)
{
return
TrapSiteDesc
(
wasm
:
:
BytecodeOffset
(
readCallSiteLineOrBytecode
(
)
)
rootCompiler_
.
inlinedCallerOffsetsIndex
(
)
)
;
}
FeatureUsage
featureUsage
(
)
const
{
return
iter_
.
featureUsage
(
)
;
}
[
[
nodiscard
]
]
bool
initRoot
(
)
{
MOZ_ASSERT
(
!
callerCompiler_
)
;
const
FuncType
&
ft
=
funcType
(
)
;
const
ArgTypeVector
args
(
ft
)
;
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
if
(
!
newBlock
(
nullptr
&
curBlock_
)
)
{
return
false
;
}
for
(
ABIArgIter
i
(
args
ABIKind
:
:
Wasm
)
;
!
i
.
done
(
)
;
i
+
+
)
{
MaybeRefType
argRefType
;
if
(
!
args
.
isSyntheticStackResultPointerArg
(
i
.
index
(
)
)
)
{
ValType
argType
=
ft
.
arg
(
i
.
index
(
)
)
;
argRefType
=
argType
.
isRefType
(
)
?
MaybeRefType
(
argType
.
refType
(
)
)
:
MaybeRefType
(
)
;
}
MWasmParameter
*
ins
=
MWasmParameter
:
:
New
(
alloc
(
)
*
i
i
.
mirType
(
)
argRefType
)
;
curBlock_
-
>
add
(
ins
)
;
if
(
args
.
isSyntheticStackResultPointerArg
(
i
.
index
(
)
)
)
{
MOZ_ASSERT
(
stackResultPointer_
=
=
nullptr
)
;
stackResultPointer_
=
ins
;
}
else
{
curBlock_
-
>
initSlot
(
info
(
)
.
localSlot
(
args
.
naturalIndex
(
i
.
index
(
)
)
)
ins
)
;
}
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
}
instancePointer_
=
MWasmParameter
:
:
New
(
alloc
(
)
ABIArg
(
InstanceReg
)
MIRType
:
:
Pointer
)
;
curBlock_
-
>
add
(
instancePointer_
)
;
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
for
(
size_t
i
=
args
.
lengthWithoutStackResults
(
)
;
i
<
locals_
.
length
(
)
;
i
+
+
)
{
ValType
slotValType
=
locals_
[
i
]
;
#
ifndef
ENABLE_WASM_SIMD
if
(
slotValType
=
=
ValType
:
:
V128
)
{
return
iter
(
)
.
fail
(
"
Ion
has
no
SIMD
support
yet
"
)
;
}
#
endif
MDefinition
*
zero
=
constantZeroOfValType
(
slotValType
)
;
curBlock_
-
>
initSlot
(
info
(
)
.
localSlot
(
i
)
zero
)
;
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
}
return
true
;
}
[
[
nodiscard
]
]
bool
initInline
(
const
DefVector
&
argValues
)
{
MOZ_ASSERT
(
callerCompiler_
)
;
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
if
(
!
newBlock
(
nullptr
&
curBlock_
)
)
{
return
false
;
}
MBasicBlock
*
pred
=
callerCompiler_
-
>
curBlock_
;
pred
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
curBlock_
)
)
;
if
(
!
curBlock_
-
>
addPredecessorWithoutPhis
(
pred
)
)
{
return
false
;
}
const
FuncType
&
type
=
funcType
(
)
;
for
(
uint32_t
argIndex
=
0
;
argIndex
<
type
.
args
(
)
.
length
(
)
;
argIndex
+
+
)
{
curBlock_
-
>
initSlot
(
info
(
)
.
localSlot
(
argIndex
)
argValues
[
argIndex
]
)
;
}
instancePointer_
=
callerCompiler_
-
>
instancePointer_
;
for
(
size_t
i
=
type
.
args
(
)
.
length
(
)
;
i
<
locals_
.
length
(
)
;
i
+
+
)
{
ValType
slotValType
=
locals_
[
i
]
;
#
ifndef
ENABLE_WASM_SIMD
if
(
slotValType
=
=
ValType
:
:
V128
)
{
return
iter
(
)
.
fail
(
"
Ion
has
no
SIMD
support
yet
"
)
;
}
#
endif
MDefinition
*
zero
=
constantZeroOfValType
(
slotValType
)
;
curBlock_
-
>
initSlot
(
info
(
)
.
localSlot
(
i
)
zero
)
;
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
}
return
true
;
}
void
finish
(
)
{
mirGen
(
)
.
accumulateWasmMaxStackArgBytes
(
maxStackArgBytes_
)
;
MOZ_ASSERT
(
pendingBlockDepth_
=
=
0
)
;
#
ifdef
DEBUG
for
(
PendingBlockTarget
&
targets
:
pendingBlocks_
)
{
MOZ_ASSERT
(
targets
.
patches
.
empty
(
)
)
;
}
#
endif
MOZ_ASSERT
(
inDeadCode
(
)
)
;
MOZ_ASSERT
(
done
(
)
)
;
MOZ_ASSERT
(
func_
.
callSiteLineNums
.
length
(
)
=
=
lastReadCallSite_
)
;
MOZ_ASSERT_IF
(
compilerEnv
(
)
.
mode
(
)
=
=
CompileMode
:
:
LazyTiering
codeTailMeta
(
)
-
>
getFuncDefCallRefs
(
funcIndex
(
)
)
.
length
=
=
numCallRefs_
)
;
MOZ_ASSERT_IF
(
codeTailMeta
(
)
codeTailMeta
(
)
-
>
getFuncDefAllocSites
(
funcIndex
(
)
)
.
length
=
=
numAllocSites_
)
;
MOZ_ASSERT_IF
(
!
isInlined
(
)
pendingInlineReturns_
.
empty
(
)
&
&
!
pendingInlineCatchBlock_
)
;
MOZ_ASSERT
(
bodyRethrowPadPatches_
.
empty
(
)
)
;
}
MIRGenerator
&
mirGen
(
)
const
{
return
rootCompiler_
.
mirGen
(
)
;
}
MIRGraph
&
mirGraph
(
)
const
{
return
rootCompiler_
.
mirGraph
(
)
;
}
const
CompileInfo
&
info
(
)
const
{
return
info_
;
}
const
CompilerEnvironment
&
compilerEnv
(
)
const
{
return
rootCompiler_
.
compilerEnv
(
)
;
}
MDefinition
*
getLocalDef
(
unsigned
slot
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
return
curBlock_
-
>
getSlot
(
info
(
)
.
localSlot
(
slot
)
)
;
}
const
ValTypeVector
&
locals
(
)
const
{
return
locals_
;
}
MDefinition
*
constantF32
(
float
f
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
cst
=
MWasmFloatConstant
:
:
NewFloat32
(
alloc
(
)
f
)
;
curBlock_
-
>
add
(
cst
)
;
return
cst
;
}
template
<
typename
T
>
MDefinition
*
constantF32
(
T
)
=
delete
;
MDefinition
*
constantF64
(
double
d
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
cst
=
MWasmFloatConstant
:
:
NewDouble
(
alloc
(
)
d
)
;
curBlock_
-
>
add
(
cst
)
;
return
cst
;
}
template
<
typename
T
>
MDefinition
*
constantF64
(
T
)
=
delete
;
MDefinition
*
constantI32
(
int32_t
i
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MConstant
*
constant
=
MConstant
:
:
New
(
alloc
(
)
Int32Value
(
i
)
MIRType
:
:
Int32
)
;
curBlock_
-
>
add
(
constant
)
;
return
constant
;
}
template
<
typename
T
>
MDefinition
*
constantI32
(
T
)
=
delete
;
MDefinition
*
constantI64
(
int64_t
i
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MConstant
*
constant
=
MConstant
:
:
NewInt64
(
alloc
(
)
i
)
;
curBlock_
-
>
add
(
constant
)
;
return
constant
;
}
template
<
typename
T
>
MDefinition
*
constantI64
(
T
)
=
delete
;
MDefinition
*
constantTargetWord
(
intptr_t
n
)
{
return
targetIs64Bit
(
)
?
constantI64
(
int64_t
(
n
)
)
:
constantI32
(
int32_t
(
n
)
)
;
}
template
<
typename
T
>
MDefinition
*
constantTargetWord
(
T
)
=
delete
;
#
ifdef
ENABLE_WASM_SIMD
MDefinition
*
constantV128
(
V128
v
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MWasmFloatConstant
*
constant
=
MWasmFloatConstant
:
:
NewSimd128
(
alloc
(
)
SimdConstant
:
:
CreateSimd128
(
(
int8_t
*
)
v
.
bytes
)
)
;
curBlock_
-
>
add
(
constant
)
;
return
constant
;
}
template
<
typename
T
>
MDefinition
*
constantV128
(
T
)
=
delete
;
#
endif
MDefinition
*
constantNullRef
(
MaybeRefType
type
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MWasmNullConstant
*
constant
=
MWasmNullConstant
:
:
New
(
alloc
(
)
type
)
;
curBlock_
-
>
add
(
constant
)
;
return
constant
;
}
MDefinition
*
constantZeroOfValType
(
ValType
valType
)
{
switch
(
valType
.
kind
(
)
)
{
case
ValType
:
:
I32
:
return
constantI32
(
0
)
;
case
ValType
:
:
I64
:
return
constantI64
(
int64_t
(
0
)
)
;
#
ifdef
ENABLE_WASM_SIMD
case
ValType
:
:
V128
:
return
constantV128
(
V128
(
0
)
)
;
#
endif
case
ValType
:
:
F32
:
return
constantF32
(
0
.
0f
)
;
case
ValType
:
:
F64
:
return
constantF64
(
0
.
0
)
;
case
ValType
:
:
Ref
:
return
constantNullRef
(
MaybeRefType
(
valType
.
refType
(
)
)
)
;
default
:
MOZ_CRASH
(
)
;
}
}
void
fence
(
)
{
if
(
inDeadCode
(
)
)
{
return
;
}
MWasmFence
*
ins
=
MWasmFence
:
:
New
(
alloc
(
)
)
;
curBlock_
-
>
add
(
ins
)
;
}
template
<
class
T
>
MDefinition
*
unary
(
MDefinition
*
op
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
T
*
ins
=
T
:
:
New
(
alloc
(
)
op
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
template
<
class
T
>
MDefinition
*
unary
(
MDefinition
*
op
MIRType
type
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
T
*
ins
=
T
:
:
New
(
alloc
(
)
op
type
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
template
<
class
T
>
MDefinition
*
binary
(
MDefinition
*
lhs
MDefinition
*
rhs
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
T
*
ins
=
T
:
:
New
(
alloc
(
)
lhs
rhs
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
template
<
class
T
>
MDefinition
*
binary
(
MDefinition
*
lhs
MDefinition
*
rhs
MIRType
type
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
T
*
ins
=
T
:
:
New
(
alloc
(
)
lhs
rhs
type
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
template
<
class
T
>
MDefinition
*
binary
(
MDefinition
*
lhs
MDefinition
*
rhs
MIRType
type
MWasmBinaryBitwise
:
:
SubOpcode
subOpc
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
T
*
ins
=
T
:
:
New
(
alloc
(
)
lhs
rhs
type
subOpc
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
ursh
(
MDefinition
*
lhs
MDefinition
*
rhs
MIRType
type
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MUrsh
:
:
NewWasm
(
alloc
(
)
lhs
rhs
type
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
add
(
MDefinition
*
lhs
MDefinition
*
rhs
MIRType
type
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MAdd
:
:
NewWasm
(
alloc
(
)
lhs
rhs
type
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
bool
mustPreserveNaN
(
MIRType
type
)
{
return
IsFloatingPointType
(
type
)
&
&
!
codeMeta
(
)
.
isAsmJS
(
)
;
}
MDefinition
*
sub
(
MDefinition
*
lhs
MDefinition
*
rhs
MIRType
type
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MSub
*
ins
=
MSub
:
:
NewWasm
(
alloc
(
)
lhs
rhs
type
mustPreserveNaN
(
type
)
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
nearbyInt
(
MDefinition
*
input
RoundingMode
roundingMode
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MNearbyInt
:
:
New
(
alloc
(
)
input
input
-
>
type
(
)
roundingMode
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
minMax
(
MDefinition
*
lhs
MDefinition
*
rhs
MIRType
type
bool
isMax
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
if
(
mustPreserveNaN
(
type
)
)
{
MDefinition
*
zero
=
constantZeroOfValType
(
ValType
:
:
fromMIRType
(
type
)
)
;
lhs
=
sub
(
lhs
zero
type
)
;
rhs
=
sub
(
rhs
zero
type
)
;
}
MMinMax
*
ins
=
MMinMax
:
:
NewWasm
(
alloc
(
)
lhs
rhs
type
isMax
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
mul
(
MDefinition
*
lhs
MDefinition
*
rhs
MIRType
type
MMul
:
:
Mode
mode
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MMul
:
:
NewWasm
(
alloc
(
)
lhs
rhs
type
mode
mustPreserveNaN
(
type
)
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
div
(
MDefinition
*
lhs
MDefinition
*
rhs
MIRType
type
bool
unsignd
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
bool
trapOnError
=
!
codeMeta
(
)
.
isAsmJS
(
)
;
if
(
!
unsignd
&
&
type
=
=
MIRType
:
:
Int32
)
{
auto
*
lhs2
=
createTruncateToInt32
(
lhs
)
;
curBlock_
-
>
add
(
lhs2
)
;
lhs
=
lhs2
;
auto
*
rhs2
=
createTruncateToInt32
(
rhs
)
;
curBlock_
-
>
add
(
rhs2
)
;
rhs
=
rhs2
;
}
#
if
defined
(
JS_CODEGEN_X86
)
|
|
defined
(
JS_CODEGEN_ARM
)
if
(
type
=
=
MIRType
:
:
Int64
)
{
auto
*
ins
=
MWasmBuiltinDivI64
:
:
New
(
alloc
(
)
lhs
rhs
instancePointer_
unsignd
trapOnError
trapSiteDesc
(
)
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
#
endif
auto
*
ins
=
MDiv
:
:
New
(
alloc
(
)
lhs
rhs
type
unsignd
trapOnError
trapSiteDesc
(
)
mustPreserveNaN
(
type
)
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MInstruction
*
createTruncateToInt32
(
MDefinition
*
op
)
{
if
(
op
-
>
type
(
)
=
=
MIRType
:
:
Double
|
|
op
-
>
type
(
)
=
=
MIRType
:
:
Float32
)
{
return
MWasmBuiltinTruncateToInt32
:
:
New
(
alloc
(
)
op
instancePointer_
)
;
}
return
MTruncateToInt32
:
:
New
(
alloc
(
)
op
)
;
}
MDefinition
*
mod
(
MDefinition
*
lhs
MDefinition
*
rhs
MIRType
type
bool
unsignd
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
bool
trapOnError
=
!
codeMeta
(
)
.
isAsmJS
(
)
;
if
(
!
unsignd
&
&
type
=
=
MIRType
:
:
Int32
)
{
auto
*
lhs2
=
createTruncateToInt32
(
lhs
)
;
curBlock_
-
>
add
(
lhs2
)
;
lhs
=
lhs2
;
auto
*
rhs2
=
createTruncateToInt32
(
rhs
)
;
curBlock_
-
>
add
(
rhs2
)
;
rhs
=
rhs2
;
}
#
if
defined
(
JS_CODEGEN_X86
)
|
|
defined
(
JS_CODEGEN_ARM
)
if
(
type
=
=
MIRType
:
:
Int64
)
{
auto
*
ins
=
MWasmBuiltinModI64
:
:
New
(
alloc
(
)
lhs
rhs
instancePointer_
unsignd
trapOnError
trapSiteDesc
(
)
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
#
endif
if
(
type
=
=
MIRType
:
:
Double
)
{
auto
*
ins
=
MWasmBuiltinModD
:
:
New
(
alloc
(
)
lhs
rhs
instancePointer_
type
bytecodeOffset
(
)
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
auto
*
ins
=
MMod
:
:
New
(
alloc
(
)
lhs
rhs
type
unsignd
trapOnError
trapSiteDesc
(
)
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
bitnot
(
MDefinition
*
op
MIRType
type
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MBitNot
:
:
New
(
alloc
(
)
op
type
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
select
(
MDefinition
*
trueExpr
MDefinition
*
falseExpr
MDefinition
*
condExpr
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MWasmSelect
:
:
New
(
alloc
(
)
trueExpr
falseExpr
condExpr
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
extendI32
(
MDefinition
*
op
bool
isUnsigned
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MExtendInt32ToInt64
:
:
New
(
alloc
(
)
op
isUnsigned
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
signExtend
(
MDefinition
*
op
uint32_t
srcSize
uint32_t
targetSize
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MInstruction
*
ins
;
switch
(
targetSize
)
{
case
4
:
{
MSignExtendInt32
:
:
Mode
mode
;
switch
(
srcSize
)
{
case
1
:
mode
=
MSignExtendInt32
:
:
Byte
;
break
;
case
2
:
mode
=
MSignExtendInt32
:
:
Half
;
break
;
default
:
MOZ_CRASH
(
"
Bad
sign
extension
"
)
;
}
ins
=
MSignExtendInt32
:
:
New
(
alloc
(
)
op
mode
)
;
break
;
}
case
8
:
{
MSignExtendInt64
:
:
Mode
mode
;
switch
(
srcSize
)
{
case
1
:
mode
=
MSignExtendInt64
:
:
Byte
;
break
;
case
2
:
mode
=
MSignExtendInt64
:
:
Half
;
break
;
case
4
:
mode
=
MSignExtendInt64
:
:
Word
;
break
;
default
:
MOZ_CRASH
(
"
Bad
sign
extension
"
)
;
}
ins
=
MSignExtendInt64
:
:
New
(
alloc
(
)
op
mode
)
;
break
;
}
default
:
{
MOZ_CRASH
(
"
Bad
sign
extension
"
)
;
}
}
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
convertI64ToFloatingPoint
(
MDefinition
*
op
MIRType
type
bool
isUnsigned
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
#
if
defined
(
JS_CODEGEN_ARM
)
auto
*
ins
=
MBuiltinInt64ToFloatingPoint
:
:
New
(
alloc
(
)
op
instancePointer_
type
bytecodeOffset
(
)
isUnsigned
)
;
#
else
auto
*
ins
=
MInt64ToFloatingPoint
:
:
New
(
alloc
(
)
op
type
bytecodeOffset
(
)
isUnsigned
)
;
#
endif
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
rotate
(
MDefinition
*
input
MDefinition
*
count
MIRType
type
bool
left
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MRotate
:
:
New
(
alloc
(
)
input
count
type
left
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
template
<
class
T
>
MDefinition
*
truncate
(
MDefinition
*
op
TruncFlags
flags
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
T
:
:
New
(
alloc
(
)
op
flags
trapSiteDesc
(
)
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
#
if
defined
(
JS_CODEGEN_ARM
)
MDefinition
*
truncateWithInstance
(
MDefinition
*
op
TruncFlags
flags
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MWasmBuiltinTruncateToInt64
:
:
New
(
alloc
(
)
op
instancePointer_
flags
trapSiteDesc
(
)
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
#
endif
MDefinition
*
compare
(
MDefinition
*
lhs
MDefinition
*
rhs
JSOp
op
MCompare
:
:
CompareType
type
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MCompare
:
:
NewWasm
(
alloc
(
)
lhs
rhs
op
type
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
void
assign
(
unsigned
slot
MDefinition
*
def
)
{
if
(
inDeadCode
(
)
)
{
return
;
}
curBlock_
-
>
setSlot
(
info
(
)
.
localSlot
(
slot
)
def
)
;
}
MDefinition
*
compareIsNull
(
MDefinition
*
ref
JSOp
compareOp
)
{
MDefinition
*
nullVal
=
constantNullRef
(
MaybeRefType
(
)
)
;
if
(
!
nullVal
)
{
return
nullptr
;
}
return
compare
(
ref
nullVal
compareOp
MCompare
:
:
Compare_WasmAnyRef
)
;
}
[
[
nodiscard
]
]
MDefinition
*
refAsNonNull
(
MDefinition
*
ref
)
{
MOZ_ASSERT
(
!
inDeadCode
(
)
)
;
auto
*
ins
=
MWasmRefAsNonNull
:
:
New
(
alloc
(
)
ref
trapSiteDesc
(
)
)
;
if
(
!
ins
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
[
[
nodiscard
]
]
bool
brOnNull
(
uint32_t
relativeDepth
const
DefVector
&
values
const
ResultType
&
type
MDefinition
*
condition
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
MBasicBlock
*
fallthroughBlock
=
nullptr
;
if
(
!
newBlock
(
curBlock_
&
fallthroughBlock
)
)
{
return
false
;
}
MDefinition
*
check
=
compareIsNull
(
condition
JSOp
:
:
Eq
)
;
if
(
!
check
)
{
return
false
;
}
MTest
*
test
=
MTest
:
:
New
(
alloc
(
)
check
nullptr
fallthroughBlock
)
;
if
(
!
test
|
|
!
addControlFlowPatch
(
test
relativeDepth
MTest
:
:
TrueBranchIndex
)
)
{
return
false
;
}
if
(
!
pushDefs
(
values
)
)
{
return
false
;
}
curBlock_
-
>
end
(
test
)
;
curBlock_
=
fallthroughBlock
;
return
true
;
}
[
[
nodiscard
]
]
bool
brOnNonNull
(
uint32_t
relativeDepth
const
DefVector
&
values
const
ResultType
&
type
MDefinition
*
condition
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
MBasicBlock
*
fallthroughBlock
=
nullptr
;
if
(
!
newBlock
(
curBlock_
&
fallthroughBlock
)
)
{
return
false
;
}
MDefinition
*
check
=
compareIsNull
(
condition
JSOp
:
:
Ne
)
;
if
(
!
check
)
{
return
false
;
}
MTest
*
test
=
MTest
:
:
New
(
alloc
(
)
check
nullptr
fallthroughBlock
)
;
if
(
!
test
|
|
!
addControlFlowPatch
(
test
relativeDepth
MTest
:
:
TrueBranchIndex
)
)
{
return
false
;
}
if
(
!
pushDefs
(
values
)
)
{
return
false
;
}
curBlock_
-
>
end
(
test
)
;
curBlock_
=
fallthroughBlock
;
return
true
;
}
MDefinition
*
refI31
(
MDefinition
*
input
)
{
auto
*
ins
=
MWasmNewI31Ref
:
:
New
(
alloc
(
)
input
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
i31Get
(
MDefinition
*
input
FieldWideningOp
wideningOp
)
{
auto
*
ins
=
MWasmI31RefGet
:
:
New
(
alloc
(
)
input
wideningOp
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
#
ifdef
ENABLE_WASM_SIMD
MDefinition
*
binarySimd128
(
MDefinition
*
lhs
MDefinition
*
rhs
bool
commutative
SimdOp
op
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
lhs
-
>
type
(
)
=
=
MIRType
:
:
Simd128
&
&
rhs
-
>
type
(
)
=
=
MIRType
:
:
Simd128
)
;
auto
*
ins
=
MWasmBinarySimd128
:
:
New
(
alloc
(
)
lhs
rhs
commutative
op
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
shiftSimd128
(
MDefinition
*
lhs
MDefinition
*
rhs
SimdOp
op
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
lhs
-
>
type
(
)
=
=
MIRType
:
:
Simd128
&
&
rhs
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
int32_t
maskBits
;
if
(
MacroAssembler
:
:
MustMaskShiftCountSimd128
(
op
&
maskBits
)
)
{
MDefinition
*
mask
=
constantI32
(
maskBits
)
;
auto
*
rhs2
=
MBitAnd
:
:
New
(
alloc
(
)
rhs
mask
MIRType
:
:
Int32
)
;
curBlock_
-
>
add
(
rhs2
)
;
rhs
=
rhs2
;
}
auto
*
ins
=
MWasmShiftSimd128
:
:
New
(
alloc
(
)
lhs
rhs
op
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
replaceLaneSimd128
(
MDefinition
*
lhs
MDefinition
*
rhs
uint32_t
laneIndex
SimdOp
op
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
lhs
-
>
type
(
)
=
=
MIRType
:
:
Simd128
)
;
auto
*
ins
=
MWasmReplaceLaneSimd128
:
:
New
(
alloc
(
)
lhs
rhs
laneIndex
op
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
scalarToSimd128
(
MDefinition
*
src
SimdOp
op
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MWasmScalarToSimd128
:
:
New
(
alloc
(
)
src
op
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
unarySimd128
(
MDefinition
*
src
SimdOp
op
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
src
-
>
type
(
)
=
=
MIRType
:
:
Simd128
)
;
auto
*
ins
=
MWasmUnarySimd128
:
:
New
(
alloc
(
)
src
op
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
reduceSimd128
(
MDefinition
*
src
SimdOp
op
ValType
outType
uint32_t
imm
=
0
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
src
-
>
type
(
)
=
=
MIRType
:
:
Simd128
)
;
auto
*
ins
=
MWasmReduceSimd128
:
:
New
(
alloc
(
)
src
op
outType
.
toMIRType
(
)
imm
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
ternarySimd128
(
MDefinition
*
v0
MDefinition
*
v1
MDefinition
*
v2
SimdOp
op
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
v0
-
>
type
(
)
=
=
MIRType
:
:
Simd128
&
&
v1
-
>
type
(
)
=
=
MIRType
:
:
Simd128
&
&
v2
-
>
type
(
)
=
=
MIRType
:
:
Simd128
)
;
auto
*
ins
=
MWasmTernarySimd128
:
:
New
(
alloc
(
)
v0
v1
v2
op
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
MDefinition
*
shuffleSimd128
(
MDefinition
*
v1
MDefinition
*
v2
V128
control
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
v1
-
>
type
(
)
=
=
MIRType
:
:
Simd128
)
;
MOZ_ASSERT
(
v2
-
>
type
(
)
=
=
MIRType
:
:
Simd128
)
;
auto
*
ins
=
BuildWasmShuffleSimd128
(
alloc
(
)
reinterpret_cast
<
int8_t
*
>
(
control
.
bytes
)
v1
v2
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
#
endif
private
:
MDefinition
*
maybeLoadMemoryBase
(
uint32_t
memoryIndex
)
{
#
ifdef
WASM_HAS_HEAPREG
if
(
memoryIndex
=
=
0
)
{
return
nullptr
;
}
#
endif
return
memoryBase
(
memoryIndex
)
;
}
public
:
MDefinition
*
memoryBase
(
uint32_t
memoryIndex
)
{
AliasSet
aliases
=
!
codeMeta
(
)
.
memories
[
memoryIndex
]
.
canMovingGrow
(
)
?
AliasSet
:
:
None
(
)
:
AliasSet
:
:
Load
(
AliasSet
:
:
WasmHeapMeta
)
;
#
ifdef
WASM_HAS_HEAPREG
if
(
memoryIndex
=
=
0
)
{
MWasmHeapReg
*
base
=
MWasmHeapReg
:
:
New
(
alloc
(
)
aliases
)
;
curBlock_
-
>
add
(
base
)
;
return
base
;
}
#
endif
uint32_t
offset
=
memoryIndex
=
=
0
?
Instance
:
:
offsetOfMemory0Base
(
)
:
(
Instance
:
:
offsetInData
(
codeMeta
(
)
.
offsetOfMemoryInstanceData
(
memoryIndex
)
+
offsetof
(
MemoryInstanceData
base
)
)
)
;
MWasmLoadInstance
*
base
=
MWasmLoadInstance
:
:
New
(
alloc
(
)
instancePointer_
offset
MIRType
:
:
Pointer
aliases
)
;
curBlock_
-
>
add
(
base
)
;
return
base
;
}
private
:
MWasmLoadInstance
*
maybeLoadBoundsCheckLimit
(
uint32_t
memoryIndex
MIRType
type
)
{
MOZ_ASSERT
(
type
=
=
MIRType
:
:
Int32
|
|
type
=
=
MIRType
:
:
Int64
)
;
if
(
codeMeta
(
)
.
hugeMemoryEnabled
(
memoryIndex
)
)
{
return
nullptr
;
}
uint32_t
offset
=
memoryIndex
=
=
0
?
Instance
:
:
offsetOfMemory0BoundsCheckLimit
(
)
:
(
Instance
:
:
offsetInData
(
codeMeta
(
)
.
offsetOfMemoryInstanceData
(
memoryIndex
)
+
offsetof
(
MemoryInstanceData
boundsCheckLimit
)
)
)
;
AliasSet
aliases
=
!
codeMeta
(
)
.
memories
[
memoryIndex
]
.
canMovingGrow
(
)
?
AliasSet
:
:
None
(
)
:
AliasSet
:
:
Load
(
AliasSet
:
:
WasmHeapMeta
)
;
auto
*
load
=
MWasmLoadInstance
:
:
New
(
alloc
(
)
instancePointer_
offset
type
aliases
)
;
curBlock_
-
>
add
(
load
)
;
return
load
;
}
MDefinition
*
maybeCanonicalizeNaN
(
Scalar
:
:
Type
accessType
MDefinition
*
value
)
{
MOZ_ASSERT
(
codeMeta
(
)
.
isAsmJS
(
)
)
;
if
(
Scalar
:
:
isFloatingType
(
accessType
)
&
&
js
:
:
SupportDifferentialTesting
(
)
)
{
auto
*
canonicalize
=
MCanonicalizeNaN
:
:
New
(
alloc
(
)
value
)
;
curBlock_
-
>
add
(
canonicalize
)
;
return
canonicalize
;
}
return
value
;
}
bool
needAlignmentCheck
(
MemoryAccessDesc
*
access
MDefinition
*
base
bool
*
mustAdd
)
{
MOZ_ASSERT
(
!
*
mustAdd
)
;
if
(
codeMeta
(
)
.
isAsmJS
(
)
|
|
!
access
-
>
isAtomic
(
)
)
{
return
false
;
}
if
(
base
-
>
isConstant
(
)
)
{
uint32_t
ptr
=
0
;
if
(
isMem64
(
access
-
>
memoryIndex
(
)
)
)
{
ptr
=
uint32_t
(
base
-
>
toConstant
(
)
-
>
toInt64
(
)
)
;
}
else
{
ptr
=
base
-
>
toConstant
(
)
-
>
toInt32
(
)
;
}
if
(
(
(
ptr
+
access
-
>
offset64
(
)
)
&
(
access
-
>
byteSize
(
)
-
1
)
)
=
=
0
)
{
return
false
;
}
}
*
mustAdd
=
(
access
-
>
offset64
(
)
&
(
access
-
>
byteSize
(
)
-
1
)
)
!
=
0
;
return
true
;
}
void
foldConstantPointer
(
MemoryAccessDesc
*
access
MDefinition
*
*
base
)
{
uint64_t
offsetGuardLimit
=
GetMaxOffsetGuardLimit
(
codeMeta
(
)
.
hugeMemoryEnabled
(
access
-
>
memoryIndex
(
)
)
)
;
if
(
(
*
base
)
-
>
isConstant
(
)
)
{
uint64_t
basePtr
=
0
;
if
(
isMem64
(
access
-
>
memoryIndex
(
)
)
)
{
basePtr
=
uint64_t
(
(
*
base
)
-
>
toConstant
(
)
-
>
toInt64
(
)
)
;
}
else
{
basePtr
=
uint64_t
(
int64_t
(
(
*
base
)
-
>
toConstant
(
)
-
>
toInt32
(
)
)
)
;
}
uint64_t
offset
=
access
-
>
offset64
(
)
;
if
(
offset
<
offsetGuardLimit
&
&
basePtr
<
offsetGuardLimit
-
offset
)
{
offset
+
=
basePtr
;
access
-
>
setOffset32
(
uint32_t
(
offset
)
)
;
*
base
=
isMem64
(
access
-
>
memoryIndex
(
)
)
?
constantI64
(
int64_t
(
0
)
)
:
constantI32
(
0
)
;
}
}
}
void
maybeComputeEffectiveAddress
(
MemoryAccessDesc
*
access
MDefinition
*
*
base
bool
mustAddOffset
)
{
uint64_t
offsetGuardLimit
=
GetMaxOffsetGuardLimit
(
codeMeta
(
)
.
hugeMemoryEnabled
(
access
-
>
memoryIndex
(
)
)
)
;
if
(
access
-
>
offset64
(
)
>
=
offsetGuardLimit
|
|
access
-
>
offset64
(
)
>
UINT32_MAX
|
|
mustAddOffset
|
|
!
JitOptions
.
wasmFoldOffsets
)
{
*
base
=
computeEffectiveAddress
(
*
base
access
)
;
}
}
MWasmLoadInstance
*
needBoundsCheck
(
uint32_t
memoryIndex
)
{
#
ifdef
JS_64BIT
static_assert
(
0x100000000
%
PageSize
=
=
0
)
;
bool
mem32LimitIs64Bits
=
isMem32
(
memoryIndex
)
&
&
!
codeMeta
(
)
.
memories
[
memoryIndex
]
.
boundsCheckLimitIs32Bits
(
)
&
&
MaxMemoryPages
(
codeMeta
(
)
.
memories
[
memoryIndex
]
.
addressType
(
)
)
>
=
Pages
(
0x100000000
/
PageSize
)
;
#
else
bool
mem32LimitIs64Bits
=
false
;
#
endif
return
maybeLoadBoundsCheckLimit
(
memoryIndex
mem32LimitIs64Bits
|
|
isMem64
(
memoryIndex
)
?
MIRType
:
:
Int64
:
MIRType
:
:
Int32
)
;
}
void
performBoundsCheck
(
uint32_t
memoryIndex
MDefinition
*
*
base
MWasmLoadInstance
*
boundsCheckLimit
)
{
MDefinition
*
actualBase
=
*
base
;
bool
extendAndWrapIndex
=
isMem32
(
memoryIndex
)
&
&
boundsCheckLimit
-
>
type
(
)
=
=
MIRType
:
:
Int64
;
if
(
extendAndWrapIndex
)
{
auto
*
extended
=
MWasmExtendU32Index
:
:
New
(
alloc
(
)
actualBase
)
;
curBlock_
-
>
add
(
extended
)
;
actualBase
=
extended
;
}
auto
target
=
memoryIndex
=
=
0
?
MWasmBoundsCheck
:
:
Memory0
:
MWasmBoundsCheck
:
:
Unknown
;
auto
*
ins
=
MWasmBoundsCheck
:
:
New
(
alloc
(
)
actualBase
boundsCheckLimit
trapSiteDesc
(
)
target
)
;
curBlock_
-
>
add
(
ins
)
;
actualBase
=
ins
;
if
(
JitOptions
.
spectreIndexMasking
)
{
if
(
extendAndWrapIndex
)
{
auto
*
wrapped
=
MWasmWrapU32Index
:
:
New
(
alloc
(
)
actualBase
)
;
curBlock_
-
>
add
(
wrapped
)
;
actualBase
=
wrapped
;
}
*
base
=
actualBase
;
}
}
void
checkOffsetAndAlignmentAndBounds
(
MemoryAccessDesc
*
access
MDefinition
*
*
base
)
{
MOZ_ASSERT
(
!
inDeadCode
(
)
)
;
MOZ_ASSERT
(
!
codeMeta
(
)
.
isAsmJS
(
)
)
;
foldConstantPointer
(
access
base
)
;
bool
mustAddOffsetForAlignmentCheck
=
false
;
bool
alignmentCheck
=
needAlignmentCheck
(
access
*
base
&
mustAddOffsetForAlignmentCheck
)
;
maybeComputeEffectiveAddress
(
access
base
mustAddOffsetForAlignmentCheck
)
;
if
(
alignmentCheck
)
{
curBlock_
-
>
add
(
MWasmAlignmentCheck
:
:
New
(
alloc
(
)
*
base
access
-
>
byteSize
(
)
trapSiteDesc
(
)
)
)
;
}
MWasmLoadInstance
*
boundsCheckLimit
=
needBoundsCheck
(
access
-
>
memoryIndex
(
)
)
;
if
(
boundsCheckLimit
)
{
performBoundsCheck
(
access
-
>
memoryIndex
(
)
base
boundsCheckLimit
)
;
}
#
ifndef
JS_64BIT
if
(
isMem64
(
access
-
>
memoryIndex
(
)
)
)
{
MOZ_ASSERT
(
(
*
base
)
-
>
type
(
)
=
=
MIRType
:
:
Int64
)
;
MOZ_ASSERT
(
!
codeMeta
(
)
.
hugeMemoryEnabled
(
access
-
>
memoryIndex
(
)
)
)
;
auto
*
chopped
=
MWasmWrapU32Index
:
:
New
(
alloc
(
)
*
base
)
;
MOZ_ASSERT
(
chopped
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
curBlock_
-
>
add
(
chopped
)
;
*
base
=
chopped
;
}
#
endif
}
bool
isSmallerAccessForI64
(
ValType
result
const
MemoryAccessDesc
*
access
)
{
if
(
result
=
=
ValType
:
:
I64
&
&
access
-
>
byteSize
(
)
<
=
4
)
{
MOZ_ASSERT
(
!
isSignedIntType
(
access
-
>
type
(
)
)
)
;
return
true
;
}
return
false
;
}
public
:
bool
isMem32
(
uint32_t
memoryIndex
)
{
return
codeMeta
(
)
.
memories
[
memoryIndex
]
.
addressType
(
)
=
=
AddressType
:
:
I32
;
}
bool
isMem64
(
uint32_t
memoryIndex
)
{
return
codeMeta
(
)
.
memories
[
memoryIndex
]
.
addressType
(
)
=
=
AddressType
:
:
I64
;
}
bool
hugeMemoryEnabled
(
uint32_t
memoryIndex
)
{
return
codeMeta
(
)
.
hugeMemoryEnabled
(
memoryIndex
)
;
}
MDefinition
*
computeEffectiveAddress
(
MDefinition
*
base
MemoryAccessDesc
*
access
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
uint64_t
offset
=
access
-
>
offset64
(
)
;
if
(
offset
=
=
0
)
{
return
base
;
}
auto
*
ins
=
MWasmAddOffset
:
:
New
(
alloc
(
)
base
offset
trapSiteDesc
(
)
)
;
curBlock_
-
>
add
(
ins
)
;
access
-
>
clearOffset
(
)
;
return
ins
;
}
MDefinition
*
load
(
MDefinition
*
base
MemoryAccessDesc
*
access
ValType
result
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MDefinition
*
memoryBase
=
maybeLoadMemoryBase
(
access
-
>
memoryIndex
(
)
)
;
MInstruction
*
load
=
nullptr
;
if
(
codeMeta
(
)
.
isAsmJS
(
)
)
{
MOZ_ASSERT
(
access
-
>
offset64
(
)
=
=
0
)
;
MWasmLoadInstance
*
boundsCheckLimit
=
maybeLoadBoundsCheckLimit
(
access
-
>
memoryIndex
(
)
MIRType
:
:
Int32
)
;
load
=
MAsmJSLoadHeap
:
:
New
(
alloc
(
)
memoryBase
base
boundsCheckLimit
access
-
>
type
(
)
)
;
}
else
{
checkOffsetAndAlignmentAndBounds
(
access
&
base
)
;
#
ifndef
JS_64BIT
MOZ_ASSERT
(
base
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
#
endif
load
=
MWasmLoad
:
:
New
(
alloc
(
)
memoryBase
base
*
access
result
.
toMIRType
(
)
)
;
}
if
(
!
load
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
load
)
;
return
load
;
}
void
store
(
MDefinition
*
base
MemoryAccessDesc
*
access
MDefinition
*
v
)
{
if
(
inDeadCode
(
)
)
{
return
;
}
MDefinition
*
memoryBase
=
maybeLoadMemoryBase
(
access
-
>
memoryIndex
(
)
)
;
MInstruction
*
store
=
nullptr
;
if
(
codeMeta
(
)
.
isAsmJS
(
)
)
{
MOZ_ASSERT
(
access
-
>
offset64
(
)
=
=
0
)
;
MWasmLoadInstance
*
boundsCheckLimit
=
maybeLoadBoundsCheckLimit
(
access
-
>
memoryIndex
(
)
MIRType
:
:
Int32
)
;
v
=
maybeCanonicalizeNaN
(
access
-
>
type
(
)
v
)
;
store
=
MAsmJSStoreHeap
:
:
New
(
alloc
(
)
memoryBase
base
boundsCheckLimit
access
-
>
type
(
)
v
)
;
}
else
{
checkOffsetAndAlignmentAndBounds
(
access
&
base
)
;
#
ifndef
JS_64BIT
MOZ_ASSERT
(
base
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
#
endif
store
=
MWasmStore
:
:
New
(
alloc
(
)
memoryBase
base
*
access
v
)
;
}
if
(
!
store
)
{
return
;
}
curBlock_
-
>
add
(
store
)
;
}
MDefinition
*
atomicCompareExchangeHeap
(
MDefinition
*
base
MemoryAccessDesc
*
access
ValType
result
MDefinition
*
oldv
MDefinition
*
newv
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
checkOffsetAndAlignmentAndBounds
(
access
&
base
)
;
#
ifndef
JS_64BIT
MOZ_ASSERT
(
base
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
#
endif
if
(
isSmallerAccessForI64
(
result
access
)
)
{
auto
*
cvtOldv
=
MWrapInt64ToInt32
:
:
New
(
alloc
(
)
oldv
true
)
;
curBlock_
-
>
add
(
cvtOldv
)
;
oldv
=
cvtOldv
;
auto
*
cvtNewv
=
MWrapInt64ToInt32
:
:
New
(
alloc
(
)
newv
true
)
;
curBlock_
-
>
add
(
cvtNewv
)
;
newv
=
cvtNewv
;
}
MDefinition
*
memoryBase
=
maybeLoadMemoryBase
(
access
-
>
memoryIndex
(
)
)
;
MInstruction
*
cas
=
MWasmCompareExchangeHeap
:
:
New
(
alloc
(
)
bytecodeOffset
(
)
memoryBase
base
*
access
oldv
newv
instancePointer_
)
;
if
(
!
cas
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
cas
)
;
if
(
isSmallerAccessForI64
(
result
access
)
)
{
cas
=
MExtendInt32ToInt64
:
:
New
(
alloc
(
)
cas
true
)
;
curBlock_
-
>
add
(
cas
)
;
}
return
cas
;
}
MDefinition
*
atomicExchangeHeap
(
MDefinition
*
base
MemoryAccessDesc
*
access
ValType
result
MDefinition
*
value
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
checkOffsetAndAlignmentAndBounds
(
access
&
base
)
;
#
ifndef
JS_64BIT
MOZ_ASSERT
(
base
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
#
endif
if
(
isSmallerAccessForI64
(
result
access
)
)
{
auto
*
cvtValue
=
MWrapInt64ToInt32
:
:
New
(
alloc
(
)
value
true
)
;
curBlock_
-
>
add
(
cvtValue
)
;
value
=
cvtValue
;
}
MDefinition
*
memoryBase
=
maybeLoadMemoryBase
(
access
-
>
memoryIndex
(
)
)
;
MInstruction
*
xchg
=
MWasmAtomicExchangeHeap
:
:
New
(
alloc
(
)
bytecodeOffset
(
)
memoryBase
base
*
access
value
instancePointer_
)
;
if
(
!
xchg
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
xchg
)
;
if
(
isSmallerAccessForI64
(
result
access
)
)
{
xchg
=
MExtendInt32ToInt64
:
:
New
(
alloc
(
)
xchg
true
)
;
curBlock_
-
>
add
(
xchg
)
;
}
return
xchg
;
}
MDefinition
*
atomicBinopHeap
(
AtomicOp
op
MDefinition
*
base
MemoryAccessDesc
*
access
ValType
result
MDefinition
*
value
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
checkOffsetAndAlignmentAndBounds
(
access
&
base
)
;
#
ifndef
JS_64BIT
MOZ_ASSERT
(
base
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
#
endif
if
(
isSmallerAccessForI64
(
result
access
)
)
{
auto
*
cvtValue
=
MWrapInt64ToInt32
:
:
New
(
alloc
(
)
value
true
)
;
curBlock_
-
>
add
(
cvtValue
)
;
value
=
cvtValue
;
}
MDefinition
*
memoryBase
=
maybeLoadMemoryBase
(
access
-
>
memoryIndex
(
)
)
;
MInstruction
*
binop
=
MWasmAtomicBinopHeap
:
:
New
(
alloc
(
)
bytecodeOffset
(
)
op
memoryBase
base
*
access
value
instancePointer_
)
;
if
(
!
binop
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
binop
)
;
if
(
isSmallerAccessForI64
(
result
access
)
)
{
binop
=
MExtendInt32ToInt64
:
:
New
(
alloc
(
)
binop
true
)
;
curBlock_
-
>
add
(
binop
)
;
}
return
binop
;
}
#
ifdef
ENABLE_WASM_SIMD
MDefinition
*
loadSplatSimd128
(
Scalar
:
:
Type
viewType
const
LinearMemoryAddress
<
MDefinition
*
>
&
addr
wasm
:
:
SimdOp
splatOp
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
viewType
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
)
;
if
(
viewType
=
=
Scalar
:
:
Float64
#
if
defined
(
JS_CODEGEN_X64
)
|
|
defined
(
JS_CODEGEN_X86
)
|
|
(
js
:
:
jit
:
:
CPUInfo
:
:
IsAVX2Present
(
)
&
&
(
viewType
=
=
Scalar
:
:
Uint8
|
|
viewType
=
=
Scalar
:
:
Uint16
|
|
viewType
=
=
Scalar
:
:
Float32
)
)
#
endif
)
{
access
.
setSplatSimd128Load
(
)
;
return
load
(
addr
.
base
&
access
ValType
:
:
V128
)
;
}
ValType
resultType
=
ValType
:
:
I32
;
if
(
viewType
=
=
Scalar
:
:
Float32
)
{
resultType
=
ValType
:
:
F32
;
splatOp
=
wasm
:
:
SimdOp
:
:
F32x4Splat
;
}
auto
*
scalar
=
load
(
addr
.
base
&
access
resultType
)
;
if
(
!
inDeadCode
(
)
&
&
!
scalar
)
{
return
nullptr
;
}
return
scalarToSimd128
(
scalar
splatOp
)
;
}
MDefinition
*
loadExtendSimd128
(
const
LinearMemoryAddress
<
MDefinition
*
>
&
addr
wasm
:
:
SimdOp
op
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
Scalar
:
:
Float64
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
)
;
access
.
setWidenSimd128Load
(
op
)
;
return
load
(
addr
.
base
&
access
ValType
:
:
V128
)
;
}
MDefinition
*
loadZeroSimd128
(
Scalar
:
:
Type
viewType
size_t
numBytes
const
LinearMemoryAddress
<
MDefinition
*
>
&
addr
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
viewType
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
)
;
access
.
setZeroExtendSimd128Load
(
)
;
return
load
(
addr
.
base
&
access
ValType
:
:
V128
)
;
}
MDefinition
*
loadLaneSimd128
(
uint32_t
laneSize
const
LinearMemoryAddress
<
MDefinition
*
>
&
addr
uint32_t
laneIndex
MDefinition
*
src
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
Scalar
:
:
Simd128
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
)
;
MDefinition
*
memoryBase
=
maybeLoadMemoryBase
(
access
.
memoryIndex
(
)
)
;
MDefinition
*
base
=
addr
.
base
;
MOZ_ASSERT
(
!
codeMeta
(
)
.
isAsmJS
(
)
)
;
checkOffsetAndAlignmentAndBounds
(
&
access
&
base
)
;
#
ifndef
JS_64BIT
MOZ_ASSERT
(
base
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
#
endif
MInstruction
*
load
=
MWasmLoadLaneSimd128
:
:
New
(
alloc
(
)
memoryBase
base
access
laneSize
laneIndex
src
)
;
if
(
!
load
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
load
)
;
return
load
;
}
void
storeLaneSimd128
(
uint32_t
laneSize
const
LinearMemoryAddress
<
MDefinition
*
>
&
addr
uint32_t
laneIndex
MDefinition
*
src
)
{
if
(
inDeadCode
(
)
)
{
return
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
Scalar
:
:
Simd128
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
)
;
MDefinition
*
memoryBase
=
maybeLoadMemoryBase
(
access
.
memoryIndex
(
)
)
;
MDefinition
*
base
=
addr
.
base
;
MOZ_ASSERT
(
!
codeMeta
(
)
.
isAsmJS
(
)
)
;
checkOffsetAndAlignmentAndBounds
(
&
access
&
base
)
;
#
ifndef
JS_64BIT
MOZ_ASSERT
(
base
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
#
endif
MInstruction
*
store
=
MWasmStoreLaneSimd128
:
:
New
(
alloc
(
)
memoryBase
base
access
laneSize
laneIndex
src
)
;
if
(
!
store
)
{
return
;
}
curBlock_
-
>
add
(
store
)
;
}
#
endif
MDefinition
*
loadGlobalVar
(
const
GlobalDesc
&
global
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
MInstruction
*
load
;
if
(
global
.
isIndirect
(
)
)
{
auto
*
cellPtr
=
MWasmLoadInstanceDataField
:
:
New
(
alloc
(
)
MIRType
:
:
Pointer
global
.
offset
(
)
true
instancePointer_
)
;
curBlock_
-
>
add
(
cellPtr
)
;
load
=
MWasmLoadGlobalCell
:
:
New
(
alloc
(
)
global
.
type
(
)
.
toMIRType
(
)
cellPtr
global
.
type
(
)
)
;
}
else
{
load
=
MWasmLoadInstanceDataField
:
:
New
(
alloc
(
)
global
.
type
(
)
.
toMIRType
(
)
global
.
offset
(
)
!
global
.
isMutable
(
)
instancePointer_
global
.
type
(
)
.
toMaybeRefType
(
)
)
;
}
curBlock_
-
>
add
(
load
)
;
return
load
;
}
[
[
nodiscard
]
]
bool
storeGlobalVar
(
uint32_t
lineOrBytecode
const
GlobalDesc
&
global
MDefinition
*
v
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
if
(
global
.
isIndirect
(
)
)
{
auto
*
valueAddr
=
MWasmLoadInstanceDataField
:
:
New
(
alloc
(
)
MIRType
:
:
Pointer
global
.
offset
(
)
true
instancePointer_
)
;
curBlock_
-
>
add
(
valueAddr
)
;
if
(
global
.
type
(
)
.
toMIRType
(
)
=
=
MIRType
:
:
WasmAnyRef
)
{
MOZ_ASSERT
(
v
-
>
type
(
)
=
=
MIRType
:
:
WasmAnyRef
)
;
auto
*
prevValue
=
MWasmLoadGlobalCell
:
:
New
(
alloc
(
)
MIRType
:
:
WasmAnyRef
valueAddr
global
.
type
(
)
)
;
curBlock_
-
>
add
(
prevValue
)
;
auto
*
store
=
MWasmStoreRef
:
:
New
(
alloc
(
)
instancePointer_
valueAddr
0
v
AliasSet
:
:
WasmGlobalCell
WasmPreBarrierKind
:
:
Normal
)
;
curBlock_
-
>
add
(
store
)
;
return
postBarrierEdgePrecise
(
lineOrBytecode
valueAddr
prevValue
)
;
}
auto
*
store
=
MWasmStoreGlobalCell
:
:
New
(
alloc
(
)
v
valueAddr
)
;
curBlock_
-
>
add
(
store
)
;
return
true
;
}
if
(
global
.
type
(
)
.
toMIRType
(
)
=
=
MIRType
:
:
WasmAnyRef
)
{
auto
*
valueAddr
=
MWasmDerivedPointer
:
:
New
(
alloc
(
)
instancePointer_
wasm
:
:
Instance
:
:
offsetInData
(
global
.
offset
(
)
)
)
;
curBlock_
-
>
add
(
valueAddr
)
;
MOZ_ASSERT
(
v
-
>
type
(
)
=
=
MIRType
:
:
WasmAnyRef
)
;
auto
*
prevValue
=
MWasmLoadGlobalCell
:
:
New
(
alloc
(
)
MIRType
:
:
WasmAnyRef
valueAddr
global
.
type
(
)
)
;
curBlock_
-
>
add
(
prevValue
)
;
auto
*
store
=
MWasmStoreRef
:
:
New
(
alloc
(
)
instancePointer_
valueAddr
0
v
AliasSet
:
:
WasmInstanceData
WasmPreBarrierKind
:
:
Normal
)
;
curBlock_
-
>
add
(
store
)
;
return
postBarrierEdgePrecise
(
lineOrBytecode
valueAddr
prevValue
)
;
}
auto
*
store
=
MWasmStoreInstanceDataField
:
:
New
(
alloc
(
)
global
.
offset
(
)
v
instancePointer_
)
;
curBlock_
-
>
add
(
store
)
;
return
true
;
}
MDefinition
*
loadCachedRefFunc
(
uint32_t
funcIndex
)
{
uint32_t
exportedFuncIndex
=
codeMeta
(
)
.
findFuncExportIndex
(
funcIndex
)
;
MWasmLoadInstanceDataField
*
refFunc
=
MWasmLoadInstanceDataField
:
:
New
(
alloc
(
)
MIRType
:
:
WasmAnyRef
codeMeta
(
)
.
offsetOfFuncExportInstanceData
(
exportedFuncIndex
)
+
offsetof
(
FuncExportInstanceData
func
)
true
instancePointer_
)
;
curBlock_
-
>
add
(
refFunc
)
;
return
refFunc
;
}
MDefinition
*
loadTableField
(
uint32_t
tableIndex
unsigned
fieldOffset
MIRType
type
)
{
uint32_t
instanceDataOffset
=
wasm
:
:
Instance
:
:
offsetInData
(
codeMeta
(
)
.
offsetOfTableInstanceData
(
tableIndex
)
+
fieldOffset
)
;
auto
*
load
=
MWasmLoadInstance
:
:
New
(
alloc
(
)
instancePointer_
instanceDataOffset
type
AliasSet
:
:
Load
(
AliasSet
:
:
WasmTableMeta
)
)
;
curBlock_
-
>
add
(
load
)
;
return
load
;
}
MDefinition
*
loadTableLength
(
uint32_t
tableIndex
)
{
return
loadTableField
(
tableIndex
offsetof
(
TableInstanceData
length
)
MIRType
:
:
Int32
)
;
}
MDefinition
*
loadTableElements
(
uint32_t
tableIndex
)
{
return
loadTableField
(
tableIndex
offsetof
(
TableInstanceData
elements
)
MIRType
:
:
Pointer
)
;
}
MDefinition
*
tableAddressToI32
(
AddressType
addressType
MDefinition
*
address
)
{
switch
(
addressType
)
{
case
AddressType
:
:
I32
:
return
address
;
case
AddressType
:
:
I64
:
auto
*
clamp
=
MWasmClampTable64Address
:
:
New
(
alloc
(
)
address
)
;
if
(
!
clamp
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
clamp
)
;
return
clamp
;
}
MOZ_CRASH
(
"
unknown
address
type
"
)
;
}
MDefinition
*
tableGetAnyRef
(
uint32_t
tableIndex
MDefinition
*
address
)
{
const
TableDesc
&
table
=
codeMeta
(
)
.
tables
[
tableIndex
]
;
auto
*
length
=
loadTableLength
(
tableIndex
)
;
auto
*
check
=
MWasmBoundsCheck
:
:
New
(
alloc
(
)
address
length
trapSiteDesc
(
)
MWasmBoundsCheck
:
:
Unknown
)
;
curBlock_
-
>
add
(
check
)
;
if
(
JitOptions
.
spectreIndexMasking
)
{
address
=
check
;
}
auto
*
elements
=
loadTableElements
(
tableIndex
)
;
auto
*
element
=
MWasmLoadTableElement
:
:
New
(
alloc
(
)
elements
address
table
.
elemType
)
;
curBlock_
-
>
add
(
element
)
;
return
element
;
}
[
[
nodiscard
]
]
bool
tableSetAnyRef
(
uint32_t
tableIndex
MDefinition
*
address
MDefinition
*
value
uint32_t
lineOrBytecode
)
{
const
TableDesc
&
table
=
codeMeta
(
)
.
tables
[
tableIndex
]
;
auto
*
length
=
loadTableLength
(
tableIndex
)
;
auto
*
check
=
MWasmBoundsCheck
:
:
New
(
alloc
(
)
address
length
trapSiteDesc
(
)
MWasmBoundsCheck
:
:
Unknown
)
;
curBlock_
-
>
add
(
check
)
;
if
(
JitOptions
.
spectreIndexMasking
)
{
address
=
check
;
}
auto
*
elements
=
loadTableElements
(
tableIndex
)
;
auto
*
prevValue
=
MWasmLoadTableElement
:
:
New
(
alloc
(
)
elements
address
table
.
elemType
)
;
curBlock_
-
>
add
(
prevValue
)
;
auto
*
loc
=
MWasmDerivedIndexPointer
:
:
New
(
alloc
(
)
elements
address
ScalePointer
)
;
curBlock_
-
>
add
(
loc
)
;
auto
*
store
=
MWasmStoreRef
:
:
New
(
alloc
(
)
instancePointer_
loc
0
value
AliasSet
:
:
WasmTableElement
WasmPreBarrierKind
:
:
Normal
)
;
curBlock_
-
>
add
(
store
)
;
return
postBarrierEdgePrecise
(
lineOrBytecode
loc
prevValue
)
;
}
void
addInterruptCheck
(
)
{
if
(
inDeadCode
(
)
)
{
return
;
}
curBlock_
-
>
add
(
MWasmInterruptCheck
:
:
New
(
alloc
(
)
instancePointer_
trapSiteDesc
(
)
)
)
;
}
[
[
nodiscard
]
]
bool
postBarrierWholeCell
(
uint32_t
lineOrBytecode
MDefinition
*
object
MDefinition
*
newValue
)
{
auto
*
barrier
=
MWasmPostWriteBarrierWholeCell
:
:
New
(
alloc
(
)
instancePointer_
object
newValue
)
;
if
(
!
barrier
)
{
return
false
;
}
curBlock_
-
>
add
(
barrier
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
postBarrierEdgePrecise
(
uint32_t
lineOrBytecode
MDefinition
*
valueAddr
MDefinition
*
value
)
{
return
emitInstanceCall2
(
lineOrBytecode
SASigPostBarrierEdgePrecise
valueAddr
value
)
;
}
[
[
nodiscard
]
]
bool
postBarrierEdgeAtIndex
(
uint32_t
lineOrBytecode
MDefinition
*
object
MDefinition
*
valueBase
MDefinition
*
index
uint32_t
scale
MDefinition
*
newValue
)
{
auto
*
barrier
=
MWasmPostWriteBarrierEdgeAtIndex
:
:
New
(
alloc
(
)
instancePointer_
object
valueBase
index
scale
newValue
)
;
if
(
!
barrier
)
{
return
false
;
}
curBlock_
-
>
add
(
barrier
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
passInstanceCallArg
(
MIRType
instanceType
CallCompileState
*
callState
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
callState
-
>
instanceArg
=
=
ABIArg
(
)
)
;
MOZ_ASSERT
(
instanceType
=
=
MIRType
:
:
Pointer
)
;
callState
-
>
instanceArg
=
callState
-
>
abi
.
next
(
MIRType
:
:
Pointer
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
passCallArgWorker
(
MDefinition
*
argDef
MIRType
type
CallCompileState
*
callState
)
{
MOZ_ASSERT
(
argDef
-
>
type
(
)
=
=
type
)
;
if
(
!
callState
-
>
hardFP
&
&
(
type
=
=
MIRType
:
:
Double
|
|
type
=
=
MIRType
:
:
Float32
)
)
{
MIRType
softType
=
(
type
=
=
MIRType
:
:
Double
)
?
MIRType
:
:
Int64
:
MIRType
:
:
Int32
;
auto
*
softDef
=
MReinterpretCast
:
:
New
(
alloc
(
)
argDef
softType
)
;
if
(
!
softDef
)
{
return
false
;
}
curBlock_
-
>
add
(
softDef
)
;
argDef
=
softDef
;
}
ABIArg
arg
=
callState
-
>
abi
.
next
(
type
)
;
switch
(
arg
.
kind
(
)
)
{
#
ifdef
JS_CODEGEN_REGISTER_PAIR
case
ABIArg
:
:
GPR_PAIR
:
{
auto
mirLow
=
MWrapInt64ToInt32
:
:
New
(
alloc
(
)
argDef
true
)
;
curBlock_
-
>
add
(
mirLow
)
;
auto
mirHigh
=
MWrapInt64ToInt32
:
:
New
(
alloc
(
)
argDef
false
)
;
curBlock_
-
>
add
(
mirHigh
)
;
return
callState
-
>
regArgs
.
append
(
MWasmCallBase
:
:
Arg
(
AnyRegister
(
arg
.
gpr64
(
)
.
low
)
mirLow
)
)
&
&
callState
-
>
regArgs
.
append
(
MWasmCallBase
:
:
Arg
(
AnyRegister
(
arg
.
gpr64
(
)
.
high
)
mirHigh
)
)
;
}
#
endif
case
ABIArg
:
:
GPR
:
case
ABIArg
:
:
FPU
:
return
callState
-
>
regArgs
.
append
(
MWasmCallBase
:
:
Arg
(
arg
.
reg
(
)
argDef
)
)
;
case
ABIArg
:
:
Stack
:
{
auto
*
mir
=
MWasmStackArg
:
:
New
(
alloc
(
)
arg
.
offsetFromArgBase
(
)
argDef
)
;
curBlock_
-
>
add
(
mir
)
;
return
true
;
}
case
ABIArg
:
:
Uninitialized
:
MOZ_ASSERT_UNREACHABLE
(
"
Uninitialized
ABIArg
kind
"
)
;
}
MOZ_CRASH
(
"
Unknown
ABIArg
kind
.
"
)
;
}
template
<
typename
VecT
>
[
[
nodiscard
]
]
bool
passCallArgs
(
const
DefVector
&
argDefs
const
VecT
&
types
CallCompileState
*
callState
)
{
MOZ_ASSERT
(
argDefs
.
length
(
)
=
=
types
.
length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
argDefs
.
length
(
)
;
i
+
+
)
{
MDefinition
*
def
=
argDefs
[
i
]
;
ValType
type
=
types
[
i
]
;
if
(
!
passCallArg
(
def
type
callState
)
)
{
return
false
;
}
}
return
true
;
}
[
[
nodiscard
]
]
bool
passCallArg
(
MDefinition
*
argDef
MIRType
type
CallCompileState
*
callState
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
return
passCallArgWorker
(
argDef
type
callState
)
;
}
[
[
nodiscard
]
]
bool
passCallArg
(
MDefinition
*
argDef
ValType
type
CallCompileState
*
callState
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
return
passCallArgWorker
(
argDef
type
.
toMIRType
(
)
callState
)
;
}
[
[
nodiscard
]
]
bool
passStackResultAreaCallArg
(
const
ResultType
&
resultType
CallCompileState
*
callState
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
ABIResultIter
iter
(
resultType
)
;
while
(
!
iter
.
done
(
)
&
&
iter
.
cur
(
)
.
inRegister
(
)
)
{
iter
.
next
(
)
;
}
if
(
iter
.
done
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
callState
-
>
abiKind
=
=
ABIKind
:
:
Wasm
)
;
auto
*
stackResultArea
=
MWasmStackResultArea
:
:
New
(
alloc
(
)
)
;
if
(
!
stackResultArea
)
{
return
false
;
}
if
(
!
stackResultArea
-
>
init
(
alloc
(
)
iter
.
remaining
(
)
)
)
{
return
false
;
}
for
(
uint32_t
base
=
iter
.
index
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
MWasmStackResultArea
:
:
StackResult
loc
(
iter
.
cur
(
)
.
stackOffset
(
)
iter
.
cur
(
)
.
type
(
)
.
toMIRType
(
)
)
;
stackResultArea
-
>
initResult
(
iter
.
index
(
)
-
base
loc
)
;
}
curBlock_
-
>
add
(
stackResultArea
)
;
MDefinition
*
def
=
callState
-
>
returnCall
?
(
MDefinition
*
)
stackResultPointer_
:
(
MDefinition
*
)
stackResultArea
;
if
(
!
passCallArg
(
def
MIRType
:
:
StackResults
callState
)
)
{
return
false
;
}
callState
-
>
stackResultArea
=
stackResultArea
;
return
true
;
}
[
[
nodiscard
]
]
bool
finishCallArgs
(
CallCompileState
*
callState
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
if
(
!
callState
-
>
regArgs
.
append
(
MWasmCallBase
:
:
Arg
(
AnyRegister
(
InstanceReg
)
instancePointer_
)
)
)
{
return
false
;
}
uint32_t
stackBytes
=
callState
-
>
abi
.
stackBytesConsumedSoFar
(
)
;
maxStackArgBytes_
=
std
:
:
max
(
maxStackArgBytes_
stackBytes
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
emitCallArgs
(
const
FuncType
&
funcType
const
DefVector
&
args
CallCompileState
*
callState
)
{
for
(
size_t
i
=
0
n
=
funcType
.
args
(
)
.
length
(
)
;
i
<
n
;
+
+
i
)
{
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
if
(
!
passCallArg
(
args
[
i
]
funcType
.
args
(
)
[
i
]
callState
)
)
{
return
false
;
}
}
ResultType
resultType
=
ResultType
:
:
Vector
(
funcType
.
results
(
)
)
;
if
(
!
passStackResultAreaCallArg
(
resultType
callState
)
)
{
return
false
;
}
return
finishCallArgs
(
callState
)
;
}
[
[
nodiscard
]
]
bool
collectBuiltinCallResult
(
MIRType
type
MDefinition
*
*
result
CallCompileState
*
callState
)
{
MOZ_ASSERT
(
callState
-
>
abiKind
=
=
ABIKind
:
:
System
)
;
MInstruction
*
def
;
switch
(
type
)
{
case
MIRType
:
:
Int32
:
def
=
MWasmRegisterResult
:
:
New
(
alloc
(
)
MIRType
:
:
Int32
ReturnReg
)
;
break
;
case
MIRType
:
:
Int64
:
def
=
MWasmRegister64Result
:
:
New
(
alloc
(
)
ReturnReg64
)
;
break
;
case
MIRType
:
:
Float32
:
def
=
MWasmBuiltinFloatRegisterResult
:
:
New
(
alloc
(
)
type
ReturnFloat32Reg
callState
-
>
hardFP
)
;
break
;
case
MIRType
:
:
Double
:
def
=
MWasmBuiltinFloatRegisterResult
:
:
New
(
alloc
(
)
type
ReturnDoubleReg
callState
-
>
hardFP
)
;
break
;
#
ifdef
ENABLE_WASM_SIMD
case
MIRType
:
:
Simd128
:
MOZ_CRASH
(
"
SIMD128
not
supported
in
builtin
ABI
"
)
;
#
endif
case
MIRType
:
:
WasmAnyRef
:
def
=
MWasmRegisterResult
:
:
New
(
alloc
(
)
MIRType
:
:
WasmAnyRef
ReturnReg
)
;
break
;
case
MIRType
:
:
None
:
MOZ_ASSERT
(
result
=
=
nullptr
"
Not
expecting
any
results
created
"
)
;
return
true
;
default
:
MOZ_CRASH
(
"
unexpected
MIRType
result
for
builtin
call
"
)
;
}
if
(
!
def
)
{
return
false
;
}
curBlock_
-
>
add
(
def
)
;
*
result
=
def
;
return
true
;
}
[
[
nodiscard
]
]
bool
collectWasmCallResults
(
const
ResultType
&
type
CallCompileState
*
callState
DefVector
*
results
)
{
MOZ_ASSERT
(
callState
-
>
abiKind
=
=
ABIKind
:
:
Wasm
)
;
MOZ_ASSERT
(
callState
-
>
hardFP
)
;
if
(
!
results
-
>
reserve
(
type
.
length
(
)
)
)
{
return
false
;
}
ABIResultIter
iter
(
type
)
;
uint32_t
stackResultCount
=
0
;
while
(
!
iter
.
done
(
)
)
{
if
(
iter
.
cur
(
)
.
onStack
(
)
)
{
stackResultCount
+
+
;
}
iter
.
next
(
)
;
}
for
(
iter
.
switchToPrev
(
)
;
!
iter
.
done
(
)
;
iter
.
prev
(
)
)
{
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
const
ABIResult
&
result
=
iter
.
cur
(
)
;
MInstruction
*
def
;
if
(
result
.
inRegister
(
)
)
{
switch
(
result
.
type
(
)
.
kind
(
)
)
{
case
wasm
:
:
ValType
:
:
I32
:
def
=
MWasmRegisterResult
:
:
New
(
alloc
(
)
MIRType
:
:
Int32
result
.
gpr
(
)
)
;
break
;
case
wasm
:
:
ValType
:
:
I64
:
def
=
MWasmRegister64Result
:
:
New
(
alloc
(
)
result
.
gpr64
(
)
)
;
break
;
case
wasm
:
:
ValType
:
:
F32
:
def
=
MWasmFloatRegisterResult
:
:
New
(
alloc
(
)
MIRType
:
:
Float32
result
.
fpr
(
)
)
;
break
;
case
wasm
:
:
ValType
:
:
F64
:
def
=
MWasmFloatRegisterResult
:
:
New
(
alloc
(
)
MIRType
:
:
Double
result
.
fpr
(
)
)
;
break
;
case
wasm
:
:
ValType
:
:
Ref
:
def
=
MWasmRegisterResult
:
:
New
(
alloc
(
)
MIRType
:
:
WasmAnyRef
result
.
gpr
(
)
result
.
type
(
)
.
toMaybeRefType
(
)
)
;
break
;
case
wasm
:
:
ValType
:
:
V128
:
#
ifdef
ENABLE_WASM_SIMD
def
=
MWasmFloatRegisterResult
:
:
New
(
alloc
(
)
MIRType
:
:
Simd128
result
.
fpr
(
)
)
;
#
else
return
this
-
>
iter
(
)
.
fail
(
"
Ion
has
no
SIMD
support
yet
"
)
;
#
endif
}
}
else
{
MOZ_ASSERT
(
callState
-
>
stackResultArea
)
;
MOZ_ASSERT
(
stackResultCount
)
;
uint32_t
idx
=
-
-
stackResultCount
;
def
=
MWasmStackResult
:
:
New
(
alloc
(
)
callState
-
>
stackResultArea
idx
)
;
}
if
(
!
def
)
{
return
false
;
}
curBlock_
-
>
add
(
def
)
;
results
-
>
infallibleAppend
(
def
)
;
}
MOZ_ASSERT
(
results
-
>
length
(
)
=
=
type
.
length
(
)
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
call
(
CallCompileState
*
callState
const
CallSiteDesc
&
desc
const
CalleeDesc
&
callee
const
ArgTypeVector
&
argTypes
MDefinition
*
addressOrRef
=
nullptr
)
{
if
(
!
beginCatchableCall
(
callState
)
)
{
return
false
;
}
MInstruction
*
ins
;
if
(
callState
-
>
isCatchable
(
)
)
{
ins
=
MWasmCallCatchable
:
:
New
(
alloc
(
)
desc
callee
callState
-
>
regArgs
StackArgAreaSizeUnaligned
(
argTypes
callState
-
>
abiKind
)
callState
-
>
tryNoteIndex
callState
-
>
fallthroughBlock
callState
-
>
prePadBlock
addressOrRef
)
;
}
else
{
ins
=
MWasmCallUncatchable
:
:
New
(
alloc
(
)
desc
callee
callState
-
>
regArgs
StackArgAreaSizeUnaligned
(
argTypes
callState
-
>
abiKind
)
addressOrRef
)
;
}
if
(
!
ins
)
{
return
false
;
}
curBlock_
-
>
add
(
ins
)
;
return
finishCatchableCall
(
callState
)
;
}
[
[
nodiscard
]
]
CallRefHint
auditInlineableCallees
(
InliningHeuristics
:
:
CallKind
kind
CallRefHint
hints
)
{
MOZ_ASSERT_IF
(
kind
=
=
InliningHeuristics
:
:
CallKind
:
:
Direct
hints
.
length
(
)
=
=
1
)
;
if
(
compilerEnv
(
)
.
mode
(
)
!
=
CompileMode
:
:
LazyTiering
)
{
return
CallRefHint
(
)
;
}
MOZ_ASSERT
(
!
codeMeta
(
)
.
isAsmJS
(
)
)
;
if
(
hints
.
empty
(
)
)
{
return
CallRefHint
(
)
;
}
if
(
rootCompiler_
.
inliningBudget
(
)
<
0
)
{
return
CallRefHint
(
)
;
}
CallRefHint
filtered
;
for
(
uint32_t
i
=
0
;
i
<
hints
.
length
(
)
;
i
+
+
)
{
uint32_t
funcIndex
=
hints
.
get
(
i
)
;
if
(
codeMeta
(
)
.
funcIsImport
(
funcIndex
)
)
{
continue
;
}
FeatureUsage
funcFeatureUsage
=
codeTailMeta
(
)
-
>
funcDefFeatureUsage
(
funcIndex
)
;
if
(
funcFeatureUsage
&
FeatureUsage
:
:
ReturnCall
)
{
continue
;
}
uint32_t
inlineeBodySize
=
codeTailMeta
(
)
-
>
funcDefRange
(
funcIndex
)
.
size
;
uint32_t
rootFunctionBodySize
=
rootCompiler_
.
func
(
)
.
bytecodeSize
(
)
;
bool
largeFunctionBackoff
;
bool
smallEnough
=
InliningHeuristics
:
:
isSmallEnoughToInline
(
kind
inliningDepth
(
)
inlineeBodySize
rootFunctionBodySize
&
largeFunctionBackoff
)
;
if
(
largeFunctionBackoff
)
{
rootCompiler_
.
noteLargeFunctionBackoffWasApplied
(
)
;
}
if
(
!
smallEnough
)
{
continue
;
}
filtered
.
append
(
funcIndex
)
;
}
return
filtered
;
}
[
[
nodiscard
]
]
bool
finishInlinedCallDirect
(
FunctionCompiler
&
calleeCompiler
DefVector
*
results
)
{
const
PendingInlineReturnVector
&
calleeReturns
=
calleeCompiler
.
pendingInlineReturns_
;
MBasicBlock
*
calleeCatchBlock
=
calleeCompiler
.
pendingInlineCatchBlock_
;
const
FuncType
&
calleeFuncType
=
calleeCompiler
.
funcType
(
)
;
MBasicBlock
*
lastBlockBeforeCall
=
curBlock_
;
iter_
.
addFeatureUsage
(
calleeCompiler
.
featureUsage
(
)
)
;
if
(
calleeCatchBlock
)
{
ControlInstructionVector
*
tryLandingPadPatches
;
bool
inTryCode
=
inTryBlock
(
&
tryLandingPadPatches
)
;
MOZ_RELEASE_ASSERT
(
inTryCode
)
;
MBasicBlock
*
callerCatchBlock
=
nullptr
;
if
(
!
newBlock
(
nullptr
&
callerCatchBlock
)
)
{
return
false
;
}
callerCatchBlock
-
>
inheritSlots
(
lastBlockBeforeCall
)
;
calleeCatchBlock
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
callerCatchBlock
)
)
;
if
(
!
callerCatchBlock
-
>
addPredecessorWithoutPhis
(
calleeCatchBlock
)
)
{
return
false
;
}
MBasicBlock
*
prevBlock
=
curBlock_
;
curBlock_
=
callerCatchBlock
;
if
(
!
endWithPadPatch
(
tryLandingPadPatches
)
)
{
return
false
;
}
curBlock_
=
prevBlock
;
}
if
(
calleeReturns
.
empty
(
)
)
{
curBlock_
=
nullptr
;
return
true
;
}
MBasicBlock
*
joinAfterCall
=
nullptr
;
if
(
!
newBlock
(
nullptr
&
joinAfterCall
)
)
{
return
false
;
}
joinAfterCall
-
>
inheritSlots
(
lastBlockBeforeCall
)
;
for
(
uint32_t
i
=
0
;
i
<
calleeFuncType
.
results
(
)
.
length
(
)
;
i
+
+
)
{
MPhi
*
phi
=
MPhi
:
:
New
(
alloc
(
)
calleeFuncType
.
results
(
)
[
i
]
.
toMIRType
(
)
)
;
if
(
!
phi
|
|
!
phi
-
>
reserveLength
(
calleeReturns
.
length
(
)
)
)
{
return
false
;
}
joinAfterCall
-
>
addPhi
(
phi
)
;
if
(
!
results
-
>
append
(
phi
)
)
{
return
false
;
}
}
for
(
size_t
i
=
0
;
i
<
calleeReturns
.
length
(
)
;
i
+
+
)
{
const
PendingInlineReturn
&
calleeReturn
=
calleeReturns
[
i
]
;
MBasicBlock
*
pred
=
calleeReturn
.
jump
-
>
block
(
)
;
if
(
!
joinAfterCall
-
>
addPredecessorWithoutPhis
(
pred
)
)
{
return
false
;
}
calleeReturn
.
jump
-
>
replaceSuccessor
(
MGoto
:
:
TargetIndex
joinAfterCall
)
;
for
(
uint32_t
resultIndex
=
0
;
resultIndex
<
calleeFuncType
.
results
(
)
.
length
(
)
;
resultIndex
+
+
)
{
MDefinition
*
result
=
(
*
results
)
[
resultIndex
]
;
(
(
MPhi
*
)
(
result
)
)
-
>
addInput
(
calleeReturn
.
results
[
resultIndex
]
)
;
}
}
curBlock_
=
joinAfterCall
;
return
true
;
}
[
[
nodiscard
]
]
bool
callDirect
(
const
FuncType
&
funcType
uint32_t
funcIndex
uint32_t
lineOrBytecode
const
DefVector
&
args
DefVector
*
results
)
{
MOZ_ASSERT
(
!
inDeadCode
(
)
)
;
CallCompileState
callState
(
ABIKind
:
:
Wasm
)
;
CallSiteDesc
desc
(
lineOrBytecode
rootCompiler_
.
inlinedCallerOffsetsIndex
(
)
CallSiteKind
:
:
Func
)
;
ResultType
resultType
=
ResultType
:
:
Vector
(
funcType
.
results
(
)
)
;
auto
callee
=
CalleeDesc
:
:
function
(
funcIndex
)
;
ArgTypeVector
argTypes
(
funcType
)
;
return
emitCallArgs
(
funcType
args
&
callState
)
&
&
call
(
&
callState
desc
callee
argTypes
)
&
&
collectWasmCallResults
(
resultType
&
callState
results
)
;
}
[
[
nodiscard
]
]
bool
returnCallDirect
(
const
FuncType
&
funcType
uint32_t
funcIndex
uint32_t
lineOrBytecode
const
DefVector
&
args
DefVector
*
results
)
{
MOZ_ASSERT
(
!
inDeadCode
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
isInlined
(
)
)
;
CallCompileState
callState
(
ABIKind
:
:
Wasm
)
;
callState
.
returnCall
=
true
;
CallSiteDesc
desc
(
lineOrBytecode
CallSiteKind
:
:
ReturnFunc
)
;
auto
callee
=
CalleeDesc
:
:
function
(
funcIndex
)
;
ArgTypeVector
argTypes
(
funcType
)
;
if
(
!
emitCallArgs
(
funcType
args
&
callState
)
)
{
return
false
;
}
auto
ins
=
MWasmReturnCall
:
:
New
(
alloc
(
)
desc
callee
callState
.
regArgs
StackArgAreaSizeUnaligned
(
argTypes
callState
.
abiKind
)
nullptr
)
;
if
(
!
ins
)
{
return
false
;
}
curBlock_
-
>
end
(
ins
)
;
curBlock_
=
nullptr
;
return
true
;
}
[
[
nodiscard
]
]
bool
returnCallImport
(
unsigned
globalDataOffset
uint32_t
lineOrBytecode
const
FuncType
&
funcType
const
DefVector
&
args
DefVector
*
results
)
{
MOZ_ASSERT
(
!
inDeadCode
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
isInlined
(
)
)
;
CallCompileState
callState
(
ABIKind
:
:
Wasm
)
;
callState
.
returnCall
=
true
;
CallSiteDesc
desc
(
lineOrBytecode
CallSiteKind
:
:
Import
)
;
auto
callee
=
CalleeDesc
:
:
import
(
globalDataOffset
)
;
ArgTypeVector
argTypes
(
funcType
)
;
if
(
!
emitCallArgs
(
funcType
args
&
callState
)
)
{
return
false
;
}
auto
*
ins
=
MWasmReturnCall
:
:
New
(
alloc
(
)
desc
callee
callState
.
regArgs
StackArgAreaSizeUnaligned
(
argTypes
callState
.
abiKind
)
nullptr
)
;
if
(
!
ins
)
{
return
false
;
}
curBlock_
-
>
end
(
ins
)
;
curBlock_
=
nullptr
;
return
true
;
}
[
[
nodiscard
]
]
bool
returnCallIndirect
(
uint32_t
funcTypeIndex
uint32_t
tableIndex
MDefinition
*
address
uint32_t
lineOrBytecode
const
DefVector
&
args
DefVector
*
results
)
{
MOZ_ASSERT
(
!
inDeadCode
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
isInlined
(
)
)
;
const
FuncType
&
funcType
=
(
*
codeMeta
(
)
.
types
)
[
funcTypeIndex
]
.
funcType
(
)
;
CallIndirectId
callIndirectId
=
CallIndirectId
:
:
forFuncType
(
codeMeta
(
)
funcTypeIndex
)
;
CallCompileState
callState
(
ABIKind
:
:
Wasm
)
;
callState
.
returnCall
=
true
;
CalleeDesc
callee
;
MOZ_ASSERT
(
callIndirectId
.
kind
(
)
!
=
CallIndirectIdKind
:
:
AsmJS
)
;
const
TableDesc
&
table
=
codeMeta
(
)
.
tables
[
tableIndex
]
;
callee
=
CalleeDesc
:
:
wasmTable
(
codeMeta
(
)
table
tableIndex
callIndirectId
)
;
CallSiteDesc
desc
(
lineOrBytecode
CallSiteKind
:
:
Indirect
)
;
ArgTypeVector
argTypes
(
funcType
)
;
if
(
!
emitCallArgs
(
funcType
args
&
callState
)
)
{
return
false
;
}
MDefinition
*
address32
=
tableAddressToI32
(
table
.
addressType
(
)
address
)
;
if
(
!
address32
)
{
return
false
;
}
auto
*
ins
=
MWasmReturnCall
:
:
New
(
alloc
(
)
desc
callee
callState
.
regArgs
StackArgAreaSizeUnaligned
(
argTypes
callState
.
abiKind
)
address32
)
;
if
(
!
ins
)
{
return
false
;
}
curBlock_
-
>
end
(
ins
)
;
curBlock_
=
nullptr
;
return
true
;
}
[
[
nodiscard
]
]
bool
callIndirect
(
uint32_t
funcTypeIndex
uint32_t
tableIndex
MDefinition
*
address
uint32_t
lineOrBytecode
const
DefVector
&
args
DefVector
*
results
)
{
MOZ_ASSERT
(
!
inDeadCode
(
)
)
;
CallCompileState
callState
(
ABIKind
:
:
Wasm
)
;
const
FuncType
&
funcType
=
(
*
codeMeta
(
)
.
types
)
[
funcTypeIndex
]
.
funcType
(
)
;
CallIndirectId
callIndirectId
=
CallIndirectId
:
:
forFuncType
(
codeMeta
(
)
funcTypeIndex
)
;
CalleeDesc
callee
;
if
(
codeMeta
(
)
.
isAsmJS
(
)
)
{
MOZ_ASSERT
(
tableIndex
=
=
0
)
;
MOZ_ASSERT
(
callIndirectId
.
kind
(
)
=
=
CallIndirectIdKind
:
:
AsmJS
)
;
uint32_t
tableIndex
=
codeMeta
(
)
.
asmJSSigToTableIndex
[
funcTypeIndex
]
;
const
TableDesc
&
table
=
codeMeta
(
)
.
tables
[
tableIndex
]
;
MOZ_ASSERT
(
table
.
initialLength
(
)
<
=
UINT32_MAX
)
;
MOZ_ASSERT
(
IsPowerOfTwo
(
table
.
initialLength
(
)
)
)
;
MDefinition
*
mask
=
constantI32
(
int32_t
(
table
.
initialLength
(
)
-
1
)
)
;
MBitAnd
*
maskedAddress
=
MBitAnd
:
:
New
(
alloc
(
)
address
mask
MIRType
:
:
Int32
)
;
curBlock_
-
>
add
(
maskedAddress
)
;
address
=
maskedAddress
;
callee
=
CalleeDesc
:
:
asmJSTable
(
codeMeta
(
)
tableIndex
)
;
}
else
{
MOZ_ASSERT
(
callIndirectId
.
kind
(
)
!
=
CallIndirectIdKind
:
:
AsmJS
)
;
const
TableDesc
&
table
=
codeMeta
(
)
.
tables
[
tableIndex
]
;
callee
=
CalleeDesc
:
:
wasmTable
(
codeMeta
(
)
table
tableIndex
callIndirectId
)
;
address
=
tableAddressToI32
(
table
.
addressType
(
)
address
)
;
if
(
!
address
)
{
return
false
;
}
}
CallSiteDesc
desc
(
lineOrBytecode
rootCompiler_
.
inlinedCallerOffsetsIndex
(
)
CallSiteKind
:
:
Indirect
)
;
ArgTypeVector
argTypes
(
funcType
)
;
ResultType
resultType
=
ResultType
:
:
Vector
(
funcType
.
results
(
)
)
;
return
emitCallArgs
(
funcType
args
&
callState
)
&
&
call
(
&
callState
desc
callee
argTypes
address
)
&
&
collectWasmCallResults
(
resultType
&
callState
results
)
;
}
[
[
nodiscard
]
]
bool
callImport
(
unsigned
instanceDataOffset
uint32_t
lineOrBytecode
const
FuncType
&
funcType
const
DefVector
&
args
DefVector
*
results
)
{
MOZ_ASSERT
(
!
inDeadCode
(
)
)
;
CallCompileState
callState
(
ABIKind
:
:
Wasm
)
;
CallSiteDesc
desc
(
lineOrBytecode
rootCompiler_
.
inlinedCallerOffsetsIndex
(
)
CallSiteKind
:
:
Import
)
;
auto
callee
=
CalleeDesc
:
:
import
(
instanceDataOffset
)
;
ArgTypeVector
argTypes
(
funcType
)
;
ResultType
resultType
=
ResultType
:
:
Vector
(
funcType
.
results
(
)
)
;
return
emitCallArgs
(
funcType
args
&
callState
)
&
&
call
(
&
callState
desc
callee
argTypes
)
&
&
collectWasmCallResults
(
resultType
&
callState
results
)
;
}
[
[
nodiscard
]
]
bool
builtinCall
(
CallCompileState
*
callState
const
SymbolicAddressSignature
&
builtin
uint32_t
lineOrBytecode
MDefinition
*
*
result
)
{
if
(
inDeadCode
(
)
)
{
*
result
=
nullptr
;
return
true
;
}
MOZ_ASSERT
(
builtin
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
CallSiteDesc
desc
(
lineOrBytecode
rootCompiler_
.
inlinedCallerOffsetsIndex
(
)
CallSiteKind
:
:
Symbolic
)
;
auto
callee
=
CalleeDesc
:
:
builtin
(
builtin
.
identity
)
;
auto
*
ins
=
MWasmCallUncatchable
:
:
New
(
alloc
(
)
desc
callee
callState
-
>
regArgs
StackArgAreaSizeUnaligned
(
builtin
callState
-
>
abiKind
)
)
;
if
(
!
ins
)
{
return
false
;
}
curBlock_
-
>
add
(
ins
)
;
return
collectBuiltinCallResult
(
builtin
.
retType
result
callState
)
;
}
[
[
nodiscard
]
]
bool
builtinCall1
(
const
SymbolicAddressSignature
&
builtin
uint32_t
lineOrBytecode
MDefinition
*
arg
MDefinition
*
*
result
)
{
CallCompileState
callState
(
ABIKind
:
:
System
)
;
return
passCallArg
(
arg
builtin
.
argTypes
[
0
]
&
callState
)
&
&
finishCallArgs
(
&
callState
)
&
&
builtinCall
(
&
callState
builtin
lineOrBytecode
result
)
;
}
[
[
nodiscard
]
]
bool
builtinCall2
(
const
SymbolicAddressSignature
&
builtin
uint32_t
lineOrBytecode
MDefinition
*
arg1
MDefinition
*
arg2
MDefinition
*
*
result
)
{
CallCompileState
callState
(
ABIKind
:
:
System
)
;
return
passCallArg
(
arg1
builtin
.
argTypes
[
0
]
&
callState
)
&
&
passCallArg
(
arg2
builtin
.
argTypes
[
1
]
&
callState
)
&
&
finishCallArgs
(
&
callState
)
&
&
builtinCall
(
&
callState
builtin
lineOrBytecode
result
)
;
}
[
[
nodiscard
]
]
bool
builtinCall5
(
const
SymbolicAddressSignature
&
builtin
uint32_t
lineOrBytecode
MDefinition
*
arg1
MDefinition
*
arg2
MDefinition
*
arg3
MDefinition
*
arg4
MDefinition
*
arg5
MDefinition
*
*
result
)
{
CallCompileState
callState
(
ABIKind
:
:
System
)
;
return
passCallArg
(
arg1
builtin
.
argTypes
[
0
]
&
callState
)
&
&
passCallArg
(
arg2
builtin
.
argTypes
[
1
]
&
callState
)
&
&
passCallArg
(
arg3
builtin
.
argTypes
[
2
]
&
callState
)
&
&
passCallArg
(
arg4
builtin
.
argTypes
[
3
]
&
callState
)
&
&
passCallArg
(
arg5
builtin
.
argTypes
[
4
]
&
callState
)
&
&
finishCallArgs
(
&
callState
)
&
&
builtinCall
(
&
callState
builtin
lineOrBytecode
result
)
;
}
[
[
nodiscard
]
]
bool
builtinCall6
(
const
SymbolicAddressSignature
&
builtin
uint32_t
lineOrBytecode
MDefinition
*
arg1
MDefinition
*
arg2
MDefinition
*
arg3
MDefinition
*
arg4
MDefinition
*
arg5
MDefinition
*
arg6
MDefinition
*
*
result
)
{
CallCompileState
callState
(
ABIKind
:
:
System
)
;
return
passCallArg
(
arg1
builtin
.
argTypes
[
0
]
&
callState
)
&
&
passCallArg
(
arg2
builtin
.
argTypes
[
1
]
&
callState
)
&
&
passCallArg
(
arg3
builtin
.
argTypes
[
2
]
&
callState
)
&
&
passCallArg
(
arg4
builtin
.
argTypes
[
3
]
&
callState
)
&
&
passCallArg
(
arg5
builtin
.
argTypes
[
4
]
&
callState
)
&
&
passCallArg
(
arg6
builtin
.
argTypes
[
5
]
&
callState
)
&
&
finishCallArgs
(
&
callState
)
&
&
builtinCall
(
&
callState
builtin
lineOrBytecode
result
)
;
}
[
[
nodiscard
]
]
bool
instanceCall
(
CallCompileState
*
callState
const
SymbolicAddressSignature
&
builtin
uint32_t
lineOrBytecode
MDefinition
*
*
result
=
nullptr
)
{
MOZ_ASSERT_IF
(
!
result
builtin
.
retType
=
=
MIRType
:
:
None
)
;
if
(
inDeadCode
(
)
)
{
if
(
result
)
{
*
result
=
nullptr
;
}
return
true
;
}
CallSiteDesc
desc
(
lineOrBytecode
rootCompiler_
.
inlinedCallerOffsetsIndex
(
)
CallSiteKind
:
:
Symbolic
)
;
if
(
builtin
.
failureMode
!
=
FailureMode
:
:
Infallible
&
&
!
beginCatchableCall
(
callState
)
)
{
return
false
;
}
MInstruction
*
ins
;
if
(
callState
-
>
isCatchable
(
)
)
{
ins
=
MWasmCallCatchable
:
:
NewBuiltinInstanceMethodCall
(
alloc
(
)
desc
builtin
.
identity
builtin
.
failureMode
builtin
.
failureTrap
callState
-
>
instanceArg
callState
-
>
regArgs
StackArgAreaSizeUnaligned
(
builtin
callState
-
>
abiKind
)
callState
-
>
tryNoteIndex
callState
-
>
fallthroughBlock
callState
-
>
prePadBlock
)
;
}
else
{
ins
=
MWasmCallUncatchable
:
:
NewBuiltinInstanceMethodCall
(
alloc
(
)
desc
builtin
.
identity
builtin
.
failureMode
builtin
.
failureTrap
callState
-
>
instanceArg
callState
-
>
regArgs
StackArgAreaSizeUnaligned
(
builtin
callState
-
>
abiKind
)
)
;
}
if
(
!
ins
)
{
return
false
;
}
curBlock_
-
>
add
(
ins
)
;
if
(
!
finishCatchableCall
(
callState
)
)
{
return
false
;
}
if
(
!
result
)
{
return
true
;
}
return
collectBuiltinCallResult
(
builtin
.
retType
result
callState
)
;
}
[
[
nodiscard
]
]
bool
emitInstanceCallN
(
uint32_t
lineOrBytecode
const
SymbolicAddressSignature
&
callee
MDefinition
*
*
args
size_t
numArgs
MDefinition
*
*
result
=
nullptr
)
{
MOZ_ASSERT
(
callee
.
numArgs
>
0
)
;
MOZ_ASSERT
(
callee
.
argTypes
[
0
]
=
=
MIRType
:
:
Pointer
)
;
MOZ_ASSERT
(
numArgs
+
1
=
=
callee
.
numArgs
)
;
MOZ_ASSERT
(
(
result
=
=
nullptr
)
=
=
(
callee
.
retType
=
=
MIRType
:
:
None
)
)
;
if
(
inDeadCode
(
)
)
{
if
(
result
)
{
*
result
=
nullptr
;
}
return
true
;
}
for
(
size_t
i
=
0
;
i
<
numArgs
;
i
+
+
)
{
if
(
!
args
[
i
]
)
{
if
(
result
)
{
*
result
=
nullptr
;
}
return
false
;
}
}
CallCompileState
callState
(
ABIKind
:
:
System
)
;
if
(
!
passInstanceCallArg
(
callee
.
argTypes
[
0
]
&
callState
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
numArgs
;
i
+
+
)
{
if
(
!
passCallArg
(
args
[
i
]
callee
.
argTypes
[
i
+
1
]
&
callState
)
)
{
return
false
;
}
}
if
(
!
finishCallArgs
(
&
callState
)
)
{
return
false
;
}
return
instanceCall
(
&
callState
callee
lineOrBytecode
result
)
;
}
[
[
nodiscard
]
]
bool
emitInstanceCall0
(
uint32_t
lineOrBytecode
const
SymbolicAddressSignature
&
callee
MDefinition
*
*
result
=
nullptr
)
{
MDefinition
*
args
[
0
]
=
{
}
;
return
emitInstanceCallN
(
lineOrBytecode
callee
args
0
result
)
;
}
[
[
nodiscard
]
]
bool
emitInstanceCall1
(
uint32_t
lineOrBytecode
const
SymbolicAddressSignature
&
callee
MDefinition
*
arg1
MDefinition
*
*
result
=
nullptr
)
{
MDefinition
*
args
[
1
]
=
{
arg1
}
;
return
emitInstanceCallN
(
lineOrBytecode
callee
args
1
result
)
;
}
[
[
nodiscard
]
]
bool
emitInstanceCall2
(
uint32_t
lineOrBytecode
const
SymbolicAddressSignature
&
callee
MDefinition
*
arg1
MDefinition
*
arg2
MDefinition
*
*
result
=
nullptr
)
{
MDefinition
*
args
[
2
]
=
{
arg1
arg2
}
;
return
emitInstanceCallN
(
lineOrBytecode
callee
args
2
result
)
;
}
[
[
nodiscard
]
]
bool
emitInstanceCall3
(
uint32_t
lineOrBytecode
const
SymbolicAddressSignature
&
callee
MDefinition
*
arg1
MDefinition
*
arg2
MDefinition
*
arg3
MDefinition
*
*
result
=
nullptr
)
{
MDefinition
*
args
[
3
]
=
{
arg1
arg2
arg3
}
;
return
emitInstanceCallN
(
lineOrBytecode
callee
args
3
result
)
;
}
[
[
nodiscard
]
]
bool
emitInstanceCall4
(
uint32_t
lineOrBytecode
const
SymbolicAddressSignature
&
callee
MDefinition
*
arg1
MDefinition
*
arg2
MDefinition
*
arg3
MDefinition
*
arg4
MDefinition
*
*
result
=
nullptr
)
{
MDefinition
*
args
[
4
]
=
{
arg1
arg2
arg3
arg4
}
;
return
emitInstanceCallN
(
lineOrBytecode
callee
args
4
result
)
;
}
[
[
nodiscard
]
]
bool
emitInstanceCall5
(
uint32_t
lineOrBytecode
const
SymbolicAddressSignature
&
callee
MDefinition
*
arg1
MDefinition
*
arg2
MDefinition
*
arg3
MDefinition
*
arg4
MDefinition
*
arg5
MDefinition
*
*
result
=
nullptr
)
{
MDefinition
*
args
[
5
]
=
{
arg1
arg2
arg3
arg4
arg5
}
;
return
emitInstanceCallN
(
lineOrBytecode
callee
args
5
result
)
;
}
[
[
nodiscard
]
]
bool
emitInstanceCall6
(
uint32_t
lineOrBytecode
const
SymbolicAddressSignature
&
callee
MDefinition
*
arg1
MDefinition
*
arg2
MDefinition
*
arg3
MDefinition
*
arg4
MDefinition
*
arg5
MDefinition
*
arg6
MDefinition
*
*
result
=
nullptr
)
{
MDefinition
*
args
[
6
]
=
{
arg1
arg2
arg3
arg4
arg5
arg6
}
;
return
emitInstanceCallN
(
lineOrBytecode
callee
args
6
result
)
;
}
[
[
nodiscard
]
]
MDefinition
*
stackSwitch
(
MDefinition
*
suspender
MDefinition
*
fn
MDefinition
*
data
StackSwitchKind
kind
)
{
MOZ_ASSERT
(
!
inDeadCode
(
)
)
;
MInstruction
*
ins
;
switch
(
kind
)
{
case
StackSwitchKind
:
:
SwitchToMain
:
ins
=
MWasmStackSwitchToMain
:
:
New
(
alloc
(
)
suspender
fn
data
)
;
break
;
case
StackSwitchKind
:
:
SwitchToSuspendable
:
ins
=
MWasmStackSwitchToSuspendable
:
:
New
(
alloc
(
)
suspender
fn
data
)
;
break
;
case
StackSwitchKind
:
:
ContinueOnSuspendable
:
ins
=
MWasmStackContinueOnSuspendable
:
:
New
(
alloc
(
)
suspender
data
)
;
break
;
}
if
(
!
ins
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
[
[
nodiscard
]
]
bool
callRef
(
const
FuncType
&
funcType
MDefinition
*
ref
uint32_t
lineOrBytecode
const
DefVector
&
args
DefVector
*
results
)
{
MOZ_ASSERT
(
!
inDeadCode
(
)
)
;
CallCompileState
callState
(
ABIKind
:
:
Wasm
)
;
CalleeDesc
callee
=
CalleeDesc
:
:
wasmFuncRef
(
)
;
CallSiteDesc
desc
(
lineOrBytecode
rootCompiler_
.
inlinedCallerOffsetsIndex
(
)
CallSiteKind
:
:
FuncRef
)
;
ArgTypeVector
argTypes
(
funcType
)
;
ResultType
resultType
=
ResultType
:
:
Vector
(
funcType
.
results
(
)
)
;
return
emitCallArgs
(
funcType
args
&
callState
)
&
&
call
(
&
callState
desc
callee
argTypes
ref
)
&
&
collectWasmCallResults
(
resultType
&
callState
results
)
;
}
[
[
nodiscard
]
]
bool
returnCallRef
(
const
FuncType
&
funcType
MDefinition
*
ref
uint32_t
lineOrBytecode
const
DefVector
&
args
DefVector
*
results
)
{
MOZ_ASSERT
(
!
inDeadCode
(
)
)
;
MOZ_ASSERT
(
!
isInlined
(
)
)
;
CallCompileState
callState
(
ABIKind
:
:
Wasm
)
;
callState
.
returnCall
=
true
;
CalleeDesc
callee
=
CalleeDesc
:
:
wasmFuncRef
(
)
;
CallSiteDesc
desc
(
lineOrBytecode
CallSiteKind
:
:
FuncRef
)
;
ArgTypeVector
argTypes
(
funcType
)
;
if
(
!
emitCallArgs
(
funcType
args
&
callState
)
)
{
return
false
;
}
auto
*
ins
=
MWasmReturnCall
:
:
New
(
alloc
(
)
desc
callee
callState
.
regArgs
StackArgAreaSizeUnaligned
(
argTypes
callState
.
abiKind
)
ref
)
;
if
(
!
ins
)
{
return
false
;
}
curBlock_
-
>
end
(
ins
)
;
curBlock_
=
nullptr
;
return
true
;
}
[
[
nodiscard
]
]
MDefinition
*
stringCast
(
MDefinition
*
string
)
{
auto
*
ins
=
MWasmTrapIfAnyRefIsNotJSString
:
:
New
(
alloc
(
)
string
wasm
:
:
Trap
:
:
BadCast
trapSiteDesc
(
)
)
;
if
(
!
ins
)
{
return
ins
;
}
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
[
[
nodiscard
]
]
MDefinition
*
stringTest
(
MDefinition
*
string
)
{
auto
*
ins
=
MWasmAnyRefIsJSString
:
:
New
(
alloc
(
)
string
)
;
if
(
!
ins
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
[
[
nodiscard
]
]
MDefinition
*
stringLength
(
MDefinition
*
string
)
{
auto
*
ins
=
MWasmAnyRefJSStringLength
:
:
New
(
alloc
(
)
string
wasm
:
:
Trap
:
:
BadCast
trapSiteDesc
(
)
)
;
if
(
!
ins
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
[
[
nodiscard
]
]
bool
dispatchInlineBuiltinModuleFunc
(
const
BuiltinModuleFunc
&
builtinModuleFunc
const
DefVector
&
params
)
{
BuiltinInlineOp
inlineOp
=
builtinModuleFunc
.
inlineOp
(
)
;
MOZ_ASSERT
(
inlineOp
!
=
BuiltinInlineOp
:
:
None
)
;
switch
(
inlineOp
)
{
case
BuiltinInlineOp
:
:
StringCast
:
{
MOZ_ASSERT
(
params
.
length
(
)
=
=
1
)
;
MDefinition
*
string
=
params
[
0
]
;
MDefinition
*
cast
=
stringCast
(
string
)
;
if
(
!
cast
)
{
return
false
;
}
iter
(
)
.
setResult
(
string
)
;
return
true
;
}
case
BuiltinInlineOp
:
:
StringTest
:
{
MOZ_ASSERT
(
params
.
length
(
)
=
=
1
)
;
MDefinition
*
string
=
params
[
0
]
;
MDefinition
*
test
=
stringTest
(
string
)
;
if
(
!
test
)
{
return
false
;
}
iter
(
)
.
setResult
(
test
)
;
return
true
;
}
case
BuiltinInlineOp
:
:
StringLength
:
{
MOZ_ASSERT
(
params
.
length
(
)
=
=
1
)
;
MDefinition
*
string
=
params
[
0
]
;
MDefinition
*
length
=
stringLength
(
string
)
;
if
(
!
length
)
{
return
false
;
}
iter
(
)
.
setResult
(
length
)
;
return
true
;
}
case
BuiltinInlineOp
:
:
None
:
case
BuiltinInlineOp
:
:
Limit
:
break
;
}
MOZ_CRASH
(
)
;
}
[
[
nodiscard
]
]
bool
callBuiltinModuleFunc
(
const
BuiltinModuleFunc
&
builtinModuleFunc
const
DefVector
&
params
)
{
MOZ_ASSERT
(
!
inDeadCode
(
)
)
;
BuiltinInlineOp
inlineOp
=
builtinModuleFunc
.
inlineOp
(
)
;
if
(
inlineOp
!
=
BuiltinInlineOp
:
:
None
)
{
return
dispatchInlineBuiltinModuleFunc
(
builtinModuleFunc
params
)
;
}
const
SymbolicAddressSignature
&
callee
=
*
builtinModuleFunc
.
sig
(
)
;
CallCompileState
callState
(
ABIKind
:
:
System
)
;
if
(
!
passInstanceCallArg
(
callee
.
argTypes
[
0
]
&
callState
)
|
|
!
passCallArgs
(
params
builtinModuleFunc
.
funcType
(
)
-
>
args
(
)
&
callState
)
)
{
return
false
;
}
if
(
builtinModuleFunc
.
usesMemory
(
)
)
{
if
(
!
passCallArg
(
memoryBase
(
0
)
MIRType
:
:
Pointer
&
callState
)
)
{
return
false
;
}
}
if
(
!
finishCallArgs
(
&
callState
)
)
{
return
false
;
}
bool
hasResult
=
!
builtinModuleFunc
.
funcType
(
)
-
>
results
(
)
.
empty
(
)
;
MDefinition
*
result
=
nullptr
;
MDefinition
*
*
resultOutParam
=
hasResult
?
&
result
:
nullptr
;
if
(
!
instanceCall
(
&
callState
callee
readBytecodeOffset
(
)
resultOutParam
)
)
{
return
false
;
}
if
(
hasResult
)
{
iter
(
)
.
setResult
(
result
)
;
}
return
true
;
}
inline
bool
inDeadCode
(
)
const
{
return
curBlock_
=
=
nullptr
;
}
[
[
nodiscard
]
]
bool
returnValues
(
DefVector
&
&
values
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
if
(
isInlined
(
)
)
{
MGoto
*
jump
=
MGoto
:
:
New
(
alloc
(
)
)
;
if
(
!
jump
)
{
return
false
;
}
curBlock_
-
>
end
(
jump
)
;
curBlock_
=
nullptr
;
return
pendingInlineReturns_
.
emplaceBack
(
PendingInlineReturn
(
jump
std
:
:
move
(
values
)
)
)
;
}
if
(
values
.
empty
(
)
)
{
curBlock_
-
>
end
(
MWasmReturnVoid
:
:
New
(
alloc
(
)
instancePointer_
)
)
;
}
else
{
ResultType
resultType
=
ResultType
:
:
Vector
(
funcType
(
)
.
results
(
)
)
;
ABIResultIter
iter
(
resultType
)
;
while
(
!
iter
.
done
(
)
)
{
iter
.
next
(
)
;
}
iter
.
switchToPrev
(
)
;
for
(
uint32_t
i
=
0
;
!
iter
.
done
(
)
;
iter
.
prev
(
)
i
+
+
)
{
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
const
ABIResult
&
result
=
iter
.
cur
(
)
;
if
(
result
.
onStack
(
)
)
{
MOZ_ASSERT
(
iter
.
remaining
(
)
>
1
)
;
if
(
result
.
type
(
)
.
isRefRepr
(
)
)
{
auto
*
store
=
MWasmStoreRef
:
:
New
(
alloc
(
)
instancePointer_
stackResultPointer_
result
.
stackOffset
(
)
values
[
i
]
AliasSet
:
:
WasmStackResult
WasmPreBarrierKind
:
:
None
)
;
curBlock_
-
>
add
(
store
)
;
}
else
{
auto
*
store
=
MWasmStoreStackResult
:
:
New
(
alloc
(
)
stackResultPointer_
result
.
stackOffset
(
)
values
[
i
]
)
;
curBlock_
-
>
add
(
store
)
;
}
}
else
{
MOZ_ASSERT
(
iter
.
remaining
(
)
=
=
1
)
;
MOZ_ASSERT
(
i
+
1
=
=
values
.
length
(
)
)
;
curBlock_
-
>
end
(
MWasmReturn
:
:
New
(
alloc
(
)
values
[
i
]
instancePointer_
)
)
;
}
}
}
curBlock_
=
nullptr
;
return
true
;
}
void
unreachableTrap
(
)
{
if
(
inDeadCode
(
)
)
{
return
;
}
auto
*
ins
=
MWasmTrap
:
:
New
(
alloc
(
)
wasm
:
:
Trap
:
:
Unreachable
trapSiteDesc
(
)
)
;
curBlock_
-
>
end
(
ins
)
;
curBlock_
=
nullptr
;
}
private
:
static
uint32_t
numPushed
(
MBasicBlock
*
block
)
{
return
block
-
>
stackDepth
(
)
-
block
-
>
info
(
)
.
firstStackSlot
(
)
;
}
public
:
[
[
nodiscard
]
]
bool
pushDefs
(
const
DefVector
&
defs
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
numPushed
(
curBlock_
)
=
=
0
)
;
if
(
!
curBlock_
-
>
ensureHasSlots
(
defs
.
length
(
)
)
)
{
return
false
;
}
for
(
MDefinition
*
def
:
defs
)
{
MOZ_ASSERT
(
def
-
>
type
(
)
!
=
MIRType
:
:
None
)
;
curBlock_
-
>
push
(
def
)
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
popPushedDefs
(
DefVector
*
defs
)
{
size_t
n
=
numPushed
(
curBlock_
)
;
if
(
!
defs
-
>
resizeUninitialized
(
n
)
)
{
return
false
;
}
for
(
;
n
>
0
;
n
-
-
)
{
MDefinition
*
def
=
curBlock_
-
>
pop
(
)
;
MOZ_ASSERT
(
def
-
>
type
(
)
!
=
MIRType
:
:
Value
)
;
(
*
defs
)
[
n
-
1
]
=
def
;
}
return
true
;
}
private
:
[
[
nodiscard
]
]
bool
addJoinPredecessor
(
const
DefVector
&
defs
MBasicBlock
*
*
joinPred
)
{
*
joinPred
=
curBlock_
;
if
(
inDeadCode
(
)
)
{
return
true
;
}
return
pushDefs
(
defs
)
;
}
public
:
[
[
nodiscard
]
]
bool
branchAndStartThen
(
MDefinition
*
cond
MBasicBlock
*
*
elseBlock
)
{
if
(
inDeadCode
(
)
)
{
*
elseBlock
=
nullptr
;
}
else
{
MBasicBlock
*
thenBlock
;
if
(
!
newBlock
(
curBlock_
&
thenBlock
)
)
{
return
false
;
}
if
(
!
newBlock
(
curBlock_
elseBlock
)
)
{
return
false
;
}
curBlock_
-
>
end
(
MTest
:
:
New
(
alloc
(
)
cond
thenBlock
*
elseBlock
)
)
;
curBlock_
=
thenBlock
;
mirGraph
(
)
.
moveBlockToEnd
(
curBlock_
)
;
}
return
startBlock
(
)
;
}
[
[
nodiscard
]
]
bool
switchToElse
(
MBasicBlock
*
elseBlock
MBasicBlock
*
*
thenJoinPred
)
{
DefVector
values
;
if
(
!
finishBlock
(
&
values
)
)
{
return
false
;
}
if
(
!
elseBlock
)
{
*
thenJoinPred
=
nullptr
;
}
else
{
if
(
!
addJoinPredecessor
(
values
thenJoinPred
)
)
{
return
false
;
}
curBlock_
=
elseBlock
;
mirGraph
(
)
.
moveBlockToEnd
(
curBlock_
)
;
}
return
startBlock
(
)
;
}
[
[
nodiscard
]
]
bool
joinIfElse
(
MBasicBlock
*
thenJoinPred
DefVector
*
defs
)
{
DefVector
values
;
if
(
!
finishBlock
(
&
values
)
)
{
return
false
;
}
if
(
!
thenJoinPred
&
&
inDeadCode
(
)
)
{
return
true
;
}
MBasicBlock
*
elseJoinPred
;
if
(
!
addJoinPredecessor
(
values
&
elseJoinPred
)
)
{
return
false
;
}
mozilla
:
:
Array
<
MBasicBlock
*
2
>
blocks
;
size_t
numJoinPreds
=
0
;
if
(
thenJoinPred
)
{
blocks
[
numJoinPreds
+
+
]
=
thenJoinPred
;
}
if
(
elseJoinPred
)
{
blocks
[
numJoinPreds
+
+
]
=
elseJoinPred
;
}
if
(
numJoinPreds
=
=
0
)
{
return
true
;
}
MBasicBlock
*
join
;
if
(
!
goToNewBlock
(
blocks
[
0
]
&
join
)
)
{
return
false
;
}
for
(
size_t
i
=
1
;
i
<
numJoinPreds
;
+
+
i
)
{
if
(
!
goToExistingBlock
(
blocks
[
i
]
join
)
)
{
return
false
;
}
}
curBlock_
=
join
;
return
popPushedDefs
(
defs
)
;
}
[
[
nodiscard
]
]
bool
startBlock
(
)
{
MOZ_ASSERT_IF
(
pendingBlockDepth_
<
pendingBlocks_
.
length
(
)
pendingBlocks_
[
pendingBlockDepth_
]
.
patches
.
empty
(
)
)
;
pendingBlockDepth_
+
+
;
return
true
;
}
[
[
nodiscard
]
]
bool
finishBlock
(
DefVector
*
defs
)
{
MOZ_ASSERT
(
pendingBlockDepth_
)
;
uint32_t
topLabel
=
-
-
pendingBlockDepth_
;
return
bindBranches
(
topLabel
defs
)
;
}
[
[
nodiscard
]
]
bool
startLoop
(
MBasicBlock
*
*
loopHeader
size_t
paramCount
)
{
*
loopHeader
=
nullptr
;
pendingBlockDepth_
+
+
;
rootCompiler_
.
startLoop
(
)
;
if
(
inDeadCode
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
curBlock_
-
>
loopDepth
(
)
=
=
rootCompiler_
.
loopDepth
(
)
-
1
)
;
*
loopHeader
=
MBasicBlock
:
:
New
(
mirGraph
(
)
info
(
)
curBlock_
MBasicBlock
:
:
PENDING_LOOP_HEADER
)
;
if
(
!
*
loopHeader
)
{
return
false
;
}
(
*
loopHeader
)
-
>
setLoopDepth
(
rootCompiler_
.
loopDepth
(
)
)
;
mirGraph
(
)
.
addBlock
(
*
loopHeader
)
;
curBlock_
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
*
loopHeader
)
)
;
DefVector
loopParams
;
if
(
!
iter
(
)
.
getResults
(
paramCount
&
loopParams
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
paramCount
;
i
+
+
)
{
MPhi
*
phi
=
MPhi
:
:
New
(
alloc
(
)
loopParams
[
i
]
-
>
type
(
)
)
;
if
(
!
phi
)
{
return
false
;
}
if
(
!
phi
-
>
reserveLength
(
2
)
)
{
return
false
;
}
(
*
loopHeader
)
-
>
addPhi
(
phi
)
;
phi
-
>
addInput
(
loopParams
[
i
]
)
;
loopParams
[
i
]
=
phi
;
}
iter
(
)
.
setResults
(
paramCount
loopParams
)
;
MBasicBlock
*
body
;
if
(
!
goToNewBlock
(
*
loopHeader
&
body
)
)
{
return
false
;
}
curBlock_
=
body
;
return
true
;
}
private
:
void
fixupRedundantPhis
(
MBasicBlock
*
b
)
{
for
(
size_t
i
=
0
depth
=
b
-
>
stackDepth
(
)
;
i
<
depth
;
i
+
+
)
{
MDefinition
*
def
=
b
-
>
getSlot
(
i
)
;
if
(
def
-
>
isUnused
(
)
)
{
b
-
>
setSlot
(
i
def
-
>
toPhi
(
)
-
>
getOperand
(
0
)
)
;
}
}
}
[
[
nodiscard
]
]
bool
setLoopBackedge
(
MBasicBlock
*
loopEntry
MBasicBlock
*
loopBody
MBasicBlock
*
backedge
size_t
paramCount
)
{
if
(
!
loopEntry
-
>
setBackedgeWasm
(
backedge
paramCount
)
)
{
return
false
;
}
for
(
MPhiIterator
phi
=
loopEntry
-
>
phisBegin
(
)
;
phi
!
=
loopEntry
-
>
phisEnd
(
)
;
phi
+
+
)
{
MOZ_ASSERT
(
phi
-
>
numOperands
(
)
=
=
2
)
;
if
(
phi
-
>
getOperand
(
0
)
=
=
phi
-
>
getOperand
(
1
)
)
{
phi
-
>
setUnused
(
)
;
}
}
for
(
PendingBlockTarget
&
pendingBlockTarget
:
pendingBlocks_
)
{
for
(
ControlFlowPatch
&
p
:
pendingBlockTarget
.
patches
)
{
MBasicBlock
*
block
=
p
.
ins
-
>
block
(
)
;
if
(
block
-
>
loopDepth
(
)
>
=
loopEntry
-
>
loopDepth
(
)
)
{
fixupRedundantPhis
(
block
)
;
}
}
}
if
(
loopBody
)
{
fixupRedundantPhis
(
loopBody
)
;
}
for
(
uint32_t
depth
=
0
;
depth
<
iter
(
)
.
controlStackDepth
(
)
;
depth
+
+
)
{
LabelKind
kind
=
iter
(
)
.
controlKind
(
depth
)
;
if
(
kind
!
=
LabelKind
:
:
Try
&
&
kind
!
=
LabelKind
:
:
TryTable
&
&
kind
!
=
LabelKind
:
:
Body
)
{
continue
;
}
Control
&
control
=
iter
(
)
.
controlItem
(
depth
)
;
if
(
!
control
.
tryControl
)
{
continue
;
}
for
(
MControlInstruction
*
patch
:
control
.
tryControl
-
>
landingPadPatches
)
{
MBasicBlock
*
block
=
patch
-
>
block
(
)
;
if
(
block
-
>
loopDepth
(
)
>
=
loopEntry
-
>
loopDepth
(
)
)
{
fixupRedundantPhis
(
block
)
;
}
}
}
for
(
MControlInstruction
*
patch
:
bodyRethrowPadPatches_
)
{
MBasicBlock
*
block
=
patch
-
>
block
(
)
;
if
(
block
-
>
loopDepth
(
)
>
=
loopEntry
-
>
loopDepth
(
)
)
{
fixupRedundantPhis
(
block
)
;
}
}
for
(
PendingInlineReturn
&
pendingReturn
:
pendingInlineReturns_
)
{
for
(
uint32_t
resultIndex
=
0
;
resultIndex
<
pendingReturn
.
results
.
length
(
)
;
resultIndex
+
+
)
{
MDefinition
*
*
pendingResult
=
&
pendingReturn
.
results
[
resultIndex
]
;
if
(
(
*
pendingResult
)
-
>
isUnused
(
)
)
{
*
pendingResult
=
(
*
pendingResult
)
-
>
toPhi
(
)
-
>
getOperand
(
0
)
;
}
}
}
for
(
MPhiIterator
phi
=
loopEntry
-
>
phisBegin
(
)
;
phi
!
=
loopEntry
-
>
phisEnd
(
)
;
)
{
MPhi
*
entryDef
=
*
phi
+
+
;
if
(
!
entryDef
-
>
isUnused
(
)
)
{
continue
;
}
entryDef
-
>
justReplaceAllUsesWith
(
entryDef
-
>
getOperand
(
0
)
)
;
loopEntry
-
>
discardPhi
(
entryDef
)
;
mirGraph
(
)
.
addPhiToFreeList
(
entryDef
)
;
}
return
true
;
}
public
:
[
[
nodiscard
]
]
bool
closeLoop
(
MBasicBlock
*
loopHeader
DefVector
*
loopResults
)
{
MOZ_ASSERT
(
pendingBlockDepth_
>
=
1
)
;
MOZ_ASSERT
(
rootCompiler_
.
loopDepth
(
)
)
;
uint32_t
headerLabel
=
pendingBlockDepth_
-
1
;
if
(
!
loopHeader
)
{
MOZ_ASSERT
(
inDeadCode
(
)
)
;
MOZ_ASSERT
(
headerLabel
>
=
pendingBlocks_
.
length
(
)
|
|
pendingBlocks_
[
headerLabel
]
.
patches
.
empty
(
)
)
;
pendingBlockDepth_
-
-
;
rootCompiler_
.
closeLoop
(
)
;
return
true
;
}
MBasicBlock
*
loopBody
=
curBlock_
;
curBlock_
=
nullptr
;
DefVector
backedgeValues
;
if
(
!
bindBranches
(
headerLabel
&
backedgeValues
)
)
{
return
false
;
}
MOZ_ASSERT
(
loopHeader
-
>
loopDepth
(
)
=
=
rootCompiler_
.
loopDepth
(
)
)
;
if
(
curBlock_
)
{
for
(
size_t
i
=
0
n
=
numPushed
(
curBlock_
)
;
i
!
=
n
;
i
+
+
)
{
curBlock_
-
>
pop
(
)
;
}
if
(
!
pushDefs
(
backedgeValues
)
)
{
return
false
;
}
MOZ_ASSERT
(
curBlock_
-
>
loopDepth
(
)
=
=
rootCompiler_
.
loopDepth
(
)
)
;
curBlock_
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
loopHeader
)
)
;
if
(
!
setLoopBackedge
(
loopHeader
loopBody
curBlock_
backedgeValues
.
length
(
)
)
)
{
return
false
;
}
}
curBlock_
=
loopBody
;
rootCompiler_
.
closeLoop
(
)
;
if
(
curBlock_
&
&
curBlock_
-
>
loopDepth
(
)
!
=
rootCompiler_
.
loopDepth
(
)
)
{
MBasicBlock
*
out
;
if
(
!
goToNewBlock
(
curBlock_
&
out
)
)
{
return
false
;
}
curBlock_
=
out
;
}
pendingBlockDepth_
-
=
1
;
return
inDeadCode
(
)
|
|
popPushedDefs
(
loopResults
)
;
}
[
[
nodiscard
]
]
bool
addControlFlowPatch
(
MControlInstruction
*
ins
uint32_t
relative
uint32_t
index
BranchHint
branchHint
=
BranchHint
:
:
Invalid
)
{
MOZ_ASSERT
(
relative
<
pendingBlockDepth_
)
;
uint32_t
absolute
=
pendingBlockDepth_
-
1
-
relative
;
if
(
absolute
>
=
pendingBlocks_
.
length
(
)
&
&
!
pendingBlocks_
.
resize
(
absolute
+
1
)
)
{
return
false
;
}
pendingBlocks_
[
absolute
]
.
hint
=
branchHint
;
return
pendingBlocks_
[
absolute
]
.
patches
.
append
(
ControlFlowPatch
(
ins
index
)
)
;
}
[
[
nodiscard
]
]
bool
br
(
uint32_t
relativeDepth
const
DefVector
&
values
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
MGoto
*
jump
=
MGoto
:
:
New
(
alloc
(
)
)
;
if
(
!
addControlFlowPatch
(
jump
relativeDepth
MGoto
:
:
TargetIndex
)
)
{
return
false
;
}
if
(
!
pushDefs
(
values
)
)
{
return
false
;
}
curBlock_
-
>
end
(
jump
)
;
curBlock_
=
nullptr
;
return
true
;
}
[
[
nodiscard
]
]
bool
brIf
(
uint32_t
relativeDepth
const
DefVector
&
values
MDefinition
*
condition
BranchHint
branchHint
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
MBasicBlock
*
joinBlock
=
nullptr
;
if
(
!
newBlock
(
curBlock_
&
joinBlock
)
)
{
return
false
;
}
MTest
*
test
=
MTest
:
:
New
(
alloc
(
)
condition
nullptr
joinBlock
)
;
if
(
!
addControlFlowPatch
(
test
relativeDepth
MTest
:
:
TrueBranchIndex
branchHint
)
)
{
return
false
;
}
if
(
!
pushDefs
(
values
)
)
{
return
false
;
}
curBlock_
-
>
end
(
test
)
;
curBlock_
=
joinBlock
;
return
true
;
}
[
[
nodiscard
]
]
bool
brTable
(
MDefinition
*
operand
uint32_t
defaultDepth
const
Uint32Vector
&
depths
const
DefVector
&
values
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
size_t
numCases
=
depths
.
length
(
)
;
MOZ_ASSERT
(
numCases
<
=
INT32_MAX
)
;
MOZ_ASSERT
(
numCases
)
;
MTableSwitch
*
table
=
MTableSwitch
:
:
New
(
alloc
(
)
operand
0
int32_t
(
numCases
-
1
)
)
;
size_t
defaultIndex
;
if
(
!
table
-
>
addDefault
(
nullptr
&
defaultIndex
)
)
{
return
false
;
}
if
(
!
addControlFlowPatch
(
table
defaultDepth
defaultIndex
)
)
{
return
false
;
}
using
IndexToCaseMap
=
HashMap
<
uint32_t
uint32_t
DefaultHasher
<
uint32_t
>
SystemAllocPolicy
>
;
IndexToCaseMap
indexToCase
;
if
(
!
indexToCase
.
put
(
defaultDepth
defaultIndex
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
numCases
;
i
+
+
)
{
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
uint32_t
depth
=
depths
[
i
]
;
size_t
caseIndex
;
IndexToCaseMap
:
:
AddPtr
p
=
indexToCase
.
lookupForAdd
(
depth
)
;
if
(
!
p
)
{
if
(
!
table
-
>
addSuccessor
(
nullptr
&
caseIndex
)
)
{
return
false
;
}
if
(
!
addControlFlowPatch
(
table
depth
caseIndex
)
)
{
return
false
;
}
if
(
!
indexToCase
.
add
(
p
depth
caseIndex
)
)
{
return
false
;
}
}
else
{
caseIndex
=
p
-
>
value
(
)
;
}
if
(
!
table
-
>
addCase
(
caseIndex
)
)
{
return
false
;
}
}
if
(
!
pushDefs
(
values
)
)
{
return
false
;
}
curBlock_
-
>
end
(
table
)
;
curBlock_
=
nullptr
;
return
true
;
}
bool
inTryBlockFrom
(
uint32_t
fromRelativeDepth
uint32_t
*
tryRelativeDepth
)
const
{
uint32_t
relativeDepth
;
if
(
iter_
.
controlFindInnermostFrom
(
[
]
(
LabelKind
kind
const
Control
&
control
)
{
return
control
.
tryControl
!
=
nullptr
&
&
control
.
tryControl
-
>
inBody
;
}
fromRelativeDepth
&
relativeDepth
)
)
{
*
tryRelativeDepth
=
relativeDepth
;
return
true
;
}
if
(
callerCompiler_
&
&
callerCompiler_
-
>
inTryCode
(
)
)
{
*
tryRelativeDepth
=
iter_
.
controlStackDepth
(
)
-
1
;
return
true
;
}
return
false
;
}
bool
inTryBlockFrom
(
uint32_t
fromRelativeDepth
ControlInstructionVector
*
*
landingPadPatches
)
{
uint32_t
tryRelativeDepth
;
if
(
!
inTryBlockFrom
(
fromRelativeDepth
&
tryRelativeDepth
)
)
{
return
false
;
}
if
(
tryRelativeDepth
=
=
iter
(
)
.
controlStackDepth
(
)
-
1
)
{
*
landingPadPatches
=
&
bodyRethrowPadPatches_
;
}
else
{
*
landingPadPatches
=
&
iter
(
)
.
controlItem
(
tryRelativeDepth
)
.
tryControl
-
>
landingPadPatches
;
}
return
true
;
}
bool
inTryBlock
(
ControlInstructionVector
*
*
landingPadPatches
)
{
return
inTryBlockFrom
(
0
landingPadPatches
)
;
}
bool
inTryCode
(
)
const
{
uint32_t
tryRelativeDepth
;
return
inTryBlockFrom
(
0
&
tryRelativeDepth
)
;
}
MDefinition
*
loadTag
(
uint32_t
tagIndex
)
{
MWasmLoadInstanceDataField
*
tag
=
MWasmLoadInstanceDataField
:
:
New
(
alloc
(
)
MIRType
:
:
WasmAnyRef
codeMeta
(
)
.
offsetOfTagInstanceData
(
tagIndex
)
true
instancePointer_
)
;
curBlock_
-
>
add
(
tag
)
;
return
tag
;
}
void
loadPendingExceptionState
(
MDefinition
*
*
pendingException
MDefinition
*
*
pendingExceptionTag
)
{
auto
*
exception
=
MWasmLoadInstance
:
:
New
(
alloc
(
)
instancePointer_
wasm
:
:
Instance
:
:
offsetOfPendingException
(
)
MIRType
:
:
WasmAnyRef
AliasSet
:
:
Load
(
AliasSet
:
:
WasmPendingException
)
)
;
curBlock_
-
>
add
(
exception
)
;
*
pendingException
=
exception
;
auto
*
tag
=
MWasmLoadInstance
:
:
New
(
alloc
(
)
instancePointer_
wasm
:
:
Instance
:
:
offsetOfPendingExceptionTag
(
)
MIRType
:
:
WasmAnyRef
AliasSet
:
:
Load
(
AliasSet
:
:
WasmPendingException
)
)
;
curBlock_
-
>
add
(
tag
)
;
*
pendingExceptionTag
=
tag
;
}
[
[
nodiscard
]
]
bool
setPendingExceptionState
(
MDefinition
*
exception
MDefinition
*
tag
)
{
auto
*
exceptionAddr
=
MWasmDerivedPointer
:
:
New
(
alloc
(
)
instancePointer_
Instance
:
:
offsetOfPendingException
(
)
)
;
curBlock_
-
>
add
(
exceptionAddr
)
;
auto
*
setException
=
MWasmStoreRef
:
:
New
(
alloc
(
)
instancePointer_
exceptionAddr
0
exception
AliasSet
:
:
WasmPendingException
WasmPreBarrierKind
:
:
Normal
)
;
curBlock_
-
>
add
(
setException
)
;
if
(
!
postBarrierEdgePrecise
(
0
exceptionAddr
exception
)
)
{
return
false
;
}
auto
*
exceptionTagAddr
=
MWasmDerivedPointer
:
:
New
(
alloc
(
)
instancePointer_
Instance
:
:
offsetOfPendingExceptionTag
(
)
)
;
curBlock_
-
>
add
(
exceptionTagAddr
)
;
auto
*
setExceptionTag
=
MWasmStoreRef
:
:
New
(
alloc
(
)
instancePointer_
exceptionTagAddr
0
tag
AliasSet
:
:
WasmPendingException
WasmPreBarrierKind
:
:
Normal
)
;
curBlock_
-
>
add
(
setExceptionTag
)
;
return
postBarrierEdgePrecise
(
0
exceptionTagAddr
tag
)
;
}
[
[
nodiscard
]
]
bool
endWithPadPatch
(
ControlInstructionVector
*
tryLandingPadPatches
)
{
MGoto
*
jumpToLandingPad
=
MGoto
:
:
New
(
alloc
(
)
)
;
curBlock_
-
>
end
(
jumpToLandingPad
)
;
return
tryLandingPadPatches
-
>
emplaceBack
(
jumpToLandingPad
)
;
}
[
[
nodiscard
]
]
bool
delegatePadPatches
(
const
ControlInstructionVector
&
patches
uint32_t
relativeDepth
)
{
if
(
patches
.
empty
(
)
)
{
return
true
;
}
ControlInstructionVector
*
targetPatches
;
if
(
!
inTryBlockFrom
(
relativeDepth
&
targetPatches
)
)
{
MOZ_ASSERT
(
relativeDepth
<
=
pendingBlockDepth_
-
1
)
;
targetPatches
=
&
bodyRethrowPadPatches_
;
}
for
(
MControlInstruction
*
ins
:
patches
)
{
if
(
!
targetPatches
-
>
emplaceBack
(
ins
)
)
{
return
false
;
}
}
return
true
;
}
[
[
nodiscard
]
]
bool
beginCatchableCall
(
CallCompileState
*
callState
)
{
if
(
!
inTryBlock
(
&
callState
-
>
tryLandingPadPatches
)
)
{
MOZ_ASSERT
(
!
callState
-
>
isCatchable
(
)
)
;
return
true
;
}
MOZ_ASSERT
(
callState
-
>
isCatchable
(
)
)
;
if
(
!
rootCompiler_
.
addTryNote
(
&
callState
-
>
tryNoteIndex
)
)
{
return
false
;
}
return
newBlock
(
curBlock_
&
callState
-
>
fallthroughBlock
)
&
&
newBlock
(
curBlock_
&
callState
-
>
prePadBlock
)
;
}
[
[
nodiscard
]
]
bool
finishCatchableCall
(
CallCompileState
*
callState
)
{
if
(
!
callState
-
>
tryLandingPadPatches
)
{
return
true
;
}
MBasicBlock
*
callBlock
=
curBlock_
;
curBlock_
=
callState
-
>
prePadBlock
;
curBlock_
-
>
add
(
MWasmCallLandingPrePad
:
:
New
(
alloc
(
)
callBlock
callState
-
>
tryNoteIndex
)
)
;
if
(
!
endWithPadPatch
(
callState
-
>
tryLandingPadPatches
)
)
{
return
false
;
}
curBlock_
=
callState
-
>
fallthroughBlock
;
return
true
;
}
[
[
nodiscard
]
]
bool
createTryLandingPad
(
ControlInstructionVector
&
landingPadPatches
MBasicBlock
*
*
landingPad
)
{
MOZ_ASSERT
(
!
landingPadPatches
.
empty
(
)
)
;
MControlInstruction
*
ins
=
landingPadPatches
[
0
]
;
MBasicBlock
*
pred
=
ins
-
>
block
(
)
;
if
(
!
newBlock
(
pred
landingPad
)
)
{
return
false
;
}
ins
-
>
replaceSuccessor
(
MGoto
:
:
TargetIndex
*
landingPad
)
;
for
(
size_t
i
=
1
;
i
<
landingPadPatches
.
length
(
)
;
i
+
+
)
{
ins
=
landingPadPatches
[
i
]
;
pred
=
ins
-
>
block
(
)
;
if
(
!
(
*
landingPad
)
-
>
addPredecessor
(
alloc
(
)
pred
)
)
{
return
false
;
}
ins
-
>
replaceSuccessor
(
MGoto
:
:
TargetIndex
*
landingPad
)
;
}
landingPadPatches
.
clear
(
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
createTryTableLandingPad
(
TryControl
*
tryControl
)
{
if
(
tryControl
-
>
landingPadPatches
.
empty
(
)
)
{
return
true
;
}
MBasicBlock
*
landingPad
;
if
(
!
createTryLandingPad
(
tryControl
-
>
landingPadPatches
&
landingPad
)
)
{
return
false
;
}
MDefinition
*
pendingException
;
MDefinition
*
pendingExceptionTag
;
if
(
!
consumePendingException
(
&
landingPad
&
pendingException
&
pendingExceptionTag
)
)
{
return
false
;
}
MBasicBlock
*
originalBlock
=
curBlock_
;
curBlock_
=
landingPad
;
bool
hadCatchAll
=
false
;
for
(
const
TryTableCatch
&
tryTableCatch
:
tryControl
-
>
catches
)
{
if
(
tryTableCatch
.
tagIndex
=
=
CatchAllIndex
)
{
DefVector
values
;
if
(
tryTableCatch
.
captureExnRef
&
&
!
values
.
append
(
pendingException
)
)
{
return
false
;
}
if
(
!
br
(
tryTableCatch
.
labelRelativeDepth
values
)
)
{
return
false
;
}
hadCatchAll
=
true
;
break
;
}
MBasicBlock
*
catchBlock
=
nullptr
;
MBasicBlock
*
fallthroughBlock
=
nullptr
;
if
(
!
newBlock
(
curBlock_
&
catchBlock
)
|
|
!
newBlock
(
curBlock_
&
fallthroughBlock
)
)
{
return
false
;
}
MDefinition
*
catchTag
=
loadTag
(
tryTableCatch
.
tagIndex
)
;
MDefinition
*
matchesCatchTag
=
compare
(
pendingExceptionTag
catchTag
JSOp
:
:
Eq
MCompare
:
:
Compare_WasmAnyRef
)
;
curBlock_
-
>
end
(
MTest
:
:
New
(
alloc
(
)
matchesCatchTag
catchBlock
fallthroughBlock
)
)
;
curBlock_
=
catchBlock
;
DefVector
values
;
if
(
!
loadExceptionValues
(
pendingException
tryTableCatch
.
tagIndex
&
values
)
)
{
return
false
;
}
if
(
tryTableCatch
.
captureExnRef
&
&
!
values
.
append
(
pendingException
)
)
{
return
false
;
}
if
(
!
br
(
tryTableCatch
.
labelRelativeDepth
values
)
)
{
return
false
;
}
curBlock_
=
fallthroughBlock
;
}
if
(
!
hadCatchAll
)
{
if
(
!
throwFrom
(
pendingException
pendingExceptionTag
)
)
{
return
false
;
}
}
curBlock_
=
originalBlock
;
return
true
;
}
[
[
nodiscard
]
]
bool
consumePendingException
(
MBasicBlock
*
*
landingPad
MDefinition
*
*
pendingException
MDefinition
*
*
pendingExceptionTag
)
{
MBasicBlock
*
prevBlock
=
curBlock_
;
curBlock_
=
*
landingPad
;
loadPendingExceptionState
(
pendingException
pendingExceptionTag
)
;
auto
*
null
=
constantNullRef
(
MaybeRefType
(
)
)
;
if
(
!
setPendingExceptionState
(
null
null
)
)
{
return
false
;
}
*
landingPad
=
curBlock_
;
curBlock_
=
prevBlock
;
return
true
;
}
[
[
nodiscard
]
]
bool
startTry
(
)
{
Control
&
control
=
iter
(
)
.
controlItem
(
)
;
control
.
block
=
curBlock_
;
control
.
tryControl
=
rootCompiler_
.
newTryControl
(
)
;
if
(
!
control
.
tryControl
)
{
return
false
;
}
control
.
tryControl
-
>
inBody
=
true
;
return
startBlock
(
)
;
}
[
[
nodiscard
]
]
bool
startTryTable
(
TryTableCatchVector
&
&
catches
)
{
Control
&
control
=
iter
(
)
.
controlItem
(
)
;
control
.
block
=
curBlock_
;
control
.
tryControl
=
rootCompiler_
.
newTryControl
(
)
;
if
(
!
control
.
tryControl
)
{
return
false
;
}
control
.
tryControl
-
>
inBody
=
true
;
control
.
tryControl
-
>
catches
=
std
:
:
move
(
catches
)
;
return
startBlock
(
)
;
}
[
[
nodiscard
]
]
bool
joinTryOrCatchBlock
(
Control
&
control
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
!
curBlock_
-
>
hasLastIns
(
)
)
;
MGoto
*
jump
=
MGoto
:
:
New
(
alloc
(
)
)
;
if
(
!
addControlFlowPatch
(
jump
0
MGoto
:
:
TargetIndex
)
)
{
return
false
;
}
curBlock_
-
>
end
(
jump
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
switchToCatch
(
Control
&
control
LabelKind
fromKind
uint32_t
tagIndex
)
{
control
.
tryControl
-
>
inBody
=
false
;
if
(
!
control
.
block
)
{
MOZ_ASSERT
(
inDeadCode
(
)
)
;
return
true
;
}
if
(
!
joinTryOrCatchBlock
(
control
)
)
{
return
false
;
}
if
(
fromKind
=
=
LabelKind
:
:
Try
)
{
if
(
!
control
.
tryControl
-
>
landingPadPatches
.
empty
(
)
)
{
MBasicBlock
*
padBlock
=
nullptr
;
if
(
!
createTryLandingPad
(
control
.
tryControl
-
>
landingPadPatches
&
padBlock
)
)
{
return
false
;
}
if
(
!
consumePendingException
(
&
padBlock
&
control
.
tryControl
-
>
pendingException
&
control
.
tryControl
-
>
pendingExceptionTag
)
)
{
return
false
;
}
control
.
block
=
padBlock
;
}
else
{
control
.
block
=
nullptr
;
}
}
if
(
!
control
.
block
)
{
curBlock_
=
nullptr
;
return
true
;
}
curBlock_
=
control
.
block
;
MOZ_ASSERT
(
control
.
tryControl
-
>
pendingException
)
;
MOZ_ASSERT
(
control
.
tryControl
-
>
pendingExceptionTag
)
;
if
(
tagIndex
=
=
CatchAllIndex
)
{
MBasicBlock
*
catchAllBlock
=
nullptr
;
if
(
!
goToNewBlock
(
curBlock_
&
catchAllBlock
)
)
{
return
false
;
}
curBlock_
=
catchAllBlock
;
return
true
;
}
MBasicBlock
*
catchBlock
=
nullptr
;
MBasicBlock
*
fallthroughBlock
=
nullptr
;
if
(
!
newBlock
(
curBlock_
&
catchBlock
)
|
|
!
newBlock
(
curBlock_
&
fallthroughBlock
)
)
{
return
false
;
}
MDefinition
*
catchTag
=
loadTag
(
tagIndex
)
;
MDefinition
*
matchesCatchTag
=
compare
(
control
.
tryControl
-
>
pendingExceptionTag
catchTag
JSOp
:
:
Eq
MCompare
:
:
Compare_WasmAnyRef
)
;
curBlock_
-
>
end
(
MTest
:
:
New
(
alloc
(
)
matchesCatchTag
catchBlock
fallthroughBlock
)
)
;
control
.
block
=
fallthroughBlock
;
curBlock_
=
catchBlock
;
DefVector
values
;
if
(
!
loadExceptionValues
(
control
.
tryControl
-
>
pendingException
tagIndex
&
values
)
)
{
return
false
;
}
iter
(
)
.
setResults
(
values
.
length
(
)
values
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
loadExceptionValues
(
MDefinition
*
exception
uint32_t
tagIndex
DefVector
*
values
)
{
SharedTagType
tagType
=
codeMeta
(
)
.
tags
[
tagIndex
]
.
type
;
const
ValTypeVector
&
params
=
tagType
-
>
argTypes
(
)
;
const
TagOffsetVector
&
offsets
=
tagType
-
>
argOffsets
(
)
;
auto
*
data
=
MWasmLoadField
:
:
New
(
alloc
(
)
exception
nullptr
WasmExceptionObject
:
:
offsetOfData
(
)
mozilla
:
:
Nothing
(
)
MIRType
:
:
Pointer
MWideningOp
:
:
None
AliasSet
:
:
Load
(
AliasSet
:
:
Any
)
)
;
if
(
!
data
)
{
return
false
;
}
curBlock_
-
>
add
(
data
)
;
if
(
!
values
-
>
reserve
(
params
.
length
(
)
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
params
.
length
(
)
;
i
+
+
)
{
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
auto
*
load
=
MWasmLoadField
:
:
New
(
alloc
(
)
data
exception
offsets
[
i
]
mozilla
:
:
Nothing
(
)
params
[
i
]
.
toMIRType
(
)
MWideningOp
:
:
None
AliasSet
:
:
Load
(
AliasSet
:
:
Any
)
mozilla
:
:
Nothing
(
)
params
[
i
]
.
toMaybeRefType
(
)
)
;
if
(
!
load
|
|
!
values
-
>
append
(
load
)
)
{
return
false
;
}
curBlock_
-
>
add
(
load
)
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
finishTryCatch
(
LabelKind
kind
Control
&
control
DefVector
*
defs
)
{
switch
(
kind
)
{
case
LabelKind
:
:
Try
:
{
uint32_t
relativeDepth
=
1
;
if
(
!
delegatePadPatches
(
control
.
tryControl
-
>
landingPadPatches
relativeDepth
)
)
{
return
false
;
}
break
;
}
case
LabelKind
:
:
Catch
:
{
MOZ_ASSERT
(
!
control
.
tryControl
-
>
inBody
)
;
MBasicBlock
*
padBlock
=
control
.
block
;
if
(
padBlock
)
{
MBasicBlock
*
prevBlock
=
curBlock_
;
curBlock_
=
padBlock
;
if
(
!
throwFrom
(
control
.
tryControl
-
>
pendingException
control
.
tryControl
-
>
pendingExceptionTag
)
)
{
return
false
;
}
curBlock_
=
prevBlock
;
}
break
;
}
case
LabelKind
:
:
CatchAll
:
{
MOZ_ASSERT
(
!
control
.
tryControl
-
>
inBody
)
;
break
;
}
default
:
MOZ_CRASH
(
)
;
}
return
finishBlock
(
defs
)
;
}
[
[
nodiscard
]
]
bool
finishTryTable
(
Control
&
control
DefVector
*
defs
)
{
control
.
tryControl
-
>
inBody
=
false
;
if
(
!
createTryTableLandingPad
(
control
.
tryControl
.
get
(
)
)
)
{
return
false
;
}
return
finishBlock
(
defs
)
;
}
[
[
nodiscard
]
]
bool
emitBodyRethrowPad
(
Control
&
control
)
{
if
(
bodyRethrowPadPatches_
.
empty
(
)
)
{
return
true
;
}
MBasicBlock
*
padBlock
;
if
(
!
createTryLandingPad
(
bodyRethrowPadPatches_
&
padBlock
)
)
{
return
false
;
}
if
(
callerCompiler_
&
&
callerCompiler_
-
>
inTryCode
(
)
)
{
pendingInlineCatchBlock_
=
padBlock
;
return
true
;
}
MDefinition
*
pendingException
;
MDefinition
*
pendingExceptionTag
;
if
(
!
consumePendingException
(
&
padBlock
&
pendingException
&
pendingExceptionTag
)
)
{
return
false
;
}
MBasicBlock
*
prevBlock
=
curBlock_
;
curBlock_
=
padBlock
;
if
(
!
throwFrom
(
pendingException
pendingExceptionTag
)
)
{
return
false
;
}
curBlock_
=
prevBlock
;
MOZ_ASSERT
(
bodyRethrowPadPatches_
.
empty
(
)
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
emitNewException
(
MDefinition
*
tag
MDefinition
*
*
exception
)
{
return
emitInstanceCall1
(
readBytecodeOffset
(
)
SASigExceptionNew
tag
exception
)
;
}
[
[
nodiscard
]
]
bool
emitThrow
(
uint32_t
tagIndex
const
DefVector
&
argValues
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
MDefinition
*
tag
=
loadTag
(
tagIndex
)
;
if
(
!
tag
)
{
return
false
;
}
MDefinition
*
exception
;
if
(
!
emitNewException
(
tag
&
exception
)
)
{
return
false
;
}
auto
*
data
=
MWasmLoadField
:
:
New
(
alloc
(
)
exception
nullptr
WasmExceptionObject
:
:
offsetOfData
(
)
mozilla
:
:
Nothing
(
)
MIRType
:
:
Pointer
MWideningOp
:
:
None
AliasSet
:
:
Load
(
AliasSet
:
:
Any
)
)
;
if
(
!
data
)
{
return
false
;
}
curBlock_
-
>
add
(
data
)
;
SharedTagType
tagType
=
codeMeta
(
)
.
tags
[
tagIndex
]
.
type
;
for
(
size_t
i
=
0
;
i
<
tagType
-
>
argOffsets
(
)
.
length
(
)
;
i
+
+
)
{
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
ValType
type
=
tagType
-
>
argTypes
(
)
[
i
]
;
uint32_t
offset
=
tagType
-
>
argOffsets
(
)
[
i
]
;
if
(
!
type
.
isRefRepr
(
)
)
{
auto
*
store
=
MWasmStoreField
:
:
New
(
alloc
(
)
data
exception
offset
mozilla
:
:
Nothing
(
)
argValues
[
i
]
MNarrowingOp
:
:
None
AliasSet
:
:
Store
(
AliasSet
:
:
Any
)
)
;
if
(
!
store
)
{
return
false
;
}
curBlock_
-
>
add
(
store
)
;
continue
;
}
auto
*
store
=
MWasmStoreFieldRef
:
:
New
(
alloc
(
)
instancePointer_
data
exception
offset
mozilla
:
:
Nothing
(
)
argValues
[
i
]
AliasSet
:
:
Store
(
AliasSet
:
:
Any
)
Nothing
(
)
WasmPreBarrierKind
:
:
None
)
;
if
(
!
store
)
{
return
false
;
}
curBlock_
-
>
add
(
store
)
;
if
(
!
postBarrierWholeCell
(
bytecodeOffset
exception
argValues
[
i
]
)
)
{
return
false
;
}
}
return
throwFrom
(
exception
tag
)
;
}
[
[
nodiscard
]
]
bool
emitThrowRef
(
MDefinition
*
exnRef
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
exnRef
=
refAsNonNull
(
exnRef
)
;
if
(
!
exnRef
)
{
return
false
;
}
if
(
!
emitInstanceCall1
(
readBytecodeOffset
(
)
SASigThrowException
exnRef
)
)
{
return
false
;
}
unreachableTrap
(
)
;
curBlock_
=
nullptr
;
return
true
;
}
[
[
nodiscard
]
]
bool
throwFrom
(
MDefinition
*
exn
MDefinition
*
tag
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
ControlInstructionVector
*
tryLandingPadPatches
;
if
(
inTryBlock
(
&
tryLandingPadPatches
)
)
{
if
(
!
setPendingExceptionState
(
exn
tag
)
)
{
return
false
;
}
if
(
!
endWithPadPatch
(
tryLandingPadPatches
)
)
{
return
false
;
}
curBlock_
=
nullptr
;
return
true
;
}
if
(
!
emitInstanceCall1
(
readBytecodeOffset
(
)
SASigThrowException
exn
)
)
{
return
false
;
}
unreachableTrap
(
)
;
curBlock_
=
nullptr
;
return
true
;
}
[
[
nodiscard
]
]
bool
emitRethrow
(
uint32_t
relativeDepth
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
Control
&
control
=
iter
(
)
.
controlItem
(
relativeDepth
)
;
MOZ_ASSERT
(
iter
(
)
.
controlKind
(
relativeDepth
)
=
=
LabelKind
:
:
Catch
|
|
iter
(
)
.
controlKind
(
relativeDepth
)
=
=
LabelKind
:
:
CatchAll
)
;
return
throwFrom
(
control
.
tryControl
-
>
pendingException
control
.
tryControl
-
>
pendingExceptionTag
)
;
}
static
void
fieldLoadInfoToMIR
(
StorageType
type
FieldWideningOp
wideningOp
MIRType
*
mirType
MWideningOp
*
mirWideningOp
)
{
switch
(
type
.
kind
(
)
)
{
case
StorageType
:
:
I8
:
{
switch
(
wideningOp
)
{
case
FieldWideningOp
:
:
Signed
:
*
mirType
=
MIRType
:
:
Int32
;
*
mirWideningOp
=
MWideningOp
:
:
FromS8
;
return
;
case
FieldWideningOp
:
:
Unsigned
:
*
mirType
=
MIRType
:
:
Int32
;
*
mirWideningOp
=
MWideningOp
:
:
FromU8
;
return
;
default
:
MOZ_CRASH
(
)
;
}
}
case
StorageType
:
:
I16
:
{
switch
(
wideningOp
)
{
case
FieldWideningOp
:
:
Signed
:
*
mirType
=
MIRType
:
:
Int32
;
*
mirWideningOp
=
MWideningOp
:
:
FromS16
;
return
;
case
FieldWideningOp
:
:
Unsigned
:
*
mirType
=
MIRType
:
:
Int32
;
*
mirWideningOp
=
MWideningOp
:
:
FromU16
;
return
;
default
:
MOZ_CRASH
(
)
;
}
}
default
:
{
switch
(
wideningOp
)
{
case
FieldWideningOp
:
:
None
:
*
mirType
=
type
.
toMIRType
(
)
;
*
mirWideningOp
=
MWideningOp
:
:
None
;
return
;
default
:
MOZ_CRASH
(
)
;
}
}
}
}
static
Scale
scaleFromFieldType
(
StorageType
type
)
{
if
(
type
.
kind
(
)
=
=
StorageType
:
:
V128
)
{
return
Scale
:
:
Invalid
;
}
return
ShiftToScale
(
type
.
indexingShift
(
)
)
;
}
static
MNarrowingOp
fieldStoreInfoToMIR
(
StorageType
type
)
{
switch
(
type
.
kind
(
)
)
{
case
StorageType
:
:
I8
:
return
MNarrowingOp
:
:
To8
;
case
StorageType
:
:
I16
:
return
MNarrowingOp
:
:
To16
;
default
:
return
MNarrowingOp
:
:
None
;
}
}
[
[
nodiscard
]
]
bool
writeGcValueAtBasePlusOffset
(
uint32_t
lineOrBytecode
StorageType
type
MDefinition
*
keepAlive
AliasSet
:
:
Flag
aliasBitset
MDefinition
*
value
MDefinition
*
base
uint32_t
offset
uint32_t
fieldIndex
bool
needsTrapInfo
WasmPreBarrierKind
preBarrierKind
)
{
MOZ_ASSERT
(
aliasBitset
!
=
0
)
;
MOZ_ASSERT
(
keepAlive
-
>
type
(
)
=
=
MIRType
:
:
WasmAnyRef
)
;
MOZ_ASSERT
(
type
.
widenToValType
(
)
.
toMIRType
(
)
=
=
value
-
>
type
(
)
)
;
MNarrowingOp
narrowingOp
=
fieldStoreInfoToMIR
(
type
)
;
if
(
!
type
.
isRefRepr
(
)
)
{
MaybeTrapSiteDesc
maybeTrap
;
if
(
needsTrapInfo
)
{
maybeTrap
.
emplace
(
trapSiteDesc
(
)
)
;
}
auto
*
store
=
MWasmStoreField
:
:
New
(
alloc
(
)
base
keepAlive
offset
mozilla
:
:
Some
(
fieldIndex
)
value
narrowingOp
AliasSet
:
:
Store
(
aliasBitset
)
maybeTrap
)
;
if
(
!
store
)
{
return
false
;
}
curBlock_
-
>
add
(
store
)
;
return
true
;
}
MOZ_ASSERT
(
narrowingOp
=
=
MNarrowingOp
:
:
None
)
;
MOZ_ASSERT
(
type
.
widenToValType
(
)
=
=
type
.
valType
(
)
)
;
auto
*
store
=
MWasmStoreFieldRef
:
:
New
(
alloc
(
)
instancePointer_
base
keepAlive
offset
mozilla
:
:
Some
(
fieldIndex
)
value
AliasSet
:
:
Store
(
aliasBitset
)
mozilla
:
:
Some
(
trapSiteDesc
(
)
)
preBarrierKind
)
;
if
(
!
store
)
{
return
false
;
}
curBlock_
-
>
add
(
store
)
;
return
postBarrierWholeCell
(
lineOrBytecode
keepAlive
value
)
;
}
[
[
nodiscard
]
]
bool
writeGcValueAtBasePlusScaledIndex
(
uint32_t
lineOrBytecode
StorageType
type
MDefinition
*
keepAlive
AliasSet
:
:
Flag
aliasBitset
MDefinition
*
value
MDefinition
*
base
uint32_t
scale
MDefinition
*
index
WasmPreBarrierKind
preBarrierKind
)
{
MOZ_ASSERT
(
aliasBitset
!
=
0
)
;
MOZ_ASSERT
(
keepAlive
-
>
type
(
)
=
=
MIRType
:
:
WasmAnyRef
)
;
MOZ_ASSERT
(
type
.
widenToValType
(
)
.
toMIRType
(
)
=
=
value
-
>
type
(
)
)
;
MOZ_ASSERT
(
scale
=
=
1
|
|
scale
=
=
2
|
|
scale
=
=
4
|
|
scale
=
=
8
|
|
scale
=
=
16
)
;
MNarrowingOp
narrowingOp
=
fieldStoreInfoToMIR
(
type
)
;
if
(
!
type
.
isRefRepr
(
)
)
{
MaybeTrapSiteDesc
maybeTrap
;
Scale
scale
=
scaleFromFieldType
(
type
)
;
auto
*
store
=
MWasmStoreElement
:
:
New
(
alloc
(
)
base
index
value
keepAlive
narrowingOp
scale
AliasSet
:
:
Store
(
aliasBitset
)
maybeTrap
)
;
if
(
!
store
)
{
return
false
;
}
curBlock_
-
>
add
(
store
)
;
return
true
;
}
MOZ_ASSERT
(
narrowingOp
=
=
MNarrowingOp
:
:
None
)
;
MOZ_ASSERT
(
type
.
widenToValType
(
)
=
=
type
.
valType
(
)
)
;
auto
*
store
=
MWasmStoreElementRef
:
:
New
(
alloc
(
)
instancePointer_
base
index
value
keepAlive
AliasSet
:
:
Store
(
aliasBitset
)
mozilla
:
:
Some
(
trapSiteDesc
(
)
)
preBarrierKind
)
;
if
(
!
store
)
{
return
false
;
}
curBlock_
-
>
add
(
store
)
;
return
postBarrierEdgeAtIndex
(
lineOrBytecode
keepAlive
base
index
sizeof
(
void
*
)
value
)
;
}
[
[
nodiscard
]
]
MDefinition
*
readGcValueAtBasePlusOffset
(
StorageType
type
FieldWideningOp
fieldWideningOp
MDefinition
*
keepAlive
AliasSet
:
:
Flag
aliasBitset
MDefinition
*
base
uint32_t
offset
uint32_t
fieldIndex
bool
needsTrapInfo
)
{
MOZ_ASSERT
(
aliasBitset
!
=
0
)
;
MOZ_ASSERT
(
keepAlive
-
>
type
(
)
=
=
MIRType
:
:
WasmAnyRef
)
;
MIRType
mirType
;
MWideningOp
mirWideningOp
;
fieldLoadInfoToMIR
(
type
fieldWideningOp
&
mirType
&
mirWideningOp
)
;
MaybeTrapSiteDesc
maybeTrap
;
if
(
needsTrapInfo
)
{
maybeTrap
.
emplace
(
trapSiteDesc
(
)
)
;
}
auto
*
load
=
MWasmLoadField
:
:
New
(
alloc
(
)
base
keepAlive
offset
mozilla
:
:
Some
(
fieldIndex
)
mirType
mirWideningOp
AliasSet
:
:
Load
(
aliasBitset
)
maybeTrap
type
.
toMaybeRefType
(
)
)
;
if
(
!
load
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
load
)
;
return
load
;
}
[
[
nodiscard
]
]
MDefinition
*
readGcArrayValueAtIndex
(
StorageType
type
FieldWideningOp
fieldWideningOp
MDefinition
*
keepAlive
AliasSet
:
:
Flag
aliasBitset
MDefinition
*
base
MDefinition
*
index
)
{
MOZ_ASSERT
(
aliasBitset
!
=
0
)
;
MOZ_ASSERT
(
keepAlive
-
>
type
(
)
=
=
MIRType
:
:
WasmAnyRef
)
;
MIRType
mirType
;
MWideningOp
mirWideningOp
;
fieldLoadInfoToMIR
(
type
fieldWideningOp
&
mirType
&
mirWideningOp
)
;
Scale
scale
=
scaleFromFieldType
(
type
)
;
auto
*
load
=
MWasmLoadElement
:
:
New
(
alloc
(
)
base
keepAlive
index
mirType
mirWideningOp
scale
AliasSet
:
:
Load
(
aliasBitset
)
mozilla
:
:
Some
(
trapSiteDesc
(
)
)
type
.
toMaybeRefType
(
)
)
;
if
(
!
load
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
load
)
;
return
load
;
}
[
[
nodiscard
]
]
MDefinition
*
loadSuperTypeVector
(
uint32_t
typeIndex
)
{
uint32_t
stvOffset
=
codeMeta
(
)
.
offsetOfSuperTypeVector
(
typeIndex
)
;
auto
*
load
=
MWasmLoadInstanceDataField
:
:
New
(
alloc
(
)
MIRType
:
:
Pointer
stvOffset
true
instancePointer_
)
;
if
(
!
load
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
load
)
;
return
load
;
}
uint32_t
readAllocSiteIndex
(
uint32_t
typeIndex
)
{
if
(
!
codeTailMeta
(
)
|
|
!
codeTailMeta
(
)
-
>
hasFuncDefAllocSites
(
)
)
{
return
typeIndex
;
}
AllocSitesRange
rangeInModule
=
codeTailMeta
(
)
-
>
getFuncDefAllocSites
(
funcIndex
(
)
)
;
uint32_t
localIndex
=
numAllocSites_
+
+
;
MOZ_RELEASE_ASSERT
(
localIndex
<
rangeInModule
.
length
)
;
return
rangeInModule
.
begin
+
localIndex
;
}
[
[
nodiscard
]
]
MDefinition
*
loadAllocSiteInstanceData
(
uint32_t
allocSiteIndex
)
{
auto
*
allocSites
=
MWasmLoadInstance
:
:
New
(
alloc
(
)
instancePointer_
Instance
:
:
offsetOfAllocSites
(
)
MIRType
:
:
Pointer
AliasSet
:
:
None
(
)
)
;
if
(
!
allocSites
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
allocSites
)
;
auto
*
result
=
MWasmDerivedPointer
:
:
New
(
alloc
(
)
allocSites
allocSiteIndex
*
sizeof
(
gc
:
:
AllocSite
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
result
)
;
return
result
;
}
[
[
nodiscard
]
]
MDefinition
*
createStructObject
(
uint32_t
typeIndex
uint32_t
allocSiteIndex
bool
zeroFields
)
{
MDefinition
*
allocSite
=
loadAllocSiteInstanceData
(
allocSiteIndex
)
;
if
(
!
allocSite
)
{
return
nullptr
;
}
const
TypeDef
*
typeDef
=
&
(
*
codeMeta
(
)
.
types
)
[
typeIndex
]
;
auto
*
structObject
=
MWasmNewStructObject
:
:
New
(
alloc
(
)
instancePointer_
allocSite
typeDef
zeroFields
trapSiteDesc
(
)
)
;
if
(
!
structObject
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
structObject
)
;
return
structObject
;
}
[
[
nodiscard
]
]
bool
writeValueToStructField
(
uint32_t
lineOrBytecode
const
StructType
&
structType
uint32_t
fieldIndex
MDefinition
*
structObject
MDefinition
*
value
WasmPreBarrierKind
preBarrierKind
)
{
StorageType
fieldType
=
structType
.
fields_
[
fieldIndex
]
.
type
;
uint32_t
fieldOffset
=
structType
.
fieldOffset
(
fieldIndex
)
;
bool
areaIsOutline
;
uint32_t
areaOffset
;
WasmStructObject
:
:
fieldOffsetToAreaAndOffset
(
fieldType
fieldOffset
&
areaIsOutline
&
areaOffset
)
;
MDefinition
*
base
;
bool
needsTrapInfo
;
if
(
areaIsOutline
)
{
auto
*
loadDataPointer
=
MWasmLoadField
:
:
New
(
alloc
(
)
structObject
nullptr
WasmStructObject
:
:
offsetOfOutlineData
(
)
mozilla
:
:
Nothing
(
)
MIRType
:
:
Pointer
MWideningOp
:
:
None
AliasSet
:
:
Load
(
AliasSet
:
:
WasmStructOutlineDataPointer
)
mozilla
:
:
Some
(
trapSiteDesc
(
)
)
)
;
if
(
!
loadDataPointer
)
{
return
false
;
}
curBlock_
-
>
add
(
loadDataPointer
)
;
base
=
loadDataPointer
;
needsTrapInfo
=
false
;
}
else
{
base
=
structObject
;
needsTrapInfo
=
true
;
areaOffset
+
=
WasmStructObject
:
:
offsetOfInlineData
(
)
;
}
AliasSet
:
:
Flag
fieldAliasSet
=
areaIsOutline
?
AliasSet
:
:
WasmStructOutlineDataArea
:
AliasSet
:
:
WasmStructInlineDataArea
;
return
writeGcValueAtBasePlusOffset
(
lineOrBytecode
fieldType
structObject
fieldAliasSet
value
base
areaOffset
fieldIndex
needsTrapInfo
preBarrierKind
)
;
}
[
[
nodiscard
]
]
MDefinition
*
readValueFromStructField
(
const
StructType
&
structType
uint32_t
fieldIndex
FieldWideningOp
wideningOp
MDefinition
*
structObject
)
{
StorageType
fieldType
=
structType
.
fields_
[
fieldIndex
]
.
type
;
uint32_t
fieldOffset
=
structType
.
fieldOffset
(
fieldIndex
)
;
bool
areaIsOutline
;
uint32_t
areaOffset
;
WasmStructObject
:
:
fieldOffsetToAreaAndOffset
(
fieldType
fieldOffset
&
areaIsOutline
&
areaOffset
)
;
MDefinition
*
base
;
bool
needsTrapInfo
;
if
(
areaIsOutline
)
{
auto
*
loadDataPointer
=
MWasmLoadField
:
:
New
(
alloc
(
)
structObject
nullptr
WasmStructObject
:
:
offsetOfOutlineData
(
)
mozilla
:
:
Nothing
(
)
MIRType
:
:
Pointer
MWideningOp
:
:
None
AliasSet
:
:
Load
(
AliasSet
:
:
WasmStructOutlineDataPointer
)
mozilla
:
:
Some
(
trapSiteDesc
(
)
)
)
;
if
(
!
loadDataPointer
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
loadDataPointer
)
;
base
=
loadDataPointer
;
needsTrapInfo
=
false
;
}
else
{
base
=
structObject
;
needsTrapInfo
=
true
;
areaOffset
+
=
WasmStructObject
:
:
offsetOfInlineData
(
)
;
}
AliasSet
:
:
Flag
fieldAliasSet
=
areaIsOutline
?
AliasSet
:
:
WasmStructOutlineDataArea
:
AliasSet
:
:
WasmStructInlineDataArea
;
return
readGcValueAtBasePlusOffset
(
fieldType
wideningOp
structObject
fieldAliasSet
base
areaOffset
fieldIndex
needsTrapInfo
)
;
}
inline
bool
targetIs64Bit
(
)
const
{
#
ifdef
JS_64BIT
return
true
;
#
else
return
false
;
#
endif
}
[
[
nodiscard
]
]
MDefinition
*
unsignedWidenToTargetWord
(
MDefinition
*
val
)
{
if
(
targetIs64Bit
(
)
)
{
if
(
val
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
{
auto
*
ext
=
MExtendInt32ToInt64
:
:
New
(
alloc
(
)
val
true
)
;
if
(
!
ext
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
ext
)
;
return
ext
;
}
MOZ_ASSERT
(
val
-
>
type
(
)
=
=
MIRType
:
:
Int64
)
;
return
val
;
}
MOZ_ASSERT
(
val
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
return
val
;
}
[
[
nodiscard
]
]
MDefinition
*
getWasmArrayObjectNumElements
(
MDefinition
*
arrayObject
)
{
MOZ_ASSERT
(
arrayObject
-
>
type
(
)
=
=
MIRType
:
:
WasmAnyRef
)
;
auto
*
numElements
=
MWasmLoadField
:
:
New
(
alloc
(
)
arrayObject
nullptr
WasmArrayObject
:
:
offsetOfNumElements
(
)
mozilla
:
:
Nothing
(
)
MIRType
:
:
Int32
MWideningOp
:
:
None
AliasSet
:
:
Load
(
AliasSet
:
:
WasmArrayNumElements
)
mozilla
:
:
Some
(
trapSiteDesc
(
)
)
)
;
if
(
!
numElements
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
numElements
)
;
return
numElements
;
}
[
[
nodiscard
]
]
MDefinition
*
getWasmArrayObjectData
(
MDefinition
*
arrayObject
)
{
MOZ_ASSERT
(
arrayObject
-
>
type
(
)
=
=
MIRType
:
:
WasmAnyRef
)
;
auto
*
data
=
MWasmLoadField
:
:
New
(
alloc
(
)
arrayObject
nullptr
WasmArrayObject
:
:
offsetOfData
(
)
mozilla
:
:
Nothing
(
)
MIRType
:
:
WasmArrayData
MWideningOp
:
:
None
AliasSet
:
:
Load
(
AliasSet
:
:
WasmArrayDataPointer
)
mozilla
:
:
Some
(
trapSiteDesc
(
)
)
)
;
if
(
!
data
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
data
)
;
return
data
;
}
[
[
nodiscard
]
]
MDefinition
*
createArrayObject
(
uint32_t
typeIndex
uint32_t
allocSiteIndex
MDefinition
*
numElements
bool
zeroFields
)
{
MDefinition
*
allocSite
=
loadAllocSiteInstanceData
(
allocSiteIndex
)
;
if
(
!
allocSite
)
{
return
nullptr
;
}
const
TypeDef
*
typeDef
=
&
(
*
codeMeta
(
)
.
types
)
[
typeIndex
]
;
auto
*
arrayObject
=
MWasmNewArrayObject
:
:
New
(
alloc
(
)
instancePointer_
numElements
allocSite
typeDef
zeroFields
trapSiteDesc
(
)
)
;
if
(
!
arrayObject
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
arrayObject
)
;
return
arrayObject
;
}
[
[
nodiscard
]
]
MDefinition
*
setupForArrayAccess
(
MDefinition
*
arrayObject
MDefinition
*
index
)
{
MOZ_ASSERT
(
arrayObject
-
>
type
(
)
=
=
MIRType
:
:
WasmAnyRef
)
;
MOZ_ASSERT
(
index
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
MDefinition
*
numElements
=
getWasmArrayObjectNumElements
(
arrayObject
)
;
if
(
!
numElements
)
{
return
nullptr
;
}
auto
*
boundsCheck
=
MWasmBoundsCheck
:
:
New
(
alloc
(
)
index
numElements
trapSiteDesc
(
)
MWasmBoundsCheck
:
:
Target
:
:
Unknown
)
;
if
(
!
boundsCheck
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
boundsCheck
)
;
return
getWasmArrayObjectData
(
arrayObject
)
;
}
[
[
nodiscard
]
]
bool
fillArray
(
uint32_t
lineOrBytecode
const
ArrayType
&
arrayType
MDefinition
*
arrayObject
MDefinition
*
index
MDefinition
*
numElements
MDefinition
*
val
WasmPreBarrierKind
preBarrierKind
)
{
mozilla
:
:
DebugOnly
<
MIRType
>
valMIRType
=
val
-
>
type
(
)
;
StorageType
elemType
=
arrayType
.
elementType
(
)
;
MOZ_ASSERT
(
elemType
.
widenToValType
(
)
.
toMIRType
(
)
=
=
valMIRType
)
;
uint32_t
elemSize
=
elemType
.
size
(
)
;
MOZ_ASSERT
(
elemSize
>
=
1
&
&
elemSize
<
=
16
)
;
MDefinition
*
arrayBase
=
getWasmArrayObjectData
(
arrayObject
)
;
if
(
!
arrayBase
)
{
return
false
;
}
MBasicBlock
*
loopBlock
;
if
(
!
newBlock
(
curBlock_
&
loopBlock
MBasicBlock
:
:
LOOP_HEADER
)
)
{
return
false
;
}
MBasicBlock
*
afterBlock
;
if
(
!
newBlock
(
loopBlock
&
afterBlock
)
)
{
return
false
;
}
MAdd
*
limit
=
MAdd
:
:
NewWasm
(
alloc
(
)
index
numElements
MIRType
:
:
Int32
)
;
if
(
!
limit
)
{
return
false
;
}
curBlock_
-
>
add
(
limit
)
;
MDefinition
*
limitEqualsBase
=
compare
(
limit
index
JSOp
:
:
StrictEq
MCompare
:
:
Compare_UInt32
)
;
if
(
!
limitEqualsBase
)
{
return
false
;
}
MTest
*
skipIfLimitEqualsBase
=
MTest
:
:
New
(
alloc
(
)
limitEqualsBase
afterBlock
loopBlock
)
;
if
(
!
skipIfLimitEqualsBase
)
{
return
false
;
}
curBlock_
-
>
end
(
skipIfLimitEqualsBase
)
;
if
(
!
afterBlock
-
>
addPredecessor
(
alloc
(
)
curBlock_
)
)
{
return
false
;
}
curBlock_
=
loopBlock
;
MPhi
*
indexPhi
=
MPhi
:
:
New
(
alloc
(
)
MIRType
:
:
Int32
)
;
if
(
!
indexPhi
)
{
return
false
;
}
if
(
!
indexPhi
-
>
reserveLength
(
2
)
)
{
return
false
;
}
indexPhi
-
>
addInput
(
index
)
;
curBlock_
-
>
addPhi
(
indexPhi
)
;
curBlock_
-
>
setLoopDepth
(
rootCompiler_
.
loopDepth
(
)
+
1
)
;
if
(
!
writeGcValueAtBasePlusScaledIndex
(
lineOrBytecode
elemType
arrayObject
AliasSet
:
:
WasmArrayDataArea
val
arrayBase
elemSize
indexPhi
preBarrierKind
)
)
{
return
false
;
}
auto
*
indexNext
=
MAdd
:
:
NewWasm
(
alloc
(
)
indexPhi
constantI32
(
1
)
MIRType
:
:
Int32
)
;
if
(
!
indexNext
)
{
return
false
;
}
curBlock_
-
>
add
(
indexNext
)
;
indexPhi
-
>
addInput
(
indexNext
)
;
MDefinition
*
indexNextLtuLimit
=
compare
(
indexNext
limit
JSOp
:
:
Lt
MCompare
:
:
Compare_UInt32
)
;
if
(
!
indexNextLtuLimit
)
{
return
false
;
}
auto
*
continueIfIndexNextLtuLimit
=
MTest
:
:
New
(
alloc
(
)
indexNextLtuLimit
loopBlock
afterBlock
)
;
if
(
!
continueIfIndexNextLtuLimit
)
{
return
false
;
}
curBlock_
-
>
end
(
continueIfIndexNextLtuLimit
)
;
if
(
!
loopBlock
-
>
addPredecessor
(
alloc
(
)
loopBlock
)
)
{
return
false
;
}
curBlock_
=
afterBlock
;
return
true
;
}
[
[
nodiscard
]
]
MDefinition
*
createArrayNewCallAndLoop
(
uint32_t
lineOrBytecode
uint32_t
typeIndex
uint32_t
allocSiteIndex
MDefinition
*
numElements
MDefinition
*
fillValue
)
{
MDefinition
*
arrayObject
=
createArrayObject
(
typeIndex
allocSiteIndex
numElements
false
)
;
if
(
!
arrayObject
)
{
return
nullptr
;
}
const
ArrayType
&
arrayType
=
(
*
codeMeta
(
)
.
types
)
[
typeIndex
]
.
arrayType
(
)
;
if
(
!
fillArray
(
lineOrBytecode
arrayType
arrayObject
constantI32
(
0
)
numElements
fillValue
WasmPreBarrierKind
:
:
None
)
)
{
return
nullptr
;
}
return
arrayObject
;
}
[
[
nodiscard
]
]
bool
createArrayCopy
(
uint32_t
lineOrBytecode
MDefinition
*
dstArrayObject
MDefinition
*
dstArrayIndex
MDefinition
*
srcArrayObject
MDefinition
*
srcArrayIndex
MDefinition
*
numElements
int32_t
elemSize
bool
elemsAreRefTyped
)
{
MDefinition
*
dstNumElements
=
getWasmArrayObjectNumElements
(
dstArrayObject
)
;
if
(
!
dstNumElements
)
{
return
false
;
}
MDefinition
*
srcNumElements
=
getWasmArrayObjectNumElements
(
srcArrayObject
)
;
if
(
!
srcNumElements
)
{
return
false
;
}
MInstruction
*
dstBoundsCheck
=
MWasmBoundsCheckRange32
:
:
New
(
alloc
(
)
dstArrayIndex
numElements
dstNumElements
trapSiteDesc
(
)
)
;
if
(
!
dstBoundsCheck
)
{
return
false
;
}
curBlock_
-
>
add
(
dstBoundsCheck
)
;
MInstruction
*
srcBoundsCheck
=
MWasmBoundsCheckRange32
:
:
New
(
alloc
(
)
srcArrayIndex
numElements
srcNumElements
trapSiteDesc
(
)
)
;
if
(
!
srcBoundsCheck
)
{
return
false
;
}
curBlock_
-
>
add
(
srcBoundsCheck
)
;
MBasicBlock
*
copyBlock
=
nullptr
;
if
(
!
newBlock
(
curBlock_
&
copyBlock
)
)
{
return
false
;
}
MBasicBlock
*
joinBlock
=
nullptr
;
if
(
!
newBlock
(
curBlock_
&
joinBlock
)
)
{
return
false
;
}
MInstruction
*
condition
=
MCompare
:
:
NewWasm
(
alloc
(
)
numElements
constantI32
(
0
)
JSOp
:
:
StrictEq
MCompare
:
:
Compare_UInt32
)
;
curBlock_
-
>
add
(
condition
)
;
MTest
*
test
=
MTest
:
:
New
(
alloc
(
)
condition
joinBlock
copyBlock
)
;
if
(
!
test
)
{
return
false
;
}
curBlock_
-
>
end
(
test
)
;
curBlock_
=
copyBlock
;
MInstruction
*
dstData
=
MWasmLoadField
:
:
New
(
alloc
(
)
dstArrayObject
nullptr
WasmArrayObject
:
:
offsetOfData
(
)
mozilla
:
:
Nothing
(
)
MIRType
:
:
WasmArrayData
MWideningOp
:
:
None
AliasSet
:
:
Load
(
AliasSet
:
:
WasmArrayDataPointer
)
)
;
if
(
!
dstData
)
{
return
false
;
}
curBlock_
-
>
add
(
dstData
)
;
MInstruction
*
srcData
=
MWasmLoadField
:
:
New
(
alloc
(
)
srcArrayObject
nullptr
WasmArrayObject
:
:
offsetOfData
(
)
mozilla
:
:
Nothing
(
)
MIRType
:
:
WasmArrayData
MWideningOp
:
:
None
AliasSet
:
:
Load
(
AliasSet
:
:
WasmArrayDataPointer
)
)
;
if
(
!
srcData
)
{
return
false
;
}
curBlock_
-
>
add
(
srcData
)
;
if
(
elemsAreRefTyped
)
{
MOZ_RELEASE_ASSERT
(
elemSize
=
=
sizeof
(
void
*
)
)
;
if
(
!
builtinCall5
(
SASigArrayRefsMove
lineOrBytecode
dstData
dstArrayIndex
srcData
srcArrayIndex
numElements
nullptr
)
)
{
return
false
;
}
}
else
{
MDefinition
*
elemSizeDef
=
constantI32
(
elemSize
)
;
if
(
!
elemSizeDef
)
{
return
false
;
}
if
(
!
builtinCall6
(
SASigArrayMemMove
lineOrBytecode
dstData
dstArrayIndex
srcData
srcArrayIndex
elemSizeDef
numElements
nullptr
)
)
{
return
false
;
}
}
MGoto
*
fallthrough
=
MGoto
:
:
New
(
alloc
(
)
joinBlock
)
;
if
(
!
fallthrough
)
{
return
false
;
}
curBlock_
-
>
end
(
fallthrough
)
;
if
(
!
joinBlock
-
>
addPredecessor
(
alloc
(
)
curBlock_
)
)
{
return
false
;
}
curBlock_
=
joinBlock
;
return
true
;
}
[
[
nodiscard
]
]
bool
createArrayFill
(
uint32_t
lineOrBytecode
uint32_t
typeIndex
MDefinition
*
arrayObject
MDefinition
*
index
MDefinition
*
val
MDefinition
*
numElements
)
{
MOZ_ASSERT
(
arrayObject
-
>
type
(
)
=
=
MIRType
:
:
WasmAnyRef
)
;
MOZ_ASSERT
(
index
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
MOZ_ASSERT
(
numElements
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
const
ArrayType
&
arrayType
=
(
*
codeMeta
(
)
.
types
)
[
typeIndex
]
.
arrayType
(
)
;
MDefinition
*
actualNumElements
=
getWasmArrayObjectNumElements
(
arrayObject
)
;
if
(
!
actualNumElements
)
{
return
false
;
}
auto
*
boundsCheck
=
MWasmBoundsCheckRange32
:
:
New
(
alloc
(
)
index
numElements
actualNumElements
trapSiteDesc
(
)
)
;
if
(
!
boundsCheck
)
{
return
false
;
}
curBlock_
-
>
add
(
boundsCheck
)
;
return
fillArray
(
lineOrBytecode
arrayType
arrayObject
index
numElements
val
WasmPreBarrierKind
:
:
Normal
)
;
}
[
[
nodiscard
]
]
bool
trapIfZero
(
wasm
:
:
Trap
trapKind
MDefinition
*
arg
)
{
MOZ_ASSERT
(
arg
-
>
type
(
)
=
=
MIRType
:
:
Int32
)
;
MBasicBlock
*
trapBlock
=
nullptr
;
if
(
!
newBlock
(
curBlock_
&
trapBlock
)
)
{
return
false
;
}
auto
*
trap
=
MWasmTrap
:
:
New
(
alloc
(
)
trapKind
trapSiteDesc
(
)
)
;
if
(
!
trap
)
{
return
false
;
}
trapBlock
-
>
end
(
trap
)
;
MBasicBlock
*
joinBlock
=
nullptr
;
if
(
!
newBlock
(
curBlock_
&
joinBlock
)
)
{
return
false
;
}
auto
*
test
=
MTest
:
:
New
(
alloc
(
)
arg
joinBlock
trapBlock
)
;
if
(
!
test
)
{
return
false
;
}
curBlock_
-
>
end
(
test
)
;
curBlock_
=
joinBlock
;
return
true
;
}
[
[
nodiscard
]
]
MDefinition
*
refCast
(
MDefinition
*
ref
RefType
destType
)
{
MInstruction
*
cast
=
nullptr
;
if
(
destType
.
isTypeRef
(
)
)
{
uint32_t
typeIndex
=
codeMeta
(
)
.
types
-
>
indexOf
(
*
destType
.
typeDef
(
)
)
;
MDefinition
*
superSTV
=
loadSuperTypeVector
(
typeIndex
)
;
if
(
!
superSTV
)
{
return
nullptr
;
}
cast
=
MWasmRefCastConcrete
:
:
New
(
alloc
(
)
ref
superSTV
destType
trapSiteDesc
(
)
)
;
}
else
{
cast
=
MWasmRefCastAbstract
:
:
New
(
alloc
(
)
ref
destType
trapSiteDesc
(
)
)
;
}
if
(
!
cast
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
cast
)
;
return
cast
;
}
[
[
nodiscard
]
]
MDefinition
*
refTest
(
MDefinition
*
ref
RefType
destType
)
{
MInstruction
*
isSubTypeOf
=
nullptr
;
if
(
destType
.
isTypeRef
(
)
)
{
uint32_t
typeIndex
=
codeMeta
(
)
.
types
-
>
indexOf
(
*
destType
.
typeDef
(
)
)
;
MDefinition
*
superSTV
=
loadSuperTypeVector
(
typeIndex
)
;
if
(
!
superSTV
)
{
return
nullptr
;
}
isSubTypeOf
=
MWasmRefTestConcrete
:
:
New
(
alloc
(
)
ref
superSTV
destType
)
;
}
else
{
isSubTypeOf
=
MWasmRefTestAbstract
:
:
New
(
alloc
(
)
ref
destType
)
;
}
MOZ_ASSERT
(
isSubTypeOf
)
;
curBlock_
-
>
add
(
isSubTypeOf
)
;
return
isSubTypeOf
;
}
[
[
nodiscard
]
]
bool
brOnCastCommon
(
bool
onSuccess
uint32_t
labelRelativeDepth
RefType
sourceType
RefType
destType
const
ResultType
&
labelType
const
DefVector
&
values
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
MBasicBlock
*
fallthroughBlock
=
nullptr
;
if
(
!
newBlock
(
curBlock_
&
fallthroughBlock
)
)
{
return
false
;
}
MOZ_RELEASE_ASSERT
(
values
.
length
(
)
>
0
)
;
MDefinition
*
ref
=
values
.
back
(
)
;
MOZ_ASSERT
(
ref
-
>
type
(
)
=
=
MIRType
:
:
WasmAnyRef
)
;
MDefinition
*
success
=
refTest
(
ref
destType
)
;
if
(
!
success
)
{
return
false
;
}
MTest
*
test
;
if
(
onSuccess
)
{
test
=
MTest
:
:
New
(
alloc
(
)
success
nullptr
fallthroughBlock
)
;
if
(
!
test
|
|
!
addControlFlowPatch
(
test
labelRelativeDepth
MTest
:
:
TrueBranchIndex
)
)
{
return
false
;
}
}
else
{
test
=
MTest
:
:
New
(
alloc
(
)
success
fallthroughBlock
nullptr
)
;
if
(
!
test
|
|
!
addControlFlowPatch
(
test
labelRelativeDepth
MTest
:
:
FalseBranchIndex
)
)
{
return
false
;
}
}
if
(
!
pushDefs
(
values
)
)
{
return
false
;
}
curBlock_
-
>
end
(
test
)
;
curBlock_
=
fallthroughBlock
;
return
true
;
}
[
[
nodiscard
]
]
bool
brOnNonStruct
(
const
DefVector
&
values
)
{
if
(
inDeadCode
(
)
)
{
return
true
;
}
MBasicBlock
*
fallthroughBlock
=
nullptr
;
if
(
!
newBlock
(
curBlock_
&
fallthroughBlock
)
)
{
return
false
;
}
MOZ_ASSERT
(
values
.
length
(
)
>
0
)
;
MOZ_ASSERT
(
values
.
back
(
)
-
>
type
(
)
=
=
MIRType
:
:
WasmAnyRef
)
;
MGoto
*
jump
=
MGoto
:
:
New
(
alloc
(
)
fallthroughBlock
)
;
if
(
!
jump
)
{
return
false
;
}
if
(
!
pushDefs
(
values
)
)
{
return
false
;
}
curBlock_
-
>
end
(
jump
)
;
curBlock_
=
fallthroughBlock
;
return
true
;
}
[
[
nodiscard
]
]
MDefinition
*
convertAnyExtern
(
MDefinition
*
ref
wasm
:
:
RefType
:
:
Kind
kind
)
{
auto
*
converted
=
MWasmRefConvertAnyExtern
:
:
New
(
alloc
(
)
ref
kind
)
;
if
(
!
converted
)
{
return
nullptr
;
}
curBlock_
-
>
add
(
converted
)
;
return
converted
;
}
uint32_t
readCallSiteLineOrBytecode
(
)
{
if
(
!
func_
.
callSiteLineNums
.
empty
(
)
)
{
return
func_
.
callSiteLineNums
[
lastReadCallSite_
+
+
]
;
}
return
iter_
.
lastOpcodeOffset
(
)
;
}
uint32_t
readBytecodeOffset
(
)
{
return
iter_
.
lastOpcodeOffset
(
)
;
}
CallRefHint
readCallRefHint
(
)
{
if
(
compilerEnv
(
)
.
mode
(
)
!
=
CompileMode
:
:
LazyTiering
)
{
return
CallRefHint
(
)
;
}
CallRefMetricsRange
rangeInModule
=
codeTailMeta
(
)
-
>
getFuncDefCallRefs
(
funcIndex
(
)
)
;
uint32_t
localIndex
=
numCallRefs_
+
+
;
MOZ_RELEASE_ASSERT
(
localIndex
<
rangeInModule
.
length
)
;
uint32_t
moduleIndex
=
rangeInModule
.
begin
+
localIndex
;
return
codeTailMeta
(
)
-
>
getCallRefHint
(
moduleIndex
)
;
}
#
if
DEBUG
bool
done
(
)
const
{
return
iter_
.
done
(
)
;
}
#
endif
private
:
[
[
nodiscard
]
]
bool
newBlock
(
MBasicBlock
*
pred
MBasicBlock
*
*
block
MBasicBlock
:
:
Kind
kind
=
MBasicBlock
:
:
NORMAL
)
{
*
block
=
MBasicBlock
:
:
New
(
mirGraph
(
)
info
(
)
pred
kind
)
;
if
(
!
*
block
)
{
return
false
;
}
mirGraph
(
)
.
addBlock
(
*
block
)
;
(
*
block
)
-
>
setLoopDepth
(
rootCompiler_
.
loopDepth
(
)
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
goToNewBlock
(
MBasicBlock
*
pred
MBasicBlock
*
*
block
)
{
if
(
!
newBlock
(
pred
block
)
)
{
return
false
;
}
pred
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
*
block
)
)
;
return
true
;
}
[
[
nodiscard
]
]
bool
goToExistingBlock
(
MBasicBlock
*
prev
MBasicBlock
*
next
)
{
MOZ_ASSERT
(
prev
)
;
MOZ_ASSERT
(
next
)
;
prev
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
next
)
)
;
return
next
-
>
addPredecessor
(
alloc
(
)
prev
)
;
}
[
[
nodiscard
]
]
bool
bindBranches
(
uint32_t
absolute
DefVector
*
defs
)
{
if
(
absolute
>
=
pendingBlocks_
.
length
(
)
|
|
pendingBlocks_
[
absolute
]
.
patches
.
empty
(
)
)
{
return
inDeadCode
(
)
|
|
popPushedDefs
(
defs
)
;
}
ControlFlowPatchVector
&
patches
=
pendingBlocks_
[
absolute
]
.
patches
;
MControlInstruction
*
ins
=
patches
[
0
]
.
ins
;
MBasicBlock
*
pred
=
ins
-
>
block
(
)
;
MBasicBlock
*
join
=
nullptr
;
if
(
!
newBlock
(
pred
&
join
)
)
{
return
false
;
}
if
(
pendingBlocks_
[
absolute
]
.
hint
!
=
BranchHint
:
:
Invalid
)
{
join
-
>
setBranchHinting
(
pendingBlocks_
[
absolute
]
.
hint
)
;
}
pred
-
>
mark
(
)
;
ins
-
>
replaceSuccessor
(
patches
[
0
]
.
index
join
)
;
for
(
size_t
i
=
1
;
i
<
patches
.
length
(
)
;
i
+
+
)
{
ins
=
patches
[
i
]
.
ins
;
pred
=
ins
-
>
block
(
)
;
if
(
!
pred
-
>
isMarked
(
)
)
{
if
(
!
join
-
>
addPredecessor
(
alloc
(
)
pred
)
)
{
return
false
;
}
pred
-
>
mark
(
)
;
}
ins
-
>
replaceSuccessor
(
patches
[
i
]
.
index
join
)
;
}
MOZ_ASSERT_IF
(
curBlock_
!
curBlock_
-
>
isMarked
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
join
-
>
numPredecessors
(
)
;
i
+
+
)
{
join
-
>
getPredecessor
(
i
)
-
>
unmark
(
)
;
}
if
(
curBlock_
&
&
!
goToExistingBlock
(
curBlock_
join
)
)
{
return
false
;
}
curBlock_
=
join
;
if
(
!
popPushedDefs
(
defs
)
)
{
return
false
;
}
patches
.
clear
(
)
;
return
true
;
}
bool
emitI32Const
(
)
;
bool
emitI64Const
(
)
;
bool
emitF32Const
(
)
;
bool
emitF64Const
(
)
;
bool
emitBlock
(
)
;
bool
emitLoop
(
)
;
bool
emitIf
(
)
;
bool
emitElse
(
)
;
bool
emitEnd
(
)
;
bool
emitBr
(
)
;
bool
emitBrIf
(
)
;
bool
emitBrTable
(
)
;
bool
emitReturn
(
)
;
bool
emitUnreachable
(
)
;
bool
emitTry
(
)
;
bool
emitCatch
(
)
;
bool
emitCatchAll
(
)
;
bool
emitTryTable
(
)
;
bool
emitDelegate
(
)
;
bool
emitThrow
(
)
;
bool
emitThrowRef
(
)
;
bool
emitRethrow
(
)
;
bool
emitInlineCall
(
const
FuncType
&
funcType
uint32_t
funcIndex
InliningHeuristics
:
:
CallKind
callKind
const
DefVector
&
args
DefVector
*
results
)
;
bool
emitCall
(
bool
asmJSFuncDef
)
;
bool
emitCallIndirect
(
bool
oldStyle
)
;
bool
emitStackSwitch
(
)
;
bool
emitReturnCall
(
)
;
bool
emitReturnCallIndirect
(
)
;
bool
emitReturnCallRef
(
)
;
bool
emitGetLocal
(
)
;
bool
emitSetLocal
(
)
;
bool
emitTeeLocal
(
)
;
bool
emitGetGlobal
(
)
;
bool
emitSetGlobal
(
)
;
bool
emitTeeGlobal
(
)
;
template
<
typename
MIRClass
>
bool
emitUnary
(
ValType
operandType
)
;
template
<
typename
MIRClass
>
bool
emitConversion
(
ValType
operandType
ValType
resultType
)
;
template
<
typename
MIRClass
>
bool
emitUnaryWithType
(
ValType
operandType
MIRType
mirType
)
;
template
<
typename
MIRClass
>
bool
emitConversionWithType
(
ValType
operandType
ValType
resultType
MIRType
mirType
)
;
bool
emitTruncate
(
ValType
operandType
ValType
resultType
bool
isUnsigned
bool
isSaturating
)
;
bool
emitSignExtend
(
uint32_t
srcSize
uint32_t
targetSize
)
;
bool
emitExtendI32
(
bool
isUnsigned
)
;
bool
emitConvertI64ToFloatingPoint
(
ValType
resultType
MIRType
mirType
bool
isUnsigned
)
;
bool
emitReinterpret
(
ValType
resultType
ValType
operandType
MIRType
mirType
)
;
bool
emitAdd
(
ValType
type
MIRType
mirType
)
;
bool
emitSub
(
ValType
type
MIRType
mirType
)
;
bool
emitRotate
(
ValType
type
bool
isLeftRotation
)
;
bool
emitBitNot
(
ValType
operandType
MIRType
mirType
)
;
bool
emitBitwiseAndOrXor
(
ValType
operandType
MIRType
mirType
MWasmBinaryBitwise
:
:
SubOpcode
subOpc
)
;
template
<
typename
MIRClass
>
bool
emitShift
(
ValType
operandType
MIRType
mirType
)
;
bool
emitUrsh
(
ValType
operandType
MIRType
mirType
)
;
bool
emitMul
(
ValType
operandType
MIRType
mirType
)
;
bool
emitDiv
(
ValType
operandType
MIRType
mirType
bool
isUnsigned
)
;
bool
emitRem
(
ValType
operandType
MIRType
mirType
bool
isUnsigned
)
;
bool
emitMinMax
(
ValType
operandType
MIRType
mirType
bool
isMax
)
;
bool
emitCopySign
(
ValType
operandType
)
;
bool
emitComparison
(
ValType
operandType
JSOp
compareOp
MCompare
:
:
CompareType
compareType
)
;
bool
emitSelect
(
bool
typed
)
;
bool
emitLoad
(
ValType
type
Scalar
:
:
Type
viewType
)
;
bool
emitStore
(
ValType
resultType
Scalar
:
:
Type
viewType
)
;
bool
emitTeeStore
(
ValType
resultType
Scalar
:
:
Type
viewType
)
;
bool
emitTeeStoreWithCoercion
(
ValType
resultType
Scalar
:
:
Type
viewType
)
;
bool
tryInlineUnaryBuiltin
(
SymbolicAddress
callee
MDefinition
*
input
)
;
bool
emitUnaryMathBuiltinCall
(
const
SymbolicAddressSignature
&
callee
)
;
bool
emitBinaryMathBuiltinCall
(
const
SymbolicAddressSignature
&
callee
)
;
bool
emitMemoryGrow
(
)
;
bool
emitMemorySize
(
)
;
bool
emitAtomicCmpXchg
(
ValType
type
Scalar
:
:
Type
viewType
)
;
bool
emitAtomicLoad
(
ValType
type
Scalar
:
:
Type
viewType
)
;
bool
emitAtomicRMW
(
ValType
type
Scalar
:
:
Type
viewType
jit
:
:
AtomicOp
op
)
;
bool
emitAtomicStore
(
ValType
type
Scalar
:
:
Type
viewType
)
;
bool
emitWait
(
ValType
type
uint32_t
byteSize
)
;
bool
emitFence
(
)
;
bool
emitNotify
(
)
;
bool
emitAtomicXchg
(
ValType
type
Scalar
:
:
Type
viewType
)
;
bool
emitMemCopyCall
(
uint32_t
dstMemIndex
uint32_t
srcMemIndex
MDefinition
*
dst
MDefinition
*
src
MDefinition
*
len
)
;
bool
emitMemCopyInline
(
uint32_t
memoryIndex
MDefinition
*
dst
MDefinition
*
src
uint32_t
length
)
;
bool
emitMemCopy
(
)
;
bool
emitTableCopy
(
)
;
bool
emitDataOrElemDrop
(
bool
isData
)
;
bool
emitMemFillCall
(
uint32_t
memoryIndex
MDefinition
*
start
MDefinition
*
val
MDefinition
*
len
)
;
bool
emitMemFillInline
(
uint32_t
memoryIndex
MDefinition
*
start
MDefinition
*
val
uint32_t
length
)
;
bool
emitMemFill
(
)
;
bool
emitMemInit
(
)
;
bool
emitTableInit
(
)
;
bool
emitTableFill
(
)
;
bool
emitMemDiscard
(
)
;
bool
emitTableGet
(
)
;
bool
emitTableGrow
(
)
;
bool
emitTableSet
(
)
;
bool
emitTableSize
(
)
;
bool
emitRefFunc
(
)
;
bool
emitRefNull
(
)
;
bool
emitRefIsNull
(
)
;
bool
emitConstSimd128
(
)
;
bool
emitBinarySimd128
(
bool
commutative
SimdOp
op
)
;
bool
emitTernarySimd128
(
wasm
:
:
SimdOp
op
)
;
bool
emitShiftSimd128
(
SimdOp
op
)
;
bool
emitSplatSimd128
(
ValType
inType
SimdOp
op
)
;
bool
emitUnarySimd128
(
SimdOp
op
)
;
bool
emitReduceSimd128
(
SimdOp
op
)
;
bool
emitExtractLaneSimd128
(
ValType
outType
uint32_t
laneLimit
SimdOp
op
)
;
bool
emitReplaceLaneSimd128
(
ValType
laneType
uint32_t
laneLimit
SimdOp
op
)
;
bool
emitShuffleSimd128
(
)
;
bool
emitLoadSplatSimd128
(
Scalar
:
:
Type
viewType
wasm
:
:
SimdOp
splatOp
)
;
bool
emitLoadExtendSimd128
(
wasm
:
:
SimdOp
op
)
;
bool
emitLoadZeroSimd128
(
Scalar
:
:
Type
viewType
size_t
numBytes
)
;
bool
emitLoadLaneSimd128
(
uint32_t
laneSize
)
;
bool
emitStoreLaneSimd128
(
uint32_t
laneSize
)
;
bool
emitRefAsNonNull
(
)
;
bool
emitBrOnNull
(
)
;
bool
emitBrOnNonNull
(
)
;
bool
emitSpeculativeInlineCallRef
(
uint32_t
bytecodeOffset
const
FuncType
&
funcType
CallRefHint
expectedFuncIndices
MDefinition
*
actualCalleeFunc
const
DefVector
&
args
DefVector
*
results
)
;
bool
emitCallRef
(
)
;
bool
emitStructNew
(
)
;
bool
emitStructNewDefault
(
)
;
bool
emitStructSet
(
)
;
bool
emitStructGet
(
FieldWideningOp
wideningOp
)
;
bool
emitArrayNew
(
)
;
bool
emitArrayNewDefault
(
)
;
bool
emitArrayNewFixed
(
)
;
bool
emitArrayNewData
(
)
;
bool
emitArrayNewElem
(
)
;
bool
emitArrayInitData
(
)
;
bool
emitArrayInitElem
(
)
;
bool
emitArraySet
(
)
;
bool
emitArrayGet
(
FieldWideningOp
wideningOp
)
;
bool
emitArrayLen
(
)
;
bool
emitArrayCopy
(
)
;
bool
emitArrayFill
(
)
;
bool
emitRefI31
(
)
;
bool
emitI31Get
(
FieldWideningOp
wideningOp
)
;
bool
emitRefTest
(
bool
nullable
)
;
bool
emitRefCast
(
bool
nullable
)
;
bool
emitBrOnCast
(
bool
onSuccess
)
;
bool
emitAnyConvertExtern
(
)
;
bool
emitExternConvertAny
(
)
;
bool
emitCallBuiltinModuleFunc
(
)
;
public
:
bool
emitBodyExprs
(
)
;
}
;
template
<
>
MDefinition
*
FunctionCompiler
:
:
unary
<
MToFloat32
>
(
MDefinition
*
op
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MToFloat32
:
:
New
(
alloc
(
)
op
mustPreserveNaN
(
op
-
>
type
(
)
)
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
template
<
>
MDefinition
*
FunctionCompiler
:
:
unary
<
MWasmBuiltinTruncateToInt32
>
(
MDefinition
*
op
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MWasmBuiltinTruncateToInt32
:
:
New
(
alloc
(
)
op
instancePointer_
trapSiteDescWithCallSiteLineNumber
(
)
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
template
<
>
MDefinition
*
FunctionCompiler
:
:
unary
<
MNot
>
(
MDefinition
*
op
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MNot
:
:
NewInt32
(
alloc
(
)
op
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
template
<
>
MDefinition
*
FunctionCompiler
:
:
unary
<
MAbs
>
(
MDefinition
*
op
MIRType
type
)
{
if
(
inDeadCode
(
)
)
{
return
nullptr
;
}
auto
*
ins
=
MAbs
:
:
NewWasm
(
alloc
(
)
op
type
)
;
curBlock_
-
>
add
(
ins
)
;
return
ins
;
}
bool
FunctionCompiler
:
:
emitI32Const
(
)
{
int32_t
i32
;
if
(
!
iter
(
)
.
readI32Const
(
&
i32
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
constantI32
(
i32
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitI64Const
(
)
{
int64_t
i64
;
if
(
!
iter
(
)
.
readI64Const
(
&
i64
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
constantI64
(
i64
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitF32Const
(
)
{
float
f32
;
if
(
!
iter
(
)
.
readF32Const
(
&
f32
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
constantF32
(
f32
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitF64Const
(
)
{
double
f64
;
if
(
!
iter
(
)
.
readF64Const
(
&
f64
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
constantF64
(
f64
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitBlock
(
)
{
BlockType
type
;
return
iter
(
)
.
readBlock
(
&
type
)
&
&
startBlock
(
)
;
}
bool
FunctionCompiler
:
:
emitLoop
(
)
{
BlockType
type
;
if
(
!
iter
(
)
.
readLoop
(
&
type
)
)
{
return
false
;
}
MBasicBlock
*
loopHeader
;
if
(
!
startLoop
(
&
loopHeader
type
.
params
(
)
.
length
(
)
)
)
{
return
false
;
}
addInterruptCheck
(
)
;
iter
(
)
.
controlItem
(
)
.
block
=
loopHeader
;
return
true
;
}
bool
FunctionCompiler
:
:
emitIf
(
)
{
BranchHint
branchHint
=
iter
(
)
.
getBranchHint
(
funcIndex
(
)
relativeBytecodeOffset
(
)
)
;
BlockType
type
;
MDefinition
*
condition
=
nullptr
;
if
(
!
iter
(
)
.
readIf
(
&
type
&
condition
)
)
{
return
false
;
}
MBasicBlock
*
elseBlock
;
if
(
!
branchAndStartThen
(
condition
&
elseBlock
)
)
{
return
false
;
}
if
(
!
inDeadCode
(
)
&
&
branchHint
!
=
BranchHint
:
:
Invalid
)
{
getCurBlock
(
)
-
>
setBranchHinting
(
branchHint
)
;
}
iter
(
)
.
controlItem
(
)
.
block
=
elseBlock
;
return
true
;
}
bool
FunctionCompiler
:
:
emitElse
(
)
{
ResultType
paramType
;
ResultType
resultType
;
DefVector
thenValues
;
if
(
!
iter
(
)
.
readElse
(
&
paramType
&
resultType
&
thenValues
)
)
{
return
false
;
}
if
(
!
pushDefs
(
thenValues
)
)
{
return
false
;
}
Control
&
control
=
iter
(
)
.
controlItem
(
)
;
return
switchToElse
(
control
.
block
&
control
.
block
)
;
}
bool
FunctionCompiler
:
:
emitEnd
(
)
{
LabelKind
kind
;
ResultType
type
;
DefVector
preJoinDefs
;
DefVector
resultsForEmptyElse
;
if
(
!
iter
(
)
.
readEnd
(
&
kind
&
type
&
preJoinDefs
&
resultsForEmptyElse
)
)
{
return
false
;
}
Control
&
control
=
iter
(
)
.
controlItem
(
)
;
MBasicBlock
*
block
=
control
.
block
;
if
(
!
pushDefs
(
preJoinDefs
)
)
{
return
false
;
}
DefVector
postJoinDefs
;
switch
(
kind
)
{
case
LabelKind
:
:
Body
:
{
MOZ_ASSERT
(
!
control
.
tryControl
)
;
if
(
!
emitBodyRethrowPad
(
control
)
)
{
return
false
;
}
if
(
!
finishBlock
(
&
postJoinDefs
)
)
{
return
false
;
}
if
(
!
returnValues
(
std
:
:
move
(
postJoinDefs
)
)
)
{
return
false
;
}
iter
(
)
.
popEnd
(
)
;
MOZ_ASSERT
(
iter
(
)
.
controlStackEmpty
(
)
)
;
return
iter
(
)
.
endFunction
(
iter
(
)
.
end
(
)
)
;
}
case
LabelKind
:
:
Block
:
MOZ_ASSERT
(
!
control
.
tryControl
)
;
if
(
!
finishBlock
(
&
postJoinDefs
)
)
{
return
false
;
}
iter
(
)
.
popEnd
(
)
;
break
;
case
LabelKind
:
:
Loop
:
MOZ_ASSERT
(
!
control
.
tryControl
)
;
if
(
!
closeLoop
(
block
&
postJoinDefs
)
)
{
return
false
;
}
iter
(
)
.
popEnd
(
)
;
break
;
case
LabelKind
:
:
Then
:
{
MOZ_ASSERT
(
!
control
.
tryControl
)
;
if
(
!
switchToElse
(
block
&
block
)
)
{
return
false
;
}
if
(
!
pushDefs
(
resultsForEmptyElse
)
)
{
return
false
;
}
if
(
!
joinIfElse
(
block
&
postJoinDefs
)
)
{
return
false
;
}
iter
(
)
.
popEnd
(
)
;
break
;
}
case
LabelKind
:
:
Else
:
MOZ_ASSERT
(
!
control
.
tryControl
)
;
if
(
!
joinIfElse
(
block
&
postJoinDefs
)
)
{
return
false
;
}
iter
(
)
.
popEnd
(
)
;
break
;
case
LabelKind
:
:
Try
:
case
LabelKind
:
:
Catch
:
case
LabelKind
:
:
CatchAll
:
MOZ_ASSERT
(
control
.
tryControl
)
;
if
(
!
finishTryCatch
(
kind
control
&
postJoinDefs
)
)
{
return
false
;
}
rootCompiler
(
)
.
freeTryControl
(
std
:
:
move
(
control
.
tryControl
)
)
;
iter
(
)
.
popEnd
(
)
;
break
;
case
LabelKind
:
:
TryTable
:
MOZ_ASSERT
(
control
.
tryControl
)
;
if
(
!
finishTryTable
(
control
&
postJoinDefs
)
)
{
return
false
;
}
rootCompiler
(
)
.
freeTryControl
(
std
:
:
move
(
control
.
tryControl
)
)
;
iter
(
)
.
popEnd
(
)
;
break
;
}
MOZ_ASSERT_IF
(
!
inDeadCode
(
)
postJoinDefs
.
length
(
)
=
=
type
.
length
(
)
)
;
iter
(
)
.
setResults
(
postJoinDefs
.
length
(
)
postJoinDefs
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitBr
(
)
{
uint32_t
relativeDepth
;
ResultType
type
;
DefVector
values
;
if
(
!
iter
(
)
.
readBr
(
&
relativeDepth
&
type
&
values
)
)
{
return
false
;
}
return
br
(
relativeDepth
values
)
;
}
bool
FunctionCompiler
:
:
emitBrIf
(
)
{
uint32_t
relativeDepth
;
ResultType
type
;
DefVector
values
;
MDefinition
*
condition
;
BranchHint
branchHint
=
iter
(
)
.
getBranchHint
(
funcIndex
(
)
relativeBytecodeOffset
(
)
)
;
if
(
!
iter
(
)
.
readBrIf
(
&
relativeDepth
&
type
&
values
&
condition
)
)
{
return
false
;
}
return
brIf
(
relativeDepth
values
condition
branchHint
)
;
}
bool
FunctionCompiler
:
:
emitBrTable
(
)
{
Uint32Vector
depths
;
uint32_t
defaultDepth
;
ResultType
branchValueType
;
DefVector
branchValues
;
MDefinition
*
index
;
if
(
!
iter
(
)
.
readBrTable
(
&
depths
&
defaultDepth
&
branchValueType
&
branchValues
&
index
)
)
{
return
false
;
}
bool
allSameDepth
=
true
;
for
(
uint32_t
depth
:
depths
)
{
if
(
depth
!
=
defaultDepth
)
{
allSameDepth
=
false
;
break
;
}
}
if
(
allSameDepth
)
{
return
br
(
defaultDepth
branchValues
)
;
}
return
brTable
(
index
defaultDepth
depths
branchValues
)
;
}
bool
FunctionCompiler
:
:
emitReturn
(
)
{
DefVector
values
;
if
(
!
iter
(
)
.
readReturn
(
&
values
)
)
{
return
false
;
}
return
returnValues
(
std
:
:
move
(
values
)
)
;
}
bool
FunctionCompiler
:
:
emitUnreachable
(
)
{
if
(
!
iter
(
)
.
readUnreachable
(
)
)
{
return
false
;
}
unreachableTrap
(
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitTry
(
)
{
BlockType
type
;
if
(
!
iter
(
)
.
readTry
(
&
type
)
)
{
return
false
;
}
return
startTry
(
)
;
}
bool
FunctionCompiler
:
:
emitCatch
(
)
{
LabelKind
kind
;
uint32_t
tagIndex
;
ResultType
paramType
resultType
;
DefVector
tryValues
;
if
(
!
iter
(
)
.
readCatch
(
&
kind
&
tagIndex
&
paramType
&
resultType
&
tryValues
)
)
{
return
false
;
}
if
(
!
pushDefs
(
tryValues
)
)
{
return
false
;
}
return
switchToCatch
(
iter
(
)
.
controlItem
(
)
kind
tagIndex
)
;
}
bool
FunctionCompiler
:
:
emitCatchAll
(
)
{
LabelKind
kind
;
ResultType
paramType
resultType
;
DefVector
tryValues
;
if
(
!
iter
(
)
.
readCatchAll
(
&
kind
&
paramType
&
resultType
&
tryValues
)
)
{
return
false
;
}
if
(
!
pushDefs
(
tryValues
)
)
{
return
false
;
}
return
switchToCatch
(
iter
(
)
.
controlItem
(
)
kind
CatchAllIndex
)
;
}
bool
FunctionCompiler
:
:
emitTryTable
(
)
{
BlockType
type
;
TryTableCatchVector
catches
;
if
(
!
iter
(
)
.
readTryTable
(
&
type
&
catches
)
)
{
return
false
;
}
return
startTryTable
(
std
:
:
move
(
catches
)
)
;
}
bool
FunctionCompiler
:
:
emitDelegate
(
)
{
uint32_t
relativeDepth
;
ResultType
resultType
;
DefVector
tryValues
;
if
(
!
iter
(
)
.
readDelegate
(
&
relativeDepth
&
resultType
&
tryValues
)
)
{
return
false
;
}
Control
&
control
=
iter
(
)
.
controlItem
(
)
;
MBasicBlock
*
block
=
control
.
block
;
MOZ_ASSERT
(
control
.
tryControl
)
;
if
(
block
)
{
ControlInstructionVector
&
padPatches
=
control
.
tryControl
-
>
landingPadPatches
;
if
(
!
delegatePadPatches
(
padPatches
relativeDepth
)
)
{
return
false
;
}
}
rootCompiler
(
)
.
freeTryControl
(
std
:
:
move
(
control
.
tryControl
)
)
;
iter
(
)
.
popDelegate
(
)
;
if
(
!
pushDefs
(
tryValues
)
)
{
return
false
;
}
DefVector
postJoinDefs
;
if
(
!
finishBlock
(
&
postJoinDefs
)
)
{
return
false
;
}
MOZ_ASSERT_IF
(
!
inDeadCode
(
)
postJoinDefs
.
length
(
)
=
=
resultType
.
length
(
)
)
;
iter
(
)
.
setResults
(
postJoinDefs
.
length
(
)
postJoinDefs
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitThrow
(
)
{
uint32_t
tagIndex
;
DefVector
argValues
;
if
(
!
iter
(
)
.
readThrow
(
&
tagIndex
&
argValues
)
)
{
return
false
;
}
return
emitThrow
(
tagIndex
argValues
)
;
}
bool
FunctionCompiler
:
:
emitThrowRef
(
)
{
MDefinition
*
exnRef
;
if
(
!
iter
(
)
.
readThrowRef
(
&
exnRef
)
)
{
return
false
;
}
return
emitThrowRef
(
exnRef
)
;
}
bool
FunctionCompiler
:
:
emitRethrow
(
)
{
uint32_t
relativeDepth
;
if
(
!
iter
(
)
.
readRethrow
(
&
relativeDepth
)
)
{
return
false
;
}
return
emitRethrow
(
relativeDepth
)
;
}
bool
FunctionCompiler
:
:
emitInlineCall
(
const
FuncType
&
funcType
uint32_t
funcIndex
InliningHeuristics
:
:
CallKind
callKind
const
DefVector
&
args
DefVector
*
results
)
{
UniqueChars
error
;
const
BytecodeRange
&
funcRange
=
codeTailMeta
(
)
-
>
funcDefRange
(
funcIndex
)
;
BytecodeSpan
funcBytecode
=
codeTailMeta
(
)
-
>
funcDefBody
(
funcIndex
)
;
FuncCompileInput
func
(
funcIndex
funcRange
.
start
funcBytecode
.
data
(
)
funcBytecode
.
data
(
)
+
funcBytecode
.
size
(
)
Uint32Vector
(
)
)
;
Decoder
d
(
func
.
begin
func
.
end
func
.
lineOrBytecode
&
error
)
;
ValTypeVector
locals
;
if
(
!
DecodeLocalEntriesWithParams
(
d
codeMeta
(
)
funcIndex
&
locals
)
)
{
return
false
;
}
CompileInfo
*
compileInfo
=
rootCompiler
(
)
.
startInlineCall
(
this
-
>
funcIndex
(
)
bytecodeOffset
(
)
funcIndex
locals
.
length
(
)
funcRange
.
size
callKind
)
;
if
(
!
compileInfo
)
{
return
false
;
}
FunctionCompiler
calleeCompiler
(
this
d
func
locals
*
compileInfo
)
;
if
(
!
calleeCompiler
.
initInline
(
args
)
)
{
MOZ_ASSERT
(
!
error
)
;
return
false
;
}
if
(
!
calleeCompiler
.
startBlock
(
)
)
{
MOZ_ASSERT
(
!
error
)
;
return
false
;
}
if
(
!
calleeCompiler
.
emitBodyExprs
(
)
)
{
MOZ_ASSERT
(
!
error
)
;
return
false
;
}
calleeCompiler
.
finish
(
)
;
rootCompiler_
.
finishInlineCall
(
)
;
return
finishInlinedCallDirect
(
calleeCompiler
results
)
;
}
bool
FunctionCompiler
:
:
emitCall
(
bool
asmJSFuncDef
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
funcIndex
;
DefVector
args
;
if
(
asmJSFuncDef
)
{
if
(
!
iter
(
)
.
readOldCallDirect
(
codeMeta
(
)
.
numFuncImports
&
funcIndex
&
args
)
)
{
return
false
;
}
}
else
{
if
(
!
iter
(
)
.
readCall
(
&
funcIndex
&
args
)
)
{
return
false
;
}
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
const
FuncType
&
funcType
=
codeMeta
(
)
.
getFuncType
(
funcIndex
)
;
DefVector
results
;
if
(
codeMeta
(
)
.
funcIsImport
(
funcIndex
)
)
{
BuiltinModuleFuncId
knownFuncImport
=
codeMeta
(
)
.
knownFuncImport
(
funcIndex
)
;
if
(
knownFuncImport
!
=
BuiltinModuleFuncId
:
:
None
)
{
const
BuiltinModuleFunc
&
builtinModuleFunc
=
BuiltinModuleFuncs
:
:
getFromId
(
knownFuncImport
)
;
return
callBuiltinModuleFunc
(
builtinModuleFunc
args
)
;
}
uint32_t
instanceDataOffset
=
codeMeta
(
)
.
offsetOfFuncImportInstanceData
(
funcIndex
)
;
if
(
!
callImport
(
instanceDataOffset
lineOrBytecode
funcType
args
&
results
)
)
{
return
false
;
}
}
else
{
const
auto
callKind
=
InliningHeuristics
:
:
CallKind
:
:
Direct
;
CallRefHint
hints
;
hints
.
append
(
funcIndex
)
;
hints
=
auditInlineableCallees
(
callKind
hints
)
;
if
(
!
hints
.
empty
(
)
)
{
if
(
!
emitInlineCall
(
funcType
funcIndex
callKind
args
&
results
)
)
{
return
false
;
}
}
else
{
if
(
!
callDirect
(
funcType
funcIndex
lineOrBytecode
args
&
results
)
)
{
return
false
;
}
}
}
iter
(
)
.
setResults
(
results
.
length
(
)
results
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitCallIndirect
(
bool
oldStyle
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
funcTypeIndex
;
uint32_t
tableIndex
;
MDefinition
*
callee
;
DefVector
args
;
if
(
oldStyle
)
{
tableIndex
=
0
;
if
(
!
iter
(
)
.
readOldCallIndirect
(
&
funcTypeIndex
&
callee
&
args
)
)
{
return
false
;
}
}
else
{
if
(
!
iter
(
)
.
readCallIndirect
(
&
funcTypeIndex
&
tableIndex
&
callee
&
args
)
)
{
return
false
;
}
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
DefVector
results
;
if
(
!
callIndirect
(
funcTypeIndex
tableIndex
callee
lineOrBytecode
args
&
results
)
)
{
return
false
;
}
iter
(
)
.
setResults
(
results
.
length
(
)
results
)
;
return
true
;
}
#
ifdef
ENABLE_WASM_JSPI
bool
FunctionCompiler
:
:
emitStackSwitch
(
)
{
StackSwitchKind
kind
;
MDefinition
*
suspender
;
MDefinition
*
fn
;
MDefinition
*
data
;
if
(
!
iter
(
)
.
readStackSwitch
(
&
kind
&
suspender
&
fn
&
data
)
)
{
return
false
;
}
MDefinition
*
result
=
stackSwitch
(
suspender
fn
data
kind
)
;
if
(
!
result
)
{
return
false
;
}
if
(
kind
=
=
StackSwitchKind
:
:
SwitchToMain
)
{
iter
(
)
.
setResult
(
result
)
;
}
return
true
;
}
#
endif
bool
FunctionCompiler
:
:
emitReturnCall
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
funcIndex
;
DefVector
args
;
if
(
!
iter
(
)
.
readReturnCall
(
&
funcIndex
&
args
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
const
FuncType
&
funcType
=
codeMeta
(
)
.
getFuncType
(
funcIndex
)
;
DefVector
results
;
if
(
codeMeta
(
)
.
funcIsImport
(
funcIndex
)
)
{
uint32_t
globalDataOffset
=
codeMeta
(
)
.
offsetOfFuncImportInstanceData
(
funcIndex
)
;
if
(
!
returnCallImport
(
globalDataOffset
lineOrBytecode
funcType
args
&
results
)
)
{
return
false
;
}
}
else
{
if
(
!
returnCallDirect
(
funcType
funcIndex
lineOrBytecode
args
&
results
)
)
{
return
false
;
}
}
return
true
;
}
bool
FunctionCompiler
:
:
emitReturnCallIndirect
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
funcTypeIndex
;
uint32_t
tableIndex
;
MDefinition
*
callee
;
DefVector
args
;
if
(
!
iter
(
)
.
readReturnCallIndirect
(
&
funcTypeIndex
&
tableIndex
&
callee
&
args
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
DefVector
results
;
return
returnCallIndirect
(
funcTypeIndex
tableIndex
callee
lineOrBytecode
args
&
results
)
;
}
bool
FunctionCompiler
:
:
emitReturnCallRef
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
funcTypeIndex
;
MDefinition
*
callee
;
DefVector
args
;
if
(
!
iter
(
)
.
readReturnCallRef
(
&
funcTypeIndex
&
callee
&
args
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
const
FuncType
&
funcType
=
codeMeta
(
)
.
types
-
>
type
(
funcTypeIndex
)
.
funcType
(
)
;
DefVector
results
;
return
returnCallRef
(
funcType
callee
lineOrBytecode
args
&
results
)
;
}
bool
FunctionCompiler
:
:
emitGetLocal
(
)
{
uint32_t
id
;
if
(
!
iter
(
)
.
readGetLocal
(
&
id
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
getLocalDef
(
id
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitSetLocal
(
)
{
uint32_t
id
;
MDefinition
*
value
;
if
(
!
iter
(
)
.
readSetLocal
(
&
id
&
value
)
)
{
return
false
;
}
assign
(
id
value
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitTeeLocal
(
)
{
uint32_t
id
;
MDefinition
*
value
;
if
(
!
iter
(
)
.
readTeeLocal
(
&
id
&
value
)
)
{
return
false
;
}
assign
(
id
value
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitGetGlobal
(
)
{
uint32_t
id
;
if
(
!
iter
(
)
.
readGetGlobal
(
&
id
)
)
{
return
false
;
}
const
GlobalDesc
&
global
=
codeMeta
(
)
.
globals
[
id
]
;
if
(
!
global
.
isConstant
(
)
)
{
iter
(
)
.
setResult
(
loadGlobalVar
(
global
)
)
;
return
true
;
}
LitVal
value
=
global
.
constantValue
(
)
;
MDefinition
*
result
;
switch
(
value
.
type
(
)
.
kind
(
)
)
{
case
ValType
:
:
I32
:
result
=
constantI32
(
int32_t
(
value
.
i32
(
)
)
)
;
break
;
case
ValType
:
:
I64
:
result
=
constantI64
(
int64_t
(
value
.
i64
(
)
)
)
;
break
;
case
ValType
:
:
F32
:
result
=
constantF32
(
value
.
f32
(
)
)
;
break
;
case
ValType
:
:
F64
:
result
=
constantF64
(
value
.
f64
(
)
)
;
break
;
case
ValType
:
:
V128
:
#
ifdef
ENABLE_WASM_SIMD
result
=
constantV128
(
value
.
v128
(
)
)
;
break
;
#
else
return
iter
(
)
.
fail
(
"
Ion
has
no
SIMD
support
yet
"
)
;
#
endif
case
ValType
:
:
Ref
:
MOZ_ASSERT
(
value
.
ref
(
)
.
isNull
(
)
)
;
result
=
constantNullRef
(
MaybeRefType
(
value
.
type
(
)
.
refType
(
)
)
)
;
break
;
default
:
MOZ_CRASH
(
"
unexpected
type
in
EmitGetGlobal
"
)
;
}
iter
(
)
.
setResult
(
result
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitSetGlobal
(
)
{
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
uint32_t
id
;
MDefinition
*
value
;
if
(
!
iter
(
)
.
readSetGlobal
(
&
id
&
value
)
)
{
return
false
;
}
const
GlobalDesc
&
global
=
codeMeta
(
)
.
globals
[
id
]
;
MOZ_ASSERT
(
global
.
isMutable
(
)
)
;
return
storeGlobalVar
(
bytecodeOffset
global
value
)
;
}
bool
FunctionCompiler
:
:
emitTeeGlobal
(
)
{
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
uint32_t
id
;
MDefinition
*
value
;
if
(
!
iter
(
)
.
readTeeGlobal
(
&
id
&
value
)
)
{
return
false
;
}
const
GlobalDesc
&
global
=
codeMeta
(
)
.
globals
[
id
]
;
MOZ_ASSERT
(
global
.
isMutable
(
)
)
;
return
storeGlobalVar
(
bytecodeOffset
global
value
)
;
}
template
<
typename
MIRClass
>
bool
FunctionCompiler
:
:
emitUnary
(
ValType
operandType
)
{
MDefinition
*
input
;
if
(
!
iter
(
)
.
readUnary
(
operandType
&
input
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
unary
<
MIRClass
>
(
input
)
)
;
return
true
;
}
template
<
typename
MIRClass
>
bool
FunctionCompiler
:
:
emitConversion
(
ValType
operandType
ValType
resultType
)
{
MDefinition
*
input
;
if
(
!
iter
(
)
.
readConversion
(
operandType
resultType
&
input
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
unary
<
MIRClass
>
(
input
)
)
;
return
true
;
}
template
<
typename
MIRClass
>
bool
FunctionCompiler
:
:
emitUnaryWithType
(
ValType
operandType
MIRType
mirType
)
{
MDefinition
*
input
;
if
(
!
iter
(
)
.
readUnary
(
operandType
&
input
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
unary
<
MIRClass
>
(
input
mirType
)
)
;
return
true
;
}
template
<
typename
MIRClass
>
bool
FunctionCompiler
:
:
emitConversionWithType
(
ValType
operandType
ValType
resultType
MIRType
mirType
)
{
MDefinition
*
input
;
if
(
!
iter
(
)
.
readConversion
(
operandType
resultType
&
input
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
unary
<
MIRClass
>
(
input
mirType
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitTruncate
(
ValType
operandType
ValType
resultType
bool
isUnsigned
bool
isSaturating
)
{
MDefinition
*
input
=
nullptr
;
if
(
!
iter
(
)
.
readConversion
(
operandType
resultType
&
input
)
)
{
return
false
;
}
TruncFlags
flags
=
0
;
if
(
isUnsigned
)
{
flags
|
=
TRUNC_UNSIGNED
;
}
if
(
isSaturating
)
{
flags
|
=
TRUNC_SATURATING
;
}
if
(
resultType
=
=
ValType
:
:
I32
)
{
if
(
codeMeta
(
)
.
isAsmJS
(
)
)
{
if
(
inDeadCode
(
)
)
{
(
void
)
readCallSiteLineOrBytecode
(
)
;
iter
(
)
.
setResult
(
nullptr
)
;
}
else
if
(
input
&
&
(
input
-
>
type
(
)
=
=
MIRType
:
:
Double
|
|
input
-
>
type
(
)
=
=
MIRType
:
:
Float32
)
)
{
iter
(
)
.
setResult
(
unary
<
MWasmBuiltinTruncateToInt32
>
(
input
)
)
;
}
else
{
iter
(
)
.
setResult
(
unary
<
MTruncateToInt32
>
(
input
)
)
;
}
}
else
{
iter
(
)
.
setResult
(
truncate
<
MWasmTruncateToInt32
>
(
input
flags
)
)
;
}
}
else
{
MOZ_ASSERT
(
resultType
=
=
ValType
:
:
I64
)
;
MOZ_ASSERT
(
!
codeMeta
(
)
.
isAsmJS
(
)
)
;
#
if
defined
(
JS_CODEGEN_ARM
)
iter
(
)
.
setResult
(
truncateWithInstance
(
input
flags
)
)
;
#
else
iter
(
)
.
setResult
(
truncate
<
MWasmTruncateToInt64
>
(
input
flags
)
)
;
#
endif
}
return
true
;
}
bool
FunctionCompiler
:
:
emitSignExtend
(
uint32_t
srcSize
uint32_t
targetSize
)
{
MDefinition
*
input
;
ValType
type
=
targetSize
=
=
4
?
ValType
:
:
I32
:
ValType
:
:
I64
;
if
(
!
iter
(
)
.
readConversion
(
type
type
&
input
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
signExtend
(
input
srcSize
targetSize
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitExtendI32
(
bool
isUnsigned
)
{
MDefinition
*
input
;
if
(
!
iter
(
)
.
readConversion
(
ValType
:
:
I32
ValType
:
:
I64
&
input
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
extendI32
(
input
isUnsigned
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitConvertI64ToFloatingPoint
(
ValType
resultType
MIRType
mirType
bool
isUnsigned
)
{
MDefinition
*
input
;
if
(
!
iter
(
)
.
readConversion
(
ValType
:
:
I64
resultType
&
input
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
convertI64ToFloatingPoint
(
input
mirType
isUnsigned
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitReinterpret
(
ValType
resultType
ValType
operandType
MIRType
mirType
)
{
MDefinition
*
input
;
if
(
!
iter
(
)
.
readConversion
(
operandType
resultType
&
input
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
unary
<
MReinterpretCast
>
(
input
mirType
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitAdd
(
ValType
type
MIRType
mirType
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readBinary
(
type
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
add
(
lhs
rhs
mirType
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitSub
(
ValType
type
MIRType
mirType
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readBinary
(
type
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
sub
(
lhs
rhs
mirType
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitRotate
(
ValType
type
bool
isLeftRotation
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readBinary
(
type
&
lhs
&
rhs
)
)
{
return
false
;
}
MDefinition
*
result
=
rotate
(
lhs
rhs
type
.
toMIRType
(
)
isLeftRotation
)
;
iter
(
)
.
setResult
(
result
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitBitNot
(
ValType
operandType
MIRType
mirType
)
{
MDefinition
*
input
;
if
(
!
iter
(
)
.
readUnary
(
operandType
&
input
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
bitnot
(
input
mirType
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitBitwiseAndOrXor
(
ValType
operandType
MIRType
mirType
MWasmBinaryBitwise
:
:
SubOpcode
subOpc
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readBinary
(
operandType
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
binary
<
MWasmBinaryBitwise
>
(
lhs
rhs
mirType
subOpc
)
)
;
return
true
;
}
template
<
typename
MIRClass
>
bool
FunctionCompiler
:
:
emitShift
(
ValType
operandType
MIRType
mirType
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readBinary
(
operandType
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
binary
<
MIRClass
>
(
lhs
rhs
mirType
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitUrsh
(
ValType
operandType
MIRType
mirType
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readBinary
(
operandType
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
ursh
(
lhs
rhs
mirType
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitMul
(
ValType
operandType
MIRType
mirType
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readBinary
(
operandType
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
mul
(
lhs
rhs
mirType
mirType
=
=
MIRType
:
:
Int32
?
MMul
:
:
Integer
:
MMul
:
:
Normal
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitDiv
(
ValType
operandType
MIRType
mirType
bool
isUnsigned
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readBinary
(
operandType
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
div
(
lhs
rhs
mirType
isUnsigned
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitRem
(
ValType
operandType
MIRType
mirType
bool
isUnsigned
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readBinary
(
operandType
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
mod
(
lhs
rhs
mirType
isUnsigned
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitMinMax
(
ValType
operandType
MIRType
mirType
bool
isMax
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readBinary
(
operandType
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
minMax
(
lhs
rhs
mirType
isMax
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitCopySign
(
ValType
operandType
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readBinary
(
operandType
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
binary
<
MCopySign
>
(
lhs
rhs
operandType
.
toMIRType
(
)
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitComparison
(
ValType
operandType
JSOp
compareOp
MCompare
:
:
CompareType
compareType
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readComparison
(
operandType
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
compare
(
lhs
rhs
compareOp
compareType
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitSelect
(
bool
typed
)
{
StackType
type
;
MDefinition
*
trueValue
;
MDefinition
*
falseValue
;
MDefinition
*
condition
;
if
(
!
iter
(
)
.
readSelect
(
typed
&
type
&
trueValue
&
falseValue
&
condition
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
select
(
trueValue
falseValue
condition
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitLoad
(
ValType
type
Scalar
:
:
Type
viewType
)
{
LinearMemoryAddress
<
MDefinition
*
>
addr
;
if
(
!
iter
(
)
.
readLoad
(
type
Scalar
:
:
byteSize
(
viewType
)
&
addr
)
)
{
return
false
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
viewType
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
)
;
auto
*
ins
=
load
(
addr
.
base
&
access
type
)
;
if
(
!
inDeadCode
(
)
&
&
!
ins
)
{
return
false
;
}
iter
(
)
.
setResult
(
ins
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitStore
(
ValType
resultType
Scalar
:
:
Type
viewType
)
{
LinearMemoryAddress
<
MDefinition
*
>
addr
;
MDefinition
*
value
;
if
(
!
iter
(
)
.
readStore
(
resultType
Scalar
:
:
byteSize
(
viewType
)
&
addr
&
value
)
)
{
return
false
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
viewType
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
)
;
store
(
addr
.
base
&
access
value
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitTeeStore
(
ValType
resultType
Scalar
:
:
Type
viewType
)
{
LinearMemoryAddress
<
MDefinition
*
>
addr
;
MDefinition
*
value
;
if
(
!
iter
(
)
.
readTeeStore
(
resultType
Scalar
:
:
byteSize
(
viewType
)
&
addr
&
value
)
)
{
return
false
;
}
MOZ_ASSERT
(
isMem32
(
addr
.
memoryIndex
)
)
;
MemoryAccessDesc
access
(
addr
.
memoryIndex
viewType
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
)
;
store
(
addr
.
base
&
access
value
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitTeeStoreWithCoercion
(
ValType
resultType
Scalar
:
:
Type
viewType
)
{
LinearMemoryAddress
<
MDefinition
*
>
addr
;
MDefinition
*
value
;
if
(
!
iter
(
)
.
readTeeStore
(
resultType
Scalar
:
:
byteSize
(
viewType
)
&
addr
&
value
)
)
{
return
false
;
}
if
(
resultType
=
=
ValType
:
:
F32
&
&
viewType
=
=
Scalar
:
:
Float64
)
{
value
=
unary
<
MToDouble
>
(
value
)
;
}
else
if
(
resultType
=
=
ValType
:
:
F64
&
&
viewType
=
=
Scalar
:
:
Float32
)
{
value
=
unary
<
MToFloat32
>
(
value
)
;
}
else
{
MOZ_CRASH
(
"
unexpected
coerced
store
"
)
;
}
MOZ_ASSERT
(
isMem32
(
addr
.
memoryIndex
)
)
;
MemoryAccessDesc
access
(
addr
.
memoryIndex
viewType
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
)
;
store
(
addr
.
base
&
access
value
)
;
return
true
;
}
bool
FunctionCompiler
:
:
tryInlineUnaryBuiltin
(
SymbolicAddress
callee
MDefinition
*
input
)
{
if
(
!
input
)
{
return
false
;
}
MOZ_ASSERT
(
IsFloatingPointType
(
input
-
>
type
(
)
)
)
;
RoundingMode
mode
;
if
(
!
IsRoundingFunction
(
callee
&
mode
)
)
{
return
false
;
}
if
(
!
MNearbyInt
:
:
HasAssemblerSupport
(
mode
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
nearbyInt
(
input
mode
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitUnaryMathBuiltinCall
(
const
SymbolicAddressSignature
&
callee
)
{
MOZ_ASSERT
(
callee
.
numArgs
=
=
1
)
;
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
MDefinition
*
input
;
if
(
!
iter
(
)
.
readUnary
(
ValType
:
:
fromMIRType
(
callee
.
argTypes
[
0
]
)
&
input
)
)
{
return
false
;
}
if
(
tryInlineUnaryBuiltin
(
callee
.
identity
input
)
)
{
return
true
;
}
MDefinition
*
def
;
if
(
!
builtinCall1
(
callee
lineOrBytecode
input
&
def
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
def
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitBinaryMathBuiltinCall
(
const
SymbolicAddressSignature
&
callee
)
{
MOZ_ASSERT
(
callee
.
numArgs
=
=
2
)
;
MOZ_ASSERT
(
callee
.
argTypes
[
0
]
=
=
callee
.
argTypes
[
1
]
)
;
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readBinary
(
ValType
:
:
fromMIRType
(
callee
.
argTypes
[
0
]
)
&
lhs
&
rhs
)
)
{
return
false
;
}
MDefinition
*
def
;
if
(
!
builtinCall2
(
callee
lineOrBytecode
lhs
rhs
&
def
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
def
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitMemoryGrow
(
)
{
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
MDefinition
*
delta
;
uint32_t
memoryIndex
;
if
(
!
iter
(
)
.
readMemoryGrow
(
&
memoryIndex
&
delta
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
memoryIndexValue
=
constantI32
(
int32_t
(
memoryIndex
)
)
;
if
(
!
memoryIndexValue
)
{
return
false
;
}
const
SymbolicAddressSignature
&
callee
=
isMem32
(
memoryIndex
)
?
SASigMemoryGrowM32
:
SASigMemoryGrowM64
;
MDefinition
*
ret
;
if
(
!
emitInstanceCall2
(
bytecodeOffset
callee
delta
memoryIndexValue
&
ret
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
ret
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitMemorySize
(
)
{
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
uint32_t
memoryIndex
;
if
(
!
iter
(
)
.
readMemorySize
(
&
memoryIndex
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
memoryIndexValue
=
constantI32
(
int32_t
(
memoryIndex
)
)
;
if
(
!
memoryIndexValue
)
{
return
false
;
}
const
SymbolicAddressSignature
&
callee
=
isMem32
(
memoryIndex
)
?
SASigMemorySizeM32
:
SASigMemorySizeM64
;
MDefinition
*
ret
;
if
(
!
emitInstanceCall1
(
bytecodeOffset
callee
memoryIndexValue
&
ret
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
ret
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitAtomicCmpXchg
(
ValType
type
Scalar
:
:
Type
viewType
)
{
LinearMemoryAddress
<
MDefinition
*
>
addr
;
MDefinition
*
oldValue
;
MDefinition
*
newValue
;
if
(
!
iter
(
)
.
readAtomicCmpXchg
(
&
addr
type
byteSize
(
viewType
)
&
oldValue
&
newValue
)
)
{
return
false
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
viewType
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
Synchronization
:
:
Full
(
)
)
;
auto
*
ins
=
atomicCompareExchangeHeap
(
addr
.
base
&
access
type
oldValue
newValue
)
;
if
(
!
inDeadCode
(
)
&
&
!
ins
)
{
return
false
;
}
iter
(
)
.
setResult
(
ins
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitAtomicLoad
(
ValType
type
Scalar
:
:
Type
viewType
)
{
LinearMemoryAddress
<
MDefinition
*
>
addr
;
if
(
!
iter
(
)
.
readAtomicLoad
(
&
addr
type
byteSize
(
viewType
)
)
)
{
return
false
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
viewType
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
Synchronization
:
:
Load
(
)
)
;
auto
*
ins
=
load
(
addr
.
base
&
access
type
)
;
if
(
!
inDeadCode
(
)
&
&
!
ins
)
{
return
false
;
}
iter
(
)
.
setResult
(
ins
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitAtomicRMW
(
ValType
type
Scalar
:
:
Type
viewType
jit
:
:
AtomicOp
op
)
{
LinearMemoryAddress
<
MDefinition
*
>
addr
;
MDefinition
*
value
;
if
(
!
iter
(
)
.
readAtomicRMW
(
&
addr
type
byteSize
(
viewType
)
&
value
)
)
{
return
false
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
viewType
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
Synchronization
:
:
Full
(
)
)
;
auto
*
ins
=
atomicBinopHeap
(
op
addr
.
base
&
access
type
value
)
;
if
(
!
inDeadCode
(
)
&
&
!
ins
)
{
return
false
;
}
iter
(
)
.
setResult
(
ins
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitAtomicStore
(
ValType
type
Scalar
:
:
Type
viewType
)
{
LinearMemoryAddress
<
MDefinition
*
>
addr
;
MDefinition
*
value
;
if
(
!
iter
(
)
.
readAtomicStore
(
&
addr
type
byteSize
(
viewType
)
&
value
)
)
{
return
false
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
viewType
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
Synchronization
:
:
Store
(
)
)
;
store
(
addr
.
base
&
access
value
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitWait
(
ValType
type
uint32_t
byteSize
)
{
MOZ_ASSERT
(
type
=
=
ValType
:
:
I32
|
|
type
=
=
ValType
:
:
I64
)
;
MOZ_ASSERT
(
type
.
size
(
)
=
=
byteSize
)
;
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
LinearMemoryAddress
<
MDefinition
*
>
addr
;
MDefinition
*
expected
;
MDefinition
*
timeout
;
if
(
!
iter
(
)
.
readWait
(
&
addr
type
byteSize
&
expected
&
timeout
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
type
=
=
ValType
:
:
I32
?
Scalar
:
:
Int32
:
Scalar
:
:
Int64
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
)
;
MDefinition
*
ptr
=
computeEffectiveAddress
(
addr
.
base
&
access
)
;
if
(
!
ptr
)
{
return
false
;
}
MDefinition
*
memoryIndex
=
constantI32
(
int32_t
(
addr
.
memoryIndex
)
)
;
if
(
!
memoryIndex
)
{
return
false
;
}
const
SymbolicAddressSignature
&
callee
=
isMem32
(
addr
.
memoryIndex
)
?
(
type
=
=
ValType
:
:
I32
?
SASigWaitI32M32
:
SASigWaitI64M32
)
:
(
type
=
=
ValType
:
:
I32
?
SASigWaitI32M64
:
SASigWaitI64M64
)
;
MDefinition
*
ret
;
if
(
!
emitInstanceCall4
(
bytecodeOffset
callee
ptr
expected
timeout
memoryIndex
&
ret
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
ret
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitFence
(
)
{
if
(
!
iter
(
)
.
readFence
(
)
)
{
return
false
;
}
fence
(
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitNotify
(
)
{
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
LinearMemoryAddress
<
MDefinition
*
>
addr
;
MDefinition
*
count
;
if
(
!
iter
(
)
.
readNotify
(
&
addr
&
count
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
Scalar
:
:
Int32
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
)
;
MDefinition
*
ptr
=
computeEffectiveAddress
(
addr
.
base
&
access
)
;
if
(
!
ptr
)
{
return
false
;
}
MDefinition
*
memoryIndex
=
constantI32
(
int32_t
(
addr
.
memoryIndex
)
)
;
if
(
!
memoryIndex
)
{
return
false
;
}
const
SymbolicAddressSignature
&
callee
=
isMem32
(
addr
.
memoryIndex
)
?
SASigWakeM32
:
SASigWakeM64
;
MDefinition
*
ret
;
if
(
!
emitInstanceCall3
(
bytecodeOffset
callee
ptr
count
memoryIndex
&
ret
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
ret
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitAtomicXchg
(
ValType
type
Scalar
:
:
Type
viewType
)
{
LinearMemoryAddress
<
MDefinition
*
>
addr
;
MDefinition
*
value
;
if
(
!
iter
(
)
.
readAtomicRMW
(
&
addr
type
byteSize
(
viewType
)
&
value
)
)
{
return
false
;
}
MemoryAccessDesc
access
(
addr
.
memoryIndex
viewType
addr
.
align
addr
.
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
addr
.
memoryIndex
)
Synchronization
:
:
Full
(
)
)
;
MDefinition
*
ins
=
atomicExchangeHeap
(
addr
.
base
&
access
type
value
)
;
if
(
!
inDeadCode
(
)
&
&
!
ins
)
{
return
false
;
}
iter
(
)
.
setResult
(
ins
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitMemCopyCall
(
uint32_t
dstMemIndex
uint32_t
srcMemIndex
MDefinition
*
dst
MDefinition
*
src
MDefinition
*
len
)
{
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
if
(
dstMemIndex
=
=
srcMemIndex
)
{
const
SymbolicAddressSignature
&
callee
=
(
codeMeta
(
)
.
usesSharedMemory
(
dstMemIndex
)
?
(
isMem32
(
dstMemIndex
)
?
SASigMemCopySharedM32
:
SASigMemCopySharedM64
)
:
(
isMem32
(
dstMemIndex
)
?
SASigMemCopyM32
:
SASigMemCopyM64
)
)
;
MDefinition
*
base
=
memoryBase
(
dstMemIndex
)
;
if
(
!
base
)
{
return
false
;
}
return
emitInstanceCall4
(
bytecodeOffset
callee
dst
src
len
base
)
;
}
AddressType
dstIndexType
=
codeMeta
(
)
.
memories
[
dstMemIndex
]
.
addressType
(
)
;
AddressType
srcIndexType
=
codeMeta
(
)
.
memories
[
srcMemIndex
]
.
addressType
(
)
;
if
(
dstIndexType
=
=
AddressType
:
:
I32
)
{
dst
=
extendI32
(
dst
true
)
;
if
(
!
dst
)
{
return
false
;
}
}
if
(
srcIndexType
=
=
AddressType
:
:
I32
)
{
src
=
extendI32
(
src
true
)
;
if
(
!
src
)
{
return
false
;
}
}
if
(
dstIndexType
=
=
AddressType
:
:
I32
|
|
srcIndexType
=
=
AddressType
:
:
I32
)
{
len
=
extendI32
(
len
true
)
;
if
(
!
len
)
{
return
false
;
}
}
MDefinition
*
dstMemIndexValue
=
constantI32
(
int32_t
(
dstMemIndex
)
)
;
if
(
!
dstMemIndexValue
)
{
return
false
;
}
MDefinition
*
srcMemIndexValue
=
constantI32
(
int32_t
(
srcMemIndex
)
)
;
if
(
!
srcMemIndexValue
)
{
return
false
;
}
return
emitInstanceCall5
(
bytecodeOffset
SASigMemCopyAny
dst
src
len
dstMemIndexValue
srcMemIndexValue
)
;
}
bool
FunctionCompiler
:
:
emitMemCopyInline
(
uint32_t
memoryIndex
MDefinition
*
dst
MDefinition
*
src
uint32_t
length
)
{
MOZ_ASSERT
(
length
!
=
0
&
&
length
<
=
MaxInlineMemoryCopyLength
)
;
size_t
remainder
=
length
;
#
ifdef
ENABLE_WASM_SIMD
size_t
numCopies16
=
0
;
if
(
MacroAssembler
:
:
SupportsFastUnalignedFPAccesses
(
)
)
{
numCopies16
=
remainder
/
sizeof
(
V128
)
;
remainder
%
=
sizeof
(
V128
)
;
}
#
endif
#
ifdef
JS_64BIT
size_t
numCopies8
=
remainder
/
sizeof
(
uint64_t
)
;
remainder
%
=
sizeof
(
uint64_t
)
;
#
endif
size_t
numCopies4
=
remainder
/
sizeof
(
uint32_t
)
;
remainder
%
=
sizeof
(
uint32_t
)
;
size_t
numCopies2
=
remainder
/
sizeof
(
uint16_t
)
;
remainder
%
=
sizeof
(
uint16_t
)
;
size_t
numCopies1
=
remainder
;
size_t
offset
=
0
;
DefVector
loadedValues
;
#
ifdef
ENABLE_WASM_SIMD
for
(
uint32_t
i
=
0
;
i
<
numCopies16
;
i
+
+
)
{
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Simd128
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
auto
*
loadValue
=
load
(
src
&
access
ValType
:
:
V128
)
;
if
(
!
loadValue
|
|
!
loadedValues
.
append
(
loadValue
)
)
{
return
false
;
}
offset
+
=
sizeof
(
V128
)
;
}
#
endif
#
ifdef
JS_64BIT
for
(
uint32_t
i
=
0
;
i
<
numCopies8
;
i
+
+
)
{
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Int64
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
auto
*
loadValue
=
load
(
src
&
access
ValType
:
:
I64
)
;
if
(
!
loadValue
|
|
!
loadedValues
.
append
(
loadValue
)
)
{
return
false
;
}
offset
+
=
sizeof
(
uint64_t
)
;
}
#
endif
for
(
uint32_t
i
=
0
;
i
<
numCopies4
;
i
+
+
)
{
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Uint32
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
auto
*
loadValue
=
load
(
src
&
access
ValType
:
:
I32
)
;
if
(
!
loadValue
|
|
!
loadedValues
.
append
(
loadValue
)
)
{
return
false
;
}
offset
+
=
sizeof
(
uint32_t
)
;
}
if
(
numCopies2
)
{
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Uint16
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
auto
*
loadValue
=
load
(
src
&
access
ValType
:
:
I32
)
;
if
(
!
loadValue
|
|
!
loadedValues
.
append
(
loadValue
)
)
{
return
false
;
}
offset
+
=
sizeof
(
uint16_t
)
;
}
if
(
numCopies1
)
{
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Uint8
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
auto
*
loadValue
=
load
(
src
&
access
ValType
:
:
I32
)
;
if
(
!
loadValue
|
|
!
loadedValues
.
append
(
loadValue
)
)
{
return
false
;
}
}
offset
=
length
;
if
(
numCopies1
)
{
offset
-
=
sizeof
(
uint8_t
)
;
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Uint8
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
auto
*
value
=
loadedValues
.
popCopy
(
)
;
store
(
dst
&
access
value
)
;
}
if
(
numCopies2
)
{
offset
-
=
sizeof
(
uint16_t
)
;
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Uint16
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
auto
*
value
=
loadedValues
.
popCopy
(
)
;
store
(
dst
&
access
value
)
;
}
for
(
uint32_t
i
=
0
;
i
<
numCopies4
;
i
+
+
)
{
offset
-
=
sizeof
(
uint32_t
)
;
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Uint32
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
auto
*
value
=
loadedValues
.
popCopy
(
)
;
store
(
dst
&
access
value
)
;
}
#
ifdef
JS_64BIT
for
(
uint32_t
i
=
0
;
i
<
numCopies8
;
i
+
+
)
{
offset
-
=
sizeof
(
uint64_t
)
;
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Int64
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
auto
*
value
=
loadedValues
.
popCopy
(
)
;
store
(
dst
&
access
value
)
;
}
#
endif
#
ifdef
ENABLE_WASM_SIMD
for
(
uint32_t
i
=
0
;
i
<
numCopies16
;
i
+
+
)
{
offset
-
=
sizeof
(
V128
)
;
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Simd128
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
auto
*
value
=
loadedValues
.
popCopy
(
)
;
store
(
dst
&
access
value
)
;
}
#
endif
return
true
;
}
bool
FunctionCompiler
:
:
emitMemCopy
(
)
{
MDefinition
*
dst
*
src
*
len
;
uint32_t
dstMemIndex
;
uint32_t
srcMemIndex
;
if
(
!
iter
(
)
.
readMemOrTableCopy
(
true
&
dstMemIndex
&
dst
&
srcMemIndex
&
src
&
len
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
if
(
dstMemIndex
=
=
srcMemIndex
&
&
len
-
>
isConstant
(
)
)
{
uint64_t
length
=
isMem32
(
dstMemIndex
)
?
len
-
>
toConstant
(
)
-
>
toInt32
(
)
:
len
-
>
toConstant
(
)
-
>
toInt64
(
)
;
static_assert
(
MaxInlineMemoryCopyLength
<
=
UINT32_MAX
)
;
if
(
length
!
=
0
&
&
length
<
=
MaxInlineMemoryCopyLength
)
{
return
emitMemCopyInline
(
dstMemIndex
dst
src
uint32_t
(
length
)
)
;
}
}
return
emitMemCopyCall
(
dstMemIndex
srcMemIndex
dst
src
len
)
;
}
bool
FunctionCompiler
:
:
emitTableCopy
(
)
{
MDefinition
*
dst
*
src
*
len
;
uint32_t
dstTableIndex
;
uint32_t
srcTableIndex
;
if
(
!
iter
(
)
.
readMemOrTableCopy
(
false
&
dstTableIndex
&
dst
&
srcTableIndex
&
src
&
len
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
const
TableDesc
&
dstTable
=
codeMeta
(
)
.
tables
[
dstTableIndex
]
;
const
TableDesc
&
srcTable
=
codeMeta
(
)
.
tables
[
srcTableIndex
]
;
AddressType
dstAddressType
=
dstTable
.
addressType
(
)
;
AddressType
srcAddressType
=
srcTable
.
addressType
(
)
;
AddressType
lenAddressType
=
dstAddressType
=
=
AddressType
:
:
I64
&
&
srcAddressType
=
=
AddressType
:
:
I64
?
AddressType
:
:
I64
:
AddressType
:
:
I32
;
MDefinition
*
dst32
=
tableAddressToI32
(
dstAddressType
dst
)
;
if
(
!
dst32
)
{
return
false
;
}
MDefinition
*
src32
=
tableAddressToI32
(
srcAddressType
src
)
;
if
(
!
src32
)
{
return
false
;
}
MDefinition
*
len32
=
tableAddressToI32
(
lenAddressType
len
)
;
if
(
!
len32
)
{
return
false
;
}
MDefinition
*
dti
=
constantI32
(
int32_t
(
dstTableIndex
)
)
;
MDefinition
*
sti
=
constantI32
(
int32_t
(
srcTableIndex
)
)
;
return
emitInstanceCall5
(
bytecodeOffset
SASigTableCopy
dst32
src32
len32
dti
sti
)
;
}
bool
FunctionCompiler
:
:
emitDataOrElemDrop
(
bool
isData
)
{
uint32_t
segIndexVal
=
0
;
if
(
!
iter
(
)
.
readDataOrElemDrop
(
isData
&
segIndexVal
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
MDefinition
*
segIndex
=
constantI32
(
int32_t
(
segIndexVal
)
)
;
const
SymbolicAddressSignature
&
callee
=
isData
?
SASigDataDrop
:
SASigElemDrop
;
return
emitInstanceCall1
(
bytecodeOffset
callee
segIndex
)
;
}
bool
FunctionCompiler
:
:
emitMemFillCall
(
uint32_t
memoryIndex
MDefinition
*
start
MDefinition
*
val
MDefinition
*
len
)
{
MDefinition
*
base
=
memoryBase
(
memoryIndex
)
;
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
const
SymbolicAddressSignature
&
callee
=
(
codeMeta
(
)
.
usesSharedMemory
(
memoryIndex
)
?
(
isMem32
(
memoryIndex
)
?
SASigMemFillSharedM32
:
SASigMemFillSharedM64
)
:
(
isMem32
(
memoryIndex
)
?
SASigMemFillM32
:
SASigMemFillM64
)
)
;
return
emitInstanceCall4
(
bytecodeOffset
callee
start
val
len
base
)
;
}
bool
FunctionCompiler
:
:
emitMemFillInline
(
uint32_t
memoryIndex
MDefinition
*
start
MDefinition
*
val
uint32_t
length
)
{
MOZ_ASSERT
(
length
!
=
0
&
&
length
<
=
MaxInlineMemoryFillLength
)
;
uint32_t
value
=
val
-
>
toConstant
(
)
-
>
toInt32
(
)
;
size_t
remainder
=
length
;
#
ifdef
ENABLE_WASM_SIMD
size_t
numCopies16
=
0
;
if
(
MacroAssembler
:
:
SupportsFastUnalignedFPAccesses
(
)
)
{
numCopies16
=
remainder
/
sizeof
(
V128
)
;
remainder
%
=
sizeof
(
V128
)
;
}
#
endif
#
ifdef
JS_64BIT
size_t
numCopies8
=
remainder
/
sizeof
(
uint64_t
)
;
remainder
%
=
sizeof
(
uint64_t
)
;
#
endif
size_t
numCopies4
=
remainder
/
sizeof
(
uint32_t
)
;
remainder
%
=
sizeof
(
uint32_t
)
;
size_t
numCopies2
=
remainder
/
sizeof
(
uint16_t
)
;
remainder
%
=
sizeof
(
uint16_t
)
;
size_t
numCopies1
=
remainder
;
#
ifdef
ENABLE_WASM_SIMD
MDefinition
*
val16
=
numCopies16
?
constantV128
(
V128
(
value
)
)
:
nullptr
;
#
endif
#
ifdef
JS_64BIT
MDefinition
*
val8
=
numCopies8
?
constantI64
(
int64_t
(
SplatByteToUInt
<
uint64_t
>
(
value
8
)
)
)
:
nullptr
;
#
endif
MDefinition
*
val4
=
numCopies4
?
constantI32
(
int32_t
(
SplatByteToUInt
<
uint32_t
>
(
value
4
)
)
)
:
nullptr
;
MDefinition
*
val2
=
numCopies2
?
constantI32
(
int32_t
(
SplatByteToUInt
<
uint32_t
>
(
value
2
)
)
)
:
nullptr
;
size_t
offset
=
length
;
if
(
numCopies1
)
{
offset
-
=
sizeof
(
uint8_t
)
;
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Uint8
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
store
(
start
&
access
val
)
;
}
if
(
numCopies2
)
{
offset
-
=
sizeof
(
uint16_t
)
;
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Uint16
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
store
(
start
&
access
val2
)
;
}
for
(
uint32_t
i
=
0
;
i
<
numCopies4
;
i
+
+
)
{
offset
-
=
sizeof
(
uint32_t
)
;
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Uint32
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
store
(
start
&
access
val4
)
;
}
#
ifdef
JS_64BIT
for
(
uint32_t
i
=
0
;
i
<
numCopies8
;
i
+
+
)
{
offset
-
=
sizeof
(
uint64_t
)
;
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Int64
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
store
(
start
&
access
val8
)
;
}
#
endif
#
ifdef
ENABLE_WASM_SIMD
for
(
uint32_t
i
=
0
;
i
<
numCopies16
;
i
+
+
)
{
offset
-
=
sizeof
(
V128
)
;
MemoryAccessDesc
access
(
memoryIndex
Scalar
:
:
Simd128
1
offset
trapSiteDesc
(
)
hugeMemoryEnabled
(
memoryIndex
)
)
;
store
(
start
&
access
val16
)
;
}
#
endif
return
true
;
}
bool
FunctionCompiler
:
:
emitMemFill
(
)
{
uint32_t
memoryIndex
;
MDefinition
*
start
*
val
*
len
;
if
(
!
iter
(
)
.
readMemFill
(
&
memoryIndex
&
start
&
val
&
len
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
if
(
len
-
>
isConstant
(
)
&
&
val
-
>
isConstant
(
)
)
{
uint64_t
length
=
isMem32
(
memoryIndex
)
?
len
-
>
toConstant
(
)
-
>
toInt32
(
)
:
len
-
>
toConstant
(
)
-
>
toInt64
(
)
;
static_assert
(
MaxInlineMemoryFillLength
<
=
UINT32_MAX
)
;
if
(
length
!
=
0
&
&
length
<
=
MaxInlineMemoryFillLength
)
{
return
emitMemFillInline
(
memoryIndex
start
val
uint32_t
(
length
)
)
;
}
}
return
emitMemFillCall
(
memoryIndex
start
val
len
)
;
}
bool
FunctionCompiler
:
:
emitMemInit
(
)
{
uint32_t
segIndexVal
=
0
dstMemIndex
=
0
;
MDefinition
*
dstOff
*
srcOff
*
len
;
if
(
!
iter
(
)
.
readMemOrTableInit
(
true
&
segIndexVal
&
dstMemIndex
&
dstOff
&
srcOff
&
len
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
const
SymbolicAddressSignature
&
callee
=
(
isMem32
(
dstMemIndex
)
?
SASigMemInitM32
:
SASigMemInitM64
)
;
MDefinition
*
segIndex
=
constantI32
(
int32_t
(
segIndexVal
)
)
;
if
(
!
segIndex
)
{
return
false
;
}
MDefinition
*
dti
=
constantI32
(
int32_t
(
dstMemIndex
)
)
;
if
(
!
dti
)
{
return
false
;
}
return
emitInstanceCall5
(
bytecodeOffset
callee
dstOff
srcOff
len
segIndex
dti
)
;
}
bool
FunctionCompiler
:
:
emitTableInit
(
)
{
uint32_t
segIndexVal
=
0
dstTableIndex
=
0
;
MDefinition
*
dstOff
*
srcOff
*
len
;
if
(
!
iter
(
)
.
readMemOrTableInit
(
false
&
segIndexVal
&
dstTableIndex
&
dstOff
&
srcOff
&
len
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
const
TableDesc
&
table
=
codeMeta
(
)
.
tables
[
dstTableIndex
]
;
MDefinition
*
dstOff32
=
tableAddressToI32
(
table
.
addressType
(
)
dstOff
)
;
if
(
!
dstOff32
)
{
return
false
;
}
MDefinition
*
segIndex
=
constantI32
(
int32_t
(
segIndexVal
)
)
;
if
(
!
segIndex
)
{
return
false
;
}
MDefinition
*
dti
=
constantI32
(
int32_t
(
dstTableIndex
)
)
;
if
(
!
dti
)
{
return
false
;
}
return
emitInstanceCall5
(
bytecodeOffset
SASigTableInit
dstOff32
srcOff
len
segIndex
dti
)
;
}
bool
FunctionCompiler
:
:
emitTableFill
(
)
{
uint32_t
tableIndex
;
MDefinition
*
start
*
val
*
len
;
if
(
!
iter
(
)
.
readTableFill
(
&
tableIndex
&
start
&
val
&
len
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
const
TableDesc
&
table
=
codeMeta
(
)
.
tables
[
tableIndex
]
;
MDefinition
*
start32
=
tableAddressToI32
(
table
.
addressType
(
)
start
)
;
if
(
!
start32
)
{
return
false
;
}
MDefinition
*
len32
=
tableAddressToI32
(
table
.
addressType
(
)
len
)
;
if
(
!
len32
)
{
return
false
;
}
MDefinition
*
tableIndexArg
=
constantI32
(
int32_t
(
tableIndex
)
)
;
if
(
!
tableIndexArg
)
{
return
false
;
}
return
emitInstanceCall4
(
bytecodeOffset
SASigTableFill
start32
val
len32
tableIndexArg
)
;
}
#
if
ENABLE_WASM_MEMORY_CONTROL
bool
FunctionCompiler
:
:
emitMemDiscard
(
)
{
uint32_t
memoryIndex
;
MDefinition
*
start
*
len
;
if
(
!
iter
(
)
.
readMemDiscard
(
&
memoryIndex
&
start
&
len
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
MDefinition
*
base
=
memoryBase
(
memoryIndex
)
;
bool
mem32
=
isMem32
(
memoryIndex
)
;
const
SymbolicAddressSignature
&
callee
=
(
codeMeta
(
)
.
usesSharedMemory
(
memoryIndex
)
?
(
mem32
?
SASigMemDiscardSharedM32
:
SASigMemDiscardSharedM64
)
:
(
mem32
?
SASigMemDiscardM32
:
SASigMemDiscardM64
)
)
;
return
emitInstanceCall3
(
bytecodeOffset
callee
start
len
base
)
;
}
#
endif
bool
FunctionCompiler
:
:
emitTableGet
(
)
{
uint32_t
tableIndex
;
MDefinition
*
address
;
if
(
!
iter
(
)
.
readTableGet
(
&
tableIndex
&
address
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
const
TableDesc
&
table
=
codeMeta
(
)
.
tables
[
tableIndex
]
;
MDefinition
*
address32
=
tableAddressToI32
(
table
.
addressType
(
)
address
)
;
if
(
!
address32
)
{
return
false
;
}
if
(
table
.
elemType
.
tableRepr
(
)
=
=
TableRepr
:
:
Ref
)
{
MDefinition
*
ret
=
tableGetAnyRef
(
tableIndex
address32
)
;
if
(
!
ret
)
{
return
false
;
}
iter
(
)
.
setResult
(
ret
)
;
return
true
;
}
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
MDefinition
*
tableIndexArg
=
constantI32
(
int32_t
(
tableIndex
)
)
;
if
(
!
tableIndexArg
)
{
return
false
;
}
MDefinition
*
ret
;
if
(
!
emitInstanceCall2
(
bytecodeOffset
SASigTableGet
address32
tableIndexArg
&
ret
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
ret
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitTableGrow
(
)
{
uint32_t
tableIndex
;
MDefinition
*
initValue
;
MDefinition
*
delta
;
if
(
!
iter
(
)
.
readTableGrow
(
&
tableIndex
&
initValue
&
delta
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
const
TableDesc
&
table
=
codeMeta
(
)
.
tables
[
tableIndex
]
;
MDefinition
*
delta32
=
tableAddressToI32
(
table
.
addressType
(
)
delta
)
;
if
(
!
delta32
)
{
return
false
;
}
MDefinition
*
tableIndexArg
=
constantI32
(
int32_t
(
tableIndex
)
)
;
if
(
!
tableIndexArg
)
{
return
false
;
}
MDefinition
*
ret
;
if
(
!
emitInstanceCall3
(
bytecodeOffset
SASigTableGrow
initValue
delta32
tableIndexArg
&
ret
)
)
{
return
false
;
}
if
(
table
.
addressType
(
)
=
=
AddressType
:
:
I64
)
{
ret
=
extendI32
(
ret
false
)
;
if
(
!
ret
)
{
return
false
;
}
}
iter
(
)
.
setResult
(
ret
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitTableSet
(
)
{
uint32_t
tableIndex
;
MDefinition
*
address
;
MDefinition
*
value
;
if
(
!
iter
(
)
.
readTableSet
(
&
tableIndex
&
address
&
value
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
const
TableDesc
&
table
=
codeMeta
(
)
.
tables
[
tableIndex
]
;
MDefinition
*
address32
=
tableAddressToI32
(
table
.
addressType
(
)
address
)
;
if
(
!
address32
)
{
return
false
;
}
if
(
table
.
elemType
.
tableRepr
(
)
=
=
TableRepr
:
:
Ref
)
{
return
tableSetAnyRef
(
tableIndex
address32
value
bytecodeOffset
)
;
}
MDefinition
*
tableIndexArg
=
constantI32
(
int32_t
(
tableIndex
)
)
;
if
(
!
tableIndexArg
)
{
return
false
;
}
return
emitInstanceCall3
(
bytecodeOffset
SASigTableSet
address32
value
tableIndexArg
)
;
}
bool
FunctionCompiler
:
:
emitTableSize
(
)
{
uint32_t
tableIndex
;
if
(
!
iter
(
)
.
readTableSize
(
&
tableIndex
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
length
=
loadTableLength
(
tableIndex
)
;
if
(
!
length
)
{
return
false
;
}
if
(
codeMeta
(
)
.
tables
[
tableIndex
]
.
addressType
(
)
=
=
AddressType
:
:
I64
)
{
length
=
extendI32
(
length
true
)
;
if
(
!
length
)
{
return
false
;
}
}
iter
(
)
.
setResult
(
length
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitRefFunc
(
)
{
uint32_t
funcIndex
;
if
(
!
iter
(
)
.
readRefFunc
(
&
funcIndex
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
MDefinition
*
funcIndexArg
=
constantI32
(
int32_t
(
funcIndex
)
)
;
if
(
!
funcIndexArg
)
{
return
false
;
}
MDefinition
*
ret
;
if
(
!
emitInstanceCall1
(
bytecodeOffset
SASigRefFunc
funcIndexArg
&
ret
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
ret
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitRefNull
(
)
{
RefType
type
;
if
(
!
iter
(
)
.
readRefNull
(
&
type
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
nullVal
=
constantNullRef
(
MaybeRefType
(
type
)
)
;
if
(
!
nullVal
)
{
return
false
;
}
iter
(
)
.
setResult
(
nullVal
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitRefIsNull
(
)
{
MDefinition
*
input
;
if
(
!
iter
(
)
.
readRefIsNull
(
&
input
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
nullVal
=
constantNullRef
(
MaybeRefType
(
)
)
;
if
(
!
nullVal
)
{
return
false
;
}
iter
(
)
.
setResult
(
compare
(
input
nullVal
JSOp
:
:
Eq
MCompare
:
:
Compare_WasmAnyRef
)
)
;
return
true
;
}
#
ifdef
ENABLE_WASM_SIMD
bool
FunctionCompiler
:
:
emitConstSimd128
(
)
{
V128
v128
;
if
(
!
iter
(
)
.
readV128Const
(
&
v128
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
constantV128
(
v128
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitBinarySimd128
(
bool
commutative
SimdOp
op
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readBinary
(
ValType
:
:
V128
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
binarySimd128
(
lhs
rhs
commutative
op
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitTernarySimd128
(
wasm
:
:
SimdOp
op
)
{
MDefinition
*
v0
;
MDefinition
*
v1
;
MDefinition
*
v2
;
if
(
!
iter
(
)
.
readTernary
(
ValType
:
:
V128
&
v0
&
v1
&
v2
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
ternarySimd128
(
v0
v1
v2
op
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitShiftSimd128
(
SimdOp
op
)
{
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readVectorShift
(
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
shiftSimd128
(
lhs
rhs
op
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitSplatSimd128
(
ValType
inType
SimdOp
op
)
{
MDefinition
*
src
;
if
(
!
iter
(
)
.
readConversion
(
inType
ValType
:
:
V128
&
src
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
scalarToSimd128
(
src
op
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitUnarySimd128
(
SimdOp
op
)
{
MDefinition
*
src
;
if
(
!
iter
(
)
.
readUnary
(
ValType
:
:
V128
&
src
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
unarySimd128
(
src
op
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitReduceSimd128
(
SimdOp
op
)
{
MDefinition
*
src
;
if
(
!
iter
(
)
.
readConversion
(
ValType
:
:
V128
ValType
:
:
I32
&
src
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
reduceSimd128
(
src
op
ValType
:
:
I32
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitExtractLaneSimd128
(
ValType
outType
uint32_t
laneLimit
SimdOp
op
)
{
uint32_t
laneIndex
;
MDefinition
*
src
;
if
(
!
iter
(
)
.
readExtractLane
(
outType
laneLimit
&
laneIndex
&
src
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
reduceSimd128
(
src
op
outType
laneIndex
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitReplaceLaneSimd128
(
ValType
laneType
uint32_t
laneLimit
SimdOp
op
)
{
uint32_t
laneIndex
;
MDefinition
*
lhs
;
MDefinition
*
rhs
;
if
(
!
iter
(
)
.
readReplaceLane
(
laneType
laneLimit
&
laneIndex
&
lhs
&
rhs
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
replaceLaneSimd128
(
lhs
rhs
laneIndex
op
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitShuffleSimd128
(
)
{
MDefinition
*
v1
;
MDefinition
*
v2
;
V128
control
;
if
(
!
iter
(
)
.
readVectorShuffle
(
&
v1
&
v2
&
control
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
shuffleSimd128
(
v1
v2
control
)
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitLoadSplatSimd128
(
Scalar
:
:
Type
viewType
wasm
:
:
SimdOp
splatOp
)
{
LinearMemoryAddress
<
MDefinition
*
>
addr
;
if
(
!
iter
(
)
.
readLoadSplat
(
Scalar
:
:
byteSize
(
viewType
)
&
addr
)
)
{
return
false
;
}
auto
*
ins
=
loadSplatSimd128
(
viewType
addr
splatOp
)
;
if
(
!
inDeadCode
(
)
&
&
!
ins
)
{
return
false
;
}
iter
(
)
.
setResult
(
ins
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitLoadExtendSimd128
(
wasm
:
:
SimdOp
op
)
{
LinearMemoryAddress
<
MDefinition
*
>
addr
;
if
(
!
iter
(
)
.
readLoadExtend
(
&
addr
)
)
{
return
false
;
}
auto
*
ins
=
loadExtendSimd128
(
addr
op
)
;
if
(
!
inDeadCode
(
)
&
&
!
ins
)
{
return
false
;
}
iter
(
)
.
setResult
(
ins
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitLoadZeroSimd128
(
Scalar
:
:
Type
viewType
size_t
numBytes
)
{
LinearMemoryAddress
<
MDefinition
*
>
addr
;
if
(
!
iter
(
)
.
readLoadSplat
(
numBytes
&
addr
)
)
{
return
false
;
}
auto
*
ins
=
loadZeroSimd128
(
viewType
numBytes
addr
)
;
if
(
!
inDeadCode
(
)
&
&
!
ins
)
{
return
false
;
}
iter
(
)
.
setResult
(
ins
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitLoadLaneSimd128
(
uint32_t
laneSize
)
{
uint32_t
laneIndex
;
MDefinition
*
src
;
LinearMemoryAddress
<
MDefinition
*
>
addr
;
if
(
!
iter
(
)
.
readLoadLane
(
laneSize
&
addr
&
laneIndex
&
src
)
)
{
return
false
;
}
auto
*
ins
=
loadLaneSimd128
(
laneSize
addr
laneIndex
src
)
;
if
(
!
inDeadCode
(
)
&
&
!
ins
)
{
return
false
;
}
iter
(
)
.
setResult
(
ins
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitStoreLaneSimd128
(
uint32_t
laneSize
)
{
uint32_t
laneIndex
;
MDefinition
*
src
;
LinearMemoryAddress
<
MDefinition
*
>
addr
;
if
(
!
iter
(
)
.
readStoreLane
(
laneSize
&
addr
&
laneIndex
&
src
)
)
{
return
false
;
}
storeLaneSimd128
(
laneSize
addr
laneIndex
src
)
;
return
true
;
}
#
endif
bool
FunctionCompiler
:
:
emitRefAsNonNull
(
)
{
MDefinition
*
ref
;
if
(
!
iter
(
)
.
readRefAsNonNull
(
&
ref
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
ins
=
refAsNonNull
(
ref
)
;
if
(
!
ins
)
{
return
false
;
}
iter
(
)
.
setResult
(
ins
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitBrOnNull
(
)
{
uint32_t
relativeDepth
;
ResultType
type
;
DefVector
values
;
MDefinition
*
condition
;
if
(
!
iter
(
)
.
readBrOnNull
(
&
relativeDepth
&
type
&
values
&
condition
)
)
{
return
false
;
}
return
brOnNull
(
relativeDepth
values
type
condition
)
;
}
bool
FunctionCompiler
:
:
emitBrOnNonNull
(
)
{
uint32_t
relativeDepth
;
ResultType
type
;
DefVector
values
;
MDefinition
*
condition
;
if
(
!
iter
(
)
.
readBrOnNonNull
(
&
relativeDepth
&
type
&
values
&
condition
)
)
{
return
false
;
}
return
brOnNonNull
(
relativeDepth
values
type
condition
)
;
}
bool
FunctionCompiler
:
:
emitSpeculativeInlineCallRef
(
uint32_t
bytecodeOffset
const
FuncType
&
funcType
CallRefHint
expectedFuncIndices
MDefinition
*
actualCalleeFunc
const
DefVector
&
args
DefVector
*
results
)
{
MOZ_ASSERT
(
!
expectedFuncIndices
.
empty
(
)
)
;
actualCalleeFunc
=
refAsNonNull
(
actualCalleeFunc
)
;
if
(
!
actualCalleeFunc
)
{
return
false
;
}
constexpr
size_t
numElseBlocks
=
CallRefHint
:
:
NUM_ENTRIES
+
1
;
Vector
<
MBasicBlock
*
numElseBlocks
SystemAllocPolicy
>
elseBlocks
;
if
(
!
elseBlocks
.
reserve
(
numElseBlocks
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
expectedFuncIndices
.
length
(
)
;
i
+
+
)
{
uint32_t
funcIndex
=
expectedFuncIndices
.
get
(
i
)
;
MDefinition
*
expectedCalleeFunc
=
loadCachedRefFunc
(
funcIndex
)
;
if
(
!
expectedCalleeFunc
)
{
return
false
;
}
MDefinition
*
isExpectedCallee
=
compare
(
actualCalleeFunc
expectedCalleeFunc
JSOp
:
:
Eq
MCompare
:
:
Compare_WasmAnyRef
)
;
if
(
!
isExpectedCallee
)
{
return
false
;
}
MBasicBlock
*
elseBlock
;
if
(
!
branchAndStartThen
(
isExpectedCallee
&
elseBlock
)
)
{
return
false
;
}
DefVector
inlineResults
;
if
(
!
emitInlineCall
(
funcType
funcIndex
InliningHeuristics
:
:
CallKind
:
:
CallRef
args
&
inlineResults
)
)
{
return
false
;
}
if
(
!
pushDefs
(
inlineResults
)
)
{
return
false
;
}
if
(
!
switchToElse
(
elseBlock
&
elseBlock
)
)
{
return
false
;
}
elseBlocks
.
infallibleAppend
(
elseBlock
)
;
}
DefVector
callResults
;
if
(
!
callRef
(
funcType
actualCalleeFunc
bytecodeOffset
args
&
callResults
)
)
{
return
false
;
}
if
(
!
pushDefs
(
callResults
)
)
{
return
false
;
}
for
(
uint32_t
i
=
elseBlocks
.
length
(
)
-
1
;
i
!
=
0
;
i
-
-
)
{
DefVector
results
;
if
(
!
joinIfElse
(
elseBlocks
[
i
]
&
results
)
|
|
!
pushDefs
(
results
)
)
{
return
false
;
}
}
return
joinIfElse
(
elseBlocks
[
0
]
results
)
;
}
bool
FunctionCompiler
:
:
emitCallRef
(
)
{
uint32_t
bytecodeOffset
=
readBytecodeOffset
(
)
;
uint32_t
funcTypeIndex
;
MDefinition
*
callee
;
DefVector
args
;
if
(
!
iter
(
)
.
readCallRef
(
&
funcTypeIndex
&
callee
&
args
)
)
{
return
false
;
}
CallRefHint
hint
=
readCallRefHint
(
)
;
if
(
inDeadCode
(
)
)
{
return
true
;
}
const
FuncType
&
funcType
=
codeMeta
(
)
.
types
-
>
type
(
funcTypeIndex
)
.
funcType
(
)
;
CallRefHint
approved
=
auditInlineableCallees
(
InliningHeuristics
:
:
CallKind
:
:
CallRef
hint
)
;
if
(
!
approved
.
empty
(
)
)
{
DefVector
results
;
if
(
!
emitSpeculativeInlineCallRef
(
bytecodeOffset
funcType
approved
callee
args
&
results
)
)
{
return
false
;
}
iter
(
)
.
setResults
(
results
.
length
(
)
results
)
;
return
true
;
}
DefVector
results
;
if
(
!
callRef
(
funcType
callee
bytecodeOffset
args
&
results
)
)
{
return
false
;
}
iter
(
)
.
setResults
(
results
.
length
(
)
results
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitStructNew
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
typeIndex
;
DefVector
args
;
if
(
!
iter
(
)
.
readStructNew
(
&
typeIndex
&
args
)
)
{
return
false
;
}
uint32_t
allocSiteIndex
=
readAllocSiteIndex
(
typeIndex
)
;
if
(
inDeadCode
(
)
)
{
return
true
;
}
const
TypeDef
&
typeDef
=
(
*
codeMeta
(
)
.
types
)
[
typeIndex
]
;
const
StructType
&
structType
=
typeDef
.
structType
(
)
;
MOZ_ASSERT
(
args
.
length
(
)
=
=
structType
.
fields_
.
length
(
)
)
;
MDefinition
*
structObject
=
createStructObject
(
typeIndex
allocSiteIndex
false
)
;
if
(
!
structObject
)
{
return
false
;
}
for
(
uint32_t
fieldIndex
=
0
;
fieldIndex
<
structType
.
fields_
.
length
(
)
;
fieldIndex
+
+
)
{
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
if
(
!
writeValueToStructField
(
lineOrBytecode
structType
fieldIndex
structObject
args
[
fieldIndex
]
WasmPreBarrierKind
:
:
None
)
)
{
return
false
;
}
}
iter
(
)
.
setResult
(
structObject
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitStructNewDefault
(
)
{
uint32_t
typeIndex
;
if
(
!
iter
(
)
.
readStructNewDefault
(
&
typeIndex
)
)
{
return
false
;
}
uint32_t
allocSiteIndex
=
readAllocSiteIndex
(
typeIndex
)
;
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
structObject
=
createStructObject
(
typeIndex
allocSiteIndex
true
)
;
if
(
!
structObject
)
{
return
false
;
}
iter
(
)
.
setResult
(
structObject
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitStructSet
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
typeIndex
;
uint32_t
fieldIndex
;
MDefinition
*
structObject
;
MDefinition
*
value
;
if
(
!
iter
(
)
.
readStructSet
(
&
typeIndex
&
fieldIndex
&
structObject
&
value
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
const
StructType
&
structType
=
(
*
codeMeta
(
)
.
types
)
[
typeIndex
]
.
structType
(
)
;
return
writeValueToStructField
(
lineOrBytecode
structType
fieldIndex
structObject
value
WasmPreBarrierKind
:
:
Normal
)
;
}
bool
FunctionCompiler
:
:
emitStructGet
(
FieldWideningOp
wideningOp
)
{
uint32_t
typeIndex
;
uint32_t
fieldIndex
;
MDefinition
*
structObject
;
if
(
!
iter
(
)
.
readStructGet
(
&
typeIndex
&
fieldIndex
wideningOp
&
structObject
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
const
StructType
&
structType
=
(
*
codeMeta
(
)
.
types
)
[
typeIndex
]
.
structType
(
)
;
MDefinition
*
load
=
readValueFromStructField
(
structType
fieldIndex
wideningOp
structObject
)
;
if
(
!
load
)
{
return
false
;
}
iter
(
)
.
setResult
(
load
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitArrayNew
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
typeIndex
;
MDefinition
*
numElements
;
MDefinition
*
fillValue
;
if
(
!
iter
(
)
.
readArrayNew
(
&
typeIndex
&
numElements
&
fillValue
)
)
{
return
false
;
}
uint32_t
allocSiteIndex
=
readAllocSiteIndex
(
typeIndex
)
;
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
arrayObject
=
createArrayNewCallAndLoop
(
lineOrBytecode
typeIndex
allocSiteIndex
numElements
fillValue
)
;
if
(
!
arrayObject
)
{
return
false
;
}
iter
(
)
.
setResult
(
arrayObject
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitArrayNewDefault
(
)
{
uint32_t
typeIndex
;
MDefinition
*
numElements
;
if
(
!
iter
(
)
.
readArrayNewDefault
(
&
typeIndex
&
numElements
)
)
{
return
false
;
}
uint32_t
allocSiteIndex
=
readAllocSiteIndex
(
typeIndex
)
;
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
arrayObject
=
createArrayObject
(
typeIndex
allocSiteIndex
numElements
true
)
;
if
(
!
arrayObject
)
{
return
false
;
}
iter
(
)
.
setResult
(
arrayObject
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitArrayNewFixed
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
typeIndex
numElements
;
DefVector
values
;
if
(
!
iter
(
)
.
readArrayNewFixed
(
&
typeIndex
&
numElements
&
values
)
)
{
return
false
;
}
MOZ_ASSERT
(
values
.
length
(
)
=
=
numElements
)
;
uint32_t
allocSiteIndex
=
readAllocSiteIndex
(
typeIndex
)
;
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
numElementsDef
=
constantI32
(
int32_t
(
numElements
)
)
;
if
(
!
numElementsDef
)
{
return
false
;
}
const
ArrayType
&
arrayType
=
(
*
codeMeta
(
)
.
types
)
[
typeIndex
]
.
arrayType
(
)
;
StorageType
elemType
=
arrayType
.
elementType
(
)
;
uint32_t
elemSize
=
elemType
.
size
(
)
;
MDefinition
*
arrayObject
=
createArrayObject
(
typeIndex
allocSiteIndex
numElementsDef
false
)
;
if
(
!
arrayObject
)
{
return
false
;
}
MDefinition
*
base
=
getWasmArrayObjectData
(
arrayObject
)
;
if
(
!
base
)
{
return
false
;
}
static_assert
(
16
*
MaxFunctionBytes
<
=
MaxArrayPayloadBytes
)
;
MOZ_RELEASE_ASSERT
(
numElements
<
=
MaxFunctionBytes
)
;
for
(
uint32_t
i
=
0
;
i
<
numElements
;
i
+
+
)
{
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
if
(
!
writeGcValueAtBasePlusOffset
(
lineOrBytecode
elemType
arrayObject
AliasSet
:
:
WasmArrayDataArea
values
[
numElements
-
1
-
i
]
base
i
*
elemSize
i
false
WasmPreBarrierKind
:
:
None
)
)
{
return
false
;
}
}
iter
(
)
.
setResult
(
arrayObject
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitArrayNewData
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
typeIndex
segIndex
;
MDefinition
*
segByteOffset
;
MDefinition
*
numElements
;
if
(
!
iter
(
)
.
readArrayNewData
(
&
typeIndex
&
segIndex
&
segByteOffset
&
numElements
)
)
{
return
false
;
}
uint32_t
allocSiteIndex
=
readAllocSiteIndex
(
typeIndex
)
;
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
typeIndexValue
=
constantI32
(
int32_t
(
typeIndex
)
)
;
if
(
!
typeIndexValue
)
{
return
false
;
}
MDefinition
*
allocSite
=
loadAllocSiteInstanceData
(
allocSiteIndex
)
;
if
(
!
allocSite
)
{
return
false
;
}
MDefinition
*
segIndexM
=
constantI32
(
int32_t
(
segIndex
)
)
;
if
(
!
segIndexM
)
{
return
false
;
}
MDefinition
*
arrayObject
;
if
(
!
emitInstanceCall5
(
lineOrBytecode
SASigArrayNewData
segByteOffset
numElements
typeIndexValue
allocSite
segIndexM
&
arrayObject
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
arrayObject
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitArrayNewElem
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
typeIndex
segIndex
;
MDefinition
*
segElemIndex
;
MDefinition
*
numElements
;
if
(
!
iter
(
)
.
readArrayNewElem
(
&
typeIndex
&
segIndex
&
segElemIndex
&
numElements
)
)
{
return
false
;
}
uint32_t
allocSiteIndex
=
readAllocSiteIndex
(
typeIndex
)
;
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
typeIndexValue
=
constantI32
(
int32_t
(
typeIndex
)
)
;
if
(
!
typeIndexValue
)
{
return
false
;
}
MDefinition
*
allocSite
=
loadAllocSiteInstanceData
(
allocSiteIndex
)
;
if
(
!
allocSite
)
{
return
false
;
}
MDefinition
*
segIndexM
=
constantI32
(
int32_t
(
segIndex
)
)
;
if
(
!
segIndexM
)
{
return
false
;
}
MDefinition
*
arrayObject
;
if
(
!
emitInstanceCall5
(
lineOrBytecode
SASigArrayNewElem
segElemIndex
numElements
typeIndexValue
allocSite
segIndexM
&
arrayObject
)
)
{
return
false
;
}
iter
(
)
.
setResult
(
arrayObject
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitArrayInitData
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
unusedTypeIndex
segIndex
;
MDefinition
*
array
;
MDefinition
*
arrayIndex
;
MDefinition
*
segOffset
;
MDefinition
*
length
;
if
(
!
iter
(
)
.
readArrayInitData
(
&
unusedTypeIndex
&
segIndex
&
array
&
arrayIndex
&
segOffset
&
length
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
segIndexM
=
constantI32
(
int32_t
(
segIndex
)
)
;
if
(
!
segIndexM
)
{
return
false
;
}
return
emitInstanceCall5
(
lineOrBytecode
SASigArrayInitData
array
arrayIndex
segOffset
length
segIndexM
)
;
}
bool
FunctionCompiler
:
:
emitArrayInitElem
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
typeIndex
segIndex
;
MDefinition
*
array
;
MDefinition
*
arrayIndex
;
MDefinition
*
segOffset
;
MDefinition
*
length
;
if
(
!
iter
(
)
.
readArrayInitElem
(
&
typeIndex
&
segIndex
&
array
&
arrayIndex
&
segOffset
&
length
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
typeIndexValue
=
constantI32
(
int32_t
(
typeIndex
)
)
;
if
(
!
typeIndexValue
)
{
return
false
;
}
MDefinition
*
segIndexM
=
constantI32
(
int32_t
(
segIndex
)
)
;
if
(
!
segIndexM
)
{
return
false
;
}
return
emitInstanceCall6
(
lineOrBytecode
SASigArrayInitElem
array
arrayIndex
segOffset
length
typeIndexValue
segIndexM
)
;
}
bool
FunctionCompiler
:
:
emitArraySet
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
typeIndex
;
MDefinition
*
value
;
MDefinition
*
index
;
MDefinition
*
arrayObject
;
if
(
!
iter
(
)
.
readArraySet
(
&
typeIndex
&
value
&
index
&
arrayObject
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
base
=
setupForArrayAccess
(
arrayObject
index
)
;
if
(
!
base
)
{
return
false
;
}
const
ArrayType
&
arrayType
=
(
*
codeMeta
(
)
.
types
)
[
typeIndex
]
.
arrayType
(
)
;
StorageType
elemType
=
arrayType
.
elementType
(
)
;
uint32_t
elemSize
=
elemType
.
size
(
)
;
MOZ_ASSERT
(
elemSize
>
=
1
&
&
elemSize
<
=
16
)
;
return
writeGcValueAtBasePlusScaledIndex
(
lineOrBytecode
elemType
arrayObject
AliasSet
:
:
WasmArrayDataArea
value
base
elemSize
index
WasmPreBarrierKind
:
:
Normal
)
;
}
bool
FunctionCompiler
:
:
emitArrayGet
(
FieldWideningOp
wideningOp
)
{
uint32_t
typeIndex
;
MDefinition
*
index
;
MDefinition
*
arrayObject
;
if
(
!
iter
(
)
.
readArrayGet
(
&
typeIndex
wideningOp
&
index
&
arrayObject
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
base
=
setupForArrayAccess
(
arrayObject
index
)
;
if
(
!
base
)
{
return
false
;
}
const
ArrayType
&
arrayType
=
(
*
codeMeta
(
)
.
types
)
[
typeIndex
]
.
arrayType
(
)
;
StorageType
elemType
=
arrayType
.
elementType
(
)
;
MDefinition
*
load
=
readGcArrayValueAtIndex
(
elemType
wideningOp
arrayObject
AliasSet
:
:
WasmArrayDataArea
base
index
)
;
if
(
!
load
)
{
return
false
;
}
iter
(
)
.
setResult
(
load
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitArrayLen
(
)
{
MDefinition
*
arrayObject
;
if
(
!
iter
(
)
.
readArrayLen
(
&
arrayObject
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
numElements
=
getWasmArrayObjectNumElements
(
arrayObject
)
;
if
(
!
numElements
)
{
return
false
;
}
iter
(
)
.
setResult
(
numElements
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitArrayCopy
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
dstArrayTypeIndex
;
uint32_t
srcArrayTypeIndex
;
MDefinition
*
dstArrayObject
;
MDefinition
*
dstArrayIndex
;
MDefinition
*
srcArrayObject
;
MDefinition
*
srcArrayIndex
;
MDefinition
*
numElements
;
if
(
!
iter
(
)
.
readArrayCopy
(
&
dstArrayTypeIndex
&
srcArrayTypeIndex
&
dstArrayObject
&
dstArrayIndex
&
srcArrayObject
&
srcArrayIndex
&
numElements
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
const
ArrayType
&
dstArrayType
=
codeMeta
(
)
.
types
-
>
type
(
dstArrayTypeIndex
)
.
arrayType
(
)
;
StorageType
dstElemType
=
dstArrayType
.
elementType
(
)
;
int32_t
elemSize
=
int32_t
(
dstElemType
.
size
(
)
)
;
bool
elemsAreRefTyped
=
dstElemType
.
isRefType
(
)
;
return
createArrayCopy
(
lineOrBytecode
dstArrayObject
dstArrayIndex
srcArrayObject
srcArrayIndex
numElements
elemSize
elemsAreRefTyped
)
;
}
bool
FunctionCompiler
:
:
emitArrayFill
(
)
{
uint32_t
lineOrBytecode
=
readCallSiteLineOrBytecode
(
)
;
uint32_t
typeIndex
;
MDefinition
*
array
;
MDefinition
*
index
;
MDefinition
*
val
;
MDefinition
*
numElements
;
if
(
!
iter
(
)
.
readArrayFill
(
&
typeIndex
&
array
&
index
&
val
&
numElements
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
return
createArrayFill
(
lineOrBytecode
typeIndex
array
index
val
numElements
)
;
}
bool
FunctionCompiler
:
:
emitRefI31
(
)
{
MDefinition
*
input
;
if
(
!
iter
(
)
.
readConversion
(
ValType
:
:
I32
ValType
(
RefType
:
:
i31
(
)
.
asNonNullable
(
)
)
&
input
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
output
=
refI31
(
input
)
;
if
(
!
output
)
{
return
false
;
}
iter
(
)
.
setResult
(
output
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitI31Get
(
FieldWideningOp
wideningOp
)
{
MOZ_ASSERT
(
wideningOp
!
=
FieldWideningOp
:
:
None
)
;
MDefinition
*
input
;
if
(
!
iter
(
)
.
readConversion
(
ValType
(
RefType
:
:
i31
(
)
)
ValType
:
:
I32
&
input
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
input
=
refAsNonNull
(
input
)
;
if
(
!
input
)
{
return
false
;
}
MDefinition
*
output
=
i31Get
(
input
wideningOp
)
;
if
(
!
output
)
{
return
false
;
}
iter
(
)
.
setResult
(
output
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitRefTest
(
bool
nullable
)
{
MDefinition
*
ref
;
RefType
sourceType
;
RefType
destType
;
if
(
!
iter
(
)
.
readRefTest
(
nullable
&
sourceType
&
destType
&
ref
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
success
=
refTest
(
ref
destType
)
;
if
(
!
success
)
{
return
false
;
}
iter
(
)
.
setResult
(
success
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitRefCast
(
bool
nullable
)
{
MDefinition
*
ref
;
RefType
sourceType
;
RefType
destType
;
if
(
!
iter
(
)
.
readRefCast
(
nullable
&
sourceType
&
destType
&
ref
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
castedRef
=
refCast
(
ref
destType
)
;
if
(
!
castedRef
)
{
return
false
;
}
iter
(
)
.
setResult
(
castedRef
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitBrOnCast
(
bool
onSuccess
)
{
uint32_t
labelRelativeDepth
;
RefType
sourceType
;
RefType
destType
;
ResultType
labelType
;
DefVector
values
;
if
(
!
iter
(
)
.
readBrOnCast
(
onSuccess
&
labelRelativeDepth
&
sourceType
&
destType
&
labelType
&
values
)
)
{
return
false
;
}
return
brOnCastCommon
(
onSuccess
labelRelativeDepth
sourceType
destType
labelType
values
)
;
}
bool
FunctionCompiler
:
:
emitAnyConvertExtern
(
)
{
MDefinition
*
ref
;
if
(
!
iter
(
)
.
readRefConversion
(
RefType
:
:
extern_
(
)
RefType
:
:
any
(
)
&
ref
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
conversion
=
convertAnyExtern
(
ref
wasm
:
:
RefType
:
:
Kind
:
:
Any
)
;
if
(
!
conversion
)
{
return
false
;
}
iter
(
)
.
setResult
(
conversion
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitExternConvertAny
(
)
{
MDefinition
*
ref
;
if
(
!
iter
(
)
.
readRefConversion
(
RefType
:
:
any
(
)
RefType
:
:
extern_
(
)
&
ref
)
)
{
return
false
;
}
if
(
inDeadCode
(
)
)
{
return
true
;
}
MDefinition
*
conversion
=
convertAnyExtern
(
ref
wasm
:
:
RefType
:
:
Kind
:
:
Extern
)
;
if
(
!
conversion
)
{
return
false
;
}
iter
(
)
.
setResult
(
conversion
)
;
return
true
;
}
bool
FunctionCompiler
:
:
emitCallBuiltinModuleFunc
(
)
{
const
BuiltinModuleFunc
*
builtinModuleFunc
;
DefVector
params
;
if
(
!
iter
(
)
.
readCallBuiltinModuleFunc
(
&
builtinModuleFunc
&
params
)
)
{
return
false
;
}
return
callBuiltinModuleFunc
(
*
builtinModuleFunc
params
)
;
}
bool
FunctionCompiler
:
:
emitBodyExprs
(
)
{
if
(
!
iter
(
)
.
startFunction
(
funcIndex
(
)
)
)
{
return
false
;
}
#
define
CHECK
(
c
)
\
if
(
!
(
c
)
)
return
false
;
\
break
while
(
true
)
{
if
(
!
mirGen
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
OpBytes
op
;
if
(
!
iter
(
)
.
readOp
(
&
op
)
)
{
return
false
;
}
switch
(
op
.
b0
)
{
case
uint16_t
(
Op
:
:
End
)
:
if
(
!
emitEnd
(
)
)
{
return
false
;
}
if
(
iter
(
)
.
controlStackEmpty
(
)
)
{
return
true
;
}
break
;
case
uint16_t
(
Op
:
:
Unreachable
)
:
CHECK
(
emitUnreachable
(
)
)
;
case
uint16_t
(
Op
:
:
Nop
)
:
CHECK
(
iter
(
)
.
readNop
(
)
)
;
case
uint16_t
(
Op
:
:
Block
)
:
CHECK
(
emitBlock
(
)
)
;
case
uint16_t
(
Op
:
:
Loop
)
:
CHECK
(
emitLoop
(
)
)
;
case
uint16_t
(
Op
:
:
If
)
:
CHECK
(
emitIf
(
)
)
;
case
uint16_t
(
Op
:
:
Else
)
:
CHECK
(
emitElse
(
)
)
;
case
uint16_t
(
Op
:
:
Try
)
:
CHECK
(
emitTry
(
)
)
;
case
uint16_t
(
Op
:
:
Catch
)
:
CHECK
(
emitCatch
(
)
)
;
case
uint16_t
(
Op
:
:
CatchAll
)
:
CHECK
(
emitCatchAll
(
)
)
;
case
uint16_t
(
Op
:
:
Delegate
)
:
CHECK
(
emitDelegate
(
)
)
;
case
uint16_t
(
Op
:
:
Throw
)
:
CHECK
(
emitThrow
(
)
)
;
case
uint16_t
(
Op
:
:
Rethrow
)
:
CHECK
(
emitRethrow
(
)
)
;
case
uint16_t
(
Op
:
:
ThrowRef
)
:
if
(
!
codeMeta
(
)
.
exnrefEnabled
(
)
)
{
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
CHECK
(
emitThrowRef
(
)
)
;
case
uint16_t
(
Op
:
:
TryTable
)
:
if
(
!
codeMeta
(
)
.
exnrefEnabled
(
)
)
{
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
CHECK
(
emitTryTable
(
)
)
;
case
uint16_t
(
Op
:
:
Br
)
:
CHECK
(
emitBr
(
)
)
;
case
uint16_t
(
Op
:
:
BrIf
)
:
CHECK
(
emitBrIf
(
)
)
;
case
uint16_t
(
Op
:
:
BrTable
)
:
CHECK
(
emitBrTable
(
)
)
;
case
uint16_t
(
Op
:
:
Return
)
:
CHECK
(
emitReturn
(
)
)
;
case
uint16_t
(
Op
:
:
Call
)
:
CHECK
(
emitCall
(
false
)
)
;
case
uint16_t
(
Op
:
:
CallIndirect
)
:
CHECK
(
emitCallIndirect
(
false
)
)
;
case
uint16_t
(
Op
:
:
Drop
)
:
CHECK
(
iter
(
)
.
readDrop
(
)
)
;
case
uint16_t
(
Op
:
:
SelectNumeric
)
:
CHECK
(
emitSelect
(
false
)
)
;
case
uint16_t
(
Op
:
:
SelectTyped
)
:
CHECK
(
emitSelect
(
true
)
)
;
case
uint16_t
(
Op
:
:
LocalGet
)
:
CHECK
(
emitGetLocal
(
)
)
;
case
uint16_t
(
Op
:
:
LocalSet
)
:
CHECK
(
emitSetLocal
(
)
)
;
case
uint16_t
(
Op
:
:
LocalTee
)
:
CHECK
(
emitTeeLocal
(
)
)
;
case
uint16_t
(
Op
:
:
GlobalGet
)
:
CHECK
(
emitGetGlobal
(
)
)
;
case
uint16_t
(
Op
:
:
GlobalSet
)
:
CHECK
(
emitSetGlobal
(
)
)
;
case
uint16_t
(
Op
:
:
TableGet
)
:
CHECK
(
emitTableGet
(
)
)
;
case
uint16_t
(
Op
:
:
TableSet
)
:
CHECK
(
emitTableSet
(
)
)
;
case
uint16_t
(
Op
:
:
I32Load
)
:
CHECK
(
emitLoad
(
ValType
:
:
I32
Scalar
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
I64Load
)
:
CHECK
(
emitLoad
(
ValType
:
:
I64
Scalar
:
:
Int64
)
)
;
case
uint16_t
(
Op
:
:
F32Load
)
:
CHECK
(
emitLoad
(
ValType
:
:
F32
Scalar
:
:
Float32
)
)
;
case
uint16_t
(
Op
:
:
F64Load
)
:
CHECK
(
emitLoad
(
ValType
:
:
F64
Scalar
:
:
Float64
)
)
;
case
uint16_t
(
Op
:
:
I32Load8S
)
:
CHECK
(
emitLoad
(
ValType
:
:
I32
Scalar
:
:
Int8
)
)
;
case
uint16_t
(
Op
:
:
I32Load8U
)
:
CHECK
(
emitLoad
(
ValType
:
:
I32
Scalar
:
:
Uint8
)
)
;
case
uint16_t
(
Op
:
:
I32Load16S
)
:
CHECK
(
emitLoad
(
ValType
:
:
I32
Scalar
:
:
Int16
)
)
;
case
uint16_t
(
Op
:
:
I32Load16U
)
:
CHECK
(
emitLoad
(
ValType
:
:
I32
Scalar
:
:
Uint16
)
)
;
case
uint16_t
(
Op
:
:
I64Load8S
)
:
CHECK
(
emitLoad
(
ValType
:
:
I64
Scalar
:
:
Int8
)
)
;
case
uint16_t
(
Op
:
:
I64Load8U
)
:
CHECK
(
emitLoad
(
ValType
:
:
I64
Scalar
:
:
Uint8
)
)
;
case
uint16_t
(
Op
:
:
I64Load16S
)
:
CHECK
(
emitLoad
(
ValType
:
:
I64
Scalar
:
:
Int16
)
)
;
case
uint16_t
(
Op
:
:
I64Load16U
)
:
CHECK
(
emitLoad
(
ValType
:
:
I64
Scalar
:
:
Uint16
)
)
;
case
uint16_t
(
Op
:
:
I64Load32S
)
:
CHECK
(
emitLoad
(
ValType
:
:
I64
Scalar
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
I64Load32U
)
:
CHECK
(
emitLoad
(
ValType
:
:
I64
Scalar
:
:
Uint32
)
)
;
case
uint16_t
(
Op
:
:
I32Store
)
:
CHECK
(
emitStore
(
ValType
:
:
I32
Scalar
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
I64Store
)
:
CHECK
(
emitStore
(
ValType
:
:
I64
Scalar
:
:
Int64
)
)
;
case
uint16_t
(
Op
:
:
F32Store
)
:
CHECK
(
emitStore
(
ValType
:
:
F32
Scalar
:
:
Float32
)
)
;
case
uint16_t
(
Op
:
:
F64Store
)
:
CHECK
(
emitStore
(
ValType
:
:
F64
Scalar
:
:
Float64
)
)
;
case
uint16_t
(
Op
:
:
I32Store8
)
:
CHECK
(
emitStore
(
ValType
:
:
I32
Scalar
:
:
Int8
)
)
;
case
uint16_t
(
Op
:
:
I32Store16
)
:
CHECK
(
emitStore
(
ValType
:
:
I32
Scalar
:
:
Int16
)
)
;
case
uint16_t
(
Op
:
:
I64Store8
)
:
CHECK
(
emitStore
(
ValType
:
:
I64
Scalar
:
:
Int8
)
)
;
case
uint16_t
(
Op
:
:
I64Store16
)
:
CHECK
(
emitStore
(
ValType
:
:
I64
Scalar
:
:
Int16
)
)
;
case
uint16_t
(
Op
:
:
I64Store32
)
:
CHECK
(
emitStore
(
ValType
:
:
I64
Scalar
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
MemorySize
)
:
CHECK
(
emitMemorySize
(
)
)
;
case
uint16_t
(
Op
:
:
MemoryGrow
)
:
CHECK
(
emitMemoryGrow
(
)
)
;
case
uint16_t
(
Op
:
:
I32Const
)
:
CHECK
(
emitI32Const
(
)
)
;
case
uint16_t
(
Op
:
:
I64Const
)
:
CHECK
(
emitI64Const
(
)
)
;
case
uint16_t
(
Op
:
:
F32Const
)
:
CHECK
(
emitF32Const
(
)
)
;
case
uint16_t
(
Op
:
:
F64Const
)
:
CHECK
(
emitF64Const
(
)
)
;
case
uint16_t
(
Op
:
:
I32Eqz
)
:
CHECK
(
emitConversion
<
MNot
>
(
ValType
:
:
I32
ValType
:
:
I32
)
)
;
case
uint16_t
(
Op
:
:
I32Eq
)
:
CHECK
(
emitComparison
(
ValType
:
:
I32
JSOp
:
:
Eq
MCompare
:
:
Compare_Int32
)
)
;
case
uint16_t
(
Op
:
:
I32Ne
)
:
CHECK
(
emitComparison
(
ValType
:
:
I32
JSOp
:
:
Ne
MCompare
:
:
Compare_Int32
)
)
;
case
uint16_t
(
Op
:
:
I32LtS
)
:
CHECK
(
emitComparison
(
ValType
:
:
I32
JSOp
:
:
Lt
MCompare
:
:
Compare_Int32
)
)
;
case
uint16_t
(
Op
:
:
I32LtU
)
:
CHECK
(
emitComparison
(
ValType
:
:
I32
JSOp
:
:
Lt
MCompare
:
:
Compare_UInt32
)
)
;
case
uint16_t
(
Op
:
:
I32GtS
)
:
CHECK
(
emitComparison
(
ValType
:
:
I32
JSOp
:
:
Gt
MCompare
:
:
Compare_Int32
)
)
;
case
uint16_t
(
Op
:
:
I32GtU
)
:
CHECK
(
emitComparison
(
ValType
:
:
I32
JSOp
:
:
Gt
MCompare
:
:
Compare_UInt32
)
)
;
case
uint16_t
(
Op
:
:
I32LeS
)
:
CHECK
(
emitComparison
(
ValType
:
:
I32
JSOp
:
:
Le
MCompare
:
:
Compare_Int32
)
)
;
case
uint16_t
(
Op
:
:
I32LeU
)
:
CHECK
(
emitComparison
(
ValType
:
:
I32
JSOp
:
:
Le
MCompare
:
:
Compare_UInt32
)
)
;
case
uint16_t
(
Op
:
:
I32GeS
)
:
CHECK
(
emitComparison
(
ValType
:
:
I32
JSOp
:
:
Ge
MCompare
:
:
Compare_Int32
)
)
;
case
uint16_t
(
Op
:
:
I32GeU
)
:
CHECK
(
emitComparison
(
ValType
:
:
I32
JSOp
:
:
Ge
MCompare
:
:
Compare_UInt32
)
)
;
case
uint16_t
(
Op
:
:
I64Eqz
)
:
CHECK
(
emitConversion
<
MNot
>
(
ValType
:
:
I64
ValType
:
:
I32
)
)
;
case
uint16_t
(
Op
:
:
I64Eq
)
:
CHECK
(
emitComparison
(
ValType
:
:
I64
JSOp
:
:
Eq
MCompare
:
:
Compare_Int64
)
)
;
case
uint16_t
(
Op
:
:
I64Ne
)
:
CHECK
(
emitComparison
(
ValType
:
:
I64
JSOp
:
:
Ne
MCompare
:
:
Compare_Int64
)
)
;
case
uint16_t
(
Op
:
:
I64LtS
)
:
CHECK
(
emitComparison
(
ValType
:
:
I64
JSOp
:
:
Lt
MCompare
:
:
Compare_Int64
)
)
;
case
uint16_t
(
Op
:
:
I64LtU
)
:
CHECK
(
emitComparison
(
ValType
:
:
I64
JSOp
:
:
Lt
MCompare
:
:
Compare_UInt64
)
)
;
case
uint16_t
(
Op
:
:
I64GtS
)
:
CHECK
(
emitComparison
(
ValType
:
:
I64
JSOp
:
:
Gt
MCompare
:
:
Compare_Int64
)
)
;
case
uint16_t
(
Op
:
:
I64GtU
)
:
CHECK
(
emitComparison
(
ValType
:
:
I64
JSOp
:
:
Gt
MCompare
:
:
Compare_UInt64
)
)
;
case
uint16_t
(
Op
:
:
I64LeS
)
:
CHECK
(
emitComparison
(
ValType
:
:
I64
JSOp
:
:
Le
MCompare
:
:
Compare_Int64
)
)
;
case
uint16_t
(
Op
:
:
I64LeU
)
:
CHECK
(
emitComparison
(
ValType
:
:
I64
JSOp
:
:
Le
MCompare
:
:
Compare_UInt64
)
)
;
case
uint16_t
(
Op
:
:
I64GeS
)
:
CHECK
(
emitComparison
(
ValType
:
:
I64
JSOp
:
:
Ge
MCompare
:
:
Compare_Int64
)
)
;
case
uint16_t
(
Op
:
:
I64GeU
)
:
CHECK
(
emitComparison
(
ValType
:
:
I64
JSOp
:
:
Ge
MCompare
:
:
Compare_UInt64
)
)
;
case
uint16_t
(
Op
:
:
F32Eq
)
:
CHECK
(
emitComparison
(
ValType
:
:
F32
JSOp
:
:
Eq
MCompare
:
:
Compare_Float32
)
)
;
case
uint16_t
(
Op
:
:
F32Ne
)
:
CHECK
(
emitComparison
(
ValType
:
:
F32
JSOp
:
:
Ne
MCompare
:
:
Compare_Float32
)
)
;
case
uint16_t
(
Op
:
:
F32Lt
)
:
CHECK
(
emitComparison
(
ValType
:
:
F32
JSOp
:
:
Lt
MCompare
:
:
Compare_Float32
)
)
;
case
uint16_t
(
Op
:
:
F32Gt
)
:
CHECK
(
emitComparison
(
ValType
:
:
F32
JSOp
:
:
Gt
MCompare
:
:
Compare_Float32
)
)
;
case
uint16_t
(
Op
:
:
F32Le
)
:
CHECK
(
emitComparison
(
ValType
:
:
F32
JSOp
:
:
Le
MCompare
:
:
Compare_Float32
)
)
;
case
uint16_t
(
Op
:
:
F32Ge
)
:
CHECK
(
emitComparison
(
ValType
:
:
F32
JSOp
:
:
Ge
MCompare
:
:
Compare_Float32
)
)
;
case
uint16_t
(
Op
:
:
F64Eq
)
:
CHECK
(
emitComparison
(
ValType
:
:
F64
JSOp
:
:
Eq
MCompare
:
:
Compare_Double
)
)
;
case
uint16_t
(
Op
:
:
F64Ne
)
:
CHECK
(
emitComparison
(
ValType
:
:
F64
JSOp
:
:
Ne
MCompare
:
:
Compare_Double
)
)
;
case
uint16_t
(
Op
:
:
F64Lt
)
:
CHECK
(
emitComparison
(
ValType
:
:
F64
JSOp
:
:
Lt
MCompare
:
:
Compare_Double
)
)
;
case
uint16_t
(
Op
:
:
F64Gt
)
:
CHECK
(
emitComparison
(
ValType
:
:
F64
JSOp
:
:
Gt
MCompare
:
:
Compare_Double
)
)
;
case
uint16_t
(
Op
:
:
F64Le
)
:
CHECK
(
emitComparison
(
ValType
:
:
F64
JSOp
:
:
Le
MCompare
:
:
Compare_Double
)
)
;
case
uint16_t
(
Op
:
:
F64Ge
)
:
CHECK
(
emitComparison
(
ValType
:
:
F64
JSOp
:
:
Ge
MCompare
:
:
Compare_Double
)
)
;
case
uint16_t
(
Op
:
:
I32Clz
)
:
CHECK
(
emitUnaryWithType
<
MClz
>
(
ValType
:
:
I32
MIRType
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
I32Ctz
)
:
CHECK
(
emitUnaryWithType
<
MCtz
>
(
ValType
:
:
I32
MIRType
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
I32Popcnt
)
:
CHECK
(
emitUnaryWithType
<
MPopcnt
>
(
ValType
:
:
I32
MIRType
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
I32Add
)
:
CHECK
(
emitAdd
(
ValType
:
:
I32
MIRType
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
I32Sub
)
:
CHECK
(
emitSub
(
ValType
:
:
I32
MIRType
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
I32Mul
)
:
CHECK
(
emitMul
(
ValType
:
:
I32
MIRType
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
I32DivS
)
:
case
uint16_t
(
Op
:
:
I32DivU
)
:
CHECK
(
emitDiv
(
ValType
:
:
I32
MIRType
:
:
Int32
Op
(
op
.
b0
)
=
=
Op
:
:
I32DivU
)
)
;
case
uint16_t
(
Op
:
:
I32RemS
)
:
case
uint16_t
(
Op
:
:
I32RemU
)
:
CHECK
(
emitRem
(
ValType
:
:
I32
MIRType
:
:
Int32
Op
(
op
.
b0
)
=
=
Op
:
:
I32RemU
)
)
;
case
uint16_t
(
Op
:
:
I32And
)
:
CHECK
(
emitBitwiseAndOrXor
(
ValType
:
:
I32
MIRType
:
:
Int32
MWasmBinaryBitwise
:
:
SubOpcode
:
:
And
)
)
;
case
uint16_t
(
Op
:
:
I32Or
)
:
CHECK
(
emitBitwiseAndOrXor
(
ValType
:
:
I32
MIRType
:
:
Int32
MWasmBinaryBitwise
:
:
SubOpcode
:
:
Or
)
)
;
case
uint16_t
(
Op
:
:
I32Xor
)
:
CHECK
(
emitBitwiseAndOrXor
(
ValType
:
:
I32
MIRType
:
:
Int32
MWasmBinaryBitwise
:
:
SubOpcode
:
:
Xor
)
)
;
case
uint16_t
(
Op
:
:
I32Shl
)
:
CHECK
(
emitShift
<
MLsh
>
(
ValType
:
:
I32
MIRType
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
I32ShrS
)
:
CHECK
(
emitShift
<
MRsh
>
(
ValType
:
:
I32
MIRType
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
I32ShrU
)
:
CHECK
(
emitUrsh
(
ValType
:
:
I32
MIRType
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
I32Rotl
)
:
case
uint16_t
(
Op
:
:
I32Rotr
)
:
CHECK
(
emitRotate
(
ValType
:
:
I32
Op
(
op
.
b0
)
=
=
Op
:
:
I32Rotl
)
)
;
case
uint16_t
(
Op
:
:
I64Clz
)
:
CHECK
(
emitUnaryWithType
<
MClz
>
(
ValType
:
:
I64
MIRType
:
:
Int64
)
)
;
case
uint16_t
(
Op
:
:
I64Ctz
)
:
CHECK
(
emitUnaryWithType
<
MCtz
>
(
ValType
:
:
I64
MIRType
:
:
Int64
)
)
;
case
uint16_t
(
Op
:
:
I64Popcnt
)
:
CHECK
(
emitUnaryWithType
<
MPopcnt
>
(
ValType
:
:
I64
MIRType
:
:
Int64
)
)
;
case
uint16_t
(
Op
:
:
I64Add
)
:
CHECK
(
emitAdd
(
ValType
:
:
I64
MIRType
:
:
Int64
)
)
;
case
uint16_t
(
Op
:
:
I64Sub
)
:
CHECK
(
emitSub
(
ValType
:
:
I64
MIRType
:
:
Int64
)
)
;
case
uint16_t
(
Op
:
:
I64Mul
)
:
CHECK
(
emitMul
(
ValType
:
:
I64
MIRType
:
:
Int64
)
)
;
case
uint16_t
(
Op
:
:
I64DivS
)
:
case
uint16_t
(
Op
:
:
I64DivU
)
:
CHECK
(
emitDiv
(
ValType
:
:
I64
MIRType
:
:
Int64
Op
(
op
.
b0
)
=
=
Op
:
:
I64DivU
)
)
;
case
uint16_t
(
Op
:
:
I64RemS
)
:
case
uint16_t
(
Op
:
:
I64RemU
)
:
CHECK
(
emitRem
(
ValType
:
:
I64
MIRType
:
:
Int64
Op
(
op
.
b0
)
=
=
Op
:
:
I64RemU
)
)
;
case
uint16_t
(
Op
:
:
I64And
)
:
CHECK
(
emitBitwiseAndOrXor
(
ValType
:
:
I64
MIRType
:
:
Int64
MWasmBinaryBitwise
:
:
SubOpcode
:
:
And
)
)
;
case
uint16_t
(
Op
:
:
I64Or
)
:
CHECK
(
emitBitwiseAndOrXor
(
ValType
:
:
I64
MIRType
:
:
Int64
MWasmBinaryBitwise
:
:
SubOpcode
:
:
Or
)
)
;
case
uint16_t
(
Op
:
:
I64Xor
)
:
CHECK
(
emitBitwiseAndOrXor
(
ValType
:
:
I64
MIRType
:
:
Int64
MWasmBinaryBitwise
:
:
SubOpcode
:
:
Xor
)
)
;
case
uint16_t
(
Op
:
:
I64Shl
)
:
CHECK
(
emitShift
<
MLsh
>
(
ValType
:
:
I64
MIRType
:
:
Int64
)
)
;
case
uint16_t
(
Op
:
:
I64ShrS
)
:
CHECK
(
emitShift
<
MRsh
>
(
ValType
:
:
I64
MIRType
:
:
Int64
)
)
;
case
uint16_t
(
Op
:
:
I64ShrU
)
:
CHECK
(
emitUrsh
(
ValType
:
:
I64
MIRType
:
:
Int64
)
)
;
case
uint16_t
(
Op
:
:
I64Rotl
)
:
case
uint16_t
(
Op
:
:
I64Rotr
)
:
CHECK
(
emitRotate
(
ValType
:
:
I64
Op
(
op
.
b0
)
=
=
Op
:
:
I64Rotl
)
)
;
case
uint16_t
(
Op
:
:
F32Abs
)
:
CHECK
(
emitUnaryWithType
<
MAbs
>
(
ValType
:
:
F32
MIRType
:
:
Float32
)
)
;
case
uint16_t
(
Op
:
:
F32Neg
)
:
CHECK
(
emitUnaryWithType
<
MWasmNeg
>
(
ValType
:
:
F32
MIRType
:
:
Float32
)
)
;
case
uint16_t
(
Op
:
:
F32Ceil
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigCeilF
)
)
;
case
uint16_t
(
Op
:
:
F32Floor
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigFloorF
)
)
;
case
uint16_t
(
Op
:
:
F32Trunc
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigTruncF
)
)
;
case
uint16_t
(
Op
:
:
F32Nearest
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigNearbyIntF
)
)
;
case
uint16_t
(
Op
:
:
F32Sqrt
)
:
CHECK
(
emitUnaryWithType
<
MSqrt
>
(
ValType
:
:
F32
MIRType
:
:
Float32
)
)
;
case
uint16_t
(
Op
:
:
F32Add
)
:
CHECK
(
emitAdd
(
ValType
:
:
F32
MIRType
:
:
Float32
)
)
;
case
uint16_t
(
Op
:
:
F32Sub
)
:
CHECK
(
emitSub
(
ValType
:
:
F32
MIRType
:
:
Float32
)
)
;
case
uint16_t
(
Op
:
:
F32Mul
)
:
CHECK
(
emitMul
(
ValType
:
:
F32
MIRType
:
:
Float32
)
)
;
case
uint16_t
(
Op
:
:
F32Div
)
:
CHECK
(
emitDiv
(
ValType
:
:
F32
MIRType
:
:
Float32
false
)
)
;
case
uint16_t
(
Op
:
:
F32Min
)
:
case
uint16_t
(
Op
:
:
F32Max
)
:
CHECK
(
emitMinMax
(
ValType
:
:
F32
MIRType
:
:
Float32
Op
(
op
.
b0
)
=
=
Op
:
:
F32Max
)
)
;
case
uint16_t
(
Op
:
:
F32CopySign
)
:
CHECK
(
emitCopySign
(
ValType
:
:
F32
)
)
;
case
uint16_t
(
Op
:
:
F64Abs
)
:
CHECK
(
emitUnaryWithType
<
MAbs
>
(
ValType
:
:
F64
MIRType
:
:
Double
)
)
;
case
uint16_t
(
Op
:
:
F64Neg
)
:
CHECK
(
emitUnaryWithType
<
MWasmNeg
>
(
ValType
:
:
F64
MIRType
:
:
Double
)
)
;
case
uint16_t
(
Op
:
:
F64Ceil
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigCeilD
)
)
;
case
uint16_t
(
Op
:
:
F64Floor
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigFloorD
)
)
;
case
uint16_t
(
Op
:
:
F64Trunc
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigTruncD
)
)
;
case
uint16_t
(
Op
:
:
F64Nearest
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigNearbyIntD
)
)
;
case
uint16_t
(
Op
:
:
F64Sqrt
)
:
CHECK
(
emitUnaryWithType
<
MSqrt
>
(
ValType
:
:
F64
MIRType
:
:
Double
)
)
;
case
uint16_t
(
Op
:
:
F64Add
)
:
CHECK
(
emitAdd
(
ValType
:
:
F64
MIRType
:
:
Double
)
)
;
case
uint16_t
(
Op
:
:
F64Sub
)
:
CHECK
(
emitSub
(
ValType
:
:
F64
MIRType
:
:
Double
)
)
;
case
uint16_t
(
Op
:
:
F64Mul
)
:
CHECK
(
emitMul
(
ValType
:
:
F64
MIRType
:
:
Double
)
)
;
case
uint16_t
(
Op
:
:
F64Div
)
:
CHECK
(
emitDiv
(
ValType
:
:
F64
MIRType
:
:
Double
false
)
)
;
case
uint16_t
(
Op
:
:
F64Min
)
:
case
uint16_t
(
Op
:
:
F64Max
)
:
CHECK
(
emitMinMax
(
ValType
:
:
F64
MIRType
:
:
Double
Op
(
op
.
b0
)
=
=
Op
:
:
F64Max
)
)
;
case
uint16_t
(
Op
:
:
F64CopySign
)
:
CHECK
(
emitCopySign
(
ValType
:
:
F64
)
)
;
case
uint16_t
(
Op
:
:
I32WrapI64
)
:
CHECK
(
emitConversion
<
MWrapInt64ToInt32
>
(
ValType
:
:
I64
ValType
:
:
I32
)
)
;
case
uint16_t
(
Op
:
:
I32TruncF32S
)
:
case
uint16_t
(
Op
:
:
I32TruncF32U
)
:
CHECK
(
emitTruncate
(
ValType
:
:
F32
ValType
:
:
I32
Op
(
op
.
b0
)
=
=
Op
:
:
I32TruncF32U
false
)
)
;
case
uint16_t
(
Op
:
:
I32TruncF64S
)
:
case
uint16_t
(
Op
:
:
I32TruncF64U
)
:
CHECK
(
emitTruncate
(
ValType
:
:
F64
ValType
:
:
I32
Op
(
op
.
b0
)
=
=
Op
:
:
I32TruncF64U
false
)
)
;
case
uint16_t
(
Op
:
:
I64ExtendI32S
)
:
case
uint16_t
(
Op
:
:
I64ExtendI32U
)
:
CHECK
(
emitExtendI32
(
Op
(
op
.
b0
)
=
=
Op
:
:
I64ExtendI32U
)
)
;
case
uint16_t
(
Op
:
:
I64TruncF32S
)
:
case
uint16_t
(
Op
:
:
I64TruncF32U
)
:
CHECK
(
emitTruncate
(
ValType
:
:
F32
ValType
:
:
I64
Op
(
op
.
b0
)
=
=
Op
:
:
I64TruncF32U
false
)
)
;
case
uint16_t
(
Op
:
:
I64TruncF64S
)
:
case
uint16_t
(
Op
:
:
I64TruncF64U
)
:
CHECK
(
emitTruncate
(
ValType
:
:
F64
ValType
:
:
I64
Op
(
op
.
b0
)
=
=
Op
:
:
I64TruncF64U
false
)
)
;
case
uint16_t
(
Op
:
:
F32ConvertI32S
)
:
CHECK
(
emitConversion
<
MToFloat32
>
(
ValType
:
:
I32
ValType
:
:
F32
)
)
;
case
uint16_t
(
Op
:
:
F32ConvertI32U
)
:
CHECK
(
emitConversion
<
MWasmUnsignedToFloat32
>
(
ValType
:
:
I32
ValType
:
:
F32
)
)
;
case
uint16_t
(
Op
:
:
F32ConvertI64S
)
:
case
uint16_t
(
Op
:
:
F32ConvertI64U
)
:
CHECK
(
emitConvertI64ToFloatingPoint
(
ValType
:
:
F32
MIRType
:
:
Float32
Op
(
op
.
b0
)
=
=
Op
:
:
F32ConvertI64U
)
)
;
case
uint16_t
(
Op
:
:
F32DemoteF64
)
:
CHECK
(
emitConversion
<
MToFloat32
>
(
ValType
:
:
F64
ValType
:
:
F32
)
)
;
case
uint16_t
(
Op
:
:
F64ConvertI32S
)
:
CHECK
(
emitConversion
<
MToDouble
>
(
ValType
:
:
I32
ValType
:
:
F64
)
)
;
case
uint16_t
(
Op
:
:
F64ConvertI32U
)
:
CHECK
(
emitConversion
<
MWasmUnsignedToDouble
>
(
ValType
:
:
I32
ValType
:
:
F64
)
)
;
case
uint16_t
(
Op
:
:
F64ConvertI64S
)
:
case
uint16_t
(
Op
:
:
F64ConvertI64U
)
:
CHECK
(
emitConvertI64ToFloatingPoint
(
ValType
:
:
F64
MIRType
:
:
Double
Op
(
op
.
b0
)
=
=
Op
:
:
F64ConvertI64U
)
)
;
case
uint16_t
(
Op
:
:
F64PromoteF32
)
:
CHECK
(
emitConversion
<
MToDouble
>
(
ValType
:
:
F32
ValType
:
:
F64
)
)
;
case
uint16_t
(
Op
:
:
I32ReinterpretF32
)
:
CHECK
(
emitReinterpret
(
ValType
:
:
I32
ValType
:
:
F32
MIRType
:
:
Int32
)
)
;
case
uint16_t
(
Op
:
:
I64ReinterpretF64
)
:
CHECK
(
emitReinterpret
(
ValType
:
:
I64
ValType
:
:
F64
MIRType
:
:
Int64
)
)
;
case
uint16_t
(
Op
:
:
F32ReinterpretI32
)
:
CHECK
(
emitReinterpret
(
ValType
:
:
F32
ValType
:
:
I32
MIRType
:
:
Float32
)
)
;
case
uint16_t
(
Op
:
:
F64ReinterpretI64
)
:
CHECK
(
emitReinterpret
(
ValType
:
:
F64
ValType
:
:
I64
MIRType
:
:
Double
)
)
;
case
uint16_t
(
Op
:
:
RefEq
)
:
CHECK
(
emitComparison
(
RefType
:
:
eq
(
)
JSOp
:
:
Eq
MCompare
:
:
Compare_WasmAnyRef
)
)
;
case
uint16_t
(
Op
:
:
RefFunc
)
:
CHECK
(
emitRefFunc
(
)
)
;
case
uint16_t
(
Op
:
:
RefNull
)
:
CHECK
(
emitRefNull
(
)
)
;
case
uint16_t
(
Op
:
:
RefIsNull
)
:
CHECK
(
emitRefIsNull
(
)
)
;
case
uint16_t
(
Op
:
:
I32Extend8S
)
:
CHECK
(
emitSignExtend
(
1
4
)
)
;
case
uint16_t
(
Op
:
:
I32Extend16S
)
:
CHECK
(
emitSignExtend
(
2
4
)
)
;
case
uint16_t
(
Op
:
:
I64Extend8S
)
:
CHECK
(
emitSignExtend
(
1
8
)
)
;
case
uint16_t
(
Op
:
:
I64Extend16S
)
:
CHECK
(
emitSignExtend
(
2
8
)
)
;
case
uint16_t
(
Op
:
:
I64Extend32S
)
:
CHECK
(
emitSignExtend
(
4
8
)
)
;
case
uint16_t
(
Op
:
:
ReturnCall
)
:
{
CHECK
(
emitReturnCall
(
)
)
;
}
case
uint16_t
(
Op
:
:
ReturnCallIndirect
)
:
{
CHECK
(
emitReturnCallIndirect
(
)
)
;
}
case
uint16_t
(
Op
:
:
RefAsNonNull
)
:
CHECK
(
emitRefAsNonNull
(
)
)
;
case
uint16_t
(
Op
:
:
BrOnNull
)
:
{
CHECK
(
emitBrOnNull
(
)
)
;
}
case
uint16_t
(
Op
:
:
BrOnNonNull
)
:
{
CHECK
(
emitBrOnNonNull
(
)
)
;
}
case
uint16_t
(
Op
:
:
CallRef
)
:
{
CHECK
(
emitCallRef
(
)
)
;
}
case
uint16_t
(
Op
:
:
ReturnCallRef
)
:
{
CHECK
(
emitReturnCallRef
(
)
)
;
}
case
uint16_t
(
Op
:
:
GcPrefix
)
:
{
switch
(
op
.
b1
)
{
case
uint32_t
(
GcOp
:
:
StructNew
)
:
CHECK
(
emitStructNew
(
)
)
;
case
uint32_t
(
GcOp
:
:
StructNewDefault
)
:
CHECK
(
emitStructNewDefault
(
)
)
;
case
uint32_t
(
GcOp
:
:
StructSet
)
:
CHECK
(
emitStructSet
(
)
)
;
case
uint32_t
(
GcOp
:
:
StructGet
)
:
CHECK
(
emitStructGet
(
FieldWideningOp
:
:
None
)
)
;
case
uint32_t
(
GcOp
:
:
StructGetS
)
:
CHECK
(
emitStructGet
(
FieldWideningOp
:
:
Signed
)
)
;
case
uint32_t
(
GcOp
:
:
StructGetU
)
:
CHECK
(
emitStructGet
(
FieldWideningOp
:
:
Unsigned
)
)
;
case
uint32_t
(
GcOp
:
:
ArrayNew
)
:
CHECK
(
emitArrayNew
(
)
)
;
case
uint32_t
(
GcOp
:
:
ArrayNewDefault
)
:
CHECK
(
emitArrayNewDefault
(
)
)
;
case
uint32_t
(
GcOp
:
:
ArrayNewFixed
)
:
CHECK
(
emitArrayNewFixed
(
)
)
;
case
uint32_t
(
GcOp
:
:
ArrayNewData
)
:
CHECK
(
emitArrayNewData
(
)
)
;
case
uint32_t
(
GcOp
:
:
ArrayNewElem
)
:
CHECK
(
emitArrayNewElem
(
)
)
;
case
uint32_t
(
GcOp
:
:
ArrayInitData
)
:
CHECK
(
emitArrayInitData
(
)
)
;
case
uint32_t
(
GcOp
:
:
ArrayInitElem
)
:
CHECK
(
emitArrayInitElem
(
)
)
;
case
uint32_t
(
GcOp
:
:
ArraySet
)
:
CHECK
(
emitArraySet
(
)
)
;
case
uint32_t
(
GcOp
:
:
ArrayGet
)
:
CHECK
(
emitArrayGet
(
FieldWideningOp
:
:
None
)
)
;
case
uint32_t
(
GcOp
:
:
ArrayGetS
)
:
CHECK
(
emitArrayGet
(
FieldWideningOp
:
:
Signed
)
)
;
case
uint32_t
(
GcOp
:
:
ArrayGetU
)
:
CHECK
(
emitArrayGet
(
FieldWideningOp
:
:
Unsigned
)
)
;
case
uint32_t
(
GcOp
:
:
ArrayLen
)
:
CHECK
(
emitArrayLen
(
)
)
;
case
uint32_t
(
GcOp
:
:
ArrayCopy
)
:
CHECK
(
emitArrayCopy
(
)
)
;
case
uint32_t
(
GcOp
:
:
ArrayFill
)
:
CHECK
(
emitArrayFill
(
)
)
;
case
uint32_t
(
GcOp
:
:
RefI31
)
:
CHECK
(
emitRefI31
(
)
)
;
case
uint32_t
(
GcOp
:
:
I31GetS
)
:
CHECK
(
emitI31Get
(
FieldWideningOp
:
:
Signed
)
)
;
case
uint32_t
(
GcOp
:
:
I31GetU
)
:
CHECK
(
emitI31Get
(
FieldWideningOp
:
:
Unsigned
)
)
;
case
uint32_t
(
GcOp
:
:
BrOnCast
)
:
CHECK
(
emitBrOnCast
(
true
)
)
;
case
uint32_t
(
GcOp
:
:
BrOnCastFail
)
:
CHECK
(
emitBrOnCast
(
false
)
)
;
case
uint32_t
(
GcOp
:
:
RefTest
)
:
CHECK
(
emitRefTest
(
false
)
)
;
case
uint32_t
(
GcOp
:
:
RefTestNull
)
:
CHECK
(
emitRefTest
(
true
)
)
;
case
uint32_t
(
GcOp
:
:
RefCast
)
:
CHECK
(
emitRefCast
(
false
)
)
;
case
uint32_t
(
GcOp
:
:
RefCastNull
)
:
CHECK
(
emitRefCast
(
true
)
)
;
case
uint16_t
(
GcOp
:
:
AnyConvertExtern
)
:
CHECK
(
emitAnyConvertExtern
(
)
)
;
case
uint16_t
(
GcOp
:
:
ExternConvertAny
)
:
CHECK
(
emitExternConvertAny
(
)
)
;
default
:
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
break
;
}
#
ifdef
ENABLE_WASM_SIMD
case
uint16_t
(
Op
:
:
SimdPrefix
)
:
{
if
(
!
codeMeta
(
)
.
simdAvailable
(
)
)
{
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
switch
(
op
.
b1
)
{
case
uint32_t
(
SimdOp
:
:
V128Const
)
:
CHECK
(
emitConstSimd128
(
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Load
)
:
CHECK
(
emitLoad
(
ValType
:
:
V128
Scalar
:
:
Simd128
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Store
)
:
CHECK
(
emitStore
(
ValType
:
:
V128
Scalar
:
:
Simd128
)
)
;
case
uint32_t
(
SimdOp
:
:
V128And
)
:
case
uint32_t
(
SimdOp
:
:
V128Or
)
:
case
uint32_t
(
SimdOp
:
:
V128Xor
)
:
case
uint32_t
(
SimdOp
:
:
I8x16AvgrU
)
:
case
uint32_t
(
SimdOp
:
:
I16x8AvgrU
)
:
case
uint32_t
(
SimdOp
:
:
I8x16Add
)
:
case
uint32_t
(
SimdOp
:
:
I8x16AddSatS
)
:
case
uint32_t
(
SimdOp
:
:
I8x16AddSatU
)
:
case
uint32_t
(
SimdOp
:
:
I8x16MinS
)
:
case
uint32_t
(
SimdOp
:
:
I8x16MinU
)
:
case
uint32_t
(
SimdOp
:
:
I8x16MaxS
)
:
case
uint32_t
(
SimdOp
:
:
I8x16MaxU
)
:
case
uint32_t
(
SimdOp
:
:
I16x8Add
)
:
case
uint32_t
(
SimdOp
:
:
I16x8AddSatS
)
:
case
uint32_t
(
SimdOp
:
:
I16x8AddSatU
)
:
case
uint32_t
(
SimdOp
:
:
I16x8Mul
)
:
case
uint32_t
(
SimdOp
:
:
I16x8MinS
)
:
case
uint32_t
(
SimdOp
:
:
I16x8MinU
)
:
case
uint32_t
(
SimdOp
:
:
I16x8MaxS
)
:
case
uint32_t
(
SimdOp
:
:
I16x8MaxU
)
:
case
uint32_t
(
SimdOp
:
:
I32x4Add
)
:
case
uint32_t
(
SimdOp
:
:
I32x4Mul
)
:
case
uint32_t
(
SimdOp
:
:
I32x4MinS
)
:
case
uint32_t
(
SimdOp
:
:
I32x4MinU
)
:
case
uint32_t
(
SimdOp
:
:
I32x4MaxS
)
:
case
uint32_t
(
SimdOp
:
:
I32x4MaxU
)
:
case
uint32_t
(
SimdOp
:
:
I64x2Add
)
:
case
uint32_t
(
SimdOp
:
:
I64x2Mul
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Add
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Mul
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Min
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Max
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Add
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Mul
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Min
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Max
)
:
case
uint32_t
(
SimdOp
:
:
I8x16Eq
)
:
case
uint32_t
(
SimdOp
:
:
I8x16Ne
)
:
case
uint32_t
(
SimdOp
:
:
I16x8Eq
)
:
case
uint32_t
(
SimdOp
:
:
I16x8Ne
)
:
case
uint32_t
(
SimdOp
:
:
I32x4Eq
)
:
case
uint32_t
(
SimdOp
:
:
I32x4Ne
)
:
case
uint32_t
(
SimdOp
:
:
I64x2Eq
)
:
case
uint32_t
(
SimdOp
:
:
I64x2Ne
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Eq
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Ne
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Eq
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Ne
)
:
case
uint32_t
(
SimdOp
:
:
I32x4DotI16x8S
)
:
case
uint32_t
(
SimdOp
:
:
I16x8ExtmulLowI8x16S
)
:
case
uint32_t
(
SimdOp
:
:
I16x8ExtmulHighI8x16S
)
:
case
uint32_t
(
SimdOp
:
:
I16x8ExtmulLowI8x16U
)
:
case
uint32_t
(
SimdOp
:
:
I16x8ExtmulHighI8x16U
)
:
case
uint32_t
(
SimdOp
:
:
I32x4ExtmulLowI16x8S
)
:
case
uint32_t
(
SimdOp
:
:
I32x4ExtmulHighI16x8S
)
:
case
uint32_t
(
SimdOp
:
:
I32x4ExtmulLowI16x8U
)
:
case
uint32_t
(
SimdOp
:
:
I32x4ExtmulHighI16x8U
)
:
case
uint32_t
(
SimdOp
:
:
I64x2ExtmulLowI32x4S
)
:
case
uint32_t
(
SimdOp
:
:
I64x2ExtmulHighI32x4S
)
:
case
uint32_t
(
SimdOp
:
:
I64x2ExtmulLowI32x4U
)
:
case
uint32_t
(
SimdOp
:
:
I64x2ExtmulHighI32x4U
)
:
case
uint32_t
(
SimdOp
:
:
I16x8Q15MulrSatS
)
:
CHECK
(
emitBinarySimd128
(
true
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
V128AndNot
)
:
case
uint32_t
(
SimdOp
:
:
I8x16Sub
)
:
case
uint32_t
(
SimdOp
:
:
I8x16SubSatS
)
:
case
uint32_t
(
SimdOp
:
:
I8x16SubSatU
)
:
case
uint32_t
(
SimdOp
:
:
I16x8Sub
)
:
case
uint32_t
(
SimdOp
:
:
I16x8SubSatS
)
:
case
uint32_t
(
SimdOp
:
:
I16x8SubSatU
)
:
case
uint32_t
(
SimdOp
:
:
I32x4Sub
)
:
case
uint32_t
(
SimdOp
:
:
I64x2Sub
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Sub
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Div
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Sub
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Div
)
:
case
uint32_t
(
SimdOp
:
:
I8x16NarrowI16x8S
)
:
case
uint32_t
(
SimdOp
:
:
I8x16NarrowI16x8U
)
:
case
uint32_t
(
SimdOp
:
:
I16x8NarrowI32x4S
)
:
case
uint32_t
(
SimdOp
:
:
I16x8NarrowI32x4U
)
:
case
uint32_t
(
SimdOp
:
:
I8x16LtS
)
:
case
uint32_t
(
SimdOp
:
:
I8x16LtU
)
:
case
uint32_t
(
SimdOp
:
:
I8x16GtS
)
:
case
uint32_t
(
SimdOp
:
:
I8x16GtU
)
:
case
uint32_t
(
SimdOp
:
:
I8x16LeS
)
:
case
uint32_t
(
SimdOp
:
:
I8x16LeU
)
:
case
uint32_t
(
SimdOp
:
:
I8x16GeS
)
:
case
uint32_t
(
SimdOp
:
:
I8x16GeU
)
:
case
uint32_t
(
SimdOp
:
:
I16x8LtS
)
:
case
uint32_t
(
SimdOp
:
:
I16x8LtU
)
:
case
uint32_t
(
SimdOp
:
:
I16x8GtS
)
:
case
uint32_t
(
SimdOp
:
:
I16x8GtU
)
:
case
uint32_t
(
SimdOp
:
:
I16x8LeS
)
:
case
uint32_t
(
SimdOp
:
:
I16x8LeU
)
:
case
uint32_t
(
SimdOp
:
:
I16x8GeS
)
:
case
uint32_t
(
SimdOp
:
:
I16x8GeU
)
:
case
uint32_t
(
SimdOp
:
:
I32x4LtS
)
:
case
uint32_t
(
SimdOp
:
:
I32x4LtU
)
:
case
uint32_t
(
SimdOp
:
:
I32x4GtS
)
:
case
uint32_t
(
SimdOp
:
:
I32x4GtU
)
:
case
uint32_t
(
SimdOp
:
:
I32x4LeS
)
:
case
uint32_t
(
SimdOp
:
:
I32x4LeU
)
:
case
uint32_t
(
SimdOp
:
:
I32x4GeS
)
:
case
uint32_t
(
SimdOp
:
:
I32x4GeU
)
:
case
uint32_t
(
SimdOp
:
:
I64x2LtS
)
:
case
uint32_t
(
SimdOp
:
:
I64x2GtS
)
:
case
uint32_t
(
SimdOp
:
:
I64x2LeS
)
:
case
uint32_t
(
SimdOp
:
:
I64x2GeS
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Lt
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Gt
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Le
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Ge
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Lt
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Gt
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Le
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Ge
)
:
case
uint32_t
(
SimdOp
:
:
I8x16Swizzle
)
:
case
uint32_t
(
SimdOp
:
:
F32x4PMax
)
:
case
uint32_t
(
SimdOp
:
:
F32x4PMin
)
:
case
uint32_t
(
SimdOp
:
:
F64x2PMax
)
:
case
uint32_t
(
SimdOp
:
:
F64x2PMin
)
:
CHECK
(
emitBinarySimd128
(
false
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
I8x16Splat
)
:
case
uint32_t
(
SimdOp
:
:
I16x8Splat
)
:
case
uint32_t
(
SimdOp
:
:
I32x4Splat
)
:
CHECK
(
emitSplatSimd128
(
ValType
:
:
I32
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
I64x2Splat
)
:
CHECK
(
emitSplatSimd128
(
ValType
:
:
I64
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
F32x4Splat
)
:
CHECK
(
emitSplatSimd128
(
ValType
:
:
F32
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
F64x2Splat
)
:
CHECK
(
emitSplatSimd128
(
ValType
:
:
F64
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
I8x16Neg
)
:
case
uint32_t
(
SimdOp
:
:
I16x8Neg
)
:
case
uint32_t
(
SimdOp
:
:
I16x8ExtendLowI8x16S
)
:
case
uint32_t
(
SimdOp
:
:
I16x8ExtendHighI8x16S
)
:
case
uint32_t
(
SimdOp
:
:
I16x8ExtendLowI8x16U
)
:
case
uint32_t
(
SimdOp
:
:
I16x8ExtendHighI8x16U
)
:
case
uint32_t
(
SimdOp
:
:
I32x4Neg
)
:
case
uint32_t
(
SimdOp
:
:
I32x4ExtendLowI16x8S
)
:
case
uint32_t
(
SimdOp
:
:
I32x4ExtendHighI16x8S
)
:
case
uint32_t
(
SimdOp
:
:
I32x4ExtendLowI16x8U
)
:
case
uint32_t
(
SimdOp
:
:
I32x4ExtendHighI16x8U
)
:
case
uint32_t
(
SimdOp
:
:
I32x4TruncSatF32x4S
)
:
case
uint32_t
(
SimdOp
:
:
I32x4TruncSatF32x4U
)
:
case
uint32_t
(
SimdOp
:
:
I64x2Neg
)
:
case
uint32_t
(
SimdOp
:
:
I64x2ExtendLowI32x4S
)
:
case
uint32_t
(
SimdOp
:
:
I64x2ExtendHighI32x4S
)
:
case
uint32_t
(
SimdOp
:
:
I64x2ExtendLowI32x4U
)
:
case
uint32_t
(
SimdOp
:
:
I64x2ExtendHighI32x4U
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Abs
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Neg
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Sqrt
)
:
case
uint32_t
(
SimdOp
:
:
F32x4ConvertI32x4S
)
:
case
uint32_t
(
SimdOp
:
:
F32x4ConvertI32x4U
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Abs
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Neg
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Sqrt
)
:
case
uint32_t
(
SimdOp
:
:
V128Not
)
:
case
uint32_t
(
SimdOp
:
:
I8x16Popcnt
)
:
case
uint32_t
(
SimdOp
:
:
I8x16Abs
)
:
case
uint32_t
(
SimdOp
:
:
I16x8Abs
)
:
case
uint32_t
(
SimdOp
:
:
I32x4Abs
)
:
case
uint32_t
(
SimdOp
:
:
I64x2Abs
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Ceil
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Floor
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Trunc
)
:
case
uint32_t
(
SimdOp
:
:
F32x4Nearest
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Ceil
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Floor
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Trunc
)
:
case
uint32_t
(
SimdOp
:
:
F64x2Nearest
)
:
case
uint32_t
(
SimdOp
:
:
F32x4DemoteF64x2Zero
)
:
case
uint32_t
(
SimdOp
:
:
F64x2PromoteLowF32x4
)
:
case
uint32_t
(
SimdOp
:
:
F64x2ConvertLowI32x4S
)
:
case
uint32_t
(
SimdOp
:
:
F64x2ConvertLowI32x4U
)
:
case
uint32_t
(
SimdOp
:
:
I32x4TruncSatF64x2SZero
)
:
case
uint32_t
(
SimdOp
:
:
I32x4TruncSatF64x2UZero
)
:
case
uint32_t
(
SimdOp
:
:
I16x8ExtaddPairwiseI8x16S
)
:
case
uint32_t
(
SimdOp
:
:
I16x8ExtaddPairwiseI8x16U
)
:
case
uint32_t
(
SimdOp
:
:
I32x4ExtaddPairwiseI16x8S
)
:
case
uint32_t
(
SimdOp
:
:
I32x4ExtaddPairwiseI16x8U
)
:
CHECK
(
emitUnarySimd128
(
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
V128AnyTrue
)
:
case
uint32_t
(
SimdOp
:
:
I8x16AllTrue
)
:
case
uint32_t
(
SimdOp
:
:
I16x8AllTrue
)
:
case
uint32_t
(
SimdOp
:
:
I32x4AllTrue
)
:
case
uint32_t
(
SimdOp
:
:
I64x2AllTrue
)
:
case
uint32_t
(
SimdOp
:
:
I8x16Bitmask
)
:
case
uint32_t
(
SimdOp
:
:
I16x8Bitmask
)
:
case
uint32_t
(
SimdOp
:
:
I32x4Bitmask
)
:
case
uint32_t
(
SimdOp
:
:
I64x2Bitmask
)
:
CHECK
(
emitReduceSimd128
(
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
I8x16Shl
)
:
case
uint32_t
(
SimdOp
:
:
I8x16ShrS
)
:
case
uint32_t
(
SimdOp
:
:
I8x16ShrU
)
:
case
uint32_t
(
SimdOp
:
:
I16x8Shl
)
:
case
uint32_t
(
SimdOp
:
:
I16x8ShrS
)
:
case
uint32_t
(
SimdOp
:
:
I16x8ShrU
)
:
case
uint32_t
(
SimdOp
:
:
I32x4Shl
)
:
case
uint32_t
(
SimdOp
:
:
I32x4ShrS
)
:
case
uint32_t
(
SimdOp
:
:
I32x4ShrU
)
:
case
uint32_t
(
SimdOp
:
:
I64x2Shl
)
:
case
uint32_t
(
SimdOp
:
:
I64x2ShrS
)
:
case
uint32_t
(
SimdOp
:
:
I64x2ShrU
)
:
CHECK
(
emitShiftSimd128
(
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
I8x16ExtractLaneS
)
:
case
uint32_t
(
SimdOp
:
:
I8x16ExtractLaneU
)
:
CHECK
(
emitExtractLaneSimd128
(
ValType
:
:
I32
16
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
I16x8ExtractLaneS
)
:
case
uint32_t
(
SimdOp
:
:
I16x8ExtractLaneU
)
:
CHECK
(
emitExtractLaneSimd128
(
ValType
:
:
I32
8
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
I32x4ExtractLane
)
:
CHECK
(
emitExtractLaneSimd128
(
ValType
:
:
I32
4
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
I64x2ExtractLane
)
:
CHECK
(
emitExtractLaneSimd128
(
ValType
:
:
I64
2
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
F32x4ExtractLane
)
:
CHECK
(
emitExtractLaneSimd128
(
ValType
:
:
F32
4
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
F64x2ExtractLane
)
:
CHECK
(
emitExtractLaneSimd128
(
ValType
:
:
F64
2
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
I8x16ReplaceLane
)
:
CHECK
(
emitReplaceLaneSimd128
(
ValType
:
:
I32
16
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
I16x8ReplaceLane
)
:
CHECK
(
emitReplaceLaneSimd128
(
ValType
:
:
I32
8
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
I32x4ReplaceLane
)
:
CHECK
(
emitReplaceLaneSimd128
(
ValType
:
:
I32
4
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
I64x2ReplaceLane
)
:
CHECK
(
emitReplaceLaneSimd128
(
ValType
:
:
I64
2
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
F32x4ReplaceLane
)
:
CHECK
(
emitReplaceLaneSimd128
(
ValType
:
:
F32
4
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
F64x2ReplaceLane
)
:
CHECK
(
emitReplaceLaneSimd128
(
ValType
:
:
F64
2
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Bitselect
)
:
CHECK
(
emitTernarySimd128
(
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
I8x16Shuffle
)
:
CHECK
(
emitShuffleSimd128
(
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Load8Splat
)
:
CHECK
(
emitLoadSplatSimd128
(
Scalar
:
:
Uint8
SimdOp
:
:
I8x16Splat
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Load16Splat
)
:
CHECK
(
emitLoadSplatSimd128
(
Scalar
:
:
Uint16
SimdOp
:
:
I16x8Splat
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Load32Splat
)
:
CHECK
(
emitLoadSplatSimd128
(
Scalar
:
:
Float32
SimdOp
:
:
I32x4Splat
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Load64Splat
)
:
CHECK
(
emitLoadSplatSimd128
(
Scalar
:
:
Float64
SimdOp
:
:
I64x2Splat
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Load8x8S
)
:
case
uint32_t
(
SimdOp
:
:
V128Load8x8U
)
:
case
uint32_t
(
SimdOp
:
:
V128Load16x4S
)
:
case
uint32_t
(
SimdOp
:
:
V128Load16x4U
)
:
case
uint32_t
(
SimdOp
:
:
V128Load32x2S
)
:
case
uint32_t
(
SimdOp
:
:
V128Load32x2U
)
:
CHECK
(
emitLoadExtendSimd128
(
SimdOp
(
op
.
b1
)
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Load32Zero
)
:
CHECK
(
emitLoadZeroSimd128
(
Scalar
:
:
Float32
4
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Load64Zero
)
:
CHECK
(
emitLoadZeroSimd128
(
Scalar
:
:
Float64
8
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Load8Lane
)
:
CHECK
(
emitLoadLaneSimd128
(
1
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Load16Lane
)
:
CHECK
(
emitLoadLaneSimd128
(
2
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Load32Lane
)
:
CHECK
(
emitLoadLaneSimd128
(
4
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Load64Lane
)
:
CHECK
(
emitLoadLaneSimd128
(
8
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Store8Lane
)
:
CHECK
(
emitStoreLaneSimd128
(
1
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Store16Lane
)
:
CHECK
(
emitStoreLaneSimd128
(
2
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Store32Lane
)
:
CHECK
(
emitStoreLaneSimd128
(
4
)
)
;
case
uint32_t
(
SimdOp
:
:
V128Store64Lane
)
:
CHECK
(
emitStoreLaneSimd128
(
8
)
)
;
#
ifdef
ENABLE_WASM_RELAXED_SIMD
case
uint32_t
(
SimdOp
:
:
F32x4RelaxedMadd
)
:
case
uint32_t
(
SimdOp
:
:
F32x4RelaxedNmadd
)
:
case
uint32_t
(
SimdOp
:
:
F64x2RelaxedMadd
)
:
case
uint32_t
(
SimdOp
:
:
F64x2RelaxedNmadd
)
:
case
uint32_t
(
SimdOp
:
:
I8x16RelaxedLaneSelect
)
:
case
uint32_t
(
SimdOp
:
:
I16x8RelaxedLaneSelect
)
:
case
uint32_t
(
SimdOp
:
:
I32x4RelaxedLaneSelect
)
:
case
uint32_t
(
SimdOp
:
:
I64x2RelaxedLaneSelect
)
:
case
uint32_t
(
SimdOp
:
:
I32x4RelaxedDotI8x16I7x16AddS
)
:
{
if
(
!
codeMeta
(
)
.
v128RelaxedEnabled
(
)
)
{
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
CHECK
(
emitTernarySimd128
(
SimdOp
(
op
.
b1
)
)
)
;
}
case
uint32_t
(
SimdOp
:
:
F32x4RelaxedMin
)
:
case
uint32_t
(
SimdOp
:
:
F32x4RelaxedMax
)
:
case
uint32_t
(
SimdOp
:
:
F64x2RelaxedMin
)
:
case
uint32_t
(
SimdOp
:
:
F64x2RelaxedMax
)
:
{
if
(
!
codeMeta
(
)
.
v128RelaxedEnabled
(
)
)
{
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
CHECK
(
emitBinarySimd128
(
false
SimdOp
(
op
.
b1
)
)
)
;
}
case
uint32_t
(
SimdOp
:
:
I16x8RelaxedQ15MulrS
)
:
{
if
(
!
codeMeta
(
)
.
v128RelaxedEnabled
(
)
)
{
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
CHECK
(
emitBinarySimd128
(
true
SimdOp
(
op
.
b1
)
)
)
;
}
case
uint32_t
(
SimdOp
:
:
I32x4RelaxedTruncF32x4S
)
:
case
uint32_t
(
SimdOp
:
:
I32x4RelaxedTruncF32x4U
)
:
case
uint32_t
(
SimdOp
:
:
I32x4RelaxedTruncF64x2SZero
)
:
case
uint32_t
(
SimdOp
:
:
I32x4RelaxedTruncF64x2UZero
)
:
{
if
(
!
codeMeta
(
)
.
v128RelaxedEnabled
(
)
)
{
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
CHECK
(
emitUnarySimd128
(
SimdOp
(
op
.
b1
)
)
)
;
}
case
uint32_t
(
SimdOp
:
:
I8x16RelaxedSwizzle
)
:
case
uint32_t
(
SimdOp
:
:
I16x8RelaxedDotI8x16I7x16S
)
:
{
if
(
!
codeMeta
(
)
.
v128RelaxedEnabled
(
)
)
{
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
CHECK
(
emitBinarySimd128
(
false
SimdOp
(
op
.
b1
)
)
)
;
}
#
endif
default
:
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
break
;
}
#
endif
case
uint16_t
(
Op
:
:
MiscPrefix
)
:
{
switch
(
op
.
b1
)
{
case
uint32_t
(
MiscOp
:
:
I32TruncSatF32S
)
:
case
uint32_t
(
MiscOp
:
:
I32TruncSatF32U
)
:
CHECK
(
emitTruncate
(
ValType
:
:
F32
ValType
:
:
I32
MiscOp
(
op
.
b1
)
=
=
MiscOp
:
:
I32TruncSatF32U
true
)
)
;
case
uint32_t
(
MiscOp
:
:
I32TruncSatF64S
)
:
case
uint32_t
(
MiscOp
:
:
I32TruncSatF64U
)
:
CHECK
(
emitTruncate
(
ValType
:
:
F64
ValType
:
:
I32
MiscOp
(
op
.
b1
)
=
=
MiscOp
:
:
I32TruncSatF64U
true
)
)
;
case
uint32_t
(
MiscOp
:
:
I64TruncSatF32S
)
:
case
uint32_t
(
MiscOp
:
:
I64TruncSatF32U
)
:
CHECK
(
emitTruncate
(
ValType
:
:
F32
ValType
:
:
I64
MiscOp
(
op
.
b1
)
=
=
MiscOp
:
:
I64TruncSatF32U
true
)
)
;
case
uint32_t
(
MiscOp
:
:
I64TruncSatF64S
)
:
case
uint32_t
(
MiscOp
:
:
I64TruncSatF64U
)
:
CHECK
(
emitTruncate
(
ValType
:
:
F64
ValType
:
:
I64
MiscOp
(
op
.
b1
)
=
=
MiscOp
:
:
I64TruncSatF64U
true
)
)
;
case
uint32_t
(
MiscOp
:
:
MemoryCopy
)
:
CHECK
(
emitMemCopy
(
)
)
;
case
uint32_t
(
MiscOp
:
:
DataDrop
)
:
CHECK
(
emitDataOrElemDrop
(
true
)
)
;
case
uint32_t
(
MiscOp
:
:
MemoryFill
)
:
CHECK
(
emitMemFill
(
)
)
;
case
uint32_t
(
MiscOp
:
:
MemoryInit
)
:
CHECK
(
emitMemInit
(
)
)
;
case
uint32_t
(
MiscOp
:
:
TableCopy
)
:
CHECK
(
emitTableCopy
(
)
)
;
case
uint32_t
(
MiscOp
:
:
ElemDrop
)
:
CHECK
(
emitDataOrElemDrop
(
false
)
)
;
case
uint32_t
(
MiscOp
:
:
TableInit
)
:
CHECK
(
emitTableInit
(
)
)
;
case
uint32_t
(
MiscOp
:
:
TableFill
)
:
CHECK
(
emitTableFill
(
)
)
;
#
if
ENABLE_WASM_MEMORY_CONTROL
case
uint32_t
(
MiscOp
:
:
MemoryDiscard
)
:
{
if
(
!
codeMeta
(
)
.
memoryControlEnabled
(
)
)
{
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
CHECK
(
emitMemDiscard
(
)
)
;
}
#
endif
case
uint32_t
(
MiscOp
:
:
TableGrow
)
:
CHECK
(
emitTableGrow
(
)
)
;
case
uint32_t
(
MiscOp
:
:
TableSize
)
:
CHECK
(
emitTableSize
(
)
)
;
default
:
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
break
;
}
case
uint16_t
(
Op
:
:
ThreadPrefix
)
:
{
if
(
codeMeta
(
)
.
sharedMemoryEnabled
(
)
=
=
Shareable
:
:
False
)
{
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
switch
(
op
.
b1
)
{
case
uint32_t
(
ThreadOp
:
:
Notify
)
:
CHECK
(
emitNotify
(
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32Wait
)
:
CHECK
(
emitWait
(
ValType
:
:
I32
4
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64Wait
)
:
CHECK
(
emitWait
(
ValType
:
:
I64
8
)
)
;
case
uint32_t
(
ThreadOp
:
:
Fence
)
:
CHECK
(
emitFence
(
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicLoad
)
:
CHECK
(
emitAtomicLoad
(
ValType
:
:
I32
Scalar
:
:
Int32
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicLoad
)
:
CHECK
(
emitAtomicLoad
(
ValType
:
:
I64
Scalar
:
:
Int64
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicLoad8U
)
:
CHECK
(
emitAtomicLoad
(
ValType
:
:
I32
Scalar
:
:
Uint8
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicLoad16U
)
:
CHECK
(
emitAtomicLoad
(
ValType
:
:
I32
Scalar
:
:
Uint16
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicLoad8U
)
:
CHECK
(
emitAtomicLoad
(
ValType
:
:
I64
Scalar
:
:
Uint8
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicLoad16U
)
:
CHECK
(
emitAtomicLoad
(
ValType
:
:
I64
Scalar
:
:
Uint16
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicLoad32U
)
:
CHECK
(
emitAtomicLoad
(
ValType
:
:
I64
Scalar
:
:
Uint32
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicStore
)
:
CHECK
(
emitAtomicStore
(
ValType
:
:
I32
Scalar
:
:
Int32
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicStore
)
:
CHECK
(
emitAtomicStore
(
ValType
:
:
I64
Scalar
:
:
Int64
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicStore8U
)
:
CHECK
(
emitAtomicStore
(
ValType
:
:
I32
Scalar
:
:
Uint8
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicStore16U
)
:
CHECK
(
emitAtomicStore
(
ValType
:
:
I32
Scalar
:
:
Uint16
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicStore8U
)
:
CHECK
(
emitAtomicStore
(
ValType
:
:
I64
Scalar
:
:
Uint8
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicStore16U
)
:
CHECK
(
emitAtomicStore
(
ValType
:
:
I64
Scalar
:
:
Uint16
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicStore32U
)
:
CHECK
(
emitAtomicStore
(
ValType
:
:
I64
Scalar
:
:
Uint32
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicAdd
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Int32
AtomicOp
:
:
Add
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicAdd
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Int64
AtomicOp
:
:
Add
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicAdd8U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Uint8
AtomicOp
:
:
Add
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicAdd16U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Uint16
AtomicOp
:
:
Add
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicAdd8U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint8
AtomicOp
:
:
Add
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicAdd16U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint16
AtomicOp
:
:
Add
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicAdd32U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint32
AtomicOp
:
:
Add
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicSub
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Int32
AtomicOp
:
:
Sub
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicSub
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Int64
AtomicOp
:
:
Sub
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicSub8U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Uint8
AtomicOp
:
:
Sub
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicSub16U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Uint16
AtomicOp
:
:
Sub
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicSub8U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint8
AtomicOp
:
:
Sub
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicSub16U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint16
AtomicOp
:
:
Sub
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicSub32U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint32
AtomicOp
:
:
Sub
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicAnd
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Int32
AtomicOp
:
:
And
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicAnd
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Int64
AtomicOp
:
:
And
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicAnd8U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Uint8
AtomicOp
:
:
And
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicAnd16U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Uint16
AtomicOp
:
:
And
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicAnd8U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint8
AtomicOp
:
:
And
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicAnd16U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint16
AtomicOp
:
:
And
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicAnd32U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint32
AtomicOp
:
:
And
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicOr
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Int32
AtomicOp
:
:
Or
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicOr
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Int64
AtomicOp
:
:
Or
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicOr8U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Uint8
AtomicOp
:
:
Or
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicOr16U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Uint16
AtomicOp
:
:
Or
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicOr8U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint8
AtomicOp
:
:
Or
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicOr16U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint16
AtomicOp
:
:
Or
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicOr32U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint32
AtomicOp
:
:
Or
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicXor
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Int32
AtomicOp
:
:
Xor
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicXor
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Int64
AtomicOp
:
:
Xor
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicXor8U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Uint8
AtomicOp
:
:
Xor
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicXor16U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I32
Scalar
:
:
Uint16
AtomicOp
:
:
Xor
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicXor8U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint8
AtomicOp
:
:
Xor
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicXor16U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint16
AtomicOp
:
:
Xor
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicXor32U
)
:
CHECK
(
emitAtomicRMW
(
ValType
:
:
I64
Scalar
:
:
Uint32
AtomicOp
:
:
Xor
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicXchg
)
:
CHECK
(
emitAtomicXchg
(
ValType
:
:
I32
Scalar
:
:
Int32
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicXchg
)
:
CHECK
(
emitAtomicXchg
(
ValType
:
:
I64
Scalar
:
:
Int64
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicXchg8U
)
:
CHECK
(
emitAtomicXchg
(
ValType
:
:
I32
Scalar
:
:
Uint8
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicXchg16U
)
:
CHECK
(
emitAtomicXchg
(
ValType
:
:
I32
Scalar
:
:
Uint16
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicXchg8U
)
:
CHECK
(
emitAtomicXchg
(
ValType
:
:
I64
Scalar
:
:
Uint8
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicXchg16U
)
:
CHECK
(
emitAtomicXchg
(
ValType
:
:
I64
Scalar
:
:
Uint16
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicXchg32U
)
:
CHECK
(
emitAtomicXchg
(
ValType
:
:
I64
Scalar
:
:
Uint32
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicCmpXchg
)
:
CHECK
(
emitAtomicCmpXchg
(
ValType
:
:
I32
Scalar
:
:
Int32
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicCmpXchg
)
:
CHECK
(
emitAtomicCmpXchg
(
ValType
:
:
I64
Scalar
:
:
Int64
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicCmpXchg8U
)
:
CHECK
(
emitAtomicCmpXchg
(
ValType
:
:
I32
Scalar
:
:
Uint8
)
)
;
case
uint32_t
(
ThreadOp
:
:
I32AtomicCmpXchg16U
)
:
CHECK
(
emitAtomicCmpXchg
(
ValType
:
:
I32
Scalar
:
:
Uint16
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicCmpXchg8U
)
:
CHECK
(
emitAtomicCmpXchg
(
ValType
:
:
I64
Scalar
:
:
Uint8
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicCmpXchg16U
)
:
CHECK
(
emitAtomicCmpXchg
(
ValType
:
:
I64
Scalar
:
:
Uint16
)
)
;
case
uint32_t
(
ThreadOp
:
:
I64AtomicCmpXchg32U
)
:
CHECK
(
emitAtomicCmpXchg
(
ValType
:
:
I64
Scalar
:
:
Uint32
)
)
;
default
:
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
break
;
}
case
uint16_t
(
Op
:
:
MozPrefix
)
:
{
if
(
op
.
b1
=
=
uint32_t
(
MozOp
:
:
CallBuiltinModuleFunc
)
)
{
if
(
!
codeMeta
(
)
.
isBuiltinModule
(
)
)
{
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
CHECK
(
emitCallBuiltinModuleFunc
(
)
)
;
}
#
ifdef
ENABLE_WASM_JSPI
if
(
op
.
b1
=
=
uint32_t
(
MozOp
:
:
StackSwitch
)
)
{
if
(
!
codeMeta
(
)
.
isBuiltinModule
(
)
|
|
!
codeMeta
(
)
.
jsPromiseIntegrationEnabled
(
)
)
{
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
CHECK
(
emitStackSwitch
(
)
)
;
}
#
endif
if
(
!
codeMeta
(
)
.
isAsmJS
(
)
)
{
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
switch
(
op
.
b1
)
{
case
uint32_t
(
MozOp
:
:
TeeGlobal
)
:
CHECK
(
emitTeeGlobal
(
)
)
;
case
uint32_t
(
MozOp
:
:
I32Min
)
:
case
uint32_t
(
MozOp
:
:
I32Max
)
:
CHECK
(
emitMinMax
(
ValType
:
:
I32
MIRType
:
:
Int32
MozOp
(
op
.
b1
)
=
=
MozOp
:
:
I32Max
)
)
;
case
uint32_t
(
MozOp
:
:
I32Neg
)
:
CHECK
(
emitUnaryWithType
<
MWasmNeg
>
(
ValType
:
:
I32
MIRType
:
:
Int32
)
)
;
case
uint32_t
(
MozOp
:
:
I32BitNot
)
:
CHECK
(
emitBitNot
(
ValType
:
:
I32
MIRType
:
:
Int32
)
)
;
case
uint32_t
(
MozOp
:
:
I32Abs
)
:
CHECK
(
emitUnaryWithType
<
MAbs
>
(
ValType
:
:
I32
MIRType
:
:
Int32
)
)
;
case
uint32_t
(
MozOp
:
:
F32TeeStoreF64
)
:
CHECK
(
emitTeeStoreWithCoercion
(
ValType
:
:
F32
Scalar
:
:
Float64
)
)
;
case
uint32_t
(
MozOp
:
:
F64TeeStoreF32
)
:
CHECK
(
emitTeeStoreWithCoercion
(
ValType
:
:
F64
Scalar
:
:
Float32
)
)
;
case
uint32_t
(
MozOp
:
:
I32TeeStore8
)
:
CHECK
(
emitTeeStore
(
ValType
:
:
I32
Scalar
:
:
Int8
)
)
;
case
uint32_t
(
MozOp
:
:
I32TeeStore16
)
:
CHECK
(
emitTeeStore
(
ValType
:
:
I32
Scalar
:
:
Int16
)
)
;
case
uint32_t
(
MozOp
:
:
I64TeeStore8
)
:
CHECK
(
emitTeeStore
(
ValType
:
:
I64
Scalar
:
:
Int8
)
)
;
case
uint32_t
(
MozOp
:
:
I64TeeStore16
)
:
CHECK
(
emitTeeStore
(
ValType
:
:
I64
Scalar
:
:
Int16
)
)
;
case
uint32_t
(
MozOp
:
:
I64TeeStore32
)
:
CHECK
(
emitTeeStore
(
ValType
:
:
I64
Scalar
:
:
Int32
)
)
;
case
uint32_t
(
MozOp
:
:
I32TeeStore
)
:
CHECK
(
emitTeeStore
(
ValType
:
:
I32
Scalar
:
:
Int32
)
)
;
case
uint32_t
(
MozOp
:
:
I64TeeStore
)
:
CHECK
(
emitTeeStore
(
ValType
:
:
I64
Scalar
:
:
Int64
)
)
;
case
uint32_t
(
MozOp
:
:
F32TeeStore
)
:
CHECK
(
emitTeeStore
(
ValType
:
:
F32
Scalar
:
:
Float32
)
)
;
case
uint32_t
(
MozOp
:
:
F64TeeStore
)
:
CHECK
(
emitTeeStore
(
ValType
:
:
F64
Scalar
:
:
Float64
)
)
;
case
uint32_t
(
MozOp
:
:
F64Mod
)
:
CHECK
(
emitRem
(
ValType
:
:
F64
MIRType
:
:
Double
false
)
)
;
case
uint32_t
(
MozOp
:
:
F64SinNative
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigSinNativeD
)
)
;
case
uint32_t
(
MozOp
:
:
F64SinFdlibm
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigSinFdlibmD
)
)
;
case
uint32_t
(
MozOp
:
:
F64CosNative
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigCosNativeD
)
)
;
case
uint32_t
(
MozOp
:
:
F64CosFdlibm
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigCosFdlibmD
)
)
;
case
uint32_t
(
MozOp
:
:
F64TanNative
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigTanNativeD
)
)
;
case
uint32_t
(
MozOp
:
:
F64TanFdlibm
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigTanFdlibmD
)
)
;
case
uint32_t
(
MozOp
:
:
F64Asin
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigASinD
)
)
;
case
uint32_t
(
MozOp
:
:
F64Acos
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigACosD
)
)
;
case
uint32_t
(
MozOp
:
:
F64Atan
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigATanD
)
)
;
case
uint32_t
(
MozOp
:
:
F64Exp
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigExpD
)
)
;
case
uint32_t
(
MozOp
:
:
F64Log
)
:
CHECK
(
emitUnaryMathBuiltinCall
(
SASigLogD
)
)
;
case
uint32_t
(
MozOp
:
:
F64Pow
)
:
CHECK
(
emitBinaryMathBuiltinCall
(
SASigPowD
)
)
;
case
uint32_t
(
MozOp
:
:
F64Atan2
)
:
CHECK
(
emitBinaryMathBuiltinCall
(
SASigATan2D
)
)
;
case
uint32_t
(
MozOp
:
:
OldCallDirect
)
:
CHECK
(
emitCall
(
true
)
)
;
case
uint32_t
(
MozOp
:
:
OldCallIndirect
)
:
CHECK
(
emitCallIndirect
(
true
)
)
;
default
:
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
break
;
}
default
:
return
iter
(
)
.
unrecognizedOpcode
(
&
op
)
;
}
}
MOZ_CRASH
(
"
unreachable
"
)
;
#
undef
CHECK
}
}
bool
RootCompiler
:
:
generate
(
)
{
if
(
codeMeta_
.
numMemories
(
)
>
0
)
{
if
(
codeMeta_
.
memories
[
0
]
.
addressType
(
)
=
=
AddressType
:
:
I32
)
{
mirGen_
.
initMinWasmMemory0Length
(
codeMeta_
.
memories
[
0
]
.
initialLength32
(
)
)
;
}
else
{
mirGen_
.
initMinWasmMemory0Length
(
codeMeta_
.
memories
[
0
]
.
initialLength64
(
)
)
;
}
}
if
(
codeMeta_
.
branchHintingEnabled
(
)
&
&
!
codeMeta_
.
branchHints
.
isEmpty
(
)
)
{
compileInfo_
.
setBranchHinting
(
true
)
;
}
if
(
codeTailMeta_
)
{
auto
guard
=
codeTailMeta_
-
>
inliningBudget
.
lock
(
)
;
if
(
guard
.
get
(
)
>
0
)
{
localInliningBudget_
=
int64_t
(
codeMeta_
.
codeSectionSize
(
)
)
*
PerFunctionMaxInliningRatio
;
localInliningBudget_
=
std
:
:
min
<
int64_t
>
(
localInliningBudget_
guard
.
get
(
)
)
;
}
else
{
localInliningBudget_
=
0
;
}
MOZ_ASSERT
(
localInliningBudget_
>
=
0
)
;
}
else
{
localInliningBudget_
=
0
;
}
FunctionCompiler
funcCompiler
(
*
this
decoder_
func_
locals_
compileInfo_
)
;
if
(
!
funcCompiler
.
initRoot
(
)
|
|
!
funcCompiler
.
startBlock
(
)
|
|
!
funcCompiler
.
emitBodyExprs
(
)
)
{
return
false
;
}
funcCompiler
.
finish
(
)
;
observedFeatures_
=
funcCompiler
.
featureUsage
(
)
;
MOZ_ASSERT
(
loopDepth_
=
=
0
)
;
funcStats_
.
numFuncs
+
=
1
;
funcStats_
.
bytecodeSize
+
=
func_
.
bytecodeSize
(
)
;
funcStats_
.
inlinedDirectCallCount
+
=
inliningStats_
.
inlinedDirectFunctions
;
funcStats_
.
inlinedCallRefCount
+
=
inliningStats_
.
inlinedCallRefFunctions
;
funcStats_
.
inlinedDirectCallBytecodeSize
+
=
inliningStats_
.
inlinedDirectBytecodeSize
;
funcStats_
.
inlinedCallRefBytecodeSize
+
=
inliningStats_
.
inlinedCallRefBytecodeSize
;
funcStats_
.
numLargeFunctionBackoffs
+
=
inliningStats_
.
largeFunctionBackoff
?
1
:
0
;
if
(
codeTailMeta_
)
{
auto
guard
=
codeTailMeta_
-
>
inliningBudget
.
lock
(
)
;
if
(
guard
.
get
(
)
>
=
0
)
{
guard
.
get
(
)
-
=
int64_t
(
inliningStats_
.
inlinedDirectBytecodeSize
)
;
guard
.
get
(
)
-
=
int64_t
(
inliningStats_
.
inlinedCallRefBytecodeSize
)
;
if
(
guard
.
get
(
)
<
0
)
{
JS_LOG
(
wasmPerf
Info
"
CM
=
.
.
%
06lx
RC
:
:
generate
"
"
Inlining
budget
for
entire
module
exceeded
"
0xFFFFFF
&
(
unsigned
long
)
uintptr_t
(
&
codeMeta_
)
)
;
}
}
if
(
localInliningBudget_
<
0
)
{
funcStats_
.
numInliningBudgetOverruns
+
=
1
;
}
}
return
true
;
}
CompileInfo
*
RootCompiler
:
:
startInlineCall
(
uint32_t
callerFuncIndex
BytecodeOffset
callerOffset
uint32_t
calleeFuncIndex
uint32_t
numLocals
size_t
inlineeBytecodeSize
InliningHeuristics
:
:
CallKind
callKind
)
{
if
(
callKind
=
=
InliningHeuristics
:
:
CallKind
:
:
Direct
)
{
inliningStats_
.
inlinedDirectBytecodeSize
+
=
inlineeBytecodeSize
;
inliningStats_
.
inlinedDirectFunctions
+
=
1
;
}
else
{
MOZ_ASSERT
(
callKind
=
=
InliningHeuristics
:
:
CallKind
:
:
CallRef
)
;
inliningStats_
.
inlinedCallRefBytecodeSize
+
=
inlineeBytecodeSize
;
inliningStats_
.
inlinedCallRefFunctions
+
=
1
;
}
if
(
localInliningBudget_
>
=
0
)
{
localInliningBudget_
-
=
int64_t
(
inlineeBytecodeSize
)
;
#
ifdef
JS_JITSPEW
if
(
localInliningBudget_
<
=
0
)
{
JS_LOG
(
wasmPerf
Info
"
CM
=
.
.
%
06lx
RC
:
:
startInlineCall
"
"
Inlining
budget
for
fI
=
%
u
exceeded
"
0xFFFFFF
&
(
unsigned
long
)
uintptr_t
(
&
codeMeta_
)
callerFuncIndex
)
;
}
#
endif
}
if
(
!
inlinedCallerOffsets_
.
append
(
callerOffset
)
)
{
return
nullptr
;
}
InlinedCallerOffsets
inlinedCallerOffsets
;
if
(
!
inlinedCallerOffsets
.
appendAll
(
inlinedCallerOffsets_
)
)
{
return
nullptr
;
}
if
(
!
inliningContext_
.
append
(
std
:
:
move
(
inlinedCallerOffsets
)
&
inlinedCallerOffsetsIndex_
)
)
{
return
nullptr
;
}
UniqueCompileInfo
compileInfo
=
MakeUnique
<
CompileInfo
>
(
numLocals
)
;
if
(
!
compileInfo
|
|
!
compileInfos_
.
append
(
std
:
:
move
(
compileInfo
)
)
)
{
return
nullptr
;
}
return
compileInfos_
[
compileInfos_
.
length
(
)
-
1
]
.
get
(
)
;
}
void
RootCompiler
:
:
finishInlineCall
(
)
{
inlinedCallerOffsets_
.
popBack
(
)
;
}
bool
wasm
:
:
IonCompileFunctions
(
const
CodeMetadata
&
codeMeta
const
CodeTailMetadata
*
codeTailMeta
const
CompilerEnvironment
&
compilerEnv
LifoAlloc
&
lifo
const
FuncCompileInputVector
&
inputs
CompiledCode
*
code
UniqueChars
*
error
)
{
MOZ_ASSERT
(
compilerEnv
.
tier
(
)
=
=
Tier
:
:
Optimized
)
;
MOZ_ASSERT
(
compilerEnv
.
debug
(
)
=
=
DebugEnabled
:
:
False
)
;
MOZ_ASSERT_IF
(
compilerEnv
.
mode
(
)
=
=
CompileMode
:
:
LazyTiering
!
!
codeTailMeta
)
;
JS
:
:
AutoSuppressGCAnalysis
nogc
;
TempAllocator
alloc
(
&
lifo
)
;
JitContext
jitContext
;
MOZ_ASSERT
(
IsCompilingWasm
(
)
)
;
WasmMacroAssembler
masm
(
alloc
)
;
#
if
defined
(
JS_CODEGEN_ARM64
)
masm
.
SetStackPointer64
(
PseudoStackPointer64
)
;
#
endif
MOZ_ASSERT
(
code
-
>
empty
(
)
)
;
if
(
!
code
-
>
swap
(
masm
)
)
{
return
false
;
}
RegisterOffsets
trapExitLayout
;
size_t
trapExitLayoutNumWords
;
GenerateTrapExitRegisterOffsets
(
&
trapExitLayout
&
trapExitLayoutNumWords
)
;
for
(
const
FuncCompileInput
&
func
:
inputs
)
{
JitSpewCont
(
JitSpew_Codegen
"
\
n
"
)
;
JitSpew
(
JitSpew_Codegen
"
#
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
"
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
"
)
;
JitSpew
(
JitSpew_Codegen
"
#
=
=
"
)
;
JitSpew
(
JitSpew_Codegen
"
#
wasm
:
:
IonCompileFunctions
:
starting
on
function
index
%
d
"
(
int
)
func
.
index
)
;
Decoder
d
(
func
.
begin
func
.
end
func
.
lineOrBytecode
error
)
;
ValTypeVector
locals
;
if
(
!
DecodeLocalEntriesWithParams
(
d
codeMeta
func
.
index
&
locals
)
)
{
return
false
;
}
RootCompiler
rootCompiler
(
compilerEnv
codeMeta
codeTailMeta
alloc
locals
func
d
masm
.
tryNotes
(
)
masm
.
inliningContext
(
)
)
;
if
(
!
rootCompiler
.
generate
(
)
)
{
return
false
;
}
FeatureUsage
observedFeatures
=
rootCompiler
.
observedFeatures
(
)
;
code
-
>
featureUsage
|
=
observedFeatures
;
{
jit
:
:
SpewBeginWasmFunction
(
&
rootCompiler
.
mirGen
(
)
func
.
index
)
;
jit
:
:
AutoSpewEndFunction
spewEndFunction
(
&
rootCompiler
.
mirGen
(
)
)
;
if
(
!
OptimizeMIR
(
&
rootCompiler
.
mirGen
(
)
)
)
{
return
false
;
}
LIRGraph
*
lir
=
GenerateLIR
(
&
rootCompiler
.
mirGen
(
)
)
;
if
(
!
lir
)
{
return
false
;
}
size_t
unwindInfoBefore
=
masm
.
codeRangeUnwindInfos
(
)
.
length
(
)
;
CodeGenerator
codegen
(
&
rootCompiler
.
mirGen
(
)
lir
&
masm
&
codeMeta
)
;
TrapSiteDesc
prologueTrapSiteDesc
(
wasm
:
:
BytecodeOffset
(
func
.
lineOrBytecode
)
)
;
FuncOffsets
offsets
;
ArgTypeVector
args
(
codeMeta
.
getFuncType
(
func
.
index
)
)
;
IonPerfSpewer
spewer
;
if
(
!
codegen
.
generateWasm
(
CallIndirectId
:
:
forFunc
(
codeMeta
func
.
index
)
prologueTrapSiteDesc
args
trapExitLayout
trapExitLayoutNumWords
&
offsets
&
code
-
>
stackMaps
&
d
&
spewer
)
)
{
return
false
;
}
bool
hasUnwindInfo
=
unwindInfoBefore
!
=
masm
.
codeRangeUnwindInfos
(
)
.
length
(
)
;
if
(
!
code
-
>
codeRanges
.
emplaceBack
(
func
.
index
offsets
hasUnwindInfo
)
)
{
return
false
;
}
if
(
PerfEnabled
(
)
)
{
if
(
!
code
-
>
funcIonSpewers
.
emplaceBack
(
func
.
index
std
:
:
move
(
spewer
)
)
)
{
return
false
;
}
}
}
code
-
>
compileStats
.
merge
(
rootCompiler
.
funcStats
(
)
)
;
if
(
!
code
-
>
funcs
.
emplaceBack
(
func
.
index
observedFeatures
)
)
{
return
false
;
}
JitSpew
(
JitSpew_Codegen
"
#
wasm
:
:
IonCompileFunctions
:
completed
function
index
%
d
"
(
int
)
func
.
index
)
;
JitSpew
(
JitSpew_Codegen
"
#
=
=
"
)
;
JitSpew
(
JitSpew_Codegen
"
#
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
"
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
"
)
;
JitSpewCont
(
JitSpew_Codegen
"
\
n
"
)
;
}
masm
.
finish
(
)
;
if
(
masm
.
oom
(
)
)
{
return
false
;
}
return
code
-
>
swap
(
masm
)
;
}
bool
wasm
:
:
IonDumpFunction
(
const
CompilerEnvironment
&
compilerEnv
const
CodeMetadata
&
codeMeta
const
FuncCompileInput
&
func
IonDumpContents
contents
GenericPrinter
&
out
UniqueChars
*
error
)
{
LifoAlloc
lifo
(
TempAllocator
:
:
PreferredLifoChunkSize
js
:
:
BackgroundMallocArena
)
;
TempAllocator
alloc
(
&
lifo
)
;
JitContext
jitContext
;
Decoder
d
(
func
.
begin
func
.
end
func
.
lineOrBytecode
error
)
;
ValTypeVector
locals
;
if
(
!
DecodeLocalEntriesWithParams
(
d
codeMeta
func
.
index
&
locals
)
)
{
return
false
;
}
TryNoteVector
tryNotes
;
InliningContext
inliningContext
;
RootCompiler
rootCompiler
(
compilerEnv
codeMeta
nullptr
alloc
locals
func
d
tryNotes
inliningContext
)
;
if
(
!
rootCompiler
.
generate
(
)
)
{
return
false
;
}
if
(
contents
=
=
IonDumpContents
:
:
UnoptimizedMIR
)
{
rootCompiler
.
mirGraph
(
)
.
dump
(
out
)
;
return
true
;
}
if
(
!
OptimizeMIR
(
&
rootCompiler
.
mirGen
(
)
)
)
{
return
false
;
}
if
(
contents
=
=
IonDumpContents
:
:
OptimizedMIR
)
{
rootCompiler
.
mirGraph
(
)
.
dump
(
out
)
;
return
true
;
}
#
ifdef
JS_JITSPEW
LIRGraph
*
lir
=
GenerateLIR
(
&
rootCompiler
.
mirGen
(
)
)
;
if
(
!
lir
)
{
return
false
;
}
MOZ_ASSERT
(
contents
=
=
IonDumpContents
:
:
LIR
)
;
lir
-
>
dump
(
out
)
;
#
else
out
.
printf
(
"
cannot
dump
LIR
without
-
-
enable
-
jitspew
"
)
;
#
endif
return
true
;
}
bool
js
:
:
wasm
:
:
IonPlatformSupport
(
)
{
#
if
defined
(
JS_CODEGEN_X64
)
|
|
defined
(
JS_CODEGEN_X86
)
|
|
\
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
|
|
\
defined
(
JS_CODEGEN_ARM64
)
|
|
defined
(
JS_CODEGEN_LOONG64
)
|
|
\
defined
(
JS_CODEGEN_RISCV64
)
return
true
;
#
else
return
false
;
#
endif
}
