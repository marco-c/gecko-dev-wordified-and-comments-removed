#
include
"
wasm
/
WasmTable
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
wasm
/
WasmInstance
.
h
"
#
include
"
wasm
/
WasmJS
.
h
"
using
namespace
js
;
using
namespace
js
:
:
wasm
;
using
mozilla
:
:
CheckedInt
;
Table
:
:
Table
(
JSContext
*
cx
const
TableDesc
&
desc
HandleWasmTableObject
maybeObject
UniqueByteArray
array
)
:
maybeObject_
(
maybeObject
)
observers_
(
cx
-
>
zone
(
)
)
array_
(
std
:
:
move
(
array
)
)
kind_
(
desc
.
kind
)
length_
(
desc
.
limits
.
initial
)
maximum_
(
desc
.
limits
.
maximum
)
external_
(
desc
.
external
)
{
}
SharedTable
Table
:
:
create
(
JSContext
*
cx
const
TableDesc
&
desc
HandleWasmTableObject
maybeObject
)
{
UniqueByteArray
array
;
if
(
desc
.
external
)
array
.
reset
(
(
uint8_t
*
)
cx
-
>
pod_calloc
<
ExternalTableElem
>
(
desc
.
limits
.
initial
)
)
;
else
array
.
reset
(
(
uint8_t
*
)
cx
-
>
pod_calloc
<
void
*
>
(
desc
.
limits
.
initial
)
)
;
if
(
!
array
)
return
nullptr
;
return
SharedTable
(
cx
-
>
new_
<
Table
>
(
cx
desc
maybeObject
std
:
:
move
(
array
)
)
)
;
}
void
Table
:
:
tracePrivate
(
JSTracer
*
trc
)
{
if
(
maybeObject_
)
{
MOZ_ASSERT
(
!
gc
:
:
IsAboutToBeFinalized
(
&
maybeObject_
)
)
;
TraceEdge
(
trc
&
maybeObject_
"
wasm
table
object
"
)
;
}
if
(
external_
)
{
ExternalTableElem
*
array
=
externalArray
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length_
;
i
+
+
)
{
if
(
array
[
i
]
.
tls
)
array
[
i
]
.
tls
-
>
instance
-
>
trace
(
trc
)
;
else
MOZ_ASSERT
(
!
array
[
i
]
.
code
)
;
}
}
}
void
Table
:
:
trace
(
JSTracer
*
trc
)
{
if
(
maybeObject_
)
TraceEdge
(
trc
&
maybeObject_
"
wasm
table
object
"
)
;
else
tracePrivate
(
trc
)
;
}
void
*
*
Table
:
:
internalArray
(
)
const
{
MOZ_ASSERT
(
!
external_
)
;
return
(
void
*
*
)
array_
.
get
(
)
;
}
ExternalTableElem
*
Table
:
:
externalArray
(
)
const
{
MOZ_ASSERT
(
external_
)
;
return
(
ExternalTableElem
*
)
array_
.
get
(
)
;
}
void
Table
:
:
set
(
uint32_t
index
void
*
code
Instance
&
instance
)
{
if
(
external_
)
{
ExternalTableElem
&
elem
=
externalArray
(
)
[
index
]
;
if
(
elem
.
tls
)
JSObject
:
:
writeBarrierPre
(
elem
.
tls
-
>
instance
-
>
objectUnbarriered
(
)
)
;
elem
.
code
=
code
;
elem
.
tls
=
instance
.
tlsData
(
)
;
MOZ_ASSERT
(
elem
.
tls
-
>
instance
-
>
objectUnbarriered
(
)
-
>
isTenured
(
)
"
no
writeBarrierPost
"
)
;
}
else
{
internalArray
(
)
[
index
]
=
code
;
}
}
void
Table
:
:
setNull
(
uint32_t
index
)
{
ExternalTableElem
&
elem
=
externalArray
(
)
[
index
]
;
if
(
elem
.
tls
)
JSObject
:
:
writeBarrierPre
(
elem
.
tls
-
>
instance
-
>
objectUnbarriered
(
)
)
;
elem
.
code
=
nullptr
;
elem
.
tls
=
nullptr
;
}
uint32_t
Table
:
:
grow
(
uint32_t
delta
JSContext
*
cx
)
{
if
(
!
delta
)
return
length_
;
uint32_t
oldLength
=
length_
;
CheckedInt
<
uint32_t
>
newLength
=
oldLength
;
newLength
+
=
delta
;
if
(
!
newLength
.
isValid
(
)
)
return
-
1
;
if
(
maximum_
&
&
newLength
.
value
(
)
>
maximum_
.
value
(
)
)
return
-
1
;
MOZ_ASSERT
(
movingGrowable
(
)
)
;
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
ExternalTableElem
*
newArray
=
rt
-
>
pod_realloc
(
externalArray
(
)
length_
newLength
.
value
(
)
)
;
if
(
!
newArray
)
return
-
1
;
Unused
<
<
array_
.
release
(
)
;
array_
.
reset
(
(
uint8_t
*
)
newArray
)
;
PodZero
(
newArray
+
length_
delta
)
;
length_
=
newLength
.
value
(
)
;
if
(
observers_
.
initialized
(
)
)
{
for
(
InstanceSet
:
:
Range
r
=
observers_
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
r
.
front
(
)
-
>
instance
(
)
.
onMovingGrowTable
(
)
;
}
return
oldLength
;
}
bool
Table
:
:
movingGrowable
(
)
const
{
return
!
maximum_
|
|
length_
<
maximum_
.
value
(
)
;
}
bool
Table
:
:
addMovingGrowObserver
(
JSContext
*
cx
WasmInstanceObject
*
instance
)
{
MOZ_ASSERT
(
movingGrowable
(
)
)
;
if
(
!
observers_
.
initialized
(
)
&
&
!
observers_
.
init
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
if
(
!
observers_
.
putNew
(
instance
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
size_t
Table
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
array_
.
get
(
)
)
;
}
