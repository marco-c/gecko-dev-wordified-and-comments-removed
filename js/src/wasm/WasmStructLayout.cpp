#
include
"
wasm
/
WasmStructLayout
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
jstypes
.
h
"
namespace
js
:
:
wasm
{
#
ifdef
DEBUG
static
bool
Is8Aligned
(
uint32_t
n
)
{
return
(
n
&
7
)
=
=
0
;
}
static
bool
IsWordAligned
(
uintptr_t
x
)
{
return
(
x
%
sizeof
(
void
*
)
)
=
=
0
;
}
#
endif
static
uint32_t
IndexOfLeastSignificantZeroBit
(
uint8_t
n
)
{
for
(
uint32_t
i
=
0
;
i
<
8
;
i
+
+
)
{
if
(
(
(
n
>
>
i
)
&
1
)
=
=
0
)
{
return
i
;
}
}
MOZ_CRASH
(
)
;
}
static
uint32_t
IndexOfLeastSignificantZero2Bits
(
uint8_t
n
)
{
for
(
uint32_t
i
=
0
;
i
<
8
;
i
+
=
2
)
{
if
(
(
(
n
>
>
i
)
&
3
)
=
=
0
)
{
return
i
;
}
}
MOZ_CRASH
(
)
;
}
static
uint32_t
IndexOfLeastSignificantZero4Bits
(
uint8_t
n
)
{
for
(
uint32_t
i
=
0
;
i
<
8
;
i
+
=
4
)
{
if
(
(
(
n
>
>
i
)
&
0xF
)
=
=
0
)
{
return
i
;
}
}
MOZ_CRASH
(
)
;
}
static
uint32_t
IndexOfMostSignificantOneBit
(
uint8_t
n
)
{
for
(
int32_t
i
=
7
;
i
>
=
0
;
i
-
-
)
{
if
(
(
(
n
>
>
i
)
&
1
)
=
=
1
)
{
return
uint32_t
(
i
)
;
}
}
MOZ_CRASH
(
)
;
}
#
ifdef
DEBUG
static
uint32_t
OffsetToChunkNumber
(
uint32_t
offset
)
{
return
offset
/
8
;
}
#
endif
uint32_t
BitVector
:
:
hashNonZero
(
)
const
{
mozilla
:
:
HashNumber
hash
(
42
)
;
for
(
uint8_t
b
:
chunks_
)
{
if
(
b
!
=
0
)
{
hash
=
mozilla
:
:
AddToHash
(
hash
b
)
;
}
}
return
uint32_t
(
hash
)
;
}
uint32_t
BitVector
:
:
totalOffset
(
)
const
{
if
(
chunks_
.
empty
(
)
)
{
return
0
;
}
size_t
i
;
for
(
i
=
chunks_
.
length
(
)
;
i
>
=
1
;
i
-
-
)
{
if
(
chunks_
[
i
-
1
]
!
=
0
)
{
break
;
}
}
if
(
i
=
=
0
)
{
return
0
;
}
i
-
-
;
MOZ_ASSERT
(
i
<
chunks_
.
length
(
)
)
;
return
8
*
uint32_t
(
i
)
+
IndexOfMostSignificantOneBit
(
chunks_
[
i
]
)
+
1
;
}
BitVector
:
:
Result
BitVector
:
:
addMoreChunks
(
)
{
for
(
uint32_t
i
=
0
;
i
<
LookbackLimit
/
2
;
i
+
+
)
{
if
(
!
chunks_
.
append
(
0
)
)
{
return
Result
:
:
OOM
;
}
}
return
Result
:
:
OK
;
}
BitVector
:
:
Result
BitVector
:
:
init
(
uint32_t
chunksReserved
uint32_t
chunksTotal
)
{
MOZ_ASSERT_IF
(
chunksReserved
>
0
chunksReserved
<
chunksTotal
)
;
if
(
!
chunks_
.
resize
(
chunksTotal
)
)
{
return
Result
:
:
OOM
;
}
for
(
uint32_t
i
=
0
;
i
<
chunksReserved
;
i
+
+
)
{
chunks_
[
i
]
=
0xFF
;
}
for
(
uint32_t
i
=
chunksReserved
;
i
<
chunksTotal
;
i
+
+
)
{
chunks_
[
i
]
=
0
;
}
return
Result
:
:
OK
;
}
BitVector
:
:
Result
BitVector
:
:
allocate
(
uint32_t
size
uint32_t
firstChunk
uint32_t
lastChunkPlus1
uint32_t
*
offset
)
{
MOZ_ASSERT
(
firstChunk
<
lastChunkPlus1
)
;
MOZ_ASSERT
(
lastChunkPlus1
<
=
chunks_
.
length
(
)
)
;
if
(
lastChunkPlus1
-
firstChunk
>
LookbackLimit
)
{
firstChunk
=
lastChunkPlus1
-
LookbackLimit
;
}
switch
(
size
)
{
case
8
:
{
for
(
uint32_t
i
=
firstChunk
;
i
<
lastChunkPlus1
;
i
+
+
)
{
if
(
chunks_
[
i
]
=
=
0
)
{
*
offset
=
i
*
8
;
chunks_
[
i
]
=
0xFF
;
return
Result
:
:
OK
;
}
}
break
;
}
case
16
:
{
for
(
uint32_t
i
=
firstChunk
+
1
;
i
<
lastChunkPlus1
;
i
+
+
)
{
if
(
chunks_
[
i
-
1
]
=
=
0
&
&
chunks_
[
i
]
=
=
0
)
{
*
offset
=
(
i
-
1
)
*
8
;
chunks_
[
i
-
1
]
=
0xFF
;
chunks_
[
i
]
=
0xFF
;
return
Result
:
:
OK
;
}
}
break
;
}
case
1
:
{
for
(
uint32_t
i
=
firstChunk
;
i
<
lastChunkPlus1
;
i
+
+
)
{
if
(
chunks_
[
i
]
!
=
0xFF
)
{
uint32_t
bitShift
=
IndexOfLeastSignificantZeroBit
(
chunks_
[
i
]
)
;
*
offset
=
i
*
8
+
bitShift
;
chunks_
[
i
]
|
=
(
1
<
<
bitShift
)
;
return
Result
:
:
OK
;
}
}
break
;
}
case
4
:
{
for
(
uint32_t
i
=
firstChunk
;
i
<
lastChunkPlus1
;
i
+
+
)
{
if
(
(
chunks_
[
i
]
&
(
0xF
<
<
0
)
)
=
=
0
|
|
(
chunks_
[
i
]
&
(
0xF
<
<
4
)
)
=
=
0
)
{
uint32_t
bitShift
=
IndexOfLeastSignificantZero4Bits
(
chunks_
[
i
]
)
;
*
offset
=
i
*
8
+
bitShift
;
chunks_
[
i
]
|
=
(
0x0F
<
<
bitShift
)
;
return
Result
:
:
OK
;
}
}
break
;
}
case
2
:
{
for
(
uint32_t
i
=
firstChunk
;
i
<
lastChunkPlus1
;
i
+
+
)
{
if
(
(
chunks_
[
i
]
&
(
3
<
<
0
)
)
=
=
0
|
|
(
chunks_
[
i
]
&
(
3
<
<
2
)
)
=
=
0
|
|
(
chunks_
[
i
]
&
(
3
<
<
4
)
)
=
=
0
|
|
(
chunks_
[
i
]
&
(
3
<
<
6
)
)
=
=
0
)
{
uint32_t
bitShift
=
IndexOfLeastSignificantZero2Bits
(
chunks_
[
i
]
)
;
*
offset
=
i
*
8
+
bitShift
;
chunks_
[
i
]
|
=
(
3
<
<
bitShift
)
;
return
Result
:
:
OK
;
}
}
break
;
}
default
:
{
MOZ_CRASH
(
)
;
}
}
return
Result
:
:
Fail
;
}
void
BitVector
:
:
deallocate
(
uint32_t
offset
uint32_t
size
)
{
MOZ_ASSERT
(
OffsetToChunkNumber
(
offset
+
size
-
1
)
<
chunks_
.
length
(
)
)
;
switch
(
size
)
{
case
8
:
{
MOZ_ASSERT
(
(
offset
%
8
)
=
=
0
)
;
uint32_t
chunk
=
offset
/
8
;
MOZ_ASSERT
(
chunks_
[
chunk
]
=
=
0xFF
)
;
chunks_
[
chunk
]
=
0
;
break
;
}
case
16
:
{
MOZ_ASSERT
(
(
offset
%
8
)
=
=
0
)
;
uint32_t
chunk
=
offset
/
8
;
MOZ_ASSERT
(
chunk
+
1
<
chunks_
.
length
(
)
)
;
MOZ_ASSERT
(
chunks_
[
chunk
]
=
=
0xFF
)
;
MOZ_ASSERT
(
chunks_
[
chunk
+
1
]
=
=
0xFF
)
;
chunks_
[
chunk
]
=
0
;
chunks_
[
chunk
+
1
]
=
0
;
break
;
}
case
1
:
{
uint32_t
chunk
=
offset
/
8
;
uint32_t
shift
=
offset
%
8
;
uint8_t
mask
=
1
<
<
shift
;
MOZ_ASSERT
(
(
chunks_
[
chunk
]
&
mask
)
=
=
mask
)
;
chunks_
[
chunk
]
&
=
~
mask
;
break
;
}
case
4
:
{
MOZ_ASSERT
(
(
offset
%
4
)
=
=
0
)
;
uint32_t
chunk
=
offset
/
8
;
uint32_t
shift
=
offset
%
8
;
uint8_t
mask
=
0xF
<
<
shift
;
MOZ_ASSERT
(
(
chunks_
[
chunk
]
&
mask
)
=
=
mask
)
;
chunks_
[
chunk
]
&
=
~
mask
;
break
;
}
case
2
:
{
MOZ_ASSERT
(
(
offset
%
2
)
=
=
0
)
;
uint32_t
chunk
=
offset
/
8
;
uint32_t
shift
=
offset
%
8
;
uint8_t
mask
=
0x3
<
<
shift
;
MOZ_ASSERT
(
(
chunks_
[
chunk
]
&
mask
)
=
=
mask
)
;
chunks_
[
chunk
]
&
=
~
mask
;
break
;
}
default
:
{
MOZ_CRASH
(
)
;
}
}
}
BitVector
:
:
Result
FixedSizeBitVector
:
:
init
(
uint32_t
layoutBytesReserved
uint32_t
layoutBytesTotal
)
{
MOZ_ASSERT
(
layoutBytesTotal
>
0
)
;
MOZ_ASSERT
(
layoutBytesReserved
<
layoutBytesTotal
)
;
MOZ_ASSERT
(
Is8Aligned
(
layoutBytesReserved
)
)
;
MOZ_ASSERT
(
Is8Aligned
(
layoutBytesTotal
)
)
;
chunksReserved_
=
layoutBytesReserved
/
8
;
chunksTotal_
=
layoutBytesTotal
/
8
;
return
BitVector
:
:
init
(
chunksReserved_
chunksTotal_
)
;
}
BitVector
:
:
Result
FixedSizeBitVector
:
:
allocate
(
uint32_t
size
uint32_t
*
offset
)
{
return
BitVector
:
:
allocate
(
size
chunksReserved_
chunksTotal_
offset
)
;
}
BitVector
:
:
Result
VariableSizeBitVector
:
:
init
(
)
{
return
BitVector
:
:
init
(
0
1
)
;
}
BitVector
:
:
Result
VariableSizeBitVector
:
:
allocate
(
uint32_t
size
uint32_t
*
offset
)
{
Result
res
=
BitVector
:
:
allocate
(
size
0
chunks_
.
length
(
)
offset
)
;
if
(
res
=
=
Result
:
:
OOM
)
{
return
Result
:
:
OOM
;
}
if
(
res
=
=
Result
:
:
OK
)
{
used_
=
true
;
return
res
;
}
res
=
addMoreChunks
(
)
;
if
(
res
=
=
Result
:
:
OOM
)
{
return
Result
:
:
OOM
;
}
res
=
BitVector
:
:
allocate
(
size
0
chunks_
.
length
(
)
offset
)
;
if
(
res
=
=
Result
:
:
OOM
)
{
return
Result
:
:
OOM
;
}
MOZ_RELEASE_ASSERT
(
res
=
=
Result
:
:
OK
)
;
used_
=
true
;
return
Result
:
:
OK
;
}
bool
VariableSizeBitVector
:
:
unused
(
)
const
{
return
!
used_
;
}
uint32_t
VariableSizeBitVector
:
:
totalOffset
(
)
const
{
uint32_t
res
=
BitVector
:
:
totalOffset
(
)
;
MOZ_ASSERT
(
used_
=
=
(
res
>
0
)
)
;
return
res
;
}
bool
StructLayout
:
:
init
(
uint32_t
firstUsableILOffset
uint32_t
usableILSize
)
{
MOZ_ASSERT
(
IsWordAligned
(
firstUsableILOffset
)
)
;
MOZ_ASSERT
(
IsWordAligned
(
usableILSize
)
)
;
MOZ_ASSERT
(
usableILSize
>
=
sizeof
(
void
*
)
)
;
oolptrILO_
=
InvalidOffset
;
BitVector
:
:
Result
res
=
ilBitVector_
.
init
(
firstUsableILOffset
firstUsableILOffset
+
usableILSize
)
;
if
(
res
=
=
BitVector
:
:
Result
:
:
OOM
)
{
return
false
;
}
res
=
oolBitVector_
.
init
(
)
;
if
(
res
=
=
BitVector
:
:
Result
:
:
OOM
)
{
return
false
;
}
return
true
;
}
bool
StructLayout
:
:
addField
(
uint32_t
fieldSize
FieldAccessPath
*
path
)
{
MOZ_ASSERT
(
fieldSize
=
=
16
|
|
fieldSize
=
=
8
|
|
fieldSize
=
=
4
|
|
fieldSize
=
=
2
|
|
fieldSize
=
=
1
)
;
numFieldsProcessed_
+
+
;
MOZ_RELEASE_ASSERT
(
numFieldsProcessed_
<
=
js
:
:
wasm
:
:
MaxStructFields
)
;
MOZ_RELEASE_ASSERT
(
fieldSize
<
=
16
)
;
*
path
=
FieldAccessPath
(
)
;
mozilla
:
:
DebugOnly
<
uint32_t
>
initialHash
=
hash
(
)
;
MOZ_ASSERT
(
oolBitVector_
.
unused
(
)
=
=
(
oolptrILO_
=
=
InvalidOffset
)
)
;
if
(
oolBitVector_
.
unused
(
)
)
{
uint32_t
fieldOffset
=
InvalidOffset
;
BitVector
:
:
Result
res
=
ilBitVector_
.
allocate
(
fieldSize
&
fieldOffset
)
;
if
(
res
=
=
BitVector
:
:
Result
:
:
OOM
)
{
return
false
;
}
mozilla
:
:
DebugOnly
<
uint32_t
>
hash2
=
hash
(
)
;
if
(
res
=
=
BitVector
:
:
Result
:
:
OK
)
{
uint32_t
dummyOffset
=
InvalidOffset
;
res
=
ilBitVector_
.
allocate
(
sizeof
(
void
*
)
&
dummyOffset
)
;
if
(
res
=
=
BitVector
:
:
Result
:
:
OOM
)
{
return
false
;
}
if
(
res
=
=
BitVector
:
:
Result
:
:
OK
)
{
MOZ_ASSERT
(
fieldOffset
!
=
dummyOffset
)
;
ilBitVector_
.
deallocate
(
dummyOffset
sizeof
(
void
*
)
)
;
MOZ_ASSERT
(
hash
(
)
=
=
hash2
)
;
*
path
=
FieldAccessPath
(
fieldOffset
)
;
return
true
;
}
ilBitVector_
.
deallocate
(
fieldOffset
fieldSize
)
;
}
}
MOZ_ASSERT
(
hash
(
)
=
=
initialHash
)
;
MOZ_ASSERT
(
oolBitVector_
.
unused
(
)
=
=
(
oolptrILO_
=
=
InvalidOffset
)
)
;
if
(
oolBitVector_
.
unused
(
)
)
{
uint32_t
oolptrOffset
=
InvalidOffset
;
BitVector
:
:
Result
res
=
ilBitVector_
.
allocate
(
sizeof
(
void
*
)
&
oolptrOffset
)
;
if
(
res
=
=
BitVector
:
:
Result
:
:
OOM
)
{
return
false
;
}
MOZ_ASSERT
(
res
=
=
BitVector
:
:
Result
:
:
OK
)
;
oolptrILO_
=
oolptrOffset
;
uint32_t
fieldOffset
=
InvalidOffset
;
res
=
oolBitVector_
.
allocate
(
fieldSize
&
fieldOffset
)
;
if
(
res
=
=
BitVector
:
:
Result
:
:
OOM
)
{
return
false
;
}
MOZ_RELEASE_ASSERT
(
res
=
=
BitVector
:
:
Result
:
:
OK
)
;
MOZ_ASSERT
(
!
oolBitVector_
.
unused
(
)
)
;
MOZ_ASSERT
(
fieldOffset
=
=
0
)
;
*
path
=
FieldAccessPath
(
oolptrILO_
fieldOffset
)
;
return
true
;
}
MOZ_ASSERT
(
hash
(
)
=
=
initialHash
)
;
MOZ_ASSERT
(
!
oolBitVector_
.
unused
(
)
&
&
oolptrILO_
!
=
InvalidOffset
)
;
uint32_t
fieldOffset
=
InvalidOffset
;
BitVector
:
:
Result
res
=
ilBitVector_
.
allocate
(
fieldSize
&
fieldOffset
)
;
if
(
res
=
=
BitVector
:
:
Result
:
:
OOM
)
{
return
false
;
}
if
(
res
=
=
BitVector
:
:
Result
:
:
OK
)
{
*
path
=
FieldAccessPath
(
fieldOffset
)
;
return
true
;
}
fieldOffset
=
InvalidOffset
;
res
=
oolBitVector_
.
allocate
(
fieldSize
&
fieldOffset
)
;
if
(
res
=
=
BitVector
:
:
Result
:
:
OOM
)
{
return
false
;
}
MOZ_RELEASE_ASSERT
(
res
=
=
BitVector
:
:
Result
:
:
OK
)
;
*
path
=
FieldAccessPath
(
oolptrILO_
fieldOffset
)
;
return
true
;
}
uint32_t
StructLayout
:
:
hash
(
)
const
{
uint32_t
h
=
ilBitVector_
.
hashNonZero
(
)
;
h
=
(
h
<
<
16
)
|
(
h
>
>
16
)
;
h
^
=
oolBitVector_
.
hashNonZero
(
)
;
return
h
;
}
uint32_t
StructLayout
:
:
totalSizeIL
(
)
const
{
return
js
:
:
RoundUp
(
ilBitVector_
.
totalOffset
(
)
sizeof
(
void
*
)
)
;
}
bool
StructLayout
:
:
hasOOL
(
)
const
{
return
!
oolBitVector_
.
unused
(
)
;
}
uint32_t
StructLayout
:
:
totalSizeOOL
(
)
const
{
MOZ_ASSERT
(
hasOOL
(
)
)
;
MOZ_ASSERT
(
oolptrILO_
!
=
InvalidOffset
)
;
return
js
:
:
RoundUp
(
oolBitVector_
.
totalOffset
(
)
sizeof
(
void
*
)
)
;
}
FieldAccessPath
StructLayout
:
:
oolPointerPath
(
)
const
{
MOZ_ASSERT
(
hasOOL
(
)
)
;
MOZ_ASSERT
(
oolptrILO_
!
=
InvalidOffset
)
;
return
FieldAccessPath
(
oolptrILO_
)
;
}
}
