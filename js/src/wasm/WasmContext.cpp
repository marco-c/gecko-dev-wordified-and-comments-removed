#
include
"
wasm
/
WasmContext
.
h
"
#
include
"
js
/
friend
/
StackLimits
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
wasm
/
WasmPI
.
h
"
using
namespace
js
:
:
wasm
;
Context
:
:
Context
(
)
:
triedToInstallSignalHandlers
(
false
)
haveSignalHandlers
(
false
)
stackLimit
(
JS
:
:
NativeStackLimitMin
)
#
ifdef
ENABLE_WASM_JSPI
activeSuspender_
(
nullptr
)
onSuspendableStack
(
0
)
suspendableStacksCount
(
0
)
suspendedStacks_
(
)
#
endif
{
}
Context
:
:
~
Context
(
)
{
#
ifdef
ENABLE_WASM_JSPI
MOZ_ASSERT
(
activeSuspender_
=
=
nullptr
)
;
MOZ_ASSERT
(
suspendedStacks_
.
isEmpty
(
)
)
;
#
endif
}
void
Context
:
:
initStackLimit
(
JSContext
*
cx
)
{
stackLimit
=
cx
-
>
jitStackLimitNoInterrupt
;
}
#
ifdef
ENABLE_WASM_JSPI
SuspenderObject
*
Context
:
:
activeSuspender
(
)
{
return
activeSuspender_
;
}
void
Context
:
:
trace
(
JSTracer
*
trc
)
{
if
(
activeSuspender_
)
{
TraceEdge
(
trc
&
activeSuspender_
"
suspender
"
)
;
}
}
void
Context
:
:
traceRoots
(
JSTracer
*
trc
)
{
if
(
!
trc
-
>
isTenuringTracer
(
)
)
{
return
;
}
gc
:
:
AssertRootMarkingPhase
(
trc
)
;
for
(
const
SuspenderObjectData
&
data
:
suspendedStacks_
)
{
TraceSuspendableStack
(
trc
data
)
;
}
}
void
Context
:
:
enterSuspendableStack
(
SuspenderObject
*
suspender
JS
:
:
NativeStackLimit
newStackLimit
)
{
MOZ_ASSERT
(
onSuspendableStack
=
=
0
)
;
MOZ_ASSERT
(
!
activeSuspender_
)
;
activeSuspender_
=
suspender
;
onSuspendableStack
=
1
;
stackLimit
=
newStackLimit
;
}
void
Context
:
:
leaveSuspendableStack
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
onSuspendableStack
!
=
0
)
;
MOZ_ASSERT
(
activeSuspender_
)
;
activeSuspender_
=
nullptr
;
onSuspendableStack
=
0
;
initStackLimit
(
cx
)
;
}
bool
js
:
:
IsSuspendableStackActive
(
JSContext
*
cx
)
{
return
cx
-
>
wasm
(
)
.
onSuspendableStack
!
=
0
;
}
JS
:
:
NativeStackLimit
js
:
:
GetSuspendableStackLimit
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
IsSuspendableStackActive
(
cx
)
)
;
return
cx
-
>
wasm
(
)
.
stackLimit
;
}
#
endif
