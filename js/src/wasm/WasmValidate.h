#
ifndef
wasm_validate_h
#
define
wasm_validate_h
#
include
<
type_traits
>
#
include
"
ds
/
Bitmap
.
h
"
#
include
"
wasm
/
WasmCompile
.
h
"
#
include
"
wasm
/
WasmTypes
.
h
"
namespace
js
{
namespace
wasm
{
struct
SectionRange
{
uint32_t
start
;
uint32_t
size
;
uint32_t
end
(
)
const
{
return
start
+
size
;
}
bool
operator
=
=
(
const
SectionRange
&
rhs
)
const
{
return
start
=
=
rhs
.
start
&
&
size
=
=
rhs
.
size
;
}
}
;
using
MaybeSectionRange
=
Maybe
<
SectionRange
>
;
struct
CompileArgs
;
class
Decoder
;
struct
CompilerEnvironment
{
enum
State
{
InitialWithArgs
InitialWithModeTierDebug
Computed
}
;
State
state_
;
union
{
const
CompileArgs
*
args_
;
struct
{
CompileMode
mode_
;
Tier
tier_
;
OptimizedBackend
optimizedBackend_
;
DebugEnabled
debug_
;
}
;
}
;
public
:
explicit
CompilerEnvironment
(
const
CompileArgs
&
args
)
;
CompilerEnvironment
(
CompileMode
mode
Tier
tier
OptimizedBackend
optimizedBackend
DebugEnabled
debugEnabled
)
;
void
computeParameters
(
Decoder
&
d
)
;
void
computeParameters
(
)
;
bool
isComputed
(
)
const
{
return
state_
=
=
Computed
;
}
CompileMode
mode
(
)
const
{
MOZ_ASSERT
(
isComputed
(
)
)
;
return
mode_
;
}
Tier
tier
(
)
const
{
MOZ_ASSERT
(
isComputed
(
)
)
;
return
tier_
;
}
OptimizedBackend
optimizedBackend
(
)
const
{
MOZ_ASSERT
(
isComputed
(
)
)
;
return
optimizedBackend_
;
}
DebugEnabled
debug
(
)
const
{
MOZ_ASSERT
(
isComputed
(
)
)
;
return
debug_
;
}
bool
debugEnabled
(
)
const
{
return
debug
(
)
=
=
DebugEnabled
:
:
True
;
}
}
;
struct
ModuleEnvironment
{
const
ModuleKind
kind
;
const
FeatureArgs
features
;
Maybe
<
uint32_t
>
dataCount
;
MemoryUsage
memoryUsage
;
uint64_t
minMemoryLength
;
Maybe
<
uint64_t
>
maxMemoryLength
;
TypeDefVector
types
;
TypeIdDescVector
typeIds
;
FuncDescVector
funcs
;
Uint32Vector
funcImportGlobalDataOffsets
;
GlobalDescVector
globals
;
#
ifdef
ENABLE_WASM_EXCEPTIONS
EventDescVector
events
;
#
endif
TableDescVector
tables
;
Uint32Vector
asmJSSigToTableIndex
;
ImportVector
imports
;
ExportVector
exports
;
Maybe
<
uint32_t
>
startFuncIndex
;
ElemSegmentVector
elemSegments
;
MaybeSectionRange
codeSection
;
SparseBitmap
validForRefFunc
;
DataSegmentEnvVector
dataSegments
;
CustomSectionEnvVector
customSections
;
Maybe
<
uint32_t
>
nameCustomSectionIndex
;
Maybe
<
Name
>
moduleName
;
NameVector
funcNames
;
explicit
ModuleEnvironment
(
FeatureArgs
features
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind
(
kind
)
features
(
features
)
memoryUsage
(
MemoryUsage
:
:
None
)
minMemoryLength
(
0
)
{
}
size_t
numTables
(
)
const
{
return
tables
.
length
(
)
;
}
size_t
numTypes
(
)
const
{
return
types
.
length
(
)
;
}
size_t
numFuncs
(
)
const
{
return
funcs
.
length
(
)
;
}
size_t
numFuncImports
(
)
const
{
return
funcImportGlobalDataOffsets
.
length
(
)
;
}
size_t
numFuncDefs
(
)
const
{
return
funcs
.
length
(
)
-
funcImportGlobalDataOffsets
.
length
(
)
;
}
Shareable
sharedMemoryEnabled
(
)
const
{
return
features
.
sharedMemory
;
}
bool
refTypesEnabled
(
)
const
{
return
features
.
refTypes
;
}
bool
functionReferencesEnabled
(
)
const
{
return
features
.
functionReferences
;
}
bool
gcTypesEnabled
(
)
const
{
return
features
.
gcTypes
;
}
bool
multiValueEnabled
(
)
const
{
return
features
.
multiValue
;
}
bool
v128Enabled
(
)
const
{
return
features
.
v128
;
}
bool
hugeMemoryEnabled
(
)
const
{
return
!
isAsmJS
(
)
&
&
features
.
hugeMemory
;
}
bool
exceptionsEnabled
(
)
const
{
return
features
.
exceptions
;
}
bool
usesMemory
(
)
const
{
return
memoryUsage
!
=
MemoryUsage
:
:
None
;
}
bool
usesSharedMemory
(
)
const
{
return
memoryUsage
=
=
MemoryUsage
:
:
Shared
;
}
bool
isAsmJS
(
)
const
{
return
kind
=
=
ModuleKind
:
:
AsmJS
;
}
uint32_t
funcMaxResults
(
)
const
{
return
multiValueEnabled
(
)
?
MaxResults
:
1
;
}
bool
funcIsImport
(
uint32_t
funcIndex
)
const
{
return
funcIndex
<
funcImportGlobalDataOffsets
.
length
(
)
;
}
bool
isRefSubtypeOf
(
RefType
one
RefType
two
)
const
{
if
(
one
=
=
two
)
{
return
true
;
}
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
if
(
functionReferencesEnabled
(
)
)
{
if
(
!
(
one
.
isNullable
(
)
=
=
two
.
isNullable
(
)
|
|
two
.
isNullable
(
)
)
)
{
return
false
;
}
if
(
!
one
.
isTypeIndex
(
)
&
&
!
two
.
isTypeIndex
(
)
&
&
one
.
kind
(
)
=
=
two
.
kind
(
)
)
{
return
true
;
}
#
ifdef
ENABLE_WASM_GC
if
(
gcTypesEnabled
(
)
)
{
if
(
isStructType
(
one
)
&
&
two
.
isEq
(
)
)
{
return
true
;
}
if
(
isStructType
(
one
)
&
&
isStructType
(
two
)
)
{
return
isStructPrefixOf
(
two
one
)
;
}
}
#
endif
return
false
;
}
#
endif
return
false
;
}
bool
isStructType
(
ValType
t
)
const
{
return
t
.
isTypeIndex
(
)
&
&
types
[
t
.
refType
(
)
.
typeIndex
(
)
]
.
isStructType
(
)
;
}
private
:
bool
isStructPrefixOf
(
ValType
a
ValType
b
)
const
{
const
StructType
&
other
=
types
[
a
.
refType
(
)
.
typeIndex
(
)
]
.
structType
(
)
;
return
types
[
b
.
refType
(
)
.
typeIndex
(
)
]
.
structType
(
)
.
hasPrefix
(
other
)
;
}
}
;
class
ElemSegmentFlags
{
enum
class
Flags
:
uint32_t
{
Passive
=
0x1
WithIndexOrDeclared
=
0x2
ElemExpression
=
0x4
KindMask
=
Passive
|
WithIndexOrDeclared
PayloadMask
=
ElemExpression
AllFlags
=
Passive
|
WithIndexOrDeclared
|
ElemExpression
}
;
uint32_t
encoded_
;
explicit
ElemSegmentFlags
(
uint32_t
encoded
)
:
encoded_
(
encoded
)
{
}
public
:
ElemSegmentFlags
(
ElemSegmentKind
kind
ElemSegmentPayload
payload
)
{
encoded_
=
uint32_t
(
kind
)
|
uint32_t
(
payload
)
;
}
static
Maybe
<
ElemSegmentFlags
>
construct
(
uint32_t
encoded
)
{
if
(
encoded
>
uint32_t
(
Flags
:
:
AllFlags
)
)
{
return
Nothing
(
)
;
}
return
Some
(
ElemSegmentFlags
(
encoded
)
)
;
}
uint32_t
encoded
(
)
const
{
return
encoded_
;
}
ElemSegmentKind
kind
(
)
const
{
return
static_cast
<
ElemSegmentKind
>
(
encoded_
&
uint32_t
(
Flags
:
:
KindMask
)
)
;
}
ElemSegmentPayload
payload
(
)
const
{
return
static_cast
<
ElemSegmentPayload
>
(
encoded_
&
uint32_t
(
Flags
:
:
PayloadMask
)
)
;
}
}
;
class
Encoder
{
Bytes
&
bytes_
;
template
<
class
T
>
MOZ_MUST_USE
bool
write
(
const
T
&
v
)
{
return
bytes_
.
append
(
reinterpret_cast
<
const
uint8_t
*
>
(
&
v
)
sizeof
(
T
)
)
;
}
template
<
typename
UInt
>
MOZ_MUST_USE
bool
writeVarU
(
UInt
i
)
{
do
{
uint8_t
byte
=
i
&
0x7f
;
i
>
>
=
7
;
if
(
i
!
=
0
)
{
byte
|
=
0x80
;
}
if
(
!
bytes_
.
append
(
byte
)
)
{
return
false
;
}
}
while
(
i
!
=
0
)
;
return
true
;
}
template
<
typename
SInt
>
MOZ_MUST_USE
bool
writeVarS
(
SInt
i
)
{
bool
done
;
do
{
uint8_t
byte
=
i
&
0x7f
;
i
>
>
=
7
;
done
=
(
(
i
=
=
0
)
&
&
!
(
byte
&
0x40
)
)
|
|
(
(
i
=
=
-
1
)
&
&
(
byte
&
0x40
)
)
;
if
(
!
done
)
{
byte
|
=
0x80
;
}
if
(
!
bytes_
.
append
(
byte
)
)
{
return
false
;
}
}
while
(
!
done
)
;
return
true
;
}
void
patchVarU32
(
size_t
offset
uint32_t
patchBits
uint32_t
assertBits
)
{
do
{
uint8_t
assertByte
=
assertBits
&
0x7f
;
uint8_t
patchByte
=
patchBits
&
0x7f
;
assertBits
>
>
=
7
;
patchBits
>
>
=
7
;
if
(
assertBits
!
=
0
)
{
assertByte
|
=
0x80
;
patchByte
|
=
0x80
;
}
MOZ_ASSERT
(
assertByte
=
=
bytes_
[
offset
]
)
;
bytes_
[
offset
]
=
patchByte
;
offset
+
+
;
}
while
(
assertBits
!
=
0
)
;
}
void
patchFixedU7
(
size_t
offset
uint8_t
patchBits
uint8_t
assertBits
)
{
MOZ_ASSERT
(
patchBits
<
=
uint8_t
(
INT8_MAX
)
)
;
patchFixedU8
(
offset
patchBits
assertBits
)
;
}
void
patchFixedU8
(
size_t
offset
uint8_t
patchBits
uint8_t
assertBits
)
{
MOZ_ASSERT
(
bytes_
[
offset
]
=
=
assertBits
)
;
bytes_
[
offset
]
=
patchBits
;
}
uint32_t
varU32ByteLength
(
size_t
offset
)
const
{
size_t
start
=
offset
;
while
(
bytes_
[
offset
]
&
0x80
)
{
offset
+
+
;
}
return
offset
-
start
+
1
;
}
public
:
explicit
Encoder
(
Bytes
&
bytes
)
:
bytes_
(
bytes
)
{
MOZ_ASSERT
(
empty
(
)
)
;
}
size_t
currentOffset
(
)
const
{
return
bytes_
.
length
(
)
;
}
bool
empty
(
)
const
{
return
currentOffset
(
)
=
=
0
;
}
MOZ_MUST_USE
bool
writeFixedU7
(
uint8_t
i
)
{
MOZ_ASSERT
(
i
<
=
uint8_t
(
INT8_MAX
)
)
;
return
writeFixedU8
(
i
)
;
}
MOZ_MUST_USE
bool
writeFixedU8
(
uint8_t
i
)
{
return
write
<
uint8_t
>
(
i
)
;
}
MOZ_MUST_USE
bool
writeFixedU32
(
uint32_t
i
)
{
return
write
<
uint32_t
>
(
i
)
;
}
MOZ_MUST_USE
bool
writeFixedF32
(
float
f
)
{
return
write
<
float
>
(
f
)
;
}
MOZ_MUST_USE
bool
writeFixedF64
(
double
d
)
{
return
write
<
double
>
(
d
)
;
}
MOZ_MUST_USE
bool
writeVarU32
(
uint32_t
i
)
{
return
writeVarU
<
uint32_t
>
(
i
)
;
}
MOZ_MUST_USE
bool
writeVarS32
(
int32_t
i
)
{
return
writeVarS
<
int32_t
>
(
i
)
;
}
MOZ_MUST_USE
bool
writeVarU64
(
uint64_t
i
)
{
return
writeVarU
<
uint64_t
>
(
i
)
;
}
MOZ_MUST_USE
bool
writeVarS64
(
int64_t
i
)
{
return
writeVarS
<
int64_t
>
(
i
)
;
}
MOZ_MUST_USE
bool
writeValType
(
ValType
type
)
{
static_assert
(
size_t
(
TypeCode
:
:
Limit
)
<
=
UINT8_MAX
"
fits
"
)
;
if
(
type
.
isTypeIndex
(
)
)
{
return
writeFixedU8
(
uint8_t
(
TypeCode
:
:
NullableRef
)
)
&
&
writeVarU32
(
type
.
refType
(
)
.
typeIndex
(
)
)
;
}
TypeCode
tc
=
UnpackTypeCodeType
(
type
.
packed
(
)
)
;
MOZ_ASSERT
(
size_t
(
tc
)
<
size_t
(
TypeCode
:
:
Limit
)
)
;
return
writeFixedU8
(
uint8_t
(
tc
)
)
;
}
MOZ_MUST_USE
bool
writeOp
(
Opcode
opcode
)
{
uint32_t
bits
=
opcode
.
bits
(
)
;
if
(
!
writeFixedU8
(
bits
&
255
)
)
{
return
false
;
}
if
(
opcode
.
isOp
(
)
)
{
return
true
;
}
return
writeVarU32
(
bits
>
>
8
)
;
}
MOZ_MUST_USE
bool
writePatchableFixedU7
(
size_t
*
offset
)
{
*
offset
=
bytes_
.
length
(
)
;
return
writeFixedU8
(
UINT8_MAX
)
;
}
void
patchFixedU7
(
size_t
offset
uint8_t
patchBits
)
{
return
patchFixedU7
(
offset
patchBits
UINT8_MAX
)
;
}
MOZ_MUST_USE
bool
writePatchableVarU32
(
size_t
*
offset
)
{
*
offset
=
bytes_
.
length
(
)
;
return
writeVarU32
(
UINT32_MAX
)
;
}
void
patchVarU32
(
size_t
offset
uint32_t
patchBits
)
{
return
patchVarU32
(
offset
patchBits
UINT32_MAX
)
;
}
MOZ_MUST_USE
bool
writeBytes
(
const
void
*
bytes
uint32_t
numBytes
)
{
return
writeVarU32
(
numBytes
)
&
&
bytes_
.
append
(
reinterpret_cast
<
const
uint8_t
*
>
(
bytes
)
numBytes
)
;
}
MOZ_MUST_USE
bool
startSection
(
SectionId
id
size_t
*
offset
)
{
MOZ_ASSERT
(
uint32_t
(
id
)
<
128
)
;
return
writeVarU32
(
uint32_t
(
id
)
)
&
&
writePatchableVarU32
(
offset
)
;
}
void
finishSection
(
size_t
offset
)
{
return
patchVarU32
(
offset
bytes_
.
length
(
)
-
offset
-
varU32ByteLength
(
offset
)
)
;
}
}
;
class
Decoder
{
const
uint8_t
*
const
beg_
;
const
uint8_t
*
const
end_
;
const
uint8_t
*
cur_
;
const
size_t
offsetInModule_
;
UniqueChars
*
error_
;
UniqueCharsVector
*
warnings_
;
bool
resilientMode_
;
template
<
class
T
>
MOZ_MUST_USE
bool
read
(
T
*
out
)
{
if
(
bytesRemain
(
)
<
sizeof
(
T
)
)
{
return
false
;
}
memcpy
(
(
void
*
)
out
cur_
sizeof
(
T
)
)
;
cur_
+
=
sizeof
(
T
)
;
return
true
;
}
template
<
class
T
>
T
uncheckedRead
(
)
{
MOZ_ASSERT
(
bytesRemain
(
)
>
=
sizeof
(
T
)
)
;
T
ret
;
memcpy
(
&
ret
cur_
sizeof
(
T
)
)
;
cur_
+
=
sizeof
(
T
)
;
return
ret
;
}
template
<
class
T
>
void
uncheckedRead
(
T
*
ret
)
{
MOZ_ASSERT
(
bytesRemain
(
)
>
=
sizeof
(
T
)
)
;
memcpy
(
ret
cur_
sizeof
(
T
)
)
;
cur_
+
=
sizeof
(
T
)
;
}
template
<
typename
UInt
>
MOZ_MUST_USE
bool
readVarU
(
UInt
*
out
)
{
DebugOnly
<
const
uint8_t
*
>
before
=
cur_
;
const
unsigned
numBits
=
sizeof
(
UInt
)
*
CHAR_BIT
;
const
unsigned
remainderBits
=
numBits
%
7
;
const
unsigned
numBitsInSevens
=
numBits
-
remainderBits
;
UInt
u
=
0
;
uint8_t
byte
;
UInt
shift
=
0
;
do
{
if
(
!
readFixedU8
(
&
byte
)
)
{
return
false
;
}
if
(
!
(
byte
&
0x80
)
)
{
*
out
=
u
|
UInt
(
byte
)
<
<
shift
;
return
true
;
}
u
|
=
UInt
(
byte
&
0x7F
)
<
<
shift
;
shift
+
=
7
;
}
while
(
shift
!
=
numBitsInSevens
)
;
if
(
!
readFixedU8
(
&
byte
)
|
|
(
byte
&
(
unsigned
(
-
1
)
<
<
remainderBits
)
)
)
{
return
false
;
}
*
out
=
u
|
(
UInt
(
byte
)
<
<
numBitsInSevens
)
;
MOZ_ASSERT_IF
(
sizeof
(
UInt
)
=
=
4
unsigned
(
cur_
-
before
)
<
=
MaxVarU32DecodedBytes
)
;
return
true
;
}
template
<
typename
SInt
>
MOZ_MUST_USE
bool
readVarS
(
SInt
*
out
)
{
using
UInt
=
std
:
:
make_unsigned_t
<
SInt
>
;
const
unsigned
numBits
=
sizeof
(
SInt
)
*
CHAR_BIT
;
const
unsigned
remainderBits
=
numBits
%
7
;
const
unsigned
numBitsInSevens
=
numBits
-
remainderBits
;
SInt
s
=
0
;
uint8_t
byte
;
unsigned
shift
=
0
;
do
{
if
(
!
readFixedU8
(
&
byte
)
)
{
return
false
;
}
s
|
=
SInt
(
byte
&
0x7f
)
<
<
shift
;
shift
+
=
7
;
if
(
!
(
byte
&
0x80
)
)
{
if
(
byte
&
0x40
)
{
s
|
=
UInt
(
-
1
)
<
<
shift
;
}
*
out
=
s
;
return
true
;
}
}
while
(
shift
<
numBitsInSevens
)
;
if
(
!
remainderBits
|
|
!
readFixedU8
(
&
byte
)
|
|
(
byte
&
0x80
)
)
{
return
false
;
}
uint8_t
mask
=
0x7f
&
(
uint8_t
(
-
1
)
<
<
remainderBits
)
;
if
(
(
byte
&
mask
)
!
=
(
(
byte
&
(
1
<
<
(
remainderBits
-
1
)
)
)
?
mask
:
0
)
)
{
return
false
;
}
*
out
=
s
|
UInt
(
byte
)
<
<
shift
;
return
true
;
}
public
:
Decoder
(
const
uint8_t
*
begin
const
uint8_t
*
end
size_t
offsetInModule
UniqueChars
*
error
UniqueCharsVector
*
warnings
=
nullptr
bool
resilientMode
=
false
)
:
beg_
(
begin
)
end_
(
end
)
cur_
(
begin
)
offsetInModule_
(
offsetInModule
)
error_
(
error
)
warnings_
(
warnings
)
resilientMode_
(
resilientMode
)
{
MOZ_ASSERT
(
begin
<
=
end
)
;
}
explicit
Decoder
(
const
Bytes
&
bytes
size_t
offsetInModule
=
0
UniqueChars
*
error
=
nullptr
UniqueCharsVector
*
warnings
=
nullptr
)
:
beg_
(
bytes
.
begin
(
)
)
end_
(
bytes
.
end
(
)
)
cur_
(
bytes
.
begin
(
)
)
offsetInModule_
(
offsetInModule
)
error_
(
error
)
warnings_
(
warnings
)
resilientMode_
(
false
)
{
}
bool
fail
(
const
char
*
msg
)
{
return
fail
(
currentOffset
(
)
msg
)
;
}
bool
failf
(
const
char
*
msg
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
void
warnf
(
const
char
*
msg
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
bool
fail
(
size_t
errorOffset
const
char
*
msg
)
;
UniqueChars
*
error
(
)
{
return
error_
;
}
void
clearError
(
)
{
if
(
error_
)
{
error_
-
>
reset
(
)
;
}
}
bool
done
(
)
const
{
MOZ_ASSERT
(
cur_
<
=
end_
)
;
return
cur_
=
=
end_
;
}
bool
resilientMode
(
)
const
{
return
resilientMode_
;
}
size_t
bytesRemain
(
)
const
{
MOZ_ASSERT
(
end_
>
=
cur_
)
;
return
size_t
(
end_
-
cur_
)
;
}
void
rollbackPosition
(
const
uint8_t
*
pos
)
{
cur_
=
pos
;
}
const
uint8_t
*
currentPosition
(
)
const
{
return
cur_
;
}
size_t
currentOffset
(
)
const
{
return
offsetInModule_
+
(
cur_
-
beg_
)
;
}
const
uint8_t
*
begin
(
)
const
{
return
beg_
;
}
const
uint8_t
*
end
(
)
const
{
return
end_
;
}
bool
peekByte
(
uint8_t
*
byte
)
{
if
(
done
(
)
)
{
return
false
;
}
*
byte
=
*
cur_
;
return
true
;
}
MOZ_MUST_USE
bool
readFixedU8
(
uint8_t
*
i
)
{
return
read
<
uint8_t
>
(
i
)
;
}
MOZ_MUST_USE
bool
readFixedU32
(
uint32_t
*
u
)
{
return
read
<
uint32_t
>
(
u
)
;
}
MOZ_MUST_USE
bool
readFixedF32
(
float
*
f
)
{
return
read
<
float
>
(
f
)
;
}
MOZ_MUST_USE
bool
readFixedF64
(
double
*
d
)
{
return
read
<
double
>
(
d
)
;
}
#
ifdef
ENABLE_WASM_SIMD
MOZ_MUST_USE
bool
readFixedV128
(
V128
*
d
)
{
for
(
unsigned
i
=
0
;
i
<
16
;
i
+
+
)
{
if
(
!
read
<
uint8_t
>
(
d
-
>
bytes
+
i
)
)
{
return
false
;
}
}
return
true
;
}
#
endif
MOZ_MUST_USE
bool
readVarU32
(
uint32_t
*
out
)
{
return
readVarU
<
uint32_t
>
(
out
)
;
}
MOZ_MUST_USE
bool
readVarS32
(
int32_t
*
out
)
{
return
readVarS
<
int32_t
>
(
out
)
;
}
MOZ_MUST_USE
bool
readVarU64
(
uint64_t
*
out
)
{
return
readVarU
<
uint64_t
>
(
out
)
;
}
MOZ_MUST_USE
bool
readVarS64
(
int64_t
*
out
)
{
return
readVarS
<
int64_t
>
(
out
)
;
}
MOZ_MUST_USE
ValType
uncheckedReadValType
(
)
{
uint8_t
code
=
uncheckedReadFixedU8
(
)
;
switch
(
code
)
{
case
uint8_t
(
TypeCode
:
:
FuncRef
)
:
case
uint8_t
(
TypeCode
:
:
ExternRef
)
:
return
RefType
:
:
fromTypeCode
(
TypeCode
(
code
)
true
)
;
case
uint8_t
(
TypeCode
:
:
Ref
)
:
case
uint8_t
(
TypeCode
:
:
NullableRef
)
:
{
bool
nullable
=
code
=
=
uint8_t
(
TypeCode
:
:
NullableRef
)
;
uint8_t
nextByte
;
peekByte
(
&
nextByte
)
;
if
(
(
nextByte
&
SLEB128SignMask
)
=
=
SLEB128SignBit
)
{
uint8_t
code
=
uncheckedReadFixedU8
(
)
;
return
RefType
:
:
fromTypeCode
(
TypeCode
(
code
)
nullable
)
;
}
int32_t
x
=
uncheckedReadVarS32
(
)
;
return
RefType
:
:
fromTypeIndex
(
x
nullable
)
;
}
default
:
return
ValType
:
:
fromNonRefTypeCode
(
TypeCode
(
code
)
)
;
}
}
MOZ_MUST_USE
bool
readValType
(
uint32_t
numTypes
const
FeatureArgs
&
features
ValType
*
type
)
{
static_assert
(
uint8_t
(
TypeCode
:
:
Limit
)
<
=
UINT8_MAX
"
fits
"
)
;
uint8_t
code
;
if
(
!
readFixedU8
(
&
code
)
)
{
return
fail
(
"
expected
type
code
"
)
;
}
switch
(
code
)
{
case
uint8_t
(
TypeCode
:
:
I32
)
:
case
uint8_t
(
TypeCode
:
:
F32
)
:
case
uint8_t
(
TypeCode
:
:
F64
)
:
case
uint8_t
(
TypeCode
:
:
I64
)
:
*
type
=
ValType
:
:
fromNonRefTypeCode
(
TypeCode
(
code
)
)
;
return
true
;
#
ifdef
ENABLE_WASM_SIMD
case
uint8_t
(
TypeCode
:
:
V128
)
:
if
(
!
features
.
v128
)
{
return
fail
(
"
v128
not
enabled
"
)
;
}
*
type
=
ValType
:
:
fromNonRefTypeCode
(
TypeCode
(
code
)
)
;
return
true
;
#
endif
#
ifdef
ENABLE_WASM_REFTYPES
case
uint8_t
(
TypeCode
:
:
FuncRef
)
:
case
uint8_t
(
TypeCode
:
:
ExternRef
)
:
if
(
!
features
.
refTypes
)
{
return
fail
(
"
reference
types
not
enabled
"
)
;
}
*
type
=
RefType
:
:
fromTypeCode
(
TypeCode
(
code
)
true
)
;
return
true
;
#
endif
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
case
uint8_t
(
TypeCode
:
:
Ref
)
:
case
uint8_t
(
TypeCode
:
:
NullableRef
)
:
{
if
(
!
features
.
functionReferences
)
{
return
fail
(
"
(
ref
T
)
types
not
enabled
"
)
;
}
bool
nullable
=
code
=
=
uint8_t
(
TypeCode
:
:
NullableRef
)
;
RefType
refType
;
if
(
!
readHeapType
(
numTypes
features
nullable
&
refType
)
)
{
return
false
;
}
*
type
=
refType
;
return
true
;
}
#
endif
#
ifdef
ENABLE_WASM_GC
case
uint8_t
(
TypeCode
:
:
EqRef
)
:
if
(
!
features
.
gcTypes
)
{
return
fail
(
"
gc
types
not
enabled
"
)
;
}
*
type
=
RefType
:
:
fromTypeCode
(
TypeCode
(
code
)
true
)
;
return
true
;
#
endif
default
:
return
fail
(
"
bad
type
"
)
;
}
}
MOZ_MUST_USE
bool
readValType
(
const
TypeDefVector
&
types
const
FeatureArgs
&
features
ValType
*
type
)
{
if
(
!
readValType
(
types
.
length
(
)
features
type
)
)
{
return
false
;
}
if
(
type
-
>
isTypeIndex
(
)
&
&
!
validateTypeIndex
(
types
features
type
-
>
refType
(
)
)
)
{
return
false
;
}
return
true
;
}
MOZ_MUST_USE
bool
readHeapType
(
uint32_t
numTypes
const
FeatureArgs
&
features
bool
nullable
RefType
*
type
)
{
uint8_t
nextByte
;
if
(
!
peekByte
(
&
nextByte
)
)
{
return
fail
(
"
expected
heap
type
code
"
)
;
}
if
(
(
nextByte
&
SLEB128SignMask
)
=
=
SLEB128SignBit
)
{
uint8_t
code
;
if
(
!
readFixedU8
(
&
code
)
)
{
return
false
;
}
switch
(
code
)
{
case
uint8_t
(
TypeCode
:
:
FuncRef
)
:
case
uint8_t
(
TypeCode
:
:
ExternRef
)
:
*
type
=
RefType
:
:
fromTypeCode
(
TypeCode
(
code
)
nullable
)
;
return
true
;
#
ifdef
ENABLE_WASM_GC
case
uint8_t
(
TypeCode
:
:
EqRef
)
:
if
(
!
features
.
gcTypes
)
{
return
fail
(
"
gc
types
not
enabled
"
)
;
}
*
type
=
RefType
:
:
fromTypeCode
(
TypeCode
(
code
)
nullable
)
;
return
true
;
#
endif
default
:
return
fail
(
"
invalid
heap
type
"
)
;
}
}
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
if
(
features
.
functionReferences
)
{
int32_t
x
;
if
(
!
readVarS32
(
&
x
)
|
|
x
<
0
|
|
uint32_t
(
x
)
>
=
numTypes
)
{
return
fail
(
"
invalid
heap
type
index
"
)
;
}
*
type
=
RefType
:
:
fromTypeIndex
(
x
nullable
)
;
return
true
;
}
#
endif
return
fail
(
"
invalid
heap
type
"
)
;
}
MOZ_MUST_USE
bool
readHeapType
(
const
TypeDefVector
&
types
const
FeatureArgs
&
features
bool
nullable
RefType
*
type
)
{
if
(
!
readHeapType
(
types
.
length
(
)
features
nullable
type
)
)
{
return
false
;
}
if
(
type
-
>
isTypeIndex
(
)
&
&
!
validateTypeIndex
(
types
features
*
type
)
)
{
return
false
;
}
return
true
;
}
MOZ_MUST_USE
bool
readRefType
(
uint32_t
numTypes
const
FeatureArgs
&
features
RefType
*
type
)
{
ValType
valType
;
if
(
!
readValType
(
numTypes
features
&
valType
)
)
{
return
false
;
}
if
(
!
valType
.
isReference
(
)
)
{
return
fail
(
"
bad
type
"
)
;
}
*
type
=
valType
.
refType
(
)
;
return
true
;
}
MOZ_MUST_USE
bool
readRefType
(
const
TypeDefVector
&
types
const
FeatureArgs
&
features
RefType
*
type
)
{
ValType
valType
;
if
(
!
readValType
(
types
features
&
valType
)
)
{
return
false
;
}
if
(
!
valType
.
isReference
(
)
)
{
return
fail
(
"
bad
type
"
)
;
}
*
type
=
valType
.
refType
(
)
;
return
true
;
}
MOZ_MUST_USE
bool
validateTypeIndex
(
const
TypeDefVector
&
types
const
FeatureArgs
&
features
RefType
type
)
{
MOZ_ASSERT
(
type
.
isTypeIndex
(
)
)
;
if
(
features
.
gcTypes
&
&
types
[
type
.
typeIndex
(
)
]
.
isStructType
(
)
)
{
return
true
;
}
return
fail
(
"
type
index
references
an
invalid
type
"
)
;
}
MOZ_MUST_USE
bool
readOp
(
OpBytes
*
op
)
{
static_assert
(
size_t
(
Op
:
:
Limit
)
=
=
256
"
fits
"
)
;
uint8_t
u8
;
if
(
!
readFixedU8
(
&
u8
)
)
{
return
false
;
}
op
-
>
b0
=
u8
;
if
(
MOZ_LIKELY
(
!
IsPrefixByte
(
u8
)
)
)
{
return
true
;
}
if
(
!
readVarU32
(
&
op
-
>
b1
)
)
{
return
false
;
}
return
true
;
}
MOZ_MUST_USE
bool
readBytes
(
uint32_t
numBytes
const
uint8_t
*
*
bytes
=
nullptr
)
{
if
(
bytes
)
{
*
bytes
=
cur_
;
}
if
(
bytesRemain
(
)
<
numBytes
)
{
return
false
;
}
cur_
+
=
numBytes
;
return
true
;
}
MOZ_MUST_USE
bool
readSectionHeader
(
uint8_t
*
id
SectionRange
*
range
)
;
MOZ_MUST_USE
bool
startSection
(
SectionId
id
ModuleEnvironment
*
env
MaybeSectionRange
*
range
const
char
*
sectionName
)
;
MOZ_MUST_USE
bool
finishSection
(
const
SectionRange
&
range
const
char
*
sectionName
)
;
MOZ_MUST_USE
bool
startCustomSection
(
const
char
*
expected
size_t
expectedLength
ModuleEnvironment
*
env
MaybeSectionRange
*
range
)
;
template
<
size_t
NameSizeWith0
>
MOZ_MUST_USE
bool
startCustomSection
(
const
char
(
&
name
)
[
NameSizeWith0
]
ModuleEnvironment
*
env
MaybeSectionRange
*
range
)
{
MOZ_ASSERT
(
name
[
NameSizeWith0
-
1
]
=
=
'
\
0
'
)
;
return
startCustomSection
(
name
NameSizeWith0
-
1
env
range
)
;
}
void
finishCustomSection
(
const
char
*
name
const
SectionRange
&
range
)
;
void
skipAndFinishCustomSection
(
const
SectionRange
&
range
)
;
MOZ_MUST_USE
bool
skipCustomSection
(
ModuleEnvironment
*
env
)
;
MOZ_MUST_USE
bool
startNameSubsection
(
NameType
nameType
Maybe
<
uint32_t
>
*
endOffset
)
;
MOZ_MUST_USE
bool
finishNameSubsection
(
uint32_t
endOffset
)
;
MOZ_MUST_USE
bool
skipNameSubsection
(
)
;
uint8_t
uncheckedReadFixedU8
(
)
{
return
uncheckedRead
<
uint8_t
>
(
)
;
}
uint32_t
uncheckedReadFixedU32
(
)
{
return
uncheckedRead
<
uint32_t
>
(
)
;
}
void
uncheckedReadFixedF32
(
float
*
out
)
{
uncheckedRead
<
float
>
(
out
)
;
}
void
uncheckedReadFixedF64
(
double
*
out
)
{
uncheckedRead
<
double
>
(
out
)
;
}
template
<
typename
UInt
>
UInt
uncheckedReadVarU
(
)
{
static
const
unsigned
numBits
=
sizeof
(
UInt
)
*
CHAR_BIT
;
static
const
unsigned
remainderBits
=
numBits
%
7
;
static
const
unsigned
numBitsInSevens
=
numBits
-
remainderBits
;
UInt
decoded
=
0
;
uint32_t
shift
=
0
;
do
{
uint8_t
byte
=
*
cur_
+
+
;
if
(
!
(
byte
&
0x80
)
)
{
return
decoded
|
(
UInt
(
byte
)
<
<
shift
)
;
}
decoded
|
=
UInt
(
byte
&
0x7f
)
<
<
shift
;
shift
+
=
7
;
}
while
(
shift
!
=
numBitsInSevens
)
;
uint8_t
byte
=
*
cur_
+
+
;
MOZ_ASSERT
(
!
(
byte
&
0xf0
)
)
;
return
decoded
|
(
UInt
(
byte
)
<
<
numBitsInSevens
)
;
}
uint32_t
uncheckedReadVarU32
(
)
{
return
uncheckedReadVarU
<
uint32_t
>
(
)
;
}
int32_t
uncheckedReadVarS32
(
)
{
int32_t
i32
=
0
;
MOZ_ALWAYS_TRUE
(
readVarS32
(
&
i32
)
)
;
return
i32
;
}
uint64_t
uncheckedReadVarU64
(
)
{
return
uncheckedReadVarU
<
uint64_t
>
(
)
;
}
int64_t
uncheckedReadVarS64
(
)
{
int64_t
i64
=
0
;
MOZ_ALWAYS_TRUE
(
readVarS64
(
&
i64
)
)
;
return
i64
;
}
Op
uncheckedReadOp
(
)
{
static_assert
(
size_t
(
Op
:
:
Limit
)
=
=
256
"
fits
"
)
;
uint8_t
u8
=
uncheckedReadFixedU8
(
)
;
return
u8
!
=
UINT8_MAX
?
Op
(
u8
)
:
Op
(
uncheckedReadFixedU8
(
)
+
UINT8_MAX
)
;
}
}
;
MOZ_MUST_USE
bool
EncodeLocalEntries
(
Encoder
&
d
const
ValTypeVector
&
locals
)
;
MOZ_MUST_USE
bool
DecodeValidatedLocalEntries
(
Decoder
&
d
ValTypeVector
*
locals
)
;
MOZ_MUST_USE
bool
DecodeLocalEntries
(
Decoder
&
d
const
TypeDefVector
&
types
const
FeatureArgs
&
features
ValTypeVector
*
locals
)
;
MOZ_MUST_USE
bool
StartsCodeSection
(
const
uint8_t
*
begin
const
uint8_t
*
end
SectionRange
*
range
)
;
MOZ_MUST_USE
bool
DecodeModuleEnvironment
(
Decoder
&
d
ModuleEnvironment
*
env
)
;
MOZ_MUST_USE
bool
ValidateFunctionBody
(
const
ModuleEnvironment
&
env
uint32_t
funcIndex
uint32_t
bodySize
Decoder
&
d
)
;
MOZ_MUST_USE
bool
DecodeModuleTail
(
Decoder
&
d
ModuleEnvironment
*
env
)
;
void
ConvertMemoryPagesToBytes
(
Limits
*
memory
)
;
MOZ_MUST_USE
bool
Validate
(
JSContext
*
cx
const
ShareableBytes
&
bytecode
UniqueChars
*
error
)
;
}
}
#
endif
