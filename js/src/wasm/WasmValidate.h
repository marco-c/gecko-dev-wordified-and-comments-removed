#
ifndef
wasm_validate_h
#
define
wasm_validate_h
#
include
<
type_traits
>
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
WasmFeatures
.
h
"
#
include
"
wasm
/
WasmBinary
.
h
"
#
include
"
wasm
/
WasmCompile
.
h
"
#
include
"
wasm
/
WasmCompileArgs
.
h
"
#
include
"
wasm
/
WasmModuleTypes
.
h
"
#
include
"
wasm
/
WasmProcess
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
namespace
js
{
namespace
wasm
{
using
mozilla
:
:
Some
;
struct
ModuleMetadata
{
const
ModuleKind
kind
;
const
FeatureArgs
features
;
Maybe
<
uint32_t
>
dataCount
;
MemoryDescVector
memories
;
MutableTypeContext
types
;
FuncDescVector
funcs
;
BranchHintCollection
branchHints
;
uint32_t
numFuncImports
;
uint32_t
numGlobalImports
;
GlobalDescVector
globals
;
TagDescVector
tags
;
TableDescVector
tables
;
Uint32Vector
asmJSSigToTableIndex
;
ImportVector
imports
;
ExportVector
exports
;
Maybe
<
uint32_t
>
startFuncIndex
;
ModuleElemSegmentVector
elemSegments
;
MaybeSectionRange
codeSection
;
uint32_t
funcImportsOffsetStart
;
uint32_t
typeDefsOffsetStart
;
uint32_t
memoriesOffsetStart
;
uint32_t
tablesOffsetStart
;
uint32_t
tagsOffsetStart
;
DataSegmentEnvVector
dataSegments
;
CustomSectionEnvVector
customSections
;
Maybe
<
uint32_t
>
nameCustomSectionIndex
;
Maybe
<
Name
>
moduleName
;
NameVector
funcNames
;
bool
parsedBranchHints
;
explicit
ModuleMetadata
(
FeatureArgs
features
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind
(
kind
)
features
(
features
)
numFuncImports
(
0
)
numGlobalImports
(
0
)
funcImportsOffsetStart
(
UINT32_MAX
)
typeDefsOffsetStart
(
UINT32_MAX
)
memoriesOffsetStart
(
UINT32_MAX
)
tablesOffsetStart
(
UINT32_MAX
)
tagsOffsetStart
(
UINT32_MAX
)
parsedBranchHints
(
false
)
{
}
[
[
nodiscard
]
]
bool
init
(
)
{
types
=
js_new
<
TypeContext
>
(
features
)
;
return
types
;
}
size_t
numTables
(
)
const
{
return
tables
.
length
(
)
;
}
size_t
numTypes
(
)
const
{
return
types
-
>
length
(
)
;
}
size_t
numFuncs
(
)
const
{
return
funcs
.
length
(
)
;
}
size_t
numFuncDefs
(
)
const
{
return
funcs
.
length
(
)
-
numFuncImports
;
}
bool
funcIsImport
(
uint32_t
funcIndex
)
const
{
return
funcIndex
<
numFuncImports
;
}
size_t
numMemories
(
)
const
{
return
memories
.
length
(
)
;
}
#
define
WASM_FEATURE
(
NAME
SHORT_NAME
.
.
.
)
\
bool
SHORT_NAME
#
#
Enabled
(
)
const
{
return
features
.
SHORT_NAME
;
}
JS_FOR_WASM_FEATURES
(
WASM_FEATURE
)
#
undef
WASM_FEATURE
Shareable
sharedMemoryEnabled
(
)
const
{
return
features
.
sharedMemory
;
}
bool
simdAvailable
(
)
const
{
return
features
.
simd
;
}
bool
isAsmJS
(
)
const
{
return
kind
=
=
ModuleKind
:
:
AsmJS
;
}
bool
isBuiltinModule
(
)
const
{
return
features
.
isBuiltinModule
;
}
bool
hugeMemoryEnabled
(
uint32_t
memoryIndex
)
const
{
return
!
isAsmJS
(
)
&
&
memoryIndex
<
memories
.
length
(
)
&
&
IsHugeMemoryEnabled
(
memories
[
memoryIndex
]
.
indexType
(
)
)
;
}
bool
usesSharedMemory
(
uint32_t
memoryIndex
)
const
{
return
memoryIndex
<
memories
.
length
(
)
&
&
memories
[
memoryIndex
]
.
isShared
(
)
;
}
void
declareFuncExported
(
uint32_t
funcIndex
bool
eager
bool
canRefFunc
)
{
FuncFlags
flags
=
funcs
[
funcIndex
]
.
flags
;
flags
=
FuncFlags
(
uint8_t
(
flags
)
|
uint8_t
(
FuncFlags
:
:
Exported
)
)
;
if
(
eager
)
{
flags
=
FuncFlags
(
uint8_t
(
flags
)
|
uint8_t
(
FuncFlags
:
:
Eager
)
)
;
}
if
(
canRefFunc
)
{
flags
=
FuncFlags
(
uint8_t
(
flags
)
|
uint8_t
(
FuncFlags
:
:
CanRefFunc
)
)
;
}
funcs
[
funcIndex
]
.
flags
=
flags
;
}
uint32_t
offsetOfFuncImportInstanceData
(
uint32_t
funcIndex
)
const
{
MOZ_ASSERT
(
funcIndex
<
numFuncImports
)
;
return
funcImportsOffsetStart
+
funcIndex
*
sizeof
(
FuncImportInstanceData
)
;
}
uint32_t
offsetOfTypeDefInstanceData
(
uint32_t
typeIndex
)
const
{
MOZ_ASSERT
(
typeIndex
<
types
-
>
length
(
)
)
;
return
typeDefsOffsetStart
+
typeIndex
*
sizeof
(
TypeDefInstanceData
)
;
}
uint32_t
offsetOfTypeDef
(
uint32_t
typeIndex
)
const
{
return
offsetOfTypeDefInstanceData
(
typeIndex
)
+
offsetof
(
TypeDefInstanceData
typeDef
)
;
}
uint32_t
offsetOfSuperTypeVector
(
uint32_t
typeIndex
)
const
{
return
offsetOfTypeDefInstanceData
(
typeIndex
)
+
offsetof
(
TypeDefInstanceData
superTypeVector
)
;
}
uint32_t
offsetOfMemoryInstanceData
(
uint32_t
memoryIndex
)
const
{
MOZ_ASSERT
(
memoryIndex
<
memories
.
length
(
)
)
;
return
memoriesOffsetStart
+
memoryIndex
*
sizeof
(
MemoryInstanceData
)
;
}
uint32_t
offsetOfTableInstanceData
(
uint32_t
tableIndex
)
const
{
MOZ_ASSERT
(
tableIndex
<
tables
.
length
(
)
)
;
return
tablesOffsetStart
+
tableIndex
*
sizeof
(
TableInstanceData
)
;
}
uint32_t
offsetOfTagInstanceData
(
uint32_t
tagIndex
)
const
{
MOZ_ASSERT
(
tagIndex
<
tags
.
length
(
)
)
;
return
tagsOffsetStart
+
tagIndex
*
sizeof
(
TagInstanceData
)
;
}
bool
addDefinedFunc
(
ValTypeVector
&
&
params
ValTypeVector
&
&
results
bool
declareForRef
=
false
Maybe
<
CacheableName
>
&
&
optionalExportedName
=
mozilla
:
:
Nothing
(
)
)
;
bool
addImportedFunc
(
ValTypeVector
&
&
params
ValTypeVector
&
&
results
CacheableName
&
&
importModName
CacheableName
&
&
importFieldName
)
;
}
;
class
ElemSegmentFlags
{
enum
class
Flags
:
uint32_t
{
Passive
=
0x1
TableIndexOrDeclared
=
0x2
ElemExpressions
=
0x4
KindMask
=
Passive
|
TableIndexOrDeclared
PayloadMask
=
ElemExpressions
AllFlags
=
Passive
|
TableIndexOrDeclared
|
ElemExpressions
}
;
uint32_t
encoded_
;
explicit
ElemSegmentFlags
(
uint32_t
encoded
)
:
encoded_
(
encoded
)
{
}
public
:
ElemSegmentFlags
(
ElemSegmentKind
kind
ElemSegmentPayload
payload
)
{
encoded_
=
uint32_t
(
kind
)
|
uint32_t
(
payload
)
;
}
static
Maybe
<
ElemSegmentFlags
>
construct
(
uint32_t
encoded
)
{
if
(
encoded
>
uint32_t
(
Flags
:
:
AllFlags
)
)
{
return
Nothing
(
)
;
}
return
Some
(
ElemSegmentFlags
(
encoded
)
)
;
}
uint32_t
encoded
(
)
const
{
return
encoded_
;
}
ElemSegmentKind
kind
(
)
const
{
return
static_cast
<
ElemSegmentKind
>
(
encoded_
&
uint32_t
(
Flags
:
:
KindMask
)
)
;
}
ElemSegmentPayload
payload
(
)
const
{
return
static_cast
<
ElemSegmentPayload
>
(
encoded_
&
uint32_t
(
Flags
:
:
PayloadMask
)
)
;
}
}
;
class
NothingVector
{
Nothing
unused_
;
public
:
bool
reserve
(
size_t
size
)
{
return
true
;
}
bool
resize
(
size_t
length
)
{
return
true
;
}
Nothing
&
operator
[
]
(
size_t
)
{
return
unused_
;
}
Nothing
&
back
(
)
{
return
unused_
;
}
size_t
length
(
)
const
{
return
0
;
}
bool
append
(
Nothing
&
nothing
)
{
return
true
;
}
void
infallibleAppend
(
Nothing
&
nothing
)
{
}
}
;
struct
ValidatingPolicy
{
using
Value
=
Nothing
;
using
ValueVector
=
NothingVector
;
using
ControlItem
=
Nothing
;
}
;
template
<
typename
Policy
>
class
OpIter
;
using
ValidatingOpIter
=
OpIter
<
ValidatingPolicy
>
;
[
[
nodiscard
]
]
bool
CheckIsSubtypeOf
(
Decoder
&
d
const
ModuleMetadata
&
moduleMeta
size_t
opcodeOffset
StorageType
subType
StorageType
superType
)
;
[
[
nodiscard
]
]
bool
EncodeLocalEntries
(
Encoder
&
e
const
ValTypeVector
&
locals
)
;
[
[
nodiscard
]
]
bool
DecodeValidatedLocalEntries
(
const
TypeContext
&
types
Decoder
&
d
ValTypeVector
*
locals
)
;
[
[
nodiscard
]
]
bool
DecodeLocalEntriesWithParams
(
Decoder
&
d
const
ModuleMetadata
&
moduleMeta
uint32_t
funcIndex
ValTypeVector
*
locals
)
;
[
[
nodiscard
]
]
bool
StartsCodeSection
(
const
uint8_t
*
begin
const
uint8_t
*
end
SectionRange
*
codeSection
)
;
[
[
nodiscard
]
]
bool
DecodeModuleEnvironment
(
Decoder
&
d
ModuleMetadata
*
moduleMeta
)
;
[
[
nodiscard
]
]
bool
ValidateFunctionBody
(
const
ModuleMetadata
&
moduleMeta
uint32_t
funcIndex
uint32_t
bodySize
Decoder
&
d
)
;
[
[
nodiscard
]
]
bool
DecodeModuleTail
(
Decoder
&
d
ModuleMetadata
*
moduleMeta
)
;
[
[
nodiscard
]
]
bool
Validate
(
JSContext
*
cx
const
ShareableBytes
&
bytecode
const
FeatureOptions
&
options
UniqueChars
*
error
)
;
}
}
#
endif
