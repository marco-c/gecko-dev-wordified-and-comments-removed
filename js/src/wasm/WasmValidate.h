#
ifndef
wasm_validate_h
#
define
wasm_validate_h
#
include
<
type_traits
>
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
WasmFeatures
.
h
"
#
include
"
wasm
/
WasmBinary
.
h
"
#
include
"
wasm
/
WasmCompile
.
h
"
#
include
"
wasm
/
WasmCompileArgs
.
h
"
#
include
"
wasm
/
WasmModuleTypes
.
h
"
#
include
"
wasm
/
WasmProcess
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
namespace
js
{
namespace
wasm
{
class
ElemSegmentFlags
{
enum
class
Flags
:
uint32_t
{
Passive
=
0x1
TableIndexOrDeclared
=
0x2
ElemExpressions
=
0x4
KindMask
=
Passive
|
TableIndexOrDeclared
PayloadMask
=
ElemExpressions
AllFlags
=
Passive
|
TableIndexOrDeclared
|
ElemExpressions
}
;
uint32_t
encoded_
;
explicit
ElemSegmentFlags
(
uint32_t
encoded
)
:
encoded_
(
encoded
)
{
}
public
:
ElemSegmentFlags
(
ElemSegmentKind
kind
ElemSegmentPayload
payload
)
{
encoded_
=
uint32_t
(
kind
)
|
uint32_t
(
payload
)
;
}
static
Maybe
<
ElemSegmentFlags
>
construct
(
uint32_t
encoded
)
{
if
(
encoded
>
uint32_t
(
Flags
:
:
AllFlags
)
)
{
return
Nothing
(
)
;
}
return
Some
(
ElemSegmentFlags
(
encoded
)
)
;
}
uint32_t
encoded
(
)
const
{
return
encoded_
;
}
ElemSegmentKind
kind
(
)
const
{
return
static_cast
<
ElemSegmentKind
>
(
encoded_
&
uint32_t
(
Flags
:
:
KindMask
)
)
;
}
ElemSegmentPayload
payload
(
)
const
{
return
static_cast
<
ElemSegmentPayload
>
(
encoded_
&
uint32_t
(
Flags
:
:
PayloadMask
)
)
;
}
}
;
class
NothingVector
{
Nothing
unused_
;
public
:
bool
reserve
(
size_t
size
)
{
return
true
;
}
bool
resize
(
size_t
length
)
{
return
true
;
}
Nothing
&
operator
[
]
(
size_t
)
{
return
unused_
;
}
Nothing
&
back
(
)
{
return
unused_
;
}
size_t
length
(
)
const
{
return
0
;
}
bool
append
(
Nothing
&
nothing
)
{
return
true
;
}
void
infallibleAppend
(
Nothing
&
nothing
)
{
}
}
;
struct
ValidatingPolicy
{
using
Value
=
Nothing
;
using
ValueVector
=
NothingVector
;
using
ControlItem
=
Nothing
;
}
;
template
<
typename
Policy
>
class
OpIter
;
using
ValidatingOpIter
=
OpIter
<
ValidatingPolicy
>
;
[
[
nodiscard
]
]
bool
CheckIsSubtypeOf
(
Decoder
&
d
const
CodeMetadata
&
codeMeta
size_t
opcodeOffset
StorageType
subType
StorageType
superType
)
;
[
[
nodiscard
]
]
bool
EncodeLocalEntries
(
Encoder
&
e
const
ValTypeVector
&
locals
)
;
[
[
nodiscard
]
]
bool
DecodeValidatedLocalEntries
(
const
TypeContext
&
types
Decoder
&
d
ValTypeVector
*
locals
)
;
[
[
nodiscard
]
]
bool
DecodeLocalEntriesWithParams
(
Decoder
&
d
const
CodeMetadata
&
codeMeta
uint32_t
funcIndex
ValTypeVector
*
locals
)
;
[
[
nodiscard
]
]
bool
StartsCodeSection
(
const
uint8_t
*
begin
const
uint8_t
*
end
SectionRange
*
codeSection
)
;
[
[
nodiscard
]
]
bool
DecodeModuleEnvironment
(
Decoder
&
d
CodeMetadata
*
codeMeta
ModuleMetadata
*
moduleMeta
)
;
[
[
nodiscard
]
]
bool
ValidateFunctionBody
(
const
CodeMetadata
&
codeMeta
uint32_t
funcIndex
uint32_t
bodySize
Decoder
&
d
)
;
[
[
nodiscard
]
]
bool
DecodeModuleTail
(
Decoder
&
d
CodeMetadata
*
codeMeta
ModuleMetadata
*
meta
)
;
[
[
nodiscard
]
]
bool
Validate
(
JSContext
*
cx
const
ShareableBytes
&
bytecode
const
FeatureOptions
&
options
UniqueChars
*
error
)
;
}
}
#
endif
