#
ifndef
wasm_validate_h
#
define
wasm_validate_h
#
include
<
type_traits
>
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
WasmFeatures
.
h
"
#
include
"
wasm
/
WasmBinary
.
h
"
#
include
"
wasm
/
WasmCompile
.
h
"
#
include
"
wasm
/
WasmCompileArgs
.
h
"
#
include
"
wasm
/
WasmModuleTypes
.
h
"
#
include
"
wasm
/
WasmOpIter
.
h
"
#
include
"
wasm
/
WasmProcess
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
namespace
js
{
namespace
wasm
{
class
ElemSegmentFlags
{
enum
class
Flags
:
uint32_t
{
Passive
=
0x1
TableIndexOrDeclared
=
0x2
ElemExpressions
=
0x4
KindMask
=
Passive
|
TableIndexOrDeclared
PayloadMask
=
ElemExpressions
AllFlags
=
Passive
|
TableIndexOrDeclared
|
ElemExpressions
}
;
uint32_t
encoded_
;
explicit
ElemSegmentFlags
(
uint32_t
encoded
)
:
encoded_
(
encoded
)
{
}
public
:
ElemSegmentFlags
(
ElemSegmentKind
kind
ElemSegmentPayload
payload
)
{
encoded_
=
uint32_t
(
kind
)
|
uint32_t
(
payload
)
;
}
static
mozilla
:
:
Maybe
<
ElemSegmentFlags
>
construct
(
uint32_t
encoded
)
{
if
(
encoded
>
uint32_t
(
Flags
:
:
AllFlags
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
return
mozilla
:
:
Some
(
ElemSegmentFlags
(
encoded
)
)
;
}
uint32_t
encoded
(
)
const
{
return
encoded_
;
}
ElemSegmentKind
kind
(
)
const
{
return
static_cast
<
ElemSegmentKind
>
(
encoded_
&
uint32_t
(
Flags
:
:
KindMask
)
)
;
}
ElemSegmentPayload
payload
(
)
const
{
return
static_cast
<
ElemSegmentPayload
>
(
encoded_
&
uint32_t
(
Flags
:
:
PayloadMask
)
)
;
}
}
;
class
NothingVector
{
mozilla
:
:
Nothing
unused_
;
public
:
bool
reserve
(
size_t
size
)
{
return
true
;
}
bool
resize
(
size_t
length
)
{
return
true
;
}
mozilla
:
:
Nothing
&
operator
[
]
(
size_t
)
{
return
unused_
;
}
mozilla
:
:
Nothing
&
back
(
)
{
return
unused_
;
}
size_t
length
(
)
const
{
return
0
;
}
bool
append
(
mozilla
:
:
Nothing
&
nothing
)
{
return
true
;
}
void
infallibleAppend
(
mozilla
:
:
Nothing
&
nothing
)
{
}
}
;
struct
ValidatingPolicy
{
using
Value
=
mozilla
:
:
Nothing
;
using
ValueVector
=
NothingVector
;
using
ControlItem
=
mozilla
:
:
Nothing
;
}
;
template
<
typename
Policy
>
class
OpIter
;
using
ValidatingOpIter
=
OpIter
<
ValidatingPolicy
>
;
[
[
nodiscard
]
]
bool
CheckIsSubtypeOf
(
Decoder
&
d
const
CodeMetadata
&
codeMeta
size_t
opcodeOffset
ResultType
subType
ResultType
superType
)
;
[
[
nodiscard
]
]
bool
CheckIsSubtypeOf
(
Decoder
&
d
const
CodeMetadata
&
codeMeta
size_t
opcodeOffset
StorageType
subType
StorageType
superType
)
;
[
[
nodiscard
]
]
bool
EncodeLocalEntries
(
Encoder
&
e
const
ValTypeVector
&
locals
)
;
[
[
nodiscard
]
]
bool
DecodeValidatedLocalEntries
(
const
TypeContext
&
types
Decoder
&
d
ValTypeVector
*
locals
)
;
[
[
nodiscard
]
]
bool
DecodeLocalEntriesWithParams
(
Decoder
&
d
const
CodeMetadata
&
codeMeta
uint32_t
funcIndex
ValTypeVector
*
locals
)
;
[
[
nodiscard
]
]
bool
StartsCodeSection
(
const
uint8_t
*
begin
const
uint8_t
*
end
BytecodeRange
*
codeSection
)
;
[
[
nodiscard
]
]
bool
DecodeModuleEnvironment
(
Decoder
&
d
CodeMetadata
*
codeMeta
ModuleMetadata
*
moduleMeta
)
;
[
[
nodiscard
]
]
bool
ValidateFunctionBody
(
const
CodeMetadata
&
codeMeta
uint32_t
funcIndex
uint32_t
bodySize
Decoder
&
d
)
;
[
[
nodiscard
]
]
bool
DecodeModuleTail
(
Decoder
&
d
CodeMetadata
*
codeMeta
ModuleMetadata
*
meta
)
;
[
[
nodiscard
]
]
bool
Validate
(
JSContext
*
cx
const
ShareableBytes
&
bytecode
const
FeatureOptions
&
options
UniqueChars
*
error
)
;
struct
BaseOpDumper
{
virtual
void
dumpOpBegin
(
OpBytes
op
)
{
}
virtual
void
dumpOpEnd
(
)
{
}
virtual
void
dumpTypeIndex
(
uint32_t
typeIndex
bool
asTypeUse
=
false
)
{
}
virtual
void
dumpFuncIndex
(
uint32_t
funcIndex
)
{
}
virtual
void
dumpTableIndex
(
uint32_t
tableIndex
)
{
}
virtual
void
dumpGlobalIndex
(
uint32_t
globalIndex
)
{
}
virtual
void
dumpMemoryIndex
(
uint32_t
memoryIndex
)
{
}
virtual
void
dumpElemIndex
(
uint32_t
elemIndex
)
{
}
virtual
void
dumpDataIndex
(
uint32_t
dataIndex
)
{
}
virtual
void
dumpTagIndex
(
uint32_t
tagIndex
)
{
}
virtual
void
dumpLocalIndex
(
uint32_t
localIndex
)
{
}
virtual
void
dumpBlockType
(
BlockType
type
)
{
}
virtual
void
dumpI32Const
(
int32_t
constant
)
{
}
virtual
void
dumpI64Const
(
int64_t
constant
)
{
}
virtual
void
dumpF32Const
(
float
constant
)
{
}
virtual
void
dumpF64Const
(
double
constant
)
{
}
virtual
void
dumpV128Const
(
V128
constant
)
{
}
virtual
void
dumpVectorMask
(
V128
mask
)
{
}
virtual
void
dumpRefType
(
RefType
type
)
{
}
virtual
void
dumpHeapType
(
RefType
type
)
{
}
virtual
void
dumpValType
(
ValType
type
)
{
}
virtual
void
dumpTryTableCatches
(
const
TryTableCatchVector
&
catches
)
{
}
virtual
void
dumpLinearMemoryAddress
(
LinearMemoryAddress
<
mozilla
:
:
Nothing
>
addr
)
{
}
virtual
void
dumpBlockDepth
(
uint32_t
relativeDepth
)
{
}
virtual
void
dumpBlockDepths
(
const
Uint32Vector
&
relativeDepths
)
{
}
virtual
void
dumpFieldIndex
(
uint32_t
fieldIndex
)
{
}
virtual
void
dumpNumElements
(
uint32_t
numElements
)
{
}
virtual
void
dumpLaneIndex
(
uint32_t
laneIndex
)
{
}
virtual
void
startScope
(
)
{
}
;
virtual
void
endScope
(
)
{
}
;
}
;
[
[
nodiscard
]
]
bool
ValidateOps
(
ValidatingOpIter
&
iter
BaseOpDumper
&
dumper
const
CodeMetadata
&
codeMeta
)
;
}
}
#
endif
