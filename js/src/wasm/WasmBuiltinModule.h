#
ifndef
wasm_builtin_module_h
#
define
wasm_builtin_module_h
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
wasm
/
WasmBuiltins
.
h
"
#
include
"
wasm
/
WasmCompileArgs
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
#
include
"
wasm
/
WasmTypeDecls
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
namespace
js
{
namespace
wasm
{
struct
MOZ_STACK_CLASS
BuiltinModuleInstances
{
explicit
BuiltinModuleInstances
(
JSContext
*
cx
)
:
selfTest
(
cx
)
intGemm
(
cx
)
jsString
(
cx
)
{
}
Rooted
<
JSObject
*
>
selfTest
;
Rooted
<
JSObject
*
>
intGemm
;
Rooted
<
JSObject
*
>
jsString
;
MutableHandle
<
JSObject
*
>
operator
[
]
(
BuiltinModuleId
module
)
{
switch
(
module
)
{
case
BuiltinModuleId
:
:
SelfTest
:
{
return
&
selfTest
;
}
case
BuiltinModuleId
:
:
IntGemm
:
{
return
&
intGemm
;
}
case
BuiltinModuleId
:
:
JSString
:
{
return
&
jsString
;
}
default
:
{
MOZ_CRASH
(
)
;
}
}
}
}
;
class
BuiltinModuleFunc
{
private
:
SharedRecGroup
recGroup_
;
const
char
*
exportName_
;
const
SymbolicAddressSignature
*
sig_
;
bool
usesMemory_
;
BuiltinInlineOp
inlineOp_
;
public
:
BuiltinModuleFunc
(
)
=
default
;
[
[
nodiscard
]
]
bool
init
(
const
RefPtr
<
TypeContext
>
&
types
mozilla
:
:
Span
<
const
ValType
>
params
mozilla
:
:
Maybe
<
ValType
>
result
bool
usesMemory
const
SymbolicAddressSignature
*
sig
BuiltinInlineOp
inlineOp
const
char
*
exportName
)
;
const
RecGroup
*
recGroup
(
)
const
{
return
recGroup_
.
get
(
)
;
}
const
TypeDef
*
typeDef
(
)
const
{
return
&
recGroup_
-
>
type
(
0
)
;
}
const
FuncType
*
funcType
(
)
const
{
return
&
typeDef
(
)
-
>
funcType
(
)
;
}
const
char
*
exportName
(
)
const
{
return
exportName_
;
}
const
SymbolicAddressSignature
*
sig
(
)
const
{
return
sig_
;
}
bool
usesMemory
(
)
const
{
return
usesMemory_
;
}
BuiltinInlineOp
inlineOp
(
)
const
{
return
inlineOp_
;
}
}
;
class
BuiltinModuleFuncs
{
using
Storage
=
mozilla
:
:
EnumeratedArray
<
BuiltinModuleFuncId
BuiltinModuleFunc
size_t
(
BuiltinModuleFuncId
:
:
Limit
)
>
;
Storage
funcs_
;
static
BuiltinModuleFuncs
*
singleton_
;
public
:
[
[
nodiscard
]
]
static
bool
init
(
)
;
static
void
destroy
(
)
;
static
const
BuiltinModuleFunc
&
getFromId
(
BuiltinModuleFuncId
id
)
{
return
singleton_
-
>
funcs_
[
id
]
;
}
}
;
mozilla
:
:
Maybe
<
BuiltinModuleId
>
ImportMatchesBuiltinModule
(
mozilla
:
:
Span
<
const
char
>
importName
BuiltinModuleIds
enabledBuiltins
)
;
bool
ImportMatchesBuiltinModuleFunc
(
mozilla
:
:
Span
<
const
char
>
importName
BuiltinModuleId
module
const
BuiltinModuleFunc
*
*
matchedFunc
BuiltinModuleFuncId
*
matchedFuncId
)
;
[
[
nodiscard
]
]
bool
CompileBuiltinModule
(
JSContext
*
cx
BuiltinModuleId
module
MutableHandle
<
WasmModuleObject
*
>
result
)
;
[
[
nodiscard
]
]
bool
InstantiateBuiltinModule
(
JSContext
*
cx
BuiltinModuleId
module
MutableHandle
<
JSObject
*
>
result
)
;
}
}
#
endif
