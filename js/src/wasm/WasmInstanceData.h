#
ifndef
wasm_instance_data_h
#
define
wasm_instance_data_h
#
include
<
stdint
.
h
>
#
include
"
NamespaceImports
.
h
"
#
include
"
gc
/
Pretenuring
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
wasm
/
WasmInstance
.
h
"
#
include
"
wasm
/
WasmMemory
.
h
"
#
include
"
wasm
/
WasmTypeDecls
.
h
"
namespace
js
{
namespace
wasm
{
struct
ExportArg
{
uint64_t
lo
;
uint64_t
hi
;
}
;
using
ExportFuncPtr
=
int32_t
(
*
)
(
ExportArg
*
Instance
*
)
;
struct
TypeDefInstanceData
{
TypeDefInstanceData
(
)
:
typeDef
(
nullptr
)
superTypeVector
(
nullptr
)
shape
(
nullptr
)
clasp
(
nullptr
)
allocKind
(
gc
:
:
AllocKind
:
:
LIMIT
)
unused
(
0
)
{
}
const
wasm
:
:
TypeDef
*
typeDef
;
const
wasm
:
:
SuperTypeVector
*
superTypeVector
;
GCPtr
<
Shape
*
>
shape
;
const
JSClass
*
clasp
;
gc
:
:
AllocKind
allocKind
;
union
{
uint32_t
structTypeSize
;
uint32_t
arrayElemSize
;
uint32_t
unused
;
}
;
static
constexpr
size_t
offsetOfShape
(
)
{
return
offsetof
(
TypeDefInstanceData
shape
)
;
}
static
constexpr
size_t
offsetOfSuperTypeVector
(
)
{
return
offsetof
(
TypeDefInstanceData
superTypeVector
)
;
}
static
constexpr
size_t
offsetOfArrayElemSize
(
)
{
return
offsetof
(
TypeDefInstanceData
arrayElemSize
)
;
}
}
;
struct
FuncDefInstanceData
{
int32_t
hotnessCounter
;
}
;
struct
FuncExportInstanceData
{
GCPtr
<
JSFunction
*
>
func
;
}
;
struct
FuncImportInstanceData
{
void
*
code
;
Instance
*
instance
;
JS
:
:
Realm
*
realm
;
GCPtr
<
JSObject
*
>
callable
;
static_assert
(
sizeof
(
GCPtr
<
JSObject
*
>
)
=
=
sizeof
(
void
*
)
"
for
JIT
access
"
)
;
bool
isFunctionCallBind
;
}
;
struct
MemoryInstanceData
{
GCPtr
<
WasmMemoryObject
*
>
memory
;
uint8_t
*
base
;
uintptr_t
boundsCheckLimit
;
bool
isShared
;
}
;
struct
TableInstanceData
{
uint64_t
length
;
void
*
elements
;
}
;
struct
TagInstanceData
{
GCPtr
<
WasmTagObject
*
>
object
;
}
;
struct
FunctionTableElem
{
void
*
code
;
Instance
*
instance
;
}
;
struct
CallRefMetrics
{
static
constexpr
size_t
NUM_SLOTS
=
3
;
static_assert
(
NUM_SLOTS
>
=
1
)
;
GCPtr
<
JSFunction
*
>
targets
[
NUM_SLOTS
]
;
uint32_t
counts
[
NUM_SLOTS
]
;
uint32_t
countOther
;
static_assert
(
sizeof
(
GCPtr
<
JSFunction
*
>
)
=
=
sizeof
(
void
*
)
)
;
static_assert
(
sizeof
(
uint32_t
)
=
=
4
)
;
CallRefMetrics
(
)
{
for
(
size_t
i
=
0
;
i
<
NUM_SLOTS
;
i
+
+
)
{
targets
[
i
]
=
nullptr
;
counts
[
i
]
=
0
;
}
countOther
=
0
;
MOZ_ASSERT
(
checkInvariants
(
)
)
;
}
[
[
nodiscard
]
]
bool
checkInvariants
(
)
const
{
size_t
i
;
for
(
i
=
0
;
i
<
NUM_SLOTS
;
i
+
+
)
{
if
(
targets
[
i
]
=
=
nullptr
&
&
counts
[
i
]
!
=
0
)
{
return
false
;
}
}
for
(
i
=
0
;
i
<
NUM_SLOTS
;
i
+
+
)
{
if
(
targets
[
i
]
=
=
nullptr
)
{
break
;
}
}
size_t
numUsed
=
i
;
for
(
;
i
<
NUM_SLOTS
;
i
+
+
)
{
if
(
targets
[
i
]
!
=
nullptr
)
{
return
false
;
}
}
for
(
i
=
0
;
i
<
numUsed
;
i
+
+
)
{
for
(
size_t
j
=
i
+
1
;
j
<
numUsed
;
j
+
+
)
{
if
(
targets
[
j
]
=
=
targets
[
i
]
)
{
return
false
;
}
}
}
return
true
;
}
static
size_t
offsetOfTarget
(
size_t
n
)
{
MOZ_ASSERT
(
n
<
NUM_SLOTS
)
;
return
offsetof
(
CallRefMetrics
targets
)
+
n
*
sizeof
(
GCPtr
<
JSFunction
*
>
)
;
}
static
size_t
offsetOfCount
(
size_t
n
)
{
MOZ_ASSERT
(
n
<
NUM_SLOTS
)
;
return
offsetof
(
CallRefMetrics
counts
)
+
n
*
sizeof
(
uint32_t
)
;
}
static
size_t
offsetOfCountOther
(
)
{
return
offsetof
(
CallRefMetrics
countOther
)
;
}
}
;
}
}
#
endif
