#
ifndef
wasm_code_h
#
define
wasm_code_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
utility
>
#
include
"
jstypes
.
h
"
#
include
"
gc
/
Memory
.
h
"
#
include
"
jit
/
ProcessExecutableMemory
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
threading
/
ExclusiveData
.
h
"
#
include
"
util
/
Memory
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
#
include
"
wasm
/
AsmJS
.
h
"
#
include
"
wasm
/
WasmBuiltinModule
.
h
"
#
include
"
wasm
/
WasmBuiltins
.
h
"
#
include
"
wasm
/
WasmCodegenConstants
.
h
"
#
include
"
wasm
/
WasmCodegenTypes
.
h
"
#
include
"
wasm
/
WasmCompileArgs
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmExprType
.
h
"
#
include
"
wasm
/
WasmGC
.
h
"
#
include
"
wasm
/
WasmLog
.
h
"
#
include
"
wasm
/
WasmMetadata
.
h
"
#
include
"
wasm
/
WasmModuleTypes
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
#
include
"
wasm
/
WasmShareable
.
h
"
#
include
"
wasm
/
WasmTypeDecls
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
using
js
:
:
CodeMetadataForAsmJS
;
struct
JS_PUBLIC_API
JSContext
;
class
JSFunction
;
namespace
js
{
namespace
jit
{
class
MacroAssembler
;
}
;
namespace
wasm
{
struct
LinkDataCacheablePod
{
uint32_t
trapOffset
=
0
;
WASM_CHECK_CACHEABLE_POD
(
trapOffset
)
;
LinkDataCacheablePod
(
)
=
default
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
LinkDataCacheablePod
)
;
WASM_CHECK_CACHEABLE_POD_PADDING
(
LinkDataCacheablePod
)
struct
LinkData
:
LinkDataCacheablePod
{
explicit
LinkData
(
Tier
tier
)
:
tier
(
tier
)
{
}
LinkDataCacheablePod
&
pod
(
)
{
return
*
this
;
}
const
LinkDataCacheablePod
&
pod
(
)
const
{
return
*
this
;
}
struct
InternalLink
{
uint32_t
patchAtOffset
;
uint32_t
targetOffset
;
#
ifdef
JS_CODELABEL_LINKMODE
uint32_t
mode
;
#
endif
WASM_CHECK_CACHEABLE_POD
(
patchAtOffset
targetOffset
)
;
#
ifdef
JS_CODELABEL_LINKMODE
WASM_CHECK_CACHEABLE_POD
(
mode
)
#
endif
}
;
using
InternalLinkVector
=
Vector
<
InternalLink
0
SystemAllocPolicy
>
;
struct
SymbolicLinkArray
:
EnumeratedArray
<
SymbolicAddress
Uint32Vector
size_t
(
SymbolicAddress
:
:
Limit
)
>
{
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
const
Tier
tier
;
InternalLinkVector
internalLinks
;
SymbolicLinkArray
symbolicLinks
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
LinkData
:
:
InternalLink
)
;
using
UniqueLinkData
=
UniquePtr
<
LinkData
>
;
struct
FreeCode
{
uint32_t
codeLength
;
FreeCode
(
)
:
codeLength
(
0
)
{
}
explicit
FreeCode
(
uint32_t
codeLength
)
:
codeLength
(
codeLength
)
{
}
void
operator
(
)
(
uint8_t
*
codeBytes
)
;
}
;
using
UniqueCodeBytes
=
UniquePtr
<
uint8_t
FreeCode
>
;
class
Code
;
class
CodeBlock
;
class
ModuleSegment
;
class
LazyStubSegment
;
using
UniqueCodeBlock
=
UniquePtr
<
CodeBlock
>
;
using
UniqueConstCodeBlock
=
UniquePtr
<
const
CodeBlock
>
;
using
UniqueCodeBlockVector
=
Vector
<
UniqueCodeBlock
0
SystemAllocPolicy
>
;
class
CodeSegment
:
public
ShareableBase
<
CodeSegment
>
{
protected
:
enum
class
Kind
{
LazyStubs
Module
}
;
CodeSegment
(
UniqueCodeBytes
bytes
uint32_t
length
Kind
kind
)
:
bytes_
(
std
:
:
move
(
bytes
)
)
length_
(
length
)
kind_
(
kind
)
code_
(
nullptr
)
{
}
bool
initialize
(
const
Code
&
code
)
;
private
:
const
UniqueCodeBytes
bytes_
;
const
uint32_t
length_
;
const
Kind
kind_
;
const
Code
*
code_
;
public
:
bool
initialized
(
)
const
{
return
!
!
code_
;
}
bool
isLazyStubs
(
)
const
{
return
kind_
=
=
Kind
:
:
LazyStubs
;
}
bool
isModule
(
)
const
{
return
kind_
=
=
Kind
:
:
Module
;
}
const
ModuleSegment
*
asModule
(
)
const
{
MOZ_ASSERT
(
isModule
(
)
)
;
return
(
ModuleSegment
*
)
this
;
}
ModuleSegment
*
asModule
(
)
{
MOZ_ASSERT
(
isModule
(
)
)
;
return
(
ModuleSegment
*
)
this
;
}
const
LazyStubSegment
*
asLazyStub
(
)
const
{
MOZ_ASSERT
(
isLazyStubs
(
)
)
;
return
(
LazyStubSegment
*
)
this
;
}
LazyStubSegment
*
asLazyStub
(
)
{
MOZ_ASSERT
(
isLazyStubs
(
)
)
;
return
(
LazyStubSegment
*
)
this
;
}
uint8_t
*
base
(
)
const
{
return
bytes_
.
get
(
)
;
}
uint32_t
length
(
)
const
{
MOZ_ASSERT
(
length_
!
=
UINT32_MAX
)
;
return
length_
;
}
const
Code
&
code
(
)
const
{
return
*
code_
;
}
void
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
size_t
*
code
)
const
;
}
;
using
SharedCodeSegment
=
RefPtr
<
CodeSegment
>
;
using
SharedModuleSegment
=
RefPtr
<
ModuleSegment
>
;
class
ModuleSegment
:
public
CodeSegment
{
const
Tier
tier_
;
uint8_t
*
const
trapCode_
;
public
:
ModuleSegment
(
Tier
tier
UniqueCodeBytes
codeBytes
uint32_t
codeLength
const
LinkData
&
linkData
)
;
static
SharedModuleSegment
create
(
Tier
tier
jit
:
:
MacroAssembler
&
masm
const
LinkData
&
linkData
)
;
static
SharedModuleSegment
create
(
Tier
tier
const
Bytes
&
unlinkedBytes
const
LinkData
&
linkData
)
;
bool
initialize
(
const
CodeBlock
&
codeBlock
const
LinkData
&
linkData
const
CodeMetadata
&
codeMeta
const
CodeMetadataForAsmJS
*
codeMetaForAsmJS
)
;
Tier
tier
(
)
const
{
return
tier_
;
}
const
CodeBlock
&
codeBlock
(
)
const
;
uint8_t
*
trapCode
(
)
const
{
return
trapCode_
;
}
const
CodeRange
*
lookupRange
(
const
void
*
pc
)
const
;
void
addSizeOfMisc
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
code
size_t
*
data
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
ModuleSegment
)
;
}
;
extern
UniqueCodeBytes
AllocateCodeBytes
(
mozilla
:
:
Maybe
<
jit
:
:
AutoMarkJitCodeWritableForThread
>
&
writable
uint32_t
codeLength
)
;
extern
bool
StaticallyLink
(
const
ModuleSegment
&
ms
const
LinkData
&
linkData
)
;
extern
void
StaticallyUnlink
(
uint8_t
*
base
const
LinkData
&
linkData
)
;
using
SharedLazyStubSegment
=
RefPtr
<
LazyStubSegment
>
;
using
LazyStubSegmentVector
=
Vector
<
SharedLazyStubSegment
0
SystemAllocPolicy
>
;
class
LazyStubSegment
:
public
CodeSegment
{
CodeRangeVector
codeRanges_
;
size_t
usedBytes_
;
public
:
LazyStubSegment
(
UniqueCodeBytes
bytes
size_t
length
)
:
CodeSegment
(
std
:
:
move
(
bytes
)
length
CodeSegment
:
:
Kind
:
:
LazyStubs
)
usedBytes_
(
0
)
{
}
static
SharedLazyStubSegment
create
(
const
Code
&
code
size_t
codeLength
)
;
static
size_t
AlignBytesNeeded
(
size_t
bytes
)
{
return
AlignBytes
(
bytes
gc
:
:
SystemPageSize
(
)
)
;
}
bool
hasSpace
(
size_t
bytes
)
const
;
[
[
nodiscard
]
]
bool
addStubs
(
const
CodeMetadata
&
codeMeta
size_t
codeLength
const
Uint32Vector
&
funcExportIndices
const
FuncExportVector
&
funcExports
const
CodeRangeVector
&
codeRanges
uint8_t
*
*
codePtr
size_t
*
offsetInSegment
)
;
const
CodeRangeVector
&
codeRanges
(
)
const
{
return
codeRanges_
;
}
[
[
nodiscard
]
]
const
CodeRange
*
lookupRange
(
const
void
*
pc
)
const
;
void
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
size_t
*
code
size_t
*
data
)
const
;
}
;
struct
LazyFuncExport
{
size_t
funcIndex
;
size_t
lazyStubBlockIndex
;
size_t
funcCodeRangeIndex
;
mozilla
:
:
DebugOnly
<
Tier
>
tier
;
LazyFuncExport
(
size_t
funcIndex
size_t
lazyStubBlockIndex
size_t
funcCodeRangeIndex
Tier
tier
)
:
funcIndex
(
funcIndex
)
lazyStubBlockIndex
(
lazyStubBlockIndex
)
funcCodeRangeIndex
(
funcCodeRangeIndex
)
tier
(
tier
)
{
}
}
;
using
LazyFuncExportVector
=
Vector
<
LazyFuncExport
0
SystemAllocPolicy
>
;
class
LazyStubTier
{
LazyStubSegmentVector
stubSegments_
;
UniqueCodeBlockVector
codeBlocks_
;
LazyFuncExportVector
exports_
;
[
[
nodiscard
]
]
bool
createManyEntryStubs
(
const
Uint32Vector
&
funcExportIndices
const
CodeMetadata
&
codeMeta
const
CodeBlock
&
tierCodeBlock
size_t
*
stubBlockIndex
)
;
public
:
LazyStubTier
(
)
=
default
;
[
[
nodiscard
]
]
bool
createOneEntryStub
(
uint32_t
funcExportIndex
const
CodeMetadata
&
codeMeta
const
CodeBlock
&
tierCodeBlock
)
;
bool
entryStubsEmpty
(
)
const
{
return
codeBlocks_
.
empty
(
)
;
}
bool
hasEntryStub
(
uint32_t
funcIndex
)
const
;
[
[
nodiscard
]
]
void
*
lookupInterpEntry
(
uint32_t
funcIndex
)
const
;
[
[
nodiscard
]
]
bool
createTier2
(
const
CodeMetadata
&
codeMeta
const
CodeBlock
&
tierCodeBlock
Maybe
<
size_t
>
*
outStubBlockIndex
)
;
void
setJitEntries
(
const
Maybe
<
size_t
>
&
stubBlockIndex
const
Code
&
code
)
;
void
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
size_t
*
code
size_t
*
data
)
const
;
}
;
enum
class
CodeBlockKind
{
BaselineTier
OptimizedTier
LazyStubs
}
;
class
CodeBlock
{
public
:
const
Code
*
code
;
const
CodeBlockKind
kind
;
SharedCodeSegment
segment
;
const
uint8_t
*
codeBase
;
size_t
codeLength
;
Uint32Vector
funcToCodeRange
;
CodeRangeVector
codeRanges
;
CallSiteVector
callSites
;
TrapSiteVectorArray
trapSites
;
FuncImportVector
funcImports
;
FuncExportVector
funcExports
;
StackMaps
stackMaps
;
TryNoteVector
tryNotes
;
CodeRangeUnwindInfoVector
codeRangeUnwindInfos
;
uint32_t
debugTrapOffset
;
bool
unregisterOnDestroy_
;
static
constexpr
CodeBlockKind
kindFromTier
(
Tier
tier
)
{
if
(
tier
=
=
Tier
:
:
Optimized
)
{
return
CodeBlockKind
:
:
OptimizedTier
;
}
MOZ_ASSERT
(
tier
=
=
Tier
:
:
Baseline
)
;
return
CodeBlockKind
:
:
BaselineTier
;
}
explicit
CodeBlock
(
CodeBlockKind
kind
)
:
code
(
nullptr
)
kind
(
kind
)
debugTrapOffset
(
0
)
unregisterOnDestroy_
(
false
)
{
}
explicit
CodeBlock
(
Tier
tier
)
:
CodeBlock
(
kindFromTier
(
tier
)
)
{
}
~
CodeBlock
(
)
;
bool
initialized
(
)
const
{
return
!
!
code
&
&
segment
-
>
initialized
(
)
;
}
bool
initialize
(
const
Code
&
code
const
LinkData
*
linkData
const
CodeMetadata
&
codeMeta
const
CodeMetadataForAsmJS
*
codeMetaForAsmJS
)
;
Tier
tier
(
)
const
{
switch
(
kind
)
{
case
CodeBlockKind
:
:
BaselineTier
:
return
Tier
:
:
Baseline
;
case
CodeBlockKind
:
:
OptimizedTier
:
return
Tier
:
:
Optimized
;
default
:
MOZ_CRASH
(
)
;
}
}
const
uint8_t
*
base
(
)
const
{
return
codeBase
;
}
uint32_t
length
(
)
const
{
return
codeLength
;
}
bool
containsCodePC
(
const
void
*
pc
)
const
{
return
pc
>
=
base
(
)
&
&
pc
<
(
base
(
)
+
length
(
)
)
;
}
const
ModuleSegment
&
moduleSegment
(
)
const
{
return
*
segment
-
>
asModule
(
)
;
}
const
LazyStubSegment
&
lazyStubSegment
(
)
const
{
return
*
segment
-
>
asLazyStub
(
)
;
}
const
CodeRange
&
codeRange
(
const
FuncExport
&
funcExport
)
const
{
return
codeRanges
[
funcToCodeRange
[
funcExport
.
funcIndex
(
)
]
]
;
}
const
CodeRange
*
lookupRange
(
const
void
*
pc
)
const
;
const
TryNote
*
lookupTryNote
(
const
void
*
pc
)
const
;
FuncExport
&
lookupFuncExport
(
uint32_t
funcIndex
size_t
*
funcExportIndex
=
nullptr
)
;
const
FuncExport
&
lookupFuncExport
(
uint32_t
funcIndex
size_t
*
funcExportIndex
=
nullptr
)
const
;
void
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
size_t
*
code
size_t
*
data
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE_ARGS
(
CodeBlock
const
wasm
:
:
LinkData
&
data
)
;
}
;
class
JumpTables
{
using
TablePointer
=
mozilla
:
:
UniquePtr
<
void
*
[
]
JS
:
:
FreePolicy
>
;
CompileMode
mode_
;
TablePointer
tiering_
;
TablePointer
jit_
;
size_t
numFuncs_
;
static_assert
(
JumpTableJitEntryOffset
=
=
0
"
Each
jit
entry
in
table
must
have
compatible
layout
with
BaseScript
and
"
"
SelfHostedLazyScript
"
)
;
public
:
bool
init
(
CompileMode
mode
const
ModuleSegment
&
ms
const
CodeRangeVector
&
codeRanges
)
;
void
setJitEntry
(
size_t
i
void
*
target
)
const
{
MOZ_ASSERT
(
i
<
numFuncs_
)
;
jit_
.
get
(
)
[
i
]
=
target
;
}
void
setJitEntryIfNull
(
size_t
i
void
*
target
)
const
{
MOZ_ASSERT
(
i
<
numFuncs_
)
;
void
*
expected
=
nullptr
;
(
void
)
__atomic_compare_exchange_n
(
&
jit_
.
get
(
)
[
i
]
&
expected
target
false
__ATOMIC_RELAXED
__ATOMIC_RELAXED
)
;
}
void
*
*
getAddressOfJitEntry
(
size_t
i
)
const
{
MOZ_ASSERT
(
i
<
numFuncs_
)
;
MOZ_ASSERT
(
jit_
.
get
(
)
[
i
]
)
;
return
&
jit_
.
get
(
)
[
i
]
;
}
size_t
funcIndexFromJitEntry
(
void
*
*
target
)
const
{
MOZ_ASSERT
(
target
>
=
&
jit_
.
get
(
)
[
0
]
)
;
MOZ_ASSERT
(
target
<
=
&
(
jit_
.
get
(
)
[
numFuncs_
-
1
]
)
)
;
return
(
intptr_t
*
)
target
-
(
intptr_t
*
)
&
jit_
.
get
(
)
[
0
]
;
}
void
setTieringEntry
(
size_t
i
void
*
target
)
const
{
MOZ_ASSERT
(
i
<
numFuncs_
)
;
if
(
mode_
=
=
CompileMode
:
:
Tier1
)
{
tiering_
.
get
(
)
[
i
]
=
target
;
}
}
void
*
*
tiering
(
)
const
{
return
tiering_
.
get
(
)
;
}
size_t
sizeOfMiscExcludingThis
(
)
const
{
return
sizeof
(
void
*
)
*
(
2
+
(
tiering_
?
1
:
0
)
)
*
numFuncs_
;
}
}
;
using
SharedCode
=
RefPtr
<
const
Code
>
;
using
MutableCode
=
RefPtr
<
Code
>
;
using
MetadataAnalysisHashMap
=
HashMap
<
const
char
*
uint32_t
mozilla
:
:
CStringHasher
SystemAllocPolicy
>
;
class
Code
:
public
ShareableBase
<
Code
>
{
SharedCodeMetadata
codeMeta_
;
SharedCodeMetadataForAsmJS
codeMetaForAsmJS_
;
mutable
UniqueConstCodeBlock
tier2_
;
mutable
Atomic
<
bool
>
hasTier2_
;
UniqueCodeBlock
tier1_
;
ExclusiveData
<
CacheableCharsVector
>
profilingLabels_
;
JumpTables
jumpTables_
;
RWExclusiveData
<
LazyStubTier
>
lazyStubs_
;
public
:
Code
(
const
CodeMetadata
&
codeMeta
const
CodeMetadataForAsmJS
*
codeMetaForAsmJS
UniqueCodeBlock
tier1
JumpTables
&
&
maybeJumpTables
)
;
bool
initialized
(
)
const
{
return
tier1_
-
>
initialized
(
)
;
}
bool
initialize
(
const
LinkData
&
linkData
)
;
void
setTieringEntry
(
size_t
i
void
*
target
)
const
{
jumpTables_
.
setTieringEntry
(
i
target
)
;
}
void
*
*
tieringJumpTable
(
)
const
{
return
jumpTables_
.
tiering
(
)
;
}
void
setJitEntry
(
size_t
i
void
*
target
)
const
{
jumpTables_
.
setJitEntry
(
i
target
)
;
}
void
setJitEntryIfNull
(
size_t
i
void
*
target
)
const
{
jumpTables_
.
setJitEntryIfNull
(
i
target
)
;
}
void
*
*
getAddressOfJitEntry
(
size_t
i
)
const
{
return
jumpTables_
.
getAddressOfJitEntry
(
i
)
;
}
uint32_t
getFuncIndex
(
JSFunction
*
fun
)
const
;
bool
setAndBorrowTier2
(
UniqueCodeBlock
tier2
const
LinkData
&
linkData
const
CodeBlock
*
*
borrowedTier
)
const
;
void
commitTier2
(
)
const
;
bool
hasTier2
(
)
const
{
return
hasTier2_
;
}
Tiers
tiers
(
)
const
;
bool
hasTier
(
Tier
t
)
const
;
Tier
stableTier
(
)
const
;
Tier
bestTier
(
)
const
;
const
CodeBlock
&
codeBlock
(
Tier
tier
)
const
;
const
CodeMetadata
&
codeMeta
(
)
const
{
return
*
codeMeta_
;
}
const
CodeMetadataForAsmJS
*
codeMetaForAsmJS
(
)
const
{
return
codeMetaForAsmJS_
;
}
const
ModuleSegment
&
segment
(
Tier
iter
)
const
{
return
*
codeBlock
(
iter
)
.
segment
-
>
asModule
(
)
;
}
const
RWExclusiveData
<
LazyStubTier
>
&
lazyStubs
(
)
const
{
return
lazyStubs_
;
}
const
CallSite
*
lookupCallSite
(
void
*
returnAddress
)
const
;
const
CodeRange
*
lookupFuncRange
(
void
*
pc
)
const
;
const
StackMap
*
lookupStackMap
(
uint8_t
*
nextPC
)
const
;
const
TryNote
*
lookupTryNote
(
void
*
pc
Tier
*
tier
)
const
;
bool
lookupTrap
(
void
*
pc
Trap
*
trap
BytecodeOffset
*
bytecode
)
const
;
const
CodeRangeUnwindInfo
*
lookupUnwindInfo
(
void
*
pc
)
const
;
bool
lookupFunctionTier
(
const
CodeRange
*
codeRange
Tier
*
tier
)
const
;
void
ensureProfilingLabels
(
bool
profilingEnabled
)
const
;
const
char
*
profilingLabel
(
uint32_t
funcIndex
)
const
;
void
disassemble
(
JSContext
*
cx
Tier
tier
int
kindSelection
PrintCallback
printString
)
const
;
MetadataAnalysisHashMap
metadataAnalysis
(
JSContext
*
cx
)
const
;
void
addSizeOfMiscIfNotSeen
(
MallocSizeOf
mallocSizeOf
CodeMetadata
:
:
SeenSet
*
seenCodeMeta
CodeMetadataForAsmJS
:
:
SeenSet
*
seenCodeMetaForAsmJS
Code
:
:
SeenSet
*
seenCode
size_t
*
code
size_t
*
data
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE_ARGS
(
SharedCode
const
wasm
:
:
LinkData
&
data
)
;
}
;
void
PatchDebugSymbolicAccesses
(
uint8_t
*
codeBase
jit
:
:
MacroAssembler
&
masm
)
;
}
}
#
endif
