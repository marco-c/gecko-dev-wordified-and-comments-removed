#
ifndef
wasm_code_h
#
define
wasm_code_h
#
include
"
js
/
HashTable
.
h
"
#
include
"
threading
/
ExclusiveData
.
h
"
#
include
"
wasm
/
WasmTypes
.
h
"
namespace
js
{
struct
AsmJSMetadata
;
class
WasmInstanceObject
;
namespace
wasm
{
struct
LinkDataTier
;
struct
MetadataTier
;
struct
Metadata
;
struct
ShareableBytes
:
ShareableBase
<
ShareableBytes
>
{
Bytes
bytes
;
ShareableBytes
(
)
=
default
;
explicit
ShareableBytes
(
Bytes
&
&
bytes
)
:
bytes
(
Move
(
bytes
)
)
{
}
size_t
sizeOfExcludingThis
(
MallocSizeOf
m
)
const
{
return
bytes
.
sizeOfExcludingThis
(
m
)
;
}
const
uint8_t
*
begin
(
)
const
{
return
bytes
.
begin
(
)
;
}
const
uint8_t
*
end
(
)
const
{
return
bytes
.
end
(
)
;
}
size_t
length
(
)
const
{
return
bytes
.
length
(
)
;
}
bool
append
(
const
uint8_t
*
p
uint32_t
ct
)
{
return
bytes
.
append
(
p
ct
)
;
}
}
;
typedef
RefPtr
<
ShareableBytes
>
MutableBytes
;
typedef
RefPtr
<
const
ShareableBytes
>
SharedBytes
;
struct
FreeCode
{
uint32_t
codeLength
;
FreeCode
(
)
:
codeLength
(
0
)
{
}
explicit
FreeCode
(
uint32_t
codeLength
)
:
codeLength
(
codeLength
)
{
}
void
operator
(
)
(
uint8_t
*
codeBytes
)
;
}
;
using
UniqueCodeBytes
=
UniquePtr
<
uint8_t
FreeCode
>
;
class
Code
;
class
CodeTier
;
class
ModuleSegment
;
class
CodeSegment
{
protected
:
static
UniqueCodeBytes
AllocateCodeBytes
(
uint32_t
codeLength
)
;
const
CodeTier
*
codeTier_
;
UniqueCodeBytes
bytes_
;
uint32_t
length_
;
enum
class
Kind
{
LazyStubs
Module
}
kind_
;
bool
registerInProcessMap
(
)
;
private
:
bool
registered_
;
public
:
CodeSegment
(
)
:
codeTier_
(
nullptr
)
length_
(
0
)
kind_
(
Kind
:
:
Module
)
registered_
(
false
)
{
}
~
CodeSegment
(
)
;
bool
isLazyStubs
(
)
const
{
return
kind_
=
=
Kind
:
:
LazyStubs
;
}
bool
isModule
(
)
const
{
return
kind_
=
=
Kind
:
:
Module
;
}
const
ModuleSegment
*
asModule
(
)
const
{
MOZ_ASSERT
(
isModule
(
)
)
;
return
(
ModuleSegment
*
)
this
;
}
uint8_t
*
base
(
)
const
{
return
bytes_
.
get
(
)
;
}
uint32_t
length
(
)
const
{
return
length_
;
}
bool
containsCodePC
(
const
void
*
pc
)
const
{
return
pc
>
=
base
(
)
&
&
pc
<
(
base
(
)
+
length_
)
;
}
void
initCodeTier
(
const
CodeTier
*
codeTier
)
{
MOZ_ASSERT
(
!
codeTier_
)
;
codeTier_
=
codeTier
;
}
const
Code
&
code
(
)
const
;
}
;
typedef
UniquePtr
<
ModuleSegment
>
UniqueModuleSegment
;
typedef
UniquePtr
<
const
ModuleSegment
>
UniqueConstModuleSegment
;
class
ModuleSegment
:
public
CodeSegment
{
Tier
tier_
;
uint8_t
*
interruptCode_
;
uint8_t
*
outOfBoundsCode_
;
uint8_t
*
unalignedAccessCode_
;
uint8_t
*
trapCode_
;
bool
initialize
(
Tier
tier
UniqueCodeBytes
bytes
uint32_t
codeLength
const
ShareableBytes
&
bytecode
const
LinkDataTier
&
linkData
const
Metadata
&
metadata
const
CodeRangeVector
&
codeRanges
)
;
static
UniqueModuleSegment
create
(
Tier
tier
UniqueCodeBytes
bytes
uint32_t
codeLength
const
ShareableBytes
&
bytecode
const
LinkDataTier
&
linkData
const
Metadata
&
metadata
const
CodeRangeVector
&
codeRanges
)
;
public
:
ModuleSegment
(
const
ModuleSegment
&
)
=
delete
;
void
operator
=
(
const
ModuleSegment
&
)
=
delete
;
ModuleSegment
(
)
:
CodeSegment
(
)
tier_
(
Tier
(
-
1
)
)
interruptCode_
(
nullptr
)
outOfBoundsCode_
(
nullptr
)
unalignedAccessCode_
(
nullptr
)
trapCode_
(
nullptr
)
{
}
static
UniqueModuleSegment
create
(
Tier
tier
jit
:
:
MacroAssembler
&
masm
const
ShareableBytes
&
bytecode
const
LinkDataTier
&
linkData
const
Metadata
&
metadata
const
CodeRangeVector
&
codeRanges
)
;
static
UniqueModuleSegment
create
(
Tier
tier
const
Bytes
&
unlinkedBytes
const
ShareableBytes
&
bytecode
const
LinkDataTier
&
linkData
const
Metadata
&
metadata
const
CodeRangeVector
&
codeRanges
)
;
Tier
tier
(
)
const
{
return
tier_
;
}
uint8_t
*
interruptCode
(
)
const
{
return
interruptCode_
;
}
uint8_t
*
outOfBoundsCode
(
)
const
{
return
outOfBoundsCode_
;
}
uint8_t
*
unalignedAccessCode
(
)
const
{
return
unalignedAccessCode_
;
}
uint8_t
*
trapCode
(
)
const
{
return
trapCode_
;
}
size_t
serializedSize
(
)
const
;
uint8_t
*
serialize
(
uint8_t
*
cursor
const
LinkDataTier
&
linkDataTier
)
const
;
const
uint8_t
*
deserialize
(
const
uint8_t
*
cursor
const
ShareableBytes
&
bytecode
const
LinkDataTier
&
linkDataTier
const
Metadata
&
metadata
const
CodeRangeVector
&
codeRanges
)
;
void
addSizeOfMisc
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
code
size_t
*
data
)
const
;
}
;
class
FuncExport
{
Sig
sig_
;
MOZ_INIT_OUTSIDE_CTOR
struct
CacheablePod
{
uint32_t
funcIndex_
;
uint32_t
codeRangeIndex_
;
uint32_t
interpEntryOffset_
;
}
pod
;
public
:
FuncExport
(
)
=
default
;
explicit
FuncExport
(
Sig
&
&
sig
uint32_t
funcIndex
)
:
sig_
(
Move
(
sig
)
)
{
pod
.
funcIndex_
=
funcIndex
;
pod
.
codeRangeIndex_
=
UINT32_MAX
;
pod
.
interpEntryOffset_
=
UINT32_MAX
;
}
void
initInterpEntryOffset
(
uint32_t
entryOffset
)
{
MOZ_ASSERT
(
pod
.
interpEntryOffset_
=
=
UINT32_MAX
)
;
pod
.
interpEntryOffset_
=
entryOffset
;
}
void
initCodeRangeIndex
(
uint32_t
codeRangeIndex
)
{
MOZ_ASSERT
(
pod
.
codeRangeIndex_
=
=
UINT32_MAX
)
;
pod
.
codeRangeIndex_
=
codeRangeIndex
;
}
const
Sig
&
sig
(
)
const
{
return
sig_
;
}
uint32_t
funcIndex
(
)
const
{
return
pod
.
funcIndex_
;
}
uint32_t
codeRangeIndex
(
)
const
{
MOZ_ASSERT
(
pod
.
codeRangeIndex_
!
=
UINT32_MAX
)
;
return
pod
.
codeRangeIndex_
;
}
uint32_t
interpEntryOffset
(
)
const
{
MOZ_ASSERT
(
pod
.
interpEntryOffset_
!
=
UINT32_MAX
)
;
return
pod
.
interpEntryOffset_
;
}
bool
clone
(
const
FuncExport
&
src
)
{
mozilla
:
:
PodAssign
(
&
pod
&
src
.
pod
)
;
return
sig_
.
clone
(
src
.
sig_
)
;
}
WASM_DECLARE_SERIALIZABLE
(
FuncExport
)
}
;
typedef
Vector
<
FuncExport
0
SystemAllocPolicy
>
FuncExportVector
;
class
FuncImport
{
Sig
sig_
;
struct
CacheablePod
{
uint32_t
tlsDataOffset_
;
uint32_t
interpExitCodeOffset_
;
uint32_t
jitExitCodeOffset_
;
}
pod
;
public
:
FuncImport
(
)
{
memset
(
&
pod
0
sizeof
(
CacheablePod
)
)
;
}
FuncImport
(
Sig
&
&
sig
uint32_t
tlsDataOffset
)
:
sig_
(
Move
(
sig
)
)
{
pod
.
tlsDataOffset_
=
tlsDataOffset
;
pod
.
interpExitCodeOffset_
=
0
;
pod
.
jitExitCodeOffset_
=
0
;
}
void
initInterpExitOffset
(
uint32_t
off
)
{
MOZ_ASSERT
(
!
pod
.
interpExitCodeOffset_
)
;
pod
.
interpExitCodeOffset_
=
off
;
}
void
initJitExitOffset
(
uint32_t
off
)
{
MOZ_ASSERT
(
!
pod
.
jitExitCodeOffset_
)
;
pod
.
jitExitCodeOffset_
=
off
;
}
const
Sig
&
sig
(
)
const
{
return
sig_
;
}
uint32_t
tlsDataOffset
(
)
const
{
return
pod
.
tlsDataOffset_
;
}
uint32_t
interpExitCodeOffset
(
)
const
{
return
pod
.
interpExitCodeOffset_
;
}
uint32_t
jitExitCodeOffset
(
)
const
{
return
pod
.
jitExitCodeOffset_
;
}
bool
clone
(
const
FuncImport
&
src
)
{
mozilla
:
:
PodAssign
(
&
pod
&
src
.
pod
)
;
return
sig_
.
clone
(
src
.
sig_
)
;
}
WASM_DECLARE_SERIALIZABLE
(
FuncImport
)
}
;
typedef
Vector
<
FuncImport
0
SystemAllocPolicy
>
FuncImportVector
;
enum
class
MemoryUsage
{
None
=
false
Unshared
=
1
Shared
=
2
}
;
struct
NameInBytecode
{
uint32_t
offset
;
uint32_t
length
;
NameInBytecode
(
)
:
offset
(
UINT32_MAX
)
length
(
0
)
{
}
NameInBytecode
(
uint32_t
offset
uint32_t
length
)
:
offset
(
offset
)
length
(
length
)
{
}
}
;
typedef
Vector
<
NameInBytecode
0
SystemAllocPolicy
>
NameInBytecodeVector
;
struct
CustomSection
{
NameInBytecode
name
;
uint32_t
offset
;
uint32_t
length
;
CustomSection
(
)
=
default
;
CustomSection
(
NameInBytecode
name
uint32_t
offset
uint32_t
length
)
:
name
(
name
)
offset
(
offset
)
length
(
length
)
{
}
}
;
typedef
Vector
<
CustomSection
0
SystemAllocPolicy
>
CustomSectionVector
;
typedef
Vector
<
ValTypeVector
0
SystemAllocPolicy
>
FuncArgTypesVector
;
typedef
Vector
<
ExprType
0
SystemAllocPolicy
>
FuncReturnTypesVector
;
struct
MetadataCacheablePod
{
ModuleKind
kind
;
MemoryUsage
memoryUsage
;
uint32_t
minMemoryLength
;
uint32_t
globalDataLength
;
Maybe
<
uint32_t
>
maxMemoryLength
;
Maybe
<
uint32_t
>
startFuncIndex
;
explicit
MetadataCacheablePod
(
ModuleKind
kind
)
:
kind
(
kind
)
memoryUsage
(
MemoryUsage
:
:
None
)
minMemoryLength
(
0
)
globalDataLength
(
0
)
{
}
}
;
typedef
uint8_t
ModuleHash
[
8
]
;
struct
Metadata
:
public
ShareableBase
<
Metadata
>
public
MetadataCacheablePod
{
SigWithIdVector
sigIds
;
GlobalDescVector
globals
;
TableDescVector
tables
;
NameInBytecodeVector
funcNames
;
CustomSectionVector
customSections
;
CacheableChars
filename
;
CacheableChars
baseURL
;
CacheableChars
sourceMapURL
;
bool
debugEnabled
;
FuncArgTypesVector
debugFuncArgTypes
;
FuncReturnTypesVector
debugFuncReturnTypes
;
ModuleHash
debugHash
;
explicit
Metadata
(
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
MetadataCacheablePod
(
kind
)
debugEnabled
(
false
)
debugHash
(
)
{
}
virtual
~
Metadata
(
)
{
}
MetadataCacheablePod
&
pod
(
)
{
return
*
this
;
}
const
MetadataCacheablePod
&
pod
(
)
const
{
return
*
this
;
}
bool
usesMemory
(
)
const
{
return
memoryUsage
!
=
MemoryUsage
:
:
None
;
}
bool
usesSharedMemory
(
)
const
{
return
memoryUsage
=
=
MemoryUsage
:
:
Shared
;
}
bool
isAsmJS
(
)
const
{
return
kind
=
=
ModuleKind
:
:
AsmJS
;
}
const
AsmJSMetadata
&
asAsmJS
(
)
const
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
return
*
(
const
AsmJSMetadata
*
)
this
;
}
virtual
bool
mutedErrors
(
)
const
{
return
false
;
}
virtual
const
char16_t
*
displayURL
(
)
const
{
return
nullptr
;
}
virtual
ScriptSource
*
maybeScriptSource
(
)
const
{
return
nullptr
;
}
virtual
bool
getFuncName
(
const
Bytes
*
maybeBytecode
uint32_t
funcIndex
UTF8Bytes
*
name
)
const
;
WASM_DECLARE_SERIALIZABLE_VIRTUAL
(
Metadata
)
;
}
;
typedef
RefPtr
<
Metadata
>
MutableMetadata
;
typedef
RefPtr
<
const
Metadata
>
SharedMetadata
;
struct
MetadataTier
{
explicit
MetadataTier
(
Tier
tier
)
:
tier
(
tier
)
{
}
const
Tier
tier
;
MemoryAccessVector
memoryAccesses
;
CodeRangeVector
codeRanges
;
CallSiteVector
callSites
;
TrapSiteVectorArray
trapSites
;
FuncImportVector
funcImports
;
FuncExportVector
funcExports
;
Uint32Vector
debugTrapFarJumpOffsets
;
Uint32Vector
debugFuncToCodeRange
;
FuncExport
&
lookupFuncExport
(
uint32_t
funcIndex
)
;
const
FuncExport
&
lookupFuncExport
(
uint32_t
funcIndex
)
const
;
bool
clone
(
const
MetadataTier
&
src
)
;
WASM_DECLARE_SERIALIZABLE
(
MetadataTier
)
;
}
;
using
UniqueMetadataTier
=
UniquePtr
<
MetadataTier
>
;
class
CodeTier
{
const
Tier
tier_
;
const
Code
*
code_
;
UniqueMetadataTier
metadata_
;
UniqueConstModuleSegment
segment_
;
UniqueConstModuleSegment
takeOwnership
(
UniqueModuleSegment
segment
)
const
{
segment
-
>
initCodeTier
(
this
)
;
return
UniqueConstModuleSegment
(
segment
.
release
(
)
)
;
}
public
:
explicit
CodeTier
(
Tier
tier
)
:
tier_
(
tier
)
code_
(
nullptr
)
metadata_
(
nullptr
)
segment_
(
nullptr
)
{
}
CodeTier
(
Tier
tier
UniqueMetadataTier
metadata
UniqueModuleSegment
segment
)
:
tier_
(
tier
)
code_
(
nullptr
)
metadata_
(
Move
(
metadata
)
)
segment_
(
takeOwnership
(
Move
(
segment
)
)
)
{
}
void
initCode
(
const
Code
*
code
)
{
MOZ_ASSERT
(
!
code_
)
;
code_
=
code
;
}
Tier
tier
(
)
const
{
return
tier_
;
}
const
MetadataTier
&
metadata
(
)
const
{
return
*
metadata_
.
get
(
)
;
}
const
ModuleSegment
&
segment
(
)
const
{
return
*
segment_
.
get
(
)
;
}
const
Code
&
code
(
)
const
{
return
*
code_
;
}
size_t
serializedSize
(
)
const
;
uint8_t
*
serialize
(
uint8_t
*
cursor
const
LinkDataTier
&
linkData
)
const
;
const
uint8_t
*
deserialize
(
const
uint8_t
*
cursor
const
SharedBytes
&
bytecode
Metadata
&
metadata
const
LinkDataTier
&
linkData
)
;
void
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
size_t
*
code
size_t
*
data
)
const
;
}
;
typedef
UniquePtr
<
CodeTier
>
UniqueCodeTier
;
typedef
UniquePtr
<
const
CodeTier
>
UniqueConstCodeTier
;
class
JumpTables
{
using
TablePointer
=
mozilla
:
:
UniquePtr
<
void
*
[
]
JS
:
:
FreePolicy
>
;
CompileMode
mode_
;
TablePointer
tiering_
;
TablePointer
jit_
;
size_t
numFuncs_
;
public
:
bool
init
(
CompileMode
mode
const
ModuleSegment
&
ms
const
CodeRangeVector
&
codeRanges
)
;
void
setJitEntry
(
size_t
i
void
*
target
)
const
{
MOZ_ASSERT
(
i
<
numFuncs_
)
;
jit_
.
get
(
)
[
2
*
i
]
=
target
;
jit_
.
get
(
)
[
2
*
i
+
1
]
=
target
;
}
void
*
*
getAddressOfJitEntry
(
size_t
i
)
const
{
MOZ_ASSERT
(
i
<
numFuncs_
)
;
MOZ_ASSERT
(
jit_
.
get
(
)
[
2
*
i
]
)
;
return
&
jit_
.
get
(
)
[
2
*
i
]
;
}
size_t
funcIndexFromJitEntry
(
void
*
*
target
)
const
{
MOZ_ASSERT
(
target
>
=
&
jit_
.
get
(
)
[
0
]
)
;
MOZ_ASSERT
(
target
<
=
&
(
jit_
.
get
(
)
[
2
*
numFuncs_
-
1
]
)
)
;
size_t
index
=
(
intptr_t
*
)
target
-
(
intptr_t
*
)
&
jit_
.
get
(
)
[
0
]
;
MOZ_ASSERT
(
index
%
2
=
=
0
)
;
return
index
/
2
;
}
void
setTieringEntry
(
size_t
i
void
*
target
)
const
{
MOZ_ASSERT
(
i
<
numFuncs_
)
;
if
(
mode_
=
=
CompileMode
:
:
Tier1
)
tiering_
.
get
(
)
[
i
]
=
target
;
}
void
*
*
tiering
(
)
const
{
return
tiering_
.
get
(
)
;
}
size_t
sizeOfMiscIncludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
2
*
sizeof
(
void
*
)
*
numFuncs_
+
(
tiering_
?
sizeof
(
void
*
)
:
numFuncs_
)
;
}
}
;
class
Code
:
public
ShareableBase
<
Code
>
{
UniqueConstCodeTier
tier1_
;
mutable
UniqueConstCodeTier
tier2_
;
mutable
Atomic
<
bool
>
hasTier2_
;
SharedMetadata
metadata_
;
ExclusiveData
<
CacheableCharsVector
>
profilingLabels_
;
JumpTables
jumpTables_
;
UniqueConstCodeTier
takeOwnership
(
UniqueCodeTier
codeTier
)
const
{
codeTier
-
>
initCode
(
this
)
;
return
UniqueConstCodeTier
(
codeTier
.
release
(
)
)
;
}
public
:
Code
(
)
;
Code
(
UniqueCodeTier
tier
const
Metadata
&
metadata
JumpTables
&
&
maybeJumpTables
)
;
void
setTieringEntry
(
size_t
i
void
*
target
)
const
{
jumpTables_
.
setTieringEntry
(
i
target
)
;
}
void
*
*
tieringJumpTable
(
)
const
{
return
jumpTables_
.
tiering
(
)
;
}
void
setJitEntry
(
size_t
i
void
*
target
)
const
{
jumpTables_
.
setJitEntry
(
i
target
)
;
}
void
*
*
getAddressOfJitEntry
(
size_t
i
)
const
{
return
jumpTables_
.
getAddressOfJitEntry
(
i
)
;
}
uint32_t
getFuncIndex
(
JSFunction
*
fun
)
const
;
void
setTier2
(
UniqueCodeTier
tier2
)
const
;
void
commitTier2
(
)
const
;
bool
hasTier2
(
)
const
{
return
hasTier2_
;
}
Tiers
tiers
(
)
const
;
bool
hasTier
(
Tier
t
)
const
;
Tier
stableTier
(
)
const
;
Tier
bestTier
(
)
const
;
const
CodeTier
&
codeTier
(
Tier
tier
)
const
;
const
Metadata
&
metadata
(
)
const
{
return
*
metadata_
;
}
const
ModuleSegment
&
segment
(
Tier
iter
)
const
{
return
codeTier
(
iter
)
.
segment
(
)
;
}
const
MetadataTier
&
metadata
(
Tier
iter
)
const
{
return
codeTier
(
iter
)
.
metadata
(
)
;
}
const
CallSite
*
lookupCallSite
(
void
*
returnAddress
)
const
;
const
CodeRange
*
lookupRange
(
void
*
pc
)
const
;
const
MemoryAccess
*
lookupMemoryAccess
(
void
*
pc
)
const
;
bool
containsCodePC
(
const
void
*
pc
)
const
;
bool
lookupTrap
(
void
*
pc
Trap
*
trap
BytecodeOffset
*
bytecode
)
const
;
void
ensureProfilingLabels
(
const
Bytes
*
maybeBytecode
bool
profilingEnabled
)
const
;
const
char
*
profilingLabel
(
uint32_t
funcIndex
)
const
;
void
addSizeOfMiscIfNotSeen
(
MallocSizeOf
mallocSizeOf
Metadata
:
:
SeenSet
*
seenMetadata
Code
:
:
SeenSet
*
seenCode
size_t
*
code
size_t
*
data
)
const
;
size_t
serializedSize
(
)
const
;
uint8_t
*
serialize
(
uint8_t
*
cursor
const
LinkDataTier
&
linkDataTier
)
const
;
const
uint8_t
*
deserialize
(
const
uint8_t
*
cursor
const
SharedBytes
&
bytecode
const
LinkDataTier
&
linkDataTier
Metadata
&
metadata
)
;
}
;
typedef
RefPtr
<
const
Code
>
SharedCode
;
typedef
RefPtr
<
Code
>
MutableCode
;
}
}
#
endif
