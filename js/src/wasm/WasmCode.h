#
ifndef
wasm_code_h
#
define
wasm_code_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
utility
>
#
include
"
jstypes
.
h
"
#
include
"
gc
/
Memory
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
threading
/
ExclusiveData
.
h
"
#
include
"
util
/
Memory
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
#
include
"
wasm
/
WasmBuiltins
.
h
"
#
include
"
wasm
/
WasmCodegenTypes
.
h
"
#
include
"
wasm
/
WasmCompileArgs
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmExprType
.
h
"
#
include
"
wasm
/
WasmGC
.
h
"
#
include
"
wasm
/
WasmLog
.
h
"
#
include
"
wasm
/
WasmModuleTypes
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
#
include
"
wasm
/
WasmShareable
.
h
"
#
include
"
wasm
/
WasmTypeDecls
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
struct
JS_PUBLIC_API
JSContext
;
class
JSFunction
;
namespace
js
{
struct
AsmJSMetadata
;
class
ScriptSource
;
namespace
jit
{
class
MacroAssembler
;
}
;
namespace
wasm
{
struct
MetadataTier
;
struct
Metadata
;
struct
LinkDataCacheablePod
{
uint32_t
trapOffset
=
0
;
WASM_CHECK_CACHEABLE_POD
(
trapOffset
)
;
LinkDataCacheablePod
(
)
=
default
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
LinkDataCacheablePod
)
;
struct
LinkData
:
LinkDataCacheablePod
{
explicit
LinkData
(
Tier
tier
)
:
tier
(
tier
)
{
}
LinkDataCacheablePod
&
pod
(
)
{
return
*
this
;
}
const
LinkDataCacheablePod
&
pod
(
)
const
{
return
*
this
;
}
struct
InternalLink
{
uint32_t
patchAtOffset
;
uint32_t
targetOffset
;
#
ifdef
JS_CODELABEL_LINKMODE
uint32_t
mode
;
#
endif
WASM_CHECK_CACHEABLE_POD
(
patchAtOffset
targetOffset
)
;
#
ifdef
JS_CODELABEL_LINKMODE
WASM_CHECK_CACHEABLE_POD
(
mode
)
#
endif
}
;
using
InternalLinkVector
=
Vector
<
InternalLink
0
SystemAllocPolicy
>
;
struct
SymbolicLinkArray
:
EnumeratedArray
<
SymbolicAddress
SymbolicAddress
:
:
Limit
Uint32Vector
>
{
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
const
Tier
tier
;
InternalLinkVector
internalLinks
;
SymbolicLinkArray
symbolicLinks
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
LinkData
:
:
InternalLink
)
;
using
UniqueLinkData
=
UniquePtr
<
LinkData
>
;
struct
FreeCode
{
uint32_t
codeLength
;
FreeCode
(
)
:
codeLength
(
0
)
{
}
explicit
FreeCode
(
uint32_t
codeLength
)
:
codeLength
(
codeLength
)
{
}
void
operator
(
)
(
uint8_t
*
codeBytes
)
;
}
;
using
UniqueCodeBytes
=
UniquePtr
<
uint8_t
FreeCode
>
;
class
Code
;
class
CodeTier
;
class
ModuleSegment
;
class
LazyStubSegment
;
class
CodeSegment
{
protected
:
enum
class
Kind
{
LazyStubs
Module
}
;
CodeSegment
(
UniqueCodeBytes
bytes
uint32_t
length
Kind
kind
)
:
bytes_
(
std
:
:
move
(
bytes
)
)
length_
(
length
)
kind_
(
kind
)
codeTier_
(
nullptr
)
unregisterOnDestroy_
(
false
)
{
}
bool
initialize
(
const
CodeTier
&
codeTier
)
;
private
:
const
UniqueCodeBytes
bytes_
;
const
uint32_t
length_
;
const
Kind
kind_
;
const
CodeTier
*
codeTier_
;
bool
unregisterOnDestroy_
;
public
:
bool
initialized
(
)
const
{
return
!
!
codeTier_
;
}
~
CodeSegment
(
)
;
bool
isLazyStubs
(
)
const
{
return
kind_
=
=
Kind
:
:
LazyStubs
;
}
bool
isModule
(
)
const
{
return
kind_
=
=
Kind
:
:
Module
;
}
const
ModuleSegment
*
asModule
(
)
const
{
MOZ_ASSERT
(
isModule
(
)
)
;
return
(
ModuleSegment
*
)
this
;
}
const
LazyStubSegment
*
asLazyStub
(
)
const
{
MOZ_ASSERT
(
isLazyStubs
(
)
)
;
return
(
LazyStubSegment
*
)
this
;
}
uint8_t
*
base
(
)
const
{
return
bytes_
.
get
(
)
;
}
uint32_t
length
(
)
const
{
MOZ_ASSERT
(
length_
!
=
UINT32_MAX
)
;
return
length_
;
}
bool
containsCodePC
(
const
void
*
pc
)
const
{
return
pc
>
=
base
(
)
&
&
pc
<
(
base
(
)
+
length_
)
;
}
const
CodeTier
&
codeTier
(
)
const
{
MOZ_ASSERT
(
initialized
(
)
)
;
return
*
codeTier_
;
}
const
Code
&
code
(
)
const
;
void
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
size_t
*
code
)
const
;
}
;
using
UniqueModuleSegment
=
UniquePtr
<
ModuleSegment
>
;
class
ModuleSegment
:
public
CodeSegment
{
const
Tier
tier_
;
uint8_t
*
const
trapCode_
;
public
:
ModuleSegment
(
Tier
tier
UniqueCodeBytes
codeBytes
uint32_t
codeLength
const
LinkData
&
linkData
)
;
static
UniqueModuleSegment
create
(
Tier
tier
jit
:
:
MacroAssembler
&
masm
const
LinkData
&
linkData
)
;
static
UniqueModuleSegment
create
(
Tier
tier
const
Bytes
&
unlinkedBytes
const
LinkData
&
linkData
)
;
bool
initialize
(
const
CodeTier
&
codeTier
const
LinkData
&
linkData
const
Metadata
&
metadata
const
MetadataTier
&
metadataTier
)
;
Tier
tier
(
)
const
{
return
tier_
;
}
uint8_t
*
trapCode
(
)
const
{
return
trapCode_
;
}
const
CodeRange
*
lookupRange
(
const
void
*
pc
)
const
;
void
addSizeOfMisc
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
code
size_t
*
data
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
ModuleSegment
)
;
}
;
extern
UniqueCodeBytes
AllocateCodeBytes
(
uint32_t
codeLength
)
;
extern
bool
StaticallyLink
(
const
ModuleSegment
&
ms
const
LinkData
&
linkData
)
;
extern
void
StaticallyUnlink
(
uint8_t
*
base
const
LinkData
&
linkData
)
;
class
FuncExport
{
uint32_t
typeIndex_
;
uint32_t
funcIndex_
;
uint32_t
eagerInterpEntryOffset_
;
bool
hasEagerStubs_
;
WASM_CHECK_CACHEABLE_POD
(
typeIndex_
funcIndex_
eagerInterpEntryOffset_
hasEagerStubs_
)
;
public
:
FuncExport
(
)
=
default
;
explicit
FuncExport
(
uint32_t
typeIndex
uint32_t
funcIndex
bool
hasEagerStubs
)
{
typeIndex_
=
typeIndex
;
funcIndex_
=
funcIndex
;
eagerInterpEntryOffset_
=
UINT32_MAX
;
hasEagerStubs_
=
hasEagerStubs
;
}
void
initEagerInterpEntryOffset
(
uint32_t
entryOffset
)
{
MOZ_ASSERT
(
eagerInterpEntryOffset_
=
=
UINT32_MAX
)
;
MOZ_ASSERT
(
hasEagerStubs
(
)
)
;
eagerInterpEntryOffset_
=
entryOffset
;
}
bool
hasEagerStubs
(
)
const
{
return
hasEagerStubs_
;
}
uint32_t
typeIndex
(
)
const
{
return
typeIndex_
;
}
uint32_t
funcIndex
(
)
const
{
return
funcIndex_
;
}
uint32_t
eagerInterpEntryOffset
(
)
const
{
MOZ_ASSERT
(
eagerInterpEntryOffset_
!
=
UINT32_MAX
)
;
MOZ_ASSERT
(
hasEagerStubs
(
)
)
;
return
eagerInterpEntryOffset_
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
FuncExport
)
;
using
FuncExportVector
=
Vector
<
FuncExport
0
SystemAllocPolicy
>
;
class
FuncImport
{
private
:
uint32_t
typeIndex_
;
uint32_t
instanceOffset_
;
uint32_t
interpExitCodeOffset_
;
uint32_t
jitExitCodeOffset_
;
WASM_CHECK_CACHEABLE_POD
(
typeIndex_
instanceOffset_
interpExitCodeOffset_
jitExitCodeOffset_
)
;
public
:
FuncImport
(
)
:
typeIndex_
(
0
)
instanceOffset_
(
0
)
interpExitCodeOffset_
(
0
)
jitExitCodeOffset_
(
0
)
{
}
FuncImport
(
uint32_t
typeIndex
uint32_t
instanceOffset
)
{
typeIndex_
=
typeIndex
;
instanceOffset_
=
instanceOffset
;
interpExitCodeOffset_
=
0
;
jitExitCodeOffset_
=
0
;
}
void
initInterpExitOffset
(
uint32_t
off
)
{
MOZ_ASSERT
(
!
interpExitCodeOffset_
)
;
interpExitCodeOffset_
=
off
;
}
void
initJitExitOffset
(
uint32_t
off
)
{
MOZ_ASSERT
(
!
jitExitCodeOffset_
)
;
jitExitCodeOffset_
=
off
;
}
uint32_t
typeIndex
(
)
const
{
return
typeIndex_
;
}
uint32_t
instanceOffset
(
)
const
{
return
instanceOffset_
;
}
uint32_t
interpExitCodeOffset
(
)
const
{
return
interpExitCodeOffset_
;
}
uint32_t
jitExitCodeOffset
(
)
const
{
return
jitExitCodeOffset_
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
FuncImport
)
using
FuncImportVector
=
Vector
<
FuncImport
0
SystemAllocPolicy
>
;
struct
MetadataCacheablePod
{
ModuleKind
kind
;
Maybe
<
MemoryDesc
>
memory
;
uint32_t
globalDataLength
;
Maybe
<
uint32_t
>
startFuncIndex
;
Maybe
<
uint32_t
>
nameCustomSectionIndex
;
bool
filenameIsURL
;
bool
omitsBoundsChecks
;
WASM_CHECK_CACHEABLE_POD
(
kind
memory
globalDataLength
startFuncIndex
nameCustomSectionIndex
filenameIsURL
omitsBoundsChecks
)
explicit
MetadataCacheablePod
(
ModuleKind
kind
)
:
kind
(
kind
)
globalDataLength
(
0
)
filenameIsURL
(
false
)
omitsBoundsChecks
(
false
)
{
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
MetadataCacheablePod
)
typedef
uint8_t
ModuleHash
[
8
]
;
using
FuncArgTypesVector
=
Vector
<
ValTypeVector
0
SystemAllocPolicy
>
;
using
FuncReturnTypesVector
=
Vector
<
ValTypeVector
0
SystemAllocPolicy
>
;
struct
Metadata
:
public
ShareableBase
<
Metadata
>
public
MetadataCacheablePod
{
TypeDefVector
types
;
TypeIdDescVector
typeIds
;
GlobalDescVector
globals
;
TableDescVector
tables
;
TagDescVector
tags
;
CacheableChars
filename
;
CacheableChars
sourceMapURL
;
SharedBytes
namePayload
;
Maybe
<
Name
>
moduleName
;
NameVector
funcNames
;
bool
debugEnabled
;
FuncArgTypesVector
debugFuncArgTypes
;
FuncReturnTypesVector
debugFuncReturnTypes
;
ModuleHash
debugHash
;
explicit
Metadata
(
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
MetadataCacheablePod
(
kind
)
debugEnabled
(
false
)
debugHash
(
)
{
}
virtual
~
Metadata
(
)
=
default
;
MetadataCacheablePod
&
pod
(
)
{
return
*
this
;
}
const
MetadataCacheablePod
&
pod
(
)
const
{
return
*
this
;
}
bool
usesMemory
(
)
const
{
return
memory
.
isSome
(
)
;
}
bool
usesSharedMemory
(
)
const
{
return
memory
.
isSome
(
)
&
&
memory
-
>
isShared
(
)
;
}
const
FuncType
&
getFuncImportType
(
const
FuncImport
&
funcImport
)
const
{
return
types
[
funcImport
.
typeIndex
(
)
]
.
funcType
(
)
;
}
const
FuncType
&
getFuncExportType
(
const
FuncExport
&
funcExport
)
const
{
return
types
[
funcExport
.
typeIndex
(
)
]
.
funcType
(
)
;
}
ResultType
getFuncResultType
(
uint32_t
funcIndex
)
const
{
return
ResultType
:
:
Vector
(
debugFuncReturnTypes
[
funcIndex
]
)
;
}
;
bool
isAsmJS
(
)
const
{
return
kind
=
=
ModuleKind
:
:
AsmJS
;
}
const
AsmJSMetadata
&
asAsmJS
(
)
const
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
return
*
(
const
AsmJSMetadata
*
)
this
;
}
virtual
bool
mutedErrors
(
)
const
{
return
false
;
}
virtual
const
char16_t
*
displayURL
(
)
const
{
return
nullptr
;
}
virtual
ScriptSource
*
maybeScriptSource
(
)
const
{
return
nullptr
;
}
enum
NameContext
{
Standalone
BeforeLocation
}
;
virtual
bool
getFuncName
(
NameContext
ctx
uint32_t
funcIndex
UTF8Bytes
*
name
)
const
;
bool
getFuncNameStandalone
(
uint32_t
funcIndex
UTF8Bytes
*
name
)
const
{
return
getFuncName
(
NameContext
:
:
Standalone
funcIndex
name
)
;
}
bool
getFuncNameBeforeLocation
(
uint32_t
funcIndex
UTF8Bytes
*
name
)
const
{
return
getFuncName
(
NameContext
:
:
BeforeLocation
funcIndex
name
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
Metadata
)
;
}
;
using
MutableMetadata
=
RefPtr
<
Metadata
>
;
using
SharedMetadata
=
RefPtr
<
const
Metadata
>
;
struct
MetadataTier
{
explicit
MetadataTier
(
Tier
tier
=
Tier
:
:
Serialized
)
:
tier
(
tier
)
debugTrapOffset
(
0
)
{
}
const
Tier
tier
;
Uint32Vector
funcToCodeRange
;
CodeRangeVector
codeRanges
;
CallSiteVector
callSites
;
TrapSiteVectorArray
trapSites
;
FuncImportVector
funcImports
;
FuncExportVector
funcExports
;
StackMaps
stackMaps
;
TryNoteVector
tryNotes
;
uint32_t
debugTrapOffset
;
FuncExport
&
lookupFuncExport
(
uint32_t
funcIndex
size_t
*
funcExportIndex
=
nullptr
)
;
const
FuncExport
&
lookupFuncExport
(
uint32_t
funcIndex
size_t
*
funcExportIndex
=
nullptr
)
const
;
const
CodeRange
&
codeRange
(
const
FuncExport
&
funcExport
)
const
{
return
codeRanges
[
funcToCodeRange
[
funcExport
.
funcIndex
(
)
]
]
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
UniqueMetadataTier
=
UniquePtr
<
MetadataTier
>
;
using
UniqueLazyStubSegment
=
UniquePtr
<
LazyStubSegment
>
;
using
LazyStubSegmentVector
=
Vector
<
UniqueLazyStubSegment
0
SystemAllocPolicy
>
;
class
LazyStubSegment
:
public
CodeSegment
{
CodeRangeVector
codeRanges_
;
size_t
usedBytes_
;
public
:
LazyStubSegment
(
UniqueCodeBytes
bytes
size_t
length
)
:
CodeSegment
(
std
:
:
move
(
bytes
)
length
CodeSegment
:
:
Kind
:
:
LazyStubs
)
usedBytes_
(
0
)
{
}
static
UniqueLazyStubSegment
create
(
const
CodeTier
&
codeTier
size_t
codeLength
)
;
static
size_t
AlignBytesNeeded
(
size_t
bytes
)
{
return
AlignBytes
(
bytes
gc
:
:
SystemPageSize
(
)
)
;
}
bool
hasSpace
(
size_t
bytes
)
const
;
[
[
nodiscard
]
]
bool
addStubs
(
const
Metadata
&
metadata
size_t
codeLength
const
Uint32Vector
&
funcExportIndices
const
FuncExportVector
&
funcExports
const
CodeRangeVector
&
codeRanges
uint8_t
*
*
codePtr
size_t
*
indexFirstInsertedCodeRange
)
;
const
CodeRangeVector
&
codeRanges
(
)
const
{
return
codeRanges_
;
}
[
[
nodiscard
]
]
const
CodeRange
*
lookupRange
(
const
void
*
pc
)
const
;
void
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
size_t
*
code
size_t
*
data
)
const
;
}
;
struct
LazyFuncExport
{
size_t
funcIndex
;
size_t
lazyStubSegmentIndex
;
size_t
funcCodeRangeIndex
;
LazyFuncExport
(
size_t
funcIndex
size_t
lazyStubSegmentIndex
size_t
funcCodeRangeIndex
)
:
funcIndex
(
funcIndex
)
lazyStubSegmentIndex
(
lazyStubSegmentIndex
)
funcCodeRangeIndex
(
funcCodeRangeIndex
)
{
}
}
;
using
LazyFuncExportVector
=
Vector
<
LazyFuncExport
0
SystemAllocPolicy
>
;
class
LazyStubTier
{
LazyStubSegmentVector
stubSegments_
;
LazyFuncExportVector
exports_
;
size_t
lastStubSegmentIndex_
;
[
[
nodiscard
]
]
bool
createManyEntryStubs
(
const
Uint32Vector
&
funcExportIndices
const
Metadata
&
metadata
const
CodeTier
&
codeTier
size_t
*
stubSegmentIndex
)
;
public
:
LazyStubTier
(
)
:
lastStubSegmentIndex_
(
0
)
{
}
[
[
nodiscard
]
]
bool
createOneEntryStub
(
uint32_t
funcExportIndex
const
Metadata
&
metadata
const
CodeTier
&
codeTier
)
;
bool
entryStubsEmpty
(
)
const
{
return
stubSegments_
.
empty
(
)
;
}
bool
hasEntryStub
(
uint32_t
funcIndex
)
const
;
[
[
nodiscard
]
]
void
*
lookupInterpEntry
(
uint32_t
funcIndex
)
const
;
[
[
nodiscard
]
]
bool
createTier2
(
const
Uint32Vector
&
funcExportIndices
const
Metadata
&
metadata
const
CodeTier
&
codeTier
Maybe
<
size_t
>
*
stubSegmentIndex
)
;
void
setJitEntries
(
const
Maybe
<
size_t
>
&
stubSegmentIndex
const
Code
&
code
)
;
void
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
size_t
*
code
size_t
*
data
)
const
;
}
;
using
UniqueCodeTier
=
UniquePtr
<
CodeTier
>
;
using
UniqueConstCodeTier
=
UniquePtr
<
const
CodeTier
>
;
class
CodeTier
{
const
Code
*
code_
;
const
UniqueMetadataTier
metadata_
;
const
UniqueModuleSegment
segment_
;
RWExclusiveData
<
LazyStubTier
>
lazyStubs_
;
static
const
MutexId
&
mutexForTier
(
Tier
tier
)
{
if
(
tier
=
=
Tier
:
:
Baseline
)
{
return
mutexid
:
:
WasmLazyStubsTier1
;
}
MOZ_ASSERT
(
tier
=
=
Tier
:
:
Optimized
)
;
return
mutexid
:
:
WasmLazyStubsTier2
;
}
public
:
CodeTier
(
UniqueMetadataTier
metadata
UniqueModuleSegment
segment
)
:
code_
(
nullptr
)
metadata_
(
std
:
:
move
(
metadata
)
)
segment_
(
std
:
:
move
(
segment
)
)
lazyStubs_
(
mutexForTier
(
segment_
-
>
tier
(
)
)
)
{
}
bool
initialized
(
)
const
{
return
!
!
code_
&
&
segment_
-
>
initialized
(
)
;
}
bool
initialize
(
const
Code
&
code
const
LinkData
&
linkData
const
Metadata
&
metadata
)
;
Tier
tier
(
)
const
{
return
segment_
-
>
tier
(
)
;
}
const
RWExclusiveData
<
LazyStubTier
>
&
lazyStubs
(
)
const
{
return
lazyStubs_
;
}
const
MetadataTier
&
metadata
(
)
const
{
return
*
metadata_
.
get
(
)
;
}
const
ModuleSegment
&
segment
(
)
const
{
return
*
segment_
.
get
(
)
;
}
const
Code
&
code
(
)
const
{
MOZ_ASSERT
(
initialized
(
)
)
;
return
*
code_
;
}
const
CodeRange
*
lookupRange
(
const
void
*
pc
)
const
;
const
TryNote
*
lookupTryNote
(
const
void
*
pc
)
const
;
void
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
size_t
*
code
size_t
*
data
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE_ARGS
(
CodeTier
const
wasm
:
:
LinkData
&
data
)
;
}
;
class
JumpTables
{
using
TablePointer
=
mozilla
:
:
UniquePtr
<
void
*
[
]
JS
:
:
FreePolicy
>
;
CompileMode
mode_
;
TablePointer
tiering_
;
TablePointer
jit_
;
size_t
numFuncs_
;
public
:
bool
init
(
CompileMode
mode
const
ModuleSegment
&
ms
const
CodeRangeVector
&
codeRanges
)
;
void
setJitEntry
(
size_t
i
void
*
target
)
const
{
MOZ_ASSERT
(
i
<
numFuncs_
)
;
jit_
.
get
(
)
[
i
]
=
target
;
}
void
setJitEntryIfNull
(
size_t
i
void
*
target
)
const
{
MOZ_ASSERT
(
i
<
numFuncs_
)
;
void
*
expected
=
nullptr
;
(
void
)
__atomic_compare_exchange_n
(
&
jit_
.
get
(
)
[
i
]
&
expected
target
false
__ATOMIC_RELAXED
__ATOMIC_RELAXED
)
;
}
void
*
*
getAddressOfJitEntry
(
size_t
i
)
const
{
MOZ_ASSERT
(
i
<
numFuncs_
)
;
MOZ_ASSERT
(
jit_
.
get
(
)
[
i
]
)
;
return
&
jit_
.
get
(
)
[
i
]
;
}
size_t
funcIndexFromJitEntry
(
void
*
*
target
)
const
{
MOZ_ASSERT
(
target
>
=
&
jit_
.
get
(
)
[
0
]
)
;
MOZ_ASSERT
(
target
<
=
&
(
jit_
.
get
(
)
[
numFuncs_
-
1
]
)
)
;
return
(
intptr_t
*
)
target
-
(
intptr_t
*
)
&
jit_
.
get
(
)
[
0
]
;
}
void
setTieringEntry
(
size_t
i
void
*
target
)
const
{
MOZ_ASSERT
(
i
<
numFuncs_
)
;
if
(
mode_
=
=
CompileMode
:
:
Tier1
)
{
tiering_
.
get
(
)
[
i
]
=
target
;
}
}
void
*
*
tiering
(
)
const
{
return
tiering_
.
get
(
)
;
}
size_t
sizeOfMiscExcludingThis
(
)
const
{
return
sizeof
(
void
*
)
*
(
2
+
(
tiering_
?
1
:
0
)
)
*
numFuncs_
;
}
}
;
using
SharedCode
=
RefPtr
<
const
Code
>
;
using
MutableCode
=
RefPtr
<
Code
>
;
class
Code
:
public
ShareableBase
<
Code
>
{
UniqueCodeTier
tier1_
;
mutable
UniqueConstCodeTier
tier2_
;
mutable
Atomic
<
bool
>
hasTier2_
;
SharedMetadata
metadata_
;
ExclusiveData
<
CacheableCharsVector
>
profilingLabels_
;
JumpTables
jumpTables_
;
public
:
Code
(
UniqueCodeTier
tier1
const
Metadata
&
metadata
JumpTables
&
&
maybeJumpTables
)
;
bool
initialized
(
)
const
{
return
tier1_
-
>
initialized
(
)
;
}
bool
initialize
(
const
LinkData
&
linkData
)
;
void
setTieringEntry
(
size_t
i
void
*
target
)
const
{
jumpTables_
.
setTieringEntry
(
i
target
)
;
}
void
*
*
tieringJumpTable
(
)
const
{
return
jumpTables_
.
tiering
(
)
;
}
void
setJitEntry
(
size_t
i
void
*
target
)
const
{
jumpTables_
.
setJitEntry
(
i
target
)
;
}
void
setJitEntryIfNull
(
size_t
i
void
*
target
)
const
{
jumpTables_
.
setJitEntryIfNull
(
i
target
)
;
}
void
*
*
getAddressOfJitEntry
(
size_t
i
)
const
{
return
jumpTables_
.
getAddressOfJitEntry
(
i
)
;
}
uint32_t
getFuncIndex
(
JSFunction
*
fun
)
const
;
bool
setAndBorrowTier2
(
UniqueCodeTier
tier2
const
LinkData
&
linkData
const
CodeTier
*
*
borrowedTier
)
const
;
void
commitTier2
(
)
const
;
bool
hasTier2
(
)
const
{
return
hasTier2_
;
}
Tiers
tiers
(
)
const
;
bool
hasTier
(
Tier
t
)
const
;
Tier
stableTier
(
)
const
;
Tier
bestTier
(
)
const
;
const
CodeTier
&
codeTier
(
Tier
tier
)
const
;
const
Metadata
&
metadata
(
)
const
{
return
*
metadata_
;
}
const
ModuleSegment
&
segment
(
Tier
iter
)
const
{
return
codeTier
(
iter
)
.
segment
(
)
;
}
const
MetadataTier
&
metadata
(
Tier
iter
)
const
{
return
codeTier
(
iter
)
.
metadata
(
)
;
}
const
CallSite
*
lookupCallSite
(
void
*
returnAddress
)
const
;
const
CodeRange
*
lookupFuncRange
(
void
*
pc
)
const
;
const
StackMap
*
lookupStackMap
(
uint8_t
*
nextPC
)
const
;
const
TryNote
*
lookupTryNote
(
void
*
pc
Tier
*
tier
)
const
;
bool
containsCodePC
(
const
void
*
pc
)
const
;
bool
lookupTrap
(
void
*
pc
Trap
*
trap
BytecodeOffset
*
bytecode
)
const
;
void
ensureProfilingLabels
(
bool
profilingEnabled
)
const
;
const
char
*
profilingLabel
(
uint32_t
funcIndex
)
const
;
void
disassemble
(
JSContext
*
cx
Tier
tier
int
kindSelection
PrintCallback
printString
)
const
;
void
addSizeOfMiscIfNotSeen
(
MallocSizeOf
mallocSizeOf
Metadata
:
:
SeenSet
*
seenMetadata
Code
:
:
SeenSet
*
seenCode
size_t
*
code
size_t
*
data
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE_ARGS
(
SharedCode
const
wasm
:
:
LinkData
&
data
)
;
}
;
void
PatchDebugSymbolicAccesses
(
uint8_t
*
codeBase
jit
:
:
MacroAssembler
&
masm
)
;
}
}
#
endif
