#
include
"
wasm
/
WasmInstance
-
inl
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
jsmath
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
jit
/
AtomicOperations
.
h
"
#
include
"
jit
/
Disassemble
.
h
"
#
include
"
jit
/
JitCommon
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
jit
/
Registers
.
h
"
#
include
"
js
/
ForOfIterator
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
Stack
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
ErrorObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
Iteration
.
h
"
#
include
"
vm
/
JitActivation
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
wasm
/
WasmBuiltins
.
h
"
#
include
"
wasm
/
WasmCode
.
h
"
#
include
"
wasm
/
WasmDebug
.
h
"
#
include
"
wasm
/
WasmDebugFrame
.
h
"
#
include
"
wasm
/
WasmGcObject
.
h
"
#
include
"
wasm
/
WasmJS
.
h
"
#
include
"
wasm
/
WasmMemory
.
h
"
#
include
"
wasm
/
WasmModule
.
h
"
#
include
"
wasm
/
WasmStubs
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
#
include
"
wasm
/
WasmValue
.
h
"
#
include
"
gc
/
StoreBuffer
-
inl
.
h
"
#
include
"
vm
/
ArrayBufferObject
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
using
mozilla
:
:
BitwiseCast
;
using
mozilla
:
:
CheckedUint32
;
using
mozilla
:
:
DebugOnly
;
static_assert
(
alignof
(
Instance
)
>
=
std
:
:
max
(
sizeof
(
Registers
:
:
RegisterContent
)
sizeof
(
FloatRegisters
:
:
RegisterContent
)
)
)
;
static_assert
(
Instance
:
:
offsetOfGlobalArea
(
)
%
alignof
(
Instance
)
=
=
0
)
;
static_assert
(
Instance
:
:
offsetOfMemoryBase
(
)
=
=
0
)
;
static_assert
(
Instance
:
:
offsetOfLastCommonJitField
(
)
<
128
)
;
TypeDefInstanceData
*
Instance
:
:
typeDefInstanceData
(
uint32_t
typeIndex
)
const
{
TypeDefInstanceData
*
instanceData
=
(
TypeDefInstanceData
*
)
(
globalData
(
)
+
metadata
(
)
.
typeIdsOffsetStart
)
;
return
&
instanceData
[
typeIndex
]
;
}
const
void
*
Instance
:
:
addressOfGlobalCell
(
const
GlobalDesc
&
global
)
const
{
const
void
*
cell
=
globalData
(
)
+
global
.
offset
(
)
;
if
(
global
.
isIndirect
(
)
)
{
cell
=
*
(
const
void
*
*
)
cell
;
}
return
cell
;
}
FuncImportInstanceData
&
Instance
:
:
funcImportInstanceData
(
const
FuncImport
&
fi
)
{
return
*
(
FuncImportInstanceData
*
)
(
globalData
(
)
+
fi
.
instanceOffset
(
)
)
;
}
TableInstanceData
&
Instance
:
:
tableInstanceData
(
const
TableDesc
&
td
)
const
{
return
*
(
TableInstanceData
*
)
(
globalData
(
)
+
td
.
globalDataOffset
)
;
}
GCPtr
<
WasmTagObject
*
>
&
Instance
:
:
tagInstanceData
(
const
TagDesc
&
td
)
const
{
return
*
(
GCPtr
<
WasmTagObject
*
>
*
)
(
globalData
(
)
+
td
.
globalDataOffset
)
;
}
static
bool
UnpackResults
(
JSContext
*
cx
const
ValTypeVector
&
resultTypes
const
Maybe
<
char
*
>
stackResultsArea
uint64_t
*
argv
MutableHandleValue
rval
)
{
if
(
!
stackResultsArea
)
{
MOZ_ASSERT
(
resultTypes
.
length
(
)
<
=
1
)
;
if
(
resultTypes
.
length
(
)
=
=
1
)
{
return
ToWebAssemblyValue
(
cx
rval
resultTypes
[
0
]
argv
true
)
;
}
return
true
;
}
MOZ_ASSERT
(
stackResultsArea
.
isSome
(
)
)
;
Rooted
<
ArrayObject
*
>
array
(
cx
)
;
if
(
!
IterableToArray
(
cx
rval
&
array
)
)
{
return
false
;
}
if
(
resultTypes
.
length
(
)
!
=
array
-
>
length
(
)
)
{
UniqueChars
expected
(
JS_smprintf
(
"
%
zu
"
resultTypes
.
length
(
)
)
)
;
UniqueChars
got
(
JS_smprintf
(
"
%
u
"
array
-
>
length
(
)
)
)
;
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_WRONG_NUMBER_OF_VALUES
expected
.
get
(
)
got
.
get
(
)
)
;
return
false
;
}
DebugOnly
<
uint64_t
>
previousOffset
=
~
(
uint64_t
)
0
;
ABIResultIter
iter
(
ResultType
:
:
Vector
(
resultTypes
)
)
;
while
(
!
iter
.
done
(
)
)
{
iter
.
next
(
)
;
}
DebugOnly
<
bool
>
seenRegisterResult
=
false
;
for
(
iter
.
switchToPrev
(
)
;
!
iter
.
done
(
)
;
iter
.
prev
(
)
)
{
const
ABIResult
&
result
=
iter
.
cur
(
)
;
MOZ_ASSERT
(
!
seenRegisterResult
)
;
rval
.
set
(
array
-
>
getDenseElement
(
iter
.
index
(
)
)
)
;
if
(
result
.
inRegister
(
)
)
{
if
(
!
ToWebAssemblyValue
(
cx
rval
result
.
type
(
)
argv
true
)
)
{
return
false
;
}
seenRegisterResult
=
true
;
continue
;
}
uint32_t
result_size
=
result
.
size
(
)
;
MOZ_ASSERT
(
result_size
=
=
4
|
|
result_size
=
=
8
)
;
#
ifdef
DEBUG
if
(
previousOffset
=
=
~
(
uint64_t
)
0
)
{
previousOffset
=
(
uint64_t
)
result
.
stackOffset
(
)
;
}
else
{
MOZ_ASSERT
(
previousOffset
-
(
uint64_t
)
result_size
=
=
(
uint64_t
)
result
.
stackOffset
(
)
)
;
previousOffset
-
=
(
uint64_t
)
result_size
;
}
#
endif
char
*
loc
=
stackResultsArea
.
value
(
)
+
result
.
stackOffset
(
)
;
if
(
!
ToWebAssemblyValue
(
cx
rval
result
.
type
(
)
loc
result_size
=
=
8
)
)
{
return
false
;
}
}
return
true
;
}
bool
Instance
:
:
callImport
(
JSContext
*
cx
uint32_t
funcImportIndex
unsigned
argc
uint64_t
*
argv
)
{
AssertRealmUnchanged
aru
(
cx
)
;
Tier
tier
=
code
(
)
.
bestTier
(
)
;
const
FuncImport
&
fi
=
metadata
(
tier
)
.
funcImports
[
funcImportIndex
]
;
const
FuncType
&
funcType
=
metadata
(
)
.
getFuncImportType
(
fi
)
;
ArgTypeVector
argTypes
(
funcType
)
;
InvokeArgs
args
(
cx
)
;
if
(
!
args
.
init
(
cx
argTypes
.
lengthWithoutStackResults
(
)
)
)
{
return
false
;
}
if
(
funcType
.
hasUnexposableArgOrRet
(
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_BAD_VAL_TYPE
)
;
return
false
;
}
MOZ_ASSERT
(
argTypes
.
lengthWithStackResults
(
)
=
=
argc
)
;
Maybe
<
char
*
>
stackResultPointer
;
for
(
size_t
i
=
0
;
i
<
argc
;
i
+
+
)
{
const
void
*
rawArgLoc
=
&
argv
[
i
]
;
if
(
argTypes
.
isSyntheticStackResultPointerArg
(
i
)
)
{
stackResultPointer
=
Some
(
*
(
char
*
*
)
rawArgLoc
)
;
continue
;
}
size_t
naturalIndex
=
argTypes
.
naturalIndex
(
i
)
;
ValType
type
=
funcType
.
args
(
)
[
naturalIndex
]
;
MutableHandleValue
argValue
=
args
[
naturalIndex
]
;
if
(
!
ToJSValue
(
cx
rawArgLoc
type
argValue
)
)
{
return
false
;
}
}
FuncImportInstanceData
&
import
=
funcImportInstanceData
(
fi
)
;
Rooted
<
JSObject
*
>
importCallable
(
cx
import
.
callable
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
importCallable
-
>
nonCCWRealm
(
)
)
;
RootedValue
fval
(
cx
ObjectValue
(
*
importCallable
)
)
;
RootedValue
thisv
(
cx
UndefinedValue
(
)
)
;
RootedValue
rval
(
cx
)
;
if
(
!
Call
(
cx
fval
thisv
args
&
rval
)
)
{
return
false
;
}
if
(
!
UnpackResults
(
cx
funcType
.
results
(
)
stackResultPointer
argv
&
rval
)
)
{
return
false
;
}
if
(
!
JitOptions
.
enableWasmJitExit
)
{
return
true
;
}
for
(
auto
t
:
code
(
)
.
tiers
(
)
)
{
void
*
jitExitCode
=
codeBase
(
t
)
+
fi
.
jitExitCodeOffset
(
)
;
if
(
import
.
code
=
=
jitExitCode
)
{
return
true
;
}
}
void
*
jitExitCode
=
codeBase
(
tier
)
+
fi
.
jitExitCodeOffset
(
)
;
if
(
!
importCallable
-
>
is
<
JSFunction
>
(
)
)
{
return
true
;
}
if
(
!
importCallable
-
>
as
<
JSFunction
>
(
)
.
hasBytecode
(
)
)
{
return
true
;
}
JSScript
*
script
=
importCallable
-
>
as
<
JSFunction
>
(
)
.
nonLazyScript
(
)
;
if
(
!
script
-
>
hasJitScript
(
)
)
{
return
true
;
}
if
(
!
funcType
.
canHaveJitExit
(
)
)
{
return
true
;
}
import
.
code
=
jitExitCode
;
return
true
;
}
int32_t
Instance
:
:
callImport_general
(
Instance
*
instance
int32_t
funcImportIndex
int32_t
argc
uint64_t
*
argv
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
instance
-
>
callImport
(
cx
funcImportIndex
argc
argv
)
;
}
template
<
typename
ValT
typename
PtrT
>
static
int32_t
PerformWait
(
Instance
*
instance
PtrT
byteOffset
ValT
value
int64_t
timeout_ns
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
if
(
!
instance
-
>
memory
(
)
-
>
isShared
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_NONSHARED_WAIT
)
;
return
-
1
;
}
if
(
byteOffset
&
(
sizeof
(
ValT
)
-
1
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_UNALIGNED_ACCESS
)
;
return
-
1
;
}
if
(
byteOffset
+
sizeof
(
ValT
)
>
instance
-
>
memory
(
)
-
>
volatileMemoryLength
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
timeout
;
if
(
timeout_ns
>
=
0
)
{
timeout
=
mozilla
:
:
Some
(
mozilla
:
:
TimeDuration
:
:
FromMicroseconds
(
double
(
timeout_ns
)
/
1000
)
)
;
}
MOZ_ASSERT
(
byteOffset
<
=
SIZE_MAX
"
Bounds
check
is
broken
"
)
;
switch
(
atomics_wait_impl
(
cx
instance
-
>
sharedMemoryBuffer
(
)
size_t
(
byteOffset
)
value
timeout
)
)
{
case
FutexThread
:
:
WaitResult
:
:
OK
:
return
0
;
case
FutexThread
:
:
WaitResult
:
:
NotEqual
:
return
1
;
case
FutexThread
:
:
WaitResult
:
:
TimedOut
:
return
2
;
case
FutexThread
:
:
WaitResult
:
:
Error
:
return
-
1
;
default
:
MOZ_CRASH
(
)
;
}
}
int32_t
Instance
:
:
wait_i32_m32
(
Instance
*
instance
uint32_t
byteOffset
int32_t
value
int64_t
timeout_ns
)
{
MOZ_ASSERT
(
SASigWaitI32M32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
return
PerformWait
(
instance
byteOffset
value
timeout_ns
)
;
}
int32_t
Instance
:
:
wait_i32_m64
(
Instance
*
instance
uint64_t
byteOffset
int32_t
value
int64_t
timeout_ns
)
{
MOZ_ASSERT
(
SASigWaitI32M64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
return
PerformWait
(
instance
byteOffset
value
timeout_ns
)
;
}
int32_t
Instance
:
:
wait_i64_m32
(
Instance
*
instance
uint32_t
byteOffset
int64_t
value
int64_t
timeout_ns
)
{
MOZ_ASSERT
(
SASigWaitI64M32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
return
PerformWait
(
instance
byteOffset
value
timeout_ns
)
;
}
int32_t
Instance
:
:
wait_i64_m64
(
Instance
*
instance
uint64_t
byteOffset
int64_t
value
int64_t
timeout_ns
)
{
MOZ_ASSERT
(
SASigWaitI64M64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
return
PerformWait
(
instance
byteOffset
value
timeout_ns
)
;
}
template
<
typename
PtrT
>
static
int32_t
PerformWake
(
Instance
*
instance
PtrT
byteOffset
int32_t
count
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
if
(
byteOffset
&
3
)
{
ReportTrapError
(
cx
JSMSG_WASM_UNALIGNED_ACCESS
)
;
return
-
1
;
}
if
(
byteOffset
>
=
instance
-
>
memory
(
)
-
>
volatileMemoryLength
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
if
(
!
instance
-
>
memory
(
)
-
>
isShared
(
)
)
{
return
0
;
}
MOZ_ASSERT
(
byteOffset
<
=
SIZE_MAX
"
Bounds
check
is
broken
"
)
;
int64_t
woken
=
atomics_notify_impl
(
instance
-
>
sharedMemoryBuffer
(
)
size_t
(
byteOffset
)
int64_t
(
count
)
)
;
if
(
woken
>
INT32_MAX
)
{
ReportTrapError
(
cx
JSMSG_WASM_WAKE_OVERFLOW
)
;
return
-
1
;
}
return
int32_t
(
woken
)
;
}
int32_t
Instance
:
:
wake_m32
(
Instance
*
instance
uint32_t
byteOffset
int32_t
count
)
{
MOZ_ASSERT
(
SASigWakeM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
return
PerformWake
(
instance
byteOffset
count
)
;
}
int32_t
Instance
:
:
wake_m64
(
Instance
*
instance
uint64_t
byteOffset
int32_t
count
)
{
MOZ_ASSERT
(
SASigWakeM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
return
PerformWake
(
instance
byteOffset
count
)
;
}
uint32_t
Instance
:
:
memoryGrow_m32
(
Instance
*
instance
uint32_t
delta
)
{
MOZ_ASSERT
(
SASigMemoryGrowM32
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
MOZ_ASSERT
(
!
instance
-
>
isAsmJS
(
)
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
Rooted
<
WasmMemoryObject
*
>
memory
(
cx
instance
-
>
memory_
)
;
uint32_t
ret
=
uint32_t
(
WasmMemoryObject
:
:
grow
(
memory
uint64_t
(
delta
)
cx
)
)
;
MOZ_RELEASE_ASSERT
(
instance
-
>
memoryBase_
=
=
instance
-
>
memory_
-
>
buffer
(
)
.
dataPointerEither
(
)
)
;
return
ret
;
}
uint64_t
Instance
:
:
memoryGrow_m64
(
Instance
*
instance
uint64_t
delta
)
{
MOZ_ASSERT
(
SASigMemoryGrowM64
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
MOZ_ASSERT
(
!
instance
-
>
isAsmJS
(
)
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
Rooted
<
WasmMemoryObject
*
>
memory
(
cx
instance
-
>
memory_
)
;
uint64_t
ret
=
WasmMemoryObject
:
:
grow
(
memory
delta
cx
)
;
MOZ_RELEASE_ASSERT
(
instance
-
>
memoryBase_
=
=
instance
-
>
memory_
-
>
buffer
(
)
.
dataPointerEither
(
)
)
;
return
ret
;
}
uint32_t
Instance
:
:
memorySize_m32
(
Instance
*
instance
)
{
MOZ_ASSERT
(
SASigMemorySizeM32
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
DebugOnly
<
JSContext
*
>
cx
=
instance
-
>
cx
(
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
instance
-
>
realm
(
)
)
;
Pages
pages
=
instance
-
>
memory
(
)
-
>
volatilePages
(
)
;
#
ifdef
JS_64BIT
MOZ_ASSERT
(
pages
<
=
Pages
(
MaxMemory32LimitField
)
)
;
#
endif
return
uint32_t
(
pages
.
value
(
)
)
;
}
uint64_t
Instance
:
:
memorySize_m64
(
Instance
*
instance
)
{
MOZ_ASSERT
(
SASigMemorySizeM64
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
DebugOnly
<
JSContext
*
>
cx
=
instance
-
>
cx
(
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
instance
-
>
realm
(
)
)
;
Pages
pages
=
instance
-
>
memory
(
)
-
>
volatilePages
(
)
;
#
ifdef
JS_64BIT
MOZ_ASSERT
(
pages
<
=
Pages
(
MaxMemory64LimitField
)
)
;
#
endif
return
pages
.
value
(
)
;
}
template
<
typename
T
typename
F
typename
I
>
inline
int32_t
WasmMemoryCopy
(
JSContext
*
cx
T
memBase
size_t
memLen
I
dstByteOffset
I
srcByteOffset
I
len
F
memMove
)
{
if
(
!
MemoryBoundsCheck
(
dstByteOffset
len
memLen
)
|
|
!
MemoryBoundsCheck
(
srcByteOffset
len
memLen
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
memMove
(
memBase
+
uintptr_t
(
dstByteOffset
)
memBase
+
uintptr_t
(
srcByteOffset
)
size_t
(
len
)
)
;
return
0
;
}
template
<
typename
I
>
inline
int32_t
MemoryCopy
(
JSContext
*
cx
I
dstByteOffset
I
srcByteOffset
I
len
uint8_t
*
memBase
)
{
const
WasmArrayRawBuffer
*
rawBuf
=
WasmArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
byteLength
(
)
;
return
WasmMemoryCopy
(
cx
memBase
memLen
dstByteOffset
srcByteOffset
len
memmove
)
;
}
template
<
typename
I
>
inline
int32_t
MemoryCopyShared
(
JSContext
*
cx
I
dstByteOffset
I
srcByteOffset
I
len
uint8_t
*
memBase
)
{
using
RacyMemMove
=
void
(
*
)
(
SharedMem
<
uint8_t
*
>
SharedMem
<
uint8_t
*
>
size_t
)
;
const
WasmSharedArrayRawBuffer
*
rawBuf
=
WasmSharedArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
volatileByteLength
(
)
;
return
WasmMemoryCopy
<
SharedMem
<
uint8_t
*
>
RacyMemMove
>
(
cx
SharedMem
<
uint8_t
*
>
:
:
shared
(
memBase
)
memLen
dstByteOffset
srcByteOffset
len
AtomicOperations
:
:
memmoveSafeWhenRacy
)
;
}
int32_t
Instance
:
:
memCopy_m32
(
Instance
*
instance
uint32_t
dstByteOffset
uint32_t
srcByteOffset
uint32_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemCopyM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryCopy
(
cx
dstByteOffset
srcByteOffset
len
memBase
)
;
}
int32_t
Instance
:
:
memCopyShared_m32
(
Instance
*
instance
uint32_t
dstByteOffset
uint32_t
srcByteOffset
uint32_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemCopySharedM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryCopyShared
(
cx
dstByteOffset
srcByteOffset
len
memBase
)
;
}
int32_t
Instance
:
:
memCopy_m64
(
Instance
*
instance
uint64_t
dstByteOffset
uint64_t
srcByteOffset
uint64_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemCopyM64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryCopy
(
cx
dstByteOffset
srcByteOffset
len
memBase
)
;
}
int32_t
Instance
:
:
memCopyShared_m64
(
Instance
*
instance
uint64_t
dstByteOffset
uint64_t
srcByteOffset
uint64_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemCopySharedM64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryCopyShared
(
cx
dstByteOffset
srcByteOffset
len
memBase
)
;
}
template
<
typename
T
typename
F
typename
I
>
inline
int32_t
WasmMemoryFill
(
JSContext
*
cx
T
memBase
size_t
memLen
I
byteOffset
uint32_t
value
I
len
F
memSet
)
{
if
(
!
MemoryBoundsCheck
(
byteOffset
len
memLen
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
memSet
(
memBase
+
uintptr_t
(
byteOffset
)
int
(
value
)
size_t
(
len
)
)
;
return
0
;
}
template
<
typename
I
>
inline
int32_t
MemoryFill
(
JSContext
*
cx
I
byteOffset
uint32_t
value
I
len
uint8_t
*
memBase
)
{
const
WasmArrayRawBuffer
*
rawBuf
=
WasmArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
byteLength
(
)
;
return
WasmMemoryFill
(
cx
memBase
memLen
byteOffset
value
len
memset
)
;
}
template
<
typename
I
>
inline
int32_t
MemoryFillShared
(
JSContext
*
cx
I
byteOffset
uint32_t
value
I
len
uint8_t
*
memBase
)
{
const
WasmSharedArrayRawBuffer
*
rawBuf
=
WasmSharedArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
volatileByteLength
(
)
;
return
WasmMemoryFill
(
cx
SharedMem
<
uint8_t
*
>
:
:
shared
(
memBase
)
memLen
byteOffset
value
len
AtomicOperations
:
:
memsetSafeWhenRacy
)
;
}
int32_t
Instance
:
:
memFill_m32
(
Instance
*
instance
uint32_t
byteOffset
uint32_t
value
uint32_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemFillM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryFill
(
cx
byteOffset
value
len
memBase
)
;
}
int32_t
Instance
:
:
memFillShared_m32
(
Instance
*
instance
uint32_t
byteOffset
uint32_t
value
uint32_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemFillSharedM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryFillShared
(
cx
byteOffset
value
len
memBase
)
;
}
int32_t
Instance
:
:
memFill_m64
(
Instance
*
instance
uint64_t
byteOffset
uint32_t
value
uint64_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemFillM64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryFill
(
cx
byteOffset
value
len
memBase
)
;
}
int32_t
Instance
:
:
memFillShared_m64
(
Instance
*
instance
uint64_t
byteOffset
uint32_t
value
uint64_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemFillSharedM64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryFillShared
(
cx
byteOffset
value
len
memBase
)
;
}
static
bool
BoundsCheckInit
(
uint32_t
dstOffset
uint32_t
srcOffset
uint32_t
len
size_t
memLen
uint32_t
segLen
)
{
uint64_t
dstOffsetLimit
=
uint64_t
(
dstOffset
)
+
uint64_t
(
len
)
;
uint64_t
srcOffsetLimit
=
uint64_t
(
srcOffset
)
+
uint64_t
(
len
)
;
return
dstOffsetLimit
>
memLen
|
|
srcOffsetLimit
>
segLen
;
}
static
bool
BoundsCheckInit
(
uint64_t
dstOffset
uint32_t
srcOffset
uint32_t
len
size_t
memLen
uint32_t
segLen
)
{
uint64_t
dstOffsetLimit
=
dstOffset
+
uint64_t
(
len
)
;
uint64_t
srcOffsetLimit
=
uint64_t
(
srcOffset
)
+
uint64_t
(
len
)
;
return
dstOffsetLimit
<
dstOffset
|
|
dstOffsetLimit
>
memLen
|
|
srcOffsetLimit
>
segLen
;
}
template
<
typename
I
>
static
int32_t
MemoryInit
(
JSContext
*
cx
Instance
*
instance
I
dstOffset
uint32_t
srcOffset
uint32_t
len
const
DataSegment
*
maybeSeg
)
{
if
(
!
maybeSeg
)
{
if
(
len
=
=
0
&
&
srcOffset
=
=
0
)
{
return
0
;
}
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
const
DataSegment
&
seg
=
*
maybeSeg
;
MOZ_RELEASE_ASSERT
(
!
seg
.
active
(
)
)
;
const
uint32_t
segLen
=
seg
.
bytes
.
length
(
)
;
WasmMemoryObject
*
mem
=
instance
-
>
memory
(
)
;
const
size_t
memLen
=
mem
-
>
volatileMemoryLength
(
)
;
if
(
BoundsCheckInit
(
dstOffset
srcOffset
len
memLen
segLen
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
SharedMem
<
uint8_t
*
>
dataPtr
=
mem
-
>
buffer
(
)
.
dataPointerEither
(
)
;
if
(
mem
-
>
isShared
(
)
)
{
AtomicOperations
:
:
memcpySafeWhenRacy
(
dataPtr
+
uintptr_t
(
dstOffset
)
(
uint8_t
*
)
seg
.
bytes
.
begin
(
)
+
srcOffset
len
)
;
}
else
{
uint8_t
*
rawBuf
=
dataPtr
.
unwrap
(
)
;
memcpy
(
rawBuf
+
uintptr_t
(
dstOffset
)
(
const
char
*
)
seg
.
bytes
.
begin
(
)
+
srcOffset
len
)
;
}
return
0
;
}
int32_t
Instance
:
:
memInit_m32
(
Instance
*
instance
uint32_t
dstOffset
uint32_t
srcOffset
uint32_t
len
uint32_t
segIndex
)
{
MOZ_ASSERT
(
SASigMemInitM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveDataSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryInit
(
cx
instance
dstOffset
srcOffset
len
instance
-
>
passiveDataSegments_
[
segIndex
]
)
;
}
int32_t
Instance
:
:
memInit_m64
(
Instance
*
instance
uint64_t
dstOffset
uint32_t
srcOffset
uint32_t
len
uint32_t
segIndex
)
{
MOZ_ASSERT
(
SASigMemInitM64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveDataSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryInit
(
cx
instance
dstOffset
srcOffset
len
instance
-
>
passiveDataSegments_
[
segIndex
]
)
;
}
int32_t
Instance
:
:
tableCopy
(
Instance
*
instance
uint32_t
dstOffset
uint32_t
srcOffset
uint32_t
len
uint32_t
dstTableIndex
uint32_t
srcTableIndex
)
{
MOZ_ASSERT
(
SASigTableCopy
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
const
SharedTable
&
srcTable
=
instance
-
>
tables
(
)
[
srcTableIndex
]
;
uint32_t
srcTableLen
=
srcTable
-
>
length
(
)
;
const
SharedTable
&
dstTable
=
instance
-
>
tables
(
)
[
dstTableIndex
]
;
uint32_t
dstTableLen
=
dstTable
-
>
length
(
)
;
uint64_t
dstOffsetLimit
=
uint64_t
(
dstOffset
)
+
len
;
uint64_t
srcOffsetLimit
=
uint64_t
(
srcOffset
)
+
len
;
if
(
dstOffsetLimit
>
dstTableLen
|
|
srcOffsetLimit
>
srcTableLen
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
bool
isOOM
=
false
;
if
(
&
srcTable
=
=
&
dstTable
&
&
dstOffset
>
srcOffset
)
{
for
(
uint32_t
i
=
len
;
i
>
0
;
i
-
-
)
{
if
(
!
dstTable
-
>
copy
(
cx
*
srcTable
dstOffset
+
(
i
-
1
)
srcOffset
+
(
i
-
1
)
)
)
{
isOOM
=
true
;
break
;
}
}
}
else
if
(
&
srcTable
=
=
&
dstTable
&
&
dstOffset
=
=
srcOffset
)
{
}
else
{
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
!
dstTable
-
>
copy
(
cx
*
srcTable
dstOffset
+
i
srcOffset
+
i
)
)
{
isOOM
=
true
;
break
;
}
}
}
if
(
isOOM
)
{
return
-
1
;
}
return
0
;
}
bool
Instance
:
:
initElems
(
uint32_t
tableIndex
const
ElemSegment
&
seg
uint32_t
dstOffset
uint32_t
srcOffset
uint32_t
len
)
{
Table
&
table
=
*
tables_
[
tableIndex
]
;
MOZ_ASSERT
(
dstOffset
<
=
table
.
length
(
)
)
;
MOZ_ASSERT
(
len
<
=
table
.
length
(
)
-
dstOffset
)
;
Tier
tier
=
code
(
)
.
bestTier
(
)
;
const
MetadataTier
&
metadataTier
=
metadata
(
tier
)
;
const
FuncImportVector
&
funcImports
=
metadataTier
.
funcImports
;
const
CodeRangeVector
&
codeRanges
=
metadataTier
.
codeRanges
;
const
Uint32Vector
&
funcToCodeRange
=
metadataTier
.
funcToCodeRange
;
const
Uint32Vector
&
elemFuncIndices
=
seg
.
elemFuncIndices
;
MOZ_ASSERT
(
srcOffset
<
=
elemFuncIndices
.
length
(
)
)
;
MOZ_ASSERT
(
len
<
=
elemFuncIndices
.
length
(
)
-
srcOffset
)
;
uint8_t
*
codeBaseTier
=
codeBase
(
tier
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
uint32_t
funcIndex
=
elemFuncIndices
[
srcOffset
+
i
]
;
if
(
funcIndex
=
=
NullFuncIndex
)
{
table
.
setNull
(
dstOffset
+
i
)
;
}
else
if
(
!
table
.
isFunction
(
)
)
{
void
*
fnref
=
Instance
:
:
refFunc
(
this
funcIndex
)
;
if
(
fnref
=
=
AnyRef
:
:
invalid
(
)
.
forCompiledCode
(
)
)
{
return
false
;
}
table
.
fillAnyRef
(
dstOffset
+
i
1
AnyRef
:
:
fromCompiledCode
(
fnref
)
)
;
}
else
{
if
(
funcIndex
<
metadataTier
.
funcImports
.
length
(
)
)
{
FuncImportInstanceData
&
import
=
funcImportInstanceData
(
funcImports
[
funcIndex
]
)
;
MOZ_ASSERT
(
import
.
callable
-
>
isCallable
(
)
)
;
if
(
import
.
callable
-
>
is
<
JSFunction
>
(
)
)
{
JSFunction
*
fun
=
&
import
.
callable
-
>
as
<
JSFunction
>
(
)
;
if
(
IsWasmExportedFunction
(
fun
)
)
{
WasmInstanceObject
*
calleeInstanceObj
=
ExportedFunctionToInstanceObject
(
fun
)
;
Instance
&
calleeInstance
=
calleeInstanceObj
-
>
instance
(
)
;
Tier
calleeTier
=
calleeInstance
.
code
(
)
.
bestTier
(
)
;
const
CodeRange
&
calleeCodeRange
=
calleeInstanceObj
-
>
getExportedFunctionCodeRange
(
fun
calleeTier
)
;
void
*
code
=
calleeInstance
.
codeBase
(
calleeTier
)
+
calleeCodeRange
.
funcCheckedCallEntry
(
)
;
table
.
setFuncRef
(
dstOffset
+
i
code
&
calleeInstance
)
;
continue
;
}
}
}
void
*
code
=
codeBaseTier
+
codeRanges
[
funcToCodeRange
[
funcIndex
]
]
.
funcCheckedCallEntry
(
)
;
table
.
setFuncRef
(
dstOffset
+
i
code
this
)
;
}
}
return
true
;
}
int32_t
Instance
:
:
tableInit
(
Instance
*
instance
uint32_t
dstOffset
uint32_t
srcOffset
uint32_t
len
uint32_t
segIndex
uint32_t
tableIndex
)
{
MOZ_ASSERT
(
SASigTableInit
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveElemSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
if
(
!
instance
-
>
passiveElemSegments_
[
segIndex
]
)
{
if
(
len
=
=
0
&
&
srcOffset
=
=
0
)
{
return
0
;
}
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
const
ElemSegment
&
seg
=
*
instance
-
>
passiveElemSegments_
[
segIndex
]
;
MOZ_RELEASE_ASSERT
(
!
seg
.
active
(
)
)
;
const
uint32_t
segLen
=
seg
.
length
(
)
;
const
Table
&
table
=
*
instance
-
>
tables
(
)
[
tableIndex
]
;
const
uint32_t
tableLen
=
table
.
length
(
)
;
uint64_t
dstOffsetLimit
=
uint64_t
(
dstOffset
)
+
uint64_t
(
len
)
;
uint64_t
srcOffsetLimit
=
uint64_t
(
srcOffset
)
+
uint64_t
(
len
)
;
if
(
dstOffsetLimit
>
tableLen
|
|
srcOffsetLimit
>
segLen
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
if
(
!
instance
-
>
initElems
(
tableIndex
seg
dstOffset
srcOffset
len
)
)
{
return
-
1
;
}
return
0
;
}
int32_t
Instance
:
:
tableFill
(
Instance
*
instance
uint32_t
start
void
*
value
uint32_t
len
uint32_t
tableIndex
)
{
MOZ_ASSERT
(
SASigTableFill
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
Table
&
table
=
*
instance
-
>
tables
(
)
[
tableIndex
]
;
uint64_t
offsetLimit
=
uint64_t
(
start
)
+
uint64_t
(
len
)
;
if
(
offsetLimit
>
table
.
length
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
switch
(
table
.
repr
(
)
)
{
case
TableRepr
:
:
Ref
:
table
.
fillAnyRef
(
start
len
AnyRef
:
:
fromCompiledCode
(
value
)
)
;
break
;
case
TableRepr
:
:
Func
:
MOZ_RELEASE_ASSERT
(
!
table
.
isAsmJS
(
)
)
;
table
.
fillFuncRef
(
start
len
FuncRef
:
:
fromCompiledCode
(
value
)
cx
)
;
break
;
}
return
0
;
}
template
<
typename
I
>
static
bool
WasmDiscardCheck
(
Instance
*
instance
I
byteOffset
I
byteLen
size_t
memLen
bool
shared
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
if
(
byteOffset
%
wasm
:
:
PageSize
!
=
0
|
|
byteLen
%
wasm
:
:
PageSize
!
=
0
)
{
ReportTrapError
(
cx
JSMSG_WASM_UNALIGNED_ACCESS
)
;
return
false
;
}
if
(
!
MemoryBoundsCheck
(
byteOffset
byteLen
memLen
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
false
;
}
return
true
;
}
template
<
typename
I
>
static
int32_t
MemDiscardNotShared
(
Instance
*
instance
I
byteOffset
I
byteLen
uint8_t
*
memBase
)
{
WasmArrayRawBuffer
*
rawBuf
=
WasmArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
byteLength
(
)
;
if
(
!
WasmDiscardCheck
(
instance
byteOffset
byteLen
memLen
false
)
)
{
return
-
1
;
}
rawBuf
-
>
discard
(
byteOffset
byteLen
)
;
return
0
;
}
template
<
typename
I
>
static
int32_t
MemDiscardShared
(
Instance
*
instance
I
byteOffset
I
byteLen
uint8_t
*
memBase
)
{
WasmSharedArrayRawBuffer
*
rawBuf
=
WasmSharedArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
volatileByteLength
(
)
;
if
(
!
WasmDiscardCheck
(
instance
byteOffset
byteLen
memLen
true
)
)
{
return
-
1
;
}
rawBuf
-
>
discard
(
byteOffset
byteLen
)
;
return
0
;
}
int32_t
Instance
:
:
memDiscard_m32
(
Instance
*
instance
uint32_t
byteOffset
uint32_t
byteLen
uint8_t
*
memBase
)
{
return
MemDiscardNotShared
(
instance
byteOffset
byteLen
memBase
)
;
}
int32_t
Instance
:
:
memDiscard_m64
(
Instance
*
instance
uint64_t
byteOffset
uint64_t
byteLen
uint8_t
*
memBase
)
{
return
MemDiscardNotShared
(
instance
byteOffset
byteLen
memBase
)
;
}
int32_t
Instance
:
:
memDiscardShared_m32
(
Instance
*
instance
uint32_t
byteOffset
uint32_t
byteLen
uint8_t
*
memBase
)
{
return
MemDiscardShared
(
instance
byteOffset
byteLen
memBase
)
;
}
int32_t
Instance
:
:
memDiscardShared_m64
(
Instance
*
instance
uint64_t
byteOffset
uint64_t
byteLen
uint8_t
*
memBase
)
{
return
MemDiscardShared
(
instance
byteOffset
byteLen
memBase
)
;
}
void
*
Instance
:
:
tableGet
(
Instance
*
instance
uint32_t
index
uint32_t
tableIndex
)
{
MOZ_ASSERT
(
SASigTableGet
.
failureMode
=
=
FailureMode
:
:
FailOnInvalidRef
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
const
Table
&
table
=
*
instance
-
>
tables
(
)
[
tableIndex
]
;
if
(
index
>
=
table
.
length
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_TABLE_OUT_OF_BOUNDS
)
;
return
AnyRef
:
:
invalid
(
)
.
forCompiledCode
(
)
;
}
switch
(
table
.
repr
(
)
)
{
case
TableRepr
:
:
Ref
:
return
table
.
getAnyRef
(
index
)
.
forCompiledCode
(
)
;
case
TableRepr
:
:
Func
:
{
MOZ_RELEASE_ASSERT
(
!
table
.
isAsmJS
(
)
)
;
RootedFunction
fun
(
cx
)
;
if
(
!
table
.
getFuncRef
(
cx
index
&
fun
)
)
{
return
AnyRef
:
:
invalid
(
)
.
forCompiledCode
(
)
;
}
return
FuncRef
:
:
fromJSFunction
(
fun
)
.
forCompiledCode
(
)
;
}
}
MOZ_CRASH
(
"
Should
not
happen
"
)
;
}
uint32_t
Instance
:
:
tableGrow
(
Instance
*
instance
void
*
initValue
uint32_t
delta
uint32_t
tableIndex
)
{
MOZ_ASSERT
(
SASigTableGrow
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
RootedAnyRef
ref
(
cx
AnyRef
:
:
fromCompiledCode
(
initValue
)
)
;
Table
&
table
=
*
instance
-
>
tables
(
)
[
tableIndex
]
;
uint32_t
oldSize
=
table
.
grow
(
delta
)
;
if
(
oldSize
!
=
uint32_t
(
-
1
)
&
&
initValue
!
=
nullptr
)
{
switch
(
table
.
repr
(
)
)
{
case
TableRepr
:
:
Ref
:
table
.
fillAnyRef
(
oldSize
delta
ref
)
;
break
;
case
TableRepr
:
:
Func
:
MOZ_RELEASE_ASSERT
(
!
table
.
isAsmJS
(
)
)
;
table
.
fillFuncRef
(
oldSize
delta
FuncRef
:
:
fromAnyRefUnchecked
(
ref
)
cx
)
;
break
;
}
}
return
oldSize
;
}
int32_t
Instance
:
:
tableSet
(
Instance
*
instance
uint32_t
index
void
*
value
uint32_t
tableIndex
)
{
MOZ_ASSERT
(
SASigTableSet
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
Table
&
table
=
*
instance
-
>
tables
(
)
[
tableIndex
]
;
if
(
index
>
=
table
.
length
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_TABLE_OUT_OF_BOUNDS
)
;
return
-
1
;
}
switch
(
table
.
repr
(
)
)
{
case
TableRepr
:
:
Ref
:
table
.
fillAnyRef
(
index
1
AnyRef
:
:
fromCompiledCode
(
value
)
)
;
break
;
case
TableRepr
:
:
Func
:
MOZ_RELEASE_ASSERT
(
!
table
.
isAsmJS
(
)
)
;
table
.
fillFuncRef
(
index
1
FuncRef
:
:
fromCompiledCode
(
value
)
cx
)
;
break
;
}
return
0
;
}
uint32_t
Instance
:
:
tableSize
(
Instance
*
instance
uint32_t
tableIndex
)
{
MOZ_ASSERT
(
SASigTableSize
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
Table
&
table
=
*
instance
-
>
tables
(
)
[
tableIndex
]
;
return
table
.
length
(
)
;
}
void
*
Instance
:
:
refFunc
(
Instance
*
instance
uint32_t
funcIndex
)
{
MOZ_ASSERT
(
SASigRefFunc
.
failureMode
=
=
FailureMode
:
:
FailOnInvalidRef
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
Tier
tier
=
instance
-
>
code
(
)
.
bestTier
(
)
;
const
MetadataTier
&
metadataTier
=
instance
-
>
metadata
(
tier
)
;
const
FuncImportVector
&
funcImports
=
metadataTier
.
funcImports
;
if
(
funcIndex
<
funcImports
.
length
(
)
)
{
FuncImportInstanceData
&
import
=
instance
-
>
funcImportInstanceData
(
funcImports
[
funcIndex
]
)
;
if
(
import
.
callable
-
>
is
<
JSFunction
>
(
)
)
{
JSFunction
*
fun
=
&
import
.
callable
-
>
as
<
JSFunction
>
(
)
;
if
(
IsWasmExportedFunction
(
fun
)
)
{
return
FuncRef
:
:
fromJSFunction
(
fun
)
.
forCompiledCode
(
)
;
}
}
}
RootedFunction
fun
(
cx
)
;
Rooted
<
WasmInstanceObject
*
>
instanceObj
(
cx
instance
-
>
object
(
)
)
;
if
(
!
WasmInstanceObject
:
:
getExportedFunction
(
cx
instanceObj
funcIndex
&
fun
)
)
{
ReportOutOfMemory
(
cx
)
;
return
AnyRef
:
:
invalid
(
)
.
forCompiledCode
(
)
;
}
return
FuncRef
:
:
fromJSFunction
(
fun
)
.
forCompiledCode
(
)
;
}
int32_t
Instance
:
:
elemDrop
(
Instance
*
instance
uint32_t
segIndex
)
{
MOZ_ASSERT
(
SASigElemDrop
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveElemSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
if
(
!
instance
-
>
passiveElemSegments_
[
segIndex
]
)
{
return
0
;
}
SharedElemSegment
&
segRefPtr
=
instance
-
>
passiveElemSegments_
[
segIndex
]
;
MOZ_RELEASE_ASSERT
(
!
segRefPtr
-
>
active
(
)
)
;
segRefPtr
=
nullptr
;
return
0
;
}
int32_t
Instance
:
:
dataDrop
(
Instance
*
instance
uint32_t
segIndex
)
{
MOZ_ASSERT
(
SASigDataDrop
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveDataSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
if
(
!
instance
-
>
passiveDataSegments_
[
segIndex
]
)
{
return
0
;
}
SharedDataSegment
&
segRefPtr
=
instance
-
>
passiveDataSegments_
[
segIndex
]
;
MOZ_RELEASE_ASSERT
(
!
segRefPtr
-
>
active
(
)
)
;
segRefPtr
=
nullptr
;
return
0
;
}
void
Instance
:
:
postBarrier
(
Instance
*
instance
gc
:
:
Cell
*
*
location
)
{
MOZ_ASSERT
(
SASigPostBarrier
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
MOZ_ASSERT
(
location
)
;
instance
-
>
storeBuffer_
-
>
putCell
(
reinterpret_cast
<
JSObject
*
*
>
(
location
)
)
;
}
void
Instance
:
:
postBarrierPrecise
(
Instance
*
instance
JSObject
*
*
location
JSObject
*
prev
)
{
MOZ_ASSERT
(
SASigPostBarrierPrecise
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
postBarrierPreciseWithOffset
(
instance
location
0
prev
)
;
}
void
Instance
:
:
postBarrierPreciseWithOffset
(
Instance
*
instance
JSObject
*
*
base
uint32_t
offset
JSObject
*
prev
)
{
MOZ_ASSERT
(
SASigPostBarrierPreciseWithOffset
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
MOZ_ASSERT
(
base
)
;
JSObject
*
*
location
=
(
JSObject
*
*
)
(
uintptr_t
(
base
)
+
size_t
(
offset
)
)
;
JSObject
*
next
=
*
location
;
JSObject
:
:
postWriteBarrier
(
location
prev
next
)
;
}
void
*
Instance
:
:
structNew
(
Instance
*
instance
TypeDefInstanceData
*
typeDefData
)
{
MOZ_ASSERT
(
SASigStructNew
.
failureMode
=
=
FailureMode
:
:
FailOnNullPtr
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
WasmStructObject
:
:
createStruct
<
true
>
(
cx
typeDefData
typeDefData
-
>
allocSite
.
initialHeap
(
)
)
;
}
void
*
Instance
:
:
structNewUninit
(
Instance
*
instance
TypeDefInstanceData
*
typeDefData
)
{
MOZ_ASSERT
(
SASigStructNew
.
failureMode
=
=
FailureMode
:
:
FailOnNullPtr
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
WasmStructObject
:
:
createStruct
<
false
>
(
cx
typeDefData
typeDefData
-
>
allocSite
.
initialHeap
(
)
)
;
}
void
*
Instance
:
:
arrayNew
(
Instance
*
instance
uint32_t
numElements
TypeDefInstanceData
*
typeDefData
)
{
MOZ_ASSERT
(
SASigArrayNew
.
failureMode
=
=
FailureMode
:
:
FailOnNullPtr
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
WasmArrayObject
:
:
createArray
<
true
>
(
cx
typeDefData
typeDefData
-
>
allocSite
.
initialHeap
(
)
numElements
)
;
}
void
*
Instance
:
:
arrayNewUninit
(
Instance
*
instance
uint32_t
numElements
TypeDefInstanceData
*
typeDefData
)
{
MOZ_ASSERT
(
SASigArrayNew
.
failureMode
=
=
FailureMode
:
:
FailOnNullPtr
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
WasmArrayObject
:
:
createArray
<
false
>
(
cx
typeDefData
typeDefData
-
>
allocSite
.
initialHeap
(
)
numElements
)
;
}
void
*
Instance
:
:
arrayNewData
(
Instance
*
instance
uint32_t
segByteOffset
uint32_t
numElements
TypeDefInstanceData
*
typeDefData
uint32_t
segIndex
)
{
MOZ_ASSERT
(
SASigArrayNewData
.
failureMode
=
=
FailureMode
:
:
FailOnNullPtr
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveDataSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
const
DataSegment
*
seg
=
instance
-
>
passiveDataSegments_
[
segIndex
]
;
if
(
!
seg
&
&
(
numElements
!
=
0
|
|
segByteOffset
!
=
0
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
nullptr
;
}
const
TypeDef
*
typeDef
=
typeDefData
-
>
typeDef
;
Rooted
<
WasmArrayObject
*
>
arrayObj
(
cx
WasmArrayObject
:
:
createArray
(
cx
typeDefData
typeDefData
-
>
allocSite
.
initialHeap
(
)
numElements
)
)
;
if
(
!
arrayObj
)
{
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
arrayObj
-
>
is
<
WasmArrayObject
>
(
)
)
;
if
(
!
seg
)
{
return
arrayObj
;
}
CheckedUint32
numBytesToCopy
=
CheckedUint32
(
numElements
)
*
CheckedUint32
(
typeDef
-
>
arrayType
(
)
.
elementType_
.
size
(
)
)
;
if
(
!
numBytesToCopy
.
isValid
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
nullptr
;
}
CheckedUint32
lastByteOffsetPlus1
=
CheckedUint32
(
segByteOffset
)
+
numBytesToCopy
;
CheckedUint32
numBytesAvailable
(
seg
-
>
bytes
.
length
(
)
)
;
if
(
!
lastByteOffsetPlus1
.
isValid
(
)
|
|
!
numBytesAvailable
.
isValid
(
)
|
|
lastByteOffsetPlus1
.
value
(
)
>
numBytesAvailable
.
value
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
nullptr
;
}
memcpy
(
arrayObj
-
>
data_
&
seg
-
>
bytes
[
segByteOffset
]
size_t
(
numBytesToCopy
.
value
(
)
)
)
;
return
arrayObj
;
}
void
*
Instance
:
:
arrayNewElem
(
Instance
*
instance
uint32_t
segElemIndex
uint32_t
numElements
TypeDefInstanceData
*
typeDefData
uint32_t
segIndex
)
{
MOZ_ASSERT
(
SASigArrayNewElem
.
failureMode
=
=
FailureMode
:
:
FailOnNullPtr
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveElemSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
const
ElemSegment
*
seg
=
instance
-
>
passiveElemSegments_
[
segIndex
]
;
if
(
!
seg
&
&
(
numElements
!
=
0
|
|
segElemIndex
!
=
0
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
nullptr
;
}
const
TypeDef
*
typeDef
=
typeDefData
-
>
typeDef
;
MOZ_RELEASE_ASSERT
(
typeDef
-
>
arrayType
(
)
.
elementType_
.
size
(
)
=
=
sizeof
(
void
*
)
)
;
Rooted
<
WasmArrayObject
*
>
arrayObj
(
cx
WasmArrayObject
:
:
createArray
(
cx
typeDefData
typeDefData
-
>
allocSite
.
initialHeap
(
)
numElements
)
)
;
if
(
!
arrayObj
)
{
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
arrayObj
-
>
is
<
WasmArrayObject
>
(
)
)
;
if
(
!
seg
)
{
return
arrayObj
;
}
CheckedUint32
lastIndexPlus1
=
CheckedUint32
(
segElemIndex
)
+
CheckedUint32
(
numElements
)
;
CheckedUint32
numElemsAvailable
(
seg
-
>
elemFuncIndices
.
length
(
)
)
;
if
(
!
lastIndexPlus1
.
isValid
(
)
|
|
!
numElemsAvailable
.
isValid
(
)
|
|
lastIndexPlus1
.
value
(
)
>
numElemsAvailable
.
value
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
nullptr
;
}
void
*
*
dst
=
(
void
*
*
)
arrayObj
-
>
data_
;
const
uint32_t
*
src
=
&
seg
-
>
elemFuncIndices
[
segElemIndex
]
;
for
(
uint32_t
i
=
0
;
i
<
numElements
;
i
+
+
)
{
uint32_t
funcIndex
=
src
[
i
]
;
FieldType
elemType
=
typeDef
-
>
arrayType
(
)
.
elementType_
;
MOZ_RELEASE_ASSERT
(
elemType
.
isRefType
(
)
)
;
RootedVal
value
(
cx
elemType
.
refType
(
)
)
;
if
(
funcIndex
=
=
NullFuncIndex
)
{
}
else
{
void
*
funcRef
=
Instance
:
:
refFunc
(
instance
funcIndex
)
;
if
(
funcRef
=
=
AnyRef
:
:
invalid
(
)
.
forCompiledCode
(
)
)
{
return
nullptr
;
}
value
=
Val
(
elemType
.
refType
(
)
FuncRef
:
:
fromCompiledCode
(
funcRef
)
)
;
}
value
.
get
(
)
.
writeToHeapLocation
(
&
dst
[
i
]
)
;
}
return
arrayObj
;
}
int32_t
Instance
:
:
arrayCopy
(
Instance
*
instance
void
*
dstArray
uint32_t
dstIndex
void
*
srcArray
uint32_t
srcIndex
uint32_t
numElements
uint32_t
elementSize
)
{
MOZ_ASSERT
(
SASigArrayCopy
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
if
(
!
srcArray
|
|
!
dstArray
)
{
ReportTrapError
(
cx
JSMSG_WASM_DEREF_NULL
)
;
return
-
1
;
}
bool
elemsAreRefTyped
=
false
;
if
(
int32_t
(
elementSize
)
<
0
)
{
elemsAreRefTyped
=
true
;
elementSize
=
uint32_t
(
-
int32_t
(
elementSize
)
)
;
}
MOZ_ASSERT
(
elementSize
>
=
1
&
&
elementSize
<
=
16
)
;
Rooted
<
WasmArrayObject
*
>
dstArrayObj
(
cx
static_cast
<
WasmArrayObject
*
>
(
dstArray
)
)
;
MOZ_RELEASE_ASSERT
(
dstArrayObj
-
>
is
<
WasmArrayObject
>
(
)
)
;
Rooted
<
WasmArrayObject
*
>
srcArrayObj
(
cx
static_cast
<
WasmArrayObject
*
>
(
srcArray
)
)
;
MOZ_RELEASE_ASSERT
(
srcArrayObj
-
>
is
<
WasmArrayObject
>
(
)
)
;
STATIC_ASSERT_WASMARRAYELEMENTS_NUMELEMENTS_IS_U32
;
uint64_t
dstNumElements
=
uint64_t
(
dstArrayObj
-
>
numElements_
)
;
if
(
uint64_t
(
dstIndex
)
+
uint64_t
(
numElements
)
>
dstNumElements
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
uint64_t
srcNumElements
=
uint64_t
(
srcArrayObj
-
>
numElements_
)
;
if
(
uint64_t
(
srcIndex
)
+
uint64_t
(
numElements
)
>
srcNumElements
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
uint64_t
numBytesToCopy
=
uint64_t
(
numElements
)
*
uint64_t
(
elementSize
)
;
#
ifndef
JS_64BIT
if
(
numBytesToCopy
>
uint64_t
(
UINT32_MAX
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
#
endif
uint8_t
*
srcBase
=
srcArrayObj
-
>
data_
;
uint8_t
*
dstBase
=
dstArrayObj
-
>
data_
;
srcBase
+
=
size_t
(
srcIndex
)
*
size_t
(
elementSize
)
;
dstBase
+
=
size_t
(
dstIndex
)
*
size_t
(
elementSize
)
;
if
(
numBytesToCopy
=
=
0
|
|
srcBase
=
=
dstBase
)
{
return
0
;
}
if
(
!
elemsAreRefTyped
)
{
memmove
(
dstBase
srcBase
size_t
(
numBytesToCopy
)
)
;
return
0
;
}
uint8_t
*
nextSrc
;
uint8_t
*
nextDst
;
intptr_t
step
;
if
(
dstBase
<
srcBase
)
{
step
=
intptr_t
(
elementSize
)
;
nextSrc
=
srcBase
;
nextDst
=
dstBase
;
}
else
{
step
=
-
intptr_t
(
elementSize
)
;
nextSrc
=
srcBase
+
size_t
(
numBytesToCopy
)
-
size_t
(
elementSize
)
;
nextDst
=
dstBase
+
size_t
(
numBytesToCopy
)
-
size_t
(
elementSize
)
;
}
RefType
aRefType
=
RefType
:
:
eq
(
)
;
for
(
size_t
i
=
0
;
i
<
size_t
(
numElements
)
;
i
+
+
)
{
RootedVal
value
(
cx
aRefType
)
;
value
.
get
(
)
.
readFromHeapLocation
(
nextSrc
)
;
value
.
get
(
)
.
writeToHeapLocation
(
nextDst
)
;
nextSrc
+
=
step
;
nextDst
+
=
step
;
}
return
0
;
}
void
*
Instance
:
:
exceptionNew
(
Instance
*
instance
JSObject
*
tag
)
{
MOZ_ASSERT
(
SASigExceptionNew
.
failureMode
=
=
FailureMode
:
:
FailOnNullPtr
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
Rooted
<
WasmTagObject
*
>
tagObj
(
cx
&
tag
-
>
as
<
WasmTagObject
>
(
)
)
;
RootedObject
proto
(
cx
&
cx
-
>
global
(
)
-
>
getPrototype
(
JSProto_WasmException
)
)
;
RootedObject
stack
(
cx
nullptr
)
;
return
AnyRef
:
:
fromJSObject
(
WasmExceptionObject
:
:
create
(
cx
tagObj
stack
proto
)
)
.
forCompiledCode
(
)
;
}
int32_t
Instance
:
:
throwException
(
Instance
*
instance
JSObject
*
exn
)
{
MOZ_ASSERT
(
SASigThrowException
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
RootedValue
exnVal
(
cx
UnboxAnyRef
(
AnyRef
:
:
fromJSObject
(
exn
)
)
)
;
cx
-
>
setPendingException
(
exnVal
nullptr
)
;
return
-
1
;
}
int32_t
Instance
:
:
refTest
(
Instance
*
instance
void
*
refPtr
const
wasm
:
:
TypeDef
*
typeDef
)
{
MOZ_ASSERT
(
SASigRefTest
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
if
(
!
refPtr
)
{
return
0
;
}
JSContext
*
cx
=
instance
-
>
cx
(
)
;
ASSERT_ANYREF_IS_JSOBJECT
;
Rooted
<
WasmGcObject
*
>
ref
(
cx
(
WasmGcObject
*
)
AnyRef
:
:
fromCompiledCode
(
refPtr
)
.
asJSObject
(
)
)
;
return
int32_t
(
ref
-
>
isRuntimeSubtype
(
typeDef
)
)
;
}
int32_t
Instance
:
:
intrI8VecMul
(
Instance
*
instance
uint32_t
dest
uint32_t
src1
uint32_t
src2
uint32_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigIntrI8VecMul
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
const
WasmArrayRawBuffer
*
rawBuf
=
WasmArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
byteLength
(
)
;
uint64_t
destLimit
=
uint64_t
(
dest
)
+
uint64_t
(
len
)
;
uint64_t
src1Limit
=
uint64_t
(
src1
)
+
uint64_t
(
len
)
;
uint64_t
src2Limit
=
uint64_t
(
src2
)
+
uint64_t
(
len
)
;
if
(
destLimit
>
memLen
|
|
src1Limit
>
memLen
|
|
src2Limit
>
memLen
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
uint8_t
*
destPtr
=
&
memBase
[
dest
]
;
uint8_t
*
src1Ptr
=
&
memBase
[
src1
]
;
uint8_t
*
src2Ptr
=
&
memBase
[
src2
]
;
while
(
len
>
0
)
{
*
destPtr
=
(
*
src1Ptr
)
*
(
*
src2Ptr
)
;
destPtr
+
+
;
src1Ptr
+
+
;
src2Ptr
+
+
;
len
-
-
;
}
return
0
;
}
Instance
:
:
Instance
(
JSContext
*
cx
Handle
<
WasmInstanceObject
*
>
object
const
SharedCode
&
code
Handle
<
WasmMemoryObject
*
>
memory
SharedTableVector
&
&
tables
UniqueDebugState
maybeDebug
)
:
realm_
(
cx
-
>
realm
(
)
)
jsJitArgsRectifier_
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
.
value
)
jsJitExceptionHandler_
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getExceptionTail
(
)
.
value
)
preBarrierCode_
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
preBarrier
(
MIRType
:
:
Object
)
.
value
)
storeBuffer_
(
&
cx
-
>
runtime
(
)
-
>
gc
.
storeBuffer
(
)
)
object_
(
object
)
code_
(
std
:
:
move
(
code
)
)
memory_
(
memory
)
tables_
(
std
:
:
move
(
tables
)
)
maybeDebug_
(
std
:
:
move
(
maybeDebug
)
)
debugFilter_
(
nullptr
)
maxInitializedGlobalsIndexPlus1_
(
0
)
{
}
Instance
*
Instance
:
:
create
(
JSContext
*
cx
Handle
<
WasmInstanceObject
*
>
object
const
SharedCode
&
code
uint32_t
globalDataLength
Handle
<
WasmMemoryObject
*
>
memory
SharedTableVector
&
&
tables
UniqueDebugState
maybeDebug
)
{
void
*
base
=
js_calloc
(
alignof
(
Instance
)
+
offsetof
(
Instance
globalArea_
)
+
globalDataLength
)
;
if
(
!
base
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
void
*
aligned
=
(
void
*
)
AlignBytes
(
uintptr_t
(
base
)
alignof
(
Instance
)
)
;
auto
*
instance
=
new
(
aligned
)
Instance
(
cx
object
code
memory
std
:
:
move
(
tables
)
std
:
:
move
(
maybeDebug
)
)
;
instance
-
>
allocatedBase_
=
base
;
return
instance
;
}
void
Instance
:
:
destroy
(
Instance
*
instance
)
{
instance
-
>
~
Instance
(
)
;
js_free
(
instance
-
>
allocatedBase_
)
;
}
bool
Instance
:
:
init
(
JSContext
*
cx
const
JSObjectVector
&
funcImports
const
ValVector
&
globalImportValues
const
WasmGlobalObjectVector
&
globalObjs
const
WasmTagObjectVector
&
tagObjs
const
DataSegmentVector
&
dataSegments
const
ElemSegmentVector
&
elemSegments
)
{
MOZ_ASSERT
(
!
!
maybeDebug_
=
=
metadata
(
)
.
debugEnabled
)
;
#
ifdef
DEBUG
for
(
auto
t
:
code_
-
>
tiers
(
)
)
{
MOZ_ASSERT
(
funcImports
.
length
(
)
=
=
metadata
(
t
)
.
funcImports
.
length
(
)
)
;
}
#
endif
MOZ_ASSERT
(
tables_
.
length
(
)
=
=
metadata
(
)
.
tables
.
length
(
)
)
;
memoryBase_
=
memory_
?
memory_
-
>
buffer
(
)
.
dataPointerEither
(
)
.
unwrap
(
)
:
nullptr
;
size_t
limit
=
memory_
?
memory_
-
>
boundsCheckLimit
(
)
:
0
;
#
if
!
defined
(
JS_64BIT
)
MOZ_ASSERT
(
limit
<
=
UINT32_MAX
)
;
#
endif
boundsCheckLimit_
=
limit
;
cx_
=
cx
;
valueBoxClass_
=
&
WasmValueBox
:
:
class_
;
resetInterrupt
(
cx
)
;
jumpTable_
=
code_
-
>
tieringJumpTable
(
)
;
debugFilter_
=
nullptr
;
addressOfNeedsIncrementalBarrier_
=
cx
-
>
compartment
(
)
-
>
zone
(
)
-
>
addressOfNeedsIncrementalBarrier
(
)
;
Tier
callerTier
=
code_
-
>
bestTier
(
)
;
for
(
size_t
i
=
0
;
i
<
metadata
(
callerTier
)
.
funcImports
.
length
(
)
;
i
+
+
)
{
JSObject
*
f
=
funcImports
[
i
]
;
MOZ_ASSERT
(
f
-
>
isCallable
(
)
)
;
const
FuncImport
&
fi
=
metadata
(
callerTier
)
.
funcImports
[
i
]
;
const
FuncType
&
funcType
=
metadata
(
)
.
getFuncImportType
(
fi
)
;
FuncImportInstanceData
&
import
=
funcImportInstanceData
(
fi
)
;
import
.
callable
=
f
;
if
(
f
-
>
is
<
JSFunction
>
(
)
)
{
JSFunction
*
fun
=
&
f
-
>
as
<
JSFunction
>
(
)
;
if
(
!
isAsmJS
(
)
&
&
IsWasmExportedFunction
(
fun
)
)
{
WasmInstanceObject
*
calleeInstanceObj
=
ExportedFunctionToInstanceObject
(
fun
)
;
Instance
&
calleeInstance
=
calleeInstanceObj
-
>
instance
(
)
;
Tier
calleeTier
=
calleeInstance
.
code
(
)
.
bestTier
(
)
;
const
CodeRange
&
codeRange
=
calleeInstanceObj
-
>
getExportedFunctionCodeRange
(
&
f
-
>
as
<
JSFunction
>
(
)
calleeTier
)
;
import
.
instance
=
&
calleeInstance
;
import
.
realm
=
fun
-
>
realm
(
)
;
import
.
code
=
calleeInstance
.
codeBase
(
calleeTier
)
+
codeRange
.
funcUncheckedCallEntry
(
)
;
}
else
if
(
void
*
thunk
=
MaybeGetBuiltinThunk
(
fun
funcType
)
)
{
import
.
instance
=
this
;
import
.
realm
=
fun
-
>
realm
(
)
;
import
.
code
=
thunk
;
}
else
{
import
.
instance
=
this
;
import
.
realm
=
fun
-
>
realm
(
)
;
import
.
code
=
codeBase
(
callerTier
)
+
fi
.
interpExitCodeOffset
(
)
;
}
}
else
{
import
.
instance
=
this
;
import
.
realm
=
f
-
>
nonCCWRealm
(
)
;
import
.
code
=
codeBase
(
callerTier
)
+
fi
.
interpExitCodeOffset
(
)
;
}
}
for
(
size_t
i
=
0
;
i
<
tables_
.
length
(
)
;
i
+
+
)
{
const
TableDesc
&
td
=
metadata
(
)
.
tables
[
i
]
;
TableInstanceData
&
table
=
tableInstanceData
(
td
)
;
table
.
length
=
tables_
[
i
]
-
>
length
(
)
;
table
.
elements
=
tables_
[
i
]
-
>
instanceElements
(
)
;
}
for
(
size_t
i
=
0
;
i
<
metadata
(
)
.
tags
.
length
(
)
;
i
+
+
)
{
const
TagDesc
&
td
=
metadata
(
)
.
tags
[
i
]
;
MOZ_ASSERT
(
td
.
globalDataOffset
!
=
UINT32_MAX
)
;
MOZ_ASSERT
(
tagObjs
[
i
]
!
=
nullptr
)
;
tagInstanceData
(
td
)
=
tagObjs
[
i
]
;
}
pendingException_
=
nullptr
;
pendingExceptionTag_
=
nullptr
;
if
(
metadata
(
)
.
debugEnabled
)
{
size_t
numFuncs
=
metadata
(
)
.
debugNumFuncs
(
)
;
size_t
numWords
=
std
:
:
max
<
size_t
>
(
(
numFuncs
+
31
)
/
32
1
)
;
debugFilter_
=
(
uint32_t
*
)
js_calloc
(
numWords
sizeof
(
uint32_t
)
)
;
if
(
!
debugFilter_
)
{
return
false
;
}
}
if
(
memory_
&
&
memory_
-
>
movingGrowable
(
)
&
&
!
memory_
-
>
addMovingGrowObserver
(
cx
object_
)
)
{
return
false
;
}
for
(
const
SharedTable
&
table
:
tables_
)
{
if
(
table
-
>
movingGrowable
(
)
&
&
!
table
-
>
addMovingGrowObserver
(
cx
object_
)
)
{
return
false
;
}
}
const
SharedTypeContext
&
types
=
metadata
(
)
.
types
;
Zone
*
zone
=
realm
(
)
-
>
zone
(
)
;
for
(
uint32_t
typeIndex
=
0
;
typeIndex
<
types
-
>
length
(
)
;
typeIndex
+
+
)
{
const
TypeDef
&
typeDef
=
types
-
>
type
(
typeIndex
)
;
TypeDefInstanceData
*
typeDefData
=
typeDefInstanceData
(
typeIndex
)
;
new
(
typeDefData
)
TypeDefInstanceData
(
)
;
typeDefData
-
>
typeDef
=
&
typeDef
;
if
(
typeDef
.
kind
(
)
=
=
TypeDefKind
:
:
Struct
|
|
typeDef
.
kind
(
)
=
=
TypeDefKind
:
:
Array
)
{
const
JSClass
*
clasp
;
gc
:
:
AllocKind
allocKind
;
if
(
typeDef
.
kind
(
)
=
=
TypeDefKind
:
:
Struct
)
{
clasp
=
WasmStructObject
:
:
classForTypeDef
(
&
typeDef
)
;
allocKind
=
WasmStructObject
:
:
allocKindForTypeDef
(
&
typeDef
)
;
}
else
{
clasp
=
&
WasmArrayObject
:
:
class_
;
allocKind
=
WasmArrayObject
:
:
allocKind
(
)
;
}
if
(
CanChangeToBackgroundAllocKind
(
allocKind
clasp
)
)
{
allocKind
=
ForegroundToBackgroundAllocKind
(
allocKind
)
;
}
typeDefData
-
>
shape
=
WasmGCShape
:
:
getShape
(
cx
clasp
cx
-
>
realm
(
)
TaggedProto
(
)
&
typeDef
.
recGroup
(
)
ObjectFlags
(
)
)
;
if
(
!
typeDefData
-
>
shape
)
{
return
false
;
}
typeDefData
-
>
clasp
=
clasp
;
typeDefData
-
>
allocKind
=
allocKind
;
typeDefData
-
>
allocSite
.
initWasm
(
zone
)
;
}
else
if
(
typeDef
.
kind
(
)
=
=
TypeDefKind
:
:
Func
)
{
}
else
{
MOZ_ASSERT
(
typeDef
.
kind
(
)
=
=
TypeDefKind
:
:
None
)
;
MOZ_CRASH
(
)
;
}
}
maxInitializedGlobalsIndexPlus1_
=
0
;
for
(
size_t
i
=
0
;
i
<
metadata
(
)
.
globals
.
length
(
)
;
i
+
+
maxInitializedGlobalsIndexPlus1_
=
i
)
{
const
GlobalDesc
&
global
=
metadata
(
)
.
globals
[
i
]
;
if
(
global
.
isConstant
(
)
)
{
continue
;
}
uint8_t
*
globalAddr
=
globalData
(
)
+
global
.
offset
(
)
;
switch
(
global
.
kind
(
)
)
{
case
GlobalKind
:
:
Import
:
{
size_t
imported
=
global
.
importIndex
(
)
;
if
(
global
.
isIndirect
(
)
)
{
*
(
void
*
*
)
globalAddr
=
(
void
*
)
&
globalObjs
[
imported
]
-
>
val
(
)
.
get
(
)
.
cell
(
)
;
}
else
{
globalImportValues
[
imported
]
.
writeToHeapLocation
(
globalAddr
)
;
}
break
;
}
case
GlobalKind
:
:
Variable
:
{
RootedVal
val
(
cx
)
;
const
InitExpr
&
init
=
global
.
initExpr
(
)
;
Rooted
<
WasmInstanceObject
*
>
instanceObj
(
cx
object
(
)
)
;
if
(
!
init
.
evaluate
(
cx
instanceObj
&
val
)
)
{
return
false
;
}
if
(
global
.
isIndirect
(
)
)
{
wasm
:
:
GCPtrVal
&
cell
=
globalObjs
[
i
]
-
>
val
(
)
;
cell
=
val
.
get
(
)
;
void
*
address
=
(
void
*
)
&
cell
.
get
(
)
.
cell
(
)
;
*
(
void
*
*
)
globalAddr
=
address
;
}
else
{
val
.
get
(
)
.
writeToHeapLocation
(
globalAddr
)
;
}
break
;
}
case
GlobalKind
:
:
Constant
:
{
MOZ_CRASH
(
"
skipped
at
the
top
"
)
;
}
}
}
MOZ_ASSERT
(
maxInitializedGlobalsIndexPlus1_
=
=
metadata
(
)
.
globals
.
length
(
)
)
;
if
(
!
passiveDataSegments_
.
resize
(
dataSegments
.
length
(
)
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
dataSegments
.
length
(
)
;
i
+
+
)
{
if
(
!
dataSegments
[
i
]
-
>
active
(
)
)
{
passiveDataSegments_
[
i
]
=
dataSegments
[
i
]
;
}
}
if
(
!
passiveElemSegments_
.
resize
(
elemSegments
.
length
(
)
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
elemSegments
.
length
(
)
;
i
+
+
)
{
if
(
elemSegments
[
i
]
-
>
kind
=
=
ElemSegment
:
:
Kind
:
:
Passive
)
{
passiveElemSegments_
[
i
]
=
elemSegments
[
i
]
;
}
}
return
true
;
}
Instance
:
:
~
Instance
(
)
{
realm_
-
>
wasm
.
unregisterInstance
(
*
this
)
;
if
(
debugFilter_
)
{
js_free
(
debugFilter_
)
;
}
MOZ_ASSERT
(
!
pendingException_
)
;
}
void
Instance
:
:
setInterrupt
(
)
{
interrupt_
=
true
;
stackLimit_
=
JS
:
:
NativeStackLimitMin
;
}
bool
Instance
:
:
isInterrupted
(
)
const
{
return
interrupt_
|
|
stackLimit_
=
=
JS
:
:
NativeStackLimitMin
;
}
void
Instance
:
:
resetInterrupt
(
JSContext
*
cx
)
{
interrupt_
=
false
;
stackLimit_
=
cx
-
>
stackLimitForJitCode
(
JS
:
:
StackForUntrustedScript
)
;
}
bool
Instance
:
:
debugFilter
(
uint32_t
funcIndex
)
const
{
return
(
debugFilter_
[
funcIndex
/
32
]
>
>
funcIndex
%
32
)
&
1
;
}
void
Instance
:
:
setDebugFilter
(
uint32_t
funcIndex
bool
value
)
{
if
(
value
)
{
debugFilter_
[
funcIndex
/
32
]
|
=
(
1
<
<
funcIndex
%
32
)
;
}
else
{
debugFilter_
[
funcIndex
/
32
]
&
=
~
(
1
<
<
funcIndex
%
32
)
;
}
}
size_t
Instance
:
:
memoryMappedSize
(
)
const
{
return
memory_
-
>
buffer
(
)
.
wasmMappedSize
(
)
;
}
bool
Instance
:
:
memoryAccessInGuardRegion
(
const
uint8_t
*
addr
unsigned
numBytes
)
const
{
MOZ_ASSERT
(
numBytes
>
0
)
;
if
(
!
metadata
(
)
.
usesMemory
(
)
)
{
return
false
;
}
uint8_t
*
base
=
memoryBase
(
)
.
unwrap
(
)
;
if
(
addr
<
base
)
{
return
false
;
}
size_t
lastByteOffset
=
addr
-
base
+
(
numBytes
-
1
)
;
return
lastByteOffset
>
=
memory
(
)
-
>
volatileMemoryLength
(
)
&
&
lastByteOffset
<
memoryMappedSize
(
)
;
}
void
Instance
:
:
tracePrivate
(
JSTracer
*
trc
)
{
MOZ_ASSERT_IF
(
trc
-
>
isMarkingTracer
(
)
gc
:
:
IsMarked
(
trc
-
>
runtime
(
)
object_
)
)
;
TraceEdge
(
trc
&
object_
"
wasm
instance
object
"
)
;
for
(
const
FuncImport
&
fi
:
metadata
(
code
(
)
.
stableTier
(
)
)
.
funcImports
)
{
TraceNullableEdge
(
trc
&
funcImportInstanceData
(
fi
)
.
callable
"
wasm
import
"
)
;
}
for
(
const
SharedTable
&
table
:
tables_
)
{
table
-
>
trace
(
trc
)
;
}
for
(
const
GlobalDesc
&
global
:
code
(
)
.
metadata
(
)
.
globals
)
{
if
(
!
global
.
type
(
)
.
isRefRepr
(
)
|
|
global
.
isConstant
(
)
|
|
global
.
isIndirect
(
)
)
{
continue
;
}
GCPtr
<
JSObject
*
>
*
obj
=
(
GCPtr
<
JSObject
*
>
*
)
(
globalData
(
)
+
global
.
offset
(
)
)
;
TraceNullableEdge
(
trc
obj
"
wasm
reference
-
typed
global
"
)
;
}
for
(
const
TagDesc
&
tag
:
code
(
)
.
metadata
(
)
.
tags
)
{
TraceNullableEdge
(
trc
&
tagInstanceData
(
tag
)
"
wasm
tag
"
)
;
}
const
SharedTypeContext
&
types
=
metadata
(
)
.
types
;
for
(
uint32_t
typeIndex
=
0
;
typeIndex
<
types
-
>
length
(
)
;
typeIndex
+
+
)
{
TypeDefInstanceData
*
typeDefData
=
typeDefInstanceData
(
typeIndex
)
;
TraceNullableEdge
(
trc
&
typeDefData
-
>
shape
"
wasm
shape
"
)
;
}
TraceNullableEdge
(
trc
&
memory_
"
wasm
buffer
"
)
;
TraceNullableEdge
(
trc
&
pendingException_
"
wasm
pending
exception
value
"
)
;
TraceNullableEdge
(
trc
&
pendingExceptionTag_
"
wasm
pending
exception
tag
"
)
;
if
(
maybeDebug_
)
{
maybeDebug_
-
>
trace
(
trc
)
;
}
}
void
js
:
:
wasm
:
:
TraceInstanceEdge
(
JSTracer
*
trc
Instance
*
instance
const
char
*
name
)
{
if
(
IsTracerKind
(
trc
JS
:
:
TracerKind
:
:
Moving
)
)
{
return
;
}
JSObject
*
object
=
instance
-
>
objectUnbarriered
(
)
;
TraceManuallyBarrieredEdge
(
trc
&
object
name
)
;
}
uintptr_t
Instance
:
:
traceFrame
(
JSTracer
*
trc
const
wasm
:
:
WasmFrameIter
&
wfi
uint8_t
*
nextPC
uintptr_t
highestByteVisitedInPrevFrame
)
{
const
StackMap
*
map
=
code
(
)
.
lookupStackMap
(
nextPC
)
;
if
(
!
map
)
{
return
0
;
}
Frame
*
frame
=
wfi
.
frame
(
)
;
const
size_t
numMappedBytes
=
map
-
>
header
.
numMappedWords
*
sizeof
(
void
*
)
;
const
uintptr_t
scanStart
=
uintptr_t
(
frame
)
+
(
map
-
>
header
.
frameOffsetFromTop
*
sizeof
(
void
*
)
)
-
numMappedBytes
;
MOZ_ASSERT
(
0
=
=
scanStart
%
sizeof
(
void
*
)
)
;
#
ifndef
JS_CODEGEN_ARM64
MOZ_ASSERT_IF
(
highestByteVisitedInPrevFrame
!
=
0
highestByteVisitedInPrevFrame
+
1
=
=
scanStart
)
;
#
endif
uintptr_t
*
stackWords
=
(
uintptr_t
*
)
scanStart
;
MOZ_ASSERT_IF
(
map
-
>
header
.
numExitStubWords
>
0
stackWords
[
map
-
>
header
.
numExitStubWords
-
1
-
TrapExitDummyValueOffsetFromTop
]
=
=
TrapExitDummyValue
)
;
for
(
uint32_t
i
=
0
;
i
<
map
-
>
header
.
numMappedWords
;
i
+
+
)
{
if
(
map
-
>
getBit
(
i
)
=
=
0
)
{
continue
;
}
ASSERT_ANYREF_IS_JSOBJECT
;
MOZ_ASSERT
(
js
:
:
gc
:
:
IsCellPointerValidOrNull
(
(
const
void
*
)
stackWords
[
i
]
)
)
;
if
(
stackWords
[
i
]
)
{
TraceRoot
(
trc
(
JSObject
*
*
)
&
stackWords
[
i
]
"
Instance
:
:
traceWasmFrame
:
normal
word
"
)
;
}
}
if
(
map
-
>
header
.
hasDebugFrameWithLiveRefs
)
{
DebugFrame
*
debugFrame
=
DebugFrame
:
:
from
(
frame
)
;
char
*
debugFrameP
=
(
char
*
)
debugFrame
;
ASSERT_ANYREF_IS_JSOBJECT
;
for
(
size_t
i
=
0
;
i
<
MaxRegisterResults
;
i
+
+
)
{
if
(
debugFrame
-
>
hasSpilledRegisterRefResult
(
i
)
)
{
char
*
resultRefP
=
debugFrameP
+
DebugFrame
:
:
offsetOfRegisterResult
(
i
)
;
TraceNullableRoot
(
trc
(
JSObject
*
*
)
resultRefP
"
Instance
:
:
traceWasmFrame
:
DebugFrame
:
:
resultResults_
"
)
;
}
}
if
(
debugFrame
-
>
hasCachedReturnJSValue
(
)
)
{
char
*
cachedReturnJSValueP
=
debugFrameP
+
DebugFrame
:
:
offsetOfCachedReturnJSValue
(
)
;
TraceRoot
(
trc
(
js
:
:
Value
*
)
cachedReturnJSValueP
"
Instance
:
:
traceWasmFrame
:
DebugFrame
:
:
cachedReturnJSValue_
"
)
;
}
}
return
scanStart
+
numMappedBytes
-
1
;
}
WasmMemoryObject
*
Instance
:
:
memory
(
)
const
{
return
memory_
;
}
SharedMem
<
uint8_t
*
>
Instance
:
:
memoryBase
(
)
const
{
MOZ_ASSERT
(
metadata
(
)
.
usesMemory
(
)
)
;
MOZ_ASSERT
(
memoryBase_
=
=
memory_
-
>
buffer
(
)
.
dataPointerEither
(
)
)
;
return
memory_
-
>
buffer
(
)
.
dataPointerEither
(
)
;
}
SharedArrayRawBuffer
*
Instance
:
:
sharedMemoryBuffer
(
)
const
{
MOZ_ASSERT
(
memory_
-
>
isShared
(
)
)
;
return
memory_
-
>
sharedArrayRawBuffer
(
)
;
}
WasmInstanceObject
*
Instance
:
:
objectUnbarriered
(
)
const
{
return
object_
.
unbarrieredGet
(
)
;
}
WasmInstanceObject
*
Instance
:
:
object
(
)
const
{
return
object_
;
}
static
bool
EnsureEntryStubs
(
const
Instance
&
instance
uint32_t
funcIndex
const
FuncExport
*
*
funcExport
void
*
*
interpEntry
)
{
Tier
tier
=
instance
.
code
(
)
.
bestTier
(
)
;
size_t
funcExportIndex
;
*
funcExport
=
&
instance
.
metadata
(
tier
)
.
lookupFuncExport
(
funcIndex
&
funcExportIndex
)
;
const
FuncExport
&
fe
=
*
*
funcExport
;
if
(
fe
.
hasEagerStubs
(
)
)
{
*
interpEntry
=
instance
.
codeBase
(
tier
)
+
fe
.
eagerInterpEntryOffset
(
)
;
return
true
;
}
MOZ_ASSERT
(
!
instance
.
isAsmJS
(
)
"
only
wasm
can
lazily
export
functions
"
)
;
auto
stubs
=
instance
.
code
(
tier
)
.
lazyStubs
(
)
.
writeLock
(
)
;
*
interpEntry
=
stubs
-
>
lookupInterpEntry
(
fe
.
funcIndex
(
)
)
;
if
(
*
interpEntry
)
{
return
true
;
}
Tier
prevTier
=
tier
;
tier
=
instance
.
code
(
)
.
bestTier
(
)
;
const
Metadata
&
metadata
=
instance
.
metadata
(
)
;
const
CodeTier
&
codeTier
=
instance
.
code
(
tier
)
;
if
(
tier
=
=
prevTier
)
{
if
(
!
stubs
-
>
createOneEntryStub
(
funcExportIndex
metadata
codeTier
)
)
{
return
false
;
}
*
interpEntry
=
stubs
-
>
lookupInterpEntry
(
fe
.
funcIndex
(
)
)
;
MOZ_ASSERT
(
*
interpEntry
)
;
return
true
;
}
MOZ_RELEASE_ASSERT
(
prevTier
=
=
Tier
:
:
Baseline
&
&
tier
=
=
Tier
:
:
Optimized
)
;
auto
stubs2
=
instance
.
code
(
tier
)
.
lazyStubs
(
)
.
writeLock
(
)
;
MOZ_ASSERT
(
!
stubs2
-
>
hasEntryStub
(
fe
.
funcIndex
(
)
)
)
;
if
(
!
stubs2
-
>
createOneEntryStub
(
funcExportIndex
metadata
codeTier
)
)
{
return
false
;
}
*
interpEntry
=
stubs2
-
>
lookupInterpEntry
(
fe
.
funcIndex
(
)
)
;
MOZ_ASSERT
(
*
interpEntry
)
;
return
true
;
}
static
bool
GetInterpEntryAndEnsureStubs
(
JSContext
*
cx
Instance
&
instance
uint32_t
funcIndex
CallArgs
args
void
*
*
interpEntry
const
FuncType
*
*
funcType
)
{
const
FuncExport
*
funcExport
;
if
(
!
EnsureEntryStubs
(
instance
funcIndex
&
funcExport
interpEntry
)
)
{
return
false
;
}
*
funcType
=
&
instance
.
metadata
(
)
.
getFuncExportType
(
*
funcExport
)
;
#
ifdef
DEBUG
if
(
!
funcExport
-
>
hasEagerStubs
(
)
&
&
(
*
funcType
)
-
>
canHaveJitEntry
(
)
)
{
if
(
!
EnsureBuiltinThunksInitialized
(
)
)
{
return
false
;
}
JSFunction
&
callee
=
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
;
void
*
provisionalLazyJitEntryStub
=
ProvisionalLazyJitEntryStub
(
)
;
MOZ_ASSERT
(
provisionalLazyJitEntryStub
)
;
MOZ_ASSERT
(
callee
.
isWasmWithJitEntry
(
)
)
;
MOZ_ASSERT
(
*
callee
.
wasmJitEntry
(
)
!
=
provisionalLazyJitEntryStub
)
;
}
#
endif
return
true
;
}
bool
wasm
:
:
ResultsToJSValue
(
JSContext
*
cx
ResultType
type
void
*
registerResultLoc
Maybe
<
char
*
>
stackResultsLoc
MutableHandleValue
rval
CoercionLevel
level
)
{
if
(
type
.
empty
(
)
)
{
rval
.
setUndefined
(
)
;
return
true
;
}
static_assert
(
MaxRegisterResults
=
=
1
)
;
ABIResultIter
iter
(
type
)
;
DebugOnly
<
bool
>
usedRegisterResult
=
false
;
for
(
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
if
(
iter
.
cur
(
)
.
inRegister
(
)
)
{
MOZ_ASSERT
(
!
usedRegisterResult
)
;
if
(
!
ToJSValue
<
DebugCodegenVal
>
(
cx
registerResultLoc
iter
.
cur
(
)
.
type
(
)
rval
level
)
)
{
return
false
;
}
usedRegisterResult
=
true
;
}
}
MOZ_ASSERT
(
usedRegisterResult
)
;
MOZ_ASSERT
(
(
stackResultsLoc
.
isSome
(
)
)
=
=
(
iter
.
count
(
)
>
1
)
)
;
if
(
!
stackResultsLoc
)
{
return
true
;
}
Rooted
<
ArrayObject
*
>
array
(
cx
NewDenseEmptyArray
(
cx
)
)
;
if
(
!
array
)
{
return
false
;
}
RootedValue
tmp
(
cx
)
;
for
(
iter
.
switchToPrev
(
)
;
!
iter
.
done
(
)
;
iter
.
prev
(
)
)
{
const
ABIResult
&
result
=
iter
.
cur
(
)
;
if
(
result
.
onStack
(
)
)
{
char
*
loc
=
stackResultsLoc
.
value
(
)
+
result
.
stackOffset
(
)
;
if
(
!
ToJSValue
<
DebugCodegenVal
>
(
cx
loc
result
.
type
(
)
&
tmp
level
)
)
{
return
false
;
}
if
(
!
NewbornArrayPush
(
cx
array
tmp
)
)
{
return
false
;
}
}
else
{
if
(
!
NewbornArrayPush
(
cx
array
rval
)
)
{
return
false
;
}
}
}
rval
.
set
(
ObjectValue
(
*
array
)
)
;
return
true
;
}
class
MOZ_RAII
ReturnToJSResultCollector
{
class
MOZ_RAII
StackResultsRooter
:
public
JS
:
:
CustomAutoRooter
{
ReturnToJSResultCollector
&
collector_
;
public
:
StackResultsRooter
(
JSContext
*
cx
ReturnToJSResultCollector
&
collector
)
:
JS
:
:
CustomAutoRooter
(
cx
)
collector_
(
collector
)
{
}
void
trace
(
JSTracer
*
trc
)
final
{
for
(
ABIResultIter
iter
(
collector_
.
type_
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
ABIResult
&
result
=
iter
.
cur
(
)
;
if
(
result
.
onStack
(
)
&
&
result
.
type
(
)
.
isRefRepr
(
)
)
{
char
*
loc
=
collector_
.
stackResultsArea_
.
get
(
)
+
result
.
stackOffset
(
)
;
JSObject
*
*
refLoc
=
reinterpret_cast
<
JSObject
*
*
>
(
loc
)
;
TraceNullableRoot
(
trc
refLoc
"
StackResultsRooter
:
:
trace
"
)
;
}
}
}
}
;
friend
class
StackResultsRooter
;
ResultType
type_
;
UniquePtr
<
char
[
]
JS
:
:
FreePolicy
>
stackResultsArea_
;
Maybe
<
StackResultsRooter
>
rooter_
;
public
:
explicit
ReturnToJSResultCollector
(
const
ResultType
&
type
)
:
type_
(
type
)
{
}
;
bool
init
(
JSContext
*
cx
)
{
bool
needRooter
=
false
;
ABIResultIter
iter
(
type_
)
;
for
(
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
ABIResult
&
result
=
iter
.
cur
(
)
;
if
(
result
.
onStack
(
)
&
&
result
.
type
(
)
.
isRefRepr
(
)
)
{
needRooter
=
true
;
}
}
uint32_t
areaBytes
=
iter
.
stackBytesConsumedSoFar
(
)
;
MOZ_ASSERT_IF
(
needRooter
areaBytes
>
0
)
;
if
(
areaBytes
>
0
)
{
stackResultsArea_
=
cx
-
>
make_zeroed_pod_array
<
char
>
(
areaBytes
)
;
if
(
!
stackResultsArea_
)
{
return
false
;
}
if
(
needRooter
)
{
rooter_
.
emplace
(
cx
*
this
)
;
}
}
return
true
;
}
void
*
stackResultsArea
(
)
{
MOZ_ASSERT
(
stackResultsArea_
)
;
return
stackResultsArea_
.
get
(
)
;
}
bool
collect
(
JSContext
*
cx
void
*
registerResultLoc
MutableHandleValue
rval
CoercionLevel
level
)
{
Maybe
<
char
*
>
stackResultsLoc
=
stackResultsArea_
?
Some
(
stackResultsArea_
.
get
(
)
)
:
Nothing
(
)
;
return
ResultsToJSValue
(
cx
type_
registerResultLoc
stackResultsLoc
rval
level
)
;
}
}
;
bool
Instance
:
:
callExport
(
JSContext
*
cx
uint32_t
funcIndex
CallArgs
args
CoercionLevel
level
)
{
if
(
memory_
)
{
MOZ_RELEASE_ASSERT
(
memory_
-
>
buffer
(
)
.
dataPointerEither
(
)
=
=
memoryBase
(
)
)
;
}
void
*
interpEntry
;
const
FuncType
*
funcType
;
if
(
!
GetInterpEntryAndEnsureStubs
(
cx
*
this
funcIndex
args
&
interpEntry
&
funcType
)
)
{
return
false
;
}
if
(
level
!
=
CoercionLevel
:
:
Lossless
&
&
funcType
-
>
hasUnexposableArgOrRet
(
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_BAD_VAL_TYPE
)
;
return
false
;
}
ArgTypeVector
argTypes
(
*
funcType
)
;
ResultType
resultType
(
ResultType
:
:
Vector
(
funcType
-
>
results
(
)
)
)
;
ReturnToJSResultCollector
results
(
resultType
)
;
if
(
!
results
.
init
(
cx
)
)
{
return
false
;
}
Vector
<
ExportArg
8
>
exportArgs
(
cx
)
;
if
(
!
exportArgs
.
resize
(
std
:
:
max
<
size_t
>
(
1
argTypes
.
lengthWithStackResults
(
)
)
)
)
{
return
false
;
}
ASSERT_ANYREF_IS_JSOBJECT
;
Rooted
<
GCVector
<
JSObject
*
8
SystemAllocPolicy
>
>
refs
(
cx
)
;
DebugCodegen
(
DebugChannel
:
:
Function
"
wasm
-
function
[
%
d
]
arguments
[
"
funcIndex
)
;
RootedValue
v
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
argTypes
.
lengthWithStackResults
(
)
;
+
+
i
)
{
void
*
rawArgLoc
=
&
exportArgs
[
i
]
;
if
(
argTypes
.
isSyntheticStackResultPointerArg
(
i
)
)
{
*
reinterpret_cast
<
void
*
*
>
(
rawArgLoc
)
=
results
.
stackResultsArea
(
)
;
continue
;
}
size_t
naturalIdx
=
argTypes
.
naturalIndex
(
i
)
;
v
=
naturalIdx
<
args
.
length
(
)
?
args
[
naturalIdx
]
:
UndefinedValue
(
)
;
ValType
type
=
funcType
-
>
arg
(
naturalIdx
)
;
if
(
!
ToWebAssemblyValue
<
DebugCodegenVal
>
(
cx
v
type
rawArgLoc
true
level
)
)
{
return
false
;
}
if
(
type
.
isRefRepr
(
)
)
{
void
*
ptr
=
*
reinterpret_cast
<
void
*
*
>
(
rawArgLoc
)
;
RootedAnyRef
ref
(
cx
AnyRef
:
:
fromCompiledCode
(
ptr
)
)
;
ASSERT_ANYREF_IS_JSOBJECT
;
if
(
!
refs
.
emplaceBack
(
ref
.
get
(
)
.
asJSObject
(
)
)
)
{
return
false
;
}
DebugCodegen
(
DebugChannel
:
:
Function
"
/
(
#
%
d
)
"
int
(
refs
.
length
(
)
-
1
)
)
;
}
}
if
(
refs
.
length
(
)
>
0
)
{
DebugCodegen
(
DebugChannel
:
:
Function
"
;
"
)
;
size_t
nextRef
=
0
;
for
(
size_t
i
=
0
;
i
<
argTypes
.
lengthWithStackResults
(
)
;
+
+
i
)
{
if
(
argTypes
.
isSyntheticStackResultPointerArg
(
i
)
)
{
continue
;
}
size_t
naturalIdx
=
argTypes
.
naturalIndex
(
i
)
;
ValType
type
=
funcType
-
>
arg
(
naturalIdx
)
;
if
(
type
.
isRefRepr
(
)
)
{
void
*
*
rawArgLoc
=
(
void
*
*
)
&
exportArgs
[
i
]
;
*
rawArgLoc
=
refs
[
nextRef
+
+
]
;
DebugCodegen
(
DebugChannel
:
:
Function
"
ref
(
#
%
d
)
:
=
%
p
"
int
(
nextRef
-
1
)
*
rawArgLoc
)
;
}
}
refs
.
clear
(
)
;
}
DebugCodegen
(
DebugChannel
:
:
Function
"
]
\
n
"
)
;
MOZ_ASSERT
(
!
pendingException_
)
;
{
JitActivation
activation
(
cx
)
;
auto
funcPtr
=
JS_DATA_TO_FUNC_PTR
(
ExportFuncPtr
interpEntry
)
;
if
(
!
CALL_GENERATED_2
(
funcPtr
exportArgs
.
begin
(
)
this
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
!
pendingException_
)
;
if
(
isAsmJS
(
)
&
&
args
.
isConstructing
(
)
)
{
PlainObject
*
obj
=
NewPlainObject
(
cx
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
ObjectValue
(
*
obj
)
)
;
return
true
;
}
void
*
registerResultLoc
=
&
exportArgs
[
0
]
;
DebugCodegen
(
DebugChannel
:
:
Function
"
wasm
-
function
[
%
d
]
;
results
[
"
funcIndex
)
;
if
(
!
results
.
collect
(
cx
registerResultLoc
args
.
rval
(
)
level
)
)
{
return
false
;
}
DebugCodegen
(
DebugChannel
:
:
Function
"
]
\
n
"
)
;
return
true
;
}
static
JSObject
*
GetExceptionTag
(
JSObject
*
exn
)
{
return
exn
-
>
is
<
WasmExceptionObject
>
(
)
?
&
exn
-
>
as
<
WasmExceptionObject
>
(
)
.
tag
(
)
:
nullptr
;
}
void
Instance
:
:
setPendingException
(
HandleAnyRef
exn
)
{
pendingException_
=
exn
.
get
(
)
.
asJSObject
(
)
;
pendingExceptionTag_
=
GetExceptionTag
(
exn
.
get
(
)
.
asJSObject
(
)
)
;
}
void
Instance
:
:
constantGlobalGet
(
uint32_t
globalIndex
MutableHandleVal
result
)
{
MOZ_RELEASE_ASSERT
(
globalIndex
<
maxInitializedGlobalsIndexPlus1_
)
;
const
GlobalDesc
&
global
=
metadata
(
)
.
globals
[
globalIndex
]
;
if
(
global
.
isConstant
(
)
)
{
result
.
set
(
Val
(
global
.
constantValue
(
)
)
)
;
return
;
}
const
void
*
cell
=
addressOfGlobalCell
(
global
)
;
result
.
address
(
)
-
>
initFromHeapLocation
(
global
.
type
(
)
cell
)
;
}
bool
Instance
:
:
constantRefFunc
(
uint32_t
funcIndex
MutableHandleFuncRef
result
)
{
void
*
fnref
=
Instance
:
:
refFunc
(
this
funcIndex
)
;
if
(
fnref
=
=
AnyRef
:
:
invalid
(
)
.
forCompiledCode
(
)
)
{
return
false
;
}
result
.
set
(
FuncRef
:
:
fromCompiledCode
(
fnref
)
)
;
return
true
;
}
WasmStructObject
*
Instance
:
:
constantStructNewDefault
(
JSContext
*
cx
uint32_t
typeIndex
)
{
TypeDefInstanceData
*
typeDefData
=
typeDefInstanceData
(
typeIndex
)
;
return
WasmStructObject
:
:
createStruct
(
cx
typeDefData
gc
:
:
TenuredHeap
)
;
}
WasmArrayObject
*
Instance
:
:
constantArrayNewDefault
(
JSContext
*
cx
uint32_t
typeIndex
uint32_t
numElements
)
{
TypeDefInstanceData
*
typeDefData
=
typeDefInstanceData
(
typeIndex
)
;
return
WasmArrayObject
:
:
createArray
(
cx
typeDefData
gc
:
:
TenuredHeap
numElements
)
;
}
JSAtom
*
Instance
:
:
getFuncDisplayAtom
(
JSContext
*
cx
uint32_t
funcIndex
)
const
{
UTF8Bytes
name
;
if
(
!
metadata
(
)
.
getFuncNameBeforeLocation
(
funcIndex
&
name
)
)
{
return
nullptr
;
}
return
AtomizeUTF8Chars
(
cx
name
.
begin
(
)
name
.
length
(
)
)
;
}
void
Instance
:
:
ensureProfilingLabels
(
bool
profilingEnabled
)
const
{
return
code_
-
>
ensureProfilingLabels
(
profilingEnabled
)
;
}
void
Instance
:
:
onMovingGrowMemory
(
)
{
MOZ_ASSERT
(
!
isAsmJS
(
)
)
;
MOZ_ASSERT
(
!
memory_
-
>
isShared
(
)
)
;
ArrayBufferObject
&
buffer
=
memory_
-
>
buffer
(
)
.
as
<
ArrayBufferObject
>
(
)
;
memoryBase_
=
buffer
.
dataPointer
(
)
;
size_t
limit
=
memory_
-
>
boundsCheckLimit
(
)
;
#
if
!
defined
(
JS_64BIT
)
MOZ_ASSERT
(
limit
<
=
UINT32_MAX
)
;
#
endif
boundsCheckLimit_
=
limit
;
}
void
Instance
:
:
onMovingGrowTable
(
const
Table
*
theTable
)
{
MOZ_ASSERT
(
!
isAsmJS
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
tables_
.
length
(
)
;
i
+
+
)
{
if
(
tables_
[
i
]
=
=
theTable
)
{
TableInstanceData
&
table
=
tableInstanceData
(
metadata
(
)
.
tables
[
i
]
)
;
table
.
length
=
tables_
[
i
]
-
>
length
(
)
;
table
.
elements
=
tables_
[
i
]
-
>
instanceElements
(
)
;
}
}
}
JSString
*
Instance
:
:
createDisplayURL
(
JSContext
*
cx
)
{
if
(
metadata
(
)
.
filenameIsURL
)
{
return
NewStringCopyZ
<
CanGC
>
(
cx
metadata
(
)
.
filename
.
get
(
)
)
;
}
JSStringBuilder
result
(
cx
)
;
if
(
!
result
.
append
(
"
wasm
:
"
)
)
{
return
nullptr
;
}
if
(
const
char
*
filename
=
metadata
(
)
.
filename
.
get
(
)
)
{
JSString
*
filenamePrefix
=
EncodeURI
(
cx
filename
strlen
(
filename
)
)
;
if
(
!
filenamePrefix
)
{
if
(
cx
-
>
isThrowingOutOfMemory
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
cx
-
>
isThrowingOverRecursed
(
)
)
;
cx
-
>
clearPendingException
(
)
;
return
nullptr
;
}
if
(
!
result
.
append
(
filenamePrefix
)
)
{
return
nullptr
;
}
}
if
(
metadata
(
)
.
debugEnabled
)
{
if
(
!
result
.
append
(
"
:
"
)
)
{
return
nullptr
;
}
const
ModuleHash
&
hash
=
metadata
(
)
.
debugHash
;
for
(
unsigned
char
byte
:
hash
)
{
unsigned
char
digit1
=
byte
/
16
digit2
=
byte
%
16
;
if
(
!
result
.
append
(
(
char
)
(
digit1
<
10
?
digit1
+
'
0
'
:
digit1
+
'
a
'
-
10
)
)
)
{
return
nullptr
;
}
if
(
!
result
.
append
(
(
char
)
(
digit2
<
10
?
digit2
+
'
0
'
:
digit2
+
'
a
'
-
10
)
)
)
{
return
nullptr
;
}
}
}
return
result
.
finishString
(
)
;
}
WasmBreakpointSite
*
Instance
:
:
getOrCreateBreakpointSite
(
JSContext
*
cx
uint32_t
offset
)
{
MOZ_ASSERT
(
debugEnabled
(
)
)
;
return
debug
(
)
.
getOrCreateBreakpointSite
(
cx
this
offset
)
;
}
void
Instance
:
:
destroyBreakpointSite
(
JS
:
:
GCContext
*
gcx
uint32_t
offset
)
{
MOZ_ASSERT
(
debugEnabled
(
)
)
;
return
debug
(
)
.
destroyBreakpointSite
(
gcx
this
offset
)
;
}
void
Instance
:
:
disassembleExport
(
JSContext
*
cx
uint32_t
funcIndex
Tier
tier
PrintCallback
printString
)
const
{
const
MetadataTier
&
metadataTier
=
metadata
(
tier
)
;
const
FuncExport
&
funcExport
=
metadataTier
.
lookupFuncExport
(
funcIndex
)
;
const
CodeRange
&
range
=
metadataTier
.
codeRange
(
funcExport
)
;
const
CodeTier
&
codeTier
=
code
(
tier
)
;
const
ModuleSegment
&
segment
=
codeTier
.
segment
(
)
;
MOZ_ASSERT
(
range
.
begin
(
)
<
segment
.
length
(
)
)
;
MOZ_ASSERT
(
range
.
end
(
)
<
segment
.
length
(
)
)
;
uint8_t
*
functionCode
=
segment
.
base
(
)
+
range
.
begin
(
)
;
jit
:
:
Disassemble
(
functionCode
range
.
end
(
)
-
range
.
begin
(
)
printString
)
;
}
void
Instance
:
:
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
Metadata
:
:
SeenSet
*
seenMetadata
Code
:
:
SeenSet
*
seenCode
Table
:
:
SeenSet
*
seenTables
size_t
*
code
size_t
*
data
)
const
{
*
data
+
=
mallocSizeOf
(
this
)
;
for
(
const
SharedTable
&
table
:
tables_
)
{
*
data
+
=
table
-
>
sizeOfIncludingThisIfNotSeen
(
mallocSizeOf
seenTables
)
;
}
if
(
maybeDebug_
)
{
maybeDebug_
-
>
addSizeOfMisc
(
mallocSizeOf
seenMetadata
seenCode
code
data
)
;
}
code_
-
>
addSizeOfMiscIfNotSeen
(
mallocSizeOf
seenMetadata
seenCode
code
data
)
;
}
void
wasm
:
:
ReportTrapError
(
JSContext
*
cx
unsigned
errorNumber
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
errorNumber
)
;
if
(
cx
-
>
isThrowingOutOfMemory
(
)
)
{
return
;
}
RootedValue
exn
(
cx
)
;
if
(
!
cx
-
>
getPendingException
(
&
exn
)
)
{
return
;
}
MOZ_ASSERT
(
exn
.
isObject
(
)
&
&
exn
.
toObject
(
)
.
is
<
ErrorObject
>
(
)
)
;
exn
.
toObject
(
)
.
as
<
ErrorObject
>
(
)
.
setFromWasmTrap
(
)
;
}
