#
include
"
wasm
/
WasmInstance
-
inl
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
jsmath
.
h
"
#
include
"
builtin
/
String
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
jit
/
AtomicOperations
.
h
"
#
include
"
jit
/
Disassemble
.
h
"
#
include
"
jit
/
JitCommon
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
jit
/
Registers
.
h
"
#
include
"
js
/
ForOfIterator
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
Stack
.
h
"
#
include
"
util
/
StringBuilder
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
util
/
Unicode
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
ErrorObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
Iteration
.
h
"
#
include
"
vm
/
JitActivation
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
wasm
/
WasmBuiltins
.
h
"
#
include
"
wasm
/
WasmCode
.
h
"
#
include
"
wasm
/
WasmDebug
.
h
"
#
include
"
wasm
/
WasmDebugFrame
.
h
"
#
include
"
wasm
/
WasmFeatures
.
h
"
#
include
"
wasm
/
WasmHeuristics
.
h
"
#
include
"
wasm
/
WasmInitExpr
.
h
"
#
include
"
wasm
/
WasmJS
.
h
"
#
include
"
wasm
/
WasmMemory
.
h
"
#
include
"
wasm
/
WasmModule
.
h
"
#
include
"
wasm
/
WasmModuleTypes
.
h
"
#
include
"
wasm
/
WasmPI
.
h
"
#
include
"
wasm
/
WasmStubs
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
#
include
"
wasm
/
WasmValue
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
gc
/
StoreBuffer
-
inl
.
h
"
#
include
"
vm
/
ArrayBufferObject
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
wasm
/
WasmGcObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
using
mozilla
:
:
CheckedUint32
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
static_assert
(
alignof
(
Instance
)
>
=
std
:
:
max
(
sizeof
(
Registers
:
:
RegisterContent
)
sizeof
(
FloatRegisters
:
:
RegisterContent
)
)
)
;
static_assert
(
Instance
:
:
offsetOfData
(
)
%
alignof
(
Instance
)
=
=
0
)
;
static_assert
(
Instance
:
:
offsetOfMemory0Base
(
)
=
=
0
)
;
static_assert
(
Instance
:
:
offsetOfLastCommonJitField
(
)
<
128
)
;
FuncDefInstanceData
*
Instance
:
:
funcDefInstanceData
(
uint32_t
funcIndex
)
const
{
MOZ_ASSERT
(
funcIndex
>
=
codeMeta
(
)
.
numFuncImports
)
;
uint32_t
funcDefIndex
=
funcIndex
-
codeMeta
(
)
.
numFuncImports
;
FuncDefInstanceData
*
instanceData
=
(
FuncDefInstanceData
*
)
(
data
(
)
+
codeMeta
(
)
.
funcDefsOffsetStart
)
;
return
&
instanceData
[
funcDefIndex
]
;
}
TypeDefInstanceData
*
Instance
:
:
typeDefInstanceData
(
uint32_t
typeIndex
)
const
{
TypeDefInstanceData
*
instanceData
=
(
TypeDefInstanceData
*
)
(
data
(
)
+
codeMeta
(
)
.
typeDefsOffsetStart
)
;
return
&
instanceData
[
typeIndex
]
;
}
const
void
*
Instance
:
:
addressOfGlobalCell
(
const
GlobalDesc
&
global
)
const
{
const
void
*
cell
=
data
(
)
+
global
.
offset
(
)
;
if
(
global
.
isIndirect
(
)
)
{
cell
=
*
(
const
void
*
*
)
cell
;
}
return
cell
;
}
FuncImportInstanceData
&
Instance
:
:
funcImportInstanceData
(
uint32_t
funcIndex
)
{
MOZ_ASSERT
(
funcIndex
<
codeMeta
(
)
.
numFuncImports
)
;
FuncImportInstanceData
*
instanceData
=
(
FuncImportInstanceData
*
)
(
data
(
)
+
codeMeta
(
)
.
funcImportsOffsetStart
)
;
return
instanceData
[
funcIndex
]
;
}
FuncExportInstanceData
&
Instance
:
:
funcExportInstanceData
(
uint32_t
funcExportIndex
)
{
FuncExportInstanceData
*
instanceData
=
(
FuncExportInstanceData
*
)
(
data
(
)
+
codeMeta
(
)
.
funcExportsOffsetStart
)
;
return
instanceData
[
funcExportIndex
]
;
}
MemoryInstanceData
&
Instance
:
:
memoryInstanceData
(
uint32_t
memoryIndex
)
const
{
MemoryInstanceData
*
instanceData
=
(
MemoryInstanceData
*
)
(
data
(
)
+
codeMeta
(
)
.
memoriesOffsetStart
)
;
return
instanceData
[
memoryIndex
]
;
}
TableInstanceData
&
Instance
:
:
tableInstanceData
(
uint32_t
tableIndex
)
const
{
TableInstanceData
*
instanceData
=
(
TableInstanceData
*
)
(
data
(
)
+
codeMeta
(
)
.
tablesOffsetStart
)
;
return
instanceData
[
tableIndex
]
;
}
TagInstanceData
&
Instance
:
:
tagInstanceData
(
uint32_t
tagIndex
)
const
{
TagInstanceData
*
instanceData
=
(
TagInstanceData
*
)
(
data
(
)
+
codeMeta
(
)
.
tagsOffsetStart
)
;
return
instanceData
[
tagIndex
]
;
}
static
bool
UnpackResults
(
JSContext
*
cx
const
ValTypeVector
&
resultTypes
const
Maybe
<
char
*
>
stackResultsArea
uint64_t
*
argv
MutableHandleValue
rval
)
{
if
(
!
stackResultsArea
)
{
MOZ_ASSERT
(
resultTypes
.
length
(
)
<
=
1
)
;
if
(
resultTypes
.
length
(
)
=
=
1
)
{
return
ToWebAssemblyValue
(
cx
rval
resultTypes
[
0
]
argv
true
)
;
}
return
true
;
}
MOZ_ASSERT
(
stackResultsArea
.
isSome
(
)
)
;
Rooted
<
ArrayObject
*
>
array
(
cx
)
;
if
(
!
IterableToArray
(
cx
rval
&
array
)
)
{
return
false
;
}
if
(
resultTypes
.
length
(
)
!
=
array
-
>
length
(
)
)
{
UniqueChars
expected
(
JS_smprintf
(
"
%
zu
"
resultTypes
.
length
(
)
)
)
;
UniqueChars
got
(
JS_smprintf
(
"
%
u
"
array
-
>
length
(
)
)
)
;
if
(
!
expected
|
|
!
got
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_WRONG_NUMBER_OF_VALUES
expected
.
get
(
)
got
.
get
(
)
)
;
return
false
;
}
DebugOnly
<
uint64_t
>
previousOffset
=
~
(
uint64_t
)
0
;
ABIResultIter
iter
(
ResultType
:
:
Vector
(
resultTypes
)
)
;
while
(
!
iter
.
done
(
)
)
{
iter
.
next
(
)
;
}
DebugOnly
<
bool
>
seenRegisterResult
=
false
;
for
(
iter
.
switchToPrev
(
)
;
!
iter
.
done
(
)
;
iter
.
prev
(
)
)
{
const
ABIResult
&
result
=
iter
.
cur
(
)
;
MOZ_ASSERT
(
!
seenRegisterResult
)
;
rval
.
set
(
array
-
>
getDenseElement
(
iter
.
index
(
)
)
)
;
if
(
result
.
inRegister
(
)
)
{
if
(
!
ToWebAssemblyValue
(
cx
rval
result
.
type
(
)
argv
true
)
)
{
return
false
;
}
seenRegisterResult
=
true
;
continue
;
}
uint32_t
result_size
=
result
.
size
(
)
;
MOZ_ASSERT
(
result_size
=
=
4
|
|
result_size
=
=
8
)
;
#
ifdef
DEBUG
if
(
previousOffset
=
=
~
(
uint64_t
)
0
)
{
previousOffset
=
(
uint64_t
)
result
.
stackOffset
(
)
;
}
else
{
MOZ_ASSERT
(
previousOffset
-
(
uint64_t
)
result_size
=
=
(
uint64_t
)
result
.
stackOffset
(
)
)
;
previousOffset
-
=
(
uint64_t
)
result_size
;
}
#
endif
char
*
loc
=
stackResultsArea
.
value
(
)
+
result
.
stackOffset
(
)
;
if
(
!
ToWebAssemblyValue
(
cx
rval
result
.
type
(
)
loc
result_size
=
=
8
)
)
{
return
false
;
}
}
return
true
;
}
bool
Instance
:
:
callImport
(
JSContext
*
cx
uint32_t
funcImportIndex
unsigned
argc
uint64_t
*
argv
)
{
AssertRealmUnchanged
aru
(
cx
)
;
const
FuncImport
&
fi
=
code
(
)
.
funcImport
(
funcImportIndex
)
;
const
FuncType
&
funcType
=
codeMeta
(
)
.
getFuncType
(
funcImportIndex
)
;
ArgTypeVector
argTypes
(
funcType
)
;
InvokeArgs
args
(
cx
)
;
if
(
!
args
.
init
(
cx
argTypes
.
lengthWithoutStackResults
(
)
)
)
{
return
false
;
}
if
(
funcType
.
hasUnexposableArgOrRet
(
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_BAD_VAL_TYPE
)
;
return
false
;
}
MOZ_ASSERT
(
argTypes
.
lengthWithStackResults
(
)
=
=
argc
)
;
Maybe
<
char
*
>
stackResultPointer
;
size_t
lastBoxIndexPlusOne
=
0
;
{
JS
:
:
AutoAssertNoGC
nogc
;
for
(
size_t
i
=
0
;
i
<
argc
;
i
+
+
)
{
const
void
*
rawArgLoc
=
&
argv
[
i
]
;
if
(
argTypes
.
isSyntheticStackResultPointerArg
(
i
)
)
{
stackResultPointer
=
Some
(
*
(
char
*
*
)
rawArgLoc
)
;
continue
;
}
size_t
naturalIndex
=
argTypes
.
naturalIndex
(
i
)
;
ValType
type
=
funcType
.
args
(
)
[
naturalIndex
]
;
if
(
ToJSValueMayGC
(
type
)
)
{
lastBoxIndexPlusOne
=
i
+
1
;
continue
;
}
MutableHandleValue
argValue
=
args
[
naturalIndex
]
;
if
(
!
ToJSValue
(
cx
rawArgLoc
type
argValue
)
)
{
return
false
;
}
}
}
for
(
size_t
i
=
0
;
i
<
lastBoxIndexPlusOne
;
i
+
+
)
{
if
(
argTypes
.
isSyntheticStackResultPointerArg
(
i
)
)
{
continue
;
}
const
void
*
rawArgLoc
=
&
argv
[
i
]
;
size_t
naturalIndex
=
argTypes
.
naturalIndex
(
i
)
;
ValType
type
=
funcType
.
args
(
)
[
naturalIndex
]
;
if
(
!
ToJSValueMayGC
(
type
)
)
{
continue
;
}
MOZ_ASSERT
(
!
type
.
isRefRepr
(
)
)
;
MutableHandleValue
argValue
=
args
[
naturalIndex
]
;
if
(
!
ToJSValue
(
cx
rawArgLoc
type
argValue
)
)
{
return
false
;
}
}
FuncImportInstanceData
&
import
=
funcImportInstanceData
(
funcImportIndex
)
;
Rooted
<
JSObject
*
>
importCallable
(
cx
import
.
callable
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
importCallable
-
>
nonCCWRealm
(
)
)
;
RootedValue
fval
(
cx
ObjectValue
(
*
importCallable
)
)
;
RootedValue
thisv
(
cx
UndefinedValue
(
)
)
;
RootedValue
rval
(
cx
)
;
if
(
!
Call
(
cx
fval
thisv
args
&
rval
)
)
{
return
false
;
}
if
(
!
UnpackResults
(
cx
funcType
.
results
(
)
stackResultPointer
argv
&
rval
)
)
{
return
false
;
}
if
(
!
JitOptions
.
enableWasmJitExit
)
{
return
true
;
}
void
*
jitExitCode
=
code
(
)
.
sharedStubs
(
)
.
segment
-
>
base
(
)
+
fi
.
jitExitCodeOffset
(
)
;
if
(
import
.
code
=
=
jitExitCode
)
{
return
true
;
}
if
(
!
importCallable
-
>
is
<
JSFunction
>
(
)
)
{
return
true
;
}
if
(
!
importCallable
-
>
as
<
JSFunction
>
(
)
.
hasBytecode
(
)
)
{
return
true
;
}
JSScript
*
script
=
importCallable
-
>
as
<
JSFunction
>
(
)
.
nonLazyScript
(
)
;
if
(
!
script
-
>
hasJitScript
(
)
)
{
return
true
;
}
if
(
!
funcType
.
canHaveJitExit
(
)
)
{
return
true
;
}
import
.
code
=
jitExitCode
;
return
true
;
}
int32_t
Instance
:
:
callImport_general
(
Instance
*
instance
int32_t
funcImportIndex
int32_t
argc
uint64_t
*
argv
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
#
ifdef
ENABLE_WASM_JSPI
if
(
IsSuspendableStackActive
(
cx
)
)
{
return
CallImportOnMainThread
(
cx
instance
funcImportIndex
argc
argv
)
;
}
#
endif
return
instance
-
>
callImport
(
cx
funcImportIndex
argc
argv
)
;
}
template
<
typename
ValT
typename
PtrT
>
static
int32_t
PerformWait
(
Instance
*
instance
uint32_t
memoryIndex
PtrT
byteOffset
ValT
value
int64_t
timeout_ns
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
if
(
!
instance
-
>
memory
(
memoryIndex
)
-
>
isShared
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_NONSHARED_WAIT
)
;
return
-
1
;
}
if
(
byteOffset
&
(
sizeof
(
ValT
)
-
1
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_UNALIGNED_ACCESS
)
;
return
-
1
;
}
if
(
byteOffset
+
sizeof
(
ValT
)
>
instance
-
>
memory
(
memoryIndex
)
-
>
volatileMemoryLength
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
timeout
;
if
(
timeout_ns
>
=
0
)
{
timeout
=
mozilla
:
:
Some
(
mozilla
:
:
TimeDuration
:
:
FromMicroseconds
(
double
(
timeout_ns
)
/
1000
)
)
;
}
MOZ_ASSERT
(
byteOffset
<
=
SIZE_MAX
"
Bounds
check
is
broken
"
)
;
switch
(
atomics_wait_impl
(
cx
instance
-
>
sharedMemoryBuffer
(
memoryIndex
)
size_t
(
byteOffset
)
value
timeout
)
)
{
case
FutexThread
:
:
WaitResult
:
:
OK
:
return
0
;
case
FutexThread
:
:
WaitResult
:
:
NotEqual
:
return
1
;
case
FutexThread
:
:
WaitResult
:
:
TimedOut
:
return
2
;
case
FutexThread
:
:
WaitResult
:
:
Error
:
return
-
1
;
default
:
MOZ_CRASH
(
)
;
}
}
int32_t
Instance
:
:
wait_i32_m32
(
Instance
*
instance
uint32_t
byteOffset
int32_t
value
int64_t
timeout_ns
uint32_t
memoryIndex
)
{
MOZ_ASSERT
(
SASigWaitI32M32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
return
PerformWait
(
instance
memoryIndex
byteOffset
value
timeout_ns
)
;
}
int32_t
Instance
:
:
wait_i32_m64
(
Instance
*
instance
uint64_t
byteOffset
int32_t
value
int64_t
timeout_ns
uint32_t
memoryIndex
)
{
MOZ_ASSERT
(
SASigWaitI32M64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
return
PerformWait
(
instance
memoryIndex
byteOffset
value
timeout_ns
)
;
}
int32_t
Instance
:
:
wait_i64_m32
(
Instance
*
instance
uint32_t
byteOffset
int64_t
value
int64_t
timeout_ns
uint32_t
memoryIndex
)
{
MOZ_ASSERT
(
SASigWaitI64M32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
return
PerformWait
(
instance
memoryIndex
byteOffset
value
timeout_ns
)
;
}
int32_t
Instance
:
:
wait_i64_m64
(
Instance
*
instance
uint64_t
byteOffset
int64_t
value
int64_t
timeout_ns
uint32_t
memoryIndex
)
{
MOZ_ASSERT
(
SASigWaitI64M64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
return
PerformWait
(
instance
memoryIndex
byteOffset
value
timeout_ns
)
;
}
template
<
typename
PtrT
>
static
int32_t
PerformWake
(
Instance
*
instance
PtrT
byteOffset
int32_t
count
uint32_t
memoryIndex
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
if
(
byteOffset
&
3
)
{
ReportTrapError
(
cx
JSMSG_WASM_UNALIGNED_ACCESS
)
;
return
-
1
;
}
if
(
byteOffset
>
=
instance
-
>
memory
(
memoryIndex
)
-
>
volatileMemoryLength
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
if
(
!
instance
-
>
memory
(
memoryIndex
)
-
>
isShared
(
)
)
{
return
0
;
}
MOZ_ASSERT
(
byteOffset
<
=
SIZE_MAX
"
Bounds
check
is
broken
"
)
;
int64_t
woken
=
atomics_notify_impl
(
instance
-
>
sharedMemoryBuffer
(
memoryIndex
)
size_t
(
byteOffset
)
int64_t
(
count
)
)
;
if
(
woken
>
INT32_MAX
)
{
ReportTrapError
(
cx
JSMSG_WASM_WAKE_OVERFLOW
)
;
return
-
1
;
}
return
int32_t
(
woken
)
;
}
int32_t
Instance
:
:
wake_m32
(
Instance
*
instance
uint32_t
byteOffset
int32_t
count
uint32_t
memoryIndex
)
{
MOZ_ASSERT
(
SASigWakeM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
return
PerformWake
(
instance
byteOffset
count
memoryIndex
)
;
}
int32_t
Instance
:
:
wake_m64
(
Instance
*
instance
uint64_t
byteOffset
int32_t
count
uint32_t
memoryIndex
)
{
MOZ_ASSERT
(
SASigWakeM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
return
PerformWake
(
instance
byteOffset
count
memoryIndex
)
;
}
uint32_t
Instance
:
:
memoryGrow_m32
(
Instance
*
instance
uint32_t
delta
uint32_t
memoryIndex
)
{
MOZ_ASSERT
(
SASigMemoryGrowM32
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
MOZ_ASSERT
(
!
instance
-
>
isAsmJS
(
)
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
Rooted
<
WasmMemoryObject
*
>
memory
(
cx
instance
-
>
memory
(
memoryIndex
)
)
;
uint32_t
ret
=
uint32_t
(
WasmMemoryObject
:
:
grow
(
memory
uint64_t
(
delta
)
cx
)
)
;
MOZ_RELEASE_ASSERT
(
instance
-
>
memoryBase
(
memoryIndex
)
=
=
instance
-
>
memory
(
memoryIndex
)
-
>
buffer
(
)
.
dataPointerEither
(
)
)
;
return
ret
;
}
uint64_t
Instance
:
:
memoryGrow_m64
(
Instance
*
instance
uint64_t
delta
uint32_t
memoryIndex
)
{
MOZ_ASSERT
(
SASigMemoryGrowM64
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
MOZ_ASSERT
(
!
instance
-
>
isAsmJS
(
)
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
Rooted
<
WasmMemoryObject
*
>
memory
(
cx
instance
-
>
memory
(
memoryIndex
)
)
;
uint64_t
ret
=
WasmMemoryObject
:
:
grow
(
memory
delta
cx
)
;
MOZ_RELEASE_ASSERT
(
instance
-
>
memoryBase
(
memoryIndex
)
=
=
instance
-
>
memory
(
memoryIndex
)
-
>
buffer
(
)
.
dataPointerEither
(
)
)
;
return
ret
;
}
uint32_t
Instance
:
:
memorySize_m32
(
Instance
*
instance
uint32_t
memoryIndex
)
{
MOZ_ASSERT
(
SASigMemorySizeM32
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
DebugOnly
<
JSContext
*
>
cx
=
instance
-
>
cx
(
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
instance
-
>
realm
(
)
)
;
Pages
pages
=
instance
-
>
memory
(
memoryIndex
)
-
>
volatilePages
(
)
;
#
ifdef
JS_64BIT
MOZ_ASSERT
(
pages
<
=
Pages
(
MaxMemory32PagesValidation
)
)
;
#
endif
return
uint32_t
(
pages
.
value
(
)
)
;
}
uint64_t
Instance
:
:
memorySize_m64
(
Instance
*
instance
uint32_t
memoryIndex
)
{
MOZ_ASSERT
(
SASigMemorySizeM64
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
DebugOnly
<
JSContext
*
>
cx
=
instance
-
>
cx
(
)
;
MOZ_ASSERT
(
cx
-
>
realm
(
)
=
=
instance
-
>
realm
(
)
)
;
Pages
pages
=
instance
-
>
memory
(
memoryIndex
)
-
>
volatilePages
(
)
;
#
ifdef
JS_64BIT
MOZ_ASSERT
(
pages
<
=
Pages
(
MaxMemory64PagesValidation
)
)
;
#
endif
return
pages
.
value
(
)
;
}
template
<
typename
PointerT
typename
CopyFuncT
typename
IndexT
>
inline
int32_t
WasmMemoryCopy
(
JSContext
*
cx
PointerT
dstMemBase
PointerT
srcMemBase
size_t
dstMemLen
size_t
srcMemLen
IndexT
dstByteOffset
IndexT
srcByteOffset
IndexT
len
CopyFuncT
memMove
)
{
if
(
!
MemoryBoundsCheck
(
dstByteOffset
len
dstMemLen
)
|
|
!
MemoryBoundsCheck
(
srcByteOffset
len
srcMemLen
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
memMove
(
dstMemBase
+
uintptr_t
(
dstByteOffset
)
srcMemBase
+
uintptr_t
(
srcByteOffset
)
size_t
(
len
)
)
;
return
0
;
}
template
<
typename
I
>
inline
int32_t
MemoryCopy
(
JSContext
*
cx
I
dstByteOffset
I
srcByteOffset
I
len
uint8_t
*
memBase
)
{
const
WasmArrayRawBuffer
*
rawBuf
=
WasmArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
byteLength
(
)
;
return
WasmMemoryCopy
(
cx
memBase
memBase
memLen
memLen
dstByteOffset
srcByteOffset
len
memmove
)
;
}
template
<
typename
I
>
inline
int32_t
MemoryCopyShared
(
JSContext
*
cx
I
dstByteOffset
I
srcByteOffset
I
len
uint8_t
*
memBase
)
{
using
RacyMemMove
=
void
(
*
)
(
SharedMem
<
uint8_t
*
>
SharedMem
<
uint8_t
*
>
size_t
)
;
const
WasmSharedArrayRawBuffer
*
rawBuf
=
WasmSharedArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
volatileByteLength
(
)
;
SharedMem
<
uint8_t
*
>
sharedMemBase
=
SharedMem
<
uint8_t
*
>
:
:
shared
(
memBase
)
;
return
WasmMemoryCopy
<
SharedMem
<
uint8_t
*
>
RacyMemMove
>
(
cx
sharedMemBase
sharedMemBase
memLen
memLen
dstByteOffset
srcByteOffset
len
AtomicOperations
:
:
memmoveSafeWhenRacy
)
;
}
int32_t
Instance
:
:
memCopy_m32
(
Instance
*
instance
uint32_t
dstByteOffset
uint32_t
srcByteOffset
uint32_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemCopyM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryCopy
(
cx
dstByteOffset
srcByteOffset
len
memBase
)
;
}
int32_t
Instance
:
:
memCopyShared_m32
(
Instance
*
instance
uint32_t
dstByteOffset
uint32_t
srcByteOffset
uint32_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemCopySharedM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryCopyShared
(
cx
dstByteOffset
srcByteOffset
len
memBase
)
;
}
int32_t
Instance
:
:
memCopy_m64
(
Instance
*
instance
uint64_t
dstByteOffset
uint64_t
srcByteOffset
uint64_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemCopyM64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryCopy
(
cx
dstByteOffset
srcByteOffset
len
memBase
)
;
}
int32_t
Instance
:
:
memCopyShared_m64
(
Instance
*
instance
uint64_t
dstByteOffset
uint64_t
srcByteOffset
uint64_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemCopySharedM64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryCopyShared
(
cx
dstByteOffset
srcByteOffset
len
memBase
)
;
}
static
inline
size_t
GetVolatileByteLength
(
uint8_t
*
memBase
bool
isShared
)
{
if
(
isShared
)
{
return
WasmSharedArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
-
>
volatileByteLength
(
)
;
}
return
WasmArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
-
>
byteLength
(
)
;
}
int32_t
Instance
:
:
memCopy_any
(
Instance
*
instance
uint64_t
dstByteOffset
uint64_t
srcByteOffset
uint64_t
len
uint32_t
dstMemIndex
uint32_t
srcMemIndex
)
{
MOZ_ASSERT
(
SASigMemCopyAny
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
using
RacyMemMove
=
void
(
*
)
(
SharedMem
<
uint8_t
*
>
SharedMem
<
uint8_t
*
>
size_t
)
;
const
MemoryInstanceData
&
dstMemory
=
instance
-
>
memoryInstanceData
(
dstMemIndex
)
;
const
MemoryInstanceData
&
srcMemory
=
instance
-
>
memoryInstanceData
(
srcMemIndex
)
;
uint8_t
*
dstMemBase
=
dstMemory
.
base
;
uint8_t
*
srcMemBase
=
srcMemory
.
base
;
size_t
dstMemLen
=
GetVolatileByteLength
(
dstMemBase
dstMemory
.
isShared
)
;
size_t
srcMemLen
=
GetVolatileByteLength
(
srcMemBase
srcMemory
.
isShared
)
;
return
WasmMemoryCopy
<
SharedMem
<
uint8_t
*
>
RacyMemMove
>
(
cx
SharedMem
<
uint8_t
*
>
:
:
shared
(
dstMemBase
)
SharedMem
<
uint8_t
*
>
:
:
shared
(
srcMemBase
)
dstMemLen
srcMemLen
dstByteOffset
srcByteOffset
len
AtomicOperations
:
:
memmoveSafeWhenRacy
)
;
}
template
<
typename
T
typename
F
typename
I
>
inline
int32_t
WasmMemoryFill
(
JSContext
*
cx
T
memBase
size_t
memLen
I
byteOffset
uint32_t
value
I
len
F
memSet
)
{
if
(
!
MemoryBoundsCheck
(
byteOffset
len
memLen
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
memSet
(
memBase
+
uintptr_t
(
byteOffset
)
int
(
value
)
size_t
(
len
)
)
;
return
0
;
}
template
<
typename
I
>
inline
int32_t
MemoryFill
(
JSContext
*
cx
I
byteOffset
uint32_t
value
I
len
uint8_t
*
memBase
)
{
const
WasmArrayRawBuffer
*
rawBuf
=
WasmArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
byteLength
(
)
;
return
WasmMemoryFill
(
cx
memBase
memLen
byteOffset
value
len
memset
)
;
}
template
<
typename
I
>
inline
int32_t
MemoryFillShared
(
JSContext
*
cx
I
byteOffset
uint32_t
value
I
len
uint8_t
*
memBase
)
{
const
WasmSharedArrayRawBuffer
*
rawBuf
=
WasmSharedArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
volatileByteLength
(
)
;
return
WasmMemoryFill
(
cx
SharedMem
<
uint8_t
*
>
:
:
shared
(
memBase
)
memLen
byteOffset
value
len
AtomicOperations
:
:
memsetSafeWhenRacy
)
;
}
int32_t
Instance
:
:
memFill_m32
(
Instance
*
instance
uint32_t
byteOffset
uint32_t
value
uint32_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemFillM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryFill
(
cx
byteOffset
value
len
memBase
)
;
}
int32_t
Instance
:
:
memFillShared_m32
(
Instance
*
instance
uint32_t
byteOffset
uint32_t
value
uint32_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemFillSharedM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryFillShared
(
cx
byteOffset
value
len
memBase
)
;
}
int32_t
Instance
:
:
memFill_m64
(
Instance
*
instance
uint64_t
byteOffset
uint32_t
value
uint64_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemFillM64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryFill
(
cx
byteOffset
value
len
memBase
)
;
}
int32_t
Instance
:
:
memFillShared_m64
(
Instance
*
instance
uint64_t
byteOffset
uint32_t
value
uint64_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigMemFillSharedM64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryFillShared
(
cx
byteOffset
value
len
memBase
)
;
}
static
bool
BoundsCheckInit
(
uint32_t
dstOffset
uint32_t
srcOffset
uint32_t
len
size_t
memLen
uint32_t
segLen
)
{
uint64_t
dstOffsetLimit
=
uint64_t
(
dstOffset
)
+
uint64_t
(
len
)
;
uint64_t
srcOffsetLimit
=
uint64_t
(
srcOffset
)
+
uint64_t
(
len
)
;
return
dstOffsetLimit
>
memLen
|
|
srcOffsetLimit
>
segLen
;
}
static
bool
BoundsCheckInit
(
uint64_t
dstOffset
uint32_t
srcOffset
uint32_t
len
size_t
memLen
uint32_t
segLen
)
{
uint64_t
dstOffsetLimit
=
dstOffset
+
uint64_t
(
len
)
;
uint64_t
srcOffsetLimit
=
uint64_t
(
srcOffset
)
+
uint64_t
(
len
)
;
return
dstOffsetLimit
<
dstOffset
|
|
dstOffsetLimit
>
memLen
|
|
srcOffsetLimit
>
segLen
;
}
template
<
typename
I
>
static
int32_t
MemoryInit
(
JSContext
*
cx
Instance
*
instance
uint32_t
memoryIndex
I
dstOffset
uint32_t
srcOffset
uint32_t
len
const
DataSegment
*
maybeSeg
)
{
if
(
!
maybeSeg
)
{
if
(
len
=
=
0
&
&
srcOffset
=
=
0
)
{
return
0
;
}
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
const
DataSegment
&
seg
=
*
maybeSeg
;
MOZ_RELEASE_ASSERT
(
!
seg
.
active
(
)
)
;
const
uint32_t
segLen
=
seg
.
bytes
.
length
(
)
;
WasmMemoryObject
*
mem
=
instance
-
>
memory
(
memoryIndex
)
;
const
size_t
memLen
=
mem
-
>
volatileMemoryLength
(
)
;
if
(
BoundsCheckInit
(
dstOffset
srcOffset
len
memLen
segLen
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
SharedMem
<
uint8_t
*
>
dataPtr
=
mem
-
>
buffer
(
)
.
dataPointerEither
(
)
;
if
(
mem
-
>
isShared
(
)
)
{
AtomicOperations
:
:
memcpySafeWhenRacy
(
dataPtr
+
uintptr_t
(
dstOffset
)
(
uint8_t
*
)
seg
.
bytes
.
begin
(
)
+
srcOffset
len
)
;
}
else
{
uint8_t
*
rawBuf
=
dataPtr
.
unwrap
(
)
;
memcpy
(
rawBuf
+
uintptr_t
(
dstOffset
)
(
const
char
*
)
seg
.
bytes
.
begin
(
)
+
srcOffset
len
)
;
}
return
0
;
}
int32_t
Instance
:
:
memInit_m32
(
Instance
*
instance
uint32_t
dstOffset
uint32_t
srcOffset
uint32_t
len
uint32_t
segIndex
uint32_t
memIndex
)
{
MOZ_ASSERT
(
SASigMemInitM32
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveDataSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryInit
(
cx
instance
memIndex
dstOffset
srcOffset
len
instance
-
>
passiveDataSegments_
[
segIndex
]
)
;
}
int32_t
Instance
:
:
memInit_m64
(
Instance
*
instance
uint64_t
dstOffset
uint32_t
srcOffset
uint32_t
len
uint32_t
segIndex
uint32_t
memIndex
)
{
MOZ_ASSERT
(
SASigMemInitM64
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveDataSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
MemoryInit
(
cx
instance
memIndex
dstOffset
srcOffset
len
instance
-
>
passiveDataSegments_
[
segIndex
]
)
;
}
int32_t
Instance
:
:
tableCopy
(
Instance
*
instance
uint32_t
dstOffset
uint32_t
srcOffset
uint32_t
len
uint32_t
dstTableIndex
uint32_t
srcTableIndex
)
{
MOZ_ASSERT
(
SASigTableCopy
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
const
SharedTable
&
srcTable
=
instance
-
>
tables
(
)
[
srcTableIndex
]
;
uint32_t
srcTableLen
=
srcTable
-
>
length
(
)
;
const
SharedTable
&
dstTable
=
instance
-
>
tables
(
)
[
dstTableIndex
]
;
uint32_t
dstTableLen
=
dstTable
-
>
length
(
)
;
uint64_t
dstOffsetLimit
=
uint64_t
(
dstOffset
)
+
len
;
uint64_t
srcOffsetLimit
=
uint64_t
(
srcOffset
)
+
len
;
if
(
dstOffsetLimit
>
dstTableLen
|
|
srcOffsetLimit
>
srcTableLen
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
bool
isOOM
=
false
;
if
(
&
srcTable
=
=
&
dstTable
&
&
dstOffset
>
srcOffset
)
{
for
(
uint32_t
i
=
len
;
i
>
0
;
i
-
-
)
{
if
(
!
dstTable
-
>
copy
(
cx
*
srcTable
dstOffset
+
(
i
-
1
)
srcOffset
+
(
i
-
1
)
)
)
{
isOOM
=
true
;
break
;
}
}
}
else
if
(
&
srcTable
=
=
&
dstTable
&
&
dstOffset
=
=
srcOffset
)
{
}
else
{
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
!
dstTable
-
>
copy
(
cx
*
srcTable
dstOffset
+
i
srcOffset
+
i
)
)
{
isOOM
=
true
;
break
;
}
}
}
if
(
isOOM
)
{
return
-
1
;
}
return
0
;
}
#
ifdef
DEBUG
static
bool
AllSegmentsArePassive
(
const
DataSegmentVector
&
vec
)
{
for
(
const
DataSegment
*
seg
:
vec
)
{
if
(
seg
-
>
active
(
)
)
{
return
false
;
}
}
return
true
;
}
#
endif
bool
Instance
:
:
initSegments
(
JSContext
*
cx
const
DataSegmentVector
&
dataSegments
const
ModuleElemSegmentVector
&
elemSegments
)
{
MOZ_ASSERT_IF
(
codeMeta
(
)
.
memories
.
length
(
)
=
=
0
AllSegmentsArePassive
(
dataSegments
)
)
;
Rooted
<
WasmInstanceObject
*
>
instanceObj
(
cx
object
(
)
)
;
for
(
const
ModuleElemSegment
&
seg
:
elemSegments
)
{
if
(
seg
.
active
(
)
)
{
RootedVal
offsetVal
(
cx
)
;
if
(
!
seg
.
offset
(
)
.
evaluate
(
cx
instanceObj
&
offsetVal
)
)
{
return
false
;
}
const
wasm
:
:
Table
*
table
=
tables
(
)
[
seg
.
tableIndex
]
;
uint64_t
offset
=
table
-
>
indexType
(
)
=
=
IndexType
:
:
I32
?
offsetVal
.
get
(
)
.
i32
(
)
:
offsetVal
.
get
(
)
.
i64
(
)
;
uint64_t
tableLength
=
table
-
>
length
(
)
;
if
(
offset
>
tableLength
|
|
tableLength
-
offset
<
seg
.
numElements
(
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
false
;
}
if
(
!
initElems
(
seg
.
tableIndex
seg
offset
)
)
{
return
false
;
}
}
}
for
(
const
DataSegment
*
seg
:
dataSegments
)
{
if
(
!
seg
-
>
active
(
)
)
{
continue
;
}
Rooted
<
const
WasmMemoryObject
*
>
memoryObj
(
cx
memory
(
seg
-
>
memoryIndex
)
)
;
size_t
memoryLength
=
memoryObj
-
>
volatileMemoryLength
(
)
;
uint8_t
*
memoryBase
=
memoryObj
-
>
buffer
(
)
.
dataPointerEither
(
)
.
unwrap
(
)
;
RootedVal
offsetVal
(
cx
)
;
if
(
!
seg
-
>
offset
(
)
.
evaluate
(
cx
instanceObj
&
offsetVal
)
)
{
return
false
;
}
uint64_t
offset
=
memoryObj
-
>
indexType
(
)
=
=
IndexType
:
:
I32
?
offsetVal
.
get
(
)
.
i32
(
)
:
offsetVal
.
get
(
)
.
i64
(
)
;
uint32_t
count
=
seg
-
>
bytes
.
length
(
)
;
if
(
offset
>
memoryLength
|
|
memoryLength
-
offset
<
count
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
false
;
}
memcpy
(
memoryBase
+
uintptr_t
(
offset
)
seg
-
>
bytes
.
begin
(
)
count
)
;
}
return
true
;
}
bool
Instance
:
:
initElems
(
uint32_t
tableIndex
const
ModuleElemSegment
&
seg
uint32_t
dstOffset
)
{
Table
&
table
=
*
tables_
[
tableIndex
]
;
MOZ_ASSERT
(
dstOffset
<
=
table
.
length
(
)
)
;
MOZ_ASSERT
(
seg
.
numElements
(
)
<
=
table
.
length
(
)
-
dstOffset
)
;
if
(
seg
.
numElements
(
)
=
=
0
)
{
return
true
;
}
Rooted
<
WasmInstanceObject
*
>
instanceObj
(
cx
(
)
object
(
)
)
;
if
(
table
.
isFunction
(
)
&
&
seg
.
encoding
=
=
ModuleElemSegment
:
:
Encoding
:
:
Indices
)
{
bool
ok
=
iterElemsFunctions
(
seg
[
&
]
(
uint32_t
i
void
*
code
Instance
*
instance
)
-
>
bool
{
table
.
setFuncRef
(
dstOffset
+
i
code
instance
)
;
return
true
;
}
)
;
if
(
!
ok
)
{
return
false
;
}
}
else
{
bool
ok
=
iterElemsAnyrefs
(
seg
[
&
]
(
uint32_t
i
AnyRef
ref
)
-
>
bool
{
table
.
setRef
(
dstOffset
+
i
ref
)
;
return
true
;
}
)
;
if
(
!
ok
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
F
>
bool
Instance
:
:
iterElemsFunctions
(
const
ModuleElemSegment
&
seg
const
F
&
onFunc
)
{
MOZ_ASSERT
(
seg
.
encoding
=
=
ModuleElemSegment
:
:
Encoding
:
:
Indices
)
;
if
(
seg
.
numElements
(
)
=
=
0
)
{
return
true
;
}
const
FuncImportVector
&
funcImports
=
code
(
)
.
funcImports
(
)
;
for
(
uint32_t
i
=
0
;
i
<
seg
.
numElements
(
)
;
i
+
+
)
{
uint32_t
elemFuncIndex
=
seg
.
elemIndices
[
i
]
;
if
(
elemFuncIndex
<
funcImports
.
length
(
)
)
{
FuncImportInstanceData
&
import
=
funcImportInstanceData
(
elemFuncIndex
)
;
MOZ_ASSERT
(
import
.
callable
-
>
isCallable
(
)
)
;
if
(
import
.
callable
-
>
is
<
JSFunction
>
(
)
)
{
JSFunction
*
fun
=
&
import
.
callable
-
>
as
<
JSFunction
>
(
)
;
if
(
IsWasmExportedFunction
(
fun
)
)
{
WasmInstanceObject
*
calleeInstanceObj
=
ExportedFunctionToInstanceObject
(
fun
)
;
Instance
&
calleeInstance
=
calleeInstanceObj
-
>
instance
(
)
;
uint8_t
*
codeRangeBase
;
const
CodeRange
*
codeRange
;
calleeInstanceObj
-
>
getExportedFunctionCodeRange
(
fun
&
codeRange
&
codeRangeBase
)
;
void
*
code
=
codeRangeBase
+
codeRange
-
>
funcCheckedCallEntry
(
)
;
if
(
!
onFunc
(
i
code
&
calleeInstance
)
)
{
return
false
;
}
continue
;
}
}
}
const
CodeBlock
&
codeBlock
=
code
(
)
.
funcCodeBlock
(
elemFuncIndex
)
;
const
CodeRangeVector
&
codeRanges
=
codeBlock
.
codeRanges
;
const
FuncToCodeRangeMap
&
funcToCodeRange
=
codeBlock
.
funcToCodeRange
;
void
*
code
=
codeBlock
.
segment
-
>
base
(
)
+
codeRanges
[
funcToCodeRange
[
elemFuncIndex
]
]
.
funcCheckedCallEntry
(
)
;
if
(
!
onFunc
(
i
code
this
)
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
F
>
bool
Instance
:
:
iterElemsAnyrefs
(
const
ModuleElemSegment
&
seg
const
F
&
onAnyRef
)
{
if
(
seg
.
numElements
(
)
=
=
0
)
{
return
true
;
}
switch
(
seg
.
encoding
)
{
case
ModuleElemSegment
:
:
Encoding
:
:
Indices
:
{
for
(
uint32_t
i
=
0
;
i
<
seg
.
numElements
(
)
;
i
+
+
)
{
uint32_t
funcIndex
=
seg
.
elemIndices
[
i
]
;
void
*
fnref
=
Instance
:
:
refFunc
(
this
funcIndex
)
;
if
(
fnref
=
=
AnyRef
:
:
invalid
(
)
.
forCompiledCode
(
)
)
{
return
false
;
}
if
(
!
onAnyRef
(
i
AnyRef
:
:
fromCompiledCode
(
fnref
)
)
)
{
return
false
;
}
}
}
break
;
case
ModuleElemSegment
:
:
Encoding
:
:
Expressions
:
{
Rooted
<
WasmInstanceObject
*
>
instanceObj
(
cx
(
)
object
(
)
)
;
const
ModuleElemSegment
:
:
Expressions
&
exprs
=
seg
.
elemExpressions
;
UniqueChars
error
;
Decoder
d
(
exprs
.
exprBytes
.
begin
(
)
exprs
.
exprBytes
.
end
(
)
0
&
error
)
;
for
(
uint32_t
i
=
0
;
i
<
seg
.
numElements
(
)
;
i
+
+
)
{
RootedVal
result
(
cx
(
)
)
;
if
(
!
InitExpr
:
:
decodeAndEvaluate
(
cx
(
)
instanceObj
d
seg
.
elemType
&
result
)
)
{
MOZ_ASSERT
(
!
error
)
;
return
false
;
}
AnyRef
ref
=
result
.
get
(
)
.
ref
(
)
;
if
(
!
onAnyRef
(
i
ref
)
)
{
return
false
;
}
}
}
break
;
default
:
MOZ_CRASH
(
"
unknown
encoding
type
for
element
segment
"
)
;
}
return
true
;
}
int32_t
Instance
:
:
tableInit
(
Instance
*
instance
uint32_t
dstOffset
uint32_t
srcOffset
uint32_t
len
uint32_t
segIndex
uint32_t
tableIndex
)
{
MOZ_ASSERT
(
SASigTableInit
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveElemSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
const
InstanceElemSegment
&
seg
=
instance
-
>
passiveElemSegments_
[
segIndex
]
;
const
uint32_t
segLen
=
seg
.
length
(
)
;
Table
&
table
=
*
instance
-
>
tables
(
)
[
tableIndex
]
;
const
uint32_t
tableLen
=
table
.
length
(
)
;
uint64_t
dstOffsetLimit
=
uint64_t
(
dstOffset
)
+
uint64_t
(
len
)
;
uint64_t
srcOffsetLimit
=
uint64_t
(
srcOffset
)
+
uint64_t
(
len
)
;
if
(
dstOffsetLimit
>
tableLen
|
|
srcOffsetLimit
>
segLen
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
table
.
setRef
(
dstOffset
+
i
seg
[
srcOffset
+
i
]
)
;
}
return
0
;
}
int32_t
Instance
:
:
tableFill
(
Instance
*
instance
uint32_t
start
void
*
value
uint32_t
len
uint32_t
tableIndex
)
{
MOZ_ASSERT
(
SASigTableFill
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
Table
&
table
=
*
instance
-
>
tables
(
)
[
tableIndex
]
;
uint64_t
offsetLimit
=
uint64_t
(
start
)
+
uint64_t
(
len
)
;
if
(
offsetLimit
>
table
.
length
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
switch
(
table
.
repr
(
)
)
{
case
TableRepr
:
:
Ref
:
table
.
fillAnyRef
(
start
len
AnyRef
:
:
fromCompiledCode
(
value
)
)
;
break
;
case
TableRepr
:
:
Func
:
MOZ_RELEASE_ASSERT
(
!
table
.
isAsmJS
(
)
)
;
table
.
fillFuncRef
(
start
len
FuncRef
:
:
fromCompiledCode
(
value
)
cx
)
;
break
;
}
return
0
;
}
template
<
typename
I
>
static
bool
WasmDiscardCheck
(
Instance
*
instance
I
byteOffset
I
byteLen
size_t
memLen
bool
shared
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
if
(
byteOffset
%
wasm
:
:
PageSize
!
=
0
|
|
byteLen
%
wasm
:
:
PageSize
!
=
0
)
{
ReportTrapError
(
cx
JSMSG_WASM_UNALIGNED_ACCESS
)
;
return
false
;
}
if
(
!
MemoryBoundsCheck
(
byteOffset
byteLen
memLen
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
false
;
}
return
true
;
}
template
<
typename
I
>
static
int32_t
MemDiscardNotShared
(
Instance
*
instance
I
byteOffset
I
byteLen
uint8_t
*
memBase
)
{
WasmArrayRawBuffer
*
rawBuf
=
WasmArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
byteLength
(
)
;
if
(
!
WasmDiscardCheck
(
instance
byteOffset
byteLen
memLen
false
)
)
{
return
-
1
;
}
rawBuf
-
>
discard
(
byteOffset
byteLen
)
;
return
0
;
}
template
<
typename
I
>
static
int32_t
MemDiscardShared
(
Instance
*
instance
I
byteOffset
I
byteLen
uint8_t
*
memBase
)
{
WasmSharedArrayRawBuffer
*
rawBuf
=
WasmSharedArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
volatileByteLength
(
)
;
if
(
!
WasmDiscardCheck
(
instance
byteOffset
byteLen
memLen
true
)
)
{
return
-
1
;
}
rawBuf
-
>
discard
(
byteOffset
byteLen
)
;
return
0
;
}
int32_t
Instance
:
:
memDiscard_m32
(
Instance
*
instance
uint32_t
byteOffset
uint32_t
byteLen
uint8_t
*
memBase
)
{
return
MemDiscardNotShared
(
instance
byteOffset
byteLen
memBase
)
;
}
int32_t
Instance
:
:
memDiscard_m64
(
Instance
*
instance
uint64_t
byteOffset
uint64_t
byteLen
uint8_t
*
memBase
)
{
return
MemDiscardNotShared
(
instance
byteOffset
byteLen
memBase
)
;
}
int32_t
Instance
:
:
memDiscardShared_m32
(
Instance
*
instance
uint32_t
byteOffset
uint32_t
byteLen
uint8_t
*
memBase
)
{
return
MemDiscardShared
(
instance
byteOffset
byteLen
memBase
)
;
}
int32_t
Instance
:
:
memDiscardShared_m64
(
Instance
*
instance
uint64_t
byteOffset
uint64_t
byteLen
uint8_t
*
memBase
)
{
return
MemDiscardShared
(
instance
byteOffset
byteLen
memBase
)
;
}
void
*
Instance
:
:
tableGet
(
Instance
*
instance
uint32_t
index
uint32_t
tableIndex
)
{
MOZ_ASSERT
(
SASigTableGet
.
failureMode
=
=
FailureMode
:
:
FailOnInvalidRef
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
const
Table
&
table
=
*
instance
-
>
tables
(
)
[
tableIndex
]
;
if
(
index
>
=
table
.
length
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_TABLE_OUT_OF_BOUNDS
)
;
return
AnyRef
:
:
invalid
(
)
.
forCompiledCode
(
)
;
}
switch
(
table
.
repr
(
)
)
{
case
TableRepr
:
:
Ref
:
return
table
.
getAnyRef
(
index
)
.
forCompiledCode
(
)
;
case
TableRepr
:
:
Func
:
{
MOZ_RELEASE_ASSERT
(
!
table
.
isAsmJS
(
)
)
;
RootedFunction
fun
(
cx
)
;
if
(
!
table
.
getFuncRef
(
cx
index
&
fun
)
)
{
return
AnyRef
:
:
invalid
(
)
.
forCompiledCode
(
)
;
}
return
FuncRef
:
:
fromJSFunction
(
fun
)
.
forCompiledCode
(
)
;
}
}
MOZ_CRASH
(
"
Should
not
happen
"
)
;
}
uint32_t
Instance
:
:
tableGrow
(
Instance
*
instance
void
*
initValue
uint32_t
delta
uint32_t
tableIndex
)
{
MOZ_ASSERT
(
SASigTableGrow
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
RootedAnyRef
ref
(
cx
AnyRef
:
:
fromCompiledCode
(
initValue
)
)
;
Table
&
table
=
*
instance
-
>
tables
(
)
[
tableIndex
]
;
uint32_t
oldSize
=
table
.
grow
(
delta
)
;
if
(
oldSize
!
=
uint32_t
(
-
1
)
&
&
initValue
!
=
nullptr
)
{
table
.
fillUninitialized
(
oldSize
delta
ref
cx
)
;
}
#
ifdef
DEBUG
if
(
!
table
.
elemType
(
)
.
isNullable
(
)
)
{
table
.
assertRangeNotNull
(
oldSize
delta
)
;
}
#
endif
return
oldSize
;
}
int32_t
Instance
:
:
tableSet
(
Instance
*
instance
uint32_t
index
void
*
value
uint32_t
tableIndex
)
{
MOZ_ASSERT
(
SASigTableSet
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
Table
&
table
=
*
instance
-
>
tables
(
)
[
tableIndex
]
;
if
(
index
>
=
table
.
length
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_TABLE_OUT_OF_BOUNDS
)
;
return
-
1
;
}
switch
(
table
.
repr
(
)
)
{
case
TableRepr
:
:
Ref
:
table
.
setAnyRef
(
index
AnyRef
:
:
fromCompiledCode
(
value
)
)
;
break
;
case
TableRepr
:
:
Func
:
MOZ_RELEASE_ASSERT
(
!
table
.
isAsmJS
(
)
)
;
table
.
fillFuncRef
(
index
1
FuncRef
:
:
fromCompiledCode
(
value
)
cx
)
;
break
;
}
return
0
;
}
uint32_t
Instance
:
:
tableSize
(
Instance
*
instance
uint32_t
tableIndex
)
{
MOZ_ASSERT
(
SASigTableSize
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
Table
&
table
=
*
instance
-
>
tables
(
)
[
tableIndex
]
;
return
table
.
length
(
)
;
}
void
*
Instance
:
:
refFunc
(
Instance
*
instance
uint32_t
funcIndex
)
{
MOZ_ASSERT
(
SASigRefFunc
.
failureMode
=
=
FailureMode
:
:
FailOnInvalidRef
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
RootedFunction
exportedFunc
(
cx
)
;
if
(
!
instance
-
>
getExportedFunction
(
cx
funcIndex
&
exportedFunc
)
)
{
MOZ_ASSERT
(
cx
-
>
isThrowingOutOfMemory
(
)
)
;
return
nullptr
;
}
return
FuncRef
:
:
fromJSFunction
(
exportedFunc
.
get
(
)
)
.
forCompiledCode
(
)
;
}
int32_t
Instance
:
:
elemDrop
(
Instance
*
instance
uint32_t
segIndex
)
{
MOZ_ASSERT
(
SASigElemDrop
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveElemSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
instance
-
>
passiveElemSegments_
[
segIndex
]
.
clearAndFree
(
)
;
return
0
;
}
int32_t
Instance
:
:
dataDrop
(
Instance
*
instance
uint32_t
segIndex
)
{
MOZ_ASSERT
(
SASigDataDrop
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveDataSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
if
(
!
instance
-
>
passiveDataSegments_
[
segIndex
]
)
{
return
0
;
}
SharedDataSegment
&
segRefPtr
=
instance
-
>
passiveDataSegments_
[
segIndex
]
;
MOZ_RELEASE_ASSERT
(
!
segRefPtr
-
>
active
(
)
)
;
segRefPtr
=
nullptr
;
return
0
;
}
void
Instance
:
:
postBarrier
(
Instance
*
instance
void
*
*
location
)
{
MOZ_ASSERT
(
SASigPostBarrier
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
MOZ_ASSERT
(
location
)
;
instance
-
>
storeBuffer_
-
>
putWasmAnyRef
(
reinterpret_cast
<
wasm
:
:
AnyRef
*
>
(
location
)
)
;
}
void
Instance
:
:
postBarrierPrecise
(
Instance
*
instance
void
*
*
location
void
*
prev
)
{
MOZ_ASSERT
(
SASigPostBarrierPrecise
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
postBarrierPreciseWithOffset
(
instance
location
0
prev
)
;
}
void
Instance
:
:
postBarrierPreciseWithOffset
(
Instance
*
instance
void
*
*
base
uint32_t
offset
void
*
prev
)
{
MOZ_ASSERT
(
SASigPostBarrierPreciseWithOffset
.
failureMode
=
=
FailureMode
:
:
Infallible
)
;
MOZ_ASSERT
(
base
)
;
wasm
:
:
AnyRef
*
location
=
(
wasm
:
:
AnyRef
*
)
(
uintptr_t
(
base
)
+
size_t
(
offset
)
)
;
wasm
:
:
AnyRef
next
=
*
location
;
InternalBarrierMethods
<
AnyRef
>
:
:
postBarrier
(
location
wasm
:
:
AnyRef
:
:
fromCompiledCode
(
prev
)
next
)
;
}
template
<
bool
ZeroFields
>
void
*
Instance
:
:
structNewIL
(
Instance
*
instance
TypeDefInstanceData
*
typeDefData
)
{
MOZ_ASSERT
(
(
ZeroFields
?
SASigStructNewIL_true
:
SASigStructNewIL_false
)
.
failureMode
=
=
FailureMode
:
:
FailOnNullPtr
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
WasmStructObject
:
:
createStructIL
<
ZeroFields
>
(
cx
typeDefData
typeDefData
-
>
allocSite
.
initialHeap
(
)
)
;
}
template
void
*
Instance
:
:
structNewIL
<
true
>
(
Instance
*
instance
TypeDefInstanceData
*
typeDefData
)
;
template
void
*
Instance
:
:
structNewIL
<
false
>
(
Instance
*
instance
TypeDefInstanceData
*
typeDefData
)
;
template
<
bool
ZeroFields
>
void
*
Instance
:
:
structNewOOL
(
Instance
*
instance
TypeDefInstanceData
*
typeDefData
)
{
MOZ_ASSERT
(
(
ZeroFields
?
SASigStructNewOOL_true
:
SASigStructNewOOL_false
)
.
failureMode
=
=
FailureMode
:
:
FailOnNullPtr
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
WasmStructObject
:
:
createStructOOL
<
ZeroFields
>
(
cx
typeDefData
typeDefData
-
>
allocSite
.
initialHeap
(
)
)
;
}
template
void
*
Instance
:
:
structNewOOL
<
true
>
(
Instance
*
instance
TypeDefInstanceData
*
typeDefData
)
;
template
void
*
Instance
:
:
structNewOOL
<
false
>
(
Instance
*
instance
TypeDefInstanceData
*
typeDefData
)
;
template
<
bool
ZeroFields
>
void
*
Instance
:
:
arrayNew
(
Instance
*
instance
uint32_t
numElements
TypeDefInstanceData
*
typeDefData
)
{
MOZ_ASSERT
(
(
ZeroFields
?
SASigArrayNew_true
:
SASigArrayNew_false
)
.
failureMode
=
=
FailureMode
:
:
FailOnNullPtr
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
return
WasmArrayObject
:
:
createArray
<
ZeroFields
>
(
cx
typeDefData
typeDefData
-
>
allocSite
.
initialHeap
(
)
numElements
)
;
}
template
void
*
Instance
:
:
arrayNew
<
true
>
(
Instance
*
instance
uint32_t
numElements
TypeDefInstanceData
*
typeDefData
)
;
template
void
*
Instance
:
:
arrayNew
<
false
>
(
Instance
*
instance
uint32_t
numElements
TypeDefInstanceData
*
typeDefData
)
;
static
bool
ArrayCopyFromData
(
JSContext
*
cx
Handle
<
WasmArrayObject
*
>
arrayObj
const
TypeDef
*
typeDef
uint32_t
arrayIndex
const
DataSegment
*
seg
uint32_t
segByteOffset
uint32_t
numElements
)
{
CheckedUint32
numBytesToCopy
=
CheckedUint32
(
numElements
)
*
CheckedUint32
(
typeDef
-
>
arrayType
(
)
.
elementType
(
)
.
size
(
)
)
;
if
(
!
numBytesToCopy
.
isValid
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
false
;
}
CheckedUint32
lastByteOffsetPlus1
=
CheckedUint32
(
segByteOffset
)
+
numBytesToCopy
;
CheckedUint32
numBytesAvailable
(
seg
-
>
bytes
.
length
(
)
)
;
if
(
!
lastByteOffsetPlus1
.
isValid
(
)
|
|
!
numBytesAvailable
.
isValid
(
)
|
|
lastByteOffsetPlus1
.
value
(
)
>
numBytesAvailable
.
value
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
false
;
}
uint64_t
dstNumElements
=
uint64_t
(
arrayObj
-
>
numElements_
)
;
if
(
uint64_t
(
arrayIndex
)
+
uint64_t
(
numElements
)
>
dstNumElements
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
false
;
}
if
(
numElements
!
=
0
)
{
memcpy
(
arrayObj
-
>
data_
&
seg
-
>
bytes
[
segByteOffset
]
size_t
(
numBytesToCopy
.
value
(
)
)
)
;
}
return
true
;
}
static
bool
ArrayCopyFromElem
(
JSContext
*
cx
Handle
<
WasmArrayObject
*
>
arrayObj
uint32_t
arrayIndex
const
InstanceElemSegment
&
seg
uint32_t
segOffset
uint32_t
numElements
)
{
CheckedUint32
lastIndexPlus1
=
CheckedUint32
(
segOffset
)
+
CheckedUint32
(
numElements
)
;
CheckedUint32
numElemsAvailable
(
seg
.
length
(
)
)
;
if
(
!
lastIndexPlus1
.
isValid
(
)
|
|
!
numElemsAvailable
.
isValid
(
)
|
|
lastIndexPlus1
.
value
(
)
>
numElemsAvailable
.
value
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
false
;
}
uint64_t
dstNumElements
=
uint64_t
(
arrayObj
-
>
numElements_
)
;
if
(
uint64_t
(
arrayIndex
)
+
uint64_t
(
numElements
)
>
dstNumElements
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
false
;
}
GCPtr
<
AnyRef
>
*
dst
=
reinterpret_cast
<
GCPtr
<
AnyRef
>
*
>
(
arrayObj
-
>
data_
)
;
for
(
uint32_t
i
=
0
;
i
<
numElements
;
i
+
+
)
{
dst
[
i
]
=
seg
[
segOffset
+
i
]
;
}
return
true
;
}
void
*
Instance
:
:
arrayNewData
(
Instance
*
instance
uint32_t
segByteOffset
uint32_t
numElements
TypeDefInstanceData
*
typeDefData
uint32_t
segIndex
)
{
MOZ_ASSERT
(
SASigArrayNewData
.
failureMode
=
=
FailureMode
:
:
FailOnNullPtr
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveDataSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
const
DataSegment
*
seg
=
instance
-
>
passiveDataSegments_
[
segIndex
]
;
if
(
!
seg
&
&
(
numElements
!
=
0
|
|
segByteOffset
!
=
0
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
nullptr
;
}
const
TypeDef
*
typeDef
=
typeDefData
-
>
typeDef
;
Rooted
<
WasmArrayObject
*
>
arrayObj
(
cx
WasmArrayObject
:
:
createArray
<
true
>
(
cx
typeDefData
typeDefData
-
>
allocSite
.
initialHeap
(
)
numElements
)
)
;
if
(
!
arrayObj
)
{
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
arrayObj
-
>
is
<
WasmArrayObject
>
(
)
)
;
if
(
!
seg
)
{
return
arrayObj
;
}
if
(
!
ArrayCopyFromData
(
cx
arrayObj
typeDef
0
seg
segByteOffset
numElements
)
)
{
return
nullptr
;
}
return
arrayObj
;
}
void
*
Instance
:
:
arrayNewElem
(
Instance
*
instance
uint32_t
srcOffset
uint32_t
numElements
TypeDefInstanceData
*
typeDefData
uint32_t
segIndex
)
{
MOZ_ASSERT
(
SASigArrayNewElem
.
failureMode
=
=
FailureMode
:
:
FailOnNullPtr
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveElemSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
const
InstanceElemSegment
&
seg
=
instance
-
>
passiveElemSegments_
[
segIndex
]
;
const
TypeDef
*
typeDef
=
typeDefData
-
>
typeDef
;
MOZ_RELEASE_ASSERT
(
typeDef
-
>
arrayType
(
)
.
elementType
(
)
.
size
(
)
=
=
sizeof
(
AnyRef
)
)
;
Rooted
<
WasmArrayObject
*
>
arrayObj
(
cx
WasmArrayObject
:
:
createArray
<
true
>
(
cx
typeDefData
typeDefData
-
>
allocSite
.
initialHeap
(
)
numElements
)
)
;
if
(
!
arrayObj
)
{
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
arrayObj
-
>
is
<
WasmArrayObject
>
(
)
)
;
if
(
!
ArrayCopyFromElem
(
cx
arrayObj
0
seg
srcOffset
numElements
)
)
{
return
nullptr
;
}
return
arrayObj
;
}
int32_t
Instance
:
:
arrayInitData
(
Instance
*
instance
void
*
array
uint32_t
index
uint32_t
segByteOffset
uint32_t
numElements
TypeDefInstanceData
*
typeDefData
uint32_t
segIndex
)
{
MOZ_ASSERT
(
SASigArrayInitData
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveDataSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
const
DataSegment
*
seg
=
instance
-
>
passiveDataSegments_
[
segIndex
]
;
if
(
!
seg
&
&
(
numElements
!
=
0
|
|
segByteOffset
!
=
0
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
if
(
!
array
)
{
ReportTrapError
(
cx
JSMSG_WASM_DEREF_NULL
)
;
return
-
1
;
}
if
(
!
seg
)
{
return
0
;
}
const
TypeDef
*
typeDef
=
typeDefData
-
>
typeDef
;
Rooted
<
WasmArrayObject
*
>
arrayObj
(
cx
static_cast
<
WasmArrayObject
*
>
(
array
)
)
;
MOZ_RELEASE_ASSERT
(
arrayObj
-
>
is
<
WasmArrayObject
>
(
)
)
;
if
(
!
ArrayCopyFromData
(
cx
arrayObj
typeDef
index
seg
segByteOffset
numElements
)
)
{
return
-
1
;
}
return
0
;
}
int32_t
Instance
:
:
arrayInitElem
(
Instance
*
instance
void
*
array
uint32_t
index
uint32_t
segOffset
uint32_t
numElements
TypeDefInstanceData
*
typeDefData
uint32_t
segIndex
)
{
MOZ_ASSERT
(
SASigArrayInitElem
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
segIndex
)
<
instance
-
>
passiveElemSegments_
.
length
(
)
"
ensured
by
validation
"
)
;
const
InstanceElemSegment
&
seg
=
instance
-
>
passiveElemSegments_
[
segIndex
]
;
if
(
!
array
)
{
ReportTrapError
(
cx
JSMSG_WASM_DEREF_NULL
)
;
return
-
1
;
}
const
TypeDef
*
typeDef
=
typeDefData
-
>
typeDef
;
MOZ_RELEASE_ASSERT
(
typeDef
-
>
arrayType
(
)
.
elementType
(
)
.
size
(
)
=
=
sizeof
(
AnyRef
)
)
;
Rooted
<
WasmArrayObject
*
>
arrayObj
(
cx
static_cast
<
WasmArrayObject
*
>
(
array
)
)
;
MOZ_RELEASE_ASSERT
(
arrayObj
-
>
is
<
WasmArrayObject
>
(
)
)
;
if
(
!
ArrayCopyFromElem
(
cx
arrayObj
index
seg
segOffset
numElements
)
)
{
return
-
1
;
}
return
0
;
}
int32_t
Instance
:
:
arrayCopy
(
Instance
*
instance
void
*
dstArray
uint32_t
dstIndex
void
*
srcArray
uint32_t
srcIndex
uint32_t
numElements
uint32_t
elementSize
)
{
MOZ_ASSERT
(
SASigArrayCopy
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
if
(
!
srcArray
|
|
!
dstArray
)
{
ReportTrapError
(
cx
JSMSG_WASM_DEREF_NULL
)
;
return
-
1
;
}
bool
elemsAreRefTyped
=
false
;
if
(
int32_t
(
elementSize
)
<
0
)
{
elemsAreRefTyped
=
true
;
elementSize
=
uint32_t
(
-
int32_t
(
elementSize
)
)
;
}
MOZ_ASSERT
(
elementSize
>
=
1
&
&
elementSize
<
=
16
)
;
Rooted
<
WasmArrayObject
*
>
dstArrayObj
(
cx
static_cast
<
WasmArrayObject
*
>
(
dstArray
)
)
;
MOZ_RELEASE_ASSERT
(
dstArrayObj
-
>
is
<
WasmArrayObject
>
(
)
)
;
Rooted
<
WasmArrayObject
*
>
srcArrayObj
(
cx
static_cast
<
WasmArrayObject
*
>
(
srcArray
)
)
;
MOZ_RELEASE_ASSERT
(
srcArrayObj
-
>
is
<
WasmArrayObject
>
(
)
)
;
STATIC_ASSERT_WASMARRAYELEMENTS_NUMELEMENTS_IS_U32
;
uint64_t
dstNumElements
=
uint64_t
(
dstArrayObj
-
>
numElements_
)
;
if
(
uint64_t
(
dstIndex
)
+
uint64_t
(
numElements
)
>
dstNumElements
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
uint64_t
srcNumElements
=
uint64_t
(
srcArrayObj
-
>
numElements_
)
;
if
(
uint64_t
(
srcIndex
)
+
uint64_t
(
numElements
)
>
srcNumElements
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
uint64_t
numBytesToCopy
=
uint64_t
(
numElements
)
*
uint64_t
(
elementSize
)
;
#
ifndef
JS_64BIT
if
(
numBytesToCopy
>
uint64_t
(
UINT32_MAX
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
#
endif
uint8_t
*
srcBase
=
srcArrayObj
-
>
data_
;
uint8_t
*
dstBase
=
dstArrayObj
-
>
data_
;
srcBase
+
=
size_t
(
srcIndex
)
*
size_t
(
elementSize
)
;
dstBase
+
=
size_t
(
dstIndex
)
*
size_t
(
elementSize
)
;
if
(
numBytesToCopy
=
=
0
|
|
srcBase
=
=
dstBase
)
{
return
0
;
}
if
(
!
elemsAreRefTyped
)
{
memmove
(
dstBase
srcBase
size_t
(
numBytesToCopy
)
)
;
return
0
;
}
uint8_t
*
nextSrc
;
uint8_t
*
nextDst
;
intptr_t
step
;
if
(
dstBase
<
srcBase
)
{
step
=
intptr_t
(
elementSize
)
;
nextSrc
=
srcBase
;
nextDst
=
dstBase
;
}
else
{
step
=
-
intptr_t
(
elementSize
)
;
nextSrc
=
srcBase
+
size_t
(
numBytesToCopy
)
-
size_t
(
elementSize
)
;
nextDst
=
dstBase
+
size_t
(
numBytesToCopy
)
-
size_t
(
elementSize
)
;
}
RefType
aRefType
=
RefType
:
:
eq
(
)
;
for
(
size_t
i
=
0
;
i
<
size_t
(
numElements
)
;
i
+
+
)
{
RootedVal
value
(
cx
aRefType
)
;
value
.
get
(
)
.
readFromHeapLocation
(
nextSrc
)
;
value
.
get
(
)
.
writeToHeapLocation
(
nextDst
)
;
nextSrc
+
=
step
;
nextDst
+
=
step
;
}
return
0
;
}
void
*
Instance
:
:
exceptionNew
(
Instance
*
instance
void
*
tagArg
)
{
MOZ_ASSERT
(
SASigExceptionNew
.
failureMode
=
=
FailureMode
:
:
FailOnNullPtr
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
AnyRef
tag
=
AnyRef
:
:
fromCompiledCode
(
tagArg
)
;
Rooted
<
WasmTagObject
*
>
tagObj
(
cx
&
tag
.
toJSObject
(
)
.
as
<
WasmTagObject
>
(
)
)
;
RootedObject
proto
(
cx
&
cx
-
>
global
(
)
-
>
getPrototype
(
JSProto_WasmException
)
)
;
RootedObject
stack
(
cx
nullptr
)
;
return
AnyRef
:
:
fromJSObjectOrNull
(
WasmExceptionObject
:
:
create
(
cx
tagObj
stack
proto
)
)
.
forCompiledCode
(
)
;
}
int32_t
Instance
:
:
throwException
(
Instance
*
instance
void
*
exceptionArg
)
{
MOZ_ASSERT
(
SASigThrowException
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
AnyRef
exception
=
AnyRef
:
:
fromCompiledCode
(
exceptionArg
)
;
RootedValue
exnVal
(
cx
exception
.
toJSValue
(
)
)
;
cx
-
>
setPendingException
(
exnVal
nullptr
)
;
return
-
1
;
}
int32_t
Instance
:
:
intrI8VecMul
(
Instance
*
instance
uint32_t
dest
uint32_t
src1
uint32_t
src2
uint32_t
len
uint8_t
*
memBase
)
{
MOZ_ASSERT
(
SASigIntrI8VecMul
.
failureMode
=
=
FailureMode
:
:
FailOnNegI32
)
;
JSContext
*
cx
=
instance
-
>
cx
(
)
;
const
WasmArrayRawBuffer
*
rawBuf
=
WasmArrayRawBuffer
:
:
fromDataPtr
(
memBase
)
;
size_t
memLen
=
rawBuf
-
>
byteLength
(
)
;
uint64_t
destLimit
=
uint64_t
(
dest
)
+
uint64_t
(
len
)
;
uint64_t
src1Limit
=
uint64_t
(
src1
)
+
uint64_t
(
len
)
;
uint64_t
src2Limit
=
uint64_t
(
src2
)
+
uint64_t
(
len
)
;
if
(
destLimit
>
memLen
|
|
src1Limit
>
memLen
|
|
src2Limit
>
memLen
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
uint8_t
*
destPtr
=
&
memBase
[
dest
]
;
uint8_t
*
src1Ptr
=
&
memBase
[
src1
]
;
uint8_t
*
src2Ptr
=
&
memBase
[
src2
]
;
while
(
len
>
0
)
{
*
destPtr
=
(
*
src1Ptr
)
*
(
*
src2Ptr
)
;
destPtr
+
+
;
src1Ptr
+
+
;
src2Ptr
+
+
;
len
-
-
;
}
return
0
;
}
template
<
bool
isMutable
>
static
WasmArrayObject
*
UncheckedCastToArrayI16
(
HandleAnyRef
ref
)
{
JSObject
&
object
=
ref
.
toJSObject
(
)
;
WasmArrayObject
&
array
=
object
.
as
<
WasmArrayObject
>
(
)
;
DebugOnly
<
const
ArrayType
*
>
type
(
&
array
.
typeDef
(
)
.
arrayType
(
)
)
;
MOZ_ASSERT
(
type
-
>
elementType
(
)
=
=
StorageType
:
:
I16
)
;
MOZ_ASSERT
(
type
-
>
isMutable
(
)
=
=
isMutable
)
;
return
&
array
;
}
int32_t
Instance
:
:
stringTest
(
Instance
*
instance
void
*
stringArg
)
{
AnyRef
string
=
AnyRef
:
:
fromCompiledCode
(
stringArg
)
;
if
(
string
.
isNull
(
)
|
|
!
string
.
isJSString
(
)
)
{
return
0
;
}
return
1
;
}
void
*
Instance
:
:
stringCast
(
Instance
*
instance
void
*
stringArg
)
{
AnyRef
string
=
AnyRef
:
:
fromCompiledCode
(
stringArg
)
;
if
(
string
.
isNull
(
)
|
|
!
string
.
isJSString
(
)
)
{
ReportTrapError
(
instance
-
>
cx
(
)
JSMSG_WASM_BAD_CAST
)
;
return
nullptr
;
}
return
string
.
forCompiledCode
(
)
;
}
void
*
Instance
:
:
stringFromCharCodeArray
(
Instance
*
instance
void
*
arrayArg
uint32_t
arrayStart
uint32_t
arrayEnd
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
RootedAnyRef
arrayRef
(
cx
AnyRef
:
:
fromCompiledCode
(
arrayArg
)
)
;
if
(
arrayRef
.
isNull
(
)
)
{
ReportTrapError
(
instance
-
>
cx
(
)
JSMSG_WASM_BAD_CAST
)
;
return
nullptr
;
}
Rooted
<
WasmArrayObject
*
>
array
(
cx
UncheckedCastToArrayI16
<
true
>
(
arrayRef
)
)
;
if
(
arrayStart
>
arrayEnd
|
|
arrayEnd
>
array
-
>
numElements_
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
nullptr
;
}
uint32_t
arrayCount
=
arrayEnd
-
arrayStart
;
JSLinearString
*
string
=
NewStringCopyN
<
NoGC
char16_t
>
(
cx
(
char16_t
*
)
array
-
>
data_
+
arrayStart
arrayCount
)
;
if
(
!
string
)
{
return
nullptr
;
}
return
AnyRef
:
:
fromJSString
(
string
)
.
forCompiledCode
(
)
;
}
int32_t
Instance
:
:
stringIntoCharCodeArray
(
Instance
*
instance
void
*
stringArg
void
*
arrayArg
uint32_t
arrayStart
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
AnyRef
stringRef
=
AnyRef
:
:
fromCompiledCode
(
stringArg
)
;
if
(
!
stringRef
.
isJSString
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_BAD_CAST
)
;
return
-
1
;
}
Rooted
<
JSString
*
>
string
(
cx
stringRef
.
toJSString
(
)
)
;
size_t
stringLength
=
string
-
>
length
(
)
;
RootedAnyRef
arrayRef
(
cx
AnyRef
:
:
fromCompiledCode
(
arrayArg
)
)
;
if
(
arrayRef
.
isNull
(
)
)
{
ReportTrapError
(
instance
-
>
cx
(
)
JSMSG_WASM_BAD_CAST
)
;
return
-
1
;
}
Rooted
<
WasmArrayObject
*
>
array
(
cx
UncheckedCastToArrayI16
<
true
>
(
arrayRef
)
)
;
CheckedUint32
lastIndexPlus1
=
CheckedUint32
(
arrayStart
)
+
stringLength
;
if
(
!
lastIndexPlus1
.
isValid
(
)
|
|
lastIndexPlus1
.
value
(
)
>
array
-
>
numElements_
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
JSLinearString
*
linearStr
=
string
-
>
ensureLinear
(
cx
)
;
if
(
!
linearStr
)
{
return
-
1
;
}
char16_t
*
arrayData
=
reinterpret_cast
<
char16_t
*
>
(
array
-
>
data_
)
;
CopyChars
(
arrayData
+
arrayStart
*
linearStr
)
;
return
stringLength
;
}
void
*
Instance
:
:
stringFromCharCode
(
Instance
*
instance
uint32_t
charCode
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
JSString
*
str
=
StringFromCharCode
(
cx
int32_t
(
charCode
)
)
;
if
(
!
str
)
{
MOZ_ASSERT
(
cx
-
>
isThrowingOutOfMemory
(
)
)
;
return
nullptr
;
}
return
AnyRef
:
:
fromJSString
(
str
)
.
forCompiledCode
(
)
;
}
void
*
Instance
:
:
stringFromCodePoint
(
Instance
*
instance
uint32_t
codePoint
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
if
(
codePoint
>
unicode
:
:
NonBMPMax
)
{
ReportTrapError
(
cx
JSMSG_WASM_BAD_CODEPOINT
)
;
return
nullptr
;
}
JSString
*
str
=
StringFromCodePoint
(
cx
char32_t
(
codePoint
)
)
;
if
(
!
str
)
{
MOZ_ASSERT
(
cx
-
>
isThrowingOutOfMemory
(
)
)
;
return
nullptr
;
}
return
AnyRef
:
:
fromJSString
(
str
)
.
forCompiledCode
(
)
;
}
int32_t
Instance
:
:
stringCharCodeAt
(
Instance
*
instance
void
*
stringArg
uint32_t
index
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
AnyRef
stringRef
=
AnyRef
:
:
fromCompiledCode
(
stringArg
)
;
if
(
!
stringRef
.
isJSString
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_BAD_CAST
)
;
return
-
1
;
}
Rooted
<
JSString
*
>
string
(
cx
stringRef
.
toJSString
(
)
)
;
if
(
index
>
=
string
-
>
length
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
char16_t
c
;
if
(
!
string
-
>
getChar
(
cx
index
&
c
)
)
{
MOZ_ASSERT
(
cx
-
>
isThrowingOutOfMemory
(
)
)
;
return
false
;
}
return
c
;
}
int32_t
Instance
:
:
stringCodePointAt
(
Instance
*
instance
void
*
stringArg
uint32_t
index
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
AnyRef
stringRef
=
AnyRef
:
:
fromCompiledCode
(
stringArg
)
;
if
(
!
stringRef
.
isJSString
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_BAD_CAST
)
;
return
-
1
;
}
Rooted
<
JSString
*
>
string
(
cx
stringRef
.
toJSString
(
)
)
;
if
(
index
>
=
string
-
>
length
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
-
1
;
}
char32_t
c
;
if
(
!
string
-
>
getCodePoint
(
cx
index
&
c
)
)
{
MOZ_ASSERT
(
cx
-
>
isThrowingOutOfMemory
(
)
)
;
return
false
;
}
return
c
;
}
int32_t
Instance
:
:
stringLength
(
Instance
*
instance
void
*
stringArg
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
AnyRef
stringRef
=
AnyRef
:
:
fromCompiledCode
(
stringArg
)
;
if
(
!
stringRef
.
isJSString
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_BAD_CAST
)
;
return
-
1
;
}
static_assert
(
JS
:
:
MaxStringLength
<
=
INT32_MAX
)
;
return
(
int32_t
)
stringRef
.
toJSString
(
)
-
>
length
(
)
;
}
void
*
Instance
:
:
stringConcat
(
Instance
*
instance
void
*
firstStringArg
void
*
secondStringArg
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
AnyRef
firstStringRef
=
AnyRef
:
:
fromCompiledCode
(
firstStringArg
)
;
AnyRef
secondStringRef
=
AnyRef
:
:
fromCompiledCode
(
secondStringArg
)
;
if
(
!
firstStringRef
.
isJSString
(
)
|
|
!
secondStringRef
.
isJSString
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_BAD_CAST
)
;
return
nullptr
;
}
Rooted
<
JSString
*
>
firstString
(
cx
firstStringRef
.
toJSString
(
)
)
;
Rooted
<
JSString
*
>
secondString
(
cx
secondStringRef
.
toJSString
(
)
)
;
JSString
*
result
=
ConcatStrings
<
CanGC
>
(
cx
firstString
secondString
)
;
if
(
!
result
)
{
MOZ_ASSERT
(
cx
-
>
isThrowingOutOfMemory
(
)
)
;
return
nullptr
;
}
return
AnyRef
:
:
fromJSString
(
result
)
.
forCompiledCode
(
)
;
}
void
*
Instance
:
:
stringSubstring
(
Instance
*
instance
void
*
stringArg
int32_t
startIndex
int32_t
endIndex
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
AnyRef
stringRef
=
AnyRef
:
:
fromCompiledCode
(
stringArg
)
;
if
(
!
stringRef
.
isJSString
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_BAD_CAST
)
;
return
nullptr
;
}
RootedString
string
(
cx
stringRef
.
toJSString
(
)
)
;
static_assert
(
JS
:
:
MaxStringLength
<
=
INT32_MAX
)
;
if
(
(
uint32_t
)
startIndex
>
string
-
>
length
(
)
|
|
(
uint32_t
)
endIndex
>
string
-
>
length
(
)
|
|
startIndex
>
endIndex
)
{
return
AnyRef
:
:
fromJSString
(
cx
-
>
names
(
)
.
empty_
)
.
forCompiledCode
(
)
;
}
JSString
*
result
=
SubstringKernel
(
cx
string
startIndex
endIndex
-
startIndex
)
;
if
(
!
result
)
{
MOZ_ASSERT
(
cx
-
>
isThrowingOutOfMemory
(
)
)
;
return
nullptr
;
}
return
AnyRef
:
:
fromJSString
(
result
)
.
forCompiledCode
(
)
;
}
int32_t
Instance
:
:
stringEquals
(
Instance
*
instance
void
*
firstStringArg
void
*
secondStringArg
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
AnyRef
firstStringRef
=
AnyRef
:
:
fromCompiledCode
(
firstStringArg
)
;
AnyRef
secondStringRef
=
AnyRef
:
:
fromCompiledCode
(
secondStringArg
)
;
if
(
!
firstStringRef
.
isJSString
(
)
|
|
!
secondStringRef
.
isJSString
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_BAD_CAST
)
;
return
-
1
;
}
bool
equals
;
if
(
!
EqualStrings
(
cx
firstStringRef
.
toJSString
(
)
secondStringRef
.
toJSString
(
)
&
equals
)
)
{
MOZ_ASSERT
(
cx
-
>
isThrowingOutOfMemory
(
)
)
;
return
-
1
;
}
return
equals
?
1
:
0
;
}
int32_t
Instance
:
:
stringCompare
(
Instance
*
instance
void
*
firstStringArg
void
*
secondStringArg
)
{
JSContext
*
cx
=
instance
-
>
cx
(
)
;
AnyRef
firstStringRef
=
AnyRef
:
:
fromCompiledCode
(
firstStringArg
)
;
AnyRef
secondStringRef
=
AnyRef
:
:
fromCompiledCode
(
secondStringArg
)
;
if
(
!
firstStringRef
.
isJSString
(
)
|
|
!
secondStringRef
.
isJSString
(
)
)
{
ReportTrapError
(
cx
JSMSG_WASM_BAD_CAST
)
;
return
INT32_MAX
;
}
int32_t
result
;
if
(
!
CompareStrings
(
cx
firstStringRef
.
toJSString
(
)
secondStringRef
.
toJSString
(
)
&
result
)
)
{
MOZ_ASSERT
(
cx
-
>
isThrowingOutOfMemory
(
)
)
;
return
INT32_MAX
;
}
if
(
result
<
0
)
{
return
-
1
;
}
if
(
result
>
0
)
{
return
1
;
}
return
result
;
}
Instance
:
:
Instance
(
JSContext
*
cx
Handle
<
WasmInstanceObject
*
>
object
const
SharedCode
&
code
SharedTableVector
&
&
tables
UniqueDebugState
maybeDebug
)
:
realm_
(
cx
-
>
realm
(
)
)
onSuspendableStack_
(
false
)
jsJitArgsRectifier_
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getArgumentsRectifier
(
)
.
value
)
jsJitExceptionHandler_
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
getExceptionTail
(
)
.
value
)
preBarrierCode_
(
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
-
>
preBarrier
(
MIRType
:
:
WasmAnyRef
)
.
value
)
storeBuffer_
(
&
cx
-
>
runtime
(
)
-
>
gc
.
storeBuffer
(
)
)
object_
(
object
)
code_
(
std
:
:
move
(
code
)
)
tables_
(
std
:
:
move
(
tables
)
)
maybeDebug_
(
std
:
:
move
(
maybeDebug
)
)
debugFilter_
(
nullptr
)
callRefMetrics_
(
nullptr
)
maxInitializedGlobalsIndexPlus1_
(
0
)
{
for
(
size_t
i
=
0
;
i
<
N_BASELINE_SCRATCH_WORDS
;
i
+
+
)
{
baselineScratchWords_
[
i
]
=
0
;
}
}
Instance
*
Instance
:
:
create
(
JSContext
*
cx
Handle
<
WasmInstanceObject
*
>
object
const
SharedCode
&
code
uint32_t
instanceDataLength
SharedTableVector
&
&
tables
UniqueDebugState
maybeDebug
)
{
void
*
base
=
js_calloc
(
alignof
(
Instance
)
+
offsetof
(
Instance
data_
)
+
instanceDataLength
)
;
if
(
!
base
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
void
*
aligned
=
(
void
*
)
AlignBytes
(
uintptr_t
(
base
)
alignof
(
Instance
)
)
;
auto
*
instance
=
new
(
aligned
)
Instance
(
cx
object
code
std
:
:
move
(
tables
)
std
:
:
move
(
maybeDebug
)
)
;
instance
-
>
allocatedBase_
=
base
;
return
instance
;
}
void
Instance
:
:
destroy
(
Instance
*
instance
)
{
instance
-
>
~
Instance
(
)
;
js_free
(
instance
-
>
allocatedBase_
)
;
}
bool
Instance
:
:
init
(
JSContext
*
cx
const
JSObjectVector
&
funcImports
const
ValVector
&
globalImportValues
Handle
<
WasmMemoryObjectVector
>
memories
const
WasmGlobalObjectVector
&
globalObjs
const
WasmTagObjectVector
&
tagObjs
const
DataSegmentVector
&
dataSegments
const
ModuleElemSegmentVector
&
elemSegments
)
{
MOZ_ASSERT
(
!
!
maybeDebug_
=
=
codeMeta
(
)
.
debugEnabled
)
;
MOZ_ASSERT
(
funcImports
.
length
(
)
=
=
code
(
)
.
funcImports
(
)
.
length
(
)
)
;
MOZ_ASSERT
(
tables_
.
length
(
)
=
=
codeMeta
(
)
.
tables
.
length
(
)
)
;
cx_
=
cx
;
valueBoxClass_
=
AnyRef
:
:
valueBoxClass
(
)
;
resetInterrupt
(
cx
)
;
jumpTable_
=
code_
-
>
tieringJumpTable
(
)
;
debugFilter_
=
nullptr
;
callRefMetrics_
=
nullptr
;
addressOfNeedsIncrementalBarrier_
=
cx
-
>
compartment
(
)
-
>
zone
(
)
-
>
addressOfNeedsIncrementalBarrier
(
)
;
addressOfNurseryPosition_
=
cx
-
>
nursery
(
)
.
addressOfPosition
(
)
;
#
ifdef
JS_GC_ZEAL
addressOfGCZealModeBits_
=
cx
-
>
runtime
(
)
-
>
gc
.
addressOfZealModeBits
(
)
;
#
endif
if
(
code
(
)
.
mode
(
)
=
=
CompileMode
:
:
LazyTiering
)
{
setRequestTierUpStub
(
code
(
)
.
sharedStubs
(
)
.
segment
-
>
base
(
)
+
code
(
)
.
requestTierUpStubOffset
(
)
)
;
}
else
{
setRequestTierUpStub
(
nullptr
)
;
}
if
(
code
(
)
.
mode
(
)
=
=
CompileMode
:
:
LazyTiering
)
{
for
(
uint32_t
funcIndex
=
codeMeta
(
)
.
numFuncImports
;
funcIndex
<
codeMeta
(
)
.
numFuncs
(
)
;
funcIndex
+
+
)
{
funcDefInstanceData
(
funcIndex
)
-
>
hotnessCounter
=
computeInitialHotnessCounter
(
funcIndex
)
;
}
}
const
SharedTypeContext
&
types
=
codeMeta
(
)
.
types
;
Zone
*
zone
=
realm
(
)
-
>
zone
(
)
;
for
(
uint32_t
typeIndex
=
0
;
typeIndex
<
types
-
>
length
(
)
;
typeIndex
+
+
)
{
const
TypeDef
&
typeDef
=
types
-
>
type
(
typeIndex
)
;
TypeDefInstanceData
*
typeDefData
=
typeDefInstanceData
(
typeIndex
)
;
new
(
typeDefData
)
TypeDefInstanceData
(
)
;
typeDefData
-
>
typeDef
=
&
typeDef
;
typeDefData
-
>
superTypeVector
=
typeDef
.
superTypeVector
(
)
;
if
(
typeDef
.
kind
(
)
=
=
TypeDefKind
:
:
Struct
|
|
typeDef
.
kind
(
)
=
=
TypeDefKind
:
:
Array
)
{
const
JSClass
*
clasp
;
gc
:
:
AllocKind
allocKind
;
if
(
typeDef
.
kind
(
)
=
=
TypeDefKind
:
:
Struct
)
{
clasp
=
WasmStructObject
:
:
classForTypeDef
(
&
typeDef
)
;
allocKind
=
WasmStructObject
:
:
allocKindForTypeDef
(
&
typeDef
)
;
if
(
CanChangeToBackgroundAllocKind
(
allocKind
clasp
)
)
{
allocKind
=
ForegroundToBackgroundAllocKind
(
allocKind
)
;
}
}
else
{
clasp
=
&
WasmArrayObject
:
:
class_
;
allocKind
=
gc
:
:
AllocKind
:
:
INVALID
;
}
const
ObjectFlags
objectFlags
=
{
ObjectFlag
:
:
NotExtensible
}
;
typeDefData
-
>
shape
=
WasmGCShape
:
:
getShape
(
cx
clasp
cx
-
>
realm
(
)
TaggedProto
(
)
&
typeDef
.
recGroup
(
)
objectFlags
)
;
if
(
!
typeDefData
-
>
shape
)
{
return
false
;
}
typeDefData
-
>
clasp
=
clasp
;
typeDefData
-
>
allocKind
=
allocKind
;
typeDefData
-
>
allocSite
.
initWasm
(
zone
)
;
MOZ_ASSERT
(
typeDefData
-
>
unused
=
=
0
)
;
if
(
typeDef
.
kind
(
)
=
=
TypeDefKind
:
:
Struct
)
{
typeDefData
-
>
structTypeSize
=
typeDef
.
structType
(
)
.
size_
;
MOZ_ASSERT
(
(
typeDefData
-
>
structTypeSize
%
sizeof
(
uintptr_t
)
)
=
=
0
)
;
}
else
{
uint32_t
arrayElemSize
=
typeDef
.
arrayType
(
)
.
elementType
(
)
.
size
(
)
;
typeDefData
-
>
arrayElemSize
=
arrayElemSize
;
MOZ_ASSERT
(
arrayElemSize
=
=
16
|
|
arrayElemSize
=
=
8
|
|
arrayElemSize
=
=
4
|
|
arrayElemSize
=
=
2
|
|
arrayElemSize
=
=
1
)
;
}
}
else
if
(
typeDef
.
kind
(
)
=
=
TypeDefKind
:
:
Func
)
{
}
else
{
MOZ_ASSERT
(
typeDef
.
kind
(
)
=
=
TypeDefKind
:
:
None
)
;
MOZ_CRASH
(
)
;
}
}
for
(
size_t
i
=
0
;
i
<
code
(
)
.
funcImports
(
)
.
length
(
)
;
i
+
+
)
{
JSObject
*
f
=
funcImports
[
i
]
;
#
ifdef
ENABLE_WASM_JSPI
if
(
JSObject
*
suspendingObject
=
MaybeUnwrapSuspendingObject
(
f
)
)
{
const
FuncType
&
funcType
=
codeMeta
(
)
.
getFuncType
(
i
)
;
RootedObject
wrapped
(
cx
suspendingObject
)
;
RootedFunction
wrapper
(
cx
WasmSuspendingFunctionCreate
(
cx
wrapped
funcType
)
)
;
if
(
!
wrapper
)
{
return
false
;
}
MOZ_ASSERT
(
IsWasmExportedFunction
(
wrapper
)
)
;
f
=
wrapper
;
}
#
endif
MOZ_ASSERT
(
f
-
>
isCallable
(
)
)
;
const
FuncImport
&
fi
=
code
(
)
.
funcImport
(
i
)
;
const
FuncType
&
funcType
=
codeMeta
(
)
.
getFuncType
(
i
)
;
FuncImportInstanceData
&
import
=
funcImportInstanceData
(
i
)
;
import
.
callable
=
f
;
if
(
f
-
>
is
<
JSFunction
>
(
)
)
{
JSFunction
*
fun
=
&
f
-
>
as
<
JSFunction
>
(
)
;
if
(
!
isAsmJS
(
)
&
&
IsWasmExportedFunction
(
fun
)
)
{
WasmInstanceObject
*
calleeInstanceObj
=
ExportedFunctionToInstanceObject
(
fun
)
;
Instance
&
calleeInstance
=
calleeInstanceObj
-
>
instance
(
)
;
uint8_t
*
codeRangeBase
;
const
CodeRange
*
codeRange
;
calleeInstanceObj
-
>
getExportedFunctionCodeRange
(
&
f
-
>
as
<
JSFunction
>
(
)
&
codeRange
&
codeRangeBase
)
;
import
.
instance
=
&
calleeInstance
;
import
.
realm
=
fun
-
>
realm
(
)
;
import
.
code
=
codeRangeBase
+
codeRange
-
>
funcUncheckedCallEntry
(
)
;
}
else
if
(
void
*
thunk
=
MaybeGetBuiltinThunk
(
fun
funcType
)
)
{
import
.
instance
=
this
;
import
.
realm
=
fun
-
>
realm
(
)
;
import
.
code
=
thunk
;
}
else
{
import
.
instance
=
this
;
import
.
realm
=
fun
-
>
realm
(
)
;
import
.
code
=
code
(
)
.
sharedStubs
(
)
.
segment
-
>
base
(
)
+
fi
.
interpExitCodeOffset
(
)
;
}
}
else
{
import
.
instance
=
this
;
import
.
realm
=
f
-
>
nonCCWRealm
(
)
;
import
.
code
=
code
(
)
.
sharedStubs
(
)
.
segment
-
>
base
(
)
+
fi
.
interpExitCodeOffset
(
)
;
}
}
#
ifdef
DEBUG
for
(
size_t
i
=
0
;
i
<
codeMeta
(
)
.
numExportedFuncs
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
!
funcExportInstanceData
(
i
)
.
func
)
;
}
#
endif
maxInitializedGlobalsIndexPlus1_
=
0
;
for
(
size_t
i
=
0
;
i
<
codeMeta
(
)
.
globals
.
length
(
)
;
i
+
+
maxInitializedGlobalsIndexPlus1_
=
i
)
{
const
GlobalDesc
&
global
=
codeMeta
(
)
.
globals
[
i
]
;
if
(
global
.
isConstant
(
)
)
{
continue
;
}
uint8_t
*
globalAddr
=
data
(
)
+
global
.
offset
(
)
;
switch
(
global
.
kind
(
)
)
{
case
GlobalKind
:
:
Import
:
{
size_t
imported
=
global
.
importIndex
(
)
;
if
(
global
.
isIndirect
(
)
)
{
*
(
void
*
*
)
globalAddr
=
(
void
*
)
&
globalObjs
[
imported
]
-
>
val
(
)
.
get
(
)
.
cell
(
)
;
}
else
{
globalImportValues
[
imported
]
.
writeToHeapLocation
(
globalAddr
)
;
}
break
;
}
case
GlobalKind
:
:
Variable
:
{
RootedVal
val
(
cx
)
;
const
InitExpr
&
init
=
global
.
initExpr
(
)
;
Rooted
<
WasmInstanceObject
*
>
instanceObj
(
cx
object
(
)
)
;
if
(
!
init
.
evaluate
(
cx
instanceObj
&
val
)
)
{
return
false
;
}
if
(
global
.
isIndirect
(
)
)
{
globalObjs
[
i
]
-
>
setVal
(
val
)
;
*
(
void
*
*
)
globalAddr
=
globalObjs
[
i
]
-
>
addressOfCell
(
)
;
}
else
{
val
.
get
(
)
.
writeToHeapLocation
(
globalAddr
)
;
}
break
;
}
case
GlobalKind
:
:
Constant
:
{
MOZ_CRASH
(
"
skipped
at
the
top
"
)
;
}
}
}
MOZ_ASSERT
(
maxInitializedGlobalsIndexPlus1_
=
=
codeMeta
(
)
.
globals
.
length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
memories
.
length
(
)
;
i
+
+
)
{
const
MemoryDesc
&
md
=
codeMeta
(
)
.
memories
[
i
]
;
MemoryInstanceData
&
data
=
memoryInstanceData
(
i
)
;
WasmMemoryObject
*
memory
=
memories
.
get
(
)
[
i
]
;
data
.
memory
=
memory
;
data
.
base
=
memory
-
>
buffer
(
)
.
dataPointerEither
(
)
.
unwrap
(
)
;
size_t
limit
=
memory
-
>
boundsCheckLimit
(
)
;
#
if
!
defined
(
JS_64BIT
)
MOZ_ASSERT
(
limit
<
=
UINT32_MAX
)
;
#
endif
data
.
boundsCheckLimit
=
limit
;
data
.
isShared
=
md
.
isShared
(
)
;
if
(
memory
&
&
memory
-
>
movingGrowable
(
)
&
&
!
memory
-
>
addMovingGrowObserver
(
cx
object_
)
)
{
return
false
;
}
}
if
(
memories
.
length
(
)
>
0
)
{
MemoryInstanceData
&
data
=
memoryInstanceData
(
0
)
;
memory0Base_
=
data
.
base
;
memory0BoundsCheckLimit_
=
data
.
boundsCheckLimit
;
}
else
{
memory0Base_
=
nullptr
;
memory0BoundsCheckLimit_
=
0
;
}
for
(
size_t
i
=
0
;
i
<
tables_
.
length
(
)
;
i
+
+
)
{
const
TableDesc
&
td
=
codeMeta
(
)
.
tables
[
i
]
;
TableInstanceData
&
table
=
tableInstanceData
(
i
)
;
table
.
length
=
tables_
[
i
]
-
>
length
(
)
;
table
.
elements
=
tables_
[
i
]
-
>
instanceElements
(
)
;
if
(
!
td
.
isImported
&
&
td
.
initExpr
)
{
Rooted
<
WasmInstanceObject
*
>
instanceObj
(
cx
object
(
)
)
;
RootedVal
val
(
cx
)
;
if
(
!
td
.
initExpr
-
>
evaluate
(
cx
instanceObj
&
val
)
)
{
return
false
;
}
RootedAnyRef
ref
(
cx
val
.
get
(
)
.
ref
(
)
)
;
tables_
[
i
]
-
>
fillUninitialized
(
0
tables_
[
i
]
-
>
length
(
)
ref
cx
)
;
}
}
#
ifdef
DEBUG
for
(
size_t
i
=
0
;
i
<
tables_
.
length
(
)
;
i
+
+
)
{
const
TableDesc
&
td
=
codeMeta
(
)
.
tables
[
i
]
;
if
(
!
td
.
elemType
.
isNullable
(
)
)
{
tables_
[
i
]
-
>
assertRangeNotNull
(
0
tables_
[
i
]
-
>
length
(
)
)
;
}
}
#
endif
for
(
size_t
i
=
0
;
i
<
codeMeta
(
)
.
tags
.
length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
tagObjs
[
i
]
!
=
nullptr
)
;
tagInstanceData
(
i
)
.
object
=
tagObjs
[
i
]
;
}
pendingException_
=
nullptr
;
pendingExceptionTag_
=
nullptr
;
if
(
codeMeta
(
)
.
debugEnabled
)
{
size_t
numFuncs
=
codeMeta
(
)
.
numFuncs
(
)
;
size_t
numWords
=
std
:
:
max
<
size_t
>
(
(
numFuncs
+
31
)
/
32
1
)
;
debugFilter_
=
(
uint32_t
*
)
js_calloc
(
numWords
sizeof
(
uint32_t
)
)
;
if
(
!
debugFilter_
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
if
(
code
(
)
.
mode
(
)
=
=
CompileMode
:
:
LazyTiering
)
{
callRefMetrics_
=
(
CallRefMetrics
*
)
js_calloc
(
codeMeta
(
)
.
numCallRefMetrics
sizeof
(
CallRefMetrics
)
)
;
if
(
!
callRefMetrics_
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
else
{
MOZ_ASSERT
(
codeMeta
(
)
.
numCallRefMetrics
=
=
0
)
;
}
for
(
const
SharedTable
&
table
:
tables_
)
{
if
(
table
-
>
movingGrowable
(
)
&
&
!
table
-
>
addMovingGrowObserver
(
cx
object_
)
)
{
return
false
;
}
}
if
(
!
passiveDataSegments_
.
resize
(
dataSegments
.
length
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
for
(
size_t
i
=
0
;
i
<
dataSegments
.
length
(
)
;
i
+
+
)
{
if
(
!
dataSegments
[
i
]
-
>
active
(
)
)
{
passiveDataSegments_
[
i
]
=
dataSegments
[
i
]
;
}
}
if
(
!
passiveElemSegments_
.
resize
(
elemSegments
.
length
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
for
(
size_t
i
=
0
;
i
<
elemSegments
.
length
(
)
;
i
+
+
)
{
const
ModuleElemSegment
&
seg
=
elemSegments
[
i
]
;
if
(
seg
.
kind
=
=
ModuleElemSegment
:
:
Kind
:
:
Passive
)
{
passiveElemSegments_
[
i
]
=
InstanceElemSegment
(
)
;
InstanceElemSegment
&
instanceSeg
=
passiveElemSegments_
[
i
]
;
if
(
!
instanceSeg
.
reserve
(
seg
.
numElements
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
bool
ok
=
iterElemsAnyrefs
(
seg
[
&
]
(
uint32_t
_
AnyRef
ref
)
-
>
bool
{
instanceSeg
.
infallibleAppend
(
ref
)
;
return
true
;
}
)
;
if
(
!
ok
)
{
return
false
;
}
}
}
return
true
;
}
Instance
:
:
~
Instance
(
)
{
realm_
-
>
wasm
.
unregisterInstance
(
*
this
)
;
if
(
debugFilter_
)
{
js_free
(
debugFilter_
)
;
}
if
(
callRefMetrics_
)
{
js_free
(
callRefMetrics_
)
;
}
MOZ_ASSERT
(
pendingException_
.
isNull
(
)
)
;
}
void
Instance
:
:
setInterrupt
(
)
{
interrupt_
=
true
;
stackLimit_
=
JS
:
:
NativeStackLimitMin
;
}
bool
Instance
:
:
isInterrupted
(
)
const
{
return
interrupt_
|
|
stackLimit_
=
=
JS
:
:
NativeStackLimitMin
;
}
void
Instance
:
:
resetInterrupt
(
JSContext
*
cx
)
{
interrupt_
=
false
;
#
ifdef
ENABLE_WASM_JSPI
if
(
cx
-
>
wasm
(
)
.
suspendableStackLimit
!
=
JS
:
:
NativeStackLimitMin
)
{
stackLimit_
=
cx
-
>
wasm
(
)
.
suspendableStackLimit
;
return
;
}
#
endif
stackLimit_
=
cx
-
>
stackLimitForJitCode
(
JS
:
:
StackForUntrustedScript
)
;
}
void
Instance
:
:
setTemporaryStackLimit
(
JS
:
:
NativeStackLimit
limit
)
{
if
(
!
isInterrupted
(
)
)
{
stackLimit_
=
limit
;
}
onSuspendableStack_
=
true
;
}
void
Instance
:
:
resetTemporaryStackLimit
(
JSContext
*
cx
)
{
if
(
!
isInterrupted
(
)
)
{
stackLimit_
=
cx
-
>
stackLimitForJitCode
(
JS
:
:
StackForUntrustedScript
)
;
}
onSuspendableStack_
=
false
;
}
int32_t
Instance
:
:
computeInitialHotnessCounter
(
uint32_t
funcIndex
)
{
MOZ_ASSERT
(
code
(
)
.
mode
(
)
=
=
CompileMode
:
:
LazyTiering
)
;
uint32_t
bodyLength
=
codeMeta
(
)
.
funcDefRanges
[
funcIndex
-
codeMeta
(
)
.
numFuncImports
]
.
bodyLength
;
return
codeMeta
(
)
.
lazyTieringHeuristics
.
estimateIonCompilationCost
(
bodyLength
)
;
}
void
Instance
:
:
resetHotnessCounter
(
uint32_t
funcIndex
)
{
funcDefInstanceData
(
funcIndex
)
-
>
hotnessCounter
=
INT32_MAX
;
}
int32_t
Instance
:
:
readHotnessCounter
(
uint32_t
funcIndex
)
const
{
return
funcDefInstanceData
(
funcIndex
)
-
>
hotnessCounter
;
}
void
Instance
:
:
submitCallRefHints
(
uint32_t
funcIndex
)
{
uint32_t
callCountThreshold
=
JS
:
:
Prefs
:
:
wasm_experimental_inline_call_ref_threshold
(
)
;
CallRefMetricsRange
range
=
codeMeta
(
)
.
getFuncDefCallRefs
(
funcIndex
)
;
for
(
uint32_t
callRefIndex
=
range
.
begin
;
callRefIndex
<
range
.
begin
+
range
.
length
;
callRefIndex
+
+
)
{
MOZ_RELEASE_ASSERT
(
callRefIndex
<
codeMeta
(
)
.
numCallRefMetrics
)
;
CallRefMetrics
&
metrics
=
callRefMetrics_
[
callRefIndex
]
;
if
(
metrics
.
state
=
=
CallRefMetrics
:
:
State
:
:
Monomorphic
&
&
metrics
.
callCount
>
=
callCountThreshold
)
{
uint32_t
funcIndex
=
wasm
:
:
ExportedFunctionToFuncIndex
(
metrics
.
monomorphicTarget
)
;
codeMeta
(
)
.
setCallRefHint
(
callRefIndex
CallRefHint
:
:
inlineFunc
(
funcIndex
)
)
;
}
else
{
codeMeta
(
)
.
setCallRefHint
(
callRefIndex
CallRefHint
:
:
unknown
(
)
)
;
}
}
}
bool
Instance
:
:
debugFilter
(
uint32_t
funcIndex
)
const
{
return
(
debugFilter_
[
funcIndex
/
32
]
>
>
funcIndex
%
32
)
&
1
;
}
void
Instance
:
:
setDebugFilter
(
uint32_t
funcIndex
bool
value
)
{
if
(
value
)
{
debugFilter_
[
funcIndex
/
32
]
|
=
(
1
<
<
funcIndex
%
32
)
;
}
else
{
debugFilter_
[
funcIndex
/
32
]
&
=
~
(
1
<
<
funcIndex
%
32
)
;
}
}
bool
Instance
:
:
memoryAccessInGuardRegion
(
const
uint8_t
*
addr
unsigned
numBytes
)
const
{
MOZ_ASSERT
(
numBytes
>
0
)
;
for
(
uint32_t
memoryIndex
=
0
;
memoryIndex
<
codeMeta
(
)
.
memories
.
length
(
)
;
memoryIndex
+
+
)
{
uint8_t
*
base
=
memoryBase
(
memoryIndex
)
.
unwrap
(
)
;
if
(
addr
<
base
)
{
continue
;
}
WasmMemoryObject
*
mem
=
memory
(
memoryIndex
)
;
size_t
lastByteOffset
=
addr
-
base
+
(
numBytes
-
1
)
;
if
(
lastByteOffset
>
=
mem
-
>
volatileMemoryLength
(
)
&
&
lastByteOffset
<
mem
-
>
buffer
(
)
.
wasmMappedSize
(
)
)
{
return
true
;
}
}
return
false
;
}
void
Instance
:
:
tracePrivate
(
JSTracer
*
trc
)
{
MOZ_ASSERT_IF
(
trc
-
>
isMarkingTracer
(
)
gc
:
:
IsMarked
(
trc
-
>
runtime
(
)
object_
)
)
;
TraceEdge
(
trc
&
object_
"
wasm
instance
object
"
)
;
for
(
uint32_t
funcIndex
=
0
;
funcIndex
<
codeMeta
(
)
.
numFuncImports
;
funcIndex
+
+
)
{
TraceNullableEdge
(
trc
&
funcImportInstanceData
(
funcIndex
)
.
callable
"
wasm
import
"
)
;
}
for
(
uint32_t
funcExportIndex
=
0
;
funcExportIndex
<
codeMeta
(
)
.
numExportedFuncs
(
)
;
funcExportIndex
+
+
)
{
TraceNullableEdge
(
trc
&
funcExportInstanceData
(
funcExportIndex
)
.
func
"
wasm
func
export
"
)
;
}
for
(
uint32_t
memoryIndex
=
0
;
memoryIndex
<
code
(
)
.
codeMeta
(
)
.
memories
.
length
(
)
;
memoryIndex
+
+
)
{
MemoryInstanceData
&
memoryData
=
memoryInstanceData
(
memoryIndex
)
;
TraceNullableEdge
(
trc
&
memoryData
.
memory
"
wasm
memory
object
"
)
;
}
for
(
const
SharedTable
&
table
:
tables_
)
{
table
-
>
trace
(
trc
)
;
}
for
(
const
GlobalDesc
&
global
:
code
(
)
.
codeMeta
(
)
.
globals
)
{
if
(
!
global
.
type
(
)
.
isRefRepr
(
)
|
|
global
.
isConstant
(
)
|
|
global
.
isIndirect
(
)
)
{
continue
;
}
GCPtr
<
AnyRef
>
*
obj
=
(
GCPtr
<
AnyRef
>
*
)
(
data
(
)
+
global
.
offset
(
)
)
;
TraceNullableEdge
(
trc
obj
"
wasm
reference
-
typed
global
"
)
;
}
for
(
uint32_t
tagIndex
=
0
;
tagIndex
<
code
(
)
.
codeMeta
(
)
.
tags
.
length
(
)
;
tagIndex
+
+
)
{
TraceNullableEdge
(
trc
&
tagInstanceData
(
tagIndex
)
.
object
"
wasm
tag
"
)
;
}
const
SharedTypeContext
&
types
=
codeMeta
(
)
.
types
;
for
(
uint32_t
typeIndex
=
0
;
typeIndex
<
types
-
>
length
(
)
;
typeIndex
+
+
)
{
TypeDefInstanceData
*
typeDefData
=
typeDefInstanceData
(
typeIndex
)
;
TraceNullableEdge
(
trc
&
typeDefData
-
>
shape
"
wasm
shape
"
)
;
}
if
(
callRefMetrics_
)
{
for
(
uint32_t
i
=
0
;
i
<
codeMeta
(
)
.
numCallRefMetrics
;
i
+
+
)
{
TraceNullableEdge
(
trc
&
callRefMetrics_
[
i
]
.
monomorphicTarget
"
indirect
call
target
"
)
;
}
}
TraceNullableEdge
(
trc
&
pendingException_
"
wasm
pending
exception
value
"
)
;
TraceNullableEdge
(
trc
&
pendingExceptionTag_
"
wasm
pending
exception
tag
"
)
;
passiveElemSegments_
.
trace
(
trc
)
;
if
(
maybeDebug_
)
{
maybeDebug_
-
>
trace
(
trc
)
;
}
}
void
js
:
:
wasm
:
:
TraceInstanceEdge
(
JSTracer
*
trc
Instance
*
instance
const
char
*
name
)
{
if
(
IsTracerKind
(
trc
JS
:
:
TracerKind
:
:
Moving
)
)
{
return
;
}
JSObject
*
object
=
instance
-
>
objectUnbarriered
(
)
;
TraceManuallyBarrieredEdge
(
trc
&
object
name
)
;
}
static
uintptr_t
*
GetFrameScanStartForStackMap
(
const
Frame
*
frame
const
StackMap
*
map
uintptr_t
*
highestByteVisitedInPrevFrame
)
{
const
size_t
numMappedBytes
=
map
-
>
header
.
numMappedWords
*
sizeof
(
void
*
)
;
const
uintptr_t
scanStart
=
uintptr_t
(
frame
)
+
(
map
-
>
header
.
frameOffsetFromTop
*
sizeof
(
void
*
)
)
-
numMappedBytes
;
MOZ_ASSERT
(
0
=
=
scanStart
%
sizeof
(
void
*
)
)
;
#
ifndef
JS_CODEGEN_ARM64
MOZ_ASSERT_IF
(
highestByteVisitedInPrevFrame
&
&
*
highestByteVisitedInPrevFrame
!
=
0
*
highestByteVisitedInPrevFrame
+
1
=
=
scanStart
)
;
#
endif
if
(
highestByteVisitedInPrevFrame
)
{
*
highestByteVisitedInPrevFrame
=
scanStart
+
numMappedBytes
-
1
;
}
MOZ_ASSERT_IF
(
map
-
>
header
.
numExitStubWords
>
0
(
(
uintptr_t
*
)
scanStart
)
[
map
-
>
header
.
numExitStubWords
-
1
-
TrapExitDummyValueOffsetFromTop
]
=
=
TrapExitDummyValue
)
;
return
(
uintptr_t
*
)
scanStart
;
}
uintptr_t
Instance
:
:
traceFrame
(
JSTracer
*
trc
const
wasm
:
:
WasmFrameIter
&
wfi
uint8_t
*
nextPC
uintptr_t
highestByteVisitedInPrevFrame
)
{
const
StackMap
*
map
=
code
(
)
.
lookupStackMap
(
nextPC
)
;
if
(
!
map
)
{
return
0
;
}
Frame
*
frame
=
wfi
.
frame
(
)
;
uintptr_t
*
stackWords
=
GetFrameScanStartForStackMap
(
frame
map
&
highestByteVisitedInPrevFrame
)
;
for
(
uint32_t
i
=
0
;
i
<
map
-
>
header
.
numMappedWords
;
i
+
+
)
{
if
(
map
-
>
get
(
i
)
!
=
StackMap
:
:
Kind
:
:
AnyRef
)
{
continue
;
}
TraceManuallyBarrieredNullableEdge
(
trc
(
AnyRef
*
)
&
stackWords
[
i
]
"
Instance
:
:
traceWasmFrame
:
normal
word
"
)
;
}
if
(
map
-
>
header
.
hasDebugFrameWithLiveRefs
)
{
DebugFrame
*
debugFrame
=
DebugFrame
:
:
from
(
frame
)
;
char
*
debugFrameP
=
(
char
*
)
debugFrame
;
for
(
size_t
i
=
0
;
i
<
MaxRegisterResults
;
i
+
+
)
{
if
(
debugFrame
-
>
hasSpilledRegisterRefResult
(
i
)
)
{
char
*
resultRefP
=
debugFrameP
+
DebugFrame
:
:
offsetOfRegisterResult
(
i
)
;
TraceManuallyBarrieredNullableEdge
(
trc
(
AnyRef
*
)
resultRefP
"
Instance
:
:
traceWasmFrame
:
DebugFrame
:
:
resultResults_
"
)
;
}
}
if
(
debugFrame
-
>
hasCachedReturnJSValue
(
)
)
{
char
*
cachedReturnJSValueP
=
debugFrameP
+
DebugFrame
:
:
offsetOfCachedReturnJSValue
(
)
;
TraceManuallyBarrieredEdge
(
trc
(
js
:
:
Value
*
)
cachedReturnJSValueP
"
Instance
:
:
traceWasmFrame
:
DebugFrame
:
:
cachedReturnJSValue_
"
)
;
}
}
return
highestByteVisitedInPrevFrame
;
}
void
Instance
:
:
updateFrameForMovingGC
(
const
wasm
:
:
WasmFrameIter
&
wfi
uint8_t
*
nextPC
)
{
const
StackMap
*
map
=
code
(
)
.
lookupStackMap
(
nextPC
)
;
if
(
!
map
)
{
return
;
}
Frame
*
frame
=
wfi
.
frame
(
)
;
uintptr_t
*
stackWords
=
GetFrameScanStartForStackMap
(
frame
map
nullptr
)
;
for
(
uint32_t
i
=
0
;
i
<
map
-
>
header
.
numMappedWords
;
i
+
+
)
{
if
(
map
-
>
get
(
i
)
!
=
StackMap
:
:
Kind
:
:
ArrayDataPointer
)
{
continue
;
}
uint8_t
*
*
addressOfArrayDataPointer
=
(
uint8_t
*
*
)
&
stackWords
[
i
]
;
if
(
WasmArrayObject
:
:
isDataInline
(
*
addressOfArrayDataPointer
)
)
{
WasmArrayObject
*
oldArray
=
WasmArrayObject
:
:
fromInlineDataPointer
(
*
addressOfArrayDataPointer
)
;
WasmArrayObject
*
newArray
=
(
WasmArrayObject
*
)
gc
:
:
MaybeForwarded
(
oldArray
)
;
*
addressOfArrayDataPointer
=
WasmArrayObject
:
:
addressOfInlineData
(
newArray
)
;
}
}
}
WasmMemoryObject
*
Instance
:
:
memory
(
uint32_t
memoryIndex
)
const
{
return
memoryInstanceData
(
memoryIndex
)
.
memory
;
}
SharedMem
<
uint8_t
*
>
Instance
:
:
memoryBase
(
uint32_t
memoryIndex
)
const
{
MOZ_ASSERT_IF
(
memoryIndex
=
=
0
memory0Base_
=
=
memory
(
memoryIndex
)
-
>
buffer
(
)
.
dataPointerEither
(
)
)
;
return
memory
(
memoryIndex
)
-
>
buffer
(
)
.
dataPointerEither
(
)
;
}
SharedArrayRawBuffer
*
Instance
:
:
sharedMemoryBuffer
(
uint32_t
memoryIndex
)
const
{
MOZ_ASSERT
(
memory
(
memoryIndex
)
-
>
isShared
(
)
)
;
return
memory
(
memoryIndex
)
-
>
sharedArrayRawBuffer
(
)
;
}
WasmInstanceObject
*
Instance
:
:
objectUnbarriered
(
)
const
{
return
object_
.
unbarrieredGet
(
)
;
}
WasmInstanceObject
*
Instance
:
:
object
(
)
const
{
return
object_
;
}
static
bool
GetInterpEntryAndEnsureStubs
(
JSContext
*
cx
Instance
&
instance
uint32_t
funcIndex
const
CallArgs
&
args
void
*
*
interpEntry
const
FuncType
*
*
funcType
)
{
const
FuncExport
*
funcExport
;
if
(
!
instance
.
code
(
)
.
getOrCreateInterpEntry
(
funcIndex
&
funcExport
interpEntry
)
)
{
return
false
;
}
*
funcType
=
&
instance
.
codeMeta
(
)
.
getFuncType
(
funcIndex
)
;
#
ifdef
DEBUG
if
(
!
funcExport
-
>
hasEagerStubs
(
)
&
&
(
*
funcType
)
-
>
canHaveJitEntry
(
)
)
{
if
(
!
EnsureBuiltinThunksInitialized
(
)
)
{
return
false
;
}
JSFunction
&
callee
=
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
;
void
*
provisionalLazyJitEntryStub
=
ProvisionalLazyJitEntryStub
(
)
;
MOZ_ASSERT
(
provisionalLazyJitEntryStub
)
;
MOZ_ASSERT
(
callee
.
isWasmWithJitEntry
(
)
)
;
MOZ_ASSERT
(
*
callee
.
wasmJitEntry
(
)
!
=
provisionalLazyJitEntryStub
)
;
}
#
endif
return
true
;
}
bool
wasm
:
:
ResultsToJSValue
(
JSContext
*
cx
ResultType
type
void
*
registerResultLoc
Maybe
<
char
*
>
stackResultsLoc
MutableHandleValue
rval
CoercionLevel
level
)
{
if
(
type
.
empty
(
)
)
{
rval
.
setUndefined
(
)
;
return
true
;
}
static_assert
(
MaxRegisterResults
=
=
1
)
;
ABIResultIter
iter
(
type
)
;
DebugOnly
<
bool
>
usedRegisterResult
=
false
;
for
(
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
if
(
iter
.
cur
(
)
.
inRegister
(
)
)
{
MOZ_ASSERT
(
!
usedRegisterResult
)
;
if
(
!
ToJSValue
<
DebugCodegenVal
>
(
cx
registerResultLoc
iter
.
cur
(
)
.
type
(
)
rval
level
)
)
{
return
false
;
}
usedRegisterResult
=
true
;
}
}
MOZ_ASSERT
(
usedRegisterResult
)
;
MOZ_ASSERT
(
(
stackResultsLoc
.
isSome
(
)
)
=
=
(
iter
.
count
(
)
>
1
)
)
;
if
(
!
stackResultsLoc
)
{
return
true
;
}
Rooted
<
ArrayObject
*
>
array
(
cx
NewDenseEmptyArray
(
cx
)
)
;
if
(
!
array
)
{
return
false
;
}
RootedValue
tmp
(
cx
)
;
for
(
iter
.
switchToPrev
(
)
;
!
iter
.
done
(
)
;
iter
.
prev
(
)
)
{
const
ABIResult
&
result
=
iter
.
cur
(
)
;
if
(
result
.
onStack
(
)
)
{
char
*
loc
=
stackResultsLoc
.
value
(
)
+
result
.
stackOffset
(
)
;
if
(
!
ToJSValue
<
DebugCodegenVal
>
(
cx
loc
result
.
type
(
)
&
tmp
level
)
)
{
return
false
;
}
if
(
!
NewbornArrayPush
(
cx
array
tmp
)
)
{
return
false
;
}
}
else
{
if
(
!
NewbornArrayPush
(
cx
array
rval
)
)
{
return
false
;
}
}
}
rval
.
set
(
ObjectValue
(
*
array
)
)
;
return
true
;
}
class
MOZ_RAII
ReturnToJSResultCollector
{
class
MOZ_RAII
StackResultsRooter
:
public
JS
:
:
CustomAutoRooter
{
ReturnToJSResultCollector
&
collector_
;
public
:
StackResultsRooter
(
JSContext
*
cx
ReturnToJSResultCollector
&
collector
)
:
JS
:
:
CustomAutoRooter
(
cx
)
collector_
(
collector
)
{
}
void
trace
(
JSTracer
*
trc
)
final
{
for
(
ABIResultIter
iter
(
collector_
.
type_
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
ABIResult
&
result
=
iter
.
cur
(
)
;
if
(
result
.
onStack
(
)
&
&
result
.
type
(
)
.
isRefRepr
(
)
)
{
char
*
loc
=
collector_
.
stackResultsArea_
.
get
(
)
+
result
.
stackOffset
(
)
;
AnyRef
*
refLoc
=
reinterpret_cast
<
AnyRef
*
>
(
loc
)
;
TraceNullableRoot
(
trc
refLoc
"
StackResultsRooter
:
:
trace
"
)
;
}
}
}
}
;
friend
class
StackResultsRooter
;
ResultType
type_
;
UniquePtr
<
char
[
]
JS
:
:
FreePolicy
>
stackResultsArea_
;
Maybe
<
StackResultsRooter
>
rooter_
;
public
:
explicit
ReturnToJSResultCollector
(
const
ResultType
&
type
)
:
type_
(
type
)
{
}
;
bool
init
(
JSContext
*
cx
)
{
bool
needRooter
=
false
;
ABIResultIter
iter
(
type_
)
;
for
(
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
ABIResult
&
result
=
iter
.
cur
(
)
;
if
(
result
.
onStack
(
)
&
&
result
.
type
(
)
.
isRefRepr
(
)
)
{
needRooter
=
true
;
}
}
uint32_t
areaBytes
=
iter
.
stackBytesConsumedSoFar
(
)
;
MOZ_ASSERT_IF
(
needRooter
areaBytes
>
0
)
;
if
(
areaBytes
>
0
)
{
stackResultsArea_
=
cx
-
>
make_zeroed_pod_array
<
char
>
(
areaBytes
)
;
if
(
!
stackResultsArea_
)
{
return
false
;
}
if
(
needRooter
)
{
rooter_
.
emplace
(
cx
*
this
)
;
}
}
return
true
;
}
void
*
stackResultsArea
(
)
{
MOZ_ASSERT
(
stackResultsArea_
)
;
return
stackResultsArea_
.
get
(
)
;
}
bool
collect
(
JSContext
*
cx
void
*
registerResultLoc
MutableHandleValue
rval
CoercionLevel
level
)
{
Maybe
<
char
*
>
stackResultsLoc
=
stackResultsArea_
?
Some
(
stackResultsArea_
.
get
(
)
)
:
Nothing
(
)
;
return
ResultsToJSValue
(
cx
type_
registerResultLoc
stackResultsLoc
rval
level
)
;
}
}
;
static
bool
WasmCall
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
RootedFunction
callee
(
cx
&
args
.
callee
(
)
.
as
<
JSFunction
>
(
)
)
;
Instance
&
instance
=
ExportedFunctionToInstance
(
callee
)
;
uint32_t
funcIndex
=
ExportedFunctionToFuncIndex
(
callee
)
;
return
instance
.
callExport
(
cx
funcIndex
args
)
;
}
bool
Instance
:
:
getExportedFunction
(
JSContext
*
cx
uint32_t
funcIndex
MutableHandleFunction
result
)
{
uint32_t
funcExportIndex
=
codeMeta
(
)
.
findFuncExportIndex
(
funcIndex
)
;
FuncExportInstanceData
&
instanceData
=
funcExportInstanceData
(
funcExportIndex
)
;
if
(
instanceData
.
func
)
{
result
.
set
(
instanceData
.
func
)
;
return
true
;
}
if
(
funcIndex
<
codeMeta
(
)
.
numFuncImports
)
{
FuncImportInstanceData
&
import
=
funcImportInstanceData
(
funcIndex
)
;
if
(
import
.
callable
-
>
is
<
JSFunction
>
(
)
)
{
JSFunction
*
fun
=
&
import
.
callable
-
>
as
<
JSFunction
>
(
)
;
if
(
IsWasmExportedFunction
(
fun
)
)
{
instanceData
.
func
=
fun
;
result
.
set
(
fun
)
;
return
true
;
}
}
}
const
CodeBlock
&
codeBlock
=
code
(
)
.
funcCodeBlock
(
funcIndex
)
;
const
FuncExport
&
funcExport
=
codeBlock
.
lookupFuncExport
(
funcIndex
)
;
const
TypeDef
&
funcTypeDef
=
codeMeta
(
)
.
getFuncTypeDef
(
funcIndex
)
;
unsigned
numArgs
=
funcTypeDef
.
funcType
(
)
.
args
(
)
.
length
(
)
;
if
(
isAsmJS
(
)
)
{
Rooted
<
JSAtom
*
>
name
(
cx
getFuncDisplayAtom
(
cx
funcIndex
)
)
;
if
(
!
name
)
{
return
false
;
}
result
.
set
(
NewNativeConstructor
(
cx
WasmCall
numArgs
name
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
TenuredObject
FunctionFlags
:
:
ASMJS_CTOR
)
)
;
if
(
!
result
)
{
return
false
;
}
MOZ_ASSERT
(
result
-
>
isTenured
(
)
)
;
STATIC_ASSERT_WASM_FUNCTIONS_TENURED
;
result
-
>
setWasmFuncIndex
(
funcIndex
)
;
}
else
{
Rooted
<
JSAtom
*
>
name
(
cx
NumberToAtom
(
cx
funcIndex
)
)
;
if
(
!
name
)
{
return
false
;
}
RootedObject
proto
(
cx
)
;
#
ifdef
ENABLE_WASM_TYPE_REFLECTIONS
proto
=
GlobalObject
:
:
getOrCreatePrototype
(
cx
JSProto_WasmFunction
)
;
if
(
!
proto
)
{
return
false
;
}
#
endif
result
.
set
(
NewFunctionWithProto
(
cx
WasmCall
numArgs
FunctionFlags
:
:
WASM
nullptr
name
proto
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
TenuredObject
)
)
;
if
(
!
result
)
{
return
false
;
}
MOZ_ASSERT
(
result
-
>
isTenured
(
)
)
;
STATIC_ASSERT_WASM_FUNCTIONS_TENURED
;
if
(
funcTypeDef
.
funcType
(
)
.
canHaveJitEntry
(
)
)
{
if
(
!
funcExport
.
hasEagerStubs
(
)
)
{
if
(
!
EnsureBuiltinThunksInitialized
(
)
)
{
return
false
;
}
void
*
provisionalLazyJitEntryStub
=
ProvisionalLazyJitEntryStub
(
)
;
MOZ_ASSERT
(
provisionalLazyJitEntryStub
)
;
code
(
)
.
setJitEntryIfNull
(
funcIndex
provisionalLazyJitEntryStub
)
;
}
result
-
>
setWasmJitEntry
(
code
(
)
.
getAddressOfJitEntry
(
funcIndex
)
)
;
}
else
{
result
-
>
setWasmFuncIndex
(
funcIndex
)
;
}
}
result
-
>
setExtendedSlot
(
FunctionExtended
:
:
WASM_INSTANCE_SLOT
PrivateValue
(
const_cast
<
Instance
*
>
(
this
)
)
)
;
result
-
>
setExtendedSlot
(
FunctionExtended
:
:
WASM_STV_SLOT
PrivateValue
(
(
void
*
)
funcTypeDef
.
superTypeVector
(
)
)
)
;
const
CodeRange
&
codeRange
=
codeBlock
.
codeRange
(
funcExport
)
;
result
-
>
setExtendedSlot
(
FunctionExtended
:
:
WASM_FUNC_UNCHECKED_ENTRY_SLOT
PrivateValue
(
codeBlock
.
segment
-
>
base
(
)
+
codeRange
.
funcUncheckedCallEntry
(
)
)
)
;
instanceData
.
func
=
result
;
return
true
;
}
bool
Instance
:
:
callExport
(
JSContext
*
cx
uint32_t
funcIndex
const
CallArgs
&
args
CoercionLevel
level
)
{
if
(
memory0Base_
)
{
MOZ_RELEASE_ASSERT
(
memoryBase
(
0
)
.
unwrap
(
)
=
=
memory0Base_
)
;
}
void
*
interpEntry
;
const
FuncType
*
funcType
;
if
(
!
GetInterpEntryAndEnsureStubs
(
cx
*
this
funcIndex
args
&
interpEntry
&
funcType
)
)
{
return
false
;
}
if
(
level
!
=
CoercionLevel
:
:
Lossless
&
&
funcType
-
>
hasUnexposableArgOrRet
(
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_BAD_VAL_TYPE
)
;
return
false
;
}
ArgTypeVector
argTypes
(
*
funcType
)
;
ResultType
resultType
(
ResultType
:
:
Vector
(
funcType
-
>
results
(
)
)
)
;
ReturnToJSResultCollector
results
(
resultType
)
;
if
(
!
results
.
init
(
cx
)
)
{
return
false
;
}
Vector
<
ExportArg
8
>
exportArgs
(
cx
)
;
if
(
!
exportArgs
.
resize
(
std
:
:
max
<
size_t
>
(
1
argTypes
.
lengthWithStackResults
(
)
)
)
)
{
return
false
;
}
Rooted
<
GCVector
<
AnyRef
8
SystemAllocPolicy
>
>
refs
(
cx
)
;
DebugCodegen
(
DebugChannel
:
:
Function
"
wasm
-
function
[
%
d
]
arguments
[
"
funcIndex
)
;
RootedValue
v
(
cx
)
;
for
(
size_t
i
=
0
;
i
<
argTypes
.
lengthWithStackResults
(
)
;
+
+
i
)
{
void
*
rawArgLoc
=
&
exportArgs
[
i
]
;
if
(
argTypes
.
isSyntheticStackResultPointerArg
(
i
)
)
{
*
reinterpret_cast
<
void
*
*
>
(
rawArgLoc
)
=
results
.
stackResultsArea
(
)
;
continue
;
}
size_t
naturalIdx
=
argTypes
.
naturalIndex
(
i
)
;
v
=
naturalIdx
<
args
.
length
(
)
?
args
[
naturalIdx
]
:
UndefinedValue
(
)
;
ValType
type
=
funcType
-
>
arg
(
naturalIdx
)
;
if
(
!
ToWebAssemblyValue
<
DebugCodegenVal
>
(
cx
v
type
rawArgLoc
true
level
)
)
{
return
false
;
}
if
(
type
.
isRefRepr
(
)
)
{
void
*
ptr
=
*
reinterpret_cast
<
void
*
*
>
(
rawArgLoc
)
;
RootedAnyRef
ref
(
cx
AnyRef
:
:
fromCompiledCode
(
ptr
)
)
;
if
(
!
refs
.
emplaceBack
(
ref
.
get
(
)
)
)
{
return
false
;
}
DebugCodegen
(
DebugChannel
:
:
Function
"
/
(
#
%
d
)
"
int
(
refs
.
length
(
)
-
1
)
)
;
}
}
if
(
refs
.
length
(
)
>
0
)
{
DebugCodegen
(
DebugChannel
:
:
Function
"
;
"
)
;
size_t
nextRef
=
0
;
for
(
size_t
i
=
0
;
i
<
argTypes
.
lengthWithStackResults
(
)
;
+
+
i
)
{
if
(
argTypes
.
isSyntheticStackResultPointerArg
(
i
)
)
{
continue
;
}
size_t
naturalIdx
=
argTypes
.
naturalIndex
(
i
)
;
ValType
type
=
funcType
-
>
arg
(
naturalIdx
)
;
if
(
type
.
isRefRepr
(
)
)
{
AnyRef
*
rawArgLoc
=
(
AnyRef
*
)
&
exportArgs
[
i
]
;
*
rawArgLoc
=
refs
[
nextRef
+
+
]
;
DebugCodegen
(
DebugChannel
:
:
Function
"
ref
(
#
%
d
)
:
=
%
p
"
int
(
nextRef
-
1
)
*
(
void
*
*
)
rawArgLoc
)
;
}
}
refs
.
clear
(
)
;
}
DebugCodegen
(
DebugChannel
:
:
Function
"
]
\
n
"
)
;
MOZ_ASSERT
(
pendingException_
.
isNull
(
)
)
;
{
JitActivation
activation
(
cx
)
;
auto
funcPtr
=
JS_DATA_TO_FUNC_PTR
(
ExportFuncPtr
interpEntry
)
;
if
(
!
CALL_GENERATED_2
(
funcPtr
exportArgs
.
begin
(
)
this
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
pendingException_
.
isNull
(
)
)
;
if
(
isAsmJS
(
)
&
&
args
.
isConstructing
(
)
)
{
PlainObject
*
obj
=
NewPlainObject
(
cx
)
;
if
(
!
obj
)
{
return
false
;
}
args
.
rval
(
)
.
set
(
ObjectValue
(
*
obj
)
)
;
return
true
;
}
void
*
registerResultLoc
=
&
exportArgs
[
0
]
;
DebugCodegen
(
DebugChannel
:
:
Function
"
wasm
-
function
[
%
d
]
;
results
[
"
funcIndex
)
;
if
(
!
results
.
collect
(
cx
registerResultLoc
args
.
rval
(
)
level
)
)
{
return
false
;
}
DebugCodegen
(
DebugChannel
:
:
Function
"
]
\
n
"
)
;
return
true
;
}
void
Instance
:
:
setPendingException
(
Handle
<
WasmExceptionObject
*
>
exn
)
{
pendingException_
=
AnyRef
:
:
fromJSObject
(
*
exn
.
get
(
)
)
;
pendingExceptionTag_
=
AnyRef
:
:
fromJSObject
(
exn
-
>
as
<
WasmExceptionObject
>
(
)
.
tag
(
)
)
;
}
void
Instance
:
:
constantGlobalGet
(
uint32_t
globalIndex
MutableHandleVal
result
)
{
MOZ_RELEASE_ASSERT
(
globalIndex
<
maxInitializedGlobalsIndexPlus1_
)
;
const
GlobalDesc
&
global
=
codeMeta
(
)
.
globals
[
globalIndex
]
;
if
(
global
.
isConstant
(
)
)
{
result
.
set
(
Val
(
global
.
constantValue
(
)
)
)
;
return
;
}
const
void
*
cell
=
addressOfGlobalCell
(
global
)
;
result
.
address
(
)
-
>
initFromHeapLocation
(
global
.
type
(
)
cell
)
;
}
bool
Instance
:
:
constantRefFunc
(
uint32_t
funcIndex
MutableHandleFuncRef
result
)
{
void
*
fnref
=
Instance
:
:
refFunc
(
this
funcIndex
)
;
if
(
fnref
=
=
AnyRef
:
:
invalid
(
)
.
forCompiledCode
(
)
)
{
return
false
;
}
result
.
set
(
FuncRef
:
:
fromCompiledCode
(
fnref
)
)
;
return
true
;
}
WasmStructObject
*
Instance
:
:
constantStructNewDefault
(
JSContext
*
cx
uint32_t
typeIndex
)
{
TypeDefInstanceData
*
typeDefData
=
typeDefInstanceData
(
typeIndex
)
;
const
wasm
:
:
TypeDef
*
typeDef
=
typeDefData
-
>
typeDef
;
MOZ_ASSERT
(
typeDef
-
>
kind
(
)
=
=
wasm
:
:
TypeDefKind
:
:
Struct
)
;
uint32_t
totalBytes
=
typeDef
-
>
structType
(
)
.
size_
;
bool
needsOOL
=
WasmStructObject
:
:
requiresOutlineBytes
(
totalBytes
)
;
return
needsOOL
?
WasmStructObject
:
:
createStructOOL
<
true
>
(
cx
typeDefData
gc
:
:
Heap
:
:
Tenured
)
:
WasmStructObject
:
:
createStructIL
<
true
>
(
cx
typeDefData
gc
:
:
Heap
:
:
Tenured
)
;
}
WasmArrayObject
*
Instance
:
:
constantArrayNewDefault
(
JSContext
*
cx
uint32_t
typeIndex
uint32_t
numElements
)
{
TypeDefInstanceData
*
typeDefData
=
typeDefInstanceData
(
typeIndex
)
;
return
WasmArrayObject
:
:
createArray
<
true
>
(
cx
typeDefData
gc
:
:
Heap
:
:
Tenured
numElements
)
;
}
JSAtom
*
Instance
:
:
getFuncDisplayAtom
(
JSContext
*
cx
uint32_t
funcIndex
)
const
{
UTF8Bytes
name
;
bool
ok
;
if
(
codeMetaForAsmJS
(
)
)
{
ok
=
codeMetaForAsmJS
(
)
-
>
getFuncNameForAsmJS
(
funcIndex
&
name
)
;
}
else
{
ok
=
codeMeta
(
)
.
getFuncNameForWasm
(
NameContext
:
:
BeforeLocation
funcIndex
&
name
)
;
}
if
(
!
ok
)
{
return
nullptr
;
}
return
AtomizeUTF8Chars
(
cx
name
.
begin
(
)
name
.
length
(
)
)
;
}
void
Instance
:
:
ensureProfilingLabels
(
bool
profilingEnabled
)
const
{
return
code_
-
>
ensureProfilingLabels
(
profilingEnabled
)
;
}
void
Instance
:
:
onMovingGrowMemory
(
const
WasmMemoryObject
*
memory
)
{
MOZ_ASSERT
(
!
isAsmJS
(
)
)
;
MOZ_ASSERT
(
!
memory
-
>
isShared
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
codeMeta
(
)
.
memories
.
length
(
)
;
i
+
+
)
{
MemoryInstanceData
&
md
=
memoryInstanceData
(
i
)
;
if
(
memory
!
=
md
.
memory
)
{
continue
;
}
ArrayBufferObject
&
buffer
=
md
.
memory
-
>
buffer
(
)
.
as
<
ArrayBufferObject
>
(
)
;
md
.
base
=
buffer
.
dataPointer
(
)
;
size_t
limit
=
md
.
memory
-
>
boundsCheckLimit
(
)
;
#
if
!
defined
(
JS_64BIT
)
MOZ_ASSERT
(
limit
<
=
UINT32_MAX
)
;
#
endif
md
.
boundsCheckLimit
=
limit
;
if
(
i
=
=
0
)
{
memory0Base_
=
md
.
base
;
memory0BoundsCheckLimit_
=
md
.
boundsCheckLimit
;
}
}
}
void
Instance
:
:
onMovingGrowTable
(
const
Table
*
table
)
{
MOZ_ASSERT
(
!
isAsmJS
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
tables_
.
length
(
)
;
i
+
+
)
{
if
(
tables_
[
i
]
!
=
table
)
{
continue
;
}
TableInstanceData
&
table
=
tableInstanceData
(
i
)
;
table
.
length
=
tables_
[
i
]
-
>
length
(
)
;
table
.
elements
=
tables_
[
i
]
-
>
instanceElements
(
)
;
}
}
JSString
*
Instance
:
:
createDisplayURL
(
JSContext
*
cx
)
{
if
(
codeMeta
(
)
.
scriptedCaller
(
)
.
filenameIsURL
)
{
const
char
*
filename
=
codeMeta
(
)
.
scriptedCaller
(
)
.
filename
.
get
(
)
;
return
NewStringCopyUTF8N
(
cx
JS
:
:
UTF8Chars
(
filename
strlen
(
filename
)
)
)
;
}
JSStringBuilder
result
(
cx
)
;
if
(
!
result
.
append
(
"
wasm
:
"
)
)
{
return
nullptr
;
}
if
(
const
char
*
filename
=
codeMeta
(
)
.
scriptedCaller
(
)
.
filename
.
get
(
)
)
{
JSString
*
filenamePrefix
=
EncodeURI
(
cx
filename
strlen
(
filename
)
)
;
if
(
!
filenamePrefix
)
{
if
(
cx
-
>
isThrowingOutOfMemory
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
cx
-
>
isThrowingOverRecursed
(
)
)
;
cx
-
>
clearPendingException
(
)
;
return
nullptr
;
}
if
(
!
result
.
append
(
filenamePrefix
)
)
{
return
nullptr
;
}
}
if
(
codeMeta
(
)
.
debugEnabled
)
{
if
(
!
result
.
append
(
"
:
"
)
)
{
return
nullptr
;
}
const
ModuleHash
&
hash
=
codeMeta
(
)
.
debugHash
;
for
(
unsigned
char
byte
:
hash
)
{
unsigned
char
digit1
=
byte
/
16
digit2
=
byte
%
16
;
if
(
!
result
.
append
(
(
char
)
(
digit1
<
10
?
digit1
+
'
0
'
:
digit1
+
'
a
'
-
10
)
)
)
{
return
nullptr
;
}
if
(
!
result
.
append
(
(
char
)
(
digit2
<
10
?
digit2
+
'
0
'
:
digit2
+
'
a
'
-
10
)
)
)
{
return
nullptr
;
}
}
}
return
result
.
finishString
(
)
;
}
WasmBreakpointSite
*
Instance
:
:
getOrCreateBreakpointSite
(
JSContext
*
cx
uint32_t
offset
)
{
MOZ_ASSERT
(
debugEnabled
(
)
)
;
return
debug
(
)
.
getOrCreateBreakpointSite
(
cx
this
offset
)
;
}
void
Instance
:
:
destroyBreakpointSite
(
JS
:
:
GCContext
*
gcx
uint32_t
offset
)
{
MOZ_ASSERT
(
debugEnabled
(
)
)
;
return
debug
(
)
.
destroyBreakpointSite
(
gcx
this
offset
)
;
}
void
Instance
:
:
disassembleExport
(
JSContext
*
cx
uint32_t
funcIndex
Tier
tier
PrintCallback
printString
)
const
{
const
CodeBlock
&
codeBlock
=
code
(
)
.
funcCodeBlock
(
funcIndex
)
;
const
FuncExport
&
funcExport
=
codeBlock
.
lookupFuncExport
(
funcIndex
)
;
const
CodeRange
&
range
=
codeBlock
.
codeRange
(
funcExport
)
;
const
CodeSegment
&
segment
=
*
codeBlock
.
segment
;
MOZ_ASSERT
(
range
.
begin
(
)
<
segment
.
lengthBytes
(
)
)
;
MOZ_ASSERT
(
range
.
end
(
)
<
segment
.
lengthBytes
(
)
)
;
uint8_t
*
functionCode
=
segment
.
base
(
)
+
range
.
begin
(
)
;
jit
:
:
Disassemble
(
functionCode
range
.
end
(
)
-
range
.
begin
(
)
printString
)
;
}
void
Instance
:
:
addSizeOfMisc
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
CodeMetadata
:
:
SeenSet
*
seenCodeMeta
CodeMetadataForAsmJS
:
:
SeenSet
*
seenCodeMetaForAsmJS
Code
:
:
SeenSet
*
seenCode
Table
:
:
SeenSet
*
seenTables
size_t
*
code
size_t
*
data
)
const
{
*
data
+
=
mallocSizeOf
(
this
)
;
for
(
const
SharedTable
&
table
:
tables_
)
{
*
data
+
=
table
-
>
sizeOfIncludingThisIfNotSeen
(
mallocSizeOf
seenTables
)
;
}
if
(
maybeDebug_
)
{
maybeDebug_
-
>
addSizeOfMisc
(
mallocSizeOf
seenCodeMeta
seenCodeMetaForAsmJS
seenCode
code
data
)
;
}
code_
-
>
addSizeOfMiscIfNotSeen
(
mallocSizeOf
seenCodeMeta
seenCodeMetaForAsmJS
seenCode
code
data
)
;
}
void
wasm
:
:
ReportTrapError
(
JSContext
*
cx
unsigned
errorNumber
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
errorNumber
)
;
if
(
cx
-
>
isThrowingOutOfMemory
(
)
)
{
return
;
}
RootedValue
exn
(
cx
)
;
if
(
!
cx
-
>
getPendingException
(
&
exn
)
)
{
return
;
}
MOZ_ASSERT
(
exn
.
isObject
(
)
&
&
exn
.
toObject
(
)
.
is
<
ErrorObject
>
(
)
)
;
exn
.
toObject
(
)
.
as
<
ErrorObject
>
(
)
.
setFromWasmTrap
(
)
;
}
