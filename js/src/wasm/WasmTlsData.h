#
ifndef
wasm_tls_data_h
#
define
wasm_tls_data_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
<
stdint
.
h
>
#
include
"
NamespaceImports
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
wasm
/
WasmTypeDecls
.
h
"
namespace
js
{
namespace
wasm
{
using
mozilla
:
:
Atomic
;
class
Instance
;
struct
TlsData
;
struct
TlsDataDeleter
{
void
operator
(
)
(
TlsData
*
tlsData
)
;
}
;
using
UniqueTlsData
=
UniquePtr
<
TlsData
TlsDataDeleter
>
;
struct
TlsData
{
static
constexpr
size_t
offsetOfMemoryBase
(
)
{
return
offsetof
(
TlsData
memoryBase_
)
;
}
static
constexpr
size_t
offsetOfBoundsCheckLimit
(
)
{
return
offsetof
(
TlsData
boundsCheckLimit_
)
;
}
static
constexpr
size_t
offsetOfInstance
(
)
{
return
offsetof
(
TlsData
instance_
)
;
}
static
constexpr
size_t
offsetOfRealm
(
)
{
return
offsetof
(
TlsData
realm_
)
;
}
static
constexpr
size_t
offsetOfCx
(
)
{
return
offsetof
(
TlsData
cx_
)
;
}
static
constexpr
size_t
offsetOfValueBoxClass
(
)
{
return
offsetof
(
TlsData
valueBoxClass_
)
;
}
static
constexpr
size_t
offsetOfPendingException
(
)
{
return
offsetof
(
TlsData
pendingException_
)
;
}
static
constexpr
size_t
offsetOfPendingExceptionTag
(
)
{
return
offsetof
(
TlsData
pendingExceptionTag_
)
;
}
static
constexpr
size_t
offsetOfStackLimit
(
)
{
return
offsetof
(
TlsData
stackLimit_
)
;
}
static
constexpr
size_t
offsetOfInterrupt
(
)
{
return
offsetof
(
TlsData
interrupt_
)
;
}
static
constexpr
size_t
offsetOfAddressOfNeedsIncrementalBarrier
(
)
{
return
offsetof
(
TlsData
addressOfNeedsIncrementalBarrier_
)
;
}
static
constexpr
size_t
offsetOfJumpTable
(
)
{
return
offsetof
(
TlsData
jumpTable_
)
;
}
static
constexpr
size_t
offsetOfBaselineScratch
(
)
{
return
offsetof
(
TlsData
baselineScratch_
)
;
}
static
constexpr
size_t
sizeOfBaselineScratch
(
)
{
return
sizeof
(
baselineScratch_
)
;
}
static
constexpr
size_t
offsetOfGlobalArea
(
)
{
return
offsetof
(
TlsData
globalArea_
)
;
}
static
UniqueTlsData
create
(
uint32_t
globalDataLength
)
;
void
setInterrupt
(
)
;
bool
isInterrupted
(
)
const
;
void
resetInterrupt
(
JSContext
*
cx
)
;
JSContext
*
cx
(
)
const
{
return
cx_
;
}
Instance
*
instance
(
)
const
{
return
instance_
;
}
protected
:
friend
class
Instance
;
friend
struct
TlsDataDeleter
;
uint8_t
*
memoryBase_
;
uintptr_t
boundsCheckLimit_
;
Instance
*
instance_
;
JS
:
:
Realm
*
realm_
;
JSContext
*
cx_
;
const
JSClass
*
valueBoxClass_
;
#
ifdef
ENABLE_WASM_EXCEPTIONS
GCPtrObject
pendingException_
;
GCPtrObject
pendingExceptionTag_
;
#
endif
Atomic
<
uintptr_t
mozilla
:
:
Relaxed
>
stackLimit_
;
Atomic
<
uint32_t
mozilla
:
:
Relaxed
>
interrupt_
;
const
JS
:
:
shadow
:
:
Zone
:
:
BarrierState
*
addressOfNeedsIncrementalBarrier_
;
void
*
allocatedBase_
;
void
*
*
jumpTable_
;
uint32_t
baselineScratch_
[
2
]
;
MOZ_ALIGNED_DECL
(
16
char
globalArea_
)
;
}
;
static
const
size_t
TlsDataAlign
=
16
;
static_assert
(
TlsData
:
:
offsetOfGlobalArea
(
)
%
TlsDataAlign
=
=
0
"
aligned
"
)
;
struct
ExportArg
{
uint64_t
lo
;
uint64_t
hi
;
}
;
using
ExportFuncPtr
=
int32_t
(
*
)
(
ExportArg
*
TlsData
*
)
;
struct
FuncImportTls
{
void
*
code
;
TlsData
*
tls
;
JS
:
:
Realm
*
realm
;
GCPtrFunction
fun
;
static_assert
(
sizeof
(
GCPtrFunction
)
=
=
sizeof
(
void
*
)
"
for
JIT
access
"
)
;
}
;
struct
TableTls
{
uint32_t
length
;
void
*
functionBase
;
}
;
struct
FunctionTableElem
{
void
*
code
;
TlsData
*
tls
;
}
;
}
}
#
endif
