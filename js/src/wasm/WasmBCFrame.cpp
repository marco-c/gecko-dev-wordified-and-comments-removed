#
include
"
wasm
/
WasmBCFrame
.
h
"
#
include
"
wasm
/
WasmBaselineCompile
.
h
"
#
include
"
wasm
/
WasmBCClass
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
#
include
"
wasm
/
WasmBCClass
-
inl
.
h
"
#
include
"
wasm
/
WasmBCCodegen
-
inl
.
h
"
#
include
"
wasm
/
WasmBCRegDefs
-
inl
.
h
"
#
include
"
wasm
/
WasmBCRegMgmt
-
inl
.
h
"
#
include
"
wasm
/
WasmBCStkMgmt
-
inl
.
h
"
namespace
js
{
namespace
wasm
{
BaseLocalIter
:
:
BaseLocalIter
(
const
ValTypeVector
&
locals
const
ArgTypeVector
&
args
bool
debugEnabled
)
:
locals_
(
locals
)
args_
(
args
)
argsIter_
(
args_
)
index_
(
0
)
frameSize_
(
0
)
nextFrameSize_
(
debugEnabled
?
DebugFrame
:
:
offsetOfFrame
(
)
:
0
)
frameOffset_
(
INT32_MAX
)
stackResultPointerOffset_
(
INT32_MAX
)
mirType_
(
MIRType
:
:
Undefined
)
done_
(
false
)
{
MOZ_ASSERT
(
args
.
lengthWithoutStackResults
(
)
<
=
locals
.
length
(
)
)
;
settle
(
)
;
}
int32_t
BaseLocalIter
:
:
pushLocal
(
size_t
nbytes
)
{
MOZ_ASSERT
(
nbytes
%
4
=
=
0
&
&
nbytes
<
=
16
)
;
nextFrameSize_
=
AlignBytes
(
frameSize_
nbytes
)
+
nbytes
;
return
nextFrameSize_
;
}
void
BaseLocalIter
:
:
settle
(
)
{
MOZ_ASSERT
(
!
done_
)
;
frameSize_
=
nextFrameSize_
;
if
(
!
argsIter_
.
done
(
)
)
{
mirType_
=
argsIter_
.
mirType
(
)
;
MIRType
concreteType
=
mirType_
;
switch
(
mirType_
)
{
case
MIRType
:
:
StackResults
:
MOZ_ASSERT
(
args_
.
isSyntheticStackResultPointerArg
(
index_
)
)
;
concreteType
=
MIRType
:
:
Pointer
;
[
[
fallthrough
]
]
;
case
MIRType
:
:
Int32
:
case
MIRType
:
:
Int64
:
case
MIRType
:
:
Double
:
case
MIRType
:
:
Float32
:
case
MIRType
:
:
RefOrNull
:
#
ifdef
ENABLE_WASM_SIMD
case
MIRType
:
:
Simd128
:
#
endif
if
(
argsIter_
-
>
argInRegister
(
)
)
{
frameOffset_
=
pushLocal
(
MIRTypeToSize
(
concreteType
)
)
;
}
else
{
frameOffset_
=
-
(
argsIter_
-
>
offsetFromArgBase
(
)
+
sizeof
(
Frame
)
)
;
}
break
;
default
:
MOZ_CRASH
(
"
Argument
type
"
)
;
}
if
(
mirType_
=
=
MIRType
:
:
StackResults
)
{
stackResultPointerOffset_
=
frameOffset
(
)
;
argsIter_
+
+
;
frameSize_
=
nextFrameSize_
;
MOZ_ASSERT
(
argsIter_
.
done
(
)
)
;
}
else
{
return
;
}
}
if
(
index_
<
locals_
.
length
(
)
)
{
switch
(
locals_
[
index_
]
.
kind
(
)
)
{
case
ValType
:
:
I32
:
case
ValType
:
:
I64
:
case
ValType
:
:
F32
:
case
ValType
:
:
F64
:
#
ifdef
ENABLE_WASM_SIMD
case
ValType
:
:
V128
:
#
endif
case
ValType
:
:
Ref
:
ASSERT_ANYREF_IS_JSOBJECT
;
mirType_
=
ToMIRType
(
locals_
[
index_
]
)
;
frameOffset_
=
pushLocal
(
MIRTypeToSize
(
mirType_
)
)
;
break
;
default
:
MOZ_CRASH
(
"
Compiler
bug
:
Unexpected
local
type
"
)
;
}
return
;
}
done_
=
true
;
}
void
BaseLocalIter
:
:
operator
+
+
(
int
)
{
MOZ_ASSERT
(
!
done_
)
;
index_
+
+
;
if
(
!
argsIter_
.
done
(
)
)
{
argsIter_
+
+
;
}
settle
(
)
;
}
bool
BaseCompiler
:
:
createStackMap
(
const
char
*
who
)
{
const
ExitStubMapVector
noExtras
;
return
stackMapGenerator_
.
createStackMap
(
who
noExtras
masm
.
currentOffset
(
)
HasDebugFrameWithLiveRefs
:
:
No
stk_
)
;
}
bool
BaseCompiler
:
:
createStackMap
(
const
char
*
who
CodeOffset
assemblerOffset
)
{
const
ExitStubMapVector
noExtras
;
return
stackMapGenerator_
.
createStackMap
(
who
noExtras
assemblerOffset
.
offset
(
)
HasDebugFrameWithLiveRefs
:
:
No
stk_
)
;
}
bool
BaseCompiler
:
:
createStackMap
(
const
char
*
who
HasDebugFrameWithLiveRefs
debugFrameWithLiveRefs
)
{
const
ExitStubMapVector
noExtras
;
return
stackMapGenerator_
.
createStackMap
(
who
noExtras
masm
.
currentOffset
(
)
debugFrameWithLiveRefs
stk_
)
;
}
bool
BaseCompiler
:
:
createStackMap
(
const
char
*
who
const
ExitStubMapVector
&
extras
uint32_t
assemblerOffset
HasDebugFrameWithLiveRefs
debugFrameWithLiveRefs
)
{
return
stackMapGenerator_
.
createStackMap
(
who
extras
assemblerOffset
debugFrameWithLiveRefs
stk_
)
;
}
void
BaseStackFrame
:
:
zeroLocals
(
BaseRegAlloc
*
ra
)
{
MOZ_ASSERT
(
varLow_
!
=
UINT32_MAX
)
;
if
(
varLow_
=
=
varHigh_
)
{
return
;
}
static
const
uint32_t
wordSize
=
sizeof
(
void
*
)
;
uint32_t
low
=
varLow_
;
if
(
low
%
wordSize
)
{
masm
.
store32
(
Imm32
(
0
)
Address
(
sp_
localOffset
(
low
+
4
)
)
)
;
low
+
=
4
;
}
MOZ_ASSERT
(
low
%
wordSize
=
=
0
)
;
const
uint32_t
high
=
AlignBytes
(
varHigh_
wordSize
)
;
const
uint32_t
UNROLL_LIMIT
=
16
;
const
uint32_t
initWords
=
(
high
-
low
)
/
wordSize
;
const
uint32_t
tailWords
=
initWords
%
UNROLL_LIMIT
;
const
uint32_t
loopHigh
=
high
-
(
tailWords
*
wordSize
)
;
if
(
initWords
=
=
1
)
{
masm
.
storePtr
(
ImmWord
(
0
)
Address
(
sp_
localOffset
(
low
+
wordSize
)
)
)
;
return
;
}
RegI32
zero
=
ra
-
>
needI32
(
)
;
masm
.
mov
(
ImmWord
(
0
)
zero
)
;
if
(
initWords
<
2
*
UNROLL_LIMIT
)
{
for
(
uint32_t
i
=
low
;
i
<
high
;
i
+
=
wordSize
)
{
masm
.
storePtr
(
zero
Address
(
sp_
localOffset
(
i
+
wordSize
)
)
)
;
}
ra
-
>
freeI32
(
zero
)
;
return
;
}
RegI32
p
=
ra
-
>
needI32
(
)
;
masm
.
computeEffectiveAddress
(
Address
(
sp_
localOffset
(
low
+
wordSize
)
)
p
)
;
RegI32
lim
=
ra
-
>
needI32
(
)
;
masm
.
computeEffectiveAddress
(
Address
(
sp_
localOffset
(
loopHigh
+
wordSize
)
)
lim
)
;
Label
again
;
masm
.
bind
(
&
again
)
;
for
(
uint32_t
i
=
0
;
i
<
UNROLL_LIMIT
;
+
+
i
)
{
masm
.
storePtr
(
zero
Address
(
p
-
(
wordSize
*
i
)
)
)
;
}
masm
.
subPtr
(
Imm32
(
UNROLL_LIMIT
*
wordSize
)
p
)
;
masm
.
branchPtr
(
Assembler
:
:
LessThan
lim
p
&
again
)
;
for
(
uint32_t
i
=
0
;
i
<
tailWords
;
+
+
i
)
{
masm
.
storePtr
(
zero
Address
(
p
-
(
wordSize
*
i
)
)
)
;
}
ra
-
>
freeI32
(
p
)
;
ra
-
>
freeI32
(
lim
)
;
ra
-
>
freeI32
(
zero
)
;
}
}
}
