#
ifndef
wasm_WasmMetadata_h
#
define
wasm_WasmMetadata_h
#
include
"
wasm
/
WasmBinaryTypes
.
h
"
#
include
"
wasm
/
WasmInstanceData
.
h
"
#
include
"
wasm
/
WasmModuleTypes
.
h
"
#
include
"
wasm
/
WasmProcess
.
h
"
namespace
js
{
namespace
wasm
{
class
FuncExport
{
uint32_t
funcIndex_
;
uint32_t
eagerInterpEntryOffset_
;
bool
hasEagerStubs_
;
WASM_CHECK_CACHEABLE_POD
(
funcIndex_
eagerInterpEntryOffset_
hasEagerStubs_
)
;
public
:
FuncExport
(
)
=
default
;
explicit
FuncExport
(
uint32_t
funcIndex
bool
hasEagerStubs
)
{
funcIndex_
=
funcIndex
;
eagerInterpEntryOffset_
=
UINT32_MAX
;
hasEagerStubs_
=
hasEagerStubs
;
}
void
initEagerInterpEntryOffset
(
uint32_t
entryOffset
)
{
MOZ_ASSERT
(
eagerInterpEntryOffset_
=
=
UINT32_MAX
)
;
MOZ_ASSERT
(
hasEagerStubs
(
)
)
;
eagerInterpEntryOffset_
=
entryOffset
;
}
bool
hasEagerStubs
(
)
const
{
return
hasEagerStubs_
;
}
uint32_t
funcIndex
(
)
const
{
return
funcIndex_
;
}
uint32_t
eagerInterpEntryOffset
(
)
const
{
MOZ_ASSERT
(
eagerInterpEntryOffset_
!
=
UINT32_MAX
)
;
MOZ_ASSERT
(
hasEagerStubs
(
)
)
;
return
eagerInterpEntryOffset_
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
FuncExport
)
;
using
FuncExportVector
=
Vector
<
FuncExport
0
SystemAllocPolicy
>
;
class
FuncImport
{
private
:
uint32_t
instanceOffset_
;
uint32_t
interpExitCodeOffset_
;
uint32_t
jitExitCodeOffset_
;
WASM_CHECK_CACHEABLE_POD
(
instanceOffset_
interpExitCodeOffset_
jitExitCodeOffset_
)
;
public
:
FuncImport
(
)
:
instanceOffset_
(
0
)
interpExitCodeOffset_
(
0
)
jitExitCodeOffset_
(
0
)
{
}
explicit
FuncImport
(
uint32_t
instanceOffset
)
{
instanceOffset_
=
instanceOffset
;
interpExitCodeOffset_
=
0
;
jitExitCodeOffset_
=
0
;
}
void
initInterpExitOffset
(
uint32_t
off
)
{
MOZ_ASSERT
(
!
interpExitCodeOffset_
)
;
interpExitCodeOffset_
=
off
;
}
void
initJitExitOffset
(
uint32_t
off
)
{
MOZ_ASSERT
(
!
jitExitCodeOffset_
)
;
jitExitCodeOffset_
=
off
;
}
uint32_t
instanceOffset
(
)
const
{
return
instanceOffset_
;
}
uint32_t
interpExitCodeOffset
(
)
const
{
return
interpExitCodeOffset_
;
}
uint32_t
jitExitCodeOffset
(
)
const
{
return
jitExitCodeOffset_
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
FuncImport
)
using
FuncImportVector
=
Vector
<
FuncImport
0
SystemAllocPolicy
>
;
enum
class
NameContext
{
Standalone
BeforeLocation
}
;
using
ModuleHash
=
uint8_t
[
8
]
;
struct
CodeMetadata
:
public
ShareableBase
<
CodeMetadata
>
{
ModuleKind
kind
;
SharedCompileArgs
compileArgs
;
Maybe
<
uint32_t
>
dataCount
;
MemoryDescVector
memories
;
MutableTypeContext
types
;
BranchHintCollection
branchHints
;
uint32_t
numFuncImports
;
uint32_t
numGlobalImports
;
GlobalDescVector
globals
;
TagDescVector
tags
;
TableDescVector
tables
;
uint32_t
funcDefsOffsetStart
;
uint32_t
funcImportsOffsetStart
;
uint32_t
typeDefsOffsetStart
;
uint32_t
memoriesOffsetStart
;
uint32_t
tablesOffsetStart
;
uint32_t
tagsOffsetStart
;
uint32_t
instanceDataLength
;
mutable
SharedBytes
namePayload
;
Maybe
<
Name
>
moduleName
;
NameVector
funcNames
;
Maybe
<
uint32_t
>
startFuncIndex
;
Maybe
<
uint32_t
>
nameCustomSectionIndex
;
FuncDescVector
funcs
;
RefTypeVector
elemSegmentTypes
;
Uint32Vector
asmJSSigToTableIndex
;
MaybeSectionRange
codeSection
;
CustomSectionRangeVector
customSectionRanges
;
FuncDefRangeVector
funcDefRanges
;
bool
parsedBranchHints
;
bool
debugEnabled
;
ModuleHash
debugHash
;
explicit
CodeMetadata
(
const
CompileArgs
*
compileArgs
=
nullptr
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind
(
kind
)
compileArgs
(
compileArgs
)
numFuncImports
(
0
)
numGlobalImports
(
0
)
funcDefsOffsetStart
(
UINT32_MAX
)
funcImportsOffsetStart
(
UINT32_MAX
)
typeDefsOffsetStart
(
UINT32_MAX
)
memoriesOffsetStart
(
UINT32_MAX
)
tablesOffsetStart
(
UINT32_MAX
)
tagsOffsetStart
(
UINT32_MAX
)
instanceDataLength
(
UINT32_MAX
)
parsedBranchHints
(
false
)
debugEnabled
(
false
)
debugHash
(
)
{
}
[
[
nodiscard
]
]
bool
init
(
)
{
MOZ_ASSERT
(
!
types
)
;
types
=
js_new
<
TypeContext
>
(
)
;
return
types
;
}
[
[
nodiscard
]
]
bool
prepareForCompile
(
CompileMode
mode
)
;
bool
isPreparedForCompile
(
)
const
{
return
instanceDataLength
!
=
UINT32_MAX
;
}
const
FeatureArgs
&
features
(
)
const
{
return
compileArgs
-
>
features
;
}
const
ScriptedCaller
&
scriptedCaller
(
)
const
{
return
compileArgs
-
>
scriptedCaller
;
}
const
UniqueChars
&
sourceMapURL
(
)
const
{
return
compileArgs
-
>
sourceMapURL
;
}
const
TypeDef
&
getFuncTypeDef
(
uint32_t
funcIndex
)
const
{
return
types
-
>
type
(
funcs
[
funcIndex
]
.
typeIndex
)
;
}
const
FuncType
&
getFuncType
(
uint32_t
funcIndex
)
const
{
return
getFuncTypeDef
(
funcIndex
)
.
funcType
(
)
;
}
uint32_t
funcBytecodeOffset
(
uint32_t
funcIndex
)
const
{
if
(
funcIndex
<
numFuncImports
)
{
return
0
;
}
uint32_t
funcDefIndex
=
funcIndex
-
numFuncImports
;
return
funcDefRanges
[
funcDefIndex
]
.
bytecodeOffset
;
}
const
FuncDefRange
&
funcDefRange
(
uint32_t
funcIndex
)
const
{
MOZ_ASSERT
(
funcIndex
>
=
numFuncImports
)
;
uint32_t
funcDefIndex
=
funcIndex
-
numFuncImports
;
return
funcDefRanges
[
funcDefIndex
]
;
}
size_t
numTables
(
)
const
{
return
tables
.
length
(
)
;
}
size_t
numTypes
(
)
const
{
return
types
-
>
length
(
)
;
}
size_t
numFuncs
(
)
const
{
return
funcs
.
length
(
)
;
}
size_t
numFuncDefs
(
)
const
{
return
funcs
.
length
(
)
-
numFuncImports
;
}
bool
funcIsImport
(
uint32_t
funcIndex
)
const
{
return
funcIndex
<
numFuncImports
;
}
size_t
numMemories
(
)
const
{
return
memories
.
length
(
)
;
}
#
define
WASM_FEATURE
(
NAME
SHORT_NAME
.
.
.
)
\
bool
SHORT_NAME
#
#
Enabled
(
)
const
{
return
features
(
)
.
SHORT_NAME
;
}
JS_FOR_WASM_FEATURES
(
WASM_FEATURE
)
#
undef
WASM_FEATURE
Shareable
sharedMemoryEnabled
(
)
const
{
return
features
(
)
.
sharedMemory
;
}
bool
simdAvailable
(
)
const
{
return
features
(
)
.
simd
;
}
bool
isAsmJS
(
)
const
{
return
kind
=
=
ModuleKind
:
:
AsmJS
;
}
bool
isBuiltinModule
(
)
const
{
return
features
(
)
.
isBuiltinModule
;
}
bool
hugeMemoryEnabled
(
uint32_t
memoryIndex
)
const
{
return
!
isAsmJS
(
)
&
&
memoryIndex
<
memories
.
length
(
)
&
&
IsHugeMemoryEnabled
(
memories
[
memoryIndex
]
.
indexType
(
)
)
;
}
bool
usesSharedMemory
(
uint32_t
memoryIndex
)
const
{
return
memoryIndex
<
memories
.
length
(
)
&
&
memories
[
memoryIndex
]
.
isShared
(
)
;
}
void
declareFuncExported
(
uint32_t
funcIndex
bool
eager
bool
canRefFunc
)
{
FuncFlags
flags
=
funcs
[
funcIndex
]
.
flags
;
flags
=
FuncFlags
(
uint8_t
(
flags
)
|
uint8_t
(
FuncFlags
:
:
Exported
)
)
;
if
(
eager
)
{
flags
=
FuncFlags
(
uint8_t
(
flags
)
|
uint8_t
(
FuncFlags
:
:
Eager
)
)
;
}
if
(
canRefFunc
)
{
flags
=
FuncFlags
(
uint8_t
(
flags
)
|
uint8_t
(
FuncFlags
:
:
CanRefFunc
)
)
;
}
funcs
[
funcIndex
]
.
flags
=
flags
;
}
[
[
nodiscard
]
]
bool
allocateInstanceDataBytes
(
uint32_t
bytes
uint32_t
align
uint32_t
*
assignedOffset
)
;
[
[
nodiscard
]
]
bool
allocateInstanceDataBytesN
(
uint32_t
bytes
uint32_t
align
uint32_t
count
uint32_t
*
assignedOffset
)
;
uint32_t
offsetOfFuncDefInstanceData
(
uint32_t
funcIndex
)
const
{
MOZ_ASSERT
(
funcIndex
>
=
numFuncImports
&
&
funcIndex
<
numFuncs
(
)
)
;
return
funcDefsOffsetStart
+
(
funcIndex
-
numFuncImports
)
*
sizeof
(
FuncDefInstanceData
)
;
}
uint32_t
offsetOfFuncImportInstanceData
(
uint32_t
funcIndex
)
const
{
MOZ_ASSERT
(
funcIndex
<
numFuncImports
)
;
return
funcImportsOffsetStart
+
funcIndex
*
sizeof
(
FuncImportInstanceData
)
;
}
uint32_t
offsetOfTypeDefInstanceData
(
uint32_t
typeIndex
)
const
{
MOZ_ASSERT
(
typeIndex
<
types
-
>
length
(
)
)
;
return
typeDefsOffsetStart
+
typeIndex
*
sizeof
(
TypeDefInstanceData
)
;
}
uint32_t
offsetOfTypeDef
(
uint32_t
typeIndex
)
const
{
return
offsetOfTypeDefInstanceData
(
typeIndex
)
+
offsetof
(
TypeDefInstanceData
typeDef
)
;
}
uint32_t
offsetOfSuperTypeVector
(
uint32_t
typeIndex
)
const
{
return
offsetOfTypeDefInstanceData
(
typeIndex
)
+
offsetof
(
TypeDefInstanceData
superTypeVector
)
;
}
uint32_t
offsetOfMemoryInstanceData
(
uint32_t
memoryIndex
)
const
{
MOZ_ASSERT
(
memoryIndex
<
memories
.
length
(
)
)
;
return
memoriesOffsetStart
+
memoryIndex
*
sizeof
(
MemoryInstanceData
)
;
}
uint32_t
offsetOfTableInstanceData
(
uint32_t
tableIndex
)
const
{
MOZ_ASSERT
(
tableIndex
<
tables
.
length
(
)
)
;
return
tablesOffsetStart
+
tableIndex
*
sizeof
(
TableInstanceData
)
;
}
uint32_t
offsetOfTagInstanceData
(
uint32_t
tagIndex
)
const
{
MOZ_ASSERT
(
tagIndex
<
tags
.
length
(
)
)
;
return
tagsOffsetStart
+
tagIndex
*
sizeof
(
TagInstanceData
)
;
}
bool
addDefinedFunc
(
ModuleMetadata
*
meta
ValTypeVector
&
&
params
ValTypeVector
&
&
results
bool
declareForRef
=
false
Maybe
<
CacheableName
>
&
&
optionalExportedName
=
mozilla
:
:
Nothing
(
)
)
;
bool
addImportedFunc
(
ModuleMetadata
*
meta
ValTypeVector
&
&
params
ValTypeVector
&
&
results
CacheableName
&
&
importModName
CacheableName
&
&
importFieldName
)
;
bool
getFuncNameForWasm
(
NameContext
ctx
uint32_t
funcIndex
UTF8Bytes
*
name
)
const
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
MutableCodeMetadata
=
RefPtr
<
CodeMetadata
>
;
using
SharedCodeMetadata
=
RefPtr
<
const
CodeMetadata
>
;
struct
ModuleMetadata
:
public
ShareableBase
<
ModuleMetadata
>
{
MutableCodeMetadata
codeMeta
;
ImportVector
imports
;
ExportVector
exports
;
ModuleElemSegmentVector
elemSegments
;
DataSegmentRangeVector
dataSegmentRanges
;
DataSegmentVector
dataSegments
;
CustomSectionVector
customSections
;
FeatureUsage
featureUsage
;
explicit
ModuleMetadata
(
)
=
default
;
[
[
nodiscard
]
]
bool
init
(
const
CompileArgs
&
compileArgs
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
{
codeMeta
=
js_new
<
CodeMetadata
>
(
&
compileArgs
kind
)
;
return
!
!
codeMeta
&
&
codeMeta
-
>
init
(
)
;
}
[
[
nodiscard
]
]
bool
prepareForCompile
(
CompileMode
mode
)
{
return
codeMeta
-
>
prepareForCompile
(
mode
)
;
}
bool
isPreparedForCompile
(
)
const
{
return
codeMeta
-
>
isPreparedForCompile
(
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
MutableModuleMetadata
=
RefPtr
<
ModuleMetadata
>
;
using
SharedModuleMetadata
=
RefPtr
<
const
ModuleMetadata
>
;
}
}
#
endif
