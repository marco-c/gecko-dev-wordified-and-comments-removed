#
ifndef
wasm_WasmMetadata_h
#
define
wasm_WasmMetadata_h
#
include
"
wasm
/
WasmBinaryTypes
.
h
"
#
include
"
wasm
/
WasmInstanceData
.
h
"
#
include
"
wasm
/
WasmModuleTypes
.
h
"
#
include
"
wasm
/
WasmProcess
.
h
"
namespace
js
{
namespace
wasm
{
class
FuncExport
{
uint32_t
typeIndex_
;
uint32_t
funcIndex_
;
uint32_t
eagerInterpEntryOffset_
;
bool
hasEagerStubs_
;
WASM_CHECK_CACHEABLE_POD
(
typeIndex_
funcIndex_
eagerInterpEntryOffset_
hasEagerStubs_
)
;
public
:
FuncExport
(
)
=
default
;
explicit
FuncExport
(
uint32_t
typeIndex
uint32_t
funcIndex
bool
hasEagerStubs
)
{
typeIndex_
=
typeIndex
;
funcIndex_
=
funcIndex
;
eagerInterpEntryOffset_
=
UINT32_MAX
;
hasEagerStubs_
=
hasEagerStubs
;
}
void
initEagerInterpEntryOffset
(
uint32_t
entryOffset
)
{
MOZ_ASSERT
(
eagerInterpEntryOffset_
=
=
UINT32_MAX
)
;
MOZ_ASSERT
(
hasEagerStubs
(
)
)
;
eagerInterpEntryOffset_
=
entryOffset
;
}
bool
hasEagerStubs
(
)
const
{
return
hasEagerStubs_
;
}
uint32_t
typeIndex
(
)
const
{
return
typeIndex_
;
}
uint32_t
funcIndex
(
)
const
{
return
funcIndex_
;
}
uint32_t
eagerInterpEntryOffset
(
)
const
{
MOZ_ASSERT
(
eagerInterpEntryOffset_
!
=
UINT32_MAX
)
;
MOZ_ASSERT
(
hasEagerStubs
(
)
)
;
return
eagerInterpEntryOffset_
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
FuncExport
)
;
using
FuncExportVector
=
Vector
<
FuncExport
0
SystemAllocPolicy
>
;
class
FuncImport
{
private
:
uint32_t
typeIndex_
;
uint32_t
instanceOffset_
;
uint32_t
interpExitCodeOffset_
;
uint32_t
jitExitCodeOffset_
;
WASM_CHECK_CACHEABLE_POD
(
typeIndex_
instanceOffset_
interpExitCodeOffset_
jitExitCodeOffset_
)
;
public
:
FuncImport
(
)
:
typeIndex_
(
0
)
instanceOffset_
(
0
)
interpExitCodeOffset_
(
0
)
jitExitCodeOffset_
(
0
)
{
}
FuncImport
(
uint32_t
typeIndex
uint32_t
instanceOffset
)
{
typeIndex_
=
typeIndex
;
instanceOffset_
=
instanceOffset
;
interpExitCodeOffset_
=
0
;
jitExitCodeOffset_
=
0
;
}
void
initInterpExitOffset
(
uint32_t
off
)
{
MOZ_ASSERT
(
!
interpExitCodeOffset_
)
;
interpExitCodeOffset_
=
off
;
}
void
initJitExitOffset
(
uint32_t
off
)
{
MOZ_ASSERT
(
!
jitExitCodeOffset_
)
;
jitExitCodeOffset_
=
off
;
}
uint32_t
typeIndex
(
)
const
{
return
typeIndex_
;
}
uint32_t
instanceOffset
(
)
const
{
return
instanceOffset_
;
}
uint32_t
interpExitCodeOffset
(
)
const
{
return
interpExitCodeOffset_
;
}
uint32_t
jitExitCodeOffset
(
)
const
{
return
jitExitCodeOffset_
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
FuncImport
)
using
FuncImportVector
=
Vector
<
FuncImport
0
SystemAllocPolicy
>
;
enum
class
NameContext
{
Standalone
BeforeLocation
}
;
struct
ModuleMetadata
:
public
ShareableBase
<
ModuleMetadata
>
{
ImportVector
imports
;
ExportVector
exports
;
ModuleElemSegmentVector
elemSegments
;
DataSegmentRangeVector
dataSegmentRanges
;
DataSegmentVector
dataSegments
;
CustomSectionVector
customSections
;
explicit
ModuleMetadata
(
)
=
default
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
MutableModuleMetadata
=
RefPtr
<
ModuleMetadata
>
;
using
SharedModuleMetadata
=
RefPtr
<
const
ModuleMetadata
>
;
using
ModuleHash
=
uint8_t
[
8
]
;
struct
CodeMetadata
:
public
ShareableBase
<
CodeMetadata
>
{
ModuleKind
kind
;
FeatureArgs
features
;
Maybe
<
uint32_t
>
dataCount
;
MemoryDescVector
memories
;
MutableTypeContext
types
;
BranchHintCollection
branchHints
;
uint32_t
numFuncImports
;
uint32_t
numGlobalImports
;
GlobalDescVector
globals
;
TagDescVector
tags
;
TableDescVector
tables
;
uint32_t
funcDefsOffsetStart
;
uint32_t
funcImportsOffsetStart
;
uint32_t
typeDefsOffsetStart
;
uint32_t
memoriesOffsetStart
;
uint32_t
tablesOffsetStart
;
uint32_t
tagsOffsetStart
;
uint32_t
instanceDataLength
;
FeatureUsage
featureUsage
;
bool
filenameIsURL
;
CacheableChars
filename
;
CacheableChars
sourceMapURL
;
mutable
SharedBytes
namePayload
;
Maybe
<
Name
>
moduleName
;
NameVector
funcNames
;
Maybe
<
uint32_t
>
startFuncIndex
;
Maybe
<
uint32_t
>
nameCustomSectionIndex
;
FuncDescVector
funcs
;
RefTypeVector
elemSegmentTypes
;
Uint32Vector
asmJSSigToTableIndex
;
MaybeSectionRange
codeSection
;
CustomSectionRangeVector
customSectionRanges
;
bool
parsedBranchHints
;
bool
debugEnabled
;
Uint32Vector
debugFuncTypeIndices
;
ModuleHash
debugHash
;
explicit
CodeMetadata
(
)
:
kind
(
ModuleKind
:
:
Wasm
)
features
(
)
numFuncImports
(
0
)
numGlobalImports
(
0
)
funcDefsOffsetStart
(
UINT32_MAX
)
funcImportsOffsetStart
(
UINT32_MAX
)
typeDefsOffsetStart
(
UINT32_MAX
)
memoriesOffsetStart
(
UINT32_MAX
)
tablesOffsetStart
(
UINT32_MAX
)
tagsOffsetStart
(
UINT32_MAX
)
instanceDataLength
(
0
)
featureUsage
(
FeatureUsage
:
:
None
)
filenameIsURL
(
false
)
parsedBranchHints
(
false
)
debugEnabled
(
false
)
debugHash
(
)
{
}
explicit
CodeMetadata
(
FeatureArgs
features_
ModuleKind
kind_
=
ModuleKind
:
:
Wasm
)
:
CodeMetadata
(
)
{
features
=
features_
;
kind
=
kind_
;
}
[
[
nodiscard
]
]
bool
init
(
)
{
types
=
js_new
<
TypeContext
>
(
features
)
;
return
types
;
}
const
TypeDef
&
getFuncImportTypeDef
(
const
FuncImport
&
funcImport
)
const
{
return
types
-
>
type
(
funcImport
.
typeIndex
(
)
)
;
}
const
FuncType
&
getFuncImportType
(
const
FuncImport
&
funcImport
)
const
{
return
types
-
>
type
(
funcImport
.
typeIndex
(
)
)
.
funcType
(
)
;
}
const
TypeDef
&
getFuncExportTypeDef
(
const
FuncExport
&
funcExport
)
const
{
return
types
-
>
type
(
funcExport
.
typeIndex
(
)
)
;
}
const
FuncType
&
getFuncExportType
(
const
FuncExport
&
funcExport
)
const
{
return
types
-
>
type
(
funcExport
.
typeIndex
(
)
)
.
funcType
(
)
;
}
size_t
debugNumFuncs
(
)
const
{
return
debugFuncTypeIndices
.
length
(
)
;
}
const
FuncType
&
debugFuncType
(
uint32_t
funcIndex
)
const
{
MOZ_ASSERT
(
debugEnabled
)
;
return
types
-
>
type
(
debugFuncTypeIndices
[
funcIndex
]
)
.
funcType
(
)
;
}
size_t
numTables
(
)
const
{
return
tables
.
length
(
)
;
}
size_t
numTypes
(
)
const
{
return
types
-
>
length
(
)
;
}
size_t
numFuncs
(
)
const
{
return
funcs
.
length
(
)
;
}
size_t
numFuncDefs
(
)
const
{
return
funcs
.
length
(
)
-
numFuncImports
;
}
bool
funcIsImport
(
uint32_t
funcIndex
)
const
{
return
funcIndex
<
numFuncImports
;
}
size_t
numMemories
(
)
const
{
return
memories
.
length
(
)
;
}
#
define
WASM_FEATURE
(
NAME
SHORT_NAME
.
.
.
)
\
bool
SHORT_NAME
#
#
Enabled
(
)
const
{
return
features
.
SHORT_NAME
;
}
JS_FOR_WASM_FEATURES
(
WASM_FEATURE
)
#
undef
WASM_FEATURE
Shareable
sharedMemoryEnabled
(
)
const
{
return
features
.
sharedMemory
;
}
bool
simdAvailable
(
)
const
{
return
features
.
simd
;
}
bool
isAsmJS
(
)
const
{
return
kind
=
=
ModuleKind
:
:
AsmJS
;
}
bool
isBuiltinModule
(
)
const
{
return
features
.
isBuiltinModule
;
}
bool
hugeMemoryEnabled
(
uint32_t
memoryIndex
)
const
{
return
!
isAsmJS
(
)
&
&
memoryIndex
<
memories
.
length
(
)
&
&
IsHugeMemoryEnabled
(
memories
[
memoryIndex
]
.
indexType
(
)
)
;
}
bool
usesSharedMemory
(
uint32_t
memoryIndex
)
const
{
return
memoryIndex
<
memories
.
length
(
)
&
&
memories
[
memoryIndex
]
.
isShared
(
)
;
}
void
declareFuncExported
(
uint32_t
funcIndex
bool
eager
bool
canRefFunc
)
{
FuncFlags
flags
=
funcs
[
funcIndex
]
.
flags
;
flags
=
FuncFlags
(
uint8_t
(
flags
)
|
uint8_t
(
FuncFlags
:
:
Exported
)
)
;
if
(
eager
)
{
flags
=
FuncFlags
(
uint8_t
(
flags
)
|
uint8_t
(
FuncFlags
:
:
Eager
)
)
;
}
if
(
canRefFunc
)
{
flags
=
FuncFlags
(
uint8_t
(
flags
)
|
uint8_t
(
FuncFlags
:
:
CanRefFunc
)
)
;
}
funcs
[
funcIndex
]
.
flags
=
flags
;
}
[
[
nodiscard
]
]
bool
allocateInstanceDataBytes
(
uint32_t
bytes
uint32_t
align
uint32_t
*
assignedOffset
)
;
[
[
nodiscard
]
]
bool
allocateInstanceDataBytesN
(
uint32_t
bytes
uint32_t
align
uint32_t
count
uint32_t
*
assignedOffset
)
;
[
[
nodiscard
]
]
bool
initInstanceLayout
(
CompileMode
mode
)
;
uint32_t
offsetOfFuncDefInstanceData
(
uint32_t
funcIndex
)
const
{
MOZ_ASSERT
(
funcIndex
>
=
numFuncImports
&
&
funcIndex
<
numFuncs
(
)
)
;
return
funcDefsOffsetStart
+
(
funcIndex
-
numFuncImports
)
*
sizeof
(
FuncDefInstanceData
)
;
}
uint32_t
offsetOfFuncImportInstanceData
(
uint32_t
funcIndex
)
const
{
MOZ_ASSERT
(
funcIndex
<
numFuncImports
)
;
return
funcImportsOffsetStart
+
funcIndex
*
sizeof
(
FuncImportInstanceData
)
;
}
uint32_t
offsetOfTypeDefInstanceData
(
uint32_t
typeIndex
)
const
{
MOZ_ASSERT
(
typeIndex
<
types
-
>
length
(
)
)
;
return
typeDefsOffsetStart
+
typeIndex
*
sizeof
(
TypeDefInstanceData
)
;
}
uint32_t
offsetOfTypeDef
(
uint32_t
typeIndex
)
const
{
return
offsetOfTypeDefInstanceData
(
typeIndex
)
+
offsetof
(
TypeDefInstanceData
typeDef
)
;
}
uint32_t
offsetOfSuperTypeVector
(
uint32_t
typeIndex
)
const
{
return
offsetOfTypeDefInstanceData
(
typeIndex
)
+
offsetof
(
TypeDefInstanceData
superTypeVector
)
;
}
uint32_t
offsetOfMemoryInstanceData
(
uint32_t
memoryIndex
)
const
{
MOZ_ASSERT
(
memoryIndex
<
memories
.
length
(
)
)
;
return
memoriesOffsetStart
+
memoryIndex
*
sizeof
(
MemoryInstanceData
)
;
}
uint32_t
offsetOfTableInstanceData
(
uint32_t
tableIndex
)
const
{
MOZ_ASSERT
(
tableIndex
<
tables
.
length
(
)
)
;
return
tablesOffsetStart
+
tableIndex
*
sizeof
(
TableInstanceData
)
;
}
uint32_t
offsetOfTagInstanceData
(
uint32_t
tagIndex
)
const
{
MOZ_ASSERT
(
tagIndex
<
tags
.
length
(
)
)
;
return
tagsOffsetStart
+
tagIndex
*
sizeof
(
TagInstanceData
)
;
}
bool
addDefinedFunc
(
ModuleMetadata
*
meta
ValTypeVector
&
&
params
ValTypeVector
&
&
results
bool
declareForRef
=
false
Maybe
<
CacheableName
>
&
&
optionalExportedName
=
mozilla
:
:
Nothing
(
)
)
;
bool
addImportedFunc
(
ModuleMetadata
*
meta
ValTypeVector
&
&
params
ValTypeVector
&
&
results
CacheableName
&
&
importModName
CacheableName
&
&
importFieldName
)
;
bool
getFuncNameForWasm
(
NameContext
ctx
uint32_t
funcIndex
UTF8Bytes
*
name
)
const
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
MutableCodeMetadata
=
RefPtr
<
CodeMetadata
>
;
using
SharedCodeMetadata
=
RefPtr
<
const
CodeMetadata
>
;
}
}
#
endif
