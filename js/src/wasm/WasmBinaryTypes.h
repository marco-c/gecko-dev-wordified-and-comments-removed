#
ifndef
wasm_WasmBinaryTypes_h
#
define
wasm_WasmBinaryTypes_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
namespace
js
{
namespace
wasm
{
using
BytecodeSpan
=
mozilla
:
:
Span
<
const
uint8_t
>
;
struct
BytecodeRange
{
BytecodeRange
(
)
=
default
;
BytecodeRange
(
uint32_t
start
uint32_t
size
)
:
start
(
start
)
size
(
size
)
{
}
uint32_t
start
=
0
;
uint32_t
size
=
0
;
WASM_CHECK_CACHEABLE_POD
(
start
size
)
;
uint32_t
end
(
)
const
{
return
start
+
size
;
}
bool
contains
(
const
BytecodeRange
&
other
)
const
{
return
other
.
start
>
=
start
&
&
other
.
end
(
)
<
=
end
(
)
;
}
bool
containsOffset
(
uint32_t
bytecodeOffset
)
const
{
return
bytecodeOffset
>
=
start
&
&
bytecodeOffset
<
end
(
)
;
}
int
compareOffset
(
uint32_t
bytecodeOffset
)
const
{
if
(
containsOffset
(
bytecodeOffset
)
)
{
return
0
;
}
if
(
bytecodeOffset
<
start
)
{
return
-
1
;
}
MOZ_ASSERT
(
bytecodeOffset
>
=
end
(
)
)
;
return
1
;
}
bool
operator
=
=
(
const
BytecodeRange
&
rhs
)
const
{
return
start
=
=
rhs
.
start
&
&
size
=
=
rhs
.
size
;
}
BytecodeRange
relativeTo
(
const
BytecodeRange
&
other
)
const
{
MOZ_RELEASE_ASSERT
(
other
.
contains
(
*
this
)
)
;
return
BytecodeRange
(
start
-
other
.
start
size
)
;
}
template
<
typename
T
>
BytecodeSpan
toSpan
(
const
T
&
bytecode
)
const
{
MOZ_RELEASE_ASSERT
(
end
(
)
<
=
bytecode
.
length
(
)
)
;
return
BytecodeSpan
(
bytecode
.
begin
(
)
+
start
bytecode
.
begin
(
)
+
end
(
)
)
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
BytecodeRange
)
;
using
MaybeBytecodeRange
=
mozilla
:
:
Maybe
<
BytecodeRange
>
;
using
BytecodeRangeVector
=
mozilla
:
:
Vector
<
BytecodeRange
0
SystemAllocPolicy
>
;
}
}
#
endif
