#
ifndef
wasm_valtype_h
#
define
wasm_valtype_h
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
type_traits
>
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
#
include
"
wasm
/
WasmTypeDecls
.
h
"
namespace
js
{
namespace
wasm
{
using
mozilla
:
:
Maybe
;
class
RecGroup
;
class
TypeDef
;
class
TypeContext
;
enum
class
TypeDefKind
:
uint8_t
;
union
PackedTypeCode
{
public
:
using
PackedRepr
=
uint64_t
;
private
:
static
constexpr
size_t
NullableBits
=
1
;
static
constexpr
size_t
TypeCodeBits
=
8
;
static
constexpr
size_t
TypeDefBits
=
48
;
static
constexpr
size_t
PointerTagBits
=
2
;
static_assert
(
NullableBits
+
TypeCodeBits
+
TypeDefBits
+
PointerTagBits
<
=
(
sizeof
(
PackedRepr
)
*
8
)
"
enough
bits
"
)
;
PackedRepr
bits_
;
struct
{
PackedRepr
nullable_
:
NullableBits
;
PackedRepr
typeCode_
:
TypeCodeBits
;
PackedRepr
typeDef_
:
TypeDefBits
;
PackedRepr
pointerTag_
:
PointerTagBits
;
}
;
public
:
static
constexpr
PackedRepr
NoTypeCode
=
(
(
uint64_t
)
1
<
<
TypeCodeBits
)
-
1
;
static
PackedTypeCode
invalid
(
)
{
PackedTypeCode
ptc
=
{
}
;
ptc
.
typeCode_
=
NoTypeCode
;
return
ptc
;
}
static
constexpr
PackedTypeCode
fromBits
(
PackedRepr
bits
)
{
PackedTypeCode
ptc
=
{
}
;
ptc
.
bits_
=
bits
;
return
ptc
;
}
static
PackedTypeCode
pack
(
TypeCode
tc
const
TypeDef
*
typeDef
bool
isNullable
)
{
MOZ_ASSERT
(
uint32_t
(
tc
)
<
=
(
(
1
<
<
TypeCodeBits
)
-
1
)
)
;
MOZ_ASSERT_IF
(
tc
!
=
AbstractTypeRefCode
typeDef
=
=
nullptr
)
;
MOZ_ASSERT_IF
(
tc
=
=
AbstractTypeRefCode
typeDef
!
=
nullptr
)
;
MOZ_ASSERT
(
(
uint64_t
)
typeDef
<
=
(
(
uint64_t
)
1
<
<
TypeDefBits
)
-
1
)
;
PackedTypeCode
ptc
=
{
}
;
ptc
.
typeCode_
=
PackedRepr
(
tc
)
;
ptc
.
typeDef_
=
(
uintptr_t
)
typeDef
;
ptc
.
nullable_
=
isNullable
;
return
ptc
;
}
static
PackedTypeCode
pack
(
TypeCode
tc
bool
nullable
)
{
return
pack
(
tc
nullptr
nullable
)
;
}
static
PackedTypeCode
pack
(
TypeCode
tc
)
{
return
pack
(
tc
nullptr
false
)
;
}
bool
isValid
(
)
const
{
return
typeCode_
!
=
NoTypeCode
;
}
PackedRepr
bits
(
)
const
{
return
bits_
;
}
TypeCode
typeCode
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
TypeCode
(
typeCode_
)
;
}
TypeCode
typeCodeAbstracted
(
)
const
{
TypeCode
tc
=
typeCode
(
)
;
return
tc
<
LowestPrimitiveTypeCode
?
AbstractReferenceTypeCode
:
tc
;
}
bool
isRefType
(
)
const
{
return
typeCodeAbstracted
(
)
=
=
AbstractReferenceTypeCode
;
}
bool
isRefRepr
(
)
const
{
return
typeCode
(
)
<
LowestPrimitiveTypeCode
;
}
const
TypeDef
*
typeDef
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
(
const
TypeDef
*
)
(
uintptr_t
)
typeDef_
;
}
bool
isNullable
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
bool
(
nullable_
)
;
}
PackedTypeCode
withIsNullable
(
bool
nullable
)
const
{
MOZ_ASSERT
(
isRefType
(
)
)
;
PackedTypeCode
mutated
=
*
this
;
mutated
.
nullable_
=
(
PackedRepr
)
nullable
;
return
mutated
;
}
bool
operator
=
=
(
const
PackedTypeCode
&
rhs
)
const
{
return
bits_
=
=
rhs
.
bits_
;
}
bool
operator
!
=
(
const
PackedTypeCode
&
rhs
)
const
{
return
bits_
!
=
rhs
.
bits_
;
}
}
;
static_assert
(
sizeof
(
PackedTypeCode
)
=
=
sizeof
(
uint64_t
)
"
packed
"
)
;
union
SerializableTypeCode
{
using
PackedRepr
=
uintptr_t
;
static
constexpr
size_t
NullableBits
=
1
;
static
constexpr
size_t
TypeCodeBits
=
8
;
static
constexpr
size_t
TypeIndexBits
=
20
;
PackedRepr
bits
;
struct
{
PackedRepr
nullable
:
NullableBits
;
PackedRepr
typeCode
:
TypeCodeBits
;
PackedRepr
typeIndex
:
TypeIndexBits
;
}
;
WASM_CHECK_CACHEABLE_POD
(
bits
)
;
static
constexpr
PackedRepr
NoTypeIndex
=
(
1
<
<
TypeIndexBits
)
-
1
;
static_assert
(
NullableBits
+
TypeCodeBits
+
TypeIndexBits
<
=
(
sizeof
(
PackedRepr
)
*
8
)
"
enough
bits
"
)
;
static_assert
(
NoTypeIndex
<
(
1
<
<
TypeIndexBits
)
"
enough
bits
"
)
;
static_assert
(
MaxTypes
<
NoTypeIndex
"
enough
bits
"
)
;
static
inline
SerializableTypeCode
serialize
(
PackedTypeCode
ptc
const
TypeContext
&
types
)
;
inline
PackedTypeCode
deserialize
(
const
TypeContext
&
types
)
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
SerializableTypeCode
)
;
static_assert
(
sizeof
(
SerializableTypeCode
)
=
=
sizeof
(
uintptr_t
)
"
packed
"
)
;
union
MatchTypeCode
{
using
PackedRepr
=
uint64_t
;
static
constexpr
size_t
NullableBits
=
1
;
static
constexpr
size_t
TypeCodeBits
=
8
;
static
constexpr
size_t
TypeRefBits
=
48
;
PackedRepr
bits
;
struct
{
PackedRepr
nullable
:
NullableBits
;
PackedRepr
typeCode
:
TypeCodeBits
;
PackedRepr
typeRef
:
TypeRefBits
;
}
;
WASM_CHECK_CACHEABLE_POD
(
bits
)
;
static_assert
(
NullableBits
+
TypeCodeBits
+
TypeRefBits
<
=
(
sizeof
(
PackedRepr
)
*
8
)
"
enough
bits
"
)
;
static
inline
MatchTypeCode
forMatch
(
PackedTypeCode
ptc
const
RecGroup
*
recGroup
)
;
bool
operator
=
=
(
MatchTypeCode
other
)
const
{
return
bits
=
=
other
.
bits
;
}
bool
operator
!
=
(
MatchTypeCode
other
)
const
{
return
bits
!
=
other
.
bits
;
}
HashNumber
hash
(
)
const
{
return
HashNumber
(
bits
)
;
}
}
;
enum
class
TableRepr
{
Ref
Func
}
;
enum
class
RefTypeHierarchy
{
Func
Extern
Any
}
;
class
RefType
{
public
:
enum
Kind
{
Func
=
uint8_t
(
TypeCode
:
:
FuncRef
)
Extern
=
uint8_t
(
TypeCode
:
:
ExternRef
)
Any
=
uint8_t
(
TypeCode
:
:
AnyRef
)
NoFunc
=
uint8_t
(
TypeCode
:
:
NullFuncRef
)
NoExtern
=
uint8_t
(
TypeCode
:
:
NullExternRef
)
None
=
uint8_t
(
TypeCode
:
:
NullAnyRef
)
Eq
=
uint8_t
(
TypeCode
:
:
EqRef
)
Struct
=
uint8_t
(
TypeCode
:
:
StructRef
)
Array
=
uint8_t
(
TypeCode
:
:
ArrayRef
)
TypeRef
=
uint8_t
(
AbstractTypeRefCode
)
}
;
private
:
PackedTypeCode
ptc_
;
RefType
(
Kind
kind
bool
nullable
)
:
ptc_
(
PackedTypeCode
:
:
pack
(
TypeCode
(
kind
)
nullable
)
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
}
RefType
(
const
TypeDef
*
typeDef
bool
nullable
)
:
ptc_
(
PackedTypeCode
:
:
pack
(
AbstractTypeRefCode
typeDef
nullable
)
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
}
public
:
RefType
(
)
:
ptc_
(
PackedTypeCode
:
:
invalid
(
)
)
{
}
explicit
RefType
(
PackedTypeCode
ptc
)
:
ptc_
(
ptc
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
}
static
RefType
fromTypeCode
(
TypeCode
tc
bool
nullable
)
{
MOZ_ASSERT
(
tc
!
=
AbstractTypeRefCode
)
;
return
RefType
(
Kind
(
tc
)
nullable
)
;
}
static
RefType
fromTypeDef
(
const
TypeDef
*
typeDef
bool
nullable
)
{
return
RefType
(
typeDef
nullable
)
;
}
Kind
kind
(
)
const
{
return
Kind
(
ptc_
.
typeCode
(
)
)
;
}
const
TypeDef
*
typeDef
(
)
const
{
return
ptc_
.
typeDef
(
)
;
}
PackedTypeCode
packed
(
)
const
{
return
ptc_
;
}
PackedTypeCode
*
addressOfPacked
(
)
{
return
&
ptc_
;
}
const
PackedTypeCode
*
addressOfPacked
(
)
const
{
return
&
ptc_
;
}
#
ifdef
DEBUG
bool
isValid
(
)
const
{
MOZ_ASSERT
(
(
ptc_
.
typeCode
(
)
=
=
AbstractTypeRefCode
)
=
=
(
ptc_
.
typeDef
(
)
!
=
nullptr
)
)
;
switch
(
ptc_
.
typeCode
(
)
)
{
case
TypeCode
:
:
FuncRef
:
case
TypeCode
:
:
ExternRef
:
case
TypeCode
:
:
AnyRef
:
case
TypeCode
:
:
EqRef
:
case
TypeCode
:
:
StructRef
:
case
TypeCode
:
:
ArrayRef
:
case
TypeCode
:
:
NullFuncRef
:
case
TypeCode
:
:
NullExternRef
:
case
TypeCode
:
:
NullAnyRef
:
case
AbstractTypeRefCode
:
return
true
;
default
:
return
false
;
}
}
#
endif
static
RefType
func
(
)
{
return
RefType
(
Func
true
)
;
}
static
RefType
extern_
(
)
{
return
RefType
(
Extern
true
)
;
}
static
RefType
any
(
)
{
return
RefType
(
Any
true
)
;
}
static
RefType
nofunc
(
)
{
return
RefType
(
NoFunc
true
)
;
}
static
RefType
noextern
(
)
{
return
RefType
(
NoExtern
true
)
;
}
static
RefType
none
(
)
{
return
RefType
(
None
true
)
;
}
static
RefType
eq
(
)
{
return
RefType
(
Eq
true
)
;
}
static
RefType
struct_
(
)
{
return
RefType
(
Struct
true
)
;
}
static
RefType
array
(
)
{
return
RefType
(
Array
true
)
;
}
bool
isFunc
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
Func
;
}
bool
isExtern
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
Extern
;
}
bool
isAny
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
Any
;
}
bool
isNoFunc
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
NoFunc
;
}
bool
isNoExtern
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
NoExtern
;
}
bool
isNone
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
None
;
}
bool
isEq
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
Eq
;
}
bool
isStruct
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
Struct
;
}
bool
isArray
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
Array
;
}
bool
isTypeRef
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
TypeRef
;
}
bool
isNullable
(
)
const
{
return
bool
(
ptc_
.
isNullable
(
)
)
;
}
RefType
asNonNullable
(
)
const
{
return
withIsNullable
(
false
)
;
}
RefType
withIsNullable
(
bool
nullable
)
const
{
return
RefType
(
ptc_
.
withIsNullable
(
nullable
)
)
;
}
inline
RefTypeHierarchy
hierarchy
(
)
const
;
inline
TableRepr
tableRepr
(
)
const
;
inline
bool
isFuncHierarchy
(
)
const
;
inline
bool
isExternHierarchy
(
)
const
;
inline
bool
isAnyHierarchy
(
)
const
;
static
bool
isSubTypeOf
(
RefType
subType
RefType
superType
)
;
RefType
topType
(
)
const
;
TypeDefKind
typeDefKind
(
)
const
;
bool
operator
=
=
(
const
RefType
&
that
)
const
{
return
ptc_
=
=
that
.
ptc_
;
}
bool
operator
!
=
(
const
RefType
&
that
)
const
{
return
ptc_
!
=
that
.
ptc_
;
}
}
;
class
FieldTypeTraits
{
public
:
enum
Kind
{
I8
=
uint8_t
(
TypeCode
:
:
I8
)
I16
=
uint8_t
(
TypeCode
:
:
I16
)
I32
=
uint8_t
(
TypeCode
:
:
I32
)
I64
=
uint8_t
(
TypeCode
:
:
I64
)
F32
=
uint8_t
(
TypeCode
:
:
F32
)
F64
=
uint8_t
(
TypeCode
:
:
F64
)
V128
=
uint8_t
(
TypeCode
:
:
V128
)
Ref
=
uint8_t
(
AbstractReferenceTypeCode
)
}
;
static
bool
isValidTypeCode
(
TypeCode
tc
)
{
switch
(
tc
)
{
#
ifdef
ENABLE_WASM_GC
case
TypeCode
:
:
I8
:
case
TypeCode
:
:
I16
:
#
endif
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
#
ifdef
ENABLE_WASM_SIMD
case
TypeCode
:
:
V128
:
#
endif
case
TypeCode
:
:
FuncRef
:
case
TypeCode
:
:
ExternRef
:
#
ifdef
ENABLE_WASM_GC
case
TypeCode
:
:
AnyRef
:
case
TypeCode
:
:
EqRef
:
case
TypeCode
:
:
StructRef
:
case
TypeCode
:
:
ArrayRef
:
case
TypeCode
:
:
NullFuncRef
:
case
TypeCode
:
:
NullExternRef
:
case
TypeCode
:
:
NullAnyRef
:
#
endif
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
case
AbstractTypeRefCode
:
#
endif
return
true
;
default
:
return
false
;
}
}
static
bool
isNumberTypeCode
(
TypeCode
tc
)
{
switch
(
tc
)
{
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
return
true
;
default
:
return
false
;
}
}
static
bool
isPackedTypeCode
(
TypeCode
tc
)
{
switch
(
tc
)
{
#
ifdef
ENABLE_WASM_GC
case
TypeCode
:
:
I8
:
case
TypeCode
:
:
I16
:
return
true
;
#
endif
default
:
return
false
;
}
}
static
bool
isVectorTypeCode
(
TypeCode
tc
)
{
switch
(
tc
)
{
#
ifdef
ENABLE_WASM_SIMD
case
TypeCode
:
:
V128
:
return
true
;
#
endif
default
:
return
false
;
}
}
}
;
class
ValTypeTraits
{
public
:
enum
Kind
{
I32
=
uint8_t
(
TypeCode
:
:
I32
)
I64
=
uint8_t
(
TypeCode
:
:
I64
)
F32
=
uint8_t
(
TypeCode
:
:
F32
)
F64
=
uint8_t
(
TypeCode
:
:
F64
)
V128
=
uint8_t
(
TypeCode
:
:
V128
)
Ref
=
uint8_t
(
AbstractReferenceTypeCode
)
}
;
static
bool
isValidTypeCode
(
TypeCode
tc
)
{
switch
(
tc
)
{
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
#
ifdef
ENABLE_WASM_SIMD
case
TypeCode
:
:
V128
:
#
endif
case
TypeCode
:
:
FuncRef
:
case
TypeCode
:
:
ExternRef
:
#
ifdef
ENABLE_WASM_GC
case
TypeCode
:
:
AnyRef
:
case
TypeCode
:
:
EqRef
:
case
TypeCode
:
:
StructRef
:
case
TypeCode
:
:
ArrayRef
:
case
TypeCode
:
:
NullFuncRef
:
case
TypeCode
:
:
NullExternRef
:
case
TypeCode
:
:
NullAnyRef
:
#
endif
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
case
AbstractTypeRefCode
:
#
endif
return
true
;
default
:
return
false
;
}
}
static
bool
isNumberTypeCode
(
TypeCode
tc
)
{
switch
(
tc
)
{
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
return
true
;
default
:
return
false
;
}
}
static
bool
isPackedTypeCode
(
TypeCode
tc
)
{
return
false
;
}
static
bool
isVectorTypeCode
(
TypeCode
tc
)
{
switch
(
tc
)
{
#
ifdef
ENABLE_WASM_SIMD
case
TypeCode
:
:
V128
:
return
true
;
#
endif
default
:
return
false
;
}
}
}
;
template
<
class
T
>
class
PackedType
:
public
T
{
public
:
using
Kind
=
typename
T
:
:
Kind
;
protected
:
PackedTypeCode
tc_
;
explicit
PackedType
(
TypeCode
c
)
:
tc_
(
PackedTypeCode
:
:
pack
(
c
)
)
{
MOZ_ASSERT
(
c
!
=
AbstractTypeRefCode
)
;
MOZ_ASSERT
(
isValid
(
)
)
;
}
TypeCode
typeCode
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
tc_
.
typeCode
(
)
;
}
public
:
PackedType
(
)
:
tc_
(
PackedTypeCode
:
:
invalid
(
)
)
{
}
MOZ_IMPLICIT
PackedType
(
Kind
c
)
:
tc_
(
PackedTypeCode
:
:
pack
(
TypeCode
(
c
)
)
)
{
MOZ_ASSERT
(
c
!
=
Kind
:
:
Ref
)
;
MOZ_ASSERT
(
isValid
(
)
)
;
}
MOZ_IMPLICIT
PackedType
(
RefType
rt
)
:
tc_
(
rt
.
packed
(
)
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
}
explicit
PackedType
(
PackedTypeCode
ptc
)
:
tc_
(
ptc
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
}
static
PackedType
fromMIRType
(
jit
:
:
MIRType
mty
)
{
switch
(
mty
)
{
case
jit
:
:
MIRType
:
:
Int32
:
return
PackedType
:
:
I32
;
break
;
case
jit
:
:
MIRType
:
:
Int64
:
return
PackedType
:
:
I64
;
break
;
case
jit
:
:
MIRType
:
:
Float32
:
return
PackedType
:
:
F32
;
break
;
case
jit
:
:
MIRType
:
:
Double
:
return
PackedType
:
:
F64
;
break
;
case
jit
:
:
MIRType
:
:
Simd128
:
return
PackedType
:
:
V128
;
break
;
case
jit
:
:
MIRType
:
:
RefOrNull
:
return
PackedType
:
:
Ref
;
default
:
MOZ_CRASH
(
"
fromMIRType
:
unexpected
type
"
)
;
}
}
static
PackedType
fromNonRefTypeCode
(
TypeCode
tc
)
{
#
ifdef
DEBUG
switch
(
tc
)
{
case
TypeCode
:
:
I8
:
case
TypeCode
:
:
I16
:
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
case
TypeCode
:
:
V128
:
break
;
default
:
MOZ_CRASH
(
"
Bad
type
code
"
)
;
}
#
endif
return
PackedType
(
tc
)
;
}
static
PackedType
fromBitsUnsafe
(
PackedTypeCode
:
:
PackedRepr
bits
)
{
return
PackedType
(
PackedTypeCode
:
:
fromBits
(
bits
)
)
;
}
bool
isValid
(
)
const
{
if
(
!
tc_
.
isValid
(
)
)
{
return
false
;
}
return
T
:
:
isValidTypeCode
(
tc_
.
typeCode
(
)
)
;
}
MatchTypeCode
forMatch
(
const
RecGroup
*
recGroup
)
const
{
return
MatchTypeCode
:
:
forMatch
(
tc_
recGroup
)
;
}
PackedTypeCode
packed
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
tc_
;
}
PackedTypeCode
*
addressOfPacked
(
)
{
return
&
tc_
;
}
const
PackedTypeCode
*
addressOfPacked
(
)
const
{
return
&
tc_
;
}
PackedTypeCode
:
:
PackedRepr
bitsUnsafe
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
tc_
.
bits
(
)
;
}
bool
isNumber
(
)
const
{
return
T
:
:
isNumberTypeCode
(
tc_
.
typeCode
(
)
)
;
}
bool
isPacked
(
)
const
{
return
T
:
:
isPackedTypeCode
(
tc_
.
typeCode
(
)
)
;
}
bool
isVector
(
)
const
{
return
T
:
:
isVectorTypeCode
(
tc_
.
typeCode
(
)
)
;
}
bool
isRefType
(
)
const
{
return
tc_
.
isRefType
(
)
;
}
bool
isFuncRef
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
TypeCode
:
:
FuncRef
;
}
bool
isExternRef
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
TypeCode
:
:
ExternRef
;
}
bool
isAnyRef
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
TypeCode
:
:
AnyRef
;
}
bool
isNoFunc
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
TypeCode
:
:
NullFuncRef
;
}
bool
isNoExtern
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
TypeCode
:
:
NullExternRef
;
}
bool
isNone
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
TypeCode
:
:
NullAnyRef
;
}
bool
isEqRef
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
TypeCode
:
:
EqRef
;
}
bool
isStructRef
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
TypeCode
:
:
StructRef
;
}
bool
isArrayRef
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
TypeCode
:
:
ArrayRef
;
}
bool
isTypeRef
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
AbstractTypeRefCode
;
}
bool
isRefRepr
(
)
const
{
return
tc_
.
isRefRepr
(
)
;
}
bool
isDefaultable
(
)
const
{
return
!
(
isRefType
(
)
&
&
!
isNullable
(
)
)
;
}
bool
isExposable
(
)
const
{
#
if
defined
(
ENABLE_WASM_SIMD
)
return
kind
(
)
!
=
Kind
:
:
V128
;
#
else
return
true
;
#
endif
}
bool
isNullable
(
)
const
{
return
tc_
.
isNullable
(
)
;
}
const
TypeDef
*
typeDef
(
)
const
{
return
tc_
.
typeDef
(
)
;
}
Kind
kind
(
)
const
{
return
Kind
(
tc_
.
typeCodeAbstracted
(
)
)
;
}
RefType
refType
(
)
const
{
MOZ_ASSERT
(
isRefType
(
)
)
;
return
RefType
(
tc_
)
;
}
RefType
:
:
Kind
refTypeKind
(
)
const
{
MOZ_ASSERT
(
isRefType
(
)
)
;
return
RefType
(
tc_
)
.
kind
(
)
;
}
bool
isEncodedAsJSValueOnEscape
(
)
const
{
return
isRefType
(
)
;
}
uint32_t
size
(
)
const
{
switch
(
tc_
.
typeCodeAbstracted
(
)
)
{
case
TypeCode
:
:
I8
:
return
1
;
case
TypeCode
:
:
I16
:
return
2
;
case
TypeCode
:
:
I32
:
return
4
;
case
TypeCode
:
:
I64
:
return
8
;
case
TypeCode
:
:
F32
:
return
4
;
case
TypeCode
:
:
F64
:
return
8
;
case
TypeCode
:
:
V128
:
return
16
;
case
AbstractReferenceTypeCode
:
return
sizeof
(
void
*
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
)
;
return
0
;
}
}
uint32_t
alignmentInStruct
(
)
const
{
return
size
(
)
;
}
uint32_t
indexingShift
(
)
const
{
switch
(
size
(
)
)
{
case
1
:
return
0
;
case
2
:
return
1
;
case
4
:
return
2
;
case
8
:
return
3
;
case
16
:
return
4
;
default
:
MOZ_ASSERT_UNREACHABLE
(
)
;
return
0
;
}
}
PackedType
<
ValTypeTraits
>
widenToValType
(
)
const
{
switch
(
tc_
.
typeCodeAbstracted
(
)
)
{
case
TypeCode
:
:
I8
:
case
TypeCode
:
:
I16
:
return
PackedType
<
ValTypeTraits
>
:
:
I32
;
default
:
return
PackedType
<
ValTypeTraits
>
(
tc_
)
;
}
}
PackedType
<
ValTypeTraits
>
valType
(
)
const
{
MOZ_ASSERT
(
isValType
(
)
)
;
return
PackedType
<
ValTypeTraits
>
(
tc_
)
;
}
jit
:
:
MIRType
toMIRType
(
)
const
{
switch
(
tc_
.
typeCodeAbstracted
(
)
)
{
case
TypeCode
:
:
I32
:
return
jit
:
:
MIRType
:
:
Int32
;
case
TypeCode
:
:
I64
:
return
jit
:
:
MIRType
:
:
Int64
;
case
TypeCode
:
:
F32
:
return
jit
:
:
MIRType
:
:
Float32
;
case
TypeCode
:
:
F64
:
return
jit
:
:
MIRType
:
:
Double
;
case
TypeCode
:
:
V128
:
return
jit
:
:
MIRType
:
:
Simd128
;
case
AbstractReferenceTypeCode
:
return
jit
:
:
MIRType
:
:
RefOrNull
;
default
:
MOZ_CRASH
(
"
bad
type
"
)
;
}
}
bool
isValType
(
)
const
{
switch
(
tc_
.
typeCode
(
)
)
{
case
TypeCode
:
:
I8
:
case
TypeCode
:
:
I16
:
return
false
;
default
:
return
true
;
}
}
PackedType
<
FieldTypeTraits
>
fieldType
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
PackedType
<
FieldTypeTraits
>
(
tc_
)
;
}
static
bool
isSubTypeOf
(
PackedType
subType
PackedType
superType
)
{
if
(
subType
=
=
superType
)
{
return
true
;
}
if
(
subType
.
isRefType
(
)
&
&
superType
.
isRefType
(
)
)
{
return
RefType
:
:
isSubTypeOf
(
subType
.
refType
(
)
superType
.
refType
(
)
)
;
}
return
false
;
}
bool
operator
=
=
(
const
PackedType
&
that
)
const
{
MOZ_ASSERT
(
isValid
(
)
&
&
that
.
isValid
(
)
)
;
return
tc_
=
=
that
.
tc_
;
}
bool
operator
!
=
(
const
PackedType
&
that
)
const
{
MOZ_ASSERT
(
isValid
(
)
&
&
that
.
isValid
(
)
)
;
return
tc_
!
=
that
.
tc_
;
}
bool
operator
=
=
(
Kind
that
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
MOZ_ASSERT
(
that
!
=
Kind
:
:
Ref
)
;
return
Kind
(
typeCode
(
)
)
=
=
that
;
}
bool
operator
!
=
(
Kind
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
}
;
using
ValType
=
PackedType
<
ValTypeTraits
>
;
using
FieldType
=
PackedType
<
FieldTypeTraits
>
;
using
ValTypeVector
=
Vector
<
ValType
16
SystemAllocPolicy
>
;
extern
bool
ToValType
(
JSContext
*
cx
HandleValue
v
ValType
*
out
)
;
extern
bool
ToRefType
(
JSContext
*
cx
HandleValue
v
RefType
*
out
)
;
extern
UniqueChars
ToString
(
RefType
type
const
TypeContext
*
types
)
;
extern
UniqueChars
ToString
(
ValType
type
const
TypeContext
*
types
)
;
extern
UniqueChars
ToString
(
FieldType
type
const
TypeContext
*
types
)
;
extern
UniqueChars
ToString
(
const
Maybe
<
ValType
>
&
type
const
TypeContext
*
types
)
;
}
}
#
endif
