#
include
"
wasm
/
WasmCompile
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
algorithm
>
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
Equality
.
h
"
#
include
"
js
/
ForOfIterator
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
ifndef
__wasi__
#
include
"
jit
/
ProcessExecutableMemory
.
h
"
#
endif
#
include
"
jit
/
FlushICache
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
HelperThreads
.
h
"
#
include
"
vm
/
JSAtomState
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
wasm
/
WasmBaselineCompile
.
h
"
#
include
"
wasm
/
WasmFeatures
.
h
"
#
include
"
wasm
/
WasmGenerator
.
h
"
#
include
"
wasm
/
WasmIonCompile
.
h
"
#
include
"
wasm
/
WasmOpIter
.
h
"
#
include
"
wasm
/
WasmProcess
.
h
"
#
include
"
wasm
/
WasmSignalHandlers
.
h
"
#
include
"
wasm
/
WasmValidate
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
using
mozilla
:
:
Atomic
;
uint32_t
wasm
:
:
ObservedCPUFeatures
(
)
{
enum
Arch
{
X86
=
0x1
X64
=
0x2
ARM
=
0x3
MIPS
=
0x4
MIPS64
=
0x5
ARM64
=
0x6
LOONG64
=
0x7
RISCV64
=
0x8
ARCH_BITS
=
3
}
;
#
if
defined
(
JS_CODEGEN_X86
)
MOZ_ASSERT
(
uint32_t
(
jit
:
:
CPUInfo
:
:
GetFingerprint
(
)
)
<
=
(
UINT32_MAX
>
>
ARCH_BITS
)
)
;
return
X86
|
(
uint32_t
(
jit
:
:
CPUInfo
:
:
GetFingerprint
(
)
)
<
<
ARCH_BITS
)
;
#
elif
defined
(
JS_CODEGEN_X64
)
MOZ_ASSERT
(
uint32_t
(
jit
:
:
CPUInfo
:
:
GetFingerprint
(
)
)
<
=
(
UINT32_MAX
>
>
ARCH_BITS
)
)
;
return
X64
|
(
uint32_t
(
jit
:
:
CPUInfo
:
:
GetFingerprint
(
)
)
<
<
ARCH_BITS
)
;
#
elif
defined
(
JS_CODEGEN_ARM
)
MOZ_ASSERT
(
jit
:
:
GetARMFlags
(
)
<
=
(
UINT32_MAX
>
>
ARCH_BITS
)
)
;
return
ARM
|
(
jit
:
:
GetARMFlags
(
)
<
<
ARCH_BITS
)
;
#
elif
defined
(
JS_CODEGEN_ARM64
)
MOZ_ASSERT
(
jit
:
:
GetARM64Flags
(
)
<
=
(
UINT32_MAX
>
>
ARCH_BITS
)
)
;
return
ARM64
|
(
jit
:
:
GetARM64Flags
(
)
<
<
ARCH_BITS
)
;
#
elif
defined
(
JS_CODEGEN_MIPS64
)
MOZ_ASSERT
(
jit
:
:
GetMIPSFlags
(
)
<
=
(
UINT32_MAX
>
>
ARCH_BITS
)
)
;
return
MIPS64
|
(
jit
:
:
GetMIPSFlags
(
)
<
<
ARCH_BITS
)
;
#
elif
defined
(
JS_CODEGEN_LOONG64
)
MOZ_ASSERT
(
jit
:
:
GetLOONG64Flags
(
)
<
=
(
UINT32_MAX
>
>
ARCH_BITS
)
)
;
return
LOONG64
|
(
jit
:
:
GetLOONG64Flags
(
)
<
<
ARCH_BITS
)
;
#
elif
defined
(
JS_CODEGEN_RISCV64
)
MOZ_ASSERT
(
jit
:
:
GetRISCV64Flags
(
)
<
=
(
UINT32_MAX
>
>
ARCH_BITS
)
)
;
return
RISCV64
|
(
jit
:
:
GetRISCV64Flags
(
)
<
<
ARCH_BITS
)
;
#
elif
defined
(
JS_CODEGEN_NONE
)
|
|
defined
(
JS_CODEGEN_WASM32
)
return
0
;
#
else
#
error
"
unknown
architecture
"
#
endif
}
bool
FeatureOptions
:
:
init
(
JSContext
*
cx
HandleValue
val
)
{
if
(
val
.
isNullOrUndefined
(
)
)
{
return
true
;
}
bool
jsStringBuiltinsAvailable
=
false
;
#
ifdef
ENABLE_WASM_JS_STRING_BUILTINS
jsStringBuiltinsAvailable
=
JSStringBuiltinsAvailable
(
cx
)
;
#
endif
bool
isPrivilegedContext
=
IsPrivilegedContext
(
cx
)
;
if
(
!
jsStringBuiltinsAvailable
&
&
!
isPrivilegedContext
)
{
MOZ_ASSERT
(
!
this
-
>
disableOptimizingCompiler
)
;
MOZ_ASSERT
(
!
this
-
>
jsStringConstants
)
;
MOZ_ASSERT
(
!
this
-
>
jsStringBuiltins
)
;
return
true
;
}
if
(
!
val
.
isObject
(
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_BAD_COMPILE_OPTIONS
)
;
return
false
;
}
RootedObject
obj
(
cx
&
val
.
toObject
(
)
)
;
if
(
isPrivilegedContext
)
{
RootedValue
disableOptimizingCompiler
(
cx
)
;
if
(
!
JS_GetProperty
(
cx
obj
"
disableOptimizingCompiler
"
&
disableOptimizingCompiler
)
)
{
return
false
;
}
this
-
>
disableOptimizingCompiler
=
JS
:
:
ToBoolean
(
disableOptimizingCompiler
)
;
}
else
{
MOZ_ASSERT
(
!
this
-
>
disableOptimizingCompiler
)
;
}
#
ifdef
ENABLE_WASM_JS_STRING_BUILTINS
if
(
jsStringBuiltinsAvailable
)
{
RootedValue
importedStringConstants
(
cx
)
;
if
(
!
JS_GetProperty
(
cx
obj
"
importedStringConstants
"
&
importedStringConstants
)
)
{
return
false
;
}
if
(
importedStringConstants
.
isNullOrUndefined
(
)
)
{
this
-
>
jsStringConstants
=
false
;
}
else
{
this
-
>
jsStringConstants
=
true
;
RootedString
importedStringConstantsString
(
cx
JS
:
:
ToString
(
cx
importedStringConstants
)
)
;
if
(
!
importedStringConstantsString
)
{
return
false
;
}
UniqueChars
jsStringConstantsNamespace
=
StringToNewUTF8CharsZ
(
cx
*
importedStringConstantsString
)
;
if
(
!
jsStringConstantsNamespace
)
{
return
false
;
}
this
-
>
jsStringConstantsNamespace
=
js_new
<
ShareableChars
>
(
std
:
:
move
(
jsStringConstantsNamespace
)
)
;
if
(
!
this
-
>
jsStringConstantsNamespace
)
{
return
false
;
}
}
RootedValue
builtins
(
cx
)
;
if
(
!
JS_GetProperty
(
cx
obj
"
builtins
"
&
builtins
)
)
{
return
false
;
}
if
(
!
builtins
.
isUndefined
(
)
)
{
JS
:
:
ForOfIterator
iterator
(
cx
)
;
if
(
!
iterator
.
init
(
builtins
JS
:
:
ForOfIterator
:
:
ThrowOnNonIterable
)
)
{
return
false
;
}
RootedValue
jsStringModule
(
cx
StringValue
(
cx
-
>
names
(
)
.
jsStringModule
)
)
;
RootedValue
nextBuiltin
(
cx
)
;
while
(
true
)
{
bool
done
;
if
(
!
iterator
.
next
(
&
nextBuiltin
&
done
)
)
{
return
false
;
}
if
(
done
)
{
break
;
}
bool
jsStringBuiltins
;
if
(
!
JS
:
:
LooselyEqual
(
cx
nextBuiltin
jsStringModule
&
jsStringBuiltins
)
)
{
return
false
;
}
if
(
!
jsStringBuiltins
)
{
continue
;
}
if
(
this
-
>
jsStringBuiltins
&
&
jsStringBuiltins
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_DUPLICATE_BUILTIN
)
;
return
false
;
}
this
-
>
jsStringBuiltins
=
jsStringBuiltins
;
}
}
}
#
endif
return
true
;
}
FeatureArgs
FeatureArgs
:
:
build
(
JSContext
*
cx
const
FeatureOptions
&
options
)
{
FeatureArgs
features
;
#
define
WASM_FEATURE
(
NAME
LOWER_NAME
.
.
.
)
\
features
.
LOWER_NAME
=
wasm
:
:
NAME
#
#
Available
(
cx
)
;
JS_FOR_WASM_FEATURES
(
WASM_FEATURE
)
;
#
undef
WASM_FEATURE
features
.
sharedMemory
=
wasm
:
:
ThreadsAvailable
(
cx
)
?
Shareable
:
:
True
:
Shareable
:
:
False
;
features
.
simd
=
jit
:
:
JitSupportsWasmSimd
(
)
;
features
.
isBuiltinModule
=
options
.
isBuiltinModule
;
if
(
features
.
jsStringBuiltins
)
{
features
.
builtinModules
.
jsString
=
options
.
jsStringBuiltins
;
features
.
builtinModules
.
jsStringConstants
=
options
.
jsStringConstants
;
features
.
builtinModules
.
jsStringConstantsNamespace
=
options
.
jsStringConstantsNamespace
;
}
if
(
options
.
requireExnref
)
{
features
.
exnref
=
true
;
}
return
features
;
}
SharedCompileArgs
CompileArgs
:
:
build
(
JSContext
*
cx
ScriptedCaller
&
&
scriptedCaller
const
FeatureOptions
&
options
CompileArgsError
*
error
)
{
bool
baseline
=
BaselineAvailable
(
cx
)
;
bool
ion
=
IonAvailable
(
cx
)
;
if
(
baseline
&
&
options
.
disableOptimizingCompiler
)
{
ion
=
false
;
}
bool
debug
=
cx
-
>
realm
(
)
&
&
cx
-
>
realm
(
)
-
>
debuggerObservesWasm
(
)
;
bool
forceTiering
=
cx
-
>
options
(
)
.
testWasmAwaitTier2
(
)
|
|
JitOptions
.
wasmDelayTier2
;
if
(
debug
&
&
ion
)
{
*
error
=
CompileArgsError
:
:
NoCompiler
;
return
nullptr
;
}
if
(
forceTiering
&
&
!
(
baseline
&
&
ion
)
)
{
forceTiering
=
false
;
}
if
(
!
(
baseline
|
|
ion
)
)
{
*
error
=
CompileArgsError
:
:
NoCompiler
;
return
nullptr
;
}
CompileArgs
*
target
=
cx
-
>
new_
<
CompileArgs
>
(
)
;
if
(
!
target
)
{
*
error
=
CompileArgsError
:
:
OutOfMemory
;
return
nullptr
;
}
target
-
>
scriptedCaller
=
std
:
:
move
(
scriptedCaller
)
;
target
-
>
baselineEnabled
=
baseline
;
target
-
>
ionEnabled
=
ion
;
target
-
>
debugEnabled
=
debug
;
target
-
>
forceTiering
=
forceTiering
;
target
-
>
features
=
FeatureArgs
:
:
build
(
cx
options
)
;
return
target
;
}
void
wasm
:
:
SetUseCountersForFeatureUsage
(
JSContext
*
cx
JSObject
*
object
FeatureUsage
usage
)
{
if
(
usage
&
FeatureUsage
:
:
LegacyExceptions
)
{
cx
-
>
runtime
(
)
-
>
setUseCounter
(
object
JSUseCounter
:
:
WASM_LEGACY_EXCEPTIONS
)
;
}
}
SharedCompileArgs
CompileArgs
:
:
buildForAsmJS
(
ScriptedCaller
&
&
scriptedCaller
)
{
CompileArgs
*
target
=
js_new
<
CompileArgs
>
(
)
;
if
(
!
target
)
{
return
nullptr
;
}
target
-
>
scriptedCaller
=
std
:
:
move
(
scriptedCaller
)
;
target
-
>
ionEnabled
=
true
;
target
-
>
debugEnabled
=
false
;
return
target
;
}
SharedCompileArgs
CompileArgs
:
:
buildForValidation
(
const
FeatureArgs
&
args
)
{
CompileArgs
*
target
=
js_new
<
CompileArgs
>
(
)
;
if
(
!
target
)
{
return
nullptr
;
}
target
-
>
baselineEnabled
=
false
;
target
-
>
ionEnabled
=
false
;
target
-
>
debugEnabled
=
false
;
target
-
>
forceTiering
=
false
;
target
-
>
features
=
args
;
return
target
;
}
SharedCompileArgs
CompileArgs
:
:
buildAndReport
(
JSContext
*
cx
ScriptedCaller
&
&
scriptedCaller
const
FeatureOptions
&
options
bool
reportOOM
)
{
CompileArgsError
error
;
SharedCompileArgs
args
=
CompileArgs
:
:
build
(
cx
std
:
:
move
(
scriptedCaller
)
options
&
error
)
;
if
(
args
)
{
Log
(
cx
"
available
wasm
compilers
:
tier1
=
%
s
tier2
=
%
s
"
args
-
>
baselineEnabled
?
"
baseline
"
:
"
none
"
args
-
>
ionEnabled
?
"
ion
"
:
"
none
"
)
;
return
args
;
}
switch
(
error
)
{
case
CompileArgsError
:
:
NoCompiler
:
{
JS_ReportErrorASCII
(
cx
"
no
WebAssembly
compiler
available
"
)
;
break
;
}
case
CompileArgsError
:
:
OutOfMemory
:
{
if
(
reportOOM
)
{
ReportOutOfMemory
(
cx
)
;
}
break
;
}
}
return
nullptr
;
}
enum
class
SystemClass
{
DesktopX86
DesktopX64
DesktopUnknown32
DesktopUnknown64
MobileX86
MobileArm32
MobileArm64
MobileUnknown32
MobileUnknown64
}
;
static
SystemClass
ClassifySystem
(
)
{
bool
isDesktop
;
#
if
defined
(
ANDROID
)
|
|
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_ARM64
)
isDesktop
=
false
;
#
else
isDesktop
=
true
;
#
endif
if
(
isDesktop
)
{
#
if
defined
(
JS_CODEGEN_X64
)
return
SystemClass
:
:
DesktopX64
;
#
elif
defined
(
JS_CODEGEN_X86
)
return
SystemClass
:
:
DesktopX86
;
#
elif
defined
(
JS_64BIT
)
return
SystemClass
:
:
DesktopUnknown64
;
#
else
return
SystemClass
:
:
DesktopUnknown32
;
#
endif
}
else
{
#
if
defined
(
JS_CODEGEN_X86
)
return
SystemClass
:
:
MobileX86
;
#
elif
defined
(
JS_CODEGEN_ARM
)
return
SystemClass
:
:
MobileArm32
;
#
elif
defined
(
JS_CODEGEN_ARM64
)
return
SystemClass
:
:
MobileArm64
;
#
elif
defined
(
JS_64BIT
)
return
SystemClass
:
:
MobileUnknown64
;
#
else
return
SystemClass
:
:
MobileUnknown32
;
#
endif
}
}
static
const
double
x64Tox86Inflation
=
1
.
25
;
static
const
double
x64IonBytesPerBytecode
=
2
.
45
;
static
const
double
x86IonBytesPerBytecode
=
x64IonBytesPerBytecode
*
x64Tox86Inflation
;
static
const
double
arm32IonBytesPerBytecode
=
3
.
3
;
static
const
double
arm64IonBytesPerBytecode
=
3
.
0
/
1
.
4
;
static
const
double
x64BaselineBytesPerBytecode
=
x64IonBytesPerBytecode
*
1
.
43
;
static
const
double
x86BaselineBytesPerBytecode
=
x64BaselineBytesPerBytecode
*
x64Tox86Inflation
;
static
const
double
arm32BaselineBytesPerBytecode
=
arm32IonBytesPerBytecode
*
1
.
39
;
static
const
double
arm64BaselineBytesPerBytecode
=
3
.
0
;
static
double
OptimizedBytesPerBytecode
(
SystemClass
cls
)
{
switch
(
cls
)
{
case
SystemClass
:
:
DesktopX86
:
case
SystemClass
:
:
MobileX86
:
case
SystemClass
:
:
DesktopUnknown32
:
return
x86IonBytesPerBytecode
;
case
SystemClass
:
:
DesktopX64
:
case
SystemClass
:
:
DesktopUnknown64
:
return
x64IonBytesPerBytecode
;
case
SystemClass
:
:
MobileArm32
:
case
SystemClass
:
:
MobileUnknown32
:
return
arm32IonBytesPerBytecode
;
case
SystemClass
:
:
MobileArm64
:
case
SystemClass
:
:
MobileUnknown64
:
return
arm64IonBytesPerBytecode
;
default
:
MOZ_CRASH
(
)
;
}
}
static
double
BaselineBytesPerBytecode
(
SystemClass
cls
)
{
switch
(
cls
)
{
case
SystemClass
:
:
DesktopX86
:
case
SystemClass
:
:
MobileX86
:
case
SystemClass
:
:
DesktopUnknown32
:
return
x86BaselineBytesPerBytecode
;
case
SystemClass
:
:
DesktopX64
:
case
SystemClass
:
:
DesktopUnknown64
:
return
x64BaselineBytesPerBytecode
;
case
SystemClass
:
:
MobileArm32
:
case
SystemClass
:
:
MobileUnknown32
:
return
arm32BaselineBytesPerBytecode
;
case
SystemClass
:
:
MobileArm64
:
case
SystemClass
:
:
MobileUnknown64
:
return
arm64BaselineBytesPerBytecode
;
default
:
MOZ_CRASH
(
)
;
}
}
double
wasm
:
:
EstimateCompiledCodeSize
(
Tier
tier
size_t
bytecodeSize
)
{
SystemClass
cls
=
ClassifySystem
(
)
;
switch
(
tier
)
{
case
Tier
:
:
Baseline
:
return
double
(
bytecodeSize
)
*
BaselineBytesPerBytecode
(
cls
)
;
case
Tier
:
:
Optimized
:
return
double
(
bytecodeSize
)
*
OptimizedBytesPerBytecode
(
cls
)
;
}
MOZ_CRASH
(
"
bad
tier
"
)
;
}
static
const
double
tierCutoffMs
=
10
;
static
const
double
x64IonBytecodesPerMs
=
2100
;
static
const
double
x86IonBytecodesPerMs
=
1500
;
static
const
double
arm32IonBytecodesPerMs
=
450
;
static
const
double
arm64IonBytecodesPerMs
=
750
;
static
const
double
x64DesktopTierCutoff
=
x64IonBytecodesPerMs
*
tierCutoffMs
;
static
const
double
x86DesktopTierCutoff
=
x86IonBytecodesPerMs
*
tierCutoffMs
;
static
const
double
x86MobileTierCutoff
=
x86DesktopTierCutoff
/
2
;
static
const
double
arm32MobileTierCutoff
=
arm32IonBytecodesPerMs
*
tierCutoffMs
;
static
const
double
arm64MobileTierCutoff
=
arm64IonBytecodesPerMs
*
tierCutoffMs
;
static
double
CodesizeCutoff
(
SystemClass
cls
)
{
switch
(
cls
)
{
case
SystemClass
:
:
DesktopX86
:
case
SystemClass
:
:
DesktopUnknown32
:
return
x86DesktopTierCutoff
;
case
SystemClass
:
:
DesktopX64
:
case
SystemClass
:
:
DesktopUnknown64
:
return
x64DesktopTierCutoff
;
case
SystemClass
:
:
MobileX86
:
return
x86MobileTierCutoff
;
case
SystemClass
:
:
MobileArm32
:
case
SystemClass
:
:
MobileUnknown32
:
return
arm32MobileTierCutoff
;
case
SystemClass
:
:
MobileArm64
:
case
SystemClass
:
:
MobileUnknown64
:
return
arm64MobileTierCutoff
;
default
:
MOZ_CRASH
(
)
;
}
}
static
double
EffectiveCores
(
uint32_t
cores
)
{
if
(
cores
<
=
3
)
{
return
pow
(
cores
0
.
9
)
;
}
return
pow
(
cores
0
.
75
)
;
}
#
ifndef
JS_64BIT
static
const
double
spaceCutoffPct
=
0
.
9
;
#
endif
static
bool
TieringBeneficial
(
bool
lazyTiering
uint32_t
codeSize
)
{
if
(
lazyTiering
)
{
return
true
;
}
uint32_t
cpuCount
=
GetHelperThreadCPUCount
(
)
;
MOZ_ASSERT
(
cpuCount
>
0
)
;
if
(
cpuCount
=
=
1
)
{
return
false
;
}
uint32_t
workers
=
GetMaxWasmCompilationThreads
(
)
;
uint32_t
cores
=
workers
;
SystemClass
cls
=
ClassifySystem
(
)
;
double
cutoffSize
=
CodesizeCutoff
(
cls
)
;
double
effectiveCores
=
EffectiveCores
(
cores
)
;
if
(
(
codeSize
/
effectiveCores
)
<
cutoffSize
)
{
return
false
;
}
#
ifndef
JS_64BIT
double
ionRatio
=
OptimizedBytesPerBytecode
(
cls
)
;
double
baselineRatio
=
BaselineBytesPerBytecode
(
cls
)
;
double
needMemory
=
codeSize
*
(
ionRatio
+
baselineRatio
)
;
double
availMemory
=
LikelyAvailableExecutableMemory
(
)
;
double
cutoff
=
spaceCutoffPct
*
MaxCodeBytesPerProcess
;
if
(
(
MaxCodeBytesPerProcess
-
availMemory
)
+
needMemory
>
cutoff
)
{
return
false
;
}
#
endif
return
true
;
}
static
bool
PlatformCanTier
(
bool
lazyTiering
)
{
bool
synchronousTiering
=
lazyTiering
&
&
JS
:
:
Prefs
:
:
wasm_lazy_tiering_synchronous
(
)
;
return
(
synchronousTiering
|
|
CanUseExtraThreads
(
)
)
&
&
jit
:
:
CanFlushExecutionContextForAllThreads
(
)
;
}
CompilerEnvironment
:
:
CompilerEnvironment
(
const
CompileArgs
&
args
)
:
state_
(
InitialWithArgs
)
args_
(
&
args
)
{
}
CompilerEnvironment
:
:
CompilerEnvironment
(
CompileMode
mode
Tier
tier
DebugEnabled
debugEnabled
)
:
state_
(
InitialWithModeTierDebug
)
mode_
(
mode
)
tier_
(
tier
)
debug_
(
debugEnabled
)
{
}
void
CompilerEnvironment
:
:
computeParameters
(
)
{
MOZ_ASSERT
(
state_
=
=
InitialWithModeTierDebug
)
;
state_
=
Computed
;
}
void
CompilerEnvironment
:
:
computeParameters
(
const
ModuleMetadata
&
moduleMeta
)
{
MOZ_ASSERT
(
!
isComputed
(
)
)
;
if
(
state_
=
=
InitialWithModeTierDebug
)
{
computeParameters
(
)
;
return
;
}
bool
baselineEnabled
=
args_
-
>
baselineEnabled
;
bool
ionEnabled
=
args_
-
>
ionEnabled
;
bool
debugEnabled
=
args_
-
>
debugEnabled
;
bool
forceTiering
=
args_
-
>
forceTiering
;
bool
hasSecondTier
=
ionEnabled
;
MOZ_ASSERT_IF
(
debugEnabled
baselineEnabled
)
;
MOZ_ASSERT_IF
(
forceTiering
baselineEnabled
&
&
hasSecondTier
)
;
MOZ_RELEASE_ASSERT
(
baselineEnabled
|
|
ionEnabled
)
;
bool
isGcModule
=
moduleMeta
.
codeMeta
-
>
types
-
>
hasGcType
(
)
;
uint32_t
codeSectionSize
=
moduleMeta
.
codeMeta
-
>
codeSectionSize
(
)
;
bool
lazyTiering
=
JS
:
:
Prefs
:
:
wasm_lazy_tiering
(
)
|
|
(
JS
:
:
Prefs
:
:
wasm_lazy_tiering_for_gc
(
)
&
&
isGcModule
)
;
if
(
baselineEnabled
&
&
hasSecondTier
&
&
(
TieringBeneficial
(
lazyTiering
codeSectionSize
)
|
|
forceTiering
)
&
&
PlatformCanTier
(
lazyTiering
)
)
{
mode_
=
lazyTiering
?
CompileMode
:
:
LazyTiering
:
CompileMode
:
:
EagerTiering
;
tier_
=
Tier
:
:
Baseline
;
}
else
{
mode_
=
CompileMode
:
:
Once
;
tier_
=
hasSecondTier
?
Tier
:
:
Optimized
:
Tier
:
:
Baseline
;
}
debug_
=
debugEnabled
?
DebugEnabled
:
:
True
:
DebugEnabled
:
:
False
;
state_
=
Computed
;
}
template
<
class
DecoderT
class
ModuleGeneratorT
>
static
bool
DecodeFunctionBody
(
DecoderT
&
d
ModuleGeneratorT
&
mg
uint32_t
funcIndex
)
{
uint32_t
bodySize
;
if
(
!
d
.
readVarU32
(
&
bodySize
)
)
{
return
d
.
fail
(
"
expected
number
of
function
body
bytes
"
)
;
}
if
(
bodySize
>
MaxFunctionBytes
)
{
return
d
.
fail
(
"
function
body
too
big
"
)
;
}
const
size_t
offsetInModule
=
d
.
currentOffset
(
)
;
const
uint8_t
*
bodyBegin
;
if
(
!
d
.
readBytes
(
bodySize
&
bodyBegin
)
)
{
return
d
.
fail
(
"
function
body
length
too
big
"
)
;
}
return
mg
.
compileFuncDef
(
funcIndex
offsetInModule
bodyBegin
bodyBegin
+
bodySize
)
;
}
template
<
class
DecoderT
class
ModuleGeneratorT
>
static
bool
DecodeCodeSection
(
const
CodeMetadata
&
codeMeta
DecoderT
&
d
ModuleGeneratorT
&
mg
)
{
if
(
!
codeMeta
.
codeSectionRange
)
{
if
(
codeMeta
.
numFuncDefs
(
)
!
=
0
)
{
return
d
.
fail
(
"
expected
code
section
"
)
;
}
return
mg
.
finishFuncDefs
(
)
;
}
uint32_t
numFuncDefs
;
if
(
!
d
.
readVarU32
(
&
numFuncDefs
)
)
{
return
d
.
fail
(
"
expected
function
body
count
"
)
;
}
if
(
numFuncDefs
!
=
codeMeta
.
numFuncDefs
(
)
)
{
return
d
.
fail
(
"
function
body
count
does
not
match
function
signature
count
"
)
;
}
for
(
uint32_t
funcDefIndex
=
0
;
funcDefIndex
<
numFuncDefs
;
funcDefIndex
+
+
)
{
if
(
!
DecodeFunctionBody
(
d
mg
codeMeta
.
numFuncImports
+
funcDefIndex
)
)
{
return
false
;
}
}
if
(
!
d
.
finishSection
(
*
codeMeta
.
codeSectionRange
"
code
"
)
)
{
return
false
;
}
return
mg
.
finishFuncDefs
(
)
;
}
SharedModule
wasm
:
:
CompileBuffer
(
const
CompileArgs
&
args
const
ShareableBytes
&
bytecode
UniqueChars
*
error
UniqueCharsVector
*
warnings
JS
:
:
OptimizedEncodingListener
*
listener
)
{
Decoder
d
(
bytecode
.
bytes
0
error
warnings
)
;
MutableModuleMetadata
moduleMeta
=
js_new
<
ModuleMetadata
>
(
)
;
if
(
!
moduleMeta
|
|
!
moduleMeta
-
>
init
(
args
)
)
{
return
nullptr
;
}
if
(
!
DecodeModuleEnvironment
(
d
moduleMeta
-
>
codeMeta
.
get
(
)
moduleMeta
)
)
{
return
nullptr
;
}
CompilerEnvironment
compilerEnv
(
args
)
;
compilerEnv
.
computeParameters
(
*
moduleMeta
)
;
if
(
!
moduleMeta
-
>
prepareForCompile
(
compilerEnv
.
mode
(
)
)
)
{
return
nullptr
;
}
ModuleGenerator
mg
(
*
moduleMeta
-
>
codeMeta
compilerEnv
compilerEnv
.
initialState
(
)
nullptr
error
warnings
)
;
if
(
!
mg
.
initializeCompleteTier
(
)
)
{
return
nullptr
;
}
if
(
!
DecodeCodeSection
(
*
moduleMeta
-
>
codeMeta
d
mg
)
)
{
return
nullptr
;
}
if
(
!
DecodeModuleTail
(
d
moduleMeta
-
>
codeMeta
moduleMeta
)
)
{
return
nullptr
;
}
return
mg
.
finishModule
(
bytecode
moduleMeta
listener
)
;
}
bool
wasm
:
:
CompileCompleteTier2
(
const
Bytes
&
bytecode
const
Module
&
module
UniqueChars
*
error
UniqueCharsVector
*
warnings
Atomic
<
bool
>
*
cancelled
)
{
CompilerEnvironment
compilerEnv
(
CompileMode
:
:
EagerTiering
Tier
:
:
Optimized
DebugEnabled
:
:
False
)
;
compilerEnv
.
computeParameters
(
)
;
const
CodeMetadata
&
codeMeta
=
module
.
codeMeta
(
)
;
ModuleGenerator
mg
(
codeMeta
compilerEnv
CompileState
:
:
EagerTier2
cancelled
error
warnings
)
;
if
(
!
mg
.
initializeCompleteTier
(
)
)
{
return
false
;
}
if
(
codeMeta
.
codeSectionRange
)
{
const
SectionRange
&
codeSection
=
*
codeMeta
.
codeSectionRange
;
const
uint8_t
*
codeSectionStart
=
bytecode
.
begin
(
)
+
codeSection
.
start
;
const
uint8_t
*
codeSectionEnd
=
codeSectionStart
+
codeSection
.
size
;
Decoder
d
(
codeSectionStart
codeSectionEnd
codeSection
.
start
error
)
;
if
(
!
DecodeCodeSection
(
module
.
codeMeta
(
)
d
mg
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
codeMeta
.
numFuncDefs
(
)
=
=
0
)
;
if
(
!
mg
.
finishFuncDefs
(
)
)
{
return
false
;
}
}
return
mg
.
finishTier2
(
module
)
;
}
bool
wasm
:
:
CompilePartialTier2
(
const
Code
&
code
uint32_t
funcIndex
UniqueChars
*
error
UniqueCharsVector
*
warnings
mozilla
:
:
Atomic
<
bool
>
*
cancelled
)
{
CompilerEnvironment
compilerEnv
(
CompileMode
:
:
LazyTiering
Tier
:
:
Optimized
DebugEnabled
:
:
False
)
;
compilerEnv
.
computeParameters
(
)
;
const
CodeMetadata
&
codeMeta
=
code
.
codeMeta
(
)
;
ModuleGenerator
mg
(
codeMeta
compilerEnv
CompileState
:
:
LazyTier2
cancelled
error
warnings
)
;
if
(
!
mg
.
initializePartialTier
(
code
funcIndex
)
)
{
MOZ_ASSERT
(
!
*
error
)
;
return
false
;
}
const
FuncDefRange
&
funcRange
=
codeMeta
.
funcDefRange
(
funcIndex
)
;
uint32_t
codeSectionOffset
=
codeMeta
.
codeSectionRange
-
>
start
;
uint32_t
bodyOffsetInCodeSection
=
funcRange
.
bytecodeOffset
-
codeSectionOffset
;
const
uint8_t
*
bodyBegin
=
codeMeta
.
codeSectionBytecode
-
>
begin
(
)
+
bodyOffsetInCodeSection
;
const
uint8_t
*
bodyEnd
=
bodyBegin
+
funcRange
.
bodyLength
;
return
mg
.
compileFuncDef
(
funcIndex
funcRange
.
bytecodeOffset
bodyBegin
bodyEnd
)
&
&
mg
.
finishFuncDefs
(
)
&
&
mg
.
finishPartialTier2
(
)
;
}
class
StreamingDecoder
{
Decoder
d_
;
const
ExclusiveBytesPtr
&
codeBytesEnd_
;
const
Atomic
<
bool
>
&
cancelled_
;
public
:
StreamingDecoder
(
const
CodeMetadata
&
codeMeta
const
Bytes
&
begin
const
ExclusiveBytesPtr
&
codeBytesEnd
const
Atomic
<
bool
>
&
cancelled
UniqueChars
*
error
UniqueCharsVector
*
warnings
)
:
d_
(
begin
codeMeta
.
codeSectionRange
-
>
start
error
warnings
)
codeBytesEnd_
(
codeBytesEnd
)
cancelled_
(
cancelled
)
{
}
bool
fail
(
const
char
*
msg
)
{
return
d_
.
fail
(
msg
)
;
}
bool
done
(
)
const
{
return
d_
.
done
(
)
;
}
size_t
currentOffset
(
)
const
{
return
d_
.
currentOffset
(
)
;
}
bool
waitForBytes
(
size_t
numBytes
)
{
numBytes
=
std
:
:
min
(
numBytes
d_
.
bytesRemain
(
)
)
;
const
uint8_t
*
requiredEnd
=
d_
.
currentPosition
(
)
+
numBytes
;
auto
codeBytesEnd
=
codeBytesEnd_
.
lock
(
)
;
while
(
codeBytesEnd
<
requiredEnd
)
{
if
(
cancelled_
)
{
return
false
;
}
codeBytesEnd
.
wait
(
)
;
}
return
true
;
}
bool
readVarU32
(
uint32_t
*
u32
)
{
return
waitForBytes
(
MaxVarU32DecodedBytes
)
&
&
d_
.
readVarU32
(
u32
)
;
}
bool
readBytes
(
size_t
size
const
uint8_t
*
*
begin
)
{
return
waitForBytes
(
size
)
&
&
d_
.
readBytes
(
size
begin
)
;
}
bool
finishSection
(
const
SectionRange
&
range
const
char
*
name
)
{
return
d_
.
finishSection
(
range
name
)
;
}
}
;
static
SharedBytes
CreateBytecode
(
const
Bytes
&
env
const
Bytes
&
code
const
Bytes
&
tail
UniqueChars
*
error
)
{
size_t
size
=
env
.
length
(
)
+
code
.
length
(
)
+
tail
.
length
(
)
;
if
(
size
>
MaxModuleBytes
)
{
*
error
=
DuplicateString
(
"
module
too
big
"
)
;
return
nullptr
;
}
MutableBytes
bytecode
=
js_new
<
ShareableBytes
>
(
)
;
if
(
!
bytecode
|
|
!
bytecode
-
>
bytes
.
resize
(
size
)
)
{
return
nullptr
;
}
uint8_t
*
p
=
bytecode
-
>
bytes
.
begin
(
)
;
memcpy
(
p
env
.
begin
(
)
env
.
length
(
)
)
;
p
+
=
env
.
length
(
)
;
memcpy
(
p
code
.
begin
(
)
code
.
length
(
)
)
;
p
+
=
code
.
length
(
)
;
memcpy
(
p
tail
.
begin
(
)
tail
.
length
(
)
)
;
p
+
=
tail
.
length
(
)
;
MOZ_ASSERT
(
p
=
=
bytecode
-
>
end
(
)
)
;
return
bytecode
;
}
SharedModule
wasm
:
:
CompileStreaming
(
const
CompileArgs
&
args
const
Bytes
&
envBytes
const
Bytes
&
codeBytes
const
ExclusiveBytesPtr
&
codeBytesEnd
const
ExclusiveStreamEndData
&
exclusiveStreamEnd
const
Atomic
<
bool
>
&
cancelled
UniqueChars
*
error
UniqueCharsVector
*
warnings
)
{
CompilerEnvironment
compilerEnv
(
args
)
;
MutableModuleMetadata
moduleMeta
=
js_new
<
ModuleMetadata
>
(
)
;
if
(
!
moduleMeta
|
|
!
moduleMeta
-
>
init
(
args
)
)
{
return
nullptr
;
}
CodeMetadata
&
codeMeta
=
*
moduleMeta
-
>
codeMeta
;
{
Decoder
d
(
envBytes
0
error
warnings
)
;
if
(
!
DecodeModuleEnvironment
(
d
&
codeMeta
moduleMeta
)
)
{
return
nullptr
;
}
compilerEnv
.
computeParameters
(
*
moduleMeta
)
;
if
(
!
codeMeta
.
codeSectionRange
)
{
d
.
fail
(
"
unknown
section
before
code
section
"
)
;
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
codeMeta
.
codeSectionRange
-
>
size
=
=
codeBytes
.
length
(
)
)
;
MOZ_RELEASE_ASSERT
(
d
.
done
(
)
)
;
}
if
(
!
moduleMeta
-
>
prepareForCompile
(
compilerEnv
.
mode
(
)
)
)
{
return
nullptr
;
}
ModuleGenerator
mg
(
codeMeta
compilerEnv
compilerEnv
.
initialState
(
)
&
cancelled
error
warnings
)
;
if
(
!
mg
.
initializeCompleteTier
(
)
)
{
return
nullptr
;
}
{
StreamingDecoder
d
(
codeMeta
codeBytes
codeBytesEnd
cancelled
error
warnings
)
;
if
(
!
DecodeCodeSection
(
codeMeta
d
mg
)
)
{
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
d
.
done
(
)
)
;
}
{
auto
streamEnd
=
exclusiveStreamEnd
.
lock
(
)
;
while
(
!
streamEnd
-
>
reached
)
{
if
(
cancelled
)
{
return
nullptr
;
}
streamEnd
.
wait
(
)
;
}
}
const
StreamEndData
streamEnd
=
exclusiveStreamEnd
.
lock
(
)
;
const
Bytes
&
tailBytes
=
*
streamEnd
.
tailBytes
;
{
Decoder
d
(
tailBytes
codeMeta
.
codeSectionRange
-
>
end
(
)
error
warnings
)
;
if
(
!
DecodeModuleTail
(
d
&
codeMeta
moduleMeta
)
)
{
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
d
.
done
(
)
)
;
}
SharedBytes
bytecode
=
CreateBytecode
(
envBytes
codeBytes
tailBytes
error
)
;
if
(
!
bytecode
)
{
return
nullptr
;
}
return
mg
.
finishModule
(
*
bytecode
moduleMeta
streamEnd
.
completeTier2Listener
)
;
}
class
DumpIonModuleGenerator
{
private
:
const
CompilerEnvironment
&
compilerEnv_
;
CodeMetadata
&
codeMeta_
;
uint32_t
targetFuncIndex_
;
IonDumpContents
contents_
;
GenericPrinter
&
out_
;
UniqueChars
*
error_
;
public
:
DumpIonModuleGenerator
(
const
CompilerEnvironment
&
compilerEnv
CodeMetadata
&
codeMeta
uint32_t
targetFuncIndex
IonDumpContents
contents
GenericPrinter
&
out
UniqueChars
*
error
)
:
compilerEnv_
(
compilerEnv
)
codeMeta_
(
codeMeta
)
targetFuncIndex_
(
targetFuncIndex
)
contents_
(
contents
)
out_
(
out
)
error_
(
error
)
{
}
bool
finishFuncDefs
(
)
{
return
true
;
}
bool
compileFuncDef
(
uint32_t
funcIndex
uint32_t
lineOrBytecode
const
uint8_t
*
begin
const
uint8_t
*
end
)
{
if
(
funcIndex
!
=
targetFuncIndex_
)
{
return
true
;
}
FuncCompileInput
input
(
funcIndex
lineOrBytecode
begin
end
Uint32Vector
(
)
)
;
return
IonDumpFunction
(
compilerEnv_
codeMeta_
input
contents_
out_
error_
)
;
}
}
;
bool
wasm
:
:
DumpIonFunctionInModule
(
const
ShareableBytes
&
bytecode
uint32_t
targetFuncIndex
IonDumpContents
contents
GenericPrinter
&
out
UniqueChars
*
error
)
{
SharedCompileArgs
compileArgs
=
CompileArgs
:
:
buildForValidation
(
FeatureArgs
:
:
allEnabled
(
)
)
;
if
(
!
compileArgs
)
{
return
false
;
}
CompilerEnvironment
compilerEnv
(
CompileMode
:
:
Once
Tier
:
:
Optimized
DebugEnabled
:
:
False
)
;
compilerEnv
.
computeParameters
(
)
;
UniqueCharsVector
warnings
;
Decoder
d
(
bytecode
.
bytes
0
error
&
warnings
)
;
MutableModuleMetadata
moduleMeta
=
js_new
<
ModuleMetadata
>
(
)
;
if
(
!
moduleMeta
|
|
!
moduleMeta
-
>
init
(
*
compileArgs
)
)
{
return
false
;
}
if
(
!
DecodeModuleEnvironment
(
d
moduleMeta
-
>
codeMeta
moduleMeta
)
)
{
return
false
;
}
DumpIonModuleGenerator
mg
(
compilerEnv
*
moduleMeta
-
>
codeMeta
targetFuncIndex
contents
out
error
)
;
return
moduleMeta
-
>
prepareForCompile
(
CompileMode
:
:
Once
)
&
&
DecodeCodeSection
(
*
moduleMeta
-
>
codeMeta
d
mg
)
;
}
