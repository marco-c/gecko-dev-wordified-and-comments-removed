#
include
"
wasm
/
WasmCompile
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
jsprf
.
h
"
#
include
"
wasm
/
WasmBaselineCompile
.
h
"
#
include
"
wasm
/
WasmBinaryIterator
.
h
"
#
include
"
wasm
/
WasmGenerator
.
h
"
#
include
"
wasm
/
WasmSignalHandlers
.
h
"
#
include
"
wasm
/
WasmValidate
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
static
bool
DecodeFunctionBody
(
Decoder
&
d
ModuleGenerator
&
mg
uint32_t
funcIndex
)
{
uint32_t
bodySize
;
if
(
!
d
.
readVarU32
(
&
bodySize
)
)
return
d
.
fail
(
"
expected
number
of
function
body
bytes
"
)
;
const
size_t
offsetInModule
=
d
.
currentOffset
(
)
;
const
uint8_t
*
bodyBegin
;
if
(
!
d
.
readBytes
(
bodySize
&
bodyBegin
)
)
return
d
.
fail
(
"
function
body
length
too
big
"
)
;
FunctionGenerator
fg
;
if
(
!
mg
.
startFuncDef
(
offsetInModule
&
fg
)
)
return
false
;
if
(
!
fg
.
bytes
(
)
.
resize
(
bodySize
)
)
return
false
;
memcpy
(
fg
.
bytes
(
)
.
begin
(
)
bodyBegin
bodySize
)
;
return
mg
.
finishFuncDef
(
funcIndex
&
fg
)
;
}
static
bool
DecodeCodeSection
(
Decoder
&
d
ModuleGenerator
&
mg
)
{
uint32_t
sectionStart
sectionSize
;
if
(
!
d
.
startSection
(
SectionId
:
:
Code
&
mg
.
mutableEnv
(
)
&
sectionStart
&
sectionSize
"
code
"
)
)
return
false
;
if
(
!
mg
.
startFuncDefs
(
)
)
return
false
;
if
(
sectionStart
=
=
Decoder
:
:
NotStarted
)
{
if
(
mg
.
env
(
)
.
numFuncDefs
(
)
!
=
0
)
return
d
.
fail
(
"
expected
function
bodies
"
)
;
return
mg
.
finishFuncDefs
(
)
;
}
uint32_t
numFuncDefs
;
if
(
!
d
.
readVarU32
(
&
numFuncDefs
)
)
return
d
.
fail
(
"
expected
function
body
count
"
)
;
if
(
numFuncDefs
!
=
mg
.
env
(
)
.
numFuncDefs
(
)
)
return
d
.
fail
(
"
function
body
count
does
not
match
function
signature
count
"
)
;
for
(
uint32_t
funcDefIndex
=
0
;
funcDefIndex
<
numFuncDefs
;
funcDefIndex
+
+
)
{
if
(
!
DecodeFunctionBody
(
d
mg
mg
.
env
(
)
.
numFuncImports
(
)
+
funcDefIndex
)
)
return
false
;
}
if
(
!
d
.
finishSection
(
sectionStart
sectionSize
"
code
"
)
)
return
false
;
return
mg
.
finishFuncDefs
(
)
;
}
bool
CompileArgs
:
:
initFromContext
(
JSContext
*
cx
ScriptedCaller
&
&
scriptedCaller
)
{
baselineEnabled
=
cx
-
>
options
(
)
.
wasmBaseline
(
)
;
ionEnabled
=
cx
-
>
options
(
)
.
ion
(
)
;
debugEnabled
=
cx
-
>
compartment
(
)
-
>
debuggerObservesAsmJS
(
)
;
this
-
>
scriptedCaller
=
Move
(
scriptedCaller
)
;
return
assumptions
.
initBuildIdFromContext
(
cx
)
;
}
static
void
CompilerAvailability
(
ModuleKind
kind
const
CompileArgs
&
args
bool
*
baselineEnabled
bool
*
debugEnabled
bool
*
ionEnabled
)
{
bool
baselinePossible
=
kind
=
=
ModuleKind
:
:
Wasm
&
&
BaselineCanCompile
(
)
;
*
baselineEnabled
=
baselinePossible
&
&
args
.
baselineEnabled
;
*
debugEnabled
=
baselinePossible
&
&
args
.
debugEnabled
;
*
ionEnabled
=
args
.
ionEnabled
;
if
(
!
(
*
baselineEnabled
|
|
*
ionEnabled
)
)
*
ionEnabled
=
true
;
}
static
bool
BackgroundWorkPossible
(
)
{
return
CanUseExtraThreads
(
)
&
&
HelperThreadState
(
)
.
cpuCount
>
1
;
}
bool
wasm
:
:
GetDebugEnabled
(
const
CompileArgs
&
args
ModuleKind
kind
)
{
bool
baselineEnabled
debugEnabled
ionEnabled
;
CompilerAvailability
(
kind
args
&
baselineEnabled
&
debugEnabled
&
ionEnabled
)
;
return
debugEnabled
;
}
wasm
:
:
CompileMode
wasm
:
:
GetInitialCompileMode
(
const
CompileArgs
&
args
ModuleKind
kind
)
{
bool
baselineEnabled
debugEnabled
ionEnabled
;
CompilerAvailability
(
kind
args
&
baselineEnabled
&
debugEnabled
&
ionEnabled
)
;
return
BackgroundWorkPossible
(
)
&
&
baselineEnabled
&
&
ionEnabled
&
&
!
debugEnabled
?
CompileMode
:
:
Tier1
:
CompileMode
:
:
Once
;
}
wasm
:
:
Tier
wasm
:
:
GetTier
(
const
CompileArgs
&
args
CompileMode
compileMode
ModuleKind
kind
)
{
bool
baselineEnabled
debugEnabled
ionEnabled
;
CompilerAvailability
(
kind
args
&
baselineEnabled
&
debugEnabled
&
ionEnabled
)
;
switch
(
compileMode
)
{
case
CompileMode
:
:
Tier1
:
MOZ_ASSERT
(
baselineEnabled
)
;
return
Tier
:
:
Baseline
;
case
CompileMode
:
:
Tier2
:
MOZ_ASSERT
(
ionEnabled
)
;
return
Tier
:
:
Ion
;
case
CompileMode
:
:
Once
:
return
(
debugEnabled
|
|
!
ionEnabled
)
?
Tier
:
:
Baseline
:
Tier
:
:
Ion
;
default
:
MOZ_CRASH
(
"
Bad
mode
"
)
;
}
}
namespace
js
{
namespace
wasm
{
struct
Tier2GeneratorTask
{
SharedModule
module
;
SharedCompileArgs
compileArgs
;
mozilla
:
:
Atomic
<
bool
>
cancelled
;
Tier2GeneratorTask
(
Module
&
module
const
CompileArgs
&
compileArgs
)
:
module
(
&
module
)
compileArgs
(
&
compileArgs
)
cancelled
(
false
)
{
}
}
;
}
}
static
bool
Compile
(
ModuleGenerator
&
mg
const
ShareableBytes
&
bytecode
const
CompileArgs
&
args
UniqueChars
*
error
CompileMode
compileMode
)
{
auto
env
=
js
:
:
MakeUnique
<
ModuleEnvironment
>
(
)
;
if
(
!
env
)
return
false
;
Decoder
d
(
bytecode
.
bytes
error
)
;
if
(
!
DecodeModuleEnvironment
(
d
env
.
get
(
)
)
)
return
false
;
if
(
!
mg
.
init
(
Move
(
env
)
args
compileMode
)
)
return
false
;
if
(
!
DecodeCodeSection
(
d
mg
)
)
return
false
;
if
(
!
DecodeModuleTail
(
d
&
mg
.
mutableEnv
(
)
)
)
return
false
;
return
true
;
}
SharedModule
wasm
:
:
Compile
(
const
ShareableBytes
&
bytecode
const
CompileArgs
&
args
UniqueChars
*
error
)
{
MOZ_RELEASE_ASSERT
(
wasm
:
:
HaveSignalHandlers
(
)
)
;
ModuleGenerator
mg
(
error
nullptr
)
;
CompileMode
mode
=
GetInitialCompileMode
(
args
)
;
if
(
!
:
:
Compile
(
mg
bytecode
args
error
mode
)
)
return
nullptr
;
MOZ_ASSERT
(
!
*
error
"
unreported
error
in
decoding
"
)
;
SharedModule
module
=
mg
.
finishModule
(
bytecode
)
;
if
(
!
module
)
return
nullptr
;
if
(
mode
=
=
CompileMode
:
:
Tier1
)
{
MOZ_ASSERT
(
BackgroundWorkPossible
(
)
)
;
auto
task
=
js
:
:
MakeUnique
<
Tier2GeneratorTask
>
(
*
module
args
)
;
if
(
!
task
)
{
module
-
>
unblockOnTier2GeneratorFinished
(
CompileMode
:
:
Once
)
;
return
nullptr
;
}
if
(
!
StartOffThreadWasmTier2Generator
(
&
*
task
)
)
{
module
-
>
unblockOnTier2GeneratorFinished
(
CompileMode
:
:
Once
)
;
return
nullptr
;
}
mozilla
:
:
Unused
<
<
task
.
release
(
)
;
}
return
module
;
}
bool
wasm
:
:
GenerateTier2
(
Tier2GeneratorTask
*
task
)
{
UniqueChars
error
;
ModuleGenerator
mg
(
&
error
&
task
-
>
cancelled
)
;
bool
res
=
:
:
Compile
(
mg
task
-
>
module
-
>
bytecode
(
)
*
task
-
>
compileArgs
&
error
CompileMode
:
:
Tier2
)
&
&
mg
.
finishTier2
(
task
-
>
module
-
>
bytecode
(
)
task
-
>
module
)
;
task
-
>
module
-
>
unblockOnTier2GeneratorFinished
(
res
?
CompileMode
:
:
Tier2
:
CompileMode
:
:
Once
)
;
return
res
;
}
void
wasm
:
:
CancelTier2GeneratorTask
(
Tier2GeneratorTask
*
task
)
{
task
-
>
cancelled
=
true
;
task
-
>
module
-
>
unblockOnTier2GeneratorFinished
(
CompileMode
:
:
Once
)
;
}
void
wasm
:
:
DeleteTier2GeneratorTask
(
Tier2GeneratorTask
*
task
)
{
js_delete
(
task
)
;
}
