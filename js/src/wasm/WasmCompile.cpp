#
include
"
wasm
/
WasmCompile
.
h
"
#
include
"
jsprf
.
h
"
#
include
"
wasm
/
WasmBaselineCompile
.
h
"
#
include
"
wasm
/
WasmBinaryIterator
.
h
"
#
include
"
wasm
/
WasmGenerator
.
h
"
#
include
"
wasm
/
WasmSignalHandlers
.
h
"
#
include
"
wasm
/
WasmValidate
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
static
bool
DecodeFunctionBody
(
Decoder
&
d
ModuleGenerator
&
mg
uint32_t
funcIndex
)
{
uint32_t
bodySize
;
if
(
!
d
.
readVarU32
(
&
bodySize
)
)
return
d
.
fail
(
"
expected
number
of
function
body
bytes
"
)
;
const
size_t
offsetInModule
=
d
.
currentOffset
(
)
;
const
uint8_t
*
bodyBegin
;
if
(
!
d
.
readBytes
(
bodySize
&
bodyBegin
)
)
return
d
.
fail
(
"
function
body
length
too
big
"
)
;
FunctionGenerator
fg
;
if
(
!
mg
.
startFuncDef
(
offsetInModule
&
fg
)
)
return
false
;
if
(
!
fg
.
bytes
(
)
.
resize
(
bodySize
)
)
return
false
;
memcpy
(
fg
.
bytes
(
)
.
begin
(
)
bodyBegin
bodySize
)
;
return
mg
.
finishFuncDef
(
funcIndex
&
fg
)
;
}
static
bool
DecodeCodeSection
(
Decoder
&
d
ModuleGenerator
&
mg
)
{
uint32_t
sectionStart
sectionSize
;
if
(
!
d
.
startSection
(
SectionId
:
:
Code
&
mg
.
mutableEnv
(
)
&
sectionStart
&
sectionSize
"
code
"
)
)
return
false
;
if
(
!
mg
.
startFuncDefs
(
)
)
return
false
;
if
(
sectionStart
=
=
Decoder
:
:
NotStarted
)
{
if
(
mg
.
env
(
)
.
numFuncDefs
(
)
!
=
0
)
return
d
.
fail
(
"
expected
function
bodies
"
)
;
return
mg
.
finishFuncDefs
(
)
;
}
uint32_t
numFuncDefs
;
if
(
!
d
.
readVarU32
(
&
numFuncDefs
)
)
return
d
.
fail
(
"
expected
function
body
count
"
)
;
if
(
numFuncDefs
!
=
mg
.
env
(
)
.
numFuncDefs
(
)
)
return
d
.
fail
(
"
function
body
count
does
not
match
function
signature
count
"
)
;
for
(
uint32_t
funcDefIndex
=
0
;
funcDefIndex
<
numFuncDefs
;
funcDefIndex
+
+
)
{
if
(
!
DecodeFunctionBody
(
d
mg
mg
.
env
(
)
.
numFuncImports
(
)
+
funcDefIndex
)
)
return
false
;
}
if
(
!
d
.
finishSection
(
sectionStart
sectionSize
"
code
"
)
)
return
false
;
return
mg
.
finishFuncDefs
(
)
;
}
bool
CompileArgs
:
:
initFromContext
(
JSContext
*
cx
ScriptedCaller
&
&
scriptedCaller
)
{
baselineEnabled
=
cx
-
>
options
(
)
.
wasmBaseline
(
)
;
ionEnabled
=
cx
-
>
options
(
)
.
ion
(
)
;
debugEnabled
=
cx
-
>
compartment
(
)
-
>
debuggerObservesAsmJS
(
)
;
this
-
>
scriptedCaller
=
Move
(
scriptedCaller
)
;
return
assumptions
.
initBuildIdFromContext
(
cx
)
;
}
static
void
CompilerAvailability
(
ModuleKind
kind
const
CompileArgs
&
args
bool
*
baselineEnabled
bool
*
debugEnabled
bool
*
ionEnabled
)
{
bool
baselinePossible
=
kind
=
=
ModuleKind
:
:
Wasm
&
&
BaselineCanCompile
(
)
;
*
baselineEnabled
=
baselinePossible
&
&
args
.
baselineEnabled
;
*
debugEnabled
=
baselinePossible
&
&
args
.
debugEnabled
;
*
ionEnabled
=
args
.
ionEnabled
;
if
(
!
(
*
baselineEnabled
|
|
*
ionEnabled
)
)
*
ionEnabled
=
true
;
}
bool
wasm
:
:
GetDebugEnabled
(
const
CompileArgs
&
args
ModuleKind
kind
)
{
bool
baselineEnabled
debugEnabled
ionEnabled
;
CompilerAvailability
(
kind
args
&
baselineEnabled
&
debugEnabled
&
ionEnabled
)
;
return
debugEnabled
;
}
wasm
:
:
CompileMode
wasm
:
:
GetInitialCompileMode
(
const
CompileArgs
&
args
ModuleKind
kind
)
{
bool
baselineEnabled
debugEnabled
ionEnabled
;
CompilerAvailability
(
kind
args
&
baselineEnabled
&
debugEnabled
&
ionEnabled
)
;
return
(
baselineEnabled
&
&
ionEnabled
&
&
!
debugEnabled
)
?
CompileMode
:
:
Tier1
:
CompileMode
:
:
Once
;
}
wasm
:
:
Tier
wasm
:
:
GetTier
(
const
CompileArgs
&
args
CompileMode
compileMode
ModuleKind
kind
)
{
bool
baselineEnabled
debugEnabled
ionEnabled
;
CompilerAvailability
(
kind
args
&
baselineEnabled
&
debugEnabled
&
ionEnabled
)
;
switch
(
compileMode
)
{
case
CompileMode
:
:
Tier1
:
MOZ_ASSERT
(
baselineEnabled
)
;
return
Tier
:
:
Baseline
;
case
CompileMode
:
:
Tier2
:
MOZ_ASSERT
(
ionEnabled
)
;
return
Tier
:
:
Ion
;
case
CompileMode
:
:
Once
:
return
(
debugEnabled
|
|
!
ionEnabled
)
?
Tier
:
:
Baseline
:
Tier
:
:
Ion
;
default
:
MOZ_CRASH
(
"
Bad
mode
"
)
;
}
}
SharedModule
wasm
:
:
Compile
(
const
ShareableBytes
&
bytecode
const
CompileArgs
&
args
UniqueChars
*
error
)
{
MOZ_RELEASE_ASSERT
(
wasm
:
:
HaveSignalHandlers
(
)
)
;
Decoder
d
(
bytecode
.
bytes
error
)
;
auto
env
=
js
:
:
MakeUnique
<
ModuleEnvironment
>
(
)
;
if
(
!
env
)
return
nullptr
;
if
(
!
DecodeModuleEnvironment
(
d
env
.
get
(
)
)
)
return
nullptr
;
CompileMode
compileMode
=
GetInitialCompileMode
(
args
)
;
ModuleGenerator
mg
(
error
)
;
if
(
!
mg
.
init
(
Move
(
env
)
args
compileMode
)
)
return
nullptr
;
if
(
!
DecodeCodeSection
(
d
mg
)
)
return
nullptr
;
if
(
!
DecodeModuleTail
(
d
&
mg
.
mutableEnv
(
)
)
)
return
nullptr
;
MOZ_ASSERT
(
!
*
error
"
unreported
error
in
decoding
"
)
;
return
mg
.
finish
(
bytecode
)
;
}
