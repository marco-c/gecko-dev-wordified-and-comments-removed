#
ifndef
wasm_type_def_h
#
define
wasm_type_def_h
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
js
/
RefCounted
.
h
"
#
include
"
wasm
/
WasmCodegenConstants
.
h
"
#
include
"
wasm
/
WasmCompileArgs
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
#
include
"
wasm
/
WasmUtility
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
namespace
js
{
namespace
wasm
{
using
mozilla
:
:
CheckedInt32
;
using
mozilla
:
:
MallocSizeOf
;
class
RecGroup
;
class
FuncType
{
ValTypeVector
args_
;
ValTypeVector
results_
;
uint32_t
immediateTypeId_
;
static
const
uint32_t
NO_IMMEDIATE_TYPE_ID
=
UINT32_MAX
;
bool
temporarilyUnsupportedResultCountForJitEntry
(
)
const
{
return
results
(
)
.
length
(
)
>
MaxResultsForJitEntry
;
}
bool
temporarilyUnsupportedResultCountForJitExit
(
)
const
{
return
results
(
)
.
length
(
)
>
MaxResultsForJitExit
;
}
bool
temporarilyUnsupportedReftypeForEntry
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
isRefType
(
)
&
&
(
!
arg
.
isExternRef
(
)
|
|
!
arg
.
isNullable
(
)
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isTypeRef
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
temporarilyUnsupportedReftypeForExit
(
)
const
{
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isRefType
(
)
&
&
(
!
result
.
isExternRef
(
)
|
|
!
result
.
isNullable
(
)
)
)
{
return
true
;
}
}
return
false
;
}
void
initImmediateTypeId
(
)
;
public
:
FuncType
(
)
:
args_
(
)
results_
(
)
{
initImmediateTypeId
(
)
;
}
FuncType
(
ValTypeVector
&
&
args
ValTypeVector
&
&
results
)
:
args_
(
std
:
:
move
(
args
)
)
results_
(
std
:
:
move
(
results
)
)
{
initImmediateTypeId
(
)
;
}
FuncType
(
FuncType
&
&
)
=
default
;
FuncType
&
operator
=
(
FuncType
&
&
)
=
default
;
[
[
nodiscard
]
]
bool
clone
(
const
FuncType
&
src
)
{
MOZ_ASSERT
(
args_
.
empty
(
)
)
;
MOZ_ASSERT
(
results_
.
empty
(
)
)
;
immediateTypeId_
=
src
.
immediateTypeId_
;
return
args_
.
appendAll
(
src
.
args_
)
&
&
results_
.
appendAll
(
src
.
results_
)
;
}
ValType
arg
(
unsigned
i
)
const
{
return
args_
[
i
]
;
}
const
ValTypeVector
&
args
(
)
const
{
return
args_
;
}
ValType
result
(
unsigned
i
)
const
{
return
results_
[
i
]
;
}
const
ValTypeVector
&
results
(
)
const
{
return
results_
;
}
bool
hasImmediateTypeId
(
)
const
{
return
immediateTypeId_
!
=
NO_IMMEDIATE_TYPE_ID
;
}
uint32_t
immediateTypeId
(
)
const
{
MOZ_ASSERT
(
hasImmediateTypeId
(
)
)
;
return
immediateTypeId_
;
}
static
const
uint32_t
ImmediateBit
=
0x1
;
HashNumber
hash
(
const
RecGroup
*
recGroup
)
const
{
HashNumber
hn
=
0
;
for
(
const
ValType
&
vt
:
args_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
vt
.
forMatch
(
recGroup
)
.
hash
(
)
)
;
}
for
(
const
ValType
&
vt
:
results_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
vt
.
forMatch
(
recGroup
)
.
hash
(
)
)
;
}
return
hn
;
}
static
bool
matches
(
const
RecGroup
*
lhsRecGroup
const
FuncType
&
lhs
const
RecGroup
*
rhsRecGroup
const
FuncType
&
rhs
)
{
if
(
lhs
.
args_
.
length
(
)
!
=
rhs
.
args_
.
length
(
)
|
|
lhs
.
results_
.
length
(
)
!
=
rhs
.
results_
.
length
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
lhs
.
args_
.
length
(
)
;
i
+
+
)
{
if
(
lhs
.
args_
[
i
]
.
forMatch
(
lhsRecGroup
)
!
=
rhs
.
args_
[
i
]
.
forMatch
(
rhsRecGroup
)
)
{
return
false
;
}
}
for
(
uint32_t
i
=
0
;
i
<
lhs
.
results_
.
length
(
)
;
i
+
+
)
{
if
(
lhs
.
results_
[
i
]
.
forMatch
(
lhsRecGroup
)
!
=
rhs
.
results_
[
i
]
.
forMatch
(
rhsRecGroup
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
strictlyEquals
(
const
FuncType
&
lhs
const
FuncType
&
rhs
)
{
return
EqualContainers
(
lhs
.
args
(
)
rhs
.
args
(
)
)
&
&
EqualContainers
(
lhs
.
results
(
)
rhs
.
results
(
)
)
;
}
bool
canHaveJitEntry
(
)
const
;
bool
canHaveJitExit
(
)
const
;
bool
hasInt64Arg
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
kind
(
)
=
=
ValType
:
:
Kind
:
:
I64
)
{
return
true
;
}
}
return
false
;
}
bool
hasUnexposableArgOrRet
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
!
arg
.
isExposable
(
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
!
result
.
isExposable
(
)
)
{
return
true
;
}
}
return
false
;
}
#
ifdef
WASM_PRIVATE_REFTYPES
bool
exposesTypeIndex
(
)
const
{
for
(
const
ValType
&
arg
:
args
(
)
)
{
if
(
arg
.
isTypeRef
(
)
)
{
return
true
;
}
}
for
(
const
ValType
&
result
:
results
(
)
)
{
if
(
result
.
isTypeRef
(
)
)
{
return
true
;
}
}
return
false
;
}
#
endif
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
FuncType
)
;
}
;
struct
StructField
{
FieldType
type
;
uint32_t
offset
;
bool
isMutable
;
HashNumber
hash
(
const
RecGroup
*
recGroup
)
const
{
HashNumber
hn
=
0
;
hn
=
mozilla
:
:
AddToHash
(
hn
type
.
forMatch
(
recGroup
)
.
hash
(
)
)
;
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
isMutable
)
)
;
return
hn
;
}
}
;
using
StructFieldVector
=
Vector
<
StructField
0
SystemAllocPolicy
>
;
class
StructType
{
public
:
StructFieldVector
fields_
;
uint32_t
size_
;
public
:
StructType
(
)
:
fields_
(
)
size_
(
0
)
{
}
explicit
StructType
(
StructFieldVector
&
&
fields
)
:
fields_
(
std
:
:
move
(
fields
)
)
size_
(
0
)
{
}
StructType
(
StructType
&
&
)
=
default
;
StructType
&
operator
=
(
StructType
&
&
)
=
default
;
[
[
nodiscard
]
]
bool
clone
(
const
StructType
&
src
)
{
if
(
!
fields_
.
appendAll
(
src
.
fields_
)
)
{
return
false
;
}
size_
=
src
.
size_
;
return
true
;
}
[
[
nodiscard
]
]
bool
init
(
)
;
bool
isDefaultable
(
)
const
{
for
(
auto
&
field
:
fields_
)
{
if
(
!
field
.
type
.
isDefaultable
(
)
)
{
return
false
;
}
}
return
true
;
}
HashNumber
hash
(
const
RecGroup
*
recGroup
)
const
{
HashNumber
hn
=
0
;
for
(
const
StructField
&
field
:
fields_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
field
.
hash
(
recGroup
)
)
;
}
return
hn
;
}
static
bool
matches
(
const
RecGroup
*
lhsRecGroup
const
StructType
&
lhs
const
RecGroup
*
rhsRecGroup
const
StructType
&
rhs
)
{
if
(
lhs
.
fields_
.
length
(
)
!
=
rhs
.
fields_
.
length
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
lhs
.
fields_
.
length
(
)
;
i
+
+
)
{
const
StructField
&
lhsField
=
lhs
.
fields_
[
i
]
;
const
StructField
&
rhsField
=
rhs
.
fields_
[
i
]
;
if
(
lhsField
.
isMutable
!
=
rhsField
.
isMutable
|
|
lhsField
.
type
.
forMatch
(
lhsRecGroup
)
!
=
rhsField
.
type
.
forMatch
(
rhsRecGroup
)
)
{
return
false
;
}
}
return
true
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
StructType
)
;
}
;
using
StructTypeVector
=
Vector
<
StructType
0
SystemAllocPolicy
>
;
class
StructLayout
{
CheckedInt32
sizeSoFar
=
0
;
uint32_t
structAlignment
=
1
;
public
:
CheckedInt32
addField
(
FieldType
type
)
;
CheckedInt32
close
(
)
;
}
;
class
ArrayType
{
public
:
FieldType
elementType_
;
bool
isMutable_
;
public
:
ArrayType
(
)
:
isMutable_
(
false
)
{
}
ArrayType
(
FieldType
elementType
bool
isMutable
)
:
elementType_
(
elementType
)
isMutable_
(
isMutable
)
{
}
ArrayType
(
const
ArrayType
&
)
=
default
;
ArrayType
&
operator
=
(
const
ArrayType
&
)
=
default
;
ArrayType
(
ArrayType
&
&
)
=
default
;
ArrayType
&
operator
=
(
ArrayType
&
&
)
=
default
;
[
[
nodiscard
]
]
bool
clone
(
const
ArrayType
&
src
)
{
elementType_
=
src
.
elementType_
;
isMutable_
=
src
.
isMutable_
;
return
true
;
}
bool
isDefaultable
(
)
const
{
return
elementType_
.
isDefaultable
(
)
;
}
HashNumber
hash
(
const
RecGroup
*
recGroup
)
const
{
HashNumber
hn
=
0
;
hn
=
mozilla
:
:
AddToHash
(
hn
elementType_
.
forMatch
(
recGroup
)
.
hash
(
)
)
;
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
isMutable_
)
)
;
return
hn
;
}
static
bool
matches
(
const
RecGroup
*
lhsRecGroup
const
ArrayType
&
lhs
const
RecGroup
*
rhsRecGroup
const
ArrayType
&
rhs
)
{
if
(
lhs
.
isMutable_
!
=
rhs
.
isMutable_
|
|
lhs
.
elementType_
.
forMatch
(
lhsRecGroup
)
!
=
rhs
.
elementType_
.
forMatch
(
rhsRecGroup
)
)
{
return
false
;
}
return
true
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
ArrayType
)
;
using
ArrayTypeVector
=
Vector
<
ArrayType
0
SystemAllocPolicy
>
;
enum
class
TypeDefKind
:
uint8_t
{
None
=
0
Func
Struct
Array
}
;
class
TypeDef
{
uint32_t
offsetToRecGroup_
;
TypeDefKind
kind_
;
union
{
FuncType
funcType_
;
StructType
structType_
;
ArrayType
arrayType_
;
}
;
void
setRecGroup
(
RecGroup
*
recGroup
)
{
uintptr_t
recGroupAddr
=
(
uintptr_t
)
recGroup
;
uintptr_t
typeDefAddr
=
(
uintptr_t
)
this
;
MOZ_ASSERT
(
typeDefAddr
>
recGroupAddr
)
;
MOZ_ASSERT
(
typeDefAddr
-
recGroupAddr
<
=
UINT32_MAX
)
;
offsetToRecGroup_
=
typeDefAddr
-
recGroupAddr
;
}
public
:
explicit
TypeDef
(
RecGroup
*
recGroup
)
:
offsetToRecGroup_
(
0
)
kind_
(
TypeDefKind
:
:
None
)
{
setRecGroup
(
recGroup
)
;
}
~
TypeDef
(
)
{
switch
(
kind_
)
{
case
TypeDefKind
:
:
Func
:
funcType_
.
~
FuncType
(
)
;
break
;
case
TypeDefKind
:
:
Struct
:
structType_
.
~
StructType
(
)
;
break
;
case
TypeDefKind
:
:
Array
:
arrayType_
.
~
ArrayType
(
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
}
TypeDef
&
operator
=
(
FuncType
&
&
that
)
noexcept
{
MOZ_ASSERT
(
isNone
(
)
)
;
kind_
=
TypeDefKind
:
:
Func
;
new
(
&
funcType_
)
FuncType
(
std
:
:
move
(
that
)
)
;
return
*
this
;
}
TypeDef
&
operator
=
(
StructType
&
&
that
)
noexcept
{
MOZ_ASSERT
(
isNone
(
)
)
;
kind_
=
TypeDefKind
:
:
Struct
;
new
(
&
structType_
)
StructType
(
std
:
:
move
(
that
)
)
;
return
*
this
;
}
TypeDef
&
operator
=
(
ArrayType
&
&
that
)
noexcept
{
MOZ_ASSERT
(
isNone
(
)
)
;
kind_
=
TypeDefKind
:
:
Array
;
new
(
&
arrayType_
)
ArrayType
(
std
:
:
move
(
that
)
)
;
return
*
this
;
}
const
RecGroup
&
recGroup
(
)
const
{
uintptr_t
typeDefAddr
=
(
uintptr_t
)
this
;
uintptr_t
recGroupAddr
=
typeDefAddr
-
offsetToRecGroup_
;
return
*
(
const
RecGroup
*
)
recGroupAddr
;
}
TypeDefKind
kind
(
)
const
{
return
kind_
;
}
bool
isNone
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
None
;
}
bool
isFuncType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Func
;
}
bool
isStructType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Struct
;
}
bool
isArrayType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Array
;
}
const
FuncType
&
funcType
(
)
const
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
FuncType
&
funcType
(
)
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
const
StructType
&
structType
(
)
const
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
StructType
&
structType
(
)
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
const
ArrayType
&
arrayType
(
)
const
{
MOZ_ASSERT
(
isArrayType
(
)
)
;
return
arrayType_
;
}
ArrayType
&
arrayType
(
)
{
MOZ_ASSERT
(
isArrayType
(
)
)
;
return
arrayType_
;
}
HashNumber
hash
(
)
const
{
HashNumber
hn
=
HashNumber
(
kind_
)
;
switch
(
kind_
)
{
case
TypeDefKind
:
:
Func
:
hn
=
mozilla
:
:
AddToHash
(
hn
funcType_
.
hash
(
&
recGroup
(
)
)
)
;
break
;
case
TypeDefKind
:
:
Struct
:
hn
=
mozilla
:
:
AddToHash
(
hn
structType_
.
hash
(
&
recGroup
(
)
)
)
;
break
;
case
TypeDefKind
:
:
Array
:
hn
=
mozilla
:
:
AddToHash
(
hn
arrayType_
.
hash
(
&
recGroup
(
)
)
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
return
hn
;
}
static
bool
matches
(
const
TypeDef
&
lhs
const
TypeDef
&
rhs
)
{
if
(
lhs
.
kind_
!
=
rhs
.
kind_
)
{
return
false
;
}
switch
(
lhs
.
kind_
)
{
case
TypeDefKind
:
:
Func
:
return
FuncType
:
:
matches
(
&
lhs
.
recGroup
(
)
lhs
.
funcType_
&
rhs
.
recGroup
(
)
rhs
.
funcType_
)
;
case
TypeDefKind
:
:
Struct
:
return
StructType
:
:
matches
(
&
lhs
.
recGroup
(
)
lhs
.
structType_
&
rhs
.
recGroup
(
)
rhs
.
structType_
)
;
case
TypeDefKind
:
:
Array
:
return
ArrayType
:
:
matches
(
&
lhs
.
recGroup
(
)
lhs
.
arrayType_
&
rhs
.
recGroup
(
)
rhs
.
arrayType_
)
;
case
TypeDefKind
:
:
None
:
return
true
;
}
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
TypeDef
)
;
}
;
using
SharedTypeDef
=
RefPtr
<
const
TypeDef
>
;
using
MutableTypeDef
=
RefPtr
<
TypeDef
>
;
using
TypeDefVector
=
Vector
<
TypeDef
0
SystemAllocPolicy
>
;
using
TypeDefPtrVector
=
Vector
<
const
TypeDef
*
0
SystemAllocPolicy
>
;
using
TypeDefPtrToIndexMap
=
HashMap
<
const
TypeDef
*
uint32_t
PointerHasher
<
const
TypeDef
*
>
SystemAllocPolicy
>
;
class
RecGroup
:
public
AtomicRefCounted
<
RecGroup
>
{
bool
finalizedTypes_
;
uint32_t
numTypes_
;
TypeDef
types_
[
0
]
;
friend
class
TypeContext
;
explicit
RecGroup
(
uint32_t
numTypes
)
:
finalizedTypes_
(
false
)
numTypes_
(
numTypes
)
{
}
static
constexpr
size_t
sizeOfRecGroup
(
uint32_t
numTypes
)
{
static_assert
(
MaxTypes
<
=
SIZE_MAX
/
sizeof
(
TypeDef
)
)
;
return
sizeof
(
RecGroup
)
+
sizeof
(
TypeDef
)
*
numTypes
;
}
static
RefPtr
<
RecGroup
>
allocate
(
uint32_t
numTypes
)
{
RecGroup
*
recGroup
=
(
RecGroup
*
)
js_malloc
(
sizeOfRecGroup
(
numTypes
)
)
;
if
(
!
recGroup
)
{
return
nullptr
;
}
new
(
recGroup
)
RecGroup
(
numTypes
)
;
for
(
uint32_t
i
=
0
;
i
<
numTypes
;
i
+
+
)
{
new
(
recGroup
-
>
types_
+
i
)
TypeDef
(
recGroup
)
;
}
return
recGroup
;
}
void
finalizeDefinitions
(
)
{
MOZ_ASSERT
(
!
finalizedTypes_
)
;
finalizedTypes_
=
true
;
visitReferencedGroups
(
[
]
(
const
RecGroup
*
recGroup
)
{
recGroup
-
>
AddRef
(
)
;
}
)
;
}
template
<
typename
Visitor
>
void
visitReferencedGroups
(
Visitor
visitor
)
const
{
auto
visitValType
=
[
this
visitor
]
(
ValType
type
)
{
if
(
type
.
isTypeRef
(
)
&
&
&
type
.
typeDef
(
)
-
>
recGroup
(
)
!
=
this
)
{
visitor
(
&
type
.
typeDef
(
)
-
>
recGroup
(
)
)
;
}
}
;
auto
visitFieldType
=
[
this
visitor
]
(
FieldType
type
)
{
if
(
type
.
isTypeRef
(
)
&
&
&
type
.
typeDef
(
)
-
>
recGroup
(
)
!
=
this
)
{
visitor
(
&
type
.
typeDef
(
)
-
>
recGroup
(
)
)
;
}
}
;
for
(
uint32_t
i
=
0
;
i
<
numTypes_
;
i
+
+
)
{
const
TypeDef
&
typeDef
=
types_
[
i
]
;
switch
(
typeDef
.
kind
(
)
)
{
case
TypeDefKind
:
:
Func
:
{
const
FuncType
&
funcType
=
typeDef
.
funcType
(
)
;
for
(
auto
type
:
funcType
.
args
(
)
)
{
visitValType
(
type
)
;
}
for
(
auto
type
:
funcType
.
results
(
)
)
{
visitValType
(
type
)
;
}
break
;
}
case
TypeDefKind
:
:
Struct
:
{
const
StructType
&
structType
=
typeDef
.
structType
(
)
;
for
(
const
auto
&
field
:
structType
.
fields_
)
{
visitFieldType
(
field
.
type
)
;
}
break
;
}
case
TypeDefKind
:
:
Array
:
{
const
ArrayType
&
arrayType
=
typeDef
.
arrayType
(
)
;
visitFieldType
(
arrayType
.
elementType_
)
;
break
;
}
case
TypeDefKind
:
:
None
:
{
MOZ_CRASH
(
)
;
}
}
}
}
public
:
~
RecGroup
(
)
{
if
(
finalizedTypes_
)
{
finalizedTypes_
=
false
;
visitReferencedGroups
(
[
]
(
const
RecGroup
*
recGroup
)
{
recGroup
-
>
Release
(
)
;
}
)
;
}
for
(
uint32_t
i
=
0
;
i
<
numTypes_
;
i
+
+
)
{
type
(
i
)
.
~
TypeDef
(
)
;
}
}
RecGroup
&
operator
=
(
const
RecGroup
&
)
=
delete
;
RecGroup
&
operator
=
(
RecGroup
&
&
)
=
delete
;
TypeDef
&
type
(
uint32_t
groupTypeIndex
)
{
MOZ_ASSERT
(
!
finalizedTypes_
)
;
return
types_
[
groupTypeIndex
]
;
}
const
TypeDef
&
type
(
uint32_t
groupTypeIndex
)
const
{
return
types_
[
groupTypeIndex
]
;
}
uint32_t
numTypes
(
)
const
{
return
numTypes_
;
}
uint32_t
indexOf
(
const
TypeDef
*
typeDef
)
const
{
MOZ_ASSERT
(
typeDef
>
=
types_
)
;
size_t
groupTypeIndex
=
(
size_t
)
(
typeDef
-
types_
)
;
MOZ_ASSERT
(
groupTypeIndex
<
numTypes
(
)
)
;
return
(
uint32_t
)
groupTypeIndex
;
}
HashNumber
hash
(
)
const
{
HashNumber
hn
=
0
;
for
(
uint32_t
i
=
0
;
i
<
numTypes
(
)
;
i
+
+
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
types_
[
i
]
.
hash
(
)
)
;
}
return
hn
;
}
static
bool
matches
(
const
RecGroup
&
lhs
const
RecGroup
&
rhs
)
{
if
(
lhs
.
numTypes
(
)
!
=
rhs
.
numTypes
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
lhs
.
numTypes
(
)
;
i
+
+
)
{
if
(
!
TypeDef
:
:
matches
(
lhs
.
type
(
i
)
rhs
.
type
(
i
)
)
)
{
return
false
;
}
}
return
true
;
}
}
;
using
SharedRecGroup
=
RefPtr
<
const
RecGroup
>
;
using
MutableRecGroup
=
RefPtr
<
RecGroup
>
;
using
SharedRecGroupVector
=
Vector
<
SharedRecGroup
0
SystemAllocPolicy
>
;
class
TypeCache
{
struct
TypePair
{
const
TypeDef
*
first
;
const
TypeDef
*
second
;
constexpr
TypePair
(
const
TypeDef
*
first
const
TypeDef
*
second
)
:
first
(
first
)
second
(
second
)
{
}
static
constexpr
TypePair
ordered
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
return
TypePair
(
a
b
)
;
}
static
constexpr
TypePair
unordered
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
if
(
a
<
b
)
{
return
TypePair
(
a
b
)
;
}
return
TypePair
(
b
a
)
;
}
HashNumber
hash
(
)
const
{
HashNumber
hn
=
0
;
hn
=
mozilla
:
:
AddToHash
(
hn
first
)
;
hn
=
mozilla
:
:
AddToHash
(
hn
second
)
;
return
hn
;
}
bool
operator
=
=
(
const
TypePair
&
rhs
)
const
{
return
first
=
=
rhs
.
first
&
&
second
=
=
rhs
.
second
;
}
}
;
struct
TypePairHashPolicy
{
using
Lookup
=
const
TypePair
&
;
static
HashNumber
hash
(
Lookup
pair
)
{
return
pair
.
hash
(
)
;
}
static
bool
match
(
const
TypePair
&
lhs
Lookup
rhs
)
{
return
lhs
=
=
rhs
;
}
}
;
using
TypeSet
=
HashSet
<
TypePair
TypePairHashPolicy
SystemAllocPolicy
>
;
TypeSet
equivalence_
;
TypeSet
subtype_
;
public
:
TypeCache
(
)
=
default
;
[
[
nodiscard
]
]
bool
markEquivalent
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
return
equivalence_
.
put
(
TypePair
:
:
unordered
(
a
b
)
)
;
}
void
unmarkEquivalent
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
equivalence_
.
remove
(
TypePair
:
:
unordered
(
a
b
)
)
;
}
bool
isEquivalent
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
return
equivalence_
.
has
(
TypePair
:
:
unordered
(
a
b
)
)
;
}
[
[
nodiscard
]
]
bool
markSubtypeOf
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
return
subtype_
.
put
(
TypePair
:
:
ordered
(
a
b
)
)
;
}
void
unmarkSubtypeOf
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
subtype_
.
remove
(
TypePair
:
:
ordered
(
a
b
)
)
;
}
bool
isSubtypeOf
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
return
subtype_
.
has
(
TypePair
:
:
ordered
(
a
b
)
)
;
}
}
;
enum
class
TypeResult
{
True
False
OOM
}
;
class
TypeContext
:
public
AtomicRefCounted
<
TypeContext
>
{
FeatureArgs
features_
;
MutableRecGroup
pendingRecGroup_
;
SharedRecGroupVector
recGroups_
;
TypeDefPtrVector
types_
;
TypeDefPtrToIndexMap
moduleIndices_
;
static
SharedRecGroup
canonicalizeGroup
(
SharedRecGroup
recGroup
)
;
public
:
TypeContext
(
)
=
default
;
explicit
TypeContext
(
const
FeatureArgs
&
features
)
:
features_
(
features
)
{
}
~
TypeContext
(
)
;
size_t
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
types_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
moduleIndices_
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
}
TypeContext
(
const
TypeContext
&
)
=
delete
;
TypeContext
&
operator
=
(
const
TypeContext
&
)
=
delete
;
TypeContext
(
TypeContext
&
&
)
=
delete
;
TypeContext
&
operator
=
(
TypeContext
&
&
)
=
delete
;
[
[
nodiscard
]
]
MutableRecGroup
startRecGroup
(
uint32_t
numTypes
)
{
MOZ_ASSERT
(
!
pendingRecGroup_
)
;
pendingRecGroup_
=
RecGroup
:
:
allocate
(
numTypes
)
;
if
(
!
pendingRecGroup_
|
|
!
recGroups_
.
append
(
pendingRecGroup_
)
)
{
return
nullptr
;
}
for
(
uint32_t
groupTypeIndex
=
0
;
groupTypeIndex
<
numTypes
;
groupTypeIndex
+
+
)
{
const
TypeDef
*
typeDef
=
&
pendingRecGroup_
-
>
type
(
groupTypeIndex
)
;
uint32_t
typeIndex
=
types_
.
length
(
)
;
if
(
!
types_
.
append
(
typeDef
)
|
|
!
moduleIndices_
.
put
(
typeDef
typeIndex
)
)
{
return
nullptr
;
}
}
return
pendingRecGroup_
;
}
[
[
nodiscard
]
]
bool
endRecGroup
(
)
{
MOZ_ASSERT
(
pendingRecGroup_
)
;
MutableRecGroup
recGroup
=
pendingRecGroup_
;
pendingRecGroup_
=
nullptr
;
recGroup
-
>
finalizeDefinitions
(
)
;
SharedRecGroup
canonicalRecGroup
=
canonicalizeGroup
(
recGroup
)
;
if
(
!
canonicalRecGroup
)
{
return
false
;
}
if
(
canonicalRecGroup
=
=
recGroup
)
{
return
true
;
}
recGroups_
.
back
(
)
=
canonicalRecGroup
;
MOZ_ASSERT
(
recGroup
-
>
numTypes
(
)
=
=
canonicalRecGroup
-
>
numTypes
(
)
)
;
for
(
uint32_t
groupTypeIndex
=
0
;
groupTypeIndex
<
recGroup
-
>
numTypes
(
)
;
groupTypeIndex
+
+
)
{
uint32_t
typeIndex
=
length
(
)
-
recGroup
-
>
numTypes
(
)
+
groupTypeIndex
;
const
TypeDef
*
oldTypeDef
=
types_
[
typeIndex
]
;
const
TypeDef
*
newTypeDef
=
&
canonicalRecGroup
-
>
type
(
groupTypeIndex
)
;
types_
[
typeIndex
]
=
newTypeDef
;
moduleIndices_
.
remove
(
oldTypeDef
)
;
if
(
!
moduleIndices_
.
put
(
newTypeDef
typeIndex
)
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
bool
addType
(
T
&
&
type
)
{
MutableRecGroup
recGroup
=
startRecGroup
(
1
)
;
if
(
!
recGroup
)
{
return
false
;
}
recGroup
-
>
type
(
0
)
=
std
:
:
move
(
type
)
;
return
endRecGroup
(
)
;
}
const
TypeDef
&
type
(
uint32_t
index
)
const
{
return
*
types_
[
index
]
;
}
const
TypeDef
&
operator
[
]
(
uint32_t
index
)
const
{
return
*
types_
[
index
]
;
}
bool
empty
(
)
const
{
return
types_
.
empty
(
)
;
}
uint32_t
length
(
)
const
{
return
types_
.
length
(
)
;
}
const
SharedRecGroupVector
&
groups
(
)
const
{
return
recGroups_
;
}
uint32_t
indexOf
(
const
TypeDef
&
typeDef
)
const
{
auto
moduleIndex
=
moduleIndices_
.
readonlyThreadsafeLookup
(
&
typeDef
)
;
MOZ_RELEASE_ASSERT
(
moduleIndex
.
found
(
)
)
;
return
moduleIndex
-
>
value
(
)
;
}
template
<
class
T
>
TypeResult
isEquivalent
(
T
first
T
second
TypeCache
*
cache
)
const
{
if
(
first
=
=
second
)
{
return
TypeResult
:
:
True
;
}
if
(
first
.
isRefType
(
)
&
&
second
.
isRefType
(
)
)
{
return
isRefEquivalent
(
first
.
refType
(
)
second
.
refType
(
)
cache
)
;
}
return
TypeResult
:
:
False
;
}
TypeResult
isRefEquivalent
(
RefType
first
RefType
second
TypeCache
*
cache
)
const
;
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
TypeResult
isTypeDefEquivalent
(
const
TypeDef
*
first
const
TypeDef
*
second
TypeCache
*
cache
)
const
;
#
endif
#
ifdef
ENABLE_WASM_GC
TypeResult
isStructEquivalent
(
const
TypeDef
*
first
const
TypeDef
*
second
TypeCache
*
cache
)
const
;
TypeResult
isStructFieldEquivalent
(
const
StructField
first
const
StructField
second
TypeCache
*
cache
)
const
;
TypeResult
isArrayEquivalent
(
const
TypeDef
*
first
const
TypeDef
*
second
TypeCache
*
cache
)
const
;
TypeResult
isArrayElementEquivalent
(
const
ArrayType
&
first
const
ArrayType
&
second
TypeCache
*
cache
)
const
;
#
endif
template
<
class
T
>
TypeResult
isSubtypeOf
(
T
subType
T
superType
TypeCache
*
cache
)
const
{
if
(
subType
=
=
superType
)
{
return
TypeResult
:
:
True
;
}
if
(
subType
.
isRefType
(
)
&
&
superType
.
isRefType
(
)
)
{
return
isRefSubtypeOf
(
subType
.
refType
(
)
superType
.
refType
(
)
cache
)
;
}
return
TypeResult
:
:
False
;
}
TypeResult
isRefSubtypeOf
(
RefType
subType
RefType
superType
TypeCache
*
cache
)
const
;
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
TypeResult
isTypeDefSubtypeOf
(
const
TypeDef
*
subType
const
TypeDef
*
superType
TypeCache
*
cache
)
const
;
#
endif
#
ifdef
ENABLE_WASM_GC
TypeResult
isStructSubtypeOf
(
const
TypeDef
*
subType
const
TypeDef
*
superType
TypeCache
*
cache
)
const
;
TypeResult
isStructFieldSubtypeOf
(
const
StructField
subType
const
StructField
superType
TypeCache
*
cache
)
const
;
TypeResult
isArraySubtypeOf
(
const
TypeDef
*
subType
const
TypeDef
*
superType
TypeCache
*
cache
)
const
;
TypeResult
isArrayElementSubtypeOf
(
const
ArrayType
&
subType
const
ArrayType
&
superType
TypeCache
*
cache
)
const
;
#
endif
}
;
using
SharedTypeContext
=
RefPtr
<
const
TypeContext
>
;
using
MutableTypeContext
=
RefPtr
<
TypeContext
>
;
class
TypeHandle
{
private
:
SharedTypeContext
context_
;
uint32_t
index_
;
public
:
TypeHandle
(
SharedTypeContext
context
uint32_t
index
)
:
context_
(
context
)
index_
(
index
)
{
MOZ_ASSERT
(
index_
<
context_
-
>
length
(
)
)
;
}
TypeHandle
(
SharedTypeContext
context
const
TypeDef
&
def
)
:
context_
(
context
)
index_
(
context
-
>
indexOf
(
def
)
)
{
}
TypeHandle
(
const
TypeHandle
&
)
=
default
;
TypeHandle
&
operator
=
(
const
TypeHandle
&
)
=
default
;
const
SharedTypeContext
&
context
(
)
const
{
return
context_
;
}
uint32_t
index
(
)
const
{
return
index_
;
}
const
TypeDef
&
def
(
)
const
{
return
context_
-
>
type
(
index_
)
;
}
}
;
inline
MatchTypeCode
MatchTypeCode
:
:
forMatch
(
PackedTypeCode
ptc
const
RecGroup
*
recGroup
)
{
MatchTypeCode
mtc
=
{
}
;
mtc
.
typeCode
=
PackedRepr
(
ptc
.
typeCode
(
)
)
;
if
(
ptc
.
typeDef
(
)
&
&
&
ptc
.
typeDef
(
)
-
>
recGroup
(
)
=
=
recGroup
)
{
mtc
.
isLocal
=
true
;
mtc
.
typeRef
=
recGroup
-
>
indexOf
(
ptc
.
typeDef
(
)
)
;
}
else
{
mtc
.
isLocal
=
false
;
mtc
.
typeRef
=
PackedRepr
(
ptc
.
typeDef
(
)
)
;
}
mtc
.
nullable
=
ptc
.
isNullable
(
)
;
return
mtc
;
}
}
}
#
endif
