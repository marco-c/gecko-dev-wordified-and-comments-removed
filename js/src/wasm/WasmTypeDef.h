#
ifndef
wasm_type_def_h
#
define
wasm_type_def_h
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
js
/
RefCounted
.
h
"
#
include
"
wasm
/
WasmCodegenConstants
.
h
"
#
include
"
wasm
/
WasmCompileArgs
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
#
include
"
wasm
/
WasmUtility
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
namespace
js
{
namespace
wasm
{
using
mozilla
:
:
CheckedInt32
;
using
mozilla
:
:
MallocSizeOf
;
class
FuncType
{
ValTypeVector
args_
;
ValTypeVector
results_
;
uint32_t
immediateTypeId_
;
static
const
uint32_t
NO_IMMEDIATE_TYPE_ID
=
UINT32_MAX
;
bool
temporarilyUnsupportedResultCountForJitEntry
(
)
const
{
return
results
(
)
.
length
(
)
>
MaxResultsForJitEntry
;
}
bool
temporarilyUnsupportedResultCountForJitExit
(
)
const
{
return
results
(
)
.
length
(
)
>
MaxResultsForJitExit
;
}
bool
temporarilyUnsupportedReftypeForEntry
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
isRefType
(
)
&
&
(
!
arg
.
isExternRef
(
)
|
|
!
arg
.
isNullable
(
)
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isTypeRef
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
temporarilyUnsupportedReftypeForExit
(
)
const
{
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isRefType
(
)
&
&
(
!
result
.
isExternRef
(
)
|
|
!
result
.
isNullable
(
)
)
)
{
return
true
;
}
}
return
false
;
}
void
initImmediateTypeId
(
)
;
public
:
FuncType
(
)
:
args_
(
)
results_
(
)
{
initImmediateTypeId
(
)
;
}
FuncType
(
ValTypeVector
&
&
args
ValTypeVector
&
&
results
)
:
args_
(
std
:
:
move
(
args
)
)
results_
(
std
:
:
move
(
results
)
)
{
initImmediateTypeId
(
)
;
}
FuncType
(
FuncType
&
&
)
=
default
;
FuncType
&
operator
=
(
FuncType
&
&
)
=
default
;
[
[
nodiscard
]
]
bool
clone
(
const
FuncType
&
src
)
{
MOZ_ASSERT
(
args_
.
empty
(
)
)
;
MOZ_ASSERT
(
results_
.
empty
(
)
)
;
immediateTypeId_
=
src
.
immediateTypeId_
;
return
args_
.
appendAll
(
src
.
args_
)
&
&
results_
.
appendAll
(
src
.
results_
)
;
}
ValType
arg
(
unsigned
i
)
const
{
return
args_
[
i
]
;
}
const
ValTypeVector
&
args
(
)
const
{
return
args_
;
}
ValType
result
(
unsigned
i
)
const
{
return
results_
[
i
]
;
}
const
ValTypeVector
&
results
(
)
const
{
return
results_
;
}
bool
hasImmediateTypeId
(
)
const
{
return
immediateTypeId_
!
=
NO_IMMEDIATE_TYPE_ID
;
}
uint32_t
immediateTypeId
(
)
const
{
MOZ_ASSERT
(
hasImmediateTypeId
(
)
)
;
return
immediateTypeId_
;
}
static
const
uint32_t
ImmediateBit
=
0x1
;
HashNumber
hash
(
)
const
{
HashNumber
hn
=
0
;
for
(
const
ValType
&
vt
:
args_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
vt
.
packed
(
)
.
bits
(
)
)
)
;
}
for
(
const
ValType
&
vt
:
results_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
vt
.
packed
(
)
.
bits
(
)
)
)
;
}
return
hn
;
}
bool
operator
=
=
(
const
FuncType
&
rhs
)
const
{
return
EqualContainers
(
args
(
)
rhs
.
args
(
)
)
&
&
EqualContainers
(
results
(
)
rhs
.
results
(
)
)
;
}
bool
operator
!
=
(
const
FuncType
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
canHaveJitEntry
(
)
const
;
bool
canHaveJitExit
(
)
const
;
bool
hasInt64Arg
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
kind
(
)
=
=
ValType
:
:
Kind
:
:
I64
)
{
return
true
;
}
}
return
false
;
}
bool
hasUnexposableArgOrRet
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
!
arg
.
isExposable
(
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
!
result
.
isExposable
(
)
)
{
return
true
;
}
}
return
false
;
}
#
ifdef
WASM_PRIVATE_REFTYPES
bool
exposesTypeIndex
(
)
const
{
for
(
const
ValType
&
arg
:
args
(
)
)
{
if
(
arg
.
isTypeRef
(
)
)
{
return
true
;
}
}
for
(
const
ValType
&
result
:
results
(
)
)
{
if
(
result
.
isTypeRef
(
)
)
{
return
true
;
}
}
return
false
;
}
#
endif
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
FuncType
)
;
}
;
struct
FuncTypeHashPolicy
{
using
Lookup
=
const
FuncType
&
;
static
HashNumber
hash
(
Lookup
ft
)
{
return
ft
.
hash
(
)
;
}
static
bool
match
(
const
FuncType
*
lhs
Lookup
rhs
)
{
return
*
lhs
=
=
rhs
;
}
}
;
struct
StructField
{
FieldType
type
;
uint32_t
offset
;
bool
isMutable
;
}
;
using
StructFieldVector
=
Vector
<
StructField
0
SystemAllocPolicy
>
;
class
StructType
{
public
:
StructFieldVector
fields_
;
uint32_t
size_
;
public
:
StructType
(
)
:
fields_
(
)
size_
(
0
)
{
}
explicit
StructType
(
StructFieldVector
&
&
fields
)
:
fields_
(
std
:
:
move
(
fields
)
)
size_
(
0
)
{
}
StructType
(
StructType
&
&
)
=
default
;
StructType
&
operator
=
(
StructType
&
&
)
=
default
;
[
[
nodiscard
]
]
bool
clone
(
const
StructType
&
src
)
{
if
(
!
fields_
.
appendAll
(
src
.
fields_
)
)
{
return
false
;
}
size_
=
src
.
size_
;
return
true
;
}
[
[
nodiscard
]
]
bool
init
(
)
;
bool
isDefaultable
(
)
const
{
for
(
auto
&
field
:
fields_
)
{
if
(
!
field
.
type
.
isDefaultable
(
)
)
{
return
false
;
}
}
return
true
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
StructType
)
;
}
;
using
StructTypeVector
=
Vector
<
StructType
0
SystemAllocPolicy
>
;
class
StructLayout
{
CheckedInt32
sizeSoFar
=
0
;
uint32_t
structAlignment
=
1
;
public
:
CheckedInt32
addField
(
FieldType
type
)
;
CheckedInt32
close
(
)
;
}
;
class
ArrayType
{
public
:
FieldType
elementType_
;
bool
isMutable_
;
public
:
ArrayType
(
)
:
isMutable_
(
false
)
{
}
ArrayType
(
FieldType
elementType
bool
isMutable
)
:
elementType_
(
elementType
)
isMutable_
(
isMutable
)
{
}
ArrayType
(
const
ArrayType
&
)
=
default
;
ArrayType
&
operator
=
(
const
ArrayType
&
)
=
default
;
ArrayType
(
ArrayType
&
&
)
=
default
;
ArrayType
&
operator
=
(
ArrayType
&
&
)
=
default
;
[
[
nodiscard
]
]
bool
clone
(
const
ArrayType
&
src
)
{
elementType_
=
src
.
elementType_
;
isMutable_
=
src
.
isMutable_
;
return
true
;
}
bool
isDefaultable
(
)
const
{
return
elementType_
.
isDefaultable
(
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
ArrayType
)
;
using
ArrayTypeVector
=
Vector
<
ArrayType
0
SystemAllocPolicy
>
;
enum
class
TypeDefKind
:
uint8_t
{
None
=
0
Func
Struct
Array
}
;
class
TypeDef
:
public
AtomicRefCounted
<
TypeDef
>
{
TypeDefKind
kind_
;
union
{
FuncType
funcType_
;
StructType
structType_
;
ArrayType
arrayType_
;
}
;
public
:
TypeDef
(
)
:
kind_
(
TypeDefKind
:
:
None
)
{
}
explicit
TypeDef
(
FuncType
&
&
funcType
)
:
kind_
(
TypeDefKind
:
:
Func
)
funcType_
(
std
:
:
move
(
funcType
)
)
{
}
explicit
TypeDef
(
StructType
&
&
structType
)
:
kind_
(
TypeDefKind
:
:
Struct
)
structType_
(
std
:
:
move
(
structType
)
)
{
}
explicit
TypeDef
(
ArrayType
&
&
arrayType
)
:
kind_
(
TypeDefKind
:
:
Array
)
arrayType_
(
std
:
:
move
(
arrayType
)
)
{
}
TypeDef
(
TypeDef
&
&
td
)
noexcept
:
kind_
(
td
.
kind_
)
{
switch
(
kind_
)
{
case
TypeDefKind
:
:
Func
:
new
(
&
funcType_
)
FuncType
(
std
:
:
move
(
td
.
funcType_
)
)
;
break
;
case
TypeDefKind
:
:
Struct
:
new
(
&
structType_
)
StructType
(
std
:
:
move
(
td
.
structType_
)
)
;
break
;
case
TypeDefKind
:
:
Array
:
new
(
&
arrayType_
)
ArrayType
(
std
:
:
move
(
td
.
arrayType_
)
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
}
~
TypeDef
(
)
{
switch
(
kind_
)
{
case
TypeDefKind
:
:
Func
:
funcType_
.
~
FuncType
(
)
;
break
;
case
TypeDefKind
:
:
Struct
:
structType_
.
~
StructType
(
)
;
break
;
case
TypeDefKind
:
:
Array
:
arrayType_
.
~
ArrayType
(
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
}
TypeDef
&
operator
=
(
FuncType
&
&
that
)
noexcept
{
MOZ_ASSERT
(
isNone
(
)
)
;
kind_
=
TypeDefKind
:
:
Func
;
new
(
&
funcType_
)
FuncType
(
std
:
:
move
(
that
)
)
;
return
*
this
;
}
TypeDef
&
operator
=
(
StructType
&
&
that
)
noexcept
{
MOZ_ASSERT
(
isNone
(
)
)
;
kind_
=
TypeDefKind
:
:
Struct
;
new
(
&
structType_
)
StructType
(
std
:
:
move
(
that
)
)
;
return
*
this
;
}
TypeDef
&
operator
=
(
ArrayType
&
&
that
)
noexcept
{
MOZ_ASSERT
(
isNone
(
)
)
;
kind_
=
TypeDefKind
:
:
Array
;
new
(
&
arrayType_
)
ArrayType
(
std
:
:
move
(
that
)
)
;
return
*
this
;
}
TypeDefKind
kind
(
)
const
{
return
kind_
;
}
bool
isNone
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
None
;
}
bool
isFuncType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Func
;
}
bool
isStructType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Struct
;
}
bool
isArrayType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Array
;
}
const
FuncType
&
funcType
(
)
const
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
FuncType
&
funcType
(
)
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
const
StructType
&
structType
(
)
const
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
StructType
&
structType
(
)
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
const
ArrayType
&
arrayType
(
)
const
{
MOZ_ASSERT
(
isArrayType
(
)
)
;
return
arrayType_
;
}
ArrayType
&
arrayType
(
)
{
MOZ_ASSERT
(
isArrayType
(
)
)
;
return
arrayType_
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
TypeDef
)
;
}
;
using
SharedTypeDef
=
RefPtr
<
const
TypeDef
>
;
using
MutableTypeDef
=
RefPtr
<
TypeDef
>
;
using
TypeDefVector
=
Vector
<
TypeDef
0
SystemAllocPolicy
>
;
using
MutableTypeDefVector
=
Vector
<
MutableTypeDef
0
SystemAllocPolicy
>
;
using
TypeDefToModuleIndexMap
=
HashMap
<
const
TypeDef
*
uint32_t
PointerHasher
<
const
TypeDef
*
>
SystemAllocPolicy
>
;
class
TypeCache
{
struct
TypePair
{
const
TypeDef
*
first
;
const
TypeDef
*
second
;
constexpr
TypePair
(
const
TypeDef
*
first
const
TypeDef
*
second
)
:
first
(
first
)
second
(
second
)
{
}
static
constexpr
TypePair
ordered
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
return
TypePair
(
a
b
)
;
}
static
constexpr
TypePair
unordered
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
if
(
a
<
b
)
{
return
TypePair
(
a
b
)
;
}
return
TypePair
(
b
a
)
;
}
HashNumber
hash
(
)
const
{
HashNumber
hn
=
0
;
hn
=
mozilla
:
:
AddToHash
(
hn
first
)
;
hn
=
mozilla
:
:
AddToHash
(
hn
second
)
;
return
hn
;
}
bool
operator
=
=
(
const
TypePair
&
rhs
)
const
{
return
first
=
=
rhs
.
first
&
&
second
=
=
rhs
.
second
;
}
}
;
struct
TypePairHashPolicy
{
using
Lookup
=
const
TypePair
&
;
static
HashNumber
hash
(
Lookup
pair
)
{
return
pair
.
hash
(
)
;
}
static
bool
match
(
const
TypePair
&
lhs
Lookup
rhs
)
{
return
lhs
=
=
rhs
;
}
}
;
using
TypeSet
=
HashSet
<
TypePair
TypePairHashPolicy
SystemAllocPolicy
>
;
TypeSet
equivalence_
;
TypeSet
subtype_
;
public
:
TypeCache
(
)
=
default
;
[
[
nodiscard
]
]
bool
markEquivalent
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
return
equivalence_
.
put
(
TypePair
:
:
unordered
(
a
b
)
)
;
}
void
unmarkEquivalent
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
equivalence_
.
remove
(
TypePair
:
:
unordered
(
a
b
)
)
;
}
bool
isEquivalent
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
return
equivalence_
.
has
(
TypePair
:
:
unordered
(
a
b
)
)
;
}
[
[
nodiscard
]
]
bool
markSubtypeOf
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
return
subtype_
.
put
(
TypePair
:
:
ordered
(
a
b
)
)
;
}
void
unmarkSubtypeOf
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
subtype_
.
remove
(
TypePair
:
:
ordered
(
a
b
)
)
;
}
bool
isSubtypeOf
(
const
TypeDef
*
a
const
TypeDef
*
b
)
{
return
subtype_
.
has
(
TypePair
:
:
ordered
(
a
b
)
)
;
}
}
;
enum
class
TypeResult
{
True
False
OOM
}
;
class
TypeContext
:
public
AtomicRefCounted
<
TypeContext
>
{
FeatureArgs
features_
;
MutableTypeDefVector
types_
;
TypeDefToModuleIndexMap
moduleIndices_
;
public
:
TypeContext
(
)
=
default
;
explicit
TypeContext
(
const
FeatureArgs
&
features
)
:
features_
(
features
)
{
}
size_t
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
types_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
moduleIndices_
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
}
TypeContext
(
const
TypeContext
&
)
=
delete
;
TypeContext
&
operator
=
(
const
TypeContext
&
)
=
delete
;
TypeContext
(
TypeContext
&
&
)
=
delete
;
TypeContext
&
operator
=
(
TypeContext
&
&
)
=
delete
;
[
[
nodiscard
]
]
MutableTypeDef
addType
(
)
{
MutableTypeDef
typeDef
=
js_new
<
TypeDef
>
(
)
;
if
(
!
typeDef
|
|
!
types_
.
append
(
typeDef
)
|
|
!
moduleIndices_
.
put
(
typeDef
.
get
(
)
types_
.
length
(
)
)
)
{
return
nullptr
;
}
return
typeDef
;
}
[
[
nodiscard
]
]
bool
addTypes
(
uint32_t
length
)
{
for
(
uint32_t
typeIndex
=
0
;
typeIndex
<
length
;
typeIndex
+
+
)
{
if
(
!
addType
(
)
)
{
return
false
;
}
}
return
true
;
}
TypeDef
&
type
(
uint32_t
index
)
{
return
*
types_
[
index
]
;
}
const
TypeDef
&
type
(
uint32_t
index
)
const
{
return
*
types_
[
index
]
;
}
TypeDef
&
operator
[
]
(
uint32_t
index
)
{
return
*
types_
[
index
]
;
}
const
TypeDef
&
operator
[
]
(
uint32_t
index
)
const
{
return
*
types_
[
index
]
;
}
bool
empty
(
)
const
{
return
types_
.
empty
(
)
;
}
uint32_t
length
(
)
const
{
return
types_
.
length
(
)
;
}
uint32_t
indexOf
(
const
TypeDef
&
typeDef
)
const
{
auto
moduleIndex
=
moduleIndices_
.
readonlyThreadsafeLookup
(
&
typeDef
)
;
MOZ_RELEASE_ASSERT
(
moduleIndex
.
found
(
)
)
;
return
moduleIndex
-
>
value
(
)
;
}
template
<
class
T
>
TypeResult
isEquivalent
(
T
first
T
second
TypeCache
*
cache
)
const
{
if
(
first
=
=
second
)
{
return
TypeResult
:
:
True
;
}
if
(
first
.
isRefType
(
)
&
&
second
.
isRefType
(
)
)
{
return
isRefEquivalent
(
first
.
refType
(
)
second
.
refType
(
)
cache
)
;
}
return
TypeResult
:
:
False
;
}
TypeResult
isRefEquivalent
(
RefType
first
RefType
second
TypeCache
*
cache
)
const
;
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
TypeResult
isTypeDefEquivalent
(
const
TypeDef
*
first
const
TypeDef
*
second
TypeCache
*
cache
)
const
;
#
endif
#
ifdef
ENABLE_WASM_GC
TypeResult
isStructEquivalent
(
const
TypeDef
*
first
const
TypeDef
*
second
TypeCache
*
cache
)
const
;
TypeResult
isStructFieldEquivalent
(
const
StructField
first
const
StructField
second
TypeCache
*
cache
)
const
;
TypeResult
isArrayEquivalent
(
const
TypeDef
*
first
const
TypeDef
*
second
TypeCache
*
cache
)
const
;
TypeResult
isArrayElementEquivalent
(
const
ArrayType
&
first
const
ArrayType
&
second
TypeCache
*
cache
)
const
;
#
endif
template
<
class
T
>
TypeResult
isSubtypeOf
(
T
subType
T
superType
TypeCache
*
cache
)
const
{
if
(
subType
=
=
superType
)
{
return
TypeResult
:
:
True
;
}
if
(
subType
.
isRefType
(
)
&
&
superType
.
isRefType
(
)
)
{
return
isRefSubtypeOf
(
subType
.
refType
(
)
superType
.
refType
(
)
cache
)
;
}
return
TypeResult
:
:
False
;
}
TypeResult
isRefSubtypeOf
(
RefType
subType
RefType
superType
TypeCache
*
cache
)
const
;
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
TypeResult
isTypeDefSubtypeOf
(
const
TypeDef
*
subType
const
TypeDef
*
superType
TypeCache
*
cache
)
const
;
#
endif
#
ifdef
ENABLE_WASM_GC
TypeResult
isStructSubtypeOf
(
const
TypeDef
*
subType
const
TypeDef
*
superType
TypeCache
*
cache
)
const
;
TypeResult
isStructFieldSubtypeOf
(
const
StructField
subType
const
StructField
superType
TypeCache
*
cache
)
const
;
TypeResult
isArraySubtypeOf
(
const
TypeDef
*
subType
const
TypeDef
*
superType
TypeCache
*
cache
)
const
;
TypeResult
isArrayElementSubtypeOf
(
const
ArrayType
&
subType
const
ArrayType
&
superType
TypeCache
*
cache
)
const
;
#
endif
}
;
using
SharedTypeContext
=
RefPtr
<
const
TypeContext
>
;
using
MutableTypeContext
=
RefPtr
<
TypeContext
>
;
class
TypeHandle
{
private
:
SharedTypeContext
context_
;
uint32_t
index_
;
public
:
TypeHandle
(
SharedTypeContext
context
uint32_t
index
)
:
context_
(
context
)
index_
(
index
)
{
MOZ_ASSERT
(
index_
<
context_
-
>
length
(
)
)
;
}
TypeHandle
(
SharedTypeContext
context
const
TypeDef
&
def
)
:
context_
(
context
)
index_
(
context
-
>
indexOf
(
def
)
)
{
}
TypeHandle
(
const
TypeHandle
&
)
=
default
;
TypeHandle
&
operator
=
(
const
TypeHandle
&
)
=
default
;
const
SharedTypeContext
&
context
(
)
const
{
return
context_
;
}
uint32_t
index
(
)
const
{
return
index_
;
}
const
TypeDef
&
def
(
)
const
{
return
context_
-
>
type
(
index_
)
;
}
}
;
}
}
#
endif
