#
ifndef
wasm_type_def_h
#
define
wasm_type_def_h
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
wasm
/
WasmCodegenConstants
.
h
"
#
include
"
wasm
/
WasmCompileArgs
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
#
include
"
wasm
/
WasmUtility
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
namespace
js
{
namespace
wasm
{
using
mozilla
:
:
CheckedInt32
;
using
mozilla
:
:
MallocSizeOf
;
class
FuncType
{
ValTypeVector
args_
;
ValTypeVector
results_
;
bool
temporarilyUnsupportedResultCountForJitEntry
(
)
const
{
return
results
(
)
.
length
(
)
>
MaxResultsForJitEntry
;
}
bool
temporarilyUnsupportedResultCountForJitExit
(
)
const
{
return
results
(
)
.
length
(
)
>
MaxResultsForJitExit
;
}
bool
temporarilyUnsupportedReftypeForEntry
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
isRefType
(
)
&
&
(
!
arg
.
isExternRef
(
)
|
|
!
arg
.
isNullable
(
)
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isTypeIndex
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
temporarilyUnsupportedReftypeForExit
(
)
const
{
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isRefType
(
)
&
&
(
!
result
.
isExternRef
(
)
|
|
!
result
.
isNullable
(
)
)
)
{
return
true
;
}
}
return
false
;
}
public
:
FuncType
(
)
:
args_
(
)
results_
(
)
{
}
FuncType
(
ValTypeVector
&
&
args
ValTypeVector
&
&
results
)
:
args_
(
std
:
:
move
(
args
)
)
results_
(
std
:
:
move
(
results
)
)
{
}
[
[
nodiscard
]
]
bool
clone
(
const
FuncType
&
src
)
{
MOZ_ASSERT
(
args_
.
empty
(
)
)
;
MOZ_ASSERT
(
results_
.
empty
(
)
)
;
return
args_
.
appendAll
(
src
.
args_
)
&
&
results_
.
appendAll
(
src
.
results_
)
;
}
void
renumber
(
const
RenumberVector
&
renumbering
)
{
for
(
auto
&
arg
:
args_
)
{
arg
.
renumber
(
renumbering
)
;
}
for
(
auto
&
result
:
results_
)
{
result
.
renumber
(
renumbering
)
;
}
}
ValType
arg
(
unsigned
i
)
const
{
return
args_
[
i
]
;
}
const
ValTypeVector
&
args
(
)
const
{
return
args_
;
}
ValType
result
(
unsigned
i
)
const
{
return
results_
[
i
]
;
}
const
ValTypeVector
&
results
(
)
const
{
return
results_
;
}
HashNumber
hash
(
)
const
{
HashNumber
hn
=
0
;
for
(
const
ValType
&
vt
:
args_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
vt
.
packed
(
)
.
bits
(
)
)
)
;
}
for
(
const
ValType
&
vt
:
results_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
vt
.
packed
(
)
.
bits
(
)
)
)
;
}
return
hn
;
}
bool
operator
=
=
(
const
FuncType
&
rhs
)
const
{
return
EqualContainers
(
args
(
)
rhs
.
args
(
)
)
&
&
EqualContainers
(
results
(
)
rhs
.
results
(
)
)
;
}
bool
operator
!
=
(
const
FuncType
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
canHaveJitEntry
(
)
const
;
bool
canHaveJitExit
(
)
const
;
bool
hasInt64Arg
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
kind
(
)
=
=
ValType
:
:
Kind
:
:
I64
)
{
return
true
;
}
}
return
false
;
}
bool
hasUnexposableArgOrRet
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
!
arg
.
isExposable
(
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
!
result
.
isExposable
(
)
)
{
return
true
;
}
}
return
false
;
}
#
ifdef
WASM_PRIVATE_REFTYPES
bool
exposesTypeIndex
(
)
const
{
for
(
const
ValType
&
arg
:
args
(
)
)
{
if
(
arg
.
isTypeIndex
(
)
)
{
return
true
;
}
}
for
(
const
ValType
&
result
:
results
(
)
)
{
if
(
result
.
isTypeIndex
(
)
)
{
return
true
;
}
}
return
false
;
}
#
endif
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
struct
FuncTypeHashPolicy
{
using
Lookup
=
const
FuncType
&
;
static
HashNumber
hash
(
Lookup
ft
)
{
return
ft
.
hash
(
)
;
}
static
bool
match
(
const
FuncType
*
lhs
Lookup
rhs
)
{
return
*
lhs
=
=
rhs
;
}
}
;
struct
StructField
{
FieldType
type
;
uint32_t
offset
;
bool
isMutable
;
WASM_CHECK_CACHEABLE_POD
(
type
offset
isMutable
)
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
StructField
)
;
using
StructFieldVector
=
Vector
<
StructField
0
SystemAllocPolicy
>
;
class
StructType
{
public
:
StructFieldVector
fields_
;
uint32_t
size_
;
public
:
StructType
(
)
:
fields_
(
)
size_
(
0
)
{
}
explicit
StructType
(
StructFieldVector
&
&
fields
)
:
fields_
(
std
:
:
move
(
fields
)
)
size_
(
0
)
{
}
StructType
(
StructType
&
&
)
=
default
;
StructType
&
operator
=
(
StructType
&
&
)
=
default
;
[
[
nodiscard
]
]
bool
clone
(
const
StructType
&
src
)
{
if
(
!
fields_
.
appendAll
(
src
.
fields_
)
)
{
return
false
;
}
size_
=
src
.
size_
;
return
true
;
}
void
renumber
(
const
RenumberVector
&
renumbering
)
{
for
(
auto
&
field
:
fields_
)
{
field
.
type
.
renumber
(
renumbering
)
;
}
}
bool
isDefaultable
(
)
const
{
for
(
auto
&
field
:
fields_
)
{
if
(
!
field
.
type
.
isDefaultable
(
)
)
{
return
false
;
}
}
return
true
;
}
[
[
nodiscard
]
]
bool
computeLayout
(
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
StructTypeVector
=
Vector
<
StructType
0
SystemAllocPolicy
>
;
using
StructTypePtrVector
=
Vector
<
const
StructType
*
0
SystemAllocPolicy
>
;
class
StructLayout
{
CheckedInt32
sizeSoFar
=
0
;
uint32_t
structAlignment
=
1
;
public
:
CheckedInt32
addField
(
FieldType
type
)
;
CheckedInt32
close
(
)
;
}
;
class
ArrayType
{
public
:
FieldType
elementType_
;
bool
isMutable_
;
WASM_CHECK_CACHEABLE_POD
(
elementType_
isMutable_
)
;
public
:
ArrayType
(
FieldType
elementType
bool
isMutable
)
:
elementType_
(
elementType
)
isMutable_
(
isMutable
)
{
}
ArrayType
(
const
ArrayType
&
)
=
default
;
ArrayType
&
operator
=
(
const
ArrayType
&
)
=
default
;
ArrayType
(
ArrayType
&
&
)
=
default
;
ArrayType
&
operator
=
(
ArrayType
&
&
)
=
default
;
[
[
nodiscard
]
]
bool
clone
(
const
ArrayType
&
src
)
{
elementType_
=
src
.
elementType_
;
isMutable_
=
src
.
isMutable_
;
return
true
;
}
void
renumber
(
const
RenumberVector
&
renumbering
)
{
elementType_
.
renumber
(
renumbering
)
;
}
bool
isDefaultable
(
)
const
{
return
elementType_
.
isDefaultable
(
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
ArrayType
)
;
using
ArrayTypeVector
=
Vector
<
ArrayType
0
SystemAllocPolicy
>
;
using
ArrayTypePtrVector
=
Vector
<
const
ArrayType
*
0
SystemAllocPolicy
>
;
enum
class
TypeDefKind
:
uint8_t
{
None
=
0
Func
Struct
Array
}
;
class
TypeDef
{
TypeDefKind
kind_
;
union
{
FuncType
funcType_
;
StructType
structType_
;
ArrayType
arrayType_
;
}
;
public
:
TypeDef
(
)
:
kind_
(
TypeDefKind
:
:
None
)
{
}
explicit
TypeDef
(
FuncType
&
&
funcType
)
:
kind_
(
TypeDefKind
:
:
Func
)
funcType_
(
std
:
:
move
(
funcType
)
)
{
}
explicit
TypeDef
(
StructType
&
&
structType
)
:
kind_
(
TypeDefKind
:
:
Struct
)
structType_
(
std
:
:
move
(
structType
)
)
{
}
explicit
TypeDef
(
ArrayType
&
&
arrayType
)
:
kind_
(
TypeDefKind
:
:
Array
)
arrayType_
(
std
:
:
move
(
arrayType
)
)
{
}
TypeDef
(
TypeDef
&
&
td
)
noexcept
:
kind_
(
td
.
kind_
)
{
switch
(
kind_
)
{
case
TypeDefKind
:
:
Func
:
new
(
&
funcType_
)
FuncType
(
std
:
:
move
(
td
.
funcType_
)
)
;
break
;
case
TypeDefKind
:
:
Struct
:
new
(
&
structType_
)
StructType
(
std
:
:
move
(
td
.
structType_
)
)
;
break
;
case
TypeDefKind
:
:
Array
:
new
(
&
arrayType_
)
ArrayType
(
std
:
:
move
(
td
.
arrayType_
)
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
}
~
TypeDef
(
)
{
switch
(
kind_
)
{
case
TypeDefKind
:
:
Func
:
funcType_
.
~
FuncType
(
)
;
break
;
case
TypeDefKind
:
:
Struct
:
structType_
.
~
StructType
(
)
;
break
;
case
TypeDefKind
:
:
Array
:
arrayType_
.
~
ArrayType
(
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
}
TypeDef
&
operator
=
(
TypeDef
&
&
that
)
noexcept
{
MOZ_ASSERT
(
isNone
(
)
)
;
switch
(
that
.
kind_
)
{
case
TypeDefKind
:
:
Func
:
new
(
&
funcType_
)
FuncType
(
std
:
:
move
(
that
.
funcType_
)
)
;
break
;
case
TypeDefKind
:
:
Struct
:
new
(
&
structType_
)
StructType
(
std
:
:
move
(
that
.
structType_
)
)
;
break
;
case
TypeDefKind
:
:
Array
:
new
(
&
arrayType_
)
ArrayType
(
std
:
:
move
(
that
.
arrayType_
)
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
kind_
=
that
.
kind_
;
return
*
this
;
}
[
[
nodiscard
]
]
bool
clone
(
const
TypeDef
&
src
)
{
MOZ_ASSERT
(
isNone
(
)
)
;
kind_
=
src
.
kind_
;
switch
(
src
.
kind_
)
{
case
TypeDefKind
:
:
Func
:
new
(
&
funcType_
)
FuncType
(
)
;
return
funcType_
.
clone
(
src
.
funcType
(
)
)
;
case
TypeDefKind
:
:
Struct
:
new
(
&
structType_
)
StructType
(
)
;
return
structType_
.
clone
(
src
.
structType
(
)
)
;
case
TypeDefKind
:
:
Array
:
new
(
&
arrayType_
)
ArrayType
(
src
.
arrayType
(
)
)
;
return
true
;
case
TypeDefKind
:
:
None
:
break
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
false
;
}
TypeDefKind
kind
(
)
const
{
return
kind_
;
}
bool
isNone
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
None
;
}
bool
isFuncType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Func
;
}
bool
isStructType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Struct
;
}
bool
isArrayType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Array
;
}
const
FuncType
&
funcType
(
)
const
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
FuncType
&
funcType
(
)
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
const
StructType
&
structType
(
)
const
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
StructType
&
structType
(
)
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
const
ArrayType
&
arrayType
(
)
const
{
MOZ_ASSERT
(
isArrayType
(
)
)
;
return
arrayType_
;
}
ArrayType
&
arrayType
(
)
{
MOZ_ASSERT
(
isArrayType
(
)
)
;
return
arrayType_
;
}
void
renumber
(
const
RenumberVector
&
renumbering
)
{
switch
(
kind_
)
{
case
TypeDefKind
:
:
Func
:
funcType_
.
renumber
(
renumbering
)
;
break
;
case
TypeDefKind
:
:
Struct
:
structType_
.
renumber
(
renumbering
)
;
break
;
case
TypeDefKind
:
:
Array
:
arrayType_
.
renumber
(
renumbering
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
TypeDefVector
=
Vector
<
TypeDef
0
SystemAllocPolicy
>
;
template
<
typename
T
>
using
DerivedTypeDefVector
=
Vector
<
T
0
SystemAllocPolicy
>
;
class
TypeCache
{
using
TypeIndex
=
uint32_t
;
using
TypePair
=
uint64_t
;
using
TypeSet
=
HashSet
<
TypePair
DefaultHasher
<
TypePair
>
SystemAllocPolicy
>
;
static
constexpr
TypePair
makeOrderedPair
(
TypeIndex
a
TypeIndex
b
)
{
return
(
TypePair
(
a
)
<
<
32
)
|
TypePair
(
b
)
;
}
static
constexpr
TypePair
makeUnorderedPair
(
TypeIndex
a
TypeIndex
b
)
{
if
(
a
<
b
)
{
return
(
TypePair
(
a
)
<
<
32
)
|
TypePair
(
b
)
;
}
return
(
TypePair
(
b
)
<
<
32
)
|
TypePair
(
a
)
;
}
TypeSet
equivalence_
;
TypeSet
subtype_
;
public
:
TypeCache
(
)
=
default
;
[
[
nodiscard
]
]
bool
markEquivalent
(
TypeIndex
a
TypeIndex
b
)
{
return
equivalence_
.
put
(
makeUnorderedPair
(
a
b
)
)
;
}
void
unmarkEquivalent
(
TypeIndex
a
TypeIndex
b
)
{
equivalence_
.
remove
(
makeUnorderedPair
(
a
b
)
)
;
}
bool
isEquivalent
(
TypeIndex
a
TypeIndex
b
)
{
return
equivalence_
.
has
(
makeUnorderedPair
(
a
b
)
)
;
}
[
[
nodiscard
]
]
bool
markSubtypeOf
(
TypeIndex
a
TypeIndex
b
)
{
return
subtype_
.
put
(
makeOrderedPair
(
a
b
)
)
;
}
void
unmarkSubtypeOf
(
TypeIndex
a
TypeIndex
b
)
{
subtype_
.
remove
(
makeOrderedPair
(
a
b
)
)
;
}
bool
isSubtypeOf
(
TypeIndex
a
TypeIndex
b
)
{
return
subtype_
.
has
(
makeOrderedPair
(
a
b
)
)
;
}
}
;
enum
class
TypeResult
{
True
False
OOM
}
;
class
TypeContext
:
public
AtomicRefCounted
<
TypeContext
>
{
FeatureArgs
features_
;
TypeDefVector
types_
;
public
:
TypeContext
(
)
=
default
;
TypeContext
(
const
FeatureArgs
&
features
TypeDefVector
&
&
types
)
:
features_
(
features
)
types_
(
std
:
:
move
(
types
)
)
{
}
template
<
typename
T
>
[
[
nodiscard
]
]
bool
cloneDerived
(
const
DerivedTypeDefVector
<
T
>
&
source
)
{
MOZ_ASSERT
(
types_
.
length
(
)
=
=
0
)
;
if
(
!
types_
.
resize
(
source
.
length
(
)
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
source
.
length
(
)
;
i
+
+
)
{
if
(
!
types_
[
i
]
.
clone
(
source
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
size_t
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
types_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
TypeContext
(
const
TypeContext
&
)
=
delete
;
TypeContext
&
operator
=
(
const
TypeContext
&
)
=
delete
;
TypeContext
(
TypeContext
&
&
)
=
delete
;
TypeContext
&
operator
=
(
TypeContext
&
&
)
=
delete
;
TypeDef
&
type
(
uint32_t
index
)
{
return
types_
[
index
]
;
}
const
TypeDef
&
type
(
uint32_t
index
)
const
{
return
types_
[
index
]
;
}
TypeDef
&
operator
[
]
(
uint32_t
index
)
{
return
types_
[
index
]
;
}
const
TypeDef
&
operator
[
]
(
uint32_t
index
)
const
{
return
types_
[
index
]
;
}
uint32_t
length
(
)
const
{
return
types_
.
length
(
)
;
}
template
<
typename
U
>
[
[
nodiscard
]
]
bool
append
(
U
&
&
typeDef
)
{
return
types_
.
append
(
std
:
:
forward
<
U
>
(
typeDef
)
)
;
}
[
[
nodiscard
]
]
bool
resize
(
uint32_t
length
)
{
return
types_
.
resize
(
length
)
;
}
uint32_t
indexOf
(
const
TypeDef
&
typeDef
)
const
{
const
TypeDef
*
elem
=
&
typeDef
;
MOZ_ASSERT
(
elem
>
=
types_
.
begin
(
)
&
&
elem
<
types_
.
end
(
)
)
;
return
elem
-
types_
.
begin
(
)
;
}
bool
isFuncType
(
uint32_t
index
)
const
{
return
types_
[
index
]
.
isFuncType
(
)
;
}
bool
isFuncType
(
RefType
t
)
const
{
return
t
.
isTypeIndex
(
)
&
&
isFuncType
(
t
.
typeIndex
(
)
)
;
}
FuncType
&
funcType
(
uint32_t
index
)
{
return
types_
[
index
]
.
funcType
(
)
;
}
const
FuncType
&
funcType
(
uint32_t
index
)
const
{
return
types_
[
index
]
.
funcType
(
)
;
}
FuncType
&
funcType
(
RefType
t
)
{
return
funcType
(
t
.
typeIndex
(
)
)
;
}
const
FuncType
&
funcType
(
RefType
t
)
const
{
return
funcType
(
t
.
typeIndex
(
)
)
;
}
bool
isStructType
(
uint32_t
index
)
const
{
return
types_
[
index
]
.
isStructType
(
)
;
}
bool
isStructType
(
RefType
t
)
const
{
return
t
.
isTypeIndex
(
)
&
&
isStructType
(
t
.
typeIndex
(
)
)
;
}
StructType
&
structType
(
uint32_t
index
)
{
return
types_
[
index
]
.
structType
(
)
;
}
const
StructType
&
structType
(
uint32_t
index
)
const
{
return
types_
[
index
]
.
structType
(
)
;
}
StructType
&
structType
(
RefType
t
)
{
return
structType
(
t
.
typeIndex
(
)
)
;
}
const
StructType
&
structType
(
RefType
t
)
const
{
return
structType
(
t
.
typeIndex
(
)
)
;
}
bool
isArrayType
(
uint32_t
index
)
const
{
return
types_
[
index
]
.
isArrayType
(
)
;
}
bool
isArrayType
(
RefType
t
)
const
{
return
t
.
isTypeIndex
(
)
&
&
isArrayType
(
t
.
typeIndex
(
)
)
;
}
ArrayType
&
arrayType
(
uint32_t
index
)
{
return
types_
[
index
]
.
arrayType
(
)
;
}
const
ArrayType
&
arrayType
(
uint32_t
index
)
const
{
return
types_
[
index
]
.
arrayType
(
)
;
}
ArrayType
&
arrayType
(
RefType
t
)
{
return
arrayType
(
t
.
typeIndex
(
)
)
;
}
const
ArrayType
&
arrayType
(
RefType
t
)
const
{
return
arrayType
(
t
.
typeIndex
(
)
)
;
}
template
<
class
T
>
TypeResult
isEquivalent
(
T
first
T
second
TypeCache
*
cache
)
const
{
if
(
first
=
=
second
)
{
return
TypeResult
:
:
True
;
}
if
(
first
.
isRefType
(
)
&
&
second
.
isRefType
(
)
)
{
return
isRefEquivalent
(
first
.
refType
(
)
second
.
refType
(
)
cache
)
;
}
#
ifdef
ENABLE_WASM_GC
if
(
first
.
isRtt
(
)
&
&
second
.
isRtt
(
)
)
{
if
(
first
.
hasRttDepth
(
)
!
=
second
.
hasRttDepth
(
)
)
{
return
TypeResult
:
:
False
;
}
if
(
second
.
hasRttDepth
(
)
&
&
first
.
rttDepth
(
)
!
=
second
.
rttDepth
(
)
)
{
return
TypeResult
:
:
False
;
}
return
isTypeIndexEquivalent
(
first
.
typeIndex
(
)
second
.
typeIndex
(
)
cache
)
;
}
#
endif
return
TypeResult
:
:
False
;
}
TypeResult
isRefEquivalent
(
RefType
first
RefType
second
TypeCache
*
cache
)
const
;
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
TypeResult
isTypeIndexEquivalent
(
uint32_t
firstIndex
uint32_t
secondIndex
TypeCache
*
cache
)
const
;
#
endif
#
ifdef
ENABLE_WASM_GC
TypeResult
isStructEquivalent
(
uint32_t
firstIndex
uint32_t
secondIndex
TypeCache
*
cache
)
const
;
TypeResult
isStructFieldEquivalent
(
const
StructField
first
const
StructField
second
TypeCache
*
cache
)
const
;
TypeResult
isArrayEquivalent
(
uint32_t
firstIndex
uint32_t
secondIndex
TypeCache
*
cache
)
const
;
TypeResult
isArrayElementEquivalent
(
const
ArrayType
&
first
const
ArrayType
&
second
TypeCache
*
cache
)
const
;
#
endif
template
<
class
T
>
TypeResult
isSubtypeOf
(
T
subType
T
superType
TypeCache
*
cache
)
const
{
if
(
subType
=
=
superType
)
{
return
TypeResult
:
:
True
;
}
if
(
subType
.
isRefType
(
)
&
&
superType
.
isRefType
(
)
)
{
return
isRefSubtypeOf
(
subType
.
refType
(
)
superType
.
refType
(
)
cache
)
;
}
#
ifdef
ENABLE_WASM_GC
if
(
subType
.
isRtt
(
)
&
&
superType
.
isRtt
(
)
)
{
if
(
!
subType
.
hasRttDepth
(
)
&
&
superType
.
hasRttDepth
(
)
)
{
return
TypeResult
:
:
False
;
}
if
(
superType
.
hasRttDepth
(
)
&
&
subType
.
rttDepth
(
)
!
=
superType
.
rttDepth
(
)
)
{
return
TypeResult
:
:
False
;
}
return
isTypeIndexEquivalent
(
subType
.
typeIndex
(
)
superType
.
typeIndex
(
)
cache
)
;
}
#
endif
return
TypeResult
:
:
False
;
}
TypeResult
isRefSubtypeOf
(
RefType
subType
RefType
superType
TypeCache
*
cache
)
const
;
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
TypeResult
isTypeIndexSubtypeOf
(
uint32_t
subTypeIndex
uint32_t
superTypeIndex
TypeCache
*
cache
)
const
;
#
endif
#
ifdef
ENABLE_WASM_GC
TypeResult
isStructSubtypeOf
(
uint32_t
subTypeIndex
uint32_t
superTypeIndex
TypeCache
*
cache
)
const
;
TypeResult
isStructFieldSubtypeOf
(
const
StructField
subType
const
StructField
superType
TypeCache
*
cache
)
const
;
TypeResult
isArraySubtypeOf
(
uint32_t
subTypeIndex
uint32_t
superTypeIndex
TypeCache
*
cache
)
const
;
TypeResult
isArrayElementSubtypeOf
(
const
ArrayType
&
subType
const
ArrayType
&
superType
TypeCache
*
cache
)
const
;
#
endif
}
;
using
SharedTypeContext
=
RefPtr
<
const
TypeContext
>
;
using
MutableTypeContext
=
RefPtr
<
TypeContext
>
;
class
TypeHandle
{
private
:
SharedTypeContext
context_
;
uint32_t
index_
;
public
:
TypeHandle
(
SharedTypeContext
context
uint32_t
index
)
:
context_
(
context
)
index_
(
index
)
{
MOZ_ASSERT
(
index_
<
context_
-
>
length
(
)
)
;
}
TypeHandle
(
SharedTypeContext
context
const
TypeDef
&
def
)
:
context_
(
context
)
index_
(
context
-
>
indexOf
(
def
)
)
{
}
TypeHandle
(
const
TypeHandle
&
)
=
default
;
TypeHandle
&
operator
=
(
const
TypeHandle
&
)
=
default
;
const
SharedTypeContext
&
context
(
)
const
{
return
context_
;
}
uint32_t
index
(
)
const
{
return
index_
;
}
const
TypeDef
&
def
(
)
const
{
return
context_
-
>
type
(
index_
)
;
}
}
;
class
TypeIdDesc
{
public
:
static
const
uintptr_t
ImmediateBit
=
0x1
;
private
:
TypeIdDescKind
kind_
;
size_t
bits_
;
WASM_CHECK_CACHEABLE_POD
(
kind_
bits_
)
;
TypeIdDesc
(
TypeIdDescKind
kind
size_t
bits
)
:
kind_
(
kind
)
bits_
(
bits
)
{
}
public
:
TypeIdDescKind
kind
(
)
const
{
return
kind_
;
}
static
bool
isGlobal
(
const
TypeDef
&
type
)
;
TypeIdDesc
(
)
:
kind_
(
TypeIdDescKind
:
:
None
)
bits_
(
0
)
{
}
static
TypeIdDesc
global
(
const
TypeDef
&
type
uint32_t
globalDataOffset
)
;
static
TypeIdDesc
immediate
(
const
TypeDef
&
type
)
;
bool
isGlobal
(
)
const
{
return
kind_
=
=
TypeIdDescKind
:
:
Global
;
}
uint32_t
immediate
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
TypeIdDescKind
:
:
Immediate
)
;
return
bits_
;
}
uint32_t
globalDataOffset
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
TypeIdDescKind
:
:
Global
)
;
return
bits_
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
TypeIdDesc
)
;
using
TypeIdDescVector
=
Vector
<
TypeIdDesc
0
SystemAllocPolicy
>
;
struct
TypeDefWithId
:
public
TypeDef
{
TypeIdDesc
id
;
TypeDefWithId
(
)
=
default
;
explicit
TypeDefWithId
(
TypeDef
&
&
typeDef
)
:
TypeDef
(
std
:
:
move
(
typeDef
)
)
id
(
)
{
}
TypeDefWithId
(
TypeDef
&
&
typeDef
TypeIdDesc
id
)
:
TypeDef
(
std
:
:
move
(
typeDef
)
)
id
(
id
)
{
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
TypeDefWithIdVector
=
Vector
<
TypeDefWithId
0
SystemAllocPolicy
>
;
using
TypeDefWithIdPtrVector
=
Vector
<
const
TypeDefWithId
*
0
SystemAllocPolicy
>
;
}
}
#
endif
