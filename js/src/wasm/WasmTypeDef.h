#
ifndef
wasm_type_def_h
#
define
wasm_type_def_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
js
/
RefCounted
.
h
"
#
include
"
wasm
/
WasmCodegenConstants
.
h
"
#
include
"
wasm
/
WasmCompileArgs
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
#
include
"
wasm
/
WasmUtility
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
namespace
js
{
namespace
wasm
{
class
RecGroup
;
class
FuncType
{
ValTypeVector
args_
;
ValTypeVector
results_
;
uint32_t
immediateTypeId_
=
NO_IMMEDIATE_TYPE_ID
;
static
const
uint32_t
NO_IMMEDIATE_TYPE_ID
=
UINT32_MAX
;
bool
temporarilyUnsupportedResultCountForJitEntry
(
)
const
{
return
results
(
)
.
length
(
)
>
MaxResultsForJitEntry
;
}
bool
temporarilyUnsupportedResultCountForJitExit
(
)
const
{
return
results
(
)
.
length
(
)
>
MaxResultsForJitExit
;
}
bool
temporarilyUnsupportedReftypeForEntry
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
isRefType
(
)
&
&
(
!
arg
.
isExternRef
(
)
|
|
!
arg
.
isNullable
(
)
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isTypeRef
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
temporarilyUnsupportedReftypeForExit
(
)
const
{
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isRefType
(
)
&
&
(
!
result
.
isExternRef
(
)
|
|
!
result
.
isNullable
(
)
)
)
{
return
true
;
}
}
return
false
;
}
public
:
FuncType
(
)
=
default
;
FuncType
(
ValTypeVector
&
&
args
ValTypeVector
&
&
results
)
:
args_
(
std
:
:
move
(
args
)
)
results_
(
std
:
:
move
(
results
)
)
{
}
FuncType
(
FuncType
&
&
)
=
default
;
FuncType
&
operator
=
(
FuncType
&
&
)
=
default
;
[
[
nodiscard
]
]
bool
clone
(
const
FuncType
&
src
)
{
MOZ_ASSERT
(
args_
.
empty
(
)
)
;
MOZ_ASSERT
(
results_
.
empty
(
)
)
;
immediateTypeId_
=
src
.
immediateTypeId_
;
return
args_
.
appendAll
(
src
.
args_
)
&
&
results_
.
appendAll
(
src
.
results_
)
;
}
ValType
arg
(
unsigned
i
)
const
{
return
args_
[
i
]
;
}
const
ValTypeVector
&
args
(
)
const
{
return
args_
;
}
ValType
result
(
unsigned
i
)
const
{
return
results_
[
i
]
;
}
const
ValTypeVector
&
results
(
)
const
{
return
results_
;
}
void
initImmediateTypeId
(
bool
gcEnabled
bool
isFinal
const
TypeDef
*
superTypeDef
uint32_t
recGroupLength
)
;
bool
hasImmediateTypeId
(
)
const
{
return
immediateTypeId_
!
=
NO_IMMEDIATE_TYPE_ID
;
}
uint32_t
immediateTypeId
(
)
const
{
MOZ_ASSERT
(
hasImmediateTypeId
(
)
)
;
return
immediateTypeId_
;
}
static
const
uint32_t
ImmediateBit
=
0x1
;
HashNumber
hash
(
const
RecGroup
*
recGroup
)
const
{
HashNumber
hn
=
0
;
for
(
const
ValType
&
vt
:
args_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
vt
.
forMatch
(
recGroup
)
.
hash
(
)
)
;
}
for
(
const
ValType
&
vt
:
results_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
vt
.
forMatch
(
recGroup
)
.
hash
(
)
)
;
}
return
hn
;
}
static
bool
matches
(
const
RecGroup
*
lhsRecGroup
const
FuncType
&
lhs
const
RecGroup
*
rhsRecGroup
const
FuncType
&
rhs
)
{
if
(
lhs
.
args_
.
length
(
)
!
=
rhs
.
args_
.
length
(
)
|
|
lhs
.
results_
.
length
(
)
!
=
rhs
.
results_
.
length
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
lhs
.
args_
.
length
(
)
;
i
+
+
)
{
if
(
lhs
.
args_
[
i
]
.
forMatch
(
lhsRecGroup
)
!
=
rhs
.
args_
[
i
]
.
forMatch
(
rhsRecGroup
)
)
{
return
false
;
}
}
for
(
uint32_t
i
=
0
;
i
<
lhs
.
results_
.
length
(
)
;
i
+
+
)
{
if
(
lhs
.
results_
[
i
]
.
forMatch
(
lhsRecGroup
)
!
=
rhs
.
results_
[
i
]
.
forMatch
(
rhsRecGroup
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
strictlyEquals
(
const
FuncType
&
lhs
const
FuncType
&
rhs
)
{
return
EqualContainers
(
lhs
.
args
(
)
rhs
.
args
(
)
)
&
&
EqualContainers
(
lhs
.
results
(
)
rhs
.
results
(
)
)
;
}
static
bool
canBeSubTypeOf
(
const
FuncType
&
subType
const
FuncType
&
superType
)
{
if
(
subType
.
args
(
)
.
length
(
)
!
=
superType
.
args
(
)
.
length
(
)
)
{
return
false
;
}
if
(
subType
.
results
(
)
.
length
(
)
!
=
superType
.
results
(
)
.
length
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
superType
.
results
(
)
.
length
(
)
;
i
+
+
)
{
if
(
!
ValType
:
:
isSubTypeOf
(
subType
.
results
(
)
[
i
]
superType
.
results
(
)
[
i
]
)
)
{
return
false
;
}
}
for
(
uint32_t
i
=
0
;
i
<
superType
.
args
(
)
.
length
(
)
;
i
+
+
)
{
if
(
!
ValType
:
:
isSubTypeOf
(
superType
.
args
(
)
[
i
]
subType
.
args
(
)
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
bool
canHaveJitEntry
(
)
const
;
bool
canHaveJitExit
(
)
const
;
bool
hasInt64Arg
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
kind
(
)
=
=
ValType
:
:
Kind
:
:
I64
)
{
return
true
;
}
}
return
false
;
}
bool
hasUnexposableArgOrRet
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
!
arg
.
isExposable
(
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
!
result
.
isExposable
(
)
)
{
return
true
;
}
}
return
false
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
FuncType
)
;
}
;
struct
FieldType
{
StorageType
type
;
bool
isMutable
;
FieldType
(
)
:
isMutable
(
false
)
{
}
FieldType
(
StorageType
type
bool
isMutable
)
:
type
(
type
)
isMutable
(
isMutable
)
{
}
HashNumber
hash
(
const
RecGroup
*
recGroup
)
const
{
HashNumber
hn
=
0
;
hn
=
mozilla
:
:
AddToHash
(
hn
type
.
forMatch
(
recGroup
)
.
hash
(
)
)
;
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
isMutable
)
)
;
return
hn
;
}
static
bool
matches
(
const
RecGroup
*
lhsRecGroup
const
FieldType
&
lhs
const
RecGroup
*
rhsRecGroup
const
FieldType
&
rhs
)
{
return
lhs
.
isMutable
=
=
rhs
.
isMutable
&
&
lhs
.
type
.
forMatch
(
lhsRecGroup
)
=
=
rhs
.
type
.
forMatch
(
rhsRecGroup
)
;
}
static
bool
canBeSubTypeOf
(
const
FieldType
&
subType
const
FieldType
&
superType
)
{
if
(
subType
.
isMutable
&
&
superType
.
isMutable
)
{
return
subType
.
type
=
=
superType
.
type
;
}
if
(
!
subType
.
isMutable
&
&
!
superType
.
isMutable
)
{
return
StorageType
:
:
isSubTypeOf
(
subType
.
type
superType
.
type
)
;
}
return
false
;
}
}
;
using
FieldTypeVector
=
Vector
<
FieldType
0
SystemAllocPolicy
>
;
using
FieldOffsetVector
=
Vector
<
uint32_t
2
SystemAllocPolicy
>
;
using
InlineTraceOffsetVector
=
Vector
<
uint32_t
2
SystemAllocPolicy
>
;
using
OutlineTraceOffsetVector
=
Vector
<
uint32_t
0
SystemAllocPolicy
>
;
class
StructType
{
public
:
FieldTypeVector
fields_
;
uint32_t
size_
;
FieldOffsetVector
fieldOffsets_
;
InlineTraceOffsetVector
inlineTraceOffsets_
;
OutlineTraceOffsetVector
outlineTraceOffsets_
;
public
:
StructType
(
)
:
size_
(
0
)
{
}
explicit
StructType
(
FieldTypeVector
&
&
fields
)
:
fields_
(
std
:
:
move
(
fields
)
)
size_
(
0
)
{
}
StructType
(
StructType
&
&
)
=
default
;
StructType
&
operator
=
(
StructType
&
&
)
=
default
;
[
[
nodiscard
]
]
bool
init
(
)
;
bool
isDefaultable
(
)
const
{
for
(
auto
&
field
:
fields_
)
{
if
(
!
field
.
type
.
isDefaultable
(
)
)
{
return
false
;
}
}
return
true
;
}
uint32_t
fieldOffset
(
uint32_t
fieldIndex
)
const
{
return
fieldOffsets_
[
fieldIndex
]
;
}
HashNumber
hash
(
const
RecGroup
*
recGroup
)
const
{
HashNumber
hn
=
0
;
for
(
const
FieldType
&
field
:
fields_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
field
.
hash
(
recGroup
)
)
;
}
return
hn
;
}
static
bool
matches
(
const
RecGroup
*
lhsRecGroup
const
StructType
&
lhs
const
RecGroup
*
rhsRecGroup
const
StructType
&
rhs
)
{
if
(
lhs
.
fields_
.
length
(
)
!
=
rhs
.
fields_
.
length
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
lhs
.
fields_
.
length
(
)
;
i
+
+
)
{
const
FieldType
&
lhsField
=
lhs
.
fields_
[
i
]
;
const
FieldType
&
rhsField
=
rhs
.
fields_
[
i
]
;
if
(
!
FieldType
:
:
matches
(
lhsRecGroup
lhsField
rhsRecGroup
rhsField
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
canBeSubTypeOf
(
const
StructType
&
subType
const
StructType
&
superType
)
{
if
(
subType
.
fields_
.
length
(
)
<
superType
.
fields_
.
length
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
superType
.
fields_
.
length
(
)
;
i
+
+
)
{
if
(
!
FieldType
:
:
canBeSubTypeOf
(
subType
.
fields_
[
i
]
superType
.
fields_
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
createImmutable
(
const
ValTypeVector
&
types
StructType
*
struct_
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
StructType
)
;
}
;
using
StructTypeVector
=
Vector
<
StructType
0
SystemAllocPolicy
>
;
class
StructLayout
{
mozilla
:
:
CheckedInt32
sizeSoFar
=
0
;
uint32_t
structAlignment
=
1
;
public
:
mozilla
:
:
CheckedInt32
addField
(
StorageType
type
)
;
mozilla
:
:
CheckedInt32
close
(
)
;
}
;
class
ArrayType
{
public
:
FieldType
fieldType_
;
public
:
ArrayType
(
)
=
default
;
ArrayType
(
StorageType
elementType
bool
isMutable
)
:
fieldType_
(
FieldType
(
elementType
isMutable
)
)
{
}
ArrayType
(
const
ArrayType
&
)
=
default
;
ArrayType
&
operator
=
(
const
ArrayType
&
)
=
default
;
ArrayType
(
ArrayType
&
&
)
=
default
;
ArrayType
&
operator
=
(
ArrayType
&
&
)
=
default
;
StorageType
elementType
(
)
const
{
return
fieldType_
.
type
;
}
bool
isMutable
(
)
const
{
return
fieldType_
.
isMutable
;
}
bool
isDefaultable
(
)
const
{
return
elementType
(
)
.
isDefaultable
(
)
;
}
HashNumber
hash
(
const
RecGroup
*
recGroup
)
const
{
return
fieldType_
.
hash
(
recGroup
)
;
}
static
bool
matches
(
const
RecGroup
*
lhsRecGroup
const
ArrayType
&
lhs
const
RecGroup
*
rhsRecGroup
const
ArrayType
&
rhs
)
{
return
FieldType
:
:
matches
(
lhsRecGroup
lhs
.
fieldType_
rhsRecGroup
rhs
.
fieldType_
)
;
}
static
bool
canBeSubTypeOf
(
const
ArrayType
&
subType
const
ArrayType
&
superType
)
{
return
FieldType
:
:
canBeSubTypeOf
(
subType
.
fieldType_
superType
.
fieldType_
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
ArrayType
)
;
using
ArrayTypeVector
=
Vector
<
ArrayType
0
SystemAllocPolicy
>
;
class
SuperTypeVector
{
SuperTypeVector
(
)
:
typeDef_
(
nullptr
)
length_
(
0
)
{
}
const
TypeDef
*
typeDef_
;
uint32_t
subTypingDepth_
;
uint32_t
length_
;
public
:
const
SuperTypeVector
*
types_
[
0
]
;
[
[
nodiscard
]
]
static
const
SuperTypeVector
*
createMultipleForRecGroup
(
RecGroup
*
recGroup
)
;
const
TypeDef
*
typeDef
(
)
const
{
return
typeDef_
;
}
uint32_t
length
(
)
const
{
return
length_
;
}
const
SuperTypeVector
*
type
(
size_t
index
)
const
{
MOZ_ASSERT
(
index
<
length_
)
;
return
types_
[
index
]
;
}
static
size_t
lengthForTypeDef
(
const
TypeDef
&
typeDef
)
;
static
size_t
byteSizeForTypeDef
(
const
TypeDef
&
typeDef
)
;
static
size_t
offsetOfSubTypingDepth
(
)
{
return
offsetof
(
SuperTypeVector
subTypingDepth_
)
;
}
static
size_t
offsetOfLength
(
)
{
return
offsetof
(
SuperTypeVector
length_
)
;
}
static
size_t
offsetOfSelfTypeDef
(
)
{
return
offsetof
(
SuperTypeVector
typeDef_
)
;
}
;
static
size_t
offsetOfSTVInVector
(
uint32_t
subTypingDepth
)
;
}
;
static_assert
(
offsetof
(
SuperTypeVector
types_
)
=
=
sizeof
(
SuperTypeVector
)
)
;
enum
class
TypeDefKind
:
uint8_t
{
None
=
0
Func
Struct
Array
}
;
class
TypeDef
{
uint32_t
offsetToRecGroup_
;
const
SuperTypeVector
*
superTypeVector_
;
const
TypeDef
*
superTypeDef_
;
uint16_t
subTypingDepth_
;
bool
isFinal_
;
TypeDefKind
kind_
;
union
{
FuncType
funcType_
;
StructType
structType_
;
ArrayType
arrayType_
;
}
;
void
setRecGroup
(
RecGroup
*
recGroup
)
{
uintptr_t
recGroupAddr
=
(
uintptr_t
)
recGroup
;
uintptr_t
typeDefAddr
=
(
uintptr_t
)
this
;
MOZ_ASSERT
(
typeDefAddr
>
recGroupAddr
)
;
MOZ_ASSERT
(
typeDefAddr
-
recGroupAddr
<
=
UINT32_MAX
)
;
offsetToRecGroup_
=
typeDefAddr
-
recGroupAddr
;
}
public
:
explicit
TypeDef
(
RecGroup
*
recGroup
)
:
offsetToRecGroup_
(
0
)
superTypeVector_
(
nullptr
)
superTypeDef_
(
nullptr
)
subTypingDepth_
(
0
)
isFinal_
(
true
)
kind_
(
TypeDefKind
:
:
None
)
{
setRecGroup
(
recGroup
)
;
}
~
TypeDef
(
)
{
switch
(
kind_
)
{
case
TypeDefKind
:
:
Func
:
funcType_
.
~
FuncType
(
)
;
break
;
case
TypeDefKind
:
:
Struct
:
structType_
.
~
StructType
(
)
;
break
;
case
TypeDefKind
:
:
Array
:
arrayType_
.
~
ArrayType
(
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
}
TypeDef
&
operator
=
(
FuncType
&
&
that
)
noexcept
{
MOZ_ASSERT
(
isNone
(
)
)
;
kind_
=
TypeDefKind
:
:
Func
;
new
(
&
funcType_
)
FuncType
(
std
:
:
move
(
that
)
)
;
return
*
this
;
}
TypeDef
&
operator
=
(
StructType
&
&
that
)
noexcept
{
MOZ_ASSERT
(
isNone
(
)
)
;
kind_
=
TypeDefKind
:
:
Struct
;
new
(
&
structType_
)
StructType
(
std
:
:
move
(
that
)
)
;
return
*
this
;
}
TypeDef
&
operator
=
(
ArrayType
&
&
that
)
noexcept
{
MOZ_ASSERT
(
isNone
(
)
)
;
kind_
=
TypeDefKind
:
:
Array
;
new
(
&
arrayType_
)
ArrayType
(
std
:
:
move
(
that
)
)
;
return
*
this
;
}
const
SuperTypeVector
*
superTypeVector
(
)
const
{
return
superTypeVector_
;
}
void
setSuperTypeVector
(
const
SuperTypeVector
*
superTypeVector
)
{
superTypeVector_
=
superTypeVector
;
}
static
size_t
offsetOfKind
(
)
{
return
offsetof
(
TypeDef
kind_
)
;
}
static
size_t
offsetOfSuperTypeVector
(
)
{
return
offsetof
(
TypeDef
superTypeVector_
)
;
}
static
size_t
offsetOfSubTypingDepth
(
)
{
return
offsetof
(
TypeDef
subTypingDepth_
)
;
}
const
TypeDef
*
superTypeDef
(
)
const
{
return
superTypeDef_
;
}
bool
isFinal
(
)
const
{
return
isFinal_
;
}
uint16_t
subTypingDepth
(
)
const
{
return
subTypingDepth_
;
}
const
RecGroup
&
recGroup
(
)
const
{
uintptr_t
typeDefAddr
=
(
uintptr_t
)
this
;
uintptr_t
recGroupAddr
=
typeDefAddr
-
offsetToRecGroup_
;
return
*
(
const
RecGroup
*
)
recGroupAddr
;
}
TypeDefKind
kind
(
)
const
{
return
kind_
;
}
bool
isNone
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
None
;
}
bool
isFuncType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Func
;
}
bool
isStructType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Struct
;
}
bool
isArrayType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Array
;
}
const
FuncType
&
funcType
(
)
const
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
FuncType
&
funcType
(
)
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
const
StructType
&
structType
(
)
const
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
StructType
&
structType
(
)
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
const
ArrayType
&
arrayType
(
)
const
{
MOZ_ASSERT
(
isArrayType
(
)
)
;
return
arrayType_
;
}
ArrayType
&
arrayType
(
)
{
MOZ_ASSERT
(
isArrayType
(
)
)
;
return
arrayType_
;
}
static
inline
uintptr_t
forMatch
(
const
TypeDef
*
typeDef
const
RecGroup
*
recGroup
)
;
HashNumber
hash
(
)
const
{
HashNumber
hn
=
HashNumber
(
kind_
)
;
hn
=
mozilla
:
:
AddToHash
(
hn
TypeDef
:
:
forMatch
(
superTypeDef_
&
recGroup
(
)
)
)
;
hn
=
mozilla
:
:
AddToHash
(
hn
isFinal_
)
;
switch
(
kind_
)
{
case
TypeDefKind
:
:
Func
:
hn
=
mozilla
:
:
AddToHash
(
hn
funcType_
.
hash
(
&
recGroup
(
)
)
)
;
break
;
case
TypeDefKind
:
:
Struct
:
hn
=
mozilla
:
:
AddToHash
(
hn
structType_
.
hash
(
&
recGroup
(
)
)
)
;
break
;
case
TypeDefKind
:
:
Array
:
hn
=
mozilla
:
:
AddToHash
(
hn
arrayType_
.
hash
(
&
recGroup
(
)
)
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
return
hn
;
}
static
bool
matches
(
const
TypeDef
&
lhs
const
TypeDef
&
rhs
)
{
if
(
lhs
.
kind_
!
=
rhs
.
kind_
)
{
return
false
;
}
if
(
lhs
.
isFinal_
!
=
rhs
.
isFinal_
)
{
return
false
;
}
if
(
TypeDef
:
:
forMatch
(
lhs
.
superTypeDef_
&
lhs
.
recGroup
(
)
)
!
=
TypeDef
:
:
forMatch
(
rhs
.
superTypeDef_
&
rhs
.
recGroup
(
)
)
)
{
return
false
;
}
switch
(
lhs
.
kind_
)
{
case
TypeDefKind
:
:
Func
:
return
FuncType
:
:
matches
(
&
lhs
.
recGroup
(
)
lhs
.
funcType_
&
rhs
.
recGroup
(
)
rhs
.
funcType_
)
;
case
TypeDefKind
:
:
Struct
:
return
StructType
:
:
matches
(
&
lhs
.
recGroup
(
)
lhs
.
structType_
&
rhs
.
recGroup
(
)
rhs
.
structType_
)
;
case
TypeDefKind
:
:
Array
:
return
ArrayType
:
:
matches
(
&
lhs
.
recGroup
(
)
lhs
.
arrayType_
&
rhs
.
recGroup
(
)
rhs
.
arrayType_
)
;
case
TypeDefKind
:
:
None
:
MOZ_CRASH
(
"
can
'
t
match
TypeDefKind
:
:
None
"
)
;
}
return
false
;
}
static
bool
canBeSubTypeOf
(
const
TypeDef
*
subType
const
TypeDef
*
superType
)
{
if
(
subType
-
>
kind
(
)
!
=
superType
-
>
kind
(
)
)
{
return
false
;
}
if
(
superType
-
>
isFinal
(
)
)
{
return
false
;
}
switch
(
subType
-
>
kind_
)
{
case
TypeDefKind
:
:
Func
:
return
FuncType
:
:
canBeSubTypeOf
(
subType
-
>
funcType_
superType
-
>
funcType_
)
;
case
TypeDefKind
:
:
Struct
:
return
StructType
:
:
canBeSubTypeOf
(
subType
-
>
structType_
superType
-
>
structType_
)
;
case
TypeDefKind
:
:
Array
:
return
ArrayType
:
:
canBeSubTypeOf
(
subType
-
>
arrayType_
superType
-
>
arrayType_
)
;
case
TypeDefKind
:
:
None
:
MOZ_CRASH
(
)
;
}
return
false
;
}
void
setSuperTypeDef
(
const
TypeDef
*
superTypeDef
)
{
superTypeDef_
=
superTypeDef
;
subTypingDepth_
=
superTypeDef_
-
>
subTypingDepth_
+
1
;
}
void
setFinal
(
const
bool
value
)
{
isFinal_
=
value
;
}
static
bool
isSubTypeOf
(
const
TypeDef
*
subTypeDef
const
TypeDef
*
superTypeDef
)
{
if
(
MOZ_LIKELY
(
subTypeDef
=
=
superTypeDef
)
)
{
return
true
;
}
const
SuperTypeVector
*
subSTV
=
subTypeDef
-
>
superTypeVector
(
)
;
const
SuperTypeVector
*
superSTV
=
superTypeDef
-
>
superTypeVector
(
)
;
if
(
!
subSTV
|
|
!
superSTV
)
{
while
(
subTypeDef
)
{
if
(
subTypeDef
=
=
superTypeDef
)
{
return
true
;
}
subTypeDef
=
subTypeDef
-
>
superTypeDef
(
)
;
}
return
false
;
}
MOZ_ASSERT
(
subSTV
)
;
MOZ_ASSERT
(
superSTV
)
;
MOZ_ASSERT
(
subSTV
-
>
typeDef
(
)
=
=
subTypeDef
)
;
MOZ_ASSERT
(
superSTV
-
>
typeDef
(
)
=
=
superTypeDef
)
;
uint32_t
subTypingDepth
=
superTypeDef
-
>
subTypingDepth
(
)
;
if
(
subTypingDepth
>
=
subSTV
-
>
length
(
)
)
{
return
false
;
}
return
subSTV
-
>
type
(
subTypingDepth
)
=
=
superSTV
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
TypeDef
)
;
}
;
using
SharedTypeDef
=
RefPtr
<
const
TypeDef
>
;
using
MutableTypeDef
=
RefPtr
<
TypeDef
>
;
using
TypeDefVector
=
Vector
<
TypeDef
0
SystemAllocPolicy
>
;
using
TypeDefPtrVector
=
Vector
<
const
TypeDef
*
0
SystemAllocPolicy
>
;
using
TypeDefPtrToIndexMap
=
HashMap
<
const
TypeDef
*
uint32_t
PointerHasher
<
const
TypeDef
*
>
SystemAllocPolicy
>
;
class
RecGroup
:
public
AtomicRefCounted
<
RecGroup
>
{
bool
finalizedTypes_
;
uint32_t
numTypes_
;
const
SuperTypeVector
*
vectors_
;
TypeDef
types_
[
0
]
;
friend
class
TypeContext
;
explicit
RecGroup
(
uint32_t
numTypes
)
:
finalizedTypes_
(
false
)
numTypes_
(
numTypes
)
vectors_
(
nullptr
)
{
}
static
constexpr
size_t
sizeOfRecGroup
(
uint32_t
numTypes
)
{
static_assert
(
MaxTypes
<
=
SIZE_MAX
/
sizeof
(
TypeDef
)
)
;
return
sizeof
(
RecGroup
)
+
sizeof
(
TypeDef
)
*
numTypes
;
}
static
RefPtr
<
RecGroup
>
allocate
(
uint32_t
numTypes
)
{
RecGroup
*
recGroup
=
(
RecGroup
*
)
js_malloc
(
sizeOfRecGroup
(
numTypes
)
)
;
if
(
!
recGroup
)
{
return
nullptr
;
}
new
(
recGroup
)
RecGroup
(
numTypes
)
;
for
(
uint32_t
i
=
0
;
i
<
numTypes
;
i
+
+
)
{
new
(
recGroup
-
>
types_
+
i
)
TypeDef
(
recGroup
)
;
}
return
recGroup
;
}
[
[
nodiscard
]
]
bool
finalizeDefinitions
(
)
{
MOZ_ASSERT
(
!
finalizedTypes_
)
;
vectors_
=
SuperTypeVector
:
:
createMultipleForRecGroup
(
this
)
;
if
(
!
vectors_
)
{
return
false
;
}
visitReferencedGroups
(
[
]
(
const
RecGroup
*
recGroup
)
{
recGroup
-
>
AddRef
(
)
;
}
)
;
finalizedTypes_
=
true
;
return
true
;
}
template
<
typename
Visitor
>
void
visitReferencedGroups
(
Visitor
visitor
)
const
{
auto
visitValType
=
[
this
visitor
]
(
ValType
type
)
{
if
(
type
.
isTypeRef
(
)
&
&
&
type
.
typeDef
(
)
-
>
recGroup
(
)
!
=
this
)
{
visitor
(
&
type
.
typeDef
(
)
-
>
recGroup
(
)
)
;
}
}
;
auto
visitStorageType
=
[
this
visitor
]
(
StorageType
type
)
{
if
(
type
.
isTypeRef
(
)
&
&
&
type
.
typeDef
(
)
-
>
recGroup
(
)
!
=
this
)
{
visitor
(
&
type
.
typeDef
(
)
-
>
recGroup
(
)
)
;
}
}
;
for
(
uint32_t
i
=
0
;
i
<
numTypes_
;
i
+
+
)
{
const
TypeDef
&
typeDef
=
types_
[
i
]
;
if
(
typeDef
.
superTypeDef
(
)
&
&
&
typeDef
.
superTypeDef
(
)
-
>
recGroup
(
)
!
=
this
)
{
visitor
(
&
typeDef
.
superTypeDef
(
)
-
>
recGroup
(
)
)
;
}
switch
(
typeDef
.
kind
(
)
)
{
case
TypeDefKind
:
:
Func
:
{
const
FuncType
&
funcType
=
typeDef
.
funcType
(
)
;
for
(
auto
type
:
funcType
.
args
(
)
)
{
visitValType
(
type
)
;
}
for
(
auto
type
:
funcType
.
results
(
)
)
{
visitValType
(
type
)
;
}
break
;
}
case
TypeDefKind
:
:
Struct
:
{
const
StructType
&
structType
=
typeDef
.
structType
(
)
;
for
(
const
auto
&
field
:
structType
.
fields_
)
{
visitStorageType
(
field
.
type
)
;
}
break
;
}
case
TypeDefKind
:
:
Array
:
{
const
ArrayType
&
arrayType
=
typeDef
.
arrayType
(
)
;
visitStorageType
(
arrayType
.
elementType
(
)
)
;
break
;
}
case
TypeDefKind
:
:
None
:
{
MOZ_CRASH
(
)
;
}
}
}
}
public
:
~
RecGroup
(
)
{
if
(
finalizedTypes_
)
{
finalizedTypes_
=
false
;
visitReferencedGroups
(
[
]
(
const
RecGroup
*
recGroup
)
{
recGroup
-
>
Release
(
)
;
}
)
;
}
if
(
vectors_
)
{
js_free
(
(
void
*
)
vectors_
)
;
vectors_
=
nullptr
;
}
for
(
uint32_t
i
=
0
;
i
<
numTypes_
;
i
+
+
)
{
type
(
i
)
.
~
TypeDef
(
)
;
}
}
RecGroup
&
operator
=
(
const
RecGroup
&
)
=
delete
;
RecGroup
&
operator
=
(
RecGroup
&
&
)
=
delete
;
TypeDef
&
type
(
uint32_t
groupTypeIndex
)
{
MOZ_ASSERT
(
!
finalizedTypes_
)
;
return
types_
[
groupTypeIndex
]
;
}
const
TypeDef
&
type
(
uint32_t
groupTypeIndex
)
const
{
return
types_
[
groupTypeIndex
]
;
}
uint32_t
numTypes
(
)
const
{
return
numTypes_
;
}
uint32_t
indexOf
(
const
TypeDef
*
typeDef
)
const
{
MOZ_ASSERT
(
typeDef
>
=
types_
)
;
size_t
groupTypeIndex
=
(
size_t
)
(
typeDef
-
types_
)
;
MOZ_ASSERT
(
groupTypeIndex
<
numTypes
(
)
)
;
return
(
uint32_t
)
groupTypeIndex
;
}
HashNumber
hash
(
)
const
{
HashNumber
hn
=
0
;
for
(
uint32_t
i
=
0
;
i
<
numTypes
(
)
;
i
+
+
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
types_
[
i
]
.
hash
(
)
)
;
}
return
hn
;
}
static
bool
matches
(
const
RecGroup
&
lhs
const
RecGroup
&
rhs
)
{
if
(
lhs
.
numTypes
(
)
!
=
rhs
.
numTypes
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
lhs
.
numTypes
(
)
;
i
+
+
)
{
if
(
!
TypeDef
:
:
matches
(
lhs
.
type
(
i
)
rhs
.
type
(
i
)
)
)
{
return
false
;
}
}
return
true
;
}
}
;
extern
void
PurgeCanonicalTypes
(
)
;
using
SharedRecGroup
=
RefPtr
<
const
RecGroup
>
;
using
MutableRecGroup
=
RefPtr
<
RecGroup
>
;
using
SharedRecGroupVector
=
Vector
<
SharedRecGroup
0
SystemAllocPolicy
>
;
class
TypeContext
:
public
AtomicRefCounted
<
TypeContext
>
{
MutableRecGroup
pendingRecGroup_
;
SharedRecGroupVector
recGroups_
;
TypeDefPtrVector
types_
;
TypeDefPtrToIndexMap
moduleIndices_
;
static
SharedRecGroup
canonicalizeGroup
(
SharedRecGroup
recGroup
)
;
public
:
TypeContext
(
)
=
default
;
~
TypeContext
(
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
types_
.
sizeOfExcludingThis
(
mallocSizeOf
)
+
moduleIndices_
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
}
TypeContext
(
const
TypeContext
&
)
=
delete
;
TypeContext
&
operator
=
(
const
TypeContext
&
)
=
delete
;
TypeContext
(
TypeContext
&
&
)
=
delete
;
TypeContext
&
operator
=
(
TypeContext
&
&
)
=
delete
;
[
[
nodiscard
]
]
MutableRecGroup
startRecGroup
(
uint32_t
numTypes
)
{
MOZ_ASSERT
(
!
pendingRecGroup_
)
;
MutableRecGroup
recGroup
=
RecGroup
:
:
allocate
(
numTypes
)
;
if
(
!
recGroup
|
|
!
addRecGroup
(
recGroup
)
)
{
return
nullptr
;
}
pendingRecGroup_
=
recGroup
;
return
recGroup
;
}
[
[
nodiscard
]
]
bool
endRecGroup
(
)
{
MOZ_ASSERT
(
pendingRecGroup_
)
;
MutableRecGroup
recGroup
=
pendingRecGroup_
;
pendingRecGroup_
=
nullptr
;
if
(
!
recGroup
-
>
finalizeDefinitions
(
)
)
{
return
false
;
}
SharedRecGroup
canonicalRecGroup
=
canonicalizeGroup
(
recGroup
)
;
if
(
!
canonicalRecGroup
)
{
return
false
;
}
if
(
canonicalRecGroup
=
=
recGroup
)
{
return
true
;
}
recGroups_
.
back
(
)
=
canonicalRecGroup
;
MOZ_ASSERT
(
recGroup
-
>
numTypes
(
)
=
=
canonicalRecGroup
-
>
numTypes
(
)
)
;
for
(
uint32_t
groupTypeIndex
=
0
;
groupTypeIndex
<
recGroup
-
>
numTypes
(
)
;
groupTypeIndex
+
+
)
{
uint32_t
typeIndex
=
length
(
)
-
recGroup
-
>
numTypes
(
)
+
groupTypeIndex
;
const
TypeDef
*
oldTypeDef
=
types_
[
typeIndex
]
;
const
TypeDef
*
canonTypeDef
=
&
canonicalRecGroup
-
>
type
(
groupTypeIndex
)
;
types_
[
typeIndex
]
=
canonTypeDef
;
moduleIndices_
.
remove
(
oldTypeDef
)
;
auto
canonTypeIndexEntry
=
moduleIndices_
.
lookupForAdd
(
canonTypeDef
)
;
if
(
!
canonTypeIndexEntry
&
&
!
moduleIndices_
.
add
(
canonTypeIndexEntry
canonTypeDef
typeIndex
)
)
{
return
false
;
}
}
return
true
;
}
[
[
nodiscard
]
]
bool
addRecGroup
(
SharedRecGroup
recGroup
)
{
MOZ_ASSERT
(
!
pendingRecGroup_
)
;
if
(
!
recGroups_
.
append
(
recGroup
)
)
{
return
false
;
}
for
(
uint32_t
groupTypeIndex
=
0
;
groupTypeIndex
<
recGroup
-
>
numTypes
(
)
;
groupTypeIndex
+
+
)
{
const
TypeDef
*
typeDef
=
&
recGroup
-
>
type
(
groupTypeIndex
)
;
uint32_t
typeIndex
=
types_
.
length
(
)
;
if
(
!
types_
.
append
(
typeDef
)
|
|
!
moduleIndices_
.
put
(
typeDef
typeIndex
)
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
const
TypeDef
*
addType
(
T
&
&
type
)
{
MutableRecGroup
recGroup
=
startRecGroup
(
1
)
;
if
(
!
recGroup
)
{
return
nullptr
;
}
recGroup
-
>
type
(
0
)
=
std
:
:
move
(
type
)
;
if
(
!
endRecGroup
(
)
)
{
return
nullptr
;
}
return
&
this
-
>
type
(
length
(
)
-
1
)
;
}
const
TypeDef
&
type
(
uint32_t
index
)
const
{
return
*
types_
[
index
]
;
}
const
TypeDef
&
operator
[
]
(
uint32_t
index
)
const
{
return
*
types_
[
index
]
;
}
bool
empty
(
)
const
{
return
types_
.
empty
(
)
;
}
uint32_t
length
(
)
const
{
return
types_
.
length
(
)
;
}
const
SharedRecGroupVector
&
groups
(
)
const
{
return
recGroups_
;
}
uint32_t
indexOf
(
const
TypeDef
&
typeDef
)
const
{
auto
moduleIndex
=
moduleIndices_
.
readonlyThreadsafeLookup
(
&
typeDef
)
;
MOZ_RELEASE_ASSERT
(
moduleIndex
.
found
(
)
)
;
return
moduleIndex
-
>
value
(
)
;
}
}
;
using
SharedTypeContext
=
RefPtr
<
const
TypeContext
>
;
using
MutableTypeContext
=
RefPtr
<
TypeContext
>
;
class
TypeHandle
{
private
:
SharedTypeContext
context_
;
uint32_t
index_
;
public
:
TypeHandle
(
SharedTypeContext
context
uint32_t
index
)
:
context_
(
context
)
index_
(
index
)
{
MOZ_ASSERT
(
index_
<
context_
-
>
length
(
)
)
;
}
TypeHandle
(
SharedTypeContext
context
const
TypeDef
&
def
)
:
context_
(
context
)
index_
(
context
-
>
indexOf
(
def
)
)
{
}
TypeHandle
(
const
TypeHandle
&
)
=
default
;
TypeHandle
&
operator
=
(
const
TypeHandle
&
)
=
default
;
const
SharedTypeContext
&
context
(
)
const
{
return
context_
;
}
uint32_t
index
(
)
const
{
return
index_
;
}
const
TypeDef
&
def
(
)
const
{
return
context_
-
>
type
(
index_
)
;
}
}
;
inline
uintptr_t
TypeDef
:
:
forMatch
(
const
TypeDef
*
typeDef
const
RecGroup
*
recGroup
)
{
static_assert
(
alignof
(
TypeDef
)
>
1
)
;
MOZ_ASSERT
(
(
uintptr_t
(
typeDef
)
&
0x1
)
=
=
0
)
;
if
(
typeDef
&
&
&
typeDef
-
>
recGroup
(
)
=
=
recGroup
)
{
static_assert
(
MaxTypes
<
=
0x7FFFFFFF
)
;
return
(
uintptr_t
(
recGroup
-
>
indexOf
(
typeDef
)
)
<
<
1
)
|
0x1
;
}
return
uintptr_t
(
typeDef
)
;
}
inline
MatchTypeCode
MatchTypeCode
:
:
forMatch
(
PackedTypeCode
ptc
const
RecGroup
*
recGroup
)
{
MatchTypeCode
mtc
=
{
}
;
mtc
.
typeCode
=
PackedRepr
(
ptc
.
typeCode
(
)
)
;
mtc
.
typeRef
=
TypeDef
:
:
forMatch
(
ptc
.
typeDef
(
)
recGroup
)
;
mtc
.
nullable
=
ptc
.
isNullable
(
)
;
return
mtc
;
}
template
<
class
T
>
void
PackedType
<
T
>
:
:
AddRef
(
)
const
{
if
(
!
isRefType
(
)
)
{
return
;
}
refType
(
)
.
AddRef
(
)
;
}
template
<
class
T
>
void
PackedType
<
T
>
:
:
Release
(
)
const
{
if
(
!
isRefType
(
)
)
{
return
;
}
refType
(
)
.
Release
(
)
;
}
void
RefType
:
:
AddRef
(
)
const
{
if
(
!
isTypeRef
(
)
)
{
return
;
}
typeDef
(
)
-
>
recGroup
(
)
.
AddRef
(
)
;
}
void
RefType
:
:
Release
(
)
const
{
if
(
!
isTypeRef
(
)
)
{
return
;
}
typeDef
(
)
-
>
recGroup
(
)
.
Release
(
)
;
}
inline
RefTypeHierarchy
RefType
:
:
hierarchy
(
)
const
{
switch
(
kind
(
)
)
{
case
RefType
:
:
Func
:
case
RefType
:
:
NoFunc
:
return
RefTypeHierarchy
:
:
Func
;
case
RefType
:
:
Extern
:
case
RefType
:
:
NoExtern
:
return
RefTypeHierarchy
:
:
Extern
;
case
RefType
:
:
Exn
:
case
RefType
:
:
NoExn
:
return
RefTypeHierarchy
:
:
Exn
;
case
RefType
:
:
Any
:
case
RefType
:
:
None
:
case
RefType
:
:
I31
:
case
RefType
:
:
Eq
:
case
RefType
:
:
Struct
:
case
RefType
:
:
Array
:
return
RefTypeHierarchy
:
:
Any
;
case
RefType
:
:
TypeRef
:
switch
(
typeDef
(
)
-
>
kind
(
)
)
{
case
TypeDefKind
:
:
Struct
:
case
TypeDefKind
:
:
Array
:
return
RefTypeHierarchy
:
:
Any
;
case
TypeDefKind
:
:
Func
:
return
RefTypeHierarchy
:
:
Func
;
case
TypeDefKind
:
:
None
:
MOZ_CRASH
(
)
;
}
}
MOZ_CRASH
(
"
switch
is
exhaustive
"
)
;
}
inline
TableRepr
RefType
:
:
tableRepr
(
)
const
{
switch
(
hierarchy
(
)
)
{
case
RefTypeHierarchy
:
:
Any
:
case
RefTypeHierarchy
:
:
Extern
:
case
RefTypeHierarchy
:
:
Exn
:
return
TableRepr
:
:
Ref
;
case
RefTypeHierarchy
:
:
Func
:
return
TableRepr
:
:
Func
;
}
MOZ_CRASH
(
"
switch
is
exhaustive
"
)
;
}
inline
bool
RefType
:
:
isFuncHierarchy
(
)
const
{
return
hierarchy
(
)
=
=
RefTypeHierarchy
:
:
Func
;
}
inline
bool
RefType
:
:
isExternHierarchy
(
)
const
{
return
hierarchy
(
)
=
=
RefTypeHierarchy
:
:
Extern
;
}
inline
bool
RefType
:
:
isAnyHierarchy
(
)
const
{
return
hierarchy
(
)
=
=
RefTypeHierarchy
:
:
Any
;
}
inline
bool
RefType
:
:
isExnHierarchy
(
)
const
{
return
hierarchy
(
)
=
=
RefTypeHierarchy
:
:
Exn
;
}
inline
bool
RefType
:
:
isSubTypeOf
(
RefType
subType
RefType
superType
)
{
if
(
subType
=
=
superType
)
{
return
true
;
}
if
(
subType
.
isNullable
(
)
&
&
!
superType
.
isNullable
(
)
)
{
return
false
;
}
if
(
!
subType
.
isTypeRef
(
)
&
&
!
superType
.
isTypeRef
(
)
&
&
subType
.
kind
(
)
=
=
superType
.
kind
(
)
)
{
return
true
;
}
if
(
subType
.
isEq
(
)
&
&
superType
.
isAny
(
)
)
{
return
true
;
}
if
(
subType
.
isI31
(
)
&
&
(
superType
.
isAny
(
)
|
|
superType
.
isEq
(
)
)
)
{
return
true
;
}
if
(
(
subType
.
isStruct
(
)
|
|
subType
.
isArray
(
)
)
&
&
(
superType
.
isAny
(
)
|
|
superType
.
isEq
(
)
)
)
{
return
true
;
}
if
(
subType
.
isTypeRef
(
)
&
&
subType
.
typeDef
(
)
-
>
isStructType
(
)
&
&
(
superType
.
isAny
(
)
|
|
superType
.
isEq
(
)
|
|
superType
.
isStruct
(
)
)
)
{
return
true
;
}
if
(
subType
.
isTypeRef
(
)
&
&
subType
.
typeDef
(
)
-
>
isArrayType
(
)
&
&
(
superType
.
isAny
(
)
|
|
superType
.
isEq
(
)
|
|
superType
.
isArray
(
)
)
)
{
return
true
;
}
if
(
subType
.
isTypeRef
(
)
&
&
subType
.
typeDef
(
)
-
>
isFuncType
(
)
&
&
superType
.
isFunc
(
)
)
{
return
true
;
}
if
(
subType
.
isTypeRef
(
)
&
&
superType
.
isTypeRef
(
)
)
{
return
TypeDef
:
:
isSubTypeOf
(
subType
.
typeDef
(
)
superType
.
typeDef
(
)
)
;
}
if
(
subType
.
isNoFunc
(
)
&
&
superType
.
hierarchy
(
)
=
=
RefTypeHierarchy
:
:
Func
)
{
return
true
;
}
if
(
subType
.
isNoExtern
(
)
&
&
superType
.
hierarchy
(
)
=
=
RefTypeHierarchy
:
:
Extern
)
{
return
true
;
}
if
(
subType
.
isNone
(
)
&
&
superType
.
hierarchy
(
)
=
=
RefTypeHierarchy
:
:
Any
)
{
return
true
;
}
if
(
subType
.
isNoExn
(
)
&
&
superType
.
hierarchy
(
)
=
=
RefTypeHierarchy
:
:
Exn
)
{
return
true
;
}
return
false
;
}
inline
bool
RefType
:
:
castPossible
(
RefType
sourceType
RefType
destType
)
{
if
(
sourceType
.
isNullable
(
)
&
&
destType
.
isNullable
(
)
)
{
return
true
;
}
if
(
sourceType
.
isRefBottom
(
)
|
|
destType
.
isRefBottom
(
)
)
{
return
false
;
}
RefType
sourceNonNull
=
sourceType
.
withIsNullable
(
false
)
;
RefType
destNonNull
=
destType
.
withIsNullable
(
false
)
;
return
RefType
:
:
isSubTypeOf
(
sourceNonNull
destNonNull
)
|
|
RefType
:
:
isSubTypeOf
(
destNonNull
sourceNonNull
)
;
}
}
}
#
endif
