#
ifndef
wasm_module_types_h
#
define
wasm_module_types_h
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
RefCounted
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
wasm
/
WasmCompileArgs
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmExprType
.
h
"
#
include
"
wasm
/
WasmInitExpr
.
h
"
#
include
"
wasm
/
WasmMemory
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
#
include
"
wasm
/
WasmShareable
.
h
"
#
include
"
wasm
/
WasmTypeDecls
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
#
include
"
wasm
/
WasmValue
.
h
"
namespace
js
{
namespace
wasm
{
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Span
;
class
FuncType
;
enum
ModuleKind
{
Wasm
AsmJS
}
;
struct
CacheableChars
:
UniqueChars
{
CacheableChars
(
)
=
default
;
explicit
CacheableChars
(
char
*
ptr
)
:
UniqueChars
(
ptr
)
{
}
MOZ_IMPLICIT
CacheableChars
(
UniqueChars
&
&
rhs
)
:
UniqueChars
(
std
:
:
move
(
rhs
)
)
{
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
CacheableCharsVector
=
Vector
<
CacheableChars
0
SystemAllocPolicy
>
;
struct
CacheableName
{
private
:
UTF8Bytes
bytes_
;
const
char
*
begin
(
)
const
{
return
(
const
char
*
)
bytes_
.
begin
(
)
;
}
size_t
length
(
)
const
{
return
bytes_
.
length
(
)
;
}
public
:
CacheableName
(
)
=
default
;
MOZ_IMPLICIT
CacheableName
(
UTF8Bytes
&
&
rhs
)
:
bytes_
(
std
:
:
move
(
rhs
)
)
{
}
bool
isEmpty
(
)
const
{
return
bytes_
.
length
(
)
=
=
0
;
}
Span
<
char
>
utf8Bytes
(
)
{
return
Span
<
char
>
(
bytes_
)
;
}
Span
<
const
char
>
utf8Bytes
(
)
const
{
return
Span
<
const
char
>
(
bytes_
)
;
}
static
CacheableName
fromUTF8Chars
(
UniqueChars
&
&
utf8Chars
)
;
[
[
nodiscard
]
]
static
bool
fromUTF8Chars
(
const
char
*
utf8Chars
CacheableName
*
name
)
;
[
[
nodiscard
]
]
JSAtom
*
toAtom
(
JSContext
*
cx
)
const
;
[
[
nodiscard
]
]
bool
toPropertyKey
(
JSContext
*
cx
MutableHandleId
propertyKey
)
const
;
[
[
nodiscard
]
]
UniqueChars
toQuotedString
(
JSContext
*
cx
)
const
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
CacheableName
)
;
}
;
using
CacheableNameVector
=
Vector
<
CacheableName
0
SystemAllocPolicy
>
;
struct
NameHasher
{
using
Key
=
Span
<
const
char
>
;
using
Lookup
=
Span
<
const
char
>
;
static
HashNumber
hash
(
const
Lookup
&
aLookup
)
{
return
mozilla
:
:
HashString
(
aLookup
.
data
(
)
aLookup
.
Length
(
)
)
;
}
static
bool
match
(
const
Key
&
aKey
const
Lookup
&
aLookup
)
{
return
aKey
=
=
aLookup
;
}
}
;
struct
Import
{
CacheableName
module
;
CacheableName
field
;
DefinitionKind
kind
;
Import
(
)
=
default
;
Import
(
CacheableName
&
&
module
CacheableName
&
&
field
DefinitionKind
kind
)
:
module
(
std
:
:
move
(
module
)
)
field
(
std
:
:
move
(
field
)
)
kind
(
kind
)
{
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
ImportVector
=
Vector
<
Import
0
SystemAllocPolicy
>
;
class
Export
{
public
:
struct
CacheablePod
{
DefinitionKind
kind_
;
uint32_t
index_
;
WASM_CHECK_CACHEABLE_POD
(
kind_
index_
)
;
}
;
private
:
CacheableName
fieldName_
;
CacheablePod
pod
;
public
:
Export
(
)
=
default
;
explicit
Export
(
CacheableName
&
&
fieldName
uint32_t
index
DefinitionKind
kind
)
;
explicit
Export
(
CacheableName
&
&
fieldName
DefinitionKind
kind
)
;
const
CacheableName
&
fieldName
(
)
const
{
return
fieldName_
;
}
DefinitionKind
kind
(
)
const
{
return
pod
.
kind_
;
}
uint32_t
funcIndex
(
)
const
;
uint32_t
tagIndex
(
)
const
;
uint32_t
globalIndex
(
)
const
;
uint32_t
tableIndex
(
)
const
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
Export
)
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
Export
:
:
CacheablePod
)
;
using
ExportVector
=
Vector
<
Export
0
SystemAllocPolicy
>
;
enum
class
FuncFlags
:
uint8_t
{
None
=
0x0
Exported
=
0x1
Eager
=
0x2
CanRefFunc
=
0x4
}
;
struct
FuncDesc
{
const
FuncType
*
type
;
uint32_t
typeIndex
:
24
;
FuncFlags
flags
:
8
;
static_assert
(
MaxTypes
<
=
(
1
<
<
24
)
-
1
)
;
static_assert
(
sizeof
(
FuncFlags
)
=
=
sizeof
(
uint8_t
)
)
;
FuncDesc
(
)
=
default
;
FuncDesc
(
const
FuncType
*
type
uint32_t
typeIndex
)
:
type
(
type
)
typeIndex
(
typeIndex
)
flags
(
FuncFlags
:
:
None
)
{
}
bool
isExported
(
)
const
{
return
uint8_t
(
flags
)
&
uint8_t
(
FuncFlags
:
:
Exported
)
;
}
bool
isEager
(
)
const
{
return
uint8_t
(
flags
)
&
uint8_t
(
FuncFlags
:
:
Eager
)
;
}
bool
canRefFunc
(
)
const
{
return
uint8_t
(
flags
)
&
uint8_t
(
FuncFlags
:
:
CanRefFunc
)
;
}
}
;
using
FuncDescVector
=
Vector
<
FuncDesc
0
SystemAllocPolicy
>
;
enum
class
GlobalKind
{
Import
Constant
Variable
}
;
class
GlobalDesc
{
GlobalKind
kind_
;
InitExpr
initial_
;
unsigned
offset_
;
bool
isMutable_
;
bool
isWasm_
;
bool
isExport_
;
uint32_t
importIndex_
;
bool
isExport
(
)
const
{
return
!
isConstant
(
)
&
&
isExport_
;
}
bool
isWasm
(
)
const
{
return
!
isConstant
(
)
&
&
isWasm_
;
}
public
:
GlobalDesc
(
)
=
default
;
explicit
GlobalDesc
(
InitExpr
&
&
initial
bool
isMutable
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind_
(
(
isMutable
|
|
!
initial
.
isLiteral
(
)
)
?
GlobalKind
:
:
Variable
:
GlobalKind
:
:
Constant
)
{
initial_
=
std
:
:
move
(
initial
)
;
if
(
isVariable
(
)
)
{
isMutable_
=
isMutable
;
isWasm_
=
kind
=
=
Wasm
;
isExport_
=
false
;
offset_
=
UINT32_MAX
;
}
}
explicit
GlobalDesc
(
ValType
type
bool
isMutable
uint32_t
importIndex
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind_
(
GlobalKind
:
:
Import
)
{
initial_
=
InitExpr
(
LitVal
(
type
)
)
;
importIndex_
=
importIndex
;
isMutable_
=
isMutable
;
isWasm_
=
kind
=
=
Wasm
;
isExport_
=
false
;
offset_
=
UINT32_MAX
;
}
void
setOffset
(
unsigned
offset
)
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
offset_
=
=
UINT32_MAX
)
;
offset_
=
offset
;
}
unsigned
offset
(
)
const
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
offset_
!
=
UINT32_MAX
)
;
return
offset_
;
}
void
setIsExport
(
)
{
if
(
!
isConstant
(
)
)
{
isExport_
=
true
;
}
}
GlobalKind
kind
(
)
const
{
return
kind_
;
}
bool
isVariable
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Variable
;
}
bool
isConstant
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Constant
;
}
bool
isImport
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Import
;
}
bool
isMutable
(
)
const
{
return
!
isConstant
(
)
&
&
isMutable_
;
}
const
InitExpr
&
initExpr
(
)
const
{
MOZ_ASSERT
(
!
isImport
(
)
)
;
return
initial_
;
}
uint32_t
importIndex
(
)
const
{
MOZ_ASSERT
(
isImport
(
)
)
;
return
importIndex_
;
}
LitVal
constantValue
(
)
const
{
return
initial_
.
literal
(
)
;
}
bool
isIndirect
(
)
const
{
return
isMutable
(
)
&
&
isWasm
(
)
&
&
(
isImport
(
)
|
|
isExport
(
)
)
;
}
ValType
type
(
)
const
{
return
initial_
.
type
(
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
WASM_DECLARE_FRIEND_SERIALIZE
(
GlobalDesc
)
;
}
;
using
GlobalDescVector
=
Vector
<
GlobalDesc
0
SystemAllocPolicy
>
;
using
TagOffsetVector
=
Vector
<
uint32_t
2
SystemAllocPolicy
>
;
struct
TagType
:
AtomicRefCounted
<
TagType
>
{
ValTypeVector
argTypes_
;
TagOffsetVector
argOffsets_
;
uint32_t
size_
;
TagType
(
)
:
size_
(
0
)
{
}
ResultType
resultType
(
)
const
{
return
ResultType
:
:
Vector
(
argTypes_
)
;
}
[
[
nodiscard
]
]
bool
initialize
(
ValTypeVector
&
&
argTypes
)
;
[
[
nodiscard
]
]
bool
clone
(
const
TagType
&
src
)
{
MOZ_ASSERT
(
argTypes_
.
empty
(
)
&
&
argOffsets_
.
empty
(
)
&
&
size_
=
=
0
)
;
if
(
!
argTypes_
.
appendAll
(
src
.
argTypes_
)
|
|
!
argOffsets_
.
appendAll
(
src
.
argOffsets_
)
)
{
return
false
;
}
size_
=
src
.
size_
;
return
true
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
MutableTagType
=
RefPtr
<
TagType
>
;
using
SharedTagType
=
RefPtr
<
const
TagType
>
;
struct
TagDesc
{
TagKind
kind
;
SharedTagType
type
;
bool
isExport
;
TagDesc
(
)
:
isExport
(
false
)
{
}
TagDesc
(
TagKind
kind
const
SharedTagType
&
type
bool
isExport
=
false
)
:
kind
(
kind
)
type
(
type
)
isExport
(
isExport
)
{
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
TagDescVector
=
Vector
<
TagDesc
0
SystemAllocPolicy
>
;
struct
ElemSegment
:
AtomicRefCounted
<
ElemSegment
>
{
enum
class
Kind
{
Active
Passive
Declared
}
;
Kind
kind
;
uint32_t
tableIndex
;
RefType
elemType
;
Maybe
<
InitExpr
>
offsetIfActive
;
Uint32Vector
elemFuncIndices
;
bool
active
(
)
const
{
return
kind
=
=
Kind
:
:
Active
;
}
const
InitExpr
&
offset
(
)
const
{
return
*
offsetIfActive
;
}
size_t
length
(
)
const
{
return
elemFuncIndices
.
length
(
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
constexpr
uint32_t
NullFuncIndex
=
UINT32_MAX
;
static_assert
(
NullFuncIndex
>
MaxFuncs
"
Invariant
"
)
;
using
MutableElemSegment
=
RefPtr
<
ElemSegment
>
;
using
SharedElemSegment
=
RefPtr
<
const
ElemSegment
>
;
using
ElemSegmentVector
=
Vector
<
SharedElemSegment
0
SystemAllocPolicy
>
;
struct
DataSegmentEnv
{
Maybe
<
InitExpr
>
offsetIfActive
;
uint32_t
bytecodeOffset
;
uint32_t
length
;
}
;
using
DataSegmentEnvVector
=
Vector
<
DataSegmentEnv
0
SystemAllocPolicy
>
;
struct
DataSegment
:
AtomicRefCounted
<
DataSegment
>
{
Maybe
<
InitExpr
>
offsetIfActive
;
Bytes
bytes
;
DataSegment
(
)
=
default
;
bool
active
(
)
const
{
return
!
!
offsetIfActive
;
}
const
InitExpr
&
offset
(
)
const
{
return
*
offsetIfActive
;
}
[
[
nodiscard
]
]
bool
init
(
const
ShareableBytes
&
bytecode
const
DataSegmentEnv
&
src
)
{
if
(
src
.
offsetIfActive
)
{
offsetIfActive
.
emplace
(
)
;
if
(
!
offsetIfActive
-
>
clone
(
*
src
.
offsetIfActive
)
)
{
return
false
;
}
}
return
bytes
.
append
(
bytecode
.
begin
(
)
+
src
.
bytecodeOffset
src
.
length
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
MutableDataSegment
=
RefPtr
<
DataSegment
>
;
using
SharedDataSegment
=
RefPtr
<
const
DataSegment
>
;
using
DataSegmentVector
=
Vector
<
SharedDataSegment
0
SystemAllocPolicy
>
;
struct
CustomSectionEnv
{
uint32_t
nameOffset
;
uint32_t
nameLength
;
uint32_t
payloadOffset
;
uint32_t
payloadLength
;
}
;
using
CustomSectionEnvVector
=
Vector
<
CustomSectionEnv
0
SystemAllocPolicy
>
;
struct
CustomSection
{
Bytes
name
;
SharedBytes
payload
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
using
CustomSectionVector
=
Vector
<
CustomSection
0
SystemAllocPolicy
>
;
struct
Name
{
uint32_t
offsetInNamePayload
;
uint32_t
length
;
WASM_CHECK_CACHEABLE_POD
(
offsetInNamePayload
length
)
;
Name
(
)
:
offsetInNamePayload
(
UINT32_MAX
)
length
(
0
)
{
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
Name
)
;
using
NameVector
=
Vector
<
Name
0
SystemAllocPolicy
>
;
enum
class
LimitsKind
{
Memory
Table
}
;
struct
Limits
{
IndexType
indexType
;
uint64_t
initial
;
Maybe
<
uint64_t
>
maximum
;
Shareable
shared
;
WASM_CHECK_CACHEABLE_POD
(
indexType
initial
maximum
shared
)
;
Limits
(
)
=
default
;
explicit
Limits
(
uint64_t
initial
const
Maybe
<
uint64_t
>
&
maximum
=
Nothing
(
)
Shareable
shared
=
Shareable
:
:
False
)
:
indexType
(
IndexType
:
:
I32
)
initial
(
initial
)
maximum
(
maximum
)
shared
(
shared
)
{
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
Limits
)
;
struct
MemoryDesc
{
Limits
limits
;
WASM_CHECK_CACHEABLE_POD
(
limits
)
;
bool
isShared
(
)
const
{
return
limits
.
shared
=
=
Shareable
:
:
True
;
}
bool
canMovingGrow
(
)
const
{
return
limits
.
maximum
.
isNothing
(
)
;
}
bool
boundsCheckLimitIs32Bits
(
)
const
{
return
limits
.
maximum
.
isSome
(
)
&
&
limits
.
maximum
.
value
(
)
<
(
0x100000000
/
PageSize
)
;
}
IndexType
indexType
(
)
const
{
return
limits
.
indexType
;
}
Pages
initialPages
(
)
const
{
return
Pages
(
limits
.
initial
)
;
}
Maybe
<
Pages
>
maximumPages
(
)
const
{
return
limits
.
maximum
.
map
(
[
]
(
uint64_t
x
)
{
return
Pages
(
x
)
;
}
)
;
}
uint64_t
initialLength32
(
)
const
{
MOZ_ASSERT
(
indexType
(
)
=
=
IndexType
:
:
I32
)
;
return
limits
.
initial
*
PageSize
;
}
uint64_t
initialLength64
(
)
const
{
MOZ_ASSERT
(
indexType
(
)
=
=
IndexType
:
:
I64
)
;
return
limits
.
initial
*
PageSize
;
}
MemoryDesc
(
)
=
default
;
explicit
MemoryDesc
(
Limits
limits
)
:
limits
(
limits
)
{
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
MemoryDesc
)
;
static_assert
(
MaxMemory32LimitField
<
=
UINT64_MAX
/
PageSize
)
;
struct
TableDesc
{
RefType
elemType
;
bool
isImported
;
bool
isExported
;
bool
isAsmJS
;
uint32_t
initialLength
;
Maybe
<
uint32_t
>
maximumLength
;
Maybe
<
InitExpr
>
initExpr
;
TableDesc
(
)
=
default
;
TableDesc
(
RefType
elemType
uint32_t
initialLength
Maybe
<
uint32_t
>
maximumLength
Maybe
<
InitExpr
>
&
&
initExpr
bool
isAsmJS
bool
isImported
=
false
bool
isExported
=
false
)
:
elemType
(
elemType
)
isImported
(
isImported
)
isExported
(
isExported
)
isAsmJS
(
isAsmJS
)
initialLength
(
initialLength
)
maximumLength
(
maximumLength
)
initExpr
(
std
:
:
move
(
initExpr
)
)
{
}
}
;
using
TableDescVector
=
Vector
<
TableDesc
0
SystemAllocPolicy
>
;
}
}
#
endif
