#
include
"
wasm
/
WasmGcObject
-
inl
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
<
algorithm
>
#
include
"
gc
/
Marking
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
ScalarType
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
vm
/
PropertyResult
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
vm
/
Uint8Clamped
.
h
"
#
include
"
gc
/
GCContext
-
inl
.
h
"
#
include
"
gc
/
ObjectKind
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
using
mozilla
:
:
AssertedCast
;
using
mozilla
:
:
CheckedUint32
;
using
mozilla
:
:
IsPowerOfTwo
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
PointerRangeSize
;
using
namespace
js
;
using
namespace
wasm
;
const
ObjectOps
WasmGcObject
:
:
objectOps_
=
{
WasmGcObject
:
:
obj_lookupProperty
WasmGcObject
:
:
obj_defineProperty
WasmGcObject
:
:
obj_hasProperty
WasmGcObject
:
:
obj_getProperty
WasmGcObject
:
:
obj_setProperty
WasmGcObject
:
:
obj_getOwnPropertyDescriptor
WasmGcObject
:
:
obj_deleteProperty
nullptr
nullptr
}
;
bool
WasmGcObject
:
:
obj_lookupProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleObject
objp
PropertyResult
*
propp
)
{
objp
.
set
(
nullptr
)
;
propp
-
>
setNotFound
(
)
;
return
true
;
}
bool
WasmGcObject
:
:
obj_defineProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Handle
<
PropertyDescriptor
>
desc
ObjectOpResult
&
result
)
{
result
.
failReadOnly
(
)
;
return
true
;
}
bool
WasmGcObject
:
:
obj_hasProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
foundp
)
{
*
foundp
=
false
;
return
true
;
}
bool
WasmGcObject
:
:
obj_getProperty
(
JSContext
*
cx
HandleObject
obj
HandleValue
receiver
HandleId
id
MutableHandleValue
vp
)
{
vp
.
setUndefined
(
)
;
return
true
;
}
bool
WasmGcObject
:
:
obj_setProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_MODIFIED_GC_OBJECT
)
;
return
false
;
}
bool
WasmGcObject
:
:
obj_getOwnPropertyDescriptor
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandle
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
)
{
desc
.
reset
(
)
;
return
true
;
}
bool
WasmGcObject
:
:
obj_deleteProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
ObjectOpResult
&
result
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_MODIFIED_GC_OBJECT
)
;
return
false
;
}
bool
WasmGcObject
:
:
lookUpProperty
(
JSContext
*
cx
Handle
<
WasmGcObject
*
>
obj
jsid
id
WasmGcObject
:
:
PropOffset
*
offset
StorageType
*
type
)
{
switch
(
obj
-
>
kind
(
)
)
{
case
wasm
:
:
TypeDefKind
:
:
Struct
:
{
const
auto
&
structType
=
obj
-
>
typeDef
(
)
.
structType
(
)
;
uint32_t
index
;
if
(
!
IdIsIndex
(
id
&
index
)
)
{
return
false
;
}
if
(
index
>
=
structType
.
fields_
.
length
(
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_OUT_OF_BOUNDS
)
;
return
false
;
}
const
StructField
&
field
=
structType
.
fields_
[
index
]
;
offset
-
>
set
(
field
.
offset
)
;
*
type
=
field
.
type
;
return
true
;
}
case
wasm
:
:
TypeDefKind
:
:
Array
:
{
const
auto
&
arrayType
=
obj
-
>
typeDef
(
)
.
arrayType
(
)
;
uint32_t
index
;
if
(
!
IdIsIndex
(
id
&
index
)
)
{
return
false
;
}
uint32_t
numElements
=
obj
-
>
as
<
WasmArrayObject
>
(
)
.
numElements_
;
if
(
index
>
=
numElements
)
{
return
false
;
}
uint64_t
scaledIndex
=
uint64_t
(
index
)
*
uint64_t
(
arrayType
.
elementType_
.
size
(
)
)
;
if
(
scaledIndex
>
=
uint64_t
(
UINT32_MAX
)
)
{
return
false
;
}
offset
-
>
set
(
uint32_t
(
scaledIndex
)
)
;
*
type
=
arrayType
.
elementType_
;
return
true
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
)
;
return
false
;
}
}
bool
WasmGcObject
:
:
loadValue
(
JSContext
*
cx
Handle
<
WasmGcObject
*
>
obj
jsid
id
MutableHandleValue
vp
)
{
WasmGcObject
:
:
PropOffset
offset
;
StorageType
type
;
if
(
!
lookUpProperty
(
cx
obj
id
&
offset
&
type
)
)
{
return
false
;
}
if
(
type
.
isTypeRef
(
)
)
{
type
=
RefType
:
:
fromTypeCode
(
TypeCode
:
:
EqRef
true
)
;
}
if
(
!
type
.
isExposable
(
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_BAD_VAL_TYPE
)
;
return
false
;
}
if
(
obj
-
>
is
<
WasmStructObject
>
(
)
)
{
WasmStructObject
&
structObj
=
obj
-
>
as
<
WasmStructObject
>
(
)
;
MOZ_RELEASE_ASSERT
(
structObj
.
kind
(
)
=
=
TypeDefKind
:
:
Struct
)
;
MOZ_RELEASE_ASSERT
(
offset
.
get
(
)
+
type
.
size
(
)
<
=
structObj
.
typeDef
(
)
.
structType
(
)
.
size_
)
;
return
ToJSValue
(
cx
structObj
.
fieldOffsetToAddress
(
type
offset
.
get
(
)
)
type
vp
)
;
}
MOZ_ASSERT
(
obj
-
>
is
<
WasmArrayObject
>
(
)
)
;
const
WasmArrayObject
&
arrayObj
=
obj
-
>
as
<
WasmArrayObject
>
(
)
;
return
ToJSValue
(
cx
arrayObj
.
data_
+
offset
.
get
(
)
type
vp
)
;
}
bool
WasmGcObject
:
:
isRuntimeSubtypeOf
(
const
wasm
:
:
TypeDef
*
parentTypeDef
)
const
{
return
TypeDef
:
:
isSubTypeOf
(
&
typeDef
(
)
parentTypeDef
)
;
}
bool
WasmGcObject
:
:
obj_newEnumerate
(
JSContext
*
cx
HandleObject
obj
MutableHandleIdVector
properties
bool
enumerableOnly
)
{
return
true
;
}
static
void
WriteValTo
(
const
Val
&
val
StorageType
ty
void
*
dest
)
{
switch
(
ty
.
kind
(
)
)
{
case
StorageType
:
:
I8
:
*
(
(
uint8_t
*
)
dest
)
=
val
.
i32
(
)
;
break
;
case
StorageType
:
:
I16
:
*
(
(
uint16_t
*
)
dest
)
=
val
.
i32
(
)
;
break
;
case
StorageType
:
:
I32
:
*
(
(
uint32_t
*
)
dest
)
=
val
.
i32
(
)
;
break
;
case
StorageType
:
:
I64
:
*
(
(
uint64_t
*
)
dest
)
=
val
.
i64
(
)
;
break
;
case
StorageType
:
:
F32
:
*
(
(
float
*
)
dest
)
=
val
.
f32
(
)
;
break
;
case
StorageType
:
:
F64
:
*
(
(
double
*
)
dest
)
=
val
.
f64
(
)
;
break
;
case
StorageType
:
:
V128
:
*
(
(
V128
*
)
dest
)
=
val
.
v128
(
)
;
break
;
case
StorageType
:
:
Ref
:
*
(
(
GCPtr
<
AnyRef
>
*
)
dest
)
=
val
.
ref
(
)
;
break
;
}
}
void
WasmArrayObject
:
:
obj_trace
(
JSTracer
*
trc
JSObject
*
object
)
{
WasmArrayObject
&
arrayObj
=
object
-
>
as
<
WasmArrayObject
>
(
)
;
uint8_t
*
data
=
arrayObj
.
data_
;
const
auto
&
typeDef
=
arrayObj
.
typeDef
(
)
;
const
auto
&
arrayType
=
typeDef
.
arrayType
(
)
;
if
(
!
arrayType
.
elementType_
.
isRefRepr
(
)
)
{
return
;
}
uint32_t
numElements
=
arrayObj
.
numElements_
;
uint32_t
elemSize
=
arrayType
.
elementType_
.
size
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numElements
;
i
+
+
)
{
AnyRef
*
elementPtr
=
reinterpret_cast
<
AnyRef
*
>
(
data
+
i
*
elemSize
)
;
TraceManuallyBarrieredEdge
(
trc
elementPtr
"
wasm
-
array
-
element
"
)
;
}
}
void
WasmArrayObject
:
:
obj_finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
object
)
{
WasmArrayObject
&
arrayObj
=
object
-
>
as
<
WasmArrayObject
>
(
)
;
if
(
!
arrayObj
.
isDataInline
(
)
)
{
js_free
(
arrayObj
.
dataHeader
(
)
)
;
const
TypeDef
&
typeDef
=
arrayObj
.
typeDef
(
)
;
MOZ_ASSERT
(
typeDef
.
isArrayType
(
)
)
;
size_t
trailerSize
=
calcStorageBytes
(
typeDef
.
arrayType
(
)
.
elementType_
.
size
(
)
arrayObj
.
numElements_
)
;
MOZ_RELEASE_ASSERT
(
trailerSize
<
=
size_t
(
MaxArrayPayloadBytes
)
)
;
gcx
-
>
removeCellMemory
(
&
arrayObj
trailerSize
+
TrailerBlockOverhead
MemoryUse
:
:
WasmTrailerBlock
)
;
arrayObj
.
data_
=
nullptr
;
}
}
size_t
WasmArrayObject
:
:
obj_moved
(
JSObject
*
obj
JSObject
*
old
)
{
MOZ_ASSERT
(
!
IsInsideNursery
(
obj
)
)
;
WasmArrayObject
&
arrayObj
=
obj
-
>
as
<
WasmArrayObject
>
(
)
;
WasmArrayObject
&
oldArrayObj
=
old
-
>
as
<
WasmArrayObject
>
(
)
;
if
(
oldArrayObj
.
isDataInline
(
)
)
{
arrayObj
.
data_
=
WasmArrayObject
:
:
addressOfInlineData
(
&
arrayObj
)
;
}
MOZ_ASSERT
(
arrayObj
.
isDataInline
(
)
=
=
oldArrayObj
.
isDataInline
(
)
)
;
if
(
IsInsideNursery
(
old
)
)
{
MOZ_ASSERT
(
obj
-
>
isTenured
(
)
)
;
if
(
!
arrayObj
.
isDataInline
(
)
)
{
Nursery
&
nursery
=
obj
-
>
runtimeFromMainThread
(
)
-
>
gc
.
nursery
(
)
;
nursery
.
unregisterTrailer
(
arrayObj
.
dataHeader
(
)
)
;
const
TypeDef
&
typeDef
=
arrayObj
.
typeDef
(
)
;
MOZ_ASSERT
(
typeDef
.
isArrayType
(
)
)
;
size_t
trailerSize
=
calcStorageBytes
(
typeDef
.
arrayType
(
)
.
elementType_
.
size
(
)
arrayObj
.
numElements_
)
;
MOZ_RELEASE_ASSERT
(
trailerSize
<
=
size_t
(
MaxArrayPayloadBytes
)
)
;
AddCellMemory
(
&
arrayObj
trailerSize
+
TrailerBlockOverhead
MemoryUse
:
:
WasmTrailerBlock
)
;
}
}
return
0
;
}
void
WasmArrayObject
:
:
storeVal
(
const
Val
&
val
uint32_t
itemIndex
)
{
const
ArrayType
&
arrayType
=
typeDef
(
)
.
arrayType
(
)
;
size_t
elementSize
=
arrayType
.
elementType_
.
size
(
)
;
MOZ_ASSERT
(
itemIndex
<
numElements_
)
;
uint8_t
*
data
=
data_
+
elementSize
*
itemIndex
;
WriteValTo
(
val
arrayType
.
elementType_
data
)
;
}
void
WasmArrayObject
:
:
fillVal
(
const
Val
&
val
uint32_t
itemIndex
uint32_t
len
)
{
const
ArrayType
&
arrayType
=
typeDef
(
)
.
arrayType
(
)
;
size_t
elementSize
=
arrayType
.
elementType_
.
size
(
)
;
uint8_t
*
data
=
data_
+
elementSize
*
itemIndex
;
MOZ_ASSERT
(
itemIndex
<
=
numElements_
&
&
len
<
=
numElements_
-
itemIndex
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
WriteValTo
(
val
arrayType
.
elementType_
data
)
;
data
+
=
elementSize
;
}
}
static
const
JSClassOps
WasmArrayObjectClassOps
=
{
nullptr
nullptr
nullptr
WasmGcObject
:
:
obj_newEnumerate
nullptr
nullptr
WasmArrayObject
:
:
obj_finalize
nullptr
nullptr
WasmArrayObject
:
:
obj_trace
}
;
static
const
ClassExtension
WasmArrayObjectClassExt
=
{
WasmArrayObject
:
:
obj_moved
}
;
const
JSClass
WasmArrayObject
:
:
class_
=
{
"
WasmArrayObject
"
JSClass
:
:
NON_NATIVE
|
JSCLASS_DELAY_METADATA_BUILDER
|
JSCLASS_BACKGROUND_FINALIZE
|
JSCLASS_SKIP_NURSERY_FINALIZE
&
WasmArrayObjectClassOps
JS_NULL_CLASS_SPEC
&
WasmArrayObjectClassExt
&
WasmGcObject
:
:
objectOps_
}
;
const
JSClass
*
js
:
:
WasmStructObject
:
:
classForTypeDef
(
const
wasm
:
:
TypeDef
*
typeDef
)
{
MOZ_ASSERT
(
typeDef
-
>
kind
(
)
=
=
wasm
:
:
TypeDefKind
:
:
Struct
)
;
size_t
nbytes
=
typeDef
-
>
structType
(
)
.
size_
;
return
nbytes
>
WasmStructObject_MaxInlineBytes
?
&
WasmStructObject
:
:
classOutline_
:
&
WasmStructObject
:
:
classInline_
;
}
js
:
:
gc
:
:
AllocKind
js
:
:
WasmStructObject
:
:
allocKindForTypeDef
(
const
wasm
:
:
TypeDef
*
typeDef
)
{
MOZ_ASSERT
(
typeDef
-
>
kind
(
)
=
=
wasm
:
:
TypeDefKind
:
:
Struct
)
;
size_t
nbytes
=
typeDef
-
>
structType
(
)
.
size_
;
if
(
nbytes
>
WasmStructObject_MaxInlineBytes
)
{
nbytes
=
WasmStructObject_MaxInlineBytes
;
}
nbytes
=
sizeOfIncludingInlineData
(
nbytes
)
;
return
gc
:
:
GetGCObjectKindForBytes
(
nbytes
)
;
}
void
WasmStructObject
:
:
obj_trace
(
JSTracer
*
trc
JSObject
*
object
)
{
WasmStructObject
&
structObj
=
object
-
>
as
<
WasmStructObject
>
(
)
;
const
auto
&
structType
=
structObj
.
typeDef
(
)
.
structType
(
)
;
for
(
uint32_t
offset
:
structType
.
inlineTraceOffsets_
)
{
AnyRef
*
fieldPtr
=
reinterpret_cast
<
AnyRef
*
>
(
structObj
.
inlineData
(
)
+
offset
)
;
TraceManuallyBarrieredEdge
(
trc
fieldPtr
"
wasm
-
struct
-
field
"
)
;
}
for
(
uint32_t
offset
:
structType
.
outlineTraceOffsets_
)
{
AnyRef
*
fieldPtr
=
reinterpret_cast
<
AnyRef
*
>
(
structObj
.
outlineData_
+
offset
)
;
TraceManuallyBarrieredEdge
(
trc
fieldPtr
"
wasm
-
struct
-
field
"
)
;
}
}
void
WasmStructObject
:
:
obj_finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
object
)
{
WasmStructObject
&
structObj
=
object
-
>
as
<
WasmStructObject
>
(
)
;
if
(
structObj
.
outlineData_
)
{
js_free
(
structObj
.
outlineData_
)
;
const
TypeDef
&
typeDef
=
structObj
.
typeDef
(
)
;
MOZ_ASSERT
(
typeDef
.
isStructType
(
)
)
;
uint32_t
totalBytes
=
typeDef
.
structType
(
)
.
size_
;
uint32_t
inlineBytes
outlineBytes
;
WasmStructObject
:
:
getDataByteSizes
(
totalBytes
&
inlineBytes
&
outlineBytes
)
;
MOZ_ASSERT
(
inlineBytes
=
=
WasmStructObject_MaxInlineBytes
)
;
MOZ_ASSERT
(
outlineBytes
>
0
)
;
gcx
-
>
removeCellMemory
(
&
structObj
outlineBytes
+
TrailerBlockOverhead
MemoryUse
:
:
WasmTrailerBlock
)
;
structObj
.
outlineData_
=
nullptr
;
}
}
size_t
WasmStructObject
:
:
obj_moved
(
JSObject
*
obj
JSObject
*
old
)
{
MOZ_ASSERT
(
!
IsInsideNursery
(
obj
)
)
;
if
(
IsInsideNursery
(
old
)
)
{
MOZ_ASSERT
(
obj
-
>
isTenured
(
)
)
;
WasmStructObject
&
structObj
=
obj
-
>
as
<
WasmStructObject
>
(
)
;
MOZ_ASSERT
(
structObj
.
outlineData_
)
;
Nursery
&
nursery
=
obj
-
>
runtimeFromMainThread
(
)
-
>
gc
.
nursery
(
)
;
nursery
.
unregisterTrailer
(
structObj
.
outlineData_
)
;
const
TypeDef
&
typeDef
=
structObj
.
typeDef
(
)
;
MOZ_ASSERT
(
typeDef
.
isStructType
(
)
)
;
uint32_t
totalBytes
=
typeDef
.
structType
(
)
.
size_
;
uint32_t
inlineBytes
outlineBytes
;
WasmStructObject
:
:
getDataByteSizes
(
totalBytes
&
inlineBytes
&
outlineBytes
)
;
MOZ_ASSERT
(
inlineBytes
=
=
WasmStructObject_MaxInlineBytes
)
;
MOZ_ASSERT
(
outlineBytes
>
0
)
;
AddCellMemory
(
&
structObj
outlineBytes
+
TrailerBlockOverhead
MemoryUse
:
:
WasmTrailerBlock
)
;
}
return
0
;
}
void
WasmStructObject
:
:
storeVal
(
const
Val
&
val
uint32_t
fieldIndex
)
{
const
StructType
&
structType
=
typeDef
(
)
.
structType
(
)
;
StorageType
fieldType
=
structType
.
fields_
[
fieldIndex
]
.
type
;
uint32_t
fieldOffset
=
structType
.
fields_
[
fieldIndex
]
.
offset
;
MOZ_ASSERT
(
fieldIndex
<
structType
.
fields_
.
length
(
)
)
;
bool
areaIsOutline
;
uint32_t
areaOffset
;
fieldOffsetToAreaAndOffset
(
fieldType
fieldOffset
&
areaIsOutline
&
areaOffset
)
;
uint8_t
*
data
;
if
(
areaIsOutline
)
{
data
=
outlineData_
+
areaOffset
;
}
else
{
data
=
inlineData
(
)
+
areaOffset
;
}
WriteValTo
(
val
fieldType
data
)
;
}
static
const
JSClassOps
WasmStructObjectOutlineClassOps
=
{
nullptr
nullptr
nullptr
WasmGcObject
:
:
obj_newEnumerate
nullptr
nullptr
WasmStructObject
:
:
obj_finalize
nullptr
nullptr
WasmStructObject
:
:
obj_trace
}
;
static
const
ClassExtension
WasmStructObjectOutlineClassExt
=
{
WasmStructObject
:
:
obj_moved
}
;
const
JSClass
WasmStructObject
:
:
classOutline_
=
{
"
WasmStructObject
"
JSClass
:
:
NON_NATIVE
|
JSCLASS_DELAY_METADATA_BUILDER
|
JSCLASS_BACKGROUND_FINALIZE
|
JSCLASS_SKIP_NURSERY_FINALIZE
&
WasmStructObjectOutlineClassOps
JS_NULL_CLASS_SPEC
&
WasmStructObjectOutlineClassExt
&
WasmGcObject
:
:
objectOps_
}
;
static
const
JSClassOps
WasmStructObjectInlineClassOps
=
{
nullptr
nullptr
nullptr
WasmGcObject
:
:
obj_newEnumerate
nullptr
nullptr
nullptr
nullptr
nullptr
WasmStructObject
:
:
obj_trace
}
;
static
const
ClassExtension
WasmStructObjectInlineClassExt
=
{
nullptr
}
;
const
JSClass
WasmStructObject
:
:
classInline_
=
{
"
WasmStructObject
"
JSClass
:
:
NON_NATIVE
|
JSCLASS_DELAY_METADATA_BUILDER
&
WasmStructObjectInlineClassOps
JS_NULL_CLASS_SPEC
&
WasmStructObjectInlineClassExt
&
WasmGcObject
:
:
objectOps_
}
;
