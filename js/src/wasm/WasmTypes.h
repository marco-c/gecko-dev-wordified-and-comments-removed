#
ifndef
wasm_types_h
#
define
wasm_types_h
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
RefCounted
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
MallocProvider
.
h
"
#
include
"
wasm
/
WasmBinaryConstants
.
h
"
namespace
js
{
class
PropertyName
;
namespace
jit
{
struct
BaselineScript
;
}
class
WasmMemoryObject
;
typedef
GCPtr
<
WasmMemoryObject
*
>
GCPtrWasmMemoryObject
;
typedef
Rooted
<
WasmMemoryObject
*
>
RootedWasmMemoryObject
;
typedef
Handle
<
WasmMemoryObject
*
>
HandleWasmMemoryObject
;
typedef
MutableHandle
<
WasmMemoryObject
*
>
MutableHandleWasmMemoryObject
;
class
WasmModuleObject
;
typedef
Rooted
<
WasmModuleObject
*
>
RootedWasmModuleObject
;
typedef
Handle
<
WasmModuleObject
*
>
HandleWasmModuleObject
;
typedef
MutableHandle
<
WasmModuleObject
*
>
MutableHandleWasmModuleObject
;
class
WasmInstanceObject
;
typedef
GCVector
<
WasmInstanceObject
*
>
WasmInstanceObjectVector
;
typedef
Rooted
<
WasmInstanceObject
*
>
RootedWasmInstanceObject
;
typedef
Handle
<
WasmInstanceObject
*
>
HandleWasmInstanceObject
;
typedef
MutableHandle
<
WasmInstanceObject
*
>
MutableHandleWasmInstanceObject
;
class
WasmTableObject
;
typedef
Rooted
<
WasmTableObject
*
>
RootedWasmTableObject
;
typedef
Handle
<
WasmTableObject
*
>
HandleWasmTableObject
;
typedef
MutableHandle
<
WasmTableObject
*
>
MutableHandleWasmTableObject
;
namespace
wasm
{
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
EnumeratedArray
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Move
;
using
mozilla
:
:
MallocSizeOf
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
PodZero
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
PodEqual
;
using
mozilla
:
:
RefCounted
;
using
mozilla
:
:
Some
;
using
mozilla
:
:
Unused
;
typedef
Vector
<
uint32_t
0
SystemAllocPolicy
>
Uint32Vector
;
typedef
Vector
<
uint8_t
0
SystemAllocPolicy
>
Bytes
;
typedef
int8_t
I8x16
[
16
]
;
typedef
int16_t
I16x8
[
8
]
;
typedef
int32_t
I32x4
[
4
]
;
typedef
float
F32x4
[
4
]
;
class
Code
;
class
CodeRange
;
class
Memory
;
class
Module
;
class
Instance
;
class
Table
;
#
define
WASM_DECLARE_POD_VECTOR
(
Type
VectorName
)
\
}
}
namespace
mozilla
{
\
template
<
>
struct
IsPod
<
js
:
:
wasm
:
:
Type
>
:
TrueType
{
}
;
\
}
namespace
js
{
namespace
wasm
{
\
typedef
Vector
<
Type
0
SystemAllocPolicy
>
VectorName
;
#
define
WASM_DECLARE_SERIALIZABLE
(
Type
)
\
size_t
serializedSize
(
)
const
;
\
uint8_t
*
serialize
(
uint8_t
*
cursor
)
const
;
\
const
uint8_t
*
deserialize
(
const
uint8_t
*
cursor
)
;
\
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
#
define
WASM_DECLARE_SERIALIZABLE_VIRTUAL
(
Type
)
\
virtual
size_t
serializedSize
(
)
const
;
\
virtual
uint8_t
*
serialize
(
uint8_t
*
cursor
)
const
;
\
virtual
const
uint8_t
*
deserialize
(
const
uint8_t
*
cursor
)
;
\
virtual
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
#
define
WASM_DECLARE_SERIALIZABLE_OVERRIDE
(
Type
)
\
size_t
serializedSize
(
)
const
override
;
\
uint8_t
*
serialize
(
uint8_t
*
cursor
)
const
override
;
\
const
uint8_t
*
deserialize
(
const
uint8_t
*
cursor
)
override
;
\
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
template
<
class
T
>
struct
ShareableBase
:
RefCounted
<
T
>
{
using
SeenSet
=
HashSet
<
const
T
*
DefaultHasher
<
const
T
*
>
SystemAllocPolicy
>
;
size_t
sizeOfIncludingThisIfNotSeen
(
MallocSizeOf
mallocSizeOf
SeenSet
*
seen
)
const
{
const
T
*
self
=
static_cast
<
const
T
*
>
(
this
)
;
typename
SeenSet
:
:
AddPtr
p
=
seen
-
>
lookupForAdd
(
self
)
;
if
(
p
)
return
0
;
bool
ok
=
seen
-
>
add
(
p
self
)
;
(
void
)
ok
;
return
mallocSizeOf
(
self
)
+
self
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
static
inline
bool
IsSimdType
(
ValType
vt
)
{
switch
(
vt
)
{
case
ValType
:
:
I8x16
:
case
ValType
:
:
I16x8
:
case
ValType
:
:
I32x4
:
case
ValType
:
:
F32x4
:
case
ValType
:
:
B8x16
:
case
ValType
:
:
B16x8
:
case
ValType
:
:
B32x4
:
return
true
;
default
:
return
false
;
}
}
static
inline
uint32_t
NumSimdElements
(
ValType
vt
)
{
MOZ_ASSERT
(
IsSimdType
(
vt
)
)
;
switch
(
vt
)
{
case
ValType
:
:
I8x16
:
case
ValType
:
:
B8x16
:
return
16
;
case
ValType
:
:
I16x8
:
case
ValType
:
:
B16x8
:
return
8
;
case
ValType
:
:
I32x4
:
case
ValType
:
:
F32x4
:
case
ValType
:
:
B32x4
:
return
4
;
default
:
MOZ_CRASH
(
"
Unhandled
SIMD
type
"
)
;
}
}
static
inline
ValType
SimdElementType
(
ValType
vt
)
{
MOZ_ASSERT
(
IsSimdType
(
vt
)
)
;
switch
(
vt
)
{
case
ValType
:
:
I8x16
:
case
ValType
:
:
I16x8
:
case
ValType
:
:
I32x4
:
return
ValType
:
:
I32
;
case
ValType
:
:
F32x4
:
return
ValType
:
:
F32
;
case
ValType
:
:
B8x16
:
case
ValType
:
:
B16x8
:
case
ValType
:
:
B32x4
:
return
ValType
:
:
I32
;
default
:
MOZ_CRASH
(
"
Unhandled
SIMD
type
"
)
;
}
}
static
inline
ValType
SimdBoolType
(
ValType
vt
)
{
MOZ_ASSERT
(
IsSimdType
(
vt
)
)
;
switch
(
vt
)
{
case
ValType
:
:
I8x16
:
case
ValType
:
:
B8x16
:
return
ValType
:
:
B8x16
;
case
ValType
:
:
I16x8
:
case
ValType
:
:
B16x8
:
return
ValType
:
:
B16x8
;
case
ValType
:
:
I32x4
:
case
ValType
:
:
F32x4
:
case
ValType
:
:
B32x4
:
return
ValType
:
:
B32x4
;
default
:
MOZ_CRASH
(
"
Unhandled
SIMD
type
"
)
;
}
}
static
inline
bool
IsSimdBoolType
(
ValType
vt
)
{
return
vt
=
=
ValType
:
:
B8x16
|
|
vt
=
=
ValType
:
:
B16x8
|
|
vt
=
=
ValType
:
:
B32x4
;
}
static
inline
jit
:
:
MIRType
ToMIRType
(
ValType
vt
)
{
switch
(
vt
)
{
case
ValType
:
:
I32
:
return
jit
:
:
MIRType
:
:
Int32
;
case
ValType
:
:
I64
:
return
jit
:
:
MIRType
:
:
Int64
;
case
ValType
:
:
F32
:
return
jit
:
:
MIRType
:
:
Float32
;
case
ValType
:
:
F64
:
return
jit
:
:
MIRType
:
:
Double
;
case
ValType
:
:
I8x16
:
return
jit
:
:
MIRType
:
:
Int8x16
;
case
ValType
:
:
I16x8
:
return
jit
:
:
MIRType
:
:
Int16x8
;
case
ValType
:
:
I32x4
:
return
jit
:
:
MIRType
:
:
Int32x4
;
case
ValType
:
:
F32x4
:
return
jit
:
:
MIRType
:
:
Float32x4
;
case
ValType
:
:
B8x16
:
return
jit
:
:
MIRType
:
:
Bool8x16
;
case
ValType
:
:
B16x8
:
return
jit
:
:
MIRType
:
:
Bool16x8
;
case
ValType
:
:
B32x4
:
return
jit
:
:
MIRType
:
:
Bool32x4
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
bad
type
"
)
;
}
enum
class
ExprType
{
Void
=
uint8_t
(
TypeCode
:
:
BlockVoid
)
I32
=
uint8_t
(
TypeCode
:
:
I32
)
I64
=
uint8_t
(
TypeCode
:
:
I64
)
F32
=
uint8_t
(
TypeCode
:
:
F32
)
F64
=
uint8_t
(
TypeCode
:
:
F64
)
I8x16
=
uint8_t
(
TypeCode
:
:
I8x16
)
I16x8
=
uint8_t
(
TypeCode
:
:
I16x8
)
I32x4
=
uint8_t
(
TypeCode
:
:
I32x4
)
F32x4
=
uint8_t
(
TypeCode
:
:
F32x4
)
B8x16
=
uint8_t
(
TypeCode
:
:
B8x16
)
B16x8
=
uint8_t
(
TypeCode
:
:
B16x8
)
B32x4
=
uint8_t
(
TypeCode
:
:
B32x4
)
Limit
=
uint8_t
(
TypeCode
:
:
Limit
)
}
;
static
inline
bool
IsVoid
(
ExprType
et
)
{
return
et
=
=
ExprType
:
:
Void
;
}
static
inline
ValType
NonVoidToValType
(
ExprType
et
)
{
MOZ_ASSERT
(
!
IsVoid
(
et
)
)
;
return
ValType
(
et
)
;
}
static
inline
ExprType
ToExprType
(
ValType
vt
)
{
return
ExprType
(
vt
)
;
}
static
inline
bool
IsSimdType
(
ExprType
et
)
{
return
IsVoid
(
et
)
?
false
:
IsSimdType
(
ValType
(
et
)
)
;
}
static
inline
jit
:
:
MIRType
ToMIRType
(
ExprType
et
)
{
return
IsVoid
(
et
)
?
jit
:
:
MIRType
:
:
None
:
ToMIRType
(
ValType
(
et
)
)
;
}
static
inline
const
char
*
ToCString
(
ExprType
type
)
{
switch
(
type
)
{
case
ExprType
:
:
Void
:
return
"
void
"
;
case
ExprType
:
:
I32
:
return
"
i32
"
;
case
ExprType
:
:
I64
:
return
"
i64
"
;
case
ExprType
:
:
F32
:
return
"
f32
"
;
case
ExprType
:
:
F64
:
return
"
f64
"
;
case
ExprType
:
:
I8x16
:
return
"
i8x16
"
;
case
ExprType
:
:
I16x8
:
return
"
i16x8
"
;
case
ExprType
:
:
I32x4
:
return
"
i32x4
"
;
case
ExprType
:
:
F32x4
:
return
"
f32x4
"
;
case
ExprType
:
:
B8x16
:
return
"
b8x16
"
;
case
ExprType
:
:
B16x8
:
return
"
b16x8
"
;
case
ExprType
:
:
B32x4
:
return
"
b32x4
"
;
case
ExprType
:
:
Limit
:
;
}
MOZ_CRASH
(
"
bad
expression
type
"
)
;
}
static
inline
const
char
*
ToCString
(
ValType
type
)
{
return
ToCString
(
ToExprType
(
type
)
)
;
}
template
<
class
T
>
class
Raw
{
typedef
typename
mozilla
:
:
FloatingPoint
<
T
>
:
:
Bits
Bits
;
Bits
value_
;
public
:
Raw
(
)
:
value_
(
0
)
{
}
explicit
Raw
(
T
value
)
:
value_
(
mozilla
:
:
BitwiseCast
<
Bits
>
(
value
)
)
{
}
template
<
class
U
>
MOZ_IMPLICIT
Raw
(
U
)
=
delete
;
static
Raw
fromBits
(
Bits
bits
)
{
Raw
r
;
r
.
value_
=
bits
;
return
r
;
}
Bits
bits
(
)
const
{
return
value_
;
}
T
fp
(
)
const
{
return
mozilla
:
:
BitwiseCast
<
T
>
(
value_
)
;
}
}
;
using
RawF64
=
Raw
<
double
>
;
using
RawF32
=
Raw
<
float
>
;
class
Val
{
ValType
type_
;
union
U
{
uint32_t
i32_
;
uint64_t
i64_
;
RawF32
f32_
;
RawF64
f64_
;
I8x16
i8x16_
;
I16x8
i16x8_
;
I32x4
i32x4_
;
F32x4
f32x4_
;
U
(
)
{
}
}
u
;
public
:
Val
(
)
=
default
;
explicit
Val
(
uint32_t
i32
)
:
type_
(
ValType
:
:
I32
)
{
u
.
i32_
=
i32
;
}
explicit
Val
(
uint64_t
i64
)
:
type_
(
ValType
:
:
I64
)
{
u
.
i64_
=
i64
;
}
explicit
Val
(
RawF32
f32
)
:
type_
(
ValType
:
:
F32
)
{
u
.
f32_
=
f32
;
}
explicit
Val
(
RawF64
f64
)
:
type_
(
ValType
:
:
F64
)
{
u
.
f64_
=
f64
;
}
MOZ_IMPLICIT
Val
(
float
)
=
delete
;
MOZ_IMPLICIT
Val
(
double
)
=
delete
;
explicit
Val
(
const
I8x16
&
i8x16
ValType
type
=
ValType
:
:
I8x16
)
:
type_
(
type
)
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I8x16
|
|
type_
=
=
ValType
:
:
B8x16
)
;
memcpy
(
u
.
i8x16_
i8x16
sizeof
(
u
.
i8x16_
)
)
;
}
explicit
Val
(
const
I16x8
&
i16x8
ValType
type
=
ValType
:
:
I16x8
)
:
type_
(
type
)
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I16x8
|
|
type_
=
=
ValType
:
:
B16x8
)
;
memcpy
(
u
.
i16x8_
i16x8
sizeof
(
u
.
i16x8_
)
)
;
}
explicit
Val
(
const
I32x4
&
i32x4
ValType
type
=
ValType
:
:
I32x4
)
:
type_
(
type
)
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I32x4
|
|
type_
=
=
ValType
:
:
B32x4
)
;
memcpy
(
u
.
i32x4_
i32x4
sizeof
(
u
.
i32x4_
)
)
;
}
explicit
Val
(
const
F32x4
&
f32x4
)
:
type_
(
ValType
:
:
F32x4
)
{
memcpy
(
u
.
f32x4_
f32x4
sizeof
(
u
.
f32x4_
)
)
;
}
ValType
type
(
)
const
{
return
type_
;
}
bool
isSimd
(
)
const
{
return
IsSimdType
(
type
(
)
)
;
}
uint32_t
i32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I32
)
;
return
u
.
i32_
;
}
uint64_t
i64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I64
)
;
return
u
.
i64_
;
}
RawF32
f32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F32
)
;
return
u
.
f32_
;
}
RawF64
f64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F64
)
;
return
u
.
f64_
;
}
const
I8x16
&
i8x16
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I8x16
|
|
type_
=
=
ValType
:
:
B8x16
)
;
return
u
.
i8x16_
;
}
const
I16x8
&
i16x8
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I16x8
|
|
type_
=
=
ValType
:
:
B16x8
)
;
return
u
.
i16x8_
;
}
const
I32x4
&
i32x4
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I32x4
|
|
type_
=
=
ValType
:
:
B32x4
)
;
return
u
.
i32x4_
;
}
const
F32x4
&
f32x4
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F32x4
)
;
return
u
.
f32x4_
;
}
void
writePayload
(
uint8_t
*
dst
)
const
;
}
;
typedef
Vector
<
Val
0
SystemAllocPolicy
>
ValVector
;
class
Sig
{
ValTypeVector
args_
;
ExprType
ret_
;
public
:
Sig
(
)
:
args_
(
)
ret_
(
ExprType
:
:
Void
)
{
}
Sig
(
ValTypeVector
&
&
args
ExprType
ret
)
:
args_
(
Move
(
args
)
)
ret_
(
ret
)
{
}
MOZ_MUST_USE
bool
clone
(
const
Sig
&
rhs
)
{
ret_
=
rhs
.
ret_
;
MOZ_ASSERT
(
args_
.
empty
(
)
)
;
return
args_
.
appendAll
(
rhs
.
args_
)
;
}
ValType
arg
(
unsigned
i
)
const
{
return
args_
[
i
]
;
}
const
ValTypeVector
&
args
(
)
const
{
return
args_
;
}
const
ExprType
&
ret
(
)
const
{
return
ret_
;
}
HashNumber
hash
(
)
const
{
return
AddContainerToHash
(
args_
HashNumber
(
ret_
)
)
;
}
bool
operator
=
=
(
const
Sig
&
rhs
)
const
{
return
ret
(
)
=
=
rhs
.
ret
(
)
&
&
EqualContainers
(
args
(
)
rhs
.
args
(
)
)
;
}
bool
operator
!
=
(
const
Sig
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
WASM_DECLARE_SERIALIZABLE
(
Sig
)
}
;
struct
SigHashPolicy
{
typedef
const
Sig
&
Lookup
;
static
HashNumber
hash
(
Lookup
sig
)
{
return
sig
.
hash
(
)
;
}
static
bool
match
(
const
Sig
*
lhs
Lookup
rhs
)
{
return
*
lhs
=
=
rhs
;
}
}
;
class
InitExpr
{
public
:
enum
class
Kind
{
Constant
GetGlobal
}
;
private
:
Kind
kind_
;
union
U
{
Val
val_
;
struct
{
uint32_t
index_
;
ValType
type_
;
}
global
;
U
(
)
{
}
}
u
;
public
:
InitExpr
(
)
=
default
;
explicit
InitExpr
(
Val
val
)
:
kind_
(
Kind
:
:
Constant
)
{
u
.
val_
=
val
;
}
explicit
InitExpr
(
uint32_t
globalIndex
ValType
type
)
:
kind_
(
Kind
:
:
GetGlobal
)
{
u
.
global
.
index_
=
globalIndex
;
u
.
global
.
type_
=
type
;
}
Kind
kind
(
)
const
{
return
kind_
;
}
bool
isVal
(
)
const
{
return
kind
(
)
=
=
Kind
:
:
Constant
;
}
Val
val
(
)
const
{
MOZ_ASSERT
(
isVal
(
)
)
;
return
u
.
val_
;
}
uint32_t
globalIndex
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
Kind
:
:
GetGlobal
)
;
return
u
.
global
.
index_
;
}
ValType
type
(
)
const
{
switch
(
kind
(
)
)
{
case
Kind
:
:
Constant
:
return
u
.
val_
.
type
(
)
;
case
Kind
:
:
GetGlobal
:
return
u
.
global
.
type_
;
}
MOZ_CRASH
(
"
unexpected
initExpr
type
"
)
;
}
}
;
struct
CacheableChars
:
UniqueChars
{
CacheableChars
(
)
=
default
;
explicit
CacheableChars
(
char
*
ptr
)
:
UniqueChars
(
ptr
)
{
}
MOZ_IMPLICIT
CacheableChars
(
UniqueChars
&
&
rhs
)
:
UniqueChars
(
Move
(
rhs
)
)
{
}
WASM_DECLARE_SERIALIZABLE
(
CacheableChars
)
}
;
typedef
Vector
<
CacheableChars
0
SystemAllocPolicy
>
CacheableCharsVector
;
struct
Import
{
CacheableChars
module
;
CacheableChars
field
;
DefinitionKind
kind
;
Import
(
)
=
default
;
Import
(
UniqueChars
&
&
module
UniqueChars
&
&
field
DefinitionKind
kind
)
:
module
(
Move
(
module
)
)
field
(
Move
(
field
)
)
kind
(
kind
)
{
}
WASM_DECLARE_SERIALIZABLE
(
Import
)
}
;
typedef
Vector
<
Import
0
SystemAllocPolicy
>
ImportVector
;
class
Export
{
CacheableChars
fieldName_
;
struct
CacheablePod
{
DefinitionKind
kind_
;
uint32_t
index_
;
}
pod
;
public
:
Export
(
)
=
default
;
explicit
Export
(
UniqueChars
fieldName
uint32_t
index
DefinitionKind
kind
)
;
explicit
Export
(
UniqueChars
fieldName
DefinitionKind
kind
)
;
const
char
*
fieldName
(
)
const
{
return
fieldName_
.
get
(
)
;
}
DefinitionKind
kind
(
)
const
{
return
pod
.
kind_
;
}
uint32_t
funcIndex
(
)
const
;
uint32_t
globalIndex
(
)
const
;
WASM_DECLARE_SERIALIZABLE
(
Export
)
}
;
typedef
Vector
<
Export
0
SystemAllocPolicy
>
ExportVector
;
enum
class
GlobalKind
{
Import
Constant
Variable
}
;
class
GlobalDesc
{
union
V
{
struct
{
union
U
{
InitExpr
initial_
;
struct
{
ValType
type_
;
uint32_t
index_
;
}
import
;
U
(
)
{
}
}
val
;
unsigned
offset_
;
bool
isMutable_
;
}
var
;
Val
cst_
;
V
(
)
{
}
}
u
;
GlobalKind
kind_
;
public
:
GlobalDesc
(
)
=
default
;
explicit
GlobalDesc
(
InitExpr
initial
bool
isMutable
)
:
kind_
(
(
isMutable
|
|
!
initial
.
isVal
(
)
)
?
GlobalKind
:
:
Variable
:
GlobalKind
:
:
Constant
)
{
if
(
isVariable
(
)
)
{
u
.
var
.
val
.
initial_
=
initial
;
u
.
var
.
isMutable_
=
isMutable
;
u
.
var
.
offset_
=
UINT32_MAX
;
}
else
{
u
.
cst_
=
initial
.
val
(
)
;
}
}
explicit
GlobalDesc
(
ValType
type
bool
isMutable
uint32_t
importIndex
)
:
kind_
(
GlobalKind
:
:
Import
)
{
u
.
var
.
val
.
import
.
type_
=
type
;
u
.
var
.
val
.
import
.
index_
=
importIndex
;
u
.
var
.
isMutable_
=
isMutable
;
u
.
var
.
offset_
=
UINT32_MAX
;
}
void
setOffset
(
unsigned
offset
)
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
u
.
var
.
offset_
=
=
UINT32_MAX
)
;
u
.
var
.
offset_
=
offset
;
}
unsigned
offset
(
)
const
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
u
.
var
.
offset_
!
=
UINT32_MAX
)
;
return
u
.
var
.
offset_
;
}
GlobalKind
kind
(
)
const
{
return
kind_
;
}
bool
isVariable
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Variable
;
}
bool
isConstant
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Constant
;
}
bool
isImport
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Import
;
}
bool
isMutable
(
)
const
{
return
!
isConstant
(
)
&
&
u
.
var
.
isMutable_
;
}
Val
constantValue
(
)
const
{
MOZ_ASSERT
(
isConstant
(
)
)
;
return
u
.
cst_
;
}
const
InitExpr
&
initExpr
(
)
const
{
MOZ_ASSERT
(
isVariable
(
)
)
;
return
u
.
var
.
val
.
initial_
;
}
uint32_t
importIndex
(
)
const
{
MOZ_ASSERT
(
isImport
(
)
)
;
return
u
.
var
.
val
.
import
.
index_
;
}
ValType
type
(
)
const
{
switch
(
kind_
)
{
case
GlobalKind
:
:
Import
:
return
u
.
var
.
val
.
import
.
type_
;
case
GlobalKind
:
:
Variable
:
return
u
.
var
.
val
.
initial_
.
type
(
)
;
case
GlobalKind
:
:
Constant
:
return
u
.
cst_
.
type
(
)
;
}
MOZ_CRASH
(
"
unexpected
global
kind
"
)
;
}
}
;
typedef
Vector
<
GlobalDesc
0
SystemAllocPolicy
>
GlobalDescVector
;
struct
ElemSegment
{
uint32_t
tableIndex
;
InitExpr
offset
;
Uint32Vector
elemFuncIndices
;
Uint32Vector
elemCodeRangeIndices
;
ElemSegment
(
)
=
default
;
ElemSegment
(
uint32_t
tableIndex
InitExpr
offset
Uint32Vector
&
&
elemFuncIndices
)
:
tableIndex
(
tableIndex
)
offset
(
offset
)
elemFuncIndices
(
Move
(
elemFuncIndices
)
)
{
}
WASM_DECLARE_SERIALIZABLE
(
ElemSegment
)
}
;
typedef
Vector
<
ElemSegment
0
SystemAllocPolicy
>
ElemSegmentVector
;
struct
DataSegment
{
InitExpr
offset
;
uint32_t
bytecodeOffset
;
uint32_t
length
;
}
;
typedef
Vector
<
DataSegment
0
SystemAllocPolicy
>
DataSegmentVector
;
class
SigIdDesc
{
public
:
enum
class
Kind
{
None
Immediate
Global
}
;
static
const
uintptr_t
ImmediateBit
=
0x1
;
private
:
Kind
kind_
;
size_t
bits_
;
SigIdDesc
(
Kind
kind
size_t
bits
)
:
kind_
(
kind
)
bits_
(
bits
)
{
}
public
:
Kind
kind
(
)
const
{
return
kind_
;
}
static
bool
isGlobal
(
const
Sig
&
sig
)
;
SigIdDesc
(
)
:
kind_
(
Kind
:
:
None
)
bits_
(
0
)
{
}
static
SigIdDesc
global
(
const
Sig
&
sig
uint32_t
globalDataOffset
)
;
static
SigIdDesc
immediate
(
const
Sig
&
sig
)
;
bool
isGlobal
(
)
const
{
return
kind_
=
=
Kind
:
:
Global
;
}
size_t
immediate
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
Kind
:
:
Immediate
)
;
return
bits_
;
}
uint32_t
globalDataOffset
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
Kind
:
:
Global
)
;
return
bits_
;
}
}
;
struct
SigWithId
:
Sig
{
SigIdDesc
id
;
SigWithId
(
)
=
default
;
explicit
SigWithId
(
Sig
&
&
sig
SigIdDesc
id
)
:
Sig
(
Move
(
sig
)
)
id
(
id
)
{
}
void
operator
=
(
Sig
&
&
rhs
)
{
Sig
:
:
operator
=
(
Move
(
rhs
)
)
;
}
WASM_DECLARE_SERIALIZABLE
(
SigWithId
)
}
;
typedef
Vector
<
SigWithId
0
SystemAllocPolicy
>
SigWithIdVector
;
typedef
Vector
<
const
SigWithId
*
0
SystemAllocPolicy
>
SigWithIdPtrVector
;
struct
Offsets
{
explicit
Offsets
(
uint32_t
begin
=
0
uint32_t
end
=
0
)
:
begin
(
begin
)
end
(
end
)
{
}
uint32_t
begin
;
uint32_t
end
;
void
offsetBy
(
uint32_t
offset
)
{
begin
+
=
offset
;
end
+
=
offset
;
}
}
;
struct
ProfilingOffsets
:
Offsets
{
MOZ_IMPLICIT
ProfilingOffsets
(
uint32_t
profilingReturn
=
0
)
:
Offsets
(
)
profilingReturn
(
profilingReturn
)
{
}
uint32_t
profilingEntry
(
)
const
{
return
begin
;
}
uint32_t
profilingReturn
;
void
offsetBy
(
uint32_t
offset
)
{
Offsets
:
:
offsetBy
(
offset
)
;
profilingReturn
+
=
offset
;
}
}
;
struct
FuncOffsets
:
ProfilingOffsets
{
MOZ_IMPLICIT
FuncOffsets
(
)
:
ProfilingOffsets
(
)
tableEntry
(
0
)
tableProfilingJump
(
0
)
nonProfilingEntry
(
0
)
profilingJump
(
0
)
profilingEpilogue
(
0
)
{
}
uint32_t
tableEntry
;
uint32_t
tableProfilingJump
;
uint32_t
nonProfilingEntry
;
uint32_t
profilingJump
;
uint32_t
profilingEpilogue
;
void
offsetBy
(
uint32_t
offset
)
{
ProfilingOffsets
:
:
offsetBy
(
offset
)
;
tableEntry
+
=
offset
;
tableProfilingJump
+
=
offset
;
nonProfilingEntry
+
=
offset
;
profilingJump
+
=
offset
;
profilingEpilogue
+
=
offset
;
}
}
;
enum
class
Trap
{
Unreachable
IntegerOverflow
InvalidConversionToInteger
IntegerDivideByZero
OutOfBounds
IndirectCallToNull
IndirectCallBadSig
ImpreciseSimdConversion
StackOverflow
Limit
}
;
struct
TrapOffset
{
uint32_t
bytecodeOffset
;
TrapOffset
(
)
=
default
;
explicit
TrapOffset
(
uint32_t
bytecodeOffset
)
:
bytecodeOffset
(
bytecodeOffset
)
{
}
}
;
class
CallSiteDesc
{
uint32_t
lineOrBytecode_
:
30
;
uint32_t
kind_
:
2
;
public
:
enum
Kind
{
Func
Dynamic
Symbolic
TrapExit
}
;
CallSiteDesc
(
)
{
}
explicit
CallSiteDesc
(
Kind
kind
)
:
lineOrBytecode_
(
0
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
=
=
Kind
(
kind_
)
)
;
}
CallSiteDesc
(
uint32_t
lineOrBytecode
Kind
kind
)
:
lineOrBytecode_
(
lineOrBytecode
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
=
=
Kind
(
kind_
)
)
;
MOZ_ASSERT
(
lineOrBytecode
=
=
lineOrBytecode_
)
;
}
uint32_t
lineOrBytecode
(
)
const
{
return
lineOrBytecode_
;
}
Kind
kind
(
)
const
{
return
Kind
(
kind_
)
;
}
}
;
class
CallSite
:
public
CallSiteDesc
{
uint32_t
returnAddressOffset_
;
uint32_t
stackDepth_
;
public
:
CallSite
(
)
{
}
CallSite
(
CallSiteDesc
desc
uint32_t
returnAddressOffset
uint32_t
stackDepth
)
:
CallSiteDesc
(
desc
)
returnAddressOffset_
(
returnAddressOffset
)
stackDepth_
(
stackDepth
)
{
}
void
setReturnAddressOffset
(
uint32_t
r
)
{
returnAddressOffset_
=
r
;
}
void
offsetReturnAddressBy
(
int32_t
o
)
{
returnAddressOffset_
+
=
o
;
}
uint32_t
returnAddressOffset
(
)
const
{
return
returnAddressOffset_
;
}
uint32_t
stackDepth
(
)
const
{
return
stackDepth_
;
}
}
;
WASM_DECLARE_POD_VECTOR
(
CallSite
CallSiteVector
)
class
CallSiteAndTarget
:
public
CallSite
{
uint32_t
index_
;
public
:
explicit
CallSiteAndTarget
(
CallSite
cs
)
:
CallSite
(
cs
)
{
MOZ_ASSERT
(
cs
.
kind
(
)
!
=
Func
)
;
}
CallSiteAndTarget
(
CallSite
cs
uint32_t
funcIndex
)
:
CallSite
(
cs
)
index_
(
funcIndex
)
{
MOZ_ASSERT
(
cs
.
kind
(
)
=
=
Func
)
;
}
CallSiteAndTarget
(
CallSite
cs
Trap
trap
)
:
CallSite
(
cs
)
index_
(
uint32_t
(
trap
)
)
{
MOZ_ASSERT
(
cs
.
kind
(
)
=
=
TrapExit
)
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
Func
)
;
return
index_
;
}
Trap
trap
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
TrapExit
)
;
return
Trap
(
index_
)
;
}
}
;
typedef
Vector
<
CallSiteAndTarget
0
SystemAllocPolicy
>
CallSiteAndTargetVector
;
enum
class
SymbolicAddress
{
ToInt32
#
if
defined
(
JS_CODEGEN_ARM
)
aeabi_idivmod
aeabi_uidivmod
AtomicCmpXchg
AtomicXchg
AtomicFetchAdd
AtomicFetchSub
AtomicFetchAnd
AtomicFetchOr
AtomicFetchXor
#
endif
ModD
SinD
CosD
TanD
ASinD
ACosD
ATanD
CeilD
CeilF
FloorD
FloorF
TruncD
TruncF
NearbyIntD
NearbyIntF
ExpD
LogD
PowD
ATan2D
Context
InterruptUint32
ReportOverRecursed
HandleExecutionInterrupt
ReportTrap
ReportOutOfBounds
ReportUnalignedAccess
CallImport_Void
CallImport_I32
CallImport_I64
CallImport_F64
CoerceInPlace_ToInt32
CoerceInPlace_ToNumber
DivI64
UDivI64
ModI64
UModI64
TruncateDoubleToInt64
TruncateDoubleToUint64
Uint64ToFloatingPoint
Int64ToFloatingPoint
GrowMemory
CurrentMemory
Limit
}
;
void
*
AddressOf
(
SymbolicAddress
imm
ExclusiveContext
*
cx
)
;
struct
Assumptions
{
uint32_t
cpuId
;
JS
:
:
BuildIdCharVector
buildId
;
explicit
Assumptions
(
JS
:
:
BuildIdCharVector
&
&
buildId
)
;
Assumptions
(
)
;
bool
initBuildIdFromContext
(
ExclusiveContext
*
cx
)
;
bool
clone
(
const
Assumptions
&
other
)
;
bool
operator
=
=
(
const
Assumptions
&
rhs
)
const
;
bool
operator
!
=
(
const
Assumptions
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
WASM_DECLARE_SERIALIZABLE
(
Assumptions
)
}
;
enum
ModuleKind
{
Wasm
AsmJS
}
;
struct
Limits
{
uint32_t
initial
;
Maybe
<
uint32_t
>
maximum
;
}
;
enum
class
TableKind
{
AnyFunction
TypedFunction
}
;
struct
TableDesc
{
TableKind
kind
;
bool
external
;
uint32_t
globalDataOffset
;
Limits
limits
;
TableDesc
(
)
=
default
;
TableDesc
(
TableKind
kind
Limits
limits
)
:
kind
(
kind
)
external
(
false
)
globalDataOffset
(
UINT32_MAX
)
limits
(
limits
)
{
}
}
;
typedef
Vector
<
TableDesc
0
SystemAllocPolicy
>
TableDescVector
;
struct
ExportArg
{
uint64_t
lo
;
uint64_t
hi
;
}
;
struct
TlsData
{
JSContext
*
cx
;
Instance
*
instance
;
uint8_t
*
globalData
;
uint8_t
*
memoryBase
;
void
*
stackLimit
;
}
;
typedef
int32_t
(
*
ExportFuncPtr
)
(
ExportArg
*
args
TlsData
*
tls
)
;
struct
FuncImportTls
{
void
*
code
;
TlsData
*
tls
;
jit
:
:
BaselineScript
*
baselineScript
;
GCPtrObject
obj
;
static_assert
(
sizeof
(
GCPtrObject
)
=
=
sizeof
(
void
*
)
"
for
JIT
access
"
)
;
}
;
struct
TableTls
{
uint32_t
length
;
void
*
base
;
}
;
struct
ExternalTableElem
{
void
*
code
;
TlsData
*
tls
;
}
;
class
CalleeDesc
{
public
:
enum
Which
{
Func
Import
WasmTable
AsmJSTable
Builtin
BuiltinInstanceMethod
}
;
private
:
Which
which_
;
union
U
{
U
(
)
{
}
uint32_t
funcIndex_
;
struct
{
uint32_t
globalDataOffset_
;
}
import
;
struct
{
uint32_t
globalDataOffset_
;
bool
external_
;
SigIdDesc
sigId_
;
}
table
;
SymbolicAddress
builtin_
;
}
u
;
public
:
CalleeDesc
(
)
{
}
static
CalleeDesc
function
(
uint32_t
funcIndex
)
{
CalleeDesc
c
;
c
.
which_
=
Func
;
c
.
u
.
funcIndex_
=
funcIndex
;
return
c
;
}
static
CalleeDesc
import
(
uint32_t
globalDataOffset
)
{
CalleeDesc
c
;
c
.
which_
=
Import
;
c
.
u
.
import
.
globalDataOffset_
=
globalDataOffset
;
return
c
;
}
static
CalleeDesc
wasmTable
(
const
TableDesc
&
desc
SigIdDesc
sigId
)
{
CalleeDesc
c
;
c
.
which_
=
WasmTable
;
c
.
u
.
table
.
globalDataOffset_
=
desc
.
globalDataOffset
;
c
.
u
.
table
.
external_
=
desc
.
external
;
c
.
u
.
table
.
sigId_
=
sigId
;
return
c
;
}
static
CalleeDesc
asmJSTable
(
const
TableDesc
&
desc
)
{
CalleeDesc
c
;
c
.
which_
=
AsmJSTable
;
c
.
u
.
table
.
globalDataOffset_
=
desc
.
globalDataOffset
;
return
c
;
}
static
CalleeDesc
builtin
(
SymbolicAddress
callee
)
{
CalleeDesc
c
;
c
.
which_
=
Builtin
;
c
.
u
.
builtin_
=
callee
;
return
c
;
}
static
CalleeDesc
builtinInstanceMethod
(
SymbolicAddress
callee
)
{
CalleeDesc
c
;
c
.
which_
=
BuiltinInstanceMethod
;
c
.
u
.
builtin_
=
callee
;
return
c
;
}
Which
which
(
)
const
{
return
which_
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Func
)
;
return
u
.
funcIndex_
;
}
uint32_t
importGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Import
)
;
return
u
.
import
.
globalDataOffset_
;
}
bool
isTable
(
)
const
{
return
which_
=
=
WasmTable
|
|
which_
=
=
AsmJSTable
;
}
uint32_t
tableLengthGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
isTable
(
)
)
;
return
u
.
table
.
globalDataOffset_
+
offsetof
(
TableTls
length
)
;
}
uint32_t
tableBaseGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
isTable
(
)
)
;
return
u
.
table
.
globalDataOffset_
+
offsetof
(
TableTls
base
)
;
}
bool
wasmTableIsExternal
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
external_
;
}
SigIdDesc
wasmTableSigId
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
sigId_
;
}
SymbolicAddress
builtin
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Builtin
|
|
which_
=
=
BuiltinInstanceMethod
)
;
return
u
.
builtin_
;
}
}
;
extern
bool
IsValidARMImmediate
(
uint32_t
i
)
;
extern
uint32_t
RoundUpToNextValidARMImmediate
(
uint32_t
i
)
;
static
const
unsigned
PageSize
=
64
*
1024
;
static
const
unsigned
MaxMemoryAccessSize
=
sizeof
(
Val
)
;
#
ifdef
JS_CODEGEN_X64
#
define
WASM_HUGE_MEMORY
static
const
uint64_t
IndexRange
=
uint64_t
(
UINT32_MAX
)
+
1
;
static
const
uint64_t
OffsetGuardLimit
=
uint64_t
(
INT32_MAX
)
+
1
;
static
const
uint64_t
UnalignedGuardPage
=
PageSize
;
static
const
uint64_t
HugeMappedSize
=
IndexRange
+
OffsetGuardLimit
+
UnalignedGuardPage
;
static_assert
(
MaxMemoryAccessSize
<
=
UnalignedGuardPage
"
rounded
up
to
static
page
size
"
)
;
#
else
static
const
size_t
OffsetGuardLimit
=
PageSize
-
MaxMemoryAccessSize
;
static
const
size_t
GuardSize
=
PageSize
;
extern
bool
IsValidBoundsCheckImmediate
(
uint32_t
i
)
;
extern
size_t
ComputeMappedSize
(
uint32_t
maxSize
)
;
#
endif
class
BoundsCheck
{
public
:
BoundsCheck
(
)
=
default
;
explicit
BoundsCheck
(
uint32_t
cmpOffset
)
:
cmpOffset_
(
cmpOffset
)
{
}
uint8_t
*
patchAt
(
uint8_t
*
code
)
const
{
return
code
+
cmpOffset_
;
}
void
offsetBy
(
uint32_t
offset
)
{
cmpOffset_
+
=
offset
;
}
private
:
uint32_t
cmpOffset_
;
}
;
WASM_DECLARE_POD_VECTOR
(
BoundsCheck
BoundsCheckVector
)
class
MemoryAccess
{
uint32_t
insnOffset_
;
uint32_t
trapOutOfLineOffset_
;
public
:
MemoryAccess
(
)
=
default
;
explicit
MemoryAccess
(
uint32_t
insnOffset
uint32_t
trapOutOfLineOffset
=
UINT32_MAX
)
:
insnOffset_
(
insnOffset
)
trapOutOfLineOffset_
(
trapOutOfLineOffset
)
{
}
uint32_t
insnOffset
(
)
const
{
return
insnOffset_
;
}
bool
hasTrapOutOfLineCode
(
)
const
{
return
trapOutOfLineOffset_
!
=
UINT32_MAX
;
}
uint8_t
*
trapOutOfLineCode
(
uint8_t
*
code
)
const
{
MOZ_ASSERT
(
hasTrapOutOfLineCode
(
)
)
;
return
code
+
trapOutOfLineOffset_
;
}
void
offsetBy
(
uint32_t
delta
)
{
insnOffset_
+
=
delta
;
if
(
hasTrapOutOfLineCode
(
)
)
trapOutOfLineOffset_
+
=
delta
;
}
}
;
WASM_DECLARE_POD_VECTOR
(
MemoryAccess
MemoryAccessVector
)
struct
MemoryPatch
{
uint32_t
offset
;
MemoryPatch
(
)
=
default
;
explicit
MemoryPatch
(
uint32_t
offset
)
:
offset
(
offset
)
{
}
void
offsetBy
(
uint32_t
delta
)
{
offset
+
=
delta
;
}
}
;
WASM_DECLARE_POD_VECTOR
(
MemoryPatch
MemoryPatchVector
)
static
const
unsigned
NaN64GlobalDataOffset
=
0
;
static
const
unsigned
NaN32GlobalDataOffset
=
NaN64GlobalDataOffset
+
sizeof
(
double
)
;
static
const
unsigned
InitialGlobalDataBytes
=
NaN32GlobalDataOffset
+
sizeof
(
float
)
;
static
const
unsigned
MaxSigs
=
4
*
1024
;
static
const
unsigned
MaxFuncs
=
512
*
1024
;
static
const
unsigned
MaxGlobals
=
4
*
1024
;
static
const
unsigned
MaxLocals
=
64
*
1024
;
static
const
unsigned
MaxImports
=
64
*
1024
;
static
const
unsigned
MaxExports
=
64
*
1024
;
static
const
unsigned
MaxTables
=
4
*
1024
;
static
const
unsigned
MaxTableElems
=
1024
*
1024
;
static
const
unsigned
MaxDataSegments
=
64
*
1024
;
static
const
unsigned
MaxElemSegments
=
64
*
1024
;
static
const
unsigned
MaxArgsPerFunc
=
4
*
1024
;
static
const
unsigned
MaxBrTableElems
=
4
*
1024
*
1024
;
static
const
unsigned
AsmJSMaxImports
=
4
*
1024
;
static
const
unsigned
AsmJSFirstDefFuncIndex
=
AsmJSMaxImports
+
1
;
static_assert
(
AsmJSMaxImports
<
=
MaxImports
"
conservative
"
)
;
static_assert
(
AsmJSFirstDefFuncIndex
<
MaxFuncs
"
conservative
"
)
;
}
}
#
endif
