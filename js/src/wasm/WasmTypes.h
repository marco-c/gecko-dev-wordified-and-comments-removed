#
ifndef
wasm_types_h
#
define
wasm_types_h
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
js
/
RefCounted
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
MallocProvider
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmUtility
.
h
"
namespace
js
{
namespace
jit
{
class
JitScript
;
enum
class
RoundingMode
;
}
typedef
GCVector
<
JSFunction
*
0
SystemAllocPolicy
>
JSFunctionVector
;
class
WasmMemoryObject
;
typedef
GCPtr
<
WasmMemoryObject
*
>
GCPtrWasmMemoryObject
;
typedef
Rooted
<
WasmMemoryObject
*
>
RootedWasmMemoryObject
;
typedef
Handle
<
WasmMemoryObject
*
>
HandleWasmMemoryObject
;
typedef
MutableHandle
<
WasmMemoryObject
*
>
MutableHandleWasmMemoryObject
;
class
WasmModuleObject
;
typedef
Rooted
<
WasmModuleObject
*
>
RootedWasmModuleObject
;
typedef
Handle
<
WasmModuleObject
*
>
HandleWasmModuleObject
;
typedef
MutableHandle
<
WasmModuleObject
*
>
MutableHandleWasmModuleObject
;
class
WasmInstanceObject
;
typedef
GCVector
<
WasmInstanceObject
*
>
WasmInstanceObjectVector
;
typedef
Rooted
<
WasmInstanceObject
*
>
RootedWasmInstanceObject
;
typedef
Handle
<
WasmInstanceObject
*
>
HandleWasmInstanceObject
;
typedef
MutableHandle
<
WasmInstanceObject
*
>
MutableHandleWasmInstanceObject
;
class
WasmTableObject
;
typedef
GCVector
<
WasmTableObject
*
0
SystemAllocPolicy
>
WasmTableObjectVector
;
typedef
Rooted
<
WasmTableObject
*
>
RootedWasmTableObject
;
typedef
Handle
<
WasmTableObject
*
>
HandleWasmTableObject
;
typedef
MutableHandle
<
WasmTableObject
*
>
MutableHandleWasmTableObject
;
class
WasmGlobalObject
;
typedef
GCVector
<
WasmGlobalObject
*
0
SystemAllocPolicy
>
WasmGlobalObjectVector
;
typedef
Rooted
<
WasmGlobalObject
*
>
RootedWasmGlobalObject
;
class
StructTypeDescr
;
typedef
GCVector
<
HeapPtr
<
StructTypeDescr
*
>
0
SystemAllocPolicy
>
StructTypeDescrVector
;
namespace
wasm
{
using
mozilla
:
:
ArrayEqual
;
using
mozilla
:
:
Atomic
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
EnumeratedArray
;
using
mozilla
:
:
MallocSizeOf
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
PodZero
;
using
mozilla
:
:
Some
;
using
mozilla
:
:
Unused
;
class
Code
;
class
DebugState
;
class
GeneratedSourceMap
;
class
Memory
;
class
Module
;
class
Instance
;
class
Table
;
typedef
Vector
<
uint32_t
8
SystemAllocPolicy
>
Uint32Vector
;
typedef
Vector
<
uint8_t
0
SystemAllocPolicy
>
Bytes
;
typedef
UniquePtr
<
Bytes
>
UniqueBytes
;
typedef
UniquePtr
<
const
Bytes
>
UniqueConstBytes
;
typedef
Vector
<
char
0
SystemAllocPolicy
>
UTF8Bytes
;
typedef
Vector
<
Instance
*
0
SystemAllocPolicy
>
InstanceVector
;
typedef
Vector
<
UniqueChars
0
SystemAllocPolicy
>
UniqueCharsVector
;
#
define
WASM_DECLARE_POD_VECTOR
(
Type
VectorName
)
\
}
\
}
\
namespace
mozilla
{
\
template
<
>
\
struct
IsPod
<
js
:
:
wasm
:
:
Type
>
:
TrueType
{
}
;
\
}
\
namespace
js
{
\
namespace
wasm
{
\
typedef
Vector
<
Type
0
SystemAllocPolicy
>
VectorName
;
#
define
WASM_DECLARE_SERIALIZABLE
(
Type
)
\
size_t
serializedSize
(
)
const
;
\
uint8_t
*
serialize
(
uint8_t
*
cursor
)
const
;
\
const
uint8_t
*
deserialize
(
const
uint8_t
*
cursor
)
;
\
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
template
<
class
T
>
struct
SerializableRefPtr
:
RefPtr
<
T
>
{
using
RefPtr
<
T
>
:
:
operator
=
;
SerializableRefPtr
(
)
=
default
;
template
<
class
U
>
MOZ_IMPLICIT
SerializableRefPtr
(
U
&
&
u
)
:
RefPtr
<
T
>
(
std
:
:
forward
<
U
>
(
u
)
)
{
}
WASM_DECLARE_SERIALIZABLE
(
SerializableRefPtr
)
}
;
template
<
class
T
>
struct
ShareableBase
:
AtomicRefCounted
<
T
>
{
using
SeenSet
=
HashSet
<
const
T
*
DefaultHasher
<
const
T
*
>
SystemAllocPolicy
>
;
size_t
sizeOfIncludingThisIfNotSeen
(
MallocSizeOf
mallocSizeOf
SeenSet
*
seen
)
const
{
const
T
*
self
=
static_cast
<
const
T
*
>
(
this
)
;
typename
SeenSet
:
:
AddPtr
p
=
seen
-
>
lookupForAdd
(
self
)
;
if
(
p
)
{
return
0
;
}
bool
ok
=
seen
-
>
add
(
p
self
)
;
(
void
)
ok
;
return
mallocSizeOf
(
self
)
+
self
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
struct
ShareableBytes
:
ShareableBase
<
ShareableBytes
>
{
Bytes
bytes
;
ShareableBytes
(
)
=
default
;
explicit
ShareableBytes
(
Bytes
&
&
bytes
)
:
bytes
(
std
:
:
move
(
bytes
)
)
{
}
size_t
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
bytes
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
const
uint8_t
*
begin
(
)
const
{
return
bytes
.
begin
(
)
;
}
const
uint8_t
*
end
(
)
const
{
return
bytes
.
end
(
)
;
}
size_t
length
(
)
const
{
return
bytes
.
length
(
)
;
}
bool
append
(
const
uint8_t
*
start
uint32_t
len
)
{
return
bytes
.
append
(
start
len
)
;
}
}
;
typedef
RefPtr
<
ShareableBytes
>
MutableBytes
;
typedef
RefPtr
<
const
ShareableBytes
>
SharedBytes
;
enum
class
PackedTypeCode
:
uint32_t
{
}
;
static_assert
(
std
:
:
is_pod
<
PackedTypeCode
>
:
:
value
"
must
be
POD
to
be
simply
serialized
/
deserialized
"
)
;
const
uint32_t
NoTypeCode
=
0xFF
;
const
uint32_t
NoRefTypeIndex
=
0x3FFFFF
;
static
inline
PackedTypeCode
PackTypeCode
(
TypeCode
tc
uint32_t
refTypeIndex
)
{
MOZ_ASSERT
(
uint32_t
(
tc
)
<
=
0xFF
)
;
MOZ_ASSERT_IF
(
tc
!
=
TypeCode
:
:
Ref
refTypeIndex
=
=
NoRefTypeIndex
)
;
MOZ_ASSERT_IF
(
tc
=
=
TypeCode
:
:
Ref
refTypeIndex
<
=
MaxTypes
)
;
static_assert
(
MaxTypes
<
(
1
<
<
(
30
-
8
)
)
"
enough
bits
"
)
;
return
PackedTypeCode
(
(
refTypeIndex
<
<
8
)
|
uint32_t
(
tc
)
)
;
}
static
inline
PackedTypeCode
PackTypeCode
(
TypeCode
tc
)
{
return
PackTypeCode
(
tc
NoRefTypeIndex
)
;
}
static
inline
PackedTypeCode
InvalidPackedTypeCode
(
)
{
return
PackedTypeCode
(
NoTypeCode
)
;
}
static
inline
PackedTypeCode
PackedTypeCodeFromBits
(
uint32_t
bits
)
{
return
PackTypeCode
(
TypeCode
(
bits
&
255
)
bits
>
>
8
)
;
}
static
inline
bool
IsValid
(
PackedTypeCode
ptc
)
{
return
(
uint32_t
(
ptc
)
&
255
)
!
=
NoTypeCode
;
}
static
inline
uint32_t
PackedTypeCodeToBits
(
PackedTypeCode
ptc
)
{
return
uint32_t
(
ptc
)
;
}
static
inline
TypeCode
UnpackTypeCodeType
(
PackedTypeCode
ptc
)
{
MOZ_ASSERT
(
IsValid
(
ptc
)
)
;
return
TypeCode
(
uint32_t
(
ptc
)
&
255
)
;
}
static
inline
uint32_t
UnpackTypeCodeIndex
(
PackedTypeCode
ptc
)
{
MOZ_ASSERT
(
UnpackTypeCodeType
(
ptc
)
=
=
TypeCode
:
:
Ref
)
;
return
uint32_t
(
ptc
)
>
>
8
;
}
static
inline
bool
IsReferenceType
(
PackedTypeCode
ptc
)
{
TypeCode
tc
=
UnpackTypeCodeType
(
ptc
)
;
return
tc
=
=
TypeCode
:
:
Ref
|
|
tc
=
=
TypeCode
:
:
AnyRef
|
|
tc
=
=
TypeCode
:
:
FuncRef
|
|
tc
=
=
TypeCode
:
:
NullRef
;
}
class
ValType
;
class
ExprType
{
PackedTypeCode
tc_
;
#
ifdef
DEBUG
bool
isValidCode
(
)
{
switch
(
UnpackTypeCodeType
(
tc_
)
)
{
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
case
TypeCode
:
:
AnyRef
:
case
TypeCode
:
:
FuncRef
:
case
TypeCode
:
:
NullRef
:
case
TypeCode
:
:
Ref
:
case
TypeCode
:
:
BlockVoid
:
case
TypeCode
:
:
Limit
:
return
true
;
default
:
return
false
;
}
}
#
endif
public
:
enum
Code
{
Void
=
uint8_t
(
TypeCode
:
:
BlockVoid
)
I32
=
uint8_t
(
TypeCode
:
:
I32
)
I64
=
uint8_t
(
TypeCode
:
:
I64
)
F32
=
uint8_t
(
TypeCode
:
:
F32
)
F64
=
uint8_t
(
TypeCode
:
:
F64
)
AnyRef
=
uint8_t
(
TypeCode
:
:
AnyRef
)
FuncRef
=
uint8_t
(
TypeCode
:
:
FuncRef
)
NullRef
=
uint8_t
(
TypeCode
:
:
NullRef
)
Ref
=
uint8_t
(
TypeCode
:
:
Ref
)
Limit
=
uint8_t
(
TypeCode
:
:
Limit
)
}
;
ExprType
(
)
:
tc_
(
)
{
}
ExprType
(
const
ExprType
&
that
)
:
tc_
(
that
.
tc_
)
{
}
MOZ_IMPLICIT
ExprType
(
Code
c
)
:
tc_
(
PackTypeCode
(
TypeCode
(
c
)
)
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
ExprType
(
Code
c
uint32_t
refTypeIndex
)
:
tc_
(
PackTypeCode
(
TypeCode
(
c
)
refTypeIndex
)
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
explicit
ExprType
(
PackedTypeCode
ptc
)
:
tc_
(
ptc
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
explicit
inline
ExprType
(
const
ValType
&
t
)
;
PackedTypeCode
packed
(
)
const
{
return
tc_
;
}
PackedTypeCode
*
packedPtr
(
)
{
return
&
tc_
;
}
Code
code
(
)
const
{
return
Code
(
UnpackTypeCodeType
(
tc_
)
)
;
}
bool
isValid
(
)
const
{
return
IsValid
(
tc_
)
;
}
uint32_t
refTypeIndex
(
)
const
{
return
UnpackTypeCodeIndex
(
tc_
)
;
}
bool
isRef
(
)
const
{
return
UnpackTypeCodeType
(
tc_
)
=
=
TypeCode
:
:
Ref
;
}
bool
isReference
(
)
const
{
return
IsReferenceType
(
tc_
)
;
}
bool
operator
=
=
(
const
ExprType
&
that
)
const
{
return
tc_
=
=
that
.
tc_
;
}
bool
operator
!
=
(
const
ExprType
&
that
)
const
{
return
tc_
!
=
that
.
tc_
;
}
bool
operator
=
=
(
Code
that
)
const
{
MOZ_ASSERT
(
that
!
=
Code
:
:
Ref
)
;
return
code
(
)
=
=
that
;
}
bool
operator
!
=
(
Code
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
}
;
class
ValType
{
PackedTypeCode
tc_
;
#
ifdef
DEBUG
bool
isValidCode
(
)
{
switch
(
UnpackTypeCodeType
(
tc_
)
)
{
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
case
TypeCode
:
:
AnyRef
:
case
TypeCode
:
:
FuncRef
:
case
TypeCode
:
:
NullRef
:
case
TypeCode
:
:
Ref
:
return
true
;
default
:
return
false
;
}
}
#
endif
public
:
enum
Code
{
I32
=
uint8_t
(
TypeCode
:
:
I32
)
I64
=
uint8_t
(
TypeCode
:
:
I64
)
F32
=
uint8_t
(
TypeCode
:
:
F32
)
F64
=
uint8_t
(
TypeCode
:
:
F64
)
AnyRef
=
uint8_t
(
TypeCode
:
:
AnyRef
)
FuncRef
=
uint8_t
(
TypeCode
:
:
FuncRef
)
NullRef
=
uint8_t
(
TypeCode
:
:
NullRef
)
Ref
=
uint8_t
(
TypeCode
:
:
Ref
)
}
;
ValType
(
)
:
tc_
(
InvalidPackedTypeCode
(
)
)
{
}
MOZ_IMPLICIT
ValType
(
Code
c
)
:
tc_
(
PackTypeCode
(
TypeCode
(
c
)
)
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
ValType
(
Code
c
uint32_t
refTypeIndex
)
:
tc_
(
PackTypeCode
(
TypeCode
(
c
)
refTypeIndex
)
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
explicit
ValType
(
const
ExprType
&
t
)
:
tc_
(
t
.
packed
(
)
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
explicit
ValType
(
PackedTypeCode
ptc
)
:
tc_
(
ptc
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
explicit
ValType
(
jit
:
:
MIRType
mty
)
{
switch
(
mty
)
{
case
jit
:
:
MIRType
:
:
Int32
:
tc_
=
PackTypeCode
(
TypeCode
:
:
I32
)
;
break
;
case
jit
:
:
MIRType
:
:
Int64
:
tc_
=
PackTypeCode
(
TypeCode
:
:
I64
)
;
break
;
case
jit
:
:
MIRType
:
:
Float32
:
tc_
=
PackTypeCode
(
TypeCode
:
:
F32
)
;
break
;
case
jit
:
:
MIRType
:
:
Double
:
tc_
=
PackTypeCode
(
TypeCode
:
:
F64
)
;
break
;
default
:
MOZ_CRASH
(
"
ValType
(
MIRType
)
:
unexpected
type
"
)
;
}
}
static
ValType
fromBitsUnsafe
(
uint32_t
bits
)
{
return
ValType
(
PackedTypeCodeFromBits
(
bits
)
)
;
}
PackedTypeCode
packed
(
)
const
{
return
tc_
;
}
uint32_t
bitsUnsafe
(
)
const
{
return
PackedTypeCodeToBits
(
tc_
)
;
}
Code
code
(
)
const
{
return
Code
(
UnpackTypeCodeType
(
tc_
)
)
;
}
bool
isValid
(
)
const
{
return
IsValid
(
tc_
)
;
}
uint32_t
refTypeIndex
(
)
const
{
return
UnpackTypeCodeIndex
(
tc_
)
;
}
bool
isRef
(
)
const
{
return
UnpackTypeCodeType
(
tc_
)
=
=
TypeCode
:
:
Ref
;
}
bool
isReference
(
)
const
{
return
IsReferenceType
(
tc_
)
;
}
bool
operator
=
=
(
const
ValType
&
that
)
const
{
return
tc_
=
=
that
.
tc_
;
}
bool
operator
!
=
(
const
ValType
&
that
)
const
{
return
tc_
!
=
that
.
tc_
;
}
bool
operator
=
=
(
Code
that
)
const
{
MOZ_ASSERT
(
that
!
=
Code
:
:
Ref
)
;
return
code
(
)
=
=
that
;
}
bool
operator
!
=
(
Code
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
}
;
typedef
Vector
<
ValType
16
SystemAllocPolicy
>
ValTypeVector
;
static
inline
unsigned
SizeOf
(
ValType
vt
)
{
switch
(
vt
.
code
(
)
)
{
case
ValType
:
:
I32
:
case
ValType
:
:
F32
:
return
4
;
case
ValType
:
:
I64
:
case
ValType
:
:
F64
:
return
8
;
case
ValType
:
:
AnyRef
:
case
ValType
:
:
FuncRef
:
case
ValType
:
:
NullRef
:
case
ValType
:
:
Ref
:
return
sizeof
(
intptr_t
)
;
}
MOZ_CRASH
(
"
Invalid
ValType
"
)
;
}
static
inline
jit
:
:
MIRType
ToMIRType
(
ValType
vt
)
{
switch
(
vt
.
code
(
)
)
{
case
ValType
:
:
I32
:
return
jit
:
:
MIRType
:
:
Int32
;
case
ValType
:
:
I64
:
return
jit
:
:
MIRType
:
:
Int64
;
case
ValType
:
:
F32
:
return
jit
:
:
MIRType
:
:
Float32
;
case
ValType
:
:
F64
:
return
jit
:
:
MIRType
:
:
Double
;
case
ValType
:
:
Ref
:
case
ValType
:
:
AnyRef
:
case
ValType
:
:
FuncRef
:
case
ValType
:
:
NullRef
:
return
jit
:
:
MIRType
:
:
RefOrNull
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
bad
type
"
)
;
}
static
inline
bool
IsNumberType
(
ValType
vt
)
{
return
!
vt
.
isReference
(
)
;
}
inline
ExprType
:
:
ExprType
(
const
ValType
&
t
)
:
tc_
(
t
.
packed
(
)
)
{
}
static
inline
bool
IsVoid
(
ExprType
et
)
{
return
et
=
=
ExprType
:
:
Void
;
}
static
inline
ValType
NonVoidToValType
(
ExprType
et
)
{
MOZ_ASSERT
(
!
IsVoid
(
et
)
)
;
return
ValType
(
et
)
;
}
static
inline
jit
:
:
MIRType
ToMIRType
(
ExprType
et
)
{
return
IsVoid
(
et
)
?
jit
:
:
MIRType
:
:
None
:
ToMIRType
(
ValType
(
et
)
)
;
}
static
inline
jit
:
:
MIRType
ToMIRType
(
const
Maybe
<
ValType
>
&
t
)
{
return
t
?
ToMIRType
(
ValType
(
t
.
ref
(
)
)
)
:
jit
:
:
MIRType
:
:
None
;
}
static
inline
const
char
*
ToCString
(
ValType
type
)
{
switch
(
type
.
code
(
)
)
{
case
ValType
:
:
I32
:
return
"
i32
"
;
case
ValType
:
:
I64
:
return
"
i64
"
;
case
ValType
:
:
F32
:
return
"
f32
"
;
case
ValType
:
:
F64
:
return
"
f64
"
;
case
ValType
:
:
AnyRef
:
return
"
anyref
"
;
case
ValType
:
:
FuncRef
:
return
"
funcref
"
;
case
ValType
:
:
NullRef
:
return
"
nullref
"
;
case
ValType
:
:
Ref
:
return
"
ref
"
;
default
:
MOZ_CRASH
(
"
bad
value
type
"
)
;
}
}
static
inline
const
char
*
ToCString
(
const
Maybe
<
ValType
>
&
type
)
{
return
type
?
ToCString
(
type
.
ref
(
)
)
:
"
void
"
;
}
static
inline
const
char
*
ToCString
(
ExprType
type
)
{
return
ToCString
(
type
=
=
ExprType
:
:
Void
?
Nothing
(
)
:
Some
(
ValType
(
type
)
)
)
;
}
class
AnyRef
{
JSObject
*
value_
;
explicit
AnyRef
(
)
:
value_
(
(
JSObject
*
)
-
1
)
{
}
explicit
AnyRef
(
JSObject
*
p
)
:
value_
(
p
)
{
MOZ_ASSERT
(
(
(
uintptr_t
)
p
&
0x03
)
=
=
0
)
;
}
public
:
static
AnyRef
invalid
(
)
{
return
AnyRef
(
)
;
}
static
AnyRef
fromCompiledCode
(
void
*
p
)
{
return
AnyRef
(
(
JSObject
*
)
p
)
;
}
static
AnyRef
fromJSObject
(
JSObject
*
p
)
{
return
AnyRef
(
p
)
;
}
static
AnyRef
null
(
)
{
return
AnyRef
(
nullptr
)
;
}
bool
isNull
(
)
{
return
value_
=
=
nullptr
;
}
void
*
forCompiledCode
(
)
const
{
return
value_
;
}
JSObject
*
asJSObject
(
)
{
return
value_
;
}
JSObject
*
*
asJSObjectAddress
(
)
{
return
&
value_
;
}
void
trace
(
JSTracer
*
trc
)
;
static
constexpr
uintptr_t
AnyRefTagMask
=
1
;
static
constexpr
uintptr_t
AnyRefObjTag
=
0
;
}
;
typedef
Rooted
<
AnyRef
>
RootedAnyRef
;
typedef
Handle
<
AnyRef
>
HandleAnyRef
;
typedef
MutableHandle
<
AnyRef
>
MutableHandleAnyRef
;
#
define
ASSERT_ANYREF_IS_JSOBJECT
(
void
)
(
0
)
#
define
STATIC_ASSERT_ANYREF_IS_JSOBJECT
static_assert
(
1
"
AnyRef
is
JSObject
"
)
bool
BoxAnyRef
(
JSContext
*
cx
HandleValue
val
MutableHandleAnyRef
result
)
;
Value
UnboxAnyRef
(
AnyRef
val
)
;
class
FuncRef
{
JSFunction
*
value_
;
explicit
FuncRef
(
)
:
value_
(
(
JSFunction
*
)
-
1
)
{
}
explicit
FuncRef
(
JSFunction
*
p
)
:
value_
(
p
)
{
MOZ_ASSERT
(
(
(
uintptr_t
)
p
&
0x03
)
=
=
0
)
;
}
public
:
static
FuncRef
fromCompiledCode
(
void
*
p
)
{
return
FuncRef
(
(
JSFunction
*
)
p
)
;
}
static
FuncRef
fromJSFunction
(
JSFunction
*
p
)
{
return
FuncRef
(
p
)
;
}
static
FuncRef
fromAnyRefUnchecked
(
AnyRef
p
)
{
#
ifdef
DEBUG
Value
v
=
UnboxAnyRef
(
p
)
;
if
(
v
.
isNull
(
)
)
{
return
FuncRef
(
nullptr
)
;
}
if
(
v
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
{
return
FuncRef
(
&
v
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
}
MOZ_CRASH
(
"
Bad
value
"
)
;
#
else
return
FuncRef
(
&
p
.
asJSObject
(
)
-
>
as
<
JSFunction
>
(
)
)
;
#
endif
}
AnyRef
asAnyRef
(
)
{
return
AnyRef
:
:
fromJSObject
(
(
JSObject
*
)
value_
)
;
}
void
*
forCompiledCode
(
)
const
{
return
value_
;
}
JSFunction
*
asJSFunction
(
)
{
return
value_
;
}
bool
isNull
(
)
{
return
value_
=
=
nullptr
;
}
}
;
typedef
Rooted
<
FuncRef
>
RootedFuncRef
;
typedef
Handle
<
FuncRef
>
HandleFuncRef
;
typedef
MutableHandle
<
FuncRef
>
MutableHandleFuncRef
;
Value
UnboxFuncRef
(
FuncRef
val
)
;
enum
class
Tier
{
Baseline
Debug
=
Baseline
Optimized
Serialized
=
Optimized
}
;
enum
class
OptimizedBackend
{
Ion
Cranelift
}
;
enum
class
CompileMode
{
Once
Tier1
Tier2
}
;
enum
class
DebugEnabled
{
False
True
}
;
enum
class
MemoryUsage
{
None
=
false
Unshared
=
1
Shared
=
2
}
;
class
Tiers
{
Tier
t_
[
2
]
;
uint32_t
n_
;
public
:
explicit
Tiers
(
)
{
n_
=
0
;
}
explicit
Tiers
(
Tier
t
)
{
t_
[
0
]
=
t
;
n_
=
1
;
}
explicit
Tiers
(
Tier
t
Tier
u
)
{
MOZ_ASSERT
(
t
!
=
u
)
;
t_
[
0
]
=
t
;
t_
[
1
]
=
u
;
n_
=
2
;
}
Tier
*
begin
(
)
{
return
t_
;
}
Tier
*
end
(
)
{
return
t_
+
n_
;
}
}
;
enum
ModuleKind
{
Wasm
AsmJS
}
;
enum
class
Shareable
{
False
True
}
;
class
LitVal
{
protected
:
ValType
type_
;
union
U
{
U
(
)
:
i32_
(
0
)
{
}
uint32_t
i32_
;
uint64_t
i64_
;
float
f32_
;
double
f64_
;
AnyRef
ref_
;
}
u
;
public
:
LitVal
(
)
:
type_
(
)
u
{
}
{
}
explicit
LitVal
(
uint32_t
i32
)
:
type_
(
ValType
:
:
I32
)
{
u
.
i32_
=
i32
;
}
explicit
LitVal
(
uint64_t
i64
)
:
type_
(
ValType
:
:
I64
)
{
u
.
i64_
=
i64
;
}
explicit
LitVal
(
float
f32
)
:
type_
(
ValType
:
:
F32
)
{
u
.
f32_
=
f32
;
}
explicit
LitVal
(
double
f64
)
:
type_
(
ValType
:
:
F64
)
{
u
.
f64_
=
f64
;
}
explicit
LitVal
(
ValType
type
AnyRef
any
)
:
type_
(
type
)
{
MOZ_ASSERT
(
type
.
isReference
(
)
)
;
MOZ_ASSERT
(
any
.
isNull
(
)
"
use
Val
for
non
-
nullptr
ref
types
to
get
tracing
"
)
;
u
.
ref_
=
any
;
}
ValType
type
(
)
const
{
return
type_
;
}
static
constexpr
size_t
sizeofLargestValue
(
)
{
return
sizeof
(
u
)
;
}
uint32_t
i32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I32
)
;
return
u
.
i32_
;
}
uint64_t
i64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I64
)
;
return
u
.
i64_
;
}
const
float
&
f32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F32
)
;
return
u
.
f32_
;
}
const
double
&
f64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F64
)
;
return
u
.
f64_
;
}
AnyRef
ref
(
)
const
{
MOZ_ASSERT
(
type_
.
isReference
(
)
)
;
return
u
.
ref_
;
}
}
;
class
MOZ_NON_PARAM
Val
:
public
LitVal
{
public
:
Val
(
)
:
LitVal
(
)
{
}
explicit
Val
(
const
LitVal
&
val
)
;
explicit
Val
(
uint32_t
i32
)
:
LitVal
(
i32
)
{
}
explicit
Val
(
uint64_t
i64
)
:
LitVal
(
i64
)
{
}
explicit
Val
(
float
f32
)
:
LitVal
(
f32
)
{
}
explicit
Val
(
double
f64
)
:
LitVal
(
f64
)
{
}
explicit
Val
(
ValType
type
AnyRef
val
)
:
LitVal
(
type
AnyRef
:
:
null
(
)
)
{
MOZ_ASSERT
(
type
.
isReference
(
)
)
;
u
.
ref_
=
val
;
}
explicit
Val
(
ValType
type
FuncRef
val
)
:
LitVal
(
type
AnyRef
:
:
null
(
)
)
{
MOZ_ASSERT
(
type
=
=
ValType
:
:
FuncRef
)
;
u
.
ref_
=
val
.
asAnyRef
(
)
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
typedef
Rooted
<
Val
>
RootedVal
;
typedef
Handle
<
Val
>
HandleVal
;
typedef
MutableHandle
<
Val
>
MutableHandleVal
;
typedef
GCVector
<
Val
0
SystemAllocPolicy
>
ValVector
;
typedef
Rooted
<
ValVector
>
RootedValVector
;
typedef
Handle
<
ValVector
>
HandleValVector
;
typedef
MutableHandle
<
ValVector
>
MutableHandleValVector
;
class
FuncType
{
ValTypeVector
args_
;
ValTypeVector
results_
;
public
:
FuncType
(
)
:
args_
(
)
results_
(
)
{
}
FuncType
(
ValTypeVector
&
&
args
ValTypeVector
&
&
results
)
:
args_
(
std
:
:
move
(
args
)
)
results_
(
std
:
:
move
(
results
)
)
{
}
MOZ_MUST_USE
bool
clone
(
const
FuncType
&
rhs
)
{
MOZ_ASSERT
(
args_
.
empty
(
)
)
;
MOZ_ASSERT
(
results_
.
empty
(
)
)
;
return
args_
.
appendAll
(
rhs
.
args_
)
&
&
results_
.
appendAll
(
rhs
.
results_
)
;
}
ValType
arg
(
unsigned
i
)
const
{
return
args_
[
i
]
;
}
const
ValTypeVector
&
args
(
)
const
{
return
args_
;
}
ValType
result
(
unsigned
i
)
const
{
return
results_
[
i
]
;
}
const
ValTypeVector
&
results
(
)
const
{
return
results_
;
}
Maybe
<
ValType
>
ret
(
)
const
{
if
(
results_
.
length
(
)
=
=
0
)
{
return
Nothing
(
)
;
}
MOZ_ASSERT
(
results_
.
length
(
)
=
=
1
)
;
return
Some
(
result
(
0
)
)
;
}
HashNumber
hash
(
)
const
{
HashNumber
hn
=
0
;
for
(
const
ValType
&
vt
:
args_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
vt
.
code
(
)
)
)
;
}
for
(
const
ValType
&
vt
:
results_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
vt
.
code
(
)
)
)
;
}
return
hn
;
}
bool
operator
=
=
(
const
FuncType
&
rhs
)
const
{
return
EqualContainers
(
args
(
)
rhs
.
args
(
)
)
&
&
EqualContainers
(
results
(
)
rhs
.
results
(
)
)
;
}
bool
operator
!
=
(
const
FuncType
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
hasI64ArgOrRet
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
=
=
ValType
:
:
I64
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
result
=
=
ValType
:
:
I64
)
{
return
true
;
}
}
return
false
;
}
bool
temporarilyUnsupportedAnyRef
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
isReference
(
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isReference
(
)
)
{
return
true
;
}
}
return
false
;
}
#
ifdef
WASM_PRIVATE_REFTYPES
bool
exposesRef
(
)
const
{
for
(
const
ValType
&
arg
:
args
(
)
)
{
if
(
arg
.
isRef
(
)
)
{
return
true
;
}
}
for
(
const
ValType
&
result
:
results
(
)
)
{
if
(
result
.
isRef
(
)
)
{
return
true
;
}
}
return
false
;
}
#
endif
WASM_DECLARE_SERIALIZABLE
(
FuncType
)
}
;
struct
FuncTypeHashPolicy
{
typedef
const
FuncType
&
Lookup
;
static
HashNumber
hash
(
Lookup
ft
)
{
return
ft
.
hash
(
)
;
}
static
bool
match
(
const
FuncType
*
lhs
Lookup
rhs
)
{
return
*
lhs
=
=
rhs
;
}
}
;
struct
StructField
{
ValType
type
;
uint32_t
offset
;
bool
isMutable
;
}
;
typedef
Vector
<
StructField
0
SystemAllocPolicy
>
StructFieldVector
;
class
StructType
{
public
:
StructFieldVector
fields_
;
uint32_t
moduleIndex_
;
bool
isInline_
;
public
:
StructType
(
)
:
fields_
(
)
moduleIndex_
(
0
)
isInline_
(
true
)
{
}
StructType
(
StructFieldVector
&
&
fields
uint32_t
index
bool
isInline
)
:
fields_
(
std
:
:
move
(
fields
)
)
moduleIndex_
(
index
)
isInline_
(
isInline
)
{
}
bool
copyFrom
(
const
StructType
&
src
)
{
if
(
!
fields_
.
appendAll
(
src
.
fields_
)
)
{
return
false
;
}
moduleIndex_
=
src
.
moduleIndex_
;
isInline_
=
src
.
isInline_
;
return
true
;
}
bool
hasPrefix
(
const
StructType
&
other
)
const
;
WASM_DECLARE_SERIALIZABLE
(
StructType
)
}
;
typedef
Vector
<
StructType
0
SystemAllocPolicy
>
StructTypeVector
;
class
InitExpr
{
public
:
enum
class
Kind
{
Constant
GetGlobal
}
;
private
:
Kind
kind_
;
union
U
{
LitVal
val_
;
struct
{
uint32_t
index_
;
ValType
type_
;
}
global
;
U
(
)
:
global
{
}
{
}
}
u
;
public
:
InitExpr
(
)
=
default
;
explicit
InitExpr
(
LitVal
val
)
:
kind_
(
Kind
:
:
Constant
)
{
u
.
val_
=
val
;
}
explicit
InitExpr
(
uint32_t
globalIndex
ValType
type
)
:
kind_
(
Kind
:
:
GetGlobal
)
{
u
.
global
.
index_
=
globalIndex
;
u
.
global
.
type_
=
type
;
}
Kind
kind
(
)
const
{
return
kind_
;
}
bool
isVal
(
)
const
{
return
kind
(
)
=
=
Kind
:
:
Constant
;
}
LitVal
val
(
)
const
{
MOZ_ASSERT
(
isVal
(
)
)
;
return
u
.
val_
;
}
uint32_t
globalIndex
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
Kind
:
:
GetGlobal
)
;
return
u
.
global
.
index_
;
}
ValType
type
(
)
const
{
switch
(
kind
(
)
)
{
case
Kind
:
:
Constant
:
return
u
.
val_
.
type
(
)
;
case
Kind
:
:
GetGlobal
:
return
u
.
global
.
type_
;
}
MOZ_CRASH
(
"
unexpected
initExpr
type
"
)
;
}
}
;
struct
CacheableChars
:
UniqueChars
{
CacheableChars
(
)
=
default
;
explicit
CacheableChars
(
char
*
ptr
)
:
UniqueChars
(
ptr
)
{
}
MOZ_IMPLICIT
CacheableChars
(
UniqueChars
&
&
rhs
)
:
UniqueChars
(
std
:
:
move
(
rhs
)
)
{
}
WASM_DECLARE_SERIALIZABLE
(
CacheableChars
)
}
;
typedef
Vector
<
CacheableChars
0
SystemAllocPolicy
>
CacheableCharsVector
;
struct
Import
{
CacheableChars
module
;
CacheableChars
field
;
DefinitionKind
kind
;
Import
(
)
=
default
;
Import
(
UniqueChars
&
&
module
UniqueChars
&
&
field
DefinitionKind
kind
)
:
module
(
std
:
:
move
(
module
)
)
field
(
std
:
:
move
(
field
)
)
kind
(
kind
)
{
}
WASM_DECLARE_SERIALIZABLE
(
Import
)
}
;
typedef
Vector
<
Import
0
SystemAllocPolicy
>
ImportVector
;
class
Export
{
CacheableChars
fieldName_
;
struct
CacheablePod
{
DefinitionKind
kind_
;
uint32_t
index_
;
}
pod
;
public
:
Export
(
)
=
default
;
explicit
Export
(
UniqueChars
fieldName
uint32_t
index
DefinitionKind
kind
)
;
explicit
Export
(
UniqueChars
fieldName
DefinitionKind
kind
)
;
const
char
*
fieldName
(
)
const
{
return
fieldName_
.
get
(
)
;
}
DefinitionKind
kind
(
)
const
{
return
pod
.
kind_
;
}
uint32_t
funcIndex
(
)
const
;
uint32_t
globalIndex
(
)
const
;
uint32_t
tableIndex
(
)
const
;
WASM_DECLARE_SERIALIZABLE
(
Export
)
}
;
typedef
Vector
<
Export
0
SystemAllocPolicy
>
ExportVector
;
enum
class
GlobalKind
{
Import
Constant
Variable
}
;
class
GlobalDesc
{
union
V
{
struct
{
union
U
{
InitExpr
initial_
;
struct
{
ValType
type_
;
uint32_t
index_
;
}
import
;
U
(
)
:
import
{
}
{
}
}
val
;
unsigned
offset_
;
bool
isMutable_
;
bool
isWasm_
;
bool
isExport_
;
}
var
;
LitVal
cst_
;
V
(
)
{
}
}
u
;
GlobalKind
kind_
;
bool
isExport
(
)
const
{
return
!
isConstant
(
)
&
&
u
.
var
.
isExport_
;
}
bool
isWasm
(
)
const
{
return
!
isConstant
(
)
&
&
u
.
var
.
isWasm_
;
}
public
:
GlobalDesc
(
)
=
default
;
explicit
GlobalDesc
(
InitExpr
initial
bool
isMutable
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind_
(
(
isMutable
|
|
!
initial
.
isVal
(
)
)
?
GlobalKind
:
:
Variable
:
GlobalKind
:
:
Constant
)
{
MOZ_ASSERT
(
initial
.
type
(
)
!
=
ValType
:
:
NullRef
)
;
if
(
isVariable
(
)
)
{
u
.
var
.
val
.
initial_
=
initial
;
u
.
var
.
isMutable_
=
isMutable
;
u
.
var
.
isWasm_
=
kind
=
=
Wasm
;
u
.
var
.
isExport_
=
false
;
u
.
var
.
offset_
=
UINT32_MAX
;
}
else
{
u
.
cst_
=
initial
.
val
(
)
;
}
}
explicit
GlobalDesc
(
ValType
type
bool
isMutable
uint32_t
importIndex
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind_
(
GlobalKind
:
:
Import
)
{
MOZ_ASSERT
(
type
!
=
ValType
:
:
NullRef
)
;
u
.
var
.
val
.
import
.
type_
=
type
;
u
.
var
.
val
.
import
.
index_
=
importIndex
;
u
.
var
.
isMutable_
=
isMutable
;
u
.
var
.
isWasm_
=
kind
=
=
Wasm
;
u
.
var
.
isExport_
=
false
;
u
.
var
.
offset_
=
UINT32_MAX
;
}
void
setOffset
(
unsigned
offset
)
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
u
.
var
.
offset_
=
=
UINT32_MAX
)
;
u
.
var
.
offset_
=
offset
;
}
unsigned
offset
(
)
const
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
u
.
var
.
offset_
!
=
UINT32_MAX
)
;
return
u
.
var
.
offset_
;
}
void
setIsExport
(
)
{
if
(
!
isConstant
(
)
)
{
u
.
var
.
isExport_
=
true
;
}
}
GlobalKind
kind
(
)
const
{
return
kind_
;
}
bool
isVariable
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Variable
;
}
bool
isConstant
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Constant
;
}
bool
isImport
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Import
;
}
bool
isMutable
(
)
const
{
return
!
isConstant
(
)
&
&
u
.
var
.
isMutable_
;
}
LitVal
constantValue
(
)
const
{
MOZ_ASSERT
(
isConstant
(
)
)
;
return
u
.
cst_
;
}
const
InitExpr
&
initExpr
(
)
const
{
MOZ_ASSERT
(
isVariable
(
)
)
;
return
u
.
var
.
val
.
initial_
;
}
uint32_t
importIndex
(
)
const
{
MOZ_ASSERT
(
isImport
(
)
)
;
return
u
.
var
.
val
.
import
.
index_
;
}
bool
isIndirect
(
)
const
{
return
isMutable
(
)
&
&
isWasm
(
)
&
&
(
isImport
(
)
|
|
isExport
(
)
)
;
}
ValType
type
(
)
const
{
switch
(
kind_
)
{
case
GlobalKind
:
:
Import
:
return
u
.
var
.
val
.
import
.
type_
;
case
GlobalKind
:
:
Variable
:
return
u
.
var
.
val
.
initial_
.
type
(
)
;
case
GlobalKind
:
:
Constant
:
return
u
.
cst_
.
type
(
)
;
}
MOZ_CRASH
(
"
unexpected
global
kind
"
)
;
}
}
;
typedef
Vector
<
GlobalDesc
0
SystemAllocPolicy
>
GlobalDescVector
;
struct
ElemSegment
:
AtomicRefCounted
<
ElemSegment
>
{
enum
class
Kind
{
Active
Passive
Declared
}
;
Kind
kind
;
uint32_t
tableIndex
;
ValType
elementType
;
Maybe
<
InitExpr
>
offsetIfActive
;
Uint32Vector
elemFuncIndices
;
bool
active
(
)
const
{
return
kind
=
=
Kind
:
:
Active
;
}
InitExpr
offset
(
)
const
{
return
*
offsetIfActive
;
}
size_t
length
(
)
const
{
return
elemFuncIndices
.
length
(
)
;
}
ValType
elemType
(
)
const
{
return
elementType
;
}
WASM_DECLARE_SERIALIZABLE
(
ElemSegment
)
}
;
constexpr
uint32_t
NullFuncIndex
=
UINT32_MAX
;
static_assert
(
NullFuncIndex
>
MaxFuncs
"
Invariant
"
)
;
typedef
RefPtr
<
ElemSegment
>
MutableElemSegment
;
typedef
SerializableRefPtr
<
const
ElemSegment
>
SharedElemSegment
;
typedef
Vector
<
SharedElemSegment
0
SystemAllocPolicy
>
ElemSegmentVector
;
struct
DataSegmentEnv
{
Maybe
<
InitExpr
>
offsetIfActive
;
uint32_t
bytecodeOffset
;
uint32_t
length
;
}
;
typedef
Vector
<
DataSegmentEnv
0
SystemAllocPolicy
>
DataSegmentEnvVector
;
struct
DataSegment
:
AtomicRefCounted
<
DataSegment
>
{
Maybe
<
InitExpr
>
offsetIfActive
;
Bytes
bytes
;
DataSegment
(
)
=
default
;
explicit
DataSegment
(
const
DataSegmentEnv
&
src
)
:
offsetIfActive
(
src
.
offsetIfActive
)
{
}
bool
active
(
)
const
{
return
!
!
offsetIfActive
;
}
InitExpr
offset
(
)
const
{
return
*
offsetIfActive
;
}
WASM_DECLARE_SERIALIZABLE
(
DataSegment
)
}
;
typedef
RefPtr
<
DataSegment
>
MutableDataSegment
;
typedef
SerializableRefPtr
<
const
DataSegment
>
SharedDataSegment
;
typedef
Vector
<
SharedDataSegment
0
SystemAllocPolicy
>
DataSegmentVector
;
struct
CustomSectionEnv
{
uint32_t
nameOffset
;
uint32_t
nameLength
;
uint32_t
payloadOffset
;
uint32_t
payloadLength
;
}
;
typedef
Vector
<
CustomSectionEnv
0
SystemAllocPolicy
>
CustomSectionEnvVector
;
struct
CustomSection
{
Bytes
name
;
SharedBytes
payload
;
WASM_DECLARE_SERIALIZABLE
(
CustomSection
)
}
;
typedef
Vector
<
CustomSection
0
SystemAllocPolicy
>
CustomSectionVector
;
struct
Name
{
uint32_t
offsetInNamePayload
;
uint32_t
length
;
Name
(
)
:
offsetInNamePayload
(
UINT32_MAX
)
length
(
0
)
{
}
}
;
typedef
Vector
<
Name
0
SystemAllocPolicy
>
NameVector
;
class
FuncTypeIdDesc
{
public
:
static
const
uintptr_t
ImmediateBit
=
0x1
;
private
:
FuncTypeIdDescKind
kind_
;
size_t
bits_
;
FuncTypeIdDesc
(
FuncTypeIdDescKind
kind
size_t
bits
)
:
kind_
(
kind
)
bits_
(
bits
)
{
}
public
:
FuncTypeIdDescKind
kind
(
)
const
{
return
kind_
;
}
static
bool
isGlobal
(
const
FuncType
&
funcType
)
;
FuncTypeIdDesc
(
)
:
kind_
(
FuncTypeIdDescKind
:
:
None
)
bits_
(
0
)
{
}
static
FuncTypeIdDesc
global
(
const
FuncType
&
funcType
uint32_t
globalDataOffset
)
;
static
FuncTypeIdDesc
immediate
(
const
FuncType
&
funcType
)
;
bool
isGlobal
(
)
const
{
return
kind_
=
=
FuncTypeIdDescKind
:
:
Global
;
}
size_t
immediate
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
FuncTypeIdDescKind
:
:
Immediate
)
;
return
bits_
;
}
uint32_t
globalDataOffset
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
FuncTypeIdDescKind
:
:
Global
)
;
return
bits_
;
}
}
;
struct
FuncTypeWithId
:
FuncType
{
FuncTypeIdDesc
id
;
FuncTypeWithId
(
)
=
default
;
explicit
FuncTypeWithId
(
FuncType
&
&
funcType
)
:
FuncType
(
std
:
:
move
(
funcType
)
)
id
(
)
{
}
FuncTypeWithId
(
FuncType
&
&
funcType
FuncTypeIdDesc
id
)
:
FuncType
(
std
:
:
move
(
funcType
)
)
id
(
id
)
{
}
void
operator
=
(
FuncType
&
&
rhs
)
{
FuncType
:
:
operator
=
(
std
:
:
move
(
rhs
)
)
;
}
WASM_DECLARE_SERIALIZABLE
(
FuncTypeWithId
)
}
;
typedef
Vector
<
FuncTypeWithId
0
SystemAllocPolicy
>
FuncTypeWithIdVector
;
typedef
Vector
<
const
FuncTypeWithId
*
0
SystemAllocPolicy
>
FuncTypeWithIdPtrVector
;
class
TypeDef
{
enum
{
IsFuncType
IsStructType
IsNone
}
tag_
;
union
{
FuncTypeWithId
funcType_
;
StructType
structType_
;
}
;
public
:
TypeDef
(
)
:
tag_
(
IsNone
)
{
}
explicit
TypeDef
(
FuncType
&
&
funcType
)
:
tag_
(
IsFuncType
)
funcType_
(
FuncTypeWithId
(
std
:
:
move
(
funcType
)
)
)
{
}
explicit
TypeDef
(
StructType
&
&
structType
)
:
tag_
(
IsStructType
)
structType_
(
std
:
:
move
(
structType
)
)
{
}
TypeDef
(
TypeDef
&
&
td
)
:
tag_
(
td
.
tag_
)
{
switch
(
tag_
)
{
case
IsFuncType
:
new
(
&
funcType_
)
FuncTypeWithId
(
std
:
:
move
(
td
.
funcType_
)
)
;
break
;
case
IsStructType
:
new
(
&
structType_
)
StructType
(
std
:
:
move
(
td
.
structType_
)
)
;
break
;
case
IsNone
:
break
;
}
}
~
TypeDef
(
)
{
switch
(
tag_
)
{
case
IsFuncType
:
funcType_
.
~
FuncTypeWithId
(
)
;
break
;
case
IsStructType
:
structType_
.
~
StructType
(
)
;
break
;
case
IsNone
:
break
;
}
}
TypeDef
&
operator
=
(
TypeDef
&
&
that
)
{
MOZ_ASSERT
(
isNone
(
)
)
;
switch
(
that
.
tag_
)
{
case
IsFuncType
:
new
(
&
funcType_
)
FuncTypeWithId
(
std
:
:
move
(
that
.
funcType_
)
)
;
break
;
case
IsStructType
:
new
(
&
structType_
)
StructType
(
std
:
:
move
(
that
.
structType_
)
)
;
break
;
case
IsNone
:
break
;
}
tag_
=
that
.
tag_
;
return
*
this
;
}
bool
isFuncType
(
)
const
{
return
tag_
=
=
IsFuncType
;
}
bool
isNone
(
)
const
{
return
tag_
=
=
IsNone
;
}
bool
isStructType
(
)
const
{
return
tag_
=
=
IsStructType
;
}
const
FuncTypeWithId
&
funcType
(
)
const
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
FuncTypeWithId
&
funcType
(
)
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
static
const
TypeDef
*
fromFuncTypeWithIdPtr
(
const
FuncTypeWithId
*
p
)
{
const
TypeDef
*
q
=
(
const
TypeDef
*
)
(
(
char
*
)
p
-
offsetof
(
TypeDef
funcType_
)
)
;
MOZ_ASSERT
(
q
-
>
tag_
=
=
IsFuncType
)
;
return
q
;
}
const
StructType
&
structType
(
)
const
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
StructType
&
structType
(
)
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
static
const
TypeDef
*
fromStructPtr
(
const
StructType
*
p
)
{
const
TypeDef
*
q
=
(
const
TypeDef
*
)
(
(
char
*
)
p
-
offsetof
(
TypeDef
structType_
)
)
;
MOZ_ASSERT
(
q
-
>
tag_
=
=
IsStructType
)
;
return
q
;
}
}
;
typedef
Vector
<
TypeDef
0
SystemAllocPolicy
>
TypeDefVector
;
class
BytecodeOffset
{
static
const
uint32_t
INVALID
=
-
1
;
uint32_t
offset_
;
public
:
BytecodeOffset
(
)
:
offset_
(
INVALID
)
{
}
explicit
BytecodeOffset
(
uint32_t
offset
)
:
offset_
(
offset
)
{
}
bool
isValid
(
)
const
{
return
offset_
!
=
INVALID
;
}
uint32_t
offset
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
offset_
;
}
}
;
struct
TrapSite
{
uint32_t
pcOffset
;
BytecodeOffset
bytecode
;
TrapSite
(
)
:
pcOffset
(
-
1
)
bytecode
(
)
{
}
TrapSite
(
uint32_t
pcOffset
BytecodeOffset
bytecode
)
:
pcOffset
(
pcOffset
)
bytecode
(
bytecode
)
{
}
void
offsetBy
(
uint32_t
offset
)
{
pcOffset
+
=
offset
;
}
}
;
WASM_DECLARE_POD_VECTOR
(
TrapSite
TrapSiteVector
)
struct
TrapSiteVectorArray
:
EnumeratedArray
<
Trap
Trap
:
:
Limit
TrapSiteVector
>
{
bool
empty
(
)
const
;
void
clear
(
)
;
void
swap
(
TrapSiteVectorArray
&
rhs
)
;
void
podResizeToFit
(
)
;
WASM_DECLARE_SERIALIZABLE
(
TrapSiteVectorArray
)
}
;
struct
TrapData
{
void
*
resumePC
;
void
*
unwoundPC
;
Trap
trap
;
uint32_t
bytecodeOffset
;
}
;
struct
Offsets
{
explicit
Offsets
(
uint32_t
begin
=
0
uint32_t
end
=
0
)
:
begin
(
begin
)
end
(
end
)
{
}
uint32_t
begin
;
uint32_t
end
;
}
;
struct
CallableOffsets
:
Offsets
{
MOZ_IMPLICIT
CallableOffsets
(
uint32_t
ret
=
0
)
:
Offsets
(
)
ret
(
ret
)
{
}
uint32_t
ret
;
}
;
struct
JitExitOffsets
:
CallableOffsets
{
MOZ_IMPLICIT
JitExitOffsets
(
)
:
CallableOffsets
(
)
untrustedFPStart
(
0
)
untrustedFPEnd
(
0
)
{
}
uint32_t
untrustedFPStart
;
uint32_t
untrustedFPEnd
;
}
;
struct
FuncOffsets
:
CallableOffsets
{
MOZ_IMPLICIT
FuncOffsets
(
)
:
CallableOffsets
(
)
normalEntry
(
0
)
tierEntry
(
0
)
{
}
uint32_t
normalEntry
;
uint32_t
tierEntry
;
}
;
typedef
Vector
<
FuncOffsets
0
SystemAllocPolicy
>
FuncOffsetsVector
;
class
CodeRange
{
public
:
enum
Kind
{
Function
InterpEntry
JitEntry
ImportInterpExit
ImportJitExit
BuiltinThunk
TrapExit
DebugTrap
FarJumpIsland
Throw
}
;
private
:
uint32_t
begin_
;
uint32_t
ret_
;
uint32_t
end_
;
union
{
struct
{
uint32_t
funcIndex_
;
union
{
struct
{
uint32_t
lineOrBytecode_
;
uint8_t
beginToNormalEntry_
;
uint8_t
beginToTierEntry_
;
}
func
;
struct
{
uint16_t
beginToUntrustedFPStart_
;
uint16_t
beginToUntrustedFPEnd_
;
}
jitExit
;
}
;
}
;
Trap
trap_
;
}
u
;
Kind
kind_
:
8
;
public
:
CodeRange
(
)
=
default
;
CodeRange
(
Kind
kind
Offsets
offsets
)
;
CodeRange
(
Kind
kind
uint32_t
funcIndex
Offsets
offsets
)
;
CodeRange
(
Kind
kind
CallableOffsets
offsets
)
;
CodeRange
(
Kind
kind
uint32_t
funcIndex
CallableOffsets
)
;
CodeRange
(
uint32_t
funcIndex
JitExitOffsets
offsets
)
;
CodeRange
(
uint32_t
funcIndex
uint32_t
lineOrBytecode
FuncOffsets
offsets
)
;
void
offsetBy
(
uint32_t
offset
)
{
begin_
+
=
offset
;
end_
+
=
offset
;
if
(
hasReturn
(
)
)
{
ret_
+
=
offset
;
}
}
uint32_t
begin
(
)
const
{
return
begin_
;
}
uint32_t
end
(
)
const
{
return
end_
;
}
Kind
kind
(
)
const
{
return
kind_
;
}
bool
isFunction
(
)
const
{
return
kind
(
)
=
=
Function
;
}
bool
isImportExit
(
)
const
{
return
kind
(
)
=
=
ImportJitExit
|
|
kind
(
)
=
=
ImportInterpExit
|
|
kind
(
)
=
=
BuiltinThunk
;
}
bool
isImportInterpExit
(
)
const
{
return
kind
(
)
=
=
ImportInterpExit
;
}
bool
isImportJitExit
(
)
const
{
return
kind
(
)
=
=
ImportJitExit
;
}
bool
isTrapExit
(
)
const
{
return
kind
(
)
=
=
TrapExit
;
}
bool
isDebugTrap
(
)
const
{
return
kind
(
)
=
=
DebugTrap
;
}
bool
isThunk
(
)
const
{
return
kind
(
)
=
=
FarJumpIsland
;
}
bool
hasReturn
(
)
const
{
return
isFunction
(
)
|
|
isImportExit
(
)
|
|
isDebugTrap
(
)
;
}
uint32_t
ret
(
)
const
{
MOZ_ASSERT
(
hasReturn
(
)
)
;
return
ret_
;
}
bool
isJitEntry
(
)
const
{
return
kind
(
)
=
=
JitEntry
;
}
bool
isInterpEntry
(
)
const
{
return
kind
(
)
=
=
InterpEntry
;
}
bool
isEntry
(
)
const
{
return
isInterpEntry
(
)
|
|
isJitEntry
(
)
;
}
bool
hasFuncIndex
(
)
const
{
return
isFunction
(
)
|
|
isImportExit
(
)
|
|
isEntry
(
)
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
hasFuncIndex
(
)
)
;
return
u
.
funcIndex_
;
}
Trap
trap
(
)
const
{
MOZ_ASSERT
(
isTrapExit
(
)
)
;
return
u
.
trap_
;
}
uint32_t
funcTableEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
;
}
uint32_t
funcNormalEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
u
.
func
.
beginToNormalEntry_
;
}
uint32_t
funcTierEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
u
.
func
.
beginToTierEntry_
;
}
uint32_t
funcLineOrBytecode
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
u
.
func
.
lineOrBytecode_
;
}
uint32_t
jitExitUntrustedFPStart
(
)
const
{
MOZ_ASSERT
(
isImportJitExit
(
)
)
;
return
begin_
+
u
.
jitExit
.
beginToUntrustedFPStart_
;
}
uint32_t
jitExitUntrustedFPEnd
(
)
const
{
MOZ_ASSERT
(
isImportJitExit
(
)
)
;
return
begin_
+
u
.
jitExit
.
beginToUntrustedFPEnd_
;
}
struct
OffsetInCode
{
size_t
offset
;
explicit
OffsetInCode
(
size_t
offset
)
:
offset
(
offset
)
{
}
bool
operator
=
=
(
const
CodeRange
&
rhs
)
const
{
return
offset
>
=
rhs
.
begin
(
)
&
&
offset
<
rhs
.
end
(
)
;
}
bool
operator
<
(
const
CodeRange
&
rhs
)
const
{
return
offset
<
rhs
.
begin
(
)
;
}
}
;
}
;
WASM_DECLARE_POD_VECTOR
(
CodeRange
CodeRangeVector
)
extern
const
CodeRange
*
LookupInSorted
(
const
CodeRangeVector
&
codeRanges
CodeRange
:
:
OffsetInCode
target
)
;
class
CallSiteDesc
{
static
constexpr
size_t
LINE_OR_BYTECODE_BITS_SIZE
=
29
;
uint32_t
lineOrBytecode_
:
LINE_OR_BYTECODE_BITS_SIZE
;
uint32_t
kind_
:
3
;
public
:
static
constexpr
uint32_t
MAX_LINE_OR_BYTECODE_VALUE
=
(
1
<
<
LINE_OR_BYTECODE_BITS_SIZE
)
-
1
;
enum
Kind
{
Func
Dynamic
Symbolic
EnterFrame
LeaveFrame
Breakpoint
}
;
CallSiteDesc
(
)
:
lineOrBytecode_
(
0
)
kind_
(
0
)
{
}
explicit
CallSiteDesc
(
Kind
kind
)
:
lineOrBytecode_
(
0
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
=
=
Kind
(
kind_
)
)
;
}
CallSiteDesc
(
uint32_t
lineOrBytecode
Kind
kind
)
:
lineOrBytecode_
(
lineOrBytecode
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
=
=
Kind
(
kind_
)
)
;
MOZ_ASSERT
(
lineOrBytecode
=
=
lineOrBytecode_
)
;
}
uint32_t
lineOrBytecode
(
)
const
{
return
lineOrBytecode_
;
}
Kind
kind
(
)
const
{
return
Kind
(
kind_
)
;
}
}
;
class
CallSite
:
public
CallSiteDesc
{
uint32_t
returnAddressOffset_
;
public
:
CallSite
(
)
:
returnAddressOffset_
(
0
)
{
}
CallSite
(
CallSiteDesc
desc
uint32_t
returnAddressOffset
)
:
CallSiteDesc
(
desc
)
returnAddressOffset_
(
returnAddressOffset
)
{
}
void
offsetBy
(
int32_t
delta
)
{
returnAddressOffset_
+
=
delta
;
}
uint32_t
returnAddressOffset
(
)
const
{
return
returnAddressOffset_
;
}
}
;
WASM_DECLARE_POD_VECTOR
(
CallSite
CallSiteVector
)
class
CallSiteTarget
{
uint32_t
packed_
;
#
ifdef
DEBUG
enum
Kind
{
None
FuncIndex
TrapExit
}
kind_
;
#
endif
public
:
explicit
CallSiteTarget
(
)
:
packed_
(
UINT32_MAX
)
#
ifdef
DEBUG
kind_
(
None
)
#
endif
{
}
explicit
CallSiteTarget
(
uint32_t
funcIndex
)
:
packed_
(
funcIndex
)
#
ifdef
DEBUG
kind_
(
FuncIndex
)
#
endif
{
}
explicit
CallSiteTarget
(
Trap
trap
)
:
packed_
(
uint32_t
(
trap
)
)
#
ifdef
DEBUG
kind_
(
TrapExit
)
#
endif
{
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
FuncIndex
)
;
return
packed_
;
}
Trap
trap
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
TrapExit
)
;
MOZ_ASSERT
(
packed_
<
uint32_t
(
Trap
:
:
Limit
)
)
;
return
Trap
(
packed_
)
;
}
}
;
typedef
Vector
<
CallSiteTarget
0
SystemAllocPolicy
>
CallSiteTargetVector
;
enum
class
SymbolicAddress
{
ToInt32
#
if
defined
(
JS_CODEGEN_ARM
)
aeabi_idivmod
aeabi_uidivmod
#
endif
ModD
SinD
CosD
TanD
ASinD
ACosD
ATanD
CeilD
CeilF
FloorD
FloorF
TruncD
TruncF
NearbyIntD
NearbyIntF
ExpD
LogD
PowD
ATan2D
HandleDebugTrap
HandleThrow
HandleTrap
ReportInt64JSCall
CallImport_Void
CallImport_I32
CallImport_I64
CallImport_F64
CallImport_FuncRef
CallImport_AnyRef
CoerceInPlace_ToInt32
CoerceInPlace_ToNumber
CoerceInPlace_JitEntry
DivI64
UDivI64
ModI64
UModI64
TruncateDoubleToInt64
TruncateDoubleToUint64
SaturatingTruncateDoubleToInt64
SaturatingTruncateDoubleToUint64
Uint64ToFloat32
Uint64ToDouble
Int64ToFloat32
Int64ToDouble
MemoryGrow
MemorySize
WaitI32
WaitI64
Wake
MemCopy
MemCopyShared
DataDrop
MemFill
MemFillShared
MemInit
TableCopy
ElemDrop
TableFill
TableGet
TableGrow
TableInit
TableSet
TableSize
FuncRef
PostBarrier
PostBarrierFiltering
StructNew
StructNarrow
#
if
defined
(
JS_CODEGEN_MIPS32
)
js_jit_gAtomic64Lock
#
endif
#
ifdef
WASM_CODEGEN_DEBUG
PrintI32
PrintPtr
PrintF32
PrintF64
PrintText
#
endif
Limit
}
;
enum
class
FailureMode
:
uint8_t
{
Infallible
FailOnNegI32
FailOnNullPtr
FailOnInvalidRef
}
;
static
constexpr
size_t
SymbolicAddressSignatureMaxArgs
=
6
;
struct
SymbolicAddressSignature
{
const
SymbolicAddress
identity
;
const
jit
:
:
MIRType
retType
;
const
FailureMode
failureMode
;
const
uint8_t
numArgs
;
const
jit
:
:
MIRType
argTypes
[
SymbolicAddressSignatureMaxArgs
+
1
]
;
}
;
static_assert
(
sizeof
(
SymbolicAddressSignature
)
<
=
16
"
SymbolicAddressSignature
unexpectedly
large
"
)
;
bool
IsRoundingFunction
(
SymbolicAddress
callee
jit
:
:
RoundingMode
*
mode
)
;
struct
Limits
{
uint32_t
initial
;
Maybe
<
uint32_t
>
maximum
;
Shareable
shared
;
Limits
(
)
=
default
;
explicit
Limits
(
uint32_t
initial
const
Maybe
<
uint32_t
>
&
maximum
=
Nothing
(
)
Shareable
shared
=
Shareable
:
:
False
)
:
initial
(
initial
)
maximum
(
maximum
)
shared
(
shared
)
{
}
}
;
enum
class
TableKind
{
AnyRef
FuncRef
AsmJS
}
;
static
inline
ValType
ToElemValType
(
TableKind
tk
)
{
switch
(
tk
)
{
case
TableKind
:
:
AnyRef
:
return
ValType
:
:
AnyRef
;
case
TableKind
:
:
FuncRef
:
return
ValType
:
:
FuncRef
;
case
TableKind
:
:
AsmJS
:
break
;
}
MOZ_CRASH
(
"
not
used
for
asm
.
js
"
)
;
}
struct
TableDesc
{
TableKind
kind
;
bool
importedOrExported
;
uint32_t
globalDataOffset
;
Limits
limits
;
TableDesc
(
)
=
default
;
TableDesc
(
TableKind
kind
const
Limits
&
limits
bool
importedOrExported
=
false
)
:
kind
(
kind
)
importedOrExported
(
importedOrExported
)
globalDataOffset
(
UINT32_MAX
)
limits
(
limits
)
{
}
}
;
typedef
Vector
<
TableDesc
0
SystemAllocPolicy
>
TableDescVector
;
struct
TlsData
{
uint8_t
*
memoryBase
;
uint32_t
boundsCheckLimit
;
Instance
*
instance
;
JS
:
:
Realm
*
realm
;
JSContext
*
cx
;
Atomic
<
uintptr_t
mozilla
:
:
Relaxed
>
stackLimit
;
Atomic
<
uint32_t
mozilla
:
:
Relaxed
>
interrupt
;
uint8_t
*
addressOfNeedsIncrementalBarrier
;
void
setInterrupt
(
)
;
bool
isInterrupted
(
)
const
;
void
resetInterrupt
(
JSContext
*
cx
)
;
void
*
allocatedBase
;
void
*
*
jumpTable
;
MOZ_ALIGNED_DECL
(
char
globalArea
16
)
;
}
;
static
const
size_t
TlsDataAlign
=
16
;
static_assert
(
offsetof
(
TlsData
globalArea
)
%
TlsDataAlign
=
=
0
"
aligned
"
)
;
struct
TlsDataDeleter
{
void
operator
(
)
(
TlsData
*
tlsData
)
{
js_free
(
tlsData
-
>
allocatedBase
)
;
}
}
;
typedef
UniquePtr
<
TlsData
TlsDataDeleter
>
UniqueTlsData
;
extern
UniqueTlsData
CreateTlsData
(
uint32_t
globalDataLength
)
;
struct
ExportArg
{
uint64_t
lo
;
uint64_t
hi
;
}
;
typedef
int32_t
(
*
ExportFuncPtr
)
(
ExportArg
*
args
TlsData
*
tls
)
;
struct
FuncImportTls
{
void
*
code
;
TlsData
*
tls
;
JS
:
:
Realm
*
realm
;
jit
:
:
JitScript
*
jitScript
;
GCPtrFunction
fun
;
static_assert
(
sizeof
(
GCPtrFunction
)
=
=
sizeof
(
void
*
)
"
for
JIT
access
"
)
;
}
;
struct
TableTls
{
uint32_t
length
;
void
*
functionBase
;
}
;
struct
FunctionTableElem
{
void
*
code
;
TlsData
*
tls
;
}
;
class
CalleeDesc
{
public
:
enum
Which
{
Func
Import
WasmTable
AsmJSTable
Builtin
BuiltinInstanceMethod
}
;
private
:
MOZ_INIT_OUTSIDE_CTOR
Which
which_
;
union
U
{
U
(
)
:
funcIndex_
(
0
)
{
}
uint32_t
funcIndex_
;
struct
{
uint32_t
globalDataOffset_
;
}
import
;
struct
{
uint32_t
globalDataOffset_
;
uint32_t
minLength_
;
FuncTypeIdDesc
funcTypeId_
;
}
table
;
SymbolicAddress
builtin_
;
}
u
;
public
:
CalleeDesc
(
)
{
}
static
CalleeDesc
function
(
uint32_t
funcIndex
)
{
CalleeDesc
c
;
c
.
which_
=
Func
;
c
.
u
.
funcIndex_
=
funcIndex
;
return
c
;
}
static
CalleeDesc
import
(
uint32_t
globalDataOffset
)
{
CalleeDesc
c
;
c
.
which_
=
Import
;
c
.
u
.
import
.
globalDataOffset_
=
globalDataOffset
;
return
c
;
}
static
CalleeDesc
wasmTable
(
const
TableDesc
&
desc
FuncTypeIdDesc
funcTypeId
)
{
CalleeDesc
c
;
c
.
which_
=
WasmTable
;
c
.
u
.
table
.
globalDataOffset_
=
desc
.
globalDataOffset
;
c
.
u
.
table
.
minLength_
=
desc
.
limits
.
initial
;
c
.
u
.
table
.
funcTypeId_
=
funcTypeId
;
return
c
;
}
static
CalleeDesc
asmJSTable
(
const
TableDesc
&
desc
)
{
CalleeDesc
c
;
c
.
which_
=
AsmJSTable
;
c
.
u
.
table
.
globalDataOffset_
=
desc
.
globalDataOffset
;
return
c
;
}
static
CalleeDesc
builtin
(
SymbolicAddress
callee
)
{
CalleeDesc
c
;
c
.
which_
=
Builtin
;
c
.
u
.
builtin_
=
callee
;
return
c
;
}
static
CalleeDesc
builtinInstanceMethod
(
SymbolicAddress
callee
)
{
CalleeDesc
c
;
c
.
which_
=
BuiltinInstanceMethod
;
c
.
u
.
builtin_
=
callee
;
return
c
;
}
Which
which
(
)
const
{
return
which_
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Func
)
;
return
u
.
funcIndex_
;
}
uint32_t
importGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Import
)
;
return
u
.
import
.
globalDataOffset_
;
}
bool
isTable
(
)
const
{
return
which_
=
=
WasmTable
|
|
which_
=
=
AsmJSTable
;
}
uint32_t
tableLengthGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
isTable
(
)
)
;
return
u
.
table
.
globalDataOffset_
+
offsetof
(
TableTls
length
)
;
}
uint32_t
tableFunctionBaseGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
isTable
(
)
)
;
return
u
.
table
.
globalDataOffset_
+
offsetof
(
TableTls
functionBase
)
;
}
FuncTypeIdDesc
wasmTableSigId
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
funcTypeId_
;
}
uint32_t
wasmTableMinLength
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
minLength_
;
}
SymbolicAddress
builtin
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Builtin
|
|
which_
=
=
BuiltinInstanceMethod
)
;
return
u
.
builtin_
;
}
}
;
extern
bool
IsValidARMImmediate
(
uint32_t
i
)
;
extern
uint32_t
RoundUpToNextValidARMImmediate
(
uint32_t
i
)
;
static
const
unsigned
PageSize
=
64
*
1024
;
static
const
unsigned
MaxMemoryAccessSize
=
LitVal
:
:
sizeofLargestValue
(
)
;
#
ifdef
WASM_SUPPORTS_HUGE_MEMORY
static
const
uint64_t
HugeIndexRange
=
uint64_t
(
UINT32_MAX
)
+
1
;
static
const
uint64_t
HugeOffsetGuardLimit
=
uint64_t
(
INT32_MAX
)
+
1
;
static
const
uint64_t
HugeUnalignedGuardPage
=
PageSize
;
static
const
uint64_t
HugeMappedSize
=
HugeIndexRange
+
HugeOffsetGuardLimit
+
HugeUnalignedGuardPage
;
static_assert
(
MaxMemoryAccessSize
<
=
HugeUnalignedGuardPage
"
rounded
up
to
static
page
size
"
)
;
static_assert
(
HugeOffsetGuardLimit
<
UINT32_MAX
"
checking
for
overflow
against
OffsetGuardLimit
is
enough
.
"
)
;
#
endif
static
const
size_t
OffsetGuardLimit
=
PageSize
-
MaxMemoryAccessSize
;
static
const
size_t
GuardSize
=
PageSize
;
static_assert
(
MaxMemoryAccessSize
<
GuardSize
"
Guard
page
handles
partial
out
-
of
-
bounds
"
)
;
static_assert
(
OffsetGuardLimit
<
UINT32_MAX
"
checking
for
overflow
against
OffsetGuardLimit
is
enough
.
"
)
;
static
constexpr
size_t
GetOffsetGuardLimit
(
bool
hugeMemory
)
{
#
ifdef
WASM_SUPPORTS_HUGE_MEMORY
return
hugeMemory
?
HugeOffsetGuardLimit
:
OffsetGuardLimit
;
#
else
return
OffsetGuardLimit
;
#
endif
}
#
ifdef
WASM_SUPPORTS_HUGE_MEMORY
static
const
size_t
MaxOffsetGuardLimit
=
HugeOffsetGuardLimit
;
static
const
size_t
MinOffsetGuardLimit
=
OffsetGuardLimit
;
#
else
static
const
size_t
MaxOffsetGuardLimit
=
OffsetGuardLimit
;
static
const
size_t
MinOffsetGuardLimit
=
OffsetGuardLimit
;
#
endif
extern
bool
IsValidBoundsCheckImmediate
(
uint32_t
i
)
;
extern
size_t
ComputeMappedSize
(
uint32_t
maxSize
)
;
#
if
defined
(
JS_CODEGEN_X64
)
|
|
defined
(
JS_CODEGEN_ARM64
)
static
const
uint32_t
MaxInlineMemoryCopyLength
=
64
;
static
const
uint32_t
MaxInlineMemoryFillLength
=
64
;
#
elif
defined
(
JS_CODEGEN_X86
)
static
const
uint32_t
MaxInlineMemoryCopyLength
=
32
;
static
const
uint32_t
MaxInlineMemoryFillLength
=
32
;
#
else
static
const
uint32_t
MaxInlineMemoryCopyLength
=
0
;
static
const
uint32_t
MaxInlineMemoryFillLength
=
0
;
#
endif
static_assert
(
MaxInlineMemoryCopyLength
<
MinOffsetGuardLimit
"
precondition
"
)
;
static_assert
(
MaxInlineMemoryFillLength
<
MinOffsetGuardLimit
"
precondition
"
)
;
struct
Frame
{
Frame
*
callerFP
;
TlsData
*
tls
;
#
if
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_ARM64
)
uintptr_t
padding_
;
#
endif
void
*
returnAddress
;
Instance
*
instance
(
)
const
{
return
tls
-
>
instance
;
}
}
;
#
if
defined
(
JS_CODEGEN_ARM64
)
static_assert
(
sizeof
(
Frame
)
%
16
=
=
0
"
frame
size
"
)
;
#
endif
class
DebugFrame
{
union
{
int32_t
resultI32_
;
int64_t
resultI64_
;
intptr_t
resultRef_
;
AnyRef
resultAnyRef_
;
float
resultF32_
;
double
resultF64_
;
}
;
js
:
:
Value
cachedReturnJSValue_
;
uint32_t
funcIndex_
;
union
{
struct
{
bool
observing_
:
1
;
bool
isDebuggee_
:
1
;
bool
prevUpToDate_
:
1
;
bool
hasCachedSavedFrame_
:
1
;
bool
hasCachedReturnJSValue_
:
1
;
}
;
void
*
flagsWord_
;
}
;
protected
:
#
if
JS_BITS_PER_WORD
=
=
32
&
&
!
defined
(
JS_CODEGEN_MIPS32
)
uint32_t
padding_
;
#
endif
private
:
Frame
frame_
;
public
:
static
DebugFrame
*
from
(
Frame
*
fp
)
;
Frame
&
frame
(
)
{
return
frame_
;
}
uint32_t
funcIndex
(
)
const
{
return
funcIndex_
;
}
Instance
*
instance
(
)
const
{
return
frame_
.
instance
(
)
;
}
GlobalObject
*
global
(
)
const
;
bool
hasGlobal
(
const
GlobalObject
*
global
)
const
;
JSObject
*
environmentChain
(
)
const
;
bool
getLocal
(
uint32_t
localIndex
MutableHandleValue
vp
)
;
bool
hasCachedReturnJSValue
(
)
const
{
return
hasCachedReturnJSValue_
;
}
MOZ_MUST_USE
bool
updateReturnJSValue
(
)
;
HandleValue
returnValue
(
)
const
;
void
clearReturnJSValue
(
)
;
void
observe
(
JSContext
*
cx
)
;
void
leave
(
JSContext
*
cx
)
;
bool
isDebuggee
(
)
const
{
return
isDebuggee_
;
}
void
setIsDebuggee
(
)
{
isDebuggee_
=
true
;
}
void
unsetIsDebuggee
(
)
{
isDebuggee_
=
false
;
}
bool
prevUpToDate
(
)
const
{
return
prevUpToDate_
;
}
void
setPrevUpToDate
(
)
{
prevUpToDate_
=
true
;
}
void
unsetPrevUpToDate
(
)
{
prevUpToDate_
=
false
;
}
bool
hasCachedSavedFrame
(
)
const
{
return
hasCachedSavedFrame_
;
}
void
setHasCachedSavedFrame
(
)
{
hasCachedSavedFrame_
=
true
;
}
void
clearHasCachedSavedFrame
(
)
{
hasCachedSavedFrame_
=
false
;
}
static
constexpr
size_t
offsetOfResults
(
)
{
return
offsetof
(
DebugFrame
resultI32_
)
;
}
static
constexpr
size_t
offsetOfCachedReturnJSValue
(
)
{
return
offsetof
(
DebugFrame
cachedReturnJSValue_
)
;
}
static
constexpr
size_t
offsetOfFlagsWord
(
)
{
return
offsetof
(
DebugFrame
flagsWord_
)
;
}
static
constexpr
size_t
offsetOfFuncIndex
(
)
{
return
offsetof
(
DebugFrame
funcIndex_
)
;
}
static
constexpr
size_t
offsetOfFrame
(
)
{
return
offsetof
(
DebugFrame
frame_
)
;
}
static
const
unsigned
Alignment
=
8
;
static
void
alignmentStaticAsserts
(
)
;
}
;
extern
void
Log
(
JSContext
*
cx
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
enum
class
DebugChannel
{
Function
Import
}
;
#
ifdef
WASM_CODEGEN_DEBUG
bool
IsCodegenDebugEnabled
(
DebugChannel
channel
)
;
#
endif
void
DebugCodegen
(
DebugChannel
channel
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
typedef
void
(
*
PrintCallback
)
(
const
char
*
text
)
;
}
}
#
endif
