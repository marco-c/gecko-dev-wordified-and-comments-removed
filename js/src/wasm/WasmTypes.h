#
ifndef
wasm_types_h
#
define
wasm_types_h
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
type_traits
>
#
include
"
NamespaceImports
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
js
/
RefCounted
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
MallocProvider
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmUtility
.
h
"
namespace
js
{
namespace
jit
{
enum
class
RoundingMode
;
template
<
class
VecT
class
ABIArgGeneratorT
>
class
ABIArgIterBase
;
}
typedef
GCVector
<
JSFunction
*
0
SystemAllocPolicy
>
JSFunctionVector
;
class
WasmMemoryObject
;
using
GCPtrWasmMemoryObject
=
GCPtr
<
WasmMemoryObject
*
>
;
using
RootedWasmMemoryObject
=
Rooted
<
WasmMemoryObject
*
>
;
using
HandleWasmMemoryObject
=
Handle
<
WasmMemoryObject
*
>
;
using
MutableHandleWasmMemoryObject
=
MutableHandle
<
WasmMemoryObject
*
>
;
class
WasmModuleObject
;
using
RootedWasmModuleObject
=
Rooted
<
WasmModuleObject
*
>
;
using
HandleWasmModuleObject
=
Handle
<
WasmModuleObject
*
>
;
using
MutableHandleWasmModuleObject
=
MutableHandle
<
WasmModuleObject
*
>
;
class
WasmInstanceObject
;
using
WasmInstanceObjectVector
=
GCVector
<
WasmInstanceObject
*
>
;
using
RootedWasmInstanceObject
=
Rooted
<
WasmInstanceObject
*
>
;
using
HandleWasmInstanceObject
=
Handle
<
WasmInstanceObject
*
>
;
using
MutableHandleWasmInstanceObject
=
MutableHandle
<
WasmInstanceObject
*
>
;
class
WasmTableObject
;
typedef
GCVector
<
WasmTableObject
*
0
SystemAllocPolicy
>
WasmTableObjectVector
;
using
RootedWasmTableObject
=
Rooted
<
WasmTableObject
*
>
;
using
HandleWasmTableObject
=
Handle
<
WasmTableObject
*
>
;
using
MutableHandleWasmTableObject
=
MutableHandle
<
WasmTableObject
*
>
;
class
WasmGlobalObject
;
typedef
GCVector
<
WasmGlobalObject
*
0
SystemAllocPolicy
>
WasmGlobalObjectVector
;
using
RootedWasmGlobalObject
=
Rooted
<
WasmGlobalObject
*
>
;
class
WasmExceptionObject
;
typedef
GCVector
<
WasmExceptionObject
*
0
SystemAllocPolicy
>
WasmExceptionObjectVector
;
using
RootedWasmExceptionObject
=
Rooted
<
WasmExceptionObject
*
>
;
class
WasmRuntimeExceptionObject
;
using
RootedWasmRuntimeExceptionObject
=
Rooted
<
WasmRuntimeExceptionObject
*
>
;
namespace
wasm
{
using
mozilla
:
:
Atomic
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
EnumeratedArray
;
using
mozilla
:
:
MallocSizeOf
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
PodZero
;
using
mozilla
:
:
Some
;
using
mozilla
:
:
Unused
;
class
Code
;
class
DebugState
;
class
GeneratedSourceMap
;
class
Memory
;
class
Module
;
class
Instance
;
class
Table
;
typedef
Vector
<
uint32_t
8
SystemAllocPolicy
>
Uint32Vector
;
typedef
Vector
<
uint8_t
0
SystemAllocPolicy
>
Bytes
;
using
UniqueBytes
=
UniquePtr
<
Bytes
>
;
using
UniqueConstBytes
=
UniquePtr
<
const
Bytes
>
;
typedef
Vector
<
char
0
SystemAllocPolicy
>
UTF8Bytes
;
typedef
Vector
<
Instance
*
0
SystemAllocPolicy
>
InstanceVector
;
typedef
Vector
<
UniqueChars
0
SystemAllocPolicy
>
UniqueCharsVector
;
typedef
HashMap
<
uint32_t
uint32_t
DefaultHasher
<
uint32_t
>
SystemAllocPolicy
>
RenumberMap
;
constexpr
uintptr_t
ExitOrJitEntryFPTag
=
0x1
;
#
define
WASM_DECLARE_POD_VECTOR
(
Type
VectorName
)
\
}
\
}
\
namespace
mozilla
{
\
template
<
>
\
struct
IsPod
<
js
:
:
wasm
:
:
Type
>
:
std
:
:
true_type
{
}
;
\
}
\
namespace
js
{
\
namespace
wasm
{
\
typedef
Vector
<
Type
0
SystemAllocPolicy
>
VectorName
;
#
define
WASM_DECLARE_SERIALIZABLE
(
Type
)
\
size_t
serializedSize
(
)
const
;
\
uint8_t
*
serialize
(
uint8_t
*
cursor
)
const
;
\
const
uint8_t
*
deserialize
(
const
uint8_t
*
cursor
)
;
\
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
template
<
class
T
>
struct
SerializableRefPtr
:
RefPtr
<
T
>
{
using
RefPtr
<
T
>
:
:
operator
=
;
SerializableRefPtr
(
)
=
default
;
template
<
class
U
>
MOZ_IMPLICIT
SerializableRefPtr
(
U
&
&
u
)
:
RefPtr
<
T
>
(
std
:
:
forward
<
U
>
(
u
)
)
{
}
WASM_DECLARE_SERIALIZABLE
(
SerializableRefPtr
)
}
;
template
<
class
T
>
struct
ShareableBase
:
AtomicRefCounted
<
T
>
{
using
SeenSet
=
HashSet
<
const
T
*
DefaultHasher
<
const
T
*
>
SystemAllocPolicy
>
;
size_t
sizeOfIncludingThisIfNotSeen
(
MallocSizeOf
mallocSizeOf
SeenSet
*
seen
)
const
{
const
T
*
self
=
static_cast
<
const
T
*
>
(
this
)
;
typename
SeenSet
:
:
AddPtr
p
=
seen
-
>
lookupForAdd
(
self
)
;
if
(
p
)
{
return
0
;
}
bool
ok
=
seen
-
>
add
(
p
self
)
;
(
void
)
ok
;
return
mallocSizeOf
(
self
)
+
self
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
struct
ShareableBytes
:
ShareableBase
<
ShareableBytes
>
{
Bytes
bytes
;
ShareableBytes
(
)
=
default
;
explicit
ShareableBytes
(
Bytes
&
&
bytes
)
:
bytes
(
std
:
:
move
(
bytes
)
)
{
}
size_t
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
bytes
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
const
uint8_t
*
begin
(
)
const
{
return
bytes
.
begin
(
)
;
}
const
uint8_t
*
end
(
)
const
{
return
bytes
.
end
(
)
;
}
size_t
length
(
)
const
{
return
bytes
.
length
(
)
;
}
bool
append
(
const
uint8_t
*
start
size_t
len
)
{
return
bytes
.
append
(
start
len
)
;
}
}
;
using
MutableBytes
=
RefPtr
<
ShareableBytes
>
;
using
SharedBytes
=
RefPtr
<
const
ShareableBytes
>
;
class
Opcode
{
uint32_t
bits_
;
public
:
MOZ_IMPLICIT
Opcode
(
Op
op
)
:
bits_
(
uint32_t
(
op
)
)
{
static_assert
(
size_t
(
Op
:
:
Limit
)
=
=
256
"
fits
"
)
;
MOZ_ASSERT
(
size_t
(
op
)
<
size_t
(
Op
:
:
Limit
)
)
;
}
MOZ_IMPLICIT
Opcode
(
MiscOp
op
)
:
bits_
(
(
uint32_t
(
op
)
<
<
8
)
|
uint32_t
(
Op
:
:
MiscPrefix
)
)
{
static_assert
(
size_t
(
MiscOp
:
:
Limit
)
<
=
0xFFFFFF
"
fits
"
)
;
MOZ_ASSERT
(
size_t
(
op
)
<
size_t
(
MiscOp
:
:
Limit
)
)
;
}
MOZ_IMPLICIT
Opcode
(
ThreadOp
op
)
:
bits_
(
(
uint32_t
(
op
)
<
<
8
)
|
uint32_t
(
Op
:
:
ThreadPrefix
)
)
{
static_assert
(
size_t
(
ThreadOp
:
:
Limit
)
<
=
0xFFFFFF
"
fits
"
)
;
MOZ_ASSERT
(
size_t
(
op
)
<
size_t
(
ThreadOp
:
:
Limit
)
)
;
}
MOZ_IMPLICIT
Opcode
(
MozOp
op
)
:
bits_
(
(
uint32_t
(
op
)
<
<
8
)
|
uint32_t
(
Op
:
:
MozPrefix
)
)
{
static_assert
(
size_t
(
MozOp
:
:
Limit
)
<
=
0xFFFFFF
"
fits
"
)
;
MOZ_ASSERT
(
size_t
(
op
)
<
size_t
(
MozOp
:
:
Limit
)
)
;
}
MOZ_IMPLICIT
Opcode
(
SimdOp
op
)
:
bits_
(
(
uint32_t
(
op
)
<
<
8
)
|
uint32_t
(
Op
:
:
SimdPrefix
)
)
{
static_assert
(
size_t
(
SimdOp
:
:
Limit
)
<
=
0xFFFFFF
"
fits
"
)
;
MOZ_ASSERT
(
size_t
(
op
)
<
size_t
(
SimdOp
:
:
Limit
)
)
;
}
bool
isOp
(
)
const
{
return
bits_
<
uint32_t
(
Op
:
:
FirstPrefix
)
;
}
bool
isMisc
(
)
const
{
return
(
bits_
&
255
)
=
=
uint32_t
(
Op
:
:
MiscPrefix
)
;
}
bool
isThread
(
)
const
{
return
(
bits_
&
255
)
=
=
uint32_t
(
Op
:
:
ThreadPrefix
)
;
}
bool
isMoz
(
)
const
{
return
(
bits_
&
255
)
=
=
uint32_t
(
Op
:
:
MozPrefix
)
;
}
bool
isSimd
(
)
const
{
return
(
bits_
&
255
)
=
=
uint32_t
(
Op
:
:
SimdPrefix
)
;
}
Op
asOp
(
)
const
{
MOZ_ASSERT
(
isOp
(
)
)
;
return
Op
(
bits_
)
;
}
MiscOp
asMisc
(
)
const
{
MOZ_ASSERT
(
isMisc
(
)
)
;
return
MiscOp
(
bits_
>
>
8
)
;
}
ThreadOp
asThread
(
)
const
{
MOZ_ASSERT
(
isThread
(
)
)
;
return
ThreadOp
(
bits_
>
>
8
)
;
}
MozOp
asMoz
(
)
const
{
MOZ_ASSERT
(
isMoz
(
)
)
;
return
MozOp
(
bits_
>
>
8
)
;
}
SimdOp
asSimd
(
)
const
{
MOZ_ASSERT
(
isSimd
(
)
)
;
return
SimdOp
(
bits_
>
>
8
)
;
}
uint32_t
bits
(
)
const
{
return
bits_
;
}
bool
operator
=
=
(
const
Opcode
&
that
)
const
{
return
bits_
=
=
that
.
bits_
;
}
bool
operator
!
=
(
const
Opcode
&
that
)
const
{
return
bits_
!
=
that
.
bits_
;
}
}
;
union
PackedTypeCode
{
public
:
using
PackedRepr
=
uintptr_t
;
private
:
#
ifdef
JS_64BIT
static
constexpr
size_t
PointerTagBits
=
2
;
static
constexpr
size_t
TypeCodeBits
=
8
;
static
constexpr
size_t
TypeIndexBits
=
21
;
static
constexpr
size_t
NullableBits
=
1
;
static
constexpr
size_t
RttDepthBits
=
10
;
#
else
static
constexpr
size_t
PointerTagBits
=
2
;
static
constexpr
size_t
TypeCodeBits
=
8
;
static
constexpr
size_t
TypeIndexBits
=
14
;
static
constexpr
size_t
NullableBits
=
1
;
static
constexpr
size_t
RttDepthBits
=
7
;
#
endif
static_assert
(
PointerTagBits
+
TypeCodeBits
+
TypeIndexBits
+
NullableBits
+
RttDepthBits
<
=
(
sizeof
(
PackedRepr
)
*
8
)
"
enough
bits
"
)
;
static_assert
(
MaxTypeIndex
<
(
1
<
<
TypeIndexBits
)
"
enough
bits
"
)
;
static_assert
(
MaxRttDepth
<
(
1
<
<
RttDepthBits
)
"
enough
bits
"
)
;
PackedRepr
bits_
;
struct
{
PackedRepr
pointerTag_
:
PointerTagBits
;
PackedRepr
typeCode_
:
TypeCodeBits
;
PackedRepr
typeIndex_
:
TypeIndexBits
;
PackedRepr
nullable_
:
NullableBits
;
PackedRepr
rttDepth_
:
RttDepthBits
;
}
;
public
:
static
constexpr
uint32_t
NoTypeCode
=
(
1
<
<
TypeCodeBits
)
-
1
;
static
constexpr
uint32_t
NoTypeIndex
=
(
1
<
<
TypeIndexBits
)
-
1
;
static
PackedTypeCode
invalid
(
)
{
PackedTypeCode
ptc
=
{
}
;
ptc
.
typeCode_
=
NoTypeCode
;
return
ptc
;
}
static
constexpr
PackedTypeCode
fromBits
(
PackedRepr
bits
)
{
PackedTypeCode
ptc
=
{
}
;
ptc
.
bits_
=
bits
;
return
ptc
;
}
static
constexpr
PackedTypeCode
pack
(
TypeCode
tc
uint32_t
refTypeIndex
bool
isNullable
uint32_t
rttDepth
)
{
MOZ_ASSERT
(
uint32_t
(
tc
)
<
=
(
(
1
<
<
TypeCodeBits
)
-
1
)
)
;
MOZ_ASSERT_IF
(
tc
!
=
AbstractReferenceTypeIndexCode
&
&
tc
!
=
TypeCode
:
:
Rtt
refTypeIndex
=
=
NoTypeIndex
)
;
MOZ_ASSERT_IF
(
tc
=
=
AbstractReferenceTypeIndexCode
|
|
tc
=
=
TypeCode
:
:
Rtt
refTypeIndex
<
=
MaxTypeIndex
)
;
MOZ_ASSERT_IF
(
tc
!
=
TypeCode
:
:
Rtt
rttDepth
=
=
0
)
;
MOZ_ASSERT_IF
(
tc
=
=
TypeCode
:
:
Rtt
rttDepth
<
=
MaxRttDepth
)
;
PackedTypeCode
ptc
=
{
}
;
ptc
.
typeCode_
=
PackedRepr
(
tc
)
;
ptc
.
typeIndex_
=
refTypeIndex
;
ptc
.
nullable_
=
isNullable
;
ptc
.
rttDepth_
=
rttDepth
;
return
ptc
;
}
static
constexpr
PackedTypeCode
pack
(
TypeCode
tc
bool
nullable
)
{
return
pack
(
tc
PackedTypeCode
:
:
NoTypeIndex
nullable
0
)
;
}
static
constexpr
PackedTypeCode
pack
(
TypeCode
tc
)
{
return
pack
(
tc
PackedTypeCode
:
:
NoTypeIndex
false
0
)
;
}
bool
isValid
(
)
const
{
return
typeCode_
!
=
NoTypeCode
;
}
bool
isReference
(
)
const
{
return
typeCodeAbstracted
(
)
=
=
AbstractReferenceTypeCode
;
}
PackedRepr
bits
(
)
const
{
return
bits_
;
}
TypeCode
typeCode
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
TypeCode
(
typeCode_
)
;
}
TypeCode
typeCodeAbstracted
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
TypeCode
tc
=
TypeCode
(
typeCode_
)
;
return
(
tc
<
LowestPrimitiveTypeCode
&
&
tc
!
=
TypeCode
:
:
Rtt
)
?
AbstractReferenceTypeCode
:
tc
;
}
uint32_t
typeIndex
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
uint32_t
(
typeIndex_
)
;
}
uint32_t
typeIndexUnchecked
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
uint32_t
(
typeIndex_
)
;
}
bool
isNullable
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
bool
(
nullable_
)
;
}
uint32_t
rttDepth
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
uint32_t
(
rttDepth_
)
;
}
PackedTypeCode
asNonNullable
(
)
const
{
MOZ_ASSERT
(
isReference
(
)
)
;
PackedTypeCode
mutated
=
*
this
;
mutated
.
nullable_
=
0
;
return
mutated
;
}
bool
operator
=
=
(
const
PackedTypeCode
&
rhs
)
const
{
return
bits_
=
=
rhs
.
bits_
;
}
bool
operator
!
=
(
const
PackedTypeCode
&
rhs
)
const
{
return
bits_
!
=
rhs
.
bits_
;
}
}
;
static_assert
(
sizeof
(
PackedTypeCode
)
=
=
sizeof
(
uintptr_t
)
"
packed
"
)
;
static_assert
(
std
:
:
is_pod_v
<
PackedTypeCode
>
"
must
be
POD
to
be
simply
serialized
/
deserialized
"
)
;
enum
class
TableRepr
{
Ref
Func
}
;
class
RefType
{
public
:
enum
Kind
{
Func
=
uint8_t
(
TypeCode
:
:
FuncRef
)
Extern
=
uint8_t
(
TypeCode
:
:
ExternRef
)
Eq
=
uint8_t
(
TypeCode
:
:
EqRef
)
TypeIndex
=
uint8_t
(
AbstractReferenceTypeIndexCode
)
}
;
private
:
PackedTypeCode
ptc_
;
#
ifdef
DEBUG
bool
isValid
(
)
const
{
switch
(
ptc_
.
typeCode
(
)
)
{
case
TypeCode
:
:
FuncRef
:
case
TypeCode
:
:
ExternRef
:
case
TypeCode
:
:
EqRef
:
MOZ_ASSERT
(
ptc_
.
typeIndex
(
)
=
=
PackedTypeCode
:
:
NoTypeIndex
)
;
return
true
;
case
AbstractReferenceTypeIndexCode
:
MOZ_ASSERT
(
ptc_
.
typeIndex
(
)
!
=
PackedTypeCode
:
:
NoTypeIndex
)
;
return
true
;
default
:
return
false
;
}
}
#
endif
RefType
(
Kind
kind
bool
nullable
)
:
ptc_
(
PackedTypeCode
:
:
pack
(
TypeCode
(
kind
)
nullable
)
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
}
RefType
(
uint32_t
refTypeIndex
bool
nullable
)
:
ptc_
(
PackedTypeCode
:
:
pack
(
AbstractReferenceTypeIndexCode
refTypeIndex
nullable
0
)
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
}
public
:
RefType
(
)
:
ptc_
(
PackedTypeCode
:
:
invalid
(
)
)
{
}
explicit
RefType
(
PackedTypeCode
ptc
)
:
ptc_
(
ptc
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
}
static
RefType
fromTypeCode
(
TypeCode
tc
bool
nullable
)
{
MOZ_ASSERT
(
tc
!
=
AbstractReferenceTypeIndexCode
)
;
return
RefType
(
Kind
(
tc
)
nullable
)
;
}
static
RefType
fromTypeIndex
(
uint32_t
refTypeIndex
bool
nullable
)
{
return
RefType
(
refTypeIndex
nullable
)
;
}
Kind
kind
(
)
const
{
return
Kind
(
ptc_
.
typeCode
(
)
)
;
}
uint32_t
typeIndex
(
)
const
{
return
ptc_
.
typeIndex
(
)
;
}
PackedTypeCode
packed
(
)
const
{
return
ptc_
;
}
static
RefType
func
(
)
{
return
RefType
(
Func
true
)
;
}
static
RefType
extern_
(
)
{
return
RefType
(
Extern
true
)
;
}
static
RefType
eq
(
)
{
return
RefType
(
Eq
true
)
;
}
bool
isFunc
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
Func
;
}
bool
isExtern
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
Extern
;
}
bool
isEq
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
Eq
;
}
bool
isTypeIndex
(
)
const
{
return
kind
(
)
=
=
RefType
:
:
TypeIndex
;
}
bool
isNullable
(
)
const
{
return
bool
(
ptc_
.
isNullable
(
)
)
;
}
RefType
asNonNullable
(
)
const
{
return
RefType
(
ptc_
.
asNonNullable
(
)
)
;
}
TableRepr
tableRepr
(
)
const
{
switch
(
kind
(
)
)
{
case
RefType
:
:
Func
:
return
TableRepr
:
:
Func
;
case
RefType
:
:
Extern
:
case
RefType
:
:
Eq
:
return
TableRepr
:
:
Ref
;
case
RefType
:
:
TypeIndex
:
MOZ_CRASH
(
"
NYI
"
)
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
switch
is
exhaustive
"
)
;
}
bool
operator
=
=
(
const
RefType
&
that
)
const
{
return
ptc_
=
=
that
.
ptc_
;
}
bool
operator
!
=
(
const
RefType
&
that
)
const
{
return
ptc_
!
=
that
.
ptc_
;
}
}
;
class
FieldTypeTraits
{
public
:
enum
Kind
{
I8
=
uint8_t
(
TypeCode
:
:
I8
)
I16
=
uint8_t
(
TypeCode
:
:
I16
)
I32
=
uint8_t
(
TypeCode
:
:
I32
)
I64
=
uint8_t
(
TypeCode
:
:
I64
)
F32
=
uint8_t
(
TypeCode
:
:
F32
)
F64
=
uint8_t
(
TypeCode
:
:
F64
)
V128
=
uint8_t
(
TypeCode
:
:
V128
)
Rtt
=
uint8_t
(
TypeCode
:
:
Rtt
)
Ref
=
uint8_t
(
AbstractReferenceTypeCode
)
}
;
static
bool
isValidTypeCode
(
TypeCode
tc
)
{
switch
(
tc
)
{
case
TypeCode
:
:
I8
:
case
TypeCode
:
:
I16
:
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
case
TypeCode
:
:
V128
:
case
TypeCode
:
:
FuncRef
:
case
TypeCode
:
:
ExternRef
:
case
TypeCode
:
:
EqRef
:
case
TypeCode
:
:
Rtt
:
case
AbstractReferenceTypeIndexCode
:
return
true
;
default
:
return
false
;
}
}
}
;
class
ValTypeTraits
{
public
:
enum
Kind
{
I32
=
uint8_t
(
TypeCode
:
:
I32
)
I64
=
uint8_t
(
TypeCode
:
:
I64
)
F32
=
uint8_t
(
TypeCode
:
:
F32
)
F64
=
uint8_t
(
TypeCode
:
:
F64
)
V128
=
uint8_t
(
TypeCode
:
:
V128
)
Rtt
=
uint8_t
(
TypeCode
:
:
Rtt
)
Ref
=
uint8_t
(
AbstractReferenceTypeCode
)
}
;
static
bool
isValidTypeCode
(
TypeCode
tc
)
{
switch
(
tc
)
{
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
case
TypeCode
:
:
V128
:
case
TypeCode
:
:
FuncRef
:
case
TypeCode
:
:
ExternRef
:
case
TypeCode
:
:
EqRef
:
case
TypeCode
:
:
Rtt
:
case
AbstractReferenceTypeIndexCode
:
return
true
;
default
:
return
false
;
}
}
}
;
template
<
class
T
>
class
PackedType
:
public
T
{
public
:
using
Kind
=
typename
T
:
:
Kind
;
protected
:
PackedTypeCode
tc_
;
explicit
PackedType
(
TypeCode
c
)
:
tc_
(
PackedTypeCode
:
:
pack
(
c
)
)
{
MOZ_ASSERT
(
c
!
=
AbstractReferenceTypeIndexCode
)
;
MOZ_ASSERT
(
isValid
(
)
)
;
}
TypeCode
typeCode
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
tc_
.
typeCode
(
)
;
}
public
:
PackedType
(
)
:
tc_
(
PackedTypeCode
:
:
invalid
(
)
)
{
}
MOZ_IMPLICIT
PackedType
(
Kind
c
)
:
tc_
(
PackedTypeCode
:
:
pack
(
TypeCode
(
c
)
)
)
{
MOZ_ASSERT
(
c
!
=
Kind
:
:
Ref
)
;
MOZ_ASSERT
(
isValid
(
)
)
;
}
MOZ_IMPLICIT
PackedType
(
RefType
rt
)
:
tc_
(
rt
.
packed
(
)
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
}
explicit
PackedType
(
PackedTypeCode
ptc
)
:
tc_
(
ptc
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
}
explicit
PackedType
(
jit
:
:
MIRType
mty
)
{
switch
(
mty
)
{
case
jit
:
:
MIRType
:
:
Int32
:
tc_
=
PackedTypeCode
:
:
pack
(
TypeCode
:
:
I32
)
;
break
;
case
jit
:
:
MIRType
:
:
Int64
:
tc_
=
PackedTypeCode
:
:
pack
(
TypeCode
:
:
I64
)
;
break
;
case
jit
:
:
MIRType
:
:
Float32
:
tc_
=
PackedTypeCode
:
:
pack
(
TypeCode
:
:
F32
)
;
break
;
case
jit
:
:
MIRType
:
:
Double
:
tc_
=
PackedTypeCode
:
:
pack
(
TypeCode
:
:
F64
)
;
break
;
case
jit
:
:
MIRType
:
:
Simd128
:
tc_
=
PackedTypeCode
:
:
pack
(
TypeCode
:
:
V128
)
;
break
;
default
:
MOZ_CRASH
(
"
PackedType
(
MIRType
)
:
unexpected
type
"
)
;
}
}
static
PackedType
fromNonRefTypeCode
(
TypeCode
tc
)
{
#
ifdef
DEBUG
switch
(
tc
)
{
case
TypeCode
:
:
I8
:
case
TypeCode
:
:
I16
:
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
case
TypeCode
:
:
V128
:
break
;
default
:
MOZ_CRASH
(
"
Bad
type
code
"
)
;
}
#
endif
return
PackedType
(
tc
)
;
}
static
PackedType
fromRtt
(
uint32_t
typeIndex
uint32_t
rttDepth
)
{
return
PackedType
(
PackedTypeCode
:
:
pack
(
TypeCode
:
:
Rtt
typeIndex
false
rttDepth
)
)
;
}
static
PackedType
fromBitsUnsafe
(
uint64_t
bits
)
{
return
PackedType
(
PackedTypeCode
:
:
fromBits
(
bits
)
)
;
}
static
constexpr
PackedType
hostPtr
(
)
{
#
ifdef
JS_64BIT
return
PackedType
:
:
I64
;
#
else
return
PackedType
:
:
I32
;
#
endif
}
bool
isValid
(
)
const
{
if
(
!
tc_
.
isValid
(
)
)
{
return
false
;
}
return
T
:
:
isValidTypeCode
(
tc_
.
typeCode
(
)
)
;
}
PackedTypeCode
packed
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
tc_
;
}
uint64_t
bitsUnsafe
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
tc_
.
bits
(
)
;
}
bool
isFuncRef
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
TypeCode
:
:
FuncRef
;
}
bool
isExternRef
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
TypeCode
:
:
ExternRef
;
}
bool
isEqRef
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
TypeCode
:
:
EqRef
;
}
bool
isTypeIndex
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
tc_
.
typeCode
(
)
=
=
AbstractReferenceTypeIndexCode
;
}
bool
isReference
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
tc_
.
isReference
(
)
;
}
bool
isRtt
(
)
const
{
return
tc_
.
typeCode
(
)
=
=
TypeCode
:
:
Rtt
;
}
bool
isDefaultable
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
!
(
isRtt
(
)
|
|
(
isReference
(
)
&
&
!
isNullable
(
)
)
)
;
}
bool
isExposable
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
#
if
defined
(
ENABLE_WASM_SIMD
)
|
|
defined
(
ENABLE_WASM_GC
)
return
!
(
kind
(
)
=
=
Kind
:
:
V128
|
|
isRtt
(
)
|
|
isTypeIndex
(
)
)
;
#
else
return
true
;
#
endif
}
bool
isNullable
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
tc_
.
isNullable
(
)
;
}
uint32_t
typeIndex
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
tc_
.
typeIndex
(
)
;
}
uint32_t
rttDepth
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
tc_
.
rttDepth
(
)
;
}
Kind
kind
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
Kind
(
tc_
.
typeCodeAbstracted
(
)
)
;
}
RefType
refType
(
)
const
{
MOZ_ASSERT
(
isReference
(
)
)
;
return
RefType
(
tc_
)
;
}
RefType
:
:
Kind
refTypeKind
(
)
const
{
MOZ_ASSERT
(
isReference
(
)
)
;
return
RefType
(
tc_
)
.
kind
(
)
;
}
void
renumber
(
const
RenumberMap
&
map
)
{
if
(
!
isTypeIndex
(
)
)
{
return
;
}
if
(
RenumberMap
:
:
Ptr
p
=
map
.
lookup
(
refType
(
)
.
typeIndex
(
)
)
)
{
*
this
=
RefType
:
:
fromTypeIndex
(
p
-
>
value
(
)
isNullable
(
)
)
;
}
}
void
offsetTypeIndex
(
uint32_t
offsetBy
)
{
if
(
!
isTypeIndex
(
)
)
{
return
;
}
*
this
=
RefType
:
:
fromTypeIndex
(
refType
(
)
.
typeIndex
(
)
+
offsetBy
isNullable
(
)
)
;
}
bool
isEncodedAsJSValueOnEscape
(
)
const
{
switch
(
typeCode
(
)
)
{
case
TypeCode
:
:
FuncRef
:
case
TypeCode
:
:
ExternRef
:
case
TypeCode
:
:
EqRef
:
return
true
;
default
:
return
false
;
}
}
uint32_t
size
(
)
const
{
switch
(
tc_
.
typeCodeAbstracted
(
)
)
{
case
TypeCode
:
:
I8
:
return
1
;
case
TypeCode
:
:
I16
:
return
2
;
case
TypeCode
:
:
I32
:
return
4
;
case
TypeCode
:
:
I64
:
return
8
;
case
TypeCode
:
:
F32
:
return
4
;
case
TypeCode
:
:
F64
:
return
8
;
case
TypeCode
:
:
V128
:
return
16
;
case
TypeCode
:
:
Rtt
:
case
AbstractReferenceTypeCode
:
return
sizeof
(
void
*
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
)
;
return
0
;
}
}
uint32_t
alignmentInStruct
(
)
const
{
return
size
(
)
;
}
uint32_t
indexingShift
(
)
const
{
switch
(
size
(
)
)
{
case
1
:
return
0
;
case
2
:
return
1
;
case
4
:
return
2
;
case
8
:
return
3
;
case
16
:
return
4
;
default
:
MOZ_ASSERT_UNREACHABLE
(
)
;
return
0
;
}
}
PackedType
<
ValTypeTraits
>
widenToValType
(
)
const
{
switch
(
tc_
.
typeCodeAbstracted
(
)
)
{
case
TypeCode
:
:
I8
:
case
TypeCode
:
:
I16
:
return
PackedType
<
ValTypeTraits
>
:
:
I32
;
default
:
return
PackedType
<
ValTypeTraits
>
(
tc_
)
;
}
}
bool
operator
=
=
(
const
PackedType
&
that
)
const
{
MOZ_ASSERT
(
isValid
(
)
&
&
that
.
isValid
(
)
)
;
return
tc_
=
=
that
.
tc_
;
}
bool
operator
!
=
(
const
PackedType
&
that
)
const
{
MOZ_ASSERT
(
isValid
(
)
&
&
that
.
isValid
(
)
)
;
return
tc_
!
=
that
.
tc_
;
}
bool
operator
=
=
(
Kind
that
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
MOZ_ASSERT
(
that
!
=
Kind
:
:
Ref
)
;
return
Kind
(
typeCode
(
)
)
=
=
that
;
}
bool
operator
!
=
(
Kind
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
}
;
using
ValType
=
PackedType
<
ValTypeTraits
>
;
using
FieldType
=
PackedType
<
FieldTypeTraits
>
;
struct
V128
{
uint8_t
bytes
[
16
]
;
V128
(
)
{
memset
(
bytes
0
sizeof
(
bytes
)
)
;
}
template
<
typename
T
>
T
extractLane
(
unsigned
lane
)
const
{
T
result
;
MOZ_ASSERT
(
lane
<
16
/
sizeof
(
T
)
)
;
memcpy
(
&
result
bytes
+
sizeof
(
T
)
*
lane
sizeof
(
T
)
)
;
return
result
;
}
template
<
typename
T
>
void
insertLane
(
unsigned
lane
T
value
)
{
MOZ_ASSERT
(
lane
<
16
/
sizeof
(
T
)
)
;
memcpy
(
bytes
+
sizeof
(
T
)
*
lane
&
value
sizeof
(
T
)
)
;
}
bool
operator
=
=
(
const
V128
&
rhs
)
const
{
for
(
size_t
i
=
0
;
i
<
sizeof
(
bytes
)
;
i
+
+
)
{
if
(
bytes
[
i
]
!
=
rhs
.
bytes
[
i
]
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
V128
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
}
;
static_assert
(
sizeof
(
V128
)
=
=
16
"
Invariant
"
)
;
typedef
Vector
<
ValType
16
SystemAllocPolicy
>
ValTypeVector
;
static
inline
unsigned
SizeOf
(
ValType
vt
)
{
switch
(
vt
.
kind
(
)
)
{
case
ValType
:
:
I32
:
case
ValType
:
:
F32
:
return
4
;
case
ValType
:
:
I64
:
case
ValType
:
:
F64
:
return
8
;
case
ValType
:
:
V128
:
return
16
;
case
ValType
:
:
Rtt
:
case
ValType
:
:
Ref
:
return
sizeof
(
intptr_t
)
;
}
MOZ_CRASH
(
"
Invalid
ValType
"
)
;
}
static
inline
jit
:
:
MIRType
ToMIRType
(
ValType
vt
)
{
switch
(
vt
.
kind
(
)
)
{
case
ValType
:
:
I32
:
return
jit
:
:
MIRType
:
:
Int32
;
case
ValType
:
:
I64
:
return
jit
:
:
MIRType
:
:
Int64
;
case
ValType
:
:
F32
:
return
jit
:
:
MIRType
:
:
Float32
;
case
ValType
:
:
F64
:
return
jit
:
:
MIRType
:
:
Double
;
case
ValType
:
:
V128
:
return
jit
:
:
MIRType
:
:
Simd128
;
case
ValType
:
:
Rtt
:
case
ValType
:
:
Ref
:
return
jit
:
:
MIRType
:
:
RefOrNull
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
bad
type
"
)
;
}
static
inline
bool
IsNumberType
(
ValType
vt
)
{
return
!
vt
.
isReference
(
)
;
}
static
inline
jit
:
:
MIRType
ToMIRType
(
const
Maybe
<
ValType
>
&
t
)
{
return
t
?
ToMIRType
(
ValType
(
t
.
ref
(
)
)
)
:
jit
:
:
MIRType
:
:
None
;
}
extern
UniqueChars
ToString
(
ValType
type
)
;
extern
UniqueChars
ToString
(
const
Maybe
<
ValType
>
&
type
)
;
class
AnyRef
{
mutable
JSObject
*
value_
;
explicit
AnyRef
(
)
:
value_
(
(
JSObject
*
)
-
1
)
{
}
explicit
AnyRef
(
JSObject
*
p
)
:
value_
(
p
)
{
MOZ_ASSERT
(
(
(
uintptr_t
)
p
&
0x03
)
=
=
0
)
;
}
public
:
static
AnyRef
invalid
(
)
{
return
AnyRef
(
)
;
}
static
AnyRef
fromCompiledCode
(
void
*
p
)
{
return
AnyRef
(
(
JSObject
*
)
p
)
;
}
static
AnyRef
fromJSObject
(
JSObject
*
p
)
{
return
AnyRef
(
p
)
;
}
static
AnyRef
null
(
)
{
return
AnyRef
(
nullptr
)
;
}
bool
isNull
(
)
const
{
return
value_
=
=
nullptr
;
}
bool
operator
=
=
(
const
AnyRef
&
rhs
)
const
{
return
this
-
>
value_
=
=
rhs
.
value_
;
}
bool
operator
!
=
(
const
AnyRef
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
void
*
forCompiledCode
(
)
const
{
return
value_
;
}
JSObject
*
asJSObject
(
)
const
{
return
value_
;
}
JSObject
*
*
asJSObjectAddress
(
)
const
{
return
&
value_
;
}
void
trace
(
JSTracer
*
trc
)
;
static
constexpr
uintptr_t
AnyRefTagMask
=
1
;
static
constexpr
uintptr_t
AnyRefObjTag
=
0
;
}
;
using
RootedAnyRef
=
Rooted
<
AnyRef
>
;
using
HandleAnyRef
=
Handle
<
AnyRef
>
;
using
MutableHandleAnyRef
=
MutableHandle
<
AnyRef
>
;
#
define
ASSERT_ANYREF_IS_JSOBJECT
(
void
)
(
0
)
#
define
STATIC_ASSERT_ANYREF_IS_JSOBJECT
static_assert
(
1
"
AnyRef
is
JSObject
"
)
bool
BoxAnyRef
(
JSContext
*
cx
HandleValue
val
MutableHandleAnyRef
result
)
;
JSObject
*
BoxBoxableValue
(
JSContext
*
cx
HandleValue
val
)
;
Value
UnboxAnyRef
(
AnyRef
val
)
;
class
WasmValueBox
:
public
NativeObject
{
static
const
unsigned
VALUE_SLOT
=
0
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
1
;
static
const
JSClass
class_
;
static
WasmValueBox
*
create
(
JSContext
*
cx
HandleValue
val
)
;
Value
value
(
)
const
{
return
getFixedSlot
(
VALUE_SLOT
)
;
}
static
size_t
offsetOfValue
(
)
{
return
NativeObject
:
:
getFixedSlotOffset
(
VALUE_SLOT
)
;
}
}
;
class
FuncRef
{
JSFunction
*
value_
;
explicit
FuncRef
(
)
:
value_
(
(
JSFunction
*
)
-
1
)
{
}
explicit
FuncRef
(
JSFunction
*
p
)
:
value_
(
p
)
{
MOZ_ASSERT
(
(
(
uintptr_t
)
p
&
0x03
)
=
=
0
)
;
}
public
:
static
FuncRef
fromCompiledCode
(
void
*
p
)
{
return
FuncRef
(
(
JSFunction
*
)
p
)
;
}
static
FuncRef
fromJSFunction
(
JSFunction
*
p
)
{
return
FuncRef
(
p
)
;
}
static
FuncRef
fromAnyRefUnchecked
(
AnyRef
p
)
;
AnyRef
asAnyRef
(
)
{
return
AnyRef
:
:
fromJSObject
(
(
JSObject
*
)
value_
)
;
}
void
*
forCompiledCode
(
)
const
{
return
value_
;
}
JSFunction
*
asJSFunction
(
)
{
return
value_
;
}
bool
isNull
(
)
{
return
value_
=
=
nullptr
;
}
}
;
using
RootedFuncRef
=
Rooted
<
FuncRef
>
;
using
HandleFuncRef
=
Handle
<
FuncRef
>
;
using
MutableHandleFuncRef
=
MutableHandle
<
FuncRef
>
;
Value
UnboxFuncRef
(
FuncRef
val
)
;
struct
ExceptionTag
:
AtomicRefCounted
<
ExceptionTag
>
{
ExceptionTag
(
)
=
default
;
}
;
using
SharedExceptionTag
=
RefPtr
<
ExceptionTag
>
;
typedef
Vector
<
SharedExceptionTag
0
SystemAllocPolicy
>
SharedExceptionTagVector
;
class
WasmJSExceptionObject
:
public
NativeObject
{
static
const
unsigned
VALUE_SLOT
=
0
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
1
;
static
const
JSClass
class_
;
const
Value
&
value
(
)
const
{
return
getFixedSlot
(
VALUE_SLOT
)
;
}
static
WasmJSExceptionObject
*
create
(
JSContext
*
cx
MutableHandleValue
value
)
;
}
;
enum
class
Tier
{
Baseline
Debug
=
Baseline
Optimized
Serialized
=
Optimized
}
;
class
Tiers
{
Tier
t_
[
2
]
;
uint32_t
n_
;
public
:
explicit
Tiers
(
)
{
n_
=
0
;
}
explicit
Tiers
(
Tier
t
)
{
t_
[
0
]
=
t
;
n_
=
1
;
}
explicit
Tiers
(
Tier
t
Tier
u
)
{
MOZ_ASSERT
(
t
!
=
u
)
;
t_
[
0
]
=
t
;
t_
[
1
]
=
u
;
n_
=
2
;
}
Tier
*
begin
(
)
{
return
t_
;
}
Tier
*
end
(
)
{
return
t_
+
n_
;
}
}
;
enum
ModuleKind
{
Wasm
AsmJS
}
;
enum
class
Shareable
{
False
True
}
;
struct
FeatureOptions
{
FeatureOptions
(
)
:
simdWormhole
(
false
)
{
}
bool
simdWormhole
;
}
;
struct
FeatureArgs
{
FeatureArgs
(
)
:
sharedMemory
(
Shareable
:
:
False
)
refTypes
(
false
)
functionReferences
(
false
)
gcTypes
(
false
)
multiValue
(
false
)
v128
(
false
)
hugeMemory
(
false
)
simdWormhole
(
false
)
exceptions
(
false
)
{
}
FeatureArgs
(
const
FeatureArgs
&
)
=
default
;
FeatureArgs
&
operator
=
(
const
FeatureArgs
&
)
=
default
;
FeatureArgs
(
FeatureArgs
&
&
)
=
default
;
static
FeatureArgs
build
(
JSContext
*
cx
const
FeatureOptions
&
options
)
;
FeatureArgs
withRefTypes
(
bool
refTypes
)
const
{
FeatureArgs
features
=
*
this
;
features
.
refTypes
=
refTypes
;
return
features
;
}
Shareable
sharedMemory
;
bool
refTypes
;
bool
functionReferences
;
bool
gcTypes
;
bool
multiValue
;
bool
v128
;
bool
hugeMemory
;
bool
simdWormhole
;
bool
exceptions
;
}
;
class
LitVal
{
public
:
union
Cell
{
int32_t
i32_
;
int64_t
i64_
;
float
f32_
;
double
f64_
;
wasm
:
:
V128
v128_
;
wasm
:
:
AnyRef
ref_
;
Cell
(
)
:
v128_
(
)
{
}
~
Cell
(
)
=
default
;
}
;
protected
:
ValType
type_
;
Cell
cell_
;
public
:
LitVal
(
)
:
type_
(
ValType
(
)
)
cell_
{
}
{
}
explicit
LitVal
(
ValType
type
)
:
type_
(
type
)
{
MOZ_ASSERT
(
type
.
isDefaultable
(
)
)
;
switch
(
type
.
kind
(
)
)
{
case
ValType
:
:
Kind
:
:
I32
:
{
cell_
.
i32_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
I64
:
{
cell_
.
i64_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
F32
:
{
cell_
.
f32_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
F64
:
{
cell_
.
f64_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
V128
:
{
new
(
&
cell_
.
v128_
)
V128
(
)
;
break
;
}
case
ValType
:
:
Kind
:
:
Ref
:
{
cell_
.
ref_
=
AnyRef
:
:
null
(
)
;
break
;
}
case
ValType
:
:
Kind
:
:
Rtt
:
{
MOZ_CRASH
(
"
not
defaultable
"
)
;
}
}
}
explicit
LitVal
(
uint32_t
i32
)
:
type_
(
ValType
:
:
I32
)
{
cell_
.
i32_
=
i32
;
}
explicit
LitVal
(
uint64_t
i64
)
:
type_
(
ValType
:
:
I64
)
{
cell_
.
i64_
=
i64
;
}
explicit
LitVal
(
float
f32
)
:
type_
(
ValType
:
:
F32
)
{
cell_
.
f32_
=
f32
;
}
explicit
LitVal
(
double
f64
)
:
type_
(
ValType
:
:
F64
)
{
cell_
.
f64_
=
f64
;
}
explicit
LitVal
(
V128
v128
)
:
type_
(
ValType
:
:
V128
)
{
cell_
.
v128_
=
v128
;
}
explicit
LitVal
(
ValType
type
AnyRef
any
)
:
type_
(
type
)
{
MOZ_ASSERT
(
type
.
isReference
(
)
)
;
MOZ_ASSERT
(
any
.
isNull
(
)
"
use
Val
for
non
-
nullptr
ref
types
to
get
tracing
"
)
;
cell_
.
ref_
=
any
;
}
ValType
type
(
)
const
{
return
type_
;
}
static
constexpr
size_t
sizeofLargestValue
(
)
{
return
sizeof
(
cell_
)
;
}
Cell
&
cell
(
)
{
return
cell_
;
}
const
Cell
&
cell
(
)
const
{
return
cell_
;
}
uint32_t
i32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I32
)
;
return
cell_
.
i32_
;
}
uint64_t
i64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I64
)
;
return
cell_
.
i64_
;
}
const
float
&
f32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F32
)
;
return
cell_
.
f32_
;
}
const
double
&
f64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F64
)
;
return
cell_
.
f64_
;
}
AnyRef
ref
(
)
const
{
MOZ_ASSERT
(
type_
.
isReference
(
)
)
;
return
cell_
.
ref_
;
}
const
V128
&
v128
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
V128
)
;
return
cell_
.
v128_
;
}
}
;
class
MOZ_NON_PARAM
Val
:
public
LitVal
{
public
:
Val
(
)
:
LitVal
(
)
{
}
explicit
Val
(
ValType
type
)
:
LitVal
(
type
)
{
}
explicit
Val
(
const
LitVal
&
val
)
;
explicit
Val
(
uint32_t
i32
)
:
LitVal
(
i32
)
{
}
explicit
Val
(
uint64_t
i64
)
:
LitVal
(
i64
)
{
}
explicit
Val
(
float
f32
)
:
LitVal
(
f32
)
{
}
explicit
Val
(
double
f64
)
:
LitVal
(
f64
)
{
}
explicit
Val
(
V128
v128
)
:
LitVal
(
v128
)
{
}
explicit
Val
(
ValType
type
AnyRef
val
)
:
LitVal
(
type
AnyRef
:
:
null
(
)
)
{
MOZ_ASSERT
(
type
.
isReference
(
)
)
;
cell_
.
ref_
=
val
;
}
explicit
Val
(
ValType
type
FuncRef
val
)
:
LitVal
(
type
AnyRef
:
:
null
(
)
)
{
MOZ_ASSERT
(
type
.
isFuncRef
(
)
)
;
cell_
.
ref_
=
val
.
asAnyRef
(
)
;
}
Val
(
const
Val
&
)
=
default
;
Val
&
operator
=
(
const
Val
&
)
=
default
;
bool
operator
=
=
(
const
Val
&
rhs
)
const
{
if
(
type_
!
=
rhs
.
type_
)
{
return
false
;
}
switch
(
type_
.
kind
(
)
)
{
case
ValType
:
:
I32
:
return
cell_
.
i32_
=
=
rhs
.
cell_
.
i32_
;
case
ValType
:
:
I64
:
return
cell_
.
i64_
=
=
rhs
.
cell_
.
i64_
;
case
ValType
:
:
F32
:
return
cell_
.
f32_
=
=
rhs
.
cell_
.
f32_
;
case
ValType
:
:
F64
:
return
cell_
.
f64_
=
=
rhs
.
cell_
.
f64_
;
case
ValType
:
:
V128
:
return
cell_
.
v128_
=
=
rhs
.
cell_
.
v128_
;
case
ValType
:
:
Rtt
:
case
ValType
:
:
Ref
:
return
cell_
.
ref_
=
=
rhs
.
cell_
.
ref_
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
false
;
}
bool
operator
!
=
(
const
Val
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
isJSObject
(
)
const
{
return
type_
.
isValid
(
)
&
&
type_
.
isReference
(
)
&
&
!
cell_
.
ref_
.
isNull
(
)
;
}
JSObject
*
asJSObject
(
)
const
{
MOZ_ASSERT
(
isJSObject
(
)
)
;
return
cell_
.
ref_
.
asJSObject
(
)
;
}
JSObject
*
*
asJSObjectAddress
(
)
const
{
return
cell_
.
ref_
.
asJSObjectAddress
(
)
;
}
static
bool
fromJSValue
(
JSContext
*
cx
ValType
targetType
HandleValue
val
MutableHandle
<
Val
>
rval
)
;
bool
toJSValue
(
JSContext
*
cx
MutableHandleValue
rval
)
const
;
void
trace
(
JSTracer
*
trc
)
const
;
}
;
using
GCPtrVal
=
GCPtr
<
Val
>
;
using
RootedVal
=
Rooted
<
Val
>
;
using
HandleVal
=
Handle
<
Val
>
;
using
MutableHandleVal
=
MutableHandle
<
Val
>
;
typedef
GCVector
<
Val
0
SystemAllocPolicy
>
ValVector
;
using
RootedValVector
=
Rooted
<
ValVector
>
;
using
HandleValVector
=
Handle
<
ValVector
>
;
using
MutableHandleValVector
=
MutableHandle
<
ValVector
>
;
[
[
nodiscard
]
]
extern
bool
CheckRefType
(
JSContext
*
cx
RefType
targetType
HandleValue
v
MutableHandleFunction
fnval
MutableHandleAnyRef
refval
)
;
[
[
nodiscard
]
]
extern
bool
CheckFuncRefValue
(
JSContext
*
cx
HandleValue
v
MutableHandleFunction
fun
)
;
[
[
nodiscard
]
]
extern
bool
CheckEqRefValue
(
JSContext
*
cx
HandleValue
v
MutableHandleAnyRef
vp
)
;
class
NoDebug
;
class
DebugCodegenVal
;
template
<
typename
Debug
=
NoDebug
>
extern
bool
ToWebAssemblyValue
(
JSContext
*
cx
HandleValue
val
FieldType
type
void
*
loc
bool
mustWrite64
)
;
template
<
typename
Debug
=
NoDebug
>
extern
bool
ToWebAssemblyValue
(
JSContext
*
cx
HandleValue
val
ValType
type
void
*
loc
bool
mustWrite64
)
;
template
<
typename
Debug
=
NoDebug
>
extern
bool
ToJSValue
(
JSContext
*
cx
const
void
*
src
FieldType
type
MutableHandleValue
dst
)
;
template
<
typename
Debug
=
NoDebug
>
extern
bool
ToJSValue
(
JSContext
*
cx
const
void
*
src
ValType
type
MutableHandleValue
dst
)
;
class
FuncType
{
ValTypeVector
args_
;
ValTypeVector
results_
;
public
:
FuncType
(
)
:
args_
(
)
results_
(
)
{
}
FuncType
(
ValTypeVector
&
&
args
ValTypeVector
&
&
results
)
:
args_
(
std
:
:
move
(
args
)
)
results_
(
std
:
:
move
(
results
)
)
{
}
[
[
nodiscard
]
]
bool
clone
(
const
FuncType
&
src
)
{
MOZ_ASSERT
(
args_
.
empty
(
)
)
;
MOZ_ASSERT
(
results_
.
empty
(
)
)
;
return
args_
.
appendAll
(
src
.
args_
)
&
&
results_
.
appendAll
(
src
.
results_
)
;
}
void
renumber
(
const
RenumberMap
&
map
)
{
for
(
auto
&
arg
:
args_
)
{
arg
.
renumber
(
map
)
;
}
for
(
auto
&
result
:
results_
)
{
result
.
renumber
(
map
)
;
}
}
void
offsetTypeIndex
(
uint32_t
offsetBy
)
{
for
(
auto
&
arg
:
args_
)
{
arg
.
offsetTypeIndex
(
offsetBy
)
;
}
for
(
auto
&
result
:
results_
)
{
result
.
offsetTypeIndex
(
offsetBy
)
;
}
}
ValType
arg
(
unsigned
i
)
const
{
return
args_
[
i
]
;
}
const
ValTypeVector
&
args
(
)
const
{
return
args_
;
}
ValType
result
(
unsigned
i
)
const
{
return
results_
[
i
]
;
}
const
ValTypeVector
&
results
(
)
const
{
return
results_
;
}
HashNumber
hash
(
)
const
{
HashNumber
hn
=
0
;
for
(
const
ValType
&
vt
:
args_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
vt
.
packed
(
)
.
bits
(
)
)
)
;
}
for
(
const
ValType
&
vt
:
results_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
vt
.
packed
(
)
.
bits
(
)
)
)
;
}
return
hn
;
}
bool
operator
=
=
(
const
FuncType
&
rhs
)
const
{
return
EqualContainers
(
args
(
)
rhs
.
args
(
)
)
&
&
EqualContainers
(
results
(
)
rhs
.
results
(
)
)
;
}
bool
operator
!
=
(
const
FuncType
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
temporarilyUnsupportedResultCountForJitEntry
(
)
const
{
return
results
(
)
.
length
(
)
>
MaxResultsForJitEntry
;
}
bool
temporarilyUnsupportedResultCountForJitExit
(
)
const
{
return
results
(
)
.
length
(
)
>
MaxResultsForJitExit
;
}
bool
hasUnexposableArgOrRet
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
!
arg
.
isExposable
(
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
!
result
.
isExposable
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
temporarilyUnsupportedReftypeForEntry
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
isReference
(
)
&
&
(
!
arg
.
isExternRef
(
)
|
|
!
arg
.
isNullable
(
)
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isTypeIndex
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
temporarilyUnsupportedReftypeForInlineEntry
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
isReference
(
)
&
&
(
!
arg
.
isExternRef
(
)
|
|
!
arg
.
isNullable
(
)
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isTypeIndex
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
temporarilyUnsupportedReftypeForExit
(
)
const
{
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isReference
(
)
&
&
(
!
result
.
isExternRef
(
)
|
|
!
result
.
isNullable
(
)
)
)
{
return
true
;
}
}
return
false
;
}
#
ifdef
WASM_PRIVATE_REFTYPES
bool
exposesTypeIndex
(
)
const
{
for
(
const
ValType
&
arg
:
args
(
)
)
{
if
(
arg
.
isTypeIndex
(
)
)
{
return
true
;
}
}
for
(
const
ValType
&
result
:
results
(
)
)
{
if
(
result
.
isTypeIndex
(
)
)
{
return
true
;
}
}
return
false
;
}
#
endif
WASM_DECLARE_SERIALIZABLE
(
FuncType
)
}
;
struct
FuncTypeHashPolicy
{
using
Lookup
=
const
FuncType
&
;
static
HashNumber
hash
(
Lookup
ft
)
{
return
ft
.
hash
(
)
;
}
static
bool
match
(
const
FuncType
*
lhs
Lookup
rhs
)
{
return
*
lhs
=
=
rhs
;
}
}
;
enum
class
StackResults
{
HasStackResults
NoStackResults
}
;
class
ArgTypeVector
{
const
ValTypeVector
&
args_
;
bool
hasStackResults_
;
size_t
length
(
)
const
{
return
args_
.
length
(
)
+
size_t
(
hasStackResults_
)
;
}
template
<
class
VecT
class
ABIArgGeneratorT
>
friend
class
jit
:
:
ABIArgIterBase
;
public
:
ArgTypeVector
(
const
ValTypeVector
&
args
StackResults
stackResults
)
:
args_
(
args
)
hasStackResults_
(
stackResults
=
=
StackResults
:
:
HasStackResults
)
{
}
explicit
ArgTypeVector
(
const
FuncType
&
funcType
)
;
bool
hasSyntheticStackResultPointerArg
(
)
const
{
return
hasStackResults_
;
}
StackResults
stackResults
(
)
const
{
return
hasSyntheticStackResultPointerArg
(
)
?
StackResults
:
:
HasStackResults
:
StackResults
:
:
NoStackResults
;
}
size_t
lengthWithoutStackResults
(
)
const
{
return
args_
.
length
(
)
;
}
bool
isSyntheticStackResultPointerArg
(
size_t
idx
)
const
{
MOZ_ASSERT
(
idx
<
lengthWithStackResults
(
)
)
;
return
idx
=
=
args_
.
length
(
)
;
}
bool
isNaturalArg
(
size_t
idx
)
const
{
return
!
isSyntheticStackResultPointerArg
(
idx
)
;
}
size_t
naturalIndex
(
size_t
idx
)
const
{
MOZ_ASSERT
(
isNaturalArg
(
idx
)
)
;
return
idx
;
}
size_t
lengthWithStackResults
(
)
const
{
return
length
(
)
;
}
jit
:
:
MIRType
operator
[
]
(
size_t
i
)
const
{
MOZ_ASSERT
(
i
<
lengthWithStackResults
(
)
)
;
if
(
isSyntheticStackResultPointerArg
(
i
)
)
{
return
jit
:
:
MIRType
:
:
StackResults
;
}
return
ToMIRType
(
args_
[
naturalIndex
(
i
)
]
)
;
}
}
;
template
<
typename
PointerType
>
class
TaggedValue
{
public
:
enum
Kind
{
ImmediateKind1
=
0
ImmediateKind2
=
1
PointerKind1
=
2
PointerKind2
=
3
}
;
using
PackedRepr
=
uintptr_t
;
private
:
PackedRepr
bits_
;
static
constexpr
PackedRepr
PayloadShift
=
2
;
static
constexpr
PackedRepr
KindMask
=
0x3
;
static
constexpr
PackedRepr
PointerKindBit
=
0x2
;
constexpr
static
bool
IsPointerKind
(
Kind
kind
)
{
return
PackedRepr
(
kind
)
&
PointerKindBit
;
}
constexpr
static
bool
IsImmediateKind
(
Kind
kind
)
{
return
!
IsPointerKind
(
kind
)
;
}
static_assert
(
IsImmediateKind
(
ImmediateKind1
)
"
immediate
kind
1
"
)
;
static_assert
(
IsImmediateKind
(
ImmediateKind2
)
"
immediate
kind
2
"
)
;
static_assert
(
IsPointerKind
(
PointerKind1
)
"
pointer
kind
1
"
)
;
static_assert
(
IsPointerKind
(
PointerKind2
)
"
pointer
kind
2
"
)
;
static
PackedRepr
PackImmediate
(
Kind
kind
PackedRepr
imm
)
{
MOZ_ASSERT
(
IsImmediateKind
(
kind
)
)
;
MOZ_ASSERT
(
(
PackedRepr
(
kind
)
&
KindMask
)
=
=
kind
)
;
MOZ_ASSERT
(
(
imm
&
(
PackedRepr
(
KindMask
)
<
<
(
(
sizeof
(
PackedRepr
)
*
8
)
-
PayloadShift
)
)
)
=
=
0
)
;
return
PackedRepr
(
kind
)
|
(
PackedRepr
(
imm
)
<
<
PayloadShift
)
;
}
static
PackedRepr
PackPointer
(
Kind
kind
PointerType
*
ptr
)
{
PackedRepr
ptrBits
=
reinterpret_cast
<
PackedRepr
>
(
ptr
)
;
MOZ_ASSERT
(
IsPointerKind
(
kind
)
)
;
MOZ_ASSERT
(
(
PackedRepr
(
kind
)
&
KindMask
)
=
=
kind
)
;
MOZ_ASSERT
(
(
ptrBits
&
KindMask
)
=
=
0
)
;
return
PackedRepr
(
kind
)
|
ptrBits
;
}
public
:
TaggedValue
(
Kind
kind
PackedRepr
imm
)
:
bits_
(
PackImmediate
(
kind
imm
)
)
{
}
TaggedValue
(
Kind
kind
PointerType
*
ptr
)
:
bits_
(
PackPointer
(
kind
ptr
)
)
{
}
PackedRepr
bits
(
)
const
{
return
bits_
;
}
Kind
kind
(
)
const
{
return
Kind
(
bits
(
)
&
KindMask
)
;
}
PackedRepr
immediate
(
)
const
{
MOZ_ASSERT
(
IsImmediateKind
(
kind
(
)
)
)
;
return
mozilla
:
:
AssertedCast
<
PackedRepr
>
(
bits
(
)
>
>
PayloadShift
)
;
}
PointerType
*
pointer
(
)
const
{
MOZ_ASSERT
(
IsPointerKind
(
kind
(
)
)
)
;
return
reinterpret_cast
<
PointerType
*
>
(
bits
(
)
&
~
KindMask
)
;
}
}
;
static_assert
(
std
:
:
is_same
<
TaggedValue
<
void
*
>
:
:
PackedRepr
PackedTypeCode
:
:
PackedRepr
>
(
)
"
can
use
pointer
tagging
with
PackedTypeCode
"
)
;
class
ResultType
{
using
Tagged
=
TaggedValue
<
const
ValTypeVector
>
;
Tagged
tagged_
;
enum
Kind
{
EmptyKind
=
Tagged
:
:
ImmediateKind1
SingleKind
=
Tagged
:
:
ImmediateKind2
#
ifdef
ENABLE_WASM_MULTI_VALUE
VectorKind
=
Tagged
:
:
PointerKind1
#
endif
InvalidKind
=
Tagged
:
:
PointerKind2
}
;
ResultType
(
Kind
kind
uint32_t
imm
)
:
tagged_
(
Tagged
:
:
Kind
(
kind
)
imm
)
{
}
#
ifdef
ENABLE_WASM_MULTI_VALUE
explicit
ResultType
(
const
ValTypeVector
*
ptr
)
:
tagged_
(
Tagged
:
:
Kind
(
VectorKind
)
ptr
)
{
}
#
endif
Kind
kind
(
)
const
{
return
Kind
(
tagged_
.
kind
(
)
)
;
}
ValType
singleValType
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
SingleKind
)
;
return
ValType
(
PackedTypeCode
:
:
fromBits
(
tagged_
.
immediate
(
)
)
)
;
}
#
ifdef
ENABLE_WASM_MULTI_VALUE
const
ValTypeVector
&
values
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
VectorKind
)
;
return
*
tagged_
.
pointer
(
)
;
}
#
endif
public
:
ResultType
(
)
:
tagged_
(
Tagged
:
:
Kind
(
InvalidKind
)
nullptr
)
{
}
static
ResultType
Empty
(
)
{
return
ResultType
(
EmptyKind
uint32_t
(
0
)
)
;
}
static
ResultType
Single
(
ValType
vt
)
{
return
ResultType
(
SingleKind
vt
.
bitsUnsafe
(
)
)
;
}
static
ResultType
Vector
(
const
ValTypeVector
&
vals
)
{
switch
(
vals
.
length
(
)
)
{
case
0
:
return
Empty
(
)
;
case
1
:
return
Single
(
vals
[
0
]
)
;
default
:
#
ifdef
ENABLE_WASM_MULTI_VALUE
return
ResultType
(
&
vals
)
;
#
else
MOZ_CRASH
(
"
multi
-
value
returns
not
supported
"
)
;
#
endif
}
}
bool
empty
(
)
const
{
return
kind
(
)
=
=
EmptyKind
;
}
size_t
length
(
)
const
{
switch
(
kind
(
)
)
{
case
EmptyKind
:
return
0
;
case
SingleKind
:
return
1
;
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
VectorKind
:
return
values
(
)
.
length
(
)
;
#
endif
default
:
MOZ_CRASH
(
"
bad
resulttype
"
)
;
}
}
ValType
operator
[
]
(
size_t
i
)
const
{
switch
(
kind
(
)
)
{
case
SingleKind
:
MOZ_ASSERT
(
i
=
=
0
)
;
return
singleValType
(
)
;
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
VectorKind
:
return
values
(
)
[
i
]
;
#
endif
default
:
MOZ_CRASH
(
"
bad
resulttype
"
)
;
}
}
bool
operator
=
=
(
ResultType
rhs
)
const
{
switch
(
kind
(
)
)
{
case
EmptyKind
:
case
SingleKind
:
case
InvalidKind
:
return
tagged_
.
bits
(
)
=
=
rhs
.
tagged_
.
bits
(
)
;
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
VectorKind
:
{
if
(
rhs
.
kind
(
)
!
=
VectorKind
)
{
return
false
;
}
return
EqualContainers
(
values
(
)
rhs
.
values
(
)
)
;
}
#
endif
default
:
MOZ_CRASH
(
"
bad
resulttype
"
)
;
}
}
bool
operator
!
=
(
ResultType
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
}
;
class
BlockType
{
using
Tagged
=
TaggedValue
<
const
FuncType
>
;
Tagged
tagged_
;
enum
Kind
{
VoidToVoidKind
=
Tagged
:
:
ImmediateKind1
VoidToSingleKind
=
Tagged
:
:
ImmediateKind2
#
ifdef
ENABLE_WASM_MULTI_VALUE
FuncKind
=
Tagged
:
:
PointerKind1
FuncResultsKind
=
Tagged
:
:
PointerKind2
#
endif
}
;
BlockType
(
Kind
kind
uint32_t
imm
)
:
tagged_
(
Tagged
:
:
Kind
(
kind
)
imm
)
{
}
#
ifdef
ENABLE_WASM_MULTI_VALUE
BlockType
(
Kind
kind
const
FuncType
&
type
)
:
tagged_
(
Tagged
:
:
Kind
(
kind
)
&
type
)
{
}
#
endif
Kind
kind
(
)
const
{
return
Kind
(
tagged_
.
kind
(
)
)
;
}
ValType
singleValType
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
VoidToSingleKind
)
;
return
ValType
(
PackedTypeCode
:
:
fromBits
(
tagged_
.
immediate
(
)
)
)
;
}
#
ifdef
ENABLE_WASM_MULTI_VALUE
const
FuncType
&
funcType
(
)
const
{
return
*
tagged_
.
pointer
(
)
;
}
#
endif
public
:
BlockType
(
)
:
tagged_
(
Tagged
:
:
Kind
(
VoidToVoidKind
)
PackedTypeCode
:
:
invalid
(
)
.
bits
(
)
)
{
}
static
BlockType
VoidToVoid
(
)
{
return
BlockType
(
VoidToVoidKind
uint32_t
(
0
)
)
;
}
static
BlockType
VoidToSingle
(
ValType
vt
)
{
return
BlockType
(
VoidToSingleKind
vt
.
bitsUnsafe
(
)
)
;
}
static
BlockType
Func
(
const
FuncType
&
type
)
{
#
ifdef
ENABLE_WASM_MULTI_VALUE
if
(
type
.
args
(
)
.
length
(
)
=
=
0
)
{
return
FuncResults
(
type
)
;
}
return
BlockType
(
FuncKind
type
)
;
#
else
MOZ_ASSERT
(
type
.
args
(
)
.
length
(
)
=
=
0
)
;
return
FuncResults
(
type
)
;
#
endif
}
static
BlockType
FuncResults
(
const
FuncType
&
type
)
{
switch
(
type
.
results
(
)
.
length
(
)
)
{
case
0
:
return
VoidToVoid
(
)
;
case
1
:
return
VoidToSingle
(
type
.
results
(
)
[
0
]
)
;
default
:
#
ifdef
ENABLE_WASM_MULTI_VALUE
return
BlockType
(
FuncResultsKind
type
)
;
#
else
MOZ_CRASH
(
"
multi
-
value
returns
not
supported
"
)
;
#
endif
}
}
ResultType
params
(
)
const
{
switch
(
kind
(
)
)
{
case
VoidToVoidKind
:
case
VoidToSingleKind
:
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
FuncResultsKind
:
#
endif
return
ResultType
:
:
Empty
(
)
;
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
FuncKind
:
return
ResultType
:
:
Vector
(
funcType
(
)
.
args
(
)
)
;
#
endif
default
:
MOZ_CRASH
(
"
unexpected
kind
"
)
;
}
}
ResultType
results
(
)
const
{
switch
(
kind
(
)
)
{
case
VoidToVoidKind
:
return
ResultType
:
:
Empty
(
)
;
case
VoidToSingleKind
:
return
ResultType
:
:
Single
(
singleValType
(
)
)
;
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
FuncKind
:
case
FuncResultsKind
:
return
ResultType
:
:
Vector
(
funcType
(
)
.
results
(
)
)
;
#
endif
default
:
MOZ_CRASH
(
"
unexpected
kind
"
)
;
}
}
bool
operator
=
=
(
BlockType
rhs
)
const
{
if
(
kind
(
)
!
=
rhs
.
kind
(
)
)
{
return
false
;
}
switch
(
kind
(
)
)
{
case
VoidToVoidKind
:
case
VoidToSingleKind
:
return
tagged_
.
bits
(
)
=
=
rhs
.
tagged_
.
bits
(
)
;
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
FuncKind
:
return
funcType
(
)
=
=
rhs
.
funcType
(
)
;
case
FuncResultsKind
:
return
EqualContainers
(
funcType
(
)
.
results
(
)
rhs
.
funcType
(
)
.
results
(
)
)
;
#
endif
default
:
MOZ_CRASH
(
"
unexpected
kind
"
)
;
}
}
bool
operator
!
=
(
BlockType
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
}
;
struct
StructField
{
FieldType
type
;
uint32_t
offset
;
bool
isMutable
;
}
;
typedef
Vector
<
StructField
0
SystemAllocPolicy
>
StructFieldVector
;
class
StructType
{
public
:
StructFieldVector
fields_
;
uint32_t
size_
;
public
:
StructType
(
)
:
fields_
(
)
size_
(
0
)
{
}
explicit
StructType
(
StructFieldVector
&
&
fields
)
:
fields_
(
std
:
:
move
(
fields
)
)
size_
(
0
)
{
}
StructType
(
StructType
&
&
)
=
default
;
StructType
&
operator
=
(
StructType
&
&
)
=
default
;
[
[
nodiscard
]
]
bool
clone
(
const
StructType
&
src
)
{
if
(
!
fields_
.
appendAll
(
src
.
fields_
)
)
{
return
false
;
}
size_
=
src
.
size_
;
return
true
;
}
void
renumber
(
const
RenumberMap
&
map
)
{
for
(
auto
&
field
:
fields_
)
{
field
.
type
.
renumber
(
map
)
;
}
}
void
offsetTypeIndex
(
uint32_t
offsetBy
)
{
for
(
auto
&
field
:
fields_
)
{
field
.
type
.
offsetTypeIndex
(
offsetBy
)
;
}
}
bool
isDefaultable
(
)
const
{
for
(
auto
&
field
:
fields_
)
{
if
(
!
field
.
type
.
isDefaultable
(
)
)
{
return
false
;
}
}
return
true
;
}
[
[
nodiscard
]
]
bool
computeLayout
(
)
;
bool
hasPrefix
(
const
StructType
&
other
)
const
;
WASM_DECLARE_SERIALIZABLE
(
StructType
)
}
;
typedef
Vector
<
StructType
0
SystemAllocPolicy
>
StructTypeVector
;
typedef
Vector
<
const
StructType
*
0
SystemAllocPolicy
>
StructTypePtrVector
;
class
ArrayType
{
public
:
FieldType
elementType_
;
bool
isMutable_
;
public
:
ArrayType
(
FieldType
elementType
bool
isMutable
)
:
elementType_
(
elementType
)
isMutable_
(
isMutable
)
{
}
ArrayType
(
const
ArrayType
&
)
=
default
;
ArrayType
&
operator
=
(
const
ArrayType
&
)
=
default
;
ArrayType
(
ArrayType
&
&
)
=
default
;
ArrayType
&
operator
=
(
ArrayType
&
&
)
=
default
;
MOZ_MUST_USE
bool
clone
(
const
ArrayType
&
src
)
{
elementType_
=
src
.
elementType_
;
isMutable_
=
src
.
isMutable_
;
return
true
;
}
void
renumber
(
const
RenumberMap
&
map
)
{
elementType_
.
renumber
(
map
)
;
}
void
offsetTypeIndex
(
uint32_t
offsetBy
)
{
elementType_
.
offsetTypeIndex
(
offsetBy
)
;
}
bool
isDefaultable
(
)
const
{
return
elementType_
.
isDefaultable
(
)
;
}
WASM_DECLARE_SERIALIZABLE
(
ArrayType
)
}
;
typedef
Vector
<
ArrayType
0
SystemAllocPolicy
>
ArrayTypeVector
;
typedef
Vector
<
const
ArrayType
*
0
SystemAllocPolicy
>
ArrayTypePtrVector
;
class
InitExpr
{
public
:
enum
class
Kind
{
Constant
GetGlobal
RefFunc
}
;
private
:
Kind
kind_
;
union
U
{
LitVal
val_
;
struct
{
uint32_t
index_
;
ValType
type_
;
}
global
;
uint32_t
refFuncIndex_
;
U
(
)
:
global
{
}
{
}
}
u
;
public
:
InitExpr
(
)
=
default
;
static
InitExpr
fromConstant
(
LitVal
val
)
{
InitExpr
expr
;
expr
.
kind_
=
Kind
:
:
Constant
;
expr
.
u
.
val_
=
val
;
return
expr
;
}
static
InitExpr
fromGetGlobal
(
uint32_t
globalIndex
ValType
type
)
{
InitExpr
expr
;
expr
.
kind_
=
Kind
:
:
GetGlobal
;
expr
.
u
.
global
.
index_
=
globalIndex
;
expr
.
u
.
global
.
type_
=
type
;
return
expr
;
}
static
InitExpr
fromRefFunc
(
uint32_t
refFuncIndex
)
{
InitExpr
expr
;
expr
.
kind_
=
Kind
:
:
RefFunc
;
expr
.
u
.
refFuncIndex_
=
refFuncIndex
;
return
expr
;
}
Kind
kind
(
)
const
{
return
kind_
;
}
bool
isVal
(
)
const
{
return
kind
(
)
=
=
Kind
:
:
Constant
;
}
LitVal
val
(
)
const
{
MOZ_ASSERT
(
isVal
(
)
)
;
return
u
.
val_
;
}
uint32_t
globalIndex
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
Kind
:
:
GetGlobal
)
;
return
u
.
global
.
index_
;
}
uint32_t
refFuncIndex
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
Kind
:
:
RefFunc
)
;
return
u
.
refFuncIndex_
;
}
ValType
type
(
)
const
{
switch
(
kind
(
)
)
{
case
Kind
:
:
Constant
:
return
u
.
val_
.
type
(
)
;
case
Kind
:
:
GetGlobal
:
return
u
.
global
.
type_
;
case
Kind
:
:
RefFunc
:
return
ValType
(
RefType
:
:
func
(
)
)
;
}
MOZ_CRASH
(
"
unexpected
initExpr
type
"
)
;
}
}
;
struct
CacheableChars
:
UniqueChars
{
CacheableChars
(
)
=
default
;
explicit
CacheableChars
(
char
*
ptr
)
:
UniqueChars
(
ptr
)
{
}
MOZ_IMPLICIT
CacheableChars
(
UniqueChars
&
&
rhs
)
:
UniqueChars
(
std
:
:
move
(
rhs
)
)
{
}
WASM_DECLARE_SERIALIZABLE
(
CacheableChars
)
}
;
typedef
Vector
<
CacheableChars
0
SystemAllocPolicy
>
CacheableCharsVector
;
struct
Import
{
CacheableChars
module
;
CacheableChars
field
;
DefinitionKind
kind
;
Import
(
)
=
default
;
Import
(
UniqueChars
&
&
module
UniqueChars
&
&
field
DefinitionKind
kind
)
:
module
(
std
:
:
move
(
module
)
)
field
(
std
:
:
move
(
field
)
)
kind
(
kind
)
{
}
WASM_DECLARE_SERIALIZABLE
(
Import
)
}
;
typedef
Vector
<
Import
0
SystemAllocPolicy
>
ImportVector
;
class
Export
{
CacheableChars
fieldName_
;
struct
CacheablePod
{
DefinitionKind
kind_
;
uint32_t
index_
;
}
pod
;
public
:
Export
(
)
=
default
;
explicit
Export
(
UniqueChars
fieldName
uint32_t
index
DefinitionKind
kind
)
;
explicit
Export
(
UniqueChars
fieldName
DefinitionKind
kind
)
;
const
char
*
fieldName
(
)
const
{
return
fieldName_
.
get
(
)
;
}
DefinitionKind
kind
(
)
const
{
return
pod
.
kind_
;
}
uint32_t
funcIndex
(
)
const
;
#
ifdef
ENABLE_WASM_EXCEPTIONS
uint32_t
eventIndex
(
)
const
;
#
endif
uint32_t
globalIndex
(
)
const
;
uint32_t
tableIndex
(
)
const
;
WASM_DECLARE_SERIALIZABLE
(
Export
)
}
;
typedef
Vector
<
Export
0
SystemAllocPolicy
>
ExportVector
;
class
TypeIdDesc
;
struct
FuncDesc
{
FuncType
*
type
;
TypeIdDesc
*
typeId
;
uint32_t
typeIndex
;
FuncDesc
(
)
=
default
;
FuncDesc
(
FuncType
*
type
TypeIdDesc
*
typeId
uint32_t
typeIndex
)
:
type
(
type
)
typeId
(
typeId
)
typeIndex
(
typeIndex
)
{
}
}
;
typedef
Vector
<
FuncDesc
0
SystemAllocPolicy
>
FuncDescVector
;
enum
class
GlobalKind
{
Import
Constant
Variable
}
;
class
GlobalDesc
{
union
V
{
struct
{
union
U
{
InitExpr
initial_
;
struct
{
ValType
type_
;
uint32_t
index_
;
}
import
;
U
(
)
:
import
{
}
{
}
}
val
;
unsigned
offset_
;
bool
isMutable_
;
bool
isWasm_
;
bool
isExport_
;
}
var
;
LitVal
cst_
;
V
(
)
{
}
}
u
;
GlobalKind
kind_
;
bool
isExport
(
)
const
{
return
!
isConstant
(
)
&
&
u
.
var
.
isExport_
;
}
bool
isWasm
(
)
const
{
return
!
isConstant
(
)
&
&
u
.
var
.
isWasm_
;
}
public
:
GlobalDesc
(
)
=
default
;
explicit
GlobalDesc
(
InitExpr
initial
bool
isMutable
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind_
(
(
isMutable
|
|
!
initial
.
isVal
(
)
)
?
GlobalKind
:
:
Variable
:
GlobalKind
:
:
Constant
)
{
if
(
isVariable
(
)
)
{
u
.
var
.
val
.
initial_
=
initial
;
u
.
var
.
isMutable_
=
isMutable
;
u
.
var
.
isWasm_
=
kind
=
=
Wasm
;
u
.
var
.
isExport_
=
false
;
u
.
var
.
offset_
=
UINT32_MAX
;
}
else
{
u
.
cst_
=
initial
.
val
(
)
;
}
}
explicit
GlobalDesc
(
ValType
type
bool
isMutable
uint32_t
importIndex
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind_
(
GlobalKind
:
:
Import
)
{
u
.
var
.
val
.
import
.
type_
=
type
;
u
.
var
.
val
.
import
.
index_
=
importIndex
;
u
.
var
.
isMutable_
=
isMutable
;
u
.
var
.
isWasm_
=
kind
=
=
Wasm
;
u
.
var
.
isExport_
=
false
;
u
.
var
.
offset_
=
UINT32_MAX
;
}
void
setOffset
(
unsigned
offset
)
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
u
.
var
.
offset_
=
=
UINT32_MAX
)
;
u
.
var
.
offset_
=
offset
;
}
unsigned
offset
(
)
const
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
u
.
var
.
offset_
!
=
UINT32_MAX
)
;
return
u
.
var
.
offset_
;
}
void
setIsExport
(
)
{
if
(
!
isConstant
(
)
)
{
u
.
var
.
isExport_
=
true
;
}
}
GlobalKind
kind
(
)
const
{
return
kind_
;
}
bool
isVariable
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Variable
;
}
bool
isConstant
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Constant
;
}
bool
isImport
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Import
;
}
bool
isMutable
(
)
const
{
return
!
isConstant
(
)
&
&
u
.
var
.
isMutable_
;
}
LitVal
constantValue
(
)
const
{
MOZ_ASSERT
(
isConstant
(
)
)
;
return
u
.
cst_
;
}
const
InitExpr
&
initExpr
(
)
const
{
MOZ_ASSERT
(
isVariable
(
)
)
;
return
u
.
var
.
val
.
initial_
;
}
uint32_t
importIndex
(
)
const
{
MOZ_ASSERT
(
isImport
(
)
)
;
return
u
.
var
.
val
.
import
.
index_
;
}
bool
isIndirect
(
)
const
{
return
isMutable
(
)
&
&
isWasm
(
)
&
&
(
isImport
(
)
|
|
isExport
(
)
)
;
}
ValType
type
(
)
const
{
switch
(
kind_
)
{
case
GlobalKind
:
:
Import
:
return
u
.
var
.
val
.
import
.
type_
;
case
GlobalKind
:
:
Variable
:
return
u
.
var
.
val
.
initial_
.
type
(
)
;
case
GlobalKind
:
:
Constant
:
return
u
.
cst_
.
type
(
)
;
}
MOZ_CRASH
(
"
unexpected
global
kind
"
)
;
}
}
;
typedef
Vector
<
GlobalDesc
0
SystemAllocPolicy
>
GlobalDescVector
;
#
ifdef
ENABLE_WASM_EXCEPTIONS
struct
EventDesc
{
EventKind
kind
;
ValTypeVector
type
;
bool
isExport
;
EventDesc
(
EventKind
kind
ValTypeVector
&
&
type
bool
isExport
=
false
)
:
kind
(
kind
)
type
(
std
:
:
move
(
type
)
)
isExport
(
isExport
)
{
}
ResultType
resultType
(
)
const
{
return
ResultType
:
:
Vector
(
type
)
;
}
}
;
typedef
Vector
<
EventDesc
0
SystemAllocPolicy
>
EventDescVector
;
#
endif
struct
ElemSegment
:
AtomicRefCounted
<
ElemSegment
>
{
enum
class
Kind
{
Active
Passive
Declared
}
;
Kind
kind
;
uint32_t
tableIndex
;
RefType
elemType
;
Maybe
<
InitExpr
>
offsetIfActive
;
Uint32Vector
elemFuncIndices
;
bool
active
(
)
const
{
return
kind
=
=
Kind
:
:
Active
;
}
InitExpr
offset
(
)
const
{
return
*
offsetIfActive
;
}
size_t
length
(
)
const
{
return
elemFuncIndices
.
length
(
)
;
}
WASM_DECLARE_SERIALIZABLE
(
ElemSegment
)
}
;
constexpr
uint32_t
NullFuncIndex
=
UINT32_MAX
;
static_assert
(
NullFuncIndex
>
MaxFuncs
"
Invariant
"
)
;
using
MutableElemSegment
=
RefPtr
<
ElemSegment
>
;
using
SharedElemSegment
=
SerializableRefPtr
<
const
ElemSegment
>
;
typedef
Vector
<
SharedElemSegment
0
SystemAllocPolicy
>
ElemSegmentVector
;
struct
DataSegmentEnv
{
Maybe
<
InitExpr
>
offsetIfActive
;
uint32_t
bytecodeOffset
;
uint32_t
length
;
}
;
typedef
Vector
<
DataSegmentEnv
0
SystemAllocPolicy
>
DataSegmentEnvVector
;
struct
DataSegment
:
AtomicRefCounted
<
DataSegment
>
{
Maybe
<
InitExpr
>
offsetIfActive
;
Bytes
bytes
;
DataSegment
(
)
=
default
;
explicit
DataSegment
(
const
DataSegmentEnv
&
src
)
:
offsetIfActive
(
src
.
offsetIfActive
)
{
}
bool
active
(
)
const
{
return
!
!
offsetIfActive
;
}
InitExpr
offset
(
)
const
{
return
*
offsetIfActive
;
}
WASM_DECLARE_SERIALIZABLE
(
DataSegment
)
}
;
using
MutableDataSegment
=
RefPtr
<
DataSegment
>
;
using
SharedDataSegment
=
SerializableRefPtr
<
const
DataSegment
>
;
typedef
Vector
<
SharedDataSegment
0
SystemAllocPolicy
>
DataSegmentVector
;
struct
CustomSectionEnv
{
uint32_t
nameOffset
;
uint32_t
nameLength
;
uint32_t
payloadOffset
;
uint32_t
payloadLength
;
}
;
typedef
Vector
<
CustomSectionEnv
0
SystemAllocPolicy
>
CustomSectionEnvVector
;
struct
CustomSection
{
Bytes
name
;
SharedBytes
payload
;
WASM_DECLARE_SERIALIZABLE
(
CustomSection
)
}
;
typedef
Vector
<
CustomSection
0
SystemAllocPolicy
>
CustomSectionVector
;
struct
Name
{
uint32_t
offsetInNamePayload
;
uint32_t
length
;
Name
(
)
:
offsetInNamePayload
(
UINT32_MAX
)
length
(
0
)
{
}
}
;
typedef
Vector
<
Name
0
SystemAllocPolicy
>
NameVector
;
enum
class
TypeDefKind
:
uint8_t
{
None
=
0
Func
Struct
Array
}
;
class
TypeDef
{
TypeDefKind
kind_
;
union
{
FuncType
funcType_
;
StructType
structType_
;
ArrayType
arrayType_
;
}
;
public
:
TypeDef
(
)
:
kind_
(
TypeDefKind
:
:
None
)
{
}
explicit
TypeDef
(
FuncType
&
&
funcType
)
:
kind_
(
TypeDefKind
:
:
Func
)
funcType_
(
std
:
:
move
(
funcType
)
)
{
}
explicit
TypeDef
(
StructType
&
&
structType
)
:
kind_
(
TypeDefKind
:
:
Struct
)
structType_
(
std
:
:
move
(
structType
)
)
{
}
explicit
TypeDef
(
ArrayType
&
&
arrayType
)
:
kind_
(
TypeDefKind
:
:
Array
)
arrayType_
(
std
:
:
move
(
arrayType
)
)
{
}
TypeDef
(
TypeDef
&
&
td
)
:
kind_
(
td
.
kind_
)
{
switch
(
kind_
)
{
case
TypeDefKind
:
:
Func
:
new
(
&
funcType_
)
FuncType
(
std
:
:
move
(
td
.
funcType_
)
)
;
break
;
case
TypeDefKind
:
:
Struct
:
new
(
&
structType_
)
StructType
(
std
:
:
move
(
td
.
structType_
)
)
;
break
;
case
TypeDefKind
:
:
Array
:
new
(
&
arrayType_
)
ArrayType
(
std
:
:
move
(
td
.
arrayType_
)
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
}
~
TypeDef
(
)
{
switch
(
kind_
)
{
case
TypeDefKind
:
:
Func
:
funcType_
.
~
FuncType
(
)
;
break
;
case
TypeDefKind
:
:
Struct
:
structType_
.
~
StructType
(
)
;
break
;
case
TypeDefKind
:
:
Array
:
arrayType_
.
~
ArrayType
(
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
}
TypeDef
&
operator
=
(
TypeDef
&
&
that
)
{
MOZ_ASSERT
(
isNone
(
)
)
;
switch
(
that
.
kind_
)
{
case
TypeDefKind
:
:
Func
:
new
(
&
funcType_
)
FuncType
(
std
:
:
move
(
that
.
funcType_
)
)
;
break
;
case
TypeDefKind
:
:
Struct
:
new
(
&
structType_
)
StructType
(
std
:
:
move
(
that
.
structType_
)
)
;
break
;
case
TypeDefKind
:
:
Array
:
new
(
&
arrayType_
)
ArrayType
(
std
:
:
move
(
that
.
arrayType_
)
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
kind_
=
that
.
kind_
;
return
*
this
;
}
[
[
nodiscard
]
]
bool
clone
(
const
TypeDef
&
src
)
{
MOZ_ASSERT
(
isNone
(
)
)
;
kind_
=
src
.
kind_
;
switch
(
src
.
kind_
)
{
case
TypeDefKind
:
:
Func
:
new
(
&
funcType_
)
FuncType
(
)
;
return
funcType_
.
clone
(
src
.
funcType
(
)
)
;
case
TypeDefKind
:
:
Struct
:
new
(
&
structType_
)
StructType
(
)
;
return
structType_
.
clone
(
src
.
structType
(
)
)
;
case
TypeDefKind
:
:
Array
:
new
(
&
arrayType_
)
ArrayType
(
src
.
arrayType
(
)
)
;
return
true
;
case
TypeDefKind
:
:
None
:
break
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
false
;
}
TypeDefKind
kind
(
)
const
{
return
kind_
;
}
bool
isNone
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
None
;
}
bool
isFuncType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Func
;
}
bool
isStructType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Struct
;
}
bool
isArrayType
(
)
const
{
return
kind_
=
=
TypeDefKind
:
:
Array
;
}
const
FuncType
&
funcType
(
)
const
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
FuncType
&
funcType
(
)
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
const
StructType
&
structType
(
)
const
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
StructType
&
structType
(
)
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
const
ArrayType
&
arrayType
(
)
const
{
MOZ_ASSERT
(
isArrayType
(
)
)
;
return
arrayType_
;
}
ArrayType
&
arrayType
(
)
{
MOZ_ASSERT
(
isArrayType
(
)
)
;
return
arrayType_
;
}
void
renumber
(
const
RenumberMap
&
map
)
{
switch
(
kind_
)
{
case
TypeDefKind
:
:
Func
:
funcType_
.
renumber
(
map
)
;
break
;
case
TypeDefKind
:
:
Struct
:
structType_
.
renumber
(
map
)
;
break
;
case
TypeDefKind
:
:
Array
:
arrayType_
.
renumber
(
map
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
}
void
offsetTypeIndex
(
uint32_t
offsetBy
)
{
switch
(
kind_
)
{
case
TypeDefKind
:
:
Func
:
funcType_
.
offsetTypeIndex
(
offsetBy
)
;
break
;
case
TypeDefKind
:
:
Struct
:
structType_
.
offsetTypeIndex
(
offsetBy
)
;
break
;
case
TypeDefKind
:
:
Array
:
arrayType_
.
offsetTypeIndex
(
offsetBy
)
;
break
;
case
TypeDefKind
:
:
None
:
break
;
}
}
WASM_DECLARE_SERIALIZABLE
(
TypeDef
)
}
;
typedef
Vector
<
TypeDef
0
SystemAllocPolicy
>
TypeDefVector
;
class
TypeIdDesc
{
public
:
static
const
uintptr_t
ImmediateBit
=
0x1
;
private
:
TypeIdDescKind
kind_
;
size_t
bits_
;
TypeIdDesc
(
TypeIdDescKind
kind
size_t
bits
)
:
kind_
(
kind
)
bits_
(
bits
)
{
}
public
:
TypeIdDescKind
kind
(
)
const
{
return
kind_
;
}
static
bool
isGlobal
(
const
TypeDef
&
type
)
;
TypeIdDesc
(
)
:
kind_
(
TypeIdDescKind
:
:
None
)
bits_
(
0
)
{
}
static
TypeIdDesc
global
(
const
TypeDef
&
type
uint32_t
globalDataOffset
)
;
static
TypeIdDesc
immediate
(
const
TypeDef
&
type
)
;
bool
isGlobal
(
)
const
{
return
kind_
=
=
TypeIdDescKind
:
:
Global
;
}
size_t
immediate
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
TypeIdDescKind
:
:
Immediate
)
;
return
bits_
;
}
uint32_t
globalDataOffset
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
TypeIdDescKind
:
:
Global
)
;
return
bits_
;
}
}
;
typedef
Vector
<
TypeIdDesc
0
SystemAllocPolicy
>
TypeIdDescVector
;
struct
TypeDefWithId
:
public
TypeDef
{
TypeIdDesc
id
;
TypeDefWithId
(
)
=
default
;
explicit
TypeDefWithId
(
TypeDef
&
&
typeDef
)
:
TypeDef
(
std
:
:
move
(
typeDef
)
)
id
(
)
{
}
TypeDefWithId
(
TypeDef
&
&
typeDef
TypeIdDesc
id
)
:
TypeDef
(
std
:
:
move
(
typeDef
)
)
id
(
id
)
{
}
WASM_DECLARE_SERIALIZABLE
(
TypeDefWithId
)
}
;
typedef
Vector
<
TypeDefWithId
0
SystemAllocPolicy
>
TypeDefWithIdVector
;
typedef
Vector
<
const
TypeDefWithId
*
0
SystemAllocPolicy
>
TypeDefWithIdPtrVector
;
class
TypeContext
{
FeatureArgs
features_
;
TypeDefVector
types_
;
public
:
TypeContext
(
const
FeatureArgs
&
features
TypeDefVector
&
&
types
)
:
features_
(
features
)
types_
(
std
:
:
move
(
types
)
)
{
}
TypeContext
(
const
TypeContext
&
)
=
delete
;
TypeContext
&
operator
=
(
const
TypeContext
&
)
=
delete
;
TypeContext
(
TypeContext
&
&
)
=
default
;
TypeContext
&
operator
=
(
TypeContext
&
&
)
=
default
;
TypeDef
&
type
(
uint32_t
index
)
{
return
types_
[
index
]
;
}
const
TypeDef
&
type
(
uint32_t
index
)
const
{
return
types_
[
index
]
;
}
TypeDef
&
operator
[
]
(
uint32_t
index
)
{
return
types_
[
index
]
;
}
const
TypeDef
&
operator
[
]
(
uint32_t
index
)
const
{
return
types_
[
index
]
;
}
uint32_t
length
(
)
const
{
return
types_
.
length
(
)
;
}
template
<
typename
U
>
[
[
nodiscard
]
]
bool
append
(
U
&
&
typeDef
)
{
return
types_
.
append
(
std
:
:
move
(
typeDef
)
)
;
}
[
[
nodiscard
]
]
bool
resize
(
uint32_t
length
)
{
return
types_
.
resize
(
length
)
;
}
[
[
nodiscard
]
]
bool
transferTypes
(
const
TypeDefWithIdVector
&
types
uint32_t
*
baseIndex
)
{
*
baseIndex
=
length
(
)
;
if
(
!
resize
(
*
baseIndex
+
types
.
length
(
)
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
types
.
length
(
)
;
i
+
+
)
{
if
(
!
types_
[
*
baseIndex
+
i
]
.
clone
(
types
[
i
]
)
)
{
return
false
;
}
types_
[
*
baseIndex
+
i
]
.
offsetTypeIndex
(
*
baseIndex
)
;
}
return
true
;
}
bool
isFuncType
(
uint32_t
index
)
const
{
return
types_
[
index
]
.
isFuncType
(
)
;
}
bool
isFuncType
(
RefType
t
)
const
{
return
t
.
isTypeIndex
(
)
&
&
isFuncType
(
t
.
typeIndex
(
)
)
;
}
FuncType
&
funcType
(
uint32_t
index
)
{
return
types_
[
index
]
.
funcType
(
)
;
}
const
FuncType
&
funcType
(
uint32_t
index
)
const
{
return
types_
[
index
]
.
funcType
(
)
;
}
FuncType
&
funcType
(
RefType
t
)
{
return
funcType
(
t
.
typeIndex
(
)
)
;
}
const
FuncType
&
funcType
(
RefType
t
)
const
{
return
funcType
(
t
.
typeIndex
(
)
)
;
}
bool
isStructType
(
uint32_t
index
)
const
{
return
types_
[
index
]
.
isStructType
(
)
;
}
bool
isStructType
(
RefType
t
)
const
{
return
t
.
isTypeIndex
(
)
&
&
isStructType
(
t
.
typeIndex
(
)
)
;
}
StructType
&
structType
(
uint32_t
index
)
{
return
types_
[
index
]
.
structType
(
)
;
}
const
StructType
&
structType
(
uint32_t
index
)
const
{
return
types_
[
index
]
.
structType
(
)
;
}
StructType
&
structType
(
RefType
t
)
{
return
structType
(
t
.
typeIndex
(
)
)
;
}
const
StructType
&
structType
(
RefType
t
)
const
{
return
structType
(
t
.
typeIndex
(
)
)
;
}
bool
isArrayType
(
uint32_t
index
)
const
{
return
types_
[
index
]
.
isArrayType
(
)
;
}
bool
isArrayType
(
RefType
t
)
const
{
return
t
.
isTypeIndex
(
)
&
&
isArrayType
(
t
.
typeIndex
(
)
)
;
}
ArrayType
&
arrayType
(
uint32_t
index
)
{
return
types_
[
index
]
.
arrayType
(
)
;
}
const
ArrayType
&
arrayType
(
uint32_t
index
)
const
{
return
types_
[
index
]
.
arrayType
(
)
;
}
ArrayType
&
arrayType
(
RefType
t
)
{
return
arrayType
(
t
.
typeIndex
(
)
)
;
}
const
ArrayType
&
arrayType
(
RefType
t
)
const
{
return
arrayType
(
t
.
typeIndex
(
)
)
;
}
template
<
class
T
>
bool
isSubtypeOf
(
T
one
T
two
)
const
{
if
(
one
=
=
two
)
{
return
true
;
}
if
(
one
.
isRtt
(
)
&
&
two
.
isRtt
(
)
&
&
one
.
typeIndex
(
)
=
=
two
.
typeIndex
(
)
)
{
return
true
;
}
return
one
.
isReference
(
)
&
&
two
.
isReference
(
)
&
&
isRefSubtypeOf
(
one
.
refType
(
)
two
.
refType
(
)
)
;
}
bool
isRefSubtypeOf
(
RefType
one
RefType
two
)
const
{
if
(
one
=
=
two
)
{
return
true
;
}
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
if
(
features_
.
functionReferences
)
{
if
(
!
(
one
.
isNullable
(
)
=
=
two
.
isNullable
(
)
|
|
two
.
isNullable
(
)
)
)
{
return
false
;
}
if
(
!
one
.
isTypeIndex
(
)
&
&
!
two
.
isTypeIndex
(
)
&
&
one
.
kind
(
)
=
=
two
.
kind
(
)
)
{
return
true
;
}
#
ifdef
ENABLE_WASM_GC
if
(
features_
.
gcTypes
)
{
if
(
isStructType
(
one
)
&
&
two
.
isEq
(
)
)
{
return
true
;
}
if
(
isArrayType
(
one
)
&
&
two
.
isEq
(
)
)
{
return
true
;
}
if
(
isStructType
(
one
)
&
&
isStructType
(
two
)
)
{
return
structType
(
one
)
.
hasPrefix
(
structType
(
two
)
)
;
}
if
(
isArrayType
(
one
)
&
&
isArrayType
(
two
)
)
{
return
isArraySubtypeOf
(
arrayType
(
one
)
arrayType
(
two
)
)
;
}
}
#
endif
return
false
;
}
#
endif
return
false
;
}
#
ifdef
ENABLE_WASM_GC
bool
isArraySubtypeOf
(
const
ArrayType
&
one
const
ArrayType
&
two
)
const
{
if
(
one
.
isMutable_
&
&
!
two
.
isMutable_
)
{
return
false
;
}
return
one
.
elementType_
=
=
two
.
elementType_
;
}
#
endif
size_t
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
types_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
class
TypeHandle
{
private
:
uint32_t
index_
;
public
:
explicit
TypeHandle
(
uint32_t
index
)
:
index_
(
index
)
{
}
TypeHandle
(
const
TypeHandle
&
)
=
default
;
TypeHandle
&
operator
=
(
const
TypeHandle
&
)
=
default
;
TypeDef
&
get
(
TypeContext
*
tycx
)
const
{
return
tycx
-
>
type
(
index_
)
;
}
const
TypeDef
&
get
(
const
TypeContext
*
tycx
)
const
{
return
tycx
-
>
type
(
index_
)
;
}
uint32_t
index
(
)
const
{
return
index_
;
}
}
;
class
BytecodeOffset
{
static
const
uint32_t
INVALID
=
-
1
;
uint32_t
offset_
;
public
:
BytecodeOffset
(
)
:
offset_
(
INVALID
)
{
}
explicit
BytecodeOffset
(
uint32_t
offset
)
:
offset_
(
offset
)
{
}
bool
isValid
(
)
const
{
return
offset_
!
=
INVALID
;
}
uint32_t
offset
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
offset_
;
}
}
;
struct
TrapSite
{
uint32_t
pcOffset
;
BytecodeOffset
bytecode
;
TrapSite
(
)
:
pcOffset
(
-
1
)
bytecode
(
)
{
}
TrapSite
(
uint32_t
pcOffset
BytecodeOffset
bytecode
)
:
pcOffset
(
pcOffset
)
bytecode
(
bytecode
)
{
}
void
offsetBy
(
uint32_t
offset
)
{
pcOffset
+
=
offset
;
}
}
;
WASM_DECLARE_POD_VECTOR
(
TrapSite
TrapSiteVector
)
struct
TrapSiteVectorArray
:
EnumeratedArray
<
Trap
Trap
:
:
Limit
TrapSiteVector
>
{
bool
empty
(
)
const
;
void
clear
(
)
;
void
swap
(
TrapSiteVectorArray
&
rhs
)
;
void
shrinkStorageToFit
(
)
;
WASM_DECLARE_SERIALIZABLE
(
TrapSiteVectorArray
)
}
;
struct
TrapData
{
void
*
resumePC
;
void
*
unwoundPC
;
Trap
trap
;
uint32_t
bytecodeOffset
;
}
;
struct
Offsets
{
explicit
Offsets
(
uint32_t
begin
=
0
uint32_t
end
=
0
)
:
begin
(
begin
)
end
(
end
)
{
}
uint32_t
begin
;
uint32_t
end
;
}
;
struct
CallableOffsets
:
Offsets
{
MOZ_IMPLICIT
CallableOffsets
(
uint32_t
ret
=
0
)
:
Offsets
(
)
ret
(
ret
)
{
}
uint32_t
ret
;
}
;
struct
JitExitOffsets
:
CallableOffsets
{
MOZ_IMPLICIT
JitExitOffsets
(
)
:
CallableOffsets
(
)
untrustedFPStart
(
0
)
untrustedFPEnd
(
0
)
{
}
uint32_t
untrustedFPStart
;
uint32_t
untrustedFPEnd
;
}
;
struct
FuncOffsets
:
CallableOffsets
{
MOZ_IMPLICIT
FuncOffsets
(
)
:
CallableOffsets
(
)
uncheckedCallEntry
(
0
)
tierEntry
(
0
)
{
}
uint32_t
uncheckedCallEntry
;
uint32_t
tierEntry
;
}
;
typedef
Vector
<
FuncOffsets
0
SystemAllocPolicy
>
FuncOffsetsVector
;
class
CodeRange
{
public
:
enum
Kind
{
Function
InterpEntry
JitEntry
ImportInterpExit
ImportJitExit
BuiltinThunk
TrapExit
DebugTrap
FarJumpIsland
Throw
}
;
private
:
uint32_t
begin_
;
uint32_t
ret_
;
uint32_t
end_
;
union
{
struct
{
uint32_t
funcIndex_
;
union
{
struct
{
uint32_t
lineOrBytecode_
;
uint8_t
beginToUncheckedCallEntry_
;
uint8_t
beginToTierEntry_
;
}
func
;
struct
{
uint16_t
beginToUntrustedFPStart_
;
uint16_t
beginToUntrustedFPEnd_
;
}
jitExit
;
}
;
}
;
Trap
trap_
;
}
u
;
Kind
kind_
:
8
;
public
:
CodeRange
(
)
=
default
;
CodeRange
(
Kind
kind
Offsets
offsets
)
;
CodeRange
(
Kind
kind
uint32_t
funcIndex
Offsets
offsets
)
;
CodeRange
(
Kind
kind
CallableOffsets
offsets
)
;
CodeRange
(
Kind
kind
uint32_t
funcIndex
CallableOffsets
)
;
CodeRange
(
uint32_t
funcIndex
JitExitOffsets
offsets
)
;
CodeRange
(
uint32_t
funcIndex
uint32_t
lineOrBytecode
FuncOffsets
offsets
)
;
void
offsetBy
(
uint32_t
offset
)
{
begin_
+
=
offset
;
end_
+
=
offset
;
if
(
hasReturn
(
)
)
{
ret_
+
=
offset
;
}
}
uint32_t
begin
(
)
const
{
return
begin_
;
}
uint32_t
end
(
)
const
{
return
end_
;
}
Kind
kind
(
)
const
{
return
kind_
;
}
bool
isFunction
(
)
const
{
return
kind
(
)
=
=
Function
;
}
bool
isImportExit
(
)
const
{
return
kind
(
)
=
=
ImportJitExit
|
|
kind
(
)
=
=
ImportInterpExit
|
|
kind
(
)
=
=
BuiltinThunk
;
}
bool
isImportInterpExit
(
)
const
{
return
kind
(
)
=
=
ImportInterpExit
;
}
bool
isImportJitExit
(
)
const
{
return
kind
(
)
=
=
ImportJitExit
;
}
bool
isTrapExit
(
)
const
{
return
kind
(
)
=
=
TrapExit
;
}
bool
isDebugTrap
(
)
const
{
return
kind
(
)
=
=
DebugTrap
;
}
bool
isThunk
(
)
const
{
return
kind
(
)
=
=
FarJumpIsland
;
}
bool
hasReturn
(
)
const
{
return
isFunction
(
)
|
|
isImportExit
(
)
|
|
isDebugTrap
(
)
;
}
uint32_t
ret
(
)
const
{
MOZ_ASSERT
(
hasReturn
(
)
)
;
return
ret_
;
}
bool
isJitEntry
(
)
const
{
return
kind
(
)
=
=
JitEntry
;
}
bool
isInterpEntry
(
)
const
{
return
kind
(
)
=
=
InterpEntry
;
}
bool
isEntry
(
)
const
{
return
isInterpEntry
(
)
|
|
isJitEntry
(
)
;
}
bool
hasFuncIndex
(
)
const
{
return
isFunction
(
)
|
|
isImportExit
(
)
|
|
isEntry
(
)
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
hasFuncIndex
(
)
)
;
return
u
.
funcIndex_
;
}
Trap
trap
(
)
const
{
MOZ_ASSERT
(
isTrapExit
(
)
)
;
return
u
.
trap_
;
}
uint32_t
funcCheckedCallEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
;
}
uint32_t
funcUncheckedCallEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
u
.
func
.
beginToUncheckedCallEntry_
;
}
uint32_t
funcTierEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
u
.
func
.
beginToTierEntry_
;
}
uint32_t
funcLineOrBytecode
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
u
.
func
.
lineOrBytecode_
;
}
uint32_t
jitExitUntrustedFPStart
(
)
const
{
MOZ_ASSERT
(
isImportJitExit
(
)
)
;
return
begin_
+
u
.
jitExit
.
beginToUntrustedFPStart_
;
}
uint32_t
jitExitUntrustedFPEnd
(
)
const
{
MOZ_ASSERT
(
isImportJitExit
(
)
)
;
return
begin_
+
u
.
jitExit
.
beginToUntrustedFPEnd_
;
}
struct
OffsetInCode
{
size_t
offset
;
explicit
OffsetInCode
(
size_t
offset
)
:
offset
(
offset
)
{
}
bool
operator
=
=
(
const
CodeRange
&
rhs
)
const
{
return
offset
>
=
rhs
.
begin
(
)
&
&
offset
<
rhs
.
end
(
)
;
}
bool
operator
<
(
const
CodeRange
&
rhs
)
const
{
return
offset
<
rhs
.
begin
(
)
;
}
}
;
}
;
WASM_DECLARE_POD_VECTOR
(
CodeRange
CodeRangeVector
)
extern
const
CodeRange
*
LookupInSorted
(
const
CodeRangeVector
&
codeRanges
CodeRange
:
:
OffsetInCode
target
)
;
class
CallSiteDesc
{
static
constexpr
size_t
LINE_OR_BYTECODE_BITS_SIZE
=
29
;
uint32_t
lineOrBytecode_
:
LINE_OR_BYTECODE_BITS_SIZE
;
uint32_t
kind_
:
3
;
public
:
static
constexpr
uint32_t
MAX_LINE_OR_BYTECODE_VALUE
=
(
1
<
<
LINE_OR_BYTECODE_BITS_SIZE
)
-
1
;
enum
Kind
{
Func
Dynamic
Symbolic
EnterFrame
LeaveFrame
Breakpoint
}
;
CallSiteDesc
(
)
:
lineOrBytecode_
(
0
)
kind_
(
0
)
{
}
explicit
CallSiteDesc
(
Kind
kind
)
:
lineOrBytecode_
(
0
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
=
=
Kind
(
kind_
)
)
;
}
CallSiteDesc
(
uint32_t
lineOrBytecode
Kind
kind
)
:
lineOrBytecode_
(
lineOrBytecode
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
=
=
Kind
(
kind_
)
)
;
MOZ_ASSERT
(
lineOrBytecode
=
=
lineOrBytecode_
)
;
}
uint32_t
lineOrBytecode
(
)
const
{
return
lineOrBytecode_
;
}
Kind
kind
(
)
const
{
return
Kind
(
kind_
)
;
}
bool
mightBeCrossInstance
(
)
const
{
return
kind
(
)
=
=
CallSiteDesc
:
:
Dynamic
;
}
}
;
class
CallSite
:
public
CallSiteDesc
{
uint32_t
returnAddressOffset_
;
public
:
CallSite
(
)
:
returnAddressOffset_
(
0
)
{
}
CallSite
(
CallSiteDesc
desc
uint32_t
returnAddressOffset
)
:
CallSiteDesc
(
desc
)
returnAddressOffset_
(
returnAddressOffset
)
{
}
void
offsetBy
(
int32_t
delta
)
{
returnAddressOffset_
+
=
delta
;
}
uint32_t
returnAddressOffset
(
)
const
{
return
returnAddressOffset_
;
}
}
;
WASM_DECLARE_POD_VECTOR
(
CallSite
CallSiteVector
)
class
CallSiteTarget
{
uint32_t
packed_
;
#
ifdef
DEBUG
enum
Kind
{
None
FuncIndex
TrapExit
}
kind_
;
#
endif
public
:
explicit
CallSiteTarget
(
)
:
packed_
(
UINT32_MAX
)
#
ifdef
DEBUG
kind_
(
None
)
#
endif
{
}
explicit
CallSiteTarget
(
uint32_t
funcIndex
)
:
packed_
(
funcIndex
)
#
ifdef
DEBUG
kind_
(
FuncIndex
)
#
endif
{
}
explicit
CallSiteTarget
(
Trap
trap
)
:
packed_
(
uint32_t
(
trap
)
)
#
ifdef
DEBUG
kind_
(
TrapExit
)
#
endif
{
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
FuncIndex
)
;
return
packed_
;
}
Trap
trap
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
TrapExit
)
;
MOZ_ASSERT
(
packed_
<
uint32_t
(
Trap
:
:
Limit
)
)
;
return
Trap
(
packed_
)
;
}
}
;
typedef
Vector
<
CallSiteTarget
0
SystemAllocPolicy
>
CallSiteTargetVector
;
struct
WasmTryNote
{
explicit
WasmTryNote
(
uint32_t
begin
=
0
uint32_t
end
=
0
uint32_t
framePushed
=
0
)
:
begin
(
begin
)
end
(
end
)
framePushed
(
framePushed
)
{
}
uint32_t
begin
;
uint32_t
end
;
uint32_t
entryPoint
;
uint32_t
framePushed
;
void
offsetBy
(
uint32_t
offset
)
{
begin
+
=
offset
;
end
+
=
offset
;
entryPoint
+
=
offset
;
}
bool
operator
<
(
const
WasmTryNote
&
other
)
const
{
if
(
end
=
=
other
.
end
)
{
return
begin
>
other
.
begin
;
}
else
{
return
end
<
other
.
end
;
}
}
}
;
WASM_DECLARE_POD_VECTOR
(
WasmTryNote
WasmTryNoteVector
)
enum
class
SymbolicAddress
{
ToInt32
#
if
defined
(
JS_CODEGEN_ARM
)
aeabi_idivmod
aeabi_uidivmod
#
endif
ModD
SinD
CosD
TanD
ASinD
ACosD
ATanD
CeilD
CeilF
FloorD
FloorF
TruncD
TruncF
NearbyIntD
NearbyIntF
ExpD
LogD
PowD
ATan2D
HandleDebugTrap
HandleThrow
HandleTrap
ReportV128JSCall
CallImport_General
CoerceInPlace_ToInt32
CoerceInPlace_ToNumber
CoerceInPlace_JitEntry
CoerceInPlace_ToBigInt
AllocateBigInt
BoxValue_Anyref
DivI64
UDivI64
ModI64
UModI64
TruncateDoubleToInt64
TruncateDoubleToUint64
SaturatingTruncateDoubleToInt64
SaturatingTruncateDoubleToUint64
Uint64ToFloat32
Uint64ToDouble
Int64ToFloat32
Int64ToDouble
MemoryGrow
MemorySize
WaitI32
WaitI64
Wake
MemCopy
MemCopyShared
DataDrop
MemFill
MemFillShared
MemInit
TableCopy
ElemDrop
TableFill
TableGet
TableGrow
TableInit
TableSet
TableSize
RefFunc
RefTest
RttSub
PreBarrierFiltering
PostBarrier
PostBarrierFiltering
StructNew
#
if
defined
(
ENABLE_WASM_EXCEPTIONS
)
ExceptionNew
ThrowException
GetLocalExceptionIndex
#
endif
ArrayNew
InlineTypedObjectClass
#
if
defined
(
JS_CODEGEN_MIPS32
)
js_jit_gAtomic64Lock
#
endif
#
ifdef
WASM_CODEGEN_DEBUG
PrintI32
PrintPtr
PrintF32
PrintF64
PrintText
#
endif
Limit
}
;
enum
class
FailureMode
:
uint8_t
{
Infallible
FailOnNegI32
FailOnNullPtr
FailOnInvalidRef
}
;
static
constexpr
size_t
SymbolicAddressSignatureMaxArgs
=
6
;
struct
SymbolicAddressSignature
{
const
SymbolicAddress
identity
;
const
jit
:
:
MIRType
retType
;
const
FailureMode
failureMode
;
const
uint8_t
numArgs
;
const
jit
:
:
MIRType
argTypes
[
SymbolicAddressSignatureMaxArgs
+
1
]
;
}
;
static_assert
(
sizeof
(
SymbolicAddressSignature
)
<
=
16
"
SymbolicAddressSignature
unexpectedly
large
"
)
;
bool
IsRoundingFunction
(
SymbolicAddress
callee
jit
:
:
RoundingMode
*
mode
)
;
struct
Limits
{
uint64_t
initial
;
Maybe
<
uint64_t
>
maximum
;
Shareable
shared
;
Limits
(
)
=
default
;
explicit
Limits
(
uint64_t
initial
const
Maybe
<
uint64_t
>
&
maximum
=
Nothing
(
)
Shareable
shared
=
Shareable
:
:
False
)
:
initial
(
initial
)
maximum
(
maximum
)
shared
(
shared
)
{
}
}
;
struct
TableDesc
{
RefType
elemType
;
bool
importedOrExported
;
bool
isAsmJS
;
uint32_t
globalDataOffset
;
uint32_t
initialLength
;
Maybe
<
uint32_t
>
maximumLength
;
TableDesc
(
)
=
default
;
TableDesc
(
RefType
elemType
uint32_t
initialLength
Maybe
<
uint32_t
>
maximumLength
bool
isAsmJS
bool
importedOrExported
=
false
)
:
elemType
(
elemType
)
importedOrExported
(
importedOrExported
)
isAsmJS
(
isAsmJS
)
globalDataOffset
(
UINT32_MAX
)
initialLength
(
initialLength
)
maximumLength
(
maximumLength
)
{
}
}
;
typedef
Vector
<
TableDesc
0
SystemAllocPolicy
>
TableDescVector
;
struct
TlsData
{
uint8_t
*
memoryBase
;
uint32_t
boundsCheckLimit32
;
Instance
*
instance
;
JS
:
:
Realm
*
realm
;
JSContext
*
cx
;
const
JSClass
*
valueBoxClass
;
Atomic
<
uintptr_t
mozilla
:
:
Relaxed
>
stackLimit
;
Atomic
<
uint32_t
mozilla
:
:
Relaxed
>
interrupt
;
uint8_t
*
addressOfNeedsIncrementalBarrier
;
void
setInterrupt
(
)
;
bool
isInterrupted
(
)
const
;
void
resetInterrupt
(
JSContext
*
cx
)
;
void
*
allocatedBase
;
void
*
*
jumpTable
;
MOZ_ALIGNED_DECL
(
16
char
globalArea
)
;
}
;
static
const
size_t
TlsDataAlign
=
16
;
static_assert
(
offsetof
(
TlsData
globalArea
)
%
TlsDataAlign
=
=
0
"
aligned
"
)
;
struct
TlsDataDeleter
{
void
operator
(
)
(
TlsData
*
tlsData
)
{
js_free
(
tlsData
-
>
allocatedBase
)
;
}
}
;
typedef
UniquePtr
<
TlsData
TlsDataDeleter
>
UniqueTlsData
;
extern
UniqueTlsData
CreateTlsData
(
uint32_t
globalDataLength
)
;
struct
ExportArg
{
uint64_t
lo
;
uint64_t
hi
;
}
;
using
ExportFuncPtr
=
int32_t
(
*
)
(
ExportArg
*
TlsData
*
)
;
struct
FuncImportTls
{
void
*
code
;
TlsData
*
tls
;
JS
:
:
Realm
*
realm
;
GCPtrFunction
fun
;
static_assert
(
sizeof
(
GCPtrFunction
)
=
=
sizeof
(
void
*
)
"
for
JIT
access
"
)
;
}
;
struct
TableTls
{
uint32_t
length
;
void
*
functionBase
;
}
;
struct
FunctionTableElem
{
void
*
code
;
TlsData
*
tls
;
}
;
class
CalleeDesc
{
public
:
enum
Which
{
Func
Import
WasmTable
AsmJSTable
Builtin
BuiltinInstanceMethod
}
;
private
:
MOZ_INIT_OUTSIDE_CTOR
Which
which_
;
union
U
{
U
(
)
:
funcIndex_
(
0
)
{
}
uint32_t
funcIndex_
;
struct
{
uint32_t
globalDataOffset_
;
}
import
;
struct
{
uint32_t
globalDataOffset_
;
uint32_t
minLength_
;
TypeIdDesc
funcTypeId_
;
}
table
;
SymbolicAddress
builtin_
;
}
u
;
public
:
CalleeDesc
(
)
=
default
;
static
CalleeDesc
function
(
uint32_t
funcIndex
)
{
CalleeDesc
c
;
c
.
which_
=
Func
;
c
.
u
.
funcIndex_
=
funcIndex
;
return
c
;
}
static
CalleeDesc
import
(
uint32_t
globalDataOffset
)
{
CalleeDesc
c
;
c
.
which_
=
Import
;
c
.
u
.
import
.
globalDataOffset_
=
globalDataOffset
;
return
c
;
}
static
CalleeDesc
wasmTable
(
const
TableDesc
&
desc
TypeIdDesc
funcTypeId
)
{
CalleeDesc
c
;
c
.
which_
=
WasmTable
;
c
.
u
.
table
.
globalDataOffset_
=
desc
.
globalDataOffset
;
c
.
u
.
table
.
minLength_
=
desc
.
initialLength
;
c
.
u
.
table
.
funcTypeId_
=
funcTypeId
;
return
c
;
}
static
CalleeDesc
asmJSTable
(
const
TableDesc
&
desc
)
{
CalleeDesc
c
;
c
.
which_
=
AsmJSTable
;
c
.
u
.
table
.
globalDataOffset_
=
desc
.
globalDataOffset
;
return
c
;
}
static
CalleeDesc
builtin
(
SymbolicAddress
callee
)
{
CalleeDesc
c
;
c
.
which_
=
Builtin
;
c
.
u
.
builtin_
=
callee
;
return
c
;
}
static
CalleeDesc
builtinInstanceMethod
(
SymbolicAddress
callee
)
{
CalleeDesc
c
;
c
.
which_
=
BuiltinInstanceMethod
;
c
.
u
.
builtin_
=
callee
;
return
c
;
}
Which
which
(
)
const
{
return
which_
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Func
)
;
return
u
.
funcIndex_
;
}
uint32_t
importGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Import
)
;
return
u
.
import
.
globalDataOffset_
;
}
bool
isTable
(
)
const
{
return
which_
=
=
WasmTable
|
|
which_
=
=
AsmJSTable
;
}
uint32_t
tableLengthGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
isTable
(
)
)
;
return
u
.
table
.
globalDataOffset_
+
offsetof
(
TableTls
length
)
;
}
uint32_t
tableFunctionBaseGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
isTable
(
)
)
;
return
u
.
table
.
globalDataOffset_
+
offsetof
(
TableTls
functionBase
)
;
}
TypeIdDesc
wasmTableSigId
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
funcTypeId_
;
}
uint32_t
wasmTableMinLength
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
minLength_
;
}
SymbolicAddress
builtin
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Builtin
|
|
which_
=
=
BuiltinInstanceMethod
)
;
return
u
.
builtin_
;
}
}
;
enum
class
MemoryKind
{
Memory32
Memory64
}
;
static
const
uint64_t
HighestValidARMImmediate
=
0xff000000
;
extern
bool
IsValidARMImmediate
(
uint32_t
i
)
;
extern
uint64_t
RoundUpToNextValidARMImmediate
(
uint64_t
i
)
;
static
const
unsigned
MaxMemoryAccessSize
=
LitVal
:
:
sizeofLargestValue
(
)
;
#
ifdef
WASM_SUPPORTS_HUGE_MEMORY
static
const
uint64_t
HugeIndexRange
=
uint64_t
(
UINT32_MAX
)
+
1
;
static
const
uint64_t
HugeOffsetGuardLimit
=
uint64_t
(
INT32_MAX
)
+
1
;
static
const
uint64_t
HugeUnalignedGuardPage
=
PageSize
;
static
const
uint64_t
HugeMappedSize
=
HugeIndexRange
+
HugeOffsetGuardLimit
+
HugeUnalignedGuardPage
;
static_assert
(
MaxMemoryAccessSize
<
=
HugeUnalignedGuardPage
"
rounded
up
to
static
page
size
"
)
;
static_assert
(
HugeOffsetGuardLimit
<
UINT32_MAX
"
checking
for
overflow
against
OffsetGuardLimit
is
enough
.
"
)
;
#
endif
static
const
size_t
OffsetGuardLimit
=
PageSize
-
MaxMemoryAccessSize
;
static
const
size_t
GuardSize
=
PageSize
;
static_assert
(
MaxMemoryAccessSize
<
GuardSize
"
Guard
page
handles
partial
out
-
of
-
bounds
"
)
;
static_assert
(
OffsetGuardLimit
<
UINT32_MAX
"
checking
for
overflow
against
OffsetGuardLimit
is
enough
.
"
)
;
static
constexpr
size_t
GetMaxOffsetGuardLimit
(
bool
hugeMemory
)
{
#
ifdef
WASM_SUPPORTS_HUGE_MEMORY
return
hugeMemory
?
HugeOffsetGuardLimit
:
OffsetGuardLimit
;
#
else
return
OffsetGuardLimit
;
#
endif
}
static
const
size_t
MinOffsetGuardLimit
=
OffsetGuardLimit
;
extern
bool
IsValidBoundsCheckImmediate
(
uint32_t
i
)
;
extern
size_t
ComputeMappedSize
(
uint64_t
maxSize
)
;
#
if
defined
(
JS_CODEGEN_X64
)
|
|
defined
(
JS_CODEGEN_ARM64
)
static
const
uint32_t
MaxInlineMemoryCopyLength
=
64
;
static
const
uint32_t
MaxInlineMemoryFillLength
=
64
;
#
elif
defined
(
JS_CODEGEN_X86
)
static
const
uint32_t
MaxInlineMemoryCopyLength
=
32
;
static
const
uint32_t
MaxInlineMemoryFillLength
=
32
;
#
else
static
const
uint32_t
MaxInlineMemoryCopyLength
=
0
;
static
const
uint32_t
MaxInlineMemoryFillLength
=
0
;
#
endif
static_assert
(
MaxInlineMemoryCopyLength
<
MinOffsetGuardLimit
"
precondition
"
)
;
static_assert
(
MaxInlineMemoryFillLength
<
MinOffsetGuardLimit
"
precondition
"
)
;
class
Frame
{
uint8_t
*
callerFP_
;
void
*
returnAddress_
;
public
:
static
constexpr
uint32_t
callerFPOffset
(
)
{
return
offsetof
(
Frame
callerFP_
)
;
}
static
constexpr
uint32_t
returnAddressOffset
(
)
{
return
offsetof
(
Frame
returnAddress_
)
;
}
uint8_t
*
returnAddress
(
)
const
{
return
reinterpret_cast
<
uint8_t
*
>
(
returnAddress_
)
;
}
void
*
*
addressOfReturnAddress
(
)
{
return
reinterpret_cast
<
void
*
*
>
(
&
returnAddress_
)
;
}
uint8_t
*
rawCaller
(
)
const
{
return
callerFP_
;
}
Frame
*
wasmCaller
(
)
const
{
MOZ_ASSERT
(
!
callerIsExitOrJitEntryFP
(
)
)
;
return
reinterpret_cast
<
Frame
*
>
(
callerFP_
)
;
}
bool
callerIsExitOrJitEntryFP
(
)
const
{
return
isExitOrJitEntryFP
(
callerFP_
)
;
}
uint8_t
*
jitEntryCaller
(
)
const
{
return
toJitEntryCaller
(
callerFP_
)
;
}
static
const
Frame
*
fromUntaggedWasmExitFP
(
const
void
*
savedFP
)
{
MOZ_ASSERT
(
!
isExitOrJitEntryFP
(
savedFP
)
)
;
return
reinterpret_cast
<
const
Frame
*
>
(
savedFP
)
;
}
static
bool
isExitOrJitEntryFP
(
const
void
*
fp
)
{
return
reinterpret_cast
<
uintptr_t
>
(
fp
)
&
ExitOrJitEntryFPTag
;
}
static
uint8_t
*
toJitEntryCaller
(
const
void
*
fp
)
{
MOZ_ASSERT
(
isExitOrJitEntryFP
(
fp
)
)
;
return
reinterpret_cast
<
uint8_t
*
>
(
reinterpret_cast
<
uintptr_t
>
(
fp
)
&
~
ExitOrJitEntryFPTag
)
;
}
static
uint8_t
*
addExitOrJitEntryFPTag
(
const
Frame
*
fp
)
{
MOZ_ASSERT
(
!
isExitOrJitEntryFP
(
fp
)
)
;
return
reinterpret_cast
<
uint8_t
*
>
(
reinterpret_cast
<
uintptr_t
>
(
fp
)
|
ExitOrJitEntryFPTag
)
;
}
}
;
static_assert
(
!
std
:
:
is_polymorphic_v
<
Frame
>
"
Frame
doesn
'
t
need
a
vtable
.
"
)
;
static_assert
(
sizeof
(
Frame
)
=
=
2
*
sizeof
(
void
*
)
"
Frame
is
a
two
pointer
structure
"
)
;
class
FrameWithTls
:
public
Frame
{
TlsData
*
calleeTls_
;
TlsData
*
callerTls_
;
public
:
TlsData
*
calleeTls
(
)
{
return
calleeTls_
;
}
TlsData
*
callerTls
(
)
{
return
callerTls_
;
}
constexpr
static
uint32_t
sizeWithoutFrame
(
)
{
return
sizeof
(
wasm
:
:
FrameWithTls
)
-
sizeof
(
wasm
:
:
Frame
)
;
}
constexpr
static
uint32_t
calleeTLSOffset
(
)
{
return
offsetof
(
FrameWithTls
calleeTls_
)
-
sizeof
(
wasm
:
:
Frame
)
;
}
constexpr
static
uint32_t
callerTLSOffset
(
)
{
return
offsetof
(
FrameWithTls
callerTls_
)
-
sizeof
(
wasm
:
:
Frame
)
;
}
}
;
static_assert
(
FrameWithTls
:
:
calleeTLSOffset
(
)
=
=
0u
"
Callee
tls
stored
right
above
the
return
address
.
"
)
;
static_assert
(
FrameWithTls
:
:
callerTLSOffset
(
)
=
=
sizeof
(
void
*
)
"
Caller
tls
stored
right
above
the
callee
tls
.
"
)
;
static_assert
(
FrameWithTls
:
:
sizeWithoutFrame
(
)
=
=
2
*
sizeof
(
void
*
)
"
There
are
only
two
additional
slots
"
)
;
#
if
defined
(
JS_CODEGEN_ARM64
)
static_assert
(
sizeof
(
Frame
)
%
16
=
=
0
"
frame
is
aligned
"
)
;
#
endif
class
DebugFrame
{
union
SpilledRegisterResult
{
private
:
int32_t
i32_
;
int64_t
i64_
;
intptr_t
ref_
;
AnyRef
anyref_
;
float
f32_
;
double
f64_
;
#
ifdef
ENABLE_WASM_SIMD
V128
v128_
;
#
endif
#
ifdef
DEBUG
static
inline
void
assertAllValueTypesHandled
(
ValType
type
)
{
switch
(
type
.
kind
(
)
)
{
case
ValType
:
:
I32
:
case
ValType
:
:
I64
:
case
ValType
:
:
F32
:
case
ValType
:
:
F64
:
case
ValType
:
:
V128
:
case
ValType
:
:
Rtt
:
return
;
case
ValType
:
:
Ref
:
switch
(
type
.
refTypeKind
(
)
)
{
case
RefType
:
:
Func
:
case
RefType
:
:
Extern
:
case
RefType
:
:
Eq
:
case
RefType
:
:
TypeIndex
:
return
;
}
}
}
#
endif
}
;
SpilledRegisterResult
registerResults_
[
MaxRegisterResults
]
;
js
:
:
Value
cachedReturnJSValue_
;
void
*
stackResultsPointer_
;
uint32_t
funcIndex_
;
union
Flags
{
struct
{
uint32_t
observing
:
1
;
uint32_t
isDebuggee
:
1
;
uint32_t
prevUpToDate
:
1
;
uint32_t
hasCachedSavedFrame
:
1
;
uint32_t
hasCachedReturnJSValue
:
1
;
uint32_t
hasSpilledRefRegisterResult
:
MaxRegisterResults
;
}
;
uint32_t
allFlags
;
}
flags_
;
protected
:
#
if
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_ARM
)
|
|
\
defined
(
JS_CODEGEN_X86
)
uint32_t
padding_
;
#
endif
#
if
defined
(
ENABLE_WASM_SIMD
)
&
&
defined
(
JS_CODEGEN_ARM64
)
uint64_t
padding_
;
#
endif
private
:
Frame
frame_
;
public
:
static
DebugFrame
*
from
(
Frame
*
fp
)
;
Frame
&
frame
(
)
{
return
frame_
;
}
uint32_t
funcIndex
(
)
const
{
return
funcIndex_
;
}
Instance
*
instance
(
)
const
;
GlobalObject
*
global
(
)
const
;
bool
hasGlobal
(
const
GlobalObject
*
global
)
const
;
JSObject
*
environmentChain
(
)
const
;
bool
getLocal
(
uint32_t
localIndex
MutableHandleValue
vp
)
;
bool
hasCachedReturnJSValue
(
)
const
{
return
flags_
.
hasCachedReturnJSValue
;
}
[
[
nodiscard
]
]
bool
updateReturnJSValue
(
JSContext
*
cx
)
;
HandleValue
returnValue
(
)
const
;
void
clearReturnJSValue
(
)
;
void
observe
(
JSContext
*
cx
)
;
void
leave
(
JSContext
*
cx
)
;
bool
isDebuggee
(
)
const
{
return
flags_
.
isDebuggee
;
}
void
setIsDebuggee
(
)
{
flags_
.
isDebuggee
=
true
;
}
void
unsetIsDebuggee
(
)
{
flags_
.
isDebuggee
=
false
;
}
bool
prevUpToDate
(
)
const
{
return
flags_
.
prevUpToDate
;
}
void
setPrevUpToDate
(
)
{
flags_
.
prevUpToDate
=
true
;
}
void
unsetPrevUpToDate
(
)
{
flags_
.
prevUpToDate
=
false
;
}
bool
hasCachedSavedFrame
(
)
const
{
return
flags_
.
hasCachedSavedFrame
;
}
void
setHasCachedSavedFrame
(
)
{
flags_
.
hasCachedSavedFrame
=
true
;
}
void
clearHasCachedSavedFrame
(
)
{
flags_
.
hasCachedSavedFrame
=
false
;
}
bool
hasSpilledRegisterRefResult
(
size_t
n
)
const
{
uint32_t
mask
=
hasSpilledRegisterRefResultBitMask
(
n
)
;
return
(
flags_
.
allFlags
&
mask
)
!
=
0
;
}
static
constexpr
size_t
offsetOfRegisterResults
(
)
{
return
offsetof
(
DebugFrame
registerResults_
)
;
}
static
constexpr
size_t
offsetOfRegisterResult
(
size_t
n
)
{
MOZ_ASSERT
(
n
<
MaxRegisterResults
)
;
return
offsetOfRegisterResults
(
)
+
n
*
sizeof
(
SpilledRegisterResult
)
;
}
static
constexpr
size_t
offsetOfCachedReturnJSValue
(
)
{
return
offsetof
(
DebugFrame
cachedReturnJSValue_
)
;
}
static
constexpr
size_t
offsetOfStackResultsPointer
(
)
{
return
offsetof
(
DebugFrame
stackResultsPointer_
)
;
}
static
constexpr
size_t
offsetOfFlags
(
)
{
return
offsetof
(
DebugFrame
flags_
)
;
}
static
constexpr
uint32_t
hasSpilledRegisterRefResultBitMask
(
size_t
n
)
{
MOZ_ASSERT
(
n
<
MaxRegisterResults
)
;
union
Flags
flags
=
{
.
allFlags
=
0
}
;
flags
.
hasSpilledRefRegisterResult
=
1
<
<
n
;
MOZ_ASSERT
(
flags
.
allFlags
!
=
0
)
;
return
flags
.
allFlags
;
}
static
constexpr
size_t
offsetOfFuncIndex
(
)
{
return
offsetof
(
DebugFrame
funcIndex_
)
;
}
static
constexpr
size_t
offsetOfFrame
(
)
{
return
offsetof
(
DebugFrame
frame_
)
;
}
static
const
unsigned
Alignment
=
8
;
static
void
alignmentStaticAsserts
(
)
;
}
;
extern
void
Log
(
JSContext
*
cx
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
enum
class
DebugChannel
{
Function
Import
}
;
#
ifdef
WASM_CODEGEN_DEBUG
bool
IsCodegenDebugEnabled
(
DebugChannel
channel
)
;
#
endif
void
DebugCodegen
(
DebugChannel
channel
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
using
PrintCallback
=
void
(
*
)
(
const
char
*
)
;
#
ifdef
ENABLE_WASM_SIMD_WORMHOLE
bool
IsWormholeTrigger
(
const
V128
&
shuffleMask
)
;
jit
:
:
SimdConstant
WormholeSignature
(
)
;
#
endif
}
template
<
>
struct
InternalBarrierMethods
<
wasm
:
:
Val
>
{
STATIC_ASSERT_ANYREF_IS_JSOBJECT
;
static
bool
isMarkable
(
const
wasm
:
:
Val
&
v
)
{
return
v
.
isJSObject
(
)
;
}
static
void
preBarrier
(
const
wasm
:
:
Val
&
v
)
{
if
(
v
.
isJSObject
(
)
)
{
gc
:
:
PreWriteBarrier
(
v
.
asJSObject
(
)
)
;
}
}
static
MOZ_ALWAYS_INLINE
void
postBarrier
(
wasm
:
:
Val
*
vp
const
wasm
:
:
Val
&
prev
const
wasm
:
:
Val
&
next
)
{
MOZ_RELEASE_ASSERT
(
!
prev
.
type
(
)
.
isValid
(
)
|
|
prev
.
type
(
)
=
=
next
.
type
(
)
)
;
JSObject
*
prevObj
=
prev
.
isJSObject
(
)
?
prev
.
asJSObject
(
)
:
nullptr
;
JSObject
*
nextObj
=
next
.
isJSObject
(
)
?
next
.
asJSObject
(
)
:
nullptr
;
if
(
nextObj
)
{
JSObject
:
:
postWriteBarrier
(
vp
-
>
asJSObjectAddress
(
)
prevObj
nextObj
)
;
}
}
static
void
readBarrier
(
const
wasm
:
:
Val
&
v
)
{
if
(
v
.
isJSObject
(
)
)
{
gc
:
:
ReadBarrier
(
v
.
asJSObject
(
)
)
;
}
}
#
ifdef
DEBUG
static
void
assertThingIsNotGray
(
const
wasm
:
:
Val
&
v
)
{
if
(
v
.
isJSObject
(
)
)
{
JS
:
:
AssertObjectIsNotGray
(
v
.
asJSObject
(
)
)
;
}
}
#
endif
}
;
}
#
endif
