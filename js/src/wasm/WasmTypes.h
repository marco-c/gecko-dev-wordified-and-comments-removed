#
ifndef
wasm_types_h
#
define
wasm_types_h
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
type_traits
>
#
include
"
NamespaceImports
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
js
/
RefCounted
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
MallocProvider
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmUtility
.
h
"
namespace
js
{
namespace
jit
{
class
JitScript
;
enum
class
RoundingMode
;
template
<
class
VecT
>
class
ABIArgIter
;
}
typedef
GCVector
<
JSFunction
*
0
SystemAllocPolicy
>
JSFunctionVector
;
class
WasmMemoryObject
;
using
GCPtrWasmMemoryObject
=
GCPtr
<
WasmMemoryObject
*
>
;
using
RootedWasmMemoryObject
=
Rooted
<
WasmMemoryObject
*
>
;
using
HandleWasmMemoryObject
=
Handle
<
WasmMemoryObject
*
>
;
using
MutableHandleWasmMemoryObject
=
MutableHandle
<
WasmMemoryObject
*
>
;
class
WasmModuleObject
;
using
RootedWasmModuleObject
=
Rooted
<
WasmModuleObject
*
>
;
using
HandleWasmModuleObject
=
Handle
<
WasmModuleObject
*
>
;
using
MutableHandleWasmModuleObject
=
MutableHandle
<
WasmModuleObject
*
>
;
class
WasmInstanceObject
;
using
WasmInstanceObjectVector
=
GCVector
<
WasmInstanceObject
*
>
;
using
RootedWasmInstanceObject
=
Rooted
<
WasmInstanceObject
*
>
;
using
HandleWasmInstanceObject
=
Handle
<
WasmInstanceObject
*
>
;
using
MutableHandleWasmInstanceObject
=
MutableHandle
<
WasmInstanceObject
*
>
;
class
WasmTableObject
;
typedef
GCVector
<
WasmTableObject
*
0
SystemAllocPolicy
>
WasmTableObjectVector
;
using
RootedWasmTableObject
=
Rooted
<
WasmTableObject
*
>
;
using
HandleWasmTableObject
=
Handle
<
WasmTableObject
*
>
;
using
MutableHandleWasmTableObject
=
MutableHandle
<
WasmTableObject
*
>
;
class
WasmGlobalObject
;
typedef
GCVector
<
WasmGlobalObject
*
0
SystemAllocPolicy
>
WasmGlobalObjectVector
;
using
RootedWasmGlobalObject
=
Rooted
<
WasmGlobalObject
*
>
;
class
StructTypeDescr
;
typedef
GCVector
<
HeapPtr
<
StructTypeDescr
*
>
0
SystemAllocPolicy
>
StructTypeDescrVector
;
namespace
wasm
{
using
mozilla
:
:
ArrayEqual
;
using
mozilla
:
:
Atomic
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
EnumeratedArray
;
using
mozilla
:
:
MallocSizeOf
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
PodZero
;
using
mozilla
:
:
Some
;
using
mozilla
:
:
Unused
;
class
Code
;
class
DebugState
;
class
GeneratedSourceMap
;
class
Memory
;
class
Module
;
class
Instance
;
class
Table
;
typedef
Vector
<
uint32_t
8
SystemAllocPolicy
>
Uint32Vector
;
typedef
Vector
<
uint8_t
0
SystemAllocPolicy
>
Bytes
;
using
UniqueBytes
=
UniquePtr
<
Bytes
>
;
using
UniqueConstBytes
=
UniquePtr
<
const
Bytes
>
;
typedef
Vector
<
char
0
SystemAllocPolicy
>
UTF8Bytes
;
typedef
Vector
<
Instance
*
0
SystemAllocPolicy
>
InstanceVector
;
typedef
Vector
<
UniqueChars
0
SystemAllocPolicy
>
UniqueCharsVector
;
constexpr
uintptr_t
ExitOrJitEntryFPTag
=
0x1
;
#
define
WASM_DECLARE_POD_VECTOR
(
Type
VectorName
)
\
}
\
}
\
namespace
mozilla
{
\
template
<
>
\
struct
IsPod
<
js
:
:
wasm
:
:
Type
>
:
std
:
:
true_type
{
}
;
\
}
\
namespace
js
{
\
namespace
wasm
{
\
typedef
Vector
<
Type
0
SystemAllocPolicy
>
VectorName
;
#
define
WASM_DECLARE_SERIALIZABLE
(
Type
)
\
size_t
serializedSize
(
)
const
;
\
uint8_t
*
serialize
(
uint8_t
*
cursor
)
const
;
\
const
uint8_t
*
deserialize
(
const
uint8_t
*
cursor
)
;
\
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
template
<
class
T
>
struct
SerializableRefPtr
:
RefPtr
<
T
>
{
using
RefPtr
<
T
>
:
:
operator
=
;
SerializableRefPtr
(
)
=
default
;
template
<
class
U
>
MOZ_IMPLICIT
SerializableRefPtr
(
U
&
&
u
)
:
RefPtr
<
T
>
(
std
:
:
forward
<
U
>
(
u
)
)
{
}
WASM_DECLARE_SERIALIZABLE
(
SerializableRefPtr
)
}
;
template
<
class
T
>
struct
ShareableBase
:
AtomicRefCounted
<
T
>
{
using
SeenSet
=
HashSet
<
const
T
*
DefaultHasher
<
const
T
*
>
SystemAllocPolicy
>
;
size_t
sizeOfIncludingThisIfNotSeen
(
MallocSizeOf
mallocSizeOf
SeenSet
*
seen
)
const
{
const
T
*
self
=
static_cast
<
const
T
*
>
(
this
)
;
typename
SeenSet
:
:
AddPtr
p
=
seen
-
>
lookupForAdd
(
self
)
;
if
(
p
)
{
return
0
;
}
bool
ok
=
seen
-
>
add
(
p
self
)
;
(
void
)
ok
;
return
mallocSizeOf
(
self
)
+
self
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
struct
ShareableBytes
:
ShareableBase
<
ShareableBytes
>
{
Bytes
bytes
;
ShareableBytes
(
)
=
default
;
explicit
ShareableBytes
(
Bytes
&
&
bytes
)
:
bytes
(
std
:
:
move
(
bytes
)
)
{
}
size_t
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
bytes
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
const
uint8_t
*
begin
(
)
const
{
return
bytes
.
begin
(
)
;
}
const
uint8_t
*
end
(
)
const
{
return
bytes
.
end
(
)
;
}
size_t
length
(
)
const
{
return
bytes
.
length
(
)
;
}
bool
append
(
const
uint8_t
*
start
uint32_t
len
)
{
return
bytes
.
append
(
start
len
)
;
}
}
;
using
MutableBytes
=
RefPtr
<
ShareableBytes
>
;
using
SharedBytes
=
RefPtr
<
const
ShareableBytes
>
;
class
Opcode
{
uint32_t
bits_
;
public
:
MOZ_IMPLICIT
Opcode
(
Op
op
)
:
bits_
(
uint32_t
(
op
)
)
{
static_assert
(
size_t
(
Op
:
:
Limit
)
=
=
256
"
fits
"
)
;
MOZ_ASSERT
(
size_t
(
op
)
<
size_t
(
Op
:
:
Limit
)
)
;
}
MOZ_IMPLICIT
Opcode
(
MiscOp
op
)
:
bits_
(
(
uint32_t
(
op
)
<
<
8
)
|
uint32_t
(
Op
:
:
MiscPrefix
)
)
{
static_assert
(
size_t
(
MiscOp
:
:
Limit
)
<
=
0xFFFFFF
"
fits
"
)
;
MOZ_ASSERT
(
size_t
(
op
)
<
size_t
(
MiscOp
:
:
Limit
)
)
;
}
MOZ_IMPLICIT
Opcode
(
ThreadOp
op
)
:
bits_
(
(
uint32_t
(
op
)
<
<
8
)
|
uint32_t
(
Op
:
:
ThreadPrefix
)
)
{
static_assert
(
size_t
(
ThreadOp
:
:
Limit
)
<
=
0xFFFFFF
"
fits
"
)
;
MOZ_ASSERT
(
size_t
(
op
)
<
size_t
(
ThreadOp
:
:
Limit
)
)
;
}
MOZ_IMPLICIT
Opcode
(
MozOp
op
)
:
bits_
(
(
uint32_t
(
op
)
<
<
8
)
|
uint32_t
(
Op
:
:
MozPrefix
)
)
{
static_assert
(
size_t
(
MozOp
:
:
Limit
)
<
=
0xFFFFFF
"
fits
"
)
;
MOZ_ASSERT
(
size_t
(
op
)
<
size_t
(
MozOp
:
:
Limit
)
)
;
}
MOZ_IMPLICIT
Opcode
(
SimdOp
op
)
:
bits_
(
(
uint32_t
(
op
)
<
<
8
)
|
uint32_t
(
Op
:
:
SimdPrefix
)
)
{
static_assert
(
size_t
(
SimdOp
:
:
Limit
)
<
=
0xFFFFFF
"
fits
"
)
;
MOZ_ASSERT
(
size_t
(
op
)
<
size_t
(
SimdOp
:
:
Limit
)
)
;
}
bool
isOp
(
)
const
{
return
bits_
<
uint32_t
(
Op
:
:
FirstPrefix
)
;
}
bool
isMisc
(
)
const
{
return
(
bits_
&
255
)
=
=
uint32_t
(
Op
:
:
MiscPrefix
)
;
}
bool
isThread
(
)
const
{
return
(
bits_
&
255
)
=
=
uint32_t
(
Op
:
:
ThreadPrefix
)
;
}
bool
isMoz
(
)
const
{
return
(
bits_
&
255
)
=
=
uint32_t
(
Op
:
:
MozPrefix
)
;
}
bool
isSimd
(
)
const
{
return
(
bits_
&
255
)
=
=
uint32_t
(
Op
:
:
SimdPrefix
)
;
}
Op
asOp
(
)
const
{
MOZ_ASSERT
(
isOp
(
)
)
;
return
Op
(
bits_
)
;
}
MiscOp
asMisc
(
)
const
{
MOZ_ASSERT
(
isMisc
(
)
)
;
return
MiscOp
(
bits_
>
>
8
)
;
}
ThreadOp
asThread
(
)
const
{
MOZ_ASSERT
(
isThread
(
)
)
;
return
ThreadOp
(
bits_
>
>
8
)
;
}
MozOp
asMoz
(
)
const
{
MOZ_ASSERT
(
isMoz
(
)
)
;
return
MozOp
(
bits_
>
>
8
)
;
}
SimdOp
asSimd
(
)
const
{
MOZ_ASSERT
(
isSimd
(
)
)
;
return
SimdOp
(
bits_
>
>
8
)
;
}
uint32_t
bits
(
)
const
{
return
bits_
;
}
bool
operator
=
=
(
const
Opcode
&
that
)
const
{
return
bits_
=
=
that
.
bits_
;
}
bool
operator
!
=
(
const
Opcode
&
that
)
const
{
return
bits_
!
=
that
.
bits_
;
}
}
;
enum
class
PackedTypeCode
:
uint32_t
{
}
;
static_assert
(
std
:
:
is_pod_v
<
PackedTypeCode
>
"
must
be
POD
to
be
simply
serialized
/
deserialized
"
)
;
const
uint32_t
NoTypeCode
=
0xFF
;
const
uint32_t
NoRefTypeIndex
=
0x3FFFFF
;
static
inline
PackedTypeCode
PackTypeCode
(
TypeCode
tc
uint32_t
refTypeIndex
)
{
MOZ_ASSERT
(
uint32_t
(
tc
)
<
=
0xFF
)
;
MOZ_ASSERT_IF
(
tc
!
=
TypeCode
:
:
OptRef
refTypeIndex
=
=
NoRefTypeIndex
)
;
MOZ_ASSERT_IF
(
tc
=
=
TypeCode
:
:
OptRef
refTypeIndex
<
=
MaxTypes
)
;
static_assert
(
MaxTypes
<
(
1
<
<
(
30
-
8
)
)
"
enough
bits
"
)
;
return
PackedTypeCode
(
(
refTypeIndex
<
<
8
)
|
uint32_t
(
tc
)
)
;
}
static
inline
PackedTypeCode
PackTypeCode
(
TypeCode
tc
)
{
return
PackTypeCode
(
tc
NoRefTypeIndex
)
;
}
static
inline
PackedTypeCode
InvalidPackedTypeCode
(
)
{
return
PackedTypeCode
(
NoTypeCode
)
;
}
static
inline
PackedTypeCode
PackedTypeCodeFromBits
(
uint32_t
bits
)
{
return
PackTypeCode
(
TypeCode
(
bits
&
255
)
bits
>
>
8
)
;
}
static
inline
bool
IsValid
(
PackedTypeCode
ptc
)
{
return
(
uint32_t
(
ptc
)
&
255
)
!
=
NoTypeCode
;
}
static
inline
uint32_t
PackedTypeCodeToBits
(
PackedTypeCode
ptc
)
{
return
uint32_t
(
ptc
)
;
}
static
inline
TypeCode
UnpackTypeCodeType
(
PackedTypeCode
ptc
)
{
MOZ_ASSERT
(
IsValid
(
ptc
)
)
;
return
TypeCode
(
uint32_t
(
ptc
)
&
255
)
;
}
static
inline
uint32_t
UnpackTypeCodeIndex
(
PackedTypeCode
ptc
)
{
MOZ_ASSERT
(
UnpackTypeCodeType
(
ptc
)
=
=
TypeCode
:
:
OptRef
)
;
return
uint32_t
(
ptc
)
>
>
8
;
}
static
inline
uint32_t
UnpackTypeCodeIndexUnchecked
(
PackedTypeCode
ptc
)
{
return
uint32_t
(
ptc
)
>
>
8
;
}
static
inline
TypeCode
UnpackTypeCodeTypeAbstracted
(
PackedTypeCode
ptc
)
{
TypeCode
c
=
UnpackTypeCodeType
(
ptc
)
;
return
c
<
LowestPrimitiveTypeCode
?
TypeCode
:
:
OptRef
:
c
;
}
static
inline
bool
IsReferenceType
(
PackedTypeCode
ptc
)
{
return
UnpackTypeCodeTypeAbstracted
(
ptc
)
=
=
TypeCode
:
:
OptRef
;
}
class
RefType
{
public
:
enum
Kind
{
Any
=
uint8_t
(
TypeCode
:
:
AnyRef
)
Func
=
uint8_t
(
TypeCode
:
:
FuncRef
)
TypeIndex
=
uint8_t
(
TypeCode
:
:
OptRef
)
}
;
private
:
PackedTypeCode
ptc_
;
#
ifdef
DEBUG
bool
isValid
(
)
const
{
switch
(
UnpackTypeCodeType
(
ptc_
)
)
{
case
TypeCode
:
:
FuncRef
:
case
TypeCode
:
:
AnyRef
:
MOZ_ASSERT
(
UnpackTypeCodeIndexUnchecked
(
ptc_
)
=
=
NoRefTypeIndex
)
;
return
true
;
case
TypeCode
:
:
OptRef
:
MOZ_ASSERT
(
UnpackTypeCodeIndexUnchecked
(
ptc_
)
!
=
NoRefTypeIndex
)
;
return
true
;
default
:
return
false
;
}
}
#
endif
explicit
RefType
(
Kind
kind
)
:
ptc_
(
PackTypeCode
(
TypeCode
(
kind
)
)
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
}
explicit
RefType
(
uint32_t
refTypeIndex
)
:
ptc_
(
PackTypeCode
(
TypeCode
:
:
OptRef
refTypeIndex
)
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
}
public
:
RefType
(
)
:
ptc_
(
InvalidPackedTypeCode
(
)
)
{
}
explicit
RefType
(
PackedTypeCode
ptc
)
:
ptc_
(
ptc
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
}
static
RefType
fromTypeCode
(
TypeCode
tc
)
{
MOZ_ASSERT
(
tc
!
=
TypeCode
:
:
OptRef
)
;
return
RefType
(
Kind
(
tc
)
)
;
}
static
RefType
fromTypeIndex
(
uint32_t
refTypeIndex
)
{
return
RefType
(
refTypeIndex
)
;
}
Kind
kind
(
)
const
{
return
Kind
(
UnpackTypeCodeType
(
ptc_
)
)
;
}
uint32_t
typeIndex
(
)
const
{
return
UnpackTypeCodeIndex
(
ptc_
)
;
}
PackedTypeCode
packed
(
)
const
{
return
ptc_
;
}
static
RefType
any
(
)
{
return
RefType
(
Any
)
;
}
static
RefType
func
(
)
{
return
RefType
(
Func
)
;
}
bool
operator
=
=
(
const
RefType
&
that
)
const
{
return
ptc_
=
=
that
.
ptc_
;
}
bool
operator
!
=
(
const
RefType
&
that
)
const
{
return
ptc_
!
=
that
.
ptc_
;
}
}
;
class
ValType
{
PackedTypeCode
tc_
;
#
ifdef
DEBUG
bool
isValidTypeCode
(
)
{
MOZ_ASSERT
(
isValid
(
)
)
;
switch
(
UnpackTypeCodeType
(
tc_
)
)
{
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
case
TypeCode
:
:
V128
:
case
TypeCode
:
:
AnyRef
:
case
TypeCode
:
:
FuncRef
:
case
TypeCode
:
:
OptRef
:
return
true
;
default
:
return
false
;
}
}
#
endif
public
:
enum
Kind
{
I32
=
uint8_t
(
TypeCode
:
:
I32
)
I64
=
uint8_t
(
TypeCode
:
:
I64
)
F32
=
uint8_t
(
TypeCode
:
:
F32
)
F64
=
uint8_t
(
TypeCode
:
:
F64
)
V128
=
uint8_t
(
TypeCode
:
:
V128
)
Ref
=
uint8_t
(
TypeCode
:
:
OptRef
)
}
;
private
:
explicit
ValType
(
TypeCode
c
)
:
tc_
(
PackTypeCode
(
c
)
)
{
MOZ_ASSERT
(
c
!
=
TypeCode
:
:
OptRef
)
;
MOZ_ASSERT
(
isValid
(
)
)
;
}
TypeCode
typeCode
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
UnpackTypeCodeType
(
tc_
)
;
}
public
:
ValType
(
)
:
tc_
(
InvalidPackedTypeCode
(
)
)
{
}
MOZ_IMPLICIT
ValType
(
Kind
c
)
:
tc_
(
PackTypeCode
(
TypeCode
(
c
)
)
)
{
MOZ_ASSERT
(
c
!
=
Ref
)
;
MOZ_ASSERT
(
isValidTypeCode
(
)
)
;
}
MOZ_IMPLICIT
ValType
(
RefType
rt
)
:
tc_
(
rt
.
packed
(
)
)
{
MOZ_ASSERT
(
isValidTypeCode
(
)
)
;
}
explicit
ValType
(
PackedTypeCode
ptc
)
:
tc_
(
ptc
)
{
MOZ_ASSERT
(
isValidTypeCode
(
)
)
;
}
explicit
ValType
(
jit
:
:
MIRType
mty
)
{
switch
(
mty
)
{
case
jit
:
:
MIRType
:
:
Int32
:
tc_
=
PackTypeCode
(
TypeCode
:
:
I32
)
;
break
;
case
jit
:
:
MIRType
:
:
Int64
:
tc_
=
PackTypeCode
(
TypeCode
:
:
I64
)
;
break
;
case
jit
:
:
MIRType
:
:
Float32
:
tc_
=
PackTypeCode
(
TypeCode
:
:
F32
)
;
break
;
case
jit
:
:
MIRType
:
:
Double
:
tc_
=
PackTypeCode
(
TypeCode
:
:
F64
)
;
break
;
case
jit
:
:
MIRType
:
:
Simd128
:
tc_
=
PackTypeCode
(
TypeCode
:
:
V128
)
;
break
;
default
:
MOZ_CRASH
(
"
ValType
(
MIRType
)
:
unexpected
type
"
)
;
}
}
static
ValType
fromNonRefTypeCode
(
TypeCode
tc
)
{
#
ifdef
DEBUG
switch
(
tc
)
{
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
case
TypeCode
:
:
V128
:
break
;
default
:
MOZ_CRASH
(
"
Bad
type
code
"
)
;
}
#
endif
return
ValType
(
tc
)
;
}
static
ValType
fromBitsUnsafe
(
uint32_t
bits
)
{
return
ValType
(
PackedTypeCodeFromBits
(
bits
)
)
;
}
bool
isValid
(
)
const
{
return
IsValid
(
tc_
)
;
}
PackedTypeCode
packed
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
tc_
;
}
uint32_t
bitsUnsafe
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
PackedTypeCodeToBits
(
tc_
)
;
}
bool
isAnyRef
(
)
const
{
return
UnpackTypeCodeType
(
tc_
)
=
=
TypeCode
:
:
AnyRef
;
}
bool
isFuncRef
(
)
const
{
return
UnpackTypeCodeType
(
tc_
)
=
=
TypeCode
:
:
FuncRef
;
}
bool
isNullable
(
)
const
{
MOZ_ASSERT
(
isReference
(
)
)
;
return
true
;
}
bool
isTypeIndex
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
UnpackTypeCodeType
(
tc_
)
=
=
TypeCode
:
:
OptRef
;
}
bool
isReference
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
IsReferenceType
(
tc_
)
;
}
Kind
kind
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
Kind
(
UnpackTypeCodeTypeAbstracted
(
tc_
)
)
;
}
RefType
refType
(
)
const
{
MOZ_ASSERT
(
isReference
(
)
)
;
return
RefType
(
tc_
)
;
}
RefType
:
:
Kind
refTypeKind
(
)
const
{
MOZ_ASSERT
(
isReference
(
)
)
;
return
RefType
(
tc_
)
.
kind
(
)
;
}
bool
isEncodedAsJSValueOnEscape
(
)
const
{
switch
(
typeCode
(
)
)
{
case
TypeCode
:
:
AnyRef
:
case
TypeCode
:
:
FuncRef
:
return
true
;
default
:
return
false
;
}
}
bool
operator
=
=
(
const
ValType
&
that
)
const
{
MOZ_ASSERT
(
isValid
(
)
&
&
that
.
isValid
(
)
)
;
return
tc_
=
=
that
.
tc_
;
}
bool
operator
!
=
(
const
ValType
&
that
)
const
{
MOZ_ASSERT
(
isValid
(
)
&
&
that
.
isValid
(
)
)
;
return
tc_
!
=
that
.
tc_
;
}
bool
operator
=
=
(
Kind
that
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
MOZ_ASSERT
(
that
!
=
Kind
:
:
Ref
)
;
return
Kind
(
typeCode
(
)
)
=
=
that
;
}
bool
operator
!
=
(
Kind
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
}
;
struct
V128
{
uint8_t
bytes
[
16
]
;
V128
(
)
{
memset
(
bytes
0
sizeof
(
bytes
)
)
;
}
template
<
typename
T
>
T
extractLane
(
unsigned
lane
)
const
{
T
result
;
MOZ_ASSERT
(
lane
<
16
/
sizeof
(
T
)
)
;
memcpy
(
&
result
bytes
+
sizeof
(
T
)
*
lane
sizeof
(
T
)
)
;
return
result
;
}
template
<
typename
T
>
void
insertLane
(
unsigned
lane
T
value
)
{
MOZ_ASSERT
(
lane
<
16
/
sizeof
(
T
)
)
;
memcpy
(
bytes
+
sizeof
(
T
)
*
lane
&
value
sizeof
(
T
)
)
;
}
}
;
static_assert
(
sizeof
(
V128
)
=
=
16
"
Invariant
"
)
;
typedef
Vector
<
ValType
16
SystemAllocPolicy
>
ValTypeVector
;
static
inline
unsigned
SizeOf
(
ValType
vt
)
{
switch
(
vt
.
kind
(
)
)
{
case
ValType
:
:
I32
:
case
ValType
:
:
F32
:
return
4
;
case
ValType
:
:
I64
:
case
ValType
:
:
F64
:
return
8
;
case
ValType
:
:
V128
:
return
16
;
case
ValType
:
:
Ref
:
return
sizeof
(
intptr_t
)
;
}
MOZ_CRASH
(
"
Invalid
ValType
"
)
;
}
static
inline
jit
:
:
MIRType
ToMIRType
(
ValType
vt
)
{
switch
(
vt
.
kind
(
)
)
{
case
ValType
:
:
I32
:
return
jit
:
:
MIRType
:
:
Int32
;
case
ValType
:
:
I64
:
return
jit
:
:
MIRType
:
:
Int64
;
case
ValType
:
:
F32
:
return
jit
:
:
MIRType
:
:
Float32
;
case
ValType
:
:
F64
:
return
jit
:
:
MIRType
:
:
Double
;
case
ValType
:
:
V128
:
return
jit
:
:
MIRType
:
:
Simd128
;
case
ValType
:
:
Ref
:
return
jit
:
:
MIRType
:
:
RefOrNull
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
bad
type
"
)
;
}
static
inline
bool
IsNumberType
(
ValType
vt
)
{
return
!
vt
.
isReference
(
)
;
}
static
inline
jit
:
:
MIRType
ToMIRType
(
const
Maybe
<
ValType
>
&
t
)
{
return
t
?
ToMIRType
(
ValType
(
t
.
ref
(
)
)
)
:
jit
:
:
MIRType
:
:
None
;
}
extern
UniqueChars
ToString
(
ValType
type
)
;
static
inline
const
char
*
ToCString
(
ValType
type
)
{
switch
(
type
.
kind
(
)
)
{
case
ValType
:
:
I32
:
return
"
i32
"
;
case
ValType
:
:
I64
:
return
"
i64
"
;
case
ValType
:
:
V128
:
return
"
v128
"
;
case
ValType
:
:
F32
:
return
"
f32
"
;
case
ValType
:
:
F64
:
return
"
f64
"
;
case
ValType
:
:
Ref
:
switch
(
type
.
refTypeKind
(
)
)
{
case
RefType
:
:
Any
:
return
"
externref
"
;
case
RefType
:
:
Func
:
return
"
funcref
"
;
case
RefType
:
:
TypeIndex
:
return
"
optref
"
;
}
}
MOZ_CRASH
(
"
bad
value
type
"
)
;
}
static
inline
const
char
*
ToCString
(
const
Maybe
<
ValType
>
&
type
)
{
return
type
?
ToCString
(
type
.
ref
(
)
)
:
"
void
"
;
}
class
AnyRef
{
JSObject
*
value_
;
explicit
AnyRef
(
)
:
value_
(
(
JSObject
*
)
-
1
)
{
}
explicit
AnyRef
(
JSObject
*
p
)
:
value_
(
p
)
{
MOZ_ASSERT
(
(
(
uintptr_t
)
p
&
0x03
)
=
=
0
)
;
}
public
:
static
AnyRef
invalid
(
)
{
return
AnyRef
(
)
;
}
static
AnyRef
fromCompiledCode
(
void
*
p
)
{
return
AnyRef
(
(
JSObject
*
)
p
)
;
}
static
AnyRef
fromJSObject
(
JSObject
*
p
)
{
return
AnyRef
(
p
)
;
}
static
AnyRef
null
(
)
{
return
AnyRef
(
nullptr
)
;
}
bool
isNull
(
)
{
return
value_
=
=
nullptr
;
}
void
*
forCompiledCode
(
)
const
{
return
value_
;
}
JSObject
*
asJSObject
(
)
{
return
value_
;
}
JSObject
*
*
asJSObjectAddress
(
)
{
return
&
value_
;
}
void
trace
(
JSTracer
*
trc
)
;
static
constexpr
uintptr_t
AnyRefTagMask
=
1
;
static
constexpr
uintptr_t
AnyRefObjTag
=
0
;
}
;
using
RootedAnyRef
=
Rooted
<
AnyRef
>
;
using
HandleAnyRef
=
Handle
<
AnyRef
>
;
using
MutableHandleAnyRef
=
MutableHandle
<
AnyRef
>
;
#
define
ASSERT_ANYREF_IS_JSOBJECT
(
void
)
(
0
)
#
define
STATIC_ASSERT_ANYREF_IS_JSOBJECT
static_assert
(
1
"
AnyRef
is
JSObject
"
)
bool
BoxAnyRef
(
JSContext
*
cx
HandleValue
val
MutableHandleAnyRef
result
)
;
JSObject
*
BoxBoxableValue
(
JSContext
*
cx
HandleValue
val
)
;
Value
UnboxAnyRef
(
AnyRef
val
)
;
class
WasmValueBox
:
public
NativeObject
{
static
const
unsigned
VALUE_SLOT
=
0
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
1
;
static
const
JSClass
class_
;
static
WasmValueBox
*
create
(
JSContext
*
cx
HandleValue
val
)
;
Value
value
(
)
const
{
return
getFixedSlot
(
VALUE_SLOT
)
;
}
static
size_t
offsetOfValue
(
)
{
return
NativeObject
:
:
getFixedSlotOffset
(
VALUE_SLOT
)
;
}
}
;
class
FuncRef
{
JSFunction
*
value_
;
explicit
FuncRef
(
)
:
value_
(
(
JSFunction
*
)
-
1
)
{
}
explicit
FuncRef
(
JSFunction
*
p
)
:
value_
(
p
)
{
MOZ_ASSERT
(
(
(
uintptr_t
)
p
&
0x03
)
=
=
0
)
;
}
public
:
static
FuncRef
fromCompiledCode
(
void
*
p
)
{
return
FuncRef
(
(
JSFunction
*
)
p
)
;
}
static
FuncRef
fromJSFunction
(
JSFunction
*
p
)
{
return
FuncRef
(
p
)
;
}
static
FuncRef
fromAnyRefUnchecked
(
AnyRef
p
)
{
#
ifdef
DEBUG
Value
v
=
UnboxAnyRef
(
p
)
;
if
(
v
.
isNull
(
)
)
{
return
FuncRef
(
nullptr
)
;
}
if
(
v
.
toObject
(
)
.
is
<
JSFunction
>
(
)
)
{
return
FuncRef
(
&
v
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
}
MOZ_CRASH
(
"
Bad
value
"
)
;
#
else
return
FuncRef
(
&
p
.
asJSObject
(
)
-
>
as
<
JSFunction
>
(
)
)
;
#
endif
}
AnyRef
asAnyRef
(
)
{
return
AnyRef
:
:
fromJSObject
(
(
JSObject
*
)
value_
)
;
}
void
*
forCompiledCode
(
)
const
{
return
value_
;
}
JSFunction
*
asJSFunction
(
)
{
return
value_
;
}
bool
isNull
(
)
{
return
value_
=
=
nullptr
;
}
}
;
using
RootedFuncRef
=
Rooted
<
FuncRef
>
;
using
HandleFuncRef
=
Handle
<
FuncRef
>
;
using
MutableHandleFuncRef
=
MutableHandle
<
FuncRef
>
;
Value
UnboxFuncRef
(
FuncRef
val
)
;
enum
class
Tier
{
Baseline
Debug
=
Baseline
Optimized
Serialized
=
Optimized
}
;
enum
class
OptimizedBackend
{
Ion
Cranelift
}
;
enum
class
CompileMode
{
Once
Tier1
Tier2
}
;
enum
class
DebugEnabled
{
False
True
}
;
enum
class
MemoryUsage
{
None
=
false
Unshared
=
1
Shared
=
2
}
;
class
Tiers
{
Tier
t_
[
2
]
;
uint32_t
n_
;
public
:
explicit
Tiers
(
)
{
n_
=
0
;
}
explicit
Tiers
(
Tier
t
)
{
t_
[
0
]
=
t
;
n_
=
1
;
}
explicit
Tiers
(
Tier
t
Tier
u
)
{
MOZ_ASSERT
(
t
!
=
u
)
;
t_
[
0
]
=
t
;
t_
[
1
]
=
u
;
n_
=
2
;
}
Tier
*
begin
(
)
{
return
t_
;
}
Tier
*
end
(
)
{
return
t_
+
n_
;
}
}
;
enum
ModuleKind
{
Wasm
AsmJS
}
;
enum
class
Shareable
{
False
True
}
;
class
LitVal
{
protected
:
ValType
type_
;
union
U
{
U
(
)
:
i32_
(
0
)
{
}
uint32_t
i32_
;
uint64_t
i64_
;
float
f32_
;
double
f64_
;
AnyRef
ref_
;
V128
v128_
;
}
u
;
public
:
LitVal
(
)
:
type_
(
)
u
{
}
{
}
explicit
LitVal
(
ValType
type
)
:
type_
(
type
)
{
switch
(
type
.
kind
(
)
)
{
case
ValType
:
:
Kind
:
:
I32
:
{
u
.
i32_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
I64
:
{
u
.
i64_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
F32
:
{
u
.
f32_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
F64
:
{
u
.
f64_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
V128
:
{
new
(
&
u
.
v128_
)
V128
(
)
;
break
;
}
case
ValType
:
:
Kind
:
:
Ref
:
{
u
.
ref_
=
AnyRef
:
:
null
(
)
;
break
;
}
}
}
explicit
LitVal
(
uint32_t
i32
)
:
type_
(
ValType
:
:
I32
)
{
u
.
i32_
=
i32
;
}
explicit
LitVal
(
uint64_t
i64
)
:
type_
(
ValType
:
:
I64
)
{
u
.
i64_
=
i64
;
}
explicit
LitVal
(
float
f32
)
:
type_
(
ValType
:
:
F32
)
{
u
.
f32_
=
f32
;
}
explicit
LitVal
(
double
f64
)
:
type_
(
ValType
:
:
F64
)
{
u
.
f64_
=
f64
;
}
explicit
LitVal
(
V128
v128
)
:
type_
(
ValType
:
:
V128
)
{
u
.
v128_
=
v128
;
}
explicit
LitVal
(
ValType
type
AnyRef
any
)
:
type_
(
type
)
{
MOZ_ASSERT
(
type
.
isReference
(
)
)
;
MOZ_ASSERT
(
any
.
isNull
(
)
"
use
Val
for
non
-
nullptr
ref
types
to
get
tracing
"
)
;
u
.
ref_
=
any
;
}
ValType
type
(
)
const
{
return
type_
;
}
static
constexpr
size_t
sizeofLargestValue
(
)
{
return
sizeof
(
u
)
;
}
uint32_t
i32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I32
)
;
return
u
.
i32_
;
}
uint64_t
i64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I64
)
;
return
u
.
i64_
;
}
const
float
&
f32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F32
)
;
return
u
.
f32_
;
}
const
double
&
f64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F64
)
;
return
u
.
f64_
;
}
AnyRef
ref
(
)
const
{
MOZ_ASSERT
(
type_
.
isReference
(
)
)
;
return
u
.
ref_
;
}
const
V128
&
v128
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
V128
)
;
return
u
.
v128_
;
}
}
;
class
MOZ_NON_PARAM
Val
:
public
LitVal
{
public
:
Val
(
)
:
LitVal
(
)
{
}
explicit
Val
(
ValType
type
)
:
LitVal
(
type
)
{
}
explicit
Val
(
const
LitVal
&
val
)
;
explicit
Val
(
uint32_t
i32
)
:
LitVal
(
i32
)
{
}
explicit
Val
(
uint64_t
i64
)
:
LitVal
(
i64
)
{
}
explicit
Val
(
float
f32
)
:
LitVal
(
f32
)
{
}
explicit
Val
(
double
f64
)
:
LitVal
(
f64
)
{
}
explicit
Val
(
V128
v128
)
:
LitVal
(
v128
)
{
}
explicit
Val
(
ValType
type
AnyRef
val
)
:
LitVal
(
type
AnyRef
:
:
null
(
)
)
{
MOZ_ASSERT
(
type
.
isReference
(
)
)
;
u
.
ref_
=
val
;
}
explicit
Val
(
ValType
type
FuncRef
val
)
:
LitVal
(
type
AnyRef
:
:
null
(
)
)
{
MOZ_ASSERT
(
type
.
isFuncRef
(
)
)
;
u
.
ref_
=
val
.
asAnyRef
(
)
;
}
void
trace
(
JSTracer
*
trc
)
;
}
;
using
RootedVal
=
Rooted
<
Val
>
;
using
HandleVal
=
Handle
<
Val
>
;
using
MutableHandleVal
=
MutableHandle
<
Val
>
;
typedef
GCVector
<
Val
0
SystemAllocPolicy
>
ValVector
;
using
RootedValVector
=
Rooted
<
ValVector
>
;
using
HandleValVector
=
Handle
<
ValVector
>
;
using
MutableHandleValVector
=
MutableHandle
<
ValVector
>
;
class
FuncType
{
ValTypeVector
args_
;
ValTypeVector
results_
;
public
:
FuncType
(
)
:
args_
(
)
results_
(
)
{
}
FuncType
(
ValTypeVector
&
&
args
ValTypeVector
&
&
results
)
:
args_
(
std
:
:
move
(
args
)
)
results_
(
std
:
:
move
(
results
)
)
{
}
MOZ_MUST_USE
bool
clone
(
const
FuncType
&
rhs
)
{
MOZ_ASSERT
(
args_
.
empty
(
)
)
;
MOZ_ASSERT
(
results_
.
empty
(
)
)
;
return
args_
.
appendAll
(
rhs
.
args_
)
&
&
results_
.
appendAll
(
rhs
.
results_
)
;
}
ValType
arg
(
unsigned
i
)
const
{
return
args_
[
i
]
;
}
const
ValTypeVector
&
args
(
)
const
{
return
args_
;
}
ValType
result
(
unsigned
i
)
const
{
return
results_
[
i
]
;
}
const
ValTypeVector
&
results
(
)
const
{
return
results_
;
}
HashNumber
hash
(
)
const
{
HashNumber
hn
=
0
;
for
(
const
ValType
&
vt
:
args_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
vt
.
packed
(
)
)
)
;
}
for
(
const
ValType
&
vt
:
results_
)
{
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
vt
.
packed
(
)
)
)
;
}
return
hn
;
}
bool
operator
=
=
(
const
FuncType
&
rhs
)
const
{
return
EqualContainers
(
args
(
)
rhs
.
args
(
)
)
&
&
EqualContainers
(
results
(
)
rhs
.
results
(
)
)
;
}
bool
operator
!
=
(
const
FuncType
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
temporarilyUnsupportedResultCountForJitEntry
(
)
const
{
return
results
(
)
.
length
(
)
>
MaxResultsForJitEntry
;
}
bool
temporarilyUnsupportedResultCountForJitExit
(
)
const
{
return
results
(
)
.
length
(
)
>
MaxResultsForJitExit
;
}
#
ifdef
ENABLE_WASM_SIMD
bool
hasV128ArgOrRet
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
=
=
ValType
:
:
V128
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
result
=
=
ValType
:
:
V128
)
{
return
true
;
}
}
return
false
;
}
#
endif
bool
temporarilyUnsupportedReftypeForEntry
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
isReference
(
)
&
&
!
arg
.
isAnyRef
(
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isTypeIndex
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
temporarilyUnsupportedReftypeForInlineEntry
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
isReference
(
)
&
&
!
arg
.
isAnyRef
(
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isTypeIndex
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
temporarilyUnsupportedReftypeForExit
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
isTypeIndex
(
)
)
{
return
true
;
}
}
for
(
ValType
result
:
results
(
)
)
{
if
(
result
.
isReference
(
)
&
&
!
result
.
isAnyRef
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
jitExitRequiresArgCheck
(
)
const
{
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
isEncodedAsJSValueOnEscape
(
)
)
{
return
true
;
}
}
return
false
;
}
#
ifdef
WASM_PRIVATE_REFTYPES
bool
exposesTypeIndex
(
)
const
{
for
(
const
ValType
&
arg
:
args
(
)
)
{
if
(
arg
.
isTypeIndex
(
)
)
{
return
true
;
}
}
for
(
const
ValType
&
result
:
results
(
)
)
{
if
(
result
.
isTypeIndex
(
)
)
{
return
true
;
}
}
return
false
;
}
#
endif
WASM_DECLARE_SERIALIZABLE
(
FuncType
)
}
;
struct
FuncTypeHashPolicy
{
using
Lookup
=
const
FuncType
&
;
static
HashNumber
hash
(
Lookup
ft
)
{
return
ft
.
hash
(
)
;
}
static
bool
match
(
const
FuncType
*
lhs
Lookup
rhs
)
{
return
*
lhs
=
=
rhs
;
}
}
;
enum
class
StackResults
{
HasStackResults
NoStackResults
}
;
class
ArgTypeVector
{
const
ValTypeVector
&
args_
;
bool
hasStackResults_
;
size_t
length
(
)
const
{
return
args_
.
length
(
)
+
size_t
(
hasStackResults_
)
;
}
friend
jit
:
:
ABIArgIter
<
ArgTypeVector
>
;
friend
jit
:
:
ABIArgIter
<
const
ArgTypeVector
>
;
public
:
ArgTypeVector
(
const
ValTypeVector
&
args
StackResults
stackResults
)
:
args_
(
args
)
hasStackResults_
(
stackResults
=
=
StackResults
:
:
HasStackResults
)
{
}
explicit
ArgTypeVector
(
const
FuncType
&
funcType
)
;
bool
hasSyntheticStackResultPointerArg
(
)
const
{
return
hasStackResults_
;
}
StackResults
stackResults
(
)
const
{
return
hasSyntheticStackResultPointerArg
(
)
?
StackResults
:
:
HasStackResults
:
StackResults
:
:
NoStackResults
;
}
size_t
lengthWithoutStackResults
(
)
const
{
return
args_
.
length
(
)
;
}
bool
isSyntheticStackResultPointerArg
(
size_t
idx
)
const
{
MOZ_ASSERT
(
idx
<
lengthWithStackResults
(
)
)
;
return
idx
=
=
args_
.
length
(
)
;
}
bool
isNaturalArg
(
size_t
idx
)
const
{
return
!
isSyntheticStackResultPointerArg
(
idx
)
;
}
size_t
naturalIndex
(
size_t
idx
)
const
{
MOZ_ASSERT
(
isNaturalArg
(
idx
)
)
;
return
idx
;
}
size_t
lengthWithStackResults
(
)
const
{
return
length
(
)
;
}
jit
:
:
MIRType
operator
[
]
(
size_t
i
)
const
{
MOZ_ASSERT
(
i
<
lengthWithStackResults
(
)
)
;
if
(
isSyntheticStackResultPointerArg
(
i
)
)
{
return
jit
:
:
MIRType
:
:
StackResults
;
}
return
ToMIRType
(
args_
[
naturalIndex
(
i
)
]
)
;
}
}
;
template
<
typename
PointerType
>
class
TaggedValue
{
public
:
enum
Kind
{
ImmediateKind1
=
0
ImmediateKind2
=
1
PointerKind1
=
2
PointerKind2
=
3
}
;
private
:
uintptr_t
bits_
;
static
constexpr
uintptr_t
PayloadShift
=
2
;
static
constexpr
uintptr_t
KindMask
=
0x3
;
static
constexpr
uintptr_t
PointerKindBit
=
0x2
;
constexpr
static
bool
IsPointerKind
(
Kind
kind
)
{
return
uintptr_t
(
kind
)
&
PointerKindBit
;
}
constexpr
static
bool
IsImmediateKind
(
Kind
kind
)
{
return
!
IsPointerKind
(
kind
)
;
}
static_assert
(
IsImmediateKind
(
ImmediateKind1
)
"
immediate
kind
1
"
)
;
static_assert
(
IsImmediateKind
(
ImmediateKind2
)
"
immediate
kind
2
"
)
;
static_assert
(
IsPointerKind
(
PointerKind1
)
"
pointer
kind
1
"
)
;
static_assert
(
IsPointerKind
(
PointerKind2
)
"
pointer
kind
2
"
)
;
static
uintptr_t
PackImmediate
(
Kind
kind
uint32_t
imm
)
{
MOZ_ASSERT
(
IsImmediateKind
(
kind
)
)
;
MOZ_ASSERT
(
(
uintptr_t
(
kind
)
&
KindMask
)
=
=
kind
)
;
MOZ_ASSERT
(
(
imm
&
(
uint32_t
(
KindMask
)
<
<
(
32
-
PayloadShift
)
)
)
=
=
0
)
;
return
uintptr_t
(
kind
)
|
(
uintptr_t
(
imm
)
<
<
PayloadShift
)
;
}
static
uintptr_t
PackPointer
(
Kind
kind
PointerType
*
ptr
)
{
uintptr_t
ptrBits
=
reinterpret_cast
<
uintptr_t
>
(
ptr
)
;
MOZ_ASSERT
(
IsPointerKind
(
kind
)
)
;
MOZ_ASSERT
(
(
uintptr_t
(
kind
)
&
KindMask
)
=
=
kind
)
;
MOZ_ASSERT
(
(
ptrBits
&
KindMask
)
=
=
0
)
;
return
uintptr_t
(
kind
)
|
ptrBits
;
}
public
:
TaggedValue
(
Kind
kind
uint32_t
imm
)
:
bits_
(
PackImmediate
(
kind
imm
)
)
{
}
TaggedValue
(
Kind
kind
PointerType
*
ptr
)
:
bits_
(
PackPointer
(
kind
ptr
)
)
{
}
uintptr_t
bits
(
)
const
{
return
bits_
;
}
Kind
kind
(
)
const
{
return
Kind
(
bits
(
)
&
KindMask
)
;
}
uint32_t
immediate
(
)
const
{
MOZ_ASSERT
(
IsImmediateKind
(
kind
(
)
)
)
;
return
mozilla
:
:
AssertedCast
<
uint32_t
>
(
bits
(
)
>
>
PayloadShift
)
;
}
PointerType
*
pointer
(
)
const
{
MOZ_ASSERT
(
IsPointerKind
(
kind
(
)
)
)
;
return
reinterpret_cast
<
PointerType
*
>
(
bits
(
)
&
~
KindMask
)
;
}
}
;
class
ResultType
{
using
Tagged
=
TaggedValue
<
const
ValTypeVector
>
;
Tagged
tagged_
;
enum
Kind
{
EmptyKind
=
Tagged
:
:
ImmediateKind1
SingleKind
=
Tagged
:
:
ImmediateKind2
#
ifdef
ENABLE_WASM_MULTI_VALUE
VectorKind
=
Tagged
:
:
PointerKind1
#
endif
InvalidKind
=
Tagged
:
:
PointerKind2
}
;
ResultType
(
Kind
kind
uint32_t
imm
)
:
tagged_
(
Tagged
:
:
Kind
(
kind
)
imm
)
{
}
#
ifdef
ENABLE_WASM_MULTI_VALUE
explicit
ResultType
(
const
ValTypeVector
*
ptr
)
:
tagged_
(
Tagged
:
:
Kind
(
VectorKind
)
ptr
)
{
}
#
endif
Kind
kind
(
)
const
{
return
Kind
(
tagged_
.
kind
(
)
)
;
}
ValType
singleValType
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
SingleKind
)
;
return
ValType
(
PackedTypeCodeFromBits
(
tagged_
.
immediate
(
)
)
)
;
}
#
ifdef
ENABLE_WASM_MULTI_VALUE
const
ValTypeVector
&
values
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
VectorKind
)
;
return
*
tagged_
.
pointer
(
)
;
}
#
endif
public
:
ResultType
(
)
:
tagged_
(
Tagged
:
:
Kind
(
InvalidKind
)
nullptr
)
{
}
static
ResultType
Empty
(
)
{
return
ResultType
(
EmptyKind
uint32_t
(
0
)
)
;
}
static
ResultType
Single
(
ValType
vt
)
{
return
ResultType
(
SingleKind
vt
.
bitsUnsafe
(
)
)
;
}
static
ResultType
Vector
(
const
ValTypeVector
&
vals
)
{
switch
(
vals
.
length
(
)
)
{
case
0
:
return
Empty
(
)
;
case
1
:
return
Single
(
vals
[
0
]
)
;
default
:
#
ifdef
ENABLE_WASM_MULTI_VALUE
return
ResultType
(
&
vals
)
;
#
else
MOZ_CRASH
(
"
multi
-
value
returns
not
supported
"
)
;
#
endif
}
}
bool
empty
(
)
const
{
return
kind
(
)
=
=
EmptyKind
;
}
size_t
length
(
)
const
{
switch
(
kind
(
)
)
{
case
EmptyKind
:
return
0
;
case
SingleKind
:
return
1
;
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
VectorKind
:
return
values
(
)
.
length
(
)
;
#
endif
default
:
MOZ_CRASH
(
"
bad
resulttype
"
)
;
}
}
ValType
operator
[
]
(
size_t
i
)
const
{
switch
(
kind
(
)
)
{
case
SingleKind
:
MOZ_ASSERT
(
i
=
=
0
)
;
return
singleValType
(
)
;
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
VectorKind
:
return
values
(
)
[
i
]
;
#
endif
default
:
MOZ_CRASH
(
"
bad
resulttype
"
)
;
}
}
bool
operator
=
=
(
ResultType
rhs
)
const
{
switch
(
kind
(
)
)
{
case
EmptyKind
:
case
SingleKind
:
case
InvalidKind
:
return
tagged_
.
bits
(
)
=
=
rhs
.
tagged_
.
bits
(
)
;
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
VectorKind
:
{
if
(
rhs
.
kind
(
)
!
=
VectorKind
)
{
return
false
;
}
return
EqualContainers
(
values
(
)
rhs
.
values
(
)
)
;
}
#
endif
default
:
MOZ_CRASH
(
"
bad
resulttype
"
)
;
}
}
bool
operator
!
=
(
ResultType
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
}
;
class
BlockType
{
using
Tagged
=
TaggedValue
<
const
FuncType
>
;
Tagged
tagged_
;
enum
Kind
{
VoidToVoidKind
=
Tagged
:
:
ImmediateKind1
VoidToSingleKind
=
Tagged
:
:
ImmediateKind2
#
ifdef
ENABLE_WASM_MULTI_VALUE
FuncKind
=
Tagged
:
:
PointerKind1
FuncResultsKind
=
Tagged
:
:
PointerKind2
#
endif
}
;
BlockType
(
Kind
kind
uint32_t
imm
)
:
tagged_
(
Tagged
:
:
Kind
(
kind
)
imm
)
{
}
#
ifdef
ENABLE_WASM_MULTI_VALUE
BlockType
(
Kind
kind
const
FuncType
&
type
)
:
tagged_
(
Tagged
:
:
Kind
(
kind
)
&
type
)
{
}
#
endif
Kind
kind
(
)
const
{
return
Kind
(
tagged_
.
kind
(
)
)
;
}
ValType
singleValType
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
VoidToSingleKind
)
;
return
ValType
(
PackedTypeCodeFromBits
(
tagged_
.
immediate
(
)
)
)
;
}
#
ifdef
ENABLE_WASM_MULTI_VALUE
const
FuncType
&
funcType
(
)
const
{
return
*
tagged_
.
pointer
(
)
;
}
#
endif
public
:
BlockType
(
)
:
tagged_
(
Tagged
:
:
Kind
(
VoidToVoidKind
)
uint32_t
(
InvalidPackedTypeCode
(
)
)
)
{
}
static
BlockType
VoidToVoid
(
)
{
return
BlockType
(
VoidToVoidKind
uint32_t
(
0
)
)
;
}
static
BlockType
VoidToSingle
(
ValType
vt
)
{
return
BlockType
(
VoidToSingleKind
vt
.
bitsUnsafe
(
)
)
;
}
static
BlockType
Func
(
const
FuncType
&
type
)
{
#
ifdef
ENABLE_WASM_MULTI_VALUE
if
(
type
.
args
(
)
.
length
(
)
=
=
0
)
{
return
FuncResults
(
type
)
;
}
return
BlockType
(
FuncKind
type
)
;
#
else
MOZ_ASSERT
(
type
.
args
(
)
.
length
(
)
=
=
0
)
;
return
FuncResults
(
type
)
;
#
endif
}
static
BlockType
FuncResults
(
const
FuncType
&
type
)
{
switch
(
type
.
results
(
)
.
length
(
)
)
{
case
0
:
return
VoidToVoid
(
)
;
case
1
:
return
VoidToSingle
(
type
.
results
(
)
[
0
]
)
;
default
:
#
ifdef
ENABLE_WASM_MULTI_VALUE
return
BlockType
(
FuncResultsKind
type
)
;
#
else
MOZ_CRASH
(
"
multi
-
value
returns
not
supported
"
)
;
#
endif
}
}
ResultType
params
(
)
const
{
switch
(
kind
(
)
)
{
case
VoidToVoidKind
:
case
VoidToSingleKind
:
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
FuncResultsKind
:
#
endif
return
ResultType
:
:
Empty
(
)
;
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
FuncKind
:
return
ResultType
:
:
Vector
(
funcType
(
)
.
args
(
)
)
;
#
endif
default
:
MOZ_CRASH
(
"
unexpected
kind
"
)
;
}
}
ResultType
results
(
)
const
{
switch
(
kind
(
)
)
{
case
VoidToVoidKind
:
return
ResultType
:
:
Empty
(
)
;
case
VoidToSingleKind
:
return
ResultType
:
:
Single
(
singleValType
(
)
)
;
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
FuncKind
:
case
FuncResultsKind
:
return
ResultType
:
:
Vector
(
funcType
(
)
.
results
(
)
)
;
#
endif
default
:
MOZ_CRASH
(
"
unexpected
kind
"
)
;
}
}
bool
operator
=
=
(
BlockType
rhs
)
const
{
if
(
kind
(
)
!
=
rhs
.
kind
(
)
)
{
return
false
;
}
switch
(
kind
(
)
)
{
case
VoidToVoidKind
:
case
VoidToSingleKind
:
return
tagged_
.
bits
(
)
=
=
rhs
.
tagged_
.
bits
(
)
;
#
ifdef
ENABLE_WASM_MULTI_VALUE
case
FuncKind
:
return
funcType
(
)
=
=
rhs
.
funcType
(
)
;
case
FuncResultsKind
:
return
EqualContainers
(
funcType
(
)
.
results
(
)
rhs
.
funcType
(
)
.
results
(
)
)
;
#
endif
default
:
MOZ_CRASH
(
"
unexpected
kind
"
)
;
}
}
bool
operator
!
=
(
BlockType
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
}
;
struct
StructField
{
ValType
type
;
uint32_t
offset
;
bool
isMutable
;
}
;
typedef
Vector
<
StructField
0
SystemAllocPolicy
>
StructFieldVector
;
class
StructType
{
public
:
StructFieldVector
fields_
;
uint32_t
moduleIndex_
;
bool
isInline_
;
public
:
StructType
(
)
:
fields_
(
)
moduleIndex_
(
0
)
isInline_
(
true
)
{
}
StructType
(
StructFieldVector
&
&
fields
uint32_t
index
bool
isInline
)
:
fields_
(
std
:
:
move
(
fields
)
)
moduleIndex_
(
index
)
isInline_
(
isInline
)
{
}
bool
copyFrom
(
const
StructType
&
src
)
{
if
(
!
fields_
.
appendAll
(
src
.
fields_
)
)
{
return
false
;
}
moduleIndex_
=
src
.
moduleIndex_
;
isInline_
=
src
.
isInline_
;
return
true
;
}
bool
hasPrefix
(
const
StructType
&
other
)
const
;
WASM_DECLARE_SERIALIZABLE
(
StructType
)
}
;
typedef
Vector
<
StructType
0
SystemAllocPolicy
>
StructTypeVector
;
class
InitExpr
{
public
:
enum
class
Kind
{
Constant
GetGlobal
RefFunc
}
;
private
:
Kind
kind_
;
union
U
{
LitVal
val_
;
struct
{
uint32_t
index_
;
ValType
type_
;
}
global
;
uint32_t
refFuncIndex_
;
U
(
)
:
global
{
}
{
}
}
u
;
public
:
InitExpr
(
)
=
default
;
static
InitExpr
fromConstant
(
LitVal
val
)
{
InitExpr
expr
;
expr
.
kind_
=
Kind
:
:
Constant
;
expr
.
u
.
val_
=
val
;
return
expr
;
}
static
InitExpr
fromGetGlobal
(
uint32_t
globalIndex
ValType
type
)
{
InitExpr
expr
;
expr
.
kind_
=
Kind
:
:
GetGlobal
;
expr
.
u
.
global
.
index_
=
globalIndex
;
expr
.
u
.
global
.
type_
=
type
;
return
expr
;
}
static
InitExpr
fromRefFunc
(
uint32_t
refFuncIndex
)
{
InitExpr
expr
;
expr
.
kind_
=
Kind
:
:
RefFunc
;
expr
.
u
.
refFuncIndex_
=
refFuncIndex
;
return
expr
;
}
Kind
kind
(
)
const
{
return
kind_
;
}
bool
isVal
(
)
const
{
return
kind
(
)
=
=
Kind
:
:
Constant
;
}
LitVal
val
(
)
const
{
MOZ_ASSERT
(
isVal
(
)
)
;
return
u
.
val_
;
}
uint32_t
globalIndex
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
Kind
:
:
GetGlobal
)
;
return
u
.
global
.
index_
;
}
uint32_t
refFuncIndex
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
Kind
:
:
RefFunc
)
;
return
u
.
refFuncIndex_
;
}
ValType
type
(
)
const
{
switch
(
kind
(
)
)
{
case
Kind
:
:
Constant
:
return
u
.
val_
.
type
(
)
;
case
Kind
:
:
GetGlobal
:
return
u
.
global
.
type_
;
case
Kind
:
:
RefFunc
:
return
ValType
(
RefType
:
:
func
(
)
)
;
}
MOZ_CRASH
(
"
unexpected
initExpr
type
"
)
;
}
}
;
struct
CacheableChars
:
UniqueChars
{
CacheableChars
(
)
=
default
;
explicit
CacheableChars
(
char
*
ptr
)
:
UniqueChars
(
ptr
)
{
}
MOZ_IMPLICIT
CacheableChars
(
UniqueChars
&
&
rhs
)
:
UniqueChars
(
std
:
:
move
(
rhs
)
)
{
}
WASM_DECLARE_SERIALIZABLE
(
CacheableChars
)
}
;
typedef
Vector
<
CacheableChars
0
SystemAllocPolicy
>
CacheableCharsVector
;
struct
Import
{
CacheableChars
module
;
CacheableChars
field
;
DefinitionKind
kind
;
Import
(
)
=
default
;
Import
(
UniqueChars
&
&
module
UniqueChars
&
&
field
DefinitionKind
kind
)
:
module
(
std
:
:
move
(
module
)
)
field
(
std
:
:
move
(
field
)
)
kind
(
kind
)
{
}
WASM_DECLARE_SERIALIZABLE
(
Import
)
}
;
typedef
Vector
<
Import
0
SystemAllocPolicy
>
ImportVector
;
class
Export
{
CacheableChars
fieldName_
;
struct
CacheablePod
{
DefinitionKind
kind_
;
uint32_t
index_
;
}
pod
;
public
:
Export
(
)
=
default
;
explicit
Export
(
UniqueChars
fieldName
uint32_t
index
DefinitionKind
kind
)
;
explicit
Export
(
UniqueChars
fieldName
DefinitionKind
kind
)
;
const
char
*
fieldName
(
)
const
{
return
fieldName_
.
get
(
)
;
}
DefinitionKind
kind
(
)
const
{
return
pod
.
kind_
;
}
uint32_t
funcIndex
(
)
const
;
uint32_t
globalIndex
(
)
const
;
uint32_t
tableIndex
(
)
const
;
WASM_DECLARE_SERIALIZABLE
(
Export
)
}
;
typedef
Vector
<
Export
0
SystemAllocPolicy
>
ExportVector
;
enum
class
GlobalKind
{
Import
Constant
Variable
}
;
class
GlobalDesc
{
union
V
{
struct
{
union
U
{
InitExpr
initial_
;
struct
{
ValType
type_
;
uint32_t
index_
;
}
import
;
U
(
)
:
import
{
}
{
}
}
val
;
unsigned
offset_
;
bool
isMutable_
;
bool
isWasm_
;
bool
isExport_
;
}
var
;
LitVal
cst_
;
V
(
)
{
}
}
u
;
GlobalKind
kind_
;
bool
isExport
(
)
const
{
return
!
isConstant
(
)
&
&
u
.
var
.
isExport_
;
}
bool
isWasm
(
)
const
{
return
!
isConstant
(
)
&
&
u
.
var
.
isWasm_
;
}
public
:
GlobalDesc
(
)
=
default
;
explicit
GlobalDesc
(
InitExpr
initial
bool
isMutable
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind_
(
(
isMutable
|
|
!
initial
.
isVal
(
)
)
?
GlobalKind
:
:
Variable
:
GlobalKind
:
:
Constant
)
{
if
(
isVariable
(
)
)
{
u
.
var
.
val
.
initial_
=
initial
;
u
.
var
.
isMutable_
=
isMutable
;
u
.
var
.
isWasm_
=
kind
=
=
Wasm
;
u
.
var
.
isExport_
=
false
;
u
.
var
.
offset_
=
UINT32_MAX
;
}
else
{
u
.
cst_
=
initial
.
val
(
)
;
}
}
explicit
GlobalDesc
(
ValType
type
bool
isMutable
uint32_t
importIndex
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind_
(
GlobalKind
:
:
Import
)
{
u
.
var
.
val
.
import
.
type_
=
type
;
u
.
var
.
val
.
import
.
index_
=
importIndex
;
u
.
var
.
isMutable_
=
isMutable
;
u
.
var
.
isWasm_
=
kind
=
=
Wasm
;
u
.
var
.
isExport_
=
false
;
u
.
var
.
offset_
=
UINT32_MAX
;
}
void
setOffset
(
unsigned
offset
)
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
u
.
var
.
offset_
=
=
UINT32_MAX
)
;
u
.
var
.
offset_
=
offset
;
}
unsigned
offset
(
)
const
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
u
.
var
.
offset_
!
=
UINT32_MAX
)
;
return
u
.
var
.
offset_
;
}
void
setIsExport
(
)
{
if
(
!
isConstant
(
)
)
{
u
.
var
.
isExport_
=
true
;
}
}
GlobalKind
kind
(
)
const
{
return
kind_
;
}
bool
isVariable
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Variable
;
}
bool
isConstant
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Constant
;
}
bool
isImport
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Import
;
}
bool
isMutable
(
)
const
{
return
!
isConstant
(
)
&
&
u
.
var
.
isMutable_
;
}
LitVal
constantValue
(
)
const
{
MOZ_ASSERT
(
isConstant
(
)
)
;
return
u
.
cst_
;
}
const
InitExpr
&
initExpr
(
)
const
{
MOZ_ASSERT
(
isVariable
(
)
)
;
return
u
.
var
.
val
.
initial_
;
}
uint32_t
importIndex
(
)
const
{
MOZ_ASSERT
(
isImport
(
)
)
;
return
u
.
var
.
val
.
import
.
index_
;
}
bool
isIndirect
(
)
const
{
return
isMutable
(
)
&
&
isWasm
(
)
&
&
(
isImport
(
)
|
|
isExport
(
)
)
;
}
ValType
type
(
)
const
{
switch
(
kind_
)
{
case
GlobalKind
:
:
Import
:
return
u
.
var
.
val
.
import
.
type_
;
case
GlobalKind
:
:
Variable
:
return
u
.
var
.
val
.
initial_
.
type
(
)
;
case
GlobalKind
:
:
Constant
:
return
u
.
cst_
.
type
(
)
;
}
MOZ_CRASH
(
"
unexpected
global
kind
"
)
;
}
}
;
typedef
Vector
<
GlobalDesc
0
SystemAllocPolicy
>
GlobalDescVector
;
struct
ElemSegment
:
AtomicRefCounted
<
ElemSegment
>
{
enum
class
Kind
{
Active
Passive
Declared
}
;
Kind
kind
;
uint32_t
tableIndex
;
ValType
elementType
;
Maybe
<
InitExpr
>
offsetIfActive
;
Uint32Vector
elemFuncIndices
;
bool
active
(
)
const
{
return
kind
=
=
Kind
:
:
Active
;
}
InitExpr
offset
(
)
const
{
return
*
offsetIfActive
;
}
size_t
length
(
)
const
{
return
elemFuncIndices
.
length
(
)
;
}
ValType
elemType
(
)
const
{
return
elementType
;
}
WASM_DECLARE_SERIALIZABLE
(
ElemSegment
)
}
;
constexpr
uint32_t
NullFuncIndex
=
UINT32_MAX
;
static_assert
(
NullFuncIndex
>
MaxFuncs
"
Invariant
"
)
;
using
MutableElemSegment
=
RefPtr
<
ElemSegment
>
;
using
SharedElemSegment
=
SerializableRefPtr
<
const
ElemSegment
>
;
typedef
Vector
<
SharedElemSegment
0
SystemAllocPolicy
>
ElemSegmentVector
;
struct
DataSegmentEnv
{
Maybe
<
InitExpr
>
offsetIfActive
;
uint32_t
bytecodeOffset
;
uint32_t
length
;
}
;
typedef
Vector
<
DataSegmentEnv
0
SystemAllocPolicy
>
DataSegmentEnvVector
;
struct
DataSegment
:
AtomicRefCounted
<
DataSegment
>
{
Maybe
<
InitExpr
>
offsetIfActive
;
Bytes
bytes
;
DataSegment
(
)
=
default
;
explicit
DataSegment
(
const
DataSegmentEnv
&
src
)
:
offsetIfActive
(
src
.
offsetIfActive
)
{
}
bool
active
(
)
const
{
return
!
!
offsetIfActive
;
}
InitExpr
offset
(
)
const
{
return
*
offsetIfActive
;
}
WASM_DECLARE_SERIALIZABLE
(
DataSegment
)
}
;
using
MutableDataSegment
=
RefPtr
<
DataSegment
>
;
using
SharedDataSegment
=
SerializableRefPtr
<
const
DataSegment
>
;
typedef
Vector
<
SharedDataSegment
0
SystemAllocPolicy
>
DataSegmentVector
;
struct
CustomSectionEnv
{
uint32_t
nameOffset
;
uint32_t
nameLength
;
uint32_t
payloadOffset
;
uint32_t
payloadLength
;
}
;
typedef
Vector
<
CustomSectionEnv
0
SystemAllocPolicy
>
CustomSectionEnvVector
;
struct
CustomSection
{
Bytes
name
;
SharedBytes
payload
;
WASM_DECLARE_SERIALIZABLE
(
CustomSection
)
}
;
typedef
Vector
<
CustomSection
0
SystemAllocPolicy
>
CustomSectionVector
;
struct
Name
{
uint32_t
offsetInNamePayload
;
uint32_t
length
;
Name
(
)
:
offsetInNamePayload
(
UINT32_MAX
)
length
(
0
)
{
}
}
;
typedef
Vector
<
Name
0
SystemAllocPolicy
>
NameVector
;
class
FuncTypeIdDesc
{
public
:
static
const
uintptr_t
ImmediateBit
=
0x1
;
private
:
FuncTypeIdDescKind
kind_
;
size_t
bits_
;
FuncTypeIdDesc
(
FuncTypeIdDescKind
kind
size_t
bits
)
:
kind_
(
kind
)
bits_
(
bits
)
{
}
public
:
FuncTypeIdDescKind
kind
(
)
const
{
return
kind_
;
}
static
bool
isGlobal
(
const
FuncType
&
funcType
)
;
FuncTypeIdDesc
(
)
:
kind_
(
FuncTypeIdDescKind
:
:
None
)
bits_
(
0
)
{
}
static
FuncTypeIdDesc
global
(
const
FuncType
&
funcType
uint32_t
globalDataOffset
)
;
static
FuncTypeIdDesc
immediate
(
const
FuncType
&
funcType
)
;
bool
isGlobal
(
)
const
{
return
kind_
=
=
FuncTypeIdDescKind
:
:
Global
;
}
size_t
immediate
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
FuncTypeIdDescKind
:
:
Immediate
)
;
return
bits_
;
}
uint32_t
globalDataOffset
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
FuncTypeIdDescKind
:
:
Global
)
;
return
bits_
;
}
}
;
struct
FuncTypeWithId
:
FuncType
{
FuncTypeIdDesc
id
;
FuncTypeWithId
(
)
=
default
;
explicit
FuncTypeWithId
(
FuncType
&
&
funcType
)
:
FuncType
(
std
:
:
move
(
funcType
)
)
id
(
)
{
}
FuncTypeWithId
(
FuncType
&
&
funcType
FuncTypeIdDesc
id
)
:
FuncType
(
std
:
:
move
(
funcType
)
)
id
(
id
)
{
}
void
operator
=
(
FuncType
&
&
rhs
)
{
FuncType
:
:
operator
=
(
std
:
:
move
(
rhs
)
)
;
}
WASM_DECLARE_SERIALIZABLE
(
FuncTypeWithId
)
}
;
typedef
Vector
<
FuncTypeWithId
0
SystemAllocPolicy
>
FuncTypeWithIdVector
;
typedef
Vector
<
const
FuncTypeWithId
*
0
SystemAllocPolicy
>
FuncTypeWithIdPtrVector
;
class
TypeDef
{
enum
{
IsFuncType
IsStructType
IsNone
}
tag_
;
union
{
FuncTypeWithId
funcType_
;
StructType
structType_
;
}
;
public
:
TypeDef
(
)
:
tag_
(
IsNone
)
{
}
explicit
TypeDef
(
FuncType
&
&
funcType
)
:
tag_
(
IsFuncType
)
funcType_
(
FuncTypeWithId
(
std
:
:
move
(
funcType
)
)
)
{
}
explicit
TypeDef
(
StructType
&
&
structType
)
:
tag_
(
IsStructType
)
structType_
(
std
:
:
move
(
structType
)
)
{
}
TypeDef
(
TypeDef
&
&
td
)
:
tag_
(
td
.
tag_
)
{
switch
(
tag_
)
{
case
IsFuncType
:
new
(
&
funcType_
)
FuncTypeWithId
(
std
:
:
move
(
td
.
funcType_
)
)
;
break
;
case
IsStructType
:
new
(
&
structType_
)
StructType
(
std
:
:
move
(
td
.
structType_
)
)
;
break
;
case
IsNone
:
break
;
}
}
~
TypeDef
(
)
{
switch
(
tag_
)
{
case
IsFuncType
:
funcType_
.
~
FuncTypeWithId
(
)
;
break
;
case
IsStructType
:
structType_
.
~
StructType
(
)
;
break
;
case
IsNone
:
break
;
}
}
TypeDef
&
operator
=
(
TypeDef
&
&
that
)
{
MOZ_ASSERT
(
isNone
(
)
)
;
switch
(
that
.
tag_
)
{
case
IsFuncType
:
new
(
&
funcType_
)
FuncTypeWithId
(
std
:
:
move
(
that
.
funcType_
)
)
;
break
;
case
IsStructType
:
new
(
&
structType_
)
StructType
(
std
:
:
move
(
that
.
structType_
)
)
;
break
;
case
IsNone
:
break
;
}
tag_
=
that
.
tag_
;
return
*
this
;
}
bool
isFuncType
(
)
const
{
return
tag_
=
=
IsFuncType
;
}
bool
isNone
(
)
const
{
return
tag_
=
=
IsNone
;
}
bool
isStructType
(
)
const
{
return
tag_
=
=
IsStructType
;
}
const
FuncTypeWithId
&
funcType
(
)
const
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
FuncTypeWithId
&
funcType
(
)
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
static
const
TypeDef
*
fromFuncTypeWithIdPtr
(
const
FuncTypeWithId
*
p
)
{
const
TypeDef
*
q
=
(
const
TypeDef
*
)
(
(
char
*
)
p
-
offsetof
(
TypeDef
funcType_
)
)
;
MOZ_ASSERT
(
q
-
>
tag_
=
=
IsFuncType
)
;
return
q
;
}
const
StructType
&
structType
(
)
const
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
StructType
&
structType
(
)
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
static
const
TypeDef
*
fromStructPtr
(
const
StructType
*
p
)
{
const
TypeDef
*
q
=
(
const
TypeDef
*
)
(
(
char
*
)
p
-
offsetof
(
TypeDef
structType_
)
)
;
MOZ_ASSERT
(
q
-
>
tag_
=
=
IsStructType
)
;
return
q
;
}
}
;
typedef
Vector
<
TypeDef
0
SystemAllocPolicy
>
TypeDefVector
;
class
BytecodeOffset
{
static
const
uint32_t
INVALID
=
-
1
;
uint32_t
offset_
;
public
:
BytecodeOffset
(
)
:
offset_
(
INVALID
)
{
}
explicit
BytecodeOffset
(
uint32_t
offset
)
:
offset_
(
offset
)
{
}
bool
isValid
(
)
const
{
return
offset_
!
=
INVALID
;
}
uint32_t
offset
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
offset_
;
}
}
;
struct
TrapSite
{
uint32_t
pcOffset
;
BytecodeOffset
bytecode
;
TrapSite
(
)
:
pcOffset
(
-
1
)
bytecode
(
)
{
}
TrapSite
(
uint32_t
pcOffset
BytecodeOffset
bytecode
)
:
pcOffset
(
pcOffset
)
bytecode
(
bytecode
)
{
}
void
offsetBy
(
uint32_t
offset
)
{
pcOffset
+
=
offset
;
}
}
;
WASM_DECLARE_POD_VECTOR
(
TrapSite
TrapSiteVector
)
struct
TrapSiteVectorArray
:
EnumeratedArray
<
Trap
Trap
:
:
Limit
TrapSiteVector
>
{
bool
empty
(
)
const
;
void
clear
(
)
;
void
swap
(
TrapSiteVectorArray
&
rhs
)
;
void
shrinkStorageToFit
(
)
;
WASM_DECLARE_SERIALIZABLE
(
TrapSiteVectorArray
)
}
;
struct
TrapData
{
void
*
resumePC
;
void
*
unwoundPC
;
Trap
trap
;
uint32_t
bytecodeOffset
;
}
;
struct
Offsets
{
explicit
Offsets
(
uint32_t
begin
=
0
uint32_t
end
=
0
)
:
begin
(
begin
)
end
(
end
)
{
}
uint32_t
begin
;
uint32_t
end
;
}
;
struct
CallableOffsets
:
Offsets
{
MOZ_IMPLICIT
CallableOffsets
(
uint32_t
ret
=
0
)
:
Offsets
(
)
ret
(
ret
)
{
}
uint32_t
ret
;
}
;
struct
JitExitOffsets
:
CallableOffsets
{
MOZ_IMPLICIT
JitExitOffsets
(
)
:
CallableOffsets
(
)
untrustedFPStart
(
0
)
untrustedFPEnd
(
0
)
{
}
uint32_t
untrustedFPStart
;
uint32_t
untrustedFPEnd
;
}
;
struct
FuncOffsets
:
CallableOffsets
{
MOZ_IMPLICIT
FuncOffsets
(
)
:
CallableOffsets
(
)
uncheckedCallEntry
(
0
)
tierEntry
(
0
)
{
}
uint32_t
uncheckedCallEntry
;
uint32_t
tierEntry
;
}
;
typedef
Vector
<
FuncOffsets
0
SystemAllocPolicy
>
FuncOffsetsVector
;
class
CodeRange
{
public
:
enum
Kind
{
Function
InterpEntry
JitEntry
ImportInterpExit
ImportJitExit
BuiltinThunk
TrapExit
DebugTrap
FarJumpIsland
Throw
}
;
private
:
uint32_t
begin_
;
uint32_t
ret_
;
uint32_t
end_
;
union
{
struct
{
uint32_t
funcIndex_
;
union
{
struct
{
uint32_t
lineOrBytecode_
;
uint8_t
beginToUncheckedCallEntry_
;
uint8_t
beginToTierEntry_
;
}
func
;
struct
{
uint16_t
beginToUntrustedFPStart_
;
uint16_t
beginToUntrustedFPEnd_
;
}
jitExit
;
}
;
}
;
Trap
trap_
;
}
u
;
Kind
kind_
:
8
;
public
:
CodeRange
(
)
=
default
;
CodeRange
(
Kind
kind
Offsets
offsets
)
;
CodeRange
(
Kind
kind
uint32_t
funcIndex
Offsets
offsets
)
;
CodeRange
(
Kind
kind
CallableOffsets
offsets
)
;
CodeRange
(
Kind
kind
uint32_t
funcIndex
CallableOffsets
)
;
CodeRange
(
uint32_t
funcIndex
JitExitOffsets
offsets
)
;
CodeRange
(
uint32_t
funcIndex
uint32_t
lineOrBytecode
FuncOffsets
offsets
)
;
void
offsetBy
(
uint32_t
offset
)
{
begin_
+
=
offset
;
end_
+
=
offset
;
if
(
hasReturn
(
)
)
{
ret_
+
=
offset
;
}
}
uint32_t
begin
(
)
const
{
return
begin_
;
}
uint32_t
end
(
)
const
{
return
end_
;
}
Kind
kind
(
)
const
{
return
kind_
;
}
bool
isFunction
(
)
const
{
return
kind
(
)
=
=
Function
;
}
bool
isImportExit
(
)
const
{
return
kind
(
)
=
=
ImportJitExit
|
|
kind
(
)
=
=
ImportInterpExit
|
|
kind
(
)
=
=
BuiltinThunk
;
}
bool
isImportInterpExit
(
)
const
{
return
kind
(
)
=
=
ImportInterpExit
;
}
bool
isImportJitExit
(
)
const
{
return
kind
(
)
=
=
ImportJitExit
;
}
bool
isTrapExit
(
)
const
{
return
kind
(
)
=
=
TrapExit
;
}
bool
isDebugTrap
(
)
const
{
return
kind
(
)
=
=
DebugTrap
;
}
bool
isThunk
(
)
const
{
return
kind
(
)
=
=
FarJumpIsland
;
}
bool
hasReturn
(
)
const
{
return
isFunction
(
)
|
|
isImportExit
(
)
|
|
isDebugTrap
(
)
;
}
uint32_t
ret
(
)
const
{
MOZ_ASSERT
(
hasReturn
(
)
)
;
return
ret_
;
}
bool
isJitEntry
(
)
const
{
return
kind
(
)
=
=
JitEntry
;
}
bool
isInterpEntry
(
)
const
{
return
kind
(
)
=
=
InterpEntry
;
}
bool
isEntry
(
)
const
{
return
isInterpEntry
(
)
|
|
isJitEntry
(
)
;
}
bool
hasFuncIndex
(
)
const
{
return
isFunction
(
)
|
|
isImportExit
(
)
|
|
isEntry
(
)
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
hasFuncIndex
(
)
)
;
return
u
.
funcIndex_
;
}
Trap
trap
(
)
const
{
MOZ_ASSERT
(
isTrapExit
(
)
)
;
return
u
.
trap_
;
}
uint32_t
funcCheckedCallEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
;
}
uint32_t
funcUncheckedCallEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
u
.
func
.
beginToUncheckedCallEntry_
;
}
uint32_t
funcTierEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
u
.
func
.
beginToTierEntry_
;
}
uint32_t
funcLineOrBytecode
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
u
.
func
.
lineOrBytecode_
;
}
uint32_t
jitExitUntrustedFPStart
(
)
const
{
MOZ_ASSERT
(
isImportJitExit
(
)
)
;
return
begin_
+
u
.
jitExit
.
beginToUntrustedFPStart_
;
}
uint32_t
jitExitUntrustedFPEnd
(
)
const
{
MOZ_ASSERT
(
isImportJitExit
(
)
)
;
return
begin_
+
u
.
jitExit
.
beginToUntrustedFPEnd_
;
}
struct
OffsetInCode
{
size_t
offset
;
explicit
OffsetInCode
(
size_t
offset
)
:
offset
(
offset
)
{
}
bool
operator
=
=
(
const
CodeRange
&
rhs
)
const
{
return
offset
>
=
rhs
.
begin
(
)
&
&
offset
<
rhs
.
end
(
)
;
}
bool
operator
<
(
const
CodeRange
&
rhs
)
const
{
return
offset
<
rhs
.
begin
(
)
;
}
}
;
}
;
WASM_DECLARE_POD_VECTOR
(
CodeRange
CodeRangeVector
)
extern
const
CodeRange
*
LookupInSorted
(
const
CodeRangeVector
&
codeRanges
CodeRange
:
:
OffsetInCode
target
)
;
class
CallSiteDesc
{
static
constexpr
size_t
LINE_OR_BYTECODE_BITS_SIZE
=
29
;
uint32_t
lineOrBytecode_
:
LINE_OR_BYTECODE_BITS_SIZE
;
uint32_t
kind_
:
3
;
public
:
static
constexpr
uint32_t
MAX_LINE_OR_BYTECODE_VALUE
=
(
1
<
<
LINE_OR_BYTECODE_BITS_SIZE
)
-
1
;
enum
Kind
{
Func
Dynamic
Symbolic
EnterFrame
LeaveFrame
Breakpoint
}
;
CallSiteDesc
(
)
:
lineOrBytecode_
(
0
)
kind_
(
0
)
{
}
explicit
CallSiteDesc
(
Kind
kind
)
:
lineOrBytecode_
(
0
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
=
=
Kind
(
kind_
)
)
;
}
CallSiteDesc
(
uint32_t
lineOrBytecode
Kind
kind
)
:
lineOrBytecode_
(
lineOrBytecode
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
=
=
Kind
(
kind_
)
)
;
MOZ_ASSERT
(
lineOrBytecode
=
=
lineOrBytecode_
)
;
}
uint32_t
lineOrBytecode
(
)
const
{
return
lineOrBytecode_
;
}
Kind
kind
(
)
const
{
return
Kind
(
kind_
)
;
}
}
;
class
CallSite
:
public
CallSiteDesc
{
uint32_t
returnAddressOffset_
;
public
:
CallSite
(
)
:
returnAddressOffset_
(
0
)
{
}
CallSite
(
CallSiteDesc
desc
uint32_t
returnAddressOffset
)
:
CallSiteDesc
(
desc
)
returnAddressOffset_
(
returnAddressOffset
)
{
}
void
offsetBy
(
int32_t
delta
)
{
returnAddressOffset_
+
=
delta
;
}
uint32_t
returnAddressOffset
(
)
const
{
return
returnAddressOffset_
;
}
}
;
WASM_DECLARE_POD_VECTOR
(
CallSite
CallSiteVector
)
class
CallSiteTarget
{
uint32_t
packed_
;
#
ifdef
DEBUG
enum
Kind
{
None
FuncIndex
TrapExit
}
kind_
;
#
endif
public
:
explicit
CallSiteTarget
(
)
:
packed_
(
UINT32_MAX
)
#
ifdef
DEBUG
kind_
(
None
)
#
endif
{
}
explicit
CallSiteTarget
(
uint32_t
funcIndex
)
:
packed_
(
funcIndex
)
#
ifdef
DEBUG
kind_
(
FuncIndex
)
#
endif
{
}
explicit
CallSiteTarget
(
Trap
trap
)
:
packed_
(
uint32_t
(
trap
)
)
#
ifdef
DEBUG
kind_
(
TrapExit
)
#
endif
{
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
FuncIndex
)
;
return
packed_
;
}
Trap
trap
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
TrapExit
)
;
MOZ_ASSERT
(
packed_
<
uint32_t
(
Trap
:
:
Limit
)
)
;
return
Trap
(
packed_
)
;
}
}
;
typedef
Vector
<
CallSiteTarget
0
SystemAllocPolicy
>
CallSiteTargetVector
;
enum
class
SymbolicAddress
{
ToInt32
#
if
defined
(
JS_CODEGEN_ARM
)
aeabi_idivmod
aeabi_uidivmod
#
endif
ModD
SinD
CosD
TanD
ASinD
ACosD
ATanD
CeilD
CeilF
FloorD
FloorF
TruncD
TruncF
NearbyIntD
NearbyIntF
ExpD
LogD
PowD
ATan2D
HandleDebugTrap
HandleThrow
HandleTrap
ReportV128JSCall
CallImport_Void
CallImport_I32
CallImport_I64
CallImport_V128
CallImport_F64
CallImport_FuncRef
CallImport_AnyRef
CoerceInPlace_ToInt32
CoerceInPlace_ToNumber
CoerceInPlace_JitEntry
CoerceInPlace_ToBigInt
AllocateBigInt
BoxValue_Anyref
DivI64
UDivI64
ModI64
UModI64
TruncateDoubleToInt64
TruncateDoubleToUint64
SaturatingTruncateDoubleToInt64
SaturatingTruncateDoubleToUint64
Uint64ToFloat32
Uint64ToDouble
Int64ToFloat32
Int64ToDouble
MemoryGrow
MemorySize
WaitI32
WaitI64
Wake
MemCopy
MemCopyShared
DataDrop
MemFill
MemFillShared
MemInit
TableCopy
ElemDrop
TableFill
TableGet
TableGrow
TableInit
TableSet
TableSize
RefFunc
PreBarrierFiltering
PostBarrier
PostBarrierFiltering
StructNew
StructNarrow
#
if
defined
(
JS_CODEGEN_MIPS32
)
js_jit_gAtomic64Lock
#
endif
#
ifdef
WASM_CODEGEN_DEBUG
PrintI32
PrintPtr
PrintF32
PrintF64
PrintText
#
endif
Limit
}
;
enum
class
FailureMode
:
uint8_t
{
Infallible
FailOnNegI32
FailOnNullPtr
FailOnInvalidRef
}
;
static
constexpr
size_t
SymbolicAddressSignatureMaxArgs
=
6
;
struct
SymbolicAddressSignature
{
const
SymbolicAddress
identity
;
const
jit
:
:
MIRType
retType
;
const
FailureMode
failureMode
;
const
uint8_t
numArgs
;
const
jit
:
:
MIRType
argTypes
[
SymbolicAddressSignatureMaxArgs
+
1
]
;
}
;
static_assert
(
sizeof
(
SymbolicAddressSignature
)
<
=
16
"
SymbolicAddressSignature
unexpectedly
large
"
)
;
bool
IsRoundingFunction
(
SymbolicAddress
callee
jit
:
:
RoundingMode
*
mode
)
;
struct
Limits
{
uint32_t
initial
;
Maybe
<
uint32_t
>
maximum
;
Shareable
shared
;
Limits
(
)
=
default
;
explicit
Limits
(
uint32_t
initial
const
Maybe
<
uint32_t
>
&
maximum
=
Nothing
(
)
Shareable
shared
=
Shareable
:
:
False
)
:
initial
(
initial
)
maximum
(
maximum
)
shared
(
shared
)
{
}
}
;
enum
class
TableKind
{
AnyRef
FuncRef
AsmJS
}
;
static
inline
ValType
ToElemValType
(
TableKind
tk
)
{
switch
(
tk
)
{
case
TableKind
:
:
AnyRef
:
return
RefType
:
:
any
(
)
;
case
TableKind
:
:
FuncRef
:
return
RefType
:
:
func
(
)
;
case
TableKind
:
:
AsmJS
:
break
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
switch
is
exhaustive
"
)
;
}
struct
TableDesc
{
TableKind
kind
;
bool
importedOrExported
;
uint32_t
globalDataOffset
;
Limits
limits
;
TableDesc
(
)
=
default
;
TableDesc
(
TableKind
kind
const
Limits
&
limits
bool
importedOrExported
=
false
)
:
kind
(
kind
)
importedOrExported
(
importedOrExported
)
globalDataOffset
(
UINT32_MAX
)
limits
(
limits
)
{
}
}
;
typedef
Vector
<
TableDesc
0
SystemAllocPolicy
>
TableDescVector
;
enum
class
TableRepr
{
Ref
Func
}
;
struct
TlsData
{
uint8_t
*
memoryBase
;
uint32_t
boundsCheckLimit
;
Instance
*
instance
;
JS
:
:
Realm
*
realm
;
JSContext
*
cx
;
const
JSClass
*
valueBoxClass
;
Atomic
<
uintptr_t
mozilla
:
:
Relaxed
>
stackLimit
;
Atomic
<
uint32_t
mozilla
:
:
Relaxed
>
interrupt
;
uint8_t
*
addressOfNeedsIncrementalBarrier
;
void
setInterrupt
(
)
;
bool
isInterrupted
(
)
const
;
void
resetInterrupt
(
JSContext
*
cx
)
;
void
*
allocatedBase
;
void
*
*
jumpTable
;
MOZ_ALIGNED_DECL
(
16
char
globalArea
)
;
}
;
static
const
size_t
TlsDataAlign
=
16
;
static_assert
(
offsetof
(
TlsData
globalArea
)
%
TlsDataAlign
=
=
0
"
aligned
"
)
;
struct
TlsDataDeleter
{
void
operator
(
)
(
TlsData
*
tlsData
)
{
js_free
(
tlsData
-
>
allocatedBase
)
;
}
}
;
typedef
UniquePtr
<
TlsData
TlsDataDeleter
>
UniqueTlsData
;
extern
UniqueTlsData
CreateTlsData
(
uint32_t
globalDataLength
)
;
struct
ExportArg
{
uint64_t
lo
;
uint64_t
hi
;
}
;
using
ExportFuncPtr
=
int32_t
(
*
)
(
ExportArg
*
TlsData
*
)
;
struct
FuncImportTls
{
void
*
code
;
TlsData
*
tls
;
JS
:
:
Realm
*
realm
;
jit
:
:
JitScript
*
jitScript
;
GCPtrFunction
fun
;
static_assert
(
sizeof
(
GCPtrFunction
)
=
=
sizeof
(
void
*
)
"
for
JIT
access
"
)
;
}
;
struct
TableTls
{
uint32_t
length
;
void
*
functionBase
;
}
;
struct
FunctionTableElem
{
void
*
code
;
TlsData
*
tls
;
}
;
class
CalleeDesc
{
public
:
enum
Which
{
Func
Import
WasmTable
AsmJSTable
Builtin
BuiltinInstanceMethod
}
;
private
:
MOZ_INIT_OUTSIDE_CTOR
Which
which_
;
union
U
{
U
(
)
:
funcIndex_
(
0
)
{
}
uint32_t
funcIndex_
;
struct
{
uint32_t
globalDataOffset_
;
}
import
;
struct
{
uint32_t
globalDataOffset_
;
uint32_t
minLength_
;
FuncTypeIdDesc
funcTypeId_
;
}
table
;
SymbolicAddress
builtin_
;
}
u
;
public
:
CalleeDesc
(
)
=
default
;
static
CalleeDesc
function
(
uint32_t
funcIndex
)
{
CalleeDesc
c
;
c
.
which_
=
Func
;
c
.
u
.
funcIndex_
=
funcIndex
;
return
c
;
}
static
CalleeDesc
import
(
uint32_t
globalDataOffset
)
{
CalleeDesc
c
;
c
.
which_
=
Import
;
c
.
u
.
import
.
globalDataOffset_
=
globalDataOffset
;
return
c
;
}
static
CalleeDesc
wasmTable
(
const
TableDesc
&
desc
FuncTypeIdDesc
funcTypeId
)
{
CalleeDesc
c
;
c
.
which_
=
WasmTable
;
c
.
u
.
table
.
globalDataOffset_
=
desc
.
globalDataOffset
;
c
.
u
.
table
.
minLength_
=
desc
.
limits
.
initial
;
c
.
u
.
table
.
funcTypeId_
=
funcTypeId
;
return
c
;
}
static
CalleeDesc
asmJSTable
(
const
TableDesc
&
desc
)
{
CalleeDesc
c
;
c
.
which_
=
AsmJSTable
;
c
.
u
.
table
.
globalDataOffset_
=
desc
.
globalDataOffset
;
return
c
;
}
static
CalleeDesc
builtin
(
SymbolicAddress
callee
)
{
CalleeDesc
c
;
c
.
which_
=
Builtin
;
c
.
u
.
builtin_
=
callee
;
return
c
;
}
static
CalleeDesc
builtinInstanceMethod
(
SymbolicAddress
callee
)
{
CalleeDesc
c
;
c
.
which_
=
BuiltinInstanceMethod
;
c
.
u
.
builtin_
=
callee
;
return
c
;
}
Which
which
(
)
const
{
return
which_
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Func
)
;
return
u
.
funcIndex_
;
}
uint32_t
importGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Import
)
;
return
u
.
import
.
globalDataOffset_
;
}
bool
isTable
(
)
const
{
return
which_
=
=
WasmTable
|
|
which_
=
=
AsmJSTable
;
}
uint32_t
tableLengthGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
isTable
(
)
)
;
return
u
.
table
.
globalDataOffset_
+
offsetof
(
TableTls
length
)
;
}
uint32_t
tableFunctionBaseGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
isTable
(
)
)
;
return
u
.
table
.
globalDataOffset_
+
offsetof
(
TableTls
functionBase
)
;
}
FuncTypeIdDesc
wasmTableSigId
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
funcTypeId_
;
}
uint32_t
wasmTableMinLength
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
minLength_
;
}
SymbolicAddress
builtin
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Builtin
|
|
which_
=
=
BuiltinInstanceMethod
)
;
return
u
.
builtin_
;
}
}
;
extern
bool
IsValidARMImmediate
(
uint32_t
i
)
;
extern
uint32_t
RoundUpToNextValidARMImmediate
(
uint32_t
i
)
;
static
const
unsigned
PageSize
=
64
*
1024
;
static
const
unsigned
MaxMemoryAccessSize
=
LitVal
:
:
sizeofLargestValue
(
)
;
#
ifdef
WASM_SUPPORTS_HUGE_MEMORY
static
const
uint64_t
HugeIndexRange
=
uint64_t
(
UINT32_MAX
)
+
1
;
static
const
uint64_t
HugeOffsetGuardLimit
=
uint64_t
(
INT32_MAX
)
+
1
;
static
const
uint64_t
HugeUnalignedGuardPage
=
PageSize
;
static
const
uint64_t
HugeMappedSize
=
HugeIndexRange
+
HugeOffsetGuardLimit
+
HugeUnalignedGuardPage
;
static_assert
(
MaxMemoryAccessSize
<
=
HugeUnalignedGuardPage
"
rounded
up
to
static
page
size
"
)
;
static_assert
(
HugeOffsetGuardLimit
<
UINT32_MAX
"
checking
for
overflow
against
OffsetGuardLimit
is
enough
.
"
)
;
#
endif
static
const
size_t
OffsetGuardLimit
=
PageSize
-
MaxMemoryAccessSize
;
static
const
size_t
GuardSize
=
PageSize
;
static_assert
(
MaxMemoryAccessSize
<
GuardSize
"
Guard
page
handles
partial
out
-
of
-
bounds
"
)
;
static_assert
(
OffsetGuardLimit
<
UINT32_MAX
"
checking
for
overflow
against
OffsetGuardLimit
is
enough
.
"
)
;
static
constexpr
size_t
GetOffsetGuardLimit
(
bool
hugeMemory
)
{
#
ifdef
WASM_SUPPORTS_HUGE_MEMORY
return
hugeMemory
?
HugeOffsetGuardLimit
:
OffsetGuardLimit
;
#
else
return
OffsetGuardLimit
;
#
endif
}
#
ifdef
WASM_SUPPORTS_HUGE_MEMORY
static
const
size_t
MaxOffsetGuardLimit
=
HugeOffsetGuardLimit
;
static
const
size_t
MinOffsetGuardLimit
=
OffsetGuardLimit
;
#
else
static
const
size_t
MaxOffsetGuardLimit
=
OffsetGuardLimit
;
static
const
size_t
MinOffsetGuardLimit
=
OffsetGuardLimit
;
#
endif
extern
bool
IsValidBoundsCheckImmediate
(
uint32_t
i
)
;
extern
size_t
ComputeMappedSize
(
uint32_t
maxSize
)
;
#
if
defined
(
JS_CODEGEN_X64
)
|
|
defined
(
JS_CODEGEN_ARM64
)
static
const
uint32_t
MaxInlineMemoryCopyLength
=
64
;
static
const
uint32_t
MaxInlineMemoryFillLength
=
64
;
#
elif
defined
(
JS_CODEGEN_X86
)
static
const
uint32_t
MaxInlineMemoryCopyLength
=
32
;
static
const
uint32_t
MaxInlineMemoryFillLength
=
32
;
#
else
static
const
uint32_t
MaxInlineMemoryCopyLength
=
0
;
static
const
uint32_t
MaxInlineMemoryFillLength
=
0
;
#
endif
static_assert
(
MaxInlineMemoryCopyLength
<
MinOffsetGuardLimit
"
precondition
"
)
;
static_assert
(
MaxInlineMemoryFillLength
<
MinOffsetGuardLimit
"
precondition
"
)
;
class
Frame
{
uint8_t
*
callerFP_
;
TlsData
*
tls_
;
#
if
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_ARM64
)
protected
:
uintptr_t
padding_
;
private
:
#
endif
void
*
returnAddress_
;
public
:
static
constexpr
uint32_t
tlsOffset
(
)
{
return
offsetof
(
Frame
tls_
)
;
}
static
constexpr
uint32_t
callerFPOffset
(
)
{
return
offsetof
(
Frame
callerFP_
)
;
}
static
constexpr
uint32_t
returnAddressOffset
(
)
{
return
offsetof
(
Frame
returnAddress_
)
;
}
uint8_t
*
returnAddress
(
)
const
{
return
reinterpret_cast
<
uint8_t
*
>
(
returnAddress_
)
;
}
void
*
*
addressOfReturnAddress
(
)
{
return
reinterpret_cast
<
void
*
*
>
(
&
returnAddress_
)
;
}
uint8_t
*
rawCaller
(
)
const
{
return
callerFP_
;
}
TlsData
*
tls
(
)
const
{
return
tls_
;
}
Instance
*
instance
(
)
const
{
return
tls
(
)
-
>
instance
;
}
Frame
*
wasmCaller
(
)
const
{
MOZ_ASSERT
(
!
callerIsExitOrJitEntryFP
(
)
)
;
return
reinterpret_cast
<
Frame
*
>
(
callerFP_
)
;
}
bool
callerIsExitOrJitEntryFP
(
)
const
{
return
isExitOrJitEntryFP
(
callerFP_
)
;
}
uint8_t
*
jitEntryCaller
(
)
const
{
return
toJitEntryCaller
(
callerFP_
)
;
}
static
const
Frame
*
fromUntaggedWasmExitFP
(
const
void
*
savedFP
)
{
MOZ_ASSERT
(
!
isExitOrJitEntryFP
(
savedFP
)
)
;
return
reinterpret_cast
<
const
Frame
*
>
(
savedFP
)
;
}
static
bool
isExitOrJitEntryFP
(
const
void
*
fp
)
{
return
reinterpret_cast
<
uintptr_t
>
(
fp
)
&
ExitOrJitEntryFPTag
;
}
static
uint8_t
*
toJitEntryCaller
(
const
void
*
fp
)
{
MOZ_ASSERT
(
isExitOrJitEntryFP
(
fp
)
)
;
return
reinterpret_cast
<
uint8_t
*
>
(
reinterpret_cast
<
uintptr_t
>
(
fp
)
&
~
ExitOrJitEntryFPTag
)
;
}
static
uint8_t
*
addExitOrJitEntryFPTag
(
const
Frame
*
fp
)
{
MOZ_ASSERT
(
!
isExitOrJitEntryFP
(
fp
)
)
;
return
reinterpret_cast
<
uint8_t
*
>
(
reinterpret_cast
<
uintptr_t
>
(
fp
)
|
ExitOrJitEntryFPTag
)
;
}
}
;
static_assert
(
!
std
:
:
is_polymorphic_v
<
Frame
>
"
Frame
doesn
'
t
need
a
vtable
.
"
)
;
#
if
defined
(
JS_CODEGEN_ARM64
)
static_assert
(
sizeof
(
Frame
)
%
16
=
=
0
"
frame
is
aligned
"
)
;
#
endif
class
DebugFrame
{
union
SpilledRegisterResult
{
private
:
int32_t
i32_
;
int64_t
i64_
;
intptr_t
ref_
;
AnyRef
anyref_
;
float
f32_
;
double
f64_
;
#
ifdef
ENABLE_WASM_SIMD
V128
v128_
;
#
endif
#
ifdef
DEBUG
static
inline
void
assertAllValueTypesHandled
(
ValType
type
)
{
switch
(
type
.
kind
(
)
)
{
case
ValType
:
:
I32
:
case
ValType
:
:
I64
:
case
ValType
:
:
F32
:
case
ValType
:
:
F64
:
case
ValType
:
:
V128
:
return
;
case
ValType
:
:
Ref
:
switch
(
type
.
refTypeKind
(
)
)
{
case
RefType
:
:
Any
:
case
RefType
:
:
Func
:
case
RefType
:
:
TypeIndex
:
return
;
}
}
}
#
endif
}
;
SpilledRegisterResult
registerResults_
[
MaxRegisterResults
]
;
js
:
:
Value
cachedReturnJSValue_
;
void
*
stackResultsPointer_
;
uint32_t
funcIndex_
;
union
Flags
{
struct
{
uint32_t
observing
:
1
;
uint32_t
isDebuggee
:
1
;
uint32_t
prevUpToDate
:
1
;
uint32_t
hasCachedSavedFrame
:
1
;
uint32_t
hasCachedReturnJSValue
:
1
;
uint32_t
hasSpilledRefRegisterResult
:
MaxRegisterResults
;
}
;
uint32_t
allFlags
;
}
flags_
;
protected
:
#
if
defined
(
JS_CODEGEN_MIPS32
)
uint32_t
padding_
;
#
endif
private
:
Frame
frame_
;
public
:
static
DebugFrame
*
from
(
Frame
*
fp
)
;
Frame
&
frame
(
)
{
return
frame_
;
}
uint32_t
funcIndex
(
)
const
{
return
funcIndex_
;
}
Instance
*
instance
(
)
const
{
return
frame_
.
instance
(
)
;
}
GlobalObject
*
global
(
)
const
;
bool
hasGlobal
(
const
GlobalObject
*
global
)
const
;
JSObject
*
environmentChain
(
)
const
;
bool
getLocal
(
uint32_t
localIndex
MutableHandleValue
vp
)
;
bool
hasCachedReturnJSValue
(
)
const
{
return
flags_
.
hasCachedReturnJSValue
;
}
MOZ_MUST_USE
bool
updateReturnJSValue
(
JSContext
*
cx
)
;
HandleValue
returnValue
(
)
const
;
void
clearReturnJSValue
(
)
;
void
observe
(
JSContext
*
cx
)
;
void
leave
(
JSContext
*
cx
)
;
bool
isDebuggee
(
)
const
{
return
flags_
.
isDebuggee
;
}
void
setIsDebuggee
(
)
{
flags_
.
isDebuggee
=
true
;
}
void
unsetIsDebuggee
(
)
{
flags_
.
isDebuggee
=
false
;
}
bool
prevUpToDate
(
)
const
{
return
flags_
.
prevUpToDate
;
}
void
setPrevUpToDate
(
)
{
flags_
.
prevUpToDate
=
true
;
}
void
unsetPrevUpToDate
(
)
{
flags_
.
prevUpToDate
=
false
;
}
bool
hasCachedSavedFrame
(
)
const
{
return
flags_
.
hasCachedSavedFrame
;
}
void
setHasCachedSavedFrame
(
)
{
flags_
.
hasCachedSavedFrame
=
true
;
}
void
clearHasCachedSavedFrame
(
)
{
flags_
.
hasCachedSavedFrame
=
false
;
}
bool
hasSpilledRegisterRefResult
(
size_t
n
)
const
{
uint32_t
mask
=
hasSpilledRegisterRefResultBitMask
(
n
)
;
return
(
flags_
.
allFlags
&
mask
)
!
=
0
;
}
static
constexpr
size_t
offsetOfRegisterResults
(
)
{
return
offsetof
(
DebugFrame
registerResults_
)
;
}
static
constexpr
size_t
offsetOfRegisterResult
(
size_t
n
)
{
MOZ_ASSERT
(
n
<
MaxRegisterResults
)
;
return
offsetOfRegisterResults
(
)
+
n
*
sizeof
(
SpilledRegisterResult
)
;
}
static
constexpr
size_t
offsetOfCachedReturnJSValue
(
)
{
return
offsetof
(
DebugFrame
cachedReturnJSValue_
)
;
}
static
constexpr
size_t
offsetOfStackResultsPointer
(
)
{
return
offsetof
(
DebugFrame
stackResultsPointer_
)
;
}
static
constexpr
size_t
offsetOfFlags
(
)
{
return
offsetof
(
DebugFrame
flags_
)
;
}
static
constexpr
uint32_t
hasSpilledRegisterRefResultBitMask
(
size_t
n
)
{
MOZ_ASSERT
(
n
<
MaxRegisterResults
)
;
union
Flags
flags
=
{
.
allFlags
=
0
}
;
flags
.
hasSpilledRefRegisterResult
=
1
<
<
n
;
MOZ_ASSERT
(
flags
.
allFlags
!
=
0
)
;
return
flags
.
allFlags
;
}
static
constexpr
size_t
offsetOfFuncIndex
(
)
{
return
offsetof
(
DebugFrame
funcIndex_
)
;
}
static
constexpr
size_t
offsetOfFrame
(
)
{
return
offsetof
(
DebugFrame
frame_
)
;
}
static
const
unsigned
Alignment
=
8
;
static
void
alignmentStaticAsserts
(
)
;
}
;
extern
void
Log
(
JSContext
*
cx
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
enum
class
DebugChannel
{
Function
Import
}
;
#
ifdef
WASM_CODEGEN_DEBUG
bool
IsCodegenDebugEnabled
(
DebugChannel
channel
)
;
#
endif
void
DebugCodegen
(
DebugChannel
channel
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
using
PrintCallback
=
void
(
*
)
(
const
char
*
)
;
}
}
#
endif
