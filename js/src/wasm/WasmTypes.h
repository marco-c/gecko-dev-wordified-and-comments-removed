#
ifndef
wasm_types_h
#
define
wasm_types_h
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
<
type_traits
>
#
include
"
NamespaceImports
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
js
/
RefCounted
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
MallocProvider
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
wasm
/
WasmBuiltins
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmCodegenTypes
.
h
"
#
include
"
wasm
/
WasmExprType
.
h
"
#
include
"
wasm
/
WasmInitExpr
.
h
"
#
include
"
wasm
/
WasmMemory
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
#
include
"
wasm
/
WasmShareable
.
h
"
#
include
"
wasm
/
WasmTlsData
.
h
"
#
include
"
wasm
/
WasmTypeDecls
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
#
include
"
wasm
/
WasmUtility
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
#
include
"
wasm
/
WasmValue
.
h
"
namespace
js
{
namespace
jit
{
enum
class
RoundingMode
;
}
namespace
wasm
{
using
mozilla
:
:
Atomic
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
MallocSizeOf
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
PodZero
;
using
mozilla
:
:
Some
;
class
Code
;
class
DebugState
;
class
GeneratedSourceMap
;
class
Memory
;
class
Module
;
class
Instance
;
class
Table
;
struct
ExceptionTag
:
AtomicRefCounted
<
ExceptionTag
>
{
ExceptionTag
(
)
=
default
;
}
;
using
SharedExceptionTag
=
RefPtr
<
ExceptionTag
>
;
using
SharedExceptionTagVector
=
Vector
<
SharedExceptionTag
0
SystemAllocPolicy
>
;
class
WasmJSExceptionObject
:
public
NativeObject
{
static
const
unsigned
VALUE_SLOT
=
0
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
1
;
static
const
JSClass
class_
;
const
Value
&
value
(
)
const
{
return
getFixedSlot
(
VALUE_SLOT
)
;
}
static
WasmJSExceptionObject
*
create
(
JSContext
*
cx
MutableHandleValue
value
)
;
}
;
enum
ModuleKind
{
Wasm
AsmJS
}
;
struct
CacheableChars
:
UniqueChars
{
CacheableChars
(
)
=
default
;
explicit
CacheableChars
(
char
*
ptr
)
:
UniqueChars
(
ptr
)
{
}
MOZ_IMPLICIT
CacheableChars
(
UniqueChars
&
&
rhs
)
:
UniqueChars
(
std
:
:
move
(
rhs
)
)
{
}
WASM_DECLARE_SERIALIZABLE
(
CacheableChars
)
}
;
using
CacheableCharsVector
=
Vector
<
CacheableChars
0
SystemAllocPolicy
>
;
struct
Import
{
CacheableChars
module
;
CacheableChars
field
;
DefinitionKind
kind
;
Import
(
)
=
default
;
Import
(
UniqueChars
&
&
module
UniqueChars
&
&
field
DefinitionKind
kind
)
:
module
(
std
:
:
move
(
module
)
)
field
(
std
:
:
move
(
field
)
)
kind
(
kind
)
{
}
WASM_DECLARE_SERIALIZABLE
(
Import
)
}
;
using
ImportVector
=
Vector
<
Import
0
SystemAllocPolicy
>
;
class
Export
{
CacheableChars
fieldName_
;
struct
CacheablePod
{
DefinitionKind
kind_
;
uint32_t
index_
;
}
pod
;
public
:
Export
(
)
=
default
;
explicit
Export
(
UniqueChars
fieldName
uint32_t
index
DefinitionKind
kind
)
;
explicit
Export
(
UniqueChars
fieldName
DefinitionKind
kind
)
;
const
char
*
fieldName
(
)
const
{
return
fieldName_
.
get
(
)
;
}
DefinitionKind
kind
(
)
const
{
return
pod
.
kind_
;
}
uint32_t
funcIndex
(
)
const
;
#
ifdef
ENABLE_WASM_EXCEPTIONS
uint32_t
tagIndex
(
)
const
;
#
endif
uint32_t
globalIndex
(
)
const
;
uint32_t
tableIndex
(
)
const
;
WASM_DECLARE_SERIALIZABLE
(
Export
)
}
;
using
ExportVector
=
Vector
<
Export
0
SystemAllocPolicy
>
;
enum
class
FuncFlags
:
uint8_t
{
None
=
0x0
Exported
=
0x1
Eager
=
0x2
CanRefFunc
=
0x4
}
;
class
TypeIdDesc
;
struct
FuncDesc
{
FuncType
*
type
;
TypeIdDesc
*
typeId
;
uint32_t
typeIndex
:
24
;
FuncFlags
flags
:
8
;
static_assert
(
MaxTypes
<
=
(
1
<
<
24
)
-
1
)
;
static_assert
(
sizeof
(
FuncFlags
)
=
=
sizeof
(
uint8_t
)
)
;
FuncDesc
(
)
=
default
;
FuncDesc
(
FuncType
*
type
TypeIdDesc
*
typeId
uint32_t
typeIndex
)
:
type
(
type
)
typeId
(
typeId
)
typeIndex
(
typeIndex
)
flags
(
FuncFlags
:
:
None
)
{
}
bool
isExported
(
)
const
{
return
uint8_t
(
flags
)
&
uint8_t
(
FuncFlags
:
:
Exported
)
;
}
bool
isEager
(
)
const
{
return
uint8_t
(
flags
)
&
uint8_t
(
FuncFlags
:
:
Eager
)
;
}
bool
canRefFunc
(
)
const
{
return
uint8_t
(
flags
)
&
uint8_t
(
FuncFlags
:
:
CanRefFunc
)
;
}
}
;
using
FuncDescVector
=
Vector
<
FuncDesc
0
SystemAllocPolicy
>
;
enum
class
GlobalKind
{
Import
Constant
Variable
}
;
class
GlobalDesc
{
GlobalKind
kind_
;
InitExpr
initial_
;
unsigned
offset_
;
bool
isMutable_
;
bool
isWasm_
;
bool
isExport_
;
uint32_t
importIndex_
;
bool
isExport
(
)
const
{
return
!
isConstant
(
)
&
&
isExport_
;
}
bool
isWasm
(
)
const
{
return
!
isConstant
(
)
&
&
isWasm_
;
}
public
:
GlobalDesc
(
)
=
default
;
explicit
GlobalDesc
(
InitExpr
&
&
initial
bool
isMutable
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind_
(
(
isMutable
|
|
!
initial
.
isLiteral
(
)
)
?
GlobalKind
:
:
Variable
:
GlobalKind
:
:
Constant
)
{
initial_
=
std
:
:
move
(
initial
)
;
if
(
isVariable
(
)
)
{
isMutable_
=
isMutable
;
isWasm_
=
kind
=
=
Wasm
;
isExport_
=
false
;
offset_
=
UINT32_MAX
;
}
}
explicit
GlobalDesc
(
ValType
type
bool
isMutable
uint32_t
importIndex
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind_
(
GlobalKind
:
:
Import
)
{
initial_
=
InitExpr
(
LitVal
(
type
)
)
;
importIndex_
=
importIndex
;
isMutable_
=
isMutable
;
isWasm_
=
kind
=
=
Wasm
;
isExport_
=
false
;
offset_
=
UINT32_MAX
;
}
void
setOffset
(
unsigned
offset
)
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
offset_
=
=
UINT32_MAX
)
;
offset_
=
offset
;
}
unsigned
offset
(
)
const
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
offset_
!
=
UINT32_MAX
)
;
return
offset_
;
}
void
setIsExport
(
)
{
if
(
!
isConstant
(
)
)
{
isExport_
=
true
;
}
}
GlobalKind
kind
(
)
const
{
return
kind_
;
}
bool
isVariable
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Variable
;
}
bool
isConstant
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Constant
;
}
bool
isImport
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Import
;
}
bool
isMutable
(
)
const
{
return
!
isConstant
(
)
&
&
isMutable_
;
}
const
InitExpr
&
initExpr
(
)
const
{
MOZ_ASSERT
(
!
isImport
(
)
)
;
return
initial_
;
}
uint32_t
importIndex
(
)
const
{
MOZ_ASSERT
(
isImport
(
)
)
;
return
importIndex_
;
}
LitVal
constantValue
(
)
const
{
return
initial_
.
literal
(
)
;
}
bool
isIndirect
(
)
const
{
return
isMutable
(
)
&
&
isWasm
(
)
&
&
(
isImport
(
)
|
|
isExport
(
)
)
;
}
ValType
type
(
)
const
{
return
initial_
.
type
(
)
;
}
WASM_DECLARE_SERIALIZABLE
(
GlobalDesc
)
}
;
using
GlobalDescVector
=
Vector
<
GlobalDesc
0
SystemAllocPolicy
>
;
#
ifdef
ENABLE_WASM_EXCEPTIONS
struct
TagDesc
{
TagKind
kind
;
ValTypeVector
type
;
bool
isExport
;
TagDesc
(
TagKind
kind
ValTypeVector
&
&
type
bool
isExport
=
false
)
:
kind
(
kind
)
type
(
std
:
:
move
(
type
)
)
isExport
(
isExport
)
{
}
ResultType
resultType
(
)
const
{
return
ResultType
:
:
Vector
(
type
)
;
}
}
;
using
TagDescVector
=
Vector
<
TagDesc
0
SystemAllocPolicy
>
;
#
endif
struct
ElemSegment
:
AtomicRefCounted
<
ElemSegment
>
{
enum
class
Kind
{
Active
Passive
Declared
}
;
Kind
kind
;
uint32_t
tableIndex
;
RefType
elemType
;
Maybe
<
InitExpr
>
offsetIfActive
;
Uint32Vector
elemFuncIndices
;
bool
active
(
)
const
{
return
kind
=
=
Kind
:
:
Active
;
}
const
InitExpr
&
offset
(
)
const
{
return
*
offsetIfActive
;
}
size_t
length
(
)
const
{
return
elemFuncIndices
.
length
(
)
;
}
WASM_DECLARE_SERIALIZABLE
(
ElemSegment
)
}
;
constexpr
uint32_t
NullFuncIndex
=
UINT32_MAX
;
static_assert
(
NullFuncIndex
>
MaxFuncs
"
Invariant
"
)
;
using
MutableElemSegment
=
RefPtr
<
ElemSegment
>
;
using
SharedElemSegment
=
SerializableRefPtr
<
const
ElemSegment
>
;
using
ElemSegmentVector
=
Vector
<
SharedElemSegment
0
SystemAllocPolicy
>
;
struct
DataSegmentEnv
{
Maybe
<
InitExpr
>
offsetIfActive
;
uint32_t
bytecodeOffset
;
uint32_t
length
;
}
;
using
DataSegmentEnvVector
=
Vector
<
DataSegmentEnv
0
SystemAllocPolicy
>
;
struct
DataSegment
:
AtomicRefCounted
<
DataSegment
>
{
Maybe
<
InitExpr
>
offsetIfActive
;
Bytes
bytes
;
DataSegment
(
)
=
default
;
bool
active
(
)
const
{
return
!
!
offsetIfActive
;
}
const
InitExpr
&
offset
(
)
const
{
return
*
offsetIfActive
;
}
[
[
nodiscard
]
]
bool
init
(
const
ShareableBytes
&
bytecode
const
DataSegmentEnv
&
src
)
{
if
(
src
.
offsetIfActive
)
{
offsetIfActive
.
emplace
(
)
;
if
(
!
offsetIfActive
-
>
clone
(
*
src
.
offsetIfActive
)
)
{
return
false
;
}
}
return
bytes
.
append
(
bytecode
.
begin
(
)
+
src
.
bytecodeOffset
src
.
length
)
;
}
WASM_DECLARE_SERIALIZABLE
(
DataSegment
)
}
;
using
MutableDataSegment
=
RefPtr
<
DataSegment
>
;
using
SharedDataSegment
=
SerializableRefPtr
<
const
DataSegment
>
;
using
DataSegmentVector
=
Vector
<
SharedDataSegment
0
SystemAllocPolicy
>
;
struct
CustomSectionEnv
{
uint32_t
nameOffset
;
uint32_t
nameLength
;
uint32_t
payloadOffset
;
uint32_t
payloadLength
;
}
;
using
CustomSectionEnvVector
=
Vector
<
CustomSectionEnv
0
SystemAllocPolicy
>
;
struct
CustomSection
{
Bytes
name
;
SharedBytes
payload
;
WASM_DECLARE_SERIALIZABLE
(
CustomSection
)
}
;
using
CustomSectionVector
=
Vector
<
CustomSection
0
SystemAllocPolicy
>
;
struct
Name
{
uint32_t
offsetInNamePayload
;
uint32_t
length
;
Name
(
)
:
offsetInNamePayload
(
UINT32_MAX
)
length
(
0
)
{
}
}
;
using
NameVector
=
Vector
<
Name
0
SystemAllocPolicy
>
;
enum
class
LimitsKind
{
Memory
Table
}
;
struct
Limits
{
IndexType
indexType
;
uint64_t
initial
;
Maybe
<
uint64_t
>
maximum
;
Shareable
shared
;
Limits
(
)
=
default
;
explicit
Limits
(
uint64_t
initial
const
Maybe
<
uint64_t
>
&
maximum
=
Nothing
(
)
Shareable
shared
=
Shareable
:
:
False
)
:
indexType
(
IndexType
:
:
I32
)
initial
(
initial
)
maximum
(
maximum
)
shared
(
shared
)
{
}
}
;
struct
MemoryDesc
{
Limits
limits
;
bool
isShared
(
)
const
{
return
limits
.
shared
=
=
Shareable
:
:
True
;
}
bool
canMovingGrow
(
)
const
{
return
limits
.
maximum
.
isNothing
(
)
;
}
bool
boundsCheckLimitIs32Bits
(
)
const
{
return
limits
.
maximum
.
isSome
(
)
&
&
limits
.
maximum
.
value
(
)
<
(
0x100000000
/
PageSize
)
;
}
IndexType
indexType
(
)
const
{
return
limits
.
indexType
;
}
Pages
initialPages
(
)
const
{
return
Pages
(
limits
.
initial
)
;
}
Maybe
<
Pages
>
maximumPages
(
)
const
{
return
limits
.
maximum
.
map
(
[
]
(
uint64_t
x
)
{
return
Pages
(
x
)
;
}
)
;
}
uint64_t
initialLength32
(
)
const
{
MOZ_ASSERT
(
indexType
(
)
=
=
IndexType
:
:
I32
)
;
return
limits
.
initial
*
PageSize
;
}
MemoryDesc
(
)
=
default
;
explicit
MemoryDesc
(
Limits
limits
)
:
limits
(
limits
)
{
}
}
;
static_assert
(
MaxMemory32LimitField
<
=
UINT64_MAX
/
PageSize
)
;
struct
TableDesc
{
RefType
elemType
;
bool
importedOrExported
;
bool
isAsmJS
;
uint32_t
globalDataOffset
;
uint32_t
initialLength
;
Maybe
<
uint32_t
>
maximumLength
;
TableDesc
(
)
=
default
;
TableDesc
(
RefType
elemType
uint32_t
initialLength
Maybe
<
uint32_t
>
maximumLength
bool
isAsmJS
bool
importedOrExported
=
false
)
:
elemType
(
elemType
)
importedOrExported
(
importedOrExported
)
isAsmJS
(
isAsmJS
)
globalDataOffset
(
UINT32_MAX
)
initialLength
(
initialLength
)
maximumLength
(
maximumLength
)
{
}
}
;
using
TableDescVector
=
Vector
<
TableDesc
0
SystemAllocPolicy
>
;
extern
void
Log
(
JSContext
*
cx
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
enum
class
DebugChannel
{
Function
Import
}
;
#
ifdef
WASM_CODEGEN_DEBUG
bool
IsCodegenDebugEnabled
(
DebugChannel
channel
)
;
#
endif
void
DebugCodegen
(
DebugChannel
channel
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
using
PrintCallback
=
void
(
*
)
(
const
char
*
)
;
}
}
#
endif
