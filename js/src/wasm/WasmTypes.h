#
ifndef
wasm_types_h
#
define
wasm_types_h
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
js
/
RefCounted
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
MallocProvider
.
h
"
#
include
"
wasm
/
WasmBinaryConstants
.
h
"
namespace
js
{
namespace
jit
{
struct
BaselineScript
;
enum
class
RoundingMode
;
}
class
WasmMemoryObject
;
typedef
GCPtr
<
WasmMemoryObject
*
>
GCPtrWasmMemoryObject
;
typedef
Rooted
<
WasmMemoryObject
*
>
RootedWasmMemoryObject
;
typedef
Handle
<
WasmMemoryObject
*
>
HandleWasmMemoryObject
;
typedef
MutableHandle
<
WasmMemoryObject
*
>
MutableHandleWasmMemoryObject
;
class
WasmModuleObject
;
typedef
Rooted
<
WasmModuleObject
*
>
RootedWasmModuleObject
;
typedef
Handle
<
WasmModuleObject
*
>
HandleWasmModuleObject
;
typedef
MutableHandle
<
WasmModuleObject
*
>
MutableHandleWasmModuleObject
;
class
WasmInstanceObject
;
typedef
GCVector
<
WasmInstanceObject
*
>
WasmInstanceObjectVector
;
typedef
Rooted
<
WasmInstanceObject
*
>
RootedWasmInstanceObject
;
typedef
Handle
<
WasmInstanceObject
*
>
HandleWasmInstanceObject
;
typedef
MutableHandle
<
WasmInstanceObject
*
>
MutableHandleWasmInstanceObject
;
class
WasmTableObject
;
typedef
Rooted
<
WasmTableObject
*
>
RootedWasmTableObject
;
typedef
Handle
<
WasmTableObject
*
>
HandleWasmTableObject
;
typedef
MutableHandle
<
WasmTableObject
*
>
MutableHandleWasmTableObject
;
class
WasmGlobalObject
;
typedef
GCVector
<
WasmGlobalObject
*
0
SystemAllocPolicy
>
WasmGlobalObjectVector
;
typedef
Rooted
<
WasmGlobalObject
*
>
RootedWasmGlobalObject
;
namespace
wasm
{
using
mozilla
:
:
ArrayEqual
;
using
mozilla
:
:
Atomic
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
EnumeratedArray
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
MallocSizeOf
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
PodZero
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
Some
;
using
mozilla
:
:
Unused
;
class
Code
;
class
DebugState
;
class
GeneratedSourceMap
;
class
Memory
;
class
Module
;
class
Instance
;
class
Table
;
typedef
Vector
<
uint32_t
0
SystemAllocPolicy
>
Uint32Vector
;
typedef
Vector
<
uint8_t
0
SystemAllocPolicy
>
Bytes
;
typedef
UniquePtr
<
Bytes
>
UniqueBytes
;
typedef
UniquePtr
<
const
Bytes
>
UniqueConstBytes
;
typedef
Vector
<
char
0
SystemAllocPolicy
>
UTF8Bytes
;
typedef
Vector
<
Instance
*
0
SystemAllocPolicy
>
InstanceVector
;
typedef
Vector
<
UniqueChars
0
SystemAllocPolicy
>
UniqueCharsVector
;
#
define
WASM_DECLARE_POD_VECTOR
(
Type
VectorName
)
\
}
}
namespace
mozilla
{
\
template
<
>
struct
IsPod
<
js
:
:
wasm
:
:
Type
>
:
TrueType
{
}
;
\
}
namespace
js
{
namespace
wasm
{
\
typedef
Vector
<
Type
0
SystemAllocPolicy
>
VectorName
;
#
define
WASM_DECLARE_SERIALIZABLE
(
Type
)
\
size_t
serializedSize
(
)
const
;
\
uint8_t
*
serialize
(
uint8_t
*
cursor
)
const
;
\
const
uint8_t
*
deserialize
(
const
uint8_t
*
cursor
)
;
\
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
#
define
WASM_DECLARE_SERIALIZABLE_VIRTUAL
(
Type
)
\
virtual
size_t
serializedSize
(
)
const
;
\
virtual
uint8_t
*
serialize
(
uint8_t
*
cursor
)
const
;
\
virtual
const
uint8_t
*
deserialize
(
const
uint8_t
*
cursor
)
;
\
virtual
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
#
define
WASM_DECLARE_SERIALIZABLE_OVERRIDE
(
Type
)
\
size_t
serializedSize
(
)
const
override
;
\
uint8_t
*
serialize
(
uint8_t
*
cursor
)
const
override
;
\
const
uint8_t
*
deserialize
(
const
uint8_t
*
cursor
)
override
;
\
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
template
<
class
T
>
struct
ShareableBase
:
AtomicRefCounted
<
T
>
{
using
SeenSet
=
HashSet
<
const
T
*
DefaultHasher
<
const
T
*
>
SystemAllocPolicy
>
;
size_t
sizeOfIncludingThisIfNotSeen
(
MallocSizeOf
mallocSizeOf
SeenSet
*
seen
)
const
{
const
T
*
self
=
static_cast
<
const
T
*
>
(
this
)
;
typename
SeenSet
:
:
AddPtr
p
=
seen
-
>
lookupForAdd
(
self
)
;
if
(
p
)
return
0
;
bool
ok
=
seen
-
>
add
(
p
self
)
;
(
void
)
ok
;
return
mallocSizeOf
(
self
)
+
self
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
enum
class
PackedTypeCode
:
uint32_t
{
}
;
const
uint32_t
NoTypeCode
=
0xFF
;
const
uint32_t
NoRefTypeIndex
=
0xFFFFFF
;
static
inline
PackedTypeCode
InvalidPackedTypeCode
(
)
{
return
PackedTypeCode
(
(
NoRefTypeIndex
<
<
8
)
|
NoTypeCode
)
;
}
static
inline
PackedTypeCode
PackTypeCode
(
TypeCode
tc
)
{
MOZ_ASSERT
(
uint32_t
(
tc
)
<
=
0xFF
)
;
MOZ_ASSERT
(
tc
!
=
TypeCode
:
:
Ref
)
;
return
PackedTypeCode
(
(
NoRefTypeIndex
<
<
8
)
|
uint32_t
(
tc
)
)
;
}
static
inline
PackedTypeCode
PackTypeCode
(
TypeCode
tc
uint32_t
refTypeIndex
)
{
MOZ_ASSERT
(
uint32_t
(
tc
)
<
=
0xFF
)
;
MOZ_ASSERT_IF
(
tc
!
=
TypeCode
:
:
Ref
refTypeIndex
=
=
NoRefTypeIndex
)
;
MOZ_ASSERT_IF
(
tc
=
=
TypeCode
:
:
Ref
refTypeIndex
<
=
MaxTypes
)
;
return
PackedTypeCode
(
(
refTypeIndex
<
<
8
)
|
uint32_t
(
tc
)
)
;
}
static
inline
PackedTypeCode
PackedTypeCodeFromBits
(
uint32_t
bits
)
{
return
PackTypeCode
(
TypeCode
(
bits
&
255
)
bits
>
>
8
)
;
}
static
inline
bool
IsValid
(
PackedTypeCode
ptc
)
{
return
(
uint32_t
(
ptc
)
&
255
)
!
=
NoTypeCode
;
}
static
inline
uint32_t
PackedTypeCodeToBits
(
PackedTypeCode
ptc
)
{
return
uint32_t
(
ptc
)
;
}
static
inline
TypeCode
UnpackTypeCodeType
(
PackedTypeCode
ptc
)
{
MOZ_ASSERT
(
IsValid
(
ptc
)
)
;
return
TypeCode
(
uint32_t
(
ptc
)
&
255
)
;
}
static
inline
uint32_t
UnpackTypeCodeIndex
(
PackedTypeCode
ptc
)
{
MOZ_ASSERT
(
UnpackTypeCodeType
(
ptc
)
=
=
TypeCode
:
:
Ref
)
;
return
uint32_t
(
ptc
)
>
>
8
;
}
class
ValType
;
class
ExprType
{
PackedTypeCode
tc_
;
#
ifdef
DEBUG
bool
isValidCode
(
)
{
switch
(
UnpackTypeCodeType
(
tc_
)
)
{
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
case
TypeCode
:
:
AnyRef
:
case
TypeCode
:
:
Ref
:
case
TypeCode
:
:
BlockVoid
:
case
TypeCode
:
:
Limit
:
return
true
;
default
:
return
false
;
}
}
#
endif
public
:
enum
Code
{
Void
=
uint8_t
(
TypeCode
:
:
BlockVoid
)
I32
=
uint8_t
(
TypeCode
:
:
I32
)
I64
=
uint8_t
(
TypeCode
:
:
I64
)
F32
=
uint8_t
(
TypeCode
:
:
F32
)
F64
=
uint8_t
(
TypeCode
:
:
F64
)
AnyRef
=
uint8_t
(
TypeCode
:
:
AnyRef
)
Ref
=
uint8_t
(
TypeCode
:
:
Ref
)
Limit
=
uint8_t
(
TypeCode
:
:
Limit
)
}
;
ExprType
(
)
:
tc_
(
)
{
}
ExprType
(
const
ExprType
&
that
)
:
tc_
(
that
.
tc_
)
{
}
MOZ_IMPLICIT
ExprType
(
Code
c
)
:
tc_
(
PackTypeCode
(
TypeCode
(
c
)
)
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
ExprType
(
Code
c
uint32_t
refTypeIndex
)
:
tc_
(
PackTypeCode
(
TypeCode
(
c
)
refTypeIndex
)
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
explicit
ExprType
(
PackedTypeCode
ptc
)
:
tc_
(
ptc
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
explicit
inline
ExprType
(
const
ValType
&
t
)
;
PackedTypeCode
packed
(
)
const
{
return
tc_
;
}
Code
code
(
)
const
{
return
Code
(
UnpackTypeCodeType
(
tc_
)
)
;
}
uint32_t
refTypeIndex
(
)
const
{
return
UnpackTypeCodeIndex
(
tc_
)
;
}
bool
isValid
(
)
const
{
return
IsValid
(
tc_
)
;
}
bool
isRef
(
)
const
{
return
UnpackTypeCodeType
(
tc_
)
=
=
TypeCode
:
:
Ref
;
}
bool
isRefOrAnyRef
(
)
const
{
TypeCode
tc
=
UnpackTypeCodeType
(
tc_
)
;
return
tc
=
=
TypeCode
:
:
Ref
|
|
tc
=
=
TypeCode
:
:
AnyRef
;
}
bool
operator
=
=
(
const
ExprType
&
that
)
const
{
return
tc_
=
=
that
.
tc_
;
}
bool
operator
!
=
(
const
ExprType
&
that
)
const
{
return
tc_
!
=
that
.
tc_
;
}
bool
operator
=
=
(
Code
that
)
const
{
MOZ_ASSERT
(
that
!
=
Code
:
:
Ref
)
;
return
code
(
)
=
=
that
;
}
bool
operator
!
=
(
Code
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
}
;
class
ValType
{
PackedTypeCode
tc_
;
#
ifdef
DEBUG
bool
isValidCode
(
)
{
switch
(
UnpackTypeCodeType
(
tc_
)
)
{
case
TypeCode
:
:
I32
:
case
TypeCode
:
:
I64
:
case
TypeCode
:
:
F32
:
case
TypeCode
:
:
F64
:
case
TypeCode
:
:
AnyRef
:
case
TypeCode
:
:
Ref
:
return
true
;
default
:
return
false
;
}
}
#
endif
public
:
enum
Code
{
I32
=
uint8_t
(
TypeCode
:
:
I32
)
I64
=
uint8_t
(
TypeCode
:
:
I64
)
F32
=
uint8_t
(
TypeCode
:
:
F32
)
F64
=
uint8_t
(
TypeCode
:
:
F64
)
AnyRef
=
uint8_t
(
TypeCode
:
:
AnyRef
)
Ref
=
uint8_t
(
TypeCode
:
:
Ref
)
}
;
ValType
(
)
:
tc_
(
InvalidPackedTypeCode
(
)
)
{
}
MOZ_IMPLICIT
ValType
(
Code
c
)
:
tc_
(
PackTypeCode
(
TypeCode
(
c
)
)
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
ValType
(
Code
c
uint32_t
refTypeIndex
)
:
tc_
(
PackTypeCode
(
TypeCode
(
c
)
refTypeIndex
)
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
explicit
ValType
(
const
ExprType
&
t
)
:
tc_
(
t
.
packed
(
)
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
explicit
ValType
(
PackedTypeCode
ptc
)
:
tc_
(
ptc
)
{
MOZ_ASSERT
(
isValidCode
(
)
)
;
}
static
ValType
fromBitsUnsafe
(
uint32_t
bits
)
{
return
ValType
(
PackedTypeCodeFromBits
(
bits
)
)
;
}
PackedTypeCode
packed
(
)
const
{
return
tc_
;
}
uint32_t
bitsUnsafe
(
)
const
{
return
PackedTypeCodeToBits
(
tc_
)
;
}
Code
code
(
)
const
{
return
Code
(
UnpackTypeCodeType
(
tc_
)
)
;
}
uint32_t
refTypeIndex
(
)
const
{
return
UnpackTypeCodeIndex
(
tc_
)
;
}
bool
isValid
(
)
const
{
return
IsValid
(
tc_
)
;
}
bool
isRef
(
)
const
{
return
UnpackTypeCodeType
(
tc_
)
=
=
TypeCode
:
:
Ref
;
}
bool
isRefOrAnyRef
(
)
const
{
TypeCode
tc
=
UnpackTypeCodeType
(
tc_
)
;
return
tc
=
=
TypeCode
:
:
Ref
|
|
tc
=
=
TypeCode
:
:
AnyRef
;
}
bool
operator
=
=
(
const
ValType
&
that
)
const
{
return
tc_
=
=
that
.
tc_
;
}
bool
operator
!
=
(
const
ValType
&
that
)
const
{
return
tc_
!
=
that
.
tc_
;
}
bool
operator
=
=
(
Code
that
)
const
{
MOZ_ASSERT
(
that
!
=
Code
:
:
Ref
)
;
return
code
(
)
=
=
that
;
}
bool
operator
!
=
(
Code
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
}
;
typedef
Vector
<
ValType
8
SystemAllocPolicy
>
ValTypeVector
;
static
inline
unsigned
SizeOf
(
ValType
vt
)
{
switch
(
vt
.
code
(
)
)
{
case
ValType
:
:
I32
:
case
ValType
:
:
F32
:
return
4
;
case
ValType
:
:
I64
:
case
ValType
:
:
F64
:
return
8
;
case
ValType
:
:
AnyRef
:
case
ValType
:
:
Ref
:
return
sizeof
(
intptr_t
)
;
}
MOZ_CRASH
(
"
Invalid
ValType
"
)
;
}
static
inline
jit
:
:
MIRType
ToMIRType
(
ValType
vt
)
{
switch
(
vt
.
code
(
)
)
{
case
ValType
:
:
I32
:
return
jit
:
:
MIRType
:
:
Int32
;
case
ValType
:
:
I64
:
return
jit
:
:
MIRType
:
:
Int64
;
case
ValType
:
:
F32
:
return
jit
:
:
MIRType
:
:
Float32
;
case
ValType
:
:
F64
:
return
jit
:
:
MIRType
:
:
Double
;
case
ValType
:
:
Ref
:
return
jit
:
:
MIRType
:
:
Pointer
;
case
ValType
:
:
AnyRef
:
return
jit
:
:
MIRType
:
:
Pointer
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
bad
type
"
)
;
}
static
inline
bool
IsNumberType
(
ValType
vt
)
{
return
!
vt
.
isRefOrAnyRef
(
)
;
}
inline
ExprType
:
:
ExprType
(
const
ValType
&
t
)
:
tc_
(
t
.
packed
(
)
)
{
}
static
inline
bool
IsVoid
(
ExprType
et
)
{
return
et
=
=
ExprType
:
:
Void
;
}
static
inline
ValType
NonVoidToValType
(
ExprType
et
)
{
MOZ_ASSERT
(
!
IsVoid
(
et
)
)
;
return
ValType
(
et
)
;
}
static
inline
jit
:
:
MIRType
ToMIRType
(
ExprType
et
)
{
return
IsVoid
(
et
)
?
jit
:
:
MIRType
:
:
None
:
ToMIRType
(
ValType
(
et
)
)
;
}
static
inline
const
char
*
ToCString
(
ExprType
type
)
{
switch
(
type
.
code
(
)
)
{
case
ExprType
:
:
Void
:
return
"
void
"
;
case
ExprType
:
:
I32
:
return
"
i32
"
;
case
ExprType
:
:
I64
:
return
"
i64
"
;
case
ExprType
:
:
F32
:
return
"
f32
"
;
case
ExprType
:
:
F64
:
return
"
f64
"
;
case
ExprType
:
:
AnyRef
:
return
"
anyref
"
;
case
ExprType
:
:
Ref
:
return
"
ref
"
;
case
ExprType
:
:
Limit
:
;
}
MOZ_CRASH
(
"
bad
expression
type
"
)
;
}
static
inline
const
char
*
ToCString
(
ValType
type
)
{
return
ToCString
(
ExprType
(
type
)
)
;
}
enum
class
Tier
{
Baseline
Debug
=
Baseline
Ion
Serialized
=
Ion
}
;
enum
class
CompileMode
{
Once
Tier1
Tier2
}
;
enum
class
DebugEnabled
{
False
True
}
;
class
Tiers
{
Tier
t_
[
2
]
;
uint32_t
n_
;
public
:
explicit
Tiers
(
)
{
n_
=
0
;
}
explicit
Tiers
(
Tier
t
)
{
t_
[
0
]
=
t
;
n_
=
1
;
}
explicit
Tiers
(
Tier
t
Tier
u
)
{
MOZ_ASSERT
(
t
!
=
u
)
;
t_
[
0
]
=
t
;
t_
[
1
]
=
u
;
n_
=
2
;
}
Tier
*
begin
(
)
{
return
t_
;
}
Tier
*
end
(
)
{
return
t_
+
n_
;
}
}
;
enum
ModuleKind
{
Wasm
AsmJS
}
;
enum
class
Shareable
{
False
True
}
;
enum
class
HasGcTypes
{
False
True
}
;
class
LitVal
{
protected
:
ValType
type_
;
union
U
{
uint32_t
i32_
;
uint64_t
i64_
;
float
f32_
;
double
f64_
;
JSObject
*
ptr_
;
}
u
;
public
:
LitVal
(
)
:
type_
(
)
u
{
}
{
}
explicit
LitVal
(
uint32_t
i32
)
:
type_
(
ValType
:
:
I32
)
{
u
.
i32_
=
i32
;
}
explicit
LitVal
(
uint64_t
i64
)
:
type_
(
ValType
:
:
I64
)
{
u
.
i64_
=
i64
;
}
explicit
LitVal
(
float
f32
)
:
type_
(
ValType
:
:
F32
)
{
u
.
f32_
=
f32
;
}
explicit
LitVal
(
double
f64
)
:
type_
(
ValType
:
:
F64
)
{
u
.
f64_
=
f64
;
}
explicit
LitVal
(
ValType
refType
JSObject
*
ptr
)
:
type_
(
refType
)
{
MOZ_ASSERT
(
refType
.
isRefOrAnyRef
(
)
)
;
MOZ_ASSERT
(
ptr
=
=
nullptr
"
use
Val
for
non
-
nullptr
ref
types
to
get
tracing
"
)
;
u
.
ptr_
=
ptr
;
}
ValType
type
(
)
const
{
return
type_
;
}
static
constexpr
size_t
sizeofLargestValue
(
)
{
return
sizeof
(
u
)
;
}
uint32_t
i32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I32
)
;
return
u
.
i32_
;
}
uint64_t
i64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I64
)
;
return
u
.
i64_
;
}
const
float
&
f32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F32
)
;
return
u
.
f32_
;
}
const
double
&
f64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F64
)
;
return
u
.
f64_
;
}
JSObject
*
ptr
(
)
const
{
MOZ_ASSERT
(
type_
.
isRefOrAnyRef
(
)
)
;
return
u
.
ptr_
;
}
}
;
typedef
Vector
<
LitVal
0
SystemAllocPolicy
>
LitValVector
;
class
MOZ_NON_PARAM
Val
:
public
LitVal
{
public
:
Val
(
)
:
LitVal
(
)
{
}
explicit
Val
(
const
LitVal
&
val
)
;
explicit
Val
(
uint32_t
i32
)
:
LitVal
(
i32
)
{
}
explicit
Val
(
uint64_t
i64
)
:
LitVal
(
i64
)
{
}
explicit
Val
(
float
f32
)
:
LitVal
(
f32
)
{
}
explicit
Val
(
double
f64
)
:
LitVal
(
f64
)
{
}
explicit
Val
(
JSObject
*
obj
)
:
LitVal
(
ValType
:
:
AnyRef
nullptr
)
{
u
.
ptr_
=
obj
;
}
void
writePayload
(
uint8_t
*
dst
)
const
;
void
trace
(
JSTracer
*
trc
)
;
}
;
typedef
Rooted
<
Val
>
RootedVal
;
typedef
Handle
<
Val
>
HandleVal
;
typedef
MutableHandle
<
Val
>
MutableHandleVal
;
typedef
GCVector
<
Val
0
SystemAllocPolicy
>
GCVectorVal
;
typedef
Rooted
<
GCVectorVal
>
RootedValVector
;
typedef
Handle
<
GCVectorVal
>
HandleValVector
;
typedef
MutableHandle
<
GCVectorVal
>
MutableHandleValVector
;
class
FuncType
{
ValTypeVector
args_
;
ExprType
ret_
;
public
:
FuncType
(
)
:
args_
(
)
ret_
(
ExprType
:
:
Void
)
{
}
FuncType
(
ValTypeVector
&
&
args
ExprType
ret
)
:
args_
(
std
:
:
move
(
args
)
)
ret_
(
ret
)
{
}
MOZ_MUST_USE
bool
clone
(
const
FuncType
&
rhs
)
{
ret_
=
rhs
.
ret_
;
MOZ_ASSERT
(
args_
.
empty
(
)
)
;
return
args_
.
appendAll
(
rhs
.
args_
)
;
}
ValType
arg
(
unsigned
i
)
const
{
return
args_
[
i
]
;
}
const
ValTypeVector
&
args
(
)
const
{
return
args_
;
}
const
ExprType
&
ret
(
)
const
{
return
ret_
;
}
HashNumber
hash
(
)
const
{
HashNumber
hn
=
HashNumber
(
ret_
.
code
(
)
)
;
for
(
const
ValType
&
vt
:
args_
)
hn
=
mozilla
:
:
AddToHash
(
hn
HashNumber
(
vt
.
code
(
)
)
)
;
return
hn
;
}
bool
operator
=
=
(
const
FuncType
&
rhs
)
const
{
return
ret
(
)
=
=
rhs
.
ret
(
)
&
&
EqualContainers
(
args
(
)
rhs
.
args
(
)
)
;
}
bool
operator
!
=
(
const
FuncType
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
hasI64ArgOrRet
(
)
const
{
if
(
ret
(
)
=
=
ExprType
:
:
I64
)
return
true
;
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
=
=
ValType
:
:
I64
)
return
true
;
}
return
false
;
}
bool
temporarilyUnsupportedAnyRef
(
)
const
{
if
(
ret
(
)
.
isRefOrAnyRef
(
)
)
return
true
;
for
(
ValType
arg
:
args
(
)
)
{
if
(
arg
.
isRefOrAnyRef
(
)
)
return
true
;
}
return
false
;
}
WASM_DECLARE_SERIALIZABLE
(
FuncType
)
}
;
struct
FuncTypeHashPolicy
{
typedef
const
FuncType
&
Lookup
;
static
HashNumber
hash
(
Lookup
ft
)
{
return
ft
.
hash
(
)
;
}
static
bool
match
(
const
FuncType
*
lhs
Lookup
rhs
)
{
return
*
lhs
=
=
rhs
;
}
}
;
struct
StructField
{
ValType
type
;
uint32_t
offset
;
bool
isMutable
;
}
;
typedef
Vector
<
StructField
0
SystemAllocPolicy
>
StructFieldVector
;
class
StructType
{
public
:
StructFieldVector
fields_
;
public
:
StructType
(
)
:
fields_
(
)
{
}
explicit
StructType
(
StructFieldVector
&
&
fields
)
:
fields_
(
std
:
:
move
(
fields
)
)
{
}
bool
hasPrefix
(
const
StructType
&
other
)
const
;
WASM_DECLARE_SERIALIZABLE
(
StructType
)
}
;
typedef
Vector
<
StructType
0
SystemAllocPolicy
>
StructTypeVector
;
class
InitExpr
{
public
:
enum
class
Kind
{
Constant
GetGlobal
}
;
private
:
Kind
kind_
;
union
U
{
LitVal
val_
;
struct
{
uint32_t
index_
;
ValType
type_
;
}
global
;
U
(
)
:
global
{
}
{
}
}
u
;
public
:
InitExpr
(
)
=
default
;
explicit
InitExpr
(
LitVal
val
)
:
kind_
(
Kind
:
:
Constant
)
{
u
.
val_
=
val
;
}
explicit
InitExpr
(
uint32_t
globalIndex
ValType
type
)
:
kind_
(
Kind
:
:
GetGlobal
)
{
u
.
global
.
index_
=
globalIndex
;
u
.
global
.
type_
=
type
;
}
Kind
kind
(
)
const
{
return
kind_
;
}
bool
isVal
(
)
const
{
return
kind
(
)
=
=
Kind
:
:
Constant
;
}
LitVal
val
(
)
const
{
MOZ_ASSERT
(
isVal
(
)
)
;
return
u
.
val_
;
}
uint32_t
globalIndex
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
Kind
:
:
GetGlobal
)
;
return
u
.
global
.
index_
;
}
ValType
type
(
)
const
{
switch
(
kind
(
)
)
{
case
Kind
:
:
Constant
:
return
u
.
val_
.
type
(
)
;
case
Kind
:
:
GetGlobal
:
return
u
.
global
.
type_
;
}
MOZ_CRASH
(
"
unexpected
initExpr
type
"
)
;
}
}
;
struct
CacheableChars
:
UniqueChars
{
CacheableChars
(
)
=
default
;
explicit
CacheableChars
(
char
*
ptr
)
:
UniqueChars
(
ptr
)
{
}
MOZ_IMPLICIT
CacheableChars
(
UniqueChars
&
&
rhs
)
:
UniqueChars
(
std
:
:
move
(
rhs
)
)
{
}
WASM_DECLARE_SERIALIZABLE
(
CacheableChars
)
}
;
typedef
Vector
<
CacheableChars
0
SystemAllocPolicy
>
CacheableCharsVector
;
struct
Import
{
CacheableChars
module
;
CacheableChars
field
;
DefinitionKind
kind
;
Import
(
)
=
default
;
Import
(
UniqueChars
&
&
module
UniqueChars
&
&
field
DefinitionKind
kind
)
:
module
(
std
:
:
move
(
module
)
)
field
(
std
:
:
move
(
field
)
)
kind
(
kind
)
{
}
WASM_DECLARE_SERIALIZABLE
(
Import
)
}
;
typedef
Vector
<
Import
0
SystemAllocPolicy
>
ImportVector
;
class
Export
{
CacheableChars
fieldName_
;
struct
CacheablePod
{
DefinitionKind
kind_
;
uint32_t
index_
;
}
pod
;
public
:
Export
(
)
=
default
;
explicit
Export
(
UniqueChars
fieldName
uint32_t
index
DefinitionKind
kind
)
;
explicit
Export
(
UniqueChars
fieldName
DefinitionKind
kind
)
;
const
char
*
fieldName
(
)
const
{
return
fieldName_
.
get
(
)
;
}
DefinitionKind
kind
(
)
const
{
return
pod
.
kind_
;
}
uint32_t
funcIndex
(
)
const
;
uint32_t
globalIndex
(
)
const
;
WASM_DECLARE_SERIALIZABLE
(
Export
)
}
;
typedef
Vector
<
Export
0
SystemAllocPolicy
>
ExportVector
;
enum
class
GlobalKind
{
Import
Constant
Variable
}
;
class
GlobalDesc
{
union
V
{
struct
{
union
U
{
InitExpr
initial_
;
struct
{
ValType
type_
;
uint32_t
index_
;
}
import
;
U
(
)
:
import
{
}
{
}
}
val
;
unsigned
offset_
;
bool
isMutable_
;
bool
isWasm_
;
bool
isExport_
;
}
var
;
LitVal
cst_
;
V
(
)
{
}
}
u
;
GlobalKind
kind_
;
bool
isExport
(
)
const
{
return
!
isConstant
(
)
&
&
u
.
var
.
isExport_
;
}
bool
isWasm
(
)
const
{
return
!
isConstant
(
)
&
&
u
.
var
.
isWasm_
;
}
public
:
GlobalDesc
(
)
=
default
;
explicit
GlobalDesc
(
InitExpr
initial
bool
isMutable
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind_
(
(
isMutable
|
|
!
initial
.
isVal
(
)
)
?
GlobalKind
:
:
Variable
:
GlobalKind
:
:
Constant
)
{
if
(
isVariable
(
)
)
{
u
.
var
.
val
.
initial_
=
initial
;
u
.
var
.
isMutable_
=
isMutable
;
u
.
var
.
isWasm_
=
kind
=
=
Wasm
;
u
.
var
.
isExport_
=
false
;
u
.
var
.
offset_
=
UINT32_MAX
;
}
else
{
u
.
cst_
=
initial
.
val
(
)
;
}
}
explicit
GlobalDesc
(
ValType
type
bool
isMutable
uint32_t
importIndex
ModuleKind
kind
=
ModuleKind
:
:
Wasm
)
:
kind_
(
GlobalKind
:
:
Import
)
{
u
.
var
.
val
.
import
.
type_
=
type
;
u
.
var
.
val
.
import
.
index_
=
importIndex
;
u
.
var
.
isMutable_
=
isMutable
;
u
.
var
.
isWasm_
=
kind
=
=
Wasm
;
u
.
var
.
isExport_
=
false
;
u
.
var
.
offset_
=
UINT32_MAX
;
}
void
setOffset
(
unsigned
offset
)
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
u
.
var
.
offset_
=
=
UINT32_MAX
)
;
u
.
var
.
offset_
=
offset
;
}
unsigned
offset
(
)
const
{
MOZ_ASSERT
(
!
isConstant
(
)
)
;
MOZ_ASSERT
(
u
.
var
.
offset_
!
=
UINT32_MAX
)
;
return
u
.
var
.
offset_
;
}
void
setIsExport
(
)
{
if
(
!
isConstant
(
)
)
u
.
var
.
isExport_
=
true
;
}
GlobalKind
kind
(
)
const
{
return
kind_
;
}
bool
isVariable
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Variable
;
}
bool
isConstant
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Constant
;
}
bool
isImport
(
)
const
{
return
kind_
=
=
GlobalKind
:
:
Import
;
}
bool
isMutable
(
)
const
{
return
!
isConstant
(
)
&
&
u
.
var
.
isMutable_
;
}
LitVal
constantValue
(
)
const
{
MOZ_ASSERT
(
isConstant
(
)
)
;
return
u
.
cst_
;
}
const
InitExpr
&
initExpr
(
)
const
{
MOZ_ASSERT
(
isVariable
(
)
)
;
return
u
.
var
.
val
.
initial_
;
}
uint32_t
importIndex
(
)
const
{
MOZ_ASSERT
(
isImport
(
)
)
;
return
u
.
var
.
val
.
import
.
index_
;
}
bool
isIndirect
(
)
const
{
return
isMutable
(
)
&
&
isWasm
(
)
&
&
(
isImport
(
)
|
|
isExport
(
)
)
;
}
ValType
type
(
)
const
{
switch
(
kind_
)
{
case
GlobalKind
:
:
Import
:
return
u
.
var
.
val
.
import
.
type_
;
case
GlobalKind
:
:
Variable
:
return
u
.
var
.
val
.
initial_
.
type
(
)
;
case
GlobalKind
:
:
Constant
:
return
u
.
cst_
.
type
(
)
;
}
MOZ_CRASH
(
"
unexpected
global
kind
"
)
;
}
}
;
typedef
Vector
<
GlobalDesc
0
SystemAllocPolicy
>
GlobalDescVector
;
struct
ElemSegment
{
uint32_t
tableIndex
;
InitExpr
offset
;
Uint32Vector
elemFuncIndices
;
Uint32Vector
elemCodeRangeIndices1_
;
mutable
Uint32Vector
elemCodeRangeIndices2_
;
ElemSegment
(
)
=
default
;
ElemSegment
(
uint32_t
tableIndex
InitExpr
offset
Uint32Vector
&
&
elemFuncIndices
)
:
tableIndex
(
tableIndex
)
offset
(
offset
)
elemFuncIndices
(
std
:
:
move
(
elemFuncIndices
)
)
{
}
Uint32Vector
&
elemCodeRangeIndices
(
Tier
t
)
{
switch
(
t
)
{
case
Tier
:
:
Baseline
:
return
elemCodeRangeIndices1_
;
case
Tier
:
:
Ion
:
return
elemCodeRangeIndices2_
;
default
:
MOZ_CRASH
(
"
No
such
tier
"
)
;
}
}
const
Uint32Vector
&
elemCodeRangeIndices
(
Tier
t
)
const
{
switch
(
t
)
{
case
Tier
:
:
Baseline
:
return
elemCodeRangeIndices1_
;
case
Tier
:
:
Ion
:
return
elemCodeRangeIndices2_
;
default
:
MOZ_CRASH
(
"
No
such
tier
"
)
;
}
}
void
setTier2
(
Uint32Vector
&
&
elemCodeRangeIndices
)
const
{
MOZ_ASSERT
(
elemCodeRangeIndices2_
.
length
(
)
=
=
0
)
;
elemCodeRangeIndices2_
=
std
:
:
move
(
elemCodeRangeIndices
)
;
}
WASM_DECLARE_SERIALIZABLE
(
ElemSegment
)
}
;
typedef
Vector
<
ElemSegment
0
SystemAllocPolicy
>
ElemSegmentVector
;
struct
DataSegment
{
InitExpr
offset
;
uint32_t
bytecodeOffset
;
uint32_t
length
;
}
;
typedef
Vector
<
DataSegment
0
SystemAllocPolicy
>
DataSegmentVector
;
class
FuncTypeIdDesc
{
public
:
enum
class
Kind
{
None
Immediate
Global
}
;
static
const
uintptr_t
ImmediateBit
=
0x1
;
private
:
Kind
kind_
;
size_t
bits_
;
FuncTypeIdDesc
(
Kind
kind
size_t
bits
)
:
kind_
(
kind
)
bits_
(
bits
)
{
}
public
:
Kind
kind
(
)
const
{
return
kind_
;
}
static
bool
isGlobal
(
const
FuncType
&
funcType
)
;
FuncTypeIdDesc
(
)
:
kind_
(
Kind
:
:
None
)
bits_
(
0
)
{
}
static
FuncTypeIdDesc
global
(
const
FuncType
&
funcType
uint32_t
globalDataOffset
)
;
static
FuncTypeIdDesc
immediate
(
const
FuncType
&
funcType
)
;
bool
isGlobal
(
)
const
{
return
kind_
=
=
Kind
:
:
Global
;
}
size_t
immediate
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
Kind
:
:
Immediate
)
;
return
bits_
;
}
uint32_t
globalDataOffset
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
Kind
:
:
Global
)
;
return
bits_
;
}
}
;
struct
FuncTypeWithId
:
FuncType
{
FuncTypeIdDesc
id
;
FuncTypeWithId
(
)
=
default
;
explicit
FuncTypeWithId
(
FuncType
&
&
funcType
)
:
FuncType
(
std
:
:
move
(
funcType
)
)
id
(
)
{
}
FuncTypeWithId
(
FuncType
&
&
funcType
FuncTypeIdDesc
id
)
:
FuncType
(
std
:
:
move
(
funcType
)
)
id
(
id
)
{
}
void
operator
=
(
FuncType
&
&
rhs
)
{
FuncType
:
:
operator
=
(
std
:
:
move
(
rhs
)
)
;
}
WASM_DECLARE_SERIALIZABLE
(
FuncTypeWithId
)
}
;
typedef
Vector
<
FuncTypeWithId
0
SystemAllocPolicy
>
FuncTypeWithIdVector
;
typedef
Vector
<
const
FuncTypeWithId
*
0
SystemAllocPolicy
>
FuncTypeWithIdPtrVector
;
class
TypeDef
{
enum
{
IsFuncType
IsStructType
IsNone
}
tag_
;
union
{
FuncTypeWithId
funcType_
;
StructType
structType_
;
}
;
public
:
TypeDef
(
)
:
tag_
(
IsNone
)
{
}
explicit
TypeDef
(
FuncType
&
&
funcType
)
:
tag_
(
IsFuncType
)
funcType_
(
FuncTypeWithId
(
std
:
:
move
(
funcType
)
)
)
{
}
explicit
TypeDef
(
StructType
&
&
structType
)
:
tag_
(
IsStructType
)
structType_
(
std
:
:
move
(
structType
)
)
{
}
TypeDef
(
TypeDef
&
&
td
)
:
tag_
(
td
.
tag_
)
{
switch
(
tag_
)
{
case
IsFuncType
:
new
(
&
funcType_
)
FuncTypeWithId
(
std
:
:
move
(
td
.
funcType_
)
)
;
break
;
case
IsStructType
:
new
(
&
structType_
)
StructType
(
std
:
:
move
(
td
.
structType_
)
)
;
break
;
case
IsNone
:
break
;
}
}
~
TypeDef
(
)
{
switch
(
tag_
)
{
case
IsFuncType
:
funcType_
.
~
FuncTypeWithId
(
)
;
break
;
case
IsStructType
:
structType_
.
~
StructType
(
)
;
break
;
case
IsNone
:
break
;
}
}
TypeDef
&
operator
=
(
TypeDef
&
&
that
)
{
MOZ_ASSERT
(
isNone
(
)
)
;
switch
(
that
.
tag_
)
{
case
IsFuncType
:
new
(
&
funcType_
)
FuncTypeWithId
(
std
:
:
move
(
that
.
funcType_
)
)
;
break
;
case
IsStructType
:
new
(
&
structType_
)
StructType
(
std
:
:
move
(
that
.
structType_
)
)
;
break
;
case
IsNone
:
break
;
}
tag_
=
that
.
tag_
;
return
*
this
;
}
bool
isFuncType
(
)
const
{
return
tag_
=
=
IsFuncType
;
}
bool
isNone
(
)
const
{
return
tag_
=
=
IsNone
;
}
bool
isStructType
(
)
const
{
return
tag_
=
=
IsStructType
;
}
const
FuncTypeWithId
&
funcType
(
)
const
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
FuncTypeWithId
&
funcType
(
)
{
MOZ_ASSERT
(
isFuncType
(
)
)
;
return
funcType_
;
}
static
const
TypeDef
*
fromFuncTypeWithIdPtr
(
const
FuncTypeWithId
*
p
)
{
const
TypeDef
*
q
=
(
const
TypeDef
*
)
(
(
char
*
)
p
-
offsetof
(
TypeDef
funcType_
)
)
;
MOZ_ASSERT
(
q
-
>
tag_
=
=
IsFuncType
)
;
return
q
;
}
const
StructType
&
structType
(
)
const
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
StructType
&
structType
(
)
{
MOZ_ASSERT
(
isStructType
(
)
)
;
return
structType_
;
}
static
const
TypeDef
*
fromStructPtr
(
const
StructType
*
p
)
{
const
TypeDef
*
q
=
(
const
TypeDef
*
)
(
(
char
*
)
p
-
offsetof
(
TypeDef
structType_
)
)
;
MOZ_ASSERT
(
q
-
>
tag_
=
=
IsStructType
)
;
return
q
;
}
}
;
typedef
Vector
<
TypeDef
0
SystemAllocPolicy
>
TypeDefVector
;
enum
class
Trap
{
Unreachable
IntegerOverflow
InvalidConversionToInteger
IntegerDivideByZero
OutOfBounds
UnalignedAccess
IndirectCallToNull
IndirectCallBadSig
StackOverflow
CheckInterrupt
ThrowReported
Limit
}
;
class
BytecodeOffset
{
static
const
uint32_t
INVALID
=
-
1
;
uint32_t
offset_
;
public
:
BytecodeOffset
(
)
:
offset_
(
INVALID
)
{
}
explicit
BytecodeOffset
(
uint32_t
offset
)
:
offset_
(
offset
)
{
}
bool
isValid
(
)
const
{
return
offset_
!
=
INVALID
;
}
uint32_t
offset
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
offset_
;
}
}
;
struct
TrapSite
{
uint32_t
pcOffset
;
BytecodeOffset
bytecode
;
TrapSite
(
)
:
pcOffset
(
-
1
)
bytecode
(
)
{
}
TrapSite
(
uint32_t
pcOffset
BytecodeOffset
bytecode
)
:
pcOffset
(
pcOffset
)
bytecode
(
bytecode
)
{
}
void
offsetBy
(
uint32_t
offset
)
{
pcOffset
+
=
offset
;
}
}
;
WASM_DECLARE_POD_VECTOR
(
TrapSite
TrapSiteVector
)
struct
TrapSiteVectorArray
:
EnumeratedArray
<
Trap
Trap
:
:
Limit
TrapSiteVector
>
{
bool
empty
(
)
const
;
void
clear
(
)
;
void
swap
(
TrapSiteVectorArray
&
rhs
)
;
void
podResizeToFit
(
)
;
WASM_DECLARE_SERIALIZABLE
(
TrapSiteVectorArray
)
}
;
struct
Offsets
{
explicit
Offsets
(
uint32_t
begin
=
0
uint32_t
end
=
0
)
:
begin
(
begin
)
end
(
end
)
{
}
uint32_t
begin
;
uint32_t
end
;
}
;
struct
CallableOffsets
:
Offsets
{
MOZ_IMPLICIT
CallableOffsets
(
uint32_t
ret
=
0
)
:
Offsets
(
)
ret
(
ret
)
{
}
uint32_t
ret
;
}
;
struct
JitExitOffsets
:
CallableOffsets
{
MOZ_IMPLICIT
JitExitOffsets
(
)
:
CallableOffsets
(
)
untrustedFPStart
(
0
)
untrustedFPEnd
(
0
)
{
}
uint32_t
untrustedFPStart
;
uint32_t
untrustedFPEnd
;
}
;
struct
FuncOffsets
:
CallableOffsets
{
MOZ_IMPLICIT
FuncOffsets
(
)
:
CallableOffsets
(
)
normalEntry
(
0
)
tierEntry
(
0
)
{
}
uint32_t
normalEntry
;
uint32_t
tierEntry
;
}
;
typedef
Vector
<
FuncOffsets
0
SystemAllocPolicy
>
FuncOffsetsVector
;
class
CodeRange
{
public
:
enum
Kind
{
Function
InterpEntry
JitEntry
ImportInterpExit
ImportJitExit
BuiltinThunk
TrapExit
DebugTrap
FarJumpIsland
OutOfBoundsExit
UnalignedExit
Throw
}
;
private
:
uint32_t
begin_
;
uint32_t
ret_
;
uint32_t
end_
;
union
{
struct
{
uint32_t
funcIndex_
;
union
{
struct
{
uint32_t
lineOrBytecode_
;
uint8_t
beginToNormalEntry_
;
uint8_t
beginToTierEntry_
;
}
func
;
struct
{
uint16_t
beginToUntrustedFPStart_
;
uint16_t
beginToUntrustedFPEnd_
;
}
jitExit
;
}
;
}
;
Trap
trap_
;
}
u
;
Kind
kind_
:
8
;
public
:
CodeRange
(
)
=
default
;
CodeRange
(
Kind
kind
Offsets
offsets
)
;
CodeRange
(
Kind
kind
uint32_t
funcIndex
Offsets
offsets
)
;
CodeRange
(
Kind
kind
CallableOffsets
offsets
)
;
CodeRange
(
Kind
kind
uint32_t
funcIndex
CallableOffsets
)
;
CodeRange
(
uint32_t
funcIndex
JitExitOffsets
offsets
)
;
CodeRange
(
uint32_t
funcIndex
uint32_t
lineOrBytecode
FuncOffsets
offsets
)
;
void
offsetBy
(
uint32_t
offset
)
{
begin_
+
=
offset
;
end_
+
=
offset
;
if
(
hasReturn
(
)
)
ret_
+
=
offset
;
}
uint32_t
begin
(
)
const
{
return
begin_
;
}
uint32_t
end
(
)
const
{
return
end_
;
}
Kind
kind
(
)
const
{
return
kind_
;
}
bool
isFunction
(
)
const
{
return
kind
(
)
=
=
Function
;
}
bool
isImportExit
(
)
const
{
return
kind
(
)
=
=
ImportJitExit
|
|
kind
(
)
=
=
ImportInterpExit
|
|
kind
(
)
=
=
BuiltinThunk
;
}
bool
isImportInterpExit
(
)
const
{
return
kind
(
)
=
=
ImportInterpExit
;
}
bool
isImportJitExit
(
)
const
{
return
kind
(
)
=
=
ImportJitExit
;
}
bool
isTrapExit
(
)
const
{
return
kind
(
)
=
=
TrapExit
;
}
bool
isDebugTrap
(
)
const
{
return
kind
(
)
=
=
DebugTrap
;
}
bool
isThunk
(
)
const
{
return
kind
(
)
=
=
FarJumpIsland
;
}
bool
hasReturn
(
)
const
{
return
isFunction
(
)
|
|
isImportExit
(
)
|
|
isDebugTrap
(
)
;
}
uint32_t
ret
(
)
const
{
MOZ_ASSERT
(
hasReturn
(
)
)
;
return
ret_
;
}
bool
isJitEntry
(
)
const
{
return
kind
(
)
=
=
JitEntry
;
}
bool
isInterpEntry
(
)
const
{
return
kind
(
)
=
=
InterpEntry
;
}
bool
isEntry
(
)
const
{
return
isInterpEntry
(
)
|
|
isJitEntry
(
)
;
}
bool
hasFuncIndex
(
)
const
{
return
isFunction
(
)
|
|
isImportExit
(
)
|
|
isEntry
(
)
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
hasFuncIndex
(
)
)
;
return
u
.
funcIndex_
;
}
Trap
trap
(
)
const
{
MOZ_ASSERT
(
isTrapExit
(
)
)
;
return
u
.
trap_
;
}
uint32_t
funcTableEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
;
}
uint32_t
funcNormalEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
u
.
func
.
beginToNormalEntry_
;
}
uint32_t
funcTierEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
u
.
func
.
beginToTierEntry_
;
}
uint32_t
funcLineOrBytecode
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
u
.
func
.
lineOrBytecode_
;
}
uint32_t
jitExitUntrustedFPStart
(
)
const
{
MOZ_ASSERT
(
isImportJitExit
(
)
)
;
return
begin_
+
u
.
jitExit
.
beginToUntrustedFPStart_
;
}
uint32_t
jitExitUntrustedFPEnd
(
)
const
{
MOZ_ASSERT
(
isImportJitExit
(
)
)
;
return
begin_
+
u
.
jitExit
.
beginToUntrustedFPEnd_
;
}
struct
OffsetInCode
{
size_t
offset
;
explicit
OffsetInCode
(
size_t
offset
)
:
offset
(
offset
)
{
}
bool
operator
=
=
(
const
CodeRange
&
rhs
)
const
{
return
offset
>
=
rhs
.
begin
(
)
&
&
offset
<
rhs
.
end
(
)
;
}
bool
operator
<
(
const
CodeRange
&
rhs
)
const
{
return
offset
<
rhs
.
begin
(
)
;
}
}
;
}
;
WASM_DECLARE_POD_VECTOR
(
CodeRange
CodeRangeVector
)
extern
const
CodeRange
*
LookupInSorted
(
const
CodeRangeVector
&
codeRanges
CodeRange
:
:
OffsetInCode
target
)
;
class
CallSiteDesc
{
uint32_t
lineOrBytecode_
:
29
;
uint32_t
kind_
:
3
;
public
:
enum
Kind
{
Func
Dynamic
Symbolic
EnterFrame
LeaveFrame
Breakpoint
}
;
CallSiteDesc
(
)
:
lineOrBytecode_
(
0
)
kind_
(
0
)
{
}
explicit
CallSiteDesc
(
Kind
kind
)
:
lineOrBytecode_
(
0
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
=
=
Kind
(
kind_
)
)
;
}
CallSiteDesc
(
uint32_t
lineOrBytecode
Kind
kind
)
:
lineOrBytecode_
(
lineOrBytecode
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
=
=
Kind
(
kind_
)
)
;
MOZ_ASSERT
(
lineOrBytecode
=
=
lineOrBytecode_
)
;
}
uint32_t
lineOrBytecode
(
)
const
{
return
lineOrBytecode_
;
}
Kind
kind
(
)
const
{
return
Kind
(
kind_
)
;
}
}
;
class
CallSite
:
public
CallSiteDesc
{
uint32_t
returnAddressOffset_
;
public
:
CallSite
(
)
:
returnAddressOffset_
(
0
)
{
}
CallSite
(
CallSiteDesc
desc
uint32_t
returnAddressOffset
)
:
CallSiteDesc
(
desc
)
returnAddressOffset_
(
returnAddressOffset
)
{
}
void
offsetBy
(
int32_t
delta
)
{
returnAddressOffset_
+
=
delta
;
}
uint32_t
returnAddressOffset
(
)
const
{
return
returnAddressOffset_
;
}
}
;
WASM_DECLARE_POD_VECTOR
(
CallSite
CallSiteVector
)
class
CallSiteTarget
{
uint32_t
packed_
;
#
ifdef
DEBUG
enum
Kind
{
None
FuncIndex
TrapExit
}
kind_
;
#
endif
public
:
explicit
CallSiteTarget
(
)
:
packed_
(
UINT32_MAX
)
#
ifdef
DEBUG
kind_
(
None
)
#
endif
{
}
explicit
CallSiteTarget
(
uint32_t
funcIndex
)
:
packed_
(
funcIndex
)
#
ifdef
DEBUG
kind_
(
FuncIndex
)
#
endif
{
}
explicit
CallSiteTarget
(
Trap
trap
)
:
packed_
(
uint32_t
(
trap
)
)
#
ifdef
DEBUG
kind_
(
TrapExit
)
#
endif
{
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
FuncIndex
)
;
return
packed_
;
}
Trap
trap
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
TrapExit
)
;
MOZ_ASSERT
(
packed_
<
uint32_t
(
Trap
:
:
Limit
)
)
;
return
Trap
(
packed_
)
;
}
}
;
typedef
Vector
<
CallSiteTarget
0
SystemAllocPolicy
>
CallSiteTargetVector
;
enum
class
SymbolicAddress
{
ToInt32
#
if
defined
(
JS_CODEGEN_ARM
)
aeabi_idivmod
aeabi_uidivmod
#
endif
ModD
SinD
CosD
TanD
ASinD
ACosD
ATanD
CeilD
CeilF
FloorD
FloorF
TruncD
TruncF
NearbyIntD
NearbyIntF
ExpD
LogD
PowD
ATan2D
HandleDebugTrap
HandleThrow
HandleTrap
ReportOutOfBounds
ReportUnalignedAccess
ReportInt64JSCall
CallImport_Void
CallImport_I32
CallImport_I64
CallImport_F64
CallImport_Ref
CoerceInPlace_ToInt32
CoerceInPlace_ToNumber
CoerceInPlace_JitEntry
DivI64
UDivI64
ModI64
UModI64
TruncateDoubleToInt64
TruncateDoubleToUint64
SaturatingTruncateDoubleToInt64
SaturatingTruncateDoubleToUint64
Uint64ToFloat32
Uint64ToDouble
Int64ToFloat32
Int64ToDouble
GrowMemory
CurrentMemory
WaitI32
WaitI64
Wake
MemCopy
MemFill
#
ifdef
ENABLE_WASM_GC
PostBarrier
#
endif
#
if
defined
(
JS_CODEGEN_MIPS32
)
js_jit_gAtomic64Lock
#
endif
Limit
}
;
bool
IsRoundingFunction
(
SymbolicAddress
callee
jit
:
:
RoundingMode
*
mode
)
;
struct
Assumptions
{
uint32_t
cpuId
;
JS
:
:
BuildIdCharVector
buildId
;
explicit
Assumptions
(
JS
:
:
BuildIdCharVector
&
&
buildId
)
;
Assumptions
(
)
;
bool
initBuildIdFromContext
(
JSContext
*
cx
)
;
bool
clone
(
const
Assumptions
&
other
)
;
bool
operator
=
=
(
const
Assumptions
&
rhs
)
const
;
bool
operator
!
=
(
const
Assumptions
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
size_t
serializedSize
(
)
const
;
uint8_t
*
serialize
(
uint8_t
*
cursor
)
const
;
const
uint8_t
*
deserialize
(
const
uint8_t
*
cursor
size_t
remain
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
struct
Limits
{
uint32_t
initial
;
Maybe
<
uint32_t
>
maximum
;
Shareable
shared
;
Limits
(
)
=
default
;
explicit
Limits
(
uint32_t
initial
const
Maybe
<
uint32_t
>
&
maximum
=
Nothing
(
)
Shareable
shared
=
Shareable
:
:
False
)
:
initial
(
initial
)
maximum
(
maximum
)
shared
(
shared
)
{
}
}
;
enum
class
TableKind
{
AnyFunction
TypedFunction
}
;
struct
TableDesc
{
TableKind
kind
;
bool
external
;
uint32_t
globalDataOffset
;
Limits
limits
;
TableDesc
(
)
=
default
;
TableDesc
(
TableKind
kind
const
Limits
&
limits
)
:
kind
(
kind
)
external
(
false
)
globalDataOffset
(
UINT32_MAX
)
limits
(
limits
)
{
}
}
;
typedef
Vector
<
TableDesc
0
SystemAllocPolicy
>
TableDescVector
;
struct
TlsData
{
uint8_t
*
memoryBase
;
#
ifndef
WASM_HUGE_MEMORY
uint32_t
boundsCheckLimit
;
#
endif
Instance
*
instance
;
JS
:
:
Realm
*
realm
;
JSContext
*
cx
;
Atomic
<
uintptr_t
mozilla
:
:
Relaxed
>
stackLimit
;
Atomic
<
uint32_t
mozilla
:
:
Relaxed
>
interrupt
;
#
ifdef
ENABLE_WASM_GC
uint8_t
*
addressOfNeedsIncrementalBarrier
;
#
endif
void
setInterrupt
(
)
;
bool
isInterrupted
(
)
const
;
void
resetInterrupt
(
JSContext
*
cx
)
;
void
*
allocatedBase
;
void
*
*
jumpTable
;
MOZ_ALIGNED_DECL
(
char
globalArea
16
)
;
}
;
static
const
size_t
TlsDataAlign
=
16
;
static_assert
(
offsetof
(
TlsData
globalArea
)
%
TlsDataAlign
=
=
0
"
aligned
"
)
;
struct
TlsDataDeleter
{
void
operator
(
)
(
TlsData
*
tlsData
)
{
js_free
(
tlsData
-
>
allocatedBase
)
;
}
}
;
typedef
UniquePtr
<
TlsData
TlsDataDeleter
>
UniqueTlsData
;
extern
UniqueTlsData
CreateTlsData
(
uint32_t
globalDataLength
)
;
struct
ExportArg
{
uint64_t
lo
;
uint64_t
hi
;
}
;
typedef
int32_t
(
*
ExportFuncPtr
)
(
ExportArg
*
args
TlsData
*
tls
)
;
struct
FuncImportTls
{
void
*
code
;
TlsData
*
tls
;
JS
:
:
Realm
*
realm
;
jit
:
:
BaselineScript
*
baselineScript
;
GCPtrObject
obj
;
static_assert
(
sizeof
(
GCPtrObject
)
=
=
sizeof
(
void
*
)
"
for
JIT
access
"
)
;
}
;
struct
TableTls
{
uint32_t
length
;
void
*
base
;
}
;
struct
ExternalTableElem
{
void
*
code
;
TlsData
*
tls
;
}
;
class
CalleeDesc
{
public
:
enum
Which
{
Func
Import
WasmTable
AsmJSTable
Builtin
BuiltinInstanceMethod
}
;
private
:
MOZ_INIT_OUTSIDE_CTOR
Which
which_
;
union
U
{
U
(
)
:
funcIndex_
(
0
)
{
}
uint32_t
funcIndex_
;
struct
{
uint32_t
globalDataOffset_
;
}
import
;
struct
{
uint32_t
globalDataOffset_
;
uint32_t
minLength_
;
bool
external_
;
FuncTypeIdDesc
funcTypeId_
;
}
table
;
SymbolicAddress
builtin_
;
}
u
;
public
:
CalleeDesc
(
)
{
}
static
CalleeDesc
function
(
uint32_t
funcIndex
)
{
CalleeDesc
c
;
c
.
which_
=
Func
;
c
.
u
.
funcIndex_
=
funcIndex
;
return
c
;
}
static
CalleeDesc
import
(
uint32_t
globalDataOffset
)
{
CalleeDesc
c
;
c
.
which_
=
Import
;
c
.
u
.
import
.
globalDataOffset_
=
globalDataOffset
;
return
c
;
}
static
CalleeDesc
wasmTable
(
const
TableDesc
&
desc
FuncTypeIdDesc
funcTypeId
)
{
CalleeDesc
c
;
c
.
which_
=
WasmTable
;
c
.
u
.
table
.
globalDataOffset_
=
desc
.
globalDataOffset
;
c
.
u
.
table
.
minLength_
=
desc
.
limits
.
initial
;
c
.
u
.
table
.
external_
=
desc
.
external
;
c
.
u
.
table
.
funcTypeId_
=
funcTypeId
;
return
c
;
}
static
CalleeDesc
asmJSTable
(
const
TableDesc
&
desc
)
{
CalleeDesc
c
;
c
.
which_
=
AsmJSTable
;
c
.
u
.
table
.
globalDataOffset_
=
desc
.
globalDataOffset
;
return
c
;
}
static
CalleeDesc
builtin
(
SymbolicAddress
callee
)
{
CalleeDesc
c
;
c
.
which_
=
Builtin
;
c
.
u
.
builtin_
=
callee
;
return
c
;
}
static
CalleeDesc
builtinInstanceMethod
(
SymbolicAddress
callee
)
{
CalleeDesc
c
;
c
.
which_
=
BuiltinInstanceMethod
;
c
.
u
.
builtin_
=
callee
;
return
c
;
}
Which
which
(
)
const
{
return
which_
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Func
)
;
return
u
.
funcIndex_
;
}
uint32_t
importGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Import
)
;
return
u
.
import
.
globalDataOffset_
;
}
bool
isTable
(
)
const
{
return
which_
=
=
WasmTable
|
|
which_
=
=
AsmJSTable
;
}
uint32_t
tableLengthGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
isTable
(
)
)
;
return
u
.
table
.
globalDataOffset_
+
offsetof
(
TableTls
length
)
;
}
uint32_t
tableBaseGlobalDataOffset
(
)
const
{
MOZ_ASSERT
(
isTable
(
)
)
;
return
u
.
table
.
globalDataOffset_
+
offsetof
(
TableTls
base
)
;
}
bool
wasmTableIsExternal
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
external_
;
}
FuncTypeIdDesc
wasmTableSigId
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
funcTypeId_
;
}
uint32_t
wasmTableMinLength
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
minLength_
;
}
SymbolicAddress
builtin
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Builtin
|
|
which_
=
=
BuiltinInstanceMethod
)
;
return
u
.
builtin_
;
}
}
;
extern
bool
IsValidARMImmediate
(
uint32_t
i
)
;
extern
uint32_t
RoundUpToNextValidARMImmediate
(
uint32_t
i
)
;
static
const
unsigned
PageSize
=
64
*
1024
;
static
const
unsigned
MaxMemoryAccessSize
=
LitVal
:
:
sizeofLargestValue
(
)
;
#
ifdef
WASM_HUGE_MEMORY
static
const
uint64_t
IndexRange
=
uint64_t
(
UINT32_MAX
)
+
1
;
static
const
uint64_t
OffsetGuardLimit
=
uint64_t
(
INT32_MAX
)
+
1
;
static
const
uint64_t
UnalignedGuardPage
=
PageSize
;
static
const
uint64_t
HugeMappedSize
=
IndexRange
+
OffsetGuardLimit
+
UnalignedGuardPage
;
static_assert
(
MaxMemoryAccessSize
<
=
UnalignedGuardPage
"
rounded
up
to
static
page
size
"
)
;
#
else
static
const
size_t
OffsetGuardLimit
=
PageSize
-
MaxMemoryAccessSize
;
static
const
size_t
GuardSize
=
PageSize
;
extern
bool
IsValidBoundsCheckImmediate
(
uint32_t
i
)
;
extern
size_t
ComputeMappedSize
(
uint32_t
maxSize
)
;
#
endif
struct
Frame
{
Frame
*
callerFP
;
TlsData
*
tls
;
#
if
defined
(
JS_CODEGEN_MIPS32
)
|
|
defined
(
JS_CODEGEN_ARM64
)
uintptr_t
padding_
;
#
endif
void
*
returnAddress
;
Instance
*
instance
(
)
const
{
return
tls
-
>
instance
;
}
}
;
#
if
defined
(
JS_CODEGEN_ARM64
)
static_assert
(
sizeof
(
Frame
)
%
16
=
=
0
"
frame
size
"
)
;
#
endif
class
DebugFrame
{
union
{
int32_t
resultI32_
;
int64_t
resultI64_
;
intptr_t
resultRef_
;
float
resultF32_
;
double
resultF64_
;
}
;
js
:
:
Value
cachedReturnJSValue_
;
uint32_t
funcIndex_
;
union
{
struct
{
bool
observing_
:
1
;
bool
isDebuggee_
:
1
;
bool
prevUpToDate_
:
1
;
bool
hasCachedSavedFrame_
:
1
;
bool
hasCachedReturnJSValue_
:
1
;
}
;
void
*
flagsWord_
;
}
;
protected
:
#
if
JS_BITS_PER_WORD
=
=
32
&
&
!
defined
(
JS_CODEGEN_MIPS32
)
uint32_t
padding_
;
#
endif
private
:
Frame
frame_
;
public
:
static
DebugFrame
*
from
(
Frame
*
fp
)
;
Frame
&
frame
(
)
{
return
frame_
;
}
uint32_t
funcIndex
(
)
const
{
return
funcIndex_
;
}
Instance
*
instance
(
)
const
{
return
frame_
.
instance
(
)
;
}
GlobalObject
*
global
(
)
const
;
JSObject
*
environmentChain
(
)
const
;
bool
getLocal
(
uint32_t
localIndex
MutableHandleValue
vp
)
;
void
updateReturnJSValue
(
)
;
HandleValue
returnValue
(
)
const
;
void
clearReturnJSValue
(
)
;
void
observe
(
JSContext
*
cx
)
;
void
leave
(
JSContext
*
cx
)
;
bool
isDebuggee
(
)
const
{
return
isDebuggee_
;
}
void
setIsDebuggee
(
)
{
isDebuggee_
=
true
;
}
void
unsetIsDebuggee
(
)
{
isDebuggee_
=
false
;
}
bool
prevUpToDate
(
)
const
{
return
prevUpToDate_
;
}
void
setPrevUpToDate
(
)
{
prevUpToDate_
=
true
;
}
void
unsetPrevUpToDate
(
)
{
prevUpToDate_
=
false
;
}
bool
hasCachedSavedFrame
(
)
const
{
return
hasCachedSavedFrame_
;
}
void
setHasCachedSavedFrame
(
)
{
hasCachedSavedFrame_
=
true
;
}
void
clearHasCachedSavedFrame
(
)
{
hasCachedSavedFrame_
=
false
;
}
static
constexpr
size_t
offsetOfResults
(
)
{
return
offsetof
(
DebugFrame
resultI32_
)
;
}
static
constexpr
size_t
offsetOfFlagsWord
(
)
{
return
offsetof
(
DebugFrame
flagsWord_
)
;
}
static
constexpr
size_t
offsetOfFuncIndex
(
)
{
return
offsetof
(
DebugFrame
funcIndex_
)
;
}
static
constexpr
size_t
offsetOfFrame
(
)
{
return
offsetof
(
DebugFrame
frame_
)
;
}
static
const
unsigned
Alignment
=
8
;
static
void
alignmentStaticAsserts
(
)
;
}
;
}
}
#
endif
