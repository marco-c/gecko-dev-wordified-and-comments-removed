#
include
"
wasm
/
WasmGC
.
h
"
#
include
"
wasm
/
WasmInstance
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
using
mozilla
:
:
DebugOnly
;
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
wasm
:
:
StackMap
*
wasm
:
:
ConvertStackMapBoolVectorToStackMap
(
const
StackMapBoolVector
&
vec
bool
hasRefs
)
{
wasm
:
:
StackMap
*
stackMap
=
wasm
:
:
StackMap
:
:
create
(
vec
.
length
(
)
)
;
if
(
!
stackMap
)
{
return
nullptr
;
}
bool
hasRefsObserved
=
false
;
size_t
i
=
0
;
for
(
bool
b
:
vec
)
{
if
(
b
)
{
stackMap
-
>
setBit
(
i
)
;
hasRefsObserved
=
true
;
}
i
+
+
;
}
MOZ_RELEASE_ASSERT
(
hasRefs
=
=
hasRefsObserved
)
;
return
stackMap
;
}
bool
wasm
:
:
CreateStackMapForFunctionEntryTrap
(
const
wasm
:
:
ArgTypeVector
&
argTypes
const
RegisterOffsets
&
trapExitLayout
size_t
trapExitLayoutWords
size_t
nBytesReservedBeforeTrap
size_t
nInboundStackArgBytes
wasm
:
:
StackMap
*
*
result
)
{
*
result
=
nullptr
;
const
size_t
nFrameBytes
=
sizeof
(
wasm
:
:
Frame
)
;
const
size_t
trapExitLayoutBytes
=
trapExitLayoutWords
*
sizeof
(
void
*
)
;
const
DebugOnly
<
size_t
>
nTotalBytes
=
trapExitLayoutBytes
+
nBytesReservedBeforeTrap
+
nFrameBytes
+
nInboundStackArgBytes
;
StackMapBoolVector
vec
;
bool
hasRefs
=
false
;
wasm
:
:
ExitStubMapVector
trapExitExtras
;
if
(
!
GenerateStackmapEntriesForTrapExit
(
argTypes
trapExitLayout
trapExitLayoutWords
&
trapExitExtras
)
)
{
return
false
;
}
MOZ_ASSERT
(
trapExitExtras
.
length
(
)
=
=
trapExitLayoutWords
)
;
if
(
!
vec
.
appendN
(
false
trapExitLayoutWords
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
trapExitLayoutWords
;
i
+
+
)
{
vec
[
i
]
=
trapExitExtras
[
i
]
;
hasRefs
|
=
vec
[
i
]
;
}
MOZ_ASSERT
(
nBytesReservedBeforeTrap
%
sizeof
(
void
*
)
=
=
0
)
;
if
(
!
vec
.
appendN
(
false
nBytesReservedBeforeTrap
/
sizeof
(
void
*
)
)
)
{
return
false
;
}
if
(
!
vec
.
appendN
(
false
nFrameBytes
/
sizeof
(
void
*
)
)
)
{
return
false
;
}
MOZ_ASSERT
(
nInboundStackArgBytes
%
sizeof
(
void
*
)
=
=
0
)
;
const
size_t
numStackArgWords
=
nInboundStackArgBytes
/
sizeof
(
void
*
)
;
const
size_t
wordsSoFar
=
vec
.
length
(
)
;
if
(
!
vec
.
appendN
(
false
numStackArgWords
)
)
{
return
false
;
}
for
(
WasmABIArgIter
i
(
argTypes
)
;
!
i
.
done
(
)
;
i
+
+
)
{
ABIArg
argLoc
=
*
i
;
if
(
argLoc
.
kind
(
)
=
=
ABIArg
:
:
Stack
&
&
argTypes
[
i
.
index
(
)
]
=
=
MIRType
:
:
WasmAnyRef
)
{
uint32_t
offset
=
argLoc
.
offsetFromArgBase
(
)
;
MOZ_ASSERT
(
offset
<
nInboundStackArgBytes
)
;
MOZ_ASSERT
(
offset
%
sizeof
(
void
*
)
=
=
0
)
;
vec
[
wordsSoFar
+
offset
/
sizeof
(
void
*
)
]
=
true
;
hasRefs
=
true
;
}
}
#
ifndef
DEBUG
if
(
!
hasRefs
)
{
return
true
;
}
#
endif
MOZ_ASSERT
(
vec
.
length
(
)
*
sizeof
(
void
*
)
=
=
nTotalBytes
)
;
wasm
:
:
StackMap
*
stackMap
=
ConvertStackMapBoolVectorToStackMap
(
vec
hasRefs
)
;
if
(
!
stackMap
)
{
return
false
;
}
stackMap
-
>
setExitStubWords
(
trapExitLayoutWords
)
;
stackMap
-
>
setFrameOffsetFromTop
(
nFrameBytes
/
sizeof
(
void
*
)
+
numStackArgWords
)
;
#
ifdef
DEBUG
for
(
uint32_t
i
=
0
;
i
<
nFrameBytes
/
sizeof
(
void
*
)
;
i
+
+
)
{
MOZ_ASSERT
(
stackMap
-
>
getBit
(
stackMap
-
>
header
.
numMappedWords
-
stackMap
-
>
header
.
frameOffsetFromTop
+
i
)
=
=
0
)
;
}
#
endif
*
result
=
stackMap
;
return
true
;
}
bool
wasm
:
:
GenerateStackmapEntriesForTrapExit
(
const
ArgTypeVector
&
args
const
RegisterOffsets
&
trapExitLayout
const
size_t
trapExitLayoutNumWords
ExitStubMapVector
*
extras
)
{
MOZ_ASSERT
(
extras
-
>
empty
(
)
)
;
if
(
!
extras
-
>
appendN
(
false
trapExitLayoutNumWords
)
)
{
return
false
;
}
for
(
WasmABIArgIter
i
(
args
)
;
!
i
.
done
(
)
;
i
+
+
)
{
if
(
!
i
-
>
argInRegister
(
)
|
|
i
.
mirType
(
)
!
=
MIRType
:
:
WasmAnyRef
)
{
continue
;
}
size_t
offsetFromTop
=
trapExitLayout
.
getOffset
(
i
-
>
gpr
(
)
)
;
MOZ_RELEASE_ASSERT
(
offsetFromTop
<
trapExitLayoutNumWords
)
;
size_t
offsetFromBottom
=
trapExitLayoutNumWords
-
1
-
offsetFromTop
;
(
*
extras
)
[
offsetFromBottom
]
=
true
;
}
return
true
;
}
void
wasm
:
:
EmitWasmPreBarrierGuard
(
MacroAssembler
&
masm
Register
instance
Register
scratch
Register
valueAddr
size_t
valueOffset
Label
*
skipBarrier
BytecodeOffset
*
trapOffset
)
{
masm
.
loadPtr
(
Address
(
instance
Instance
:
:
offsetOfAddressOfNeedsIncrementalBarrier
(
)
)
scratch
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
Address
(
scratch
0
)
Imm32
(
0x1
)
skipBarrier
)
;
if
(
trapOffset
)
{
masm
.
append
(
wasm
:
:
Trap
:
:
NullPointerDereference
wasm
:
:
TrapSite
(
masm
.
currentOffset
(
)
*
trapOffset
)
)
;
}
masm
.
loadPtr
(
Address
(
valueAddr
valueOffset
)
scratch
)
;
masm
.
branchTestPtr
(
Assembler
:
:
Zero
scratch
scratch
skipBarrier
)
;
}
void
wasm
:
:
EmitWasmPreBarrierCall
(
MacroAssembler
&
masm
Register
instance
Register
scratch
Register
valueAddr
size_t
valueOffset
)
{
MOZ_ASSERT
(
valueAddr
=
=
PreBarrierReg
)
;
if
(
valueOffset
!
=
0
)
{
masm
.
addPtr
(
Imm32
(
valueOffset
)
valueAddr
)
;
}
#
if
defined
(
DEBUG
)
&
&
defined
(
JS_CODEGEN_ARM64
)
Label
ok
;
masm
.
Cmp
(
sp
vixl
:
:
Operand
(
x28
)
)
;
masm
.
B
(
&
ok
Assembler
:
:
Equal
)
;
masm
.
breakpoint
(
)
;
masm
.
bind
(
&
ok
)
;
#
endif
masm
.
loadPtr
(
Address
(
instance
Instance
:
:
offsetOfPreBarrierCode
(
)
)
scratch
)
;
masm
.
call
(
scratch
)
;
if
(
valueOffset
!
=
0
)
{
masm
.
subPtr
(
Imm32
(
valueOffset
)
valueAddr
)
;
}
}
void
wasm
:
:
EmitWasmPostBarrierGuard
(
MacroAssembler
&
masm
const
Maybe
<
Register
>
&
object
Register
otherScratch
Register
setValue
Label
*
skipBarrier
)
{
masm
.
branchTestPtr
(
Assembler
:
:
Zero
setValue
setValue
skipBarrier
)
;
if
(
object
)
{
masm
.
branchPtrInNurseryChunk
(
Assembler
:
:
Equal
*
object
otherScratch
skipBarrier
)
;
}
masm
.
branchPtrInNurseryChunk
(
Assembler
:
:
NotEqual
setValue
otherScratch
skipBarrier
)
;
}
#
ifdef
DEBUG
bool
wasm
:
:
IsValidStackMapKey
(
bool
debugEnabled
const
uint8_t
*
nextPC
)
{
#
if
defined
(
JS_CODEGEN_X64
)
|
|
defined
(
JS_CODEGEN_X86
)
const
uint8_t
*
insn
=
nextPC
;
return
(
insn
[
-
2
]
=
=
0x0F
&
&
insn
[
-
1
]
=
=
0x0B
)
|
|
(
insn
[
-
2
]
=
=
0xFF
&
&
(
insn
[
-
1
]
&
0xF8
)
=
=
0xD0
)
|
|
insn
[
-
5
]
=
=
0xE8
;
#
elif
defined
(
JS_CODEGEN_ARM
)
const
uint32_t
*
insn
=
(
const
uint32_t
*
)
nextPC
;
return
(
(
uintptr_t
(
insn
)
&
3
)
=
=
0
)
&
&
(
insn
[
-
1
]
=
=
0xe7f000f0
|
|
(
insn
[
-
1
]
&
0xfffffff0
)
=
=
0xe12fff30
|
|
(
insn
[
-
1
]
&
0x0f000000
)
=
=
0x0b000000
)
;
#
elif
defined
(
JS_CODEGEN_ARM64
)
const
uint32_t
hltInsn
=
0xd4a00000
;
const
uint32_t
*
insn
=
(
const
uint32_t
*
)
nextPC
;
return
(
(
uintptr_t
(
insn
)
&
3
)
=
=
0
)
&
&
(
insn
[
-
1
]
=
=
hltInsn
|
|
(
insn
[
-
1
]
&
0xfffffc1f
)
=
=
0xd63f0000
|
|
(
insn
[
-
1
]
&
0xfc000000
)
=
=
0x94000000
)
;
#
elif
defined
(
JS_CODEGEN_MIPS64
)
return
true
;
#
elif
defined
(
JS_CODEGEN_LOONG64
)
return
true
;
#
elif
defined
(
JS_CODEGEN_RISCV64
)
const
uint32_t
*
insn
=
(
const
uint32_t
*
)
nextPC
;
return
(
(
(
uintptr_t
(
insn
)
&
3
)
=
=
0
)
&
&
(
(
insn
[
-
1
]
=
=
0x00006037
&
&
insn
[
-
2
]
=
=
0x00100073
)
|
|
(
(
insn
[
-
1
]
&
kBaseOpcodeMask
)
=
=
JALR
)
|
|
(
(
insn
[
-
1
]
&
kBaseOpcodeMask
)
=
=
JAL
)
|
|
(
insn
[
-
1
]
=
=
0x00100073
&
&
(
insn
[
-
2
]
&
kITypeMask
)
=
=
RO_CSRRWI
)
)
)
;
#
else
MOZ_CRASH
(
"
IsValidStackMapKey
:
requires
implementation
on
this
platform
"
)
;
#
endif
}
#
endif
