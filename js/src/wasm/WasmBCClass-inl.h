#
ifndef
wasm_wasm_baseline_object_inl_h
#
define
wasm_wasm_baseline_object_inl_h
namespace
js
{
namespace
wasm
{
const
FuncType
&
BaseCompiler
:
:
funcType
(
)
const
{
return
*
moduleEnv_
.
funcs
[
func_
.
index
]
.
type
;
}
bool
BaseCompiler
:
:
usesMemory
(
)
const
{
return
moduleEnv_
.
memories
.
length
(
)
>
0
;
}
bool
BaseCompiler
:
:
usesSharedMemory
(
uint32_t
memoryIndex
)
const
{
return
moduleEnv_
.
usesSharedMemory
(
memoryIndex
)
;
}
const
Local
&
BaseCompiler
:
:
localFromSlot
(
uint32_t
slot
MIRType
type
)
{
MOZ_ASSERT
(
localInfo_
[
slot
]
.
type
=
=
type
)
;
return
localInfo_
[
slot
]
;
}
BytecodeOffset
BaseCompiler
:
:
bytecodeOffset
(
)
const
{
return
iter_
.
bytecodeOffset
(
)
;
}
bool
BaseCompiler
:
:
isMem32
(
uint32_t
memoryIndex
)
const
{
return
moduleEnv_
.
memories
[
memoryIndex
]
.
indexType
(
)
=
=
IndexType
:
:
I32
;
}
bool
BaseCompiler
:
:
isMem64
(
uint32_t
memoryIndex
)
const
{
return
moduleEnv_
.
memories
[
memoryIndex
]
.
indexType
(
)
=
=
IndexType
:
:
I64
;
}
bool
BaseCompiler
:
:
hugeMemoryEnabled
(
uint32_t
memoryIndex
)
const
{
return
moduleEnv_
.
hugeMemoryEnabled
(
memoryIndex
)
;
}
uint32_t
BaseCompiler
:
:
instanceOffsetOfMemoryBase
(
uint32_t
memoryIndex
)
const
{
if
(
memoryIndex
=
=
0
)
{
return
Instance
:
:
offsetOfMemoryBase
(
)
;
}
return
Instance
:
:
offsetInData
(
moduleEnv_
.
memories
[
memoryIndex
]
.
globalDataOffset
+
offsetof
(
MemoryInstanceData
memoryBase
)
)
;
}
uint32_t
BaseCompiler
:
:
instanceOffsetOfBoundsCheckLimit
(
uint32_t
memoryIndex
)
const
{
if
(
memoryIndex
=
=
0
)
{
return
Instance
:
:
offsetOfBoundsCheckLimit
(
)
;
}
return
Instance
:
:
offsetInData
(
moduleEnv_
.
memories
[
memoryIndex
]
.
globalDataOffset
+
offsetof
(
MemoryInstanceData
boundsCheckLimit
)
)
;
}
}
}
#
endif
