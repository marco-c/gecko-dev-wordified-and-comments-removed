#
include
"
wasm
/
WasmMemory
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
wasm
/
WasmCodegenTypes
.
h
"
#
include
"
wasm
/
WasmProcess
.
h
"
using
mozilla
:
:
IsPowerOfTwo
;
using
namespace
js
;
using
namespace
js
:
:
wasm
;
const
char
*
wasm
:
:
ToString
(
IndexType
indexType
)
{
switch
(
indexType
)
{
case
IndexType
:
:
I32
:
return
"
i32
"
;
case
IndexType
:
:
I64
:
return
"
i64
"
;
default
:
MOZ_CRASH
(
)
;
}
}
bool
wasm
:
:
ToIndexType
(
JSContext
*
cx
HandleValue
value
IndexType
*
indexType
)
{
RootedString
typeStr
(
cx
ToString
(
cx
value
)
)
;
if
(
!
typeStr
)
{
return
false
;
}
Rooted
<
JSLinearString
*
>
typeLinearStr
(
cx
typeStr
-
>
ensureLinear
(
cx
)
)
;
if
(
!
typeLinearStr
)
{
return
false
;
}
if
(
StringEqualsLiteral
(
typeLinearStr
"
i32
"
)
)
{
*
indexType
=
IndexType
:
:
I32
;
}
else
if
(
StringEqualsLiteral
(
typeLinearStr
"
i64
"
)
)
{
*
indexType
=
IndexType
:
:
I64
;
}
else
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_BAD_STRING_IDX_TYPE
)
;
return
false
;
}
return
true
;
}
static
const
unsigned
MaxMemoryAccessSize
=
LitVal
:
:
sizeofLargestValue
(
)
;
static_assert
(
MaxMemoryAccessSize
>
=
8
"
MaxMemoryAccessSize
too
low
"
)
;
static_assert
(
MaxMemoryAccessSize
<
=
64
"
MaxMemoryAccessSize
too
high
"
)
;
static_assert
(
(
MaxMemoryAccessSize
&
(
MaxMemoryAccessSize
-
1
)
)
=
=
0
"
MaxMemoryAccessSize
is
not
a
power
of
two
"
)
;
#
ifdef
WASM_SUPPORTS_HUGE_MEMORY
static_assert
(
MaxMemoryAccessSize
<
=
HugeUnalignedGuardPage
"
rounded
up
to
static
page
size
"
)
;
static_assert
(
HugeOffsetGuardLimit
<
UINT32_MAX
"
checking
for
overflow
against
OffsetGuardLimit
is
enough
.
"
)
;
#
if
!
(
defined
(
JS_CODEGEN_X64
)
|
|
defined
(
JS_CODEGEN_ARM64
)
)
#
error
"
Not
an
expected
configuration
"
#
endif
#
endif
static
const
size_t
OffsetGuardLimit
=
PageSize
-
MaxMemoryAccessSize
;
static_assert
(
MaxMemoryAccessSize
<
GuardSize
"
Guard
page
handles
partial
out
-
of
-
bounds
"
)
;
static_assert
(
OffsetGuardLimit
<
UINT32_MAX
"
checking
for
overflow
against
OffsetGuardLimit
is
enough
.
"
)
;
size_t
wasm
:
:
GetMaxOffsetGuardLimit
(
bool
hugeMemory
)
{
#
ifdef
WASM_SUPPORTS_HUGE_MEMORY
return
hugeMemory
?
HugeOffsetGuardLimit
:
OffsetGuardLimit
;
#
else
return
OffsetGuardLimit
;
#
endif
}
static
const
size_t
MinOffsetGuardLimit
=
OffsetGuardLimit
;
static_assert
(
MaxInlineMemoryCopyLength
<
MinOffsetGuardLimit
"
precondition
"
)
;
static_assert
(
MaxInlineMemoryFillLength
<
MinOffsetGuardLimit
"
precondition
"
)
;
#
ifdef
JS_64BIT
wasm
:
:
Pages
wasm
:
:
MaxMemoryPages
(
IndexType
t
)
{
MOZ_ASSERT_IF
(
t
=
=
IndexType
:
:
I64
!
IsHugeMemoryEnabled
(
t
)
)
;
size_t
desired
=
MaxMemoryLimitField
(
t
)
;
size_t
actual
=
ArrayBufferObject
:
:
maxBufferByteLength
(
)
/
PageSize
;
return
wasm
:
:
Pages
(
std
:
:
min
(
desired
actual
)
)
;
}
size_t
wasm
:
:
MaxMemoryBoundsCheckLimit
(
IndexType
t
)
{
return
MaxMemoryPages
(
t
)
.
byteLength
(
)
;
}
#
else
wasm
:
:
Pages
wasm
:
:
MaxMemoryPages
(
IndexType
t
)
{
MOZ_ASSERT
(
ArrayBufferObject
:
:
maxBufferByteLength
(
)
>
=
INT32_MAX
/
PageSize
)
;
return
wasm
:
:
Pages
(
INT32_MAX
/
PageSize
)
;
}
size_t
wasm
:
:
MaxMemoryBoundsCheckLimit
(
IndexType
t
)
{
size_t
boundsCheckLimit
=
size_t
(
INT32_MAX
)
+
1
;
MOZ_ASSERT
(
IsValidBoundsCheckImmediate
(
boundsCheckLimit
)
)
;
return
boundsCheckLimit
;
}
#
endif
static
const
uint64_t
HighestValidARMImmediate
=
0xff000000
;
bool
wasm
:
:
IsValidARMImmediate
(
uint32_t
i
)
{
bool
valid
=
(
IsPowerOfTwo
(
i
)
|
|
(
i
&
0x00ffffff
)
=
=
0
)
;
MOZ_ASSERT_IF
(
valid
i
%
PageSize
=
=
0
)
;
return
valid
;
}
uint64_t
wasm
:
:
RoundUpToNextValidARMImmediate
(
uint64_t
i
)
{
MOZ_ASSERT
(
i
<
=
HighestValidARMImmediate
)
;
static_assert
(
HighestValidARMImmediate
=
=
0xff000000
"
algorithm
relies
on
specific
constant
"
)
;
if
(
i
<
=
16
*
1024
*
1024
)
{
i
=
i
?
mozilla
:
:
RoundUpPow2
(
i
)
:
0
;
}
else
{
i
=
(
i
+
0x00ffffff
)
&
~
0x00ffffff
;
}
MOZ_ASSERT
(
IsValidARMImmediate
(
i
)
)
;
return
i
;
}
Pages
wasm
:
:
ClampedMaxPages
(
IndexType
t
Pages
initialPages
const
Maybe
<
Pages
>
&
sourceMaxPages
bool
useHugeMemory
)
{
Pages
clampedMaxPages
;
if
(
sourceMaxPages
.
isSome
(
)
)
{
clampedMaxPages
=
std
:
:
min
(
*
sourceMaxPages
wasm
:
:
MaxMemoryPages
(
t
)
)
;
#
ifndef
JS_64BIT
static_assert
(
sizeof
(
uintptr_t
)
=
=
4
"
assuming
not
64
bit
implies
32
bit
"
)
;
static
const
uint64_t
OneGib
=
1
<
<
30
;
static
const
Pages
OneGibPages
=
Pages
(
OneGib
>
>
wasm
:
:
PageBits
)
;
static_assert
(
HighestValidARMImmediate
>
OneGib
"
computing
mapped
size
on
ARM
requires
clamped
max
size
"
)
;
Pages
clampedPages
=
std
:
:
max
(
OneGibPages
initialPages
)
;
clampedMaxPages
=
std
:
:
min
(
clampedPages
clampedMaxPages
)
;
#
endif
}
else
{
clampedMaxPages
=
wasm
:
:
MaxMemoryPages
(
t
)
;
}
MOZ_RELEASE_ASSERT
(
sourceMaxPages
.
isNothing
(
)
|
|
clampedMaxPages
<
=
*
sourceMaxPages
)
;
MOZ_RELEASE_ASSERT
(
clampedMaxPages
<
=
wasm
:
:
MaxMemoryPages
(
t
)
)
;
MOZ_RELEASE_ASSERT
(
initialPages
<
=
clampedMaxPages
)
;
return
clampedMaxPages
;
}
size_t
wasm
:
:
ComputeMappedSize
(
wasm
:
:
Pages
clampedMaxPages
)
{
size_t
maxSize
=
clampedMaxPages
.
byteLength
(
)
;
uint64_t
boundsCheckLimit
=
RoundUpToNextValidBoundsCheckImmediate
(
maxSize
)
;
MOZ_ASSERT
(
IsValidBoundsCheckImmediate
(
boundsCheckLimit
)
)
;
MOZ_ASSERT
(
boundsCheckLimit
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
MOZ_ASSERT
(
GuardSize
%
gc
:
:
SystemPageSize
(
)
=
=
0
)
;
return
boundsCheckLimit
+
GuardSize
;
}
bool
wasm
:
:
IsValidBoundsCheckImmediate
(
uint32_t
i
)
{
#
ifdef
JS_CODEGEN_ARM
return
IsValidARMImmediate
(
i
)
;
#
else
return
true
;
#
endif
}
uint64_t
wasm
:
:
RoundUpToNextValidBoundsCheckImmediate
(
uint64_t
i
)
{
#
ifdef
JS_CODEGEN_ARM
return
RoundUpToNextValidARMImmediate
(
i
)
;
#
else
return
i
;
#
endif
}
