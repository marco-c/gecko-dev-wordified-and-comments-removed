#
ifndef
wasm_codegen_types_h
#
define
wasm_codegen_types_h
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
<
stdint
.
h
>
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
wasm
/
WasmBuiltins
.
h
"
#
include
"
wasm
/
WasmCodegenConstants
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmInstanceData
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
#
include
"
wasm
/
WasmUtility
.
h
"
namespace
js
{
namespace
jit
{
template
<
class
VecT
class
ABIArgGeneratorT
>
class
ABIArgIterBase
;
}
namespace
wasm
{
struct
CodeMetadata
;
struct
TableDesc
;
struct
V128
;
enum
class
StackResults
{
HasStackResults
NoStackResults
}
;
class
ArgTypeVector
{
const
ValTypeVector
&
args_
;
bool
hasStackResults_
;
size_t
length
(
)
const
{
return
args_
.
length
(
)
+
size_t
(
hasStackResults_
)
;
}
template
<
class
VecT
class
ABIArgGeneratorT
>
friend
class
jit
:
:
ABIArgIterBase
;
public
:
ArgTypeVector
(
const
ValTypeVector
&
args
StackResults
stackResults
)
:
args_
(
args
)
hasStackResults_
(
stackResults
=
=
StackResults
:
:
HasStackResults
)
{
}
explicit
ArgTypeVector
(
const
FuncType
&
funcType
)
;
bool
hasSyntheticStackResultPointerArg
(
)
const
{
return
hasStackResults_
;
}
StackResults
stackResults
(
)
const
{
return
hasSyntheticStackResultPointerArg
(
)
?
StackResults
:
:
HasStackResults
:
StackResults
:
:
NoStackResults
;
}
size_t
lengthWithoutStackResults
(
)
const
{
return
args_
.
length
(
)
;
}
bool
isSyntheticStackResultPointerArg
(
size_t
idx
)
const
{
MOZ_ASSERT
(
idx
<
lengthWithStackResults
(
)
)
;
return
idx
=
=
args_
.
length
(
)
;
}
bool
isNaturalArg
(
size_t
idx
)
const
{
return
!
isSyntheticStackResultPointerArg
(
idx
)
;
}
size_t
naturalIndex
(
size_t
idx
)
const
{
MOZ_ASSERT
(
isNaturalArg
(
idx
)
)
;
return
idx
;
}
size_t
lengthWithStackResults
(
)
const
{
return
length
(
)
;
}
jit
:
:
MIRType
operator
[
]
(
size_t
i
)
const
{
MOZ_ASSERT
(
i
<
lengthWithStackResults
(
)
)
;
if
(
isSyntheticStackResultPointerArg
(
i
)
)
{
return
jit
:
:
MIRType
:
:
StackResults
;
}
return
args_
[
naturalIndex
(
i
)
]
.
toMIRType
(
)
;
}
}
;
class
BytecodeOffset
{
static
const
uint32_t
INVALID
=
-
1
;
uint32_t
offset_
;
WASM_CHECK_CACHEABLE_POD
(
offset_
)
;
public
:
BytecodeOffset
(
)
:
offset_
(
INVALID
)
{
}
explicit
BytecodeOffset
(
uint32_t
offset
)
:
offset_
(
offset
)
{
}
bool
isValid
(
)
const
{
return
offset_
!
=
INVALID
;
}
uint32_t
offset
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
offset_
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
BytecodeOffset
)
;
enum
class
TrapMachineInsn
{
OfficialUD
Load8
Load16
Load32
Load64
Load128
Store8
Store16
Store32
Store64
Store128
Atomic
}
;
static
inline
TrapMachineInsn
TrapMachineInsnForLoad
(
int
byteSize
)
{
switch
(
byteSize
)
{
case
1
:
return
TrapMachineInsn
:
:
Load8
;
case
2
:
return
TrapMachineInsn
:
:
Load16
;
case
4
:
return
TrapMachineInsn
:
:
Load32
;
case
8
:
return
TrapMachineInsn
:
:
Load64
;
case
16
:
return
TrapMachineInsn
:
:
Load128
;
default
:
MOZ_CRASH
(
"
TrapMachineInsnForLoad
"
)
;
}
}
static
inline
TrapMachineInsn
TrapMachineInsnForLoadWord
(
)
{
return
TrapMachineInsnForLoad
(
sizeof
(
void
*
)
)
;
}
static
inline
TrapMachineInsn
TrapMachineInsnForStore
(
int
byteSize
)
{
switch
(
byteSize
)
{
case
1
:
return
TrapMachineInsn
:
:
Store8
;
case
2
:
return
TrapMachineInsn
:
:
Store16
;
case
4
:
return
TrapMachineInsn
:
:
Store32
;
case
8
:
return
TrapMachineInsn
:
:
Store64
;
case
16
:
return
TrapMachineInsn
:
:
Store128
;
default
:
MOZ_CRASH
(
"
TrapMachineInsnForStore
"
)
;
}
}
static
inline
TrapMachineInsn
TrapMachineInsnForStoreWord
(
)
{
return
TrapMachineInsnForStore
(
sizeof
(
void
*
)
)
;
}
#
ifdef
DEBUG
const
char
*
NameOfTrap
(
Trap
trap
)
;
const
char
*
NameOfTrapMachineInsn
(
TrapMachineInsn
tmi
)
;
#
endif
class
FaultingCodeOffset
{
static
constexpr
uint32_t
INVALID
=
UINT32_MAX
;
uint32_t
offset_
;
public
:
FaultingCodeOffset
(
)
:
offset_
(
INVALID
)
{
}
explicit
FaultingCodeOffset
(
uint32_t
offset
)
:
offset_
(
offset
)
{
MOZ_ASSERT
(
offset
!
=
INVALID
)
;
}
bool
isValid
(
)
const
{
return
offset_
!
=
INVALID
;
}
uint32_t
get
(
)
const
{
MOZ_ASSERT
(
isValid
(
)
)
;
return
offset_
;
}
}
;
static_assert
(
sizeof
(
FaultingCodeOffset
)
=
=
4
)
;
using
FaultingCodeOffsetPair
=
std
:
:
pair
<
FaultingCodeOffset
FaultingCodeOffset
>
;
static_assert
(
sizeof
(
FaultingCodeOffsetPair
)
=
=
8
)
;
struct
TrapSite
{
#
ifdef
DEBUG
TrapMachineInsn
insn
;
#
endif
uint32_t
pcOffset
;
BytecodeOffset
bytecode
;
WASM_CHECK_CACHEABLE_POD
(
pcOffset
bytecode
)
;
TrapSite
(
)
:
#
ifdef
DEBUG
insn
(
TrapMachineInsn
:
:
OfficialUD
)
#
endif
pcOffset
(
-
1
)
{
}
TrapSite
(
TrapMachineInsn
insn
FaultingCodeOffset
fco
BytecodeOffset
bytecode
)
:
#
ifdef
DEBUG
insn
(
insn
)
#
endif
pcOffset
(
fco
.
get
(
)
)
bytecode
(
bytecode
)
{
}
void
offsetBy
(
uint32_t
offset
)
{
pcOffset
+
=
offset
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
TrapSite
)
;
WASM_DECLARE_POD_VECTOR
(
TrapSite
TrapSiteVector
)
struct
TrapSiteVectorArray
:
mozilla
:
:
EnumeratedArray
<
Trap
TrapSiteVector
size_t
(
Trap
:
:
Limit
)
>
{
bool
empty
(
)
const
;
void
clear
(
)
;
void
swap
(
TrapSiteVectorArray
&
rhs
)
;
void
shrinkStorageToFit
(
)
;
size_t
sumOfLengths
(
)
const
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
}
;
struct
CallFarJump
{
uint32_t
targetFuncIndex
;
uint32_t
jumpOffset
;
WASM_CHECK_CACHEABLE_POD
(
targetFuncIndex
jumpOffset
)
;
CallFarJump
(
uint32_t
targetFuncIndex
uint32_t
jumpOffset
)
:
targetFuncIndex
(
targetFuncIndex
)
jumpOffset
(
jumpOffset
)
{
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
CallFarJump
)
;
using
CallFarJumpVector
=
Vector
<
CallFarJump
0
SystemAllocPolicy
>
;
class
CallRefMetricsPatch
{
private
:
uint32_t
offsetOfOffsetPatch_
;
static
constexpr
uint32_t
NO_OFFSET
=
UINT32_MAX
;
WASM_CHECK_CACHEABLE_POD
(
offsetOfOffsetPatch_
)
;
public
:
explicit
CallRefMetricsPatch
(
)
:
offsetOfOffsetPatch_
(
NO_OFFSET
)
{
}
bool
hasOffsetOfOffsetPatch
(
)
const
{
return
offsetOfOffsetPatch_
!
=
NO_OFFSET
;
}
uint32_t
offsetOfOffsetPatch
(
)
const
{
return
offsetOfOffsetPatch_
;
}
void
setOffset
(
uint32_t
indexOffset
)
{
MOZ_ASSERT
(
!
hasOffsetOfOffsetPatch
(
)
)
;
MOZ_ASSERT
(
indexOffset
!
=
NO_OFFSET
)
;
offsetOfOffsetPatch_
=
indexOffset
;
}
}
;
using
CallRefMetricsPatchVector
=
Vector
<
CallRefMetricsPatch
0
SystemAllocPolicy
>
;
struct
TrapData
{
void
*
resumePC
;
void
*
unwoundPC
;
Trap
trap
;
uint32_t
bytecodeOffset
;
bool
failedUnwindSignatureMismatch
;
}
;
struct
Offsets
{
explicit
Offsets
(
uint32_t
begin
=
0
uint32_t
end
=
0
)
:
begin
(
begin
)
end
(
end
)
{
}
uint32_t
begin
;
uint32_t
end
;
WASM_CHECK_CACHEABLE_POD
(
begin
end
)
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
Offsets
)
;
struct
CallableOffsets
:
Offsets
{
MOZ_IMPLICIT
CallableOffsets
(
uint32_t
ret
=
0
)
:
ret
(
ret
)
{
}
uint32_t
ret
;
WASM_CHECK_CACHEABLE_POD_WITH_PARENT
(
Offsets
ret
)
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
CallableOffsets
)
;
struct
ImportOffsets
:
CallableOffsets
{
MOZ_IMPLICIT
ImportOffsets
(
)
:
afterFallbackCheck
(
0
)
{
}
uint32_t
afterFallbackCheck
;
WASM_CHECK_CACHEABLE_POD_WITH_PARENT
(
CallableOffsets
afterFallbackCheck
)
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
ImportOffsets
)
;
struct
FuncOffsets
:
CallableOffsets
{
MOZ_IMPLICIT
FuncOffsets
(
)
:
uncheckedCallEntry
(
0
)
tierEntry
(
0
)
{
}
uint32_t
uncheckedCallEntry
;
uint32_t
tierEntry
;
WASM_CHECK_CACHEABLE_POD_WITH_PARENT
(
CallableOffsets
uncheckedCallEntry
tierEntry
)
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
FuncOffsets
)
;
using
FuncOffsetsVector
=
Vector
<
FuncOffsets
0
SystemAllocPolicy
>
;
class
CodeRange
{
public
:
enum
Kind
{
Function
InterpEntry
JitEntry
ImportInterpExit
ImportJitExit
BuiltinThunk
TrapExit
DebugStub
RequestTierUpStub
FarJumpIsland
Throw
}
;
private
:
uint32_t
begin_
;
uint32_t
ret_
;
uint32_t
end_
;
union
{
struct
{
uint32_t
funcIndex_
;
union
{
struct
{
uint16_t
beginToUncheckedCallEntry_
;
uint16_t
beginToTierEntry_
;
bool
hasUnwindInfo_
;
}
func
;
uint16_t
jitExitEntry_
;
}
;
}
;
Trap
trap_
;
}
u
;
Kind
kind_
:
8
;
WASM_CHECK_CACHEABLE_POD
(
begin_
ret_
end_
u
.
funcIndex_
u
.
func
.
beginToUncheckedCallEntry_
u
.
func
.
beginToTierEntry_
u
.
func
.
hasUnwindInfo_
u
.
trap_
kind_
)
;
public
:
CodeRange
(
)
=
default
;
CodeRange
(
Kind
kind
Offsets
offsets
)
;
CodeRange
(
Kind
kind
uint32_t
funcIndex
Offsets
offsets
)
;
CodeRange
(
Kind
kind
CallableOffsets
offsets
)
;
CodeRange
(
Kind
kind
uint32_t
funcIndex
CallableOffsets
)
;
CodeRange
(
Kind
kind
uint32_t
funcIndex
ImportOffsets
offsets
)
;
CodeRange
(
uint32_t
funcIndex
FuncOffsets
offsets
bool
hasUnwindInfo
)
;
void
offsetBy
(
uint32_t
offset
)
{
begin_
+
=
offset
;
end_
+
=
offset
;
if
(
hasReturn
(
)
)
{
ret_
+
=
offset
;
}
}
uint32_t
begin
(
)
const
{
return
begin_
;
}
uint32_t
end
(
)
const
{
return
end_
;
}
Kind
kind
(
)
const
{
return
kind_
;
}
bool
isFunction
(
)
const
{
return
kind
(
)
=
=
Function
;
}
bool
isImportExit
(
)
const
{
return
kind
(
)
=
=
ImportJitExit
|
|
kind
(
)
=
=
ImportInterpExit
|
|
kind
(
)
=
=
BuiltinThunk
;
}
bool
isImportInterpExit
(
)
const
{
return
kind
(
)
=
=
ImportInterpExit
;
}
bool
isImportJitExit
(
)
const
{
return
kind
(
)
=
=
ImportJitExit
;
}
bool
isTrapExit
(
)
const
{
return
kind
(
)
=
=
TrapExit
;
}
bool
isDebugStub
(
)
const
{
return
kind
(
)
=
=
DebugStub
;
}
bool
isRequestTierUpStub
(
)
const
{
return
kind
(
)
=
=
RequestTierUpStub
;
}
bool
isThunk
(
)
const
{
return
kind
(
)
=
=
FarJumpIsland
;
}
bool
hasReturn
(
)
const
{
return
isFunction
(
)
|
|
isImportExit
(
)
|
|
isDebugStub
(
)
|
|
isRequestTierUpStub
(
)
|
|
isJitEntry
(
)
;
}
uint32_t
ret
(
)
const
{
MOZ_ASSERT
(
hasReturn
(
)
)
;
return
ret_
;
}
bool
isJitEntry
(
)
const
{
return
kind
(
)
=
=
JitEntry
;
}
bool
isInterpEntry
(
)
const
{
return
kind
(
)
=
=
InterpEntry
;
}
bool
isEntry
(
)
const
{
return
isInterpEntry
(
)
|
|
isJitEntry
(
)
;
}
bool
hasFuncIndex
(
)
const
{
return
isFunction
(
)
|
|
isImportExit
(
)
|
|
isEntry
(
)
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
hasFuncIndex
(
)
)
;
return
u
.
funcIndex_
;
}
Trap
trap
(
)
const
{
MOZ_ASSERT
(
isTrapExit
(
)
)
;
return
u
.
trap_
;
}
uint32_t
funcCheckedCallEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
MOZ_ASSERT
(
u
.
func
.
beginToUncheckedCallEntry_
!
=
0
)
;
return
begin_
;
}
uint32_t
funcUncheckedCallEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
u
.
func
.
beginToUncheckedCallEntry_
;
}
uint32_t
funcTierEntry
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
begin_
+
u
.
func
.
beginToTierEntry_
;
}
bool
funcHasUnwindInfo
(
)
const
{
MOZ_ASSERT
(
isFunction
(
)
)
;
return
u
.
func
.
hasUnwindInfo_
;
}
uint32_t
importJitExitEntry
(
)
const
{
MOZ_ASSERT
(
isImportJitExit
(
)
)
;
return
begin_
+
u
.
jitExitEntry_
;
}
struct
OffsetInCode
{
size_t
offset
;
explicit
OffsetInCode
(
size_t
offset
)
:
offset
(
offset
)
{
}
bool
operator
=
=
(
const
CodeRange
&
rhs
)
const
{
return
offset
>
=
rhs
.
begin
(
)
&
&
offset
<
rhs
.
end
(
)
;
}
bool
operator
<
(
const
CodeRange
&
rhs
)
const
{
return
offset
<
rhs
.
begin
(
)
;
}
}
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
CodeRange
)
;
WASM_DECLARE_POD_VECTOR
(
CodeRange
CodeRangeVector
)
extern
const
CodeRange
*
LookupInSorted
(
const
CodeRangeVector
&
codeRanges
CodeRange
:
:
OffsetInCode
target
)
;
class
CallSiteDesc
{
static
constexpr
size_t
LINE_OR_BYTECODE_BITS_SIZE
=
28
;
uint32_t
lineOrBytecode_
:
LINE_OR_BYTECODE_BITS_SIZE
;
uint32_t
kind_
:
4
;
WASM_CHECK_CACHEABLE_POD
(
lineOrBytecode_
kind_
)
;
public
:
static
constexpr
uint32_t
MAX_LINE_OR_BYTECODE_VALUE
=
(
1
<
<
LINE_OR_BYTECODE_BITS_SIZE
)
-
1
;
enum
Kind
{
Func
Import
Indirect
IndirectFast
FuncRef
FuncRefFast
ReturnFunc
ReturnStub
Symbolic
EnterFrame
LeaveFrame
CollapseFrame
StackSwitch
Breakpoint
RequestTierUp
}
;
CallSiteDesc
(
)
:
lineOrBytecode_
(
0
)
kind_
(
0
)
{
}
explicit
CallSiteDesc
(
Kind
kind
)
:
lineOrBytecode_
(
0
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
=
=
Kind
(
kind_
)
)
;
}
CallSiteDesc
(
uint32_t
lineOrBytecode
Kind
kind
)
:
lineOrBytecode_
(
lineOrBytecode
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
=
=
Kind
(
kind_
)
)
;
MOZ_ASSERT
(
lineOrBytecode
=
=
lineOrBytecode_
)
;
}
CallSiteDesc
(
BytecodeOffset
bytecodeOffset
Kind
kind
)
:
lineOrBytecode_
(
bytecodeOffset
.
offset
(
)
)
kind_
(
kind
)
{
MOZ_ASSERT
(
kind
=
=
Kind
(
kind_
)
)
;
MOZ_ASSERT
(
bytecodeOffset
.
offset
(
)
=
=
lineOrBytecode_
)
;
}
uint32_t
lineOrBytecode
(
)
const
{
return
lineOrBytecode_
;
}
Kind
kind
(
)
const
{
return
Kind
(
kind_
)
;
}
bool
isImportCall
(
)
const
{
return
kind
(
)
=
=
CallSiteDesc
:
:
Import
;
}
bool
isIndirectCall
(
)
const
{
return
kind
(
)
=
=
CallSiteDesc
:
:
Indirect
;
}
bool
isFuncRefCall
(
)
const
{
return
kind
(
)
=
=
CallSiteDesc
:
:
FuncRef
;
}
bool
isReturnStub
(
)
const
{
return
kind
(
)
=
=
CallSiteDesc
:
:
ReturnStub
;
}
bool
isStackSwitch
(
)
const
{
return
kind
(
)
=
=
CallSiteDesc
:
:
StackSwitch
;
}
bool
mightBeCrossInstance
(
)
const
{
return
isImportCall
(
)
|
|
isIndirectCall
(
)
|
|
isFuncRefCall
(
)
|
|
isReturnStub
(
)
|
|
isStackSwitch
(
)
;
}
}
;
static_assert
(
js
:
:
wasm
:
:
MaxFunctionBytes
<
=
CallSiteDesc
:
:
MAX_LINE_OR_BYTECODE_VALUE
)
;
WASM_DECLARE_CACHEABLE_POD
(
CallSiteDesc
)
;
class
CallSite
:
public
CallSiteDesc
{
uint32_t
returnAddressOffset_
;
WASM_CHECK_CACHEABLE_POD_WITH_PARENT
(
CallSiteDesc
returnAddressOffset_
)
;
public
:
CallSite
(
)
:
returnAddressOffset_
(
0
)
{
}
CallSite
(
CallSiteDesc
desc
uint32_t
returnAddressOffset
)
:
CallSiteDesc
(
desc
)
returnAddressOffset_
(
returnAddressOffset
)
{
}
void
offsetBy
(
uint32_t
delta
)
{
returnAddressOffset_
+
=
delta
;
}
uint32_t
returnAddressOffset
(
)
const
{
return
returnAddressOffset_
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
CallSite
)
;
WASM_DECLARE_POD_VECTOR
(
CallSite
CallSiteVector
)
class
CallSiteTarget
{
uint32_t
packed_
;
WASM_CHECK_CACHEABLE_POD
(
packed_
)
;
#
ifdef
DEBUG
enum
Kind
{
None
FuncIndex
TrapExit
}
kind_
;
WASM_CHECK_CACHEABLE_POD
(
kind_
)
;
#
endif
public
:
explicit
CallSiteTarget
(
)
:
packed_
(
UINT32_MAX
)
#
ifdef
DEBUG
kind_
(
None
)
#
endif
{
}
explicit
CallSiteTarget
(
uint32_t
funcIndex
)
:
packed_
(
funcIndex
)
#
ifdef
DEBUG
kind_
(
FuncIndex
)
#
endif
{
}
explicit
CallSiteTarget
(
Trap
trap
)
:
packed_
(
uint32_t
(
trap
)
)
#
ifdef
DEBUG
kind_
(
TrapExit
)
#
endif
{
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
FuncIndex
)
;
return
packed_
;
}
Trap
trap
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
TrapExit
)
;
MOZ_ASSERT
(
packed_
<
uint32_t
(
Trap
:
:
Limit
)
)
;
return
Trap
(
packed_
)
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
CallSiteTarget
)
;
using
CallSiteTargetVector
=
Vector
<
CallSiteTarget
0
SystemAllocPolicy
>
;
struct
TryNote
{
private
:
static
const
uint32_t
BEGIN_NONE
=
UINT32_MAX
;
static
const
uint32_t
IS_DELEGATE
=
UINT32_MAX
;
uint32_t
begin_
;
uint32_t
end_
;
uint32_t
entryPointOrIsDelegate_
;
uint32_t
framePushedOrDelegateOffset_
;
WASM_CHECK_CACHEABLE_POD
(
begin_
end_
entryPointOrIsDelegate_
framePushedOrDelegateOffset_
)
;
public
:
explicit
TryNote
(
)
:
begin_
(
BEGIN_NONE
)
end_
(
0
)
entryPointOrIsDelegate_
(
0
)
framePushedOrDelegateOffset_
(
0
)
{
}
bool
hasTryBody
(
)
const
{
return
begin_
!
=
BEGIN_NONE
;
}
uint32_t
tryBodyBegin
(
)
const
{
return
begin_
;
}
uint32_t
tryBodyEnd
(
)
const
{
return
end_
;
}
bool
offsetWithinTryBody
(
uint32_t
offset
)
const
{
return
offset
>
begin_
&
&
offset
<
=
end_
;
}
bool
isDelegate
(
)
const
{
return
entryPointOrIsDelegate_
=
=
IS_DELEGATE
;
}
uint32_t
delegateOffset
(
)
const
{
MOZ_ASSERT
(
isDelegate
(
)
)
;
return
framePushedOrDelegateOffset_
;
}
uint32_t
landingPadEntryPoint
(
)
const
{
MOZ_ASSERT
(
!
isDelegate
(
)
)
;
return
entryPointOrIsDelegate_
;
}
uint32_t
landingPadFramePushed
(
)
const
{
MOZ_ASSERT
(
!
isDelegate
(
)
)
;
return
framePushedOrDelegateOffset_
;
}
void
setTryBodyBegin
(
uint32_t
begin
)
{
MOZ_ASSERT
(
begin_
=
=
BEGIN_NONE
)
;
begin_
=
begin
;
}
void
setTryBodyEnd
(
uint32_t
end
)
{
MOZ_ASSERT
(
begin_
!
=
BEGIN_NONE
)
;
end_
=
end
;
MOZ_ASSERT
(
end_
>
begin_
)
;
}
void
setDelegate
(
uint32_t
delegateOffset
)
{
entryPointOrIsDelegate_
=
IS_DELEGATE
;
framePushedOrDelegateOffset_
=
delegateOffset
;
}
void
setLandingPad
(
uint32_t
entryPoint
uint32_t
framePushed
)
{
MOZ_ASSERT
(
!
isDelegate
(
)
)
;
entryPointOrIsDelegate_
=
entryPoint
;
framePushedOrDelegateOffset_
=
framePushed
;
}
void
offsetBy
(
uint32_t
offset
)
{
begin_
+
=
offset
;
end_
+
=
offset
;
if
(
isDelegate
(
)
)
{
framePushedOrDelegateOffset_
+
=
offset
;
}
else
{
entryPointOrIsDelegate_
+
=
offset
;
}
}
bool
operator
<
(
const
TryNote
&
other
)
const
{
if
(
this
=
=
&
other
)
{
return
false
;
}
MOZ_ASSERT
(
end_
<
=
other
.
begin_
|
|
begin_
>
=
other
.
end_
|
|
(
begin_
>
other
.
begin_
&
&
end_
<
other
.
end_
)
|
|
(
other
.
begin_
>
begin_
&
&
other
.
end_
<
end_
)
)
;
return
end_
<
other
.
end_
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
TryNote
)
;
WASM_DECLARE_POD_VECTOR
(
TryNote
TryNoteVector
)
class
CodeRangeUnwindInfo
{
public
:
enum
UnwindHow
{
Normal
RestoreFpRa
RestoreFp
UseFpLr
UseFp
}
;
private
:
uint32_t
offset_
;
UnwindHow
unwindHow_
;
WASM_CHECK_CACHEABLE_POD
(
offset_
unwindHow_
)
;
public
:
CodeRangeUnwindInfo
(
uint32_t
offset
UnwindHow
unwindHow
)
:
offset_
(
offset
)
unwindHow_
(
unwindHow
)
{
}
uint32_t
offset
(
)
const
{
return
offset_
;
}
UnwindHow
unwindHow
(
)
const
{
return
unwindHow_
;
}
void
offsetBy
(
uint32_t
offset
)
{
offset_
+
=
offset
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
CodeRangeUnwindInfo
)
;
WASM_DECLARE_POD_VECTOR
(
CodeRangeUnwindInfo
CodeRangeUnwindInfoVector
)
enum
class
CallIndirectIdKind
{
AsmJS
Immediate
Global
None
}
;
class
CallIndirectId
{
CallIndirectIdKind
kind_
;
union
{
size_t
immediate_
;
struct
{
size_t
instanceDataOffset_
;
bool
hasSuperType_
;
}
global_
;
}
;
explicit
CallIndirectId
(
CallIndirectIdKind
kind
)
:
kind_
(
kind
)
{
}
public
:
CallIndirectId
(
)
:
kind_
(
CallIndirectIdKind
:
:
None
)
{
}
static
CallIndirectId
forAsmJSFunc
(
)
;
static
CallIndirectId
forFunc
(
const
CodeMetadata
&
codeMeta
uint32_t
funcIndex
)
;
static
CallIndirectId
forFuncType
(
const
CodeMetadata
&
codeMeta
uint32_t
funcTypeIndex
)
;
CallIndirectIdKind
kind
(
)
const
{
return
kind_
;
}
bool
isGlobal
(
)
const
{
return
kind_
=
=
CallIndirectIdKind
:
:
Global
;
}
uint32_t
immediate
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
CallIndirectIdKind
:
:
Immediate
)
;
return
immediate_
;
}
uint32_t
instanceDataOffset
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
CallIndirectIdKind
:
:
Global
)
;
return
global_
.
instanceDataOffset_
;
}
bool
hasSuperType
(
)
const
{
MOZ_ASSERT
(
kind_
=
=
CallIndirectIdKind
:
:
Global
)
;
return
global_
.
hasSuperType_
;
}
}
;
class
CalleeDesc
{
public
:
enum
Which
{
Func
Import
WasmTable
AsmJSTable
Builtin
BuiltinInstanceMethod
FuncRef
}
;
private
:
MOZ_INIT_OUTSIDE_CTOR
Which
which_
;
union
U
{
U
(
)
:
funcIndex_
(
0
)
{
}
uint32_t
funcIndex_
;
struct
{
uint32_t
instanceDataOffset_
;
}
import
;
struct
{
uint32_t
instanceDataOffset_
;
uint64_t
minLength_
;
mozilla
:
:
Maybe
<
uint64_t
>
maxLength_
;
CallIndirectId
callIndirectId_
;
}
table
;
SymbolicAddress
builtin_
;
}
u
;
public
:
CalleeDesc
(
)
=
default
;
static
CalleeDesc
function
(
uint32_t
funcIndex
)
;
static
CalleeDesc
import
(
uint32_t
instanceDataOffset
)
;
static
CalleeDesc
wasmTable
(
const
CodeMetadata
&
codeMeta
const
TableDesc
&
desc
uint32_t
tableIndex
CallIndirectId
callIndirectId
)
;
static
CalleeDesc
asmJSTable
(
const
CodeMetadata
&
codeMeta
uint32_t
tableIndex
)
;
static
CalleeDesc
builtin
(
SymbolicAddress
callee
)
;
static
CalleeDesc
builtinInstanceMethod
(
SymbolicAddress
callee
)
;
static
CalleeDesc
wasmFuncRef
(
)
;
Which
which
(
)
const
{
return
which_
;
}
uint32_t
funcIndex
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Func
)
;
return
u
.
funcIndex_
;
}
uint32_t
importInstanceDataOffset
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Import
)
;
return
u
.
import
.
instanceDataOffset_
;
}
bool
isTable
(
)
const
{
return
which_
=
=
WasmTable
|
|
which_
=
=
AsmJSTable
;
}
uint32_t
tableLengthInstanceDataOffset
(
)
const
{
MOZ_ASSERT
(
isTable
(
)
)
;
return
u
.
table
.
instanceDataOffset_
+
offsetof
(
TableInstanceData
length
)
;
}
uint32_t
tableFunctionBaseInstanceDataOffset
(
)
const
{
MOZ_ASSERT
(
isTable
(
)
)
;
return
u
.
table
.
instanceDataOffset_
+
offsetof
(
TableInstanceData
elements
)
;
}
CallIndirectId
wasmTableSigId
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
callIndirectId_
;
}
uint32_t
wasmTableMinLength
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
minLength_
;
}
mozilla
:
:
Maybe
<
uint32_t
>
wasmTableMaxLength
(
)
const
{
MOZ_ASSERT
(
which_
=
=
WasmTable
)
;
return
u
.
table
.
maxLength_
;
}
SymbolicAddress
builtin
(
)
const
{
MOZ_ASSERT
(
which_
=
=
Builtin
|
|
which_
=
=
BuiltinInstanceMethod
)
;
return
u
.
builtin_
;
}
bool
isFuncRef
(
)
const
{
return
which_
=
=
FuncRef
;
}
}
;
}
}
#
endif
