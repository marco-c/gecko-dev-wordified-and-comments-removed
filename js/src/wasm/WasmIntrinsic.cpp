#
include
"
wasm
/
WasmIntrinsic
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
wasm
/
WasmGenerator
.
h
"
#
include
"
wasm
/
WasmJS
.
h
"
#
include
"
wasm
/
WasmModule
.
h
"
#
include
"
wasm
/
WasmOpIter
.
h
"
#
include
"
wasm
/
WasmValidate
.
h
"
using
namespace
js
;
using
namespace
js
:
:
wasm
;
static
const
ValType
IntrinsicI8VecMul_Params
[
]
=
{
ValType
:
:
I32
ValType
:
:
I32
ValType
:
:
I32
ValType
:
:
I32
}
;
const
Intrinsic
IntrinsicI8VecMul
=
{
"
i8vecmul
"
mozilla
:
:
Span
<
const
ValType
>
(
IntrinsicI8VecMul_Params
)
SASigIntrI8VecMul
}
;
bool
Intrinsic
:
:
funcType
(
FuncType
*
type
)
const
{
ValTypeVector
paramVec
;
if
(
!
paramVec
.
append
(
params
.
data
(
)
params
.
data
(
)
+
params
.
size
(
)
)
)
{
return
false
;
}
*
type
=
FuncType
(
std
:
:
move
(
paramVec
)
ValTypeVector
(
)
)
;
return
true
;
}
const
Intrinsic
&
Intrinsic
:
:
getFromOp
(
IntrinsicOp
op
)
{
switch
(
op
)
{
case
IntrinsicOp
:
:
I8VecMul
:
return
IntrinsicI8VecMul
;
default
:
MOZ_CRASH
(
"
unexpected
intrinsic
"
)
;
}
}
bool
EncodeIntrinsicBody
(
const
Intrinsic
&
intrinsic
Bytes
*
body
)
{
Encoder
encoder
(
*
body
)
;
if
(
!
EncodeLocalEntries
(
encoder
ValTypeVector
(
)
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
intrinsic
.
params
.
size
(
)
;
i
+
+
)
{
if
(
!
encoder
.
writeOp
(
Op
:
:
GetLocal
)
|
|
!
encoder
.
writeVarU32
(
i
)
)
{
return
false
;
}
}
if
(
!
encoder
.
writeOp
(
IntrinsicOp
:
:
I8VecMul
)
)
{
return
false
;
}
if
(
!
encoder
.
writeOp
(
Op
:
:
End
)
)
{
return
false
;
}
return
true
;
}
bool
wasm
:
:
CompileIntrinsicModule
(
JSContext
*
cx
IntrinsicOp
op
MutableHandleWasmModuleObject
result
)
{
const
Intrinsic
&
intrinsic
=
Intrinsic
:
:
getFromOp
(
op
)
;
FeatureOptions
featureOptions
;
featureOptions
.
intrinsics
=
true
;
SharedCompileArgs
compileArgs
=
CompileArgs
:
:
build
(
cx
ScriptedCaller
(
)
featureOptions
)
;
CompilerEnvironment
compilerEnv
(
CompileMode
:
:
Once
IonAvailable
(
cx
)
?
Tier
:
:
Optimized
:
Tier
:
:
Baseline
OptimizedBackend
:
:
Ion
DebugEnabled
:
:
False
)
;
compilerEnv
.
computeParameters
(
)
;
ModuleEnvironment
moduleEnv
(
compileArgs
-
>
features
)
;
UniqueChars
emptyString
=
DuplicateString
(
"
"
)
;
UniqueChars
memoryString
=
DuplicateString
(
"
memory
"
)
;
if
(
!
emptyString
|
|
!
memoryString
|
|
!
moduleEnv
.
imports
.
append
(
Import
(
std
:
:
move
(
emptyString
)
std
:
:
move
(
memoryString
)
DefinitionKind
:
:
Memory
)
)
)
{
return
false
;
}
moduleEnv
.
memory
=
Some
(
MemoryDesc
(
Limits
(
0
)
)
)
;
FuncType
type
;
if
(
!
intrinsic
.
funcType
(
&
type
)
|
|
!
moduleEnv
.
types
.
append
(
TypeDef
(
std
:
:
move
(
type
)
)
)
|
|
!
moduleEnv
.
typeIds
.
append
(
TypeIdDesc
(
)
)
)
{
return
false
;
}
FuncDesc
decl
(
&
moduleEnv
.
types
[
0
]
.
funcType
(
)
&
moduleEnv
.
typeIds
[
0
]
0
)
;
if
(
!
moduleEnv
.
funcs
.
append
(
decl
)
)
{
return
false
;
}
moduleEnv
.
declareFuncExported
(
0
true
false
)
;
Bytes
intrinsicBody
;
if
(
!
EncodeIntrinsicBody
(
intrinsic
&
intrinsicBody
)
)
{
return
false
;
}
UniqueChars
exportString
=
DuplicateString
(
intrinsic
.
exportName
)
;
if
(
!
exportString
|
|
!
moduleEnv
.
exports
.
append
(
Export
(
std
:
:
move
(
exportString
)
0
DefinitionKind
:
:
Function
)
)
)
{
return
false
;
}
UniqueChars
error
;
ModuleGenerator
mg
(
*
compileArgs
&
moduleEnv
&
compilerEnv
nullptr
&
error
)
;
if
(
!
mg
.
init
(
nullptr
)
|
|
!
mg
.
compileFuncDef
(
0
0
intrinsicBody
.
begin
(
)
intrinsicBody
.
begin
(
)
+
intrinsicBody
.
length
(
)
)
|
|
!
mg
.
finishFuncDefs
(
)
)
{
MOZ_ASSERT
(
!
error
)
;
return
false
;
}
SharedBytes
bytecode
=
js_new
<
ShareableBytes
>
(
)
;
SharedModule
module
=
mg
.
finishModule
(
*
bytecode
nullptr
)
;
if
(
!
module
)
{
return
false
;
}
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreatePrototype
(
cx
JSProto_WasmModule
)
)
;
if
(
!
proto
)
{
return
false
;
}
result
.
set
(
WasmModuleObject
:
:
create
(
cx
*
module
proto
)
)
;
return
!
!
result
;
}
