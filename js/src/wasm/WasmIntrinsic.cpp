#
include
"
wasm
/
WasmIntrinsic
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
wasm
/
WasmGenerator
.
h
"
#
include
"
wasm
/
WasmIntrinsicGenerated
.
h
"
#
include
"
wasm
/
WasmJS
.
h
"
#
include
"
wasm
/
WasmModule
.
h
"
#
include
"
wasm
/
WasmOpIter
.
h
"
#
include
"
wasm
/
WasmValidate
.
h
"
using
namespace
js
;
using
namespace
js
:
:
wasm
;
#
define
INTR_DECL
(
op
export
sa_name
abitype
entry
idx
)
\
static
const
ValType
Intrinsic
#
#
op
#
#
_Params
[
]
=
\
DECLARE_INTRINSIC_SAS_PARAM_VALTYPES_
#
#
op
;
\
\
const
Intrinsic
Intrinsic
#
#
op
=
{
\
export
\
mozilla
:
:
Span
<
const
ValType
>
(
Intrinsic
#
#
op
#
#
_Params
)
\
SASig
#
#
sa_name
\
}
;
FOR_EACH_INTRINSIC
(
INTR_DECL
)
#
undef
INTR_DECL
bool
Intrinsic
:
:
funcType
(
FuncType
*
type
)
const
{
ValTypeVector
paramVec
;
if
(
!
paramVec
.
append
(
params
.
data
(
)
params
.
data
(
)
+
params
.
size
(
)
)
)
{
return
false
;
}
*
type
=
FuncType
(
std
:
:
move
(
paramVec
)
ValTypeVector
(
)
)
;
return
true
;
}
const
Intrinsic
&
Intrinsic
:
:
getFromId
(
IntrinsicId
id
)
{
switch
(
id
)
{
#
define
OP
(
op
export
sa_name
abitype
entry
idx
)
\
case
IntrinsicId
:
:
op
:
\
return
Intrinsic
#
#
op
;
FOR_EACH_INTRINSIC
(
OP
)
#
undef
OP
default
:
MOZ_CRASH
(
"
unexpected
intrinsic
"
)
;
}
}
bool
EncodeIntrinsicBody
(
const
Intrinsic
&
intrinsic
IntrinsicId
id
Bytes
*
body
)
{
Encoder
encoder
(
*
body
)
;
if
(
!
EncodeLocalEntries
(
encoder
ValTypeVector
(
)
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
intrinsic
.
params
.
size
(
)
;
i
+
+
)
{
if
(
!
encoder
.
writeOp
(
Op
:
:
LocalGet
)
|
|
!
encoder
.
writeVarU32
(
i
)
)
{
return
false
;
}
}
if
(
!
encoder
.
writeOp
(
MozOp
:
:
Intrinsic
)
)
{
return
false
;
}
if
(
!
encoder
.
writeVarU32
(
uint32_t
(
id
)
)
)
{
return
false
;
}
if
(
!
encoder
.
writeOp
(
Op
:
:
End
)
)
{
return
false
;
}
return
true
;
}
bool
wasm
:
:
CompileIntrinsicModule
(
JSContext
*
cx
const
mozilla
:
:
Span
<
IntrinsicId
>
ids
Shareable
sharedMemory
MutableHandleWasmModuleObject
result
)
{
FeatureOptions
featureOptions
;
featureOptions
.
intrinsics
=
true
;
SharedCompileArgs
compileArgs
=
CompileArgs
:
:
build
(
cx
ScriptedCaller
(
)
featureOptions
)
;
if
(
!
compileArgs
)
{
return
false
;
}
CompilerEnvironment
compilerEnv
(
CompileMode
:
:
Once
IonAvailable
(
cx
)
?
Tier
:
:
Optimized
:
Tier
:
:
Baseline
OptimizedBackend
:
:
Ion
DebugEnabled
:
:
False
)
;
compilerEnv
.
computeParameters
(
)
;
ModuleEnvironment
moduleEnv
(
compileArgs
-
>
features
)
;
UniqueChars
emptyString
=
DuplicateString
(
"
"
)
;
UniqueChars
memoryString
=
DuplicateString
(
"
memory
"
)
;
if
(
!
emptyString
|
|
!
memoryString
|
|
!
moduleEnv
.
imports
.
append
(
Import
(
std
:
:
move
(
emptyString
)
std
:
:
move
(
memoryString
)
DefinitionKind
:
:
Memory
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
moduleEnv
.
memory
=
Some
(
MemoryDesc
(
Limits
(
0
Nothing
(
)
sharedMemory
)
)
)
;
if
(
!
moduleEnv
.
initTypes
(
ids
.
size
(
)
)
)
{
return
false
;
}
for
(
uint32_t
funcIndex
=
0
;
funcIndex
<
ids
.
size
(
)
;
funcIndex
+
+
)
{
const
IntrinsicId
&
id
=
ids
[
funcIndex
]
;
const
Intrinsic
&
intrinsic
=
Intrinsic
:
:
getFromId
(
id
)
;
FuncType
type
;
if
(
!
intrinsic
.
funcType
(
&
type
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
(
*
moduleEnv
.
types
)
[
funcIndex
]
=
TypeDef
(
std
:
:
move
(
type
)
)
;
}
for
(
uint32_t
funcIndex
=
0
;
funcIndex
<
ids
.
size
(
)
;
funcIndex
+
+
)
{
FuncDesc
decl
(
&
(
*
moduleEnv
.
types
)
[
funcIndex
]
.
funcType
(
)
&
moduleEnv
.
typeIds
[
funcIndex
]
funcIndex
)
;
if
(
!
moduleEnv
.
funcs
.
append
(
decl
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
moduleEnv
.
declareFuncExported
(
funcIndex
true
false
)
;
}
for
(
uint32_t
funcIndex
=
0
;
funcIndex
<
ids
.
size
(
)
;
funcIndex
+
+
)
{
const
Intrinsic
&
intrinsic
=
Intrinsic
:
:
getFromId
(
ids
[
funcIndex
]
)
;
UniqueChars
exportString
=
DuplicateString
(
intrinsic
.
exportName
)
;
if
(
!
exportString
|
|
!
moduleEnv
.
exports
.
append
(
Export
(
std
:
:
move
(
exportString
)
funcIndex
DefinitionKind
:
:
Function
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
UniqueChars
error
;
ModuleGenerator
mg
(
*
compileArgs
&
moduleEnv
&
compilerEnv
nullptr
&
error
nullptr
)
;
if
(
!
mg
.
init
(
nullptr
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
Vector
<
Bytes
1
SystemAllocPolicy
>
bodies
;
if
(
!
bodies
.
reserve
(
ids
.
size
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
for
(
uint32_t
funcIndex
=
0
;
funcIndex
<
ids
.
size
(
)
;
funcIndex
+
+
)
{
IntrinsicId
id
=
ids
[
funcIndex
]
;
const
Intrinsic
&
intrinsic
=
Intrinsic
:
:
getFromId
(
ids
[
funcIndex
]
)
;
bodies
.
infallibleAppend
(
Bytes
(
)
)
;
Bytes
&
bytecode
=
bodies
.
back
(
)
;
if
(
!
EncodeIntrinsicBody
(
intrinsic
id
&
bytecode
)
|
|
!
mg
.
compileFuncDef
(
funcIndex
0
bytecode
.
begin
(
)
bytecode
.
begin
(
)
+
bytecode
.
length
(
)
)
)
{
MOZ_ASSERT
(
!
error
)
;
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
if
(
!
mg
.
finishFuncDefs
(
)
)
{
MOZ_ASSERT
(
!
error
)
;
ReportOutOfMemory
(
cx
)
;
return
false
;
}
SharedBytes
bytecode
=
js_new
<
ShareableBytes
>
(
)
;
SharedModule
module
=
mg
.
finishModule
(
*
bytecode
nullptr
)
;
if
(
!
module
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreatePrototype
(
cx
JSProto_WasmModule
)
)
;
if
(
!
proto
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
result
.
set
(
WasmModuleObject
:
:
create
(
cx
*
module
proto
)
)
;
return
!
!
result
;
}
