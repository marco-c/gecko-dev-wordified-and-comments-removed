#
include
"
wasm
/
WasmStubs
.
h
"
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
<
type_traits
>
#
include
"
jit
/
ABIArgGenerator
.
h
"
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
jit
/
RegisterAllocator
.
h
"
#
include
"
js
/
Printf
.
h
"
#
include
"
util
/
Memory
.
h
"
#
include
"
wasm
/
WasmCode
.
h
"
#
include
"
wasm
/
WasmGenerator
.
h
"
#
include
"
wasm
/
WasmInstance
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
#
include
"
wasm
/
WasmInstance
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
using
MIRTypeVector
=
Vector
<
jit
:
:
MIRType
8
SystemAllocPolicy
>
;
using
ABIArgMIRTypeIter
=
jit
:
:
ABIArgIter
<
MIRTypeVector
>
;
static
uint32_t
ResultStackSize
(
ValType
type
)
{
switch
(
type
.
kind
(
)
)
{
case
ValType
:
:
I32
:
return
ABIResult
:
:
StackSizeOfInt32
;
case
ValType
:
:
I64
:
return
ABIResult
:
:
StackSizeOfInt64
;
case
ValType
:
:
F32
:
return
ABIResult
:
:
StackSizeOfFloat
;
case
ValType
:
:
F64
:
return
ABIResult
:
:
StackSizeOfDouble
;
#
ifdef
ENABLE_WASM_SIMD
case
ValType
:
:
V128
:
return
ABIResult
:
:
StackSizeOfV128
;
#
endif
case
ValType
:
:
Ref
:
return
ABIResult
:
:
StackSizeOfPtr
;
default
:
MOZ_CRASH
(
"
Unexpected
result
type
"
)
;
}
}
uint32_t
js
:
:
wasm
:
:
MIRTypeToABIResultSize
(
jit
:
:
MIRType
type
)
{
switch
(
type
)
{
case
MIRType
:
:
Int32
:
return
ABIResult
:
:
StackSizeOfInt32
;
case
MIRType
:
:
Int64
:
return
ABIResult
:
:
StackSizeOfInt64
;
case
MIRType
:
:
Float32
:
return
ABIResult
:
:
StackSizeOfFloat
;
case
MIRType
:
:
Double
:
return
ABIResult
:
:
StackSizeOfDouble
;
#
ifdef
ENABLE_WASM_SIMD
case
MIRType
:
:
Simd128
:
return
ABIResult
:
:
StackSizeOfV128
;
#
endif
case
MIRType
:
:
Pointer
:
case
MIRType
:
:
RefOrNull
:
return
ABIResult
:
:
StackSizeOfPtr
;
default
:
MOZ_CRASH
(
"
MIRTypeToABIResultSize
-
unhandled
case
"
)
;
}
}
uint32_t
ABIResult
:
:
size
(
)
const
{
return
ResultStackSize
(
type
(
)
)
;
}
void
ABIResultIter
:
:
settleRegister
(
ValType
type
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT_IF
(
direction_
=
=
Next
index
(
)
<
MaxRegisterResults
)
;
MOZ_ASSERT_IF
(
direction_
=
=
Prev
index
(
)
>
=
count_
-
MaxRegisterResults
)
;
static_assert
(
MaxRegisterResults
=
=
1
"
expected
a
single
register
result
"
)
;
switch
(
type
.
kind
(
)
)
{
case
ValType
:
:
I32
:
cur_
=
ABIResult
(
type
ReturnReg
)
;
break
;
case
ValType
:
:
I64
:
cur_
=
ABIResult
(
type
ReturnReg64
)
;
break
;
case
ValType
:
:
F32
:
cur_
=
ABIResult
(
type
ReturnFloat32Reg
)
;
break
;
case
ValType
:
:
F64
:
cur_
=
ABIResult
(
type
ReturnDoubleReg
)
;
break
;
case
ValType
:
:
Ref
:
cur_
=
ABIResult
(
type
ReturnReg
)
;
break
;
#
ifdef
ENABLE_WASM_SIMD
case
ValType
:
:
V128
:
cur_
=
ABIResult
(
type
ReturnSimd128Reg
)
;
break
;
#
endif
default
:
MOZ_CRASH
(
"
Unexpected
result
type
"
)
;
}
}
void
ABIResultIter
:
:
settleNext
(
)
{
MOZ_ASSERT
(
direction_
=
=
Next
)
;
MOZ_ASSERT
(
!
done
(
)
)
;
uint32_t
typeIndex
=
count_
-
index_
-
1
;
ValType
type
=
type_
[
typeIndex
]
;
if
(
index_
<
MaxRegisterResults
)
{
settleRegister
(
type
)
;
return
;
}
cur_
=
ABIResult
(
type
nextStackOffset_
)
;
nextStackOffset_
+
=
ResultStackSize
(
type
)
;
}
void
ABIResultIter
:
:
settlePrev
(
)
{
MOZ_ASSERT
(
direction_
=
=
Prev
)
;
MOZ_ASSERT
(
!
done
(
)
)
;
uint32_t
typeIndex
=
index_
;
ValType
type
=
type_
[
typeIndex
]
;
if
(
count_
-
index_
-
1
<
MaxRegisterResults
)
{
settleRegister
(
type
)
;
return
;
}
uint32_t
size
=
ResultStackSize
(
type
)
;
MOZ_ASSERT
(
nextStackOffset_
>
=
size
)
;
nextStackOffset_
-
=
size
;
cur_
=
ABIResult
(
type
nextStackOffset_
)
;
}
#
ifdef
WASM_CODEGEN_DEBUG
template
<
class
Closure
>
static
void
GenPrint
(
DebugChannel
channel
MacroAssembler
&
masm
const
Maybe
<
Register
>
&
taken
Closure
passArgAndCall
)
{
if
(
!
IsCodegenDebugEnabled
(
channel
)
)
{
return
;
}
AllocatableRegisterSet
regs
(
RegisterSet
:
:
All
(
)
)
;
LiveRegisterSet
save
(
regs
.
asLiveSet
(
)
)
;
masm
.
PushRegsInMask
(
save
)
;
if
(
taken
)
{
regs
.
take
(
taken
.
value
(
)
)
;
}
Register
temp
=
regs
.
takeAnyGeneral
(
)
;
{
MOZ_ASSERT
(
MaybeGetJitContext
(
)
"
codegen
debug
checks
require
a
jit
context
"
)
;
masm
.
setupUnalignedABICall
(
temp
)
;
passArgAndCall
(
IsCompilingWasm
(
)
temp
)
;
}
masm
.
PopRegsInMask
(
save
)
;
}
static
void
GenPrintf
(
DebugChannel
channel
MacroAssembler
&
masm
const
char
*
fmt
.
.
.
)
{
va_list
ap
;
va_start
(
ap
fmt
)
;
UniqueChars
str
=
JS_vsmprintf
(
fmt
ap
)
;
va_end
(
ap
)
;
GenPrint
(
channel
masm
Nothing
(
)
[
&
]
(
bool
inWasm
Register
temp
)
{
const
char
*
text
=
str
.
release
(
)
;
masm
.
movePtr
(
ImmPtr
(
(
void
*
)
text
ImmPtr
:
:
NoCheckToken
(
)
)
temp
)
;
masm
.
passABIArg
(
temp
)
;
if
(
inWasm
)
{
masm
.
callDebugWithABI
(
SymbolicAddress
:
:
PrintText
)
;
}
else
{
using
Fn
=
void
(
*
)
(
const
char
*
output
)
;
masm
.
callWithABI
<
Fn
PrintText
>
(
MoveOp
:
:
GENERAL
CheckUnsafeCallWithABI
:
:
DontCheckOther
)
;
}
}
)
;
}
static
void
GenPrintIsize
(
DebugChannel
channel
MacroAssembler
&
masm
const
Register
&
src
)
{
GenPrint
(
channel
masm
Some
(
src
)
[
&
]
(
bool
inWasm
Register
_temp
)
{
masm
.
passABIArg
(
src
)
;
if
(
inWasm
)
{
masm
.
callDebugWithABI
(
SymbolicAddress
:
:
PrintI32
)
;
}
else
{
using
Fn
=
void
(
*
)
(
int32_t
val
)
;
masm
.
callWithABI
<
Fn
PrintI32
>
(
MoveOp
:
:
GENERAL
CheckUnsafeCallWithABI
:
:
DontCheckOther
)
;
}
}
)
;
}
static
void
GenPrintPtr
(
DebugChannel
channel
MacroAssembler
&
masm
const
Register
&
src
)
{
GenPrint
(
channel
masm
Some
(
src
)
[
&
]
(
bool
inWasm
Register
_temp
)
{
masm
.
passABIArg
(
src
)
;
if
(
inWasm
)
{
masm
.
callDebugWithABI
(
SymbolicAddress
:
:
PrintPtr
)
;
}
else
{
using
Fn
=
void
(
*
)
(
uint8_t
*
val
)
;
masm
.
callWithABI
<
Fn
PrintPtr
>
(
MoveOp
:
:
GENERAL
CheckUnsafeCallWithABI
:
:
DontCheckOther
)
;
}
}
)
;
}
static
void
GenPrintI64
(
DebugChannel
channel
MacroAssembler
&
masm
const
Register64
&
src
)
{
#
if
JS_BITS_PER_WORD
=
=
64
GenPrintf
(
channel
masm
"
i64
"
)
;
GenPrintIsize
(
channel
masm
src
.
reg
)
;
#
else
GenPrintf
(
channel
masm
"
i64
(
"
)
;
GenPrintIsize
(
channel
masm
src
.
low
)
;
GenPrintIsize
(
channel
masm
src
.
high
)
;
GenPrintf
(
channel
masm
"
)
"
)
;
#
endif
}
static
void
GenPrintF32
(
DebugChannel
channel
MacroAssembler
&
masm
const
FloatRegister
&
src
)
{
GenPrint
(
channel
masm
Nothing
(
)
[
&
]
(
bool
inWasm
Register
temp
)
{
masm
.
passABIArg
(
src
MoveOp
:
:
FLOAT32
)
;
if
(
inWasm
)
{
masm
.
callDebugWithABI
(
SymbolicAddress
:
:
PrintF32
)
;
}
else
{
using
Fn
=
void
(
*
)
(
float
val
)
;
masm
.
callWithABI
<
Fn
PrintF32
>
(
MoveOp
:
:
GENERAL
CheckUnsafeCallWithABI
:
:
DontCheckOther
)
;
}
}
)
;
}
static
void
GenPrintF64
(
DebugChannel
channel
MacroAssembler
&
masm
const
FloatRegister
&
src
)
{
GenPrint
(
channel
masm
Nothing
(
)
[
&
]
(
bool
inWasm
Register
temp
)
{
masm
.
passABIArg
(
src
MoveOp
:
:
DOUBLE
)
;
if
(
inWasm
)
{
masm
.
callDebugWithABI
(
SymbolicAddress
:
:
PrintF64
)
;
}
else
{
using
Fn
=
void
(
*
)
(
double
val
)
;
masm
.
callWithABI
<
Fn
PrintF64
>
(
MoveOp
:
:
GENERAL
CheckUnsafeCallWithABI
:
:
DontCheckOther
)
;
}
}
)
;
}
#
ifdef
ENABLE_WASM_SIMD
static
void
GenPrintV128
(
DebugChannel
channel
MacroAssembler
&
masm
const
FloatRegister
&
src
)
{
GenPrintf
(
channel
masm
"
v128
"
)
;
}
#
endif
#
else
static
void
GenPrintf
(
DebugChannel
channel
MacroAssembler
&
masm
const
char
*
fmt
.
.
.
)
{
}
static
void
GenPrintIsize
(
DebugChannel
channel
MacroAssembler
&
masm
const
Register
&
src
)
{
}
static
void
GenPrintPtr
(
DebugChannel
channel
MacroAssembler
&
masm
const
Register
&
src
)
{
}
static
void
GenPrintI64
(
DebugChannel
channel
MacroAssembler
&
masm
const
Register64
&
src
)
{
}
static
void
GenPrintF32
(
DebugChannel
channel
MacroAssembler
&
masm
const
FloatRegister
&
src
)
{
}
static
void
GenPrintF64
(
DebugChannel
channel
MacroAssembler
&
masm
const
FloatRegister
&
src
)
{
}
#
ifdef
ENABLE_WASM_SIMD
static
void
GenPrintV128
(
DebugChannel
channel
MacroAssembler
&
masm
const
FloatRegister
&
src
)
{
}
#
endif
#
endif
static
bool
FinishOffsets
(
MacroAssembler
&
masm
Offsets
*
offsets
)
{
masm
.
flushBuffer
(
)
;
offsets
-
>
end
=
masm
.
size
(
)
;
return
!
masm
.
oom
(
)
;
}
static
void
AssertStackAlignment
(
MacroAssembler
&
masm
uint32_t
alignment
uint32_t
addBeforeAssert
=
0
)
{
MOZ_ASSERT
(
(
sizeof
(
Frame
)
+
masm
.
framePushed
(
)
+
addBeforeAssert
)
%
alignment
=
=
0
)
;
masm
.
assertStackAlignment
(
alignment
addBeforeAssert
)
;
}
template
<
class
VectorT
template
<
class
VecT
>
class
ABIArgIterT
>
static
unsigned
StackArgBytesHelper
(
const
VectorT
&
args
)
{
ABIArgIterT
<
VectorT
>
iter
(
args
)
;
while
(
!
iter
.
done
(
)
)
{
iter
+
+
;
}
return
iter
.
stackBytesConsumedSoFar
(
)
;
}
template
<
class
VectorT
>
static
unsigned
StackArgBytesForNativeABI
(
const
VectorT
&
args
)
{
return
StackArgBytesHelper
<
VectorT
ABIArgIter
>
(
args
)
;
}
template
<
class
VectorT
>
static
unsigned
StackArgBytesForWasmABI
(
const
VectorT
&
args
)
{
return
StackArgBytesHelper
<
VectorT
WasmABIArgIter
>
(
args
)
;
}
static
unsigned
StackArgBytesForWasmABI
(
const
FuncType
&
funcType
)
{
ArgTypeVector
args
(
funcType
)
;
return
StackArgBytesForWasmABI
(
args
)
;
}
static
void
Move64
(
MacroAssembler
&
masm
const
Address
&
src
const
Address
&
dest
Register
scratch
)
{
#
if
JS_BITS_PER_WORD
=
=
32
MOZ_RELEASE_ASSERT
(
src
.
base
!
=
scratch
&
&
dest
.
base
!
=
scratch
)
;
masm
.
load32
(
LowWord
(
src
)
scratch
)
;
masm
.
store32
(
scratch
LowWord
(
dest
)
)
;
masm
.
load32
(
HighWord
(
src
)
scratch
)
;
masm
.
store32
(
scratch
HighWord
(
dest
)
)
;
#
else
Register64
scratch64
(
scratch
)
;
masm
.
load64
(
src
scratch64
)
;
masm
.
store64
(
scratch64
dest
)
;
#
endif
}
static
void
SetupABIArguments
(
MacroAssembler
&
masm
const
FuncExport
&
fe
const
FuncType
&
funcType
Register
argv
Register
scratch
)
{
ArgTypeVector
args
(
funcType
)
;
for
(
WasmABIArgIter
iter
(
args
)
;
!
iter
.
done
(
)
;
iter
+
+
)
{
unsigned
argOffset
=
iter
.
index
(
)
*
sizeof
(
ExportArg
)
;
Address
src
(
argv
argOffset
)
;
MIRType
type
=
iter
.
mirType
(
)
;
switch
(
iter
-
>
kind
(
)
)
{
case
ABIArg
:
:
GPR
:
if
(
type
=
=
MIRType
:
:
Int32
)
{
masm
.
load32
(
src
iter
-
>
gpr
(
)
)
;
}
else
if
(
type
=
=
MIRType
:
:
Int64
)
{
masm
.
load64
(
src
iter
-
>
gpr64
(
)
)
;
}
else
if
(
type
=
=
MIRType
:
:
RefOrNull
)
{
masm
.
loadPtr
(
src
iter
-
>
gpr
(
)
)
;
}
else
if
(
type
=
=
MIRType
:
:
StackResults
)
{
MOZ_ASSERT
(
args
.
isSyntheticStackResultPointerArg
(
iter
.
index
(
)
)
)
;
masm
.
loadPtr
(
src
iter
-
>
gpr
(
)
)
;
}
else
{
MOZ_CRASH
(
"
unknown
GPR
type
"
)
;
}
break
;
#
ifdef
JS_CODEGEN_REGISTER_PAIR
case
ABIArg
:
:
GPR_PAIR
:
if
(
type
=
=
MIRType
:
:
Int64
)
{
masm
.
load64
(
src
iter
-
>
gpr64
(
)
)
;
}
else
{
MOZ_CRASH
(
"
wasm
uses
hardfp
for
function
calls
.
"
)
;
}
break
;
#
endif
case
ABIArg
:
:
FPU
:
{
static_assert
(
sizeof
(
ExportArg
)
>
=
jit
:
:
Simd128DataSize
"
ExportArg
must
be
big
enough
to
store
SIMD
values
"
)
;
switch
(
type
)
{
case
MIRType
:
:
Double
:
masm
.
loadDouble
(
src
iter
-
>
fpu
(
)
)
;
break
;
case
MIRType
:
:
Float32
:
masm
.
loadFloat32
(
src
iter
-
>
fpu
(
)
)
;
break
;
case
MIRType
:
:
Simd128
:
#
ifdef
ENABLE_WASM_SIMD
masm
.
loadUnalignedSimd128
(
src
iter
-
>
fpu
(
)
)
;
break
;
#
else
MOZ_CRASH
(
"
V128
not
supported
in
SetupABIArguments
"
)
;
#
endif
default
:
MOZ_CRASH
(
"
unexpected
FPU
type
"
)
;
break
;
}
break
;
}
case
ABIArg
:
:
Stack
:
switch
(
type
)
{
case
MIRType
:
:
Int32
:
masm
.
load32
(
src
scratch
)
;
masm
.
storePtr
(
scratch
Address
(
masm
.
getStackPointer
(
)
iter
-
>
offsetFromArgBase
(
)
)
)
;
break
;
case
MIRType
:
:
Int64
:
{
RegisterOrSP
sp
=
masm
.
getStackPointer
(
)
;
Move64
(
masm
src
Address
(
sp
iter
-
>
offsetFromArgBase
(
)
)
scratch
)
;
break
;
}
case
MIRType
:
:
RefOrNull
:
masm
.
loadPtr
(
src
scratch
)
;
masm
.
storePtr
(
scratch
Address
(
masm
.
getStackPointer
(
)
iter
-
>
offsetFromArgBase
(
)
)
)
;
break
;
case
MIRType
:
:
Double
:
{
ScratchDoubleScope
fpscratch
(
masm
)
;
masm
.
loadDouble
(
src
fpscratch
)
;
masm
.
storeDouble
(
fpscratch
Address
(
masm
.
getStackPointer
(
)
iter
-
>
offsetFromArgBase
(
)
)
)
;
break
;
}
case
MIRType
:
:
Float32
:
{
ScratchFloat32Scope
fpscratch
(
masm
)
;
masm
.
loadFloat32
(
src
fpscratch
)
;
masm
.
storeFloat32
(
fpscratch
Address
(
masm
.
getStackPointer
(
)
iter
-
>
offsetFromArgBase
(
)
)
)
;
break
;
}
case
MIRType
:
:
Simd128
:
{
#
ifdef
ENABLE_WASM_SIMD
ScratchSimd128Scope
fpscratch
(
masm
)
;
masm
.
loadUnalignedSimd128
(
src
fpscratch
)
;
masm
.
storeUnalignedSimd128
(
fpscratch
Address
(
masm
.
getStackPointer
(
)
iter
-
>
offsetFromArgBase
(
)
)
)
;
break
;
#
else
MOZ_CRASH
(
"
V128
not
supported
in
SetupABIArguments
"
)
;
#
endif
}
case
MIRType
:
:
StackResults
:
{
MOZ_ASSERT
(
args
.
isSyntheticStackResultPointerArg
(
iter
.
index
(
)
)
)
;
masm
.
loadPtr
(
src
scratch
)
;
masm
.
storePtr
(
scratch
Address
(
masm
.
getStackPointer
(
)
iter
-
>
offsetFromArgBase
(
)
)
)
;
break
;
}
default
:
MOZ_CRASH
(
"
unexpected
stack
arg
type
"
)
;
}
break
;
case
ABIArg
:
:
Uninitialized
:
MOZ_CRASH
(
"
Uninitialized
ABIArg
kind
"
)
;
}
}
}
static
void
StoreRegisterResult
(
MacroAssembler
&
masm
const
FuncExport
&
fe
const
FuncType
&
funcType
Register
loc
)
{
ResultType
results
=
ResultType
:
:
Vector
(
funcType
.
results
(
)
)
;
DebugOnly
<
bool
>
sawRegisterResult
=
false
;
for
(
ABIResultIter
iter
(
results
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
ABIResult
&
result
=
iter
.
cur
(
)
;
if
(
result
.
inRegister
(
)
)
{
MOZ_ASSERT
(
!
sawRegisterResult
)
;
sawRegisterResult
=
true
;
switch
(
result
.
type
(
)
.
kind
(
)
)
{
case
ValType
:
:
I32
:
masm
.
store32
(
result
.
gpr
(
)
Address
(
loc
0
)
)
;
break
;
case
ValType
:
:
I64
:
masm
.
store64
(
result
.
gpr64
(
)
Address
(
loc
0
)
)
;
break
;
case
ValType
:
:
V128
:
#
ifdef
ENABLE_WASM_SIMD
masm
.
storeUnalignedSimd128
(
result
.
fpr
(
)
Address
(
loc
0
)
)
;
break
;
#
else
MOZ_CRASH
(
"
V128
not
supported
in
StoreABIReturn
"
)
;
#
endif
case
ValType
:
:
F32
:
masm
.
canonicalizeFloat
(
result
.
fpr
(
)
)
;
masm
.
storeFloat32
(
result
.
fpr
(
)
Address
(
loc
0
)
)
;
break
;
case
ValType
:
:
F64
:
masm
.
canonicalizeDouble
(
result
.
fpr
(
)
)
;
masm
.
storeDouble
(
result
.
fpr
(
)
Address
(
loc
0
)
)
;
break
;
case
ValType
:
:
Ref
:
masm
.
storePtr
(
result
.
gpr
(
)
Address
(
loc
0
)
)
;
break
;
}
}
}
MOZ_ASSERT
(
sawRegisterResult
=
=
(
results
.
length
(
)
>
0
)
)
;
}
#
if
defined
(
JS_CODEGEN_ARM
)
static
const
LiveRegisterSet
NonVolatileRegs
=
LiveRegisterSet
(
GeneralRegisterSet
(
Registers
:
:
NonVolatileMask
&
~
(
Registers
:
:
SetType
(
1
)
<
<
Registers
:
:
lr
)
)
FloatRegisterSet
(
FloatRegisters
:
:
NonVolatileMask
|
(
FloatRegisters
:
:
SetType
(
1
)
<
<
FloatRegisters
:
:
d15
)
|
(
FloatRegisters
:
:
SetType
(
1
)
<
<
FloatRegisters
:
:
s31
)
)
)
;
#
elif
defined
(
JS_CODEGEN_ARM64
)
static
const
LiveRegisterSet
NonVolatileRegs
=
LiveRegisterSet
(
GeneralRegisterSet
(
(
Registers
:
:
NonVolatileMask
&
~
(
Registers
:
:
SetType
(
1
)
<
<
Registers
:
:
lr
)
)
|
(
Registers
:
:
SetType
(
1
)
<
<
Registers
:
:
x16
)
)
FloatRegisterSet
(
FloatRegisters
:
:
NonVolatileMask
|
FloatRegisters
:
:
NonAllocatableMask
)
)
;
#
else
static
const
LiveRegisterSet
NonVolatileRegs
=
LiveRegisterSet
(
GeneralRegisterSet
(
Registers
:
:
NonVolatileMask
)
FloatRegisterSet
(
FloatRegisters
:
:
NonVolatileMask
)
)
;
#
endif
static
const
unsigned
NumExtraPushed
=
2
;
#
ifdef
JS_CODEGEN_ARM64
static
const
unsigned
WasmPushSize
=
16
;
#
else
static
const
unsigned
WasmPushSize
=
sizeof
(
void
*
)
;
#
endif
static
void
AssertExpectedSP
(
MacroAssembler
&
masm
)
{
#
ifdef
JS_CODEGEN_ARM64
MOZ_ASSERT
(
sp
.
Is
(
masm
.
GetStackPointer64
(
)
)
)
;
#
ifdef
DEBUG
masm
.
asVIXL
(
)
.
Mov
(
PseudoStackPointer64
1
)
;
#
endif
#
endif
}
template
<
class
Operand
>
static
void
WasmPush
(
MacroAssembler
&
masm
const
Operand
&
op
)
{
#
ifdef
JS_CODEGEN_ARM64
masm
.
reserveStack
(
WasmPushSize
)
;
masm
.
storePtr
(
op
Address
(
masm
.
getStackPointer
(
)
0
)
)
;
#
else
masm
.
Push
(
op
)
;
#
endif
}
static
void
WasmPop
(
MacroAssembler
&
masm
Register
r
)
{
#
ifdef
JS_CODEGEN_ARM64
masm
.
loadPtr
(
Address
(
masm
.
getStackPointer
(
)
0
)
r
)
;
masm
.
freeStack
(
WasmPushSize
)
;
#
else
masm
.
Pop
(
r
)
;
#
endif
}
static
void
MoveSPForJitABI
(
MacroAssembler
&
masm
)
{
#
ifdef
JS_CODEGEN_ARM64
masm
.
moveStackPtrTo
(
PseudoStackPointer
)
;
#
endif
}
static
void
CallFuncExport
(
MacroAssembler
&
masm
const
FuncExport
&
fe
const
Maybe
<
ImmPtr
>
&
funcPtr
)
{
MOZ_ASSERT
(
fe
.
hasEagerStubs
(
)
=
=
!
funcPtr
)
;
MoveSPForJitABI
(
masm
)
;
if
(
funcPtr
)
{
masm
.
call
(
*
funcPtr
)
;
}
else
{
masm
.
call
(
CallSiteDesc
(
CallSiteDesc
:
:
Func
)
fe
.
funcIndex
(
)
)
;
}
}
STATIC_ASSERT_ANYREF_IS_JSOBJECT
;
static
void
UnboxAnyrefIntoValue
(
MacroAssembler
&
masm
Register
instance
Register
src
const
Address
&
dst
Register
scratch
)
{
MOZ_ASSERT
(
src
!
=
scratch
)
;
GenPrintPtr
(
DebugChannel
:
:
Import
masm
src
)
;
Label
notNull
mustUnbox
done
;
masm
.
branchTestPtr
(
Assembler
:
:
NonZero
src
src
&
notNull
)
;
masm
.
storeValue
(
NullValue
(
)
dst
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
notNull
)
;
masm
.
storeValue
(
JSVAL_TYPE_OBJECT
src
dst
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
Equal
src
Address
(
instance
Instance
:
:
offsetOfValueBoxClass
(
)
)
scratch
src
&
mustUnbox
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
mustUnbox
)
;
Move64
(
masm
Address
(
src
WasmValueBox
:
:
offsetOfValue
(
)
)
dst
scratch
)
;
masm
.
bind
(
&
done
)
;
}
static
void
UnboxAnyrefIntoValueReg
(
MacroAssembler
&
masm
Register
instance
Register
src
ValueOperand
dst
Register
scratch
)
{
MOZ_ASSERT
(
src
!
=
scratch
)
;
#
if
JS_BITS_PER_WORD
=
=
32
MOZ_ASSERT
(
dst
.
typeReg
(
)
!
=
scratch
)
;
MOZ_ASSERT
(
dst
.
payloadReg
(
)
!
=
scratch
)
;
#
else
MOZ_ASSERT
(
dst
.
valueReg
(
)
!
=
scratch
)
;
#
endif
GenPrintPtr
(
DebugChannel
:
:
Import
masm
src
)
;
Label
notNull
mustUnbox
done
;
masm
.
branchTestPtr
(
Assembler
:
:
NonZero
src
src
&
notNull
)
;
masm
.
moveValue
(
NullValue
(
)
dst
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
notNull
)
;
masm
.
moveValue
(
TypedOrValueRegister
(
MIRType
:
:
Object
AnyRegister
(
src
)
)
dst
)
;
masm
.
branchTestObjClass
(
Assembler
:
:
Equal
src
Address
(
instance
Instance
:
:
offsetOfValueBoxClass
(
)
)
scratch
src
&
mustUnbox
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
mustUnbox
)
;
masm
.
loadValue
(
Address
(
src
WasmValueBox
:
:
offsetOfValue
(
)
)
dst
)
;
masm
.
bind
(
&
done
)
;
}
static
void
BoxValueIntoAnyref
(
MacroAssembler
&
masm
ValueOperand
src
Register
dest
Label
*
oolConvert
)
{
Label
nullValue
objectValue
done
;
{
ScratchTagScope
tag
(
masm
src
)
;
masm
.
splitTagForTest
(
src
tag
)
;
masm
.
branchTestObject
(
Assembler
:
:
Equal
tag
&
objectValue
)
;
masm
.
branchTestNull
(
Assembler
:
:
Equal
tag
&
nullValue
)
;
masm
.
jump
(
oolConvert
)
;
}
masm
.
bind
(
&
nullValue
)
;
masm
.
xorPtr
(
dest
dest
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
objectValue
)
;
masm
.
unboxObject
(
src
dest
)
;
masm
.
bind
(
&
done
)
;
}
static
bool
GenerateInterpEntry
(
MacroAssembler
&
masm
const
FuncExport
&
fe
const
FuncType
&
funcType
const
Maybe
<
ImmPtr
>
&
funcPtr
Offsets
*
offsets
)
{
AutoCreatedBy
acb
(
masm
"
GenerateInterpEntry
"
)
;
AssertExpectedSP
(
masm
)
;
masm
.
haltingAlign
(
CodeAlignment
)
;
offsets
-
>
begin
=
masm
.
currentOffset
(
)
;
#
ifdef
JS_USE_LINK_REGISTER
#
if
defined
(
JS_CODEGEN_ARM
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
|
|
\
defined
(
JS_CODEGEN_LOONG64
)
masm
.
pushReturnAddress
(
)
;
#
elif
defined
(
JS_CODEGEN_ARM64
)
WasmPush
(
masm
lr
)
;
#
else
MOZ_CRASH
(
"
Implement
this
"
)
;
#
endif
#
endif
masm
.
setFramePushed
(
0
)
;
masm
.
PushRegsInMask
(
NonVolatileRegs
)
;
const
unsigned
nonVolatileRegsPushSize
=
masm
.
PushRegsInMaskSizeInBytes
(
NonVolatileRegs
)
;
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
nonVolatileRegsPushSize
)
;
Register
argv
=
ABINonArgReturnReg0
;
Register
scratch
=
ABINonArgReturnReg1
;
const
unsigned
argBase
=
sizeof
(
void
*
)
+
masm
.
framePushed
(
)
;
ABIArgGenerator
abi
;
ABIArg
arg
;
arg
=
abi
.
next
(
MIRType
:
:
Pointer
)
;
if
(
arg
.
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
masm
.
movePtr
(
arg
.
gpr
(
)
argv
)
;
}
else
{
masm
.
loadPtr
(
Address
(
masm
.
getStackPointer
(
)
argBase
+
arg
.
offsetFromArgBase
(
)
)
argv
)
;
}
arg
=
abi
.
next
(
MIRType
:
:
Pointer
)
;
if
(
arg
.
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
masm
.
movePtr
(
arg
.
gpr
(
)
InstanceReg
)
;
}
else
{
masm
.
loadPtr
(
Address
(
masm
.
getStackPointer
(
)
argBase
+
arg
.
offsetFromArgBase
(
)
)
InstanceReg
)
;
}
WasmPush
(
masm
InstanceReg
)
;
WasmPush
(
masm
argv
)
;
const
unsigned
framePushedBeforeAlign
=
nonVolatileRegsPushSize
+
NumExtraPushed
*
WasmPushSize
;
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
framePushedBeforeAlign
)
;
masm
.
setFramePushed
(
0
)
;
#
ifdef
JS_CODEGEN_ARM64
static_assert
(
WasmStackAlignment
=
=
16
"
ARM64
SP
alignment
"
)
;
#
else
masm
.
moveStackPtrTo
(
scratch
)
;
masm
.
andToStackPtr
(
Imm32
(
~
(
WasmStackAlignment
-
1
)
)
)
;
masm
.
Push
(
scratch
)
;
#
endif
unsigned
argDecrement
=
StackDecrementForCall
(
WasmStackAlignment
masm
.
framePushed
(
)
StackArgBytesForWasmABI
(
funcType
)
)
;
masm
.
reserveStack
(
argDecrement
)
;
SetupABIArguments
(
masm
fe
funcType
argv
scratch
)
;
masm
.
andPtr
(
Imm32
(
int32_t
(
~
ExitFPTag
)
)
FramePointer
)
;
masm
.
loadWasmPinnedRegsFromInstance
(
)
;
masm
.
storePtr
(
InstanceReg
Address
(
masm
.
getStackPointer
(
)
WasmCalleeInstanceOffsetBeforeCall
)
)
;
masm
.
assertStackAlignment
(
WasmStackAlignment
)
;
CallFuncExport
(
masm
fe
funcPtr
)
;
masm
.
assertStackAlignment
(
WasmStackAlignment
)
;
masm
.
freeStack
(
argDecrement
)
;
#
ifdef
JS_CODEGEN_ARM64
static_assert
(
WasmStackAlignment
=
=
16
"
ARM64
SP
alignment
"
)
;
#
else
masm
.
PopStackPtr
(
)
;
#
endif
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
0
)
;
masm
.
setFramePushed
(
framePushedBeforeAlign
)
;
WasmPop
(
masm
argv
)
;
WasmPop
(
masm
InstanceReg
)
;
StoreRegisterResult
(
masm
fe
funcType
argv
)
;
Label
success
join
;
masm
.
branchPtr
(
Assembler
:
:
NotEqual
FramePointer
Imm32
(
FailFP
)
&
success
)
;
masm
.
move32
(
Imm32
(
false
)
ReturnReg
)
;
masm
.
jump
(
&
join
)
;
masm
.
bind
(
&
success
)
;
masm
.
move32
(
Imm32
(
true
)
ReturnReg
)
;
masm
.
bind
(
&
join
)
;
masm
.
PopRegsInMask
(
NonVolatileRegs
)
;
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
0
)
;
#
if
defined
(
JS_CODEGEN_ARM64
)
masm
.
setFramePushed
(
WasmPushSize
)
;
WasmPop
(
masm
lr
)
;
masm
.
abiret
(
)
;
#
else
masm
.
ret
(
)
;
#
endif
return
FinishOffsets
(
masm
offsets
)
;
}
#
ifdef
JS_PUNBOX64
static
const
ValueOperand
ScratchValIonEntry
=
ValueOperand
(
ABINonArgReg0
)
;
#
else
static
const
ValueOperand
ScratchValIonEntry
=
ValueOperand
(
ABINonArgReg0
ABINonArgReg1
)
;
#
endif
static
const
Register
ScratchIonEntry
=
ABINonArgReg2
;
static
void
CallSymbolicAddress
(
MacroAssembler
&
masm
bool
isAbsolute
SymbolicAddress
sym
)
{
if
(
isAbsolute
)
{
masm
.
call
(
ImmPtr
(
SymbolicAddressTarget
(
sym
)
ImmPtr
:
:
NoCheckToken
(
)
)
)
;
}
else
{
masm
.
call
(
sym
)
;
}
}
static
void
GenerateJitEntryLoadInstance
(
MacroAssembler
&
masm
)
{
unsigned
offset
=
JitFrameLayout
:
:
offsetOfCalleeToken
(
)
;
masm
.
loadFunctionFromCalleeToken
(
Address
(
FramePointer
offset
)
ScratchIonEntry
)
;
offset
=
FunctionExtended
:
:
offsetOfExtendedSlot
(
FunctionExtended
:
:
WASM_INSTANCE_SLOT
)
;
masm
.
loadPrivate
(
Address
(
ScratchIonEntry
offset
)
InstanceReg
)
;
}
static
void
GenerateJitEntryThrow
(
MacroAssembler
&
masm
unsigned
frameSize
)
{
AssertExpectedSP
(
masm
)
;
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
frameSize
)
;
masm
.
freeStack
(
frameSize
)
;
MoveSPForJitABI
(
masm
)
;
masm
.
moveStackPtrTo
(
FramePointer
)
;
GenerateJitEntryLoadInstance
(
masm
)
;
masm
.
loadPtr
(
Address
(
InstanceReg
Instance
:
:
offsetOfCx
(
)
)
ScratchIonEntry
)
;
masm
.
enterFakeExitFrameForWasm
(
ScratchIonEntry
ScratchIonEntry
ExitFrameType
:
:
WasmGenericJitEntry
)
;
masm
.
loadPtr
(
Address
(
InstanceReg
Instance
:
:
offsetOfJSJitExceptionHandler
(
)
)
ScratchIonEntry
)
;
masm
.
jump
(
ScratchIonEntry
)
;
}
static
void
GenerateBigIntInitialization
(
MacroAssembler
&
masm
unsigned
bytesPushedByPrologue
Register64
input
Register
scratch
const
FuncExport
&
fe
Label
*
fail
)
{
#
if
JS_BITS_PER_WORD
=
=
32
MOZ_ASSERT
(
input
.
low
!
=
scratch
)
;
MOZ_ASSERT
(
input
.
high
!
=
scratch
)
;
#
else
MOZ_ASSERT
(
input
.
reg
!
=
scratch
)
;
#
endif
AllocatableRegisterSet
regs
(
RegisterSet
:
:
Volatile
(
)
)
;
LiveRegisterSet
save
(
regs
.
asLiveSet
(
)
)
;
masm
.
PushRegsInMask
(
save
)
;
unsigned
frameSize
=
StackDecrementForCall
(
ABIStackAlignment
masm
.
framePushed
(
)
+
bytesPushedByPrologue
0
)
;
masm
.
reserveStack
(
frameSize
)
;
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
CallSymbolicAddress
(
masm
!
fe
.
hasEagerStubs
(
)
SymbolicAddress
:
:
AllocateBigInt
)
;
masm
.
storeCallPointerResult
(
scratch
)
;
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
masm
.
freeStack
(
frameSize
)
;
LiveRegisterSet
ignore
;
ignore
.
add
(
scratch
)
;
masm
.
PopRegsInMaskIgnore
(
save
ignore
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
scratch
scratch
fail
)
;
masm
.
initializeBigInt64
(
Scalar
:
:
BigInt64
scratch
input
)
;
}
static
bool
GenerateJitEntry
(
MacroAssembler
&
masm
size_t
funcExportIndex
const
FuncExport
&
fe
const
FuncType
&
funcType
const
Maybe
<
ImmPtr
>
&
funcPtr
CallableOffsets
*
offsets
)
{
AutoCreatedBy
acb
(
masm
"
GenerateJitEntry
"
)
;
AssertExpectedSP
(
masm
)
;
RegisterOrSP
sp
=
masm
.
getStackPointer
(
)
;
GenerateJitEntryPrologue
(
masm
offsets
)
;
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
0
)
;
unsigned
normalBytesNeeded
=
StackArgBytesForWasmABI
(
funcType
)
;
MIRTypeVector
coerceArgTypes
;
MOZ_ALWAYS_TRUE
(
coerceArgTypes
.
append
(
MIRType
:
:
Int32
)
)
;
MOZ_ALWAYS_TRUE
(
coerceArgTypes
.
append
(
MIRType
:
:
Pointer
)
)
;
MOZ_ALWAYS_TRUE
(
coerceArgTypes
.
append
(
MIRType
:
:
Pointer
)
)
;
unsigned
oolBytesNeeded
=
StackArgBytesForWasmABI
(
coerceArgTypes
)
;
unsigned
bytesNeeded
=
std
:
:
max
(
normalBytesNeeded
oolBytesNeeded
)
;
unsigned
frameSizeExclFP
=
StackDecrementForCall
(
WasmStackAlignment
masm
.
framePushed
(
)
bytesNeeded
)
;
masm
.
reserveStack
(
frameSizeExclFP
)
;
uint32_t
frameSize
=
masm
.
framePushed
(
)
;
GenerateJitEntryLoadInstance
(
masm
)
;
if
(
funcType
.
hasUnexposableArgOrRet
(
)
)
{
CallSymbolicAddress
(
masm
!
fe
.
hasEagerStubs
(
)
SymbolicAddress
:
:
ReportV128JSCall
)
;
GenerateJitEntryThrow
(
masm
frameSize
)
;
return
FinishOffsets
(
masm
offsets
)
;
}
FloatRegister
scratchF
=
ABINonArgDoubleReg
;
Register
scratchG
=
ScratchIonEntry
;
ValueOperand
scratchV
=
ScratchValIonEntry
;
GenPrintf
(
DebugChannel
:
:
Function
masm
"
wasm
-
function
[
%
d
]
;
arguments
"
fe
.
funcIndex
(
)
)
;
Label
oolCall
;
for
(
size_t
i
=
0
;
i
<
funcType
.
args
(
)
.
length
(
)
;
i
+
+
)
{
Address
jitArgAddr
(
FramePointer
JitFrameLayout
:
:
offsetOfActualArg
(
i
)
)
;
masm
.
loadValue
(
jitArgAddr
scratchV
)
;
Label
next
;
switch
(
funcType
.
args
(
)
[
i
]
.
kind
(
)
)
{
case
ValType
:
:
I32
:
{
ScratchTagScope
tag
(
masm
scratchV
)
;
masm
.
splitTagForTest
(
scratchV
tag
)
;
masm
.
branchTestInt32
(
Assembler
:
:
Equal
tag
&
next
)
;
Label
storeBack
notDouble
;
masm
.
branchTestDouble
(
Assembler
:
:
NotEqual
tag
&
notDouble
)
;
{
ScratchTagScopeRelease
_
(
&
tag
)
;
masm
.
unboxDouble
(
scratchV
scratchF
)
;
masm
.
branchTruncateDoubleMaybeModUint32
(
scratchF
scratchG
&
oolCall
)
;
masm
.
jump
(
&
storeBack
)
;
}
masm
.
bind
(
&
notDouble
)
;
Label
nullOrUndefined
notNullOrUndefined
;
masm
.
branchTestUndefined
(
Assembler
:
:
Equal
tag
&
nullOrUndefined
)
;
masm
.
branchTestNull
(
Assembler
:
:
NotEqual
tag
&
notNullOrUndefined
)
;
masm
.
bind
(
&
nullOrUndefined
)
;
{
ScratchTagScopeRelease
_
(
&
tag
)
;
masm
.
storeValue
(
Int32Value
(
0
)
jitArgAddr
)
;
}
masm
.
jump
(
&
next
)
;
masm
.
bind
(
&
notNullOrUndefined
)
;
masm
.
branchTestBoolean
(
Assembler
:
:
NotEqual
tag
&
oolCall
)
;
masm
.
unboxBoolean
(
scratchV
scratchG
)
;
masm
.
bind
(
&
storeBack
)
;
{
ScratchTagScopeRelease
_
(
&
tag
)
;
masm
.
storeValue
(
JSVAL_TYPE_INT32
scratchG
jitArgAddr
)
;
}
break
;
}
case
ValType
:
:
I64
:
{
ScratchTagScope
tag
(
masm
scratchV
)
;
masm
.
splitTagForTest
(
scratchV
tag
)
;
masm
.
branchTestBigInt
(
Assembler
:
:
NotEqual
tag
&
oolCall
)
;
masm
.
jump
(
&
next
)
;
break
;
}
case
ValType
:
:
F32
:
case
ValType
:
:
F64
:
{
ScratchTagScope
tag
(
masm
scratchV
)
;
masm
.
splitTagForTest
(
scratchV
tag
)
;
masm
.
branchTestDouble
(
Assembler
:
:
Equal
tag
&
next
)
;
Label
storeBack
notInt32
;
{
ScratchTagScopeRelease
_
(
&
tag
)
;
masm
.
branchTestInt32
(
Assembler
:
:
NotEqual
scratchV
&
notInt32
)
;
masm
.
int32ValueToDouble
(
scratchV
scratchF
)
;
masm
.
jump
(
&
storeBack
)
;
}
masm
.
bind
(
&
notInt32
)
;
Label
notUndefined
;
masm
.
branchTestUndefined
(
Assembler
:
:
NotEqual
tag
&
notUndefined
)
;
{
ScratchTagScopeRelease
_
(
&
tag
)
;
masm
.
storeValue
(
DoubleValue
(
JS
:
:
GenericNaN
(
)
)
jitArgAddr
)
;
masm
.
jump
(
&
next
)
;
}
masm
.
bind
(
&
notUndefined
)
;
Label
notNull
;
masm
.
branchTestNull
(
Assembler
:
:
NotEqual
tag
&
notNull
)
;
{
ScratchTagScopeRelease
_
(
&
tag
)
;
masm
.
storeValue
(
DoubleValue
(
0
.
)
jitArgAddr
)
;
}
masm
.
jump
(
&
next
)
;
masm
.
bind
(
&
notNull
)
;
masm
.
branchTestBoolean
(
Assembler
:
:
NotEqual
tag
&
oolCall
)
;
masm
.
boolValueToDouble
(
scratchV
scratchF
)
;
masm
.
bind
(
&
storeBack
)
;
{
ScratchTagScopeRelease
_
(
&
tag
)
;
masm
.
boxDouble
(
scratchF
jitArgAddr
)
;
}
break
;
}
case
ValType
:
:
Ref
:
{
switch
(
funcType
.
args
(
)
[
i
]
.
refTypeKind
(
)
)
{
case
RefType
:
:
Extern
:
{
ScratchTagScope
tag
(
masm
scratchV
)
;
masm
.
splitTagForTest
(
scratchV
tag
)
;
masm
.
branchTestObject
(
Assembler
:
:
Equal
tag
&
next
)
;
masm
.
branchTestNull
(
Assembler
:
:
Equal
tag
&
next
)
;
masm
.
jump
(
&
oolCall
)
;
break
;
}
case
RefType
:
:
Func
:
case
RefType
:
:
Eq
:
case
RefType
:
:
TypeRef
:
{
MOZ_CRASH
(
"
unexpected
argument
type
when
calling
from
the
jit
"
)
;
}
}
break
;
}
case
ValType
:
:
V128
:
{
MOZ_CRASH
(
"
unexpected
argument
type
when
calling
from
the
jit
"
)
;
}
default
:
{
MOZ_CRASH
(
"
unexpected
argument
type
when
calling
from
the
jit
"
)
;
}
}
masm
.
nopAlign
(
CodeAlignment
)
;
masm
.
bind
(
&
next
)
;
}
Label
rejoinBeforeCall
;
masm
.
bind
(
&
rejoinBeforeCall
)
;
ArgTypeVector
args
(
funcType
)
;
for
(
WasmABIArgIter
iter
(
args
)
;
!
iter
.
done
(
)
;
iter
+
+
)
{
Address
argv
(
FramePointer
JitFrameLayout
:
:
offsetOfActualArg
(
iter
.
index
(
)
)
)
;
bool
isStackArg
=
iter
-
>
kind
(
)
=
=
ABIArg
:
:
Stack
;
switch
(
iter
.
mirType
(
)
)
{
case
MIRType
:
:
Int32
:
{
Register
target
=
isStackArg
?
ScratchIonEntry
:
iter
-
>
gpr
(
)
;
masm
.
unboxInt32
(
argv
target
)
;
GenPrintIsize
(
DebugChannel
:
:
Function
masm
target
)
;
if
(
isStackArg
)
{
masm
.
storePtr
(
target
Address
(
sp
iter
-
>
offsetFromArgBase
(
)
)
)
;
}
break
;
}
case
MIRType
:
:
Int64
:
{
if
(
isStackArg
)
{
Address
dst
(
sp
iter
-
>
offsetFromArgBase
(
)
)
;
Register
src
=
scratchV
.
payloadOrValueReg
(
)
;
#
if
JS_BITS_PER_WORD
=
=
64
Register64
scratch64
(
scratchG
)
;
#
else
Register64
scratch64
(
scratchG
ABINonArgReg3
)
;
#
endif
masm
.
unboxBigInt
(
argv
src
)
;
masm
.
loadBigInt64
(
src
scratch64
)
;
GenPrintI64
(
DebugChannel
:
:
Function
masm
scratch64
)
;
masm
.
store64
(
scratch64
dst
)
;
}
else
{
Register
src
=
scratchG
;
Register64
target
=
iter
-
>
gpr64
(
)
;
masm
.
unboxBigInt
(
argv
src
)
;
masm
.
loadBigInt64
(
src
target
)
;
GenPrintI64
(
DebugChannel
:
:
Function
masm
target
)
;
}
break
;
}
case
MIRType
:
:
Float32
:
{
FloatRegister
target
=
isStackArg
?
ABINonArgDoubleReg
:
iter
-
>
fpu
(
)
;
masm
.
unboxDouble
(
argv
ABINonArgDoubleReg
)
;
masm
.
convertDoubleToFloat32
(
ABINonArgDoubleReg
target
)
;
GenPrintF32
(
DebugChannel
:
:
Function
masm
target
.
asSingle
(
)
)
;
if
(
isStackArg
)
{
masm
.
storeFloat32
(
target
Address
(
sp
iter
-
>
offsetFromArgBase
(
)
)
)
;
}
break
;
}
case
MIRType
:
:
Double
:
{
FloatRegister
target
=
isStackArg
?
ABINonArgDoubleReg
:
iter
-
>
fpu
(
)
;
masm
.
unboxDouble
(
argv
target
)
;
GenPrintF64
(
DebugChannel
:
:
Function
masm
target
)
;
if
(
isStackArg
)
{
masm
.
storeDouble
(
target
Address
(
sp
iter
-
>
offsetFromArgBase
(
)
)
)
;
}
break
;
}
case
MIRType
:
:
RefOrNull
:
{
Register
target
=
isStackArg
?
ScratchIonEntry
:
iter
-
>
gpr
(
)
;
masm
.
unboxObjectOrNull
(
argv
target
)
;
GenPrintPtr
(
DebugChannel
:
:
Function
masm
target
)
;
if
(
isStackArg
)
{
masm
.
storePtr
(
target
Address
(
sp
iter
-
>
offsetFromArgBase
(
)
)
)
;
}
break
;
}
default
:
{
MOZ_CRASH
(
"
unexpected
input
argument
when
calling
from
jit
"
)
;
}
}
}
GenPrintf
(
DebugChannel
:
:
Function
masm
"
\
n
"
)
;
masm
.
loadWasmPinnedRegsFromInstance
(
)
;
masm
.
storePtr
(
InstanceReg
Address
(
masm
.
getStackPointer
(
)
WasmCalleeInstanceOffsetBeforeCall
)
)
;
masm
.
assertStackAlignment
(
WasmStackAlignment
)
;
CallFuncExport
(
masm
fe
funcPtr
)
;
masm
.
assertStackAlignment
(
WasmStackAlignment
)
;
Label
exception
;
masm
.
branchPtr
(
Assembler
:
:
Equal
FramePointer
Imm32
(
FailFP
)
&
exception
)
;
masm
.
freeStack
(
frameSizeExclFP
)
;
GenPrintf
(
DebugChannel
:
:
Function
masm
"
wasm
-
function
[
%
d
]
;
returns
"
fe
.
funcIndex
(
)
)
;
const
ValTypeVector
&
results
=
funcType
.
results
(
)
;
if
(
results
.
length
(
)
=
=
0
)
{
GenPrintf
(
DebugChannel
:
:
Function
masm
"
void
"
)
;
masm
.
moveValue
(
UndefinedValue
(
)
JSReturnOperand
)
;
}
else
{
MOZ_ASSERT
(
results
.
length
(
)
=
=
1
"
multi
-
value
return
to
JS
unimplemented
"
)
;
switch
(
results
[
0
]
.
kind
(
)
)
{
case
ValType
:
:
I32
:
GenPrintIsize
(
DebugChannel
:
:
Function
masm
ReturnReg
)
;
masm
.
boxNonDouble
(
JSVAL_TYPE_INT32
ReturnReg
JSReturnOperand
)
;
break
;
case
ValType
:
:
F32
:
{
masm
.
canonicalizeFloat
(
ReturnFloat32Reg
)
;
masm
.
convertFloat32ToDouble
(
ReturnFloat32Reg
ReturnDoubleReg
)
;
GenPrintF64
(
DebugChannel
:
:
Function
masm
ReturnDoubleReg
)
;
ScratchDoubleScope
fpscratch
(
masm
)
;
masm
.
boxDouble
(
ReturnDoubleReg
JSReturnOperand
fpscratch
)
;
break
;
}
case
ValType
:
:
F64
:
{
masm
.
canonicalizeDouble
(
ReturnDoubleReg
)
;
GenPrintF64
(
DebugChannel
:
:
Function
masm
ReturnDoubleReg
)
;
ScratchDoubleScope
fpscratch
(
masm
)
;
masm
.
boxDouble
(
ReturnDoubleReg
JSReturnOperand
fpscratch
)
;
break
;
}
case
ValType
:
:
I64
:
{
Label
fail
done
;
GenPrintI64
(
DebugChannel
:
:
Function
masm
ReturnReg64
)
;
GenerateBigIntInitialization
(
masm
0
ReturnReg64
scratchG
fe
&
fail
)
;
masm
.
boxNonDouble
(
JSVAL_TYPE_BIGINT
scratchG
JSReturnOperand
)
;
masm
.
jump
(
&
done
)
;
masm
.
bind
(
&
fail
)
;
masm
.
reserveStack
(
frameSizeExclFP
)
;
masm
.
jump
(
&
exception
)
;
masm
.
bind
(
&
done
)
;
masm
.
setFramePushed
(
0
)
;
break
;
}
case
ValType
:
:
V128
:
{
MOZ_CRASH
(
"
unexpected
return
type
when
calling
from
ion
to
wasm
"
)
;
}
case
ValType
:
:
Ref
:
{
switch
(
results
[
0
]
.
refTypeKind
(
)
)
{
case
RefType
:
:
Func
:
case
RefType
:
:
Eq
:
case
RefType
:
:
Extern
:
GenerateJitEntryLoadInstance
(
masm
)
;
UnboxAnyrefIntoValueReg
(
masm
InstanceReg
ReturnReg
JSReturnOperand
WasmJitEntryReturnScratch
)
;
break
;
case
RefType
:
:
TypeRef
:
MOZ_CRASH
(
"
unexpected
return
type
when
calling
from
ion
to
wasm
"
)
;
}
break
;
}
}
}
GenPrintf
(
DebugChannel
:
:
Function
masm
"
\
n
"
)
;
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
0
)
;
AssertExpectedSP
(
masm
)
;
GenerateJitEntryEpilogue
(
masm
offsets
)
;
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
0
)
;
if
(
funcType
.
args
(
)
.
length
(
)
)
{
masm
.
bind
(
&
oolCall
)
;
masm
.
setFramePushed
(
frameSize
)
;
jit
:
:
WasmABIArgIter
<
MIRTypeVector
>
argsIter
(
coerceArgTypes
)
;
if
(
argsIter
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
masm
.
movePtr
(
ImmWord
(
funcExportIndex
)
argsIter
-
>
gpr
(
)
)
;
}
else
{
masm
.
storePtr
(
ImmWord
(
funcExportIndex
)
Address
(
sp
argsIter
-
>
offsetFromArgBase
(
)
)
)
;
}
argsIter
+
+
;
if
(
argsIter
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
masm
.
movePtr
(
InstanceReg
argsIter
-
>
gpr
(
)
)
;
}
else
{
masm
.
storePtr
(
InstanceReg
Address
(
sp
argsIter
-
>
offsetFromArgBase
(
)
)
)
;
}
argsIter
+
+
;
Address
argv
(
FramePointer
JitFrameLayout
:
:
offsetOfActualArgs
(
)
)
;
if
(
argsIter
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
masm
.
computeEffectiveAddress
(
argv
argsIter
-
>
gpr
(
)
)
;
}
else
{
masm
.
computeEffectiveAddress
(
argv
ScratchIonEntry
)
;
masm
.
storePtr
(
ScratchIonEntry
Address
(
sp
argsIter
-
>
offsetFromArgBase
(
)
)
)
;
}
argsIter
+
+
;
MOZ_ASSERT
(
argsIter
.
done
(
)
)
;
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
CallSymbolicAddress
(
masm
!
fe
.
hasEagerStubs
(
)
SymbolicAddress
:
:
CoerceInPlace_JitEntry
)
;
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
masm
.
branchTest32
(
Assembler
:
:
NonZero
ReturnReg
ReturnReg
&
rejoinBeforeCall
)
;
}
masm
.
bind
(
&
exception
)
;
masm
.
setFramePushed
(
frameSize
)
;
GenerateJitEntryThrow
(
masm
frameSize
)
;
return
FinishOffsets
(
masm
offsets
)
;
}
void
wasm
:
:
GenerateDirectCallFromJit
(
MacroAssembler
&
masm
const
FuncExport
&
fe
const
Instance
&
inst
const
JitCallStackArgVector
&
stackArgs
Register
scratch
uint32_t
*
callOffset
)
{
MOZ_ASSERT
(
!
IsCompilingWasm
(
)
)
;
const
FuncType
&
funcType
=
inst
.
metadata
(
)
.
getFuncExportType
(
fe
)
;
size_t
framePushedAtStart
=
masm
.
framePushed
(
)
;
*
callOffset
=
masm
.
buildFakeExitFrame
(
scratch
)
;
masm
.
moveStackPtrTo
(
FramePointer
)
;
masm
.
loadJSContext
(
scratch
)
;
masm
.
enterFakeExitFrame
(
scratch
scratch
ExitFrameType
:
:
DirectWasmJitCall
)
;
unsigned
bytesNeeded
=
StackArgBytesForWasmABI
(
funcType
)
;
bytesNeeded
=
StackDecrementForCall
(
WasmStackAlignment
masm
.
framePushed
(
)
bytesNeeded
)
;
if
(
bytesNeeded
)
{
masm
.
reserveStack
(
bytesNeeded
)
;
}
GenPrintf
(
DebugChannel
:
:
Function
masm
"
wasm
-
function
[
%
d
]
;
arguments
"
fe
.
funcIndex
(
)
)
;
ArgTypeVector
args
(
funcType
)
;
for
(
WasmABIArgIter
iter
(
args
)
;
!
iter
.
done
(
)
;
iter
+
+
)
{
MOZ_ASSERT_IF
(
iter
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
iter
-
>
gpr
(
)
!
=
scratch
)
;
MOZ_ASSERT_IF
(
iter
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
iter
-
>
gpr
(
)
!
=
FramePointer
)
;
if
(
iter
-
>
kind
(
)
!
=
ABIArg
:
:
Stack
)
{
switch
(
iter
.
mirType
(
)
)
{
case
MIRType
:
:
Int32
:
GenPrintIsize
(
DebugChannel
:
:
Function
masm
iter
-
>
gpr
(
)
)
;
break
;
case
MIRType
:
:
Int64
:
GenPrintI64
(
DebugChannel
:
:
Function
masm
iter
-
>
gpr64
(
)
)
;
break
;
case
MIRType
:
:
Float32
:
GenPrintF32
(
DebugChannel
:
:
Function
masm
iter
-
>
fpu
(
)
)
;
break
;
case
MIRType
:
:
Double
:
GenPrintF64
(
DebugChannel
:
:
Function
masm
iter
-
>
fpu
(
)
)
;
break
;
case
MIRType
:
:
RefOrNull
:
GenPrintPtr
(
DebugChannel
:
:
Function
masm
iter
-
>
gpr
(
)
)
;
break
;
case
MIRType
:
:
StackResults
:
MOZ_ASSERT
(
args
.
isSyntheticStackResultPointerArg
(
iter
.
index
(
)
)
)
;
GenPrintPtr
(
DebugChannel
:
:
Function
masm
iter
-
>
gpr
(
)
)
;
break
;
default
:
MOZ_CRASH
(
"
ion
to
wasm
fast
path
can
only
handle
i32
/
f32
/
f64
"
)
;
}
continue
;
}
Address
dst
(
masm
.
getStackPointer
(
)
iter
-
>
offsetFromArgBase
(
)
)
;
const
JitCallStackArg
&
stackArg
=
stackArgs
[
iter
.
index
(
)
]
;
switch
(
stackArg
.
tag
(
)
)
{
case
JitCallStackArg
:
:
Tag
:
:
Imm32
:
GenPrintf
(
DebugChannel
:
:
Function
masm
"
%
d
"
stackArg
.
imm32
(
)
)
;
masm
.
storePtr
(
ImmWord
(
stackArg
.
imm32
(
)
)
dst
)
;
break
;
case
JitCallStackArg
:
:
Tag
:
:
GPR
:
MOZ_ASSERT
(
stackArg
.
gpr
(
)
!
=
scratch
)
;
MOZ_ASSERT
(
stackArg
.
gpr
(
)
!
=
FramePointer
)
;
GenPrintIsize
(
DebugChannel
:
:
Function
masm
stackArg
.
gpr
(
)
)
;
masm
.
storePtr
(
stackArg
.
gpr
(
)
dst
)
;
break
;
case
JitCallStackArg
:
:
Tag
:
:
FPU
:
switch
(
iter
.
mirType
(
)
)
{
case
MIRType
:
:
Double
:
GenPrintF64
(
DebugChannel
:
:
Function
masm
stackArg
.
fpu
(
)
)
;
masm
.
storeDouble
(
stackArg
.
fpu
(
)
dst
)
;
break
;
case
MIRType
:
:
Float32
:
GenPrintF32
(
DebugChannel
:
:
Function
masm
stackArg
.
fpu
(
)
)
;
masm
.
storeFloat32
(
stackArg
.
fpu
(
)
dst
)
;
break
;
default
:
MOZ_CRASH
(
"
unexpected
MIR
type
for
a
float
register
in
wasm
fast
call
"
)
;
}
break
;
case
JitCallStackArg
:
:
Tag
:
:
Address
:
{
Address
src
=
stackArg
.
addr
(
)
;
MOZ_ASSERT
(
src
.
base
=
=
masm
.
getStackPointer
(
)
)
;
src
.
offset
+
=
masm
.
framePushed
(
)
-
framePushedAtStart
;
switch
(
iter
.
mirType
(
)
)
{
case
MIRType
:
:
Double
:
{
ScratchDoubleScope
fpscratch
(
masm
)
;
GenPrintF64
(
DebugChannel
:
:
Function
masm
fpscratch
)
;
masm
.
loadDouble
(
src
fpscratch
)
;
masm
.
storeDouble
(
fpscratch
dst
)
;
break
;
}
case
MIRType
:
:
Float32
:
{
ScratchFloat32Scope
fpscratch
(
masm
)
;
masm
.
loadFloat32
(
src
fpscratch
)
;
GenPrintF32
(
DebugChannel
:
:
Function
masm
fpscratch
)
;
masm
.
storeFloat32
(
fpscratch
dst
)
;
break
;
}
case
MIRType
:
:
Int32
:
{
masm
.
loadPtr
(
src
scratch
)
;
GenPrintIsize
(
DebugChannel
:
:
Function
masm
scratch
)
;
masm
.
storePtr
(
scratch
dst
)
;
break
;
}
case
MIRType
:
:
RefOrNull
:
{
masm
.
loadPtr
(
src
scratch
)
;
GenPrintPtr
(
DebugChannel
:
:
Function
masm
scratch
)
;
masm
.
storePtr
(
scratch
dst
)
;
break
;
}
case
MIRType
:
:
StackResults
:
{
MOZ_CRASH
(
"
multi
-
value
in
ion
to
wasm
fast
path
unimplemented
"
)
;
}
default
:
{
MOZ_CRASH
(
"
unexpected
MIR
type
for
a
stack
slot
in
wasm
fast
call
"
)
;
}
}
break
;
}
case
JitCallStackArg
:
:
Tag
:
:
Undefined
:
{
MOZ_CRASH
(
"
can
'
t
happen
because
of
arg
.
kind
(
)
check
"
)
;
}
}
}
GenPrintf
(
DebugChannel
:
:
Function
masm
"
\
n
"
)
;
masm
.
movePtr
(
ImmPtr
(
&
inst
)
InstanceReg
)
;
masm
.
storePtr
(
InstanceReg
Address
(
masm
.
getStackPointer
(
)
WasmCalleeInstanceOffsetBeforeCall
)
)
;
masm
.
loadWasmPinnedRegsFromInstance
(
)
;
const
CodeTier
&
codeTier
=
inst
.
code
(
)
.
codeTier
(
inst
.
code
(
)
.
bestTier
(
)
)
;
const
MetadataTier
&
metadata
=
codeTier
.
metadata
(
)
;
const
CodeRange
&
codeRange
=
metadata
.
codeRange
(
fe
)
;
void
*
callee
=
codeTier
.
segment
(
)
.
base
(
)
+
codeRange
.
funcUncheckedCallEntry
(
)
;
masm
.
assertStackAlignment
(
WasmStackAlignment
)
;
MoveSPForJitABI
(
masm
)
;
masm
.
callJit
(
ImmPtr
(
callee
)
)
;
#
ifdef
JS_CODEGEN_ARM64
masm
.
initPseudoStackPtr
(
)
;
#
endif
masm
.
assertStackAlignment
(
WasmStackAlignment
)
;
masm
.
branchPtr
(
Assembler
:
:
Equal
FramePointer
Imm32
(
wasm
:
:
FailFP
)
masm
.
exceptionLabel
(
)
)
;
GenPrintf
(
DebugChannel
:
:
Function
masm
"
wasm
-
function
[
%
d
]
;
returns
"
fe
.
funcIndex
(
)
)
;
const
ValTypeVector
&
results
=
funcType
.
results
(
)
;
if
(
results
.
length
(
)
=
=
0
)
{
masm
.
moveValue
(
UndefinedValue
(
)
JSReturnOperand
)
;
GenPrintf
(
DebugChannel
:
:
Function
masm
"
void
"
)
;
}
else
{
MOZ_ASSERT
(
results
.
length
(
)
=
=
1
"
multi
-
value
return
to
JS
unimplemented
"
)
;
switch
(
results
[
0
]
.
kind
(
)
)
{
case
wasm
:
:
ValType
:
:
I32
:
GenPrintIsize
(
DebugChannel
:
:
Function
masm
ReturnReg
)
;
#
ifdef
JS_64BIT
masm
.
widenInt32
(
ReturnReg
)
;
#
endif
break
;
case
wasm
:
:
ValType
:
:
I64
:
GenPrintI64
(
DebugChannel
:
:
Function
masm
ReturnReg64
)
;
break
;
case
wasm
:
:
ValType
:
:
F32
:
masm
.
canonicalizeFloat
(
ReturnFloat32Reg
)
;
GenPrintF32
(
DebugChannel
:
:
Function
masm
ReturnFloat32Reg
)
;
break
;
case
wasm
:
:
ValType
:
:
F64
:
masm
.
canonicalizeDouble
(
ReturnDoubleReg
)
;
GenPrintF64
(
DebugChannel
:
:
Function
masm
ReturnDoubleReg
)
;
break
;
case
wasm
:
:
ValType
:
:
Ref
:
switch
(
results
[
0
]
.
refTypeKind
(
)
)
{
case
wasm
:
:
RefType
:
:
Func
:
case
wasm
:
:
RefType
:
:
Eq
:
case
wasm
:
:
RefType
:
:
Extern
:
UnboxAnyrefIntoValueReg
(
masm
InstanceReg
ReturnReg
JSReturnOperand
WasmJitEntryReturnScratch
)
;
break
;
case
wasm
:
:
RefType
:
:
TypeRef
:
MOZ_CRASH
(
"
unexpected
return
type
when
calling
from
ion
to
wasm
"
)
;
}
break
;
case
wasm
:
:
ValType
:
:
V128
:
MOZ_CRASH
(
"
unexpected
return
type
when
calling
from
ion
to
wasm
"
)
;
}
}
GenPrintf
(
DebugChannel
:
:
Function
masm
"
\
n
"
)
;
size_t
fpOffset
=
bytesNeeded
+
ExitFooterFrame
:
:
Size
(
)
+
ExitFrameLayout
:
:
offsetOfCallerFramePtr
(
)
;
masm
.
loadPtr
(
Address
(
masm
.
getStackPointer
(
)
fpOffset
)
FramePointer
)
;
masm
.
leaveExitFrame
(
bytesNeeded
+
ExitFrameLayout
:
:
Size
(
)
)
;
MOZ_ASSERT
(
framePushedAtStart
=
=
masm
.
framePushed
(
)
)
;
}
static
void
StackCopy
(
MacroAssembler
&
masm
MIRType
type
Register
scratch
Address
src
Address
dst
)
{
if
(
type
=
=
MIRType
:
:
Int32
)
{
masm
.
load32
(
src
scratch
)
;
GenPrintIsize
(
DebugChannel
:
:
Import
masm
scratch
)
;
masm
.
store32
(
scratch
dst
)
;
}
else
if
(
type
=
=
MIRType
:
:
Int64
)
{
#
if
JS_BITS_PER_WORD
=
=
32
MOZ_RELEASE_ASSERT
(
src
.
base
!
=
scratch
&
&
dst
.
base
!
=
scratch
)
;
GenPrintf
(
DebugChannel
:
:
Import
masm
"
i64
(
"
)
;
masm
.
load32
(
LowWord
(
src
)
scratch
)
;
GenPrintIsize
(
DebugChannel
:
:
Import
masm
scratch
)
;
masm
.
store32
(
scratch
LowWord
(
dst
)
)
;
masm
.
load32
(
HighWord
(
src
)
scratch
)
;
GenPrintIsize
(
DebugChannel
:
:
Import
masm
scratch
)
;
masm
.
store32
(
scratch
HighWord
(
dst
)
)
;
GenPrintf
(
DebugChannel
:
:
Import
masm
"
)
"
)
;
#
else
Register64
scratch64
(
scratch
)
;
masm
.
load64
(
src
scratch64
)
;
GenPrintIsize
(
DebugChannel
:
:
Import
masm
scratch
)
;
masm
.
store64
(
scratch64
dst
)
;
#
endif
}
else
if
(
type
=
=
MIRType
:
:
RefOrNull
|
|
type
=
=
MIRType
:
:
Pointer
|
|
type
=
=
MIRType
:
:
StackResults
)
{
masm
.
loadPtr
(
src
scratch
)
;
GenPrintPtr
(
DebugChannel
:
:
Import
masm
scratch
)
;
masm
.
storePtr
(
scratch
dst
)
;
}
else
if
(
type
=
=
MIRType
:
:
Float32
)
{
ScratchFloat32Scope
fpscratch
(
masm
)
;
masm
.
loadFloat32
(
src
fpscratch
)
;
GenPrintF32
(
DebugChannel
:
:
Import
masm
fpscratch
)
;
masm
.
storeFloat32
(
fpscratch
dst
)
;
}
else
if
(
type
=
=
MIRType
:
:
Double
)
{
ScratchDoubleScope
fpscratch
(
masm
)
;
masm
.
loadDouble
(
src
fpscratch
)
;
GenPrintF64
(
DebugChannel
:
:
Import
masm
fpscratch
)
;
masm
.
storeDouble
(
fpscratch
dst
)
;
#
ifdef
ENABLE_WASM_SIMD
}
else
if
(
type
=
=
MIRType
:
:
Simd128
)
{
ScratchSimd128Scope
fpscratch
(
masm
)
;
masm
.
loadUnalignedSimd128
(
src
fpscratch
)
;
GenPrintV128
(
DebugChannel
:
:
Import
masm
fpscratch
)
;
masm
.
storeUnalignedSimd128
(
fpscratch
dst
)
;
#
endif
}
else
{
MOZ_CRASH
(
"
StackCopy
:
unexpected
type
"
)
;
}
}
static
void
FillArgumentArrayForInterpExit
(
MacroAssembler
&
masm
unsigned
funcImportIndex
const
FuncType
&
funcType
unsigned
argOffset
Register
scratch
)
{
const
unsigned
offsetFromFPToCallerStackArgs
=
sizeof
(
FrameWithInstances
)
;
GenPrintf
(
DebugChannel
:
:
Import
masm
"
wasm
-
import
[
%
u
]
;
arguments
"
funcImportIndex
)
;
ArgTypeVector
args
(
funcType
)
;
for
(
ABIArgIter
i
(
args
)
;
!
i
.
done
(
)
;
i
+
+
)
{
Address
dst
(
masm
.
getStackPointer
(
)
argOffset
+
i
.
index
(
)
*
sizeof
(
Value
)
)
;
MIRType
type
=
i
.
mirType
(
)
;
MOZ_ASSERT
(
args
.
isSyntheticStackResultPointerArg
(
i
.
index
(
)
)
=
=
(
type
=
=
MIRType
:
:
StackResults
)
)
;
switch
(
i
-
>
kind
(
)
)
{
case
ABIArg
:
:
GPR
:
if
(
type
=
=
MIRType
:
:
Int32
)
{
GenPrintIsize
(
DebugChannel
:
:
Import
masm
i
-
>
gpr
(
)
)
;
masm
.
store32
(
i
-
>
gpr
(
)
dst
)
;
}
else
if
(
type
=
=
MIRType
:
:
Int64
)
{
GenPrintI64
(
DebugChannel
:
:
Import
masm
i
-
>
gpr64
(
)
)
;
masm
.
store64
(
i
-
>
gpr64
(
)
dst
)
;
}
else
if
(
type
=
=
MIRType
:
:
RefOrNull
)
{
GenPrintPtr
(
DebugChannel
:
:
Import
masm
i
-
>
gpr
(
)
)
;
masm
.
storePtr
(
i
-
>
gpr
(
)
dst
)
;
}
else
if
(
type
=
=
MIRType
:
:
StackResults
)
{
GenPrintPtr
(
DebugChannel
:
:
Import
masm
i
-
>
gpr
(
)
)
;
masm
.
storePtr
(
i
-
>
gpr
(
)
dst
)
;
}
else
{
MOZ_CRASH
(
"
FillArgumentArrayForInterpExit
ABIArg
:
:
GPR
:
unexpected
type
"
)
;
}
break
;
#
ifdef
JS_CODEGEN_REGISTER_PAIR
case
ABIArg
:
:
GPR_PAIR
:
if
(
type
=
=
MIRType
:
:
Int64
)
{
GenPrintI64
(
DebugChannel
:
:
Import
masm
i
-
>
gpr64
(
)
)
;
masm
.
store64
(
i
-
>
gpr64
(
)
dst
)
;
}
else
{
MOZ_CRASH
(
"
wasm
uses
hardfp
for
function
calls
.
"
)
;
}
break
;
#
endif
case
ABIArg
:
:
FPU
:
{
FloatRegister
srcReg
=
i
-
>
fpu
(
)
;
if
(
type
=
=
MIRType
:
:
Double
)
{
GenPrintF64
(
DebugChannel
:
:
Import
masm
srcReg
)
;
masm
.
storeDouble
(
srcReg
dst
)
;
}
else
if
(
type
=
=
MIRType
:
:
Float32
)
{
GenPrintF32
(
DebugChannel
:
:
Import
masm
srcReg
)
;
masm
.
storeFloat32
(
srcReg
dst
)
;
}
else
if
(
type
=
=
MIRType
:
:
Simd128
)
{
ScratchDoubleScope
dscratch
(
masm
)
;
masm
.
loadConstantDouble
(
0
dscratch
)
;
GenPrintF64
(
DebugChannel
:
:
Import
masm
dscratch
)
;
masm
.
storeDouble
(
dscratch
dst
)
;
}
else
{
MOZ_CRASH
(
"
Unknown
MIRType
in
wasm
exit
stub
"
)
;
}
break
;
}
case
ABIArg
:
:
Stack
:
{
Address
src
(
FramePointer
offsetFromFPToCallerStackArgs
+
i
-
>
offsetFromArgBase
(
)
)
;
if
(
type
=
=
MIRType
:
:
Simd128
)
{
ScratchDoubleScope
dscratch
(
masm
)
;
masm
.
loadConstantDouble
(
0
dscratch
)
;
GenPrintF64
(
DebugChannel
:
:
Import
masm
dscratch
)
;
masm
.
storeDouble
(
dscratch
dst
)
;
}
else
{
StackCopy
(
masm
type
scratch
src
dst
)
;
}
break
;
}
case
ABIArg
:
:
Uninitialized
:
MOZ_CRASH
(
"
Uninitialized
ABIArg
kind
"
)
;
}
}
GenPrintf
(
DebugChannel
:
:
Import
masm
"
\
n
"
)
;
}
static
void
FillArgumentArrayForJitExit
(
MacroAssembler
&
masm
Register
instance
unsigned
funcImportIndex
const
FuncType
&
funcType
unsigned
argOffset
Register
scratch
Register
scratch2
Label
*
throwLabel
)
{
MOZ_ASSERT
(
scratch
!
=
scratch2
)
;
const
unsigned
offsetFromFPToCallerStackArgs
=
sizeof
(
FrameWithInstances
)
;
GenPrintf
(
DebugChannel
:
:
Import
masm
"
wasm
-
import
[
%
u
]
;
arguments
"
funcImportIndex
)
;
ArgTypeVector
args
(
funcType
)
;
for
(
ABIArgIter
i
(
args
)
;
!
i
.
done
(
)
;
i
+
+
)
{
Address
dst
(
masm
.
getStackPointer
(
)
argOffset
+
i
.
index
(
)
*
sizeof
(
Value
)
)
;
MIRType
type
=
i
.
mirType
(
)
;
MOZ_ASSERT
(
args
.
isSyntheticStackResultPointerArg
(
i
.
index
(
)
)
=
=
(
type
=
=
MIRType
:
:
StackResults
)
)
;
switch
(
i
-
>
kind
(
)
)
{
case
ABIArg
:
:
GPR
:
if
(
type
=
=
MIRType
:
:
Int32
)
{
GenPrintIsize
(
DebugChannel
:
:
Import
masm
i
-
>
gpr
(
)
)
;
masm
.
storeValue
(
JSVAL_TYPE_INT32
i
-
>
gpr
(
)
dst
)
;
}
else
if
(
type
=
=
MIRType
:
:
Int64
)
{
MOZ_CRASH
(
"
Should
not
happen
"
)
;
}
else
if
(
type
=
=
MIRType
:
:
RefOrNull
)
{
masm
.
movePtr
(
i
-
>
gpr
(
)
scratch2
)
;
UnboxAnyrefIntoValue
(
masm
instance
scratch2
dst
scratch
)
;
}
else
if
(
type
=
=
MIRType
:
:
StackResults
)
{
MOZ_CRASH
(
"
Multi
-
result
exit
to
JIT
unimplemented
"
)
;
}
else
{
MOZ_CRASH
(
"
FillArgumentArrayForJitExit
ABIArg
:
:
GPR
:
unexpected
type
"
)
;
}
break
;
#
ifdef
JS_CODEGEN_REGISTER_PAIR
case
ABIArg
:
:
GPR_PAIR
:
if
(
type
=
=
MIRType
:
:
Int64
)
{
MOZ_CRASH
(
"
Should
not
happen
"
)
;
}
else
{
MOZ_CRASH
(
"
wasm
uses
hardfp
for
function
calls
.
"
)
;
}
break
;
#
endif
case
ABIArg
:
:
FPU
:
{
FloatRegister
srcReg
=
i
-
>
fpu
(
)
;
if
(
type
=
=
MIRType
:
:
Double
)
{
ScratchDoubleScope
fpscratch
(
masm
)
;
masm
.
moveDouble
(
srcReg
fpscratch
)
;
masm
.
canonicalizeDouble
(
fpscratch
)
;
GenPrintF64
(
DebugChannel
:
:
Import
masm
fpscratch
)
;
masm
.
boxDouble
(
fpscratch
dst
)
;
}
else
if
(
type
=
=
MIRType
:
:
Float32
)
{
ScratchDoubleScope
fpscratch
(
masm
)
;
masm
.
convertFloat32ToDouble
(
srcReg
fpscratch
)
;
masm
.
canonicalizeDouble
(
fpscratch
)
;
GenPrintF64
(
DebugChannel
:
:
Import
masm
fpscratch
)
;
masm
.
boxDouble
(
fpscratch
dst
)
;
}
else
if
(
type
=
=
MIRType
:
:
Simd128
)
{
ScratchDoubleScope
dscratch
(
masm
)
;
masm
.
loadConstantDouble
(
0
dscratch
)
;
GenPrintF64
(
DebugChannel
:
:
Import
masm
dscratch
)
;
masm
.
boxDouble
(
dscratch
dst
)
;
}
else
{
MOZ_CRASH
(
"
Unknown
MIRType
in
wasm
exit
stub
"
)
;
}
break
;
}
case
ABIArg
:
:
Stack
:
{
Address
src
(
FramePointer
offsetFromFPToCallerStackArgs
+
i
-
>
offsetFromArgBase
(
)
)
;
if
(
type
=
=
MIRType
:
:
Int32
)
{
masm
.
load32
(
src
scratch
)
;
GenPrintIsize
(
DebugChannel
:
:
Import
masm
scratch
)
;
masm
.
storeValue
(
JSVAL_TYPE_INT32
scratch
dst
)
;
}
else
if
(
type
=
=
MIRType
:
:
Int64
)
{
MOZ_CRASH
(
"
Should
not
happen
"
)
;
}
else
if
(
type
=
=
MIRType
:
:
RefOrNull
)
{
masm
.
loadPtr
(
src
scratch
)
;
UnboxAnyrefIntoValue
(
masm
instance
scratch
dst
scratch2
)
;
}
else
if
(
IsFloatingPointType
(
type
)
)
{
ScratchDoubleScope
dscratch
(
masm
)
;
FloatRegister
fscratch
=
dscratch
.
asSingle
(
)
;
if
(
type
=
=
MIRType
:
:
Float32
)
{
masm
.
loadFloat32
(
src
fscratch
)
;
masm
.
convertFloat32ToDouble
(
fscratch
dscratch
)
;
}
else
{
masm
.
loadDouble
(
src
dscratch
)
;
}
masm
.
canonicalizeDouble
(
dscratch
)
;
GenPrintF64
(
DebugChannel
:
:
Import
masm
dscratch
)
;
masm
.
boxDouble
(
dscratch
dst
)
;
}
else
if
(
type
=
=
MIRType
:
:
Simd128
)
{
ScratchDoubleScope
dscratch
(
masm
)
;
masm
.
loadConstantDouble
(
0
dscratch
)
;
GenPrintF64
(
DebugChannel
:
:
Import
masm
dscratch
)
;
masm
.
boxDouble
(
dscratch
dst
)
;
}
else
{
MOZ_CRASH
(
"
FillArgumentArrayForJitExit
ABIArg
:
:
Stack
:
unexpected
type
"
)
;
}
break
;
}
case
ABIArg
:
:
Uninitialized
:
MOZ_CRASH
(
"
Uninitialized
ABIArg
kind
"
)
;
}
}
GenPrintf
(
DebugChannel
:
:
Import
masm
"
\
n
"
)
;
}
static
bool
GenerateImportFunction
(
jit
:
:
MacroAssembler
&
masm
const
FuncImport
&
fi
const
FuncType
&
funcType
CallIndirectId
callIndirectId
FuncOffsets
*
offsets
)
{
AutoCreatedBy
acb
(
masm
"
wasm
:
:
GenerateImportFunction
"
)
;
AssertExpectedSP
(
masm
)
;
GenerateFunctionPrologue
(
masm
callIndirectId
Nothing
(
)
offsets
)
;
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
0
)
;
const
unsigned
sizeOfInstanceSlot
=
sizeof
(
void
*
)
;
unsigned
framePushed
=
StackDecrementForCall
(
WasmStackAlignment
sizeof
(
Frame
)
StackArgBytesForWasmABI
(
funcType
)
+
sizeOfInstanceSlot
)
;
masm
.
wasmReserveStackChecked
(
framePushed
BytecodeOffset
(
0
)
)
;
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
framePushed
)
;
masm
.
storePtr
(
InstanceReg
Address
(
masm
.
getStackPointer
(
)
framePushed
-
sizeOfInstanceSlot
)
)
;
Register
scratch
=
ABINonArgReg0
;
unsigned
offsetFromFPToCallerStackArgs
=
sizeof
(
Frame
)
;
ArgTypeVector
args
(
funcType
)
;
for
(
WasmABIArgIter
i
(
args
)
;
!
i
.
done
(
)
;
i
+
+
)
{
if
(
i
-
>
kind
(
)
!
=
ABIArg
:
:
Stack
)
{
continue
;
}
Address
src
(
FramePointer
offsetFromFPToCallerStackArgs
+
i
-
>
offsetFromArgBase
(
)
)
;
Address
dst
(
masm
.
getStackPointer
(
)
i
-
>
offsetFromArgBase
(
)
)
;
GenPrintf
(
DebugChannel
:
:
Import
masm
"
calling
exotic
import
function
with
arguments
:
"
)
;
StackCopy
(
masm
i
.
mirType
(
)
scratch
src
dst
)
;
GenPrintf
(
DebugChannel
:
:
Import
masm
"
\
n
"
)
;
}
CallSiteDesc
desc
(
CallSiteDesc
:
:
Import
)
;
MoveSPForJitABI
(
masm
)
;
masm
.
wasmCallImport
(
desc
CalleeDesc
:
:
import
(
fi
.
instanceOffset
(
)
)
)
;
masm
.
loadPtr
(
Address
(
masm
.
getStackPointer
(
)
framePushed
-
sizeOfInstanceSlot
)
InstanceReg
)
;
masm
.
loadWasmPinnedRegsFromInstance
(
)
;
masm
.
switchToWasmInstanceRealm
(
ABINonArgReturnReg0
ABINonArgReturnReg1
)
;
GenerateFunctionEpilogue
(
masm
framePushed
offsets
)
;
return
FinishOffsets
(
masm
offsets
)
;
}
static
const
unsigned
STUBS_LIFO_DEFAULT_CHUNK_SIZE
=
4
*
1024
;
bool
wasm
:
:
GenerateImportFunctions
(
const
ModuleEnvironment
&
env
const
FuncImportVector
&
imports
CompiledCode
*
code
)
{
LifoAlloc
lifo
(
STUBS_LIFO_DEFAULT_CHUNK_SIZE
)
;
TempAllocator
alloc
(
&
lifo
)
;
WasmMacroAssembler
masm
(
alloc
env
)
;
for
(
uint32_t
funcIndex
=
0
;
funcIndex
<
imports
.
length
(
)
;
funcIndex
+
+
)
{
const
FuncImport
&
fi
=
imports
[
funcIndex
]
;
const
FuncType
&
funcType
=
*
env
.
funcs
[
funcIndex
]
.
type
;
CallIndirectId
callIndirectId
=
CallIndirectId
:
:
forFunc
(
env
funcIndex
)
;
FuncOffsets
offsets
;
if
(
!
GenerateImportFunction
(
masm
fi
funcType
callIndirectId
&
offsets
)
)
{
return
false
;
}
if
(
!
code
-
>
codeRanges
.
emplaceBack
(
funcIndex
0
offsets
)
)
{
return
false
;
}
}
masm
.
finish
(
)
;
if
(
masm
.
oom
(
)
)
{
return
false
;
}
return
code
-
>
swap
(
masm
)
;
}
static
bool
GenerateImportInterpExit
(
MacroAssembler
&
masm
const
FuncImport
&
fi
const
FuncType
&
funcType
uint32_t
funcImportIndex
Label
*
throwLabel
CallableOffsets
*
offsets
)
{
AutoCreatedBy
acb
(
masm
"
GenerateImportInterpExit
"
)
;
AssertExpectedSP
(
masm
)
;
masm
.
setFramePushed
(
0
)
;
static
const
MIRType
typeArray
[
]
=
{
MIRType
:
:
Pointer
MIRType
:
:
Pointer
MIRType
:
:
Int32
MIRType
:
:
Pointer
}
;
MIRTypeVector
invokeArgTypes
;
MOZ_ALWAYS_TRUE
(
invokeArgTypes
.
append
(
typeArray
std
:
:
size
(
typeArray
)
)
)
;
unsigned
argOffset
=
AlignBytes
(
StackArgBytesForNativeABI
(
invokeArgTypes
)
sizeof
(
double
)
)
;
unsigned
abiArgCount
=
ArgTypeVector
(
funcType
)
.
lengthWithStackResults
(
)
;
unsigned
argBytes
=
std
:
:
max
<
size_t
>
(
1
abiArgCount
)
*
sizeof
(
Value
)
;
unsigned
framePushed
=
StackDecrementForCall
(
ABIStackAlignment
sizeof
(
Frame
)
argOffset
+
argBytes
)
;
GenerateExitPrologue
(
masm
framePushed
ExitReason
:
:
Fixed
:
:
ImportInterp
offsets
)
;
Register
scratch
=
ABINonArgReturnReg0
;
FillArgumentArrayForInterpExit
(
masm
funcImportIndex
funcType
argOffset
scratch
)
;
ABIArgMIRTypeIter
i
(
invokeArgTypes
)
;
if
(
i
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
masm
.
movePtr
(
InstanceReg
i
-
>
gpr
(
)
)
;
}
else
{
masm
.
storePtr
(
InstanceReg
Address
(
masm
.
getStackPointer
(
)
i
-
>
offsetFromArgBase
(
)
)
)
;
}
i
+
+
;
if
(
i
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
masm
.
mov
(
ImmWord
(
funcImportIndex
)
i
-
>
gpr
(
)
)
;
}
else
{
masm
.
store32
(
Imm32
(
funcImportIndex
)
Address
(
masm
.
getStackPointer
(
)
i
-
>
offsetFromArgBase
(
)
)
)
;
}
i
+
+
;
unsigned
argc
=
abiArgCount
;
if
(
i
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
masm
.
mov
(
ImmWord
(
argc
)
i
-
>
gpr
(
)
)
;
}
else
{
masm
.
store32
(
Imm32
(
argc
)
Address
(
masm
.
getStackPointer
(
)
i
-
>
offsetFromArgBase
(
)
)
)
;
}
i
+
+
;
Address
argv
(
masm
.
getStackPointer
(
)
argOffset
)
;
if
(
i
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
masm
.
computeEffectiveAddress
(
argv
i
-
>
gpr
(
)
)
;
}
else
{
masm
.
computeEffectiveAddress
(
argv
scratch
)
;
masm
.
storePtr
(
scratch
Address
(
masm
.
getStackPointer
(
)
i
-
>
offsetFromArgBase
(
)
)
)
;
}
i
+
+
;
MOZ_ASSERT
(
i
.
done
(
)
)
;
AssertStackAlignment
(
masm
ABIStackAlignment
)
;
masm
.
call
(
SymbolicAddress
:
:
CallImport_General
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
ReturnReg
ReturnReg
throwLabel
)
;
ResultType
resultType
=
ResultType
:
:
Vector
(
funcType
.
results
(
)
)
;
ValType
registerResultType
;
for
(
ABIResultIter
iter
(
resultType
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
if
(
iter
.
cur
(
)
.
inRegister
(
)
)
{
MOZ_ASSERT
(
!
registerResultType
.
isValid
(
)
)
;
registerResultType
=
iter
.
cur
(
)
.
type
(
)
;
}
}
if
(
!
registerResultType
.
isValid
(
)
)
{
GenPrintf
(
DebugChannel
:
:
Import
masm
"
wasm
-
import
[
%
u
]
;
returns
"
funcImportIndex
)
;
GenPrintf
(
DebugChannel
:
:
Import
masm
"
void
"
)
;
}
else
{
switch
(
registerResultType
.
kind
(
)
)
{
case
ValType
:
:
I32
:
masm
.
load32
(
argv
ReturnReg
)
;
GenPrintf
(
DebugChannel
:
:
Import
masm
"
wasm
-
import
[
%
u
]
;
returns
"
funcImportIndex
)
;
GenPrintIsize
(
DebugChannel
:
:
Import
masm
ReturnReg
)
;
break
;
case
ValType
:
:
I64
:
masm
.
load64
(
argv
ReturnReg64
)
;
GenPrintf
(
DebugChannel
:
:
Import
masm
"
wasm
-
import
[
%
u
]
;
returns
"
funcImportIndex
)
;
GenPrintI64
(
DebugChannel
:
:
Import
masm
ReturnReg64
)
;
break
;
case
ValType
:
:
V128
:
masm
.
breakpoint
(
)
;
break
;
case
ValType
:
:
F32
:
masm
.
loadFloat32
(
argv
ReturnFloat32Reg
)
;
GenPrintf
(
DebugChannel
:
:
Import
masm
"
wasm
-
import
[
%
u
]
;
returns
"
funcImportIndex
)
;
GenPrintF32
(
DebugChannel
:
:
Import
masm
ReturnFloat32Reg
)
;
break
;
case
ValType
:
:
F64
:
masm
.
loadDouble
(
argv
ReturnDoubleReg
)
;
GenPrintf
(
DebugChannel
:
:
Import
masm
"
wasm
-
import
[
%
u
]
;
returns
"
funcImportIndex
)
;
GenPrintF64
(
DebugChannel
:
:
Import
masm
ReturnDoubleReg
)
;
break
;
case
ValType
:
:
Ref
:
switch
(
registerResultType
.
refTypeKind
(
)
)
{
case
RefType
:
:
Func
:
masm
.
loadPtr
(
argv
ReturnReg
)
;
GenPrintf
(
DebugChannel
:
:
Import
masm
"
wasm
-
import
[
%
u
]
;
returns
"
funcImportIndex
)
;
GenPrintPtr
(
DebugChannel
:
:
Import
masm
ReturnReg
)
;
break
;
case
RefType
:
:
Extern
:
case
RefType
:
:
Eq
:
masm
.
loadPtr
(
argv
ReturnReg
)
;
GenPrintf
(
DebugChannel
:
:
Import
masm
"
wasm
-
import
[
%
u
]
;
returns
"
funcImportIndex
)
;
GenPrintPtr
(
DebugChannel
:
:
Import
masm
ReturnReg
)
;
break
;
case
RefType
:
:
TypeRef
:
MOZ_CRASH
(
"
No
Ref
support
here
yet
"
)
;
}
break
;
}
}
GenPrintf
(
DebugChannel
:
:
Import
masm
"
\
n
"
)
;
MOZ_ASSERT
(
NonVolatileRegs
.
has
(
InstanceReg
)
)
;
#
if
defined
(
JS_CODEGEN_X64
)
|
|
defined
(
JS_CODEGEN_ARM
)
|
|
\
defined
(
JS_CODEGEN_ARM64
)
|
|
defined
(
JS_CODEGEN_MIPS64
)
|
|
\
defined
(
JS_CODEGEN_LOONG64
)
MOZ_ASSERT
(
NonVolatileRegs
.
has
(
HeapReg
)
)
;
#
endif
GenerateExitEpilogue
(
masm
framePushed
ExitReason
:
:
Fixed
:
:
ImportInterp
offsets
)
;
return
FinishOffsets
(
masm
offsets
)
;
}
static
bool
GenerateImportJitExit
(
MacroAssembler
&
masm
const
FuncImport
&
fi
const
FuncType
&
funcType
unsigned
funcImportIndex
Label
*
throwLabel
CallableOffsets
*
offsets
)
{
AutoCreatedBy
acb
(
masm
"
GenerateImportJitExit
"
)
;
AssertExpectedSP
(
masm
)
;
masm
.
setFramePushed
(
0
)
;
static_assert
(
WasmStackAlignment
>
=
JitStackAlignment
"
subsumes
"
)
;
const
unsigned
sizeOfInstanceSlot
=
sizeof
(
void
*
)
;
const
unsigned
sizeOfRetAddrAndFP
=
2
*
sizeof
(
void
*
)
;
const
unsigned
sizeOfPreFrame
=
WasmToJSJitFrameLayout
:
:
Size
(
)
-
sizeOfRetAddrAndFP
;
const
unsigned
sizeOfThisAndArgs
=
(
1
+
funcType
.
args
(
)
.
length
(
)
)
*
sizeof
(
Value
)
;
const
unsigned
totalJitFrameBytes
=
sizeOfRetAddrAndFP
+
sizeOfPreFrame
+
sizeOfThisAndArgs
+
sizeOfInstanceSlot
;
const
unsigned
jitFramePushed
=
StackDecrementForCall
(
JitStackAlignment
sizeof
(
Frame
)
totalJitFrameBytes
)
-
sizeOfRetAddrAndFP
;
GenerateJitExitPrologue
(
masm
jitFramePushed
offsets
)
;
unsigned
argc
=
funcType
.
args
(
)
.
length
(
)
;
size_t
argOffset
=
0
;
uint32_t
descriptor
=
MakeFrameDescriptorForJitCall
(
FrameType
:
:
WasmToJSJit
argc
)
;
masm
.
storePtr
(
ImmWord
(
uintptr_t
(
descriptor
)
)
Address
(
masm
.
getStackPointer
(
)
argOffset
)
)
;
argOffset
+
=
sizeof
(
size_t
)
;
size_t
calleeArgOffset
=
argOffset
;
argOffset
+
=
sizeof
(
size_t
)
;
MOZ_ASSERT
(
argOffset
=
=
sizeOfPreFrame
)
;
masm
.
storeValue
(
UndefinedValue
(
)
Address
(
masm
.
getStackPointer
(
)
argOffset
)
)
;
argOffset
+
=
sizeof
(
Value
)
;
Register
scratch
=
ABINonArgReturnReg1
;
Register
scratch2
=
ABINonArgReturnReg0
;
FillArgumentArrayForJitExit
(
masm
InstanceReg
funcImportIndex
funcType
argOffset
scratch
scratch2
throwLabel
)
;
argOffset
+
=
funcType
.
args
(
)
.
length
(
)
*
sizeof
(
Value
)
;
MOZ_ASSERT
(
argOffset
=
=
sizeOfThisAndArgs
+
sizeOfPreFrame
)
;
const
size_t
savedInstanceOffset
=
argOffset
;
masm
.
storePtr
(
InstanceReg
Address
(
masm
.
getStackPointer
(
)
savedInstanceOffset
)
)
;
Register
callee
=
ABINonArgReturnReg0
;
masm
.
loadWasmGlobalPtr
(
fi
.
instanceOffset
(
)
+
offsetof
(
FuncImportInstanceData
fun
)
callee
)
;
masm
.
storePtr
(
callee
Address
(
masm
.
getStackPointer
(
)
calleeArgOffset
)
)
;
masm
.
loadFunctionArgCount
(
callee
scratch
)
;
Label
rectify
;
masm
.
branch32
(
Assembler
:
:
Above
scratch
Imm32
(
funcType
.
args
(
)
.
length
(
)
)
&
rectify
)
;
masm
.
loadJitCodeRaw
(
callee
callee
)
;
Label
rejoinBeforeCall
;
masm
.
bind
(
&
rejoinBeforeCall
)
;
AssertStackAlignment
(
masm
JitStackAlignment
sizeOfRetAddrAndFP
)
;
#
ifdef
JS_CODEGEN_ARM64
AssertExpectedSP
(
masm
)
;
masm
.
moveStackPtrTo
(
PseudoStackPointer
)
;
#
endif
masm
.
callJitNoProfiler
(
callee
)
;
AssertStackAlignment
(
masm
JitStackAlignment
sizeOfRetAddrAndFP
)
;
masm
.
loadPtr
(
Address
(
masm
.
getStackPointer
(
)
savedInstanceOffset
)
InstanceReg
)
;
static_assert
(
ABIStackAlignment
<
=
JitStackAlignment
"
subsumes
"
)
;
masm
.
reserveStack
(
sizeOfRetAddrAndFP
)
;
unsigned
nativeFramePushed
=
masm
.
framePushed
(
)
;
AssertStackAlignment
(
masm
ABIStackAlignment
)
;
#
ifdef
DEBUG
{
Label
ok
;
masm
.
branchTestMagic
(
Assembler
:
:
NotEqual
JSReturnOperand
&
ok
)
;
masm
.
breakpoint
(
)
;
masm
.
bind
(
&
ok
)
;
}
#
endif
GenPrintf
(
DebugChannel
:
:
Import
masm
"
wasm
-
import
[
%
u
]
;
returns
"
funcImportIndex
)
;
Label
oolConvert
;
const
ValTypeVector
&
results
=
funcType
.
results
(
)
;
if
(
results
.
length
(
)
=
=
0
)
{
GenPrintf
(
DebugChannel
:
:
Import
masm
"
void
"
)
;
}
else
{
MOZ_ASSERT
(
results
.
length
(
)
=
=
1
"
multi
-
value
return
unimplemented
"
)
;
switch
(
results
[
0
]
.
kind
(
)
)
{
case
ValType
:
:
I32
:
masm
.
truncateValueToInt32
(
JSReturnOperand
ReturnDoubleReg
ReturnReg
&
oolConvert
)
;
GenPrintIsize
(
DebugChannel
:
:
Import
masm
ReturnReg
)
;
break
;
case
ValType
:
:
I64
:
masm
.
jump
(
&
oolConvert
)
;
break
;
case
ValType
:
:
V128
:
masm
.
breakpoint
(
)
;
break
;
case
ValType
:
:
F32
:
masm
.
convertValueToFloat
(
JSReturnOperand
ReturnFloat32Reg
&
oolConvert
)
;
GenPrintF32
(
DebugChannel
:
:
Import
masm
ReturnFloat32Reg
)
;
break
;
case
ValType
:
:
F64
:
masm
.
convertValueToDouble
(
JSReturnOperand
ReturnDoubleReg
&
oolConvert
)
;
GenPrintF64
(
DebugChannel
:
:
Import
masm
ReturnDoubleReg
)
;
break
;
case
ValType
:
:
Ref
:
switch
(
results
[
0
]
.
refTypeKind
(
)
)
{
case
RefType
:
:
Extern
:
BoxValueIntoAnyref
(
masm
JSReturnOperand
ReturnReg
&
oolConvert
)
;
GenPrintPtr
(
DebugChannel
:
:
Import
masm
ReturnReg
)
;
break
;
case
RefType
:
:
Func
:
case
RefType
:
:
Eq
:
case
RefType
:
:
TypeRef
:
MOZ_CRASH
(
"
typed
reference
returned
by
import
(
jit
exit
)
NYI
"
)
;
}
break
;
}
}
GenPrintf
(
DebugChannel
:
:
Import
masm
"
\
n
"
)
;
Label
done
;
masm
.
bind
(
&
done
)
;
GenerateJitExitEpilogue
(
masm
masm
.
framePushed
(
)
offsets
)
;
{
masm
.
bind
(
&
rectify
)
;
masm
.
loadPtr
(
Address
(
InstanceReg
Instance
:
:
offsetOfJSJitArgsRectifier
(
)
)
callee
)
;
masm
.
jump
(
&
rejoinBeforeCall
)
;
}
if
(
oolConvert
.
used
(
)
)
{
masm
.
bind
(
&
oolConvert
)
;
masm
.
setFramePushed
(
nativeFramePushed
)
;
MIRTypeVector
coerceArgTypes
;
MOZ_ALWAYS_TRUE
(
coerceArgTypes
.
append
(
MIRType
:
:
Pointer
)
)
;
unsigned
offsetToCoerceArgv
=
AlignBytes
(
StackArgBytesForNativeABI
(
coerceArgTypes
)
sizeof
(
Value
)
)
;
MOZ_ASSERT
(
nativeFramePushed
>
=
offsetToCoerceArgv
+
sizeof
(
Value
)
)
;
AssertStackAlignment
(
masm
ABIStackAlignment
)
;
masm
.
storeValue
(
JSReturnOperand
Address
(
masm
.
getStackPointer
(
)
offsetToCoerceArgv
)
)
;
SetExitFP
(
masm
ExitReason
:
:
Fixed
:
:
ImportJit
scratch
)
;
ABIArgMIRTypeIter
i
(
coerceArgTypes
)
;
Address
argv
(
masm
.
getStackPointer
(
)
offsetToCoerceArgv
)
;
if
(
i
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
masm
.
computeEffectiveAddress
(
argv
i
-
>
gpr
(
)
)
;
}
else
{
masm
.
computeEffectiveAddress
(
argv
scratch
)
;
masm
.
storePtr
(
scratch
Address
(
masm
.
getStackPointer
(
)
i
-
>
offsetFromArgBase
(
)
)
)
;
}
i
+
+
;
MOZ_ASSERT
(
i
.
done
(
)
)
;
AssertStackAlignment
(
masm
ABIStackAlignment
)
;
const
ValTypeVector
&
results
=
funcType
.
results
(
)
;
if
(
results
.
length
(
)
>
0
)
{
MOZ_ASSERT
(
results
.
length
(
)
=
=
1
"
multi
-
value
return
unimplemented
"
)
;
switch
(
results
[
0
]
.
kind
(
)
)
{
case
ValType
:
:
I32
:
masm
.
call
(
SymbolicAddress
:
:
CoerceInPlace_ToInt32
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
ReturnReg
ReturnReg
throwLabel
)
;
masm
.
unboxInt32
(
Address
(
masm
.
getStackPointer
(
)
offsetToCoerceArgv
)
ReturnReg
)
;
break
;
case
ValType
:
:
I64
:
{
masm
.
call
(
SymbolicAddress
:
:
CoerceInPlace_ToBigInt
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
ReturnReg
ReturnReg
throwLabel
)
;
Address
argv
(
masm
.
getStackPointer
(
)
offsetToCoerceArgv
)
;
masm
.
unboxBigInt
(
argv
scratch
)
;
masm
.
loadBigInt64
(
scratch
ReturnReg64
)
;
break
;
}
case
ValType
:
:
F64
:
case
ValType
:
:
F32
:
masm
.
call
(
SymbolicAddress
:
:
CoerceInPlace_ToNumber
)
;
masm
.
branchTest32
(
Assembler
:
:
Zero
ReturnReg
ReturnReg
throwLabel
)
;
masm
.
unboxDouble
(
Address
(
masm
.
getStackPointer
(
)
offsetToCoerceArgv
)
ReturnDoubleReg
)
;
if
(
results
[
0
]
.
kind
(
)
=
=
ValType
:
:
F32
)
{
masm
.
convertDoubleToFloat32
(
ReturnDoubleReg
ReturnFloat32Reg
)
;
}
break
;
case
ValType
:
:
Ref
:
switch
(
results
[
0
]
.
refTypeKind
(
)
)
{
case
RefType
:
:
Extern
:
masm
.
call
(
SymbolicAddress
:
:
BoxValue_Anyref
)
;
masm
.
branchTestPtr
(
Assembler
:
:
Zero
ReturnReg
ReturnReg
throwLabel
)
;
break
;
case
RefType
:
:
Func
:
case
RefType
:
:
Eq
:
case
RefType
:
:
TypeRef
:
MOZ_CRASH
(
"
Unsupported
convert
type
"
)
;
}
break
;
default
:
MOZ_CRASH
(
"
Unsupported
convert
type
"
)
;
}
}
ClearExitFP
(
masm
scratch
)
;
masm
.
jump
(
&
done
)
;
masm
.
setFramePushed
(
0
)
;
}
MOZ_ASSERT
(
masm
.
framePushed
(
)
=
=
0
)
;
return
FinishOffsets
(
masm
offsets
)
;
}
struct
ABIFunctionArgs
{
ABIFunctionType
abiType
;
size_t
len
;
explicit
ABIFunctionArgs
(
ABIFunctionType
sig
)
:
abiType
(
ABIFunctionType
(
sig
>
>
ArgType_Shift
)
)
{
len
=
0
;
uint64_t
i
=
uint64_t
(
abiType
)
;
while
(
i
)
{
i
=
i
>
>
ArgType_Shift
;
len
+
+
;
}
}
size_t
length
(
)
const
{
return
len
;
}
MIRType
operator
[
]
(
size_t
i
)
const
{
MOZ_ASSERT
(
i
<
len
)
;
uint64_t
abi
=
uint64_t
(
abiType
)
;
while
(
i
-
-
)
{
abi
=
abi
>
>
ArgType_Shift
;
}
return
ToMIRType
(
ABIArgType
(
abi
&
ArgType_Mask
)
)
;
}
}
;
bool
wasm
:
:
GenerateBuiltinThunk
(
MacroAssembler
&
masm
ABIFunctionType
abiType
ExitReason
exitReason
void
*
funcPtr
CallableOffsets
*
offsets
)
{
AssertExpectedSP
(
masm
)
;
masm
.
setFramePushed
(
0
)
;
ABIFunctionArgs
args
(
abiType
)
;
uint32_t
framePushed
=
StackDecrementForCall
(
ABIStackAlignment
sizeof
(
Frame
)
StackArgBytesForNativeABI
(
args
)
)
;
GenerateExitPrologue
(
masm
framePushed
exitReason
offsets
)
;
unsigned
offsetFromFPToCallerStackArgs
=
sizeof
(
FrameWithInstances
)
;
Register
scratch
=
ABINonArgReturnReg0
;
for
(
ABIArgIter
i
(
args
)
;
!
i
.
done
(
)
;
i
+
+
)
{
if
(
i
-
>
argInRegister
(
)
)
{
#
ifdef
JS_CODEGEN_ARM
if
(
!
UseHardFpABI
(
)
&
&
IsFloatingPointType
(
i
.
mirType
(
)
)
)
{
FloatRegister
input
=
i
-
>
fpu
(
)
;
if
(
i
.
mirType
(
)
=
=
MIRType
:
:
Float32
)
{
masm
.
ma_vxfer
(
input
Register
:
:
FromCode
(
input
.
id
(
)
)
)
;
}
else
if
(
i
.
mirType
(
)
=
=
MIRType
:
:
Double
)
{
uint32_t
regId
=
input
.
singleOverlay
(
)
.
id
(
)
;
masm
.
ma_vxfer
(
input
Register
:
:
FromCode
(
regId
)
Register
:
:
FromCode
(
regId
+
1
)
)
;
}
}
#
endif
continue
;
}
Address
src
(
FramePointer
offsetFromFPToCallerStackArgs
+
i
-
>
offsetFromArgBase
(
)
)
;
Address
dst
(
masm
.
getStackPointer
(
)
i
-
>
offsetFromArgBase
(
)
)
;
StackCopy
(
masm
i
.
mirType
(
)
scratch
src
dst
)
;
}
AssertStackAlignment
(
masm
ABIStackAlignment
)
;
MoveSPForJitABI
(
masm
)
;
masm
.
call
(
ImmPtr
(
funcPtr
ImmPtr
:
:
NoCheckToken
(
)
)
)
;
#
if
defined
(
JS_CODEGEN_X64
)
#
elif
defined
(
JS_CODEGEN_X86
)
Operand
op
(
esp
0
)
;
MIRType
retType
=
ToMIRType
(
ABIArgType
(
std
:
:
underlying_type_t
<
ABIFunctionType
>
(
abiType
)
&
ArgType_Mask
)
)
;
if
(
retType
=
=
MIRType
:
:
Float32
)
{
masm
.
fstp32
(
op
)
;
masm
.
loadFloat32
(
op
ReturnFloat32Reg
)
;
}
else
if
(
retType
=
=
MIRType
:
:
Double
)
{
masm
.
fstp
(
op
)
;
masm
.
loadDouble
(
op
ReturnDoubleReg
)
;
}
#
elif
defined
(
JS_CODEGEN_ARM
)
MIRType
retType
=
ToMIRType
(
ABIArgType
(
std
:
:
underlying_type_t
<
ABIFunctionType
>
(
abiType
)
&
ArgType_Mask
)
)
;
if
(
!
UseHardFpABI
(
)
&
&
IsFloatingPointType
(
retType
)
)
{
masm
.
ma_vxfer
(
r0
r1
d0
)
;
}
#
endif
GenerateExitEpilogue
(
masm
framePushed
exitReason
offsets
)
;
return
FinishOffsets
(
masm
offsets
)
;
}
#
if
defined
(
JS_CODEGEN_ARM
)
static
const
LiveRegisterSet
RegsToPreserve
(
GeneralRegisterSet
(
Registers
:
:
AllMask
&
~
(
(
Registers
:
:
SetType
(
1
)
<
<
Registers
:
:
sp
)
|
(
Registers
:
:
SetType
(
1
)
<
<
Registers
:
:
pc
)
)
)
FloatRegisterSet
(
FloatRegisters
:
:
AllDoubleMask
)
)
;
#
ifdef
ENABLE_WASM_SIMD
#
error
"
high
lanes
of
SIMD
registers
need
to
be
saved
too
.
"
#
endif
#
elif
defined
(
JS_CODEGEN_MIPS64
)
static
const
LiveRegisterSet
RegsToPreserve
(
GeneralRegisterSet
(
Registers
:
:
AllMask
&
~
(
(
Registers
:
:
SetType
(
1
)
<
<
Registers
:
:
k0
)
|
(
Registers
:
:
SetType
(
1
)
<
<
Registers
:
:
k1
)
|
(
Registers
:
:
SetType
(
1
)
<
<
Registers
:
:
sp
)
|
(
Registers
:
:
SetType
(
1
)
<
<
Registers
:
:
zero
)
)
)
FloatRegisterSet
(
FloatRegisters
:
:
AllDoubleMask
)
)
;
#
ifdef
ENABLE_WASM_SIMD
#
error
"
high
lanes
of
SIMD
registers
need
to
be
saved
too
.
"
#
endif
#
elif
defined
(
JS_CODEGEN_LOONG64
)
static
const
LiveRegisterSet
RegsToPreserve
(
GeneralRegisterSet
(
Registers
:
:
AllMask
&
~
(
(
uint32_t
(
1
)
<
<
Registers
:
:
tp
)
|
(
uint32_t
(
1
)
<
<
Registers
:
:
fp
)
|
(
uint32_t
(
1
)
<
<
Registers
:
:
sp
)
|
(
uint32_t
(
1
)
<
<
Registers
:
:
zero
)
)
)
FloatRegisterSet
(
FloatRegisters
:
:
AllDoubleMask
)
)
;
#
ifdef
ENABLE_WASM_SIMD
#
error
"
high
lanes
of
SIMD
registers
need
to
be
saved
too
.
"
#
endif
#
elif
defined
(
JS_CODEGEN_ARM64
)
static
const
LiveRegisterSet
RegsToPreserve
(
GeneralRegisterSet
(
Registers
:
:
AllMask
&
~
(
(
Registers
:
:
SetType
(
1
)
<
<
RealStackPointer
.
code
(
)
)
|
(
Registers
:
:
SetType
(
1
)
<
<
Registers
:
:
lr
)
)
)
#
ifdef
ENABLE_WASM_SIMD
FloatRegisterSet
(
FloatRegisters
:
:
AllSimd128Mask
)
)
;
#
else
FloatRegisterSet
(
FloatRegisters
:
:
AllDoubleMask
)
)
;
#
endif
#
elif
defined
(
JS_CODEGEN_X86
)
|
|
defined
(
JS_CODEGEN_X64
)
static
const
LiveRegisterSet
RegsToPreserve
(
GeneralRegisterSet
(
Registers
:
:
AllMask
&
~
(
Registers
:
:
SetType
(
1
)
<
<
Registers
:
:
StackPointer
)
)
FloatRegisterSet
(
FloatRegisters
:
:
AllMask
)
)
;
#
else
static
const
LiveRegisterSet
RegsToPreserve
(
GeneralRegisterSet
(
0
)
FloatRegisterSet
(
FloatRegisters
:
:
AllDoubleMask
)
)
;
#
ifdef
ENABLE_WASM_SIMD
#
error
"
no
SIMD
support
"
#
endif
#
endif
void
wasm
:
:
GenerateTrapExitRegisterOffsets
(
RegisterOffsets
*
offsets
size_t
*
numWords
)
{
*
numWords
=
WasmPushSize
/
sizeof
(
void
*
)
;
MOZ_ASSERT
(
*
numWords
=
=
TrapExitDummyValueOffsetFromTop
+
1
)
;
for
(
GeneralRegisterBackwardIterator
iter
(
RegsToPreserve
.
gprs
(
)
)
;
iter
.
more
(
)
;
+
+
iter
)
{
offsets
-
>
setOffset
(
*
iter
*
numWords
)
;
(
*
numWords
)
+
+
;
}
}
static
bool
GenerateTrapExit
(
MacroAssembler
&
masm
Label
*
throwLabel
Offsets
*
offsets
)
{
AssertExpectedSP
(
masm
)
;
masm
.
haltingAlign
(
CodeAlignment
)
;
masm
.
setFramePushed
(
0
)
;
offsets
-
>
begin
=
masm
.
currentOffset
(
)
;
WasmPush
(
masm
ImmWord
(
TrapExitDummyValue
)
)
;
unsigned
framePushedBeforePreserve
=
masm
.
framePushed
(
)
;
masm
.
PushRegsInMask
(
RegsToPreserve
)
;
unsigned
offsetOfReturnWord
=
masm
.
framePushed
(
)
-
framePushedBeforePreserve
;
Register
preAlignStackPointer
=
ABINonVolatileReg
;
masm
.
moveStackPtrTo
(
preAlignStackPointer
)
;
masm
.
andToStackPtr
(
Imm32
(
~
(
ABIStackAlignment
-
1
)
)
)
;
if
(
ShadowStackSpace
)
{
masm
.
subFromStackPtr
(
Imm32
(
ShadowStackSpace
)
)
;
}
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
masm
.
call
(
SymbolicAddress
:
:
HandleTrap
)
;
masm
.
branchTestPtr
(
Assembler
:
:
Zero
ReturnReg
ReturnReg
throwLabel
)
;
masm
.
moveToStackPtr
(
preAlignStackPointer
)
;
masm
.
storePtr
(
ReturnReg
Address
(
masm
.
getStackPointer
(
)
offsetOfReturnWord
)
)
;
masm
.
PopRegsInMask
(
RegsToPreserve
)
;
#
ifdef
JS_CODEGEN_ARM64
WasmPop
(
masm
lr
)
;
masm
.
abiret
(
)
;
#
else
masm
.
ret
(
)
;
#
endif
return
FinishOffsets
(
masm
offsets
)
;
}
static
void
ClobberWasmRegsForLongJmp
(
MacroAssembler
&
masm
Register
jumpReg
)
{
AllocatableGeneralRegisterSet
gprs
(
GeneralRegisterSet
:
:
All
(
)
)
;
RegisterAllocator
:
:
takeWasmRegisters
(
gprs
)
;
gprs
.
take
(
InstanceReg
)
;
gprs
.
take
(
jumpReg
)
;
for
(
GeneralRegisterIterator
iter
(
gprs
.
asLiveSet
(
)
)
;
iter
.
more
(
)
;
+
+
iter
)
{
Register
reg
=
*
iter
;
masm
.
xorPtr
(
reg
reg
)
;
}
AllocatableFloatRegisterSet
fprs
(
FloatRegisterSet
:
:
All
(
)
)
;
Maybe
<
FloatRegister
>
regNaN
;
for
(
FloatRegisterIterator
iter
(
fprs
.
asLiveSet
(
)
)
;
iter
.
more
(
)
;
+
+
iter
)
{
FloatRegister
reg
=
*
iter
;
if
(
!
reg
.
isDouble
(
)
)
{
continue
;
}
if
(
regNaN
)
{
masm
.
moveDouble
(
*
regNaN
reg
)
;
continue
;
}
masm
.
loadConstantDouble
(
std
:
:
numeric_limits
<
double
>
:
:
signaling_NaN
(
)
reg
)
;
regNaN
=
Some
(
reg
)
;
}
}
static
bool
GenerateThrowStub
(
MacroAssembler
&
masm
Label
*
throwLabel
Offsets
*
offsets
)
{
Register
scratch1
=
ABINonArgReturnReg0
;
Register
scratch2
=
ABINonArgReturnReg1
;
AssertExpectedSP
(
masm
)
;
masm
.
haltingAlign
(
CodeAlignment
)
;
masm
.
setFramePushed
(
0
)
;
masm
.
bind
(
throwLabel
)
;
offsets
-
>
begin
=
masm
.
currentOffset
(
)
;
masm
.
andToStackPtr
(
Imm32
(
~
(
ABIStackAlignment
-
1
)
)
)
;
if
(
ShadowStackSpace
)
{
masm
.
subFromStackPtr
(
Imm32
(
ShadowStackSpace
)
)
;
}
masm
.
reserveStack
(
sizeof
(
jit
:
:
ResumeFromException
)
)
;
masm
.
moveStackPtrTo
(
scratch1
)
;
MIRTypeVector
handleThrowTypes
;
MOZ_ALWAYS_TRUE
(
handleThrowTypes
.
append
(
MIRType
:
:
Pointer
)
)
;
unsigned
frameSize
=
StackDecrementForCall
(
ABIStackAlignment
masm
.
framePushed
(
)
StackArgBytesForNativeABI
(
handleThrowTypes
)
)
;
masm
.
reserveStack
(
frameSize
)
;
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
ABIArgMIRTypeIter
i
(
handleThrowTypes
)
;
if
(
i
-
>
kind
(
)
=
=
ABIArg
:
:
GPR
)
{
masm
.
movePtr
(
scratch1
i
-
>
gpr
(
)
)
;
}
else
{
masm
.
storePtr
(
scratch1
Address
(
masm
.
getStackPointer
(
)
i
-
>
offsetFromArgBase
(
)
)
)
;
}
i
+
+
;
MOZ_ASSERT
(
i
.
done
(
)
)
;
masm
.
call
(
SymbolicAddress
:
:
HandleThrow
)
;
Label
resumeCatch
leaveWasm
;
masm
.
load32
(
Address
(
ReturnReg
offsetof
(
jit
:
:
ResumeFromException
kind
)
)
scratch1
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch1
Imm32
(
jit
:
:
ExceptionResumeKind
:
:
WasmCatch
)
&
resumeCatch
)
;
masm
.
branch32
(
Assembler
:
:
Equal
scratch1
Imm32
(
jit
:
:
ExceptionResumeKind
:
:
Wasm
)
&
leaveWasm
)
;
masm
.
breakpoint
(
)
;
masm
.
bind
(
&
resumeCatch
)
;
masm
.
loadPtr
(
Address
(
ReturnReg
ResumeFromException
:
:
offsetOfInstance
(
)
)
InstanceReg
)
;
masm
.
loadWasmPinnedRegsFromInstance
(
)
;
masm
.
switchToWasmInstanceRealm
(
scratch1
scratch2
)
;
masm
.
loadPtr
(
Address
(
ReturnReg
ResumeFromException
:
:
offsetOfTarget
(
)
)
scratch1
)
;
masm
.
loadPtr
(
Address
(
ReturnReg
ResumeFromException
:
:
offsetOfFramePointer
(
)
)
FramePointer
)
;
masm
.
loadStackPtr
(
Address
(
ReturnReg
ResumeFromException
:
:
offsetOfStackPointer
(
)
)
)
;
MoveSPForJitABI
(
masm
)
;
ClobberWasmRegsForLongJmp
(
masm
scratch1
)
;
masm
.
jump
(
scratch1
)
;
masm
.
bind
(
&
leaveWasm
)
;
masm
.
loadPtr
(
Address
(
ReturnReg
ResumeFromException
:
:
offsetOfFramePointer
(
)
)
FramePointer
)
;
masm
.
loadPtr
(
Address
(
ReturnReg
ResumeFromException
:
:
offsetOfStackPointer
(
)
)
scratch1
)
;
masm
.
moveToStackPtr
(
scratch1
)
;
#
ifdef
JS_CODEGEN_ARM64
masm
.
loadPtr
(
Address
(
scratch1
0
)
lr
)
;
masm
.
addToStackPtr
(
Imm32
(
8
)
)
;
masm
.
abiret
(
)
;
#
else
masm
.
ret
(
)
;
#
endif
return
FinishOffsets
(
masm
offsets
)
;
}
static
const
LiveRegisterSet
AllAllocatableRegs
=
LiveRegisterSet
(
GeneralRegisterSet
(
Registers
:
:
AllocatableMask
)
FloatRegisterSet
(
FloatRegisters
:
:
AllMask
)
)
;
static
bool
GenerateDebugTrapStub
(
MacroAssembler
&
masm
Label
*
throwLabel
CallableOffsets
*
offsets
)
{
AssertExpectedSP
(
masm
)
;
masm
.
haltingAlign
(
CodeAlignment
)
;
masm
.
setFramePushed
(
0
)
;
GenerateExitPrologue
(
masm
0
ExitReason
:
:
Fixed
:
:
DebugTrap
offsets
)
;
masm
.
PushRegsInMask
(
AllAllocatableRegs
)
;
uint32_t
framePushed
=
masm
.
framePushed
(
)
;
#
ifdef
JS_CODEGEN_ARM64
static_assert
(
ABIStackAlignment
=
=
16
"
ARM64
SP
alignment
"
)
;
#
else
Register
scratch
=
ABINonArgReturnReg0
;
masm
.
moveStackPtrTo
(
scratch
)
;
masm
.
subFromStackPtr
(
Imm32
(
sizeof
(
intptr_t
)
)
)
;
masm
.
andToStackPtr
(
Imm32
(
~
(
ABIStackAlignment
-
1
)
)
)
;
masm
.
storePtr
(
scratch
Address
(
masm
.
getStackPointer
(
)
0
)
)
;
#
endif
if
(
ShadowStackSpace
)
{
masm
.
subFromStackPtr
(
Imm32
(
ShadowStackSpace
)
)
;
}
masm
.
assertStackAlignment
(
ABIStackAlignment
)
;
masm
.
call
(
SymbolicAddress
:
:
HandleDebugTrap
)
;
masm
.
branchIfFalseBool
(
ReturnReg
throwLabel
)
;
if
(
ShadowStackSpace
)
{
masm
.
addToStackPtr
(
Imm32
(
ShadowStackSpace
)
)
;
}
#
ifndef
JS_CODEGEN_ARM64
masm
.
Pop
(
scratch
)
;
masm
.
moveToStackPtr
(
scratch
)
;
#
endif
masm
.
setFramePushed
(
framePushed
)
;
masm
.
PopRegsInMask
(
AllAllocatableRegs
)
;
GenerateExitEpilogue
(
masm
0
ExitReason
:
:
Fixed
:
:
DebugTrap
offsets
)
;
return
FinishOffsets
(
masm
offsets
)
;
}
bool
wasm
:
:
GenerateEntryStubs
(
MacroAssembler
&
masm
size_t
funcExportIndex
const
FuncExport
&
fe
const
FuncType
&
funcType
const
Maybe
<
ImmPtr
>
&
callee
bool
isAsmJS
CodeRangeVector
*
codeRanges
)
{
MOZ_ASSERT
(
!
callee
=
=
fe
.
hasEagerStubs
(
)
)
;
MOZ_ASSERT_IF
(
isAsmJS
fe
.
hasEagerStubs
(
)
)
;
Offsets
offsets
;
if
(
!
GenerateInterpEntry
(
masm
fe
funcType
callee
&
offsets
)
)
{
return
false
;
}
if
(
!
codeRanges
-
>
emplaceBack
(
CodeRange
:
:
InterpEntry
fe
.
funcIndex
(
)
offsets
)
)
{
return
false
;
}
if
(
isAsmJS
|
|
!
funcType
.
canHaveJitEntry
(
)
)
{
return
true
;
}
CallableOffsets
jitOffsets
;
if
(
!
GenerateJitEntry
(
masm
funcExportIndex
fe
funcType
callee
&
jitOffsets
)
)
{
return
false
;
}
if
(
!
codeRanges
-
>
emplaceBack
(
CodeRange
:
:
JitEntry
fe
.
funcIndex
(
)
jitOffsets
)
)
{
return
false
;
}
return
true
;
}
bool
wasm
:
:
GenerateProvisionalLazyJitEntryStub
(
MacroAssembler
&
masm
Offsets
*
offsets
)
{
AssertExpectedSP
(
masm
)
;
masm
.
setFramePushed
(
0
)
;
offsets
-
>
begin
=
masm
.
currentOffset
(
)
;
#
ifdef
JS_CODEGEN_ARM64
masm
.
SetStackPointer64
(
PseudoStackPointer64
)
;
masm
.
Mov
(
PseudoStackPointer64
sp
)
;
#
endif
#
ifdef
JS_USE_LINK_REGISTER
masm
.
pushReturnAddress
(
)
;
#
endif
AllocatableGeneralRegisterSet
regs
(
GeneralRegisterSet
:
:
Volatile
(
)
)
;
Register
temp
=
regs
.
takeAny
(
)
;
using
Fn
=
void
*
(
*
)
(
)
;
masm
.
setupUnalignedABICall
(
temp
)
;
masm
.
callWithABI
<
Fn
GetContextSensitiveInterpreterStub
>
(
MoveOp
:
:
GENERAL
CheckUnsafeCallWithABI
:
:
DontCheckHasExitFrame
)
;
#
ifdef
JS_USE_LINK_REGISTER
masm
.
popReturnAddress
(
)
;
#
endif
masm
.
jump
(
ReturnReg
)
;
#
ifdef
JS_CODEGEN_ARM64
masm
.
SetStackPointer64
(
sp
)
;
#
endif
return
FinishOffsets
(
masm
offsets
)
;
}
bool
wasm
:
:
GenerateStubs
(
const
ModuleEnvironment
&
env
const
FuncImportVector
&
imports
const
FuncExportVector
&
exports
CompiledCode
*
code
)
{
LifoAlloc
lifo
(
STUBS_LIFO_DEFAULT_CHUNK_SIZE
)
;
TempAllocator
alloc
(
&
lifo
)
;
JitContext
jcx
;
WasmMacroAssembler
masm
(
alloc
env
)
;
AutoCreatedBy
acb
(
masm
"
wasm
:
:
GenerateStubs
"
)
;
if
(
!
code
-
>
swap
(
masm
)
)
{
return
false
;
}
Label
throwLabel
;
JitSpew
(
JitSpew_Codegen
"
#
Emitting
wasm
import
stubs
"
)
;
for
(
uint32_t
funcIndex
=
0
;
funcIndex
<
imports
.
length
(
)
;
funcIndex
+
+
)
{
const
FuncImport
&
fi
=
imports
[
funcIndex
]
;
const
FuncType
&
funcType
=
*
env
.
funcs
[
funcIndex
]
.
type
;
CallableOffsets
interpOffsets
;
if
(
!
GenerateImportInterpExit
(
masm
fi
funcType
funcIndex
&
throwLabel
&
interpOffsets
)
)
{
return
false
;
}
if
(
!
code
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
ImportInterpExit
funcIndex
interpOffsets
)
)
{
return
false
;
}
if
(
!
funcType
.
canHaveJitExit
(
)
)
{
continue
;
}
CallableOffsets
jitOffsets
;
if
(
!
GenerateImportJitExit
(
masm
fi
funcType
funcIndex
&
throwLabel
&
jitOffsets
)
)
{
return
false
;
}
if
(
!
code
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
ImportJitExit
funcIndex
jitOffsets
)
)
{
return
false
;
}
}
JitSpew
(
JitSpew_Codegen
"
#
Emitting
wasm
export
stubs
"
)
;
Maybe
<
ImmPtr
>
noAbsolute
;
for
(
size_t
i
=
0
;
i
<
exports
.
length
(
)
;
i
+
+
)
{
const
FuncExport
&
fe
=
exports
[
i
]
;
const
FuncType
&
funcType
=
(
*
env
.
types
)
[
fe
.
typeIndex
(
)
]
.
funcType
(
)
;
if
(
!
fe
.
hasEagerStubs
(
)
)
{
continue
;
}
if
(
!
GenerateEntryStubs
(
masm
i
fe
funcType
noAbsolute
env
.
isAsmJS
(
)
&
code
-
>
codeRanges
)
)
{
return
false
;
}
}
JitSpew
(
JitSpew_Codegen
"
#
Emitting
wasm
exit
stubs
"
)
;
Offsets
offsets
;
if
(
!
GenerateTrapExit
(
masm
&
throwLabel
&
offsets
)
)
{
return
false
;
}
if
(
!
code
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
TrapExit
offsets
)
)
{
return
false
;
}
CallableOffsets
callableOffsets
;
if
(
!
GenerateDebugTrapStub
(
masm
&
throwLabel
&
callableOffsets
)
)
{
return
false
;
}
if
(
!
code
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
DebugTrap
callableOffsets
)
)
{
return
false
;
}
if
(
!
GenerateThrowStub
(
masm
&
throwLabel
&
offsets
)
)
{
return
false
;
}
if
(
!
code
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
Throw
offsets
)
)
{
return
false
;
}
masm
.
finish
(
)
;
if
(
masm
.
oom
(
)
)
{
return
false
;
}
return
code
-
>
swap
(
masm
)
;
}
