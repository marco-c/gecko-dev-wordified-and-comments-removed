#
ifndef
wasm_memory_h
#
define
wasm_memory_h
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
stdint
.
h
>
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
namespace
js
{
namespace
wasm
{
enum
class
IndexType
:
uint8_t
{
I32
I64
}
;
inline
ValType
ToValType
(
IndexType
it
)
{
return
it
=
=
IndexType
:
:
I64
?
ValType
:
:
I64
:
ValType
:
:
I32
;
}
inline
IndexType
MinIndexType
(
IndexType
a
IndexType
b
)
{
return
(
a
=
=
IndexType
:
:
I32
|
|
b
=
=
IndexType
:
:
I32
)
?
IndexType
:
:
I32
:
IndexType
:
:
I64
;
}
extern
bool
ToIndexType
(
JSContext
*
cx
HandleValue
value
IndexType
*
indexType
)
;
extern
const
char
*
ToString
(
IndexType
indexType
)
;
struct
Pages
{
private
:
uint64_t
value_
;
public
:
constexpr
Pages
(
)
:
value_
(
0
)
{
}
constexpr
explicit
Pages
(
uint64_t
value
)
:
value_
(
value
)
{
}
uint64_t
value
(
)
const
{
return
value_
;
}
static
Pages
fromByteLengthExact
(
size_t
byteLength
)
{
MOZ_ASSERT
(
byteLength
%
PageSize
=
=
0
)
;
return
Pages
(
byteLength
/
PageSize
)
;
}
bool
hasByteLength
(
)
const
{
mozilla
:
:
CheckedInt
<
size_t
>
length
(
value_
)
;
length
*
=
PageSize
;
return
length
.
isValid
(
)
;
}
size_t
byteLength
(
)
const
{
mozilla
:
:
CheckedInt
<
size_t
>
length
(
value_
)
;
length
*
=
PageSize
;
return
length
.
value
(
)
;
}
bool
checkedIncrement
(
Pages
delta
)
{
mozilla
:
:
CheckedInt
<
uint64_t
>
newValue
=
value_
;
newValue
+
=
delta
.
value_
;
if
(
!
newValue
.
isValid
(
)
)
{
return
false
;
}
value_
=
newValue
.
value
(
)
;
return
true
;
}
bool
operator
=
=
(
Pages
other
)
const
{
return
value_
=
=
other
.
value_
;
}
bool
operator
!
=
(
Pages
other
)
const
{
return
value_
!
=
other
.
value_
;
}
bool
operator
<
=
(
Pages
other
)
const
{
return
value_
<
=
other
.
value_
;
}
bool
operator
<
(
Pages
other
)
const
{
return
value_
<
other
.
value_
;
}
bool
operator
>
=
(
Pages
other
)
const
{
return
value_
>
=
other
.
value_
;
}
bool
operator
>
(
Pages
other
)
const
{
return
value_
>
other
.
value_
;
}
}
;
extern
Pages
MaxMemoryPages
(
IndexType
t
)
;
static
inline
size_t
MaxMemoryBytes
(
IndexType
t
)
{
return
MaxMemoryPages
(
t
)
.
byteLength
(
)
;
}
extern
size_t
MaxMemoryBoundsCheckLimit
(
IndexType
t
)
;
static
inline
uint64_t
MaxMemoryPagesValidation
(
IndexType
indexType
)
{
return
indexType
=
=
IndexType
:
:
I32
?
MaxMemory32PagesValidation
:
MaxMemory64PagesValidation
;
}
static
inline
uint64_t
MaxTableElemsValidation
(
IndexType
indexType
)
{
return
indexType
=
=
IndexType
:
:
I32
?
MaxTable32ElemsValidation
:
MaxTable64ElemsValidation
;
}
extern
Pages
ClampedMaxPages
(
IndexType
t
Pages
initialPages
const
mozilla
:
:
Maybe
<
Pages
>
&
sourceMaxPages
bool
useHugeMemory
)
;
extern
size_t
ComputeMappedSize
(
Pages
clampedMaxPages
)
;
extern
uint64_t
GetMaxOffsetGuardLimit
(
bool
hugeMemory
)
;
extern
bool
IsValidBoundsCheckImmediate
(
uint32_t
i
)
;
extern
bool
IsValidARMImmediate
(
uint32_t
i
)
;
extern
uint64_t
RoundUpToNextValidBoundsCheckImmediate
(
uint64_t
i
)
;
extern
uint64_t
RoundUpToNextValidARMImmediate
(
uint64_t
i
)
;
#
ifdef
WASM_SUPPORTS_HUGE_MEMORY
static
const
uint64_t
HugeIndexRange
=
uint64_t
(
UINT32_MAX
)
+
1
;
static
const
uint64_t
HugeOffsetGuardLimit
=
1
<
<
25
;
static
const
uint64_t
HugeUnalignedGuardPage
=
PageSize
;
static
const
uint64_t
HugeMappedSize
=
HugeIndexRange
+
HugeOffsetGuardLimit
+
HugeUnalignedGuardPage
;
static_assert
(
HugeMappedSize
%
PageSize
=
=
0
)
;
#
endif
static
const
size_t
GuardSize
=
PageSize
;
static
const
size_t
NullPtrGuardSize
=
4096
;
static
inline
bool
MemoryBoundsCheck
(
uint32_t
offset
uint32_t
len
size_t
memLen
)
{
uint64_t
offsetLimit
=
uint64_t
(
offset
)
+
uint64_t
(
len
)
;
return
offsetLimit
<
=
memLen
;
}
static
inline
bool
MemoryBoundsCheck
(
uint64_t
offset
uint64_t
len
size_t
memLen
)
{
uint64_t
offsetLimit
=
offset
+
len
;
bool
didOverflow
=
offsetLimit
<
offset
;
bool
tooLong
=
memLen
<
offsetLimit
;
return
!
didOverflow
&
&
!
tooLong
;
}
}
}
#
endif
