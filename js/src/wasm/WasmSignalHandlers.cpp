#
include
"
wasm
/
WasmSignalHandlers
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
jit
/
AtomicOperations
.
h
"
#
include
"
jit
/
Disassembler
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
wasm
/
WasmBuiltins
.
h
"
#
include
"
wasm
/
WasmInstance
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
using
JS
:
:
GenericNaN
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
PodArrayZero
;
#
if
defined
(
ANDROID
)
#
include
<
sys
/
system_properties
.
h
>
#
if
defined
(
MOZ_LINKER
)
extern
"
C
"
MFBT_API
bool
IsSignalHandlingBroken
(
)
;
#
endif
#
endif
static
MOZ_THREAD_LOCAL
(
bool
)
sAlreadyInSignalHandler
;
struct
AutoSignalHandler
{
explicit
AutoSignalHandler
(
)
{
MOZ_ASSERT
(
!
sAlreadyInSignalHandler
.
get
(
)
)
;
sAlreadyInSignalHandler
.
set
(
true
)
;
}
~
AutoSignalHandler
(
)
{
MOZ_ASSERT
(
sAlreadyInSignalHandler
.
get
(
)
)
;
sAlreadyInSignalHandler
.
set
(
false
)
;
}
}
;
#
if
defined
(
XP_WIN
)
#
define
XMM_sig
(
p
i
)
(
(
p
)
-
>
Xmm
#
#
i
)
#
define
EIP_sig
(
p
)
(
(
p
)
-
>
Eip
)
#
define
EBP_sig
(
p
)
(
(
p
)
-
>
Ebp
)
#
define
ESP_sig
(
p
)
(
(
p
)
-
>
Esp
)
#
define
RIP_sig
(
p
)
(
(
p
)
-
>
Rip
)
#
define
RAX_sig
(
p
)
(
(
p
)
-
>
Rax
)
#
define
RCX_sig
(
p
)
(
(
p
)
-
>
Rcx
)
#
define
RDX_sig
(
p
)
(
(
p
)
-
>
Rdx
)
#
define
RBX_sig
(
p
)
(
(
p
)
-
>
Rbx
)
#
define
RSP_sig
(
p
)
(
(
p
)
-
>
Rsp
)
#
define
RBP_sig
(
p
)
(
(
p
)
-
>
Rbp
)
#
define
RSI_sig
(
p
)
(
(
p
)
-
>
Rsi
)
#
define
RDI_sig
(
p
)
(
(
p
)
-
>
Rdi
)
#
define
R8_sig
(
p
)
(
(
p
)
-
>
R8
)
#
define
R9_sig
(
p
)
(
(
p
)
-
>
R9
)
#
define
R10_sig
(
p
)
(
(
p
)
-
>
R10
)
#
define
R11_sig
(
p
)
(
(
p
)
-
>
R11
)
#
define
R12_sig
(
p
)
(
(
p
)
-
>
R12
)
#
define
R13_sig
(
p
)
(
(
p
)
-
>
R13
)
#
define
R14_sig
(
p
)
(
(
p
)
-
>
R14
)
#
define
R15_sig
(
p
)
(
(
p
)
-
>
R15
)
#
elif
defined
(
__OpenBSD__
)
#
define
XMM_sig
(
p
i
)
(
(
p
)
-
>
sc_fpstate
-
>
fx_xmm
[
i
]
)
#
define
EIP_sig
(
p
)
(
(
p
)
-
>
sc_eip
)
#
define
EBP_sig
(
p
)
(
(
p
)
-
>
sc_ebp
)
#
define
ESP_sig
(
p
)
(
(
p
)
-
>
sc_esp
)
#
define
RIP_sig
(
p
)
(
(
p
)
-
>
sc_rip
)
#
define
RAX_sig
(
p
)
(
(
p
)
-
>
sc_rax
)
#
define
RCX_sig
(
p
)
(
(
p
)
-
>
sc_rcx
)
#
define
RDX_sig
(
p
)
(
(
p
)
-
>
sc_rdx
)
#
define
RBX_sig
(
p
)
(
(
p
)
-
>
sc_rbx
)
#
define
RSP_sig
(
p
)
(
(
p
)
-
>
sc_rsp
)
#
define
RBP_sig
(
p
)
(
(
p
)
-
>
sc_rbp
)
#
define
RSI_sig
(
p
)
(
(
p
)
-
>
sc_rsi
)
#
define
RDI_sig
(
p
)
(
(
p
)
-
>
sc_rdi
)
#
define
R8_sig
(
p
)
(
(
p
)
-
>
sc_r8
)
#
define
R9_sig
(
p
)
(
(
p
)
-
>
sc_r9
)
#
define
R10_sig
(
p
)
(
(
p
)
-
>
sc_r10
)
#
define
R11_sig
(
p
)
(
(
p
)
-
>
sc_r11
)
#
define
R12_sig
(
p
)
(
(
p
)
-
>
sc_r12
)
#
if
defined
(
__arm__
)
#
define
R13_sig
(
p
)
(
(
p
)
-
>
sc_usr_sp
)
#
define
R14_sig
(
p
)
(
(
p
)
-
>
sc_usr_lr
)
#
define
R15_sig
(
p
)
(
(
p
)
-
>
sc_pc
)
#
else
#
define
R13_sig
(
p
)
(
(
p
)
-
>
sc_r13
)
#
define
R14_sig
(
p
)
(
(
p
)
-
>
sc_r14
)
#
define
R15_sig
(
p
)
(
(
p
)
-
>
sc_r15
)
#
endif
#
if
defined
(
__aarch64__
)
#
define
EPC_sig
(
p
)
(
(
p
)
-
>
sc_elr
)
#
define
RFP_sig
(
p
)
(
(
p
)
-
>
sc_x
[
29
]
)
#
define
RLR_sig
(
p
)
(
(
p
)
-
>
sc_lr
)
#
define
R31_sig
(
p
)
(
(
p
)
-
>
sc_sp
)
#
endif
#
if
defined
(
__mips__
)
#
define
EPC_sig
(
p
)
(
(
p
)
-
>
sc_pc
)
#
define
RFP_sig
(
p
)
(
(
p
)
-
>
sc_regs
[
30
]
)
#
endif
#
elif
defined
(
__linux__
)
|
|
defined
(
__sun
)
#
if
defined
(
__linux__
)
#
define
XMM_sig
(
p
i
)
(
(
p
)
-
>
uc_mcontext
.
fpregs
-
>
_xmm
[
i
]
)
#
define
EIP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_EIP
]
)
#
define
EBP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_EBP
]
)
#
define
ESP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_ESP
]
)
#
else
#
define
XMM_sig
(
p
i
)
(
(
p
)
-
>
uc_mcontext
.
fpregs
.
fp_reg_set
.
fpchip_state
.
xmm
[
i
]
)
#
define
EIP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_PC
]
)
#
define
EBP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_EBP
]
)
#
define
ESP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_ESP
]
)
#
endif
#
define
RIP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_RIP
]
)
#
define
RAX_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_RAX
]
)
#
define
RCX_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_RCX
]
)
#
define
RDX_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_RDX
]
)
#
define
RBX_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_RBX
]
)
#
define
RSP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_RSP
]
)
#
define
RBP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_RBP
]
)
#
define
RSI_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_RSI
]
)
#
define
RDI_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_RDI
]
)
#
define
R8_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_R8
]
)
#
define
R9_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_R9
]
)
#
define
R10_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_R10
]
)
#
define
R12_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_R12
]
)
#
if
defined
(
__linux__
)
&
&
defined
(
__arm__
)
#
define
R11_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
arm_fp
)
#
define
R13_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
arm_sp
)
#
define
R14_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
arm_lr
)
#
define
R15_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
arm_pc
)
#
else
#
define
R11_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_R11
]
)
#
define
R13_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_R13
]
)
#
define
R14_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_R14
]
)
#
define
R15_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
REG_R15
]
)
#
endif
#
if
defined
(
__linux__
)
&
&
defined
(
__aarch64__
)
#
define
EPC_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
pc
)
#
define
RFP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
regs
[
29
]
)
#
define
RLR_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
regs
[
30
]
)
#
define
R31_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
regs
[
31
]
)
#
endif
#
if
defined
(
__linux__
)
&
&
defined
(
__mips__
)
#
define
EPC_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
pc
)
#
define
RFP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
30
]
)
#
define
RSP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
29
]
)
#
define
R31_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
gregs
[
31
]
)
#
endif
#
elif
defined
(
__NetBSD__
)
#
define
XMM_sig
(
p
i
)
(
(
(
struct
fxsave64
*
)
(
p
)
-
>
uc_mcontext
.
__fpregs
)
-
>
fx_xmm
[
i
]
)
#
define
EIP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_EIP
]
)
#
define
EBP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_EBP
]
)
#
define
ESP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_ESP
]
)
#
define
RIP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_RIP
]
)
#
define
RAX_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_RAX
]
)
#
define
RCX_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_RCX
]
)
#
define
RDX_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_RDX
]
)
#
define
RBX_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_RBX
]
)
#
define
RSP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_RSP
]
)
#
define
RBP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_RBP
]
)
#
define
RSI_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_RSI
]
)
#
define
RDI_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_RDI
]
)
#
define
R8_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_R8
]
)
#
define
R9_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_R9
]
)
#
define
R10_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_R10
]
)
#
define
R11_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_R11
]
)
#
define
R12_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_R12
]
)
#
define
R13_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_R13
]
)
#
define
R14_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_R14
]
)
#
define
R15_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_R15
]
)
#
if
defined
(
__aarch64__
)
#
define
EPC_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_PC
]
)
#
define
RFP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_X29
]
)
#
define
RLR_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_X30
]
)
#
define
R31_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_SP
]
)
#
endif
#
if
defined
(
__mips__
)
#
define
EPC_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_EPC
]
)
#
define
RFP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_S8
]
)
#
endif
#
elif
defined
(
__DragonFly__
)
|
|
defined
(
__FreeBSD__
)
|
|
defined
(
__FreeBSD_kernel__
)
#
if
defined
(
__DragonFly__
)
#
define
XMM_sig
(
p
i
)
(
(
(
union
savefpu
*
)
(
p
)
-
>
uc_mcontext
.
mc_fpregs
)
-
>
sv_xmm
.
sv_xmm
[
i
]
)
#
else
#
define
XMM_sig
(
p
i
)
(
(
(
struct
savefpu
*
)
(
p
)
-
>
uc_mcontext
.
mc_fpstate
)
-
>
sv_xmm
[
i
]
)
#
endif
#
define
EIP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_eip
)
#
define
EBP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_ebp
)
#
define
ESP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_esp
)
#
define
RIP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_rip
)
#
define
RAX_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_rax
)
#
define
RCX_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_rcx
)
#
define
RDX_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_rdx
)
#
define
RBX_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_rbx
)
#
define
RSP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_rsp
)
#
define
RBP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_rbp
)
#
define
RSI_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_rsi
)
#
define
RDI_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_rdi
)
#
define
R8_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_r8
)
#
define
R9_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_r9
)
#
define
R10_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_r10
)
#
define
R12_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_r12
)
#
if
defined
(
__FreeBSD__
)
&
&
defined
(
__arm__
)
#
define
R11_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_R11
]
)
#
define
R13_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_R13
]
)
#
define
R14_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_R14
]
)
#
define
R15_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
__gregs
[
_REG_R15
]
)
#
else
#
define
R11_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_r11
)
#
define
R13_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_r13
)
#
define
R14_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_r14
)
#
define
R15_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_r15
)
#
endif
#
if
defined
(
__FreeBSD__
)
&
&
defined
(
__aarch64__
)
#
define
EPC_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_gpregs
.
gp_elr
)
#
define
RFP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_gpregs
.
gp_x
[
29
]
)
#
define
RLR_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_gpregs
.
gp_lr
)
#
define
R31_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_gpregs
.
gp_sp
)
#
endif
#
if
defined
(
__FreeBSD__
)
&
&
defined
(
__mips__
)
#
define
EPC_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_pc
)
#
define
RFP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
.
mc_regs
[
30
]
)
#
endif
#
elif
defined
(
XP_DARWIN
)
#
define
EIP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
-
>
__ss
.
__eip
)
#
define
EBP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
-
>
__ss
.
__ebp
)
#
define
ESP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
-
>
__ss
.
__esp
)
#
define
RIP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
-
>
__ss
.
__rip
)
#
define
RBP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
-
>
__ss
.
__rbp
)
#
define
RSP_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
-
>
__ss
.
__rsp
)
#
define
R14_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
-
>
__ss
.
__lr
)
#
define
R15_sig
(
p
)
(
(
p
)
-
>
uc_mcontext
-
>
__ss
.
__pc
)
#
else
#
error
"
Don
'
t
know
how
to
read
/
write
to
the
thread
state
via
the
mcontext_t
.
"
#
endif
#
if
defined
(
XP_WIN
)
#
include
"
jswin
.
h
"
#
else
#
include
<
signal
.
h
>
#
include
<
sys
/
mman
.
h
>
#
endif
#
if
defined
(
__FreeBSD__
)
|
|
defined
(
__FreeBSD_kernel__
)
#
include
<
sys
/
ucontext
.
h
>
#
endif
#
if
defined
(
__x86_64__
)
#
if
defined
(
__DragonFly__
)
#
include
<
machine
/
npx
.
h
>
#
elif
defined
(
__FreeBSD__
)
|
|
defined
(
__FreeBSD_kernel__
)
|
|
\
defined
(
__NetBSD__
)
|
|
defined
(
__OpenBSD__
)
#
include
<
machine
/
fpu
.
h
>
#
endif
#
endif
#
if
defined
(
ANDROID
)
#
if
!
defined
(
__BIONIC_HAVE_UCONTEXT_T
)
#
if
defined
(
__arm__
)
#
if
!
defined
(
__BIONIC_HAVE_STRUCT_SIGCONTEXT
)
#
include
<
asm
/
sigcontext
.
h
>
#
endif
typedef
struct
sigcontext
mcontext_t
;
typedef
struct
ucontext
{
uint32_t
uc_flags
;
struct
ucontext
*
uc_link
;
stack_t
uc_stack
;
mcontext_t
uc_mcontext
;
}
ucontext_t
;
#
elif
defined
(
__mips__
)
typedef
struct
{
uint32_t
regmask
;
uint32_t
status
;
uint64_t
pc
;
uint64_t
gregs
[
32
]
;
uint64_t
fpregs
[
32
]
;
uint32_t
acx
;
uint32_t
fpc_csr
;
uint32_t
fpc_eir
;
uint32_t
used_math
;
uint32_t
dsp
;
uint64_t
mdhi
;
uint64_t
mdlo
;
uint32_t
hi1
;
uint32_t
lo1
;
uint32_t
hi2
;
uint32_t
lo2
;
uint32_t
hi3
;
uint32_t
lo3
;
}
mcontext_t
;
typedef
struct
ucontext
{
uint32_t
uc_flags
;
struct
ucontext
*
uc_link
;
stack_t
uc_stack
;
mcontext_t
uc_mcontext
;
}
ucontext_t
;
#
elif
defined
(
__i386__
)
typedef
struct
{
uint32_t
gregs
[
19
]
;
void
*
fpregs
;
uint32_t
oldmask
;
uint32_t
cr2
;
}
mcontext_t
;
typedef
uint32_t
kernel_sigset_t
[
2
]
;
typedef
struct
ucontext
{
uint32_t
uc_flags
;
struct
ucontext
*
uc_link
;
stack_t
uc_stack
;
mcontext_t
uc_mcontext
;
}
ucontext_t
;
enum
{
REG_EIP
=
14
}
;
#
endif
#
endif
#
endif
#
if
!
defined
(
XP_WIN
)
#
define
CONTEXT
ucontext_t
#
endif
#
if
defined
(
XP_DARWIN
)
#
if
defined
(
__x86_64__
)
struct
macos_x64_context
{
x86_thread_state64_t
thread
;
x86_float_state64_t
float_
;
}
;
#
define
EMULATOR_CONTEXT
macos_x64_context
#
elif
defined
(
__i386__
)
struct
macos_x86_context
{
x86_thread_state_t
thread
;
x86_float_state_t
float_
;
}
;
#
define
EMULATOR_CONTEXT
macos_x86_context
#
elif
defined
(
__arm__
)
struct
macos_arm_context
{
arm_thread_state_t
thread
;
arm_neon_state_t
float_
;
}
;
#
define
EMULATOR_CONTEXT
macos_arm_context
#
else
#
error
Unsupported
architecture
#
endif
#
else
#
define
EMULATOR_CONTEXT
CONTEXT
#
endif
#
if
defined
(
_M_X64
)
|
|
defined
(
__x86_64__
)
#
define
PC_sig
(
p
)
RIP_sig
(
p
)
#
define
FP_sig
(
p
)
RBP_sig
(
p
)
#
define
SP_sig
(
p
)
RSP_sig
(
p
)
#
elif
defined
(
_M_IX86
)
|
|
defined
(
__i386__
)
#
define
PC_sig
(
p
)
EIP_sig
(
p
)
#
define
FP_sig
(
p
)
EBP_sig
(
p
)
#
define
SP_sig
(
p
)
ESP_sig
(
p
)
#
elif
defined
(
__arm__
)
#
define
FP_sig
(
p
)
R11_sig
(
p
)
#
define
SP_sig
(
p
)
R13_sig
(
p
)
#
define
LR_sig
(
p
)
R14_sig
(
p
)
#
define
PC_sig
(
p
)
R15_sig
(
p
)
#
elif
defined
(
__aarch64__
)
#
define
PC_sig
(
p
)
EPC_sig
(
p
)
#
define
FP_sig
(
p
)
RFP_sig
(
p
)
#
define
SP_sig
(
p
)
R31_sig
(
p
)
#
define
LR_sig
(
p
)
RLR_sig
(
p
)
#
elif
defined
(
__mips__
)
#
define
PC_sig
(
p
)
EPC_sig
(
p
)
#
define
FP_sig
(
p
)
RFP_sig
(
p
)
#
define
SP_sig
(
p
)
RSP_sig
(
p
)
#
define
LR_sig
(
p
)
R31_sig
(
p
)
#
endif
static
uint8_t
*
*
ContextToPC
(
CONTEXT
*
context
)
{
#
ifdef
JS_CODEGEN_NONE
MOZ_CRASH
(
)
;
#
else
return
reinterpret_cast
<
uint8_t
*
*
>
(
&
PC_sig
(
context
)
)
;
#
endif
}
static
uint8_t
*
ContextToFP
(
CONTEXT
*
context
)
{
#
ifdef
JS_CODEGEN_NONE
MOZ_CRASH
(
)
;
#
else
return
reinterpret_cast
<
uint8_t
*
>
(
FP_sig
(
context
)
)
;
#
endif
}
#
ifndef
JS_CODEGEN_NONE
static
uint8_t
*
ContextToSP
(
CONTEXT
*
context
)
{
return
reinterpret_cast
<
uint8_t
*
>
(
SP_sig
(
context
)
)
;
}
#
if
defined
(
__arm__
)
|
|
defined
(
__aarch64__
)
|
|
defined
(
__mips__
)
static
uint8_t
*
ContextToLR
(
CONTEXT
*
context
)
{
return
reinterpret_cast
<
uint8_t
*
>
(
LR_sig
(
context
)
)
;
}
#
endif
#
endif
#
if
defined
(
XP_DARWIN
)
static
uint8_t
*
*
ContextToPC
(
EMULATOR_CONTEXT
*
context
)
{
#
if
defined
(
__x86_64__
)
static_assert
(
sizeof
(
context
-
>
thread
.
__rip
)
=
=
sizeof
(
void
*
)
"
stored
IP
should
be
compile
-
time
pointer
-
sized
"
)
;
return
reinterpret_cast
<
uint8_t
*
*
>
(
&
context
-
>
thread
.
__rip
)
;
#
elif
defined
(
__i386__
)
static_assert
(
sizeof
(
context
-
>
thread
.
uts
.
ts32
.
__eip
)
=
=
sizeof
(
void
*
)
"
stored
IP
should
be
compile
-
time
pointer
-
sized
"
)
;
return
reinterpret_cast
<
uint8_t
*
*
>
(
&
context
-
>
thread
.
uts
.
ts32
.
__eip
)
;
#
elif
defined
(
__arm__
)
static_assert
(
sizeof
(
context
-
>
thread
.
__pc
)
=
=
sizeof
(
void
*
)
"
stored
IP
should
be
compile
-
time
pointer
-
sized
"
)
;
return
reinterpret_cast
<
uint8_t
*
*
>
(
&
context
-
>
thread
.
__pc
)
;
#
else
#
error
Unsupported
architecture
#
endif
}
static
uint8_t
*
ContextToFP
(
EMULATOR_CONTEXT
*
context
)
{
#
if
defined
(
__x86_64__
)
return
(
uint8_t
*
)
context
-
>
thread
.
__rbp
;
#
elif
defined
(
__i386__
)
return
(
uint8_t
*
)
context
-
>
thread
.
uts
.
ts32
.
__ebp
;
#
elif
defined
(
__arm__
)
return
(
uint8_t
*
)
context
-
>
thread
.
__r
[
11
]
;
#
else
#
error
Unsupported
architecture
#
endif
}
#
if
defined
(
__arm__
)
|
|
defined
(
__aarch64__
)
static
uint8_t
*
ContextToLR
(
EMULATOR_CONTEXT
*
context
)
{
return
(
uint8_t
*
)
context
-
>
thread
.
__lr
;
}
#
endif
static
uint8_t
*
ContextToSP
(
EMULATOR_CONTEXT
*
context
)
{
#
if
defined
(
__x86_64__
)
return
(
uint8_t
*
)
context
-
>
thread
.
__rsp
;
#
elif
defined
(
__i386__
)
return
(
uint8_t
*
)
context
-
>
thread
.
uts
.
ts32
.
__esp
;
#
elif
defined
(
__arm__
)
return
(
uint8_t
*
)
context
-
>
thread
.
__sp
;
#
else
#
error
Unsupported
architecture
#
endif
}
static
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
ToRegisterState
(
EMULATOR_CONTEXT
*
context
)
{
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
state
;
state
.
fp
=
ContextToFP
(
context
)
;
state
.
pc
=
*
ContextToPC
(
context
)
;
state
.
sp
=
ContextToSP
(
context
)
;
#
if
defined
(
__arm__
)
|
|
defined
(
__aarch64__
)
state
.
lr
=
ContextToLR
(
context
)
;
#
endif
return
state
;
}
#
endif
static
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
ToRegisterState
(
CONTEXT
*
context
)
{
#
ifdef
JS_CODEGEN_NONE
MOZ_CRASH
(
)
;
#
else
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
state
;
state
.
fp
=
ContextToFP
(
context
)
;
state
.
pc
=
*
ContextToPC
(
context
)
;
state
.
sp
=
ContextToSP
(
context
)
;
#
if
defined
(
__arm__
)
|
|
defined
(
__aarch64__
)
|
|
defined
(
__mips__
)
state
.
lr
=
ContextToLR
(
context
)
;
#
endif
return
state
;
#
endif
}
#
if
defined
(
WASM_HUGE_MEMORY
)
MOZ_COLD
static
void
SetFPRegToNaN
(
size_t
size
void
*
fp_reg
)
{
MOZ_RELEASE_ASSERT
(
size
<
=
Simd128DataSize
)
;
memset
(
fp_reg
0
Simd128DataSize
)
;
switch
(
size
)
{
case
4
:
*
static_cast
<
float
*
>
(
fp_reg
)
=
GenericNaN
(
)
;
break
;
case
8
:
*
static_cast
<
double
*
>
(
fp_reg
)
=
GenericNaN
(
)
;
break
;
default
:
MOZ_CRASH
(
"
unexpected
size
in
SetFPRegToNaN
"
)
;
}
}
MOZ_COLD
static
void
SetGPRegToZero
(
void
*
gp_reg
)
{
memset
(
gp_reg
0
sizeof
(
intptr_t
)
)
;
}
MOZ_COLD
static
void
SetFPRegToLoadedValue
(
SharedMem
<
void
*
>
addr
size_t
size
void
*
fp_reg
)
{
MOZ_RELEASE_ASSERT
(
size
<
=
Simd128DataSize
)
;
memset
(
fp_reg
0
Simd128DataSize
)
;
AtomicOperations
:
:
memcpySafeWhenRacy
(
fp_reg
addr
size
)
;
}
MOZ_COLD
static
void
SetGPRegToLoadedValue
(
SharedMem
<
void
*
>
addr
size_t
size
void
*
gp_reg
)
{
MOZ_RELEASE_ASSERT
(
size
<
=
sizeof
(
void
*
)
)
;
memset
(
gp_reg
0
sizeof
(
void
*
)
)
;
AtomicOperations
:
:
memcpySafeWhenRacy
(
gp_reg
addr
size
)
;
}
MOZ_COLD
static
void
SetGPRegToLoadedValueSext32
(
SharedMem
<
void
*
>
addr
size_t
size
void
*
gp_reg
)
{
MOZ_RELEASE_ASSERT
(
size
<
=
sizeof
(
int32_t
)
)
;
int8_t
msb
=
AtomicOperations
:
:
loadSafeWhenRacy
(
addr
.
cast
<
uint8_t
*
>
(
)
+
(
size
-
1
)
)
;
memset
(
gp_reg
0
sizeof
(
void
*
)
)
;
memset
(
gp_reg
msb
>
>
7
sizeof
(
int32_t
)
)
;
AtomicOperations
:
:
memcpySafeWhenRacy
(
gp_reg
addr
size
)
;
}
MOZ_COLD
static
void
StoreValueFromFPReg
(
SharedMem
<
void
*
>
addr
size_t
size
const
void
*
fp_reg
)
{
MOZ_RELEASE_ASSERT
(
size
<
=
Simd128DataSize
)
;
AtomicOperations
:
:
memcpySafeWhenRacy
(
addr
const_cast
<
void
*
>
(
fp_reg
)
size
)
;
}
MOZ_COLD
static
void
StoreValueFromGPReg
(
SharedMem
<
void
*
>
addr
size_t
size
const
void
*
gp_reg
)
{
MOZ_RELEASE_ASSERT
(
size
<
=
sizeof
(
void
*
)
)
;
AtomicOperations
:
:
memcpySafeWhenRacy
(
addr
const_cast
<
void
*
>
(
gp_reg
)
size
)
;
}
MOZ_COLD
static
void
StoreValueFromGPImm
(
SharedMem
<
void
*
>
addr
size_t
size
int32_t
imm
)
{
MOZ_RELEASE_ASSERT
(
size
<
=
sizeof
(
imm
)
)
;
AtomicOperations
:
:
memcpySafeWhenRacy
(
addr
static_cast
<
void
*
>
(
&
imm
)
size
)
;
}
#
if
!
defined
(
XP_DARWIN
)
MOZ_COLD
static
void
*
AddressOfFPRegisterSlot
(
CONTEXT
*
context
FloatRegisters
:
:
Encoding
encoding
)
{
switch
(
encoding
)
{
case
X86Encoding
:
:
xmm0
:
return
&
XMM_sig
(
context
0
)
;
case
X86Encoding
:
:
xmm1
:
return
&
XMM_sig
(
context
1
)
;
case
X86Encoding
:
:
xmm2
:
return
&
XMM_sig
(
context
2
)
;
case
X86Encoding
:
:
xmm3
:
return
&
XMM_sig
(
context
3
)
;
case
X86Encoding
:
:
xmm4
:
return
&
XMM_sig
(
context
4
)
;
case
X86Encoding
:
:
xmm5
:
return
&
XMM_sig
(
context
5
)
;
case
X86Encoding
:
:
xmm6
:
return
&
XMM_sig
(
context
6
)
;
case
X86Encoding
:
:
xmm7
:
return
&
XMM_sig
(
context
7
)
;
case
X86Encoding
:
:
xmm8
:
return
&
XMM_sig
(
context
8
)
;
case
X86Encoding
:
:
xmm9
:
return
&
XMM_sig
(
context
9
)
;
case
X86Encoding
:
:
xmm10
:
return
&
XMM_sig
(
context
10
)
;
case
X86Encoding
:
:
xmm11
:
return
&
XMM_sig
(
context
11
)
;
case
X86Encoding
:
:
xmm12
:
return
&
XMM_sig
(
context
12
)
;
case
X86Encoding
:
:
xmm13
:
return
&
XMM_sig
(
context
13
)
;
case
X86Encoding
:
:
xmm14
:
return
&
XMM_sig
(
context
14
)
;
case
X86Encoding
:
:
xmm15
:
return
&
XMM_sig
(
context
15
)
;
default
:
break
;
}
MOZ_CRASH
(
)
;
}
MOZ_COLD
static
void
*
AddressOfGPRegisterSlot
(
EMULATOR_CONTEXT
*
context
Registers
:
:
Code
code
)
{
switch
(
code
)
{
case
X86Encoding
:
:
rax
:
return
&
RAX_sig
(
context
)
;
case
X86Encoding
:
:
rcx
:
return
&
RCX_sig
(
context
)
;
case
X86Encoding
:
:
rdx
:
return
&
RDX_sig
(
context
)
;
case
X86Encoding
:
:
rbx
:
return
&
RBX_sig
(
context
)
;
case
X86Encoding
:
:
rsp
:
return
&
RSP_sig
(
context
)
;
case
X86Encoding
:
:
rbp
:
return
&
RBP_sig
(
context
)
;
case
X86Encoding
:
:
rsi
:
return
&
RSI_sig
(
context
)
;
case
X86Encoding
:
:
rdi
:
return
&
RDI_sig
(
context
)
;
case
X86Encoding
:
:
r8
:
return
&
R8_sig
(
context
)
;
case
X86Encoding
:
:
r9
:
return
&
R9_sig
(
context
)
;
case
X86Encoding
:
:
r10
:
return
&
R10_sig
(
context
)
;
case
X86Encoding
:
:
r11
:
return
&
R11_sig
(
context
)
;
case
X86Encoding
:
:
r12
:
return
&
R12_sig
(
context
)
;
case
X86Encoding
:
:
r13
:
return
&
R13_sig
(
context
)
;
case
X86Encoding
:
:
r14
:
return
&
R14_sig
(
context
)
;
case
X86Encoding
:
:
r15
:
return
&
R15_sig
(
context
)
;
default
:
break
;
}
MOZ_CRASH
(
)
;
}
#
else
MOZ_COLD
static
void
*
AddressOfFPRegisterSlot
(
EMULATOR_CONTEXT
*
context
FloatRegisters
:
:
Encoding
encoding
)
{
switch
(
encoding
)
{
case
X86Encoding
:
:
xmm0
:
return
&
context
-
>
float_
.
__fpu_xmm0
;
case
X86Encoding
:
:
xmm1
:
return
&
context
-
>
float_
.
__fpu_xmm1
;
case
X86Encoding
:
:
xmm2
:
return
&
context
-
>
float_
.
__fpu_xmm2
;
case
X86Encoding
:
:
xmm3
:
return
&
context
-
>
float_
.
__fpu_xmm3
;
case
X86Encoding
:
:
xmm4
:
return
&
context
-
>
float_
.
__fpu_xmm4
;
case
X86Encoding
:
:
xmm5
:
return
&
context
-
>
float_
.
__fpu_xmm5
;
case
X86Encoding
:
:
xmm6
:
return
&
context
-
>
float_
.
__fpu_xmm6
;
case
X86Encoding
:
:
xmm7
:
return
&
context
-
>
float_
.
__fpu_xmm7
;
case
X86Encoding
:
:
xmm8
:
return
&
context
-
>
float_
.
__fpu_xmm8
;
case
X86Encoding
:
:
xmm9
:
return
&
context
-
>
float_
.
__fpu_xmm9
;
case
X86Encoding
:
:
xmm10
:
return
&
context
-
>
float_
.
__fpu_xmm10
;
case
X86Encoding
:
:
xmm11
:
return
&
context
-
>
float_
.
__fpu_xmm11
;
case
X86Encoding
:
:
xmm12
:
return
&
context
-
>
float_
.
__fpu_xmm12
;
case
X86Encoding
:
:
xmm13
:
return
&
context
-
>
float_
.
__fpu_xmm13
;
case
X86Encoding
:
:
xmm14
:
return
&
context
-
>
float_
.
__fpu_xmm14
;
case
X86Encoding
:
:
xmm15
:
return
&
context
-
>
float_
.
__fpu_xmm15
;
default
:
break
;
}
MOZ_CRASH
(
)
;
}
MOZ_COLD
static
void
*
AddressOfGPRegisterSlot
(
EMULATOR_CONTEXT
*
context
Registers
:
:
Code
code
)
{
switch
(
code
)
{
case
X86Encoding
:
:
rax
:
return
&
context
-
>
thread
.
__rax
;
case
X86Encoding
:
:
rcx
:
return
&
context
-
>
thread
.
__rcx
;
case
X86Encoding
:
:
rdx
:
return
&
context
-
>
thread
.
__rdx
;
case
X86Encoding
:
:
rbx
:
return
&
context
-
>
thread
.
__rbx
;
case
X86Encoding
:
:
rsp
:
return
&
context
-
>
thread
.
__rsp
;
case
X86Encoding
:
:
rbp
:
return
&
context
-
>
thread
.
__rbp
;
case
X86Encoding
:
:
rsi
:
return
&
context
-
>
thread
.
__rsi
;
case
X86Encoding
:
:
rdi
:
return
&
context
-
>
thread
.
__rdi
;
case
X86Encoding
:
:
r8
:
return
&
context
-
>
thread
.
__r8
;
case
X86Encoding
:
:
r9
:
return
&
context
-
>
thread
.
__r9
;
case
X86Encoding
:
:
r10
:
return
&
context
-
>
thread
.
__r10
;
case
X86Encoding
:
:
r11
:
return
&
context
-
>
thread
.
__r11
;
case
X86Encoding
:
:
r12
:
return
&
context
-
>
thread
.
__r12
;
case
X86Encoding
:
:
r13
:
return
&
context
-
>
thread
.
__r13
;
case
X86Encoding
:
:
r14
:
return
&
context
-
>
thread
.
__r14
;
case
X86Encoding
:
:
r15
:
return
&
context
-
>
thread
.
__r15
;
default
:
break
;
}
MOZ_CRASH
(
)
;
}
#
endif
MOZ_COLD
static
void
SetRegisterToCoercedUndefined
(
EMULATOR_CONTEXT
*
context
size_t
size
const
Disassembler
:
:
OtherOperand
&
value
)
{
if
(
value
.
kind
(
)
=
=
Disassembler
:
:
OtherOperand
:
:
FPR
)
SetFPRegToNaN
(
size
AddressOfFPRegisterSlot
(
context
value
.
fpr
(
)
)
)
;
else
SetGPRegToZero
(
AddressOfGPRegisterSlot
(
context
value
.
gpr
(
)
)
)
;
}
MOZ_COLD
static
void
SetRegisterToLoadedValue
(
EMULATOR_CONTEXT
*
context
SharedMem
<
void
*
>
addr
size_t
size
const
Disassembler
:
:
OtherOperand
&
value
)
{
if
(
value
.
kind
(
)
=
=
Disassembler
:
:
OtherOperand
:
:
FPR
)
SetFPRegToLoadedValue
(
addr
size
AddressOfFPRegisterSlot
(
context
value
.
fpr
(
)
)
)
;
else
SetGPRegToLoadedValue
(
addr
size
AddressOfGPRegisterSlot
(
context
value
.
gpr
(
)
)
)
;
}
MOZ_COLD
static
void
SetRegisterToLoadedValueSext32
(
EMULATOR_CONTEXT
*
context
SharedMem
<
void
*
>
addr
size_t
size
const
Disassembler
:
:
OtherOperand
&
value
)
{
SetGPRegToLoadedValueSext32
(
addr
size
AddressOfGPRegisterSlot
(
context
value
.
gpr
(
)
)
)
;
}
MOZ_COLD
static
void
StoreValueFromRegister
(
EMULATOR_CONTEXT
*
context
SharedMem
<
void
*
>
addr
size_t
size
const
Disassembler
:
:
OtherOperand
&
value
)
{
if
(
value
.
kind
(
)
=
=
Disassembler
:
:
OtherOperand
:
:
FPR
)
StoreValueFromFPReg
(
addr
size
AddressOfFPRegisterSlot
(
context
value
.
fpr
(
)
)
)
;
else
if
(
value
.
kind
(
)
=
=
Disassembler
:
:
OtherOperand
:
:
GPR
)
StoreValueFromGPReg
(
addr
size
AddressOfGPRegisterSlot
(
context
value
.
gpr
(
)
)
)
;
else
StoreValueFromGPImm
(
addr
size
value
.
imm
(
)
)
;
}
MOZ_COLD
static
uint8_t
*
ComputeAccessAddress
(
EMULATOR_CONTEXT
*
context
const
Disassembler
:
:
ComplexAddress
&
address
)
{
MOZ_RELEASE_ASSERT
(
!
address
.
isPCRelative
(
)
"
PC
-
relative
addresses
not
supported
yet
"
)
;
uintptr_t
result
=
address
.
disp
(
)
;
if
(
address
.
hasBase
(
)
)
{
uintptr_t
base
;
StoreValueFromGPReg
(
SharedMem
<
void
*
>
:
:
unshared
(
&
base
)
sizeof
(
uintptr_t
)
AddressOfGPRegisterSlot
(
context
address
.
base
(
)
)
)
;
result
+
=
base
;
}
if
(
address
.
hasIndex
(
)
)
{
uintptr_t
index
;
StoreValueFromGPReg
(
SharedMem
<
void
*
>
:
:
unshared
(
&
index
)
sizeof
(
uintptr_t
)
AddressOfGPRegisterSlot
(
context
address
.
index
(
)
)
)
;
MOZ_ASSERT
(
address
.
scale
(
)
<
32
"
address
shift
overflow
"
)
;
result
+
=
index
*
(
uintptr_t
(
1
)
<
<
address
.
scale
(
)
)
;
}
return
reinterpret_cast
<
uint8_t
*
>
(
result
)
;
}
MOZ_COLD
static
void
HandleMemoryAccess
(
EMULATOR_CONTEXT
*
context
uint8_t
*
pc
uint8_t
*
faultingAddress
const
CodeSegment
*
segment
const
Instance
&
instance
JitActivation
*
activation
uint8_t
*
*
ppc
)
{
MOZ_RELEASE_ASSERT
(
instance
.
code
(
)
.
containsCodePC
(
pc
)
)
;
const
MemoryAccess
*
memoryAccess
=
instance
.
code
(
)
.
lookupMemoryAccess
(
pc
)
;
if
(
!
memoryAccess
)
{
activation
-
>
startWasmInterrupt
(
ToRegisterState
(
context
)
)
;
*
ppc
=
segment
-
>
outOfBoundsCode
(
)
;
return
;
}
MOZ_RELEASE_ASSERT
(
memoryAccess
-
>
insnOffset
(
)
=
=
(
pc
-
segment
-
>
base
(
)
)
)
;
if
(
memoryAccess
-
>
hasTrapOutOfLineCode
(
)
)
{
*
ppc
=
memoryAccess
-
>
trapOutOfLineCode
(
segment
-
>
base
(
)
)
;
return
;
}
MOZ_RELEASE_ASSERT
(
instance
.
isAsmJS
(
)
)
;
uint32_t
memoryLength
=
instance
.
memory
(
)
-
>
buffer
(
)
.
byteLength
(
)
;
Disassembler
:
:
HeapAccess
access
;
uint8_t
*
end
=
Disassembler
:
:
DisassembleHeapAccess
(
pc
&
access
)
;
const
Disassembler
:
:
ComplexAddress
&
address
=
access
.
address
(
)
;
MOZ_RELEASE_ASSERT
(
end
>
pc
)
;
MOZ_RELEASE_ASSERT
(
segment
-
>
containsCodePC
(
end
)
)
;
MOZ_RELEASE_ASSERT
(
address
.
disp
(
)
>
=
0
)
;
MOZ_RELEASE_ASSERT
(
address
.
base
(
)
=
=
HeapReg
.
code
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
address
.
hasIndex
(
)
|
|
address
.
index
(
)
!
=
HeapReg
.
code
(
)
)
;
MOZ_RELEASE_ASSERT
(
address
.
scale
(
)
=
=
0
)
;
if
(
address
.
hasBase
(
)
)
{
uintptr_t
base
;
StoreValueFromGPReg
(
SharedMem
<
void
*
>
:
:
unshared
(
&
base
)
sizeof
(
uintptr_t
)
AddressOfGPRegisterSlot
(
context
address
.
base
(
)
)
)
;
MOZ_RELEASE_ASSERT
(
reinterpret_cast
<
uint8_t
*
>
(
base
)
=
=
instance
.
memoryBase
(
)
)
;
}
if
(
address
.
hasIndex
(
)
)
{
uintptr_t
index
;
StoreValueFromGPReg
(
SharedMem
<
void
*
>
:
:
unshared
(
&
index
)
sizeof
(
uintptr_t
)
AddressOfGPRegisterSlot
(
context
address
.
index
(
)
)
)
;
MOZ_RELEASE_ASSERT
(
uint32_t
(
index
)
=
=
index
)
;
}
uint8_t
*
accessAddress
=
ComputeAccessAddress
(
context
address
)
;
MOZ_RELEASE_ASSERT
(
size_t
(
faultingAddress
-
accessAddress
)
<
access
.
size
(
)
"
Given
faulting
address
does
not
appear
to
be
within
computed
"
"
faulting
address
range
"
)
;
MOZ_RELEASE_ASSERT
(
accessAddress
>
=
instance
.
memoryBase
(
)
"
Access
begins
outside
the
asm
.
js
heap
"
)
;
MOZ_RELEASE_ASSERT
(
accessAddress
+
access
.
size
(
)
<
=
instance
.
memoryBase
(
)
+
instance
.
memoryMappedSize
(
)
"
Access
extends
beyond
the
asm
.
js
heap
guard
region
"
)
;
MOZ_RELEASE_ASSERT
(
accessAddress
+
access
.
size
(
)
>
instance
.
memoryBase
(
)
+
memoryLength
"
Computed
access
address
is
not
actually
out
of
bounds
"
)
;
intptr_t
unwrappedOffset
=
accessAddress
-
instance
.
memoryBase
(
)
.
unwrap
(
)
;
uint32_t
wrappedOffset
=
uint32_t
(
unwrappedOffset
)
;
size_t
size
=
access
.
size
(
)
;
MOZ_RELEASE_ASSERT
(
wrappedOffset
+
size
>
wrappedOffset
)
;
bool
inBounds
=
wrappedOffset
+
size
<
memoryLength
;
if
(
inBounds
)
{
SharedMem
<
uint8_t
*
>
wrappedAddress
=
instance
.
memoryBase
(
)
+
wrappedOffset
;
MOZ_RELEASE_ASSERT
(
wrappedAddress
>
=
instance
.
memoryBase
(
)
)
;
MOZ_RELEASE_ASSERT
(
wrappedAddress
+
size
>
wrappedAddress
)
;
MOZ_RELEASE_ASSERT
(
wrappedAddress
+
size
<
=
instance
.
memoryBase
(
)
+
memoryLength
)
;
switch
(
access
.
kind
(
)
)
{
case
Disassembler
:
:
HeapAccess
:
:
Load
:
SetRegisterToLoadedValue
(
context
wrappedAddress
.
cast
<
void
*
>
(
)
size
access
.
otherOperand
(
)
)
;
break
;
case
Disassembler
:
:
HeapAccess
:
:
LoadSext32
:
SetRegisterToLoadedValueSext32
(
context
wrappedAddress
.
cast
<
void
*
>
(
)
size
access
.
otherOperand
(
)
)
;
break
;
case
Disassembler
:
:
HeapAccess
:
:
Store
:
StoreValueFromRegister
(
context
wrappedAddress
.
cast
<
void
*
>
(
)
size
access
.
otherOperand
(
)
)
;
break
;
case
Disassembler
:
:
HeapAccess
:
:
LoadSext64
:
MOZ_CRASH
(
"
no
int64
accesses
in
asm
.
js
"
)
;
case
Disassembler
:
:
HeapAccess
:
:
Unknown
:
MOZ_CRASH
(
"
Failed
to
disassemble
instruction
"
)
;
}
}
else
{
switch
(
access
.
kind
(
)
)
{
case
Disassembler
:
:
HeapAccess
:
:
Load
:
case
Disassembler
:
:
HeapAccess
:
:
LoadSext32
:
SetRegisterToCoercedUndefined
(
context
access
.
size
(
)
access
.
otherOperand
(
)
)
;
break
;
case
Disassembler
:
:
HeapAccess
:
:
Store
:
break
;
case
Disassembler
:
:
HeapAccess
:
:
LoadSext64
:
MOZ_CRASH
(
"
no
int64
accesses
in
asm
.
js
"
)
;
case
Disassembler
:
:
HeapAccess
:
:
Unknown
:
MOZ_CRASH
(
"
Failed
to
disassemble
instruction
"
)
;
}
}
*
ppc
=
end
;
}
#
else
MOZ_COLD
static
void
HandleMemoryAccess
(
EMULATOR_CONTEXT
*
context
uint8_t
*
pc
uint8_t
*
faultingAddress
const
CodeSegment
*
segment
const
Instance
&
instance
JitActivation
*
activation
uint8_t
*
*
ppc
)
{
MOZ_RELEASE_ASSERT
(
instance
.
code
(
)
.
containsCodePC
(
pc
)
)
;
const
MemoryAccess
*
memoryAccess
=
instance
.
code
(
)
.
lookupMemoryAccess
(
pc
)
;
if
(
!
memoryAccess
)
{
activation
-
>
startWasmInterrupt
(
ToRegisterState
(
context
)
)
;
*
ppc
=
segment
-
>
outOfBoundsCode
(
)
;
return
;
}
MOZ_RELEASE_ASSERT
(
memoryAccess
-
>
hasTrapOutOfLineCode
(
)
)
;
*
ppc
=
memoryAccess
-
>
trapOutOfLineCode
(
segment
-
>
base
(
)
)
;
}
#
endif
MOZ_COLD
static
bool
IsHeapAccessAddress
(
const
Instance
&
instance
uint8_t
*
faultingAddress
)
{
size_t
accessLimit
=
instance
.
memoryMappedSize
(
)
;
return
instance
.
metadata
(
)
.
usesMemory
(
)
&
&
faultingAddress
>
=
instance
.
memoryBase
(
)
&
&
faultingAddress
<
instance
.
memoryBase
(
)
+
accessLimit
;
}
#
if
defined
(
XP_WIN
)
static
bool
HandleFault
(
PEXCEPTION_POINTERS
exception
)
{
EXCEPTION_RECORD
*
record
=
exception
-
>
ExceptionRecord
;
CONTEXT
*
context
=
exception
-
>
ContextRecord
;
if
(
record
-
>
ExceptionCode
!
=
EXCEPTION_ACCESS_VIOLATION
&
&
record
-
>
ExceptionCode
!
=
EXCEPTION_ILLEGAL_INSTRUCTION
)
{
return
false
;
}
uint8_t
*
*
ppc
=
ContextToPC
(
context
)
;
uint8_t
*
pc
=
*
ppc
;
const
CodeSegment
*
codeSegment
=
LookupCodeSegment
(
pc
)
;
if
(
!
codeSegment
)
return
false
;
JitActivation
*
activation
=
TlsContext
.
get
(
)
-
>
activation
(
)
-
>
asJit
(
)
;
MOZ_ASSERT
(
activation
)
;
const
Instance
*
instance
=
LookupFaultingInstance
(
*
codeSegment
pc
ContextToFP
(
context
)
)
;
if
(
!
instance
)
{
return
activation
-
>
isWasmInterrupted
(
)
&
&
pc
=
=
codeSegment
-
>
interruptCode
(
)
&
&
codeSegment
-
>
containsCodePC
(
activation
-
>
wasmInterruptResumePC
(
)
)
;
}
if
(
activation
-
>
isWasmInterrupted
(
)
)
{
MOZ_ASSERT
(
activation
-
>
wasmInterruptResumePC
(
)
=
=
pc
)
;
activation
-
>
finishWasmInterrupt
(
)
;
}
if
(
record
-
>
ExceptionCode
=
=
EXCEPTION_ILLEGAL_INSTRUCTION
)
{
Trap
trap
;
BytecodeOffset
bytecode
;
if
(
!
codeSegment
-
>
code
(
)
.
lookupTrap
(
pc
&
trap
&
bytecode
)
)
return
false
;
activation
-
>
startWasmTrap
(
trap
bytecode
.
offset
pc
ContextToFP
(
context
)
)
;
*
ppc
=
codeSegment
-
>
trapCode
(
)
;
return
true
;
}
if
(
record
-
>
NumberParameters
<
2
)
return
false
;
uint8_t
*
faultingAddress
=
reinterpret_cast
<
uint8_t
*
>
(
record
-
>
ExceptionInformation
[
1
]
)
;
if
(
!
IsHeapAccessAddress
(
*
instance
faultingAddress
)
)
return
false
;
MOZ_ASSERT
(
activation
-
>
compartment
(
)
=
=
instance
-
>
compartment
(
)
)
;
HandleMemoryAccess
(
context
pc
faultingAddress
codeSegment
*
instance
activation
ppc
)
;
return
true
;
}
static
LONG
WINAPI
WasmFaultHandler
(
LPEXCEPTION_POINTERS
exception
)
{
if
(
sAlreadyInSignalHandler
.
get
(
)
)
return
EXCEPTION_CONTINUE_SEARCH
;
AutoSignalHandler
ash
;
if
(
HandleFault
(
exception
)
)
return
EXCEPTION_CONTINUE_EXECUTION
;
return
EXCEPTION_CONTINUE_SEARCH
;
}
#
elif
defined
(
XP_DARWIN
)
#
include
<
mach
/
exc
.
h
>
#
pragma
pack
(
4
)
typedef
struct
{
mach_msg_header_t
Head
;
mach_msg_body_t
msgh_body
;
mach_msg_port_descriptor_t
thread
;
mach_msg_port_descriptor_t
task
;
NDR_record_t
NDR
;
exception_type_t
exception
;
mach_msg_type_number_t
codeCnt
;
int64_t
code
[
2
]
;
}
Request__mach_exception_raise_t
;
#
pragma
pack
(
)
struct
ExceptionRequest
{
Request__mach_exception_raise_t
body
;
mach_msg_trailer_t
trailer
;
}
;
static
bool
HandleMachException
(
JSContext
*
cx
const
ExceptionRequest
&
request
)
{
mach_port_t
cxThread
=
request
.
body
.
thread
.
name
;
EMULATOR_CONTEXT
context
;
#
if
defined
(
__x86_64__
)
unsigned
int
thread_state_count
=
x86_THREAD_STATE64_COUNT
;
unsigned
int
float_state_count
=
x86_FLOAT_STATE64_COUNT
;
int
thread_state
=
x86_THREAD_STATE64
;
int
float_state
=
x86_FLOAT_STATE64
;
#
elif
defined
(
__i386__
)
unsigned
int
thread_state_count
=
x86_THREAD_STATE_COUNT
;
unsigned
int
float_state_count
=
x86_FLOAT_STATE_COUNT
;
int
thread_state
=
x86_THREAD_STATE
;
int
float_state
=
x86_FLOAT_STATE
;
#
elif
defined
(
__arm__
)
unsigned
int
thread_state_count
=
ARM_THREAD_STATE_COUNT
;
unsigned
int
float_state_count
=
ARM_NEON_STATE_COUNT
;
int
thread_state
=
ARM_THREAD_STATE
;
int
float_state
=
ARM_NEON_STATE
;
#
else
#
error
Unsupported
architecture
#
endif
kern_return_t
kret
;
kret
=
thread_get_state
(
cxThread
thread_state
(
thread_state_t
)
&
context
.
thread
&
thread_state_count
)
;
if
(
kret
!
=
KERN_SUCCESS
)
return
false
;
kret
=
thread_get_state
(
cxThread
float_state
(
thread_state_t
)
&
context
.
float_
&
float_state_count
)
;
if
(
kret
!
=
KERN_SUCCESS
)
return
false
;
uint8_t
*
*
ppc
=
ContextToPC
(
&
context
)
;
uint8_t
*
pc
=
*
ppc
;
if
(
request
.
body
.
exception
!
=
EXC_BAD_ACCESS
&
&
request
.
body
.
exception
!
=
EXC_BAD_INSTRUCTION
)
{
return
false
;
}
AutoNoteSingleThreadedRegion
anstr
;
const
CodeSegment
*
codeSegment
=
LookupCodeSegment
(
pc
)
;
if
(
!
codeSegment
)
return
false
;
const
Instance
*
instance
=
LookupFaultingInstance
(
*
codeSegment
pc
ContextToFP
(
&
context
)
)
;
if
(
!
instance
)
return
false
;
JitActivation
*
activation
=
cx
-
>
activation
(
)
-
>
asJit
(
)
;
MOZ_ASSERT
(
activation
-
>
compartment
(
)
=
=
instance
-
>
compartment
(
)
)
;
if
(
request
.
body
.
exception
=
=
EXC_BAD_INSTRUCTION
)
{
Trap
trap
;
BytecodeOffset
bytecode
;
if
(
!
codeSegment
-
>
code
(
)
.
lookupTrap
(
pc
&
trap
&
bytecode
)
)
return
false
;
activation
-
>
startWasmTrap
(
trap
bytecode
.
offset
pc
ContextToFP
(
&
context
)
)
;
*
ppc
=
codeSegment
-
>
trapCode
(
)
;
}
else
{
MOZ_ASSERT
(
request
.
body
.
exception
=
=
EXC_BAD_ACCESS
)
;
if
(
request
.
body
.
codeCnt
!
=
2
)
return
false
;
uint8_t
*
faultingAddress
=
reinterpret_cast
<
uint8_t
*
>
(
request
.
body
.
code
[
1
]
)
;
if
(
!
IsHeapAccessAddress
(
*
instance
faultingAddress
)
)
return
false
;
HandleMemoryAccess
(
&
context
pc
faultingAddress
codeSegment
*
instance
activation
ppc
)
;
}
kret
=
thread_set_state
(
cxThread
float_state
(
thread_state_t
)
&
context
.
float_
float_state_count
)
;
if
(
kret
!
=
KERN_SUCCESS
)
return
false
;
kret
=
thread_set_state
(
cxThread
thread_state
(
thread_state_t
)
&
context
.
thread
thread_state_count
)
;
if
(
kret
!
=
KERN_SUCCESS
)
return
false
;
return
true
;
}
static
const
mach_msg_id_t
sExceptionId
=
2405
;
static
const
mach_msg_id_t
sQuitId
=
42
;
static
void
MachExceptionHandlerThread
(
JSContext
*
cx
)
{
mach_port_t
port
=
cx
-
>
wasmMachExceptionHandler
.
port
(
)
;
kern_return_t
kret
;
while
(
true
)
{
ExceptionRequest
request
;
kret
=
mach_msg
(
&
request
.
body
.
Head
MACH_RCV_MSG
0
sizeof
(
request
)
port
MACH_MSG_TIMEOUT_NONE
MACH_PORT_NULL
)
;
if
(
kret
!
=
KERN_SUCCESS
)
{
fprintf
(
stderr
"
MachExceptionHandlerThread
:
mach_msg
failed
with
%
d
\
n
"
(
int
)
kret
)
;
MOZ_CRASH
(
)
;
}
if
(
request
.
body
.
Head
.
msgh_id
=
=
sQuitId
)
break
;
if
(
request
.
body
.
Head
.
msgh_id
!
=
sExceptionId
)
{
fprintf
(
stderr
"
Unexpected
msg
header
id
%
d
\
n
"
(
int
)
request
.
body
.
Head
.
msgh_bits
)
;
MOZ_CRASH
(
)
;
}
bool
handled
=
HandleMachException
(
cx
request
)
;
kern_return_t
replyCode
=
handled
?
KERN_SUCCESS
:
KERN_FAILURE
;
__Reply__exception_raise_t
reply
;
reply
.
Head
.
msgh_bits
=
MACH_MSGH_BITS
(
MACH_MSGH_BITS_REMOTE
(
request
.
body
.
Head
.
msgh_bits
)
0
)
;
reply
.
Head
.
msgh_size
=
sizeof
(
reply
)
;
reply
.
Head
.
msgh_remote_port
=
request
.
body
.
Head
.
msgh_remote_port
;
reply
.
Head
.
msgh_local_port
=
MACH_PORT_NULL
;
reply
.
Head
.
msgh_id
=
request
.
body
.
Head
.
msgh_id
+
100
;
reply
.
NDR
=
NDR_record
;
reply
.
RetCode
=
replyCode
;
mach_msg
(
&
reply
.
Head
MACH_SEND_MSG
sizeof
(
reply
)
0
MACH_PORT_NULL
MACH_MSG_TIMEOUT_NONE
MACH_PORT_NULL
)
;
}
}
MachExceptionHandler
:
:
MachExceptionHandler
(
)
:
installed_
(
false
)
thread_
(
)
port_
(
MACH_PORT_NULL
)
{
}
void
MachExceptionHandler
:
:
uninstall
(
)
{
if
(
installed_
)
{
thread_port_t
thread
=
mach_thread_self
(
)
;
kern_return_t
kret
=
thread_set_exception_ports
(
thread
EXC_MASK_BAD_ACCESS
MACH_PORT_NULL
EXCEPTION_DEFAULT
|
MACH_EXCEPTION_CODES
THREAD_STATE_NONE
)
;
mach_port_deallocate
(
mach_task_self
(
)
thread
)
;
if
(
kret
!
=
KERN_SUCCESS
)
MOZ_CRASH
(
)
;
installed_
=
false
;
}
if
(
thread_
.
joinable
(
)
)
{
mach_msg_header_t
msg
;
msg
.
msgh_bits
=
MACH_MSGH_BITS
(
MACH_MSG_TYPE_COPY_SEND
0
)
;
msg
.
msgh_size
=
sizeof
(
msg
)
;
msg
.
msgh_remote_port
=
port_
;
msg
.
msgh_local_port
=
MACH_PORT_NULL
;
msg
.
msgh_reserved
=
0
;
msg
.
msgh_id
=
sQuitId
;
kern_return_t
kret
=
mach_msg
(
&
msg
MACH_SEND_MSG
sizeof
(
msg
)
0
MACH_PORT_NULL
MACH_MSG_TIMEOUT_NONE
MACH_PORT_NULL
)
;
if
(
kret
!
=
KERN_SUCCESS
)
{
fprintf
(
stderr
"
MachExceptionHandler
:
failed
to
send
quit
message
:
%
d
\
n
"
(
int
)
kret
)
;
MOZ_CRASH
(
)
;
}
thread_
.
join
(
)
;
}
if
(
port_
!
=
MACH_PORT_NULL
)
{
DebugOnly
<
kern_return_t
>
kret
=
mach_port_destroy
(
mach_task_self
(
)
port_
)
;
MOZ_ASSERT
(
kret
=
=
KERN_SUCCESS
)
;
port_
=
MACH_PORT_NULL
;
}
}
bool
MachExceptionHandler
:
:
install
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
!
installed
(
)
)
;
kern_return_t
kret
;
mach_port_t
thread
;
auto
onFailure
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
uninstall
(
)
;
}
)
;
kret
=
mach_port_allocate
(
mach_task_self
(
)
MACH_PORT_RIGHT_RECEIVE
&
port_
)
;
if
(
kret
!
=
KERN_SUCCESS
)
return
false
;
kret
=
mach_port_insert_right
(
mach_task_self
(
)
port_
port_
MACH_MSG_TYPE_MAKE_SEND
)
;
if
(
kret
!
=
KERN_SUCCESS
)
return
false
;
if
(
!
thread_
.
init
(
MachExceptionHandlerThread
cx
)
)
return
false
;
thread
=
mach_thread_self
(
)
;
kret
=
thread_set_exception_ports
(
thread
EXC_MASK_BAD_ACCESS
port_
EXCEPTION_DEFAULT
|
MACH_EXCEPTION_CODES
THREAD_STATE_NONE
)
;
mach_port_deallocate
(
mach_task_self
(
)
thread
)
;
if
(
kret
!
=
KERN_SUCCESS
)
return
false
;
installed_
=
true
;
onFailure
.
release
(
)
;
return
true
;
}
#
else
static
bool
HandleFault
(
int
signum
siginfo_t
*
info
void
*
ctx
)
{
if
(
sAlreadyInSignalHandler
.
get
(
)
)
return
false
;
AutoSignalHandler
ash
;
MOZ_RELEASE_ASSERT
(
signum
=
=
SIGSEGV
|
|
signum
=
=
SIGBUS
|
|
signum
=
=
SIGILL
)
;
CONTEXT
*
context
=
(
CONTEXT
*
)
ctx
;
uint8_t
*
*
ppc
=
ContextToPC
(
context
)
;
uint8_t
*
pc
=
*
ppc
;
const
CodeSegment
*
segment
=
LookupCodeSegment
(
pc
)
;
if
(
!
segment
)
return
false
;
const
Instance
*
instance
=
LookupFaultingInstance
(
*
segment
pc
ContextToFP
(
context
)
)
;
if
(
!
instance
)
return
false
;
JitActivation
*
activation
=
TlsContext
.
get
(
)
-
>
activation
(
)
-
>
asJit
(
)
;
MOZ_ASSERT
(
activation
-
>
compartment
(
)
=
=
instance
-
>
compartment
(
)
)
;
if
(
signum
=
=
SIGILL
)
{
Trap
trap
;
BytecodeOffset
bytecode
;
if
(
!
segment
-
>
code
(
)
.
lookupTrap
(
pc
&
trap
&
bytecode
)
)
return
false
;
activation
-
>
startWasmTrap
(
trap
bytecode
.
offset
pc
ContextToFP
(
context
)
)
;
*
ppc
=
segment
-
>
trapCode
(
)
;
return
true
;
}
uint8_t
*
faultingAddress
=
reinterpret_cast
<
uint8_t
*
>
(
info
-
>
si_addr
)
;
if
(
!
faultingAddress
)
{
#
ifdef
SI_KERNEL
if
(
info
-
>
si_code
!
=
SI_KERNEL
)
return
false
;
#
else
return
false
;
#
endif
}
else
{
if
(
!
IsHeapAccessAddress
(
*
instance
faultingAddress
)
)
return
false
;
}
#
ifdef
JS_CODEGEN_ARM
if
(
signum
=
=
SIGBUS
)
{
activation
-
>
startWasmInterrupt
(
ToRegisterState
(
context
)
)
;
*
ppc
=
segment
-
>
unalignedAccessCode
(
)
;
return
true
;
}
#
endif
HandleMemoryAccess
(
context
pc
faultingAddress
segment
*
instance
activation
ppc
)
;
return
true
;
}
static
struct
sigaction
sPrevSEGVHandler
;
static
struct
sigaction
sPrevSIGBUSHandler
;
static
struct
sigaction
sPrevSIGILLHandler
;
static
void
WasmFaultHandler
(
int
signum
siginfo_t
*
info
void
*
context
)
{
if
(
HandleFault
(
signum
info
context
)
)
return
;
struct
sigaction
*
previousSignal
=
nullptr
;
switch
(
signum
)
{
case
SIGSEGV
:
previousSignal
=
&
sPrevSEGVHandler
;
break
;
case
SIGBUS
:
previousSignal
=
&
sPrevSIGBUSHandler
;
break
;
case
SIGILL
:
previousSignal
=
&
sPrevSIGILLHandler
;
break
;
}
MOZ_ASSERT
(
previousSignal
)
;
if
(
previousSignal
-
>
sa_flags
&
SA_SIGINFO
)
previousSignal
-
>
sa_sigaction
(
signum
info
context
)
;
else
if
(
previousSignal
-
>
sa_handler
=
=
SIG_DFL
|
|
previousSignal
-
>
sa_handler
=
=
SIG_IGN
)
sigaction
(
signum
previousSignal
nullptr
)
;
else
previousSignal
-
>
sa_handler
(
signum
)
;
}
#
endif
static
void
RedirectIonBackedgesToInterruptCheck
(
JSContext
*
cx
)
{
if
(
!
cx
-
>
runtime
(
)
-
>
hasJitRuntime
(
)
)
return
;
jit
:
:
JitRuntime
*
jitRuntime
=
cx
-
>
runtime
(
)
-
>
jitRuntime
(
)
;
Zone
*
zone
=
cx
-
>
zoneRaw
(
)
;
if
(
zone
&
&
!
zone
-
>
isAtomsZone
(
)
)
{
if
(
!
jitRuntime
-
>
preventBackedgePatching
(
)
)
{
jit
:
:
JitZoneGroup
*
jzg
=
zone
-
>
group
(
)
-
>
jitZoneGroup
;
jzg
-
>
patchIonBackedges
(
cx
jit
:
:
JitZoneGroup
:
:
BackedgeInterruptCheck
)
;
}
}
}
bool
wasm
:
:
InInterruptibleCode
(
JSContext
*
cx
uint8_t
*
pc
const
CodeSegment
*
*
cs
)
{
if
(
!
cx
-
>
compartment
(
)
)
return
false
;
*
cs
=
LookupCodeSegment
(
pc
)
;
if
(
!
*
cs
)
return
false
;
const
Code
&
code
=
(
*
cs
)
-
>
code
(
)
;
const
CodeRange
*
codeRange
=
code
.
lookupRange
(
pc
)
;
return
codeRange
&
&
codeRange
-
>
isFunction
(
)
;
}
static
bool
RedirectJitCodeToInterruptCheck
(
JSContext
*
cx
CONTEXT
*
context
)
{
if
(
cx
!
=
cx
-
>
runtime
(
)
-
>
activeContext
(
)
)
return
false
;
AutoNoteSingleThreadedRegion
anstr
;
RedirectIonBackedgesToInterruptCheck
(
cx
)
;
#
ifdef
JS_SIMULATOR
uint8_t
*
pc
=
cx
-
>
simulator
(
)
-
>
get_pc_as
<
uint8_t
*
>
(
)
;
#
else
uint8_t
*
pc
=
*
ContextToPC
(
context
)
;
#
endif
const
CodeSegment
*
codeSegment
=
nullptr
;
if
(
!
InInterruptibleCode
(
cx
pc
&
codeSegment
)
)
return
false
;
#
ifdef
JS_SIMULATOR
cx
-
>
simulator
(
)
-
>
trigger_wasm_interrupt
(
)
;
#
else
JitActivation
*
activation
=
cx
-
>
activation
(
)
-
>
asJit
(
)
;
uint8_t
*
fp
=
ContextToFP
(
context
)
;
if
(
!
fp
)
return
false
;
if
(
activation
-
>
isWasmInterrupted
(
)
)
return
false
;
activation
-
>
startWasmInterrupt
(
ToRegisterState
(
context
)
)
;
*
ContextToPC
(
context
)
=
codeSegment
-
>
interruptCode
(
)
;
#
endif
return
true
;
}
#
if
!
defined
(
XP_WIN
)
static
const
int
sInterruptSignal
=
SIGVTALRM
;
static
void
JitInterruptHandler
(
int
signum
siginfo_t
*
info
void
*
context
)
{
if
(
JSContext
*
cx
=
TlsContext
.
get
(
)
)
{
#
if
defined
(
JS_SIMULATOR_ARM
)
|
|
defined
(
JS_SIMULATOR_MIPS32
)
|
|
defined
(
JS_SIMULATOR_MIPS64
)
SimulatorProcess
:
:
ICacheCheckingDisableCount
+
+
;
#
endif
RedirectJitCodeToInterruptCheck
(
cx
(
CONTEXT
*
)
context
)
;
#
if
defined
(
JS_SIMULATOR_ARM
)
|
|
defined
(
JS_SIMULATOR_MIPS32
)
|
|
defined
(
JS_SIMULATOR_MIPS64
)
SimulatorProcess
:
:
cacheInvalidatedBySignalHandler_
=
true
;
SimulatorProcess
:
:
ICacheCheckingDisableCount
-
-
;
#
endif
cx
-
>
finishHandlingJitInterrupt
(
)
;
}
}
#
endif
static
bool
sTriedInstallSignalHandlers
=
false
;
static
bool
sHaveSignalHandlers
=
false
;
static
bool
ProcessHasSignalHandlers
(
)
{
if
(
sTriedInstallSignalHandlers
)
return
sHaveSignalHandlers
;
sTriedInstallSignalHandlers
=
true
;
#
if
defined
(
ANDROID
)
#
if
!
defined
(
__aarch64__
)
char
version_string
[
PROP_VALUE_MAX
]
;
PodArrayZero
(
version_string
)
;
if
(
__system_property_get
(
"
ro
.
build
.
version
.
sdk
"
version_string
)
>
0
)
{
if
(
atol
(
version_string
)
<
19
)
return
false
;
}
#
endif
#
if
defined
(
MOZ_LINKER
)
if
(
IsSignalHandlingBroken
(
)
)
return
false
;
#
endif
#
endif
#
if
defined
(
XP_WIN
)
#
else
struct
sigaction
interruptHandler
;
interruptHandler
.
sa_flags
=
SA_SIGINFO
;
interruptHandler
.
sa_sigaction
=
&
JitInterruptHandler
;
sigemptyset
(
&
interruptHandler
.
sa_mask
)
;
struct
sigaction
prev
;
if
(
sigaction
(
sInterruptSignal
&
interruptHandler
&
prev
)
)
MOZ_CRASH
(
"
unable
to
install
interrupt
handler
"
)
;
if
(
(
prev
.
sa_flags
&
SA_SIGINFO
&
&
prev
.
sa_sigaction
)
|
|
(
prev
.
sa_handler
!
=
SIG_DFL
&
&
prev
.
sa_handler
!
=
SIG_IGN
)
)
{
MOZ_CRASH
(
"
contention
for
interrupt
signal
"
)
;
}
#
endif
sAlreadyInSignalHandler
.
infallibleInit
(
)
;
#
if
defined
(
XP_WIN
)
#
if
defined
(
MOZ_ASAN
)
const
bool
firstHandler
=
false
;
#
else
const
bool
firstHandler
=
true
;
#
endif
if
(
!
AddVectoredExceptionHandler
(
firstHandler
WasmFaultHandler
)
)
return
false
;
#
elif
defined
(
XP_DARWIN
)
#
else
struct
sigaction
faultHandler
;
faultHandler
.
sa_flags
=
SA_SIGINFO
|
SA_NODEFER
|
SA_ONSTACK
;
faultHandler
.
sa_sigaction
=
WasmFaultHandler
;
sigemptyset
(
&
faultHandler
.
sa_mask
)
;
if
(
sigaction
(
SIGSEGV
&
faultHandler
&
sPrevSEGVHandler
)
)
MOZ_CRASH
(
"
unable
to
install
segv
handler
"
)
;
#
if
defined
(
JS_CODEGEN_ARM
)
struct
sigaction
busHandler
;
busHandler
.
sa_flags
=
SA_SIGINFO
|
SA_NODEFER
|
SA_ONSTACK
;
busHandler
.
sa_sigaction
=
WasmFaultHandler
;
sigemptyset
(
&
busHandler
.
sa_mask
)
;
if
(
sigaction
(
SIGBUS
&
busHandler
&
sPrevSIGBUSHandler
)
)
MOZ_CRASH
(
"
unable
to
install
sigbus
handler
"
)
;
#
endif
struct
sigaction
illegalHandler
;
illegalHandler
.
sa_flags
=
SA_SIGINFO
|
SA_NODEFER
|
SA_ONSTACK
;
illegalHandler
.
sa_sigaction
=
WasmFaultHandler
;
sigemptyset
(
&
illegalHandler
.
sa_mask
)
;
if
(
sigaction
(
SIGILL
&
illegalHandler
&
sPrevSIGILLHandler
)
)
MOZ_CRASH
(
"
unable
to
install
segv
handler
"
)
;
#
endif
sHaveSignalHandlers
=
true
;
return
true
;
}
bool
wasm
:
:
EnsureSignalHandlers
(
JSContext
*
cx
)
{
if
(
!
ProcessHasSignalHandlers
(
)
)
return
true
;
#
if
defined
(
XP_DARWIN
)
if
(
!
cx
-
>
wasmMachExceptionHandler
.
installed
(
)
&
&
!
cx
-
>
wasmMachExceptionHandler
.
install
(
cx
)
)
return
false
;
#
endif
return
true
;
}
bool
wasm
:
:
HaveSignalHandlers
(
)
{
MOZ_ASSERT
(
sTriedInstallSignalHandlers
)
;
return
sHaveSignalHandlers
;
}
void
js
:
:
InterruptRunningJitCode
(
JSContext
*
cx
)
{
if
(
!
HaveSignalHandlers
(
)
)
return
;
if
(
!
cx
-
>
startHandlingJitInterrupt
(
)
)
return
;
if
(
cx
=
=
TlsContext
.
get
(
)
)
{
RedirectIonBackedgesToInterruptCheck
(
cx
)
;
cx
-
>
finishHandlingJitInterrupt
(
)
;
return
;
}
#
if
defined
(
XP_WIN
)
HANDLE
thread
=
(
HANDLE
)
cx
-
>
threadNative
(
)
;
if
(
SuspendThread
(
thread
)
!
=
(
DWORD
)
-
1
)
{
CONTEXT
context
;
context
.
ContextFlags
=
CONTEXT_FULL
;
if
(
GetThreadContext
(
thread
&
context
)
)
{
if
(
RedirectJitCodeToInterruptCheck
(
cx
&
context
)
)
SetThreadContext
(
thread
&
context
)
;
}
ResumeThread
(
thread
)
;
}
cx
-
>
finishHandlingJitInterrupt
(
)
;
#
else
pthread_t
thread
=
(
pthread_t
)
cx
-
>
threadNative
(
)
;
pthread_kill
(
thread
sInterruptSignal
)
;
#
endif
}
