#
ifndef
wasm_compile_h
#
define
wasm_compile_h
#
include
"
wasm
/
WasmModule
.
h
"
namespace
js
{
namespace
wasm
{
struct
ScriptedCaller
{
UniqueChars
filename
;
bool
filenameIsURL
;
unsigned
line
;
ScriptedCaller
(
)
:
filenameIsURL
(
false
)
line
(
0
)
{
}
}
;
struct
CompileArgs
:
ShareableBase
<
CompileArgs
>
{
Assumptions
assumptions
;
ScriptedCaller
scriptedCaller
;
UniqueChars
sourceMapURL
;
bool
baselineEnabled
;
bool
debugEnabled
;
bool
ionEnabled
;
bool
sharedMemoryEnabled
;
HasGcTypes
gcTypesConfigured
;
bool
testTiering
;
CompileArgs
(
Assumptions
&
&
assumptions
ScriptedCaller
&
&
scriptedCaller
)
:
assumptions
(
std
:
:
move
(
assumptions
)
)
scriptedCaller
(
std
:
:
move
(
scriptedCaller
)
)
baselineEnabled
(
false
)
debugEnabled
(
false
)
ionEnabled
(
false
)
sharedMemoryEnabled
(
false
)
gcTypesConfigured
(
HasGcTypes
:
:
False
)
testTiering
(
false
)
{
}
CompileArgs
(
)
=
default
;
bool
initFromContext
(
JSContext
*
cx
ScriptedCaller
&
&
scriptedCaller
)
;
}
;
typedef
RefPtr
<
CompileArgs
>
MutableCompileArgs
;
typedef
RefPtr
<
const
CompileArgs
>
SharedCompileArgs
;
double
EstimateCompiledCodeSize
(
Tier
tier
size_t
bytecodeSize
)
;
SharedModule
CompileBuffer
(
const
CompileArgs
&
args
const
ShareableBytes
&
bytecode
UniqueChars
*
error
UniqueCharsVector
*
warnings
)
;
void
CompileTier2
(
const
CompileArgs
&
args
Module
&
module
Atomic
<
bool
>
*
cancelled
)
;
typedef
ExclusiveWaitableData
<
const
uint8_t
*
>
ExclusiveStreamEnd
;
typedef
ExclusiveWaitableData
<
const
Bytes
*
>
ExclusiveTailBytesPtr
;
SharedModule
CompileStreaming
(
const
CompileArgs
&
args
const
Bytes
&
envBytes
const
Bytes
&
codeBytes
const
ExclusiveStreamEnd
&
codeStreamEnd
const
ExclusiveTailBytesPtr
&
tailBytesPtr
const
Atomic
<
bool
>
&
cancelled
UniqueChars
*
error
UniqueCharsVector
*
warnings
)
;
}
}
#
endif
