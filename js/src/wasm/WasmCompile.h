#
ifndef
wasm_compile_h
#
define
wasm_compile_h
#
include
"
vm
/
Runtime
.
h
"
#
include
"
wasm
/
WasmModule
.
h
"
namespace
js
{
namespace
wasm
{
uint32_t
ObservedCPUFeatures
(
)
;
struct
ScriptedCaller
{
UniqueChars
filename
;
bool
filenameIsURL
;
unsigned
line
;
ScriptedCaller
(
)
:
filenameIsURL
(
false
)
line
(
0
)
{
}
}
;
struct
FeatureArgs
{
FeatureArgs
(
)
:
sharedMemory
(
Shareable
:
:
False
)
refTypes
(
false
)
functionReferences
(
false
)
gcTypes
(
false
)
multiValue
(
false
)
v128
(
false
)
hugeMemory
(
false
)
exceptions
(
false
)
{
}
static
FeatureArgs
build
(
JSContext
*
cx
)
;
FeatureArgs
withRefTypes
(
bool
refTypes
)
const
{
FeatureArgs
features
=
*
this
;
features
.
refTypes
=
refTypes
;
return
features
;
}
Shareable
sharedMemory
;
bool
refTypes
;
bool
functionReferences
;
bool
gcTypes
;
bool
multiValue
;
bool
v128
;
bool
hugeMemory
;
bool
exceptions
;
}
;
struct
CompileArgs
;
using
MutableCompileArgs
=
RefPtr
<
CompileArgs
>
;
using
SharedCompileArgs
=
RefPtr
<
const
CompileArgs
>
;
struct
CompileArgs
:
ShareableBase
<
CompileArgs
>
{
ScriptedCaller
scriptedCaller
;
UniqueChars
sourceMapURL
;
bool
baselineEnabled
;
bool
ionEnabled
;
bool
craneliftEnabled
;
bool
debugEnabled
;
bool
forceTiering
;
FeatureArgs
features
;
static
SharedCompileArgs
build
(
JSContext
*
cx
ScriptedCaller
&
&
scriptedCaller
)
;
explicit
CompileArgs
(
ScriptedCaller
&
&
scriptedCaller
)
:
scriptedCaller
(
std
:
:
move
(
scriptedCaller
)
)
baselineEnabled
(
false
)
ionEnabled
(
false
)
craneliftEnabled
(
false
)
debugEnabled
(
false
)
forceTiering
(
false
)
{
}
}
;
double
EstimateCompiledCodeSize
(
Tier
tier
size_t
bytecodeSize
)
;
SharedModule
CompileBuffer
(
const
CompileArgs
&
args
const
ShareableBytes
&
bytecode
UniqueChars
*
error
UniqueCharsVector
*
warnings
JS
:
:
OptimizedEncodingListener
*
listener
=
nullptr
JSTelemetrySender
telemetrySender
=
JSTelemetrySender
(
)
)
;
void
CompileTier2
(
const
CompileArgs
&
args
const
Bytes
&
bytecode
const
Module
&
module
Atomic
<
bool
>
*
cancelled
JSTelemetrySender
telemetrySender
=
JSTelemetrySender
(
)
)
;
using
ExclusiveBytesPtr
=
ExclusiveWaitableData
<
const
uint8_t
*
>
;
struct
StreamEndData
{
bool
reached
;
const
Bytes
*
tailBytes
;
Tier2Listener
tier2Listener
;
StreamEndData
(
)
:
reached
(
false
)
{
}
}
;
using
ExclusiveStreamEndData
=
ExclusiveWaitableData
<
StreamEndData
>
;
SharedModule
CompileStreaming
(
const
CompileArgs
&
args
const
Bytes
&
envBytes
const
Bytes
&
codeBytes
const
ExclusiveBytesPtr
&
codeBytesEnd
const
ExclusiveStreamEndData
&
streamEnd
const
Atomic
<
bool
>
&
cancelled
UniqueChars
*
error
UniqueCharsVector
*
warnings
JSTelemetrySender
telemetrySender
=
JSTelemetrySender
(
)
)
;
}
}
#
endif
