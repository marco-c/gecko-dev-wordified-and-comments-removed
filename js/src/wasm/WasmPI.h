#
ifndef
wasm_pi_h
#
define
wasm_pi_h
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
PromiseObject
.
h
"
#
include
"
wasm
/
WasmAnyRef
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
namespace
js
{
class
WasmStructObject
;
namespace
wasm
{
class
Context
;
#
ifdef
ENABLE_WASM_JSPI
static
const
uint32_t
SuspenderObjectDataSlot
=
0
;
enum
SuspenderState
{
Initial
Moribund
Active
Suspended
CalledOnMain
}
;
class
SuspenderObjectData
{
void
*
stackMemory_
;
void
*
mainFP_
;
void
*
mainSP_
;
void
*
suspendableFP_
;
void
*
suspendableSP_
;
void
*
suspendableExitFP_
;
void
*
suspendedReturnAddress_
;
void
*
mainExitFP_
;
SuspenderState
state_
;
public
:
explicit
SuspenderObjectData
(
void
*
stackMemory
)
;
inline
SuspenderState
state
(
)
const
{
return
state_
;
}
void
setState
(
SuspenderState
state
)
{
state_
=
state
;
}
bool
isTraceable
(
)
const
{
return
state_
=
=
SuspenderState
:
:
Active
|
|
state_
=
=
SuspenderState
:
:
Suspended
|
|
state_
=
=
SuspenderState
:
:
CalledOnMain
;
}
bool
isMoribund
(
)
const
{
return
state_
=
=
SuspenderState
:
:
Moribund
;
}
bool
isActive
(
)
const
{
return
state_
=
=
SuspenderState
:
:
Active
;
}
bool
isSuspended
(
)
const
{
return
state_
=
=
SuspenderState
:
:
Suspended
;
}
bool
isCalledOnMain
(
)
const
{
return
state_
=
=
SuspenderState
:
:
CalledOnMain
;
}
bool
hasFramePointer
(
void
*
fp
)
const
{
MOZ_ASSERT
(
!
isMoribund
(
)
)
;
return
(
uintptr_t
)
stackMemory_
<
=
(
uintptr_t
)
fp
&
&
(
uintptr_t
)
fp
<
(
uintptr_t
)
stackMemory_
+
SuspendableStackPlusRedZoneSize
;
}
void
*
stackMemory
(
)
const
{
MOZ_ASSERT
(
!
isMoribund
(
)
)
;
return
stackMemory_
;
}
void
*
mainFP
(
)
const
{
MOZ_ASSERT
(
isActive
(
)
)
;
return
mainFP_
;
}
void
*
mainSP
(
)
const
{
MOZ_ASSERT
(
isActive
(
)
)
;
return
mainSP_
;
}
void
*
mainExitFP
(
)
const
{
MOZ_ASSERT
(
isSuspended
(
)
)
;
return
mainExitFP_
;
}
void
*
suspendableFP
(
)
const
{
MOZ_ASSERT
(
isSuspended
(
)
)
;
return
suspendableFP_
;
}
void
*
suspendableSP
(
)
const
{
MOZ_ASSERT
(
isSuspended
(
)
)
;
return
suspendableSP_
;
}
void
*
suspendedReturnAddress
(
)
const
{
MOZ_ASSERT
(
isSuspended
(
)
)
;
return
suspendedReturnAddress_
;
}
void
*
suspendableExitFP
(
)
const
{
MOZ_ASSERT
(
isTraceable
(
)
)
;
return
suspendableExitFP_
;
}
void
releaseStackMemory
(
)
;
#
if
defined
(
JS_SIMULATOR_ARM64
)
|
|
defined
(
JS_SIMULATOR_ARM
)
|
|
\
defined
(
JS_SIMULATOR_RISCV64
)
|
|
defined
(
JS_SIMULATOR_LOONG64
)
|
|
\
defined
(
JS_SIMULATOR_MIPS64
)
void
switchSimulatorToMain
(
)
;
void
switchSimulatorToSuspendable
(
)
;
#
endif
static
constexpr
size_t
offsetOfMainFP
(
)
{
return
offsetof
(
SuspenderObjectData
mainFP_
)
;
}
static
constexpr
size_t
offsetOfMainSP
(
)
{
return
offsetof
(
SuspenderObjectData
mainSP_
)
;
}
static
constexpr
size_t
offsetOfSuspendableFP
(
)
{
return
offsetof
(
SuspenderObjectData
suspendableFP_
)
;
}
static
constexpr
size_t
offsetOfSuspendableSP
(
)
{
return
offsetof
(
SuspenderObjectData
suspendableSP_
)
;
}
static
constexpr
size_t
offsetOfSuspendableExitFP
(
)
{
return
offsetof
(
SuspenderObjectData
suspendableExitFP_
)
;
}
static
constexpr
size_t
offsetOfMainExitFP
(
)
{
return
offsetof
(
SuspenderObjectData
mainExitFP_
)
;
}
static
constexpr
size_t
offsetOfSuspendedReturnAddress
(
)
{
return
offsetof
(
SuspenderObjectData
suspendedReturnAddress_
)
;
}
}
;
class
SuspenderObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
enum
{
DataSlot
PromisingPromiseSlot
SuspendingReturnTypeSlot
SlotCount
}
;
enum
class
ReturnType
:
int32_t
{
Unknown
Promise
Exception
}
;
static
SuspenderObject
*
create
(
JSContext
*
cx
)
;
PromiseObject
*
promisingPromise
(
)
const
{
return
&
getReservedSlot
(
PromisingPromiseSlot
)
.
toObject
(
)
.
as
<
PromiseObject
>
(
)
;
}
void
setPromisingPromise
(
Handle
<
PromiseObject
*
>
promise
)
{
setReservedSlot
(
PromisingPromiseSlot
ObjectOrNullValue
(
promise
)
)
;
}
ReturnType
suspendingReturnType
(
)
const
{
return
ReturnType
(
getReservedSlot
(
SuspendingReturnTypeSlot
)
.
toInt32
(
)
)
;
}
void
setSuspendingReturnType
(
ReturnType
type
)
{
MOZ_ASSERT
(
(
type
=
=
ReturnType
:
:
Unknown
)
!
=
(
suspendingReturnType
(
)
=
=
ReturnType
:
:
Unknown
)
)
;
setReservedSlot
(
SuspendingReturnTypeSlot
Int32Value
(
int32_t
(
type
)
)
)
;
}
JS
:
:
NativeStackLimit
stackMemoryBase
(
)
const
;
JS
:
:
NativeStackLimit
stackMemoryLimitForSystem
(
)
const
;
JS
:
:
NativeStackLimit
stackMemoryLimitForJit
(
)
const
;
SuspenderState
state
(
)
{
return
data
(
)
-
>
state
(
)
;
}
inline
bool
hasData
(
)
{
return
!
getReservedSlot
(
DataSlot
)
.
isUndefined
(
)
;
}
inline
SuspenderObjectData
*
data
(
)
{
return
static_cast
<
SuspenderObjectData
*
>
(
getReservedSlot
(
DataSlot
)
.
toPrivate
(
)
)
;
}
inline
const
SuspenderObjectData
*
data
(
)
const
{
return
static_cast
<
const
SuspenderObjectData
*
>
(
getReservedSlot
(
DataSlot
)
.
toPrivate
(
)
)
;
}
void
setMoribund
(
JSContext
*
cx
)
;
void
setActive
(
JSContext
*
cx
)
;
void
setSuspended
(
JSContext
*
cx
)
;
void
setCalledOnMain
(
JSContext
*
cx
)
;
void
enter
(
JSContext
*
cx
)
;
void
suspend
(
JSContext
*
cx
)
;
void
resume
(
JSContext
*
cx
)
;
void
leave
(
JSContext
*
cx
)
;
void
forwardToSuspendable
(
)
;
private
:
static
const
JSClassOps
classOps_
;
static
const
ClassExtension
classExt_
;
static
void
finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
size_t
moved
(
JSObject
*
obj
JSObject
*
old
)
;
}
;
using
CallOnMainStackFn
=
bool
(
*
)
(
void
*
data
)
;
bool
CallOnMainStack
(
JSContext
*
cx
CallOnMainStackFn
fn
void
*
data
)
;
JSFunction
*
WasmSuspendingFunctionCreate
(
JSContext
*
cx
HandleObject
func
wasm
:
:
ValTypeVector
&
&
params
wasm
:
:
ValTypeVector
&
&
results
)
;
JSFunction
*
WasmSuspendingFunctionCreate
(
JSContext
*
cx
HandleObject
func
const
FuncType
&
type
)
;
JSFunction
*
WasmPromisingFunctionCreate
(
JSContext
*
cx
HandleObject
func
wasm
:
:
ValTypeVector
&
&
params
wasm
:
:
ValTypeVector
&
&
results
)
;
SuspenderObject
*
CurrentSuspender
(
Instance
*
instance
int
reserved
)
;
SuspenderObject
*
CreateSuspender
(
Instance
*
instance
int
reserved
)
;
PromiseObject
*
CreatePromisingPromise
(
Instance
*
instance
SuspenderObject
*
suspender
)
;
JSObject
*
GetSuspendingPromiseResult
(
Instance
*
instance
void
*
result
SuspenderObject
*
suspender
)
;
void
*
AddPromiseReactions
(
Instance
*
instance
SuspenderObject
*
suspender
void
*
result
JSFunction
*
continueOnSuspendable
)
;
void
*
ForwardExceptionToSuspended
(
Instance
*
instance
SuspenderObject
*
suspender
void
*
exception
)
;
int32_t
SetPromisingPromiseResults
(
Instance
*
instance
SuspenderObject
*
suspender
WasmStructObject
*
results
)
;
void
UpdateSuspenderState
(
Instance
*
instance
SuspenderObject
*
suspender
UpdateSuspenderStateAction
action
)
;
void
TraceSuspendableStack
(
JSTracer
*
trc
const
SuspenderObjectData
&
data
)
;
#
endif
}
}
#
endif
