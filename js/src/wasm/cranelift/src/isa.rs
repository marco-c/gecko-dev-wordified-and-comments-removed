use
log
:
:
warn
;
use
std
:
:
env
;
use
cranelift_codegen
:
:
isa
;
use
cranelift_codegen
:
:
settings
:
:
{
self
Configurable
}
;
use
crate
:
:
bindings
:
:
StaticEnvironment
;
use
crate
:
:
utils
:
:
{
BasicError
DashResult
}
;
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
pub
const
POINTER_SIZE
:
usize
=
8
;
#
[
cfg
(
target_pointer_width
=
"
32
"
)
]
pub
const
POINTER_SIZE
:
usize
=
4
;
#
[
cfg
(
feature
=
"
cranelift_x86
"
)
]
pub
mod
platform
{
use
super
:
:
*
;
pub
const
IS_SUPPORTED
:
bool
=
true
;
pub
const
USES_HEAP_REG
:
bool
=
true
;
pub
(
crate
)
fn
make_isa_builder
(
env
:
&
StaticEnvironment
)
-
>
DashResult
<
isa
:
:
Builder
>
{
let
mut
ib
=
isa
:
:
lookup_by_name
(
"
x86_64
-
unknown
-
unknown
"
)
.
map_err
(
BasicError
:
:
from
)
?
;
if
!
env
.
has_sse2
{
return
Err
(
"
SSE2
is
mandatory
for
Baldrdash
!
"
.
into
(
)
)
;
}
if
env
.
has_sse3
{
ib
.
enable
(
"
has_sse3
"
)
.
map_err
(
BasicError
:
:
from
)
?
;
}
if
env
.
has_sse41
{
ib
.
enable
(
"
has_sse41
"
)
.
map_err
(
BasicError
:
:
from
)
?
;
}
if
env
.
has_sse42
{
ib
.
enable
(
"
has_sse42
"
)
.
map_err
(
BasicError
:
:
from
)
?
;
}
if
env
.
has_popcnt
{
ib
.
enable
(
"
has_popcnt
"
)
.
map_err
(
BasicError
:
:
from
)
?
;
}
if
env
.
has_avx
{
ib
.
enable
(
"
has_avx
"
)
.
map_err
(
BasicError
:
:
from
)
?
;
}
if
env
.
has_bmi1
{
ib
.
enable
(
"
has_bmi1
"
)
.
map_err
(
BasicError
:
:
from
)
?
;
}
if
env
.
has_bmi2
{
ib
.
enable
(
"
has_bmi2
"
)
.
map_err
(
BasicError
:
:
from
)
?
;
}
if
env
.
has_lzcnt
{
ib
.
enable
(
"
has_lzcnt
"
)
.
map_err
(
BasicError
:
:
from
)
?
;
}
Ok
(
ib
)
}
}
#
[
cfg
(
feature
=
"
cranelift_arm64
"
)
]
pub
mod
platform
{
use
super
:
:
*
;
pub
const
IS_SUPPORTED
:
bool
=
true
;
pub
const
USES_HEAP_REG
:
bool
=
true
;
pub
(
crate
)
fn
make_isa_builder
(
_env
:
&
StaticEnvironment
)
-
>
DashResult
<
isa
:
:
Builder
>
{
let
ib
=
isa
:
:
lookup_by_name
(
"
aarch64
-
unknown
-
unknown
"
)
.
map_err
(
BasicError
:
:
from
)
?
;
Ok
(
ib
)
}
}
#
[
cfg
(
not
(
any
(
feature
=
"
cranelift_x86
"
feature
=
"
cranelift_arm64
"
)
)
)
]
pub
mod
platform
{
use
super
:
:
*
;
pub
const
IS_SUPPORTED
:
bool
=
false
;
pub
const
USES_HEAP_REG
:
bool
=
false
;
pub
(
crate
)
fn
make_isa_builder
(
_env
:
&
StaticEnvironment
)
-
>
DashResult
<
isa
:
:
Builder
>
{
Err
(
"
Platform
not
supported
yet
!
"
.
into
(
)
)
}
}
impl
From
<
isa
:
:
LookupError
>
for
BasicError
{
fn
from
(
err
:
isa
:
:
LookupError
)
-
>
BasicError
{
BasicError
:
:
new
(
err
.
to_string
(
)
)
}
}
impl
From
<
settings
:
:
SetError
>
for
BasicError
{
fn
from
(
err
:
settings
:
:
SetError
)
-
>
BasicError
{
BasicError
:
:
new
(
err
.
to_string
(
)
)
}
}
struct
EnvVariableFlags
<
'
env
>
{
opt_level
:
Option
<
&
'
env
str
>
jump_tables
:
Option
<
bool
>
}
#
[
inline
]
fn
str_to_bool
(
value
:
&
str
)
-
>
bool
{
value
=
=
"
true
"
|
|
value
=
=
"
on
"
|
|
value
=
=
"
yes
"
|
|
value
=
=
"
1
"
}
impl
<
'
env
>
EnvVariableFlags
<
'
env
>
{
fn
parse
(
input
:
&
'
env
Result
<
String
env
:
:
VarError
>
)
-
>
Option
<
Self
>
{
let
input
=
match
input
{
Ok
(
input
)
=
>
input
.
as_str
(
)
Err
(
_
)
=
>
return
None
}
;
let
mut
flags
=
EnvVariableFlags
{
opt_level
:
None
jump_tables
:
None
}
;
for
entry
in
input
.
split
(
'
'
)
{
if
let
Some
(
equals_index
)
=
entry
.
find
(
'
=
'
)
{
let
(
key
value
)
=
entry
.
split_at
(
equals_index
)
;
let
value
=
&
value
[
1
.
.
]
;
match
key
{
"
opt_level
"
=
>
{
flags
.
opt_level
=
Some
(
value
)
;
}
"
jump_tables
"
=
>
{
flags
.
jump_tables
=
Some
(
str_to_bool
(
value
)
)
;
}
_
=
>
{
warn
!
(
"
Unknown
setting
with
key
{
}
"
key
)
;
}
}
}
else
{
warn
!
(
"
Missing
=
in
pair
:
{
}
"
entry
)
;
}
}
Some
(
flags
)
}
}
fn
make_shared_flags
(
env
:
&
StaticEnvironment
env_flags
:
&
Option
<
EnvVariableFlags
>
)
-
>
settings
:
:
SetResult
<
settings
:
:
Flags
>
{
let
mut
sb
=
settings
:
:
builder
(
)
;
sb
.
enable
(
"
avoid_div_traps
"
)
?
;
debug_assert_eq
!
(
env
.
size_of_wasm_frame
%
POINTER_SIZE
0
)
;
let
num_words
=
env
.
size_of_wasm_frame
/
POINTER_SIZE
;
sb
.
set
(
"
baldrdash_prologue_words
"
&
num_words
.
to_string
(
)
)
?
;
let
libcall_call_conv
=
if
env
.
platform_is_windows
{
"
baldrdash_windows
"
}
else
{
"
baldrdash_system_v
"
}
;
sb
.
set
(
"
libcall_call_conv
"
libcall_call_conv
)
?
;
sb
.
enable
(
"
emit_all_ones_funcaddrs
"
)
?
;
if
!
cfg
!
(
debug_assertions
)
{
sb
.
set
(
"
enable_verifier
"
"
false
"
)
?
;
}
sb
.
set
(
"
enable_probestack
"
"
false
"
)
?
;
let
opt_level
=
match
env_flags
{
Some
(
env_flags
)
=
>
env_flags
.
opt_level
None
=
>
None
}
.
unwrap_or
(
"
speed
"
)
;
sb
.
set
(
"
opt_level
"
opt_level
)
?
;
let
enable_jump_tables
=
match
env_flags
{
Some
(
env_flags
)
=
>
env_flags
.
jump_tables
None
=
>
None
}
.
unwrap_or
(
true
)
;
sb
.
set
(
"
enable_jump_tables
"
if
enable_jump_tables
{
"
true
"
}
else
{
"
false
"
}
)
?
;
if
platform
:
:
USES_HEAP_REG
{
sb
.
enable
(
"
enable_pinned_reg
"
)
?
;
sb
.
enable
(
"
use_pinned_reg_as_heap_base
"
)
?
;
}
if
env
.
ref_types_enabled
{
sb
.
enable
(
"
enable_safepoints
"
)
?
;
}
Ok
(
settings
:
:
Flags
:
:
new
(
sb
)
)
}
pub
fn
make_isa
(
env
:
&
StaticEnvironment
)
-
>
DashResult
<
Box
<
dyn
isa
:
:
TargetIsa
>
>
{
let
env_flags_str
=
std
:
:
env
:
:
var
(
"
CRANELIFT_FLAGS
"
)
;
let
env_flags
=
EnvVariableFlags
:
:
parse
(
&
env_flags_str
)
;
let
shared_flags
=
make_shared_flags
(
env
&
env_flags
)
.
map_err
(
BasicError
:
:
from
)
?
;
let
ib
=
platform
:
:
make_isa_builder
(
env
)
?
;
Ok
(
ib
.
finish
(
shared_flags
)
)
}
