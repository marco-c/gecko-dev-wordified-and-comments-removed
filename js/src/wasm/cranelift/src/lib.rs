mod
bindings
;
mod
compile
;
mod
isa
;
mod
utils
;
mod
wasm2clif
;
use
log
:
:
{
self
error
}
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
os
:
:
raw
:
:
c_char
;
use
std
:
:
ptr
;
use
std
:
:
fmt
:
:
Display
;
use
crate
:
:
bindings
:
:
{
CompiledFunc
FuncCompileInput
ModuleEnvironment
StaticEnvironment
}
;
use
crate
:
:
compile
:
:
BatchCompiler
;
use
cranelift_codegen
:
:
CodegenError
;
#
[
no_mangle
]
pub
extern
"
C
"
fn
cranelift_initialize
(
)
{
let
filter
=
log
:
:
max_level
(
)
;
match
env_logger
:
:
try_init
(
)
{
Ok
(
_
)
=
>
{
}
Err
(
_
)
=
>
{
log
:
:
set_max_level
(
filter
)
;
}
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
cranelift_compiler_create
<
'
a
'
b
>
(
static_env
:
*
const
StaticEnvironment
env
:
*
const
bindings
:
:
LowLevelModuleEnvironment
)
-
>
*
mut
BatchCompiler
<
'
a
'
b
>
{
let
env
=
env
.
as_ref
(
)
.
unwrap
(
)
;
let
static_env
=
static_env
.
as_ref
(
)
.
unwrap
(
)
;
match
BatchCompiler
:
:
new
(
static_env
ModuleEnvironment
:
:
new
(
env
)
)
{
Ok
(
compiler
)
=
>
Box
:
:
into_raw
(
Box
:
:
new
(
compiler
)
)
Err
(
err
)
=
>
{
error
!
(
"
When
constructing
the
batch
compiler
:
{
}
"
err
)
;
ptr
:
:
null_mut
(
)
}
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
cranelift_compiler_destroy
(
compiler
:
*
mut
BatchCompiler
)
{
assert
!
(
!
compiler
.
is_null
(
)
"
NULL
pointer
passed
to
cranelift_compiler_destroy
"
)
;
let
_box
=
Box
:
:
from_raw
(
compiler
)
;
}
fn
error_to_cstring
<
D
:
Display
>
(
err
:
D
)
-
>
*
mut
c_char
{
use
std
:
:
fmt
:
:
Write
;
let
mut
s
=
String
:
:
new
(
)
;
let
_
=
write
!
(
&
mut
s
"
{
}
"
err
)
;
let
cstr
=
CString
:
:
new
(
s
)
.
unwrap
(
)
;
cstr
.
into_raw
(
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
cranelift_compile_function
(
compiler
:
*
mut
BatchCompiler
data
:
*
const
FuncCompileInput
result
:
*
mut
CompiledFunc
error
:
*
mut
*
mut
c_char
)
-
>
bool
{
let
compiler
=
compiler
.
as_mut
(
)
.
unwrap
(
)
;
let
data
=
data
.
as_ref
(
)
.
unwrap
(
)
;
compiler
.
clear
(
)
;
if
let
Err
(
e
)
=
compiler
.
translate_wasm
(
data
)
{
let
cstr
=
error_to_cstring
(
e
)
;
*
error
=
cstr
;
return
false
;
}
;
if
let
Err
(
e
)
=
compiler
.
compile
(
data
.
stackmaps
(
)
)
{
match
e
{
CodegenError
:
:
Verifier
(
verifier_error
)
=
>
{
panic
!
(
"
Cranelift
verifier
error
:
{
}
"
verifier_error
)
;
}
CodegenError
:
:
ImplLimitExceeded
|
CodegenError
:
:
CodeTooLarge
|
CodegenError
:
:
Unsupported
(
_
)
=
>
{
let
cstr
=
error_to_cstring
(
e
)
;
*
error
=
cstr
;
return
false
;
}
}
}
;
let
result
=
result
.
as_mut
(
)
.
unwrap
(
)
;
result
.
reset
(
&
compiler
.
current_func
)
;
true
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
cranelift_compiler_free_error
(
s
:
*
mut
c_char
)
{
let
_cstr
=
CString
:
:
from_raw
(
s
)
;
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
cranelift_supports_platform
(
)
-
>
bool
{
isa
:
:
platform
:
:
IS_SUPPORTED
}
