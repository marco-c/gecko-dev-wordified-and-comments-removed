use
log
:
:
{
debug
info
}
;
use
std
:
:
fmt
;
use
std
:
:
mem
;
use
cranelift_codegen
:
:
binemit
:
:
{
Addend
CodeInfo
CodeOffset
NullStackmapSink
Reloc
RelocSink
Stackmap
TrapSink
}
;
use
cranelift_codegen
:
:
entity
:
:
EntityRef
;
use
cranelift_codegen
:
:
ir
:
:
{
self
constant
:
:
ConstantOffset
stackslot
:
:
StackSize
ExternalName
JumpTable
SourceLoc
TrapCode
}
;
use
cranelift_codegen
:
:
isa
:
:
TargetIsa
;
use
cranelift_codegen
:
:
CodegenResult
;
use
cranelift_codegen
:
:
Context
;
use
cranelift_wasm
:
:
{
FuncIndex
FuncTranslator
ModuleTranslationState
WasmResult
}
;
use
crate
:
:
bindings
;
use
crate
:
:
isa
:
:
{
make_isa
POINTER_SIZE
}
;
use
crate
:
:
utils
:
:
DashResult
;
use
crate
:
:
wasm2clif
:
:
{
init_sig
TransEnv
TRAP_THROW_REPORTED
}
;
const
USER_FUNCTION_NAMESPACE
:
u32
=
0
;
const
SYMBOLIC_FUNCTION_NAMESPACE
:
u32
=
1
;
pub
struct
CompiledFunc
{
pub
frame_pushed
:
StackSize
pub
contains_calls
:
bool
pub
metadata
:
Vec
<
bindings
:
:
MetadataEntry
>
pub
rodata_relocs
:
Vec
<
u32
>
pub
code_buffer
:
Vec
<
u8
>
pub
code_size
:
CodeOffset
pub
jumptables_size
:
CodeOffset
pub
rodata_size
:
CodeOffset
}
impl
CompiledFunc
{
fn
new
(
)
-
>
Self
{
Self
{
frame_pushed
:
0
contains_calls
:
false
metadata
:
vec
!
[
]
rodata_relocs
:
vec
!
[
]
code_buffer
:
vec
!
[
]
code_size
:
0
jumptables_size
:
0
rodata_size
:
0
}
}
fn
clear
(
&
mut
self
)
{
self
.
frame_pushed
=
0
;
self
.
contains_calls
=
false
;
self
.
metadata
.
clear
(
)
;
self
.
rodata_relocs
.
clear
(
)
;
self
.
code_buffer
.
clear
(
)
;
self
.
code_size
=
0
;
self
.
jumptables_size
=
0
;
self
.
rodata_size
=
0
;
}
}
pub
struct
BatchCompiler
<
'
static_env
'
module_env
>
{
static_environ
:
&
'
static_env
bindings
:
:
StaticEnvironment
environ
:
bindings
:
:
ModuleEnvironment
<
'
module_env
>
isa
:
Box
<
dyn
TargetIsa
>
func_translator
:
FuncTranslator
dummy_module_state
:
ModuleTranslationState
context
:
Context
trap_relocs
:
Traps
trans_env
:
TransEnv
<
'
static_env
'
module_env
>
pub
current_func
:
CompiledFunc
}
impl
<
'
static_env
'
module_env
>
BatchCompiler
<
'
static_env
'
module_env
>
{
pub
fn
new
(
static_environ
:
&
'
static_env
bindings
:
:
StaticEnvironment
environ
:
bindings
:
:
ModuleEnvironment
<
'
module_env
>
)
-
>
DashResult
<
Self
>
{
let
isa
=
make_isa
(
static_environ
)
?
;
let
trans_env
=
TransEnv
:
:
new
(
&
*
isa
environ
static_environ
)
;
Ok
(
BatchCompiler
{
static_environ
environ
isa
func_translator
:
FuncTranslator
:
:
new
(
)
dummy_module_state
:
ModuleTranslationState
:
:
new
(
)
context
:
Context
:
:
new
(
)
trap_relocs
:
Traps
:
:
new
(
)
trans_env
current_func
:
CompiledFunc
:
:
new
(
)
}
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
context
.
clear
(
)
;
self
.
trap_relocs
.
clear
(
)
;
self
.
trans_env
.
clear
(
)
;
self
.
current_func
.
clear
(
)
;
}
pub
fn
compile
(
&
mut
self
stackmaps
:
bindings
:
:
Stackmaps
)
-
>
CodegenResult
<
(
)
>
{
let
info
=
self
.
context
.
compile
(
&
*
self
.
isa
)
?
;
debug
!
(
"
Optimized
wasm
function
IR
:
{
}
"
self
)
;
self
.
binemit
(
info
stackmaps
)
}
pub
fn
translate_wasm
(
&
mut
self
func
:
&
bindings
:
:
FuncCompileInput
)
-
>
WasmResult
<
(
)
>
{
let
index
=
FuncIndex
:
:
new
(
func
.
index
as
usize
)
;
self
.
context
.
func
.
signature
=
init_sig
(
&
self
.
environ
self
.
static_environ
.
call_conv
(
)
index
)
?
;
self
.
context
.
func
.
name
=
wasm_function_name
(
index
)
;
self
.
func_translator
.
translate
(
&
self
.
dummy_module_state
func
.
bytecode
(
)
func
.
offset_in_module
as
usize
&
mut
self
.
context
.
func
&
mut
self
.
trans_env
)
?
;
info
!
(
"
Translated
wasm
function
{
}
.
"
func
.
index
)
;
debug
!
(
"
Translated
wasm
function
IR
:
{
}
"
self
)
;
Ok
(
(
)
)
}
fn
binemit
(
&
mut
self
info
:
CodeInfo
stackmaps
:
bindings
:
:
Stackmaps
)
-
>
CodegenResult
<
(
)
>
{
let
total_size
=
info
.
total_size
as
usize
;
let
frame_pushed
=
self
.
frame_pushed
(
)
;
let
contains_calls
=
self
.
contains_calls
(
)
;
info
!
(
"
Emitting
{
}
bytes
frame_pushed
=
{
}
\
n
.
"
total_size
frame_pushed
)
;
self
.
current_func
.
frame_pushed
=
frame_pushed
;
self
.
current_func
.
contains_calls
=
contains_calls
;
if
self
.
current_func
.
code_buffer
.
len
(
)
<
total_size
{
let
current_size
=
self
.
current_func
.
code_buffer
.
len
(
)
;
self
.
current_func
.
code_buffer
.
reserve
(
total_size
-
current_size
)
;
unsafe
{
self
.
current_func
.
code_buffer
.
set_len
(
total_size
)
}
;
}
{
let
mut
relocs
=
Relocations
:
:
new
(
&
mut
self
.
current_func
.
metadata
&
mut
self
.
current_func
.
rodata_relocs
)
;
let
code_buffer
=
&
mut
self
.
current_func
.
code_buffer
;
unsafe
{
self
.
context
.
emit_to_memory
(
&
*
self
.
isa
code_buffer
.
as_mut_ptr
(
)
&
mut
relocs
&
mut
self
.
trap_relocs
&
mut
NullStackmapSink
{
}
)
}
;
self
.
current_func
.
metadata
.
append
(
&
mut
self
.
trap_relocs
.
metadata
)
;
}
if
self
.
static_environ
.
ref_types_enabled
{
self
.
emit_stackmaps
(
stackmaps
)
;
}
self
.
current_func
.
code_size
=
info
.
code_size
;
self
.
current_func
.
jumptables_size
=
info
.
jumptables_size
;
self
.
current_func
.
rodata_size
=
info
.
rodata_size
;
Ok
(
(
)
)
}
fn
emit_stackmaps
(
&
self
mut
stackmaps
:
bindings
:
:
Stackmaps
)
{
let
encinfo
=
self
.
isa
.
encoding_info
(
)
;
let
func
=
&
self
.
context
.
func
;
let
stack_slots
=
&
func
.
stack_slots
;
for
block
in
func
.
layout
.
blocks
(
)
{
let
mut
pending_safepoint
=
None
;
for
(
offset
inst
inst_size
)
in
func
.
inst_offsets
(
block
&
encinfo
)
{
if
let
Some
(
stackmap
)
=
pending_safepoint
.
take
(
)
{
stackmaps
.
add_stackmap
(
stack_slots
offset
+
inst_size
stackmap
)
;
}
if
func
.
dfg
[
inst
]
.
opcode
(
)
=
=
ir
:
:
Opcode
:
:
Safepoint
{
let
args
=
func
.
dfg
.
inst_args
(
inst
)
;
let
stackmap
=
Stackmap
:
:
from_values
(
&
args
func
&
*
self
.
isa
)
;
pending_safepoint
=
Some
(
stackmap
)
;
}
}
debug_assert
!
(
pending_safepoint
.
is_none
(
)
)
;
}
}
fn
frame_pushed
(
&
self
)
-
>
StackSize
{
let
total
=
self
.
context
.
func
.
stack_slots
.
layout_info
.
expect
(
"
No
frame
"
)
.
frame_size
;
let
sm_pushed
=
StackSize
:
:
from
(
self
.
isa
.
flags
(
)
.
baldrdash_prologue_words
(
)
)
*
mem
:
:
size_of
:
:
<
usize
>
(
)
as
StackSize
;
total
.
checked_sub
(
sm_pushed
)
.
expect
(
"
SpiderMonkey
prologue
pushes
not
counted
"
)
}
fn
contains_calls
(
&
self
)
-
>
bool
{
!
self
.
context
.
func
.
dfg
.
signatures
.
is_empty
(
)
}
}
impl
<
'
static_env
'
module_env
>
fmt
:
:
Display
for
BatchCompiler
<
'
static_env
'
module_env
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
context
.
func
.
display
(
self
.
isa
.
as_ref
(
)
)
)
}
}
pub
fn
wasm_function_name
(
func
:
FuncIndex
)
-
>
ExternalName
{
ExternalName
:
:
User
{
namespace
:
USER_FUNCTION_NAMESPACE
index
:
func
.
index
(
)
as
u32
}
}
pub
fn
symbolic_function_name
(
sym
:
bindings
:
:
SymbolicAddress
)
-
>
ExternalName
{
ExternalName
:
:
User
{
namespace
:
SYMBOLIC_FUNCTION_NAMESPACE
index
:
sym
as
u32
}
}
struct
Relocations
<
'
a
>
{
metadata
:
&
'
a
mut
Vec
<
bindings
:
:
MetadataEntry
>
rodata_relocs
:
&
'
a
mut
Vec
<
CodeOffset
>
}
impl
<
'
a
>
Relocations
<
'
a
>
{
fn
new
(
metadata
:
&
'
a
mut
Vec
<
bindings
:
:
MetadataEntry
>
rodata_relocs
:
&
'
a
mut
Vec
<
CodeOffset
>
)
-
>
Self
{
Self
{
metadata
rodata_relocs
}
}
}
impl
<
'
a
>
RelocSink
for
Relocations
<
'
a
>
{
fn
reloc_block
(
&
mut
self
_at
:
CodeOffset
_reloc
:
Reloc
_block_offset
:
CodeOffset
)
{
unimplemented
!
(
"
block
relocations
NYI
"
)
;
}
fn
reloc_external
(
&
mut
self
at
:
CodeOffset
srcloc
:
SourceLoc
reloc
:
Reloc
name
:
&
ExternalName
_addend
:
Addend
)
{
debug_assert
!
(
!
srcloc
.
is_default
(
)
)
;
match
*
name
{
ExternalName
:
:
User
{
namespace
:
USER_FUNCTION_NAMESPACE
index
}
=
>
{
let
payload_size
=
match
reloc
{
Reloc
:
:
X86CallPCRel4
=
>
4
_
=
>
panic
!
(
"
unhandled
call
relocation
"
)
}
;
let
func_index
=
FuncIndex
:
:
new
(
index
as
usize
)
;
let
offset
=
at
+
payload_size
;
self
.
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
direct_call
(
offset
srcloc
func_index
)
)
;
}
ExternalName
:
:
User
{
namespace
:
SYMBOLIC_FUNCTION_NAMESPACE
index
}
=
>
{
let
payload_size
=
match
reloc
{
Reloc
:
:
Abs8
=
>
{
debug_assert_eq
!
(
POINTER_SIZE
8
)
;
8
}
_
=
>
panic
!
(
"
unhandled
user
-
space
symbolic
call
relocation
"
)
}
;
let
sym
=
index
.
into
(
)
;
let
offset
=
at
+
payload_size
;
self
.
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
symbolic_access
(
offset
srcloc
sym
)
)
;
}
ExternalName
:
:
LibCall
(
call
)
=
>
{
let
payload_size
=
match
reloc
{
Reloc
:
:
Abs8
=
>
{
debug_assert_eq
!
(
POINTER_SIZE
8
)
;
8
}
_
=
>
panic
!
(
"
unhandled
libcall
symbolic
call
relocation
"
)
}
;
let
sym
=
match
call
{
ir
:
:
LibCall
:
:
CeilF32
=
>
bindings
:
:
SymbolicAddress
:
:
CeilF32
ir
:
:
LibCall
:
:
CeilF64
=
>
bindings
:
:
SymbolicAddress
:
:
CeilF64
ir
:
:
LibCall
:
:
FloorF32
=
>
bindings
:
:
SymbolicAddress
:
:
FloorF32
ir
:
:
LibCall
:
:
FloorF64
=
>
bindings
:
:
SymbolicAddress
:
:
FloorF64
ir
:
:
LibCall
:
:
NearestF32
=
>
bindings
:
:
SymbolicAddress
:
:
NearestF32
ir
:
:
LibCall
:
:
NearestF64
=
>
bindings
:
:
SymbolicAddress
:
:
NearestF64
ir
:
:
LibCall
:
:
TruncF32
=
>
bindings
:
:
SymbolicAddress
:
:
TruncF32
ir
:
:
LibCall
:
:
TruncF64
=
>
bindings
:
:
SymbolicAddress
:
:
TruncF64
_
=
>
{
panic
!
(
"
Don
'
t
understand
external
{
}
"
name
)
;
}
}
;
let
offset
=
at
+
payload_size
;
self
.
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
symbolic_access
(
offset
srcloc
sym
)
)
;
}
_
=
>
{
panic
!
(
"
Don
'
t
understand
external
{
}
"
name
)
;
}
}
}
fn
reloc_constant
(
&
mut
self
_at
:
CodeOffset
_reloc
:
Reloc
_const_offset
:
ConstantOffset
)
{
unimplemented
!
(
"
constant
pool
relocations
NYI
"
)
;
}
fn
reloc_jt
(
&
mut
self
at
:
CodeOffset
reloc
:
Reloc
_jt
:
JumpTable
)
{
match
reloc
{
Reloc
:
:
X86PCRelRodata4
=
>
{
self
.
rodata_relocs
.
push
(
at
)
;
}
_
=
>
{
panic
!
(
"
Unhandled
/
unexpected
reloc
type
"
)
;
}
}
}
fn
add_call_site
(
&
mut
self
opcode
:
ir
:
:
Opcode
ret_addr
:
CodeOffset
srcloc
:
SourceLoc
)
{
if
opcode
=
=
ir
:
:
Opcode
:
:
CallIndirect
{
self
.
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
indirect_call
(
ret_addr
srcloc
)
)
;
}
}
}
struct
Traps
{
metadata
:
Vec
<
bindings
:
:
MetadataEntry
>
}
impl
Traps
{
fn
new
(
)
-
>
Self
{
Self
{
metadata
:
Vec
:
:
new
(
)
}
}
fn
clear
(
&
mut
self
)
{
self
.
metadata
.
clear
(
)
;
}
}
impl
TrapSink
for
Traps
{
fn
trap
(
&
mut
self
trap_offset
:
CodeOffset
loc
:
SourceLoc
trap
:
TrapCode
)
{
use
ir
:
:
TrapCode
:
:
*
;
let
bd_trap
=
match
trap
{
StackOverflow
=
>
{
return
;
}
HeapOutOfBounds
|
OutOfBounds
|
TableOutOfBounds
=
>
bindings
:
:
Trap
:
:
OutOfBounds
IndirectCallToNull
=
>
bindings
:
:
Trap
:
:
IndirectCallToNull
BadSignature
=
>
bindings
:
:
Trap
:
:
IndirectCallBadSig
IntegerOverflow
=
>
bindings
:
:
Trap
:
:
IntegerOverflow
IntegerDivisionByZero
=
>
bindings
:
:
Trap
:
:
IntegerDivideByZero
BadConversionToInteger
=
>
bindings
:
:
Trap
:
:
InvalidConversionToInteger
Interrupt
=
>
bindings
:
:
Trap
:
:
CheckInterrupt
UnreachableCodeReached
=
>
bindings
:
:
Trap
:
:
Unreachable
User
(
x
)
if
x
=
=
TRAP_THROW_REPORTED
=
>
bindings
:
:
Trap
:
:
ThrowReported
User
(
_
)
=
>
panic
!
(
"
Uncovered
trap
code
{
}
"
trap
)
}
;
debug_assert
!
(
!
loc
.
is_default
(
)
)
;
self
.
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
trap
(
trap_offset
loc
bd_trap
)
)
;
}
}
