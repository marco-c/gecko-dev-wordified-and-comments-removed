use
std
:
:
fmt
;
use
std
:
:
mem
;
use
cranelift_codegen
:
:
binemit
:
:
{
Addend
CodeInfo
CodeOffset
NullStackmapSink
NullTrapSink
Reloc
RelocSink
Stackmap
}
;
use
cranelift_codegen
:
:
entity
:
:
EntityRef
;
use
cranelift_codegen
:
:
ir
:
:
{
self
constant
:
:
ConstantOffset
stackslot
:
:
StackSize
}
;
use
cranelift_codegen
:
:
isa
:
:
TargetIsa
;
use
cranelift_codegen
:
:
CodegenResult
;
use
cranelift_codegen
:
:
Context
;
use
cranelift_wasm
:
:
{
FuncIndex
FuncTranslator
ModuleTranslationState
WasmResult
}
;
use
crate
:
:
bindings
;
use
crate
:
:
isa
:
:
make_isa
;
use
crate
:
:
utils
:
:
DashResult
;
use
crate
:
:
wasm2clif
:
:
{
init_sig
TransEnv
POINTER_SIZE
TRAP_THROW_REPORTED
}
;
const
USER_FUNCTION_NAMESPACE
:
u32
=
0
;
const
SYMBOLIC_FUNCTION_NAMESPACE
:
u32
=
1
;
pub
struct
CompiledFunc
{
pub
frame_pushed
:
StackSize
pub
contains_calls
:
bool
pub
metadata
:
Vec
<
bindings
:
:
MetadataEntry
>
pub
rodata_relocs
:
Vec
<
u32
>
pub
code_buffer
:
Vec
<
u8
>
pub
code_size
:
CodeOffset
pub
jumptables_size
:
CodeOffset
pub
rodata_size
:
CodeOffset
}
impl
CompiledFunc
{
fn
new
(
)
-
>
Self
{
Self
{
frame_pushed
:
0
contains_calls
:
false
metadata
:
vec
!
[
]
rodata_relocs
:
vec
!
[
]
code_buffer
:
vec
!
[
]
code_size
:
0
jumptables_size
:
0
rodata_size
:
0
}
}
fn
reset
(
self
:
&
mut
Self
frame_pushed
:
StackSize
contains_calls
:
bool
)
{
self
.
frame_pushed
=
frame_pushed
;
self
.
contains_calls
=
contains_calls
;
self
.
metadata
.
clear
(
)
;
self
.
rodata_relocs
.
clear
(
)
;
self
.
code_buffer
.
clear
(
)
;
self
.
code_size
=
0
;
self
.
jumptables_size
=
0
;
self
.
rodata_size
=
0
;
}
}
pub
struct
BatchCompiler
<
'
a
'
b
>
{
static_environ
:
&
'
a
bindings
:
:
StaticEnvironment
environ
:
bindings
:
:
ModuleEnvironment
<
'
b
>
isa
:
Box
<
dyn
TargetIsa
>
context
:
Context
dummy_module_state
:
ModuleTranslationState
trans
:
FuncTranslator
pub
current_func
:
CompiledFunc
}
impl
<
'
a
'
b
>
BatchCompiler
<
'
a
'
b
>
{
pub
fn
new
(
static_environ
:
&
'
a
bindings
:
:
StaticEnvironment
environ
:
bindings
:
:
ModuleEnvironment
<
'
b
>
)
-
>
DashResult
<
Self
>
{
Ok
(
BatchCompiler
{
static_environ
environ
isa
:
make_isa
(
static_environ
)
?
context
:
Context
:
:
new
(
)
dummy_module_state
:
ModuleTranslationState
:
:
new
(
)
trans
:
FuncTranslator
:
:
new
(
)
current_func
:
CompiledFunc
:
:
new
(
)
}
)
}
pub
fn
compile
(
&
mut
self
stackmaps
:
bindings
:
:
Stackmaps
)
-
>
CodegenResult
<
(
)
>
{
let
info
=
self
.
context
.
compile
(
&
*
self
.
isa
)
?
;
debug
!
(
"
Optimized
wasm
function
IR
:
{
}
"
self
)
;
self
.
binemit
(
info
stackmaps
)
}
pub
fn
translate_wasm
(
&
mut
self
func
:
&
bindings
:
:
FuncCompileInput
)
-
>
WasmResult
<
(
)
>
{
self
.
context
.
clear
(
)
;
let
tenv
=
&
mut
TransEnv
:
:
new
(
&
*
self
.
isa
&
self
.
environ
self
.
static_environ
)
;
let
index
=
FuncIndex
:
:
new
(
func
.
index
as
usize
)
;
self
.
context
.
func
.
signature
=
init_sig
(
&
self
.
environ
self
.
static_environ
.
call_conv
(
)
index
)
?
;
self
.
context
.
func
.
name
=
wasm_function_name
(
index
)
;
self
.
trans
.
translate
(
&
self
.
dummy_module_state
func
.
bytecode
(
)
func
.
offset_in_module
as
usize
&
mut
self
.
context
.
func
tenv
)
?
;
info
!
(
"
Translated
wasm
function
{
}
.
"
func
.
index
)
;
debug
!
(
"
Translated
wasm
function
IR
:
{
}
"
self
)
;
Ok
(
(
)
)
}
fn
binemit
(
&
mut
self
info
:
CodeInfo
stackmaps
:
bindings
:
:
Stackmaps
)
-
>
CodegenResult
<
(
)
>
{
let
total_size
=
info
.
total_size
as
usize
;
let
frame_pushed
=
self
.
frame_pushed
(
)
;
let
contains_calls
=
self
.
contains_calls
(
)
;
info
!
(
"
Emitting
{
}
bytes
frame_pushed
=
{
}
\
n
.
"
total_size
frame_pushed
)
;
self
.
current_func
.
reset
(
frame_pushed
contains_calls
)
;
let
mut
metadata
=
mem
:
:
replace
(
&
mut
self
.
current_func
.
metadata
vec
!
[
]
)
;
self
.
emit_metadata
(
&
mut
metadata
stackmaps
)
;
mem
:
:
swap
(
&
mut
metadata
&
mut
self
.
current_func
.
metadata
)
;
if
self
.
current_func
.
code_buffer
.
len
(
)
<
total_size
{
let
current_size
=
self
.
current_func
.
code_buffer
.
len
(
)
;
self
.
current_func
.
code_buffer
.
reserve
(
total_size
-
current_size
)
;
unsafe
{
self
.
current_func
.
code_buffer
.
set_len
(
total_size
)
}
;
}
{
let
emit_env
=
&
mut
EmitEnv
:
:
new
(
&
mut
self
.
current_func
.
metadata
&
mut
self
.
current_func
.
rodata_relocs
)
;
let
mut
trap_sink
=
NullTrapSink
{
}
;
unsafe
{
let
code_buffer
=
&
mut
self
.
current_func
.
code_buffer
;
self
.
context
.
emit_to_memory
(
&
*
self
.
isa
code_buffer
.
as_mut_ptr
(
)
emit_env
&
mut
trap_sink
&
mut
NullStackmapSink
{
}
)
}
;
}
self
.
current_func
.
code_size
=
info
.
code_size
;
self
.
current_func
.
jumptables_size
=
info
.
jumptables_size
;
self
.
current_func
.
rodata_size
=
info
.
rodata_size
;
Ok
(
(
)
)
}
fn
frame_pushed
(
&
self
)
-
>
StackSize
{
let
total
=
self
.
context
.
func
.
stack_slots
.
layout_info
.
expect
(
"
No
frame
"
)
.
frame_size
;
let
sm_pushed
=
StackSize
:
:
from
(
self
.
isa
.
flags
(
)
.
baldrdash_prologue_words
(
)
)
*
mem
:
:
size_of
:
:
<
usize
>
(
)
as
StackSize
;
total
.
checked_sub
(
sm_pushed
)
.
expect
(
"
SpiderMonkey
prologue
pushes
not
counted
"
)
}
fn
contains_calls
(
&
self
)
-
>
bool
{
!
self
.
context
.
func
.
dfg
.
signatures
.
is_empty
(
)
}
#
[
cfg
(
feature
=
"
cranelift_x86
"
)
]
fn
platform_specific_ignores_metadata
(
opcode
:
ir
:
:
Opcode
)
-
>
bool
{
match
opcode
{
ir
:
:
Opcode
:
:
X86Sdivmodx
|
ir
:
:
Opcode
:
:
X86Udivmodx
=
>
true
_
=
>
false
}
}
#
[
cfg
(
not
(
feature
=
"
cranelift_x86
"
)
)
]
fn
platform_specific_ignores_metadata
(
_opcode
:
ir
:
:
Opcode
)
-
>
bool
{
false
}
fn
emit_metadata
(
&
self
metadata
:
&
mut
Vec
<
bindings
:
:
MetadataEntry
>
mut
stackmaps
:
bindings
:
:
Stackmaps
)
{
let
encinfo
=
self
.
isa
.
encoding_info
(
)
;
let
func
=
&
self
.
context
.
func
;
let
stack_slots
=
&
func
.
stack_slots
;
for
block
in
func
.
layout
.
blocks
(
)
{
let
mut
pending_safepoint
=
None
;
for
(
offset
inst
inst_size
)
in
func
.
inst_offsets
(
block
&
encinfo
)
{
if
let
Some
(
stackmap
)
=
pending_safepoint
.
take
(
)
{
stackmaps
.
add_stackmap
(
stack_slots
offset
+
inst_size
stackmap
)
;
}
let
opcode
=
func
.
dfg
[
inst
]
.
opcode
(
)
;
match
opcode
{
ir
:
:
Opcode
:
:
Call
=
>
self
.
call_metadata
(
metadata
inst
offset
+
inst_size
)
ir
:
:
Opcode
:
:
CallIndirect
=
>
{
self
.
indirect_call_metadata
(
metadata
inst
offset
+
inst_size
)
}
ir
:
:
Opcode
:
:
Trap
|
ir
:
:
Opcode
:
:
Trapif
|
ir
:
:
Opcode
:
:
Trapff
=
>
{
self
.
trap_metadata
(
metadata
inst
offset
)
}
ir
:
:
Opcode
:
:
Safepoint
=
>
{
let
args
=
func
.
dfg
.
inst_args
(
inst
)
;
let
stackmap
=
Stackmap
:
:
from_values
(
&
args
func
&
*
self
.
isa
)
;
pending_safepoint
=
Some
(
stackmap
)
;
}
ir
:
:
Opcode
:
:
Load
|
ir
:
:
Opcode
:
:
LoadComplex
|
ir
:
:
Opcode
:
:
Uload8
|
ir
:
:
Opcode
:
:
Uload8Complex
|
ir
:
:
Opcode
:
:
Sload8
|
ir
:
:
Opcode
:
:
Sload8Complex
|
ir
:
:
Opcode
:
:
Uload16
|
ir
:
:
Opcode
:
:
Uload16Complex
|
ir
:
:
Opcode
:
:
Sload16
|
ir
:
:
Opcode
:
:
Sload16Complex
|
ir
:
:
Opcode
:
:
Uload32
|
ir
:
:
Opcode
:
:
Uload32Complex
|
ir
:
:
Opcode
:
:
Sload32
|
ir
:
:
Opcode
:
:
Sload32Complex
|
ir
:
:
Opcode
:
:
Store
|
ir
:
:
Opcode
:
:
StoreComplex
|
ir
:
:
Opcode
:
:
Istore8
|
ir
:
:
Opcode
:
:
Istore8Complex
|
ir
:
:
Opcode
:
:
Istore16
|
ir
:
:
Opcode
:
:
Istore16Complex
|
ir
:
:
Opcode
:
:
Istore32
|
ir
:
:
Opcode
:
:
Istore32Complex
=
>
self
.
memory_metadata
(
metadata
inst
offset
)
ir
:
:
Opcode
:
:
Spill
|
ir
:
:
Opcode
:
:
Fill
|
ir
:
:
Opcode
:
:
FillNop
|
ir
:
:
Opcode
:
:
JumpTableEntry
=
>
{
}
_
if
BatchCompiler
:
:
platform_specific_ignores_metadata
(
opcode
)
=
>
{
}
_
=
>
{
debug_assert
!
(
!
opcode
.
is_call
(
)
"
Missed
call
opcode
"
)
;
debug_assert
!
(
!
opcode
.
can_trap
(
)
"
Missed
trap
:
{
}
"
func
.
dfg
.
display_inst
(
inst
Some
(
self
.
isa
.
as_ref
(
)
)
)
)
;
debug_assert
!
(
!
opcode
.
can_load
(
)
"
Missed
load
:
{
}
"
func
.
dfg
.
display_inst
(
inst
Some
(
self
.
isa
.
as_ref
(
)
)
)
)
;
debug_assert
!
(
!
opcode
.
can_store
(
)
"
Missed
store
:
{
}
"
func
.
dfg
.
display_inst
(
inst
Some
(
self
.
isa
.
as_ref
(
)
)
)
)
;
}
}
}
assert
!
(
pending_safepoint
.
is_none
(
)
)
;
}
}
fn
srcloc
(
&
self
inst
:
ir
:
:
Inst
)
-
>
ir
:
:
SourceLoc
{
let
srcloc
=
self
.
context
.
func
.
srclocs
[
inst
]
;
debug_assert
!
(
!
srcloc
.
is_default
(
)
"
No
source
location
on
{
}
"
self
.
context
.
func
.
dfg
.
display_inst
(
inst
Some
(
self
.
isa
.
as_ref
(
)
)
)
)
;
srcloc
}
fn
call_metadata
(
&
self
metadata
:
&
mut
Vec
<
bindings
:
:
MetadataEntry
>
inst
:
ir
:
:
Inst
ret_addr
:
CodeOffset
)
{
let
func
=
&
self
.
context
.
func
;
let
callee
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Call
{
func_ref
.
.
}
=
>
&
func
.
dfg
.
ext_funcs
[
func_ref
]
.
name
_
=
>
panic
!
(
"
Bad
format
for
call
"
)
}
;
let
func_index
=
match
*
callee
{
ir
:
:
ExternalName
:
:
User
{
namespace
:
USER_FUNCTION_NAMESPACE
index
}
=
>
FuncIndex
:
:
new
(
index
as
usize
)
_
=
>
panic
!
(
"
Direct
call
to
{
}
unsupported
"
callee
)
}
;
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
direct_call
(
ret_addr
func_index
self
.
srcloc
(
inst
)
)
)
;
}
fn
indirect_call_metadata
(
&
self
metadata
:
&
mut
Vec
<
bindings
:
:
MetadataEntry
>
inst
:
ir
:
:
Inst
ret_addr
:
CodeOffset
)
{
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
indirect_call
(
ret_addr
self
.
srcloc
(
inst
)
)
)
;
}
fn
trap_metadata
(
&
self
metadata
:
&
mut
Vec
<
bindings
:
:
MetadataEntry
>
inst
:
ir
:
:
Inst
offset
:
CodeOffset
)
{
let
func
=
&
self
.
context
.
func
;
let
(
code
trap_offset
)
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Trap
{
code
.
.
}
=
>
(
code
0
)
ir
:
:
InstructionData
:
:
IntCondTrap
{
code
.
.
}
|
ir
:
:
InstructionData
:
:
FloatCondTrap
{
code
.
.
}
=
>
{
(
code
2
)
}
_
=
>
panic
!
(
"
Bad
format
for
trap
"
)
}
;
let
bd_trap
=
match
code
{
ir
:
:
TrapCode
:
:
StackOverflow
=
>
bindings
:
:
Trap
:
:
StackOverflow
ir
:
:
TrapCode
:
:
HeapOutOfBounds
=
>
bindings
:
:
Trap
:
:
OutOfBounds
ir
:
:
TrapCode
:
:
OutOfBounds
=
>
bindings
:
:
Trap
:
:
OutOfBounds
ir
:
:
TrapCode
:
:
TableOutOfBounds
=
>
bindings
:
:
Trap
:
:
OutOfBounds
ir
:
:
TrapCode
:
:
IndirectCallToNull
=
>
bindings
:
:
Trap
:
:
IndirectCallToNull
ir
:
:
TrapCode
:
:
BadSignature
=
>
bindings
:
:
Trap
:
:
IndirectCallBadSig
ir
:
:
TrapCode
:
:
IntegerOverflow
=
>
bindings
:
:
Trap
:
:
IntegerOverflow
ir
:
:
TrapCode
:
:
IntegerDivisionByZero
=
>
bindings
:
:
Trap
:
:
IntegerDivideByZero
ir
:
:
TrapCode
:
:
BadConversionToInteger
=
>
bindings
:
:
Trap
:
:
InvalidConversionToInteger
ir
:
:
TrapCode
:
:
Interrupt
=
>
bindings
:
:
Trap
:
:
CheckInterrupt
ir
:
:
TrapCode
:
:
UnreachableCodeReached
=
>
bindings
:
:
Trap
:
:
Unreachable
ir
:
:
TrapCode
:
:
User
(
x
)
if
x
=
=
TRAP_THROW_REPORTED
=
>
bindings
:
:
Trap
:
:
ThrowReported
ir
:
:
TrapCode
:
:
User
(
_
)
=
>
panic
!
(
"
Uncovered
trap
code
{
}
"
code
)
}
;
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
trap
(
offset
+
trap_offset
self
.
srcloc
(
inst
)
bd_trap
)
)
;
}
fn
memory_metadata
(
&
self
metadata
:
&
mut
Vec
<
bindings
:
:
MetadataEntry
>
inst
:
ir
:
:
Inst
offset
:
CodeOffset
)
{
let
func
=
&
self
.
context
.
func
;
let
memflags
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Load
{
flags
.
.
}
|
ir
:
:
InstructionData
:
:
LoadComplex
{
flags
.
.
}
|
ir
:
:
InstructionData
:
:
Store
{
flags
.
.
}
|
ir
:
:
InstructionData
:
:
StoreComplex
{
flags
.
.
}
=
>
flags
_
=
>
panic
!
(
"
Bad
format
for
memory
access
"
)
}
;
if
memflags
.
notrap
(
)
{
return
;
}
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
memory_access
(
offset
self
.
srcloc
(
inst
)
)
)
;
}
}
impl
<
'
a
'
b
>
fmt
:
:
Display
for
BatchCompiler
<
'
a
'
b
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
context
.
func
.
display
(
self
.
isa
.
as_ref
(
)
)
)
}
}
pub
fn
wasm_function_name
(
func
:
FuncIndex
)
-
>
ir
:
:
ExternalName
{
ir
:
:
ExternalName
:
:
User
{
namespace
:
USER_FUNCTION_NAMESPACE
index
:
func
.
index
(
)
as
u32
}
}
pub
fn
symbolic_function_name
(
sym
:
bindings
:
:
SymbolicAddress
)
-
>
ir
:
:
ExternalName
{
ir
:
:
ExternalName
:
:
User
{
namespace
:
SYMBOLIC_FUNCTION_NAMESPACE
index
:
sym
as
u32
}
}
struct
EmitEnv
<
'
a
>
{
metadata
:
&
'
a
mut
Vec
<
bindings
:
:
MetadataEntry
>
rodata_relocs
:
&
'
a
mut
Vec
<
CodeOffset
>
}
impl
<
'
a
>
EmitEnv
<
'
a
>
{
pub
fn
new
(
metadata
:
&
'
a
mut
Vec
<
bindings
:
:
MetadataEntry
>
rodata_relocs
:
&
'
a
mut
Vec
<
CodeOffset
>
)
-
>
EmitEnv
<
'
a
>
{
EmitEnv
{
metadata
rodata_relocs
}
}
}
impl
<
'
a
>
RelocSink
for
EmitEnv
<
'
a
>
{
fn
reloc_block
(
&
mut
self
_offset
:
CodeOffset
_reloc
:
Reloc
_block_offset
:
CodeOffset
)
{
unimplemented
!
(
)
;
}
fn
reloc_external
(
&
mut
self
offset
:
CodeOffset
_reloc
:
Reloc
name
:
&
ir
:
:
ExternalName
_addend
:
Addend
)
{
match
*
name
{
ir
:
:
ExternalName
:
:
User
{
namespace
:
USER_FUNCTION_NAMESPACE
.
.
}
=
>
{
}
ir
:
:
ExternalName
:
:
User
{
namespace
:
SYMBOLIC_FUNCTION_NAMESPACE
index
}
=
>
{
let
sym
=
index
.
into
(
)
;
let
offset
=
offset
+
POINTER_SIZE
as
u32
;
self
.
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
symbolic_access
(
offset
sym
)
)
;
}
ir
:
:
ExternalName
:
:
LibCall
(
call
)
=
>
{
let
sym
=
match
call
{
ir
:
:
LibCall
:
:
CeilF32
=
>
bindings
:
:
SymbolicAddress
:
:
CeilF32
ir
:
:
LibCall
:
:
CeilF64
=
>
bindings
:
:
SymbolicAddress
:
:
CeilF64
ir
:
:
LibCall
:
:
FloorF32
=
>
bindings
:
:
SymbolicAddress
:
:
FloorF32
ir
:
:
LibCall
:
:
FloorF64
=
>
bindings
:
:
SymbolicAddress
:
:
FloorF64
ir
:
:
LibCall
:
:
NearestF32
=
>
bindings
:
:
SymbolicAddress
:
:
NearestF32
ir
:
:
LibCall
:
:
NearestF64
=
>
bindings
:
:
SymbolicAddress
:
:
NearestF64
ir
:
:
LibCall
:
:
TruncF32
=
>
bindings
:
:
SymbolicAddress
:
:
TruncF32
ir
:
:
LibCall
:
:
TruncF64
=
>
bindings
:
:
SymbolicAddress
:
:
TruncF64
_
=
>
{
panic
!
(
"
Don
'
t
understand
external
{
}
"
name
)
;
}
}
;
let
offset
=
offset
+
POINTER_SIZE
as
u32
;
self
.
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
symbolic_access
(
offset
sym
)
)
;
}
_
=
>
{
panic
!
(
"
Don
'
t
understand
external
{
}
"
name
)
;
}
}
}
fn
reloc_jt
(
&
mut
self
offset
:
CodeOffset
reloc
:
Reloc
_jt
:
ir
:
:
JumpTable
)
{
match
reloc
{
Reloc
:
:
X86PCRelRodata4
=
>
{
self
.
rodata_relocs
.
push
(
offset
)
;
}
_
=
>
{
panic
!
(
"
Unhandled
/
unexpected
reloc
type
"
)
;
}
}
}
fn
reloc_constant
(
&
mut
self
_offset
:
CodeOffset
_reloc
:
Reloc
_constant_pool_offset
:
ConstantOffset
)
{
unimplemented
!
(
"
constant
pools
NYI
"
)
;
}
}
