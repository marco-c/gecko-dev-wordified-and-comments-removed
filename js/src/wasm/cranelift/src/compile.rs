use
baldrdash
as
bd
;
use
cpu
:
:
make_isa
;
use
cranelift_codegen
:
:
binemit
:
:
{
Addend
CodeOffset
NullTrapSink
Reloc
RelocSink
}
;
use
cranelift_codegen
:
:
entity
:
:
EntityRef
;
use
cranelift_codegen
:
:
ir
;
use
cranelift_codegen
:
:
ir
:
:
stackslot
:
:
StackSize
;
use
cranelift_codegen
:
:
isa
:
:
TargetIsa
;
use
cranelift_codegen
:
:
CodegenResult
;
use
cranelift_codegen
:
:
Context
;
use
cranelift_wasm
:
:
{
FuncIndex
FuncTranslator
WasmResult
}
;
use
std
:
:
fmt
;
use
std
:
:
mem
;
use
utils
:
:
DashResult
;
use
wasm2clif
:
:
{
init_sig
native_pointer_size
TransEnv
}
;
pub
struct
CompiledFunc
{
pub
frame_pushed
:
StackSize
pub
contains_calls
:
bool
pub
metadata
:
Vec
<
bd
:
:
MetadataEntry
>
pub
code_buffer
:
Vec
<
u8
>
}
impl
CompiledFunc
{
fn
new
(
)
-
>
Self
{
Self
{
frame_pushed
:
0
contains_calls
:
false
metadata
:
vec
!
[
]
code_buffer
:
vec
!
[
]
}
}
fn
reset
(
self
:
&
mut
Self
frame_pushed
:
StackSize
contains_calls
:
bool
)
{
self
.
frame_pushed
=
frame_pushed
;
self
.
contains_calls
=
contains_calls
;
self
.
metadata
.
clear
(
)
;
self
.
code_buffer
.
clear
(
)
;
}
}
pub
struct
BatchCompiler
<
'
a
'
b
>
{
static_environ
:
&
'
a
bd
:
:
StaticEnvironment
environ
:
bd
:
:
ModuleEnvironment
<
'
b
>
isa
:
Box
<
TargetIsa
>
context
:
Context
trans
:
FuncTranslator
pub
current_func
:
CompiledFunc
}
impl
<
'
a
'
b
>
BatchCompiler
<
'
a
'
b
>
{
pub
fn
new
(
static_environ
:
&
'
a
bd
:
:
StaticEnvironment
environ
:
bd
:
:
ModuleEnvironment
<
'
b
>
)
-
>
DashResult
<
Self
>
{
Ok
(
BatchCompiler
{
static_environ
environ
isa
:
make_isa
(
static_environ
)
?
context
:
Context
:
:
new
(
)
trans
:
FuncTranslator
:
:
new
(
)
current_func
:
CompiledFunc
:
:
new
(
)
}
)
}
pub
fn
compile
(
&
mut
self
)
-
>
CodegenResult
<
(
)
>
{
let
size
=
self
.
context
.
compile
(
&
*
self
.
isa
)
?
;
self
.
binemit
(
size
as
usize
)
}
pub
fn
translate_wasm
(
&
mut
self
func
:
&
bd
:
:
FuncCompileInput
)
-
>
WasmResult
<
bd
:
:
FuncTypeWithId
>
{
self
.
context
.
clear
(
)
;
let
index
=
FuncIndex
:
:
new
(
func
.
index
as
usize
)
;
let
wsig
=
init_sig
(
&
mut
self
.
context
.
func
.
signature
&
self
.
environ
index
)
;
self
.
context
.
func
.
name
=
wasm_function_name
(
index
)
;
let
tenv
=
&
mut
TransEnv
:
:
new
(
&
*
self
.
isa
&
self
.
environ
self
.
static_environ
)
;
self
.
trans
.
translate
(
func
.
bytecode
(
)
&
mut
self
.
context
.
func
tenv
)
?
;
info
!
(
"
Translated
wasm
function
{
}
.
"
func
.
index
)
;
debug
!
(
"
Content
:
{
}
"
self
.
context
.
func
.
display
(
&
*
self
.
isa
)
)
;
Ok
(
wsig
)
}
fn
binemit
(
&
mut
self
size
:
usize
)
-
>
CodegenResult
<
(
)
>
{
let
frame_pushed
=
self
.
frame_pushed
(
)
;
let
contains_calls
=
self
.
contains_calls
(
)
;
info
!
(
"
Emitting
{
}
bytes
frame_pushed
=
{
}
\
n
.
"
size
frame_pushed
)
;
self
.
current_func
.
reset
(
frame_pushed
contains_calls
)
;
let
mut
metadata
=
mem
:
:
replace
(
&
mut
self
.
current_func
.
metadata
vec
!
[
]
)
;
self
.
emit_metadata
(
&
mut
metadata
)
;
mem
:
:
swap
(
&
mut
metadata
&
mut
self
.
current_func
.
metadata
)
;
if
self
.
current_func
.
code_buffer
.
len
(
)
<
size
{
let
current_size
=
self
.
current_func
.
code_buffer
.
len
(
)
;
self
.
current_func
.
code_buffer
.
reserve
(
size
-
current_size
)
;
unsafe
{
self
.
current_func
.
code_buffer
.
set_len
(
size
)
}
;
}
{
let
eenv
=
&
mut
EmitEnv
:
:
new
(
&
mut
self
.
current_func
.
metadata
)
;
let
mut
trap_sink
=
NullTrapSink
{
}
;
unsafe
{
let
code_buffer
=
&
mut
self
.
current_func
.
code_buffer
;
self
.
context
.
emit_to_memory
(
&
*
self
.
isa
code_buffer
.
as_mut_ptr
(
)
eenv
&
mut
trap_sink
)
}
;
}
Ok
(
(
)
)
}
fn
frame_pushed
(
&
self
)
-
>
StackSize
{
let
total
=
self
.
context
.
func
.
stack_slots
.
frame_size
.
expect
(
"
No
frame
"
)
;
let
sm_pushed
=
StackSize
:
:
from
(
self
.
isa
.
flags
(
)
.
baldrdash_prologue_words
(
)
)
*
mem
:
:
size_of
:
:
<
usize
>
(
)
as
StackSize
;
total
.
checked_sub
(
sm_pushed
)
.
expect
(
"
SpiderMonkey
prologue
pushes
not
counted
"
)
}
fn
contains_calls
(
&
self
)
-
>
bool
{
!
self
.
context
.
func
.
dfg
.
signatures
.
is_empty
(
)
}
fn
emit_metadata
(
&
self
metadata
:
&
mut
Vec
<
bd
:
:
MetadataEntry
>
)
{
let
encinfo
=
self
.
isa
.
encoding_info
(
)
;
let
func
=
&
self
.
context
.
func
;
for
ebb
in
func
.
layout
.
ebbs
(
)
{
for
(
offset
inst
inst_size
)
in
func
.
inst_offsets
(
ebb
&
encinfo
)
{
let
opcode
=
func
.
dfg
[
inst
]
.
opcode
(
)
;
match
opcode
{
ir
:
:
Opcode
:
:
Call
=
>
self
.
call_metadata
(
metadata
inst
offset
+
inst_size
)
ir
:
:
Opcode
:
:
CallIndirect
=
>
{
self
.
indirect_call_metadata
(
metadata
inst
offset
+
inst_size
)
}
ir
:
:
Opcode
:
:
Trap
|
ir
:
:
Opcode
:
:
Trapif
|
ir
:
:
Opcode
:
:
Trapff
=
>
{
self
.
trap_metadata
(
metadata
inst
offset
)
}
ir
:
:
Opcode
:
:
Load
|
ir
:
:
Opcode
:
:
LoadComplex
|
ir
:
:
Opcode
:
:
Uload8
|
ir
:
:
Opcode
:
:
Uload8Complex
|
ir
:
:
Opcode
:
:
Sload8
|
ir
:
:
Opcode
:
:
Sload8Complex
|
ir
:
:
Opcode
:
:
Uload16
|
ir
:
:
Opcode
:
:
Uload16Complex
|
ir
:
:
Opcode
:
:
Sload16
|
ir
:
:
Opcode
:
:
Sload16Complex
|
ir
:
:
Opcode
:
:
Uload32
|
ir
:
:
Opcode
:
:
Uload32Complex
|
ir
:
:
Opcode
:
:
Sload32
|
ir
:
:
Opcode
:
:
Sload32Complex
|
ir
:
:
Opcode
:
:
Store
|
ir
:
:
Opcode
:
:
StoreComplex
|
ir
:
:
Opcode
:
:
Istore8
|
ir
:
:
Opcode
:
:
Istore8Complex
|
ir
:
:
Opcode
:
:
Istore16
|
ir
:
:
Opcode
:
:
Istore16Complex
|
ir
:
:
Opcode
:
:
Istore32
|
ir
:
:
Opcode
:
:
Istore32Complex
=
>
self
.
memory_metadata
(
metadata
inst
offset
)
ir
:
:
Opcode
:
:
Spill
|
ir
:
:
Opcode
:
:
Fill
|
ir
:
:
Opcode
:
:
X86Sdivmodx
|
ir
:
:
Opcode
:
:
X86Udivmodx
=
>
{
}
_
=
>
{
assert
!
(
!
opcode
.
is_call
(
)
"
Missed
call
opcode
"
)
;
assert
!
(
!
opcode
.
can_trap
(
)
"
Missed
trap
:
{
}
"
func
.
dfg
.
display_inst
(
inst
Some
(
self
.
isa
.
as_ref
(
)
)
)
)
;
assert
!
(
!
opcode
.
can_load
(
)
"
Missed
load
:
{
}
"
func
.
dfg
.
display_inst
(
inst
Some
(
self
.
isa
.
as_ref
(
)
)
)
)
;
assert
!
(
!
opcode
.
can_store
(
)
"
Missed
store
:
{
}
"
func
.
dfg
.
display_inst
(
inst
Some
(
self
.
isa
.
as_ref
(
)
)
)
)
;
}
}
}
}
}
fn
call_metadata
(
&
self
metadata
:
&
mut
Vec
<
bd
:
:
MetadataEntry
>
inst
:
ir
:
:
Inst
ret_addr
:
CodeOffset
)
{
let
func
=
&
self
.
context
.
func
;
let
callee
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Call
{
func_ref
.
.
}
=
>
&
func
.
dfg
.
ext_funcs
[
func_ref
]
.
name
_
=
>
panic
!
(
"
Bad
format
for
call
"
)
}
;
let
func_index
=
match
*
callee
{
ir
:
:
ExternalName
:
:
User
{
namespace
:
0
index
}
=
>
FuncIndex
:
:
new
(
index
as
usize
)
_
=
>
panic
!
(
"
Direct
call
to
{
}
unsupported
"
callee
)
}
;
let
srcloc
=
func
.
srclocs
[
inst
]
;
assert
!
(
!
srcloc
.
is_default
(
)
"
No
source
location
on
{
}
"
func
.
dfg
.
display_inst
(
inst
Some
(
self
.
isa
.
as_ref
(
)
)
)
)
;
metadata
.
push
(
bd
:
:
MetadataEntry
:
:
direct_call
(
ret_addr
func_index
srcloc
)
)
;
}
fn
indirect_call_metadata
(
&
self
metadata
:
&
mut
Vec
<
bd
:
:
MetadataEntry
>
inst
:
ir
:
:
Inst
ret_addr
:
CodeOffset
)
{
let
func
=
&
self
.
context
.
func
;
let
srcloc
=
func
.
srclocs
[
inst
]
;
assert
!
(
!
srcloc
.
is_default
(
)
"
No
source
location
on
{
}
"
func
.
dfg
.
display_inst
(
inst
Some
(
self
.
isa
.
as_ref
(
)
)
)
)
;
metadata
.
push
(
bd
:
:
MetadataEntry
:
:
indirect_call
(
ret_addr
srcloc
)
)
;
}
fn
trap_metadata
(
&
self
metadata
:
&
mut
Vec
<
bd
:
:
MetadataEntry
>
inst
:
ir
:
:
Inst
offset
:
CodeOffset
)
{
let
func
=
&
self
.
context
.
func
;
let
(
code
trap_offset
)
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Trap
{
code
.
.
}
=
>
(
code
0
)
ir
:
:
InstructionData
:
:
IntCondTrap
{
code
.
.
}
|
ir
:
:
InstructionData
:
:
FloatCondTrap
{
code
.
.
}
=
>
{
(
code
2
)
}
_
=
>
panic
!
(
"
Bad
format
for
trap
"
)
}
;
let
bd_trap
=
match
code
{
ir
:
:
TrapCode
:
:
StackOverflow
=
>
bd
:
:
Trap
:
:
StackOverflow
ir
:
:
TrapCode
:
:
HeapOutOfBounds
=
>
bd
:
:
Trap
:
:
OutOfBounds
ir
:
:
TrapCode
:
:
OutOfBounds
=
>
bd
:
:
Trap
:
:
OutOfBounds
ir
:
:
TrapCode
:
:
TableOutOfBounds
=
>
bd
:
:
Trap
:
:
OutOfBounds
ir
:
:
TrapCode
:
:
IndirectCallToNull
=
>
bd
:
:
Trap
:
:
IndirectCallToNull
ir
:
:
TrapCode
:
:
BadSignature
=
>
bd
:
:
Trap
:
:
IndirectCallBadSig
ir
:
:
TrapCode
:
:
IntegerOverflow
=
>
bd
:
:
Trap
:
:
IntegerOverflow
ir
:
:
TrapCode
:
:
IntegerDivisionByZero
=
>
bd
:
:
Trap
:
:
IntegerDivideByZero
ir
:
:
TrapCode
:
:
BadConversionToInteger
=
>
bd
:
:
Trap
:
:
InvalidConversionToInteger
ir
:
:
TrapCode
:
:
Interrupt
=
>
bd
:
:
Trap
:
:
CheckInterrupt
ir
:
:
TrapCode
:
:
UnreachableCodeReached
=
>
bd
:
:
Trap
:
:
Unreachable
ir
:
:
TrapCode
:
:
User
(
_
)
=
>
panic
!
(
"
Uncovered
trap
code
{
}
"
code
)
}
;
let
srcloc
=
func
.
srclocs
[
inst
]
;
assert
!
(
!
srcloc
.
is_default
(
)
"
No
source
location
on
{
}
"
func
.
dfg
.
display_inst
(
inst
Some
(
self
.
isa
.
as_ref
(
)
)
)
)
;
metadata
.
push
(
bd
:
:
MetadataEntry
:
:
trap
(
offset
+
trap_offset
srcloc
bd_trap
)
)
;
}
fn
memory_metadata
(
&
self
metadata
:
&
mut
Vec
<
bd
:
:
MetadataEntry
>
inst
:
ir
:
:
Inst
offset
:
CodeOffset
)
{
let
func
=
&
self
.
context
.
func
;
let
memflags
=
match
func
.
dfg
[
inst
]
{
ir
:
:
InstructionData
:
:
Load
{
flags
.
.
}
|
ir
:
:
InstructionData
:
:
LoadComplex
{
flags
.
.
}
|
ir
:
:
InstructionData
:
:
Store
{
flags
.
.
}
|
ir
:
:
InstructionData
:
:
StoreComplex
{
flags
.
.
}
=
>
flags
_
=
>
panic
!
(
"
Bad
format
for
memory
access
"
)
}
;
if
memflags
.
notrap
(
)
{
return
;
}
let
srcloc
=
func
.
srclocs
[
inst
]
;
assert
!
(
!
srcloc
.
is_default
(
)
"
No
source
location
on
{
}
"
func
.
dfg
.
display_inst
(
inst
Some
(
self
.
isa
.
as_ref
(
)
)
)
)
;
metadata
.
push
(
bd
:
:
MetadataEntry
:
:
memory_access
(
offset
srcloc
)
)
;
}
}
impl
<
'
a
'
b
>
fmt
:
:
Display
for
BatchCompiler
<
'
a
'
b
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
context
.
func
.
display
(
self
.
isa
.
as_ref
(
)
)
)
}
}
pub
fn
wasm_function_name
(
func
:
FuncIndex
)
-
>
ir
:
:
ExternalName
{
ir
:
:
ExternalName
:
:
User
{
namespace
:
0
index
:
func
.
index
(
)
as
u32
}
}
pub
fn
symbolic_function_name
(
sym
:
bd
:
:
SymbolicAddress
)
-
>
ir
:
:
ExternalName
{
ir
:
:
ExternalName
:
:
User
{
namespace
:
1
index
:
sym
as
u32
}
}
struct
EmitEnv
<
'
a
>
{
metadata
:
&
'
a
mut
Vec
<
bd
:
:
MetadataEntry
>
}
impl
<
'
a
>
EmitEnv
<
'
a
>
{
pub
fn
new
(
metadata
:
&
'
a
mut
Vec
<
bd
:
:
MetadataEntry
>
)
-
>
EmitEnv
<
'
a
>
{
EmitEnv
{
metadata
}
}
}
impl
<
'
a
>
RelocSink
for
EmitEnv
<
'
a
>
{
fn
reloc_ebb
(
&
mut
self
_offset
:
CodeOffset
_reloc
:
Reloc
_ebb_offset
:
CodeOffset
)
{
unimplemented
!
(
)
;
}
fn
reloc_external
(
&
mut
self
offset
:
CodeOffset
_reloc
:
Reloc
name
:
&
ir
:
:
ExternalName
_addend
:
Addend
)
{
match
*
name
{
ir
:
:
ExternalName
:
:
User
{
namespace
:
0
.
.
}
=
>
{
}
ir
:
:
ExternalName
:
:
User
{
namespace
:
1
index
}
=
>
{
let
sym
=
index
.
into
(
)
;
let
offset
=
offset
+
native_pointer_size
(
)
as
u32
;
self
.
metadata
.
push
(
bd
:
:
MetadataEntry
:
:
symbolic_access
(
offset
sym
)
)
;
}
ir
:
:
ExternalName
:
:
LibCall
(
call
)
=
>
{
let
sym
=
match
call
{
ir
:
:
LibCall
:
:
CeilF32
=
>
bd
:
:
SymbolicAddress
:
:
CeilF32
ir
:
:
LibCall
:
:
CeilF64
=
>
bd
:
:
SymbolicAddress
:
:
CeilF64
ir
:
:
LibCall
:
:
FloorF32
=
>
bd
:
:
SymbolicAddress
:
:
FloorF32
ir
:
:
LibCall
:
:
FloorF64
=
>
bd
:
:
SymbolicAddress
:
:
FloorF64
ir
:
:
LibCall
:
:
NearestF32
=
>
bd
:
:
SymbolicAddress
:
:
NearestF32
ir
:
:
LibCall
:
:
NearestF64
=
>
bd
:
:
SymbolicAddress
:
:
NearestF64
ir
:
:
LibCall
:
:
TruncF32
=
>
bd
:
:
SymbolicAddress
:
:
TruncF32
ir
:
:
LibCall
:
:
TruncF64
=
>
bd
:
:
SymbolicAddress
:
:
TruncF64
_
=
>
{
panic
!
(
"
Don
'
t
understand
external
{
}
"
name
)
;
}
}
;
let
offset
=
offset
+
native_pointer_size
(
)
as
u32
;
self
.
metadata
.
push
(
bd
:
:
MetadataEntry
:
:
symbolic_access
(
offset
sym
)
)
;
}
_
=
>
{
panic
!
(
"
Don
'
t
understand
external
{
}
"
name
)
;
}
}
}
fn
reloc_jt
(
&
mut
self
_offset
:
CodeOffset
_reloc
:
Reloc
_jt
:
ir
:
:
JumpTable
)
{
unimplemented
!
(
)
;
}
}
