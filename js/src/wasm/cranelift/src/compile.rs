use
log
:
:
{
debug
info
}
;
use
std
:
:
fmt
;
use
std
:
:
mem
;
use
cranelift_codegen
:
:
binemit
:
:
{
Addend
CodeInfo
CodeOffset
NullStackMapSink
Reloc
RelocSink
TrapSink
}
;
use
cranelift_codegen
:
:
entity
:
:
EntityRef
;
use
cranelift_codegen
:
:
ir
:
:
{
self
constant
:
:
ConstantOffset
stackslot
:
:
StackSize
ExternalName
JumpTable
SourceLoc
TrapCode
Type
}
;
use
cranelift_codegen
:
:
isa
:
:
TargetIsa
;
use
cranelift_codegen
:
:
machinst
:
:
MachStackMap
;
use
cranelift_codegen
:
:
CodegenResult
;
use
cranelift_codegen
:
:
Context
;
use
cranelift_wasm
:
:
{
FuncIndex
FuncTranslator
ModuleTranslationState
WasmResult
}
;
use
crate
:
:
bindings
;
use
crate
:
:
isa
:
:
make_isa
;
use
crate
:
:
utils
:
:
DashResult
;
use
crate
:
:
wasm2clif
:
:
{
init_sig
TransEnv
TRAP_THROW_REPORTED
}
;
const
USER_FUNCTION_NAMESPACE
:
u32
=
0
;
const
SYMBOLIC_FUNCTION_NAMESPACE
:
u32
=
1
;
pub
struct
CompiledFunc
{
pub
frame_pushed
:
StackSize
pub
contains_calls
:
bool
pub
metadata
:
Vec
<
bindings
:
:
MetadataEntry
>
pub
rodata_relocs
:
Vec
<
u32
>
pub
code_buffer
:
Vec
<
u8
>
pub
code_size
:
CodeOffset
pub
jumptables_size
:
CodeOffset
pub
rodata_size
:
CodeOffset
}
impl
CompiledFunc
{
fn
new
(
)
-
>
Self
{
Self
{
frame_pushed
:
0
contains_calls
:
false
metadata
:
vec
!
[
]
rodata_relocs
:
vec
!
[
]
code_buffer
:
vec
!
[
]
code_size
:
0
jumptables_size
:
0
rodata_size
:
0
}
}
fn
clear
(
&
mut
self
)
{
self
.
frame_pushed
=
0
;
self
.
contains_calls
=
false
;
self
.
metadata
.
clear
(
)
;
self
.
rodata_relocs
.
clear
(
)
;
self
.
code_buffer
.
clear
(
)
;
self
.
code_size
=
0
;
self
.
jumptables_size
=
0
;
self
.
rodata_size
=
0
;
}
}
pub
struct
BatchCompiler
<
'
static_env
'
module_env
>
{
static_environ
:
&
'
static_env
bindings
:
:
StaticEnvironment
environ
:
bindings
:
:
ModuleEnvironment
<
'
module_env
>
module_state
:
ModuleTranslationState
isa
:
Box
<
dyn
TargetIsa
>
func_translator
:
FuncTranslator
context
:
Context
trap_relocs
:
Traps
trans_env
:
TransEnv
<
'
static_env
'
module_env
>
pub
current_func
:
CompiledFunc
}
impl
<
'
static_env
'
module_env
>
BatchCompiler
<
'
static_env
'
module_env
>
{
pub
fn
new
(
static_environ
:
&
'
static_env
bindings
:
:
StaticEnvironment
environ
:
bindings
:
:
ModuleEnvironment
<
'
module_env
>
)
-
>
DashResult
<
Self
>
{
let
isa
=
make_isa
(
static_environ
)
?
;
let
trans_env
=
TransEnv
:
:
new
(
&
*
isa
environ
static_environ
)
;
Ok
(
BatchCompiler
{
static_environ
environ
isa
func_translator
:
FuncTranslator
:
:
new
(
)
module_state
:
create_module_translation_state
(
&
environ
)
?
context
:
Context
:
:
new
(
)
trap_relocs
:
Traps
:
:
new
(
)
trans_env
current_func
:
CompiledFunc
:
:
new
(
)
}
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
context
.
clear
(
)
;
self
.
trap_relocs
.
clear
(
)
;
self
.
trans_env
.
clear
(
)
;
self
.
current_func
.
clear
(
)
;
}
pub
fn
compile
(
&
mut
self
stackmaps
:
bindings
:
:
Stackmaps
)
-
>
CodegenResult
<
(
)
>
{
let
info
=
self
.
context
.
compile
(
&
*
self
.
isa
)
?
;
debug
!
(
"
Optimized
wasm
function
IR
:
{
}
"
self
)
;
self
.
binemit
(
info
stackmaps
)
}
pub
fn
translate_wasm
(
&
mut
self
func
:
&
bindings
:
:
FuncCompileInput
)
-
>
WasmResult
<
(
)
>
{
let
index
=
FuncIndex
:
:
new
(
func
.
index
as
usize
)
;
self
.
context
.
func
.
signature
=
init_sig
(
&
self
.
environ
self
.
static_environ
.
call_conv
(
)
index
)
?
;
self
.
context
.
func
.
name
=
wasm_function_name
(
index
)
;
self
.
func_translator
.
translate
(
&
self
.
module_state
func
.
bytecode
(
)
func
.
offset_in_module
as
usize
&
mut
self
.
context
.
func
&
mut
self
.
trans_env
)
?
;
info
!
(
"
Translated
wasm
function
{
}
.
"
func
.
index
)
;
debug
!
(
"
Translated
wasm
function
IR
:
{
}
"
self
)
;
Ok
(
(
)
)
}
fn
binemit
(
&
mut
self
info
:
CodeInfo
stackmaps
:
bindings
:
:
Stackmaps
)
-
>
CodegenResult
<
(
)
>
{
let
total_size
=
info
.
total_size
as
usize
;
let
frame_pushed
=
self
.
frame_pushed
(
)
;
let
contains_calls
=
self
.
contains_calls
(
)
;
info
!
(
"
Emitting
{
}
bytes
frame_pushed
=
{
}
.
"
total_size
frame_pushed
)
;
self
.
current_func
.
frame_pushed
=
frame_pushed
;
self
.
current_func
.
contains_calls
=
contains_calls
;
if
self
.
current_func
.
code_buffer
.
len
(
)
<
total_size
{
let
current_size
=
self
.
current_func
.
code_buffer
.
len
(
)
;
self
.
current_func
.
code_buffer
.
reserve
(
total_size
-
current_size
)
;
unsafe
{
self
.
current_func
.
code_buffer
.
set_len
(
total_size
)
}
;
}
{
let
mut
relocs
=
Relocations
:
:
new
(
&
mut
self
.
current_func
.
metadata
&
mut
self
.
current_func
.
rodata_relocs
)
;
let
code_buffer
=
&
mut
self
.
current_func
.
code_buffer
;
unsafe
{
self
.
context
.
emit_to_memory
(
&
*
self
.
isa
code_buffer
.
as_mut_ptr
(
)
&
mut
relocs
&
mut
self
.
trap_relocs
&
mut
NullStackMapSink
{
}
)
}
;
self
.
current_func
.
metadata
.
append
(
&
mut
self
.
trap_relocs
.
metadata
)
;
}
if
self
.
static_environ
.
ref_types_enabled
{
self
.
emit_stackmaps
(
stackmaps
)
;
}
self
.
current_func
.
code_size
=
info
.
code_size
;
self
.
current_func
.
jumptables_size
=
info
.
jumptables_size
;
self
.
current_func
.
rodata_size
=
info
.
rodata_size
;
Ok
(
(
)
)
}
fn
emit_stackmaps
(
&
self
mut
stackmaps
:
bindings
:
:
Stackmaps
)
{
let
mach_buf
=
&
self
.
context
.
mach_compile_result
.
as_ref
(
)
.
unwrap
(
)
.
buffer
;
let
mach_stackmaps
=
mach_buf
.
stack_maps
(
)
;
for
&
MachStackMap
{
offset_end
ref
stack_map
.
.
}
in
mach_stackmaps
{
debug
!
(
"
Stack
map
at
end
-
of
-
insn
offset
{
}
:
{
:
?
}
"
offset_end
stack_map
)
;
stackmaps
.
add_stackmap
(
0
offset_end
stack_map
)
;
}
}
fn
frame_pushed
(
&
self
)
-
>
StackSize
{
let
total
=
self
.
context
.
mach_compile_result
.
as_ref
(
)
.
expect
(
"
always
use
Mach
backend
"
)
.
frame_size
;
let
sm_pushed
=
StackSize
:
:
from
(
self
.
isa
.
flags
(
)
.
baldrdash_prologue_words
(
)
)
*
mem
:
:
size_of
:
:
<
usize
>
(
)
as
StackSize
;
total
.
checked_sub
(
sm_pushed
)
.
expect
(
"
SpiderMonkey
prologue
pushes
not
counted
"
)
}
fn
contains_calls
(
&
self
)
-
>
bool
{
!
self
.
context
.
func
.
dfg
.
signatures
.
is_empty
(
)
}
}
impl
<
'
static_env
'
module_env
>
fmt
:
:
Display
for
BatchCompiler
<
'
static_env
'
module_env
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
context
.
func
.
display
(
self
.
isa
.
as_ref
(
)
)
)
}
}
fn
create_module_translation_state
(
env
:
&
bindings
:
:
ModuleEnvironment
)
-
>
WasmResult
<
ModuleTranslationState
>
{
let
num_sig
=
env
.
num_types
(
)
;
let
mut
arg_vecs
=
vec
!
[
]
;
let
mut
result_vecs
=
vec
!
[
]
;
for
i
in
0
.
.
num_sig
{
let
sig
=
env
.
type_
(
i
)
;
arg_vecs
.
push
(
sig
.
args
(
)
?
)
;
result_vecs
.
push
(
sig
.
results
(
)
?
)
;
}
let
types
:
Vec
<
(
&
[
Type
]
&
[
Type
]
)
>
=
arg_vecs
.
iter
(
)
.
zip
(
result_vecs
.
iter
(
)
)
.
map
(
|
(
args
results
)
|
(
&
args
[
.
.
]
&
results
[
.
.
]
)
)
.
collect
(
)
;
ModuleTranslationState
:
:
from_func_sigs
(
&
types
[
.
.
]
)
}
pub
fn
wasm_function_name
(
func
:
FuncIndex
)
-
>
ExternalName
{
ExternalName
:
:
User
{
namespace
:
USER_FUNCTION_NAMESPACE
index
:
func
.
index
(
)
as
u32
}
}
pub
fn
symbolic_function_name
(
sym
:
bindings
:
:
SymbolicAddress
)
-
>
ExternalName
{
ExternalName
:
:
User
{
namespace
:
SYMBOLIC_FUNCTION_NAMESPACE
index
:
sym
as
u32
}
}
struct
Relocations
<
'
a
>
{
metadata
:
&
'
a
mut
Vec
<
bindings
:
:
MetadataEntry
>
rodata_relocs
:
&
'
a
mut
Vec
<
CodeOffset
>
}
impl
<
'
a
>
Relocations
<
'
a
>
{
fn
new
(
metadata
:
&
'
a
mut
Vec
<
bindings
:
:
MetadataEntry
>
rodata_relocs
:
&
'
a
mut
Vec
<
CodeOffset
>
)
-
>
Self
{
Self
{
metadata
rodata_relocs
}
}
}
impl
<
'
a
>
RelocSink
for
Relocations
<
'
a
>
{
fn
reloc_block
(
&
mut
self
_at
:
CodeOffset
_reloc
:
Reloc
_block_offset
:
CodeOffset
)
{
unimplemented
!
(
"
block
relocations
NYI
"
)
;
}
fn
reloc_external
(
&
mut
self
at
:
CodeOffset
srcloc
:
SourceLoc
reloc
:
Reloc
name
:
&
ExternalName
_addend
:
Addend
)
{
debug_assert
!
(
!
srcloc
.
is_default
(
)
)
;
match
*
name
{
ExternalName
:
:
User
{
namespace
:
USER_FUNCTION_NAMESPACE
index
}
=
>
{
let
func_index
=
FuncIndex
:
:
new
(
index
as
usize
)
;
#
[
cfg
(
feature
=
"
cranelift_x86
"
)
]
let
offset
=
at
+
match
reloc
{
Reloc
:
:
X86CallPCRel4
=
>
4
_
=
>
unreachable
!
(
)
}
;
#
[
cfg
(
feature
=
"
cranelift_arm64
"
)
]
let
offset
=
match
reloc
{
Reloc
:
:
Arm64Call
=
>
at
+
4
_
=
>
unreachable
!
(
)
}
;
#
[
cfg
(
not
(
any
(
feature
=
"
cranelift_x86
"
feature
=
"
cranelift_arm64
"
)
)
)
]
let
offset
=
{
let
_reloc
=
reloc
;
at
}
;
self
.
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
direct_call
(
offset
srcloc
func_index
)
)
;
}
ExternalName
:
:
User
{
namespace
:
SYMBOLIC_FUNCTION_NAMESPACE
index
}
=
>
{
let
sym
=
index
.
into
(
)
;
#
[
cfg
(
feature
=
"
cranelift_x86
"
)
]
let
offset
=
at
+
match
reloc
{
Reloc
:
:
Abs8
=
>
8
_
=
>
unreachable
!
(
)
}
;
#
[
cfg
(
feature
=
"
cranelift_arm64
"
)
]
let
offset
=
match
reloc
{
Reloc
:
:
Abs8
=
>
at
+
4
_
=
>
unreachable
!
(
)
}
;
#
[
cfg
(
not
(
any
(
feature
=
"
cranelift_x86
"
feature
=
"
cranelift_arm64
"
)
)
)
]
let
offset
=
at
;
self
.
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
symbolic_access
(
offset
srcloc
sym
)
)
;
}
ExternalName
:
:
LibCall
(
call
)
=
>
{
let
sym
=
match
call
{
ir
:
:
LibCall
:
:
CeilF32
=
>
bindings
:
:
SymbolicAddress
:
:
CeilF32
ir
:
:
LibCall
:
:
CeilF64
=
>
bindings
:
:
SymbolicAddress
:
:
CeilF64
ir
:
:
LibCall
:
:
FloorF32
=
>
bindings
:
:
SymbolicAddress
:
:
FloorF32
ir
:
:
LibCall
:
:
FloorF64
=
>
bindings
:
:
SymbolicAddress
:
:
FloorF64
ir
:
:
LibCall
:
:
NearestF32
=
>
bindings
:
:
SymbolicAddress
:
:
NearestF32
ir
:
:
LibCall
:
:
NearestF64
=
>
bindings
:
:
SymbolicAddress
:
:
NearestF64
ir
:
:
LibCall
:
:
TruncF32
=
>
bindings
:
:
SymbolicAddress
:
:
TruncF32
ir
:
:
LibCall
:
:
TruncF64
=
>
bindings
:
:
SymbolicAddress
:
:
TruncF64
_
=
>
{
panic
!
(
"
Don
'
t
understand
external
{
}
"
name
)
;
}
}
;
#
[
cfg
(
feature
=
"
cranelift_x86
"
)
]
let
offset
=
at
+
match
reloc
{
Reloc
:
:
Abs8
=
>
8
_
=
>
unreachable
!
(
)
}
;
#
[
cfg
(
feature
=
"
cranelift_arm64
"
)
]
let
offset
=
match
reloc
{
Reloc
:
:
Abs8
=
>
at
_
=
>
unreachable
!
(
)
}
;
#
[
cfg
(
not
(
any
(
feature
=
"
cranelift_x86
"
feature
=
"
cranelift_arm64
"
)
)
)
]
let
offset
=
at
;
self
.
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
symbolic_access
(
offset
srcloc
sym
)
)
;
}
_
=
>
{
panic
!
(
"
Don
'
t
understand
external
{
}
"
name
)
;
}
}
}
fn
reloc_constant
(
&
mut
self
_at
:
CodeOffset
_reloc
:
Reloc
_const_offset
:
ConstantOffset
)
{
unimplemented
!
(
"
constant
pool
relocations
NYI
"
)
;
}
fn
reloc_jt
(
&
mut
self
at
:
CodeOffset
reloc
:
Reloc
_jt
:
JumpTable
)
{
match
reloc
{
Reloc
:
:
X86PCRelRodata4
=
>
{
self
.
rodata_relocs
.
push
(
at
)
;
}
_
=
>
{
panic
!
(
"
Unhandled
/
unexpected
reloc
type
"
)
;
}
}
}
fn
add_call_site
(
&
mut
self
opcode
:
ir
:
:
Opcode
ret_addr
:
CodeOffset
srcloc
:
SourceLoc
)
{
if
opcode
=
=
ir
:
:
Opcode
:
:
CallIndirect
{
self
.
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
indirect_call
(
ret_addr
srcloc
)
)
;
}
}
}
struct
Traps
{
metadata
:
Vec
<
bindings
:
:
MetadataEntry
>
}
impl
Traps
{
fn
new
(
)
-
>
Self
{
Self
{
metadata
:
Vec
:
:
new
(
)
}
}
fn
clear
(
&
mut
self
)
{
self
.
metadata
.
clear
(
)
;
}
}
impl
TrapSink
for
Traps
{
fn
trap
(
&
mut
self
trap_offset
:
CodeOffset
loc
:
SourceLoc
trap
:
TrapCode
)
{
use
ir
:
:
TrapCode
:
:
*
;
let
bd_trap
=
match
trap
{
StackOverflow
=
>
{
return
;
}
HeapOutOfBounds
|
TableOutOfBounds
=
>
bindings
:
:
Trap
:
:
OutOfBounds
HeapMisaligned
=
>
bindings
:
:
Trap
:
:
UnalignedAccess
IndirectCallToNull
=
>
bindings
:
:
Trap
:
:
IndirectCallToNull
BadSignature
=
>
bindings
:
:
Trap
:
:
IndirectCallBadSig
IntegerOverflow
=
>
bindings
:
:
Trap
:
:
IntegerOverflow
IntegerDivisionByZero
=
>
bindings
:
:
Trap
:
:
IntegerDivideByZero
BadConversionToInteger
=
>
bindings
:
:
Trap
:
:
InvalidConversionToInteger
Interrupt
=
>
bindings
:
:
Trap
:
:
CheckInterrupt
UnreachableCodeReached
=
>
bindings
:
:
Trap
:
:
Unreachable
User
(
x
)
if
x
=
=
TRAP_THROW_REPORTED
=
>
bindings
:
:
Trap
:
:
ThrowReported
User
(
_
)
=
>
panic
!
(
"
Uncovered
trap
code
{
}
"
trap
)
}
;
debug_assert
!
(
!
loc
.
is_default
(
)
)
;
self
.
metadata
.
push
(
bindings
:
:
MetadataEntry
:
:
trap
(
trap_offset
loc
bd_trap
)
)
;
}
}
