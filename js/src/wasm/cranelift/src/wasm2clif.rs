use
std
:
:
collections
:
:
HashMap
;
use
cranelift_codegen
:
:
cursor
:
:
{
Cursor
FuncCursor
}
;
use
cranelift_codegen
:
:
entity
:
:
{
EntityRef
PrimaryMap
SecondaryMap
}
;
use
cranelift_codegen
:
:
ir
;
use
cranelift_codegen
:
:
ir
:
:
condcodes
:
:
IntCC
;
use
cranelift_codegen
:
:
ir
:
:
InstBuilder
;
use
cranelift_codegen
:
:
isa
:
:
{
CallConv
TargetFrontendConfig
TargetIsa
}
;
use
cranelift_codegen
:
:
packed_option
:
:
PackedOption
;
use
cranelift_wasm
:
:
{
FuncEnvironment
FuncIndex
GlobalIndex
GlobalVariable
MemoryIndex
ReturnMode
SignatureIndex
TableIndex
WasmError
WasmResult
}
;
use
crate
:
:
bindings
;
use
crate
:
:
compile
:
:
{
symbolic_function_name
wasm_function_name
}
;
fn
native_pointer_type
(
)
-
>
ir
:
:
Type
{
if
cfg
!
(
target_pointer_width
=
"
64
"
)
{
ir
:
:
types
:
:
I64
}
else
{
ir
:
:
types
:
:
I32
}
}
pub
fn
native_pointer_size
(
)
-
>
i32
{
if
cfg
!
(
target_pointer_width
=
"
64
"
)
{
8
}
else
{
4
}
}
fn
offset32
(
offset
:
usize
)
-
>
ir
:
:
immediates
:
:
Offset32
{
assert
!
(
offset
<
=
i32
:
:
max_value
(
)
as
usize
)
;
(
offset
as
i32
)
.
into
(
)
}
fn
imm64
(
offset
:
usize
)
-
>
ir
:
:
immediates
:
:
Imm64
{
(
offset
as
i64
)
.
into
(
)
}
fn
init_sig_from_wsig
(
call_conv
:
CallConv
wsig
:
bindings
:
:
FuncTypeWithId
)
-
>
WasmResult
<
ir
:
:
Signature
>
{
let
mut
sig
=
ir
:
:
Signature
:
:
new
(
call_conv
)
;
for
arg
in
wsig
.
args
(
)
?
{
sig
.
params
.
push
(
ir
:
:
AbiParam
:
:
new
(
arg
)
)
;
}
if
let
Some
(
ret_type
)
=
wsig
.
ret_type
(
)
?
{
let
ret
=
match
ret_type
{
ir
:
:
types
:
:
I32
=
>
ir
:
:
AbiParam
:
:
new
(
ret_type
)
.
uext
(
)
_
=
>
ir
:
:
AbiParam
:
:
new
(
ret_type
)
}
;
sig
.
returns
.
push
(
ret
)
;
}
sig
.
params
.
push
(
ir
:
:
AbiParam
:
:
special
(
native_pointer_type
(
)
ir
:
:
ArgumentPurpose
:
:
VMContext
)
)
;
Ok
(
sig
)
}
pub
fn
init_sig
(
env
:
&
bindings
:
:
ModuleEnvironment
call_conv
:
CallConv
func_index
:
FuncIndex
)
-
>
WasmResult
<
ir
:
:
Signature
>
{
let
wsig
=
env
.
function_signature
(
func_index
)
;
init_sig_from_wsig
(
call_conv
wsig
)
}
pub
struct
TransEnv
<
'
a
'
b
'
c
>
{
isa
:
&
'
a
dyn
TargetIsa
env
:
&
'
b
bindings
:
:
ModuleEnvironment
<
'
b
>
static_env
:
&
'
c
bindings
:
:
StaticEnvironment
tables
:
PrimaryMap
<
TableIndex
TableInfo
>
signatures
:
HashMap
<
i32
ir
:
:
GlobalValue
>
func_gvs
:
SecondaryMap
<
FuncIndex
PackedOption
<
ir
:
:
GlobalValue
>
>
vmctx_gv
:
PackedOption
<
ir
:
:
GlobalValue
>
instance_gv
:
PackedOption
<
ir
:
:
GlobalValue
>
interrupt_gv
:
PackedOption
<
ir
:
:
GlobalValue
>
symbolic
:
[
PackedOption
<
ir
:
:
FuncRef
>
;
2
]
cx_addr
:
PackedOption
<
ir
:
:
GlobalValue
>
realm_addr
:
PackedOption
<
ir
:
:
GlobalValue
>
}
impl
<
'
a
'
b
'
c
>
TransEnv
<
'
a
'
b
'
c
>
{
pub
fn
new
(
isa
:
&
'
a
dyn
TargetIsa
env
:
&
'
b
bindings
:
:
ModuleEnvironment
static_env
:
&
'
c
bindings
:
:
StaticEnvironment
)
-
>
Self
{
TransEnv
{
isa
env
static_env
tables
:
PrimaryMap
:
:
new
(
)
signatures
:
HashMap
:
:
new
(
)
func_gvs
:
SecondaryMap
:
:
new
(
)
vmctx_gv
:
None
.
into
(
)
instance_gv
:
None
.
into
(
)
interrupt_gv
:
None
.
into
(
)
symbolic
:
[
None
.
into
(
)
;
2
]
cx_addr
:
None
.
into
(
)
realm_addr
:
None
.
into
(
)
}
}
fn
get_vmctx_gv
(
&
mut
self
func
:
&
mut
ir
:
:
Function
)
-
>
ir
:
:
GlobalValue
{
match
self
.
vmctx_gv
.
expand
(
)
{
Some
(
gv
)
=
>
gv
None
=
>
{
let
gv
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
VMContext
)
;
self
.
vmctx_gv
=
Some
(
gv
)
.
into
(
)
;
gv
}
}
}
fn
get_table
(
&
mut
self
func
:
&
mut
ir
:
:
Function
table
:
TableIndex
)
-
>
TableInfo
{
let
vmctx
=
self
.
get_vmctx_gv
(
func
)
;
while
self
.
tables
.
len
(
)
<
=
table
.
index
(
)
{
let
wtab
=
self
.
env
.
table
(
TableIndex
:
:
new
(
self
.
tables
.
len
(
)
)
)
;
self
.
tables
.
push
(
TableInfo
:
:
new
(
wtab
func
vmctx
)
)
;
}
self
.
tables
[
table
]
.
clone
(
)
}
fn
sig_global
(
&
mut
self
func
:
&
mut
ir
:
:
Function
offset
:
usize
)
-
>
ir
:
:
GlobalValue
{
let
vmctx
=
self
.
get_vmctx_gv
(
func
)
;
*
self
.
signatures
.
entry
(
offset
as
i32
)
.
or_insert_with
(
|
|
{
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
IAddImm
{
base
:
vmctx
offset
:
imm64
(
offset
)
global_type
:
native_pointer_type
(
)
}
)
}
)
}
fn
func_import_global
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
FuncIndex
)
-
>
ir
:
:
GlobalValue
{
if
let
Some
(
gv
)
=
self
.
func_gvs
.
get
(
index
)
.
and_then
(
|
gv
|
gv
.
expand
(
)
)
{
return
gv
;
}
let
vmctx
=
self
.
get_vmctx_gv
(
func
)
;
let
gv
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
IAddImm
{
base
:
vmctx
offset
:
imm64
(
self
.
env
.
func_import_tls_offset
(
index
)
)
global_type
:
native_pointer_type
(
)
}
)
;
self
.
func_gvs
[
index
]
=
gv
.
into
(
)
;
gv
}
fn
load_instance
(
&
mut
self
pos
:
&
mut
FuncCursor
)
-
>
ir
:
:
Value
{
let
gv
=
match
self
.
instance_gv
.
expand
(
)
{
Some
(
gv
)
=
>
gv
None
=
>
{
let
vmctx
=
self
.
get_vmctx_gv
(
pos
.
func
)
;
let
gv
=
pos
.
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
IAddImm
{
base
:
vmctx
offset
:
imm64
(
self
.
static_env
.
instanceTlsOffset
)
global_type
:
native_pointer_type
(
)
}
)
;
self
.
instance_gv
=
gv
.
into
(
)
;
gv
}
}
;
let
ga
=
pos
.
ins
(
)
.
global_value
(
native_pointer_type
(
)
gv
)
;
pos
.
ins
(
)
.
load
(
native_pointer_type
(
)
ir
:
:
MemFlags
:
:
trusted
(
)
ga
0
)
}
fn
load_interrupt_flag
(
&
mut
self
pos
:
&
mut
FuncCursor
)
-
>
ir
:
:
Value
{
let
gv
=
match
self
.
interrupt_gv
.
expand
(
)
{
Some
(
gv
)
=
>
gv
None
=
>
{
let
vmctx
=
self
.
get_vmctx_gv
(
pos
.
func
)
;
let
gv
=
pos
.
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
IAddImm
{
base
:
vmctx
offset
:
imm64
(
self
.
static_env
.
interruptTlsOffset
)
global_type
:
native_pointer_type
(
)
}
)
;
self
.
interrupt_gv
=
gv
.
into
(
)
;
gv
}
}
;
let
ga
=
pos
.
ins
(
)
.
global_value
(
native_pointer_type
(
)
gv
)
;
pos
.
ins
(
)
.
load
(
ir
:
:
types
:
:
I32
ir
:
:
MemFlags
:
:
trusted
(
)
ga
0
)
}
fn
symbolic_funcref
<
MKSIG
:
FnOnce
(
)
-
>
ir
:
:
Signature
>
(
&
mut
self
func
:
&
mut
ir
:
:
Function
sym
:
bindings
:
:
SymbolicAddress
make_sig
:
MKSIG
)
-
>
(
ir
:
:
FuncRef
ir
:
:
SigRef
)
{
let
symidx
=
sym
as
usize
;
if
let
Some
(
fnref
)
=
self
.
symbolic
[
symidx
]
.
expand
(
)
{
return
(
fnref
func
.
dfg
.
ext_funcs
[
fnref
]
.
signature
)
;
}
let
signature
=
func
.
import_signature
(
make_sig
(
)
)
;
let
fnref
=
func
.
import_function
(
ir
:
:
ExtFuncData
{
signature
name
:
symbolic_function_name
(
sym
)
colocated
:
false
}
)
;
self
.
symbolic
[
symidx
]
=
fnref
.
into
(
)
;
(
fnref
signature
)
}
fn
switch_to_wasm_tls_realm
(
&
mut
self
pos
:
&
mut
FuncCursor
)
{
if
self
.
cx_addr
.
is_none
(
)
{
let
vmctx
=
self
.
get_vmctx_gv
(
&
mut
pos
.
func
)
;
self
.
cx_addr
=
pos
.
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
IAddImm
{
base
:
vmctx
offset
:
imm64
(
self
.
static_env
.
cxTlsOffset
)
global_type
:
native_pointer_type
(
)
}
)
.
into
(
)
;
}
if
self
.
realm_addr
.
is_none
(
)
{
let
vmctx
=
self
.
get_vmctx_gv
(
&
mut
pos
.
func
)
;
self
.
realm_addr
=
pos
.
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
IAddImm
{
base
:
vmctx
offset
:
imm64
(
self
.
static_env
.
realmTlsOffset
)
global_type
:
native_pointer_type
(
)
}
)
.
into
(
)
;
}
let
ptr
=
native_pointer_type
(
)
;
let
flags
=
ir
:
:
MemFlags
:
:
trusted
(
)
;
let
cx_addr_val
=
pos
.
ins
(
)
.
global_value
(
ptr
self
.
cx_addr
.
unwrap
(
)
)
;
let
cx
=
pos
.
ins
(
)
.
load
(
ptr
flags
cx_addr_val
0
)
;
let
realm_addr_val
=
pos
.
ins
(
)
.
global_value
(
ptr
self
.
realm_addr
.
unwrap
(
)
)
;
let
realm
=
pos
.
ins
(
)
.
load
(
ptr
flags
realm_addr_val
0
)
;
pos
.
ins
(
)
.
store
(
flags
realm
cx
offset32
(
self
.
static_env
.
realmCxOffset
)
)
;
}
fn
switch_to_indirect_callee_realm
(
&
mut
self
pos
:
&
mut
FuncCursor
vmctx
:
ir
:
:
Value
)
{
let
ptr
=
native_pointer_type
(
)
;
let
flags
=
ir
:
:
MemFlags
:
:
trusted
(
)
;
let
cx
=
pos
.
ins
(
)
.
load
(
ptr
flags
vmctx
offset32
(
self
.
static_env
.
cxTlsOffset
)
)
;
let
realm
=
pos
.
ins
(
)
.
load
(
ptr
flags
vmctx
offset32
(
self
.
static_env
.
realmTlsOffset
)
)
;
pos
.
ins
(
)
.
store
(
flags
realm
cx
offset32
(
self
.
static_env
.
realmCxOffset
)
)
;
}
fn
switch_to_import_realm
(
&
mut
self
pos
:
&
mut
FuncCursor
vmctx
:
ir
:
:
Value
gv_addr
:
ir
:
:
Value
)
{
let
ptr
=
native_pointer_type
(
)
;
let
flags
=
ir
:
:
MemFlags
:
:
trusted
(
)
;
let
cx
=
pos
.
ins
(
)
.
load
(
ptr
flags
vmctx
offset32
(
self
.
static_env
.
cxTlsOffset
)
)
;
let
realm
=
pos
.
ins
(
)
.
load
(
ptr
flags
gv_addr
offset32
(
self
.
static_env
.
realmFuncImportTlsOffset
)
)
;
pos
.
ins
(
)
.
store
(
flags
realm
cx
offset32
(
self
.
static_env
.
realmCxOffset
)
)
;
}
fn
load_pinned_reg
(
&
self
pos
:
&
mut
FuncCursor
vmctx
:
ir
:
:
Value
)
{
if
cfg
!
(
feature
=
"
cranelift_x86
"
)
&
&
cfg
!
(
target_pointer_width
=
"
64
"
)
{
let
heap_base
=
pos
.
ins
(
)
.
load
(
native_pointer_type
(
)
ir
:
:
MemFlags
:
:
trusted
(
)
vmctx
self
.
static_env
.
memoryBaseTlsOffset
as
i32
)
;
pos
.
ins
(
)
.
set_pinned_reg
(
heap_base
)
;
}
}
fn
reload_tls_and_pinned_regs
(
&
mut
self
pos
:
&
mut
FuncCursor
)
{
let
vmctx_gv
=
self
.
get_vmctx_gv
(
&
mut
pos
.
func
)
;
let
vmctx
=
pos
.
ins
(
)
.
global_value
(
native_pointer_type
(
)
vmctx_gv
)
;
self
.
load_pinned_reg
(
pos
vmctx
)
;
}
}
impl
<
'
a
'
b
'
c
>
FuncEnvironment
for
TransEnv
<
'
a
'
b
'
c
>
{
fn
target_config
(
&
self
)
-
>
TargetFrontendConfig
{
self
.
isa
.
frontend_config
(
)
}
fn
pointer_type
(
&
self
)
-
>
ir
:
:
Type
{
native_pointer_type
(
)
}
fn
make_global
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
GlobalIndex
)
-
>
WasmResult
<
GlobalVariable
>
{
let
global
=
self
.
env
.
global
(
index
)
;
if
global
.
is_constant
(
)
{
let
mut
pos
=
FuncCursor
:
:
new
(
func
)
;
pos
.
next_ebb
(
)
.
expect
(
"
empty
function
"
)
;
pos
.
next_inst
(
)
;
return
Ok
(
GlobalVariable
:
:
Const
(
global
.
emit_constant
(
&
mut
pos
)
?
)
)
;
}
let
vmctx_gv
=
self
.
get_vmctx_gv
(
func
)
;
let
offset
=
global
.
tls_offset
(
)
;
let
(
base_gv
offset
)
=
if
global
.
is_indirect
(
)
{
let
gv
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
Load
{
base
:
vmctx_gv
offset
:
offset32
(
offset
)
global_type
:
native_pointer_type
(
)
readonly
:
true
}
)
;
(
gv
0
.
into
(
)
)
}
else
{
(
vmctx_gv
offset32
(
offset
)
)
}
;
let
mem_ty
=
global
.
value_type
(
)
?
;
Ok
(
GlobalVariable
:
:
Memory
{
gv
:
base_gv
ty
:
mem_ty
offset
}
)
}
fn
make_heap
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
MemoryIndex
)
-
>
WasmResult
<
ir
:
:
Heap
>
{
if
index
.
index
(
)
!
=
0
{
return
Err
(
WasmError
:
:
Unsupported
(
"
only
one
wasm
memory
supported
"
.
to_string
(
)
)
)
;
}
let
vcmtx
=
self
.
get_vmctx_gv
(
func
)
;
let
bound
=
self
.
static_env
.
staticMemoryBound
as
u64
;
let
is_static
=
bound
>
0
;
let
base
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
Load
{
base
:
vcmtx
offset
:
offset32
(
0
)
global_type
:
native_pointer_type
(
)
readonly
:
is_static
}
)
;
let
style
=
if
is_static
{
let
bound
=
bound
.
into
(
)
;
ir
:
:
HeapStyle
:
:
Static
{
bound
}
}
else
{
let
bound_gv
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
Load
{
base
:
vcmtx
offset
:
native_pointer_size
(
)
.
into
(
)
global_type
:
ir
:
:
types
:
:
I32
readonly
:
false
}
)
;
ir
:
:
HeapStyle
:
:
Dynamic
{
bound_gv
}
}
;
let
min_size
=
(
self
.
env
.
min_memory_length
(
)
as
u64
)
.
into
(
)
;
let
offset_guard_size
=
(
self
.
static_env
.
memoryGuardSize
as
u64
)
.
into
(
)
;
Ok
(
func
.
create_heap
(
ir
:
:
HeapData
{
base
min_size
offset_guard_size
style
index_type
:
ir
:
:
types
:
:
I32
}
)
)
}
fn
make_indirect_sig
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
SignatureIndex
)
-
>
WasmResult
<
ir
:
:
SigRef
>
{
let
wsig
=
self
.
env
.
signature
(
index
)
;
let
mut
sigdata
=
init_sig_from_wsig
(
self
.
static_env
.
call_conv
(
)
wsig
)
?
;
if
wsig
.
id_kind
(
)
!
=
bindings
:
:
FuncTypeIdDescKind
:
:
None
{
sigdata
.
params
.
push
(
ir
:
:
AbiParam
:
:
special
(
native_pointer_type
(
)
ir
:
:
ArgumentPurpose
:
:
SignatureId
)
)
;
}
Ok
(
func
.
import_signature
(
sigdata
)
)
}
fn
make_table
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
TableIndex
)
-
>
WasmResult
<
ir
:
:
Table
>
{
let
table_desc
=
self
.
get_table
(
func
index
)
;
let
bound_gv
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
Load
{
base
:
table_desc
.
global
offset
:
0
.
into
(
)
global_type
:
ir
:
:
types
:
:
I32
readonly
:
false
}
)
;
let
base_gv
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
Load
{
base
:
table_desc
.
global
offset
:
offset32
(
native_pointer_size
(
)
as
usize
)
global_type
:
native_pointer_type
(
)
readonly
:
false
}
)
;
Ok
(
func
.
create_table
(
ir
:
:
TableData
{
base_gv
min_size
:
0
.
into
(
)
bound_gv
element_size
:
(
u64
:
:
from
(
self
.
pointer_bytes
(
)
)
*
2
)
.
into
(
)
index_type
:
ir
:
:
types
:
:
I32
}
)
)
}
fn
make_direct_func
(
&
mut
self
func
:
&
mut
ir
:
:
Function
index
:
FuncIndex
)
-
>
WasmResult
<
ir
:
:
FuncRef
>
{
let
sigdata
=
init_sig
(
&
self
.
env
self
.
static_env
.
call_conv
(
)
index
)
?
;
let
signature
=
func
.
import_signature
(
sigdata
)
;
Ok
(
func
.
import_function
(
ir
:
:
ExtFuncData
{
name
:
wasm_function_name
(
index
)
signature
colocated
:
true
}
)
)
}
fn
translate_call_indirect
(
&
mut
self
mut
pos
:
FuncCursor
table_index
:
TableIndex
table
:
ir
:
:
Table
sig_index
:
SignatureIndex
sig_ref
:
ir
:
:
SigRef
callee
:
ir
:
:
Value
call_args
:
&
[
ir
:
:
Value
]
)
-
>
WasmResult
<
ir
:
:
Inst
>
{
let
wsig
=
self
.
env
.
signature
(
sig_index
)
;
if
table_index
.
index
(
)
!
=
0
{
return
Err
(
WasmError
:
:
Unsupported
(
"
only
one
wasm
table
supported
"
.
to_string
(
)
)
)
;
}
let
wtable
=
self
.
get_table
(
pos
.
func
table_index
)
;
let
sigid_value
=
match
wsig
.
id_kind
(
)
{
bindings
:
:
FuncTypeIdDescKind
:
:
None
=
>
None
bindings
:
:
FuncTypeIdDescKind
:
:
Immediate
=
>
{
let
imm
=
wsig
.
id_immediate
(
)
as
i64
;
Some
(
pos
.
ins
(
)
.
iconst
(
native_pointer_type
(
)
imm
)
)
}
bindings
:
:
FuncTypeIdDescKind
:
:
Global
=
>
{
let
gv
=
self
.
sig_global
(
pos
.
func
wsig
.
id_tls_offset
(
)
)
;
let
addr
=
pos
.
ins
(
)
.
global_value
(
native_pointer_type
(
)
gv
)
;
Some
(
pos
.
ins
(
)
.
load
(
native_pointer_type
(
)
ir
:
:
MemFlags
:
:
trusted
(
)
addr
0
)
)
}
}
;
let
(
bound_gv
base_gv
)
=
{
let
table_data
=
&
pos
.
func
.
tables
[
table
]
;
(
table_data
.
bound_gv
table_data
.
base_gv
)
}
;
let
tlength
=
pos
.
ins
(
)
.
global_value
(
ir
:
:
types
:
:
I32
bound_gv
)
;
let
oob
=
pos
.
ins
(
)
.
icmp
(
IntCC
:
:
UnsignedGreaterThanOrEqual
callee
tlength
)
;
pos
.
ins
(
)
.
trapnz
(
oob
ir
:
:
TrapCode
:
:
OutOfBounds
)
;
let
tbase
=
pos
.
ins
(
)
.
global_value
(
native_pointer_type
(
)
base_gv
)
;
let
callee_x
=
if
native_pointer_type
(
)
!
=
ir
:
:
types
:
:
I32
{
pos
.
ins
(
)
.
uextend
(
native_pointer_type
(
)
callee
)
}
else
{
callee
}
;
let
callee_scaled
=
pos
.
ins
(
)
.
imul_imm
(
callee_x
wtable
.
entry_size
(
)
)
;
let
entry
=
pos
.
ins
(
)
.
iadd
(
tbase
callee_scaled
)
;
let
callee_func
=
pos
.
ins
(
)
.
load
(
native_pointer_type
(
)
ir
:
:
MemFlags
:
:
trusted
(
)
entry
0
)
;
pos
.
ins
(
)
.
trapz
(
callee_func
ir
:
:
TrapCode
:
:
IndirectCallToNull
)
;
let
callee_vmctx
=
pos
.
ins
(
)
.
load
(
native_pointer_type
(
)
ir
:
:
MemFlags
:
:
trusted
(
)
entry
native_pointer_size
(
)
)
;
self
.
switch_to_indirect_callee_realm
(
&
mut
pos
callee_vmctx
)
;
self
.
load_pinned_reg
(
&
mut
pos
callee_vmctx
)
;
let
mut
args
=
ir
:
:
ValueList
:
:
default
(
)
;
args
.
push
(
callee_func
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
args
.
extend
(
call_args
.
iter
(
)
.
cloned
(
)
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
args
.
push
(
callee_vmctx
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
if
let
Some
(
sigid
)
=
sigid_value
{
args
.
push
(
sigid
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
}
let
call
=
pos
.
ins
(
)
.
CallIndirect
(
ir
:
:
Opcode
:
:
CallIndirect
ir
:
:
types
:
:
INVALID
sig_ref
args
)
.
0
;
self
.
switch_to_wasm_tls_realm
(
&
mut
pos
)
;
self
.
reload_tls_and_pinned_regs
(
&
mut
pos
)
;
Ok
(
call
)
}
fn
translate_call
(
&
mut
self
mut
pos
:
FuncCursor
callee_index
:
FuncIndex
callee
:
ir
:
:
FuncRef
call_args
:
&
[
ir
:
:
Value
]
)
-
>
WasmResult
<
ir
:
:
Inst
>
{
let
mut
args
=
ir
:
:
ValueList
:
:
default
(
)
;
args
.
extend
(
call_args
.
iter
(
)
.
cloned
(
)
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
if
self
.
env
.
func_is_import
(
callee_index
)
{
let
gv
=
self
.
func_import_global
(
pos
.
func
callee_index
)
;
let
gv_addr
=
pos
.
ins
(
)
.
global_value
(
native_pointer_type
(
)
gv
)
;
let
fit_code
=
pos
.
ins
(
)
.
load
(
native_pointer_type
(
)
ir
:
:
MemFlags
:
:
trusted
(
)
gv_addr
0
)
;
let
fit_tls
=
pos
.
ins
(
)
.
load
(
native_pointer_type
(
)
ir
:
:
MemFlags
:
:
trusted
(
)
gv_addr
native_pointer_size
(
)
)
;
self
.
switch_to_import_realm
(
&
mut
pos
fit_tls
gv_addr
)
;
self
.
load_pinned_reg
(
&
mut
pos
fit_tls
)
;
args
.
push
(
fit_tls
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
args
.
insert
(
0
fit_code
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
let
sig
=
pos
.
func
.
dfg
.
ext_funcs
[
callee
]
.
signature
;
let
call
=
pos
.
ins
(
)
.
CallIndirect
(
ir
:
:
Opcode
:
:
CallIndirect
ir
:
:
types
:
:
INVALID
sig
args
)
.
0
;
self
.
switch_to_wasm_tls_realm
(
&
mut
pos
)
;
self
.
reload_tls_and_pinned_regs
(
&
mut
pos
)
;
Ok
(
call
)
}
else
{
let
vmctx
=
pos
.
func
.
special_param
(
ir
:
:
ArgumentPurpose
:
:
VMContext
)
.
expect
(
"
Missing
vmctx
arg
"
)
;
args
.
push
(
vmctx
&
mut
pos
.
func
.
dfg
.
value_lists
)
;
Ok
(
pos
.
ins
(
)
.
Call
(
ir
:
:
Opcode
:
:
Call
ir
:
:
types
:
:
INVALID
callee
args
)
.
0
)
}
}
fn
translate_memory_grow
(
&
mut
self
mut
pos
:
FuncCursor
_index
:
MemoryIndex
_heap
:
ir
:
:
Heap
val
:
ir
:
:
Value
)
-
>
WasmResult
<
ir
:
:
Value
>
{
let
call_conv
=
self
.
static_env
.
call_conv
(
)
;
let
(
fnref
sigref
)
=
self
.
symbolic_funcref
(
pos
.
func
bindings
:
:
SymbolicAddress
:
:
MemoryGrow
|
|
{
let
mut
sig
=
ir
:
:
Signature
:
:
new
(
call_conv
)
;
sig
.
params
.
push
(
ir
:
:
AbiParam
:
:
new
(
native_pointer_type
(
)
)
)
;
sig
.
params
.
push
(
ir
:
:
AbiParam
:
:
new
(
ir
:
:
types
:
:
I32
)
.
uext
(
)
)
;
sig
.
params
.
push
(
ir
:
:
AbiParam
:
:
special
(
native_pointer_type
(
)
ir
:
:
ArgumentPurpose
:
:
VMContext
)
)
;
sig
.
returns
.
push
(
ir
:
:
AbiParam
:
:
new
(
ir
:
:
types
:
:
I32
)
.
uext
(
)
)
;
sig
}
)
;
let
instance
=
self
.
load_instance
(
&
mut
pos
)
;
let
vmctx
=
pos
.
func
.
special_param
(
ir
:
:
ArgumentPurpose
:
:
VMContext
)
.
expect
(
"
Missing
vmctx
arg
"
)
;
let
addr
=
pos
.
ins
(
)
.
func_addr
(
native_pointer_type
(
)
fnref
)
;
let
call
=
pos
.
ins
(
)
.
call_indirect
(
sigref
addr
&
[
instance
val
vmctx
]
)
;
self
.
switch_to_wasm_tls_realm
(
&
mut
pos
)
;
self
.
reload_tls_and_pinned_regs
(
&
mut
pos
)
;
Ok
(
pos
.
func
.
dfg
.
first_result
(
call
)
)
}
fn
translate_memory_size
(
&
mut
self
mut
pos
:
FuncCursor
_index
:
MemoryIndex
_heap
:
ir
:
:
Heap
)
-
>
WasmResult
<
ir
:
:
Value
>
{
let
call_conv
=
self
.
static_env
.
call_conv
(
)
;
let
(
fnref
sigref
)
=
self
.
symbolic_funcref
(
pos
.
func
bindings
:
:
SymbolicAddress
:
:
MemorySize
|
|
{
let
mut
sig
=
ir
:
:
Signature
:
:
new
(
call_conv
)
;
sig
.
params
.
push
(
ir
:
:
AbiParam
:
:
new
(
native_pointer_type
(
)
)
)
;
sig
.
params
.
push
(
ir
:
:
AbiParam
:
:
special
(
native_pointer_type
(
)
ir
:
:
ArgumentPurpose
:
:
VMContext
)
)
;
sig
.
returns
.
push
(
ir
:
:
AbiParam
:
:
new
(
ir
:
:
types
:
:
I32
)
.
uext
(
)
)
;
sig
}
)
;
let
instance
=
self
.
load_instance
(
&
mut
pos
)
;
let
vmctx
=
pos
.
func
.
special_param
(
ir
:
:
ArgumentPurpose
:
:
VMContext
)
.
expect
(
"
Missing
vmctx
arg
"
)
;
let
addr
=
pos
.
ins
(
)
.
func_addr
(
native_pointer_type
(
)
fnref
)
;
let
call
=
pos
.
ins
(
)
.
call_indirect
(
sigref
addr
&
[
instance
vmctx
]
)
;
self
.
switch_to_wasm_tls_realm
(
&
mut
pos
)
;
self
.
reload_tls_and_pinned_regs
(
&
mut
pos
)
;
Ok
(
pos
.
func
.
dfg
.
first_result
(
call
)
)
}
fn
translate_loop_header
(
&
mut
self
mut
pos
:
FuncCursor
)
-
>
WasmResult
<
(
)
>
{
let
interrupt
=
self
.
load_interrupt_flag
(
&
mut
pos
)
;
pos
.
ins
(
)
.
trapnz
(
interrupt
ir
:
:
TrapCode
:
:
Interrupt
)
;
Ok
(
(
)
)
}
fn
return_mode
(
&
self
)
-
>
ReturnMode
{
ReturnMode
:
:
FallthroughReturn
}
}
#
[
derive
(
Clone
)
]
struct
TableInfo
{
pub
global
:
ir
:
:
GlobalValue
}
impl
TableInfo
{
pub
fn
new
(
wtab
:
bindings
:
:
TableDesc
func
:
&
mut
ir
:
:
Function
vmctx
:
ir
:
:
GlobalValue
)
-
>
TableInfo
{
let
offset
=
wtab
.
tls_offset
(
)
;
assert
!
(
offset
<
i32
:
:
max_value
(
)
as
usize
)
;
let
offset
=
imm64
(
offset
)
;
let
global
=
func
.
create_global_value
(
ir
:
:
GlobalValueData
:
:
IAddImm
{
base
:
vmctx
offset
global_type
:
native_pointer_type
(
)
}
)
;
TableInfo
{
global
}
}
pub
fn
entry_size
(
&
self
)
-
>
i64
{
i64
:
:
from
(
native_pointer_size
(
)
)
*
2
}
}
