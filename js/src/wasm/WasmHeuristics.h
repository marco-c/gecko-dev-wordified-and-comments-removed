#
ifndef
wasm_WasmHeuristics_h
#
define
wasm_WasmHeuristics_h
#
include
<
math
.
h
>
#
include
"
js
/
Prefs
.
h
"
#
include
"
threading
/
ExclusiveData
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
namespace
js
{
namespace
wasm
{
class
LazyTieringHeuristics
{
uint32_t
level_
=
0
;
static
constexpr
uint32_t
MIN_LEVEL
=
1
;
static
constexpr
uint32_t
MAX_LEVEL
=
9
;
static
constexpr
float
scale_
[
7
]
=
{
27
.
0
9
.
0
3
.
0
1
.
0
0
.
333
0
.
111
0
.
037
}
;
public
:
LazyTieringHeuristics
(
)
{
level_
=
JS
:
:
Prefs
:
:
wasm_lazy_tiering_level
(
)
;
level_
=
std
:
:
max
<
uint32_t
>
(
level_
MIN_LEVEL
)
;
level_
=
std
:
:
min
<
uint32_t
>
(
level_
MAX_LEVEL
)
;
}
uint32_t
level
(
)
const
{
return
level_
;
}
int32_t
estimateIonCompilationCost
(
uint32_t
bodyLength
)
const
{
if
(
MOZ_LIKELY
(
MIN_LEVEL
<
level_
&
&
level_
<
MAX_LEVEL
)
)
{
float
thresholdF
=
30000
.
0
+
4000
.
0
*
float
(
bodyLength
)
;
thresholdF
*
=
0
.
25
;
thresholdF
*
=
scale_
[
level_
-
(
MIN_LEVEL
+
1
)
]
;
thresholdF
=
std
:
:
max
<
float
>
(
thresholdF
10
.
0
)
;
thresholdF
=
std
:
:
min
<
float
>
(
thresholdF
2
.
0e9
)
;
int32_t
thresholdI
=
int32_t
(
thresholdF
)
;
MOZ_RELEASE_ASSERT
(
thresholdI
>
=
0
)
;
return
thresholdI
;
}
if
(
level_
=
=
MIN_LEVEL
)
{
return
INT32_MAX
;
}
if
(
level_
=
=
MAX_LEVEL
)
{
return
0
;
}
MOZ_CRASH
(
)
;
}
}
;
class
InliningHeuristics
{
uint32_t
level_
=
0
;
static
constexpr
uint32_t
MIN_LEVEL
=
1
;
static
constexpr
uint32_t
MAX_LEVEL
=
9
;
bool
directAllowed_
=
true
;
bool
callRefAllowed_
=
true
;
public
:
InliningHeuristics
(
)
{
directAllowed_
=
JS
:
:
Prefs
:
:
wasm_direct_inlining
(
)
;
callRefAllowed_
=
JS
:
:
Prefs
:
:
wasm_call_ref_inlining
(
)
;
level_
=
JS
:
:
Prefs
:
:
wasm_inlining_level
(
)
;
level_
=
std
:
:
max
<
uint32_t
>
(
level_
MIN_LEVEL
)
;
level_
=
std
:
:
min
<
uint32_t
>
(
level_
MAX_LEVEL
)
;
}
uint32_t
level
(
)
const
{
return
level_
;
}
bool
directAllowed
(
)
const
{
return
directAllowed_
;
}
bool
callRefAllowed
(
)
const
{
return
callRefAllowed_
;
}
enum
class
CallKind
{
Direct
CallRef
}
;
bool
isSmallEnoughToInline
(
CallKind
callKind
uint32_t
inliningDepth
uint32_t
bodyLength
)
const
{
MOZ_RELEASE_ASSERT
(
inliningDepth
<
=
10
)
;
if
(
(
callKind
=
=
CallKind
:
:
Direct
&
&
!
directAllowed_
)
|
|
(
callKind
=
=
CallKind
:
:
CallRef
&
&
!
callRefAllowed_
)
)
{
return
false
;
}
static
constexpr
int32_t
baseSize
[
9
]
=
{
0
50
100
150
200
250
300
350
400
}
;
MOZ_RELEASE_ASSERT
(
level_
>
=
MIN_LEVEL
&
&
level_
<
=
MAX_LEVEL
)
;
int32_t
allowedSize
=
baseSize
[
level_
-
MIN_LEVEL
]
;
allowedSize
-
=
int32_t
(
50
*
inliningDepth
)
;
return
allowedSize
>
0
&
&
bodyLength
<
=
uint32_t
(
allowedSize
)
;
}
}
;
}
}
#
endif
