#
ifndef
wasm_WasmHeuristics_h
#
define
wasm_WasmHeuristics_h
#
include
<
math
.
h
>
#
include
"
js
/
Prefs
.
h
"
#
include
"
threading
/
ExclusiveData
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
namespace
js
{
namespace
wasm
{
class
LazyTieringHeuristics
{
static
constexpr
uint32_t
MIN_LEVEL
=
1
;
static
constexpr
uint32_t
MAX_LEVEL
=
9
;
static
constexpr
float
scale_
[
7
]
=
{
27
.
0
9
.
0
3
.
0
1
.
0
0
.
333
0
.
111
0
.
037
}
;
public
:
static
uint32_t
rawLevel
(
)
{
uint32_t
level
=
JS
:
:
Prefs
:
:
wasm_lazy_tiering_level
(
)
;
level
=
std
:
:
max
<
uint32_t
>
(
level
MIN_LEVEL
)
;
level
=
std
:
:
min
<
uint32_t
>
(
level
MAX_LEVEL
)
;
return
level
;
}
static
int32_t
estimateIonCompilationCost
(
uint32_t
bodyLength
)
{
uint32_t
level
=
rawLevel
(
)
;
if
(
MOZ_LIKELY
(
MIN_LEVEL
<
level
&
&
level
<
MAX_LEVEL
)
)
{
float
thresholdF
=
30000
.
0
+
4000
.
0
*
float
(
bodyLength
)
;
thresholdF
*
=
0
.
25
;
thresholdF
*
=
scale_
[
level
-
(
MIN_LEVEL
+
1
)
]
;
thresholdF
=
std
:
:
max
<
float
>
(
thresholdF
10
.
0
)
;
thresholdF
=
std
:
:
min
<
float
>
(
thresholdF
2
.
0e9
)
;
int32_t
thresholdI
=
int32_t
(
thresholdF
)
;
MOZ_RELEASE_ASSERT
(
thresholdI
>
=
0
)
;
return
thresholdI
;
}
if
(
level
=
=
MIN_LEVEL
)
{
return
INT32_MAX
;
}
if
(
level
=
=
MAX_LEVEL
)
{
return
0
;
}
MOZ_CRASH
(
)
;
}
}
;
class
InliningHeuristics
{
static
constexpr
uint32_t
MIN_LEVEL
=
1
;
static
constexpr
uint32_t
MAX_LEVEL
=
9
;
public
:
static
uint32_t
rawLevel
(
)
{
uint32_t
level
=
JS
:
:
Prefs
:
:
wasm_inlining_level
(
)
;
level
=
std
:
:
max
<
uint32_t
>
(
level
MIN_LEVEL
)
;
level
=
std
:
:
min
<
uint32_t
>
(
level
MAX_LEVEL
)
;
return
level
;
}
static
bool
rawDirectAllowed
(
)
{
return
JS
:
:
Prefs
:
:
wasm_direct_inlining
(
)
;
}
static
bool
rawCallRefAllowed
(
)
{
return
JS
:
:
Prefs
:
:
wasm_call_ref_inlining
(
)
;
}
enum
class
CallKind
{
Direct
CallRef
}
;
static
bool
isSmallEnoughToInline
(
CallKind
callKind
uint32_t
inliningDepth
uint32_t
bodyLength
)
{
MOZ_RELEASE_ASSERT
(
inliningDepth
<
=
10
)
;
if
(
(
callKind
=
=
CallKind
:
:
Direct
&
&
!
rawDirectAllowed
(
)
)
|
|
(
callKind
=
=
CallKind
:
:
CallRef
&
&
!
rawCallRefAllowed
(
)
)
)
{
return
false
;
}
static
constexpr
int32_t
baseSize
[
9
]
=
{
0
50
100
150
200
250
300
350
400
}
;
uint32_t
level
=
rawLevel
(
)
;
MOZ_RELEASE_ASSERT
(
level
>
=
MIN_LEVEL
&
&
level
<
=
MAX_LEVEL
)
;
int32_t
allowedSize
=
baseSize
[
level
-
MIN_LEVEL
]
;
allowedSize
-
=
int32_t
(
50
*
inliningDepth
)
;
return
allowedSize
>
0
&
&
bodyLength
<
=
uint32_t
(
allowedSize
)
;
}
}
;
}
}
#
endif
