#
ifndef
wasm_WasmGcObject_h
#
define
wasm_WasmGcObject_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
gc
/
GCProbes
.
h
"
#
include
"
gc
/
Pretenuring
.
h
"
#
include
"
gc
/
ZoneAllocator
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
Probes
.
h
"
#
include
"
wasm
/
WasmInstanceData
.
h
"
#
include
"
wasm
/
WasmMemory
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
namespace
js
{
class
WasmGcObject
:
public
JSObject
{
protected
:
const
wasm
:
:
SuperTypeVector
*
superTypeVector_
;
static
const
ObjectOps
objectOps_
;
[
[
nodiscard
]
]
static
bool
obj_lookupProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleObject
objp
PropertyResult
*
propp
)
;
[
[
nodiscard
]
]
static
bool
obj_defineProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Handle
<
PropertyDescriptor
>
desc
ObjectOpResult
&
result
)
;
[
[
nodiscard
]
]
static
bool
obj_hasProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
foundp
)
;
[
[
nodiscard
]
]
static
bool
obj_getProperty
(
JSContext
*
cx
HandleObject
obj
HandleValue
receiver
HandleId
id
MutableHandleValue
vp
)
;
[
[
nodiscard
]
]
static
bool
obj_setProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
;
[
[
nodiscard
]
]
static
bool
obj_getOwnPropertyDescriptor
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandle
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
)
;
[
[
nodiscard
]
]
static
bool
obj_deleteProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
ObjectOpResult
&
result
)
;
class
PropOffset
{
uint32_t
u32_
;
public
:
PropOffset
(
)
:
u32_
(
0
)
{
}
uint32_t
get
(
)
const
{
return
u32_
;
}
void
set
(
uint32_t
u32
)
{
u32_
=
u32
;
}
}
;
[
[
nodiscard
]
]
static
bool
lookUpProperty
(
JSContext
*
cx
Handle
<
WasmGcObject
*
>
obj
jsid
id
PropOffset
*
offset
wasm
:
:
StorageType
*
type
)
;
public
:
[
[
nodiscard
]
]
static
bool
loadValue
(
JSContext
*
cx
Handle
<
WasmGcObject
*
>
obj
jsid
id
MutableHandleValue
vp
)
;
const
wasm
:
:
SuperTypeVector
&
superTypeVector
(
)
const
{
return
*
superTypeVector_
;
}
static
constexpr
size_t
offsetOfSuperTypeVector
(
)
{
return
offsetof
(
WasmGcObject
superTypeVector_
)
;
}
const
wasm
:
:
TypeDef
&
typeDef
(
)
const
{
return
*
superTypeVector
(
)
.
typeDef
(
)
;
}
wasm
:
:
TypeDefKind
kind
(
)
const
{
return
superTypeVector
(
)
.
typeDef
(
)
-
>
kind
(
)
;
}
[
[
nodiscard
]
]
bool
isRuntimeSubtypeOf
(
const
wasm
:
:
TypeDef
*
parentTypeDef
)
const
;
[
[
nodiscard
]
]
static
bool
obj_newEnumerate
(
JSContext
*
cx
HandleObject
obj
MutableHandleIdVector
properties
bool
enumerableOnly
)
;
}
;
class
WasmArrayObject
:
public
WasmGcObject
public
TrailingArray
<
WasmArrayObject
>
{
public
:
static
const
JSClass
class_
;
uint32_t
numElements_
;
uint8_t
*
data_
;
uint8_t
*
inlineStorage
(
)
{
return
offsetToPointer
<
uint8_t
>
(
offsetOfInlineStorage
(
)
)
;
}
template
<
typename
T
>
T
*
inlineArrayElements
(
)
{
return
offsetToPointer
<
T
>
(
offsetOfInlineArrayData
(
)
)
;
}
static
inline
gc
:
:
AllocKind
allocKindForOOL
(
)
;
static
inline
gc
:
:
AllocKind
allocKindForIL
(
uint32_t
storageBytes
)
;
inline
gc
:
:
AllocKind
allocKind
(
)
const
;
static
constexpr
mozilla
:
:
CheckedUint32
calcStorageBytesChecked
(
uint32_t
elemSize
uint32_t
numElements
)
{
static_assert
(
sizeof
(
WasmArrayObject
)
%
gc
:
:
CellAlignBytes
=
=
0
)
;
mozilla
:
:
CheckedUint32
storageBytes
=
elemSize
;
storageBytes
*
=
numElements
;
storageBytes
+
=
sizeof
(
WasmArrayObject
:
:
DataHeader
)
;
storageBytes
-
=
1
;
storageBytes
+
=
gc
:
:
CellAlignBytes
-
(
storageBytes
%
gc
:
:
CellAlignBytes
)
;
return
storageBytes
;
}
static
uint32_t
calcStorageBytesUnchecked
(
uint32_t
elemSize
uint32_t
numElements
)
{
mozilla
:
:
CheckedUint32
storageBytes
=
calcStorageBytesChecked
(
elemSize
numElements
)
;
MOZ_ASSERT
(
storageBytes
.
isValid
(
)
)
;
return
storageBytes
.
value
(
)
;
}
static
inline
constexpr
uint32_t
maxInlineElementsForElemSize
(
uint32_t
elemSize
)
;
size_t
sizeOfExcludingThis
(
)
const
;
using
DataHeader
=
uintptr_t
;
static
const
DataHeader
DataIsIL
=
0x37
;
static
const
DataHeader
DataIsOOL
=
0x71
;
template
<
bool
ZeroFields
>
static
MOZ_ALWAYS_INLINE
WasmArrayObject
*
createArrayOOL
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
js
:
:
gc
:
:
AllocSite
*
allocSite
js
:
:
gc
:
:
Heap
initialHeap
uint32_t
numElements
uint32_t
storageBytes
)
;
template
<
bool
ZeroFields
>
static
MOZ_ALWAYS_INLINE
WasmArrayObject
*
createArrayIL
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
js
:
:
gc
:
:
AllocSite
*
allocSite
js
:
:
gc
:
:
Heap
initialHeap
uint32_t
numElements
uint32_t
storageBytes
)
;
template
<
bool
ZeroFields
>
static
MOZ_ALWAYS_INLINE
WasmArrayObject
*
createArray
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
js
:
:
gc
:
:
AllocSite
*
allocSite
js
:
:
gc
:
:
Heap
initialHeap
uint32_t
numElements
)
;
static
constexpr
size_t
offsetOfNumElements
(
)
{
return
offsetof
(
WasmArrayObject
numElements_
)
;
}
static
constexpr
size_t
offsetOfData
(
)
{
return
offsetof
(
WasmArrayObject
data_
)
;
}
static
const
uint32_t
inlineStorageAlignment
=
8
;
static
constexpr
size_t
offsetOfInlineStorage
(
)
{
return
AlignBytes
(
sizeof
(
WasmArrayObject
)
inlineStorageAlignment
)
;
}
static
constexpr
size_t
offsetOfInlineArrayData
(
)
{
return
offsetOfInlineStorage
(
)
+
sizeof
(
DataHeader
)
;
}
static
void
obj_trace
(
JSTracer
*
trc
JSObject
*
object
)
;
static
void
obj_finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
object
)
;
static
size_t
obj_moved
(
JSObject
*
objNew
JSObject
*
objOld
)
;
void
storeVal
(
const
wasm
:
:
Val
&
val
uint32_t
itemIndex
)
;
void
fillVal
(
const
wasm
:
:
Val
&
val
uint32_t
itemIndex
uint32_t
len
)
;
static
inline
DataHeader
*
dataHeaderFromDataPointer
(
const
uint8_t
*
data
)
{
MOZ_ASSERT
(
data
)
;
DataHeader
*
header
=
(
DataHeader
*
)
data
;
header
-
-
;
MOZ_ASSERT
(
*
header
=
=
DataIsIL
|
|
*
header
=
=
DataIsOOL
)
;
return
header
;
}
DataHeader
*
dataHeader
(
)
const
{
return
WasmArrayObject
:
:
dataHeaderFromDataPointer
(
data_
)
;
}
static
inline
uint8_t
*
dataHeaderToDataPointer
(
const
DataHeader
*
header
)
{
MOZ_ASSERT
(
header
)
;
MOZ_ASSERT
(
*
header
=
=
DataIsIL
|
|
*
header
=
=
DataIsOOL
)
;
header
+
+
;
return
(
uint8_t
*
)
header
;
}
static
bool
isDataInline
(
uint8_t
*
data
)
{
const
DataHeader
*
header
=
dataHeaderFromDataPointer
(
data
)
;
MOZ_ASSERT
(
*
header
=
=
DataIsIL
|
|
*
header
=
=
DataIsOOL
)
;
return
*
header
=
=
DataIsIL
;
}
bool
isDataInline
(
)
const
{
return
WasmArrayObject
:
:
isDataInline
(
data_
)
;
}
static
WasmArrayObject
*
fromInlineDataPointer
(
uint8_t
*
data
)
{
MOZ_ASSERT
(
isDataInline
(
data
)
)
;
return
(
WasmArrayObject
*
)
(
data
-
WasmArrayObject
:
:
offsetOfInlineArrayData
(
)
)
;
}
static
DataHeader
*
addressOfInlineDataHeader
(
WasmArrayObject
*
base
)
{
return
base
-
>
offsetToPointer
<
DataHeader
>
(
offsetOfInlineStorage
(
)
)
;
}
static
uint8_t
*
addressOfInlineData
(
WasmArrayObject
*
base
)
{
return
base
-
>
offsetToPointer
<
uint8_t
>
(
offsetOfInlineArrayData
(
)
)
;
}
}
;
static_assert
(
(
WasmArrayObject
:
:
offsetOfInlineStorage
(
)
%
8
)
=
=
0
)
;
#
define
STATIC_ASSERT_WASMARRAYELEMENTS_NUMELEMENTS_IS_U32
\
static_assert
(
sizeof
(
js
:
:
WasmArrayObject
:
:
numElements_
)
=
=
sizeof
(
uint32_t
)
)
class
WasmStructObject
:
public
WasmGcObject
public
TrailingArray
<
WasmStructObject
>
{
public
:
static
const
JSClass
classInline_
;
static
const
JSClass
classOutline_
;
static
const
JSClass
*
classFromOOLness
(
bool
needsOOLstorage
)
{
return
needsOOLstorage
?
&
classOutline_
:
&
classInline_
;
}
size_t
sizeOfExcludingThis
(
)
const
;
template
<
bool
ZeroFields
>
static
MOZ_ALWAYS_INLINE
WasmStructObject
*
createStructIL
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
gc
:
:
AllocSite
*
allocSite
js
:
:
gc
:
:
Heap
initialHeap
)
;
template
<
bool
ZeroFields
>
static
MOZ_ALWAYS_INLINE
WasmStructObject
*
createStructOOL
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
gc
:
:
AllocSite
*
allocSite
js
:
:
gc
:
:
Heap
initialHeap
)
;
uint8_t
*
fieldIndexToAddress
(
uint32_t
fieldIndex
)
;
bool
hasOOLPointer
(
)
const
;
uint8_t
*
*
addressOfOOLPointer
(
)
const
;
uint8_t
*
getOOLPointer
(
)
const
;
void
setOOLPointer
(
uint8_t
*
newOOLpointer
)
;
uint8_t
*
*
addressOfOOLPointer
(
const
wasm
:
:
TypeDefInstanceData
*
typeDefData
)
const
;
void
setOOLPointer
(
const
wasm
:
:
TypeDefInstanceData
*
typeDefData
uint8_t
*
newOOLpointer
)
;
bool
getField
(
JSContext
*
cx
uint32_t
index
MutableHandle
<
Value
>
val
)
;
static
void
obj_trace
(
JSTracer
*
trc
JSObject
*
object
)
;
static
size_t
obj_moved
(
JSObject
*
objNew
JSObject
*
objOld
)
;
void
storeVal
(
const
wasm
:
:
Val
&
val
uint32_t
fieldIndex
)
;
}
;
static_assert
(
sizeof
(
WasmStructObject
)
=
=
16
)
;
static_assert
(
(
sizeof
(
WasmStructObject
)
%
8
)
=
=
0
)
;
const
size_t
WasmStructObject_MaxInlineBytes
=
(
(
JSObject
:
:
MAX_BYTE_SIZE
-
sizeof
(
WasmStructObject
)
)
/
8
)
*
8
;
static_assert
(
(
WasmStructObject_MaxInlineBytes
%
8
)
=
=
0
)
;
static_assert
(
wasm
:
:
WasmStructObject_Size_ASSUMED
=
=
sizeof
(
WasmStructObject
)
)
;
static_assert
(
wasm
:
:
WasmStructObject_MaxInlineBytes_ASSUMED
=
=
WasmStructObject_MaxInlineBytes
)
;
const
size_t
WasmArrayObject_MaxInlineBytes
=
(
(
JSObject
:
:
MAX_BYTE_SIZE
-
sizeof
(
WasmArrayObject
)
)
/
16
)
*
16
;
static_assert
(
(
WasmArrayObject_MaxInlineBytes
%
16
)
=
=
0
)
;
inline
constexpr
uint32_t
WasmArrayObject
:
:
maxInlineElementsForElemSize
(
uint32_t
elemSize
)
{
MOZ_RELEASE_ASSERT
(
elemSize
>
0
)
;
uint32_t
result
=
WasmArrayObject_MaxInlineBytes
;
static_assert
(
WasmArrayObject_MaxInlineBytes
%
gc
:
:
CellAlignBytes
=
=
0
)
;
result
-
=
sizeof
(
WasmArrayObject
:
:
DataHeader
)
;
result
/
=
elemSize
;
MOZ_RELEASE_ASSERT
(
calcStorageBytesChecked
(
elemSize
result
)
.
isValid
(
)
)
;
return
result
;
}
inline
bool
WasmStructObject
:
:
hasOOLPointer
(
)
const
{
const
wasm
:
:
SuperTypeVector
*
stv
=
superTypeVector_
;
const
wasm
:
:
TypeDef
*
typeDef
=
stv
-
>
typeDef
(
)
;
MOZ_ASSERT
(
typeDef
-
>
superTypeVector
(
)
=
=
stv
)
;
const
wasm
:
:
StructType
&
structType
=
typeDef
-
>
structType
(
)
;
uint32_t
offset
=
structType
.
oolPointerOffset_
;
return
offset
!
=
wasm
:
:
StructType
:
:
InvalidOffset
;
}
inline
uint8_t
*
*
WasmStructObject
:
:
addressOfOOLPointer
(
)
const
{
const
wasm
:
:
SuperTypeVector
*
stv
=
superTypeVector_
;
const
wasm
:
:
TypeDef
*
typeDef
=
stv
-
>
typeDef
(
)
;
MOZ_ASSERT
(
typeDef
-
>
superTypeVector
(
)
=
=
stv
)
;
const
wasm
:
:
StructType
&
structType
=
typeDef
-
>
structType
(
)
;
uint32_t
offset
=
structType
.
oolPointerOffset_
;
MOZ_RELEASE_ASSERT
(
offset
!
=
wasm
:
:
StructType
:
:
InvalidOffset
)
;
return
(
uint8_t
*
*
)
(
(
uint8_t
*
)
this
+
offset
)
;
}
inline
uint8_t
*
WasmStructObject
:
:
getOOLPointer
(
)
const
{
return
*
addressOfOOLPointer
(
)
;
}
inline
void
WasmStructObject
:
:
setOOLPointer
(
uint8_t
*
newOOLpointer
)
{
*
addressOfOOLPointer
(
)
=
newOOLpointer
;
}
inline
uint8_t
*
*
WasmStructObject
:
:
addressOfOOLPointer
(
const
wasm
:
:
TypeDefInstanceData
*
typeDefData
)
const
{
uint32_t
offset
=
typeDefData
-
>
cached
.
strukt
.
oolPointerOffset
;
MOZ_RELEASE_ASSERT
(
offset
!
=
wasm
:
:
StructType
:
:
InvalidOffset
)
;
uint8_t
*
*
addr
=
(
uint8_t
*
*
)
(
(
uint8_t
*
)
this
+
offset
)
;
MOZ_ASSERT
(
addr
=
=
addressOfOOLPointer
(
)
)
;
return
addr
;
}
inline
void
WasmStructObject
:
:
setOOLPointer
(
const
wasm
:
:
TypeDefInstanceData
*
typeDefData
uint8_t
*
newOOLpointer
)
{
*
addressOfOOLPointer
(
typeDefData
)
=
newOOLpointer
;
}
static_assert
(
WasmStructObject_MaxInlineBytes
<
=
wasm
:
:
NullPtrGuardSize
)
;
static_assert
(
sizeof
(
WasmArrayObject
)
<
=
wasm
:
:
NullPtrGuardSize
)
;
template
<
typename
T
>
class
MOZ_RAII
StableWasmArrayObjectElements
{
static
constexpr
size_t
MaxInlineElements
=
WasmArrayObject
:
:
maxInlineElementsForElemSize
(
sizeof
(
T
)
)
;
Rooted
<
WasmArrayObject
*
>
array_
;
T
*
elements_
;
mozilla
:
:
Maybe
<
mozilla
:
:
Vector
<
T
MaxInlineElements
SystemAllocPolicy
>
>
ownElements_
;
public
:
StableWasmArrayObjectElements
(
JSContext
*
cx
Handle
<
WasmArrayObject
*
>
array
)
:
array_
(
cx
array
)
elements_
(
nullptr
)
{
if
(
array
-
>
isDataInline
(
)
)
{
ownElements_
.
emplace
(
)
;
if
(
!
ownElements_
-
>
resize
(
array
-
>
numElements_
)
)
{
MOZ_CRASH
(
)
;
}
const
T
*
src
=
array
-
>
inlineArrayElements
<
T
>
(
)
;
std
:
:
copy
(
src
src
+
array
-
>
numElements_
ownElements_
-
>
begin
(
)
)
;
elements_
=
ownElements_
-
>
begin
(
)
;
}
else
{
elements_
=
reinterpret_cast
<
T
*
>
(
array
-
>
data_
)
;
}
}
T
*
elements
(
)
{
return
elements_
;
}
size_t
length
(
)
const
{
return
array_
-
>
numElements_
;
}
}
;
}
namespace
js
{
inline
bool
IsWasmGcObjectClass
(
const
JSClass
*
class_
)
{
return
class_
=
=
&
WasmArrayObject
:
:
class_
|
|
class_
=
=
&
WasmStructObject
:
:
classInline_
|
|
class_
=
=
&
WasmStructObject
:
:
classOutline_
;
}
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
WasmGcObject
>
(
)
const
{
return
js
:
:
IsWasmGcObjectClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
WasmStructObject
>
(
)
const
{
const
JSClass
*
class_
=
getClass
(
)
;
return
class_
=
=
&
js
:
:
WasmStructObject
:
:
classInline_
|
|
class_
=
=
&
js
:
:
WasmStructObject
:
:
classOutline_
;
}
#
endif
