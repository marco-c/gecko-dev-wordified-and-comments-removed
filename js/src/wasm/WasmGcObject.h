#
ifndef
wasm_WasmGcObject_h
#
define
wasm_WasmGcObject_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
gc
/
GCProbes
.
h
"
#
include
"
gc
/
Pretenuring
.
h
"
#
include
"
gc
/
ZoneAllocator
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
Probes
.
h
"
#
include
"
wasm
/
WasmInstanceData
.
h
"
#
include
"
wasm
/
WasmMemory
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
using
js
:
:
wasm
:
:
FieldType
;
namespace
js
:
:
wasm
{
static
const
size_t
TrailerBlockOverhead
=
(
16
/
2
)
+
(
1
*
sizeof
(
void
*
)
)
;
}
namespace
js
{
class
WasmGcObject
:
public
JSObject
{
protected
:
const
wasm
:
:
SuperTypeVector
*
superTypeVector_
;
static
const
ObjectOps
objectOps_
;
[
[
nodiscard
]
]
static
bool
obj_lookupProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleObject
objp
PropertyResult
*
propp
)
;
[
[
nodiscard
]
]
static
bool
obj_defineProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Handle
<
PropertyDescriptor
>
desc
ObjectOpResult
&
result
)
;
[
[
nodiscard
]
]
static
bool
obj_hasProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
foundp
)
;
[
[
nodiscard
]
]
static
bool
obj_getProperty
(
JSContext
*
cx
HandleObject
obj
HandleValue
receiver
HandleId
id
MutableHandleValue
vp
)
;
[
[
nodiscard
]
]
static
bool
obj_setProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
;
[
[
nodiscard
]
]
static
bool
obj_getOwnPropertyDescriptor
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandle
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
)
;
[
[
nodiscard
]
]
static
bool
obj_deleteProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
ObjectOpResult
&
result
)
;
class
PropOffset
{
uint32_t
u32_
;
public
:
PropOffset
(
)
:
u32_
(
0
)
{
}
uint32_t
get
(
)
const
{
return
u32_
;
}
void
set
(
uint32_t
u32
)
{
u32_
=
u32
;
}
}
;
[
[
nodiscard
]
]
static
bool
lookUpProperty
(
JSContext
*
cx
Handle
<
WasmGcObject
*
>
obj
jsid
id
PropOffset
*
offset
FieldType
*
type
)
;
public
:
[
[
nodiscard
]
]
static
bool
loadValue
(
JSContext
*
cx
Handle
<
WasmGcObject
*
>
obj
jsid
id
MutableHandleValue
vp
)
;
const
wasm
:
:
SuperTypeVector
&
superTypeVector
(
)
const
{
return
*
superTypeVector_
;
}
static
size_t
offsetOfSuperTypeVector
(
)
{
return
offsetof
(
WasmGcObject
superTypeVector_
)
;
}
const
wasm
:
:
TypeDef
&
typeDef
(
)
const
{
return
*
superTypeVector
(
)
.
typeDef
(
)
;
}
wasm
:
:
TypeDefKind
kind
(
)
const
{
return
superTypeVector
(
)
.
typeDef
(
)
-
>
kind
(
)
;
}
[
[
nodiscard
]
]
bool
isRuntimeSubtypeOf
(
const
wasm
:
:
TypeDef
*
parentTypeDef
)
const
;
[
[
nodiscard
]
]
static
bool
obj_newEnumerate
(
JSContext
*
cx
HandleObject
obj
MutableHandleIdVector
properties
bool
enumerableOnly
)
;
}
;
class
WasmArrayObject
:
public
WasmGcObject
{
public
:
static
const
JSClass
class_
;
uint32_t
numElements_
;
uint8_t
*
data_
;
static
gc
:
:
AllocKind
allocKind
(
)
;
template
<
bool
ZeroFields
>
static
WasmArrayObject
*
createArrayNonEmpty
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
js
:
:
gc
:
:
Heap
initialHeap
uint32_t
numElements
)
;
static
WasmArrayObject
*
createArrayEmpty
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
js
:
:
gc
:
:
Heap
initialHeap
)
;
template
<
bool
ZeroFields
>
static
MOZ_ALWAYS_INLINE
WasmArrayObject
*
createArray
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
js
:
:
gc
:
:
Heap
initialHeap
uint32_t
numElements
)
{
return
numElements
=
=
0
?
createArrayEmpty
(
cx
typeDefData
initialHeap
)
:
createArrayNonEmpty
<
ZeroFields
>
(
cx
typeDefData
initialHeap
numElements
)
;
}
static
constexpr
size_t
offsetOfNumElements
(
)
{
return
offsetof
(
WasmArrayObject
numElements_
)
;
}
static
constexpr
size_t
offsetOfData
(
)
{
return
offsetof
(
WasmArrayObject
data_
)
;
}
static
void
obj_trace
(
JSTracer
*
trc
JSObject
*
object
)
;
static
void
obj_finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
object
)
;
static
size_t
obj_moved
(
JSObject
*
obj
JSObject
*
old
)
;
void
storeVal
(
const
wasm
:
:
Val
&
val
uint32_t
itemIndex
)
;
void
fillVal
(
const
wasm
:
:
Val
&
val
uint32_t
itemIndex
uint32_t
len
)
;
}
;
#
define
STATIC_ASSERT_WASMARRAYELEMENTS_NUMELEMENTS_IS_U32
\
static_assert
(
sizeof
(
js
:
:
WasmArrayObject
:
:
numElements_
)
=
=
sizeof
(
uint32_t
)
)
class
WasmStructObject
:
public
WasmGcObject
{
public
:
static
const
JSClass
classInline_
;
static
const
JSClass
classOutline_
;
uint8_t
*
outlineData_
;
alignas
(
8
)
uint8_t
inlineData_
[
0
]
;
static
inline
size_t
sizeOfIncludingInlineData
(
size_t
sizeOfInlineData
)
{
size_t
n
=
sizeof
(
WasmStructObject
)
+
sizeOfInlineData
;
MOZ_ASSERT
(
n
<
=
JSObject
:
:
MAX_BYTE_SIZE
)
;
return
n
;
}
static
const
JSClass
*
classForTypeDef
(
const
wasm
:
:
TypeDef
*
typeDef
)
;
static
js
:
:
gc
:
:
AllocKind
allocKindForTypeDef
(
const
wasm
:
:
TypeDef
*
typeDef
)
;
template
<
bool
ZeroFields
>
static
MOZ_ALWAYS_INLINE
WasmStructObject
*
createStructIL
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
js
:
:
gc
:
:
Heap
initialHeap
)
;
template
<
bool
ZeroFields
>
static
MOZ_ALWAYS_INLINE
WasmStructObject
*
createStructOOL
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
js
:
:
gc
:
:
Heap
initialHeap
)
;
static
inline
void
getDataByteSizes
(
uint32_t
totalBytes
uint32_t
*
inlineBytes
uint32_t
*
outlineBytes
)
;
static
inline
bool
requiresOutlineBytes
(
uint32_t
totalBytes
)
;
static
inline
void
fieldOffsetToAreaAndOffset
(
FieldType
fieldType
uint32_t
fieldOffset
bool
*
areaIsOutline
uint32_t
*
areaOffset
)
;
inline
uint8_t
*
fieldOffsetToAddress
(
FieldType
fieldType
uint32_t
fieldOffset
)
const
;
static
constexpr
size_t
offsetOfOutlineData
(
)
{
return
offsetof
(
WasmStructObject
outlineData_
)
;
}
static
constexpr
size_t
offsetOfInlineData
(
)
{
return
offsetof
(
WasmStructObject
inlineData_
)
;
}
static
void
obj_trace
(
JSTracer
*
trc
JSObject
*
object
)
;
static
void
obj_finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
object
)
;
static
size_t
obj_moved
(
JSObject
*
obj
JSObject
*
old
)
;
void
storeVal
(
const
wasm
:
:
Val
&
val
uint32_t
fieldIndex
)
;
}
;
static_assert
(
(
offsetof
(
WasmStructObject
inlineData_
)
%
8
)
=
=
0
)
;
const
size_t
WasmStructObject_MaxInlineBytes
=
(
(
JSObject
:
:
MAX_BYTE_SIZE
-
sizeof
(
WasmStructObject
)
)
/
16
)
*
16
;
static_assert
(
(
WasmStructObject_MaxInlineBytes
%
16
)
=
=
0
)
;
inline
void
WasmStructObject
:
:
getDataByteSizes
(
uint32_t
totalBytes
uint32_t
*
inlineBytes
uint32_t
*
outlineBytes
)
{
if
(
MOZ_UNLIKELY
(
totalBytes
>
WasmStructObject_MaxInlineBytes
)
)
{
*
inlineBytes
=
WasmStructObject_MaxInlineBytes
;
*
outlineBytes
=
totalBytes
-
WasmStructObject_MaxInlineBytes
;
}
else
{
*
inlineBytes
=
totalBytes
;
*
outlineBytes
=
0
;
}
}
inline
bool
WasmStructObject
:
:
requiresOutlineBytes
(
uint32_t
totalBytes
)
{
uint32_t
inlineBytes
outlineBytes
;
WasmStructObject
:
:
getDataByteSizes
(
totalBytes
&
inlineBytes
&
outlineBytes
)
;
return
outlineBytes
>
0
;
}
inline
void
WasmStructObject
:
:
fieldOffsetToAreaAndOffset
(
FieldType
fieldType
uint32_t
fieldOffset
bool
*
areaIsOutline
uint32_t
*
areaOffset
)
{
if
(
fieldOffset
<
WasmStructObject_MaxInlineBytes
)
{
*
areaIsOutline
=
false
;
*
areaOffset
=
fieldOffset
;
}
else
{
*
areaIsOutline
=
true
;
*
areaOffset
=
fieldOffset
-
WasmStructObject_MaxInlineBytes
;
}
MOZ_RELEASE_ASSERT
(
(
fieldOffset
<
WasmStructObject_MaxInlineBytes
)
=
=
(
(
fieldOffset
+
fieldType
.
size
(
)
-
1
)
<
WasmStructObject_MaxInlineBytes
)
)
;
}
inline
uint8_t
*
WasmStructObject
:
:
fieldOffsetToAddress
(
FieldType
fieldType
uint32_t
fieldOffset
)
const
{
bool
areaIsOutline
;
uint32_t
areaOffset
;
fieldOffsetToAreaAndOffset
(
fieldType
fieldOffset
&
areaIsOutline
&
areaOffset
)
;
return
(
(
uint8_t
*
)
(
areaIsOutline
?
outlineData_
:
&
inlineData_
[
0
]
)
)
+
areaOffset
;
}
static_assert
(
WasmStructObject_MaxInlineBytes
<
=
wasm
:
:
NullPtrGuardSize
)
;
static_assert
(
sizeof
(
WasmArrayObject
)
<
=
wasm
:
:
NullPtrGuardSize
)
;
}
namespace
js
{
inline
bool
IsWasmGcObjectClass
(
const
JSClass
*
class_
)
{
return
class_
=
=
&
WasmArrayObject
:
:
class_
|
|
class_
=
=
&
WasmStructObject
:
:
classInline_
|
|
class_
=
=
&
WasmStructObject
:
:
classOutline_
;
}
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
WasmGcObject
>
(
)
const
{
return
js
:
:
IsWasmGcObjectClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
WasmStructObject
>
(
)
const
{
const
JSClass
*
class_
=
getClass
(
)
;
return
class_
=
=
&
js
:
:
WasmStructObject
:
:
classInline_
|
|
class_
=
=
&
js
:
:
WasmStructObject
:
:
classOutline_
;
}
namespace
js
{
template
<
bool
ZeroFields
>
MOZ_ALWAYS_INLINE
WasmStructObject
*
WasmStructObject
:
:
createStructIL
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
js
:
:
gc
:
:
Heap
initialHeap
)
{
MOZ_ASSERT
(
IsWasmGcObjectClass
(
typeDefData
-
>
clasp
)
)
;
MOZ_ASSERT
(
!
typeDefData
-
>
clasp
-
>
isNativeObject
(
)
)
;
debugCheckNewObject
(
typeDefData
-
>
shape
typeDefData
-
>
allocKind
initialHeap
)
;
mozilla
:
:
DebugOnly
<
const
wasm
:
:
TypeDef
*
>
typeDef
=
typeDefData
-
>
typeDef
;
MOZ_ASSERT
(
typeDef
-
>
kind
(
)
=
=
wasm
:
:
TypeDefKind
:
:
Struct
)
;
WasmStructObject
*
structObj
=
(
WasmStructObject
*
)
cx
-
>
newCell
<
WasmGcObject
>
(
typeDefData
-
>
allocKind
initialHeap
typeDefData
-
>
clasp
&
typeDefData
-
>
allocSite
)
;
if
(
MOZ_UNLIKELY
(
!
structObj
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
MOZ_ASSERT
(
(
uintptr_t
(
&
(
structObj
-
>
inlineData_
[
0
]
)
)
%
sizeof
(
uintptr_t
)
)
=
=
0
)
;
structObj
-
>
initShape
(
typeDefData
-
>
shape
)
;
structObj
-
>
superTypeVector_
=
typeDefData
-
>
superTypeVector
;
structObj
-
>
outlineData_
=
nullptr
;
if
constexpr
(
ZeroFields
)
{
uint32_t
totalBytes
=
typeDefData
-
>
structTypeSize
;
MOZ_ASSERT
(
totalBytes
=
=
typeDef
-
>
structType
(
)
.
size_
)
;
MOZ_ASSERT
(
totalBytes
<
=
WasmStructObject_MaxInlineBytes
)
;
MOZ_ASSERT
(
(
totalBytes
%
sizeof
(
uintptr_t
)
)
=
=
0
)
;
memset
(
&
(
structObj
-
>
inlineData_
[
0
]
)
0
totalBytes
)
;
}
js
:
:
gc
:
:
gcprobes
:
:
CreateObject
(
structObj
)
;
probes
:
:
CreateObject
(
cx
structObj
)
;
return
structObj
;
}
template
<
bool
ZeroFields
>
MOZ_ALWAYS_INLINE
WasmStructObject
*
WasmStructObject
:
:
createStructOOL
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
js
:
:
gc
:
:
Heap
initialHeap
)
{
MOZ_ASSERT
(
IsWasmGcObjectClass
(
typeDefData
-
>
clasp
)
)
;
MOZ_ASSERT
(
!
typeDefData
-
>
clasp
-
>
isNativeObject
(
)
)
;
debugCheckNewObject
(
typeDefData
-
>
shape
typeDefData
-
>
allocKind
initialHeap
)
;
mozilla
:
:
DebugOnly
<
const
wasm
:
:
TypeDef
*
>
typeDef
=
typeDefData
-
>
typeDef
;
MOZ_ASSERT
(
typeDef
-
>
kind
(
)
=
=
wasm
:
:
TypeDefKind
:
:
Struct
)
;
uint32_t
totalBytes
=
typeDefData
-
>
structTypeSize
;
MOZ_ASSERT
(
totalBytes
=
=
typeDef
-
>
structType
(
)
.
size_
)
;
MOZ_ASSERT
(
totalBytes
>
WasmStructObject_MaxInlineBytes
)
;
MOZ_ASSERT
(
(
totalBytes
%
sizeof
(
uintptr_t
)
)
=
=
0
)
;
uint32_t
inlineBytes
outlineBytes
;
WasmStructObject
:
:
getDataByteSizes
(
totalBytes
&
inlineBytes
&
outlineBytes
)
;
MOZ_ASSERT
(
inlineBytes
=
=
WasmStructObject_MaxInlineBytes
)
;
MOZ_ASSERT
(
outlineBytes
>
0
)
;
Nursery
&
nursery
=
cx
-
>
nursery
(
)
;
PointerAndUint7
outlineData
=
nursery
.
mallocedBlockCache
(
)
.
alloc
(
outlineBytes
)
;
if
(
MOZ_UNLIKELY
(
!
outlineData
.
pointer
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
Rooted
<
WasmStructObject
*
>
structObj
(
cx
)
;
structObj
=
(
WasmStructObject
*
)
cx
-
>
newCell
<
WasmGcObject
>
(
typeDefData
-
>
allocKind
initialHeap
typeDefData
-
>
clasp
&
typeDefData
-
>
allocSite
)
;
if
(
MOZ_UNLIKELY
(
!
structObj
)
)
{
ReportOutOfMemory
(
cx
)
;
if
(
outlineData
.
pointer
(
)
)
{
nursery
.
mallocedBlockCache
(
)
.
free
(
outlineData
)
;
}
return
nullptr
;
}
MOZ_ASSERT
(
(
uintptr_t
(
&
(
structObj
-
>
inlineData_
[
0
]
)
)
%
sizeof
(
uintptr_t
)
)
=
=
0
)
;
structObj
-
>
initShape
(
typeDefData
-
>
shape
)
;
structObj
-
>
superTypeVector_
=
typeDefData
-
>
superTypeVector
;
structObj
-
>
outlineData_
=
(
uint8_t
*
)
outlineData
.
pointer
(
)
;
if
constexpr
(
ZeroFields
)
{
memset
(
&
(
structObj
-
>
inlineData_
[
0
]
)
0
inlineBytes
)
;
memset
(
outlineData
.
pointer
(
)
0
outlineBytes
)
;
}
if
(
MOZ_LIKELY
(
js
:
:
gc
:
:
IsInsideNursery
(
structObj
)
)
)
{
if
(
MOZ_UNLIKELY
(
!
nursery
.
registerTrailer
(
outlineData
outlineBytes
)
)
)
{
nursery
.
mallocedBlockCache
(
)
.
free
(
outlineData
)
;
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
}
else
{
MOZ_ASSERT
(
structObj
-
>
isTenured
(
)
)
;
AddCellMemory
(
structObj
outlineBytes
+
wasm
:
:
TrailerBlockOverhead
MemoryUse
:
:
WasmTrailerBlock
)
;
}
js
:
:
gc
:
:
gcprobes
:
:
CreateObject
(
structObj
)
;
probes
:
:
CreateObject
(
cx
structObj
)
;
return
structObj
;
}
}
#
endif
