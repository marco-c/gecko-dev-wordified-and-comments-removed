#
ifndef
wasm_WasmGcObject_h
#
define
wasm_WasmGcObject_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
gc
/
GCProbes
.
h
"
#
include
"
gc
/
Pretenuring
.
h
"
#
include
"
gc
/
ZoneAllocator
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
Probes
.
h
"
#
include
"
wasm
/
WasmInstanceData
.
h
"
#
include
"
wasm
/
WasmMemory
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
namespace
js
:
:
wasm
{
static
const
size_t
TrailerBlockOverhead
=
(
16
/
2
)
+
(
1
*
sizeof
(
void
*
)
)
;
}
namespace
js
{
class
WasmGcObject
:
public
JSObject
{
protected
:
const
wasm
:
:
SuperTypeVector
*
superTypeVector_
;
static
const
ObjectOps
objectOps_
;
[
[
nodiscard
]
]
static
bool
obj_lookupProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleObject
objp
PropertyResult
*
propp
)
;
[
[
nodiscard
]
]
static
bool
obj_defineProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Handle
<
PropertyDescriptor
>
desc
ObjectOpResult
&
result
)
;
[
[
nodiscard
]
]
static
bool
obj_hasProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
foundp
)
;
[
[
nodiscard
]
]
static
bool
obj_getProperty
(
JSContext
*
cx
HandleObject
obj
HandleValue
receiver
HandleId
id
MutableHandleValue
vp
)
;
[
[
nodiscard
]
]
static
bool
obj_setProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
;
[
[
nodiscard
]
]
static
bool
obj_getOwnPropertyDescriptor
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandle
<
mozilla
:
:
Maybe
<
PropertyDescriptor
>
>
desc
)
;
[
[
nodiscard
]
]
static
bool
obj_deleteProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
ObjectOpResult
&
result
)
;
class
PropOffset
{
uint32_t
u32_
;
public
:
PropOffset
(
)
:
u32_
(
0
)
{
}
uint32_t
get
(
)
const
{
return
u32_
;
}
void
set
(
uint32_t
u32
)
{
u32_
=
u32
;
}
}
;
[
[
nodiscard
]
]
static
bool
lookUpProperty
(
JSContext
*
cx
Handle
<
WasmGcObject
*
>
obj
jsid
id
PropOffset
*
offset
wasm
:
:
StorageType
*
type
)
;
public
:
[
[
nodiscard
]
]
static
bool
loadValue
(
JSContext
*
cx
Handle
<
WasmGcObject
*
>
obj
jsid
id
MutableHandleValue
vp
)
;
const
wasm
:
:
SuperTypeVector
&
superTypeVector
(
)
const
{
return
*
superTypeVector_
;
}
static
constexpr
size_t
offsetOfSuperTypeVector
(
)
{
return
offsetof
(
WasmGcObject
superTypeVector_
)
;
}
const
wasm
:
:
TypeDef
&
typeDef
(
)
const
{
return
*
superTypeVector
(
)
.
typeDef
(
)
;
}
wasm
:
:
TypeDefKind
kind
(
)
const
{
return
superTypeVector
(
)
.
typeDef
(
)
-
>
kind
(
)
;
}
[
[
nodiscard
]
]
bool
isRuntimeSubtypeOf
(
const
wasm
:
:
TypeDef
*
parentTypeDef
)
const
;
[
[
nodiscard
]
]
static
bool
obj_newEnumerate
(
JSContext
*
cx
HandleObject
obj
MutableHandleIdVector
properties
bool
enumerableOnly
)
;
}
;
class
WasmArrayObject
:
public
WasmGcObject
public
TrailingArray
<
WasmArrayObject
>
{
public
:
static
const
JSClass
class_
;
uint32_t
numElements_
;
uint8_t
*
data_
;
uint8_t
*
inlineStorage
(
)
{
return
offsetToPointer
<
uint8_t
>
(
offsetOfInlineStorage
(
)
)
;
}
static
inline
gc
:
:
AllocKind
allocKindForOOL
(
)
;
static
inline
gc
:
:
AllocKind
allocKindForIL
(
uint32_t
storageBytes
)
;
inline
gc
:
:
AllocKind
allocKind
(
)
const
;
static
constexpr
mozilla
:
:
CheckedUint32
calcStorageBytesChecked
(
uint32_t
elemSize
uint32_t
numElements
)
{
static_assert
(
sizeof
(
WasmArrayObject
)
%
gc
:
:
CellAlignBytes
=
=
0
)
;
mozilla
:
:
CheckedUint32
storageBytes
=
elemSize
;
storageBytes
*
=
numElements
;
storageBytes
+
=
sizeof
(
WasmArrayObject
:
:
DataHeader
)
;
storageBytes
-
=
1
;
storageBytes
+
=
gc
:
:
CellAlignBytes
-
(
storageBytes
%
gc
:
:
CellAlignBytes
)
;
return
storageBytes
;
}
static
uint32_t
calcStorageBytesUnchecked
(
uint32_t
elemSize
uint32_t
numElements
)
{
mozilla
:
:
CheckedUint32
storageBytes
=
calcStorageBytesChecked
(
elemSize
numElements
)
;
MOZ_ASSERT
(
storageBytes
.
isValid
(
)
)
;
return
storageBytes
.
value
(
)
;
}
static
inline
constexpr
uint32_t
maxInlineElementsForElemSize
(
uint32_t
elemSize
)
;
static
void
addSizeOfExcludingThis
(
JSObject
*
obj
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ClassInfo
*
info
JS
:
:
RuntimeSizes
*
runtimeSizes
)
;
using
DataHeader
=
uintptr_t
;
static
const
DataHeader
DataIsIL
=
0
;
static
const
DataHeader
DataIsOOL
=
1
;
template
<
bool
ZeroFields
>
static
MOZ_ALWAYS_INLINE
WasmArrayObject
*
createArrayOOL
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
js
:
:
gc
:
:
AllocSite
*
allocSite
js
:
:
gc
:
:
Heap
initialHeap
uint32_t
numElements
uint32_t
storageBytes
)
;
template
<
bool
ZeroFields
>
static
MOZ_ALWAYS_INLINE
WasmArrayObject
*
createArrayIL
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
js
:
:
gc
:
:
AllocSite
*
allocSite
js
:
:
gc
:
:
Heap
initialHeap
uint32_t
numElements
uint32_t
storageBytes
)
;
template
<
bool
ZeroFields
>
static
MOZ_ALWAYS_INLINE
WasmArrayObject
*
createArray
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
js
:
:
gc
:
:
AllocSite
*
allocSite
js
:
:
gc
:
:
Heap
initialHeap
uint32_t
numElements
)
;
static
constexpr
size_t
offsetOfNumElements
(
)
{
return
offsetof
(
WasmArrayObject
numElements_
)
;
}
static
constexpr
size_t
offsetOfData
(
)
{
return
offsetof
(
WasmArrayObject
data_
)
;
}
static
const
uint32_t
inlineStorageAlignment
=
8
;
static
constexpr
size_t
offsetOfInlineStorage
(
)
{
return
AlignBytes
(
sizeof
(
WasmArrayObject
)
inlineStorageAlignment
)
;
}
static
constexpr
size_t
offsetOfInlineArrayData
(
)
{
return
offsetOfInlineStorage
(
)
+
sizeof
(
DataHeader
)
;
}
static
void
obj_trace
(
JSTracer
*
trc
JSObject
*
object
)
;
static
void
obj_finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
object
)
;
static
size_t
obj_moved
(
JSObject
*
obj
JSObject
*
old
)
;
void
storeVal
(
const
wasm
:
:
Val
&
val
uint32_t
itemIndex
)
;
void
fillVal
(
const
wasm
:
:
Val
&
val
uint32_t
itemIndex
uint32_t
len
)
;
static
DataHeader
*
dataHeaderFromDataPointer
(
const
uint8_t
*
data
)
{
MOZ_ASSERT
(
data
)
;
return
(
DataHeader
*
)
data
-
1
;
}
DataHeader
*
dataHeader
(
)
const
{
return
WasmArrayObject
:
:
dataHeaderFromDataPointer
(
data_
)
;
}
static
bool
isDataInline
(
uint8_t
*
data
)
{
const
DataHeader
*
header
=
dataHeaderFromDataPointer
(
data
)
;
MOZ_ASSERT
(
*
header
=
=
DataIsIL
|
|
*
header
=
=
DataIsOOL
)
;
return
*
header
=
=
DataIsIL
;
}
bool
isDataInline
(
)
const
{
return
WasmArrayObject
:
:
isDataInline
(
data_
)
;
}
static
WasmArrayObject
*
fromInlineDataPointer
(
uint8_t
*
data
)
{
MOZ_ASSERT
(
isDataInline
(
data
)
)
;
return
(
WasmArrayObject
*
)
(
data
-
WasmArrayObject
:
:
offsetOfInlineArrayData
(
)
)
;
}
static
DataHeader
*
addressOfInlineDataHeader
(
WasmArrayObject
*
base
)
{
return
base
-
>
offsetToPointer
<
DataHeader
>
(
offsetOfInlineStorage
(
)
)
;
}
static
uint8_t
*
addressOfInlineData
(
WasmArrayObject
*
base
)
{
return
base
-
>
offsetToPointer
<
uint8_t
>
(
offsetOfInlineArrayData
(
)
)
;
}
}
;
static_assert
(
(
WasmArrayObject
:
:
offsetOfInlineStorage
(
)
%
8
)
=
=
0
)
;
#
define
STATIC_ASSERT_WASMARRAYELEMENTS_NUMELEMENTS_IS_U32
\
static_assert
(
sizeof
(
js
:
:
WasmArrayObject
:
:
numElements_
)
=
=
sizeof
(
uint32_t
)
)
class
WasmStructObject
:
public
WasmGcObject
public
TrailingArray
<
WasmStructObject
>
{
public
:
static
const
JSClass
classInline_
;
static
const
JSClass
classOutline_
;
uint8_t
*
outlineData_
;
uint8_t
*
inlineData
(
)
{
return
offsetToPointer
<
uint8_t
>
(
offsetOfInlineData
(
)
)
;
}
static
inline
constexpr
size_t
sizeOfIncludingInlineData
(
size_t
sizeOfInlineData
)
{
size_t
n
=
sizeof
(
WasmStructObject
)
+
sizeOfInlineData
;
MOZ_ASSERT
(
n
<
=
JSObject
:
:
MAX_BYTE_SIZE
)
;
return
n
;
}
static
void
addSizeOfExcludingThis
(
JSObject
*
obj
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
ClassInfo
*
info
JS
:
:
RuntimeSizes
*
runtimeSizes
)
;
static
const
JSClass
*
classForTypeDef
(
const
wasm
:
:
TypeDef
*
typeDef
)
;
static
js
:
:
gc
:
:
AllocKind
allocKindForTypeDef
(
const
wasm
:
:
TypeDef
*
typeDef
)
;
template
<
bool
ZeroFields
>
static
MOZ_ALWAYS_INLINE
WasmStructObject
*
createStructIL
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
gc
:
:
AllocSite
*
allocSite
js
:
:
gc
:
:
Heap
initialHeap
)
;
template
<
bool
ZeroFields
>
static
MOZ_ALWAYS_INLINE
WasmStructObject
*
createStructOOL
(
JSContext
*
cx
wasm
:
:
TypeDefInstanceData
*
typeDefData
gc
:
:
AllocSite
*
allocSite
js
:
:
gc
:
:
Heap
initialHeap
)
;
static
inline
void
getDataByteSizes
(
uint32_t
totalBytes
uint32_t
*
inlineBytes
uint32_t
*
outlineBytes
)
;
static
inline
bool
requiresOutlineBytes
(
uint32_t
totalBytes
)
;
static
inline
void
fieldOffsetToAreaAndOffset
(
wasm
:
:
StorageType
fieldType
uint32_t
fieldOffset
bool
*
areaIsOutline
uint32_t
*
areaOffset
)
;
inline
uint8_t
*
fieldOffsetToAddress
(
wasm
:
:
StorageType
fieldType
uint32_t
fieldOffset
)
;
bool
getField
(
JSContext
*
cx
uint32_t
index
MutableHandle
<
Value
>
val
)
;
static
const
uint32_t
inlineDataAlignment
=
8
;
static
constexpr
size_t
offsetOfOutlineData
(
)
{
return
offsetof
(
WasmStructObject
outlineData_
)
;
}
static
constexpr
size_t
offsetOfInlineData
(
)
{
return
AlignBytes
(
sizeof
(
WasmStructObject
)
inlineDataAlignment
)
;
}
static
void
obj_trace
(
JSTracer
*
trc
JSObject
*
object
)
;
static
void
obj_finalize
(
JS
:
:
GCContext
*
gcx
JSObject
*
object
)
;
static
size_t
obj_moved
(
JSObject
*
obj
JSObject
*
old
)
;
void
storeVal
(
const
wasm
:
:
Val
&
val
uint32_t
fieldIndex
)
;
}
;
static_assert
(
(
WasmStructObject
:
:
offsetOfInlineData
(
)
%
8
)
=
=
0
)
;
const
size_t
WasmStructObject_MaxInlineBytes
=
(
(
JSObject
:
:
MAX_BYTE_SIZE
-
sizeof
(
WasmStructObject
)
)
/
16
)
*
16
;
const
size_t
WasmArrayObject_MaxInlineBytes
=
(
(
JSObject
:
:
MAX_BYTE_SIZE
-
sizeof
(
WasmArrayObject
)
)
/
16
)
*
16
;
static_assert
(
(
WasmStructObject_MaxInlineBytes
%
16
)
=
=
0
)
;
static_assert
(
(
WasmArrayObject_MaxInlineBytes
%
16
)
=
=
0
)
;
inline
constexpr
uint32_t
WasmArrayObject
:
:
maxInlineElementsForElemSize
(
uint32_t
elemSize
)
{
MOZ_RELEASE_ASSERT
(
elemSize
>
0
)
;
uint32_t
result
=
WasmArrayObject_MaxInlineBytes
;
static_assert
(
WasmArrayObject_MaxInlineBytes
%
gc
:
:
CellAlignBytes
=
=
0
)
;
result
-
=
sizeof
(
WasmArrayObject
:
:
DataHeader
)
;
result
/
=
elemSize
;
MOZ_RELEASE_ASSERT
(
calcStorageBytesChecked
(
elemSize
result
)
.
isValid
(
)
)
;
return
result
;
}
inline
void
WasmStructObject
:
:
getDataByteSizes
(
uint32_t
totalBytes
uint32_t
*
inlineBytes
uint32_t
*
outlineBytes
)
{
if
(
MOZ_UNLIKELY
(
totalBytes
>
WasmStructObject_MaxInlineBytes
)
)
{
*
inlineBytes
=
WasmStructObject_MaxInlineBytes
;
*
outlineBytes
=
totalBytes
-
WasmStructObject_MaxInlineBytes
;
}
else
{
*
inlineBytes
=
totalBytes
;
*
outlineBytes
=
0
;
}
}
inline
bool
WasmStructObject
:
:
requiresOutlineBytes
(
uint32_t
totalBytes
)
{
uint32_t
inlineBytes
outlineBytes
;
WasmStructObject
:
:
getDataByteSizes
(
totalBytes
&
inlineBytes
&
outlineBytes
)
;
return
outlineBytes
>
0
;
}
inline
void
WasmStructObject
:
:
fieldOffsetToAreaAndOffset
(
wasm
:
:
StorageType
fieldType
uint32_t
fieldOffset
bool
*
areaIsOutline
uint32_t
*
areaOffset
)
{
if
(
fieldOffset
<
WasmStructObject_MaxInlineBytes
)
{
*
areaIsOutline
=
false
;
*
areaOffset
=
fieldOffset
;
}
else
{
*
areaIsOutline
=
true
;
*
areaOffset
=
fieldOffset
-
WasmStructObject_MaxInlineBytes
;
}
MOZ_RELEASE_ASSERT
(
(
fieldOffset
<
WasmStructObject_MaxInlineBytes
)
=
=
(
(
fieldOffset
+
fieldType
.
size
(
)
-
1
)
<
WasmStructObject_MaxInlineBytes
)
)
;
}
inline
uint8_t
*
WasmStructObject
:
:
fieldOffsetToAddress
(
wasm
:
:
StorageType
fieldType
uint32_t
fieldOffset
)
{
bool
areaIsOutline
;
uint32_t
areaOffset
;
fieldOffsetToAreaAndOffset
(
fieldType
fieldOffset
&
areaIsOutline
&
areaOffset
)
;
return
(
areaIsOutline
?
outlineData_
:
inlineData
(
)
)
+
areaOffset
;
}
static_assert
(
WasmStructObject_MaxInlineBytes
<
=
wasm
:
:
NullPtrGuardSize
)
;
static_assert
(
sizeof
(
WasmArrayObject
)
<
=
wasm
:
:
NullPtrGuardSize
)
;
template
<
typename
T
>
class
MOZ_RAII
StableWasmArrayObjectElements
{
static
constexpr
size_t
MaxInlineElements
=
WasmArrayObject
:
:
maxInlineElementsForElemSize
(
sizeof
(
T
)
)
;
Rooted
<
WasmArrayObject
*
>
array_
;
T
*
elements_
;
mozilla
:
:
Maybe
<
mozilla
:
:
Vector
<
T
MaxInlineElements
SystemAllocPolicy
>
>
ownElements_
;
public
:
StableWasmArrayObjectElements
(
JSContext
*
cx
Handle
<
WasmArrayObject
*
>
array
)
:
array_
(
cx
array
)
elements_
(
nullptr
)
{
if
(
array
-
>
isDataInline
(
)
)
{
ownElements_
.
emplace
(
)
;
if
(
!
ownElements_
-
>
resize
(
array
-
>
numElements_
)
)
{
MOZ_CRASH
(
)
;
}
std
:
:
copy
(
array
-
>
inlineStorage
(
)
array
-
>
inlineStorage
(
)
+
array
-
>
numElements_
*
sizeof
(
T
)
ownElements_
-
>
begin
(
)
)
;
elements_
=
ownElements_
-
>
begin
(
)
;
}
else
{
elements_
=
reinterpret_cast
<
T
*
>
(
array
-
>
data_
)
;
}
}
T
*
elements
(
)
{
return
elements_
;
}
size_t
length
(
)
const
{
return
array_
-
>
numElements_
;
}
}
;
}
namespace
js
{
inline
bool
IsWasmGcObjectClass
(
const
JSClass
*
class_
)
{
return
class_
=
=
&
WasmArrayObject
:
:
class_
|
|
class_
=
=
&
WasmStructObject
:
:
classInline_
|
|
class_
=
=
&
WasmStructObject
:
:
classOutline_
;
}
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
WasmGcObject
>
(
)
const
{
return
js
:
:
IsWasmGcObjectClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
WasmStructObject
>
(
)
const
{
const
JSClass
*
class_
=
getClass
(
)
;
return
class_
=
=
&
js
:
:
WasmStructObject
:
:
classInline_
|
|
class_
=
=
&
js
:
:
WasmStructObject
:
:
classOutline_
;
}
#
endif
