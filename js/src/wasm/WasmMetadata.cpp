#
include
"
wasm
/
WasmMetadata
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
using
mozilla
:
:
CheckedInt
;
using
namespace
js
;
using
namespace
js
:
:
wasm
;
bool
CodeMetadata
:
:
addDefinedFunc
(
ModuleMetadata
*
moduleMeta
ValTypeVector
&
&
params
ValTypeVector
&
&
results
bool
declareForRef
Maybe
<
CacheableName
>
&
&
optionalExportedName
)
{
uint32_t
typeIndex
=
types
-
>
length
(
)
;
FuncType
funcType
(
std
:
:
move
(
params
)
std
:
:
move
(
results
)
)
;
if
(
!
types
-
>
addType
(
std
:
:
move
(
funcType
)
)
)
{
return
false
;
}
FuncDesc
funcDesc
=
FuncDesc
(
&
(
*
types
)
[
typeIndex
]
.
funcType
(
)
typeIndex
)
;
uint32_t
funcIndex
=
funcs
.
length
(
)
;
if
(
!
funcs
.
append
(
funcDesc
)
)
{
return
false
;
}
if
(
declareForRef
)
{
declareFuncExported
(
funcIndex
true
true
)
;
}
if
(
optionalExportedName
.
isSome
(
)
)
{
if
(
!
moduleMeta
-
>
exports
.
emplaceBack
(
std
:
:
move
(
optionalExportedName
.
ref
(
)
)
funcIndex
DefinitionKind
:
:
Function
)
)
{
return
false
;
}
}
return
true
;
}
bool
CodeMetadata
:
:
addImportedFunc
(
ModuleMetadata
*
moduleMeta
ValTypeVector
&
&
params
ValTypeVector
&
&
results
CacheableName
&
&
importModName
CacheableName
&
&
importFieldName
)
{
MOZ_ASSERT
(
numFuncImports
=
=
funcs
.
length
(
)
)
;
if
(
!
addDefinedFunc
(
moduleMeta
std
:
:
move
(
params
)
std
:
:
move
(
results
)
false
mozilla
:
:
Nothing
(
)
)
)
{
return
false
;
}
numFuncImports
+
+
;
return
moduleMeta
-
>
imports
.
emplaceBack
(
std
:
:
move
(
importModName
)
std
:
:
move
(
importFieldName
)
DefinitionKind
:
:
Function
)
;
}
static
const
uint32_t
MaxInstanceDataOffset
=
INT32_MAX
-
Instance
:
:
offsetOfData
(
)
;
[
[
nodiscard
]
]
static
bool
AllocateInstanceDataBytes
(
uint32_t
bytes
uint32_t
align
uint32_t
*
instanceDataLength
uint32_t
*
assignedOffset
)
{
MOZ_ASSERT
(
*
assignedOffset
=
=
UINT32_MAX
)
;
CheckedInt
<
uint32_t
>
newInstanceDataLength
(
*
instanceDataLength
)
;
newInstanceDataLength
+
=
ComputeByteAlignment
(
newInstanceDataLength
.
value
(
)
align
)
;
if
(
!
newInstanceDataLength
.
isValid
(
)
)
{
return
false
;
}
*
assignedOffset
=
newInstanceDataLength
.
value
(
)
;
newInstanceDataLength
+
=
bytes
;
if
(
!
newInstanceDataLength
.
isValid
(
)
)
{
return
false
;
}
if
(
newInstanceDataLength
.
value
(
)
>
MaxInstanceDataOffset
+
1
)
{
return
false
;
}
*
instanceDataLength
=
newInstanceDataLength
.
value
(
)
;
return
true
;
}
[
[
nodiscard
]
]
static
bool
AllocateInstanceDataBytesN
(
uint32_t
bytes
uint32_t
align
uint32_t
count
uint32_t
*
instanceDataLength
uint32_t
*
assignedOffset
)
{
MOZ_ASSERT
(
bytes
%
align
=
=
0
)
;
CheckedInt
<
uint32_t
>
totalBytes
=
bytes
;
totalBytes
*
=
count
;
if
(
!
totalBytes
.
isValid
(
)
)
{
return
false
;
}
return
AllocateInstanceDataBytes
(
totalBytes
.
value
(
)
align
instanceDataLength
assignedOffset
)
;
}
Maybe
<
uint32_t
>
CodeMetadata
:
:
doInstanceLayout
(
)
{
uint32_t
instanceDataLength
=
0
;
if
(
!
AllocateInstanceDataBytesN
(
sizeof
(
TypeDefInstanceData
)
alignof
(
TypeDefInstanceData
)
types
-
>
length
(
)
&
instanceDataLength
&
typeDefsOffsetStart
)
)
{
return
Nothing
(
)
;
}
if
(
!
AllocateInstanceDataBytesN
(
sizeof
(
FuncImportInstanceData
)
alignof
(
FuncImportInstanceData
)
numFuncImports
&
instanceDataLength
&
funcImportsOffsetStart
)
)
{
return
Nothing
(
)
;
}
if
(
!
AllocateInstanceDataBytesN
(
sizeof
(
MemoryInstanceData
)
alignof
(
MemoryInstanceData
)
memories
.
length
(
)
&
instanceDataLength
&
memoriesOffsetStart
)
)
{
return
Nothing
(
)
;
}
if
(
!
AllocateInstanceDataBytesN
(
sizeof
(
TableInstanceData
)
alignof
(
TableInstanceData
)
tables
.
length
(
)
&
instanceDataLength
&
tablesOffsetStart
)
)
{
return
Nothing
(
)
;
}
if
(
!
AllocateInstanceDataBytesN
(
sizeof
(
TagInstanceData
)
alignof
(
TagInstanceData
)
tags
.
length
(
)
&
instanceDataLength
&
tagsOffsetStart
)
)
{
return
Nothing
(
)
;
}
for
(
GlobalDesc
&
global
:
globals
)
{
if
(
global
.
isConstant
(
)
)
{
continue
;
}
uint32_t
width
=
global
.
isIndirect
(
)
?
sizeof
(
void
*
)
:
global
.
type
(
)
.
size
(
)
;
uint32_t
assignedOffset
=
UINT32_MAX
;
if
(
!
AllocateInstanceDataBytes
(
width
width
&
instanceDataLength
&
assignedOffset
)
)
{
return
Nothing
(
)
;
}
global
.
setOffset
(
assignedOffset
)
;
}
return
Some
(
instanceDataLength
)
;
}
