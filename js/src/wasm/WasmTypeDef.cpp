#
include
"
wasm
/
WasmTypeDef
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
Printf
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
wasm
/
WasmJS
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
using
mozilla
:
:
IsPowerOfTwo
;
using
ImmediateType
=
uint32_t
;
static
const
unsigned
sTotalBits
=
sizeof
(
ImmediateType
)
*
8
;
static
const
unsigned
sTagBits
=
1
;
static
const
unsigned
sReturnBit
=
1
;
static
const
unsigned
sLengthBits
=
4
;
static
const
unsigned
sTypeBits
=
3
;
static
const
unsigned
sMaxTypes
=
(
sTotalBits
-
sTagBits
-
sReturnBit
-
sLengthBits
)
/
sTypeBits
;
static
bool
IsImmediateValType
(
ValType
vt
)
{
switch
(
vt
.
kind
(
)
)
{
case
ValType
:
:
I32
:
case
ValType
:
:
I64
:
case
ValType
:
:
F32
:
case
ValType
:
:
F64
:
case
ValType
:
:
V128
:
return
true
;
case
ValType
:
:
Ref
:
switch
(
vt
.
refTypeKind
(
)
)
{
case
RefType
:
:
Func
:
case
RefType
:
:
Extern
:
case
RefType
:
:
Eq
:
return
true
;
case
RefType
:
:
TypeRef
:
return
false
;
}
break
;
}
MOZ_CRASH
(
"
bad
ValType
"
)
;
}
static
unsigned
EncodeImmediateValType
(
ValType
vt
)
{
static_assert
(
7
<
(
1
<
<
sTypeBits
)
"
fits
"
)
;
switch
(
vt
.
kind
(
)
)
{
case
ValType
:
:
I32
:
return
0
;
case
ValType
:
:
I64
:
return
1
;
case
ValType
:
:
F32
:
return
2
;
case
ValType
:
:
F64
:
return
3
;
case
ValType
:
:
V128
:
return
4
;
case
ValType
:
:
Ref
:
switch
(
vt
.
refTypeKind
(
)
)
{
case
RefType
:
:
Func
:
return
5
;
case
RefType
:
:
Extern
:
return
6
;
case
RefType
:
:
Eq
:
return
7
;
case
RefType
:
:
TypeRef
:
break
;
}
break
;
}
MOZ_CRASH
(
"
bad
ValType
"
)
;
}
static
bool
IsImmediateFuncType
(
const
FuncType
&
funcType
)
{
const
ValTypeVector
&
results
=
funcType
.
results
(
)
;
const
ValTypeVector
&
args
=
funcType
.
args
(
)
;
if
(
results
.
length
(
)
+
args
.
length
(
)
>
sMaxTypes
)
{
return
false
;
}
if
(
results
.
length
(
)
>
1
)
{
return
false
;
}
for
(
ValType
v
:
results
)
{
if
(
!
IsImmediateValType
(
v
)
)
{
return
false
;
}
}
for
(
ValType
v
:
args
)
{
if
(
!
IsImmediateValType
(
v
)
)
{
return
false
;
}
}
return
true
;
}
static
ImmediateType
LengthToBits
(
uint32_t
length
)
{
static_assert
(
sMaxTypes
<
=
(
(
1
<
<
sLengthBits
)
-
1
)
"
fits
"
)
;
MOZ_ASSERT
(
length
<
=
sMaxTypes
)
;
return
length
;
}
static
ImmediateType
EncodeImmediateFuncType
(
const
FuncType
&
funcType
)
{
ImmediateType
immediate
=
FuncType
:
:
ImmediateBit
;
uint32_t
shift
=
sTagBits
;
if
(
funcType
.
results
(
)
.
length
(
)
>
0
)
{
MOZ_ASSERT
(
funcType
.
results
(
)
.
length
(
)
=
=
1
)
;
immediate
|
=
(
1
<
<
shift
)
;
shift
+
=
sReturnBit
;
immediate
|
=
EncodeImmediateValType
(
funcType
.
results
(
)
[
0
]
)
<
<
shift
;
shift
+
=
sTypeBits
;
}
else
{
shift
+
=
sReturnBit
;
}
immediate
|
=
LengthToBits
(
funcType
.
args
(
)
.
length
(
)
)
<
<
shift
;
shift
+
=
sLengthBits
;
for
(
ValType
argType
:
funcType
.
args
(
)
)
{
immediate
|
=
EncodeImmediateValType
(
argType
)
<
<
shift
;
shift
+
=
sTypeBits
;
}
MOZ_ASSERT
(
shift
<
=
sTotalBits
)
;
return
immediate
;
}
void
FuncType
:
:
initImmediateTypeId
(
)
{
if
(
!
IsImmediateFuncType
(
*
this
)
)
{
immediateTypeId_
=
NO_IMMEDIATE_TYPE_ID
;
return
;
}
immediateTypeId_
=
EncodeImmediateFuncType
(
*
this
)
;
}
bool
FuncType
:
:
canHaveJitEntry
(
)
const
{
return
!
hasUnexposableArgOrRet
(
)
&
&
!
temporarilyUnsupportedReftypeForEntry
(
)
&
&
!
temporarilyUnsupportedResultCountForJitEntry
(
)
&
&
JitOptions
.
enableWasmJitEntry
;
}
bool
FuncType
:
:
canHaveJitExit
(
)
const
{
return
!
hasUnexposableArgOrRet
(
)
&
&
!
temporarilyUnsupportedReftypeForExit
(
)
&
&
!
hasInt64Arg
(
)
&
&
!
temporarilyUnsupportedResultCountForJitExit
(
)
&
&
JitOptions
.
enableWasmJitExit
;
}
size_t
FuncType
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
args_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
static
inline
CheckedInt32
RoundUpToAlignment
(
CheckedInt32
address
uint32_t
align
)
{
MOZ_ASSERT
(
IsPowerOfTwo
(
align
)
)
;
return
(
(
address
+
(
align
-
1
)
)
/
align
)
*
align
;
}
CheckedInt32
StructLayout
:
:
addField
(
FieldType
type
)
{
uint32_t
fieldSize
=
type
.
size
(
)
;
uint32_t
fieldAlignment
=
type
.
alignmentInStruct
(
)
;
MOZ_ASSERT
(
fieldSize
>
=
1
&
&
fieldSize
<
=
16
)
;
MOZ_ASSERT
(
(
fieldSize
&
(
fieldSize
-
1
)
)
=
=
0
)
;
MOZ_ASSERT
(
fieldAlignment
=
=
fieldSize
)
;
structAlignment
=
std
:
:
max
(
structAlignment
fieldAlignment
)
;
CheckedInt32
offset
=
RoundUpToAlignment
(
sizeSoFar
fieldAlignment
)
;
if
(
!
offset
.
isValid
(
)
)
{
return
offset
;
}
sizeSoFar
=
offset
+
fieldSize
;
if
(
!
sizeSoFar
.
isValid
(
)
)
{
return
sizeSoFar
;
}
MOZ_ASSERT
(
offset
/
16
=
=
(
offset
+
fieldSize
-
1
)
/
16
)
;
return
offset
;
}
CheckedInt32
StructLayout
:
:
close
(
)
{
return
RoundUpToAlignment
(
sizeSoFar
structAlignment
)
;
}
bool
StructType
:
:
init
(
)
{
StructLayout
layout
;
for
(
StructField
&
field
:
fields_
)
{
CheckedInt32
offset
=
layout
.
addField
(
field
.
type
)
;
if
(
!
offset
.
isValid
(
)
)
{
return
false
;
}
field
.
offset
=
offset
.
value
(
)
;
}
CheckedInt32
size
=
layout
.
close
(
)
;
if
(
!
size
.
isValid
(
)
)
{
return
false
;
}
size_
=
size
.
value
(
)
;
return
true
;
}
size_t
StructType
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
fields_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
ArrayType
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
0
;
}
size_t
TypeDef
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
switch
(
kind_
)
{
case
TypeDefKind
:
:
Struct
:
{
return
structType_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
case
TypeDefKind
:
:
Func
:
{
return
funcType_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
case
TypeDefKind
:
:
Array
:
{
return
arrayType_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
case
TypeDefKind
:
:
None
:
{
return
0
;
}
default
:
break
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
0
;
}
TypeResult
TypeContext
:
:
isRefEquivalent
(
RefType
first
RefType
second
TypeCache
*
cache
)
const
{
if
(
first
=
=
second
)
{
return
TypeResult
:
:
True
;
}
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
if
(
features_
.
functionReferences
)
{
if
(
first
.
isNullable
(
)
!
=
second
.
isNullable
(
)
)
{
return
TypeResult
:
:
False
;
}
if
(
!
first
.
isTypeRef
(
)
&
&
!
second
.
isTypeRef
(
)
&
&
first
.
kind
(
)
=
=
second
.
kind
(
)
)
{
return
TypeResult
:
:
True
;
}
if
(
first
.
isTypeRef
(
)
&
&
second
.
isTypeRef
(
)
)
{
return
isTypeDefEquivalent
(
first
.
typeDef
(
)
second
.
typeDef
(
)
cache
)
;
}
}
#
endif
return
TypeResult
:
:
False
;
}
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
TypeResult
TypeContext
:
:
isTypeDefEquivalent
(
const
TypeDef
*
first
const
TypeDef
*
second
TypeCache
*
cache
)
const
{
MOZ_ASSERT
(
features_
.
functionReferences
)
;
if
(
first
=
=
second
)
{
return
TypeResult
:
:
True
;
}
#
ifdef
ENABLE_WASM_GC
if
(
features_
.
gc
)
{
if
(
first
-
>
isStructType
(
)
&
&
second
-
>
isStructType
(
)
)
{
return
isStructEquivalent
(
first
second
cache
)
;
}
if
(
first
-
>
isArrayType
(
)
&
&
second
-
>
isArrayType
(
)
)
{
return
isArrayEquivalent
(
first
second
cache
)
;
}
}
#
endif
return
TypeResult
:
:
False
;
}
#
endif
#
ifdef
ENABLE_WASM_GC
TypeResult
TypeContext
:
:
isStructEquivalent
(
const
TypeDef
*
first
const
TypeDef
*
second
TypeCache
*
cache
)
const
{
if
(
cache
-
>
isEquivalent
(
first
second
)
)
{
return
TypeResult
:
:
True
;
}
const
StructType
&
firstStruct
=
first
-
>
structType
(
)
;
const
StructType
&
secondStruct
=
second
-
>
structType
(
)
;
if
(
firstStruct
.
fields_
.
length
(
)
!
=
secondStruct
.
fields_
.
length
(
)
)
{
return
TypeResult
:
:
False
;
}
if
(
!
cache
-
>
markEquivalent
(
first
second
)
)
{
return
TypeResult
:
:
OOM
;
}
for
(
uint32_t
i
=
0
;
i
<
secondStruct
.
fields_
.
length
(
)
;
i
+
+
)
{
TypeResult
result
=
isStructFieldEquivalent
(
firstStruct
.
fields_
[
i
]
secondStruct
.
fields_
[
i
]
cache
)
;
if
(
result
!
=
TypeResult
:
:
True
)
{
cache
-
>
unmarkEquivalent
(
first
second
)
;
return
result
;
}
}
return
TypeResult
:
:
True
;
}
TypeResult
TypeContext
:
:
isStructFieldEquivalent
(
const
StructField
first
const
StructField
second
TypeCache
*
cache
)
const
{
if
(
first
.
isMutable
!
=
second
.
isMutable
)
{
return
TypeResult
:
:
False
;
}
return
isEquivalent
(
first
.
type
second
.
type
cache
)
;
}
TypeResult
TypeContext
:
:
isArrayEquivalent
(
const
TypeDef
*
firstDef
const
TypeDef
*
secondDef
TypeCache
*
cache
)
const
{
if
(
cache
-
>
isEquivalent
(
firstDef
secondDef
)
)
{
return
TypeResult
:
:
True
;
}
const
ArrayType
&
firstArray
=
firstDef
-
>
arrayType
(
)
;
const
ArrayType
&
secondArray
=
secondDef
-
>
arrayType
(
)
;
if
(
!
cache
-
>
markEquivalent
(
firstDef
secondDef
)
)
{
return
TypeResult
:
:
OOM
;
}
TypeResult
result
=
isArrayElementEquivalent
(
firstArray
secondArray
cache
)
;
if
(
result
!
=
TypeResult
:
:
True
)
{
cache
-
>
unmarkEquivalent
(
firstDef
secondDef
)
;
}
return
result
;
}
TypeResult
TypeContext
:
:
isArrayElementEquivalent
(
const
ArrayType
&
first
const
ArrayType
&
second
TypeCache
*
cache
)
const
{
if
(
first
.
isMutable_
!
=
second
.
isMutable_
)
{
return
TypeResult
:
:
False
;
}
return
isEquivalent
(
first
.
elementType_
second
.
elementType_
cache
)
;
}
#
endif
TypeResult
TypeContext
:
:
isRefSubtypeOf
(
RefType
subType
RefType
superType
TypeCache
*
cache
)
const
{
if
(
subType
=
=
superType
)
{
return
TypeResult
:
:
True
;
}
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
if
(
features_
.
functionReferences
)
{
if
(
!
(
subType
.
isNullable
(
)
=
=
superType
.
isNullable
(
)
|
|
superType
.
isNullable
(
)
)
)
{
return
TypeResult
:
:
False
;
}
if
(
!
subType
.
isTypeRef
(
)
&
&
!
superType
.
isTypeRef
(
)
&
&
subType
.
kind
(
)
=
=
superType
.
kind
(
)
)
{
return
TypeResult
:
:
True
;
}
if
(
subType
.
isTypeRef
(
)
&
&
subType
.
typeDef
(
)
-
>
isStructType
(
)
&
&
superType
.
isEq
(
)
)
{
return
TypeResult
:
:
True
;
}
if
(
subType
.
isTypeRef
(
)
&
&
subType
.
typeDef
(
)
-
>
isArrayType
(
)
&
&
superType
.
isEq
(
)
)
{
return
TypeResult
:
:
True
;
}
if
(
subType
.
isTypeRef
(
)
&
&
subType
.
typeDef
(
)
-
>
isFuncType
(
)
&
&
superType
.
isFunc
(
)
)
{
return
TypeResult
:
:
True
;
}
if
(
subType
.
isTypeRef
(
)
&
&
superType
.
isTypeRef
(
)
)
{
return
isTypeDefSubtypeOf
(
subType
.
typeDef
(
)
superType
.
typeDef
(
)
cache
)
;
}
}
#
endif
return
TypeResult
:
:
False
;
}
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
TypeResult
TypeContext
:
:
isTypeDefSubtypeOf
(
const
TypeDef
*
subType
const
TypeDef
*
superType
TypeCache
*
cache
)
const
{
MOZ_ASSERT
(
features_
.
functionReferences
)
;
if
(
subType
=
=
superType
)
{
return
TypeResult
:
:
True
;
}
#
ifdef
ENABLE_WASM_GC
if
(
features_
.
gc
)
{
if
(
subType
-
>
isStructType
(
)
&
&
superType
-
>
isStructType
(
)
)
{
return
isStructSubtypeOf
(
subType
superType
cache
)
;
}
if
(
subType
-
>
isArrayType
(
)
&
&
superType
-
>
isArrayType
(
)
)
{
return
isArraySubtypeOf
(
subType
superType
cache
)
;
}
}
#
endif
return
TypeResult
:
:
False
;
}
#
endif
#
ifdef
ENABLE_WASM_GC
TypeResult
TypeContext
:
:
isStructSubtypeOf
(
const
TypeDef
*
subType
const
TypeDef
*
superType
TypeCache
*
cache
)
const
{
if
(
cache
-
>
isSubtypeOf
(
subType
superType
)
)
{
return
TypeResult
:
:
True
;
}
const
StructType
&
subStruct
=
subType
-
>
structType
(
)
;
const
StructType
&
superStruct
=
superType
-
>
structType
(
)
;
if
(
subStruct
.
fields_
.
length
(
)
<
superStruct
.
fields_
.
length
(
)
)
{
return
TypeResult
:
:
False
;
}
if
(
!
cache
-
>
markSubtypeOf
(
subType
superType
)
)
{
return
TypeResult
:
:
OOM
;
}
for
(
uint32_t
i
=
0
;
i
<
superStruct
.
fields_
.
length
(
)
;
i
+
+
)
{
TypeResult
result
=
isStructFieldSubtypeOf
(
subStruct
.
fields_
[
i
]
superStruct
.
fields_
[
i
]
cache
)
;
if
(
result
!
=
TypeResult
:
:
True
)
{
cache
-
>
unmarkSubtypeOf
(
subType
superType
)
;
return
result
;
}
}
return
TypeResult
:
:
True
;
}
TypeResult
TypeContext
:
:
isStructFieldSubtypeOf
(
const
StructField
subType
const
StructField
superType
TypeCache
*
cache
)
const
{
if
(
subType
.
isMutable
&
&
superType
.
isMutable
)
{
return
isEquivalent
(
subType
.
type
superType
.
type
cache
)
;
}
if
(
!
subType
.
isMutable
&
&
!
superType
.
isMutable
)
{
return
isSubtypeOf
(
subType
.
type
superType
.
type
cache
)
;
}
return
TypeResult
:
:
False
;
}
TypeResult
TypeContext
:
:
isArraySubtypeOf
(
const
TypeDef
*
subType
const
TypeDef
*
superType
TypeCache
*
cache
)
const
{
if
(
cache
-
>
isSubtypeOf
(
subType
superType
)
)
{
return
TypeResult
:
:
True
;
}
const
ArrayType
&
subArray
=
subType
-
>
arrayType
(
)
;
const
ArrayType
&
superArray
=
superType
-
>
arrayType
(
)
;
if
(
!
cache
-
>
markSubtypeOf
(
subType
superType
)
)
{
return
TypeResult
:
:
OOM
;
}
TypeResult
result
=
isArrayElementSubtypeOf
(
subArray
superArray
cache
)
;
if
(
result
!
=
TypeResult
:
:
True
)
{
cache
-
>
unmarkSubtypeOf
(
subType
superType
)
;
}
return
result
;
}
TypeResult
TypeContext
:
:
isArrayElementSubtypeOf
(
const
ArrayType
&
subType
const
ArrayType
&
superType
TypeCache
*
cache
)
const
{
if
(
subType
.
isMutable_
&
&
superType
.
isMutable_
)
{
return
isEquivalent
(
subType
.
elementType_
superType
.
elementType_
cache
)
;
}
if
(
!
subType
.
isMutable_
&
&
!
superType
.
isMutable_
)
{
return
isSubtypeOf
(
subType
.
elementType_
superType
.
elementType_
cache
)
;
}
return
TypeResult
:
:
False
;
}
#
endif
