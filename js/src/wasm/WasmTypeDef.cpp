#
include
"
wasm
/
WasmTypeDef
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
jit
/
JitOptions
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
Printf
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
threading
/
ExclusiveData
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
wasm
/
WasmJS
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
using
mozilla
:
:
IsPowerOfTwo
;
using
ImmediateType
=
uint32_t
;
static
const
unsigned
sTotalBits
=
sizeof
(
ImmediateType
)
*
8
;
static
const
unsigned
sTagBits
=
1
;
static
const
unsigned
sReturnBit
=
1
;
static
const
unsigned
sLengthBits
=
4
;
static
const
unsigned
sTypeBits
=
3
;
static
const
unsigned
sMaxTypes
=
(
sTotalBits
-
sTagBits
-
sReturnBit
-
sLengthBits
)
/
sTypeBits
;
static
bool
IsImmediateValType
(
ValType
vt
)
{
switch
(
vt
.
kind
(
)
)
{
case
ValType
:
:
I32
:
case
ValType
:
:
I64
:
case
ValType
:
:
F32
:
case
ValType
:
:
F64
:
case
ValType
:
:
V128
:
return
true
;
case
ValType
:
:
Ref
:
switch
(
vt
.
refTypeKind
(
)
)
{
case
RefType
:
:
Func
:
case
RefType
:
:
Extern
:
case
RefType
:
:
Eq
:
return
true
;
case
RefType
:
:
TypeRef
:
return
false
;
}
break
;
}
MOZ_CRASH
(
"
bad
ValType
"
)
;
}
static
unsigned
EncodeImmediateValType
(
ValType
vt
)
{
static_assert
(
7
<
(
1
<
<
sTypeBits
)
"
fits
"
)
;
switch
(
vt
.
kind
(
)
)
{
case
ValType
:
:
I32
:
return
0
;
case
ValType
:
:
I64
:
return
1
;
case
ValType
:
:
F32
:
return
2
;
case
ValType
:
:
F64
:
return
3
;
case
ValType
:
:
V128
:
return
4
;
case
ValType
:
:
Ref
:
switch
(
vt
.
refTypeKind
(
)
)
{
case
RefType
:
:
Func
:
return
5
;
case
RefType
:
:
Extern
:
return
6
;
case
RefType
:
:
Eq
:
return
7
;
case
RefType
:
:
TypeRef
:
break
;
}
break
;
}
MOZ_CRASH
(
"
bad
ValType
"
)
;
}
static
bool
IsImmediateFuncType
(
const
FuncType
&
funcType
)
{
const
ValTypeVector
&
results
=
funcType
.
results
(
)
;
const
ValTypeVector
&
args
=
funcType
.
args
(
)
;
if
(
results
.
length
(
)
+
args
.
length
(
)
>
sMaxTypes
)
{
return
false
;
}
if
(
results
.
length
(
)
>
1
)
{
return
false
;
}
for
(
ValType
v
:
results
)
{
if
(
!
IsImmediateValType
(
v
)
)
{
return
false
;
}
}
for
(
ValType
v
:
args
)
{
if
(
!
IsImmediateValType
(
v
)
)
{
return
false
;
}
}
return
true
;
}
static
ImmediateType
LengthToBits
(
uint32_t
length
)
{
static_assert
(
sMaxTypes
<
=
(
(
1
<
<
sLengthBits
)
-
1
)
"
fits
"
)
;
MOZ_ASSERT
(
length
<
=
sMaxTypes
)
;
return
length
;
}
static
ImmediateType
EncodeImmediateFuncType
(
const
FuncType
&
funcType
)
{
ImmediateType
immediate
=
FuncType
:
:
ImmediateBit
;
uint32_t
shift
=
sTagBits
;
if
(
funcType
.
results
(
)
.
length
(
)
>
0
)
{
MOZ_ASSERT
(
funcType
.
results
(
)
.
length
(
)
=
=
1
)
;
immediate
|
=
(
1
<
<
shift
)
;
shift
+
=
sReturnBit
;
immediate
|
=
EncodeImmediateValType
(
funcType
.
results
(
)
[
0
]
)
<
<
shift
;
shift
+
=
sTypeBits
;
}
else
{
shift
+
=
sReturnBit
;
}
immediate
|
=
LengthToBits
(
funcType
.
args
(
)
.
length
(
)
)
<
<
shift
;
shift
+
=
sLengthBits
;
for
(
ValType
argType
:
funcType
.
args
(
)
)
{
immediate
|
=
EncodeImmediateValType
(
argType
)
<
<
shift
;
shift
+
=
sTypeBits
;
}
MOZ_ASSERT
(
shift
<
=
sTotalBits
)
;
return
immediate
;
}
void
FuncType
:
:
initImmediateTypeId
(
)
{
if
(
!
IsImmediateFuncType
(
*
this
)
)
{
immediateTypeId_
=
NO_IMMEDIATE_TYPE_ID
;
return
;
}
immediateTypeId_
=
EncodeImmediateFuncType
(
*
this
)
;
}
bool
FuncType
:
:
canHaveJitEntry
(
)
const
{
return
!
hasUnexposableArgOrRet
(
)
&
&
!
temporarilyUnsupportedReftypeForEntry
(
)
&
&
!
temporarilyUnsupportedResultCountForJitEntry
(
)
&
&
JitOptions
.
enableWasmJitEntry
;
}
bool
FuncType
:
:
canHaveJitExit
(
)
const
{
return
!
hasUnexposableArgOrRet
(
)
&
&
!
temporarilyUnsupportedReftypeForExit
(
)
&
&
!
hasInt64Arg
(
)
&
&
!
temporarilyUnsupportedResultCountForJitExit
(
)
&
&
JitOptions
.
enableWasmJitExit
;
}
size_t
FuncType
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
args_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
static
inline
CheckedInt32
RoundUpToAlignment
(
CheckedInt32
address
uint32_t
align
)
{
MOZ_ASSERT
(
IsPowerOfTwo
(
align
)
)
;
return
(
(
address
+
(
align
-
1
)
)
/
align
)
*
align
;
}
CheckedInt32
StructLayout
:
:
addField
(
FieldType
type
)
{
uint32_t
fieldSize
=
type
.
size
(
)
;
uint32_t
fieldAlignment
=
type
.
alignmentInStruct
(
)
;
MOZ_ASSERT
(
fieldSize
>
=
1
&
&
fieldSize
<
=
16
)
;
MOZ_ASSERT
(
(
fieldSize
&
(
fieldSize
-
1
)
)
=
=
0
)
;
MOZ_ASSERT
(
fieldAlignment
=
=
fieldSize
)
;
structAlignment
=
std
:
:
max
(
structAlignment
fieldAlignment
)
;
CheckedInt32
offset
=
RoundUpToAlignment
(
sizeSoFar
fieldAlignment
)
;
if
(
!
offset
.
isValid
(
)
)
{
return
offset
;
}
sizeSoFar
=
offset
+
fieldSize
;
if
(
!
sizeSoFar
.
isValid
(
)
)
{
return
sizeSoFar
;
}
MOZ_ASSERT
(
offset
/
16
=
=
(
offset
+
fieldSize
-
1
)
/
16
)
;
return
offset
;
}
CheckedInt32
StructLayout
:
:
close
(
)
{
return
RoundUpToAlignment
(
sizeSoFar
structAlignment
)
;
}
bool
StructType
:
:
init
(
)
{
StructLayout
layout
;
for
(
StructField
&
field
:
fields_
)
{
CheckedInt32
offset
=
layout
.
addField
(
field
.
type
)
;
if
(
!
offset
.
isValid
(
)
)
{
return
false
;
}
field
.
offset
=
offset
.
value
(
)
;
}
CheckedInt32
size
=
layout
.
close
(
)
;
if
(
!
size
.
isValid
(
)
)
{
return
false
;
}
size_
=
size
.
value
(
)
;
return
true
;
}
size_t
StructType
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
fields_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
ArrayType
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
return
0
;
}
size_t
TypeDef
:
:
sizeOfExcludingThis
(
MallocSizeOf
mallocSizeOf
)
const
{
switch
(
kind_
)
{
case
TypeDefKind
:
:
Struct
:
{
return
structType_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
case
TypeDefKind
:
:
Func
:
{
return
funcType_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
case
TypeDefKind
:
:
Array
:
{
return
arrayType_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
case
TypeDefKind
:
:
None
:
{
return
0
;
}
default
:
break
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
0
;
}
struct
RecGroupHashPolicy
{
using
Lookup
=
const
SharedRecGroup
&
;
static
HashNumber
hash
(
Lookup
lookup
)
{
return
lookup
-
>
hash
(
)
;
}
static
bool
match
(
const
SharedRecGroup
&
lhs
Lookup
rhs
)
{
return
RecGroup
:
:
matches
(
*
rhs
*
lhs
)
;
}
}
;
class
TypeIdSet
{
using
Set
=
HashSet
<
SharedRecGroup
RecGroupHashPolicy
SystemAllocPolicy
>
;
Set
set_
;
public
:
~
TypeIdSet
(
)
{
MOZ_ASSERT_IF
(
!
JSRuntime
:
:
hasLiveRuntimes
(
)
set_
.
empty
(
)
)
;
}
SharedRecGroup
insert
(
SharedRecGroup
recGroup
)
{
Set
:
:
AddPtr
p
=
set_
.
lookupForAdd
(
recGroup
)
;
if
(
p
)
{
return
*
p
;
}
if
(
!
set_
.
add
(
p
recGroup
)
)
{
return
nullptr
;
}
return
recGroup
;
}
void
clearRecGroup
(
SharedRecGroup
*
recGroupCell
)
{
if
(
Set
:
:
Ptr
p
=
set_
.
lookup
(
*
recGroupCell
)
)
{
*
recGroupCell
=
nullptr
;
if
(
(
*
p
)
-
>
hasOneRef
(
)
)
{
set_
.
remove
(
p
)
;
}
}
else
{
*
recGroupCell
=
nullptr
;
}
}
}
;
ExclusiveData
<
TypeIdSet
>
typeIdSet
(
mutexid
:
:
WasmTypeIdSet
)
;
SharedRecGroup
TypeContext
:
:
canonicalizeGroup
(
SharedRecGroup
recGroup
)
{
ExclusiveData
<
TypeIdSet
>
:
:
Guard
locked
=
typeIdSet
.
lock
(
)
;
return
locked
-
>
insert
(
recGroup
)
;
}
TypeContext
:
:
~
TypeContext
(
)
{
ExclusiveData
<
TypeIdSet
>
:
:
Guard
locked
=
typeIdSet
.
lock
(
)
;
for
(
int32_t
groupIndex
=
recGroups_
.
length
(
)
-
1
;
groupIndex
>
=
0
;
groupIndex
-
-
)
{
locked
-
>
clearRecGroup
(
&
recGroups_
[
groupIndex
]
)
;
}
}
