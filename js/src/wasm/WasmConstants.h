#
ifndef
wasm_constants_h
#
define
wasm_constants_h
#
include
<
stdint
.
h
>
#
include
"
wasm
/
WasmIntrinsicGenerated
.
h
"
namespace
js
{
namespace
wasm
{
static
const
uint32_t
MagicNumber
=
0x6d736100
;
static
const
uint32_t
EncodingVersion
=
0x01
;
enum
class
SectionId
{
Custom
=
0
Type
=
1
Import
=
2
Function
=
3
Table
=
4
Memory
=
5
Global
=
6
Export
=
7
Start
=
8
Elem
=
9
Code
=
10
Data
=
11
DataCount
=
12
#
ifdef
ENABLE_WASM_EXCEPTIONS
Tag
=
13
#
endif
}
;
static
const
uint8_t
SLEB128SignMask
=
0xc0
;
static
const
uint8_t
SLEB128SignBit
=
0x40
;
enum
class
TypeCode
{
I32
=
0x7f
I64
=
0x7e
F32
=
0x7d
F64
=
0x7c
V128
=
0x7b
I8
=
0x7a
I16
=
0x79
FuncRef
=
0x70
ExternRef
=
0x6f
EqRef
=
0x6d
NullableRef
=
0x6c
Ref
=
0x6b
RttWithDepth
=
0x69
Rtt
=
0x68
Func
=
0x60
Struct
=
0x5f
Array
=
0x5e
BlockVoid
=
0x40
Limit
=
0x80
}
;
static
constexpr
TypeCode
LowestPrimitiveTypeCode
=
TypeCode
:
:
I16
;
static
constexpr
TypeCode
AbstractReferenceTypeCode
=
TypeCode
:
:
ExternRef
;
static
constexpr
TypeCode
AbstractReferenceTypeIndexCode
=
TypeCode
:
:
Ref
;
static
constexpr
TypeCode
AbstractRttCode
=
TypeCode
:
:
Rtt
;
enum
class
TypeIdDescKind
{
None
Immediate
Global
}
;
enum
class
Trap
{
Unreachable
IntegerOverflow
InvalidConversionToInteger
IntegerDivideByZero
OutOfBounds
UnalignedAccess
IndirectCallToNull
IndirectCallBadSig
NullPointerDereference
BadCast
StackOverflow
CheckInterrupt
ThrowReported
Limit
}
;
static
const
intptr_t
NULLREF_VALUE
=
intptr_t
(
(
void
*
)
nullptr
)
;
enum
class
DefinitionKind
{
Function
=
0x00
Table
=
0x01
Memory
=
0x02
Global
=
0x03
#
ifdef
ENABLE_WASM_EXCEPTIONS
Tag
=
0x04
#
endif
}
;
enum
class
GlobalTypeImmediate
{
IsMutable
=
0x1
AllowedMask
=
0x1
}
;
enum
class
LimitsFlags
{
Default
=
0x0
HasMaximum
=
0x1
IsShared
=
0x2
IsI64
=
0x4
}
;
enum
class
LimitsMask
{
Table
=
uint8_t
(
LimitsFlags
:
:
HasMaximum
)
#
ifdef
ENABLE_WASM_MEMORY64
Memory
=
uint8_t
(
LimitsFlags
:
:
HasMaximum
)
|
uint8_t
(
LimitsFlags
:
:
IsShared
)
|
uint8_t
(
LimitsFlags
:
:
IsI64
)
#
else
Memory
=
uint8_t
(
LimitsFlags
:
:
HasMaximum
)
|
uint8_t
(
LimitsFlags
:
:
IsShared
)
#
endif
}
;
enum
class
DataSegmentKind
{
Active
=
0x00
Passive
=
0x01
ActiveWithMemoryIndex
=
0x02
}
;
enum
class
ElemSegmentKind
:
uint32_t
{
Active
=
0x0
Passive
=
0x1
ActiveWithTableIndex
=
0x2
Declared
=
0x3
}
;
enum
class
ElemSegmentPayload
:
uint32_t
{
ExternIndex
=
0x0
ElemExpression
=
0x4
}
;
#
ifdef
ENABLE_WASM_EXCEPTIONS
enum
class
TagKind
{
Exception
=
0x0
}
;
#
endif
enum
class
Op
{
Unreachable
=
0x00
Nop
=
0x01
Block
=
0x02
Loop
=
0x03
If
=
0x04
Else
=
0x05
#
ifdef
ENABLE_WASM_EXCEPTIONS
Try
=
0x06
Catch
=
0x07
Throw
=
0x08
Rethrow
=
0x09
#
endif
End
=
0x0b
Br
=
0x0c
BrIf
=
0x0d
BrTable
=
0x0e
Return
=
0x0f
Call
=
0x10
CallIndirect
=
0x11
#
ifdef
ENABLE_WASM_EXCEPTIONS
Delegate
=
0x18
CatchAll
=
0x19
#
endif
Drop
=
0x1a
SelectNumeric
=
0x1b
SelectTyped
=
0x1c
GetLocal
=
0x20
SetLocal
=
0x21
TeeLocal
=
0x22
GetGlobal
=
0x23
SetGlobal
=
0x24
TableGet
=
0x25
TableSet
=
0x26
I32Load
=
0x28
I64Load
=
0x29
F32Load
=
0x2a
F64Load
=
0x2b
I32Load8S
=
0x2c
I32Load8U
=
0x2d
I32Load16S
=
0x2e
I32Load16U
=
0x2f
I64Load8S
=
0x30
I64Load8U
=
0x31
I64Load16S
=
0x32
I64Load16U
=
0x33
I64Load32S
=
0x34
I64Load32U
=
0x35
I32Store
=
0x36
I64Store
=
0x37
F32Store
=
0x38
F64Store
=
0x39
I32Store8
=
0x3a
I32Store16
=
0x3b
I64Store8
=
0x3c
I64Store16
=
0x3d
I64Store32
=
0x3e
MemorySize
=
0x3f
MemoryGrow
=
0x40
I32Const
=
0x41
I64Const
=
0x42
F32Const
=
0x43
F64Const
=
0x44
I32Eqz
=
0x45
I32Eq
=
0x46
I32Ne
=
0x47
I32LtS
=
0x48
I32LtU
=
0x49
I32GtS
=
0x4a
I32GtU
=
0x4b
I32LeS
=
0x4c
I32LeU
=
0x4d
I32GeS
=
0x4e
I32GeU
=
0x4f
I64Eqz
=
0x50
I64Eq
=
0x51
I64Ne
=
0x52
I64LtS
=
0x53
I64LtU
=
0x54
I64GtS
=
0x55
I64GtU
=
0x56
I64LeS
=
0x57
I64LeU
=
0x58
I64GeS
=
0x59
I64GeU
=
0x5a
F32Eq
=
0x5b
F32Ne
=
0x5c
F32Lt
=
0x5d
F32Gt
=
0x5e
F32Le
=
0x5f
F32Ge
=
0x60
F64Eq
=
0x61
F64Ne
=
0x62
F64Lt
=
0x63
F64Gt
=
0x64
F64Le
=
0x65
F64Ge
=
0x66
I32Clz
=
0x67
I32Ctz
=
0x68
I32Popcnt
=
0x69
I32Add
=
0x6a
I32Sub
=
0x6b
I32Mul
=
0x6c
I32DivS
=
0x6d
I32DivU
=
0x6e
I32RemS
=
0x6f
I32RemU
=
0x70
I32And
=
0x71
I32Or
=
0x72
I32Xor
=
0x73
I32Shl
=
0x74
I32ShrS
=
0x75
I32ShrU
=
0x76
I32Rotl
=
0x77
I32Rotr
=
0x78
I64Clz
=
0x79
I64Ctz
=
0x7a
I64Popcnt
=
0x7b
I64Add
=
0x7c
I64Sub
=
0x7d
I64Mul
=
0x7e
I64DivS
=
0x7f
I64DivU
=
0x80
I64RemS
=
0x81
I64RemU
=
0x82
I64And
=
0x83
I64Or
=
0x84
I64Xor
=
0x85
I64Shl
=
0x86
I64ShrS
=
0x87
I64ShrU
=
0x88
I64Rotl
=
0x89
I64Rotr
=
0x8a
F32Abs
=
0x8b
F32Neg
=
0x8c
F32Ceil
=
0x8d
F32Floor
=
0x8e
F32Trunc
=
0x8f
F32Nearest
=
0x90
F32Sqrt
=
0x91
F32Add
=
0x92
F32Sub
=
0x93
F32Mul
=
0x94
F32Div
=
0x95
F32Min
=
0x96
F32Max
=
0x97
F32CopySign
=
0x98
F64Abs
=
0x99
F64Neg
=
0x9a
F64Ceil
=
0x9b
F64Floor
=
0x9c
F64Trunc
=
0x9d
F64Nearest
=
0x9e
F64Sqrt
=
0x9f
F64Add
=
0xa0
F64Sub
=
0xa1
F64Mul
=
0xa2
F64Div
=
0xa3
F64Min
=
0xa4
F64Max
=
0xa5
F64CopySign
=
0xa6
I32WrapI64
=
0xa7
I32TruncSF32
=
0xa8
I32TruncUF32
=
0xa9
I32TruncSF64
=
0xaa
I32TruncUF64
=
0xab
I64ExtendSI32
=
0xac
I64ExtendUI32
=
0xad
I64TruncSF32
=
0xae
I64TruncUF32
=
0xaf
I64TruncSF64
=
0xb0
I64TruncUF64
=
0xb1
F32ConvertSI32
=
0xb2
F32ConvertUI32
=
0xb3
F32ConvertSI64
=
0xb4
F32ConvertUI64
=
0xb5
F32DemoteF64
=
0xb6
F64ConvertSI32
=
0xb7
F64ConvertUI32
=
0xb8
F64ConvertSI64
=
0xb9
F64ConvertUI64
=
0xba
F64PromoteF32
=
0xbb
I32ReinterpretF32
=
0xbc
I64ReinterpretF64
=
0xbd
F32ReinterpretI32
=
0xbe
F64ReinterpretI64
=
0xbf
I32Extend8S
=
0xc0
I32Extend16S
=
0xc1
I64Extend8S
=
0xc2
I64Extend16S
=
0xc3
I64Extend32S
=
0xc4
RefNull
=
0xd0
RefIsNull
=
0xd1
RefFunc
=
0xd2
RefAsNonNull
=
0xd3
BrOnNull
=
0xd4
RefEq
=
0xd5
FirstPrefix
=
0xfa
IntrinsicPrefix
=
0xfa
GcPrefix
=
0xfb
MiscPrefix
=
0xfc
SimdPrefix
=
0xfd
ThreadPrefix
=
0xfe
MozPrefix
=
0xff
Limit
=
0x100
}
;
inline
bool
IsPrefixByte
(
uint8_t
b
)
{
return
b
>
=
uint8_t
(
Op
:
:
FirstPrefix
)
;
}
enum
class
GcOp
{
StructNewWithRtt
=
0x1
StructNewDefaultWithRtt
=
0x2
StructGet
=
0x03
StructGetS
=
0x04
StructGetU
=
0x05
StructSet
=
0x06
ArrayNewWithRtt
=
0x11
ArrayNewDefaultWithRtt
=
0x12
ArrayGet
=
0x13
ArrayGetS
=
0x14
ArrayGetU
=
0x15
ArraySet
=
0x16
ArrayLen
=
0x17
RttCanon
=
0x30
RttSub
=
0x31
RefTest
=
0x40
RefCast
=
0x41
BrOnCast
=
0x42
Limit
}
;
enum
class
SimdOp
{
V128Load
=
0x00
I16x8LoadS8x8
=
0x01
I16x8LoadU8x8
=
0x02
I32x4LoadS16x4
=
0x03
I32x4LoadU16x4
=
0x04
I64x2LoadS32x2
=
0x05
I64x2LoadU32x2
=
0x06
V8x16LoadSplat
=
0x07
V16x8LoadSplat
=
0x08
V32x4LoadSplat
=
0x09
V64x2LoadSplat
=
0x0a
V128Store
=
0x0b
V128Const
=
0x0c
V8x16Shuffle
=
0x0d
V8x16Swizzle
=
0x0e
I8x16Splat
=
0x0f
I16x8Splat
=
0x10
I32x4Splat
=
0x11
I64x2Splat
=
0x12
F32x4Splat
=
0x13
F64x2Splat
=
0x14
I8x16ExtractLaneS
=
0x15
I8x16ExtractLaneU
=
0x16
I8x16ReplaceLane
=
0x17
I16x8ExtractLaneS
=
0x18
I16x8ExtractLaneU
=
0x19
I16x8ReplaceLane
=
0x1a
I32x4ExtractLane
=
0x1b
I32x4ReplaceLane
=
0x1c
I64x2ExtractLane
=
0x1d
I64x2ReplaceLane
=
0x1e
F32x4ExtractLane
=
0x1f
F32x4ReplaceLane
=
0x20
F64x2ExtractLane
=
0x21
F64x2ReplaceLane
=
0x22
I8x16Eq
=
0x23
I8x16Ne
=
0x24
I8x16LtS
=
0x25
I8x16LtU
=
0x26
I8x16GtS
=
0x27
I8x16GtU
=
0x28
I8x16LeS
=
0x29
I8x16LeU
=
0x2a
I8x16GeS
=
0x2b
I8x16GeU
=
0x2c
I16x8Eq
=
0x2d
I16x8Ne
=
0x2e
I16x8LtS
=
0x2f
I16x8LtU
=
0x30
I16x8GtS
=
0x31
I16x8GtU
=
0x32
I16x8LeS
=
0x33
I16x8LeU
=
0x34
I16x8GeS
=
0x35
I16x8GeU
=
0x36
I32x4Eq
=
0x37
I32x4Ne
=
0x38
I32x4LtS
=
0x39
I32x4LtU
=
0x3a
I32x4GtS
=
0x3b
I32x4GtU
=
0x3c
I32x4LeS
=
0x3d
I32x4LeU
=
0x3e
I32x4GeS
=
0x3f
I32x4GeU
=
0x40
F32x4Eq
=
0x41
F32x4Ne
=
0x42
F32x4Lt
=
0x43
F32x4Gt
=
0x44
F32x4Le
=
0x45
F32x4Ge
=
0x46
F64x2Eq
=
0x47
F64x2Ne
=
0x48
F64x2Lt
=
0x49
F64x2Gt
=
0x4a
F64x2Le
=
0x4b
F64x2Ge
=
0x4c
V128Not
=
0x4d
V128And
=
0x4e
V128AndNot
=
0x4f
V128Or
=
0x50
V128Xor
=
0x51
V128Bitselect
=
0x52
V128AnyTrue
=
0x53
V128Load8Lane
=
0x54
V128Load16Lane
=
0x55
V128Load32Lane
=
0x56
V128Load64Lane
=
0x57
V128Store8Lane
=
0x58
V128Store16Lane
=
0x59
V128Store32Lane
=
0x5a
V128Store64Lane
=
0x5b
V128Load32Zero
=
0x5c
V128Load64Zero
=
0x5d
F32x4DemoteF64x2Zero
=
0x5e
F64x2PromoteLowF32x4
=
0x5f
I8x16Abs
=
0x60
I8x16Neg
=
0x61
I8x16Popcnt
=
0x62
I8x16AllTrue
=
0x63
I8x16Bitmask
=
0x64
I8x16NarrowSI16x8
=
0x65
I8x16NarrowUI16x8
=
0x66
F32x4Ceil
=
0x67
F32x4Floor
=
0x68
F32x4Trunc
=
0x69
F32x4Nearest
=
0x6a
I8x16Shl
=
0x6b
I8x16ShrS
=
0x6c
I8x16ShrU
=
0x6d
I8x16Add
=
0x6e
I8x16AddSaturateS
=
0x6f
I8x16AddSaturateU
=
0x70
I8x16Sub
=
0x71
I8x16SubSaturateS
=
0x72
I8x16SubSaturateU
=
0x73
F64x2Ceil
=
0x74
F64x2Floor
=
0x75
I8x16MinS
=
0x76
I8x16MinU
=
0x77
I8x16MaxS
=
0x78
I8x16MaxU
=
0x79
F64x2Trunc
=
0x7a
I8x16AvgrU
=
0x7b
I16x8ExtAddPairwiseI8x16S
=
0x7c
I16x8ExtAddPairwiseI8x16U
=
0x7d
I32x4ExtAddPairwiseI16x8S
=
0x7e
I32x4ExtAddPairwiseI16x8U
=
0x7f
I16x8Abs
=
0x80
I16x8Neg
=
0x81
I16x8Q15MulrSatS
=
0x82
I16x8AllTrue
=
0x83
I16x8Bitmask
=
0x84
I16x8NarrowSI32x4
=
0x85
I16x8NarrowUI32x4
=
0x86
I16x8WidenLowSI8x16
=
0x87
I16x8WidenHighSI8x16
=
0x88
I16x8WidenLowUI8x16
=
0x89
I16x8WidenHighUI8x16
=
0x8a
I16x8Shl
=
0x8b
I16x8ShrS
=
0x8c
I16x8ShrU
=
0x8d
I16x8Add
=
0x8e
I16x8AddSaturateS
=
0x8f
I16x8AddSaturateU
=
0x90
I16x8Sub
=
0x91
I16x8SubSaturateS
=
0x92
I16x8SubSaturateU
=
0x93
F64x2Nearest
=
0x94
I16x8Mul
=
0x95
I16x8MinS
=
0x96
I16x8MinU
=
0x97
I16x8MaxS
=
0x98
I16x8MaxU
=
0x99
I16x8AvgrU
=
0x9b
I16x8ExtMulLowSI8x16
=
0x9c
I16x8ExtMulHighSI8x16
=
0x9d
I16x8ExtMulLowUI8x16
=
0x9e
I16x8ExtMulHighUI8x16
=
0x9f
I32x4Abs
=
0xa0
I32x4Neg
=
0xa1
I32x4AllTrue
=
0xa3
I32x4Bitmask
=
0xa4
I32x4WidenLowSI16x8
=
0xa7
I32x4WidenHighSI16x8
=
0xa8
I32x4WidenLowUI16x8
=
0xa9
I32x4WidenHighUI16x8
=
0xaa
I32x4Shl
=
0xab
I32x4ShrS
=
0xac
I32x4ShrU
=
0xad
I32x4Add
=
0xae
F32x4RelaxedFma
=
0xaf
F32x4RelaxedFms
=
0xb0
I32x4Sub
=
0xb1
I32x4Mul
=
0xb5
I32x4MinS
=
0xb6
I32x4MinU
=
0xb7
I32x4MaxS
=
0xb8
I32x4MaxU
=
0xb9
I32x4DotSI16x8
=
0xba
I32x4ExtMulLowSI16x8
=
0xbc
I32x4ExtMulHighSI16x8
=
0xbd
I32x4ExtMulLowUI16x8
=
0xbe
I32x4ExtMulHighUI16x8
=
0xbf
I64x2Abs
=
0xc0
I64x2Neg
=
0xc1
I64x2AllTrue
=
0xc3
I64x2Bitmask
=
0xc4
I64x2WidenLowSI32x4
=
0xc7
I64x2WidenHighSI32x4
=
0xc8
I64x2WidenLowUI32x4
=
0xc9
I64x2WidenHighUI32x4
=
0xca
I64x2Shl
=
0xcb
I64x2ShrS
=
0xcc
I64x2ShrU
=
0xcd
I64x2Add
=
0xce
F64x2RelaxedFma
=
0xcf
F64x2RelaxedFms
=
0xd0
I64x2Sub
=
0xd1
I64x2Mul
=
0xd5
I64x2Eq
=
0xd6
I64x2Ne
=
0xd7
I64x2LtS
=
0xd8
I64x2GtS
=
0xd9
I64x2LeS
=
0xda
I64x2GeS
=
0xdb
I64x2ExtMulLowSI32x4
=
0xdc
I64x2ExtMulHighSI32x4
=
0xdd
I64x2ExtMulLowUI32x4
=
0xde
I64x2ExtMulHighUI32x4
=
0xdf
F32x4Abs
=
0xe0
F32x4Neg
=
0xe1
F32x4Sqrt
=
0xe3
F32x4Add
=
0xe4
F32x4Sub
=
0xe5
F32x4Mul
=
0xe6
F32x4Div
=
0xe7
F32x4Min
=
0xe8
F32x4Max
=
0xe9
F32x4PMin
=
0xea
F32x4PMax
=
0xeb
F64x2Abs
=
0xec
F64x2Neg
=
0xed
F64x2Sqrt
=
0xef
F64x2Add
=
0xf0
F64x2Sub
=
0xf1
F64x2Mul
=
0xf2
F64x2Div
=
0xf3
F64x2Min
=
0xf4
F64x2Max
=
0xf5
F64x2PMin
=
0xf6
F64x2PMax
=
0xf7
I32x4TruncSSatF32x4
=
0xf8
I32x4TruncUSatF32x4
=
0xf9
F32x4ConvertSI32x4
=
0xfa
F32x4ConvertUI32x4
=
0xfb
I32x4TruncSatF64x2SZero
=
0xfc
I32x4TruncSatF64x2UZero
=
0xfd
F64x2ConvertLowI32x4S
=
0xfe
F64x2ConvertLowI32x4U
=
0xff
#
ifdef
ENABLE_WASM_SIMD_WORMHOLE
MozWHSELFTEST
=
0x200
MozWHPMADDUBSW
=
0x201
MozWHPMADDWD
=
0x202
#
endif
Limit
}
;
enum
class
MiscOp
{
I32TruncSSatF32
=
0x00
I32TruncUSatF32
=
0x01
I32TruncSSatF64
=
0x02
I32TruncUSatF64
=
0x03
I64TruncSSatF32
=
0x04
I64TruncUSatF32
=
0x05
I64TruncSSatF64
=
0x06
I64TruncUSatF64
=
0x07
MemInit
=
0x08
DataDrop
=
0x09
MemCopy
=
0x0a
MemFill
=
0x0b
TableInit
=
0x0c
ElemDrop
=
0x0d
TableCopy
=
0x0e
TableGrow
=
0x0f
TableSize
=
0x10
TableFill
=
0x11
Limit
}
;
enum
class
ThreadOp
{
Wake
=
0x00
I32Wait
=
0x01
I64Wait
=
0x02
Fence
=
0x03
I32AtomicLoad
=
0x10
I64AtomicLoad
=
0x11
I32AtomicLoad8U
=
0x12
I32AtomicLoad16U
=
0x13
I64AtomicLoad8U
=
0x14
I64AtomicLoad16U
=
0x15
I64AtomicLoad32U
=
0x16
I32AtomicStore
=
0x17
I64AtomicStore
=
0x18
I32AtomicStore8U
=
0x19
I32AtomicStore16U
=
0x1a
I64AtomicStore8U
=
0x1b
I64AtomicStore16U
=
0x1c
I64AtomicStore32U
=
0x1d
I32AtomicAdd
=
0x1e
I64AtomicAdd
=
0x1f
I32AtomicAdd8U
=
0x20
I32AtomicAdd16U
=
0x21
I64AtomicAdd8U
=
0x22
I64AtomicAdd16U
=
0x23
I64AtomicAdd32U
=
0x24
I32AtomicSub
=
0x25
I64AtomicSub
=
0x26
I32AtomicSub8U
=
0x27
I32AtomicSub16U
=
0x28
I64AtomicSub8U
=
0x29
I64AtomicSub16U
=
0x2a
I64AtomicSub32U
=
0x2b
I32AtomicAnd
=
0x2c
I64AtomicAnd
=
0x2d
I32AtomicAnd8U
=
0x2e
I32AtomicAnd16U
=
0x2f
I64AtomicAnd8U
=
0x30
I64AtomicAnd16U
=
0x31
I64AtomicAnd32U
=
0x32
I32AtomicOr
=
0x33
I64AtomicOr
=
0x34
I32AtomicOr8U
=
0x35
I32AtomicOr16U
=
0x36
I64AtomicOr8U
=
0x37
I64AtomicOr16U
=
0x38
I64AtomicOr32U
=
0x39
I32AtomicXor
=
0x3a
I64AtomicXor
=
0x3b
I32AtomicXor8U
=
0x3c
I32AtomicXor16U
=
0x3d
I64AtomicXor8U
=
0x3e
I64AtomicXor16U
=
0x3f
I64AtomicXor32U
=
0x40
I32AtomicXchg
=
0x41
I64AtomicXchg
=
0x42
I32AtomicXchg8U
=
0x43
I32AtomicXchg16U
=
0x44
I64AtomicXchg8U
=
0x45
I64AtomicXchg16U
=
0x46
I64AtomicXchg32U
=
0x47
I32AtomicCmpXchg
=
0x48
I64AtomicCmpXchg
=
0x49
I32AtomicCmpXchg8U
=
0x4a
I32AtomicCmpXchg16U
=
0x4b
I64AtomicCmpXchg8U
=
0x4c
I64AtomicCmpXchg16U
=
0x4d
I64AtomicCmpXchg32U
=
0x4e
Limit
}
;
enum
class
IntrinsicOp
{
#
define
DECL_INTRINSIC_OP
(
op
export
sa_name
abitype
entry
idx
)
\
op
=
idx
/
/
NOLINT
FOR_EACH_INTRINSIC
(
DECL_INTRINSIC_OP
)
#
undef
DECL_INTRINSIC_OP
Limit
}
;
enum
class
MozOp
{
TeeGlobal
=
0x01
I32Min
I32Max
I32Neg
I32BitNot
I32Abs
F32TeeStoreF64
F64TeeStoreF32
I32TeeStore8
I32TeeStore16
I64TeeStore8
I64TeeStore16
I64TeeStore32
I32TeeStore
I64TeeStore
F32TeeStore
F64TeeStore
F64Mod
F64Sin
F64Cos
F64Tan
F64Asin
F64Acos
F64Atan
F64Exp
F64Log
F64Pow
F64Atan2
OldCallDirect
OldCallIndirect
Limit
}
;
struct
OpBytes
{
uint16_t
b0
;
uint32_t
b1
;
explicit
OpBytes
(
Op
x
)
{
b0
=
uint16_t
(
x
)
;
b1
=
0
;
}
OpBytes
(
)
=
default
;
}
;
static
const
char
NameSectionName
[
]
=
"
name
"
;
static
const
char
SourceMappingURLSectionName
[
]
=
"
sourceMappingURL
"
;
enum
class
NameType
{
Module
=
0
Function
=
1
Local
=
2
}
;
enum
class
FieldFlags
{
Mutable
=
0x01
AllowedMask
=
0x01
}
;
enum
class
FieldExtension
{
None
Signed
Unsigned
}
;
static
const
unsigned
PageSize
=
64
*
1024
;
static
const
unsigned
PageBits
=
16
;
static_assert
(
PageSize
=
=
(
1u
<
<
PageBits
)
)
;
static
const
unsigned
PageMask
=
(
(
1u
<
<
PageBits
)
-
1
)
;
static
const
unsigned
MaxTypes
=
1000000
;
static
const
unsigned
MaxFuncs
=
1000000
;
static
const
unsigned
MaxTables
=
100000
;
static
const
unsigned
MaxImports
=
100000
;
static
const
unsigned
MaxExports
=
100000
;
static
const
unsigned
MaxGlobals
=
1000000
;
static
const
unsigned
MaxDataSegments
=
100000
;
static
const
unsigned
MaxDataSegmentLengthPages
=
16384
;
static
const
unsigned
MaxElemSegments
=
10000000
;
static
const
unsigned
MaxElemSegmentLength
=
10000000
;
static
const
unsigned
MaxTableLimitField
=
UINT32_MAX
;
static
const
unsigned
MaxTableLength
=
10000000
;
static
const
unsigned
MaxLocals
=
50000
;
static
const
unsigned
MaxParams
=
1000
;
static
const
unsigned
MaxResults
=
1000
;
static
const
unsigned
MaxStructFields
=
1000
;
static
const
uint64_t
MaxMemory32LimitField
=
uint64_t
(
1
)
<
<
16
;
static
const
uint64_t
MaxMemory64LimitField
=
uint64_t
(
1
)
<
<
48
;
static
const
unsigned
MaxStringBytes
=
100000
;
static
const
unsigned
MaxModuleBytes
=
1024
*
1024
*
1024
;
static
const
unsigned
MaxFunctionBytes
=
7654321
;
#
ifdef
JS_64BIT
static
const
unsigned
MaxTypeIndex
=
1000000
;
static
const
unsigned
MaxRttDepth
=
1000
;
#
else
static
const
unsigned
MaxTypeIndex
=
15000
;
static
const
unsigned
MaxRttDepth
=
100
;
#
endif
static
const
unsigned
MaxTags
=
1000000
;
static
const
unsigned
MaxBrTableElems
=
1000000
;
static
const
unsigned
MaxCodeSectionBytes
=
MaxModuleBytes
;
static
const
uint32_t
RttDepthNone
=
MaxRttDepth
+
1
;
static
const
unsigned
MaxVarU32DecodedBytes
=
5
;
enum
class
OptimizedBackend
{
Ion
Cranelift
}
;
enum
class
CompileMode
{
Once
Tier1
Tier2
}
;
enum
class
DebugEnabled
{
False
True
}
;
}
}
#
endif
