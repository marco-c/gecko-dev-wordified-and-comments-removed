#
ifndef
wasm_frame_h
#
define
wasm_frame_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
"
jit
/
Registers
.
h
"
namespace
js
{
namespace
wasm
{
class
Instance
;
constexpr
uintptr_t
ExitFPTag
=
0x1
;
class
Frame
{
uint8_t
*
callerFP_
;
void
*
returnAddress_
;
public
:
static
constexpr
uint32_t
callerFPOffset
(
)
{
return
offsetof
(
Frame
callerFP_
)
;
}
static
constexpr
uint32_t
returnAddressOffset
(
)
{
return
offsetof
(
Frame
returnAddress_
)
;
}
uint8_t
*
returnAddress
(
)
const
{
return
reinterpret_cast
<
uint8_t
*
>
(
returnAddress_
)
;
}
void
*
*
addressOfReturnAddress
(
)
{
return
reinterpret_cast
<
void
*
*
>
(
&
returnAddress_
)
;
}
uint8_t
*
rawCaller
(
)
const
{
return
callerFP_
;
}
Frame
*
wasmCaller
(
)
const
{
return
reinterpret_cast
<
Frame
*
>
(
callerFP_
)
;
}
uint8_t
*
jitEntryCaller
(
)
const
{
return
callerFP_
;
}
static
const
Frame
*
fromUntaggedWasmExitFP
(
const
void
*
savedFP
)
{
MOZ_ASSERT
(
!
isExitFP
(
savedFP
)
)
;
return
reinterpret_cast
<
const
Frame
*
>
(
savedFP
)
;
}
static
bool
isExitFP
(
const
void
*
fp
)
{
return
reinterpret_cast
<
uintptr_t
>
(
fp
)
&
ExitFPTag
;
}
static
uint8_t
*
untagExitFP
(
const
void
*
fp
)
{
MOZ_ASSERT
(
isExitFP
(
fp
)
)
;
return
reinterpret_cast
<
uint8_t
*
>
(
reinterpret_cast
<
uintptr_t
>
(
fp
)
&
~
ExitFPTag
)
;
}
static
uint8_t
*
addExitFPTag
(
const
Frame
*
fp
)
{
MOZ_ASSERT
(
!
isExitFP
(
fp
)
)
;
return
reinterpret_cast
<
uint8_t
*
>
(
reinterpret_cast
<
uintptr_t
>
(
fp
)
|
ExitFPTag
)
;
}
}
;
static_assert
(
!
std
:
:
is_polymorphic_v
<
Frame
>
"
Frame
doesn
'
t
need
a
vtable
.
"
)
;
static_assert
(
sizeof
(
Frame
)
=
=
2
*
sizeof
(
void
*
)
"
Frame
is
a
two
pointer
structure
"
)
;
class
FrameWithShadowStackSpace
:
public
Frame
{
protected
:
uint8_t
shadowStackSpace_
[
js
:
:
jit
:
:
ShadowStackSpace
]
;
}
;
class
FrameWithInstances
:
public
std
:
:
conditional_t
<
js
:
:
jit
:
:
ShadowStackSpace
>
=
1
FrameWithShadowStackSpace
Frame
>
{
Instance
*
calleeInstance_
;
Instance
*
callerInstance_
;
public
:
Instance
*
calleeInstance
(
)
{
return
calleeInstance_
;
}
Instance
*
callerInstance
(
)
{
return
callerInstance_
;
}
constexpr
static
uint32_t
sizeOfInstanceFields
(
)
{
return
sizeof
(
wasm
:
:
FrameWithInstances
)
-
sizeof
(
wasm
:
:
Frame
)
-
js
:
:
jit
:
:
ShadowStackSpace
;
}
constexpr
static
uint32_t
sizeOfInstanceFieldsAndShadowStack
(
)
{
return
sizeof
(
wasm
:
:
FrameWithInstances
)
-
sizeof
(
wasm
:
:
Frame
)
;
}
constexpr
static
uint32_t
calleeInstanceOffset
(
)
{
return
offsetof
(
FrameWithInstances
calleeInstance_
)
;
}
constexpr
static
uint32_t
calleeInstanceOffsetWithoutFrame
(
)
{
return
calleeInstanceOffset
(
)
-
sizeof
(
wasm
:
:
Frame
)
;
}
constexpr
static
uint32_t
callerInstanceOffset
(
)
{
return
offsetof
(
FrameWithInstances
callerInstance_
)
;
}
constexpr
static
uint32_t
callerInstanceOffsetWithoutFrame
(
)
{
return
callerInstanceOffset
(
)
-
sizeof
(
wasm
:
:
Frame
)
;
}
}
;
static_assert
(
FrameWithInstances
:
:
calleeInstanceOffsetWithoutFrame
(
)
=
=
js
:
:
jit
:
:
ShadowStackSpace
"
Callee
instance
stored
right
above
the
return
address
.
"
)
;
static_assert
(
FrameWithInstances
:
:
callerInstanceOffsetWithoutFrame
(
)
=
=
js
:
:
jit
:
:
ShadowStackSpace
+
sizeof
(
void
*
)
"
Caller
instance
stored
right
above
the
callee
instance
.
"
)
;
static_assert
(
FrameWithInstances
:
:
sizeOfInstanceFields
(
)
=
=
2
*
sizeof
(
void
*
)
"
There
are
only
two
additional
slots
"
)
;
#
if
defined
(
JS_CODEGEN_ARM64
)
static_assert
(
sizeof
(
Frame
)
%
16
=
=
0
"
frame
is
aligned
"
)
;
#
endif
}
}
#
endif
