#
ifndef
wasm_frame_h
#
define
wasm_frame_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
"
jit
/
Registers
.
h
"
namespace
js
{
namespace
wasm
{
struct
TlsData
;
constexpr
uintptr_t
ExitOrJitEntryFPTag
=
0x1
;
constexpr
uintptr_t
TrampolineFpTag
=
0x2
;
#
if
defined
(
JS_CODEGEN_X86
)
constexpr
uint32_t
IndirectStubAdditionalAlignment
=
8u
;
#
else
constexpr
uint32_t
IndirectStubAdditionalAlignment
=
0u
;
#
endif
class
Frame
{
uint8_t
*
callerFP_
;
void
*
returnAddress_
;
public
:
static
constexpr
uint32_t
callerFPOffset
(
)
{
return
offsetof
(
Frame
callerFP_
)
;
}
static
constexpr
uint32_t
returnAddressOffset
(
)
{
return
offsetof
(
Frame
returnAddress_
)
;
}
uint8_t
*
returnAddress
(
)
const
{
return
reinterpret_cast
<
uint8_t
*
>
(
returnAddress_
)
;
}
void
*
*
addressOfReturnAddress
(
)
{
return
reinterpret_cast
<
void
*
*
>
(
&
returnAddress_
)
;
}
uint8_t
*
rawCaller
(
)
const
{
return
callerFP_
;
}
Frame
*
wasmCaller
(
)
const
{
MOZ_ASSERT
(
!
callerIsExitOrJitEntryFP
(
)
&
&
!
callerIsTrampolineFP
(
)
)
;
return
reinterpret_cast
<
Frame
*
>
(
callerFP_
)
;
}
Frame
*
trampolineCaller
(
)
const
{
MOZ_ASSERT
(
callerIsTrampolineFP
(
)
)
;
return
reinterpret_cast
<
Frame
*
>
(
reinterpret_cast
<
uintptr_t
>
(
callerFP_
)
&
~
TrampolineFpTag
)
;
}
bool
callerIsExitOrJitEntryFP
(
)
const
{
return
isExitOrJitEntryFP
(
callerFP_
)
;
}
bool
callerIsTrampolineFP
(
)
const
{
return
isTrampolineFP
(
callerFP_
)
;
}
size_t
numberOfTrampolineSlots
(
)
const
{
return
callerIsTrampolineFP
(
)
?
(
(
sizeof
(
Frame
)
+
IndirectStubAdditionalAlignment
)
/
sizeof
(
void
*
)
)
:
0
;
}
uint8_t
*
jitEntryCaller
(
)
const
{
return
toJitEntryCaller
(
callerFP_
)
;
}
static
const
Frame
*
fromUntaggedWasmExitFP
(
const
void
*
savedFP
)
{
MOZ_ASSERT
(
!
isExitOrJitEntryFP
(
savedFP
)
)
;
return
reinterpret_cast
<
const
Frame
*
>
(
savedFP
)
;
}
static
bool
isExitOrJitEntryFP
(
const
void
*
fp
)
{
return
reinterpret_cast
<
uintptr_t
>
(
fp
)
&
ExitOrJitEntryFPTag
;
}
static
uint8_t
*
toJitEntryCaller
(
const
void
*
fp
)
{
MOZ_ASSERT
(
isExitOrJitEntryFP
(
fp
)
)
;
return
reinterpret_cast
<
uint8_t
*
>
(
reinterpret_cast
<
uintptr_t
>
(
fp
)
&
~
ExitOrJitEntryFPTag
)
;
}
static
bool
isTrampolineFP
(
const
void
*
fp
)
{
return
reinterpret_cast
<
uintptr_t
>
(
fp
)
&
TrampolineFpTag
;
}
static
uint8_t
*
addExitOrJitEntryFPTag
(
const
Frame
*
fp
)
{
MOZ_ASSERT
(
!
isExitOrJitEntryFP
(
fp
)
)
;
return
reinterpret_cast
<
uint8_t
*
>
(
reinterpret_cast
<
uintptr_t
>
(
fp
)
|
ExitOrJitEntryFPTag
)
;
}
}
;
static_assert
(
!
std
:
:
is_polymorphic_v
<
Frame
>
"
Frame
doesn
'
t
need
a
vtable
.
"
)
;
static_assert
(
sizeof
(
Frame
)
=
=
2
*
sizeof
(
void
*
)
"
Frame
is
a
two
pointer
structure
"
)
;
class
FrameWithTls
:
public
Frame
{
TlsData
*
calleeTls_
;
TlsData
*
callerTls_
;
public
:
TlsData
*
calleeTls
(
)
{
return
calleeTls_
;
}
TlsData
*
callerTls
(
)
{
return
callerTls_
;
}
constexpr
static
uint32_t
sizeOf
(
)
{
return
sizeof
(
wasm
:
:
FrameWithTls
)
+
js
:
:
jit
:
:
ShadowStackSpace
;
}
constexpr
static
uint32_t
sizeWithoutFrame
(
)
{
return
sizeof
(
wasm
:
:
FrameWithTls
)
-
sizeof
(
wasm
:
:
Frame
)
;
}
constexpr
static
uint32_t
calleeTLSOffset
(
)
{
return
offsetof
(
FrameWithTls
calleeTls_
)
-
sizeof
(
wasm
:
:
Frame
)
;
}
constexpr
static
uint32_t
callerTLSOffset
(
)
{
return
offsetof
(
FrameWithTls
callerTls_
)
-
sizeof
(
wasm
:
:
Frame
)
;
}
}
;
static_assert
(
FrameWithTls
:
:
calleeTLSOffset
(
)
=
=
0u
"
Callee
tls
stored
right
above
the
return
address
.
"
)
;
static_assert
(
FrameWithTls
:
:
callerTLSOffset
(
)
=
=
sizeof
(
void
*
)
"
Caller
tls
stored
right
above
the
callee
tls
.
"
)
;
static_assert
(
FrameWithTls
:
:
sizeWithoutFrame
(
)
=
=
2
*
sizeof
(
void
*
)
"
There
are
only
two
additional
slots
"
)
;
#
if
defined
(
JS_CODEGEN_ARM64
)
static_assert
(
sizeof
(
Frame
)
%
16
=
=
0
"
frame
is
aligned
"
)
;
#
endif
}
}
#
endif
