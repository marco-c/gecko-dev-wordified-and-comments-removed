#
ifndef
wasm_shareable_h
#
define
wasm_shareable_h
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
js
/
RefCounted
.
h
"
#
include
"
wasm
/
WasmTypeDecls
.
h
"
namespace
js
{
namespace
wasm
{
template
<
class
T
>
using
SeenSet
=
HashSet
<
const
T
*
DefaultHasher
<
const
T
*
>
SystemAllocPolicy
>
;
template
<
class
T
>
struct
ShareableBase
:
AtomicRefCounted
<
T
>
{
using
SeenSet
=
wasm
:
:
SeenSet
<
T
>
;
size_t
sizeOfIncludingThisIfNotSeen
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
SeenSet
*
seen
)
const
{
const
T
*
self
=
static_cast
<
const
T
*
>
(
this
)
;
typename
SeenSet
:
:
AddPtr
p
=
seen
-
>
lookupForAdd
(
self
)
;
if
(
p
)
{
return
0
;
}
bool
ok
=
seen
-
>
add
(
p
self
)
;
(
void
)
ok
;
return
mallocSizeOf
(
self
)
+
self
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
template
<
typename
T
size_t
MinInlineCapacity
class
AllocPolicy
>
struct
ShareableVector
:
public
ShareableBase
<
ShareableVector
<
T
MinInlineCapacity
AllocPolicy
>
>
{
using
VecT
=
mozilla
:
:
Vector
<
T
MinInlineCapacity
AllocPolicy
>
;
VecT
vector
;
size_t
length
(
)
const
{
return
vector
.
length
(
)
;
}
bool
empty
(
)
const
{
return
vector
.
empty
(
)
;
}
T
*
begin
(
)
{
return
vector
.
begin
(
)
;
}
T
*
end
(
)
{
return
vector
.
end
(
)
;
}
const
T
*
begin
(
)
const
{
return
vector
.
begin
(
)
;
}
const
T
*
end
(
)
const
{
return
vector
.
end
(
)
;
}
mozilla
:
:
Span
<
const
T
>
span
(
)
const
{
return
mozilla
:
:
Span
<
const
T
>
(
begin
(
)
end
(
)
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
vector
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
bool
append
(
const
T
*
start
size_t
len
)
{
return
vector
.
append
(
start
len
)
;
}
bool
appendAll
(
const
VecT
&
other
)
{
return
vector
.
appendAll
(
other
)
;
}
void
shrinkTo
(
size_t
len
)
{
return
vector
.
shrinkTo
(
len
)
;
}
ShareableVector
(
)
=
default
;
explicit
ShareableVector
(
VecT
&
&
vector
)
:
vector
(
std
:
:
move
(
vector
)
)
{
}
static
const
ShareableVector
*
fromSpan
(
mozilla
:
:
Span
<
const
T
>
span
)
{
ShareableVector
*
vector
=
js_new
<
ShareableVector
>
(
)
;
if
(
!
vector
|
|
!
vector
-
>
append
(
span
.
data
(
)
span
.
size
(
)
)
)
{
return
nullptr
;
}
return
vector
;
}
}
;
using
ShareableBytes
=
ShareableVector
<
uint8_t
0
SystemAllocPolicy
>
;
using
MutableBytes
=
RefPtr
<
ShareableBytes
>
;
using
SharedBytes
=
RefPtr
<
const
ShareableBytes
>
;
struct
ShareableChars
:
public
ShareableBase
<
ShareableChars
>
{
UniqueChars
chars
;
ShareableChars
(
)
=
default
;
explicit
ShareableChars
(
UniqueChars
&
&
chars
)
:
chars
(
std
:
:
move
(
chars
)
)
{
}
}
;
using
SharedChars
=
RefPtr
<
const
ShareableChars
>
;
}
}
#
endif
