#
ifndef
wasm_compile_args_h
#
define
wasm_compile_args_h
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
WasmFeatures
.
h
"
#
include
"
wasm
/
WasmConstants
.
h
"
#
include
"
wasm
/
WasmShareable
.
h
"
namespace
js
{
namespace
wasm
{
enum
class
Shareable
{
False
True
}
;
enum
class
Tier
{
Baseline
Debug
=
Baseline
Optimized
Serialized
=
Optimized
}
;
class
Tiers
{
Tier
t_
[
2
]
;
uint32_t
n_
;
public
:
explicit
Tiers
(
)
{
n_
=
0
;
}
explicit
Tiers
(
Tier
t
)
{
t_
[
0
]
=
t
;
n_
=
1
;
}
explicit
Tiers
(
Tier
t
Tier
u
)
{
MOZ_ASSERT
(
t
!
=
u
)
;
t_
[
0
]
=
t
;
t_
[
1
]
=
u
;
n_
=
2
;
}
Tier
*
begin
(
)
{
return
t_
;
}
Tier
*
end
(
)
{
return
t_
+
n_
;
}
}
;
struct
FeatureOptions
{
FeatureOptions
(
)
:
isBuiltinModule
(
false
)
jsStringBuiltins
(
false
)
{
}
bool
isBuiltinModule
;
bool
jsStringBuiltins
;
[
[
nodiscard
]
]
bool
init
(
JSContext
*
cx
HandleValue
val
)
;
}
;
struct
FeatureArgs
{
FeatureArgs
(
)
:
#
define
WASM_FEATURE
(
NAME
LOWER_NAME
.
.
.
)
LOWER_NAME
(
false
)
JS_FOR_WASM_FEATURES
(
WASM_FEATURE
)
#
undef
WASM_FEATURE
sharedMemory
(
Shareable
:
:
False
)
simd
(
false
)
isBuiltinModule
(
false
)
{
}
FeatureArgs
(
const
FeatureArgs
&
)
=
default
;
FeatureArgs
&
operator
=
(
const
FeatureArgs
&
)
=
default
;
FeatureArgs
(
FeatureArgs
&
&
)
=
default
;
static
FeatureArgs
build
(
JSContext
*
cx
const
FeatureOptions
&
options
)
;
#
define
WASM_FEATURE
(
NAME
LOWER_NAME
.
.
.
)
bool
LOWER_NAME
;
JS_FOR_WASM_FEATURES
(
WASM_FEATURE
)
#
undef
WASM_FEATURE
Shareable
sharedMemory
;
bool
simd
;
bool
isBuiltinModule
;
BuiltinModuleIds
builtinModules
;
}
;
enum
class
FeatureUsage
:
uint8_t
{
None
=
0x0
LegacyExceptions
=
0x1
}
;
void
SetUseCountersForFeatureUsage
(
JSContext
*
cx
JSObject
*
object
FeatureUsage
usage
)
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
FeatureUsage
)
;
struct
ScriptedCaller
{
UniqueChars
filename
;
bool
filenameIsURL
;
uint32_t
line
;
ScriptedCaller
(
)
:
filenameIsURL
(
false
)
line
(
0
)
{
}
}
;
enum
class
CompileArgsError
{
OutOfMemory
NoCompiler
}
;
struct
CompileArgs
;
using
MutableCompileArgs
=
RefPtr
<
CompileArgs
>
;
using
SharedCompileArgs
=
RefPtr
<
const
CompileArgs
>
;
struct
CompileArgs
:
ShareableBase
<
CompileArgs
>
{
ScriptedCaller
scriptedCaller
;
UniqueChars
sourceMapURL
;
bool
baselineEnabled
;
bool
ionEnabled
;
bool
debugEnabled
;
bool
forceTiering
;
FeatureArgs
features
;
static
SharedCompileArgs
build
(
JSContext
*
cx
ScriptedCaller
&
&
scriptedCaller
const
FeatureOptions
&
options
CompileArgsError
*
error
)
;
static
SharedCompileArgs
buildForAsmJS
(
ScriptedCaller
&
&
scriptedCaller
)
;
static
SharedCompileArgs
buildAndReport
(
JSContext
*
cx
ScriptedCaller
&
&
scriptedCaller
const
FeatureOptions
&
options
bool
reportOOM
=
false
)
;
explicit
CompileArgs
(
ScriptedCaller
&
&
scriptedCaller
)
:
scriptedCaller
(
std
:
:
move
(
scriptedCaller
)
)
baselineEnabled
(
false
)
ionEnabled
(
false
)
debugEnabled
(
false
)
forceTiering
(
false
)
{
}
}
;
struct
CompileArgs
;
class
Decoder
;
struct
CompilerEnvironment
{
enum
State
{
InitialWithArgs
InitialWithModeTierDebug
Computed
}
;
State
state_
;
union
{
const
CompileArgs
*
args_
;
struct
{
CompileMode
mode_
;
Tier
tier_
;
DebugEnabled
debug_
;
}
;
}
;
public
:
explicit
CompilerEnvironment
(
const
CompileArgs
&
args
)
;
CompilerEnvironment
(
CompileMode
mode
Tier
tier
DebugEnabled
debugEnabled
)
;
void
computeParameters
(
Decoder
&
d
)
;
void
computeParameters
(
)
;
bool
isComputed
(
)
const
{
return
state_
=
=
Computed
;
}
CompileMode
mode
(
)
const
{
MOZ_ASSERT
(
isComputed
(
)
)
;
return
mode_
;
}
Tier
tier
(
)
const
{
MOZ_ASSERT
(
isComputed
(
)
)
;
return
tier_
;
}
DebugEnabled
debug
(
)
const
{
MOZ_ASSERT
(
isComputed
(
)
)
;
return
debug_
;
}
bool
debugEnabled
(
)
const
{
return
debug
(
)
=
=
DebugEnabled
:
:
True
;
}
}
;
}
}
#
endif
