#
include
"
wasm
/
WasmGenerator
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
EnumeratedRange
.
h
"
#
include
"
mozilla
/
SHA1
.
h
"
#
include
<
algorithm
>
#
include
"
wasm
/
WasmBaselineCompile
.
h
"
#
include
"
wasm
/
WasmCompile
.
h
"
#
include
"
wasm
/
WasmIonCompile
.
h
"
#
include
"
wasm
/
WasmStubs
.
h
"
#
include
"
jit
/
MacroAssembler
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
using
mozilla
:
:
CheckedInt
;
using
mozilla
:
:
MakeEnumeratedRange
;
static
const
unsigned
GENERATOR_LIFO_DEFAULT_CHUNK_SIZE
=
4
*
1024
;
static
const
unsigned
COMPILATION_LIFO_DEFAULT_CHUNK_SIZE
=
64
*
1024
;
static
const
uint32_t
BAD_CODE_RANGE
=
UINT32_MAX
;
ModuleGenerator
:
:
ModuleGenerator
(
UniqueChars
*
error
)
:
tier_
(
Tier
(
-
1
)
)
compileMode_
(
CompileMode
:
:
Once
)
error_
(
error
)
linkDataTier_
(
nullptr
)
metadataTier_
(
nullptr
)
numSigs_
(
0
)
numTables_
(
0
)
lifo_
(
GENERATOR_LIFO_DEFAULT_CHUNK_SIZE
)
masmAlloc_
(
&
lifo_
)
masm_
(
MacroAssembler
:
:
WasmToken
(
)
masmAlloc_
)
lastPatchedCallsite_
(
0
)
startOfUnpatchedCallsites_
(
0
)
parallel_
(
false
)
outstanding_
(
0
)
currentTask_
(
nullptr
)
batchedBytecode_
(
0
)
activeFuncDef_
(
nullptr
)
startedFuncDefs_
(
false
)
finishedFuncDefs_
(
false
)
numFinishedFuncDefs_
(
0
)
{
MOZ_ASSERT
(
IsCompilingWasm
(
)
)
;
}
ModuleGenerator
:
:
~
ModuleGenerator
(
)
{
if
(
parallel_
)
{
if
(
outstanding_
)
{
AutoLockHelperThreadState
lock
;
while
(
true
)
{
CompileTaskPtrVector
&
worklist
=
HelperThreadState
(
)
.
wasmWorklist
(
lock
compileMode_
)
;
MOZ_ASSERT
(
outstanding_
>
=
worklist
.
length
(
)
)
;
outstanding_
-
=
worklist
.
length
(
)
;
worklist
.
clear
(
)
;
CompileTaskPtrVector
&
finished
=
HelperThreadState
(
)
.
wasmFinishedList
(
lock
compileMode_
)
;
MOZ_ASSERT
(
outstanding_
>
=
finished
.
length
(
)
)
;
outstanding_
-
=
finished
.
length
(
)
;
finished
.
clear
(
)
;
uint32_t
numFailed
=
HelperThreadState
(
)
.
harvestFailedWasmJobs
(
lock
compileMode_
)
;
MOZ_ASSERT
(
outstanding_
>
=
numFailed
)
;
outstanding_
-
=
numFailed
;
if
(
!
outstanding_
)
break
;
HelperThreadState
(
)
.
wait
(
lock
GlobalHelperThreadState
:
:
CONSUMER
)
;
}
}
MOZ_ASSERT
(
HelperThreadState
(
)
.
wasmCompilationInProgress
(
compileMode_
)
)
;
HelperThreadState
(
)
.
wasmCompilationInProgress
(
compileMode_
)
=
false
;
}
else
{
MOZ_ASSERT
(
!
outstanding_
)
;
}
MOZ_ASSERT_IF
(
finishedFuncDefs_
!
batchedBytecode_
)
;
MOZ_ASSERT_IF
(
finishedFuncDefs_
!
currentTask_
)
;
}
bool
ModuleGenerator
:
:
initAsmJS
(
Metadata
*
asmJSMetadata
)
{
MOZ_ASSERT
(
env_
-
>
isAsmJS
(
)
)
;
if
(
!
linkData_
.
initTier1
(
Tier
:
:
Ion
*
asmJSMetadata
)
)
return
false
;
linkDataTier_
=
&
linkData_
.
linkData
(
Tier
:
:
Ion
)
;
metadataTier_
=
&
asmJSMetadata
-
>
metadata
(
Tier
:
:
Ion
)
;
metadata_
=
asmJSMetadata
;
MOZ_ASSERT
(
isAsmJS
(
)
)
;
metadata_
-
>
debugEnabled
=
false
;
tier_
=
Tier
:
:
Ion
;
MOZ_ASSERT
(
env_
-
>
sigs
.
length
(
)
=
=
AsmJSMaxTypes
)
;
MOZ_ASSERT
(
env_
-
>
tables
.
length
(
)
=
=
AsmJSMaxTables
)
;
MOZ_ASSERT
(
env_
-
>
asmJSSigToTableIndex
.
length
(
)
=
=
AsmJSMaxTypes
)
;
return
true
;
}
bool
ModuleGenerator
:
:
initWasm
(
const
CompileArgs
&
args
)
{
MOZ_ASSERT
(
!
env_
-
>
isAsmJS
(
)
)
;
tier_
=
GetTier
(
args
compileMode_
)
;
auto
metadataTier
=
js
:
:
MakeUnique
<
MetadataTier
>
(
tier_
)
;
if
(
!
metadataTier
)
return
false
;
metadata_
=
js_new
<
Metadata
>
(
Move
(
metadataTier
)
)
;
if
(
!
metadata_
)
return
false
;
metadataTier_
=
&
metadata_
-
>
metadata
(
tier_
)
;
if
(
!
linkData_
.
initTier1
(
tier_
*
metadata_
)
)
return
false
;
linkDataTier_
=
&
linkData_
.
linkData
(
tier_
)
;
MOZ_ASSERT
(
!
isAsmJS
(
)
)
;
metadata_
-
>
debugEnabled
=
GetDebugEnabled
(
args
)
;
numSigs_
=
env_
-
>
sigs
.
length
(
)
;
numTables_
=
env_
-
>
tables
.
length
(
)
;
for
(
size_t
i
=
0
;
i
<
env_
-
>
funcImportGlobalDataOffsets
.
length
(
)
;
i
+
+
)
{
env_
-
>
funcImportGlobalDataOffsets
[
i
]
=
metadata_
-
>
globalDataLength
;
metadata_
-
>
globalDataLength
+
=
sizeof
(
FuncImportTls
)
;
if
(
!
addFuncImport
(
*
env_
-
>
funcSigs
[
i
]
env_
-
>
funcImportGlobalDataOffsets
[
i
]
)
)
return
false
;
}
for
(
TableDesc
&
table
:
env_
-
>
tables
)
{
if
(
!
allocateGlobalBytes
(
sizeof
(
TableTls
)
sizeof
(
void
*
)
&
table
.
globalDataOffset
)
)
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
numSigs_
;
i
+
+
)
{
SigWithId
&
sig
=
env_
-
>
sigs
[
i
]
;
if
(
SigIdDesc
:
:
isGlobal
(
sig
)
)
{
uint32_t
globalDataOffset
;
if
(
!
allocateGlobalBytes
(
sizeof
(
void
*
)
sizeof
(
void
*
)
&
globalDataOffset
)
)
return
false
;
sig
.
id
=
SigIdDesc
:
:
global
(
sig
globalDataOffset
)
;
Sig
copy
;
if
(
!
copy
.
clone
(
sig
)
)
return
false
;
if
(
!
metadata_
-
>
sigIds
.
emplaceBack
(
Move
(
copy
)
sig
.
id
)
)
return
false
;
}
else
{
sig
.
id
=
SigIdDesc
:
:
immediate
(
sig
)
;
}
}
for
(
GlobalDesc
&
global
:
env_
-
>
globals
)
{
if
(
global
.
isConstant
(
)
)
continue
;
if
(
!
allocateGlobal
(
&
global
)
)
return
false
;
}
for
(
const
Export
&
exp
:
env_
-
>
exports
)
{
if
(
exp
.
kind
(
)
=
=
DefinitionKind
:
:
Function
)
{
if
(
!
exportedFuncs_
.
put
(
exp
.
funcIndex
(
)
)
)
return
false
;
}
}
if
(
env_
-
>
startFuncIndex
)
{
metadata_
-
>
startFuncIndex
.
emplace
(
*
env_
-
>
startFuncIndex
)
;
if
(
!
exportedFuncs_
.
put
(
*
env_
-
>
startFuncIndex
)
)
return
false
;
}
if
(
metadata_
-
>
debugEnabled
)
{
if
(
!
debugFuncArgTypes_
.
resize
(
env_
-
>
funcSigs
.
length
(
)
)
)
return
false
;
if
(
!
debugFuncReturnTypes_
.
resize
(
env_
-
>
funcSigs
.
length
(
)
)
)
return
false
;
for
(
size_t
i
=
0
;
i
<
debugFuncArgTypes_
.
length
(
)
;
i
+
+
)
{
if
(
!
debugFuncArgTypes_
[
i
]
.
appendAll
(
env_
-
>
funcSigs
[
i
]
-
>
args
(
)
)
)
return
false
;
debugFuncReturnTypes_
[
i
]
=
env_
-
>
funcSigs
[
i
]
-
>
ret
(
)
;
}
}
return
true
;
}
bool
ModuleGenerator
:
:
init
(
UniqueModuleEnvironment
env
const
CompileArgs
&
args
CompileMode
compileMode
Metadata
*
maybeAsmJSMetadata
)
{
env_
=
Move
(
env
)
;
compileMode_
=
compileMode
;
if
(
!
funcToCodeRange_
.
appendN
(
BAD_CODE_RANGE
env_
-
>
funcSigs
.
length
(
)
)
)
return
false
;
if
(
!
assumptions_
.
clone
(
args
.
assumptions
)
)
return
false
;
if
(
!
exportedFuncs_
.
init
(
)
)
return
false
;
if
(
env_
-
>
isAsmJS
(
)
?
!
initAsmJS
(
maybeAsmJSMetadata
)
:
!
initWasm
(
args
)
)
return
false
;
if
(
args
.
scriptedCaller
.
filename
)
{
metadata_
-
>
filename
=
DuplicateString
(
args
.
scriptedCaller
.
filename
.
get
(
)
)
;
if
(
!
metadata_
-
>
filename
)
return
false
;
}
return
true
;
}
ModuleEnvironment
&
ModuleGenerator
:
:
mutableEnv
(
)
{
MOZ_ASSERT
(
!
startedFuncDefs_
|
|
finishedFuncDefs_
)
;
return
*
env_
;
}
bool
ModuleGenerator
:
:
finishOutstandingTask
(
)
{
MOZ_ASSERT
(
parallel_
)
;
CompileTask
*
task
=
nullptr
;
{
AutoLockHelperThreadState
lock
;
while
(
true
)
{
MOZ_ASSERT
(
outstanding_
>
0
)
;
if
(
HelperThreadState
(
)
.
wasmFailed
(
lock
compileMode_
)
)
{
if
(
error_
)
{
MOZ_ASSERT
(
!
*
error_
"
Should
have
stopped
earlier
"
)
;
*
error_
=
Move
(
HelperThreadState
(
)
.
harvestWasmError
(
lock
compileMode_
)
)
;
}
return
false
;
}
if
(
!
HelperThreadState
(
)
.
wasmFinishedList
(
lock
compileMode_
)
.
empty
(
)
)
{
outstanding_
-
-
;
task
=
HelperThreadState
(
)
.
wasmFinishedList
(
lock
compileMode_
)
.
popCopy
(
)
;
break
;
}
HelperThreadState
(
)
.
wait
(
lock
GlobalHelperThreadState
:
:
CONSUMER
)
;
}
}
return
finishTask
(
task
)
;
}
bool
ModuleGenerator
:
:
funcIsCompiled
(
uint32_t
funcIndex
)
const
{
return
funcToCodeRange_
[
funcIndex
]
!
=
BAD_CODE_RANGE
;
}
const
CodeRange
&
ModuleGenerator
:
:
funcCodeRange
(
uint32_t
funcIndex
)
const
{
MOZ_ASSERT
(
funcIsCompiled
(
funcIndex
)
)
;
const
CodeRange
&
cr
=
metadataTier_
-
>
codeRanges
[
funcToCodeRange_
[
funcIndex
]
]
;
MOZ_ASSERT
(
cr
.
isFunction
(
)
)
;
return
cr
;
}
static
uint32_t
JumpRange
(
)
{
return
Min
(
JitOptions
.
jumpThreshold
JumpImmediateRange
)
;
}
typedef
HashMap
<
uint32_t
uint32_t
DefaultHasher
<
uint32_t
>
SystemAllocPolicy
>
OffsetMap
;
bool
ModuleGenerator
:
:
patchCallSites
(
)
{
masm_
.
haltingAlign
(
CodeAlignment
)
;
OffsetMap
existingCallFarJumps
;
if
(
!
existingCallFarJumps
.
init
(
)
)
return
false
;
EnumeratedArray
<
Trap
Trap
:
:
Limit
Maybe
<
uint32_t
>
>
existingTrapFarJumps
;
for
(
;
lastPatchedCallsite_
<
masm_
.
callSites
(
)
.
length
(
)
;
lastPatchedCallsite_
+
+
)
{
const
CallSiteAndTarget
&
cs
=
masm_
.
callSites
(
)
[
lastPatchedCallsite_
]
;
uint32_t
callerOffset
=
cs
.
returnAddressOffset
(
)
;
MOZ_RELEASE_ASSERT
(
callerOffset
<
INT32_MAX
)
;
switch
(
cs
.
kind
(
)
)
{
case
CallSiteDesc
:
:
Dynamic
:
case
CallSiteDesc
:
:
Symbolic
:
break
;
case
CallSiteDesc
:
:
Func
:
{
if
(
funcIsCompiled
(
cs
.
funcIndex
(
)
)
)
{
uint32_t
calleeOffset
=
funcCodeRange
(
cs
.
funcIndex
(
)
)
.
funcNormalEntry
(
)
;
MOZ_RELEASE_ASSERT
(
calleeOffset
<
INT32_MAX
)
;
if
(
uint32_t
(
abs
(
int32_t
(
calleeOffset
)
-
int32_t
(
callerOffset
)
)
)
<
JumpRange
(
)
)
{
masm_
.
patchCall
(
callerOffset
calleeOffset
)
;
break
;
}
}
OffsetMap
:
:
AddPtr
p
=
existingCallFarJumps
.
lookupForAdd
(
cs
.
funcIndex
(
)
)
;
if
(
!
p
)
{
Offsets
offsets
;
offsets
.
begin
=
masm_
.
currentOffset
(
)
;
masm_
.
append
(
CallFarJump
(
cs
.
funcIndex
(
)
masm_
.
farJumpWithPatch
(
)
)
)
;
offsets
.
end
=
masm_
.
currentOffset
(
)
;
if
(
masm_
.
oom
(
)
)
return
false
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
FarJumpIsland
offsets
)
)
return
false
;
if
(
!
existingCallFarJumps
.
add
(
p
cs
.
funcIndex
(
)
offsets
.
begin
)
)
return
false
;
}
masm_
.
patchCall
(
callerOffset
p
-
>
value
(
)
)
;
break
;
}
case
CallSiteDesc
:
:
TrapExit
:
{
if
(
!
existingTrapFarJumps
[
cs
.
trap
(
)
]
)
{
Offsets
offsets
;
offsets
.
begin
=
masm_
.
currentOffset
(
)
;
masm_
.
loadPtr
(
Address
(
FramePointer
offsetof
(
Frame
tls
)
)
WasmTlsReg
)
;
masm_
.
append
(
TrapFarJump
(
cs
.
trap
(
)
masm_
.
farJumpWithPatch
(
)
)
)
;
offsets
.
end
=
masm_
.
currentOffset
(
)
;
if
(
masm_
.
oom
(
)
)
return
false
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
FarJumpIsland
offsets
)
)
return
false
;
existingTrapFarJumps
[
cs
.
trap
(
)
]
=
Some
(
offsets
.
begin
)
;
}
masm_
.
patchCall
(
callerOffset
*
existingTrapFarJumps
[
cs
.
trap
(
)
]
)
;
break
;
}
case
CallSiteDesc
:
:
Breakpoint
:
case
CallSiteDesc
:
:
EnterFrame
:
case
CallSiteDesc
:
:
LeaveFrame
:
{
Uint32Vector
&
jumps
=
metadataTier_
-
>
debugTrapFarJumpOffsets
;
if
(
jumps
.
empty
(
)
|
|
uint32_t
(
abs
(
int32_t
(
jumps
.
back
(
)
)
-
int32_t
(
callerOffset
)
)
)
>
=
JumpRange
(
)
)
{
Offsets
offsets
;
offsets
.
begin
=
masm_
.
currentOffset
(
)
;
masm_
.
loadPtr
(
Address
(
FramePointer
offsetof
(
Frame
tls
)
)
WasmTlsReg
)
;
uint32_t
jumpOffset
=
masm_
.
farJumpWithPatch
(
)
.
offset
(
)
;
offsets
.
end
=
masm_
.
currentOffset
(
)
;
if
(
masm_
.
oom
(
)
)
return
false
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
FarJumpIsland
offsets
)
)
return
false
;
if
(
!
debugTrapFarJumps_
.
emplaceBack
(
jumpOffset
)
)
return
false
;
if
(
!
jumps
.
emplaceBack
(
offsets
.
begin
)
)
return
false
;
}
break
;
}
}
}
masm_
.
flushBuffer
(
)
;
return
true
;
}
bool
ModuleGenerator
:
:
patchFarJumps
(
const
TrapExitOffsetArray
&
trapExits
const
Offsets
&
debugTrapStub
)
{
for
(
const
CallFarJump
&
farJump
:
masm_
.
callFarJumps
(
)
)
masm_
.
patchFarJump
(
farJump
.
jump
funcCodeRange
(
farJump
.
funcIndex
)
.
funcNormalEntry
(
)
)
;
for
(
const
TrapFarJump
&
farJump
:
masm_
.
trapFarJumps
(
)
)
masm_
.
patchFarJump
(
farJump
.
jump
trapExits
[
farJump
.
trap
]
.
begin
)
;
for
(
uint32_t
debugTrapFarJump
:
debugTrapFarJumps_
)
masm_
.
patchFarJump
(
CodeOffset
(
debugTrapFarJump
)
debugTrapStub
.
begin
)
;
return
true
;
}
bool
ModuleGenerator
:
:
finishTask
(
CompileTask
*
task
)
{
masm_
.
haltingAlign
(
CodeAlignment
)
;
if
(
(
masm_
.
size
(
)
-
startOfUnpatchedCallsites_
)
+
task
-
>
masm
(
)
.
size
(
)
>
JumpRange
(
)
)
{
startOfUnpatchedCallsites_
=
masm_
.
size
(
)
;
if
(
!
patchCallSites
(
)
)
return
false
;
}
uint32_t
offsetInWhole
=
masm_
.
size
(
)
;
for
(
const
FuncCompileUnit
&
unit
:
task
-
>
units
(
)
)
{
const
FuncBytes
&
func
=
unit
.
func
(
)
;
FuncOffsets
offsets
=
unit
.
offsets
(
)
;
offsets
.
offsetBy
(
offsetInWhole
)
;
uint32_t
funcCodeRangeIndex
=
metadataTier_
-
>
codeRanges
.
length
(
)
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
func
.
index
(
)
func
.
lineOrBytecode
(
)
offsets
)
)
return
false
;
MOZ_ASSERT
(
!
funcIsCompiled
(
func
.
index
(
)
)
)
;
funcToCodeRange_
[
func
.
index
(
)
]
=
funcCodeRangeIndex
;
}
mozilla
:
:
DebugOnly
<
size_t
>
sizeBefore
=
masm_
.
size
(
)
;
if
(
!
masm_
.
asmMergeWith
(
task
-
>
masm
(
)
)
)
return
false
;
MOZ_ASSERT
(
masm_
.
size
(
)
=
=
offsetInWhole
+
task
-
>
masm
(
)
.
size
(
)
)
;
if
(
!
task
-
>
reset
(
&
freeFuncBytes_
)
)
return
false
;
freeTasks_
.
infallibleAppend
(
task
)
;
return
true
;
}
bool
ModuleGenerator
:
:
finishFuncExports
(
)
{
for
(
ElemSegment
&
elems
:
env_
-
>
elemSegments
)
{
if
(
env_
-
>
tables
[
elems
.
tableIndex
]
.
external
)
{
for
(
uint32_t
funcIndex
:
elems
.
elemFuncIndices
)
{
if
(
!
exportedFuncs_
.
put
(
funcIndex
)
)
return
false
;
}
}
}
Uint32Vector
sorted
;
if
(
!
sorted
.
reserve
(
exportedFuncs_
.
count
(
)
)
)
return
false
;
for
(
Uint32Set
:
:
Range
r
=
exportedFuncs_
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
sorted
.
infallibleAppend
(
r
.
front
(
)
)
;
std
:
:
sort
(
sorted
.
begin
(
)
sorted
.
end
(
)
)
;
MOZ_ASSERT
(
metadataTier_
-
>
funcExports
.
empty
(
)
)
;
if
(
!
metadataTier_
-
>
funcExports
.
reserve
(
sorted
.
length
(
)
)
)
return
false
;
for
(
uint32_t
funcIndex
:
sorted
)
{
Sig
sig
;
if
(
!
sig
.
clone
(
funcSig
(
funcIndex
)
)
)
return
false
;
uint32_t
codeRangeIndex
=
funcToCodeRange_
[
funcIndex
]
;
metadataTier_
-
>
funcExports
.
infallibleEmplaceBack
(
Move
(
sig
)
funcIndex
codeRangeIndex
)
;
}
return
true
;
}
typedef
Vector
<
Offsets
0
SystemAllocPolicy
>
OffsetVector
;
typedef
Vector
<
CallableOffsets
0
SystemAllocPolicy
>
CallableOffsetVector
;
bool
ModuleGenerator
:
:
finishCodegen
(
)
{
masm_
.
haltingAlign
(
CodeAlignment
)
;
uint32_t
offsetInWhole
=
masm_
.
size
(
)
;
uint32_t
numFuncExports
=
metadataTier_
-
>
funcExports
.
length
(
)
;
MOZ_ASSERT
(
numFuncExports
=
=
exportedFuncs_
.
count
(
)
)
;
OffsetVector
entries
;
CallableOffsetVector
interpExits
;
CallableOffsetVector
jitExits
;
TrapExitOffsetArray
trapExits
;
Offsets
outOfBoundsExit
;
Offsets
unalignedAccessExit
;
Offsets
interruptExit
;
Offsets
throwStub
;
Offsets
debugTrapStub
;
{
TempAllocator
alloc
(
&
lifo_
)
;
MacroAssembler
masm
(
MacroAssembler
:
:
WasmToken
(
)
alloc
)
;
Label
throwLabel
;
if
(
!
entries
.
resize
(
numFuncExports
)
)
return
false
;
for
(
uint32_t
i
=
0
;
i
<
numFuncExports
;
i
+
+
)
entries
[
i
]
=
GenerateEntry
(
masm
metadataTier_
-
>
funcExports
[
i
]
)
;
if
(
!
interpExits
.
resize
(
numFuncImports
(
)
)
)
return
false
;
if
(
!
jitExits
.
resize
(
numFuncImports
(
)
)
)
return
false
;
for
(
uint32_t
i
=
0
;
i
<
numFuncImports
(
)
;
i
+
+
)
{
interpExits
[
i
]
=
GenerateImportInterpExit
(
masm
metadataTier_
-
>
funcImports
[
i
]
i
&
throwLabel
)
;
jitExits
[
i
]
=
GenerateImportJitExit
(
masm
metadataTier_
-
>
funcImports
[
i
]
&
throwLabel
)
;
}
for
(
Trap
trap
:
MakeEnumeratedRange
(
Trap
:
:
Limit
)
)
trapExits
[
trap
]
=
GenerateTrapExit
(
masm
trap
&
throwLabel
)
;
outOfBoundsExit
=
GenerateOutOfBoundsExit
(
masm
&
throwLabel
)
;
unalignedAccessExit
=
GenerateUnalignedExit
(
masm
&
throwLabel
)
;
interruptExit
=
GenerateInterruptExit
(
masm
&
throwLabel
)
;
throwStub
=
GenerateThrowStub
(
masm
&
throwLabel
)
;
debugTrapStub
=
GenerateDebugTrapStub
(
masm
&
throwLabel
)
;
if
(
masm
.
oom
(
)
|
|
!
masm_
.
asmMergeWith
(
masm
)
)
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
numFuncExports
;
i
+
+
)
{
entries
[
i
]
.
offsetBy
(
offsetInWhole
)
;
metadataTier_
-
>
funcExports
[
i
]
.
initEntryOffset
(
entries
[
i
]
.
begin
)
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
Entry
entries
[
i
]
)
)
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
numFuncImports
(
)
;
i
+
+
)
{
interpExits
[
i
]
.
offsetBy
(
offsetInWhole
)
;
metadataTier_
-
>
funcImports
[
i
]
.
initInterpExitOffset
(
interpExits
[
i
]
.
begin
)
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
ImportInterpExit
interpExits
[
i
]
)
)
return
false
;
jitExits
[
i
]
.
offsetBy
(
offsetInWhole
)
;
metadataTier_
-
>
funcImports
[
i
]
.
initJitExitOffset
(
jitExits
[
i
]
.
begin
)
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
ImportJitExit
jitExits
[
i
]
)
)
return
false
;
}
for
(
Trap
trap
:
MakeEnumeratedRange
(
Trap
:
:
Limit
)
)
{
trapExits
[
trap
]
.
offsetBy
(
offsetInWhole
)
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
TrapExit
trapExits
[
trap
]
)
)
return
false
;
}
outOfBoundsExit
.
offsetBy
(
offsetInWhole
)
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
Inline
outOfBoundsExit
)
)
return
false
;
unalignedAccessExit
.
offsetBy
(
offsetInWhole
)
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
Inline
unalignedAccessExit
)
)
return
false
;
interruptExit
.
offsetBy
(
offsetInWhole
)
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
Interrupt
interruptExit
)
)
return
false
;
throwStub
.
offsetBy
(
offsetInWhole
)
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
Throw
throwStub
)
)
return
false
;
debugTrapStub
.
offsetBy
(
offsetInWhole
)
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
CodeRange
:
:
DebugTrap
debugTrapStub
)
)
return
false
;
linkDataTier_
-
>
unalignedAccessOffset
=
unalignedAccessExit
.
begin
;
linkDataTier_
-
>
outOfBoundsOffset
=
outOfBoundsExit
.
begin
;
linkDataTier_
-
>
interruptOffset
=
interruptExit
.
begin
;
if
(
!
patchCallSites
(
)
)
return
false
;
if
(
!
patchFarJumps
(
trapExits
debugTrapStub
)
)
return
false
;
masm_
.
finish
(
)
;
return
!
masm_
.
oom
(
)
;
}
bool
ModuleGenerator
:
:
finishLinkData
(
)
{
metadata_
-
>
globalDataLength
=
AlignBytes
(
metadata_
-
>
globalDataLength
gc
:
:
SystemPageSize
(
)
)
;
for
(
size_t
i
=
0
;
i
<
masm_
.
numSymbolicAccesses
(
)
;
i
+
+
)
{
SymbolicAccess
src
=
masm_
.
symbolicAccess
(
i
)
;
if
(
!
linkDataTier_
-
>
symbolicLinks
[
src
.
target
]
.
append
(
src
.
patchAt
.
offset
(
)
)
)
return
false
;
}
for
(
size_t
i
=
0
;
i
<
masm_
.
numCodeLabels
(
)
;
i
+
+
)
{
CodeLabel
cl
=
masm_
.
codeLabel
(
i
)
;
LinkDataTier
:
:
InternalLink
inLink
(
LinkDataTier
:
:
InternalLink
:
:
CodeLabel
)
;
inLink
.
patchAtOffset
=
masm_
.
labelToPatchOffset
(
*
cl
.
patchAt
(
)
)
;
inLink
.
targetOffset
=
cl
.
target
(
)
-
>
offset
(
)
;
if
(
!
linkDataTier_
-
>
internalLinks
.
append
(
inLink
)
)
return
false
;
}
return
true
;
}
bool
ModuleGenerator
:
:
addFuncImport
(
const
Sig
&
sig
uint32_t
globalDataOffset
)
{
MOZ_ASSERT
(
!
finishedFuncDefs_
)
;
Sig
copy
;
if
(
!
copy
.
clone
(
sig
)
)
return
false
;
return
metadataTier_
-
>
funcImports
.
emplaceBack
(
Move
(
copy
)
globalDataOffset
)
;
}
bool
ModuleGenerator
:
:
allocateGlobalBytes
(
uint32_t
bytes
uint32_t
align
uint32_t
*
globalDataOffset
)
{
CheckedInt
<
uint32_t
>
newGlobalDataLength
(
metadata_
-
>
globalDataLength
)
;
newGlobalDataLength
+
=
ComputeByteAlignment
(
newGlobalDataLength
.
value
(
)
align
)
;
if
(
!
newGlobalDataLength
.
isValid
(
)
)
return
false
;
*
globalDataOffset
=
newGlobalDataLength
.
value
(
)
;
newGlobalDataLength
+
=
bytes
;
if
(
!
newGlobalDataLength
.
isValid
(
)
)
return
false
;
metadata_
-
>
globalDataLength
=
newGlobalDataLength
.
value
(
)
;
return
true
;
}
bool
ModuleGenerator
:
:
allocateGlobal
(
GlobalDesc
*
global
)
{
MOZ_ASSERT
(
!
startedFuncDefs_
)
;
unsigned
width
=
0
;
switch
(
global
-
>
type
(
)
)
{
case
ValType
:
:
I32
:
case
ValType
:
:
F32
:
width
=
4
;
break
;
case
ValType
:
:
I64
:
case
ValType
:
:
F64
:
width
=
8
;
break
;
case
ValType
:
:
I8x16
:
case
ValType
:
:
I16x8
:
case
ValType
:
:
I32x4
:
case
ValType
:
:
F32x4
:
case
ValType
:
:
B8x16
:
case
ValType
:
:
B16x8
:
case
ValType
:
:
B32x4
:
width
=
16
;
break
;
}
uint32_t
offset
;
if
(
!
allocateGlobalBytes
(
width
width
&
offset
)
)
return
false
;
global
-
>
setOffset
(
offset
)
;
return
true
;
}
bool
ModuleGenerator
:
:
addGlobal
(
ValType
type
bool
isConst
uint32_t
*
index
)
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
MOZ_ASSERT
(
!
startedFuncDefs_
)
;
*
index
=
env_
-
>
globals
.
length
(
)
;
GlobalDesc
global
(
type
!
isConst
*
index
)
;
if
(
!
allocateGlobal
(
&
global
)
)
return
false
;
return
env_
-
>
globals
.
append
(
global
)
;
}
bool
ModuleGenerator
:
:
addExport
(
CacheableChars
&
&
fieldName
uint32_t
funcIndex
)
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
return
env_
-
>
exports
.
emplaceBack
(
Move
(
fieldName
)
funcIndex
DefinitionKind
:
:
Function
)
&
&
exportedFuncs_
.
put
(
funcIndex
)
;
}
void
ModuleGenerator
:
:
initSig
(
uint32_t
sigIndex
Sig
&
&
sig
)
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
MOZ_ASSERT
(
sigIndex
=
=
numSigs_
)
;
numSigs_
+
+
;
MOZ_ASSERT
(
env_
-
>
sigs
[
sigIndex
]
=
=
Sig
(
)
)
;
env_
-
>
sigs
[
sigIndex
]
=
Move
(
sig
)
;
}
const
SigWithId
&
ModuleGenerator
:
:
sig
(
uint32_t
index
)
const
{
MOZ_ASSERT
(
index
<
numSigs_
)
;
return
env_
-
>
sigs
[
index
]
;
}
void
ModuleGenerator
:
:
initFuncSig
(
uint32_t
funcIndex
uint32_t
sigIndex
)
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
MOZ_ASSERT
(
!
env_
-
>
funcSigs
[
funcIndex
]
)
;
env_
-
>
funcSigs
[
funcIndex
]
=
&
env_
-
>
sigs
[
sigIndex
]
;
}
void
ModuleGenerator
:
:
initMemoryUsage
(
MemoryUsage
memoryUsage
)
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
MOZ_ASSERT
(
env_
-
>
memoryUsage
=
=
MemoryUsage
:
:
None
)
;
env_
-
>
memoryUsage
=
memoryUsage
;
}
void
ModuleGenerator
:
:
bumpMinMemoryLength
(
uint32_t
newMinMemoryLength
)
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
MOZ_ASSERT
(
newMinMemoryLength
>
=
env_
-
>
minMemoryLength
)
;
env_
-
>
minMemoryLength
=
newMinMemoryLength
;
}
bool
ModuleGenerator
:
:
initImport
(
uint32_t
funcIndex
uint32_t
sigIndex
)
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
MOZ_ASSERT
(
!
env_
-
>
funcSigs
[
funcIndex
]
)
;
env_
-
>
funcSigs
[
funcIndex
]
=
&
env_
-
>
sigs
[
sigIndex
]
;
uint32_t
globalDataOffset
;
if
(
!
allocateGlobalBytes
(
sizeof
(
FuncImportTls
)
sizeof
(
void
*
)
&
globalDataOffset
)
)
return
false
;
MOZ_ASSERT
(
!
env_
-
>
funcImportGlobalDataOffsets
[
funcIndex
]
)
;
env_
-
>
funcImportGlobalDataOffsets
[
funcIndex
]
=
globalDataOffset
;
MOZ_ASSERT
(
funcIndex
=
=
metadataTier_
-
>
funcImports
.
length
(
)
)
;
return
addFuncImport
(
sig
(
sigIndex
)
globalDataOffset
)
;
}
uint32_t
ModuleGenerator
:
:
numFuncImports
(
)
const
{
MOZ_ASSERT_IF
(
isAsmJS
(
)
finishedFuncDefs_
)
;
return
metadataTier_
-
>
funcImports
.
length
(
)
;
}
const
SigWithId
&
ModuleGenerator
:
:
funcSig
(
uint32_t
funcIndex
)
const
{
MOZ_ASSERT
(
env_
-
>
funcSigs
[
funcIndex
]
)
;
return
*
env_
-
>
funcSigs
[
funcIndex
]
;
}
bool
ModuleGenerator
:
:
startFuncDefs
(
)
{
MOZ_ASSERT
(
!
startedFuncDefs_
)
;
MOZ_ASSERT
(
!
finishedFuncDefs_
)
;
GlobalHelperThreadState
&
threads
=
HelperThreadState
(
)
;
MOZ_ASSERT
(
threads
.
threadCount
>
1
)
;
uint32_t
numTasks
;
if
(
CanUseExtraThreads
(
)
&
&
threads
.
cpuCount
>
1
&
&
threads
.
wasmCompilationInProgress
(
compileMode_
)
.
compareExchange
(
false
true
)
)
{
#
ifdef
DEBUG
{
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
!
HelperThreadState
(
)
.
wasmFailed
(
lock
compileMode_
)
)
;
MOZ_ASSERT
(
HelperThreadState
(
)
.
wasmWorklist
(
lock
compileMode_
)
.
empty
(
)
)
;
MOZ_ASSERT
(
HelperThreadState
(
)
.
wasmFinishedList
(
lock
compileMode_
)
.
empty
(
)
)
;
}
#
endif
parallel_
=
true
;
numTasks
=
2
*
threads
.
maxWasmCompilationThreads
(
)
;
}
else
{
numTasks
=
1
;
}
if
(
!
tasks_
.
initCapacity
(
numTasks
)
)
return
false
;
for
(
size_t
i
=
0
;
i
<
numTasks
;
i
+
+
)
{
tasks_
.
infallibleEmplaceBack
(
*
env_
tier_
compileMode_
COMPILATION_LIFO_DEFAULT_CHUNK_SIZE
)
;
}
if
(
!
freeTasks_
.
reserve
(
numTasks
)
)
return
false
;
for
(
size_t
i
=
0
;
i
<
numTasks
;
i
+
+
)
freeTasks_
.
infallibleAppend
(
&
tasks_
[
i
]
)
;
startedFuncDefs_
=
true
;
MOZ_ASSERT
(
!
finishedFuncDefs_
)
;
return
true
;
}
bool
ModuleGenerator
:
:
startFuncDef
(
uint32_t
lineOrBytecode
FunctionGenerator
*
fg
)
{
MOZ_ASSERT
(
startedFuncDefs_
)
;
MOZ_ASSERT
(
!
activeFuncDef_
)
;
MOZ_ASSERT
(
!
finishedFuncDefs_
)
;
if
(
!
freeFuncBytes_
.
empty
(
)
)
{
fg
-
>
funcBytes_
=
Move
(
freeFuncBytes_
.
back
(
)
)
;
freeFuncBytes_
.
popBack
(
)
;
}
else
{
fg
-
>
funcBytes_
=
js
:
:
MakeUnique
<
FuncBytes
>
(
)
;
if
(
!
fg
-
>
funcBytes_
)
return
false
;
}
if
(
!
currentTask_
)
{
if
(
freeTasks_
.
empty
(
)
&
&
!
finishOutstandingTask
(
)
)
return
false
;
currentTask_
=
freeTasks_
.
popCopy
(
)
;
}
fg
-
>
funcBytes_
-
>
setLineOrBytecode
(
lineOrBytecode
)
;
fg
-
>
m_
=
this
;
activeFuncDef_
=
fg
;
return
true
;
}
bool
ModuleGenerator
:
:
launchBatchCompile
(
)
{
MOZ_ASSERT
(
currentTask_
)
;
currentTask_
-
>
setDebugEnabled
(
metadata_
-
>
debugEnabled
)
;
size_t
numBatchedFuncs
=
currentTask_
-
>
units
(
)
.
length
(
)
;
MOZ_ASSERT
(
numBatchedFuncs
)
;
if
(
parallel_
)
{
if
(
!
StartOffThreadWasmCompile
(
currentTask_
compileMode_
)
)
return
false
;
outstanding_
+
+
;
}
else
{
if
(
!
CompileFunction
(
currentTask_
error_
)
)
return
false
;
if
(
!
finishTask
(
currentTask_
)
)
return
false
;
}
currentTask_
=
nullptr
;
batchedBytecode_
=
0
;
numFinishedFuncDefs_
+
=
numBatchedFuncs
;
return
true
;
}
bool
ModuleGenerator
:
:
finishFuncDef
(
uint32_t
funcIndex
FunctionGenerator
*
fg
)
{
MOZ_ASSERT
(
activeFuncDef_
=
=
fg
)
;
MOZ_ASSERT_IF
(
compileMode_
=
=
CompileMode
:
:
Tier1
funcIndex
<
env_
-
>
numFuncs
(
)
)
;
UniqueFuncBytes
func
=
Move
(
fg
-
>
funcBytes_
)
;
func
-
>
setFunc
(
funcIndex
&
funcSig
(
funcIndex
)
)
;
uint32_t
funcBytecodeLength
=
func
-
>
bytes
(
)
.
length
(
)
;
if
(
!
currentTask_
-
>
units
(
)
.
emplaceBack
(
Move
(
func
)
)
)
return
false
;
uint32_t
threshold
;
switch
(
tier_
)
{
case
Tier
:
:
Baseline
:
threshold
=
JitOptions
.
wasmBatchBaselineThreshold
;
break
;
case
Tier
:
:
Ion
:
threshold
=
JitOptions
.
wasmBatchIonThreshold
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
tier
value
"
)
;
break
;
}
batchedBytecode_
+
=
funcBytecodeLength
;
MOZ_ASSERT
(
batchedBytecode_
<
=
MaxModuleBytes
)
;
if
(
batchedBytecode_
>
threshold
&
&
!
launchBatchCompile
(
)
)
return
false
;
fg
-
>
m_
=
nullptr
;
activeFuncDef_
=
nullptr
;
return
true
;
}
bool
ModuleGenerator
:
:
finishFuncDefs
(
)
{
MOZ_ASSERT
(
startedFuncDefs_
)
;
MOZ_ASSERT
(
!
activeFuncDef_
)
;
MOZ_ASSERT
(
!
finishedFuncDefs_
)
;
if
(
currentTask_
&
&
!
launchBatchCompile
(
)
)
return
false
;
while
(
outstanding_
>
0
)
{
if
(
!
finishOutstandingTask
(
)
)
return
false
;
}
linkDataTier_
-
>
functionCodeLength
=
masm_
.
size
(
)
;
finishedFuncDefs_
=
true
;
if
(
!
isAsmJS
(
)
)
{
for
(
size_t
funcIndex
=
0
;
funcIndex
<
numFuncImports
(
)
;
funcIndex
+
+
)
{
const
FuncImport
&
funcImport
=
metadataTier_
-
>
funcImports
[
funcIndex
]
;
const
SigWithId
&
sig
=
funcSig
(
funcIndex
)
;
FuncOffsets
offsets
=
GenerateImportFunction
(
masm_
funcImport
sig
.
id
)
;
if
(
masm_
.
oom
(
)
)
return
false
;
uint32_t
codeRangeIndex
=
metadataTier_
-
>
codeRanges
.
length
(
)
;
if
(
!
metadataTier_
-
>
codeRanges
.
emplaceBack
(
funcIndex
0
offsets
)
)
return
false
;
MOZ_ASSERT
(
!
funcIsCompiled
(
funcIndex
)
)
;
funcToCodeRange_
[
funcIndex
]
=
codeRangeIndex
;
}
}
#
ifdef
DEBUG
if
(
isAsmJS
(
)
)
{
MOZ_ASSERT
(
numFuncImports
(
)
<
AsmJSFirstDefFuncIndex
)
;
for
(
uint32_t
i
=
0
;
i
<
AsmJSFirstDefFuncIndex
;
i
+
+
)
MOZ_ASSERT
(
funcToCodeRange_
[
i
]
=
=
BAD_CODE_RANGE
)
;
for
(
uint32_t
i
=
AsmJSFirstDefFuncIndex
;
i
<
numFinishedFuncDefs_
;
i
+
+
)
MOZ_ASSERT
(
funcCodeRange
(
i
)
.
funcIndex
(
)
=
=
i
)
;
}
else
{
MOZ_ASSERT
(
numFinishedFuncDefs_
=
=
env_
-
>
numFuncDefs
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
env_
-
>
numFuncs
(
)
;
i
+
+
)
MOZ_ASSERT
(
funcCodeRange
(
i
)
.
funcIndex
(
)
=
=
i
)
;
}
#
endif
for
(
ElemSegment
&
elems
:
env_
-
>
elemSegments
)
{
Uint32Vector
&
codeRangeIndices
=
elems
.
elemCodeRangeIndices
(
tier_
)
;
MOZ_ASSERT
(
codeRangeIndices
.
empty
(
)
)
;
if
(
!
codeRangeIndices
.
reserve
(
elems
.
elemFuncIndices
.
length
(
)
)
)
return
false
;
for
(
uint32_t
funcIndex
:
elems
.
elemFuncIndices
)
codeRangeIndices
.
infallibleAppend
(
funcToCodeRange_
[
funcIndex
]
)
;
}
return
true
;
}
bool
ModuleGenerator
:
:
initSigTableLength
(
uint32_t
sigIndex
uint32_t
length
)
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
MOZ_ASSERT
(
length
!
=
0
)
;
MOZ_ASSERT
(
length
<
=
MaxTableInitialLength
)
;
MOZ_ASSERT
(
env_
-
>
asmJSSigToTableIndex
[
sigIndex
]
=
=
0
)
;
env_
-
>
asmJSSigToTableIndex
[
sigIndex
]
=
numTables_
;
TableDesc
&
table
=
env_
-
>
tables
[
numTables_
+
+
]
;
table
.
kind
=
TableKind
:
:
TypedFunction
;
table
.
limits
.
initial
=
length
;
table
.
limits
.
maximum
=
Some
(
length
)
;
return
allocateGlobalBytes
(
sizeof
(
TableTls
)
sizeof
(
void
*
)
&
table
.
globalDataOffset
)
;
}
bool
ModuleGenerator
:
:
initSigTableElems
(
uint32_t
sigIndex
Uint32Vector
&
&
elemFuncIndices
)
{
MOZ_ASSERT
(
isAsmJS
(
)
)
;
MOZ_ASSERT
(
finishedFuncDefs_
)
;
uint32_t
tableIndex
=
env_
-
>
asmJSSigToTableIndex
[
sigIndex
]
;
MOZ_ASSERT
(
env_
-
>
tables
[
tableIndex
]
.
limits
.
initial
=
=
elemFuncIndices
.
length
(
)
)
;
Uint32Vector
codeRangeIndices
;
if
(
!
codeRangeIndices
.
resize
(
elemFuncIndices
.
length
(
)
)
)
return
false
;
for
(
size_t
i
=
0
;
i
<
elemFuncIndices
.
length
(
)
;
i
+
+
)
codeRangeIndices
[
i
]
=
funcToCodeRange_
[
elemFuncIndices
[
i
]
]
;
InitExpr
offset
(
Val
(
uint32_t
(
0
)
)
)
;
if
(
!
env_
-
>
elemSegments
.
emplaceBack
(
tableIndex
offset
Move
(
elemFuncIndices
)
)
)
return
false
;
env_
-
>
elemSegments
.
back
(
)
.
elemCodeRangeIndices
(
tier_
)
=
Move
(
codeRangeIndices
)
;
return
true
;
}
static_assert
(
sizeof
(
ModuleHash
)
<
=
sizeof
(
mozilla
:
:
SHA1Sum
:
:
Hash
)
"
The
ModuleHash
size
shall
not
exceed
the
SHA1
hash
size
.
"
)
;
void
ModuleGenerator
:
:
generateBytecodeHash
(
const
ShareableBytes
&
bytecode
)
{
mozilla
:
:
SHA1Sum
:
:
Hash
hash
;
mozilla
:
:
SHA1Sum
sha1Sum
;
sha1Sum
.
update
(
bytecode
.
begin
(
)
bytecode
.
length
(
)
)
;
sha1Sum
.
finish
(
hash
)
;
memcpy
(
metadata_
-
>
hash
hash
sizeof
(
ModuleHash
)
)
;
}
SharedModule
ModuleGenerator
:
:
finish
(
const
ShareableBytes
&
bytecode
)
{
MOZ_ASSERT
(
!
activeFuncDef_
)
;
MOZ_ASSERT
(
finishedFuncDefs_
)
;
if
(
!
finishFuncExports
(
)
)
return
nullptr
;
if
(
!
finishCodegen
(
)
)
return
nullptr
;
if
(
!
metadataTier_
-
>
callSites
.
appendAll
(
masm_
.
callSites
(
)
)
)
return
nullptr
;
metadataTier_
-
>
memoryAccesses
=
masm_
.
extractMemoryAccesses
(
)
;
metadata_
-
>
memoryUsage
=
env_
-
>
memoryUsage
;
metadata_
-
>
minMemoryLength
=
env_
-
>
minMemoryLength
;
metadata_
-
>
maxMemoryLength
=
env_
-
>
maxMemoryLength
;
metadata_
-
>
tables
=
Move
(
env_
-
>
tables
)
;
metadata_
-
>
globals
=
Move
(
env_
-
>
globals
)
;
metadata_
-
>
funcNames
=
Move
(
env_
-
>
funcNames
)
;
metadata_
-
>
customSections
=
Move
(
env_
-
>
customSections
)
;
metadata_
-
>
debugFuncArgTypes
=
Move
(
debugFuncArgTypes_
)
;
metadata_
-
>
debugFuncReturnTypes
=
Move
(
debugFuncReturnTypes_
)
;
if
(
metadata_
-
>
debugEnabled
)
metadataTier_
-
>
debugFuncToCodeRange
=
Move
(
funcToCodeRange_
)
;
metadataTier_
-
>
memoryAccesses
.
podResizeToFit
(
)
;
metadataTier_
-
>
codeRanges
.
podResizeToFit
(
)
;
metadataTier_
-
>
callSites
.
podResizeToFit
(
)
;
metadataTier_
-
>
debugTrapFarJumpOffsets
.
podResizeToFit
(
)
;
metadataTier_
-
>
debugFuncToCodeRange
.
podResizeToFit
(
)
;
if
(
isAsmJS
(
)
&
&
!
metadata_
-
>
tables
.
resize
(
numTables_
)
)
return
nullptr
;
#
ifdef
DEBUG
uint32_t
lastEnd
=
0
;
for
(
const
CodeRange
&
codeRange
:
metadataTier_
-
>
codeRanges
)
{
MOZ_ASSERT
(
codeRange
.
begin
(
)
>
=
lastEnd
)
;
lastEnd
=
codeRange
.
end
(
)
;
}
#
endif
#
ifdef
DEBUG
uint32_t
lastOffset
=
0
;
for
(
uint32_t
debugTrapFarJumpOffset
:
metadataTier_
-
>
debugTrapFarJumpOffsets
)
{
MOZ_ASSERT
(
debugTrapFarJumpOffset
>
=
lastOffset
)
;
lastOffset
=
debugTrapFarJumpOffset
;
}
#
endif
if
(
!
finishLinkData
(
)
)
return
nullptr
;
generateBytecodeHash
(
bytecode
)
;
UniqueConstCodeSegment
codeSegment
=
CodeSegment
:
:
create
(
tier_
masm_
bytecode
*
linkDataTier_
*
metadata_
)
;
if
(
!
codeSegment
)
return
nullptr
;
UniqueConstBytes
maybeDebuggingBytes
;
if
(
metadata_
-
>
debugEnabled
)
{
Bytes
bytes
;
if
(
!
bytes
.
resize
(
masm_
.
bytesNeeded
(
)
)
)
return
nullptr
;
masm_
.
executableCopy
(
bytes
.
begin
(
)
false
)
;
maybeDebuggingBytes
=
js
:
:
MakeUnique
<
Bytes
>
(
Move
(
bytes
)
)
;
if
(
!
maybeDebuggingBytes
)
return
nullptr
;
}
SharedCode
code
=
js_new
<
Code
>
(
Move
(
codeSegment
)
*
metadata_
)
;
if
(
!
code
)
return
nullptr
;
return
SharedModule
(
js_new
<
Module
>
(
Move
(
assumptions_
)
*
code
Move
(
maybeDebuggingBytes
)
Move
(
linkData_
)
Move
(
env_
-
>
imports
)
Move
(
env_
-
>
exports
)
Move
(
env_
-
>
dataSegments
)
Move
(
env_
-
>
elemSegments
)
bytecode
)
)
;
}
bool
wasm
:
:
CompileFunction
(
CompileTask
*
task
UniqueChars
*
error
)
{
TraceLoggerThread
*
logger
=
TraceLoggerForCurrentThread
(
)
;
AutoTraceLog
logCompile
(
logger
TraceLogger_WasmCompilation
)
;
switch
(
task
-
>
tier
(
)
)
{
case
Tier
:
:
Ion
:
for
(
FuncCompileUnit
&
unit
:
task
-
>
units
(
)
)
{
if
(
!
IonCompileFunction
(
task
&
unit
error
)
)
return
false
;
}
break
;
case
Tier
:
:
Baseline
:
for
(
FuncCompileUnit
&
unit
:
task
-
>
units
(
)
)
{
if
(
!
BaselineCompileFunction
(
task
&
unit
error
)
)
return
false
;
}
break
;
default
:
MOZ_CRASH
(
"
Invalid
tier
value
"
)
;
}
return
true
;
}
