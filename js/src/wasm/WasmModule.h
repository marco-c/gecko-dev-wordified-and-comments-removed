#
ifndef
wasm_module_h
#
define
wasm_module_h
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
wasm
/
WasmCode
.
h
"
#
include
"
wasm
/
WasmTable
.
h
"
namespace
js
{
namespace
wasm
{
struct
LinkDataTierCacheablePod
{
uint32_t
functionCodeLength
;
uint32_t
interruptOffset
;
uint32_t
outOfBoundsOffset
;
uint32_t
unalignedAccessOffset
;
LinkDataTierCacheablePod
(
)
{
mozilla
:
:
PodZero
(
this
)
;
}
}
;
struct
LinkDataTier
:
LinkDataTierCacheablePod
{
const
Tier
tier
;
explicit
LinkDataTier
(
Tier
tier
)
:
tier
(
tier
)
{
MOZ_ASSERT
(
tier
=
=
Tier
:
:
Baseline
|
|
tier
=
=
Tier
:
:
Ion
)
;
}
LinkDataTierCacheablePod
&
pod
(
)
{
return
*
this
;
}
const
LinkDataTierCacheablePod
&
pod
(
)
const
{
return
*
this
;
}
struct
InternalLink
{
enum
Kind
{
RawPointer
CodeLabel
InstructionImmediate
}
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
patchAtOffset
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
targetOffset
;
InternalLink
(
)
=
default
;
explicit
InternalLink
(
Kind
kind
)
;
bool
isRawPointerPatch
(
)
;
}
;
typedef
Vector
<
InternalLink
0
SystemAllocPolicy
>
InternalLinkVector
;
struct
SymbolicLinkArray
:
EnumeratedArray
<
SymbolicAddress
SymbolicAddress
:
:
Limit
Uint32Vector
>
{
WASM_DECLARE_SERIALIZABLE
(
SymbolicLinkArray
)
}
;
InternalLinkVector
internalLinks
;
SymbolicLinkArray
symbolicLinks
;
WASM_DECLARE_SERIALIZABLE
(
LinkData
)
}
;
typedef
UniquePtr
<
LinkDataTier
>
UniqueLinkDataTier
;
struct
LinkData
{
UniqueLinkDataTier
tier_
;
LinkData
(
)
:
tier_
(
nullptr
)
{
}
bool
initTier
(
Tier
tier
)
;
Tiers
tiers
(
)
const
;
const
LinkDataTier
&
linkData
(
Tier
tier
)
const
;
LinkDataTier
&
linkData
(
Tier
tier
)
;
WASM_DECLARE_SERIALIZABLE
(
LinkData
)
}
;
class
Module
:
public
JS
:
:
WasmModule
{
const
Assumptions
assumptions_
;
const
SharedCode
code_
;
const
UniqueConstBytes
unlinkedCodeForDebugging_
;
const
LinkData
linkData_
;
const
ImportVector
imports_
;
const
ExportVector
exports_
;
const
DataSegmentVector
dataSegments_
;
const
ElemSegmentVector
elemSegments_
;
const
SharedBytes
bytecode_
;
mutable
mozilla
:
:
Atomic
<
bool
>
codeIsBusy_
;
bool
instantiateFunctions
(
JSContext
*
cx
Handle
<
FunctionVector
>
funcImports
)
const
;
bool
instantiateMemory
(
JSContext
*
cx
MutableHandleWasmMemoryObject
memory
)
const
;
bool
instantiateTable
(
JSContext
*
cx
MutableHandleWasmTableObject
table
SharedTableVector
*
tables
)
const
;
bool
initSegments
(
JSContext
*
cx
HandleWasmInstanceObject
instance
Handle
<
FunctionVector
>
funcImports
HandleWasmMemoryObject
memory
const
ValVector
&
globalImports
)
const
;
public
:
Module
(
Assumptions
&
&
assumptions
const
Code
&
code
UniqueConstBytes
unlinkedCodeForDebugging
LinkData
&
&
linkData
ImportVector
&
&
imports
ExportVector
&
&
exports
DataSegmentVector
&
&
dataSegments
ElemSegmentVector
&
&
elemSegments
const
ShareableBytes
&
bytecode
)
:
assumptions_
(
Move
(
assumptions
)
)
code_
(
&
code
)
unlinkedCodeForDebugging_
(
Move
(
unlinkedCodeForDebugging
)
)
linkData_
(
Move
(
linkData
)
)
imports_
(
Move
(
imports
)
)
exports_
(
Move
(
exports
)
)
dataSegments_
(
Move
(
dataSegments
)
)
elemSegments_
(
Move
(
elemSegments
)
)
bytecode_
(
&
bytecode
)
codeIsBusy_
(
false
)
{
MOZ_ASSERT_IF
(
metadata
(
)
.
debugEnabled
unlinkedCodeForDebugging_
)
;
}
~
Module
(
)
override
{
}
const
Code
&
code
(
)
const
{
return
*
code_
;
}
const
Metadata
&
metadata
(
)
const
{
return
code_
-
>
metadata
(
)
;
}
const
MetadataTier
&
metadata
(
Tier
t
)
const
{
return
code_
-
>
metadata
(
t
)
;
}
const
ImportVector
&
imports
(
)
const
{
return
imports_
;
}
const
ExportVector
&
exports
(
)
const
{
return
exports_
;
}
const
Bytes
&
bytecode
(
)
const
{
return
bytecode_
-
>
bytes
;
}
uint32_t
codeLength
(
Tier
t
)
const
{
return
code_
-
>
segment
(
t
)
.
length
(
)
;
}
bool
instantiate
(
JSContext
*
cx
Handle
<
FunctionVector
>
funcImports
HandleWasmTableObject
tableImport
HandleWasmMemoryObject
memoryImport
const
ValVector
&
globalImports
HandleObject
instanceProto
MutableHandleWasmInstanceObject
instanceObj
)
const
;
size_t
bytecodeSerializedSize
(
)
const
override
;
void
bytecodeSerialize
(
uint8_t
*
bytecodeBegin
size_t
bytecodeSize
)
const
override
;
size_t
compiledSerializedSize
(
)
const
override
;
void
compiledSerialize
(
uint8_t
*
compiledBegin
size_t
compiledSize
)
const
override
;
static
bool
assumptionsMatch
(
const
Assumptions
&
current
const
uint8_t
*
compiledBegin
size_t
remain
)
;
static
RefPtr
<
Module
>
deserialize
(
const
uint8_t
*
bytecodeBegin
size_t
bytecodeSize
const
uint8_t
*
compiledBegin
size_t
compiledSize
Metadata
*
maybeMetadata
=
nullptr
)
;
JSObject
*
createObject
(
JSContext
*
cx
)
override
;
void
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
Metadata
:
:
SeenSet
*
seenMetadata
ShareableBytes
:
:
SeenSet
*
seenBytes
Code
:
:
SeenSet
*
seenCode
size_t
*
code
size_t
*
data
)
const
;
bool
extractCode
(
JSContext
*
cx
MutableHandleValue
vp
)
const
;
}
;
typedef
RefPtr
<
Module
>
SharedModule
;
bool
CompiledModuleAssumptionsMatch
(
PRFileDesc
*
compiled
JS
:
:
BuildIdCharVector
&
&
buildId
)
;
SharedModule
DeserializeModule
(
PRFileDesc
*
bytecode
PRFileDesc
*
maybeCompiled
JS
:
:
BuildIdCharVector
&
&
buildId
UniqueChars
filename
unsigned
line
unsigned
column
)
;
}
}
#
endif
