#
ifndef
wasm_val_h
#
define
wasm_val_h
#
include
"
js
/
Class
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
wasm
/
WasmValType
.
h
"
namespace
js
{
namespace
wasm
{
struct
V128
{
uint8_t
bytes
[
16
]
;
V128
(
)
{
memset
(
bytes
0
sizeof
(
bytes
)
)
;
}
template
<
typename
T
>
T
extractLane
(
unsigned
lane
)
const
{
T
result
;
MOZ_ASSERT
(
lane
<
16
/
sizeof
(
T
)
)
;
memcpy
(
&
result
bytes
+
sizeof
(
T
)
*
lane
sizeof
(
T
)
)
;
return
result
;
}
template
<
typename
T
>
void
insertLane
(
unsigned
lane
T
value
)
{
MOZ_ASSERT
(
lane
<
16
/
sizeof
(
T
)
)
;
memcpy
(
bytes
+
sizeof
(
T
)
*
lane
&
value
sizeof
(
T
)
)
;
}
bool
operator
=
=
(
const
V128
&
rhs
)
const
{
for
(
size_t
i
=
0
;
i
<
sizeof
(
bytes
)
;
i
+
+
)
{
if
(
bytes
[
i
]
!
=
rhs
.
bytes
[
i
]
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
V128
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
}
;
static_assert
(
sizeof
(
V128
)
=
=
16
"
Invariant
"
)
;
class
AnyRef
{
mutable
JSObject
*
value_
;
explicit
AnyRef
(
)
:
value_
(
(
JSObject
*
)
-
1
)
{
}
explicit
AnyRef
(
JSObject
*
p
)
:
value_
(
p
)
{
MOZ_ASSERT
(
(
(
uintptr_t
)
p
&
0x03
)
=
=
0
)
;
}
public
:
static
AnyRef
invalid
(
)
{
return
AnyRef
(
)
;
}
static
AnyRef
fromCompiledCode
(
void
*
p
)
{
return
AnyRef
(
(
JSObject
*
)
p
)
;
}
static
AnyRef
fromJSObject
(
JSObject
*
p
)
{
return
AnyRef
(
p
)
;
}
static
AnyRef
null
(
)
{
return
AnyRef
(
nullptr
)
;
}
bool
isNull
(
)
const
{
return
value_
=
=
nullptr
;
}
bool
operator
=
=
(
const
AnyRef
&
rhs
)
const
{
return
this
-
>
value_
=
=
rhs
.
value_
;
}
bool
operator
!
=
(
const
AnyRef
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
void
*
forCompiledCode
(
)
const
{
return
value_
;
}
JSObject
*
asJSObject
(
)
const
{
return
value_
;
}
JSObject
*
*
asJSObjectAddress
(
)
const
{
return
&
value_
;
}
void
trace
(
JSTracer
*
trc
)
;
static
constexpr
uintptr_t
AnyRefTagMask
=
1
;
static
constexpr
uintptr_t
AnyRefObjTag
=
0
;
}
;
using
RootedAnyRef
=
Rooted
<
AnyRef
>
;
using
HandleAnyRef
=
Handle
<
AnyRef
>
;
using
MutableHandleAnyRef
=
MutableHandle
<
AnyRef
>
;
#
define
ASSERT_ANYREF_IS_JSOBJECT
(
void
)
(
0
)
#
define
STATIC_ASSERT_ANYREF_IS_JSOBJECT
static_assert
(
1
"
AnyRef
is
JSObject
"
)
bool
BoxAnyRef
(
JSContext
*
cx
HandleValue
val
MutableHandleAnyRef
result
)
;
JSObject
*
BoxBoxableValue
(
JSContext
*
cx
HandleValue
val
)
;
Value
UnboxAnyRef
(
AnyRef
val
)
;
class
WasmValueBox
:
public
NativeObject
{
static
const
unsigned
VALUE_SLOT
=
0
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
1
;
static
const
JSClass
class_
;
static
WasmValueBox
*
create
(
JSContext
*
cx
HandleValue
val
)
;
Value
value
(
)
const
{
return
getFixedSlot
(
VALUE_SLOT
)
;
}
static
size_t
offsetOfValue
(
)
{
return
NativeObject
:
:
getFixedSlotOffset
(
VALUE_SLOT
)
;
}
}
;
class
FuncRef
{
JSFunction
*
value_
;
explicit
FuncRef
(
)
:
value_
(
(
JSFunction
*
)
-
1
)
{
}
explicit
FuncRef
(
JSFunction
*
p
)
:
value_
(
p
)
{
MOZ_ASSERT
(
(
(
uintptr_t
)
p
&
0x03
)
=
=
0
)
;
}
public
:
static
FuncRef
fromCompiledCode
(
void
*
p
)
{
return
FuncRef
(
(
JSFunction
*
)
p
)
;
}
static
FuncRef
fromJSFunction
(
JSFunction
*
p
)
{
return
FuncRef
(
p
)
;
}
static
FuncRef
fromAnyRefUnchecked
(
AnyRef
p
)
;
AnyRef
asAnyRef
(
)
{
return
AnyRef
:
:
fromJSObject
(
(
JSObject
*
)
value_
)
;
}
void
*
forCompiledCode
(
)
const
{
return
value_
;
}
JSFunction
*
asJSFunction
(
)
{
return
value_
;
}
bool
isNull
(
)
{
return
value_
=
=
nullptr
;
}
}
;
using
RootedFuncRef
=
Rooted
<
FuncRef
>
;
using
HandleFuncRef
=
Handle
<
FuncRef
>
;
using
MutableHandleFuncRef
=
MutableHandle
<
FuncRef
>
;
Value
UnboxFuncRef
(
FuncRef
val
)
;
class
LitVal
{
public
:
union
Cell
{
int32_t
i32_
;
int64_t
i64_
;
float
f32_
;
double
f64_
;
wasm
:
:
V128
v128_
;
wasm
:
:
AnyRef
ref_
;
Cell
(
)
:
v128_
(
)
{
}
~
Cell
(
)
=
default
;
}
;
protected
:
ValType
type_
;
Cell
cell_
;
public
:
LitVal
(
)
:
type_
(
ValType
(
)
)
cell_
{
}
{
}
explicit
LitVal
(
ValType
type
)
:
type_
(
type
)
{
MOZ_ASSERT
(
type
.
isDefaultable
(
)
)
;
switch
(
type
.
kind
(
)
)
{
case
ValType
:
:
Kind
:
:
I32
:
{
cell_
.
i32_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
I64
:
{
cell_
.
i64_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
F32
:
{
cell_
.
f32_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
F64
:
{
cell_
.
f64_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
V128
:
{
new
(
&
cell_
.
v128_
)
V128
(
)
;
break
;
}
case
ValType
:
:
Kind
:
:
Ref
:
{
cell_
.
ref_
=
AnyRef
:
:
null
(
)
;
break
;
}
case
ValType
:
:
Kind
:
:
Rtt
:
{
MOZ_CRASH
(
"
not
defaultable
"
)
;
}
}
}
explicit
LitVal
(
uint32_t
i32
)
:
type_
(
ValType
:
:
I32
)
{
cell_
.
i32_
=
i32
;
}
explicit
LitVal
(
uint64_t
i64
)
:
type_
(
ValType
:
:
I64
)
{
cell_
.
i64_
=
i64
;
}
explicit
LitVal
(
float
f32
)
:
type_
(
ValType
:
:
F32
)
{
cell_
.
f32_
=
f32
;
}
explicit
LitVal
(
double
f64
)
:
type_
(
ValType
:
:
F64
)
{
cell_
.
f64_
=
f64
;
}
explicit
LitVal
(
V128
v128
)
:
type_
(
ValType
:
:
V128
)
{
cell_
.
v128_
=
v128
;
}
explicit
LitVal
(
ValType
type
AnyRef
any
)
:
type_
(
type
)
{
MOZ_ASSERT
(
type
.
isReference
(
)
)
;
MOZ_ASSERT
(
any
.
isNull
(
)
"
use
Val
for
non
-
nullptr
ref
types
to
get
tracing
"
)
;
cell_
.
ref_
=
any
;
}
ValType
type
(
)
const
{
return
type_
;
}
static
constexpr
size_t
sizeofLargestValue
(
)
{
return
sizeof
(
cell_
)
;
}
Cell
&
cell
(
)
{
return
cell_
;
}
const
Cell
&
cell
(
)
const
{
return
cell_
;
}
uint32_t
i32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I32
)
;
return
cell_
.
i32_
;
}
uint64_t
i64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I64
)
;
return
cell_
.
i64_
;
}
const
float
&
f32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F32
)
;
return
cell_
.
f32_
;
}
const
double
&
f64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F64
)
;
return
cell_
.
f64_
;
}
AnyRef
ref
(
)
const
{
MOZ_ASSERT
(
type_
.
isReference
(
)
)
;
return
cell_
.
ref_
;
}
const
V128
&
v128
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
V128
)
;
return
cell_
.
v128_
;
}
}
;
class
MOZ_NON_PARAM
Val
:
public
LitVal
{
public
:
Val
(
)
:
LitVal
(
)
{
}
explicit
Val
(
ValType
type
)
:
LitVal
(
type
)
{
}
explicit
Val
(
const
LitVal
&
val
)
;
explicit
Val
(
uint32_t
i32
)
:
LitVal
(
i32
)
{
}
explicit
Val
(
uint64_t
i64
)
:
LitVal
(
i64
)
{
}
explicit
Val
(
float
f32
)
:
LitVal
(
f32
)
{
}
explicit
Val
(
double
f64
)
:
LitVal
(
f64
)
{
}
explicit
Val
(
V128
v128
)
:
LitVal
(
v128
)
{
}
explicit
Val
(
ValType
type
AnyRef
val
)
:
LitVal
(
type
AnyRef
:
:
null
(
)
)
{
MOZ_ASSERT
(
type
.
isReference
(
)
)
;
cell_
.
ref_
=
val
;
}
explicit
Val
(
ValType
type
FuncRef
val
)
:
LitVal
(
type
AnyRef
:
:
null
(
)
)
{
MOZ_ASSERT
(
type
.
isFuncRef
(
)
)
;
cell_
.
ref_
=
val
.
asAnyRef
(
)
;
}
Val
(
const
Val
&
)
=
default
;
Val
&
operator
=
(
const
Val
&
)
=
default
;
bool
operator
=
=
(
const
Val
&
rhs
)
const
{
if
(
type_
!
=
rhs
.
type_
)
{
return
false
;
}
switch
(
type_
.
kind
(
)
)
{
case
ValType
:
:
I32
:
return
cell_
.
i32_
=
=
rhs
.
cell_
.
i32_
;
case
ValType
:
:
I64
:
return
cell_
.
i64_
=
=
rhs
.
cell_
.
i64_
;
case
ValType
:
:
F32
:
return
cell_
.
f32_
=
=
rhs
.
cell_
.
f32_
;
case
ValType
:
:
F64
:
return
cell_
.
f64_
=
=
rhs
.
cell_
.
f64_
;
case
ValType
:
:
V128
:
return
cell_
.
v128_
=
=
rhs
.
cell_
.
v128_
;
case
ValType
:
:
Rtt
:
case
ValType
:
:
Ref
:
return
cell_
.
ref_
=
=
rhs
.
cell_
.
ref_
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
false
;
}
bool
operator
!
=
(
const
Val
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
isJSObject
(
)
const
{
return
type_
.
isValid
(
)
&
&
type_
.
isReference
(
)
&
&
!
cell_
.
ref_
.
isNull
(
)
;
}
JSObject
*
asJSObject
(
)
const
{
MOZ_ASSERT
(
isJSObject
(
)
)
;
return
cell_
.
ref_
.
asJSObject
(
)
;
}
JSObject
*
*
asJSObjectAddress
(
)
const
{
return
cell_
.
ref_
.
asJSObjectAddress
(
)
;
}
void
readFromRootedLocation
(
const
void
*
loc
)
;
void
writeToRootedLocation
(
void
*
loc
bool
mustWrite64
)
const
;
static
bool
fromJSValue
(
JSContext
*
cx
ValType
targetType
HandleValue
val
MutableHandle
<
Val
>
rval
)
;
bool
toJSValue
(
JSContext
*
cx
MutableHandleValue
rval
)
const
;
void
trace
(
JSTracer
*
trc
)
const
;
}
;
using
GCPtrVal
=
GCPtr
<
Val
>
;
using
RootedVal
=
Rooted
<
Val
>
;
using
HandleVal
=
Handle
<
Val
>
;
using
MutableHandleVal
=
MutableHandle
<
Val
>
;
using
ValVector
=
GCVector
<
Val
0
SystemAllocPolicy
>
;
using
RootedValVector
=
Rooted
<
ValVector
>
;
using
HandleValVector
=
Handle
<
ValVector
>
;
using
MutableHandleValVector
=
MutableHandle
<
ValVector
>
;
[
[
nodiscard
]
]
extern
bool
CheckRefType
(
JSContext
*
cx
RefType
targetType
HandleValue
v
MutableHandleFunction
fnval
MutableHandleAnyRef
refval
)
;
[
[
nodiscard
]
]
extern
bool
CheckFuncRefValue
(
JSContext
*
cx
HandleValue
v
MutableHandleFunction
fun
)
;
[
[
nodiscard
]
]
extern
bool
CheckEqRefValue
(
JSContext
*
cx
HandleValue
v
MutableHandleAnyRef
vp
)
;
class
NoDebug
;
class
DebugCodegenVal
;
enum
class
CoercionLevel
{
Spec
Lossless
}
;
template
<
typename
Debug
=
NoDebug
>
extern
bool
ToWebAssemblyValue
(
JSContext
*
cx
HandleValue
val
FieldType
type
void
*
loc
bool
mustWrite64
CoercionLevel
level
=
CoercionLevel
:
:
Spec
)
;
template
<
typename
Debug
=
NoDebug
>
extern
bool
ToWebAssemblyValue
(
JSContext
*
cx
HandleValue
val
ValType
type
void
*
loc
bool
mustWrite64
CoercionLevel
level
=
CoercionLevel
:
:
Spec
)
;
template
<
typename
Debug
=
NoDebug
>
extern
bool
ToJSValue
(
JSContext
*
cx
const
void
*
src
FieldType
type
MutableHandleValue
dst
CoercionLevel
level
=
CoercionLevel
:
:
Spec
)
;
template
<
typename
Debug
=
NoDebug
>
extern
bool
ToJSValue
(
JSContext
*
cx
const
void
*
src
ValType
type
MutableHandleValue
dst
CoercionLevel
level
=
CoercionLevel
:
:
Spec
)
;
}
template
<
>
struct
InternalBarrierMethods
<
wasm
:
:
Val
>
{
STATIC_ASSERT_ANYREF_IS_JSOBJECT
;
static
bool
isMarkable
(
const
wasm
:
:
Val
&
v
)
{
return
v
.
isJSObject
(
)
;
}
static
void
preBarrier
(
const
wasm
:
:
Val
&
v
)
{
if
(
v
.
isJSObject
(
)
)
{
gc
:
:
PreWriteBarrier
(
v
.
asJSObject
(
)
)
;
}
}
static
MOZ_ALWAYS_INLINE
void
postBarrier
(
wasm
:
:
Val
*
vp
const
wasm
:
:
Val
&
prev
const
wasm
:
:
Val
&
next
)
{
MOZ_RELEASE_ASSERT
(
!
prev
.
type
(
)
.
isValid
(
)
|
|
prev
.
type
(
)
=
=
next
.
type
(
)
)
;
JSObject
*
prevObj
=
prev
.
isJSObject
(
)
?
prev
.
asJSObject
(
)
:
nullptr
;
JSObject
*
nextObj
=
next
.
isJSObject
(
)
?
next
.
asJSObject
(
)
:
nullptr
;
if
(
nextObj
)
{
JSObject
:
:
postWriteBarrier
(
vp
-
>
asJSObjectAddress
(
)
prevObj
nextObj
)
;
}
}
static
void
readBarrier
(
const
wasm
:
:
Val
&
v
)
{
if
(
v
.
isJSObject
(
)
)
{
gc
:
:
ReadBarrier
(
v
.
asJSObject
(
)
)
;
}
}
#
ifdef
DEBUG
static
void
assertThingIsNotGray
(
const
wasm
:
:
Val
&
v
)
{
if
(
v
.
isJSObject
(
)
)
{
JS
:
:
AssertObjectIsNotGray
(
v
.
asJSObject
(
)
)
;
}
}
#
endif
}
;
}
#
endif
