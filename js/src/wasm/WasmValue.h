#
ifndef
wasm_val_h
#
define
wasm_val_h
#
include
<
string
.
h
>
#
include
"
js
/
Class
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
wasm
/
WasmAnyRef
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
#
include
"
wasm
/
WasmTypeDef
.
h
"
namespace
js
{
namespace
wasm
{
struct
V128
{
uint8_t
bytes
[
16
]
=
{
}
;
WASM_CHECK_CACHEABLE_POD
(
bytes
)
;
V128
(
)
=
default
;
explicit
V128
(
uint8_t
splatValue
)
{
memset
(
bytes
int
(
splatValue
)
sizeof
(
bytes
)
)
;
}
template
<
typename
T
>
void
extractLane
(
unsigned
lane
T
*
result
)
const
{
MOZ_ASSERT
(
lane
<
16
/
sizeof
(
T
)
)
;
memcpy
(
result
bytes
+
sizeof
(
T
)
*
lane
sizeof
(
T
)
)
;
}
template
<
typename
T
>
void
insertLane
(
unsigned
lane
T
value
)
{
MOZ_ASSERT
(
lane
<
16
/
sizeof
(
T
)
)
;
memcpy
(
bytes
+
sizeof
(
T
)
*
lane
&
value
sizeof
(
T
)
)
;
}
bool
operator
=
=
(
const
V128
&
rhs
)
const
{
return
memcmp
(
bytes
rhs
.
bytes
sizeof
(
bytes
)
)
=
=
0
;
}
bool
operator
!
=
(
const
V128
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
}
;
WASM_DECLARE_CACHEABLE_POD
(
V128
)
;
static_assert
(
sizeof
(
V128
)
=
=
16
"
Invariant
"
)
;
class
FuncRef
{
mutable
JSFunction
*
value_
;
explicit
FuncRef
(
)
:
value_
(
(
JSFunction
*
)
-
1
)
{
}
explicit
FuncRef
(
JSFunction
*
p
)
:
value_
(
p
)
{
MOZ_ASSERT
(
(
(
uintptr_t
)
p
&
0x03
)
=
=
0
)
;
}
public
:
static
FuncRef
fromCompiledCode
(
void
*
p
)
{
return
FuncRef
(
(
JSFunction
*
)
p
)
;
}
static
FuncRef
fromJSFunction
(
JSFunction
*
p
)
{
return
FuncRef
(
p
)
;
}
static
FuncRef
fromAnyRefUnchecked
(
AnyRef
p
)
;
static
FuncRef
null
(
)
{
return
FuncRef
(
nullptr
)
;
}
AnyRef
toAnyRef
(
)
{
return
AnyRef
:
:
fromJSObjectOrNull
(
(
JSObject
*
)
value_
)
;
}
void
*
forCompiledCode
(
)
const
{
return
value_
;
}
JSFunction
*
asJSFunction
(
)
{
return
value_
;
}
bool
isNull
(
)
const
{
return
value_
=
=
nullptr
;
}
void
trace
(
JSTracer
*
trc
)
const
;
}
;
using
RootedFuncRef
=
Rooted
<
FuncRef
>
;
using
HandleFuncRef
=
Handle
<
FuncRef
>
;
using
MutableHandleFuncRef
=
MutableHandle
<
FuncRef
>
;
Value
UnboxFuncRef
(
FuncRef
val
)
;
class
LitVal
{
public
:
union
Cell
{
uint32_t
i32_
;
uint64_t
i64_
;
float
f32_
;
double
f64_
;
wasm
:
:
V128
v128_
;
mutable
wasm
:
:
AnyRef
ref_
;
Cell
(
)
:
v128_
(
)
{
}
~
Cell
(
)
=
default
;
WASM_CHECK_CACHEABLE_POD
(
i32_
i64_
f32_
f64_
v128_
)
;
WASM_ALLOW_NON_CACHEABLE_POD_FIELD
(
ref_
"
The
pointer
value
in
ref_
is
guaranteed
to
always
be
null
in
a
"
"
LitVal
.
"
)
;
}
;
protected
:
ValType
type_
;
Cell
cell_
;
public
:
LitVal
(
)
=
default
;
explicit
LitVal
(
ValType
type
)
:
type_
(
type
)
{
switch
(
type
.
kind
(
)
)
{
case
ValType
:
:
Kind
:
:
I32
:
{
cell_
.
i32_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
I64
:
{
cell_
.
i64_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
F32
:
{
cell_
.
f32_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
F64
:
{
cell_
.
f64_
=
0
;
break
;
}
case
ValType
:
:
Kind
:
:
V128
:
{
new
(
&
cell_
.
v128_
)
V128
(
)
;
break
;
}
case
ValType
:
:
Kind
:
:
Ref
:
{
cell_
.
ref_
=
nullptr
;
break
;
}
}
}
explicit
LitVal
(
uint32_t
i32
)
:
type_
(
ValType
:
:
I32
)
{
cell_
.
i32_
=
i32
;
}
explicit
LitVal
(
uint64_t
i64
)
:
type_
(
ValType
:
:
I64
)
{
cell_
.
i64_
=
i64
;
}
explicit
LitVal
(
float
f32
)
:
type_
(
ValType
:
:
F32
)
{
cell_
.
f32_
=
f32
;
}
explicit
LitVal
(
double
f64
)
:
type_
(
ValType
:
:
F64
)
{
cell_
.
f64_
=
f64
;
}
explicit
LitVal
(
V128
v128
)
:
type_
(
ValType
:
:
V128
)
{
cell_
.
v128_
=
v128
;
}
explicit
LitVal
(
ValType
type
AnyRef
any
)
:
type_
(
type
)
{
MOZ_ASSERT
(
type
.
isRefRepr
(
)
)
;
MOZ_ASSERT
(
any
.
isNull
(
)
"
use
Val
for
non
-
nullptr
ref
types
to
get
tracing
"
)
;
cell_
.
ref_
=
any
;
}
ValType
type
(
)
const
{
return
type_
;
}
static
constexpr
size_t
sizeofLargestValue
(
)
{
return
sizeof
(
cell_
)
;
}
Cell
&
cell
(
)
{
return
cell_
;
}
const
Cell
&
cell
(
)
const
{
return
cell_
;
}
void
unsafeSetType
(
ValType
type
)
{
type_
=
type
;
}
uint32_t
i32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I32
)
;
return
cell_
.
i32_
;
}
uint64_t
i64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
I64
)
;
return
cell_
.
i64_
;
}
const
float
&
f32
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F32
)
;
return
cell_
.
f32_
;
}
const
double
&
f64
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
F64
)
;
return
cell_
.
f64_
;
}
AnyRef
ref
(
)
const
{
MOZ_ASSERT
(
type_
.
isRefRepr
(
)
)
;
return
cell_
.
ref_
;
}
const
V128
&
v128
(
)
const
{
MOZ_ASSERT
(
type_
=
=
ValType
:
:
V128
)
;
return
cell_
.
v128_
;
}
WASM_DECLARE_FRIEND_SERIALIZE
(
LitVal
)
;
}
;
WASM_DECLARE_CACHEABLE_POD
(
LitVal
:
:
Cell
)
;
class
MOZ_NON_PARAM
Val
:
public
LitVal
{
public
:
Val
(
)
=
default
;
explicit
Val
(
ValType
type
)
:
LitVal
(
type
)
{
}
explicit
Val
(
const
LitVal
&
val
)
;
explicit
Val
(
uint32_t
i32
)
:
LitVal
(
i32
)
{
}
explicit
Val
(
uint64_t
i64
)
:
LitVal
(
i64
)
{
}
explicit
Val
(
float
f32
)
:
LitVal
(
f32
)
{
}
explicit
Val
(
double
f64
)
:
LitVal
(
f64
)
{
}
explicit
Val
(
V128
v128
)
:
LitVal
(
v128
)
{
}
explicit
Val
(
ValType
type
AnyRef
val
)
:
LitVal
(
type
AnyRef
:
:
null
(
)
)
{
MOZ_ASSERT
(
type
.
isRefRepr
(
)
)
;
cell_
.
ref_
=
val
;
}
explicit
Val
(
ValType
type
FuncRef
val
)
:
LitVal
(
type
AnyRef
:
:
null
(
)
)
{
MOZ_ASSERT
(
type
.
refType
(
)
.
isFuncHierarchy
(
)
)
;
cell_
.
ref_
=
val
.
toAnyRef
(
)
;
}
Val
(
const
Val
&
)
=
default
;
Val
&
operator
=
(
const
Val
&
)
=
default
;
bool
operator
=
=
(
const
Val
&
rhs
)
const
{
if
(
type_
!
=
rhs
.
type_
)
{
return
false
;
}
switch
(
type_
.
kind
(
)
)
{
case
ValType
:
:
I32
:
return
cell_
.
i32_
=
=
rhs
.
cell_
.
i32_
;
case
ValType
:
:
I64
:
return
cell_
.
i64_
=
=
rhs
.
cell_
.
i64_
;
case
ValType
:
:
F32
:
return
cell_
.
f32_
=
=
rhs
.
cell_
.
f32_
;
case
ValType
:
:
F64
:
return
cell_
.
f64_
=
=
rhs
.
cell_
.
f64_
;
case
ValType
:
:
V128
:
return
cell_
.
v128_
=
=
rhs
.
cell_
.
v128_
;
case
ValType
:
:
Ref
:
return
cell_
.
ref_
=
=
rhs
.
cell_
.
ref_
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
false
;
}
bool
operator
!
=
(
const
Val
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
isInvalid
(
)
const
{
return
!
type_
.
isValid
(
)
;
}
bool
isAnyRef
(
)
const
{
return
type_
.
isValid
(
)
&
&
type_
.
isRefRepr
(
)
;
}
AnyRef
&
toAnyRef
(
)
const
{
MOZ_ASSERT
(
isAnyRef
(
)
)
;
return
cell_
.
ref_
;
}
void
initFromRootedLocation
(
ValType
type
const
void
*
loc
)
;
void
initFromHeapLocation
(
ValType
type
const
void
*
loc
)
;
void
writeToRootedLocation
(
void
*
loc
bool
mustWrite64
)
const
;
void
readFromHeapLocation
(
const
void
*
loc
)
;
void
writeToHeapLocation
(
void
*
loc
)
const
;
static
bool
fromJSValue
(
JSContext
*
cx
ValType
targetType
HandleValue
val
MutableHandle
<
Val
>
rval
)
;
bool
toJSValue
(
JSContext
*
cx
MutableHandleValue
rval
)
const
;
void
trace
(
JSTracer
*
trc
)
const
;
}
;
using
GCPtrVal
=
GCPtr
<
Val
>
;
using
RootedVal
=
Rooted
<
Val
>
;
using
HandleVal
=
Handle
<
Val
>
;
using
MutableHandleVal
=
MutableHandle
<
Val
>
;
using
ValVector
=
GCVector
<
Val
0
SystemAllocPolicy
>
;
using
RootedValVector
=
Rooted
<
ValVector
>
;
using
HandleValVector
=
Handle
<
ValVector
>
;
using
MutableHandleValVector
=
MutableHandle
<
ValVector
>
;
template
<
int
N
>
using
ValVectorN
=
GCVector
<
Val
N
SystemAllocPolicy
>
;
template
<
int
N
>
using
RootedValVectorN
=
Rooted
<
ValVectorN
<
N
>
>
;
[
[
nodiscard
]
]
extern
bool
CheckRefType
(
JSContext
*
cx
RefType
targetType
HandleValue
v
MutableHandleAnyRef
vp
)
;
[
[
nodiscard
]
]
extern
bool
CheckRefType
(
JSContext
*
cx
RefType
targetType
HandleValue
v
)
;
class
NoDebug
;
class
DebugCodegenVal
;
enum
class
CoercionLevel
{
Spec
Lossless
}
;
template
<
typename
Debug
=
NoDebug
>
extern
bool
ToWebAssemblyValue
(
JSContext
*
cx
HandleValue
val
ValType
type
void
*
loc
bool
mustWrite64
CoercionLevel
level
=
CoercionLevel
:
:
Spec
)
;
template
<
typename
Debug
=
NoDebug
>
extern
bool
ToJSValue
(
JSContext
*
cx
const
void
*
src
StorageType
type
MutableHandleValue
dst
CoercionLevel
level
=
CoercionLevel
:
:
Spec
)
;
template
<
typename
Debug
=
NoDebug
>
extern
bool
ToJSValueMayGC
(
StorageType
type
)
;
template
<
typename
Debug
=
NoDebug
>
extern
bool
ToJSValue
(
JSContext
*
cx
const
void
*
src
ValType
type
MutableHandleValue
dst
CoercionLevel
level
=
CoercionLevel
:
:
Spec
)
;
template
<
typename
Debug
=
NoDebug
>
extern
bool
ToJSValueMayGC
(
ValType
type
)
;
#
ifdef
DEBUG
void
AssertEdgeSourceNotInsideNursery
(
void
*
vp
)
;
#
endif
}
template
<
>
struct
InternalBarrierMethods
<
wasm
:
:
AnyRef
>
{
static
bool
isMarkable
(
const
wasm
:
:
AnyRef
v
)
{
return
v
.
isGCThing
(
)
;
}
static
void
preBarrier
(
const
wasm
:
:
AnyRef
v
)
{
if
(
v
.
isGCThing
(
)
)
{
gc
:
:
PreWriteBarrierImpl
(
v
.
toGCThing
(
)
)
;
}
}
static
MOZ_ALWAYS_INLINE
void
postBarrier
(
wasm
:
:
AnyRef
*
vp
const
wasm
:
:
AnyRef
prev
const
wasm
:
:
AnyRef
next
)
{
#
ifdef
DEBUG
AssertEdgeSourceNotInsideNursery
(
vp
)
;
#
endif
gc
:
:
StoreBuffer
*
sb
;
if
(
next
.
isGCThing
(
)
&
&
(
sb
=
next
.
toGCThing
(
)
-
>
storeBuffer
(
)
)
)
{
if
(
prev
.
isGCThing
(
)
&
&
prev
.
toGCThing
(
)
-
>
storeBuffer
(
)
)
{
return
;
}
sb
-
>
putWasmAnyRefEdgeFromTenured
(
vp
)
;
return
;
}
if
(
prev
.
isGCThing
(
)
&
&
(
sb
=
prev
.
toGCThing
(
)
-
>
storeBuffer
(
)
)
)
{
sb
-
>
unputWasmAnyRef
(
vp
)
;
}
}
static
void
readBarrier
(
const
wasm
:
:
AnyRef
v
)
{
if
(
v
.
isGCThing
(
)
)
{
gc
:
:
ReadBarrierImpl
(
v
.
toGCThing
(
)
)
;
}
}
#
ifdef
DEBUG
static
void
assertThingIsNotGray
(
const
wasm
:
:
AnyRef
v
)
{
if
(
v
.
isGCThing
(
)
)
{
JS
:
:
AssertCellIsNotGray
(
v
.
toGCThing
(
)
)
;
}
}
#
endif
}
;
template
<
>
struct
InternalBarrierMethods
<
wasm
:
:
Val
>
{
static
bool
isMarkable
(
const
wasm
:
:
Val
&
v
)
{
return
v
.
isAnyRef
(
)
;
}
static
void
preBarrier
(
const
wasm
:
:
Val
&
v
)
{
if
(
v
.
isAnyRef
(
)
)
{
InternalBarrierMethods
<
wasm
:
:
AnyRef
>
:
:
preBarrier
(
v
.
toAnyRef
(
)
)
;
}
}
static
MOZ_ALWAYS_INLINE
void
postBarrier
(
wasm
:
:
Val
*
vp
const
wasm
:
:
Val
&
prev
const
wasm
:
:
Val
&
next
)
{
MOZ_ASSERT_IF
(
next
.
isAnyRef
(
)
prev
.
isAnyRef
(
)
|
|
prev
.
isInvalid
(
)
)
;
MOZ_ASSERT_IF
(
prev
.
isAnyRef
(
)
next
.
isAnyRef
(
)
)
;
if
(
next
.
isAnyRef
(
)
)
{
InternalBarrierMethods
<
wasm
:
:
AnyRef
>
:
:
postBarrier
(
&
vp
-
>
toAnyRef
(
)
prev
.
isAnyRef
(
)
?
prev
.
toAnyRef
(
)
:
wasm
:
:
AnyRef
:
:
null
(
)
next
.
toAnyRef
(
)
)
;
return
;
}
}
static
void
readBarrier
(
const
wasm
:
:
Val
&
v
)
{
if
(
v
.
isAnyRef
(
)
)
{
InternalBarrierMethods
<
wasm
:
:
AnyRef
>
:
:
readBarrier
(
v
.
toAnyRef
(
)
)
;
}
}
#
ifdef
DEBUG
static
void
assertThingIsNotGray
(
const
wasm
:
:
Val
&
v
)
{
if
(
v
.
isAnyRef
(
)
)
{
InternalBarrierMethods
<
wasm
:
:
AnyRef
>
:
:
assertThingIsNotGray
(
v
.
toAnyRef
(
)
)
;
}
}
#
endif
}
;
}
template
<
>
struct
JS
:
:
SafelyInitialized
<
js
:
:
wasm
:
:
AnyRef
>
{
static
constexpr
js
:
:
wasm
:
:
AnyRef
create
(
)
{
return
js
:
:
wasm
:
:
AnyRef
:
:
null
(
)
;
}
}
;
#
endif
