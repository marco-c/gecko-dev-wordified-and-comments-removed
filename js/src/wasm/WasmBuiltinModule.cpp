#
include
"
wasm
/
WasmBuiltinModule
.
h
"
#
include
"
util
/
Text
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
wasm
/
WasmBuiltinModuleGenerated
.
h
"
#
include
"
wasm
/
WasmFeatures
.
h
"
#
include
"
wasm
/
WasmGenerator
.
h
"
#
include
"
wasm
/
WasmJS
.
h
"
#
include
"
wasm
/
WasmModule
.
h
"
#
include
"
wasm
/
WasmOpIter
.
h
"
#
include
"
wasm
/
WasmStaticTypeDefs
.
h
"
#
include
"
wasm
/
WasmValidate
.
h
"
using
namespace
js
;
using
namespace
js
:
:
wasm
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
BuiltinModuleFuncs
*
BuiltinModuleFuncs
:
:
singleton_
=
nullptr
;
[
[
nodiscard
]
]
bool
BuiltinModuleFunc
:
:
init
(
const
RefPtr
<
TypeContext
>
&
types
mozilla
:
:
Span
<
const
ValType
>
params
Maybe
<
ValType
>
result
bool
usesMemory
const
SymbolicAddressSignature
*
sig
BuiltinInlineOp
inlineOp
const
char
*
exportName
)
{
MOZ_ASSERT
(
!
recGroup_
)
;
exportName_
=
exportName
;
sig_
=
sig
;
usesMemory_
=
usesMemory
;
inlineOp_
=
inlineOp
;
ValTypeVector
paramVec
;
if
(
!
paramVec
.
append
(
params
.
data
(
)
params
.
data
(
)
+
params
.
size
(
)
)
)
{
return
false
;
}
ValTypeVector
resultVec
;
if
(
result
.
isSome
(
)
&
&
!
resultVec
.
append
(
*
result
)
)
{
return
false
;
}
const
TypeDef
*
typeDef
=
types
-
>
addType
(
FuncType
(
std
:
:
move
(
paramVec
)
std
:
:
move
(
resultVec
)
)
)
;
if
(
!
typeDef
)
{
return
false
;
}
recGroup_
=
&
typeDef
-
>
recGroup
(
)
;
return
true
;
}
bool
BuiltinModuleFuncs
:
:
init
(
)
{
singleton_
=
js_new
<
BuiltinModuleFuncs
>
(
)
;
if
(
!
singleton_
)
{
return
false
;
}
RefPtr
<
TypeContext
>
types
=
js_new
<
TypeContext
>
(
)
;
if
(
!
types
)
{
return
false
;
}
#
define
VISIT_BUILTIN_FUNC
(
op
export
sa_name
abitype
needs_thunk
entry
\
uses_memory
inline_op
.
.
.
)
\
const
ValType
op
#
#
Params
[
]
=
\
DECLARE_BUILTIN_MODULE_FUNC_PARAM_VALTYPES_
#
#
op
;
\
Maybe
<
ValType
>
op
#
#
Result
=
DECLARE_BUILTIN_MODULE_FUNC_RESULT_VALTYPE_
#
#
op
;
\
if
(
!
singleton_
-
>
funcs_
[
BuiltinModuleFuncId
:
:
op
]
.
init
(
\
types
mozilla
:
:
Span
<
const
ValType
>
(
op
#
#
Params
)
op
#
#
Result
\
uses_memory
&
SASig
#
#
sa_name
inline_op
export
)
)
{
\
return
false
;
\
}
FOR_EACH_BUILTIN_MODULE_FUNC
(
VISIT_BUILTIN_FUNC
)
#
undef
VISIT_BUILTIN_FUNC
return
true
;
}
void
BuiltinModuleFuncs
:
:
destroy
(
)
{
if
(
!
singleton_
)
{
return
;
}
js_delete
(
singleton_
)
;
singleton_
=
nullptr
;
}
bool
EncodeFuncBody
(
const
BuiltinModuleFunc
&
builtinModuleFunc
BuiltinModuleFuncId
id
Bytes
*
body
)
{
Encoder
encoder
(
*
body
)
;
if
(
!
EncodeLocalEntries
(
encoder
ValTypeVector
(
)
)
)
{
return
false
;
}
const
FuncType
*
funcType
=
builtinModuleFunc
.
funcType
(
)
;
for
(
uint32_t
i
=
0
;
i
<
funcType
-
>
args
(
)
.
length
(
)
;
i
+
+
)
{
if
(
!
encoder
.
writeOp
(
Op
:
:
LocalGet
)
|
|
!
encoder
.
writeVarU32
(
i
)
)
{
return
false
;
}
}
if
(
!
encoder
.
writeOp
(
MozOp
:
:
CallBuiltinModuleFunc
)
)
{
return
false
;
}
if
(
!
encoder
.
writeVarU32
(
uint32_t
(
id
)
)
)
{
return
false
;
}
return
encoder
.
writeOp
(
Op
:
:
End
)
;
}
struct
BuiltinMemory
{
Shareable
shared
;
const
Import
*
import
;
BuiltinMemory
(
Shareable
shared
const
Import
*
import
)
:
shared
(
shared
)
import
(
import
)
{
}
}
;
bool
CompileBuiltinModule
(
JSContext
*
cx
const
mozilla
:
:
Span
<
BuiltinModuleFuncId
>
ids
mozilla
:
:
Maybe
<
BuiltinMemory
>
memory
MutableHandle
<
WasmModuleObject
*
>
result
)
{
FeatureOptions
featureOptions
;
featureOptions
.
isBuiltinModule
=
true
;
SharedCompileArgs
compileArgs
=
CompileArgs
:
:
buildAndReport
(
cx
ScriptedCaller
(
)
featureOptions
true
)
;
if
(
!
compileArgs
)
{
return
false
;
}
CompilerEnvironment
compilerEnv
(
CompileMode
:
:
Once
IonAvailable
(
cx
)
?
Tier
:
:
Optimized
:
Tier
:
:
Baseline
DebugEnabled
:
:
False
)
;
compilerEnv
.
computeParameters
(
)
;
MutableModuleMetadata
moduleMeta
=
js_new
<
ModuleMetadata
>
(
)
;
if
(
!
moduleMeta
|
|
!
moduleMeta
-
>
init
(
*
compileArgs
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
MutableCodeMetadata
codeMeta
=
moduleMeta
-
>
codeMeta
;
if
(
memory
.
isSome
(
)
)
{
CacheableName
moduleString
;
CacheableName
fieldString
;
if
(
!
memory
-
>
import
)
{
if
(
!
CacheableName
:
:
fromUTF8Chars
(
"
memory
"
&
fieldString
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
else
{
MOZ_ASSERT
(
memory
-
>
import
-
>
kind
=
=
DefinitionKind
:
:
Memory
)
;
if
(
!
memory
-
>
import
-
>
module
.
clone
(
&
moduleString
)
|
|
!
memory
-
>
import
-
>
field
.
clone
(
&
fieldString
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
if
(
!
moduleMeta
-
>
imports
.
append
(
Import
(
std
:
:
move
(
moduleString
)
std
:
:
move
(
fieldString
)
DefinitionKind
:
:
Memory
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
if
(
!
codeMeta
-
>
memories
.
append
(
MemoryDesc
(
Limits
(
0
Nothing
(
)
memory
-
>
shared
PageSize
:
:
Standard
)
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
for
(
uint32_t
funcIndex
=
0
;
funcIndex
<
ids
.
size
(
)
;
funcIndex
+
+
)
{
const
BuiltinModuleFuncId
&
id
=
ids
[
funcIndex
]
;
const
BuiltinModuleFunc
&
builtinModuleFunc
=
BuiltinModuleFuncs
:
:
getFromId
(
id
)
;
SharedRecGroup
recGroup
=
builtinModuleFunc
.
recGroup
(
)
;
MOZ_ASSERT
(
recGroup
-
>
numTypes
(
)
=
=
1
)
;
if
(
!
codeMeta
-
>
types
-
>
addRecGroup
(
recGroup
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
if
(
!
StaticTypeDefs
:
:
addAllToTypeContext
(
codeMeta
-
>
types
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
for
(
uint32_t
funcIndex
=
0
;
funcIndex
<
ids
.
size
(
)
;
funcIndex
+
+
)
{
FuncDesc
decl
(
funcIndex
)
;
if
(
!
codeMeta
-
>
funcs
.
append
(
decl
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
codeMeta
-
>
funcs
[
funcIndex
]
.
declareFuncExported
(
true
true
)
;
}
for
(
uint32_t
funcIndex
=
0
;
funcIndex
<
ids
.
size
(
)
;
funcIndex
+
+
)
{
const
BuiltinModuleFunc
&
builtinModuleFunc
=
BuiltinModuleFuncs
:
:
getFromId
(
ids
[
funcIndex
]
)
;
CacheableName
exportName
;
if
(
!
CacheableName
:
:
fromUTF8Chars
(
builtinModuleFunc
.
exportName
(
)
&
exportName
)
|
|
!
moduleMeta
-
>
exports
.
append
(
Export
(
std
:
:
move
(
exportName
)
funcIndex
DefinitionKind
:
:
Function
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
if
(
!
moduleMeta
-
>
prepareForCompile
(
compilerEnv
.
mode
(
)
)
)
{
return
false
;
}
UniqueChars
error
;
ModuleGenerator
mg
(
*
codeMeta
compilerEnv
compilerEnv
.
initialState
(
)
nullptr
&
error
nullptr
)
;
if
(
!
mg
.
initializeCompleteTier
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
Vector
<
Bytes
1
SystemAllocPolicy
>
bodies
;
if
(
!
bodies
.
reserve
(
ids
.
size
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
uint32_t
funcBytecodeOffset
=
CallSite
:
:
FIRST_VALID_BYTECODE_OFFSET
;
for
(
uint32_t
funcIndex
=
0
;
funcIndex
<
ids
.
size
(
)
;
funcIndex
+
+
)
{
BuiltinModuleFuncId
id
=
ids
[
funcIndex
]
;
const
BuiltinModuleFunc
&
builtinModuleFunc
=
BuiltinModuleFuncs
:
:
getFromId
(
ids
[
funcIndex
]
)
;
bodies
.
infallibleAppend
(
Bytes
(
)
)
;
Bytes
&
bytecode
=
bodies
.
back
(
)
;
if
(
!
EncodeFuncBody
(
builtinModuleFunc
id
&
bytecode
)
|
|
!
mg
.
compileFuncDef
(
funcIndex
funcBytecodeOffset
bytecode
.
begin
(
)
bytecode
.
begin
(
)
+
bytecode
.
length
(
)
)
)
{
MOZ_ASSERT
(
!
error
)
;
ReportOutOfMemory
(
cx
)
;
return
false
;
}
funcBytecodeOffset
+
=
bytecode
.
length
(
)
;
}
if
(
!
mg
.
finishFuncDefs
(
)
)
{
MOZ_ASSERT
(
!
error
)
;
ReportOutOfMemory
(
cx
)
;
return
false
;
}
SharedModule
module
=
mg
.
finishModule
(
BytecodeBufferOrSource
(
)
*
moduleMeta
nullptr
)
;
if
(
!
module
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
RootedObject
proto
(
cx
GlobalObject
:
:
getOrCreatePrototype
(
cx
JSProto_WasmModule
)
)
;
if
(
!
proto
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
result
.
set
(
WasmModuleObject
:
:
create
(
cx
*
module
proto
)
)
;
return
!
!
result
;
}
static
BuiltinModuleFuncId
SelfTestFuncs
[
]
=
{
BuiltinModuleFuncId
:
:
I8VecMul
}
;
#
ifdef
ENABLE_WASM_MOZ_INTGEMM
static
BuiltinModuleFuncId
IntGemmFuncs
[
]
=
{
BuiltinModuleFuncId
:
:
I8PrepareB
BuiltinModuleFuncId
:
:
I8PrepareBFromTransposed
BuiltinModuleFuncId
:
:
I8PrepareBFromQuantizedTransposed
BuiltinModuleFuncId
:
:
I8PrepareA
BuiltinModuleFuncId
:
:
I8PrepareBias
BuiltinModuleFuncId
:
:
I8MultiplyAndAddBias
BuiltinModuleFuncId
:
:
I8SelectColumnsOfB
}
;
static
const
char
*
IntGemmModuleName
=
"
wasm_gemm
"
;
#
endif
static
BuiltinModuleFuncId
JSStringFuncs
[
]
=
{
BuiltinModuleFuncId
:
:
StringTest
BuiltinModuleFuncId
:
:
StringCast
BuiltinModuleFuncId
:
:
StringFromCharCodeArray
BuiltinModuleFuncId
:
:
StringIntoCharCodeArray
BuiltinModuleFuncId
:
:
StringFromCharCode
BuiltinModuleFuncId
:
:
StringFromCodePoint
BuiltinModuleFuncId
:
:
StringCharCodeAt
BuiltinModuleFuncId
:
:
StringCodePointAt
BuiltinModuleFuncId
:
:
StringLength
BuiltinModuleFuncId
:
:
StringConcat
BuiltinModuleFuncId
:
:
StringSubstring
BuiltinModuleFuncId
:
:
StringEquals
BuiltinModuleFuncId
:
:
StringCompare
}
;
static
const
char
*
JSStringModuleName
=
"
wasm
:
js
-
string
"
;
Maybe
<
BuiltinModuleId
>
wasm
:
:
ImportMatchesBuiltinModule
(
mozilla
:
:
Span
<
const
char
>
importName
const
BuiltinModuleIds
&
enabledBuiltins
)
{
if
(
enabledBuiltins
.
jsString
&
&
importName
=
=
mozilla
:
:
MakeStringSpan
(
JSStringModuleName
)
)
{
return
Some
(
BuiltinModuleId
:
:
JSString
)
;
}
if
(
enabledBuiltins
.
jsStringConstants
&
&
importName
=
=
mozilla
:
:
MakeStringSpan
(
enabledBuiltins
.
jsStringConstantsNamespace
-
>
chars
.
get
(
)
)
)
{
return
Some
(
BuiltinModuleId
:
:
JSStringConstants
)
;
}
#
ifdef
ENABLE_WASM_MOZ_INTGEMM
if
(
enabledBuiltins
.
intGemm
&
&
importName
=
=
mozilla
:
:
MakeStringSpan
(
IntGemmModuleName
)
)
{
return
Some
(
BuiltinModuleId
:
:
IntGemm
)
;
}
#
endif
MOZ_RELEASE_ASSERT
(
!
enabledBuiltins
.
selfTest
)
;
return
Nothing
(
)
;
}
bool
wasm
:
:
ImportMatchesBuiltinModuleFunc
(
mozilla
:
:
Span
<
const
char
>
importName
BuiltinModuleId
module
const
BuiltinModuleFunc
*
*
matchedFunc
BuiltinModuleFuncId
*
matchedFuncId
)
{
if
(
module
=
=
BuiltinModuleId
:
:
JSStringConstants
)
{
return
false
;
}
#
ifdef
ENABLE_WASM_MOZ_INTGEMM
if
(
module
=
=
BuiltinModuleId
:
:
IntGemm
)
{
for
(
BuiltinModuleFuncId
funcId
:
IntGemmFuncs
)
{
const
BuiltinModuleFunc
&
func
=
BuiltinModuleFuncs
:
:
getFromId
(
funcId
)
;
if
(
importName
=
=
mozilla
:
:
MakeStringSpan
(
func
.
exportName
(
)
)
)
{
*
matchedFunc
=
&
func
;
*
matchedFuncId
=
funcId
;
return
true
;
}
}
}
#
endif
MOZ_RELEASE_ASSERT
(
module
=
=
BuiltinModuleId
:
:
JSString
)
;
for
(
BuiltinModuleFuncId
funcId
:
JSStringFuncs
)
{
const
BuiltinModuleFunc
&
func
=
BuiltinModuleFuncs
:
:
getFromId
(
funcId
)
;
if
(
importName
=
=
mozilla
:
:
MakeStringSpan
(
func
.
exportName
(
)
)
)
{
*
matchedFunc
=
&
func
;
*
matchedFuncId
=
funcId
;
return
true
;
}
}
return
false
;
}
bool
wasm
:
:
CompileBuiltinModule
(
JSContext
*
cx
BuiltinModuleId
module
const
Import
*
moduleMemoryImport
MutableHandle
<
WasmModuleObject
*
>
result
)
{
switch
(
module
)
{
case
BuiltinModuleId
:
:
SelfTest
:
return
CompileBuiltinModule
(
cx
SelfTestFuncs
Some
(
BuiltinMemory
(
Shareable
:
:
False
nullptr
)
)
result
)
;
#
ifdef
ENABLE_WASM_MOZ_INTGEMM
case
BuiltinModuleId
:
:
IntGemm
:
return
CompileBuiltinModule
(
cx
IntGemmFuncs
Some
(
BuiltinMemory
(
Shareable
:
:
False
moduleMemoryImport
)
)
result
)
;
#
endif
case
BuiltinModuleId
:
:
JSString
:
return
CompileBuiltinModule
(
cx
JSStringFuncs
Nothing
(
)
result
)
;
case
BuiltinModuleId
:
:
JSStringConstants
:
MOZ_CRASH
(
)
;
default
:
MOZ_CRASH
(
)
;
}
}
bool
wasm
:
:
InstantiateBuiltinModule
(
JSContext
*
cx
BuiltinModuleId
module
const
Import
*
moduleMemoryImport
HandleObject
importObj
MutableHandleObject
result
)
{
Rooted
<
WasmModuleObject
*
>
moduleObj
(
cx
)
;
if
(
!
CompileBuiltinModule
(
cx
module
moduleMemoryImport
&
moduleObj
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
Rooted
<
ImportValues
>
imports
(
cx
)
;
if
(
!
wasm
:
:
GetImports
(
cx
moduleObj
-
>
module
(
)
importObj
imports
.
address
(
)
)
)
{
return
false
;
}
Rooted
<
WasmInstanceObject
*
>
instanceObj
(
cx
)
;
RootedObject
instanceProto
(
cx
)
;
if
(
!
moduleObj
-
>
module
(
)
.
instantiate
(
cx
*
imports
.
address
(
)
instanceProto
&
instanceObj
)
)
{
MOZ_RELEASE_ASSERT
(
cx
-
>
isThrowingOutOfMemory
(
)
)
;
return
false
;
}
result
.
set
(
&
instanceObj
-
>
exportsObj
(
)
)
;
return
true
;
}
