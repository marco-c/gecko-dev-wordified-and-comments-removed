#
include
"
wasm
/
WasmModule
.
h
"
#
include
<
chrono
>
#
include
"
js
/
BuildId
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
Printf
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
StreamConsumer
.
h
"
#
include
"
threading
/
LockGuard
.
h
"
#
include
"
threading
/
Thread
.
h
"
#
include
"
vm
/
HelperThreadState
.
h
"
#
include
"
vm
/
PlainObject
.
h
"
#
include
"
wasm
/
WasmBaselineCompile
.
h
"
#
include
"
wasm
/
WasmCompile
.
h
"
#
include
"
wasm
/
WasmDebug
.
h
"
#
include
"
wasm
/
WasmInstance
.
h
"
#
include
"
wasm
/
WasmIonCompile
.
h
"
#
include
"
wasm
/
WasmJS
.
h
"
#
include
"
wasm
/
WasmModuleTypes
.
h
"
#
include
"
wasm
/
WasmPI
.
h
"
#
include
"
wasm
/
WasmSerialize
.
h
"
#
include
"
wasm
/
WasmUtility
.
h
"
#
include
"
debugger
/
DebugAPI
-
inl
.
h
"
#
include
"
vm
/
ArrayBufferObject
-
inl
.
h
"
#
include
"
vm
/
JSAtomUtils
-
inl
.
h
"
#
include
"
wasm
/
WasmInstance
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
using
namespace
js
:
:
wasm
;
static
UniqueChars
Tier2ResultsContext
(
const
ScriptedCaller
&
scriptedCaller
)
{
return
scriptedCaller
.
filename
?
JS_smprintf
(
"
%
s
:
%
d
"
scriptedCaller
.
filename
.
get
(
)
scriptedCaller
.
line
)
:
UniqueChars
(
)
;
}
static
void
ReportTier2ResultsOffThread
(
bool
success
const
ScriptedCaller
&
scriptedCaller
const
UniqueChars
&
error
const
UniqueCharsVector
&
warnings
)
{
UniqueChars
context
=
Tier2ResultsContext
(
scriptedCaller
)
;
const
char
*
contextString
=
context
?
context
.
get
(
)
:
"
unknown
"
;
if
(
!
success
)
{
const
char
*
errorString
=
error
?
error
.
get
(
)
:
"
out
of
memory
"
;
LogOffThread
(
"
'
%
s
'
:
wasm
tier
-
2
failed
with
'
%
s
'
.
\
n
"
contextString
errorString
)
;
}
size_t
numWarnings
=
std
:
:
min
<
size_t
>
(
warnings
.
length
(
)
3
)
;
for
(
size_t
i
=
0
;
i
<
numWarnings
;
i
+
+
)
{
LogOffThread
(
"
'
%
s
'
:
wasm
tier
-
2
warning
:
'
%
s
'
.
\
n
'
.
"
contextString
warnings
[
i
]
.
get
(
)
)
;
}
if
(
warnings
.
length
(
)
>
numWarnings
)
{
LogOffThread
(
"
'
%
s
'
:
other
warnings
suppressed
.
\
n
"
contextString
)
;
}
}
class
Module
:
:
Tier2GeneratorTaskImpl
:
public
Tier2GeneratorTask
{
SharedCompileArgs
compileArgs_
;
SharedBytes
bytecode_
;
SharedModule
module_
;
Atomic
<
bool
>
cancelled_
;
public
:
Tier2GeneratorTaskImpl
(
const
CompileArgs
&
compileArgs
const
ShareableBytes
&
bytecode
Module
&
module
)
:
compileArgs_
(
&
compileArgs
)
bytecode_
(
&
bytecode
)
module_
(
&
module
)
cancelled_
(
false
)
{
}
~
Tier2GeneratorTaskImpl
(
)
override
{
module_
-
>
tier2Listener_
=
nullptr
;
module_
-
>
testingTier2Active_
=
false
;
}
void
cancel
(
)
override
{
cancelled_
=
true
;
}
void
runHelperThreadTask
(
AutoLockHelperThreadState
&
locked
)
override
{
{
AutoUnlockHelperThreadState
unlock
(
locked
)
;
UniqueChars
error
;
UniqueCharsVector
warnings
;
bool
success
=
CompileTier2
(
*
compileArgs_
bytecode_
-
>
bytes
*
module_
&
error
&
warnings
&
cancelled_
)
;
if
(
!
cancelled_
)
{
ReportTier2ResultsOffThread
(
success
compileArgs_
-
>
scriptedCaller
error
warnings
)
;
}
}
HelperThreadState
(
)
.
incWasmTier2GeneratorsFinished
(
locked
)
;
js_delete
(
this
)
;
}
ThreadType
threadType
(
)
override
{
return
ThreadType
:
:
THREAD_TYPE_WASM_GENERATOR_TIER2
;
}
}
;
Module
:
:
~
Module
(
)
{
MOZ_ASSERT
(
!
tier2Listener_
)
;
MOZ_ASSERT
(
!
testingTier2Active_
)
;
}
void
Module
:
:
startTier2
(
const
CompileArgs
&
args
const
ShareableBytes
&
bytecode
JS
:
:
OptimizedEncodingListener
*
listener
)
{
MOZ_ASSERT
(
!
testingTier2Active_
)
;
auto
task
=
MakeUnique
<
Tier2GeneratorTaskImpl
>
(
args
bytecode
*
this
)
;
if
(
!
task
)
{
return
;
}
tier2Listener_
=
listener
;
testingTier2Active_
=
true
;
StartOffThreadWasmTier2Generator
(
std
:
:
move
(
task
)
)
;
}
bool
Module
:
:
finishTier2
(
const
LinkData
&
linkData2
UniqueCodeBlock
code2
)
const
{
if
(
!
code_
-
>
finishCompleteTier2
(
linkData2
std
:
:
move
(
code2
)
)
)
{
return
false
;
}
if
(
tier2Listener_
)
{
Bytes
bytes
;
if
(
serialize
(
linkData2
&
bytes
)
)
{
tier2Listener_
-
>
storeOptimizedEncoding
(
bytes
.
begin
(
)
bytes
.
length
(
)
)
;
}
tier2Listener_
=
nullptr
;
}
testingTier2Active_
=
false
;
return
true
;
}
void
Module
:
:
testingBlockOnTier2Complete
(
)
const
{
while
(
testingTier2Active_
)
{
ThisThread
:
:
SleepMilliseconds
(
1
)
;
}
}
JSObject
*
Module
:
:
createObject
(
JSContext
*
cx
)
const
{
if
(
!
GlobalObject
:
:
ensureConstructor
(
cx
cx
-
>
global
(
)
JSProto_WebAssembly
)
)
{
return
nullptr
;
}
if
(
!
cx
-
>
isRuntimeCodeGenEnabled
(
JS
:
:
RuntimeCode
:
:
WASM
nullptr
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_CSP_BLOCKED_WASM
"
WebAssembly
.
Module
"
)
;
return
nullptr
;
}
RootedObject
proto
(
cx
&
cx
-
>
global
(
)
-
>
getPrototype
(
JSProto_WasmModule
)
)
;
return
WasmModuleObject
:
:
create
(
cx
*
this
proto
)
;
}
JSObject
*
Module
:
:
createObjectForAsmJS
(
JSContext
*
cx
)
const
{
return
WasmModuleObject
:
:
create
(
cx
*
this
nullptr
)
;
}
bool
wasm
:
:
GetOptimizedEncodingBuildId
(
JS
:
:
BuildIdCharVector
*
buildId
)
{
if
(
!
GetBuildId
|
|
!
GetBuildId
(
buildId
)
)
{
return
false
;
}
uint32_t
cpu
=
ObservedCPUFeatures
(
)
;
if
(
!
buildId
-
>
reserve
(
buildId
-
>
length
(
)
+
13
)
)
{
return
false
;
}
buildId
-
>
infallibleAppend
(
'
(
'
)
;
while
(
cpu
)
{
buildId
-
>
infallibleAppend
(
'
0
'
+
(
cpu
&
0xf
)
)
;
cpu
>
>
=
4
;
}
buildId
-
>
infallibleAppend
(
'
)
'
)
;
buildId
-
>
infallibleAppend
(
'
m
'
)
;
buildId
-
>
infallibleAppend
(
wasm
:
:
IsHugeMemoryEnabled
(
IndexType
:
:
I32
)
?
'
+
'
:
'
-
'
)
;
buildId
-
>
infallibleAppend
(
wasm
:
:
IsHugeMemoryEnabled
(
IndexType
:
:
I64
)
?
'
+
'
:
'
-
'
)
;
return
true
;
}
void
Module
:
:
addSizeOfMisc
(
MallocSizeOf
mallocSizeOf
CodeMetadata
:
:
SeenSet
*
seenCodeMeta
CodeMetadataForAsmJS
:
:
SeenSet
*
seenCodeMetaForAsmJS
Code
:
:
SeenSet
*
seenCode
size_t
*
code
size_t
*
data
)
const
{
code_
-
>
addSizeOfMiscIfNotSeen
(
mallocSizeOf
seenCodeMeta
seenCodeMetaForAsmJS
seenCode
code
data
)
;
*
data
+
=
mallocSizeOf
(
this
)
+
SizeOfVectorExcludingThis
(
dataSegments_
mallocSizeOf
)
+
SizeOfVectorExcludingThis
(
elemSegments_
mallocSizeOf
)
+
SizeOfVectorExcludingThis
(
customSections_
mallocSizeOf
)
;
}
bool
Module
:
:
extractCode
(
JSContext
*
cx
Tier
tier
MutableHandleValue
vp
)
const
{
Rooted
<
PlainObject
*
>
result
(
cx
NewPlainObject
(
cx
)
)
;
if
(
!
result
)
{
return
false
;
}
testingBlockOnTier2Complete
(
)
;
if
(
!
code_
-
>
hasTier
(
tier
)
)
{
vp
.
setNull
(
)
;
return
true
;
}
const
CodeSegment
&
codeSegment
=
code_
-
>
segment
(
tier
)
;
RootedObject
codeObj
(
cx
JS_NewUint8Array
(
cx
codeSegment
.
lengthBytes
(
)
)
)
;
if
(
!
codeObj
)
{
return
false
;
}
memcpy
(
codeObj
-
>
as
<
TypedArrayObject
>
(
)
.
dataPointerUnshared
(
)
codeSegment
.
base
(
)
codeSegment
.
lengthBytes
(
)
)
;
RootedValue
value
(
cx
ObjectValue
(
*
codeObj
)
)
;
if
(
!
JS_DefineProperty
(
cx
result
"
code
"
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
RootedObject
segments
(
cx
NewDenseEmptyArray
(
cx
)
)
;
if
(
!
segments
)
{
return
false
;
}
for
(
const
CodeRange
&
p
:
code
(
tier
)
.
codeRanges
)
{
RootedObject
segment
(
cx
NewPlainObjectWithProto
(
cx
nullptr
)
)
;
if
(
!
segment
)
{
return
false
;
}
value
.
setNumber
(
(
uint32_t
)
p
.
begin
(
)
)
;
if
(
!
JS_DefineProperty
(
cx
segment
"
begin
"
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
value
.
setNumber
(
(
uint32_t
)
p
.
end
(
)
)
;
if
(
!
JS_DefineProperty
(
cx
segment
"
end
"
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
value
.
setNumber
(
(
uint32_t
)
p
.
kind
(
)
)
;
if
(
!
JS_DefineProperty
(
cx
segment
"
kind
"
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
if
(
p
.
isFunction
(
)
)
{
value
.
setNumber
(
(
uint32_t
)
p
.
funcIndex
(
)
)
;
if
(
!
JS_DefineProperty
(
cx
segment
"
funcIndex
"
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
value
.
setNumber
(
(
uint32_t
)
p
.
funcUncheckedCallEntry
(
)
)
;
if
(
!
JS_DefineProperty
(
cx
segment
"
funcBodyBegin
"
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
value
.
setNumber
(
(
uint32_t
)
p
.
end
(
)
)
;
if
(
!
JS_DefineProperty
(
cx
segment
"
funcBodyEnd
"
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
}
if
(
!
NewbornArrayPush
(
cx
segments
ObjectValue
(
*
segment
)
)
)
{
return
false
;
}
}
value
.
setObject
(
*
segments
)
;
if
(
!
JS_DefineProperty
(
cx
result
"
segments
"
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
vp
.
setObject
(
*
result
)
;
return
true
;
}
static
const
Import
&
FindImportFunction
(
const
ImportVector
&
imports
uint32_t
funcImportIndex
)
{
for
(
const
Import
&
import
:
imports
)
{
if
(
import
.
kind
!
=
DefinitionKind
:
:
Function
)
{
continue
;
}
if
(
funcImportIndex
=
=
0
)
{
return
import
;
}
funcImportIndex
-
-
;
}
MOZ_CRASH
(
"
ran
out
of
imports
"
)
;
}
bool
Module
:
:
instantiateFunctions
(
JSContext
*
cx
const
JSObjectVector
&
funcImports
)
const
{
#
ifdef
DEBUG
for
(
auto
t
:
code
(
)
.
tiers
(
)
)
{
MOZ_ASSERT
(
funcImports
.
length
(
)
=
=
code
(
t
)
.
funcImports
.
length
(
)
)
;
}
#
endif
if
(
codeMeta
(
)
.
isAsmJS
(
)
)
{
return
true
;
}
Tier
tier
=
code
(
)
.
stableTier
(
)
;
for
(
size_t
i
=
0
;
i
<
code
(
tier
)
.
funcImports
.
length
(
)
;
i
+
+
)
{
if
(
!
funcImports
[
i
]
-
>
is
<
JSFunction
>
(
)
)
{
continue
;
}
JSFunction
*
f
=
&
funcImports
[
i
]
-
>
as
<
JSFunction
>
(
)
;
if
(
!
IsWasmExportedFunction
(
f
)
)
{
continue
;
}
uint32_t
funcIndex
=
ExportedFunctionToFuncIndex
(
f
)
;
Instance
&
instance
=
ExportedFunctionToInstance
(
f
)
;
Tier
otherTier
=
instance
.
code
(
)
.
stableTier
(
)
;
const
TypeDef
&
exportFuncType
=
instance
.
codeMeta
(
)
.
getFuncExportTypeDef
(
instance
.
code
(
otherTier
)
.
lookupFuncExport
(
funcIndex
)
)
;
const
TypeDef
&
importFuncType
=
codeMeta
(
)
.
getFuncImportTypeDef
(
code
(
tier
)
.
funcImports
[
i
]
)
;
if
(
!
TypeDef
:
:
isSubTypeOf
(
&
exportFuncType
&
importFuncType
)
)
{
const
Import
&
import
=
FindImportFunction
(
moduleMeta
(
)
.
imports
i
)
;
UniqueChars
importModuleName
=
import
.
module
.
toQuotedString
(
cx
)
;
UniqueChars
importFieldName
=
import
.
field
.
toQuotedString
(
cx
)
;
if
(
!
importFieldName
|
|
!
importModuleName
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_BAD_IMPORT_SIG
importModuleName
.
get
(
)
importFieldName
.
get
(
)
)
;
return
false
;
}
}
return
true
;
}
template
<
typename
T
>
static
bool
CheckLimits
(
JSContext
*
cx
T
declaredMin
const
Maybe
<
T
>
&
declaredMax
T
defaultMax
T
actualLength
const
Maybe
<
T
>
&
actualMax
bool
isAsmJS
const
char
*
kind
)
{
if
(
isAsmJS
)
{
MOZ_ASSERT
(
actualLength
>
=
declaredMin
)
;
MOZ_ASSERT
(
!
declaredMax
)
;
MOZ_ASSERT
(
actualLength
=
=
actualMax
.
value
(
)
)
;
return
true
;
}
if
(
actualLength
<
declaredMin
|
|
actualLength
>
declaredMax
.
valueOr
(
defaultMax
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_BAD_IMP_SIZE
kind
)
;
return
false
;
}
if
(
(
actualMax
&
&
declaredMax
&
&
*
actualMax
>
*
declaredMax
)
|
|
(
!
actualMax
&
&
declaredMax
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_BAD_IMP_MAX
kind
)
;
return
false
;
}
return
true
;
}
static
bool
CheckSharing
(
JSContext
*
cx
bool
declaredShared
bool
isShared
)
{
if
(
isShared
&
&
!
cx
-
>
realm
(
)
-
>
creationOptions
(
)
.
getSharedMemoryAndAtomicsEnabled
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_NO_SHMEM_LINK
)
;
return
false
;
}
if
(
declaredShared
&
&
!
isShared
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_IMP_SHARED_REQD
)
;
return
false
;
}
if
(
!
declaredShared
&
&
isShared
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_IMP_SHARED_BANNED
)
;
return
false
;
}
return
true
;
}
bool
Module
:
:
instantiateMemories
(
JSContext
*
cx
const
WasmMemoryObjectVector
&
memoryImports
MutableHandle
<
WasmMemoryObjectVector
>
memoryObjs
)
const
{
for
(
uint32_t
memoryIndex
=
0
;
memoryIndex
<
codeMeta
(
)
.
memories
.
length
(
)
;
memoryIndex
+
+
)
{
const
MemoryDesc
&
desc
=
codeMeta
(
)
.
memories
[
memoryIndex
]
;
Rooted
<
WasmMemoryObject
*
>
memory
(
cx
)
;
if
(
memoryIndex
<
memoryImports
.
length
(
)
)
{
memory
=
memoryImports
[
memoryIndex
]
;
MOZ_ASSERT_IF
(
codeMeta
(
)
.
isAsmJS
(
)
memory
-
>
buffer
(
)
.
isPreparedForAsmJS
(
)
)
;
MOZ_ASSERT_IF
(
!
codeMeta
(
)
.
isAsmJS
(
)
memory
-
>
buffer
(
)
.
isWasm
(
)
)
;
if
(
memory
-
>
indexType
(
)
!
=
desc
.
indexType
(
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_BAD_IMP_INDEX
ToString
(
memory
-
>
indexType
(
)
)
)
;
return
false
;
}
if
(
!
CheckLimits
(
cx
desc
.
initialPages
(
)
desc
.
maximumPages
(
)
MaxMemoryPages
(
desc
.
indexType
(
)
)
memory
-
>
volatilePages
(
)
memory
-
>
sourceMaxPages
(
)
codeMeta
(
)
.
isAsmJS
(
)
"
Memory
"
)
)
{
return
false
;
}
if
(
!
CheckSharing
(
cx
desc
.
isShared
(
)
memory
-
>
isShared
(
)
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
!
codeMeta
(
)
.
isAsmJS
(
)
)
;
if
(
desc
.
initialPages
(
)
>
MaxMemoryPages
(
desc
.
indexType
(
)
)
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_MEM_IMP_LIMIT
)
;
return
false
;
}
Rooted
<
ArrayBufferObjectMaybeShared
*
>
buffer
(
cx
CreateWasmBuffer
(
cx
desc
)
)
;
if
(
!
buffer
)
{
return
false
;
}
RootedObject
proto
(
cx
&
cx
-
>
global
(
)
-
>
getPrototype
(
JSProto_WasmMemory
)
)
;
memory
=
WasmMemoryObject
:
:
create
(
cx
buffer
IsHugeMemoryEnabled
(
desc
.
indexType
(
)
)
proto
)
;
if
(
!
memory
)
{
return
false
;
}
}
MOZ_RELEASE_ASSERT
(
codeMeta
(
)
.
isAsmJS
(
)
|
|
memory
-
>
isHuge
(
)
=
=
IsHugeMemoryEnabled
(
desc
.
indexType
(
)
)
)
;
if
(
!
memoryObjs
.
get
(
)
.
append
(
memory
)
)
{
return
false
;
}
}
return
true
;
}
bool
Module
:
:
instantiateTags
(
JSContext
*
cx
WasmTagObjectVector
&
tagObjs
)
const
{
size_t
tagLength
=
codeMeta
(
)
.
tags
.
length
(
)
;
if
(
tagLength
=
=
0
)
{
return
true
;
}
size_t
importedTagsLength
=
tagObjs
.
length
(
)
;
if
(
tagObjs
.
length
(
)
<
=
tagLength
&
&
!
tagObjs
.
resize
(
tagLength
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
uint32_t
tagIndex
=
0
;
RootedObject
proto
(
cx
&
cx
-
>
global
(
)
-
>
getPrototype
(
JSProto_WasmTag
)
)
;
for
(
const
TagDesc
&
desc
:
codeMeta
(
)
.
tags
)
{
if
(
tagIndex
>
=
importedTagsLength
)
{
Rooted
<
WasmTagObject
*
>
tagObj
(
cx
WasmTagObject
:
:
create
(
cx
desc
.
type
proto
)
)
;
if
(
!
tagObj
)
{
return
false
;
}
tagObjs
[
tagIndex
]
=
tagObj
;
}
tagIndex
+
+
;
}
return
true
;
}
bool
Module
:
:
instantiateImportedTable
(
JSContext
*
cx
const
TableDesc
&
td
Handle
<
WasmTableObject
*
>
tableObj
WasmTableObjectVector
*
tableObjs
SharedTableVector
*
tables
)
const
{
MOZ_ASSERT
(
tableObj
)
;
MOZ_ASSERT
(
!
codeMeta
(
)
.
isAsmJS
(
)
)
;
Table
&
table
=
tableObj
-
>
table
(
)
;
if
(
!
CheckLimits
(
cx
td
.
initialLength
td
.
maximumLength
MaxTableLimitField
table
.
length
(
)
table
.
maximum
(
)
codeMeta
(
)
.
isAsmJS
(
)
"
Table
"
)
)
{
return
false
;
}
if
(
!
tables
-
>
append
(
&
table
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
if
(
!
tableObjs
-
>
append
(
tableObj
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
bool
Module
:
:
instantiateLocalTable
(
JSContext
*
cx
const
TableDesc
&
td
WasmTableObjectVector
*
tableObjs
SharedTableVector
*
tables
)
const
{
if
(
td
.
initialLength
>
MaxTableLength
)
{
JS_ReportErrorNumberUTF8
(
cx
GetErrorMessage
nullptr
JSMSG_WASM_TABLE_IMP_LIMIT
)
;
return
false
;
}
SharedTable
table
;
Rooted
<
WasmTableObject
*
>
tableObj
(
cx
)
;
if
(
td
.
isExported
)
{
RootedObject
proto
(
cx
&
cx
-
>
global
(
)
-
>
getPrototype
(
JSProto_WasmTable
)
)
;
tableObj
.
set
(
WasmTableObject
:
:
create
(
cx
td
.
initialLength
td
.
maximumLength
td
.
elemType
proto
)
)
;
if
(
!
tableObj
)
{
return
false
;
}
table
=
&
tableObj
-
>
table
(
)
;
}
else
{
table
=
Table
:
:
create
(
cx
td
nullptr
)
;
if
(
!
table
)
{
return
false
;
}
}
if
(
!
tableObjs
-
>
append
(
tableObj
.
get
(
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
if
(
!
tables
-
>
emplaceBack
(
table
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
bool
Module
:
:
instantiateTables
(
JSContext
*
cx
const
WasmTableObjectVector
&
tableImports
MutableHandle
<
WasmTableObjectVector
>
tableObjs
SharedTableVector
*
tables
)
const
{
uint32_t
tableIndex
=
0
;
for
(
const
TableDesc
&
td
:
codeMeta
(
)
.
tables
)
{
if
(
tableIndex
<
tableImports
.
length
(
)
)
{
Rooted
<
WasmTableObject
*
>
tableObj
(
cx
tableImports
[
tableIndex
]
)
;
if
(
!
instantiateImportedTable
(
cx
td
tableObj
&
tableObjs
.
get
(
)
tables
)
)
{
return
false
;
}
}
else
{
if
(
!
instantiateLocalTable
(
cx
td
&
tableObjs
.
get
(
)
tables
)
)
{
return
false
;
}
}
tableIndex
+
+
;
}
return
true
;
}
static
bool
EnsureExportedGlobalObject
(
JSContext
*
cx
const
ValVector
&
globalImportValues
size_t
globalIndex
const
GlobalDesc
&
global
WasmGlobalObjectVector
&
globalObjs
)
{
if
(
globalIndex
<
globalObjs
.
length
(
)
&
&
globalObjs
[
globalIndex
]
)
{
return
true
;
}
RootedVal
val
(
cx
)
;
if
(
global
.
kind
(
)
=
=
GlobalKind
:
:
Import
)
{
MOZ_ASSERT
(
!
global
.
isMutable
(
)
)
;
val
.
set
(
Val
(
globalImportValues
[
globalIndex
]
)
)
;
}
else
{
val
.
set
(
Val
(
global
.
type
(
)
)
)
;
}
RootedObject
proto
(
cx
&
cx
-
>
global
(
)
-
>
getPrototype
(
JSProto_WasmGlobal
)
)
;
Rooted
<
WasmGlobalObject
*
>
go
(
cx
WasmGlobalObject
:
:
create
(
cx
val
global
.
isMutable
(
)
proto
)
)
;
if
(
!
go
)
{
return
false
;
}
if
(
globalObjs
.
length
(
)
<
=
globalIndex
&
&
!
globalObjs
.
resize
(
globalIndex
+
1
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
globalObjs
[
globalIndex
]
=
go
;
return
true
;
}
bool
Module
:
:
instantiateGlobals
(
JSContext
*
cx
const
ValVector
&
globalImportValues
WasmGlobalObjectVector
&
globalObjs
)
const
{
const
GlobalDescVector
&
globals
=
codeMeta
(
)
.
globals
;
for
(
const
Export
&
exp
:
moduleMeta
(
)
.
exports
)
{
if
(
exp
.
kind
(
)
!
=
DefinitionKind
:
:
Global
)
{
continue
;
}
unsigned
globalIndex
=
exp
.
globalIndex
(
)
;
const
GlobalDesc
&
global
=
globals
[
globalIndex
]
;
if
(
!
EnsureExportedGlobalObject
(
cx
globalImportValues
globalIndex
global
globalObjs
)
)
{
return
false
;
}
}
#
ifdef
DEBUG
size_t
numGlobalImports
=
0
;
for
(
const
Import
&
import
:
moduleMeta
(
)
.
imports
)
{
if
(
import
.
kind
!
=
DefinitionKind
:
:
Global
)
{
continue
;
}
size_t
globalIndex
=
numGlobalImports
+
+
;
const
GlobalDesc
&
global
=
globals
[
globalIndex
]
;
MOZ_ASSERT
(
global
.
importIndex
(
)
=
=
globalIndex
)
;
MOZ_ASSERT_IF
(
global
.
isIndirect
(
)
globalIndex
<
globalObjs
.
length
(
)
|
|
globalObjs
[
globalIndex
]
)
;
}
MOZ_ASSERT_IF
(
!
codeMeta
(
)
.
isAsmJS
(
)
numGlobalImports
=
=
globals
.
length
(
)
|
|
!
globals
[
numGlobalImports
]
.
isImport
(
)
)
;
#
endif
return
true
;
}
static
bool
GetFunctionExport
(
JSContext
*
cx
Handle
<
WasmInstanceObject
*
>
instanceObj
const
JSObjectVector
&
funcImports
uint32_t
funcIndex
MutableHandleFunction
func
)
{
if
(
funcIndex
<
funcImports
.
length
(
)
&
&
funcImports
[
funcIndex
]
-
>
is
<
JSFunction
>
(
)
)
{
JSFunction
*
f
=
&
funcImports
[
funcIndex
]
-
>
as
<
JSFunction
>
(
)
;
if
(
IsWasmExportedFunction
(
f
)
)
{
func
.
set
(
f
)
;
return
true
;
}
}
return
instanceObj
-
>
getExportedFunction
(
cx
instanceObj
funcIndex
func
)
;
}
static
bool
GetGlobalExport
(
JSContext
*
cx
Handle
<
WasmInstanceObject
*
>
instanceObj
const
JSObjectVector
&
funcImports
const
GlobalDesc
&
global
uint32_t
globalIndex
const
ValVector
&
globalImportValues
const
WasmGlobalObjectVector
&
globalObjs
MutableHandleValue
val
)
{
Rooted
<
WasmGlobalObject
*
>
globalObj
(
cx
globalObjs
[
globalIndex
]
)
;
val
.
setObject
(
*
globalObj
)
;
if
(
global
.
isIndirect
(
)
|
|
global
.
isImport
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
!
global
.
isMutable
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
global
.
isImport
(
)
)
;
RootedVal
globalVal
(
cx
)
;
instanceObj
-
>
instance
(
)
.
constantGlobalGet
(
globalIndex
&
globalVal
)
;
globalObj
-
>
setVal
(
globalVal
)
;
return
true
;
}
static
bool
CreateExportObject
(
JSContext
*
cx
Handle
<
WasmInstanceObject
*
>
instanceObj
const
JSObjectVector
&
funcImports
const
WasmTableObjectVector
&
tableObjs
const
WasmMemoryObjectVector
&
memoryObjs
const
WasmTagObjectVector
&
tagObjs
const
ValVector
&
globalImportValues
const
WasmGlobalObjectVector
&
globalObjs
const
ExportVector
&
exports
)
{
const
Instance
&
instance
=
instanceObj
-
>
instance
(
)
;
const
CodeMetadata
&
codeMeta
=
instance
.
codeMeta
(
)
;
const
GlobalDescVector
&
globals
=
codeMeta
.
globals
;
if
(
codeMeta
.
isAsmJS
(
)
&
&
exports
.
length
(
)
=
=
1
&
&
exports
[
0
]
.
fieldName
(
)
.
isEmpty
(
)
)
{
RootedFunction
func
(
cx
)
;
if
(
!
GetFunctionExport
(
cx
instanceObj
funcImports
exports
[
0
]
.
funcIndex
(
)
&
func
)
)
{
return
false
;
}
instanceObj
-
>
initExportsObj
(
*
func
.
get
(
)
)
;
return
true
;
}
RootedObject
exportObj
(
cx
)
;
uint8_t
propertyAttr
=
JSPROP_ENUMERATE
;
if
(
codeMeta
.
isAsmJS
(
)
)
{
exportObj
=
NewPlainObject
(
cx
)
;
}
else
{
exportObj
=
NewPlainObjectWithProto
(
cx
nullptr
)
;
propertyAttr
|
=
JSPROP_READONLY
|
JSPROP_PERMANENT
;
}
if
(
!
exportObj
)
{
return
false
;
}
for
(
const
Export
&
exp
:
exports
)
{
JSAtom
*
atom
=
exp
.
fieldName
(
)
.
toAtom
(
cx
)
;
if
(
!
atom
)
{
return
false
;
}
RootedId
id
(
cx
AtomToId
(
atom
)
)
;
RootedValue
val
(
cx
)
;
switch
(
exp
.
kind
(
)
)
{
case
DefinitionKind
:
:
Function
:
{
RootedFunction
func
(
cx
)
;
if
(
!
GetFunctionExport
(
cx
instanceObj
funcImports
exp
.
funcIndex
(
)
&
func
)
)
{
return
false
;
}
val
=
ObjectValue
(
*
func
)
;
break
;
}
case
DefinitionKind
:
:
Table
:
{
val
=
ObjectValue
(
*
tableObjs
[
exp
.
tableIndex
(
)
]
)
;
break
;
}
case
DefinitionKind
:
:
Memory
:
{
val
=
ObjectValue
(
*
memoryObjs
[
exp
.
memoryIndex
(
)
]
)
;
break
;
}
case
DefinitionKind
:
:
Global
:
{
const
GlobalDesc
&
global
=
globals
[
exp
.
globalIndex
(
)
]
;
if
(
!
GetGlobalExport
(
cx
instanceObj
funcImports
global
exp
.
globalIndex
(
)
globalImportValues
globalObjs
&
val
)
)
{
return
false
;
}
break
;
}
case
DefinitionKind
:
:
Tag
:
{
val
=
ObjectValue
(
*
tagObjs
[
exp
.
tagIndex
(
)
]
)
;
break
;
}
}
if
(
!
JS_DefinePropertyById
(
cx
exportObj
id
val
propertyAttr
)
)
{
return
false
;
}
}
if
(
!
codeMeta
.
isAsmJS
(
)
)
{
if
(
!
PreventExtensions
(
cx
exportObj
)
)
{
return
false
;
}
}
instanceObj
-
>
initExportsObj
(
*
exportObj
)
;
return
true
;
}
bool
Module
:
:
instantiate
(
JSContext
*
cx
ImportValues
&
imports
HandleObject
instanceProto
MutableHandle
<
WasmInstanceObject
*
>
instance
)
const
{
MOZ_RELEASE_ASSERT
(
cx
-
>
wasm
(
)
.
haveSignalHandlers
)
;
if
(
!
instantiateFunctions
(
cx
imports
.
funcs
)
)
{
return
false
;
}
Rooted
<
WasmMemoryObjectVector
>
memories
(
cx
)
;
if
(
!
instantiateMemories
(
cx
imports
.
memories
&
memories
)
)
{
return
false
;
}
if
(
!
instantiateTags
(
cx
imports
.
tagObjs
)
)
{
return
false
;
}
Rooted
<
WasmTableObjectVector
>
tableObjs
(
cx
)
;
SharedTableVector
tables
;
if
(
!
instantiateTables
(
cx
imports
.
tables
&
tableObjs
&
tables
)
)
{
return
false
;
}
if
(
!
instantiateGlobals
(
cx
imports
.
globalValues
imports
.
globalObjs
)
)
{
return
false
;
}
UniqueDebugState
maybeDebug
;
if
(
codeMeta
(
)
.
debugEnabled
)
{
maybeDebug
=
cx
-
>
make_unique
<
DebugState
>
(
*
code_
*
this
)
;
if
(
!
maybeDebug
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
instance
.
set
(
WasmInstanceObject
:
:
create
(
cx
code_
dataSegments_
elemSegments_
codeMeta
(
)
.
instanceDataLength
memories
std
:
:
move
(
tables
)
imports
.
funcs
codeMeta
(
)
.
globals
imports
.
globalValues
imports
.
globalObjs
imports
.
tagObjs
instanceProto
std
:
:
move
(
maybeDebug
)
)
)
;
if
(
!
instance
)
{
return
false
;
}
if
(
!
CreateExportObject
(
cx
instance
imports
.
funcs
tableObjs
.
get
(
)
memories
.
get
(
)
imports
.
tagObjs
imports
.
globalValues
imports
.
globalObjs
moduleMeta
(
)
.
exports
)
)
{
return
false
;
}
if
(
!
cx
-
>
realm
(
)
-
>
wasm
.
registerInstance
(
cx
instance
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
if
(
!
instance
-
>
instance
(
)
.
initSegments
(
cx
dataSegments_
elemSegments_
)
)
{
return
false
;
}
if
(
codeMeta
(
)
.
startFuncIndex
)
{
FixedInvokeArgs
<
0
>
args
(
cx
)
;
if
(
!
instance
-
>
instance
(
)
.
callExport
(
cx
*
codeMeta
(
)
.
startFuncIndex
args
)
)
{
return
false
;
}
}
JSUseCounter
useCounter
=
codeMeta
(
)
.
isAsmJS
(
)
?
JSUseCounter
:
:
ASMJS
:
JSUseCounter
:
:
WASM
;
cx
-
>
runtime
(
)
-
>
setUseCounter
(
instance
useCounter
)
;
SetUseCountersForFeatureUsage
(
cx
instance
codeMeta
(
)
.
featureUsage
)
;
if
(
cx
-
>
options
(
)
.
testWasmAwaitTier2
(
)
)
{
testingBlockOnTier2Complete
(
)
;
}
return
true
;
}
