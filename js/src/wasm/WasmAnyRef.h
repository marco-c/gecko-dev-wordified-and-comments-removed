#
ifndef
wasm_anyref_h
#
define
wasm_anyref_h
#
include
<
utility
>
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
class
JSObject
;
class
JSString
;
namespace
js
{
namespace
gc
{
struct
Cell
;
}
;
namespace
wasm
{
enum
class
AnyRefKind
:
uint8_t
{
Null
Object
}
;
enum
class
AnyRefTag
:
uint8_t
{
ObjectOrNull
=
0x0
}
;
static
constexpr
uintptr_t
TAG_MASK
=
0x3
;
static
constexpr
uintptr_t
TAG_SHIFT
=
2
;
static_assert
(
TAG_SHIFT
<
=
gc
:
:
CellAlignShift
"
not
enough
free
bits
"
)
;
static
constexpr
uintptr_t
AddAnyRefTag
(
uintptr_t
value
AnyRefTag
tag
)
{
MOZ_ASSERT
(
!
(
value
&
TAG_MASK
)
)
;
return
value
|
uintptr_t
(
tag
)
;
}
static
constexpr
AnyRefTag
GetAnyRefTag
(
uintptr_t
value
)
{
return
(
AnyRefTag
)
(
value
&
TAG_MASK
)
;
}
static
constexpr
uintptr_t
RemoveAnyRefTag
(
uintptr_t
value
)
{
return
value
&
~
TAG_MASK
;
}
static
constexpr
uintptr_t
NULLREF_VALUE
=
0
;
static_assert
(
GetAnyRefTag
(
NULLREF_VALUE
)
=
=
AnyRefTag
:
:
ObjectOrNull
)
;
static
constexpr
uintptr_t
INVALIDREF_VALUE
=
UINTPTR_MAX
&
~
TAG_MASK
;
static_assert
(
GetAnyRefTag
(
INVALIDREF_VALUE
)
=
=
AnyRefTag
:
:
ObjectOrNull
)
;
class
AnyRef
{
uintptr_t
value_
;
AnyRefTag
pointerTag
(
)
const
{
return
GetAnyRefTag
(
value_
)
;
}
explicit
AnyRef
(
uintptr_t
value
)
:
value_
(
value
)
{
}
public
:
explicit
AnyRef
(
)
:
value_
(
NULLREF_VALUE
)
{
}
MOZ_IMPLICIT
AnyRef
(
std
:
:
nullptr_t
)
:
value_
(
NULLREF_VALUE
)
{
}
static
AnyRef
null
(
)
{
return
AnyRef
(
NULLREF_VALUE
)
;
}
static
AnyRef
invalid
(
)
{
return
AnyRef
(
INVALIDREF_VALUE
)
;
}
static
AnyRef
fromJSObjectOrNull
(
JSObject
*
objectOrNull
)
{
MOZ_ASSERT
(
GetAnyRefTag
(
(
uintptr_t
)
objectOrNull
)
=
=
AnyRefTag
:
:
ObjectOrNull
)
;
return
AnyRef
(
(
uintptr_t
)
objectOrNull
)
;
}
static
AnyRef
fromJSObject
(
JSObject
&
object
)
{
MOZ_ASSERT
(
GetAnyRefTag
(
(
uintptr_t
)
&
object
)
=
=
AnyRefTag
:
:
ObjectOrNull
)
;
return
AnyRef
(
(
uintptr_t
)
&
object
)
;
}
static
AnyRef
fromCompiledCode
(
void
*
pointer
)
{
return
AnyRef
(
(
uintptr_t
)
pointer
)
;
}
static
bool
fromJSValue
(
JSContext
*
cx
JS
:
:
HandleValue
value
JS
:
:
MutableHandle
<
AnyRef
>
result
)
;
static
bool
valueNeedsBoxing
(
JS
:
:
HandleValue
value
)
{
return
!
value
.
isObjectOrNull
(
)
;
}
static
JSObject
*
boxValue
(
JSContext
*
cx
JS
:
:
HandleValue
value
)
;
bool
operator
=
=
(
const
AnyRef
&
rhs
)
const
{
return
this
-
>
value_
=
=
rhs
.
value_
;
}
bool
operator
!
=
(
const
AnyRef
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
isInvalid
(
)
const
{
return
*
this
=
=
AnyRef
:
:
invalid
(
)
;
}
AnyRefKind
kind
(
)
const
{
if
(
value_
=
=
NULLREF_VALUE
)
{
return
AnyRefKind
:
:
Null
;
}
switch
(
pointerTag
(
)
)
{
case
AnyRefTag
:
:
ObjectOrNull
:
{
MOZ_ASSERT
(
!
isInvalid
(
)
)
;
return
AnyRefKind
:
:
Object
;
}
default
:
{
MOZ_CRASH
(
"
unknown
AnyRef
tag
"
)
;
}
}
}
bool
isNull
(
)
const
{
return
value_
=
=
NULLREF_VALUE
;
}
bool
isGCThing
(
)
const
{
return
kind
(
)
=
=
AnyRefKind
:
:
Object
;
}
bool
isJSObject
(
)
const
{
return
kind
(
)
=
=
AnyRefKind
:
:
Object
;
}
gc
:
:
Cell
*
toGCThing
(
)
const
{
MOZ_ASSERT
(
isGCThing
(
)
)
;
return
(
gc
:
:
Cell
*
)
RemoveAnyRefTag
(
value_
)
;
}
JSObject
&
toJSObject
(
)
const
{
MOZ_ASSERT
(
isJSObject
(
)
)
;
return
*
(
JSObject
*
)
value_
;
}
JSObject
*
toJSObjectOrNull
(
)
const
{
MOZ_ASSERT
(
!
isInvalid
(
)
)
;
return
(
JSObject
*
)
value_
;
}
JS
:
:
Value
toJSValue
(
)
const
;
void
*
forCompiledCode
(
)
const
{
return
(
void
*
)
value_
;
}
uintptr_t
rawValue
(
)
const
{
return
value_
;
}
static
const
JSClass
*
valueBoxClass
(
)
;
static
size_t
valueBoxOffsetOfValue
(
)
;
}
;
using
RootedAnyRef
=
JS
:
:
Rooted
<
AnyRef
>
;
using
HandleAnyRef
=
JS
:
:
Handle
<
AnyRef
>
;
using
MutableHandleAnyRef
=
JS
:
:
MutableHandle
<
AnyRef
>
;
#
define
ASSERT_ANYREF_IS_JSOBJECT
(
void
)
(
0
)
#
define
STATIC_ASSERT_ANYREF_IS_JSOBJECT
static_assert
(
1
"
AnyRef
is
JSObject
"
)
}
template
<
class
Wrapper
>
class
WrappedPtrOperations
<
wasm
:
:
AnyRef
Wrapper
>
{
const
wasm
:
:
AnyRef
&
value
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
bool
isNull
(
)
const
{
return
value
(
)
.
isNull
(
)
;
}
}
;
template
<
typename
F
>
auto
MapGCThingTyped
(
const
wasm
:
:
AnyRef
&
val
F
&
&
f
)
{
switch
(
val
.
kind
(
)
)
{
case
wasm
:
:
AnyRefKind
:
:
Object
:
return
mozilla
:
:
Some
(
f
(
&
val
.
toJSObject
(
)
)
)
;
case
wasm
:
:
AnyRefKind
:
:
Null
:
{
using
ReturnType
=
decltype
(
f
(
static_cast
<
JSObject
*
>
(
nullptr
)
)
)
;
return
mozilla
:
:
Maybe
<
ReturnType
>
(
)
;
}
}
MOZ_CRASH
(
)
;
}
template
<
typename
F
>
bool
ApplyGCThingTyped
(
const
wasm
:
:
AnyRef
&
val
F
&
&
f
)
{
return
MapGCThingTyped
(
val
[
&
f
]
(
auto
t
)
{
f
(
t
)
;
return
true
;
}
)
.
isSome
(
)
;
}
}
namespace
JS
{
template
<
>
struct
GCPolicy
<
js
:
:
wasm
:
:
AnyRef
>
{
static
void
trace
(
JSTracer
*
trc
js
:
:
wasm
:
:
AnyRef
*
v
const
char
*
name
)
{
TraceRoot
(
trc
v
name
)
;
}
static
bool
isValid
(
const
js
:
:
wasm
:
:
AnyRef
&
v
)
{
return
!
v
.
isGCThing
(
)
|
|
js
:
:
gc
:
:
IsCellPointerValid
(
v
.
toGCThing
(
)
)
;
}
}
;
}
#
endif
