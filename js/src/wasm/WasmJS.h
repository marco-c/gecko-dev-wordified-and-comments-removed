#
ifndef
wasm_js_h
#
define
wasm_js_h
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
stdint
.
h
>
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
ZoneAllocator
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
SweepingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
BufferSize
.
h
"
#
include
"
vm
/
JSFunction
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
wasm
/
WasmTypes
.
h
"
class
JSFreeOp
;
class
JSObject
;
class
JSTracer
;
struct
JSContext
;
namespace
JS
{
class
CallArgs
;
class
Value
;
}
namespace
js
{
class
ArrayBufferObject
;
class
ArrayBufferObjectMaybeShared
;
class
JSStringBuilder
;
class
SharedArrayRawBuffer
;
class
TypedArrayObject
;
class
WasmFunctionScope
;
class
WasmInstanceScope
;
namespace
wasm
{
struct
ImportValues
;
bool
HasPlatformSupport
(
JSContext
*
cx
)
;
bool
HasSupport
(
JSContext
*
cx
)
;
bool
BaselineAvailable
(
JSContext
*
cx
)
;
bool
IonAvailable
(
JSContext
*
cx
)
;
bool
CraneliftAvailable
(
JSContext
*
cx
)
;
bool
AnyCompilerAvailable
(
JSContext
*
cx
)
;
bool
IonDisabledByFeatures
(
JSContext
*
cx
bool
*
isDisabled
JSStringBuilder
*
reason
=
nullptr
)
;
bool
CraneliftDisabledByFeatures
(
JSContext
*
cx
bool
*
isDisabled
JSStringBuilder
*
reason
=
nullptr
)
;
bool
StreamingCompilationAvailable
(
JSContext
*
cx
)
;
bool
CodeCachingAvailable
(
JSContext
*
cx
)
;
bool
ReftypesAvailable
(
JSContext
*
cx
)
;
bool
FunctionReferencesAvailable
(
JSContext
*
cx
)
;
bool
GcTypesAvailable
(
JSContext
*
cx
)
;
bool
MultiValuesAvailable
(
JSContext
*
cx
)
;
bool
ThreadsAvailable
(
JSContext
*
cx
)
;
bool
SimdAvailable
(
JSContext
*
cx
)
;
bool
SimdWormholeAvailable
(
JSContext
*
cx
)
;
#
if
defined
(
ENABLE_WASM_SIMD
)
&
&
defined
(
DEBUG
)
void
ReportSimdAnalysis
(
const
char
*
data
)
;
#
endif
bool
ExceptionsAvailable
(
JSContext
*
cx
)
;
size_t
MaxMemory32Pages
(
)
;
size_t
MaxMemory32BoundsCheckLimit
(
)
;
static
inline
size_t
MaxMemory32Bytes
(
)
{
return
MaxMemory32Pages
(
)
*
PageSize
;
}
[
[
nodiscard
]
]
bool
Eval
(
JSContext
*
cx
Handle
<
TypedArrayObject
*
>
code
HandleObject
importObj
HandleValue
maybeOptions
MutableHandleWasmInstanceObject
instanceObj
)
;
struct
ImportValues
;
[
[
nodiscard
]
]
bool
GetImports
(
JSContext
*
cx
const
Module
&
module
HandleObject
importObj
ImportValues
*
imports
)
;
[
[
nodiscard
]
]
bool
CompileAndSerialize
(
const
ShareableBytes
&
bytecode
Bytes
*
serialized
)
;
[
[
nodiscard
]
]
bool
DeserializeModule
(
JSContext
*
cx
const
Bytes
&
serialized
MutableHandleObject
module
)
;
bool
IsWasmExportedFunction
(
JSFunction
*
fun
)
;
Instance
&
ExportedFunctionToInstance
(
JSFunction
*
fun
)
;
WasmInstanceObject
*
ExportedFunctionToInstanceObject
(
JSFunction
*
fun
)
;
uint32_t
ExportedFunctionToFuncIndex
(
JSFunction
*
fun
)
;
bool
IsSharedWasmMemoryObject
(
JSObject
*
obj
)
;
}
class
WasmModuleObject
:
public
NativeObject
{
static
const
unsigned
MODULE_SLOT
=
0
;
static
const
JSClassOps
classOps_
;
static
const
ClassSpec
classSpec_
;
static
void
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
static
bool
imports
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
exports
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
customSections
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
1
;
static
const
JSClass
class_
;
static
const
JSClass
&
protoClass_
;
static
const
JSPropertySpec
properties
[
]
;
static
const
JSFunctionSpec
methods
[
]
;
static
const
JSFunctionSpec
static_methods
[
]
;
static
bool
construct
(
JSContext
*
unsigned
Value
*
)
;
static
WasmModuleObject
*
create
(
JSContext
*
cx
const
wasm
:
:
Module
&
module
HandleObject
proto
)
;
const
wasm
:
:
Module
&
module
(
)
const
;
}
;
STATIC_ASSERT_ANYREF_IS_JSOBJECT
;
class
WasmGlobalObject
:
public
NativeObject
{
static
const
unsigned
MUTABLE_SLOT
=
0
;
static
const
unsigned
VAL_SLOT
=
1
;
static
const
JSClassOps
classOps_
;
static
const
ClassSpec
classSpec_
;
static
void
finalize
(
JSFreeOp
*
JSObject
*
obj
)
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
bool
typeImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
static
bool
type
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
valueGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
static
bool
valueGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
valueSetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
static
bool
valueSetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
2
;
static
const
JSClass
class_
;
static
const
JSClass
&
protoClass_
;
static
const
JSPropertySpec
properties
[
]
;
static
const
JSFunctionSpec
methods
[
]
;
static
const
JSFunctionSpec
static_methods
[
]
;
static
bool
construct
(
JSContext
*
unsigned
Value
*
)
;
static
WasmGlobalObject
*
create
(
JSContext
*
cx
wasm
:
:
HandleVal
value
bool
isMutable
HandleObject
proto
)
;
bool
isNewborn
(
)
{
return
getReservedSlot
(
VAL_SLOT
)
.
isUndefined
(
)
;
}
bool
isMutable
(
)
const
;
wasm
:
:
ValType
type
(
)
const
;
wasm
:
:
GCPtrVal
&
val
(
)
const
;
}
;
class
WasmInstanceObject
:
public
NativeObject
{
static
const
unsigned
INSTANCE_SLOT
=
0
;
static
const
unsigned
EXPORTS_OBJ_SLOT
=
1
;
static
const
unsigned
EXPORTS_SLOT
=
2
;
static
const
unsigned
SCOPES_SLOT
=
3
;
static
const
unsigned
INSTANCE_SCOPE_SLOT
=
4
;
static
const
unsigned
GLOBALS_SLOT
=
5
;
static
const
JSClassOps
classOps_
;
static
const
ClassSpec
classSpec_
;
static
bool
exportsGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
static
bool
exportsGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
bool
isNewborn
(
)
const
;
static
void
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
using
ExportMap
=
GCHashMap
<
uint32_t
HeapPtr
<
JSFunction
*
>
DefaultHasher
<
uint32_t
>
ZoneAllocPolicy
>
;
ExportMap
&
exports
(
)
const
;
class
UnspecifiedScopeMap
;
UnspecifiedScopeMap
&
scopes
(
)
const
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
6
;
static
const
JSClass
class_
;
static
const
JSClass
&
protoClass_
;
static
const
JSPropertySpec
properties
[
]
;
static
const
JSFunctionSpec
methods
[
]
;
static
const
JSFunctionSpec
static_methods
[
]
;
static
bool
construct
(
JSContext
*
unsigned
Value
*
)
;
static
WasmInstanceObject
*
create
(
JSContext
*
cx
RefPtr
<
const
wasm
:
:
Code
>
code
const
wasm
:
:
DataSegmentVector
&
dataSegments
const
wasm
:
:
ElemSegmentVector
&
elemSegments
wasm
:
:
UniqueTlsData
tlsData
HandleWasmMemoryObject
memory
Vector
<
RefPtr
<
wasm
:
:
ExceptionTag
>
0
SystemAllocPolicy
>
&
&
exceptionTags
Vector
<
RefPtr
<
wasm
:
:
Table
>
0
SystemAllocPolicy
>
&
&
tables
const
JSFunctionVector
&
funcImports
const
wasm
:
:
GlobalDescVector
&
globals
const
wasm
:
:
ValVector
&
globalImportValues
const
WasmGlobalObjectVector
&
globalObjs
HandleObject
proto
UniquePtr
<
wasm
:
:
DebugState
>
maybeDebug
)
;
void
initExportsObj
(
JSObject
&
exportsObj
)
;
wasm
:
:
Instance
&
instance
(
)
const
;
JSObject
&
exportsObj
(
)
const
;
static
bool
getExportedFunction
(
JSContext
*
cx
HandleWasmInstanceObject
instanceObj
uint32_t
funcIndex
MutableHandleFunction
fun
)
;
const
wasm
:
:
CodeRange
&
getExportedFunctionCodeRange
(
JSFunction
*
fun
wasm
:
:
Tier
tier
)
;
static
WasmInstanceScope
*
getScope
(
JSContext
*
cx
HandleWasmInstanceObject
instanceObj
)
;
static
WasmFunctionScope
*
getFunctionScope
(
JSContext
*
cx
HandleWasmInstanceObject
instanceObj
uint32_t
funcIndex
)
;
using
GlobalObjectVector
=
GCVector
<
HeapPtr
<
WasmGlobalObject
*
>
0
ZoneAllocPolicy
>
;
GlobalObjectVector
&
indirectGlobals
(
)
const
;
}
;
class
WasmMemoryObject
:
public
NativeObject
{
static
const
unsigned
BUFFER_SLOT
=
0
;
static
const
unsigned
OBSERVERS_SLOT
=
1
;
static
const
JSClassOps
classOps_
;
static
const
ClassSpec
classSpec_
;
static
void
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
static
bool
bufferGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
static
bool
bufferGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
typeImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
static
bool
type
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
growImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
static
bool
grow
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
uint32_t
growShared
(
HandleWasmMemoryObject
memory
uint32_t
delta
)
;
using
InstanceSet
=
JS
:
:
WeakCache
<
GCHashSet
<
WeakHeapPtrWasmInstanceObject
MovableCellHasher
<
WeakHeapPtrWasmInstanceObject
>
ZoneAllocPolicy
>
>
;
bool
hasObservers
(
)
const
;
InstanceSet
&
observers
(
)
const
;
InstanceSet
*
getOrCreateObservers
(
JSContext
*
cx
)
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
2
;
static
const
JSClass
class_
;
static
const
JSClass
&
protoClass_
;
static
const
JSPropertySpec
properties
[
]
;
static
const
JSFunctionSpec
methods
[
]
;
static
const
JSFunctionSpec
static_methods
[
]
;
static
bool
construct
(
JSContext
*
unsigned
Value
*
)
;
static
WasmMemoryObject
*
create
(
JSContext
*
cx
Handle
<
ArrayBufferObjectMaybeShared
*
>
buffer
HandleObject
proto
)
;
ArrayBufferObjectMaybeShared
&
buffer
(
)
const
;
js
:
:
BufferSize
volatileMemoryLength
(
)
const
;
bool
isShared
(
)
const
;
bool
isHuge
(
)
const
;
bool
movingGrowable
(
)
const
;
js
:
:
BufferSize
boundsCheckLimit
(
)
const
;
SharedArrayRawBuffer
*
sharedArrayRawBuffer
(
)
const
;
bool
addMovingGrowObserver
(
JSContext
*
cx
WasmInstanceObject
*
instance
)
;
static
uint32_t
grow
(
HandleWasmMemoryObject
memory
uint32_t
delta
JSContext
*
cx
)
;
}
;
class
WasmTableObject
:
public
NativeObject
{
static
const
unsigned
TABLE_SLOT
=
0
;
static
const
JSClassOps
classOps_
;
static
const
ClassSpec
classSpec_
;
bool
isNewborn
(
)
const
;
static
void
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
static
bool
lengthGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
static
bool
lengthGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
typeImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
static
bool
type
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
getImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
static
bool
get
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
setImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
static
bool
set
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
bool
growImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
;
static
bool
grow
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
1
;
static
const
JSClass
class_
;
static
const
JSClass
&
protoClass_
;
static
const
JSPropertySpec
properties
[
]
;
static
const
JSFunctionSpec
methods
[
]
;
static
const
JSFunctionSpec
static_methods
[
]
;
static
bool
construct
(
JSContext
*
unsigned
Value
*
)
;
static
WasmTableObject
*
create
(
JSContext
*
cx
uint32_t
initialLength
mozilla
:
:
Maybe
<
uint32_t
>
maximumLength
wasm
:
:
RefType
tableType
HandleObject
proto
)
;
wasm
:
:
Table
&
table
(
)
const
;
bool
fillRange
(
JSContext
*
cx
uint32_t
index
uint32_t
length
HandleValue
value
)
const
;
#
ifdef
DEBUG
void
assertRangeNull
(
uint32_t
index
uint32_t
length
)
const
;
#
endif
}
;
class
WasmExceptionObject
:
public
NativeObject
{
static
const
unsigned
TAG_SLOT
=
0
;
static
const
unsigned
TYPE_SLOT
=
1
;
static
const
JSClassOps
classOps_
;
static
const
ClassSpec
classSpec_
;
static
void
finalize
(
JSFreeOp
*
JSObject
*
obj
)
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
2
;
static
const
JSClass
class_
;
static
const
JSClass
&
protoClass_
;
static
const
JSPropertySpec
properties
[
]
;
static
const
JSFunctionSpec
methods
[
]
;
static
const
JSFunctionSpec
static_methods
[
]
;
static
bool
construct
(
JSContext
*
unsigned
Value
*
)
;
static
WasmExceptionObject
*
create
(
JSContext
*
cx
const
wasm
:
:
ValTypeVector
&
type
HandleObject
proto
)
;
bool
isNewborn
(
)
const
;
wasm
:
:
ValTypeVector
&
valueTypes
(
)
const
;
wasm
:
:
ResultType
resultType
(
)
const
;
wasm
:
:
ExceptionTag
&
tag
(
)
const
;
}
;
class
WasmRuntimeExceptionObject
:
public
NativeObject
{
static
const
unsigned
TAG_SLOT
=
0
;
static
const
unsigned
VALUES_SLOT
=
1
;
static
const
unsigned
REFS_SLOT
=
2
;
static
const
JSClassOps
classOps_
;
static
const
ClassSpec
classSpec_
;
static
void
finalize
(
JSFreeOp
*
JSObject
*
obj
)
;
static
void
trace
(
JSTracer
*
trc
JSObject
*
obj
)
;
public
:
static
const
unsigned
RESERVED_SLOTS
=
3
;
static
const
JSClass
class_
;
static
const
JSClass
&
protoClass_
;
static
const
JSPropertySpec
properties
[
]
;
static
const
JSFunctionSpec
methods
[
]
;
static
const
JSFunctionSpec
static_methods
[
]
;
static
bool
construct
(
JSContext
*
unsigned
Value
*
)
;
static
WasmRuntimeExceptionObject
*
create
(
JSContext
*
cx
wasm
:
:
SharedExceptionTag
tag
Handle
<
ArrayBufferObject
*
>
values
HandleArrayObject
refs
)
;
bool
isNewborn
(
)
const
;
wasm
:
:
ExceptionTag
&
tag
(
)
const
;
ArrayObject
&
refs
(
)
const
;
static
size_t
offsetOfValues
(
)
{
return
NativeObject
:
:
getFixedSlotOffset
(
VALUES_SLOT
)
;
}
static
size_t
offsetOfRefs
(
)
{
return
NativeObject
:
:
getFixedSlotOffset
(
REFS_SLOT
)
;
}
}
;
class
WasmNamespaceObject
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
private
:
static
const
ClassSpec
classSpec_
;
}
;
}
#
endif
