#
ifndef
wasm_TypedObject_h
#
define
wasm_TypedObject_h
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
wasm
/
WasmTypes
.
h
"
namespace
js
{
class
TypedProto
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
static
TypedProto
*
create
(
JSContext
*
cx
)
;
}
;
class
RttValue
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
enum
Slot
{
Handle
=
0
Size
=
1
Proto
=
2
TraceList
=
3
SlotCount
=
4
}
;
static
RttValue
*
createFromHandle
(
JSContext
*
cx
wasm
:
:
TypeHandle
handle
)
;
TypedProto
&
typedProto
(
)
const
{
return
getReservedSlot
(
Slot
:
:
Proto
)
.
toObject
(
)
.
as
<
TypedProto
>
(
)
;
}
size_t
size
(
)
const
{
return
getReservedSlot
(
Slot
:
:
Size
)
.
toInt32
(
)
;
}
const
wasm
:
:
TypeDef
&
getType
(
JSContext
*
cx
)
const
;
[
[
nodiscard
]
]
bool
lookupProperty
(
JSContext
*
cx
jsid
id
uint32_t
*
offset
wasm
:
:
ValType
*
type
)
;
[
[
nodiscard
]
]
bool
hasProperty
(
JSContext
*
cx
jsid
id
)
{
uint32_t
offset
;
wasm
:
:
ValType
type
;
return
lookupProperty
(
cx
id
&
offset
&
type
)
;
}
uint32_t
propertyCount
(
JSContext
*
cx
)
;
[
[
nodiscard
]
]
bool
hasTraceList
(
)
const
{
return
!
getFixedSlot
(
Slot
:
:
TraceList
)
.
isUndefined
(
)
;
}
const
uint32_t
*
traceList
(
)
const
{
MOZ_ASSERT
(
hasTraceList
(
)
)
;
return
reinterpret_cast
<
uint32_t
*
>
(
getFixedSlot
(
Slot
:
:
TraceList
)
.
toPrivate
(
)
)
;
}
void
initInstance
(
JSContext
*
cx
uint8_t
*
mem
)
;
void
traceInstance
(
JSTracer
*
trace
uint8_t
*
mem
)
;
static
void
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
}
;
using
HandleRttValue
=
Handle
<
RttValue
*
>
;
class
TypedObject
:
public
JSObject
{
protected
:
GCPtr
<
RttValue
*
>
rttValue_
;
static
const
ObjectOps
objectOps_
;
[
[
nodiscard
]
]
static
bool
obj_lookupProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleObject
objp
MutableHandle
<
PropertyResult
>
propp
)
;
[
[
nodiscard
]
]
static
bool
obj_defineProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Handle
<
PropertyDescriptor
>
desc
ObjectOpResult
&
result
)
;
[
[
nodiscard
]
]
static
bool
obj_hasProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
foundp
)
;
[
[
nodiscard
]
]
static
bool
obj_getProperty
(
JSContext
*
cx
HandleObject
obj
HandleValue
receiver
HandleId
id
MutableHandleValue
vp
)
;
[
[
nodiscard
]
]
static
bool
obj_setProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
;
[
[
nodiscard
]
]
static
bool
obj_getOwnPropertyDescriptor
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandle
<
PropertyDescriptor
>
desc
)
;
[
[
nodiscard
]
]
static
bool
obj_deleteProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
ObjectOpResult
&
result
)
;
bool
loadValue
(
JSContext
*
cx
size_t
offset
wasm
:
:
ValType
type
MutableHandleValue
vp
)
;
uint8_t
*
typedMem
(
)
const
;
uint8_t
*
typedMemBase
(
)
const
;
public
:
[
[
nodiscard
]
]
static
bool
obj_newEnumerate
(
JSContext
*
cx
HandleObject
obj
MutableHandleIdVector
properties
bool
enumerableOnly
)
;
TypedProto
&
typedProto
(
)
const
{
return
staticPrototype
(
)
-
>
as
<
TypedProto
>
(
)
;
}
RttValue
&
rttValue
(
)
const
{
MOZ_ASSERT
(
rttValue_
)
;
return
*
rttValue_
;
}
static
JS
:
:
Result
<
TypedObject
*
JS
:
:
OOM
>
create
(
JSContext
*
cx
js
:
:
gc
:
:
AllocKind
kind
js
:
:
gc
:
:
InitialHeap
heap
js
:
:
HandleShape
shape
)
;
uint32_t
offset
(
)
const
;
uint32_t
size
(
)
const
{
return
rttValue
(
)
.
size
(
)
;
}
uint8_t
*
typedMem
(
const
JS
:
:
AutoRequireNoGC
&
)
const
{
return
typedMem
(
)
;
}
uint8_t
*
typedMem
(
size_t
offset
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
offset
<
=
(
size_t
)
size
(
)
)
;
return
typedMem
(
nogc
)
+
offset
;
}
static
TypedObject
*
createZeroed
(
JSContext
*
cx
HandleRttValue
typeObj
gc
:
:
InitialHeap
heap
=
gc
:
:
DefaultHeap
)
;
static
constexpr
size_t
offsetOfRttValue
(
)
{
return
offsetof
(
TypedObject
rttValue_
)
;
}
}
;
using
HandleTypedObject
=
Handle
<
TypedObject
*
>
;
class
OutlineTypedObject
:
public
TypedObject
{
JSObject
*
owner_
;
uint8_t
*
data_
;
void
setOwnerAndData
(
JSObject
*
owner
uint8_t
*
data
)
;
void
setData
(
uint8_t
*
data
)
{
data_
=
data
;
}
public
:
static
constexpr
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
OBJECT2
;
static
size_t
offsetOfData
(
)
{
return
offsetof
(
OutlineTypedObject
data_
)
;
}
static
size_t
offsetOfOwner
(
)
{
return
offsetof
(
OutlineTypedObject
owner_
)
;
}
static
const
JSClass
class_
;
JSObject
&
owner
(
)
const
{
MOZ_ASSERT
(
owner_
)
;
return
*
owner_
;
}
uint8_t
*
outOfLineTypedMem
(
)
const
{
return
data_
;
}
private
:
static
OutlineTypedObject
*
createUnattached
(
JSContext
*
cx
HandleRttValue
type
gc
:
:
InitialHeap
heap
=
gc
:
:
DefaultHeap
)
;
public
:
static
OutlineTypedObject
*
createZeroed
(
JSContext
*
cx
HandleRttValue
rtt
gc
:
:
InitialHeap
heap
)
;
private
:
void
attach
(
ArrayBufferObject
&
buffer
)
;
public
:
static
void
obj_trace
(
JSTracer
*
trace
JSObject
*
object
)
;
}
;
class
InlineTypedObject
:
public
TypedObject
{
friend
class
TypedObject
;
uint8_t
data_
[
1
]
;
public
:
static
const
JSClass
class_
;
static
const
size_t
MaxInlineBytes
=
JSObject
:
:
MAX_BYTE_SIZE
-
sizeof
(
TypedObject
)
;
protected
:
uint8_t
*
inlineTypedMem
(
)
const
{
return
(
uint8_t
*
)
&
data_
;
}
public
:
static
inline
gc
:
:
AllocKind
allocKindForRttValue
(
RttValue
*
rtt
)
;
static
bool
canAccommodateSize
(
size_t
size
)
{
return
size
<
=
MaxInlineBytes
;
}
static
bool
canAccommodateType
(
RttValue
*
type
)
{
return
type
-
>
size
(
)
<
=
MaxInlineBytes
;
}
uint8_t
*
inlineTypedMem
(
const
JS
:
:
AutoRequireNoGC
&
)
const
{
return
inlineTypedMem
(
)
;
}
static
void
obj_trace
(
JSTracer
*
trace
JSObject
*
object
)
;
static
size_t
obj_moved
(
JSObject
*
dst
JSObject
*
src
)
;
static
size_t
offsetOfDataStart
(
)
{
return
offsetof
(
InlineTypedObject
data_
)
;
}
static
InlineTypedObject
*
create
(
JSContext
*
cx
HandleRttValue
rtt
gc
:
:
InitialHeap
heap
=
gc
:
:
DefaultHeap
)
;
}
;
inline
bool
IsTypedObjectClass
(
const
JSClass
*
class_
)
{
return
class_
=
=
&
OutlineTypedObject
:
:
class_
|
|
class_
=
=
&
InlineTypedObject
:
:
class_
;
}
inline
bool
IsOutlineTypedObjectClass
(
const
JSClass
*
class_
)
{
return
class_
=
=
&
OutlineTypedObject
:
:
class_
;
}
inline
bool
IsInlineTypedObjectClass
(
const
JSClass
*
class_
)
{
return
class_
=
=
&
InlineTypedObject
:
:
class_
;
}
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
TypedObject
>
(
)
const
{
return
js
:
:
IsTypedObjectClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
OutlineTypedObject
>
(
)
const
{
return
js
:
:
IsOutlineTypedObjectClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
InlineTypedObject
>
(
)
const
{
return
js
:
:
IsInlineTypedObjectClass
(
getClass
(
)
)
;
}
#
endif
