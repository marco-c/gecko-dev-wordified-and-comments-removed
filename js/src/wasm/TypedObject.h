#
ifndef
wasm_TypedObject_h
#
define
wasm_TypedObject_h
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
WeakMap
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
experimental
/
JitInfo
.
h
"
#
include
"
js
/
ScalarType
.
h
"
#
include
"
vm
/
ArrayBufferObject
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
Uint8Clamped
.
h
"
namespace
js
{
class
WasmNamespaceObject
;
extern
bool
InitTypedObjectSlots
(
JSContext
*
cx
Handle
<
WasmNamespaceObject
*
>
namespaceObject
)
;
class
TypedProto
:
public
NativeObject
{
public
:
static
const
JSClass
class_
;
protected
:
friend
class
ArrayMetaTypeDescr
;
friend
class
StructMetaTypeDescr
;
static
TypedProto
*
create
(
JSContext
*
cx
)
;
}
;
enum
class
TypeKind
:
int32_t
{
Scalar
Reference
Struct
Array
}
;
class
TypeDescr
:
public
NativeObject
{
public
:
enum
Slot
{
Kind
=
0
StringRepr
=
1
Alignment
=
2
Size
=
3
Proto
=
4
TraceList
=
5
Type
=
6
ArrayElemType
=
6
ArrayLength
=
7
StructFieldNames
=
6
StructFieldTypes
=
7
StructFieldOffsets
=
8
StructFieldMuts
=
9
SlotCount
=
10
}
;
TypedProto
&
typedProto
(
)
const
{
return
getReservedSlot
(
Slot
:
:
Proto
)
.
toObject
(
)
.
as
<
TypedProto
>
(
)
;
}
JSAtom
&
stringRepr
(
)
const
{
return
getReservedSlot
(
Slot
:
:
StringRepr
)
.
toString
(
)
-
>
asAtom
(
)
;
}
TypeKind
kind
(
)
const
{
return
(
TypeKind
)
getReservedSlot
(
Slot
:
:
Kind
)
.
toInt32
(
)
;
}
uint32_t
alignment
(
)
const
{
int32_t
i
=
getReservedSlot
(
Slot
:
:
Alignment
)
.
toInt32
(
)
;
MOZ_ASSERT
(
i
>
=
0
)
;
return
uint32_t
(
i
)
;
}
uint32_t
size
(
)
const
{
int32_t
i
=
getReservedSlot
(
Slot
:
:
Size
)
.
toInt32
(
)
;
MOZ_ASSERT
(
i
>
=
0
)
;
return
uint32_t
(
i
)
;
}
MOZ_MUST_USE
bool
hasProperty
(
const
JSAtomState
&
names
jsid
id
)
;
MOZ_MUST_USE
bool
hasTraceList
(
)
const
{
return
!
getFixedSlot
(
Slot
:
:
TraceList
)
.
isUndefined
(
)
;
}
const
uint32_t
*
traceList
(
)
const
{
MOZ_ASSERT
(
hasTraceList
(
)
)
;
return
reinterpret_cast
<
uint32_t
*
>
(
getFixedSlot
(
Slot
:
:
TraceList
)
.
toPrivate
(
)
)
;
}
void
initInstance
(
uint8_t
*
mem
)
;
void
traceInstance
(
JSTracer
*
trace
uint8_t
*
mem
)
;
static
void
finalize
(
JSFreeOp
*
fop
JSObject
*
obj
)
;
}
;
using
HandleTypeDescr
=
Handle
<
TypeDescr
*
>
;
class
SimpleTypeDescr
:
public
TypeDescr
{
}
;
class
ComplexTypeDescr
:
public
TypeDescr
{
}
;
class
ScalarTypeDescr
:
public
SimpleTypeDescr
{
public
:
using
Type
=
Scalar
:
:
Type
;
static
const
TypeKind
Kind
=
TypeKind
:
:
Scalar
;
static
uint32_t
size
(
Type
t
)
;
static
uint32_t
alignment
(
Type
t
)
;
static
const
char
*
typeName
(
Type
type
)
;
static
const
JSClass
class_
;
Type
type
(
)
const
{
return
Type
(
getReservedSlot
(
Slot
:
:
Type
)
.
toInt32
(
)
)
;
}
static
MOZ_MUST_USE
bool
call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
}
;
#
define
JS_FOR_EACH_SCALAR_NUMBER_TYPE_REPR
(
MACRO_
)
\
MACRO_
(
Scalar
:
:
Int32
int32_t
int32
WasmNamespaceObject
:
:
Int32Desc
)
\
MACRO_
(
Scalar
:
:
Float32
float
float32
WasmNamespaceObject
:
:
Float32Desc
)
\
MACRO_
(
Scalar
:
:
Float64
double
float64
WasmNamespaceObject
:
:
Float64Desc
)
#
define
JS_FOR_EACH_SCALAR_BIGINT_TYPE_REPR
(
MACRO_
)
\
MACRO_
(
Scalar
:
:
BigInt64
int64_t
bigint64
WasmNamespaceObject
:
:
Int64Desc
)
#
define
JS_FOR_EACH_SCALAR_TYPE_REPR
(
MACRO_
)
\
JS_FOR_EACH_SCALAR_NUMBER_TYPE_REPR
(
MACRO_
)
\
JS_FOR_EACH_SCALAR_BIGINT_TYPE_REPR
(
MACRO_
)
enum
class
ReferenceType
{
TYPE_OBJECT
TYPE_WASM_ANYREF
}
;
class
ReferenceTypeDescr
:
public
SimpleTypeDescr
{
public
:
using
Type
=
ReferenceType
;
static
const
char
*
typeName
(
Type
type
)
;
static
const
int32_t
TYPE_MAX
=
int32_t
(
ReferenceType
:
:
TYPE_WASM_ANYREF
)
+
1
;
static
const
TypeKind
Kind
=
TypeKind
:
:
Reference
;
static
const
JSClass
class_
;
static
uint32_t
size
(
Type
t
)
;
static
uint32_t
alignment
(
Type
t
)
;
ReferenceType
type
(
)
const
{
return
(
ReferenceType
)
getReservedSlot
(
Slot
:
:
Type
)
.
toInt32
(
)
;
}
const
char
*
typeName
(
)
const
{
return
typeName
(
type
(
)
)
;
}
static
MOZ_MUST_USE
bool
call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
}
;
#
define
JS_FOR_EACH_REFERENCE_TYPE_REPR
(
MACRO_
)
\
MACRO_
(
ReferenceType
:
:
TYPE_OBJECT
GCPtrObject
Object
\
WasmNamespaceObject
:
:
ObjectDesc
)
\
MACRO_
(
ReferenceType
:
:
TYPE_WASM_ANYREF
GCPtrObject
WasmAnyRef
\
WasmNamespaceObject
:
:
WasmAnyRefDesc
)
class
ArrayTypeDescr
;
class
ArrayMetaTypeDescr
:
public
NativeObject
{
private
:
static
ArrayTypeDescr
*
create
(
JSContext
*
cx
HandleObject
arrayTypePrototype
HandleTypeDescr
elementType
HandleAtom
stringRepr
int32_t
size
int32_t
length
)
;
public
:
static
MOZ_MUST_USE
bool
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
}
;
class
ArrayTypeDescr
:
public
ComplexTypeDescr
{
public
:
static
const
JSClass
class_
;
static
const
TypeKind
Kind
=
TypeKind
:
:
Array
;
TypeDescr
&
elementType
(
)
const
{
return
getReservedSlot
(
Slot
:
:
ArrayElemType
)
.
toObject
(
)
.
as
<
TypeDescr
>
(
)
;
}
uint32_t
length
(
)
const
{
int32_t
i
=
getReservedSlot
(
Slot
:
:
ArrayLength
)
.
toInt32
(
)
;
MOZ_ASSERT
(
i
>
=
0
)
;
return
uint32_t
(
i
)
;
}
static
int32_t
offsetOfLength
(
)
{
return
getFixedSlotOffset
(
Slot
:
:
ArrayLength
)
;
}
}
;
struct
StructFieldProps
{
StructFieldProps
(
)
:
isMutable
(
0
)
alignAsInt64
(
0
)
alignAsV128
(
0
)
{
}
uint32_t
isMutable
:
1
;
uint32_t
alignAsInt64
:
1
;
uint32_t
alignAsV128
:
1
;
}
;
class
StructTypeDescr
;
class
StructMetaTypeDescr
:
public
NativeObject
{
public
:
static
StructTypeDescr
*
createFromArrays
(
JSContext
*
cx
HandleObject
structTypePrototype
HandleIdVector
ids
HandleValueVector
fieldTypeObjs
Vector
<
StructFieldProps
>
&
fieldProps
)
;
static
MOZ_MUST_USE
bool
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
class
Layout
{
friend
class
StructMetaTypeDescr
;
mozilla
:
:
CheckedInt32
sizeSoFar
=
0
;
int32_t
structAlignment
=
1
;
mozilla
:
:
CheckedInt32
addField
(
int32_t
fieldAlignment
int32_t
fieldSize
)
;
public
:
mozilla
:
:
CheckedInt32
addScalar
(
Scalar
:
:
Type
type
)
;
mozilla
:
:
CheckedInt32
addReference
(
ReferenceType
type
)
;
mozilla
:
:
CheckedInt32
close
(
int32_t
*
alignment
=
nullptr
)
;
}
;
}
;
class
StructTypeDescr
:
public
ComplexTypeDescr
{
public
:
static
const
JSClass
class_
;
size_t
fieldCount
(
)
const
;
MOZ_MUST_USE
bool
fieldIndex
(
jsid
id
size_t
*
out
)
const
;
JSAtom
&
fieldName
(
size_t
index
)
const
;
TypeDescr
&
fieldDescr
(
size_t
index
)
const
;
size_t
fieldOffset
(
size_t
index
)
const
;
bool
fieldIsMutable
(
size_t
index
)
const
;
static
bool
call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
private
:
ArrayObject
&
fieldInfoObject
(
size_t
slot
)
const
{
return
getReservedSlot
(
slot
)
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
;
}
}
;
using
HandleStructTypeDescr
=
Handle
<
StructTypeDescr
*
>
;
class
TypedObject
:
public
JSObject
{
static
MOZ_MUST_USE
bool
obj_getArrayElement
(
JSContext
*
cx
Handle
<
TypedObject
*
>
typedObj
Handle
<
TypeDescr
*
>
typeDescr
uint32_t
index
MutableHandleValue
vp
)
;
protected
:
static
const
ObjectOps
objectOps_
;
static
MOZ_MUST_USE
bool
obj_lookupProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandleObject
objp
MutableHandle
<
PropertyResult
>
propp
)
;
static
MOZ_MUST_USE
bool
obj_defineProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Handle
<
PropertyDescriptor
>
desc
ObjectOpResult
&
result
)
;
static
MOZ_MUST_USE
bool
obj_hasProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
foundp
)
;
static
MOZ_MUST_USE
bool
obj_getProperty
(
JSContext
*
cx
HandleObject
obj
HandleValue
receiver
HandleId
id
MutableHandleValue
vp
)
;
static
MOZ_MUST_USE
bool
obj_getElement
(
JSContext
*
cx
HandleObject
obj
HandleValue
receiver
uint32_t
index
MutableHandleValue
vp
)
;
static
MOZ_MUST_USE
bool
obj_setProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
HandleValue
v
HandleValue
receiver
ObjectOpResult
&
result
)
;
static
MOZ_MUST_USE
bool
obj_getOwnPropertyDescriptor
(
JSContext
*
cx
HandleObject
obj
HandleId
id
MutableHandle
<
PropertyDescriptor
>
desc
)
;
static
MOZ_MUST_USE
bool
obj_deleteProperty
(
JSContext
*
cx
HandleObject
obj
HandleId
id
ObjectOpResult
&
result
)
;
bool
loadValue
(
JSContext
*
cx
size_t
offset
HandleTypeDescr
type
MutableHandleValue
vp
)
;
uint8_t
*
typedMem
(
)
const
;
uint8_t
*
typedMemBase
(
)
const
;
public
:
static
MOZ_MUST_USE
bool
obj_newEnumerate
(
JSContext
*
cx
HandleObject
obj
MutableHandleIdVector
properties
bool
enumerableOnly
)
;
TypedProto
&
typedProto
(
)
const
{
return
staticPrototype
(
)
-
>
as
<
TypedProto
>
(
)
;
}
TypeDescr
&
typeDescr
(
)
const
{
return
group
(
)
-
>
typeDescr
(
)
;
}
static
JS
:
:
Result
<
TypedObject
*
JS
:
:
OOM
>
create
(
JSContext
*
cx
js
:
:
gc
:
:
AllocKind
kind
js
:
:
gc
:
:
InitialHeap
heap
js
:
:
HandleShape
shape
js
:
:
HandleObjectGroup
group
)
;
uint32_t
offset
(
)
const
;
uint32_t
length
(
)
const
;
uint8_t
*
typedMem
(
const
JS
:
:
AutoRequireNoGC
&
)
const
{
return
typedMem
(
)
;
}
uint32_t
size
(
)
const
{
return
typeDescr
(
)
.
size
(
)
;
}
uint8_t
*
typedMem
(
size_t
offset
const
JS
:
:
AutoRequireNoGC
&
nogc
)
const
{
MOZ_ASSERT
(
offset
<
=
(
size_t
)
size
(
)
)
;
return
typedMem
(
nogc
)
+
offset
;
}
static
TypedObject
*
createZeroed
(
JSContext
*
cx
HandleTypeDescr
typeObj
gc
:
:
InitialHeap
heap
=
gc
:
:
DefaultHeap
)
;
static
MOZ_MUST_USE
bool
construct
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
Shape
*
*
addressOfShapeFromGC
(
)
{
return
shape_
.
unbarrieredAddress
(
)
;
}
}
;
using
HandleTypedObject
=
Handle
<
TypedObject
*
>
;
class
OutlineTypedObject
:
public
TypedObject
{
JSObject
*
owner_
;
uint8_t
*
data_
;
void
setOwnerAndData
(
JSObject
*
owner
uint8_t
*
data
)
;
void
setData
(
uint8_t
*
data
)
{
data_
=
data
;
}
public
:
static
size_t
offsetOfData
(
)
{
return
offsetof
(
OutlineTypedObject
data_
)
;
}
static
size_t
offsetOfOwner
(
)
{
return
offsetof
(
OutlineTypedObject
owner_
)
;
}
static
const
JSClass
class_
;
JSObject
&
owner
(
)
const
{
MOZ_ASSERT
(
owner_
)
;
return
*
owner_
;
}
uint8_t
*
outOfLineTypedMem
(
)
const
{
return
data_
;
}
private
:
static
OutlineTypedObject
*
createUnattached
(
JSContext
*
cx
HandleTypeDescr
type
gc
:
:
InitialHeap
heap
=
gc
:
:
DefaultHeap
)
;
public
:
static
OutlineTypedObject
*
createZeroed
(
JSContext
*
cx
HandleTypeDescr
descr
gc
:
:
InitialHeap
heap
)
;
private
:
void
attach
(
ArrayBufferObject
&
buffer
)
;
public
:
static
void
obj_trace
(
JSTracer
*
trace
JSObject
*
object
)
;
}
;
class
InlineTypedObject
:
public
TypedObject
{
friend
class
TypedObject
;
uint8_t
data_
[
1
]
;
public
:
static
const
JSClass
class_
;
static
const
size_t
MaxInlineBytes
=
JSObject
:
:
MAX_BYTE_SIZE
-
sizeof
(
TypedObject
)
;
protected
:
uint8_t
*
inlineTypedMem
(
)
const
{
return
(
uint8_t
*
)
&
data_
;
}
public
:
static
inline
gc
:
:
AllocKind
allocKindForTypeDescriptor
(
TypeDescr
*
descr
)
;
static
bool
canAccommodateSize
(
size_t
size
)
{
return
size
<
=
MaxInlineBytes
;
}
static
bool
canAccommodateType
(
TypeDescr
*
type
)
{
return
type
-
>
size
(
)
<
=
MaxInlineBytes
;
}
uint8_t
*
inlineTypedMem
(
const
JS
:
:
AutoRequireNoGC
&
)
const
{
return
inlineTypedMem
(
)
;
}
static
void
obj_trace
(
JSTracer
*
trace
JSObject
*
object
)
;
static
size_t
obj_moved
(
JSObject
*
dst
JSObject
*
src
)
;
static
size_t
offsetOfDataStart
(
)
{
return
offsetof
(
InlineTypedObject
data_
)
;
}
static
InlineTypedObject
*
create
(
JSContext
*
cx
HandleTypeDescr
descr
gc
:
:
InitialHeap
heap
=
gc
:
:
DefaultHeap
)
;
}
;
inline
bool
IsTypedObjectClass
(
const
JSClass
*
class_
)
{
return
class_
=
=
&
OutlineTypedObject
:
:
class_
|
|
class_
=
=
&
InlineTypedObject
:
:
class_
;
}
inline
bool
IsOutlineTypedObjectClass
(
const
JSClass
*
class_
)
{
return
class_
=
=
&
OutlineTypedObject
:
:
class_
;
}
inline
bool
IsInlineTypedObjectClass
(
const
JSClass
*
class_
)
{
return
class_
=
=
&
InlineTypedObject
:
:
class_
;
}
inline
bool
IsSimpleTypeDescrClass
(
const
JSClass
*
clasp
)
{
return
clasp
=
=
&
ScalarTypeDescr
:
:
class_
|
|
clasp
=
=
&
ReferenceTypeDescr
:
:
class_
;
}
inline
bool
IsComplexTypeDescrClass
(
const
JSClass
*
clasp
)
{
return
clasp
=
=
&
StructTypeDescr
:
:
class_
|
|
clasp
=
=
&
ArrayTypeDescr
:
:
class_
;
}
inline
bool
IsTypeDescrClass
(
const
JSClass
*
clasp
)
{
return
IsSimpleTypeDescrClass
(
clasp
)
|
|
IsComplexTypeDescrClass
(
clasp
)
;
}
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
SimpleTypeDescr
>
(
)
const
{
return
js
:
:
IsSimpleTypeDescrClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
ComplexTypeDescr
>
(
)
const
{
return
js
:
:
IsComplexTypeDescrClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
TypeDescr
>
(
)
const
{
return
js
:
:
IsTypeDescrClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
TypedObject
>
(
)
const
{
return
js
:
:
IsTypedObjectClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
OutlineTypedObject
>
(
)
const
{
return
js
:
:
IsOutlineTypedObjectClass
(
getClass
(
)
)
;
}
template
<
>
inline
bool
JSObject
:
:
is
<
js
:
:
InlineTypedObject
>
(
)
const
{
return
js
:
:
IsInlineTypedObjectClass
(
getClass
(
)
)
;
}
#
endif
