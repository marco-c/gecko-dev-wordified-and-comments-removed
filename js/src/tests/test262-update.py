#
-
*
-
coding
:
utf
-
8
-
*
-
from
__future__
import
print_function
import
contextlib
import
io
import
os
import
tempfile
import
shutil
import
sys
from
functools
import
partial
from
itertools
import
chain
imap
UNSUPPORTED_FEATURES
=
set
(
[
"
tail
-
call
-
optimization
"
]
)
contextlib
.
contextmanager
def
TemporaryDirectory
(
)
:
    
tmpDir
=
tempfile
.
mkdtemp
(
)
    
try
:
        
yield
tmpDir
    
finally
:
        
shutil
.
rmtree
(
tmpDir
)
def
loadTest262Parser
(
test262Dir
)
:
    
"
"
"
    
Loads
the
test262
test
record
parser
.
    
"
"
"
    
import
imp
    
fileObj
=
None
    
try
:
        
moduleName
=
"
parseTestRecord
"
        
packagingDir
=
os
.
path
.
join
(
test262Dir
"
tools
"
"
packaging
"
)
        
(
fileObj
pathName
description
)
=
imp
.
find_module
(
moduleName
[
packagingDir
]
)
        
return
imp
.
load_module
(
moduleName
fileObj
pathName
description
)
    
finally
:
        
if
fileObj
:
            
fileObj
.
close
(
)
def
tryParseTestFile
(
test262parser
source
testName
)
:
    
"
"
"
    
Returns
the
result
of
test262parser
.
parseTestRecord
(
)
or
None
if
a
parser
    
error
occured
.
    
See
<
https
:
/
/
github
.
com
/
tc39
/
test262
/
blob
/
master
/
INTERPRETING
.
md
>
for
an
    
overview
of
the
returned
test
attributes
.
    
"
"
"
    
try
:
        
return
test262parser
.
parseTestRecord
(
source
testName
)
    
except
Exception
as
err
:
        
print
(
"
Error
'
%
s
'
in
file
:
%
s
"
%
(
err
testName
)
file
=
sys
.
stderr
)
        
print
(
"
Please
report
this
error
to
the
test262
GitHub
repository
!
"
)
        
return
None
def
createRefTestEntry
(
skip
skipIf
error
isModule
)
:
    
"
"
"
    
Creates
the
|
reftest
|
entry
from
the
input
list
.
Or
the
empty
string
if
no
    
reftest
entry
is
required
.
    
"
"
"
    
terms
=
[
]
    
comments
=
[
]
    
if
skip
:
        
terms
.
append
(
"
skip
"
)
        
comments
.
extend
(
skip
)
    
if
skipIf
:
        
terms
.
append
(
"
skip
-
if
(
"
+
"
|
|
"
.
join
(
[
cond
for
(
cond
_
)
in
skipIf
]
)
+
"
)
"
)
        
comments
.
extend
(
[
comment
for
(
_
comment
)
in
skipIf
]
)
    
if
error
:
        
terms
.
append
(
"
error
:
"
+
error
)
    
if
isModule
:
        
terms
.
append
(
"
module
"
)
    
line
=
"
"
.
join
(
terms
)
    
if
comments
:
        
line
+
=
"
-
-
"
+
"
"
.
join
(
comments
)
    
return
line
def
createSource
(
testSource
refTest
prologue
epilogue
)
:
    
"
"
"
    
Returns
the
post
-
processed
source
for
|
testSource
|
.
    
"
"
"
    
source
=
testSource
    
if
prologue
:
        
source
=
prologue
+
"
\
n
"
+
source
    
if
refTest
:
        
source
=
"
/
/
|
reftest
|
"
+
refTest
+
"
\
n
"
+
source
    
if
epilogue
:
        
source
+
=
"
\
n
"
+
epilogue
+
"
\
n
"
    
return
source
def
writeTestFile
(
test262OutDir
testFileName
source
)
:
    
"
"
"
    
Writes
the
test
source
to
|
test262OutDir
|
.
    
"
"
"
    
with
io
.
open
(
os
.
path
.
join
(
test262OutDir
testFileName
)
"
wb
"
)
as
output
:
        
output
.
write
(
source
)
def
addSuffixToFileName
(
fileName
suffix
)
:
    
(
filePath
ext
)
=
os
.
path
.
splitext
(
fileName
)
    
return
filePath
+
suffix
+
ext
def
writeShellAndBrowserFiles
(
test262OutDir
harnessDir
includesMap
localIncludesMap
relPath
)
:
    
"
"
"
    
Generate
the
shell
.
js
and
browser
.
js
files
for
the
test
harness
.
    
"
"
"
    
def
findParentIncludes
(
relPath
includesMap
)
:
        
parentIncludes
=
set
(
)
        
current
=
relPath
        
while
current
:
            
(
parent
child
)
=
os
.
path
.
split
(
current
)
            
if
parent
in
includesMap
:
                
parentIncludes
.
update
(
includesMap
[
parent
]
)
            
current
=
parent
        
return
parentIncludes
    
def
findIncludes
(
includesMap
relPath
)
:
        
includeSet
=
includesMap
[
relPath
]
        
parentIncludes
=
findParentIncludes
(
relPath
includesMap
)
        
for
include
in
includeSet
:
            
if
include
not
in
parentIncludes
:
                
yield
include
    
def
readIncludeFile
(
filePath
)
:
        
with
io
.
open
(
filePath
"
rb
"
)
as
includeFile
:
            
return
"
/
/
file
:
%
s
\
n
%
s
"
%
(
os
.
path
.
basename
(
filePath
)
includeFile
.
read
(
)
)
    
localIncludes
=
localIncludesMap
[
relPath
]
if
relPath
in
localIncludesMap
else
[
]
    
includeSource
=
"
\
n
"
.
join
(
imap
(
readIncludeFile
chain
(
        
imap
(
partial
(
os
.
path
.
join
harnessDir
)
findIncludes
(
includesMap
relPath
)
)
        
imap
(
partial
(
os
.
path
.
join
os
.
getcwd
(
)
)
localIncludes
)
    
)
)
)
    
with
io
.
open
(
os
.
path
.
join
(
test262OutDir
relPath
"
shell
.
js
"
)
"
wb
"
)
as
shellFile
:
        
shellFile
.
write
(
includeSource
)
    
with
io
.
open
(
os
.
path
.
join
(
test262OutDir
relPath
"
browser
.
js
"
)
"
wb
"
)
as
browserFile
:
        
browserFile
.
write
(
"
"
)
def
pathStartsWith
(
path
*
args
)
:
    
prefix
=
os
.
path
.
join
(
*
args
)
    
return
os
.
path
.
commonprefix
(
[
path
prefix
]
)
=
=
prefix
def
fileNameEndsWith
(
filePath
suffix
)
:
    
return
os
.
path
.
splitext
(
os
.
path
.
basename
(
filePath
)
)
[
0
]
.
endswith
(
suffix
)
def
convertTestFile
(
test262parser
testSource
testName
includeSet
strictTests
)
:
    
"
"
"
    
Convert
a
test262
test
to
a
compatible
jstests
test
file
.
    
"
"
"
    
testRec
=
tryParseTestFile
(
test262parser
testSource
testName
)
    
refTestSkip
=
[
]
    
refTestSkipIf
=
[
]
    
if
testRec
is
None
:
        
refTestSkip
.
append
(
"
has
YAML
errors
"
)
        
testRec
=
dict
(
)
    
onlyStrict
=
"
onlyStrict
"
in
testRec
    
noStrict
=
"
noStrict
"
in
testRec
    
raw
=
"
raw
"
in
testRec
    
async
=
"
async
"
in
testRec
    
assert
"
DONE
"
not
in
testSource
or
async
"
Missing
async
attribute
in
:
%
s
"
%
testName
    
isModule
=
"
module
"
in
testRec
    
isNegative
=
"
negative
"
in
testRec
    
assert
not
isNegative
or
type
(
testRec
[
"
negative
"
]
)
=
=
dict
    
errorType
=
testRec
[
"
negative
"
]
[
"
type
"
]
if
isNegative
else
None
    
isSupportFile
=
fileNameEndsWith
(
testName
"
FIXTURE
"
)
    
if
isSupportFile
:
        
refTestSkip
.
append
(
"
not
a
test
file
"
)
    
if
"
features
"
in
testRec
:
        
unsupported
=
UNSUPPORTED_FEATURES
.
intersection
(
testRec
[
"
features
"
]
)
        
if
unsupported
:
            
refTestSkip
.
append
(
"
%
s
is
not
supported
"
%
"
"
.
join
(
list
(
unsupported
)
)
)
    
if
"
includes
"
in
testRec
:
        
assert
not
raw
"
Raw
test
with
includes
:
%
s
"
%
testName
        
includeSet
.
update
(
testRec
[
"
includes
"
]
)
    
if
not
isNegative
and
not
async
and
not
isSupportFile
:
        
testEpilogue
=
"
reportCompare
(
0
0
)
;
"
    
else
:
        
testEpilogue
=
"
"
    
refTest
=
createRefTestEntry
(
refTestSkip
refTestSkipIf
errorType
isModule
)
    
noStrictVariant
=
raw
or
isModule
or
isSupportFile
    
assert
not
(
noStrictVariant
and
(
onlyStrict
or
noStrict
)
)
\
           
"
Unexpected
onlyStrict
or
noStrict
attribute
:
%
s
"
%
testName
    
if
noStrictVariant
or
noStrict
or
not
onlyStrict
:
        
testPrologue
=
"
"
        
nonStrictSource
=
createSource
(
testSource
refTest
testPrologue
testEpilogue
)
        
testFileName
=
testName
        
yield
(
testFileName
nonStrictSource
)
    
if
not
noStrictVariant
and
(
onlyStrict
or
(
not
noStrict
and
strictTests
)
)
:
        
testPrologue
=
"
'
use
strict
'
;
"
        
strictSource
=
createSource
(
testSource
refTest
testPrologue
testEpilogue
)
        
testFileName
=
testName
        
if
not
noStrict
:
            
testFileName
=
addSuffixToFileName
(
testFileName
"
-
strict
"
)
        
yield
(
testFileName
strictSource
)
def
process_test262
(
test262Dir
test262OutDir
strictTests
)
:
    
"
"
"
    
Process
all
test262
files
and
converts
them
into
jstests
compatible
tests
.
    
"
"
"
    
harnessDir
=
os
.
path
.
join
(
test262Dir
"
harness
"
)
    
testDir
=
os
.
path
.
join
(
test262Dir
"
test
"
)
    
test262parser
=
loadTest262Parser
(
test262Dir
)
    
includesMap
=
{
}
    
localIncludesMap
=
{
}
    
includesMap
[
"
"
]
=
set
(
[
"
sta
.
js
"
"
assert
.
js
"
]
)
    
localIncludesMap
[
"
"
]
=
[
"
test262
-
host
.
js
"
]
    
includesMap
[
"
"
]
.
update
(
[
"
propertyHelper
.
js
"
"
compareArray
.
js
"
]
)
    
writeShellAndBrowserFiles
(
test262OutDir
harnessDir
includesMap
localIncludesMap
"
"
)
    
explicitIncludes
=
{
}
    
explicitIncludes
[
"
intl402
"
]
=
[
"
testBuiltInObject
.
js
"
]
    
explicitIncludes
[
os
.
path
.
join
(
"
built
-
ins
"
"
DataView
"
)
]
=
[
"
byteConversionValues
.
js
"
]
    
explicitIncludes
[
os
.
path
.
join
(
"
built
-
ins
"
"
Promise
"
)
]
=
[
"
PromiseHelper
.
js
"
]
    
explicitIncludes
[
os
.
path
.
join
(
"
built
-
ins
"
"
TypedArray
"
)
]
=
[
"
byteConversionValues
.
js
"
        
"
detachArrayBuffer
.
js
"
"
nans
.
js
"
]
    
explicitIncludes
[
os
.
path
.
join
(
"
built
-
ins
"
"
TypedArrays
"
)
]
=
[
"
detachArrayBuffer
.
js
"
]
    
localIncludesMap
[
os
.
path
.
join
(
"
intl402
"
"
PluralRules
"
)
]
=
[
"
test262
-
intl
-
extras
.
js
"
]
    
for
(
dirPath
dirNames
fileNames
)
in
os
.
walk
(
testDir
)
:
        
relPath
=
os
.
path
.
relpath
(
dirPath
testDir
)
        
if
relPath
=
=
"
.
"
:
            
continue
        
os
.
makedirs
(
os
.
path
.
join
(
test262OutDir
relPath
)
)
        
includeSet
=
set
(
)
        
includesMap
[
relPath
]
=
includeSet
        
if
relPath
in
explicitIncludes
:
            
includeSet
.
update
(
explicitIncludes
[
relPath
]
)
        
for
fileName
in
fileNames
:
            
filePath
=
os
.
path
.
join
(
dirPath
fileName
)
            
testName
=
os
.
path
.
relpath
(
filePath
testDir
)
            
(
_
fileExt
)
=
os
.
path
.
splitext
(
fileName
)
            
if
fileExt
!
=
"
.
js
"
:
                
shutil
.
copyfile
(
filePath
os
.
path
.
join
(
test262OutDir
testName
)
)
                
continue
            
with
io
.
open
(
filePath
"
rb
"
)
as
testFile
:
                
testSource
=
testFile
.
read
(
)
            
for
(
newFileName
newSource
)
in
convertTestFile
(
test262parser
testSource
testName
includeSet
strictTests
)
:
                
writeTestFile
(
test262OutDir
newFileName
newSource
)
        
writeShellAndBrowserFiles
(
test262OutDir
harnessDir
includesMap
localIncludesMap
relPath
)
def
update_test262
(
args
)
:
    
import
subprocess
    
url
=
args
.
url
    
branch
=
args
.
branch
    
revision
=
args
.
revision
    
outDir
=
args
.
out
    
if
not
os
.
path
.
isabs
(
outDir
)
:
        
outDir
=
os
.
path
.
join
(
os
.
getcwd
(
)
outDir
)
    
strictTests
=
args
.
strict
    
with
TemporaryDirectory
(
)
as
inDir
:
        
if
revision
=
=
"
HEAD
"
:
            
subprocess
.
check_call
(
[
"
git
"
"
clone
"
"
-
-
depth
=
1
"
"
-
-
branch
=
%
s
"
%
branch
url
inDir
]
)
        
else
:
            
subprocess
.
check_call
(
[
"
git
"
"
clone
"
"
-
-
single
-
branch
"
"
-
-
branch
=
%
s
"
%
branch
url
inDir
]
)
            
subprocess
.
check_call
(
[
"
git
"
"
-
C
"
inDir
"
reset
"
"
-
-
hard
"
revision
]
)
        
if
os
.
path
.
isdir
(
outDir
)
:
            
shutil
.
rmtree
(
outDir
)
        
os
.
makedirs
(
outDir
)
        
shutil
.
copyfile
(
os
.
path
.
join
(
inDir
"
LICENSE
"
)
os
.
path
.
join
(
outDir
"
LICENSE
"
)
)
        
with
io
.
open
(
os
.
path
.
join
(
outDir
"
GIT
-
INFO
"
)
"
wb
"
)
as
info
:
            
subprocess
.
check_call
(
[
"
git
"
"
-
C
"
inDir
"
log
"
"
-
1
"
]
stdout
=
info
)
        
process_test262
(
inDir
outDir
strictTests
)
if
__name__
=
=
"
__main__
"
:
    
import
argparse
    
if
"
/
"
.
join
(
os
.
path
.
normpath
(
os
.
getcwd
(
)
)
.
split
(
os
.
sep
)
[
-
3
:
]
)
!
=
"
js
/
src
/
tests
"
:
        
raise
RuntimeError
(
"
%
s
must
be
run
from
js
/
src
/
tests
"
%
sys
.
argv
[
0
]
)
    
parser
=
argparse
.
ArgumentParser
(
description
=
"
Update
the
test262
test
suite
.
"
)
    
parser
.
add_argument
(
"
-
-
url
"
default
=
"
git
:
/
/
github
.
com
/
tc39
/
test262
.
git
"
                        
help
=
"
URL
to
git
repository
(
default
:
%
(
default
)
s
)
"
)
    
parser
.
add_argument
(
"
-
-
branch
"
default
=
"
master
"
                        
help
=
"
Git
branch
(
default
:
%
(
default
)
s
)
"
)
    
parser
.
add_argument
(
"
-
-
revision
"
default
=
"
HEAD
"
                        
help
=
"
Git
revision
(
default
:
%
(
default
)
s
)
"
)
    
parser
.
add_argument
(
"
-
-
out
"
default
=
"
test262
"
                        
help
=
"
Output
directory
.
Any
existing
directory
will
be
removed
!
(
default
:
%
(
default
)
s
)
"
)
    
parser
.
add_argument
(
"
-
-
strict
"
default
=
False
action
=
"
store_true
"
                        
help
=
"
Generate
additional
strict
mode
tests
.
Not
enabled
by
default
.
"
)
    
parser
.
set_defaults
(
func
=
update_test262
)
    
args
=
parser
.
parse_args
(
)
    
args
.
func
(
args
)
