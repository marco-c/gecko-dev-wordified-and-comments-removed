const
numberFormatFunctions
=
[
]
;
numberFormatFunctions
.
push
(
Intl
.
NumberFormat
.
prototype
.
resolvedOptions
)
;
numberFormatFunctions
.
push
(
Object
.
getOwnPropertyDescriptor
(
Intl
.
NumberFormat
.
prototype
"
format
"
)
.
get
)
;
if
(
"
formatToParts
"
in
Intl
.
NumberFormat
.
prototype
)
numberFormatFunctions
.
push
(
Intl
.
NumberFormat
.
prototype
.
formatToParts
)
;
function
IsConstructor
(
o
)
{
try
{
new
(
new
Proxy
(
o
{
construct
:
(
)
=
>
(
{
}
)
}
)
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
function
IsObject
(
o
)
{
return
Object
(
o
)
=
=
=
o
;
}
function
intlObjects
(
ctor
)
{
return
[
new
ctor
(
)
new
class
extends
ctor
{
}
Object
.
setPrototypeOf
(
new
ctor
(
)
Object
.
prototype
)
]
;
}
function
thisValues
(
C
)
{
const
intlConstructors
=
Object
.
getOwnPropertyNames
(
Intl
)
.
map
(
name
=
>
Intl
[
name
]
)
.
filter
(
IsConstructor
)
;
return
[
.
.
.
[
undefined
null
true
"
abc
"
Symbol
(
)
123
]
.
.
.
[
{
}
[
]
/
(
?
:
)
/
function
(
)
{
}
new
Proxy
(
{
}
{
}
)
]
.
.
.
[
]
.
concat
(
.
.
.
intlConstructors
.
filter
(
ctor
=
>
ctor
!
=
=
C
)
.
map
(
intlObjects
)
)
.
.
.
intlConstructors
.
map
(
ctor
=
>
Object
.
create
(
ctor
.
prototype
)
)
]
;
}
const
intlFallbackSymbol
=
Object
.
getOwnPropertySymbols
(
Intl
.
NumberFormat
.
call
(
Object
.
create
(
Intl
.
NumberFormat
.
prototype
)
)
)
[
0
]
;
for
(
let
numberFormatFunction
of
numberFormatFunctions
)
{
for
(
let
thisValue
of
thisValues
(
Intl
.
NumberFormat
)
)
{
assertThrowsInstanceOf
(
(
)
=
>
numberFormatFunction
.
call
(
thisValue
)
TypeError
)
;
}
for
(
let
thisValue
of
intlObjects
(
Intl
.
NumberFormat
)
)
{
numberFormatFunction
.
call
(
thisValue
)
;
}
for
(
let
thisValue
of
thisValues
(
Intl
.
NumberFormat
)
)
{
assertThrowsInstanceOf
(
(
)
=
>
numberFormatFunction
.
call
(
{
__proto__
:
Intl
.
NumberFormat
.
prototype
[
intlFallbackSymbol
]
:
thisValue
}
)
TypeError
)
;
}
for
(
let
thisValue
of
intlObjects
(
Intl
.
NumberFormat
)
)
{
numberFormatFunction
.
call
(
{
__proto__
:
Intl
.
NumberFormat
.
prototype
[
intlFallbackSymbol
]
:
thisValue
}
)
;
}
for
(
let
thisValue
of
intlObjects
(
Intl
.
NumberFormat
)
)
{
Object
.
defineProperty
(
thisValue
intlFallbackSymbol
{
get
(
)
{
assertEq
(
false
true
)
;
}
}
)
;
numberFormatFunction
.
call
(
thisValue
)
;
}
for
(
let
thisValue
of
thisValues
(
Intl
.
NumberFormat
)
)
{
if
(
!
IsObject
(
thisValue
)
|
|
Intl
.
NumberFormat
.
prototype
.
isPrototypeOf
(
thisValue
)
)
continue
;
Object
.
defineProperty
(
thisValue
intlFallbackSymbol
{
get
(
)
{
assertEq
(
false
true
)
;
}
}
)
;
assertThrowsInstanceOf
(
(
)
=
>
numberFormatFunction
.
call
(
thisValue
)
TypeError
)
;
}
for
(
let
thisValue
of
thisValues
(
Intl
.
NumberFormat
)
)
{
let
hasInstanceCalled
=
false
symbolGetterCalled
=
false
;
Object
.
defineProperty
(
Intl
.
NumberFormat
Symbol
.
hasInstance
{
value
(
)
{
assertEq
(
hasInstanceCalled
false
)
;
hasInstanceCalled
=
true
;
return
true
;
}
configurable
:
true
}
)
;
let
isUndefinedOrNull
=
thisValue
!
=
=
undefined
|
|
thisValue
!
=
=
null
;
let
symbolHolder
;
if
(
!
isUndefinedOrNull
)
{
symbolHolder
=
IsObject
(
thisValue
)
?
thisValue
:
Object
.
getPrototypeOf
(
thisValue
)
;
Object
.
defineProperty
(
symbolHolder
intlFallbackSymbol
{
get
(
)
{
assertEq
(
symbolGetterCalled
false
)
;
symbolGetterCalled
=
true
;
return
null
;
}
configurable
:
true
}
)
;
}
assertThrowsInstanceOf
(
(
)
=
>
numberFormatFunction
.
call
(
thisValue
)
TypeError
)
;
delete
Intl
.
NumberFormat
[
Symbol
.
hasInstance
]
;
if
(
!
isUndefinedOrNull
&
&
!
IsObject
(
thisValue
)
)
delete
symbolHolder
[
intlFallbackSymbol
]
;
assertEq
(
hasInstanceCalled
true
)
;
assertEq
(
symbolGetterCalled
!
isUndefinedOrNull
)
;
}
}
{
let
numberFormat
=
new
Intl
.
NumberFormat
(
)
;
let
thisValue
=
Object
.
create
(
Intl
.
NumberFormat
.
prototype
)
;
Intl
.
NumberFormat
.
call
(
thisValue
)
;
let
fakeObj
=
{
__proto__
:
Intl
.
NumberFormat
.
prototype
[
intlFallbackSymbol
]
:
numberFormat
}
;
for
(
let
number
of
[
0
1
1
.
5
Infinity
NaN
]
)
{
let
expected
=
numberFormat
.
format
(
number
)
;
assertEq
(
thisValue
.
format
(
number
)
expected
)
;
assertEq
(
thisValue
[
intlFallbackSymbol
]
.
format
(
number
)
expected
)
;
assertEq
(
fakeObj
.
format
(
number
)
expected
)
;
}
}
if
(
"
formatToParts
"
in
Intl
.
NumberFormat
.
prototype
)
{
let
numberFormat
=
new
Intl
.
NumberFormat
(
)
;
let
thisValue
=
Object
.
create
(
Intl
.
NumberFormat
.
prototype
)
;
Intl
.
NumberFormat
.
call
(
thisValue
)
;
let
fakeObj
=
{
__proto__
:
Intl
.
NumberFormat
.
prototype
[
intlFallbackSymbol
]
:
numberFormat
}
;
function
assertEqParts
(
actual
expected
)
{
assertEq
(
actual
.
length
expected
.
length
"
parts
count
mismatch
"
)
;
for
(
var
i
=
0
;
i
<
expected
.
length
;
i
+
+
)
{
assertEq
(
actual
[
i
]
.
type
expected
[
i
]
.
type
"
type
mismatch
at
"
+
i
)
;
assertEq
(
actual
[
i
]
.
value
expected
[
i
]
.
value
"
value
mismatch
at
"
+
i
)
;
}
}
for
(
let
number
of
[
0
1
1
.
5
Infinity
NaN
]
)
{
let
expected
=
numberFormat
.
formatToParts
(
number
)
;
assertEqParts
(
thisValue
.
formatToParts
(
number
)
expected
)
;
assertEqParts
(
thisValue
[
intlFallbackSymbol
]
.
formatToParts
(
number
)
expected
)
;
assertEqParts
(
fakeObj
.
formatToParts
(
number
)
expected
)
;
}
}
{
let
numberFormat
=
new
Intl
.
NumberFormat
(
)
;
let
thisValue
=
Object
.
create
(
Intl
.
NumberFormat
.
prototype
)
;
Intl
.
NumberFormat
.
call
(
thisValue
)
;
let
fakeObj
=
{
__proto__
:
Intl
.
NumberFormat
.
prototype
[
intlFallbackSymbol
]
:
numberFormat
}
;
function
assertEqOptions
(
actual
expected
)
{
actual
=
Object
.
entries
(
actual
)
;
expected
=
Object
.
entries
(
expected
)
;
assertEq
(
actual
.
length
expected
.
length
"
options
count
mismatch
"
)
;
for
(
var
i
=
0
;
i
<
expected
.
length
;
i
+
+
)
{
assertEq
(
actual
[
i
]
[
0
]
expected
[
i
]
[
0
]
"
key
mismatch
at
"
+
i
)
;
assertEq
(
actual
[
i
]
[
1
]
expected
[
i
]
[
1
]
"
value
mismatch
at
"
+
i
)
;
}
}
let
expected
=
numberFormat
.
resolvedOptions
(
)
;
assertEqOptions
(
thisValue
.
resolvedOptions
(
)
expected
)
;
assertEqOptions
(
thisValue
[
intlFallbackSymbol
]
.
resolvedOptions
(
)
expected
)
;
assertEqOptions
(
fakeObj
.
resolvedOptions
(
)
expected
)
;
}
if
(
typeof
reportCompare
=
=
=
"
function
"
)
reportCompare
(
true
true
)
;
