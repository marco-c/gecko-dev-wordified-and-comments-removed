const
tzMapper
=
[
x
=
>
x
x
=
>
x
.
toUpperCase
(
)
x
=
>
x
.
toLowerCase
(
)
]
;
const
utcTimeZones
=
[
"
Etc
/
UTC
"
"
Etc
/
GMT
"
"
GMT
"
"
Etc
/
Greenwich
"
"
Etc
/
GMT
-
0
"
"
Etc
/
GMT
+
0
"
"
Etc
/
GMT0
"
"
Etc
/
Universal
"
"
Etc
/
Zulu
"
"
GMT
+
0
"
"
GMT
-
0
"
"
GMT0
"
"
Greenwich
"
"
UTC
"
"
Universal
"
"
Zulu
"
]
;
for
(
let
timeZone
of
utcTimeZones
)
{
for
(
let
map
of
tzMapper
)
{
let
dtf
=
new
Intl
.
DateTimeFormat
(
undefined
{
timeZone
:
map
(
timeZone
)
}
)
;
assertEq
(
dtf
.
resolvedOptions
(
)
.
timeZone
"
UTC
"
)
;
}
}
const
uctTimeZones
=
[
"
Etc
/
UCT
"
"
UCT
"
]
;
for
(
let
timeZone
of
uctTimeZones
)
{
for
(
let
map
of
tzMapper
)
{
let
dtf
=
new
Intl
.
DateTimeFormat
(
undefined
{
timeZone
:
map
(
timeZone
)
}
)
;
assertEq
(
dtf
.
resolvedOptions
(
)
.
timeZone
"
Etc
/
UCT
"
)
;
}
}
const
invalidTimeZones
=
[
"
"
"
null
"
"
undefined
"
"
UTC
\
0
"
"
Etc
/
Unknown
"
"
GMT
-
1
"
"
GMT
+
1
"
"
GMT
-
10
"
"
GMT
+
10
"
"
GMT
-
10
:
00
"
"
GMT
+
10
:
00
"
"
GMT
-
1000
"
"
GMT
+
1000
"
"
ACT
"
"
AET
"
"
AGT
"
"
ART
"
"
AST
"
"
BET
"
"
BST
"
"
CAT
"
"
CNT
"
"
CST
"
"
CTT
"
"
EAT
"
"
ECT
"
"
IET
"
"
IST
"
"
JST
"
"
MIT
"
"
NET
"
"
NST
"
"
PLT
"
"
PNT
"
"
PRT
"
"
PST
"
"
SST
"
"
VST
"
"
SystemV
/
AST4ADT
"
"
SystemV
/
EST5EDT
"
"
SystemV
/
CST6CDT
"
"
SystemV
/
MST7MDT
"
"
SystemV
/
PST8PDT
"
"
SystemV
/
YST9YDT
"
"
SystemV
/
AST4
"
"
SystemV
/
EST5
"
"
SystemV
/
CST6
"
"
SystemV
/
MST7
"
"
SystemV
/
PST8
"
"
SystemV
/
YST9
"
"
SystemV
/
HST10
"
]
;
for
(
let
timeZone
of
invalidTimeZones
)
{
for
(
let
map
of
tzMapper
)
{
assertThrowsInstanceOf
(
(
)
=
>
{
new
Intl
.
DateTimeFormat
(
undefined
{
timeZone
:
map
(
timeZone
)
}
)
;
}
RangeError
)
;
}
}
for
(
let
gmtOffset
=
-
14
;
gmtOffset
<
=
12
;
+
+
gmtOffset
)
{
if
(
gmtOffset
=
=
=
0
)
continue
;
let
timeZone
=
Etc
/
GMT
{
gmtOffset
>
0
?
"
+
"
:
"
"
}
{
gmtOffset
}
;
for
(
let
map
of
tzMapper
)
{
let
dtf
=
new
Intl
.
DateTimeFormat
(
undefined
{
timeZone
:
map
(
timeZone
)
}
)
;
assertEq
(
dtf
.
resolvedOptions
(
)
.
timeZone
timeZone
)
;
}
}
const
invalidEtcGMTNames
=
[
"
Etc
/
GMT
-
15
"
"
Etc
/
GMT
+
13
"
"
Etc
/
GMT
-
10
:
00
"
"
Etc
/
GMT
+
10
:
00
"
"
Etc
/
GMT
-
1000
"
"
Etc
/
GMT
+
1000
"
]
;
for
(
let
timeZone
of
invalidEtcGMTNames
)
{
for
(
let
map
of
tzMapper
)
{
assertThrowsInstanceOf
(
(
)
=
>
{
new
Intl
.
DateTimeFormat
(
undefined
{
timeZone
:
map
(
timeZone
)
}
)
;
}
RangeError
)
;
}
}
for
(
let
nonStrings
of
[
null
0
0
.
5
true
false
]
)
{
assertThrowsInstanceOf
(
(
)
=
>
{
new
Intl
.
DateTimeFormat
(
undefined
{
timeZone
:
nonStrings
}
)
;
}
RangeError
)
;
}
assertThrowsInstanceOf
(
(
)
=
>
{
new
Intl
.
DateTimeFormat
(
undefined
{
timeZone
:
Symbol
(
)
}
)
;
}
TypeError
)
;
{
let
{
timeZone
:
tzAbsent
}
=
new
Intl
.
DateTimeFormat
(
undefined
{
}
)
.
resolvedOptions
(
)
;
let
{
timeZone
:
tzUndefined
}
=
new
Intl
.
DateTimeFormat
(
undefined
{
timeZone
:
undefined
}
)
.
resolvedOptions
(
)
;
assertEq
(
typeof
tzAbsent
"
string
"
)
;
assertEq
(
typeof
tzUndefined
"
string
"
)
;
assertEq
(
tzUndefined
tzAbsent
)
;
let
{
timeZone
:
tzDefault
}
=
new
Intl
.
DateTimeFormat
(
undefined
{
timeZone
:
tzAbsent
}
)
.
resolvedOptions
(
)
;
assertEq
(
tzDefault
tzAbsent
)
;
}
{
let
timeZone
=
"
Europe
/
Warsaw
"
;
let
obj
=
{
toString
(
)
{
return
timeZone
;
}
}
;
let
dtf
=
new
Intl
.
DateTimeFormat
(
undefined
{
timeZone
:
obj
}
)
;
assertEq
(
dtf
.
resolvedOptions
(
)
.
timeZone
timeZone
)
;
}
if
(
typeof
reportCompare
=
=
=
"
function
"
)
reportCompare
(
0
0
"
ok
"
)
;
