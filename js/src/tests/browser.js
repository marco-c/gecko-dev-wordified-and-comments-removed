(
function
initializeUtilityExports
(
global
parent
)
{
var
Error
=
global
.
Error
;
var
String
=
global
.
String
;
var
GlobalEval
=
global
.
eval
;
var
ReflectApply
=
global
.
Reflect
.
apply
;
var
FunctionToString
=
global
.
Function
.
prototype
.
toString
;
var
ObjectDefineProperty
=
global
.
Object
.
defineProperty
;
var
ObjectGetOwnPropertyDescriptor
=
global
.
Object
.
getOwnPropertyDescriptor
;
var
Worker
=
global
.
Worker
;
var
Blob
=
global
.
Blob
;
var
URL
=
global
.
URL
;
var
document
=
global
.
document
;
var
documentDocumentElement
=
global
.
document
.
documentElement
;
var
DocumentCreateElement
=
global
.
document
.
createElement
;
var
EventTargetPrototypeAddEventListener
=
global
.
EventTarget
.
prototype
.
addEventListener
;
var
HTMLElementPrototypeStyleSetter
=
ObjectGetOwnPropertyDescriptor
(
global
.
HTMLElement
.
prototype
"
style
"
)
.
set
;
var
HTMLIFramePrototypeContentWindowGetter
=
ObjectGetOwnPropertyDescriptor
(
global
.
HTMLIFrameElement
.
prototype
"
contentWindow
"
)
.
get
;
var
HTMLScriptElementTextSetter
=
ObjectGetOwnPropertyDescriptor
(
global
.
HTMLScriptElement
.
prototype
"
text
"
)
.
set
;
var
NodePrototypeAppendChild
=
global
.
Node
.
prototype
.
appendChild
;
var
NodePrototypeRemoveChild
=
global
.
Node
.
prototype
.
removeChild
;
var
{
get
:
WindowOnErrorGetter
set
:
WindowOnErrorSetter
}
=
ObjectGetOwnPropertyDescriptor
(
global
"
onerror
"
)
;
var
WorkerPrototypePostMessage
=
Worker
.
prototype
.
postMessage
;
var
URLCreateObjectURL
=
URL
.
createObjectURL
;
var
savedGlobalOnError
=
[
]
;
function
setGlobalOnError
(
newOnError
)
{
var
currentOnError
=
ReflectApply
(
WindowOnErrorGetter
global
[
]
)
;
ArrayPush
(
savedGlobalOnError
currentOnError
)
;
ReflectApply
(
WindowOnErrorSetter
global
[
newOnError
]
)
;
}
function
restoreGlobalOnError
(
)
{
var
previousOnError
=
ArrayPop
(
savedGlobalOnError
)
;
ReflectApply
(
WindowOnErrorSetter
global
[
previousOnError
]
)
;
}
function
ArrayPush
(
array
value
)
{
ReflectApply
(
ObjectDefineProperty
null
[
array
array
.
length
{
__proto__
:
null
value
writable
:
true
enumerable
:
true
configurable
:
true
}
]
)
;
}
function
ArrayPop
(
array
)
{
if
(
array
.
length
)
{
var
item
=
array
[
array
.
length
-
1
]
;
array
.
length
-
=
1
;
return
item
;
}
}
function
AppendChild
(
elt
kid
)
{
ReflectApply
(
NodePrototypeAppendChild
elt
[
kid
]
)
;
}
function
CreateElement
(
name
)
{
return
ReflectApply
(
DocumentCreateElement
document
[
name
]
)
;
}
function
RemoveChild
(
elt
kid
)
{
ReflectApply
(
NodePrototypeRemoveChild
elt
[
kid
]
)
;
}
function
CreateWorker
(
script
)
{
var
blob
=
new
Blob
(
[
script
]
{
__proto__
:
null
type
:
"
text
/
javascript
"
}
)
;
return
new
Worker
(
URLCreateObjectURL
(
blob
)
)
;
}
var
evaluate
=
global
.
evaluate
;
if
(
typeof
evaluate
!
=
=
"
function
"
)
{
evaluate
=
function
evaluate
(
code
)
{
if
(
typeof
code
!
=
=
"
string
"
)
throw
Error
(
"
Expected
string
argument
for
evaluate
(
)
"
)
;
return
GlobalEval
(
code
)
;
}
;
global
.
evaluate
=
evaluate
;
}
var
evaluateScript
=
global
.
evaluateScript
;
if
(
typeof
evaluateScript
!
=
=
"
function
"
)
{
evaluateScript
=
function
evaluateScript
(
code
)
{
code
=
String
(
code
)
;
var
script
=
CreateElement
(
"
script
"
)
;
var
hasUncaughtError
=
false
;
var
uncaughtError
;
var
eventOptions
=
{
__proto__
:
null
once
:
true
}
;
ReflectApply
(
EventTargetPrototypeAddEventListener
script
[
"
beforescriptexecute
"
function
(
)
{
setGlobalOnError
(
function
(
messageOrEvent
source
lineno
colno
error
)
{
hasUncaughtError
=
true
;
uncaughtError
=
error
;
return
true
;
}
)
;
}
eventOptions
]
)
;
ReflectApply
(
EventTargetPrototypeAddEventListener
script
[
"
afterscriptexecute
"
function
(
)
{
restoreGlobalOnError
(
)
;
}
eventOptions
]
)
;
ReflectApply
(
HTMLScriptElementTextSetter
script
[
code
]
)
;
AppendChild
(
documentDocumentElement
script
)
;
RemoveChild
(
documentDocumentElement
script
)
;
if
(
hasUncaughtError
)
throw
uncaughtError
;
}
;
global
.
evaluateScript
=
evaluateScript
;
}
var
newGlobal
=
global
.
newGlobal
;
if
(
typeof
newGlobal
!
=
=
"
function
"
)
{
newGlobal
=
parent
?
parent
.
newGlobal
:
function
newGlobal
(
)
{
var
iframe
=
CreateElement
(
"
iframe
"
)
;
AppendChild
(
documentDocumentElement
iframe
)
;
var
win
=
ReflectApply
(
HTMLIFramePrototypeContentWindowGetter
iframe
[
]
)
;
ReflectApply
(
HTMLElementPrototypeStyleSetter
iframe
[
"
display
:
none
"
]
)
;
var
initFunction
=
ReflectApply
(
FunctionToString
initializeUtilityExports
[
]
)
;
win
.
Function
(
"
parent
"
initFunction
+
"
;
initializeUtilityExports
(
this
parent
)
;
"
)
(
global
)
;
return
win
;
}
;
global
.
newGlobal
=
newGlobal
;
}
var
detachArrayBuffer
=
global
.
detachArrayBuffer
;
if
(
typeof
detachArrayBuffer
!
=
=
"
function
"
)
{
var
worker
=
null
;
detachArrayBuffer
=
function
detachArrayBuffer
(
arrayBuffer
)
{
if
(
worker
=
=
=
null
)
{
worker
=
CreateWorker
(
"
/
*
black
hole
*
/
"
)
;
}
ReflectApply
(
WorkerPrototypePostMessage
worker
[
"
detach
"
[
arrayBuffer
]
]
)
;
}
;
global
.
detachArrayBuffer
=
detachArrayBuffer
;
}
}
)
(
this
)
;
(
function
(
global
)
{
var
ReflectApply
=
global
.
Reflect
.
apply
;
var
ObjectGetOwnPropertyDescriptor
=
global
.
Object
.
getOwnPropertyDescriptor
;
var
String
=
global
.
String
;
var
document
=
global
.
document
;
var
DocumentCreateElement
=
global
.
document
.
createElement
;
var
NodePrototypeAppendChild
=
global
.
Node
.
prototype
.
appendChild
;
var
NodePrototypeTextContentSetter
=
ObjectGetOwnPropertyDescriptor
(
global
.
Node
.
prototype
"
textContent
"
)
.
set
;
var
HTMLElementPrototypeSetAttribute
=
global
.
Element
.
prototype
.
setAttribute
;
var
printOutputContainer
=
global
.
document
.
getElementById
(
"
jsreftest
-
print
-
output
-
container
"
)
;
function
AppendChild
(
elt
kid
)
{
ReflectApply
(
NodePrototypeAppendChild
elt
[
kid
]
)
;
}
function
CreateElement
(
name
)
{
return
ReflectApply
(
DocumentCreateElement
document
[
name
]
)
;
}
function
HTMLSetAttribute
(
element
name
value
)
{
ReflectApply
(
HTMLElementPrototypeSetAttribute
element
[
name
value
]
)
;
}
function
SetTextContent
(
element
text
)
{
ReflectApply
(
NodePrototypeTextContentSetter
element
[
text
]
)
;
}
function
AddPrintOutput
(
s
)
{
var
msgDiv
=
CreateElement
(
"
div
"
)
;
SetTextContent
(
msgDiv
s
)
;
AppendChild
(
printOutputContainer
msgDiv
)
;
}
global
.
AddPrintOutput
=
AddPrintOutput
;
function
writeHeaderToLog
(
string
)
{
string
=
String
(
string
)
;
dump
(
string
+
"
\
n
"
)
;
var
h2
=
CreateElement
(
"
h2
"
)
;
SetTextContent
(
h2
string
)
;
AppendChild
(
printOutputContainer
h2
)
;
}
global
.
writeHeaderToLog
=
writeHeaderToLog
;
function
writeFormattedResult
(
expect
actual
string
passed
)
{
string
=
String
(
string
)
;
dump
(
string
+
"
\
n
"
)
;
var
font
=
CreateElement
(
"
font
"
)
;
if
(
passed
)
{
HTMLSetAttribute
(
font
"
color
"
"
#
009900
"
)
;
SetTextContent
(
font
"
\
u00A0
"
+
global
.
PASSED
)
;
}
else
{
HTMLSetAttribute
(
font
"
color
"
"
#
aa0000
"
)
;
SetTextContent
(
font
"
\
u00A0
"
+
global
.
FAILED
+
expect
)
;
}
var
b
=
CreateElement
(
"
b
"
)
;
AppendChild
(
b
font
)
;
var
tt
=
CreateElement
(
"
tt
"
)
;
SetTextContent
(
tt
string
)
;
AppendChild
(
tt
b
)
;
AppendChild
(
printOutputContainer
tt
)
;
AppendChild
(
printOutputContainer
CreateElement
(
"
br
"
)
)
;
}
global
.
writeFormattedResult
=
writeFormattedResult
;
}
)
(
this
)
;
var
gPageCompleted
;
var
GLOBAL
=
this
+
'
'
;
var
jstestsTestPassesUnlessItThrows
=
false
;
var
jstestsRestoreFunction
;
var
jstestsOptions
;
function
testPassesUnlessItThrows
(
)
{
jstestsTestPassesUnlessItThrows
=
true
;
}
function
setRestoreFunction
(
restore
)
{
jstestsRestoreFunction
=
restore
;
}
window
.
onerror
=
function
(
msg
page
line
)
{
jstestsTestPassesUnlessItThrows
=
false
;
options
=
jstestsOptions
;
if
(
typeof
jstestsRestoreFunction
=
=
=
"
function
"
)
{
jstestsRestoreFunction
(
)
;
}
optionsPush
(
)
;
if
(
typeof
DESCRIPTION
=
=
'
undefined
'
)
{
DESCRIPTION
=
'
Unknown
'
;
}
if
(
typeof
EXPECTED
=
=
'
undefined
'
)
{
EXPECTED
=
'
Unknown
'
;
}
var
testcase
=
new
TestCase
(
"
unknown
-
test
-
name
"
DESCRIPTION
EXPECTED
"
error
"
)
;
if
(
document
.
location
.
href
.
indexOf
(
'
-
n
.
js
'
)
!
=
-
1
)
{
testcase
.
passed
=
true
;
}
testcase
.
reason
=
page
+
'
:
'
+
line
+
'
:
'
+
msg
;
reportFailure
(
msg
)
;
optionsReset
(
)
;
}
;
function
gc
(
)
{
try
{
SpecialPowers
.
forceGC
(
)
;
}
catch
(
ex
)
{
print
(
'
gc
:
'
+
ex
)
;
}
}
function
options
(
aOptionName
)
{
var
value
=
'
'
;
for
(
var
optionName
in
options
.
currvalues
)
{
value
+
=
optionName
+
'
'
;
}
if
(
value
)
{
value
=
value
.
substring
(
0
value
.
length
-
1
)
;
}
if
(
aOptionName
)
{
if
(
!
(
aOptionName
in
SpecialPowers
.
Cu
)
)
{
throw
"
Unsupported
JSContext
option
'
"
+
aOptionName
+
"
'
"
;
}
if
(
options
.
currvalues
.
hasOwnProperty
(
aOptionName
)
)
delete
options
.
currvalues
[
aOptionName
]
;
else
options
.
currvalues
[
aOptionName
]
=
true
;
SpecialPowers
.
Cu
[
aOptionName
]
=
options
.
currvalues
.
hasOwnProperty
(
aOptionName
)
;
}
return
value
;
}
jstestsOptions
=
options
;
function
optionsInit
(
)
{
options
.
currvalues
=
{
strict
:
true
werror
:
true
strict_mode
:
true
}
;
options
.
initvalues
=
{
}
;
options
.
stackvalues
=
[
]
;
for
(
var
optionName
in
options
.
currvalues
)
{
var
propName
=
optionName
;
if
(
!
(
propName
in
SpecialPowers
.
Cu
)
)
{
throw
"
options
.
currvalues
is
out
of
sync
with
Components
.
utils
"
;
}
if
(
!
SpecialPowers
.
Cu
[
propName
]
)
{
delete
options
.
currvalues
[
optionName
]
;
}
else
{
options
.
initvalues
[
optionName
]
=
true
;
}
}
}
function
jsTestDriverBrowserInit
(
)
{
if
(
typeof
dump
!
=
'
function
'
)
{
dump
=
print
;
}
optionsInit
(
)
;
optionsClear
(
)
;
if
(
document
.
location
.
search
.
indexOf
(
'
?
'
)
!
=
0
)
{
return
;
}
var
properties
=
{
}
;
var
fields
=
document
.
location
.
search
.
slice
(
1
)
.
split
(
'
;
'
)
;
for
(
var
ifield
=
0
;
ifield
<
fields
.
length
;
ifield
+
+
)
{
var
propertycaptures
=
/
^
(
[
^
=
]
+
)
=
(
.
*
)
/
.
exec
(
fields
[
ifield
]
)
;
if
(
!
propertycaptures
)
{
properties
[
fields
[
ifield
]
]
=
true
;
}
else
{
properties
[
propertycaptures
[
1
]
]
=
decodeURIComponent
(
propertycaptures
[
2
]
)
;
if
(
propertycaptures
[
1
]
=
=
'
language
'
)
{
properties
.
mimetype
=
fields
[
ifield
+
1
]
;
}
}
}
if
(
properties
.
language
!
=
'
type
'
)
{
try
{
properties
.
version
=
/
javascript
(
[
.
0
-
9
]
+
)
/
.
exec
(
properties
.
mimetype
)
[
1
]
;
}
catch
(
ex
)
{
}
}
if
(
!
properties
.
version
&
&
navigator
.
userAgent
.
indexOf
(
'
Gecko
/
'
)
!
=
-
1
)
{
if
(
properties
.
test
.
match
(
/
^
js1_6
/
)
)
{
properties
.
version
=
'
1
.
6
'
;
}
else
if
(
properties
.
test
.
match
(
/
^
js1_7
/
)
)
{
properties
.
version
=
'
1
.
7
'
;
}
else
if
(
properties
.
test
.
match
(
/
^
js1_8
/
)
)
{
properties
.
version
=
'
1
.
8
'
;
}
else
if
(
properties
.
test
.
match
(
/
^
ecma_6
\
/
LexicalEnvironment
/
)
)
{
properties
.
version
=
'
1
.
8
'
;
}
else
if
(
properties
.
test
.
match
(
/
^
ecma_6
\
/
Class
/
)
)
{
properties
.
version
=
'
1
.
8
'
;
}
else
if
(
properties
.
test
.
match
(
/
^
ecma_6
\
/
extensions
/
)
)
{
properties
.
version
=
'
1
.
8
'
;
}
}
if
(
!
properties
.
language
)
{
properties
.
language
=
'
type
'
;
properties
.
mimetype
=
'
text
/
javascript
'
;
}
gTestPath
=
properties
.
test
;
if
(
properties
.
gczeal
)
{
gczeal
(
Number
(
properties
.
gczeal
)
)
;
}
var
testpathparts
=
properties
.
test
.
split
(
/
\
/
/
)
;
if
(
testpathparts
.
length
<
2
)
{
return
;
}
document
.
write
(
'
<
title
>
'
+
properties
.
test
+
'
<
\
/
title
>
'
)
;
document
.
write
(
'
<
script
>
<
/
script
>
'
)
;
var
prepath
=
"
"
;
var
i
=
0
;
for
(
end
=
testpathparts
.
length
-
1
;
i
<
end
;
i
+
+
)
{
prepath
+
=
testpathparts
[
i
]
+
"
/
"
;
outputscripttag
(
prepath
+
"
shell
.
js
"
properties
)
;
outputscripttag
(
prepath
+
"
browser
.
js
"
properties
)
;
}
outputscripttag
(
prepath
+
testpathparts
[
i
]
properties
)
;
outputscripttag
(
'
js
-
test
-
driver
-
end
.
js
'
properties
)
;
return
;
}
function
outputscripttag
(
src
properties
)
{
if
(
!
src
)
{
return
;
}
var
s
=
'
<
script
src
=
"
'
+
src
+
'
"
charset
=
"
utf
-
8
"
'
;
if
(
properties
.
language
!
=
'
type
'
)
{
s
+
=
'
language
=
"
javascript
'
;
if
(
properties
.
version
)
{
s
+
=
properties
.
version
;
}
}
else
{
s
+
=
'
type
=
"
'
+
properties
.
mimetype
;
if
(
properties
.
version
)
{
s
+
=
'
;
version
=
'
+
properties
.
version
;
}
}
s
+
=
'
"
>
<
\
/
script
>
'
;
document
.
write
(
s
)
;
}
function
jsTestDriverEnd
(
)
{
if
(
gDelayTestDriverEnd
)
{
return
;
}
window
.
onerror
=
null
;
options
=
jstestsOptions
;
if
(
typeof
jstestsRestoreFunction
=
=
=
"
function
"
)
{
jstestsRestoreFunction
(
)
;
}
if
(
jstestsTestPassesUnlessItThrows
)
{
var
testcase
=
new
TestCase
(
"
unknown
-
test
-
name
"
"
"
true
true
)
;
print
(
PASSED
)
;
jstestsTestPassesUnlessItThrows
=
false
;
}
try
{
optionsReset
(
)
;
}
catch
(
ex
)
{
dump
(
'
jsTestDriverEnd
'
+
ex
)
;
}
if
(
window
.
opener
&
&
window
.
opener
.
runNextTest
)
{
if
(
window
.
opener
.
reportCallBack
)
{
window
.
opener
.
reportCallBack
(
window
.
opener
.
gWindow
)
;
}
setTimeout
(
'
window
.
opener
.
runNextTest
(
)
'
250
)
;
}
else
{
for
(
var
i
=
0
;
i
<
gTestcases
.
length
;
i
+
+
)
{
gTestcases
[
i
]
.
dump
(
)
;
}
document
.
documentElement
.
className
=
'
'
;
gPageCompleted
=
true
;
}
}
var
dlog
=
(
function
(
s
)
{
}
)
;
var
gDialogCloser
;
var
gDialogCloserObserver
;
function
registerDialogCloser
(
)
{
gDialogCloser
=
SpecialPowers
.
Cc
[
'
mozilla
.
org
/
embedcomp
/
window
-
watcher
;
1
'
]
.
getService
(
SpecialPowers
.
Ci
.
nsIWindowWatcher
)
;
gDialogCloserObserver
=
{
observe
:
dialogCloser_observe
}
;
gDialogCloser
.
registerNotification
(
gDialogCloserObserver
)
;
}
function
unregisterDialogCloser
(
)
{
gczeal
(
0
)
;
if
(
!
gDialogCloserObserver
|
|
!
gDialogCloser
)
{
return
;
}
gDialogCloser
.
unregisterNotification
(
gDialogCloserObserver
)
;
gDialogCloserObserver
=
null
;
gDialogCloser
=
null
;
}
var
gDialogCloserSubjects
=
[
]
;
function
dialogCloser_observe
(
subject
topic
data
)
{
if
(
subject
instanceof
ChromeWindow
&
&
topic
=
=
'
domwindowopened
'
)
{
gDialogCloserSubjects
.
push
(
subject
)
;
subject
.
setTimeout
(
closeDialog
0
)
;
}
}
function
closeDialog
(
)
{
var
subject
;
while
(
(
subject
=
gDialogCloserSubjects
.
pop
(
)
)
!
=
null
)
{
if
(
subject
.
document
instanceof
XULDocument
&
&
subject
.
document
.
documentURI
=
=
'
chrome
:
/
/
global
/
content
/
commonDialog
.
xul
'
)
{
subject
.
close
(
)
;
}
else
{
subject
.
close
(
)
;
}
}
}
registerDialogCloser
(
)
;
window
.
addEventListener
(
'
unload
'
unregisterDialogCloser
true
)
;
jsTestDriverBrowserInit
(
)
;
