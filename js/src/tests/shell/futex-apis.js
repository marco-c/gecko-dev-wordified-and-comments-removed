if
(
!
(
this
.
SharedArrayBuffer
&
&
this
.
Atomics
)
)
{
reportCompare
(
true
true
)
;
quit
(
0
)
;
}
let
ab
=
new
ArrayBuffer
(
16
)
;
let
sab
=
new
SharedArrayBuffer
(
16
)
;
{
let
values
=
[
null
undefined
true
false
new
Boolean
(
true
)
10
3
.
14
new
Number
(
4
)
"
Hi
there
"
new
Date
/
a
*
utomaton
/
g
{
password
:
"
qumquat
"
}
new
DataView
(
new
ArrayBuffer
(
10
)
)
new
ArrayBuffer
(
128
)
new
SharedArrayBuffer
(
128
)
new
Error
(
"
Ouch
"
)
[
1
1
2
3
5
8
]
(
(
x
)
=
>
-
x
)
new
Map
(
)
new
Set
(
)
new
WeakMap
(
)
new
WeakSet
(
)
this
.
Promise
?
new
Promise
(
(
)
=
>
"
done
"
)
:
null
Symbol
(
"
halleluja
"
)
Object
Int32Array
Date
Math
Atomics
]
;
for
(
let
i
=
0
;
i
<
values
.
length
;
i
+
+
)
{
let
view
=
values
[
i
]
;
assertThrowsInstanceOf
(
(
)
=
>
Atomics
.
wait
(
view
0
0
)
TypeError
)
;
assertThrowsInstanceOf
(
(
)
=
>
Atomics
.
wake
(
view
0
)
TypeError
)
;
}
}
{
let
views
=
[
Int8Array
Uint8Array
Int16Array
Uint16Array
Int32Array
Uint32Array
]
;
for
(
let
View
of
views
)
{
let
view
=
new
View
(
ab
)
;
assertThrowsInstanceOf
(
(
)
=
>
Atomics
.
wait
(
view
0
0
)
TypeError
)
;
assertThrowsInstanceOf
(
(
)
=
>
Atomics
.
wake
(
view
0
)
TypeError
)
;
}
}
{
let
views
=
[
Int8Array
Uint8Array
Int16Array
Uint16Array
Uint32Array
Uint8ClampedArray
Float32Array
Float64Array
]
;
for
(
let
View
of
views
)
{
let
view
=
new
View
(
sab
)
;
assertThrowsInstanceOf
(
(
)
=
>
Atomics
.
wait
(
view
0
0
)
TypeError
)
;
assertThrowsInstanceOf
(
(
)
=
>
Atomics
.
wake
(
view
0
)
TypeError
)
;
}
}
{
let
view
=
new
Int32Array
(
sab
)
;
let
indices
=
[
(
view
)
=
>
-
1
(
view
)
=
>
view
.
length
(
view
)
=
>
view
.
length
*
2
(
view
)
=
>
'
-
3
.
5
'
(
view
)
=
>
(
{
valueOf
:
(
)
=
>
-
8
}
)
]
;
for
(
let
iidx
=
0
;
iidx
<
indices
.
length
;
iidx
+
+
)
{
let
Idx
=
indices
[
iidx
]
(
view
)
;
assertThrowsInstanceOf
(
(
)
=
>
Atomics
.
wait
(
view
Idx
10
)
RangeError
)
;
assertThrowsInstanceOf
(
(
)
=
>
Atomics
.
wake
(
view
Idx
)
RangeError
)
;
}
}
reportCompare
(
true
true
)
;
