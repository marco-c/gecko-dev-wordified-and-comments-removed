const
SEED
=
(
Math
.
random
(
)
*
10
)
+
1
;
function
genRandomArrayBuffer
(
size
width
seed
)
{
let
buf
=
new
ArrayBuffer
(
(
width
/
8
)
*
size
)
;
let
arr
=
new
Uint8Array
(
buf
)
;
let
len
=
0
;
for
(
let
n
of
XorShiftGenerator
(
seed
buf
.
byteLength
)
)
arr
[
len
+
+
]
=
n
;
return
buf
;
}
function
lte
(
a
b
)
{
if
(
isNaN
(
b
)
)
return
true
;
return
a
<
=
b
;
}
function
gte
(
a
b
)
{
return
lte
(
b
a
)
;
}
function
cmp
(
a
b
)
{
return
lte
(
a
b
)
?
gte
(
a
b
)
?
0
:
-
1
:
1
;
}
function
SortTest
(
dataType
dataSource
)
{
let
typedArray
=
new
dataType
(
dataSource
)
;
let
originalValues
=
Array
.
from
(
typedArray
)
;
typedArray
.
sort
(
)
;
assertDeepEq
(
Array
.
from
(
typedArray
)
Array
.
from
(
originalValues
)
.
sort
(
cmp
)
The
array
is
not
properly
sorted
!
seed
:
{
SEED
}
)
;
for
(
let
i
=
0
;
i
<
typedArray
.
length
-
1
;
i
+
+
)
assertEq
(
lte
(
typedArray
[
i
]
typedArray
[
i
+
1
]
)
true
The
array
is
not
properly
sorted
!
{
typedArray
[
i
]
}
>
{
typedArray
[
i
+
1
]
}
seed
:
{
SEED
}
)
typedArray
.
sort
(
(
x
y
)
=
>
cmp
(
y
x
)
)
;
for
(
let
i
=
typedArray
.
length
-
2
;
i
>
=
0
;
i
-
-
)
assertEq
(
gte
(
typedArray
[
i
]
typedArray
[
i
+
1
]
)
true
The
array
is
not
properly
sorted
!
{
typedArray
[
i
]
}
<
{
typedArray
[
i
+
1
]
}
seed
:
{
SEED
}
)
}
for
(
let
constructor
of
anyTypedArrayConstructors
)
{
for
(
let
arrayLength
of
[
256
16
0
]
)
{
let
source
=
genRandomArrayBuffer
(
arrayLength
constructor
.
BYTES_PER_ELEMENT
*
8
SEED
)
;
SortTest
(
constructor
source
)
;
}
}
if
(
typeof
reportCompare
=
=
=
"
function
"
)
reportCompare
(
true
true
)
;
