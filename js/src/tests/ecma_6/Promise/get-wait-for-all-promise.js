if
(
!
this
.
Promise
)
{
this
.
reportCompare
&
&
reportCompare
(
true
true
)
;
quit
(
0
)
;
}
let
GetWaitForAllPromise
=
getSelfHostedValue
(
'
GetWaitForAllPromise
'
)
;
function
onResolved
(
val
)
{
result
=
'
resolved
with
'
+
val
;
}
function
onRejected
(
val
)
{
result
=
'
rejected
with
'
+
val
;
}
let
originalThen
=
Promise
.
prototype
.
then
;
Promise
.
prototype
.
then
=
1
;
Promise
[
Symbol
.
species
]
=
function
(
)
{
}
;
let
PromiseCtor
=
Promise
;
Promise
=
{
}
;
Array
.
prototype
[
Symbol
.
iterator
]
=
function
(
)
{
}
;
let
resolveFunctions
=
[
]
;
let
rejectFunctions
=
[
]
;
let
promises
=
[
]
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
let
p
=
new
PromiseCtor
(
function
(
res_
rej_
)
{
resolveFunctions
.
push
(
res_
)
;
rejectFunctions
.
push
(
rej_
)
;
}
)
;
promises
.
push
(
p
)
;
}
let
allPromise
=
GetWaitForAllPromise
(
promises
)
;
let
then
=
originalThen
.
call
(
allPromise
onResolved
onRejected
)
;
resolveFunctions
.
forEach
(
(
fun
i
)
=
>
fun
(
i
)
)
;
drainJobQueue
(
)
;
assertEq
(
result
'
resolved
with
0
1
2
'
)
;
result
=
undefined
;
originalThen
.
call
(
GetWaitForAllPromise
(
[
]
)
v
=
>
(
result
=
v
)
)
;
drainJobQueue
(
)
;
assertEq
(
result
instanceof
Array
true
)
;
assertEq
(
result
.
length
0
)
;
result
=
undefined
;
originalThen
.
call
(
GetWaitForAllPromise
(
[
]
)
v
=
>
(
result
=
v
)
)
;
drainJobQueue
(
)
;
assertEq
(
result
instanceof
Array
true
)
;
assertEq
(
result
.
length
0
)
;
this
.
reportCompare
&
&
reportCompare
(
true
true
)
;
