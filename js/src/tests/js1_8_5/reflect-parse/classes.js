function
testClasses
(
)
{
function
methodFun
(
id
kind
generator
args
body
=
[
]
)
{
assertEq
(
generator
&
&
kind
=
=
=
"
method
"
generator
)
;
assertEq
(
typeof
id
=
=
=
'
string
'
|
|
id
=
=
=
null
true
)
;
let
methodName
;
switch
(
kind
)
{
case
"
method
"
:
methodName
=
typeof
id
=
=
=
'
string
'
?
ident
(
id
)
:
null
;
break
;
case
"
get
"
:
case
"
set
"
:
methodName
=
ident
(
{
kind
}
{
typeof
id
=
=
=
'
string
'
?
id
:
"
"
}
)
;
break
;
default
:
methodName
=
null
;
break
;
}
return
generator
?
genFunExpr
(
"
es6
"
methodName
args
.
map
(
ident
)
blockStmt
(
body
)
)
:
funExpr
(
methodName
args
.
map
(
ident
)
blockStmt
(
body
)
)
;
}
function
simpleMethod
(
id
kind
generator
args
=
[
]
isStatic
=
false
)
{
return
classMethod
(
ident
(
id
)
methodFun
(
id
kind
generator
args
)
kind
isStatic
)
;
}
function
ctorWithName
(
id
body
=
[
]
)
{
return
classMethod
(
ident
(
"
constructor
"
)
methodFun
(
id
"
method
"
false
[
]
body
)
"
method
"
false
)
;
}
function
emptyCPNMethod
(
id
isStatic
)
{
return
classMethod
(
computedName
(
lit
(
id
)
)
funExpr
(
null
[
]
blockStmt
(
[
]
)
)
"
method
"
isStatic
)
;
}
function
assertClassExpr
(
str
methods
heritage
=
null
name
=
null
)
{
let
template
=
classExpr
(
name
heritage
methods
)
;
assertExpr
(
"
(
"
+
str
+
"
)
"
template
)
;
}
let
ctorPlaceholder
=
{
}
;
function
assertClass
(
str
methods
heritage
=
null
constructorBody
=
[
]
)
{
let
namelessStr
=
str
.
replace
(
"
NAME
"
"
"
)
;
let
namedStr
=
str
.
replace
(
"
NAME
"
"
Foo
"
)
;
let
namedCtor
=
ctorWithName
(
"
Foo
"
constructorBody
)
;
let
namelessCtor
=
ctorWithName
(
null
constructorBody
)
;
let
namelessMethods
=
methods
.
map
(
x
=
>
x
=
=
ctorPlaceholder
?
namelessCtor
:
x
)
;
let
namedMethods
=
methods
.
map
(
x
=
>
x
=
=
ctorPlaceholder
?
namedCtor
:
x
)
;
assertClassExpr
(
namelessStr
namelessMethods
heritage
)
;
assertClassExpr
(
namedStr
namedMethods
heritage
ident
(
"
Foo
"
)
)
;
let
template
=
classStmt
(
ident
(
"
Foo
"
)
heritage
namedMethods
)
;
assertStmt
(
namedStr
template
)
;
}
function
assertNamedClassError
(
str
error
)
{
assertError
(
str
error
)
;
assertError
(
"
(
"
+
str
+
"
)
"
error
)
;
}
function
assertClassError
(
str
error
)
{
assertNamedClassError
(
str
error
)
;
assertError
(
"
(
"
+
str
.
replace
(
"
NAME
"
"
"
)
+
"
)
"
error
)
;
}
assertError
(
"
class
{
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertClass
(
"
class
NAME
{
constructor
(
)
{
}
}
"
[
ctorPlaceholder
]
)
;
assertNamedClassError
(
"
class
x
.
y
{
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertNamedClassError
(
"
class
[
]
{
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertNamedClassError
(
"
class
{
x
}
{
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertNamedClassError
(
"
class
for
{
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertClass
(
"
class
NAME
{
constructor
(
)
{
}
method
(
)
{
}
}
"
[
ctorPlaceholder
simpleMethod
(
"
method
"
"
method
"
false
)
]
)
;
assertClass
(
"
class
NAME
{
constructor
(
)
{
}
get
method
(
)
{
}
}
"
[
ctorPlaceholder
simpleMethod
(
"
method
"
"
get
"
false
)
]
)
;
assertClass
(
"
class
NAME
{
constructor
(
)
{
}
set
method
(
x
)
{
}
}
"
[
ctorPlaceholder
simpleMethod
(
"
method
"
"
set
"
false
[
"
x
"
]
)
]
)
;
assertClass
(
class
NAME
{
constructor
(
)
{
}
;
static
method
(
)
{
}
;
static
*
methodGen
(
)
{
}
;
static
get
getter
(
)
{
}
;
static
set
setter
(
x
)
{
}
}
[
ctorPlaceholder
simpleMethod
(
"
method
"
"
method
"
false
[
]
true
)
simpleMethod
(
"
methodGen
"
"
method
"
true
[
]
true
)
simpleMethod
(
"
getter
"
"
get
"
false
[
]
true
)
simpleMethod
(
"
setter
"
"
set
"
false
[
"
x
"
]
true
)
]
)
;
assertClass
(
"
class
NAME
{
constructor
(
)
{
}
static
(
)
{
}
}
"
[
ctorPlaceholder
simpleMethod
(
"
static
"
"
method
"
false
)
]
)
;
assertClass
(
"
class
NAME
{
static
static
(
)
{
}
;
constructor
(
)
{
}
}
"
[
simpleMethod
(
"
static
"
"
method
"
false
[
]
true
)
ctorPlaceholder
]
)
;
assertClass
(
"
class
NAME
{
static
get
static
(
)
{
}
;
constructor
(
)
{
}
}
"
[
simpleMethod
(
"
static
"
"
get
"
false
[
]
true
)
ctorPlaceholder
]
)
;
assertClass
(
"
class
NAME
{
constructor
(
)
{
}
;
static
set
static
(
x
)
{
}
}
"
[
ctorPlaceholder
simpleMethod
(
"
static
"
"
set
"
false
[
"
x
"
]
true
)
]
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
}
;
get
static
foo
(
)
{
}
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
}
static
prototype
(
)
{
}
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
}
static
*
prototype
(
)
{
}
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
static
get
prototype
(
)
{
}
;
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
static
set
prototype
(
x
)
{
}
;
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertClass
(
"
class
NAME
{
constructor
(
)
{
}
;
static
[
\
"
prototype
\
"
]
(
)
{
}
}
"
[
ctorPlaceholder
emptyCPNMethod
(
"
prototype
"
true
)
]
)
;
assertClass
(
"
class
NAME
{
}
"
[
]
)
;
assertClass
(
"
class
NAME
extends
null
{
}
"
[
]
lit
(
null
)
)
;
assertClassError
(
"
class
NAME
extends
null
{
constructor
(
)
1
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
}
constructor
(
a
)
{
}
}
"
SyntaxError
)
;
let
methods
=
[
[
"
method
(
)
{
}
"
simpleMethod
(
"
method
"
"
method
"
false
)
]
[
"
*
method
(
)
{
}
"
simpleMethod
(
"
method
"
"
method
"
true
)
]
[
"
get
method
(
)
{
}
"
simpleMethod
(
"
method
"
"
get
"
false
)
]
[
"
set
method
(
x
)
{
}
"
simpleMethod
(
"
method
"
"
set
"
false
[
"
x
"
]
)
]
[
"
static
method
(
)
{
}
"
simpleMethod
(
"
method
"
"
method
"
false
[
]
true
)
]
[
"
static
*
method
(
)
{
}
"
simpleMethod
(
"
method
"
"
method
"
true
[
]
true
)
]
[
"
static
get
method
(
)
{
}
"
simpleMethod
(
"
method
"
"
get
"
false
[
]
true
)
]
[
"
static
set
method
(
x
)
{
}
"
simpleMethod
(
"
method
"
"
set
"
false
[
"
x
"
]
true
)
]
]
;
let
i
j
;
for
(
i
=
0
;
i
<
methods
.
length
;
i
+
+
)
{
for
(
j
=
0
;
j
<
methods
.
length
;
j
+
+
)
{
let
str
=
"
class
NAME
{
constructor
(
)
{
}
"
+
methods
[
i
]
[
0
]
+
"
"
+
methods
[
j
]
[
0
]
+
"
}
"
;
assertClass
(
str
[
ctorPlaceholder
methods
[
i
]
[
1
]
methods
[
j
]
[
1
]
]
)
;
}
}
assertClass
(
"
class
NAME
{
constructor
(
)
{
}
[
\
"
constructor
\
"
]
(
)
{
}
}
"
[
ctorPlaceholder
emptyCPNMethod
(
"
constructor
"
false
)
]
)
;
assertClassError
(
"
class
NAME
{
*
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
get
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
set
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertClass
(
"
class
NAME
{
constructor
(
)
{
}
;
}
"
[
ctorPlaceholder
]
)
;
assertClass
(
"
class
NAME
{
;
;
;
constructor
(
)
{
}
}
"
[
ctorPlaceholder
]
)
;
assertClass
(
"
class
NAME
{
method
(
)
{
}
constructor
(
)
{
}
}
"
[
simpleMethod
(
"
method
"
"
method
"
false
)
ctorPlaceholder
]
)
;
assertError
(
function
*
foo
(
)
{
class
yield
{
constructor
(
)
{
}
}
}
SyntaxError
)
;
assertError
(
function
*
foo
(
)
{
(
class
yield
{
constructor
(
)
{
}
}
)
}
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
}
*
get
foo
(
)
{
}
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
}
*
set
foo
(
)
{
}
}
"
SyntaxError
)
;
assertClass
(
"
class
NAME
{
*
method
(
)
{
}
constructor
(
)
{
}
}
"
[
simpleMethod
(
"
method
"
"
method
"
true
)
ctorPlaceholder
]
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
var
yield
;
}
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
}
[
delete
bar
]
(
)
{
}
}
"
SyntaxError
)
;
let
FooCtor
=
ctorWithName
(
"
Foo
"
)
;
assertError
(
"
{
let
Foo
;
class
Foo
{
constructor
(
)
{
}
}
}
"
SyntaxError
)
;
assertStmt
(
"
{
let
Foo
;
(
class
Foo
{
constructor
(
)
{
}
}
)
}
"
blockStmt
(
[
letDecl
(
[
{
id
:
ident
(
"
Foo
"
)
init
:
null
}
]
)
exprStmt
(
classExpr
(
ident
(
"
Foo
"
)
null
[
FooCtor
]
)
)
]
)
)
;
assertError
(
"
{
const
Foo
=
0
;
class
Foo
{
constructor
(
)
{
}
}
}
"
SyntaxError
)
;
assertStmt
(
"
{
const
Foo
=
0
;
(
class
Foo
{
constructor
(
)
{
}
}
)
}
"
blockStmt
(
[
constDecl
(
[
{
id
:
ident
(
"
Foo
"
)
init
:
lit
(
0
)
}
]
)
exprStmt
(
classExpr
(
ident
(
"
Foo
"
)
null
[
FooCtor
]
)
)
]
)
)
;
assertError
(
"
{
class
Foo
{
constructor
(
)
{
}
}
class
Foo
{
constructor
(
)
{
}
}
}
"
SyntaxError
)
;
assertStmt
(
{
(
class
Foo
{
constructor
(
)
{
}
}
class
Foo
{
constructor
(
)
{
}
}
)
;
}
blockStmt
(
[
exprStmt
(
seqExpr
(
[
classExpr
(
ident
(
"
Foo
"
)
null
[
FooCtor
]
)
classExpr
(
ident
(
"
Foo
"
)
null
[
FooCtor
]
)
]
)
)
]
)
)
;
assertStmt
(
{
var
x
=
class
Foo
{
constructor
(
)
{
}
}
;
class
Foo
{
constructor
(
)
{
}
}
}
blockStmt
(
[
varDecl
(
[
{
id
:
ident
(
"
x
"
)
init
:
classExpr
(
ident
(
"
Foo
"
)
null
[
FooCtor
]
)
}
]
)
classStmt
(
ident
(
"
Foo
"
)
null
[
FooCtor
]
)
]
)
)
;
assertError
(
"
if
(
1
)
class
Foo
{
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
extends
null
undefined
{
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
extends
(
delete
x
)
{
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
extends
{
constructor
(
)
{
}
}
"
SyntaxError
)
;
assertClass
(
"
class
NAME
{
constructor
(
)
{
}
;
extends
(
)
{
}
}
"
[
ctorPlaceholder
simpleMethod
(
"
extends
"
"
method
"
false
)
]
)
;
assertClass
(
"
class
NAME
extends
null
{
constructor
(
)
{
}
}
"
[
ctorPlaceholder
]
lit
(
null
)
)
;
assertClass
(
"
class
NAME
extends
(
undefined
undefined
)
{
constructor
(
)
{
}
}
"
[
ctorPlaceholder
]
seqExpr
(
[
ident
(
"
undefined
"
)
ident
(
"
undefined
"
)
]
)
)
;
let
emptyFunction
=
funExpr
(
null
[
]
blockStmt
(
[
]
)
)
;
assertClass
(
"
class
NAME
extends
function
(
)
{
}
{
constructor
(
)
{
}
}
"
[
ctorPlaceholder
]
emptyFunction
)
;
assertClass
(
"
class
NAME
extends
new
function
(
)
{
}
(
)
{
constructor
(
)
{
}
}
"
[
ctorPlaceholder
]
newExpr
(
emptyFunction
[
]
)
)
;
assertClass
(
"
class
NAME
extends
function
(
)
{
}
(
)
{
constructor
(
)
{
}
}
"
[
ctorPlaceholder
]
callExpr
(
emptyFunction
[
]
)
)
;
assertClass
(
"
class
NAME
extends
{
}
.
foo
{
constructor
(
)
{
}
}
"
[
ctorPlaceholder
]
dotExpr
(
objExpr
(
[
]
)
ident
(
"
foo
"
)
)
)
;
assertClass
(
"
class
NAME
extends
{
}
[
foo
]
{
constructor
(
)
{
}
}
"
[
ctorPlaceholder
]
memExpr
(
objExpr
(
[
]
)
ident
(
"
foo
"
)
)
)
;
function
assertValidSuperProps
(
assertion
makeStr
makeExpr
type
generator
args
static
extending
)
{
let
superProperty
=
superProp
(
ident
(
"
prop
"
)
)
;
let
superMember
=
superElem
(
lit
(
"
prop
"
)
)
;
let
situations
=
[
[
"
super
.
prop
"
superProperty
]
[
"
super
[
'
prop
'
]
"
superMember
]
[
"
super
.
prop
(
)
"
callExpr
(
superProperty
[
]
)
]
[
"
super
[
'
prop
'
]
(
)
"
callExpr
(
superMember
[
]
)
]
[
"
new
super
.
prop
(
)
"
newExpr
(
superProperty
[
]
)
]
[
"
new
super
[
'
prop
'
]
(
)
"
newExpr
(
superMember
[
]
)
]
[
"
delete
super
.
prop
"
unExpr
(
"
delete
"
superProperty
)
]
[
"
delete
super
[
'
prop
'
]
"
unExpr
(
"
delete
"
superMember
)
]
[
"
+
+
super
.
prop
"
updExpr
(
"
+
+
"
superProperty
true
)
]
[
"
super
[
'
prop
'
]
-
-
"
updExpr
(
"
-
-
"
superMember
false
)
]
[
"
super
.
prop
=
4
"
aExpr
(
"
=
"
superProperty
lit
(
4
)
)
]
[
"
super
[
'
prop
'
]
=
4
"
aExpr
(
"
=
"
superMember
lit
(
4
)
)
]
[
"
super
.
prop
+
=
4
"
aExpr
(
"
+
=
"
superProperty
lit
(
4
)
)
]
[
"
super
[
'
prop
'
]
+
=
4
"
aExpr
(
"
+
=
"
superMember
lit
(
4
)
)
]
[
"
super
.
prop
-
=
4
"
aExpr
(
"
-
=
"
superProperty
lit
(
4
)
)
]
[
"
super
[
'
prop
'
]
-
=
4
"
aExpr
(
"
-
=
"
superMember
lit
(
4
)
)
]
[
"
super
.
prop
*
=
4
"
aExpr
(
"
*
=
"
superProperty
lit
(
4
)
)
]
[
"
super
[
'
prop
'
]
*
=
4
"
aExpr
(
"
*
=
"
superMember
lit
(
4
)
)
]
[
"
super
.
prop
/
=
4
"
aExpr
(
"
/
=
"
superProperty
lit
(
4
)
)
]
[
"
super
[
'
prop
'
]
/
=
4
"
aExpr
(
"
/
=
"
superMember
lit
(
4
)
)
]
[
"
super
.
prop
%
=
4
"
aExpr
(
"
%
=
"
superProperty
lit
(
4
)
)
]
[
"
super
[
'
prop
'
]
%
=
4
"
aExpr
(
"
%
=
"
superMember
lit
(
4
)
)
]
[
"
super
.
prop
<
<
=
4
"
aExpr
(
"
<
<
=
"
superProperty
lit
(
4
)
)
]
[
"
super
[
'
prop
'
]
<
<
=
4
"
aExpr
(
"
<
<
=
"
superMember
lit
(
4
)
)
]
[
"
super
.
prop
>
>
=
4
"
aExpr
(
"
>
>
=
"
superProperty
lit
(
4
)
)
]
[
"
super
[
'
prop
'
]
>
>
=
4
"
aExpr
(
"
>
>
=
"
superMember
lit
(
4
)
)
]
[
"
super
.
prop
>
>
>
=
4
"
aExpr
(
"
>
>
>
=
"
superProperty
lit
(
4
)
)
]
[
"
super
[
'
prop
'
]
>
>
>
=
4
"
aExpr
(
"
>
>
>
=
"
superMember
lit
(
4
)
)
]
[
"
super
.
prop
|
=
4
"
aExpr
(
"
|
=
"
superProperty
lit
(
4
)
)
]
[
"
super
[
'
prop
'
]
|
=
4
"
aExpr
(
"
|
=
"
superMember
lit
(
4
)
)
]
[
"
super
.
prop
^
=
4
"
aExpr
(
"
^
=
"
superProperty
lit
(
4
)
)
]
[
"
super
[
'
prop
'
]
^
=
4
"
aExpr
(
"
^
=
"
superMember
lit
(
4
)
)
]
[
"
super
.
prop
&
=
4
"
aExpr
(
"
&
=
"
superProperty
lit
(
4
)
)
]
[
"
super
[
'
prop
'
]
&
=
4
"
aExpr
(
"
&
=
"
superMember
lit
(
4
)
)
]
[
"
(
)
=
>
super
.
prop
"
arrowExpr
(
[
]
superProperty
)
]
[
"
(
)
=
>
super
[
'
prop
'
]
"
arrowExpr
(
[
]
superMember
)
]
]
;
for
(
let
situation
of
situations
)
{
let
sitStr
=
situation
[
0
]
;
let
sitExpr
=
situation
[
1
]
;
let
fun
=
methodFun
(
"
method
"
type
generator
args
[
exprStmt
(
sitExpr
)
]
)
;
let
str
=
makeStr
(
sitStr
type
generator
args
static
extending
)
;
assertion
(
str
makeExpr
(
fun
type
static
)
extending
)
;
}
}
function
assertValidSuperPropTypes
(
assertion
makeStr
makeExpr
static
extending
)
{
for
(
let
type
of
[
"
method
"
"
get
"
"
set
"
]
)
{
if
(
type
=
=
=
"
method
"
)
{
assertValidSuperProps
(
assertion
makeStr
makeExpr
type
true
[
]
static
extending
)
;
assertValidSuperProps
(
assertion
makeStr
makeExpr
type
false
[
]
static
extending
)
;
continue
;
}
assertValidSuperProps
(
assertion
makeStr
makeExpr
type
false
type
=
=
=
"
set
"
?
[
"
x
"
]
:
[
]
static
extending
)
;
}
}
function
makeSuperPropMethodStr
(
propStr
type
generator
args
)
{
return
{
type
=
=
=
"
method
"
?
"
"
:
type
}
{
generator
?
"
*
"
:
"
"
}
method
(
{
args
.
join
(
"
"
)
}
)
{
{
propStr
}
;
}
;
}
function
makeClassSuperPropStr
(
propStr
type
generator
args
static
extending
)
{
return
class
NAME
{
extending
?
"
extends
null
"
:
"
"
}
{
constructor
(
)
{
}
;
{
static
?
"
static
"
:
"
"
}
{
makeSuperPropMethodStr
(
propStr
type
generator
args
)
}
}
;
}
function
makeClassSuperPropExpr
(
fun
type
static
)
{
return
[
ctorPlaceholder
classMethod
(
ident
(
"
method
"
)
fun
type
static
)
]
;
}
function
doClassSuperPropAssert
(
str
expr
extending
)
{
assertClass
(
str
expr
extending
?
lit
(
null
)
:
null
)
;
}
function
assertValidClassSuperPropExtends
(
extending
)
{
assertValidSuperPropTypes
(
doClassSuperPropAssert
makeClassSuperPropStr
makeClassSuperPropExpr
false
extending
)
;
assertValidSuperPropTypes
(
doClassSuperPropAssert
makeClassSuperPropStr
makeClassSuperPropExpr
true
extending
)
;
}
function
assertValidClassSuperProps
(
)
{
assertValidClassSuperPropExtends
(
false
)
;
assertValidClassSuperPropExtends
(
true
)
;
}
function
makeOLSuperPropStr
(
propStr
type
generator
args
)
{
let
str
=
(
{
{
makeSuperPropMethodStr
(
propStr
type
generator
args
)
}
}
)
;
return
str
;
}
function
makeOLSuperPropExpr
(
fun
)
{
return
objExpr
(
[
{
type
:
"
Property
"
key
:
ident
(
"
method
"
)
value
:
fun
}
]
)
;
}
function
assertValidOLSuperProps
(
)
{
assertValidSuperPropTypes
(
assertExpr
makeOLSuperPropStr
makeOLSuperPropExpr
)
;
}
assertValidClassSuperProps
(
)
;
assertValidOLSuperProps
(
)
;
assertError
(
"
function
foo
(
)
{
super
.
prop
;
}
"
SyntaxError
)
;
assertError
(
"
(
function
(
)
{
super
.
prop
;
}
"
SyntaxError
)
;
assertError
(
"
(
(
)
=
>
super
.
prop
)
"
SyntaxError
)
;
assertError
(
"
function
*
foo
(
)
{
super
.
prop
;
}
"
SyntaxError
)
;
assertError
(
"
super
.
prop
"
SyntaxError
)
;
assertError
(
"
function
foo
(
)
{
super
[
'
prop
'
]
;
}
"
SyntaxError
)
;
assertError
(
"
(
function
(
)
{
super
[
'
prop
'
]
;
}
"
SyntaxError
)
;
assertError
(
"
(
(
)
=
>
super
[
'
prop
'
]
)
"
SyntaxError
)
;
assertError
(
"
function
*
foo
(
)
{
super
[
'
prop
'
]
;
}
"
SyntaxError
)
;
assertError
(
"
super
[
'
prop
'
]
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
function
nested
(
)
{
super
.
prop
;
}
}
}
"
SyntaxError
)
;
assertError
(
"
super
"
SyntaxError
)
;
assertError
(
"
{
foo
(
)
{
super
}
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
super
;
}
}
"
SyntaxError
)
;
assertError
(
"
super
(
)
"
SyntaxError
)
;
assertError
(
"
(
function
(
)
{
super
(
)
;
}
)
"
SyntaxError
)
;
assertError
(
"
(
super
(
)
for
(
x
in
y
)
)
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
(
super
(
)
for
(
x
in
y
)
)
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
super
(
)
;
}
}
"
SyntaxError
)
;
function
superConstructor
(
args
)
{
return
classMethod
(
ident
(
"
constructor
"
)
methodFun
(
"
NAME
"
"
method
"
false
[
]
[
exprStmt
(
superCallExpr
(
args
)
)
]
)
"
method
"
false
)
;
}
function
superCallBody
(
args
)
{
return
[
exprStmt
(
superCallExpr
(
args
)
)
]
;
}
assertClass
(
"
class
NAME
extends
null
{
constructor
(
)
{
super
(
)
}
}
"
[
ctorPlaceholder
]
lit
(
null
)
superCallBody
(
[
]
)
)
;
assertClass
(
"
class
NAME
extends
null
{
constructor
(
)
{
super
(
1
)
}
}
"
[
ctorPlaceholder
]
lit
(
null
)
superCallBody
(
[
lit
(
1
)
]
)
)
;
assertClass
(
"
class
NAME
extends
null
{
constructor
(
)
{
super
(
1
a
)
}
}
"
[
ctorPlaceholder
]
lit
(
null
)
superCallBody
(
[
lit
(
1
)
ident
(
"
a
"
)
]
)
)
;
assertClass
(
"
class
NAME
extends
null
{
constructor
(
)
{
super
(
.
.
.
[
]
)
}
}
"
[
ctorPlaceholder
]
lit
(
null
)
superCallBody
(
[
spread
(
arrExpr
(
[
]
)
)
]
)
)
;
assertClassError
(
"
class
NAME
{
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
;
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
static
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
static
y
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
static
*
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
static
*
y
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
static
get
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
static
get
y
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
static
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
static
;
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
extends
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
super
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
super
.
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
super
.
x
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
super
.
m
(
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
super
[
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
super
(
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
(
{
}
)
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
void
0
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
1
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
false
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
}
a
(
)
(
{
}
)
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
}
a
(
)
void
0
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
}
a
(
)
1
}
"
SyntaxError
)
;
assertClassError
(
"
class
NAME
{
constructor
(
)
{
}
a
(
)
false
}
"
SyntaxError
)
;
}
runtest
(
testClasses
)
;
