(
function
(
global
)
{
"
use
strict
"
;
var
undefined
;
var
Error
=
global
.
Error
;
var
Function
=
global
.
Function
;
var
Number
=
global
.
Number
;
var
RegExp
=
global
.
RegExp
;
var
String
=
global
.
String
;
var
Symbol
=
global
.
Symbol
;
var
TypeError
=
global
.
TypeError
;
var
ArrayIsArray
=
global
.
Array
.
isArray
;
var
MathAbs
=
global
.
Math
.
abs
;
var
ObjectCreate
=
global
.
Object
.
create
;
var
ObjectDefineProperty
=
global
.
Object
.
defineProperty
;
var
ReflectApply
=
global
.
Reflect
.
apply
;
var
RegExpPrototypeExec
=
global
.
RegExp
.
prototype
.
exec
;
var
StringPrototypeCharCodeAt
=
global
.
String
.
prototype
.
charCodeAt
;
var
StringPrototypeEndsWith
=
global
.
String
.
prototype
.
endsWith
;
var
StringPrototypeIndexOf
=
global
.
String
.
prototype
.
indexOf
;
var
StringPrototypeSubstring
=
global
.
String
.
prototype
.
substring
;
var
runningInBrowser
=
typeof
global
.
window
!
=
=
"
undefined
"
;
if
(
runningInBrowser
)
{
var
SpecialPowersSetGCZeal
=
global
.
SpecialPowers
?
global
.
SpecialPowers
.
setGCZeal
:
undefined
;
}
var
evaluate
=
global
.
evaluate
;
function
ArrayPop
(
arr
)
{
assertEq
(
ArrayIsArray
(
arr
)
true
"
ArrayPop
must
only
be
used
on
actual
arrays
"
)
;
var
len
=
arr
.
length
;
if
(
len
=
=
=
0
)
return
undefined
;
var
v
=
arr
[
len
-
1
]
;
arr
.
length
-
-
;
return
v
;
}
function
ArrayPush
(
arr
val
)
{
assertEq
(
ArrayIsArray
(
arr
)
true
"
ArrayPush
must
only
be
used
on
actual
arrays
"
)
;
var
desc
=
ObjectCreate
(
null
)
;
desc
.
value
=
val
;
desc
.
enumerable
=
true
;
desc
.
configurable
=
true
;
desc
.
writable
=
true
;
ObjectDefineProperty
(
arr
arr
.
length
desc
)
;
}
function
StringCharCodeAt
(
str
index
)
{
return
ReflectApply
(
StringPrototypeCharCodeAt
str
[
index
]
)
;
}
function
StringEndsWith
(
str
needle
)
{
return
ReflectApply
(
StringPrototypeEndsWith
str
[
needle
]
)
;
}
function
StringSplit
(
str
delimiter
)
{
assertEq
(
typeof
str
=
=
=
"
string
"
&
&
typeof
delimiter
=
=
=
"
string
"
true
"
StringSplit
must
be
called
with
two
string
arguments
"
)
;
assertEq
(
delimiter
.
length
>
0
true
"
StringSplit
doesn
'
t
support
an
empty
delimiter
string
"
)
;
var
parts
=
[
]
;
var
last
=
0
;
while
(
true
)
{
var
i
=
ReflectApply
(
StringPrototypeIndexOf
str
[
delimiter
last
]
)
;
if
(
i
<
0
)
{
if
(
last
<
str
.
length
)
ArrayPush
(
parts
ReflectApply
(
StringPrototypeSubstring
str
[
last
]
)
)
;
return
parts
;
}
ArrayPush
(
parts
ReflectApply
(
StringPrototypeSubstring
str
[
last
i
]
)
)
;
last
=
i
+
delimiter
.
length
;
}
}
function
SameValue
(
v1
v2
)
{
if
(
v1
=
=
=
0
&
&
v2
=
=
=
0
)
return
1
/
v1
=
=
=
1
/
v2
;
if
(
v1
!
=
=
v1
&
&
v2
!
=
=
v2
)
return
true
;
return
v1
=
=
=
v2
;
}
var
assertEq
=
global
.
assertEq
;
if
(
typeof
assertEq
!
=
=
"
function
"
)
{
assertEq
=
function
assertEq
(
actual
expected
message
)
{
if
(
!
SameValue
(
actual
expected
)
)
{
throw
new
TypeError
(
Assertion
failed
:
got
"
{
actual
}
"
expected
"
{
expected
}
"
+
(
message
?
"
:
"
+
message
:
"
"
)
)
;
}
}
;
global
.
assertEq
=
assertEq
;
}
function
assertEqArray
(
actual
expected
)
{
var
len
=
actual
.
length
;
assertEq
(
len
expected
.
length
"
mismatching
array
lengths
"
)
;
var
i
=
0
;
try
{
for
(
;
i
<
len
;
i
+
+
)
assertEq
(
actual
[
i
]
expected
[
i
]
"
mismatch
at
element
"
+
i
)
;
}
catch
(
e
)
{
throw
new
Error
(
Exception
thrown
at
index
{
i
}
:
{
e
}
)
;
}
}
global
.
assertEqArray
=
assertEqArray
;
function
assertThrows
(
f
)
{
var
ok
=
false
;
try
{
f
(
)
;
}
catch
(
exc
)
{
ok
=
true
;
}
if
(
!
ok
)
throw
new
Error
(
Assertion
failed
:
{
f
}
did
not
throw
as
expected
)
;
}
global
.
assertThrows
=
assertThrows
;
function
assertThrowsInstanceOf
(
f
ctor
msg
)
{
var
fullmsg
;
try
{
f
(
)
;
}
catch
(
exc
)
{
if
(
exc
instanceof
ctor
)
return
;
fullmsg
=
Assertion
failed
:
expected
exception
{
ctor
.
name
}
got
{
exc
}
;
}
if
(
fullmsg
=
=
=
undefined
)
fullmsg
=
Assertion
failed
:
expected
exception
{
ctor
.
name
}
no
exception
thrown
;
if
(
msg
!
=
=
undefined
)
fullmsg
+
=
"
-
"
+
msg
;
throw
new
Error
(
fullmsg
)
;
}
global
.
assertThrowsInstanceOf
=
assertThrowsInstanceOf
;
var
dump
=
global
.
dump
;
if
(
typeof
global
.
dump
=
=
=
"
function
"
)
{
}
else
{
if
(
runningInBrowser
)
{
dump
=
function
(
)
{
}
;
}
else
{
dump
=
global
.
print
;
}
global
.
dump
=
dump
;
}
var
print
;
if
(
runningInBrowser
)
{
print
=
function
print
(
)
{
var
s
=
"
TEST
-
INFO
|
"
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
s
+
=
String
(
arguments
[
i
]
)
+
"
"
;
dump
(
s
+
"
\
n
"
)
;
global
.
AddPrintOutput
(
s
)
;
}
;
global
.
print
=
print
;
}
else
{
print
=
global
.
print
;
}
var
quit
=
global
.
quit
;
if
(
typeof
quit
!
=
=
"
function
"
)
{
quit
=
function
quit
(
)
{
}
;
global
.
quit
=
quit
;
}
var
gczeal
=
global
.
gczeal
;
if
(
typeof
gczeal
!
=
=
"
function
"
)
{
if
(
typeof
SpecialPowersSetGCZeal
=
=
=
"
function
"
)
{
gczeal
=
function
gczeal
(
z
)
{
SpecialPowersSetGCZeal
(
z
)
;
}
;
}
else
{
gczeal
=
function
(
)
{
}
;
}
global
.
gczeal
=
gczeal
;
}
var
evaluateScript
=
global
.
evaluateScript
;
if
(
typeof
evaluate
=
=
=
"
function
"
&
&
typeof
evaluateScript
!
=
=
"
function
"
)
{
evaluateScript
=
function
evaluateScript
(
code
)
{
evaluate
(
String
(
code
)
)
;
}
;
global
.
evaluateScript
=
evaluateScript
;
}
function
toPrinted
(
value
)
{
value
=
String
(
value
)
;
var
digits
=
"
0123456789ABCDEF
"
;
var
result
=
"
"
;
for
(
var
i
=
0
;
i
<
value
.
length
;
i
+
+
)
{
var
ch
=
StringCharCodeAt
(
value
i
)
;
if
(
ch
=
=
=
0x5C
&
&
i
+
1
<
value
.
length
)
{
var
d
=
value
[
i
+
1
]
;
if
(
d
=
=
=
"
n
"
)
{
result
+
=
"
NL
"
;
i
+
+
;
}
else
if
(
d
=
=
=
"
r
"
)
{
result
+
=
"
CR
"
;
i
+
+
;
}
else
{
result
+
=
"
\
\
"
;
}
}
else
if
(
ch
=
=
=
0x0A
)
{
result
+
=
"
NL
"
;
}
else
if
(
ch
<
0x20
|
|
ch
>
0x7E
)
{
var
a
=
digits
[
ch
&
0xf
]
;
ch
>
>
=
4
;
var
b
=
digits
[
ch
&
0xf
]
;
ch
>
>
=
4
;
if
(
ch
)
{
var
c
=
digits
[
ch
&
0xf
]
;
ch
>
>
=
4
;
var
d
=
digits
[
ch
&
0xf
]
;
result
+
=
"
\
\
u
"
+
d
+
c
+
b
+
a
;
}
else
{
result
+
=
"
\
\
x
"
+
b
+
a
;
}
}
else
{
result
+
=
value
[
i
]
;
}
}
return
result
;
}
function
*
XorShiftGenerator
(
seed
size
)
{
let
x
=
seed
;
for
(
let
i
=
0
;
i
<
size
;
i
+
+
)
{
x
^
=
x
>
>
12
;
x
^
=
x
<
<
25
;
x
^
=
x
>
>
27
;
yield
x
%
256
;
}
}
global
.
XorShiftGenerator
=
XorShiftGenerator
;
global
.
SECTION
=
"
"
;
global
.
VERSION
=
"
"
;
global
.
BUGNUMBER
=
"
"
;
var
PASSED
=
"
PASSED
!
"
;
var
FAILED
=
"
FAILED
!
"
;
function
startTest
(
)
{
if
(
global
.
BUGNUMBER
)
print
(
"
BUGNUMBER
:
"
+
global
.
BUGNUMBER
)
;
}
global
.
startTest
=
startTest
;
var
callStack
=
[
]
;
function
enterFunc
(
funcName
)
{
assertEq
(
typeof
funcName
"
string
"
"
enterFunc
must
be
given
a
string
funcName
"
)
;
if
(
!
StringEndsWith
(
funcName
"
(
)
"
)
)
funcName
+
=
"
(
)
"
;
ArrayPush
(
callStack
funcName
)
;
}
global
.
enterFunc
=
enterFunc
;
function
exitFunc
(
funcName
)
{
assertEq
(
typeof
funcName
=
=
=
"
string
"
|
|
typeof
funcName
=
=
=
"
undefined
"
true
"
exitFunc
must
be
given
no
arguments
or
a
string
"
)
;
var
lastFunc
=
ArrayPop
(
callStack
)
;
assertEq
(
typeof
lastFunc
"
string
"
"
exitFunc
called
too
many
times
"
)
;
if
(
funcName
)
{
if
(
!
StringEndsWith
(
funcName
"
(
)
"
)
)
funcName
+
=
"
(
)
"
;
if
(
lastFunc
!
=
=
funcName
)
{
reportCompare
(
funcName
lastFunc
"
Test
driver
failure
wrong
exit
function
"
)
;
}
}
}
global
.
exitFunc
=
exitFunc
;
function
currentFunc
(
)
{
if
(
callStack
.
length
=
=
0
)
return
"
top
level
script
"
;
return
callStack
[
callStack
.
length
-
1
]
;
}
function
AddTestCase
(
description
expect
actual
)
{
new
TestCase
(
SECTION
description
expect
actual
)
;
}
global
.
AddTestCase
=
AddTestCase
;
var
testCasesCounter
=
0
;
var
testCasesArray
=
[
]
;
function
TestCase
(
n
d
e
a
r
)
{
this
.
name
=
n
;
this
.
description
=
d
;
this
.
expect
=
e
;
this
.
actual
=
a
;
this
.
passed
=
getTestCaseResult
(
e
a
)
;
this
.
reason
=
typeof
r
!
=
=
'
undefined
'
?
String
(
r
)
:
'
'
;
this
.
bugnumber
=
typeof
BUGNUMER
!
=
=
'
undefined
'
?
BUGNUMBER
:
'
'
;
this
.
type
=
runningInBrowser
?
'
browser
'
:
'
shell
'
;
ObjectDefineProperty
(
testCasesArray
testCasesCounter
+
+
{
__proto__
:
null
value
:
this
enumerable
:
true
configurable
:
true
writable
:
true
}
)
;
}
global
.
TestCase
=
TestCase
;
TestCase
.
prototype
.
dump
=
function
(
)
{
if
(
!
runningInBrowser
)
{
dump
(
\
njstest
:
{
this
.
path
}
+
bug
:
{
this
.
bugnumber
}
+
result
:
{
this
.
passed
?
'
PASSED
'
:
'
FAILED
'
}
+
type
:
{
this
.
type
}
+
description
:
{
toPrinted
(
this
.
description
)
}
+
reason
:
{
toPrinted
(
this
.
reason
)
}
\
n
)
;
}
}
;
TestCase
.
prototype
.
testPassed
=
(
function
TestCase_testPassed
(
)
{
return
this
.
passed
;
}
)
;
TestCase
.
prototype
.
testFailed
=
(
function
TestCase_testFailed
(
)
{
return
!
this
.
passed
;
}
)
;
TestCase
.
prototype
.
testDescription
=
(
function
TestCase_testDescription
(
)
{
return
this
.
description
+
'
'
+
this
.
reason
;
}
)
;
function
getTestCaseResult
(
expected
actual
)
{
if
(
typeof
expected
!
=
=
typeof
actual
)
return
false
;
if
(
typeof
expected
!
=
=
'
number
'
)
return
actual
=
=
expected
;
if
(
actual
!
=
=
actual
)
return
expected
!
=
=
expected
;
if
(
expected
!
=
=
expected
)
return
false
;
if
(
actual
!
=
=
expected
)
return
MathAbs
(
actual
-
expected
)
<
=
1E
-
10
;
return
true
;
}
function
reportTestCaseResult
(
description
expected
actual
output
)
{
var
testcase
=
new
TestCase
(
"
unknown
-
test
-
name
"
description
expected
actual
output
)
;
if
(
!
runningInBrowser
)
{
if
(
testcase
.
passed
)
{
print
(
PASSED
+
description
)
;
}
else
{
reportFailure
(
description
+
"
:
"
+
output
)
;
}
}
}
function
getTestCases
(
)
{
return
testCasesArray
;
}
global
.
getTestCases
=
getTestCases
;
function
expectExitCode
(
n
)
{
print
(
'
-
-
-
NOTE
:
IN
THIS
TESTCASE
WE
EXPECT
EXIT
CODE
'
+
n
+
'
-
-
-
'
)
;
}
global
.
expectExitCode
=
expectExitCode
;
function
inSection
(
x
)
{
return
"
Section
"
+
x
+
"
of
test
-
"
;
}
global
.
inSection
=
inSection
;
function
reportFailure
(
msg
)
{
msg
=
String
(
msg
)
;
var
lines
=
StringSplit
(
msg
"
\
n
"
)
;
var
funcName
=
currentFunc
(
)
;
var
prefix
=
funcName
?
"
[
reported
from
"
+
funcName
+
"
]
"
:
"
"
;
for
(
var
i
=
0
;
i
<
lines
.
length
;
i
+
+
)
print
(
FAILED
+
prefix
+
lines
[
i
]
)
;
}
global
.
reportFailure
=
reportFailure
;
function
printStatus
(
msg
)
{
msg
=
String
(
msg
)
;
var
lines
=
StringSplit
(
msg
"
\
n
"
)
;
for
(
var
i
=
0
;
i
<
lines
.
length
;
i
+
+
)
print
(
"
STATUS
:
"
+
lines
[
i
]
)
;
}
global
.
printStatus
=
printStatus
;
function
printBugNumber
(
num
)
{
BUGNUMBER
=
num
;
print
(
'
BUGNUMBER
:
'
+
num
)
;
}
global
.
printBugNumber
=
printBugNumber
;
function
reportCompare
(
expected
actual
description
)
{
var
expected_t
=
typeof
expected
;
var
actual_t
=
typeof
actual
;
var
output
=
"
"
;
if
(
typeof
description
=
=
=
"
undefined
"
)
description
=
"
"
;
if
(
expected_t
!
=
=
actual_t
)
output
+
=
Type
mismatch
expected
type
{
expected_t
}
actual
type
{
actual_t
}
;
if
(
expected
!
=
actual
)
output
+
=
Expected
value
'
{
toPrinted
(
expected
)
}
'
Actual
value
'
{
toPrinted
(
actual
)
}
'
;
reportTestCaseResult
(
description
expected
actual
output
)
;
}
global
.
reportCompare
=
reportCompare
;
function
reportMatch
(
expectedRegExp
actual
description
)
{
var
expected_t
=
"
string
"
;
var
actual_t
=
typeof
actual
;
var
output
=
"
"
;
if
(
typeof
description
=
=
=
"
undefined
"
)
description
=
"
"
;
if
(
expected_t
!
=
=
actual_t
)
output
+
=
Type
mismatch
expected
type
{
expected_t
}
actual
type
{
actual_t
}
;
var
matches
=
ReflectApply
(
RegExpPrototypeExec
expectedRegExp
[
actual
]
)
!
=
=
null
;
if
(
!
matches
)
{
output
+
=
Expected
match
to
'
{
toPrinted
(
expectedRegExp
)
}
'
Actual
value
'
{
toPrinted
(
actual
)
}
'
;
}
reportTestCaseResult
(
description
true
matches
output
)
;
}
global
.
reportMatch
=
reportMatch
;
function
compareSource
(
expect
actual
summary
)
{
var
expectP
=
String
(
expect
)
;
var
actualP
=
String
(
actual
)
;
print
(
'
expect
:
\
n
'
+
expectP
)
;
print
(
'
actual
:
\
n
'
+
actualP
)
;
reportCompare
(
expectP
actualP
summary
)
;
try
{
var
expectCompile
=
'
No
Error
'
;
var
actualCompile
;
Function
(
expect
)
;
try
{
Function
(
actual
)
;
actualCompile
=
'
No
Error
'
;
}
catch
(
ex1
)
{
actualCompile
=
ex1
+
'
'
;
}
reportCompare
(
expectCompile
actualCompile
summary
+
'
:
compile
actual
'
)
;
}
catch
(
ex
)
{
}
}
global
.
compareSource
=
compareSource
;
function
test
(
)
{
var
testCases
=
getTestCases
(
)
;
for
(
var
i
=
0
;
i
<
testCases
.
length
;
i
+
+
)
{
var
testCase
=
testCases
[
i
]
;
testCase
.
reason
+
=
testCase
.
passed
?
"
"
:
"
wrong
value
"
;
if
(
!
runningInBrowser
)
{
var
message
=
{
testCase
.
description
}
=
{
testCase
.
actual
}
expected
:
{
testCase
.
expect
}
;
print
(
(
testCase
.
passed
?
PASSED
:
FAILED
)
+
message
)
;
}
}
}
global
.
test
=
test
;
function
writeHeaderToLog
(
string
)
{
print
(
string
)
;
}
global
.
writeHeaderToLog
=
writeHeaderToLog
;
function
jsTestDriverEnd
(
)
{
if
(
gDelayTestDriverEnd
)
{
return
;
}
try
{
optionsReset
(
)
;
}
catch
(
ex
)
{
dump
(
'
jsTestDriverEnd
'
+
ex
)
;
}
var
testCases
=
getTestCases
(
)
;
for
(
var
i
=
0
;
i
<
testCases
.
length
;
i
+
+
)
{
testCases
[
i
]
.
dump
(
)
;
}
}
global
.
jsTestDriverEnd
=
jsTestDriverEnd
;
function
getPromiseResult
(
promise
)
{
var
result
error
caught
=
false
;
promise
.
then
(
r
=
>
{
result
=
r
;
}
e
=
>
{
caught
=
true
;
error
=
e
;
}
)
;
drainJobQueue
(
)
;
if
(
caught
)
throw
error
;
return
result
;
}
global
.
getPromiseResult
=
getPromiseResult
;
function
assertEventuallyEq
(
promise
expected
)
{
assertEq
(
getPromiseResult
(
promise
)
expected
)
;
}
global
.
assertEventuallyEq
=
assertEventuallyEq
;
function
assertEventuallyThrows
(
promise
expectedErrorType
)
{
assertThrowsInstanceOf
(
(
)
=
>
getPromiseResult
(
promise
)
expectedErrorType
)
;
}
;
global
.
assertEventuallyThrows
=
assertEventuallyThrows
;
function
assertEventuallyDeepEq
(
promise
expected
)
{
assertDeepEq
(
getPromiseResult
(
promise
)
expected
)
;
}
;
global
.
assertEventuallyDeepEq
=
assertEventuallyDeepEq
;
}
)
(
this
)
;
var
gDelayTestDriverEnd
=
false
;
var
gFailureExpected
=
false
;
var
GLOBAL
=
this
+
'
'
;
var
DESCRIPTION
;
var
EXPECTED
;
function
optionsInit
(
)
{
options
.
initvalues
=
{
}
;
options
.
stackvalues
=
[
]
;
var
optionNames
=
options
(
)
.
split
(
'
'
)
;
for
(
var
i
=
0
;
i
<
optionNames
.
length
;
i
+
+
)
{
var
optionName
=
optionNames
[
i
]
;
if
(
optionName
)
{
options
.
initvalues
[
optionName
]
=
'
'
;
}
}
}
function
optionsClear
(
)
{
var
optionNames
=
options
(
)
.
split
(
'
'
)
;
for
(
var
i
=
0
;
i
<
optionNames
.
length
;
i
+
+
)
{
var
optionName
=
optionNames
[
i
]
;
if
(
optionName
&
&
optionName
!
=
=
"
ion
"
)
{
options
(
optionName
)
;
}
}
}
function
optionsPush
(
)
{
var
optionsframe
=
{
}
;
options
.
stackvalues
.
push
(
optionsframe
)
;
var
optionNames
=
options
(
)
.
split
(
'
'
)
;
for
(
var
i
=
0
;
i
<
optionNames
.
length
;
i
+
+
)
{
var
optionName
=
optionNames
[
i
]
;
if
(
optionName
)
{
optionsframe
[
optionName
]
=
'
'
;
}
}
optionsClear
(
)
;
}
function
optionsPop
(
)
{
var
optionsframe
=
options
.
stackvalues
.
pop
(
)
;
optionsClear
(
)
;
for
(
var
optionName
in
optionsframe
)
{
options
(
optionName
)
;
}
}
function
optionsReset
(
)
{
try
{
optionsClear
(
)
;
for
(
var
optionName
in
options
.
initvalues
)
{
if
(
!
options
.
hasOwnProperty
(
optionName
)
)
continue
;
options
(
optionName
)
;
}
}
catch
(
ex
)
{
print
(
'
optionsReset
:
caught
'
+
ex
)
;
}
}
if
(
typeof
options
=
=
'
function
'
)
{
optionsInit
(
)
;
optionsClear
(
)
;
}
