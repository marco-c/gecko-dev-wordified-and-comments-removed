(
function
(
global
)
{
"
use
strict
"
;
var
undefined
;
var
document
=
global
.
document
;
var
Error
=
global
.
Error
;
var
Function
=
global
.
Function
;
var
Number
=
global
.
Number
;
var
RegExp
=
global
.
RegExp
;
var
String
=
global
.
String
;
var
Symbol
=
global
.
Symbol
;
var
TypeError
=
global
.
TypeError
;
var
ArrayIsArray
=
global
.
Array
.
isArray
;
var
MathAbs
=
global
.
Math
.
abs
;
var
ObjectCreate
=
global
.
Object
.
create
;
var
ObjectDefineProperty
=
global
.
Object
.
defineProperty
;
var
ReflectApply
=
global
.
Reflect
.
apply
;
var
RegExpPrototypeExec
=
global
.
RegExp
.
prototype
.
exec
;
var
StringPrototypeCharCodeAt
=
global
.
String
.
prototype
.
charCodeAt
;
var
StringPrototypeEndsWith
=
global
.
String
.
prototype
.
endsWith
;
var
StringPrototypeIndexOf
=
global
.
String
.
prototype
.
indexOf
;
var
StringPrototypeSubstring
=
global
.
String
.
prototype
.
substring
;
var
runningInBrowser
=
typeof
global
.
window
!
=
=
"
undefined
"
;
if
(
runningInBrowser
)
{
var
SpecialPowersSetGCZeal
=
global
.
SpecialPowers
?
global
.
SpecialPowers
.
setGCZeal
:
undefined
;
}
var
runningInShell
=
typeof
window
=
=
=
"
undefined
"
;
var
isReftest
=
typeof
document
=
=
=
"
object
"
&
&
/
jsreftest
.
html
/
.
test
(
document
.
location
.
href
)
;
var
evaluate
=
global
.
evaluate
;
function
ArrayPop
(
arr
)
{
assertEq
(
ArrayIsArray
(
arr
)
true
"
ArrayPop
must
only
be
used
on
actual
arrays
"
)
;
var
len
=
arr
.
length
;
if
(
len
=
=
=
0
)
return
undefined
;
var
v
=
arr
[
len
-
1
]
;
arr
.
length
-
-
;
return
v
;
}
function
ArrayPush
(
arr
val
)
{
assertEq
(
ArrayIsArray
(
arr
)
true
"
ArrayPush
must
only
be
used
on
actual
arrays
"
)
;
var
desc
=
ObjectCreate
(
null
)
;
desc
.
value
=
val
;
desc
.
enumerable
=
true
;
desc
.
configurable
=
true
;
desc
.
writable
=
true
;
ObjectDefineProperty
(
arr
arr
.
length
desc
)
;
}
function
StringCharCodeAt
(
str
index
)
{
return
ReflectApply
(
StringPrototypeCharCodeAt
str
[
index
]
)
;
}
function
StringEndsWith
(
str
needle
)
{
return
ReflectApply
(
StringPrototypeEndsWith
str
[
needle
]
)
;
}
function
StringReplace
(
str
regexp
replacement
)
{
assertEq
(
typeof
str
=
=
=
"
string
"
&
&
typeof
regexp
=
=
=
"
object
"
&
&
typeof
replacement
=
=
=
"
function
"
true
"
StringReplace
must
be
called
with
a
string
a
RegExp
object
and
a
function
"
)
;
regexp
.
lastIndex
=
0
;
var
result
=
"
"
;
var
last
=
0
;
while
(
true
)
{
var
match
=
ReflectApply
(
RegExpPrototypeExec
regexp
[
str
]
)
;
if
(
!
match
)
{
result
+
=
ReflectApply
(
StringPrototypeSubstring
str
[
last
]
)
;
return
result
;
}
result
+
=
ReflectApply
(
StringPrototypeSubstring
str
[
last
match
.
index
]
)
;
result
+
=
ReflectApply
(
replacement
null
match
)
;
last
=
match
.
index
+
match
[
0
]
.
length
;
}
}
function
StringSplit
(
str
delimiter
)
{
assertEq
(
typeof
str
=
=
=
"
string
"
&
&
typeof
delimiter
=
=
=
"
string
"
true
"
StringSplit
must
be
called
with
two
string
arguments
"
)
;
assertEq
(
delimiter
.
length
>
0
true
"
StringSplit
doesn
'
t
support
an
empty
delimiter
string
"
)
;
var
parts
=
[
]
;
var
last
=
0
;
while
(
true
)
{
var
i
=
ReflectApply
(
StringPrototypeIndexOf
str
[
delimiter
last
]
)
;
if
(
i
<
0
)
{
if
(
last
<
str
.
length
)
ArrayPush
(
parts
ReflectApply
(
StringPrototypeSubstring
str
[
last
]
)
)
;
return
parts
;
}
ArrayPush
(
parts
ReflectApply
(
StringPrototypeSubstring
str
[
last
i
]
)
)
;
last
=
i
+
delimiter
.
length
;
}
}
function
SameValue
(
v1
v2
)
{
if
(
v1
=
=
=
0
&
&
v2
=
=
=
0
)
return
1
/
v1
=
=
=
1
/
v2
;
if
(
v1
!
=
=
v1
&
&
v2
!
=
=
v2
)
return
true
;
return
v1
=
=
=
v2
;
}
var
assertEq
=
global
.
assertEq
;
if
(
typeof
assertEq
!
=
=
"
function
"
)
{
assertEq
=
function
assertEq
(
actual
expected
message
)
{
if
(
!
SameValue
(
actual
expected
)
)
{
throw
new
TypeError
(
'
Assertion
failed
:
got
"
'
+
actual
+
'
"
'
+
'
expected
"
'
+
expected
+
(
message
?
"
:
"
+
message
:
"
"
)
)
;
}
}
;
global
.
assertEq
=
assertEq
;
}
function
assertEqArray
(
actual
expected
)
{
var
len
=
actual
.
length
;
assertEq
(
len
expected
.
length
"
mismatching
array
lengths
"
)
;
var
i
=
0
;
try
{
for
(
;
i
<
len
;
i
+
+
)
assertEq
(
actual
[
i
]
expected
[
i
]
"
mismatch
at
element
"
+
i
)
;
}
catch
(
e
)
{
throw
new
Error
(
"
Exception
thrown
at
index
"
+
i
+
"
:
"
+
e
)
;
}
}
global
.
assertEqArray
=
assertEqArray
;
function
assertThrows
(
f
)
{
var
ok
=
false
;
try
{
f
(
)
;
}
catch
(
exc
)
{
ok
=
true
;
}
if
(
!
ok
)
throw
new
Error
(
"
Assertion
failed
:
"
+
f
+
"
did
not
throw
as
expected
"
)
;
}
global
.
assertThrows
=
assertThrows
;
function
assertThrowsInstanceOf
(
f
ctor
msg
)
{
var
fullmsg
;
try
{
f
(
)
;
}
catch
(
exc
)
{
if
(
exc
instanceof
ctor
)
return
;
fullmsg
=
"
Assertion
failed
:
expected
exception
"
+
ctor
.
name
+
"
got
"
+
exc
;
}
if
(
fullmsg
=
=
=
undefined
)
{
fullmsg
=
"
Assertion
failed
:
expected
exception
"
+
ctor
.
name
+
"
"
+
"
no
exception
thrown
"
;
}
if
(
msg
!
=
=
undefined
)
fullmsg
+
=
"
-
"
+
msg
;
throw
new
Error
(
fullmsg
)
;
}
global
.
assertThrowsInstanceOf
=
assertThrowsInstanceOf
;
var
dump
=
global
.
dump
;
if
(
typeof
global
.
dump
=
=
=
"
function
"
)
{
}
else
{
if
(
runningInBrowser
)
{
dump
=
function
(
)
{
}
;
}
else
{
dump
=
global
.
print
;
}
global
.
dump
=
dump
;
}
var
print
;
if
(
runningInBrowser
)
{
print
=
function
print
(
)
{
var
s
=
"
TEST
-
INFO
|
"
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
s
+
=
String
(
arguments
[
i
]
)
+
"
"
;
dump
(
s
+
"
\
n
"
)
;
global
.
AddPrintOutput
(
s
)
;
}
;
global
.
print
=
print
;
}
else
{
print
=
global
.
print
;
}
var
quit
=
global
.
quit
;
if
(
typeof
quit
!
=
=
"
function
"
)
{
quit
=
function
quit
(
)
{
}
;
global
.
quit
=
quit
;
}
var
gczeal
=
global
.
gczeal
;
if
(
typeof
gczeal
!
=
=
"
function
"
)
{
if
(
typeof
SpecialPowersSetGCZeal
=
=
=
"
function
"
)
{
gczeal
=
function
gczeal
(
z
)
{
SpecialPowersSetGCZeal
(
z
)
;
}
;
}
else
{
gczeal
=
function
(
)
{
}
;
}
global
.
gczeal
=
gczeal
;
}
var
evaluateScript
=
global
.
evaluateScript
;
if
(
typeof
evaluate
=
=
=
"
function
"
&
&
typeof
evaluateScript
!
=
=
"
function
"
)
{
evaluateScript
=
function
evaluateScript
(
code
)
{
evaluate
(
String
(
code
)
)
;
}
;
global
.
evaluateScript
=
evaluateScript
;
}
function
toPrinted
(
value
)
{
value
=
String
(
value
)
;
var
digits
=
"
0123456789ABCDEF
"
;
var
result
=
"
"
;
for
(
var
i
=
0
;
i
<
value
.
length
;
i
+
+
)
{
var
ch
=
StringCharCodeAt
(
value
i
)
;
if
(
ch
=
=
=
0x5C
&
&
i
+
1
<
value
.
length
)
{
var
d
=
value
[
i
+
1
]
;
if
(
d
=
=
=
"
n
"
)
{
result
+
=
"
NL
"
;
i
+
+
;
}
else
if
(
d
=
=
=
"
r
"
)
{
result
+
=
"
CR
"
;
i
+
+
;
}
else
{
result
+
=
"
\
\
"
;
}
}
else
if
(
c
=
=
=
0x0A
)
{
result
+
=
"
NL
"
;
}
else
if
(
ch
<
0x20
|
|
ch
>
0x7E
)
{
var
a
=
digits
[
ch
&
0xf
]
;
ch
>
>
=
4
;
var
b
=
digits
[
ch
&
0xf
]
;
ch
>
>
=
4
;
if
(
ch
)
{
var
c
=
digits
[
ch
&
0xf
]
;
ch
>
>
=
4
;
var
d
=
digits
[
ch
&
0xf
]
;
result
+
=
"
\
\
u
"
+
d
+
c
+
b
+
a
;
}
else
{
result
+
=
"
\
\
x
"
+
b
+
a
;
}
}
else
{
result
+
=
value
[
i
]
;
}
}
return
result
;
}
global
.
toPrinted
=
toPrinted
;
function
*
XorShiftGenerator
(
seed
size
)
{
let
x
=
seed
;
for
(
let
i
=
0
;
i
<
size
;
i
+
+
)
{
x
^
=
x
>
>
12
;
x
^
=
x
<
<
25
;
x
^
=
x
>
>
27
;
yield
x
%
256
;
}
}
global
.
XorShiftGenerator
=
XorShiftGenerator
;
global
.
SECTION
=
"
"
;
global
.
VERSION
=
"
"
;
global
.
BUGNUMBER
=
"
"
;
var
PASSED
=
"
PASSED
!
"
;
global
.
PASSED
=
PASSED
;
var
FAILED
=
"
FAILED
!
"
;
global
.
FAILED
=
FAILED
;
function
startTest
(
)
{
if
(
global
.
BUGNUMBER
)
global
.
print
(
"
BUGNUMBER
:
"
+
global
.
BUGNUMBER
)
;
}
global
.
startTest
=
startTest
;
var
callStack
=
[
]
;
function
enterFunc
(
funcName
)
{
assertEq
(
typeof
funcName
"
string
"
"
enterFunc
must
be
given
a
string
funcName
"
)
;
if
(
!
StringEndsWith
(
funcName
"
(
)
"
)
)
funcName
+
=
"
(
)
"
;
ArrayPush
(
callStack
funcName
)
;
}
global
.
enterFunc
=
enterFunc
;
function
exitFunc
(
funcName
)
{
assertEq
(
typeof
funcName
=
=
=
"
string
"
|
|
typeof
funcName
=
=
=
"
undefined
"
true
"
exitFunc
must
be
given
no
arguments
or
a
string
"
)
;
var
lastFunc
=
ArrayPop
(
callStack
)
;
assertEq
(
typeof
lastFunc
"
string
"
"
exitFunc
called
too
many
times
"
)
;
if
(
funcName
)
{
if
(
!
StringEndsWith
(
funcName
"
(
)
"
)
)
funcName
+
=
"
(
)
"
;
if
(
lastFunc
!
=
=
funcName
)
{
global
.
reportCompare
(
funcName
lastFunc
"
Test
driver
failure
wrong
exit
function
"
)
;
}
}
}
global
.
exitFunc
=
exitFunc
;
function
currentFunc
(
)
{
if
(
callStack
.
length
=
=
0
)
return
"
top
level
script
"
;
return
callStack
[
callStack
.
length
-
1
]
;
}
global
.
currentFunc
=
currentFunc
;
var
writeFormattedResult
=
function
writeFormattedResult
(
expect
actual
string
passed
)
{
print
(
(
passed
?
PASSED
:
FAILED
)
+
string
+
'
expected
:
'
+
expect
)
;
}
;
global
.
writeFormattedResult
=
writeFormattedResult
;
function
AddTestCase
(
description
expect
actual
)
{
new
TestCase
(
SECTION
description
expect
actual
)
;
}
global
.
AddTestCase
=
AddTestCase
;
function
TestCase
(
n
d
e
a
)
{
this
.
name
=
n
;
this
.
description
=
d
;
this
.
expect
=
e
;
this
.
actual
=
a
;
this
.
passed
=
getTestCaseResult
(
e
a
)
;
this
.
reason
=
'
'
;
this
.
bugnumber
=
typeof
BUGNUMER
!
=
=
'
undefined
'
?
BUGNUMBER
:
'
'
;
this
.
type
=
runningInShell
?
'
shell
'
:
'
browser
'
;
ObjectDefineProperty
(
gTestcases
gTc
+
+
{
__proto__
:
null
value
:
this
enumerable
:
true
configurable
:
true
writable
:
true
}
)
;
}
global
.
TestCase
=
TestCase
;
TestCase
.
prototype
.
dump
=
function
(
)
{
if
(
!
isReftest
)
{
dump
(
'
\
njstest
:
'
+
this
.
path
+
'
'
+
'
bug
:
'
+
this
.
bugnumber
+
'
'
+
'
result
:
'
+
(
this
.
passed
?
'
PASSED
'
:
'
FAILED
'
)
+
'
'
+
'
type
:
'
+
this
.
type
+
'
'
+
'
description
:
'
+
toPrinted
(
this
.
description
)
+
'
'
+
'
reason
:
'
+
toPrinted
(
this
.
reason
)
+
'
\
n
'
)
;
}
}
;
TestCase
.
prototype
.
testPassed
=
(
function
TestCase_testPassed
(
)
{
return
this
.
passed
;
}
)
;
TestCase
.
prototype
.
testFailed
=
(
function
TestCase_testFailed
(
)
{
return
!
this
.
passed
;
}
)
;
TestCase
.
prototype
.
testDescription
=
(
function
TestCase_testDescription
(
)
{
return
this
.
description
+
'
'
+
this
.
reason
;
}
)
;
function
getTestCases
(
)
{
return
gTestcases
;
}
global
.
getTestCases
=
getTestCases
;
function
expectExitCode
(
n
)
{
print
(
'
-
-
-
NOTE
:
IN
THIS
TESTCASE
WE
EXPECT
EXIT
CODE
'
+
n
+
'
-
-
-
'
)
;
}
global
.
expectExitCode
=
expectExitCode
;
function
inSection
(
x
)
{
return
"
Section
"
+
x
+
"
of
test
-
"
;
}
global
.
inSection
=
inSection
;
function
reportFailure
(
msg
)
{
var
lines
=
StringSplit
(
msg
"
\
n
"
)
;
var
funcName
=
currentFunc
(
)
;
var
prefix
=
funcName
?
"
[
reported
from
"
+
funcName
+
"
]
"
:
"
"
;
for
(
var
i
=
0
;
i
<
lines
.
length
;
i
+
+
)
print
(
FAILED
+
prefix
+
lines
[
i
]
)
;
}
global
.
reportFailure
=
reportFailure
;
function
printStatus
(
msg
)
{
msg
=
String
(
msg
)
;
var
lines
=
StringSplit
(
msg
"
\
n
"
)
;
for
(
var
i
=
0
;
i
<
lines
.
length
;
i
+
+
)
print
(
STATUS
+
lines
[
i
]
)
;
}
global
.
printStatus
=
printStatus
;
function
printBugNumber
(
num
)
{
BUGNUMBER
=
num
;
print
(
'
BUGNUMBER
:
'
+
num
)
;
}
global
.
printBugNumber
=
printBugNumber
;
function
reportCompare
(
expected
actual
description
)
{
var
expected_t
=
typeof
expected
;
var
actual_t
=
typeof
actual
;
var
output
=
"
"
;
if
(
typeof
description
=
=
=
"
undefined
"
)
description
=
'
'
;
if
(
expected_t
!
=
=
actual_t
)
{
output
+
=
"
Type
mismatch
expected
type
"
+
expected_t
+
"
actual
type
"
+
actual_t
+
"
"
;
}
if
(
expected
!
=
actual
)
{
output
+
=
"
Expected
value
'
"
+
toPrinted
(
expected
)
+
"
'
Actual
value
'
"
+
toPrinted
(
actual
)
+
"
'
"
;
}
var
testcase
=
new
TestCase
(
"
unknown
-
test
-
name
"
description
expected
actual
)
;
testcase
.
reason
=
output
;
if
(
!
isReftest
)
{
if
(
testcase
.
passed
)
{
print
(
PASSED
+
description
)
;
}
else
{
reportFailure
(
description
+
"
:
"
+
output
)
;
}
}
return
testcase
.
passed
;
}
global
.
reportCompare
=
reportCompare
;
function
reportMatch
(
expectedRegExp
actual
description
)
{
var
expected_t
=
"
string
"
;
var
actual_t
=
typeof
actual
;
var
output
=
"
"
;
if
(
typeof
description
=
=
=
"
undefined
"
)
description
=
'
'
;
if
(
expected_t
!
=
=
actual_t
)
{
output
+
=
"
Type
mismatch
expected
type
"
+
expected_t
+
"
actual
type
"
+
actual_t
+
"
"
;
}
var
matches
=
ReflectApply
(
RegExpPrototypeExec
expectedRegExp
[
actual
]
)
!
=
=
null
;
if
(
!
matches
)
{
output
+
=
"
Expected
match
to
'
"
+
toPrinted
(
expectedRegExp
)
+
"
'
Actual
value
'
"
+
toPrinted
(
actual
)
+
"
'
"
;
}
var
testcase
=
new
TestCase
(
"
unknown
-
test
-
name
"
description
true
matches
)
;
testcase
.
reason
=
output
;
if
(
!
isReftest
)
{
if
(
testcase
.
passed
)
{
print
(
PASSED
+
description
)
;
}
else
{
reportFailure
(
description
+
"
:
"
+
output
)
;
}
}
return
testcase
.
passed
;
}
global
.
reportMatch
=
reportMatch
;
function
normalizeSource
(
source
)
{
source
=
String
(
source
)
;
source
=
StringReplace
(
source
/
(
[
(
)
{
}
.
:
\
[
\
]
]
)
/
mg
(
_
punctuator
)
=
>
{
punctuator
}
)
;
source
=
StringReplace
(
source
/
(
\
w
+
)
/
mg
(
_
word
)
=
>
{
word
}
)
;
source
=
StringReplace
(
source
/
<
(
\
/
)
?
(
\
w
+
)
(
\
/
)
?
>
/
mg
(
_
left
=
"
"
tagName
right
=
"
"
)
=
>
<
{
left
}
{
tagName
}
{
right
}
>
)
;
source
=
StringReplace
(
source
/
\
s
+
/
mg
_
=
>
'
'
)
;
source
=
StringReplace
(
source
/
new
(
\
w
+
)
\
s
*
\
(
\
s
*
\
)
/
mg
(
_
name
)
=
>
new
{
name
}
)
;
return
source
;
}
function
compareSource
(
expect
actual
summary
)
{
var
expectP
=
normalizeSource
(
expect
)
;
var
actualP
=
normalizeSource
(
actual
)
;
print
(
'
expect
:
\
n
'
+
expectP
)
;
print
(
'
actual
:
\
n
'
+
actualP
)
;
reportCompare
(
expectP
actualP
summary
)
;
try
{
var
expectCompile
=
'
No
Error
'
;
var
actualCompile
;
Function
(
expect
)
;
try
{
Function
(
actual
)
;
actualCompile
=
'
No
Error
'
;
}
catch
(
ex1
)
{
actualCompile
=
ex1
+
'
'
;
}
reportCompare
(
expectCompile
actualCompile
summary
+
'
:
compile
actual
'
)
;
}
catch
(
ex
)
{
}
}
global
.
compareSource
=
compareSource
;
function
getTestCaseResult
(
expected
actual
)
{
if
(
typeof
expected
!
=
=
typeof
actual
)
return
false
;
if
(
typeof
expected
!
=
=
'
number
'
)
return
actual
=
=
expected
;
if
(
actual
!
=
=
actual
)
return
expected
!
=
=
expected
;
if
(
expected
!
=
=
expected
)
return
false
;
if
(
actual
!
=
=
expected
)
return
MathAbs
(
actual
-
expected
)
<
=
1E
-
10
;
return
true
;
}
function
test
(
)
{
for
(
gTc
=
0
;
gTc
<
gTestcases
.
length
;
gTc
+
+
)
{
try
{
var
testCase
=
gTestcases
[
gTc
]
;
testCase
.
passed
=
writeTestCaseResult
(
testCase
.
expect
testCase
.
actual
testCase
.
description
+
"
=
"
+
testCase
.
actual
)
;
testCase
.
reason
+
=
testCase
.
passed
?
"
"
:
"
wrong
value
"
;
}
catch
(
e
)
{
print
(
'
test
(
)
:
empty
testcase
for
gTc
=
'
+
gTc
+
'
'
+
e
)
;
}
}
return
gTestcases
;
}
global
.
test
=
test
;
function
writeTestCaseResult
(
expect
actual
string
)
{
var
passed
=
getTestCaseResult
(
expect
actual
)
;
if
(
!
isReftest
)
{
writeFormattedResult
(
expect
actual
string
passed
)
;
}
return
passed
;
}
global
.
writeTestCaseResult
=
writeTestCaseResult
;
function
writeHeaderToLog
(
string
)
{
print
(
string
)
;
}
global
.
writeHeaderToLog
=
writeHeaderToLog
;
function
jsTestDriverEnd
(
)
{
if
(
gDelayTestDriverEnd
)
{
return
;
}
try
{
optionsReset
(
)
;
}
catch
(
ex
)
{
dump
(
'
jsTestDriverEnd
'
+
ex
)
;
}
for
(
var
i
=
0
;
i
<
gTestcases
.
length
;
i
+
+
)
{
gTestcases
[
i
]
.
dump
(
)
;
}
}
global
.
jsTestDriverEnd
=
jsTestDriverEnd
;
function
getPromiseResult
(
promise
)
{
var
result
error
caught
=
false
;
promise
.
then
(
r
=
>
{
result
=
r
;
}
e
=
>
{
caught
=
true
;
error
=
e
;
}
)
;
drainJobQueue
(
)
;
if
(
caught
)
throw
error
;
return
result
;
}
function
assertEventuallyEq
(
promise
expected
)
{
assertEq
(
getPromiseResult
(
promise
)
expected
)
;
}
global
.
assertEventuallyEq
=
assertEventuallyEq
;
function
assertEventuallyThrows
(
promise
expectedErrorType
)
{
assertThrowsInstanceOf
(
(
)
=
>
getPromiseResult
(
promise
)
expectedErrorType
)
;
}
;
global
.
assertEventuallyThrows
=
assertEventuallyThrows
;
function
assertEventuallyDeepEq
(
promise
expected
)
{
assertDeepEq
(
getPromiseResult
(
promise
)
expected
)
;
}
;
global
.
assertEventuallyDeepEq
=
assertEventuallyDeepEq
;
}
)
(
this
)
;
var
STATUS
=
"
STATUS
:
"
;
var
gDelayTestDriverEnd
=
false
;
var
gFailureExpected
=
false
;
var
gTestcases
=
new
Array
(
)
;
var
gTc
=
gTestcases
.
length
;
var
summary
=
'
'
;
var
description
=
'
'
;
var
expected
=
'
'
;
var
actual
=
'
'
;
var
msg
=
'
'
;
var
GLOBAL
=
this
+
'
'
;
var
DESCRIPTION
;
var
EXPECTED
;
function
optionsInit
(
)
{
options
.
initvalues
=
{
}
;
options
.
stackvalues
=
[
]
;
var
optionNames
=
options
(
)
.
split
(
'
'
)
;
for
(
var
i
=
0
;
i
<
optionNames
.
length
;
i
+
+
)
{
var
optionName
=
optionNames
[
i
]
;
if
(
optionName
)
{
options
.
initvalues
[
optionName
]
=
'
'
;
}
}
}
function
optionsClear
(
)
{
var
optionNames
=
options
(
)
.
split
(
'
'
)
;
for
(
var
i
=
0
;
i
<
optionNames
.
length
;
i
+
+
)
{
var
optionName
=
optionNames
[
i
]
;
if
(
optionName
&
&
optionName
!
=
=
"
ion
"
)
{
options
(
optionName
)
;
}
}
}
function
optionsPush
(
)
{
var
optionsframe
=
{
}
;
options
.
stackvalues
.
push
(
optionsframe
)
;
var
optionNames
=
options
(
)
.
split
(
'
'
)
;
for
(
var
i
=
0
;
i
<
optionNames
.
length
;
i
+
+
)
{
var
optionName
=
optionNames
[
i
]
;
if
(
optionName
)
{
optionsframe
[
optionName
]
=
'
'
;
}
}
optionsClear
(
)
;
}
function
optionsPop
(
)
{
var
optionsframe
=
options
.
stackvalues
.
pop
(
)
;
optionsClear
(
)
;
for
(
var
optionName
in
optionsframe
)
{
options
(
optionName
)
;
}
}
function
optionsReset
(
)
{
try
{
optionsClear
(
)
;
for
(
var
optionName
in
options
.
initvalues
)
{
if
(
!
options
.
hasOwnProperty
(
optionName
)
)
continue
;
options
(
optionName
)
;
}
}
catch
(
ex
)
{
print
(
'
optionsReset
:
caught
'
+
ex
)
;
}
}
if
(
typeof
options
=
=
'
function
'
)
{
optionsInit
(
)
;
optionsClear
(
)
;
}
