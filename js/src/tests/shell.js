(
function
(
global
)
{
var
undefined
;
var
Error
=
global
.
Error
;
var
Number
=
global
.
Number
;
var
TypeError
=
global
.
TypeError
;
var
ArrayIsArray
=
global
.
Array
.
isArray
;
var
ObjectCreate
=
global
.
Object
.
create
;
var
ObjectDefineProperty
=
global
.
Object
.
defineProperty
;
var
ReflectApply
=
global
.
Reflect
.
apply
;
var
StringPrototypeEndsWith
=
global
.
String
.
prototype
.
endsWith
;
function
ArrayPop
(
arr
)
{
assertEq
(
ArrayIsArray
(
arr
)
true
"
ArrayPop
must
only
be
used
on
actual
arrays
"
)
;
var
len
=
arr
.
length
;
if
(
len
=
=
=
0
)
return
undefined
;
var
v
=
arr
[
len
-
1
]
;
arr
.
length
-
-
;
return
v
;
}
function
ArrayPush
(
arr
val
)
{
assertEq
(
ArrayIsArray
(
arr
)
true
"
ArrayPush
must
only
be
used
on
actual
arrays
"
)
;
var
desc
=
ObjectCreate
(
null
)
;
desc
.
value
=
val
;
desc
.
enumerable
=
true
;
desc
.
configurable
=
true
;
desc
.
writable
=
true
;
ObjectDefineProperty
(
arr
arr
.
length
desc
)
;
}
function
StringEndsWith
(
str
needle
)
{
return
ReflectApply
(
StringPrototypeEndsWith
str
[
needle
]
)
;
}
function
SameValue
(
v1
v2
)
{
if
(
v1
=
=
=
0
&
&
v2
=
=
=
0
)
return
1
/
v1
=
=
=
1
/
v2
;
if
(
v1
!
=
=
v1
&
&
v2
!
=
=
v2
)
return
true
;
return
v1
=
=
=
v2
;
}
var
assertEq
=
global
.
assertEq
;
if
(
typeof
assertEq
!
=
=
"
function
"
)
{
assertEq
=
function
assertEq
(
actual
expected
message
)
{
if
(
!
SameValue
(
actual
expected
)
)
{
throw
new
TypeError
(
'
Assertion
failed
:
got
"
'
+
actual
+
'
"
'
+
'
expected
"
'
+
expected
+
(
message
?
"
:
"
+
message
:
"
"
)
)
;
}
}
;
global
.
assertEq
=
assertEq
;
}
function
assertEqArray
(
actual
expected
)
{
var
len
=
actual
.
length
;
assertEq
(
len
expected
.
length
"
mismatching
array
lengths
"
)
;
var
i
=
0
;
try
{
for
(
;
i
<
len
;
i
+
+
)
assertEq
(
actual
[
i
]
expected
[
i
]
"
mismatch
at
element
"
+
i
)
;
}
catch
(
e
)
{
throw
new
Error
(
"
Exception
thrown
at
index
"
+
i
+
"
:
"
+
e
)
;
}
}
global
.
assertEqArray
=
assertEqArray
;
function
assertThrows
(
f
)
{
var
ok
=
false
;
try
{
f
(
)
;
}
catch
(
exc
)
{
ok
=
true
;
}
if
(
!
ok
)
throw
new
Error
(
"
Assertion
failed
:
"
+
f
+
"
did
not
throw
as
expected
"
)
;
}
global
.
assertThrows
=
assertThrows
;
function
assertThrowsInstanceOf
(
f
ctor
msg
)
{
var
fullmsg
;
try
{
f
(
)
;
}
catch
(
exc
)
{
if
(
exc
instanceof
ctor
)
return
;
fullmsg
=
"
Assertion
failed
:
expected
exception
"
+
ctor
.
name
+
"
got
"
+
exc
;
}
if
(
fullmsg
=
=
=
undefined
)
{
fullmsg
=
"
Assertion
failed
:
expected
exception
"
+
ctor
.
name
+
"
"
+
"
no
exception
thrown
"
;
}
if
(
msg
!
=
=
undefined
)
fullmsg
+
=
"
-
"
+
msg
;
throw
new
Error
(
fullmsg
)
;
}
global
.
assertThrowsInstanceOf
=
assertThrowsInstanceOf
;
assertEq
(
typeof
global
.
print
"
function
"
"
print
function
is
pre
-
existing
either
provided
by
the
shell
or
"
+
"
the
already
-
executed
top
-
level
browser
.
js
"
)
;
global
.
SECTION
=
"
"
;
global
.
VERSION
=
"
"
;
global
.
BUGNUMBER
=
"
"
;
function
startTest
(
)
{
if
(
global
.
BUGNUMBER
)
global
.
print
(
"
BUGNUMBER
:
"
+
global
.
BUGNUMBER
)
;
}
global
.
startTest
=
startTest
;
var
callStack
=
[
]
;
function
enterFunc
(
funcName
)
{
assertEq
(
typeof
funcName
"
string
"
"
enterFunc
must
be
given
a
string
funcName
"
)
;
if
(
!
StringEndsWith
(
funcName
"
(
)
"
)
)
funcName
+
=
"
(
)
"
;
ArrayPush
(
callStack
funcName
)
;
}
global
.
enterFunc
=
enterFunc
;
function
exitFunc
(
funcName
)
{
assertEq
(
typeof
funcName
=
=
=
"
string
"
|
|
typeof
funcName
=
=
=
"
undefined
"
true
"
exitFunc
must
be
given
no
arguments
or
a
string
"
)
;
var
lastFunc
=
ArrayPop
(
callStack
)
;
assertEq
(
typeof
lastFunc
"
string
"
"
exitFunc
called
too
many
times
"
)
;
if
(
funcName
)
{
if
(
!
StringEndsWith
(
funcName
"
(
)
"
)
)
funcName
+
=
"
(
)
"
;
if
(
lastFunc
!
=
=
funcName
)
{
global
.
reportCompare
(
funcName
lastFunc
"
Test
driver
failure
wrong
exit
function
"
)
;
}
}
}
global
.
exitFunc
=
exitFunc
;
function
currentFunc
(
)
{
assertEq
(
callStack
.
length
>
0
true
"
must
be
a
current
function
to
examine
"
)
;
return
callStack
[
callStack
.
length
-
1
]
;
}
global
.
currentFunc
=
currentFunc
;
function
inRhino
(
)
{
return
typeof
global
.
defineClass
=
=
=
"
function
"
;
}
global
.
inRhino
=
inRhino
;
function
GetContext
(
)
{
return
global
.
Packages
.
com
.
netscape
.
javascript
.
Context
.
getCurrentContext
(
)
;
}
global
.
GetContext
=
GetContext
;
function
OptLevel
(
i
)
{
i
=
Number
(
i
)
;
var
cx
=
GetContext
(
)
;
cx
.
setOptimizationLevel
(
i
)
;
}
global
.
OptLevel
=
OptLevel
;
}
)
(
this
)
;
var
STATUS
=
"
STATUS
:
"
;
var
VERBOSE
=
false
;
var
SECT_PREFIX
=
'
Section
'
;
var
SECT_SUFFIX
=
'
of
test
-
'
;
var
gDelayTestDriverEnd
=
false
;
var
gTestcases
=
new
Array
(
)
;
var
gTc
=
gTestcases
.
length
;
var
summary
=
'
'
;
var
description
=
'
'
;
var
expected
=
'
'
;
var
actual
=
'
'
;
var
msg
=
'
'
;
var
GLOBAL
=
this
+
'
'
;
var
PASSED
=
"
PASSED
!
"
;
var
FAILED
=
"
FAILED
!
"
;
var
DEBUG
=
false
;
var
DESCRIPTION
;
var
EXPECTED
;
function
testPassesUnlessItThrows
(
)
{
print
(
PASSED
)
;
}
function
AddTestCase
(
description
expect
actual
)
{
new
TestCase
(
SECTION
description
expect
actual
)
;
}
function
TestCase
(
n
d
e
a
)
{
this
.
name
=
n
;
this
.
description
=
d
;
this
.
expect
=
e
;
this
.
actual
=
a
;
this
.
passed
=
getTestCaseResult
(
e
a
)
;
this
.
reason
=
'
'
;
this
.
bugnumber
=
typeof
(
BUGNUMER
)
!
=
'
undefined
'
?
BUGNUMBER
:
'
'
;
this
.
type
=
(
typeof
window
=
=
'
undefined
'
?
'
shell
'
:
'
browser
'
)
;
(
{
}
)
.
constructor
.
defineProperty
(
gTestcases
gTc
+
+
{
value
:
this
enumerable
:
true
configurable
:
true
writable
:
true
}
)
;
}
gFailureExpected
=
false
;
TestCase
.
prototype
.
dump
=
function
(
)
{
if
(
typeof
document
!
=
"
object
"
|
|
!
document
.
location
.
href
.
match
(
/
jsreftest
.
html
/
)
)
{
dump
(
'
\
njstest
:
'
+
this
.
path
+
'
'
+
'
bug
:
'
+
this
.
bugnumber
+
'
'
+
'
result
:
'
+
(
this
.
passed
?
'
PASSED
'
:
'
FAILED
'
)
+
'
'
+
'
type
:
'
+
this
.
type
+
'
'
+
'
description
:
'
+
toPrinted
(
this
.
description
)
+
'
'
+
'
reason
:
'
+
toPrinted
(
this
.
reason
)
+
'
\
n
'
)
;
}
}
;
TestCase
.
prototype
.
testPassed
=
(
function
TestCase_testPassed
(
)
{
return
this
.
passed
;
}
)
;
TestCase
.
prototype
.
testFailed
=
(
function
TestCase_testFailed
(
)
{
return
!
this
.
passed
;
}
)
;
TestCase
.
prototype
.
testDescription
=
(
function
TestCase_testDescription
(
)
{
return
this
.
description
+
'
'
+
this
.
reason
;
}
)
;
function
getTestCases
(
)
{
return
gTestcases
;
}
function
expectExitCode
(
n
)
{
print
(
'
-
-
-
NOTE
:
IN
THIS
TESTCASE
WE
EXPECT
EXIT
CODE
'
+
n
+
'
-
-
-
'
)
;
}
function
inSection
(
x
)
{
return
SECT_PREFIX
+
x
+
SECT_SUFFIX
;
}
function
reportFailure
(
msg
)
{
var
lines
=
msg
.
split
(
"
\
n
"
)
;
var
l
;
var
funcName
=
currentFunc
(
)
;
var
prefix
=
(
funcName
)
?
"
[
reported
from
"
+
funcName
+
"
]
"
:
"
"
;
for
(
var
i
=
0
;
i
<
lines
.
length
;
i
+
+
)
print
(
FAILED
+
prefix
+
lines
[
i
]
)
;
}
function
printStatus
(
msg
)
{
msg
=
msg
.
toString
(
)
;
var
lines
=
msg
.
split
(
"
\
n
"
)
;
var
l
;
for
(
var
i
=
0
;
i
<
lines
.
length
;
i
+
+
)
print
(
STATUS
+
lines
[
i
]
)
;
}
function
printBugNumber
(
num
)
{
BUGNUMBER
=
num
;
print
(
'
BUGNUMBER
:
'
+
num
)
;
}
function
toPrinted
(
value
)
{
value
=
String
(
value
)
;
value
=
value
.
replace
(
/
\
\
n
/
g
'
NL
'
)
.
replace
(
/
\
n
/
g
'
NL
'
)
.
replace
(
/
\
\
r
/
g
'
CR
'
)
.
replace
(
/
[
^
\
x20
-
\
x7E
]
+
/
g
escapeString
)
;
return
value
;
}
function
escapeString
(
str
)
{
var
a
b
c
d
;
var
len
=
str
.
length
;
var
result
=
"
"
;
var
digits
=
[
"
0
"
"
1
"
"
2
"
"
3
"
"
4
"
"
5
"
"
6
"
"
7
"
"
8
"
"
9
"
"
A
"
"
B
"
"
C
"
"
D
"
"
E
"
"
F
"
]
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
ch
=
str
.
charCodeAt
(
i
)
;
a
=
digits
[
ch
&
0xf
]
;
ch
>
>
=
4
;
b
=
digits
[
ch
&
0xf
]
;
ch
>
>
=
4
;
if
(
ch
)
{
c
=
digits
[
ch
&
0xf
]
;
ch
>
>
=
4
;
d
=
digits
[
ch
&
0xf
]
;
result
+
=
"
\
\
u
"
+
d
+
c
+
b
+
a
;
}
else
{
result
+
=
"
\
\
x
"
+
b
+
a
;
}
}
return
result
;
}
function
reportCompare
(
expected
actual
description
)
{
var
expected_t
=
typeof
expected
;
var
actual_t
=
typeof
actual
;
var
output
=
"
"
;
if
(
typeof
description
=
=
"
undefined
"
)
{
description
=
'
'
;
}
else
if
(
VERBOSE
)
{
printStatus
(
"
Comparing
'
"
+
description
+
"
'
"
)
;
}
if
(
expected_t
!
=
actual_t
)
{
output
+
=
"
Type
mismatch
expected
type
"
+
expected_t
+
"
actual
type
"
+
actual_t
+
"
"
;
}
else
if
(
VERBOSE
)
{
printStatus
(
"
Expected
type
'
"
+
expected_t
+
"
'
matched
actual
"
+
"
type
'
"
+
actual_t
+
"
'
"
)
;
}
if
(
expected
!
=
actual
)
{
output
+
=
"
Expected
value
'
"
+
toPrinted
(
expected
)
+
"
'
Actual
value
'
"
+
toPrinted
(
actual
)
+
"
'
"
;
}
else
if
(
VERBOSE
)
{
printStatus
(
"
Expected
value
'
"
+
toPrinted
(
expected
)
+
"
'
matched
actual
value
'
"
+
toPrinted
(
actual
)
+
"
'
"
)
;
}
var
testcase
=
new
TestCase
(
"
unknown
-
test
-
name
"
description
expected
actual
)
;
testcase
.
reason
=
output
;
if
(
typeof
document
!
=
"
object
"
|
|
!
document
.
location
.
href
.
match
(
/
jsreftest
.
html
/
)
)
{
if
(
testcase
.
passed
)
{
print
(
PASSED
+
description
)
;
}
else
{
reportFailure
(
description
+
"
:
"
+
output
)
;
}
}
return
testcase
.
passed
;
}
function
reportMatch
(
expectedRegExp
actual
description
)
{
var
expected_t
=
"
string
"
;
var
actual_t
=
typeof
actual
;
var
output
=
"
"
;
if
(
typeof
description
=
=
"
undefined
"
)
{
description
=
'
'
;
}
else
if
(
VERBOSE
)
{
printStatus
(
"
Comparing
'
"
+
description
+
"
'
"
)
;
}
if
(
expected_t
!
=
actual_t
)
{
output
+
=
"
Type
mismatch
expected
type
"
+
expected_t
+
"
actual
type
"
+
actual_t
+
"
"
;
}
else
if
(
VERBOSE
)
{
printStatus
(
"
Expected
type
'
"
+
expected_t
+
"
'
matched
actual
"
+
"
type
'
"
+
actual_t
+
"
'
"
)
;
}
var
matches
=
expectedRegExp
.
test
(
actual
)
;
if
(
!
matches
)
{
output
+
=
"
Expected
match
to
'
"
+
toPrinted
(
expectedRegExp
)
+
"
'
Actual
value
'
"
+
toPrinted
(
actual
)
+
"
'
"
;
}
else
if
(
VERBOSE
)
{
printStatus
(
"
Expected
match
to
'
"
+
toPrinted
(
expectedRegExp
)
+
"
'
matched
actual
value
'
"
+
toPrinted
(
actual
)
+
"
'
"
)
;
}
var
testcase
=
new
TestCase
(
"
unknown
-
test
-
name
"
description
true
matches
)
;
testcase
.
reason
=
output
;
if
(
typeof
document
!
=
"
object
"
|
|
!
document
.
location
.
href
.
match
(
/
jsreftest
.
html
/
)
)
{
if
(
testcase
.
passed
)
{
print
(
PASSED
+
description
)
;
}
else
{
reportFailure
(
description
+
"
:
"
+
output
)
;
}
}
return
testcase
.
passed
;
}
function
*
XorShiftGenerator
(
seed
size
)
{
let
x
=
seed
;
for
(
let
i
=
0
;
i
<
size
;
i
+
+
)
{
x
^
=
x
>
>
12
;
x
^
=
x
<
<
25
;
x
^
=
x
>
>
27
;
yield
x
%
256
;
}
}
function
compareSource
(
expect
actual
summary
)
{
var
expectP
=
expect
.
replace
(
/
(
[
(
)
{
}
.
:
\
[
\
]
]
)
/
mg
'
1
'
)
.
replace
(
/
(
\
w
+
)
/
mg
'
1
'
)
.
replace
(
/
<
(
\
/
)
?
(
\
w
+
)
(
\
/
)
?
>
/
mg
'
<
1
2
3
>
'
)
.
replace
(
/
\
s
+
/
mg
'
'
)
.
replace
(
/
new
(
\
w
+
)
\
s
*
\
(
\
s
*
\
)
/
mg
'
new
1
'
)
;
var
actualP
=
actual
.
replace
(
/
(
[
(
)
{
}
.
:
\
[
\
]
]
)
/
mg
'
1
'
)
.
replace
(
/
(
\
w
+
)
/
mg
'
1
'
)
.
replace
(
/
<
(
\
/
)
?
(
\
w
+
)
(
\
/
)
?
>
/
mg
'
<
1
2
3
>
'
)
.
replace
(
/
\
s
+
/
mg
'
'
)
.
replace
(
/
new
(
\
w
+
)
\
s
*
\
(
\
s
*
\
)
/
mg
'
new
1
'
)
;
print
(
'
expect
:
\
n
'
+
expectP
)
;
print
(
'
actual
:
\
n
'
+
actualP
)
;
reportCompare
(
expectP
actualP
summary
)
;
try
{
var
expectCompile
=
'
No
Error
'
;
var
actualCompile
;
eval
(
expect
)
;
try
{
eval
(
actual
)
;
actualCompile
=
'
No
Error
'
;
}
catch
(
ex1
)
{
actualCompile
=
ex1
+
'
'
;
}
reportCompare
(
expectCompile
actualCompile
summary
+
'
:
compile
actual
'
)
;
}
catch
(
ex
)
{
}
}
function
optionsInit
(
)
{
options
.
initvalues
=
{
}
;
options
.
stackvalues
=
[
]
;
var
optionNames
=
options
(
)
.
split
(
'
'
)
;
for
(
var
i
=
0
;
i
<
optionNames
.
length
;
i
+
+
)
{
var
optionName
=
optionNames
[
i
]
;
if
(
optionName
)
{
options
.
initvalues
[
optionName
]
=
'
'
;
}
}
}
function
optionsClear
(
)
{
var
optionNames
=
options
(
)
.
split
(
'
'
)
;
for
(
var
i
=
0
;
i
<
optionNames
.
length
;
i
+
+
)
{
var
optionName
=
optionNames
[
i
]
;
if
(
optionName
&
&
optionName
!
=
"
methodjit
"
&
&
optionName
!
=
"
methodjit_always
"
&
&
optionName
!
=
"
ion
"
)
{
options
(
optionName
)
;
}
}
}
function
optionsPush
(
)
{
var
optionsframe
=
{
}
;
options
.
stackvalues
.
push
(
optionsframe
)
;
var
optionNames
=
options
(
)
.
split
(
'
'
)
;
for
(
var
i
=
0
;
i
<
optionNames
.
length
;
i
+
+
)
{
var
optionName
=
optionNames
[
i
]
;
if
(
optionName
)
{
optionsframe
[
optionName
]
=
'
'
;
}
}
optionsClear
(
)
;
}
function
optionsPop
(
)
{
var
optionsframe
=
options
.
stackvalues
.
pop
(
)
;
optionsClear
(
)
;
for
(
optionName
in
optionsframe
)
{
options
(
optionName
)
;
}
}
function
optionsReset
(
)
{
try
{
optionsClear
(
)
;
for
(
var
optionName
in
options
.
initvalues
)
{
if
(
!
options
.
hasOwnProperty
(
optionName
)
)
continue
;
options
(
optionName
)
;
}
}
catch
(
ex
)
{
print
(
'
optionsReset
:
caught
'
+
ex
)
;
}
}
if
(
typeof
options
=
=
'
function
'
)
{
optionsInit
(
)
;
optionsClear
(
)
;
}
function
getTestCaseResult
(
expected
actual
)
{
if
(
typeof
expected
!
=
typeof
actual
)
return
false
;
if
(
typeof
expected
!
=
'
number
'
)
return
actual
=
=
expected
;
if
(
actual
!
=
actual
)
return
expected
!
=
expected
;
if
(
expected
!
=
expected
)
return
false
;
if
(
actual
!
=
expected
)
return
Math
.
abs
(
actual
-
expected
)
<
=
1E
-
10
;
return
true
;
}
if
(
typeof
dump
=
=
'
undefined
'
)
{
if
(
typeof
window
=
=
'
undefined
'
&
&
typeof
print
=
=
'
function
'
)
{
dump
=
print
;
}
else
{
dump
=
(
function
(
)
{
}
)
;
}
}
function
test
(
)
{
for
(
gTc
=
0
;
gTc
<
gTestcases
.
length
;
gTc
+
+
)
{
try
{
gTestcases
[
gTc
]
.
passed
=
writeTestCaseResult
(
gTestcases
[
gTc
]
.
expect
gTestcases
[
gTc
]
.
actual
gTestcases
[
gTc
]
.
description
+
"
=
"
+
gTestcases
[
gTc
]
.
actual
)
;
gTestcases
[
gTc
]
.
reason
+
=
(
gTestcases
[
gTc
]
.
passed
)
?
"
"
:
"
wrong
value
"
;
}
catch
(
e
)
{
print
(
'
test
(
)
:
empty
testcase
for
gTc
=
'
+
gTc
+
'
'
+
e
)
;
}
}
stopTest
(
)
;
return
(
gTestcases
)
;
}
function
writeTestCaseResult
(
expect
actual
string
)
{
var
passed
=
getTestCaseResult
(
expect
actual
)
;
if
(
typeof
document
!
=
"
object
"
|
|
!
document
.
location
.
href
.
match
(
/
jsreftest
.
html
/
)
)
{
writeFormattedResult
(
expect
actual
string
passed
)
;
}
return
passed
;
}
function
writeFormattedResult
(
expect
actual
string
passed
)
{
var
s
=
(
passed
?
PASSED
:
FAILED
)
+
string
+
'
expected
:
'
+
expect
;
print
(
s
)
;
return
passed
;
}
function
writeHeaderToLog
(
string
)
{
print
(
string
)
;
}
function
stopTest
(
)
{
var
gc
;
if
(
gc
!
=
undefined
)
{
gc
(
)
;
}
}
function
jsTestDriverEnd
(
)
{
if
(
gDelayTestDriverEnd
)
{
return
;
}
try
{
optionsReset
(
)
;
}
catch
(
ex
)
{
dump
(
'
jsTestDriverEnd
'
+
ex
)
;
}
for
(
var
i
=
0
;
i
<
gTestcases
.
length
;
i
+
+
)
{
gTestcases
[
i
]
.
dump
(
)
;
}
}
