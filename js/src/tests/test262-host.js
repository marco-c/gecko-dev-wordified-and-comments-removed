;
(
function
createHostObject
(
global
)
{
var
FunctionToString
=
global
.
Function
.
prototype
.
toString
;
var
ReflectApply
=
global
.
Reflect
.
apply
;
var
NewGlobal
=
global
.
newGlobal
;
var
Atomics
=
global
.
Atomics
;
var
SharedArrayBuffer
=
global
.
SharedArrayBuffer
;
var
Int32Array
=
global
.
Int32Array
;
var
setSharedArrayBuffer
=
global
.
setSharedArrayBuffer
;
var
getSharedArrayBuffer
=
global
.
getSharedArrayBuffer
;
var
evalInWorker
=
global
.
evalInWorker
;
var
monotonicNow
=
global
.
monotonicNow
;
var
hasCreateIsHTMLDDA
=
"
createIsHTMLDDA
"
in
global
;
var
hasThreads
=
(
"
helperThreadCount
"
in
global
?
global
.
helperThreadCount
(
)
>
0
:
true
)
;
var
hasMailbox
=
typeof
setSharedArrayBuffer
=
=
"
function
"
&
&
typeof
getSharedArrayBuffer
=
=
"
function
"
;
var
hasEvalInWorker
=
typeof
evalInWorker
=
=
"
function
"
;
if
(
!
hasCreateIsHTMLDDA
&
&
!
(
"
document
"
in
global
&
&
"
all
"
in
global
.
document
)
)
throw
new
Error
(
"
no
[
[
IsHTMLDDA
]
]
object
available
for
testing
"
)
;
var
IsHTMLDDA
=
hasCreateIsHTMLDDA
?
global
.
createIsHTMLDDA
(
)
:
global
.
document
.
all
;
var
shellCode
=
hasMailbox
&
&
hasEvalInWorker
;
var
sabTestable
=
Atomics
&
&
SharedArrayBuffer
&
&
hasThreads
&
&
shellCode
;
global
.
262
=
{
__proto__
:
null
createRealm
(
)
{
var
newGlobalObject
=
NewGlobal
(
)
;
var
createHostObjectFn
=
ReflectApply
(
FunctionToString
createHostObject
[
]
)
;
newGlobalObject
.
Function
(
{
createHostObjectFn
}
createHostObject
(
this
)
;
)
(
)
;
return
newGlobalObject
.
262
;
}
detachArrayBuffer
:
global
.
detachArrayBuffer
evalScript
:
global
.
evaluateScript
|
|
global
.
evaluate
global
IsHTMLDDA
agent
:
(
function
(
)
{
if
(
!
sabTestable
)
{
return
{
_notAvailable
(
)
{
if
(
!
hasThreads
&
&
shellCode
)
{
global
.
reportCompare
(
0
0
)
;
global
.
quit
(
0
)
;
}
throw
new
Error
(
"
Agents
not
available
"
)
;
}
start
(
script
)
{
this
.
_notAvailable
(
)
}
broadcast
(
sab
id
)
{
this
.
_notAvailable
(
)
}
getReport
(
)
{
this
.
_notAvailable
(
)
}
sleep
(
s
)
{
this
.
_notAvailable
(
)
}
}
}
var
_MSG_LOC
=
0
;
var
_ID_LOC
=
1
;
var
_ACK_LOC
=
2
;
var
_RDY_LOC
=
3
;
var
_LOCKTXT_LOC
=
4
;
var
_NUMTXT_LOC
=
5
;
var
_NEXT_LOC
=
6
;
var
_SLEEP_LOC
=
7
;
var
_FIRST
=
10
;
var
_ia
=
new
Int32Array
(
new
SharedArrayBuffer
(
65536
)
)
;
_ia
[
_NEXT_LOC
]
=
_FIRST
;
var
_worker_prefix
=
if
(
typeof
262
=
=
'
undefined
'
)
262
=
{
}
;
262
.
agent
=
(
function
(
)
{
var
_ia
=
new
Int32Array
(
getSharedArrayBuffer
(
)
)
;
var
agent
=
{
receiveBroadcast
(
receiver
)
{
var
k
;
while
(
(
(
k
=
Atomics
.
load
(
_ia
{
_MSG_LOC
}
)
)
&
1
)
=
=
0
)
;
var
received_sab
=
getSharedArrayBuffer
(
)
;
var
received_id
=
Atomics
.
load
(
_ia
{
_ID_LOC
}
)
;
Atomics
.
add
(
_ia
{
_ACK_LOC
}
1
)
;
while
(
Atomics
.
load
(
_ia
{
_MSG_LOC
}
)
=
=
k
)
;
receiver
(
received_sab
received_id
)
;
}
report
(
msg
)
{
while
(
Atomics
.
compareExchange
(
_ia
{
_LOCKTXT_LOC
}
0
1
)
=
=
1
)
;
msg
=
"
"
+
msg
;
var
i
=
_ia
[
{
_NEXT_LOC
}
]
;
_ia
[
i
+
+
]
=
msg
.
length
;
for
(
let
j
=
0
;
j
<
msg
.
length
;
j
+
+
)
_ia
[
i
+
+
]
=
msg
.
charCodeAt
(
j
)
;
_ia
[
{
_NEXT_LOC
}
]
=
i
;
Atomics
.
add
(
_ia
{
_NUMTXT_LOC
}
1
)
;
Atomics
.
store
(
_ia
{
_LOCKTXT_LOC
}
0
)
;
}
sleep
(
s
)
{
Atomics
.
wait
(
_ia
{
_SLEEP_LOC
}
0
s
)
;
}
leaving
(
)
{
}
monotonicNow
}
;
Atomics
.
add
(
_ia
{
_RDY_LOC
}
1
)
;
return
agent
;
}
)
(
)
;
;
return
{
_numWorkers
:
0
_numReports
:
0
_reportPtr
:
_FIRST
_bailIfNotAvailable
(
)
{
if
(
!
sabTestable
)
{
if
(
!
hasThreads
&
&
shellCode
)
{
global
.
reportCompare
(
0
0
)
;
global
.
quit
(
0
)
;
}
throw
new
Error
(
"
Agents
not
available
"
)
;
}
}
start
(
script
)
{
this
.
_bailIfNotAvailable
(
)
;
setSharedArrayBuffer
(
_ia
.
buffer
)
;
var
oldrdy
=
Atomics
.
load
(
_ia
_RDY_LOC
)
;
evalInWorker
(
_worker_prefix
+
script
)
;
while
(
Atomics
.
load
(
_ia
_RDY_LOC
)
=
=
oldrdy
)
;
this
.
_numWorkers
+
+
;
}
broadcast
(
sab
id
)
{
this
.
_bailIfNotAvailable
(
)
;
setSharedArrayBuffer
(
sab
)
;
Atomics
.
store
(
_ia
_ID_LOC
id
)
;
Atomics
.
store
(
_ia
_ACK_LOC
0
)
;
Atomics
.
add
(
_ia
_MSG_LOC
1
)
;
while
(
Atomics
.
load
(
_ia
_ACK_LOC
)
<
this
.
_numWorkers
)
;
Atomics
.
add
(
_ia
_MSG_LOC
1
)
;
}
getReport
(
)
{
this
.
_bailIfNotAvailable
(
)
;
if
(
this
.
_numReports
=
=
Atomics
.
load
(
_ia
_NUMTXT_LOC
)
)
return
null
;
var
s
=
"
"
;
var
i
=
this
.
_reportPtr
;
var
len
=
_ia
[
i
+
+
]
;
for
(
let
j
=
0
;
j
<
len
;
j
+
+
)
s
+
=
String
.
fromCharCode
(
_ia
[
i
+
+
]
)
;
this
.
_reportPtr
=
i
;
this
.
_numReports
+
+
;
return
s
;
}
sleep
(
s
)
{
this
.
_bailIfNotAvailable
(
)
;
Atomics
.
wait
(
_ia
_SLEEP_LOC
0
s
)
;
}
monotonicNow
}
;
}
)
(
)
}
;
}
)
(
this
)
;
var
mozAsyncTestDone
=
false
;
function
DONE
(
failure
)
{
if
(
mozAsyncTestDone
)
{
reportFailure
(
"
DONE
(
)
already
called
"
)
;
return
;
}
mozAsyncTestDone
=
true
;
if
(
failure
)
reportFailure
(
failure
)
;
else
reportCompare
(
0
0
)
;
}
