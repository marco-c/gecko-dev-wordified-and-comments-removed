var
ctorPromise
;
function
hasProp
(
obj
name
expected
msg
)
{
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
name
)
;
assert
.
sameValue
(
hasOwnProperty
expected
msg
)
;
var
hasProperty
=
Reflect
.
has
(
obj
name
)
;
assert
.
sameValue
(
hasProperty
expected
msg
)
;
}
class
C
{
async
*
#
m
(
)
{
return
42
;
}
get
ref
(
)
{
return
this
.
#
m
;
}
constructor
(
)
{
hasProp
(
this
'
#
m
'
false
'
private
methods
are
defined
in
an
special
internal
slot
and
cannot
be
found
as
own
properties
'
)
;
assert
.
sameValue
(
typeof
this
.
#
m
'
function
'
)
;
assert
.
sameValue
(
this
.
ref
this
.
#
m
'
returns
the
same
value
'
)
;
assert
.
sameValue
(
this
.
#
m
(
(
)
=
>
this
)
(
)
.
#
m
'
memberexpression
and
call
expression
forms
'
)
;
var
ctorIter
=
this
.
#
m
(
)
;
var
p
=
ctorIter
.
next
(
)
;
ctorPromise
=
p
.
then
(
(
{
value
done
}
)
=
>
{
assert
.
sameValue
(
value
42
'
return
from
generator
method
inside
ctor
'
)
;
assert
.
sameValue
(
done
true
'
iterator
is
done
inside
ctor
'
)
;
}
DONE
)
;
assert
.
sameValue
(
this
.
#
m
.
name
'
#
m
'
'
function
name
inside
constructor
'
)
;
}
}
var
c
=
new
C
(
)
;
var
other
=
new
C
(
)
;
hasProp
(
C
.
prototype
'
#
m
'
false
'
method
is
not
defined
in
the
prototype
'
)
;
hasProp
(
C
'
#
m
'
false
'
method
is
not
defined
in
the
contructor
'
)
;
hasProp
(
c
'
#
m
'
false
'
method
cannot
be
seen
outside
of
the
class
'
)
;
assert
.
sameValue
(
c
.
ref
other
.
ref
'
The
method
is
defined
once
and
reused
on
every
new
instance
'
)
;
assert
.
sameValue
(
c
.
ref
.
name
'
#
m
'
'
function
name
is
preserved
external
reference
'
)
;
ctorPromise
.
then
(
(
)
=
>
{
var
iter
=
c
.
ref
(
)
;
return
iter
.
next
(
)
.
then
(
(
{
value
done
}
)
=
>
{
assert
.
sameValue
(
value
42
'
return
from
generator
method
'
)
;
assert
.
sameValue
(
done
true
'
iterator
is
done
'
)
;
}
)
;
}
)
.
then
(
DONE
DONE
)
;
