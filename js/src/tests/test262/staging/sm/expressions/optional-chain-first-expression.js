const
expressions
=
[
"
this
"
"
ident
"
"
null
"
"
true
"
"
false
"
"
123
"
"
123n
"
"
'
str
'
"
"
[
]
"
"
{
}
"
"
function
(
)
{
}
"
"
class
{
}
"
"
function
*
(
)
{
}
"
"
async
function
(
)
{
}
"
"
async
function
*
(
)
{
}
"
"
/
a
/
"
"
str
"
"
(
a
+
b
)
"
"
a
[
b
]
"
"
a
.
b
"
"
a
"
"
super
[
a
]
"
"
super
.
a
"
"
new
.
target
"
"
import
.
meta
"
"
new
C
(
)
"
"
new
C
"
"
f
(
)
"
"
super
(
)
"
"
a
?
.
b
"
"
a
?
.
[
b
]
"
"
a
?
.
(
)
"
"
a
?
.
"
]
;
function
tryParse
(
s
f
=
Function
)
{
try
{
f
(
s
)
;
}
catch
{
}
}
function
tryRun
(
s
f
=
Function
)
{
try
{
f
(
s
)
(
)
;
}
catch
{
}
}
for
(
let
expr
of
expressions
)
{
tryRun
(
void
(
{
expr
}
?
.
(
)
)
;
)
;
tryRun
(
void
(
{
expr
}
?
.
p
(
)
)
;
)
;
tryRun
(
void
(
(
{
expr
}
)
?
.
(
)
)
;
)
;
tryRun
(
void
(
(
{
expr
}
)
?
.
p
(
)
)
;
)
;
}
function
inClassConstructor
(
s
)
{
return
class
C
{
constructor
(
)
{
{
s
}
}
}
;
}
for
(
let
expr
of
[
"
super
[
a
]
"
"
super
.
a
"
"
super
(
)
"
]
)
{
tryRun
(
inClassConstructor
(
void
(
{
expr
}
?
.
(
)
)
;
)
)
;
tryRun
(
inClassConstructor
(
void
(
{
expr
}
?
.
p
(
)
)
;
)
)
;
tryRun
(
inClassConstructor
(
void
(
(
{
expr
}
)
?
.
(
)
)
;
)
)
;
tryRun
(
inClassConstructor
(
void
(
(
{
expr
}
)
?
.
p
(
)
)
;
)
)
;
}
if
(
typeof
parseModule
=
=
=
"
function
"
)
{
const
expressions
=
[
"
import
.
meta
"
"
import
(
'
'
)
"
]
;
for
(
let
expr
of
expressions
)
{
tryParse
(
void
(
{
expr
}
?
.
(
)
)
;
parseModule
)
;
tryParse
(
void
(
{
expr
}
?
.
p
(
)
)
;
parseModule
)
;
tryParse
(
void
(
(
{
expr
}
)
?
.
(
)
)
;
parseModule
)
;
tryParse
(
void
(
(
{
expr
}
)
?
.
p
(
)
)
;
parseModule
)
;
}
}
reportCompare
(
0
0
)
;
