function
syntaxError
(
script
)
{
assert
.
throws
(
SyntaxError
function
(
)
{
Function
(
script
)
;
}
)
;
}
syntaxError
(
"
{
*
a
(
)
{
}
}
"
)
;
syntaxError
(
"
b
=
{
*
(
)
{
}
"
)
;
syntaxError
(
"
b
=
{
*
{
}
"
)
;
syntaxError
(
"
b
=
{
*
)
{
}
"
)
;
syntaxError
(
"
b
=
{
*
(
{
}
"
)
;
syntaxError
(
"
b
=
{
*
(
)
{
"
)
;
syntaxError
(
"
b
=
{
*
(
)
}
"
)
;
syntaxError
(
"
b
=
{
*
a
(
"
)
;
syntaxError
(
"
b
=
{
*
a
)
"
)
;
syntaxError
(
"
b
=
{
*
a
(
}
"
)
;
syntaxError
(
"
b
=
{
*
a
)
}
"
)
;
syntaxError
(
"
b
=
{
*
a
(
)
"
)
;
syntaxError
(
"
b
=
{
*
a
(
)
}
"
)
;
syntaxError
(
"
b
=
{
*
a
(
)
{
}
"
)
;
syntaxError
(
"
b
=
{
*
a
)
{
}
"
)
;
syntaxError
(
"
b
=
{
*
a
}
}
"
)
;
syntaxError
(
"
b
=
{
*
a
{
}
}
"
)
;
syntaxError
(
"
b
=
{
*
a
(
{
}
}
"
)
;
syntaxError
(
"
b
=
{
*
a
(
)
{
}
}
"
)
;
syntaxError
(
"
b
=
{
*
(
)
{
}
}
"
)
;
syntaxError
(
"
b
=
{
*
get
a
(
)
{
}
}
"
)
;
syntaxError
(
"
b
=
{
get
*
a
(
)
{
}
}
"
)
;
syntaxError
(
"
b
=
{
get
a
*
(
)
{
}
}
"
)
;
syntaxError
(
"
b
=
{
*
set
a
(
c
)
{
}
}
"
)
;
syntaxError
(
"
b
=
{
set
*
a
(
c
)
{
}
}
"
)
;
syntaxError
(
"
b
=
{
set
a
*
(
c
)
{
}
}
"
)
;
syntaxError
(
"
b
=
{
*
a
:
1
}
"
)
;
syntaxError
(
"
b
=
{
a
*
:
1
}
"
)
;
syntaxError
(
"
b
=
{
a
:
*
1
}
"
)
;
syntaxError
(
"
b
=
{
a
*
(
)
{
}
}
"
)
;
var
b
=
{
*
g
(
)
{
var
a
=
{
[
yield
1
]
:
2
[
yield
2
]
:
3
}
;
return
a
;
}
}
var
it
=
b
.
g
(
)
;
var
next
=
it
.
next
(
)
;
assert
.
sameValue
(
next
.
done
false
)
;
assert
.
sameValue
(
next
.
value
1
)
;
next
=
it
.
next
(
"
hello
"
)
;
assert
.
sameValue
(
next
.
done
false
)
;
assert
.
sameValue
(
next
.
value
2
)
;
next
=
it
.
next
(
"
world
"
)
;
assert
.
sameValue
(
next
.
done
true
)
;
assert
.
sameValue
(
next
.
value
.
hello
2
)
;
assert
.
sameValue
(
next
.
value
.
world
3
)
;
assert
.
sameValue
(
b
.
g
.
hasOwnProperty
(
"
prototype
"
)
true
)
;
var
a
=
{
*
b
(
c
)
{
"
use
strict
"
;
yield
c
;
}
}
;
assert
.
sameValue
(
a
.
b
(
1
)
.
next
(
)
.
value
1
)
;
a
=
{
*
[
"
b
"
]
(
c
)
{
"
use
strict
"
;
return
c
;
}
}
;
assert
.
sameValue
(
a
.
b
(
1
)
.
next
(
)
.
value
1
)
;
a
=
{
*
g
(
)
{
yield
1
;
}
}
assert
.
throws
(
TypeError
(
)
=
>
{
new
a
.
g
}
)
;
reportCompare
(
0
0
)
;
