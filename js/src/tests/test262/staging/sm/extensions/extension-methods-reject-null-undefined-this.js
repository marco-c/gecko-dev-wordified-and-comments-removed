var
BUGNUMBER
=
619283
;
var
summary
=
"
ECMAScript
built
-
in
methods
that
immediately
throw
when
|
this
|
is
"
+
"
|
undefined
|
or
|
null
|
(
due
to
CheckObjectCoercible
ToObject
or
ToString
)
"
;
print
(
BUGNUMBER
+
"
:
"
+
summary
)
;
var
ClassToMethodMap
=
{
Object
:
[
"
toSource
"
]
Function
:
[
"
toSource
"
]
Array
:
[
"
toSource
"
]
String
:
[
"
toSource
"
]
Boolean
:
[
"
toSource
"
]
Number
:
[
"
toSource
"
]
Date
:
[
"
toSource
"
]
RegExp
:
[
"
toSource
"
]
Error
:
[
"
toSource
"
]
}
;
var
badThisValues
=
[
null
undefined
]
;
function
testMethod
(
Class
className
method
)
{
var
expr
;
for
(
var
i
=
0
sz
=
badThisValues
.
length
;
i
<
sz
;
i
+
+
)
{
var
badThis
=
badThisValues
[
i
]
;
expr
=
className
+
"
.
prototype
.
"
+
method
+
"
.
call
(
"
+
badThis
+
"
)
"
;
try
{
Class
.
prototype
[
method
]
.
call
(
badThis
)
;
throw
new
Error
(
expr
+
"
didn
'
t
throw
a
TypeError
"
)
;
}
catch
(
e
)
{
assert
.
sameValue
(
e
instanceof
TypeError
true
"
wrong
error
for
"
+
expr
+
"
instead
threw
"
+
e
)
;
}
expr
=
className
+
"
.
prototype
.
"
+
method
+
"
.
apply
(
"
+
badThis
+
"
)
"
;
try
{
Class
.
prototype
[
method
]
.
apply
(
badThis
)
;
throw
new
Error
(
expr
+
"
didn
'
t
throw
a
TypeError
"
)
;
}
catch
(
e
)
{
assert
.
sameValue
(
e
instanceof
TypeError
true
"
wrong
error
for
"
+
expr
+
"
instead
threw
"
+
e
)
;
}
}
expr
=
"
(
0
"
+
className
+
"
.
prototype
.
"
+
method
+
"
)
(
)
"
try
{
(
0
Class
.
prototype
[
method
]
)
(
)
;
throw
new
Error
(
expr
+
"
didn
'
t
throw
a
TypeError
"
)
;
}
catch
(
e
)
{
assert
.
sameValue
(
e
instanceof
TypeError
true
"
wrong
error
for
"
+
expr
+
"
instead
threw
"
+
e
)
;
}
}
for
(
var
className
in
ClassToMethodMap
)
{
var
Class
=
this
[
className
]
;
var
methodNames
=
ClassToMethodMap
[
className
]
;
for
(
var
i
=
0
sz
=
methodNames
.
length
;
i
<
sz
;
i
+
+
)
{
var
method
=
methodNames
[
i
]
;
testMethod
(
Class
className
method
)
;
}
}
print
(
"
All
tests
passed
!
"
)
;
reportCompare
(
0
0
)
;
