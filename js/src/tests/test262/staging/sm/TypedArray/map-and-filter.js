for
(
var
constructor
of
anyTypedArrayConstructors
)
{
assert
.
sameValue
(
constructor
.
prototype
.
map
.
length
1
)
;
assert
.
compareArray
(
new
constructor
(
[
1
3
5
]
)
.
map
(
v
=
>
v
*
2
)
new
constructor
(
[
2
6
10
]
)
)
;
assert
.
compareArray
(
new
constructor
(
[
-
1
13
5
]
)
.
map
(
v
=
>
v
-
2
)
new
constructor
(
[
-
3
11
3
]
)
)
;
assert
.
compareArray
(
new
constructor
(
10
)
.
map
(
v
=
>
v
)
new
constructor
(
10
)
)
;
assert
.
compareArray
(
new
constructor
(
)
.
map
(
v
=
>
v
+
1
)
new
constructor
)
;
assert
.
compareArray
(
new
constructor
(
[
1
2
3
]
)
.
map
(
v
=
>
v
)
new
constructor
(
[
1
2
3
]
)
)
;
var
arr
=
new
constructor
(
[
1
2
3
4
5
]
)
;
var
sum
=
0
;
var
count
=
0
;
assert
.
compareArray
(
arr
.
map
(
(
v
k
o
)
=
>
{
count
+
+
;
sum
+
=
v
;
assert
.
sameValue
(
k
v
-
1
)
;
assert
.
sameValue
(
o
arr
)
;
return
v
;
}
)
arr
)
;
assert
.
sameValue
(
sum
15
)
;
assert
.
sameValue
(
count
5
)
;
var
changeArr
=
new
constructor
(
[
1
2
3
4
5
]
)
;
assert
.
compareArray
(
arr
.
map
(
(
v
k
)
=
>
{
changeArr
[
k
]
=
v
+
1
;
return
v
;
}
)
new
constructor
(
[
1
2
3
4
5
]
)
)
;
function
assertThisArg
(
thisArg
thisValue
)
{
assert
.
compareArray
(
arr
.
map
(
function
(
v
)
{
assert
.
deepEqual
(
this
thisValue
)
;
return
v
;
}
thisArg
)
arr
)
;
assert
.
compareArray
(
arr
.
map
(
function
(
v
)
{
"
use
strict
"
;
assert
.
deepEqual
(
this
thisArg
)
;
return
v
;
}
thisArg
)
arr
)
;
var
self
=
this
;
assert
.
compareArray
(
arr
.
map
(
(
v
)
=
>
{
assert
.
sameValue
(
this
self
)
;
return
v
;
}
thisArg
)
arr
)
;
}
assertThisArg
(
[
1
2
3
]
[
1
2
3
]
)
;
assertThisArg
(
Object
Object
)
;
assertThisArg
(
1
Object
(
1
)
)
;
assertThisArg
(
"
1
"
Object
(
"
1
"
)
)
;
assertThisArg
(
false
Object
(
false
)
)
;
assertThisArg
(
undefined
this
)
;
assertThisArg
(
null
this
)
;
var
sum
=
0
;
var
count
=
0
;
var
thrown
=
false
;
try
{
arr
.
map
(
(
v
k
o
)
=
>
{
count
+
+
;
sum
+
=
v
;
assert
.
sameValue
(
k
v
-
1
)
;
assert
.
sameValue
(
o
arr
)
;
if
(
v
=
=
=
3
)
{
throw
"
map
"
;
}
return
v
;
}
)
}
catch
(
e
)
{
assert
.
sameValue
(
e
"
map
"
)
;
thrown
=
true
;
}
assert
.
sameValue
(
thrown
true
)
;
assert
.
sameValue
(
sum
6
)
;
assert
.
sameValue
(
count
3
)
;
assertThrowsInstanceOf
(
(
)
=
>
{
arr
.
map
(
)
;
}
TypeError
)
;
var
invalidCallbacks
=
[
undefined
null
1
false
"
"
Symbol
(
)
[
]
{
}
/
.
/
]
;
invalidCallbacks
.
forEach
(
callback
=
>
{
assertThrowsInstanceOf
(
(
)
=
>
{
arr
.
map
(
callback
)
;
}
TypeError
)
;
}
)
arr
.
map
(
function
*
(
)
{
throw
"
This
line
will
not
be
executed
"
;
}
)
;
if
(
typeof
createNewGlobal
=
=
=
"
function
"
)
{
var
map
=
createNewGlobal
(
)
[
constructor
.
name
]
.
prototype
.
map
;
var
sum
=
0
;
assert
.
compareArray
(
map
.
call
(
new
constructor
(
[
1
2
3
]
)
v
=
>
sum
+
=
v
)
new
constructor
(
[
1
3
6
]
)
)
;
assert
.
sameValue
(
sum
6
)
;
}
var
invalidReceivers
=
[
undefined
null
1
false
"
"
Symbol
(
)
[
]
{
}
/
.
/
new
Proxy
(
new
constructor
(
)
{
}
)
]
;
invalidReceivers
.
forEach
(
invalidReceiver
=
>
{
assertThrowsInstanceOf
(
(
)
=
>
{
constructor
.
prototype
.
filter
.
call
(
invalidReceiver
(
)
=
>
true
)
;
}
TypeError
"
Assert
that
map
fails
if
this
value
is
not
a
TypedArray
"
)
;
}
)
;
assert
.
compareArray
(
Object
.
defineProperty
(
new
constructor
(
[
1
2
3
]
)
"
length
"
{
get
(
)
{
throw
new
Error
(
"
length
accessor
called
"
)
;
}
}
)
.
map
(
(
b
)
=
>
b
)
new
constructor
(
[
1
2
3
]
)
)
;
}
for
(
var
constructor
of
anyTypedArrayConstructors
)
{
assert
.
sameValue
(
constructor
.
prototype
.
filter
.
length
1
)
assert
.
compareArray
(
new
constructor
(
[
1
2
3
]
)
.
filter
(
x
=
>
x
=
=
x
)
new
constructor
(
[
1
2
3
]
)
)
;
assert
.
compareArray
(
new
constructor
(
[
1
2
3
4
]
)
.
filter
(
x
=
>
x
%
2
=
=
0
)
new
constructor
(
[
2
4
]
)
)
;
assert
.
compareArray
(
new
constructor
(
[
1
2
3
4
5
]
)
.
filter
(
x
=
>
x
<
4
)
new
constructor
(
[
1
2
3
]
)
)
;
assert
.
compareArray
(
new
constructor
(
)
.
filter
(
x
=
>
x
*
2
=
=
4
)
new
constructor
(
)
)
;
var
arr
=
new
constructor
(
[
1
2
3
4
5
]
)
;
var
sum
=
0
;
var
count
=
0
;
assert
.
compareArray
(
arr
.
filter
(
(
v
k
o
)
=
>
{
count
+
+
;
sum
+
=
v
;
assert
.
sameValue
(
k
v
-
1
)
;
assert
.
sameValue
(
o
arr
)
;
return
(
v
<
4
)
;
}
)
new
constructor
(
[
1
2
3
]
)
)
;
assert
.
sameValue
(
sum
15
)
;
assert
.
sameValue
(
count
5
)
;
var
changeArr
=
new
constructor
(
[
1
2
3
4
5
]
)
;
assert
.
compareArray
(
arr
.
filter
(
(
v
k
)
=
>
{
changeArr
[
k
]
=
v
+
1
;
return
true
;
}
)
new
constructor
(
[
1
2
3
4
5
]
)
)
;
function
assertThisArg
(
thisArg
thisValue
)
{
assert
.
compareArray
(
arr
.
filter
(
function
(
v
)
{
assert
.
deepEqual
(
this
thisValue
)
;
return
v
;
}
thisArg
)
arr
)
;
assert
.
compareArray
(
arr
.
filter
(
function
(
v
)
{
"
use
strict
"
;
assert
.
deepEqual
(
this
thisArg
)
;
return
v
;
}
thisArg
)
arr
)
;
var
self
=
this
;
assert
.
compareArray
(
arr
.
filter
(
(
v
)
=
>
{
assert
.
sameValue
(
this
self
)
;
return
v
;
}
thisArg
)
arr
)
;
}
assertThisArg
(
[
1
2
3
]
[
1
2
3
]
)
;
assertThisArg
(
Object
Object
)
;
assertThisArg
(
1
Object
(
1
)
)
;
assertThisArg
(
"
1
"
Object
(
"
1
"
)
)
;
assertThisArg
(
false
Object
(
false
)
)
;
assertThisArg
(
undefined
this
)
;
assertThisArg
(
null
this
)
;
var
sum
=
0
;
var
count
=
0
;
var
thrown
=
false
;
try
{
arr
.
filter
(
(
v
k
o
)
=
>
{
count
+
+
;
sum
+
=
v
;
assert
.
sameValue
(
k
v
-
1
)
;
assert
.
sameValue
(
o
arr
)
;
if
(
v
=
=
=
3
)
{
throw
"
filter
"
;
}
return
v
;
}
)
}
catch
(
e
)
{
assert
.
sameValue
(
e
"
filter
"
)
;
thrown
=
true
;
}
assert
.
sameValue
(
thrown
true
)
;
assert
.
sameValue
(
sum
6
)
;
assert
.
sameValue
(
count
3
)
;
assertThrowsInstanceOf
(
(
)
=
>
{
arr
.
filter
(
)
;
}
TypeError
)
;
var
invalidCallbacks
=
[
undefined
null
1
false
"
"
Symbol
(
)
[
]
{
}
/
.
/
]
;
invalidCallbacks
.
forEach
(
callback
=
>
{
assertThrowsInstanceOf
(
(
)
=
>
{
arr
.
filter
(
callback
)
;
}
TypeError
)
;
}
)
arr
.
filter
(
function
*
(
)
{
throw
"
This
line
will
not
be
executed
"
;
}
)
;
if
(
typeof
createNewGlobal
=
=
=
"
function
"
)
{
var
filter
=
createNewGlobal
(
)
[
constructor
.
name
]
.
prototype
.
filter
;
var
sum
=
0
;
assert
.
compareArray
(
filter
.
call
(
new
constructor
(
[
1
2
3
]
)
v
=
>
{
sum
+
=
v
;
return
true
}
)
new
constructor
(
[
1
2
3
]
)
)
;
assert
.
sameValue
(
sum
6
)
;
}
var
invalidReceivers
=
[
undefined
null
1
false
"
"
Symbol
(
)
[
]
{
}
/
.
/
new
Proxy
(
new
constructor
(
)
{
}
)
]
;
invalidReceivers
.
forEach
(
invalidReceiver
=
>
{
assertThrowsInstanceOf
(
(
)
=
>
{
constructor
.
prototype
.
filter
.
call
(
invalidReceiver
(
)
=
>
true
)
;
}
TypeError
"
Assert
that
filter
fails
if
this
value
is
not
a
TypedArray
"
)
;
}
)
;
assert
.
compareArray
(
Object
.
defineProperty
(
new
constructor
(
[
1
2
3
]
)
"
length
"
{
get
(
)
{
throw
new
Error
(
"
length
accessor
called
"
)
;
}
}
)
.
filter
(
(
b
)
=
>
true
)
new
constructor
(
[
1
2
3
]
)
)
;
}
var
arr
=
new
Uint16Array
(
[
1
2
3
]
)
;
var
old
=
Array
.
prototype
[
Symbol
.
iterator
]
;
Array
.
prototype
[
Symbol
.
iterator
]
=
(
)
=
>
{
throw
new
Error
(
"
unreachable
"
)
;
}
;
assert
.
compareArray
(
arr
.
filter
(
v
=
>
true
)
arr
)
;
Array
.
prototype
[
Symbol
.
iterator
]
=
old
;
Object
.
defineProperty
(
Array
.
prototype
0
{
configurable
:
true
get
:
function
(
)
{
return
1
;
}
set
:
function
(
)
{
this
.
b
=
1
;
}
}
)
;
assert
.
compareArray
(
new
Uint16Array
(
[
1
2
3
]
)
.
filter
(
v
=
>
true
)
new
Uint16Array
(
[
1
2
3
]
)
)
;
delete
Array
.
prototype
[
0
]
;
reportCompare
(
0
0
)
;
