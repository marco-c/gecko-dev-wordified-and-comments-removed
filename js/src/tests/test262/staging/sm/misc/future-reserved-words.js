var
futureReservedWords
=
[
"
class
"
"
const
"
"
enum
"
"
export
"
"
extends
"
"
import
"
"
super
"
]
;
var
strictFutureReservedWords
=
[
"
implements
"
"
interface
"
"
let
"
"
package
"
"
private
"
"
protected
"
"
public
"
"
static
"
"
yield
"
]
;
function
testNormalAndStrict
(
word
code
message
)
{
if
(
strictFutureReservedWords
.
includes
(
word
)
)
{
eval
(
code
)
;
}
else
{
assert
(
futureReservedWords
.
includes
(
word
)
)
;
assert
.
throws
(
SyntaxError
function
(
)
{
eval
(
code
)
;
}
word
+
"
:
normal
"
+
message
)
;
}
assert
.
throws
(
SyntaxError
function
(
)
{
eval
(
"
'
use
strict
'
;
"
+
code
)
;
}
word
+
"
:
strict
"
+
message
)
;
}
function
testWord
(
word
)
{
testNormalAndStrict
(
word
word
+
"
=
'
foo
'
;
"
"
assignment
"
)
;
testNormalAndStrict
(
word
"
(
{
"
+
word
+
"
}
=
'
foo
'
)
;
"
"
destructuring
shorthand
"
)
;
testNormalAndStrict
(
word
"
var
"
+
word
+
"
;
"
"
var
"
)
;
testNormalAndStrict
(
word
"
for
(
var
"
+
word
+
"
in
{
}
)
;
"
"
for
-
in
var
"
)
;
testNormalAndStrict
(
word
"
try
{
}
catch
(
"
+
word
+
"
)
{
}
"
"
catch
var
"
)
;
testNormalAndStrict
(
word
word
+
"
:
while
(
false
)
;
"
"
label
"
)
;
testNormalAndStrict
(
word
"
function
foo
(
"
+
word
+
"
)
{
}
"
"
function
argument
"
)
;
assert
.
throws
(
SyntaxError
function
(
)
{
eval
(
"
function
foo
(
"
+
word
+
"
)
{
'
use
strict
'
;
}
"
)
;
}
word
+
"
:
function
argument
retroactively
strict
"
)
;
testNormalAndStrict
(
word
"
var
s
=
(
function
foo
(
"
+
word
+
"
)
{
}
)
;
"
"
function
expression
argument
"
)
;
assert
.
throws
(
SyntaxError
function
(
)
{
eval
(
"
var
s
=
(
function
foo
(
"
+
word
+
"
)
{
'
use
strict
'
;
}
)
;
"
)
;
}
word
+
"
:
function
expression
argument
retroactively
strict
"
)
;
if
(
strictFutureReservedWords
.
includes
(
word
)
)
{
Function
(
word
"
return
17
"
)
;
}
else
{
assert
.
throws
(
SyntaxError
function
(
)
{
Function
(
word
"
return
17
"
)
;
}
word
+
"
:
argument
with
normal
Function
"
)
;
}
assert
.
throws
(
SyntaxError
function
(
)
{
Function
(
word
"
'
use
strict
'
;
return
17
"
)
;
}
word
+
"
:
argument
with
strict
Function
"
)
;
testNormalAndStrict
(
word
"
var
o
=
{
set
x
(
"
+
word
+
"
)
{
}
}
;
"
"
property
setter
argument
"
)
;
assert
.
throws
(
SyntaxError
function
(
)
{
eval
(
"
var
o
=
{
set
x
(
"
+
word
+
"
)
{
'
use
strict
'
;
}
}
;
"
)
;
}
word
+
"
:
property
setter
argument
retroactively
strict
"
)
;
testNormalAndStrict
(
word
"
function
"
+
word
+
"
(
)
{
}
"
"
function
name
"
)
;
assert
.
throws
(
SyntaxError
function
(
)
{
eval
(
"
function
"
+
word
+
"
(
)
{
'
use
strict
'
;
}
"
)
;
}
word
+
"
:
function
name
retroactively
strict
"
)
;
testNormalAndStrict
(
word
"
var
s
=
(
function
"
+
word
+
"
(
)
{
}
)
;
"
"
function
expression
name
"
)
;
assert
.
throws
(
SyntaxError
function
(
)
{
eval
(
"
var
s
=
(
function
"
+
word
+
"
(
)
{
'
use
strict
'
;
}
)
;
"
)
;
}
word
+
"
:
function
expression
name
retroactively
strict
"
)
;
}
futureReservedWords
.
forEach
(
testWord
)
;
strictFutureReservedWords
.
forEach
(
testWord
)
;
reportCompare
(
0
0
)
;
