class
DuckRegExp
extends
RegExp
{
constructor
(
pattern
flags
)
{
return
Object
.
create
(
DuckRegExp
.
prototype
{
regExp
:
{
value
:
new
RegExp
(
pattern
flags
)
}
lastIndex
:
{
value
:
0
writable
:
true
enumerable
:
false
configurable
:
false
}
}
)
;
}
exec
(
.
.
.
args
)
{
this
.
regExp
.
lastIndex
=
this
.
lastIndex
;
try
{
return
this
.
regExp
.
exec
(
.
.
.
args
)
;
}
finally
{
if
(
this
.
global
|
|
this
.
sticky
)
this
.
lastIndex
=
this
.
regExp
.
lastIndex
;
}
}
get
source
(
)
{
return
this
.
regExp
.
source
;
}
get
global
(
)
{
return
this
.
regExp
.
global
;
}
get
ignoreCase
(
)
{
return
this
.
regExp
.
ignoreCase
;
}
get
multiline
(
)
{
return
this
.
regExp
.
multiline
;
}
get
sticky
(
)
{
return
this
.
regExp
.
sticky
;
}
get
unicode
(
)
{
return
this
.
regExp
.
unicode
;
}
}
const
testCasesNotPositiveZero
=
[
{
regExp
:
/
a
/
lastIndex
:
-
1
input
:
"
a
"
}
{
regExp
:
/
a
/
g
lastIndex
:
-
1
input
:
"
a
"
}
{
regExp
:
/
a
/
y
lastIndex
:
-
1
input
:
"
a
"
}
{
regExp
:
/
a
/
lastIndex
:
100
input
:
"
a
"
}
{
regExp
:
/
a
/
g
lastIndex
:
100
input
:
"
a
"
}
{
regExp
:
/
a
/
y
lastIndex
:
100
input
:
"
a
"
}
{
regExp
:
/
a
/
lastIndex
:
-
1
input
:
"
b
"
}
{
regExp
:
/
a
/
g
lastIndex
:
-
1
input
:
"
b
"
}
{
regExp
:
/
a
/
y
lastIndex
:
-
1
input
:
"
b
"
}
{
regExp
:
/
a
/
lastIndex
:
-
0
input
:
"
a
"
}
{
regExp
:
/
a
/
g
lastIndex
:
-
0
input
:
"
a
"
}
{
regExp
:
/
a
/
y
lastIndex
:
-
0
input
:
"
a
"
}
{
regExp
:
/
a
/
lastIndex
:
-
0
input
:
"
b
"
}
{
regExp
:
/
a
/
g
lastIndex
:
-
0
input
:
"
b
"
}
{
regExp
:
/
a
/
y
lastIndex
:
-
0
input
:
"
b
"
}
]
;
const
testCasesPositiveZero
=
[
{
regExp
:
/
a
/
lastIndex
:
0
input
:
"
a
"
}
{
regExp
:
/
a
/
g
lastIndex
:
0
input
:
"
a
"
}
{
regExp
:
/
a
/
y
lastIndex
:
0
input
:
"
a
"
}
{
regExp
:
/
a
/
lastIndex
:
0
input
:
"
b
"
}
{
regExp
:
/
a
/
g
lastIndex
:
0
input
:
"
b
"
}
{
regExp
:
/
a
/
y
lastIndex
:
0
input
:
"
b
"
}
]
;
const
testCases
=
[
.
.
.
testCasesNotPositiveZero
.
.
.
testCasesPositiveZero
]
;
for
(
let
Constructor
of
[
RegExp
DuckRegExp
]
)
{
for
(
let
{
regExp
lastIndex
input
}
of
testCases
)
{
let
re
=
new
Constructor
(
regExp
)
;
re
.
lastIndex
=
lastIndex
;
re
[
Symbol
.
search
]
(
input
)
;
assert
.
sameValue
(
re
.
lastIndex
lastIndex
)
;
}
for
(
let
{
regExp
lastIndex
input
}
of
testCasesNotPositiveZero
)
{
let
re
=
new
Constructor
(
regExp
)
;
Object
.
defineProperty
(
re
"
lastIndex
"
{
value
:
lastIndex
writable
:
false
}
)
;
assertThrowsInstanceOf
(
(
)
=
>
re
[
Symbol
.
search
]
(
input
)
TypeError
)
;
assert
.
sameValue
(
re
.
lastIndex
lastIndex
)
;
}
for
(
let
{
regExp
lastIndex
input
}
of
testCasesPositiveZero
)
{
let
re
=
new
Constructor
(
regExp
)
;
Object
.
defineProperty
(
re
"
lastIndex
"
{
value
:
lastIndex
writable
:
false
}
)
;
if
(
re
.
global
|
|
re
.
sticky
)
{
assertThrowsInstanceOf
(
(
)
=
>
re
[
Symbol
.
search
]
(
input
)
TypeError
)
;
}
else
{
re
[
Symbol
.
search
]
(
input
)
;
}
assert
.
sameValue
(
re
.
lastIndex
lastIndex
)
;
}
for
(
let
{
regExp
lastIndex
input
}
of
testCases
)
{
let
re
=
new
RegExp
(
regExp
)
;
let
badIndex
=
{
valueOf
(
)
{
assert
.
sameValue
(
false
true
)
;
}
}
;
re
.
lastIndex
=
badIndex
;
re
[
Symbol
.
search
]
(
input
)
;
assert
.
sameValue
(
re
.
lastIndex
badIndex
)
;
}
}
reportCompare
(
0
0
)
;
