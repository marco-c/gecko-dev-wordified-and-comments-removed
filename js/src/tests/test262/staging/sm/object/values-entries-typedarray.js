function
assertSameEntries
(
actual
expected
)
{
assert
.
sameValue
(
actual
.
length
expected
.
length
)
;
for
(
let
i
=
0
;
i
<
expected
.
length
;
+
+
i
)
assert
.
compareArray
(
actual
[
i
]
expected
[
i
]
)
;
}
function
throwsTypeError
(
fn
)
{
try
{
fn
(
)
;
}
catch
(
e
)
{
assert
.
sameValue
(
e
instanceof
TypeError
true
)
;
return
true
;
}
return
false
;
}
const
ACCESS_ON_DETACHED_ARRAY_BUFFER_THROWS
=
(
(
)
=
>
{
let
ta
=
new
Int32Array
(
10
)
;
262
.
detachArrayBuffer
(
ta
.
buffer
)
;
let
throws
=
throwsTypeError
(
(
)
=
>
ta
[
0
]
)
;
assert
.
sameValue
(
throwsTypeError
(
(
)
=
>
Object
.
getOwnPropertyDescriptor
(
ta
0
)
)
throws
)
;
return
throws
;
}
)
(
)
;
function
maybeThrowOnDetached
(
fn
returnValue
)
{
if
(
ACCESS_ON_DETACHED_ARRAY_BUFFER_THROWS
)
{
assertThrowsInstanceOf
(
fn
TypeError
)
;
return
returnValue
;
}
return
fn
(
)
;
}
for
(
let
len
of
[
0
1
10
]
)
{
let
array
=
new
Array
(
len
)
.
fill
(
1
)
;
let
ta
=
new
Int32Array
(
array
)
;
assert
.
compareArray
(
Object
.
keys
(
ta
)
Object
.
keys
(
array
)
)
;
assert
.
compareArray
(
Object
.
values
(
ta
)
Object
.
values
(
array
)
)
;
assertSameEntries
(
Object
.
entries
(
ta
)
Object
.
entries
(
array
)
)
;
262
.
detachArrayBuffer
(
ta
.
buffer
)
;
assert
.
compareArray
(
maybeThrowOnDetached
(
(
)
=
>
Object
.
keys
(
ta
)
[
]
)
[
]
)
;
assert
.
compareArray
(
maybeThrowOnDetached
(
(
)
=
>
Object
.
values
(
ta
)
[
]
)
[
]
)
;
assertSameEntries
(
maybeThrowOnDetached
(
(
)
=
>
Object
.
entries
(
ta
)
[
]
)
[
]
)
;
}
reportCompare
(
0
0
)
;
