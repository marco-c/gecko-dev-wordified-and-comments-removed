assert
.
sameValue
(
typeof
Reflect
'
object
'
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
Reflect
)
Object
.
prototype
)
;
assert
.
sameValue
(
Reflect
.
toString
(
)
'
[
object
Reflect
]
'
)
;
assertThrowsInstanceOf
(
(
)
=
>
new
Reflect
TypeError
)
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
this
"
Reflect
"
)
;
assert
.
sameValue
(
desc
.
enumerable
false
)
;
assert
.
sameValue
(
desc
.
configurable
true
)
;
assert
.
sameValue
(
desc
.
writable
true
)
;
for
(
const
name
in
Reflect
)
throw
new
Error
(
"
Reflect
should
not
have
any
enumerable
properties
"
)
;
var
methods
=
{
apply
:
3
construct
:
2
defineProperty
:
3
deleteProperty
:
2
get
:
2
getOwnPropertyDescriptor
:
2
getPrototypeOf
:
1
has
:
2
isExtensible
:
1
ownKeys
:
1
preventExtensions
:
1
set
:
3
setPrototypeOf
:
2
}
;
for
(
const
name
of
Reflect
.
ownKeys
(
Reflect
)
)
{
if
(
typeof
name
!
=
=
"
symbol
"
&
&
name
!
=
=
"
parse
"
)
assert
.
sameValue
(
name
in
methods
true
unexpected
property
found
:
Reflect
.
{
name
}
)
;
}
for
(
const
name
of
Object
.
keys
(
methods
)
)
{
var
desc
=
Object
.
getOwnPropertyDescriptor
(
Reflect
name
)
;
assert
.
sameValue
(
desc
.
enumerable
false
)
;
assert
.
sameValue
(
desc
.
configurable
true
)
;
assert
.
sameValue
(
desc
.
writable
true
)
;
var
f
=
desc
.
value
;
assert
.
sameValue
(
typeof
f
"
function
"
)
;
assert
.
sameValue
(
f
.
length
methods
[
name
]
)
;
}
delete
this
.
Reflect
;
assert
.
sameValue
(
"
Reflect
"
in
this
false
)
;
reportCompare
(
0
0
)
;
