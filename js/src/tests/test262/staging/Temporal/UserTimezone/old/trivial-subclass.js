class
CustomUTCSubclass
extends
Temporal
.
TimeZone
{
constructor
(
)
{
super
(
"
UTC
"
)
;
}
get
id
(
)
{
return
"
Etc
/
Custom
/
UTC_Subclass
"
;
}
toString
(
)
{
return
"
Etc
/
Custom
/
UTC_Subclass
"
;
}
getOffsetNanosecondsFor
(
)
{
return
0
;
}
getPossibleInstantsFor
(
dateTime
)
{
var
{
year
month
day
hour
minute
second
millisecond
microsecond
nanosecond
}
=
dateTime
;
var
dayNum
=
MakeDay
(
year
month
day
)
;
var
time
=
MakeTime
(
hour
minute
second
millisecond
microsecond
nanosecond
)
;
var
epochNs
=
MakeDate
(
dayNum
time
)
;
return
[
new
Temporal
.
Instant
(
epochNs
)
]
;
}
getNextTransition
(
)
{
return
null
;
}
getPreviousTransition
(
)
{
return
null
;
}
}
const
nsPerDay
=
86400_000_000_000n
;
const
nsPerMillisecond
=
1_000_000n
;
function
Day
(
t
)
{
return
t
/
nsPerDay
;
}
function
MakeDate
(
day
time
)
{
return
day
*
nsPerDay
+
time
;
}
function
MakeDay
(
year
month
day
)
{
const
m
=
month
-
1
;
const
ym
=
year
+
Math
.
floor
(
m
/
12
)
;
const
mn
=
m
%
12
;
const
t
=
BigInt
(
Date
.
UTC
(
ym
mn
1
)
)
*
nsPerMillisecond
;
return
Day
(
t
)
+
BigInt
(
day
)
-
1n
;
}
function
MakeTime
(
h
min
s
ms
s
ns
)
{
const
MinutesPerHour
=
60n
;
const
SecondsPerMinute
=
60n
;
const
nsPerSecond
=
1_000_000_000n
;
const
nsPerMinute
=
nsPerSecond
*
SecondsPerMinute
;
const
nsPerHour
=
nsPerMinute
*
MinutesPerHour
;
return
(
BigInt
(
h
)
*
nsPerHour
+
BigInt
(
min
)
*
nsPerMinute
+
BigInt
(
s
)
*
nsPerSecond
+
BigInt
(
ms
)
*
nsPerMillisecond
+
BigInt
(
s
)
*
1000n
+
BigInt
(
ns
)
)
;
}
var
obj
=
new
CustomUTCSubclass
(
)
;
var
inst
=
Temporal
.
Instant
.
fromEpochNanoseconds
(
0n
)
;
var
dt
=
new
Temporal
.
PlainDateTime
(
1976
11
18
15
23
30
123
456
789
)
;
assert
.
sameValue
(
typeof
obj
"
object
"
)
assert
.
sameValue
(
obj
.
id
"
Etc
/
Custom
/
UTC_Subclass
"
)
assert
.
throws
(
RangeError
(
)
=
>
Temporal
.
TimeZone
.
from
(
"
Etc
/
Custom
/
UTC_Subclass
"
)
)
;
assert
.
throws
(
RangeError
(
)
=
>
Temporal
.
TimeZone
.
from
(
"
2020
-
05
-
26T16
:
02
:
46
.
251163036
+
00
:
00
[
Etc
/
Custom
/
UTC_Subclass
]
"
)
)
;
assert
.
sameValue
(
obj
.
getOffsetStringFor
(
inst
)
"
+
00
:
00
"
)
var
fakeGregorian
=
{
toString
(
)
{
return
"
gregory
"
;
}
}
;
assert
.
sameValue
(
{
obj
.
getPlainDateTimeFor
(
inst
)
}
"
1970
-
01
-
01T00
:
00
:
00
"
)
;
assert
.
sameValue
(
{
obj
.
getPlainDateTimeFor
(
inst
fakeGregorian
)
}
"
1970
-
01
-
01T00
:
00
:
00
[
u
-
ca
=
gregory
]
"
)
;
assert
.
sameValue
(
{
obj
.
getInstantFor
(
dt
)
}
"
1976
-
11
-
18T15
:
23
:
30
.
123456789Z
"
)
;
assert
.
sameValue
(
{
obj
}
obj
.
id
)
assert
.
sameValue
(
inst
.
toString
(
{
timeZone
:
obj
}
)
"
1970
-
01
-
01T00
:
00
:
00
+
00
:
00
"
)
var
zdt
=
new
Temporal
.
ZonedDateTime
(
0n
obj
)
;
assert
.
sameValue
(
zdt
.
toString
(
)
"
1970
-
01
-
01T00
:
00
:
00
+
00
:
00
[
Etc
/
Custom
/
UTC_Subclass
]
"
)
;
assert
.
sameValue
(
obj
.
getNextTransition
(
)
null
)
assert
.
sameValue
(
obj
.
getPreviousTransition
(
)
null
)
assert
(
Temporal
.
Now
.
plainDateTimeISO
(
obj
)
instanceof
Temporal
.
PlainDateTime
)
;
assert
(
Temporal
.
Now
.
plainDateTime
(
fakeGregorian
obj
)
instanceof
Temporal
.
PlainDateTime
)
;
assert
(
Temporal
.
Now
.
plainDateISO
(
obj
)
instanceof
Temporal
.
PlainDate
)
;
assert
(
Temporal
.
Now
.
plainDate
(
fakeGregorian
obj
)
instanceof
Temporal
.
PlainDate
)
;
assert
(
Temporal
.
Now
.
plainTimeISO
(
obj
)
instanceof
Temporal
.
PlainTime
)
;
reportCompare
(
0
0
)
;
