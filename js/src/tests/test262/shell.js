function
assert
(
mustBeTrue
message
)
{
if
(
mustBeTrue
=
=
=
true
)
{
return
;
}
if
(
message
=
=
=
undefined
)
{
message
=
'
Expected
true
but
got
'
+
String
(
mustBeTrue
)
;
}
ERROR
(
message
)
;
}
assert
.
_isSameValue
=
function
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
a
!
=
=
0
|
|
1
/
a
=
=
=
1
/
b
;
}
return
a
!
=
=
a
&
&
b
!
=
=
b
;
}
;
assert
.
sameValue
=
function
(
actual
expected
message
)
{
if
(
assert
.
_isSameValue
(
actual
expected
)
)
{
return
;
}
if
(
message
=
=
=
undefined
)
{
message
=
'
'
;
}
else
{
message
+
=
'
'
;
}
message
+
=
'
Expected
SameValue
(
'
+
String
(
actual
)
+
'
'
+
String
(
expected
)
+
'
)
to
be
true
'
;
ERROR
(
message
)
;
}
;
assert
.
notSameValue
=
function
(
actual
unexpected
message
)
{
if
(
!
assert
.
_isSameValue
(
actual
unexpected
)
)
{
return
;
}
if
(
message
=
=
=
undefined
)
{
message
=
'
'
;
}
else
{
message
+
=
'
'
;
}
message
+
=
'
Expected
SameValue
(
'
+
String
(
actual
)
+
'
'
+
String
(
unexpected
)
+
'
)
to
be
false
'
;
ERROR
(
message
)
;
}
;
assert
.
throws
=
function
(
expectedErrorConstructor
func
message
)
{
if
(
typeof
func
!
=
=
"
function
"
)
{
ERROR
(
'
assert
.
throws
requires
two
arguments
:
the
error
constructor
'
+
'
and
a
function
to
run
'
)
;
return
;
}
if
(
message
=
=
=
undefined
)
{
message
=
'
'
;
}
else
{
message
+
=
'
'
;
}
try
{
func
(
)
;
}
catch
(
thrown
)
{
if
(
typeof
thrown
!
=
=
'
object
'
|
|
thrown
=
=
=
null
)
{
message
+
=
'
Thrown
value
was
not
an
object
!
'
;
ERROR
(
message
)
;
}
else
if
(
thrown
.
constructor
!
=
=
expectedErrorConstructor
)
{
message
+
=
'
Expected
a
'
+
expectedErrorConstructor
.
name
+
'
but
got
a
'
+
thrown
.
constructor
.
name
;
ERROR
(
message
)
;
}
return
;
}
message
+
=
'
Expected
a
'
+
expectedErrorConstructor
.
name
+
'
to
be
thrown
but
no
exception
was
thrown
at
all
'
;
ERROR
(
message
)
;
}
;
assert
.
throws
.
early
=
function
(
err
code
)
{
var
wrappedCode
=
'
function
wrapperFn
(
)
{
'
+
code
+
'
}
'
;
var
ieval
=
eval
;
assert
.
throws
(
err
function
(
)
{
Function
(
wrappedCode
)
;
}
'
Function
:
'
+
code
)
;
}
;
function
compareArray
(
a
b
)
{
if
(
b
.
length
!
=
=
a
.
length
)
{
return
false
;
}
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
{
if
(
b
[
i
]
!
=
=
a
[
i
]
)
{
return
false
;
}
}
return
true
;
}
assert
.
compareArray
=
function
(
actual
expected
message
)
{
assert
(
compareArray
(
actual
expected
)
'
Expected
[
'
+
actual
.
join
(
'
'
)
+
'
]
and
[
'
+
expected
.
join
(
'
'
)
+
'
]
to
have
the
same
contents
.
'
+
message
)
;
}
;
function
verifyProperty
(
obj
name
desc
options
)
{
assert
(
arguments
.
length
>
2
'
verifyProperty
should
receive
at
least
3
arguments
:
obj
name
and
descriptor
'
)
;
var
originalDesc
=
Object
.
getOwnPropertyDescriptor
(
obj
name
)
;
var
nameStr
=
String
(
name
)
;
if
(
desc
=
=
=
undefined
)
{
assert
.
sameValue
(
originalDesc
undefined
"
obj
[
'
"
+
nameStr
+
"
'
]
descriptor
should
be
undefined
"
)
;
return
true
;
}
assert
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
name
)
"
obj
should
have
an
own
property
"
+
nameStr
)
;
assert
.
notSameValue
(
desc
null
"
The
desc
argument
should
be
an
object
or
undefined
null
"
)
;
assert
.
sameValue
(
typeof
desc
"
object
"
"
The
desc
argument
should
be
an
object
or
undefined
"
+
String
(
desc
)
)
;
var
failures
=
[
]
;
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
desc
'
value
'
)
)
{
if
(
desc
.
value
!
=
=
originalDesc
.
value
)
{
failures
.
push
(
"
descriptor
value
should
be
"
+
desc
.
value
)
;
}
}
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
desc
'
enumerable
'
)
)
{
if
(
desc
.
enumerable
!
=
=
originalDesc
.
enumerable
|
|
desc
.
enumerable
!
=
=
isEnumerable
(
obj
name
)
)
{
failures
.
push
(
'
descriptor
should
'
+
(
desc
.
enumerable
?
'
'
:
'
not
'
)
+
'
be
enumerable
'
)
;
}
}
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
desc
'
writable
'
)
)
{
if
(
desc
.
writable
!
=
=
originalDesc
.
writable
|
|
desc
.
writable
!
=
=
isWritable
(
obj
name
)
)
{
failures
.
push
(
'
descriptor
should
'
+
(
desc
.
writable
?
'
'
:
'
not
'
)
+
'
be
writable
'
)
;
}
}
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
desc
'
configurable
'
)
)
{
if
(
desc
.
configurable
!
=
=
originalDesc
.
configurable
|
|
desc
.
configurable
!
=
=
isConfigurable
(
obj
name
)
)
{
failures
.
push
(
'
descriptor
should
'
+
(
desc
.
configurable
?
'
'
:
'
not
'
)
+
'
be
configurable
'
)
;
}
}
assert
(
!
failures
.
length
failures
.
join
(
'
;
'
)
)
;
if
(
options
&
&
options
.
restore
)
{
Object
.
defineProperty
(
obj
name
originalDesc
)
;
}
return
true
;
}
function
isConfigurable
(
obj
name
)
{
try
{
delete
obj
[
name
]
;
}
catch
(
e
)
{
if
(
!
(
e
instanceof
TypeError
)
)
{
ERROR
(
"
Expected
TypeError
got
"
+
e
)
;
}
}
return
!
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
name
)
;
}
function
isEnumerable
(
obj
name
)
{
var
stringCheck
=
false
;
if
(
typeof
name
=
=
=
"
string
"
)
{
for
(
var
x
in
obj
)
{
if
(
x
=
=
=
name
)
{
stringCheck
=
true
;
break
;
}
}
}
else
{
stringCheck
=
true
;
}
return
stringCheck
&
&
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
name
)
&
&
Object
.
prototype
.
propertyIsEnumerable
.
call
(
obj
name
)
;
}
function
isEqualTo
(
obj
name
expectedValue
)
{
var
actualValue
=
obj
[
name
]
;
return
assert
.
_isSameValue
(
actualValue
expectedValue
)
;
}
function
isWritable
(
obj
name
verifyProp
value
)
{
var
newValue
=
value
|
|
"
unlikelyValue
"
;
var
hadValue
=
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
name
)
;
var
oldValue
=
obj
[
name
]
;
var
writeSucceeded
;
try
{
obj
[
name
]
=
newValue
;
}
catch
(
e
)
{
if
(
!
(
e
instanceof
TypeError
)
)
{
ERROR
(
"
Expected
TypeError
got
"
+
e
)
;
}
}
writeSucceeded
=
isEqualTo
(
obj
verifyProp
|
|
name
newValue
)
;
if
(
writeSucceeded
)
{
if
(
hadValue
)
{
obj
[
name
]
=
oldValue
;
}
else
{
delete
obj
[
name
]
;
}
}
return
writeSucceeded
;
}
function
verifyEqualTo
(
obj
name
value
)
{
if
(
!
isEqualTo
(
obj
name
value
)
)
{
ERROR
(
"
Expected
obj
[
"
+
String
(
name
)
+
"
]
to
equal
"
+
value
+
"
actually
"
+
obj
[
name
]
)
;
}
}
function
verifyWritable
(
obj
name
verifyProp
value
)
{
if
(
!
verifyProp
)
{
assert
(
Object
.
getOwnPropertyDescriptor
(
obj
name
)
.
writable
"
Expected
obj
[
"
+
String
(
name
)
+
"
]
to
have
writable
:
true
.
"
)
;
}
if
(
!
isWritable
(
obj
name
verifyProp
value
)
)
{
ERROR
(
"
Expected
obj
[
"
+
String
(
name
)
+
"
]
to
be
writable
but
was
not
.
"
)
;
}
}
function
verifyNotWritable
(
obj
name
verifyProp
value
)
{
if
(
!
verifyProp
)
{
assert
(
!
Object
.
getOwnPropertyDescriptor
(
obj
name
)
.
writable
"
Expected
obj
[
"
+
String
(
name
)
+
"
]
to
have
writable
:
false
.
"
)
;
}
if
(
isWritable
(
obj
name
verifyProp
)
)
{
ERROR
(
"
Expected
obj
[
"
+
String
(
name
)
+
"
]
NOT
to
be
writable
but
was
.
"
)
;
}
}
function
verifyEnumerable
(
obj
name
)
{
assert
(
Object
.
getOwnPropertyDescriptor
(
obj
name
)
.
enumerable
"
Expected
obj
[
"
+
String
(
name
)
+
"
]
to
have
enumerable
:
true
.
"
)
;
if
(
!
isEnumerable
(
obj
name
)
)
{
ERROR
(
"
Expected
obj
[
"
+
String
(
name
)
+
"
]
to
be
enumerable
but
was
not
.
"
)
;
}
}
function
verifyNotEnumerable
(
obj
name
)
{
assert
(
!
Object
.
getOwnPropertyDescriptor
(
obj
name
)
.
enumerable
"
Expected
obj
[
"
+
String
(
name
)
+
"
]
to
have
enumerable
:
false
.
"
)
;
if
(
isEnumerable
(
obj
name
)
)
{
ERROR
(
"
Expected
obj
[
"
+
String
(
name
)
+
"
]
NOT
to
be
enumerable
but
was
.
"
)
;
}
}
function
verifyConfigurable
(
obj
name
)
{
assert
(
Object
.
getOwnPropertyDescriptor
(
obj
name
)
.
configurable
"
Expected
obj
[
"
+
String
(
name
)
+
"
]
to
have
configurable
:
true
.
"
)
;
if
(
!
isConfigurable
(
obj
name
)
)
{
ERROR
(
"
Expected
obj
[
"
+
String
(
name
)
+
"
]
to
be
configurable
but
was
not
.
"
)
;
}
}
function
verifyNotConfigurable
(
obj
name
)
{
assert
(
!
Object
.
getOwnPropertyDescriptor
(
obj
name
)
.
configurable
"
Expected
obj
[
"
+
String
(
name
)
+
"
]
to
have
configurable
:
false
.
"
)
;
if
(
isConfigurable
(
obj
name
)
)
{
ERROR
(
"
Expected
obj
[
"
+
String
(
name
)
+
"
]
NOT
to
be
configurable
but
was
.
"
)
;
}
}
function
Test262Error
(
message
)
{
this
.
message
=
message
|
|
"
"
;
}
Test262Error
.
prototype
.
toString
=
function
(
)
{
return
"
Test262Error
:
"
+
this
.
message
;
}
;
var
ERROR
;
ERROR
=
function
ERROR
(
message
)
{
throw
new
Test262Error
(
message
)
;
}
;
;
(
function
createHostObject
(
global
)
{
"
use
strict
"
;
var
FunctionToString
=
global
.
Function
.
prototype
.
toString
;
var
ReflectApply
=
global
.
Reflect
.
apply
;
var
Atomics
=
global
.
Atomics
;
var
Error
=
global
.
Error
;
var
SharedArrayBuffer
=
global
.
SharedArrayBuffer
;
var
Int32Array
=
global
.
Int32Array
;
var
NewGlobal
=
global
.
newGlobal
;
var
setSharedArrayBuffer
=
global
.
setSharedArrayBuffer
;
var
getSharedArrayBuffer
=
global
.
getSharedArrayBuffer
;
var
evalInWorker
=
global
.
evalInWorker
;
var
monotonicNow
=
global
.
monotonicNow
;
var
hasCreateIsHTMLDDA
=
"
createIsHTMLDDA
"
in
global
;
var
hasThreads
=
(
"
helperThreadCount
"
in
global
?
global
.
helperThreadCount
(
)
>
0
:
true
)
;
var
hasMailbox
=
typeof
setSharedArrayBuffer
=
=
=
"
function
"
&
&
typeof
getSharedArrayBuffer
=
=
=
"
function
"
;
var
hasEvalInWorker
=
typeof
evalInWorker
=
=
=
"
function
"
;
if
(
!
hasCreateIsHTMLDDA
&
&
!
(
"
document
"
in
global
&
&
"
all
"
in
global
.
document
)
)
throw
new
Error
(
"
no
[
[
IsHTMLDDA
]
]
object
available
for
testing
"
)
;
var
IsHTMLDDA
=
hasCreateIsHTMLDDA
?
global
.
createIsHTMLDDA
(
)
:
global
.
document
.
all
;
var
shellCode
=
hasMailbox
&
&
hasEvalInWorker
;
var
sabTestable
=
Atomics
&
&
SharedArrayBuffer
&
&
hasThreads
&
&
shellCode
;
global
.
262
=
{
__proto__
:
null
createRealm
(
)
{
var
newGlobalObject
=
NewGlobal
(
)
;
var
createHostObjectFn
=
ReflectApply
(
FunctionToString
createHostObject
[
]
)
;
newGlobalObject
.
Function
(
{
createHostObjectFn
}
createHostObject
(
this
)
;
)
(
)
;
return
newGlobalObject
.
262
;
}
detachArrayBuffer
:
global
.
detachArrayBuffer
evalScript
:
global
.
evaluateScript
|
|
global
.
evaluate
global
IsHTMLDDA
agent
:
(
function
(
)
{
if
(
!
sabTestable
)
{
let
{
reportCompare
quit
}
=
global
;
function
notAvailable
(
)
{
if
(
!
hasThreads
&
&
shellCode
)
{
reportCompare
(
0
0
)
;
quit
(
0
)
;
}
throw
new
Error
(
"
Agents
not
available
"
)
;
}
return
{
start
(
script
)
{
notAvailable
(
)
}
broadcast
(
sab
id
)
{
notAvailable
(
)
}
getReport
(
)
{
notAvailable
(
)
}
sleep
(
s
)
{
notAvailable
(
)
}
monotonicNow
}
}
var
_MSG_LOC
=
0
;
var
_ID_LOC
=
1
;
var
_ACK_LOC
=
2
;
var
_RDY_LOC
=
3
;
var
_LOCKTXT_LOC
=
4
;
var
_NUMTXT_LOC
=
5
;
var
_NEXT_LOC
=
6
;
var
_SLEEP_LOC
=
7
;
var
_FIRST
=
10
;
var
_ia
=
new
Int32Array
(
new
SharedArrayBuffer
(
65536
)
)
;
_ia
[
_NEXT_LOC
]
=
_FIRST
;
var
_worker_prefix
=
if
(
typeof
262
=
=
=
'
undefined
'
)
262
=
{
}
;
262
.
agent
=
(
function
(
global
)
{
var
ReflectApply
=
global
.
Reflect
.
apply
;
var
StringCharCodeAt
=
global
.
String
.
prototype
.
charCodeAt
;
var
{
add
:
Atomics_add
compareExchange
:
Atomics_compareExchange
load
:
Atomics_load
store
:
Atomics_store
wait
:
Atomics_wait
}
=
global
.
Atomics
;
var
{
getSharedArrayBuffer
}
=
global
;
var
_ia
=
new
Int32Array
(
getSharedArrayBuffer
(
)
)
;
var
agent
=
{
receiveBroadcast
(
receiver
)
{
var
k
;
while
(
(
(
k
=
Atomics_load
(
_ia
{
_MSG_LOC
}
)
)
&
1
)
=
=
=
0
)
;
var
received_sab
=
getSharedArrayBuffer
(
)
;
var
received_id
=
Atomics_load
(
_ia
{
_ID_LOC
}
)
;
Atomics_add
(
_ia
{
_ACK_LOC
}
1
)
;
while
(
Atomics_load
(
_ia
{
_MSG_LOC
}
)
=
=
=
k
)
;
receiver
(
received_sab
received_id
)
;
}
report
(
msg
)
{
while
(
Atomics_compareExchange
(
_ia
{
_LOCKTXT_LOC
}
0
1
)
=
=
=
1
)
;
msg
=
"
"
+
msg
;
var
i
=
_ia
[
{
_NEXT_LOC
}
]
;
_ia
[
i
+
+
]
=
msg
.
length
;
for
(
let
j
=
0
;
j
<
msg
.
length
;
j
+
+
)
_ia
[
i
+
+
]
=
ReflectApply
(
StringCharCodeAt
msg
[
j
]
)
;
_ia
[
{
_NEXT_LOC
}
]
=
i
;
Atomics_add
(
_ia
{
_NUMTXT_LOC
}
1
)
;
Atomics_store
(
_ia
{
_LOCKTXT_LOC
}
0
)
;
}
sleep
(
s
)
{
Atomics_wait
(
_ia
{
_SLEEP_LOC
}
0
s
)
;
}
leaving
(
)
{
}
monotonicNow
:
global
.
monotonicNow
}
;
Atomics_add
(
_ia
{
_RDY_LOC
}
1
)
;
return
agent
;
}
)
(
this
)
;
;
var
_numWorkers
=
0
;
var
_numReports
=
0
;
var
_reportPtr
=
_FIRST
;
var
{
add
:
Atomics_add
load
:
Atomics_load
store
:
Atomics_store
wait
:
Atomics_wait
}
=
Atomics
;
var
StringFromCharCode
=
global
.
String
.
fromCharCode
;
return
{
start
(
script
)
{
setSharedArrayBuffer
(
_ia
.
buffer
)
;
var
oldrdy
=
Atomics_load
(
_ia
_RDY_LOC
)
;
evalInWorker
(
_worker_prefix
+
script
)
;
while
(
Atomics_load
(
_ia
_RDY_LOC
)
=
=
=
oldrdy
)
;
_numWorkers
+
+
;
}
broadcast
(
sab
id
)
{
setSharedArrayBuffer
(
sab
)
;
Atomics_store
(
_ia
_ID_LOC
id
)
;
Atomics_store
(
_ia
_ACK_LOC
0
)
;
Atomics_add
(
_ia
_MSG_LOC
1
)
;
while
(
Atomics_load
(
_ia
_ACK_LOC
)
<
_numWorkers
)
;
Atomics_add
(
_ia
_MSG_LOC
1
)
;
}
getReport
(
)
{
if
(
_numReports
=
=
=
Atomics_load
(
_ia
_NUMTXT_LOC
)
)
return
null
;
var
s
=
"
"
;
var
i
=
_reportPtr
;
var
len
=
_ia
[
i
+
+
]
;
for
(
let
j
=
0
;
j
<
len
;
j
+
+
)
s
+
=
StringFromCharCode
(
_ia
[
i
+
+
]
)
;
_reportPtr
=
i
;
_numReports
+
+
;
return
s
;
}
sleep
(
s
)
{
Atomics_wait
(
_ia
_SLEEP_LOC
0
s
)
;
}
monotonicNow
}
;
}
)
(
)
}
;
}
)
(
this
)
;
var
mozAsyncTestDone
=
false
;
function
DONE
(
failure
)
{
if
(
mozAsyncTestDone
)
{
reportFailure
(
"
DONE
(
)
already
called
"
)
;
return
;
}
mozAsyncTestDone
=
true
;
if
(
failure
)
reportFailure
(
failure
)
;
else
reportCompare
(
0
0
)
;
}
