var
modes
=
[
"
shortest
"
"
longest
"
"
strict
"
]
;
function
makeIterator
(
log
name
elements
)
{
var
elementsIter
=
elements
.
values
(
)
;
var
iterator
=
{
next
(
)
{
log
.
push
(
call
{
name
}
next
)
;
assert
.
sameValue
(
this
iterator
)
;
assert
.
sameValue
(
arguments
.
length
0
)
;
var
result
=
elementsIter
.
next
(
)
;
return
{
get
done
(
)
{
log
.
push
(
get
{
name
}
.
result
.
done
)
;
return
result
.
done
;
}
get
value
(
)
{
log
.
push
(
get
{
name
}
.
result
.
value
)
;
return
result
.
value
;
}
}
;
}
return
(
)
{
log
.
push
(
call
{
name
}
return
)
;
assert
.
sameValue
(
this
iterator
)
;
assert
.
sameValue
(
arguments
.
length
0
)
;
return
{
get
done
(
)
{
log
.
push
(
unexpected
get
{
name
}
.
result
.
done
)
;
return
result
.
done
;
}
get
value
(
)
{
log
.
push
(
unexpected
get
{
name
}
.
result
.
value
)
;
return
result
.
value
;
}
}
;
}
}
;
return
iterator
;
}
for
(
var
mode
of
modes
)
{
var
log
=
[
]
;
var
iterables
=
[
makeIterator
(
log
"
first
"
[
1
2
3
]
)
makeIterator
(
log
"
second
"
[
4
5
6
]
)
makeIterator
(
log
"
third
"
[
7
8
9
]
)
]
;
var
it
=
Iterator
.
zip
(
iterables
{
mode
}
)
;
log
.
push
(
"
start
"
)
;
for
(
var
v
of
it
)
{
log
.
push
(
"
loop
"
)
;
}
var
expected
=
[
"
start
"
"
call
first
next
"
"
get
first
.
result
.
done
"
"
get
first
.
result
.
value
"
"
call
second
next
"
"
get
second
.
result
.
done
"
"
get
second
.
result
.
value
"
"
call
third
next
"
"
get
third
.
result
.
done
"
"
get
third
.
result
.
value
"
"
loop
"
"
call
first
next
"
"
get
first
.
result
.
done
"
"
get
first
.
result
.
value
"
"
call
second
next
"
"
get
second
.
result
.
done
"
"
get
second
.
result
.
value
"
"
call
third
next
"
"
get
third
.
result
.
done
"
"
get
third
.
result
.
value
"
"
loop
"
"
call
first
next
"
"
get
first
.
result
.
done
"
"
get
first
.
result
.
value
"
"
call
second
next
"
"
get
second
.
result
.
done
"
"
get
second
.
result
.
value
"
"
call
third
next
"
"
get
third
.
result
.
done
"
"
get
third
.
result
.
value
"
"
loop
"
]
;
switch
(
mode
)
{
case
"
shortest
"
:
{
expected
.
push
(
"
call
first
next
"
"
get
first
.
result
.
done
"
"
call
third
return
"
"
call
second
return
"
)
;
break
;
}
case
"
longest
"
:
case
"
strict
"
:
{
expected
.
push
(
"
call
first
next
"
"
get
first
.
result
.
done
"
"
call
second
next
"
"
get
second
.
result
.
done
"
"
call
third
next
"
"
get
third
.
result
.
done
"
)
;
break
;
}
}
assert
.
compareArray
(
log
expected
)
;
}
reportCompare
(
0
0
)
;
