function
asyncTest
(
testFunc
)
{
if
(
!
Object
.
hasOwn
(
globalThis
"
DONE
"
)
)
{
throw
new
Test262Error
(
"
asyncTest
called
without
async
flag
"
)
;
}
if
(
typeof
testFunc
!
=
=
"
function
"
)
{
DONE
(
new
Test262Error
(
"
asyncTest
called
with
non
-
function
argument
"
)
)
;
return
;
}
try
{
testFunc
(
)
.
then
(
function
(
)
{
DONE
(
)
;
}
function
(
error
)
{
DONE
(
error
)
;
}
)
;
}
catch
(
syncError
)
{
DONE
(
syncError
)
;
}
}
assert
.
throwsAsync
=
function
(
expectedErrorConstructor
func
message
)
{
return
new
Promise
(
function
(
resolve
)
{
var
fail
=
function
(
detail
)
{
if
(
message
=
=
=
undefined
)
{
throw
new
Test262Error
(
detail
)
;
}
throw
new
Test262Error
(
message
+
"
"
+
detail
)
;
}
;
if
(
typeof
expectedErrorConstructor
!
=
=
"
function
"
)
{
fail
(
"
assert
.
throwsAsync
called
with
an
argument
that
is
not
an
error
constructor
"
)
;
}
if
(
typeof
func
!
=
=
"
function
"
)
{
fail
(
"
assert
.
throwsAsync
called
with
an
argument
that
is
not
a
function
"
)
;
}
var
expectedName
=
expectedErrorConstructor
.
name
;
var
expectation
=
"
Expected
a
"
+
expectedName
+
"
to
be
thrown
asynchronously
"
;
var
res
;
try
{
res
=
func
(
)
;
}
catch
(
thrown
)
{
fail
(
expectation
+
"
but
the
function
threw
synchronously
"
)
;
}
if
(
res
=
=
=
null
|
|
typeof
res
!
=
=
"
object
"
|
|
typeof
res
.
then
!
=
=
"
function
"
)
{
fail
(
expectation
+
"
but
result
was
not
a
thenable
"
)
;
}
var
onResFulfilled
onResRejected
;
var
resSettlementP
=
new
Promise
(
function
(
onFulfilled
onRejected
)
{
onResFulfilled
=
onFulfilled
;
onResRejected
=
onRejected
;
}
)
;
try
{
res
.
then
(
onResFulfilled
onResRejected
)
}
catch
(
thrown
)
{
fail
(
expectation
+
"
but
.
then
threw
synchronously
"
)
;
}
resolve
(
resSettlementP
.
then
(
function
(
)
{
fail
(
expectation
+
"
but
no
exception
was
thrown
at
all
"
)
;
}
function
(
thrown
)
{
var
actualName
;
if
(
thrown
=
=
=
null
|
|
typeof
thrown
!
=
=
"
object
"
)
{
fail
(
expectation
+
"
but
thrown
value
was
not
an
object
"
)
;
}
else
if
(
thrown
.
constructor
!
=
=
expectedErrorConstructor
)
{
actualName
=
thrown
.
constructor
.
name
;
if
(
expectedName
=
=
=
actualName
)
{
fail
(
expectation
+
"
but
got
a
different
error
constructor
with
the
same
name
"
)
;
}
fail
(
expectation
+
"
but
got
a
"
+
actualName
)
;
}
}
)
)
;
}
)
;
}
;
const
ASCII_IDENTIFIER
=
/
^
[
_a
-
zA
-
Z
]
[
_a
-
zA
-
Z0
-
9
]
*
/
u
;
function
formatPropertyName
(
propertyKey
objectName
=
"
"
)
{
switch
(
typeof
propertyKey
)
{
case
"
symbol
"
:
if
(
Symbol
.
keyFor
(
propertyKey
)
!
=
=
undefined
)
{
return
{
objectName
}
[
Symbol
.
for
(
'
{
Symbol
.
keyFor
(
propertyKey
)
}
'
)
]
;
}
else
if
(
propertyKey
.
description
.
startsWith
(
'
Symbol
.
'
)
)
{
return
{
objectName
}
[
{
propertyKey
.
description
}
]
;
}
else
{
return
{
objectName
}
[
Symbol
(
'
{
propertyKey
.
description
}
'
)
]
}
case
"
string
"
:
if
(
propertyKey
!
=
=
String
(
Number
(
propertyKey
)
)
)
{
if
(
ASCII_IDENTIFIER
.
test
(
propertyKey
)
)
{
return
objectName
?
{
objectName
}
.
{
propertyKey
}
:
propertyKey
;
}
return
{
objectName
}
[
'
{
propertyKey
.
replace
(
/
'
/
g
"
\
\
'
"
)
}
'
]
}
default
:
return
{
objectName
}
[
{
propertyKey
}
]
;
}
}
const
SKIP_SYMBOL
=
Symbol
(
"
Skip
"
)
;
var
TemporalHelpers
=
{
ISOMonths
:
[
{
month
:
1
monthCode
:
"
M01
"
daysInMonth
:
31
}
{
month
:
2
monthCode
:
"
M02
"
daysInMonth
:
29
}
{
month
:
3
monthCode
:
"
M03
"
daysInMonth
:
31
}
{
month
:
4
monthCode
:
"
M04
"
daysInMonth
:
30
}
{
month
:
5
monthCode
:
"
M05
"
daysInMonth
:
31
}
{
month
:
6
monthCode
:
"
M06
"
daysInMonth
:
30
}
{
month
:
7
monthCode
:
"
M07
"
daysInMonth
:
31
}
{
month
:
8
monthCode
:
"
M08
"
daysInMonth
:
31
}
{
month
:
9
monthCode
:
"
M09
"
daysInMonth
:
30
}
{
month
:
10
monthCode
:
"
M10
"
daysInMonth
:
31
}
{
month
:
11
monthCode
:
"
M11
"
daysInMonth
:
30
}
{
month
:
12
monthCode
:
"
M12
"
daysInMonth
:
31
}
]
CalendarEras
:
{
buddhist
:
[
{
era
:
"
buddhist
"
aliases
:
[
"
be
"
]
}
]
chinese
:
[
{
era
:
"
chinese
"
}
]
coptic
:
[
{
era
:
"
coptic
"
}
{
era
:
"
coptic
-
inverse
"
}
]
dangi
:
[
{
era
:
"
dangi
"
}
]
ethiopic
:
[
{
era
:
"
ethiopic
"
aliases
:
[
"
incar
"
]
}
{
era
:
"
ethioaa
"
aliases
:
[
"
ethiopic
-
amete
-
alem
"
"
mundi
"
]
}
]
ethioaa
:
[
{
era
:
"
ethioaa
"
aliases
:
[
"
ethiopic
-
amete
-
alem
"
"
mundi
"
]
}
]
gregory
:
[
{
era
:
"
gregory
"
aliases
:
[
"
ce
"
"
ad
"
]
}
{
era
:
"
gregory
-
inverse
"
aliases
:
[
"
bc
"
"
bce
"
]
}
]
hebrew
:
[
{
era
:
"
hebrew
"
aliases
:
[
"
am
"
]
}
]
indian
:
[
{
era
:
"
indian
"
aliases
:
[
"
saka
"
]
}
]
islamic
:
[
{
era
:
"
islamic
"
aliases
:
[
"
ah
"
]
}
]
"
islamic
-
civil
"
:
[
{
era
:
"
islamic
-
civil
"
aliases
:
[
"
islamicc
"
"
ah
"
]
}
]
"
islamic
-
rgsa
"
:
[
{
era
:
"
islamic
-
rgsa
"
aliases
:
[
"
ah
"
]
}
]
"
islamic
-
tbla
"
:
[
{
era
:
"
islamic
-
tbla
"
aliases
:
[
"
ah
"
]
}
]
"
islamic
-
umalqura
"
:
[
{
era
:
"
islamic
-
umalqura
"
aliases
:
[
"
ah
"
]
}
]
japanese
:
[
{
era
:
"
heisei
"
}
{
era
:
"
japanese
"
aliases
:
[
"
gregory
"
"
ad
"
"
ce
"
]
}
{
era
:
"
japanese
-
inverse
"
aliases
:
[
"
gregory
-
inverse
"
"
bc
"
"
bce
"
]
}
{
era
:
"
meiji
"
}
{
era
:
"
reiwa
"
}
{
era
:
"
showa
"
}
{
era
:
"
taisho
"
}
]
persian
:
[
{
era
:
"
persian
"
aliases
:
[
"
ap
"
]
}
]
roc
:
[
{
era
:
"
roc
"
aliases
:
[
"
minguo
"
]
}
{
era
:
"
roc
-
inverse
"
aliases
:
[
"
before
-
roc
"
]
}
]
}
canonicalizeCalendarEra
(
calendarId
eraName
)
{
assert
.
sameValue
(
typeof
calendarId
"
string
"
"
calendar
must
be
string
in
canonicalizeCalendarEra
"
)
;
if
(
calendarId
=
=
=
"
iso8601
"
)
{
assert
.
sameValue
(
eraName
undefined
)
;
return
undefined
;
}
assert
(
Object
.
hasOwn
(
TemporalHelpers
.
CalendarEras
calendarId
)
)
;
if
(
eraName
=
=
=
undefined
)
{
return
undefined
;
}
assert
.
sameValue
(
typeof
eraName
"
string
"
"
eraName
must
be
string
or
undefined
in
canonicalizeCalendarEra
"
)
;
for
(
let
{
era
aliases
=
[
]
}
of
TemporalHelpers
.
CalendarEras
[
calendarId
]
)
{
if
(
era
=
=
=
eraName
|
|
aliases
.
includes
(
eraName
)
)
{
return
era
;
}
}
throw
new
Test262Error
(
Unsupported
era
name
:
{
eraName
}
)
;
}
assertDuration
(
duration
years
months
weeks
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
description
=
"
"
)
{
const
prefix
=
description
?
{
description
}
:
:
"
"
;
assert
(
duration
instanceof
Temporal
.
Duration
{
prefix
}
instanceof
)
;
assert
.
sameValue
(
duration
.
years
years
{
prefix
}
years
result
:
)
;
assert
.
sameValue
(
duration
.
months
months
{
prefix
}
months
result
:
)
;
assert
.
sameValue
(
duration
.
weeks
weeks
{
prefix
}
weeks
result
:
)
;
assert
.
sameValue
(
duration
.
days
days
{
prefix
}
days
result
:
)
;
assert
.
sameValue
(
duration
.
hours
hours
{
prefix
}
hours
result
:
)
;
assert
.
sameValue
(
duration
.
minutes
minutes
{
prefix
}
minutes
result
:
)
;
assert
.
sameValue
(
duration
.
seconds
seconds
{
prefix
}
seconds
result
:
)
;
assert
.
sameValue
(
duration
.
milliseconds
milliseconds
{
prefix
}
milliseconds
result
:
)
;
assert
.
sameValue
(
duration
.
microseconds
microseconds
{
prefix
}
microseconds
result
:
)
;
assert
.
sameValue
(
duration
.
nanoseconds
nanoseconds
{
prefix
}
nanoseconds
result
)
;
}
assertDateDuration
(
duration
years
months
weeks
days
description
=
"
"
)
{
const
prefix
=
description
?
{
description
}
:
:
"
"
;
assert
(
duration
instanceof
Temporal
.
Duration
{
prefix
}
instanceof
)
;
assert
.
sameValue
(
duration
.
years
years
{
prefix
}
years
result
:
)
;
assert
.
sameValue
(
duration
.
months
months
{
prefix
}
months
result
:
)
;
assert
.
sameValue
(
duration
.
weeks
weeks
{
prefix
}
weeks
result
:
)
;
assert
.
sameValue
(
duration
.
days
days
{
prefix
}
days
result
:
)
;
assert
.
sameValue
(
duration
.
hours
0
{
prefix
}
hours
result
should
be
zero
:
)
;
assert
.
sameValue
(
duration
.
minutes
0
{
prefix
}
minutes
result
should
be
zero
:
)
;
assert
.
sameValue
(
duration
.
seconds
0
{
prefix
}
seconds
result
should
be
zero
:
)
;
assert
.
sameValue
(
duration
.
milliseconds
0
{
prefix
}
milliseconds
result
should
be
zero
:
)
;
assert
.
sameValue
(
duration
.
microseconds
0
{
prefix
}
microseconds
result
should
be
zero
:
)
;
assert
.
sameValue
(
duration
.
nanoseconds
0
{
prefix
}
nanoseconds
result
should
be
zero
:
)
;
}
assertDurationsEqual
(
actual
expected
description
=
"
"
)
{
const
prefix
=
description
?
{
description
}
:
:
"
"
;
assert
(
expected
instanceof
Temporal
.
Duration
{
prefix
}
expected
value
should
be
a
Temporal
.
Duration
)
;
TemporalHelpers
.
assertDuration
(
actual
expected
.
years
expected
.
months
expected
.
weeks
expected
.
days
expected
.
hours
expected
.
minutes
expected
.
seconds
expected
.
milliseconds
expected
.
microseconds
expected
.
nanoseconds
description
)
;
}
assertInstantsEqual
(
actual
expected
description
=
"
"
)
{
const
prefix
=
description
?
{
description
}
:
:
"
"
;
assert
(
expected
instanceof
Temporal
.
Instant
{
prefix
}
expected
value
should
be
a
Temporal
.
Instant
)
;
assert
(
actual
instanceof
Temporal
.
Instant
{
prefix
}
instanceof
)
;
assert
(
actual
.
equals
(
expected
)
{
prefix
}
equals
method
)
;
}
assertPlainDate
(
date
year
month
monthCode
day
description
=
"
"
era
=
undefined
eraYear
=
undefined
)
{
const
prefix
=
description
?
{
description
}
:
:
"
"
;
assert
(
date
instanceof
Temporal
.
PlainDate
{
prefix
}
instanceof
)
;
assert
.
sameValue
(
TemporalHelpers
.
canonicalizeCalendarEra
(
date
.
calendarId
date
.
era
)
TemporalHelpers
.
canonicalizeCalendarEra
(
date
.
calendarId
era
)
{
prefix
}
era
result
:
)
;
assert
.
sameValue
(
date
.
eraYear
eraYear
{
prefix
}
eraYear
result
:
)
;
assert
.
sameValue
(
date
.
year
year
{
prefix
}
year
result
:
)
;
assert
.
sameValue
(
date
.
month
month
{
prefix
}
month
result
:
)
;
assert
.
sameValue
(
date
.
monthCode
monthCode
{
prefix
}
monthCode
result
:
)
;
assert
.
sameValue
(
date
.
day
day
{
prefix
}
day
result
:
)
;
}
assertPlainDateTime
(
datetime
year
month
monthCode
day
hour
minute
second
millisecond
microsecond
nanosecond
description
=
"
"
era
=
undefined
eraYear
=
undefined
)
{
const
prefix
=
description
?
{
description
}
:
:
"
"
;
assert
(
datetime
instanceof
Temporal
.
PlainDateTime
{
prefix
}
instanceof
)
;
assert
.
sameValue
(
TemporalHelpers
.
canonicalizeCalendarEra
(
datetime
.
calendarId
datetime
.
era
)
TemporalHelpers
.
canonicalizeCalendarEra
(
datetime
.
calendarId
era
)
{
prefix
}
era
result
:
)
;
assert
.
sameValue
(
datetime
.
eraYear
eraYear
{
prefix
}
eraYear
result
:
)
;
assert
.
sameValue
(
datetime
.
year
year
{
prefix
}
year
result
:
)
;
assert
.
sameValue
(
datetime
.
month
month
{
prefix
}
month
result
:
)
;
assert
.
sameValue
(
datetime
.
monthCode
monthCode
{
prefix
}
monthCode
result
:
)
;
assert
.
sameValue
(
datetime
.
day
day
{
prefix
}
day
result
:
)
;
assert
.
sameValue
(
datetime
.
hour
hour
{
prefix
}
hour
result
:
)
;
assert
.
sameValue
(
datetime
.
minute
minute
{
prefix
}
minute
result
:
)
;
assert
.
sameValue
(
datetime
.
second
second
{
prefix
}
second
result
:
)
;
assert
.
sameValue
(
datetime
.
millisecond
millisecond
{
prefix
}
millisecond
result
:
)
;
assert
.
sameValue
(
datetime
.
microsecond
microsecond
{
prefix
}
microsecond
result
:
)
;
assert
.
sameValue
(
datetime
.
nanosecond
nanosecond
{
prefix
}
nanosecond
result
:
)
;
}
assertPlainDateTimesEqual
(
actual
expected
description
=
"
"
)
{
const
prefix
=
description
?
{
description
}
:
:
"
"
;
assert
(
expected
instanceof
Temporal
.
PlainDateTime
{
prefix
}
expected
value
should
be
a
Temporal
.
PlainDateTime
)
;
assert
(
actual
instanceof
Temporal
.
PlainDateTime
{
prefix
}
instanceof
)
;
assert
(
actual
.
equals
(
expected
)
{
prefix
}
equals
method
)
;
assert
.
sameValue
(
actual
.
calendarId
expected
.
calendarId
{
prefix
}
calendar
same
value
:
)
;
}
assertPlainMonthDay
(
monthDay
monthCode
day
description
=
"
"
referenceISOYear
=
1972
)
{
const
prefix
=
description
?
{
description
}
:
:
"
"
;
assert
(
monthDay
instanceof
Temporal
.
PlainMonthDay
{
prefix
}
instanceof
)
;
assert
.
sameValue
(
monthDay
.
monthCode
monthCode
{
prefix
}
monthCode
result
:
)
;
assert
.
sameValue
(
monthDay
.
day
day
{
prefix
}
day
result
:
)
;
const
isoYear
=
Number
(
monthDay
.
toString
(
{
calendarName
:
"
always
"
}
)
.
split
(
"
-
"
)
[
0
]
)
;
assert
.
sameValue
(
isoYear
referenceISOYear
{
prefix
}
referenceISOYear
result
:
)
;
}
assertPlainTime
(
time
hour
minute
second
millisecond
microsecond
nanosecond
description
=
"
"
)
{
const
prefix
=
description
?
{
description
}
:
:
"
"
;
assert
(
time
instanceof
Temporal
.
PlainTime
{
prefix
}
instanceof
)
;
assert
.
sameValue
(
time
.
hour
hour
{
prefix
}
hour
result
:
)
;
assert
.
sameValue
(
time
.
minute
minute
{
prefix
}
minute
result
:
)
;
assert
.
sameValue
(
time
.
second
second
{
prefix
}
second
result
:
)
;
assert
.
sameValue
(
time
.
millisecond
millisecond
{
prefix
}
millisecond
result
:
)
;
assert
.
sameValue
(
time
.
microsecond
microsecond
{
prefix
}
microsecond
result
:
)
;
assert
.
sameValue
(
time
.
nanosecond
nanosecond
{
prefix
}
nanosecond
result
:
)
;
}
assertPlainTimesEqual
(
actual
expected
description
=
"
"
)
{
const
prefix
=
description
?
{
description
}
:
:
"
"
;
assert
(
expected
instanceof
Temporal
.
PlainTime
{
prefix
}
expected
value
should
be
a
Temporal
.
PlainTime
)
;
assert
(
actual
instanceof
Temporal
.
PlainTime
{
prefix
}
instanceof
)
;
assert
(
actual
.
equals
(
expected
)
{
prefix
}
equals
method
)
;
}
assertPlainYearMonth
(
yearMonth
year
month
monthCode
description
=
"
"
era
=
undefined
eraYear
=
undefined
referenceISODay
=
1
)
{
const
prefix
=
description
?
{
description
}
:
:
"
"
;
assert
(
yearMonth
instanceof
Temporal
.
PlainYearMonth
{
prefix
}
instanceof
)
;
assert
.
sameValue
(
TemporalHelpers
.
canonicalizeCalendarEra
(
yearMonth
.
calendarId
yearMonth
.
era
)
TemporalHelpers
.
canonicalizeCalendarEra
(
yearMonth
.
calendarId
era
)
{
prefix
}
era
result
:
)
;
assert
.
sameValue
(
yearMonth
.
eraYear
eraYear
{
prefix
}
eraYear
result
:
)
;
assert
.
sameValue
(
yearMonth
.
year
year
{
prefix
}
year
result
:
)
;
assert
.
sameValue
(
yearMonth
.
month
month
{
prefix
}
month
result
:
)
;
assert
.
sameValue
(
yearMonth
.
monthCode
monthCode
{
prefix
}
monthCode
result
:
)
;
const
isoDay
=
Number
(
yearMonth
.
toString
(
{
calendarName
:
"
always
"
}
)
.
slice
(
1
)
.
split
(
'
-
'
)
[
2
]
.
slice
(
0
2
)
)
;
assert
.
sameValue
(
isoDay
referenceISODay
{
prefix
}
referenceISODay
result
:
)
;
}
assertZonedDateTimesEqual
(
actual
expected
description
=
"
"
)
{
const
prefix
=
description
?
{
description
}
:
:
"
"
;
assert
(
expected
instanceof
Temporal
.
ZonedDateTime
{
prefix
}
expected
value
should
be
a
Temporal
.
ZonedDateTime
)
;
assert
(
actual
instanceof
Temporal
.
ZonedDateTime
{
prefix
}
instanceof
)
;
assert
(
actual
.
equals
(
expected
)
{
prefix
}
equals
method
)
;
assert
.
sameValue
(
actual
.
timeZone
expected
.
timeZone
{
prefix
}
time
zone
same
value
:
)
;
assert
.
sameValue
(
actual
.
calendarId
expected
.
calendarId
{
prefix
}
calendar
same
value
:
)
;
}
assertUnreachable
(
description
)
{
let
message
=
"
This
code
should
not
be
executed
"
;
if
(
description
)
{
message
=
{
message
}
:
{
description
}
;
}
throw
new
Test262Error
(
message
)
;
}
checkPlainDateTimeConversionFastPath
(
func
message
=
"
checkPlainDateTimeConversionFastPath
"
)
{
const
actual
=
[
]
;
const
expected
=
[
]
;
const
calendar
=
"
iso8601
"
;
const
datetime
=
new
Temporal
.
PlainDateTime
(
2000
5
2
12
34
56
987
654
321
calendar
)
;
const
prototypeDescrs
=
Object
.
getOwnPropertyDescriptors
(
Temporal
.
PlainDateTime
.
prototype
)
;
[
"
year
"
"
month
"
"
monthCode
"
"
day
"
"
hour
"
"
minute
"
"
second
"
"
millisecond
"
"
microsecond
"
"
nanosecond
"
]
.
forEach
(
(
property
)
=
>
{
Object
.
defineProperty
(
datetime
property
{
get
(
)
{
actual
.
push
(
get
{
formatPropertyName
(
property
)
}
)
;
const
value
=
prototypeDescrs
[
property
]
.
get
.
call
(
this
)
;
return
{
toString
(
)
{
actual
.
push
(
toString
{
formatPropertyName
(
property
)
}
)
;
return
value
.
toString
(
)
;
}
valueOf
(
)
{
actual
.
push
(
valueOf
{
formatPropertyName
(
property
)
}
)
;
return
value
;
}
}
;
}
}
)
;
}
)
;
Object
.
defineProperty
(
datetime
"
calendar
"
{
get
(
)
{
actual
.
push
(
"
get
calendar
"
)
;
return
calendar
;
}
}
)
;
func
(
datetime
)
;
assert
.
compareArray
(
actual
expected
{
message
}
:
property
getters
not
called
)
;
}
checkPluralUnitsAccepted
(
func
validSingularUnits
)
{
const
plurals
=
{
year
:
'
years
'
month
:
'
months
'
week
:
'
weeks
'
day
:
'
days
'
hour
:
'
hours
'
minute
:
'
minutes
'
second
:
'
seconds
'
millisecond
:
'
milliseconds
'
microsecond
:
'
microseconds
'
nanosecond
:
'
nanoseconds
'
}
;
validSingularUnits
.
forEach
(
(
unit
)
=
>
{
const
singularValue
=
func
(
unit
)
;
const
pluralValue
=
func
(
plurals
[
unit
]
)
;
const
desc
=
Plural
{
plurals
[
unit
]
}
produces
the
same
result
as
singular
{
unit
}
;
if
(
singularValue
instanceof
Temporal
.
Duration
)
{
TemporalHelpers
.
assertDurationsEqual
(
pluralValue
singularValue
desc
)
;
}
else
if
(
singularValue
instanceof
Temporal
.
Instant
)
{
TemporalHelpers
.
assertInstantsEqual
(
pluralValue
singularValue
desc
)
;
}
else
if
(
singularValue
instanceof
Temporal
.
PlainDateTime
)
{
TemporalHelpers
.
assertPlainDateTimesEqual
(
pluralValue
singularValue
desc
)
;
}
else
if
(
singularValue
instanceof
Temporal
.
PlainTime
)
{
TemporalHelpers
.
assertPlainTimesEqual
(
pluralValue
singularValue
desc
)
;
}
else
if
(
singularValue
instanceof
Temporal
.
ZonedDateTime
)
{
TemporalHelpers
.
assertZonedDateTimesEqual
(
pluralValue
singularValue
desc
)
;
}
else
{
assert
.
sameValue
(
pluralValue
singularValue
)
;
}
}
)
;
}
checkRoundingIncrementOptionWrongType
(
checkFunc
assertTrueResultFunc
assertObjectResultFunc
)
{
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
null
)
"
null
"
)
;
const
trueResult
=
checkFunc
(
true
)
;
assertTrueResultFunc
(
trueResult
"
true
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
false
)
"
false
"
)
;
assert
.
throws
(
TypeError
(
)
=
>
checkFunc
(
Symbol
(
)
)
"
symbol
"
)
;
assert
.
throws
(
TypeError
(
)
=
>
checkFunc
(
2n
)
"
bigint
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
{
}
)
"
plain
object
"
)
;
const
expected
=
[
"
get
roundingIncrement
.
valueOf
"
"
call
roundingIncrement
.
valueOf
"
]
;
const
actual
=
[
]
;
const
observer
=
TemporalHelpers
.
toPrimitiveObserver
(
actual
2
"
roundingIncrement
"
)
;
const
objectResult
=
checkFunc
(
observer
)
;
assertObjectResultFunc
(
objectResult
"
object
with
valueOf
"
)
;
assert
.
compareArray
(
actual
expected
"
order
of
operations
"
)
;
}
checkStringOptionWrongType
(
propertyName
value
checkFunc
assertFunc
)
{
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
null
)
"
null
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
true
)
"
true
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
false
)
"
false
"
)
;
assert
.
throws
(
TypeError
(
)
=
>
checkFunc
(
Symbol
(
)
)
"
symbol
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
2
)
"
number
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
2n
)
"
bigint
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
{
}
)
"
plain
object
"
)
;
const
expected
=
[
get
{
propertyName
}
.
toString
call
{
propertyName
}
.
toString
]
;
const
actual
=
[
]
;
const
observer
=
TemporalHelpers
.
toPrimitiveObserver
(
actual
value
propertyName
)
;
const
result
=
checkFunc
(
observer
)
;
assertFunc
(
result
"
object
with
toString
"
)
;
assert
.
compareArray
(
actual
expected
"
order
of
operations
"
)
;
}
checkSubclassingIgnored
(
.
.
.
args
)
{
this
.
checkSubclassConstructorNotObject
(
.
.
.
args
)
;
this
.
checkSubclassConstructorUndefined
(
.
.
.
args
)
;
this
.
checkSubclassConstructorThrows
(
.
.
.
args
)
;
this
.
checkSubclassConstructorNotCalled
(
.
.
.
args
)
;
this
.
checkSubclassSpeciesInvalidResult
(
.
.
.
args
)
;
this
.
checkSubclassSpeciesNotAConstructor
(
.
.
.
args
)
;
this
.
checkSubclassSpeciesNull
(
.
.
.
args
)
;
this
.
checkSubclassSpeciesUndefined
(
.
.
.
args
)
;
this
.
checkSubclassSpeciesThrows
(
.
.
.
args
)
;
}
checkSubclassConstructorNotObject
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
function
check
(
value
description
)
{
const
instance
=
new
construct
(
.
.
.
constructArgs
)
;
instance
.
constructor
=
value
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
description
)
;
resultAssertions
(
result
)
;
}
check
(
null
"
null
"
)
;
check
(
true
"
true
"
)
;
check
(
"
test
"
"
string
"
)
;
check
(
Symbol
(
)
"
Symbol
"
)
;
check
(
7
"
number
"
)
;
check
(
7n
"
bigint
"
)
;
}
checkSubclassConstructorUndefined
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
let
called
=
0
;
class
MySubclass
extends
construct
{
constructor
(
)
{
+
+
called
;
super
(
.
.
.
constructArgs
)
;
}
}
const
instance
=
new
MySubclass
(
)
;
assert
.
sameValue
(
called
1
)
;
MySubclass
.
prototype
.
constructor
=
undefined
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
called
1
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
checkSubclassConstructorThrows
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
function
CustomError
(
)
{
}
const
instance
=
new
construct
(
.
.
.
constructArgs
)
;
Object
.
defineProperty
(
instance
"
constructor
"
{
get
(
)
{
throw
new
CustomError
(
)
;
}
}
)
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
checkSubclassConstructorNotCalled
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
let
called
=
0
;
class
MySubclass
extends
construct
{
constructor
(
)
{
+
+
called
;
super
(
.
.
.
constructArgs
)
;
}
}
const
instance
=
new
MySubclass
(
)
;
assert
.
sameValue
(
called
1
)
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
called
1
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
checkSubclassSpeciesInvalidResult
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
function
check
(
value
description
)
{
const
instance
=
new
construct
(
.
.
.
constructArgs
)
;
instance
.
constructor
=
{
[
Symbol
.
species
]
:
function
(
)
{
return
value
;
}
}
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
description
)
;
resultAssertions
(
result
)
;
}
check
(
undefined
"
undefined
"
)
;
check
(
null
"
null
"
)
;
check
(
true
"
true
"
)
;
check
(
"
test
"
"
string
"
)
;
check
(
Symbol
(
)
"
Symbol
"
)
;
check
(
7
"
number
"
)
;
check
(
7n
"
bigint
"
)
;
check
(
{
}
"
plain
object
"
)
;
}
checkSubclassSpeciesNotAConstructor
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
function
check
(
value
description
)
{
const
instance
=
new
construct
(
.
.
.
constructArgs
)
;
instance
.
constructor
=
{
[
Symbol
.
species
]
:
value
}
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
description
)
;
resultAssertions
(
result
)
;
}
check
(
true
"
true
"
)
;
check
(
"
test
"
"
string
"
)
;
check
(
Symbol
(
)
"
Symbol
"
)
;
check
(
7
"
number
"
)
;
check
(
7n
"
bigint
"
)
;
check
(
{
}
"
plain
object
"
)
;
}
checkSubclassSpeciesNull
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
let
called
=
0
;
class
MySubclass
extends
construct
{
constructor
(
)
{
+
+
called
;
super
(
.
.
.
constructArgs
)
;
}
}
const
instance
=
new
MySubclass
(
)
;
assert
.
sameValue
(
called
1
)
;
MySubclass
.
prototype
.
constructor
=
{
[
Symbol
.
species
]
:
null
}
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
called
1
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
checkSubclassSpeciesUndefined
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
let
called
=
0
;
class
MySubclass
extends
construct
{
constructor
(
)
{
+
+
called
;
super
(
.
.
.
constructArgs
)
;
}
}
const
instance
=
new
MySubclass
(
)
;
assert
.
sameValue
(
called
1
)
;
MySubclass
.
prototype
.
constructor
=
{
[
Symbol
.
species
]
:
undefined
}
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
called
1
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
checkSubclassSpeciesThrows
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
function
CustomError
(
)
{
}
const
instance
=
new
construct
(
.
.
.
constructArgs
)
;
instance
.
constructor
=
{
get
[
Symbol
.
species
]
(
)
{
throw
new
CustomError
(
)
;
}
}
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
}
checkSubclassingIgnoredStatic
(
.
.
.
args
)
{
this
.
checkStaticInvalidReceiver
(
.
.
.
args
)
;
this
.
checkStaticReceiverNotCalled
(
.
.
.
args
)
;
this
.
checkThisValueNotCalled
(
.
.
.
args
)
;
}
checkStaticInvalidReceiver
(
construct
method
methodArgs
resultAssertions
)
{
function
check
(
value
description
)
{
const
result
=
construct
[
method
]
.
apply
(
value
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
check
(
undefined
"
undefined
"
)
;
check
(
null
"
null
"
)
;
check
(
true
"
true
"
)
;
check
(
"
test
"
"
string
"
)
;
check
(
Symbol
(
)
"
symbol
"
)
;
check
(
7
"
number
"
)
;
check
(
7n
"
bigint
"
)
;
check
(
{
}
"
Non
-
callable
object
"
)
;
}
checkStaticReceiverNotCalled
(
construct
method
methodArgs
resultAssertions
)
{
function
check
(
value
description
)
{
const
receiver
=
function
(
)
{
return
value
;
}
;
const
result
=
construct
[
method
]
.
apply
(
receiver
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
check
(
undefined
"
undefined
"
)
;
check
(
null
"
null
"
)
;
check
(
true
"
true
"
)
;
check
(
"
test
"
"
string
"
)
;
check
(
Symbol
(
)
"
symbol
"
)
;
check
(
7
"
number
"
)
;
check
(
7n
"
bigint
"
)
;
check
(
{
}
"
Non
-
callable
object
"
)
;
}
checkThisValueNotCalled
(
construct
method
methodArgs
resultAssertions
)
{
let
called
=
false
;
class
MySubclass
extends
construct
{
constructor
(
.
.
.
args
)
{
called
=
true
;
super
(
.
.
.
args
)
;
}
}
const
result
=
MySubclass
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
called
false
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
checkToTemporalCalendarFastPath
(
func
)
{
const
plainDate
=
new
Temporal
.
PlainDate
(
2000
5
2
"
iso8601
"
)
;
const
plainDateTime
=
new
Temporal
.
PlainDateTime
(
2000
5
2
12
34
56
987
654
321
"
iso8601
"
)
;
const
plainMonthDay
=
new
Temporal
.
PlainMonthDay
(
5
2
"
iso8601
"
)
;
const
plainYearMonth
=
new
Temporal
.
PlainYearMonth
(
2000
5
"
iso8601
"
)
;
const
zonedDateTime
=
new
Temporal
.
ZonedDateTime
(
1_000_000_000_000_000_000n
"
UTC
"
"
iso8601
"
)
;
[
plainDate
plainDateTime
plainMonthDay
plainYearMonth
zonedDateTime
]
.
forEach
(
(
temporalObject
)
=
>
{
const
actual
=
[
]
;
const
expected
=
[
]
;
Object
.
defineProperty
(
temporalObject
"
calendar
"
{
get
(
)
{
actual
.
push
(
"
get
calendar
"
)
;
return
calendar
;
}
}
)
;
func
(
temporalObject
)
;
assert
.
compareArray
(
actual
expected
"
calendar
getter
not
called
"
)
;
}
)
;
}
checkToTemporalInstantFastPath
(
func
)
{
const
actual
=
[
]
;
const
expected
=
[
]
;
const
datetime
=
new
Temporal
.
ZonedDateTime
(
1_000_000_000_987_654_321n
"
UTC
"
)
;
Object
.
defineProperty
(
datetime
'
toString
'
{
get
(
)
{
actual
.
push
(
"
get
toString
"
)
;
return
function
(
options
)
{
actual
.
push
(
"
call
toString
"
)
;
return
Temporal
.
ZonedDateTime
.
prototype
.
toString
.
call
(
this
options
)
;
}
;
}
}
)
;
func
(
datetime
)
;
assert
.
compareArray
(
actual
expected
"
toString
not
called
"
)
;
}
checkToTemporalPlainDateTimeFastPath
(
func
)
{
const
actual
=
[
]
;
const
expected
=
[
]
;
const
date
=
new
Temporal
.
PlainDate
(
2000
5
2
"
iso8601
"
)
;
const
prototypeDescrs
=
Object
.
getOwnPropertyDescriptors
(
Temporal
.
PlainDate
.
prototype
)
;
[
"
year
"
"
month
"
"
monthCode
"
"
day
"
]
.
forEach
(
(
property
)
=
>
{
Object
.
defineProperty
(
date
property
{
get
(
)
{
actual
.
push
(
get
{
formatPropertyName
(
property
)
}
)
;
const
value
=
prototypeDescrs
[
property
]
.
get
.
call
(
this
)
;
return
TemporalHelpers
.
toPrimitiveObserver
(
actual
value
property
)
;
}
}
)
;
}
)
;
[
"
hour
"
"
minute
"
"
second
"
"
millisecond
"
"
microsecond
"
"
nanosecond
"
]
.
forEach
(
(
property
)
=
>
{
Object
.
defineProperty
(
date
property
{
get
(
)
{
actual
.
push
(
get
{
formatPropertyName
(
property
)
}
)
;
return
undefined
;
}
}
)
;
}
)
;
Object
.
defineProperty
(
date
"
calendar
"
{
get
(
)
{
actual
.
push
(
"
get
calendar
"
)
;
return
"
iso8601
"
;
}
}
)
;
func
(
date
)
;
assert
.
compareArray
(
actual
expected
"
property
getters
not
called
"
)
;
}
observeProperty
(
calls
object
propertyName
value
objectName
=
"
"
)
{
Object
.
defineProperty
(
object
propertyName
{
get
(
)
{
calls
.
push
(
get
{
formatPropertyName
(
propertyName
objectName
)
}
)
;
return
value
;
}
set
(
v
)
{
calls
.
push
(
set
{
formatPropertyName
(
propertyName
objectName
)
}
)
;
}
}
)
;
}
observeMethod
(
calls
object
propertyName
objectName
=
"
"
)
{
const
method
=
object
[
propertyName
]
;
object
[
propertyName
]
=
function
(
)
{
calls
.
push
(
call
{
formatPropertyName
(
propertyName
objectName
)
}
)
;
return
method
.
apply
(
object
arguments
)
;
}
;
}
SUBSTITUTE_SKIP
:
SKIP_SYMBOL
substituteMethod
(
object
propertyName
values
)
{
let
calls
=
0
;
const
method
=
object
[
propertyName
]
;
object
[
propertyName
]
=
function
(
)
{
if
(
calls
>
=
values
.
length
)
{
return
method
.
apply
(
object
arguments
)
;
}
else
if
(
values
[
calls
]
=
=
=
SKIP_SYMBOL
)
{
calls
+
+
;
return
method
.
apply
(
object
arguments
)
;
}
else
{
return
values
[
calls
+
+
]
;
}
}
;
}
propertyBagObserver
(
calls
propertyBag
objectName
skipToPrimitive
)
{
return
new
Proxy
(
propertyBag
{
ownKeys
(
target
)
{
calls
.
push
(
ownKeys
{
objectName
}
)
;
return
Reflect
.
ownKeys
(
target
)
;
}
getOwnPropertyDescriptor
(
target
key
)
{
calls
.
push
(
getOwnPropertyDescriptor
{
formatPropertyName
(
key
objectName
)
}
)
;
return
Reflect
.
getOwnPropertyDescriptor
(
target
key
)
;
}
get
(
target
key
receiver
)
{
calls
.
push
(
get
{
formatPropertyName
(
key
objectName
)
}
)
;
const
result
=
Reflect
.
get
(
target
key
receiver
)
;
if
(
result
=
=
=
undefined
)
{
return
undefined
;
}
if
(
(
result
!
=
=
null
&
&
typeof
result
=
=
=
"
object
"
)
|
|
typeof
result
=
=
=
"
function
"
)
{
return
result
;
}
if
(
skipToPrimitive
&
&
skipToPrimitive
.
indexOf
(
key
)
>
=
0
)
{
return
result
;
}
return
TemporalHelpers
.
toPrimitiveObserver
(
calls
result
{
formatPropertyName
(
key
objectName
)
}
)
;
}
has
(
target
key
)
{
calls
.
push
(
has
{
formatPropertyName
(
key
objectName
)
}
)
;
return
Reflect
.
has
(
target
key
)
;
}
}
)
;
}
toPrimitiveObserver
(
calls
primitiveValue
propertyName
)
{
return
{
get
valueOf
(
)
{
calls
.
push
(
get
{
propertyName
}
.
valueOf
)
;
return
function
(
)
{
calls
.
push
(
call
{
propertyName
}
.
valueOf
)
;
return
primitiveValue
;
}
;
}
get
toString
(
)
{
calls
.
push
(
get
{
propertyName
}
.
toString
)
;
return
function
(
)
{
calls
.
push
(
call
{
propertyName
}
.
toString
)
;
if
(
primitiveValue
=
=
=
undefined
)
return
undefined
;
return
primitiveValue
.
toString
(
)
;
}
;
}
}
;
}
ISO
:
{
plainMonthDayStringsInvalid
(
)
{
return
[
"
11
-
18junk
"
"
11
-
18
[
u
-
ca
=
gregory
]
"
"
11
-
18
[
u
-
ca
=
hebrew
]
"
"
11
-
18
[
U
-
CA
=
iso8601
]
"
"
11
-
18
[
u
-
CA
=
iso8601
]
"
"
11
-
18
[
FOO
=
bar
]
"
]
;
}
plainMonthDayStringsValid
(
)
{
return
[
"
10
-
01
"
"
1001
"
"
1965
-
10
-
01
"
"
1976
-
10
-
01T152330
.
1
+
00
:
00
"
"
19761001T15
:
23
:
30
.
1
+
00
:
00
"
"
1976
-
10
-
01T15
:
23
:
30
.
1
+
0000
"
"
1976
-
10
-
01T152330
.
1
+
0000
"
"
19761001T15
:
23
:
30
.
1
+
0000
"
"
19761001T152330
.
1
+
00
:
00
"
"
19761001T152330
.
1
+
0000
"
"
+
001976
-
10
-
01T152330
.
1
+
00
:
00
"
"
+
0019761001T15
:
23
:
30
.
1
+
00
:
00
"
"
+
001976
-
10
-
01T15
:
23
:
30
.
1
+
0000
"
"
+
001976
-
10
-
01T152330
.
1
+
0000
"
"
+
0019761001T15
:
23
:
30
.
1
+
0000
"
"
+
0019761001T152330
.
1
+
00
:
00
"
"
+
0019761001T152330
.
1
+
0000
"
"
1976
-
10
-
01T15
:
23
:
00
"
"
1976
-
10
-
01T15
:
23
"
"
1976
-
10
-
01T15
"
"
1976
-
10
-
01
"
"
-
-
10
-
01
"
"
-
-
1001
"
]
;
}
plainTimeStringsAmbiguous
(
)
{
const
ambiguousStrings
=
[
"
2021
-
12
"
"
2021
-
12
[
-
12
:
00
]
"
"
1214
"
"
0229
"
"
1130
"
"
12
-
14
"
"
12
-
14
[
-
14
:
00
]
"
"
202112
"
"
202112
[
UTC
]
"
]
;
const
stringsWithCalendar
=
ambiguousStrings
.
map
(
(
s
)
=
>
s
+
'
[
u
-
ca
=
iso8601
]
'
)
;
return
ambiguousStrings
.
concat
(
stringsWithCalendar
)
;
}
plainTimeStringsUnambiguous
(
)
{
return
[
"
2021
-
13
"
"
202113
"
"
2021
-
13
[
-
13
:
00
]
"
"
202113
[
-
13
:
00
]
"
"
0000
-
00
"
"
000000
"
"
0000
-
00
[
UTC
]
"
"
000000
[
UTC
]
"
"
1314
"
"
13
-
14
"
"
1232
"
"
0230
"
"
0631
"
"
0000
"
"
00
-
00
"
]
;
}
plainYearMonthStringsInvalid
(
)
{
return
[
"
2020
-
13
"
"
1976
-
11
[
u
-
ca
=
gregory
]
"
"
1976
-
11
[
u
-
ca
=
hebrew
]
"
"
1976
-
11
[
U
-
CA
=
iso8601
]
"
"
1976
-
11
[
u
-
CA
=
iso8601
]
"
"
1976
-
11
[
FOO
=
bar
]
"
]
;
}
plainYearMonthStringsValid
(
)
{
return
[
"
1976
-
11
"
"
1976
-
11
-
10
"
"
1976
-
11
-
01T09
:
00
:
00
+
00
:
00
"
"
1976
-
11
-
01T00
:
00
:
00
+
05
:
00
"
"
197611
"
"
+
00197611
"
"
1976
-
11
-
18T15
:
23
:
30
.
1
-
02
:
00
"
"
1976
-
11
-
18T152330
.
1
+
00
:
00
"
"
19761118T15
:
23
:
30
.
1
+
00
:
00
"
"
1976
-
11
-
18T15
:
23
:
30
.
1
+
0000
"
"
1976
-
11
-
18T152330
.
1
+
0000
"
"
19761118T15
:
23
:
30
.
1
+
0000
"
"
19761118T152330
.
1
+
00
:
00
"
"
19761118T152330
.
1
+
0000
"
"
+
001976
-
11
-
18T152330
.
1
+
00
:
00
"
"
+
0019761118T15
:
23
:
30
.
1
+
00
:
00
"
"
+
001976
-
11
-
18T15
:
23
:
30
.
1
+
0000
"
"
+
001976
-
11
-
18T152330
.
1
+
0000
"
"
+
0019761118T15
:
23
:
30
.
1
+
0000
"
"
+
0019761118T152330
.
1
+
00
:
00
"
"
+
0019761118T152330
.
1
+
0000
"
"
1976
-
11
-
18T15
:
23
"
"
1976
-
11
-
18T15
"
"
1976
-
11
-
18
"
]
;
}
plainYearMonthStringsValidNegativeYear
(
)
{
return
[
"
-
009999
-
11
"
]
;
}
}
}
;
