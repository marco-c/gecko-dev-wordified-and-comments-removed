function
asyncTest
(
testFunc
)
{
if
(
!
Object
.
hasOwn
(
globalThis
"
DONE
"
)
)
{
throw
new
Test262Error
(
"
asyncTest
called
without
async
flag
"
)
;
}
if
(
typeof
testFunc
!
=
=
"
function
"
)
{
DONE
(
new
Test262Error
(
"
asyncTest
called
with
non
-
function
argument
"
)
)
;
return
;
}
try
{
testFunc
(
)
.
then
(
function
(
)
{
DONE
(
)
;
}
function
(
error
)
{
DONE
(
error
)
;
}
)
;
}
catch
(
syncError
)
{
DONE
(
syncError
)
;
}
}
assert
.
throwsAsync
=
async
function
(
expectedErrorConstructor
func
message
)
{
var
innerThenable
;
if
(
message
=
=
=
undefined
)
{
message
=
"
"
;
}
else
{
message
+
=
"
"
;
}
if
(
typeof
func
=
=
=
"
function
"
)
{
try
{
innerThenable
=
func
(
)
;
if
(
innerThenable
=
=
=
null
|
|
typeof
innerThenable
!
=
=
"
object
"
|
|
typeof
innerThenable
.
then
!
=
=
"
function
"
)
{
message
+
=
"
Expected
to
obtain
an
inner
promise
that
would
reject
with
a
"
+
expectedErrorConstructor
.
name
+
"
but
result
was
not
a
thenable
"
;
throw
new
Test262Error
(
message
)
;
}
}
catch
(
thrown
)
{
message
+
=
"
Expected
a
"
+
expectedErrorConstructor
.
name
+
"
to
be
thrown
asynchronously
but
an
exception
was
thrown
synchronously
while
obtaining
the
inner
promise
"
;
throw
new
Test262Error
(
message
)
;
}
}
else
{
message
+
=
"
assert
.
throwsAsync
called
with
an
argument
that
is
not
a
function
"
;
throw
new
Test262Error
(
message
)
;
}
try
{
return
innerThenable
.
then
(
function
(
)
{
message
+
=
"
Expected
a
"
+
expectedErrorConstructor
.
name
+
"
to
be
thrown
asynchronously
but
no
exception
was
thrown
at
all
"
;
throw
new
Test262Error
(
message
)
;
}
function
(
thrown
)
{
var
expectedName
actualName
;
if
(
typeof
thrown
!
=
=
"
object
"
|
|
thrown
=
=
=
null
)
{
message
+
=
"
Thrown
value
was
not
an
object
!
"
;
throw
new
Test262Error
(
message
)
;
}
else
if
(
thrown
.
constructor
!
=
=
expectedErrorConstructor
)
{
expectedName
=
expectedErrorConstructor
.
name
;
actualName
=
thrown
.
constructor
.
name
;
if
(
expectedName
=
=
=
actualName
)
{
message
+
=
"
Expected
a
"
+
expectedName
+
"
but
got
a
different
error
constructor
with
the
same
name
"
;
}
else
{
message
+
=
"
Expected
a
"
+
expectedName
+
"
but
got
a
"
+
actualName
;
}
throw
new
Test262Error
(
message
)
;
}
}
)
;
}
catch
(
thrown
)
{
if
(
typeof
thrown
!
=
=
"
object
"
|
|
thrown
=
=
=
null
)
{
message
+
=
"
Expected
a
"
+
expectedErrorConstructor
.
name
+
"
to
be
thrown
asynchronously
but
innerThenable
synchronously
threw
a
value
that
was
not
an
object
"
;
}
else
{
message
+
=
"
Expected
a
"
+
expectedErrorConstructor
.
name
+
"
to
be
thrown
asynchronously
but
a
"
+
thrown
.
constructor
.
name
+
"
was
thrown
synchronously
"
;
}
throw
new
Test262Error
(
message
)
;
}
}
;
const
ASCII_IDENTIFIER
=
/
^
[
_a
-
zA
-
Z
]
[
_a
-
zA
-
Z0
-
9
]
*
/
u
;
function
formatPropertyName
(
propertyKey
objectName
=
"
"
)
{
switch
(
typeof
propertyKey
)
{
case
"
symbol
"
:
if
(
Symbol
.
keyFor
(
propertyKey
)
!
=
=
undefined
)
{
return
{
objectName
}
[
Symbol
.
for
(
'
{
Symbol
.
keyFor
(
propertyKey
)
}
'
)
]
;
}
else
if
(
propertyKey
.
description
.
startsWith
(
'
Symbol
.
'
)
)
{
return
{
objectName
}
[
{
propertyKey
.
description
}
]
;
}
else
{
return
{
objectName
}
[
Symbol
(
'
{
propertyKey
.
description
}
'
)
]
}
case
"
string
"
:
if
(
propertyKey
!
=
=
String
(
Number
(
propertyKey
)
)
)
{
if
(
ASCII_IDENTIFIER
.
test
(
propertyKey
)
)
{
return
objectName
?
{
objectName
}
.
{
propertyKey
}
:
propertyKey
;
}
return
{
objectName
}
[
'
{
propertyKey
.
replace
(
/
'
/
g
"
\
\
'
"
)
}
'
]
}
default
:
return
{
objectName
}
[
{
propertyKey
}
]
;
}
}
const
SKIP_SYMBOL
=
Symbol
(
"
Skip
"
)
;
var
TemporalHelpers
=
{
ISOMonths
:
[
{
month
:
1
monthCode
:
"
M01
"
daysInMonth
:
31
}
{
month
:
2
monthCode
:
"
M02
"
daysInMonth
:
29
}
{
month
:
3
monthCode
:
"
M03
"
daysInMonth
:
31
}
{
month
:
4
monthCode
:
"
M04
"
daysInMonth
:
30
}
{
month
:
5
monthCode
:
"
M05
"
daysInMonth
:
31
}
{
month
:
6
monthCode
:
"
M06
"
daysInMonth
:
30
}
{
month
:
7
monthCode
:
"
M07
"
daysInMonth
:
31
}
{
month
:
8
monthCode
:
"
M08
"
daysInMonth
:
31
}
{
month
:
9
monthCode
:
"
M09
"
daysInMonth
:
30
}
{
month
:
10
monthCode
:
"
M10
"
daysInMonth
:
31
}
{
month
:
11
monthCode
:
"
M11
"
daysInMonth
:
30
}
{
month
:
12
monthCode
:
"
M12
"
daysInMonth
:
31
}
]
assertDuration
(
duration
years
months
weeks
days
hours
minutes
seconds
milliseconds
microseconds
nanoseconds
description
=
"
"
)
{
assert
(
duration
instanceof
Temporal
.
Duration
{
description
}
instanceof
)
;
assert
.
sameValue
(
duration
.
years
years
{
description
}
years
result
)
;
assert
.
sameValue
(
duration
.
months
months
{
description
}
months
result
)
;
assert
.
sameValue
(
duration
.
weeks
weeks
{
description
}
weeks
result
)
;
assert
.
sameValue
(
duration
.
days
days
{
description
}
days
result
)
;
assert
.
sameValue
(
duration
.
hours
hours
{
description
}
hours
result
)
;
assert
.
sameValue
(
duration
.
minutes
minutes
{
description
}
minutes
result
)
;
assert
.
sameValue
(
duration
.
seconds
seconds
{
description
}
seconds
result
)
;
assert
.
sameValue
(
duration
.
milliseconds
milliseconds
{
description
}
milliseconds
result
)
;
assert
.
sameValue
(
duration
.
microseconds
microseconds
{
description
}
microseconds
result
)
;
assert
.
sameValue
(
duration
.
nanoseconds
nanoseconds
{
description
}
nanoseconds
result
)
;
}
assertDateDuration
(
duration
years
months
weeks
days
description
=
"
"
)
{
assert
(
duration
instanceof
Temporal
.
Duration
{
description
}
instanceof
)
;
assert
.
sameValue
(
duration
.
years
years
{
description
}
years
result
)
;
assert
.
sameValue
(
duration
.
months
months
{
description
}
months
result
)
;
assert
.
sameValue
(
duration
.
weeks
weeks
{
description
}
weeks
result
)
;
assert
.
sameValue
(
duration
.
days
days
{
description
}
days
result
)
;
assert
.
sameValue
(
duration
.
hours
0
{
description
}
hours
result
should
be
zero
)
;
assert
.
sameValue
(
duration
.
minutes
0
{
description
}
minutes
result
should
be
zero
)
;
assert
.
sameValue
(
duration
.
seconds
0
{
description
}
seconds
result
should
be
zero
)
;
assert
.
sameValue
(
duration
.
milliseconds
0
{
description
}
milliseconds
result
should
be
zero
)
;
assert
.
sameValue
(
duration
.
microseconds
0
{
description
}
microseconds
result
should
be
zero
)
;
assert
.
sameValue
(
duration
.
nanoseconds
0
{
description
}
nanoseconds
result
should
be
zero
)
;
}
assertDurationsEqual
(
actual
expected
description
=
"
"
)
{
assert
(
expected
instanceof
Temporal
.
Duration
{
description
}
expected
value
should
be
a
Temporal
.
Duration
)
;
TemporalHelpers
.
assertDuration
(
actual
expected
.
years
expected
.
months
expected
.
weeks
expected
.
days
expected
.
hours
expected
.
minutes
expected
.
seconds
expected
.
milliseconds
expected
.
microseconds
expected
.
nanoseconds
description
)
;
}
assertInstantsEqual
(
actual
expected
description
=
"
"
)
{
assert
(
expected
instanceof
Temporal
.
Instant
{
description
}
expected
value
should
be
a
Temporal
.
Instant
)
;
assert
(
actual
instanceof
Temporal
.
Instant
{
description
}
instanceof
)
;
assert
(
actual
.
equals
(
expected
)
{
description
}
equals
method
)
;
}
assertPlainDate
(
date
year
month
monthCode
day
description
=
"
"
era
=
undefined
eraYear
=
undefined
)
{
assert
(
date
instanceof
Temporal
.
PlainDate
{
description
}
instanceof
)
;
assert
.
sameValue
(
date
.
era
era
{
description
}
era
result
)
;
assert
.
sameValue
(
date
.
eraYear
eraYear
{
description
}
eraYear
result
)
;
assert
.
sameValue
(
date
.
year
year
{
description
}
year
result
)
;
assert
.
sameValue
(
date
.
month
month
{
description
}
month
result
)
;
assert
.
sameValue
(
date
.
monthCode
monthCode
{
description
}
monthCode
result
)
;
assert
.
sameValue
(
date
.
day
day
{
description
}
day
result
)
;
}
assertPlainDateTime
(
datetime
year
month
monthCode
day
hour
minute
second
millisecond
microsecond
nanosecond
description
=
"
"
era
=
undefined
eraYear
=
undefined
)
{
assert
(
datetime
instanceof
Temporal
.
PlainDateTime
{
description
}
instanceof
)
;
assert
.
sameValue
(
datetime
.
era
era
{
description
}
era
result
)
;
assert
.
sameValue
(
datetime
.
eraYear
eraYear
{
description
}
eraYear
result
)
;
assert
.
sameValue
(
datetime
.
year
year
{
description
}
year
result
)
;
assert
.
sameValue
(
datetime
.
month
month
{
description
}
month
result
)
;
assert
.
sameValue
(
datetime
.
monthCode
monthCode
{
description
}
monthCode
result
)
;
assert
.
sameValue
(
datetime
.
day
day
{
description
}
day
result
)
;
assert
.
sameValue
(
datetime
.
hour
hour
{
description
}
hour
result
)
;
assert
.
sameValue
(
datetime
.
minute
minute
{
description
}
minute
result
)
;
assert
.
sameValue
(
datetime
.
second
second
{
description
}
second
result
)
;
assert
.
sameValue
(
datetime
.
millisecond
millisecond
{
description
}
millisecond
result
)
;
assert
.
sameValue
(
datetime
.
microsecond
microsecond
{
description
}
microsecond
result
)
;
assert
.
sameValue
(
datetime
.
nanosecond
nanosecond
{
description
}
nanosecond
result
)
;
}
assertPlainDateTimesEqual
(
actual
expected
description
=
"
"
)
{
assert
(
expected
instanceof
Temporal
.
PlainDateTime
{
description
}
expected
value
should
be
a
Temporal
.
PlainDateTime
)
;
assert
(
actual
instanceof
Temporal
.
PlainDateTime
{
description
}
instanceof
)
;
assert
(
actual
.
equals
(
expected
)
{
description
}
equals
method
)
;
assert
.
sameValue
(
actual
.
getISOFields
(
)
.
calendar
expected
.
getISOFields
(
)
.
calendar
{
description
}
calendar
same
value
)
;
}
assertPlainMonthDay
(
monthDay
monthCode
day
description
=
"
"
referenceISOYear
=
1972
)
{
assert
(
monthDay
instanceof
Temporal
.
PlainMonthDay
{
description
}
instanceof
)
;
assert
.
sameValue
(
monthDay
.
monthCode
monthCode
{
description
}
monthCode
result
)
;
assert
.
sameValue
(
monthDay
.
day
day
{
description
}
day
result
)
;
assert
.
sameValue
(
monthDay
.
getISOFields
(
)
.
isoYear
referenceISOYear
{
description
}
referenceISOYear
result
)
;
}
assertPlainTime
(
time
hour
minute
second
millisecond
microsecond
nanosecond
description
=
"
"
)
{
assert
(
time
instanceof
Temporal
.
PlainTime
{
description
}
instanceof
)
;
assert
.
sameValue
(
time
.
hour
hour
{
description
}
hour
result
)
;
assert
.
sameValue
(
time
.
minute
minute
{
description
}
minute
result
)
;
assert
.
sameValue
(
time
.
second
second
{
description
}
second
result
)
;
assert
.
sameValue
(
time
.
millisecond
millisecond
{
description
}
millisecond
result
)
;
assert
.
sameValue
(
time
.
microsecond
microsecond
{
description
}
microsecond
result
)
;
assert
.
sameValue
(
time
.
nanosecond
nanosecond
{
description
}
nanosecond
result
)
;
}
assertPlainTimesEqual
(
actual
expected
description
=
"
"
)
{
assert
(
expected
instanceof
Temporal
.
PlainTime
{
description
}
expected
value
should
be
a
Temporal
.
PlainTime
)
;
assert
(
actual
instanceof
Temporal
.
PlainTime
{
description
}
instanceof
)
;
assert
(
actual
.
equals
(
expected
)
{
description
}
equals
method
)
;
}
assertPlainYearMonth
(
yearMonth
year
month
monthCode
description
=
"
"
era
=
undefined
eraYear
=
undefined
referenceISODay
=
1
)
{
assert
(
yearMonth
instanceof
Temporal
.
PlainYearMonth
{
description
}
instanceof
)
;
assert
.
sameValue
(
yearMonth
.
era
era
{
description
}
era
result
)
;
assert
.
sameValue
(
yearMonth
.
eraYear
eraYear
{
description
}
eraYear
result
)
;
assert
.
sameValue
(
yearMonth
.
year
year
{
description
}
year
result
)
;
assert
.
sameValue
(
yearMonth
.
month
month
{
description
}
month
result
)
;
assert
.
sameValue
(
yearMonth
.
monthCode
monthCode
{
description
}
monthCode
result
)
;
assert
.
sameValue
(
yearMonth
.
getISOFields
(
)
.
isoDay
referenceISODay
{
description
}
referenceISODay
result
)
;
}
assertZonedDateTimesEqual
(
actual
expected
description
=
"
"
)
{
assert
(
expected
instanceof
Temporal
.
ZonedDateTime
{
description
}
expected
value
should
be
a
Temporal
.
ZonedDateTime
)
;
assert
(
actual
instanceof
Temporal
.
ZonedDateTime
{
description
}
instanceof
)
;
assert
(
actual
.
equals
(
expected
)
{
description
}
equals
method
)
;
assert
.
sameValue
(
actual
.
timeZone
expected
.
timeZone
{
description
}
time
zone
same
value
)
;
assert
.
sameValue
(
actual
.
getISOFields
(
)
.
calendar
expected
.
getISOFields
(
)
.
calendar
{
description
}
calendar
same
value
)
;
}
assertUnreachable
(
description
)
{
let
message
=
"
This
code
should
not
be
executed
"
;
if
(
description
)
{
message
=
{
message
}
:
{
description
}
;
}
throw
new
Test262Error
(
message
)
;
}
checkCalendarDateUntilLargestUnitSingular
(
func
expectedLargestUnitCalls
)
{
const
actual
=
[
]
;
class
DateUntilOptionsCalendar
extends
Temporal
.
Calendar
{
constructor
(
)
{
super
(
"
iso8601
"
)
;
}
dateUntil
(
earlier
later
options
)
{
actual
.
push
(
options
.
largestUnit
)
;
return
super
.
dateUntil
(
earlier
later
options
)
;
}
toString
(
)
{
return
"
date
-
until
-
options
"
;
}
}
const
calendar
=
new
DateUntilOptionsCalendar
(
)
;
Object
.
entries
(
expectedLargestUnitCalls
)
.
forEach
(
(
[
largestUnit
expected
]
index
)
=
>
{
func
(
calendar
largestUnit
index
)
;
assert
.
compareArray
(
actual
expected
largestUnit
passed
to
calendar
.
dateUntil
(
)
for
largestUnit
{
largestUnit
}
)
;
actual
.
splice
(
0
)
;
}
)
;
}
checkPlainDateTimeConversionFastPath
(
func
message
=
"
checkPlainDateTimeConversionFastPath
"
)
{
const
actual
=
[
]
;
const
expected
=
[
]
;
const
calendar
=
new
Temporal
.
Calendar
(
"
iso8601
"
)
;
const
datetime
=
new
Temporal
.
PlainDateTime
(
2000
5
2
12
34
56
987
654
321
calendar
)
;
const
prototypeDescrs
=
Object
.
getOwnPropertyDescriptors
(
Temporal
.
PlainDateTime
.
prototype
)
;
[
"
year
"
"
month
"
"
monthCode
"
"
day
"
"
hour
"
"
minute
"
"
second
"
"
millisecond
"
"
microsecond
"
"
nanosecond
"
]
.
forEach
(
(
property
)
=
>
{
Object
.
defineProperty
(
datetime
property
{
get
(
)
{
actual
.
push
(
get
{
formatPropertyName
(
property
)
}
)
;
const
value
=
prototypeDescrs
[
property
]
.
get
.
call
(
this
)
;
return
{
toString
(
)
{
actual
.
push
(
toString
{
formatPropertyName
(
property
)
}
)
;
return
value
.
toString
(
)
;
}
valueOf
(
)
{
actual
.
push
(
valueOf
{
formatPropertyName
(
property
)
}
)
;
return
value
;
}
}
;
}
}
)
;
}
)
;
Object
.
defineProperty
(
datetime
"
calendar
"
{
get
(
)
{
actual
.
push
(
"
get
calendar
"
)
;
return
calendar
;
}
}
)
;
func
(
datetime
calendar
)
;
assert
.
compareArray
(
actual
expected
{
message
}
:
property
getters
not
called
)
;
}
checkPluralUnitsAccepted
(
func
validSingularUnits
)
{
const
plurals
=
{
year
:
'
years
'
month
:
'
months
'
week
:
'
weeks
'
day
:
'
days
'
hour
:
'
hours
'
minute
:
'
minutes
'
second
:
'
seconds
'
millisecond
:
'
milliseconds
'
microsecond
:
'
microseconds
'
nanosecond
:
'
nanoseconds
'
}
;
validSingularUnits
.
forEach
(
(
unit
)
=
>
{
const
singularValue
=
func
(
unit
)
;
const
pluralValue
=
func
(
plurals
[
unit
]
)
;
const
desc
=
Plural
{
plurals
[
unit
]
}
produces
the
same
result
as
singular
{
unit
}
;
if
(
singularValue
instanceof
Temporal
.
Duration
)
{
TemporalHelpers
.
assertDurationsEqual
(
pluralValue
singularValue
desc
)
;
}
else
if
(
singularValue
instanceof
Temporal
.
Instant
)
{
TemporalHelpers
.
assertInstantsEqual
(
pluralValue
singularValue
desc
)
;
}
else
if
(
singularValue
instanceof
Temporal
.
PlainDateTime
)
{
TemporalHelpers
.
assertPlainDateTimesEqual
(
pluralValue
singularValue
desc
)
;
}
else
if
(
singularValue
instanceof
Temporal
.
PlainTime
)
{
TemporalHelpers
.
assertPlainTimesEqual
(
pluralValue
singularValue
desc
)
;
}
else
if
(
singularValue
instanceof
Temporal
.
ZonedDateTime
)
{
TemporalHelpers
.
assertZonedDateTimesEqual
(
pluralValue
singularValue
desc
)
;
}
else
{
assert
.
sameValue
(
pluralValue
singularValue
)
;
}
}
)
;
}
checkRoundingIncrementOptionWrongType
(
checkFunc
assertTrueResultFunc
assertObjectResultFunc
)
{
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
null
)
"
null
"
)
;
const
trueResult
=
checkFunc
(
true
)
;
assertTrueResultFunc
(
trueResult
"
true
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
false
)
"
false
"
)
;
assert
.
throws
(
TypeError
(
)
=
>
checkFunc
(
Symbol
(
)
)
"
symbol
"
)
;
assert
.
throws
(
TypeError
(
)
=
>
checkFunc
(
2n
)
"
bigint
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
{
}
)
"
plain
object
"
)
;
const
expected
=
[
"
get
roundingIncrement
.
valueOf
"
"
call
roundingIncrement
.
valueOf
"
]
;
const
actual
=
[
]
;
const
observer
=
TemporalHelpers
.
toPrimitiveObserver
(
actual
2
"
roundingIncrement
"
)
;
const
objectResult
=
checkFunc
(
observer
)
;
assertObjectResultFunc
(
objectResult
"
object
with
valueOf
"
)
;
assert
.
compareArray
(
actual
expected
"
order
of
operations
"
)
;
}
checkStringOptionWrongType
(
propertyName
value
checkFunc
assertFunc
)
{
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
null
)
"
null
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
true
)
"
true
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
false
)
"
false
"
)
;
assert
.
throws
(
TypeError
(
)
=
>
checkFunc
(
Symbol
(
)
)
"
symbol
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
2
)
"
number
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
2n
)
"
bigint
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
checkFunc
(
{
}
)
"
plain
object
"
)
;
const
expected
=
[
get
{
propertyName
}
.
toString
call
{
propertyName
}
.
toString
]
;
const
actual
=
[
]
;
const
observer
=
TemporalHelpers
.
toPrimitiveObserver
(
actual
value
propertyName
)
;
const
result
=
checkFunc
(
observer
)
;
assertFunc
(
result
"
object
with
toString
"
)
;
assert
.
compareArray
(
actual
expected
"
order
of
operations
"
)
;
}
checkSubclassingIgnored
(
.
.
.
args
)
{
this
.
checkSubclassConstructorNotObject
(
.
.
.
args
)
;
this
.
checkSubclassConstructorUndefined
(
.
.
.
args
)
;
this
.
checkSubclassConstructorThrows
(
.
.
.
args
)
;
this
.
checkSubclassConstructorNotCalled
(
.
.
.
args
)
;
this
.
checkSubclassSpeciesInvalidResult
(
.
.
.
args
)
;
this
.
checkSubclassSpeciesNotAConstructor
(
.
.
.
args
)
;
this
.
checkSubclassSpeciesNull
(
.
.
.
args
)
;
this
.
checkSubclassSpeciesUndefined
(
.
.
.
args
)
;
this
.
checkSubclassSpeciesThrows
(
.
.
.
args
)
;
}
checkSubclassConstructorNotObject
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
function
check
(
value
description
)
{
const
instance
=
new
construct
(
.
.
.
constructArgs
)
;
instance
.
constructor
=
value
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
description
)
;
resultAssertions
(
result
)
;
}
check
(
null
"
null
"
)
;
check
(
true
"
true
"
)
;
check
(
"
test
"
"
string
"
)
;
check
(
Symbol
(
)
"
Symbol
"
)
;
check
(
7
"
number
"
)
;
check
(
7n
"
bigint
"
)
;
}
checkSubclassConstructorUndefined
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
let
called
=
0
;
class
MySubclass
extends
construct
{
constructor
(
)
{
+
+
called
;
super
(
.
.
.
constructArgs
)
;
}
}
const
instance
=
new
MySubclass
(
)
;
assert
.
sameValue
(
called
1
)
;
MySubclass
.
prototype
.
constructor
=
undefined
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
called
1
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
checkSubclassConstructorThrows
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
function
CustomError
(
)
{
}
const
instance
=
new
construct
(
.
.
.
constructArgs
)
;
Object
.
defineProperty
(
instance
"
constructor
"
{
get
(
)
{
throw
new
CustomError
(
)
;
}
}
)
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
checkSubclassConstructorNotCalled
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
let
called
=
0
;
class
MySubclass
extends
construct
{
constructor
(
)
{
+
+
called
;
super
(
.
.
.
constructArgs
)
;
}
}
const
instance
=
new
MySubclass
(
)
;
assert
.
sameValue
(
called
1
)
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
called
1
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
checkSubclassSpeciesInvalidResult
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
function
check
(
value
description
)
{
const
instance
=
new
construct
(
.
.
.
constructArgs
)
;
instance
.
constructor
=
{
[
Symbol
.
species
]
:
function
(
)
{
return
value
;
}
}
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
description
)
;
resultAssertions
(
result
)
;
}
check
(
undefined
"
undefined
"
)
;
check
(
null
"
null
"
)
;
check
(
true
"
true
"
)
;
check
(
"
test
"
"
string
"
)
;
check
(
Symbol
(
)
"
Symbol
"
)
;
check
(
7
"
number
"
)
;
check
(
7n
"
bigint
"
)
;
check
(
{
}
"
plain
object
"
)
;
}
checkSubclassSpeciesNotAConstructor
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
function
check
(
value
description
)
{
const
instance
=
new
construct
(
.
.
.
constructArgs
)
;
instance
.
constructor
=
{
[
Symbol
.
species
]
:
value
}
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
description
)
;
resultAssertions
(
result
)
;
}
check
(
true
"
true
"
)
;
check
(
"
test
"
"
string
"
)
;
check
(
Symbol
(
)
"
Symbol
"
)
;
check
(
7
"
number
"
)
;
check
(
7n
"
bigint
"
)
;
check
(
{
}
"
plain
object
"
)
;
}
checkSubclassSpeciesNull
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
let
called
=
0
;
class
MySubclass
extends
construct
{
constructor
(
)
{
+
+
called
;
super
(
.
.
.
constructArgs
)
;
}
}
const
instance
=
new
MySubclass
(
)
;
assert
.
sameValue
(
called
1
)
;
MySubclass
.
prototype
.
constructor
=
{
[
Symbol
.
species
]
:
null
}
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
called
1
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
checkSubclassSpeciesUndefined
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
let
called
=
0
;
class
MySubclass
extends
construct
{
constructor
(
)
{
+
+
called
;
super
(
.
.
.
constructArgs
)
;
}
}
const
instance
=
new
MySubclass
(
)
;
assert
.
sameValue
(
called
1
)
;
MySubclass
.
prototype
.
constructor
=
{
[
Symbol
.
species
]
:
undefined
}
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
called
1
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
checkSubclassSpeciesThrows
(
construct
constructArgs
method
methodArgs
resultAssertions
)
{
function
CustomError
(
)
{
}
const
instance
=
new
construct
(
.
.
.
constructArgs
)
;
instance
.
constructor
=
{
get
[
Symbol
.
species
]
(
)
{
throw
new
CustomError
(
)
;
}
}
;
const
result
=
instance
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
}
checkSubclassingIgnoredStatic
(
.
.
.
args
)
{
this
.
checkStaticInvalidReceiver
(
.
.
.
args
)
;
this
.
checkStaticReceiverNotCalled
(
.
.
.
args
)
;
this
.
checkThisValueNotCalled
(
.
.
.
args
)
;
}
checkStaticInvalidReceiver
(
construct
method
methodArgs
resultAssertions
)
{
function
check
(
value
description
)
{
const
result
=
construct
[
method
]
.
apply
(
value
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
check
(
undefined
"
undefined
"
)
;
check
(
null
"
null
"
)
;
check
(
true
"
true
"
)
;
check
(
"
test
"
"
string
"
)
;
check
(
Symbol
(
)
"
symbol
"
)
;
check
(
7
"
number
"
)
;
check
(
7n
"
bigint
"
)
;
check
(
{
}
"
Non
-
callable
object
"
)
;
}
checkStaticReceiverNotCalled
(
construct
method
methodArgs
resultAssertions
)
{
function
check
(
value
description
)
{
const
receiver
=
function
(
)
{
return
value
;
}
;
const
result
=
construct
[
method
]
.
apply
(
receiver
methodArgs
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
check
(
undefined
"
undefined
"
)
;
check
(
null
"
null
"
)
;
check
(
true
"
true
"
)
;
check
(
"
test
"
"
string
"
)
;
check
(
Symbol
(
)
"
symbol
"
)
;
check
(
7
"
number
"
)
;
check
(
7n
"
bigint
"
)
;
check
(
{
}
"
Non
-
callable
object
"
)
;
}
checkThisValueNotCalled
(
construct
method
methodArgs
resultAssertions
)
{
let
called
=
false
;
class
MySubclass
extends
construct
{
constructor
(
.
.
.
args
)
{
called
=
true
;
super
(
.
.
.
args
)
;
}
}
const
result
=
MySubclass
[
method
]
(
.
.
.
methodArgs
)
;
assert
.
sameValue
(
called
false
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
result
)
construct
.
prototype
)
;
resultAssertions
(
result
)
;
}
checkTimeZonePossibleInstantsIterable
(
func
expected
)
{
class
TimeZonePossibleInstantsIterable
extends
Temporal
.
TimeZone
{
constructor
(
)
{
super
(
"
UTC
"
)
;
this
.
getPossibleInstantsForCallCount
=
0
;
this
.
getPossibleInstantsForCalledWith
=
[
]
;
this
.
getPossibleInstantsForReturns
=
[
]
;
this
.
iteratorExhausted
=
[
]
;
}
toString
(
)
{
return
"
Custom
/
Iterable
"
;
}
getOffsetNanosecondsFor
(
instant
)
{
if
(
Temporal
.
Instant
.
compare
(
instant
"
2030
-
01
-
01T00
:
00Z
"
)
>
=
0
&
&
Temporal
.
Instant
.
compare
(
instant
"
2030
-
01
-
03T01
:
00Z
"
)
<
0
)
{
return
3600_000_000_000
;
}
else
{
return
0
;
}
}
getPossibleInstantsFor
(
dateTime
)
{
this
.
getPossibleInstantsForCallCount
+
+
;
this
.
getPossibleInstantsForCalledWith
.
push
(
dateTime
)
;
let
retval
=
super
.
getPossibleInstantsFor
(
dateTime
)
;
if
(
dateTime
.
toPlainDate
(
)
.
equals
(
"
2030
-
01
-
01
"
)
&
&
dateTime
.
hour
=
=
=
0
)
{
retval
=
[
]
;
}
else
if
(
dateTime
.
toPlainDate
(
)
.
equals
(
"
2030
-
01
-
03
"
)
&
&
dateTime
.
hour
=
=
=
0
)
{
retval
.
push
(
retval
[
0
]
.
subtract
(
{
hours
:
1
}
)
)
;
}
else
if
(
dateTime
.
year
=
=
=
2030
&
&
dateTime
.
month
=
=
=
1
&
&
dateTime
.
day
>
=
1
&
&
dateTime
.
day
<
=
2
)
{
retval
[
0
]
=
retval
[
0
]
.
subtract
(
{
hours
:
1
}
)
;
}
this
.
getPossibleInstantsForReturns
.
push
(
retval
)
;
this
.
iteratorExhausted
.
push
(
false
)
;
return
{
callIndex
:
this
.
getPossibleInstantsForCallCount
-
1
timeZone
:
this
*
[
Symbol
.
iterator
]
(
)
{
yield
*
this
.
timeZone
.
getPossibleInstantsForReturns
[
this
.
callIndex
]
;
this
.
timeZone
.
iteratorExhausted
[
this
.
callIndex
]
=
true
;
}
}
;
}
}
const
timeZone
=
new
TimeZonePossibleInstantsIterable
(
)
;
func
(
timeZone
)
;
assert
.
sameValue
(
timeZone
.
getPossibleInstantsForCallCount
expected
.
length
"
getPossibleInstantsFor
(
)
method
called
correct
number
of
times
"
)
;
for
(
let
index
=
0
;
index
<
expected
.
length
;
index
+
+
)
{
assert
.
sameValue
(
timeZone
.
getPossibleInstantsForCalledWith
[
index
]
.
toString
(
)
expected
[
index
]
"
getPossibleInstantsFor
(
)
called
with
expected
PlainDateTime
"
)
;
assert
(
timeZone
.
iteratorExhausted
[
index
]
"
iterated
through
the
whole
iterable
"
)
;
}
}
checkToTemporalCalendarFastPath
(
func
)
{
class
CalendarFastPathCheck
extends
Temporal
.
Calendar
{
constructor
(
)
{
super
(
"
iso8601
"
)
;
}
dateFromFields
(
.
.
.
args
)
{
return
super
.
dateFromFields
(
.
.
.
args
)
.
withCalendar
(
this
)
;
}
monthDayFromFields
(
.
.
.
args
)
{
const
{
isoYear
isoMonth
isoDay
}
=
super
.
monthDayFromFields
(
.
.
.
args
)
.
getISOFields
(
)
;
return
new
Temporal
.
PlainMonthDay
(
isoMonth
isoDay
this
isoYear
)
;
}
yearMonthFromFields
(
.
.
.
args
)
{
const
{
isoYear
isoMonth
isoDay
}
=
super
.
yearMonthFromFields
(
.
.
.
args
)
.
getISOFields
(
)
;
return
new
Temporal
.
PlainYearMonth
(
isoYear
isoMonth
this
isoDay
)
;
}
toString
(
)
{
return
"
fast
-
path
-
check
"
;
}
}
const
calendar
=
new
CalendarFastPathCheck
(
)
;
const
plainDate
=
new
Temporal
.
PlainDate
(
2000
5
2
calendar
)
;
const
plainDateTime
=
new
Temporal
.
PlainDateTime
(
2000
5
2
12
34
56
987
654
321
calendar
)
;
const
plainMonthDay
=
new
Temporal
.
PlainMonthDay
(
5
2
calendar
)
;
const
plainYearMonth
=
new
Temporal
.
PlainYearMonth
(
2000
5
calendar
)
;
const
zonedDateTime
=
new
Temporal
.
ZonedDateTime
(
1_000_000_000_000_000_000n
"
UTC
"
calendar
)
;
[
plainDate
plainDateTime
plainMonthDay
plainYearMonth
zonedDateTime
]
.
forEach
(
(
temporalObject
)
=
>
{
const
actual
=
[
]
;
const
expected
=
[
]
;
Object
.
defineProperty
(
temporalObject
"
calendar
"
{
get
(
)
{
actual
.
push
(
"
get
calendar
"
)
;
return
calendar
;
}
}
)
;
func
(
temporalObject
calendar
)
;
assert
.
compareArray
(
actual
expected
"
calendar
getter
not
called
"
)
;
}
)
;
}
checkToTemporalInstantFastPath
(
func
)
{
const
actual
=
[
]
;
const
expected
=
[
]
;
const
datetime
=
new
Temporal
.
ZonedDateTime
(
1_000_000_000_987_654_321n
"
UTC
"
)
;
Object
.
defineProperty
(
datetime
'
toString
'
{
get
(
)
{
actual
.
push
(
"
get
toString
"
)
;
return
function
(
options
)
{
actual
.
push
(
"
call
toString
"
)
;
return
Temporal
.
ZonedDateTime
.
prototype
.
toString
.
call
(
this
options
)
;
}
;
}
}
)
;
func
(
datetime
)
;
assert
.
compareArray
(
actual
expected
"
toString
not
called
"
)
;
}
checkToTemporalPlainDateTimeFastPath
(
func
)
{
const
actual
=
[
]
;
const
expected
=
[
]
;
const
calendar
=
new
Temporal
.
Calendar
(
"
iso8601
"
)
;
const
date
=
new
Temporal
.
PlainDate
(
2000
5
2
calendar
)
;
const
prototypeDescrs
=
Object
.
getOwnPropertyDescriptors
(
Temporal
.
PlainDate
.
prototype
)
;
[
"
year
"
"
month
"
"
monthCode
"
"
day
"
]
.
forEach
(
(
property
)
=
>
{
Object
.
defineProperty
(
date
property
{
get
(
)
{
actual
.
push
(
get
{
formatPropertyName
(
property
)
}
)
;
const
value
=
prototypeDescrs
[
property
]
.
get
.
call
(
this
)
;
return
TemporalHelpers
.
toPrimitiveObserver
(
actual
value
property
)
;
}
}
)
;
}
)
;
[
"
hour
"
"
minute
"
"
second
"
"
millisecond
"
"
microsecond
"
"
nanosecond
"
]
.
forEach
(
(
property
)
=
>
{
Object
.
defineProperty
(
date
property
{
get
(
)
{
actual
.
push
(
get
{
formatPropertyName
(
property
)
}
)
;
return
undefined
;
}
}
)
;
}
)
;
Object
.
defineProperty
(
date
"
calendar
"
{
get
(
)
{
actual
.
push
(
"
get
calendar
"
)
;
return
calendar
;
}
}
)
;
func
(
date
calendar
)
;
assert
.
compareArray
(
actual
expected
"
property
getters
not
called
"
)
;
}
calendarCheckFieldsPrototypePollution
(
)
{
class
CalendarCheckFieldsPrototypePollution
extends
Temporal
.
Calendar
{
constructor
(
)
{
super
(
"
iso8601
"
)
;
this
.
dateFromFieldsCallCount
=
0
;
this
.
yearMonthFromFieldsCallCount
=
0
;
this
.
monthDayFromFieldsCallCount
=
0
;
}
dateFromFields
(
fields
options
=
{
}
)
{
this
.
dateFromFieldsCallCount
+
+
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
fields
)
null
"
dateFromFields
should
be
called
with
null
-
prototype
fields
object
"
)
;
return
super
.
dateFromFields
(
fields
options
)
;
}
yearMonthFromFields
(
fields
options
=
{
}
)
{
this
.
yearMonthFromFieldsCallCount
+
+
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
fields
)
null
"
yearMonthFromFields
should
be
called
with
null
-
prototype
fields
object
"
)
;
return
super
.
yearMonthFromFields
(
fields
options
)
;
}
monthDayFromFields
(
fields
options
=
{
}
)
{
this
.
monthDayFromFieldsCallCount
+
+
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
fields
)
null
"
monthDayFromFields
should
be
called
with
null
-
prototype
fields
object
"
)
;
return
super
.
monthDayFromFields
(
fields
options
)
;
}
}
return
new
CalendarCheckFieldsPrototypePollution
(
)
;
}
calendarCheckMergeFieldsPrototypePollution
(
)
{
class
CalendarCheckMergeFieldsPrototypePollution
extends
Temporal
.
Calendar
{
constructor
(
)
{
super
(
"
iso8601
"
)
;
this
.
mergeFieldsCallCount
=
0
;
}
toString
(
)
{
return
"
merge
-
fields
-
null
-
proto
"
;
}
mergeFields
(
fields
additionalFields
)
{
this
.
mergeFieldsCallCount
+
+
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
fields
)
null
"
mergeFields
should
be
called
with
null
-
prototype
fields
object
(
first
argument
)
"
)
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
additionalFields
)
null
"
mergeFields
should
be
called
with
null
-
prototype
fields
object
(
second
argument
)
"
)
;
return
super
.
mergeFields
(
fields
additionalFields
)
;
}
}
return
new
CalendarCheckMergeFieldsPrototypePollution
(
)
;
}
calendarCheckOptionsPrototypePollution
(
)
{
class
CalendarCheckOptionsPrototypePollution
extends
Temporal
.
Calendar
{
constructor
(
)
{
super
(
"
iso8601
"
)
;
this
.
yearMonthFromFieldsCallCount
=
0
;
this
.
dateUntilCallCount
=
0
;
}
toString
(
)
{
return
"
options
-
null
-
proto
"
;
}
yearMonthFromFields
(
fields
options
)
{
this
.
yearMonthFromFieldsCallCount
+
+
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
options
)
null
"
yearMonthFromFields
should
be
called
with
null
-
prototype
options
"
)
;
return
super
.
yearMonthFromFields
(
fields
options
)
;
}
dateUntil
(
one
two
options
)
{
this
.
dateUntilCallCount
+
+
;
assert
.
sameValue
(
Object
.
getPrototypeOf
(
options
)
null
"
dateUntil
should
be
called
with
null
-
prototype
options
"
)
;
return
super
.
dateUntil
(
one
two
options
)
;
}
}
return
new
CalendarCheckOptionsPrototypePollution
(
)
;
}
calendarDateAddUndefinedOptions
(
)
{
class
CalendarDateAddUndefinedOptions
extends
Temporal
.
Calendar
{
constructor
(
)
{
super
(
"
iso8601
"
)
;
this
.
dateAddCallCount
=
0
;
}
toString
(
)
{
return
"
dateadd
-
undef
-
options
"
;
}
dateAdd
(
date
duration
options
)
{
this
.
dateAddCallCount
+
+
;
assert
.
sameValue
(
options
undefined
"
dateAdd
shouldn
'
t
be
called
with
options
"
)
;
return
super
.
dateAdd
(
date
duration
options
)
;
}
}
return
new
CalendarDateAddUndefinedOptions
(
)
;
}
calendarDateAddPlainDateInstance
(
)
{
class
CalendarDateAddPlainDateInstance
extends
Temporal
.
Calendar
{
constructor
(
)
{
super
(
"
iso8601
"
)
;
this
.
dateAddCallCount
=
0
;
this
.
specificPlainDate
=
undefined
;
}
toString
(
)
{
return
"
dateadd
-
plain
-
date
-
instance
"
;
}
dateFromFields
(
.
.
.
args
)
{
return
super
.
dateFromFields
(
.
.
.
args
)
.
withCalendar
(
this
)
;
}
dateAdd
(
date
duration
options
)
{
this
.
dateAddCallCount
+
+
;
assert
(
date
instanceof
Temporal
.
PlainDate
"
dateAdd
(
)
should
be
called
with
a
PlainDate
instance
"
)
;
if
(
this
.
dateAddCallCount
=
=
=
1
&
&
this
.
specificPlainDate
)
{
assert
.
sameValue
(
date
this
.
specificPlainDate
dateAdd
(
)
should
be
called
first
with
the
specific
PlainDate
instance
{
this
.
specificPlainDate
}
)
;
}
return
super
.
dateAdd
(
date
duration
options
)
.
withCalendar
(
this
)
;
}
}
return
new
CalendarDateAddPlainDateInstance
(
)
;
}
calendarFieldsIterable
(
)
{
class
CalendarFieldsIterable
extends
Temporal
.
Calendar
{
constructor
(
)
{
super
(
"
iso8601
"
)
;
this
.
fieldsCallCount
=
0
;
this
.
fieldsCalledWith
=
[
]
;
this
.
iteratorExhausted
=
[
]
;
}
toString
(
)
{
return
"
fields
-
iterable
"
;
}
fields
(
fieldNames
)
{
this
.
fieldsCallCount
+
+
;
this
.
fieldsCalledWith
.
push
(
fieldNames
.
slice
(
)
)
;
this
.
iteratorExhausted
.
push
(
false
)
;
return
{
callIndex
:
this
.
fieldsCallCount
-
1
calendar
:
this
*
[
Symbol
.
iterator
]
(
)
{
yield
*
this
.
calendar
.
fieldsCalledWith
[
this
.
callIndex
]
;
this
.
calendar
.
iteratorExhausted
[
this
.
callIndex
]
=
true
;
}
}
;
}
}
return
new
CalendarFieldsIterable
(
)
;
}
calendarFromFieldsUndefinedOptions
(
)
{
class
CalendarFromFieldsUndefinedOptions
extends
Temporal
.
Calendar
{
constructor
(
)
{
super
(
"
iso8601
"
)
;
this
.
dateFromFieldsCallCount
=
0
;
this
.
monthDayFromFieldsCallCount
=
0
;
this
.
yearMonthFromFieldsCallCount
=
0
;
}
toString
(
)
{
return
"
from
-
fields
-
undef
-
options
"
;
}
dateFromFields
(
fields
options
)
{
this
.
dateFromFieldsCallCount
+
+
;
assert
.
sameValue
(
options
undefined
"
dateFromFields
shouldn
'
t
be
called
with
options
"
)
;
return
super
.
dateFromFields
(
fields
options
)
;
}
yearMonthFromFields
(
fields
options
)
{
this
.
yearMonthFromFieldsCallCount
+
+
;
assert
.
sameValue
(
options
undefined
"
yearMonthFromFields
shouldn
'
t
be
called
with
options
"
)
;
return
super
.
yearMonthFromFields
(
fields
options
)
;
}
monthDayFromFields
(
fields
options
)
{
this
.
monthDayFromFieldsCallCount
+
+
;
assert
.
sameValue
(
options
undefined
"
monthDayFromFields
shouldn
'
t
be
called
with
options
"
)
;
return
super
.
monthDayFromFields
(
fields
options
)
;
}
}
return
new
CalendarFromFieldsUndefinedOptions
(
)
;
}
calendarMakeInfinityTime
(
)
{
class
CalendarMakeInfinityTime
extends
Temporal
.
Calendar
{
constructor
(
)
{
super
(
"
iso8601
"
)
;
}
dateFromFields
(
fields
options
)
{
const
retval
=
super
.
dateFromFields
(
fields
options
)
;
fields
.
hour
=
Infinity
;
fields
.
minute
=
Infinity
;
fields
.
second
=
Infinity
;
fields
.
millisecond
=
Infinity
;
fields
.
microsecond
=
Infinity
;
fields
.
nanosecond
=
Infinity
;
return
retval
;
}
}
return
new
CalendarMakeInfinityTime
(
)
;
}
calendarMakeInvalidGettersTime
(
)
{
class
CalendarMakeInvalidGettersTime
extends
Temporal
.
Calendar
{
constructor
(
)
{
super
(
"
iso8601
"
)
;
}
dateFromFields
(
fields
options
)
{
const
retval
=
super
.
dateFromFields
(
fields
options
)
;
const
throwingDescriptor
=
{
get
(
)
{
throw
new
Test262Error
(
"
reading
a
sabotaged
time
field
"
)
;
}
}
;
Object
.
defineProperties
(
fields
{
hour
:
throwingDescriptor
minute
:
throwingDescriptor
second
:
throwingDescriptor
millisecond
:
throwingDescriptor
microsecond
:
throwingDescriptor
nanosecond
:
throwingDescriptor
}
)
;
return
retval
;
}
}
return
new
CalendarMakeInvalidGettersTime
(
)
;
}
calendarMergeFieldsGetters
(
)
{
class
CalendarMergeFieldsGetters
extends
Temporal
.
Calendar
{
constructor
(
)
{
super
(
"
iso8601
"
)
;
this
.
mergeFieldsReturnOperations
=
[
]
;
}
toString
(
)
{
return
"
merge
-
fields
-
getters
"
;
}
dateFromFields
(
fields
options
)
{
assert
.
sameValue
(
fields
.
shouldNotBeCopied
undefined
"
extra
fields
should
not
be
copied
"
)
;
return
super
.
dateFromFields
(
fields
options
)
;
}
yearMonthFromFields
(
fields
options
)
{
assert
.
sameValue
(
fields
.
shouldNotBeCopied
undefined
"
extra
fields
should
not
be
copied
"
)
;
return
super
.
yearMonthFromFields
(
fields
options
)
;
}
monthDayFromFields
(
fields
options
)
{
assert
.
sameValue
(
fields
.
shouldNotBeCopied
undefined
"
extra
fields
should
not
be
copied
"
)
;
return
super
.
monthDayFromFields
(
fields
options
)
;
}
mergeFields
(
fields
additionalFields
)
{
const
retval
=
super
.
mergeFields
(
fields
additionalFields
)
;
retval
.
_calendar
=
this
;
retval
.
shouldNotBeCopied
=
true
;
return
new
Proxy
(
retval
{
get
(
target
key
)
{
target
.
_calendar
.
mergeFieldsReturnOperations
.
push
(
get
{
key
}
)
;
const
result
=
target
[
key
]
;
if
(
result
=
=
=
undefined
)
{
return
undefined
;
}
return
TemporalHelpers
.
toPrimitiveObserver
(
target
.
_calendar
.
mergeFieldsReturnOperations
result
key
)
;
}
has
(
target
key
)
{
target
.
_calendar
.
mergeFieldsReturnOperations
.
push
(
has
{
key
}
)
;
return
key
in
target
;
}
}
)
;
}
}
return
new
CalendarMergeFieldsGetters
(
)
;
}
calendarMergeFieldsReturnsPrimitive
(
primitive
)
{
class
CalendarMergeFieldsPrimitive
extends
Temporal
.
Calendar
{
constructor
(
mergeFieldsReturnValue
)
{
super
(
"
iso8601
"
)
;
this
.
_mergeFieldsReturnValue
=
mergeFieldsReturnValue
;
this
.
dateFromFieldsCallCount
=
0
;
this
.
monthDayFromFieldsCallCount
=
0
;
this
.
yearMonthFromFieldsCallCount
=
0
;
}
toString
(
)
{
return
"
merge
-
fields
-
primitive
"
;
}
dateFromFields
(
fields
options
)
{
this
.
dateFromFieldsCallCount
+
+
;
return
super
.
dateFromFields
(
fields
options
)
;
}
yearMonthFromFields
(
fields
options
)
{
this
.
yearMonthFromFieldsCallCount
+
+
;
return
super
.
yearMonthFromFields
(
fields
options
)
;
}
monthDayFromFields
(
fields
options
)
{
this
.
monthDayFromFieldsCallCount
+
+
;
return
super
.
monthDayFromFields
(
fields
options
)
;
}
mergeFields
(
)
{
return
this
.
_mergeFieldsReturnValue
;
}
}
return
new
CalendarMergeFieldsPrimitive
(
primitive
)
;
}
calendarWithExtraFields
(
fields
)
{
class
CalendarWithExtraFields
extends
Temporal
.
Calendar
{
constructor
(
extraFields
)
{
super
(
"
iso8601
"
)
;
this
.
_extraFields
=
extraFields
;
}
fields
(
fieldNames
)
{
return
super
.
fields
(
fieldNames
)
.
concat
(
this
.
_extraFields
)
;
}
}
return
new
CalendarWithExtraFields
(
fields
)
;
}
crossDateLineTimeZone
(
)
{
const
{
compare
}
=
Temporal
.
PlainDateTime
;
const
skippedDay
=
new
Temporal
.
PlainDate
(
2011
12
30
)
;
const
transitionEpoch
=
1325239200_000_000_000n
;
const
beforeOffset
=
new
Temporal
.
TimeZone
(
"
-
10
:
00
"
)
;
const
afterOffset
=
new
Temporal
.
TimeZone
(
"
+
14
:
00
"
)
;
class
CrossDateLineTimeZone
extends
Temporal
.
TimeZone
{
constructor
(
)
{
super
(
"
+
14
:
00
"
)
;
}
getOffsetNanosecondsFor
(
instant
)
{
if
(
instant
.
epochNanoseconds
<
transitionEpoch
)
{
return
beforeOffset
.
getOffsetNanosecondsFor
(
instant
)
;
}
return
afterOffset
.
getOffsetNanosecondsFor
(
instant
)
;
}
getPossibleInstantsFor
(
datetime
)
{
const
comparison
=
Temporal
.
PlainDate
.
compare
(
datetime
.
toPlainDate
(
)
skippedDay
)
;
if
(
comparison
=
=
=
0
)
{
return
[
]
;
}
if
(
comparison
<
0
)
{
return
[
beforeOffset
.
getInstantFor
(
datetime
)
]
;
}
return
[
afterOffset
.
getInstantFor
(
datetime
)
]
;
}
getPreviousTransition
(
instant
)
{
if
(
instant
.
epochNanoseconds
>
transitionEpoch
)
return
new
Temporal
.
Instant
(
transitionEpoch
)
;
return
null
;
}
getNextTransition
(
instant
)
{
if
(
instant
.
epochNanoseconds
<
transitionEpoch
)
return
new
Temporal
.
Instant
(
transitionEpoch
)
;
return
null
;
}
toString
(
)
{
return
"
Custom
/
Date_Line
"
;
}
}
return
new
CrossDateLineTimeZone
(
)
;
}
observeProperty
(
calls
object
propertyName
value
objectName
=
"
"
)
{
Object
.
defineProperty
(
object
propertyName
{
get
(
)
{
calls
.
push
(
get
{
formatPropertyName
(
propertyName
objectName
)
}
)
;
return
value
;
}
set
(
v
)
{
calls
.
push
(
set
{
formatPropertyName
(
propertyName
objectName
)
}
)
;
}
}
)
;
}
observeMethod
(
calls
object
propertyName
objectName
=
"
"
)
{
const
method
=
object
[
propertyName
]
;
object
[
propertyName
]
=
function
(
)
{
calls
.
push
(
call
{
formatPropertyName
(
propertyName
objectName
)
}
)
;
return
method
.
apply
(
object
arguments
)
;
}
;
}
SUBSTITUTE_SKIP
:
SKIP_SYMBOL
substituteMethod
(
object
propertyName
values
)
{
let
calls
=
0
;
const
method
=
object
[
propertyName
]
;
object
[
propertyName
]
=
function
(
)
{
if
(
calls
>
=
values
.
length
)
{
return
method
.
apply
(
object
arguments
)
;
}
else
if
(
values
[
calls
]
=
=
=
SKIP_SYMBOL
)
{
calls
+
+
;
return
method
.
apply
(
object
arguments
)
;
}
else
{
return
values
[
calls
+
+
]
;
}
}
;
}
calendarObserver
(
calls
objectName
methodOverrides
=
{
}
)
{
function
removeExtraHasPropertyChecks
(
objectName
calls
)
{
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
yearOfWeek
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
yearMonthFromFields
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
year
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
weekOfYear
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
monthsInYear
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
monthDayFromFields
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
monthCode
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
month
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
mergeFields
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
inLeapYear
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
id
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
fields
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
daysInYear
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
daysInWeek
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
daysInMonth
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
dayOfYear
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
dayOfWeek
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
day
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
dateUntil
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
dateFromFields
)
;
assert
.
sameValue
(
calls
.
pop
(
)
has
{
objectName
}
.
dateAdd
)
;
}
const
iso8601
=
new
Temporal
.
Calendar
(
"
iso8601
"
)
;
const
trackingMethods
=
{
dateFromFields
(
.
.
.
args
)
{
calls
.
push
(
call
{
objectName
}
.
dateFromFields
)
;
if
(
'
dateFromFields
'
in
methodOverrides
)
{
const
value
=
methodOverrides
.
dateFromFields
;
return
typeof
value
=
=
=
"
function
"
?
value
(
.
.
.
args
)
:
value
;
}
const
originalResult
=
iso8601
.
dateFromFields
(
.
.
.
args
)
;
const
{
isoYear
isoMonth
isoDay
}
=
originalResult
.
getISOFields
(
)
;
const
result
=
new
Temporal
.
PlainDate
(
isoYear
isoMonth
isoDay
this
)
;
removeExtraHasPropertyChecks
(
objectName
calls
)
;
return
result
;
}
yearMonthFromFields
(
.
.
.
args
)
{
calls
.
push
(
call
{
objectName
}
.
yearMonthFromFields
)
;
if
(
'
yearMonthFromFields
'
in
methodOverrides
)
{
const
value
=
methodOverrides
.
yearMonthFromFields
;
return
typeof
value
=
=
=
"
function
"
?
value
(
.
.
.
args
)
:
value
;
}
const
originalResult
=
iso8601
.
yearMonthFromFields
(
.
.
.
args
)
;
const
{
isoYear
isoMonth
isoDay
}
=
originalResult
.
getISOFields
(
)
;
const
result
=
new
Temporal
.
PlainYearMonth
(
isoYear
isoMonth
this
isoDay
)
;
removeExtraHasPropertyChecks
(
objectName
calls
)
;
return
result
;
}
monthDayFromFields
(
.
.
.
args
)
{
calls
.
push
(
call
{
objectName
}
.
monthDayFromFields
)
;
if
(
'
monthDayFromFields
'
in
methodOverrides
)
{
const
value
=
methodOverrides
.
monthDayFromFields
;
return
typeof
value
=
=
=
"
function
"
?
value
(
.
.
.
args
)
:
value
;
}
const
originalResult
=
iso8601
.
monthDayFromFields
(
.
.
.
args
)
;
const
{
isoYear
isoMonth
isoDay
}
=
originalResult
.
getISOFields
(
)
;
const
result
=
new
Temporal
.
PlainMonthDay
(
isoMonth
isoDay
this
isoYear
)
;
removeExtraHasPropertyChecks
(
objectName
calls
)
;
return
result
;
}
dateAdd
(
.
.
.
args
)
{
calls
.
push
(
call
{
objectName
}
.
dateAdd
)
;
if
(
'
dateAdd
'
in
methodOverrides
)
{
const
value
=
methodOverrides
.
dateAdd
;
return
typeof
value
=
=
=
"
function
"
?
value
(
.
.
.
args
)
:
value
;
}
const
originalResult
=
iso8601
.
dateAdd
(
.
.
.
args
)
;
const
{
isoYear
isoMonth
isoDay
}
=
originalResult
.
getISOFields
(
)
;
const
result
=
new
Temporal
.
PlainDate
(
isoYear
isoMonth
isoDay
this
)
;
removeExtraHasPropertyChecks
(
objectName
calls
)
;
return
result
;
}
id
:
"
iso8601
"
}
;
[
"
dateUntil
"
"
day
"
"
dayOfWeek
"
"
dayOfYear
"
"
daysInMonth
"
"
daysInWeek
"
"
daysInYear
"
"
era
"
"
eraYear
"
"
fields
"
"
inLeapYear
"
"
mergeFields
"
"
month
"
"
monthCode
"
"
monthsInYear
"
"
toString
"
"
weekOfYear
"
"
year
"
"
yearOfWeek
"
]
.
forEach
(
(
methodName
)
=
>
{
trackingMethods
[
methodName
]
=
function
(
.
.
.
args
)
{
calls
.
push
(
call
{
formatPropertyName
(
methodName
objectName
)
}
)
;
if
(
methodName
in
methodOverrides
)
{
const
value
=
methodOverrides
[
methodName
]
;
return
typeof
value
=
=
=
"
function
"
?
value
(
.
.
.
args
)
:
value
;
}
return
iso8601
[
methodName
]
(
.
.
.
args
)
;
}
;
}
)
;
return
new
Proxy
(
trackingMethods
{
get
(
target
key
receiver
)
{
const
result
=
Reflect
.
get
(
target
key
receiver
)
;
calls
.
push
(
get
{
formatPropertyName
(
key
objectName
)
}
)
;
return
result
;
}
has
(
target
key
)
{
calls
.
push
(
has
{
formatPropertyName
(
key
objectName
)
}
)
;
return
Reflect
.
has
(
target
key
)
;
}
}
)
;
}
calendarThrowEverything
(
)
{
class
CalendarThrowEverything
extends
Temporal
.
Calendar
{
constructor
(
)
{
super
(
"
iso8601
"
)
;
}
toString
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
toString
should
not
be
called
"
)
;
}
dateFromFields
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
dateFromFields
should
not
be
called
"
)
;
}
yearMonthFromFields
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
yearMonthFromFields
should
not
be
called
"
)
;
}
monthDayFromFields
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
monthDayFromFields
should
not
be
called
"
)
;
}
dateAdd
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
dateAdd
should
not
be
called
"
)
;
}
dateUntil
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
dateUntil
should
not
be
called
"
)
;
}
era
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
era
should
not
be
called
"
)
;
}
eraYear
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
eraYear
should
not
be
called
"
)
;
}
year
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
year
should
not
be
called
"
)
;
}
month
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
month
should
not
be
called
"
)
;
}
monthCode
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
monthCode
should
not
be
called
"
)
;
}
day
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
day
should
not
be
called
"
)
;
}
fields
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
fields
should
not
be
called
"
)
;
}
mergeFields
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
mergeFields
should
not
be
called
"
)
;
}
}
return
new
CalendarThrowEverything
(
)
;
}
oneShiftTimeZone
(
shiftInstant
shiftNanoseconds
)
{
class
OneShiftTimeZone
extends
Temporal
.
TimeZone
{
constructor
(
shiftInstant
shiftNanoseconds
)
{
super
(
"
+
00
:
00
"
)
;
this
.
_shiftInstant
=
shiftInstant
;
this
.
_epoch1
=
shiftInstant
.
epochNanoseconds
;
this
.
_epoch2
=
this
.
_epoch1
+
BigInt
(
shiftNanoseconds
)
;
this
.
_shiftNanoseconds
=
shiftNanoseconds
;
this
.
_shift
=
new
Temporal
.
Duration
(
0
0
0
0
0
0
0
0
0
this
.
_shiftNanoseconds
)
;
this
.
getPossibleInstantsForCalledWith
=
[
]
;
}
_isBeforeShift
(
instant
)
{
return
instant
.
epochNanoseconds
<
this
.
_epoch1
;
}
getOffsetNanosecondsFor
(
instant
)
{
return
this
.
_isBeforeShift
(
instant
)
?
0
:
this
.
_shiftNanoseconds
;
}
getPossibleInstantsFor
(
plainDateTime
)
{
this
.
getPossibleInstantsForCalledWith
.
push
(
plainDateTime
.
toString
(
{
calendarName
:
"
never
"
}
)
)
;
const
[
instant
]
=
super
.
getPossibleInstantsFor
(
plainDateTime
)
;
if
(
this
.
_shiftNanoseconds
>
0
)
{
if
(
this
.
_isBeforeShift
(
instant
)
)
return
[
instant
]
;
if
(
instant
.
epochNanoseconds
<
this
.
_epoch2
)
return
[
]
;
return
[
instant
.
subtract
(
this
.
_shift
)
]
;
}
if
(
instant
.
epochNanoseconds
<
this
.
_epoch2
)
return
[
instant
]
;
const
shifted
=
instant
.
subtract
(
this
.
_shift
)
;
if
(
this
.
_isBeforeShift
(
instant
)
)
return
[
instant
shifted
]
;
return
[
shifted
]
;
}
getNextTransition
(
instant
)
{
return
this
.
_isBeforeShift
(
instant
)
?
this
.
_shiftInstant
:
null
;
}
getPreviousTransition
(
instant
)
{
return
this
.
_isBeforeShift
(
instant
)
?
null
:
this
.
_shiftInstant
;
}
toString
(
)
{
return
"
Custom
/
One_Shift
"
;
}
}
return
new
OneShiftTimeZone
(
shiftInstant
shiftNanoseconds
)
;
}
propertyBagObserver
(
calls
propertyBag
objectName
)
{
return
new
Proxy
(
propertyBag
{
ownKeys
(
target
)
{
calls
.
push
(
ownKeys
{
objectName
}
)
;
return
Reflect
.
ownKeys
(
target
)
;
}
getOwnPropertyDescriptor
(
target
key
)
{
calls
.
push
(
getOwnPropertyDescriptor
{
formatPropertyName
(
key
objectName
)
}
)
;
return
Reflect
.
getOwnPropertyDescriptor
(
target
key
)
;
}
get
(
target
key
receiver
)
{
calls
.
push
(
get
{
formatPropertyName
(
key
objectName
)
}
)
;
const
result
=
Reflect
.
get
(
target
key
receiver
)
;
if
(
result
=
=
=
undefined
)
{
return
undefined
;
}
if
(
(
result
!
=
=
null
&
&
typeof
result
=
=
=
"
object
"
)
|
|
typeof
result
=
=
=
"
function
"
)
{
return
result
;
}
return
TemporalHelpers
.
toPrimitiveObserver
(
calls
result
{
formatPropertyName
(
key
objectName
)
}
)
;
}
has
(
target
key
)
{
calls
.
push
(
has
{
formatPropertyName
(
key
objectName
)
}
)
;
return
Reflect
.
has
(
target
key
)
;
}
}
)
;
}
specificOffsetTimeZone
(
offsetValue
)
{
class
SpecificOffsetTimeZone
extends
Temporal
.
TimeZone
{
constructor
(
offsetValue
)
{
super
(
"
UTC
"
)
;
this
.
_offsetValue
=
offsetValue
;
}
getOffsetNanosecondsFor
(
)
{
return
this
.
_offsetValue
;
}
getPossibleInstantsFor
(
dt
)
{
if
(
typeof
this
.
_offsetValue
!
=
=
'
number
'
|
|
Math
.
abs
(
this
.
_offsetValue
)
>
=
86400e9
|
|
isNaN
(
this
.
_offsetValue
)
)
return
[
]
;
const
zdt
=
dt
.
toZonedDateTime
(
"
UTC
"
)
.
add
(
{
nanoseconds
:
-
this
.
_offsetValue
}
)
;
return
[
zdt
.
toInstant
(
)
]
;
}
get
id
(
)
{
return
this
.
getOffsetStringFor
(
new
Temporal
.
Instant
(
0n
)
)
;
}
}
return
new
SpecificOffsetTimeZone
(
offsetValue
)
;
}
springForwardFallBackTimeZone
(
)
{
const
{
compare
}
=
Temporal
.
PlainDateTime
;
const
springForwardLocal
=
new
Temporal
.
PlainDateTime
(
2000
4
2
2
)
;
const
springForwardEpoch
=
954669600_000_000_000n
;
const
fallBackLocal
=
new
Temporal
.
PlainDateTime
(
2000
10
29
1
)
;
const
fallBackEpoch
=
972810000_000_000_000n
;
const
winterOffset
=
new
Temporal
.
TimeZone
(
'
-
08
:
00
'
)
;
const
summerOffset
=
new
Temporal
.
TimeZone
(
'
-
07
:
00
'
)
;
class
SpringForwardFallBackTimeZone
extends
Temporal
.
TimeZone
{
constructor
(
)
{
super
(
"
-
08
:
00
"
)
;
}
getOffsetNanosecondsFor
(
instant
)
{
if
(
instant
.
epochNanoseconds
<
springForwardEpoch
|
|
instant
.
epochNanoseconds
>
=
fallBackEpoch
)
{
return
winterOffset
.
getOffsetNanosecondsFor
(
instant
)
;
}
return
summerOffset
.
getOffsetNanosecondsFor
(
instant
)
;
}
getPossibleInstantsFor
(
datetime
)
{
if
(
compare
(
datetime
springForwardLocal
)
>
=
0
&
&
compare
(
datetime
springForwardLocal
.
add
(
{
hours
:
1
}
)
)
<
0
)
{
return
[
]
;
}
if
(
compare
(
datetime
fallBackLocal
)
>
=
0
&
&
compare
(
datetime
fallBackLocal
.
add
(
{
hours
:
1
}
)
)
<
0
)
{
return
[
summerOffset
.
getInstantFor
(
datetime
)
winterOffset
.
getInstantFor
(
datetime
)
]
;
}
if
(
compare
(
datetime
springForwardLocal
)
<
0
|
|
compare
(
datetime
fallBackLocal
)
>
=
0
)
{
return
[
winterOffset
.
getInstantFor
(
datetime
)
]
;
}
return
[
summerOffset
.
getInstantFor
(
datetime
)
]
;
}
getPreviousTransition
(
instant
)
{
if
(
instant
.
epochNanoseconds
>
fallBackEpoch
)
return
new
Temporal
.
Instant
(
fallBackEpoch
)
;
if
(
instant
.
epochNanoseconds
>
springForwardEpoch
)
return
new
Temporal
.
Instant
(
springForwardEpoch
)
;
return
null
;
}
getNextTransition
(
instant
)
{
if
(
instant
.
epochNanoseconds
<
springForwardEpoch
)
return
new
Temporal
.
Instant
(
springForwardEpoch
)
;
if
(
instant
.
epochNanoseconds
<
fallBackEpoch
)
return
new
Temporal
.
Instant
(
fallBackEpoch
)
;
return
null
;
}
get
id
(
)
{
return
"
Custom
/
Spring_Fall
"
;
}
toString
(
)
{
return
"
Custom
/
Spring_Fall
"
;
}
}
return
new
SpringForwardFallBackTimeZone
(
)
;
}
timeZoneObserver
(
calls
objectName
methodOverrides
=
{
}
)
{
const
utc
=
new
Temporal
.
TimeZone
(
"
UTC
"
)
;
const
trackingMethods
=
{
id
:
"
UTC
"
}
;
[
"
getOffsetNanosecondsFor
"
"
getPossibleInstantsFor
"
"
toString
"
]
.
forEach
(
(
methodName
)
=
>
{
trackingMethods
[
methodName
]
=
function
(
.
.
.
args
)
{
calls
.
push
(
call
{
formatPropertyName
(
methodName
objectName
)
}
)
;
if
(
methodName
in
methodOverrides
)
{
const
value
=
methodOverrides
[
methodName
]
;
return
typeof
value
=
=
=
"
function
"
?
value
(
.
.
.
args
)
:
value
;
}
return
utc
[
methodName
]
(
.
.
.
args
)
;
}
;
}
)
;
return
new
Proxy
(
trackingMethods
{
get
(
target
key
receiver
)
{
const
result
=
Reflect
.
get
(
target
key
receiver
)
;
calls
.
push
(
get
{
formatPropertyName
(
key
objectName
)
}
)
;
return
result
;
}
has
(
target
key
)
{
calls
.
push
(
has
{
formatPropertyName
(
key
objectName
)
}
)
;
return
Reflect
.
has
(
target
key
)
;
}
}
)
;
}
timeZoneThrowEverything
(
)
{
class
TimeZoneThrowEverything
extends
Temporal
.
TimeZone
{
constructor
(
)
{
super
(
"
UTC
"
)
;
}
getOffsetNanosecondsFor
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
getOffsetNanosecondsFor
should
not
be
called
"
)
;
}
getPossibleInstantsFor
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
getPossibleInstantsFor
should
not
be
called
"
)
;
}
toString
(
)
{
TemporalHelpers
.
assertUnreachable
(
"
toString
should
not
be
called
"
)
;
}
}
return
new
TimeZoneThrowEverything
(
)
;
}
toPrimitiveObserver
(
calls
primitiveValue
propertyName
)
{
return
{
get
valueOf
(
)
{
calls
.
push
(
get
{
propertyName
}
.
valueOf
)
;
return
function
(
)
{
calls
.
push
(
call
{
propertyName
}
.
valueOf
)
;
return
primitiveValue
;
}
;
}
get
toString
(
)
{
calls
.
push
(
get
{
propertyName
}
.
toString
)
;
return
function
(
)
{
calls
.
push
(
call
{
propertyName
}
.
toString
)
;
if
(
primitiveValue
=
=
=
undefined
)
return
undefined
;
return
primitiveValue
.
toString
(
)
;
}
;
}
}
;
}
ISO
:
{
plainMonthDayStringsInvalid
(
)
{
return
[
"
11
-
18junk
"
"
11
-
18
[
u
-
ca
=
gregory
]
"
"
11
-
18
[
u
-
ca
=
hebrew
]
"
]
;
}
plainMonthDayStringsValid
(
)
{
return
[
"
10
-
01
"
"
1001
"
"
1965
-
10
-
01
"
"
1976
-
10
-
01T152330
.
1
+
00
:
00
"
"
19761001T15
:
23
:
30
.
1
+
00
:
00
"
"
1976
-
10
-
01T15
:
23
:
30
.
1
+
0000
"
"
1976
-
10
-
01T152330
.
1
+
0000
"
"
19761001T15
:
23
:
30
.
1
+
0000
"
"
19761001T152330
.
1
+
00
:
00
"
"
19761001T152330
.
1
+
0000
"
"
+
001976
-
10
-
01T152330
.
1
+
00
:
00
"
"
+
0019761001T15
:
23
:
30
.
1
+
00
:
00
"
"
+
001976
-
10
-
01T15
:
23
:
30
.
1
+
0000
"
"
+
001976
-
10
-
01T152330
.
1
+
0000
"
"
+
0019761001T15
:
23
:
30
.
1
+
0000
"
"
+
0019761001T152330
.
1
+
00
:
00
"
"
+
0019761001T152330
.
1
+
0000
"
"
1976
-
10
-
01T15
:
23
:
00
"
"
1976
-
10
-
01T15
:
23
"
"
1976
-
10
-
01T15
"
"
1976
-
10
-
01
"
"
-
-
10
-
01
"
"
-
-
1001
"
]
;
}
plainTimeStringsAmbiguous
(
)
{
const
ambiguousStrings
=
[
"
2021
-
12
"
"
2021
-
12
[
-
12
:
00
]
"
"
1214
"
"
0229
"
"
1130
"
"
12
-
14
"
"
12
-
14
[
-
14
:
00
]
"
"
202112
"
"
202112
[
UTC
]
"
]
;
const
stringsWithCalendar
=
ambiguousStrings
.
map
(
(
s
)
=
>
s
+
'
[
u
-
ca
=
iso8601
]
'
)
;
return
ambiguousStrings
.
concat
(
stringsWithCalendar
)
;
}
plainTimeStringsUnambiguous
(
)
{
return
[
"
2021
-
13
"
"
202113
"
"
2021
-
13
[
-
13
:
00
]
"
"
202113
[
-
13
:
00
]
"
"
0000
-
00
"
"
000000
"
"
0000
-
00
[
UTC
]
"
"
000000
[
UTC
]
"
"
1314
"
"
13
-
14
"
"
1232
"
"
0230
"
"
0631
"
"
0000
"
"
00
-
00
"
]
;
}
plainYearMonthStringsInvalid
(
)
{
return
[
"
2020
-
13
"
]
;
}
plainYearMonthStringsValid
(
)
{
return
[
"
1976
-
11
"
"
1976
-
11
-
10
"
"
1976
-
11
-
01T09
:
00
:
00
+
00
:
00
"
"
1976
-
11
-
01T00
:
00
:
00
+
05
:
00
"
"
197611
"
"
+
00197611
"
"
1976
-
11
-
18T15
:
23
:
30
.
1
\
u221202
:
00
"
"
1976
-
11
-
18T152330
.
1
+
00
:
00
"
"
19761118T15
:
23
:
30
.
1
+
00
:
00
"
"
1976
-
11
-
18T15
:
23
:
30
.
1
+
0000
"
"
1976
-
11
-
18T152330
.
1
+
0000
"
"
19761118T15
:
23
:
30
.
1
+
0000
"
"
19761118T152330
.
1
+
00
:
00
"
"
19761118T152330
.
1
+
0000
"
"
+
001976
-
11
-
18T152330
.
1
+
00
:
00
"
"
+
0019761118T15
:
23
:
30
.
1
+
00
:
00
"
"
+
001976
-
11
-
18T15
:
23
:
30
.
1
+
0000
"
"
+
001976
-
11
-
18T152330
.
1
+
0000
"
"
+
0019761118T15
:
23
:
30
.
1
+
0000
"
"
+
0019761118T152330
.
1
+
00
:
00
"
"
+
0019761118T152330
.
1
+
0000
"
"
1976
-
11
-
18T15
:
23
"
"
1976
-
11
-
18T15
"
"
1976
-
11
-
18
"
]
;
}
plainYearMonthStringsValidNegativeYear
(
)
{
return
[
"
\
u2212009999
-
11
"
]
;
}
}
}
;
