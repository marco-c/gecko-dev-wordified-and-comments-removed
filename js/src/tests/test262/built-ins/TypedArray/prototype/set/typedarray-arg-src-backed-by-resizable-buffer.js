function
IsBigIntTypedArray
(
ta
)
{
return
ta
instanceof
BigInt64Array
|
|
ta
instanceof
BigUint64Array
;
}
function
SetNumOrBigInt
(
target
source
offset
)
{
if
(
IsBigIntTypedArray
(
target
)
)
{
const
bigIntSource
=
[
]
;
for
(
const
s
of
source
)
{
bigIntSource
.
push
(
BigInt
(
s
)
)
;
}
source
=
bigIntSource
;
}
if
(
offset
=
=
undefined
)
{
return
target
.
set
(
source
)
;
}
return
target
.
set
(
source
offset
)
;
}
for
(
let
targetIsResizable
of
[
false
true
]
)
{
for
(
let
targetCtor
of
ctors
)
{
for
(
let
sourceCtor
of
ctors
)
{
const
rab
=
CreateResizableArrayBuffer
(
4
*
sourceCtor
.
BYTES_PER_ELEMENT
8
*
sourceCtor
.
BYTES_PER_ELEMENT
)
;
const
fixedLength
=
new
sourceCtor
(
rab
0
4
)
;
const
fixedLengthWithOffset
=
new
sourceCtor
(
rab
2
*
sourceCtor
.
BYTES_PER_ELEMENT
2
)
;
const
lengthTracking
=
new
sourceCtor
(
rab
0
)
;
const
lengthTrackingWithOffset
=
new
sourceCtor
(
rab
2
*
sourceCtor
.
BYTES_PER_ELEMENT
)
;
const
taFull
=
new
sourceCtor
(
rab
)
;
for
(
let
i
=
0
;
i
<
4
;
+
+
i
)
{
taFull
[
i
]
=
MayNeedBigInt
(
taFull
i
+
1
)
;
}
const
targetAb
=
targetIsResizable
?
new
ArrayBuffer
(
6
*
targetCtor
.
BYTES_PER_ELEMENT
)
:
new
ArrayBuffer
(
6
*
targetCtor
.
BYTES_PER_ELEMENT
{
maxByteLength
:
8
*
targetCtor
.
BYTES_PER_ELEMENT
}
)
;
const
target
=
new
targetCtor
(
targetAb
)
;
if
(
IsBigIntTypedArray
(
target
)
!
=
IsBigIntTypedArray
(
taFull
)
)
{
continue
;
}
SetNumOrBigInt
(
target
fixedLength
)
;
assert
.
compareArray
(
ToNumbers
(
target
)
[
1
2
3
4
0
0
]
)
;
SetNumOrBigInt
(
target
fixedLengthWithOffset
)
;
assert
.
compareArray
(
ToNumbers
(
target
)
[
3
4
3
4
0
0
]
)
;
SetNumOrBigInt
(
target
lengthTracking
1
)
;
assert
.
compareArray
(
ToNumbers
(
target
)
[
3
1
2
3
4
0
]
)
;
SetNumOrBigInt
(
target
lengthTrackingWithOffset
1
)
;
assert
.
compareArray
(
ToNumbers
(
target
)
[
3
3
4
3
4
0
]
)
;
rab
.
resize
(
3
*
sourceCtor
.
BYTES_PER_ELEMENT
)
;
assert
.
throws
(
TypeError
(
)
=
>
{
SetNumOrBigInt
(
target
fixedLength
)
;
}
)
;
assert
.
throws
(
TypeError
(
)
=
>
{
SetNumOrBigInt
(
target
fixedLengthWithOffset
)
;
}
)
;
assert
.
compareArray
(
ToNumbers
(
target
)
[
3
3
4
3
4
0
]
)
;
SetNumOrBigInt
(
target
lengthTracking
)
;
assert
.
compareArray
(
ToNumbers
(
target
)
[
1
2
3
3
4
0
]
)
;
SetNumOrBigInt
(
target
lengthTrackingWithOffset
)
;
assert
.
compareArray
(
ToNumbers
(
target
)
[
3
2
3
3
4
0
]
)
;
rab
.
resize
(
1
*
sourceCtor
.
BYTES_PER_ELEMENT
)
;
assert
.
throws
(
TypeError
(
)
=
>
{
SetNumOrBigInt
(
target
fixedLength
)
;
}
)
;
assert
.
throws
(
TypeError
(
)
=
>
{
SetNumOrBigInt
(
target
fixedLengthWithOffset
)
;
}
)
;
assert
.
throws
(
TypeError
(
)
=
>
{
SetNumOrBigInt
(
target
lengthTrackingWithOffset
)
;
}
)
;
SetNumOrBigInt
(
target
lengthTracking
3
)
;
assert
.
compareArray
(
ToNumbers
(
target
)
[
3
2
3
1
4
0
]
)
;
rab
.
resize
(
0
)
;
assert
.
throws
(
TypeError
(
)
=
>
{
SetNumOrBigInt
(
target
fixedLength
)
;
}
)
;
assert
.
throws
(
TypeError
(
)
=
>
{
SetNumOrBigInt
(
target
fixedLengthWithOffset
)
;
}
)
;
assert
.
throws
(
TypeError
(
)
=
>
{
SetNumOrBigInt
(
target
lengthTrackingWithOffset
)
;
}
)
;
SetNumOrBigInt
(
target
lengthTracking
4
)
;
assert
.
compareArray
(
ToNumbers
(
target
)
[
3
2
3
1
4
0
]
)
;
rab
.
resize
(
6
*
sourceCtor
.
BYTES_PER_ELEMENT
)
;
for
(
let
i
=
0
;
i
<
6
;
+
+
i
)
{
taFull
[
i
]
=
MayNeedBigInt
(
taFull
i
+
1
)
;
}
SetNumOrBigInt
(
target
fixedLength
)
;
assert
.
compareArray
(
ToNumbers
(
target
)
[
1
2
3
4
4
0
]
)
;
SetNumOrBigInt
(
target
fixedLengthWithOffset
)
;
assert
.
compareArray
(
ToNumbers
(
target
)
[
3
4
3
4
4
0
]
)
;
SetNumOrBigInt
(
target
lengthTracking
0
)
;
assert
.
compareArray
(
ToNumbers
(
target
)
[
1
2
3
4
5
6
]
)
;
SetNumOrBigInt
(
target
lengthTrackingWithOffset
1
)
;
assert
.
compareArray
(
ToNumbers
(
target
)
[
1
3
4
5
6
6
]
)
;
}
}
}
reportCompare
(
0
0
)
;
