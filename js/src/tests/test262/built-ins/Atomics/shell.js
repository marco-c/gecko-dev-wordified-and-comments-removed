function
testWithAtomicsOutOfBoundsIndices
(
f
)
{
var
bad_indices
=
[
function
(
view
)
{
return
-
1
;
}
function
(
view
)
{
return
view
.
length
;
}
function
(
view
)
{
return
view
.
length
*
2
;
}
function
(
view
)
{
return
Number
.
POSITIVE_INFINITY
;
}
function
(
view
)
{
return
Number
.
NEGATIVE_INFINITY
;
}
function
(
view
)
{
return
{
valueOf
:
function
(
)
{
return
125
;
}
}
;
}
function
(
view
)
{
return
{
toString
:
function
(
)
{
return
'
125
'
;
}
valueOf
:
false
}
;
}
]
;
for
(
var
i
=
0
;
i
<
bad_indices
.
length
;
+
+
i
)
{
var
IdxGen
=
bad_indices
[
i
]
;
try
{
f
(
IdxGen
)
;
}
catch
(
e
)
{
e
.
message
+
=
'
(
Testing
with
index
gen
'
+
IdxGen
+
'
.
)
'
;
throw
e
;
}
}
}
function
testWithAtomicsInBoundsIndices
(
f
)
{
var
good_indices
=
[
function
(
view
)
{
return
0
/
-
1
;
}
function
(
view
)
{
return
'
-
0
'
;
}
function
(
view
)
{
return
undefined
;
}
function
(
view
)
{
return
NaN
;
}
function
(
view
)
{
return
0
.
5
;
}
function
(
view
)
{
return
'
0
.
5
'
;
}
function
(
view
)
{
return
-
0
.
9
;
}
function
(
view
)
{
return
{
password
:
'
qumquat
'
}
;
}
function
(
view
)
{
return
view
.
length
-
1
;
}
function
(
view
)
{
return
{
valueOf
:
function
(
)
{
return
0
;
}
}
;
}
function
(
view
)
{
return
{
toString
:
function
(
)
{
return
'
0
'
;
}
valueOf
:
false
}
;
}
]
;
for
(
var
i
=
0
;
i
<
good_indices
.
length
;
+
+
i
)
{
var
IdxGen
=
good_indices
[
i
]
;
try
{
f
(
IdxGen
)
;
}
catch
(
e
)
{
e
.
message
+
=
'
(
Testing
with
index
gen
'
+
IdxGen
+
'
.
)
'
;
throw
e
;
}
}
}
function
testWithAtomicsNonViewValues
(
f
)
{
var
values
=
[
null
undefined
true
false
new
Boolean
(
true
)
10
3
.
14
new
Number
(
4
)
'
Hi
there
'
new
Date
/
a
*
utomaton
/
g
{
password
:
'
qumquat
'
}
new
DataView
(
new
ArrayBuffer
(
10
)
)
new
ArrayBuffer
(
128
)
new
SharedArrayBuffer
(
128
)
new
Error
(
'
Ouch
'
)
[
1
1
2
3
5
8
]
function
(
x
)
{
return
-
x
;
}
Symbol
(
'
halleluja
'
)
Object
Int32Array
Date
Math
Atomics
]
;
for
(
var
i
=
0
;
i
<
values
.
length
;
+
+
i
)
{
var
nonView
=
values
[
i
]
;
try
{
f
(
nonView
)
;
}
catch
(
e
)
{
e
.
message
+
=
'
(
Testing
with
non
-
view
value
'
+
nonView
+
'
.
)
'
;
throw
e
;
}
}
}
var
floatArrayConstructors
=
[
Float64Array
Float32Array
]
;
var
nonClampedIntArrayConstructors
=
[
Int32Array
Int16Array
Int8Array
Uint32Array
Uint16Array
Uint8Array
]
;
var
intArrayConstructors
=
nonClampedIntArrayConstructors
.
concat
(
[
Uint8ClampedArray
]
)
;
if
(
typeof
Float16Array
!
=
=
'
undefined
'
)
{
floatArrayConstructors
.
push
(
Float16Array
)
;
}
var
typedArrayConstructors
=
floatArrayConstructors
.
concat
(
intArrayConstructors
)
;
var
TypedArray
=
Object
.
getPrototypeOf
(
Int8Array
)
;
function
testWithTypedArrayConstructors
(
f
selected
)
{
var
constructors
=
selected
|
|
typedArrayConstructors
;
for
(
var
i
=
0
;
i
<
constructors
.
length
;
+
+
i
)
{
var
constructor
=
constructors
[
i
]
;
try
{
f
(
constructor
)
;
}
catch
(
e
)
{
e
.
message
+
=
"
(
Testing
with
"
+
constructor
.
name
+
"
.
)
"
;
throw
e
;
}
}
}
var
nonAtomicsFriendlyTypedArrayConstructors
=
floatArrayConstructors
.
concat
(
[
Uint8ClampedArray
]
)
;
function
testWithNonAtomicsFriendlyTypedArrayConstructors
(
f
)
{
testWithTypedArrayConstructors
(
f
nonAtomicsFriendlyTypedArrayConstructors
)
;
}
function
testWithAtomicsFriendlyTypedArrayConstructors
(
f
)
{
testWithTypedArrayConstructors
(
f
[
Int32Array
Int16Array
Int8Array
Uint32Array
Uint16Array
Uint8Array
]
)
;
}
function
testTypedArrayConversions
(
byteConversionValues
fn
)
{
var
values
=
byteConversionValues
.
values
;
var
expected
=
byteConversionValues
.
expected
;
testWithTypedArrayConstructors
(
function
(
TA
)
{
var
name
=
TA
.
name
.
slice
(
0
-
5
)
;
return
values
.
forEach
(
function
(
value
index
)
{
var
exp
=
expected
[
name
]
[
index
]
;
var
initial
=
0
;
if
(
exp
=
=
=
0
)
{
initial
=
1
;
}
fn
(
TA
value
exp
initial
)
;
}
)
;
}
)
;
}
function
isFloatTypedArrayConstructor
(
arg
)
{
return
floatArrayConstructors
.
indexOf
(
arg
)
!
=
=
-
1
;
}
function
floatTypedArrayConstructorPrecision
(
FA
)
{
if
(
typeof
Float16Array
!
=
=
"
undefined
"
&
&
FA
=
=
=
Float16Array
)
{
return
"
half
"
;
}
else
if
(
FA
=
=
=
Float32Array
)
{
return
"
single
"
;
}
else
if
(
FA
=
=
=
Float64Array
)
{
return
"
double
"
;
}
else
{
throw
new
Error
(
"
Malformed
test
-
floatTypedArrayConstructorPrecision
called
with
non
-
float
TypedArray
"
)
;
}
}
