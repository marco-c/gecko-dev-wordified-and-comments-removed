function
asyncTest
(
testFunc
)
{
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
globalThis
"
DONE
"
)
)
{
throw
new
Test262Error
(
"
asyncTest
called
without
async
flag
"
)
;
}
if
(
typeof
testFunc
!
=
=
"
function
"
)
{
DONE
(
new
Test262Error
(
"
asyncTest
called
with
non
-
function
argument
"
)
)
;
return
;
}
try
{
testFunc
(
)
.
then
(
function
(
)
{
DONE
(
)
;
}
function
(
error
)
{
DONE
(
error
)
;
}
)
;
}
catch
(
syncError
)
{
DONE
(
syncError
)
;
}
}
assert
.
throwsAsync
=
function
(
expectedErrorConstructor
func
message
)
{
return
new
Promise
(
function
(
resolve
)
{
var
fail
=
function
(
detail
)
{
if
(
message
=
=
=
undefined
)
{
throw
new
Test262Error
(
detail
)
;
}
throw
new
Test262Error
(
message
+
"
"
+
detail
)
;
}
;
if
(
typeof
expectedErrorConstructor
!
=
=
"
function
"
)
{
fail
(
"
assert
.
throwsAsync
called
with
an
argument
that
is
not
an
error
constructor
"
)
;
}
if
(
typeof
func
!
=
=
"
function
"
)
{
fail
(
"
assert
.
throwsAsync
called
with
an
argument
that
is
not
a
function
"
)
;
}
var
expectedName
=
expectedErrorConstructor
.
name
;
var
expectation
=
"
Expected
a
"
+
expectedName
+
"
to
be
thrown
asynchronously
"
;
var
res
;
try
{
res
=
func
(
)
;
}
catch
(
thrown
)
{
fail
(
expectation
+
"
but
the
function
threw
synchronously
"
)
;
}
if
(
res
=
=
=
null
|
|
typeof
res
!
=
=
"
object
"
|
|
typeof
res
.
then
!
=
=
"
function
"
)
{
fail
(
expectation
+
"
but
result
was
not
a
thenable
"
)
;
}
var
onResFulfilled
onResRejected
;
var
resSettlementP
=
new
Promise
(
function
(
onFulfilled
onRejected
)
{
onResFulfilled
=
onFulfilled
;
onResRejected
=
onRejected
;
}
)
;
try
{
res
.
then
(
onResFulfilled
onResRejected
)
}
catch
(
thrown
)
{
fail
(
expectation
+
"
but
.
then
threw
synchronously
"
)
;
}
resolve
(
resSettlementP
.
then
(
function
(
)
{
fail
(
expectation
+
"
but
no
exception
was
thrown
at
all
"
)
;
}
function
(
thrown
)
{
var
actualName
;
if
(
thrown
=
=
=
null
|
|
typeof
thrown
!
=
=
"
object
"
)
{
fail
(
expectation
+
"
but
thrown
value
was
not
an
object
"
)
;
}
else
if
(
thrown
.
constructor
!
=
=
expectedErrorConstructor
)
{
actualName
=
thrown
.
constructor
.
name
;
if
(
expectedName
=
=
=
actualName
)
{
fail
(
expectation
+
"
but
got
a
different
error
constructor
with
the
same
name
"
)
;
}
fail
(
expectation
+
"
but
got
a
"
+
actualName
)
;
}
}
)
)
;
}
)
;
}
;
{
let
getReport
=
262
.
agent
.
getReport
.
bind
(
262
.
agent
)
;
262
.
agent
.
getReport
=
function
(
)
{
var
r
;
while
(
(
r
=
getReport
(
)
)
=
=
null
)
{
262
.
agent
.
sleep
(
1
)
;
}
return
r
;
}
;
if
(
this
.
setTimeout
=
=
=
undefined
)
{
(
function
(
that
)
{
that
.
setTimeout
=
function
(
callback
delay
)
{
let
p
=
Promise
.
resolve
(
)
;
let
start
=
Date
.
now
(
)
;
let
end
=
start
+
delay
;
function
check
(
)
{
if
(
(
end
-
Date
.
now
(
)
)
>
0
)
{
p
.
then
(
check
)
;
}
else
{
callback
(
)
;
}
}
p
.
then
(
check
)
;
}
}
)
(
this
)
;
}
262
.
agent
.
setTimeout
=
setTimeout
;
262
.
agent
.
getReportAsync
=
function
(
)
{
return
new
Promise
(
function
(
resolve
)
{
(
function
loop
(
)
{
let
result
=
getReport
(
)
;
if
(
!
result
)
{
setTimeout
(
loop
1000
)
;
}
else
{
resolve
(
result
)
;
}
}
)
(
)
;
}
)
;
}
;
}
262
.
agent
.
safeBroadcast
=
function
(
typedArray
)
{
let
Constructor
=
Object
.
getPrototypeOf
(
typedArray
)
.
constructor
;
let
temp
=
new
Constructor
(
new
SharedArrayBuffer
(
Constructor
.
BYTES_PER_ELEMENT
)
)
;
try
{
Atomics
.
wait
(
temp
0
Constructor
=
=
=
Int32Array
?
1
:
BigInt
(
1
)
)
;
}
catch
(
error
)
{
throw
new
Test262Error
(
{
Constructor
.
name
}
cannot
be
used
as
a
shared
typed
array
.
(
{
error
}
)
)
;
}
262
.
agent
.
broadcast
(
typedArray
.
buffer
)
;
}
;
262
.
agent
.
safeBroadcastAsync
=
async
function
(
ta
index
expected
)
{
await
262
.
agent
.
broadcast
(
ta
.
buffer
)
;
await
262
.
agent
.
waitUntil
(
ta
index
expected
)
;
await
262
.
agent
.
tryYield
(
)
;
return
await
Atomics
.
load
(
ta
index
)
;
}
;
262
.
agent
.
waitUntil
=
function
(
typedArray
index
expected
)
{
var
agents
=
0
;
while
(
(
agents
=
Atomics
.
load
(
typedArray
index
)
)
!
=
=
expected
)
{
}
assert
.
sameValue
(
agents
expected
"
Reporting
number
of
'
agents
'
equals
the
value
of
'
expected
'
"
)
;
}
;
262
.
agent
.
timeouts
=
{
yield
:
100
small
:
200
long
:
1000
huge
:
10000
}
;
262
.
agent
.
tryYield
=
function
(
)
{
262
.
agent
.
sleep
(
262
.
agent
.
timeouts
.
yield
)
;
}
;
262
.
agent
.
trySleep
=
function
(
ms
)
{
262
.
agent
.
sleep
(
ms
)
;
}
;
function
DETACHBUFFER
(
buffer
)
{
if
(
!
262
|
|
typeof
262
.
detachArrayBuffer
!
=
=
"
function
"
)
{
throw
new
Test262Error
(
"
No
method
available
to
detach
an
ArrayBuffer
"
)
;
}
262
.
detachArrayBuffer
(
buffer
)
;
}
