function
nextUp
(
num
)
{
if
(
!
Number
.
isFinite
(
num
)
)
{
return
num
;
}
if
(
num
=
=
=
0
)
{
return
Number
.
MIN_VALUE
;
}
var
f64
=
new
Float64Array
(
[
num
]
)
;
var
u64
=
new
BigUint64Array
(
f64
.
buffer
)
;
u64
[
0
]
+
=
(
num
<
0
?
-
1n
:
1n
)
;
return
f64
[
0
]
;
}
function
nextDown
(
num
)
{
if
(
!
Number
.
isFinite
(
num
)
)
{
return
num
;
}
if
(
num
=
=
=
0
)
{
return
-
Number
.
MIN_VALUE
;
}
var
f64
=
new
Float64Array
(
[
num
]
)
;
var
u64
=
new
BigUint64Array
(
f64
.
buffer
)
;
u64
[
0
]
+
=
(
num
<
0
?
1n
:
-
1n
)
;
return
f64
[
0
]
;
}
function
f64Repr
(
f
)
{
const
buf
=
new
ArrayBuffer
(
8
)
;
new
DataView
(
buf
)
.
setFloat64
(
0
f
)
;
return
new
Uint8Array
(
buf
)
;
}
function
createTimeZone
(
)
{
const
tz
=
new
Temporal
.
TimeZone
(
"
UTC
"
)
;
TemporalHelpers
.
substituteMethod
(
tz
"
getPossibleInstantsFor
"
[
TemporalHelpers
.
SUBSTITUTE_SKIP
[
new
Temporal
.
Instant
(
-
86400_0000_0000_000_000_000n
)
]
[
new
Temporal
.
Instant
(
86400_0000_0000_000_000_000n
-
100_000_000n
)
]
]
)
;
return
tz
;
}
function
createRelativeTo
(
)
{
return
new
Temporal
.
ZonedDateTime
(
-
86400_0000_0000_000_000_000n
createTimeZone
(
)
)
;
}
const
d
=
new
Temporal
.
Duration
(
0
0
0
0
0
0
0
0
0
1
)
;
const
expected
=
5
.
7870370370370_705268347050756396228860247432848547e
-
23
;
assert
.
sameValue
(
expected
5
.
7870370370370_6998177e
-
23
"
the
float
representation
of
the
result
is
5
.
7870370370370_6998177e
-
23
"
)
;
assert
.
compareArray
(
f64Repr
(
expected
)
[
0x3b
0x51
0x7d
0x80
0xc6
0xf1
0x14
0xa8
]
"
the
bit
representation
of
the
result
is
0x3b517d80c6f114a8
"
)
;
assert
.
sameValue
(
nextDown
(
expected
)
5
.
7870370370370_6880628e
-
23
"
the
next
Number
in
direction
-
Infinity
is
less
precise
"
)
;
assert
.
sameValue
(
nextUp
(
expected
)
5
.
7870370370370_7115727e
-
23
"
the
next
Number
in
direction
+
Infinity
is
less
precise
"
)
;
assert
.
sameValue
(
d
.
total
(
{
unit
:
"
years
"
relativeTo
:
createRelativeTo
(
)
}
)
expected
"
Correct
division
by
large
number
in
years
total
"
)
;
assert
.
sameValue
(
d
.
total
(
{
unit
:
"
months
"
relativeTo
:
createRelativeTo
(
)
}
)
expected
"
Correct
division
by
large
number
in
months
total
"
)
;
assert
.
sameValue
(
d
.
total
(
{
unit
:
"
weeks
"
relativeTo
:
createRelativeTo
(
)
}
)
expected
"
Correct
division
by
large
number
in
weeks
total
"
)
;
reportCompare
(
0
0
)
;
