const
units
=
[
"
seconds
"
"
milliseconds
"
"
microseconds
"
"
nanoseconds
"
]
;
const
toNanos
=
{
"
seconds
"
:
1_000_000_000n
"
milliseconds
"
:
1_000_000n
"
microseconds
"
:
1_000n
"
nanoseconds
"
:
1n
}
;
const
integers
=
[
0
1
2
2
*
*
51
2
*
*
52
2
*
*
53
2
*
*
54
]
;
const
fractions
=
[
0
1
10
100
125
200
250
500
750
800
900
950
999
1_000
1_999
2_000
2_999
3_000
3_999
4_000
4_999
999_999
1_000_000
1_000_001
999_999_999
1_000_000_000
1_000_000_001
]
;
const
maxTimeDuration
=
(
2n
*
*
53n
)
*
(
10n
*
*
9n
)
-
1n
;
for
(
let
unit
of
units
.
slice
(
0
-
1
)
)
{
let
smallerUnit
=
units
[
units
.
indexOf
(
unit
)
+
1
]
;
for
(
let
integer
of
integers
)
{
for
(
let
fraction
of
fractions
)
{
let
totalNanoseconds
=
BigInt
(
integer
)
*
toNanos
[
unit
]
+
BigInt
(
fraction
)
*
toNanos
[
smallerUnit
]
;
if
(
totalNanoseconds
>
maxTimeDuration
)
{
continue
;
}
let
i
=
BigInt
(
integer
)
+
BigInt
(
fraction
)
/
1000n
;
let
f
=
String
(
fraction
%
1000
)
.
padStart
(
3
"
0
"
)
;
let
expected
=
Number
(
{
i
}
.
{
f
}
)
;
let
d
=
Temporal
.
Duration
.
from
(
{
[
unit
]
:
integer
[
smallerUnit
]
:
fraction
}
)
;
let
actual
=
d
.
total
(
unit
)
;
assert
.
sameValue
(
actual
expected
{
unit
}
=
{
integer
}
{
smallerUnit
}
=
{
fraction
}
)
;
}
}
}
reportCompare
(
0
0
)
;
