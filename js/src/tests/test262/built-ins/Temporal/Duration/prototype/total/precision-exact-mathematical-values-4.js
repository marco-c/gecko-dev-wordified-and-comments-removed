function
nextUp
(
num
)
{
if
(
!
Number
.
isFinite
(
num
)
)
{
return
num
;
}
if
(
num
=
=
=
0
)
{
return
Number
.
MIN_VALUE
;
}
var
f64
=
new
Float64Array
(
[
num
]
)
;
var
u64
=
new
BigUint64Array
(
f64
.
buffer
)
;
u64
[
0
]
+
=
(
num
<
0
?
-
1n
:
1n
)
;
return
f64
[
0
]
;
}
function
nextDown
(
num
)
{
if
(
!
Number
.
isFinite
(
num
)
)
{
return
num
;
}
if
(
num
=
=
=
0
)
{
return
-
Number
.
MIN_VALUE
;
}
var
f64
=
new
Float64Array
(
[
num
]
)
;
var
u64
=
new
BigUint64Array
(
f64
.
buffer
)
;
u64
[
0
]
+
=
(
num
<
0
?
1n
:
-
1n
)
;
return
f64
[
0
]
;
}
function
f64Repr
(
f
)
{
const
buf
=
new
ArrayBuffer
(
8
)
;
new
DataView
(
buf
)
.
setFloat64
(
0
f
)
;
return
new
Uint8Array
(
buf
)
;
}
function
createTimeZone
(
)
{
const
tz
=
new
Temporal
.
TimeZone
(
"
UTC
"
)
;
TemporalHelpers
.
substituteMethod
(
tz
"
getPossibleInstantsFor
"
[
TemporalHelpers
.
SUBSTITUTE_SKIP
TemporalHelpers
.
SUBSTITUTE_SKIP
[
new
Temporal
.
Instant
(
-
86400_0000_0000_000_000_000n
)
]
[
new
Temporal
.
Instant
(
86400_0000_0000_000_000_000n
)
]
]
)
;
return
tz
;
}
function
createRelativeTo
(
)
{
return
new
Temporal
.
ZonedDateTime
(
-
86400_0000_0000_000_000_000n
createTimeZone
(
)
)
;
}
const
expected
=
1
.
000001830000000_5355699074074074074074074074074074
;
assert
.
sameValue
(
expected
1
.
000001830000000_64659
"
the
float
representation
of
the
result
is
1
.
00000183000000064659
"
)
;
assert
.
compareArray
(
f64Repr
(
expected
)
[
0x3f
0xf0
0x00
0x01
0xeb
0x3c
0xa4
0x79
]
"
the
bit
representation
of
the
result
is
0x3ff00001eb3ca479
"
)
;
assert
.
sameValue
(
nextDown
(
expected
)
1
.
000001830000000_42455
"
the
next
Number
in
direction
-
Infinity
is
less
precise
"
)
;
assert
.
sameValue
(
nextUp
(
expected
)
1
.
000001830000000_86864
"
the
next
Number
in
direction
+
Infinity
is
less
precise
"
)
;
const
duration
=
new
Temporal
.
Duration
(
1
0
0
0
0
0
0
9
254
648
)
;
assert
.
sameValue
(
duration
.
total
(
{
unit
:
"
years
"
relativeTo
:
createRelativeTo
(
)
}
)
expected
"
Correct
division
by
large
number
in
years
total
"
)
;
reportCompare
(
0
0
)
;
