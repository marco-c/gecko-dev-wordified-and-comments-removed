function
nextUp
(
num
)
{
if
(
!
Number
.
isFinite
(
num
)
)
{
return
num
;
}
if
(
num
=
=
=
0
)
{
return
Number
.
MIN_VALUE
;
}
var
f64
=
new
Float64Array
(
[
num
]
)
;
var
u64
=
new
BigUint64Array
(
f64
.
buffer
)
;
u64
[
0
]
+
=
(
num
<
0
?
-
1n
:
1n
)
;
return
f64
[
0
]
;
}
function
nextDown
(
num
)
{
if
(
!
Number
.
isFinite
(
num
)
)
{
return
num
;
}
if
(
num
=
=
=
0
)
{
return
-
Number
.
MIN_VALUE
;
}
var
f64
=
new
Float64Array
(
[
num
]
)
;
var
u64
=
new
BigUint64Array
(
f64
.
buffer
)
;
u64
[
0
]
+
=
(
num
<
0
?
1n
:
-
1n
)
;
return
f64
[
0
]
;
}
let
duration
=
Temporal
.
Duration
.
from
(
{
hours
:
4000
nanoseconds
:
1
}
)
;
let
total
=
duration
.
total
(
{
unit
:
"
hours
"
}
)
;
const
expected
=
4000
.
0000000000005
;
assert
.
sameValue
(
expected
4000
.
0000000000002777
"
the
float
representation
of
the
result
is
4000
.
0000000000005
"
)
;
assert
.
sameValue
(
nextDown
(
expected
)
4000
"
the
next
Number
in
direction
-
Infinity
is
less
precise
"
)
;
assert
.
sameValue
(
nextUp
(
expected
)
4000
.
000000000001
"
the
next
Number
in
direction
+
Infinity
is
less
precise
"
)
;
assert
.
sameValue
(
total
expected
"
return
value
of
total
(
)
"
)
;
reportCompare
(
0
0
)
;
