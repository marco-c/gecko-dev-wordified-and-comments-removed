const
oneNsDuration
=
Temporal
.
Duration
.
from
(
{
nanoseconds
:
1
}
)
;
const
negOneNsDuration
=
Temporal
.
Duration
.
from
(
{
nanoseconds
:
-
1
}
)
;
const
dayNs
=
86_400_000_000_000
;
const
epochInstant
=
new
Temporal
.
Instant
(
0n
)
;
function
timeZoneSubstituteValues
(
getPossibleInstantsFor
getOffsetNanosecondsFor
)
{
const
tz
=
new
Temporal
.
TimeZone
(
"
UTC
"
)
;
TemporalHelpers
.
substituteMethod
(
tz
"
getPossibleInstantsFor
"
getPossibleInstantsFor
)
;
TemporalHelpers
.
substituteMethod
(
tz
"
getOffsetNanosecondsFor
"
getOffsetNanosecondsFor
)
;
return
tz
;
}
let
zdt
=
new
Temporal
.
ZonedDateTime
(
0n
timeZoneSubstituteValues
(
[
[
epochInstant
]
]
[
TemporalHelpers
.
SUBSTITUTE_SKIP
dayNs
-
1
-
dayNs
+
1
]
)
)
;
assert
.
throws
(
RangeError
(
)
=
>
oneNsDuration
.
total
(
{
relativeTo
:
zdt
unit
:
"
day
"
}
)
"
RangeError
when
days
<
0
and
sign
=
1
"
)
;
zdt
=
new
Temporal
.
ZonedDateTime
(
0n
timeZoneSubstituteValues
(
[
[
epochInstant
]
]
[
TemporalHelpers
.
SUBSTITUTE_SKIP
-
dayNs
+
1
dayNs
-
1
]
)
)
;
assert
.
throws
(
RangeError
(
)
=
>
negOneNsDuration
.
total
(
{
relativeTo
:
zdt
unit
:
"
day
"
}
)
"
RangeError
when
days
>
0
and
sign
=
-
1
"
)
;
zdt
=
new
Temporal
.
ZonedDateTime
(
0n
timeZoneSubstituteValues
(
[
[
new
Temporal
.
Instant
(
-
2n
)
]
[
new
Temporal
.
Instant
(
-
4n
)
]
]
[
TemporalHelpers
.
SUBSTITUTE_SKIP
dayNs
-
1
-
dayNs
+
1
]
)
)
;
assert
.
throws
(
RangeError
(
)
=
>
negOneNsDuration
.
total
(
{
relativeTo
:
zdt
unit
:
"
day
"
}
)
"
RangeError
when
nanoseconds
>
0
and
sign
=
-
1
"
)
;
reportCompare
(
0
0
)
;
