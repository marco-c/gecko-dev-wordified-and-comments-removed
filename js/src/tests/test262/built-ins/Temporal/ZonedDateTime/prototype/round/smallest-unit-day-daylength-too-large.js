class
TimeZone
extends
Temporal
.
TimeZone
{
#
count
=
0
;
#
nanoseconds
;
constructor
(
nanoseconds
)
{
super
(
"
UTC
"
)
;
this
.
#
nanoseconds
=
nanoseconds
;
}
getPossibleInstantsFor
(
dateTime
)
{
if
(
+
+
this
.
#
count
=
=
=
2
)
{
return
[
new
Temporal
.
Instant
(
this
.
#
nanoseconds
)
]
;
}
return
super
.
getPossibleInstantsFor
(
dateTime
)
;
}
}
const
maxInstant
=
86_40000_00000_00000_00000n
;
const
minInstant
=
-
86_40000_00000_00000_00000n
;
const
oneDay
=
24n
*
60n
*
60n
*
1000n
*
1000n
*
1000n
{
let
tz
=
new
TimeZone
(
maxInstant
)
;
let
zoned
=
new
Temporal
.
ZonedDateTime
(
0n
tz
)
;
let
result
=
zoned
.
round
(
{
smallestUnit
:
"
days
"
}
)
;
assert
(
zoned
.
equals
(
result
)
)
;
}
{
let
tz
=
new
TimeZone
(
maxInstant
)
;
let
zoned
=
new
Temporal
.
ZonedDateTime
(
minInstant
tz
)
;
let
result
=
zoned
.
round
(
{
smallestUnit
:
"
days
"
}
)
;
assert
(
zoned
.
equals
(
result
)
)
;
}
{
let
tz
=
new
TimeZone
(
minInstant
)
;
let
zoned
=
new
Temporal
.
ZonedDateTime
(
0n
tz
)
;
assert
.
throws
(
RangeError
(
)
=
>
zoned
.
round
(
{
smallestUnit
:
"
days
"
}
)
)
;
}
{
let
tz
=
new
TimeZone
(
minInstant
)
;
let
zoned
=
new
Temporal
.
ZonedDateTime
(
maxInstant
-
oneDay
tz
)
;
assert
.
throws
(
RangeError
(
)
=
>
zoned
.
round
(
{
smallestUnit
:
"
days
"
}
)
)
;
}
reportCompare
(
0
0
)
;
