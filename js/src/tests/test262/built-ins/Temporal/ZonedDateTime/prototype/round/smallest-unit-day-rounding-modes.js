class
TimeZone
extends
Temporal
.
TimeZone
{
#
count
=
0
;
#
nanoseconds
;
constructor
(
nanoseconds
)
{
super
(
"
UTC
"
)
;
this
.
#
nanoseconds
=
nanoseconds
;
}
getPossibleInstantsFor
(
dateTime
)
{
if
(
+
+
this
.
#
count
=
=
=
2
)
{
return
[
new
Temporal
.
Instant
(
this
.
#
nanoseconds
)
]
;
}
return
super
.
getPossibleInstantsFor
(
dateTime
)
;
}
}
function
test
(
epochNanoseconds
tomorrowEpochNanoseconds
testCases
)
{
for
(
let
[
roundingMode
expected
]
of
Object
.
entries
(
testCases
)
)
{
let
timeZone
=
new
TimeZone
(
tomorrowEpochNanoseconds
)
;
let
zoned
=
new
Temporal
.
ZonedDateTime
(
epochNanoseconds
timeZone
)
;
let
result
=
zoned
.
round
(
{
smallestUnit
:
"
days
"
roundingMode
}
)
;
assert
.
sameValue
(
result
.
epochNanoseconds
expected
)
;
}
}
const
oneDay
=
24n
*
60n
*
60n
*
1000n
*
1000n
*
1000n
;
test
(
3n
10n
{
ceil
:
oneDay
floor
:
0n
trunc
:
0n
halfExpand
:
0n
}
)
;
test
(
-
3n
10n
{
ceil
:
0n
floor
:
-
oneDay
trunc
:
-
oneDay
halfExpand
:
0n
}
)
;
test
(
-
3n
-
10n
{
ceil
:
oneDay
floor
:
0n
trunc
:
0n
halfExpand
:
0n
}
)
;
test
(
3n
9223372036854775807n
{
ceil
:
oneDay
floor
:
0n
trunc
:
0n
halfExpand
:
0n
}
)
;
reportCompare
(
0
0
)
;
