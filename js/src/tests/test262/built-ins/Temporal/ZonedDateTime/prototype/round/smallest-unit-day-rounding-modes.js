class
TimeZone
extends
Temporal
.
TimeZone
{
#
count
=
0
;
#
nanoseconds
;
constructor
(
todayEpochNanoseconds
tomorrowEpochNanoseconds
)
{
super
(
"
UTC
"
)
;
this
.
#
nanoseconds
=
[
todayEpochNanoseconds
tomorrowEpochNanoseconds
]
;
}
getPossibleInstantsFor
(
dateTime
)
{
const
nanoseconds
=
this
.
#
nanoseconds
[
this
.
#
count
+
+
]
;
if
(
nanoseconds
=
=
=
undefined
)
{
return
super
.
getPossibleInstantsFor
(
dateTime
)
;
}
return
[
new
Temporal
.
Instant
(
nanoseconds
)
]
;
}
}
function
test
(
epochNanoseconds
todayEpochNanoseconds
tomorrowEpochNanoseconds
testCases
)
{
for
(
let
[
roundingMode
expected
]
of
Object
.
entries
(
testCases
)
)
{
let
timeZone
=
new
TimeZone
(
todayEpochNanoseconds
tomorrowEpochNanoseconds
)
;
let
zoned
=
new
Temporal
.
ZonedDateTime
(
epochNanoseconds
timeZone
)
;
let
result
=
zoned
.
round
(
{
smallestUnit
:
"
days
"
roundingMode
}
)
;
assert
.
sameValue
(
result
.
epochNanoseconds
expected
)
;
}
}
const
oneDay
=
24n
*
60n
*
60n
*
1000n
*
1000n
*
1000n
;
test
(
3n
undefined
10n
{
ceil
:
10n
floor
:
0n
trunc
:
0n
halfExpand
:
0n
}
)
;
test
(
-
3n
undefined
10n
{
ceil
:
10n
floor
:
-
oneDay
trunc
:
-
oneDay
halfExpand
:
10n
}
)
;
assert
.
throws
(
RangeError
(
)
=
>
{
test
(
-
3n
0n
10n
{
ceil
:
undefined
}
)
;
}
"
instant
is
before
TimeZone
protocol
'
s
start
-
of
-
day
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
{
test
(
-
3n
undefined
-
10n
{
ceil
:
undefined
}
)
;
}
"
instant
is
after
TimeZone
protocol
'
s
end
-
of
-
day
"
)
;
assert
.
throws
(
RangeError
(
)
=
>
{
test
(
0n
0n
0n
{
ceil
:
undefined
}
)
;
}
"
instant
is
within
zero
-
duration
day
"
)
;
test
(
3n
undefined
9223372036854775807n
{
ceil
:
9223372036854775807n
floor
:
0n
trunc
:
0n
halfExpand
:
0n
}
)
;
reportCompare
(
0
0
)
;
