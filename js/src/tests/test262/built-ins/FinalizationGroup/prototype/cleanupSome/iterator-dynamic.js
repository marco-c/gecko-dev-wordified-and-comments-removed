var
called
=
0
;
var
endOfCall
=
0
;
var
first
second
third
;
var
firstIter
secondIter
thirdIter
;
var
fg
=
new
FinalizationGroup
(
function
(
)
{
}
)
;
function
callback
(
iterator
)
{
called
+
=
1
;
if
(
called
=
=
=
1
)
{
fg
.
cleanupSome
(
callback
)
;
first
=
iterator
.
next
(
)
;
firstIter
=
iterator
;
}
else
if
(
called
=
=
=
2
)
{
fg
.
cleanupSome
(
callback
)
;
second
=
iterator
.
next
(
)
;
secondIter
=
iterator
;
}
else
if
(
called
=
=
=
3
)
{
fg
.
cleanupSome
(
callback
)
;
third
=
iterator
.
next
(
)
;
thirdIter
=
iterator
;
}
endOfCall
+
=
1
;
}
function
emptyCells
(
)
{
var
o1
=
{
}
;
var
o2
=
{
}
;
fg
.
register
(
o1
'
holdings
1
'
)
;
fg
.
register
(
o2
'
holdings
2
'
)
;
var
prom
=
asyncGC
(
o1
o2
)
;
o1
=
null
;
o2
=
null
;
return
prom
;
}
emptyCells
(
)
.
then
(
function
(
)
{
fg
.
cleanupSome
(
callback
)
;
assert
.
sameValue
(
called
4
'
cleanup
successfully
'
)
;
assert
.
sameValue
(
endOfCall
4
'
cleanup
ended
successfully
'
)
;
assert
.
notSameValue
(
firstIter
secondIter
'
callback
is
not
called
with
the
same
iterator
#
1
'
)
;
assert
.
notSameValue
(
firstIter
thirdIter
'
callback
is
not
called
with
the
same
iterator
#
2
'
)
;
assert
.
notSameValue
(
secondIter
thirdIter
'
callback
is
not
called
with
the
same
iterator
#
3
'
)
;
assert
.
sameValue
(
first
.
value
undefined
'
iterator
is
already
consumed
'
)
;
assert
.
sameValue
(
first
.
done
true
'
first
callback
will
find
no
empty
Targets
'
)
;
assert
.
sameValue
(
second
.
done
false
'
second
callback
will
find
an
empty
Target
'
)
;
assert
.
sameValue
(
third
.
done
false
'
third
callback
will
find
an
empty
Target
'
)
;
var
holdings
=
[
second
.
value
third
.
value
]
;
assert
(
holdings
.
includes
(
'
holdings
1
'
)
'
iterators
consume
emptied
cells
#
1
'
)
;
assert
(
holdings
.
includes
(
'
holdings
2
'
)
'
iterators
consume
emptied
cells
#
2
'
)
;
}
)
.
then
(
DONE
resolveAsyncGC
)
;
