const
max
=
new
Temporal
.
ZonedDateTime
(
86400_0000_0000_000_000_000n
"
UTC
"
)
;
for
(
const
timeZone
of
[
"
Etc
/
GMT
+
0
"
"
Europe
/
Amsterdam
"
"
America
/
Vancouver
"
]
)
{
const
limit
=
max
.
withTimeZone
(
timeZone
)
;
const
instance
=
new
Temporal
.
PlainDateTime
(
1970
1
1
1
1
1
1
1
1
)
.
toZonedDateTime
(
timeZone
)
;
instance
.
since
(
limit
{
largestUnit
:
"
years
"
}
)
;
limit
.
since
(
instance
{
largestUnit
:
"
years
"
}
)
;
const
resultTimeUnit
=
instance
.
until
(
limit
{
largestUnit
:
"
seconds
"
}
)
;
TemporalHelpers
.
assertDurationsEqual
(
limit
.
until
(
instance
{
largestUnit
:
"
seconds
"
}
)
resultTimeUnit
.
negated
(
)
Arithmetic
until
limit
with
time
largestUnit
is
self
-
consistent
(
{
timeZone
}
)
)
;
}
const
min
=
new
Temporal
.
ZonedDateTime
(
-
86400_0000_0000_000_000_000n
"
UTC
"
)
;
for
(
const
timeZone
of
[
"
Etc
/
GMT
+
0
"
"
Europe
/
Amsterdam
"
"
America
/
Vancouver
"
]
)
{
const
limit
=
min
.
withTimeZone
(
timeZone
)
;
const
instance
=
new
Temporal
.
PlainDateTime
(
1970
9
1
15
47
32
)
.
toZonedDateTime
(
timeZone
)
;
instance
.
since
(
limit
{
largestUnit
:
"
years
"
}
)
;
limit
.
since
(
instance
{
largestUnit
:
"
years
"
}
)
;
const
resultTimeUnit
=
instance
.
until
(
limit
{
largestUnit
:
"
seconds
"
}
)
;
TemporalHelpers
.
assertDurationsEqual
(
limit
.
until
(
instance
{
largestUnit
:
"
seconds
"
}
)
resultTimeUnit
.
negated
(
)
Arithmetic
until
limit
with
time
largestUnit
is
self
-
consistent
(
{
timeZone
}
)
)
;
}
reportCompare
(
0
0
)
;
