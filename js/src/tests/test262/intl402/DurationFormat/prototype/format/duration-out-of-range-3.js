function
nextDown
(
num
)
{
if
(
!
Number
.
isFinite
(
num
)
)
{
return
num
;
}
if
(
num
=
=
=
0
)
{
return
-
Number
.
MIN_VALUE
;
}
var
f64
=
new
Float64Array
(
[
num
]
)
;
var
u64
=
new
BigUint64Array
(
f64
.
buffer
)
;
u64
[
0
]
+
=
(
num
<
0
?
1n
:
-
1n
)
;
return
f64
[
0
]
;
}
function
negatedDuration
(
duration
)
{
let
result
=
{
.
.
.
duration
}
;
for
(
let
key
of
Object
.
keys
(
result
)
)
{
result
[
key
]
=
-
result
[
key
]
+
0
;
}
return
result
;
}
function
fromNanoseconds
(
unit
value
)
{
switch
(
unit
)
{
case
"
days
"
:
return
value
/
(
86400n
*
1_000_000_000n
)
;
case
"
hours
"
:
return
value
/
(
3600n
*
1_000_000_000n
)
;
case
"
minutes
"
:
return
value
/
(
60n
*
1_000_000_000n
)
;
case
"
seconds
"
:
return
value
/
1_000_000_000n
;
case
"
milliseconds
"
:
return
value
/
1_000_000n
;
case
"
microseconds
"
:
return
value
/
1_000n
;
case
"
nanoseconds
"
:
return
value
;
}
throw
new
Error
(
"
invalid
unit
:
"
+
unit
)
;
}
function
toNanoseconds
(
unit
value
)
{
switch
(
unit
)
{
case
"
days
"
:
return
value
*
86400n
*
1_000_000_000n
;
case
"
hours
"
:
return
value
*
3600n
*
1_000_000_000n
;
case
"
minutes
"
:
return
value
*
60n
*
1_000_000_000n
;
case
"
seconds
"
:
return
value
*
1_000_000_000n
;
case
"
milliseconds
"
:
return
value
*
1_000_000n
;
case
"
microseconds
"
:
return
value
*
1_000n
;
case
"
nanoseconds
"
:
return
value
;
}
throw
new
Error
(
"
invalid
unit
:
"
+
unit
)
;
}
const
df
=
new
Intl
.
DurationFormat
(
)
;
const
units
=
[
"
days
"
"
hours
"
"
minutes
"
"
seconds
"
"
milliseconds
"
"
microseconds
"
"
nanoseconds
"
]
;
const
zeroDuration
=
{
days
:
0
hours
:
0
minutes
:
0
seconds
:
0
milliseconds
:
0
microseconds
:
0
nanoseconds
:
0
}
;
const
maxTimeDuration
=
BigInt
(
Number
.
MAX_SAFE_INTEGER
)
*
1_000_000_000n
+
999_999_999n
;
for
(
let
i
=
0
;
i
<
units
.
length
;
+
+
i
)
{
let
unit
=
units
[
i
]
;
for
(
let
j
=
i
+
1
;
j
<
units
.
length
;
+
+
j
)
{
let
maxUnit
=
fromNanoseconds
(
unit
maxTimeDuration
)
;
let
adjusted
=
BigInt
(
Number
(
maxUnit
)
)
;
if
(
adjusted
<
=
maxUnit
)
{
maxUnit
=
adjusted
;
}
else
{
maxUnit
=
BigInt
(
nextDown
(
Number
(
maxUnit
)
)
)
;
}
let
remaining
=
maxTimeDuration
-
toNanoseconds
(
unit
maxUnit
)
;
let
maxDuration
=
{
.
.
.
zeroDuration
[
unit
]
:
Number
(
maxUnit
)
}
;
for
(
let
k
=
j
;
k
<
units
.
length
;
+
+
k
)
{
let
smallerUnit
=
units
[
k
]
;
let
remainingSmallerUnit
=
fromNanoseconds
(
smallerUnit
remaining
)
;
maxDuration
[
smallerUnit
]
=
Number
(
remainingSmallerUnit
)
;
remaining
-
=
toNanoseconds
(
smallerUnit
remainingSmallerUnit
)
;
}
assert
.
sameValue
(
remaining
0n
"
zero
remaining
nanoseconds
"
)
;
assert
.
sameValue
(
typeof
df
.
format
(
maxDuration
)
"
string
"
Duration
"
{
JSON
.
stringify
(
maxDuration
)
}
"
doesn
'
t
throw
)
;
let
minDuration
=
negatedDuration
(
maxDuration
)
;
assert
.
sameValue
(
typeof
df
.
format
(
minDuration
)
"
string
"
Duration
"
{
JSON
.
stringify
(
minDuration
)
}
"
doesn
'
t
throw
)
;
let
tooLargeDuration
=
{
.
.
.
maxDuration
nanoseconds
:
maxDuration
.
nanoseconds
+
1
}
;
assert
.
throws
(
RangeError
(
)
=
>
df
.
format
(
tooLargeDuration
)
Duration
"
{
JSON
.
stringify
(
tooLargeDuration
)
}
"
throws
)
;
let
tooSmallDuration
=
negatedDuration
(
tooLargeDuration
)
;
assert
.
throws
(
RangeError
(
)
=
>
df
.
format
(
tooSmallDuration
)
Duration
"
{
JSON
.
stringify
(
tooSmallDuration
)
}
"
throws
)
;
}
}
reportCompare
(
0
0
)
;
