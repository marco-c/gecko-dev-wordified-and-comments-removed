function
arrayContains
(
array
subArray
)
{
var
found
;
for
(
var
i
=
0
;
i
<
subArray
.
length
;
i
+
+
)
{
found
=
false
;
for
(
var
j
=
0
;
j
<
array
.
length
;
j
+
+
)
{
if
(
subArray
[
i
]
=
=
=
array
[
j
]
)
{
found
=
true
;
break
;
}
}
if
(
!
found
)
{
return
false
;
}
}
return
true
;
}
function
assertRelativeDateMs
(
date
expectedMs
)
{
var
actualMs
=
date
.
valueOf
(
)
;
var
localOffset
=
date
.
getTimezoneOffset
(
)
*
60000
;
if
(
actualMs
-
localOffset
!
=
=
expectedMs
)
{
ERROR
(
'
Expected
'
+
date
+
'
to
be
'
+
expectedMs
+
'
milliseconds
from
the
Unix
epoch
'
)
;
}
}
var
byteConversionValues
=
{
values
:
[
127
128
32767
32768
2147483647
2147483648
255
256
65535
65536
4294967295
4294967296
9007199254740991
9007199254740992
1
.
1
0
.
1
0
.
5
0
.
50000001
0
.
6
0
.
7
undefined
-
1
-
0
-
0
.
1
-
1
.
1
NaN
-
127
-
128
-
32767
-
32768
-
2147483647
-
2147483648
-
255
-
256
-
65535
-
65536
-
4294967295
-
4294967296
Infinity
-
Infinity
0
]
expected
:
{
Int8
:
[
127
-
128
-
1
0
-
1
0
-
1
0
-
1
0
-
1
0
-
1
0
1
0
0
0
0
0
0
-
1
0
0
-
1
0
-
127
-
128
1
0
1
0
1
0
1
0
1
0
0
0
0
]
Uint8
:
[
127
128
255
0
255
0
255
0
255
0
255
0
255
0
1
0
0
0
0
0
0
255
0
0
255
0
129
128
1
0
1
0
1
0
1
0
1
0
0
0
0
]
Uint8Clamped
:
[
127
128
255
255
255
255
255
255
255
255
255
255
255
255
1
0
0
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
255
0
0
]
Int16
:
[
127
128
32767
-
32768
-
1
0
255
256
-
1
0
-
1
0
-
1
0
1
0
0
0
0
0
0
-
1
0
0
-
1
0
-
127
-
128
-
32767
-
32768
1
0
-
255
-
256
1
0
1
0
0
0
0
]
Uint16
:
[
127
128
32767
32768
65535
0
255
256
65535
0
65535
0
65535
0
1
0
0
0
0
0
0
65535
0
0
65535
0
65409
65408
32769
32768
1
0
65281
65280
1
0
1
0
0
0
0
]
Int32
:
[
127
128
32767
32768
2147483647
-
2147483648
255
256
65535
65536
-
1
0
-
1
0
1
0
0
0
0
0
0
-
1
0
0
-
1
0
-
127
-
128
-
32767
-
32768
-
2147483647
-
2147483648
-
255
-
256
-
65535
-
65536
1
0
0
0
0
]
Uint32
:
[
127
128
32767
32768
2147483647
2147483648
255
256
65535
65536
4294967295
0
4294967295
0
1
0
0
0
0
0
0
4294967295
0
0
4294967295
0
4294967169
4294967168
4294934529
4294934528
2147483649
2147483648
4294967041
4294967040
4294901761
4294901760
1
0
0
0
0
]
Float32
:
[
127
128
32767
32768
2147483648
2147483648
255
256
65535
65536
4294967296
4294967296
9007199254740992
9007199254740992
1
.
100000023841858
0
.
10000000149011612
0
.
5
0
.
5
0
.
6000000238418579
0
.
699999988079071
NaN
-
1
-
0
-
0
.
10000000149011612
-
1
.
100000023841858
NaN
-
127
-
128
-
32767
-
32768
-
2147483648
-
2147483648
-
255
-
256
-
65535
-
65536
-
4294967296
-
4294967296
Infinity
-
Infinity
0
]
Float64
:
[
127
128
32767
32768
2147483647
2147483648
255
256
65535
65536
4294967295
4294967296
9007199254740991
9007199254740992
1
.
1
0
.
1
0
.
5
0
.
50000001
0
.
6
0
.
7
NaN
-
1
-
0
-
0
.
1
-
1
.
1
NaN
-
127
-
128
-
32767
-
32768
-
2147483647
-
2147483648
-
255
-
256
-
65535
-
65536
-
4294967295
-
4294967296
Infinity
-
Infinity
0
]
}
}
;
var
date_1899_end
=
-
2208988800001
;
var
date_1900_start
=
-
2208988800000
;
var
date_1969_end
=
-
1
;
var
date_1970_start
=
0
;
var
date_1999_end
=
946684799999
;
var
date_2000_start
=
946684800000
;
var
date_2099_end
=
4102444799999
;
var
date_2100_start
=
4102444800000
;
var
start_of_time
=
-
8
.
64e15
;
var
end_of_time
=
8
.
64e15
;
function
decimalToHexString
(
n
)
{
var
hex
=
"
0123456789ABCDEF
"
;
n
>
>
>
=
0
;
var
s
=
"
"
;
while
(
n
)
{
s
=
hex
[
n
&
0xf
]
+
s
;
n
>
>
>
=
4
;
}
while
(
s
.
length
<
4
)
{
s
=
"
0
"
+
s
;
}
return
s
;
}
function
decimalToPercentHexString
(
n
)
{
var
hex
=
"
0123456789ABCDEF
"
;
return
"
%
"
+
hex
[
(
n
>
>
4
)
&
0xf
]
+
hex
[
n
&
0xf
]
;
}
assert
.
deepEqual
=
function
(
actual
expected
message
)
{
var
format
=
assert
.
deepEqual
.
format
;
assert
(
assert
.
deepEqual
.
_compare
(
actual
expected
)
Expected
{
format
(
actual
)
}
to
be
structurally
equal
to
{
format
(
expected
)
}
.
{
(
message
|
|
'
'
)
}
)
;
}
;
assert
.
deepEqual
.
format
=
function
(
value
seen
)
{
switch
(
typeof
value
)
{
case
'
string
'
:
return
typeof
JSON
!
=
=
"
undefined
"
?
JSON
.
stringify
(
value
)
:
"
{
value
}
"
;
case
'
number
'
:
case
'
boolean
'
:
case
'
symbol
'
:
case
'
bigint
'
:
return
value
.
toString
(
)
;
case
'
undefined
'
:
return
'
undefined
'
;
case
'
function
'
:
return
[
Function
{
value
.
name
?
:
{
value
.
name
}
:
'
'
}
]
;
case
'
object
'
:
if
(
value
=
=
=
null
)
return
'
null
'
;
if
(
value
instanceof
Date
)
return
Date
"
{
value
.
toISOString
(
)
}
"
;
if
(
value
instanceof
RegExp
)
return
value
.
toString
(
)
;
if
(
!
seen
)
{
seen
=
{
counter
:
0
map
:
new
Map
(
)
}
;
}
let
usage
=
seen
.
map
.
get
(
value
)
;
if
(
usage
)
{
usage
.
used
=
true
;
return
[
Ref
:
#
{
usage
.
id
}
]
;
}
usage
=
{
id
:
+
+
seen
.
counter
used
:
false
}
;
seen
.
map
.
set
(
value
usage
)
;
if
(
typeof
Set
!
=
=
"
undefined
"
&
&
value
instanceof
Set
)
{
return
Set
{
{
Array
.
from
(
value
)
.
map
(
value
=
>
assert
.
deepEqual
.
format
(
value
seen
)
)
.
join
(
'
'
)
}
}
{
usage
.
used
?
as
#
{
usage
.
id
}
:
'
'
}
;
}
if
(
typeof
Map
!
=
=
"
undefined
"
&
&
value
instanceof
Map
)
{
return
Map
{
{
Array
.
from
(
value
)
.
map
(
pair
=
>
{
assert
.
deepEqual
.
format
(
pair
[
0
]
seen
)
}
=
>
{
assert
.
deepEqual
.
format
(
pair
[
1
]
seen
)
}
}
)
.
join
(
'
'
)
}
}
{
usage
.
used
?
as
#
{
usage
.
id
}
:
'
'
}
;
}
if
(
Array
.
isArray
?
Array
.
isArray
(
value
)
:
value
instanceof
Array
)
{
return
[
{
value
.
map
(
value
=
>
assert
.
deepEqual
.
format
(
value
seen
)
)
.
join
(
'
'
)
}
]
{
usage
.
used
?
as
#
{
usage
.
id
}
:
'
'
}
;
}
let
tag
=
Symbol
.
toStringTag
in
value
?
value
[
Symbol
.
toStringTag
]
:
'
Object
'
;
if
(
tag
=
=
=
'
Object
'
&
&
Object
.
getPrototypeOf
(
value
)
=
=
=
null
)
{
tag
=
'
[
Object
:
null
prototype
]
'
;
}
return
{
tag
?
{
tag
}
:
'
'
}
{
{
Object
.
keys
(
value
)
.
map
(
key
=
>
{
key
.
toString
(
)
}
:
{
assert
.
deepEqual
.
format
(
value
[
key
]
seen
)
}
)
.
join
(
'
'
)
}
}
{
usage
.
used
?
as
#
{
usage
.
id
}
:
'
'
}
;
default
:
return
typeof
value
;
}
}
;
assert
.
deepEqual
.
_compare
=
(
function
(
)
{
var
EQUAL
=
1
;
var
NOT_EQUAL
=
-
1
;
var
UNKNOWN
=
0
;
function
deepEqual
(
a
b
)
{
return
compareEquality
(
a
b
)
=
=
=
EQUAL
;
}
function
compareEquality
(
a
b
cache
)
{
return
compareIf
(
a
b
isOptional
compareOptionality
)
|
|
compareIf
(
a
b
isPrimitiveEquatable
comparePrimitiveEquality
)
|
|
compareIf
(
a
b
isObjectEquatable
compareObjectEquality
cache
)
|
|
NOT_EQUAL
;
}
function
compareIf
(
a
b
test
compare
cache
)
{
return
!
test
(
a
)
?
!
test
(
b
)
?
UNKNOWN
:
NOT_EQUAL
:
!
test
(
b
)
?
NOT_EQUAL
:
cacheComparison
(
a
b
compare
cache
)
;
}
function
tryCompareStrictEquality
(
a
b
)
{
return
a
=
=
=
b
?
EQUAL
:
UNKNOWN
;
}
function
tryCompareTypeOfEquality
(
a
b
)
{
return
typeof
a
!
=
=
typeof
b
?
NOT_EQUAL
:
UNKNOWN
;
}
function
tryCompareToStringTagEquality
(
a
b
)
{
var
aTag
=
Symbol
.
toStringTag
in
a
?
a
[
Symbol
.
toStringTag
]
:
undefined
;
var
bTag
=
Symbol
.
toStringTag
in
b
?
b
[
Symbol
.
toStringTag
]
:
undefined
;
return
aTag
!
=
=
bTag
?
NOT_EQUAL
:
UNKNOWN
;
}
function
isOptional
(
value
)
{
return
value
=
=
=
undefined
|
|
value
=
=
=
null
;
}
function
compareOptionality
(
a
b
)
{
return
tryCompareStrictEquality
(
a
b
)
|
|
NOT_EQUAL
;
}
function
isPrimitiveEquatable
(
value
)
{
switch
(
typeof
value
)
{
case
'
string
'
:
case
'
number
'
:
case
'
bigint
'
:
case
'
boolean
'
:
case
'
symbol
'
:
return
true
;
default
:
return
isBoxed
(
value
)
;
}
}
function
comparePrimitiveEquality
(
a
b
)
{
if
(
isBoxed
(
a
)
)
a
=
a
.
valueOf
(
)
;
if
(
isBoxed
(
b
)
)
b
=
b
.
valueOf
(
)
;
return
tryCompareStrictEquality
(
a
b
)
|
|
tryCompareTypeOfEquality
(
a
b
)
|
|
compareIf
(
a
b
isNaNEquatable
compareNaNEquality
)
|
|
NOT_EQUAL
;
}
function
isNaNEquatable
(
value
)
{
return
typeof
value
=
=
=
'
number
'
;
}
function
compareNaNEquality
(
a
b
)
{
return
isNaN
(
a
)
&
&
isNaN
(
b
)
?
EQUAL
:
NOT_EQUAL
;
}
function
isObjectEquatable
(
value
)
{
return
typeof
value
=
=
=
'
object
'
;
}
function
compareObjectEquality
(
a
b
cache
)
{
if
(
!
cache
)
cache
=
new
Map
(
)
;
return
getCache
(
cache
a
b
)
|
|
setCache
(
cache
a
b
EQUAL
)
|
|
cacheComparison
(
a
b
tryCompareStrictEquality
cache
)
|
|
cacheComparison
(
a
b
tryCompareToStringTagEquality
cache
)
|
|
compareIf
(
a
b
isValueOfEquatable
compareValueOfEquality
)
|
|
compareIf
(
a
b
isToStringEquatable
compareToStringEquality
)
|
|
compareIf
(
a
b
isArrayLikeEquatable
compareArrayLikeEquality
cache
)
|
|
compareIf
(
a
b
isStructurallyEquatable
compareStructuralEquality
cache
)
|
|
compareIf
(
a
b
isIterableEquatable
compareIterableEquality
cache
)
|
|
cacheComparison
(
a
b
fail
cache
)
;
}
function
isBoxed
(
value
)
{
return
value
instanceof
String
|
|
value
instanceof
Number
|
|
value
instanceof
Boolean
|
|
typeof
Symbol
=
=
=
'
function
'
&
&
value
instanceof
Symbol
|
|
typeof
BigInt
=
=
=
'
function
'
&
&
value
instanceof
BigInt
;
}
function
isValueOfEquatable
(
value
)
{
return
value
instanceof
Date
;
}
function
compareValueOfEquality
(
a
b
)
{
return
compareIf
(
a
.
valueOf
(
)
b
.
valueOf
(
)
isPrimitiveEquatable
comparePrimitiveEquality
)
|
|
NOT_EQUAL
;
}
function
isToStringEquatable
(
value
)
{
return
value
instanceof
RegExp
;
}
function
compareToStringEquality
(
a
b
)
{
return
compareIf
(
a
.
toString
(
)
b
.
toString
(
)
isPrimitiveEquatable
comparePrimitiveEquality
)
|
|
NOT_EQUAL
;
}
function
isArrayLikeEquatable
(
value
)
{
return
(
Array
.
isArray
?
Array
.
isArray
(
value
)
:
value
instanceof
Array
)
|
|
(
typeof
Uint8Array
=
=
=
'
function
'
&
&
value
instanceof
Uint8Array
)
|
|
(
typeof
Uint8ClampedArray
=
=
=
'
function
'
&
&
value
instanceof
Uint8ClampedArray
)
|
|
(
typeof
Uint16Array
=
=
=
'
function
'
&
&
value
instanceof
Uint16Array
)
|
|
(
typeof
Uint32Array
=
=
=
'
function
'
&
&
value
instanceof
Uint32Array
)
|
|
(
typeof
Int8Array
=
=
=
'
function
'
&
&
value
instanceof
Int8Array
)
|
|
(
typeof
Int16Array
=
=
=
'
function
'
&
&
value
instanceof
Int16Array
)
|
|
(
typeof
Int32Array
=
=
=
'
function
'
&
&
value
instanceof
Int32Array
)
|
|
(
typeof
Float32Array
=
=
=
'
function
'
&
&
value
instanceof
Float32Array
)
|
|
(
typeof
Float64Array
=
=
=
'
function
'
&
&
value
instanceof
Float64Array
)
|
|
(
typeof
BigUint64Array
=
=
=
'
function
'
&
&
value
instanceof
BigUint64Array
)
|
|
(
typeof
BigInt64Array
=
=
=
'
function
'
&
&
value
instanceof
BigInt64Array
)
;
}
function
compareArrayLikeEquality
(
a
b
cache
)
{
if
(
a
.
length
!
=
=
b
.
length
)
return
NOT_EQUAL
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
{
if
(
compareEquality
(
a
[
i
]
b
[
i
]
cache
)
=
=
=
NOT_EQUAL
)
{
return
NOT_EQUAL
;
}
}
return
EQUAL
;
}
function
isStructurallyEquatable
(
value
)
{
return
!
(
typeof
Promise
=
=
=
'
function
'
&
&
value
instanceof
Promise
|
|
typeof
WeakMap
=
=
=
'
function
'
&
&
value
instanceof
WeakMap
|
|
typeof
WeakSet
=
=
=
'
function
'
&
&
value
instanceof
WeakSet
|
|
typeof
Map
=
=
=
'
function
'
&
&
value
instanceof
Map
|
|
typeof
Set
=
=
=
'
function
'
&
&
value
instanceof
Set
)
;
}
function
compareStructuralEquality
(
a
b
cache
)
{
var
aKeys
=
[
]
;
for
(
var
key
in
a
)
aKeys
.
push
(
key
)
;
var
bKeys
=
[
]
;
for
(
var
key
in
b
)
bKeys
.
push
(
key
)
;
if
(
aKeys
.
length
!
=
=
bKeys
.
length
)
{
return
NOT_EQUAL
;
}
aKeys
.
sort
(
)
;
bKeys
.
sort
(
)
;
for
(
var
i
=
0
;
i
<
aKeys
.
length
;
i
+
+
)
{
var
aKey
=
aKeys
[
i
]
;
var
bKey
=
bKeys
[
i
]
;
if
(
compareEquality
(
aKey
bKey
cache
)
=
=
=
NOT_EQUAL
)
{
return
NOT_EQUAL
;
}
if
(
compareEquality
(
a
[
aKey
]
b
[
bKey
]
cache
)
=
=
=
NOT_EQUAL
)
{
return
NOT_EQUAL
;
}
}
return
compareIf
(
a
b
isIterableEquatable
compareIterableEquality
cache
)
|
|
EQUAL
;
}
function
isIterableEquatable
(
value
)
{
return
typeof
Symbol
=
=
=
'
function
'
&
&
typeof
value
[
Symbol
.
iterator
]
=
=
=
'
function
'
;
}
function
compareIteratorEquality
(
a
b
cache
)
{
if
(
typeof
Map
=
=
=
'
function
'
&
&
a
instanceof
Map
&
&
b
instanceof
Map
|
|
typeof
Set
=
=
=
'
function
'
&
&
a
instanceof
Set
&
&
b
instanceof
Set
)
{
if
(
a
.
size
!
=
=
b
.
size
)
return
NOT_EQUAL
;
}
var
ar
br
;
while
(
true
)
{
ar
=
a
.
next
(
)
;
br
=
b
.
next
(
)
;
if
(
ar
.
done
)
{
if
(
br
.
done
)
return
EQUAL
;
if
(
b
.
return
)
b
.
return
(
)
;
return
NOT_EQUAL
;
}
if
(
br
.
done
)
{
if
(
a
.
return
)
a
.
return
(
)
;
return
NOT_EQUAL
;
}
if
(
compareEquality
(
ar
.
value
br
.
value
cache
)
=
=
=
NOT_EQUAL
)
{
if
(
a
.
return
)
a
.
return
(
)
;
if
(
b
.
return
)
b
.
return
(
)
;
return
NOT_EQUAL
;
}
}
}
function
compareIterableEquality
(
a
b
cache
)
{
return
compareIteratorEquality
(
a
[
Symbol
.
iterator
]
(
)
b
[
Symbol
.
iterator
]
(
)
cache
)
;
}
function
cacheComparison
(
a
b
compare
cache
)
{
var
result
=
compare
(
a
b
cache
)
;
if
(
cache
&
&
(
result
=
=
=
EQUAL
|
|
result
=
=
=
NOT_EQUAL
)
)
{
setCache
(
cache
a
b
(
result
)
)
;
}
return
result
;
}
function
fail
(
)
{
return
NOT_EQUAL
;
}
function
setCache
(
cache
left
right
result
)
{
var
otherCache
;
otherCache
=
cache
.
get
(
left
)
;
if
(
!
otherCache
)
cache
.
set
(
left
otherCache
=
new
Map
(
)
)
;
otherCache
.
set
(
right
result
)
;
otherCache
=
cache
.
get
(
right
)
;
if
(
!
otherCache
)
cache
.
set
(
right
otherCache
=
new
Map
(
)
)
;
otherCache
.
set
(
left
result
)
;
}
function
getCache
(
cache
left
right
)
{
var
otherCache
;
var
result
;
otherCache
=
cache
.
get
(
left
)
;
result
=
otherCache
&
&
otherCache
.
get
(
right
)
;
if
(
result
)
return
result
;
otherCache
=
cache
.
get
(
right
)
;
result
=
otherCache
&
&
otherCache
.
get
(
left
)
;
if
(
result
)
return
result
;
return
UNKNOWN
;
}
return
deepEqual
;
}
)
(
)
;
function
DETACHBUFFER
(
buffer
)
{
if
(
!
262
|
|
typeof
262
.
detachArrayBuffer
!
=
=
"
function
"
)
{
throw
new
Test262Error
(
"
No
method
available
to
detach
an
ArrayBuffer
"
)
;
}
262
.
detachArrayBuffer
(
buffer
)
;
}
var
__globalObject
=
Function
(
"
return
this
;
"
)
(
)
;
function
fnGlobalObject
(
)
{
return
__globalObject
;
}
function
isConstructor
(
f
)
{
try
{
Reflect
.
construct
(
function
(
)
{
}
[
]
f
)
;
}
catch
(
e
)
{
return
false
;
}
return
true
;
}
var
NaNs
=
[
NaN
Number
.
NaN
NaN
*
0
0
/
0
Infinity
/
Infinity
-
(
0
/
0
)
Math
.
pow
(
-
1
0
.
5
)
-
Math
.
pow
(
-
1
0
.
5
)
Number
(
"
Not
-
a
-
Number
"
)
]
;
const
NATIVE_FUNCTION_RE
=
/
\
bfunction
\
b
[
\
s
\
S
]
*
\
(
[
\
s
\
S
]
*
\
)
[
\
s
\
S
]
*
\
{
[
\
s
\
S
]
*
\
[
[
\
s
\
S
]
*
\
bnative
\
b
[
\
s
\
S
]
+
\
bcode
\
b
[
\
s
\
S
]
*
\
]
[
\
s
\
S
]
*
\
}
/
;
const
assertToStringOrNativeFunction
=
function
(
fn
expected
)
{
const
actual
=
"
"
+
fn
;
try
{
assert
.
sameValue
(
actual
expected
)
;
}
catch
(
unused
)
{
assertNativeFunction
(
fn
expected
)
;
}
}
;
const
assertNativeFunction
=
function
(
fn
special
)
{
const
actual
=
"
"
+
fn
;
assert
(
NATIVE_FUNCTION_RE
.
test
(
actual
)
"
Conforms
to
NativeFunction
Syntax
:
'
"
+
actual
+
"
'
.
"
+
(
special
?
"
(
"
+
special
+
"
)
"
:
"
"
)
)
;
}
;
function
checkSequence
(
arr
message
)
{
arr
.
forEach
(
function
(
e
i
)
{
if
(
e
!
=
=
(
i
+
1
)
)
{
ERROR
(
(
message
?
message
:
"
Steps
in
unexpected
sequence
:
"
)
+
"
'
"
+
arr
.
join
(
'
'
)
+
"
'
"
)
;
}
}
)
;
return
true
;
}
function
checkSettledPromises
(
settleds
expected
message
)
{
const
prefix
=
message
?
{
message
}
:
:
'
'
;
assert
.
sameValue
(
Array
.
isArray
(
settleds
)
true
{
prefix
}
Settled
values
is
an
array
)
;
assert
.
sameValue
(
settleds
.
length
expected
.
length
{
prefix
}
The
settled
values
has
a
different
length
than
expected
)
;
settleds
.
forEach
(
(
settled
i
)
=
>
{
assert
.
sameValue
(
Object
.
prototype
.
hasOwnProperty
.
call
(
settled
'
status
'
)
true
{
prefix
}
The
settled
value
has
a
property
status
)
;
assert
.
sameValue
(
settled
.
status
expected
[
i
]
.
status
{
prefix
}
status
for
item
{
i
}
)
;
if
(
settled
.
status
=
=
=
'
fulfilled
'
)
{
assert
.
sameValue
(
Object
.
prototype
.
hasOwnProperty
.
call
(
settled
'
value
'
)
true
{
prefix
}
The
fulfilled
promise
has
a
property
named
value
)
;
assert
.
sameValue
(
Object
.
prototype
.
hasOwnProperty
.
call
(
settled
'
reason
'
)
false
{
prefix
}
The
fulfilled
promise
has
no
property
named
reason
)
;
assert
.
sameValue
(
settled
.
value
expected
[
i
]
.
value
{
prefix
}
value
for
item
{
i
}
)
;
}
else
{
assert
.
sameValue
(
settled
.
status
'
rejected
'
{
prefix
}
Valid
statuses
are
only
fulfilled
or
rejected
)
;
assert
.
sameValue
(
Object
.
prototype
.
hasOwnProperty
.
call
(
settled
'
value
'
)
false
{
prefix
}
The
fulfilled
promise
has
no
property
named
value
)
;
assert
.
sameValue
(
Object
.
prototype
.
hasOwnProperty
.
call
(
settled
'
reason
'
)
true
{
prefix
}
The
fulfilled
promise
has
a
property
named
reason
)
;
assert
.
sameValue
(
settled
.
reason
expected
[
i
]
.
reason
{
prefix
}
Reason
value
for
item
{
i
}
)
;
}
}
)
;
}
function
allowProxyTraps
(
overrides
)
{
function
throwTest262Error
(
msg
)
{
return
function
(
)
{
throw
new
Test262Error
(
msg
)
;
}
;
}
if
(
!
overrides
)
{
overrides
=
{
}
;
}
return
{
getPrototypeOf
:
overrides
.
getPrototypeOf
|
|
throwTest262Error
(
'
[
[
GetPrototypeOf
]
]
trap
called
'
)
setPrototypeOf
:
overrides
.
setPrototypeOf
|
|
throwTest262Error
(
'
[
[
SetPrototypeOf
]
]
trap
called
'
)
isExtensible
:
overrides
.
isExtensible
|
|
throwTest262Error
(
'
[
[
IsExtensible
]
]
trap
called
'
)
preventExtensions
:
overrides
.
preventExtensions
|
|
throwTest262Error
(
'
[
[
PreventExtensions
]
]
trap
called
'
)
getOwnPropertyDescriptor
:
overrides
.
getOwnPropertyDescriptor
|
|
throwTest262Error
(
'
[
[
GetOwnProperty
]
]
trap
called
'
)
has
:
overrides
.
has
|
|
throwTest262Error
(
'
[
[
HasProperty
]
]
trap
called
'
)
get
:
overrides
.
get
|
|
throwTest262Error
(
'
[
[
Get
]
]
trap
called
'
)
set
:
overrides
.
set
|
|
throwTest262Error
(
'
[
[
Set
]
]
trap
called
'
)
deleteProperty
:
overrides
.
deleteProperty
|
|
throwTest262Error
(
'
[
[
Delete
]
]
trap
called
'
)
defineProperty
:
overrides
.
defineProperty
|
|
throwTest262Error
(
'
[
[
DefineOwnProperty
]
]
trap
called
'
)
enumerate
:
throwTest262Error
(
'
[
[
Enumerate
]
]
trap
called
:
this
trap
has
been
removed
'
)
ownKeys
:
overrides
.
ownKeys
|
|
throwTest262Error
(
'
[
[
OwnPropertyKeys
]
]
trap
called
'
)
apply
:
overrides
.
apply
|
|
throwTest262Error
(
'
[
[
Call
]
]
trap
called
'
)
construct
:
overrides
.
construct
|
|
throwTest262Error
(
'
[
[
Construct
]
]
trap
called
'
)
}
;
}
var
MAX_ITERATIONS
=
100000
;
var
typedArrayConstructors
=
[
Float64Array
Float32Array
Int32Array
Int16Array
Int8Array
Uint32Array
Uint16Array
Uint8Array
Uint8ClampedArray
]
;
var
floatArrayConstructors
=
typedArrayConstructors
.
slice
(
0
2
)
;
var
intArrayConstructors
=
typedArrayConstructors
.
slice
(
2
7
)
;
var
TypedArray
=
Object
.
getPrototypeOf
(
Int8Array
)
;
function
testWithTypedArrayConstructors
(
f
selected
)
{
var
constructors
=
selected
|
|
typedArrayConstructors
;
for
(
var
i
=
0
;
i
<
constructors
.
length
;
+
+
i
)
{
var
constructor
=
constructors
[
i
]
;
try
{
f
(
constructor
)
;
}
catch
(
e
)
{
e
.
message
+
=
"
(
Testing
with
"
+
constructor
.
name
+
"
.
)
"
;
throw
e
;
}
}
}
function
testWithNonAtomicsFriendlyTypedArrayConstructors
(
f
)
{
testWithTypedArrayConstructors
(
f
[
Float64Array
Float32Array
Uint8ClampedArray
]
)
;
}
function
testWithAtomicsFriendlyTypedArrayConstructors
(
f
)
{
testWithTypedArrayConstructors
(
f
[
Int32Array
Int16Array
Int8Array
Uint32Array
Uint16Array
Uint8Array
]
)
;
}
function
testTypedArrayConversions
(
byteConversionValues
fn
)
{
var
values
=
byteConversionValues
.
values
;
var
expected
=
byteConversionValues
.
expected
;
testWithTypedArrayConstructors
(
function
(
TA
)
{
var
name
=
TA
.
name
.
slice
(
0
-
5
)
;
return
values
.
forEach
(
function
(
value
index
)
{
var
exp
=
expected
[
name
]
[
index
]
;
var
initial
=
0
;
if
(
exp
=
=
=
0
)
{
initial
=
1
;
}
fn
(
TA
value
exp
initial
)
;
}
)
;
}
)
;
}
if
(
Promise
=
=
=
undefined
&
&
this
.
setTimeout
=
=
=
undefined
)
{
if
(
/
\
DONE
(
)
/
.
test
(
code
)
)
ERROR
(
"
Async
test
capability
is
not
supported
in
your
test
environment
"
)
;
}
if
(
Promise
!
=
=
undefined
&
&
this
.
setTimeout
=
=
=
undefined
)
{
(
function
(
that
)
{
that
.
setTimeout
=
function
(
callback
delay
)
{
var
p
=
Promise
.
resolve
(
)
;
var
start
=
Date
.
now
(
)
;
var
end
=
start
+
delay
;
function
check
(
)
{
var
timeLeft
=
end
-
Date
.
now
(
)
;
if
(
timeLeft
>
0
)
p
.
then
(
check
)
;
else
callback
(
)
;
}
p
.
then
(
check
)
;
}
}
)
(
this
)
;
}
