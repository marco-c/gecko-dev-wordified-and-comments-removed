function
ToIntegerOrInfinity
(
arg
)
{
assert
.
sameValue
(
typeof
arg
"
number
"
)
;
return
Number
.
isNaN
(
arg
)
?
0
:
Math
.
trunc
(
arg
)
;
}
function
StringSubstr
(
string
start
length
)
{
assert
.
sameValue
(
typeof
string
"
string
"
)
;
let
size
=
string
.
length
;
let
intStart
=
ToIntegerOrInfinity
(
start
)
;
if
(
intStart
=
=
=
-
Infinity
)
{
intStart
=
0
;
}
else
if
(
intStart
<
0
)
{
intStart
=
Math
.
max
(
size
+
intStart
0
)
;
}
else
{
intStart
=
Math
.
min
(
intStart
size
)
}
assert
(
0
<
=
intStart
&
&
intStart
<
=
size
)
;
let
intLength
=
length
=
=
=
undefined
?
size
:
ToIntegerOrInfinity
(
length
)
;
intLength
=
Math
.
min
(
Math
.
max
(
intLength
0
)
size
)
;
assert
(
0
<
=
intLength
&
&
intLength
<
=
size
)
;
let
intEnd
=
Math
.
min
(
intStart
+
intLength
size
)
;
assert
(
intStart
<
=
intEnd
&
&
intEnd
<
=
size
)
;
let
result
=
string
.
substring
(
intStart
intEnd
)
;
assert
.
sameValue
(
result
.
length
intEnd
-
intStart
)
;
for
(
let
i
=
0
;
i
<
result
.
length
;
+
+
i
)
{
assert
.
sameValue
(
result
[
i
]
string
[
intStart
+
i
]
)
;
}
return
result
;
}
const
positiveIntegers
=
[
0
1
2
3
4
5
10
100
]
;
const
integers
=
[
.
.
.
positiveIntegers
.
.
.
positiveIntegers
.
map
(
v
=
>
-
v
)
]
;
const
numbers
=
[
.
.
.
integers
.
.
.
integers
.
map
(
v
=
>
v
+
0
.
5
)
-
Infinity
Infinity
NaN
]
;
for
(
let
string
of
[
"
"
"
a
"
"
ab
"
"
abc
"
]
)
{
for
(
let
start
of
numbers
)
{
for
(
let
length
of
[
.
.
.
numbers
undefined
]
)
{
let
actual
=
string
.
substr
(
start
length
)
;
let
expected
=
StringSubstr
(
string
start
length
)
;
assert
.
sameValue
(
actual
expected
"
{
string
}
"
.
substr
(
{
start
}
{
length
}
)
)
;
}
}
}
reportCompare
(
0
0
)
;
