const
bindingPatterns
=
[
"
[
]
"
"
[
a
]
"
"
[
a
b
]
"
"
[
a
.
.
.
b
]
"
"
[
.
.
.
a
]
"
"
[
.
.
.
[
]
]
"
"
{
}
"
"
{
p
:
a
}
"
"
{
p
:
a
=
0
}
"
"
{
p
:
{
}
}
"
"
{
p
:
a
q
:
b
}
"
"
{
a
}
"
"
{
a
b
}
"
"
{
a
=
0
}
"
]
;
const
functions
=
[
p
=
>
function
f
(
{
p
}
)
{
}
p
=
>
function
*
g
(
{
p
}
)
{
}
p
=
>
(
{
m
(
{
p
}
)
{
}
}
)
;
p
=
>
(
class
{
m
(
{
p
}
)
{
}
}
)
;
p
=
>
(
{
p
}
)
=
>
{
}
;
]
;
for
(
let
pattern
of
bindingPatterns
)
{
for
(
let
fn
of
functions
)
{
eval
(
fn
(
.
.
.
{
pattern
}
)
)
;
eval
(
fn
(
x
.
.
.
{
pattern
}
)
)
;
eval
(
fn
(
x
y
.
.
.
{
pattern
}
)
)
;
eval
(
fn
(
x
=
0
.
.
.
{
pattern
}
)
)
;
eval
(
fn
(
x
=
0
y
=
0
.
.
.
{
pattern
}
)
)
;
eval
(
fn
(
[
]
.
.
.
{
pattern
}
)
)
;
eval
(
fn
(
[
x
]
.
.
.
{
pattern
}
)
)
;
eval
(
fn
(
[
x
=
0
]
.
.
.
{
pattern
}
)
)
;
eval
(
fn
(
[
.
.
.
x
]
.
.
.
{
pattern
}
)
)
;
eval
(
fn
(
{
}
.
.
.
{
pattern
}
)
)
;
eval
(
fn
(
{
p
:
x
}
.
.
.
{
pattern
}
)
)
;
eval
(
fn
(
{
x
}
.
.
.
{
pattern
}
)
)
;
eval
(
fn
(
{
x
=
0
}
.
.
.
{
pattern
}
)
)
;
assertThrowsInstanceOf
(
(
)
=
>
eval
(
fn
(
.
.
.
{
pattern
}
)
)
SyntaxError
)
;
assertThrowsInstanceOf
(
(
)
=
>
eval
(
fn
(
.
.
.
{
pattern
}
x
)
)
SyntaxError
)
;
assertThrowsInstanceOf
(
(
)
=
>
eval
(
fn
(
.
.
.
{
pattern
}
x
=
0
)
)
SyntaxError
)
;
assertThrowsInstanceOf
(
(
)
=
>
eval
(
fn
(
.
.
.
{
pattern
}
.
.
.
x
)
)
SyntaxError
)
;
assertThrowsInstanceOf
(
(
)
=
>
eval
(
fn
(
.
.
.
{
pattern
}
[
]
)
)
SyntaxError
)
;
assertThrowsInstanceOf
(
(
)
=
>
eval
(
fn
(
.
.
.
{
pattern
}
{
}
)
)
SyntaxError
)
;
assertThrowsInstanceOf
(
(
)
=
>
eval
(
fn
(
.
.
.
{
pattern
}
=
0
)
)
SyntaxError
)
;
}
}
for
(
let
fn
of
functions
)
{
assertThrowsInstanceOf
(
(
)
=
>
eval
(
fn
(
.
.
.
)
)
SyntaxError
)
;
assertThrowsInstanceOf
(
(
)
=
>
eval
(
fn
(
.
.
.
[
)
)
SyntaxError
)
;
assertThrowsInstanceOf
(
(
)
=
>
eval
(
fn
(
.
.
.
{
)
)
SyntaxError
)
;
assertThrowsInstanceOf
(
(
)
=
>
eval
(
fn
(
.
.
.
[
0
]
)
)
SyntaxError
)
;
assertThrowsInstanceOf
(
(
)
=
>
eval
(
fn
(
.
.
.
[
p
.
q
]
)
)
SyntaxError
)
;
}
assertThrowsInstanceOf
(
(
)
=
>
eval
(
(
{
get
p
(
.
.
.
[
]
)
{
}
}
)
)
SyntaxError
)
;
assertThrowsInstanceOf
(
(
)
=
>
eval
(
(
{
set
p
(
.
.
.
[
]
)
{
}
}
)
)
SyntaxError
)
;
if
(
typeof
reportCompare
=
=
=
"
function
"
)
reportCompare
(
0
0
)
;
