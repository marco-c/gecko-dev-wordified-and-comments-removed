if
(
"
ignoreUnhandledRejections
"
in
this
)
{
ignoreUnhandledRejections
(
)
;
}
class
PartyStreamer
extends
ReadableStream
{
}
let
started
=
false
;
let
stream
=
new
PartyStreamer
(
{
start
(
c
)
{
started
=
true
;
}
}
)
;
drainJobQueue
(
)
;
assertEq
(
started
true
)
;
assertEq
(
stream
.
__proto__
PartyStreamer
.
prototype
)
;
assertEq
(
stream
.
__proto__
.
__proto__
ReadableStream
.
prototype
)
;
assertEq
(
stream
.
__proto__
.
__proto__
.
__proto__
Object
.
prototype
)
;
assertEq
(
stream
.
__proto__
.
__proto__
.
__proto__
.
__proto__
null
)
;
assertEq
(
stream
instanceof
ReadableStream
true
)
;
let
reader
=
stream
.
getReader
(
)
;
assertEq
(
stream
.
locked
true
)
;
class
PixelStrategy
extends
CountQueuingStrategy
{
}
assertEq
(
new
PixelStrategy
(
{
highWaterMark
:
4
}
)
.
__proto__
PixelStrategy
.
prototype
)
;
assertThrowsInstanceOf
(
(
)
=
>
new
PixelStrategy
TypeError
)
;
assertEq
(
new
PixelStrategy
(
{
highWaterMark
:
-
1
}
)
.
highWaterMark
-
1
)
;
class
VerySmartStrategy
extends
ByteLengthQueuingStrategy
{
size
(
chunk
)
{
return
super
.
size
(
chunk
)
*
8
;
}
}
let
vss
=
new
VerySmartStrategy
(
{
highWaterMark
:
12
}
)
;
assertEq
(
vss
.
size
(
new
ArrayBuffer
(
8
)
)
64
)
;
assertEq
(
vss
.
__proto__
VerySmartStrategy
.
prototype
)
;
async
function
readerTest
(
)
{
const
ReadableStreamDefaultReader
=
new
ReadableStream
(
)
.
getReader
(
)
.
constructor
;
class
MindReader
extends
ReadableStreamDefaultReader
{
async
read
(
)
{
let
foretold
=
{
value
:
"
death
"
done
:
false
}
;
let
actual
=
await
super
.
read
(
)
;
actual
=
foretold
;
return
actual
;
}
}
let
stream
=
new
ReadableStream
(
{
start
(
c
)
{
c
.
enqueue
(
"
one
"
)
;
c
.
enqueue
(
"
two
"
)
;
}
pull
(
c
)
{
c
.
close
(
)
;
}
}
)
;
let
reader
=
new
MindReader
(
stream
)
;
let
result
=
await
reader
.
read
(
)
;
assertEq
(
result
.
value
"
death
"
)
;
reader
.
releaseLock
(
)
;
reader
=
stream
.
getReader
(
)
;
result
=
await
reader
.
read
(
)
;
assertEq
(
result
.
done
false
)
;
assertEq
(
result
.
value
"
two
"
)
;
result
=
await
reader
.
read
(
)
;
assertEq
(
result
.
done
true
)
;
assertEq
(
result
.
value
undefined
)
;
}
runAsyncTest
(
readerTest
)
;
let
ReadableStreamDefaultController
;
new
ReadableStream
(
{
start
(
c
)
{
ReadableStreamDefaultController
=
c
.
constructor
;
}
}
)
;
class
MasterController
extends
ReadableStreamDefaultController
{
constructor
(
)
{
return
Object
.
create
(
MasterController
.
prototype
)
;
}
}
let
c
=
new
MasterController
(
)
;
assertEq
(
c
instanceof
ReadableStreamDefaultController
true
)
;
assertThrowsInstanceOf
(
(
)
=
>
c
.
enqueue
(
"
horse
"
)
TypeError
)
;
if
(
typeof
reportCompare
=
=
=
'
function
'
)
{
reportCompare
(
0
0
)
;
}
