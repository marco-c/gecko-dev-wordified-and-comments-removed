let
method
=
Tuple
.
prototype
.
filter
;
let
pred
=
(
x
i
tup
)
=
>
x
%
2
=
=
=
0
;
assertEq
(
method
.
call
(
#
[
1
2
3
4
5
6
]
pred
)
#
[
2
4
6
]
)
;
assertEq
(
method
.
call
(
Object
(
#
[
1
2
3
4
5
6
]
)
pred
)
#
[
2
4
6
]
)
;
assertThrowsInstanceOf
(
(
)
=
>
method
.
call
(
"
monkeys
"
pred
)
TypeError
"
value
of
TupleObject
must
be
a
Tuple
"
)
;
let
tup
=
#
[
1
2
3
]
;
assertThrowsInstanceOf
(
(
)
=
>
tup
.
filter
(
)
TypeError
"
missing
function
argument
to
Tuple
.
prototype
.
filter
"
)
;
assertThrowsInstanceOf
(
(
)
=
>
tup
.
filter
(
undefined
)
TypeError
"
missing
function
argument
to
Tuple
.
prototype
.
filter
"
)
;
assertThrowsInstanceOf
(
(
)
=
>
tup
.
filter
(
"
monkeys
"
)
TypeError
"
bad
function
argument
to
Tuple
.
prototype
.
filter
"
)
;
var
pred2
=
x
=
>
x
%
2
=
=
=
0
;
assertEq
(
tup
.
filter
(
pred2
)
#
[
2
]
)
;
pred2
=
(
x
i
)
=
>
x
+
i
<
5
;
assertEq
(
tup
.
filter
(
pred2
)
#
[
1
2
]
)
;
var
pred3
=
(
a
b
c
d
e
)
=
>
e
=
=
=
undefined
;
assertEq
(
tup
.
filter
(
pred3
)
tup
)
;
var
pred1
=
(
x
i
tup
)
=
>
(
tup
.
indexOf
(
x
+
i
)
!
=
=
(
-
1
)
)
;
assertEq
(
#
[
1
2
3
4
5
6
7
]
.
filter
(
pred1
)
#
[
1
2
3
4
]
)
;
pred1
=
function
(
x
i
tup
)
{
return
(
this
.
elements
.
indexOf
(
x
)
!
=
=
-
1
)
;
}
;
assertEq
(
#
[
1
2
3
4
5
]
.
filter
(
pred1
{
elements
:
[
2
4
]
}
)
#
[
2
4
]
)
;
Object
.
defineProperty
(
Tuple
.
prototype
"
length
"
{
get
(
)
{
return
0
}
}
)
assertEq
(
tup
.
filter
(
pred
)
#
[
2
]
)
;
assertEq
(
#
[
]
.
filter
(
pred
)
#
[
]
)
;
assertEq
(
#
[
1
]
.
filter
(
pred
)
#
[
]
)
;
assertEq
(
#
[
2
]
.
filter
(
pred
)
#
[
2
]
)
;
assertEq
(
tup
.
filter
(
pred
)
#
[
2
]
)
;
assertEq
(
tup
.
filter
(
x
=
>
x
>
1
)
#
[
2
3
]
)
;
reportCompare
(
0
0
)
;
