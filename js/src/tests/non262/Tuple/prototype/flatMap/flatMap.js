let
method
=
Tuple
.
prototype
.
flatMap
;
let
id
=
x
=
>
x
;
assertEq
(
method
.
call
(
#
[
1
#
[
2
]
3
]
id
)
#
[
1
2
3
]
)
;
assertEq
(
method
.
call
(
Object
(
#
[
1
#
[
2
]
3
]
)
id
)
#
[
1
2
3
]
)
;
assertThrowsInstanceOf
(
(
)
=
>
method
.
call
(
"
monkeys
"
id
)
TypeError
"
value
of
TupleObject
must
be
a
Tuple
"
)
;
assertThrowsInstanceOf
(
(
)
=
>
method
.
call
(
null
id
)
TypeError
"
value
of
TupleObject
must
be
a
Tuple
"
)
;
assertThrowsInstanceOf
(
(
)
=
>
method
.
call
(
id
)
TypeError
"
value
of
TupleObject
must
be
a
Tuple
"
)
;
let
tup
=
#
[
1
2
#
[
3
#
[
4
5
]
6
]
#
[
5
6
]
7
]
;
let
tup2
=
#
[
1
#
[
2
]
3
]
;
assertThrowsInstanceOf
(
(
)
=
>
tup
.
flatMap
(
)
TypeError
"
missing
function
argument
to
Tuple
.
prototype
.
flatMap
"
)
;
assertThrowsInstanceOf
(
(
)
=
>
tup
.
flatMap
(
undefined
)
TypeError
"
missing
function
argument
to
Tuple
.
prototype
.
flatMap
"
)
;
assertThrowsInstanceOf
(
(
)
=
>
tup
.
flatMap
(
"
monkeys
"
)
TypeError
"
bad
function
argument
to
Tuple
.
prototype
.
flatMap
"
)
;
var
f2
=
function
(
x
)
{
if
(
typeof
(
x
)
=
=
=
"
number
"
)
{
return
(
x
*
x
)
;
}
else
{
return
0
;
}
}
;
assertEq
(
tup2
.
flatMap
(
f2
)
#
[
1
0
9
]
)
;
f2
=
function
(
x
i
)
{
if
(
typeof
(
x
)
=
=
=
"
number
"
)
{
return
(
x
+
i
)
;
}
else
{
return
(
i
)
;
}
}
;
assertEq
(
tup2
.
flatMap
(
f2
)
#
[
1
1
5
]
)
;
var
f3
=
(
a
b
c
d
e
)
=
>
e
=
=
=
undefined
;
assertEq
(
tup2
.
flatMap
(
f3
)
#
[
true
true
true
]
)
;
var
f4
=
function
(
x
i
tup
)
{
if
(
typeof
(
x
)
=
=
=
"
number
"
)
{
return
(
tup
.
indexOf
(
x
+
1
)
*
i
*
x
)
;
}
else
{
return
(
tup
.
indexOf
(
x
)
*
i
)
;
}
}
assertEq
(
tup2
.
flatMap
(
f4
)
#
[
-
0
1
-
6
]
)
;
f1
=
function
(
x
i
tup
)
{
if
(
typeof
(
x
)
=
=
"
number
"
)
{
return
(
this
.
elements
.
indexOf
(
x
)
*
x
)
;
}
else
{
return
(
this
.
elements
.
indexOf
(
x
)
)
;
}
}
assertEq
(
#
[
1
2
#
[
3
4
]
#
[
5
]
]
.
flatMap
(
f1
{
elements
:
[
2
4
]
}
)
#
[
-
1
0
-
1
-
1
]
)
;
var
badF
=
x
=
>
new
Object
(
x
)
;
assertThrowsInstanceOf
(
(
)
=
>
tup
.
flatMap
(
badF
)
TypeError
"
Tuple
cannot
contain
Object
"
)
;
var
f
=
x
=
>
#
[
x
x
]
;
assertEq
(
#
[
1
#
[
2
3
]
4
]
.
flatMap
(
f
)
#
[
1
1
#
[
2
3
]
#
[
2
3
]
4
4
]
)
;
reportCompare
(
0
0
)
;
