let
method
=
Tuple
.
prototype
.
slice
;
assertEq
(
method
.
call
(
#
[
1
2
3
4
5
6
]
2
4
)
#
[
3
4
]
)
;
assertEq
(
method
.
call
(
Object
(
#
[
1
2
3
4
5
6
]
)
2
4
)
#
[
3
4
]
)
;
assertThrowsInstanceOf
(
(
)
=
>
method
.
call
(
"
monkeys
"
)
TypeError
"
value
of
TupleObject
must
be
a
Tuple
"
)
;
assertThrowsInstanceOf
(
(
)
=
>
method
.
call
(
true
)
TypeError
"
value
of
TupleObject
must
be
a
Tuple
"
)
;
assertThrowsInstanceOf
(
(
)
=
>
method
.
call
(
false
)
TypeError
"
value
of
TupleObject
must
be
a
Tuple
"
)
;
let
tup
=
#
[
1
2
3
]
;
let
len
=
3
;
assertEq
(
tup
.
slice
(
"
monkeys
"
4
)
tup
.
slice
(
0
4
)
)
;
assertThrowsInstanceOf
(
(
)
=
>
tup
.
slice
(
Symbol
(
"
1
"
)
4
)
TypeError
"
can
'
t
convert
symbol
to
number
"
)
;
assertEq
(
tup
.
slice
(
undefined
4
)
tup
.
slice
(
0
4
)
)
;
assertEq
(
tup
.
slice
(
undefined
)
tup
.
slice
(
0
)
)
;
assertEq
(
tup
.
slice
(
NaN
)
tup
.
slice
(
0
)
)
;
assertEq
(
tup
.
slice
(
Number
.
POSITIVE_INFINITY
)
tup
.
slice
(
len
)
)
;
assertEq
(
tup
.
slice
(
Number
.
NEGATIVE_INFINITY
)
tup
.
slice
(
0
)
)
;
assertEq
(
tup
.
slice
(
{
valueOf
:
function
(
)
{
return
0
}
toString
:
function
(
)
{
return
3
}
}
)
tup
.
slice
(
0
3
)
)
;
assertEq
(
tup
.
slice
(
)
tup
.
slice
(
0
)
)
;
var
relativeStart
=
-
2
;
assertEq
(
tup
.
slice
(
relativeStart
4
)
tup
.
slice
(
len
+
relativeStart
4
)
)
;
relativeStart
=
(
-
1
*
len
)
;
assertEq
(
tup
.
slice
(
relativeStart
4
)
tup
.
slice
(
0
4
)
)
;
relativeStart
=
-
256
;
assertEq
(
tup
.
slice
(
relativeStart
4
)
tup
.
slice
(
0
4
)
)
;
var
tup2
=
#
[
1
2
3
4
5
6
7
]
;
relativeStart
=
2
;
assertEq
(
tup2
.
slice
(
relativeStart
4
)
#
[
3
4
]
)
;
assertEq
(
tup2
.
slice
(
tup2
.
length
tup2
.
length
)
#
[
]
)
;
assertEq
(
tup2
.
slice
(
tup2
.
length
+
5
tup2
.
length
)
tup2
.
slice
(
tup2
.
length
tup2
.
length
)
)
;
relativeStart
=
0
;
assertEq
(
tup2
.
slice
(
relativeStart
4
)
#
[
1
2
3
4
]
)
;
relativeStart
=
2
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeStart
)
#
[
]
)
;
relativeStart
=
4
;
relativeEnd
=
2
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
]
)
;
relativeEnd
=
tup2
.
length
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
5
6
7
]
)
;
relativeEnd
=
tup2
.
length
+
3
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
5
6
7
]
)
;
relativeStart
=
-
4
;
relativeEnd
=
4
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
4
]
)
;
relativeEnd
=
tup2
.
length
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
4
5
6
7
]
)
;
relativeStart
=
-
1
*
tup2
.
length
;
relativeEnd
=
5
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
1
2
3
4
5
]
)
;
relativeStart
=
(
-
1
*
tup2
.
length
)
-
4
;
relativeEnd
=
tup2
.
length
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
tup2
)
;
assertEq
(
tup
.
slice
(
2
undefined
)
tup
.
slice
(
2
len
)
)
;
assertEq
(
tup
.
slice
(
2
)
tup
.
slice
(
2
len
)
)
;
assertEq
(
tup
.
slice
(
2
"
monkeys
"
)
tup
.
slice
(
2
0
)
)
;
assertThrowsInstanceOf
(
(
)
=
>
tup
.
slice
(
2
Symbol
(
"
x
"
)
)
TypeError
"
can
'
t
convert
Symbol
to
Number
"
)
;
assertEq
(
tup
.
slice
(
2
2
.
5
)
tup
.
slice
(
2
0
)
)
;
assertEq
(
tup
.
slice
(
2
NaN
)
tup
.
slice
(
2
0
)
)
;
assertEq
(
tup
.
slice
(
2
Number
.
POSITIVE_INFINITY
)
tup
.
slice
(
2
len
)
)
;
assertEq
(
tup
.
slice
(
2
Number
.
NEGATIVE_INFINITY
)
tup
.
slice
(
2
0
)
)
;
assertEq
(
tup
.
slice
(
0
Number
.
POSITIVE_INFINITY
)
tup
.
slice
(
0
len
)
)
;
assertEq
(
tup
.
slice
(
0
Number
.
NEGATIVE_INFINITY
)
tup
.
slice
(
0
0
)
)
;
assertEq
(
tup
.
slice
(
{
valueOf
:
function
(
)
{
return
3
}
toString
:
function
(
)
{
return
0
}
}
)
tup
.
slice
(
0
0
)
)
;
var
relativeEnd
=
-
1
;
relativeStart
=
2
;
assertEq
(
tup
.
slice
(
relativeStart
relativeEnd
)
tup
.
slice
(
relativeStart
len
+
relativeEnd
)
)
;
relativeEnd
=
(
-
1
*
len
)
;
assertEq
(
tup
.
slice
(
relativeStart
relativeEnd
)
tup
.
slice
(
relativeStart
0
)
)
;
relativeEnd
=
-
256
;
assertEq
(
tup
.
slice
(
relativeStart
relativeEnd
)
tup
.
slice
(
relativeStart
0
)
)
;
relativeStart
=
-
3
;
relativeEnd
=
-
1
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
5
6
]
)
;
relativeEnd
=
(
-
1
*
len
)
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
]
)
;
relativeEnd
=
-
256
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
]
)
;
relativeStart
=
0
;
relativeEnd
=
-
3
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
1
2
3
4
]
)
;
relativeStart
=
2
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
3
4
]
)
;
relativeEnd
=
-
1
*
tup2
.
length
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
]
)
;
relativeEnd
=
(
-
1
*
tup2
.
length
)
-
5
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
]
)
;
relativeStart
=
-
1
*
tup2
.
length
;
relativeEnd
=
5
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
1
2
3
4
5
]
)
;
relativeStart
=
-
3
;
relativeEnd
=
-
1
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
5
6
]
)
;
relativeStart
=
(
-
1
*
tup2
.
length
)
-
5
;
relativeEnd
=
-
3
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
1
2
3
4
]
)
;
relativeEnd
=
relativeStart
;
assertEq
(
tup2
.
slice
(
relativeStart
relativeEnd
)
#
[
]
)
;
reportCompare
(
0
0
)
;
