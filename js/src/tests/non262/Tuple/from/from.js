assertEq
(
Tuple
.
from
(
[
1
2
]
undefined
)
#
[
1
2
]
)
;
assertThrowsInstanceOf
(
(
)
=
>
Tuple
.
from
(
[
1
2
3
]
"
monkeys
"
)
TypeError
"
mapfn
not
callable
"
)
;
assertThrowsInstanceOf
(
(
)
=
>
Tuple
.
from
(
undefined
)
TypeError
"
can
'
t
access
property
Symbol
.
iterator
of
undefined
"
)
;
assertThrowsInstanceOf
(
(
)
=
>
Tuple
.
from
(
null
)
TypeError
"
can
'
t
access
property
Symbol
.
iterator
of
null
"
)
;
assertEq
(
Tuple
.
from
(
1
)
#
[
]
)
;
var
obj
=
{
}
;
obj
[
Symbol
.
iterator
]
=
null
;
assertEq
(
Tuple
.
from
(
obj
)
#
[
]
)
;
obj
[
Symbol
.
iterator
]
=
5
;
assertThrowsInstanceOf
(
(
)
=
>
Tuple
.
from
(
obj
)
TypeError
"
number
is
not
a
function
"
)
;
assertEq
(
Tuple
.
from
(
[
1
2
3
]
x
=
>
x
+
1
)
#
[
2
3
4
]
)
;
assertEq
(
Tuple
.
from
(
#
[
1
2
3
]
x
=
>
x
+
1
)
#
[
2
3
4
]
)
;
assertEq
(
Tuple
.
from
(
"
xyz
"
c
=
>
String
.
fromCharCode
(
c
.
charCodeAt
(
0
)
+
1
)
)
#
[
'
y
'
'
z
'
'
{
'
]
)
;
assertEq
(
Tuple
.
from
(
[
1
2
3
4
5
]
)
#
[
1
2
3
4
5
]
)
;
assertEq
(
Tuple
.
from
(
#
[
1
2
3
4
5
]
)
#
[
1
2
3
4
5
]
)
;
assertEq
(
Tuple
.
from
(
"
xyz
"
)
#
[
'
x
'
'
y
'
'
z
'
]
)
;
assertThrowsInstanceOf
(
(
)
=
>
Tuple
.
from
(
[
1
2
]
x
=
>
[
x
]
)
TypeError
"
Tuple
cannot
contain
object
"
)
;
var
obj
=
{
length
:
3
0
:
"
a
"
1
:
"
b
"
2
:
"
c
"
}
;
assertEq
(
Tuple
.
from
(
obj
)
#
[
"
a
"
"
b
"
"
c
"
]
)
;
assertEq
(
Tuple
.
from
(
obj
s
=
>
s
+
s
)
#
[
"
aa
"
"
bb
"
"
cc
"
]
)
;
obj
=
{
0
:
"
a
"
1
:
"
b
"
2
:
"
c
"
}
;
assertEq
(
Tuple
.
from
(
obj
)
#
[
]
)
;
obj
=
{
length
:
3
0
:
1
2
:
3
}
;
assertEq
(
Tuple
.
from
(
obj
)
#
[
1
undefined
3
]
)
;
obj
=
{
length
:
3
0
:
1
1
:
[
2
]
2
:
3
}
;
assertThrowsInstanceOf
(
(
)
=
>
Tuple
.
from
(
obj
)
TypeError
"
Tuple
cannot
contain
object
"
)
;
assertThrowsInstanceOf
(
(
)
=
>
Tuple
.
from
(
[
1
2
[
3
4
]
]
)
TypeError
"
Tuple
can
'
t
contain
Object
"
)
;
reportCompare
(
0
0
)
;
