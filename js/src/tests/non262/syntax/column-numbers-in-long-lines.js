var
BUGNUMBER
=
1551916
;
var
summary
=
"
Optimize
computing
a
column
number
as
count
of
code
points
by
caching
"
+
"
column
numbers
(
and
whether
each
chunk
might
contain
anything
multi
-
unit
)
"
+
"
and
counting
forward
from
them
"
;
print
(
BUGNUMBER
+
"
:
"
+
summary
)
;
function
checkLoc
(
node
expectedStart
expectedEnd
)
{
let
start
=
node
.
loc
.
start
;
assertEq
(
start
.
line
expectedStart
[
0
]
"
start
line
number
must
be
as
expected
"
)
;
assertEq
(
start
.
column
expectedStart
[
1
]
"
start
column
number
must
be
as
expected
"
)
;
let
end
=
node
.
loc
.
end
;
assertEq
(
end
.
line
expectedEnd
[
0
]
"
end
line
number
must
be
as
expected
"
)
;
assertEq
(
end
.
column
expectedEnd
[
1
]
"
end
column
number
must
be
as
expected
"
)
;
}
function
lengthInCodePoints
(
str
)
{
return
[
.
.
.
str
]
.
length
;
}
const
columnsAreCodePoints
=
(
function
(
)
{
var
columnTypes
=
[
]
;
function
checkColumn
(
actual
expectedPoints
expectedUnits
)
{
if
(
actual
=
=
=
expectedPoints
)
columnTypes
.
push
(
"
p
"
)
;
else
if
(
actual
=
=
=
expectedUnits
)
columnTypes
.
push
(
"
u
"
)
;
else
columnTypes
.
push
(
"
x
"
)
;
}
var
script
=
Reflect
.
parse
(
'
"
"
;
'
{
loc
:
true
}
)
;
assertEq
(
script
.
type
"
Program
"
)
;
assertEq
(
script
.
loc
.
start
.
line
1
)
;
assertEq
(
script
.
loc
.
end
.
line
1
)
;
assertEq
(
script
.
loc
.
start
.
column
0
)
;
checkColumn
(
script
.
loc
.
end
.
column
7
11
)
;
var
body
=
script
.
body
;
assertEq
(
body
.
length
1
)
;
var
stmt
=
body
[
0
]
;
assertEq
(
stmt
.
type
"
ExpressionStatement
"
)
;
assertEq
(
stmt
.
loc
.
start
.
line
1
)
;
assertEq
(
stmt
.
loc
.
end
.
line
1
)
;
assertEq
(
stmt
.
loc
.
start
.
column
0
)
;
checkColumn
(
stmt
.
loc
.
end
.
column
7
11
)
;
var
expr
=
stmt
.
expression
;
assertEq
(
expr
.
type
"
Literal
"
)
;
assertEq
(
expr
.
value
"
"
)
;
assertEq
(
expr
.
loc
.
start
.
line
1
)
;
assertEq
(
expr
.
loc
.
end
.
line
1
)
;
assertEq
(
expr
.
loc
.
start
.
column
0
)
;
checkColumn
(
expr
.
loc
.
end
.
column
6
10
)
;
var
checkResult
=
columnTypes
.
join
(
"
"
)
;
assertEq
(
checkResult
=
=
=
"
p
p
p
"
|
|
checkResult
=
=
=
"
u
u
u
"
true
"
columns
must
be
wholly
code
points
or
units
:
"
+
checkResult
)
;
return
checkResult
=
=
=
"
p
p
p
"
;
}
)
(
)
;
function
testSimple
(
)
{
if
(
!
columnsAreCodePoints
)
return
;
let
simpleCodeArray
=
[
'
var
Q
=
[
[
'
'
"
(
x
"
]
[
"
'
'
)
x
"
]
[
"
'
'
*
x
"
]
[
"
'
'
+
x
"
]
[
"
'
'
x
"
]
[
"
-
x
'
'
"
]
[
"
.
x
"
'
'
]
[
"
/
x
"
]
'
'
[
"
0x
"
]
'
'
[
"
1x
"
]
[
'
'
"
2x
"
]
[
"
'
'
3x
"
]
[
"
'
'
4x
"
]
[
"
'
'
5x
"
]
[
"
6
'
'
x
"
]
[
"
7x
'
'
"
]
[
"
8x
"
'
'
]
[
"
9x
"
]
'
'
[
"
:
x
"
]
'
'
[
"
;
x
"
]
[
'
'
"
<
x
"
]
[
"
'
'
=
x
"
]
[
"
'
'
>
x
"
]
[
"
'
'
?
x
"
]
[
"
'
'
x
"
]
[
"
Ax
'
'
"
]
[
"
Bx
"
'
'
]
[
"
Cx
"
]
'
'
[
"
Dx
"
]
'
'
[
"
Ex
"
]
[
'
'
"
Fx
"
]
[
"
'
'
Gx
"
]
[
"
'
'
Hx
"
]
[
"
'
'
Ix
"
]
[
"
J
'
'
x
"
]
[
"
Kx
'
'
"
]
[
"
Lx
"
'
'
]
[
"
Mx
"
]
'
'
[
"
Nx
"
]
'
'
[
"
Ox
"
]
]
;
'
]
;
let
simpleCode
=
simpleCodeArray
.
join
(
"
"
)
;
const
CodePointLength
=
370
;
assertEq
(
lengthInCodePoints
(
simpleCode
)
CodePointLength
"
code
point
count
should
be
correct
"
)
;
const
RepetitionNumber
=
4
;
const
ElementsPerCycle
=
9
;
const
MinFaceScreamingPerElementInCycle
=
2
;
const
ElementsInCycleWithThreeFaceScreaming
=
2
;
const
OverallCodeUnitCount
=
CodePointLength
+
RepetitionNumber
*
(
ElementsPerCycle
*
MinFaceScreamingPerElementInCycle
+
ElementsInCycleWithThreeFaceScreaming
)
;
assertEq
(
OverallCodeUnitCount
>
CodePointLength
true
"
string
contains
code
points
outside
BMP
so
length
in
units
"
+
"
exceeds
length
in
points
"
)
;
assertEq
(
OverallCodeUnitCount
450
"
code
unit
count
computation
produces
this
value
"
)
;
assertEq
(
simpleCode
.
length
OverallCodeUnitCount
"
string
length
must
match
"
)
;
var
Q
;
eval
(
simpleCode
)
;
assertEq
(
Array
.
isArray
(
Q
)
true
)
;
const
NumArrayElements
=
40
;
assertEq
(
Q
.
length
NumArrayElements
)
;
Q
.
forEach
(
(
v
i
)
=
>
{
assertEq
(
Array
.
isArray
(
v
)
true
)
;
assertEq
(
v
.
length
1
)
;
assertEq
(
v
[
0
]
"
"
+
String
.
fromCharCode
(
'
(
'
.
charCodeAt
(
0
)
+
i
)
+
"
x
"
)
;
}
)
;
let
parseTree
=
Reflect
.
parse
(
simpleCode
{
loc
:
true
}
)
;
assertEq
(
parseTree
.
type
"
Program
"
)
;
checkLoc
(
parseTree
[
1
0
]
[
1
370
]
)
;
assertEq
(
parseTree
.
body
.
length
1
)
;
let
varDecl
=
parseTree
.
body
[
0
]
;
assertEq
(
varDecl
.
type
"
VariableDeclaration
"
)
;
checkLoc
(
varDecl
[
1
0
]
[
1
369
]
)
;
let
varInit
=
varDecl
.
declarations
[
0
]
.
init
;
assertEq
(
varInit
.
type
"
ArrayExpression
"
)
;
checkLoc
(
varInit
[
1
8
]
[
1
369
]
)
;
assertEq
(
varInit
.
elements
.
length
NumArrayElements
"
array
literal
length
"
)
;
const
ItemLength
=
lengthInCodePoints
(
'
[
"
#
x
"
]
'
)
;
assertEq
(
ItemLength
9
"
item
length
check
"
)
;
for
(
let
i
=
0
;
i
<
NumArrayElements
;
i
+
+
)
{
let
elem
=
varInit
.
elements
[
i
]
;
assertEq
(
elem
.
type
"
ArrayExpression
"
)
;
let
startCol
=
9
+
i
*
ItemLength
;
let
endCol
=
startCol
+
ItemLength
-
1
;
checkLoc
(
elem
[
1
startCol
]
[
1
endCol
]
)
;
let
arrayElems
=
elem
.
elements
;
assertEq
(
arrayElems
.
length
1
)
;
let
str
=
arrayElems
[
0
]
;
assertEq
(
str
.
type
"
Literal
"
)
;
assertEq
(
str
.
value
"
"
+
String
.
fromCharCode
(
'
(
'
.
charCodeAt
(
0
)
+
i
)
+
"
x
"
)
;
checkLoc
(
str
[
1
startCol
+
1
]
[
1
endCol
-
1
]
)
;
}
}
testSimple
(
)
;
function
testGuaranteedSingleUnit
(
)
{
if
(
!
columnsAreCodePoints
)
return
;
let
mixedChunksCode
=
"
var
Z
=
[
[
[
]
"
;
assertEq
(
mixedChunksCode
.
length
15
)
;
assertEq
(
lengthInCodePoints
(
mixedChunksCode
)
15
)
;
mixedChunksCode
+
=
"
"
.
repeat
(
128
-
mixedChunksCode
.
length
)
;
assertEq
(
mixedChunksCode
.
length
128
)
;
assertEq
(
lengthInCodePoints
(
mixedChunksCode
)
128
)
;
mixedChunksCode
+
=
"
[
"
+
"
[
]
"
.
repeat
(
42
)
+
"
"
;
assertEq
(
mixedChunksCode
.
length
256
)
;
assertEq
(
lengthInCodePoints
(
mixedChunksCode
)
256
)
;
mixedChunksCode
+
=
"
[
]
]
'
"
+
"
"
.
repeat
(
61
)
;
assertEq
(
mixedChunksCode
.
length
384
+
1
)
;
assertEq
(
lengthInCodePoints
(
mixedChunksCode
)
324
)
;
mixedChunksCode
+
=
"
'
]
'
\
u2028
'
]
;
"
;
assertEq
(
mixedChunksCode
.
length
396
)
;
assertEq
(
lengthInCodePoints
(
mixedChunksCode
)
335
)
;
let
parseTree
=
Reflect
.
parse
(
mixedChunksCode
{
loc
:
true
}
)
;
assertEq
(
parseTree
.
type
"
Program
"
)
;
checkLoc
(
parseTree
[
1
0
]
[
2
4
]
)
;
assertEq
(
parseTree
.
body
.
length
1
)
;
let
varDecl
=
parseTree
.
body
[
0
]
;
assertEq
(
varDecl
.
type
"
VariableDeclaration
"
)
;
checkLoc
(
varDecl
[
1
0
]
[
2
3
]
)
;
let
varInit
=
varDecl
.
declarations
[
0
]
.
init
;
assertEq
(
varInit
.
type
"
ArrayExpression
"
)
;
checkLoc
(
varInit
[
1
8
]
[
2
3
]
)
;
let
outerArrayElements
=
varInit
.
elements
;
assertEq
(
outerArrayElements
.
length
2
)
;
{
let
nestedArray
=
varInit
.
elements
[
0
]
;
assertEq
(
nestedArray
.
type
"
ArrayExpression
"
)
;
checkLoc
(
nestedArray
[
1
10
]
[
1
327
]
)
;
let
nestedArrayElements
=
nestedArray
.
elements
;
assertEq
(
nestedArrayElements
.
length
3
)
;
let
emptyArray
=
nestedArrayElements
[
0
]
;
assertEq
(
emptyArray
.
type
"
ArrayExpression
"
)
;
assertEq
(
emptyArray
.
elements
.
length
0
)
;
checkLoc
(
emptyArray
[
1
12
]
[
1
14
]
)
;
let
bigArrayOfEmpties
=
nestedArrayElements
[
1
]
;
assertEq
(
bigArrayOfEmpties
.
type
"
ArrayExpression
"
)
;
assertEq
(
bigArrayOfEmpties
.
elements
.
length
42
+
1
)
;
bigArrayOfEmpties
.
elements
.
forEach
(
(
elem
i
)
=
>
{
assertEq
(
elem
.
type
"
ArrayExpression
"
)
;
assertEq
(
elem
.
elements
.
length
0
)
;
if
(
i
!
=
=
42
)
checkLoc
(
elem
[
1
129
+
i
*
3
]
[
1
131
+
i
*
3
]
)
;
else
checkLoc
(
elem
[
1
256
]
[
1
258
]
)
;
}
)
;
let
multiUnitStringLiteral
=
nestedArrayElements
[
2
]
;
assertEq
(
multiUnitStringLiteral
.
type
"
Literal
"
)
;
assertEq
(
multiUnitStringLiteral
.
value
"
"
.
repeat
(
61
)
)
;
checkLoc
(
multiUnitStringLiteral
[
1
262
]
[
1
325
]
)
;
}
{
let
stringLiteralWithEmbeddedTerminator
=
outerArrayElements
[
1
]
;
assertEq
(
stringLiteralWithEmbeddedTerminator
.
type
"
Literal
"
)
;
assertEq
(
stringLiteralWithEmbeddedTerminator
.
value
"
\
u2028
"
)
;
checkLoc
(
stringLiteralWithEmbeddedTerminator
[
1
329
]
[
2
1
]
)
;
}
}
testGuaranteedSingleUnit
(
)
;
if
(
typeof
reportCompare
=
=
=
"
function
"
)
reportCompare
(
true
true
)
;
print
(
"
Testing
completed
"
)
;
