const
floatConstructors
=
anyTypedArrayConstructors
.
filter
(
isFloatConstructor
)
;
if
(
typeof
newGlobal
=
=
=
"
function
"
)
{
const
otherGlobal
=
newGlobal
(
)
;
floatConstructors
.
push
(
otherGlobal
.
Float16Array
)
;
floatConstructors
.
push
(
otherGlobal
.
Float32Array
)
;
floatConstructors
.
push
(
otherGlobal
.
Float64Array
)
;
}
function
*
prod
(
xs
ys
)
{
for
(
let
x
of
xs
)
{
for
(
let
y
of
ys
)
{
yield
[
x
y
]
;
}
}
}
const
isLittleEndian
=
new
Uint8Array
(
new
Uint16Array
(
[
1
]
)
.
buffer
)
[
0
]
!
=
=
0
;
function
seti16
(
i16
i
v
)
{
i16
[
i
]
=
v
;
}
function
seti32
(
i16
i
[
hi
lo
]
)
{
i16
[
i
*
2
+
isLittleEndian
]
=
hi
;
i16
[
i
*
2
+
!
isLittleEndian
]
=
lo
;
}
function
seti64
(
i16
i
[
hi
hiMid
loMid
lo
]
)
{
if
(
isLittleEndian
)
{
i16
[
i
*
4
]
=
lo
;
i16
[
i
*
4
+
1
]
=
loMid
;
i16
[
i
*
4
+
2
]
=
hiMid
;
i16
[
i
*
4
+
3
]
=
hi
;
}
else
{
i16
[
i
*
4
+
3
]
=
lo
;
i16
[
i
*
4
+
2
]
=
loMid
;
i16
[
i
*
4
+
1
]
=
hiMid
;
i16
[
i
*
4
]
=
hi
;
}
}
const
setInt
=
{
Float16
:
seti16
Float32
:
seti32
Float64
:
seti64
}
;
const
NaNs
=
{
Float16
:
[
0x7C01
|
0
0x7DFF
|
0
0x7E01
|
0
0x7FFF
|
0
0xFC01
|
0
0xFDFF
|
0
0xFE01
|
0
0xFFFF
|
0
]
Float32
:
[
[
0x7F80
|
0
0x0001
|
0
]
[
0x7FBF
|
0
0xFFFF
|
0
]
[
0x7FC0
|
0
0x0000
|
0
]
[
0x7FFF
|
0
0xFFFF
|
0
]
[
0xFF80
|
0
0x0001
|
0
]
[
0xFFBF
|
0
0xFFFF
|
0
]
[
0xFFC0
|
0
0x0000
|
0
]
[
0xFFFF
|
0
0xFFFF
|
0
]
]
Float64
:
[
[
0x7FF0
|
0
0x0000
|
0
0x0000
|
0
0x0001
|
0
]
[
0x7FF7
|
0
0xFFFF
|
0
0xFFFF
|
0
0xFFFF
|
0
]
[
0x7FF8
|
0
0x0000
|
0
0x0000
|
0
0x0000
|
0
]
[
0x7FFF
|
0
0xFFFF
|
0
0xFFFF
|
0
0xFFFF
|
0
]
[
0xFFF0
|
0
0x0000
|
0
0x0000
|
0
0x0001
|
0
]
[
0xFFF7
|
0
0xFFFF
|
0
0xFFFF
|
0
0xFFFF
|
0
]
[
0xFFF8
|
0
0x0000
|
0
0x0000
|
0
0x0000
|
0
]
[
0xFFFF
|
0
0xFFFF
|
0
0xFFFF
|
0
0xFFFF
|
0
]
]
}
;
const
TypedArraySort
=
Int32Array
.
prototype
.
sort
;
const
typedArrayLengths
=
[
16
4096
]
;
for
(
const
[
TA
taLength
]
of
prod
(
floatConstructors
typedArrayLengths
)
)
{
let
type
=
TA
.
name
.
slice
(
0
-
"
Array
"
.
length
)
;
let
nansLength
=
NaNs
[
type
]
.
length
;
let
fta
=
new
TA
(
taLength
)
;
let
i16
=
new
Int16Array
(
fta
.
buffer
)
;
for
(
let
i
=
0
;
i
<
nansLength
;
+
+
i
)
{
setInt
[
type
]
(
i16
i
NaNs
[
type
]
[
i
]
)
;
}
fta
[
nansLength
]
=
123
;
fta
[
nansLength
+
1
]
=
-
456
;
TypedArraySort
.
call
(
fta
)
;
assertEq
(
fta
[
0
]
-
456
)
;
const
zeroOffset
=
1
;
const
zeroCount
=
taLength
-
nansLength
-
2
;
for
(
let
i
=
0
;
i
<
zeroCount
;
+
+
i
)
{
assertEq
(
fta
[
zeroOffset
+
i
]
0
At
offset
:
{
zeroOffset
+
i
}
)
;
}
assertEq
(
fta
[
zeroOffset
+
zeroCount
]
123
)
;
const
nanOffset
=
zeroCount
+
2
;
for
(
let
i
=
0
;
i
<
nansLength
;
+
+
i
)
{
assertEq
(
fta
[
nanOffset
+
i
]
NaN
At
offset
:
{
nanOffset
+
i
}
)
;
}
}
if
(
typeof
reportCompare
=
=
=
"
function
"
)
reportCompare
(
true
true
)
;
