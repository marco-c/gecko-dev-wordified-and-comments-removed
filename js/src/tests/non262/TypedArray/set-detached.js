function
*
createTypedArrays
(
lengths
=
[
0
1
4
4096
]
)
{
for
(
let
length
of
lengths
)
{
let
buffer
=
new
ArrayBuffer
(
length
*
Int32Array
.
BYTES_PER_ELEMENT
)
;
let
typedArray
=
new
Int32Array
(
buffer
)
;
yield
{
typedArray
buffer
}
;
}
}
if
(
typeof
detachArrayBuffer
=
=
=
"
function
"
)
{
class
ExpectedError
extends
Error
{
}
for
(
let
{
typedArray
buffer
}
of
createTypedArrays
(
)
)
{
detachArrayBuffer
(
buffer
)
;
assertThrowsInstanceOf
(
(
)
=
>
typedArray
.
set
(
null
{
valueOf
(
)
{
throw
new
ExpectedError
(
)
;
}
}
)
ExpectedError
)
;
}
for
(
let
[
offset
error
]
of
[
[
0
TypeError
]
[
1000000
TypeError
]
[
-
1
RangeError
]
]
)
{
for
(
let
source
of
[
[
]
[
0
]
new
Int32Array
(
0
)
new
Int32Array
(
1
)
]
)
{
for
(
let
{
typedArray
buffer
}
of
createTypedArrays
(
)
)
{
assertThrowsInstanceOf
(
(
)
=
>
typedArray
.
set
(
source
{
valueOf
(
)
{
detachArrayBuffer
(
buffer
)
;
return
offset
;
}
}
)
error
)
;
}
}
}
for
(
let
{
typedArray
}
of
createTypedArrays
(
)
)
{
for
(
let
{
typedArray
:
source
buffer
:
sourceBuffer
}
of
createTypedArrays
(
)
)
{
detachArrayBuffer
(
sourceBuffer
)
;
assertThrowsInstanceOf
(
(
)
=
>
typedArray
.
set
(
source
{
valueOf
(
)
{
throw
new
ExpectedError
(
)
;
}
}
)
ExpectedError
)
;
}
}
for
(
let
[
offset
error
]
of
[
[
0
TypeError
]
[
1000000
TypeError
]
[
-
1
RangeError
]
]
)
{
for
(
let
{
typedArray
}
of
createTypedArrays
(
)
)
{
for
(
let
{
typedArray
:
source
buffer
:
sourceBuffer
}
of
createTypedArrays
(
)
)
{
assertThrowsInstanceOf
(
(
)
=
>
typedArray
.
set
(
source
{
valueOf
(
)
{
detachArrayBuffer
(
sourceBuffer
)
;
return
offset
;
}
}
)
error
)
;
}
}
}
for
(
let
src
of
[
ta
=
>
ta
ta
=
>
new
Int32Array
(
ta
.
buffer
)
ta
=
>
new
Float32Array
(
ta
.
buffer
)
]
)
{
for
(
let
{
typedArray
buffer
}
of
createTypedArrays
(
)
)
{
let
source
=
src
(
typedArray
)
;
assertThrowsInstanceOf
(
(
)
=
>
typedArray
.
set
(
source
{
valueOf
(
)
{
detachArrayBuffer
(
buffer
)
;
return
0
;
}
}
)
TypeError
)
;
}
}
for
(
let
offset
of
[
(
)
=
>
0
ta
=
>
Math
.
min
(
1
ta
.
length
)
ta
=
>
Math
.
max
(
0
ta
.
length
-
1
)
]
)
{
for
(
let
{
typedArray
buffer
}
of
createTypedArrays
(
)
)
{
let
source
=
{
get
length
(
)
{
detachArrayBuffer
(
buffer
)
;
return
0
;
}
}
;
typedArray
.
set
(
source
offset
(
typedArray
)
)
;
}
}
for
(
let
offset
of
[
(
)
=
>
0
ta
=
>
Math
.
min
(
1
ta
.
length
)
ta
=
>
Math
.
max
(
0
ta
.
length
-
1
)
]
)
{
for
(
let
{
typedArray
buffer
}
of
createTypedArrays
(
)
)
{
let
source
=
{
length
:
{
valueOf
(
)
{
detachArrayBuffer
(
buffer
)
;
return
0
;
}
}
}
;
typedArray
.
set
(
source
offset
(
typedArray
)
)
;
}
}
for
(
let
{
typedArray
buffer
}
of
createTypedArrays
(
)
)
{
let
source
=
{
length
:
{
valueOf
(
)
{
detachArrayBuffer
(
buffer
)
;
return
1
;
}
}
}
;
if
(
typedArray
.
length
=
=
=
0
)
{
assertThrowsInstanceOf
(
(
)
=
>
typedArray
.
set
(
source
)
RangeError
)
;
}
else
{
typedArray
.
set
(
source
)
;
}
}
for
(
let
{
typedArray
buffer
}
of
createTypedArrays
(
)
)
{
let
source
=
{
get
0
(
)
{
throw
new
ExpectedError
(
)
;
}
length
:
{
valueOf
(
)
{
detachArrayBuffer
(
buffer
)
;
return
1
;
}
}
}
;
let
err
=
typedArray
.
length
=
=
=
0
?
RangeError
:
ExpectedError
;
assertThrowsInstanceOf
(
(
)
=
>
typedArray
.
set
(
source
)
err
)
;
}
for
(
let
{
typedArray
buffer
}
of
createTypedArrays
(
)
)
{
let
source
=
{
get
0
(
)
{
return
{
valueOf
(
)
{
throw
new
ExpectedError
(
)
;
}
}
;
}
length
:
{
valueOf
(
)
{
detachArrayBuffer
(
buffer
)
;
return
1
;
}
}
}
;
let
err
=
typedArray
.
length
=
=
=
0
?
RangeError
:
ExpectedError
;
assertThrowsInstanceOf
(
(
)
=
>
typedArray
.
set
(
source
)
err
)
;
}
for
(
let
{
typedArray
buffer
}
of
createTypedArrays
(
)
)
{
let
source
=
Object
.
defineProperties
(
[
]
{
0
:
{
get
(
)
{
detachArrayBuffer
(
buffer
)
;
return
1
;
}
}
}
)
;
if
(
typedArray
.
length
=
=
=
0
)
{
assertThrowsInstanceOf
(
(
)
=
>
typedArray
.
set
(
source
)
RangeError
)
;
}
else
{
typedArray
.
set
(
source
)
;
}
}
for
(
let
{
typedArray
buffer
}
of
createTypedArrays
(
)
)
{
let
accessed
=
false
;
let
source
=
Object
.
defineProperties
(
[
]
{
0
:
{
get
(
)
{
detachArrayBuffer
(
buffer
)
;
return
1
;
}
}
1
:
{
get
(
)
{
assertEq
(
accessed
false
)
;
accessed
=
true
;
return
2
;
}
}
}
)
;
if
(
typedArray
.
length
<
=
1
)
{
assertThrowsInstanceOf
(
(
)
=
>
typedArray
.
set
(
source
)
RangeError
)
;
}
else
{
assertEq
(
accessed
false
)
;
typedArray
.
set
(
source
)
;
assertEq
(
accessed
true
)
;
}
}
for
(
let
{
typedArray
buffer
}
of
createTypedArrays
(
)
)
{
let
source
=
[
{
valueOf
(
)
{
detachArrayBuffer
(
buffer
)
;
return
1
;
}
}
]
;
if
(
typedArray
.
length
=
=
=
0
)
{
assertThrowsInstanceOf
(
(
)
=
>
typedArray
.
set
(
source
)
RangeError
)
;
}
else
{
typedArray
.
set
(
source
)
;
}
}
for
(
let
{
typedArray
buffer
}
of
createTypedArrays
(
)
)
{
let
accessed
=
false
;
let
source
=
[
{
valueOf
(
)
{
detachArrayBuffer
(
buffer
)
;
return
1
;
}
}
{
valueOf
(
)
{
assertEq
(
accessed
false
)
;
accessed
=
true
;
return
2
;
}
}
]
;
if
(
typedArray
.
length
<
=
1
)
{
assertThrowsInstanceOf
(
(
)
=
>
typedArray
.
set
(
source
)
RangeError
)
;
}
else
{
assertEq
(
accessed
false
)
;
typedArray
.
set
(
source
)
;
assertEq
(
accessed
true
)
;
}
}
}
if
(
typeof
reportCompare
=
=
=
"
function
"
)
reportCompare
(
true
true
)
;
