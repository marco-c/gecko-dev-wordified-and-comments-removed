for
(
let
minimumIntegerDigits
of
[
undefined
1
21
]
)
{
for
(
let
minimumFractionDigits
of
[
undefined
0
20
]
)
{
for
(
let
maximumFractionDigits
of
[
undefined
0
20
]
)
{
for
(
let
minimumSignificantDigits
of
[
undefined
0
21
]
)
{
for
(
let
maximumSignificantDigits
of
[
undefined
0
21
]
)
{
for
(
let
roundingPriority
of
[
undefined
"
morePrecision
"
]
)
{
for
(
let
roundingIncrement
of
[
undefined
5000
]
)
{
for
(
let
roundingMode
of
[
undefined
"
trunc
"
]
)
{
for
(
let
trailingZeroDisplay
of
[
undefined
"
stripIfInteger
"
]
)
{
let
options
=
{
minimumIntegerDigits
minimumFractionDigits
maximumFractionDigits
minimumSignificantDigits
maximumSignificantDigits
roundingPriority
roundingIncrement
roundingMode
trailingZeroDisplay
}
;
let
pl
;
try
{
pl
=
new
Intl
.
PluralRules
(
"
en
"
options
)
;
}
catch
(
e
)
{
continue
;
}
let
mnfdDefault
=
0
;
let
mxfdDefault
=
3
;
if
(
roundingIncrement
>
1
)
{
mxfdDefault
=
mnfdDefault
;
}
let
hasSd
=
minimumSignificantDigits
!
=
=
undefined
|
|
maximumSignificantDigits
!
=
=
undefined
;
let
needSd
=
true
;
let
needFd
=
true
;
if
(
(
roundingPriority
?
?
"
auto
"
)
=
=
=
"
auto
"
)
{
needSd
=
hasSd
;
if
(
needSd
)
{
needFd
=
false
;
}
}
let
mnsd
=
undefined
;
let
mxsd
=
undefined
;
if
(
needSd
)
{
mnsd
=
minimumSignificantDigits
?
?
1
;
mxsd
=
maximumSignificantDigits
?
?
21
;
}
let
mnfd
=
undefined
;
let
mxfd
=
undefined
;
if
(
needFd
)
{
mnfd
=
minimumFractionDigits
?
?
mnfdDefault
;
mxfd
=
maximumFractionDigits
?
?
Math
.
max
(
mxfdDefault
mnfd
)
;
}
if
(
!
needSd
&
&
!
needFd
)
{
mnfd
=
0
;
mxfd
=
0
;
mnsd
=
1
;
mxsd
=
2
;
}
let
resolved
=
pl
.
resolvedOptions
(
)
;
assertEq
(
resolved
.
minimumIntegerDigits
minimumIntegerDigits
?
?
1
)
;
assertEq
(
resolved
.
minimumFractionDigits
mnfd
)
;
assertEq
(
resolved
.
maximumFractionDigits
mxfd
)
;
assertEq
(
resolved
.
minimumSignificantDigits
mnsd
)
;
assertEq
(
resolved
.
maximumSignificantDigits
mxsd
)
;
assertEq
(
resolved
.
roundingPriority
roundingPriority
?
?
"
auto
"
)
;
assertEq
(
resolved
.
roundingIncrement
roundingIncrement
?
?
1
)
;
assertEq
(
resolved
.
roundingMode
roundingMode
?
?
"
halfExpand
"
)
;
assertEq
(
resolved
.
trailingZeroDisplay
trailingZeroDisplay
?
?
"
auto
"
)
;
}
}
}
}
}
}
}
}
}
if
(
typeof
reportCompare
=
=
=
"
function
"
)
reportCompare
(
0
0
'
ok
'
)
;
