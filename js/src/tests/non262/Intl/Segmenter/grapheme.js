const
locales
=
[
"
en
"
"
de
"
"
fr
"
"
ar
"
"
ja
"
"
zh
"
"
th
"
]
;
let
strings
=
{
"
"
:
[
]
"
test
"
:
"
test
"
.
split
(
"
"
)
"
hello
world
"
:
"
hello
world
"
.
split
(
"
"
)
"
hello
\
0world
"
:
"
hello
\
0world
"
.
split
(
"
"
)
"
\
r
\
n
"
:
[
"
\
r
\
n
"
]
"
\
xff
"
:
"
\
xff
"
.
split
(
"
"
)
"
"
:
"
"
.
split
(
"
"
)
"
e
\
u0300
"
:
[
"
e
\
u0300
"
]
"
\
u1100
\
u1161
\
u11A8
"
:
[
"
\
u1100
\
u1161
\
u11A8
"
]
"
\
u0E01
\
u0E33
"
:
[
"
\
u0E01
\
u0E33
"
]
"
\
u0937
\
u093F
"
:
[
"
\
u0937
\
u093F
"
]
"
\
u263A
\
uFE0F
"
:
[
"
\
u263A
\
uFE0F
"
]
"
\
u
{
1F385
}
\
u
{
1F3FB
}
"
:
[
"
\
u
{
1F385
}
\
u
{
1F3FB
}
"
]
"
\
u
{
1F469
}
\
u
{
1F3FD
}
\
u
{
200D
}
\
u
{
1F52C
}
"
:
[
"
\
u
{
1F469
}
\
u
{
1F3FD
}
\
u
{
200D
}
\
u
{
1F52C
}
"
]
"
\
u
{
1F469
}
\
u
{
1F3FD
}
\
u
{
200D
}
\
u
{
1F52C
}
\
u
{
FE0F
}
"
:
[
"
\
u
{
1F469
}
\
u
{
1F3FD
}
\
u
{
200D
}
\
u
{
1F52C
}
\
u
{
FE0F
}
"
]
"
\
u
{
1F926
}
\
u
{
1F3FC
}
\
u
{
200D
}
\
u
{
2642
}
\
u
{
FE0F
}
"
:
[
"
\
u
{
1F926
}
\
u
{
1F3FC
}
\
u
{
200D
}
\
u
{
2642
}
\
u
{
FE0F
}
"
]
"
\
u
{
1F1E9
}
\
u
{
1F1EA
}
"
:
[
"
\
u
{
1F1E9
}
\
u
{
1F1EA
}
"
]
"
\
u
{
1F3F4
}
\
u
{
E0067
}
\
u
{
E0062
}
\
u
{
E0073
}
\
u
{
E0063
}
\
u
{
E0074
}
\
u
{
E007F
}
"
:
[
"
\
u
{
1F3F4
}
\
u
{
E0067
}
\
u
{
E0062
}
\
u
{
E0073
}
\
u
{
E0063
}
\
u
{
E0074
}
\
u
{
E007F
}
"
]
}
;
function
assertIsSegmentDataObject
(
obj
)
{
assertEq
(
Object
.
getPrototypeOf
(
obj
)
Object
.
prototype
)
;
let
keys
=
Reflect
.
ownKeys
(
obj
)
;
assertEq
(
keys
.
length
3
)
;
assertEq
(
keys
[
0
]
"
segment
"
)
;
assertEq
(
keys
[
1
]
"
index
"
)
;
assertEq
(
keys
[
2
]
"
input
"
)
;
assertEq
(
typeof
obj
.
segment
"
string
"
)
;
assertEq
(
typeof
obj
.
index
"
number
"
)
;
assertEq
(
typeof
obj
.
input
"
string
"
)
;
assertEq
(
Number
.
isInteger
(
obj
.
index
)
true
)
;
assertEq
(
obj
.
index
>
=
0
true
)
;
assertEq
(
obj
.
index
<
obj
.
input
.
length
true
)
;
assertEq
(
obj
.
segment
.
length
>
0
true
)
;
assertEq
(
obj
.
input
.
substr
(
obj
.
index
obj
.
segment
.
length
)
obj
.
segment
)
;
}
function
segmentsFromContaining
(
segmenter
string
)
{
let
segments
=
segmenter
.
segment
(
string
)
;
let
result
=
[
]
;
for
(
let
index
=
0
data
;
(
data
=
segments
.
containing
(
index
)
)
;
index
+
=
data
.
segment
.
length
)
{
result
.
push
(
data
)
;
}
return
result
;
}
for
(
let
locale
of
locales
)
{
let
segmenter
=
new
Intl
.
Segmenter
(
locale
{
granularity
:
"
grapheme
"
}
)
;
let
resolved
=
segmenter
.
resolvedOptions
(
)
;
assertEq
(
resolved
.
locale
locale
)
;
assertEq
(
resolved
.
granularity
"
grapheme
"
)
;
for
(
let
[
string
graphemes
]
of
Object
.
entries
(
strings
)
)
{
let
segments
=
[
.
.
.
segmenter
.
segment
(
string
)
]
;
segments
.
forEach
(
assertIsSegmentDataObject
)
;
assertEq
(
segments
.
reduce
(
(
acc
{
segment
}
)
=
>
acc
+
segment
"
"
)
string
)
;
assertEq
(
segments
.
every
(
(
{
input
}
)
=
>
input
=
=
=
string
)
true
)
;
assertEq
(
isNaN
(
segments
.
reduce
(
(
acc
{
index
}
)
=
>
index
>
acc
?
index
:
NaN
-
Infinity
)
)
false
)
;
assertEqArray
(
segments
.
map
(
(
{
segment
}
)
=
>
segment
)
graphemes
)
;
assertDeepEq
(
segmentsFromContaining
(
segmenter
string
)
segments
)
;
}
}
if
(
typeof
reportCompare
=
=
=
"
function
"
)
reportCompare
(
0
0
)
;
