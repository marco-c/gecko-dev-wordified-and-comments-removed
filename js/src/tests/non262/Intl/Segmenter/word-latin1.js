const
strings
=
{
"
"
:
[
]
"
\
r
\
n
"
:
[
"
\
r
\
n
"
]
"
\
n
"
:
[
"
\
n
"
]
"
\
r
"
:
[
"
\
r
"
]
"
\
v
"
:
[
"
\
v
"
]
"
\
f
"
:
[
"
\
f
"
]
"
\
x85
"
:
[
"
\
x85
"
]
"
"
:
[
"
"
]
"
"
:
[
"
"
]
"
\
xAD
"
:
[
"
\
xAD
"
]
"
\
xAD
\
xAD
"
:
[
"
\
xAD
\
xAD
"
]
"
a
"
:
[
"
a
"
]
"
ab
"
:
[
"
ab
"
]
"
a
:
b
"
:
[
"
a
:
b
"
]
"
a
b
"
:
[
"
a
b
"
]
"
a
.
b
"
:
[
"
a
.
b
"
]
"
a
'
b
"
:
[
"
a
'
b
"
]
"
1
"
:
[
"
1
"
]
"
12
"
:
[
"
12
"
]
"
a1
"
:
[
"
a1
"
]
"
1a
"
:
[
"
1a
"
]
"
1
2
"
:
[
"
1
2
"
]
"
1
;
2
"
:
[
"
1
;
2
"
]
"
1
.
2
"
:
[
"
1
.
2
"
]
"
1
'
2
"
:
[
"
1
'
2
"
]
"
a_
"
:
[
"
a_
"
]
"
1_
"
:
[
"
1_
"
]
"
__
"
:
[
"
__
"
]
"
_a
"
:
[
"
_a
"
]
"
_1
"
:
[
"
_1
"
]
"
\
0
"
:
[
"
\
0
"
]
"
?
"
:
[
"
?
"
]
"
?
?
"
:
[
"
?
"
"
?
"
]
}
;
function
assertSegments
(
string
words
)
{
let
seg
=
segmenter
.
segment
(
string
)
;
let
segments
=
[
.
.
.
seg
]
;
assertEqArray
(
segments
.
map
(
(
{
segment
}
)
=
>
segment
)
words
)
;
for
(
let
expected
of
segments
)
{
let
{
segment
index
}
=
expected
;
for
(
let
i
=
index
;
i
<
index
+
segment
.
length
;
+
+
i
)
{
let
actual
=
seg
.
containing
(
i
)
;
assertDeepEq
(
actual
expected
)
;
}
}
}
let
segmenter
=
new
Intl
.
Segmenter
(
"
en
"
{
granularity
:
"
word
"
}
)
;
for
(
let
[
string
words
]
of
Object
.
entries
(
strings
)
)
{
assertSegments
(
string
words
)
;
}
for
(
let
string
of
[
"
\
r
\
n
"
"
\
n
"
"
\
r
"
"
\
v
"
"
\
f
"
"
\
x85
"
]
)
{
assertSegments
(
string
+
"
\
xAD
"
[
string
"
\
xAD
"
]
)
;
assertSegments
(
"
\
xAD
"
+
string
[
"
\
xAD
"
string
]
)
;
}
for
(
let
string
of
[
"
"
"
"
]
)
{
assertSegments
(
string
+
"
\
xAD
"
[
string
+
"
\
xAD
"
]
)
;
assertSegments
(
"
\
xAD
"
+
string
[
"
\
xAD
"
string
]
)
;
}
assertSegments
(
"
\
xAD
"
[
"
\
xAD
"
"
"
]
)
;
assertSegments
(
"
\
xAD
\
xAD
"
[
"
\
xAD
\
xAD
"
"
"
]
)
;
for
(
let
string
of
[
"
a
"
"
ab
"
"
a
:
b
"
"
a
b
"
"
a
.
b
"
"
a
'
b
"
"
1
"
"
12
"
"
a1
"
"
1a
"
"
1
2
"
"
1
;
2
"
"
1
.
2
"
"
1
'
2
"
"
a_
"
"
1_
"
"
__
"
"
_a
"
"
_1
"
"
?
"
]
)
{
assertSegments
(
string
+
"
\
xAD
"
[
string
+
"
\
xAD
"
]
)
;
assertSegments
(
"
\
xAD
"
+
string
[
"
\
xAD
"
string
]
)
;
if
(
string
=
=
=
"
a
.
b
"
)
{
assertSegments
(
string
.
split
(
"
"
)
.
join
(
"
\
xAD
"
)
[
"
a
\
xAD
"
"
.
\
xAD
"
"
b
"
]
)
;
assertSegments
(
string
.
split
(
"
"
)
.
join
(
"
\
xAD
\
xAD
"
)
[
"
a
\
xAD
\
xAD
"
"
.
\
xAD
\
xAD
"
"
b
"
]
)
;
}
else
{
assertSegments
(
string
.
split
(
"
"
)
.
join
(
"
\
xAD
"
)
[
string
.
split
(
"
"
)
.
join
(
"
\
xAD
"
)
]
)
;
assertSegments
(
string
.
split
(
"
"
)
.
join
(
"
\
xAD
\
xAD
"
)
[
string
.
split
(
"
"
)
.
join
(
"
\
xAD
\
xAD
"
)
]
)
;
}
}
assertSegments
(
"
?
\
xAD
?
"
[
"
?
\
xAD
"
"
?
"
]
)
;
for
(
let
string
of
[
"
a
:
b
"
"
a
b
"
"
a
.
b
"
"
a
'
b
"
"
1
2
"
"
1
;
2
"
"
1
.
2
"
"
1
'
2
"
]
)
{
let
prefix
=
string
.
slice
(
0
-
1
)
;
let
suffix
=
string
.
slice
(
1
)
;
assertSegments
(
prefix
prefix
.
split
(
"
"
)
)
;
assertSegments
(
suffix
suffix
.
split
(
"
"
)
)
;
}
assertSegments
(
"
a
b
"
[
"
a
"
"
"
"
b
"
]
)
;
assertSegments
(
"
a
;
b
"
[
"
a
"
"
;
"
"
b
"
]
)
;
assertSegments
(
"
1
:
2
"
[
"
1
"
"
:
"
"
2
"
]
)
;
assertSegments
(
"
1
2
"
[
"
1
"
"
"
"
2
"
]
)
;
assertSegments
(
"
a
.
2
"
[
"
a
"
"
.
"
"
2
"
]
)
;
assertSegments
(
"
1
.
b
"
[
"
1
"
"
.
"
"
b
"
]
)
;
assertSegments
(
"
a
'
2
"
[
"
a
"
"
'
"
"
2
"
]
)
;
assertSegments
(
"
1
'
b
"
[
"
1
"
"
'
"
"
b
"
]
)
;
assertSegments
(
"
_
_
"
[
"
_
"
"
"
"
_
"
]
)
;
assertSegments
(
"
_
;
_
"
[
"
_
"
"
;
"
"
_
"
]
)
;
assertSegments
(
"
_
:
_
"
[
"
_
"
"
:
"
"
_
"
]
)
;
assertSegments
(
"
_
_
"
[
"
_
"
"
"
"
_
"
]
)
;
assertSegments
(
"
_
.
_
"
[
"
_
"
"
.
"
"
_
"
]
)
;
assertSegments
(
"
_
'
_
"
[
"
_
"
"
'
"
"
_
"
]
)
;
assertEq
(
new
Intl
.
Segmenter
(
"
en
-
posix
"
)
.
resolvedOptions
(
)
.
locale
"
en
"
)
;
assertEq
(
new
Intl
.
Segmenter
(
"
en
-
u
-
va
-
posix
"
)
.
resolvedOptions
(
)
.
locale
"
en
"
)
;
if
(
typeof
reportCompare
=
=
=
"
function
"
)
reportCompare
(
0
0
)
;
