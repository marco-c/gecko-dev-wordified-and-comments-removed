function
IsLatin1String
(
str
)
{
for
(
var
i
=
0
;
i
<
str
.
length
;
+
+
i
)
{
if
(
str
.
charCodeAt
(
i
)
>
0xff
)
{
return
false
;
}
}
return
true
;
}
function
IsTwoByteString
(
str
)
{
return
!
IsLatin1String
(
str
)
;
}
const
latin1Strings
=
[
"
"
"
a
"
"
\
0
"
"
\
u
{
80
}
"
"
\
u
{
ff
}
"
"
ascii
"
"
l
t
-
"
"
This
is
an
ASCII
string
which
is
too
large
for
inline
storage
"
"
This
is
a
l
t
-
string
which
is
too
large
for
inline
storage
"
]
;
assertEq
(
latin1Strings
.
every
(
IsLatin1String
)
true
)
;
const
twoByteStrings
=
[
"
\
u
{
100
}
"
"
\
u
{
10ffff
}
"
.
.
.
latin1Strings
.
map
(
s
=
>
"
\
u
{
100
}
"
+
s
)
.
.
.
latin1Strings
.
map
(
s
=
>
s
+
"
\
u
{
100
}
"
)
.
.
.
latin1Strings
.
map
(
s
=
>
s
+
"
\
u
{
100
}
"
+
"
-
"
)
.
.
.
latin1Strings
.
map
(
s
=
>
"
-
"
+
"
\
u
{
100
}
"
+
s
)
]
;
assertEq
(
twoByteStrings
.
every
(
IsTwoByteString
)
true
)
;
const
unpairedSurrogates
=
[
"
\
u
{
D800
}
"
"
\
u
{
DBFF
}
"
"
\
u
{
DC00
}
"
"
\
u
{
DFFF
}
"
]
;
const
strings
=
[
.
.
.
latin1Strings
.
.
.
twoByteStrings
.
.
.
representativeStringArray
(
)
]
;
function
toRope
(
string
)
{
try
{
let
rope
=
newRope
(
string
[
0
]
string
.
slice
(
1
)
)
;
return
{
rope
filler
:
"
"
}
;
}
catch
{
}
let
filler
=
"
012345678901234567890123456789
"
;
let
rope
=
newRope
(
string
filler
)
;
return
{
rope
filler
}
;
}
for
(
let
string
of
strings
)
{
assertEq
(
string
.
isWellFormed
(
)
true
)
;
assertEq
(
string
.
toWellFormed
(
)
string
)
;
if
(
string
.
length
>
=
2
)
{
let
{
rope
filler
}
=
toRope
(
string
)
;
assertEq
(
rope
.
isWellFormed
(
)
true
)
;
assertEq
(
rope
.
toWellFormed
(
)
string
+
filler
)
;
}
let
copy
=
newString
(
string
)
;
assertEq
(
copy
.
isWellFormed
(
)
true
)
;
assertEq
(
copy
.
toWellFormed
(
)
string
)
;
let
twoByte
=
newString
(
string
{
twoByte
:
true
}
)
;
assertEq
(
twoByte
.
isWellFormed
(
)
true
)
;
assertEq
(
twoByte
.
toWellFormed
(
)
string
)
;
}
for
(
let
unpaired
of
unpairedSurrogates
)
{
assertEq
(
unpaired
.
isWellFormed
(
)
false
)
;
assertEq
(
unpaired
.
toWellFormed
(
)
"
\
u
{
FFFD
}
"
)
;
}
for
(
let
unpaired
of
unpairedSurrogates
.
flatMap
(
unpaired
=
>
{
return
[
unpaired
unpaired
+
unpaired
unpaired
+
"
-
"
+
unpaired
]
;
}
)
)
{
for
(
let
string
of
strings
.
flatMap
(
string
=
>
{
return
[
unpaired
+
string
string
+
unpaired
string
+
unpaired
+
"
-
"
"
-
"
+
unpaired
+
string
string
+
unpaired
+
string
]
;
}
)
)
{
assertEq
(
string
.
isWellFormed
(
)
false
)
;
assertEq
(
string
.
toWellFormed
(
)
=
=
=
string
false
)
;
if
(
string
.
length
>
=
2
)
{
let
{
rope
filler
}
=
toRope
(
string
)
;
assertEq
(
rope
.
isWellFormed
(
)
false
)
;
assertEq
(
rope
.
toWellFormed
(
)
=
=
=
string
+
filler
false
)
;
}
let
copy
=
newString
(
string
)
;
assertEq
(
copy
.
isWellFormed
(
)
false
)
;
assertEq
(
copy
.
toWellFormed
(
)
=
=
=
string
false
)
;
}
}
if
(
typeof
reportCompare
=
=
=
"
function
"
)
reportCompare
(
true
true
)
;
