assertEq
(
typeof
String
.
prototype
.
matchAll
"
function
"
)
;
assertEq
(
String
.
prototype
.
matchAll
.
name
"
matchAll
"
)
;
assertEq
(
String
.
prototype
.
matchAll
.
length
1
)
;
assertEq
(
typeof
Symbol
.
matchAll
"
symbol
"
)
;
assertEq
(
typeof
RegExp
.
prototype
[
Symbol
.
matchAll
]
"
function
"
)
;
assertEq
(
RegExp
.
prototype
[
Symbol
.
matchAll
]
.
name
"
[
Symbol
.
matchAll
]
"
)
;
assertEq
(
RegExp
.
prototype
[
Symbol
.
matchAll
]
.
length
1
)
;
const
IteratorPrototype
=
Object
.
getPrototypeOf
(
Object
.
getPrototypeOf
(
[
]
[
Symbol
.
iterator
]
(
)
)
)
;
const
RegExpStringIteratorPrototype
=
Object
.
getPrototypeOf
(
"
"
.
matchAll
(
"
"
)
)
;
assertEq
(
Object
.
getPrototypeOf
(
RegExpStringIteratorPrototype
)
IteratorPrototype
)
;
assertEq
(
typeof
RegExpStringIteratorPrototype
.
next
"
function
"
)
;
assertEq
(
RegExpStringIteratorPrototype
.
next
.
name
"
next
"
)
;
assertEq
(
RegExpStringIteratorPrototype
.
next
.
length
0
)
;
assertEq
(
RegExpStringIteratorPrototype
[
Symbol
.
toStringTag
]
"
RegExp
String
Iterator
"
)
;
const
RegExp_prototype_exec
=
RegExp
.
prototype
.
exec
;
const
RegExp_prototype_match
=
RegExp
.
prototype
[
Symbol
.
match
]
;
function
assertEqIterMatchResult
(
actual
expected
)
{
assertEq
(
actual
.
done
expected
.
done
)
;
if
(
actual
.
value
=
=
=
undefined
|
|
expected
.
value
=
=
=
undefined
)
{
assertEq
(
actual
.
value
expected
.
value
)
;
}
else
{
assertEqArray
(
actual
.
value
expected
.
value
)
;
assertEq
(
actual
.
value
.
input
expected
.
value
.
input
)
;
assertEq
(
actual
.
value
.
index
expected
.
value
.
index
)
;
}
}
function
assertEqMatchResults
(
actual
expected
)
{
var
actualIter
=
actual
[
Symbol
.
iterator
]
(
)
;
var
expectedIter
=
expected
[
Symbol
.
iterator
]
(
)
;
while
(
true
)
{
var
actualResult
=
actualIter
.
next
(
)
;
var
expectedResult
=
expectedIter
.
next
(
)
;
assertEqIterMatchResult
(
actualResult
expectedResult
)
;
if
(
actualResult
.
done
&
&
expectedResult
.
done
)
return
;
}
}
function
*
matchResults
(
string
regexp
lastIndex
=
0
)
{
regexp
.
lastIndex
=
lastIndex
;
while
(
true
)
{
var
match
=
Reflect
.
apply
(
RegExp_prototype_exec
regexp
[
string
]
)
;
if
(
match
=
=
=
null
)
return
;
yield
match
;
if
(
!
regexp
.
global
)
return
;
}
}
assertEqMatchResults
(
/
a
/
[
Symbol
.
matchAll
]
(
"
ababcca
"
)
matchResults
(
"
ababcca
"
/
a
/
)
)
;
assertEqMatchResults
(
"
ababcca
"
.
matchAll
(
/
a
/
g
)
matchResults
(
"
ababcca
"
/
a
/
g
)
)
;
assertEqMatchResults
(
"
ababcca
"
.
matchAll
(
"
a
"
)
matchResults
(
"
ababcca
"
/
a
/
g
)
)
;
{
let
otherGlobal
=
newGlobal
(
)
;
let
iterator
=
otherGlobal
.
eval
(
"
ababcca
"
.
matchAll
(
/
a
/
g
)
)
;
let
expected
=
matchResults
(
"
ababcca
"
/
a
/
g
)
;
assertEqIterMatchResult
(
RegExpStringIteratorPrototype
.
next
.
call
(
iterator
)
expected
.
next
(
)
)
;
}
{
let
regexp
=
/
a
+
/
g
;
let
iterator
=
"
aabb
"
.
matchAll
(
regexp
)
;
regexp
.
compile
(
"
b
+
"
"
g
"
)
;
assertEqMatchResults
(
iterator
matchResults
(
"
aabb
"
/
a
+
/
g
)
)
;
}
{
let
regexp
=
/
a
+
/
gi
;
let
iterator
=
"
aAbb
"
.
matchAll
(
regexp
)
;
regexp
.
compile
(
"
a
+
"
"
"
)
;
assertEqMatchResults
(
iterator
matchResults
(
"
aAbb
"
/
a
+
/
gi
)
)
;
}
{
let
regexp
=
/
a
+
/
g
;
let
iterator
=
"
aabbaa
"
.
matchAll
(
regexp
)
;
let
expected
=
matchResults
(
"
aabbaa
"
/
a
+
/
g
)
;
assertEqIterMatchResult
(
iterator
.
next
(
)
expected
.
next
(
)
)
;
regexp
.
compile
(
"
b
+
"
"
g
"
)
;
assertEqIterMatchResult
(
iterator
.
next
(
)
expected
.
next
(
)
)
;
}
{
let
regexp
=
/
a
+
/
g
;
let
iterator
=
"
aabbAA
"
.
matchAll
(
regexp
)
;
let
expected
=
matchResults
(
"
aabbAA
"
/
a
+
/
g
)
;
assertEqIterMatchResult
(
iterator
.
next
(
)
expected
.
next
(
)
)
;
regexp
.
compile
(
"
a
+
"
"
i
"
)
;
assertEqIterMatchResult
(
iterator
.
next
(
)
expected
.
next
(
)
)
;
}
{
let
regexp
=
/
a
+
/
g
;
regexp
.
lastIndex
=
1
;
let
iterator
=
"
aabbaa
"
.
matchAll
(
regexp
)
;
let
expected
=
matchResults
(
"
aabbaa
"
/
a
+
/
g
1
)
;
assertEq
(
regexp
.
lastIndex
1
)
;
assertEqIterMatchResult
(
iterator
.
next
(
)
expected
.
next
(
)
)
;
assertEq
(
regexp
.
lastIndex
1
)
;
assertEqIterMatchResult
(
iterator
.
next
(
)
expected
.
next
(
)
)
;
assertEq
(
regexp
.
lastIndex
1
)
;
}
{
let
regexp
=
/
a
+
/
g
;
let
iterator
=
"
aabbaa
"
.
matchAll
(
regexp
)
;
regexp
.
lastIndex
=
1
;
let
expected
=
matchResults
(
"
aabbaa
"
/
a
+
/
g
)
;
assertEq
(
regexp
.
lastIndex
1
)
;
assertEqIterMatchResult
(
iterator
.
next
(
)
expected
.
next
(
)
)
;
assertEq
(
regexp
.
lastIndex
1
)
;
assertEqIterMatchResult
(
iterator
.
next
(
)
expected
.
next
(
)
)
;
assertEq
(
regexp
.
lastIndex
1
)
;
}
try
{
let
regexp
=
/
a
+
/
g
;
let
callCount
=
0
;
Object
.
defineProperty
(
RegExp
.
prototype
Symbol
.
match
{
get
(
)
{
assertEq
(
this
regexp
)
;
callCount
+
+
;
return
RegExp_prototype_match
;
}
}
)
;
let
iterator
=
"
aabbaa
"
.
matchAll
(
regexp
)
;
assertEq
(
callCount
2
)
;
}
finally
{
Object
.
defineProperty
(
RegExp
.
prototype
Symbol
.
match
{
value
:
RegExp_prototype_match
writable
:
true
enumerable
:
false
configurable
:
true
}
)
;
}
try
{
let
regexp
=
/
a
+
/
g
;
let
iterator
=
"
aabbaa
"
.
matchAll
(
regexp
)
;
let
lastIndices
=
[
0
2
6
]
[
Symbol
.
iterator
]
(
)
;
let
iteratorRegExp
=
null
;
let
callCount
=
0
;
Object
.
defineProperty
(
RegExp
.
prototype
"
exec
"
{
get
(
)
{
callCount
+
+
;
if
(
iteratorRegExp
=
=
=
null
)
iteratorRegExp
=
this
;
assertEq
(
this
=
=
=
regexp
false
)
;
assertEq
(
this
iteratorRegExp
)
;
assertEq
(
this
.
source
regexp
.
source
)
;
assertEq
(
this
.
flags
regexp
.
flags
)
;
assertEq
(
this
.
lastIndex
lastIndices
.
next
(
)
.
value
)
;
return
RegExp_prototype_exec
;
}
}
)
;
assertEqMatchResults
(
iterator
matchResults
(
"
aabbaa
"
/
a
+
/
g
)
)
;
assertEq
(
callCount
3
)
;
}
finally
{
Object
.
defineProperty
(
RegExp
.
prototype
"
exec
"
{
value
:
RegExp_prototype_exec
writable
:
true
enumerable
:
false
configurable
:
true
}
)
;
}
try
{
let
regexp
=
/
a
+
/
g
;
let
iterator
=
"
aabbaa
"
.
matchAll
(
regexp
)
;
let
lastIndices
=
[
0
2
6
]
[
Symbol
.
iterator
]
(
)
;
let
iteratorRegExp
=
null
;
let
callCount
=
0
;
RegExp
.
prototype
.
exec
=
function
(
.
.
.
args
)
{
callCount
+
+
;
if
(
iteratorRegExp
=
=
=
null
)
iteratorRegExp
=
this
;
assertEq
(
this
=
=
=
regexp
false
)
;
assertEq
(
this
iteratorRegExp
)
;
assertEq
(
this
.
source
regexp
.
source
)
;
assertEq
(
this
.
flags
regexp
.
flags
)
;
assertEq
(
this
.
lastIndex
lastIndices
.
next
(
)
.
value
)
;
return
Reflect
.
apply
(
RegExp_prototype_exec
this
args
)
;
}
;
assertEqMatchResults
(
iterator
matchResults
(
"
aabbaa
"
/
a
+
/
g
)
)
;
assertEq
(
callCount
3
)
;
}
finally
{
Object
.
defineProperty
(
RegExp
.
prototype
"
exec
"
{
value
:
RegExp_prototype_exec
writable
:
true
enumerable
:
false
configurable
:
true
}
)
;
}
{
let
regexp
=
/
a
+
/
;
regexp
.
lastIndex
=
2
;
let
iterator
=
regexp
[
Symbol
.
matchAll
]
(
"
aaaaa
"
)
;
assertEqMatchResults
(
iterator
matchResults
(
"
aaaaa
"
/
a
+
/
g
0
)
)
;
}
{
let
regexp
=
/
a
+
/
g
;
regexp
.
lastIndex
=
2
;
let
iterator
=
regexp
[
Symbol
.
matchAll
]
(
"
aaaaa
"
)
;
assertEqMatchResults
(
iterator
matchResults
(
"
aaaaa
"
/
a
+
/
g
2
)
)
;
}
{
let
regexp
=
/
a
+
/
y
;
regexp
.
lastIndex
=
2
;
let
iterator
=
regexp
[
Symbol
.
matchAll
]
(
"
aaaaa
"
)
;
assertEqMatchResults
(
iterator
matchResults
(
"
aaaaa
"
/
a
+
/
g
2
)
)
;
}
{
let
regexp
=
/
a
+
/
gy
;
regexp
.
lastIndex
=
2
;
let
iterator
=
regexp
[
Symbol
.
matchAll
]
(
"
aaaaa
"
)
;
assertEqMatchResults
(
iterator
matchResults
(
"
aaaaa
"
/
a
+
/
g
2
)
)
;
}
if
(
typeof
reportCompare
=
=
=
"
function
"
)
reportCompare
(
true
true
)
;
