import
os
import
re
import
subprocess
import
sys
from
pathlib
import
Path
def
copy_and_update_includes
(
src_path
dst_path
)
:
    
need_shim
=
[
        
"
regexp
-
ast
.
h
"
        
"
regexp
-
bytecode
-
peephole
.
h
"
        
"
regexp
-
bytecodes
.
h
"
        
"
regexp
-
dotprinter
.
h
"
        
"
regexp
-
error
.
h
"
        
"
regexp
.
h
"
        
"
regexp
-
macro
-
assembler
.
h
"
        
"
regexp
-
parser
.
h
"
        
"
regexp
-
stack
.
h
"
        
"
special
-
case
.
h
"
    
]
    
src
=
open
(
str
(
src_path
)
"
r
"
)
    
dst
=
open
(
str
(
dst_path
)
"
w
"
)
    
regexp_include
=
re
.
compile
(
'
#
include
"
src
/
regexp
(
?
!
/
regexp
-
flags
.
h
)
'
)
    
regexp_include_new
=
'
#
include
"
irregexp
/
imported
'
    
other_include
=
re
.
compile
(
'
#
include
"
src
/
'
)
    
need_to_add_shim
=
src_path
.
name
in
need_shim
    
adding_shim_now
=
False
    
for
line
in
src
:
        
if
adding_shim_now
:
            
if
line
=
=
"
\
n
"
:
                
dst
.
write
(
'
#
include
"
irregexp
/
RegExpShim
.
h
"
\
n
'
)
                
need_to_add_shim
=
False
                
adding_shim_now
=
False
        
if
regexp_include
.
search
(
line
)
:
            
dst
.
write
(
re
.
sub
(
regexp_include
regexp_include_new
line
)
)
        
elif
other_include
.
search
(
line
)
:
            
if
need_to_add_shim
:
                
adding_shim_now
=
True
        
else
:
            
dst
.
write
(
line
)
def
import_from
(
srcdir
dstdir
)
:
    
excluded
=
[
        
"
DIR_METADATA
"
        
"
OWNERS
"
        
"
regexp
.
cc
"
        
"
regexp
-
flags
.
h
"
        
"
regexp
-
utils
.
cc
"
        
"
regexp
-
utils
.
h
"
        
"
regexp
-
macro
-
assembler
-
arch
.
h
"
    
]
    
for
file
in
srcdir
.
iterdir
(
)
:
        
if
file
.
is_dir
(
)
:
            
continue
        
if
str
(
file
.
name
)
in
excluded
:
            
continue
        
copy_and_update_includes
(
file
dstdir
/
"
imported
"
/
file
.
name
)
if
__name__
=
=
"
__main__
"
:
    
import
argparse
    
import
tempfile
    
current_path
=
Path
(
os
.
getcwd
(
)
)
    
expected_path
=
"
js
/
src
/
irregexp
"
    
if
not
current_path
.
match
(
expected_path
)
:
        
raise
RuntimeError
(
"
%
s
must
be
run
from
%
s
"
%
(
sys
.
argv
[
0
]
expected_path
)
)
    
parser
=
argparse
.
ArgumentParser
(
description
=
"
Import
irregexp
from
v8
"
)
    
parser
.
add_argument
(
"
-
p
"
"
-
-
path
"
help
=
"
path
to
v8
/
src
/
regexp
"
required
=
False
)
    
args
=
parser
.
parse_args
(
)
    
if
args
.
path
:
        
src_path
=
Path
(
args
.
path
)
        
provided_path
=
"
the
command
-
line
"
    
elif
"
TASK_ID
"
in
os
.
environ
:
        
src_path
=
Path
(
"
/
builds
/
worker
/
v8
/
"
)
        
subprocess
.
run
(
"
git
pull
origin
master
"
shell
=
True
cwd
=
src_path
)
        
src_path
=
Path
(
"
/
builds
/
worker
/
v8
/
src
/
regexp
"
)
        
provided_path
=
"
the
hardcoded
path
in
the
taskcluster
image
"
    
elif
"
V8_GIT
"
in
os
.
environ
:
        
src_path
=
Path
(
os
.
environ
[
"
V8_GIT
"
]
)
        
provided_path
=
"
the
V8_GIT
environment
variable
"
    
else
:
        
tempdir
=
tempfile
.
TemporaryDirectory
(
)
        
v8_git
=
"
https
:
/
/
github
.
com
/
v8
/
v8
.
git
"
        
clone
=
"
git
clone
-
-
depth
1
%
s
%
s
"
%
(
v8_git
tempdir
.
name
)
        
os
.
system
(
clone
)
        
src_path
=
Path
(
tempdir
.
name
)
/
"
src
/
regexp
"
        
provided_path
=
"
the
temporary
git
checkout
"
    
if
not
(
src_path
/
"
regexp
.
h
"
)
.
exists
(
)
:
        
print
(
"
Could
not
find
regexp
.
h
in
the
path
provided
from
"
provided_path
)
        
print
(
"
Usage
:
\
n
import
-
irregexp
.
py
[
-
-
path
<
path
/
to
/
v8
/
src
/
regexp
>
]
"
)
        
sys
.
exit
(
1
)
    
if
"
MACH_VENDOR
"
not
in
os
.
environ
:
        
print
(
            
"
Running
this
script
outside
.
/
mach
vendor
is
not
recommended
-
"
            
"
You
will
need
to
update
moz
.
yaml
manually
"
        
)
        
print
(
"
We
recommend
instead
.
/
mach
vendor
js
/
src
/
irregexp
/
moz
.
yaml
"
)
        
response
=
input
(
"
Type
Y
to
continue
.
.
.
"
)
        
if
response
.
lower
(
)
!
=
"
y
"
:
            
sys
.
exit
(
1
)
    
import_from
(
src_path
current_path
)
