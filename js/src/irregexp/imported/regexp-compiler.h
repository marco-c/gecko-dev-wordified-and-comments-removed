#
ifndef
V8_REGEXP_REGEXP_COMPILER_H_
#
define
V8_REGEXP_REGEXP_COMPILER_H_
#
include
<
bitset
>
#
include
"
irregexp
/
imported
/
regexp
-
nodes
.
h
"
namespace
v8
{
namespace
internal
{
class
DynamicBitSet
;
class
Isolate
;
class
FixedLengthLoopState
;
namespace
regexp_compiler_constants
{
constexpr
base
:
:
uc32
kRangeEndMarker
=
0x110000
;
constexpr
int
kSpaceRanges
[
]
=
{
'
\
t
'
'
\
r
'
+
1
'
'
'
'
+
1
0x00A0
0x00A1
0x1680
0x1681
0x2000
0x200B
0x2028
0x202A
0x202F
0x2030
0x205F
0x2060
0x3000
0x3001
0xFEFF
0xFF00
kRangeEndMarker
}
;
constexpr
int
kSpaceRangeCount
=
arraysize
(
kSpaceRanges
)
;
constexpr
int
kWordRanges
[
]
=
{
'
0
'
'
9
'
+
1
'
A
'
'
Z
'
+
1
'
_
'
'
_
'
+
1
'
a
'
'
z
'
+
1
kRangeEndMarker
}
;
constexpr
int
kWordRangeCount
=
arraysize
(
kWordRanges
)
;
constexpr
int
kDigitRanges
[
]
=
{
'
0
'
'
9
'
+
1
kRangeEndMarker
}
;
constexpr
int
kDigitRangeCount
=
arraysize
(
kDigitRanges
)
;
constexpr
int
kSurrogateRanges
[
]
=
{
kLeadSurrogateStart
kLeadSurrogateStart
+
1
kRangeEndMarker
}
;
constexpr
int
kSurrogateRangeCount
=
arraysize
(
kSurrogateRanges
)
;
constexpr
int
kLineTerminatorRanges
[
]
=
{
0x000A
0x000B
0x000D
0x000E
0x2028
0x202A
kRangeEndMarker
}
;
constexpr
int
kLineTerminatorRangeCount
=
arraysize
(
kLineTerminatorRanges
)
;
constexpr
uint32_t
kMaxLookaheadForBoyerMoore
=
8
;
constexpr
uint32_t
kPatternTooShortForBoyerMoore
=
2
;
}
inline
bool
NeedsUnicodeCaseEquivalents
(
RegExpFlags
flags
)
{
return
IsEitherUnicode
(
flags
)
&
&
IsIgnoreCase
(
flags
)
;
}
class
QuickCheckDetails
{
public
:
QuickCheckDetails
(
)
:
characters_
(
0
)
mask_
(
0
)
value_
(
0
)
cannot_match_
(
false
)
{
}
explicit
QuickCheckDetails
(
int
characters
)
:
characters_
(
characters
)
mask_
(
0
)
value_
(
0
)
cannot_match_
(
false
)
{
}
bool
Rationalize
(
bool
one_byte
)
;
void
Merge
(
QuickCheckDetails
*
other
int
from_index
)
;
void
Advance
(
int
by
bool
one_byte
)
;
void
Clear
(
)
;
bool
cannot_match
(
)
{
return
cannot_match_
;
}
void
set_cannot_match
(
)
{
cannot_match_
=
true
;
}
struct
Position
{
Position
(
)
:
mask
(
0
)
value
(
0
)
determines_perfectly
(
false
)
{
}
base
:
:
uc32
mask
;
base
:
:
uc32
value
;
bool
determines_perfectly
;
}
;
int
characters
(
)
const
{
return
characters_
;
}
void
set_characters
(
int
characters
)
{
characters_
=
characters
;
}
Position
*
positions
(
int
index
)
{
DCHECK_LE
(
0
index
)
;
DCHECK_GT
(
characters_
index
)
;
return
positions_
+
index
;
}
const
Position
*
positions
(
int
index
)
const
{
DCHECK_LE
(
0
index
)
;
DCHECK_GT
(
characters_
index
)
;
return
positions_
+
index
;
}
uint32_t
mask
(
)
{
return
mask_
;
}
uint32_t
value
(
)
{
return
value_
;
}
private
:
int
characters_
;
Position
positions_
[
4
]
;
uint32_t
mask_
;
uint32_t
value_
;
bool
cannot_match_
;
}
;
enum
ContainedInLattice
{
kNotYet
=
0
kLatticeIn
=
1
kLatticeOut
=
2
kLatticeUnknown
=
3
}
;
inline
ContainedInLattice
Combine
(
ContainedInLattice
a
ContainedInLattice
b
)
{
return
static_cast
<
ContainedInLattice
>
(
a
|
b
)
;
}
class
BoyerMoorePositionInfo
:
public
ZoneObject
{
public
:
bool
at
(
int
i
)
const
{
return
map_
[
i
]
;
}
static
constexpr
int
kMapSize
=
128
;
static
constexpr
int
kMask
=
kMapSize
-
1
;
int
map_count
(
)
const
{
return
map_count_
;
}
void
Set
(
int
character
)
;
void
SetInterval
(
const
Interval
&
interval
)
;
void
SetAll
(
)
;
bool
is_non_word
(
)
{
return
w_
=
=
kLatticeOut
;
}
bool
is_word
(
)
{
return
w_
=
=
kLatticeIn
;
}
using
Bitset
=
std
:
:
bitset
<
kMapSize
>
;
Bitset
raw_bitset
(
)
const
{
return
map_
;
}
private
:
Bitset
map_
;
int
map_count_
=
0
;
ContainedInLattice
w_
=
kNotYet
;
}
;
class
BoyerMooreLookahead
:
public
ZoneObject
{
public
:
BoyerMooreLookahead
(
int
length
RegExpCompiler
*
compiler
Zone
*
zone
)
;
int
length
(
)
{
return
length_
;
}
int
max_char
(
)
{
return
max_char_
;
}
RegExpCompiler
*
compiler
(
)
{
return
compiler_
;
}
int
Count
(
int
map_number
)
{
return
bitmaps_
-
>
at
(
map_number
)
-
>
map_count
(
)
;
}
BoyerMoorePositionInfo
*
at
(
int
i
)
{
return
bitmaps_
-
>
at
(
i
)
;
}
void
Set
(
int
map_number
int
character
)
{
if
(
character
>
max_char_
)
return
;
BoyerMoorePositionInfo
*
info
=
bitmaps_
-
>
at
(
map_number
)
;
info
-
>
Set
(
character
)
;
}
void
SetInterval
(
int
map_number
const
Interval
&
interval
)
{
if
(
interval
.
from
(
)
>
max_char_
)
return
;
BoyerMoorePositionInfo
*
info
=
bitmaps_
-
>
at
(
map_number
)
;
if
(
interval
.
to
(
)
>
max_char_
)
{
info
-
>
SetInterval
(
Interval
(
interval
.
from
(
)
max_char_
)
)
;
}
else
{
info
-
>
SetInterval
(
interval
)
;
}
}
void
SetAll
(
int
map_number
)
{
bitmaps_
-
>
at
(
map_number
)
-
>
SetAll
(
)
;
}
void
SetRest
(
int
from_map
)
{
for
(
int
i
=
from_map
;
i
<
length_
;
i
+
+
)
SetAll
(
i
)
;
}
void
EmitSkipInstructions
(
RegExpMacroAssembler
*
masm
)
;
private
:
int
length_
;
RegExpCompiler
*
compiler_
;
int
max_char_
;
ZoneList
<
BoyerMoorePositionInfo
*
>
*
bitmaps_
;
int
GetSkipTable
(
int
min_lookahead
int
max_lookahead
DirectHandle
<
ByteArray
>
boolean_skip_table
DirectHandle
<
ByteArray
>
nibble_table
=
DirectHandle
<
ByteArray
>
{
}
)
;
bool
FindWorthwhileInterval
(
int
*
from
int
*
to
)
;
int
FindBestInterval
(
int
max_number_of_chars
int
old_biggest_points
int
*
from
int
*
to
)
;
}
;
class
Trace
{
public
:
enum
TriBool
{
UNKNOWN
=
-
1
FALSE_VALUE
=
0
TRUE_VALUE
=
1
}
;
Trace
(
)
:
cp_offset_
(
0
)
flush_budget_
(
100
)
at_start_
(
UNKNOWN
)
has_any_actions_
(
false
)
action_
(
nullptr
)
backtrack_
(
nullptr
)
fixed_length_loop_state_
(
nullptr
)
characters_preloaded_
(
0
)
bound_checked_up_to_
(
0
)
next_
(
nullptr
)
{
}
Trace
(
const
Trace
&
other
)
V8_NOEXCEPT
:
cp_offset_
(
other
.
cp_offset_
)
flush_budget_
(
other
.
flush_budget_
)
at_start_
(
other
.
at_start_
)
has_any_actions_
(
other
.
has_any_actions_
)
action_
(
nullptr
)
backtrack_
(
other
.
backtrack_
)
fixed_length_loop_state_
(
other
.
fixed_length_loop_state_
)
characters_preloaded_
(
other
.
characters_preloaded_
)
bound_checked_up_to_
(
other
.
bound_checked_up_to_
)
quick_check_performed_
(
other
.
quick_check_performed_
)
next_
(
&
other
)
{
}
enum
FlushMode
{
kFlushFull
kFlushSuccess
}
;
void
Flush
(
RegExpCompiler
*
compiler
RegExpNode
*
successor
FlushMode
mode
=
kFlushFull
)
;
int
cp_offset
(
)
const
{
return
cp_offset_
;
}
bool
has_any_actions
(
)
const
{
return
has_any_actions_
;
}
bool
has_action
(
)
const
{
return
action_
!
=
nullptr
;
}
ActionNode
*
action
(
)
const
{
return
action_
;
}
bool
is_trivial
(
)
const
{
return
backtrack_
=
=
nullptr
&
&
!
has_any_actions_
&
&
cp_offset_
=
=
0
&
&
characters_preloaded_
=
=
0
&
&
bound_checked_up_to_
=
=
0
&
&
quick_check_performed_
.
characters
(
)
=
=
0
&
&
at_start_
=
=
UNKNOWN
;
}
TriBool
at_start
(
)
const
{
return
at_start_
;
}
void
set_at_start
(
TriBool
at_start
)
{
at_start_
=
at_start
;
}
Label
*
backtrack
(
)
const
{
return
backtrack_
;
}
FixedLengthLoopState
*
fixed_length_loop_state
(
)
const
{
return
fixed_length_loop_state_
;
}
int
characters_preloaded
(
)
const
{
return
characters_preloaded_
;
}
int
bound_checked_up_to
(
)
const
{
return
bound_checked_up_to_
;
}
int
flush_budget
(
)
const
{
return
flush_budget_
;
}
QuickCheckDetails
*
quick_check_performed
(
)
{
return
&
quick_check_performed_
;
}
bool
mentions_reg
(
int
reg
)
const
;
bool
GetStoredPosition
(
int
reg
int
*
cp_offset
)
const
;
void
add_action
(
ActionNode
*
new_action
)
{
DCHECK
(
action_
=
=
nullptr
)
;
action_
=
new_action
;
has_any_actions_
=
true
;
}
void
set_backtrack
(
Label
*
backtrack
)
{
backtrack_
=
backtrack
;
}
void
set_fixed_length_loop_state
(
FixedLengthLoopState
*
state
)
{
fixed_length_loop_state_
=
state
;
}
void
set_characters_preloaded
(
int
count
)
{
characters_preloaded_
=
count
;
}
void
set_bound_checked_up_to
(
int
to
)
{
bound_checked_up_to_
=
to
;
}
void
set_flush_budget
(
int
to
)
{
DCHECK
(
to
<
=
UINT16_MAX
)
;
flush_budget_
=
to
;
}
void
set_quick_check_performed
(
QuickCheckDetails
*
d
)
{
quick_check_performed_
=
*
d
;
}
void
InvalidateCurrentCharacter
(
)
;
void
AdvanceCurrentPositionInTrace
(
int
by
RegExpCompiler
*
compiler
)
;
const
Trace
*
next
(
)
const
{
return
next_
;
}
class
ConstIterator
final
{
public
:
ConstIterator
&
operator
+
+
(
)
{
trace_
=
trace_
-
>
next
(
)
;
return
*
this
;
}
bool
operator
=
=
(
const
ConstIterator
&
other
)
const
{
return
trace_
=
=
other
.
trace_
;
}
const
Trace
*
operator
*
(
)
const
{
return
trace_
;
}
private
:
explicit
ConstIterator
(
const
Trace
*
trace
)
:
trace_
(
trace
)
{
}
const
Trace
*
trace_
;
friend
class
Trace
;
}
;
ConstIterator
begin
(
)
const
{
return
ConstIterator
(
this
)
;
}
ConstIterator
end
(
)
const
{
return
ConstIterator
(
nullptr
)
;
}
private
:
int
FindAffectedRegisters
(
DynamicBitSet
*
affected_registers
Zone
*
zone
)
;
void
PerformDeferredActions
(
RegExpMacroAssembler
*
macro
int
max_register
const
DynamicBitSet
&
affected_registers
DynamicBitSet
*
registers_to_pop
DynamicBitSet
*
registers_to_clear
Zone
*
zone
)
;
void
RestoreAffectedRegisters
(
RegExpMacroAssembler
*
macro
int
max_register
const
DynamicBitSet
&
registers_to_pop
const
DynamicBitSet
&
registers_to_clear
)
;
int
cp_offset_
;
uint16_t
flush_budget_
;
TriBool
at_start_
:
8
;
bool
has_any_actions_
:
8
;
ActionNode
*
action_
;
Label
*
backtrack_
;
FixedLengthLoopState
*
fixed_length_loop_state_
;
int
characters_preloaded_
;
int
bound_checked_up_to_
;
QuickCheckDetails
quick_check_performed_
;
const
Trace
*
next_
;
}
;
class
FixedLengthLoopState
{
public
:
explicit
FixedLengthLoopState
(
bool
not_at_start
ChoiceNode
*
loop_choice_node
)
;
void
BindStepBackwardsLabel
(
RegExpMacroAssembler
*
macro_assembler
)
;
void
BindLoopTopLabel
(
RegExpMacroAssembler
*
macro_assembler
)
;
void
GoToLoopTopLabel
(
RegExpMacroAssembler
*
macro_assembler
)
;
ChoiceNode
*
loop_choice_node
(
)
const
{
return
loop_choice_node_
;
}
Trace
*
counter_backtrack_trace
(
)
{
return
&
counter_backtrack_trace_
;
}
private
:
Label
step_backwards_label_
;
Label
loop_top_label_
;
ChoiceNode
*
loop_choice_node_
;
Trace
counter_backtrack_trace_
;
}
;
struct
PreloadState
{
static
const
int
kEatsAtLeastNotYetInitialized
=
-
1
;
bool
preload_is_current_
;
bool
preload_has_checked_bounds_
;
int
preload_characters_
;
int
eats_at_least_
;
void
init
(
)
{
eats_at_least_
=
kEatsAtLeastNotYetInitialized
;
}
}
;
RegExpError
AnalyzeRegExp
(
Isolate
*
isolate
bool
is_one_byte
RegExpFlags
flags
RegExpNode
*
node
)
;
class
FrequencyCollator
{
public
:
FrequencyCollator
(
)
:
total_samples_
(
0
)
{
for
(
int
i
=
0
;
i
<
RegExpMacroAssembler
:
:
kTableSize
;
i
+
+
)
{
frequencies_
[
i
]
=
CharacterFrequency
(
i
)
;
}
}
void
CountCharacter
(
int
character
)
{
int
index
=
(
character
&
RegExpMacroAssembler
:
:
kTableMask
)
;
frequencies_
[
index
]
.
Increment
(
)
;
total_samples_
+
+
;
}
int
Frequency
(
int
in_character
)
{
DCHECK
(
(
in_character
&
RegExpMacroAssembler
:
:
kTableMask
)
=
=
in_character
)
;
if
(
total_samples_
<
1
)
return
1
;
int
freq_in_per128
=
(
frequencies_
[
in_character
]
.
counter
(
)
*
128
)
/
total_samples_
;
return
freq_in_per128
;
}
private
:
class
CharacterFrequency
{
public
:
CharacterFrequency
(
)
:
counter_
(
0
)
character_
(
-
1
)
{
}
explicit
CharacterFrequency
(
int
character
)
:
counter_
(
0
)
character_
(
character
)
{
}
void
Increment
(
)
{
counter_
+
+
;
}
int
counter
(
)
{
return
counter_
;
}
int
character
(
)
{
return
character_
;
}
private
:
int
counter_
;
int
character_
;
}
;
private
:
CharacterFrequency
frequencies_
[
RegExpMacroAssembler
:
:
kTableSize
]
;
int
total_samples_
;
}
;
class
RegExpCompiler
{
public
:
RegExpCompiler
(
Isolate
*
isolate
Zone
*
zone
int
capture_count
RegExpFlags
flags
bool
is_one_byte
)
;
int
AllocateRegister
(
)
{
if
(
next_register_
>
=
RegExpMacroAssembler
:
:
kMaxRegister
)
{
reg_exp_too_big_
=
true
;
return
next_register_
;
}
return
next_register_
+
+
;
}
int
UnicodeLookaroundStackRegister
(
)
{
if
(
unicode_lookaround_stack_register_
=
=
kNoRegister
)
{
unicode_lookaround_stack_register_
=
AllocateRegister
(
)
;
}
return
unicode_lookaround_stack_register_
;
}
int
UnicodeLookaroundPositionRegister
(
)
{
if
(
unicode_lookaround_position_register_
=
=
kNoRegister
)
{
unicode_lookaround_position_register_
=
AllocateRegister
(
)
;
}
return
unicode_lookaround_position_register_
;
}
struct
CompilationResult
final
{
explicit
CompilationResult
(
RegExpError
err
)
:
error
(
err
)
{
}
CompilationResult
(
DirectHandle
<
Object
>
code
int
registers
)
:
code
(
code
)
num_registers
(
registers
)
{
}
static
CompilationResult
RegExpTooBig
(
)
{
return
CompilationResult
(
RegExpError
:
:
kTooLarge
)
;
}
bool
Succeeded
(
)
const
{
return
error
=
=
RegExpError
:
:
kNone
;
}
const
RegExpError
error
=
RegExpError
:
:
kNone
;
DirectHandle
<
Object
>
code
;
int
num_registers
=
0
;
}
;
CompilationResult
Assemble
(
Isolate
*
isolate
RegExpMacroAssembler
*
assembler
RegExpNode
*
start
int
capture_count
DirectHandle
<
String
>
pattern
)
;
RegExpNode
*
PreprocessRegExp
(
RegExpCompileData
*
data
bool
is_one_byte
)
;
RegExpNode
*
OptionallyStepBackToLeadSurrogate
(
RegExpNode
*
on_success
)
;
inline
void
AddWork
(
RegExpNode
*
node
)
{
if
(
!
node
-
>
on_work_list
(
)
&
&
!
node
-
>
label
(
)
-
>
is_bound
(
)
)
{
node
-
>
set_on_work_list
(
true
)
;
work_list_
-
>
push_back
(
node
)
;
}
}
static
const
int
kImplementationOffset
=
0
;
static
const
int
kNumberOfRegistersOffset
=
0
;
static
const
int
kCodeOffset
=
1
;
RegExpMacroAssembler
*
macro_assembler
(
)
{
return
macro_assembler_
;
}
EndNode
*
accept
(
)
{
return
accept_
;
}
#
if
defined
(
V8_TARGET_OS_MACOS
)
static
constexpr
int
kMaxRecursion
=
50
;
#
else
static
constexpr
int
kMaxRecursion
=
100
;
#
endif
inline
int
recursion_depth
(
)
{
return
recursion_depth_
;
}
inline
void
IncrementRecursionDepth
(
)
{
recursion_depth_
+
+
;
}
inline
void
DecrementRecursionDepth
(
)
{
recursion_depth_
-
-
;
}
inline
RegExpFlags
flags
(
)
const
{
return
flags_
;
}
inline
void
set_flags
(
RegExpFlags
flags
)
{
flags_
=
flags
;
}
void
SetRegExpTooBig
(
)
{
reg_exp_too_big_
=
true
;
}
inline
bool
one_byte
(
)
{
return
one_byte_
;
}
inline
bool
optimize
(
)
{
return
optimize_
;
}
inline
void
set_optimize
(
bool
value
)
{
optimize_
=
value
;
}
inline
bool
limiting_recursion
(
)
{
return
limiting_recursion_
;
}
inline
void
set_limiting_recursion
(
bool
value
)
{
limiting_recursion_
=
value
;
}
bool
read_backward
(
)
{
return
read_backward_
;
}
void
set_read_backward
(
bool
value
)
{
read_backward_
=
value
;
}
FrequencyCollator
*
frequency_collator
(
)
{
return
&
frequency_collator_
;
}
int
current_expansion_factor
(
)
{
return
current_expansion_factor_
;
}
void
set_current_expansion_factor
(
int
value
)
{
current_expansion_factor_
=
value
;
}
void
ToNodeMaybeCheckForStackOverflow
(
)
{
if
(
(
to_node_overflow_check_ticks_
+
+
%
64
=
=
0
)
)
{
ToNodeCheckForStackOverflow
(
)
;
}
}
void
ToNodeCheckForStackOverflow
(
)
;
Isolate
*
isolate
(
)
const
{
return
isolate_
;
}
Zone
*
zone
(
)
const
{
return
zone_
;
}
static
const
int
kNoRegister
=
-
1
;
private
:
EndNode
*
accept_
;
int
next_register_
;
int
unicode_lookaround_stack_register_
;
int
unicode_lookaround_position_register_
;
ZoneVector
<
RegExpNode
*
>
*
work_list_
;
int
recursion_depth_
;
RegExpFlags
flags_
;
RegExpMacroAssembler
*
macro_assembler_
;
bool
one_byte_
;
bool
reg_exp_too_big_
;
bool
limiting_recursion_
;
int
to_node_overflow_check_ticks_
=
0
;
bool
optimize_
;
bool
read_backward_
;
int
current_expansion_factor_
;
FrequencyCollator
frequency_collator_
;
Isolate
*
isolate_
;
Zone
*
zone_
;
}
;
class
UnicodeRangeSplitter
{
public
:
V8_EXPORT_PRIVATE
UnicodeRangeSplitter
(
ZoneList
<
CharacterRange
>
*
base
)
;
static
constexpr
int
kInitialSize
=
8
;
using
CharacterRangeVector
=
base
:
:
SmallVector
<
CharacterRange
kInitialSize
>
;
const
CharacterRangeVector
*
bmp
(
)
const
{
return
&
bmp_
;
}
const
CharacterRangeVector
*
lead_surrogates
(
)
const
{
return
&
lead_surrogates_
;
}
const
CharacterRangeVector
*
trail_surrogates
(
)
const
{
return
&
trail_surrogates_
;
}
const
CharacterRangeVector
*
non_bmp
(
)
const
{
return
&
non_bmp_
;
}
private
:
void
AddRange
(
CharacterRange
range
)
;
CharacterRangeVector
bmp_
;
CharacterRangeVector
lead_surrogates_
;
CharacterRangeVector
trail_surrogates_
;
CharacterRangeVector
non_bmp_
;
}
;
bool
RangeContainsLatin1Equivalents
(
CharacterRange
range
)
;
}
}
#
endif
