#
ifndef
V8_REGEXP_REGEXP_NODES_H_
#
define
V8_REGEXP_REGEXP_NODES_H_
#
include
"
irregexp
/
imported
/
regexp
-
macro
-
assembler
.
h
"
namespace
v8
{
namespace
internal
{
class
AlternativeGenerationList
;
class
BoyerMooreLookahead
;
class
GreedyLoopState
;
class
NodeVisitor
;
class
QuickCheckDetails
;
class
RegExpCompiler
;
class
Trace
;
struct
PreloadState
;
class
ChoiceNode
;
#
define
FOR_EACH_NODE_TYPE
(
VISIT
)
\
VISIT
(
End
)
\
VISIT
(
Action
)
\
VISIT
(
Choice
)
\
VISIT
(
LoopChoice
)
\
VISIT
(
NegativeLookaroundChoice
)
\
VISIT
(
BackReference
)
\
VISIT
(
Assertion
)
\
VISIT
(
Text
)
struct
NodeInfo
final
{
NodeInfo
(
)
:
being_analyzed
(
false
)
been_analyzed
(
false
)
follows_word_interest
(
false
)
follows_newline_interest
(
false
)
follows_start_interest
(
false
)
at_end
(
false
)
visited
(
false
)
replacement_calculated
(
false
)
{
}
bool
Matches
(
NodeInfo
*
that
)
{
return
(
at_end
=
=
that
-
>
at_end
)
&
&
(
follows_word_interest
=
=
that
-
>
follows_word_interest
)
&
&
(
follows_newline_interest
=
=
that
-
>
follows_newline_interest
)
&
&
(
follows_start_interest
=
=
that
-
>
follows_start_interest
)
;
}
void
AddFromPreceding
(
NodeInfo
*
that
)
{
at_end
|
=
that
-
>
at_end
;
follows_word_interest
|
=
that
-
>
follows_word_interest
;
follows_newline_interest
|
=
that
-
>
follows_newline_interest
;
follows_start_interest
|
=
that
-
>
follows_start_interest
;
}
bool
HasLookbehind
(
)
{
return
follows_word_interest
|
|
follows_newline_interest
|
|
follows_start_interest
;
}
void
AddFromFollowing
(
NodeInfo
*
that
)
{
follows_word_interest
|
=
that
-
>
follows_word_interest
;
follows_newline_interest
|
=
that
-
>
follows_newline_interest
;
follows_start_interest
|
=
that
-
>
follows_start_interest
;
}
void
ResetCompilationState
(
)
{
being_analyzed
=
false
;
been_analyzed
=
false
;
}
bool
being_analyzed
:
1
;
bool
been_analyzed
:
1
;
bool
follows_word_interest
:
1
;
bool
follows_newline_interest
:
1
;
bool
follows_start_interest
:
1
;
bool
at_end
:
1
;
bool
visited
:
1
;
bool
replacement_calculated
:
1
;
}
;
struct
EatsAtLeastInfo
final
{
EatsAtLeastInfo
(
)
:
EatsAtLeastInfo
(
0
)
{
}
explicit
EatsAtLeastInfo
(
uint8_t
eats
)
:
eats_at_least_from_possibly_start
(
eats
)
eats_at_least_from_not_start
(
eats
)
{
}
void
SetMin
(
const
EatsAtLeastInfo
&
other
)
{
if
(
other
.
eats_at_least_from_possibly_start
<
eats_at_least_from_possibly_start
)
{
eats_at_least_from_possibly_start
=
other
.
eats_at_least_from_possibly_start
;
}
if
(
other
.
eats_at_least_from_not_start
<
eats_at_least_from_not_start
)
{
eats_at_least_from_not_start
=
other
.
eats_at_least_from_not_start
;
}
}
bool
IsZero
(
)
const
{
return
eats_at_least_from_possibly_start
=
=
0
&
&
eats_at_least_from_not_start
=
=
0
;
}
uint8_t
eats_at_least_from_possibly_start
;
uint8_t
eats_at_least_from_not_start
;
}
;
class
RegExpNode
:
public
ZoneObject
{
public
:
explicit
RegExpNode
(
Zone
*
zone
)
:
replacement_
(
nullptr
)
on_work_list_
(
false
)
trace_count_
(
0
)
zone_
(
zone
)
{
bm_info_
[
0
]
=
bm_info_
[
1
]
=
nullptr
;
}
virtual
~
RegExpNode
(
)
;
virtual
void
Accept
(
NodeVisitor
*
visitor
)
=
0
;
virtual
void
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
=
0
;
int
EatsAtLeast
(
bool
not_at_start
)
;
virtual
EatsAtLeastInfo
EatsAtLeastFromLoopEntry
(
)
;
bool
EmitQuickCheck
(
RegExpCompiler
*
compiler
Trace
*
bounds_check_trace
Trace
*
trace
bool
preload_has_checked_bounds
Label
*
on_possible_success
QuickCheckDetails
*
details_return
bool
fall_through_on_failure
ChoiceNode
*
predecessor
)
;
virtual
void
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
=
0
;
virtual
void
GetQuickCheckDetailsFromLoopEntry
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
;
static
const
int
kNodeIsTooComplexForGreedyLoops
=
kMinInt
;
virtual
int
GreedyLoopTextLength
(
)
{
return
kNodeIsTooComplexForGreedyLoops
;
}
virtual
RegExpNode
*
GetSuccessorOfOmnivorousTextNode
(
RegExpCompiler
*
compiler
)
{
return
nullptr
;
}
static
const
int
kRecursionBudget
=
200
;
bool
KeepRecursing
(
RegExpCompiler
*
compiler
)
;
virtual
void
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
{
UNREACHABLE
(
)
;
}
virtual
RegExpNode
*
FilterOneByte
(
int
depth
RegExpFlags
flags
)
{
return
this
;
}
RegExpNode
*
replacement
(
)
{
DCHECK
(
info
(
)
-
>
replacement_calculated
)
;
return
replacement_
;
}
RegExpNode
*
set_replacement
(
RegExpNode
*
replacement
)
{
info
(
)
-
>
replacement_calculated
=
true
;
replacement_
=
replacement
;
return
replacement
;
}
void
SaveBMInfo
(
BoyerMooreLookahead
*
bm
bool
not_at_start
int
offset
)
{
if
(
offset
=
=
0
)
set_bm_info
(
not_at_start
bm
)
;
}
Label
*
label
(
)
{
return
&
label_
;
}
static
const
int
kMaxCopiesCodeGenerated
=
10
;
bool
on_work_list
(
)
{
return
on_work_list_
;
}
void
set_on_work_list
(
bool
value
)
{
on_work_list_
=
value
;
}
NodeInfo
*
info
(
)
{
return
&
info_
;
}
const
EatsAtLeastInfo
*
eats_at_least_info
(
)
const
{
return
&
eats_at_least_
;
}
void
set_eats_at_least_info
(
const
EatsAtLeastInfo
&
eats_at_least
)
{
eats_at_least_
=
eats_at_least
;
}
void
SetDoNotInline
(
)
{
trace_count_
=
kMaxCopiesCodeGenerated
;
}
BoyerMooreLookahead
*
bm_info
(
bool
not_at_start
)
{
return
bm_info_
[
not_at_start
?
1
:
0
]
;
}
Zone
*
zone
(
)
const
{
return
zone_
;
}
protected
:
enum
LimitResult
{
DONE
CONTINUE
}
;
RegExpNode
*
replacement_
;
LimitResult
LimitVersions
(
RegExpCompiler
*
compiler
Trace
*
trace
)
;
void
set_bm_info
(
bool
not_at_start
BoyerMooreLookahead
*
bm
)
{
bm_info_
[
not_at_start
?
1
:
0
]
=
bm
;
}
private
:
static
const
int
kFirstCharBudget
=
10
;
Label
label_
;
bool
on_work_list_
;
NodeInfo
info_
;
EatsAtLeastInfo
eats_at_least_
;
int
trace_count_
;
BoyerMooreLookahead
*
bm_info_
[
2
]
;
Zone
*
zone_
;
}
;
class
SeqRegExpNode
:
public
RegExpNode
{
public
:
explicit
SeqRegExpNode
(
RegExpNode
*
on_success
)
:
RegExpNode
(
on_success
-
>
zone
(
)
)
on_success_
(
on_success
)
{
}
RegExpNode
*
on_success
(
)
{
return
on_success_
;
}
void
set_on_success
(
RegExpNode
*
node
)
{
on_success_
=
node
;
}
RegExpNode
*
FilterOneByte
(
int
depth
RegExpFlags
flags
)
override
;
void
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
override
{
on_success_
-
>
FillInBMInfo
(
isolate
offset
budget
-
1
bm
not_at_start
)
;
if
(
offset
=
=
0
)
set_bm_info
(
not_at_start
bm
)
;
}
protected
:
RegExpNode
*
FilterSuccessor
(
int
depth
RegExpFlags
flags
)
;
private
:
RegExpNode
*
on_success_
;
}
;
class
ActionNode
:
public
SeqRegExpNode
{
public
:
enum
ActionType
{
SET_REGISTER_FOR_LOOP
INCREMENT_REGISTER
STORE_POSITION
BEGIN_POSITIVE_SUBMATCH
BEGIN_NEGATIVE_SUBMATCH
POSITIVE_SUBMATCH_SUCCESS
EMPTY_MATCH_CHECK
CLEAR_CAPTURES
}
;
static
ActionNode
*
SetRegisterForLoop
(
int
reg
int
val
RegExpNode
*
on_success
)
;
static
ActionNode
*
IncrementRegister
(
int
reg
RegExpNode
*
on_success
)
;
static
ActionNode
*
StorePosition
(
int
reg
bool
is_capture
RegExpNode
*
on_success
)
;
static
ActionNode
*
ClearCaptures
(
Interval
range
RegExpNode
*
on_success
)
;
static
ActionNode
*
BeginPositiveSubmatch
(
int
stack_pointer_reg
int
position_reg
RegExpNode
*
on_success
)
;
static
ActionNode
*
BeginNegativeSubmatch
(
int
stack_pointer_reg
int
position_reg
RegExpNode
*
on_success
)
;
static
ActionNode
*
PositiveSubmatchSuccess
(
int
stack_pointer_reg
int
restore_reg
int
clear_capture_count
int
clear_capture_from
RegExpNode
*
on_success
)
;
static
ActionNode
*
EmptyMatchCheck
(
int
start_register
int
repetition_register
int
repetition_limit
RegExpNode
*
on_success
)
;
void
Accept
(
NodeVisitor
*
visitor
)
override
;
void
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
override
;
void
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
filled_in
bool
not_at_start
)
override
;
void
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
override
;
ActionType
action_type
(
)
{
return
action_type_
;
}
int
GreedyLoopTextLength
(
)
override
{
return
kNodeIsTooComplexForGreedyLoops
;
}
private
:
union
{
struct
{
int
reg
;
int
value
;
}
u_store_register
;
struct
{
int
reg
;
}
u_increment_register
;
struct
{
int
reg
;
bool
is_capture
;
}
u_position_register
;
struct
{
int
stack_pointer_register
;
int
current_position_register
;
int
clear_register_count
;
int
clear_register_from
;
}
u_submatch
;
struct
{
int
start_register
;
int
repetition_register
;
int
repetition_limit
;
}
u_empty_match_check
;
struct
{
int
range_from
;
int
range_to
;
}
u_clear_captures
;
}
data_
;
ActionNode
(
ActionType
action_type
RegExpNode
*
on_success
)
:
SeqRegExpNode
(
on_success
)
action_type_
(
action_type
)
{
}
ActionType
action_type_
;
friend
class
DotPrinterImpl
;
friend
Zone
;
}
;
class
TextNode
:
public
SeqRegExpNode
{
public
:
TextNode
(
ZoneList
<
TextElement
>
*
elms
bool
read_backward
RegExpNode
*
on_success
)
:
SeqRegExpNode
(
on_success
)
elms_
(
elms
)
read_backward_
(
read_backward
)
{
}
TextNode
(
RegExpCharacterClass
*
that
bool
read_backward
RegExpNode
*
on_success
)
:
SeqRegExpNode
(
on_success
)
elms_
(
zone
(
)
-
>
New
<
ZoneList
<
TextElement
>
>
(
1
zone
(
)
)
)
read_backward_
(
read_backward
)
{
elms_
-
>
Add
(
TextElement
:
:
CharClass
(
that
)
zone
(
)
)
;
}
static
TextNode
*
CreateForCharacterRanges
(
Zone
*
zone
ZoneList
<
CharacterRange
>
*
ranges
bool
read_backward
RegExpNode
*
on_success
)
;
static
TextNode
*
CreateForSurrogatePair
(
Zone
*
zone
CharacterRange
lead
ZoneList
<
CharacterRange
>
*
trail_ranges
bool
read_backward
RegExpNode
*
on_success
)
;
static
TextNode
*
CreateForSurrogatePair
(
Zone
*
zone
ZoneList
<
CharacterRange
>
*
lead_ranges
CharacterRange
trail
bool
read_backward
RegExpNode
*
on_success
)
;
void
Accept
(
NodeVisitor
*
visitor
)
override
;
void
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
override
;
void
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
override
;
ZoneList
<
TextElement
>
*
elements
(
)
{
return
elms_
;
}
bool
read_backward
(
)
{
return
read_backward_
;
}
void
MakeCaseIndependent
(
Isolate
*
isolate
bool
is_one_byte
RegExpFlags
flags
)
;
int
GreedyLoopTextLength
(
)
override
;
RegExpNode
*
GetSuccessorOfOmnivorousTextNode
(
RegExpCompiler
*
compiler
)
override
;
void
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
override
;
void
CalculateOffsets
(
)
;
RegExpNode
*
FilterOneByte
(
int
depth
RegExpFlags
flags
)
override
;
int
Length
(
)
;
private
:
enum
TextEmitPassType
{
NON_LATIN1_MATCH
SIMPLE_CHARACTER_MATCH
NON_LETTER_CHARACTER_MATCH
CASE_CHARACTER_MATCH
CHARACTER_CLASS_MATCH
}
;
static
bool
SkipPass
(
TextEmitPassType
pass
bool
ignore_case
)
;
static
const
int
kFirstRealPass
=
SIMPLE_CHARACTER_MATCH
;
static
const
int
kLastPass
=
CHARACTER_CLASS_MATCH
;
void
TextEmitPass
(
RegExpCompiler
*
compiler
TextEmitPassType
pass
bool
preloaded
Trace
*
trace
bool
first_element_checked
int
*
checked_up_to
)
;
ZoneList
<
TextElement
>
*
elms_
;
bool
read_backward_
;
}
;
class
AssertionNode
:
public
SeqRegExpNode
{
public
:
enum
AssertionType
{
AT_END
AT_START
AT_BOUNDARY
AT_NON_BOUNDARY
AFTER_NEWLINE
}
;
static
AssertionNode
*
AtEnd
(
RegExpNode
*
on_success
)
{
return
on_success
-
>
zone
(
)
-
>
New
<
AssertionNode
>
(
AT_END
on_success
)
;
}
static
AssertionNode
*
AtStart
(
RegExpNode
*
on_success
)
{
return
on_success
-
>
zone
(
)
-
>
New
<
AssertionNode
>
(
AT_START
on_success
)
;
}
static
AssertionNode
*
AtBoundary
(
RegExpNode
*
on_success
)
{
return
on_success
-
>
zone
(
)
-
>
New
<
AssertionNode
>
(
AT_BOUNDARY
on_success
)
;
}
static
AssertionNode
*
AtNonBoundary
(
RegExpNode
*
on_success
)
{
return
on_success
-
>
zone
(
)
-
>
New
<
AssertionNode
>
(
AT_NON_BOUNDARY
on_success
)
;
}
static
AssertionNode
*
AfterNewline
(
RegExpNode
*
on_success
)
{
return
on_success
-
>
zone
(
)
-
>
New
<
AssertionNode
>
(
AFTER_NEWLINE
on_success
)
;
}
void
Accept
(
NodeVisitor
*
visitor
)
override
;
void
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
override
;
void
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
filled_in
bool
not_at_start
)
override
;
void
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
override
;
AssertionType
assertion_type
(
)
{
return
assertion_type_
;
}
private
:
friend
Zone
;
void
EmitBoundaryCheck
(
RegExpCompiler
*
compiler
Trace
*
trace
)
;
enum
IfPrevious
{
kIsNonWord
kIsWord
}
;
void
BacktrackIfPrevious
(
RegExpCompiler
*
compiler
Trace
*
trace
IfPrevious
backtrack_if_previous
)
;
AssertionNode
(
AssertionType
t
RegExpNode
*
on_success
)
:
SeqRegExpNode
(
on_success
)
assertion_type_
(
t
)
{
}
AssertionType
assertion_type_
;
}
;
class
BackReferenceNode
:
public
SeqRegExpNode
{
public
:
BackReferenceNode
(
int
start_reg
int
end_reg
RegExpFlags
flags
bool
read_backward
RegExpNode
*
on_success
)
:
SeqRegExpNode
(
on_success
)
start_reg_
(
start_reg
)
end_reg_
(
end_reg
)
flags_
(
flags
)
read_backward_
(
read_backward
)
{
}
void
Accept
(
NodeVisitor
*
visitor
)
override
;
int
start_register
(
)
{
return
start_reg_
;
}
int
end_register
(
)
{
return
end_reg_
;
}
bool
read_backward
(
)
{
return
read_backward_
;
}
void
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
override
;
void
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
override
{
return
;
}
void
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
override
;
private
:
int
start_reg_
;
int
end_reg_
;
RegExpFlags
flags_
;
bool
read_backward_
;
}
;
class
EndNode
:
public
RegExpNode
{
public
:
enum
Action
{
ACCEPT
BACKTRACK
NEGATIVE_SUBMATCH_SUCCESS
}
;
EndNode
(
Action
action
Zone
*
zone
)
:
RegExpNode
(
zone
)
action_
(
action
)
{
}
void
Accept
(
NodeVisitor
*
visitor
)
override
;
void
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
override
;
void
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
override
{
UNREACHABLE
(
)
;
}
void
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
override
{
UNREACHABLE
(
)
;
}
private
:
Action
action_
;
}
;
class
NegativeSubmatchSuccess
:
public
EndNode
{
public
:
NegativeSubmatchSuccess
(
int
stack_pointer_reg
int
position_reg
int
clear_capture_count
int
clear_capture_start
Zone
*
zone
)
:
EndNode
(
NEGATIVE_SUBMATCH_SUCCESS
zone
)
stack_pointer_register_
(
stack_pointer_reg
)
current_position_register_
(
position_reg
)
clear_capture_count_
(
clear_capture_count
)
clear_capture_start_
(
clear_capture_start
)
{
}
void
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
override
;
private
:
int
stack_pointer_register_
;
int
current_position_register_
;
int
clear_capture_count_
;
int
clear_capture_start_
;
}
;
class
Guard
:
public
ZoneObject
{
public
:
enum
Relation
{
LT
GEQ
}
;
Guard
(
int
reg
Relation
op
int
value
)
:
reg_
(
reg
)
op_
(
op
)
value_
(
value
)
{
}
int
reg
(
)
{
return
reg_
;
}
Relation
op
(
)
{
return
op_
;
}
int
value
(
)
{
return
value_
;
}
private
:
int
reg_
;
Relation
op_
;
int
value_
;
}
;
class
GuardedAlternative
{
public
:
explicit
GuardedAlternative
(
RegExpNode
*
node
)
:
node_
(
node
)
guards_
(
nullptr
)
{
}
void
AddGuard
(
Guard
*
guard
Zone
*
zone
)
;
RegExpNode
*
node
(
)
{
return
node_
;
}
void
set_node
(
RegExpNode
*
node
)
{
node_
=
node
;
}
ZoneList
<
Guard
*
>
*
guards
(
)
{
return
guards_
;
}
private
:
RegExpNode
*
node_
;
ZoneList
<
Guard
*
>
*
guards_
;
}
;
class
AlternativeGeneration
;
class
ChoiceNode
:
public
RegExpNode
{
public
:
explicit
ChoiceNode
(
int
expected_size
Zone
*
zone
)
:
RegExpNode
(
zone
)
alternatives_
(
zone
-
>
New
<
ZoneList
<
GuardedAlternative
>
>
(
expected_size
zone
)
)
not_at_start_
(
false
)
being_calculated_
(
false
)
{
}
void
Accept
(
NodeVisitor
*
visitor
)
override
;
void
AddAlternative
(
GuardedAlternative
node
)
{
alternatives
(
)
-
>
Add
(
node
zone
(
)
)
;
}
ZoneList
<
GuardedAlternative
>
*
alternatives
(
)
{
return
alternatives_
;
}
void
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
override
;
void
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
override
;
void
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
override
;
bool
being_calculated
(
)
{
return
being_calculated_
;
}
bool
not_at_start
(
)
{
return
not_at_start_
;
}
void
set_not_at_start
(
)
{
not_at_start_
=
true
;
}
void
set_being_calculated
(
bool
b
)
{
being_calculated_
=
b
;
}
virtual
bool
try_to_emit_quick_check_for_alternative
(
bool
is_first
)
{
return
true
;
}
RegExpNode
*
FilterOneByte
(
int
depth
RegExpFlags
flags
)
override
;
virtual
bool
read_backward
(
)
{
return
false
;
}
protected
:
int
GreedyLoopTextLengthForAlternative
(
GuardedAlternative
*
alternative
)
;
ZoneList
<
GuardedAlternative
>
*
alternatives_
;
private
:
template
<
typename
.
.
.
>
friend
class
Analysis
;
void
GenerateGuard
(
RegExpMacroAssembler
*
macro_assembler
Guard
*
guard
Trace
*
trace
)
;
int
CalculatePreloadCharacters
(
RegExpCompiler
*
compiler
int
eats_at_least
)
;
void
EmitOutOfLineContinuation
(
RegExpCompiler
*
compiler
Trace
*
trace
GuardedAlternative
alternative
AlternativeGeneration
*
alt_gen
int
preload_characters
bool
next_expects_preload
)
;
void
SetUpPreLoad
(
RegExpCompiler
*
compiler
Trace
*
current_trace
PreloadState
*
preloads
)
;
void
AssertGuardsMentionRegisters
(
Trace
*
trace
)
;
int
EmitOptimizedUnanchoredSearch
(
RegExpCompiler
*
compiler
Trace
*
trace
)
;
Trace
*
EmitGreedyLoop
(
RegExpCompiler
*
compiler
Trace
*
trace
AlternativeGenerationList
*
alt_gens
PreloadState
*
preloads
GreedyLoopState
*
greedy_loop_state
int
text_length
)
;
void
EmitChoices
(
RegExpCompiler
*
compiler
AlternativeGenerationList
*
alt_gens
int
first_choice
Trace
*
trace
PreloadState
*
preloads
)
;
bool
not_at_start_
;
bool
being_calculated_
;
}
;
class
NegativeLookaroundChoiceNode
:
public
ChoiceNode
{
public
:
explicit
NegativeLookaroundChoiceNode
(
GuardedAlternative
this_must_fail
GuardedAlternative
then_do_this
Zone
*
zone
)
:
ChoiceNode
(
2
zone
)
{
AddAlternative
(
this_must_fail
)
;
AddAlternative
(
then_do_this
)
;
}
void
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
override
;
void
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
override
{
continue_node
(
)
-
>
FillInBMInfo
(
isolate
offset
budget
-
1
bm
not_at_start
)
;
if
(
offset
=
=
0
)
set_bm_info
(
not_at_start
bm
)
;
}
static
constexpr
int
kLookaroundIndex
=
0
;
static
constexpr
int
kContinueIndex
=
1
;
RegExpNode
*
lookaround_node
(
)
{
return
alternatives
(
)
-
>
at
(
kLookaroundIndex
)
.
node
(
)
;
}
RegExpNode
*
continue_node
(
)
{
return
alternatives
(
)
-
>
at
(
kContinueIndex
)
.
node
(
)
;
}
bool
try_to_emit_quick_check_for_alternative
(
bool
is_first
)
override
{
return
!
is_first
;
}
void
Accept
(
NodeVisitor
*
visitor
)
override
;
RegExpNode
*
FilterOneByte
(
int
depth
RegExpFlags
flags
)
override
;
}
;
class
LoopChoiceNode
:
public
ChoiceNode
{
public
:
LoopChoiceNode
(
bool
body_can_be_zero_length
bool
read_backward
int
min_loop_iterations
Zone
*
zone
)
:
ChoiceNode
(
2
zone
)
loop_node_
(
nullptr
)
continue_node_
(
nullptr
)
body_can_be_zero_length_
(
body_can_be_zero_length
)
read_backward_
(
read_backward
)
traversed_loop_initialization_node_
(
false
)
min_loop_iterations_
(
min_loop_iterations
)
{
}
void
AddLoopAlternative
(
GuardedAlternative
alt
)
;
void
AddContinueAlternative
(
GuardedAlternative
alt
)
;
void
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
override
;
void
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
override
;
void
GetQuickCheckDetailsFromLoopEntry
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
override
;
void
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
override
;
EatsAtLeastInfo
EatsAtLeastFromLoopEntry
(
)
override
;
RegExpNode
*
loop_node
(
)
{
return
loop_node_
;
}
RegExpNode
*
continue_node
(
)
{
return
continue_node_
;
}
bool
body_can_be_zero_length
(
)
{
return
body_can_be_zero_length_
;
}
int
min_loop_iterations
(
)
const
{
return
min_loop_iterations_
;
}
bool
read_backward
(
)
override
{
return
read_backward_
;
}
void
Accept
(
NodeVisitor
*
visitor
)
override
;
RegExpNode
*
FilterOneByte
(
int
depth
RegExpFlags
flags
)
override
;
private
:
void
AddAlternative
(
GuardedAlternative
node
)
{
ChoiceNode
:
:
AddAlternative
(
node
)
;
}
RegExpNode
*
loop_node_
;
RegExpNode
*
continue_node_
;
bool
body_can_be_zero_length_
;
bool
read_backward_
;
bool
traversed_loop_initialization_node_
;
int
min_loop_iterations_
;
friend
class
IterationDecrementer
;
friend
class
LoopInitializationMarker
;
}
;
class
NodeVisitor
{
public
:
virtual
~
NodeVisitor
(
)
=
default
;
#
define
DECLARE_VISIT
(
Type
)
virtual
void
Visit
#
#
Type
(
Type
#
#
Node
*
that
)
=
0
;
FOR_EACH_NODE_TYPE
(
DECLARE_VISIT
)
#
undef
DECLARE_VISIT
}
;
}
}
#
endif
