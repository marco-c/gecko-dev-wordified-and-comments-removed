#
include
"
irregexp
/
imported
/
regexp
-
stack
.
h
"
namespace
v8
{
namespace
internal
{
RegExpStackScope
:
:
RegExpStackScope
(
Isolate
*
isolate
)
:
regexp_stack_
(
isolate
-
>
regexp_stack
(
)
)
old_sp_top_delta_
(
regexp_stack_
-
>
sp_top_delta
(
)
)
{
DCHECK
(
regexp_stack_
-
>
IsValid
(
)
)
;
}
RegExpStackScope
:
:
~
RegExpStackScope
(
)
{
CHECK_EQ
(
old_sp_top_delta_
regexp_stack_
-
>
sp_top_delta
(
)
)
;
regexp_stack_
-
>
ResetIfEmpty
(
)
;
}
RegExpStack
:
:
RegExpStack
(
)
:
thread_local_
(
this
)
{
}
RegExpStack
:
:
~
RegExpStack
(
)
{
thread_local_
.
FreeAndInvalidate
(
)
;
}
char
*
RegExpStack
:
:
ArchiveStack
(
char
*
to
)
{
if
(
!
thread_local_
.
owns_memory_
)
{
EnsureCapacity
(
thread_local_
.
memory_size_
+
1
)
;
DCHECK
(
thread_local_
.
owns_memory_
)
;
}
MemCopy
(
reinterpret_cast
<
void
*
>
(
to
)
&
thread_local_
kThreadLocalSize
)
;
thread_local_
=
ThreadLocal
(
this
)
;
return
to
+
kThreadLocalSize
;
}
char
*
RegExpStack
:
:
RestoreStack
(
char
*
from
)
{
MemCopy
(
&
thread_local_
reinterpret_cast
<
void
*
>
(
from
)
kThreadLocalSize
)
;
return
from
+
kThreadLocalSize
;
}
void
RegExpStack
:
:
ThreadLocal
:
:
ResetToStaticStack
(
RegExpStack
*
regexp_stack
)
{
if
(
owns_memory_
)
DeleteArray
(
memory_
)
;
memory_
=
regexp_stack
-
>
static_stack_
;
memory_top_
=
regexp_stack
-
>
static_stack_
+
kStaticStackSize
;
memory_size_
=
kStaticStackSize
;
stack_pointer_
=
memory_top_
;
limit_
=
reinterpret_cast
<
Address
>
(
regexp_stack
-
>
static_stack_
)
+
kStackLimitSlack
*
kSystemPointerSize
;
owns_memory_
=
false
;
}
void
RegExpStack
:
:
ThreadLocal
:
:
FreeAndInvalidate
(
)
{
if
(
owns_memory_
)
DeleteArray
(
memory_
)
;
memory_
=
nullptr
;
memory_top_
=
nullptr
;
memory_size_
=
0
;
stack_pointer_
=
nullptr
;
limit_
=
kMemoryTop
;
}
Address
RegExpStack
:
:
EnsureCapacity
(
size_t
size
)
{
if
(
size
>
kMaximumStackSize
)
return
kNullAddress
;
if
(
thread_local_
.
memory_size_
<
size
)
{
if
(
size
<
kMinimumDynamicStackSize
)
size
=
kMinimumDynamicStackSize
;
byte
*
new_memory
=
NewArray
<
byte
>
(
size
)
;
if
(
thread_local_
.
memory_size_
>
0
)
{
MemCopy
(
new_memory
+
size
-
thread_local_
.
memory_size_
thread_local_
.
memory_
thread_local_
.
memory_size_
)
;
if
(
thread_local_
.
owns_memory_
)
DeleteArray
(
thread_local_
.
memory_
)
;
}
ptrdiff_t
delta
=
sp_top_delta
(
)
;
thread_local_
.
memory_
=
new_memory
;
thread_local_
.
memory_top_
=
new_memory
+
size
;
thread_local_
.
memory_size_
=
size
;
thread_local_
.
stack_pointer_
=
thread_local_
.
memory_top_
+
delta
;
thread_local_
.
limit_
=
reinterpret_cast
<
Address
>
(
new_memory
)
+
kStackLimitSlack
*
kSystemPointerSize
;
thread_local_
.
owns_memory_
=
true
;
}
return
reinterpret_cast
<
Address
>
(
thread_local_
.
memory_top_
)
;
}
}
}
