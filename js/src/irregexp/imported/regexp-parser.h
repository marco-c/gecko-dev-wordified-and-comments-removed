#
ifndef
V8_REGEXP_REGEXP_PARSER_H_
#
define
V8_REGEXP_REGEXP_PARSER_H_
#
include
"
irregexp
/
imported
/
regexp
-
ast
.
h
"
#
include
"
irregexp
/
imported
/
regexp
-
error
.
h
"
namespace
v8
{
namespace
internal
{
struct
RegExpCompileData
;
template
<
typename
T
int
initial_size
>
class
BufferedZoneList
{
public
:
BufferedZoneList
(
)
:
list_
(
nullptr
)
last_
(
nullptr
)
{
}
void
Add
(
T
*
value
Zone
*
zone
)
{
if
(
last_
!
=
nullptr
)
{
if
(
list_
=
=
nullptr
)
{
list_
=
zone
-
>
New
<
ZoneList
<
T
*
>
>
(
initial_size
zone
)
;
}
list_
-
>
Add
(
last_
zone
)
;
}
last_
=
value
;
}
T
*
last
(
)
{
DCHECK
(
last_
!
=
nullptr
)
;
return
last_
;
}
T
*
RemoveLast
(
)
{
DCHECK
(
last_
!
=
nullptr
)
;
T
*
result
=
last_
;
if
(
(
list_
!
=
nullptr
)
&
&
(
list_
-
>
length
(
)
>
0
)
)
last_
=
list_
-
>
RemoveLast
(
)
;
else
last_
=
nullptr
;
return
result
;
}
T
*
Get
(
int
i
)
{
DCHECK
(
(
0
<
=
i
)
&
&
(
i
<
length
(
)
)
)
;
if
(
list_
=
=
nullptr
)
{
DCHECK_EQ
(
0
i
)
;
return
last_
;
}
else
{
if
(
i
=
=
list_
-
>
length
(
)
)
{
DCHECK
(
last_
!
=
nullptr
)
;
return
last_
;
}
else
{
return
list_
-
>
at
(
i
)
;
}
}
}
void
Clear
(
)
{
list_
=
nullptr
;
last_
=
nullptr
;
}
int
length
(
)
{
int
length
=
(
list_
=
=
nullptr
)
?
0
:
list_
-
>
length
(
)
;
return
length
+
(
(
last_
=
=
nullptr
)
?
0
:
1
)
;
}
ZoneList
<
T
*
>
*
GetList
(
Zone
*
zone
)
{
if
(
list_
=
=
nullptr
)
{
list_
=
zone
-
>
New
<
ZoneList
<
T
*
>
>
(
initial_size
zone
)
;
}
if
(
last_
!
=
nullptr
)
{
list_
-
>
Add
(
last_
zone
)
;
last_
=
nullptr
;
}
return
list_
;
}
private
:
ZoneList
<
T
*
>
*
list_
;
T
*
last_
;
}
;
class
RegExpBuilder
:
public
ZoneObject
{
public
:
RegExpBuilder
(
Zone
*
zone
JSRegExp
:
:
Flags
flags
)
;
void
AddCharacter
(
uc16
character
)
;
void
AddUnicodeCharacter
(
uc32
character
)
;
void
AddEscapedUnicodeCharacter
(
uc32
character
)
;
void
AddEmpty
(
)
;
void
AddCharacterClass
(
RegExpCharacterClass
*
cc
)
;
void
AddCharacterClassForDesugaring
(
uc32
c
)
;
void
AddAtom
(
RegExpTree
*
tree
)
;
void
AddTerm
(
RegExpTree
*
tree
)
;
void
AddAssertion
(
RegExpTree
*
tree
)
;
void
NewAlternative
(
)
;
bool
AddQuantifierToAtom
(
int
min
int
max
RegExpQuantifier
:
:
QuantifierType
type
)
;
void
FlushText
(
)
;
RegExpTree
*
ToRegExp
(
)
;
JSRegExp
:
:
Flags
flags
(
)
const
{
return
flags_
;
}
void
set_flags
(
JSRegExp
:
:
Flags
flags
)
{
flags_
=
flags
;
}
bool
ignore_case
(
)
const
{
return
(
flags_
&
JSRegExp
:
:
kIgnoreCase
)
!
=
0
;
}
bool
multiline
(
)
const
{
return
(
flags_
&
JSRegExp
:
:
kMultiline
)
!
=
0
;
}
bool
dotall
(
)
const
{
return
(
flags_
&
JSRegExp
:
:
kDotAll
)
!
=
0
;
}
private
:
static
const
uc16
kNoPendingSurrogate
=
0
;
void
AddLeadSurrogate
(
uc16
lead_surrogate
)
;
void
AddTrailSurrogate
(
uc16
trail_surrogate
)
;
void
FlushPendingSurrogate
(
)
;
void
FlushCharacters
(
)
;
void
FlushTerms
(
)
;
bool
NeedsDesugaringForUnicode
(
RegExpCharacterClass
*
cc
)
;
bool
NeedsDesugaringForIgnoreCase
(
uc32
c
)
;
Zone
*
zone
(
)
const
{
return
zone_
;
}
bool
unicode
(
)
const
{
return
(
flags_
&
JSRegExp
:
:
kUnicode
)
!
=
0
;
}
Zone
*
zone_
;
bool
pending_empty_
;
JSRegExp
:
:
Flags
flags_
;
ZoneList
<
uc16
>
*
characters_
;
uc16
pending_surrogate_
;
BufferedZoneList
<
RegExpTree
2
>
terms_
;
BufferedZoneList
<
RegExpTree
2
>
text_
;
BufferedZoneList
<
RegExpTree
2
>
alternatives_
;
#
ifdef
DEBUG
enum
{
ADD_NONE
ADD_CHAR
ADD_TERM
ADD_ASSERT
ADD_ATOM
}
last_added_
;
#
define
LAST
(
x
)
last_added_
=
x
;
#
else
#
define
LAST
(
x
)
#
endif
}
;
class
V8_EXPORT_PRIVATE
RegExpParser
{
public
:
RegExpParser
(
FlatStringReader
*
in
JSRegExp
:
:
Flags
flags
Isolate
*
isolate
Zone
*
zone
)
;
static
bool
ParseRegExp
(
Isolate
*
isolate
Zone
*
zone
FlatStringReader
*
input
JSRegExp
:
:
Flags
flags
RegExpCompileData
*
result
)
;
static
bool
VerifyRegExpSyntax
(
Isolate
*
isolate
Zone
*
zone
FlatStringReader
*
input
JSRegExp
:
:
Flags
flags
RegExpCompileData
*
result
const
DisallowGarbageCollection
&
nogc
)
;
private
:
bool
Parse
(
RegExpCompileData
*
result
const
DisallowGarbageCollection
&
)
;
RegExpTree
*
ParsePattern
(
)
;
RegExpTree
*
ParseDisjunction
(
)
;
RegExpTree
*
ParseGroup
(
)
;
bool
ParseIntervalQuantifier
(
int
*
min_out
int
*
max_out
)
;
uc32
ParseClassCharacterEscape
(
)
;
bool
ParseHexEscape
(
int
length
uc32
*
value
)
;
bool
ParseUnicodeEscape
(
uc32
*
value
)
;
bool
ParseUnlimitedLengthHexNumber
(
int
max_value
uc32
*
value
)
;
bool
ParsePropertyClassName
(
ZoneVector
<
char
>
*
name_1
ZoneVector
<
char
>
*
name_2
)
;
bool
AddPropertyClassRange
(
ZoneList
<
CharacterRange
>
*
add_to
bool
negate
const
ZoneVector
<
char
>
&
name_1
const
ZoneVector
<
char
>
&
name_2
)
;
RegExpTree
*
GetPropertySequence
(
const
ZoneVector
<
char
>
&
name_1
)
;
RegExpTree
*
ParseCharacterClass
(
const
RegExpBuilder
*
state
)
;
uc32
ParseOctalLiteral
(
)
;
bool
ParseBackReferenceIndex
(
int
*
index_out
)
;
void
ParseClassEscape
(
ZoneList
<
CharacterRange
>
*
ranges
Zone
*
zone
bool
add_unicode_case_equivalents
uc32
*
char_out
bool
*
is_class_escape
)
;
char
ParseClassEscape
(
)
;
RegExpTree
*
ReportError
(
RegExpError
error
)
;
void
Advance
(
)
;
void
Advance
(
int
dist
)
;
void
Reset
(
int
pos
)
;
bool
simple
(
)
;
bool
contains_anchor
(
)
{
return
contains_anchor_
;
}
void
set_contains_anchor
(
)
{
contains_anchor_
=
true
;
}
int
captures_started
(
)
{
return
captures_started_
;
}
int
position
(
)
{
return
next_pos_
-
1
;
}
bool
failed
(
)
{
return
failed_
;
}
bool
unicode
(
)
const
{
return
(
top_level_flags_
&
JSRegExp
:
:
kUnicode
)
!
=
0
;
}
static
bool
IsSyntaxCharacterOrSlash
(
uc32
c
)
;
static
const
uc32
kEndMarker
=
(
1
<
<
21
)
;
private
:
enum
SubexpressionType
{
INITIAL
CAPTURE
POSITIVE_LOOKAROUND
NEGATIVE_LOOKAROUND
GROUPING
}
;
class
RegExpParserState
:
public
ZoneObject
{
public
:
RegExpParserState
(
RegExpParserState
*
previous_state
SubexpressionType
group_type
RegExpLookaround
:
:
Type
lookaround_type
int
disjunction_capture_index
const
ZoneVector
<
uc16
>
*
capture_name
JSRegExp
:
:
Flags
flags
Zone
*
zone
)
:
previous_state_
(
previous_state
)
builder_
(
zone
-
>
New
<
RegExpBuilder
>
(
zone
flags
)
)
group_type_
(
group_type
)
lookaround_type_
(
lookaround_type
)
disjunction_capture_index_
(
disjunction_capture_index
)
capture_name_
(
capture_name
)
{
}
RegExpParserState
*
previous_state
(
)
const
{
return
previous_state_
;
}
bool
IsSubexpression
(
)
{
return
previous_state_
!
=
nullptr
;
}
RegExpBuilder
*
builder
(
)
const
{
return
builder_
;
}
SubexpressionType
group_type
(
)
const
{
return
group_type_
;
}
RegExpLookaround
:
:
Type
lookaround_type
(
)
const
{
return
lookaround_type_
;
}
int
capture_index
(
)
const
{
return
disjunction_capture_index_
;
}
const
ZoneVector
<
uc16
>
*
capture_name
(
)
const
{
return
capture_name_
;
}
bool
IsNamedCapture
(
)
const
{
return
capture_name_
!
=
nullptr
;
}
bool
IsInsideCaptureGroup
(
int
index
)
;
bool
IsInsideCaptureGroup
(
const
ZoneVector
<
uc16
>
*
name
)
;
private
:
RegExpParserState
*
const
previous_state_
;
RegExpBuilder
*
const
builder_
;
const
SubexpressionType
group_type_
;
const
RegExpLookaround
:
:
Type
lookaround_type_
;
const
int
disjunction_capture_index_
;
const
ZoneVector
<
uc16
>
*
const
capture_name_
;
}
;
RegExpCapture
*
GetCapture
(
int
index
)
;
bool
CreateNamedCaptureAtIndex
(
const
ZoneVector
<
uc16
>
*
name
int
index
)
;
const
ZoneVector
<
uc16
>
*
ParseCaptureGroupName
(
)
;
bool
ParseNamedBackReference
(
RegExpBuilder
*
builder
RegExpParserState
*
state
)
;
RegExpParserState
*
ParseOpenParenthesis
(
RegExpParserState
*
state
)
;
void
PatchNamedBackReferences
(
)
;
Handle
<
FixedArray
>
CreateCaptureNameMap
(
)
;
bool
HasNamedCaptures
(
)
;
Isolate
*
isolate
(
)
{
return
isolate_
;
}
Zone
*
zone
(
)
const
{
return
zone_
;
}
uc32
current
(
)
{
return
current_
;
}
bool
has_more
(
)
{
return
has_more_
;
}
bool
has_next
(
)
{
return
next_pos_
<
in
(
)
-
>
length
(
)
;
}
uc32
Next
(
)
;
template
<
bool
update_position
>
uc32
ReadNext
(
)
;
FlatStringReader
*
in
(
)
{
return
in_
;
}
void
ScanForCaptures
(
)
;
struct
RegExpCaptureNameLess
{
bool
operator
(
)
(
const
RegExpCapture
*
lhs
const
RegExpCapture
*
rhs
)
const
{
DCHECK_NOT_NULL
(
lhs
)
;
DCHECK_NOT_NULL
(
rhs
)
;
return
*
lhs
-
>
name
(
)
<
*
rhs
-
>
name
(
)
;
}
}
;
Isolate
*
isolate_
;
Zone
*
zone_
;
RegExpError
error_
=
RegExpError
:
:
kNone
;
int
error_pos_
=
0
;
ZoneList
<
RegExpCapture
*
>
*
captures_
;
ZoneSet
<
RegExpCapture
*
RegExpCaptureNameLess
>
*
named_captures_
;
ZoneList
<
RegExpBackReference
*
>
*
named_back_references_
;
FlatStringReader
*
in_
;
uc32
current_
;
JSRegExp
:
:
Flags
top_level_flags_
;
int
next_pos_
;
int
captures_started_
;
int
capture_count_
;
bool
has_more_
;
bool
simple_
;
bool
contains_anchor_
;
bool
is_scanned_for_captures_
;
bool
has_named_captures_
;
bool
failed_
;
}
;
}
}
#
endif
