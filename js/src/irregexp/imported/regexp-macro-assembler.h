#
ifndef
V8_REGEXP_REGEXP_MACRO_ASSEMBLER_H_
#
define
V8_REGEXP_REGEXP_MACRO_ASSEMBLER_H_
#
include
"
irregexp
/
imported
/
regexp
-
ast
.
h
"
#
include
"
irregexp
/
imported
/
regexp
.
h
"
#
include
"
irregexp
/
RegExpShim
.
h
"
namespace
v8
{
namespace
internal
{
class
ByteArray
;
class
JSRegExp
;
class
Label
;
class
String
;
static
const
base
:
:
uc32
kLeadSurrogateStart
=
0xd800
;
static
const
base
:
:
uc32
kLeadSurrogateEnd
=
0xdbff
;
static
const
base
:
:
uc32
kTrailSurrogateStart
=
0xdc00
;
static
const
base
:
:
uc32
kTrailSurrogateEnd
=
0xdfff
;
static
const
base
:
:
uc32
kNonBmpStart
=
0x10000
;
static
const
base
:
:
uc32
kNonBmpEnd
=
0x10ffff
;
class
RegExpMacroAssembler
{
public
:
static
constexpr
int
kMaxRegisterCount
=
(
1
<
<
16
)
;
static
constexpr
int
kMaxRegister
=
kMaxRegisterCount
-
1
;
static
constexpr
int
kMaxCaptures
=
(
kMaxRegister
-
1
)
/
2
;
static
constexpr
int
kMaxCPOffset
=
(
1
<
<
15
)
-
1
;
static
constexpr
int
kMinCPOffset
=
-
(
1
<
<
15
)
;
static
constexpr
int
kTableSizeBits
=
7
;
static
constexpr
int
kTableSize
=
1
<
<
kTableSizeBits
;
static
constexpr
int
kTableMask
=
kTableSize
-
1
;
static
constexpr
int
kUseCharactersValue
=
-
1
;
RegExpMacroAssembler
(
Isolate
*
isolate
Zone
*
zone
)
;
virtual
~
RegExpMacroAssembler
(
)
=
default
;
virtual
Handle
<
HeapObject
>
GetCode
(
Handle
<
String
>
source
)
=
0
;
virtual
void
AbortedCodeGeneration
(
)
{
}
virtual
int
stack_limit_slack
(
)
=
0
;
virtual
bool
CanReadUnaligned
(
)
const
=
0
;
virtual
void
AdvanceCurrentPosition
(
int
by
)
=
0
;
virtual
void
AdvanceRegister
(
int
reg
int
by
)
=
0
;
virtual
void
Backtrack
(
)
=
0
;
virtual
void
Bind
(
Label
*
label
)
=
0
;
virtual
void
CheckCharacter
(
unsigned
c
Label
*
on_equal
)
=
0
;
virtual
void
CheckCharacterAfterAnd
(
unsigned
c
unsigned
and_with
Label
*
on_equal
)
=
0
;
virtual
void
CheckCharacterGT
(
base
:
:
uc16
limit
Label
*
on_greater
)
=
0
;
virtual
void
CheckCharacterLT
(
base
:
:
uc16
limit
Label
*
on_less
)
=
0
;
virtual
void
CheckGreedyLoop
(
Label
*
on_tos_equals_current_position
)
=
0
;
virtual
void
CheckAtStart
(
int
cp_offset
Label
*
on_at_start
)
=
0
;
virtual
void
CheckNotAtStart
(
int
cp_offset
Label
*
on_not_at_start
)
=
0
;
virtual
void
CheckNotBackReference
(
int
start_reg
bool
read_backward
Label
*
on_no_match
)
=
0
;
virtual
void
CheckNotBackReferenceIgnoreCase
(
int
start_reg
bool
read_backward
bool
unicode
Label
*
on_no_match
)
=
0
;
virtual
void
CheckNotCharacter
(
unsigned
c
Label
*
on_not_equal
)
=
0
;
virtual
void
CheckNotCharacterAfterAnd
(
unsigned
c
unsigned
and_with
Label
*
on_not_equal
)
=
0
;
virtual
void
CheckNotCharacterAfterMinusAnd
(
base
:
:
uc16
c
base
:
:
uc16
minus
base
:
:
uc16
and_with
Label
*
on_not_equal
)
=
0
;
virtual
void
CheckCharacterInRange
(
base
:
:
uc16
from
base
:
:
uc16
to
Label
*
on_in_range
)
=
0
;
virtual
void
CheckCharacterNotInRange
(
base
:
:
uc16
from
base
:
:
uc16
to
Label
*
on_not_in_range
)
=
0
;
virtual
bool
CheckCharacterInRangeArray
(
const
ZoneList
<
CharacterRange
>
*
ranges
Label
*
on_in_range
)
=
0
;
virtual
bool
CheckCharacterNotInRangeArray
(
const
ZoneList
<
CharacterRange
>
*
ranges
Label
*
on_not_in_range
)
=
0
;
virtual
void
CheckBitInTable
(
Handle
<
ByteArray
>
table
Label
*
on_bit_set
)
=
0
;
virtual
void
CheckPosition
(
int
cp_offset
Label
*
on_outside_input
)
;
virtual
bool
CheckSpecialClassRanges
(
StandardCharacterSet
type
Label
*
on_no_match
)
{
return
false
;
}
virtual
void
BindJumpTarget
(
Label
*
label
)
{
Bind
(
label
)
;
}
virtual
void
Fail
(
)
=
0
;
virtual
void
GoTo
(
Label
*
label
)
=
0
;
virtual
void
IfRegisterGE
(
int
reg
int
comparand
Label
*
if_ge
)
=
0
;
virtual
void
IfRegisterLT
(
int
reg
int
comparand
Label
*
if_lt
)
=
0
;
virtual
void
IfRegisterEqPos
(
int
reg
Label
*
if_eq
)
=
0
;
V8_EXPORT_PRIVATE
void
LoadCurrentCharacter
(
int
cp_offset
Label
*
on_end_of_input
bool
check_bounds
=
true
int
characters
=
1
int
eats_at_least
=
kUseCharactersValue
)
;
virtual
void
LoadCurrentCharacterImpl
(
int
cp_offset
Label
*
on_end_of_input
bool
check_bounds
int
characters
int
eats_at_least
)
=
0
;
virtual
void
PopCurrentPosition
(
)
=
0
;
virtual
void
PopRegister
(
int
register_index
)
=
0
;
virtual
void
PushBacktrack
(
Label
*
label
)
=
0
;
virtual
void
PushCurrentPosition
(
)
=
0
;
enum
StackCheckFlag
{
kNoStackLimitCheck
=
false
kCheckStackLimit
=
true
}
;
virtual
void
PushRegister
(
int
register_index
StackCheckFlag
check_stack_limit
)
=
0
;
virtual
void
ReadCurrentPositionFromRegister
(
int
reg
)
=
0
;
virtual
void
ReadStackPointerFromRegister
(
int
reg
)
=
0
;
virtual
void
SetCurrentPositionFromEnd
(
int
by
)
=
0
;
virtual
void
SetRegister
(
int
register_index
int
to
)
=
0
;
virtual
bool
Succeed
(
)
=
0
;
virtual
void
WriteCurrentPositionToRegister
(
int
reg
int
cp_offset
)
=
0
;
virtual
void
ClearRegisters
(
int
reg_from
int
reg_to
)
=
0
;
virtual
void
WriteStackPointerToRegister
(
int
reg
)
=
0
;
void
CheckNotInSurrogatePair
(
int
cp_offset
Label
*
on_failure
)
;
#
define
IMPLEMENTATIONS_LIST
(
V
)
\
V
(
IA32
)
\
V
(
ARM
)
\
V
(
ARM64
)
\
V
(
MIPS
)
\
V
(
LOONG64
)
\
V
(
RISCV
)
\
V
(
RISCV32
)
\
V
(
S390
)
\
V
(
PPC
)
\
V
(
X64
)
\
V
(
Bytecode
)
enum
IrregexpImplementation
{
#
define
V
(
Name
)
k
#
#
Name
#
#
Implementation
IMPLEMENTATIONS_LIST
(
V
)
#
undef
V
}
;
inline
const
char
*
ImplementationToString
(
IrregexpImplementation
impl
)
{
static
const
char
*
const
kNames
[
]
=
{
#
define
V
(
Name
)
#
Name
IMPLEMENTATIONS_LIST
(
V
)
#
undef
V
}
;
return
kNames
[
impl
]
;
}
#
undef
IMPLEMENTATIONS_LIST
virtual
IrregexpImplementation
Implementation
(
)
=
0
;
static
int
CaseInsensitiveCompareNonUnicode
(
Address
byte_offset1
Address
byte_offset2
size_t
byte_length
Isolate
*
isolate
)
;
static
int
CaseInsensitiveCompareUnicode
(
Address
byte_offset1
Address
byte_offset2
size_t
byte_length
Isolate
*
isolate
)
;
static
uint32_t
IsCharacterInRangeArray
(
uint32_t
current_char
Address
raw_byte_array
Isolate
*
isolate
)
;
void
set_slow_safe
(
bool
ssc
)
{
slow_safe_compiler_
=
ssc
;
}
bool
slow_safe
(
)
const
{
return
slow_safe_compiler_
;
}
void
set_backtrack_limit
(
uint32_t
backtrack_limit
)
{
backtrack_limit_
=
backtrack_limit
;
}
void
set_can_fallback
(
bool
val
)
{
can_fallback_
=
val
;
}
enum
GlobalMode
{
NOT_GLOBAL
GLOBAL_NO_ZERO_LENGTH_CHECK
GLOBAL
GLOBAL_UNICODE
}
;
inline
void
set_global_mode
(
GlobalMode
mode
)
{
global_mode_
=
mode
;
}
inline
bool
global
(
)
const
{
return
global_mode_
!
=
NOT_GLOBAL
;
}
inline
bool
global_with_zero_length_check
(
)
const
{
return
global_mode_
=
=
GLOBAL
|
|
global_mode_
=
=
GLOBAL_UNICODE
;
}
inline
bool
global_unicode
(
)
const
{
return
global_mode_
=
=
GLOBAL_UNICODE
;
}
Isolate
*
isolate
(
)
const
{
return
isolate_
;
}
Zone
*
zone
(
)
const
{
return
zone_
;
}
protected
:
bool
has_backtrack_limit
(
)
const
;
uint32_t
backtrack_limit
(
)
const
{
return
backtrack_limit_
;
}
bool
can_fallback
(
)
const
{
return
can_fallback_
;
}
private
:
bool
slow_safe_compiler_
;
uint32_t
backtrack_limit_
;
bool
can_fallback_
=
false
;
GlobalMode
global_mode_
;
Isolate
*
const
isolate_
;
Zone
*
const
zone_
;
}
;
class
NativeRegExpMacroAssembler
:
public
RegExpMacroAssembler
{
public
:
enum
Mode
{
LATIN1
=
1
UC16
=
2
}
;
enum
Result
{
FAILURE
=
RegExp
:
:
kInternalRegExpFailure
SUCCESS
=
RegExp
:
:
kInternalRegExpSuccess
EXCEPTION
=
RegExp
:
:
kInternalRegExpException
RETRY
=
RegExp
:
:
kInternalRegExpRetry
FALLBACK_TO_EXPERIMENTAL
=
RegExp
:
:
kInternalRegExpFallbackToExperimental
SMALLEST_REGEXP_RESULT
=
RegExp
:
:
kInternalRegExpSmallestResult
}
;
NativeRegExpMacroAssembler
(
Isolate
*
isolate
Zone
*
zone
)
:
RegExpMacroAssembler
(
isolate
zone
)
range_array_cache_
(
zone
)
{
}
~
NativeRegExpMacroAssembler
(
)
override
=
default
;
static
int
Match
(
Handle
<
JSRegExp
>
regexp
Handle
<
String
>
subject
int
*
offsets_vector
int
offsets_vector_length
int
previous_index
Isolate
*
isolate
)
;
V8_EXPORT_PRIVATE
static
int
ExecuteForTesting
(
String
input
int
start_offset
const
byte
*
input_start
const
byte
*
input_end
int
*
output
int
output_size
Isolate
*
isolate
JSRegExp
regexp
)
;
bool
CanReadUnaligned
(
)
const
override
;
void
LoadCurrentCharacterImpl
(
int
cp_offset
Label
*
on_end_of_input
bool
check_bounds
int
characters
int
eats_at_least
)
override
;
virtual
void
LoadCurrentCharacterUnchecked
(
int
cp_offset
int
character_count
)
=
0
;
static
Address
GrowStack
(
Isolate
*
isolate
)
;
static
int
CheckStackGuardState
(
Isolate
*
isolate
int
start_index
RegExp
:
:
CallOrigin
call_origin
Address
*
return_address
InstructionStream
re_code
Address
*
subject
const
byte
*
*
input_start
const
byte
*
*
input_end
)
;
static
Address
word_character_map_address
(
)
{
return
reinterpret_cast
<
Address
>
(
&
word_character_map
[
0
]
)
;
}
protected
:
static
const
byte
word_character_map
[
256
]
;
Handle
<
ByteArray
>
GetOrAddRangeArray
(
const
ZoneList
<
CharacterRange
>
*
ranges
)
;
private
:
static
int
Execute
(
String
input
int
start_offset
const
byte
*
input_start
const
byte
*
input_end
int
*
output
int
output_size
Isolate
*
isolate
JSRegExp
regexp
)
;
ZoneUnorderedMap
<
uint32_t
Handle
<
FixedUInt16Array
>
>
range_array_cache_
;
}
;
}
}
#
endif
