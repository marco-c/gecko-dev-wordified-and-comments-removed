#
ifndef
V8_REGEXP_REGEXP_H_
#
define
V8_REGEXP_REGEXP_H_
#
include
"
irregexp
/
imported
/
regexp
-
error
.
h
"
#
include
"
irregexp
/
RegExpShim
.
h
"
namespace
v8
{
namespace
internal
{
class
JSRegExp
;
class
RegExpCapture
;
class
RegExpData
;
class
IrRegExpData
;
class
AtomRegExpData
;
class
RegExpMatchInfo
;
class
RegExpNode
;
class
RegExpTree
;
enum
class
RegExpCompilationTarget
:
int
{
kBytecode
kNative
}
;
struct
RegExpCompileData
{
RegExpTree
*
tree
=
nullptr
;
RegExpNode
*
node
=
nullptr
;
DirectHandle
<
Object
>
code
;
bool
simple
=
true
;
bool
contains_anchor
=
false
;
ZoneVector
<
RegExpCapture
*
>
*
named_captures
=
nullptr
;
RegExpError
error
=
RegExpError
:
:
kNone
;
int
error_pos
=
0
;
int
capture_count
=
0
;
int
register_count
=
0
;
RegExpCompilationTarget
compilation_target
;
}
;
class
RegExp
final
:
public
AllStatic
{
public
:
static
bool
CanGenerateBytecode
(
)
;
V8_EXPORT_PRIVATE
static
bool
VerifyFlags
(
RegExpFlags
flags
)
;
template
<
class
CharT
>
static
bool
VerifySyntax
(
Zone
*
zone
uintptr_t
stack_limit
const
CharT
*
input
int
input_length
RegExpFlags
flags
RegExpError
*
regexp_error_out
const
DisallowGarbageCollection
&
no_gc
)
;
V8_WARN_UNUSED_RESULT
static
MaybeDirectHandle
<
Object
>
Compile
(
Isolate
*
isolate
DirectHandle
<
JSRegExp
>
re
DirectHandle
<
String
>
pattern
RegExpFlags
flags
uint32_t
backtrack_limit
)
;
V8_WARN_UNUSED_RESULT
static
bool
EnsureFullyCompiled
(
Isolate
*
isolate
DirectHandle
<
RegExpData
>
re_data
DirectHandle
<
String
>
subject
)
;
enum
CallOrigin
:
int
{
kFromRuntime
=
0
kFromJs
=
1
}
;
V8_EXPORT_PRIVATE
V8_WARN_UNUSED_RESULT
static
std
:
:
optional
<
int
>
Exec
(
Isolate
*
isolate
DirectHandle
<
JSRegExp
>
regexp
DirectHandle
<
String
>
subject
int
index
int32_t
*
result_offsets_vector
uint32_t
result_offsets_vector_length
)
;
V8_EXPORT_PRIVATE
V8_WARN_UNUSED_RESULT
static
MaybeDirectHandle
<
Object
>
Exec_Single
(
Isolate
*
isolate
DirectHandle
<
JSRegExp
>
regexp
DirectHandle
<
String
>
subject
int
index
DirectHandle
<
RegExpMatchInfo
>
last_match_info
)
;
V8_EXPORT_PRIVATE
V8_WARN_UNUSED_RESULT
static
std
:
:
optional
<
int
>
ExperimentalOneshotExec
(
Isolate
*
isolate
DirectHandle
<
JSRegExp
>
regexp
DirectHandle
<
String
>
subject
int
index
int32_t
*
result_offsets_vector
uint32_t
result_offsets_vector_length
)
;
V8_EXPORT_PRIVATE
static
intptr_t
AtomExecRaw
(
Isolate
*
isolate
Address
data_address
Address
subject_address
int32_t
index
int32_t
*
result_offsets_vector
int32_t
result_offsets_vector_length
)
;
static
constexpr
int
kInternalRegExpFailure
=
0
;
static
constexpr
int
kInternalRegExpSuccess
=
1
;
static
constexpr
int
kInternalRegExpException
=
-
1
;
static
constexpr
int
kInternalRegExpRetry
=
-
2
;
static
constexpr
int
kInternalRegExpFallbackToExperimental
=
-
3
;
static
constexpr
int
kInternalRegExpSmallestResult
=
-
3
;
enum
IrregexpResult
:
int32_t
{
RE_FAILURE
=
kInternalRegExpFailure
RE_SUCCESS
=
kInternalRegExpSuccess
RE_EXCEPTION
=
kInternalRegExpException
RE_RETRY
=
kInternalRegExpRetry
RE_FALLBACK_TO_EXPERIMENTAL
=
kInternalRegExpFallbackToExperimental
}
;
static
DirectHandle
<
RegExpMatchInfo
>
SetLastMatchInfo
(
Isolate
*
isolate
DirectHandle
<
RegExpMatchInfo
>
last_match_info
DirectHandle
<
String
>
subject
int
capture_count
int32_t
*
match
)
;
V8_EXPORT_PRIVATE
static
bool
CompileForTesting
(
Isolate
*
isolate
Zone
*
zone
RegExpCompileData
*
input
RegExpFlags
flags
DirectHandle
<
String
>
pattern
DirectHandle
<
String
>
sample_subject
bool
is_one_byte
)
;
V8_EXPORT_PRIVATE
static
void
DotPrintForTesting
(
const
char
*
label
RegExpNode
*
node
)
;
static
const
int
kRegExpTooLargeToOptimize
=
20
*
KB
;
V8_WARN_UNUSED_RESULT
static
MaybeDirectHandle
<
Object
>
ThrowRegExpException
(
Isolate
*
isolate
RegExpFlags
flags
DirectHandle
<
String
>
pattern
RegExpError
error
)
;
static
void
ThrowRegExpException
(
Isolate
*
isolate
DirectHandle
<
RegExpData
>
re_data
RegExpError
error_text
)
;
static
bool
IsUnmodifiedRegExp
(
Isolate
*
isolate
DirectHandle
<
JSRegExp
>
regexp
)
;
static
DirectHandle
<
FixedArray
>
CreateCaptureNameMap
(
Isolate
*
isolate
ZoneVector
<
RegExpCapture
*
>
*
named_captures
)
;
}
;
class
RegExpGlobalExecRunner
final
{
public
:
RegExpGlobalExecRunner
(
DirectHandle
<
RegExpData
>
regexp_data
DirectHandle
<
String
>
subject
Isolate
*
isolate
)
;
int32_t
*
FetchNext
(
)
;
int32_t
*
LastSuccessfulMatch
(
)
const
;
bool
HasException
(
)
const
{
return
num_matches_
<
0
;
}
private
:
int
AdvanceZeroLength
(
int
last_index
)
const
;
int
max_matches
(
)
const
{
DCHECK_NE
(
register_array_size_
0
)
;
return
register_array_size_
/
registers_per_match_
;
}
RegExpResultVectorScope
result_vector_scope_
;
int
num_matches_
=
0
;
int
current_match_index_
=
0
;
int
registers_per_match_
=
0
;
int32_t
*
register_array_
=
nullptr
;
int
register_array_size_
=
0
;
DirectHandle
<
RegExpData
>
regexp_data_
;
DirectHandle
<
String
>
subject_
;
Isolate
*
const
isolate_
;
}
;
class
RegExpResultsCache
final
:
public
AllStatic
{
public
:
enum
ResultsCacheType
{
REGEXP_MULTIPLE_INDICES
STRING_SPLIT_SUBSTRINGS
}
;
static
Tagged
<
Object
>
Lookup
(
Heap
*
heap
Tagged
<
String
>
key_string
Tagged
<
Object
>
key_pattern
Tagged
<
FixedArray
>
*
last_match_out
ResultsCacheType
type
)
;
static
void
Enter
(
Isolate
*
isolate
DirectHandle
<
String
>
key_string
DirectHandle
<
Object
>
key_pattern
DirectHandle
<
FixedArray
>
value_array
DirectHandle
<
FixedArray
>
last_match_cache
ResultsCacheType
type
)
;
static
void
Clear
(
Tagged
<
FixedArray
>
cache
)
;
static
constexpr
int
kRegExpResultsCacheSize
=
0x100
;
private
:
static
constexpr
int
kStringOffset
=
0
;
static
constexpr
int
kPatternOffset
=
1
;
static
constexpr
int
kArrayOffset
=
2
;
static
constexpr
int
kLastMatchOffset
=
3
;
static
constexpr
int
kArrayEntriesPerCacheEntry
=
4
;
}
;
class
RegExpResultsCache_MatchGlobalAtom
final
:
public
AllStatic
{
public
:
static
void
TryInsert
(
Isolate
*
isolate
Tagged
<
String
>
subject
Tagged
<
String
>
pattern
int
number_of_matches
int
last_match_index
)
;
static
bool
TryGet
(
Isolate
*
isolate
Tagged
<
String
>
subject
Tagged
<
String
>
pattern
int
*
number_of_matches_out
int
*
last_match_index_out
)
;
static
void
Clear
(
Heap
*
heap
)
;
private
:
static
constexpr
int
kSubjectIndex
=
0
;
static
constexpr
int
kPatternIndex
=
1
;
static
constexpr
int
kNumberOfMatchesIndex
=
2
;
static
constexpr
int
kLastMatchIndexIndex
=
3
;
static
constexpr
int
kEntrySize
=
4
;
public
:
static
constexpr
int
kSize
=
kEntrySize
;
}
;
}
}
#
endif
