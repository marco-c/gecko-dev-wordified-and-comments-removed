#
ifndef
V8_REGEXP_REGEXP_H_
#
define
V8_REGEXP_REGEXP_H_
#
include
"
irregexp
/
imported
/
regexp
-
error
.
h
"
#
include
"
irregexp
/
RegExpShim
.
h
"
namespace
v8
{
namespace
internal
{
class
JSRegExp
;
class
RegExpCapture
;
class
RegExpMatchInfo
;
class
RegExpNode
;
class
RegExpTree
;
enum
class
RegExpCompilationTarget
:
int
{
kBytecode
kNative
}
;
struct
RegExpCompileData
{
RegExpTree
*
tree
=
nullptr
;
RegExpNode
*
node
=
nullptr
;
Handle
<
Object
>
code
;
bool
simple
=
true
;
bool
contains_anchor
=
false
;
ZoneVector
<
RegExpCapture
*
>
*
named_captures
=
nullptr
;
RegExpError
error
=
RegExpError
:
:
kNone
;
int
error_pos
=
0
;
int
capture_count
=
0
;
int
register_count
=
0
;
RegExpCompilationTarget
compilation_target
;
}
;
class
RegExp
final
:
public
AllStatic
{
public
:
static
bool
CanGenerateBytecode
(
)
;
template
<
class
CharT
>
static
bool
VerifySyntax
(
Zone
*
zone
uintptr_t
stack_limit
const
CharT
*
input
int
input_length
RegExpFlags
flags
RegExpError
*
regexp_error_out
const
DisallowGarbageCollection
&
no_gc
)
;
V8_WARN_UNUSED_RESULT
static
MaybeHandle
<
Object
>
Compile
(
Isolate
*
isolate
Handle
<
JSRegExp
>
re
Handle
<
String
>
pattern
RegExpFlags
flags
uint32_t
backtrack_limit
)
;
V8_WARN_UNUSED_RESULT
static
bool
EnsureFullyCompiled
(
Isolate
*
isolate
Handle
<
JSRegExp
>
re
Handle
<
String
>
subject
)
;
enum
CallOrigin
:
int
{
kFromRuntime
=
0
kFromJs
=
1
}
;
enum
class
ExecQuirks
{
kNone
kTreatMatchAtEndAsFailure
}
;
V8_EXPORT_PRIVATE
V8_WARN_UNUSED_RESULT
static
MaybeHandle
<
Object
>
Exec
(
Isolate
*
isolate
Handle
<
JSRegExp
>
regexp
Handle
<
String
>
subject
int
index
Handle
<
RegExpMatchInfo
>
last_match_info
ExecQuirks
exec_quirks
=
ExecQuirks
:
:
kNone
)
;
V8_EXPORT_PRIVATE
V8_WARN_UNUSED_RESULT
static
MaybeHandle
<
Object
>
ExperimentalOneshotExec
(
Isolate
*
isolate
Handle
<
JSRegExp
>
regexp
Handle
<
String
>
subject
int
index
Handle
<
RegExpMatchInfo
>
last_match_info
ExecQuirks
exec_quirks
=
ExecQuirks
:
:
kNone
)
;
static
constexpr
int
kInternalRegExpFailure
=
0
;
static
constexpr
int
kInternalRegExpSuccess
=
1
;
static
constexpr
int
kInternalRegExpException
=
-
1
;
static
constexpr
int
kInternalRegExpRetry
=
-
2
;
static
constexpr
int
kInternalRegExpFallbackToExperimental
=
-
3
;
static
constexpr
int
kInternalRegExpSmallestResult
=
-
3
;
enum
IrregexpResult
:
int32_t
{
RE_FAILURE
=
kInternalRegExpFailure
RE_SUCCESS
=
kInternalRegExpSuccess
RE_EXCEPTION
=
kInternalRegExpException
RE_RETRY
=
kInternalRegExpRetry
RE_FALLBACK_TO_EXPERIMENTAL
=
kInternalRegExpFallbackToExperimental
}
;
static
Handle
<
RegExpMatchInfo
>
SetLastMatchInfo
(
Isolate
*
isolate
Handle
<
RegExpMatchInfo
>
last_match_info
Handle
<
String
>
subject
int
capture_count
int32_t
*
match
)
;
V8_EXPORT_PRIVATE
static
bool
CompileForTesting
(
Isolate
*
isolate
Zone
*
zone
RegExpCompileData
*
input
RegExpFlags
flags
Handle
<
String
>
pattern
Handle
<
String
>
sample_subject
bool
is_one_byte
)
;
V8_EXPORT_PRIVATE
static
void
DotPrintForTesting
(
const
char
*
label
RegExpNode
*
node
)
;
static
const
int
kRegExpTooLargeToOptimize
=
20
*
KB
;
V8_WARN_UNUSED_RESULT
static
MaybeHandle
<
Object
>
ThrowRegExpException
(
Isolate
*
isolate
Handle
<
JSRegExp
>
re
Handle
<
String
>
pattern
RegExpError
error
)
;
static
void
ThrowRegExpException
(
Isolate
*
isolate
Handle
<
JSRegExp
>
re
RegExpError
error_text
)
;
static
bool
IsUnmodifiedRegExp
(
Isolate
*
isolate
Handle
<
JSRegExp
>
regexp
)
;
static
Handle
<
FixedArray
>
CreateCaptureNameMap
(
Isolate
*
isolate
ZoneVector
<
RegExpCapture
*
>
*
named_captures
)
;
}
;
class
RegExpGlobalCache
final
{
public
:
RegExpGlobalCache
(
Handle
<
JSRegExp
>
regexp
Handle
<
String
>
subject
Isolate
*
isolate
)
;
~
RegExpGlobalCache
(
)
;
int32_t
*
FetchNext
(
)
;
int32_t
*
LastSuccessfulMatch
(
)
;
bool
HasException
(
)
{
return
num_matches_
<
0
;
}
private
:
int
AdvanceZeroLength
(
int
last_index
)
;
int
num_matches_
;
int
max_matches_
;
int
current_match_index_
;
int
registers_per_match_
;
int32_t
*
register_array_
;
int
register_array_size_
;
Handle
<
JSRegExp
>
regexp_
;
Handle
<
String
>
subject_
;
Isolate
*
isolate_
;
}
;
class
RegExpResultsCache
final
:
public
AllStatic
{
public
:
enum
ResultsCacheType
{
REGEXP_MULTIPLE_INDICES
STRING_SPLIT_SUBSTRINGS
}
;
static
Object
Lookup
(
Heap
*
heap
String
key_string
Object
key_pattern
FixedArray
*
last_match_out
ResultsCacheType
type
)
;
static
void
Enter
(
Isolate
*
isolate
Handle
<
String
>
key_string
Handle
<
Object
>
key_pattern
Handle
<
FixedArray
>
value_array
Handle
<
FixedArray
>
last_match_cache
ResultsCacheType
type
)
;
static
void
Clear
(
FixedArray
cache
)
;
static
constexpr
int
kRegExpResultsCacheSize
=
0x100
;
private
:
static
constexpr
int
kStringOffset
=
0
;
static
constexpr
int
kPatternOffset
=
1
;
static
constexpr
int
kArrayOffset
=
2
;
static
constexpr
int
kLastMatchOffset
=
3
;
static
constexpr
int
kArrayEntriesPerCacheEntry
=
4
;
}
;
}
}
#
endif
