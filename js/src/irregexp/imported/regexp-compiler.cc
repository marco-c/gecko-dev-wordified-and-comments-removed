#
include
"
irregexp
/
imported
/
regexp
-
compiler
.
h
"
#
include
<
optional
>
#
include
"
irregexp
/
imported
/
regexp
-
macro
-
assembler
-
arch
.
h
"
#
ifdef
V8_INTL_SUPPORT
#
include
"
irregexp
/
imported
/
special
-
case
.
h
"
#
include
"
unicode
/
locid
.
h
"
#
include
"
unicode
/
uniset
.
h
"
#
include
"
unicode
/
utypes
.
h
"
#
endif
namespace
v8
:
:
internal
{
using
namespace
regexp_compiler_constants
;
namespace
{
constexpr
base
:
:
uc32
MaxCodeUnit
(
const
bool
one_byte
)
{
static_assert
(
String
:
:
kMaxOneByteCharCodeU
<
=
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
)
;
static_assert
(
String
:
:
kMaxUtf16CodeUnitU
<
=
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
)
;
return
one_byte
?
String
:
:
kMaxOneByteCharCodeU
:
String
:
:
kMaxUtf16CodeUnitU
;
}
constexpr
uint32_t
CharMask
(
const
bool
one_byte
)
{
static_assert
(
base
:
:
bits
:
:
IsPowerOfTwo
(
String
:
:
kMaxOneByteCharCodeU
+
1
)
)
;
static_assert
(
base
:
:
bits
:
:
IsPowerOfTwo
(
String
:
:
kMaxUtf16CodeUnitU
+
1
)
)
;
return
MaxCodeUnit
(
one_byte
)
;
}
}
void
RegExpTree
:
:
AppendToText
(
RegExpText
*
text
Zone
*
zone
)
{
UNREACHABLE
(
)
;
}
void
RegExpAtom
:
:
AppendToText
(
RegExpText
*
text
Zone
*
zone
)
{
text
-
>
AddElement
(
TextElement
:
:
Atom
(
this
)
zone
)
;
}
void
RegExpClassRanges
:
:
AppendToText
(
RegExpText
*
text
Zone
*
zone
)
{
text
-
>
AddElement
(
TextElement
:
:
ClassRanges
(
this
)
zone
)
;
}
void
RegExpText
:
:
AppendToText
(
RegExpText
*
text
Zone
*
zone
)
{
for
(
int
i
=
0
;
i
<
elements
(
)
-
>
length
(
)
;
i
+
+
)
text
-
>
AddElement
(
elements
(
)
-
>
at
(
i
)
zone
)
;
}
TextElement
TextElement
:
:
Atom
(
RegExpAtom
*
atom
)
{
return
TextElement
(
ATOM
atom
)
;
}
TextElement
TextElement
:
:
ClassRanges
(
RegExpClassRanges
*
class_ranges
)
{
return
TextElement
(
CLASS_RANGES
class_ranges
)
;
}
int
TextElement
:
:
length
(
)
const
{
switch
(
text_type
(
)
)
{
case
ATOM
:
return
atom
(
)
-
>
length
(
)
;
case
CLASS_RANGES
:
return
1
;
}
UNREACHABLE
(
)
;
}
class
RecursionCheck
{
public
:
explicit
RecursionCheck
(
RegExpCompiler
*
compiler
)
:
compiler_
(
compiler
)
{
compiler
-
>
IncrementRecursionDepth
(
)
;
}
~
RecursionCheck
(
)
{
compiler_
-
>
DecrementRecursionDepth
(
)
;
}
private
:
RegExpCompiler
*
compiler_
;
}
;
RegExpCompiler
:
:
RegExpCompiler
(
Isolate
*
isolate
Zone
*
zone
int
capture_count
RegExpFlags
flags
bool
one_byte
)
:
next_register_
(
JSRegExp
:
:
RegistersForCaptureCount
(
capture_count
)
)
unicode_lookaround_stack_register_
(
kNoRegister
)
unicode_lookaround_position_register_
(
kNoRegister
)
work_list_
(
nullptr
)
recursion_depth_
(
0
)
flags_
(
flags
)
one_byte_
(
one_byte
)
reg_exp_too_big_
(
false
)
limiting_recursion_
(
false
)
optimize_
(
v8_flags
.
regexp_optimization
)
read_backward_
(
false
)
current_expansion_factor_
(
1
)
frequency_collator_
(
)
isolate_
(
isolate
)
zone_
(
zone
)
{
accept_
=
zone
-
>
New
<
EndNode
>
(
EndNode
:
:
ACCEPT
zone
)
;
DCHECK_GE
(
RegExpMacroAssembler
:
:
kMaxRegister
next_register_
-
1
)
;
}
RegExpCompiler
:
:
CompilationResult
RegExpCompiler
:
:
Assemble
(
Isolate
*
isolate
RegExpMacroAssembler
*
macro_assembler
RegExpNode
*
start
int
capture_count
Handle
<
String
>
pattern
)
{
macro_assembler_
=
macro_assembler
;
ZoneVector
<
RegExpNode
*
>
work_list
(
zone
(
)
)
;
work_list_
=
&
work_list
;
Label
fail
;
macro_assembler_
-
>
PushBacktrack
(
&
fail
)
;
Trace
new_trace
;
start
-
>
Emit
(
this
&
new_trace
)
;
macro_assembler_
-
>
BindJumpTarget
(
&
fail
)
;
macro_assembler_
-
>
Fail
(
)
;
while
(
!
work_list
.
empty
(
)
)
{
RegExpNode
*
node
=
work_list
.
back
(
)
;
work_list
.
pop_back
(
)
;
node
-
>
set_on_work_list
(
false
)
;
if
(
!
node
-
>
label
(
)
-
>
is_bound
(
)
)
node
-
>
Emit
(
this
&
new_trace
)
;
}
if
(
reg_exp_too_big_
)
{
if
(
v8_flags
.
correctness_fuzzer_suppressions
)
{
FATAL
(
"
Aborting
on
excess
zone
allocation
"
)
;
}
macro_assembler_
-
>
AbortedCodeGeneration
(
)
;
return
CompilationResult
:
:
RegExpTooBig
(
)
;
}
Handle
<
HeapObject
>
code
=
macro_assembler_
-
>
GetCode
(
pattern
flags_
)
;
isolate
-
>
IncreaseTotalRegexpCodeGenerated
(
code
)
;
work_list_
=
nullptr
;
return
{
code
next_register_
}
;
}
bool
Trace
:
:
DeferredAction
:
:
Mentions
(
int
that
)
{
if
(
action_type
(
)
=
=
ActionNode
:
:
CLEAR_CAPTURES
)
{
Interval
range
=
static_cast
<
DeferredClearCaptures
*
>
(
this
)
-
>
range
(
)
;
return
range
.
Contains
(
that
)
;
}
else
{
return
reg
(
)
=
=
that
;
}
}
bool
Trace
:
:
mentions_reg
(
int
reg
)
{
for
(
DeferredAction
*
action
=
actions_
;
action
!
=
nullptr
;
action
=
action
-
>
next
(
)
)
{
if
(
action
-
>
Mentions
(
reg
)
)
return
true
;
}
return
false
;
}
bool
Trace
:
:
GetStoredPosition
(
int
reg
int
*
cp_offset
)
{
DCHECK_EQ
(
0
*
cp_offset
)
;
for
(
DeferredAction
*
action
=
actions_
;
action
!
=
nullptr
;
action
=
action
-
>
next
(
)
)
{
if
(
action
-
>
Mentions
(
reg
)
)
{
if
(
action
-
>
action_type
(
)
=
=
ActionNode
:
:
STORE_POSITION
)
{
*
cp_offset
=
static_cast
<
DeferredCapture
*
>
(
action
)
-
>
cp_offset
(
)
;
return
true
;
}
else
{
return
false
;
}
}
}
return
false
;
}
class
DynamicBitSet
:
public
ZoneObject
{
public
:
V8_EXPORT_PRIVATE
bool
Get
(
unsigned
value
)
const
{
if
(
value
<
kFirstLimit
)
{
return
(
first_
&
(
1
<
<
value
)
)
!
=
0
;
}
else
if
(
remaining_
=
=
nullptr
)
{
return
false
;
}
else
{
return
remaining_
-
>
Contains
(
value
)
;
}
}
void
Set
(
unsigned
value
Zone
*
zone
)
{
if
(
value
<
kFirstLimit
)
{
first_
|
=
(
1
<
<
value
)
;
}
else
{
if
(
remaining_
=
=
nullptr
)
remaining_
=
zone
-
>
New
<
ZoneList
<
unsigned
>
>
(
1
zone
)
;
if
(
remaining_
-
>
is_empty
(
)
|
|
!
remaining_
-
>
Contains
(
value
)
)
remaining_
-
>
Add
(
value
zone
)
;
}
}
private
:
static
constexpr
unsigned
kFirstLimit
=
32
;
uint32_t
first_
=
0
;
ZoneList
<
unsigned
>
*
remaining_
=
nullptr
;
}
;
int
Trace
:
:
FindAffectedRegisters
(
DynamicBitSet
*
affected_registers
Zone
*
zone
)
{
int
max_register
=
RegExpCompiler
:
:
kNoRegister
;
for
(
DeferredAction
*
action
=
actions_
;
action
!
=
nullptr
;
action
=
action
-
>
next
(
)
)
{
if
(
action
-
>
action_type
(
)
=
=
ActionNode
:
:
CLEAR_CAPTURES
)
{
Interval
range
=
static_cast
<
DeferredClearCaptures
*
>
(
action
)
-
>
range
(
)
;
for
(
int
i
=
range
.
from
(
)
;
i
<
=
range
.
to
(
)
;
i
+
+
)
affected_registers
-
>
Set
(
i
zone
)
;
if
(
range
.
to
(
)
>
max_register
)
max_register
=
range
.
to
(
)
;
}
else
{
affected_registers
-
>
Set
(
action
-
>
reg
(
)
zone
)
;
if
(
action
-
>
reg
(
)
>
max_register
)
max_register
=
action
-
>
reg
(
)
;
}
}
return
max_register
;
}
void
Trace
:
:
RestoreAffectedRegisters
(
RegExpMacroAssembler
*
assembler
int
max_register
const
DynamicBitSet
&
registers_to_pop
const
DynamicBitSet
&
registers_to_clear
)
{
for
(
int
reg
=
max_register
;
reg
>
=
0
;
reg
-
-
)
{
if
(
registers_to_pop
.
Get
(
reg
)
)
{
assembler
-
>
PopRegister
(
reg
)
;
}
else
if
(
registers_to_clear
.
Get
(
reg
)
)
{
int
clear_to
=
reg
;
while
(
reg
>
0
&
&
registers_to_clear
.
Get
(
reg
-
1
)
)
{
reg
-
-
;
}
assembler
-
>
ClearRegisters
(
reg
clear_to
)
;
}
}
}
void
Trace
:
:
PerformDeferredActions
(
RegExpMacroAssembler
*
assembler
int
max_register
const
DynamicBitSet
&
affected_registers
DynamicBitSet
*
registers_to_pop
DynamicBitSet
*
registers_to_clear
Zone
*
zone
)
{
int
pushes
=
0
;
for
(
int
reg
=
0
;
reg
<
=
max_register
;
reg
+
+
)
{
if
(
!
affected_registers
.
Get
(
reg
)
)
continue
;
enum
DeferredActionUndoType
{
IGNORE
RESTORE
CLEAR
}
;
DeferredActionUndoType
undo_action
=
IGNORE
;
int
value
=
0
;
bool
absolute
=
false
;
bool
clear
=
false
;
static
const
int
kNoStore
=
kMinInt
;
int
store_position
=
kNoStore
;
for
(
DeferredAction
*
action
=
actions_
;
action
!
=
nullptr
;
action
=
action
-
>
next
(
)
)
{
if
(
action
-
>
Mentions
(
reg
)
)
{
switch
(
action
-
>
action_type
(
)
)
{
case
ActionNode
:
:
SET_REGISTER_FOR_LOOP
:
{
Trace
:
:
DeferredSetRegisterForLoop
*
psr
=
static_cast
<
Trace
:
:
DeferredSetRegisterForLoop
*
>
(
action
)
;
if
(
!
absolute
)
{
value
+
=
psr
-
>
value
(
)
;
absolute
=
true
;
}
undo_action
=
RESTORE
;
DCHECK_EQ
(
store_position
kNoStore
)
;
DCHECK
(
!
clear
)
;
break
;
}
case
ActionNode
:
:
INCREMENT_REGISTER
:
if
(
!
absolute
)
{
value
+
+
;
}
DCHECK_EQ
(
store_position
kNoStore
)
;
DCHECK
(
!
clear
)
;
undo_action
=
RESTORE
;
break
;
case
ActionNode
:
:
STORE_POSITION
:
{
Trace
:
:
DeferredCapture
*
pc
=
static_cast
<
Trace
:
:
DeferredCapture
*
>
(
action
)
;
if
(
!
clear
&
&
store_position
=
=
kNoStore
)
{
store_position
=
pc
-
>
cp_offset
(
)
;
}
if
(
reg
<
=
1
)
{
undo_action
=
IGNORE
;
}
else
{
undo_action
=
pc
-
>
is_capture
(
)
?
CLEAR
:
RESTORE
;
}
DCHECK
(
!
absolute
)
;
DCHECK_EQ
(
value
0
)
;
break
;
}
case
ActionNode
:
:
CLEAR_CAPTURES
:
{
if
(
store_position
=
=
kNoStore
)
{
clear
=
true
;
}
undo_action
=
RESTORE
;
DCHECK
(
!
absolute
)
;
DCHECK_EQ
(
value
0
)
;
break
;
}
default
:
UNREACHABLE
(
)
;
}
}
}
if
(
undo_action
=
=
RESTORE
)
{
pushes
+
+
;
RegExpMacroAssembler
:
:
StackCheckFlag
stack_check
=
RegExpMacroAssembler
:
:
kNoStackLimitCheck
;
DCHECK_GT
(
assembler
-
>
stack_limit_slack_slot_count
(
)
0
)
;
if
(
pushes
=
=
assembler
-
>
stack_limit_slack_slot_count
(
)
)
{
stack_check
=
RegExpMacroAssembler
:
:
kCheckStackLimit
;
pushes
=
0
;
}
assembler
-
>
PushRegister
(
reg
stack_check
)
;
registers_to_pop
-
>
Set
(
reg
zone
)
;
}
else
if
(
undo_action
=
=
CLEAR
)
{
registers_to_clear
-
>
Set
(
reg
zone
)
;
}
if
(
store_position
!
=
kNoStore
)
{
assembler
-
>
WriteCurrentPositionToRegister
(
reg
store_position
)
;
}
else
if
(
clear
)
{
assembler
-
>
ClearRegisters
(
reg
reg
)
;
}
else
if
(
absolute
)
{
assembler
-
>
SetRegister
(
reg
value
)
;
}
else
if
(
value
!
=
0
)
{
assembler
-
>
AdvanceRegister
(
reg
value
)
;
}
}
}
void
Trace
:
:
Flush
(
RegExpCompiler
*
compiler
RegExpNode
*
successor
)
{
RegExpMacroAssembler
*
assembler
=
compiler
-
>
macro_assembler
(
)
;
DCHECK
(
!
is_trivial
(
)
)
;
if
(
actions_
=
=
nullptr
&
&
backtrack
(
)
=
=
nullptr
)
{
if
(
cp_offset_
!
=
0
)
assembler
-
>
AdvanceCurrentPosition
(
cp_offset_
)
;
Trace
new_state
;
successor
-
>
Emit
(
compiler
&
new_state
)
;
return
;
}
DynamicBitSet
affected_registers
;
if
(
backtrack
(
)
!
=
nullptr
)
{
assembler
-
>
PushCurrentPosition
(
)
;
}
int
max_register
=
FindAffectedRegisters
(
&
affected_registers
compiler
-
>
zone
(
)
)
;
DynamicBitSet
registers_to_pop
;
DynamicBitSet
registers_to_clear
;
PerformDeferredActions
(
assembler
max_register
affected_registers
&
registers_to_pop
&
registers_to_clear
compiler
-
>
zone
(
)
)
;
if
(
cp_offset_
!
=
0
)
{
assembler
-
>
AdvanceCurrentPosition
(
cp_offset_
)
;
}
Label
undo
;
assembler
-
>
PushBacktrack
(
&
undo
)
;
if
(
successor
-
>
KeepRecursing
(
compiler
)
)
{
Trace
new_state
;
successor
-
>
Emit
(
compiler
&
new_state
)
;
}
else
{
compiler
-
>
AddWork
(
successor
)
;
assembler
-
>
GoTo
(
successor
-
>
label
(
)
)
;
}
assembler
-
>
BindJumpTarget
(
&
undo
)
;
RestoreAffectedRegisters
(
assembler
max_register
registers_to_pop
registers_to_clear
)
;
if
(
backtrack
(
)
=
=
nullptr
)
{
assembler
-
>
Backtrack
(
)
;
}
else
{
assembler
-
>
PopCurrentPosition
(
)
;
assembler
-
>
GoTo
(
backtrack
(
)
)
;
}
}
void
NegativeSubmatchSuccess
:
:
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
{
RegExpMacroAssembler
*
assembler
=
compiler
-
>
macro_assembler
(
)
;
if
(
!
label
(
)
-
>
is_bound
(
)
)
{
assembler
-
>
Bind
(
label
(
)
)
;
}
assembler
-
>
ReadCurrentPositionFromRegister
(
current_position_register_
)
;
assembler
-
>
ReadStackPointerFromRegister
(
stack_pointer_register_
)
;
if
(
clear_capture_count_
>
0
)
{
int
clear_capture_end
=
clear_capture_start_
+
clear_capture_count_
-
1
;
assembler
-
>
ClearRegisters
(
clear_capture_start_
clear_capture_end
)
;
}
assembler
-
>
Backtrack
(
)
;
}
void
EndNode
:
:
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
{
if
(
!
trace
-
>
is_trivial
(
)
)
{
trace
-
>
Flush
(
compiler
this
)
;
return
;
}
RegExpMacroAssembler
*
assembler
=
compiler
-
>
macro_assembler
(
)
;
if
(
!
label
(
)
-
>
is_bound
(
)
)
{
assembler
-
>
Bind
(
label
(
)
)
;
}
switch
(
action_
)
{
case
ACCEPT
:
assembler
-
>
Succeed
(
)
;
return
;
case
BACKTRACK
:
assembler
-
>
GoTo
(
trace
-
>
backtrack
(
)
)
;
return
;
case
NEGATIVE_SUBMATCH_SUCCESS
:
UNREACHABLE
(
)
;
}
UNIMPLEMENTED
(
)
;
}
void
GuardedAlternative
:
:
AddGuard
(
Guard
*
guard
Zone
*
zone
)
{
if
(
guards_
=
=
nullptr
)
guards_
=
zone
-
>
New
<
ZoneList
<
Guard
*
>
>
(
1
zone
)
;
guards_
-
>
Add
(
guard
zone
)
;
}
ActionNode
*
ActionNode
:
:
SetRegisterForLoop
(
int
reg
int
val
RegExpNode
*
on_success
)
{
ActionNode
*
result
=
on_success
-
>
zone
(
)
-
>
New
<
ActionNode
>
(
SET_REGISTER_FOR_LOOP
on_success
)
;
result
-
>
data_
.
u_store_register
.
reg
=
reg
;
result
-
>
data_
.
u_store_register
.
value
=
val
;
return
result
;
}
ActionNode
*
ActionNode
:
:
IncrementRegister
(
int
reg
RegExpNode
*
on_success
)
{
ActionNode
*
result
=
on_success
-
>
zone
(
)
-
>
New
<
ActionNode
>
(
INCREMENT_REGISTER
on_success
)
;
result
-
>
data_
.
u_increment_register
.
reg
=
reg
;
return
result
;
}
ActionNode
*
ActionNode
:
:
StorePosition
(
int
reg
bool
is_capture
RegExpNode
*
on_success
)
{
ActionNode
*
result
=
on_success
-
>
zone
(
)
-
>
New
<
ActionNode
>
(
STORE_POSITION
on_success
)
;
result
-
>
data_
.
u_position_register
.
reg
=
reg
;
result
-
>
data_
.
u_position_register
.
is_capture
=
is_capture
;
return
result
;
}
ActionNode
*
ActionNode
:
:
ClearCaptures
(
Interval
range
RegExpNode
*
on_success
)
{
ActionNode
*
result
=
on_success
-
>
zone
(
)
-
>
New
<
ActionNode
>
(
CLEAR_CAPTURES
on_success
)
;
result
-
>
data_
.
u_clear_captures
.
range_from
=
range
.
from
(
)
;
result
-
>
data_
.
u_clear_captures
.
range_to
=
range
.
to
(
)
;
return
result
;
}
ActionNode
*
ActionNode
:
:
BeginPositiveSubmatch
(
int
stack_reg
int
position_reg
RegExpNode
*
body
ActionNode
*
success_node
)
{
ActionNode
*
result
=
body
-
>
zone
(
)
-
>
New
<
ActionNode
>
(
BEGIN_POSITIVE_SUBMATCH
body
)
;
result
-
>
data_
.
u_submatch
.
stack_pointer_register
=
stack_reg
;
result
-
>
data_
.
u_submatch
.
current_position_register
=
position_reg
;
result
-
>
data_
.
u_submatch
.
success_node
=
success_node
;
return
result
;
}
ActionNode
*
ActionNode
:
:
BeginNegativeSubmatch
(
int
stack_reg
int
position_reg
RegExpNode
*
on_success
)
{
ActionNode
*
result
=
on_success
-
>
zone
(
)
-
>
New
<
ActionNode
>
(
BEGIN_NEGATIVE_SUBMATCH
on_success
)
;
result
-
>
data_
.
u_submatch
.
stack_pointer_register
=
stack_reg
;
result
-
>
data_
.
u_submatch
.
current_position_register
=
position_reg
;
return
result
;
}
ActionNode
*
ActionNode
:
:
PositiveSubmatchSuccess
(
int
stack_reg
int
position_reg
int
clear_register_count
int
clear_register_from
RegExpNode
*
on_success
)
{
ActionNode
*
result
=
on_success
-
>
zone
(
)
-
>
New
<
ActionNode
>
(
POSITIVE_SUBMATCH_SUCCESS
on_success
)
;
result
-
>
data_
.
u_submatch
.
stack_pointer_register
=
stack_reg
;
result
-
>
data_
.
u_submatch
.
current_position_register
=
position_reg
;
result
-
>
data_
.
u_submatch
.
clear_register_count
=
clear_register_count
;
result
-
>
data_
.
u_submatch
.
clear_register_from
=
clear_register_from
;
return
result
;
}
ActionNode
*
ActionNode
:
:
EmptyMatchCheck
(
int
start_register
int
repetition_register
int
repetition_limit
RegExpNode
*
on_success
)
{
ActionNode
*
result
=
on_success
-
>
zone
(
)
-
>
New
<
ActionNode
>
(
EMPTY_MATCH_CHECK
on_success
)
;
result
-
>
data_
.
u_empty_match_check
.
start_register
=
start_register
;
result
-
>
data_
.
u_empty_match_check
.
repetition_register
=
repetition_register
;
result
-
>
data_
.
u_empty_match_check
.
repetition_limit
=
repetition_limit
;
return
result
;
}
ActionNode
*
ActionNode
:
:
ModifyFlags
(
RegExpFlags
flags
RegExpNode
*
on_success
)
{
ActionNode
*
result
=
on_success
-
>
zone
(
)
-
>
New
<
ActionNode
>
(
MODIFY_FLAGS
on_success
)
;
result
-
>
data_
.
u_modify_flags
.
flags
=
flags
;
return
result
;
}
#
define
DEFINE_ACCEPT
(
Type
)
\
void
Type
#
#
Node
:
:
Accept
(
NodeVisitor
*
visitor
)
{
visitor
-
>
Visit
#
#
Type
(
this
)
;
}
FOR_EACH_NODE_TYPE
(
DEFINE_ACCEPT
)
#
undef
DEFINE_ACCEPT
void
ChoiceNode
:
:
GenerateGuard
(
RegExpMacroAssembler
*
macro_assembler
Guard
*
guard
Trace
*
trace
)
{
switch
(
guard
-
>
op
(
)
)
{
case
Guard
:
:
LT
:
DCHECK
(
!
trace
-
>
mentions_reg
(
guard
-
>
reg
(
)
)
)
;
macro_assembler
-
>
IfRegisterGE
(
guard
-
>
reg
(
)
guard
-
>
value
(
)
trace
-
>
backtrack
(
)
)
;
break
;
case
Guard
:
:
GEQ
:
DCHECK
(
!
trace
-
>
mentions_reg
(
guard
-
>
reg
(
)
)
)
;
macro_assembler
-
>
IfRegisterLT
(
guard
-
>
reg
(
)
guard
-
>
value
(
)
trace
-
>
backtrack
(
)
)
;
break
;
}
}
namespace
{
#
ifdef
DEBUG
bool
ContainsOnlyUtf16CodeUnits
(
unibrow
:
:
uchar
*
chars
int
length
)
{
static_assert
(
sizeof
(
unibrow
:
:
uchar
)
=
=
4
)
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
chars
[
i
]
>
String
:
:
kMaxUtf16CodeUnit
)
return
false
;
}
return
true
;
}
#
endif
int
GetCaseIndependentLetters
(
Isolate
*
isolate
base
:
:
uc16
character
RegExpCompiler
*
compiler
unibrow
:
:
uchar
*
letters
int
letter_length
)
{
bool
one_byte_subject
=
compiler
-
>
one_byte
(
)
;
bool
unicode
=
IsEitherUnicode
(
compiler
-
>
flags
(
)
)
;
static
const
base
:
:
uc16
kMaxAscii
=
0x7f
;
if
(
!
unicode
&
&
character
<
=
kMaxAscii
)
{
base
:
:
uc16
upper
=
character
&
~
0x20
;
if
(
'
A
'
<
=
upper
&
&
upper
<
=
'
Z
'
)
{
letters
[
0
]
=
upper
;
letters
[
1
]
=
upper
|
0x20
;
return
2
;
}
letters
[
0
]
=
character
;
return
1
;
}
#
ifdef
V8_INTL_SUPPORT
if
(
!
unicode
&
&
RegExpCaseFolding
:
:
IgnoreSet
(
)
.
contains
(
character
)
)
{
if
(
one_byte_subject
&
&
character
>
String
:
:
kMaxOneByteCharCode
)
{
return
0
;
}
letters
[
0
]
=
character
;
DCHECK
(
ContainsOnlyUtf16CodeUnits
(
letters
1
)
)
;
return
1
;
}
bool
in_special_add_set
=
RegExpCaseFolding
:
:
SpecialAddSet
(
)
.
contains
(
character
)
;
icu
:
:
UnicodeSet
set
;
set
.
add
(
character
)
;
set
=
set
.
closeOver
(
unicode
?
USET_SIMPLE_CASE_INSENSITIVE
:
USET_CASE_INSENSITIVE
)
;
UChar32
canon
=
0
;
if
(
in_special_add_set
&
&
!
unicode
)
{
canon
=
RegExpCaseFolding
:
:
Canonicalize
(
character
)
;
}
int32_t
range_count
=
set
.
getRangeCount
(
)
;
int
items
=
0
;
for
(
int32_t
i
=
0
;
i
<
range_count
;
i
+
+
)
{
UChar32
start
=
set
.
getRangeStart
(
i
)
;
UChar32
end
=
set
.
getRangeEnd
(
i
)
;
CHECK
(
end
-
start
+
items
<
=
letter_length
)
;
for
(
UChar32
cu
=
start
;
cu
<
=
end
;
cu
+
+
)
{
if
(
one_byte_subject
&
&
cu
>
String
:
:
kMaxOneByteCharCode
)
continue
;
if
(
!
unicode
&
&
in_special_add_set
&
&
RegExpCaseFolding
:
:
Canonicalize
(
cu
)
!
=
canon
)
{
continue
;
}
letters
[
items
+
+
]
=
static_cast
<
unibrow
:
:
uchar
>
(
cu
)
;
}
}
DCHECK
(
ContainsOnlyUtf16CodeUnits
(
letters
items
)
)
;
return
items
;
#
else
int
length
=
isolate
-
>
jsregexp_uncanonicalize
(
)
-
>
get
(
character
'
\
0
'
letters
)
;
if
(
length
=
=
0
)
{
letters
[
0
]
=
character
;
length
=
1
;
}
if
(
one_byte_subject
)
{
int
new_length
=
0
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
letters
[
i
]
<
=
String
:
:
kMaxOneByteCharCode
)
{
letters
[
new_length
+
+
]
=
letters
[
i
]
;
}
}
length
=
new_length
;
}
DCHECK
(
ContainsOnlyUtf16CodeUnits
(
letters
length
)
)
;
return
length
;
#
endif
}
inline
bool
EmitSimpleCharacter
(
Isolate
*
isolate
RegExpCompiler
*
compiler
base
:
:
uc16
c
Label
*
on_failure
int
cp_offset
bool
check
bool
preloaded
)
{
RegExpMacroAssembler
*
assembler
=
compiler
-
>
macro_assembler
(
)
;
bool
bound_checked
=
false
;
if
(
!
preloaded
)
{
assembler
-
>
LoadCurrentCharacter
(
cp_offset
on_failure
check
)
;
bound_checked
=
true
;
}
assembler
-
>
CheckNotCharacter
(
c
on_failure
)
;
return
bound_checked
;
}
inline
bool
EmitAtomNonLetter
(
Isolate
*
isolate
RegExpCompiler
*
compiler
base
:
:
uc16
c
Label
*
on_failure
int
cp_offset
bool
check
bool
preloaded
)
{
RegExpMacroAssembler
*
macro_assembler
=
compiler
-
>
macro_assembler
(
)
;
bool
one_byte
=
compiler
-
>
one_byte
(
)
;
unibrow
:
:
uchar
chars
[
4
]
;
int
length
=
GetCaseIndependentLetters
(
isolate
c
compiler
chars
4
)
;
if
(
length
<
1
)
{
CHECK
(
one_byte
)
;
return
false
;
}
bool
checked
=
false
;
if
(
length
=
=
1
)
{
CHECK_IMPLIES
(
one_byte
chars
[
0
]
<
=
String
:
:
kMaxOneByteCharCodeU
)
;
if
(
!
preloaded
)
{
macro_assembler
-
>
LoadCurrentCharacter
(
cp_offset
on_failure
check
)
;
checked
=
check
;
}
macro_assembler
-
>
CheckNotCharacter
(
chars
[
0
]
on_failure
)
;
}
return
checked
;
}
bool
ShortCutEmitCharacterPair
(
RegExpMacroAssembler
*
macro_assembler
bool
one_byte
base
:
:
uc16
c1
base
:
:
uc16
c2
Label
*
on_failure
)
{
const
uint32_t
char_mask
=
CharMask
(
one_byte
)
;
base
:
:
uc16
exor
=
c1
^
c2
;
if
(
(
(
exor
-
1
)
&
exor
)
=
=
0
)
{
DCHECK
(
c2
>
c1
)
;
base
:
:
uc16
mask
=
char_mask
^
exor
;
macro_assembler
-
>
CheckNotCharacterAfterAnd
(
c1
mask
on_failure
)
;
return
true
;
}
DCHECK
(
c2
>
c1
)
;
base
:
:
uc16
diff
=
c2
-
c1
;
if
(
(
(
diff
-
1
)
&
diff
)
=
=
0
&
&
c1
>
=
diff
)
{
base
:
:
uc16
mask
=
char_mask
^
diff
;
macro_assembler
-
>
CheckNotCharacterAfterMinusAnd
(
c1
-
diff
diff
mask
on_failure
)
;
return
true
;
}
return
false
;
}
inline
bool
EmitAtomLetter
(
Isolate
*
isolate
RegExpCompiler
*
compiler
base
:
:
uc16
c
Label
*
on_failure
int
cp_offset
bool
check
bool
preloaded
)
{
RegExpMacroAssembler
*
macro_assembler
=
compiler
-
>
macro_assembler
(
)
;
bool
one_byte
=
compiler
-
>
one_byte
(
)
;
unibrow
:
:
uchar
chars
[
4
]
;
int
length
=
GetCaseIndependentLetters
(
isolate
c
compiler
chars
4
)
;
if
(
length
<
=
1
)
return
false
;
if
(
!
preloaded
)
{
macro_assembler
-
>
LoadCurrentCharacter
(
cp_offset
on_failure
check
)
;
}
Label
ok
;
switch
(
length
)
{
case
2
:
{
if
(
ShortCutEmitCharacterPair
(
macro_assembler
one_byte
chars
[
0
]
chars
[
1
]
on_failure
)
)
{
}
else
{
macro_assembler
-
>
CheckCharacter
(
chars
[
0
]
&
ok
)
;
macro_assembler
-
>
CheckNotCharacter
(
chars
[
1
]
on_failure
)
;
macro_assembler
-
>
Bind
(
&
ok
)
;
}
break
;
}
case
4
:
macro_assembler
-
>
CheckCharacter
(
chars
[
3
]
&
ok
)
;
[
[
fallthrough
]
]
;
case
3
:
macro_assembler
-
>
CheckCharacter
(
chars
[
0
]
&
ok
)
;
macro_assembler
-
>
CheckCharacter
(
chars
[
1
]
&
ok
)
;
macro_assembler
-
>
CheckNotCharacter
(
chars
[
2
]
on_failure
)
;
macro_assembler
-
>
Bind
(
&
ok
)
;
break
;
default
:
UNREACHABLE
(
)
;
}
return
true
;
}
void
EmitBoundaryTest
(
RegExpMacroAssembler
*
masm
int
border
Label
*
fall_through
Label
*
above_or_equal
Label
*
below
)
{
if
(
below
!
=
fall_through
)
{
masm
-
>
CheckCharacterLT
(
border
below
)
;
if
(
above_or_equal
!
=
fall_through
)
masm
-
>
GoTo
(
above_or_equal
)
;
}
else
{
masm
-
>
CheckCharacterGT
(
border
-
1
above_or_equal
)
;
}
}
void
EmitDoubleBoundaryTest
(
RegExpMacroAssembler
*
masm
int
first
int
last
Label
*
fall_through
Label
*
in_range
Label
*
out_of_range
)
{
if
(
in_range
=
=
fall_through
)
{
if
(
first
=
=
last
)
{
masm
-
>
CheckNotCharacter
(
first
out_of_range
)
;
}
else
{
masm
-
>
CheckCharacterNotInRange
(
first
last
out_of_range
)
;
}
}
else
{
if
(
first
=
=
last
)
{
masm
-
>
CheckCharacter
(
first
in_range
)
;
}
else
{
masm
-
>
CheckCharacterInRange
(
first
last
in_range
)
;
}
if
(
out_of_range
!
=
fall_through
)
masm
-
>
GoTo
(
out_of_range
)
;
}
}
void
EmitUseLookupTable
(
RegExpMacroAssembler
*
masm
ZoneList
<
base
:
:
uc32
>
*
ranges
uint32_t
start_index
uint32_t
end_index
base
:
:
uc32
min_char
Label
*
fall_through
Label
*
even_label
Label
*
odd_label
)
{
static
const
uint32_t
kSize
=
RegExpMacroAssembler
:
:
kTableSize
;
static
const
uint32_t
kMask
=
RegExpMacroAssembler
:
:
kTableMask
;
base
:
:
uc32
base
=
(
min_char
&
~
kMask
)
;
USE
(
base
)
;
for
(
uint32_t
i
=
start_index
;
i
<
=
end_index
;
i
+
+
)
{
DCHECK_EQ
(
ranges
-
>
at
(
i
)
&
~
kMask
base
)
;
}
DCHECK
(
start_index
=
=
0
|
|
(
ranges
-
>
at
(
start_index
-
1
)
&
~
kMask
)
<
=
base
)
;
char
templ
[
kSize
]
;
Label
*
on_bit_set
;
Label
*
on_bit_clear
;
int
bit
;
if
(
even_label
=
=
fall_through
)
{
on_bit_set
=
odd_label
;
on_bit_clear
=
even_label
;
bit
=
1
;
}
else
{
on_bit_set
=
even_label
;
on_bit_clear
=
odd_label
;
bit
=
0
;
}
for
(
uint32_t
i
=
0
;
i
<
(
ranges
-
>
at
(
start_index
)
&
kMask
)
&
&
i
<
kSize
;
i
+
+
)
{
templ
[
i
]
=
bit
;
}
uint32_t
j
=
0
;
bit
^
=
1
;
for
(
uint32_t
i
=
start_index
;
i
<
end_index
;
i
+
+
)
{
for
(
j
=
(
ranges
-
>
at
(
i
)
&
kMask
)
;
j
<
(
ranges
-
>
at
(
i
+
1
)
&
kMask
)
;
j
+
+
)
{
templ
[
j
]
=
bit
;
}
bit
^
=
1
;
}
for
(
uint32_t
i
=
j
;
i
<
kSize
;
i
+
+
)
{
templ
[
i
]
=
bit
;
}
Factory
*
factory
=
masm
-
>
isolate
(
)
-
>
factory
(
)
;
Handle
<
ByteArray
>
ba
=
factory
-
>
NewByteArray
(
kSize
AllocationType
:
:
kOld
)
;
for
(
uint32_t
i
=
0
;
i
<
kSize
;
i
+
+
)
{
ba
-
>
set
(
i
templ
[
i
]
)
;
}
masm
-
>
CheckBitInTable
(
ba
on_bit_set
)
;
if
(
on_bit_clear
!
=
fall_through
)
masm
-
>
GoTo
(
on_bit_clear
)
;
}
void
CutOutRange
(
RegExpMacroAssembler
*
masm
ZoneList
<
base
:
:
uc32
>
*
ranges
uint32_t
start_index
uint32_t
end_index
uint32_t
cut_index
Label
*
even_label
Label
*
odd_label
)
{
bool
odd
=
(
(
(
cut_index
-
start_index
)
&
1
)
=
=
1
)
;
Label
*
in_range_label
=
odd
?
odd_label
:
even_label
;
Label
dummy
;
EmitDoubleBoundaryTest
(
masm
ranges
-
>
at
(
cut_index
)
ranges
-
>
at
(
cut_index
+
1
)
-
1
&
dummy
in_range_label
&
dummy
)
;
DCHECK
(
!
dummy
.
is_linked
(
)
)
;
for
(
uint32_t
j
=
cut_index
;
j
>
start_index
;
j
-
-
)
{
ranges
-
>
at
(
j
)
=
ranges
-
>
at
(
j
-
1
)
;
}
for
(
uint32_t
j
=
cut_index
+
1
;
j
<
end_index
;
j
+
+
)
{
ranges
-
>
at
(
j
)
=
ranges
-
>
at
(
j
+
1
)
;
}
}
void
SplitSearchSpace
(
ZoneList
<
base
:
:
uc32
>
*
ranges
uint32_t
start_index
uint32_t
end_index
uint32_t
*
new_start_index
uint32_t
*
new_end_index
base
:
:
uc32
*
border
)
{
static
const
uint32_t
kSize
=
RegExpMacroAssembler
:
:
kTableSize
;
static
const
uint32_t
kMask
=
RegExpMacroAssembler
:
:
kTableMask
;
base
:
:
uc32
first
=
ranges
-
>
at
(
start_index
)
;
base
:
:
uc32
last
=
ranges
-
>
at
(
end_index
)
-
1
;
*
new_start_index
=
start_index
;
*
border
=
(
ranges
-
>
at
(
start_index
)
&
~
kMask
)
+
kSize
;
while
(
*
new_start_index
<
end_index
)
{
if
(
ranges
-
>
at
(
*
new_start_index
)
>
*
border
)
break
;
(
*
new_start_index
)
+
+
;
}
uint32_t
binary_chop_index
=
(
end_index
+
start_index
)
/
2
;
if
(
*
border
-
1
>
String
:
:
kMaxOneByteCharCode
&
&
end_index
-
start_index
>
(
*
new_start_index
-
start_index
)
*
2
&
&
last
-
first
>
kSize
*
2
&
&
binary_chop_index
>
*
new_start_index
&
&
ranges
-
>
at
(
binary_chop_index
)
>
=
first
+
2
*
kSize
)
{
uint32_t
scan_forward_for_section_border
=
binary_chop_index
;
uint32_t
new_border
=
(
ranges
-
>
at
(
binary_chop_index
)
|
kMask
)
+
1
;
while
(
scan_forward_for_section_border
<
end_index
)
{
if
(
ranges
-
>
at
(
scan_forward_for_section_border
)
>
new_border
)
{
*
new_start_index
=
scan_forward_for_section_border
;
*
border
=
new_border
;
break
;
}
scan_forward_for_section_border
+
+
;
}
}
DCHECK
(
*
new_start_index
>
start_index
)
;
*
new_end_index
=
*
new_start_index
-
1
;
if
(
ranges
-
>
at
(
*
new_end_index
)
=
=
*
border
)
{
(
*
new_end_index
)
-
-
;
}
if
(
*
border
>
=
ranges
-
>
at
(
end_index
)
)
{
*
border
=
ranges
-
>
at
(
end_index
)
;
*
new_start_index
=
end_index
;
*
new_end_index
=
end_index
-
1
;
}
}
void
GenerateBranches
(
RegExpMacroAssembler
*
masm
ZoneList
<
base
:
:
uc32
>
*
ranges
uint32_t
start_index
uint32_t
end_index
base
:
:
uc32
min_char
base
:
:
uc32
max_char
Label
*
fall_through
Label
*
even_label
Label
*
odd_label
)
{
DCHECK_LE
(
min_char
String
:
:
kMaxUtf16CodeUnit
)
;
DCHECK_LE
(
max_char
String
:
:
kMaxUtf16CodeUnit
)
;
base
:
:
uc32
first
=
ranges
-
>
at
(
start_index
)
;
base
:
:
uc32
last
=
ranges
-
>
at
(
end_index
)
-
1
;
DCHECK_LT
(
min_char
first
)
;
if
(
start_index
=
=
end_index
)
{
EmitBoundaryTest
(
masm
first
fall_through
even_label
odd_label
)
;
return
;
}
if
(
start_index
+
1
=
=
end_index
)
{
EmitDoubleBoundaryTest
(
masm
first
last
fall_through
even_label
odd_label
)
;
return
;
}
if
(
end_index
-
start_index
<
=
6
)
{
static
uint32_t
kNoCutIndex
=
-
1
;
uint32_t
cut
=
kNoCutIndex
;
for
(
uint32_t
i
=
start_index
;
i
<
end_index
;
i
+
+
)
{
if
(
ranges
-
>
at
(
i
)
=
=
ranges
-
>
at
(
i
+
1
)
-
1
)
{
cut
=
i
;
break
;
}
}
if
(
cut
=
=
kNoCutIndex
)
cut
=
start_index
;
CutOutRange
(
masm
ranges
start_index
end_index
cut
even_label
odd_label
)
;
DCHECK_GE
(
end_index
-
start_index
2
)
;
GenerateBranches
(
masm
ranges
start_index
+
1
end_index
-
1
min_char
max_char
fall_through
even_label
odd_label
)
;
return
;
}
static
const
int
kBits
=
RegExpMacroAssembler
:
:
kTableSizeBits
;
if
(
(
max_char
>
>
kBits
)
=
=
(
min_char
>
>
kBits
)
)
{
EmitUseLookupTable
(
masm
ranges
start_index
end_index
min_char
fall_through
even_label
odd_label
)
;
return
;
}
if
(
(
min_char
>
>
kBits
)
!
=
first
>
>
kBits
)
{
masm
-
>
CheckCharacterLT
(
first
odd_label
)
;
GenerateBranches
(
masm
ranges
start_index
+
1
end_index
first
max_char
fall_through
odd_label
even_label
)
;
return
;
}
uint32_t
new_start_index
=
0
;
uint32_t
new_end_index
=
0
;
base
:
:
uc32
border
=
0
;
SplitSearchSpace
(
ranges
start_index
end_index
&
new_start_index
&
new_end_index
&
border
)
;
Label
handle_rest
;
Label
*
above
=
&
handle_rest
;
if
(
border
=
=
last
+
1
)
{
above
=
(
end_index
&
1
)
!
=
(
start_index
&
1
)
?
odd_label
:
even_label
;
DCHECK
(
new_end_index
=
=
end_index
-
1
)
;
}
DCHECK_LE
(
start_index
new_end_index
)
;
DCHECK_LE
(
new_start_index
end_index
)
;
DCHECK_LT
(
start_index
new_start_index
)
;
DCHECK_LT
(
new_end_index
end_index
)
;
DCHECK
(
new_end_index
+
1
=
=
new_start_index
|
|
(
new_end_index
+
2
=
=
new_start_index
&
&
border
=
=
ranges
-
>
at
(
new_end_index
+
1
)
)
)
;
DCHECK_LT
(
min_char
border
-
1
)
;
DCHECK_LT
(
border
max_char
)
;
DCHECK_LT
(
ranges
-
>
at
(
new_end_index
)
border
)
;
DCHECK
(
border
<
ranges
-
>
at
(
new_start_index
)
|
|
(
border
=
=
ranges
-
>
at
(
new_start_index
)
&
&
new_start_index
=
=
end_index
&
&
new_end_index
=
=
end_index
-
1
&
&
border
=
=
last
+
1
)
)
;
DCHECK
(
new_start_index
=
=
0
|
|
border
>
=
ranges
-
>
at
(
new_start_index
-
1
)
)
;
masm
-
>
CheckCharacterGT
(
border
-
1
above
)
;
Label
dummy
;
GenerateBranches
(
masm
ranges
start_index
new_end_index
min_char
border
-
1
&
dummy
even_label
odd_label
)
;
if
(
handle_rest
.
is_linked
(
)
)
{
masm
-
>
Bind
(
&
handle_rest
)
;
bool
flip
=
(
new_start_index
&
1
)
!
=
(
start_index
&
1
)
;
GenerateBranches
(
masm
ranges
new_start_index
end_index
border
max_char
&
dummy
flip
?
odd_label
:
even_label
flip
?
even_label
:
odd_label
)
;
}
}
void
EmitClassRanges
(
RegExpMacroAssembler
*
macro_assembler
RegExpClassRanges
*
cr
bool
one_byte
Label
*
on_failure
int
cp_offset
bool
check_offset
bool
preloaded
Zone
*
zone
)
{
ZoneList
<
CharacterRange
>
*
ranges
=
cr
-
>
ranges
(
zone
)
;
CharacterRange
:
:
Canonicalize
(
ranges
)
;
if
(
one_byte
)
CharacterRange
:
:
ClampToOneByte
(
ranges
)
;
const
int
ranges_length
=
ranges
-
>
length
(
)
;
if
(
ranges_length
=
=
0
)
{
if
(
!
cr
-
>
is_negated
(
)
)
{
macro_assembler
-
>
GoTo
(
on_failure
)
;
}
if
(
check_offset
)
{
macro_assembler
-
>
CheckPosition
(
cp_offset
on_failure
)
;
}
return
;
}
const
base
:
:
uc32
max_char
=
MaxCodeUnit
(
one_byte
)
;
if
(
ranges_length
=
=
1
&
&
ranges
-
>
at
(
0
)
.
IsEverything
(
max_char
)
)
{
if
(
cr
-
>
is_negated
(
)
)
{
macro_assembler
-
>
GoTo
(
on_failure
)
;
}
else
{
if
(
check_offset
)
{
macro_assembler
-
>
CheckPosition
(
cp_offset
on_failure
)
;
}
}
return
;
}
if
(
!
preloaded
)
{
macro_assembler
-
>
LoadCurrentCharacter
(
cp_offset
on_failure
check_offset
)
;
}
if
(
cr
-
>
is_standard
(
zone
)
&
&
macro_assembler
-
>
CheckSpecialClassRanges
(
cr
-
>
standard_type
(
)
on_failure
)
)
{
return
;
}
static
constexpr
int
kMaxRangesForInlineBranchGeneration
=
16
;
if
(
ranges_length
>
kMaxRangesForInlineBranchGeneration
)
{
if
(
cr
-
>
is_negated
(
)
)
{
if
(
macro_assembler
-
>
CheckCharacterInRangeArray
(
ranges
on_failure
)
)
{
return
;
}
}
else
{
if
(
macro_assembler
-
>
CheckCharacterNotInRangeArray
(
ranges
on_failure
)
)
{
return
;
}
}
}
ZoneList
<
base
:
:
uc32
>
*
range_boundaries
=
zone
-
>
New
<
ZoneList
<
base
:
:
uc32
>
>
(
ranges_length
*
2
zone
)
;
bool
zeroth_entry_is_failure
=
!
cr
-
>
is_negated
(
)
;
for
(
int
i
=
0
;
i
<
ranges_length
;
i
+
+
)
{
CharacterRange
&
range
=
ranges
-
>
at
(
i
)
;
if
(
range
.
from
(
)
=
=
0
)
{
DCHECK_EQ
(
i
0
)
;
zeroth_entry_is_failure
=
!
zeroth_entry_is_failure
;
}
else
{
range_boundaries
-
>
Add
(
range
.
from
(
)
zone
)
;
}
range_boundaries
-
>
Add
(
range
.
to
(
)
+
1
zone
)
;
}
int
end_index
=
range_boundaries
-
>
length
(
)
-
1
;
if
(
range_boundaries
-
>
at
(
end_index
)
>
max_char
)
{
end_index
-
-
;
}
Label
fall_through
;
GenerateBranches
(
macro_assembler
range_boundaries
0
end_index
0
max_char
&
fall_through
zeroth_entry_is_failure
?
&
fall_through
:
on_failure
zeroth_entry_is_failure
?
on_failure
:
&
fall_through
)
;
macro_assembler
-
>
Bind
(
&
fall_through
)
;
}
}
RegExpNode
:
:
~
RegExpNode
(
)
=
default
;
RegExpNode
:
:
LimitResult
RegExpNode
:
:
LimitVersions
(
RegExpCompiler
*
compiler
Trace
*
trace
)
{
if
(
trace
-
>
stop_node
(
)
!
=
nullptr
)
{
return
CONTINUE
;
}
RegExpMacroAssembler
*
macro_assembler
=
compiler
-
>
macro_assembler
(
)
;
if
(
trace
-
>
is_trivial
(
)
)
{
if
(
label_
.
is_bound
(
)
|
|
on_work_list
(
)
|
|
!
KeepRecursing
(
compiler
)
)
{
macro_assembler
-
>
GoTo
(
&
label_
)
;
compiler
-
>
AddWork
(
this
)
;
return
DONE
;
}
macro_assembler
-
>
Bind
(
&
label_
)
;
return
CONTINUE
;
}
trace_count_
+
+
;
if
(
KeepRecursing
(
compiler
)
&
&
compiler
-
>
optimize
(
)
&
&
trace_count_
<
kMaxCopiesCodeGenerated
)
{
return
CONTINUE
;
}
bool
was_limiting
=
compiler
-
>
limiting_recursion
(
)
;
compiler
-
>
set_limiting_recursion
(
true
)
;
trace
-
>
Flush
(
compiler
this
)
;
compiler
-
>
set_limiting_recursion
(
was_limiting
)
;
return
DONE
;
}
bool
RegExpNode
:
:
KeepRecursing
(
RegExpCompiler
*
compiler
)
{
return
!
compiler
-
>
limiting_recursion
(
)
&
&
compiler
-
>
recursion_depth
(
)
<
=
RegExpCompiler
:
:
kMaxRecursion
;
}
void
ActionNode
:
:
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
{
std
:
:
optional
<
RegExpFlags
>
old_flags
;
if
(
action_type_
=
=
MODIFY_FLAGS
)
{
old_flags
=
bm
-
>
compiler
(
)
-
>
flags
(
)
;
bm
-
>
compiler
(
)
-
>
set_flags
(
flags
(
)
)
;
}
if
(
action_type_
=
=
BEGIN_POSITIVE_SUBMATCH
)
{
success_node
(
)
-
>
on_success
(
)
-
>
FillInBMInfo
(
isolate
offset
budget
-
1
bm
not_at_start
)
;
}
else
if
(
action_type_
!
=
POSITIVE_SUBMATCH_SUCCESS
)
{
on_success
(
)
-
>
FillInBMInfo
(
isolate
offset
budget
-
1
bm
not_at_start
)
;
}
SaveBMInfo
(
bm
not_at_start
offset
)
;
if
(
old_flags
.
has_value
(
)
)
{
bm
-
>
compiler
(
)
-
>
set_flags
(
*
old_flags
)
;
}
}
void
ActionNode
:
:
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
filled_in
bool
not_at_start
)
{
if
(
action_type_
=
=
SET_REGISTER_FOR_LOOP
)
{
on_success
(
)
-
>
GetQuickCheckDetailsFromLoopEntry
(
details
compiler
filled_in
not_at_start
)
;
}
else
if
(
action_type_
=
=
BEGIN_POSITIVE_SUBMATCH
)
{
success_node
(
)
-
>
on_success
(
)
-
>
GetQuickCheckDetails
(
details
compiler
filled_in
not_at_start
)
;
}
else
if
(
action_type
(
)
!
=
POSITIVE_SUBMATCH_SUCCESS
)
{
std
:
:
optional
<
RegExpFlags
>
old_flags
;
if
(
action_type
(
)
=
=
MODIFY_FLAGS
)
{
old_flags
=
compiler
-
>
flags
(
)
;
compiler
-
>
set_flags
(
flags
(
)
)
;
}
on_success
(
)
-
>
GetQuickCheckDetails
(
details
compiler
filled_in
not_at_start
)
;
if
(
old_flags
.
has_value
(
)
)
{
compiler
-
>
set_flags
(
*
old_flags
)
;
}
}
}
void
AssertionNode
:
:
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
{
if
(
assertion_type
(
)
=
=
AT_START
&
&
not_at_start
)
return
;
on_success
(
)
-
>
FillInBMInfo
(
isolate
offset
budget
-
1
bm
not_at_start
)
;
SaveBMInfo
(
bm
not_at_start
offset
)
;
}
void
NegativeLookaroundChoiceNode
:
:
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
filled_in
bool
not_at_start
)
{
RegExpNode
*
node
=
continue_node
(
)
;
return
node
-
>
GetQuickCheckDetails
(
details
compiler
filled_in
not_at_start
)
;
}
namespace
{
inline
uint32_t
SmearBitsRight
(
uint32_t
v
)
{
v
|
=
v
>
>
1
;
v
|
=
v
>
>
2
;
v
|
=
v
>
>
4
;
v
|
=
v
>
>
8
;
v
|
=
v
>
>
16
;
return
v
;
}
}
bool
QuickCheckDetails
:
:
Rationalize
(
bool
asc
)
{
bool
found_useful_op
=
false
;
const
uint32_t
char_mask
=
CharMask
(
asc
)
;
mask_
=
0
;
value_
=
0
;
int
char_shift
=
0
;
for
(
int
i
=
0
;
i
<
characters_
;
i
+
+
)
{
Position
*
pos
=
&
positions_
[
i
]
;
if
(
(
pos
-
>
mask
&
String
:
:
kMaxOneByteCharCode
)
!
=
0
)
{
found_useful_op
=
true
;
}
mask_
|
=
(
pos
-
>
mask
&
char_mask
)
<
<
char_shift
;
value_
|
=
(
pos
-
>
value
&
char_mask
)
<
<
char_shift
;
char_shift
+
=
asc
?
8
:
16
;
}
return
found_useful_op
;
}
uint32_t
RegExpNode
:
:
EatsAtLeast
(
bool
not_at_start
)
{
return
not_at_start
?
eats_at_least_
.
eats_at_least_from_not_start
:
eats_at_least_
.
eats_at_least_from_possibly_start
;
}
EatsAtLeastInfo
RegExpNode
:
:
EatsAtLeastFromLoopEntry
(
)
{
UNREACHABLE
(
)
;
}
void
RegExpNode
:
:
GetQuickCheckDetailsFromLoopEntry
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
{
UNREACHABLE
(
)
;
}
EatsAtLeastInfo
LoopChoiceNode
:
:
EatsAtLeastFromLoopEntry
(
)
{
DCHECK_EQ
(
alternatives_
-
>
length
(
)
2
)
;
if
(
read_backward
(
)
)
{
DCHECK_EQ
(
eats_at_least_info
(
)
-
>
eats_at_least_from_possibly_start
0
)
;
DCHECK_EQ
(
eats_at_least_info
(
)
-
>
eats_at_least_from_not_start
0
)
;
return
{
}
;
}
uint8_t
loop_body_from_not_start
=
base
:
:
saturated_cast
<
uint8_t
>
(
static_cast
<
int
>
(
loop_node_
-
>
EatsAtLeast
(
true
)
)
-
static_cast
<
int
>
(
continue_node_
-
>
EatsAtLeast
(
true
)
)
)
;
uint8_t
loop_body_from_possibly_start
=
base
:
:
saturated_cast
<
uint8_t
>
(
static_cast
<
int
>
(
loop_node_
-
>
EatsAtLeast
(
false
)
)
-
static_cast
<
int
>
(
continue_node_
-
>
EatsAtLeast
(
true
)
)
)
;
int
loop_iterations
=
base
:
:
saturated_cast
<
uint8_t
>
(
min_loop_iterations
(
)
)
;
EatsAtLeastInfo
result
;
result
.
eats_at_least_from_not_start
=
base
:
:
saturated_cast
<
uint8_t
>
(
loop_iterations
*
loop_body_from_not_start
+
continue_node_
-
>
EatsAtLeast
(
true
)
)
;
if
(
loop_iterations
>
0
&
&
loop_body_from_possibly_start
>
0
)
{
result
.
eats_at_least_from_possibly_start
=
base
:
:
saturated_cast
<
uint8_t
>
(
loop_body_from_possibly_start
+
(
loop_iterations
-
1
)
*
loop_body_from_not_start
+
continue_node_
-
>
EatsAtLeast
(
true
)
)
;
}
else
{
result
.
eats_at_least_from_possibly_start
=
continue_node_
-
>
EatsAtLeast
(
false
)
;
}
return
result
;
}
bool
RegExpNode
:
:
EmitQuickCheck
(
RegExpCompiler
*
compiler
Trace
*
bounds_check_trace
Trace
*
trace
bool
preload_has_checked_bounds
Label
*
on_possible_success
QuickCheckDetails
*
details
bool
fall_through_on_failure
ChoiceNode
*
predecessor
)
{
DCHECK_NOT_NULL
(
predecessor
)
;
if
(
details
-
>
characters
(
)
=
=
0
)
return
false
;
GetQuickCheckDetails
(
details
compiler
0
trace
-
>
at_start
(
)
=
=
Trace
:
:
FALSE_VALUE
)
;
if
(
details
-
>
cannot_match
(
)
)
return
false
;
if
(
!
details
-
>
Rationalize
(
compiler
-
>
one_byte
(
)
)
)
return
false
;
DCHECK
(
details
-
>
characters
(
)
=
=
1
|
|
compiler
-
>
macro_assembler
(
)
-
>
CanReadUnaligned
(
)
)
;
uint32_t
mask
=
details
-
>
mask
(
)
;
uint32_t
value
=
details
-
>
value
(
)
;
RegExpMacroAssembler
*
assembler
=
compiler
-
>
macro_assembler
(
)
;
if
(
trace
-
>
characters_preloaded
(
)
!
=
details
-
>
characters
(
)
)
{
DCHECK
(
trace
-
>
cp_offset
(
)
=
=
bounds_check_trace
-
>
cp_offset
(
)
)
;
int
eats_at_least
=
predecessor
-
>
EatsAtLeast
(
bounds_check_trace
-
>
at_start
(
)
=
=
Trace
:
:
FALSE_VALUE
)
;
DCHECK_GE
(
eats_at_least
details
-
>
characters
(
)
)
;
assembler
-
>
LoadCurrentCharacter
(
trace
-
>
cp_offset
(
)
bounds_check_trace
-
>
backtrack
(
)
!
preload_has_checked_bounds
details
-
>
characters
(
)
eats_at_least
)
;
}
bool
need_mask
=
true
;
if
(
details
-
>
characters
(
)
=
=
1
)
{
const
uint32_t
char_mask
=
CharMask
(
compiler
-
>
one_byte
(
)
)
;
if
(
(
mask
&
char_mask
)
=
=
char_mask
)
need_mask
=
false
;
mask
&
=
char_mask
;
}
else
{
static
const
uint32_t
kTwoByteMask
=
0xFFFF
;
static
const
uint32_t
kFourByteMask
=
0xFFFFFFFF
;
if
(
details
-
>
characters
(
)
=
=
2
&
&
compiler
-
>
one_byte
(
)
)
{
if
(
(
mask
&
kTwoByteMask
)
=
=
kTwoByteMask
)
need_mask
=
false
;
}
else
if
(
details
-
>
characters
(
)
=
=
1
&
&
!
compiler
-
>
one_byte
(
)
)
{
if
(
(
mask
&
kTwoByteMask
)
=
=
kTwoByteMask
)
need_mask
=
false
;
}
else
{
if
(
mask
=
=
kFourByteMask
)
need_mask
=
false
;
}
}
if
(
fall_through_on_failure
)
{
if
(
need_mask
)
{
assembler
-
>
CheckCharacterAfterAnd
(
value
mask
on_possible_success
)
;
}
else
{
assembler
-
>
CheckCharacter
(
value
on_possible_success
)
;
}
}
else
{
if
(
need_mask
)
{
assembler
-
>
CheckNotCharacterAfterAnd
(
value
mask
trace
-
>
backtrack
(
)
)
;
}
else
{
assembler
-
>
CheckNotCharacter
(
value
trace
-
>
backtrack
(
)
)
;
}
}
return
true
;
}
void
TextNode
:
:
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
{
if
(
read_backward
(
)
)
return
;
Isolate
*
isolate
=
compiler
-
>
macro_assembler
(
)
-
>
isolate
(
)
;
DCHECK
(
characters_filled_in
<
details
-
>
characters
(
)
)
;
int
characters
=
details
-
>
characters
(
)
;
const
uint32_t
char_mask
=
CharMask
(
compiler
-
>
one_byte
(
)
)
;
for
(
int
k
=
0
;
k
<
elements
(
)
-
>
length
(
)
;
k
+
+
)
{
TextElement
elm
=
elements
(
)
-
>
at
(
k
)
;
if
(
elm
.
text_type
(
)
=
=
TextElement
:
:
ATOM
)
{
base
:
:
Vector
<
const
base
:
:
uc16
>
quarks
=
elm
.
atom
(
)
-
>
data
(
)
;
for
(
int
i
=
0
;
i
<
characters
&
&
i
<
quarks
.
length
(
)
;
i
+
+
)
{
QuickCheckDetails
:
:
Position
*
pos
=
details
-
>
positions
(
characters_filled_in
)
;
base
:
:
uc16
c
=
quarks
[
i
]
;
if
(
IsIgnoreCase
(
compiler
-
>
flags
(
)
)
)
{
unibrow
:
:
uchar
chars
[
4
]
;
int
length
=
GetCaseIndependentLetters
(
isolate
c
compiler
chars
4
)
;
if
(
length
=
=
0
)
{
details
-
>
set_cannot_match
(
)
;
pos
-
>
determines_perfectly
=
false
;
return
;
}
if
(
length
=
=
1
)
{
pos
-
>
mask
=
char_mask
;
pos
-
>
value
=
chars
[
0
]
;
pos
-
>
determines_perfectly
=
true
;
}
else
{
uint32_t
common_bits
=
char_mask
;
uint32_t
bits
=
chars
[
0
]
;
for
(
int
j
=
1
;
j
<
length
;
j
+
+
)
{
uint32_t
differing_bits
=
(
(
chars
[
j
]
&
common_bits
)
^
bits
)
;
common_bits
^
=
differing_bits
;
bits
&
=
common_bits
;
}
uint32_t
one_zero
=
(
common_bits
|
~
char_mask
)
;
if
(
length
=
=
2
&
&
(
(
~
one_zero
)
&
(
(
~
one_zero
)
-
1
)
)
=
=
0
)
{
pos
-
>
determines_perfectly
=
true
;
}
pos
-
>
mask
=
common_bits
;
pos
-
>
value
=
bits
;
}
}
else
{
if
(
c
>
char_mask
)
{
details
-
>
set_cannot_match
(
)
;
pos
-
>
determines_perfectly
=
false
;
return
;
}
pos
-
>
mask
=
char_mask
;
pos
-
>
value
=
c
;
pos
-
>
determines_perfectly
=
true
;
}
characters_filled_in
+
+
;
DCHECK
(
characters_filled_in
<
=
details
-
>
characters
(
)
)
;
if
(
characters_filled_in
=
=
details
-
>
characters
(
)
)
{
return
;
}
}
}
else
{
QuickCheckDetails
:
:
Position
*
pos
=
details
-
>
positions
(
characters_filled_in
)
;
RegExpClassRanges
*
tree
=
elm
.
class_ranges
(
)
;
ZoneList
<
CharacterRange
>
*
ranges
=
tree
-
>
ranges
(
zone
(
)
)
;
if
(
tree
-
>
is_negated
(
)
|
|
ranges
-
>
is_empty
(
)
)
{
pos
-
>
mask
=
0
;
pos
-
>
value
=
0
;
}
else
{
int
first_range
=
0
;
while
(
ranges
-
>
at
(
first_range
)
.
from
(
)
>
char_mask
)
{
first_range
+
+
;
if
(
first_range
=
=
ranges
-
>
length
(
)
)
{
details
-
>
set_cannot_match
(
)
;
pos
-
>
determines_perfectly
=
false
;
return
;
}
}
CharacterRange
range
=
ranges
-
>
at
(
first_range
)
;
const
base
:
:
uc32
first_from
=
range
.
from
(
)
;
const
base
:
:
uc32
first_to
=
(
range
.
to
(
)
>
char_mask
)
?
char_mask
:
range
.
to
(
)
;
const
uint32_t
differing_bits
=
(
first_from
^
first_to
)
;
if
(
(
differing_bits
&
(
differing_bits
+
1
)
)
=
=
0
&
&
first_from
+
differing_bits
=
=
first_to
)
{
pos
-
>
determines_perfectly
=
true
;
}
uint32_t
common_bits
=
~
SmearBitsRight
(
differing_bits
)
;
uint32_t
bits
=
(
first_from
&
common_bits
)
;
for
(
int
i
=
first_range
+
1
;
i
<
ranges
-
>
length
(
)
;
i
+
+
)
{
range
=
ranges
-
>
at
(
i
)
;
const
base
:
:
uc32
from
=
range
.
from
(
)
;
if
(
from
>
char_mask
)
continue
;
const
base
:
:
uc32
to
=
(
range
.
to
(
)
>
char_mask
)
?
char_mask
:
range
.
to
(
)
;
pos
-
>
determines_perfectly
=
false
;
uint32_t
new_common_bits
=
(
from
^
to
)
;
new_common_bits
=
~
SmearBitsRight
(
new_common_bits
)
;
common_bits
&
=
new_common_bits
;
bits
&
=
new_common_bits
;
uint32_t
new_differing_bits
=
(
from
&
common_bits
)
^
bits
;
common_bits
^
=
new_differing_bits
;
bits
&
=
common_bits
;
}
pos
-
>
mask
=
common_bits
;
pos
-
>
value
=
bits
;
}
characters_filled_in
+
+
;
DCHECK
(
characters_filled_in
<
=
details
-
>
characters
(
)
)
;
if
(
characters_filled_in
=
=
details
-
>
characters
(
)
)
return
;
}
}
DCHECK
(
characters_filled_in
!
=
details
-
>
characters
(
)
)
;
if
(
!
details
-
>
cannot_match
(
)
)
{
on_success
(
)
-
>
GetQuickCheckDetails
(
details
compiler
characters_filled_in
true
)
;
}
}
void
QuickCheckDetails
:
:
Clear
(
)
{
for
(
int
i
=
0
;
i
<
characters_
;
i
+
+
)
{
positions_
[
i
]
.
mask
=
0
;
positions_
[
i
]
.
value
=
0
;
positions_
[
i
]
.
determines_perfectly
=
false
;
}
characters_
=
0
;
}
void
QuickCheckDetails
:
:
Advance
(
int
by
bool
one_byte
)
{
if
(
by
>
=
characters_
|
|
by
<
0
)
{
DCHECK_IMPLIES
(
by
<
0
characters_
=
=
0
)
;
Clear
(
)
;
return
;
}
DCHECK_LE
(
characters_
-
by
4
)
;
DCHECK_LE
(
characters_
4
)
;
for
(
int
i
=
0
;
i
<
characters_
-
by
;
i
+
+
)
{
positions_
[
i
]
=
positions_
[
by
+
i
]
;
}
for
(
int
i
=
characters_
-
by
;
i
<
characters_
;
i
+
+
)
{
positions_
[
i
]
.
mask
=
0
;
positions_
[
i
]
.
value
=
0
;
positions_
[
i
]
.
determines_perfectly
=
false
;
}
characters_
-
=
by
;
}
void
QuickCheckDetails
:
:
Merge
(
QuickCheckDetails
*
other
int
from_index
)
{
DCHECK
(
characters_
=
=
other
-
>
characters_
)
;
if
(
other
-
>
cannot_match_
)
{
return
;
}
if
(
cannot_match_
)
{
*
this
=
*
other
;
return
;
}
for
(
int
i
=
from_index
;
i
<
characters_
;
i
+
+
)
{
QuickCheckDetails
:
:
Position
*
pos
=
positions
(
i
)
;
QuickCheckDetails
:
:
Position
*
other_pos
=
other
-
>
positions
(
i
)
;
if
(
pos
-
>
mask
!
=
other_pos
-
>
mask
|
|
pos
-
>
value
!
=
other_pos
-
>
value
|
|
!
other_pos
-
>
determines_perfectly
)
{
pos
-
>
determines_perfectly
=
false
;
}
pos
-
>
mask
&
=
other_pos
-
>
mask
;
pos
-
>
value
&
=
pos
-
>
mask
;
other_pos
-
>
value
&
=
pos
-
>
mask
;
uint32_t
differing_bits
=
(
pos
-
>
value
^
other_pos
-
>
value
)
;
pos
-
>
mask
&
=
~
differing_bits
;
pos
-
>
value
&
=
pos
-
>
mask
;
}
}
class
VisitMarker
{
public
:
explicit
VisitMarker
(
NodeInfo
*
info
)
:
info_
(
info
)
{
DCHECK
(
!
info
-
>
visited
)
;
info
-
>
visited
=
true
;
}
~
VisitMarker
(
)
{
info_
-
>
visited
=
false
;
}
private
:
NodeInfo
*
info_
;
}
;
class
LoopInitializationMarker
{
public
:
explicit
LoopInitializationMarker
(
LoopChoiceNode
*
node
)
:
node_
(
node
)
{
DCHECK
(
!
node_
-
>
traversed_loop_initialization_node_
)
;
node_
-
>
traversed_loop_initialization_node_
=
true
;
}
~
LoopInitializationMarker
(
)
{
DCHECK
(
node_
-
>
traversed_loop_initialization_node_
)
;
node_
-
>
traversed_loop_initialization_node_
=
false
;
}
LoopInitializationMarker
(
const
LoopInitializationMarker
&
)
=
delete
;
LoopInitializationMarker
&
operator
=
(
const
LoopInitializationMarker
&
)
=
delete
;
private
:
LoopChoiceNode
*
node_
;
}
;
class
IterationDecrementer
{
public
:
explicit
IterationDecrementer
(
LoopChoiceNode
*
node
)
:
node_
(
node
)
{
DCHECK_GT
(
node_
-
>
min_loop_iterations_
0
)
;
-
-
node_
-
>
min_loop_iterations_
;
}
~
IterationDecrementer
(
)
{
+
+
node_
-
>
min_loop_iterations_
;
}
IterationDecrementer
(
const
IterationDecrementer
&
)
=
delete
;
IterationDecrementer
&
operator
=
(
const
IterationDecrementer
&
)
=
delete
;
private
:
LoopChoiceNode
*
node_
;
}
;
RegExpNode
*
SeqRegExpNode
:
:
FilterOneByte
(
int
depth
RegExpCompiler
*
compiler
)
{
if
(
info
(
)
-
>
replacement_calculated
)
return
replacement
(
)
;
if
(
depth
<
0
)
return
this
;
DCHECK
(
!
info
(
)
-
>
visited
)
;
VisitMarker
marker
(
info
(
)
)
;
return
FilterSuccessor
(
depth
-
1
compiler
)
;
}
RegExpNode
*
SeqRegExpNode
:
:
FilterSuccessor
(
int
depth
RegExpCompiler
*
compiler
)
{
RegExpNode
*
next
=
on_success_
-
>
FilterOneByte
(
depth
-
1
compiler
)
;
if
(
next
=
=
nullptr
)
return
set_replacement
(
nullptr
)
;
on_success_
=
next
;
return
set_replacement
(
this
)
;
}
bool
RangeContainsLatin1Equivalents
(
CharacterRange
range
)
{
return
range
.
Contains
(
0x039C
)
|
|
range
.
Contains
(
0x03BC
)
|
|
range
.
Contains
(
0x0178
)
;
}
namespace
{
bool
RangesContainLatin1Equivalents
(
ZoneList
<
CharacterRange
>
*
ranges
)
{
for
(
int
i
=
0
;
i
<
ranges
-
>
length
(
)
;
i
+
+
)
{
if
(
RangeContainsLatin1Equivalents
(
ranges
-
>
at
(
i
)
)
)
return
true
;
}
return
false
;
}
}
RegExpNode
*
TextNode
:
:
FilterOneByte
(
int
depth
RegExpCompiler
*
compiler
)
{
RegExpFlags
flags
=
compiler
-
>
flags
(
)
;
if
(
info
(
)
-
>
replacement_calculated
)
return
replacement
(
)
;
if
(
depth
<
0
)
return
this
;
DCHECK
(
!
info
(
)
-
>
visited
)
;
VisitMarker
marker
(
info
(
)
)
;
int
element_count
=
elements
(
)
-
>
length
(
)
;
for
(
int
i
=
0
;
i
<
element_count
;
i
+
+
)
{
TextElement
elm
=
elements
(
)
-
>
at
(
i
)
;
if
(
elm
.
text_type
(
)
=
=
TextElement
:
:
ATOM
)
{
base
:
:
Vector
<
const
base
:
:
uc16
>
quarks
=
elm
.
atom
(
)
-
>
data
(
)
;
for
(
int
j
=
0
;
j
<
quarks
.
length
(
)
;
j
+
+
)
{
base
:
:
uc16
c
=
quarks
[
j
]
;
if
(
!
IsIgnoreCase
(
flags
)
)
{
if
(
c
>
String
:
:
kMaxOneByteCharCode
)
return
set_replacement
(
nullptr
)
;
}
else
{
unibrow
:
:
uchar
chars
[
4
]
;
int
length
=
GetCaseIndependentLetters
(
compiler
-
>
isolate
(
)
c
compiler
chars
4
)
;
if
(
length
=
=
0
|
|
chars
[
0
]
>
String
:
:
kMaxOneByteCharCode
)
{
return
set_replacement
(
nullptr
)
;
}
}
}
}
else
{
DCHECK
(
elm
.
text_type
(
)
=
=
TextElement
:
:
CLASS_RANGES
)
;
RegExpClassRanges
*
cr
=
elm
.
class_ranges
(
)
;
ZoneList
<
CharacterRange
>
*
ranges
=
cr
-
>
ranges
(
zone
(
)
)
;
CharacterRange
:
:
Canonicalize
(
ranges
)
;
int
range_count
=
ranges
-
>
length
(
)
;
if
(
cr
-
>
is_negated
(
)
)
{
if
(
range_count
!
=
0
&
&
ranges
-
>
at
(
0
)
.
from
(
)
=
=
0
&
&
ranges
-
>
at
(
0
)
.
to
(
)
>
=
String
:
:
kMaxOneByteCharCode
)
{
bool
case_complications
=
!
IsEitherUnicode
(
flags
)
&
&
IsIgnoreCase
(
flags
)
&
&
RangesContainLatin1Equivalents
(
ranges
)
;
if
(
!
case_complications
)
{
return
set_replacement
(
nullptr
)
;
}
}
}
else
{
if
(
range_count
=
=
0
|
|
ranges
-
>
at
(
0
)
.
from
(
)
>
String
:
:
kMaxOneByteCharCode
)
{
bool
case_complications
=
!
IsEitherUnicode
(
flags
)
&
&
IsIgnoreCase
(
flags
)
&
&
RangesContainLatin1Equivalents
(
ranges
)
;
if
(
!
case_complications
)
{
return
set_replacement
(
nullptr
)
;
}
}
}
}
}
return
FilterSuccessor
(
depth
-
1
compiler
)
;
}
RegExpNode
*
LoopChoiceNode
:
:
FilterOneByte
(
int
depth
RegExpCompiler
*
compiler
)
{
if
(
info
(
)
-
>
replacement_calculated
)
return
replacement
(
)
;
if
(
depth
<
0
)
return
this
;
if
(
info
(
)
-
>
visited
)
return
this
;
{
VisitMarker
marker
(
info
(
)
)
;
RegExpNode
*
continue_replacement
=
continue_node_
-
>
FilterOneByte
(
depth
-
1
compiler
)
;
if
(
continue_replacement
=
=
nullptr
)
return
set_replacement
(
nullptr
)
;
}
return
ChoiceNode
:
:
FilterOneByte
(
depth
-
1
compiler
)
;
}
RegExpNode
*
ChoiceNode
:
:
FilterOneByte
(
int
depth
RegExpCompiler
*
compiler
)
{
if
(
info
(
)
-
>
replacement_calculated
)
return
replacement
(
)
;
if
(
depth
<
0
)
return
this
;
if
(
info
(
)
-
>
visited
)
return
this
;
VisitMarker
marker
(
info
(
)
)
;
int
choice_count
=
alternatives_
-
>
length
(
)
;
for
(
int
i
=
0
;
i
<
choice_count
;
i
+
+
)
{
GuardedAlternative
alternative
=
alternatives_
-
>
at
(
i
)
;
if
(
alternative
.
guards
(
)
!
=
nullptr
&
&
alternative
.
guards
(
)
-
>
length
(
)
!
=
0
)
{
set_replacement
(
this
)
;
return
this
;
}
}
int
surviving
=
0
;
RegExpNode
*
survivor
=
nullptr
;
for
(
int
i
=
0
;
i
<
choice_count
;
i
+
+
)
{
GuardedAlternative
alternative
=
alternatives_
-
>
at
(
i
)
;
RegExpNode
*
replacement
=
alternative
.
node
(
)
-
>
FilterOneByte
(
depth
-
1
compiler
)
;
DCHECK
(
replacement
!
=
this
)
;
if
(
replacement
!
=
nullptr
)
{
alternatives_
-
>
at
(
i
)
.
set_node
(
replacement
)
;
surviving
+
+
;
survivor
=
replacement
;
}
}
if
(
surviving
<
2
)
return
set_replacement
(
survivor
)
;
set_replacement
(
this
)
;
if
(
surviving
=
=
choice_count
)
{
return
this
;
}
ZoneList
<
GuardedAlternative
>
*
new_alternatives
=
zone
(
)
-
>
New
<
ZoneList
<
GuardedAlternative
>
>
(
surviving
zone
(
)
)
;
for
(
int
i
=
0
;
i
<
choice_count
;
i
+
+
)
{
RegExpNode
*
replacement
=
alternatives_
-
>
at
(
i
)
.
node
(
)
-
>
FilterOneByte
(
depth
-
1
compiler
)
;
if
(
replacement
!
=
nullptr
)
{
alternatives_
-
>
at
(
i
)
.
set_node
(
replacement
)
;
new_alternatives
-
>
Add
(
alternatives_
-
>
at
(
i
)
zone
(
)
)
;
}
}
alternatives_
=
new_alternatives
;
return
this
;
}
RegExpNode
*
NegativeLookaroundChoiceNode
:
:
FilterOneByte
(
int
depth
RegExpCompiler
*
compiler
)
{
if
(
info
(
)
-
>
replacement_calculated
)
return
replacement
(
)
;
if
(
depth
<
0
)
return
this
;
if
(
info
(
)
-
>
visited
)
return
this
;
VisitMarker
marker
(
info
(
)
)
;
RegExpNode
*
node
=
continue_node
(
)
;
RegExpNode
*
replacement
=
node
-
>
FilterOneByte
(
depth
-
1
compiler
)
;
if
(
replacement
=
=
nullptr
)
return
set_replacement
(
nullptr
)
;
alternatives_
-
>
at
(
kContinueIndex
)
.
set_node
(
replacement
)
;
RegExpNode
*
neg_node
=
lookaround_node
(
)
;
RegExpNode
*
neg_replacement
=
neg_node
-
>
FilterOneByte
(
depth
-
1
compiler
)
;
if
(
neg_replacement
=
=
nullptr
)
return
set_replacement
(
replacement
)
;
alternatives_
-
>
at
(
kLookaroundIndex
)
.
set_node
(
neg_replacement
)
;
return
set_replacement
(
this
)
;
}
void
LoopChoiceNode
:
:
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
{
if
(
body_can_be_zero_length_
|
|
info
(
)
-
>
visited
)
return
;
not_at_start
=
not_at_start
|
|
this
-
>
not_at_start
(
)
;
DCHECK_EQ
(
alternatives_
-
>
length
(
)
2
)
;
if
(
traversed_loop_initialization_node_
&
&
min_loop_iterations_
>
0
&
&
loop_node_
-
>
EatsAtLeast
(
not_at_start
)
>
continue_node_
-
>
EatsAtLeast
(
true
)
)
{
IterationDecrementer
next_iteration
(
this
)
;
loop_node_
-
>
GetQuickCheckDetails
(
details
compiler
characters_filled_in
not_at_start
)
;
}
else
{
VisitMarker
marker
(
info
(
)
)
;
ChoiceNode
:
:
GetQuickCheckDetails
(
details
compiler
characters_filled_in
not_at_start
)
;
}
}
void
LoopChoiceNode
:
:
GetQuickCheckDetailsFromLoopEntry
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
{
if
(
traversed_loop_initialization_node_
)
{
GetQuickCheckDetails
(
details
compiler
characters_filled_in
not_at_start
)
;
}
else
{
LoopInitializationMarker
marker
(
this
)
;
GetQuickCheckDetails
(
details
compiler
characters_filled_in
not_at_start
)
;
}
}
void
LoopChoiceNode
:
:
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
{
if
(
body_can_be_zero_length_
|
|
budget
<
=
0
)
{
bm
-
>
SetRest
(
offset
)
;
SaveBMInfo
(
bm
not_at_start
offset
)
;
return
;
}
ChoiceNode
:
:
FillInBMInfo
(
isolate
offset
budget
-
1
bm
not_at_start
)
;
SaveBMInfo
(
bm
not_at_start
offset
)
;
}
void
ChoiceNode
:
:
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
characters_filled_in
bool
not_at_start
)
{
not_at_start
=
(
not_at_start
|
|
not_at_start_
)
;
int
choice_count
=
alternatives_
-
>
length
(
)
;
DCHECK_LT
(
0
choice_count
)
;
alternatives_
-
>
at
(
0
)
.
node
(
)
-
>
GetQuickCheckDetails
(
details
compiler
characters_filled_in
not_at_start
)
;
for
(
int
i
=
1
;
i
<
choice_count
;
i
+
+
)
{
QuickCheckDetails
new_details
(
details
-
>
characters
(
)
)
;
RegExpNode
*
node
=
alternatives_
-
>
at
(
i
)
.
node
(
)
;
node
-
>
GetQuickCheckDetails
(
&
new_details
compiler
characters_filled_in
not_at_start
)
;
details
-
>
Merge
(
&
new_details
characters_filled_in
)
;
}
}
namespace
{
void
EmitWordCheck
(
RegExpMacroAssembler
*
assembler
Label
*
word
Label
*
non_word
bool
fall_through_on_word
)
{
if
(
assembler
-
>
CheckSpecialClassRanges
(
fall_through_on_word
?
StandardCharacterSet
:
:
kWord
:
StandardCharacterSet
:
:
kNotWord
fall_through_on_word
?
non_word
:
word
)
)
{
return
;
}
assembler
-
>
CheckCharacterGT
(
'
z
'
non_word
)
;
assembler
-
>
CheckCharacterLT
(
'
0
'
non_word
)
;
assembler
-
>
CheckCharacterGT
(
'
a
'
-
1
word
)
;
assembler
-
>
CheckCharacterLT
(
'
9
'
+
1
word
)
;
assembler
-
>
CheckCharacterLT
(
'
A
'
non_word
)
;
assembler
-
>
CheckCharacterLT
(
'
Z
'
+
1
word
)
;
if
(
fall_through_on_word
)
{
assembler
-
>
CheckNotCharacter
(
'
_
'
non_word
)
;
}
else
{
assembler
-
>
CheckCharacter
(
'
_
'
word
)
;
}
}
void
EmitHat
(
RegExpCompiler
*
compiler
RegExpNode
*
on_success
Trace
*
trace
)
{
RegExpMacroAssembler
*
assembler
=
compiler
-
>
macro_assembler
(
)
;
Trace
new_trace
(
*
trace
)
;
new_trace
.
InvalidateCurrentCharacter
(
)
;
const
bool
may_be_at_or_before_subject_string_start
=
new_trace
.
cp_offset
(
)
<
=
0
;
Label
ok
;
if
(
may_be_at_or_before_subject_string_start
)
{
assembler
-
>
CheckAtStart
(
new_trace
.
cp_offset
(
)
&
ok
)
;
}
const
bool
can_skip_bounds_check
=
!
may_be_at_or_before_subject_string_start
;
assembler
-
>
LoadCurrentCharacter
(
new_trace
.
cp_offset
(
)
-
1
new_trace
.
backtrack
(
)
can_skip_bounds_check
)
;
if
(
!
assembler
-
>
CheckSpecialClassRanges
(
StandardCharacterSet
:
:
kLineTerminator
new_trace
.
backtrack
(
)
)
)
{
if
(
!
compiler
-
>
one_byte
(
)
)
{
assembler
-
>
CheckCharacterAfterAnd
(
0x2028
0xFFFE
&
ok
)
;
}
assembler
-
>
CheckCharacter
(
'
\
n
'
&
ok
)
;
assembler
-
>
CheckNotCharacter
(
'
\
r
'
new_trace
.
backtrack
(
)
)
;
}
assembler
-
>
Bind
(
&
ok
)
;
on_success
-
>
Emit
(
compiler
&
new_trace
)
;
}
}
void
AssertionNode
:
:
EmitBoundaryCheck
(
RegExpCompiler
*
compiler
Trace
*
trace
)
{
RegExpMacroAssembler
*
assembler
=
compiler
-
>
macro_assembler
(
)
;
Isolate
*
isolate
=
assembler
-
>
isolate
(
)
;
Trace
:
:
TriBool
next_is_word_character
=
Trace
:
:
UNKNOWN
;
bool
not_at_start
=
(
trace
-
>
at_start
(
)
=
=
Trace
:
:
FALSE_VALUE
)
;
BoyerMooreLookahead
*
lookahead
=
bm_info
(
not_at_start
)
;
if
(
lookahead
=
=
nullptr
)
{
int
eats_at_least
=
std
:
:
min
(
kMaxLookaheadForBoyerMoore
EatsAtLeast
(
not_at_start
)
)
;
if
(
eats_at_least
>
=
1
)
{
BoyerMooreLookahead
*
bm
=
zone
(
)
-
>
New
<
BoyerMooreLookahead
>
(
eats_at_least
compiler
zone
(
)
)
;
FillInBMInfo
(
isolate
0
kRecursionBudget
bm
not_at_start
)
;
if
(
bm
-
>
at
(
0
)
-
>
is_non_word
(
)
)
next_is_word_character
=
Trace
:
:
FALSE_VALUE
;
if
(
bm
-
>
at
(
0
)
-
>
is_word
(
)
)
next_is_word_character
=
Trace
:
:
TRUE_VALUE
;
}
}
else
{
if
(
lookahead
-
>
at
(
0
)
-
>
is_non_word
(
)
)
next_is_word_character
=
Trace
:
:
FALSE_VALUE
;
if
(
lookahead
-
>
at
(
0
)
-
>
is_word
(
)
)
next_is_word_character
=
Trace
:
:
TRUE_VALUE
;
}
bool
at_boundary
=
(
assertion_type_
=
=
AssertionNode
:
:
AT_BOUNDARY
)
;
if
(
next_is_word_character
=
=
Trace
:
:
UNKNOWN
)
{
Label
before_non_word
;
Label
before_word
;
if
(
trace
-
>
characters_preloaded
(
)
!
=
1
)
{
assembler
-
>
LoadCurrentCharacter
(
trace
-
>
cp_offset
(
)
&
before_non_word
)
;
}
EmitWordCheck
(
assembler
&
before_word
&
before_non_word
false
)
;
assembler
-
>
Bind
(
&
before_non_word
)
;
Label
ok
;
BacktrackIfPrevious
(
compiler
trace
at_boundary
?
kIsNonWord
:
kIsWord
)
;
assembler
-
>
GoTo
(
&
ok
)
;
assembler
-
>
Bind
(
&
before_word
)
;
BacktrackIfPrevious
(
compiler
trace
at_boundary
?
kIsWord
:
kIsNonWord
)
;
assembler
-
>
Bind
(
&
ok
)
;
}
else
if
(
next_is_word_character
=
=
Trace
:
:
TRUE_VALUE
)
{
BacktrackIfPrevious
(
compiler
trace
at_boundary
?
kIsWord
:
kIsNonWord
)
;
}
else
{
DCHECK
(
next_is_word_character
=
=
Trace
:
:
FALSE_VALUE
)
;
BacktrackIfPrevious
(
compiler
trace
at_boundary
?
kIsNonWord
:
kIsWord
)
;
}
}
void
AssertionNode
:
:
BacktrackIfPrevious
(
RegExpCompiler
*
compiler
Trace
*
trace
AssertionNode
:
:
IfPrevious
backtrack_if_previous
)
{
RegExpMacroAssembler
*
assembler
=
compiler
-
>
macro_assembler
(
)
;
Trace
new_trace
(
*
trace
)
;
new_trace
.
InvalidateCurrentCharacter
(
)
;
Label
fall_through
;
Label
*
non_word
=
backtrack_if_previous
=
=
kIsNonWord
?
new_trace
.
backtrack
(
)
:
&
fall_through
;
Label
*
word
=
backtrack_if_previous
=
=
kIsNonWord
?
&
fall_through
:
new_trace
.
backtrack
(
)
;
const
bool
may_be_at_or_before_subject_string_start
=
new_trace
.
cp_offset
(
)
<
=
0
;
if
(
may_be_at_or_before_subject_string_start
)
{
assembler
-
>
CheckAtStart
(
new_trace
.
cp_offset
(
)
non_word
)
;
}
const
bool
can_skip_bounds_check
=
!
may_be_at_or_before_subject_string_start
;
assembler
-
>
LoadCurrentCharacter
(
new_trace
.
cp_offset
(
)
-
1
non_word
can_skip_bounds_check
)
;
EmitWordCheck
(
assembler
word
non_word
backtrack_if_previous
=
=
kIsNonWord
)
;
assembler
-
>
Bind
(
&
fall_through
)
;
on_success
(
)
-
>
Emit
(
compiler
&
new_trace
)
;
}
void
AssertionNode
:
:
GetQuickCheckDetails
(
QuickCheckDetails
*
details
RegExpCompiler
*
compiler
int
filled_in
bool
not_at_start
)
{
if
(
assertion_type_
=
=
AT_START
&
&
not_at_start
)
{
details
-
>
set_cannot_match
(
)
;
return
;
}
return
on_success
(
)
-
>
GetQuickCheckDetails
(
details
compiler
filled_in
not_at_start
)
;
}
void
AssertionNode
:
:
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
{
RegExpMacroAssembler
*
assembler
=
compiler
-
>
macro_assembler
(
)
;
switch
(
assertion_type_
)
{
case
AT_END
:
{
Label
ok
;
assembler
-
>
CheckPosition
(
trace
-
>
cp_offset
(
)
&
ok
)
;
assembler
-
>
GoTo
(
trace
-
>
backtrack
(
)
)
;
assembler
-
>
Bind
(
&
ok
)
;
break
;
}
case
AT_START
:
{
if
(
trace
-
>
at_start
(
)
=
=
Trace
:
:
FALSE_VALUE
)
{
assembler
-
>
GoTo
(
trace
-
>
backtrack
(
)
)
;
return
;
}
if
(
trace
-
>
at_start
(
)
=
=
Trace
:
:
UNKNOWN
)
{
assembler
-
>
CheckNotAtStart
(
trace
-
>
cp_offset
(
)
trace
-
>
backtrack
(
)
)
;
Trace
at_start_trace
=
*
trace
;
at_start_trace
.
set_at_start
(
Trace
:
:
TRUE_VALUE
)
;
on_success
(
)
-
>
Emit
(
compiler
&
at_start_trace
)
;
return
;
}
}
break
;
case
AFTER_NEWLINE
:
EmitHat
(
compiler
on_success
(
)
trace
)
;
return
;
case
AT_BOUNDARY
:
case
AT_NON_BOUNDARY
:
{
EmitBoundaryCheck
(
compiler
trace
)
;
return
;
}
}
on_success
(
)
-
>
Emit
(
compiler
trace
)
;
}
namespace
{
bool
DeterminedAlready
(
QuickCheckDetails
*
quick_check
int
offset
)
{
if
(
quick_check
=
=
nullptr
)
return
false
;
if
(
offset
>
=
quick_check
-
>
characters
(
)
)
return
false
;
return
quick_check
-
>
positions
(
offset
)
-
>
determines_perfectly
;
}
void
UpdateBoundsCheck
(
int
index
int
*
checked_up_to
)
{
if
(
index
>
*
checked_up_to
)
{
*
checked_up_to
=
index
;
}
}
}
void
TextNode
:
:
TextEmitPass
(
RegExpCompiler
*
compiler
TextEmitPassType
pass
bool
preloaded
Trace
*
trace
bool
first_element_checked
int
*
checked_up_to
)
{
RegExpMacroAssembler
*
assembler
=
compiler
-
>
macro_assembler
(
)
;
Isolate
*
isolate
=
assembler
-
>
isolate
(
)
;
bool
one_byte
=
compiler
-
>
one_byte
(
)
;
Label
*
backtrack
=
trace
-
>
backtrack
(
)
;
QuickCheckDetails
*
quick_check
=
trace
-
>
quick_check_performed
(
)
;
int
element_count
=
elements
(
)
-
>
length
(
)
;
int
backward_offset
=
read_backward
(
)
?
-
Length
(
)
:
0
;
for
(
int
i
=
preloaded
?
0
:
element_count
-
1
;
i
>
=
0
;
i
-
-
)
{
TextElement
elm
=
elements
(
)
-
>
at
(
i
)
;
int
cp_offset
=
trace
-
>
cp_offset
(
)
+
elm
.
cp_offset
(
)
+
backward_offset
;
if
(
elm
.
text_type
(
)
=
=
TextElement
:
:
ATOM
)
{
base
:
:
Vector
<
const
base
:
:
uc16
>
quarks
=
elm
.
atom
(
)
-
>
data
(
)
;
for
(
int
j
=
preloaded
?
0
:
quarks
.
length
(
)
-
1
;
j
>
=
0
;
j
-
-
)
{
if
(
first_element_checked
&
&
i
=
=
0
&
&
j
=
=
0
)
continue
;
if
(
DeterminedAlready
(
quick_check
elm
.
cp_offset
(
)
+
j
)
)
continue
;
base
:
:
uc16
quark
=
quarks
[
j
]
;
bool
needs_bounds_check
=
*
checked_up_to
<
cp_offset
+
j
|
|
read_backward
(
)
;
bool
bounds_checked
=
false
;
switch
(
pass
)
{
case
NON_LATIN1_MATCH
:
{
DCHECK
(
one_byte
)
;
if
(
IsIgnoreCase
(
compiler
-
>
flags
(
)
)
)
{
unibrow
:
:
uchar
chars
[
4
]
;
int
length
=
GetCaseIndependentLetters
(
isolate
quark
compiler
chars
4
)
;
if
(
length
=
=
0
)
{
assembler
-
>
GoTo
(
backtrack
)
;
return
;
}
}
else
{
if
(
quark
>
String
:
:
kMaxOneByteCharCode
)
{
assembler
-
>
GoTo
(
backtrack
)
;
return
;
}
}
break
;
}
case
NON_LETTER_CHARACTER_MATCH
:
bounds_checked
=
EmitAtomNonLetter
(
isolate
compiler
quark
backtrack
cp_offset
+
j
needs_bounds_check
preloaded
)
;
break
;
case
SIMPLE_CHARACTER_MATCH
:
bounds_checked
=
EmitSimpleCharacter
(
isolate
compiler
quark
backtrack
cp_offset
+
j
needs_bounds_check
preloaded
)
;
break
;
case
CASE_CHARACTER_MATCH
:
bounds_checked
=
EmitAtomLetter
(
isolate
compiler
quark
backtrack
cp_offset
+
j
needs_bounds_check
preloaded
)
;
break
;
default
:
break
;
}
if
(
bounds_checked
)
UpdateBoundsCheck
(
cp_offset
+
j
checked_up_to
)
;
}
}
else
{
DCHECK_EQ
(
TextElement
:
:
CLASS_RANGES
elm
.
text_type
(
)
)
;
if
(
pass
=
=
CHARACTER_CLASS_MATCH
)
{
if
(
first_element_checked
&
&
i
=
=
0
)
continue
;
if
(
DeterminedAlready
(
quick_check
elm
.
cp_offset
(
)
)
)
continue
;
RegExpClassRanges
*
cr
=
elm
.
class_ranges
(
)
;
bool
bounds_check
=
*
checked_up_to
<
cp_offset
|
|
read_backward
(
)
;
EmitClassRanges
(
assembler
cr
one_byte
backtrack
cp_offset
bounds_check
preloaded
zone
(
)
)
;
UpdateBoundsCheck
(
cp_offset
checked_up_to
)
;
}
}
}
}
int
TextNode
:
:
Length
(
)
{
TextElement
elm
=
elements
(
)
-
>
last
(
)
;
DCHECK_LE
(
0
elm
.
cp_offset
(
)
)
;
return
elm
.
cp_offset
(
)
+
elm
.
length
(
)
;
}
TextNode
*
TextNode
:
:
CreateForCharacterRanges
(
Zone
*
zone
ZoneList
<
CharacterRange
>
*
ranges
bool
read_backward
RegExpNode
*
on_success
)
{
DCHECK_NOT_NULL
(
ranges
)
;
return
zone
-
>
New
<
TextNode
>
(
zone
-
>
New
<
RegExpClassRanges
>
(
zone
ranges
)
read_backward
on_success
)
;
}
TextNode
*
TextNode
:
:
CreateForSurrogatePair
(
Zone
*
zone
CharacterRange
lead
ZoneList
<
CharacterRange
>
*
trail_ranges
bool
read_backward
RegExpNode
*
on_success
)
{
ZoneList
<
TextElement
>
*
elms
=
zone
-
>
New
<
ZoneList
<
TextElement
>
>
(
2
zone
)
;
if
(
lead
.
from
(
)
=
=
lead
.
to
(
)
)
{
ZoneList
<
base
:
:
uc16
>
lead_surrogate
(
1
zone
)
;
lead_surrogate
.
Add
(
lead
.
from
(
)
zone
)
;
RegExpAtom
*
atom
=
zone
-
>
New
<
RegExpAtom
>
(
lead_surrogate
.
ToConstVector
(
)
)
;
elms
-
>
Add
(
TextElement
:
:
Atom
(
atom
)
zone
)
;
}
else
{
ZoneList
<
CharacterRange
>
*
lead_ranges
=
CharacterRange
:
:
List
(
zone
lead
)
;
elms
-
>
Add
(
TextElement
:
:
ClassRanges
(
zone
-
>
New
<
RegExpClassRanges
>
(
zone
lead_ranges
)
)
zone
)
;
}
elms
-
>
Add
(
TextElement
:
:
ClassRanges
(
zone
-
>
New
<
RegExpClassRanges
>
(
zone
trail_ranges
)
)
zone
)
;
return
zone
-
>
New
<
TextNode
>
(
elms
read_backward
on_success
)
;
}
TextNode
*
TextNode
:
:
CreateForSurrogatePair
(
Zone
*
zone
ZoneList
<
CharacterRange
>
*
lead_ranges
CharacterRange
trail
bool
read_backward
RegExpNode
*
on_success
)
{
ZoneList
<
CharacterRange
>
*
trail_ranges
=
CharacterRange
:
:
List
(
zone
trail
)
;
ZoneList
<
TextElement
>
*
elms
=
zone
-
>
New
<
ZoneList
<
TextElement
>
>
(
2
zone
)
;
elms
-
>
Add
(
TextElement
:
:
ClassRanges
(
zone
-
>
New
<
RegExpClassRanges
>
(
zone
lead_ranges
)
)
zone
)
;
elms
-
>
Add
(
TextElement
:
:
ClassRanges
(
zone
-
>
New
<
RegExpClassRanges
>
(
zone
trail_ranges
)
)
zone
)
;
return
zone
-
>
New
<
TextNode
>
(
elms
read_backward
on_success
)
;
}
void
TextNode
:
:
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
{
LimitResult
limit_result
=
LimitVersions
(
compiler
trace
)
;
if
(
limit_result
=
=
DONE
)
return
;
DCHECK
(
limit_result
=
=
CONTINUE
)
;
if
(
trace
-
>
cp_offset
(
)
+
Length
(
)
>
RegExpMacroAssembler
:
:
kMaxCPOffset
)
{
compiler
-
>
SetRegExpTooBig
(
)
;
return
;
}
if
(
compiler
-
>
one_byte
(
)
)
{
int
dummy
=
0
;
TextEmitPass
(
compiler
NON_LATIN1_MATCH
false
trace
false
&
dummy
)
;
}
bool
first_elt_done
=
false
;
int
bound_checked_to
=
trace
-
>
cp_offset
(
)
-
1
;
bound_checked_to
+
=
trace
-
>
bound_checked_up_to
(
)
;
for
(
int
twice
=
0
;
twice
<
2
;
twice
+
+
)
{
bool
is_preloaded_pass
=
twice
=
=
0
;
if
(
is_preloaded_pass
&
&
trace
-
>
characters_preloaded
(
)
!
=
1
)
continue
;
if
(
IsIgnoreCase
(
compiler
-
>
flags
(
)
)
)
{
TextEmitPass
(
compiler
NON_LETTER_CHARACTER_MATCH
is_preloaded_pass
trace
first_elt_done
&
bound_checked_to
)
;
TextEmitPass
(
compiler
CASE_CHARACTER_MATCH
is_preloaded_pass
trace
first_elt_done
&
bound_checked_to
)
;
}
else
{
TextEmitPass
(
compiler
SIMPLE_CHARACTER_MATCH
is_preloaded_pass
trace
first_elt_done
&
bound_checked_to
)
;
}
TextEmitPass
(
compiler
CHARACTER_CLASS_MATCH
is_preloaded_pass
trace
first_elt_done
&
bound_checked_to
)
;
first_elt_done
=
true
;
}
Trace
successor_trace
(
*
trace
)
;
successor_trace
.
AdvanceCurrentPositionInTrace
(
read_backward
(
)
?
-
Length
(
)
:
Length
(
)
compiler
)
;
successor_trace
.
set_at_start
(
read_backward
(
)
?
Trace
:
:
UNKNOWN
:
Trace
:
:
FALSE_VALUE
)
;
RecursionCheck
rc
(
compiler
)
;
on_success
(
)
-
>
Emit
(
compiler
&
successor_trace
)
;
}
void
Trace
:
:
InvalidateCurrentCharacter
(
)
{
characters_preloaded_
=
0
;
}
void
Trace
:
:
AdvanceCurrentPositionInTrace
(
int
by
RegExpCompiler
*
compiler
)
{
characters_preloaded_
=
0
;
quick_check_performed_
.
Advance
(
by
compiler
-
>
one_byte
(
)
)
;
cp_offset_
+
=
by
;
if
(
cp_offset_
>
RegExpMacroAssembler
:
:
kMaxCPOffset
)
{
compiler
-
>
SetRegExpTooBig
(
)
;
cp_offset_
=
0
;
}
bound_checked_up_to_
=
std
:
:
max
(
0
bound_checked_up_to_
-
by
)
;
}
void
TextNode
:
:
MakeCaseIndependent
(
Isolate
*
isolate
bool
is_one_byte
RegExpFlags
flags
)
{
if
(
!
IsIgnoreCase
(
flags
)
)
return
;
#
ifdef
V8_INTL_SUPPORT
if
(
NeedsUnicodeCaseEquivalents
(
flags
)
)
return
;
#
endif
int
element_count
=
elements
(
)
-
>
length
(
)
;
for
(
int
i
=
0
;
i
<
element_count
;
i
+
+
)
{
TextElement
elm
=
elements
(
)
-
>
at
(
i
)
;
if
(
elm
.
text_type
(
)
=
=
TextElement
:
:
CLASS_RANGES
)
{
RegExpClassRanges
*
cr
=
elm
.
class_ranges
(
)
;
if
(
cr
-
>
is_standard
(
zone
(
)
)
)
continue
;
ZoneList
<
CharacterRange
>
*
ranges
=
cr
-
>
ranges
(
zone
(
)
)
;
CharacterRange
:
:
AddCaseEquivalents
(
isolate
zone
(
)
ranges
is_one_byte
)
;
}
}
}
int
TextNode
:
:
GreedyLoopTextLength
(
)
{
return
Length
(
)
;
}
RegExpNode
*
TextNode
:
:
GetSuccessorOfOmnivorousTextNode
(
RegExpCompiler
*
compiler
)
{
if
(
read_backward
(
)
)
return
nullptr
;
if
(
elements
(
)
-
>
length
(
)
!
=
1
)
return
nullptr
;
TextElement
elm
=
elements
(
)
-
>
at
(
0
)
;
if
(
elm
.
text_type
(
)
!
=
TextElement
:
:
CLASS_RANGES
)
return
nullptr
;
RegExpClassRanges
*
node
=
elm
.
class_ranges
(
)
;
ZoneList
<
CharacterRange
>
*
ranges
=
node
-
>
ranges
(
zone
(
)
)
;
CharacterRange
:
:
Canonicalize
(
ranges
)
;
if
(
node
-
>
is_negated
(
)
)
{
return
ranges
-
>
length
(
)
=
=
0
?
on_success
(
)
:
nullptr
;
}
if
(
ranges
-
>
length
(
)
!
=
1
)
return
nullptr
;
const
base
:
:
uc32
max_char
=
MaxCodeUnit
(
compiler
-
>
one_byte
(
)
)
;
return
ranges
-
>
at
(
0
)
.
IsEverything
(
max_char
)
?
on_success
(
)
:
nullptr
;
}
int
ChoiceNode
:
:
GreedyLoopTextLengthForAlternative
(
GuardedAlternative
*
alternative
)
{
int
length
=
0
;
RegExpNode
*
node
=
alternative
-
>
node
(
)
;
int
recursion_depth
=
0
;
while
(
node
!
=
this
)
{
if
(
recursion_depth
+
+
>
RegExpCompiler
:
:
kMaxRecursion
)
{
return
kNodeIsTooComplexForGreedyLoops
;
}
int
node_length
=
node
-
>
GreedyLoopTextLength
(
)
;
if
(
node_length
=
=
kNodeIsTooComplexForGreedyLoops
)
{
return
kNodeIsTooComplexForGreedyLoops
;
}
length
+
=
node_length
;
node
=
node
-
>
AsSeqRegExpNode
(
)
-
>
on_success
(
)
;
}
if
(
read_backward
(
)
)
{
length
=
-
length
;
}
if
(
length
<
RegExpMacroAssembler
:
:
kMinCPOffset
|
|
length
>
RegExpMacroAssembler
:
:
kMaxCPOffset
)
{
return
kNodeIsTooComplexForGreedyLoops
;
}
return
length
;
}
void
LoopChoiceNode
:
:
AddLoopAlternative
(
GuardedAlternative
alt
)
{
DCHECK_NULL
(
loop_node_
)
;
AddAlternative
(
alt
)
;
loop_node_
=
alt
.
node
(
)
;
}
void
LoopChoiceNode
:
:
AddContinueAlternative
(
GuardedAlternative
alt
)
{
DCHECK_NULL
(
continue_node_
)
;
AddAlternative
(
alt
)
;
continue_node_
=
alt
.
node
(
)
;
}
void
LoopChoiceNode
:
:
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
{
RegExpMacroAssembler
*
macro_assembler
=
compiler
-
>
macro_assembler
(
)
;
if
(
trace
-
>
stop_node
(
)
=
=
this
)
{
int
text_length
=
GreedyLoopTextLengthForAlternative
(
&
(
alternatives_
-
>
at
(
0
)
)
)
;
DCHECK_NE
(
kNodeIsTooComplexForGreedyLoops
text_length
)
;
DCHECK
(
trace
-
>
cp_offset
(
)
=
=
text_length
)
;
macro_assembler
-
>
AdvanceCurrentPosition
(
text_length
)
;
macro_assembler
-
>
GoTo
(
trace
-
>
loop_label
(
)
)
;
return
;
}
DCHECK_NULL
(
trace
-
>
stop_node
(
)
)
;
if
(
!
trace
-
>
is_trivial
(
)
)
{
trace
-
>
Flush
(
compiler
this
)
;
return
;
}
ChoiceNode
:
:
Emit
(
compiler
trace
)
;
}
int
ChoiceNode
:
:
CalculatePreloadCharacters
(
RegExpCompiler
*
compiler
int
eats_at_least
)
{
int
preload_characters
=
std
:
:
min
(
4
eats_at_least
)
;
DCHECK_LE
(
preload_characters
4
)
;
if
(
compiler
-
>
macro_assembler
(
)
-
>
CanReadUnaligned
(
)
)
{
bool
one_byte
=
compiler
-
>
one_byte
(
)
;
if
(
one_byte
)
{
if
(
preload_characters
=
=
3
)
preload_characters
=
2
;
}
else
{
if
(
preload_characters
>
2
)
preload_characters
=
2
;
}
}
else
{
if
(
preload_characters
>
1
)
preload_characters
=
1
;
}
return
preload_characters
;
}
class
AlternativeGeneration
:
public
Malloced
{
public
:
AlternativeGeneration
(
)
:
possible_success
(
)
expects_preload
(
false
)
after
(
)
quick_check_details
(
)
{
}
Label
possible_success
;
bool
expects_preload
;
Label
after
;
QuickCheckDetails
quick_check_details
;
}
;
class
AlternativeGenerationList
{
public
:
AlternativeGenerationList
(
int
count
Zone
*
zone
)
:
alt_gens_
(
count
zone
)
{
for
(
int
i
=
0
;
i
<
count
&
&
i
<
kAFew
;
i
+
+
)
{
alt_gens_
.
Add
(
a_few_alt_gens_
+
i
zone
)
;
}
for
(
int
i
=
kAFew
;
i
<
count
;
i
+
+
)
{
alt_gens_
.
Add
(
new
AlternativeGeneration
(
)
zone
)
;
}
}
~
AlternativeGenerationList
(
)
{
for
(
int
i
=
kAFew
;
i
<
alt_gens_
.
length
(
)
;
i
+
+
)
{
delete
alt_gens_
[
i
]
;
alt_gens_
[
i
]
=
nullptr
;
}
}
AlternativeGeneration
*
at
(
int
i
)
{
return
alt_gens_
[
i
]
;
}
private
:
static
const
int
kAFew
=
10
;
ZoneList
<
AlternativeGeneration
*
>
alt_gens_
;
AlternativeGeneration
a_few_alt_gens_
[
kAFew
]
;
}
;
void
BoyerMoorePositionInfo
:
:
Set
(
int
character
)
{
SetInterval
(
Interval
(
character
character
)
)
;
}
namespace
{
ContainedInLattice
AddRange
(
ContainedInLattice
containment
const
int
*
ranges
int
ranges_length
Interval
new_range
)
{
DCHECK_EQ
(
1
ranges_length
&
1
)
;
DCHECK_EQ
(
String
:
:
kMaxCodePoint
+
1
ranges
[
ranges_length
-
1
]
)
;
if
(
containment
=
=
kLatticeUnknown
)
return
containment
;
bool
inside
=
false
;
int
last
=
0
;
for
(
int
i
=
0
;
i
<
ranges_length
;
inside
=
!
inside
last
=
ranges
[
i
]
i
+
+
)
{
if
(
ranges
[
i
]
<
=
new_range
.
from
(
)
)
continue
;
if
(
last
<
=
new_range
.
from
(
)
&
&
new_range
.
to
(
)
<
ranges
[
i
]
)
{
return
Combine
(
containment
inside
?
kLatticeIn
:
kLatticeOut
)
;
}
return
kLatticeUnknown
;
}
return
containment
;
}
int
BitsetFirstSetBit
(
BoyerMoorePositionInfo
:
:
Bitset
bitset
)
{
static_assert
(
BoyerMoorePositionInfo
:
:
kMapSize
=
=
2
*
kInt64Size
*
kBitsPerByte
)
;
{
static
constexpr
BoyerMoorePositionInfo
:
:
Bitset
mask
(
~
uint64_t
{
0
}
)
;
BoyerMoorePositionInfo
:
:
Bitset
masked_bitset
=
bitset
&
mask
;
static_assert
(
kInt64Size
>
=
sizeof
(
decltype
(
masked_bitset
.
to_ullong
(
)
)
)
)
;
uint64_t
lsb
=
masked_bitset
.
to_ullong
(
)
;
if
(
lsb
!
=
0
)
return
base
:
:
bits
:
:
CountTrailingZeros
(
lsb
)
;
}
{
BoyerMoorePositionInfo
:
:
Bitset
masked_bitset
=
bitset
>
>
64
;
uint64_t
msb
=
masked_bitset
.
to_ullong
(
)
;
if
(
msb
!
=
0
)
return
64
+
base
:
:
bits
:
:
CountTrailingZeros
(
msb
)
;
}
return
-
1
;
}
}
void
BoyerMoorePositionInfo
:
:
SetInterval
(
const
Interval
&
interval
)
{
w_
=
AddRange
(
w_
kWordRanges
kWordRangeCount
interval
)
;
if
(
interval
.
size
(
)
>
=
kMapSize
)
{
map_count_
=
kMapSize
;
map_
.
set
(
)
;
return
;
}
for
(
int
i
=
interval
.
from
(
)
;
i
<
=
interval
.
to
(
)
;
i
+
+
)
{
int
mod_character
=
(
i
&
kMask
)
;
if
(
!
map_
[
mod_character
]
)
{
map_count_
+
+
;
map_
.
set
(
mod_character
)
;
}
if
(
map_count_
=
=
kMapSize
)
return
;
}
}
void
BoyerMoorePositionInfo
:
:
SetAll
(
)
{
w_
=
kLatticeUnknown
;
if
(
map_count_
!
=
kMapSize
)
{
map_count_
=
kMapSize
;
map_
.
set
(
)
;
}
}
BoyerMooreLookahead
:
:
BoyerMooreLookahead
(
int
length
RegExpCompiler
*
compiler
Zone
*
zone
)
:
length_
(
length
)
compiler_
(
compiler
)
max_char_
(
MaxCodeUnit
(
compiler
-
>
one_byte
(
)
)
)
{
bitmaps_
=
zone
-
>
New
<
ZoneList
<
BoyerMoorePositionInfo
*
>
>
(
length
zone
)
;
for
(
int
i
=
0
;
i
<
length
;
i
+
+
)
{
bitmaps_
-
>
Add
(
zone
-
>
New
<
BoyerMoorePositionInfo
>
(
)
zone
)
;
}
}
bool
BoyerMooreLookahead
:
:
FindWorthwhileInterval
(
int
*
from
int
*
to
)
{
int
biggest_points
=
0
;
const
int
kMaxMax
=
32
;
for
(
int
max_number_of_chars
=
4
;
max_number_of_chars
<
kMaxMax
;
max_number_of_chars
*
=
2
)
{
biggest_points
=
FindBestInterval
(
max_number_of_chars
biggest_points
from
to
)
;
}
if
(
biggest_points
=
=
0
)
return
false
;
return
true
;
}
int
BoyerMooreLookahead
:
:
FindBestInterval
(
int
max_number_of_chars
int
old_biggest_points
int
*
from
int
*
to
)
{
int
biggest_points
=
old_biggest_points
;
static
const
int
kSize
=
RegExpMacroAssembler
:
:
kTableSize
;
for
(
int
i
=
0
;
i
<
length_
;
)
{
while
(
i
<
length_
&
&
Count
(
i
)
>
max_number_of_chars
)
i
+
+
;
if
(
i
=
=
length_
)
break
;
int
remembered_from
=
i
;
BoyerMoorePositionInfo
:
:
Bitset
union_bitset
;
for
(
;
i
<
length_
&
&
Count
(
i
)
<
=
max_number_of_chars
;
i
+
+
)
{
union_bitset
|
=
bitmaps_
-
>
at
(
i
)
-
>
raw_bitset
(
)
;
}
int
frequency
=
0
;
int
j
;
while
(
(
j
=
BitsetFirstSetBit
(
union_bitset
)
)
!
=
-
1
)
{
DCHECK
(
union_bitset
[
j
]
)
;
frequency
+
=
compiler_
-
>
frequency_collator
(
)
-
>
Frequency
(
j
)
+
1
;
union_bitset
.
reset
(
j
)
;
}
bool
in_quickcheck_range
=
(
(
i
-
remembered_from
<
4
)
|
|
(
compiler_
-
>
one_byte
(
)
?
remembered_from
<
=
4
:
remembered_from
<
=
2
)
)
;
int
probability
=
(
in_quickcheck_range
?
kSize
/
2
:
kSize
)
-
frequency
;
int
points
=
(
i
-
remembered_from
)
*
probability
;
if
(
points
>
biggest_points
)
{
*
from
=
remembered_from
;
*
to
=
i
-
1
;
biggest_points
=
points
;
}
}
return
biggest_points
;
}
int
BoyerMooreLookahead
:
:
GetSkipTable
(
int
min_lookahead
int
max_lookahead
DirectHandle
<
ByteArray
>
boolean_skip_table
DirectHandle
<
ByteArray
>
nibble_table
)
{
const
int
kSkipArrayEntry
=
0
;
const
int
kDontSkipArrayEntry
=
1
;
std
:
:
memset
(
boolean_skip_table
-
>
begin
(
)
kSkipArrayEntry
boolean_skip_table
-
>
length
(
)
)
;
const
bool
fill_nibble_table
=
!
nibble_table
.
is_null
(
)
;
if
(
fill_nibble_table
)
{
std
:
:
memset
(
nibble_table
-
>
begin
(
)
0
nibble_table
-
>
length
(
)
)
;
}
for
(
int
i
=
max_lookahead
;
i
>
=
min_lookahead
;
i
-
-
)
{
BoyerMoorePositionInfo
:
:
Bitset
bitset
=
bitmaps_
-
>
at
(
i
)
-
>
raw_bitset
(
)
;
int
j
;
while
(
(
j
=
BitsetFirstSetBit
(
bitset
)
)
!
=
-
1
)
{
DCHECK
(
bitset
[
j
]
)
;
boolean_skip_table
-
>
set
(
j
kDontSkipArrayEntry
)
;
if
(
fill_nibble_table
)
{
int
lo_nibble
=
j
&
0x0f
;
int
hi_nibble
=
(
j
>
>
4
)
&
0x07
;
int
row
=
nibble_table
-
>
get
(
lo_nibble
)
;
row
|
=
1
<
<
hi_nibble
;
nibble_table
-
>
set
(
lo_nibble
row
)
;
}
bitset
.
reset
(
j
)
;
}
}
const
int
skip
=
max_lookahead
+
1
-
min_lookahead
;
return
skip
;
}
void
BoyerMooreLookahead
:
:
EmitSkipInstructions
(
RegExpMacroAssembler
*
masm
)
{
const
int
kSize
=
RegExpMacroAssembler
:
:
kTableSize
;
int
min_lookahead
=
0
;
int
max_lookahead
=
0
;
if
(
!
FindWorthwhileInterval
(
&
min_lookahead
&
max_lookahead
)
)
return
;
bool
found_single_character
=
false
;
int
single_character
=
0
;
for
(
int
i
=
max_lookahead
;
i
>
=
min_lookahead
;
i
-
-
)
{
BoyerMoorePositionInfo
*
map
=
bitmaps_
-
>
at
(
i
)
;
if
(
map
-
>
map_count
(
)
=
=
0
)
continue
;
if
(
found_single_character
|
|
map
-
>
map_count
(
)
>
1
)
{
found_single_character
=
false
;
break
;
}
DCHECK
(
!
found_single_character
)
;
DCHECK_EQ
(
map
-
>
map_count
(
)
1
)
;
found_single_character
=
true
;
single_character
=
BitsetFirstSetBit
(
map
-
>
raw_bitset
(
)
)
;
DCHECK_NE
(
single_character
-
1
)
;
}
int
lookahead_width
=
max_lookahead
+
1
-
min_lookahead
;
if
(
found_single_character
&
&
lookahead_width
=
=
1
&
&
max_lookahead
<
3
)
{
return
;
}
if
(
found_single_character
)
{
Label
cont
again
;
masm
-
>
Bind
(
&
again
)
;
masm
-
>
LoadCurrentCharacter
(
max_lookahead
&
cont
true
)
;
if
(
max_char_
>
kSize
)
{
masm
-
>
CheckCharacterAfterAnd
(
single_character
RegExpMacroAssembler
:
:
kTableMask
&
cont
)
;
}
else
{
masm
-
>
CheckCharacter
(
single_character
&
cont
)
;
}
masm
-
>
AdvanceCurrentPosition
(
lookahead_width
)
;
masm
-
>
GoTo
(
&
again
)
;
masm
-
>
Bind
(
&
cont
)
;
return
;
}
Factory
*
factory
=
masm
-
>
isolate
(
)
-
>
factory
(
)
;
Handle
<
ByteArray
>
boolean_skip_table
=
factory
-
>
NewByteArray
(
kSize
AllocationType
:
:
kOld
)
;
Handle
<
ByteArray
>
nibble_table
;
const
int
skip_distance
=
max_lookahead
+
1
-
min_lookahead
;
if
(
masm
-
>
SkipUntilBitInTableUseSimd
(
skip_distance
)
)
{
static_assert
(
kSize
=
=
128
)
;
nibble_table
=
factory
-
>
NewByteArray
(
kSize
/
kBitsPerByte
AllocationType
:
:
kOld
)
;
}
GetSkipTable
(
min_lookahead
max_lookahead
boolean_skip_table
nibble_table
)
;
DCHECK_NE
(
0
skip_distance
)
;
masm
-
>
SkipUntilBitInTable
(
max_lookahead
boolean_skip_table
nibble_table
skip_distance
)
;
}
GreedyLoopState
:
:
GreedyLoopState
(
bool
not_at_start
)
{
counter_backtrack_trace_
.
set_backtrack
(
&
label_
)
;
if
(
not_at_start
)
counter_backtrack_trace_
.
set_at_start
(
Trace
:
:
FALSE_VALUE
)
;
}
void
ChoiceNode
:
:
AssertGuardsMentionRegisters
(
Trace
*
trace
)
{
#
ifdef
DEBUG
int
choice_count
=
alternatives_
-
>
length
(
)
;
for
(
int
i
=
0
;
i
<
choice_count
-
1
;
i
+
+
)
{
GuardedAlternative
alternative
=
alternatives_
-
>
at
(
i
)
;
ZoneList
<
Guard
*
>
*
guards
=
alternative
.
guards
(
)
;
int
guard_count
=
(
guards
=
=
nullptr
)
?
0
:
guards
-
>
length
(
)
;
for
(
int
j
=
0
;
j
<
guard_count
;
j
+
+
)
{
DCHECK
(
!
trace
-
>
mentions_reg
(
guards
-
>
at
(
j
)
-
>
reg
(
)
)
)
;
}
}
#
endif
}
void
ChoiceNode
:
:
SetUpPreLoad
(
RegExpCompiler
*
compiler
Trace
*
current_trace
PreloadState
*
state
)
{
if
(
state
-
>
eats_at_least_
=
=
PreloadState
:
:
kEatsAtLeastNotYetInitialized
)
{
state
-
>
eats_at_least_
=
EatsAtLeast
(
current_trace
-
>
at_start
(
)
=
=
Trace
:
:
FALSE_VALUE
)
;
}
state
-
>
preload_characters_
=
CalculatePreloadCharacters
(
compiler
state
-
>
eats_at_least_
)
;
state
-
>
preload_is_current_
=
(
current_trace
-
>
characters_preloaded
(
)
=
=
state
-
>
preload_characters_
)
;
state
-
>
preload_has_checked_bounds_
=
state
-
>
preload_is_current_
;
}
void
ChoiceNode
:
:
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
{
int
choice_count
=
alternatives_
-
>
length
(
)
;
if
(
choice_count
=
=
1
&
&
alternatives_
-
>
at
(
0
)
.
guards
(
)
=
=
nullptr
)
{
alternatives_
-
>
at
(
0
)
.
node
(
)
-
>
Emit
(
compiler
trace
)
;
return
;
}
AssertGuardsMentionRegisters
(
trace
)
;
LimitResult
limit_result
=
LimitVersions
(
compiler
trace
)
;
if
(
limit_result
=
=
DONE
)
return
;
DCHECK
(
limit_result
=
=
CONTINUE
)
;
if
(
trace
-
>
flush_budget
(
)
=
=
0
&
&
trace
-
>
actions
(
)
!
=
nullptr
)
{
trace
-
>
Flush
(
compiler
this
)
;
return
;
}
RecursionCheck
rc
(
compiler
)
;
PreloadState
preload
;
preload
.
init
(
)
;
GreedyLoopState
greedy_loop_state
(
not_at_start
(
)
)
;
int
text_length
=
GreedyLoopTextLengthForAlternative
(
&
alternatives_
-
>
at
(
0
)
)
;
AlternativeGenerationList
alt_gens
(
choice_count
zone
(
)
)
;
if
(
choice_count
>
1
&
&
text_length
!
=
kNodeIsTooComplexForGreedyLoops
)
{
trace
=
EmitGreedyLoop
(
compiler
trace
&
alt_gens
&
preload
&
greedy_loop_state
text_length
)
;
}
else
{
preload
.
eats_at_least_
=
EmitOptimizedUnanchoredSearch
(
compiler
trace
)
;
EmitChoices
(
compiler
&
alt_gens
0
trace
&
preload
)
;
}
int
new_flush_budget
=
trace
-
>
flush_budget
(
)
/
choice_count
;
for
(
int
i
=
0
;
i
<
choice_count
;
i
+
+
)
{
AlternativeGeneration
*
alt_gen
=
alt_gens
.
at
(
i
)
;
Trace
new_trace
(
*
trace
)
;
if
(
new_trace
.
actions
(
)
!
=
nullptr
)
{
new_trace
.
set_flush_budget
(
new_flush_budget
)
;
}
bool
next_expects_preload
=
i
=
=
choice_count
-
1
?
false
:
alt_gens
.
at
(
i
+
1
)
-
>
expects_preload
;
EmitOutOfLineContinuation
(
compiler
&
new_trace
alternatives_
-
>
at
(
i
)
alt_gen
preload
.
preload_characters_
next_expects_preload
)
;
}
}
Trace
*
ChoiceNode
:
:
EmitGreedyLoop
(
RegExpCompiler
*
compiler
Trace
*
trace
AlternativeGenerationList
*
alt_gens
PreloadState
*
preload
GreedyLoopState
*
greedy_loop_state
int
text_length
)
{
RegExpMacroAssembler
*
macro_assembler
=
compiler
-
>
macro_assembler
(
)
;
DCHECK
(
trace
-
>
stop_node
(
)
=
=
nullptr
)
;
macro_assembler
-
>
PushCurrentPosition
(
)
;
Label
greedy_match_failed
;
Trace
greedy_match_trace
;
if
(
not_at_start
(
)
)
greedy_match_trace
.
set_at_start
(
Trace
:
:
FALSE_VALUE
)
;
greedy_match_trace
.
set_backtrack
(
&
greedy_match_failed
)
;
Label
loop_label
;
macro_assembler
-
>
Bind
(
&
loop_label
)
;
greedy_match_trace
.
set_stop_node
(
this
)
;
greedy_match_trace
.
set_loop_label
(
&
loop_label
)
;
alternatives_
-
>
at
(
0
)
.
node
(
)
-
>
Emit
(
compiler
&
greedy_match_trace
)
;
macro_assembler
-
>
Bind
(
&
greedy_match_failed
)
;
Label
second_choice
;
macro_assembler
-
>
Bind
(
&
second_choice
)
;
Trace
*
new_trace
=
greedy_loop_state
-
>
counter_backtrack_trace
(
)
;
EmitChoices
(
compiler
alt_gens
1
new_trace
preload
)
;
macro_assembler
-
>
Bind
(
greedy_loop_state
-
>
label
(
)
)
;
macro_assembler
-
>
CheckGreedyLoop
(
trace
-
>
backtrack
(
)
)
;
macro_assembler
-
>
AdvanceCurrentPosition
(
-
text_length
)
;
macro_assembler
-
>
GoTo
(
&
second_choice
)
;
return
new_trace
;
}
int
ChoiceNode
:
:
EmitOptimizedUnanchoredSearch
(
RegExpCompiler
*
compiler
Trace
*
trace
)
{
int
eats_at_least
=
PreloadState
:
:
kEatsAtLeastNotYetInitialized
;
if
(
alternatives_
-
>
length
(
)
!
=
2
)
return
eats_at_least
;
GuardedAlternative
alt1
=
alternatives_
-
>
at
(
1
)
;
if
(
alt1
.
guards
(
)
!
=
nullptr
&
&
alt1
.
guards
(
)
-
>
length
(
)
!
=
0
)
{
return
eats_at_least
;
}
RegExpNode
*
eats_anything_node
=
alt1
.
node
(
)
;
if
(
eats_anything_node
-
>
GetSuccessorOfOmnivorousTextNode
(
compiler
)
!
=
this
)
{
return
eats_at_least
;
}
DCHECK
(
trace
-
>
is_trivial
(
)
)
;
RegExpMacroAssembler
*
macro_assembler
=
compiler
-
>
macro_assembler
(
)
;
Isolate
*
isolate
=
macro_assembler
-
>
isolate
(
)
;
BoyerMooreLookahead
*
bm
=
bm_info
(
false
)
;
if
(
bm
=
=
nullptr
)
{
eats_at_least
=
std
:
:
min
(
kMaxLookaheadForBoyerMoore
EatsAtLeast
(
false
)
)
;
if
(
eats_at_least
>
=
1
)
{
bm
=
zone
(
)
-
>
New
<
BoyerMooreLookahead
>
(
eats_at_least
compiler
zone
(
)
)
;
GuardedAlternative
alt0
=
alternatives_
-
>
at
(
0
)
;
alt0
.
node
(
)
-
>
FillInBMInfo
(
isolate
0
kRecursionBudget
bm
false
)
;
}
}
if
(
bm
!
=
nullptr
)
{
bm
-
>
EmitSkipInstructions
(
macro_assembler
)
;
}
return
eats_at_least
;
}
void
ChoiceNode
:
:
EmitChoices
(
RegExpCompiler
*
compiler
AlternativeGenerationList
*
alt_gens
int
first_choice
Trace
*
trace
PreloadState
*
preload
)
{
RegExpMacroAssembler
*
macro_assembler
=
compiler
-
>
macro_assembler
(
)
;
SetUpPreLoad
(
compiler
trace
preload
)
;
int
choice_count
=
alternatives_
-
>
length
(
)
;
int
new_flush_budget
=
trace
-
>
flush_budget
(
)
/
choice_count
;
for
(
int
i
=
first_choice
;
i
<
choice_count
;
i
+
+
)
{
bool
is_last
=
i
=
=
choice_count
-
1
;
bool
fall_through_on_failure
=
!
is_last
;
GuardedAlternative
alternative
=
alternatives_
-
>
at
(
i
)
;
AlternativeGeneration
*
alt_gen
=
alt_gens
-
>
at
(
i
)
;
alt_gen
-
>
quick_check_details
.
set_characters
(
preload
-
>
preload_characters_
)
;
ZoneList
<
Guard
*
>
*
guards
=
alternative
.
guards
(
)
;
int
guard_count
=
(
guards
=
=
nullptr
)
?
0
:
guards
-
>
length
(
)
;
Trace
new_trace
(
*
trace
)
;
new_trace
.
set_characters_preloaded
(
preload
-
>
preload_is_current_
?
preload
-
>
preload_characters_
:
0
)
;
if
(
preload
-
>
preload_has_checked_bounds_
)
{
new_trace
.
set_bound_checked_up_to
(
preload
-
>
preload_characters_
)
;
}
new_trace
.
quick_check_performed
(
)
-
>
Clear
(
)
;
if
(
not_at_start_
)
new_trace
.
set_at_start
(
Trace
:
:
FALSE_VALUE
)
;
if
(
!
is_last
)
{
new_trace
.
set_backtrack
(
&
alt_gen
-
>
after
)
;
}
alt_gen
-
>
expects_preload
=
preload
-
>
preload_is_current_
;
bool
generate_full_check_inline
=
false
;
if
(
v8_flags
.
regexp_optimization
&
&
try_to_emit_quick_check_for_alternative
(
i
=
=
0
)
&
&
alternative
.
node
(
)
-
>
EmitQuickCheck
(
compiler
trace
&
new_trace
preload
-
>
preload_has_checked_bounds_
&
alt_gen
-
>
possible_success
&
alt_gen
-
>
quick_check_details
fall_through_on_failure
this
)
)
{
preload
-
>
preload_is_current_
=
true
;
preload
-
>
preload_has_checked_bounds_
=
true
;
if
(
!
fall_through_on_failure
)
{
macro_assembler
-
>
Bind
(
&
alt_gen
-
>
possible_success
)
;
new_trace
.
set_quick_check_performed
(
&
alt_gen
-
>
quick_check_details
)
;
new_trace
.
set_characters_preloaded
(
preload
-
>
preload_characters_
)
;
new_trace
.
set_bound_checked_up_to
(
preload
-
>
preload_characters_
)
;
generate_full_check_inline
=
true
;
}
}
else
if
(
alt_gen
-
>
quick_check_details
.
cannot_match
(
)
)
{
if
(
!
fall_through_on_failure
)
{
macro_assembler
-
>
GoTo
(
trace
-
>
backtrack
(
)
)
;
}
continue
;
}
else
{
if
(
i
!
=
first_choice
)
{
alt_gen
-
>
expects_preload
=
false
;
new_trace
.
InvalidateCurrentCharacter
(
)
;
}
generate_full_check_inline
=
true
;
}
if
(
generate_full_check_inline
)
{
if
(
new_trace
.
actions
(
)
!
=
nullptr
)
{
new_trace
.
set_flush_budget
(
new_flush_budget
)
;
}
for
(
int
j
=
0
;
j
<
guard_count
;
j
+
+
)
{
GenerateGuard
(
macro_assembler
guards
-
>
at
(
j
)
&
new_trace
)
;
}
alternative
.
node
(
)
-
>
Emit
(
compiler
&
new_trace
)
;
preload
-
>
preload_is_current_
=
false
;
}
macro_assembler
-
>
Bind
(
&
alt_gen
-
>
after
)
;
}
}
void
ChoiceNode
:
:
EmitOutOfLineContinuation
(
RegExpCompiler
*
compiler
Trace
*
trace
GuardedAlternative
alternative
AlternativeGeneration
*
alt_gen
int
preload_characters
bool
next_expects_preload
)
{
if
(
!
alt_gen
-
>
possible_success
.
is_linked
(
)
)
return
;
RegExpMacroAssembler
*
macro_assembler
=
compiler
-
>
macro_assembler
(
)
;
macro_assembler
-
>
Bind
(
&
alt_gen
-
>
possible_success
)
;
Trace
out_of_line_trace
(
*
trace
)
;
out_of_line_trace
.
set_characters_preloaded
(
preload_characters
)
;
out_of_line_trace
.
set_quick_check_performed
(
&
alt_gen
-
>
quick_check_details
)
;
if
(
not_at_start_
)
out_of_line_trace
.
set_at_start
(
Trace
:
:
FALSE_VALUE
)
;
ZoneList
<
Guard
*
>
*
guards
=
alternative
.
guards
(
)
;
int
guard_count
=
(
guards
=
=
nullptr
)
?
0
:
guards
-
>
length
(
)
;
if
(
next_expects_preload
)
{
Label
reload_current_char
;
out_of_line_trace
.
set_backtrack
(
&
reload_current_char
)
;
for
(
int
j
=
0
;
j
<
guard_count
;
j
+
+
)
{
GenerateGuard
(
macro_assembler
guards
-
>
at
(
j
)
&
out_of_line_trace
)
;
}
alternative
.
node
(
)
-
>
Emit
(
compiler
&
out_of_line_trace
)
;
macro_assembler
-
>
Bind
(
&
reload_current_char
)
;
macro_assembler
-
>
LoadCurrentCharacter
(
trace
-
>
cp_offset
(
)
nullptr
false
preload_characters
)
;
macro_assembler
-
>
GoTo
(
&
(
alt_gen
-
>
after
)
)
;
}
else
{
out_of_line_trace
.
set_backtrack
(
&
(
alt_gen
-
>
after
)
)
;
for
(
int
j
=
0
;
j
<
guard_count
;
j
+
+
)
{
GenerateGuard
(
macro_assembler
guards
-
>
at
(
j
)
&
out_of_line_trace
)
;
}
alternative
.
node
(
)
-
>
Emit
(
compiler
&
out_of_line_trace
)
;
}
}
void
ActionNode
:
:
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
{
RegExpMacroAssembler
*
assembler
=
compiler
-
>
macro_assembler
(
)
;
LimitResult
limit_result
=
LimitVersions
(
compiler
trace
)
;
if
(
limit_result
=
=
DONE
)
return
;
DCHECK
(
limit_result
=
=
CONTINUE
)
;
RecursionCheck
rc
(
compiler
)
;
switch
(
action_type_
)
{
case
STORE_POSITION
:
{
Trace
:
:
DeferredCapture
new_capture
(
data_
.
u_position_register
.
reg
data_
.
u_position_register
.
is_capture
trace
)
;
Trace
new_trace
=
*
trace
;
new_trace
.
add_action
(
&
new_capture
)
;
on_success
(
)
-
>
Emit
(
compiler
&
new_trace
)
;
break
;
}
case
INCREMENT_REGISTER
:
{
Trace
:
:
DeferredIncrementRegister
new_increment
(
data_
.
u_increment_register
.
reg
)
;
Trace
new_trace
=
*
trace
;
new_trace
.
add_action
(
&
new_increment
)
;
on_success
(
)
-
>
Emit
(
compiler
&
new_trace
)
;
break
;
}
case
SET_REGISTER_FOR_LOOP
:
{
Trace
:
:
DeferredSetRegisterForLoop
new_set
(
data_
.
u_store_register
.
reg
data_
.
u_store_register
.
value
)
;
Trace
new_trace
=
*
trace
;
new_trace
.
add_action
(
&
new_set
)
;
on_success
(
)
-
>
Emit
(
compiler
&
new_trace
)
;
break
;
}
case
CLEAR_CAPTURES
:
{
Trace
:
:
DeferredClearCaptures
new_capture
(
Interval
(
data_
.
u_clear_captures
.
range_from
data_
.
u_clear_captures
.
range_to
)
)
;
Trace
new_trace
=
*
trace
;
new_trace
.
add_action
(
&
new_capture
)
;
on_success
(
)
-
>
Emit
(
compiler
&
new_trace
)
;
break
;
}
case
BEGIN_POSITIVE_SUBMATCH
:
case
BEGIN_NEGATIVE_SUBMATCH
:
if
(
!
trace
-
>
is_trivial
(
)
)
{
trace
-
>
Flush
(
compiler
this
)
;
}
else
{
assembler
-
>
WriteCurrentPositionToRegister
(
data_
.
u_submatch
.
current_position_register
0
)
;
assembler
-
>
WriteStackPointerToRegister
(
data_
.
u_submatch
.
stack_pointer_register
)
;
on_success
(
)
-
>
Emit
(
compiler
trace
)
;
}
break
;
case
EMPTY_MATCH_CHECK
:
{
int
start_pos_reg
=
data_
.
u_empty_match_check
.
start_register
;
int
stored_pos
=
0
;
int
rep_reg
=
data_
.
u_empty_match_check
.
repetition_register
;
bool
has_minimum
=
(
rep_reg
!
=
RegExpCompiler
:
:
kNoRegister
)
;
bool
know_dist
=
trace
-
>
GetStoredPosition
(
start_pos_reg
&
stored_pos
)
;
if
(
know_dist
&
&
!
has_minimum
&
&
stored_pos
=
=
trace
-
>
cp_offset
(
)
)
{
assembler
-
>
GoTo
(
trace
-
>
backtrack
(
)
)
;
}
else
if
(
know_dist
&
&
stored_pos
<
trace
-
>
cp_offset
(
)
)
{
on_success
(
)
-
>
Emit
(
compiler
trace
)
;
}
else
if
(
!
trace
-
>
is_trivial
(
)
)
{
trace
-
>
Flush
(
compiler
this
)
;
}
else
{
Label
skip_empty_check
;
if
(
has_minimum
)
{
int
limit
=
data_
.
u_empty_match_check
.
repetition_limit
;
assembler
-
>
IfRegisterLT
(
rep_reg
limit
&
skip_empty_check
)
;
}
assembler
-
>
IfRegisterEqPos
(
data_
.
u_empty_match_check
.
start_register
trace
-
>
backtrack
(
)
)
;
assembler
-
>
Bind
(
&
skip_empty_check
)
;
on_success
(
)
-
>
Emit
(
compiler
trace
)
;
}
break
;
}
case
POSITIVE_SUBMATCH_SUCCESS
:
{
if
(
!
trace
-
>
is_trivial
(
)
)
{
trace
-
>
Flush
(
compiler
this
)
;
return
;
}
assembler
-
>
ReadCurrentPositionFromRegister
(
data_
.
u_submatch
.
current_position_register
)
;
assembler
-
>
ReadStackPointerFromRegister
(
data_
.
u_submatch
.
stack_pointer_register
)
;
int
clear_register_count
=
data_
.
u_submatch
.
clear_register_count
;
if
(
clear_register_count
=
=
0
)
{
on_success
(
)
-
>
Emit
(
compiler
trace
)
;
return
;
}
int
clear_registers_from
=
data_
.
u_submatch
.
clear_register_from
;
Label
clear_registers_backtrack
;
Trace
new_trace
=
*
trace
;
new_trace
.
set_backtrack
(
&
clear_registers_backtrack
)
;
on_success
(
)
-
>
Emit
(
compiler
&
new_trace
)
;
assembler
-
>
Bind
(
&
clear_registers_backtrack
)
;
int
clear_registers_to
=
clear_registers_from
+
clear_register_count
-
1
;
assembler
-
>
ClearRegisters
(
clear_registers_from
clear_registers_to
)
;
DCHECK
(
trace
-
>
backtrack
(
)
=
=
nullptr
)
;
assembler
-
>
Backtrack
(
)
;
return
;
}
case
MODIFY_FLAGS
:
{
compiler
-
>
set_flags
(
flags
(
)
)
;
on_success
(
)
-
>
Emit
(
compiler
trace
)
;
break
;
}
default
:
UNREACHABLE
(
)
;
}
}
void
BackReferenceNode
:
:
Emit
(
RegExpCompiler
*
compiler
Trace
*
trace
)
{
RegExpMacroAssembler
*
assembler
=
compiler
-
>
macro_assembler
(
)
;
if
(
!
trace
-
>
is_trivial
(
)
)
{
trace
-
>
Flush
(
compiler
this
)
;
return
;
}
LimitResult
limit_result
=
LimitVersions
(
compiler
trace
)
;
if
(
limit_result
=
=
DONE
)
return
;
DCHECK
(
limit_result
=
=
CONTINUE
)
;
RecursionCheck
rc
(
compiler
)
;
DCHECK_EQ
(
start_reg_
+
1
end_reg_
)
;
if
(
IsIgnoreCase
(
compiler
-
>
flags
(
)
)
)
{
bool
unicode
=
IsEitherUnicode
(
compiler
-
>
flags
(
)
)
;
assembler
-
>
CheckNotBackReferenceIgnoreCase
(
start_reg_
read_backward
(
)
unicode
trace
-
>
backtrack
(
)
)
;
}
else
{
assembler
-
>
CheckNotBackReference
(
start_reg_
read_backward
(
)
trace
-
>
backtrack
(
)
)
;
}
if
(
read_backward
(
)
)
trace
-
>
set_at_start
(
Trace
:
:
UNKNOWN
)
;
if
(
IsEitherUnicode
(
compiler
-
>
flags
(
)
)
&
&
!
compiler
-
>
one_byte
(
)
)
{
assembler
-
>
CheckNotInSurrogatePair
(
trace
-
>
cp_offset
(
)
trace
-
>
backtrack
(
)
)
;
}
on_success
(
)
-
>
Emit
(
compiler
trace
)
;
}
void
TextNode
:
:
CalculateOffsets
(
)
{
int
element_count
=
elements
(
)
-
>
length
(
)
;
int
cp_offset
=
0
;
for
(
int
i
=
0
;
i
<
element_count
;
i
+
+
)
{
TextElement
&
elm
=
elements
(
)
-
>
at
(
i
)
;
elm
.
set_cp_offset
(
cp_offset
)
;
cp_offset
+
=
elm
.
length
(
)
;
}
}
namespace
{
class
AssertionPropagator
:
public
AllStatic
{
public
:
static
void
VisitText
(
TextNode
*
that
)
{
}
static
void
VisitAction
(
ActionNode
*
that
)
{
that
-
>
info
(
)
-
>
AddFromFollowing
(
that
-
>
on_success
(
)
-
>
info
(
)
)
;
}
static
void
VisitChoice
(
ChoiceNode
*
that
int
i
)
{
that
-
>
info
(
)
-
>
AddFromFollowing
(
that
-
>
alternatives
(
)
-
>
at
(
i
)
.
node
(
)
-
>
info
(
)
)
;
}
static
void
VisitLoopChoiceContinueNode
(
LoopChoiceNode
*
that
)
{
that
-
>
info
(
)
-
>
AddFromFollowing
(
that
-
>
continue_node
(
)
-
>
info
(
)
)
;
}
static
void
VisitLoopChoiceLoopNode
(
LoopChoiceNode
*
that
)
{
that
-
>
info
(
)
-
>
AddFromFollowing
(
that
-
>
loop_node
(
)
-
>
info
(
)
)
;
}
static
void
VisitNegativeLookaroundChoiceLookaroundNode
(
NegativeLookaroundChoiceNode
*
that
)
{
VisitChoice
(
that
NegativeLookaroundChoiceNode
:
:
kLookaroundIndex
)
;
}
static
void
VisitNegativeLookaroundChoiceContinueNode
(
NegativeLookaroundChoiceNode
*
that
)
{
VisitChoice
(
that
NegativeLookaroundChoiceNode
:
:
kContinueIndex
)
;
}
static
void
VisitBackReference
(
BackReferenceNode
*
that
)
{
}
static
void
VisitAssertion
(
AssertionNode
*
that
)
{
}
}
;
class
EatsAtLeastPropagator
:
public
AllStatic
{
public
:
static
void
VisitText
(
TextNode
*
that
)
{
if
(
!
that
-
>
read_backward
(
)
)
{
uint8_t
eats_at_least
=
base
:
:
saturated_cast
<
uint8_t
>
(
that
-
>
Length
(
)
+
that
-
>
on_success
(
)
-
>
eats_at_least_info
(
)
-
>
eats_at_least_from_not_start
)
;
that
-
>
set_eats_at_least_info
(
EatsAtLeastInfo
(
eats_at_least
)
)
;
}
}
static
void
VisitAction
(
ActionNode
*
that
)
{
switch
(
that
-
>
action_type
(
)
)
{
case
ActionNode
:
:
BEGIN_POSITIVE_SUBMATCH
:
{
that
-
>
set_eats_at_least_info
(
*
that
-
>
success_node
(
)
-
>
on_success
(
)
-
>
eats_at_least_info
(
)
)
;
break
;
}
case
ActionNode
:
:
POSITIVE_SUBMATCH_SUCCESS
:
DCHECK
(
that
-
>
eats_at_least_info
(
)
-
>
IsZero
(
)
)
;
break
;
case
ActionNode
:
:
SET_REGISTER_FOR_LOOP
:
that
-
>
set_eats_at_least_info
(
that
-
>
on_success
(
)
-
>
EatsAtLeastFromLoopEntry
(
)
)
;
break
;
case
ActionNode
:
:
BEGIN_NEGATIVE_SUBMATCH
:
default
:
that
-
>
set_eats_at_least_info
(
*
that
-
>
on_success
(
)
-
>
eats_at_least_info
(
)
)
;
break
;
}
}
static
void
VisitChoice
(
ChoiceNode
*
that
int
i
)
{
EatsAtLeastInfo
eats_at_least
=
i
=
=
0
?
EatsAtLeastInfo
(
UINT8_MAX
)
:
*
that
-
>
eats_at_least_info
(
)
;
eats_at_least
.
SetMin
(
*
that
-
>
alternatives
(
)
-
>
at
(
i
)
.
node
(
)
-
>
eats_at_least_info
(
)
)
;
that
-
>
set_eats_at_least_info
(
eats_at_least
)
;
}
static
void
VisitLoopChoiceContinueNode
(
LoopChoiceNode
*
that
)
{
if
(
!
that
-
>
read_backward
(
)
)
{
that
-
>
set_eats_at_least_info
(
*
that
-
>
continue_node
(
)
-
>
eats_at_least_info
(
)
)
;
}
}
static
void
VisitLoopChoiceLoopNode
(
LoopChoiceNode
*
that
)
{
}
static
void
VisitNegativeLookaroundChoiceLookaroundNode
(
NegativeLookaroundChoiceNode
*
that
)
{
}
static
void
VisitNegativeLookaroundChoiceContinueNode
(
NegativeLookaroundChoiceNode
*
that
)
{
that
-
>
set_eats_at_least_info
(
*
that
-
>
continue_node
(
)
-
>
eats_at_least_info
(
)
)
;
}
static
void
VisitBackReference
(
BackReferenceNode
*
that
)
{
if
(
!
that
-
>
read_backward
(
)
)
{
that
-
>
set_eats_at_least_info
(
*
that
-
>
on_success
(
)
-
>
eats_at_least_info
(
)
)
;
}
}
static
void
VisitAssertion
(
AssertionNode
*
that
)
{
EatsAtLeastInfo
eats_at_least
=
*
that
-
>
on_success
(
)
-
>
eats_at_least_info
(
)
;
if
(
that
-
>
assertion_type
(
)
=
=
AssertionNode
:
:
AT_START
)
{
eats_at_least
.
eats_at_least_from_not_start
=
UINT8_MAX
;
}
that
-
>
set_eats_at_least_info
(
eats_at_least
)
;
}
}
;
}
template
<
typename
.
.
.
Propagators
>
class
Analysis
:
public
NodeVisitor
{
public
:
Analysis
(
Isolate
*
isolate
bool
is_one_byte
RegExpFlags
flags
)
:
isolate_
(
isolate
)
is_one_byte_
(
is_one_byte
)
flags_
(
flags
)
error_
(
RegExpError
:
:
kNone
)
{
}
void
EnsureAnalyzed
(
RegExpNode
*
that
)
{
StackLimitCheck
check
(
isolate
(
)
)
;
if
(
check
.
HasOverflowed
(
)
)
{
if
(
v8_flags
.
correctness_fuzzer_suppressions
)
{
FATAL
(
"
Analysis
:
Aborting
on
stack
overflow
"
)
;
}
fail
(
RegExpError
:
:
kAnalysisStackOverflow
)
;
return
;
}
if
(
that
-
>
info
(
)
-
>
been_analyzed
|
|
that
-
>
info
(
)
-
>
being_analyzed
)
return
;
that
-
>
info
(
)
-
>
being_analyzed
=
true
;
that
-
>
Accept
(
this
)
;
that
-
>
info
(
)
-
>
being_analyzed
=
false
;
that
-
>
info
(
)
-
>
been_analyzed
=
true
;
}
bool
has_failed
(
)
{
return
error_
!
=
RegExpError
:
:
kNone
;
}
RegExpError
error
(
)
{
DCHECK
(
error_
!
=
RegExpError
:
:
kNone
)
;
return
error_
;
}
void
fail
(
RegExpError
error
)
{
error_
=
error
;
}
Isolate
*
isolate
(
)
const
{
return
isolate_
;
}
void
VisitEnd
(
EndNode
*
that
)
override
{
}
#
define
STATIC_FOR_EACH
(
expr
)
\
do
{
\
int
dummy
[
]
=
{
(
(
expr
)
0
)
.
.
.
}
;
\
USE
(
dummy
)
;
\
}
while
(
false
)
void
VisitText
(
TextNode
*
that
)
override
{
that
-
>
MakeCaseIndependent
(
isolate
(
)
is_one_byte_
flags
(
)
)
;
EnsureAnalyzed
(
that
-
>
on_success
(
)
)
;
if
(
has_failed
(
)
)
return
;
that
-
>
CalculateOffsets
(
)
;
STATIC_FOR_EACH
(
Propagators
:
:
VisitText
(
that
)
)
;
}
void
VisitAction
(
ActionNode
*
that
)
override
{
if
(
that
-
>
action_type
(
)
=
=
ActionNode
:
:
MODIFY_FLAGS
)
{
set_flags
(
that
-
>
flags
(
)
)
;
}
EnsureAnalyzed
(
that
-
>
on_success
(
)
)
;
if
(
has_failed
(
)
)
return
;
STATIC_FOR_EACH
(
Propagators
:
:
VisitAction
(
that
)
)
;
}
void
VisitChoice
(
ChoiceNode
*
that
)
override
{
for
(
int
i
=
0
;
i
<
that
-
>
alternatives
(
)
-
>
length
(
)
;
i
+
+
)
{
EnsureAnalyzed
(
that
-
>
alternatives
(
)
-
>
at
(
i
)
.
node
(
)
)
;
if
(
has_failed
(
)
)
return
;
STATIC_FOR_EACH
(
Propagators
:
:
VisitChoice
(
that
i
)
)
;
}
}
void
VisitLoopChoice
(
LoopChoiceNode
*
that
)
override
{
DCHECK_EQ
(
that
-
>
alternatives
(
)
-
>
length
(
)
2
)
;
RegExpFlags
orig_flags
=
flags
(
)
;
EnsureAnalyzed
(
that
-
>
continue_node
(
)
)
;
if
(
has_failed
(
)
)
return
;
STATIC_FOR_EACH
(
Propagators
:
:
VisitLoopChoiceContinueNode
(
that
)
)
;
RegExpFlags
continuation_flags
=
flags
(
)
;
set_flags
(
orig_flags
)
;
EnsureAnalyzed
(
that
-
>
loop_node
(
)
)
;
if
(
has_failed
(
)
)
return
;
STATIC_FOR_EACH
(
Propagators
:
:
VisitLoopChoiceLoopNode
(
that
)
)
;
set_flags
(
continuation_flags
)
;
}
void
VisitNegativeLookaroundChoice
(
NegativeLookaroundChoiceNode
*
that
)
override
{
DCHECK_EQ
(
that
-
>
alternatives
(
)
-
>
length
(
)
2
)
;
EnsureAnalyzed
(
that
-
>
lookaround_node
(
)
)
;
if
(
has_failed
(
)
)
return
;
STATIC_FOR_EACH
(
Propagators
:
:
VisitNegativeLookaroundChoiceLookaroundNode
(
that
)
)
;
EnsureAnalyzed
(
that
-
>
continue_node
(
)
)
;
if
(
has_failed
(
)
)
return
;
STATIC_FOR_EACH
(
Propagators
:
:
VisitNegativeLookaroundChoiceContinueNode
(
that
)
)
;
}
void
VisitBackReference
(
BackReferenceNode
*
that
)
override
{
EnsureAnalyzed
(
that
-
>
on_success
(
)
)
;
if
(
has_failed
(
)
)
return
;
STATIC_FOR_EACH
(
Propagators
:
:
VisitBackReference
(
that
)
)
;
}
void
VisitAssertion
(
AssertionNode
*
that
)
override
{
EnsureAnalyzed
(
that
-
>
on_success
(
)
)
;
if
(
has_failed
(
)
)
return
;
STATIC_FOR_EACH
(
Propagators
:
:
VisitAssertion
(
that
)
)
;
}
#
undef
STATIC_FOR_EACH
private
:
RegExpFlags
flags
(
)
const
{
return
flags_
;
}
void
set_flags
(
RegExpFlags
flags
)
{
flags_
=
flags
;
}
Isolate
*
isolate_
;
const
bool
is_one_byte_
;
RegExpFlags
flags_
;
RegExpError
error_
;
DISALLOW_IMPLICIT_CONSTRUCTORS
(
Analysis
)
;
}
;
RegExpError
AnalyzeRegExp
(
Isolate
*
isolate
bool
is_one_byte
RegExpFlags
flags
RegExpNode
*
node
)
{
Analysis
<
AssertionPropagator
EatsAtLeastPropagator
>
analysis
(
isolate
is_one_byte
flags
)
;
DCHECK_EQ
(
node
-
>
info
(
)
-
>
been_analyzed
false
)
;
analysis
.
EnsureAnalyzed
(
node
)
;
DCHECK_IMPLIES
(
analysis
.
has_failed
(
)
analysis
.
error
(
)
!
=
RegExpError
:
:
kNone
)
;
return
analysis
.
has_failed
(
)
?
analysis
.
error
(
)
:
RegExpError
:
:
kNone
;
}
void
BackReferenceNode
:
:
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
{
bm
-
>
SetRest
(
offset
)
;
SaveBMInfo
(
bm
not_at_start
offset
)
;
}
static_assert
(
BoyerMoorePositionInfo
:
:
kMapSize
=
=
RegExpMacroAssembler
:
:
kTableSize
)
;
void
ChoiceNode
:
:
FillInBMInfo
(
Isolate
*
isolate
int
offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
{
ZoneList
<
GuardedAlternative
>
*
alts
=
alternatives
(
)
;
budget
=
(
budget
-
1
)
/
alts
-
>
length
(
)
;
for
(
int
i
=
0
;
i
<
alts
-
>
length
(
)
;
i
+
+
)
{
GuardedAlternative
&
alt
=
alts
-
>
at
(
i
)
;
if
(
alt
.
guards
(
)
!
=
nullptr
&
&
alt
.
guards
(
)
-
>
length
(
)
!
=
0
)
{
bm
-
>
SetRest
(
offset
)
;
SaveBMInfo
(
bm
not_at_start
offset
)
;
return
;
}
alt
.
node
(
)
-
>
FillInBMInfo
(
isolate
offset
budget
bm
not_at_start
)
;
}
SaveBMInfo
(
bm
not_at_start
offset
)
;
}
void
TextNode
:
:
FillInBMInfo
(
Isolate
*
isolate
int
initial_offset
int
budget
BoyerMooreLookahead
*
bm
bool
not_at_start
)
{
if
(
initial_offset
>
=
bm
-
>
length
(
)
)
return
;
if
(
read_backward
(
)
)
return
;
int
offset
=
initial_offset
;
int
max_char
=
bm
-
>
max_char
(
)
;
for
(
int
i
=
0
;
i
<
elements
(
)
-
>
length
(
)
;
i
+
+
)
{
if
(
offset
>
=
bm
-
>
length
(
)
)
{
if
(
initial_offset
=
=
0
)
set_bm_info
(
not_at_start
bm
)
;
return
;
}
TextElement
text
=
elements
(
)
-
>
at
(
i
)
;
if
(
text
.
text_type
(
)
=
=
TextElement
:
:
ATOM
)
{
RegExpAtom
*
atom
=
text
.
atom
(
)
;
for
(
int
j
=
0
;
j
<
atom
-
>
length
(
)
;
j
+
+
offset
+
+
)
{
if
(
offset
>
=
bm
-
>
length
(
)
)
{
if
(
initial_offset
=
=
0
)
set_bm_info
(
not_at_start
bm
)
;
return
;
}
base
:
:
uc16
character
=
atom
-
>
data
(
)
[
j
]
;
if
(
IsIgnoreCase
(
bm
-
>
compiler
(
)
-
>
flags
(
)
)
)
{
unibrow
:
:
uchar
chars
[
4
]
;
int
length
=
GetCaseIndependentLetters
(
isolate
character
bm
-
>
compiler
(
)
chars
4
)
;
for
(
int
k
=
0
;
k
<
length
;
k
+
+
)
{
bm
-
>
Set
(
offset
chars
[
k
]
)
;
}
}
else
{
if
(
character
<
=
max_char
)
bm
-
>
Set
(
offset
character
)
;
}
}
}
else
{
DCHECK_EQ
(
TextElement
:
:
CLASS_RANGES
text
.
text_type
(
)
)
;
RegExpClassRanges
*
class_ranges
=
text
.
class_ranges
(
)
;
ZoneList
<
CharacterRange
>
*
ranges
=
class_ranges
-
>
ranges
(
zone
(
)
)
;
if
(
class_ranges
-
>
is_negated
(
)
)
{
bm
-
>
SetAll
(
offset
)
;
}
else
{
for
(
int
k
=
0
;
k
<
ranges
-
>
length
(
)
;
k
+
+
)
{
CharacterRange
&
range
=
ranges
-
>
at
(
k
)
;
if
(
static_cast
<
int
>
(
range
.
from
(
)
)
>
max_char
)
continue
;
int
to
=
std
:
:
min
(
max_char
static_cast
<
int
>
(
range
.
to
(
)
)
)
;
bm
-
>
SetInterval
(
offset
Interval
(
range
.
from
(
)
to
)
)
;
}
}
offset
+
+
;
}
}
if
(
offset
>
=
bm
-
>
length
(
)
)
{
if
(
initial_offset
=
=
0
)
set_bm_info
(
not_at_start
bm
)
;
return
;
}
on_success
(
)
-
>
FillInBMInfo
(
isolate
offset
budget
-
1
bm
true
)
;
if
(
initial_offset
=
=
0
)
set_bm_info
(
not_at_start
bm
)
;
}
RegExpNode
*
RegExpCompiler
:
:
OptionallyStepBackToLeadSurrogate
(
RegExpNode
*
on_success
)
{
DCHECK
(
!
read_backward
(
)
)
;
ZoneList
<
CharacterRange
>
*
lead_surrogates
=
CharacterRange
:
:
List
(
zone
(
)
CharacterRange
:
:
Range
(
kLeadSurrogateStart
kLeadSurrogateEnd
)
)
;
ZoneList
<
CharacterRange
>
*
trail_surrogates
=
CharacterRange
:
:
List
(
zone
(
)
CharacterRange
:
:
Range
(
kTrailSurrogateStart
kTrailSurrogateEnd
)
)
;
ChoiceNode
*
optional_step_back
=
zone
(
)
-
>
New
<
ChoiceNode
>
(
2
zone
(
)
)
;
int
stack_register
=
UnicodeLookaroundStackRegister
(
)
;
int
position_register
=
UnicodeLookaroundPositionRegister
(
)
;
RegExpNode
*
step_back
=
TextNode
:
:
CreateForCharacterRanges
(
zone
(
)
lead_surrogates
true
on_success
)
;
RegExpLookaround
:
:
Builder
builder
(
true
step_back
stack_register
position_register
)
;
RegExpNode
*
match_trail
=
TextNode
:
:
CreateForCharacterRanges
(
zone
(
)
trail_surrogates
false
builder
.
on_match_success
(
)
)
;
optional_step_back
-
>
AddAlternative
(
GuardedAlternative
(
builder
.
ForMatch
(
match_trail
)
)
)
;
optional_step_back
-
>
AddAlternative
(
GuardedAlternative
(
on_success
)
)
;
return
optional_step_back
;
}
RegExpNode
*
RegExpCompiler
:
:
PreprocessRegExp
(
RegExpCompileData
*
data
bool
is_one_byte
)
{
RegExpNode
*
captured_body
=
RegExpCapture
:
:
ToNode
(
data
-
>
tree
0
this
accept
(
)
)
;
RegExpNode
*
node
=
captured_body
;
if
(
!
data
-
>
tree
-
>
IsAnchoredAtStart
(
)
&
&
!
IsSticky
(
flags
(
)
)
)
{
RegExpNode
*
loop_node
=
RegExpQuantifier
:
:
ToNode
(
0
RegExpTree
:
:
kInfinity
false
zone
(
)
-
>
New
<
RegExpClassRanges
>
(
StandardCharacterSet
:
:
kEverything
)
this
captured_body
data
-
>
contains_anchor
)
;
if
(
data
-
>
contains_anchor
)
{
ChoiceNode
*
first_step_node
=
zone
(
)
-
>
New
<
ChoiceNode
>
(
2
zone
(
)
)
;
first_step_node
-
>
AddAlternative
(
GuardedAlternative
(
captured_body
)
)
;
first_step_node
-
>
AddAlternative
(
GuardedAlternative
(
zone
(
)
-
>
New
<
TextNode
>
(
zone
(
)
-
>
New
<
RegExpClassRanges
>
(
StandardCharacterSet
:
:
kEverything
)
false
loop_node
)
)
)
;
node
=
first_step_node
;
}
else
{
node
=
loop_node
;
}
}
if
(
is_one_byte
)
{
node
=
node
-
>
FilterOneByte
(
RegExpCompiler
:
:
kMaxRecursion
this
)
;
if
(
node
!
=
nullptr
)
{
node
=
node
-
>
FilterOneByte
(
RegExpCompiler
:
:
kMaxRecursion
this
)
;
}
}
else
if
(
IsEitherUnicode
(
flags
(
)
)
&
&
(
IsGlobal
(
flags
(
)
)
|
|
IsSticky
(
flags
(
)
)
)
)
{
node
=
OptionallyStepBackToLeadSurrogate
(
node
)
;
}
if
(
node
=
=
nullptr
)
node
=
zone
(
)
-
>
New
<
EndNode
>
(
EndNode
:
:
BACKTRACK
zone
(
)
)
;
if
(
reg_exp_too_big_
)
{
data
-
>
error
=
RegExpError
:
:
kTooLarge
;
}
return
node
;
}
void
RegExpCompiler
:
:
ToNodeCheckForStackOverflow
(
)
{
if
(
StackLimitCheck
{
isolate
(
)
}
.
HasOverflowed
(
)
)
{
V8
:
:
FatalProcessOutOfMemory
(
isolate
(
)
"
RegExpCompiler
"
)
;
}
}
}
