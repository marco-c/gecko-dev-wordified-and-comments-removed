#
ifndef
V8_REGEXP_REGEXP_STACK_H_
#
define
V8_REGEXP_REGEXP_STACK_H_
#
include
"
irregexp
/
RegExpShim
.
h
"
namespace
v8
{
namespace
internal
{
class
RegExpStack
;
class
V8_NODISCARD
RegExpStackScope
final
{
public
:
explicit
RegExpStackScope
(
Isolate
*
isolate
)
;
~
RegExpStackScope
(
)
;
RegExpStackScope
(
const
RegExpStackScope
&
)
=
delete
;
RegExpStackScope
&
operator
=
(
const
RegExpStackScope
&
)
=
delete
;
RegExpStack
*
stack
(
)
const
{
return
regexp_stack_
;
}
private
:
RegExpStack
*
const
regexp_stack_
;
const
ptrdiff_t
old_sp_top_delta_
;
}
;
class
RegExpStack
final
{
public
:
RegExpStack
(
)
;
~
RegExpStack
(
)
;
RegExpStack
(
const
RegExpStack
&
)
=
delete
;
RegExpStack
&
operator
=
(
const
RegExpStack
&
)
=
delete
;
static
constexpr
int
kStackLimitSlack
=
32
;
Address
memory_top
(
)
const
{
DCHECK_NE
(
0
thread_local_
.
memory_size_
)
;
DCHECK_EQ
(
thread_local_
.
memory_top_
thread_local_
.
memory_
+
thread_local_
.
memory_size_
)
;
return
reinterpret_cast
<
Address
>
(
thread_local_
.
memory_top_
)
;
}
Address
stack_pointer
(
)
const
{
return
reinterpret_cast
<
Address
>
(
thread_local_
.
stack_pointer_
)
;
}
size_t
memory_size
(
)
const
{
return
thread_local_
.
memory_size_
;
}
Address
*
limit_address_address
(
)
{
return
&
thread_local_
.
limit_
;
}
Address
EnsureCapacity
(
size_t
size
)
;
static
constexpr
int
ArchiveSpacePerThread
(
)
{
return
static_cast
<
int
>
(
kThreadLocalSize
)
;
}
char
*
ArchiveStack
(
char
*
to
)
;
char
*
RestoreStack
(
char
*
from
)
;
void
FreeThreadResources
(
)
{
thread_local_
.
ResetToStaticStack
(
this
)
;
}
static
constexpr
size_t
kMaximumStackSize
=
64
*
MB
;
private
:
static
const
Address
kMemoryTop
=
static_cast
<
Address
>
(
static_cast
<
uintptr_t
>
(
-
1
)
)
;
static
constexpr
size_t
kMinimumDynamicStackSize
=
1
*
KB
;
static
constexpr
size_t
kStaticStackSize
=
2
*
kStackLimitSlack
*
kSystemPointerSize
;
byte
static_stack_
[
kStaticStackSize
]
=
{
0
}
;
static_assert
(
kStaticStackSize
<
=
kMaximumStackSize
)
;
struct
ThreadLocal
{
explicit
ThreadLocal
(
RegExpStack
*
regexp_stack
)
{
ResetToStaticStack
(
regexp_stack
)
;
}
byte
*
memory_
=
nullptr
;
byte
*
memory_top_
=
nullptr
;
size_t
memory_size_
=
0
;
byte
*
stack_pointer_
=
nullptr
;
Address
limit_
=
kNullAddress
;
bool
owns_memory_
=
false
;
void
ResetToStaticStack
(
RegExpStack
*
regexp_stack
)
;
void
ResetToStaticStackIfEmpty
(
RegExpStack
*
regexp_stack
)
{
if
(
stack_pointer_
=
=
memory_top_
)
ResetToStaticStack
(
regexp_stack
)
;
}
void
FreeAndInvalidate
(
)
;
}
;
static
constexpr
size_t
kThreadLocalSize
=
sizeof
(
ThreadLocal
)
;
Address
memory_top_address_address
(
)
{
return
reinterpret_cast
<
Address
>
(
&
thread_local_
.
memory_top_
)
;
}
Address
stack_pointer_address
(
)
{
return
reinterpret_cast
<
Address
>
(
&
thread_local_
.
stack_pointer_
)
;
}
ptrdiff_t
sp_top_delta
(
)
const
{
ptrdiff_t
result
=
reinterpret_cast
<
intptr_t
>
(
thread_local_
.
stack_pointer_
)
-
reinterpret_cast
<
intptr_t
>
(
thread_local_
.
memory_top_
)
;
DCHECK_LE
(
result
0
)
;
return
result
;
}
void
ResetIfEmpty
(
)
{
thread_local_
.
ResetToStaticStackIfEmpty
(
this
)
;
}
bool
IsValid
(
)
const
{
return
thread_local_
.
memory_
!
=
nullptr
;
}
ThreadLocal
thread_local_
;
friend
class
ExternalReference
;
friend
class
RegExpStackScope
;
}
;
}
}
#
endif
