#
include
"
irregexp
/
imported
/
regexp
-
macro
-
assembler
.
h
"
#
include
"
irregexp
/
imported
/
regexp
-
stack
.
h
"
#
include
"
irregexp
/
imported
/
special
-
case
.
h
"
#
ifdef
V8_INTL_SUPPORT
#
include
"
unicode
/
uchar
.
h
"
#
include
"
unicode
/
unistr
.
h
"
#
endif
namespace
v8
{
namespace
internal
{
RegExpMacroAssembler
:
:
RegExpMacroAssembler
(
Isolate
*
isolate
Zone
*
zone
)
:
slow_safe_compiler_
(
false
)
global_mode_
(
NOT_GLOBAL
)
isolate_
(
isolate
)
zone_
(
zone
)
{
}
RegExpMacroAssembler
:
:
~
RegExpMacroAssembler
(
)
=
default
;
int
RegExpMacroAssembler
:
:
CaseInsensitiveCompareNonUnicode
(
Address
byte_offset1
Address
byte_offset2
size_t
byte_length
Isolate
*
isolate
)
{
#
ifdef
V8_INTL_SUPPORT
DisallowGarbageCollection
no_gc
;
DCHECK_EQ
(
0
byte_length
%
2
)
;
size_t
length
=
byte_length
/
2
;
uc16
*
substring1
=
reinterpret_cast
<
uc16
*
>
(
byte_offset1
)
;
uc16
*
substring2
=
reinterpret_cast
<
uc16
*
>
(
byte_offset2
)
;
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
UChar32
c1
=
RegExpCaseFolding
:
:
Canonicalize
(
substring1
[
i
]
)
;
UChar32
c2
=
RegExpCaseFolding
:
:
Canonicalize
(
substring2
[
i
]
)
;
if
(
c1
!
=
c2
)
{
return
0
;
}
}
return
1
;
#
else
return
CaseInsensitiveCompareUnicode
(
byte_offset1
byte_offset2
byte_length
isolate
)
;
#
endif
}
int
RegExpMacroAssembler
:
:
CaseInsensitiveCompareUnicode
(
Address
byte_offset1
Address
byte_offset2
size_t
byte_length
Isolate
*
isolate
)
{
DisallowGarbageCollection
no_gc
;
DCHECK_EQ
(
0
byte_length
%
2
)
;
#
ifdef
V8_INTL_SUPPORT
int32_t
length
=
static_cast
<
int32_t
>
(
byte_length
>
>
1
)
;
icu
:
:
UnicodeString
uni_str_1
(
reinterpret_cast
<
const
char16_t
*
>
(
byte_offset1
)
length
)
;
return
uni_str_1
.
caseCompare
(
reinterpret_cast
<
const
char16_t
*
>
(
byte_offset2
)
length
U_FOLD_CASE_DEFAULT
)
=
=
0
;
#
else
uc16
*
substring1
=
reinterpret_cast
<
uc16
*
>
(
byte_offset1
)
;
uc16
*
substring2
=
reinterpret_cast
<
uc16
*
>
(
byte_offset2
)
;
size_t
length
=
byte_length
>
>
1
;
DCHECK_NOT_NULL
(
isolate
)
;
unibrow
:
:
Mapping
<
unibrow
:
:
Ecma262Canonicalize
>
*
canonicalize
=
isolate
-
>
regexp_macro_assembler_canonicalize
(
)
;
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
unibrow
:
:
uchar
c1
=
substring1
[
i
]
;
unibrow
:
:
uchar
c2
=
substring2
[
i
]
;
if
(
c1
!
=
c2
)
{
unibrow
:
:
uchar
s1
[
1
]
=
{
c1
}
;
canonicalize
-
>
get
(
c1
'
\
0
'
s1
)
;
if
(
s1
[
0
]
!
=
c2
)
{
unibrow
:
:
uchar
s2
[
1
]
=
{
c2
}
;
canonicalize
-
>
get
(
c2
'
\
0
'
s2
)
;
if
(
s1
[
0
]
!
=
s2
[
0
]
)
{
return
0
;
}
}
}
}
return
1
;
#
endif
}
void
RegExpMacroAssembler
:
:
CheckNotInSurrogatePair
(
int
cp_offset
Label
*
on_failure
)
{
Label
ok
;
LoadCurrentCharacter
(
cp_offset
&
ok
)
;
CheckCharacterNotInRange
(
kTrailSurrogateStart
kTrailSurrogateEnd
&
ok
)
;
LoadCurrentCharacter
(
cp_offset
-
1
&
ok
)
;
CheckCharacterInRange
(
kLeadSurrogateStart
kLeadSurrogateEnd
on_failure
)
;
Bind
(
&
ok
)
;
}
void
RegExpMacroAssembler
:
:
CheckPosition
(
int
cp_offset
Label
*
on_outside_input
)
{
LoadCurrentCharacter
(
cp_offset
on_outside_input
true
)
;
}
void
RegExpMacroAssembler
:
:
LoadCurrentCharacter
(
int
cp_offset
Label
*
on_end_of_input
bool
check_bounds
int
characters
int
eats_at_least
)
{
if
(
eats_at_least
=
=
kUseCharactersValue
)
{
eats_at_least
=
characters
;
}
LoadCurrentCharacterImpl
(
cp_offset
on_end_of_input
check_bounds
characters
eats_at_least
)
;
}
bool
RegExpMacroAssembler
:
:
CheckSpecialCharacterClass
(
uc16
type
Label
*
on_no_match
)
{
return
false
;
}
NativeRegExpMacroAssembler
:
:
NativeRegExpMacroAssembler
(
Isolate
*
isolate
Zone
*
zone
)
:
RegExpMacroAssembler
(
isolate
zone
)
{
}
NativeRegExpMacroAssembler
:
:
~
NativeRegExpMacroAssembler
(
)
=
default
;
void
NativeRegExpMacroAssembler
:
:
LoadCurrentCharacterImpl
(
int
cp_offset
Label
*
on_end_of_input
bool
check_bounds
int
characters
int
eats_at_least
)
{
DCHECK_GE
(
eats_at_least
characters
)
;
DCHECK
(
base
:
:
IsInRange
(
cp_offset
kMinCPOffset
kMaxCPOffset
)
)
;
if
(
check_bounds
)
{
if
(
cp_offset
>
=
0
)
{
CheckPosition
(
cp_offset
+
eats_at_least
-
1
on_end_of_input
)
;
}
else
{
CheckPosition
(
cp_offset
on_end_of_input
)
;
}
}
LoadCurrentCharacterUnchecked
(
cp_offset
characters
)
;
}
bool
NativeRegExpMacroAssembler
:
:
CanReadUnaligned
(
)
{
return
FLAG_enable_regexp_unaligned_accesses
&
&
!
slow_safe
(
)
;
}
#
ifndef
COMPILING_IRREGEXP_FOR_EXTERNAL_EMBEDDER
int
NativeRegExpMacroAssembler
:
:
CheckStackGuardState
(
Isolate
*
isolate
int
start_index
RegExp
:
:
CallOrigin
call_origin
Address
*
return_address
Code
re_code
Address
*
subject
const
byte
*
*
input_start
const
byte
*
*
input_end
)
{
DisallowGarbageCollection
no_gc
;
Address
old_pc
=
PointerAuthentication
:
:
AuthenticatePC
(
return_address
0
)
;
DCHECK_LE
(
re_code
.
raw_instruction_start
(
)
old_pc
)
;
DCHECK_LE
(
old_pc
re_code
.
raw_instruction_end
(
)
)
;
StackLimitCheck
check
(
isolate
)
;
bool
js_has_overflowed
=
check
.
JsHasOverflowed
(
)
;
if
(
call_origin
=
=
RegExp
:
:
CallOrigin
:
:
kFromJs
)
{
if
(
js_has_overflowed
)
{
return
EXCEPTION
;
}
else
if
(
check
.
InterruptRequested
(
)
)
{
return
RETRY
;
}
else
{
return
0
;
}
}
DCHECK
(
call_origin
=
=
RegExp
:
:
CallOrigin
:
:
kFromRuntime
)
;
HandleScope
handles
(
isolate
)
;
Handle
<
Code
>
code_handle
(
re_code
isolate
)
;
Handle
<
String
>
subject_handle
(
String
:
:
cast
(
Object
(
*
subject
)
)
isolate
)
;
bool
is_one_byte
=
String
:
:
IsOneByteRepresentationUnderneath
(
*
subject_handle
)
;
int
return_value
=
0
;
{
DisableGCMole
no_gc_mole
;
if
(
js_has_overflowed
)
{
AllowGarbageCollection
yes_gc
;
isolate
-
>
StackOverflow
(
)
;
return_value
=
EXCEPTION
;
}
else
if
(
check
.
InterruptRequested
(
)
)
{
AllowGarbageCollection
yes_gc
;
Object
result
=
isolate
-
>
stack_guard
(
)
-
>
HandleInterrupts
(
)
;
if
(
result
.
IsException
(
isolate
)
)
return_value
=
EXCEPTION
;
}
if
(
*
code_handle
!
=
re_code
)
{
intptr_t
delta
=
code_handle
-
>
address
(
)
-
re_code
.
address
(
)
;
Address
new_pc
=
old_pc
+
delta
;
PointerAuthentication
:
:
ReplacePC
(
return_address
new_pc
0
)
;
}
}
if
(
return_value
=
=
0
)
{
if
(
String
:
:
IsOneByteRepresentationUnderneath
(
*
subject_handle
)
!
=
is_one_byte
)
{
return_value
=
RETRY
;
}
else
{
*
subject
=
subject_handle
-
>
ptr
(
)
;
intptr_t
byte_length
=
*
input_end
-
*
input_start
;
*
input_start
=
subject_handle
-
>
AddressOfCharacterAt
(
start_index
no_gc
)
;
*
input_end
=
*
input_start
+
byte_length
;
}
}
return
return_value
;
}
int
NativeRegExpMacroAssembler
:
:
Match
(
Handle
<
JSRegExp
>
regexp
Handle
<
String
>
subject
int
*
offsets_vector
int
offsets_vector_length
int
previous_index
Isolate
*
isolate
)
{
DCHECK
(
subject
-
>
IsFlat
(
)
)
;
DCHECK_LE
(
0
previous_index
)
;
DCHECK_LE
(
previous_index
subject
-
>
length
(
)
)
;
String
subject_ptr
=
*
subject
;
int
start_offset
=
previous_index
;
int
char_length
=
subject_ptr
.
length
(
)
-
start_offset
;
int
slice_offset
=
0
;
if
(
StringShape
(
subject_ptr
)
.
IsCons
(
)
)
{
DCHECK_EQ
(
0
ConsString
:
:
cast
(
subject_ptr
)
.
second
(
)
.
length
(
)
)
;
subject_ptr
=
ConsString
:
:
cast
(
subject_ptr
)
.
first
(
)
;
}
else
if
(
StringShape
(
subject_ptr
)
.
IsSliced
(
)
)
{
SlicedString
slice
=
SlicedString
:
:
cast
(
subject_ptr
)
;
subject_ptr
=
slice
.
parent
(
)
;
slice_offset
=
slice
.
offset
(
)
;
}
if
(
StringShape
(
subject_ptr
)
.
IsThin
(
)
)
{
subject_ptr
=
ThinString
:
:
cast
(
subject_ptr
)
.
actual
(
)
;
}
bool
is_one_byte
=
subject_ptr
.
IsOneByteRepresentation
(
)
;
DCHECK
(
subject_ptr
.
IsExternalString
(
)
|
|
subject_ptr
.
IsSeqString
(
)
)
;
int
char_size_shift
=
is_one_byte
?
0
:
1
;
DisallowGarbageCollection
no_gc
;
const
byte
*
input_start
=
subject_ptr
.
AddressOfCharacterAt
(
start_offset
+
slice_offset
no_gc
)
;
int
byte_length
=
char_length
<
<
char_size_shift
;
const
byte
*
input_end
=
input_start
+
byte_length
;
return
Execute
(
*
subject
start_offset
input_start
input_end
offsets_vector
offsets_vector_length
isolate
*
regexp
)
;
}
int
NativeRegExpMacroAssembler
:
:
Execute
(
String
input
int
start_offset
const
byte
*
input_start
const
byte
*
input_end
int
*
output
int
output_size
Isolate
*
isolate
JSRegExp
regexp
)
{
RegExpStackScope
stack_scope
(
isolate
)
;
Address
stack_base
=
stack_scope
.
stack
(
)
-
>
stack_base
(
)
;
bool
is_one_byte
=
String
:
:
IsOneByteRepresentationUnderneath
(
input
)
;
Code
code
=
Code
:
:
cast
(
regexp
.
Code
(
is_one_byte
)
)
;
RegExp
:
:
CallOrigin
call_origin
=
RegExp
:
:
CallOrigin
:
:
kFromRuntime
;
using
RegexpMatcherSig
=
int
(
Address
input_string
int
start_offset
const
byte
*
input_start
const
byte
*
input_end
int
*
output
int
output_size
Address
stack_base
int
call_origin
Isolate
*
isolate
Address
regexp
)
;
auto
fn
=
GeneratedCode
<
RegexpMatcherSig
>
:
:
FromCode
(
code
)
;
int
result
=
fn
.
Call
(
input
.
ptr
(
)
start_offset
input_start
input_end
output
output_size
stack_base
call_origin
isolate
regexp
.
ptr
(
)
)
;
DCHECK_GE
(
result
SMALLEST_REGEXP_RESULT
)
;
if
(
result
=
=
EXCEPTION
&
&
!
isolate
-
>
has_pending_exception
(
)
)
{
AllowGarbageCollection
allow_allocation
;
isolate
-
>
StackOverflow
(
)
;
}
return
result
;
}
#
endif
const
byte
NativeRegExpMacroAssembler
:
:
word_character_map
[
]
=
{
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0x00u
0x00u
0x00u
0x00u
0xFFu
0x00u
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0xFFu
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
0x00u
}
;
Address
NativeRegExpMacroAssembler
:
:
GrowStack
(
Address
stack_pointer
Address
*
stack_base
Isolate
*
isolate
)
{
RegExpStack
*
regexp_stack
=
isolate
-
>
regexp_stack
(
)
;
size_t
size
=
regexp_stack
-
>
stack_capacity
(
)
;
Address
old_stack_base
=
regexp_stack
-
>
stack_base
(
)
;
DCHECK
(
old_stack_base
=
=
*
stack_base
)
;
DCHECK
(
stack_pointer
<
=
old_stack_base
)
;
DCHECK
(
static_cast
<
size_t
>
(
old_stack_base
-
stack_pointer
)
<
=
size
)
;
Address
new_stack_base
=
regexp_stack
-
>
EnsureCapacity
(
size
*
2
)
;
if
(
new_stack_base
=
=
kNullAddress
)
{
return
kNullAddress
;
}
*
stack_base
=
new_stack_base
;
intptr_t
stack_content_size
=
old_stack_base
-
stack_pointer
;
return
new_stack_base
-
stack_content_size
;
}
}
}
