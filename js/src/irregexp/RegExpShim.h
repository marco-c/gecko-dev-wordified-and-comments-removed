#
ifndef
RegexpShim_h
#
define
RegexpShim_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
SegmentedVector
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
<
algorithm
>
#
include
<
cctype
>
#
include
<
iterator
>
#
include
"
irregexp
/
RegExpTypes
.
h
"
#
include
"
irregexp
/
util
/
FlagsShim
.
h
"
#
include
"
irregexp
/
util
/
VectorShim
.
h
"
#
include
"
irregexp
/
util
/
ZoneShim
.
h
"
#
include
"
jit
/
JitCode
.
h
"
#
include
"
jit
/
Label
.
h
"
#
include
"
jit
/
shared
/
Assembler
-
shared
.
h
"
#
include
"
js
/
friend
/
StackLimits
.
h
"
#
include
"
js
/
RegExpFlags
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
threading
/
ExclusiveData
.
h
"
#
include
"
util
/
DifferentialTesting
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
MutexIDs
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
#
include
"
vm
/
RegExpShared
.
h
"
namespace
v8
{
namespace
internal
{
class
Heap
;
class
Isolate
;
class
RegExpMatchInfo
;
class
RegExpStack
;
}
}
#
define
V8_WARN_UNUSED_RESULT
[
[
nodiscard
]
]
#
define
V8_EXPORT_PRIVATE
#
define
V8_FALLTHROUGH
[
[
fallthrough
]
]
#
define
V8_NODISCARD
[
[
nodiscard
]
]
#
define
FATAL
(
x
)
MOZ_CRASH
(
x
)
#
define
UNREACHABLE
(
)
MOZ_CRASH
(
"
unreachable
code
"
)
#
define
UNIMPLEMENTED
(
)
MOZ_CRASH
(
"
unimplemented
code
"
)
#
define
STATIC_ASSERT
(
exp
)
static_assert
(
exp
#
exp
)
#
define
DCHECK
MOZ_ASSERT
#
define
DCHECK_EQ
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
=
=
(
rhs
)
)
#
define
DCHECK_NE
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
!
=
(
rhs
)
)
#
define
DCHECK_GT
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
>
(
rhs
)
)
#
define
DCHECK_GE
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
>
=
(
rhs
)
)
#
define
DCHECK_LT
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
<
(
rhs
)
)
#
define
DCHECK_LE
(
lhs
rhs
)
MOZ_ASSERT
(
(
lhs
)
<
=
(
rhs
)
)
#
define
DCHECK_NULL
(
val
)
MOZ_ASSERT
(
(
val
)
=
=
nullptr
)
#
define
DCHECK_NOT_NULL
(
val
)
MOZ_ASSERT
(
(
val
)
!
=
nullptr
)
#
define
DCHECK_IMPLIES
(
lhs
rhs
)
MOZ_ASSERT_IF
(
lhs
rhs
)
#
define
CHECK
MOZ_RELEASE_ASSERT
#
define
CHECK_LE
(
lhs
rhs
)
MOZ_RELEASE_ASSERT
(
(
lhs
)
<
=
(
rhs
)
)
#
define
CHECK_GE
(
lhs
rhs
)
MOZ_RELEASE_ASSERT
(
(
lhs
)
>
=
(
rhs
)
)
#
define
CONSTEXPR_DCHECK
MOZ_ASSERT
template
<
class
T
>
static
constexpr
inline
T
Min
(
T
t1
T
t2
)
{
return
t1
<
t2
?
t1
:
t2
;
}
template
<
class
T
>
static
constexpr
inline
T
Max
(
T
t1
T
t2
)
{
return
t1
>
t2
?
t1
:
t2
;
}
#
define
MemCopy
memcpy
#
ifdef
_MSC_VER
#
define
V8PRIxPTRDIFF
"
Ix
"
#
define
V8PRIdPTRDIFF
"
Id
"
#
define
V8PRIuPTRDIFF
"
Iu
"
#
else
#
define
V8PRIxPTRDIFF
"
tx
"
#
define
V8PRIdPTRDIFF
"
td
"
#
define
V8PRIuPTRDIFF
"
tu
"
#
endif
#
define
arraysize
std
:
:
size
#
define
DISALLOW_ASSIGN
(
TypeName
)
TypeName
&
operator
=
(
const
TypeName
&
)
=
delete
#
define
DISALLOW_COPY_AND_ASSIGN
(
TypeName
)
\
TypeName
(
const
TypeName
&
)
=
delete
;
\
DISALLOW_ASSIGN
(
TypeName
)
#
define
DISALLOW_IMPLICIT_CONSTRUCTORS
(
TypeName
)
\
TypeName
(
)
=
delete
;
\
DISALLOW_COPY_AND_ASSIGN
(
TypeName
)
namespace
v8
{
template
<
typename
T
typename
U
>
constexpr
inline
bool
IsAligned
(
T
value
U
alignment
)
{
return
(
value
&
(
alignment
-
1
)
)
=
=
0
;
}
using
byte
=
uint8_t
;
using
Address
=
uintptr_t
;
static
const
Address
kNullAddress
=
0
;
using
uc16
=
char16_t
;
using
uc32
=
uint32_t
;
namespace
base
{
struct
Use
{
template
<
typename
T
>
Use
(
T
&
&
)
{
}
}
;
#
define
USE
(
.
.
.
)
\
do
{
\
:
:
v8
:
:
base
:
:
Use
unused_tmp_array_for_use_macro
[
]
{
__VA_ARGS__
}
;
\
(
void
)
unused_tmp_array_for_use_macro
;
\
}
while
(
false
)
template
<
typename
Dst
typename
Src
>
inline
Dst
saturated_cast
(
Src
value
)
;
template
<
>
inline
uint8_t
saturated_cast
<
uint8_t
int
>
(
int
x
)
{
return
(
x
>
=
0
)
?
(
(
x
<
255
)
?
uint8_t
(
x
)
:
255
)
:
0
;
}
template
<
typename
T
typename
U
>
inline
constexpr
bool
IsInRange
(
T
value
U
lower_limit
U
higher_limit
)
{
using
unsigned_T
=
typename
std
:
:
make_unsigned
<
T
>
:
:
type
;
return
static_cast
<
unsigned_T
>
(
static_cast
<
unsigned_T
>
(
value
)
-
static_cast
<
unsigned_T
>
(
lower_limit
)
)
<
=
static_cast
<
unsigned_T
>
(
static_cast
<
unsigned_T
>
(
higher_limit
)
-
static_cast
<
unsigned_T
>
(
lower_limit
)
)
;
}
#
define
LAZY_INSTANCE_INITIALIZER
\
{
}
template
<
typename
T
>
class
LazyInstanceImpl
{
public
:
LazyInstanceImpl
(
)
:
value_
(
js
:
:
mutexid
:
:
IrregexpLazyStatic
)
{
}
const
T
*
Pointer
(
)
{
auto
val
=
value_
.
lock
(
)
;
if
(
val
-
>
isNothing
(
)
)
{
val
-
>
emplace
(
)
;
}
return
val
-
>
ptr
(
)
;
}
private
:
js
:
:
ExclusiveData
<
mozilla
:
:
Maybe
<
T
>
>
value_
;
}
;
template
<
typename
T
>
class
LazyInstance
{
public
:
using
type
=
LazyInstanceImpl
<
T
>
;
}
;
namespace
bits
{
inline
uint64_t
CountTrailingZeros
(
uint64_t
value
)
{
return
mozilla
:
:
CountTrailingZeroes64
(
value
)
;
}
inline
size_t
RoundUpToPowerOfTwo32
(
size_t
value
)
{
return
mozilla
:
:
RoundUpPow2
(
value
)
;
}
template
<
typename
T
>
constexpr
bool
IsPowerOfTwo
(
T
value
)
{
return
value
>
0
&
&
(
value
&
(
value
-
1
)
)
=
=
0
;
}
}
}
namespace
unibrow
{
using
uchar
=
unsigned
int
;
class
Latin1
{
public
:
static
const
uc16
kMaxChar
=
0xff
;
static
inline
uc16
TryConvertToLatin1
(
uc16
c
)
{
if
(
c
=
=
0x039C
|
|
c
=
=
0x03BC
)
{
return
0xB5
;
}
if
(
c
=
=
0x0178
)
{
return
0xFF
;
}
return
c
;
}
}
;
class
Utf16
{
public
:
static
inline
bool
IsLeadSurrogate
(
int
code
)
{
return
js
:
:
unicode
:
:
IsLeadSurrogate
(
code
)
;
}
static
inline
bool
IsTrailSurrogate
(
int
code
)
{
return
js
:
:
unicode
:
:
IsTrailSurrogate
(
code
)
;
}
static
inline
uc16
LeadSurrogate
(
uint32_t
char_code
)
{
return
js
:
:
unicode
:
:
LeadSurrogate
(
char_code
)
;
}
static
inline
uc16
TrailSurrogate
(
uint32_t
char_code
)
{
return
js
:
:
unicode
:
:
TrailSurrogate
(
char_code
)
;
}
static
inline
uint32_t
CombineSurrogatePair
(
char16_t
lead
char16_t
trail
)
{
return
js
:
:
unicode
:
:
UTF16Decode
(
lead
trail
)
;
}
static
const
uchar
kMaxNonSurrogateCharCode
=
0xffff
;
}
;
#
ifndef
V8_INTL_SUPPORT
template
<
class
T
int
size
=
256
>
class
Mapping
{
public
:
inline
Mapping
(
)
=
default
;
inline
int
get
(
uchar
c
uchar
n
uchar
*
result
)
{
CacheEntry
entry
=
entries_
[
c
&
kMask
]
;
if
(
entry
.
code_point_
=
=
c
)
{
if
(
entry
.
offset_
=
=
0
)
{
return
0
;
}
else
{
result
[
0
]
=
c
+
entry
.
offset_
;
return
1
;
}
}
else
{
return
CalculateValue
(
c
n
result
)
;
}
}
private
:
int
CalculateValue
(
uchar
c
uchar
n
uchar
*
result
)
{
bool
allow_caching
=
true
;
int
length
=
T
:
:
Convert
(
c
n
result
&
allow_caching
)
;
if
(
allow_caching
)
{
if
(
length
=
=
1
)
{
entries_
[
c
&
kMask
]
=
CacheEntry
(
c
result
[
0
]
-
c
)
;
return
1
;
}
else
{
entries_
[
c
&
kMask
]
=
CacheEntry
(
c
0
)
;
return
0
;
}
}
else
{
return
length
;
}
}
struct
CacheEntry
{
inline
CacheEntry
(
)
:
code_point_
(
kNoChar
)
offset_
(
0
)
{
}
inline
CacheEntry
(
uchar
code_point
signed
offset
)
:
code_point_
(
code_point
)
offset_
(
offset
)
{
}
uchar
code_point_
;
signed
offset_
;
static
const
int
kNoChar
=
(
1
<
<
21
)
-
1
;
}
;
static
const
int
kSize
=
size
;
static
const
int
kMask
=
kSize
-
1
;
CacheEntry
entries_
[
kSize
]
;
}
;
struct
Ecma262Canonicalize
{
static
const
int
kMaxWidth
=
1
;
static
int
Convert
(
uchar
c
uchar
n
uchar
*
result
bool
*
allow_caching_ptr
)
;
}
;
struct
Ecma262UnCanonicalize
{
static
const
int
kMaxWidth
=
4
;
static
int
Convert
(
uchar
c
uchar
n
uchar
*
result
bool
*
allow_caching_ptr
)
;
}
;
struct
CanonicalizationRange
{
static
const
int
kMaxWidth
=
1
;
static
int
Convert
(
uchar
c
uchar
n
uchar
*
result
bool
*
allow_caching_ptr
)
;
}
;
#
endif
struct
Letter
{
static
bool
Is
(
uchar
c
)
;
}
;
}
namespace
internal
{
#
define
PRINTF_FORMAT
(
x
y
)
MOZ_FORMAT_PRINTF
(
x
y
)
void
PRINTF_FORMAT
(
1
2
)
PrintF
(
const
char
*
format
.
.
.
)
;
void
PRINTF_FORMAT
(
2
3
)
PrintF
(
FILE
*
out
const
char
*
format
.
.
.
)
;
class
AllStatic
{
#
ifdef
DEBUG
public
:
AllStatic
(
)
=
delete
;
#
endif
}
;
class
Malloced
{
public
:
static
void
*
operator
new
(
size_t
size
)
{
js
:
:
AutoEnterOOMUnsafeRegion
oomUnsafe
;
void
*
result
=
js_malloc
(
size
)
;
if
(
!
result
)
{
oomUnsafe
.
crash
(
"
Irregexp
Malloced
shim
"
)
;
}
return
result
;
}
static
void
operator
delete
(
void
*
p
)
{
js_free
(
p
)
;
}
}
;
constexpr
int32_t
KB
=
1024
;
constexpr
int32_t
MB
=
1024
*
1024
;
#
define
kMaxInt
JSVAL_INT_MAX
#
define
kMinInt
JSVAL_INT_MIN
constexpr
int
kSystemPointerSize
=
sizeof
(
void
*
)
;
constexpr
double
kMaxSafeInteger
=
9007199254740991
.
0
;
constexpr
int
kBitsPerByte
=
8
;
constexpr
int
kBitsPerByteLog2
=
3
;
constexpr
int
kUInt32Size
=
sizeof
(
uint32_t
)
;
constexpr
int
kInt64Size
=
sizeof
(
int64_t
)
;
constexpr
int
kUC16Size
=
sizeof
(
uc16
)
;
inline
constexpr
bool
IsDecimalDigit
(
uc32
c
)
{
return
c
>
=
'
0
'
&
&
c
<
=
'
9
'
;
}
inline
bool
is_uint24
(
int64_t
val
)
{
return
(
val
>
>
24
)
=
=
0
;
}
inline
bool
is_int24
(
int64_t
val
)
{
int64_t
limit
=
int64_t
(
1
)
<
<
23
;
return
(
-
limit
<
=
val
)
&
&
(
val
<
limit
)
;
}
inline
bool
IsIdentifierStart
(
uc32
c
)
{
return
js
:
:
unicode
:
:
IsIdentifierStart
(
uint32_t
(
c
)
)
;
}
inline
bool
IsIdentifierPart
(
uc32
c
)
{
return
js
:
:
unicode
:
:
IsIdentifierPart
(
uint32_t
(
c
)
)
;
}
struct
AsUC16
{
explicit
AsUC16
(
char16_t
v
)
:
value
(
v
)
{
}
char16_t
value
;
}
;
struct
AsUC32
{
explicit
AsUC32
(
int32_t
v
)
:
value
(
v
)
{
}
int32_t
value
;
}
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
AsUC16
&
c
)
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
AsUC32
&
c
)
;
class
StdoutStream
{
public
:
operator
std
:
:
ostream
&
(
)
const
;
template
<
typename
T
>
std
:
:
ostream
&
operator
<
<
(
T
t
)
;
}
;
using
mozilla
:
:
Maybe
;
template
<
typename
T
>
Maybe
<
T
>
Just
(
const
T
&
value
)
{
return
mozilla
:
:
Some
(
value
)
;
}
template
<
typename
T
>
mozilla
:
:
Nothing
Nothing
(
)
{
return
mozilla
:
:
Nothing
(
)
;
}
template
<
typename
T
>
using
PseudoHandle
=
mozilla
:
:
UniquePtr
<
T
JS
:
:
FreePolicy
>
;
template
<
typename
lchar
typename
rchar
>
inline
int
CompareCharsUnsigned
(
const
lchar
*
lhs
const
rchar
*
rhs
size_t
chars
)
{
const
lchar
*
limit
=
lhs
+
chars
;
if
(
sizeof
(
*
lhs
)
=
=
sizeof
(
char
)
&
&
sizeof
(
*
rhs
)
=
=
sizeof
(
char
)
)
{
return
memcmp
(
lhs
rhs
chars
)
;
}
while
(
lhs
<
limit
)
{
int
r
=
static_cast
<
int
>
(
*
lhs
)
-
static_cast
<
int
>
(
*
rhs
)
;
if
(
r
!
=
0
)
return
r
;
+
+
lhs
;
+
+
rhs
;
}
return
0
;
}
template
<
typename
lchar
typename
rchar
>
inline
int
CompareChars
(
const
lchar
*
lhs
const
rchar
*
rhs
size_t
chars
)
{
DCHECK_LE
(
sizeof
(
lchar
)
2
)
;
DCHECK_LE
(
sizeof
(
rchar
)
2
)
;
if
(
sizeof
(
lchar
)
=
=
1
)
{
if
(
sizeof
(
rchar
)
=
=
1
)
{
return
CompareCharsUnsigned
(
reinterpret_cast
<
const
uint8_t
*
>
(
lhs
)
reinterpret_cast
<
const
uint8_t
*
>
(
rhs
)
chars
)
;
}
else
{
return
CompareCharsUnsigned
(
reinterpret_cast
<
const
uint8_t
*
>
(
lhs
)
reinterpret_cast
<
const
char16_t
*
>
(
rhs
)
chars
)
;
}
}
else
{
if
(
sizeof
(
rchar
)
=
=
1
)
{
return
CompareCharsUnsigned
(
reinterpret_cast
<
const
char16_t
*
>
(
lhs
)
reinterpret_cast
<
const
uint8_t
*
>
(
rhs
)
chars
)
;
}
else
{
return
CompareCharsUnsigned
(
reinterpret_cast
<
const
char16_t
*
>
(
lhs
)
reinterpret_cast
<
const
char16_t
*
>
(
rhs
)
chars
)
;
}
}
}
template
<
typename
lchar
typename
rchar
>
inline
bool
CompareCharsEqualUnsigned
(
const
lchar
*
lhs
const
rchar
*
rhs
size_t
chars
)
{
STATIC_ASSERT
(
std
:
:
is_unsigned
<
lchar
>
:
:
value
)
;
STATIC_ASSERT
(
std
:
:
is_unsigned
<
rchar
>
:
:
value
)
;
if
(
sizeof
(
*
lhs
)
=
=
sizeof
(
*
rhs
)
)
{
return
memcmp
(
lhs
rhs
chars
*
sizeof
(
*
lhs
)
)
=
=
0
;
}
for
(
const
lchar
*
limit
=
lhs
+
chars
;
lhs
<
limit
;
+
+
lhs
+
+
rhs
)
{
if
(
*
lhs
!
=
*
rhs
)
return
false
;
}
return
true
;
}
template
<
typename
lchar
typename
rchar
>
inline
bool
CompareCharsEqual
(
const
lchar
*
lhs
const
rchar
*
rhs
size_t
chars
)
{
using
ulchar
=
typename
std
:
:
make_unsigned
<
lchar
>
:
:
type
;
using
urchar
=
typename
std
:
:
make_unsigned
<
rchar
>
:
:
type
;
return
CompareCharsEqualUnsigned
(
reinterpret_cast
<
const
ulchar
*
>
(
lhs
)
reinterpret_cast
<
const
urchar
*
>
(
rhs
)
chars
)
;
}
inline
int
HexValue
(
uc32
c
)
{
c
-
=
'
0
'
;
if
(
static_cast
<
unsigned
>
(
c
)
<
=
9
)
return
c
;
c
=
(
c
|
0x20
)
-
(
'
a
'
-
'
0
'
)
;
if
(
static_cast
<
unsigned
>
(
c
)
<
=
5
)
return
c
+
10
;
return
-
1
;
}
class
Object
{
public
:
constexpr
Object
(
)
:
asBits_
(
JS
:
:
Int32Value
(
0
)
.
asRawBits
(
)
)
{
}
Object
(
const
JS
:
:
Value
&
value
)
:
asBits_
(
value
.
asRawBits
(
)
)
{
}
inline
bool
IsException
(
Isolate
*
)
const
{
MOZ_ASSERT
(
!
value
(
)
.
toBoolean
(
)
)
;
return
true
;
}
JS
:
:
Value
value
(
)
const
{
return
JS
:
:
Value
:
:
fromRawBits
(
asBits_
)
;
}
inline
static
Object
cast
(
Object
object
)
{
return
object
;
}
protected
:
void
setValue
(
const
JS
:
:
Value
&
val
)
{
asBits_
=
val
.
asRawBits
(
)
;
}
uint64_t
asBits_
;
}
JS_HAZ_GC_POINTER
;
class
Smi
:
public
Object
{
public
:
static
Smi
FromInt
(
int32_t
value
)
{
Smi
smi
;
smi
.
setValue
(
JS
:
:
Int32Value
(
value
)
)
;
return
smi
;
}
static
inline
int32_t
ToInt
(
const
Object
object
)
{
return
object
.
value
(
)
.
toInt32
(
)
;
}
}
;
class
HeapObject
:
public
Object
{
public
:
inline
static
HeapObject
cast
(
Object
object
)
{
HeapObject
h
;
h
.
setValue
(
object
.
value
(
)
)
;
return
h
;
}
}
;
class
FixedArray
:
public
HeapObject
{
public
:
inline
void
set
(
uint32_t
index
Object
value
)
{
inner
(
)
-
>
setDenseElement
(
index
value
.
value
(
)
)
;
}
inline
static
FixedArray
cast
(
Object
object
)
{
FixedArray
f
;
f
.
setValue
(
object
.
value
(
)
)
;
return
f
;
}
js
:
:
NativeObject
*
inner
(
)
{
return
&
value
(
)
.
toObject
(
)
.
as
<
js
:
:
NativeObject
>
(
)
;
}
}
;
inline
uint8_t
*
ByteArrayData
:
:
data
(
)
{
static_assert
(
alignof
(
uint8_t
)
<
=
alignof
(
ByteArrayData
)
"
The
trailing
data
must
be
aligned
to
start
immediately
"
"
after
the
header
with
no
padding
.
"
)
;
ByteArrayData
*
immediatelyAfter
=
this
+
1
;
return
reinterpret_cast
<
uint8_t
*
>
(
immediatelyAfter
)
;
}
class
ByteArray
:
public
HeapObject
{
protected
:
ByteArrayData
*
inner
(
)
const
{
return
static_cast
<
ByteArrayData
*
>
(
value
(
)
.
toPrivate
(
)
)
;
}
public
:
PseudoHandle
<
ByteArrayData
>
takeOwnership
(
Isolate
*
isolate
)
;
PseudoHandle
<
ByteArrayData
>
maybeTakeOwnership
(
Isolate
*
isolate
)
;
byte
get
(
uint32_t
index
)
{
return
inner
(
)
-
>
get
(
index
)
;
}
void
set
(
uint32_t
index
byte
val
)
{
inner
(
)
-
>
set
(
index
val
)
;
}
uint16_t
get_uint16
(
uint32_t
index
)
{
return
inner
(
)
-
>
get_uint16
(
index
)
;
}
void
set_uint16
(
uint32_t
index
uint16_t
value
)
{
inner
(
)
-
>
set_uint16
(
index
value
)
;
}
uint32_t
length
(
)
const
{
return
inner
(
)
-
>
length
;
}
byte
*
GetDataStartAddress
(
)
{
return
inner
(
)
-
>
data
(
)
;
}
static
ByteArray
cast
(
Object
object
)
{
ByteArray
b
;
b
.
setValue
(
object
.
value
(
)
)
;
return
b
;
}
bool
IsByteArray
(
)
const
{
return
true
;
}
friend
class
SMRegExpMacroAssembler
;
}
;
class
MOZ_STACK_CLASS
HandleScope
{
public
:
HandleScope
(
Isolate
*
isolate
)
;
~
HandleScope
(
)
;
private
:
size_t
level_
=
0
;
size_t
non_gc_level_
=
0
;
Isolate
*
isolate_
;
friend
class
Isolate
;
}
;
template
<
typename
T
>
class
MOZ_NONHEAP_CLASS
Handle
{
public
:
Handle
(
)
:
location_
(
nullptr
)
{
}
Handle
(
T
object
Isolate
*
isolate
)
;
Handle
(
const
JS
:
:
Value
&
value
Isolate
*
isolate
)
;
template
<
typename
S
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
S
*
T
*
>
>
>
inline
Handle
(
Handle
<
S
>
handle
)
:
location_
(
handle
.
location_
)
{
}
inline
bool
is_null
(
)
const
{
return
location_
=
=
nullptr
;
}
inline
T
operator
*
(
)
const
{
return
T
:
:
cast
(
Object
(
*
location_
)
)
;
}
;
class
MOZ_TEMPORARY_CLASS
ObjectRef
{
public
:
T
*
operator
-
>
(
)
{
return
&
object_
;
}
private
:
friend
class
Handle
;
explicit
ObjectRef
(
T
object
)
:
object_
(
object
)
{
}
T
object_
;
}
;
inline
ObjectRef
operator
-
>
(
)
const
{
return
ObjectRef
{
*
*
this
}
;
}
static
Handle
<
T
>
fromHandleValue
(
JS
:
:
HandleValue
handle
)
{
return
Handle
(
handle
.
address
(
)
)
;
}
private
:
Handle
(
const
JS
:
:
Value
*
location
)
:
location_
(
location
)
{
}
template
<
typename
>
friend
class
Handle
;
template
<
typename
>
friend
class
MaybeHandle
;
const
JS
:
:
Value
*
location_
;
}
;
template
<
typename
T
>
class
MOZ_NONHEAP_CLASS
MaybeHandle
final
{
public
:
MaybeHandle
(
)
:
location_
(
nullptr
)
{
}
template
<
typename
S
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
S
*
T
*
>
>
>
MaybeHandle
(
Handle
<
S
>
handle
)
:
location_
(
handle
.
location_
)
{
}
inline
Handle
<
T
>
ToHandleChecked
(
)
const
{
MOZ_RELEASE_ASSERT
(
location_
)
;
return
Handle
<
T
>
(
location_
)
;
}
template
<
typename
S
>
inline
bool
ToHandle
(
Handle
<
S
>
*
out
)
const
{
if
(
location_
)
{
*
out
=
Handle
<
T
>
(
location_
)
;
return
true
;
}
else
{
*
out
=
Handle
<
T
>
(
)
;
return
false
;
}
}
private
:
JS
:
:
Value
*
location_
;
}
;
template
<
typename
T
>
inline
Handle
<
T
>
handle
(
T
object
Isolate
*
isolate
)
{
return
Handle
<
T
>
(
object
isolate
)
;
}
using
DisallowGarbageCollection
=
JS
:
:
AutoAssertNoGC
;
class
AllowGarbageCollection
{
public
:
AllowGarbageCollection
(
)
{
}
}
;
class
String
:
public
HeapObject
{
private
:
JSString
*
str
(
)
const
{
return
value
(
)
.
toString
(
)
;
}
public
:
String
(
)
=
default
;
String
(
JSString
*
str
)
{
setValue
(
JS
:
:
StringValue
(
str
)
)
;
}
operator
JSString
*
(
)
const
{
return
str
(
)
;
}
static
const
int32_t
kMaxOneByteCharCode
=
unibrow
:
:
Latin1
:
:
kMaxChar
;
static
const
uint32_t
kMaxOneByteCharCodeU
=
unibrow
:
:
Latin1
:
:
kMaxChar
;
static
const
int
kMaxUtf16CodeUnit
=
0xffff
;
static
const
uint32_t
kMaxUtf16CodeUnitU
=
kMaxUtf16CodeUnit
;
static
const
uc32
kMaxCodePoint
=
0x10ffff
;
MOZ_ALWAYS_INLINE
int
length
(
)
const
{
return
str
(
)
-
>
length
(
)
;
}
bool
IsFlat
(
)
{
return
str
(
)
-
>
isLinear
(
)
;
}
;
class
FlatContent
{
public
:
FlatContent
(
JSLinearString
*
string
const
DisallowGarbageCollection
&
no_gc
)
:
string_
(
string
)
no_gc_
(
no_gc
)
{
}
inline
bool
IsOneByte
(
)
const
{
return
string_
-
>
hasLatin1Chars
(
)
;
}
inline
bool
IsTwoByte
(
)
const
{
return
!
string_
-
>
hasLatin1Chars
(
)
;
}
Vector
<
const
uint8_t
>
ToOneByteVector
(
)
const
{
MOZ_ASSERT
(
IsOneByte
(
)
)
;
return
Vector
<
const
uint8_t
>
(
string_
-
>
latin1Chars
(
no_gc_
)
string_
-
>
length
(
)
)
;
}
Vector
<
const
uc16
>
ToUC16Vector
(
)
const
{
MOZ_ASSERT
(
IsTwoByte
(
)
)
;
return
Vector
<
const
uc16
>
(
string_
-
>
twoByteChars
(
no_gc_
)
string_
-
>
length
(
)
)
;
}
private
:
const
JSLinearString
*
string_
;
const
JS
:
:
AutoAssertNoGC
&
no_gc_
;
}
;
FlatContent
GetFlatContent
(
const
DisallowGarbageCollection
&
no_gc
)
{
MOZ_ASSERT
(
IsFlat
(
)
)
;
return
FlatContent
(
&
str
(
)
-
>
asLinear
(
)
no_gc
)
;
}
static
Handle
<
String
>
Flatten
(
Isolate
*
isolate
Handle
<
String
>
string
)
;
inline
static
String
cast
(
Object
object
)
{
String
s
;
MOZ_ASSERT
(
object
.
value
(
)
.
isString
(
)
)
;
s
.
setValue
(
object
.
value
(
)
)
;
return
s
;
}
inline
static
bool
IsOneByteRepresentationUnderneath
(
String
string
)
{
return
string
.
str
(
)
-
>
hasLatin1Chars
(
)
;
}
inline
bool
IsOneByteRepresentation
(
)
const
{
return
str
(
)
-
>
hasLatin1Chars
(
)
;
}
std
:
:
unique_ptr
<
char
[
]
>
ToCString
(
)
;
template
<
typename
Char
>
Vector
<
const
Char
>
GetCharVector
(
const
DisallowGarbageCollection
&
no_gc
)
;
}
;
template
<
>
inline
Vector
<
const
uint8_t
>
String
:
:
GetCharVector
(
const
DisallowGarbageCollection
&
no_gc
)
{
String
:
:
FlatContent
flat
=
GetFlatContent
(
no_gc
)
;
MOZ_ASSERT
(
flat
.
IsOneByte
(
)
)
;
return
flat
.
ToOneByteVector
(
)
;
}
template
<
>
inline
Vector
<
const
uc16
>
String
:
:
GetCharVector
(
const
DisallowGarbageCollection
&
no_gc
)
{
String
:
:
FlatContent
flat
=
GetFlatContent
(
no_gc
)
;
MOZ_ASSERT
(
flat
.
IsTwoByte
(
)
)
;
return
flat
.
ToUC16Vector
(
)
;
}
class
JSRegExp
:
public
HeapObject
{
public
:
JSRegExp
(
)
:
HeapObject
(
)
{
}
JSRegExp
(
js
:
:
RegExpShared
*
re
)
{
setValue
(
JS
:
:
PrivateGCThingValue
(
re
)
)
;
}
void
TierUpTick
(
)
{
inner
(
)
-
>
tierUpTick
(
)
;
}
Object
Code
(
bool
is_latin1
)
const
{
return
Object
(
JS
:
:
PrivateGCThingValue
(
inner
(
)
-
>
getJitCode
(
is_latin1
)
)
)
;
}
Object
Bytecode
(
bool
is_latin1
)
const
{
return
Object
(
JS
:
:
PrivateValue
(
inner
(
)
-
>
getByteCode
(
is_latin1
)
)
)
;
}
uint32_t
BacktrackLimit
(
)
const
{
return
0
;
}
static
JSRegExp
cast
(
Object
object
)
{
JSRegExp
regexp
;
js
:
:
gc
:
:
Cell
*
regexpShared
=
object
.
value
(
)
.
toGCThing
(
)
;
MOZ_ASSERT
(
regexpShared
-
>
is
<
js
:
:
RegExpShared
>
(
)
)
;
regexp
.
setValue
(
JS
:
:
PrivateGCThingValue
(
regexpShared
)
)
;
return
regexp
;
}
static
constexpr
int
RegistersForCaptureCount
(
int
count
)
{
return
(
count
+
1
)
*
2
;
}
inline
int
MaxRegisterCount
(
)
const
{
return
inner
(
)
-
>
getMaxRegisters
(
)
;
}
static
constexpr
int
kMaxCaptures
=
(
1
<
<
15
)
-
1
;
static
constexpr
int
kNoBacktrackLimit
=
0
;
private
:
js
:
:
RegExpShared
*
inner
(
)
const
{
return
value
(
)
.
toGCThing
(
)
-
>
as
<
js
:
:
RegExpShared
>
(
)
;
}
}
;
using
RegExpFlags
=
JS
:
:
RegExpFlags
;
inline
bool
IsUnicode
(
RegExpFlags
flags
)
{
return
flags
.
unicode
(
)
;
}
inline
bool
IsGlobal
(
RegExpFlags
flags
)
{
return
flags
.
global
(
)
;
}
inline
bool
IsIgnoreCase
(
RegExpFlags
flags
)
{
return
flags
.
ignoreCase
(
)
;
}
inline
bool
IsMultiline
(
RegExpFlags
flags
)
{
return
flags
.
multiline
(
)
;
}
inline
bool
IsDotAll
(
RegExpFlags
flags
)
{
return
flags
.
dotAll
(
)
;
}
inline
bool
IsSticky
(
RegExpFlags
flags
)
{
return
flags
.
sticky
(
)
;
}
class
Histogram
{
public
:
inline
void
AddSample
(
int
sample
)
{
}
}
;
class
Counters
{
public
:
Histogram
*
regexp_backtracks
(
)
{
return
&
regexp_backtracks_
;
}
private
:
Histogram
regexp_backtracks_
;
}
;
#
define
PROFILE
(
isolate
call
)
\
do
{
\
}
while
(
false
)
;
enum
class
AllocationType
:
uint8_t
{
kYoung
kOld
}
;
using
StackGuard
=
Isolate
;
using
Factory
=
Isolate
;
class
Isolate
{
public
:
Isolate
(
JSContext
*
cx
)
:
cx_
(
cx
)
{
}
~
Isolate
(
)
;
bool
init
(
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
RegExpStack
*
regexp_stack
(
)
const
{
return
regexpStack_
;
}
void
StackOverflow
(
)
{
}
#
ifndef
V8_INTL_SUPPORT
unibrow
:
:
Mapping
<
unibrow
:
:
Ecma262UnCanonicalize
>
*
jsregexp_uncanonicalize
(
)
{
return
&
jsregexp_uncanonicalize_
;
}
unibrow
:
:
Mapping
<
unibrow
:
:
Ecma262Canonicalize
>
*
regexp_macro_assembler_canonicalize
(
)
{
return
&
regexp_macro_assembler_canonicalize_
;
}
unibrow
:
:
Mapping
<
unibrow
:
:
CanonicalizationRange
>
*
jsregexp_canonrange
(
)
{
return
&
jsregexp_canonrange_
;
}
private
:
unibrow
:
:
Mapping
<
unibrow
:
:
Ecma262UnCanonicalize
>
jsregexp_uncanonicalize_
;
unibrow
:
:
Mapping
<
unibrow
:
:
Ecma262Canonicalize
>
regexp_macro_assembler_canonicalize_
;
unibrow
:
:
Mapping
<
unibrow
:
:
CanonicalizationRange
>
jsregexp_canonrange_
;
#
endif
public
:
void
IncreaseTotalRegexpCodeGenerated
(
Handle
<
HeapObject
>
code
)
{
}
Counters
*
counters
(
)
{
return
&
counters_
;
}
inline
Factory
*
factory
(
)
{
return
this
;
}
Handle
<
ByteArray
>
NewByteArray
(
int
length
AllocationType
allocation
=
AllocationType
:
:
kYoung
)
;
Handle
<
FixedArray
>
NewFixedArray
(
int
length
)
;
template
<
typename
Char
>
Handle
<
String
>
InternalizeString
(
const
Vector
<
const
Char
>
&
str
)
;
inline
StackGuard
*
stack_guard
(
)
{
return
this
;
}
Object
HandleInterrupts
(
)
{
return
Object
(
JS
:
:
BooleanValue
(
false
)
)
;
}
JSContext
*
cx
(
)
const
{
return
cx_
;
}
void
trace
(
JSTracer
*
trc
)
;
JS
:
:
Value
*
getHandleLocation
(
const
JS
:
:
Value
&
value
)
;
private
:
mozilla
:
:
SegmentedVector
<
JS
:
:
Value
256
>
handleArena_
;
mozilla
:
:
SegmentedVector
<
PseudoHandle
<
void
>
256
>
uniquePtrArena_
;
void
*
allocatePseudoHandle
(
size_t
bytes
)
;
public
:
template
<
typename
T
>
PseudoHandle
<
T
>
takeOwnership
(
void
*
ptr
)
;
template
<
typename
T
>
PseudoHandle
<
T
>
maybeTakeOwnership
(
void
*
ptr
)
;
uint32_t
liveHandles
(
)
const
{
return
handleArena_
.
Length
(
)
;
}
uint32_t
livePseudoHandles
(
)
const
{
return
uniquePtrArena_
.
Length
(
)
;
}
private
:
void
openHandleScope
(
HandleScope
&
scope
)
{
scope
.
level_
=
handleArena_
.
Length
(
)
;
scope
.
non_gc_level_
=
uniquePtrArena_
.
Length
(
)
;
}
void
closeHandleScope
(
size_t
prevLevel
size_t
prevUniqueLevel
)
{
size_t
currLevel
=
handleArena_
.
Length
(
)
;
handleArena_
.
PopLastN
(
currLevel
-
prevLevel
)
;
size_t
currUniqueLevel
=
uniquePtrArena_
.
Length
(
)
;
uniquePtrArena_
.
PopLastN
(
currUniqueLevel
-
prevUniqueLevel
)
;
}
friend
class
HandleScope
;
JSContext
*
cx_
;
RegExpStack
*
regexpStack_
{
}
;
Counters
counters_
{
}
;
#
ifdef
DEBUG
public
:
uint32_t
shouldSimulateInterrupt_
=
0
;
#
endif
}
;
class
StackLimitCheck
{
public
:
StackLimitCheck
(
Isolate
*
isolate
)
:
cx_
(
isolate
-
>
cx
(
)
)
recursion_
(
cx_
)
{
}
bool
HasOverflowed
(
)
{
bool
overflowed
=
!
recursion_
.
checkDontReport
(
cx_
)
;
if
(
overflowed
&
&
js
:
:
SupportDifferentialTesting
(
)
)
{
fprintf
(
stderr
"
ReportOverRecursed
called
\
n
"
)
;
}
return
overflowed
;
}
bool
InterruptRequested
(
)
{
return
cx_
-
>
hasPendingInterrupt
(
js
:
:
InterruptReason
:
:
CallbackUrgent
)
;
}
bool
JsHasOverflowed
(
)
{
return
!
recursion_
.
checkConservativeDontReport
(
cx_
)
;
}
private
:
JSContext
*
cx_
;
js
:
:
AutoCheckRecursionLimit
recursion_
;
}
;
class
ExternalReference
{
public
:
static
const
void
*
TopOfRegexpStack
(
Isolate
*
isolate
)
;
static
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
RegExpStack
*
regexpStack
)
;
}
;
class
Code
:
public
HeapObject
{
public
:
uint8_t
*
raw_instruction_start
(
)
{
return
inner
(
)
-
>
raw
(
)
;
}
static
Code
cast
(
Object
object
)
{
Code
c
;
js
:
:
gc
:
:
Cell
*
jitCode
=
object
.
value
(
)
.
toGCThing
(
)
;
MOZ_ASSERT
(
jitCode
-
>
is
<
js
:
:
jit
:
:
JitCode
>
(
)
)
;
c
.
setValue
(
JS
:
:
PrivateGCThingValue
(
jitCode
)
)
;
return
c
;
}
js
:
:
jit
:
:
JitCode
*
inner
(
)
{
return
value
(
)
.
toGCThing
(
)
-
>
as
<
js
:
:
jit
:
:
JitCode
>
(
)
;
}
}
;
enum
class
MessageTemplate
{
kStackOverflow
}
;
class
MessageFormatter
{
public
:
static
const
char
*
TemplateString
(
MessageTemplate
index
)
{
switch
(
index
)
{
case
MessageTemplate
:
:
kStackOverflow
:
return
"
too
much
recursion
"
;
}
}
}
;
class
Label
{
public
:
Label
(
)
:
inner_
(
js
:
:
jit
:
:
Label
(
)
)
{
}
js
:
:
jit
:
:
Label
*
inner
(
)
{
return
&
inner_
;
}
void
Unuse
(
)
{
inner_
.
reset
(
)
;
}
bool
is_linked
(
)
{
return
inner_
.
used
(
)
;
}
bool
is_bound
(
)
{
return
inner_
.
bound
(
)
;
}
bool
is_unused
(
)
{
return
!
inner_
.
used
(
)
&
&
!
inner_
.
bound
(
)
;
}
int
pos
(
)
{
return
inner_
.
offset
(
)
;
}
void
link_to
(
int
pos
)
{
inner_
.
use
(
pos
)
;
}
void
bind_to
(
int
pos
)
{
inner_
.
bind
(
pos
)
;
}
private
:
js
:
:
jit
:
:
Label
inner_
;
js
:
:
jit
:
:
CodeOffset
patchOffset_
;
friend
class
SMRegExpMacroAssembler
;
}
;
const
bool
FLAG_correctness_fuzzer_suppressions
=
false
;
const
bool
FLAG_enable_regexp_unaligned_accesses
=
false
;
const
bool
FLAG_harmony_regexp_sequence
=
false
;
const
bool
FLAG_regexp_interpret_all
=
false
;
const
bool
FLAG_regexp_mode_modifiers
=
false
;
const
bool
FLAG_regexp_possessive_quantifier
=
false
;
const
bool
FLAG_regexp_optimization
=
true
;
#
if
MOZ_BIG_ENDIAN
(
)
const
bool
FLAG_regexp_peephole_optimization
=
false
;
#
else
const
bool
FLAG_regexp_peephole_optimization
=
true
;
#
endif
const
bool
FLAG_regexp_tier_up
=
true
;
#
define
FLAG_trace_regexp_bytecodes
js
:
:
jit
:
:
JitOptions
.
traceRegExpInterpreter
#
define
FLAG_trace_regexp_parser
js
:
:
jit
:
:
JitOptions
.
traceRegExpParser
#
define
FLAG_trace_regexp_peephole_optimization
\
js
:
:
jit
:
:
JitOptions
.
traceRegExpPeephole
#
define
V8_USE_COMPUTED_GOTO
1
#
define
COMPILING_IRREGEXP_FOR_EXTERNAL_EMBEDDER
}
}
#
endif
