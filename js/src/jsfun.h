#
ifndef
jsfun_h
#
define
jsfun_h
#
include
"
jsobj
.
h
"
#
include
"
jsscript
.
h
"
#
include
"
jstypes
.
h
"
namespace
js
{
class
FunctionExtended
;
typedef
JSNative
Native
;
}
struct
JSAtomState
;
static
const
uint32_t
JSSLOT_BOUND_FUNCTION_TARGET
=
2
;
static
const
uint32_t
JSSLOT_BOUND_FUNCTION_THIS
=
3
;
static
const
uint32_t
JSSLOT_BOUND_FUNCTION_ARGS
=
4
;
static
const
char
FunctionConstructorMedialSigils
[
]
=
"
)
{
\
n
"
;
static
const
char
FunctionConstructorFinalBrace
[
]
=
"
\
n
}
"
;
enum
class
FunctionPrefixKind
{
None
Get
Set
}
;
class
JSFunction
:
public
js
:
:
NativeObject
{
public
:
static
const
js
:
:
Class
class_
;
enum
FunctionKind
{
NormalFunction
=
0
Arrow
Method
ClassConstructor
Getter
Setter
AsmJS
FunctionKindLimit
}
;
enum
Flags
{
INTERPRETED
=
0x0001
CONSTRUCTOR
=
0x0002
EXTENDED
=
0x0004
BOUND_FUN
=
0x0008
HAS_GUESSED_ATOM
=
0x0020
HAS_BOUND_FUNCTION_NAME_PREFIX
=
0x0020
LAMBDA
=
0x0040
SELF_HOSTED
=
0x0080
HAS_COMPILE_TIME_NAME
=
0x0100
INTERPRETED_LAZY
=
0x0200
RESOLVED_LENGTH
=
0x0400
RESOLVED_NAME
=
0x0800
FUNCTION_KIND_SHIFT
=
13
FUNCTION_KIND_MASK
=
0x7
<
<
FUNCTION_KIND_SHIFT
ASMJS_KIND
=
AsmJS
<
<
FUNCTION_KIND_SHIFT
ARROW_KIND
=
Arrow
<
<
FUNCTION_KIND_SHIFT
METHOD_KIND
=
Method
<
<
FUNCTION_KIND_SHIFT
CLASSCONSTRUCTOR_KIND
=
ClassConstructor
<
<
FUNCTION_KIND_SHIFT
GETTER_KIND
=
Getter
<
<
FUNCTION_KIND_SHIFT
SETTER_KIND
=
Setter
<
<
FUNCTION_KIND_SHIFT
NATIVE_FUN
=
0
NATIVE_CTOR
=
NATIVE_FUN
|
CONSTRUCTOR
NATIVE_CLASS_CTOR
=
NATIVE_FUN
|
CONSTRUCTOR
|
CLASSCONSTRUCTOR_KIND
ASMJS_CTOR
=
ASMJS_KIND
|
NATIVE_CTOR
ASMJS_LAMBDA_CTOR
=
ASMJS_KIND
|
NATIVE_CTOR
|
LAMBDA
INTERPRETED_METHOD
=
INTERPRETED
|
METHOD_KIND
INTERPRETED_METHOD_GENERATOR_OR_ASYNC
=
INTERPRETED
|
METHOD_KIND
INTERPRETED_CLASS_CONSTRUCTOR
=
INTERPRETED
|
CLASSCONSTRUCTOR_KIND
|
CONSTRUCTOR
INTERPRETED_GETTER
=
INTERPRETED
|
GETTER_KIND
INTERPRETED_SETTER
=
INTERPRETED
|
SETTER_KIND
INTERPRETED_LAMBDA
=
INTERPRETED
|
LAMBDA
|
CONSTRUCTOR
INTERPRETED_LAMBDA_ARROW
=
INTERPRETED
|
LAMBDA
|
ARROW_KIND
INTERPRETED_LAMBDA_GENERATOR_OR_ASYNC
=
INTERPRETED
|
LAMBDA
INTERPRETED_NORMAL
=
INTERPRETED
|
CONSTRUCTOR
INTERPRETED_GENERATOR_OR_ASYNC
=
INTERPRETED
NO_XDR_FLAGS
=
RESOLVED_LENGTH
|
RESOLVED_NAME
STABLE_ACROSS_CLONES
=
CONSTRUCTOR
|
LAMBDA
|
SELF_HOSTED
|
HAS_COMPILE_TIME_NAME
|
FUNCTION_KIND_MASK
}
;
static_assert
(
(
INTERPRETED
|
INTERPRETED_LAZY
)
=
=
js
:
:
JS_FUNCTION_INTERPRETED_BITS
"
jsfriendapi
.
h
'
s
JSFunction
:
:
INTERPRETED
-
alike
is
wrong
"
)
;
static_assert
(
(
(
FunctionKindLimit
-
1
)
<
<
FUNCTION_KIND_SHIFT
)
<
=
FUNCTION_KIND_MASK
"
FunctionKind
doesn
'
t
fit
into
flags_
"
)
;
private
:
uint16_t
nargs_
;
uint16_t
flags_
;
union
U
{
class
Native
{
friend
class
JSFunction
;
js
:
:
Native
native
;
const
JSJitInfo
*
jitinfo
;
}
n
;
struct
Scripted
{
union
{
JSScript
*
script_
;
js
:
:
LazyScript
*
lazy_
;
}
s
;
JSObject
*
env_
;
}
i
;
void
*
nativeOrScript
;
}
u
;
js
:
:
GCPtrAtom
atom_
;
public
:
bool
needsCallObject
(
)
const
{
MOZ_ASSERT
(
!
isInterpretedLazy
(
)
)
;
if
(
isNative
(
)
)
return
false
;
MOZ_ASSERT_IF
(
nonLazyScript
(
)
-
>
funHasExtensibleScope
(
)
|
|
nonLazyScript
(
)
-
>
needsHomeObject
(
)
|
|
nonLazyScript
(
)
-
>
isDerivedClassConstructor
(
)
|
|
isStarGenerator
(
)
|
|
isLegacyGenerator
(
)
|
|
isAsync
(
)
nonLazyScript
(
)
-
>
bodyScope
(
)
-
>
hasEnvironment
(
)
)
;
return
nonLazyScript
(
)
-
>
bodyScope
(
)
-
>
hasEnvironment
(
)
;
}
bool
needsExtraBodyVarEnvironment
(
)
const
;
bool
needsNamedLambdaEnvironment
(
)
const
;
bool
needsFunctionEnvironmentObjects
(
)
const
{
return
needsCallObject
(
)
|
|
needsNamedLambdaEnvironment
(
)
;
}
bool
needsSomeEnvironmentObject
(
)
const
{
return
needsFunctionEnvironmentObjects
(
)
|
|
needsExtraBodyVarEnvironment
(
)
;
}
size_t
nargs
(
)
const
{
return
nargs_
;
}
uint16_t
flags
(
)
const
{
return
flags_
;
}
FunctionKind
kind
(
)
const
{
return
static_cast
<
FunctionKind
>
(
(
flags_
&
FUNCTION_KIND_MASK
)
>
>
FUNCTION_KIND_SHIFT
)
;
}
bool
isInterpreted
(
)
const
{
return
flags
(
)
&
(
INTERPRETED
|
INTERPRETED_LAZY
)
;
}
bool
isNative
(
)
const
{
return
!
isInterpreted
(
)
;
}
bool
isConstructor
(
)
const
{
return
flags
(
)
&
CONSTRUCTOR
;
}
bool
isAsmJSNative
(
)
const
{
return
kind
(
)
=
=
AsmJS
;
}
bool
isBoundFunction
(
)
const
{
return
flags
(
)
&
BOUND_FUN
;
}
bool
hasCompileTimeName
(
)
const
{
return
flags
(
)
&
HAS_COMPILE_TIME_NAME
;
}
bool
hasGuessedAtom
(
)
const
{
static_assert
(
HAS_GUESSED_ATOM
=
=
HAS_BOUND_FUNCTION_NAME_PREFIX
"
HAS_GUESSED_ATOM
is
unused
for
bound
functions
"
)
;
return
(
flags
(
)
&
(
HAS_GUESSED_ATOM
|
BOUND_FUN
)
)
=
=
HAS_GUESSED_ATOM
;
}
bool
hasBoundFunctionNamePrefix
(
)
const
{
static_assert
(
HAS_BOUND_FUNCTION_NAME_PREFIX
=
=
HAS_GUESSED_ATOM
"
HAS_BOUND_FUNCTION_NAME_PREFIX
is
only
used
for
bound
functions
"
)
;
MOZ_ASSERT
(
isBoundFunction
(
)
)
;
return
flags
(
)
&
HAS_BOUND_FUNCTION_NAME_PREFIX
;
}
bool
isLambda
(
)
const
{
return
flags
(
)
&
LAMBDA
;
}
bool
isInterpretedLazy
(
)
const
{
return
flags
(
)
&
INTERPRETED_LAZY
;
}
bool
hasScript
(
)
const
{
return
flags
(
)
&
INTERPRETED
;
}
bool
infallibleIsDefaultClassConstructor
(
JSContext
*
cx
)
const
;
bool
isArrow
(
)
const
{
return
kind
(
)
=
=
Arrow
;
}
bool
isMethod
(
)
const
{
return
kind
(
)
=
=
Method
|
|
kind
(
)
=
=
ClassConstructor
;
}
bool
isClassConstructor
(
)
const
{
return
kind
(
)
=
=
ClassConstructor
;
}
bool
isGetter
(
)
const
{
return
kind
(
)
=
=
Getter
;
}
bool
isSetter
(
)
const
{
return
kind
(
)
=
=
Setter
;
}
bool
allowSuperProperty
(
)
const
{
return
isMethod
(
)
|
|
isGetter
(
)
|
|
isSetter
(
)
;
}
bool
hasResolvedLength
(
)
const
{
return
flags
(
)
&
RESOLVED_LENGTH
;
}
bool
hasResolvedName
(
)
const
{
return
flags
(
)
&
RESOLVED_NAME
;
}
bool
isSelfHostedOrIntrinsic
(
)
const
{
return
flags
(
)
&
SELF_HOSTED
;
}
bool
isSelfHostedBuiltin
(
)
const
{
return
isSelfHostedOrIntrinsic
(
)
&
&
!
isNative
(
)
;
}
bool
isIntrinsic
(
)
const
{
return
isSelfHostedOrIntrinsic
(
)
&
&
isNative
(
)
;
}
bool
hasJITCode
(
)
const
{
if
(
!
hasScript
(
)
)
return
false
;
return
nonLazyScript
(
)
-
>
hasBaselineScript
(
)
|
|
nonLazyScript
(
)
-
>
hasIonScript
(
)
;
}
bool
isBuiltin
(
)
const
{
return
(
isNative
(
)
&
&
!
isAsmJSNative
(
)
)
|
|
isSelfHostedBuiltin
(
)
;
}
bool
isNamedLambda
(
)
const
{
return
isLambda
(
)
&
&
displayAtom
(
)
&
&
!
hasCompileTimeName
(
)
&
&
!
hasGuessedAtom
(
)
;
}
bool
hasLexicalThis
(
)
const
{
return
isArrow
(
)
|
|
nonLazyScript
(
)
-
>
isGeneratorExp
(
)
;
}
bool
isBuiltinFunctionConstructor
(
)
;
bool
needsPrototypeProperty
(
)
;
bool
strict
(
)
const
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
return
isInterpretedLazy
(
)
?
lazyScript
(
)
-
>
strict
(
)
:
nonLazyScript
(
)
-
>
strict
(
)
;
}
void
setFlags
(
uint16_t
flags
)
{
this
-
>
flags_
=
flags
;
}
void
setKind
(
FunctionKind
kind
)
{
this
-
>
flags_
&
=
~
FUNCTION_KIND_MASK
;
this
-
>
flags_
|
=
static_cast
<
uint16_t
>
(
kind
)
<
<
FUNCTION_KIND_SHIFT
;
}
void
setIsConstructor
(
)
{
MOZ_ASSERT
(
!
isConstructor
(
)
)
;
MOZ_ASSERT
(
isSelfHostedBuiltin
(
)
)
;
flags_
|
=
CONSTRUCTOR
;
}
void
setIsClassConstructor
(
)
{
MOZ_ASSERT
(
!
isClassConstructor
(
)
)
;
MOZ_ASSERT
(
isConstructor
(
)
)
;
setKind
(
ClassConstructor
)
;
}
void
setArgCount
(
uint16_t
nargs
)
{
this
-
>
nargs_
=
nargs
;
}
void
setIsBoundFunction
(
)
{
MOZ_ASSERT
(
!
isBoundFunction
(
)
)
;
flags_
|
=
BOUND_FUN
;
}
void
setIsSelfHostedBuiltin
(
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
MOZ_ASSERT
(
!
isSelfHostedBuiltin
(
)
)
;
flags_
|
=
SELF_HOSTED
;
flags_
&
=
~
CONSTRUCTOR
;
}
void
setIsIntrinsic
(
)
{
MOZ_ASSERT
(
isNative
(
)
)
;
MOZ_ASSERT
(
!
isIntrinsic
(
)
)
;
flags_
|
=
SELF_HOSTED
;
}
void
setArrow
(
)
{
setKind
(
Arrow
)
;
}
void
setResolvedLength
(
)
{
flags_
|
=
RESOLVED_LENGTH
;
}
void
setResolvedName
(
)
{
flags_
|
=
RESOLVED_NAME
;
}
void
setAsyncKind
(
js
:
:
FunctionAsyncKind
asyncKind
)
{
if
(
isInterpretedLazy
(
)
)
lazyScript
(
)
-
>
setAsyncKind
(
asyncKind
)
;
else
nonLazyScript
(
)
-
>
setAsyncKind
(
asyncKind
)
;
}
static
bool
getUnresolvedLength
(
JSContext
*
cx
js
:
:
HandleFunction
fun
js
:
:
MutableHandleValue
v
)
;
static
bool
getUnresolvedName
(
JSContext
*
cx
js
:
:
HandleFunction
fun
js
:
:
MutableHandleAtom
v
)
;
JSAtom
*
explicitName
(
)
const
{
return
(
hasCompileTimeName
(
)
|
|
hasGuessedAtom
(
)
)
?
nullptr
:
atom_
.
get
(
)
;
}
JSAtom
*
explicitOrCompileTimeName
(
)
const
{
return
hasGuessedAtom
(
)
?
nullptr
:
atom_
.
get
(
)
;
}
void
initAtom
(
JSAtom
*
atom
)
{
MOZ_ASSERT_IF
(
atom
js
:
:
AtomIsMarked
(
zone
(
)
atom
)
)
;
atom_
.
init
(
atom
)
;
}
void
setAtom
(
JSAtom
*
atom
)
{
MOZ_ASSERT_IF
(
atom
js
:
:
AtomIsMarked
(
zone
(
)
atom
)
)
;
atom_
=
atom
;
}
JSAtom
*
displayAtom
(
)
const
{
return
atom_
;
}
void
setCompileTimeName
(
JSAtom
*
atom
)
{
MOZ_ASSERT
(
!
atom_
)
;
MOZ_ASSERT
(
atom
)
;
MOZ_ASSERT
(
!
hasGuessedAtom
(
)
)
;
MOZ_ASSERT
(
!
isClassConstructor
(
)
)
;
MOZ_ASSERT
(
js
:
:
AtomIsMarked
(
zone
(
)
atom
)
)
;
atom_
=
atom
;
flags_
|
=
HAS_COMPILE_TIME_NAME
;
}
JSAtom
*
compileTimeName
(
)
const
{
MOZ_ASSERT
(
hasCompileTimeName
(
)
)
;
MOZ_ASSERT
(
atom_
)
;
return
atom_
;
}
void
setGuessedAtom
(
JSAtom
*
atom
)
{
MOZ_ASSERT
(
!
atom_
)
;
MOZ_ASSERT
(
atom
)
;
MOZ_ASSERT
(
!
hasCompileTimeName
(
)
)
;
MOZ_ASSERT
(
!
hasGuessedAtom
(
)
)
;
MOZ_ASSERT
(
!
isBoundFunction
(
)
)
;
MOZ_ASSERT
(
js
:
:
AtomIsMarked
(
zone
(
)
atom
)
)
;
atom_
=
atom
;
flags_
|
=
HAS_GUESSED_ATOM
;
}
void
clearGuessedAtom
(
)
{
MOZ_ASSERT
(
hasGuessedAtom
(
)
)
;
MOZ_ASSERT
(
!
isBoundFunction
(
)
)
;
MOZ_ASSERT
(
atom_
)
;
atom_
=
nullptr
;
flags_
&
=
~
HAS_GUESSED_ATOM
;
}
void
setPrefixedBoundFunctionName
(
JSAtom
*
atom
)
{
MOZ_ASSERT
(
!
hasBoundFunctionNamePrefix
(
)
)
;
MOZ_ASSERT
(
atom
)
;
flags_
|
=
HAS_BOUND_FUNCTION_NAME_PREFIX
;
atom_
=
atom
;
}
enum
{
MAX_ARGS_AND_VARS
=
2
*
(
(
1U
<
<
16
)
-
1
)
}
;
JSObject
*
environment
(
)
const
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
return
u
.
i
.
env_
;
}
void
setEnvironment
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
*
reinterpret_cast
<
js
:
:
GCPtrObject
*
>
(
&
u
.
i
.
env_
)
=
obj
;
}
void
initEnvironment
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
reinterpret_cast
<
js
:
:
GCPtrObject
*
>
(
&
u
.
i
.
env_
)
-
>
init
(
obj
)
;
}
void
unsetEnvironment
(
)
{
setEnvironment
(
nullptr
)
;
}
public
:
static
inline
size_t
offsetOfNargs
(
)
{
return
offsetof
(
JSFunction
nargs_
)
;
}
static
inline
size_t
offsetOfFlags
(
)
{
return
offsetof
(
JSFunction
flags_
)
;
}
static
inline
size_t
offsetOfEnvironment
(
)
{
return
offsetof
(
JSFunction
u
.
i
.
env_
)
;
}
static
inline
size_t
offsetOfAtom
(
)
{
return
offsetof
(
JSFunction
atom_
)
;
}
static
bool
createScriptForLazilyInterpretedFunction
(
JSContext
*
cx
js
:
:
HandleFunction
fun
)
;
void
maybeRelazify
(
JSRuntime
*
rt
)
;
static
JSScript
*
getOrCreateScript
(
JSContext
*
cx
js
:
:
HandleFunction
fun
)
{
MOZ_ASSERT
(
fun
-
>
isInterpreted
(
)
)
;
MOZ_ASSERT
(
cx
)
;
if
(
fun
-
>
isInterpretedLazy
(
)
)
{
if
(
!
createScriptForLazilyInterpretedFunction
(
cx
fun
)
)
return
nullptr
;
return
fun
-
>
nonLazyScript
(
)
;
}
return
fun
-
>
nonLazyScript
(
)
;
}
JSScript
*
existingScriptNonDelazifying
(
)
const
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
if
(
isInterpretedLazy
(
)
)
{
js
:
:
LazyScript
*
lazy
=
lazyScript
(
)
;
JSFunction
*
fun
=
lazy
-
>
functionNonDelazifying
(
)
;
MOZ_ASSERT
(
fun
)
;
return
fun
-
>
nonLazyScript
(
)
;
}
return
nonLazyScript
(
)
;
}
JSScript
*
existingScript
(
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
if
(
isInterpretedLazy
(
)
)
{
if
(
shadowZone
(
)
-
>
needsIncrementalBarrier
(
)
)
js
:
:
LazyScript
:
:
writeBarrierPre
(
lazyScript
(
)
)
;
JSScript
*
script
=
existingScriptNonDelazifying
(
)
;
flags_
&
=
~
INTERPRETED_LAZY
;
flags_
|
=
INTERPRETED
;
initScript
(
script
)
;
}
return
nonLazyScript
(
)
;
}
bool
hasUncompiledScript
(
)
const
{
MOZ_ASSERT
(
hasScript
(
)
)
;
return
!
u
.
i
.
s
.
script_
;
}
JSScript
*
nonLazyScript
(
)
const
{
MOZ_ASSERT
(
!
hasUncompiledScript
(
)
)
;
return
u
.
i
.
s
.
script_
;
}
static
bool
getLength
(
JSContext
*
cx
js
:
:
HandleFunction
fun
uint16_t
*
length
)
;
js
:
:
LazyScript
*
lazyScript
(
)
const
{
MOZ_ASSERT
(
isInterpretedLazy
(
)
&
&
u
.
i
.
s
.
lazy_
)
;
return
u
.
i
.
s
.
lazy_
;
}
js
:
:
LazyScript
*
lazyScriptOrNull
(
)
const
{
MOZ_ASSERT
(
isInterpretedLazy
(
)
)
;
return
u
.
i
.
s
.
lazy_
;
}
js
:
:
GeneratorKind
generatorKind
(
)
const
{
if
(
!
isInterpreted
(
)
)
return
js
:
:
NotGenerator
;
if
(
hasScript
(
)
)
return
nonLazyScript
(
)
-
>
generatorKind
(
)
;
if
(
js
:
:
LazyScript
*
lazy
=
lazyScriptOrNull
(
)
)
return
lazy
-
>
generatorKind
(
)
;
MOZ_ASSERT
(
isSelfHostedBuiltin
(
)
)
;
return
js
:
:
NotGenerator
;
}
bool
isLegacyGenerator
(
)
const
{
return
generatorKind
(
)
=
=
js
:
:
LegacyGenerator
;
}
bool
isStarGenerator
(
)
const
{
return
generatorKind
(
)
=
=
js
:
:
StarGenerator
;
}
js
:
:
FunctionAsyncKind
asyncKind
(
)
const
{
return
isInterpretedLazy
(
)
?
lazyScript
(
)
-
>
asyncKind
(
)
:
nonLazyScript
(
)
-
>
asyncKind
(
)
;
}
bool
isAsync
(
)
const
{
if
(
isInterpretedLazy
(
)
)
return
lazyScript
(
)
-
>
isAsync
(
)
;
if
(
hasScript
(
)
)
return
nonLazyScript
(
)
-
>
isAsync
(
)
;
return
false
;
}
void
setScript
(
JSScript
*
script_
)
{
mutableScript
(
)
=
script_
;
}
void
initScript
(
JSScript
*
script_
)
{
mutableScript
(
)
.
init
(
script_
)
;
}
void
setUnlazifiedScript
(
JSScript
*
script
)
{
MOZ_ASSERT
(
isInterpretedLazy
(
)
)
;
if
(
lazyScriptOrNull
(
)
)
{
js
:
:
LazyScript
:
:
writeBarrierPre
(
lazyScriptOrNull
(
)
)
;
if
(
!
lazyScript
(
)
-
>
maybeScript
(
)
)
lazyScript
(
)
-
>
initScript
(
script
)
;
}
flags_
&
=
~
INTERPRETED_LAZY
;
flags_
|
=
INTERPRETED
;
initScript
(
script
)
;
}
void
initLazyScript
(
js
:
:
LazyScript
*
lazy
)
{
MOZ_ASSERT
(
isInterpreted
(
)
)
;
flags_
&
=
~
INTERPRETED
;
flags_
|
=
INTERPRETED_LAZY
;
u
.
i
.
s
.
lazy_
=
lazy
;
}
JSNative
native
(
)
const
{
MOZ_ASSERT
(
isNative
(
)
)
;
return
u
.
n
.
native
;
}
JSNative
maybeNative
(
)
const
{
return
isInterpreted
(
)
?
nullptr
:
native
(
)
;
}
void
initNative
(
js
:
:
Native
native
const
JSJitInfo
*
jitinfo
)
{
MOZ_ASSERT
(
native
)
;
u
.
n
.
native
=
native
;
u
.
n
.
jitinfo
=
jitinfo
;
}
const
JSJitInfo
*
jitInfo
(
)
const
{
MOZ_ASSERT
(
isNative
(
)
)
;
return
u
.
n
.
jitinfo
;
}
void
setJitInfo
(
const
JSJitInfo
*
data
)
{
MOZ_ASSERT
(
isNative
(
)
)
;
u
.
n
.
jitinfo
=
data
;
}
bool
isDerivedClassConstructor
(
)
;
static
unsigned
offsetOfNativeOrScript
(
)
{
static_assert
(
offsetof
(
U
n
.
native
)
=
=
offsetof
(
U
i
.
s
.
script_
)
"
native
and
script
pointers
must
be
in
the
same
spot
"
"
for
offsetOfNativeOrScript
(
)
have
any
sense
"
)
;
static_assert
(
offsetof
(
U
n
.
native
)
=
=
offsetof
(
U
nativeOrScript
)
"
U
:
:
nativeOrScript
must
be
at
the
same
offset
as
"
"
native
"
)
;
return
offsetof
(
JSFunction
u
.
nativeOrScript
)
;
}
static
unsigned
offsetOfJitInfo
(
)
{
return
offsetof
(
JSFunction
u
.
n
.
jitinfo
)
;
}
inline
void
trace
(
JSTracer
*
trc
)
;
JSObject
*
getBoundFunctionTarget
(
)
const
;
const
js
:
:
Value
&
getBoundFunctionThis
(
)
const
;
const
js
:
:
Value
&
getBoundFunctionArgument
(
unsigned
which
)
const
;
size_t
getBoundFunctionArgumentCount
(
)
const
;
static
bool
finishBoundFunctionInit
(
JSContext
*
cx
js
:
:
HandleFunction
bound
js
:
:
HandleObject
targetObj
int32_t
argCount
)
;
private
:
js
:
:
GCPtrScript
&
mutableScript
(
)
{
MOZ_ASSERT
(
hasScript
(
)
)
;
return
*
(
js
:
:
GCPtrScript
*
)
&
u
.
i
.
s
.
script_
;
}
inline
js
:
:
FunctionExtended
*
toExtended
(
)
;
inline
const
js
:
:
FunctionExtended
*
toExtended
(
)
const
;
public
:
inline
bool
isExtended
(
)
const
{
bool
extended
=
!
!
(
flags
(
)
&
EXTENDED
)
;
MOZ_ASSERT_IF
(
isTenured
(
)
extended
=
=
(
asTenured
(
)
.
getAllocKind
(
)
=
=
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
)
)
;
return
extended
;
}
inline
void
initializeExtended
(
)
;
inline
void
initExtendedSlot
(
size_t
which
const
js
:
:
Value
&
val
)
;
inline
void
setExtendedSlot
(
size_t
which
const
js
:
:
Value
&
val
)
;
inline
const
js
:
:
Value
&
getExtendedSlot
(
size_t
which
)
const
;
static
bool
setTypeForScriptedFunction
(
JSContext
*
cx
js
:
:
HandleFunction
fun
bool
singleton
=
false
)
;
js
:
:
gc
:
:
AllocKind
getAllocKind
(
)
const
{
static_assert
(
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION
!
=
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
"
extended
/
non
-
extended
AllocKinds
have
to
be
different
"
"
for
getAllocKind
(
)
to
have
a
reason
to
exist
"
)
;
js
:
:
gc
:
:
AllocKind
kind
=
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION
;
if
(
isExtended
(
)
)
kind
=
js
:
:
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
;
MOZ_ASSERT_IF
(
isTenured
(
)
kind
=
=
asTenured
(
)
.
getAllocKind
(
)
)
;
return
kind
;
}
}
;
static_assert
(
sizeof
(
JSFunction
)
=
=
sizeof
(
js
:
:
shadow
:
:
Function
)
"
shadow
interface
must
match
actual
interface
"
)
;
extern
JSString
*
fun_toStringHelper
(
JSContext
*
cx
js
:
:
HandleObject
obj
bool
isToSource
)
;
namespace
js
{
extern
bool
Function
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
Generator
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
AsyncFunctionConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
AsyncGeneratorConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
JSFunction
*
NewNativeFunction
(
JSContext
*
cx
JSNative
native
unsigned
nargs
HandleAtom
atom
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
NewObjectKind
newKind
=
SingletonObject
)
;
extern
JSFunction
*
NewNativeConstructor
(
JSContext
*
cx
JSNative
native
unsigned
nargs
HandleAtom
atom
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
NewObjectKind
newKind
=
SingletonObject
JSFunction
:
:
Flags
flags
=
JSFunction
:
:
NATIVE_CTOR
)
;
extern
JSFunction
*
NewScriptedFunction
(
JSContext
*
cx
unsigned
nargs
JSFunction
:
:
Flags
flags
HandleAtom
atom
HandleObject
proto
=
nullptr
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
NewObjectKind
newKind
=
GenericObject
HandleObject
enclosingEnv
=
nullptr
)
;
enum
NewFunctionProtoHandling
{
NewFunctionClassProto
NewFunctionGivenProto
}
;
extern
JSFunction
*
NewFunctionWithProto
(
JSContext
*
cx
JSNative
native
unsigned
nargs
JSFunction
:
:
Flags
flags
HandleObject
enclosingEnv
HandleAtom
atom
HandleObject
proto
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
NewObjectKind
newKind
=
GenericObject
NewFunctionProtoHandling
protoHandling
=
NewFunctionClassProto
)
;
extern
JSAtom
*
IdToFunctionName
(
JSContext
*
cx
HandleId
id
FunctionPrefixKind
prefixKind
=
FunctionPrefixKind
:
:
None
)
;
extern
JSAtom
*
NameToFunctionName
(
JSContext
*
cx
HandleAtom
name
FunctionPrefixKind
prefixKind
=
FunctionPrefixKind
:
:
None
)
;
extern
bool
SetFunctionNameIfNoOwnName
(
JSContext
*
cx
HandleFunction
fun
HandleValue
name
FunctionPrefixKind
prefixKind
)
;
extern
JSFunction
*
DefineFunction
(
JSContext
*
cx
HandleObject
obj
HandleId
id
JSNative
native
unsigned
nargs
unsigned
flags
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
)
;
bool
FunctionHasResolveHook
(
const
JSAtomState
&
atomState
jsid
id
)
;
extern
bool
fun_toString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
struct
WellKnownSymbols
;
extern
bool
FunctionHasDefaultHasInstance
(
JSFunction
*
fun
const
WellKnownSymbols
&
symbols
)
;
extern
bool
fun_symbolHasInstance
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
class
FunctionExtended
:
public
JSFunction
{
public
:
static
const
unsigned
NUM_EXTENDED_SLOTS
=
2
;
static
const
unsigned
ARROW_NEWTARGET_SLOT
=
0
;
static
const
unsigned
METHOD_HOMEOBJECT_SLOT
=
0
;
static
const
unsigned
WASM_INSTANCE_SLOT
=
0
;
static
const
unsigned
WASM_FUNC_INDEX_SLOT
=
1
;
static
const
unsigned
ASMJS_MODULE_SLOT
=
0
;
static
inline
size_t
offsetOfExtendedSlot
(
unsigned
which
)
{
MOZ_ASSERT
(
which
<
NUM_EXTENDED_SLOTS
)
;
return
offsetof
(
FunctionExtended
extendedSlots
)
+
which
*
sizeof
(
GCPtrValue
)
;
}
static
inline
size_t
offsetOfArrowNewTargetSlot
(
)
{
return
offsetOfExtendedSlot
(
ARROW_NEWTARGET_SLOT
)
;
}
static
inline
size_t
offsetOfMethodHomeObjectSlot
(
)
{
return
offsetOfExtendedSlot
(
METHOD_HOMEOBJECT_SLOT
)
;
}
private
:
friend
class
JSFunction
;
GCPtrValue
extendedSlots
[
NUM_EXTENDED_SLOTS
]
;
}
;
extern
bool
CanReuseScriptForClone
(
JSCompartment
*
compartment
HandleFunction
fun
HandleObject
newParent
)
;
extern
JSFunction
*
CloneFunctionReuseScript
(
JSContext
*
cx
HandleFunction
fun
HandleObject
parent
gc
:
:
AllocKind
kind
=
gc
:
:
AllocKind
:
:
FUNCTION
NewObjectKind
newKindArg
=
GenericObject
HandleObject
proto
=
nullptr
)
;
extern
JSFunction
*
CloneFunctionAndScript
(
JSContext
*
cx
HandleFunction
fun
HandleObject
parent
HandleScope
newScope
gc
:
:
AllocKind
kind
=
gc
:
:
AllocKind
:
:
FUNCTION
HandleObject
proto
=
nullptr
)
;
}
inline
js
:
:
FunctionExtended
*
JSFunction
:
:
toExtended
(
)
{
MOZ_ASSERT
(
isExtended
(
)
)
;
return
static_cast
<
js
:
:
FunctionExtended
*
>
(
this
)
;
}
inline
const
js
:
:
FunctionExtended
*
JSFunction
:
:
toExtended
(
)
const
{
MOZ_ASSERT
(
isExtended
(
)
)
;
return
static_cast
<
const
js
:
:
FunctionExtended
*
>
(
this
)
;
}
inline
void
JSFunction
:
:
initializeExtended
(
)
{
MOZ_ASSERT
(
isExtended
(
)
)
;
MOZ_ASSERT
(
mozilla
:
:
ArrayLength
(
toExtended
(
)
-
>
extendedSlots
)
=
=
2
)
;
toExtended
(
)
-
>
extendedSlots
[
0
]
.
init
(
js
:
:
UndefinedValue
(
)
)
;
toExtended
(
)
-
>
extendedSlots
[
1
]
.
init
(
js
:
:
UndefinedValue
(
)
)
;
}
inline
void
JSFunction
:
:
initExtendedSlot
(
size_t
which
const
js
:
:
Value
&
val
)
{
MOZ_ASSERT
(
which
<
mozilla
:
:
ArrayLength
(
toExtended
(
)
-
>
extendedSlots
)
)
;
js
:
:
CheckEdgeIsNotBlackToGray
(
this
val
)
;
MOZ_ASSERT
(
js
:
:
IsObjectValueInCompartment
(
val
compartment
(
)
)
)
;
toExtended
(
)
-
>
extendedSlots
[
which
]
.
init
(
val
)
;
}
inline
void
JSFunction
:
:
setExtendedSlot
(
size_t
which
const
js
:
:
Value
&
val
)
{
MOZ_ASSERT
(
which
<
mozilla
:
:
ArrayLength
(
toExtended
(
)
-
>
extendedSlots
)
)
;
js
:
:
CheckEdgeIsNotBlackToGray
(
this
val
)
;
MOZ_ASSERT
(
js
:
:
IsObjectValueInCompartment
(
val
compartment
(
)
)
)
;
toExtended
(
)
-
>
extendedSlots
[
which
]
=
val
;
}
inline
const
js
:
:
Value
&
JSFunction
:
:
getExtendedSlot
(
size_t
which
)
const
{
MOZ_ASSERT
(
which
<
mozilla
:
:
ArrayLength
(
toExtended
(
)
-
>
extendedSlots
)
)
;
return
toExtended
(
)
-
>
extendedSlots
[
which
]
;
}
namespace
js
{
JSString
*
FunctionToString
(
JSContext
*
cx
HandleFunction
fun
bool
isToSource
)
;
template
<
XDRMode
mode
>
bool
XDRInterpretedFunction
(
XDRState
<
mode
>
*
xdr
HandleScope
enclosingScope
HandleScriptSource
sourceObject
MutableHandleFunction
objp
)
;
extern
void
ReportIncompatibleMethod
(
JSContext
*
cx
const
CallArgs
&
args
const
Class
*
clasp
)
;
extern
void
ReportIncompatible
(
JSContext
*
cx
const
CallArgs
&
args
)
;
extern
const
JSFunctionSpec
function_methods
[
]
;
extern
const
JSFunctionSpec
function_selfhosted_methods
[
]
;
extern
bool
fun_apply
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
extern
bool
fun_call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
}
#
ifdef
DEBUG
namespace
JS
{
namespace
detail
{
JS_PUBLIC_API
(
void
)
CheckIsValidConstructible
(
const
Value
&
calleev
)
;
}
}
#
endif
#
endif
