#
ifndef
ds_SinglyLinkedList_h
#
define
ds_SinglyLinkedList_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
utility
>
namespace
js
{
template
<
typename
T
>
class
SinglyLinkedList
{
T
*
last_
=
nullptr
;
public
:
SinglyLinkedList
(
)
{
static_assert
(
std
:
:
is_same_v
<
decltype
(
T
:
:
next
)
T
*
>
"
SinglyLinkedList
requires
T
has
a
next
field
of
type
T
*
"
)
;
MOZ_ASSERT
(
isEmpty
(
)
)
;
}
SinglyLinkedList
(
T
*
first
T
*
last
)
:
last_
(
last
)
{
MOZ_ASSERT
(
!
last_
-
>
next
)
;
last_
-
>
next
=
first
;
}
SinglyLinkedList
(
const
SinglyLinkedList
&
other
)
=
delete
;
SinglyLinkedList
&
operator
=
(
const
SinglyLinkedList
&
other
)
=
delete
;
SinglyLinkedList
(
SinglyLinkedList
&
&
other
)
{
std
:
:
swap
(
last_
other
.
last_
)
;
MOZ_ASSERT
(
other
.
isEmpty
(
)
)
;
}
SinglyLinkedList
&
operator
=
(
SinglyLinkedList
&
&
other
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
return
*
new
(
this
)
SinglyLinkedList
(
std
:
:
move
(
other
)
)
;
}
~
SinglyLinkedList
(
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
}
bool
isEmpty
(
)
const
{
return
!
last_
;
}
T
*
first
(
)
const
{
if
(
isEmpty
(
)
)
{
return
nullptr
;
}
T
*
element
=
last_
-
>
next
;
MOZ_ASSERT
(
element
)
;
return
element
;
}
T
*
last
(
)
const
{
return
last_
;
}
T
*
popFront
(
)
{
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
T
*
element
=
last_
-
>
next
;
if
(
element
=
=
last_
)
{
last_
=
nullptr
;
}
else
{
last_
-
>
next
=
element
-
>
next
;
}
element
-
>
next
=
nullptr
;
return
element
;
}
void
pushFront
(
T
*
element
)
{
MOZ_ASSERT
(
!
element
-
>
next
)
;
if
(
isEmpty
(
)
)
{
element
-
>
next
=
element
;
last_
=
element
;
return
;
}
element
-
>
next
=
last_
-
>
next
;
last_
-
>
next
=
element
;
}
void
pushBack
(
T
*
element
)
{
pushFront
(
element
)
;
moveFrontToBack
(
)
;
}
void
moveFrontToBack
(
)
{
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
last_
=
last_
-
>
next
;
}
void
append
(
SinglyLinkedList
&
&
other
)
{
if
(
other
.
isEmpty
(
)
)
{
return
;
}
if
(
isEmpty
(
)
)
{
new
(
this
)
SinglyLinkedList
(
std
:
:
move
(
other
)
)
;
return
;
}
T
*
firstElement
=
first
(
)
;
last
(
)
-
>
next
=
other
.
first
(
)
;
other
.
last
(
)
-
>
next
=
firstElement
;
last_
=
other
.
last
(
)
;
other
.
last_
=
nullptr
;
}
class
Iterator
{
T
*
i
=
nullptr
;
T
*
last
=
nullptr
;
public
:
explicit
Iterator
(
const
SinglyLinkedList
&
list
)
:
i
(
list
.
first
(
)
)
last
(
list
.
last
(
)
)
{
}
bool
done
(
)
const
{
return
!
i
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
i
=
i
=
=
last
?
nullptr
:
i
-
>
next
;
}
T
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
i
;
}
T
&
operator
*
(
)
const
{
return
*
get
(
)
;
}
T
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
Iterator
iter
(
)
const
{
return
Iterator
(
*
this
)
;
}
T
*
release
(
)
{
if
(
isEmpty
(
)
)
{
return
nullptr
;
}
T
*
list
=
first
(
)
;
MOZ_ASSERT
(
last_
-
>
next
)
;
last_
-
>
next
=
nullptr
;
last_
=
nullptr
;
return
list
;
}
}
;
}
#
endif
