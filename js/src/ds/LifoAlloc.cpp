#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
ds
/
MemoryProtectionExceptionHandler
.
h
"
#
ifdef
LIFO_CHUNK_PROTECT
#
include
"
gc
/
Memory
.
h
"
#
endif
using
namespace
js
;
using
mozilla
:
:
RoundUpPow2
;
using
mozilla
:
:
tl
:
:
BitSize
;
namespace
js
{
namespace
detail
{
UniquePtr
<
BumpChunk
>
BumpChunk
:
:
newWithCapacity
(
size_t
size
bool
protect
)
{
MOZ_DIAGNOSTIC_ASSERT
(
RoundUpPow2
(
size
)
=
=
size
)
;
MOZ_DIAGNOSTIC_ASSERT
(
size
>
=
sizeof
(
BumpChunk
)
)
;
void
*
mem
=
js_malloc
(
size
)
;
if
(
!
mem
)
return
nullptr
;
UniquePtr
<
BumpChunk
>
result
(
new
(
mem
)
BumpChunk
(
size
protect
)
)
;
MOZ_ASSERT
(
AlignPtr
(
result
-
>
begin
(
)
)
=
=
result
-
>
begin
(
)
)
;
return
result
;
}
bool
BumpChunk
:
:
canAlloc
(
size_t
n
)
{
uint8_t
*
aligned
=
AlignPtr
(
bump_
)
;
uint8_t
*
newBump
=
aligned
+
n
;
return
bump_
<
=
newBump
&
&
newBump
<
=
capacity_
;
}
#
ifdef
LIFO_CHUNK_PROTECT
static
const
uint8_t
*
AlignPtrUp
(
const
uint8_t
*
ptr
uintptr_t
align
)
{
MOZ_ASSERT
(
mozilla
:
:
IsPowerOfTwo
(
align
)
)
;
uintptr_t
uptr
=
uintptr_t
(
ptr
)
;
uintptr_t
diff
=
uptr
&
(
align
-
1
)
;
diff
=
(
align
-
diff
)
&
(
align
-
1
)
;
uptr
=
uptr
+
diff
;
return
(
uint8_t
*
)
uptr
;
}
static
const
uint8_t
*
AlignPtrDown
(
const
uint8_t
*
ptr
uintptr_t
align
)
{
MOZ_ASSERT
(
mozilla
:
:
IsPowerOfTwo
(
align
)
)
;
uintptr_t
uptr
=
uintptr_t
(
ptr
)
;
uptr
=
uptr
&
~
(
align
-
1
)
;
return
(
uint8_t
*
)
uptr
;
}
void
BumpChunk
:
:
setRWUntil
(
Loc
loc
)
const
{
if
(
!
protect_
)
return
;
uintptr_t
pageSize
=
gc
:
:
SystemPageSize
(
)
;
const
uint8_t
*
b
=
base
(
)
;
const
uint8_t
*
e
=
capacity_
;
b
=
AlignPtrUp
(
b
pageSize
)
;
e
=
AlignPtrDown
(
e
pageSize
)
;
if
(
e
<
b
)
e
=
b
;
const
uint8_t
*
m
=
nullptr
;
switch
(
loc
)
{
case
Loc
:
:
Header
:
m
=
b
;
break
;
case
Loc
:
:
Allocated
:
m
=
begin
(
)
;
break
;
case
Loc
:
:
Reserved
:
m
=
end
(
)
;
break
;
case
Loc
:
:
End
:
m
=
e
;
break
;
}
m
=
AlignPtrUp
(
m
pageSize
)
;
if
(
e
<
m
)
m
=
e
;
if
(
b
<
m
)
gc
:
:
UnprotectPages
(
const_cast
<
uint8_t
*
>
(
b
)
m
-
b
)
;
if
(
m
<
e
)
gc
:
:
MakePagesReadOnly
(
const_cast
<
uint8_t
*
>
(
m
)
e
-
m
)
;
}
void
BumpChunk
:
:
addMProtectHandler
(
)
const
{
if
(
!
protect_
)
return
;
js
:
:
MemoryProtectionExceptionHandler
:
:
addRegion
(
const_cast
<
uint8_t
*
>
(
base
(
)
)
capacity_
-
base
(
)
)
;
}
void
BumpChunk
:
:
removeMProtectHandler
(
)
const
{
if
(
!
protect_
)
return
;
js
:
:
MemoryProtectionExceptionHandler
:
:
removeRegion
(
const_cast
<
uint8_t
*
>
(
base
(
)
)
)
;
}
#
endif
}
}
void
LifoAlloc
:
:
reset
(
size_t
defaultChunkSize
)
{
MOZ_ASSERT
(
mozilla
:
:
IsPowerOfTwo
(
defaultChunkSize
)
)
;
while
(
!
chunks_
.
empty
(
)
)
{
chunks_
.
begin
(
)
-
>
setRWUntil
(
Loc
:
:
End
)
;
chunks_
.
popFirst
(
)
;
}
while
(
!
unused_
.
empty
(
)
)
{
unused_
.
begin
(
)
-
>
setRWUntil
(
Loc
:
:
End
)
;
unused_
.
popFirst
(
)
;
}
defaultChunkSize_
=
defaultChunkSize
;
markCount
=
0
;
curSize_
=
0
;
}
void
LifoAlloc
:
:
freeAll
(
)
{
while
(
!
chunks_
.
empty
(
)
)
{
chunks_
.
begin
(
)
-
>
setRWUntil
(
Loc
:
:
End
)
;
UniqueBumpChunk
bc
=
chunks_
.
popFirst
(
)
;
decrementCurSize
(
bc
-
>
computedSizeOfIncludingThis
(
)
)
;
}
while
(
!
unused_
.
empty
(
)
)
{
unused_
.
begin
(
)
-
>
setRWUntil
(
Loc
:
:
End
)
;
UniqueBumpChunk
bc
=
unused_
.
popFirst
(
)
;
decrementCurSize
(
bc
-
>
computedSizeOfIncludingThis
(
)
)
;
}
MOZ_ASSERT
(
curSize_
=
=
0
)
;
}
LifoAlloc
:
:
UniqueBumpChunk
LifoAlloc
:
:
newChunkWithCapacity
(
size_t
n
)
{
MOZ_ASSERT
(
fallibleScope_
"
[
OOM
]
Cannot
allocate
a
new
chunk
in
an
infallible
scope
.
"
)
;
size_t
defaultChunkFreeSpace
=
defaultChunkSize_
-
detail
:
:
BumpChunkReservedSpace
;
size_t
chunkSize
;
if
(
n
>
defaultChunkFreeSpace
)
{
MOZ_ASSERT
(
defaultChunkFreeSpace
<
defaultChunkSize_
)
;
size_t
allocSizeWithCanaries
=
n
+
(
defaultChunkSize_
-
defaultChunkFreeSpace
)
;
if
(
allocSizeWithCanaries
<
n
|
|
(
allocSizeWithCanaries
&
(
size_t
(
1
)
<
<
(
BitSize
<
size_t
>
:
:
value
-
1
)
)
)
)
{
return
nullptr
;
}
chunkSize
=
RoundUpPow2
(
allocSizeWithCanaries
)
;
}
else
{
chunkSize
=
defaultChunkSize_
;
}
bool
protect
=
false
;
#
ifdef
LIFO_CHUNK_PROTECT
protect
=
protect_
;
const
size_t
MaxPeakSize
=
32
*
1024
*
1024
;
if
(
protect
&
&
MaxPeakSize
<
=
this
-
>
peakSize_
)
protect
=
false
;
#
endif
UniqueBumpChunk
result
=
detail
:
:
BumpChunk
:
:
newWithCapacity
(
chunkSize
protect
)
;
if
(
!
result
)
return
nullptr
;
MOZ_ASSERT
(
result
-
>
computedSizeOfIncludingThis
(
)
=
=
chunkSize
)
;
return
result
;
}
bool
LifoAlloc
:
:
getOrCreateChunk
(
size_t
n
)
{
auto
protectLast
=
[
&
]
(
)
{
if
(
!
chunks_
.
empty
(
)
)
chunks_
.
last
(
)
-
>
setRWUntil
(
Loc
:
:
Reserved
)
;
}
;
if
(
!
unused_
.
empty
(
)
)
{
if
(
unused_
.
begin
(
)
-
>
canAlloc
(
n
)
)
{
protectLast
(
)
;
chunks_
.
append
(
unused_
.
popFirst
(
)
)
;
chunks_
.
last
(
)
-
>
setRWUntil
(
Loc
:
:
End
)
;
return
true
;
}
BumpChunkList
:
:
Iterator
e
(
unused_
.
end
(
)
)
;
for
(
BumpChunkList
:
:
Iterator
i
(
unused_
.
begin
(
)
)
;
i
-
>
next
(
)
!
=
e
.
get
(
)
;
+
+
i
)
{
detail
:
:
BumpChunk
*
elem
=
i
-
>
next
(
)
;
MOZ_ASSERT
(
elem
-
>
empty
(
)
)
;
if
(
elem
-
>
canAlloc
(
n
)
)
{
BumpChunkList
temp
=
unused_
.
splitAfter
(
i
.
get
(
)
)
;
protectLast
(
)
;
chunks_
.
append
(
temp
.
popFirst
(
)
)
;
unused_
.
appendAll
(
std
:
:
move
(
temp
)
)
;
chunks_
.
last
(
)
-
>
setRWUntil
(
Loc
:
:
End
)
;
return
true
;
}
}
}
UniqueBumpChunk
newChunk
=
newChunkWithCapacity
(
n
)
;
if
(
!
newChunk
)
return
false
;
size_t
size
=
newChunk
-
>
computedSizeOfIncludingThis
(
)
;
protectLast
(
)
;
chunks_
.
append
(
std
:
:
move
(
newChunk
)
)
;
incrementCurSize
(
size
)
;
return
true
;
}
void
LifoAlloc
:
:
transferFrom
(
LifoAlloc
*
other
)
{
MOZ_ASSERT
(
!
markCount
)
;
MOZ_ASSERT
(
!
other
-
>
markCount
)
;
incrementCurSize
(
other
-
>
curSize_
)
;
appendUnused
(
std
:
:
move
(
other
-
>
unused_
)
)
;
appendUsed
(
std
:
:
move
(
other
-
>
chunks_
)
)
;
other
-
>
curSize_
=
0
;
}
void
LifoAlloc
:
:
transferUnusedFrom
(
LifoAlloc
*
other
)
{
MOZ_ASSERT
(
!
markCount
)
;
size_t
size
=
0
;
for
(
detail
:
:
BumpChunk
&
bc
:
other
-
>
unused_
)
size
+
=
bc
.
computedSizeOfIncludingThis
(
)
;
appendUnused
(
std
:
:
move
(
other
-
>
unused_
)
)
;
incrementCurSize
(
size
)
;
other
-
>
decrementCurSize
(
size
)
;
}
