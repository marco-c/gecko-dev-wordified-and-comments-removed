#
ifndef
ds_FixedLengthVector_h
#
define
ds_FixedLengthVector_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
<
stddef
.
h
>
#
include
"
js
/
Utility
.
h
"
#
include
"
vm
/
JSContext
.
h
"
namespace
js
{
template
<
typename
T
>
class
FixedLengthVector
{
T
*
data_
=
nullptr
;
size_t
length_
=
0
;
public
:
FixedLengthVector
(
)
{
}
FixedLengthVector
(
FixedLengthVector
&
)
=
delete
;
FixedLengthVector
(
FixedLengthVector
&
&
)
=
default
;
~
FixedLengthVector
(
)
{
if
(
initialized
(
)
)
{
js_free
(
data_
)
;
}
}
size_t
length
(
)
const
{
return
length_
;
}
bool
initialized
(
)
const
{
return
!
!
data_
;
}
MOZ_MUST_USE
bool
allocateUninitialized
(
JSContext
*
cx
size_t
length
)
{
MOZ_ASSERT
(
!
initialized
(
)
)
;
length_
=
length
;
data_
=
cx
-
>
pod_malloc
<
T
>
(
length
)
;
if
(
MOZ_UNLIKELY
(
!
data_
)
)
{
return
false
;
}
return
true
;
}
MOZ_MUST_USE
bool
allocate
(
JSContext
*
cx
size_t
length
)
{
if
(
!
allocateUninitialized
(
cx
length
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
new
(
mozilla
:
:
KnownNotNull
&
data_
[
i
]
)
T
(
)
;
}
return
true
;
}
T
*
begin
(
)
{
MOZ_ASSERT
(
initialized
(
)
)
;
return
data_
;
}
const
T
*
begin
(
)
const
{
MOZ_ASSERT
(
initialized
(
)
)
;
return
data_
;
}
T
*
end
(
)
{
MOZ_ASSERT
(
initialized
(
)
)
;
return
data_
+
length_
;
}
const
T
*
end
(
)
const
{
MOZ_ASSERT
(
initialized
(
)
)
;
return
data_
+
length_
;
}
T
&
operator
[
]
(
size_t
index
)
{
MOZ_ASSERT
(
initialized
(
)
)
;
MOZ_ASSERT
(
index
<
length_
)
;
return
begin
(
)
[
index
]
;
}
const
T
&
operator
[
]
(
size_t
index
)
const
{
MOZ_ASSERT
(
initialized
(
)
)
;
MOZ_ASSERT
(
index
<
length_
)
;
return
begin
(
)
[
index
]
;
}
}
;
}
#
endif
