#
ifndef
js_Fifo_h
#
define
js_Fifo_h
#
include
"
mozilla
/
Move
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
namespace
js
{
template
<
typename
T
size_t
MinInlineCapacity
=
0
class
AllocPolicy
=
TempAllocPolicy
>
class
Fifo
{
static_assert
(
MinInlineCapacity
%
2
=
=
0
"
MinInlineCapacity
must
be
even
!
"
)
;
protected
:
Vector
<
T
MinInlineCapacity
/
2
AllocPolicy
>
front_
;
Vector
<
T
MinInlineCapacity
/
2
AllocPolicy
>
rear_
;
private
:
bool
fixup
(
)
{
if
(
!
front_
.
empty
(
)
)
return
true
;
if
(
!
front_
.
reserve
(
rear_
.
length
(
)
)
)
return
false
;
while
(
!
rear_
.
empty
(
)
)
{
front_
.
infallibleAppend
(
mozilla
:
:
Move
(
rear_
.
back
(
)
)
)
;
rear_
.
popBack
(
)
;
}
return
true
;
}
public
:
explicit
Fifo
(
AllocPolicy
alloc
=
AllocPolicy
(
)
)
:
front_
(
alloc
)
rear_
(
alloc
)
{
}
Fifo
(
Fifo
&
&
rhs
)
:
front_
(
mozilla
:
:
Move
(
rhs
.
front_
)
)
rear_
(
mozilla
:
:
Move
(
rhs
.
rear_
)
)
{
}
Fifo
&
operator
=
(
Fifo
&
&
rhs
)
{
MOZ_ASSERT
(
&
rhs
!
=
this
"
self
-
move
disallowed
"
)
;
this
-
>
~
Fifo
(
)
;
new
(
this
)
Fifo
(
mozilla
:
:
Move
(
rhs
)
)
;
return
*
this
;
}
Fifo
(
const
Fifo
&
)
=
delete
;
Fifo
&
operator
=
(
const
Fifo
&
)
=
delete
;
size_t
length
(
)
const
{
MOZ_ASSERT_IF
(
rear_
.
length
(
)
>
0
front_
.
length
(
)
>
0
)
;
return
front_
.
length
(
)
+
rear_
.
length
(
)
;
}
bool
empty
(
)
const
{
MOZ_ASSERT_IF
(
rear_
.
length
(
)
>
0
front_
.
length
(
)
>
0
)
;
return
front_
.
empty
(
)
;
}
template
<
typename
U
>
MOZ_MUST_USE
bool
pushBack
(
U
&
&
u
)
{
if
(
!
rear_
.
append
(
mozilla
:
:
Forward
<
U
>
(
u
)
)
)
return
false
;
if
(
!
fixup
(
)
)
{
rear_
.
popBack
(
)
;
return
false
;
}
return
true
;
}
template
<
typename
.
.
.
Args
>
MOZ_MUST_USE
bool
emplaceBack
(
Args
&
&
.
.
.
args
)
{
if
(
!
rear_
.
emplaceBack
(
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
)
return
false
;
if
(
!
fixup
(
)
)
{
rear_
.
popBack
(
)
;
return
false
;
}
return
true
;
}
T
&
front
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
return
front_
.
back
(
)
;
}
const
T
&
front
(
)
const
{
MOZ_ASSERT
(
!
empty
(
)
)
;
return
front_
.
back
(
)
;
}
MOZ_MUST_USE
bool
popFront
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
T
t
(
mozilla
:
:
Move
(
front
(
)
)
)
;
front_
.
popBack
(
)
;
if
(
!
fixup
(
)
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
front_
.
append
(
mozilla
:
:
Move
(
t
)
)
)
oomUnsafe
.
crash
(
"
js
:
:
Fifo
:
:
popFront
"
)
;
return
false
;
}
return
true
;
}
void
clear
(
)
{
front_
.
clear
(
)
;
rear_
.
clear
(
)
;
}
}
;
}
#
endif
