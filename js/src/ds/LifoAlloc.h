#
ifndef
ds_LifoAlloc_h
#
define
ds_LifoAlloc_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
<
new
>
#
include
"
jsutil
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
namespace
js
{
namespace
detail
{
template
<
typename
T
typename
D
>
class
SingleLinkedList
;
template
<
typename
T
typename
D
=
JS
:
:
DeletePolicy
<
T
>
>
class
SingleLinkedListElement
{
friend
class
SingleLinkedList
<
T
D
>
;
js
:
:
UniquePtr
<
T
D
>
next_
;
public
:
SingleLinkedListElement
(
)
:
next_
(
nullptr
)
{
}
~
SingleLinkedListElement
(
)
{
MOZ_ASSERT
(
!
next_
)
;
}
T
*
next
(
)
const
{
return
next_
.
get
(
)
;
}
}
;
template
<
typename
T
typename
D
=
JS
:
:
DeletePolicy
<
T
>
>
class
SingleLinkedList
{
private
:
UniquePtr
<
T
D
>
head_
;
T
*
last_
;
void
assertInvariants
(
)
{
MOZ_ASSERT
(
bool
(
head_
)
=
=
bool
(
last_
)
)
;
MOZ_ASSERT_IF
(
last_
!
last_
-
>
next_
)
;
}
public
:
SingleLinkedList
(
)
:
head_
(
nullptr
)
last_
(
nullptr
)
{
assertInvariants
(
)
;
}
SingleLinkedList
(
SingleLinkedList
&
&
other
)
:
head_
(
std
:
:
move
(
other
.
head_
)
)
last_
(
other
.
last_
)
{
other
.
last_
=
nullptr
;
assertInvariants
(
)
;
other
.
assertInvariants
(
)
;
}
~
SingleLinkedList
(
)
{
MOZ_ASSERT
(
!
head_
)
;
MOZ_ASSERT
(
!
last_
)
;
}
SingleLinkedList
&
operator
=
(
SingleLinkedList
&
&
other
)
{
head_
=
std
:
:
move
(
other
.
head_
)
;
last_
=
other
.
last_
;
other
.
last_
=
nullptr
;
assertInvariants
(
)
;
other
.
assertInvariants
(
)
;
return
*
this
;
}
bool
empty
(
)
const
{
return
!
last_
;
}
class
Iterator
{
T
*
current_
;
public
:
explicit
Iterator
(
T
*
current
)
:
current_
(
current
)
{
}
T
&
operator
*
(
)
const
{
return
*
current_
;
}
T
*
operator
-
>
(
)
const
{
return
current_
;
}
T
*
get
(
)
const
{
return
current_
;
}
const
Iterator
&
operator
+
+
(
)
{
current_
=
current_
-
>
next
(
)
;
return
*
this
;
}
bool
operator
!
=
(
const
Iterator
&
other
)
const
{
return
current_
!
=
other
.
current_
;
}
bool
operator
=
=
(
const
Iterator
&
other
)
const
{
return
current_
=
=
other
.
current_
;
}
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
head_
.
get
(
)
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
nullptr
)
;
}
Iterator
last
(
)
const
{
return
Iterator
(
last_
)
;
}
SingleLinkedList
splitAfter
(
T
*
newLast
)
{
MOZ_ASSERT
(
newLast
)
;
SingleLinkedList
result
;
if
(
newLast
-
>
next_
)
{
result
.
head_
=
std
:
:
move
(
newLast
-
>
next_
)
;
result
.
last_
=
last_
;
last_
=
newLast
;
}
assertInvariants
(
)
;
result
.
assertInvariants
(
)
;
return
result
;
}
void
pushFront
(
UniquePtr
<
T
D
>
&
&
elem
)
{
if
(
!
last_
)
last_
=
elem
.
get
(
)
;
elem
-
>
next_
=
std
:
:
move
(
head_
)
;
head_
=
std
:
:
move
(
elem
)
;
assertInvariants
(
)
;
}
void
append
(
UniquePtr
<
T
D
>
&
&
elem
)
{
if
(
last_
)
{
last_
-
>
next_
=
std
:
:
move
(
elem
)
;
last_
=
last_
-
>
next_
.
get
(
)
;
}
else
{
head_
=
std
:
:
move
(
elem
)
;
last_
=
head_
.
get
(
)
;
}
assertInvariants
(
)
;
}
void
appendAll
(
SingleLinkedList
&
&
list
)
{
if
(
list
.
empty
(
)
)
return
;
if
(
last_
)
last_
-
>
next_
=
std
:
:
move
(
list
.
head_
)
;
else
head_
=
std
:
:
move
(
list
.
head_
)
;
last_
=
list
.
last_
;
list
.
last_
=
nullptr
;
assertInvariants
(
)
;
list
.
assertInvariants
(
)
;
}
UniquePtr
<
T
D
>
popFirst
(
)
{
MOZ_ASSERT
(
head_
)
;
UniquePtr
<
T
D
>
result
=
std
:
:
move
(
head_
)
;
head_
=
std
:
:
move
(
result
-
>
next_
)
;
if
(
!
head_
)
last_
=
nullptr
;
assertInvariants
(
)
;
return
result
;
}
}
;
static
const
size_t
LIFO_ALLOC_ALIGN
=
8
;
MOZ_ALWAYS_INLINE
uint8_t
*
AlignPtr
(
uint8_t
*
orig
)
{
static_assert
(
mozilla
:
:
IsPowerOfTwo
(
LIFO_ALLOC_ALIGN
)
"
LIFO_ALLOC_ALIGN
must
be
a
power
of
two
"
)
;
uint8_t
*
result
=
(
uint8_t
*
)
AlignBytes
(
uintptr_t
(
orig
)
LIFO_ALLOC_ALIGN
)
;
MOZ_ASSERT
(
uintptr_t
(
result
)
%
LIFO_ALLOC_ALIGN
=
=
0
)
;
return
result
;
}
class
BumpChunk
:
public
SingleLinkedListElement
<
BumpChunk
>
{
private
:
uint8_t
*
bump_
;
uint8_t
*
const
capacity_
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
const
uintptr_t
magic_
:
24
;
static
constexpr
uintptr_t
magicNumber
=
uintptr_t
(
0x4c6966
)
;
#
endif
#
if
defined
(
DEBUG
)
|
|
defined
(
MOZ_DIAGNOSTIC_ASSERT_ENABLED
)
#
define
LIFO_CHUNK_PROTECT
1
#
endif
#
ifdef
LIFO_CHUNK_PROTECT
const
uintptr_t
protect_
:
1
;
#
endif
#
if
defined
(
DEBUG
)
#
define
LIFO_HAVE_MEM_CHECKS
1
static
constexpr
int
undefinedChunkMemory
=
0xcd
;
static
constexpr
int
uninitializedChunkMemory
=
0xce
;
#
define
LIFO_MAKE_MEM_NOACCESS
(
addr
size
)
\
do
{
\
uint8_t
*
base
=
(
addr
)
;
\
size_t
sz
=
(
size
)
;
\
memset
(
base
undefinedChunkMemory
sz
)
;
\
MOZ_MAKE_MEM_NOACCESS
(
base
sz
)
;
\
}
while
(
0
)
#
define
LIFO_MAKE_MEM_UNDEFINED
(
addr
size
)
\
do
{
\
uint8_t
*
base
=
(
addr
)
;
\
size_t
sz
=
(
size
)
;
\
MOZ_MAKE_MEM_UNDEFINED
(
base
sz
)
;
\
memset
(
base
uninitializedChunkMemory
sz
)
;
\
MOZ_MAKE_MEM_UNDEFINED
(
base
sz
)
;
\
}
while
(
0
)
#
elif
defined
(
MOZ_HAVE_MEM_CHECKS
)
#
define
LIFO_HAVE_MEM_CHECKS
1
#
define
LIFO_MAKE_MEM_NOACCESS
(
addr
size
)
MOZ_MAKE_MEM_NOACCESS
(
(
addr
)
(
size
)
)
#
define
LIFO_MAKE_MEM_UNDEFINED
(
addr
size
)
MOZ_MAKE_MEM_UNDEFINED
(
(
addr
)
(
size
)
)
#
endif
void
assertInvariants
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
magic_
=
=
magicNumber
)
;
MOZ_ASSERT
(
begin
(
)
<
=
end
(
)
)
;
MOZ_ASSERT
(
end
(
)
<
=
capacity_
)
;
}
BumpChunk
&
operator
=
(
const
BumpChunk
&
)
=
delete
;
BumpChunk
(
const
BumpChunk
&
)
=
delete
;
explicit
BumpChunk
(
uintptr_t
capacity
bool
protect
)
:
bump_
(
begin
(
)
)
capacity_
(
base
(
)
+
capacity
)
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
magic_
(
magicNumber
)
#
endif
#
ifdef
LIFO_CHUNK_PROTECT
protect_
(
protect
?
1
:
0
)
#
endif
{
assertInvariants
(
)
;
#
if
defined
(
LIFO_HAVE_MEM_CHECKS
)
LIFO_MAKE_MEM_NOACCESS
(
bump_
capacity_
-
bump_
)
;
#
endif
addMProtectHandler
(
)
;
}
const
uint8_t
*
base
(
)
const
{
return
reinterpret_cast
<
const
uint8_t
*
>
(
this
)
;
}
uint8_t
*
base
(
)
{
return
reinterpret_cast
<
uint8_t
*
>
(
this
)
;
}
void
setBump
(
uint8_t
*
newBump
)
{
assertInvariants
(
)
;
MOZ_ASSERT
(
begin
(
)
<
=
newBump
)
;
MOZ_ASSERT
(
newBump
<
=
capacity_
)
;
#
if
defined
(
LIFO_HAVE_MEM_CHECKS
)
if
(
bump_
>
newBump
)
LIFO_MAKE_MEM_NOACCESS
(
newBump
bump_
-
newBump
)
;
else
if
(
newBump
>
bump_
)
LIFO_MAKE_MEM_UNDEFINED
(
bump_
newBump
-
bump_
)
;
#
endif
bump_
=
newBump
;
}
public
:
~
BumpChunk
(
)
{
release
(
)
;
removeMProtectHandler
(
)
;
}
bool
empty
(
)
const
{
return
end
(
)
=
=
begin
(
)
;
}
size_t
used
(
)
const
{
return
end
(
)
-
begin
(
)
;
}
inline
const
uint8_t
*
begin
(
)
const
;
inline
uint8_t
*
begin
(
)
;
uint8_t
*
end
(
)
const
{
return
bump_
;
}
static
UniquePtr
<
BumpChunk
>
newWithCapacity
(
size_t
size
bool
protect
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
;
}
size_t
computedSizeOfIncludingThis
(
)
const
{
return
capacity_
-
base
(
)
;
}
class
Mark
{
BumpChunk
*
chunk_
;
uint8_t
*
bump_
;
friend
class
BumpChunk
;
explicit
Mark
(
BumpChunk
*
chunk
uint8_t
*
bump
)
:
chunk_
(
chunk
)
bump_
(
bump
)
{
}
public
:
Mark
(
)
:
chunk_
(
nullptr
)
bump_
(
nullptr
)
{
}
BumpChunk
*
markedChunk
(
)
const
{
return
chunk_
;
}
}
;
Mark
mark
(
)
{
return
Mark
(
this
end
(
)
)
;
}
bool
contains
(
void
*
ptr
)
const
{
return
begin
(
)
<
=
ptr
&
&
ptr
<
=
end
(
)
;
}
bool
contains
(
Mark
m
)
const
{
MOZ_ASSERT
(
m
.
chunk_
=
=
this
)
;
return
contains
(
m
.
bump_
)
;
}
void
release
(
)
{
setBump
(
begin
(
)
)
;
}
void
release
(
Mark
m
)
{
MOZ_RELEASE_ASSERT
(
contains
(
m
)
)
;
setBump
(
m
.
bump_
)
;
}
bool
canAlloc
(
size_t
n
)
;
size_t
unused
(
)
const
{
uint8_t
*
aligned
=
AlignPtr
(
end
(
)
)
;
if
(
aligned
<
capacity_
)
return
capacity_
-
aligned
;
return
0
;
}
MOZ_ALWAYS_INLINE
void
*
tryAlloc
(
size_t
n
)
{
uint8_t
*
aligned
=
AlignPtr
(
end
(
)
)
;
uint8_t
*
newBump
=
aligned
+
n
;
if
(
newBump
>
capacity_
)
return
nullptr
;
if
(
MOZ_UNLIKELY
(
newBump
<
bump_
)
)
return
nullptr
;
MOZ_ASSERT
(
canAlloc
(
n
)
)
;
setBump
(
newBump
)
;
return
aligned
;
}
enum
class
Loc
{
Header
=
0
Allocated
=
1
Reserved
=
2
End
=
3
}
;
#
ifdef
LIFO_CHUNK_PROTECT
void
setRWUntil
(
Loc
loc
)
const
;
void
addMProtectHandler
(
)
const
;
void
removeMProtectHandler
(
)
const
;
#
else
void
setRWUntil
(
Loc
loc
)
const
{
}
void
addMProtectHandler
(
)
const
{
}
void
removeMProtectHandler
(
)
const
{
}
#
endif
}
;
static
constexpr
size_t
BumpChunkReservedSpace
=
AlignBytes
(
sizeof
(
BumpChunk
)
LIFO_ALLOC_ALIGN
)
;
inline
const
uint8_t
*
BumpChunk
:
:
begin
(
)
const
{
return
base
(
)
+
BumpChunkReservedSpace
;
}
inline
uint8_t
*
BumpChunk
:
:
begin
(
)
{
return
base
(
)
+
BumpChunkReservedSpace
;
}
}
class
LifoAlloc
{
using
Loc
=
detail
:
:
BumpChunk
:
:
Loc
;
using
UniqueBumpChunk
=
js
:
:
UniquePtr
<
detail
:
:
BumpChunk
>
;
using
BumpChunkList
=
detail
:
:
SingleLinkedList
<
detail
:
:
BumpChunk
>
;
BumpChunkList
chunks_
;
BumpChunkList
unused_
;
size_t
markCount
;
size_t
defaultChunkSize_
;
size_t
curSize_
;
size_t
peakSize_
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
bool
fallibleScope_
;
#
endif
#
ifdef
LIFO_CHUNK_PROTECT
const
bool
protect_
;
#
endif
void
operator
=
(
const
LifoAlloc
&
)
=
delete
;
LifoAlloc
(
const
LifoAlloc
&
)
=
delete
;
UniqueBumpChunk
newChunkWithCapacity
(
size_t
n
)
;
MOZ_MUST_USE
bool
getOrCreateChunk
(
size_t
n
)
;
void
reset
(
size_t
defaultChunkSize
)
;
void
appendUnused
(
BumpChunkList
&
&
otherUnused
)
{
#
ifdef
DEBUG
for
(
detail
:
:
BumpChunk
&
bc
:
otherUnused
)
MOZ_ASSERT
(
bc
.
empty
(
)
)
;
#
endif
unused_
.
appendAll
(
std
:
:
move
(
otherUnused
)
)
;
}
void
appendUsed
(
BumpChunkList
&
&
otherChunks
)
{
chunks_
.
appendAll
(
std
:
:
move
(
otherChunks
)
)
;
}
void
incrementCurSize
(
size_t
size
)
{
curSize_
+
=
size
;
if
(
curSize_
>
peakSize_
)
peakSize_
=
curSize_
;
}
void
decrementCurSize
(
size_t
size
)
{
MOZ_ASSERT
(
curSize_
>
=
size
)
;
curSize_
-
=
size
;
}
MOZ_ALWAYS_INLINE
void
*
allocImpl
(
size_t
n
)
{
void
*
result
;
if
(
!
chunks_
.
empty
(
)
&
&
(
result
=
chunks_
.
last
(
)
-
>
tryAlloc
(
n
)
)
)
return
result
;
if
(
!
getOrCreateChunk
(
n
)
)
return
nullptr
;
result
=
chunks_
.
last
(
)
-
>
tryAlloc
(
n
)
;
MOZ_ASSERT
(
result
)
;
return
result
;
}
public
:
explicit
LifoAlloc
(
size_t
defaultChunkSize
bool
protect
=
true
)
:
peakSize_
(
0
)
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
fallibleScope_
(
true
)
#
endif
#
ifdef
LIFO_CHUNK_PROTECT
protect_
(
protect
)
#
endif
{
reset
(
defaultChunkSize
)
;
}
void
steal
(
LifoAlloc
*
other
)
{
MOZ_ASSERT
(
!
other
-
>
markCount
)
;
MOZ_DIAGNOSTIC_ASSERT
(
unused_
.
empty
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
chunks_
.
empty
(
)
)
;
chunks_
=
std
:
:
move
(
other
-
>
chunks_
)
;
unused_
=
std
:
:
move
(
other
-
>
unused_
)
;
markCount
=
other
-
>
markCount
;
defaultChunkSize_
=
other
-
>
defaultChunkSize_
;
curSize_
=
other
-
>
curSize_
;
peakSize_
=
Max
(
peakSize_
other
-
>
peakSize_
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
fallibleScope_
=
other
-
>
fallibleScope_
;
#
endif
other
-
>
reset
(
defaultChunkSize_
)
;
}
void
transferFrom
(
LifoAlloc
*
other
)
;
void
transferUnusedFrom
(
LifoAlloc
*
other
)
;
~
LifoAlloc
(
)
{
freeAll
(
)
;
}
size_t
defaultChunkSize
(
)
const
{
return
defaultChunkSize_
;
}
void
freeAll
(
)
;
static
const
unsigned
HUGE_ALLOCATION
=
50
*
1024
*
1024
;
void
freeAllIfHugeAndUnused
(
)
{
if
(
markCount
=
=
0
&
&
curSize_
>
HUGE_ALLOCATION
)
freeAll
(
)
;
}
MOZ_ALWAYS_INLINE
void
*
alloc
(
size_t
n
)
{
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
if
(
fallibleScope_
)
JS_OOM_POSSIBLY_FAIL
(
)
;
#
endif
return
allocImpl
(
n
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
MOZ_ALWAYS_INLINE
T
*
allocInSize
(
size_t
n
Args
&
&
.
.
.
args
)
{
MOZ_ASSERT
(
n
>
=
sizeof
(
T
)
"
must
request
enough
space
to
store
a
T
"
)
;
static_assert
(
alignof
(
T
)
<
=
detail
:
:
LIFO_ALLOC_ALIGN
"
LifoAlloc
must
provide
enough
alignment
to
store
T
"
)
;
void
*
ptr
=
alloc
(
n
)
;
if
(
!
ptr
)
return
nullptr
;
return
new
(
ptr
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
MOZ_ALWAYS_INLINE
void
*
allocInfallible
(
size_t
n
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
void
*
result
=
allocImpl
(
n
)
)
return
result
;
oomUnsafe
.
crash
(
"
LifoAlloc
:
:
allocInfallible
"
)
;
return
nullptr
;
}
MOZ_ALWAYS_INLINE
MOZ_MUST_USE
bool
ensureUnusedApproximate
(
size_t
n
)
{
AutoFallibleScope
fallibleAllocator
(
this
)
;
size_t
total
=
0
;
if
(
!
chunks_
.
empty
(
)
)
{
total
+
=
chunks_
.
last
(
)
-
>
unused
(
)
;
if
(
total
>
=
n
)
return
true
;
}
for
(
detail
:
:
BumpChunk
&
bc
:
unused_
)
{
total
+
=
bc
.
unused
(
)
;
if
(
total
>
=
n
)
return
true
;
}
UniqueBumpChunk
newChunk
=
newChunkWithCapacity
(
n
)
;
if
(
!
newChunk
)
return
false
;
size_t
size
=
newChunk
-
>
computedSizeOfIncludingThis
(
)
;
newChunk
-
>
setRWUntil
(
Loc
:
:
Allocated
)
;
unused_
.
pushFront
(
std
:
:
move
(
newChunk
)
)
;
incrementCurSize
(
size
)
;
return
true
;
}
MOZ_ALWAYS_INLINE
void
setAsInfallibleByDefault
(
)
{
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
fallibleScope_
=
false
;
#
endif
}
class
MOZ_NON_TEMPORARY_CLASS
AutoFallibleScope
{
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
LifoAlloc
*
lifoAlloc_
;
bool
prevFallibleScope_
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
explicit
AutoFallibleScope
(
LifoAlloc
*
lifoAlloc
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
lifoAlloc_
=
lifoAlloc
;
prevFallibleScope_
=
lifoAlloc
-
>
fallibleScope_
;
lifoAlloc
-
>
fallibleScope_
=
true
;
}
~
AutoFallibleScope
(
)
{
lifoAlloc_
-
>
fallibleScope_
=
prevFallibleScope_
;
}
#
else
public
:
explicit
AutoFallibleScope
(
LifoAlloc
*
)
{
}
#
endif
}
;
template
<
typename
T
>
T
*
newArray
(
size_t
count
)
{
static_assert
(
mozilla
:
:
IsPod
<
T
>
:
:
value
"
T
must
be
POD
so
that
constructors
(
and
destructors
"
"
when
the
LifoAlloc
is
freed
)
need
not
be
called
"
)
;
return
newArrayUninitialized
<
T
>
(
count
)
;
}
template
<
typename
T
>
T
*
newArrayUninitialized
(
size_t
count
)
{
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
CalculateAllocSize
<
T
>
(
count
&
bytes
)
)
)
return
nullptr
;
return
static_cast
<
T
*
>
(
alloc
(
bytes
)
)
;
}
using
Mark
=
detail
:
:
BumpChunk
:
:
Mark
;
Mark
mark
(
)
{
markCount
+
+
;
if
(
chunks_
.
empty
(
)
)
return
Mark
(
)
;
return
chunks_
.
last
(
)
-
>
mark
(
)
;
}
void
release
(
Mark
mark
)
{
markCount
-
-
;
BumpChunkList
released
;
if
(
!
mark
.
markedChunk
(
)
)
released
=
std
:
:
move
(
chunks_
)
;
else
released
=
chunks_
.
splitAfter
(
mark
.
markedChunk
(
)
)
;
for
(
detail
:
:
BumpChunk
&
bc
:
released
)
{
bc
.
release
(
)
;
bc
.
setRWUntil
(
Loc
:
:
Allocated
)
;
}
unused_
.
appendAll
(
std
:
:
move
(
released
)
)
;
if
(
!
chunks_
.
empty
(
)
)
{
chunks_
.
last
(
)
-
>
setRWUntil
(
Loc
:
:
End
)
;
chunks_
.
last
(
)
-
>
release
(
mark
)
;
}
}
void
releaseAll
(
)
{
MOZ_ASSERT
(
!
markCount
)
;
for
(
detail
:
:
BumpChunk
&
bc
:
chunks_
)
{
bc
.
release
(
)
;
bc
.
setRWUntil
(
Loc
:
:
Allocated
)
;
}
unused_
.
appendAll
(
std
:
:
move
(
chunks_
)
)
;
}
void
setReadOnly
(
)
{
#
ifdef
LIFO_CHUNK_PROTECT
for
(
detail
:
:
BumpChunk
&
bc
:
chunks_
)
bc
.
setRWUntil
(
Loc
:
:
Header
)
;
for
(
detail
:
:
BumpChunk
&
bc
:
unused_
)
bc
.
setRWUntil
(
Loc
:
:
Header
)
;
#
endif
}
void
setReadWrite
(
)
{
#
ifdef
LIFO_CHUNK_PROTECT
BumpChunkList
:
:
Iterator
e
(
chunks_
.
last
(
)
)
;
for
(
BumpChunkList
:
:
Iterator
i
(
chunks_
.
begin
(
)
)
;
i
!
=
e
;
+
+
i
)
i
-
>
setRWUntil
(
Loc
:
:
Reserved
)
;
if
(
!
chunks_
.
empty
(
)
)
chunks_
.
last
(
)
-
>
setRWUntil
(
Loc
:
:
End
)
;
for
(
detail
:
:
BumpChunk
&
bc
:
unused_
)
bc
.
setRWUntil
(
Loc
:
:
Allocated
)
;
#
endif
}
size_t
used
(
)
const
{
size_t
accum
=
0
;
for
(
const
detail
:
:
BumpChunk
&
chunk
:
chunks_
)
accum
+
=
chunk
.
used
(
)
;
return
accum
;
}
bool
isEmpty
(
)
const
{
return
chunks_
.
empty
(
)
|
|
(
chunks_
.
begin
(
)
=
=
chunks_
.
last
(
)
&
&
chunks_
.
last
(
)
-
>
empty
(
)
)
;
}
size_t
availableInCurrentChunk
(
)
const
{
if
(
chunks_
.
empty
(
)
)
return
0
;
return
chunks_
.
last
(
)
-
>
unused
(
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
n
=
0
;
for
(
const
detail
:
:
BumpChunk
&
chunk
:
chunks_
)
n
+
=
chunk
.
sizeOfIncludingThis
(
mallocSizeOf
)
;
for
(
const
detail
:
:
BumpChunk
&
chunk
:
unused_
)
n
+
=
chunk
.
sizeOfIncludingThis
(
mallocSizeOf
)
;
return
n
;
}
size_t
computedSizeOfExcludingThis
(
)
const
{
size_t
n
=
0
;
for
(
const
detail
:
:
BumpChunk
&
chunk
:
chunks_
)
n
+
=
chunk
.
computedSizeOfIncludingThis
(
)
;
for
(
const
detail
:
:
BumpChunk
&
chunk
:
unused_
)
n
+
=
chunk
.
computedSizeOfIncludingThis
(
)
;
return
n
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
peakSizeOfExcludingThis
(
)
const
{
return
peakSize_
;
}
template
<
typename
T
>
MOZ_ALWAYS_INLINE
T
*
pod_malloc
(
)
{
return
static_cast
<
T
*
>
(
alloc
(
sizeof
(
T
)
)
)
;
}
JS_DECLARE_NEW_METHODS
(
new_
alloc
MOZ_ALWAYS_INLINE
)
JS_DECLARE_NEW_METHODS
(
newInfallible
allocInfallible
MOZ_ALWAYS_INLINE
)
#
ifdef
DEBUG
bool
contains
(
void
*
ptr
)
const
{
for
(
const
detail
:
:
BumpChunk
&
chunk
:
chunks_
)
{
if
(
chunk
.
contains
(
ptr
)
)
return
true
;
}
return
false
;
}
#
endif
class
Enum
{
friend
class
LifoAlloc
;
friend
class
detail
:
:
BumpChunk
;
BumpChunkList
:
:
Iterator
chunkIt_
;
BumpChunkList
:
:
Iterator
chunkEnd_
;
uint8_t
*
head_
;
uint8_t
*
seekBaseAndAdvanceBy
(
size_t
size
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
uint8_t
*
aligned
=
detail
:
:
AlignPtr
(
head_
)
;
if
(
aligned
+
size
>
chunkIt_
-
>
end
(
)
)
{
+
+
chunkIt_
;
aligned
=
chunkIt_
-
>
begin
(
)
;
MOZ_ASSERT
(
!
chunkIt_
-
>
empty
(
)
)
;
}
head_
=
aligned
+
size
;
MOZ_ASSERT
(
head_
<
=
chunkIt_
-
>
end
(
)
)
;
return
aligned
;
}
public
:
explicit
Enum
(
LifoAlloc
&
alloc
)
:
chunkIt_
(
alloc
.
chunks_
.
begin
(
)
)
chunkEnd_
(
alloc
.
chunks_
.
end
(
)
)
head_
(
nullptr
)
{
if
(
chunkIt_
!
=
chunkEnd_
)
head_
=
chunkIt_
-
>
begin
(
)
;
}
bool
empty
(
)
{
return
chunkIt_
=
=
chunkEnd_
|
|
(
chunkIt_
-
>
next
(
)
=
=
chunkEnd_
.
get
(
)
&
&
head_
>
=
chunkIt_
-
>
end
(
)
)
;
}
template
<
typename
T
>
T
*
read
(
size_t
size
=
sizeof
(
T
)
)
{
return
reinterpret_cast
<
T
*
>
(
read
(
size
)
)
;
}
void
*
read
(
size_t
size
)
{
return
seekBaseAndAdvanceBy
(
size
)
;
}
}
;
}
;
class
MOZ_NON_TEMPORARY_CLASS
LifoAllocScope
{
LifoAlloc
*
lifoAlloc
;
LifoAlloc
:
:
Mark
mark
;
LifoAlloc
:
:
AutoFallibleScope
fallibleScope
;
bool
shouldRelease
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
explicit
LifoAllocScope
(
LifoAlloc
*
lifoAlloc
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
lifoAlloc
(
lifoAlloc
)
mark
(
lifoAlloc
-
>
mark
(
)
)
fallibleScope
(
lifoAlloc
)
shouldRelease
(
true
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
LifoAllocScope
(
)
{
if
(
shouldRelease
)
lifoAlloc
-
>
release
(
mark
)
;
}
LifoAlloc
&
alloc
(
)
{
return
*
lifoAlloc
;
}
void
releaseEarly
(
)
{
MOZ_ASSERT
(
shouldRelease
)
;
lifoAlloc
-
>
release
(
mark
)
;
shouldRelease
=
false
;
}
}
;
enum
Fallibility
{
Fallible
Infallible
}
;
template
<
Fallibility
fb
>
class
LifoAllocPolicy
{
LifoAlloc
&
alloc_
;
public
:
MOZ_IMPLICIT
LifoAllocPolicy
(
LifoAlloc
&
alloc
)
:
alloc_
(
alloc
)
{
}
template
<
typename
T
>
T
*
maybe_pod_malloc
(
size_t
numElems
)
{
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
CalculateAllocSize
<
T
>
(
numElems
&
bytes
)
)
)
return
nullptr
;
void
*
p
=
fb
=
=
Fallible
?
alloc_
.
alloc
(
bytes
)
:
alloc_
.
allocInfallible
(
bytes
)
;
return
static_cast
<
T
*
>
(
p
)
;
}
template
<
typename
T
>
T
*
maybe_pod_calloc
(
size_t
numElems
)
{
T
*
p
=
maybe_pod_malloc
<
T
>
(
numElems
)
;
if
(
MOZ_UNLIKELY
(
!
p
)
)
return
nullptr
;
memset
(
p
0
numElems
*
sizeof
(
T
)
)
;
return
p
;
}
template
<
typename
T
>
T
*
maybe_pod_realloc
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
T
*
n
=
maybe_pod_malloc
<
T
>
(
newSize
)
;
if
(
MOZ_UNLIKELY
(
!
n
)
)
return
nullptr
;
MOZ_ASSERT
(
!
(
oldSize
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
sizeof
(
T
)
>
:
:
value
)
)
;
memcpy
(
n
p
Min
(
oldSize
*
sizeof
(
T
)
newSize
*
sizeof
(
T
)
)
)
;
return
n
;
}
template
<
typename
T
>
T
*
pod_malloc
(
size_t
numElems
)
{
return
maybe_pod_malloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
pod_calloc
(
size_t
numElems
)
{
return
maybe_pod_calloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
pod_realloc
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
return
maybe_pod_realloc
<
T
>
(
p
oldSize
newSize
)
;
}
template
<
typename
T
>
void
free_
(
T
*
p
size_t
numElems
)
{
}
void
reportAllocOverflow
(
)
const
{
}
MOZ_MUST_USE
bool
checkSimulatedOOM
(
)
const
{
return
fb
=
=
Infallible
|
|
!
js
:
:
oom
:
:
ShouldFailWithOOM
(
)
;
}
}
;
}
#
endif
