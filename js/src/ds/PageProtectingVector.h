#
ifndef
ds_PageProtectingVector_h
#
define
ds_PageProtectingVector_h
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
ds
/
MemoryProtectionExceptionHandler
.
h
"
#
include
"
gc
/
Memory
.
h
"
namespace
js
{
template
<
typename
T
size_t
MinInlineCapacity
=
0
class
AllocPolicy
=
mozilla
:
:
MallocAllocPolicy
bool
ProtectUsed
=
true
bool
ProtectUnused
=
true
size_t
InitialLowerBound
=
0
>
class
PageProtectingVector
final
{
mozilla
:
:
Vector
<
T
MinInlineCapacity
AllocPolicy
>
vector
;
size_t
pageSize
;
size_t
pageMask
;
size_t
offsetToPage
;
size_t
firstUnusedPage
;
size_t
protectedBytes
;
size_t
protectedUnusedBytes
;
intptr_t
unprotectedBytes
;
intptr_t
unprotectedUnusedPages
;
size_t
protectionLowerBound
;
bool
protectUsedEnabled
;
bool
protectUnusedEnabled
;
bool
regionUnprotected
;
bool
protectionDisabled
;
void
updateProtectUsedOffsets
(
)
{
MOZ_ASSERT
(
!
protectedBytes
)
;
unprotectedBytes
+
=
offsetToPage
;
offsetToPage
=
(
pageSize
-
(
uintptr_t
(
vector
.
begin
(
)
)
&
pageMask
)
)
&
pageMask
;
unprotectedBytes
-
=
offsetToPage
;
protectUsedEnabled
=
ProtectUsed
&
&
!
protectionDisabled
&
&
vector
.
capacity
(
)
*
sizeof
(
T
)
>
=
protectionLowerBound
&
&
vector
.
capacity
(
)
*
sizeof
(
T
)
>
=
pageSize
+
offsetToPage
;
}
void
updateProtectUnusedOffsets
(
)
{
MOZ_ASSERT
(
!
protectedUnusedBytes
)
;
firstUnusedPage
=
(
(
vector
.
length
(
)
*
sizeof
(
T
)
+
pageMask
-
offsetToPage
)
&
~
pageMask
)
+
offsetToPage
;
unprotectedUnusedPages
=
(
vector
.
capacity
(
)
*
sizeof
(
T
)
-
firstUnusedPage
)
/
pageSize
;
protectUnusedEnabled
=
ProtectUnused
&
&
!
protectionDisabled
&
&
vector
.
capacity
(
)
*
sizeof
(
T
)
>
=
protectionLowerBound
&
&
vector
.
capacity
(
)
*
sizeof
(
T
)
>
=
pageSize
+
offsetToPage
;
}
void
updateProtectionOffsets
(
)
{
updateProtectUsedOffsets
(
)
;
updateProtectUnusedOffsets
(
)
;
}
void
protect
(
)
{
MOZ_ASSERT
(
!
regionUnprotected
)
;
if
(
MOZ_UNLIKELY
(
protectUsedEnabled
&
&
unprotectedBytes
>
=
intptr_t
(
pageSize
)
)
)
{
size_t
toProtect
=
size_t
(
unprotectedBytes
)
&
~
pageMask
;
uintptr_t
addr
=
uintptr_t
(
vector
.
begin
(
)
)
+
offsetToPage
+
protectedBytes
;
gc
:
:
MakePagesReadOnly
(
reinterpret_cast
<
void
*
>
(
addr
)
toProtect
)
;
unprotectedBytes
-
=
toProtect
;
protectedBytes
+
=
toProtect
;
}
}
void
protectUnused
(
)
{
MOZ_ASSERT
(
!
protectedUnusedBytes
)
;
if
(
protectUnusedEnabled
&
&
unprotectedUnusedPages
)
{
size_t
toProtect
=
unprotectedUnusedPages
*
pageSize
;
uintptr_t
addr
=
uintptr_t
(
vector
.
begin
(
)
)
+
firstUnusedPage
;
gc
:
:
ProtectPages
(
reinterpret_cast
<
void
*
>
(
addr
)
toProtect
)
;
unprotectedUnusedPages
=
0
;
protectedUnusedBytes
=
toProtect
;
}
}
void
protectNewBuffer
(
)
{
updateProtectionOffsets
(
)
;
if
(
protectUsedEnabled
|
|
protectUnusedEnabled
)
MemoryProtectionExceptionHandler
:
:
addRegion
(
vector
.
begin
(
)
vector
.
capacity
(
)
*
sizeof
(
T
)
)
;
protect
(
)
;
protectUnused
(
)
;
}
void
unprotect
(
)
{
MOZ_ASSERT
(
!
regionUnprotected
)
;
MOZ_ASSERT_IF
(
!
protectUsedEnabled
!
protectedBytes
)
;
if
(
protectedBytes
)
{
uintptr_t
addr
=
uintptr_t
(
vector
.
begin
(
)
)
+
offsetToPage
;
gc
:
:
UnprotectPages
(
reinterpret_cast
<
void
*
>
(
addr
)
protectedBytes
)
;
unprotectedBytes
+
=
protectedBytes
;
protectedBytes
=
0
;
}
}
void
unprotectUnused
(
size_t
newSize
)
{
MOZ_ASSERT_IF
(
!
protectUnusedEnabled
!
protectedUnusedBytes
)
;
if
(
MOZ_UNLIKELY
(
protectedUnusedBytes
&
&
newSize
>
firstUnusedPage
)
)
{
size_t
toUnprotect
=
(
(
newSize
-
firstUnusedPage
)
+
pageMask
)
&
~
pageMask
;
if
(
toUnprotect
>
protectedUnusedBytes
)
toUnprotect
=
protectedUnusedBytes
;
uintptr_t
addr
=
uintptr_t
(
vector
.
begin
(
)
)
+
firstUnusedPage
;
gc
:
:
UnprotectPages
(
reinterpret_cast
<
void
*
>
(
addr
)
toUnprotect
)
;
firstUnusedPage
+
=
toUnprotect
;
protectedUnusedBytes
-
=
toUnprotect
;
}
}
void
unprotectOldBuffer
(
)
{
unprotect
(
)
;
unprotectUnused
(
vector
.
capacity
(
)
*
sizeof
(
T
)
)
;
if
(
protectUsedEnabled
|
|
protectUnusedEnabled
)
MemoryProtectionExceptionHandler
:
:
removeRegion
(
vector
.
begin
(
)
)
;
}
bool
anyProtected
(
size_t
first
size_t
last
)
{
return
last
>
=
offsetToPage
&
&
first
<
offsetToPage
+
protectedBytes
;
}
void
setContainingRegion
(
size_t
first
size_t
last
uintptr_t
*
addr
size_t
*
size
)
{
if
(
first
<
offsetToPage
)
first
=
offsetToPage
;
if
(
last
>
offsetToPage
+
protectedBytes
-
1
)
last
=
offsetToPage
+
protectedBytes
-
1
;
uintptr_t
firstAddr
=
uintptr_t
(
vector
.
begin
(
)
)
;
uintptr_t
firstPage
=
(
firstAddr
+
first
)
&
~
pageMask
;
uintptr_t
lastPage
=
(
firstAddr
+
last
)
&
~
pageMask
;
*
size
=
pageSize
+
(
lastPage
-
firstPage
)
;
*
addr
=
firstPage
;
}
void
protectAfterUsing
(
size_t
size
)
{
unprotectedBytes
+
=
size
*
sizeof
(
T
)
;
protect
(
)
;
}
void
unprotectBeforeUsing
(
size_t
size
)
{
MOZ_ASSERT
(
vector
.
length
(
)
+
size
<
=
vector
.
capacity
(
)
)
;
unprotectUnused
(
(
vector
.
length
(
)
+
size
)
*
sizeof
(
T
)
)
;
}
class
AutoUnprotect
{
PageProtectingVector
*
vector
;
public
:
AutoUnprotect
(
)
:
vector
(
nullptr
)
{
}
;
void
emplace
(
PageProtectingVector
*
holder
)
{
vector
=
holder
;
vector
-
>
unprotectOldBuffer
(
)
;
}
explicit
AutoUnprotect
(
PageProtectingVector
*
holder
)
{
emplace
(
holder
)
;
}
~
AutoUnprotect
(
)
{
if
(
vector
)
vector
-
>
protectNewBuffer
(
)
;
}
}
;
public
:
explicit
PageProtectingVector
(
AllocPolicy
policy
=
AllocPolicy
(
)
)
:
vector
(
policy
)
pageSize
(
gc
:
:
SystemPageSize
(
)
)
pageMask
(
pageSize
-
1
)
offsetToPage
(
0
)
firstUnusedPage
(
0
)
protectedBytes
(
0
)
protectedUnusedBytes
(
0
)
unprotectedBytes
(
0
)
unprotectedUnusedPages
(
0
)
protectionLowerBound
(
InitialLowerBound
)
protectUsedEnabled
(
false
)
protectUnusedEnabled
(
false
)
regionUnprotected
(
false
)
protectionDisabled
(
false
)
{
protectNewBuffer
(
)
;
}
~
PageProtectingVector
(
)
{
unprotectOldBuffer
(
)
;
}
void
disableProtection
(
)
{
MOZ_ASSERT
(
!
protectionDisabled
)
;
unprotectOldBuffer
(
)
;
protectionDisabled
=
true
;
updateProtectionOffsets
(
)
;
}
void
enableProtection
(
)
{
MOZ_ASSERT
(
protectionDisabled
)
;
protectionDisabled
=
false
;
protectNewBuffer
(
)
;
}
void
setLowerBoundForProtection
(
size_t
bytes
)
{
if
(
protectionLowerBound
!
=
bytes
)
{
unprotectOldBuffer
(
)
;
protectionLowerBound
=
bytes
;
protectNewBuffer
(
)
;
}
}
void
unprotectRegion
(
size_t
firstByteOffset
size_t
lastByteOffset
)
{
MOZ_ASSERT
(
!
regionUnprotected
)
;
regionUnprotected
=
true
;
if
(
!
protectedBytes
|
|
!
anyProtected
(
firstByteOffset
lastByteOffset
)
)
return
;
size_t
size
;
uintptr_t
addr
;
setContainingRegion
(
firstByteOffset
lastByteOffset
&
addr
&
size
)
;
gc
:
:
UnprotectPages
(
reinterpret_cast
<
void
*
>
(
addr
)
size
)
;
}
void
reprotectRegion
(
size_t
firstByteOffset
size_t
lastByteOffset
)
{
MOZ_ASSERT
(
regionUnprotected
)
;
regionUnprotected
=
false
;
if
(
!
protectedBytes
|
|
!
anyProtected
(
firstByteOffset
lastByteOffset
)
)
return
;
size_t
size
;
uintptr_t
addr
;
setContainingRegion
(
firstByteOffset
lastByteOffset
&
addr
&
size
)
;
gc
:
:
MakePagesReadOnly
(
reinterpret_cast
<
void
*
>
(
addr
)
size
)
;
}
size_t
length
(
)
const
{
return
vector
.
length
(
)
;
}
T
*
begin
(
)
{
return
vector
.
begin
(
)
;
}
const
T
*
begin
(
)
const
{
return
vector
.
begin
(
)
;
}
void
clear
(
)
{
AutoUnprotect
guard
(
this
)
;
vector
.
clear
(
)
;
offsetToPage
=
0
;
unprotectedBytes
=
0
;
}
MOZ_MUST_USE
bool
reserve
(
size_t
size
)
{
AutoUnprotect
guard
;
if
(
size
>
vector
.
capacity
(
)
)
guard
.
emplace
(
this
)
;
return
vector
.
reserve
(
size
)
;
}
template
<
typename
U
>
MOZ_ALWAYS_INLINE
void
infallibleAppend
(
const
U
*
values
size_t
size
)
{
unprotectBeforeUsing
(
size
)
;
vector
.
infallibleAppend
(
values
size
)
;
protectAfterUsing
(
size
)
;
}
template
<
typename
U
>
MOZ_MUST_USE
bool
append
(
const
U
*
values
size_t
size
)
{
bool
ret
;
{
AutoUnprotect
guard
;
if
(
MOZ_UNLIKELY
(
vector
.
length
(
)
+
size
>
vector
.
capacity
(
)
)
)
guard
.
emplace
(
this
)
;
else
unprotectBeforeUsing
(
size
)
;
ret
=
vector
.
append
(
values
size
)
;
}
if
(
ret
)
protectAfterUsing
(
size
)
;
return
ret
;
}
}
;
}
#
endif
