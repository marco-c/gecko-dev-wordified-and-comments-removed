#
ifndef
ds_PageProtectingVector_h
#
define
ds_PageProtectingVector_h
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
gc
/
Memory
.
h
"
namespace
js
{
template
<
typename
T
size_t
MinInlineCapacity
=
0
class
AllocPolicy
=
mozilla
:
:
MallocAllocPolicy
>
class
PageProtectingVector
final
{
mozilla
:
:
Vector
<
T
MinInlineCapacity
AllocPolicy
>
vector
;
size_t
pageSize
;
size_t
pageMask
;
size_t
offsetToPage
;
size_t
protectedBytes
;
intptr_t
unprotectedBytes
;
size_t
protectionLowerBound
;
bool
protectionEnabled
;
bool
regionUnprotected
;
void
updateOffsetToPage
(
)
{
unprotectedBytes
+
=
offsetToPage
;
offsetToPage
=
(
pageSize
-
(
uintptr_t
(
vector
.
begin
(
)
)
&
pageMask
)
)
&
pageMask
;
unprotectedBytes
-
=
offsetToPage
;
protectionEnabled
=
vector
.
capacity
(
)
>
=
protectionLowerBound
&
&
vector
.
capacity
(
)
>
=
pageSize
+
offsetToPage
;
}
void
protect
(
)
{
MOZ_ASSERT
(
!
regionUnprotected
)
;
if
(
protectionEnabled
&
&
unprotectedBytes
>
=
intptr_t
(
pageSize
)
)
{
size_t
toProtect
=
size_t
(
unprotectedBytes
)
&
~
pageMask
;
uintptr_t
addr
=
uintptr_t
(
vector
.
begin
(
)
)
+
offsetToPage
+
protectedBytes
;
gc
:
:
MakePagesReadOnly
(
reinterpret_cast
<
void
*
>
(
addr
)
toProtect
)
;
unprotectedBytes
-
=
toProtect
;
protectedBytes
+
=
toProtect
;
}
}
void
unprotect
(
)
{
MOZ_ASSERT
(
!
regionUnprotected
)
;
MOZ_ASSERT_IF
(
!
protectionEnabled
!
protectedBytes
)
;
if
(
protectedBytes
)
{
uintptr_t
addr
=
uintptr_t
(
vector
.
begin
(
)
)
+
offsetToPage
;
gc
:
:
UnprotectPages
(
reinterpret_cast
<
void
*
>
(
addr
)
protectedBytes
)
;
unprotectedBytes
+
=
protectedBytes
;
protectedBytes
=
0
;
}
}
void
protectNewBuffer
(
)
{
updateOffsetToPage
(
)
;
protect
(
)
;
}
void
unprotectOldBuffer
(
)
{
unprotect
(
)
;
}
bool
anyProtected
(
size_t
first
size_t
last
)
{
return
last
>
=
offsetToPage
&
&
first
<
offsetToPage
+
protectedBytes
;
}
void
setContainingRegion
(
size_t
first
size_t
last
uintptr_t
*
addr
size_t
*
size
)
{
if
(
first
<
offsetToPage
)
first
=
offsetToPage
;
if
(
last
>
offsetToPage
+
protectedBytes
-
1
)
last
=
offsetToPage
+
protectedBytes
-
1
;
uintptr_t
firstAddr
=
uintptr_t
(
vector
.
begin
(
)
)
;
uintptr_t
firstPage
=
(
firstAddr
+
first
)
&
~
pageMask
;
uintptr_t
lastPage
=
(
firstAddr
+
last
)
&
~
pageMask
;
*
size
=
pageSize
+
(
lastPage
-
firstPage
)
;
*
addr
=
firstPage
;
}
void
increaseElemsUsed
(
size_t
used
)
{
unprotectedBytes
+
=
used
*
sizeof
(
T
)
;
protect
(
)
;
}
class
AutoUnprotect
{
PageProtectingVector
*
vector
;
public
:
AutoUnprotect
(
)
:
vector
(
nullptr
)
{
}
;
void
emplace
(
PageProtectingVector
*
holder
)
{
vector
=
holder
;
vector
-
>
unprotectOldBuffer
(
)
;
}
explicit
AutoUnprotect
(
PageProtectingVector
*
holder
)
{
emplace
(
holder
)
;
}
~
AutoUnprotect
(
)
{
if
(
vector
)
vector
-
>
protectNewBuffer
(
)
;
}
}
;
public
:
explicit
PageProtectingVector
(
AllocPolicy
policy
=
AllocPolicy
(
)
)
:
vector
(
policy
)
pageSize
(
gc
:
:
SystemPageSize
(
)
)
pageMask
(
pageSize
-
1
)
offsetToPage
(
0
)
protectedBytes
(
0
)
unprotectedBytes
(
0
)
protectionLowerBound
(
0
)
protectionEnabled
(
false
)
regionUnprotected
(
false
)
{
protectNewBuffer
(
)
;
}
~
PageProtectingVector
(
)
{
unprotectOldBuffer
(
)
;
}
void
setLowerBoundForProtection
(
size_t
bytes
)
{
if
(
protectionLowerBound
!
=
bytes
)
{
unprotectOldBuffer
(
)
;
protectionLowerBound
=
bytes
;
protectNewBuffer
(
)
;
}
}
void
unprotectRegion
(
size_t
firstByteOffset
size_t
lastByteOffset
)
{
MOZ_ASSERT
(
!
regionUnprotected
)
;
regionUnprotected
=
true
;
if
(
!
protectedBytes
|
|
!
anyProtected
(
firstByteOffset
lastByteOffset
)
)
return
;
size_t
size
;
uintptr_t
addr
;
setContainingRegion
(
firstByteOffset
lastByteOffset
&
addr
&
size
)
;
gc
:
:
UnprotectPages
(
reinterpret_cast
<
void
*
>
(
addr
)
size
)
;
}
void
reprotectRegion
(
size_t
firstByteOffset
size_t
lastByteOffset
)
{
MOZ_ASSERT
(
regionUnprotected
)
;
regionUnprotected
=
false
;
if
(
!
protectedBytes
|
|
!
anyProtected
(
firstByteOffset
lastByteOffset
)
)
return
;
size_t
size
;
uintptr_t
addr
;
setContainingRegion
(
firstByteOffset
lastByteOffset
&
addr
&
size
)
;
gc
:
:
MakePagesReadOnly
(
reinterpret_cast
<
void
*
>
(
addr
)
size
)
;
}
size_t
length
(
)
const
{
return
vector
.
length
(
)
;
}
T
*
begin
(
)
{
return
vector
.
begin
(
)
;
}
const
T
*
begin
(
)
const
{
return
vector
.
begin
(
)
;
}
void
clear
(
)
{
AutoUnprotect
guard
(
this
)
;
vector
.
clear
(
)
;
offsetToPage
=
0
;
unprotectedBytes
=
0
;
}
MOZ_MUST_USE
bool
reserve
(
size_t
size
)
{
AutoUnprotect
guard
;
if
(
size
>
vector
.
capacity
(
)
)
guard
.
emplace
(
this
)
;
return
vector
.
reserve
(
size
)
;
}
template
<
typename
U
>
MOZ_ALWAYS_INLINE
void
infallibleAppend
(
const
U
*
values
size_t
size
)
{
vector
.
infallibleAppend
(
values
size
)
;
increaseElemsUsed
(
size
)
;
}
template
<
typename
U
>
MOZ_MUST_USE
bool
append
(
const
U
*
values
size_t
size
)
{
bool
ret
;
{
AutoUnprotect
guard
;
if
(
MOZ_UNLIKELY
(
vector
.
length
(
)
+
size
>
vector
.
capacity
(
)
)
)
guard
.
emplace
(
this
)
;
ret
=
vector
.
append
(
values
size
)
;
}
if
(
ret
)
increaseElemsUsed
(
size
)
;
return
ret
;
}
}
;
}
#
endif
