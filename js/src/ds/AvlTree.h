#
ifndef
ds_AvlTree_h
#
define
ds_AvlTree_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
ds
/
LifoAlloc
.
h
"
namespace
js
{
template
<
class
T
class
C
>
class
AvlTreeImpl
{
protected
:
enum
class
Tag
:
uint8_t
{
Free
None
Left
Right
}
;
struct
Node
{
Node
*
left
;
Node
*
right
;
Tag
tag
;
T
item
;
explicit
Node
(
const
T
&
item
)
:
left
(
nullptr
)
right
(
nullptr
)
tag
(
Tag
:
:
None
)
item
(
item
)
{
}
}
;
Node
*
root_
;
Node
*
freeList_
;
LifoAlloc
*
alloc_
;
uint32_t
nextAllocSize_
;
static
const
size_t
MAX_TREE_DEPTH
=
48
;
AvlTreeImpl
(
const
AvlTreeImpl
&
)
=
delete
;
AvlTreeImpl
&
operator
=
(
const
AvlTreeImpl
&
)
=
delete
;
explicit
AvlTreeImpl
(
LifoAlloc
*
alloc
=
nullptr
)
:
root_
(
nullptr
)
freeList_
(
nullptr
)
alloc_
(
alloc
)
nextAllocSize_
(
1
)
{
}
void
setAllocator
(
LifoAlloc
*
alloc
)
{
alloc_
=
alloc
;
}
inline
void
addToFreeList
(
Node
*
node
)
{
node
-
>
left
=
freeList_
;
node
-
>
right
=
nullptr
;
node
-
>
tag
=
Tag
:
:
Free
;
freeList_
=
node
;
}
inline
void
freeNode
(
Node
*
node
)
{
MOZ_ASSERT
(
node
-
>
tag
!
=
Tag
:
:
Free
)
;
addToFreeList
(
node
)
;
}
MOZ_NEVER_INLINE
Node
*
allocateNodeOOL
(
const
T
&
v
)
{
switch
(
nextAllocSize_
)
{
case
1
:
{
nextAllocSize_
=
2
;
Node
*
node
=
alloc_
-
>
new_
<
Node
>
(
v
)
;
return
node
;
}
case
2
:
{
nextAllocSize_
=
4
;
Node
*
nodes
=
alloc_
-
>
newArrayUninitialized
<
Node
>
(
2
)
;
if
(
!
nodes
)
{
return
nullptr
;
}
Node
*
node0
=
&
nodes
[
0
]
;
addToFreeList
(
&
nodes
[
1
]
)
;
new
(
node0
)
Node
(
v
)
;
return
node0
;
}
case
4
:
{
Node
*
nodes
=
alloc_
-
>
newArrayUninitialized
<
Node
>
(
4
)
;
if
(
!
nodes
)
{
return
nullptr
;
}
Node
*
node0
=
&
nodes
[
0
]
;
addToFreeList
(
&
nodes
[
3
]
)
;
addToFreeList
(
&
nodes
[
2
]
)
;
addToFreeList
(
&
nodes
[
1
]
)
;
new
(
node0
)
Node
(
v
)
;
return
node0
;
}
default
:
{
MOZ_CRASH
(
)
;
}
}
}
inline
Node
*
allocateNode
(
const
T
&
v
)
{
Node
*
node
=
freeList_
;
if
(
MOZ_LIKELY
(
node
)
)
{
MOZ_ASSERT
(
node
-
>
tag
=
=
Tag
:
:
Free
)
;
freeList_
=
node
-
>
left
;
new
(
node
)
Node
(
v
)
;
return
node
;
}
return
allocateNodeOOL
(
v
)
;
}
enum
class
Result
{
Error
OK
Balance
}
;
using
NodeAndResult
=
std
:
:
pair
<
Node
*
Result
>
;
Node
*
rotate_left
(
Node
*
old_root
)
{
Node
*
new_root
=
old_root
-
>
right
;
old_root
-
>
right
=
new_root
-
>
left
;
new_root
-
>
left
=
old_root
;
return
new_root
;
}
Node
*
rotate_right
(
Node
*
old_root
)
{
Node
*
new_root
=
old_root
-
>
left
;
old_root
-
>
left
=
new_root
-
>
right
;
new_root
-
>
right
=
old_root
;
return
new_root
;
}
MOZ_NEVER_INLINE
Node
*
leftgrown_left
(
Node
*
root
)
{
if
(
root
-
>
left
-
>
tag
=
=
Tag
:
:
Left
)
{
root
-
>
tag
=
Tag
:
:
None
;
root
-
>
left
-
>
tag
=
Tag
:
:
None
;
root
=
rotate_right
(
root
)
;
}
else
{
switch
(
root
-
>
left
-
>
right
-
>
tag
)
{
case
Tag
:
:
Left
:
root
-
>
tag
=
Tag
:
:
Right
;
root
-
>
left
-
>
tag
=
Tag
:
:
None
;
break
;
case
Tag
:
:
Right
:
root
-
>
tag
=
Tag
:
:
None
;
root
-
>
left
-
>
tag
=
Tag
:
:
Left
;
break
;
case
Tag
:
:
None
:
root
-
>
tag
=
Tag
:
:
None
;
root
-
>
left
-
>
tag
=
Tag
:
:
None
;
break
;
case
Tag
:
:
Free
:
default
:
MOZ_CRASH
(
)
;
}
root
-
>
left
-
>
right
-
>
tag
=
Tag
:
:
None
;
root
-
>
left
=
rotate_left
(
root
-
>
left
)
;
root
=
rotate_right
(
root
)
;
}
return
root
;
}
inline
NodeAndResult
leftgrown
(
Node
*
root
)
{
switch
(
root
-
>
tag
)
{
case
Tag
:
:
Left
:
return
NodeAndResult
(
leftgrown_left
(
root
)
Result
:
:
OK
)
;
case
Tag
:
:
Right
:
root
-
>
tag
=
Tag
:
:
None
;
return
NodeAndResult
(
root
Result
:
:
OK
)
;
case
Tag
:
:
None
:
root
-
>
tag
=
Tag
:
:
Left
;
return
NodeAndResult
(
root
Result
:
:
Balance
)
;
case
Tag
:
:
Free
:
default
:
break
;
}
MOZ_CRASH
(
)
;
}
MOZ_NEVER_INLINE
Node
*
rightgrown_right
(
Node
*
root
)
{
if
(
root
-
>
right
-
>
tag
=
=
Tag
:
:
Right
)
{
root
-
>
tag
=
Tag
:
:
None
;
root
-
>
right
-
>
tag
=
Tag
:
:
None
;
root
=
rotate_left
(
root
)
;
}
else
{
switch
(
root
-
>
right
-
>
left
-
>
tag
)
{
case
Tag
:
:
Right
:
root
-
>
tag
=
Tag
:
:
Left
;
root
-
>
right
-
>
tag
=
Tag
:
:
None
;
break
;
case
Tag
:
:
Left
:
root
-
>
tag
=
Tag
:
:
None
;
root
-
>
right
-
>
tag
=
Tag
:
:
Right
;
break
;
case
Tag
:
:
None
:
root
-
>
tag
=
Tag
:
:
None
;
root
-
>
right
-
>
tag
=
Tag
:
:
None
;
break
;
case
Tag
:
:
Free
:
default
:
MOZ_CRASH
(
)
;
}
root
-
>
right
-
>
left
-
>
tag
=
Tag
:
:
None
;
root
-
>
right
=
rotate_right
(
root
-
>
right
)
;
root
=
rotate_left
(
root
)
;
}
return
root
;
}
inline
NodeAndResult
rightgrown
(
Node
*
root
)
{
switch
(
root
-
>
tag
)
{
case
Tag
:
:
Left
:
root
-
>
tag
=
Tag
:
:
None
;
return
NodeAndResult
(
root
Result
:
:
OK
)
;
case
Tag
:
:
Right
:
return
NodeAndResult
(
rightgrown_right
(
root
)
Result
:
:
OK
)
;
case
Tag
:
:
None
:
root
-
>
tag
=
Tag
:
:
Right
;
return
NodeAndResult
(
root
Result
:
:
Balance
)
;
case
Tag
:
:
Free
:
default
:
break
;
}
MOZ_CRASH
(
)
;
}
Node
*
insert_worker
(
const
T
&
v
)
{
Node
*
stack
[
MAX_TREE_DEPTH
]
;
size_t
stackPtr
=
0
;
#
define
STACK_ENTRY_SET_IS_LEFT
(
_nodePtr
)
\
(
(
Node
*
)
(
uintptr_t
(
_nodePtr
)
|
uintptr_t
(
1
)
)
)
#
define
STACK_ENTRY_GET_IS_LEFT
(
_ent
)
(
(
bool
)
(
uintptr_t
(
_ent
)
&
uintptr_t
(
1
)
)
)
#
define
STACK_ENTRY_GET_NODE
(
_ent
)
(
(
Node
*
)
(
uintptr_t
(
_ent
)
&
~
uintptr_t
(
1
)
)
)
Node
*
node
=
root_
;
while
(
true
)
{
if
(
!
node
)
{
break
;
}
int
cmpRes1
=
C
:
:
compare
(
v
node
-
>
item
)
;
if
(
cmpRes1
<
0
)
{
stack
[
stackPtr
+
+
]
=
STACK_ENTRY_SET_IS_LEFT
(
node
)
;
node
=
node
-
>
left
;
}
else
if
(
cmpRes1
>
0
)
{
stack
[
stackPtr
+
+
]
=
node
;
node
=
node
-
>
right
;
}
else
{
return
(
Node
*
)
(
uintptr_t
(
1
)
)
;
}
if
(
!
node
)
{
break
;
}
int
cmpRes2
=
C
:
:
compare
(
v
node
-
>
item
)
;
if
(
cmpRes2
<
0
)
{
stack
[
stackPtr
+
+
]
=
STACK_ENTRY_SET_IS_LEFT
(
node
)
;
node
=
node
-
>
left
;
}
else
if
(
cmpRes2
>
0
)
{
stack
[
stackPtr
+
+
]
=
node
;
node
=
node
-
>
right
;
}
else
{
return
(
Node
*
)
(
uintptr_t
(
1
)
)
;
}
MOZ_RELEASE_ASSERT
(
stackPtr
<
MAX_TREE_DEPTH
-
2
)
;
}
MOZ_ASSERT
(
!
node
)
;
Node
*
new_node
=
allocateNode
(
v
)
;
if
(
!
new_node
)
{
return
nullptr
;
}
Node
*
curr_node
=
new_node
;
Result
curr_node_action
=
Result
:
:
Balance
;
while
(
stackPtr
>
0
)
{
Node
*
parent_node_tagged
=
stack
[
-
-
stackPtr
]
;
Node
*
parent_node
=
STACK_ENTRY_GET_NODE
(
parent_node_tagged
)
;
if
(
STACK_ENTRY_GET_IS_LEFT
(
parent_node_tagged
)
)
{
parent_node
-
>
left
=
curr_node
;
if
(
curr_node_action
=
=
Result
:
:
Balance
)
{
auto
pair
=
leftgrown
(
parent_node
)
;
curr_node
=
pair
.
first
;
curr_node_action
=
pair
.
second
;
}
else
{
curr_node
=
parent_node
;
break
;
}
}
else
{
parent_node
-
>
right
=
curr_node
;
if
(
curr_node_action
=
=
Result
:
:
Balance
)
{
auto
pair
=
rightgrown
(
parent_node
)
;
curr_node
=
pair
.
first
;
curr_node_action
=
pair
.
second
;
}
else
{
curr_node
=
parent_node
;
break
;
}
}
}
if
(
stackPtr
>
0
)
{
curr_node
=
STACK_ENTRY_GET_NODE
(
stack
[
0
]
)
;
}
MOZ_ASSERT
(
curr_node
)
;
#
undef
STACK_ENTRY_SET_IS_LEFT
#
undef
STACK_ENTRY_GET_IS_LEFT
#
undef
STACK_ENTRY_GET_NODE
return
curr_node
;
}
NodeAndResult
leftshrunk
(
Node
*
n
)
{
switch
(
n
-
>
tag
)
{
case
Tag
:
:
Left
:
{
n
-
>
tag
=
Tag
:
:
None
;
return
NodeAndResult
(
n
Result
:
:
Balance
)
;
}
case
Tag
:
:
Right
:
{
if
(
n
-
>
right
-
>
tag
=
=
Tag
:
:
Right
)
{
n
-
>
tag
=
Tag
:
:
None
;
n
-
>
right
-
>
tag
=
Tag
:
:
None
;
n
=
rotate_left
(
n
)
;
return
NodeAndResult
(
n
Result
:
:
Balance
)
;
}
else
if
(
n
-
>
right
-
>
tag
=
=
Tag
:
:
None
)
{
n
-
>
tag
=
Tag
:
:
Right
;
n
-
>
right
-
>
tag
=
Tag
:
:
Left
;
n
=
rotate_left
(
n
)
;
return
NodeAndResult
(
n
Result
:
:
OK
)
;
}
else
{
switch
(
n
-
>
right
-
>
left
-
>
tag
)
{
case
Tag
:
:
Left
:
n
-
>
tag
=
Tag
:
:
None
;
n
-
>
right
-
>
tag
=
Tag
:
:
Right
;
break
;
case
Tag
:
:
Right
:
n
-
>
tag
=
Tag
:
:
Left
;
n
-
>
right
-
>
tag
=
Tag
:
:
None
;
break
;
case
Tag
:
:
None
:
n
-
>
tag
=
Tag
:
:
None
;
n
-
>
right
-
>
tag
=
Tag
:
:
None
;
break
;
case
Tag
:
:
Free
:
default
:
MOZ_CRASH
(
)
;
}
n
-
>
right
-
>
left
-
>
tag
=
Tag
:
:
None
;
n
-
>
right
=
rotate_right
(
n
-
>
right
)
;
;
n
=
rotate_left
(
n
)
;
return
NodeAndResult
(
n
Result
:
:
Balance
)
;
}
MOZ_CRASH
(
)
;
}
case
Tag
:
:
None
:
{
n
-
>
tag
=
Tag
:
:
Right
;
return
NodeAndResult
(
n
Result
:
:
OK
)
;
}
case
Tag
:
:
Free
:
default
:
{
MOZ_CRASH
(
)
;
}
}
MOZ_CRASH
(
)
;
}
NodeAndResult
rightshrunk
(
Node
*
n
)
{
switch
(
n
-
>
tag
)
{
case
Tag
:
:
Right
:
{
n
-
>
tag
=
Tag
:
:
None
;
return
NodeAndResult
(
n
Result
:
:
Balance
)
;
}
case
Tag
:
:
Left
:
{
if
(
n
-
>
left
-
>
tag
=
=
Tag
:
:
Left
)
{
n
-
>
tag
=
Tag
:
:
None
;
n
-
>
left
-
>
tag
=
Tag
:
:
None
;
n
=
rotate_right
(
n
)
;
return
NodeAndResult
(
n
Result
:
:
Balance
)
;
}
else
if
(
n
-
>
left
-
>
tag
=
=
Tag
:
:
None
)
{
n
-
>
tag
=
Tag
:
:
Left
;
n
-
>
left
-
>
tag
=
Tag
:
:
Right
;
n
=
rotate_right
(
n
)
;
return
NodeAndResult
(
n
Result
:
:
OK
)
;
}
else
{
switch
(
n
-
>
left
-
>
right
-
>
tag
)
{
case
Tag
:
:
Left
:
n
-
>
tag
=
Tag
:
:
Right
;
n
-
>
left
-
>
tag
=
Tag
:
:
None
;
break
;
case
Tag
:
:
Right
:
n
-
>
tag
=
Tag
:
:
None
;
n
-
>
left
-
>
tag
=
Tag
:
:
Left
;
break
;
case
Tag
:
:
None
:
n
-
>
tag
=
Tag
:
:
None
;
n
-
>
left
-
>
tag
=
Tag
:
:
None
;
break
;
case
Tag
:
:
Free
:
default
:
MOZ_CRASH
(
)
;
}
n
-
>
left
-
>
right
-
>
tag
=
Tag
:
:
None
;
n
-
>
left
=
rotate_left
(
n
-
>
left
)
;
n
=
rotate_right
(
n
)
;
return
NodeAndResult
(
n
Result
:
:
Balance
)
;
}
MOZ_CRASH
(
)
;
}
case
Tag
:
:
None
:
{
n
-
>
tag
=
Tag
:
:
Left
;
return
NodeAndResult
(
n
Result
:
:
OK
)
;
}
case
Tag
:
:
Free
:
default
:
{
MOZ_CRASH
(
)
;
}
}
MOZ_CRASH
(
)
;
}
mozilla
:
:
Maybe
<
NodeAndResult
>
findhighest
(
Node
*
target
Node
*
n
)
{
if
(
n
=
=
nullptr
)
{
return
mozilla
:
:
Nothing
(
)
;
}
auto
res
=
Result
:
:
Balance
;
if
(
n
-
>
right
!
=
nullptr
)
{
auto
fhi
=
findhighest
(
target
n
-
>
right
)
;
if
(
fhi
.
isSome
(
)
)
{
n
-
>
right
=
fhi
.
value
(
)
.
first
;
res
=
fhi
.
value
(
)
.
second
;
if
(
res
=
=
Result
:
:
Balance
)
{
auto
pair
=
rightshrunk
(
n
)
;
n
=
pair
.
first
;
res
=
pair
.
second
;
}
return
mozilla
:
:
Some
(
NodeAndResult
(
n
res
)
)
;
}
else
{
return
mozilla
:
:
Nothing
(
)
;
}
}
target
-
>
item
=
n
-
>
item
;
Node
*
tmp
=
n
;
n
=
n
-
>
left
;
freeNode
(
tmp
)
;
return
mozilla
:
:
Some
(
NodeAndResult
(
n
res
)
)
;
}
mozilla
:
:
Maybe
<
NodeAndResult
>
findlowest
(
Node
*
target
Node
*
n
)
{
if
(
n
=
=
nullptr
)
{
return
mozilla
:
:
Nothing
(
)
;
}
Result
res
=
Result
:
:
Balance
;
if
(
n
-
>
left
!
=
nullptr
)
{
auto
flo
=
findlowest
(
target
n
-
>
left
)
;
if
(
flo
.
isSome
(
)
)
{
n
-
>
left
=
flo
.
value
(
)
.
first
;
res
=
flo
.
value
(
)
.
second
;
if
(
res
=
=
Result
:
:
Balance
)
{
auto
pair
=
leftshrunk
(
n
)
;
n
=
pair
.
first
;
res
=
pair
.
second
;
}
return
mozilla
:
:
Some
(
NodeAndResult
(
n
res
)
)
;
}
else
{
return
mozilla
:
:
Nothing
(
)
;
}
}
target
-
>
item
=
n
-
>
item
;
Node
*
tmp
=
n
;
n
=
n
-
>
right
;
freeNode
(
tmp
)
;
return
mozilla
:
:
Some
(
NodeAndResult
(
n
res
)
)
;
}
NodeAndResult
delete_worker
(
Node
*
node
const
T
&
item
)
{
Result
tmp
=
Result
:
:
Balance
;
if
(
node
=
=
nullptr
)
{
return
NodeAndResult
(
node
Result
:
:
Error
)
;
}
int
cmp_res
=
C
:
:
compare
(
item
node
-
>
item
)
;
if
(
cmp_res
<
0
)
{
auto
pair1
=
delete_worker
(
node
-
>
left
item
)
;
node
-
>
left
=
pair1
.
first
;
tmp
=
pair1
.
second
;
if
(
tmp
=
=
Result
:
:
Balance
)
{
auto
pair2
=
leftshrunk
(
node
)
;
node
=
pair2
.
first
;
tmp
=
pair2
.
second
;
}
return
NodeAndResult
(
node
tmp
)
;
}
else
if
(
cmp_res
>
0
)
{
auto
pair1
=
delete_worker
(
node
-
>
right
item
)
;
node
-
>
right
=
pair1
.
first
;
tmp
=
pair1
.
second
;
if
(
tmp
=
=
Result
:
:
Balance
)
{
auto
pair2
=
rightshrunk
(
node
)
;
node
=
pair2
.
first
;
tmp
=
pair2
.
second
;
}
return
NodeAndResult
(
node
tmp
)
;
}
else
{
if
(
node
-
>
left
!
=
nullptr
)
{
auto
fhi
=
findhighest
(
node
node
-
>
left
)
;
if
(
fhi
.
isSome
(
)
)
{
node
-
>
left
=
fhi
.
value
(
)
.
first
;
tmp
=
fhi
.
value
(
)
.
second
;
if
(
tmp
=
=
Result
:
:
Balance
)
{
auto
pair
=
leftshrunk
(
node
)
;
node
=
pair
.
first
;
tmp
=
pair
.
second
;
}
}
return
NodeAndResult
(
node
tmp
)
;
}
if
(
node
-
>
right
!
=
nullptr
)
{
auto
flo
=
findlowest
(
node
node
-
>
right
)
;
if
(
flo
.
isSome
(
)
)
{
node
-
>
right
=
flo
.
value
(
)
.
first
;
tmp
=
flo
.
value
(
)
.
second
;
if
(
tmp
=
=
Result
:
:
Balance
)
{
auto
pair
=
rightshrunk
(
node
)
;
node
=
pair
.
first
;
tmp
=
pair
.
second
;
}
}
return
NodeAndResult
(
node
tmp
)
;
}
freeNode
(
node
)
;
return
NodeAndResult
(
nullptr
Result
:
:
Balance
)
;
}
}
Node
*
find_worker
(
const
T
&
v
)
const
{
Node
*
node
=
root_
;
while
(
node
)
{
int
cmpRes
=
C
:
:
compare
(
v
node
-
>
item
)
;
if
(
cmpRes
<
0
)
{
node
=
node
-
>
left
;
}
else
if
(
cmpRes
>
0
)
{
node
=
node
-
>
right
;
}
else
{
return
node
;
}
}
return
nullptr
;
}
public
:
class
Iter
{
const
AvlTreeImpl
<
T
C
>
*
tree_
;
Node
*
stack_
[
MAX_TREE_DEPTH
]
;
size_t
stackPtr_
;
void
setupIteratorStack
(
Node
*
node
const
T
&
v
)
{
MOZ_ASSERT
(
stackPtr_
=
=
0
)
;
size_t
stackPtr
=
0
;
while
(
node
)
{
int
cmpRes
=
C
:
:
compare
(
v
node
-
>
item
)
;
if
(
cmpRes
<
0
)
{
stack_
[
stackPtr
+
+
]
=
node
;
MOZ_RELEASE_ASSERT
(
stackPtr
<
MAX_TREE_DEPTH
)
;
node
=
node
-
>
left
;
}
else
if
(
cmpRes
>
0
)
{
node
=
node
-
>
right
;
}
else
{
stack_
[
stackPtr
+
+
]
=
node
;
MOZ_RELEASE_ASSERT
(
stackPtr
<
MAX_TREE_DEPTH
)
;
break
;
}
}
stackPtr_
=
stackPtr
;
}
void
visitLeftChildren
(
Node
*
node
)
{
while
(
true
)
{
Node
*
left
=
node
-
>
left
;
if
(
left
=
=
nullptr
)
{
break
;
}
stack_
[
stackPtr_
+
+
]
=
left
;
MOZ_RELEASE_ASSERT
(
stackPtr_
<
MAX_TREE_DEPTH
)
;
node
=
left
;
}
}
public
:
explicit
Iter
(
const
AvlTreeImpl
<
T
C
>
*
tree
)
{
tree_
=
tree
;
stackPtr_
=
0
;
if
(
tree
-
>
root_
!
=
nullptr
)
{
stack_
[
stackPtr_
+
+
]
=
tree
-
>
root_
;
MOZ_RELEASE_ASSERT
(
stackPtr_
<
MAX_TREE_DEPTH
)
;
visitLeftChildren
(
tree
-
>
root_
)
;
}
}
Iter
(
const
AvlTreeImpl
<
T
C
>
*
tree
const
T
&
startAt
)
{
tree_
=
tree
;
stackPtr_
=
0
;
setupIteratorStack
(
tree_
-
>
root_
startAt
)
;
}
bool
hasMore
(
)
const
{
return
stackPtr_
>
0
;
}
T
next
(
)
{
MOZ_RELEASE_ASSERT
(
stackPtr_
>
0
)
;
Node
*
ret
=
stack_
[
-
-
stackPtr_
]
;
Node
*
right
=
ret
-
>
right
;
if
(
right
!
=
nullptr
)
{
stack_
[
stackPtr_
+
+
]
=
right
;
MOZ_RELEASE_ASSERT
(
stackPtr_
<
MAX_TREE_DEPTH
)
;
visitLeftChildren
(
right
)
;
}
return
ret
-
>
item
;
}
}
;
}
;
template
<
class
T
class
C
>
class
AvlTree
:
public
AvlTreeImpl
<
T
C
>
{
using
Impl
=
AvlTreeImpl
<
T
C
>
;
using
ImplNode
=
typename
AvlTreeImpl
<
T
C
>
:
:
Node
;
using
ImplResult
=
typename
AvlTreeImpl
<
T
C
>
:
:
Result
;
using
ImplNodeAndResult
=
typename
AvlTreeImpl
<
T
C
>
:
:
NodeAndResult
;
public
:
explicit
AvlTree
(
LifoAlloc
*
alloc
=
nullptr
)
:
Impl
(
alloc
)
{
}
void
setAllocator
(
LifoAlloc
*
alloc
)
{
Impl
:
:
setAllocator
(
alloc
)
;
}
bool
empty
(
)
const
{
return
Impl
:
:
root_
=
=
nullptr
;
}
[
[
nodiscard
]
]
bool
insert
(
const
T
&
v
)
{
ImplNode
*
new_root
=
Impl
:
:
insert_worker
(
v
)
;
if
(
MOZ_UNLIKELY
(
uintptr_t
(
new_root
)
<
=
uintptr_t
(
1
)
)
)
{
if
(
!
new_root
)
{
return
false
;
}
MOZ_CRASH
(
)
;
}
Impl
:
:
root_
=
new_root
;
return
true
;
}
void
remove
(
const
T
&
v
)
{
ImplNodeAndResult
pair
=
Impl
:
:
delete_worker
(
Impl
:
:
root_
v
)
;
ImplNode
*
new_root
=
pair
.
first
;
ImplResult
res
=
pair
.
second
;
if
(
MOZ_UNLIKELY
(
res
=
=
ImplResult
:
:
Error
)
)
{
MOZ_CRASH
(
)
;
}
else
{
Impl
:
:
root_
=
new_root
;
}
}
bool
contains
(
const
T
&
v
T
*
res
)
const
{
ImplNode
*
node
=
Impl
:
:
find_worker
(
v
)
;
if
(
node
)
{
*
res
=
node
-
>
item
;
return
true
;
}
return
false
;
}
T
*
maybeLookup
(
const
T
&
v
)
{
ImplNode
*
node
=
Impl
:
:
find_worker
(
v
)
;
if
(
node
)
{
return
&
(
node
-
>
item
)
;
}
return
nullptr
;
}
}
;
}
#
endif
