#
ifndef
ds_OrderedHashTable_h
#
define
ds_OrderedHashTable_h
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
<
memory
>
#
include
<
tuple
>
#
include
<
utility
>
#
include
"
gc
/
Barrier
.
h
"
#
include
"
js
/
GCPolicyAPI
.
h
"
#
include
"
js
/
HashTable
.
h
"
class
JSTracer
;
namespace
js
{
namespace
detail
{
template
<
class
T
class
Ops
class
AllocPolicy
>
class
OrderedHashTable
{
public
:
using
Key
=
typename
Ops
:
:
KeyType
;
using
Lookup
=
typename
Ops
:
:
Lookup
;
using
HashCodeScrambler
=
mozilla
:
:
HashCodeScrambler
;
struct
Data
{
T
element
;
Data
*
chain
;
Data
(
const
T
&
e
Data
*
c
)
:
element
(
e
)
chain
(
c
)
{
}
Data
(
T
&
&
e
Data
*
c
)
:
element
(
std
:
:
move
(
e
)
)
chain
(
c
)
{
}
}
;
class
Range
;
friend
class
Range
;
private
:
Data
*
*
hashTable_
=
nullptr
;
Data
*
data_
=
nullptr
;
uint32_t
dataLength_
=
0
;
uint32_t
dataCapacity_
=
0
;
uint32_t
liveCount_
=
0
;
uint32_t
hashShift_
=
0
;
Range
*
ranges_
=
nullptr
;
Range
*
nurseryRanges_
=
nullptr
;
AllocPolicy
alloc_
;
const
HashCodeScrambler
*
hashCodeScrambler_
=
nullptr
;
static
constexpr
uint32_t
InitialBucketsLog2
=
1
;
static
constexpr
uint32_t
InitialBuckets
=
1
<
<
InitialBucketsLog2
;
static
constexpr
uint32_t
InitialHashShift
=
js
:
:
kHashNumberBits
-
InitialBucketsLog2
;
static
constexpr
double
FillFactor
=
8
.
0
/
3
.
0
;
static
constexpr
double
MinDataFill
=
0
.
25
;
template
<
typename
F
>
void
forEachRange
(
F
&
&
f
)
{
Range
*
next
;
for
(
Range
*
r
=
ranges_
;
r
;
r
=
next
)
{
next
=
r
-
>
next
;
f
(
r
)
;
}
for
(
Range
*
r
=
nurseryRanges_
;
r
;
r
=
next
)
{
next
=
r
-
>
next
;
f
(
r
)
;
}
}
static
MOZ_ALWAYS_INLINE
bool
calcAllocSize
(
uint32_t
dataCapacity
uint32_t
buckets
size_t
*
numBytes
)
{
using
CheckedSize
=
mozilla
:
:
CheckedInt
<
size_t
>
;
auto
res
=
CheckedSize
(
dataCapacity
)
*
sizeof
(
Data
)
+
CheckedSize
(
sizeof
(
HashCodeScrambler
)
)
+
CheckedSize
(
buckets
)
*
sizeof
(
Data
*
)
;
if
(
MOZ_UNLIKELY
(
!
res
.
isValid
(
)
)
)
{
return
false
;
}
*
numBytes
=
res
.
value
(
)
;
return
true
;
}
std
:
:
tuple
<
Data
*
Data
*
*
HashCodeScrambler
*
>
allocateBuffer
(
uint32_t
dataCapacity
uint32_t
buckets
)
{
size_t
numBytes
;
if
(
MOZ_UNLIKELY
(
!
calcAllocSize
(
dataCapacity
buckets
&
numBytes
)
)
)
{
alloc_
.
reportAllocOverflow
(
)
;
return
{
}
;
}
void
*
buf
=
alloc_
.
template
pod_malloc
<
uint8_t
>
(
numBytes
)
;
if
(
!
buf
)
{
return
{
}
;
}
static_assert
(
alignof
(
Data
)
%
alignof
(
HashCodeScrambler
)
=
=
0
"
Hash
code
scrambler
must
be
aligned
properly
"
)
;
static_assert
(
alignof
(
HashCodeScrambler
)
%
alignof
(
Data
*
)
=
=
0
"
Hash
table
entries
must
be
aligned
properly
"
)
;
auto
*
data
=
static_cast
<
Data
*
>
(
buf
)
;
auto
*
hcs
=
reinterpret_cast
<
HashCodeScrambler
*
>
(
data
+
dataCapacity
)
;
auto
*
*
table
=
reinterpret_cast
<
Data
*
*
>
(
hcs
+
1
)
;
MOZ_ASSERT
(
uintptr_t
(
table
+
buckets
)
=
=
uintptr_t
(
buf
)
+
numBytes
)
;
return
{
data
table
hcs
}
;
}
void
updateHashTableForRekey
(
Data
*
entry
HashNumber
oldHash
HashNumber
newHash
)
{
uint32_t
hashShift
=
hashShift_
;
oldHash
>
>
=
hashShift
;
newHash
>
>
=
hashShift
;
if
(
oldHash
=
=
newHash
)
{
return
;
}
Data
*
*
hashTable
=
hashTable_
;
Data
*
*
ep
=
&
hashTable
[
oldHash
]
;
while
(
*
ep
!
=
entry
)
{
ep
=
&
(
*
ep
)
-
>
chain
;
}
*
ep
=
entry
-
>
chain
;
ep
=
&
hashTable
[
newHash
]
;
while
(
*
ep
&
&
*
ep
>
entry
)
{
ep
=
&
(
*
ep
)
-
>
chain
;
}
entry
-
>
chain
=
*
ep
;
*
ep
=
entry
;
}
public
:
explicit
OrderedHashTable
(
AllocPolicy
ap
)
:
alloc_
(
std
:
:
move
(
ap
)
)
{
}
[
[
nodiscard
]
]
bool
init
(
const
HashCodeScrambler
&
hcs
)
{
MOZ_ASSERT
(
!
hashTable_
"
init
must
be
called
at
most
once
"
)
;
constexpr
uint32_t
buckets
=
InitialBuckets
;
constexpr
uint32_t
capacity
=
uint32_t
(
buckets
*
FillFactor
)
;
auto
[
dataAlloc
tableAlloc
hcsAlloc
]
=
allocateBuffer
(
capacity
buckets
)
;
if
(
!
dataAlloc
)
{
return
false
;
}
*
hcsAlloc
=
hcs
;
std
:
:
uninitialized_fill_n
(
tableAlloc
buckets
nullptr
)
;
hashTable_
=
tableAlloc
;
data_
=
dataAlloc
;
dataLength_
=
0
;
dataCapacity_
=
capacity
;
liveCount_
=
0
;
hashShift_
=
InitialHashShift
;
hashCodeScrambler_
=
hcsAlloc
;
MOZ_ASSERT
(
hashBuckets
(
)
=
=
buckets
)
;
return
true
;
}
~
OrderedHashTable
(
)
{
forEachRange
(
[
]
(
Range
*
range
)
{
range
-
>
onTableDestroyed
(
)
;
}
)
;
MOZ_ASSERT
(
!
!
data_
=
=
!
!
hashTable_
)
;
if
(
data_
)
{
freeData
(
data_
dataLength_
dataCapacity_
hashBuckets
(
)
)
;
}
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
size
=
0
;
if
(
data_
)
{
size
+
=
mallocSizeOf
(
data_
)
;
}
return
size
;
}
uint32_t
count
(
)
const
{
return
liveCount_
;
}
bool
has
(
const
Lookup
&
l
)
const
{
return
lookup
(
l
)
!
=
nullptr
;
}
T
*
get
(
const
Lookup
&
l
)
{
Data
*
e
=
lookup
(
l
prepareHash
(
l
)
)
;
return
e
?
&
e
-
>
element
:
nullptr
;
}
const
T
*
get
(
const
Lookup
&
l
)
const
{
return
const_cast
<
OrderedHashTable
*
>
(
this
)
-
>
get
(
l
)
;
}
template
<
typename
ElementInput
>
[
[
nodiscard
]
]
bool
put
(
ElementInput
&
&
element
)
{
HashNumber
h
=
prepareHash
(
Ops
:
:
getKey
(
element
)
)
;
if
(
Data
*
e
=
lookup
(
Ops
:
:
getKey
(
element
)
h
)
)
{
e
-
>
element
=
std
:
:
forward
<
ElementInput
>
(
element
)
;
return
true
;
}
if
(
dataLength_
=
=
dataCapacity_
&
&
!
rehashOnFull
(
)
)
{
return
false
;
}
auto
[
entry
chain
]
=
addEntry
(
h
)
;
new
(
entry
)
Data
(
std
:
:
forward
<
ElementInput
>
(
element
)
chain
)
;
return
true
;
}
bool
remove
(
const
Lookup
&
l
bool
*
foundp
)
{
Data
*
e
=
lookup
(
l
prepareHash
(
l
)
)
;
if
(
e
=
=
nullptr
)
{
*
foundp
=
false
;
return
true
;
}
*
foundp
=
true
;
return
remove
(
e
)
;
}
bool
remove
(
Data
*
e
)
{
MOZ_ASSERT
(
uint32_t
(
e
-
data_
)
<
dataCapacity_
)
;
liveCount_
-
-
;
Ops
:
:
makeEmpty
(
&
e
-
>
element
)
;
uint32_t
pos
=
e
-
data_
;
forEachRange
(
[
pos
]
(
Range
*
range
)
{
range
-
>
onRemove
(
pos
)
;
}
)
;
if
(
hashBuckets
(
)
>
InitialBuckets
&
&
liveCount_
<
dataLength_
*
MinDataFill
)
{
if
(
!
rehash
(
hashShift_
+
1
)
)
{
return
false
;
}
}
return
true
;
}
[
[
nodiscard
]
]
bool
clear
(
)
{
if
(
dataLength_
!
=
0
)
{
destroyData
(
data_
dataLength_
)
;
dataLength_
=
0
;
liveCount_
=
0
;
size_t
buckets
=
hashBuckets
(
)
;
std
:
:
fill_n
(
hashTable_
buckets
nullptr
)
;
forEachRange
(
[
]
(
Range
*
range
)
{
range
-
>
onClear
(
)
;
}
)
;
if
(
buckets
>
InitialBuckets
)
{
if
(
!
rehash
(
InitialHashShift
)
)
{
return
false
;
}
}
}
MOZ_ASSERT
(
hashTable_
)
;
MOZ_ASSERT
(
data_
)
;
MOZ_ASSERT
(
dataLength_
=
=
0
)
;
MOZ_ASSERT
(
liveCount_
=
=
0
)
;
return
true
;
}
class
Range
{
friend
class
OrderedHashTable
;
OrderedHashTable
*
ht
;
uint32_t
i
=
0
;
uint32_t
count
=
0
;
Range
*
*
prevp
;
Range
*
next
;
Range
(
OrderedHashTable
*
ht
Range
*
*
listp
)
:
ht
(
ht
)
prevp
(
listp
)
next
(
*
listp
)
{
*
prevp
=
this
;
if
(
next
)
{
next
-
>
prevp
=
&
next
;
}
seek
(
)
;
MOZ_ASSERT
(
valid
(
)
)
;
}
public
:
Range
(
const
Range
&
other
bool
inNursery
)
:
ht
(
other
.
ht
)
i
(
other
.
i
)
count
(
other
.
count
)
prevp
(
inNursery
?
&
ht
-
>
nurseryRanges_
:
&
ht
-
>
ranges_
)
next
(
*
prevp
)
{
*
prevp
=
this
;
if
(
next
)
{
next
-
>
prevp
=
&
next
;
}
MOZ_ASSERT
(
valid
(
)
)
;
}
~
Range
(
)
{
if
(
!
prevp
)
{
return
;
}
*
prevp
=
next
;
if
(
next
)
{
next
-
>
prevp
=
prevp
;
}
}
protected
:
Range
&
operator
=
(
const
Range
&
other
)
=
delete
;
void
seek
(
)
{
Data
*
data
=
ht
-
>
data_
;
uint32_t
dataLength
=
ht
-
>
dataLength_
;
while
(
i
<
dataLength
&
&
Ops
:
:
isEmpty
(
Ops
:
:
getKey
(
data
[
i
]
.
element
)
)
)
{
i
+
+
;
}
}
void
onRemove
(
uint32_t
j
)
{
MOZ_ASSERT
(
valid
(
)
)
;
if
(
j
<
i
)
{
count
-
-
;
}
if
(
j
=
=
i
)
{
seek
(
)
;
}
}
void
onCompact
(
)
{
MOZ_ASSERT
(
valid
(
)
)
;
i
=
count
;
}
void
onClear
(
)
{
MOZ_ASSERT
(
valid
(
)
)
;
i
=
count
=
0
;
}
#
ifdef
DEBUG
bool
valid
(
)
const
{
return
next
!
=
this
;
}
#
endif
void
onTableDestroyed
(
)
{
MOZ_ASSERT
(
valid
(
)
)
;
prevp
=
&
next
;
next
=
this
;
MOZ_ASSERT
(
!
valid
(
)
)
;
}
public
:
bool
empty
(
)
const
{
MOZ_ASSERT
(
valid
(
)
)
;
return
i
>
=
ht
-
>
dataLength_
;
}
const
T
&
front
(
)
const
{
MOZ_ASSERT
(
valid
(
)
)
;
MOZ_ASSERT
(
!
empty
(
)
)
;
return
ht
-
>
data_
[
i
]
.
element
;
}
void
popFront
(
)
{
MOZ_ASSERT
(
valid
(
)
)
;
MOZ_ASSERT
(
!
empty
(
)
)
;
MOZ_ASSERT
(
!
Ops
:
:
isEmpty
(
Ops
:
:
getKey
(
ht
-
>
data_
[
i
]
.
element
)
)
)
;
count
+
+
;
i
+
+
;
seek
(
)
;
}
static
size_t
offsetOfHashTable
(
)
{
return
offsetof
(
Range
ht
)
;
}
static
size_t
offsetOfI
(
)
{
return
offsetof
(
Range
i
)
;
}
static
size_t
offsetOfCount
(
)
{
return
offsetof
(
Range
count
)
;
}
static
size_t
offsetOfPrevP
(
)
{
return
offsetof
(
Range
prevp
)
;
}
static
size_t
offsetOfNext
(
)
{
return
offsetof
(
Range
next
)
;
}
}
;
Range
all
(
)
const
{
auto
*
self
=
const_cast
<
OrderedHashTable
*
>
(
this
)
;
return
Range
(
self
&
self
-
>
ranges_
)
;
}
void
trace
(
JSTracer
*
trc
)
{
Data
*
data
=
data_
;
uint32_t
dataLength
=
dataLength_
;
for
(
uint32_t
i
=
0
;
i
<
dataLength
;
i
+
+
)
{
if
(
!
Ops
:
:
isEmpty
(
Ops
:
:
getKey
(
data
[
i
]
.
element
)
)
)
{
Ops
:
:
trace
(
trc
this
i
data
[
i
]
.
element
)
;
}
}
}
template
<
typename
Key
>
void
traceKey
(
JSTracer
*
trc
uint32_t
index
Key
&
key
)
{
MOZ_ASSERT
(
index
<
dataLength_
)
;
using
MutableKey
=
std
:
:
remove_const_t
<
Key
>
;
using
UnbarrieredKey
=
typename
RemoveBarrier
<
MutableKey
>
:
:
Type
;
UnbarrieredKey
newKey
=
key
;
JS
:
:
GCPolicy
<
UnbarrieredKey
>
:
:
trace
(
trc
&
newKey
"
OrderedHashMap
key
"
)
;
if
(
newKey
!
=
key
)
{
rekey
(
&
data_
[
index
]
newKey
)
;
}
}
template
<
typename
Value
>
void
traceValue
(
JSTracer
*
trc
Value
&
value
)
{
JS
:
:
GCPolicy
<
Value
>
:
:
trace
(
trc
&
value
"
OrderedHashMap
value
"
)
;
}
Range
*
createRange
(
void
*
buffer
bool
inNursery
)
const
{
auto
*
self
=
const_cast
<
OrderedHashTable
*
>
(
this
)
;
Range
*
*
listp
=
inNursery
?
&
self
-
>
nurseryRanges_
:
&
self
-
>
ranges_
;
new
(
buffer
)
Range
(
self
listp
)
;
return
static_cast
<
Range
*
>
(
buffer
)
;
}
void
destroyNurseryRanges
(
)
{
if
(
nurseryRanges_
)
{
nurseryRanges_
-
>
prevp
=
nullptr
;
}
nurseryRanges_
=
nullptr
;
}
#
ifdef
DEBUG
bool
hasNurseryRanges
(
)
const
{
return
nurseryRanges_
;
}
#
endif
void
rekeyOneEntry
(
const
Key
&
current
const
Key
&
newKey
const
T
&
element
)
{
if
(
current
=
=
newKey
)
{
return
;
}
HashNumber
currentHash
=
prepareHash
(
current
)
;
HashNumber
newHash
=
prepareHash
(
newKey
)
;
Data
*
entry
=
lookup
(
current
currentHash
)
;
MOZ_ASSERT
(
entry
)
;
entry
-
>
element
=
element
;
updateHashTableForRekey
(
entry
currentHash
newHash
)
;
}
static
constexpr
size_t
offsetOfDataLength
(
)
{
return
offsetof
(
OrderedHashTable
dataLength_
)
;
}
static
constexpr
size_t
offsetOfData
(
)
{
return
offsetof
(
OrderedHashTable
data_
)
;
}
static
constexpr
size_t
offsetOfHashTable
(
)
{
return
offsetof
(
OrderedHashTable
hashTable_
)
;
}
static
constexpr
size_t
offsetOfHashShift
(
)
{
return
offsetof
(
OrderedHashTable
hashShift_
)
;
}
static
constexpr
size_t
offsetOfLiveCount
(
)
{
return
offsetof
(
OrderedHashTable
liveCount_
)
;
}
static
constexpr
size_t
offsetOfHashCodeScrambler
(
)
{
return
offsetof
(
OrderedHashTable
hashCodeScrambler_
)
;
}
static
constexpr
size_t
offsetOfDataElement
(
)
{
static_assert
(
offsetof
(
Data
element
)
=
=
0
"
RangeFront
and
RangePopFront
depend
on
offsetof
(
Data
"
"
element
)
being
0
"
)
;
return
offsetof
(
Data
element
)
;
}
static
constexpr
size_t
offsetOfDataChain
(
)
{
return
offsetof
(
Data
chain
)
;
}
static
constexpr
size_t
sizeofData
(
)
{
return
sizeof
(
Data
)
;
}
HashNumber
prepareHash
(
const
Lookup
&
l
)
const
{
const
HashCodeScrambler
&
hcs
=
*
hashCodeScrambler_
;
return
mozilla
:
:
ScrambleHashCode
(
Ops
:
:
hash
(
l
hcs
)
)
;
}
private
:
uint32_t
hashBuckets
(
)
const
{
return
1
<
<
(
js
:
:
kHashNumberBits
-
hashShift_
)
;
}
static
void
destroyData
(
Data
*
data
uint32_t
length
)
{
Data
*
end
=
data
+
length
;
for
(
Data
*
p
=
data
;
p
!
=
end
;
p
+
+
)
{
p
-
>
~
Data
(
)
;
}
}
void
freeData
(
Data
*
data
uint32_t
length
uint32_t
capacity
uint32_t
hashBuckets
)
{
MOZ_ASSERT
(
data
)
;
MOZ_ASSERT
(
capacity
>
0
)
;
destroyData
(
data
length
)
;
size_t
numBytes
;
MOZ_ALWAYS_TRUE
(
calcAllocSize
(
capacity
hashBuckets
&
numBytes
)
)
;
alloc_
.
free_
(
reinterpret_cast
<
uint8_t
*
>
(
data
)
numBytes
)
;
}
Data
*
lookup
(
const
Lookup
&
l
HashNumber
h
)
{
for
(
Data
*
e
=
hashTable_
[
h
>
>
hashShift_
]
;
e
;
e
=
e
-
>
chain
)
{
if
(
Ops
:
:
match
(
Ops
:
:
getKey
(
e
-
>
element
)
l
)
)
{
return
e
;
}
}
return
nullptr
;
}
const
Data
*
lookup
(
const
Lookup
&
l
)
const
{
return
const_cast
<
OrderedHashTable
*
>
(
this
)
-
>
lookup
(
l
prepareHash
(
l
)
)
;
}
std
:
:
tuple
<
Data
*
Data
*
>
addEntry
(
HashNumber
hash
)
{
uint32_t
dataLength
=
dataLength_
;
MOZ_ASSERT
(
dataLength
<
dataCapacity_
)
;
Data
*
entry
=
&
data_
[
dataLength
]
;
dataLength_
+
+
;
liveCount_
+
+
;
Data
*
*
hashTable
=
hashTable_
;
hash
>
>
=
hashShift_
;
Data
*
chain
=
hashTable
[
hash
]
;
hashTable
[
hash
]
=
entry
;
return
std
:
:
make_tuple
(
entry
chain
)
;
}
void
compacted
(
)
{
forEachRange
(
[
]
(
Range
*
range
)
{
range
-
>
onCompact
(
)
;
}
)
;
}
void
rehashInPlace
(
)
{
Data
*
*
hashTable
=
hashTable_
;
std
:
:
fill_n
(
hashTable
hashBuckets
(
)
nullptr
)
;
Data
*
const
data
=
data_
;
uint32_t
hashShift
=
hashShift_
;
Data
*
wp
=
data
;
Data
*
end
=
data
+
dataLength_
;
for
(
Data
*
rp
=
data
;
rp
!
=
end
;
rp
+
+
)
{
if
(
!
Ops
:
:
isEmpty
(
Ops
:
:
getKey
(
rp
-
>
element
)
)
)
{
HashNumber
h
=
prepareHash
(
Ops
:
:
getKey
(
rp
-
>
element
)
)
>
>
hashShift
;
if
(
rp
!
=
wp
)
{
wp
-
>
element
=
std
:
:
move
(
rp
-
>
element
)
;
}
wp
-
>
chain
=
hashTable
[
h
]
;
hashTable
[
h
]
=
wp
;
wp
+
+
;
}
}
MOZ_ASSERT
(
wp
=
=
data
+
liveCount_
)
;
while
(
wp
!
=
end
)
{
wp
-
>
~
Data
(
)
;
wp
+
+
;
}
dataLength_
=
liveCount_
;
compacted
(
)
;
}
[
[
nodiscard
]
]
bool
rehashOnFull
(
)
{
MOZ_ASSERT
(
dataLength_
=
=
dataCapacity_
)
;
uint32_t
newHashShift
=
liveCount_
>
=
dataCapacity_
*
0
.
75
?
hashShift_
-
1
:
hashShift_
;
return
rehash
(
newHashShift
)
;
}
[
[
nodiscard
]
]
bool
rehash
(
uint32_t
newHashShift
)
{
if
(
newHashShift
=
=
hashShift_
)
{
rehashInPlace
(
)
;
return
true
;
}
constexpr
size_t
maxCapacityLog2
=
mozilla
:
:
tl
:
:
FloorLog2
<
size_t
(
INT32_MAX
/
FillFactor
)
>
:
:
value
;
static_assert
(
maxCapacityLog2
<
kHashNumberBits
)
;
if
(
MOZ_UNLIKELY
(
newHashShift
<
(
js
:
:
kHashNumberBits
-
maxCapacityLog2
)
)
)
{
alloc_
.
reportAllocOverflow
(
)
;
return
false
;
}
uint32_t
newHashBuckets
=
uint32_t
(
1
)
<
<
(
js
:
:
kHashNumberBits
-
newHashShift
)
;
uint32_t
newCapacity
=
uint32_t
(
newHashBuckets
*
FillFactor
)
;
auto
[
newData
newHashTable
newHcs
]
=
allocateBuffer
(
newCapacity
newHashBuckets
)
;
if
(
!
newData
)
{
return
false
;
}
*
newHcs
=
*
hashCodeScrambler_
;
std
:
:
uninitialized_fill_n
(
newHashTable
newHashBuckets
nullptr
)
;
Data
*
const
oldData
=
data_
;
const
uint32_t
oldDataLength
=
dataLength_
;
Data
*
wp
=
newData
;
Data
*
end
=
oldData
+
oldDataLength
;
for
(
Data
*
p
=
oldData
;
p
!
=
end
;
p
+
+
)
{
if
(
!
Ops
:
:
isEmpty
(
Ops
:
:
getKey
(
p
-
>
element
)
)
)
{
HashNumber
h
=
prepareHash
(
Ops
:
:
getKey
(
p
-
>
element
)
)
>
>
newHashShift
;
new
(
wp
)
Data
(
std
:
:
move
(
p
-
>
element
)
newHashTable
[
h
]
)
;
newHashTable
[
h
]
=
wp
;
wp
+
+
;
}
}
MOZ_ASSERT
(
wp
=
=
newData
+
liveCount_
)
;
freeData
(
oldData
oldDataLength
dataCapacity_
hashBuckets
(
)
)
;
hashTable_
=
newHashTable
;
data_
=
newData
;
dataLength_
=
liveCount_
;
dataCapacity_
=
newCapacity
;
hashShift_
=
newHashShift
;
hashCodeScrambler_
=
newHcs
;
MOZ_ASSERT
(
hashBuckets
(
)
=
=
newHashBuckets
)
;
compacted
(
)
;
return
true
;
}
void
rekey
(
Data
*
entry
const
Key
&
k
)
{
HashNumber
oldHash
=
prepareHash
(
Ops
:
:
getKey
(
entry
-
>
element
)
)
;
HashNumber
newHash
=
prepareHash
(
k
)
;
Ops
:
:
setKey
(
entry
-
>
element
k
)
;
updateHashTableForRekey
(
entry
oldHash
newHash
)
;
}
OrderedHashTable
&
operator
=
(
const
OrderedHashTable
&
)
=
delete
;
OrderedHashTable
(
const
OrderedHashTable
&
)
=
delete
;
}
;
}
template
<
class
Key
class
Value
class
OrderedHashPolicy
class
AllocPolicy
>
class
OrderedHashMap
{
public
:
class
Entry
{
template
<
class
class
class
>
friend
class
detail
:
:
OrderedHashTable
;
void
operator
=
(
const
Entry
&
rhs
)
{
const_cast
<
Key
&
>
(
key
)
=
rhs
.
key
;
value
=
rhs
.
value
;
}
void
operator
=
(
Entry
&
&
rhs
)
{
MOZ_ASSERT
(
this
!
=
&
rhs
"
self
-
move
assignment
is
prohibited
"
)
;
const_cast
<
Key
&
>
(
key
)
=
std
:
:
move
(
rhs
.
key
)
;
value
=
std
:
:
move
(
rhs
.
value
)
;
}
public
:
Entry
(
)
=
default
;
explicit
Entry
(
const
Key
&
k
)
:
key
(
k
)
{
}
template
<
typename
V
>
Entry
(
const
Key
&
k
V
&
&
v
)
:
key
(
k
)
value
(
std
:
:
forward
<
V
>
(
v
)
)
{
}
Entry
(
Entry
&
&
rhs
)
:
key
(
std
:
:
move
(
rhs
.
key
)
)
value
(
std
:
:
move
(
rhs
.
value
)
)
{
}
const
Key
key
{
}
;
Value
value
{
}
;
static
constexpr
size_t
offsetOfKey
(
)
{
return
offsetof
(
Entry
key
)
;
}
static
constexpr
size_t
offsetOfValue
(
)
{
return
offsetof
(
Entry
value
)
;
}
}
;
private
:
struct
MapOps
;
using
Impl
=
detail
:
:
OrderedHashTable
<
Entry
MapOps
AllocPolicy
>
;
struct
MapOps
:
OrderedHashPolicy
{
using
KeyType
=
Key
;
static
void
makeEmpty
(
Entry
*
e
)
{
OrderedHashPolicy
:
:
makeEmpty
(
const_cast
<
Key
*
>
(
&
e
-
>
key
)
)
;
e
-
>
value
=
Value
(
)
;
}
static
const
Key
&
getKey
(
const
Entry
&
e
)
{
return
e
.
key
;
}
static
void
setKey
(
Entry
&
e
const
Key
&
k
)
{
const_cast
<
Key
&
>
(
e
.
key
)
=
k
;
}
static
void
trace
(
JSTracer
*
trc
Impl
*
table
uint32_t
index
Entry
&
entry
)
{
table
-
>
traceKey
(
trc
index
entry
.
key
)
;
table
-
>
traceValue
(
trc
entry
.
value
)
;
}
}
;
Impl
impl
;
public
:
using
Lookup
=
typename
Impl
:
:
Lookup
;
using
Range
=
typename
Impl
:
:
Range
;
explicit
OrderedHashMap
(
AllocPolicy
ap
)
:
impl
(
std
:
:
move
(
ap
)
)
{
}
[
[
nodiscard
]
]
bool
init
(
const
mozilla
:
:
HashCodeScrambler
&
hcs
)
{
return
impl
.
init
(
hcs
)
;
}
uint32_t
count
(
)
const
{
return
impl
.
count
(
)
;
}
bool
has
(
const
Lookup
&
key
)
const
{
return
impl
.
has
(
key
)
;
}
Range
all
(
)
const
{
return
impl
.
all
(
)
;
}
const
Entry
*
get
(
const
Lookup
&
key
)
const
{
return
impl
.
get
(
key
)
;
}
Entry
*
get
(
const
Lookup
&
key
)
{
return
impl
.
get
(
key
)
;
}
bool
remove
(
const
Lookup
&
key
bool
*
foundp
)
{
return
impl
.
remove
(
key
foundp
)
;
}
bool
remove
(
Entry
*
entry
)
{
static_assert
(
offsetof
(
typename
Impl
:
:
Data
element
)
=
=
0
)
;
auto
*
data
=
reinterpret_cast
<
typename
Impl
:
:
Data
*
>
(
entry
)
;
return
impl
.
remove
(
data
)
;
}
[
[
nodiscard
]
]
bool
clear
(
)
{
return
impl
.
clear
(
)
;
}
template
<
typename
K
typename
V
>
[
[
nodiscard
]
]
bool
put
(
K
&
&
key
V
&
&
value
)
{
return
impl
.
put
(
Entry
(
std
:
:
forward
<
K
>
(
key
)
std
:
:
forward
<
V
>
(
value
)
)
)
;
}
HashNumber
hash
(
const
Lookup
&
key
)
const
{
return
impl
.
prepareHash
(
key
)
;
}
template
<
typename
GetNewKey
>
mozilla
:
:
Maybe
<
Key
>
rekeyOneEntry
(
Lookup
&
current
GetNewKey
&
&
getNewKey
)
{
const
Entry
*
e
=
get
(
current
)
;
if
(
!
e
)
{
return
mozilla
:
:
Nothing
(
)
;
}
Key
newKey
=
getNewKey
(
current
)
;
impl
.
rekeyOneEntry
(
current
newKey
Entry
(
newKey
e
-
>
value
)
)
;
return
mozilla
:
:
Some
(
newKey
)
;
}
Range
*
createRange
(
void
*
buffer
bool
inNursery
)
const
{
return
impl
.
createRange
(
buffer
inNursery
)
;
}
void
destroyNurseryRanges
(
)
{
impl
.
destroyNurseryRanges
(
)
;
}
#
ifdef
DEBUG
bool
hasNurseryRanges
(
)
const
{
return
impl
.
hasNurseryRanges
(
)
;
}
#
endif
void
trace
(
JSTracer
*
trc
)
{
impl
.
trace
(
trc
)
;
}
static
constexpr
size_t
offsetOfEntryKey
(
)
{
return
Entry
:
:
offsetOfKey
(
)
;
}
static
constexpr
size_t
offsetOfImplDataLength
(
)
{
return
Impl
:
:
offsetOfDataLength
(
)
;
}
static
constexpr
size_t
offsetOfImplData
(
)
{
return
Impl
:
:
offsetOfData
(
)
;
}
static
constexpr
size_t
offsetOfImplHashTable
(
)
{
return
Impl
:
:
offsetOfHashTable
(
)
;
}
static
constexpr
size_t
offsetOfImplHashShift
(
)
{
return
Impl
:
:
offsetOfHashShift
(
)
;
}
static
constexpr
size_t
offsetOfImplLiveCount
(
)
{
return
Impl
:
:
offsetOfLiveCount
(
)
;
}
static
constexpr
size_t
offsetOfImplHashCodeScrambler
(
)
{
return
Impl
:
:
offsetOfHashCodeScrambler
(
)
;
}
static
constexpr
size_t
offsetOfImplDataElement
(
)
{
return
Impl
:
:
offsetOfDataElement
(
)
;
}
static
constexpr
size_t
offsetOfImplDataChain
(
)
{
return
Impl
:
:
offsetOfDataChain
(
)
;
}
static
constexpr
size_t
sizeofImplData
(
)
{
return
Impl
:
:
sizeofData
(
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
impl
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
template
<
class
T
class
OrderedHashPolicy
class
AllocPolicy
>
class
OrderedHashSet
{
private
:
struct
SetOps
;
using
Impl
=
detail
:
:
OrderedHashTable
<
T
SetOps
AllocPolicy
>
;
struct
SetOps
:
OrderedHashPolicy
{
using
KeyType
=
const
T
;
static
const
T
&
getKey
(
const
T
&
v
)
{
return
v
;
}
static
void
setKey
(
const
T
&
e
const
T
&
v
)
{
const_cast
<
T
&
>
(
e
)
=
v
;
}
static
void
trace
(
JSTracer
*
trc
Impl
*
table
uint32_t
index
T
&
entry
)
{
table
-
>
traceKey
(
trc
index
entry
)
;
}
}
;
Impl
impl
;
public
:
using
Lookup
=
typename
Impl
:
:
Lookup
;
using
Range
=
typename
Impl
:
:
Range
;
explicit
OrderedHashSet
(
AllocPolicy
ap
)
:
impl
(
std
:
:
move
(
ap
)
)
{
}
[
[
nodiscard
]
]
bool
init
(
const
mozilla
:
:
HashCodeScrambler
&
hcs
)
{
return
impl
.
init
(
hcs
)
;
}
uint32_t
count
(
)
const
{
return
impl
.
count
(
)
;
}
bool
has
(
const
Lookup
&
value
)
const
{
return
impl
.
has
(
value
)
;
}
Range
all
(
)
const
{
return
impl
.
all
(
)
;
}
template
<
typename
Input
>
[
[
nodiscard
]
]
bool
put
(
Input
&
&
value
)
{
return
impl
.
put
(
std
:
:
forward
<
Input
>
(
value
)
)
;
}
bool
remove
(
const
Lookup
&
value
bool
*
foundp
)
{
return
impl
.
remove
(
value
foundp
)
;
}
[
[
nodiscard
]
]
bool
clear
(
)
{
return
impl
.
clear
(
)
;
}
HashNumber
hash
(
const
Lookup
&
value
)
const
{
return
impl
.
prepareHash
(
value
)
;
}
template
<
typename
GetNewKey
>
mozilla
:
:
Maybe
<
T
>
rekeyOneEntry
(
Lookup
&
current
GetNewKey
&
&
getNewKey
)
{
if
(
!
has
(
current
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
T
newKey
=
getNewKey
(
current
)
;
impl
.
rekeyOneEntry
(
current
newKey
newKey
)
;
return
mozilla
:
:
Some
(
newKey
)
;
}
Range
*
createRange
(
void
*
buffer
bool
inNursery
)
const
{
return
impl
.
createRange
(
buffer
inNursery
)
;
}
void
destroyNurseryRanges
(
)
{
impl
.
destroyNurseryRanges
(
)
;
}
#
ifdef
DEBUG
bool
hasNurseryRanges
(
)
const
{
return
impl
.
hasNurseryRanges
(
)
;
}
#
endif
void
trace
(
JSTracer
*
trc
)
{
impl
.
trace
(
trc
)
;
}
static
constexpr
size_t
offsetOfEntryKey
(
)
{
return
0
;
}
static
constexpr
size_t
offsetOfImplDataLength
(
)
{
return
Impl
:
:
offsetOfDataLength
(
)
;
}
static
constexpr
size_t
offsetOfImplData
(
)
{
return
Impl
:
:
offsetOfData
(
)
;
}
static
constexpr
size_t
offsetOfImplHashTable
(
)
{
return
Impl
:
:
offsetOfHashTable
(
)
;
}
static
constexpr
size_t
offsetOfImplHashShift
(
)
{
return
Impl
:
:
offsetOfHashShift
(
)
;
}
static
constexpr
size_t
offsetOfImplLiveCount
(
)
{
return
Impl
:
:
offsetOfLiveCount
(
)
;
}
static
constexpr
size_t
offsetOfImplHashCodeScrambler
(
)
{
return
Impl
:
:
offsetOfHashCodeScrambler
(
)
;
}
static
constexpr
size_t
offsetOfImplDataElement
(
)
{
return
Impl
:
:
offsetOfDataElement
(
)
;
}
static
constexpr
size_t
offsetOfImplDataChain
(
)
{
return
Impl
:
:
offsetOfDataChain
(
)
;
}
static
constexpr
size_t
sizeofImplData
(
)
{
return
Impl
:
:
sizeofData
(
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
impl
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
}
#
endif
