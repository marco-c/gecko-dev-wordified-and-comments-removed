#
ifndef
ds_SlimLinkedList_h
#
define
ds_SlimLinkedList_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
namespace
js
{
template
<
typename
T
>
class
SlimLinkedListElement
;
template
<
typename
T
>
class
SlimLinkedList
;
template
<
typename
T
>
class
SlimLinkedListElement
{
using
ElementPtr
=
T
*
;
using
ConstElementPtr
=
const
T
*
;
static
constexpr
uintptr_t
EndTag
=
1
;
uintptr_t
next_
=
0
;
uintptr_t
prev_
=
0
;
friend
class
js
:
:
SlimLinkedList
<
T
>
;
static
uintptr_t
UntaggedPtr
(
ElementPtr
ptr
)
{
MOZ_ASSERT
(
(
uintptr_t
(
ptr
)
&
EndTag
)
=
=
0
)
;
return
uintptr_t
(
ptr
)
;
}
static
uintptr_t
GetTag
(
uintptr_t
taggedPtr
)
{
return
taggedPtr
&
EndTag
;
}
static
ElementPtr
GetPtr
(
uintptr_t
taggedPtr
)
{
return
reinterpret_cast
<
ElementPtr
>
(
uintptr_t
(
taggedPtr
)
&
~
EndTag
)
;
}
static
ConstElementPtr
GetConstPtr
(
uintptr_t
taggedPtr
)
{
return
reinterpret_cast
<
ConstElementPtr
>
(
uintptr_t
(
taggedPtr
)
&
~
EndTag
)
;
}
static
void
LinkElements
(
ElementPtr
a
ElementPtr
b
uintptr_t
maybeTag
=
0
)
{
MOZ_ASSERT
(
(
maybeTag
&
~
EndTag
)
=
=
0
)
;
a
-
>
next_
=
UntaggedPtr
(
b
)
|
maybeTag
;
b
-
>
prev_
=
UntaggedPtr
(
a
)
|
maybeTag
;
}
public
:
SlimLinkedListElement
(
)
=
default
;
~
SlimLinkedListElement
(
)
{
MOZ_ASSERT
(
!
isInList
(
)
)
;
}
SlimLinkedListElement
(
const
SlimLinkedListElement
<
T
>
&
other
)
=
delete
;
SlimLinkedListElement
&
operator
=
(
const
SlimLinkedListElement
<
T
>
&
other
)
=
delete
;
SlimLinkedListElement
(
SlimLinkedListElement
<
T
>
&
&
other
)
{
MOZ_ASSERT
(
this
!
=
&
other
)
;
MOZ_ASSERT
(
!
isInList
(
)
)
;
MOZ_ASSERT
(
!
other
.
isInList
(
)
)
;
}
SlimLinkedListElement
&
operator
=
(
SlimLinkedListElement
<
T
>
&
&
other
)
{
MOZ_ASSERT
(
this
!
=
&
other
)
;
MOZ_ASSERT
(
!
isInList
(
)
)
;
MOZ_ASSERT
(
!
other
.
isInList
(
)
)
;
return
*
this
;
}
bool
isInList
(
)
const
{
MOZ_ASSERT
(
bool
(
next_
)
=
=
bool
(
prev_
)
)
;
return
next_
;
}
bool
isLast
(
)
const
{
MOZ_ASSERT
(
isInList
(
)
)
;
return
GetTag
(
next_
)
;
}
bool
isFirst
(
)
const
{
MOZ_ASSERT
(
isInList
(
)
)
;
return
GetTag
(
prev_
)
;
}
ElementPtr
getNext
(
)
{
return
isLast
(
)
?
nullptr
:
getNextUnchecked
(
)
;
}
ConstElementPtr
getNext
(
)
const
{
return
isLast
(
)
?
nullptr
:
getNextUnchecked
(
)
;
}
ElementPtr
getPrev
(
)
{
return
isFirst
(
)
?
nullptr
:
getPrevUnchecked
(
)
;
}
ConstElementPtr
getPrev
(
)
const
{
return
isFirst
(
)
?
nullptr
:
getPrevUnchecked
(
)
;
}
private
:
ElementPtr
getNextUnchecked
(
)
{
return
GetPtr
(
next_
)
;
}
ConstElementPtr
getNextUnchecked
(
)
const
{
return
GetConstPtr
(
next_
)
;
}
;
ElementPtr
getPrevUnchecked
(
)
{
return
GetPtr
(
prev_
)
;
}
ConstElementPtr
getPrevUnchecked
(
)
const
{
return
GetConstPtr
(
prev_
)
;
}
;
ElementPtr
thisElement
(
)
{
return
static_cast
<
ElementPtr
>
(
this
)
;
}
void
makeSingleton
(
)
{
MOZ_ASSERT
(
!
isInList
(
)
)
;
LinkElements
(
thisElement
(
)
thisElement
(
)
EndTag
)
;
}
void
insertAfter
(
ElementPtr
newElement
)
{
insertListAfter
(
newElement
newElement
)
;
}
void
insertListAfter
(
ElementPtr
listFirst
ElementPtr
listLast
)
{
MOZ_ASSERT
(
isInList
(
)
)
;
MOZ_ASSERT_IF
(
listFirst
!
=
listLast
listFirst
-
>
getPrevUnchecked
(
)
=
=
listLast
)
;
MOZ_ASSERT_IF
(
listFirst
!
=
listLast
listLast
-
>
getNextUnchecked
(
)
=
=
listFirst
)
;
ElementPtr
next
=
GetPtr
(
next_
)
;
uintptr_t
tag
=
GetTag
(
next_
)
;
LinkElements
(
thisElement
(
)
listFirst
)
;
LinkElements
(
listLast
next
tag
)
;
}
void
insertBefore
(
ElementPtr
newElement
)
{
insertListBefore
(
newElement
newElement
)
;
}
void
insertListBefore
(
ElementPtr
listFirst
ElementPtr
listLast
)
{
MOZ_ASSERT
(
isInList
(
)
)
;
MOZ_ASSERT_IF
(
listFirst
!
=
listLast
listFirst
-
>
getPrevUnchecked
(
)
=
=
listLast
)
;
MOZ_ASSERT_IF
(
listFirst
!
=
listLast
listLast
-
>
getNextUnchecked
(
)
=
=
listFirst
)
;
ElementPtr
prev
=
GetPtr
(
prev_
)
;
uintptr_t
tag
=
GetTag
(
prev_
)
;
LinkElements
(
prev
listFirst
tag
)
;
LinkElements
(
listLast
thisElement
(
)
)
;
}
void
remove
(
)
{
MOZ_ASSERT
(
isInList
(
)
)
;
ElementPtr
prev
=
GetPtr
(
prev_
)
;
ElementPtr
next
=
GetPtr
(
next_
)
;
uintptr_t
tag
=
GetTag
(
prev_
)
|
GetTag
(
next_
)
;
LinkElements
(
prev
next
tag
)
;
next_
=
0
;
prev_
=
0
;
}
}
;
template
<
typename
T
>
class
SlimLinkedList
{
using
ElementPtr
=
T
*
;
using
ConstElementPtr
=
const
T
*
;
ElementPtr
first_
=
nullptr
;
public
:
template
<
typename
Type
>
class
Iterator
{
Type
current_
;
public
:
using
iterator_category
=
std
:
:
forward_iterator_tag
;
using
value_type
=
T
;
using
difference_type
=
std
:
:
ptrdiff_t
;
using
pointer
=
T
*
;
using
reference
=
T
&
;
explicit
Iterator
(
Type
current
)
:
current_
(
current
)
{
}
Type
operator
*
(
)
const
{
return
current_
;
}
const
Iterator
&
operator
+
+
(
)
{
current_
=
current_
-
>
getNext
(
)
;
return
*
this
;
}
bool
operator
=
=
(
const
Iterator
&
other
)
const
{
return
current_
=
=
other
.
current_
;
}
bool
operator
!
=
(
const
Iterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
}
;
SlimLinkedList
(
)
=
default
;
SlimLinkedList
(
const
SlimLinkedList
<
T
>
&
other
)
=
delete
;
SlimLinkedList
&
operator
=
(
const
SlimLinkedList
<
T
>
&
other
)
=
delete
;
SlimLinkedList
(
SlimLinkedList
<
T
>
&
&
other
)
{
MOZ_ASSERT
(
this
!
=
&
other
)
;
MOZ_ASSERT
(
isEmpty
(
)
)
;
std
:
:
swap
(
first_
other
.
first_
)
;
}
SlimLinkedList
&
operator
=
(
SlimLinkedList
<
T
>
&
&
other
)
{
MOZ_ASSERT
(
this
!
=
&
other
)
;
MOZ_ASSERT
(
isEmpty
(
)
)
;
std
:
:
swap
(
first_
other
.
first_
)
;
return
*
this
;
}
~
SlimLinkedList
(
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
}
void
pushFront
(
ElementPtr
newElement
)
{
if
(
isEmpty
(
)
)
{
newElement
-
>
makeSingleton
(
)
;
}
else
{
first_
-
>
insertBefore
(
newElement
)
;
}
first_
=
newElement
;
}
void
pushBack
(
ElementPtr
newElement
)
{
if
(
isEmpty
(
)
)
{
newElement
-
>
makeSingleton
(
)
;
first_
=
newElement
;
return
;
}
getLast
(
)
-
>
insertAfter
(
newElement
)
;
}
void
append
(
SlimLinkedList
<
T
>
&
&
other
)
{
MOZ_ASSERT
(
this
!
=
&
other
)
;
if
(
other
.
isEmpty
(
)
)
{
return
;
}
if
(
isEmpty
(
)
)
{
*
this
=
std
:
:
move
(
other
)
;
return
;
}
getLast
(
)
-
>
insertListAfter
(
other
.
getFirst
(
)
other
.
getLast
(
)
)
;
other
.
first_
=
nullptr
;
}
void
prepend
(
SlimLinkedList
<
T
>
&
&
other
)
{
MOZ_ASSERT
(
this
!
=
&
other
)
;
if
(
other
.
isEmpty
(
)
)
{
return
;
}
if
(
isEmpty
(
)
)
{
*
this
=
std
:
:
move
(
other
)
;
return
;
}
getFirst
(
)
-
>
insertListBefore
(
other
.
getFirst
(
)
other
.
getLast
(
)
)
;
first_
=
other
.
first_
;
other
.
first_
=
nullptr
;
}
ElementPtr
getFirst
(
)
{
return
first_
;
}
ConstElementPtr
getFirst
(
)
const
{
return
first_
;
}
ElementPtr
getLast
(
)
{
return
isEmpty
(
)
?
nullptr
:
first_
-
>
getPrevUnchecked
(
)
;
}
ConstElementPtr
getLast
(
)
const
{
return
isEmpty
(
)
?
nullptr
:
first_
-
>
getPrevUnchecked
(
)
;
}
ElementPtr
popFirst
(
)
{
if
(
isEmpty
(
)
)
{
return
nullptr
;
}
ElementPtr
result
=
first_
;
first_
=
result
-
>
getNext
(
)
;
result
-
>
remove
(
)
;
return
result
;
}
ElementPtr
popLast
(
)
{
if
(
isEmpty
(
)
)
{
return
nullptr
;
}
ElementPtr
result
=
getLast
(
)
;
if
(
result
=
=
first_
)
{
first_
=
nullptr
;
}
result
-
>
remove
(
)
;
return
result
;
}
bool
isEmpty
(
)
const
{
return
!
first_
;
}
bool
contains
(
ConstElementPtr
aElm
)
const
{
return
std
:
:
find
(
begin
(
)
end
(
)
aElm
)
!
=
end
(
)
;
}
void
remove
(
ElementPtr
element
)
{
checkContains
(
element
)
;
if
(
element
=
=
first_
)
{
first_
=
element
-
>
getNext
(
)
;
}
element
-
>
remove
(
)
;
}
void
checkContains
(
ElementPtr
element
)
{
#
ifdef
DEBUG
size_t
i
=
0
;
for
(
const
auto
&
e
:
*
this
)
{
if
(
e
=
=
element
)
{
return
;
}
if
(
i
=
=
100
)
{
return
;
}
}
MOZ_CRASH
(
"
Element
not
found
"
)
;
#
endif
}
void
clear
(
)
{
while
(
popFirst
(
)
)
{
}
}
template
<
typename
F
>
void
drain
(
F
&
&
func
)
{
while
(
ElementPtr
element
=
popFirst
(
)
)
{
func
(
element
)
;
}
}
size_t
length
(
)
const
{
return
std
:
:
distance
(
begin
(
)
end
(
)
)
;
}
Iterator
<
ElementPtr
>
begin
(
)
{
return
Iterator
<
ElementPtr
>
(
getFirst
(
)
)
;
}
Iterator
<
ConstElementPtr
>
begin
(
)
const
{
return
Iterator
<
ConstElementPtr
>
(
getFirst
(
)
)
;
}
Iterator
<
ElementPtr
>
end
(
)
{
return
Iterator
<
ElementPtr
>
(
nullptr
)
;
}
Iterator
<
ConstElementPtr
>
end
(
)
const
{
return
Iterator
<
ConstElementPtr
>
(
nullptr
)
;
}
}
;
}
#
endif
