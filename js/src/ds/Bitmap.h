#
ifndef
ds_Bitmap_h
#
define
ds_Bitmap_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
<
algorithm
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
Vector
.
h
"
namespace
js
{
class
DenseBitmap
{
using
Data
=
Vector
<
uintptr_t
0
SystemAllocPolicy
>
;
Data
data
;
public
:
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
data
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
bool
ensureSpace
(
size_t
numWords
)
{
MOZ_ASSERT
(
data
.
empty
(
)
)
;
return
data
.
appendN
(
0
numWords
)
;
}
size_t
numWords
(
)
const
{
return
data
.
length
(
)
;
}
uintptr_t
word
(
size_t
i
)
const
{
return
data
[
i
]
;
}
uintptr_t
&
word
(
size_t
i
)
{
return
data
[
i
]
;
}
void
copyBitsFrom
(
size_t
wordStart
size_t
numWords
uintptr_t
*
source
)
{
MOZ_ASSERT
(
wordStart
+
numWords
<
=
data
.
length
(
)
)
;
mozilla
:
:
PodCopy
(
&
data
[
wordStart
]
source
numWords
)
;
}
void
bitwiseOrRangeInto
(
size_t
wordStart
size_t
numWords
uintptr_t
*
target
)
const
{
for
(
size_t
i
=
0
;
i
<
numWords
;
i
+
+
)
target
[
i
]
|
=
data
[
wordStart
+
i
]
;
}
}
;
class
SparseBitmap
{
static
const
size_t
WordsInBlock
=
4096
/
sizeof
(
uintptr_t
)
;
using
BitBlock
=
mozilla
:
:
Array
<
uintptr_t
WordsInBlock
>
;
using
Data
=
HashMap
<
size_t
BitBlock
*
DefaultHasher
<
size_t
>
SystemAllocPolicy
>
;
Data
data
;
static
size_t
blockStartWord
(
size_t
word
)
{
return
word
&
~
(
WordsInBlock
-
1
)
;
}
static
size_t
wordIntersectCount
(
size_t
blockWord
const
DenseBitmap
&
other
)
{
long
count
=
other
.
numWords
(
)
-
blockWord
;
return
std
:
:
min
<
size_t
>
(
(
size_t
)
WordsInBlock
std
:
:
max
<
long
>
(
count
0
)
)
;
}
BitBlock
&
createBlock
(
Data
:
:
AddPtr
p
size_t
blockId
)
;
MOZ_ALWAYS_INLINE
BitBlock
*
getBlock
(
size_t
blockId
)
const
{
Data
:
:
Ptr
p
=
data
.
lookup
(
blockId
)
;
return
p
?
p
-
>
value
(
)
:
nullptr
;
}
MOZ_ALWAYS_INLINE
BitBlock
&
getOrCreateBlock
(
size_t
blockId
)
{
Data
:
:
AddPtr
p
=
data
.
lookupForAdd
(
blockId
)
;
if
(
p
)
return
*
p
-
>
value
(
)
;
return
createBlock
(
p
blockId
)
;
}
public
:
bool
init
(
)
{
return
data
.
init
(
)
;
}
~
SparseBitmap
(
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
MOZ_ALWAYS_INLINE
void
setBit
(
size_t
bit
)
{
size_t
word
=
bit
/
JS_BITS_PER_WORD
;
size_t
blockWord
=
blockStartWord
(
word
)
;
BitBlock
&
block
=
getOrCreateBlock
(
blockWord
/
WordsInBlock
)
;
block
[
word
-
blockWord
]
|
=
uintptr_t
(
1
)
<
<
(
bit
%
JS_BITS_PER_WORD
)
;
}
bool
getBit
(
size_t
bit
)
const
;
void
bitwiseAndWith
(
const
DenseBitmap
&
other
)
;
void
bitwiseOrWith
(
const
SparseBitmap
&
other
)
;
void
bitwiseOrInto
(
DenseBitmap
&
other
)
const
;
void
bitwiseOrRangeInto
(
size_t
wordStart
size_t
numWords
uintptr_t
*
target
)
const
;
}
;
}
#
endif
