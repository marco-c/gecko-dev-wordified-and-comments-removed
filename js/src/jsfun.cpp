#
include
"
jsfuninlines
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
<
string
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
jsarray
.
h
"
#
include
"
jsatom
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jsobj
.
h
"
#
include
"
jsscript
.
h
"
#
include
"
jsstr
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
jswrapper
.
h
"
#
include
"
builtin
/
Eval
.
h
"
#
include
"
builtin
/
Object
.
h
"
#
include
"
builtin
/
SelfHostingDefines
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
frontend
/
TokenStream
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
jit
/
InlinableNatives
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
jit
/
JitFrameIterator
.
h
"
#
include
"
js
/
CallNonGenericMethod
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
vm
/
Debugger
.
h
"
#
include
"
vm
/
GlobalObject
.
h
"
#
include
"
vm
/
Interpreter
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
SharedImmutableStringsCache
.
h
"
#
include
"
vm
/
StringBuffer
.
h
"
#
include
"
vm
/
WrapperObject
.
h
"
#
include
"
vm
/
Xdr
.
h
"
#
include
"
jsscriptinlines
.
h
"
#
include
"
vm
/
Interpreter
-
inl
.
h
"
#
include
"
vm
/
Stack
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
namespace
js
:
:
frontend
;
using
mozilla
:
:
ArrayLength
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
RangedPtr
;
static
bool
fun_enumerate
(
JSContext
*
cx
HandleObject
obj
)
{
MOZ_ASSERT
(
obj
-
>
is
<
JSFunction
>
(
)
)
;
RootedId
id
(
cx
)
;
bool
found
;
if
(
!
obj
-
>
isBoundFunction
(
)
&
&
!
obj
-
>
as
<
JSFunction
>
(
)
.
isArrow
(
)
)
{
id
=
NameToId
(
cx
-
>
names
(
)
.
prototype
)
;
if
(
!
HasProperty
(
cx
obj
id
&
found
)
)
return
false
;
}
id
=
NameToId
(
cx
-
>
names
(
)
.
length
)
;
if
(
!
HasProperty
(
cx
obj
id
&
found
)
)
return
false
;
id
=
NameToId
(
cx
-
>
names
(
)
.
name
)
;
if
(
!
HasProperty
(
cx
obj
id
&
found
)
)
return
false
;
return
true
;
}
bool
IsFunction
(
HandleValue
v
)
{
return
v
.
isObject
(
)
&
&
v
.
toObject
(
)
.
is
<
JSFunction
>
(
)
;
}
static
bool
AdvanceToActiveCallLinear
(
JSContext
*
cx
NonBuiltinScriptFrameIter
&
iter
HandleFunction
fun
)
{
MOZ_ASSERT
(
!
fun
-
>
isBuiltin
(
)
)
;
for
(
;
!
iter
.
done
(
)
;
+
+
iter
)
{
if
(
!
iter
.
isFunctionFrame
(
)
)
continue
;
if
(
iter
.
matchCallee
(
cx
fun
)
)
return
true
;
}
return
false
;
}
static
void
ThrowTypeErrorBehavior
(
JSContext
*
cx
)
{
JS_ReportErrorFlagsAndNumber
(
cx
JSREPORT_ERROR
GetErrorMessage
nullptr
JSMSG_THROW_TYPE_ERROR
)
;
}
static
bool
IsFunctionInStrictMode
(
JSFunction
*
fun
)
{
if
(
fun
-
>
isInterpreted
(
)
&
&
fun
-
>
strict
(
)
)
return
true
;
return
IsAsmJSStrictModeModuleOrFunction
(
fun
)
;
}
static
bool
ArgumentsRestrictions
(
JSContext
*
cx
HandleFunction
fun
)
{
if
(
fun
-
>
isBuiltin
(
)
|
|
IsFunctionInStrictMode
(
fun
)
|
|
fun
-
>
isBoundFunction
(
)
)
{
ThrowTypeErrorBehavior
(
cx
)
;
return
false
;
}
if
(
!
JS_ReportErrorFlagsAndNumber
(
cx
JSREPORT_WARNING
|
JSREPORT_STRICT
GetErrorMessage
nullptr
JSMSG_DEPRECATED_USAGE
js_arguments_str
)
)
{
return
false
;
}
return
true
;
}
bool
ArgumentsGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsFunction
(
args
.
thisv
(
)
)
)
;
RootedFunction
fun
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
if
(
!
ArgumentsRestrictions
(
cx
fun
)
)
return
false
;
NonBuiltinScriptFrameIter
iter
(
cx
)
;
if
(
!
AdvanceToActiveCallLinear
(
cx
iter
fun
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
Rooted
<
ArgumentsObject
*
>
argsobj
(
cx
ArgumentsObject
:
:
createUnexpected
(
cx
iter
)
)
;
if
(
!
argsobj
)
return
false
;
JSScript
*
script
=
iter
.
script
(
)
;
jit
:
:
ForbidCompilation
(
cx
script
)
;
args
.
rval
(
)
.
setObject
(
*
argsobj
)
;
return
true
;
}
static
bool
ArgumentsGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsFunction
ArgumentsGetterImpl
>
(
cx
args
)
;
}
bool
ArgumentsSetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsFunction
(
args
.
thisv
(
)
)
)
;
RootedFunction
fun
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
if
(
!
ArgumentsRestrictions
(
cx
fun
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
ArgumentsSetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsFunction
ArgumentsSetterImpl
>
(
cx
args
)
;
}
static
bool
CallerRestrictions
(
JSContext
*
cx
HandleFunction
fun
)
{
if
(
fun
-
>
isBuiltin
(
)
|
|
IsFunctionInStrictMode
(
fun
)
|
|
fun
-
>
isBoundFunction
(
)
)
{
ThrowTypeErrorBehavior
(
cx
)
;
return
false
;
}
if
(
!
JS_ReportErrorFlagsAndNumber
(
cx
JSREPORT_WARNING
|
JSREPORT_STRICT
GetErrorMessage
nullptr
JSMSG_DEPRECATED_USAGE
js_caller_str
)
)
{
return
false
;
}
return
true
;
}
bool
CallerGetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsFunction
(
args
.
thisv
(
)
)
)
;
RootedFunction
fun
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
if
(
!
CallerRestrictions
(
cx
fun
)
)
return
false
;
NonBuiltinScriptFrameIter
iter
(
cx
)
;
if
(
!
AdvanceToActiveCallLinear
(
cx
iter
fun
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
+
+
iter
;
while
(
!
iter
.
done
(
)
&
&
iter
.
isEvalFrame
(
)
)
+
+
iter
;
if
(
iter
.
done
(
)
|
|
!
iter
.
isFunctionFrame
(
)
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
RootedObject
caller
(
cx
iter
.
callee
(
cx
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
caller
)
)
return
false
;
{
JSObject
*
callerObj
=
CheckedUnwrap
(
caller
)
;
if
(
!
callerObj
)
{
args
.
rval
(
)
.
setNull
(
)
;
return
true
;
}
JSFunction
*
callerFun
=
&
callerObj
-
>
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
!
callerFun
-
>
isBuiltin
(
)
"
non
-
builtin
iterator
returned
a
builtin
?
"
)
;
if
(
callerFun
-
>
strict
(
)
)
{
JS_ReportErrorFlagsAndNumber
(
cx
JSREPORT_ERROR
GetErrorMessage
nullptr
JSMSG_CALLER_IS_STRICT
)
;
return
false
;
}
}
args
.
rval
(
)
.
setObject
(
*
caller
)
;
return
true
;
}
static
bool
CallerGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsFunction
CallerGetterImpl
>
(
cx
args
)
;
}
bool
CallerSetterImpl
(
JSContext
*
cx
const
CallArgs
&
args
)
{
MOZ_ASSERT
(
IsFunction
(
args
.
thisv
(
)
)
)
;
RootedFunction
fun
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
.
as
<
JSFunction
>
(
)
)
;
if
(
!
CallerRestrictions
(
cx
fun
)
)
return
false
;
args
.
rval
(
)
.
setUndefined
(
)
;
NonBuiltinScriptFrameIter
iter
(
cx
)
;
if
(
!
AdvanceToActiveCallLinear
(
cx
iter
fun
)
)
return
true
;
+
+
iter
;
while
(
!
iter
.
done
(
)
&
&
iter
.
isEvalFrame
(
)
)
+
+
iter
;
if
(
iter
.
done
(
)
|
|
!
iter
.
isFunctionFrame
(
)
)
return
true
;
RootedObject
caller
(
cx
iter
.
callee
(
cx
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
caller
)
)
{
cx
-
>
clearPendingException
(
)
;
return
true
;
}
JSObject
*
callerObj
=
CheckedUnwrap
(
caller
)
;
if
(
!
callerObj
)
return
true
;
JSFunction
*
callerFun
=
&
callerObj
-
>
as
<
JSFunction
>
(
)
;
MOZ_ASSERT
(
!
callerFun
-
>
isBuiltin
(
)
"
non
-
builtin
iterator
returned
a
builtin
?
"
)
;
if
(
callerFun
-
>
strict
(
)
)
{
JS_ReportErrorFlagsAndNumber
(
cx
JSREPORT_ERROR
GetErrorMessage
nullptr
JSMSG_CALLER_IS_STRICT
)
;
return
false
;
}
return
true
;
}
static
bool
CallerSetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
return
CallNonGenericMethod
<
IsFunction
CallerSetterImpl
>
(
cx
args
)
;
}
static
const
JSPropertySpec
function_properties
[
]
=
{
JS_PSGS
(
"
arguments
"
ArgumentsGetter
ArgumentsSetter
0
)
JS_PSGS
(
"
caller
"
CallerGetter
CallerSetter
0
)
JS_PS_END
}
;
static
bool
ResolveInterpretedFunctionPrototype
(
JSContext
*
cx
HandleFunction
fun
HandleId
id
)
{
MOZ_ASSERT
(
fun
-
>
isInterpreted
(
)
|
|
fun
-
>
isAsmJSNative
(
)
)
;
MOZ_ASSERT
(
id
=
=
NameToId
(
cx
-
>
names
(
)
.
prototype
)
)
;
MOZ_ASSERT
(
!
IsInternalFunctionObject
(
*
fun
)
)
;
MOZ_ASSERT
(
!
fun
-
>
isBoundFunction
(
)
)
;
bool
isStarGenerator
=
fun
-
>
isStarGenerator
(
)
;
Rooted
<
GlobalObject
*
>
global
(
cx
&
fun
-
>
global
(
)
)
;
RootedObject
objProto
(
cx
)
;
if
(
isStarGenerator
)
objProto
=
GlobalObject
:
:
getOrCreateStarGeneratorObjectPrototype
(
cx
global
)
;
else
objProto
=
fun
-
>
global
(
)
.
getOrCreateObjectPrototype
(
cx
)
;
if
(
!
objProto
)
return
false
;
RootedPlainObject
proto
(
cx
NewObjectWithGivenProto
<
PlainObject
>
(
cx
objProto
SingletonObject
)
)
;
if
(
!
proto
)
return
false
;
if
(
!
isStarGenerator
)
{
RootedValue
objVal
(
cx
ObjectValue
(
*
fun
)
)
;
if
(
!
DefineProperty
(
cx
proto
cx
-
>
names
(
)
.
constructor
objVal
nullptr
nullptr
0
)
)
return
false
;
}
RootedValue
protoVal
(
cx
ObjectValue
(
*
proto
)
)
;
return
DefineProperty
(
cx
fun
id
protoVal
nullptr
nullptr
JSPROP_PERMANENT
|
JSPROP_RESOLVING
)
;
}
static
bool
fun_mayResolve
(
const
JSAtomState
&
names
jsid
id
JSObject
*
)
{
if
(
!
JSID_IS_ATOM
(
id
)
)
return
false
;
JSAtom
*
atom
=
JSID_TO_ATOM
(
id
)
;
return
atom
=
=
names
.
prototype
|
|
atom
=
=
names
.
length
|
|
atom
=
=
names
.
name
;
}
static
bool
fun_resolve
(
JSContext
*
cx
HandleObject
obj
HandleId
id
bool
*
resolvedp
)
{
if
(
!
JSID_IS_ATOM
(
id
)
)
return
true
;
RootedFunction
fun
(
cx
&
obj
-
>
as
<
JSFunction
>
(
)
)
;
if
(
JSID_IS_ATOM
(
id
cx
-
>
names
(
)
.
prototype
)
)
{
if
(
fun
-
>
isBuiltin
(
)
|
|
(
!
fun
-
>
isConstructor
(
)
&
&
!
fun
-
>
isGenerator
(
)
)
)
return
true
;
if
(
!
ResolveInterpretedFunctionPrototype
(
cx
fun
id
)
)
return
false
;
*
resolvedp
=
true
;
return
true
;
}
bool
isLength
=
JSID_IS_ATOM
(
id
cx
-
>
names
(
)
.
length
)
;
if
(
isLength
|
|
JSID_IS_ATOM
(
id
cx
-
>
names
(
)
.
name
)
)
{
MOZ_ASSERT
(
!
IsInternalFunctionObject
(
*
obj
)
)
;
RootedValue
v
(
cx
)
;
if
(
isLength
)
{
if
(
fun
-
>
hasResolvedLength
(
)
)
return
true
;
if
(
fun
-
>
isBoundFunction
(
)
)
{
MOZ_ASSERT
(
fun
-
>
getExtendedSlot
(
BOUND_FUN_LENGTH_SLOT
)
.
isNumber
(
)
)
;
v
.
set
(
fun
-
>
getExtendedSlot
(
BOUND_FUN_LENGTH_SLOT
)
)
;
}
else
{
uint16_t
length
;
if
(
!
fun
-
>
getLength
(
cx
&
length
)
)
return
false
;
v
.
setInt32
(
length
)
;
}
}
else
{
if
(
fun
-
>
hasResolvedName
(
)
)
return
true
;
if
(
fun
-
>
isClassConstructor
(
)
)
{
MOZ_ASSERT
(
fun
-
>
name
(
)
!
=
cx
-
>
names
(
)
.
empty
)
;
if
(
fun
-
>
name
(
)
=
=
nullptr
)
return
true
;
}
v
.
setString
(
fun
-
>
name
(
)
=
=
nullptr
?
cx
-
>
runtime
(
)
-
>
emptyString
:
fun
-
>
name
(
)
)
;
}
if
(
!
NativeDefineProperty
(
cx
fun
id
v
nullptr
nullptr
JSPROP_READONLY
|
JSPROP_RESOLVING
)
)
{
return
false
;
}
if
(
isLength
)
fun
-
>
setResolvedLength
(
)
;
else
fun
-
>
setResolvedName
(
)
;
*
resolvedp
=
true
;
return
true
;
}
return
true
;
}
template
<
XDRMode
mode
>
bool
js
:
:
XDRInterpretedFunction
(
XDRState
<
mode
>
*
xdr
HandleScope
enclosingScope
HandleScript
enclosingScript
MutableHandleFunction
objp
)
{
enum
FirstWordFlag
{
HasAtom
=
0x1
IsStarGenerator
=
0x2
IsLazy
=
0x4
HasSingletonType
=
0x8
}
;
RootedAtom
atom
(
xdr
-
>
cx
(
)
)
;
uint32_t
firstword
=
0
;
uint32_t
flagsword
=
0
;
JSContext
*
cx
=
xdr
-
>
cx
(
)
;
RootedFunction
fun
(
cx
)
;
RootedScript
script
(
cx
)
;
Rooted
<
LazyScript
*
>
lazy
(
cx
)
;
if
(
mode
=
=
XDR_ENCODE
)
{
fun
=
objp
;
if
(
!
fun
-
>
isInterpreted
(
)
)
{
JSAutoByteString
funNameBytes
;
if
(
const
char
*
name
=
GetFunctionNameBytes
(
cx
fun
&
funNameBytes
)
)
{
JS_ReportErrorNumber
(
cx
GetErrorMessage
nullptr
JSMSG_NOT_SCRIPTED_FUNCTION
name
)
;
}
return
false
;
}
if
(
fun
-
>
name
(
)
|
|
fun
-
>
hasGuessedAtom
(
)
)
firstword
|
=
HasAtom
;
if
(
fun
-
>
isStarGenerator
(
)
)
firstword
|
=
IsStarGenerator
;
if
(
fun
-
>
isInterpretedLazy
(
)
)
{
firstword
|
=
IsLazy
;
lazy
=
fun
-
>
lazyScript
(
)
;
}
else
{
script
=
fun
-
>
nonLazyScript
(
)
;
}
if
(
fun
-
>
isSingleton
(
)
)
firstword
|
=
HasSingletonType
;
atom
=
fun
-
>
displayAtom
(
)
;
flagsword
=
(
fun
-
>
nargs
(
)
<
<
16
)
|
(
fun
-
>
flags
(
)
&
~
JSFunction
:
:
NO_XDR_FLAGS
)
;
MOZ_ASSERT_IF
(
fun
-
>
isSingleton
(
)
&
&
!
(
(
lazy
&
&
lazy
-
>
hasBeenCloned
(
)
)
|
|
(
script
&
&
script
-
>
hasBeenCloned
(
)
)
)
fun
-
>
environment
(
)
=
=
nullptr
)
;
}
if
(
!
xdr
-
>
codeUint32
(
&
firstword
)
)
return
false
;
if
(
(
firstword
&
HasAtom
)
&
&
!
XDRAtom
(
xdr
&
atom
)
)
return
false
;
if
(
!
xdr
-
>
codeUint32
(
&
flagsword
)
)
return
false
;
if
(
mode
=
=
XDR_DECODE
)
{
RootedObject
proto
(
cx
)
;
if
(
firstword
&
IsStarGenerator
)
{
proto
=
GlobalObject
:
:
getOrCreateStarGeneratorFunctionPrototype
(
cx
cx
-
>
global
(
)
)
;
if
(
!
proto
)
return
false
;
}
gc
:
:
AllocKind
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION
;
if
(
uint16_t
(
flagsword
)
&
JSFunction
:
:
EXTENDED
)
allocKind
=
gc
:
:
AllocKind
:
:
FUNCTION_EXTENDED
;
fun
=
NewFunctionWithProto
(
cx
nullptr
0
JSFunction
:
:
INTERPRETED
nullptr
nullptr
proto
allocKind
TenuredObject
)
;
if
(
!
fun
)
return
false
;
script
=
nullptr
;
}
if
(
firstword
&
IsLazy
)
{
if
(
!
XDRLazyScript
(
xdr
enclosingScope
enclosingScript
fun
&
lazy
)
)
return
false
;
}
else
{
if
(
!
XDRScript
(
xdr
enclosingScope
enclosingScript
fun
&
script
)
)
return
false
;
}
if
(
mode
=
=
XDR_DECODE
)
{
fun
-
>
setArgCount
(
flagsword
>
>
16
)
;
fun
-
>
setFlags
(
uint16_t
(
flagsword
)
)
;
fun
-
>
initAtom
(
atom
)
;
if
(
firstword
&
IsLazy
)
{
MOZ_ASSERT
(
fun
-
>
lazyScript
(
)
=
=
lazy
)
;
}
else
{
MOZ_ASSERT
(
fun
-
>
nonLazyScript
(
)
=
=
script
)
;
MOZ_ASSERT
(
fun
-
>
nargs
(
)
=
=
script
-
>
numArgs
(
)
)
;
}
bool
singleton
=
firstword
&
HasSingletonType
;
if
(
!
JSFunction
:
:
setTypeForScriptedFunction
(
cx
fun
singleton
)
)
return
false
;
objp
.
set
(
fun
)
;
}
return
true
;
}
template
bool
js
:
:
XDRInterpretedFunction
(
XDRState
<
XDR_ENCODE
>
*
HandleScope
HandleScript
MutableHandleFunction
)
;
template
bool
js
:
:
XDRInterpretedFunction
(
XDRState
<
XDR_DECODE
>
*
HandleScope
HandleScript
MutableHandleFunction
)
;
bool
js
:
:
fun_symbolHasInstance
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
args
.
length
(
)
<
1
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
HandleValue
func
=
args
.
thisv
(
)
;
if
(
!
func
.
isObject
(
)
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
RootedObject
obj
(
cx
&
func
.
toObject
(
)
)
;
bool
result
;
if
(
!
OrdinaryHasInstance
(
cx
obj
args
[
0
]
&
result
)
)
return
false
;
args
.
rval
(
)
.
setBoolean
(
result
)
;
return
true
;
}
bool
JS
:
:
OrdinaryHasInstance
(
JSContext
*
cx
HandleObject
objArg
HandleValue
v
bool
*
bp
)
{
RootedObject
obj
(
cx
objArg
)
;
if
(
!
obj
-
>
isCallable
(
)
)
{
*
bp
=
false
;
return
true
;
}
if
(
obj
-
>
is
<
JSFunction
>
(
)
&
&
obj
-
>
isBoundFunction
(
)
)
{
obj
=
obj
-
>
as
<
JSFunction
>
(
)
.
getBoundFunctionTarget
(
)
;
return
InstanceOfOperator
(
cx
obj
v
bp
)
;
}
if
(
!
v
.
isObject
(
)
)
{
*
bp
=
false
;
return
true
;
}
RootedValue
pval
(
cx
)
;
if
(
!
GetProperty
(
cx
obj
obj
cx
-
>
names
(
)
.
prototype
&
pval
)
)
return
false
;
if
(
pval
.
isPrimitive
(
)
)
{
RootedValue
val
(
cx
ObjectValue
(
*
obj
)
)
;
ReportValueError
(
cx
JSMSG_BAD_PROTOTYPE
-
1
val
nullptr
)
;
return
false
;
}
RootedObject
pobj
(
cx
&
pval
.
toObject
(
)
)
;
bool
isDelegate
;
if
(
!
IsDelegate
(
cx
pobj
v
&
isDelegate
)
)
return
false
;
*
bp
=
isDelegate
;
return
true
;
}
inline
void
JSFunction
:
:
trace
(
JSTracer
*
trc
)
{
if
(
isExtended
(
)
)
{
TraceRange
(
trc
ArrayLength
(
toExtended
(
)
-
>
extendedSlots
)
(
GCPtrValue
*
)
toExtended
(
)
-
>
extendedSlots
"
nativeReserved
"
)
;
}
TraceNullableEdge
(
trc
&
atom_
"
atom
"
)
;
if
(
isInterpreted
(
)
)
{
if
(
hasScript
(
)
&
&
!
hasUncompiledScript
(
)
)
TraceManuallyBarrieredEdge
(
trc
&
u
.
i
.
s
.
script_
"
script
"
)
;
else
if
(
isInterpretedLazy
(
)
&
&
u
.
i
.
s
.
lazy_
)
TraceManuallyBarrieredEdge
(
trc
&
u
.
i
.
s
.
lazy_
"
lazyScript
"
)
;
if
(
u
.
i
.
env_
)
TraceManuallyBarrieredEdge
(
trc
&
u
.
i
.
env_
"
fun_environment
"
)
;
}
}
static
void
fun_trace
(
JSTracer
*
trc
JSObject
*
obj
)
{
obj
-
>
as
<
JSFunction
>
(
)
.
trace
(
trc
)
;
}
static
bool
ThrowTypeError
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
ThrowTypeErrorBehavior
(
cx
)
;
return
false
;
}
static
JSObject
*
CreateFunctionConstructor
(
JSContext
*
cx
JSProtoKey
key
)
{
Rooted
<
GlobalObject
*
>
global
(
cx
cx
-
>
global
(
)
)
;
RootedObject
functionProto
(
cx
&
global
-
>
getPrototype
(
JSProto_Function
)
.
toObject
(
)
)
;
RootedObject
functionCtor
(
cx
NewFunctionWithProto
(
cx
Function
1
JSFunction
:
:
NATIVE_CTOR
nullptr
HandlePropertyName
(
cx
-
>
names
(
)
.
Function
)
functionProto
AllocKind
:
:
FUNCTION
SingletonObject
)
)
;
if
(
!
functionCtor
)
return
nullptr
;
return
functionCtor
;
}
static
JSObject
*
CreateFunctionPrototype
(
JSContext
*
cx
JSProtoKey
key
)
{
Rooted
<
GlobalObject
*
>
self
(
cx
cx
-
>
global
(
)
)
;
RootedObject
objectProto
(
cx
&
self
-
>
getPrototype
(
JSProto_Object
)
.
toObject
(
)
)
;
RootedObject
enclosingEnv
(
cx
&
self
-
>
lexicalEnvironment
(
)
)
;
JSObject
*
functionProto_
=
NewFunctionWithProto
(
cx
nullptr
0
JSFunction
:
:
INTERPRETED
enclosingEnv
nullptr
objectProto
AllocKind
:
:
FUNCTION
SingletonObject
)
;
if
(
!
functionProto_
)
return
nullptr
;
RootedFunction
functionProto
(
cx
&
functionProto_
-
>
as
<
JSFunction
>
(
)
)
;
const
char
*
rawSource
=
"
(
)
{
\
n
}
"
;
size_t
sourceLen
=
strlen
(
rawSource
)
;
mozilla
:
:
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
source
(
InflateString
(
cx
rawSource
&
sourceLen
)
)
;
if
(
!
source
)
return
nullptr
;
ScriptSource
*
ss
=
cx
-
>
new_
<
ScriptSource
>
(
)
;
if
(
!
ss
)
return
nullptr
;
ScriptSourceHolder
ssHolder
(
ss
)
;
if
(
!
ss
-
>
setSource
(
cx
mozilla
:
:
Move
(
source
)
sourceLen
)
)
return
nullptr
;
CompileOptions
options
(
cx
)
;
options
.
setNoScriptRval
(
true
)
.
setVersion
(
JSVERSION_DEFAULT
)
;
RootedScriptSource
sourceObject
(
cx
ScriptSourceObject
:
:
create
(
cx
ss
)
)
;
if
(
!
sourceObject
|
|
!
ScriptSourceObject
:
:
initFromOptions
(
cx
sourceObject
options
)
)
return
nullptr
;
RootedScript
script
(
cx
JSScript
:
:
Create
(
cx
options
sourceObject
0
ss
-
>
length
(
)
)
)
;
if
(
!
script
|
|
!
JSScript
:
:
initFunctionPrototype
(
cx
script
functionProto
)
)
return
nullptr
;
functionProto
-
>
initScript
(
script
)
;
ObjectGroup
*
protoGroup
=
functionProto
-
>
getGroup
(
cx
)
;
if
(
!
protoGroup
)
return
nullptr
;
protoGroup
-
>
setInterpretedFunction
(
functionProto
)
;
if
(
!
JSObject
:
:
setNewGroupUnknown
(
cx
&
JSFunction
:
:
class_
functionProto
)
)
return
nullptr
;
RootedFunction
throwTypeError
(
cx
NewFunctionWithProto
(
cx
ThrowTypeError
0
JSFunction
:
:
NATIVE_FUN
nullptr
nullptr
functionProto
AllocKind
:
:
FUNCTION
SingletonObject
)
)
;
if
(
!
throwTypeError
|
|
!
PreventExtensions
(
cx
throwTypeError
)
)
return
nullptr
;
self
-
>
setThrowTypeError
(
throwTypeError
)
;
return
functionProto
;
}
static
const
ClassOps
JSFunctionClassOps
=
{
nullptr
nullptr
nullptr
nullptr
fun_enumerate
fun_resolve
fun_mayResolve
nullptr
nullptr
nullptr
nullptr
fun_trace
}
;
static
const
ClassSpec
JSFunctionClassSpec
=
{
CreateFunctionConstructor
CreateFunctionPrototype
nullptr
nullptr
function_methods
function_properties
}
;
const
Class
JSFunction
:
:
class_
=
{
js_Function_str
JSCLASS_HAS_CACHED_PROTO
(
JSProto_Function
)
&
JSFunctionClassOps
&
JSFunctionClassSpec
}
;
const
Class
*
const
js
:
:
FunctionClassPtr
=
&
JSFunction
:
:
class_
;
bool
js
:
:
FindBody
(
JSContext
*
cx
HandleFunction
fun
HandleLinearString
src
size_t
*
bodyStart
size_t
*
bodyEnd
)
{
CompileOptions
options
(
cx
)
;
options
.
setFileAndLine
(
"
internal
-
findBody
"
0
)
;
if
(
fun
-
>
hasScript
(
)
)
options
.
setVersion
(
fun
-
>
nonLazyScript
(
)
-
>
getVersion
(
)
)
;
AutoKeepAtoms
keepAtoms
(
cx
-
>
perThreadData
)
;
AutoStableStringChars
stableChars
(
cx
)
;
if
(
!
stableChars
.
initTwoByte
(
cx
src
)
)
return
false
;
const
mozilla
:
:
Range
<
const
char16_t
>
srcChars
=
stableChars
.
twoByteRange
(
)
;
TokenStream
ts
(
cx
options
srcChars
.
start
(
)
.
get
(
)
srcChars
.
length
(
)
nullptr
)
;
int
nest
=
0
;
bool
onward
=
true
;
do
{
TokenKind
tt
;
if
(
!
ts
.
getToken
(
&
tt
)
)
return
false
;
switch
(
tt
)
{
case
TOK_NAME
:
case
TOK_YIELD
:
if
(
nest
=
=
0
)
onward
=
false
;
break
;
case
TOK_LP
:
nest
+
+
;
break
;
case
TOK_RP
:
if
(
-
-
nest
=
=
0
)
onward
=
false
;
break
;
default
:
break
;
}
}
while
(
onward
)
;
TokenKind
tt
;
if
(
!
ts
.
getToken
(
&
tt
)
)
return
false
;
if
(
tt
=
=
TOK_ARROW
)
{
if
(
!
ts
.
getToken
(
&
tt
)
)
return
false
;
}
bool
braced
=
tt
=
=
TOK_LC
;
MOZ_ASSERT_IF
(
fun
-
>
isExprBody
(
)
!
braced
)
;
*
bodyStart
=
ts
.
currentToken
(
)
.
pos
.
begin
;
if
(
braced
)
*
bodyStart
+
=
1
;
mozilla
:
:
RangedPtr
<
const
char16_t
>
end
=
srcChars
.
end
(
)
;
if
(
end
[
-
1
]
=
=
'
}
'
)
{
end
-
-
;
}
else
{
MOZ_ASSERT
(
!
braced
)
;
for
(
;
unicode
:
:
IsSpaceOrBOM2
(
end
[
-
1
]
)
;
end
-
-
)
;
}
*
bodyEnd
=
end
-
srcChars
.
start
(
)
;
MOZ_ASSERT
(
*
bodyStart
<
=
*
bodyEnd
)
;
return
true
;
}
JSString
*
js
:
:
FunctionToString
(
JSContext
*
cx
HandleFunction
fun
bool
lambdaParen
)
{
if
(
fun
-
>
isInterpretedLazy
(
)
&
&
!
fun
-
>
getOrCreateScript
(
cx
)
)
return
nullptr
;
if
(
IsAsmJSModule
(
fun
)
)
return
AsmJSModuleToString
(
cx
fun
!
lambdaParen
)
;
if
(
IsAsmJSFunction
(
fun
)
)
return
AsmJSFunctionToString
(
cx
fun
)
;
StringBuffer
out
(
cx
)
;
RootedScript
script
(
cx
)
;
if
(
fun
-
>
hasScript
(
)
)
{
script
=
fun
-
>
nonLazyScript
(
)
;
if
(
script
-
>
isGeneratorExp
(
)
)
{
if
(
!
out
.
append
(
"
function
genexp
(
)
{
"
)
|
|
!
out
.
append
(
"
\
n
[
generator
expression
]
\
n
"
)
|
|
!
out
.
append
(
"
}
"
)
)
{
return
nullptr
;
}
return
out
.
finishString
(
)
;
}
}
bool
funIsMethodOrNonArrowLambda
=
(
fun
-
>
isLambda
(
)
&
&
!
fun
-
>
isArrow
(
)
)
|
|
fun
-
>
isMethod
(
)
|
|
fun
-
>
isGetter
(
)
|
|
fun
-
>
isSetter
(
)
;
if
(
fun
-
>
isInterpreted
(
)
&
&
!
lambdaParen
&
&
funIsMethodOrNonArrowLambda
&
&
!
fun
-
>
isSelfHostedBuiltin
(
)
)
{
if
(
!
out
.
append
(
"
(
"
)
)
return
nullptr
;
}
if
(
!
fun
-
>
isArrow
(
)
)
{
if
(
!
(
fun
-
>
isStarGenerator
(
)
?
out
.
append
(
"
function
*
"
)
:
out
.
append
(
"
function
"
)
)
)
return
nullptr
;
}
if
(
fun
-
>
name
(
)
)
{
if
(
!
out
.
append
(
fun
-
>
name
(
)
)
)
return
nullptr
;
}
bool
haveSource
=
fun
-
>
isInterpreted
(
)
&
&
!
fun
-
>
isSelfHostedBuiltin
(
)
;
if
(
haveSource
&
&
!
script
-
>
scriptSource
(
)
-
>
hasSourceData
(
)
&
&
!
JSScript
:
:
loadSource
(
cx
script
-
>
scriptSource
(
)
&
haveSource
)
)
{
return
nullptr
;
}
if
(
haveSource
)
{
Rooted
<
JSFlatString
*
>
src
(
cx
script
-
>
sourceData
(
cx
)
)
;
if
(
!
src
)
return
nullptr
;
bool
funCon
=
!
fun
-
>
isArrow
(
)
&
&
script
-
>
sourceStart
(
)
=
=
0
&
&
script
-
>
sourceEnd
(
)
=
=
script
-
>
scriptSource
(
)
-
>
length
(
)
&
&
script
-
>
scriptSource
(
)
-
>
argumentsNotIncluded
(
)
;
MOZ_ASSERT_IF
(
funCon
!
fun
-
>
isArrow
(
)
)
;
MOZ_ASSERT_IF
(
funCon
!
fun
-
>
isExprBody
(
)
)
;
MOZ_ASSERT_IF
(
!
funCon
&
&
!
fun
-
>
isArrow
(
)
src
-
>
length
(
)
>
0
&
&
src
-
>
latin1OrTwoByteChar
(
0
)
=
=
'
(
'
)
;
bool
buildBody
=
funCon
;
if
(
buildBody
)
{
if
(
!
out
.
append
(
"
(
"
)
)
return
nullptr
;
MOZ_ASSERT
(
script
-
>
numArgs
(
)
=
=
fun
-
>
nargs
(
)
)
;
BindingIter
bi
(
script
)
;
for
(
unsigned
i
=
0
;
i
<
fun
-
>
nargs
(
)
;
i
+
+
bi
+
+
)
{
MOZ_ASSERT
(
bi
.
argumentSlot
(
)
=
=
i
)
;
if
(
i
&
&
!
out
.
append
(
"
"
)
)
return
nullptr
;
if
(
i
=
=
unsigned
(
fun
-
>
nargs
(
)
-
1
)
&
&
fun
-
>
hasRest
(
)
&
&
!
out
.
append
(
"
.
.
.
"
)
)
return
nullptr
;
if
(
!
out
.
append
(
bi
.
name
(
)
)
)
return
nullptr
;
}
if
(
!
out
.
append
(
"
)
{
\
n
"
)
)
return
nullptr
;
}
if
(
!
out
.
append
(
src
)
)
return
nullptr
;
if
(
buildBody
)
{
if
(
!
out
.
append
(
"
\
n
}
"
)
)
return
nullptr
;
}
if
(
!
lambdaParen
&
&
funIsMethodOrNonArrowLambda
)
{
if
(
!
out
.
append
(
"
)
"
)
)
return
nullptr
;
}
}
else
if
(
fun
-
>
isInterpreted
(
)
&
&
!
fun
-
>
isSelfHostedBuiltin
(
)
)
{
if
(
!
out
.
append
(
"
(
)
{
\
n
"
)
|
|
!
out
.
append
(
"
[
sourceless
code
]
"
)
|
|
!
out
.
append
(
"
\
n
}
"
)
)
{
return
nullptr
;
}
if
(
!
lambdaParen
&
&
fun
-
>
isLambda
(
)
&
&
!
fun
-
>
isArrow
(
)
&
&
!
out
.
append
(
"
)
"
)
)
return
nullptr
;
}
else
{
MOZ_ASSERT
(
!
fun
-
>
isExprBody
(
)
)
;
bool
derived
=
fun
-
>
infallibleIsDefaultClassConstructor
(
cx
)
;
if
(
derived
&
&
fun
-
>
isDerivedClassConstructor
(
)
)
{
if
(
!
out
.
append
(
"
(
.
.
.
args
)
{
\
n
"
)
|
|
!
out
.
append
(
"
super
(
.
.
.
args
)
;
\
n
}
"
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
out
.
append
(
"
(
)
{
\
n
"
)
)
return
nullptr
;
if
(
!
derived
)
{
if
(
!
out
.
append
(
"
[
native
code
]
"
)
)
return
nullptr
;
}
if
(
!
out
.
append
(
"
\
n
}
"
)
)
return
nullptr
;
}
}
return
out
.
finishString
(
)
;
}
JSString
*
fun_toStringHelper
(
JSContext
*
cx
HandleObject
obj
unsigned
indent
)
{
if
(
!
obj
-
>
is
<
JSFunction
>
(
)
)
{
if
(
JSFunToStringOp
op
=
obj
-
>
getOpsFunToString
(
)
)
return
op
(
cx
obj
indent
)
;
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_PROTO
js_Function_str
js_toString_str
"
object
"
)
;
return
nullptr
;
}
RootedFunction
fun
(
cx
&
obj
-
>
as
<
JSFunction
>
(
)
)
;
return
FunctionToString
(
cx
fun
indent
!
=
JS_DONT_PRETTY_PRINT
)
;
}
bool
js
:
:
FunctionHasDefaultHasInstance
(
JSFunction
*
fun
const
WellKnownSymbols
&
symbols
)
{
jsid
id
=
SYMBOL_TO_JSID
(
symbols
.
hasInstance
)
;
Shape
*
shape
=
fun
-
>
lookupPure
(
id
)
;
if
(
shape
)
{
if
(
!
shape
-
>
hasSlot
(
)
|
|
!
shape
-
>
hasDefaultGetter
(
)
)
return
false
;
const
Value
hasInstance
=
fun
-
>
as
<
NativeObject
>
(
)
.
getSlot
(
shape
-
>
slot
(
)
)
;
return
IsNativeFunction
(
hasInstance
js
:
:
fun_symbolHasInstance
)
;
}
return
true
;
}
bool
js
:
:
fun_toString
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
IsFunctionObject
(
args
.
calleev
(
)
)
)
;
uint32_t
indent
=
0
;
if
(
args
.
length
(
)
!
=
0
&
&
!
ToUint32
(
cx
args
[
0
]
&
indent
)
)
return
false
;
RootedObject
obj
(
cx
ToObject
(
cx
args
.
thisv
(
)
)
)
;
if
(
!
obj
)
return
false
;
RootedString
str
(
cx
fun_toStringHelper
(
cx
obj
indent
)
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
#
if
JS_HAS_TOSOURCE
static
bool
fun_toSource
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
MOZ_ASSERT
(
IsFunctionObject
(
args
.
calleev
(
)
)
)
;
RootedObject
obj
(
cx
ToObject
(
cx
args
.
thisv
(
)
)
)
;
if
(
!
obj
)
return
false
;
RootedString
str
(
cx
)
;
if
(
obj
-
>
isCallable
(
)
)
str
=
fun_toStringHelper
(
cx
obj
JS_DONT_PRETTY_PRINT
)
;
else
str
=
ObjectToSource
(
cx
obj
)
;
if
(
!
str
)
return
false
;
args
.
rval
(
)
.
setString
(
str
)
;
return
true
;
}
#
endif
bool
js
:
:
fun_call
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
func
=
args
.
thisv
(
)
;
if
(
!
IsCallable
(
func
)
)
{
ReportIncompatibleMethod
(
cx
args
&
JSFunction
:
:
class_
)
;
return
false
;
}
size_t
argCount
=
args
.
length
(
)
;
if
(
argCount
>
0
)
argCount
-
-
;
InvokeArgs
iargs
(
cx
)
;
if
(
!
iargs
.
init
(
argCount
)
)
return
false
;
for
(
size_t
i
=
0
;
i
<
argCount
;
i
+
+
)
iargs
[
i
]
.
set
(
args
[
i
+
1
]
)
;
return
Call
(
cx
func
args
.
get
(
0
)
iargs
args
.
rval
(
)
)
;
}
bool
js
:
:
fun_apply
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
HandleValue
fval
=
args
.
thisv
(
)
;
if
(
!
IsCallable
(
fval
)
)
{
ReportIncompatibleMethod
(
cx
args
&
JSFunction
:
:
class_
)
;
return
false
;
}
if
(
args
.
length
(
)
<
2
|
|
args
[
1
]
.
isNullOrUndefined
(
)
)
return
fun_call
(
cx
(
args
.
length
(
)
>
0
)
?
1
:
0
vp
)
;
InvokeArgs
args2
(
cx
)
;
if
(
args
[
1
]
.
isMagic
(
JS_OPTIMIZED_ARGUMENTS
)
)
{
ScriptFrameIter
iter
(
cx
)
;
MOZ_ASSERT
(
iter
.
numActualArgs
(
)
<
=
ARGS_LENGTH_MAX
)
;
if
(
!
args2
.
init
(
iter
.
numActualArgs
(
)
)
)
return
false
;
iter
.
unaliasedForEachActual
(
cx
CopyTo
(
args2
.
array
(
)
)
)
;
}
else
{
if
(
!
args
[
1
]
.
isObject
(
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_APPLY_ARGS
js_apply_str
)
;
return
false
;
}
RootedObject
aobj
(
cx
&
args
[
1
]
.
toObject
(
)
)
;
uint32_t
length
;
if
(
!
GetLengthProperty
(
cx
aobj
&
length
)
)
return
false
;
if
(
length
>
ARGS_LENGTH_MAX
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_TOO_MANY_FUN_APPLY_ARGS
)
;
return
false
;
}
if
(
!
args2
.
init
(
length
)
)
return
false
;
if
(
!
GetElements
(
cx
aobj
length
args2
.
array
(
)
)
)
return
false
;
}
return
Call
(
cx
fval
args
[
0
]
args2
args
.
rval
(
)
)
;
}
bool
JSFunction
:
:
infallibleIsDefaultClassConstructor
(
JSContext
*
cx
)
const
{
if
(
!
isSelfHostedBuiltin
(
)
)
return
false
;
bool
isDefault
=
false
;
if
(
isInterpretedLazy
(
)
)
{
JSAtom
*
name
=
&
getExtendedSlot
(
LAZY_FUNCTION_NAME_SLOT
)
.
toString
(
)
-
>
asAtom
(
)
;
isDefault
=
name
=
=
cx
-
>
names
(
)
.
DefaultDerivedClassConstructor
|
|
name
=
=
cx
-
>
names
(
)
.
DefaultBaseClassConstructor
;
}
else
{
isDefault
=
nonLazyScript
(
)
-
>
isDefaultClassConstructor
(
)
;
}
MOZ_ASSERT_IF
(
isDefault
isConstructor
(
)
)
;
MOZ_ASSERT_IF
(
isDefault
isClassConstructor
(
)
)
;
return
isDefault
;
}
bool
JSFunction
:
:
isDerivedClassConstructor
(
)
{
bool
derived
;
if
(
isInterpretedLazy
(
)
)
{
if
(
isSelfHostedBuiltin
(
)
)
{
JSAtom
*
name
=
&
getExtendedSlot
(
LAZY_FUNCTION_NAME_SLOT
)
.
toString
(
)
-
>
asAtom
(
)
;
derived
=
name
=
=
compartment
(
)
-
>
runtimeFromAnyThread
(
)
-
>
commonNames
-
>
DefaultDerivedClassConstructor
;
}
else
{
derived
=
lazyScript
(
)
-
>
isDerivedClassConstructor
(
)
;
}
}
else
{
derived
=
nonLazyScript
(
)
-
>
isDerivedClassConstructor
(
)
;
}
MOZ_ASSERT_IF
(
derived
isClassConstructor
(
)
)
;
return
derived
;
}
bool
JSFunction
:
:
getLength
(
JSContext
*
cx
uint16_t
*
length
)
{
JS
:
:
RootedFunction
self
(
cx
this
)
;
MOZ_ASSERT
(
!
self
-
>
isBoundFunction
(
)
)
;
if
(
self
-
>
isInterpretedLazy
(
)
&
&
!
self
-
>
getOrCreateScript
(
cx
)
)
return
false
;
*
length
=
self
-
>
hasScript
(
)
?
self
-
>
nonLazyScript
(
)
-
>
funLength
(
)
:
(
self
-
>
nargs
(
)
-
self
-
>
hasRest
(
)
)
;
return
true
;
}
static
const
js
:
:
Value
&
BoundFunctionEnvironmentSlotValue
(
const
JSFunction
*
fun
uint32_t
slotIndex
)
{
MOZ_ASSERT
(
fun
-
>
isBoundFunction
(
)
)
;
MOZ_ASSERT
(
fun
-
>
environment
(
)
-
>
is
<
CallObject
>
(
)
)
;
CallObject
*
callObject
=
&
fun
-
>
environment
(
)
-
>
as
<
CallObject
>
(
)
;
return
callObject
-
>
getSlot
(
slotIndex
)
;
}
JSObject
*
JSFunction
:
:
getBoundFunctionTarget
(
)
const
{
js
:
:
Value
targetVal
=
BoundFunctionEnvironmentSlotValue
(
this
JSSLOT_BOUND_FUNCTION_TARGET
)
;
MOZ_ASSERT
(
IsCallable
(
targetVal
)
)
;
return
&
targetVal
.
toObject
(
)
;
}
const
js
:
:
Value
&
JSFunction
:
:
getBoundFunctionThis
(
)
const
{
return
BoundFunctionEnvironmentSlotValue
(
this
JSSLOT_BOUND_FUNCTION_THIS
)
;
}
static
ArrayObject
*
GetBoundFunctionArguments
(
const
JSFunction
*
boundFun
)
{
js
:
:
Value
argsVal
=
BoundFunctionEnvironmentSlotValue
(
boundFun
JSSLOT_BOUND_FUNCTION_ARGS
)
;
return
&
argsVal
.
toObject
(
)
.
as
<
ArrayObject
>
(
)
;
}
const
js
:
:
Value
&
JSFunction
:
:
getBoundFunctionArgument
(
JSContext
*
cx
unsigned
which
)
const
{
MOZ_ASSERT
(
which
<
getBoundFunctionArgumentCount
(
)
)
;
RootedArrayObject
boundArgs
(
cx
GetBoundFunctionArguments
(
this
)
)
;
RootedValue
res
(
cx
)
;
return
boundArgs
-
>
getDenseElement
(
which
)
;
}
size_t
JSFunction
:
:
getBoundFunctionArgumentCount
(
)
const
{
return
GetBoundFunctionArguments
(
this
)
-
>
length
(
)
;
}
bool
JSFunction
:
:
createScriptForLazilyInterpretedFunction
(
JSContext
*
cx
HandleFunction
fun
)
{
MOZ_ASSERT
(
fun
-
>
isInterpretedLazy
(
)
)
;
Rooted
<
LazyScript
*
>
lazy
(
cx
fun
-
>
lazyScriptOrNull
(
)
)
;
if
(
lazy
)
{
if
(
cx
-
>
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
LazyScript
:
:
writeBarrierPre
(
lazy
)
;
RootedScript
script
(
cx
lazy
-
>
maybeScript
(
)
)
;
bool
canRelazify
=
!
lazy
-
>
numInnerFunctions
(
)
&
&
!
lazy
-
>
hasDirectEval
(
)
;
if
(
script
)
{
fun
-
>
setUnlazifiedScript
(
script
)
;
if
(
canRelazify
)
script
-
>
setLazyScript
(
lazy
)
;
return
true
;
}
if
(
fun
!
=
lazy
-
>
functionNonDelazifying
(
)
)
{
if
(
!
lazy
-
>
functionDelazifying
(
cx
)
)
return
false
;
script
=
lazy
-
>
functionNonDelazifying
(
)
-
>
nonLazyScript
(
)
;
if
(
!
script
)
return
false
;
fun
-
>
setUnlazifiedScript
(
script
)
;
return
true
;
}
if
(
canRelazify
&
&
!
JS
:
:
IsIncrementalGCInProgress
(
cx
)
)
{
LazyScriptCache
:
:
Lookup
lookup
(
cx
lazy
)
;
cx
-
>
caches
.
lazyScriptCache
.
lookup
(
lookup
script
.
address
(
)
)
;
}
if
(
script
)
{
RootedScope
enclosingScope
(
cx
lazy
-
>
enclosingScope
(
)
)
;
RootedScript
clonedScript
(
cx
CloneScriptIntoFunction
(
cx
enclosingScope
fun
script
)
)
;
if
(
!
clonedScript
)
return
false
;
clonedScript
-
>
setSourceObject
(
lazy
-
>
sourceObject
(
)
)
;
fun
-
>
initAtom
(
script
-
>
functionNonDelazifying
(
)
-
>
displayAtom
(
)
)
;
if
(
!
lazy
-
>
maybeScript
(
)
)
lazy
-
>
initScript
(
clonedScript
)
;
return
true
;
}
MOZ_ASSERT
(
lazy
-
>
scriptSource
(
)
-
>
hasSourceData
(
)
)
;
size_t
lazyLength
=
lazy
-
>
end
(
)
-
lazy
-
>
begin
(
)
;
UncompressedSourceCache
:
:
AutoHoldEntry
holder
;
const
char16_t
*
chars
=
lazy
-
>
scriptSource
(
)
-
>
chars
(
cx
holder
lazy
-
>
begin
(
)
lazyLength
)
;
if
(
!
chars
)
return
false
;
if
(
!
frontend
:
:
CompileLazyFunction
(
cx
lazy
chars
lazyLength
)
)
{
fun
-
>
initLazyScript
(
lazy
)
;
if
(
lazy
-
>
hasScript
(
)
)
lazy
-
>
resetScript
(
)
;
return
false
;
}
script
=
fun
-
>
nonLazyScript
(
)
;
if
(
!
lazy
-
>
maybeScript
(
)
)
lazy
-
>
initScript
(
script
)
;
if
(
canRelazify
)
{
script
-
>
setColumn
(
lazy
-
>
column
(
)
)
;
LazyScriptCache
:
:
Lookup
lookup
(
cx
lazy
)
;
cx
-
>
caches
.
lazyScriptCache
.
insert
(
lookup
script
)
;
script
-
>
setLazyScript
(
lazy
)
;
}
return
true
;
}
MOZ_ASSERT
(
fun
-
>
isSelfHostedBuiltin
(
)
)
;
RootedAtom
funAtom
(
cx
&
fun
-
>
getExtendedSlot
(
LAZY_FUNCTION_NAME_SLOT
)
.
toString
(
)
-
>
asAtom
(
)
)
;
if
(
!
funAtom
)
return
false
;
Rooted
<
PropertyName
*
>
funName
(
cx
funAtom
-
>
asPropertyName
(
)
)
;
return
cx
-
>
runtime
(
)
-
>
cloneSelfHostedFunctionScript
(
cx
funName
fun
)
;
}
void
JSFunction
:
:
maybeRelazify
(
JSRuntime
*
rt
)
{
if
(
!
hasScript
(
)
|
|
!
u
.
i
.
s
.
script_
)
return
;
JSCompartment
*
comp
=
compartment
(
)
;
if
(
comp
-
>
hasBeenEntered
(
)
&
&
!
rt
-
>
allowRelazificationForTesting
)
return
;
if
(
comp
-
>
isDebuggee
(
)
|
|
comp
-
>
isSelfHosting
)
return
;
if
(
comp
-
>
collectCoverageForDebug
(
)
)
return
;
if
(
!
u
.
i
.
s
.
script_
-
>
isRelazifiable
(
)
)
return
;
if
(
isSelfHostedBuiltin
(
)
&
&
(
!
isExtended
(
)
|
|
!
getExtendedSlot
(
LAZY_FUNCTION_NAME_SLOT
)
.
isString
(
)
)
)
{
return
;
}
JSScript
*
script
=
nonLazyScript
(
)
;
flags_
&
=
~
INTERPRETED
;
flags_
|
=
INTERPRETED_LAZY
;
LazyScript
*
lazy
=
script
-
>
maybeLazyScript
(
)
;
u
.
i
.
s
.
lazy_
=
lazy
;
if
(
lazy
)
{
MOZ_ASSERT
(
!
isSelfHostedBuiltin
(
)
)
;
}
else
{
MOZ_ASSERT
(
isSelfHostedBuiltin
(
)
)
;
MOZ_ASSERT
(
isExtended
(
)
)
;
MOZ_ASSERT
(
getExtendedSlot
(
LAZY_FUNCTION_NAME_SLOT
)
.
toString
(
)
-
>
isAtom
(
)
)
;
}
comp
-
>
scheduleDelazificationForDebugger
(
)
;
}
static
bool
fun_isGenerator
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
JSFunction
*
fun
;
if
(
!
IsFunctionObject
(
args
.
thisv
(
)
&
fun
)
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
args
.
rval
(
)
.
setBoolean
(
fun
-
>
isGenerator
(
)
)
;
return
true
;
}
static
bool
OnBadFormal
(
JSContext
*
cx
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_BAD_FORMAL
)
;
return
false
;
}
const
JSFunctionSpec
js
:
:
function_methods
[
]
=
{
#
if
JS_HAS_TOSOURCE
JS_FN
(
js_toSource_str
fun_toSource
0
0
)
#
endif
JS_FN
(
js_toString_str
fun_toString
0
0
)
JS_FN
(
js_apply_str
fun_apply
2
0
)
JS_FN
(
js_call_str
fun_call
1
0
)
JS_FN
(
"
isGenerator
"
fun_isGenerator
0
0
)
JS_SELF_HOSTED_FN
(
"
bind
"
"
FunctionBind
"
2
JSFUN_HAS_REST
)
JS_SYM_FN
(
hasInstance
fun_symbolHasInstance
1
JSPROP_READONLY
|
JSPROP_PERMANENT
)
JS_FS_END
}
;
static
bool
FunctionConstructor
(
JSContext
*
cx
unsigned
argc
Value
*
vp
GeneratorKind
generatorKind
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
Rooted
<
GlobalObject
*
>
global
(
cx
&
args
.
callee
(
)
.
global
(
)
)
;
if
(
!
GlobalObject
:
:
isRuntimeCodeGenEnabled
(
cx
global
)
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_CSP_BLOCKED_FUNCTION
)
;
return
false
;
}
bool
isStarGenerator
=
generatorKind
=
=
StarGenerator
;
MOZ_ASSERT
(
generatorKind
!
=
LegacyGenerator
)
;
RootedScript
maybeScript
(
cx
)
;
const
char
*
filename
;
unsigned
lineno
;
bool
mutedErrors
;
uint32_t
pcOffset
;
DescribeScriptedCallerForCompilation
(
cx
&
maybeScript
&
filename
&
lineno
&
pcOffset
&
mutedErrors
)
;
const
char
*
introductionType
=
"
Function
"
;
if
(
generatorKind
!
=
NotGenerator
)
introductionType
=
"
GeneratorFunction
"
;
const
char
*
introducerFilename
=
filename
;
if
(
maybeScript
&
&
maybeScript
-
>
scriptSource
(
)
-
>
introducerFilename
(
)
)
introducerFilename
=
maybeScript
-
>
scriptSource
(
)
-
>
introducerFilename
(
)
;
CompileOptions
options
(
cx
)
;
options
.
setMutedErrors
(
mutedErrors
)
.
setFileAndLine
(
filename
1
)
.
setNoScriptRval
(
false
)
.
setIntroductionInfo
(
introducerFilename
introductionType
lineno
maybeScript
pcOffset
)
;
Vector
<
char16_t
>
paramStr
(
cx
)
;
RootedString
bodyText
(
cx
)
;
if
(
args
.
length
(
)
=
=
0
)
{
bodyText
=
cx
-
>
names
(
)
.
empty
;
}
else
{
unsigned
n
=
args
.
length
(
)
-
1
;
mozilla
:
:
CheckedInt
<
uint32_t
>
paramStrLen
=
0
;
RootedString
str
(
cx
)
;
for
(
unsigned
i
=
0
;
i
<
n
;
i
+
+
)
{
str
=
ToString
<
CanGC
>
(
cx
args
[
i
]
)
;
if
(
!
str
)
return
false
;
args
[
i
]
.
setString
(
str
)
;
paramStrLen
+
=
str
-
>
length
(
)
;
}
if
(
n
>
0
)
paramStrLen
+
=
n
-
1
;
if
(
!
paramStrLen
.
isValid
(
)
|
|
paramStrLen
.
value
(
)
>
JSString
:
:
MAX_LENGTH
)
{
ReportAllocationOverflow
(
cx
)
;
return
false
;
}
uint32_t
paramsLen
=
paramStrLen
.
value
(
)
;
MOZ_ASSERT
(
paramStr
.
length
(
)
=
=
0
)
;
if
(
!
paramStr
.
growBy
(
paramsLen
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
char16_t
*
cp
=
paramStr
.
begin
(
)
;
for
(
unsigned
i
=
0
;
i
<
n
;
i
+
+
)
{
JSLinearString
*
argLinear
=
args
[
i
]
.
toString
(
)
-
>
ensureLinear
(
cx
)
;
if
(
!
argLinear
)
return
false
;
CopyChars
(
cp
*
argLinear
)
;
cp
+
=
argLinear
-
>
length
(
)
;
if
(
i
+
1
<
n
)
*
cp
+
+
=
'
'
;
}
MOZ_ASSERT
(
cp
=
=
paramStr
.
end
(
)
)
;
bodyText
=
ToString
(
cx
args
[
n
]
)
;
if
(
!
bodyText
)
return
false
;
}
RootedAtom
anonymousAtom
(
cx
cx
-
>
names
(
)
.
anonymous
)
;
RootedObject
proto
(
cx
)
;
if
(
isStarGenerator
)
{
proto
=
GlobalObject
:
:
getOrCreateStarGeneratorFunctionPrototype
(
cx
global
)
;
if
(
!
proto
)
return
false
;
}
else
{
if
(
!
GetPrototypeFromCallableConstructor
(
cx
args
&
proto
)
)
return
false
;
}
RootedObject
globalLexical
(
cx
&
global
-
>
lexicalEnvironment
(
)
)
;
RootedFunction
fun
(
cx
NewFunctionWithProto
(
cx
nullptr
0
JSFunction
:
:
INTERPRETED_LAMBDA
globalLexical
anonymousAtom
proto
AllocKind
:
:
FUNCTION
TenuredObject
)
)
;
if
(
!
fun
)
return
false
;
if
(
!
JSFunction
:
:
setTypeForScriptedFunction
(
cx
fun
)
)
return
false
;
AutoStableStringChars
stableChars
(
cx
)
;
if
(
!
stableChars
.
initTwoByte
(
cx
bodyText
)
)
return
false
;
bool
hasRest
=
false
;
Rooted
<
PropertyNameVector
>
formals
(
cx
PropertyNameVector
(
cx
)
)
;
if
(
args
.
length
(
)
>
1
)
{
AutoKeepAtoms
keepAtoms
(
cx
-
>
perThreadData
)
;
TokenStream
ts
(
cx
options
paramStr
.
begin
(
)
paramStr
.
length
(
)
nullptr
)
;
bool
yieldIsValidName
=
ts
.
versionNumber
(
)
<
JSVERSION_1_7
&
&
!
isStarGenerator
;
TokenKind
tt
;
if
(
!
ts
.
getToken
(
&
tt
)
)
return
false
;
if
(
tt
!
=
TOK_EOF
)
{
while
(
true
)
{
if
(
hasRest
)
{
ts
.
reportError
(
JSMSG_PARAMETER_AFTER_REST
)
;
return
false
;
}
if
(
tt
=
=
TOK_YIELD
&
&
yieldIsValidName
)
tt
=
TOK_NAME
;
if
(
tt
!
=
TOK_NAME
)
{
if
(
tt
=
=
TOK_TRIPLEDOT
)
{
hasRest
=
true
;
if
(
!
ts
.
getToken
(
&
tt
)
)
return
false
;
if
(
tt
=
=
TOK_YIELD
&
&
yieldIsValidName
)
tt
=
TOK_NAME
;
if
(
tt
!
=
TOK_NAME
)
{
ts
.
reportError
(
JSMSG_NO_REST_NAME
)
;
return
false
;
}
}
else
{
return
OnBadFormal
(
cx
)
;
}
}
if
(
!
formals
.
append
(
ts
.
currentName
(
)
)
)
return
false
;
if
(
!
ts
.
getToken
(
&
tt
)
)
return
false
;
if
(
tt
=
=
TOK_EOF
)
break
;
if
(
tt
!
=
TOK_COMMA
)
return
OnBadFormal
(
cx
)
;
if
(
!
ts
.
getToken
(
&
tt
)
)
return
false
;
}
}
}
if
(
hasRest
)
fun
-
>
setHasRest
(
)
;
mozilla
:
:
Range
<
const
char16_t
>
chars
=
stableChars
.
twoByteRange
(
)
;
SourceBufferHolder
:
:
Ownership
ownership
=
stableChars
.
maybeGiveOwnershipToCaller
(
)
?
SourceBufferHolder
:
:
GiveOwnership
:
SourceBufferHolder
:
:
NoOwnership
;
bool
ok
;
SourceBufferHolder
srcBuf
(
chars
.
start
(
)
.
get
(
)
chars
.
length
(
)
ownership
)
;
if
(
isStarGenerator
)
ok
=
frontend
:
:
CompileStarGeneratorBody
(
cx
&
fun
options
formals
srcBuf
)
;
else
ok
=
frontend
:
:
CompileFunctionBody
(
cx
&
fun
options
formals
srcBuf
)
;
args
.
rval
(
)
.
setObject
(
*
fun
)
;
return
ok
;
}
bool
js
:
:
Function
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
return
FunctionConstructor
(
cx
argc
vp
NotGenerator
)
;
}
bool
js
:
:
Generator
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
return
FunctionConstructor
(
cx
argc
vp
StarGenerator
)
;
}
bool
JSFunction
:
:
isBuiltinFunctionConstructor
(
)
{
return
maybeNative
(
)
=
=
Function
|
|
maybeNative
(
)
=
=
Generator
;
}
bool
JSFunction
:
:
needsExtraBodyVarEnvironment
(
)
const
{
MOZ_ASSERT
(
!
isInterpretedLazy
(
)
)
;
if
(
isNative
(
)
)
return
false
;
if
(
!
nonLazyScript
(
)
-
>
functionHasExtraBodyVarScope
(
)
)
return
false
;
return
nonLazyScript
(
)
-
>
functionExtraBodyVarScope
(
)
-
>
hasEnvironment
(
)
;
}
bool
JSFunction
:
:
needsNamedLambdaEnvironment
(
)
const
{
MOZ_ASSERT
(
!
isInterpretedLazy
(
)
)
;
if
(
!
isNamedLambda
(
)
)
return
false
;
LexicalScope
*
scope
=
nonLazyScript
(
)
-
>
maybeNamedLambdaScope
(
)
;
if
(
!
scope
)
return
false
;
return
scope
-
>
hasEnvironment
(
)
;
}
JSFunction
*
js
:
:
NewNativeFunction
(
ExclusiveContext
*
cx
Native
native
unsigned
nargs
HandleAtom
atom
gc
:
:
AllocKind
allocKind
NewObjectKind
newKind
)
{
return
NewFunctionWithProto
(
cx
native
nargs
JSFunction
:
:
NATIVE_FUN
nullptr
atom
nullptr
allocKind
newKind
)
;
}
JSFunction
*
js
:
:
NewNativeConstructor
(
ExclusiveContext
*
cx
Native
native
unsigned
nargs
HandleAtom
atom
gc
:
:
AllocKind
allocKind
NewObjectKind
newKind
JSFunction
:
:
Flags
flags
)
{
MOZ_ASSERT
(
flags
&
JSFunction
:
:
NATIVE_CTOR
)
;
return
NewFunctionWithProto
(
cx
native
nargs
flags
nullptr
atom
nullptr
allocKind
newKind
)
;
}
JSFunction
*
js
:
:
NewScriptedFunction
(
ExclusiveContext
*
cx
unsigned
nargs
JSFunction
:
:
Flags
flags
HandleAtom
atom
HandleObject
proto
gc
:
:
AllocKind
allocKind
NewObjectKind
newKind
HandleObject
enclosingEnvArg
)
{
RootedObject
enclosingEnv
(
cx
enclosingEnvArg
)
;
if
(
!
enclosingEnv
)
enclosingEnv
=
&
cx
-
>
global
(
)
-
>
lexicalEnvironment
(
)
;
return
NewFunctionWithProto
(
cx
nullptr
nargs
flags
enclosingEnv
atom
proto
allocKind
newKind
)
;
}
#
ifdef
DEBUG
static
bool
NewFunctionEnvironmentIsWellFormed
(
ExclusiveContext
*
cx
HandleObject
env
)
{
RootedObject
terminatingEnv
(
cx
SkipEnvironmentObjects
(
env
)
)
;
return
!
terminatingEnv
|
|
terminatingEnv
=
=
cx
-
>
global
(
)
|
|
terminatingEnv
-
>
is
<
DebugEnvironmentProxy
>
(
)
;
}
#
endif
JSFunction
*
js
:
:
NewFunctionWithProto
(
ExclusiveContext
*
cx
Native
native
unsigned
nargs
JSFunction
:
:
Flags
flags
HandleObject
enclosingEnv
HandleAtom
atom
HandleObject
proto
gc
:
:
AllocKind
allocKind
NewObjectKind
newKind
NewFunctionProtoHandling
protoHandling
)
{
MOZ_ASSERT
(
allocKind
=
=
AllocKind
:
:
FUNCTION
|
|
allocKind
=
=
AllocKind
:
:
FUNCTION_EXTENDED
)
;
MOZ_ASSERT_IF
(
native
!
enclosingEnv
)
;
MOZ_ASSERT
(
NewFunctionEnvironmentIsWellFormed
(
cx
enclosingEnv
)
)
;
RootedObject
funobj
(
cx
)
;
if
(
native
&
&
!
IsAsmJSModuleNative
(
native
)
)
newKind
=
SingletonObject
;
if
(
protoHandling
=
=
NewFunctionClassProto
)
{
funobj
=
NewObjectWithClassProto
(
cx
&
JSFunction
:
:
class_
proto
allocKind
newKind
)
;
}
else
{
funobj
=
NewObjectWithGivenTaggedProto
(
cx
&
JSFunction
:
:
class_
AsTaggedProto
(
proto
)
allocKind
newKind
)
;
}
if
(
!
funobj
)
return
nullptr
;
RootedFunction
fun
(
cx
&
funobj
-
>
as
<
JSFunction
>
(
)
)
;
if
(
allocKind
=
=
AllocKind
:
:
FUNCTION_EXTENDED
)
flags
=
JSFunction
:
:
Flags
(
flags
|
JSFunction
:
:
EXTENDED
)
;
fun
-
>
setArgCount
(
uint16_t
(
nargs
)
)
;
fun
-
>
setFlags
(
flags
)
;
if
(
fun
-
>
isInterpreted
(
)
)
{
MOZ_ASSERT
(
!
native
)
;
if
(
fun
-
>
isInterpretedLazy
(
)
)
fun
-
>
initLazyScript
(
nullptr
)
;
else
fun
-
>
initScript
(
nullptr
)
;
fun
-
>
initEnvironment
(
enclosingEnv
)
;
}
else
{
MOZ_ASSERT
(
fun
-
>
isNative
(
)
)
;
MOZ_ASSERT
(
native
)
;
fun
-
>
initNative
(
native
nullptr
)
;
}
if
(
allocKind
=
=
AllocKind
:
:
FUNCTION_EXTENDED
)
fun
-
>
initializeExtended
(
)
;
fun
-
>
initAtom
(
atom
)
;
return
fun
;
}
bool
js
:
:
CanReuseScriptForClone
(
JSCompartment
*
compartment
HandleFunction
fun
HandleObject
newParent
)
{
if
(
compartment
!
=
fun
-
>
compartment
(
)
|
|
fun
-
>
isSingleton
(
)
|
|
ObjectGroup
:
:
useSingletonForClone
(
fun
)
)
{
return
false
;
}
if
(
newParent
-
>
is
<
GlobalObject
>
(
)
)
return
true
;
if
(
IsSyntacticEnvironment
(
newParent
)
)
return
true
;
return
!
fun
-
>
isInterpreted
(
)
|
|
(
fun
-
>
hasScript
(
)
&
&
fun
-
>
nonLazyScript
(
)
-
>
hasNonSyntacticScope
(
)
)
;
}
static
inline
JSFunction
*
NewFunctionClone
(
JSContext
*
cx
HandleFunction
fun
NewObjectKind
newKind
gc
:
:
AllocKind
allocKind
HandleObject
proto
)
{
RootedObject
cloneProto
(
cx
proto
)
;
if
(
!
proto
&
&
fun
-
>
isStarGenerator
(
)
)
{
cloneProto
=
GlobalObject
:
:
getOrCreateStarGeneratorFunctionPrototype
(
cx
cx
-
>
global
(
)
)
;
if
(
!
cloneProto
)
return
nullptr
;
}
JSObject
*
cloneobj
=
NewObjectWithClassProto
(
cx
&
JSFunction
:
:
class_
cloneProto
allocKind
newKind
)
;
if
(
!
cloneobj
)
return
nullptr
;
RootedFunction
clone
(
cx
&
cloneobj
-
>
as
<
JSFunction
>
(
)
)
;
uint16_t
flags
=
fun
-
>
flags
(
)
&
~
JSFunction
:
:
EXTENDED
;
if
(
allocKind
=
=
AllocKind
:
:
FUNCTION_EXTENDED
)
flags
|
=
JSFunction
:
:
EXTENDED
;
clone
-
>
setArgCount
(
fun
-
>
nargs
(
)
)
;
clone
-
>
setFlags
(
flags
)
;
clone
-
>
initAtom
(
fun
-
>
displayAtom
(
)
)
;
if
(
allocKind
=
=
AllocKind
:
:
FUNCTION_EXTENDED
)
{
if
(
fun
-
>
isExtended
(
)
&
&
fun
-
>
compartment
(
)
=
=
cx
-
>
compartment
(
)
)
{
for
(
unsigned
i
=
0
;
i
<
FunctionExtended
:
:
NUM_EXTENDED_SLOTS
;
i
+
+
)
clone
-
>
initExtendedSlot
(
i
fun
-
>
getExtendedSlot
(
i
)
)
;
}
else
{
clone
-
>
initializeExtended
(
)
;
}
}
return
clone
;
}
JSFunction
*
js
:
:
CloneFunctionReuseScript
(
JSContext
*
cx
HandleFunction
fun
HandleObject
enclosingEnv
gc
:
:
AllocKind
allocKind
NewObjectKind
newKind
HandleObject
proto
)
{
MOZ_ASSERT
(
NewFunctionEnvironmentIsWellFormed
(
cx
enclosingEnv
)
)
;
MOZ_ASSERT
(
!
fun
-
>
isBoundFunction
(
)
)
;
MOZ_ASSERT
(
CanReuseScriptForClone
(
cx
-
>
compartment
(
)
fun
enclosingEnv
)
)
;
RootedFunction
clone
(
cx
NewFunctionClone
(
cx
fun
newKind
allocKind
proto
)
)
;
if
(
!
clone
)
return
nullptr
;
if
(
fun
-
>
hasScript
(
)
)
{
clone
-
>
initScript
(
fun
-
>
nonLazyScript
(
)
)
;
clone
-
>
initEnvironment
(
enclosingEnv
)
;
}
else
if
(
fun
-
>
isInterpretedLazy
(
)
)
{
MOZ_ASSERT
(
fun
-
>
compartment
(
)
=
=
clone
-
>
compartment
(
)
)
;
LazyScript
*
lazy
=
fun
-
>
lazyScriptOrNull
(
)
;
clone
-
>
initLazyScript
(
lazy
)
;
clone
-
>
initEnvironment
(
enclosingEnv
)
;
}
else
{
clone
-
>
initNative
(
fun
-
>
native
(
)
fun
-
>
jitInfo
(
)
)
;
}
if
(
fun
-
>
staticPrototype
(
)
=
=
clone
-
>
staticPrototype
(
)
)
clone
-
>
setGroup
(
fun
-
>
group
(
)
)
;
return
clone
;
}
JSFunction
*
js
:
:
CloneFunctionAndScript
(
JSContext
*
cx
HandleFunction
fun
HandleObject
enclosingEnv
HandleScope
newScope
gc
:
:
AllocKind
allocKind
HandleObject
proto
)
{
MOZ_ASSERT
(
NewFunctionEnvironmentIsWellFormed
(
cx
enclosingEnv
)
)
;
MOZ_ASSERT
(
!
fun
-
>
isBoundFunction
(
)
)
;
JSScript
:
:
AutoDelazify
funScript
(
cx
)
;
if
(
fun
-
>
isInterpreted
(
)
)
{
funScript
=
fun
;
if
(
!
funScript
)
return
nullptr
;
}
RootedFunction
clone
(
cx
NewFunctionClone
(
cx
fun
SingletonObject
allocKind
proto
)
)
;
if
(
!
clone
)
return
nullptr
;
if
(
fun
-
>
hasScript
(
)
)
{
clone
-
>
initScript
(
nullptr
)
;
clone
-
>
initEnvironment
(
enclosingEnv
)
;
}
else
{
clone
-
>
initNative
(
fun
-
>
native
(
)
fun
-
>
jitInfo
(
)
)
;
}
#
ifdef
DEBUG
RootedObject
terminatingEnv
(
cx
enclosingEnv
)
;
while
(
IsSyntacticEnvironment
(
terminatingEnv
)
)
terminatingEnv
=
terminatingEnv
-
>
enclosingEnvironment
(
)
;
MOZ_ASSERT_IF
(
!
terminatingEnv
-
>
is
<
GlobalObject
>
(
)
newScope
-
>
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
)
;
#
endif
if
(
clone
-
>
isInterpreted
(
)
)
{
RootedScript
script
(
cx
fun
-
>
nonLazyScript
(
)
)
;
MOZ_ASSERT
(
script
-
>
compartment
(
)
=
=
fun
-
>
compartment
(
)
)
;
MOZ_ASSERT
(
cx
-
>
compartment
(
)
=
=
clone
-
>
compartment
(
)
"
Otherwise
we
could
relazify
clone
below
!
"
)
;
RootedScript
clonedScript
(
cx
CloneScriptIntoFunction
(
cx
newScope
clone
script
)
)
;
if
(
!
clonedScript
)
return
nullptr
;
Debugger
:
:
onNewScript
(
cx
clonedScript
)
;
}
return
clone
;
}
JSAtom
*
js
:
:
IdToFunctionName
(
JSContext
*
cx
HandleId
id
const
char
*
prefix
)
{
if
(
JSID_IS_ATOM
(
id
)
&
&
!
prefix
)
return
JSID_TO_ATOM
(
id
)
;
if
(
JSID_IS_SYMBOL
(
id
)
&
&
!
prefix
)
{
RootedAtom
desc
(
cx
JSID_TO_SYMBOL
(
id
)
-
>
description
(
)
)
;
StringBuffer
sb
(
cx
)
;
if
(
!
sb
.
append
(
'
[
'
)
|
|
!
sb
.
append
(
desc
)
|
|
!
sb
.
append
(
'
]
'
)
)
return
nullptr
;
return
sb
.
finishAtom
(
)
;
}
RootedValue
idv
(
cx
IdToValue
(
id
)
)
;
if
(
!
prefix
)
return
ToAtom
<
CanGC
>
(
cx
idv
)
;
StringBuffer
sb
(
cx
)
;
if
(
!
sb
.
append
(
prefix
strlen
(
prefix
)
)
|
|
!
sb
.
append
(
'
'
)
|
|
!
sb
.
append
(
ToAtom
<
CanGC
>
(
cx
idv
)
)
)
return
nullptr
;
return
sb
.
finishAtom
(
)
;
}
JSFunction
*
js
:
:
DefineFunction
(
JSContext
*
cx
HandleObject
obj
HandleId
id
Native
native
unsigned
nargs
unsigned
flags
AllocKind
allocKind
)
{
GetterOp
gop
;
SetterOp
sop
;
if
(
flags
&
JSFUN_STUB_GSOPS
)
{
flags
&
=
~
JSFUN_STUB_GSOPS
;
gop
=
nullptr
;
sop
=
nullptr
;
}
else
{
gop
=
obj
-
>
getClass
(
)
-
>
getGetProperty
(
)
;
sop
=
obj
-
>
getClass
(
)
-
>
getSetProperty
(
)
;
MOZ_ASSERT
(
gop
!
=
JS_PropertyStub
)
;
MOZ_ASSERT
(
sop
!
=
JS_StrictPropertyStub
)
;
}
RootedAtom
atom
(
cx
IdToFunctionName
(
cx
id
)
)
;
if
(
!
atom
)
return
nullptr
;
RootedFunction
fun
(
cx
)
;
if
(
!
native
)
fun
=
NewScriptedFunction
(
cx
nargs
JSFunction
:
:
INTERPRETED_LAZY
atom
nullptr
allocKind
GenericObject
obj
)
;
else
if
(
flags
&
JSFUN_CONSTRUCTOR
)
fun
=
NewNativeConstructor
(
cx
native
nargs
atom
allocKind
)
;
else
fun
=
NewNativeFunction
(
cx
native
nargs
atom
allocKind
)
;
if
(
!
fun
)
return
nullptr
;
RootedValue
funVal
(
cx
ObjectValue
(
*
fun
)
)
;
if
(
!
DefineProperty
(
cx
obj
id
funVal
gop
sop
flags
&
~
JSFUN_FLAGS_MASK
)
)
return
nullptr
;
return
fun
;
}
void
js
:
:
ReportIncompatibleMethod
(
JSContext
*
cx
const
CallArgs
&
args
const
Class
*
clasp
)
{
RootedValue
thisv
(
cx
args
.
thisv
(
)
)
;
#
ifdef
DEBUG
if
(
thisv
.
isObject
(
)
)
{
MOZ_ASSERT
(
thisv
.
toObject
(
)
.
getClass
(
)
!
=
clasp
|
|
!
thisv
.
toObject
(
)
.
isNative
(
)
|
|
!
thisv
.
toObject
(
)
.
staticPrototype
(
)
|
|
thisv
.
toObject
(
)
.
staticPrototype
(
)
-
>
getClass
(
)
!
=
clasp
)
;
}
else
if
(
thisv
.
isString
(
)
)
{
MOZ_ASSERT
(
clasp
!
=
&
StringObject
:
:
class_
)
;
}
else
if
(
thisv
.
isNumber
(
)
)
{
MOZ_ASSERT
(
clasp
!
=
&
NumberObject
:
:
class_
)
;
}
else
if
(
thisv
.
isBoolean
(
)
)
{
MOZ_ASSERT
(
clasp
!
=
&
BooleanObject
:
:
class_
)
;
}
else
if
(
thisv
.
isSymbol
(
)
)
{
MOZ_ASSERT
(
clasp
!
=
&
SymbolObject
:
:
class_
)
;
}
else
{
MOZ_ASSERT
(
thisv
.
isUndefined
(
)
|
|
thisv
.
isNull
(
)
)
;
}
#
endif
if
(
JSFunction
*
fun
=
ReportIfNotFunction
(
cx
args
.
calleev
(
)
)
)
{
JSAutoByteString
funNameBytes
;
if
(
const
char
*
funName
=
GetFunctionNameBytes
(
cx
fun
&
funNameBytes
)
)
{
JS_ReportErrorNumber
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_PROTO
clasp
-
>
name
funName
InformalValueTypeName
(
thisv
)
)
;
}
}
}
void
js
:
:
ReportIncompatible
(
JSContext
*
cx
const
CallArgs
&
args
)
{
if
(
JSFunction
*
fun
=
ReportIfNotFunction
(
cx
args
.
calleev
(
)
)
)
{
JSAutoByteString
funNameBytes
;
if
(
const
char
*
funName
=
GetFunctionNameBytes
(
cx
fun
&
funNameBytes
)
)
{
JS_ReportErrorNumber
(
cx
GetErrorMessage
nullptr
JSMSG_INCOMPATIBLE_METHOD
funName
"
method
"
InformalValueTypeName
(
args
.
thisv
(
)
)
)
;
}
}
}
namespace
JS
{
namespace
detail
{
JS_PUBLIC_API
(
void
)
CheckIsValidConstructible
(
Value
calleev
)
{
JSObject
*
callee
=
&
calleev
.
toObject
(
)
;
if
(
callee
-
>
is
<
JSFunction
>
(
)
)
MOZ_ASSERT
(
callee
-
>
as
<
JSFunction
>
(
)
.
isConstructor
(
)
)
;
else
MOZ_ASSERT
(
callee
-
>
constructHook
(
)
!
=
nullptr
)
;
}
}
}
