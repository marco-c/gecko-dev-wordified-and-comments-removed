#
ifndef
gc_Scheduling_h
#
define
gc_Scheduling_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
js
/
HashTable
.
h
"
namespace
js
{
class
ZoneAllocPolicy
;
namespace
gc
{
struct
Cell
;
enum
TriggerKind
{
NoTrigger
=
0
IncrementalTrigger
NonIncrementalTrigger
}
;
class
GCSchedulingTunables
{
UnprotectedData
<
size_t
>
gcMaxBytes_
;
UnprotectedData
<
size_t
>
maxMallocBytes_
;
MainThreadData
<
size_t
>
gcMinNurseryBytes_
;
MainThreadData
<
size_t
>
gcMaxNurseryBytes_
;
MainThreadOrGCTaskData
<
size_t
>
gcZoneAllocThresholdBase_
;
UnprotectedData
<
float
>
allocThresholdFactor_
;
UnprotectedData
<
float
>
allocThresholdFactorAvoidInterrupt_
;
UnprotectedData
<
size_t
>
zoneAllocDelayBytes_
;
MainThreadData
<
bool
>
dynamicHeapGrowthEnabled_
;
MainThreadData
<
mozilla
:
:
TimeDuration
>
highFrequencyThreshold_
;
MainThreadData
<
size_t
>
highFrequencyLowLimitBytes_
;
MainThreadData
<
size_t
>
highFrequencyHighLimitBytes_
;
MainThreadData
<
float
>
highFrequencyHeapGrowthMax_
;
MainThreadData
<
float
>
highFrequencyHeapGrowthMin_
;
MainThreadData
<
float
>
lowFrequencyHeapGrowth_
;
MainThreadData
<
bool
>
dynamicMarkSliceEnabled_
;
UnprotectedData
<
uint32_t
>
minEmptyChunkCount_
;
UnprotectedData
<
uint32_t
>
maxEmptyChunkCount_
;
UnprotectedData
<
uint32_t
>
nurseryFreeThresholdForIdleCollection_
;
UnprotectedData
<
float
>
nurseryFreeThresholdForIdleCollectionFraction_
;
UnprotectedData
<
float
>
pretenureThreshold_
;
UnprotectedData
<
uint32_t
>
pretenureGroupThreshold_
;
MainThreadData
<
mozilla
:
:
TimeDuration
>
minLastDitchGCPeriod_
;
public
:
GCSchedulingTunables
(
)
;
size_t
gcMaxBytes
(
)
const
{
return
gcMaxBytes_
;
}
size_t
maxMallocBytes
(
)
const
{
return
maxMallocBytes_
;
}
size_t
gcMinNurseryBytes
(
)
const
{
return
gcMinNurseryBytes_
;
}
size_t
gcMaxNurseryBytes
(
)
const
{
return
gcMaxNurseryBytes_
;
}
size_t
gcZoneAllocThresholdBase
(
)
const
{
return
gcZoneAllocThresholdBase_
;
}
double
allocThresholdFactor
(
)
const
{
return
allocThresholdFactor_
;
}
double
allocThresholdFactorAvoidInterrupt
(
)
const
{
return
allocThresholdFactorAvoidInterrupt_
;
}
size_t
zoneAllocDelayBytes
(
)
const
{
return
zoneAllocDelayBytes_
;
}
bool
isDynamicHeapGrowthEnabled
(
)
const
{
return
dynamicHeapGrowthEnabled_
;
}
const
mozilla
:
:
TimeDuration
&
highFrequencyThreshold
(
)
const
{
return
highFrequencyThreshold_
;
}
size_t
highFrequencyLowLimitBytes
(
)
const
{
return
highFrequencyLowLimitBytes_
;
}
size_t
highFrequencyHighLimitBytes
(
)
const
{
return
highFrequencyHighLimitBytes_
;
}
double
highFrequencyHeapGrowthMax
(
)
const
{
return
highFrequencyHeapGrowthMax_
;
}
double
highFrequencyHeapGrowthMin
(
)
const
{
return
highFrequencyHeapGrowthMin_
;
}
double
lowFrequencyHeapGrowth
(
)
const
{
return
lowFrequencyHeapGrowth_
;
}
bool
isDynamicMarkSliceEnabled
(
)
const
{
return
dynamicMarkSliceEnabled_
;
}
unsigned
minEmptyChunkCount
(
const
AutoLockGC
&
)
const
{
return
minEmptyChunkCount_
;
}
unsigned
maxEmptyChunkCount
(
)
const
{
return
maxEmptyChunkCount_
;
}
uint32_t
nurseryFreeThresholdForIdleCollection
(
)
const
{
return
nurseryFreeThresholdForIdleCollection_
;
}
float
nurseryFreeThresholdForIdleCollectionFraction
(
)
const
{
return
nurseryFreeThresholdForIdleCollectionFraction_
;
}
bool
attemptPretenuring
(
)
const
{
return
pretenureThreshold_
<
1
.
0f
;
}
float
pretenureThreshold
(
)
const
{
return
pretenureThreshold_
;
}
uint32_t
pretenureGroupThreshold
(
)
const
{
return
pretenureGroupThreshold_
;
}
mozilla
:
:
TimeDuration
minLastDitchGCPeriod
(
)
const
{
return
minLastDitchGCPeriod_
;
}
MOZ_MUST_USE
bool
setParameter
(
JSGCParamKey
key
uint32_t
value
const
AutoLockGC
&
lock
)
;
void
resetParameter
(
JSGCParamKey
key
const
AutoLockGC
&
lock
)
;
void
setMaxMallocBytes
(
size_t
value
)
;
private
:
void
setHighFrequencyLowLimit
(
size_t
value
)
;
void
setHighFrequencyHighLimit
(
size_t
value
)
;
void
setHighFrequencyHeapGrowthMin
(
float
value
)
;
void
setHighFrequencyHeapGrowthMax
(
float
value
)
;
void
setLowFrequencyHeapGrowth
(
float
value
)
;
void
setMinEmptyChunkCount
(
uint32_t
value
)
;
void
setMaxEmptyChunkCount
(
uint32_t
value
)
;
}
;
class
GCSchedulingState
{
MainThreadData
<
bool
>
inHighFrequencyGCMode_
;
public
:
GCSchedulingState
(
)
:
inHighFrequencyGCMode_
(
false
)
{
}
bool
inHighFrequencyGCMode
(
)
const
{
return
inHighFrequencyGCMode_
;
}
void
updateHighFrequencyMode
(
const
mozilla
:
:
TimeStamp
&
lastGCTime
const
mozilla
:
:
TimeStamp
&
currentTime
const
GCSchedulingTunables
&
tunables
)
{
inHighFrequencyGCMode_
=
tunables
.
isDynamicHeapGrowthEnabled
(
)
&
&
!
lastGCTime
.
IsNull
(
)
&
&
lastGCTime
+
tunables
.
highFrequencyThreshold
(
)
>
currentTime
;
}
}
;
class
MemoryCounter
{
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
ReleaseAcquire
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
bytes_
;
size_t
maxBytes_
;
MainThreadData
<
size_t
>
bytesAtStartOfGC_
;
mozilla
:
:
Atomic
<
TriggerKind
mozilla
:
:
ReleaseAcquire
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
triggered_
;
public
:
MemoryCounter
(
)
;
size_t
bytes
(
)
const
{
return
bytes_
;
}
size_t
maxBytes
(
)
const
{
return
maxBytes_
;
}
TriggerKind
triggered
(
)
const
{
return
triggered_
;
}
void
setMax
(
size_t
newMax
const
AutoLockGC
&
lock
)
;
void
update
(
size_t
bytes
)
{
bytes_
+
=
bytes
;
}
void
adopt
(
MemoryCounter
&
other
)
;
TriggerKind
shouldTriggerGC
(
const
GCSchedulingTunables
&
tunables
)
const
{
if
(
MOZ_LIKELY
(
bytes_
<
maxBytes_
*
tunables
.
allocThresholdFactor
(
)
)
)
{
return
NoTrigger
;
}
if
(
bytes_
<
maxBytes_
)
{
return
IncrementalTrigger
;
}
return
NonIncrementalTrigger
;
}
bool
shouldResetIncrementalGC
(
const
GCSchedulingTunables
&
tunables
)
const
{
return
bytes_
>
maxBytes_
*
tunables
.
allocThresholdFactorAvoidInterrupt
(
)
;
}
void
recordTrigger
(
TriggerKind
trigger
)
;
void
updateOnGCStart
(
)
;
void
updateOnGCEnd
(
const
GCSchedulingTunables
&
tunables
const
AutoLockGC
&
lock
)
;
}
;
class
ZoneHeapThreshold
{
GCLockData
<
float
>
gcHeapGrowthFactor_
;
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
Relaxed
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
gcTriggerBytes_
;
public
:
ZoneHeapThreshold
(
)
:
gcHeapGrowthFactor_
(
3
.
0f
)
gcTriggerBytes_
(
0
)
{
}
float
gcHeapGrowthFactor
(
)
const
{
return
gcHeapGrowthFactor_
;
}
size_t
gcTriggerBytes
(
)
const
{
return
gcTriggerBytes_
;
}
float
eagerAllocTrigger
(
bool
highFrequencyGC
)
const
;
void
updateAfterGC
(
size_t
lastBytes
JSGCInvocationKind
gckind
const
GCSchedulingTunables
&
tunables
const
GCSchedulingState
&
state
const
AutoLockGC
&
lock
)
;
void
updateForRemovedArena
(
const
GCSchedulingTunables
&
tunables
)
;
private
:
static
float
computeZoneHeapGrowthFactorForHeapSize
(
size_t
lastBytes
const
GCSchedulingTunables
&
tunables
const
GCSchedulingState
&
state
)
;
static
size_t
computeZoneTriggerBytes
(
float
growthFactor
size_t
lastBytes
JSGCInvocationKind
gckind
const
GCSchedulingTunables
&
tunables
const
AutoLockGC
&
lock
)
;
}
;
class
MemoryTracker
{
public
:
#
ifdef
DEBUG
MemoryTracker
(
)
;
~
MemoryTracker
(
)
;
void
fixupAfterMovingGC
(
)
;
#
endif
void
addMemory
(
Cell
*
cell
size_t
nbytes
MemoryUse
use
)
{
MOZ_ASSERT
(
cell
)
;
MOZ_ASSERT
(
nbytes
)
;
mozilla
:
:
DebugOnly
<
size_t
>
initialBytes
(
bytes_
)
;
MOZ_ASSERT
(
initialBytes
+
nbytes
>
initialBytes
)
;
bytes_
+
=
nbytes
;
#
ifdef
DEBUG
trackMemory
(
cell
nbytes
use
)
;
#
endif
}
void
removeMemory
(
Cell
*
cell
size_t
nbytes
MemoryUse
use
)
{
MOZ_ASSERT
(
cell
)
;
MOZ_ASSERT
(
nbytes
)
;
MOZ_ASSERT
(
bytes_
>
=
nbytes
)
;
bytes_
-
=
nbytes
;
#
ifdef
DEBUG
untrackMemory
(
cell
nbytes
use
)
;
#
endif
}
void
swapMemory
(
Cell
*
a
Cell
*
b
MemoryUse
use
)
{
#
ifdef
DEBUG
swapTrackedMemory
(
a
b
use
)
;
#
endif
}
#
ifdef
DEBUG
void
registerPolicy
(
ZoneAllocPolicy
*
policy
)
;
void
unregisterPolicy
(
ZoneAllocPolicy
*
policy
)
;
#
endif
void
incPolicyMemory
(
ZoneAllocPolicy
*
policy
size_t
nbytes
)
{
#
ifdef
DEBUG
incTrackedPolicyMemory
(
policy
nbytes
)
;
#
endif
bytes_
+
=
nbytes
;
}
void
decPolicyMemory
(
ZoneAllocPolicy
*
policy
size_t
nbytes
)
{
#
ifdef
DEBUG
decTrackedPolicyMemory
(
policy
nbytes
)
;
#
endif
MOZ_ASSERT
(
bytes_
>
=
nbytes
)
;
bytes_
-
=
nbytes
;
}
size_t
bytes
(
)
const
{
return
bytes_
;
}
void
adopt
(
MemoryTracker
&
other
Zone
*
newZone
)
;
private
:
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
Relaxed
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
bytes_
;
#
ifdef
DEBUG
struct
Key
{
Key
(
Cell
*
cell
MemoryUse
use
)
;
Cell
*
cell
(
)
const
;
MemoryUse
use
(
)
const
;
private
:
#
ifdef
JS_64BIT
uintptr_t
cell_
:
56
;
uintptr_t
use_
:
8
;
#
else
uintptr_t
cell_
:
32
;
uintptr_t
use_
:
8
;
#
endif
}
;
struct
Hasher
{
using
Lookup
=
Key
;
static
HashNumber
hash
(
const
Lookup
&
l
)
;
static
bool
match
(
const
Key
&
key
const
Lookup
&
l
)
;
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
;
}
;
using
Map
=
HashMap
<
Key
size_t
Hasher
SystemAllocPolicy
>
;
using
ZoneAllocPolicyMap
=
HashMap
<
ZoneAllocPolicy
*
size_t
DefaultHasher
<
ZoneAllocPolicy
*
>
SystemAllocPolicy
>
;
void
trackMemory
(
Cell
*
cell
size_t
nbytes
MemoryUse
use
)
;
void
untrackMemory
(
Cell
*
cell
size_t
nbytes
MemoryUse
use
)
;
void
swapTrackedMemory
(
Cell
*
a
Cell
*
b
MemoryUse
use
)
;
size_t
getAndRemoveEntry
(
const
Key
&
key
LockGuard
<
Mutex
>
&
lock
)
;
void
incTrackedPolicyMemory
(
ZoneAllocPolicy
*
policy
size_t
nbytes
)
;
void
decTrackedPolicyMemory
(
ZoneAllocPolicy
*
policy
size_t
nbytes
)
;
Mutex
mutex
;
Map
map
;
ZoneAllocPolicyMap
policyMap
;
#
endif
}
;
}
}
#
endif
