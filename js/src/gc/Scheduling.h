#
ifndef
gc_Scheduling_h
#
define
gc_Scheduling_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
namespace
js
{
class
AutoLockGC
;
class
ZoneAllocPolicy
;
namespace
gc
{
struct
Cell
;
namespace
TuningDefaults
{
static
const
size_t
GCZoneAllocThresholdBase
=
27
*
1024
*
1024
;
static
const
size_t
GCMinNurseryBytes
=
256
*
1024
;
static
const
float
NonIncrementalFactor
=
1
.
12f
;
static
const
float
AvoidInterruptFactor
=
1
.
0f
;
static
const
size_t
ZoneAllocDelayBytes
=
1024
*
1024
;
static
const
bool
DynamicHeapGrowthEnabled
=
false
;
static
const
auto
HighFrequencyThreshold
=
1
;
static
const
size_t
HighFrequencyLowLimitBytes
=
100
*
1024
*
1024
;
static
const
size_t
HighFrequencyHighLimitBytes
=
500
*
1024
*
1024
;
static
const
float
HighFrequencyHeapGrowthMax
=
3
.
0f
;
static
const
float
HighFrequencyHeapGrowthMin
=
1
.
5f
;
static
const
float
LowFrequencyHeapGrowth
=
1
.
5f
;
static
const
bool
DynamicMarkSliceEnabled
=
false
;
static
const
uint32_t
MinEmptyChunkCount
=
1
;
static
const
uint32_t
MaxEmptyChunkCount
=
30
;
static
const
int64_t
DefaultTimeBudgetMS
=
SliceBudget
:
:
UnlimitedTimeBudget
;
static
const
JSGCMode
Mode
=
JSGC_MODE_ZONE_INCREMENTAL
;
static
const
bool
CompactingEnabled
=
true
;
static
const
uint32_t
NurseryFreeThresholdForIdleCollection
=
ChunkSize
/
4
;
static
const
float
NurseryFreeThresholdForIdleCollectionFraction
=
0
.
25f
;
static
const
float
PretenureThreshold
=
0
.
6f
;
static
const
float
PretenureGroupThreshold
=
3000
;
static
const
auto
MinLastDitchGCPeriod
=
60
;
static
const
size_t
MallocThresholdBase
=
38
*
1024
*
1024
;
static
const
float
MallocGrowthFactor
=
1
.
5f
;
}
class
GCSchedulingTunables
{
UnprotectedData
<
size_t
>
gcMaxBytes_
;
MainThreadData
<
size_t
>
gcMinNurseryBytes_
;
MainThreadData
<
size_t
>
gcMaxNurseryBytes_
;
MainThreadOrGCTaskData
<
size_t
>
gcZoneAllocThresholdBase_
;
UnprotectedData
<
float
>
nonIncrementalFactor_
;
UnprotectedData
<
float
>
avoidInterruptFactor_
;
UnprotectedData
<
size_t
>
zoneAllocDelayBytes_
;
MainThreadOrGCTaskData
<
bool
>
dynamicHeapGrowthEnabled_
;
MainThreadOrGCTaskData
<
mozilla
:
:
TimeDuration
>
highFrequencyThreshold_
;
MainThreadOrGCTaskData
<
size_t
>
highFrequencyLowLimitBytes_
;
MainThreadOrGCTaskData
<
size_t
>
highFrequencyHighLimitBytes_
;
MainThreadOrGCTaskData
<
float
>
highFrequencyHeapGrowthMax_
;
MainThreadOrGCTaskData
<
float
>
highFrequencyHeapGrowthMin_
;
MainThreadOrGCTaskData
<
float
>
lowFrequencyHeapGrowth_
;
MainThreadData
<
bool
>
dynamicMarkSliceEnabled_
;
UnprotectedData
<
uint32_t
>
minEmptyChunkCount_
;
UnprotectedData
<
uint32_t
>
maxEmptyChunkCount_
;
UnprotectedData
<
uint32_t
>
nurseryFreeThresholdForIdleCollection_
;
UnprotectedData
<
float
>
nurseryFreeThresholdForIdleCollectionFraction_
;
UnprotectedData
<
float
>
pretenureThreshold_
;
UnprotectedData
<
uint32_t
>
pretenureGroupThreshold_
;
MainThreadData
<
mozilla
:
:
TimeDuration
>
minLastDitchGCPeriod_
;
MainThreadOrGCTaskData
<
size_t
>
mallocThresholdBase_
;
MainThreadOrGCTaskData
<
float
>
mallocGrowthFactor_
;
public
:
GCSchedulingTunables
(
)
;
size_t
gcMaxBytes
(
)
const
{
return
gcMaxBytes_
;
}
size_t
gcMinNurseryBytes
(
)
const
{
return
gcMinNurseryBytes_
;
}
size_t
gcMaxNurseryBytes
(
)
const
{
return
gcMaxNurseryBytes_
;
}
size_t
gcZoneAllocThresholdBase
(
)
const
{
return
gcZoneAllocThresholdBase_
;
}
double
nonIncrementalFactor
(
)
const
{
return
nonIncrementalFactor_
;
}
double
avoidInterruptFactor
(
)
const
{
return
avoidInterruptFactor_
;
}
size_t
zoneAllocDelayBytes
(
)
const
{
return
zoneAllocDelayBytes_
;
}
bool
isDynamicHeapGrowthEnabled
(
)
const
{
return
dynamicHeapGrowthEnabled_
;
}
const
mozilla
:
:
TimeDuration
&
highFrequencyThreshold
(
)
const
{
return
highFrequencyThreshold_
;
}
size_t
highFrequencyLowLimitBytes
(
)
const
{
return
highFrequencyLowLimitBytes_
;
}
size_t
highFrequencyHighLimitBytes
(
)
const
{
return
highFrequencyHighLimitBytes_
;
}
double
highFrequencyHeapGrowthMax
(
)
const
{
return
highFrequencyHeapGrowthMax_
;
}
double
highFrequencyHeapGrowthMin
(
)
const
{
return
highFrequencyHeapGrowthMin_
;
}
double
lowFrequencyHeapGrowth
(
)
const
{
return
lowFrequencyHeapGrowth_
;
}
bool
isDynamicMarkSliceEnabled
(
)
const
{
return
dynamicMarkSliceEnabled_
;
}
unsigned
minEmptyChunkCount
(
const
AutoLockGC
&
)
const
{
return
minEmptyChunkCount_
;
}
unsigned
maxEmptyChunkCount
(
)
const
{
return
maxEmptyChunkCount_
;
}
uint32_t
nurseryFreeThresholdForIdleCollection
(
)
const
{
return
nurseryFreeThresholdForIdleCollection_
;
}
float
nurseryFreeThresholdForIdleCollectionFraction
(
)
const
{
return
nurseryFreeThresholdForIdleCollectionFraction_
;
}
bool
attemptPretenuring
(
)
const
{
return
pretenureThreshold_
<
1
.
0f
;
}
float
pretenureThreshold
(
)
const
{
return
pretenureThreshold_
;
}
uint32_t
pretenureGroupThreshold
(
)
const
{
return
pretenureGroupThreshold_
;
}
mozilla
:
:
TimeDuration
minLastDitchGCPeriod
(
)
const
{
return
minLastDitchGCPeriod_
;
}
size_t
mallocThresholdBase
(
)
const
{
return
mallocThresholdBase_
;
}
float
mallocGrowthFactor
(
)
const
{
return
mallocGrowthFactor_
;
}
MOZ_MUST_USE
bool
setParameter
(
JSGCParamKey
key
uint32_t
value
const
AutoLockGC
&
lock
)
;
void
resetParameter
(
JSGCParamKey
key
const
AutoLockGC
&
lock
)
;
private
:
void
setHighFrequencyLowLimit
(
size_t
value
)
;
void
setHighFrequencyHighLimit
(
size_t
value
)
;
void
setHighFrequencyHeapGrowthMin
(
float
value
)
;
void
setHighFrequencyHeapGrowthMax
(
float
value
)
;
void
setLowFrequencyHeapGrowth
(
float
value
)
;
void
setMinEmptyChunkCount
(
uint32_t
value
)
;
void
setMaxEmptyChunkCount
(
uint32_t
value
)
;
}
;
class
GCSchedulingState
{
MainThreadOrGCTaskData
<
bool
>
inHighFrequencyGCMode_
;
public
:
GCSchedulingState
(
)
:
inHighFrequencyGCMode_
(
false
)
{
}
bool
inHighFrequencyGCMode
(
)
const
{
return
inHighFrequencyGCMode_
;
}
void
updateHighFrequencyMode
(
const
mozilla
:
:
TimeStamp
&
lastGCTime
const
mozilla
:
:
TimeStamp
&
currentTime
const
GCSchedulingTunables
&
tunables
)
{
inHighFrequencyGCMode_
=
tunables
.
isDynamicHeapGrowthEnabled
(
)
&
&
!
lastGCTime
.
IsNull
(
)
&
&
lastGCTime
+
tunables
.
highFrequencyThreshold
(
)
>
currentTime
;
}
}
;
enum
class
TriggerKind
{
None
Incremental
NonIncremental
}
;
struct
TriggerResult
{
TriggerKind
kind
;
size_t
usedBytes
;
size_t
thresholdBytes
;
}
;
using
AtomicByteCount
=
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
ReleaseAcquire
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
;
class
HeapSize
{
HeapSize
*
const
parent_
;
AtomicByteCount
bytes_
;
AtomicByteCount
retainedBytes_
;
public
:
explicit
HeapSize
(
HeapSize
*
parent
)
:
parent_
(
parent
)
bytes_
(
0
)
{
}
size_t
bytes
(
)
const
{
return
bytes_
;
}
size_t
retainedBytes
(
)
const
{
return
retainedBytes_
;
}
void
updateOnGCStart
(
)
{
retainedBytes_
=
size_t
(
bytes_
)
;
}
void
addGCArena
(
)
{
addBytes
(
ArenaSize
)
;
}
void
removeGCArena
(
)
{
MOZ_ASSERT
(
retainedBytes_
>
=
ArenaSize
)
;
removeBytes
(
ArenaSize
true
)
;
}
void
addBytes
(
size_t
nbytes
)
{
mozilla
:
:
DebugOnly
<
size_t
>
initialBytes
(
bytes_
)
;
MOZ_ASSERT
(
initialBytes
+
nbytes
>
initialBytes
)
;
bytes_
+
=
nbytes
;
if
(
parent_
)
{
parent_
-
>
addBytes
(
nbytes
)
;
}
}
void
removeBytes
(
size_t
nbytes
bool
wasSwept
)
{
if
(
wasSwept
)
{
retainedBytes_
=
nbytes
<
=
retainedBytes_
?
retainedBytes_
-
nbytes
:
0
;
}
MOZ_ASSERT
(
bytes_
>
=
nbytes
)
;
bytes_
-
=
nbytes
;
if
(
parent_
)
{
parent_
-
>
removeBytes
(
nbytes
wasSwept
)
;
}
}
void
adopt
(
HeapSize
&
source
)
{
bytes_
+
=
source
.
bytes_
;
source
.
retainedBytes_
=
0
;
source
.
bytes_
=
0
;
}
}
;
class
HeapThreshold
{
protected
:
HeapThreshold
(
)
=
default
;
AtomicByteCount
bytes_
;
public
:
size_t
bytes
(
)
const
{
return
bytes_
;
}
size_t
nonIncrementalTriggerBytes
(
GCSchedulingTunables
&
tunables
)
const
{
return
bytes_
*
tunables
.
nonIncrementalFactor
(
)
;
}
float
eagerAllocTrigger
(
bool
highFrequencyGC
)
const
;
}
;
class
GCHeapThreshold
:
public
HeapThreshold
{
public
:
void
updateAfterGC
(
size_t
lastBytes
JSGCInvocationKind
gckind
const
GCSchedulingTunables
&
tunables
const
GCSchedulingState
&
state
const
AutoLockGC
&
lock
)
;
private
:
static
float
computeZoneHeapGrowthFactorForHeapSize
(
size_t
lastBytes
const
GCSchedulingTunables
&
tunables
const
GCSchedulingState
&
state
)
;
static
size_t
computeZoneTriggerBytes
(
float
growthFactor
size_t
lastBytes
JSGCInvocationKind
gckind
const
GCSchedulingTunables
&
tunables
const
AutoLockGC
&
lock
)
;
}
;
class
MallocHeapThreshold
:
public
HeapThreshold
{
public
:
void
updateAfterGC
(
size_t
lastBytes
size_t
baseBytes
float
growthFactor
const
AutoLockGC
&
lock
)
;
private
:
static
size_t
computeZoneTriggerBytes
(
float
growthFactor
size_t
lastBytes
size_t
baseBytes
const
AutoLockGC
&
lock
)
;
}
;
class
JitHeapThreshold
:
public
HeapThreshold
{
public
:
explicit
JitHeapThreshold
(
size_t
bytes
)
{
bytes_
=
bytes
;
}
}
;
#
ifdef
DEBUG
class
MemoryTracker
{
public
:
MemoryTracker
(
)
;
void
fixupAfterMovingGC
(
)
;
void
checkEmptyOnDestroy
(
)
;
void
adopt
(
MemoryTracker
&
other
)
;
void
trackMemory
(
Cell
*
cell
size_t
nbytes
MemoryUse
use
)
;
void
untrackMemory
(
Cell
*
cell
size_t
nbytes
MemoryUse
use
)
;
void
swapMemory
(
Cell
*
a
Cell
*
b
MemoryUse
use
)
;
void
registerPolicy
(
ZoneAllocPolicy
*
policy
)
;
void
unregisterPolicy
(
ZoneAllocPolicy
*
policy
)
;
void
movePolicy
(
ZoneAllocPolicy
*
dst
ZoneAllocPolicy
*
src
)
;
void
incPolicyMemory
(
ZoneAllocPolicy
*
policy
size_t
nbytes
)
;
void
decPolicyMemory
(
ZoneAllocPolicy
*
policy
size_t
nbytes
)
;
private
:
struct
Key
{
Key
(
Cell
*
cell
MemoryUse
use
)
;
Cell
*
cell
(
)
const
;
MemoryUse
use
(
)
const
;
private
:
#
ifdef
JS_64BIT
uintptr_t
cell_
:
56
;
uintptr_t
use_
:
8
;
#
else
uintptr_t
cell_
:
32
;
uintptr_t
use_
:
8
;
#
endif
}
;
struct
Hasher
{
using
Lookup
=
Key
;
static
HashNumber
hash
(
const
Lookup
&
l
)
;
static
bool
match
(
const
Key
&
key
const
Lookup
&
l
)
;
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
;
}
;
using
Map
=
HashMap
<
Key
size_t
Hasher
SystemAllocPolicy
>
;
using
ZoneAllocPolicyMap
=
HashMap
<
ZoneAllocPolicy
*
size_t
DefaultHasher
<
ZoneAllocPolicy
*
>
SystemAllocPolicy
>
;
bool
allowMultipleAssociations
(
MemoryUse
use
)
const
;
size_t
getAndRemoveEntry
(
const
Key
&
key
LockGuard
<
Mutex
>
&
lock
)
;
Mutex
mutex
;
Map
map
;
ZoneAllocPolicyMap
policyMap
;
}
;
#
endif
}
}
#
endif
