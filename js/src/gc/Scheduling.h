#
ifndef
gc_Scheduling_h
#
define
gc_Scheduling_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
#
include
"
util
/
DifferentialTesting
.
h
"
namespace
js
{
class
AutoLockGC
;
class
ZoneAllocator
;
class
ZoneAllocPolicy
;
namespace
gc
{
struct
Cell
;
namespace
TuningDefaults
{
static
const
size_t
GCZoneAllocThresholdBase
=
27
*
1024
*
1024
;
static
const
size_t
GCMinNurseryBytes
=
256
*
1024
;
static
const
double
SmallHeapIncrementalLimit
=
1
.
40
;
static
const
double
LargeHeapIncrementalLimit
=
1
.
10
;
static
const
size_t
ZoneAllocDelayBytes
=
1024
*
1024
;
static
const
auto
HighFrequencyThreshold
=
1
;
static
const
size_t
SmallHeapSizeMaxBytes
=
100
*
1024
*
1024
;
static
const
size_t
LargeHeapSizeMinBytes
=
500
*
1024
*
1024
;
static
const
double
HighFrequencySmallHeapGrowth
=
3
.
0
;
static
const
double
HighFrequencyLargeHeapGrowth
=
1
.
5
;
static
const
double
LowFrequencyHeapGrowth
=
1
.
5
;
static
const
uint32_t
MinEmptyChunkCount
=
1
;
static
const
uint32_t
MaxEmptyChunkCount
=
30
;
static
const
int64_t
DefaultTimeBudgetMS
=
0
;
static
const
bool
IncrementalGCEnabled
=
false
;
static
const
bool
PerZoneGCEnabled
=
false
;
static
const
bool
CompactingEnabled
=
true
;
static
const
bool
IncrementalWeakMapMarkingEnabled
=
true
;
static
const
uint32_t
NurseryFreeThresholdForIdleCollection
=
ChunkSize
/
4
;
static
const
double
NurseryFreeThresholdForIdleCollectionFraction
=
0
.
25
;
static
const
uint32_t
NurseryTimeoutForIdleCollectionMS
=
5000
;
static
const
double
PretenureThreshold
=
0
.
6
;
static
const
double
PretenureGroupThreshold
=
3000
;
static
const
double
PretenureStringThreshold
=
0
.
55
;
static
const
double
StopPretenureStringThreshold
=
0
.
9
;
static
const
auto
MinLastDitchGCPeriod
=
60
;
static
const
size_t
MallocThresholdBase
=
38
*
1024
*
1024
;
static
const
double
MallocGrowthFactor
=
1
.
5
;
static
const
double
HelperThreadRatio
=
0
.
5
;
static
const
size_t
MaxHelperThreads
=
8
;
static
const
size_t
UrgentThresholdBytes
=
16
*
1024
*
1024
;
}
class
GCSchedulingTunables
{
UnprotectedData
<
size_t
>
gcMaxBytes_
;
MainThreadData
<
size_t
>
gcMinNurseryBytes_
;
MainThreadData
<
size_t
>
gcMaxNurseryBytes_
;
MainThreadOrGCTaskData
<
size_t
>
gcZoneAllocThresholdBase_
;
UnprotectedData
<
double
>
smallHeapIncrementalLimit_
;
UnprotectedData
<
double
>
largeHeapIncrementalLimit_
;
UnprotectedData
<
size_t
>
zoneAllocDelayBytes_
;
MainThreadOrGCTaskData
<
mozilla
:
:
TimeDuration
>
highFrequencyThreshold_
;
MainThreadOrGCTaskData
<
size_t
>
smallHeapSizeMaxBytes_
;
MainThreadOrGCTaskData
<
size_t
>
largeHeapSizeMinBytes_
;
MainThreadOrGCTaskData
<
double
>
highFrequencySmallHeapGrowth_
;
MainThreadOrGCTaskData
<
double
>
highFrequencyLargeHeapGrowth_
;
MainThreadOrGCTaskData
<
double
>
lowFrequencyHeapGrowth_
;
UnprotectedData
<
uint32_t
>
minEmptyChunkCount_
;
UnprotectedData
<
uint32_t
>
maxEmptyChunkCount_
;
UnprotectedData
<
uint32_t
>
nurseryFreeThresholdForIdleCollection_
;
UnprotectedData
<
double
>
nurseryFreeThresholdForIdleCollectionFraction_
;
MainThreadData
<
mozilla
:
:
TimeDuration
>
nurseryTimeoutForIdleCollection_
;
UnprotectedData
<
double
>
pretenureThreshold_
;
UnprotectedData
<
uint32_t
>
pretenureGroupThreshold_
;
MainThreadData
<
double
>
pretenureStringThreshold_
;
MainThreadData
<
double
>
stopPretenureStringThreshold_
;
MainThreadData
<
mozilla
:
:
TimeDuration
>
minLastDitchGCPeriod_
;
MainThreadOrGCTaskData
<
size_t
>
mallocThresholdBase_
;
MainThreadOrGCTaskData
<
double
>
mallocGrowthFactor_
;
MainThreadData
<
size_t
>
urgentThresholdBytes_
;
public
:
GCSchedulingTunables
(
)
;
size_t
gcMaxBytes
(
)
const
{
return
gcMaxBytes_
;
}
size_t
gcMinNurseryBytes
(
)
const
{
return
gcMinNurseryBytes_
;
}
size_t
gcMaxNurseryBytes
(
)
const
{
return
gcMaxNurseryBytes_
;
}
size_t
gcZoneAllocThresholdBase
(
)
const
{
return
gcZoneAllocThresholdBase_
;
}
double
smallHeapIncrementalLimit
(
)
const
{
return
smallHeapIncrementalLimit_
;
}
double
largeHeapIncrementalLimit
(
)
const
{
return
largeHeapIncrementalLimit_
;
}
size_t
zoneAllocDelayBytes
(
)
const
{
return
zoneAllocDelayBytes_
;
}
const
mozilla
:
:
TimeDuration
&
highFrequencyThreshold
(
)
const
{
return
highFrequencyThreshold_
;
}
size_t
smallHeapSizeMaxBytes
(
)
const
{
return
smallHeapSizeMaxBytes_
;
}
size_t
largeHeapSizeMinBytes
(
)
const
{
return
largeHeapSizeMinBytes_
;
}
double
highFrequencySmallHeapGrowth
(
)
const
{
return
highFrequencySmallHeapGrowth_
;
}
double
highFrequencyLargeHeapGrowth
(
)
const
{
return
highFrequencyLargeHeapGrowth_
;
}
double
lowFrequencyHeapGrowth
(
)
const
{
return
lowFrequencyHeapGrowth_
;
}
unsigned
minEmptyChunkCount
(
const
AutoLockGC
&
)
const
{
return
minEmptyChunkCount_
;
}
unsigned
maxEmptyChunkCount
(
)
const
{
return
maxEmptyChunkCount_
;
}
uint32_t
nurseryFreeThresholdForIdleCollection
(
)
const
{
return
nurseryFreeThresholdForIdleCollection_
;
}
double
nurseryFreeThresholdForIdleCollectionFraction
(
)
const
{
return
nurseryFreeThresholdForIdleCollectionFraction_
;
}
mozilla
:
:
TimeDuration
nurseryTimeoutForIdleCollection
(
)
const
{
return
nurseryTimeoutForIdleCollection_
;
}
bool
attemptPretenuring
(
)
const
{
return
pretenureThreshold_
<
1
.
0
;
}
double
pretenureThreshold
(
)
const
{
return
pretenureThreshold_
;
}
uint32_t
pretenureGroupThreshold
(
)
const
{
return
pretenureGroupThreshold_
;
}
double
pretenureStringThreshold
(
)
const
{
return
pretenureStringThreshold_
;
}
double
stopPretenureStringThreshold
(
)
const
{
return
stopPretenureStringThreshold_
;
}
mozilla
:
:
TimeDuration
minLastDitchGCPeriod
(
)
const
{
return
minLastDitchGCPeriod_
;
}
size_t
mallocThresholdBase
(
)
const
{
return
mallocThresholdBase_
;
}
double
mallocGrowthFactor
(
)
const
{
return
mallocGrowthFactor_
;
}
size_t
urgentThresholdBytes
(
)
const
{
return
urgentThresholdBytes_
;
}
[
[
nodiscard
]
]
bool
setParameter
(
JSGCParamKey
key
uint32_t
value
const
AutoLockGC
&
lock
)
;
void
resetParameter
(
JSGCParamKey
key
const
AutoLockGC
&
lock
)
;
private
:
void
setSmallHeapSizeMaxBytes
(
size_t
value
)
;
void
setLargeHeapSizeMinBytes
(
size_t
value
)
;
void
setHighFrequencySmallHeapGrowth
(
double
value
)
;
void
setHighFrequencyLargeHeapGrowth
(
double
value
)
;
void
setLowFrequencyHeapGrowth
(
double
value
)
;
void
setMinEmptyChunkCount
(
uint32_t
value
)
;
void
setMaxEmptyChunkCount
(
uint32_t
value
)
;
}
;
class
GCSchedulingState
{
MainThreadOrGCTaskData
<
bool
>
inHighFrequencyGCMode_
;
public
:
MainThreadOrGCTaskData
<
bool
>
inPageLoad
;
GCSchedulingState
(
)
:
inHighFrequencyGCMode_
(
false
)
{
}
bool
inHighFrequencyGCMode
(
)
const
{
return
inHighFrequencyGCMode_
;
}
void
updateHighFrequencyMode
(
const
mozilla
:
:
TimeStamp
&
lastGCTime
const
mozilla
:
:
TimeStamp
&
currentTime
const
GCSchedulingTunables
&
tunables
)
{
if
(
js
:
:
SupportDifferentialTesting
(
)
)
{
return
;
}
inHighFrequencyGCMode_
=
!
lastGCTime
.
IsNull
(
)
&
&
lastGCTime
+
tunables
.
highFrequencyThreshold
(
)
>
currentTime
;
}
}
;
struct
TriggerResult
{
bool
shouldTrigger
;
size_t
usedBytes
;
size_t
thresholdBytes
;
}
;
using
AtomicByteCount
=
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
ReleaseAcquire
>
;
class
HeapSize
{
HeapSize
*
const
parent_
;
AtomicByteCount
bytes_
;
AtomicByteCount
retainedBytes_
;
public
:
explicit
HeapSize
(
HeapSize
*
parent
)
:
parent_
(
parent
)
bytes_
(
0
)
{
}
size_t
bytes
(
)
const
{
return
bytes_
;
}
size_t
retainedBytes
(
)
const
{
return
retainedBytes_
;
}
void
updateOnGCStart
(
)
{
retainedBytes_
=
size_t
(
bytes_
)
;
}
void
addGCArena
(
)
{
addBytes
(
ArenaSize
)
;
}
void
removeGCArena
(
)
{
MOZ_ASSERT
(
retainedBytes_
>
=
ArenaSize
)
;
removeBytes
(
ArenaSize
true
)
;
}
void
addBytes
(
size_t
nbytes
)
{
mozilla
:
:
DebugOnly
<
size_t
>
initialBytes
(
bytes_
)
;
MOZ_ASSERT
(
initialBytes
+
nbytes
>
initialBytes
)
;
bytes_
+
=
nbytes
;
if
(
parent_
)
{
parent_
-
>
addBytes
(
nbytes
)
;
}
}
void
removeBytes
(
size_t
nbytes
bool
wasSwept
)
{
if
(
wasSwept
)
{
retainedBytes_
=
nbytes
<
=
retainedBytes_
?
retainedBytes_
-
nbytes
:
0
;
}
MOZ_ASSERT
(
bytes_
>
=
nbytes
)
;
bytes_
-
=
nbytes
;
if
(
parent_
)
{
parent_
-
>
removeBytes
(
nbytes
wasSwept
)
;
}
}
void
adopt
(
HeapSize
&
source
)
{
bytes_
+
=
source
.
bytes_
;
source
.
retainedBytes_
=
0
;
source
.
bytes_
=
0
;
}
}
;
class
HeapThreshold
{
protected
:
HeapThreshold
(
)
:
startBytes_
(
SIZE_MAX
)
incrementalLimitBytes_
(
SIZE_MAX
)
sliceBytes_
(
SIZE_MAX
)
{
}
AtomicByteCount
startBytes_
;
size_t
incrementalLimitBytes_
;
size_t
sliceBytes_
;
public
:
size_t
startBytes
(
)
const
{
return
startBytes_
;
}
size_t
sliceBytes
(
)
const
{
return
sliceBytes_
;
}
size_t
incrementalLimitBytes
(
)
const
{
return
incrementalLimitBytes_
;
}
double
eagerAllocTrigger
(
bool
highFrequencyGC
)
const
;
size_t
incrementalBytesRemaining
(
const
HeapSize
&
heapSize
)
const
;
void
setSliceThreshold
(
ZoneAllocator
*
zone
const
HeapSize
&
heapSize
const
GCSchedulingTunables
&
tunables
)
;
void
clearSliceThreshold
(
)
{
sliceBytes_
=
SIZE_MAX
;
}
bool
hasSliceThreshold
(
)
const
{
return
sliceBytes_
!
=
SIZE_MAX
;
}
protected
:
static
double
computeZoneHeapGrowthFactorForHeapSize
(
size_t
lastBytes
const
GCSchedulingTunables
&
tunables
const
GCSchedulingState
&
state
)
;
void
setIncrementalLimitFromStartBytes
(
size_t
retainedBytes
const
GCSchedulingTunables
&
tunables
)
;
}
;
class
GCHeapThreshold
:
public
HeapThreshold
{
public
:
void
updateStartThreshold
(
size_t
lastBytes
JS
:
:
GCOptions
options
const
GCSchedulingTunables
&
tunables
const
GCSchedulingState
&
state
bool
isAtomsZone
const
AutoLockGC
&
lock
)
;
private
:
static
size_t
computeZoneTriggerBytes
(
double
growthFactor
size_t
lastBytes
JS
:
:
GCOptions
options
const
GCSchedulingTunables
&
tunables
const
AutoLockGC
&
lock
)
;
}
;
class
MallocHeapThreshold
:
public
HeapThreshold
{
public
:
void
updateStartThreshold
(
size_t
lastBytes
const
GCSchedulingTunables
&
tunables
const
GCSchedulingState
&
state
const
AutoLockGC
&
lock
)
;
private
:
static
size_t
computeZoneTriggerBytes
(
double
growthFactor
size_t
lastBytes
size_t
baseBytes
const
AutoLockGC
&
lock
)
;
}
;
class
JitHeapThreshold
:
public
HeapThreshold
{
public
:
explicit
JitHeapThreshold
(
size_t
bytes
)
{
startBytes_
=
bytes
;
}
}
;
struct
SharedMemoryUse
{
explicit
SharedMemoryUse
(
MemoryUse
use
)
:
count
(
0
)
nbytes
(
0
)
{
#
ifdef
DEBUG
this
-
>
use
=
use
;
#
endif
}
size_t
count
;
size_t
nbytes
;
#
ifdef
DEBUG
MemoryUse
use
;
#
endif
}
;
using
SharedMemoryMap
=
HashMap
<
void
*
SharedMemoryUse
DefaultHasher
<
void
*
>
SystemAllocPolicy
>
;
#
ifdef
DEBUG
class
MemoryTracker
{
public
:
MemoryTracker
(
)
;
void
fixupAfterMovingGC
(
)
;
void
checkEmptyOnDestroy
(
)
;
void
adopt
(
MemoryTracker
&
other
)
;
void
trackGCMemory
(
Cell
*
cell
size_t
nbytes
MemoryUse
use
)
;
void
untrackGCMemory
(
Cell
*
cell
size_t
nbytes
MemoryUse
use
)
;
void
swapGCMemory
(
Cell
*
a
Cell
*
b
MemoryUse
use
)
;
void
registerNonGCMemory
(
void
*
ptr
MemoryUse
use
)
;
void
unregisterNonGCMemory
(
void
*
ptr
MemoryUse
use
)
;
void
moveNonGCMemory
(
void
*
dst
void
*
src
MemoryUse
use
)
;
void
incNonGCMemory
(
void
*
ptr
size_t
nbytes
MemoryUse
use
)
;
void
decNonGCMemory
(
void
*
ptr
size_t
nbytes
MemoryUse
use
)
;
private
:
template
<
typename
Ptr
>
struct
Key
{
Key
(
Ptr
*
ptr
MemoryUse
use
)
;
Ptr
*
ptr
(
)
const
;
MemoryUse
use
(
)
const
;
private
:
#
ifdef
JS_64BIT
uintptr_t
ptr_
:
56
;
uintptr_t
use_
:
8
;
#
else
uintptr_t
ptr_
:
32
;
uintptr_t
use_
:
8
;
#
endif
}
;
template
<
typename
Ptr
>
struct
Hasher
{
using
KeyT
=
Key
<
Ptr
>
;
using
Lookup
=
KeyT
;
static
HashNumber
hash
(
const
Lookup
&
l
)
;
static
bool
match
(
const
KeyT
&
key
const
Lookup
&
l
)
;
static
void
rekey
(
KeyT
&
k
const
KeyT
&
newKey
)
;
}
;
template
<
typename
Ptr
>
using
Map
=
HashMap
<
Key
<
Ptr
>
size_t
Hasher
<
Ptr
>
SystemAllocPolicy
>
;
using
GCMap
=
Map
<
Cell
>
;
using
NonGCMap
=
Map
<
void
>
;
static
bool
isGCMemoryUse
(
MemoryUse
use
)
;
static
bool
isNonGCMemoryUse
(
MemoryUse
use
)
;
static
bool
allowMultipleAssociations
(
MemoryUse
use
)
;
size_t
getAndRemoveEntry
(
const
Key
<
Cell
>
&
key
LockGuard
<
Mutex
>
&
lock
)
;
Mutex
mutex
;
GCMap
gcMap
;
NonGCMap
nonGCMap
;
}
;
#
endif
static
inline
double
LinearInterpolate
(
double
x
double
x0
double
y0
double
x1
double
y1
)
{
MOZ_ASSERT
(
x0
<
x1
)
;
if
(
x
<
x0
)
{
return
y0
;
}
if
(
x
<
x1
)
{
return
y0
+
(
y1
-
y0
)
*
(
(
x
-
x0
)
/
(
x1
-
x0
)
)
;
}
return
y1
;
}
}
}
#
endif
