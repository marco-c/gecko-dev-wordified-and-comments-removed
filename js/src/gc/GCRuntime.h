#
ifndef
gc_GCRuntime_h
#
define
gc_GCRuntime_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsgc
.
h
"
#
include
"
gc
/
AtomMarking
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
gc
/
Nursery
.
h
"
#
include
"
gc
/
Statistics
.
h
"
#
include
"
gc
/
StoreBuffer
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
namespace
js
{
class
AutoLockGC
;
class
AutoLockHelperThreadState
;
class
VerifyPreTracer
;
namespace
gc
{
typedef
Vector
<
ZoneGroup
*
4
SystemAllocPolicy
>
ZoneGroupVector
;
using
BlackGrayEdgeVector
=
Vector
<
TenuredCell
*
0
SystemAllocPolicy
>
;
class
AutoMaybeStartBackgroundAllocation
;
class
AutoRunParallelTask
;
class
AutoTraceSession
;
class
MarkingValidator
;
struct
MovingTracer
;
enum
IncrementalProgress
{
NotFinished
=
0
Finished
}
;
enum
SweepActionList
{
PerSweepGroupActionList
PerZoneActionList
SweepActionListCount
}
;
class
ChunkPool
{
Chunk
*
head_
;
size_t
count_
;
public
:
ChunkPool
(
)
:
head_
(
nullptr
)
count_
(
0
)
{
}
~
ChunkPool
(
)
{
MOZ_ASSERT
(
empty
(
)
)
;
}
bool
empty
(
)
const
{
return
!
head_
;
}
size_t
count
(
)
const
{
return
count_
;
}
Chunk
*
head
(
)
{
MOZ_ASSERT
(
head_
)
;
return
head_
;
}
Chunk
*
pop
(
)
;
void
push
(
Chunk
*
chunk
)
;
Chunk
*
remove
(
Chunk
*
chunk
)
;
#
ifdef
DEBUG
bool
contains
(
Chunk
*
chunk
)
const
;
bool
verify
(
)
const
;
#
endif
class
Iter
{
public
:
explicit
Iter
(
ChunkPool
&
pool
)
:
current_
(
pool
.
head_
)
{
}
bool
done
(
)
const
{
return
!
current_
;
}
void
next
(
)
;
Chunk
*
get
(
)
const
{
return
current_
;
}
operator
Chunk
*
(
)
const
{
return
get
(
)
;
}
Chunk
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
private
:
Chunk
*
current_
;
}
;
}
;
class
BackgroundAllocTask
:
public
GCParallelTask
{
GCLockData
<
ChunkPool
&
>
chunkPool_
;
const
bool
enabled_
;
public
:
BackgroundAllocTask
(
JSRuntime
*
rt
ChunkPool
&
pool
)
;
bool
enabled
(
)
const
{
return
enabled_
;
}
protected
:
void
run
(
)
override
;
}
;
class
BackgroundDecommitTask
:
public
GCParallelTask
{
public
:
using
ChunkVector
=
mozilla
:
:
Vector
<
Chunk
*
>
;
explicit
BackgroundDecommitTask
(
JSRuntime
*
rt
)
:
GCParallelTask
(
rt
)
{
}
void
setChunksToScan
(
ChunkVector
&
chunks
)
;
protected
:
void
run
(
)
override
;
private
:
ActiveThreadOrGCTaskData
<
ChunkVector
>
toDecommit
;
}
;
class
GCSchedulingTunables
{
UnprotectedData
<
size_t
>
gcMaxBytes_
;
ActiveThreadData
<
size_t
>
gcMaxNurseryBytes_
;
ActiveThreadOrGCTaskData
<
size_t
>
gcZoneAllocThresholdBase_
;
UnprotectedData
<
double
>
zoneAllocThresholdFactor_
;
UnprotectedData
<
double
>
zoneAllocThresholdFactorAvoidInterrupt_
;
UnprotectedData
<
size_t
>
zoneAllocDelayBytes_
;
ActiveThreadData
<
bool
>
dynamicHeapGrowthEnabled_
;
ActiveThreadData
<
uint64_t
>
highFrequencyThresholdUsec_
;
ActiveThreadData
<
uint64_t
>
highFrequencyLowLimitBytes_
;
ActiveThreadData
<
uint64_t
>
highFrequencyHighLimitBytes_
;
ActiveThreadData
<
double
>
highFrequencyHeapGrowthMax_
;
ActiveThreadData
<
double
>
highFrequencyHeapGrowthMin_
;
ActiveThreadData
<
double
>
lowFrequencyHeapGrowth_
;
ActiveThreadData
<
bool
>
dynamicMarkSliceEnabled_
;
ActiveThreadData
<
bool
>
refreshFrameSlicesEnabled_
;
UnprotectedData
<
uint32_t
>
minEmptyChunkCount_
;
UnprotectedData
<
uint32_t
>
maxEmptyChunkCount_
;
public
:
GCSchedulingTunables
(
)
:
gcMaxBytes_
(
0
)
gcMaxNurseryBytes_
(
0
)
gcZoneAllocThresholdBase_
(
30
*
1024
*
1024
)
zoneAllocThresholdFactor_
(
0
.
9
)
zoneAllocThresholdFactorAvoidInterrupt_
(
0
.
95
)
zoneAllocDelayBytes_
(
1024
*
1024
)
dynamicHeapGrowthEnabled_
(
false
)
highFrequencyThresholdUsec_
(
1000
*
1000
)
highFrequencyLowLimitBytes_
(
100
*
1024
*
1024
)
highFrequencyHighLimitBytes_
(
500
*
1024
*
1024
)
highFrequencyHeapGrowthMax_
(
3
.
0
)
highFrequencyHeapGrowthMin_
(
1
.
5
)
lowFrequencyHeapGrowth_
(
1
.
5
)
dynamicMarkSliceEnabled_
(
false
)
refreshFrameSlicesEnabled_
(
true
)
minEmptyChunkCount_
(
1
)
maxEmptyChunkCount_
(
30
)
{
}
size_t
gcMaxBytes
(
)
const
{
return
gcMaxBytes_
;
}
size_t
gcMaxNurseryBytes
(
)
const
{
return
gcMaxNurseryBytes_
;
}
size_t
gcZoneAllocThresholdBase
(
)
const
{
return
gcZoneAllocThresholdBase_
;
}
double
zoneAllocThresholdFactor
(
)
const
{
return
zoneAllocThresholdFactor_
;
}
double
zoneAllocThresholdFactorAvoidInterrupt
(
)
const
{
return
zoneAllocThresholdFactorAvoidInterrupt_
;
}
size_t
zoneAllocDelayBytes
(
)
const
{
return
zoneAllocDelayBytes_
;
}
bool
isDynamicHeapGrowthEnabled
(
)
const
{
return
dynamicHeapGrowthEnabled_
;
}
uint64_t
highFrequencyThresholdUsec
(
)
const
{
return
highFrequencyThresholdUsec_
;
}
uint64_t
highFrequencyLowLimitBytes
(
)
const
{
return
highFrequencyLowLimitBytes_
;
}
uint64_t
highFrequencyHighLimitBytes
(
)
const
{
return
highFrequencyHighLimitBytes_
;
}
double
highFrequencyHeapGrowthMax
(
)
const
{
return
highFrequencyHeapGrowthMax_
;
}
double
highFrequencyHeapGrowthMin
(
)
const
{
return
highFrequencyHeapGrowthMin_
;
}
double
lowFrequencyHeapGrowth
(
)
const
{
return
lowFrequencyHeapGrowth_
;
}
bool
isDynamicMarkSliceEnabled
(
)
const
{
return
dynamicMarkSliceEnabled_
;
}
bool
areRefreshFrameSlicesEnabled
(
)
const
{
return
refreshFrameSlicesEnabled_
;
}
unsigned
minEmptyChunkCount
(
const
AutoLockGC
&
)
const
{
return
minEmptyChunkCount_
;
}
unsigned
maxEmptyChunkCount
(
)
const
{
return
maxEmptyChunkCount_
;
}
MOZ_MUST_USE
bool
setParameter
(
JSGCParamKey
key
uint32_t
value
const
AutoLockGC
&
lock
)
;
}
;
class
GCSchedulingState
{
ActiveThreadData
<
bool
>
inHighFrequencyGCMode_
;
public
:
GCSchedulingState
(
)
:
inHighFrequencyGCMode_
(
false
)
{
}
bool
inHighFrequencyGCMode
(
)
const
{
return
inHighFrequencyGCMode_
;
}
void
updateHighFrequencyMode
(
uint64_t
lastGCTime
uint64_t
currentTime
const
GCSchedulingTunables
&
tunables
)
{
inHighFrequencyGCMode_
=
tunables
.
isDynamicHeapGrowthEnabled
(
)
&
&
lastGCTime
&
&
lastGCTime
+
tunables
.
highFrequencyThresholdUsec
(
)
>
currentTime
;
}
}
;
template
<
typename
F
>
struct
Callback
{
ActiveThreadOrGCTaskData
<
F
>
op
;
ActiveThreadOrGCTaskData
<
void
*
>
data
;
Callback
(
)
:
op
(
nullptr
)
data
(
nullptr
)
{
}
Callback
(
F
op
void
*
data
)
:
op
(
op
)
data
(
data
)
{
}
}
;
template
<
typename
F
>
using
CallbackVector
=
ActiveThreadData
<
Vector
<
Callback
<
F
>
4
SystemAllocPolicy
>
>
;
template
<
typename
T
typename
Iter0
typename
Iter1
>
class
ChainedIter
{
Iter0
iter0_
;
Iter1
iter1_
;
public
:
ChainedIter
(
const
Iter0
&
iter0
const
Iter1
&
iter1
)
:
iter0_
(
iter0
)
iter1_
(
iter1
)
{
}
bool
done
(
)
const
{
return
iter0_
.
done
(
)
&
&
iter1_
.
done
(
)
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
!
iter0_
.
done
(
)
)
{
iter0_
.
next
(
)
;
}
else
{
MOZ_ASSERT
(
!
iter1_
.
done
(
)
)
;
iter1_
.
next
(
)
;
}
}
T
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
!
iter0_
.
done
(
)
)
return
iter0_
.
get
(
)
;
MOZ_ASSERT
(
!
iter1_
.
done
(
)
)
;
return
iter1_
.
get
(
)
;
}
operator
T
(
)
const
{
return
get
(
)
;
}
T
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
typedef
HashMap
<
Value
*
const
char
*
DefaultHasher
<
Value
*
>
SystemAllocPolicy
>
RootedValueMap
;
using
AllocKinds
=
mozilla
:
:
EnumSet
<
AllocKind
>
;
template
<
typename
T
>
class
MemoryCounter
{
mozilla
:
:
Atomic
<
ptrdiff_t
mozilla
:
:
ReleaseAcquire
>
bytes_
;
js
:
:
ActiveThreadData
<
size_t
>
maxBytes_
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
triggered_
;
public
:
MemoryCounter
(
)
:
bytes_
(
0
)
maxBytes_
(
0
)
triggered_
(
false
)
{
}
void
reset
(
)
{
bytes_
=
maxBytes_
;
triggered_
=
false
;
}
void
setMax
(
size_t
newMax
)
{
maxBytes_
=
(
ptrdiff_t
(
newMax
)
>
=
0
)
?
newMax
:
size_t
(
-
1
)
>
>
1
;
reset
(
)
;
}
bool
update
(
T
*
owner
size_t
bytes
)
{
bytes_
-
=
ptrdiff_t
(
bytes
)
;
if
(
MOZ_UNLIKELY
(
isTooMuchMalloc
(
)
)
)
{
if
(
!
triggered_
)
triggered_
=
owner
-
>
triggerGCForTooMuchMalloc
(
)
;
}
return
triggered_
;
}
ptrdiff_t
bytes
(
)
const
{
return
bytes_
;
}
size_t
maxBytes
(
)
const
{
return
maxBytes_
;
}
bool
isTooMuchMalloc
(
)
const
{
return
bytes_
<
=
0
;
}
}
;
class
GCRuntime
{
public
:
explicit
GCRuntime
(
JSRuntime
*
rt
)
;
MOZ_MUST_USE
bool
init
(
uint32_t
maxbytes
uint32_t
maxNurseryBytes
)
;
void
finishRoots
(
)
;
void
finish
(
)
;
inline
bool
hasZealMode
(
ZealMode
mode
)
;
inline
void
clearZealMode
(
ZealMode
mode
)
;
inline
bool
upcomingZealousGC
(
)
;
inline
bool
needZealousGC
(
)
;
MOZ_MUST_USE
bool
addRoot
(
Value
*
vp
const
char
*
name
)
;
void
removeRoot
(
Value
*
vp
)
;
void
setMarkStackLimit
(
size_t
limit
AutoLockGC
&
lock
)
;
MOZ_MUST_USE
bool
setParameter
(
JSGCParamKey
key
uint32_t
value
AutoLockGC
&
lock
)
;
uint32_t
getParameter
(
JSGCParamKey
key
const
AutoLockGC
&
lock
)
;
MOZ_MUST_USE
bool
triggerGC
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
void
maybeAllocTriggerZoneGC
(
Zone
*
zone
const
AutoLockGC
&
lock
)
;
bool
triggerZoneGC
(
Zone
*
zone
JS
:
:
gcreason
:
:
Reason
reason
size_t
usedBytes
size_t
thresholdBytes
)
;
void
maybeGC
(
Zone
*
zone
)
;
bool
gcIfRequested
(
)
;
void
gc
(
JSGCInvocationKind
gckind
JS
:
:
gcreason
:
:
Reason
reason
)
;
void
startGC
(
JSGCInvocationKind
gckind
JS
:
:
gcreason
:
:
Reason
reason
int64_t
millis
=
0
)
;
void
gcSlice
(
JS
:
:
gcreason
:
:
Reason
reason
int64_t
millis
=
0
)
;
void
finishGC
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
void
abortGC
(
)
;
void
startDebugGC
(
JSGCInvocationKind
gckind
SliceBudget
&
budget
)
;
void
debugGCSlice
(
SliceBudget
&
budget
)
;
bool
canChangeActiveContext
(
JSContext
*
cx
)
;
void
triggerFullGCForAtoms
(
)
{
MOZ_ASSERT
(
fullGCForAtomsRequested_
)
;
fullGCForAtomsRequested_
=
false
;
MOZ_RELEASE_ASSERT
(
triggerGC
(
JS
:
:
gcreason
:
:
ALLOC_TRIGGER
)
)
;
}
void
runDebugGC
(
)
;
inline
void
poke
(
)
;
enum
TraceOrMarkRuntime
{
TraceRuntime
MarkRuntime
}
;
void
traceRuntime
(
JSTracer
*
trc
AutoLockForExclusiveAccess
&
lock
)
;
void
traceRuntimeForMinorGC
(
JSTracer
*
trc
AutoLockForExclusiveAccess
&
lock
)
;
void
notifyDidPaint
(
)
;
void
shrinkBuffers
(
)
;
void
onOutOfMallocMemory
(
)
;
void
onOutOfMallocMemory
(
const
AutoLockGC
&
lock
)
;
#
ifdef
JS_GC_ZEAL
const
void
*
addressOfZealModeBits
(
)
{
return
&
zealModeBits
;
}
void
getZealBits
(
uint32_t
*
zealBits
uint32_t
*
frequency
uint32_t
*
nextScheduled
)
;
void
setZeal
(
uint8_t
zeal
uint32_t
frequency
)
;
bool
parseAndSetZeal
(
const
char
*
str
)
;
void
setNextScheduled
(
uint32_t
count
)
;
void
verifyPreBarriers
(
)
;
void
maybeVerifyPreBarriers
(
bool
always
)
;
bool
selectForMarking
(
JSObject
*
object
)
;
void
clearSelectedForMarking
(
)
;
void
setDeterministic
(
bool
enable
)
;
#
endif
uint64_t
nextCellUniqueId
(
)
{
MOZ_ASSERT
(
nextCellUniqueId_
>
0
)
;
uint64_t
uid
=
+
+
nextCellUniqueId_
;
return
uid
;
}
#
ifdef
DEBUG
bool
shutdownCollectedEverything
(
)
const
{
return
arenasEmptyAtShutdown
;
}
#
endif
public
:
State
state
(
)
const
{
return
incrementalState
;
}
bool
isHeapCompacting
(
)
const
{
return
state
(
)
=
=
State
:
:
Compact
;
}
bool
isForegroundSweeping
(
)
const
{
return
state
(
)
=
=
State
:
:
Sweep
;
}
bool
isBackgroundSweeping
(
)
{
return
helperState
.
isBackgroundSweeping
(
)
;
}
void
waitBackgroundSweepEnd
(
)
{
helperState
.
waitBackgroundSweepEnd
(
)
;
}
void
waitBackgroundSweepOrAllocEnd
(
)
{
helperState
.
waitBackgroundSweepEnd
(
)
;
allocTask
.
cancel
(
GCParallelTask
:
:
CancelAndWait
)
;
}
#
ifdef
DEBUG
bool
onBackgroundThread
(
)
{
return
helperState
.
onBackgroundThread
(
)
;
}
#
endif
void
lockGC
(
)
{
lock
.
lock
(
)
;
}
void
unlockGC
(
)
{
lock
.
unlock
(
)
;
}
#
ifdef
DEBUG
bool
currentThreadHasLockedGC
(
)
const
{
return
lock
.
ownedByCurrentThread
(
)
;
}
#
endif
void
setAlwaysPreserveCode
(
)
{
alwaysPreserveCode
=
true
;
}
bool
isIncrementalGCAllowed
(
)
const
{
return
incrementalAllowed
;
}
void
disallowIncrementalGC
(
)
{
incrementalAllowed
=
false
;
}
bool
isIncrementalGCEnabled
(
)
const
{
return
mode
=
=
JSGC_MODE_INCREMENTAL
&
&
incrementalAllowed
;
}
bool
isIncrementalGCInProgress
(
)
const
{
return
state
(
)
!
=
State
:
:
NotActive
;
}
bool
isCompactingGCEnabled
(
)
const
;
bool
isShrinkingGC
(
)
const
{
return
invocationKind
=
=
GC_SHRINK
;
}
static
bool
initializeSweepActions
(
)
;
void
setGrayRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
;
MOZ_MUST_USE
bool
addBlackRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
;
void
removeBlackRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
;
bool
triggerGCForTooMuchMalloc
(
)
{
stats
(
)
.
recordTrigger
(
mallocCounter
.
bytes
(
)
mallocCounter
.
maxBytes
(
)
)
;
return
triggerGC
(
JS
:
:
gcreason
:
:
TOO_MUCH_MALLOC
)
;
}
int32_t
getMallocBytes
(
)
const
{
return
mallocCounter
.
bytes
(
)
;
}
size_t
maxMallocBytesAllocated
(
)
const
{
return
mallocCounter
.
maxBytes
(
)
;
}
bool
isTooMuchMalloc
(
)
const
{
return
mallocCounter
.
isTooMuchMalloc
(
)
;
}
void
resetMallocBytes
(
)
{
mallocCounter
.
reset
(
)
;
}
void
setMaxMallocBytes
(
size_t
value
)
;
void
updateMallocCounter
(
JS
:
:
Zone
*
zone
size_t
nbytes
)
;
void
setGCCallback
(
JSGCCallback
callback
void
*
data
)
;
void
callGCCallback
(
JSGCStatus
status
)
const
;
void
setObjectsTenuredCallback
(
JSObjectsTenuredCallback
callback
void
*
data
)
;
void
callObjectsTenuredCallback
(
)
;
MOZ_MUST_USE
bool
addFinalizeCallback
(
JSFinalizeCallback
callback
void
*
data
)
;
void
removeFinalizeCallback
(
JSFinalizeCallback
func
)
;
MOZ_MUST_USE
bool
addWeakPointerZonesCallback
(
JSWeakPointerZonesCallback
callback
void
*
data
)
;
void
removeWeakPointerZonesCallback
(
JSWeakPointerZonesCallback
callback
)
;
MOZ_MUST_USE
bool
addWeakPointerCompartmentCallback
(
JSWeakPointerCompartmentCallback
callback
void
*
data
)
;
void
removeWeakPointerCompartmentCallback
(
JSWeakPointerCompartmentCallback
callback
)
;
JS
:
:
GCSliceCallback
setSliceCallback
(
JS
:
:
GCSliceCallback
callback
)
;
JS
:
:
GCNurseryCollectionCallback
setNurseryCollectionCallback
(
JS
:
:
GCNurseryCollectionCallback
callback
)
;
JS
:
:
DoCycleCollectionCallback
setDoCycleCollectionCallback
(
JS
:
:
DoCycleCollectionCallback
callback
)
;
void
callDoCycleCollectionCallback
(
JSContext
*
cx
)
;
void
setFullCompartmentChecks
(
bool
enable
)
;
JS
:
:
Zone
*
getCurrentSweepGroup
(
)
{
return
currentSweepGroup
;
}
void
setFoundBlackGrayEdges
(
TenuredCell
&
target
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
foundBlackGrayEdges
.
ref
(
)
.
append
(
&
target
)
)
oomUnsafe
.
crash
(
"
OOM
|
small
:
failed
to
insert
into
foundBlackGrayEdges
"
)
;
}
uint64_t
gcNumber
(
)
const
{
return
number
;
}
uint64_t
minorGCCount
(
)
const
{
return
minorGCNumber
;
}
void
incMinorGcNumber
(
)
{
+
+
minorGCNumber
;
+
+
number
;
}
uint64_t
majorGCCount
(
)
const
{
return
majorGCNumber
;
}
void
incMajorGcNumber
(
)
{
+
+
majorGCNumber
;
+
+
number
;
}
int64_t
defaultSliceBudget
(
)
const
{
return
defaultTimeBudget_
;
}
bool
isIncrementalGc
(
)
const
{
return
isIncremental
;
}
bool
isFullGc
(
)
const
{
return
isFull
;
}
bool
isCompactingGc
(
)
const
{
return
isCompacting
;
}
bool
areGrayBitsValid
(
)
const
{
return
grayBitsValid
;
}
void
setGrayBitsInvalid
(
)
{
grayBitsValid
=
false
;
}
bool
majorGCRequested
(
)
const
{
return
majorGCTriggerReason
!
=
JS
:
:
gcreason
:
:
NO_REASON
;
}
bool
fullGCForAtomsRequested
(
)
const
{
return
fullGCForAtomsRequested_
;
}
double
computeHeapGrowthFactor
(
size_t
lastBytes
)
;
size_t
computeTriggerBytes
(
double
growthFactor
size_t
lastBytes
)
;
JSGCMode
gcMode
(
)
const
{
return
mode
;
}
void
setGCMode
(
JSGCMode
m
)
{
mode
=
m
;
marker
.
setGCMode
(
mode
)
;
}
inline
void
updateOnFreeArenaAlloc
(
const
ChunkInfo
&
info
)
;
inline
void
updateOnArenaFree
(
const
ChunkInfo
&
info
)
;
ChunkPool
&
fullChunks
(
const
AutoLockGC
&
lock
)
{
return
fullChunks_
.
ref
(
)
;
}
ChunkPool
&
availableChunks
(
const
AutoLockGC
&
lock
)
{
return
availableChunks_
.
ref
(
)
;
}
ChunkPool
&
emptyChunks
(
const
AutoLockGC
&
lock
)
{
return
emptyChunks_
.
ref
(
)
;
}
const
ChunkPool
&
fullChunks
(
const
AutoLockGC
&
lock
)
const
{
return
fullChunks_
.
ref
(
)
;
}
const
ChunkPool
&
availableChunks
(
const
AutoLockGC
&
lock
)
const
{
return
availableChunks_
.
ref
(
)
;
}
const
ChunkPool
&
emptyChunks
(
const
AutoLockGC
&
lock
)
const
{
return
emptyChunks_
.
ref
(
)
;
}
typedef
ChainedIter
<
Chunk
*
ChunkPool
:
:
Iter
ChunkPool
:
:
Iter
>
NonEmptyChunksIter
;
NonEmptyChunksIter
allNonEmptyChunks
(
)
{
return
NonEmptyChunksIter
(
ChunkPool
:
:
Iter
(
availableChunks_
.
ref
(
)
)
ChunkPool
:
:
Iter
(
fullChunks_
.
ref
(
)
)
)
;
}
Chunk
*
getOrAllocChunk
(
const
AutoLockGC
&
lock
AutoMaybeStartBackgroundAllocation
&
maybeStartBGAlloc
)
;
void
recycleChunk
(
Chunk
*
chunk
const
AutoLockGC
&
lock
)
;
#
ifdef
JS_GC_ZEAL
void
startVerifyPreBarriers
(
)
;
void
endVerifyPreBarriers
(
)
;
void
finishVerifier
(
)
;
bool
isVerifyPreBarriersEnabled
(
)
const
{
return
!
!
verifyPreData
;
}
#
else
bool
isVerifyPreBarriersEnabled
(
)
const
{
return
false
;
}
#
endif
void
freeUnusedLifoBlocksAfterSweeping
(
LifoAlloc
*
lifo
)
;
void
freeAllLifoBlocksAfterSweeping
(
LifoAlloc
*
lifo
)
;
void
releaseArena
(
Arena
*
arena
const
AutoLockGC
&
lock
)
;
void
releaseHeldRelocatedArenas
(
)
;
void
releaseHeldRelocatedArenasWithoutUnlocking
(
const
AutoLockGC
&
lock
)
;
template
<
AllowGC
allowGC
>
MOZ_MUST_USE
bool
checkAllocatorState
(
JSContext
*
cx
AllocKind
kind
)
;
template
<
AllowGC
allowGC
>
JSObject
*
tryNewNurseryObject
(
JSContext
*
cx
size_t
thingSize
size_t
nDynamicSlots
const
Class
*
clasp
)
;
template
<
AllowGC
allowGC
>
static
JSObject
*
tryNewTenuredObject
(
JSContext
*
cx
AllocKind
kind
size_t
thingSize
size_t
nDynamicSlots
)
;
template
<
typename
T
AllowGC
allowGC
>
static
T
*
tryNewTenuredThing
(
JSContext
*
cx
AllocKind
kind
size_t
thingSize
)
;
static
TenuredCell
*
refillFreeListInGC
(
Zone
*
zone
AllocKind
thingKind
)
;
void
bufferGrayRoots
(
)
;
private
:
enum
IncrementalResult
{
Reset
=
0
Ok
}
;
friend
class
ArenaLists
;
Chunk
*
pickChunk
(
const
AutoLockGC
&
lock
AutoMaybeStartBackgroundAllocation
&
maybeStartBGAlloc
)
;
Arena
*
allocateArena
(
Chunk
*
chunk
Zone
*
zone
AllocKind
kind
ShouldCheckThresholds
checkThresholds
const
AutoLockGC
&
lock
)
;
void
arenaAllocatedDuringGC
(
JS
:
:
Zone
*
zone
Arena
*
arena
)
;
MOZ_MUST_USE
bool
gcIfNeededAtAllocation
(
JSContext
*
cx
)
;
template
<
typename
T
>
static
void
checkIncrementalZoneState
(
JSContext
*
cx
T
*
t
)
;
static
TenuredCell
*
refillFreeListFromAnyThread
(
JSContext
*
cx
AllocKind
thingKind
size_t
thingSize
)
;
static
TenuredCell
*
refillFreeListFromActiveCooperatingThread
(
JSContext
*
cx
AllocKind
thingKind
size_t
thingSize
)
;
static
TenuredCell
*
refillFreeListFromHelperThread
(
JSContext
*
cx
AllocKind
thingKind
)
;
friend
class
BackgroundDecommitTask
;
ChunkPool
expireEmptyChunkPool
(
const
AutoLockGC
&
lock
)
;
void
freeEmptyChunks
(
JSRuntime
*
rt
const
AutoLockGC
&
lock
)
;
void
prepareToFreeChunk
(
ChunkInfo
&
info
)
;
friend
class
BackgroundAllocTask
;
friend
class
AutoMaybeStartBackgroundAllocation
;
bool
wantBackgroundAllocation
(
const
AutoLockGC
&
lock
)
const
;
void
startBackgroundAllocTaskIfIdle
(
)
;
void
requestMajorGC
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
SliceBudget
defaultBudget
(
JS
:
:
gcreason
:
:
Reason
reason
int64_t
millis
)
;
IncrementalResult
budgetIncrementalGC
(
bool
nonincrementalByAPI
JS
:
:
gcreason
:
:
Reason
reason
SliceBudget
&
budget
AutoLockForExclusiveAccess
&
lock
)
;
IncrementalResult
resetIncrementalGC
(
AbortReason
reason
AutoLockForExclusiveAccess
&
lock
)
;
void
checkCanCallAPI
(
)
;
MOZ_MUST_USE
bool
checkIfGCAllowedInCurrentState
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
gcstats
:
:
ZoneGCStats
scanZonesBeforeGC
(
)
;
void
collect
(
bool
nonincrementalByAPI
SliceBudget
budget
JS
:
:
gcreason
:
:
Reason
reason
)
JS_HAZ_GC_CALL
;
MOZ_MUST_USE
IncrementalResult
gcCycle
(
bool
nonincrementalByAPI
SliceBudget
&
budget
JS
:
:
gcreason
:
:
Reason
reason
)
;
bool
shouldRepeatForDeadZone
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
void
incrementalCollectSlice
(
SliceBudget
&
budget
JS
:
:
gcreason
:
:
Reason
reason
AutoLockForExclusiveAccess
&
lock
)
;
void
pushZealSelectedObjects
(
)
;
void
purgeRuntime
(
AutoLockForExclusiveAccess
&
lock
)
;
MOZ_MUST_USE
bool
beginMarkPhase
(
JS
:
:
gcreason
:
:
Reason
reason
AutoLockForExclusiveAccess
&
lock
)
;
bool
prepareZonesForCollection
(
JS
:
:
gcreason
:
:
Reason
reason
bool
*
isFullOut
AutoLockForExclusiveAccess
&
lock
)
;
bool
shouldPreserveJITCode
(
JSCompartment
*
comp
int64_t
currentTime
JS
:
:
gcreason
:
:
Reason
reason
bool
canAllocateMoreCode
)
;
void
traceRuntimeForMajorGC
(
JSTracer
*
trc
AutoLockForExclusiveAccess
&
lock
)
;
void
traceRuntimeAtoms
(
JSTracer
*
trc
AutoLockForExclusiveAccess
&
lock
)
;
void
traceRuntimeCommon
(
JSTracer
*
trc
TraceOrMarkRuntime
traceOrMark
AutoLockForExclusiveAccess
&
lock
)
;
void
maybeDoCycleCollection
(
)
;
void
markCompartments
(
)
;
IncrementalProgress
drainMarkStack
(
SliceBudget
&
sliceBudget
gcstats
:
:
PhaseKind
phase
)
;
template
<
class
CompartmentIterT
>
void
markWeakReferences
(
gcstats
:
:
PhaseKind
phase
)
;
void
markWeakReferencesInCurrentGroup
(
gcstats
:
:
PhaseKind
phase
)
;
template
<
class
ZoneIterT
class
CompartmentIterT
>
void
markGrayReferences
(
gcstats
:
:
PhaseKind
phase
)
;
void
markBufferedGrayRoots
(
JS
:
:
Zone
*
zone
)
;
void
markGrayReferencesInCurrentGroup
(
gcstats
:
:
PhaseKind
phase
)
;
void
markAllWeakReferences
(
gcstats
:
:
PhaseKind
phase
)
;
void
markAllGrayReferences
(
gcstats
:
:
PhaseKind
phase
)
;
void
beginSweepPhase
(
JS
:
:
gcreason
:
:
Reason
reason
AutoLockForExclusiveAccess
&
lock
)
;
void
groupZonesForSweeping
(
JS
:
:
gcreason
:
:
Reason
reason
AutoLockForExclusiveAccess
&
lock
)
;
MOZ_MUST_USE
bool
findInterZoneEdges
(
)
;
void
getNextSweepGroup
(
)
;
void
endMarkingSweepGroup
(
)
;
void
beginSweepingSweepGroup
(
)
;
bool
shouldReleaseObservedTypes
(
)
;
void
sweepDebuggerOnMainThread
(
FreeOp
*
fop
)
;
void
sweepJitDataOnMainThread
(
FreeOp
*
fop
)
;
void
endSweepingSweepGroup
(
)
;
IncrementalProgress
performSweepActions
(
SliceBudget
&
sliceBudget
AutoLockForExclusiveAccess
&
lock
)
;
static
IncrementalProgress
sweepTypeInformation
(
GCRuntime
*
gc
FreeOp
*
fop
Zone
*
zone
SliceBudget
&
budget
AllocKind
kind
)
;
static
IncrementalProgress
mergeSweptObjectArenas
(
GCRuntime
*
gc
FreeOp
*
fop
Zone
*
zone
SliceBudget
&
budget
AllocKind
kind
)
;
static
IncrementalProgress
sweepAtomsTable
(
GCRuntime
*
gc
SliceBudget
&
budget
)
;
void
startSweepingAtomsTable
(
)
;
IncrementalProgress
sweepAtomsTable
(
SliceBudget
&
budget
)
;
static
IncrementalProgress
finalizeAllocKind
(
GCRuntime
*
gc
FreeOp
*
fop
Zone
*
zone
SliceBudget
&
budget
AllocKind
kind
)
;
static
IncrementalProgress
sweepShapeTree
(
GCRuntime
*
gc
FreeOp
*
fop
Zone
*
zone
SliceBudget
&
budget
AllocKind
kind
)
;
void
endSweepPhase
(
bool
lastGC
AutoLockForExclusiveAccess
&
lock
)
;
bool
allCCVisibleZonesWereCollected
(
)
const
;
void
sweepZones
(
FreeOp
*
fop
ZoneGroup
*
group
bool
lastGC
)
;
void
sweepZoneGroups
(
FreeOp
*
fop
bool
destroyingRuntime
)
;
void
decommitAllWithoutUnlocking
(
const
AutoLockGC
&
lock
)
;
void
startDecommit
(
)
;
void
queueZonesForBackgroundSweep
(
ZoneList
&
zones
)
;
void
sweepBackgroundThings
(
ZoneList
&
zones
LifoAlloc
&
freeBlocks
)
;
void
assertBackgroundSweepingFinished
(
)
;
bool
shouldCompact
(
)
;
void
beginCompactPhase
(
)
;
IncrementalProgress
compactPhase
(
JS
:
:
gcreason
:
:
Reason
reason
SliceBudget
&
sliceBudget
AutoLockForExclusiveAccess
&
lock
)
;
void
endCompactPhase
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
void
sweepTypesAfterCompacting
(
Zone
*
zone
)
;
void
sweepZoneAfterCompacting
(
Zone
*
zone
)
;
MOZ_MUST_USE
bool
relocateArenas
(
Zone
*
zone
JS
:
:
gcreason
:
:
Reason
reason
Arena
*
&
relocatedListOut
SliceBudget
&
sliceBudget
)
;
void
updateTypeDescrObjects
(
MovingTracer
*
trc
Zone
*
zone
)
;
void
updateCellPointers
(
MovingTracer
*
trc
Zone
*
zone
AllocKinds
kinds
size_t
bgTaskCount
)
;
void
updateAllCellPointers
(
MovingTracer
*
trc
Zone
*
zone
)
;
void
updateZonePointersToRelocatedCells
(
Zone
*
zone
AutoLockForExclusiveAccess
&
lock
)
;
void
updateRuntimePointersToRelocatedCells
(
AutoLockForExclusiveAccess
&
lock
)
;
void
protectAndHoldArenas
(
Arena
*
arenaList
)
;
void
unprotectHeldRelocatedArenas
(
)
;
void
releaseRelocatedArenas
(
Arena
*
arenaList
)
;
void
releaseRelocatedArenasWithoutUnlocking
(
Arena
*
arenaList
const
AutoLockGC
&
lock
)
;
void
finishCollection
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
void
computeNonIncrementalMarkingForValidation
(
AutoLockForExclusiveAccess
&
lock
)
;
void
validateIncrementalMarking
(
)
;
void
finishMarkingValidation
(
)
;
#
ifdef
DEBUG
void
checkForCompartmentMismatches
(
)
;
#
endif
void
callFinalizeCallbacks
(
FreeOp
*
fop
JSFinalizeStatus
status
)
const
;
void
callWeakPointerZonesCallbacks
(
)
const
;
void
callWeakPointerCompartmentCallbacks
(
JSCompartment
*
comp
)
const
;
public
:
JSRuntime
*
const
rt
;
UnprotectedData
<
JS
:
:
Zone
*
>
systemZone
;
UnprotectedData
<
ZoneGroup
*
>
systemZoneGroup
;
ActiveThreadOrGCTaskData
<
ZoneGroupVector
>
groups
;
WriteOnceData
<
Zone
*
>
atomsZone
;
private
:
UnprotectedData
<
gcstats
:
:
Statistics
>
stats_
;
public
:
gcstats
:
:
Statistics
&
stats
(
)
{
return
stats_
.
ref
(
)
;
}
GCMarker
marker
;
Vector
<
JS
:
:
GCCellPtr
0
SystemAllocPolicy
>
unmarkGrayStack
;
HeapUsage
usage
;
GCSchedulingTunables
tunables
;
GCSchedulingState
schedulingState
;
MemProfiler
mMemProfiler
;
AtomMarkingRuntime
atomMarking
;
private
:
GCLockData
<
ChunkPool
>
emptyChunks_
;
UnprotectedData
<
ChunkPool
>
availableChunks_
;
UnprotectedData
<
ChunkPool
>
fullChunks_
;
ActiveThreadData
<
RootedValueMap
>
rootsHash
;
mozilla
:
:
Atomic
<
uint64_t
mozilla
:
:
ReleaseAcquire
>
nextCellUniqueId_
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
numArenasFreeCommitted
;
ActiveThreadData
<
VerifyPreTracer
*
>
verifyPreData
;
private
:
UnprotectedData
<
bool
>
chunkAllocationSinceLastGC
;
ActiveThreadData
<
int64_t
>
lastGCTime
;
ActiveThreadData
<
JSGCMode
>
mode
;
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
ReleaseAcquire
>
numActiveZoneIters
;
ActiveThreadData
<
bool
>
cleanUpEverything
;
enum
class
GrayBufferState
{
Unused
Okay
Failed
}
;
ActiveThreadOrGCTaskData
<
GrayBufferState
>
grayBufferState
;
bool
hasBufferedGrayRoots
(
)
const
{
return
grayBufferState
=
=
GrayBufferState
:
:
Okay
;
}
void
resetBufferedGrayRoots
(
)
const
;
void
clearBufferedGrayRoots
(
)
{
grayBufferState
=
GrayBufferState
:
:
Unused
;
resetBufferedGrayRoots
(
)
;
}
UnprotectedData
<
bool
>
grayBitsValid
;
mozilla
:
:
Atomic
<
JS
:
:
gcreason
:
:
Reason
mozilla
:
:
Relaxed
>
majorGCTriggerReason
;
private
:
ActiveThreadData
<
bool
>
fullGCForAtomsRequested_
;
ActiveThreadData
<
uint64_t
>
minorGCNumber
;
ActiveThreadData
<
uint64_t
>
majorGCNumber
;
ActiveThreadData
<
uint64_t
>
jitReleaseNumber
;
ActiveThreadData
<
uint64_t
>
number
;
ActiveThreadData
<
bool
>
isIncremental
;
ActiveThreadData
<
bool
>
isFull
;
ActiveThreadData
<
bool
>
isCompacting
;
ActiveThreadData
<
JSGCInvocationKind
>
invocationKind
;
ActiveThreadData
<
JS
:
:
gcreason
:
:
Reason
>
initialReason
;
ActiveThreadOrGCTaskData
<
State
>
incrementalState
;
ActiveThreadData
<
bool
>
lastMarkSlice
;
ActiveThreadData
<
bool
>
sweepOnBackgroundThread
;
ActiveThreadData
<
bool
>
releaseObservedTypes
;
ActiveThreadData
<
BlackGrayEdgeVector
>
foundBlackGrayEdges
;
ActiveThreadOrGCTaskData
<
ZoneList
>
backgroundSweepZones
;
ActiveThreadOrGCTaskData
<
LifoAlloc
>
blocksToFreeAfterSweeping
;
private
:
ActiveThreadData
<
unsigned
>
sweepGroupIndex
;
ActiveThreadData
<
JS
:
:
Zone
*
>
sweepGroups
;
ActiveThreadOrGCTaskData
<
JS
:
:
Zone
*
>
currentSweepGroup
;
ActiveThreadData
<
SweepActionList
>
sweepActionList
;
ActiveThreadData
<
size_t
>
sweepPhaseIndex
;
ActiveThreadData
<
JS
:
:
Zone
*
>
sweepZone
;
ActiveThreadData
<
size_t
>
sweepActionIndex
;
ActiveThreadData
<
mozilla
:
:
Maybe
<
AtomSet
:
:
Enum
>
>
maybeAtomsToSweep
;
ActiveThreadData
<
bool
>
abortSweepAfterCurrentGroup
;
void
startTask
(
GCParallelTask
&
task
gcstats
:
:
PhaseKind
phase
AutoLockHelperThreadState
&
locked
)
;
void
joinTask
(
GCParallelTask
&
task
gcstats
:
:
PhaseKind
phase
AutoLockHelperThreadState
&
locked
)
;
friend
class
AutoRunParallelTask
;
ActiveThreadData
<
Arena
*
>
arenasAllocatedDuringSweep
;
ActiveThreadData
<
bool
>
startedCompacting
;
ActiveThreadData
<
ZoneList
>
zonesToMaybeCompact
;
ActiveThreadData
<
Arena
*
>
relocatedArenasToRelease
;
#
ifdef
JS_GC_ZEAL
ActiveThreadData
<
MarkingValidator
*
>
markingValidator
;
#
endif
ActiveThreadData
<
bool
>
interFrameGC
;
ActiveThreadData
<
int64_t
>
defaultTimeBudget_
;
ActiveThreadData
<
bool
>
incrementalAllowed
;
ActiveThreadData
<
bool
>
compactingEnabled
;
ActiveThreadData
<
bool
>
poked
;
#
ifdef
JS_GC_ZEAL
ActiveThreadData
<
uint32_t
>
zealModeBits
;
ActiveThreadData
<
int
>
zealFrequency
;
ActiveThreadData
<
int
>
nextScheduled
;
ActiveThreadData
<
bool
>
deterministicOnly
;
ActiveThreadData
<
int
>
incrementalLimit
;
ActiveThreadData
<
Vector
<
JSObject
*
0
SystemAllocPolicy
>
>
selectedForMarking
;
#
endif
ActiveThreadData
<
bool
>
fullCompartmentChecks
;
Callback
<
JSGCCallback
>
gcCallback
;
Callback
<
JS
:
:
DoCycleCollectionCallback
>
gcDoCycleCollectionCallback
;
Callback
<
JSObjectsTenuredCallback
>
tenuredCallback
;
CallbackVector
<
JSFinalizeCallback
>
finalizeCallbacks
;
CallbackVector
<
JSWeakPointerZonesCallback
>
updateWeakPointerZonesCallbacks
;
CallbackVector
<
JSWeakPointerCompartmentCallback
>
updateWeakPointerCompartmentCallbacks
;
MemoryCounter
<
GCRuntime
>
mallocCounter
;
CallbackVector
<
JSTraceDataOp
>
blackRootTracers
;
Callback
<
JSTraceDataOp
>
grayRootTracer
;
ActiveThreadData
<
bool
>
alwaysPreserveCode
;
#
ifdef
DEBUG
ActiveThreadData
<
bool
>
arenasEmptyAtShutdown
;
#
endif
friend
class
js
:
:
AutoLockGC
;
js
:
:
Mutex
lock
;
BackgroundAllocTask
allocTask
;
BackgroundDecommitTask
decommitTask
;
GCHelperState
helperState
;
ActiveThreadData
<
SortedArenaList
>
incrementalSweepList
;
private
:
ActiveThreadData
<
Nursery
>
nursery_
;
ActiveThreadData
<
gc
:
:
StoreBuffer
>
storeBuffer_
;
public
:
Nursery
&
nursery
(
)
{
return
nursery_
.
ref
(
)
;
}
gc
:
:
StoreBuffer
&
storeBuffer
(
)
{
return
storeBuffer_
.
ref
(
)
;
}
ActiveThreadData
<
LifoAlloc
>
blocksToFreeAfterMinorGC
;
const
void
*
addressOfNurseryPosition
(
)
{
return
nursery_
.
refNoCheck
(
)
.
addressOfPosition
(
)
;
}
const
void
*
addressOfNurseryCurrentEnd
(
)
{
return
nursery_
.
refNoCheck
(
)
.
addressOfCurrentEnd
(
)
;
}
void
minorGC
(
JS
:
:
gcreason
:
:
Reason
reason
gcstats
:
:
PhaseKind
phase
=
gcstats
:
:
PhaseKind
:
:
MINOR_GC
)
JS_HAZ_GC_CALL
;
void
evictNursery
(
JS
:
:
gcreason
:
:
Reason
reason
=
JS
:
:
gcreason
:
:
EVICT_NURSERY
)
{
minorGC
(
reason
gcstats
:
:
PhaseKind
:
:
EVICT_NURSERY
)
;
}
void
freeAllLifoBlocksAfterMinorGC
(
LifoAlloc
*
lifo
)
;
friend
class
js
:
:
GCHelperState
;
friend
class
MarkingValidator
;
friend
class
AutoTraceSession
;
friend
class
AutoEnterIteration
;
}
;
class
MOZ_RAII
AutoEnterIteration
{
GCRuntime
*
gc
;
public
:
explicit
AutoEnterIteration
(
GCRuntime
*
gc_
)
:
gc
(
gc_
)
{
+
+
gc
-
>
numActiveZoneIters
;
}
~
AutoEnterIteration
(
)
{
MOZ_ASSERT
(
gc
-
>
numActiveZoneIters
)
;
-
-
gc
-
>
numActiveZoneIters
;
}
}
;
class
MOZ_RAII
AutoMaybeStartBackgroundAllocation
{
GCRuntime
*
gc
;
public
:
AutoMaybeStartBackgroundAllocation
(
)
:
gc
(
nullptr
)
{
}
void
tryToStartBackgroundAllocation
(
GCRuntime
&
gc
)
{
this
-
>
gc
=
&
gc
;
}
~
AutoMaybeStartBackgroundAllocation
(
)
{
if
(
gc
)
gc
-
>
startBackgroundAllocTaskIfIdle
(
)
;
}
}
;
#
ifdef
JS_GC_ZEAL
inline
bool
GCRuntime
:
:
hasZealMode
(
ZealMode
mode
)
{
static_assert
(
size_t
(
ZealMode
:
:
Limit
)
<
sizeof
(
zealModeBits
)
*
8
"
Zeal
modes
must
fit
in
zealModeBits
"
)
;
return
zealModeBits
&
(
1
<
<
uint32_t
(
mode
)
)
;
}
inline
void
GCRuntime
:
:
clearZealMode
(
ZealMode
mode
)
{
zealModeBits
&
=
~
(
1
<
<
uint32_t
(
mode
)
)
;
MOZ_ASSERT
(
!
hasZealMode
(
mode
)
)
;
}
inline
bool
GCRuntime
:
:
upcomingZealousGC
(
)
{
return
nextScheduled
=
=
1
;
}
inline
bool
GCRuntime
:
:
needZealousGC
(
)
{
if
(
nextScheduled
>
0
&
&
-
-
nextScheduled
=
=
0
)
{
if
(
hasZealMode
(
ZealMode
:
:
Alloc
)
|
|
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
|
|
hasZealMode
(
ZealMode
:
:
IncrementalRootsThenFinish
)
|
|
hasZealMode
(
ZealMode
:
:
IncrementalMarkAllThenFinish
)
|
|
hasZealMode
(
ZealMode
:
:
IncrementalMultipleSlices
)
|
|
hasZealMode
(
ZealMode
:
:
Compact
)
|
|
hasZealMode
(
ZealMode
:
:
IncrementalSweepThenFinish
)
)
{
nextScheduled
=
zealFrequency
;
}
return
true
;
}
return
false
;
}
#
else
inline
bool
GCRuntime
:
:
hasZealMode
(
ZealMode
mode
)
{
return
false
;
}
inline
void
GCRuntime
:
:
clearZealMode
(
ZealMode
mode
)
{
}
inline
bool
GCRuntime
:
:
upcomingZealousGC
(
)
{
return
false
;
}
inline
bool
GCRuntime
:
:
needZealousGC
(
)
{
return
false
;
}
#
endif
}
}
#
endif
