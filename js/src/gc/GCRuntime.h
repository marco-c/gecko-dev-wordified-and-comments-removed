#
ifndef
gc_GCRuntime_h
#
define
gc_GCRuntime_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsgc
.
h
"
#
include
"
gc
/
AtomMarking
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
gc
/
Nursery
.
h
"
#
include
"
gc
/
Statistics
.
h
"
#
include
"
gc
/
StoreBuffer
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
namespace
js
{
class
AutoLockGC
;
class
AutoLockHelperThreadState
;
class
VerifyPreTracer
;
namespace
gc
{
typedef
Vector
<
ZoneGroup
*
4
SystemAllocPolicy
>
ZoneGroupVector
;
using
BlackGrayEdgeVector
=
Vector
<
TenuredCell
*
0
SystemAllocPolicy
>
;
class
AutoMaybeStartBackgroundAllocation
;
class
MarkingValidator
;
class
AutoTraceSession
;
struct
MovingTracer
;
class
ChunkPool
{
Chunk
*
head_
;
size_t
count_
;
public
:
ChunkPool
(
)
:
head_
(
nullptr
)
count_
(
0
)
{
}
size_t
count
(
)
const
{
return
count_
;
}
Chunk
*
head
(
)
{
MOZ_ASSERT
(
head_
)
;
return
head_
;
}
Chunk
*
pop
(
)
;
void
push
(
Chunk
*
chunk
)
;
Chunk
*
remove
(
Chunk
*
chunk
)
;
#
ifdef
DEBUG
bool
contains
(
Chunk
*
chunk
)
const
;
bool
verify
(
)
const
;
#
endif
class
Iter
{
public
:
explicit
Iter
(
ChunkPool
&
pool
)
:
current_
(
pool
.
head_
)
{
}
bool
done
(
)
const
{
return
!
current_
;
}
void
next
(
)
;
Chunk
*
get
(
)
const
{
return
current_
;
}
operator
Chunk
*
(
)
const
{
return
get
(
)
;
}
Chunk
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
private
:
Chunk
*
current_
;
}
;
}
;
class
BackgroundAllocTask
:
public
GCParallelTask
{
GCLockData
<
ChunkPool
&
>
chunkPool_
;
const
bool
enabled_
;
public
:
BackgroundAllocTask
(
JSRuntime
*
rt
ChunkPool
&
pool
)
;
bool
enabled
(
)
const
{
return
enabled_
;
}
protected
:
void
run
(
)
override
;
}
;
class
BackgroundDecommitTask
:
public
GCParallelTask
{
public
:
using
ChunkVector
=
mozilla
:
:
Vector
<
Chunk
*
>
;
explicit
BackgroundDecommitTask
(
JSRuntime
*
rt
)
:
GCParallelTask
(
rt
)
{
}
void
setChunksToScan
(
ChunkVector
&
chunks
)
;
protected
:
void
run
(
)
override
;
private
:
ActiveThreadOrGCTaskData
<
ChunkVector
>
toDecommit
;
}
;
class
GCSchedulingTunables
{
UnprotectedData
<
size_t
>
gcMaxBytes_
;
ActiveThreadData
<
size_t
>
gcMaxNurseryBytes_
;
ActiveThreadOrGCTaskData
<
size_t
>
gcZoneAllocThresholdBase_
;
UnprotectedData
<
double
>
zoneAllocThresholdFactor_
;
UnprotectedData
<
size_t
>
zoneAllocDelayBytes_
;
ActiveThreadData
<
bool
>
dynamicHeapGrowthEnabled_
;
ActiveThreadData
<
uint64_t
>
highFrequencyThresholdUsec_
;
ActiveThreadData
<
uint64_t
>
highFrequencyLowLimitBytes_
;
ActiveThreadData
<
uint64_t
>
highFrequencyHighLimitBytes_
;
ActiveThreadData
<
double
>
highFrequencyHeapGrowthMax_
;
ActiveThreadData
<
double
>
highFrequencyHeapGrowthMin_
;
ActiveThreadData
<
double
>
lowFrequencyHeapGrowth_
;
ActiveThreadData
<
bool
>
dynamicMarkSliceEnabled_
;
ActiveThreadData
<
bool
>
refreshFrameSlicesEnabled_
;
UnprotectedData
<
uint32_t
>
minEmptyChunkCount_
;
UnprotectedData
<
uint32_t
>
maxEmptyChunkCount_
;
public
:
GCSchedulingTunables
(
)
:
gcMaxBytes_
(
0
)
gcMaxNurseryBytes_
(
0
)
gcZoneAllocThresholdBase_
(
30
*
1024
*
1024
)
zoneAllocThresholdFactor_
(
0
.
9
)
zoneAllocDelayBytes_
(
1024
*
1024
)
dynamicHeapGrowthEnabled_
(
false
)
highFrequencyThresholdUsec_
(
1000
*
1000
)
highFrequencyLowLimitBytes_
(
100
*
1024
*
1024
)
highFrequencyHighLimitBytes_
(
500
*
1024
*
1024
)
highFrequencyHeapGrowthMax_
(
3
.
0
)
highFrequencyHeapGrowthMin_
(
1
.
5
)
lowFrequencyHeapGrowth_
(
1
.
5
)
dynamicMarkSliceEnabled_
(
false
)
refreshFrameSlicesEnabled_
(
true
)
minEmptyChunkCount_
(
1
)
maxEmptyChunkCount_
(
30
)
{
}
size_t
gcMaxBytes
(
)
const
{
return
gcMaxBytes_
;
}
size_t
gcMaxNurseryBytes
(
)
const
{
return
gcMaxNurseryBytes_
;
}
size_t
gcZoneAllocThresholdBase
(
)
const
{
return
gcZoneAllocThresholdBase_
;
}
double
zoneAllocThresholdFactor
(
)
const
{
return
zoneAllocThresholdFactor_
;
}
size_t
zoneAllocDelayBytes
(
)
const
{
return
zoneAllocDelayBytes_
;
}
bool
isDynamicHeapGrowthEnabled
(
)
const
{
return
dynamicHeapGrowthEnabled_
;
}
uint64_t
highFrequencyThresholdUsec
(
)
const
{
return
highFrequencyThresholdUsec_
;
}
uint64_t
highFrequencyLowLimitBytes
(
)
const
{
return
highFrequencyLowLimitBytes_
;
}
uint64_t
highFrequencyHighLimitBytes
(
)
const
{
return
highFrequencyHighLimitBytes_
;
}
double
highFrequencyHeapGrowthMax
(
)
const
{
return
highFrequencyHeapGrowthMax_
;
}
double
highFrequencyHeapGrowthMin
(
)
const
{
return
highFrequencyHeapGrowthMin_
;
}
double
lowFrequencyHeapGrowth
(
)
const
{
return
lowFrequencyHeapGrowth_
;
}
bool
isDynamicMarkSliceEnabled
(
)
const
{
return
dynamicMarkSliceEnabled_
;
}
bool
areRefreshFrameSlicesEnabled
(
)
const
{
return
refreshFrameSlicesEnabled_
;
}
unsigned
minEmptyChunkCount
(
const
AutoLockGC
&
)
const
{
return
minEmptyChunkCount_
;
}
unsigned
maxEmptyChunkCount
(
)
const
{
return
maxEmptyChunkCount_
;
}
MOZ_MUST_USE
bool
setParameter
(
JSGCParamKey
key
uint32_t
value
const
AutoLockGC
&
lock
)
;
}
;
class
GCSchedulingState
{
ActiveThreadData
<
bool
>
inHighFrequencyGCMode_
;
public
:
GCSchedulingState
(
)
:
inHighFrequencyGCMode_
(
false
)
{
}
bool
inHighFrequencyGCMode
(
)
const
{
return
inHighFrequencyGCMode_
;
}
void
updateHighFrequencyMode
(
uint64_t
lastGCTime
uint64_t
currentTime
const
GCSchedulingTunables
&
tunables
)
{
inHighFrequencyGCMode_
=
tunables
.
isDynamicHeapGrowthEnabled
(
)
&
&
lastGCTime
&
&
lastGCTime
+
tunables
.
highFrequencyThresholdUsec
(
)
>
currentTime
;
}
}
;
template
<
typename
F
>
struct
Callback
{
ActiveThreadData
<
F
>
op
;
ActiveThreadData
<
void
*
>
data
;
Callback
(
)
:
op
(
nullptr
)
data
(
nullptr
)
{
}
Callback
(
F
op
void
*
data
)
:
op
(
op
)
data
(
data
)
{
}
}
;
template
<
typename
F
>
using
CallbackVector
=
ActiveThreadData
<
Vector
<
Callback
<
F
>
4
SystemAllocPolicy
>
>
;
template
<
typename
T
typename
Iter0
typename
Iter1
>
class
ChainedIter
{
Iter0
iter0_
;
Iter1
iter1_
;
public
:
ChainedIter
(
const
Iter0
&
iter0
const
Iter1
&
iter1
)
:
iter0_
(
iter0
)
iter1_
(
iter1
)
{
}
bool
done
(
)
const
{
return
iter0_
.
done
(
)
&
&
iter1_
.
done
(
)
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
!
iter0_
.
done
(
)
)
{
iter0_
.
next
(
)
;
}
else
{
MOZ_ASSERT
(
!
iter1_
.
done
(
)
)
;
iter1_
.
next
(
)
;
}
}
T
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
!
iter0_
.
done
(
)
)
return
iter0_
.
get
(
)
;
MOZ_ASSERT
(
!
iter1_
.
done
(
)
)
;
return
iter1_
.
get
(
)
;
}
operator
T
(
)
const
{
return
get
(
)
;
}
T
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
typedef
HashMap
<
Value
*
const
char
*
DefaultHasher
<
Value
*
>
SystemAllocPolicy
>
RootedValueMap
;
using
AllocKinds
=
mozilla
:
:
EnumSet
<
AllocKind
>
;
class
GCRuntime
{
public
:
explicit
GCRuntime
(
JSRuntime
*
rt
)
;
MOZ_MUST_USE
bool
init
(
uint32_t
maxbytes
uint32_t
maxNurseryBytes
)
;
void
finishRoots
(
)
;
void
finish
(
)
;
inline
bool
hasZealMode
(
ZealMode
mode
)
;
inline
void
clearZealMode
(
ZealMode
mode
)
;
inline
bool
upcomingZealousGC
(
)
;
inline
bool
needZealousGC
(
)
;
MOZ_MUST_USE
bool
addRoot
(
Value
*
vp
const
char
*
name
)
;
void
removeRoot
(
Value
*
vp
)
;
void
setMarkStackLimit
(
size_t
limit
AutoLockGC
&
lock
)
;
MOZ_MUST_USE
bool
setParameter
(
JSGCParamKey
key
uint32_t
value
AutoLockGC
&
lock
)
;
uint32_t
getParameter
(
JSGCParamKey
key
const
AutoLockGC
&
lock
)
;
MOZ_MUST_USE
bool
triggerGC
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
void
maybeAllocTriggerZoneGC
(
Zone
*
zone
const
AutoLockGC
&
lock
)
;
bool
triggerZoneGC
(
Zone
*
zone
JS
:
:
gcreason
:
:
Reason
reason
)
;
void
maybeGC
(
Zone
*
zone
)
;
bool
gcIfRequested
(
)
;
void
gc
(
JSGCInvocationKind
gckind
JS
:
:
gcreason
:
:
Reason
reason
)
;
void
startGC
(
JSGCInvocationKind
gckind
JS
:
:
gcreason
:
:
Reason
reason
int64_t
millis
=
0
)
;
void
gcSlice
(
JS
:
:
gcreason
:
:
Reason
reason
int64_t
millis
=
0
)
;
void
finishGC
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
void
abortGC
(
)
;
void
startDebugGC
(
JSGCInvocationKind
gckind
SliceBudget
&
budget
)
;
void
debugGCSlice
(
SliceBudget
&
budget
)
;
bool
canChangeActiveContext
(
JSContext
*
cx
)
;
void
triggerFullGCForAtoms
(
)
{
MOZ_ASSERT
(
fullGCForAtomsRequested_
)
;
fullGCForAtomsRequested_
=
false
;
MOZ_RELEASE_ASSERT
(
triggerGC
(
JS
:
:
gcreason
:
:
ALLOC_TRIGGER
)
)
;
}
void
runDebugGC
(
)
;
inline
void
poke
(
)
;
enum
TraceOrMarkRuntime
{
TraceRuntime
MarkRuntime
}
;
void
traceRuntime
(
JSTracer
*
trc
AutoLockForExclusiveAccess
&
lock
)
;
void
traceRuntimeForMinorGC
(
JSTracer
*
trc
AutoLockForExclusiveAccess
&
lock
)
;
void
notifyDidPaint
(
)
;
void
shrinkBuffers
(
)
;
void
onOutOfMallocMemory
(
)
;
void
onOutOfMallocMemory
(
const
AutoLockGC
&
lock
)
;
#
ifdef
JS_GC_ZEAL
const
void
*
addressOfZealModeBits
(
)
{
return
&
zealModeBits
;
}
void
getZealBits
(
uint32_t
*
zealBits
uint32_t
*
frequency
uint32_t
*
nextScheduled
)
;
void
setZeal
(
uint8_t
zeal
uint32_t
frequency
)
;
bool
parseAndSetZeal
(
const
char
*
str
)
;
void
setNextScheduled
(
uint32_t
count
)
;
void
verifyPreBarriers
(
)
;
void
maybeVerifyPreBarriers
(
bool
always
)
;
bool
selectForMarking
(
JSObject
*
object
)
;
void
clearSelectedForMarking
(
)
;
void
setDeterministic
(
bool
enable
)
;
#
endif
size_t
maxMallocBytesAllocated
(
)
{
return
maxMallocBytes
;
}
uint64_t
nextCellUniqueId
(
)
{
MOZ_ASSERT
(
nextCellUniqueId_
>
0
)
;
uint64_t
uid
=
+
+
nextCellUniqueId_
;
return
uid
;
}
#
ifdef
DEBUG
bool
shutdownCollectedEverything
(
)
const
{
return
arenasEmptyAtShutdown
;
}
#
endif
public
:
State
state
(
)
const
{
return
incrementalState
;
}
bool
isHeapCompacting
(
)
const
{
return
state
(
)
=
=
State
:
:
Compact
;
}
bool
isForegroundSweeping
(
)
const
{
return
state
(
)
=
=
State
:
:
Sweep
;
}
bool
isBackgroundSweeping
(
)
{
return
helperState
.
isBackgroundSweeping
(
)
;
}
void
waitBackgroundSweepEnd
(
)
{
helperState
.
waitBackgroundSweepEnd
(
)
;
}
void
waitBackgroundSweepOrAllocEnd
(
)
{
helperState
.
waitBackgroundSweepEnd
(
)
;
allocTask
.
cancel
(
GCParallelTask
:
:
CancelAndWait
)
;
}
#
ifdef
DEBUG
bool
onBackgroundThread
(
)
{
return
helperState
.
onBackgroundThread
(
)
;
}
#
endif
void
lockGC
(
)
{
lock
.
lock
(
)
;
}
void
unlockGC
(
)
{
lock
.
unlock
(
)
;
}
#
ifdef
DEBUG
bool
currentThreadHasLockedGC
(
)
const
{
return
lock
.
ownedByCurrentThread
(
)
;
}
#
endif
void
setAlwaysPreserveCode
(
)
{
alwaysPreserveCode
=
true
;
}
bool
isIncrementalGCAllowed
(
)
const
{
return
incrementalAllowed
;
}
void
disallowIncrementalGC
(
)
{
incrementalAllowed
=
false
;
}
bool
isIncrementalGCEnabled
(
)
const
{
return
mode
=
=
JSGC_MODE_INCREMENTAL
&
&
incrementalAllowed
;
}
bool
isIncrementalGCInProgress
(
)
const
{
return
state
(
)
!
=
State
:
:
NotActive
;
}
bool
isCompactingGCEnabled
(
)
const
;
void
setGrayRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
;
MOZ_MUST_USE
bool
addBlackRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
;
void
removeBlackRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
;
void
setMaxMallocBytes
(
size_t
value
)
;
int32_t
getMallocBytes
(
)
const
{
return
mallocBytesUntilGC
;
}
void
resetMallocBytes
(
)
;
bool
isTooMuchMalloc
(
)
const
{
return
mallocBytesUntilGC
<
=
0
;
}
void
updateMallocCounter
(
JS
:
:
Zone
*
zone
size_t
nbytes
)
;
void
onTooMuchMalloc
(
)
;
void
setGCCallback
(
JSGCCallback
callback
void
*
data
)
;
void
callGCCallback
(
JSGCStatus
status
)
const
;
void
setObjectsTenuredCallback
(
JSObjectsTenuredCallback
callback
void
*
data
)
;
void
callObjectsTenuredCallback
(
)
;
MOZ_MUST_USE
bool
addFinalizeCallback
(
JSFinalizeCallback
callback
void
*
data
)
;
void
removeFinalizeCallback
(
JSFinalizeCallback
func
)
;
MOZ_MUST_USE
bool
addWeakPointerZoneGroupCallback
(
JSWeakPointerZoneGroupCallback
callback
void
*
data
)
;
void
removeWeakPointerZoneGroupCallback
(
JSWeakPointerZoneGroupCallback
callback
)
;
MOZ_MUST_USE
bool
addWeakPointerCompartmentCallback
(
JSWeakPointerCompartmentCallback
callback
void
*
data
)
;
void
removeWeakPointerCompartmentCallback
(
JSWeakPointerCompartmentCallback
callback
)
;
JS
:
:
GCSliceCallback
setSliceCallback
(
JS
:
:
GCSliceCallback
callback
)
;
JS
:
:
GCNurseryCollectionCallback
setNurseryCollectionCallback
(
JS
:
:
GCNurseryCollectionCallback
callback
)
;
JS
:
:
DoCycleCollectionCallback
setDoCycleCollectionCallback
(
JS
:
:
DoCycleCollectionCallback
callback
)
;
void
callDoCycleCollectionCallback
(
JSContext
*
cx
)
;
void
setFullCompartmentChecks
(
bool
enable
)
;
JS
:
:
Zone
*
getCurrentZoneGroup
(
)
{
return
currentZoneGroup
;
}
void
setFoundBlackGrayEdges
(
TenuredCell
&
target
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
foundBlackGrayEdges
.
ref
(
)
.
append
(
&
target
)
)
oomUnsafe
.
crash
(
"
OOM
|
small
:
failed
to
insert
into
foundBlackGrayEdges
"
)
;
}
uint64_t
gcNumber
(
)
const
{
return
number
;
}
uint64_t
minorGCCount
(
)
const
{
return
minorGCNumber
;
}
void
incMinorGcNumber
(
)
{
+
+
minorGCNumber
;
+
+
number
;
}
uint64_t
majorGCCount
(
)
const
{
return
majorGCNumber
;
}
void
incMajorGcNumber
(
)
{
+
+
majorGCNumber
;
+
+
number
;
}
int64_t
defaultSliceBudget
(
)
const
{
return
defaultTimeBudget_
;
}
bool
isIncrementalGc
(
)
const
{
return
isIncremental
;
}
bool
isFullGc
(
)
const
{
return
isFull
;
}
bool
isCompactingGc
(
)
const
{
return
isCompacting
;
}
bool
areGrayBitsValid
(
)
const
{
return
grayBitsValid
;
}
void
setGrayBitsInvalid
(
)
{
grayBitsValid
=
false
;
}
bool
majorGCRequested
(
)
const
{
return
majorGCTriggerReason
!
=
JS
:
:
gcreason
:
:
NO_REASON
;
}
bool
fullGCForAtomsRequested
(
)
const
{
return
fullGCForAtomsRequested_
;
}
double
computeHeapGrowthFactor
(
size_t
lastBytes
)
;
size_t
computeTriggerBytes
(
double
growthFactor
size_t
lastBytes
)
;
JSGCMode
gcMode
(
)
const
{
return
mode
;
}
void
setGCMode
(
JSGCMode
m
)
{
mode
=
m
;
marker
.
setGCMode
(
mode
)
;
}
inline
void
updateOnFreeArenaAlloc
(
const
ChunkInfo
&
info
)
;
inline
void
updateOnArenaFree
(
const
ChunkInfo
&
info
)
;
ChunkPool
&
fullChunks
(
const
AutoLockGC
&
lock
)
{
return
fullChunks_
.
ref
(
)
;
}
ChunkPool
&
availableChunks
(
const
AutoLockGC
&
lock
)
{
return
availableChunks_
.
ref
(
)
;
}
ChunkPool
&
emptyChunks
(
const
AutoLockGC
&
lock
)
{
return
emptyChunks_
.
ref
(
)
;
}
const
ChunkPool
&
fullChunks
(
const
AutoLockGC
&
lock
)
const
{
return
fullChunks_
.
ref
(
)
;
}
const
ChunkPool
&
availableChunks
(
const
AutoLockGC
&
lock
)
const
{
return
availableChunks_
.
ref
(
)
;
}
const
ChunkPool
&
emptyChunks
(
const
AutoLockGC
&
lock
)
const
{
return
emptyChunks_
.
ref
(
)
;
}
typedef
ChainedIter
<
Chunk
*
ChunkPool
:
:
Iter
ChunkPool
:
:
Iter
>
NonEmptyChunksIter
;
NonEmptyChunksIter
allNonEmptyChunks
(
)
{
return
NonEmptyChunksIter
(
ChunkPool
:
:
Iter
(
availableChunks_
.
ref
(
)
)
ChunkPool
:
:
Iter
(
fullChunks_
.
ref
(
)
)
)
;
}
Chunk
*
getOrAllocChunk
(
const
AutoLockGC
&
lock
AutoMaybeStartBackgroundAllocation
&
maybeStartBGAlloc
)
;
void
recycleChunk
(
Chunk
*
chunk
const
AutoLockGC
&
lock
)
;
#
ifdef
JS_GC_ZEAL
void
startVerifyPreBarriers
(
)
;
void
endVerifyPreBarriers
(
)
;
void
finishVerifier
(
)
;
bool
isVerifyPreBarriersEnabled
(
)
const
{
return
!
!
verifyPreData
;
}
#
else
bool
isVerifyPreBarriersEnabled
(
)
const
{
return
false
;
}
#
endif
void
freeUnusedLifoBlocksAfterSweeping
(
LifoAlloc
*
lifo
)
;
void
freeAllLifoBlocksAfterSweeping
(
LifoAlloc
*
lifo
)
;
void
releaseArena
(
Arena
*
arena
const
AutoLockGC
&
lock
)
;
void
releaseHeldRelocatedArenas
(
)
;
void
releaseHeldRelocatedArenasWithoutUnlocking
(
const
AutoLockGC
&
lock
)
;
template
<
AllowGC
allowGC
>
MOZ_MUST_USE
bool
checkAllocatorState
(
JSContext
*
cx
AllocKind
kind
)
;
template
<
AllowGC
allowGC
>
JSObject
*
tryNewNurseryObject
(
JSContext
*
cx
size_t
thingSize
size_t
nDynamicSlots
const
Class
*
clasp
)
;
template
<
AllowGC
allowGC
>
static
JSObject
*
tryNewTenuredObject
(
JSContext
*
cx
AllocKind
kind
size_t
thingSize
size_t
nDynamicSlots
)
;
template
<
typename
T
AllowGC
allowGC
>
static
T
*
tryNewTenuredThing
(
JSContext
*
cx
AllocKind
kind
size_t
thingSize
)
;
static
TenuredCell
*
refillFreeListInGC
(
Zone
*
zone
AllocKind
thingKind
)
;
private
:
enum
IncrementalProgress
{
NotFinished
=
0
Finished
}
;
enum
IncrementalResult
{
Reset
=
0
Ok
}
;
friend
class
ArenaLists
;
Chunk
*
pickChunk
(
const
AutoLockGC
&
lock
AutoMaybeStartBackgroundAllocation
&
maybeStartBGAlloc
)
;
Arena
*
allocateArena
(
Chunk
*
chunk
Zone
*
zone
AllocKind
kind
ShouldCheckThresholds
checkThresholds
const
AutoLockGC
&
lock
)
;
void
arenaAllocatedDuringGC
(
JS
:
:
Zone
*
zone
Arena
*
arena
)
;
MOZ_MUST_USE
bool
gcIfNeededPerAllocation
(
JSContext
*
cx
)
;
template
<
typename
T
>
static
void
checkIncrementalZoneState
(
JSContext
*
cx
T
*
t
)
;
static
TenuredCell
*
refillFreeListFromAnyThread
(
JSContext
*
cx
AllocKind
thingKind
size_t
thingSize
)
;
static
TenuredCell
*
refillFreeListFromMainThread
(
JSContext
*
cx
AllocKind
thingKind
size_t
thingSize
)
;
static
TenuredCell
*
refillFreeListOffMainThread
(
JSContext
*
cx
AllocKind
thingKind
)
;
friend
class
BackgroundDecommitTask
;
ChunkPool
expireEmptyChunkPool
(
const
AutoLockGC
&
lock
)
;
void
freeEmptyChunks
(
JSRuntime
*
rt
const
AutoLockGC
&
lock
)
;
void
prepareToFreeChunk
(
ChunkInfo
&
info
)
;
friend
class
BackgroundAllocTask
;
friend
class
AutoMaybeStartBackgroundAllocation
;
bool
wantBackgroundAllocation
(
const
AutoLockGC
&
lock
)
const
;
void
startBackgroundAllocTaskIfIdle
(
)
;
void
requestMajorGC
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
SliceBudget
defaultBudget
(
JS
:
:
gcreason
:
:
Reason
reason
int64_t
millis
)
;
IncrementalResult
budgetIncrementalGC
(
bool
nonincrementalByAPI
JS
:
:
gcreason
:
:
Reason
reason
SliceBudget
&
budget
AutoLockForExclusiveAccess
&
lock
)
;
IncrementalResult
resetIncrementalGC
(
AbortReason
reason
AutoLockForExclusiveAccess
&
lock
)
;
void
checkCanCallAPI
(
)
;
MOZ_MUST_USE
bool
checkIfGCAllowedInCurrentState
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
gcstats
:
:
ZoneGCStats
scanZonesBeforeGC
(
)
;
void
collect
(
bool
nonincrementalByAPI
SliceBudget
budget
JS
:
:
gcreason
:
:
Reason
reason
)
JS_HAZ_GC_CALL
;
MOZ_MUST_USE
IncrementalResult
gcCycle
(
bool
nonincrementalByAPI
SliceBudget
&
budget
JS
:
:
gcreason
:
:
Reason
reason
)
;
bool
shouldRepeatForDeadZone
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
void
incrementalCollectSlice
(
SliceBudget
&
budget
JS
:
:
gcreason
:
:
Reason
reason
AutoLockForExclusiveAccess
&
lock
)
;
void
pushZealSelectedObjects
(
)
;
void
purgeRuntime
(
AutoLockForExclusiveAccess
&
lock
)
;
MOZ_MUST_USE
bool
beginMarkPhase
(
JS
:
:
gcreason
:
:
Reason
reason
AutoLockForExclusiveAccess
&
lock
)
;
bool
shouldPreserveJITCode
(
JSCompartment
*
comp
int64_t
currentTime
JS
:
:
gcreason
:
:
Reason
reason
bool
canAllocateMoreCode
)
;
void
traceRuntimeForMajorGC
(
JSTracer
*
trc
AutoLockForExclusiveAccess
&
lock
)
;
void
traceRuntimeAtoms
(
JSTracer
*
trc
AutoLockForExclusiveAccess
&
lock
)
;
void
traceRuntimeCommon
(
JSTracer
*
trc
TraceOrMarkRuntime
traceOrMark
AutoLockForExclusiveAccess
&
lock
)
;
void
bufferGrayRoots
(
)
;
void
maybeDoCycleCollection
(
)
;
void
markCompartments
(
)
;
IncrementalProgress
drainMarkStack
(
SliceBudget
&
sliceBudget
gcstats
:
:
Phase
phase
)
;
template
<
class
CompartmentIterT
>
void
markWeakReferences
(
gcstats
:
:
Phase
phase
)
;
void
markWeakReferencesInCurrentGroup
(
gcstats
:
:
Phase
phase
)
;
template
<
class
ZoneIterT
class
CompartmentIterT
>
void
markGrayReferences
(
gcstats
:
:
Phase
phase
)
;
void
markBufferedGrayRoots
(
JS
:
:
Zone
*
zone
)
;
void
markGrayReferencesInCurrentGroup
(
gcstats
:
:
Phase
phase
)
;
void
markAllWeakReferences
(
gcstats
:
:
Phase
phase
)
;
void
markAllGrayReferences
(
gcstats
:
:
Phase
phase
)
;
void
beginSweepPhase
(
bool
lastGC
AutoLockForExclusiveAccess
&
lock
)
;
void
findZoneGroups
(
AutoLockForExclusiveAccess
&
lock
)
;
MOZ_MUST_USE
bool
findZoneEdgesForWeakMaps
(
)
;
void
getNextZoneGroup
(
)
;
void
endMarkingZoneGroup
(
)
;
void
beginSweepingZoneGroup
(
AutoLockForExclusiveAccess
&
lock
)
;
bool
shouldReleaseObservedTypes
(
)
;
void
endSweepingZoneGroup
(
)
;
IncrementalProgress
sweepPhase
(
SliceBudget
&
sliceBudget
AutoLockForExclusiveAccess
&
lock
)
;
void
endSweepPhase
(
bool
lastGC
AutoLockForExclusiveAccess
&
lock
)
;
void
sweepZones
(
FreeOp
*
fop
ZoneGroup
*
group
bool
lastGC
)
;
void
sweepZoneGroups
(
FreeOp
*
fop
bool
destroyingRuntime
)
;
void
decommitAllWithoutUnlocking
(
const
AutoLockGC
&
lock
)
;
void
startDecommit
(
)
;
void
queueZonesForBackgroundSweep
(
ZoneList
&
zones
)
;
void
sweepBackgroundThings
(
ZoneList
&
zones
LifoAlloc
&
freeBlocks
)
;
void
assertBackgroundSweepingFinished
(
)
;
bool
shouldCompact
(
)
;
void
beginCompactPhase
(
)
;
IncrementalProgress
compactPhase
(
JS
:
:
gcreason
:
:
Reason
reason
SliceBudget
&
sliceBudget
AutoLockForExclusiveAccess
&
lock
)
;
void
endCompactPhase
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
void
sweepTypesAfterCompacting
(
Zone
*
zone
)
;
void
sweepZoneAfterCompacting
(
Zone
*
zone
)
;
MOZ_MUST_USE
bool
relocateArenas
(
Zone
*
zone
JS
:
:
gcreason
:
:
Reason
reason
Arena
*
&
relocatedListOut
SliceBudget
&
sliceBudget
)
;
void
updateTypeDescrObjects
(
MovingTracer
*
trc
Zone
*
zone
)
;
void
updateCellPointers
(
MovingTracer
*
trc
Zone
*
zone
AllocKinds
kinds
size_t
bgTaskCount
)
;
void
updateAllCellPointers
(
MovingTracer
*
trc
Zone
*
zone
)
;
void
updateZonePointersToRelocatedCells
(
Zone
*
zone
AutoLockForExclusiveAccess
&
lock
)
;
void
updateRuntimePointersToRelocatedCells
(
AutoLockForExclusiveAccess
&
lock
)
;
void
protectAndHoldArenas
(
Arena
*
arenaList
)
;
void
unprotectHeldRelocatedArenas
(
)
;
void
releaseRelocatedArenas
(
Arena
*
arenaList
)
;
void
releaseRelocatedArenasWithoutUnlocking
(
Arena
*
arenaList
const
AutoLockGC
&
lock
)
;
void
finishCollection
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
void
computeNonIncrementalMarkingForValidation
(
AutoLockForExclusiveAccess
&
lock
)
;
void
validateIncrementalMarking
(
)
;
void
finishMarkingValidation
(
)
;
#
ifdef
DEBUG
void
checkForCompartmentMismatches
(
)
;
#
endif
void
callFinalizeCallbacks
(
FreeOp
*
fop
JSFinalizeStatus
status
)
const
;
void
callWeakPointerZoneGroupCallbacks
(
)
const
;
void
callWeakPointerCompartmentCallbacks
(
JSCompartment
*
comp
)
const
;
public
:
JSRuntime
*
const
rt
;
UnprotectedData
<
JS
:
:
Zone
*
>
systemZone
;
ActiveThreadOrGCTaskData
<
ZoneGroupVector
>
groups
;
WriteOnceData
<
Zone
*
>
atomsZone
;
private
:
UnprotectedData
<
gcstats
:
:
Statistics
>
stats_
;
public
:
gcstats
:
:
Statistics
&
stats
(
)
{
return
stats_
.
ref
(
)
;
}
GCMarker
marker
;
HeapUsage
usage
;
GCSchedulingTunables
tunables
;
GCSchedulingState
schedulingState
;
MemProfiler
mMemProfiler
;
AtomMarkingRuntime
atomMarking
;
private
:
GCLockData
<
ChunkPool
>
emptyChunks_
;
UnprotectedData
<
ChunkPool
>
availableChunks_
;
UnprotectedData
<
ChunkPool
>
fullChunks_
;
ActiveThreadData
<
RootedValueMap
>
rootsHash
;
ActiveThreadData
<
size_t
>
maxMallocBytes
;
mozilla
:
:
Atomic
<
uint64_t
mozilla
:
:
ReleaseAcquire
>
nextCellUniqueId_
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
numArenasFreeCommitted
;
ActiveThreadData
<
VerifyPreTracer
*
>
verifyPreData
;
private
:
UnprotectedData
<
bool
>
chunkAllocationSinceLastGC
;
ActiveThreadData
<
int64_t
>
lastGCTime
;
ActiveThreadData
<
JSGCMode
>
mode
;
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
ReleaseAcquire
>
numActiveZoneIters
;
ActiveThreadData
<
bool
>
cleanUpEverything
;
enum
class
GrayBufferState
{
Unused
Okay
Failed
}
;
ActiveThreadData
<
GrayBufferState
>
grayBufferState
;
bool
hasBufferedGrayRoots
(
)
const
{
return
grayBufferState
=
=
GrayBufferState
:
:
Okay
;
}
void
resetBufferedGrayRoots
(
)
const
;
void
clearBufferedGrayRoots
(
)
{
grayBufferState
=
GrayBufferState
:
:
Unused
;
resetBufferedGrayRoots
(
)
;
}
UnprotectedData
<
bool
>
grayBitsValid
;
mozilla
:
:
Atomic
<
JS
:
:
gcreason
:
:
Reason
mozilla
:
:
Relaxed
>
majorGCTriggerReason
;
private
:
ActiveThreadData
<
bool
>
fullGCForAtomsRequested_
;
ActiveThreadData
<
uint64_t
>
minorGCNumber
;
ActiveThreadData
<
uint64_t
>
majorGCNumber
;
ActiveThreadData
<
uint64_t
>
jitReleaseNumber
;
ActiveThreadData
<
uint64_t
>
number
;
ActiveThreadData
<
uint64_t
>
startNumber
;
ActiveThreadData
<
bool
>
isIncremental
;
ActiveThreadData
<
bool
>
isFull
;
ActiveThreadData
<
bool
>
isCompacting
;
ActiveThreadData
<
JSGCInvocationKind
>
invocationKind
;
ActiveThreadData
<
JS
:
:
gcreason
:
:
Reason
>
initialReason
;
ActiveThreadOrGCTaskData
<
State
>
incrementalState
;
ActiveThreadData
<
bool
>
lastMarkSlice
;
ActiveThreadData
<
bool
>
sweepOnBackgroundThread
;
ActiveThreadData
<
bool
>
releaseObservedTypes
;
ActiveThreadData
<
BlackGrayEdgeVector
>
foundBlackGrayEdges
;
ActiveThreadOrGCTaskData
<
ZoneList
>
backgroundSweepZones
;
ActiveThreadOrGCTaskData
<
LifoAlloc
>
blocksToFreeAfterSweeping
;
private
:
ActiveThreadData
<
unsigned
>
zoneGroupIndex
;
ActiveThreadData
<
JS
:
:
Zone
*
>
zoneGroups
;
ActiveThreadOrGCTaskData
<
JS
:
:
Zone
*
>
currentZoneGroup
;
ActiveThreadData
<
bool
>
sweepingTypes
;
ActiveThreadData
<
unsigned
>
finalizePhase
;
ActiveThreadData
<
JS
:
:
Zone
*
>
sweepZone
;
ActiveThreadData
<
AllocKind
>
sweepKind
;
ActiveThreadData
<
bool
>
abortSweepAfterCurrentGroup
;
void
startTask
(
GCParallelTask
&
task
gcstats
:
:
Phase
phase
AutoLockHelperThreadState
&
locked
)
;
void
joinTask
(
GCParallelTask
&
task
gcstats
:
:
Phase
phase
AutoLockHelperThreadState
&
locked
)
;
ActiveThreadData
<
Arena
*
>
arenasAllocatedDuringSweep
;
ActiveThreadData
<
bool
>
startedCompacting
;
ActiveThreadData
<
ZoneList
>
zonesToMaybeCompact
;
ActiveThreadData
<
Arena
*
>
relocatedArenasToRelease
;
#
ifdef
JS_GC_ZEAL
ActiveThreadData
<
MarkingValidator
*
>
markingValidator
;
#
endif
ActiveThreadData
<
bool
>
interFrameGC
;
ActiveThreadData
<
int64_t
>
defaultTimeBudget_
;
ActiveThreadData
<
bool
>
incrementalAllowed
;
ActiveThreadData
<
bool
>
compactingEnabled
;
ActiveThreadData
<
bool
>
poked
;
#
ifdef
JS_GC_ZEAL
ActiveThreadData
<
uint32_t
>
zealModeBits
;
ActiveThreadData
<
int
>
zealFrequency
;
ActiveThreadData
<
int
>
nextScheduled
;
ActiveThreadData
<
bool
>
deterministicOnly
;
ActiveThreadData
<
int
>
incrementalLimit
;
ActiveThreadData
<
Vector
<
JSObject
*
0
SystemAllocPolicy
>
>
selectedForMarking
;
#
endif
ActiveThreadData
<
bool
>
fullCompartmentChecks
;
Callback
<
JSGCCallback
>
gcCallback
;
Callback
<
JS
:
:
DoCycleCollectionCallback
>
gcDoCycleCollectionCallback
;
Callback
<
JSObjectsTenuredCallback
>
tenuredCallback
;
CallbackVector
<
JSFinalizeCallback
>
finalizeCallbacks
;
CallbackVector
<
JSWeakPointerZoneGroupCallback
>
updateWeakPointerZoneGroupCallbacks
;
CallbackVector
<
JSWeakPointerCompartmentCallback
>
updateWeakPointerCompartmentCallbacks
;
mozilla
:
:
Atomic
<
ptrdiff_t
mozilla
:
:
ReleaseAcquire
>
mallocBytesUntilGC
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
ReleaseAcquire
>
mallocGCTriggered
;
CallbackVector
<
JSTraceDataOp
>
blackRootTracers
;
Callback
<
JSTraceDataOp
>
grayRootTracer
;
ActiveThreadData
<
bool
>
alwaysPreserveCode
;
#
ifdef
DEBUG
ActiveThreadData
<
bool
>
arenasEmptyAtShutdown
;
#
endif
friend
class
js
:
:
AutoLockGC
;
js
:
:
Mutex
lock
;
BackgroundAllocTask
allocTask
;
BackgroundDecommitTask
decommitTask
;
GCHelperState
helperState
;
ActiveThreadData
<
SortedArenaList
>
incrementalSweepList
;
friend
class
js
:
:
GCHelperState
;
friend
class
MarkingValidator
;
friend
class
AutoTraceSession
;
friend
class
AutoEnterIteration
;
}
;
class
MOZ_RAII
AutoEnterIteration
{
GCRuntime
*
gc
;
public
:
explicit
AutoEnterIteration
(
GCRuntime
*
gc_
)
:
gc
(
gc_
)
{
+
+
gc
-
>
numActiveZoneIters
;
}
~
AutoEnterIteration
(
)
{
MOZ_ASSERT
(
gc
-
>
numActiveZoneIters
)
;
-
-
gc
-
>
numActiveZoneIters
;
}
}
;
class
MOZ_RAII
AutoMaybeStartBackgroundAllocation
{
GCRuntime
*
gc
;
public
:
AutoMaybeStartBackgroundAllocation
(
)
:
gc
(
nullptr
)
{
}
void
tryToStartBackgroundAllocation
(
GCRuntime
&
gc
)
{
this
-
>
gc
=
&
gc
;
}
~
AutoMaybeStartBackgroundAllocation
(
)
{
if
(
gc
)
gc
-
>
startBackgroundAllocTaskIfIdle
(
)
;
}
}
;
#
ifdef
JS_GC_ZEAL
inline
bool
GCRuntime
:
:
hasZealMode
(
ZealMode
mode
)
{
static_assert
(
size_t
(
ZealMode
:
:
Limit
)
<
sizeof
(
zealModeBits
)
*
8
"
Zeal
modes
must
fit
in
zealModeBits
"
)
;
return
zealModeBits
&
(
1
<
<
uint32_t
(
mode
)
)
;
}
inline
void
GCRuntime
:
:
clearZealMode
(
ZealMode
mode
)
{
zealModeBits
&
=
~
(
1
<
<
uint32_t
(
mode
)
)
;
MOZ_ASSERT
(
!
hasZealMode
(
mode
)
)
;
}
inline
bool
GCRuntime
:
:
upcomingZealousGC
(
)
{
return
nextScheduled
=
=
1
;
}
inline
bool
GCRuntime
:
:
needZealousGC
(
)
{
if
(
nextScheduled
>
0
&
&
-
-
nextScheduled
=
=
0
)
{
if
(
hasZealMode
(
ZealMode
:
:
Alloc
)
|
|
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
|
|
hasZealMode
(
ZealMode
:
:
IncrementalRootsThenFinish
)
|
|
hasZealMode
(
ZealMode
:
:
IncrementalMarkAllThenFinish
)
|
|
hasZealMode
(
ZealMode
:
:
IncrementalMultipleSlices
)
|
|
hasZealMode
(
ZealMode
:
:
Compact
)
)
{
nextScheduled
=
zealFrequency
;
}
return
true
;
}
return
false
;
}
#
else
inline
bool
GCRuntime
:
:
hasZealMode
(
ZealMode
mode
)
{
return
false
;
}
inline
void
GCRuntime
:
:
clearZealMode
(
ZealMode
mode
)
{
}
inline
bool
GCRuntime
:
:
upcomingZealousGC
(
)
{
return
false
;
}
inline
bool
GCRuntime
:
:
needZealousGC
(
)
{
return
false
;
}
#
endif
}
}
#
endif
