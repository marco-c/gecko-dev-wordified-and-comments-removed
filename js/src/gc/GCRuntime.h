#
ifndef
gc_GCRuntime_h
#
define
gc_GCRuntime_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
gc
/
ArenaList
.
h
"
#
include
"
gc
/
AtomMarking
.
h
"
#
include
"
gc
/
GCMarker
.
h
"
#
include
"
gc
/
IteratorUtils
.
h
"
#
include
"
gc
/
Nursery
.
h
"
#
include
"
gc
/
Scheduling
.
h
"
#
include
"
gc
/
Statistics
.
h
"
#
include
"
gc
/
StoreBuffer
.
h
"
#
include
"
js
/
friend
/
PerformanceHint
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
vm
/
AtomsTable
.
h
"
namespace
js
{
class
AutoAccessAtomsZone
;
class
AutoLockGC
;
class
AutoLockGCBgAlloc
;
class
AutoLockHelperThreadState
;
class
FinalizationRegistryObject
;
class
FinalizationQueueObject
;
class
VerifyPreTracer
;
class
WeakRefObject
;
class
ZoneAllocator
;
namespace
gc
{
using
BlackGrayEdgeVector
=
Vector
<
TenuredCell
*
0
SystemAllocPolicy
>
;
using
ZoneVector
=
Vector
<
JS
:
:
Zone
*
4
SystemAllocPolicy
>
;
class
AutoCallGCCallbacks
;
class
AutoGCSession
;
class
AutoHeapSession
;
class
AutoTraceSession
;
class
MarkingValidator
;
struct
MovingTracer
;
enum
class
ShouldCheckThresholds
;
class
SweepGroupsIter
;
struct
SweepAction
{
struct
Args
{
GCRuntime
*
gc
;
JSFreeOp
*
fop
;
SliceBudget
&
budget
;
}
;
virtual
~
SweepAction
(
)
=
default
;
virtual
IncrementalProgress
run
(
Args
&
state
)
=
0
;
virtual
void
assertFinished
(
)
const
=
0
;
virtual
bool
shouldSkip
(
)
{
return
false
;
}
}
;
class
ChunkPool
{
TenuredChunk
*
head_
;
size_t
count_
;
public
:
ChunkPool
(
)
:
head_
(
nullptr
)
count_
(
0
)
{
}
ChunkPool
(
const
ChunkPool
&
other
)
=
delete
;
ChunkPool
(
ChunkPool
&
&
other
)
{
*
this
=
std
:
:
move
(
other
)
;
}
~
ChunkPool
(
)
{
MOZ_ASSERT
(
!
head_
)
;
MOZ_ASSERT
(
count_
=
=
0
)
;
}
ChunkPool
&
operator
=
(
const
ChunkPool
&
other
)
=
delete
;
ChunkPool
&
operator
=
(
ChunkPool
&
&
other
)
{
head_
=
other
.
head_
;
other
.
head_
=
nullptr
;
count_
=
other
.
count_
;
other
.
count_
=
0
;
return
*
this
;
}
bool
empty
(
)
const
{
return
!
head_
;
}
size_t
count
(
)
const
{
return
count_
;
}
TenuredChunk
*
head
(
)
{
MOZ_ASSERT
(
head_
)
;
return
head_
;
}
TenuredChunk
*
pop
(
)
;
void
push
(
TenuredChunk
*
chunk
)
;
TenuredChunk
*
remove
(
TenuredChunk
*
chunk
)
;
void
sort
(
)
;
private
:
TenuredChunk
*
mergeSort
(
TenuredChunk
*
list
size_t
count
)
;
bool
isSorted
(
)
const
;
#
ifdef
DEBUG
public
:
bool
contains
(
TenuredChunk
*
chunk
)
const
;
bool
verify
(
)
const
;
void
verifyChunks
(
)
const
;
#
endif
public
:
class
Iter
{
public
:
explicit
Iter
(
ChunkPool
&
pool
)
:
current_
(
pool
.
head_
)
{
}
bool
done
(
)
const
{
return
!
current_
;
}
void
next
(
)
;
TenuredChunk
*
get
(
)
const
{
return
current_
;
}
operator
TenuredChunk
*
(
)
const
{
return
get
(
)
;
}
TenuredChunk
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
private
:
TenuredChunk
*
current_
;
}
;
}
;
class
BackgroundMarkTask
:
public
GCParallelTask
{
public
:
explicit
BackgroundMarkTask
(
GCRuntime
*
gc
)
;
void
setBudget
(
const
SliceBudget
&
budget
)
{
this
-
>
budget
=
budget
;
}
void
run
(
AutoLockHelperThreadState
&
lock
)
override
;
private
:
SliceBudget
budget
;
}
;
class
BackgroundUnmarkTask
:
public
GCParallelTask
{
public
:
explicit
BackgroundUnmarkTask
(
GCRuntime
*
gc
)
;
void
initZones
(
)
;
void
run
(
AutoLockHelperThreadState
&
lock
)
override
;
private
:
void
unmarkZones
(
AutoLockGC
&
lock
)
;
ZoneVector
zones
;
}
;
class
BackgroundSweepTask
:
public
GCParallelTask
{
public
:
explicit
BackgroundSweepTask
(
GCRuntime
*
gc
)
;
void
run
(
AutoLockHelperThreadState
&
lock
)
override
;
}
;
class
BackgroundFreeTask
:
public
GCParallelTask
{
public
:
explicit
BackgroundFreeTask
(
GCRuntime
*
gc
)
;
void
run
(
AutoLockHelperThreadState
&
lock
)
override
;
}
;
class
BackgroundAllocTask
:
public
GCParallelTask
{
GCLockData
<
ChunkPool
&
>
chunkPool_
;
const
bool
enabled_
;
public
:
BackgroundAllocTask
(
GCRuntime
*
gc
ChunkPool
&
pool
)
;
bool
enabled
(
)
const
{
return
enabled_
;
}
void
run
(
AutoLockHelperThreadState
&
lock
)
override
;
}
;
class
BackgroundDecommitTask
:
public
GCParallelTask
{
public
:
explicit
BackgroundDecommitTask
(
GCRuntime
*
gc
)
;
void
run
(
AutoLockHelperThreadState
&
lock
)
override
;
}
;
template
<
typename
F
>
struct
Callback
{
F
op
;
void
*
data
;
Callback
(
)
:
op
(
nullptr
)
data
(
nullptr
)
{
}
Callback
(
F
op
void
*
data
)
:
op
(
op
)
data
(
data
)
{
}
}
;
template
<
typename
F
>
using
CallbackVector
=
Vector
<
Callback
<
F
>
4
SystemAllocPolicy
>
;
typedef
HashMap
<
Value
*
const
char
*
DefaultHasher
<
Value
*
>
SystemAllocPolicy
>
RootedValueMap
;
using
AllocKinds
=
mozilla
:
:
EnumSet
<
AllocKind
uint64_t
>
;
class
ZoneList
{
static
Zone
*
const
End
;
Zone
*
head
;
Zone
*
tail
;
public
:
ZoneList
(
)
;
~
ZoneList
(
)
;
bool
isEmpty
(
)
const
;
Zone
*
front
(
)
const
;
void
append
(
Zone
*
zone
)
;
void
transferFrom
(
ZoneList
&
other
)
;
Zone
*
removeFront
(
)
;
void
clear
(
)
;
private
:
explicit
ZoneList
(
Zone
*
singleZone
)
;
void
check
(
)
const
;
ZoneList
(
const
ZoneList
&
other
)
=
delete
;
ZoneList
&
operator
=
(
const
ZoneList
&
other
)
=
delete
;
}
;
struct
WeakCacheToSweep
{
JS
:
:
detail
:
:
WeakCacheBase
*
cache
;
JS
:
:
Zone
*
zone
;
}
;
class
WeakCacheSweepIterator
{
using
WeakCacheBase
=
JS
:
:
detail
:
:
WeakCacheBase
;
JS
:
:
Zone
*
sweepZone
;
WeakCacheBase
*
sweepCache
;
public
:
explicit
WeakCacheSweepIterator
(
JS
:
:
Zone
*
sweepGroup
)
;
bool
done
(
)
const
;
WeakCacheToSweep
get
(
)
const
;
void
next
(
)
;
private
:
void
settle
(
)
;
}
;
class
BarrierTracer
final
:
public
GenericTracer
{
public
:
static
BarrierTracer
*
fromTracer
(
JSTracer
*
trc
)
;
explicit
BarrierTracer
(
JSRuntime
*
rt
)
;
JSObject
*
onObjectEdge
(
JSObject
*
obj
)
override
;
Shape
*
onShapeEdge
(
Shape
*
shape
)
override
;
JSString
*
onStringEdge
(
JSString
*
string
)
override
;
js
:
:
BaseScript
*
onScriptEdge
(
js
:
:
BaseScript
*
script
)
override
;
BaseShape
*
onBaseShapeEdge
(
BaseShape
*
base
)
override
;
GetterSetter
*
onGetterSetterEdge
(
GetterSetter
*
gs
)
override
;
PropMap
*
onPropMapEdge
(
PropMap
*
map
)
override
;
Scope
*
onScopeEdge
(
Scope
*
scope
)
override
;
RegExpShared
*
onRegExpSharedEdge
(
RegExpShared
*
shared
)
override
;
BigInt
*
onBigIntEdge
(
BigInt
*
bi
)
override
;
JS
:
:
Symbol
*
onSymbolEdge
(
JS
:
:
Symbol
*
sym
)
override
;
jit
:
:
JitCode
*
onJitCodeEdge
(
jit
:
:
JitCode
*
jit
)
override
;
void
performBarrier
(
JS
:
:
GCCellPtr
cell
)
;
private
:
void
handleBufferFull
(
JS
:
:
GCCellPtr
cell
)
;
GCMarker
&
marker
;
}
;
class
GCRuntime
{
friend
GCMarker
:
:
MarkQueueProgress
GCMarker
:
:
processMarkQueue
(
)
;
public
:
explicit
GCRuntime
(
JSRuntime
*
rt
)
;
[
[
nodiscard
]
]
bool
init
(
uint32_t
maxbytes
)
;
void
finishRoots
(
)
;
void
finish
(
)
;
void
freezePermanentAtoms
(
)
;
void
freezePermanentAtomsOfKind
(
AllocKind
kind
ArenaList
&
arenaList
)
;
void
restorePermanentAtoms
(
)
;
void
restorePermanentAtomsOfKind
(
AllocKind
kind
ArenaList
&
arenaList
)
;
JS
:
:
HeapState
heapState
(
)
const
{
return
heapState_
;
}
inline
bool
hasZealMode
(
ZealMode
mode
)
;
inline
void
clearZealMode
(
ZealMode
mode
)
;
inline
bool
needZealousGC
(
)
;
inline
bool
hasIncrementalTwoSliceZealMode
(
)
;
[
[
nodiscard
]
]
bool
addRoot
(
Value
*
vp
const
char
*
name
)
;
void
removeRoot
(
Value
*
vp
)
;
void
setMarkStackLimit
(
size_t
limit
AutoLockGC
&
lock
)
;
[
[
nodiscard
]
]
bool
setParameter
(
JSGCParamKey
key
uint32_t
value
)
;
[
[
nodiscard
]
]
bool
setParameter
(
JSGCParamKey
key
uint32_t
value
AutoLockGC
&
lock
)
;
void
resetParameter
(
JSGCParamKey
key
)
;
void
resetParameter
(
JSGCParamKey
key
AutoLockGC
&
lock
)
;
uint32_t
getParameter
(
JSGCParamKey
key
)
;
uint32_t
getParameter
(
JSGCParamKey
key
const
AutoLockGC
&
lock
)
;
void
setPerformanceHint
(
PerformanceHint
hint
)
;
[
[
nodiscard
]
]
bool
triggerGC
(
JS
:
:
GCReason
reason
)
;
void
maybeTriggerGCAfterAlloc
(
Zone
*
zone
)
;
void
maybeTriggerGCAfterMalloc
(
Zone
*
zone
)
;
bool
maybeTriggerGCAfterMalloc
(
Zone
*
zone
const
HeapSize
&
heap
const
HeapThreshold
&
threshold
JS
:
:
GCReason
reason
)
;
bool
triggerZoneGC
(
Zone
*
zone
JS
:
:
GCReason
reason
size_t
usedBytes
size_t
thresholdBytes
)
;
void
maybeGC
(
)
;
bool
checkEagerAllocTrigger
(
const
HeapSize
&
size
const
HeapThreshold
&
threshold
)
;
bool
gcIfRequested
(
)
;
void
gc
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
;
void
startGC
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
int64_t
millis
=
0
)
;
void
gcSlice
(
JS
:
:
GCReason
reason
int64_t
millis
=
0
)
;
void
finishGC
(
JS
:
:
GCReason
reason
)
;
void
abortGC
(
)
;
void
startDebugGC
(
JS
:
:
GCOptions
options
SliceBudget
&
budget
)
;
void
debugGCSlice
(
SliceBudget
&
budget
)
;
void
triggerFullGCForAtoms
(
JSContext
*
cx
)
;
void
runDebugGC
(
)
;
void
notifyRootsRemoved
(
)
;
enum
TraceOrMarkRuntime
{
TraceRuntime
MarkRuntime
}
;
void
traceRuntime
(
JSTracer
*
trc
AutoTraceSession
&
session
)
;
void
traceRuntimeForMinorGC
(
JSTracer
*
trc
AutoGCSession
&
session
)
;
void
purgeRuntimeForMinorGC
(
)
;
void
shrinkBuffers
(
)
;
void
onOutOfMallocMemory
(
)
;
void
onOutOfMallocMemory
(
const
AutoLockGC
&
lock
)
;
Nursery
&
nursery
(
)
{
return
nursery_
.
ref
(
)
;
}
gc
:
:
StoreBuffer
&
storeBuffer
(
)
{
return
storeBuffer_
.
ref
(
)
;
}
void
minorGC
(
JS
:
:
GCReason
reason
gcstats
:
:
PhaseKind
phase
=
gcstats
:
:
PhaseKind
:
:
MINOR_GC
)
JS_HAZ_GC_CALL
;
void
evictNursery
(
JS
:
:
GCReason
reason
=
JS
:
:
GCReason
:
:
EVICT_NURSERY
)
{
minorGC
(
reason
gcstats
:
:
PhaseKind
:
:
EVICT_NURSERY
)
;
}
void
*
addressOfNurseryPosition
(
)
{
return
nursery_
.
refNoCheck
(
)
.
addressOfPosition
(
)
;
}
const
void
*
addressOfNurseryCurrentEnd
(
)
{
return
nursery_
.
refNoCheck
(
)
.
addressOfCurrentEnd
(
)
;
}
const
void
*
addressOfStringNurseryCurrentEnd
(
)
{
return
nursery_
.
refNoCheck
(
)
.
addressOfCurrentStringEnd
(
)
;
}
const
void
*
addressOfBigIntNurseryCurrentEnd
(
)
{
return
nursery_
.
refNoCheck
(
)
.
addressOfCurrentBigIntEnd
(
)
;
}
uint32_t
*
addressOfNurseryAllocCount
(
)
{
return
stats
(
)
.
addressOfAllocsSinceMinorGCNursery
(
)
;
}
#
ifdef
JS_GC_ZEAL
const
uint32_t
*
addressOfZealModeBits
(
)
{
return
&
zealModeBits
.
refNoCheck
(
)
;
}
void
getZealBits
(
uint32_t
*
zealBits
uint32_t
*
frequency
uint32_t
*
nextScheduled
)
;
void
setZeal
(
uint8_t
zeal
uint32_t
frequency
)
;
void
unsetZeal
(
uint8_t
zeal
)
;
bool
parseAndSetZeal
(
const
char
*
str
)
;
void
setNextScheduled
(
uint32_t
count
)
;
void
verifyPreBarriers
(
)
;
void
maybeVerifyPreBarriers
(
bool
always
)
;
bool
selectForMarking
(
JSObject
*
object
)
;
void
clearSelectedForMarking
(
)
;
void
setDeterministic
(
bool
enable
)
;
#
endif
uint64_t
nextCellUniqueId
(
)
{
MOZ_ASSERT
(
nextCellUniqueId_
>
0
)
;
uint64_t
uid
=
+
+
nextCellUniqueId_
;
return
uid
;
}
void
setLowMemoryState
(
bool
newState
)
{
lowMemoryState
=
newState
;
}
bool
systemHasLowMemory
(
)
const
{
return
lowMemoryState
;
}
public
:
ZoneVector
&
zones
(
)
{
return
zones_
.
ref
(
)
;
}
gcstats
:
:
Statistics
&
stats
(
)
{
return
stats_
.
ref
(
)
;
}
State
state
(
)
const
{
return
incrementalState
;
}
bool
isHeapCompacting
(
)
const
{
return
state
(
)
=
=
State
:
:
Compact
;
}
bool
isForegroundSweeping
(
)
const
{
return
state
(
)
=
=
State
:
:
Sweep
;
}
bool
isBackgroundSweeping
(
)
const
{
return
sweepTask
.
wasStarted
(
)
;
}
bool
isBackgroundMarking
(
)
const
{
return
markTask
.
wasStarted
(
)
;
}
void
waitBackgroundSweepEnd
(
)
;
void
waitBackgroundAllocEnd
(
)
{
allocTask
.
cancelAndWait
(
)
;
}
void
waitBackgroundFreeEnd
(
)
;
void
waitForBackgroundTasks
(
)
;
void
lockGC
(
)
{
lock
.
lock
(
)
;
}
void
unlockGC
(
)
{
lock
.
unlock
(
)
;
}
#
ifdef
DEBUG
void
assertCurrentThreadHasLockedGC
(
)
const
{
lock
.
assertOwnedByCurrentThread
(
)
;
}
#
endif
void
setAlwaysPreserveCode
(
)
{
alwaysPreserveCode
=
true
;
}
bool
isIncrementalGCAllowed
(
)
const
{
return
incrementalAllowed
;
}
void
disallowIncrementalGC
(
)
{
incrementalAllowed
=
false
;
}
void
setIncrementalGCEnabled
(
bool
enabled
)
;
bool
isIncrementalGCEnabled
(
)
const
{
return
incrementalGCEnabled
;
}
bool
isIncrementalGCInProgress
(
)
const
{
return
state
(
)
!
=
State
:
:
NotActive
&
&
!
isVerifyPreBarriersEnabled
(
)
;
}
bool
isPerZoneGCEnabled
(
)
const
{
return
perZoneGCEnabled
;
}
bool
hasForegroundWork
(
)
const
;
bool
isCompactingGCEnabled
(
)
const
;
bool
isShrinkingGC
(
)
const
{
return
gcOptions
=
=
JS
:
:
GCOptions
:
:
Shrink
;
}
bool
initSweepActions
(
)
;
void
setGrayRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
;
[
[
nodiscard
]
]
bool
addBlackRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
;
void
removeBlackRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
;
void
clearBlackAndGrayRootTracers
(
)
;
void
updateMemoryCountersOnGCStart
(
)
;
void
setGCCallback
(
JSGCCallback
callback
void
*
data
)
;
void
callGCCallback
(
JSGCStatus
status
JS
:
:
GCReason
reason
)
const
;
void
setObjectsTenuredCallback
(
JSObjectsTenuredCallback
callback
void
*
data
)
;
void
callObjectsTenuredCallback
(
)
;
[
[
nodiscard
]
]
bool
addFinalizeCallback
(
JSFinalizeCallback
callback
void
*
data
)
;
void
removeFinalizeCallback
(
JSFinalizeCallback
func
)
;
void
setHostCleanupFinalizationRegistryCallback
(
JSHostCleanupFinalizationRegistryCallback
callback
void
*
data
)
;
void
callHostCleanupFinalizationRegistryCallback
(
JSFunction
*
doCleanup
GlobalObject
*
incumbentGlobal
)
;
[
[
nodiscard
]
]
bool
addWeakPointerZonesCallback
(
JSWeakPointerZonesCallback
callback
void
*
data
)
;
void
removeWeakPointerZonesCallback
(
JSWeakPointerZonesCallback
callback
)
;
[
[
nodiscard
]
]
bool
addWeakPointerCompartmentCallback
(
JSWeakPointerCompartmentCallback
callback
void
*
data
)
;
void
removeWeakPointerCompartmentCallback
(
JSWeakPointerCompartmentCallback
callback
)
;
JS
:
:
GCSliceCallback
setSliceCallback
(
JS
:
:
GCSliceCallback
callback
)
;
JS
:
:
GCNurseryCollectionCallback
setNurseryCollectionCallback
(
JS
:
:
GCNurseryCollectionCallback
callback
)
;
JS
:
:
DoCycleCollectionCallback
setDoCycleCollectionCallback
(
JS
:
:
DoCycleCollectionCallback
callback
)
;
bool
addFinalizationRegistry
(
JSContext
*
cx
FinalizationRegistryObject
*
registry
)
;
bool
registerWithFinalizationRegistry
(
JSContext
*
cx
HandleObject
target
HandleObject
record
)
;
void
setFullCompartmentChecks
(
bool
enable
)
;
JS
:
:
Zone
*
getCurrentSweepGroup
(
)
{
return
currentSweepGroup
;
}
unsigned
getCurrentSweepGroupIndex
(
)
{
return
state
(
)
=
=
State
:
:
Sweep
?
sweepGroupIndex
:
0
;
}
uint64_t
gcNumber
(
)
const
{
return
number
;
}
void
incGcNumber
(
)
{
+
+
number
;
}
uint64_t
minorGCCount
(
)
const
{
return
minorGCNumber
;
}
void
incMinorGcNumber
(
)
{
+
+
minorGCNumber
;
}
uint64_t
majorGCCount
(
)
const
{
return
majorGCNumber
;
}
void
incMajorGcNumber
(
)
{
+
+
majorGCNumber
;
}
uint64_t
gcSliceCount
(
)
const
{
return
sliceNumber
;
}
void
incGcSliceNumber
(
)
{
+
+
sliceNumber
;
}
int64_t
defaultSliceBudgetMS
(
)
const
{
return
defaultTimeBudgetMS_
;
}
bool
isIncrementalGc
(
)
const
{
return
isIncremental
;
}
bool
isFullGc
(
)
const
{
return
isFull
;
}
bool
isCompactingGc
(
)
const
{
return
isCompacting
;
}
bool
didCompactZones
(
)
const
{
return
isCompacting
&
&
zonesCompacted
;
}
bool
areGrayBitsValid
(
)
const
{
return
grayBitsValid
;
}
void
setGrayBitsInvalid
(
)
{
grayBitsValid
=
false
;
}
mozilla
:
:
TimeStamp
lastGCStartTime
(
)
const
{
return
lastGCStartTime_
;
}
mozilla
:
:
TimeStamp
lastGCEndTime
(
)
const
{
return
lastGCEndTime_
;
}
bool
majorGCRequested
(
)
const
{
return
majorGCTriggerReason
!
=
JS
:
:
GCReason
:
:
NO_REASON
;
}
bool
fullGCForAtomsRequested
(
)
const
{
return
fullGCForAtomsRequested_
;
}
double
computeHeapGrowthFactor
(
size_t
lastBytes
)
;
size_t
computeTriggerBytes
(
double
growthFactor
size_t
lastBytes
)
;
inline
void
updateOnFreeArenaAlloc
(
const
TenuredChunkInfo
&
info
)
;
inline
void
updateOnArenaFree
(
)
;
ChunkPool
&
fullChunks
(
const
AutoLockGC
&
lock
)
{
return
fullChunks_
.
ref
(
)
;
}
ChunkPool
&
availableChunks
(
const
AutoLockGC
&
lock
)
{
return
availableChunks_
.
ref
(
)
;
}
ChunkPool
&
emptyChunks
(
const
AutoLockGC
&
lock
)
{
return
emptyChunks_
.
ref
(
)
;
}
const
ChunkPool
&
fullChunks
(
const
AutoLockGC
&
lock
)
const
{
return
fullChunks_
.
ref
(
)
;
}
const
ChunkPool
&
availableChunks
(
const
AutoLockGC
&
lock
)
const
{
return
availableChunks_
.
ref
(
)
;
}
const
ChunkPool
&
emptyChunks
(
const
AutoLockGC
&
lock
)
const
{
return
emptyChunks_
.
ref
(
)
;
}
using
NonEmptyChunksIter
=
ChainedIterator
<
ChunkPool
:
:
Iter
2
>
;
NonEmptyChunksIter
allNonEmptyChunks
(
const
AutoLockGC
&
lock
)
{
return
NonEmptyChunksIter
(
availableChunks
(
lock
)
fullChunks
(
lock
)
)
;
}
#
ifdef
DEBUG
void
verifyAllChunks
(
)
;
#
endif
TenuredChunk
*
getOrAllocChunk
(
AutoLockGCBgAlloc
&
lock
)
;
void
recycleChunk
(
TenuredChunk
*
chunk
const
AutoLockGC
&
lock
)
;
#
ifdef
JS_GC_ZEAL
void
startVerifyPreBarriers
(
)
;
void
endVerifyPreBarriers
(
)
;
void
finishVerifier
(
)
;
bool
isVerifyPreBarriersEnabled
(
)
const
{
return
verifyPreData
.
refNoCheck
(
)
;
}
bool
shouldYieldForZeal
(
ZealMode
mode
)
;
#
else
bool
isVerifyPreBarriersEnabled
(
)
const
{
return
false
;
}
#
endif
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkHashTablesAfterMovingGC
(
)
;
#
endif
#
ifdef
DEBUG
bool
isPointerWithinTenuredCell
(
void
*
ptr
JS
:
:
TraceKind
traceKind
)
;
bool
hasZone
(
Zone
*
target
)
;
#
endif
void
queueUnusedLifoBlocksForFree
(
LifoAlloc
*
lifo
)
;
void
queueAllLifoBlocksForFree
(
LifoAlloc
*
lifo
)
;
void
queueAllLifoBlocksForFreeAfterMinorGC
(
LifoAlloc
*
lifo
)
;
void
queueBuffersForFreeAfterMinorGC
(
Nursery
:
:
BufferSet
&
buffers
)
;
void
releaseArena
(
Arena
*
arena
const
AutoLockGC
&
lock
)
;
template
<
AllowGC
allowGC
>
[
[
nodiscard
]
]
bool
checkAllocatorState
(
JSContext
*
cx
AllocKind
kind
)
;
template
<
AllowGC
allowGC
>
JSObject
*
tryNewNurseryObject
(
JSContext
*
cx
size_t
thingSize
size_t
nDynamicSlots
const
JSClass
*
clasp
AllocSite
*
site
)
;
template
<
AllowGC
allowGC
>
static
JSObject
*
tryNewTenuredObject
(
JSContext
*
cx
AllocKind
kind
size_t
thingSize
size_t
nDynamicSlots
)
;
template
<
typename
T
AllowGC
allowGC
>
static
T
*
tryNewTenuredThing
(
JSContext
*
cx
AllocKind
kind
size_t
thingSize
)
;
template
<
AllowGC
allowGC
>
JSString
*
tryNewNurseryString
(
JSContext
*
cx
size_t
thingSize
AllocKind
kind
)
;
template
<
AllowGC
allowGC
>
JS
:
:
BigInt
*
tryNewNurseryBigInt
(
JSContext
*
cx
size_t
thingSize
AllocKind
kind
)
;
static
TenuredCell
*
refillFreeListInGC
(
Zone
*
zone
AllocKind
thingKind
)
;
void
setParallelAtomsAllocEnabled
(
bool
enabled
)
;
void
setParallelUnmarkEnabled
(
bool
enabled
)
;
void
startTask
(
GCParallelTask
&
task
AutoLockHelperThreadState
&
lock
)
;
void
joinTask
(
GCParallelTask
&
task
AutoLockHelperThreadState
&
lock
)
;
void
updateHelperThreadCount
(
)
;
size_t
parallelWorkerCount
(
)
const
;
void
mergeRealms
(
JS
:
:
Realm
*
source
JS
:
:
Realm
*
target
)
;
bool
registerWeakRef
(
HandleObject
target
HandleObject
weakRef
)
;
bool
unregisterWeakRefWrapper
(
JSObject
*
wrapper
)
;
void
traceKeptObjects
(
JSTracer
*
trc
)
;
private
:
enum
IncrementalResult
{
ResetIncremental
=
0
Ok
}
;
TriggerResult
checkHeapThreshold
(
Zone
*
zone
const
HeapSize
&
heapSize
const
HeapThreshold
&
heapThreshold
)
;
void
updateGCThresholdsAfterCollection
(
const
AutoLockGC
&
lock
)
;
void
updateAllGCStartThresholds
(
const
AutoLockGC
&
lock
)
;
void
deleteEmptyZone
(
Zone
*
zone
)
;
friend
class
ArenaLists
;
TenuredChunk
*
pickChunk
(
AutoLockGCBgAlloc
&
lock
)
;
Arena
*
allocateArena
(
TenuredChunk
*
chunk
Zone
*
zone
AllocKind
kind
ShouldCheckThresholds
checkThresholds
const
AutoLockGC
&
lock
)
;
[
[
nodiscard
]
]
bool
gcIfNeededAtAllocation
(
JSContext
*
cx
)
;
template
<
typename
T
>
static
void
checkIncrementalZoneState
(
JSContext
*
cx
T
*
t
)
;
static
TenuredCell
*
refillFreeListFromAnyThread
(
JSContext
*
cx
AllocKind
thingKind
)
;
static
TenuredCell
*
refillFreeListFromMainThread
(
JSContext
*
cx
AllocKind
thingKind
)
;
static
TenuredCell
*
refillFreeListFromHelperThread
(
JSContext
*
cx
AllocKind
thingKind
)
;
void
attemptLastDitchGC
(
JSContext
*
cx
)
;
friend
class
BackgroundDecommitTask
;
bool
tooManyEmptyChunks
(
const
AutoLockGC
&
lock
)
;
ChunkPool
expireEmptyChunkPool
(
const
AutoLockGC
&
lock
)
;
void
freeEmptyChunks
(
const
AutoLockGC
&
lock
)
;
void
prepareToFreeChunk
(
TenuredChunkInfo
&
info
)
;
friend
class
BackgroundAllocTask
;
bool
wantBackgroundAllocation
(
const
AutoLockGC
&
lock
)
const
;
void
startBackgroundAllocTaskIfIdle
(
)
;
void
requestMajorGC
(
JS
:
:
GCReason
reason
)
;
SliceBudget
defaultBudget
(
JS
:
:
GCReason
reason
int64_t
millis
)
;
bool
maybeIncreaseSliceBudget
(
SliceBudget
&
budget
)
;
bool
maybeIncreaseSliceBudgetForLongCollections
(
SliceBudget
&
budget
)
;
bool
maybeIncreaseSliceBudgetForUrgentCollections
(
SliceBudget
&
budget
)
;
IncrementalResult
budgetIncrementalGC
(
bool
nonincrementalByAPI
JS
:
:
GCReason
reason
SliceBudget
&
budget
)
;
void
checkZoneIsScheduled
(
Zone
*
zone
JS
:
:
GCReason
reason
const
char
*
trigger
)
;
IncrementalResult
resetIncrementalGC
(
GCAbortReason
reason
)
;
void
checkCanCallAPI
(
)
;
[
[
nodiscard
]
]
bool
checkIfGCAllowedInCurrentState
(
JS
:
:
GCReason
reason
)
;
gcstats
:
:
ZoneGCStats
scanZonesBeforeGC
(
)
;
using
MaybeGCOptions
=
mozilla
:
:
Maybe
<
JS
:
:
GCOptions
>
;
void
collect
(
bool
nonincrementalByAPI
const
SliceBudget
&
budget
const
MaybeGCOptions
&
options
JS
:
:
GCReason
reason
)
JS_HAZ_GC_CALL
;
[
[
nodiscard
]
]
IncrementalResult
gcCycle
(
bool
nonincrementalByAPI
const
SliceBudget
&
budgetArg
const
MaybeGCOptions
&
options
JS
:
:
GCReason
reason
)
;
bool
shouldRepeatForDeadZone
(
JS
:
:
GCReason
reason
)
;
void
incrementalSlice
(
SliceBudget
&
budget
const
MaybeGCOptions
&
options
JS
:
:
GCReason
reason
bool
budgetWasIncreased
)
;
void
waitForBackgroundTasksBeforeSlice
(
)
;
bool
mightSweepInThisSlice
(
bool
nonIncremental
)
;
void
collectNurseryFromMajorGC
(
const
MaybeGCOptions
&
options
JS
:
:
GCReason
reason
)
;
void
collectNursery
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
gcstats
:
:
PhaseKind
phase
)
;
friend
class
AutoCallGCCallbacks
;
void
maybeCallGCCallback
(
JSGCStatus
status
JS
:
:
GCReason
reason
)
;
void
purgeRuntime
(
)
;
[
[
nodiscard
]
]
bool
beginPreparePhase
(
JS
:
:
GCReason
reason
AutoGCSession
&
session
)
;
bool
prepareZonesForCollection
(
JS
:
:
GCReason
reason
bool
*
isFullOut
)
;
void
unmarkWeakMaps
(
)
;
void
endPreparePhase
(
JS
:
:
GCReason
reason
)
;
void
beginMarkPhase
(
AutoGCSession
&
session
)
;
bool
shouldPreserveJITCode
(
JS
:
:
Realm
*
realm
const
mozilla
:
:
TimeStamp
&
currentTime
JS
:
:
GCReason
reason
bool
canAllocateMoreCode
bool
isActiveCompartment
)
;
void
discardJITCodeForGC
(
)
;
void
startBackgroundFreeAfterMinorGC
(
)
;
void
relazifyFunctionsForShrinkingGC
(
)
;
void
purgePropMapTablesForShrinkingGC
(
)
;
void
purgeSourceURLsForShrinkingGC
(
)
;
void
traceRuntimeForMajorGC
(
JSTracer
*
trc
AutoGCSession
&
session
)
;
void
traceRuntimeAtoms
(
JSTracer
*
trc
const
AutoAccessAtomsZone
&
atomsAccess
)
;
void
traceRuntimeCommon
(
JSTracer
*
trc
TraceOrMarkRuntime
traceOrMark
)
;
void
traceEmbeddingBlackRoots
(
JSTracer
*
trc
)
;
void
traceEmbeddingGrayRoots
(
JSTracer
*
trc
)
;
void
markFinalizationRegistryRoots
(
JSTracer
*
trc
)
;
void
checkNoRuntimeRoots
(
AutoGCSession
&
session
)
;
void
maybeDoCycleCollection
(
)
;
void
findDeadCompartments
(
)
;
friend
class
BackgroundMarkTask
;
IncrementalProgress
markUntilBudgetExhausted
(
SliceBudget
&
sliceBudget
GCMarker
:
:
ShouldReportMarkTime
reportTime
=
GCMarker
:
:
ReportMarkTime
)
;
void
drainMarkStack
(
)
;
template
<
class
ZoneIterT
>
IncrementalProgress
markWeakReferences
(
SliceBudget
&
budget
)
;
IncrementalProgress
markWeakReferencesInCurrentGroup
(
SliceBudget
&
budget
)
;
template
<
class
ZoneIterT
>
void
markGrayRoots
(
gcstats
:
:
PhaseKind
phase
)
;
void
markBufferedGrayRoots
(
JS
:
:
Zone
*
zone
)
;
IncrementalProgress
markAllWeakReferences
(
)
;
void
markAllGrayReferences
(
gcstats
:
:
PhaseKind
phase
)
;
void
beginSweepPhase
(
JS
:
:
GCReason
reason
AutoGCSession
&
session
)
;
void
dropStringWrappers
(
)
;
void
groupZonesForSweeping
(
JS
:
:
GCReason
reason
)
;
[
[
nodiscard
]
]
bool
findSweepGroupEdges
(
)
;
void
getNextSweepGroup
(
)
;
IncrementalProgress
markGrayRootsInCurrentGroup
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
;
IncrementalProgress
markGray
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
;
IncrementalProgress
endMarkingSweepGroup
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
;
void
markIncomingGrayCrossCompartmentPointers
(
)
;
IncrementalProgress
beginSweepingSweepGroup
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
;
IncrementalProgress
markDuringSweeping
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
;
void
updateAtomsBitmap
(
)
;
void
sweepCCWrappers
(
)
;
void
sweepMisc
(
)
;
void
sweepCompressionTasks
(
)
;
void
sweepWeakMaps
(
)
;
void
sweepUniqueIds
(
)
;
void
sweepDebuggerOnMainThread
(
JSFreeOp
*
fop
)
;
void
sweepJitDataOnMainThread
(
JSFreeOp
*
fop
)
;
void
sweepFinalizationRegistriesOnMainThread
(
)
;
void
sweepFinalizationRegistries
(
Zone
*
zone
)
;
void
queueFinalizationRegistryForCleanup
(
FinalizationQueueObject
*
queue
)
;
void
sweepWeakRefs
(
)
;
IncrementalProgress
endSweepingSweepGroup
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
;
IncrementalProgress
performSweepActions
(
SliceBudget
&
sliceBudget
)
;
void
startSweepingAtomsTable
(
)
;
IncrementalProgress
sweepAtomsTable
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
;
IncrementalProgress
sweepWeakCaches
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
;
IncrementalProgress
finalizeAllocKind
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
;
IncrementalProgress
sweepPropMapTree
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
;
void
endSweepPhase
(
bool
lastGC
)
;
bool
allCCVisibleZonesWereCollected
(
)
;
void
sweepZones
(
JSFreeOp
*
fop
bool
destroyingRuntime
)
;
void
startDecommit
(
)
;
void
decommitFreeArenas
(
const
bool
&
canel
AutoLockGC
&
lock
)
;
void
decommitFreeArenasWithoutUnlocking
(
const
AutoLockGC
&
lock
)
;
void
queueZonesAndStartBackgroundSweep
(
ZoneList
&
zones
)
;
void
sweepFromBackgroundThread
(
AutoLockHelperThreadState
&
lock
)
;
void
startBackgroundFree
(
)
;
void
freeFromBackgroundThread
(
AutoLockHelperThreadState
&
lock
)
;
void
sweepBackgroundThings
(
ZoneList
&
zones
)
;
void
assertBackgroundSweepingFinished
(
)
;
bool
shouldCompact
(
)
;
void
beginCompactPhase
(
)
;
IncrementalProgress
compactPhase
(
JS
:
:
GCReason
reason
SliceBudget
&
sliceBudget
AutoGCSession
&
session
)
;
void
endCompactPhase
(
)
;
void
sweepZoneAfterCompacting
(
MovingTracer
*
trc
Zone
*
zone
)
;
bool
canRelocateZone
(
Zone
*
zone
)
const
;
[
[
nodiscard
]
]
bool
relocateArenas
(
Zone
*
zone
JS
:
:
GCReason
reason
Arena
*
&
relocatedListOut
SliceBudget
&
sliceBudget
)
;
void
updateRttValueObjects
(
MovingTracer
*
trc
Zone
*
zone
)
;
void
updateCellPointers
(
Zone
*
zone
AllocKinds
kinds
)
;
void
updateAllCellPointers
(
MovingTracer
*
trc
Zone
*
zone
)
;
void
updateZonePointersToRelocatedCells
(
Zone
*
zone
)
;
void
updateRuntimePointersToRelocatedCells
(
AutoGCSession
&
session
)
;
void
clearRelocatedArenas
(
Arena
*
arenaList
JS
:
:
GCReason
reason
)
;
void
clearRelocatedArenasWithoutUnlocking
(
Arena
*
arenaList
JS
:
:
GCReason
reason
const
AutoLockGC
&
lock
)
;
void
releaseRelocatedArenas
(
Arena
*
arenaList
)
;
void
releaseRelocatedArenasWithoutUnlocking
(
Arena
*
arenaList
const
AutoLockGC
&
lock
)
;
#
ifdef
DEBUG
void
protectOrReleaseRelocatedArenas
(
Arena
*
arenaList
JS
:
:
GCReason
reason
)
;
void
protectAndHoldArenas
(
Arena
*
arenaList
)
;
void
unprotectHeldRelocatedArenas
(
const
AutoLockGC
&
lock
)
;
void
releaseHeldRelocatedArenas
(
)
;
void
releaseHeldRelocatedArenasWithoutUnlocking
(
const
AutoLockGC
&
lock
)
;
#
endif
enum
ShouldTriggerSliceWhenFinished
:
bool
{
DontTriggerSliceWhenFinished
=
false
TriggerSliceWhenFinished
=
true
}
;
IncrementalProgress
waitForBackgroundTask
(
GCParallelTask
&
task
const
SliceBudget
&
budget
bool
shouldPauseMutator
ShouldTriggerSliceWhenFinished
triggerSlice
)
;
void
maybeRequestGCAfterBackgroundTask
(
const
AutoLockHelperThreadState
&
lock
)
;
void
cancelRequestedGCAfterBackgroundTask
(
)
;
void
finishCollection
(
)
;
void
maybeStopPretenuring
(
)
;
void
checkGCStateNotInUse
(
)
;
IncrementalProgress
joinBackgroundMarkTask
(
)
;
#
ifdef
JS_GC_ZEAL
void
computeNonIncrementalMarkingForValidation
(
AutoGCSession
&
session
)
;
void
validateIncrementalMarking
(
)
;
void
finishMarkingValidation
(
)
;
#
endif
#
ifdef
DEBUG
void
checkForCompartmentMismatches
(
)
;
#
endif
void
callFinalizeCallbacks
(
JSFreeOp
*
fop
JSFinalizeStatus
status
)
const
;
void
callWeakPointerZonesCallbacks
(
)
const
;
void
callWeakPointerCompartmentCallbacks
(
JS
:
:
Compartment
*
comp
)
const
;
void
callDoCycleCollectionCallback
(
JSContext
*
cx
)
;
public
:
JSRuntime
*
const
rt
;
WriteOnceData
<
Zone
*
>
atomsZone
;
MainThreadData
<
JS
:
:
Zone
*
>
systemZone
;
private
:
MainThreadOrGCTaskData
<
ZoneVector
>
zones_
;
mozilla
:
:
Atomic
<
JS
:
:
HeapState
mozilla
:
:
SequentiallyConsistent
>
heapState_
;
friend
class
AutoHeapSession
;
friend
class
JS
:
:
AutoEnterCycleCollection
;
UnprotectedData
<
gcstats
:
:
Statistics
>
stats_
;
public
:
js
:
:
StringStats
stringStats
;
GCMarker
marker
;
BarrierTracer
barrierTracer
;
Vector
<
JS
:
:
GCCellPtr
0
SystemAllocPolicy
>
unmarkGrayStack
;
HeapSize
heapSize
;
GCSchedulingTunables
tunables
;
GCSchedulingState
schedulingState
;
MainThreadData
<
double
>
helperThreadRatio
;
MainThreadData
<
size_t
>
maxHelperThreads
;
MainThreadData
<
size_t
>
helperThreadCount
;
AtomMarkingRuntime
atomMarking
;
private
:
MainThreadData
<
ArenaList
>
permanentAtoms
;
MainThreadData
<
ArenaList
>
permanentFatInlineAtoms
;
GCLockData
<
ChunkPool
>
emptyChunks_
;
GCLockData
<
ChunkPool
>
availableChunks_
;
GCLockData
<
ChunkPool
>
fullChunks_
;
MainThreadData
<
RootedValueMap
>
rootsHash
;
mozilla
:
:
Atomic
<
uint64_t
mozilla
:
:
ReleaseAcquire
>
nextCellUniqueId_
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
numArenasFreeCommitted
;
MainThreadData
<
VerifyPreTracer
*
>
verifyPreData
;
private
:
MainThreadData
<
mozilla
:
:
TimeStamp
>
lastGCStartTime_
;
MainThreadData
<
mozilla
:
:
TimeStamp
>
lastGCEndTime_
;
MainThreadData
<
bool
>
incrementalGCEnabled
;
MainThreadData
<
bool
>
perZoneGCEnabled
;
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
ReleaseAcquire
>
numActiveZoneIters
;
MainThreadData
<
bool
>
cleanUpEverything
;
UnprotectedData
<
bool
>
grayBitsValid
;
mozilla
:
:
Atomic
<
JS
:
:
GCReason
mozilla
:
:
ReleaseAcquire
>
majorGCTriggerReason
;
private
:
MainThreadData
<
bool
>
fullGCForAtomsRequested_
;
MainThreadData
<
uint64_t
>
minorGCNumber
;
MainThreadData
<
uint64_t
>
majorGCNumber
;
MainThreadData
<
uint64_t
>
number
;
MainThreadData
<
uint64_t
>
sliceNumber
;
MainThreadOrGCTaskData
<
bool
>
isIncremental
;
MainThreadData
<
bool
>
isFull
;
MainThreadData
<
bool
>
isCompacting
;
MainThreadOrGCTaskData
<
JS
:
:
GCOptions
>
gcOptions
;
MainThreadData
<
JS
:
:
GCReason
>
initialReason
;
MainThreadOrGCTaskData
<
State
>
incrementalState
;
MainThreadOrGCTaskData
<
State
>
initialState
;
#
ifdef
JS_GC_ZEAL
MainThreadData
<
bool
>
useZeal
;
#
else
const
bool
useZeal
;
#
endif
MainThreadData
<
bool
>
lastMarkSlice
;
MainThreadData
<
bool
>
safeToYield
;
MainThreadData
<
bool
>
markOnBackgroundThreadDuringSweeping
;
MainThreadData
<
bool
>
sweepOnBackgroundThread
;
HelperThreadLockData
<
ZoneList
>
backgroundSweepZones
;
HelperThreadLockData
<
bool
>
requestSliceAfterBackgroundTask
;
HelperThreadLockData
<
LifoAlloc
>
lifoBlocksToFree
;
MainThreadData
<
LifoAlloc
>
lifoBlocksToFreeAfterMinorGC
;
HelperThreadLockData
<
Nursery
:
:
BufferSet
>
buffersToFreeAfterMinorGC
;
MainThreadData
<
unsigned
>
sweepGroupIndex
;
MainThreadData
<
JS
:
:
Zone
*
>
sweepGroups
;
MainThreadOrGCTaskData
<
JS
:
:
Zone
*
>
currentSweepGroup
;
MainThreadData
<
UniquePtr
<
SweepAction
>
>
sweepActions
;
MainThreadOrGCTaskData
<
JS
:
:
Zone
*
>
sweepZone
;
MainThreadOrGCTaskData
<
AllocKind
>
sweepAllocKind
;
MainThreadData
<
mozilla
:
:
Maybe
<
AtomsTable
:
:
SweepIterator
>
>
maybeAtomsToSweep
;
MainThreadOrGCTaskData
<
mozilla
:
:
Maybe
<
WeakCacheSweepIterator
>
>
weakCachesToSweep
;
MainThreadData
<
bool
>
abortSweepAfterCurrentGroup
;
MainThreadOrGCTaskData
<
IncrementalProgress
>
sweepMarkResult
;
#
ifdef
DEBUG
MainThreadData
<
Vector
<
const
Cell
*
0
SystemAllocPolicy
>
>
cellsToAssertNotGray
;
friend
void
js
:
:
gc
:
:
detail
:
:
AssertCellIsNotGray
(
const
Cell
*
)
;
#
endif
friend
class
SweepGroupsIter
;
MainThreadData
<
bool
>
startedCompacting
;
MainThreadData
<
ZoneList
>
zonesToMaybeCompact
;
MainThreadData
<
size_t
>
zonesCompacted
;
#
ifdef
DEBUG
GCLockData
<
Arena
*
>
relocatedArenasToRelease
;
#
endif
#
ifdef
JS_GC_ZEAL
MainThreadData
<
MarkingValidator
*
>
markingValidator
;
#
endif
MainThreadData
<
int64_t
>
defaultTimeBudgetMS_
;
MainThreadData
<
bool
>
incrementalAllowed
;
MainThreadData
<
bool
>
compactingEnabled
;
MainThreadData
<
bool
>
rootsRemoved
;
#
ifdef
JS_GC_ZEAL
static_assert
(
size_t
(
ZealMode
:
:
Count
)
<
=
32
"
Too
many
zeal
modes
to
store
in
a
uint32_t
"
)
;
MainThreadData
<
uint32_t
>
zealModeBits
;
MainThreadData
<
int
>
zealFrequency
;
MainThreadData
<
int
>
nextScheduled
;
MainThreadData
<
bool
>
deterministicOnly
;
MainThreadData
<
int
>
zealSliceBudget
;
MainThreadData
<
PersistentRooted
<
GCVector
<
JSObject
*
0
SystemAllocPolicy
>
>
>
selectedForMarking
;
#
endif
MainThreadData
<
bool
>
fullCompartmentChecks
;
MainThreadData
<
uint32_t
>
gcCallbackDepth
;
MainThreadData
<
Callback
<
JSGCCallback
>
>
gcCallback
;
MainThreadData
<
Callback
<
JS
:
:
DoCycleCollectionCallback
>
>
gcDoCycleCollectionCallback
;
MainThreadData
<
Callback
<
JSObjectsTenuredCallback
>
>
tenuredCallback
;
MainThreadData
<
CallbackVector
<
JSFinalizeCallback
>
>
finalizeCallbacks
;
MainThreadOrGCTaskData
<
Callback
<
JSHostCleanupFinalizationRegistryCallback
>
>
hostCleanupFinalizationRegistryCallback
;
MainThreadData
<
CallbackVector
<
JSWeakPointerZonesCallback
>
>
updateWeakPointerZonesCallbacks
;
MainThreadData
<
CallbackVector
<
JSWeakPointerCompartmentCallback
>
>
updateWeakPointerCompartmentCallbacks
;
MainThreadData
<
CallbackVector
<
JSTraceDataOp
>
>
blackRootTracers
;
MainThreadOrGCTaskData
<
Callback
<
JSTraceDataOp
>
>
grayRootTracer
;
MainThreadData
<
bool
>
alwaysPreserveCode
;
MainThreadData
<
size_t
>
inPageLoadCount
;
MainThreadData
<
bool
>
lowMemoryState
;
friend
class
js
:
:
AutoLockGC
;
friend
class
js
:
:
AutoLockGCBgAlloc
;
js
:
:
Mutex
lock
;
friend
class
BackgroundSweepTask
;
friend
class
BackgroundFreeTask
;
BackgroundAllocTask
allocTask
;
BackgroundUnmarkTask
unmarkTask
;
BackgroundMarkTask
markTask
;
BackgroundSweepTask
sweepTask
;
BackgroundFreeTask
freeTask
;
BackgroundDecommitTask
decommitTask
;
MainThreadData
<
SortedArenaList
>
incrementalSweepList
;
private
:
MainThreadData
<
Nursery
>
nursery_
;
MainThreadOrGCTaskData
<
gc
:
:
StoreBuffer
>
storeBuffer_
;
mozilla
:
:
TimeStamp
lastLastDitchTime
;
friend
class
MarkingValidator
;
friend
class
AutoEnterIteration
;
}
;
class
MOZ_RAII
AutoEnterIteration
{
GCRuntime
*
gc
;
public
:
explicit
AutoEnterIteration
(
GCRuntime
*
gc_
)
:
gc
(
gc_
)
{
+
+
gc
-
>
numActiveZoneIters
;
}
~
AutoEnterIteration
(
)
{
MOZ_ASSERT
(
gc
-
>
numActiveZoneIters
)
;
-
-
gc
-
>
numActiveZoneIters
;
}
}
;
#
ifdef
JS_GC_ZEAL
inline
bool
GCRuntime
:
:
hasZealMode
(
ZealMode
mode
)
{
static_assert
(
size_t
(
ZealMode
:
:
Limit
)
<
sizeof
(
zealModeBits
)
*
8
"
Zeal
modes
must
fit
in
zealModeBits
"
)
;
return
zealModeBits
&
(
1
<
<
uint32_t
(
mode
)
)
;
}
inline
void
GCRuntime
:
:
clearZealMode
(
ZealMode
mode
)
{
zealModeBits
&
=
~
(
1
<
<
uint32_t
(
mode
)
)
;
MOZ_ASSERT
(
!
hasZealMode
(
mode
)
)
;
}
inline
bool
GCRuntime
:
:
needZealousGC
(
)
{
if
(
nextScheduled
>
0
&
&
-
-
nextScheduled
=
=
0
)
{
if
(
hasZealMode
(
ZealMode
:
:
Alloc
)
|
|
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
|
|
hasZealMode
(
ZealMode
:
:
IncrementalMultipleSlices
)
|
|
hasZealMode
(
ZealMode
:
:
Compact
)
|
|
hasIncrementalTwoSliceZealMode
(
)
)
{
nextScheduled
=
zealFrequency
;
}
return
true
;
}
return
false
;
}
inline
bool
GCRuntime
:
:
hasIncrementalTwoSliceZealMode
(
)
{
return
hasZealMode
(
ZealMode
:
:
YieldBeforeRootMarking
)
|
|
hasZealMode
(
ZealMode
:
:
YieldBeforeMarking
)
|
|
hasZealMode
(
ZealMode
:
:
YieldBeforeSweeping
)
|
|
hasZealMode
(
ZealMode
:
:
YieldBeforeSweepingAtoms
)
|
|
hasZealMode
(
ZealMode
:
:
YieldBeforeSweepingCaches
)
|
|
hasZealMode
(
ZealMode
:
:
YieldBeforeSweepingObjects
)
|
|
hasZealMode
(
ZealMode
:
:
YieldBeforeSweepingNonObjects
)
|
|
hasZealMode
(
ZealMode
:
:
YieldBeforeSweepingPropMapTrees
)
|
|
hasZealMode
(
ZealMode
:
:
YieldWhileGrayMarking
)
;
}
#
else
inline
bool
GCRuntime
:
:
hasZealMode
(
ZealMode
mode
)
{
return
false
;
}
inline
void
GCRuntime
:
:
clearZealMode
(
ZealMode
mode
)
{
}
inline
bool
GCRuntime
:
:
needZealousGC
(
)
{
return
false
;
}
inline
bool
GCRuntime
:
:
hasIncrementalTwoSliceZealMode
(
)
{
return
false
;
}
#
endif
bool
IsCurrentlyAnimating
(
const
mozilla
:
:
TimeStamp
&
lastAnimationTime
const
mozilla
:
:
TimeStamp
&
currentTime
)
;
}
}
#
endif
