#
ifndef
gc_FinalizationObservers_h
#
define
gc_FinalizationObservers_h
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
WeakMap
.
h
"
#
include
"
gc
/
ZoneAllocator
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
class
FinalizationRegistryObject
;
class
FinalizationRecordObject
;
class
FinalizationQueueObject
;
class
WeakRefObject
;
namespace
gc
{
JS
:
:
Zone
*
GetWeakTargetZone
(
const
Value
&
value
)
;
class
ObserverListObject
;
class
ObserverList
;
class
ObserverListPtr
{
Value
value
;
enum
Kind
:
uintptr_t
{
ElementKind
=
0
ListHeadKind
=
1
KindMask
=
1
}
;
explicit
ObserverListPtr
(
Value
value
)
;
ObserverListPtr
(
void
*
ptr
Kind
kind
)
;
Kind
kind
(
)
const
;
void
*
ptr
(
)
const
;
template
<
typename
F
>
auto
map
(
F
&
&
func
)
const
;
public
:
MOZ_IMPLICIT
ObserverListPtr
(
ObserverListObject
*
element
)
;
MOZ_IMPLICIT
ObserverListPtr
(
ObserverList
*
list
)
;
static
ObserverListPtr
fromValue
(
Value
value
)
;
bool
operator
=
=
(
const
ObserverListPtr
&
other
)
const
{
return
value
=
=
other
.
value
;
}
bool
operator
!
=
(
const
ObserverListPtr
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
Value
asValue
(
)
const
{
return
value
;
}
bool
isElement
(
)
const
;
ObserverListObject
*
asElement
(
)
const
;
ObserverList
*
asList
(
)
const
;
ObserverListPtr
getNext
(
)
const
;
ObserverListPtr
getPrev
(
)
const
;
void
setNext
(
ObserverListPtr
next
)
;
void
setPrev
(
ObserverListPtr
prev
)
;
}
;
class
ObserverListObject
:
public
NativeObject
{
using
Ptr
=
ObserverListPtr
;
Ptr
getNext
(
)
const
;
Ptr
getPrev
(
)
const
;
void
setNext
(
Ptr
next
)
;
void
setPrev
(
Ptr
prev
)
;
friend
class
ObserverListPtr
;
friend
class
ObserverList
;
static
size_t
objectMoved
(
JSObject
*
obj
JSObject
*
old
)
;
void
objectMovedFrom
(
ObserverListObject
*
old
)
;
protected
:
enum
{
NextSlot
PrevSlot
SlotCount
}
;
static
const
ClassExtension
classExtension_
;
public
:
void
unlink
(
)
;
bool
isInList
(
)
const
;
}
;
class
ObserverList
{
using
Ptr
=
ObserverListPtr
;
Ptr
next
;
Ptr
prev
;
Ptr
getNext
(
)
const
{
return
next
;
}
Ptr
getPrev
(
)
const
{
return
prev
;
}
void
setNext
(
Ptr
link
)
;
void
setPrev
(
Ptr
link
)
;
friend
class
ObserverListPtr
;
public
:
class
Iter
;
ObserverList
(
)
;
~
ObserverList
(
)
;
ObserverList
(
const
ObserverList
&
other
)
=
delete
;
ObserverList
&
operator
=
(
const
ObserverList
&
other
)
=
delete
;
ObserverList
(
ObserverList
&
&
other
)
;
ObserverList
&
operator
=
(
ObserverList
&
&
other
)
;
bool
isEmpty
(
)
const
;
ObserverListObject
*
getFirst
(
)
const
;
Iter
iter
(
)
;
void
insertFront
(
ObserverListObject
*
obj
)
;
}
;
class
FinalizationObservers
{
using
RegistrySet
=
GCHashSet
<
HeapPtr
<
FinalizationRegistryObject
*
>
StableCellHasher
<
HeapPtr
<
FinalizationRegistryObject
*
>
>
ZoneAllocPolicy
>
;
RegistrySet
registries
;
using
RecordMap
=
GCHashMap
<
HeapPtr
<
Value
>
ObserverList
WeakTargetHasher
ZoneAllocPolicy
>
;
RecordMap
recordMap
;
using
WeakRefMap
=
GCHashMap
<
HeapPtr
<
Value
>
ObserverList
WeakTargetHasher
ZoneAllocPolicy
>
;
WeakRefMap
weakRefMap
;
public
:
explicit
FinalizationObservers
(
Zone
*
zone
)
;
~
FinalizationObservers
(
)
;
bool
addRegistry
(
Handle
<
FinalizationRegistryObject
*
>
registry
)
;
bool
addRecord
(
HandleValue
target
Handle
<
FinalizationRecordObject
*
>
record
)
;
void
clearRecords
(
)
;
bool
addWeakRefTarget
(
Handle
<
Value
>
target
Handle
<
WeakRefObject
*
>
weakRef
)
;
void
removeWeakRefTarget
(
Handle
<
Value
>
target
Handle
<
WeakRefObject
*
>
weakRef
)
;
void
traceWeakEdges
(
JSTracer
*
trc
)
;
private
:
void
traceWeakFinalizationRegistryEdges
(
JSTracer
*
trc
)
;
void
traceWeakWeakRefEdges
(
JSTracer
*
trc
)
;
void
traceWeakWeakRefList
(
JSTracer
*
trc
ObserverList
&
weakRefs
Value
target
)
;
bool
shouldQueueFinalizationRegistryForCleanup
(
FinalizationQueueObject
*
)
;
}
;
}
}
#
endif
