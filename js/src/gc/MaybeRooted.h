#
ifndef
gc_MaybeRooted_h
#
define
gc_MaybeRooted_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
type_traits
>
#
include
"
gc
/
Allocator
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
namespace
js
{
template
<
typename
T
>
class
MOZ_RAII
FakeRooted
:
public
RootedBase
<
T
FakeRooted
<
T
>
>
{
public
:
using
ElementType
=
T
;
template
<
typename
CX
>
explicit
FakeRooted
(
CX
*
cx
)
:
ptr
(
JS
:
:
SafelyInitialized
<
T
>
(
)
)
{
}
template
<
typename
CX
>
FakeRooted
(
CX
*
cx
T
initial
)
:
ptr
(
initial
)
{
}
DECLARE_POINTER_CONSTREF_OPS
(
T
)
;
DECLARE_POINTER_ASSIGN_OPS
(
FakeRooted
T
)
;
DECLARE_NONPOINTER_ACCESSOR_METHODS
(
ptr
)
;
DECLARE_NONPOINTER_MUTABLE_ACCESSOR_METHODS
(
ptr
)
;
private
:
T
ptr
;
void
set
(
const
T
&
value
)
{
ptr
=
value
;
}
FakeRooted
(
const
FakeRooted
&
)
=
delete
;
}
;
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
FakeRooted
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
FakeRooted
<
T
>
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
template
<
typename
T
>
class
FakeMutableHandle
:
public
js
:
:
MutableHandleBase
<
T
FakeMutableHandle
<
T
>
>
{
public
:
using
ElementType
=
T
;
MOZ_IMPLICIT
FakeMutableHandle
(
T
*
t
)
:
ptr
(
t
)
{
}
MOZ_IMPLICIT
FakeMutableHandle
(
FakeRooted
<
T
>
*
root
)
:
ptr
(
root
-
>
address
(
)
)
{
}
void
set
(
const
T
&
v
)
{
*
ptr
=
v
;
}
DECLARE_POINTER_CONSTREF_OPS
(
T
)
;
DECLARE_NONPOINTER_ACCESSOR_METHODS
(
*
ptr
)
;
DECLARE_NONPOINTER_MUTABLE_ACCESSOR_METHODS
(
*
ptr
)
;
private
:
FakeMutableHandle
(
)
:
ptr
(
nullptr
)
{
}
DELETE_ASSIGNMENT_OPS
(
FakeMutableHandle
T
)
;
T
*
ptr
;
}
;
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
FakeMutableHandle
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
FakeMutableHandle
<
T
>
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
template
<
typename
T
AllowGC
allowGC
>
class
MaybeRooted
;
template
<
typename
T
>
class
MaybeRooted
<
T
CanGC
>
{
public
:
using
HandleType
=
JS
:
:
Handle
<
T
>
;
using
RootType
=
JS
:
:
Rooted
<
T
>
;
using
MutableHandleType
=
JS
:
:
MutableHandle
<
T
>
;
static
JS
:
:
Handle
<
T
>
toHandle
(
HandleType
v
)
{
return
v
;
}
static
JS
:
:
MutableHandle
<
T
>
toMutableHandle
(
MutableHandleType
v
)
{
return
v
;
}
template
<
typename
T2
>
static
JS
:
:
Handle
<
T2
*
>
downcastHandle
(
HandleType
v
)
{
return
v
.
template
as
<
T2
>
(
)
;
}
}
;
template
<
typename
T
>
class
MaybeRooted
<
T
NoGC
>
{
public
:
using
HandleType
=
const
T
&
;
using
RootType
=
FakeRooted
<
T
>
;
using
MutableHandleType
=
FakeMutableHandle
<
T
>
;
static
JS
:
:
Handle
<
T
>
toHandle
(
HandleType
v
)
{
MOZ_CRASH
(
"
Bad
conversion
"
)
;
}
static
JS
:
:
MutableHandle
<
T
>
toMutableHandle
(
MutableHandleType
v
)
{
MOZ_CRASH
(
"
Bad
conversion
"
)
;
}
template
<
typename
T2
>
static
T2
*
downcastHandle
(
HandleType
v
)
{
return
&
v
-
>
template
as
<
T2
>
(
)
;
}
}
;
}
#
endif
