#
ifndef
gc_WeakMap_h
#
define
gc_WeakMap_h
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
DeletePolicy
.
h
"
#
include
"
gc
/
Tracer
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
gc
/
ZoneAllocator
.
h
"
#
include
"
js
/
HashTable
.
h
"
namespace
js
{
class
GCMarker
;
class
WeakMapBase
;
struct
WeakMapTracer
;
namespace
gc
{
struct
WeakMarkable
;
#
if
defined
(
JS_GC_ZEAL
)
|
|
defined
(
DEBUG
)
bool
CheckWeakMapEntryMarking
(
const
WeakMapBase
*
map
Cell
*
key
Cell
*
value
)
;
#
endif
}
using
WeakMapColors
=
HashMap
<
WeakMapBase
*
js
:
:
gc
:
:
CellColor
DefaultHasher
<
WeakMapBase
*
>
SystemAllocPolicy
>
;
class
WeakMapBase
:
public
mozilla
:
:
LinkedListElement
<
WeakMapBase
>
{
public
:
friend
class
js
:
:
GCMarker
;
using
CellColor
=
js
:
:
gc
:
:
CellColor
;
protected
:
template
<
typename
T
>
CellColor
getCellColor
(
const
T
&
k
)
const
{
if
(
!
k
-
>
zone
(
)
-
>
shouldMarkInZone
(
)
|
|
!
k
-
>
isTenured
(
)
)
{
return
CellColor
:
:
Black
;
}
return
GetCellColor
(
k
)
;
}
public
:
WeakMapBase
(
JSObject
*
memOf
JS
:
:
Zone
*
zone
)
;
virtual
~
WeakMapBase
(
)
;
JS
:
:
Zone
*
zone
(
)
const
{
return
zone_
;
}
static
void
unmarkZone
(
JS
:
:
Zone
*
zone
)
;
static
void
traceZone
(
JS
:
:
Zone
*
zone
JSTracer
*
tracer
)
;
static
bool
markZoneIteratively
(
JS
:
:
Zone
*
zone
GCMarker
*
marker
)
;
static
MOZ_MUST_USE
bool
findSweepGroupEdges
(
JS
:
:
Zone
*
zone
)
;
static
void
sweepZone
(
JS
:
:
Zone
*
zone
)
;
static
void
sweepZoneAfterMinorGC
(
JS
:
:
Zone
*
zone
)
;
static
void
traceAllMappings
(
WeakMapTracer
*
tracer
)
;
static
bool
saveZoneMarkedWeakMaps
(
JS
:
:
Zone
*
zone
WeakMapColors
&
markedWeakMaps
)
;
static
void
restoreMarkedWeakMaps
(
WeakMapColors
&
markedWeakMaps
)
;
#
if
defined
(
JS_GC_ZEAL
)
|
|
defined
(
DEBUG
)
static
bool
checkMarkingForZone
(
JS
:
:
Zone
*
zone
)
;
#
endif
template
<
typename
T
>
static
JSObject
*
getDelegate
(
const
T
&
key
)
;
protected
:
virtual
void
trace
(
JSTracer
*
tracer
)
=
0
;
virtual
bool
findZoneEdges
(
)
=
0
;
virtual
void
sweep
(
)
=
0
;
virtual
void
traceMappings
(
WeakMapTracer
*
tracer
)
=
0
;
virtual
void
clearAndCompact
(
)
=
0
;
virtual
void
markEntry
(
GCMarker
*
marker
gc
:
:
Cell
*
markedCell
gc
:
:
Cell
*
l
)
=
0
;
virtual
void
postSeverDelegate
(
GCMarker
*
marker
gc
:
:
Cell
*
key
Compartment
*
comp
)
=
0
;
virtual
bool
markEntries
(
GCMarker
*
marker
)
=
0
;
#
ifdef
JS_GC_ZEAL
virtual
bool
checkMarking
(
)
const
=
0
;
virtual
bool
allowKeysInOtherZones
(
)
const
{
return
false
;
}
friend
bool
gc
:
:
CheckWeakMapEntryMarking
(
const
WeakMapBase
*
gc
:
:
Cell
*
gc
:
:
Cell
*
)
;
#
endif
GCPtrObject
memberOf
;
JS
:
:
Zone
*
zone_
;
gc
:
:
CellColor
markColor
;
}
;
namespace
detail
{
template
<
typename
T
>
struct
RemoveBarrier
{
}
;
template
<
typename
T
>
struct
RemoveBarrier
<
js
:
:
HeapPtr
<
T
>
>
{
using
Type
=
T
;
}
;
}
template
<
class
Key
class
Value
>
class
WeakMap
:
private
HashMap
<
Key
Value
MovableCellHasher
<
Key
>
ZoneAllocPolicy
>
public
WeakMapBase
{
public
:
using
Base
=
HashMap
<
Key
Value
MovableCellHasher
<
Key
>
ZoneAllocPolicy
>
;
using
Lookup
=
typename
Base
:
:
Lookup
;
using
Entry
=
typename
Base
:
:
Entry
;
using
Range
=
typename
Base
:
:
Range
;
using
Ptr
=
typename
Base
:
:
Ptr
;
using
AddPtr
=
typename
Base
:
:
AddPtr
;
struct
Enum
:
public
Base
:
:
Enum
{
explicit
Enum
(
WeakMap
&
map
)
:
Base
:
:
Enum
(
static_cast
<
Base
&
>
(
map
)
)
{
}
}
;
using
Base
:
:
all
;
using
Base
:
:
clear
;
using
Base
:
:
has
;
using
Base
:
:
shallowSizeOfExcludingThis
;
using
Base
:
:
remove
;
using
UnbarrieredKey
=
typename
detail
:
:
RemoveBarrier
<
Key
>
:
:
Type
;
explicit
WeakMap
(
JSContext
*
cx
JSObject
*
memOf
=
nullptr
)
;
Ptr
lookup
(
const
Lookup
&
l
)
const
{
Ptr
p
=
Base
:
:
lookup
(
l
)
;
if
(
p
)
{
exposeGCThingToActiveJS
(
p
-
>
value
(
)
)
;
}
return
p
;
}
AddPtr
lookupForAdd
(
const
Lookup
&
l
)
{
AddPtr
p
=
Base
:
:
lookupForAdd
(
l
)
;
if
(
p
)
{
exposeGCThingToActiveJS
(
p
-
>
value
(
)
)
;
}
return
p
;
}
void
remove
(
Ptr
p
)
{
MOZ_ASSERT
(
p
.
found
(
)
)
;
if
(
markColor
!
=
CellColor
:
:
White
)
{
forgetKey
(
p
-
>
key
(
)
)
;
}
Base
:
:
remove
(
p
)
;
}
void
remove
(
const
Lookup
&
l
)
{
if
(
Ptr
p
=
lookup
(
l
)
)
{
remove
(
p
)
;
}
}
void
clear
(
)
{
Base
:
:
clear
(
)
;
JSRuntime
*
rt
=
zone
(
)
-
>
runtimeFromMainThread
(
)
;
if
(
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
{
rt
-
>
gc
.
marker
.
forgetWeakMap
(
this
zone
(
)
)
;
}
}
template
<
typename
KeyInput
typename
ValueInput
>
MOZ_MUST_USE
bool
add
(
AddPtr
&
p
KeyInput
&
&
k
ValueInput
&
&
v
)
{
MOZ_ASSERT
(
k
)
;
if
(
!
Base
:
:
add
(
p
std
:
:
forward
<
KeyInput
>
(
k
)
std
:
:
forward
<
ValueInput
>
(
v
)
)
)
{
return
false
;
}
barrierForInsert
(
p
-
>
key
(
)
p
-
>
value
(
)
)
;
return
true
;
}
template
<
typename
KeyInput
typename
ValueInput
>
MOZ_MUST_USE
bool
relookupOrAdd
(
AddPtr
&
p
KeyInput
&
&
k
ValueInput
&
&
v
)
{
MOZ_ASSERT
(
k
)
;
if
(
!
Base
:
:
relookupOrAdd
(
p
std
:
:
forward
<
KeyInput
>
(
k
)
std
:
:
forward
<
ValueInput
>
(
v
)
)
)
{
return
false
;
}
barrierForInsert
(
p
-
>
key
(
)
p
-
>
value
(
)
)
;
return
true
;
}
template
<
typename
KeyInput
typename
ValueInput
>
MOZ_MUST_USE
bool
put
(
KeyInput
&
&
k
ValueInput
&
&
v
)
{
MOZ_ASSERT
(
k
)
;
AddPtr
p
=
lookupForAdd
(
k
)
;
if
(
p
)
{
p
-
>
value
(
)
=
std
:
:
forward
<
ValueInput
>
(
v
)
;
return
true
;
}
return
add
(
p
std
:
:
forward
<
KeyInput
>
(
k
)
std
:
:
forward
<
ValueInput
>
(
v
)
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
MOZ_MUST_USE
bool
putNew
(
KeyInput
&
&
k
ValueInput
&
&
v
)
{
MOZ_ASSERT
(
k
)
;
barrierForInsert
(
k
v
)
;
return
Base
:
:
putNew
(
std
:
:
forward
<
KeyInput
>
(
k
)
std
:
:
forward
<
ValueInput
>
(
v
)
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
void
putNewInfallible
(
KeyInput
&
&
k
ValueInput
&
&
v
)
{
MOZ_ASSERT
(
k
)
;
barrierForInsert
(
k
v
)
;
Base
:
:
putNewInfallible
(
std
:
:
forward
(
k
)
std
:
:
forward
<
KeyInput
>
(
k
)
)
;
}
void
markEntry
(
GCMarker
*
marker
gc
:
:
Cell
*
markedCell
gc
:
:
Cell
*
origKey
)
override
;
void
postSeverDelegate
(
GCMarker
*
marker
gc
:
:
Cell
*
key
Compartment
*
comp
)
override
;
void
trace
(
JSTracer
*
trc
)
override
;
protected
:
void
forgetKey
(
UnbarrieredKey
key
)
{
JSRuntime
*
rt
=
zone
(
)
-
>
runtimeFromMainThread
(
)
;
if
(
rt
-
>
gc
.
isIncrementalGCInProgress
(
)
)
{
if
(
JSObject
*
delegate
=
getDelegate
(
key
)
)
{
js
:
:
gc
:
:
WeakKeyTable
&
weakKeys
=
delegate
-
>
zone
(
)
-
>
gcWeakKeys
(
delegate
)
;
rt
-
>
gc
.
marker
.
forgetWeakKey
(
weakKeys
this
delegate
key
)
;
}
else
{
js
:
:
gc
:
:
WeakKeyTable
&
weakKeys
=
key
-
>
zone
(
)
-
>
gcWeakKeys
(
key
)
;
rt
-
>
gc
.
marker
.
forgetWeakKey
(
weakKeys
this
key
key
)
;
}
}
}
void
barrierForInsert
(
Key
k
const
Value
&
v
)
{
if
(
markColor
=
=
CellColor
:
:
White
)
{
return
;
}
if
(
!
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
{
return
;
}
JSTracer
*
trc
=
zone
(
)
-
>
barrierTracer
(
)
;
Value
tmp
=
v
;
TraceEdge
(
trc
&
tmp
"
weakmap
inserted
value
"
)
;
MOZ_ASSERT
(
tmp
=
=
v
)
;
}
static
void
addWeakEntry
(
GCMarker
*
marker
gc
:
:
Cell
*
key
const
gc
:
:
WeakMarkable
&
markable
)
;
bool
markEntries
(
GCMarker
*
marker
)
override
;
private
:
void
exposeGCThingToActiveJS
(
const
JS
:
:
Value
&
v
)
const
{
JS
:
:
ExposeValueToActiveJS
(
v
)
;
}
void
exposeGCThingToActiveJS
(
JSObject
*
obj
)
const
{
JS
:
:
ExposeObjectToActiveJS
(
obj
)
;
}
CellColor
getDelegateColor
(
JSObject
*
key
)
const
;
CellColor
getDelegateColor
(
JSScript
*
script
)
const
;
CellColor
getDelegateColor
(
LazyScript
*
script
)
const
;
bool
findZoneEdges
(
)
override
{
return
true
;
}
void
sweep
(
)
override
;
void
clearAndCompact
(
)
override
{
Base
:
:
clear
(
)
;
Base
:
:
compact
(
)
;
}
void
traceMappings
(
WeakMapTracer
*
tracer
)
override
;
protected
:
#
if
DEBUG
void
assertEntriesNotAboutToBeFinalized
(
)
;
#
endif
#
ifdef
JS_GC_ZEAL
bool
checkMarking
(
)
const
override
;
#
endif
}
;
class
ObjectValueMap
:
public
WeakMap
<
HeapPtr
<
JSObject
*
>
HeapPtr
<
Value
>
>
{
public
:
ObjectValueMap
(
JSContext
*
cx
JSObject
*
obj
)
:
WeakMap
(
cx
obj
)
{
}
bool
findZoneEdges
(
)
override
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
}
;
class
ObjectWeakMap
{
ObjectValueMap
map
;
public
:
explicit
ObjectWeakMap
(
JSContext
*
cx
)
;
JS
:
:
Zone
*
zone
(
)
const
{
return
map
.
zone
(
)
;
}
JSObject
*
lookup
(
const
JSObject
*
obj
)
;
bool
add
(
JSContext
*
cx
JSObject
*
obj
JSObject
*
target
)
;
void
clear
(
)
;
void
trace
(
JSTracer
*
trc
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
mallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkAfterMovingGC
(
)
;
#
endif
}
;
}
namespace
JS
{
template
<
>
struct
DeletePolicy
<
js
:
:
ObjectValueMap
>
:
public
js
:
:
GCManagedDeletePolicy
<
js
:
:
ObjectValueMap
>
{
}
;
}
#
endif
