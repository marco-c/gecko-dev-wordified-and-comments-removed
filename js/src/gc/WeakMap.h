#
ifndef
gc_WeakMap_h
#
define
gc_WeakMap_h
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
DeletePolicy
.
h
"
#
include
"
js
/
HashTable
.
h
"
namespace
JS
{
class
Zone
;
}
namespace
js
{
class
GCMarker
;
class
WeakMapBase
;
struct
WeakMapTracer
;
namespace
gc
{
struct
WeakMarkable
;
}
typedef
HashSet
<
WeakMapBase
*
DefaultHasher
<
WeakMapBase
*
>
SystemAllocPolicy
>
WeakMapSet
;
class
WeakMapBase
:
public
mozilla
:
:
LinkedListElement
<
WeakMapBase
>
{
friend
class
js
:
:
GCMarker
;
public
:
WeakMapBase
(
JSObject
*
memOf
JS
:
:
Zone
*
zone
)
;
virtual
~
WeakMapBase
(
)
;
JS
:
:
Zone
*
zone
(
)
const
{
return
zone_
;
}
static
void
unmarkZone
(
JS
:
:
Zone
*
zone
)
;
static
void
traceZone
(
JS
:
:
Zone
*
zone
JSTracer
*
tracer
)
;
static
bool
markZoneIteratively
(
JS
:
:
Zone
*
zone
GCMarker
*
marker
)
;
static
bool
findInterZoneEdges
(
JS
:
:
Zone
*
zone
)
;
static
void
sweepZone
(
JS
:
:
Zone
*
zone
)
;
static
void
traceAllMappings
(
WeakMapTracer
*
tracer
)
;
static
bool
saveZoneMarkedWeakMaps
(
JS
:
:
Zone
*
zone
WeakMapSet
&
markedWeakMaps
)
;
static
void
restoreMarkedWeakMaps
(
WeakMapSet
&
markedWeakMaps
)
;
protected
:
virtual
void
trace
(
JSTracer
*
tracer
)
=
0
;
virtual
bool
findZoneEdges
(
)
=
0
;
virtual
void
sweep
(
)
=
0
;
virtual
void
traceMappings
(
WeakMapTracer
*
tracer
)
=
0
;
virtual
void
finish
(
)
=
0
;
virtual
void
markEntry
(
GCMarker
*
marker
gc
:
:
Cell
*
markedCell
JS
:
:
GCCellPtr
l
)
=
0
;
virtual
bool
markIteratively
(
GCMarker
*
marker
)
=
0
;
protected
:
GCPtrObject
memberOf
;
JS
:
:
Zone
*
zone_
;
bool
marked
;
}
;
template
<
class
Key
class
Value
class
HashPolicy
=
DefaultHasher
<
Key
>
>
class
WeakMap
:
public
HashMap
<
Key
Value
HashPolicy
ZoneAllocPolicy
>
public
WeakMapBase
{
public
:
typedef
HashMap
<
Key
Value
HashPolicy
ZoneAllocPolicy
>
Base
;
typedef
typename
Base
:
:
Enum
Enum
;
typedef
typename
Base
:
:
Lookup
Lookup
;
typedef
typename
Base
:
:
Entry
Entry
;
typedef
typename
Base
:
:
Range
Range
;
typedef
typename
Base
:
:
Ptr
Ptr
;
typedef
typename
Base
:
:
AddPtr
AddPtr
;
explicit
WeakMap
(
JSContext
*
cx
JSObject
*
memOf
=
nullptr
)
;
bool
init
(
uint32_t
len
=
16
)
;
Ptr
lookup
(
const
Lookup
&
l
)
const
{
Ptr
p
=
Base
:
:
lookup
(
l
)
;
if
(
p
)
exposeGCThingToActiveJS
(
p
-
>
value
(
)
)
;
return
p
;
}
AddPtr
lookupForAdd
(
const
Lookup
&
l
)
const
{
AddPtr
p
=
Base
:
:
lookupForAdd
(
l
)
;
if
(
p
)
exposeGCThingToActiveJS
(
p
-
>
value
(
)
)
;
return
p
;
}
Ptr
lookupWithDefault
(
const
Key
&
k
const
Value
&
defaultValue
)
{
Ptr
p
=
Base
:
:
lookupWithDefault
(
k
defaultValue
)
;
if
(
p
)
exposeGCThingToActiveJS
(
p
-
>
value
(
)
)
;
return
p
;
}
using
Base
:
:
remove
;
void
markEntry
(
GCMarker
*
marker
gc
:
:
Cell
*
markedCell
JS
:
:
GCCellPtr
origKey
)
override
;
void
trace
(
JSTracer
*
trc
)
override
;
protected
:
static
void
addWeakEntry
(
GCMarker
*
marker
JS
:
:
GCCellPtr
key
const
gc
:
:
WeakMarkable
&
markable
)
;
bool
markIteratively
(
GCMarker
*
marker
)
override
;
JSObject
*
getDelegate
(
JSObject
*
key
)
const
;
JSObject
*
getDelegate
(
JSScript
*
script
)
const
;
JSObject
*
getDelegate
(
LazyScript
*
script
)
const
;
private
:
void
exposeGCThingToActiveJS
(
const
JS
:
:
Value
&
v
)
const
{
JS
:
:
ExposeValueToActiveJS
(
v
)
;
}
void
exposeGCThingToActiveJS
(
JSObject
*
obj
)
const
{
JS
:
:
ExposeObjectToActiveJS
(
obj
)
;
}
bool
keyNeedsMark
(
JSObject
*
key
)
const
;
bool
keyNeedsMark
(
JSScript
*
script
)
const
;
bool
keyNeedsMark
(
LazyScript
*
script
)
const
;
bool
findZoneEdges
(
)
override
{
return
true
;
}
void
sweep
(
)
override
;
void
finish
(
)
override
{
Base
:
:
finish
(
)
;
}
void
traceMappings
(
WeakMapTracer
*
tracer
)
override
;
protected
:
#
if
DEBUG
void
assertEntriesNotAboutToBeFinalized
(
)
;
#
endif
}
;
class
ObjectValueMap
:
public
WeakMap
<
HeapPtr
<
JSObject
*
>
HeapPtr
<
Value
>
MovableCellHasher
<
HeapPtr
<
JSObject
*
>
>
>
{
public
:
ObjectValueMap
(
JSContext
*
cx
JSObject
*
obj
)
:
WeakMap
<
HeapPtr
<
JSObject
*
>
HeapPtr
<
Value
>
MovableCellHasher
<
HeapPtr
<
JSObject
*
>
>
>
(
cx
obj
)
{
}
bool
findZoneEdges
(
)
override
;
}
;
class
ObjectWeakMap
{
ObjectValueMap
map
;
public
:
explicit
ObjectWeakMap
(
JSContext
*
cx
)
;
bool
init
(
)
;
JS
:
:
Zone
*
zone
(
)
const
{
return
map
.
zone
(
)
;
}
JSObject
*
lookup
(
const
JSObject
*
obj
)
;
bool
add
(
JSContext
*
cx
JSObject
*
obj
JSObject
*
target
)
;
void
clear
(
)
;
void
trace
(
JSTracer
*
trc
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
mallocSizeOf
(
this
)
+
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkAfterMovingGC
(
)
;
#
endif
}
;
}
namespace
JS
{
template
<
>
struct
DeletePolicy
<
js
:
:
ObjectValueMap
>
:
public
js
:
:
GCManagedDeletePolicy
<
js
:
:
ObjectValueMap
>
{
}
;
}
#
endif
