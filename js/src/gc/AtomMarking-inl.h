#
include
"
gc
/
AtomMarking
.
h
"
#
include
"
jscompartment
.
h
"
#
include
"
gc
/
Heap
-
inl
.
h
"
namespace
js
{
namespace
gc
{
inline
size_t
GetAtomBit
(
TenuredCell
*
thing
)
{
MOZ_ASSERT
(
thing
-
>
zoneFromAnyThread
(
)
-
>
isAtomsZone
(
)
)
;
Arena
*
arena
=
thing
-
>
arena
(
)
;
size_t
arenaBit
=
(
reinterpret_cast
<
uintptr_t
>
(
thing
)
-
arena
-
>
address
(
)
)
/
CellBytesPerMarkBit
;
return
arena
-
>
atomBitmapStart
(
)
*
JS_BITS_PER_WORD
+
arenaBit
;
}
inline
bool
ThingIsPermanent
(
JSAtom
*
atom
)
{
return
atom
-
>
isPermanentAtom
(
)
;
}
inline
bool
ThingIsPermanent
(
JS
:
:
Symbol
*
symbol
)
{
return
symbol
-
>
isWellKnownSymbol
(
)
;
}
template
<
typename
T
>
MOZ_ALWAYS_INLINE
void
AtomMarkingRuntime
:
:
inlinedMarkAtom
(
JSContext
*
cx
T
*
thing
)
{
static_assert
(
mozilla
:
:
IsSame
<
T
JSAtom
>
:
:
value
|
|
mozilla
:
:
IsSame
<
T
JS
:
:
Symbol
>
:
:
value
"
Should
only
be
called
with
JSAtom
*
or
JS
:
:
Symbol
*
argument
"
)
;
MOZ_ASSERT
(
thing
)
;
js
:
:
gc
:
:
TenuredCell
*
cell
=
&
thing
-
>
asTenured
(
)
;
MOZ_ASSERT
(
cell
-
>
zoneFromAnyThread
(
)
-
>
isAtomsZone
(
)
)
;
if
(
!
cx
-
>
zone
(
)
)
return
;
MOZ_ASSERT
(
!
cx
-
>
zone
(
)
-
>
isAtomsZone
(
)
)
;
if
(
ThingIsPermanent
(
thing
)
)
return
;
size_t
bit
=
GetAtomBit
(
cell
)
;
MOZ_ASSERT
(
bit
/
JS_BITS_PER_WORD
<
allocatedWords
)
;
cx
-
>
zone
(
)
-
>
markedAtoms
(
)
.
setBit
(
bit
)
;
if
(
!
cx
-
>
helperThread
(
)
)
{
T
:
:
readBarrier
(
thing
)
;
}
markChildren
(
cx
thing
)
;
}
}
}
