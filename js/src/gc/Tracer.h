#
ifndef
js_Tracer_h
#
define
js_Tracer_h
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
TraceKind
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
namespace
JS
{
using
CompartmentSet
=
js
:
:
HashSet
<
Compartment
*
js
:
:
DefaultHasher
<
Compartment
*
>
js
:
:
SystemAllocPolicy
>
;
}
namespace
js
{
class
TaggedProto
;
namespace
wasm
{
class
AnyRef
;
}
class
GCMarker
;
#
ifdef
DEBUG
template
<
typename
T
>
void
CheckTracedThing
(
JSTracer
*
trc
T
*
thing
)
;
template
<
typename
T
>
void
CheckTracedThing
(
JSTracer
*
trc
const
T
&
thing
)
;
#
else
template
<
typename
T
>
inline
void
CheckTracedThing
(
JSTracer
*
trc
T
*
thing
)
{
}
template
<
typename
T
>
inline
void
CheckTracedThing
(
JSTracer
*
trc
const
T
&
thing
)
{
}
#
endif
namespace
gc
{
template
<
typename
T
>
struct
PtrBaseGCType
{
using
type
=
T
;
}
;
template
<
typename
T
>
struct
PtrBaseGCType
<
T
*
>
{
using
type
=
typename
BaseGCType
<
T
>
:
:
type
*
;
}
;
template
<
typename
T
>
typename
PtrBaseGCType
<
T
>
:
:
type
*
ConvertToBase
(
T
*
thingp
)
{
return
reinterpret_cast
<
typename
PtrBaseGCType
<
T
>
:
:
type
*
>
(
thingp
)
;
}
#
define
DEFINE_TRACE_FUNCTION
(
name
type
_1
_2
)
\
MOZ_ALWAYS_INLINE
bool
TraceEdgeInternal
(
JSTracer
*
trc
type
*
*
thingp
\
const
char
*
name
)
{
\
CheckTracedThing
(
trc
*
thingp
)
;
\
trc
-
>
on
#
#
name
#
#
Edge
(
thingp
name
)
;
\
return
*
thingp
;
\
}
JS_FOR_EACH_TRACEKIND
(
DEFINE_TRACE_FUNCTION
)
#
undef
DEFINE_TRACE_FUNCTION
bool
TraceEdgeInternal
(
JSTracer
*
trc
Value
*
thingp
const
char
*
name
)
;
bool
TraceEdgeInternal
(
JSTracer
*
trc
jsid
*
thingp
const
char
*
name
)
;
bool
TraceEdgeInternal
(
JSTracer
*
trc
TaggedProto
*
thingp
const
char
*
name
)
;
bool
TraceEdgeInternal
(
JSTracer
*
trc
wasm
:
:
AnyRef
*
thingp
const
char
*
name
)
;
template
<
typename
T
>
void
TraceRangeInternal
(
JSTracer
*
trc
size_t
len
T
*
vec
const
char
*
name
)
;
template
<
typename
T
>
bool
TraceWeakMapKeyInternal
(
JSTracer
*
trc
Zone
*
zone
T
*
thingp
const
char
*
name
)
;
#
ifdef
DEBUG
void
AssertRootMarkingPhase
(
JSTracer
*
trc
)
;
template
<
typename
T
>
void
AssertShouldMarkInZone
(
GCMarker
*
marker
T
*
thing
)
;
#
else
inline
void
AssertRootMarkingPhase
(
JSTracer
*
trc
)
{
}
template
<
typename
T
>
void
AssertShouldMarkInZone
(
GCMarker
*
marker
T
*
thing
)
{
}
#
endif
}
template
<
typename
T
>
inline
void
TraceEdge
(
JSTracer
*
trc
const
WriteBarriered
<
T
>
*
thingp
const
char
*
name
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
-
>
unbarrieredAddress
(
)
)
name
)
;
}
template
<
typename
T
>
inline
void
TraceEdge
(
JSTracer
*
trc
WeakHeapPtr
<
T
>
*
thingp
const
char
*
name
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
-
>
unbarrieredAddress
(
)
)
name
)
;
}
template
<
class
BC
class
T
>
inline
void
TraceCellHeaderEdge
(
JSTracer
*
trc
gc
:
:
CellWithTenuredGCPointer
<
BC
T
>
*
thingp
const
char
*
name
)
{
T
*
thing
=
thingp
-
>
headerPtr
(
)
;
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
&
thing
)
name
)
;
if
(
thing
!
=
thingp
-
>
headerPtr
(
)
)
{
thingp
-
>
unbarrieredSetHeaderPtr
(
thing
)
;
}
}
template
<
class
T
>
inline
void
TraceCellHeaderEdge
(
JSTracer
*
trc
gc
:
:
CellWithGCPointer
<
T
>
*
thingp
const
char
*
name
)
{
T
*
thing
=
thingp
-
>
headerPtr
(
)
;
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
&
thing
)
name
)
;
if
(
thing
!
=
thingp
-
>
headerPtr
(
)
)
{
thingp
-
>
unbarrieredSetHeaderPtr
(
thing
)
;
}
}
template
<
typename
T
>
inline
void
TraceNullableEdge
(
JSTracer
*
trc
const
WriteBarriered
<
T
>
*
thingp
const
char
*
name
)
{
if
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
thingp
-
>
get
(
)
)
)
{
TraceEdge
(
trc
thingp
name
)
;
}
}
template
<
typename
T
>
inline
void
TraceNullableEdge
(
JSTracer
*
trc
WeakHeapPtr
<
T
>
*
thingp
const
char
*
name
)
{
if
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
thingp
-
>
unbarrieredGet
(
)
)
)
{
TraceEdge
(
trc
thingp
name
)
;
}
}
template
<
class
BC
class
T
>
inline
void
TraceNullableCellHeaderEdge
(
JSTracer
*
trc
gc
:
:
CellWithTenuredGCPointer
<
BC
T
>
*
thingp
const
char
*
name
)
{
T
*
thing
=
thingp
-
>
headerPtr
(
)
;
if
(
thing
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
&
thing
)
name
)
;
if
(
thing
!
=
thingp
-
>
headerPtr
(
)
)
{
thingp
-
>
unbarrieredSetHeaderPtr
(
thing
)
;
}
}
}
template
<
typename
T
>
inline
void
TraceRoot
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
gc
:
:
AssertRootMarkingPhase
(
trc
)
;
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
)
name
)
;
}
template
<
typename
T
>
inline
void
TraceRoot
(
JSTracer
*
trc
const
HeapPtr
<
T
>
*
thingp
const
char
*
name
)
{
TraceRoot
(
trc
thingp
-
>
unbarrieredAddress
(
)
name
)
;
}
template
<
typename
T
>
void
TraceBufferRoot
(
JSTracer
*
trc
JS
:
:
Zone
*
zone
T
*
*
bufferp
const
char
*
name
)
{
void
*
*
ptrp
=
reinterpret_cast
<
void
*
*
>
(
bufferp
)
;
gc
:
:
TraceBufferEdgeInternal
(
trc
zone
ptrp
name
)
;
}
template
<
typename
T
>
void
BufferHolder
<
T
>
:
:
trace
(
JSTracer
*
trc
)
{
if
(
buffer
)
{
TraceBufferRoot
(
trc
zone
&
buffer
"
BufferHolder
buffer
"
)
;
JS
:
:
GCPolicy
<
T
>
:
:
trace
(
trc
buffer
"
BufferHolder
data
"
)
;
}
}
template
<
typename
T
>
inline
void
TraceNullableRoot
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
gc
:
:
AssertRootMarkingPhase
(
trc
)
;
if
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
*
thingp
)
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
)
name
)
;
}
}
template
<
typename
T
>
inline
void
TraceNullableRoot
(
JSTracer
*
trc
WeakHeapPtr
<
T
>
*
thingp
const
char
*
name
)
{
TraceNullableRoot
(
trc
thingp
-
>
unbarrieredAddress
(
)
name
)
;
}
template
<
typename
T
>
inline
void
TraceManuallyBarrieredEdge
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
)
name
)
;
}
template
<
typename
T
>
inline
void
TraceManuallyBarrieredNullableEdge
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
if
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
*
thingp
)
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
)
name
)
;
}
}
template
<
typename
T
>
struct
TraceWeakResult
{
const
bool
live_
;
const
T
initial_
;
const
T
final_
;
bool
isLive
(
)
const
{
return
live_
;
}
bool
isDead
(
)
const
{
return
!
live_
;
}
bool
wasMoved
(
)
const
{
return
isLive
(
)
&
&
final_
!
=
initial_
;
}
MOZ_IMPLICIT
operator
bool
(
)
const
{
return
isLive
(
)
;
}
T
initialTarget
(
)
const
{
return
initial_
;
}
T
finalTarget
(
)
const
{
MOZ_ASSERT
(
isLive
(
)
)
;
return
final_
;
}
}
;
template
<
typename
T
>
inline
TraceWeakResult
<
T
>
TraceWeakEdge
(
JSTracer
*
trc
BarrieredBase
<
T
>
*
thingp
const
char
*
name
)
{
T
*
addr
=
thingp
-
>
unbarrieredAddress
(
)
;
T
initial
=
*
addr
;
bool
live
=
!
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
initial
)
|
|
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
addr
)
name
)
;
return
TraceWeakResult
<
T
>
{
live
initial
*
addr
}
;
}
template
<
typename
T
>
inline
TraceWeakResult
<
T
>
TraceManuallyBarrieredWeakEdge
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
T
initial
=
*
thingp
;
bool
live
=
!
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
initial
)
|
|
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
)
name
)
;
return
TraceWeakResult
<
T
>
{
live
initial
*
thingp
}
;
}
template
<
typename
T
>
void
TraceRange
(
JSTracer
*
trc
size_t
len
BarrieredBase
<
T
>
*
vec
const
char
*
name
)
{
gc
:
:
TraceRangeInternal
(
trc
len
gc
:
:
ConvertToBase
(
vec
[
0
]
.
unbarrieredAddress
(
)
)
name
)
;
}
template
<
typename
T
>
void
TraceRootRange
(
JSTracer
*
trc
size_t
len
T
*
vec
const
char
*
name
)
{
gc
:
:
AssertRootMarkingPhase
(
trc
)
;
gc
:
:
TraceRangeInternal
(
trc
len
gc
:
:
ConvertToBase
(
vec
)
name
)
;
}
template
<
typename
T
>
void
TraceBufferEdge
(
JSTracer
*
trc
gc
:
:
Cell
*
owner
T
*
*
bufferp
const
char
*
name
)
{
void
*
*
ptrp
=
reinterpret_cast
<
void
*
*
>
(
bufferp
)
;
gc
:
:
TraceBufferEdgeInternal
(
trc
owner
ptrp
name
)
;
}
template
<
typename
T
>
void
TraceManuallyBarrieredCrossCompartmentEdge
(
JSTracer
*
trc
JSObject
*
src
T
*
dst
const
char
*
name
)
;
template
<
typename
T
>
void
TraceCrossCompartmentEdge
(
JSTracer
*
trc
JSObject
*
src
const
WriteBarriered
<
T
>
*
dst
const
char
*
name
)
{
TraceManuallyBarrieredCrossCompartmentEdge
(
trc
src
gc
:
:
ConvertToBase
(
dst
-
>
unbarrieredAddress
(
)
)
name
)
;
}
template
<
typename
T
>
void
TraceSameZoneCrossCompartmentEdge
(
JSTracer
*
trc
const
BarrieredBase
<
T
>
*
dst
const
char
*
name
)
;
template
<
typename
T
>
void
TraceWeakMapKeyEdgeInternal
(
JSTracer
*
trc
Zone
*
weakMapZone
T
*
*
thingp
const
char
*
name
)
;
template
<
typename
T
>
void
TraceWeakMapKeyEdgeInternal
(
JSTracer
*
trc
Zone
*
weakMapZone
T
*
thingp
const
char
*
name
)
;
template
<
typename
T
>
inline
void
TraceWeakMapKeyEdge
(
JSTracer
*
trc
Zone
*
weakMapZone
const
WriteBarriered
<
T
>
*
thingp
const
char
*
name
)
{
TraceWeakMapKeyEdgeInternal
(
trc
weakMapZone
gc
:
:
ConvertToBase
(
thingp
-
>
unbarrieredAddress
(
)
)
name
)
;
}
void
TraceGenericPointerRoot
(
JSTracer
*
trc
gc
:
:
Cell
*
*
thingp
const
char
*
name
)
;
void
TraceManuallyBarrieredGenericPointerEdge
(
JSTracer
*
trc
gc
:
:
Cell
*
*
thingp
const
char
*
name
)
;
void
TraceGCCellPtrRoot
(
JSTracer
*
trc
JS
:
:
GCCellPtr
*
thingp
const
char
*
name
)
;
void
TraceManuallyBarrieredGCCellPtr
(
JSTracer
*
trc
JS
:
:
GCCellPtr
*
thingp
const
char
*
name
)
;
namespace
gc
{
void
TraceCycleCollectorChildren
(
JS
:
:
CallbackTracer
*
trc
Shape
*
shape
)
;
void
TraceIncomingCCWs
(
JSTracer
*
trc
const
JS
:
:
CompartmentSet
&
compartments
)
;
void
GetTraceThingInfo
(
char
*
buf
size_t
bufsize
void
*
thing
JS
:
:
TraceKind
kind
bool
includeDetails
)
;
#
define
DEFINE_DISPATCH_FUNCTION
(
name
type
_1
_2
)
\
inline
void
DispatchToOnEdge
(
JSTracer
*
trc
type
*
*
thingp
\
const
char
*
name
)
{
\
trc
-
>
on
#
#
name
#
#
Edge
(
thingp
name
)
;
\
}
JS_FOR_EACH_TRACEKIND
(
DEFINE_DISPATCH_FUNCTION
)
#
undef
DEFINE_DISPATCH_FUNCTION
}
}
#
endif
