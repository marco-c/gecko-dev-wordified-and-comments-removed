#
ifndef
js_Tracer_h
#
define
js_Tracer_h
#
include
"
gc
/
Barrier
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
namespace
JS
{
using
CompartmentSet
=
js
:
:
HashSet
<
Compartment
*
js
:
:
DefaultHasher
<
Compartment
*
>
js
:
:
SystemAllocPolicy
>
;
}
namespace
js
{
namespace
gc
{
template
<
typename
T
>
struct
PtrBaseGCType
{
using
type
=
T
;
}
;
template
<
typename
T
>
struct
PtrBaseGCType
<
T
*
>
{
using
type
=
typename
BaseGCType
<
T
>
:
:
type
*
;
}
;
template
<
typename
T
>
typename
PtrBaseGCType
<
T
>
:
:
type
*
ConvertToBase
(
T
*
thingp
)
{
return
reinterpret_cast
<
typename
PtrBaseGCType
<
T
>
:
:
type
*
>
(
thingp
)
;
}
template
<
typename
T
>
bool
TraceEdgeInternal
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
;
template
<
typename
T
>
void
TraceRangeInternal
(
JSTracer
*
trc
size_t
len
T
*
vec
const
char
*
name
)
;
template
<
typename
T
>
bool
TraceWeakMapKeyInternal
(
JSTracer
*
trc
Zone
*
zone
T
*
thingp
const
char
*
name
)
;
#
ifdef
DEBUG
void
AssertRootMarkingPhase
(
JSTracer
*
trc
)
;
#
else
inline
void
AssertRootMarkingPhase
(
JSTracer
*
trc
)
{
}
#
endif
}
template
<
typename
T
>
inline
void
TraceEdge
(
JSTracer
*
trc
const
WriteBarriered
<
T
>
*
thingp
const
char
*
name
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
-
>
unbarrieredAddress
(
)
)
name
)
;
}
template
<
typename
T
>
inline
void
TraceEdge
(
JSTracer
*
trc
WeakHeapPtr
<
T
>
*
thingp
const
char
*
name
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
-
>
unbarrieredAddress
(
)
)
name
)
;
}
template
<
class
BC
class
T
>
inline
void
TraceCellHeaderEdge
(
JSTracer
*
trc
gc
:
:
CellWithTenuredGCPointer
<
BC
T
>
*
thingp
const
char
*
name
)
{
T
*
thing
=
thingp
-
>
headerPtr
(
)
;
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
&
thing
)
name
)
;
if
(
thing
!
=
thingp
-
>
headerPtr
(
)
)
{
thingp
-
>
unbarrieredSetHeaderPtr
(
thing
)
;
}
}
template
<
typename
T
>
inline
void
TraceNullableEdge
(
JSTracer
*
trc
const
WriteBarriered
<
T
>
*
thingp
const
char
*
name
)
{
if
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
thingp
-
>
get
(
)
)
)
{
TraceEdge
(
trc
thingp
name
)
;
}
}
template
<
typename
T
>
inline
void
TraceNullableEdge
(
JSTracer
*
trc
WeakHeapPtr
<
T
>
*
thingp
const
char
*
name
)
{
if
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
thingp
-
>
unbarrieredGet
(
)
)
)
{
TraceEdge
(
trc
thingp
name
)
;
}
}
template
<
class
BC
class
T
>
inline
void
TraceNullableCellHeaderEdge
(
JSTracer
*
trc
gc
:
:
CellWithTenuredGCPointer
<
BC
T
>
*
thingp
const
char
*
name
)
{
T
*
thing
=
thingp
-
>
headerPtr
(
)
;
if
(
thing
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
&
thing
)
name
)
;
if
(
thing
!
=
thingp
-
>
headerPtr
(
)
)
{
thingp
-
>
unbarrieredSetHeaderPtr
(
thing
)
;
}
}
}
template
<
typename
T
>
inline
void
TraceRoot
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
gc
:
:
AssertRootMarkingPhase
(
trc
)
;
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
)
name
)
;
}
template
<
typename
T
>
inline
void
TraceRoot
(
JSTracer
*
trc
const
HeapPtr
<
T
>
*
thingp
const
char
*
name
)
{
TraceRoot
(
trc
thingp
-
>
unbarrieredAddress
(
)
name
)
;
}
template
<
typename
T
>
inline
void
TraceNullableRoot
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
gc
:
:
AssertRootMarkingPhase
(
trc
)
;
if
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
*
thingp
)
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
)
name
)
;
}
}
template
<
typename
T
>
inline
void
TraceNullableRoot
(
JSTracer
*
trc
WeakHeapPtr
<
T
>
*
thingp
const
char
*
name
)
{
TraceNullableRoot
(
trc
thingp
-
>
unbarrieredAddress
(
)
name
)
;
}
template
<
typename
T
>
inline
void
TraceManuallyBarrieredEdge
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
)
name
)
;
}
template
<
typename
T
>
inline
bool
TraceManuallyBarrieredWeakEdge
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
return
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
)
name
)
;
}
template
<
typename
T
>
inline
bool
TraceWeakEdge
(
JSTracer
*
trc
BarrieredBase
<
T
>
*
thingp
const
char
*
name
)
{
return
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
-
>
unbarrieredAddress
(
)
)
name
)
;
}
template
<
typename
T
>
void
TraceRange
(
JSTracer
*
trc
size_t
len
BarrieredBase
<
T
>
*
vec
const
char
*
name
)
{
gc
:
:
TraceRangeInternal
(
trc
len
gc
:
:
ConvertToBase
(
vec
[
0
]
.
unbarrieredAddress
(
)
)
name
)
;
}
template
<
typename
T
>
void
TraceRootRange
(
JSTracer
*
trc
size_t
len
T
*
vec
const
char
*
name
)
{
gc
:
:
AssertRootMarkingPhase
(
trc
)
;
gc
:
:
TraceRangeInternal
(
trc
len
gc
:
:
ConvertToBase
(
vec
)
name
)
;
}
template
<
typename
T
>
void
TraceManuallyBarrieredCrossCompartmentEdge
(
JSTracer
*
trc
JSObject
*
src
T
*
dst
const
char
*
name
)
;
template
<
typename
T
>
void
TraceCrossCompartmentEdge
(
JSTracer
*
trc
JSObject
*
src
const
WriteBarriered
<
T
>
*
dst
const
char
*
name
)
{
TraceManuallyBarrieredCrossCompartmentEdge
(
trc
src
gc
:
:
ConvertToBase
(
dst
-
>
unbarrieredAddress
(
)
)
name
)
;
}
template
<
typename
T
>
void
TraceSameZoneCrossCompartmentEdge
(
JSTracer
*
trc
const
WriteBarriered
<
T
>
*
dst
const
char
*
name
)
;
template
<
typename
T
>
void
TraceWeakMapKeyEdgeInternal
(
JSTracer
*
trc
Zone
*
weakMapZone
T
*
*
thingp
const
char
*
name
)
;
template
<
typename
T
>
inline
void
TraceWeakMapKeyEdge
(
JSTracer
*
trc
Zone
*
weakMapZone
const
WriteBarriered
<
T
>
*
thingp
const
char
*
name
)
{
TraceWeakMapKeyEdgeInternal
(
trc
weakMapZone
gc
:
:
ConvertToBase
(
thingp
-
>
unbarrieredAddress
(
)
)
name
)
;
}
template
<
typename
T
>
void
TraceProcessGlobalRoot
(
JSTracer
*
trc
T
*
thing
const
char
*
name
)
;
void
TraceGenericPointerRoot
(
JSTracer
*
trc
gc
:
:
Cell
*
*
thingp
const
char
*
name
)
;
void
TraceManuallyBarrieredGenericPointerEdge
(
JSTracer
*
trc
gc
:
:
Cell
*
*
thingp
const
char
*
name
)
;
void
TraceGCCellPtrRoot
(
JSTracer
*
trc
JS
:
:
GCCellPtr
*
thingp
const
char
*
name
)
;
namespace
gc
{
void
TraceCycleCollectorChildren
(
JS
:
:
CallbackTracer
*
trc
Shape
*
shape
)
;
void
TraceCycleCollectorChildren
(
JS
:
:
CallbackTracer
*
trc
ObjectGroup
*
group
)
;
void
TraceIncomingCCWs
(
JSTracer
*
trc
const
JS
:
:
CompartmentSet
&
compartments
)
;
void
GetTraceThingInfo
(
char
*
buf
size_t
bufsize
void
*
thing
JS
:
:
TraceKind
kind
bool
includeDetails
)
;
inline
JSObject
*
DispatchToOnEdge
(
GenericTracer
*
trc
JSObject
*
obj
)
{
return
trc
-
>
onObjectEdge
(
obj
)
;
}
inline
JSString
*
DispatchToOnEdge
(
GenericTracer
*
trc
JSString
*
str
)
{
return
trc
-
>
onStringEdge
(
str
)
;
}
inline
JS
:
:
Symbol
*
DispatchToOnEdge
(
GenericTracer
*
trc
JS
:
:
Symbol
*
sym
)
{
return
trc
-
>
onSymbolEdge
(
sym
)
;
}
inline
JS
:
:
BigInt
*
DispatchToOnEdge
(
GenericTracer
*
trc
JS
:
:
BigInt
*
bi
)
{
return
trc
-
>
onBigIntEdge
(
bi
)
;
}
inline
js
:
:
BaseScript
*
DispatchToOnEdge
(
GenericTracer
*
trc
js
:
:
BaseScript
*
script
)
{
return
trc
-
>
onScriptEdge
(
script
)
;
}
inline
js
:
:
Shape
*
DispatchToOnEdge
(
GenericTracer
*
trc
js
:
:
Shape
*
shape
)
{
return
trc
-
>
onShapeEdge
(
shape
)
;
}
inline
js
:
:
ObjectGroup
*
DispatchToOnEdge
(
GenericTracer
*
trc
js
:
:
ObjectGroup
*
group
)
{
return
trc
-
>
onObjectGroupEdge
(
group
)
;
}
inline
js
:
:
BaseShape
*
DispatchToOnEdge
(
GenericTracer
*
trc
js
:
:
BaseShape
*
base
)
{
return
trc
-
>
onBaseShapeEdge
(
base
)
;
}
inline
js
:
:
jit
:
:
JitCode
*
DispatchToOnEdge
(
GenericTracer
*
trc
js
:
:
jit
:
:
JitCode
*
code
)
{
return
trc
-
>
onJitCodeEdge
(
code
)
;
}
inline
js
:
:
Scope
*
DispatchToOnEdge
(
GenericTracer
*
trc
js
:
:
Scope
*
scope
)
{
return
trc
-
>
onScopeEdge
(
scope
)
;
}
inline
js
:
:
RegExpShared
*
DispatchToOnEdge
(
GenericTracer
*
trc
js
:
:
RegExpShared
*
shared
)
{
return
trc
-
>
onRegExpSharedEdge
(
shared
)
;
}
}
}
#
endif
