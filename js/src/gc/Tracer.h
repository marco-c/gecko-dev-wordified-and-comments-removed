#
ifndef
js_Tracer_h
#
define
js_Tracer_h
#
include
"
jsfriendapi
.
h
"
#
include
"
gc
/
Barrier
.
h
"
namespace
js
{
namespace
gc
{
template
<
JS
:
:
TraceKind
kind
>
struct
MapTraceKindToType
{
}
;
#
define
DEFINE_TRACE_KIND_MAP
(
name
type
_
_1
)
\
template
<
>
\
struct
MapTraceKindToType
<
JS
:
:
TraceKind
:
:
name
>
{
\
using
Type
=
type
;
\
}
;
JS_FOR_EACH_TRACEKIND
(
DEFINE_TRACE_KIND_MAP
)
;
#
undef
DEFINE_TRACE_KIND_MAP
template
<
typename
T
>
struct
BaseGCType
{
using
type
=
typename
MapTraceKindToType
<
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
>
:
:
Type
;
static_assert
(
mozilla
:
:
IsBaseOf
<
type
T
>
:
:
value
"
Failed
to
find
base
type
"
)
;
}
;
template
<
typename
T
>
struct
PtrBaseGCType
{
using
type
=
T
;
}
;
template
<
typename
T
>
struct
PtrBaseGCType
<
T
*
>
{
using
type
=
typename
BaseGCType
<
T
>
:
:
type
*
;
}
;
template
<
typename
T
>
typename
PtrBaseGCType
<
T
>
:
:
type
*
ConvertToBase
(
T
*
thingp
)
{
return
reinterpret_cast
<
typename
PtrBaseGCType
<
T
>
:
:
type
*
>
(
thingp
)
;
}
template
<
typename
T
>
bool
TraceEdgeInternal
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
;
template
<
typename
T
>
void
TraceRangeInternal
(
JSTracer
*
trc
size_t
len
T
*
vec
const
char
*
name
)
;
template
<
typename
T
>
bool
TraceWeakMapKeyInternal
(
JSTracer
*
trc
Zone
*
zone
T
*
thingp
const
char
*
name
)
;
#
ifdef
DEBUG
void
AssertRootMarkingPhase
(
JSTracer
*
trc
)
;
#
else
inline
void
AssertRootMarkingPhase
(
JSTracer
*
trc
)
{
}
#
endif
}
template
<
typename
T
>
inline
void
TraceEdge
(
JSTracer
*
trc
const
WriteBarriered
<
T
>
*
thingp
const
char
*
name
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
-
>
unsafeUnbarrieredForTracing
(
)
)
name
)
;
}
template
<
typename
T
>
inline
void
TraceEdge
(
JSTracer
*
trc
WeakHeapPtr
<
T
>
*
thingp
const
char
*
name
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
-
>
unsafeGet
(
)
)
name
)
;
}
template
<
typename
T
>
inline
void
TraceNullableEdge
(
JSTracer
*
trc
const
WriteBarriered
<
T
>
*
thingp
const
char
*
name
)
{
if
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
thingp
-
>
get
(
)
)
)
{
TraceEdge
(
trc
thingp
name
)
;
}
}
template
<
typename
T
>
inline
void
TraceNullableEdge
(
JSTracer
*
trc
WeakHeapPtr
<
T
>
*
thingp
const
char
*
name
)
{
if
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
thingp
-
>
unbarrieredGet
(
)
)
)
{
TraceEdge
(
trc
thingp
name
)
;
}
}
template
<
typename
T
>
inline
void
TraceRoot
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
gc
:
:
AssertRootMarkingPhase
(
trc
)
;
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
)
name
)
;
}
template
<
typename
T
>
inline
void
TraceRoot
(
JSTracer
*
trc
WeakHeapPtr
<
T
>
*
thingp
const
char
*
name
)
{
TraceRoot
(
trc
thingp
-
>
unsafeGet
(
)
name
)
;
}
template
<
typename
T
>
inline
void
TraceNullableRoot
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
gc
:
:
AssertRootMarkingPhase
(
trc
)
;
if
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
*
thingp
)
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
)
name
)
;
}
}
template
<
typename
T
>
inline
void
TraceNullableRoot
(
JSTracer
*
trc
WeakHeapPtr
<
T
>
*
thingp
const
char
*
name
)
{
TraceNullableRoot
(
trc
thingp
-
>
unsafeGet
(
)
name
)
;
}
template
<
typename
T
>
inline
void
TraceManuallyBarrieredEdge
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
)
name
)
;
}
template
<
typename
T
>
inline
bool
TraceManuallyBarrieredWeakEdge
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
return
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
)
name
)
;
}
template
<
typename
T
>
inline
bool
TraceWeakEdge
(
JSTracer
*
trc
BarrieredBase
<
T
>
*
thingp
const
char
*
name
)
{
return
gc
:
:
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
-
>
unsafeUnbarrieredForTracing
(
)
)
name
)
;
}
template
<
typename
T
>
void
TraceRange
(
JSTracer
*
trc
size_t
len
WriteBarriered
<
T
>
*
vec
const
char
*
name
)
{
gc
:
:
TraceRangeInternal
(
trc
len
gc
:
:
ConvertToBase
(
vec
[
0
]
.
unsafeUnbarrieredForTracing
(
)
)
name
)
;
}
template
<
typename
T
>
void
TraceRootRange
(
JSTracer
*
trc
size_t
len
T
*
vec
const
char
*
name
)
{
gc
:
:
AssertRootMarkingPhase
(
trc
)
;
gc
:
:
TraceRangeInternal
(
trc
len
gc
:
:
ConvertToBase
(
vec
)
name
)
;
}
template
<
typename
T
>
void
TraceManuallyBarrieredCrossCompartmentEdge
(
JSTracer
*
trc
JSObject
*
src
T
*
dst
const
char
*
name
)
;
template
<
typename
T
>
void
TraceCrossCompartmentEdge
(
JSTracer
*
trc
JSObject
*
src
const
WriteBarriered
<
T
>
*
dst
const
char
*
name
)
{
TraceManuallyBarrieredCrossCompartmentEdge
(
trc
src
gc
:
:
ConvertToBase
(
dst
-
>
unsafeUnbarrieredForTracing
(
)
)
name
)
;
}
template
<
typename
T
>
void
TraceWeakMapKeyEdgeInternal
(
JSTracer
*
trc
Zone
*
weakMapZone
T
*
*
thingp
const
char
*
name
)
;
template
<
typename
T
>
inline
void
TraceWeakMapKeyEdge
(
JSTracer
*
trc
Zone
*
weakMapZone
const
WriteBarriered
<
T
>
*
thingp
const
char
*
name
)
{
TraceWeakMapKeyEdgeInternal
(
trc
weakMapZone
gc
:
:
ConvertToBase
(
thingp
-
>
unsafeUnbarrieredForTracing
(
)
)
name
)
;
}
template
<
typename
T
>
void
TraceProcessGlobalRoot
(
JSTracer
*
trc
T
*
thing
const
char
*
name
)
;
void
TraceGenericPointerRoot
(
JSTracer
*
trc
gc
:
:
Cell
*
*
thingp
const
char
*
name
)
;
void
TraceManuallyBarrieredGenericPointerEdge
(
JSTracer
*
trc
gc
:
:
Cell
*
*
thingp
const
char
*
name
)
;
void
TraceGCCellPtrRoot
(
JSTracer
*
trc
JS
:
:
GCCellPtr
*
thingp
const
char
*
name
)
;
void
TraceChildren
(
JSTracer
*
trc
void
*
thing
JS
:
:
TraceKind
kind
)
;
namespace
gc
{
void
TraceCycleCollectorChildren
(
JS
:
:
CallbackTracer
*
trc
Shape
*
shape
)
;
void
TraceCycleCollectorChildren
(
JS
:
:
CallbackTracer
*
trc
ObjectGroup
*
group
)
;
}
}
#
endif
