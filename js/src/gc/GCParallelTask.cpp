#
include
"
gc
/
GCParallelTask
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
gc
/
ParallelWork
.
h
"
#
include
"
vm
/
HelperThreads
.
h
"
#
include
"
vm
/
Runtime
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
mozilla
:
:
TimeDuration
;
using
mozilla
:
:
TimeStamp
;
js
:
:
GCParallelTask
:
:
~
GCParallelTask
(
)
{
assertIdle
(
)
;
}
void
js
:
:
GCParallelTask
:
:
startWithLockHeld
(
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
CanUseExtraThreads
(
)
)
;
MOZ_ASSERT
(
!
HelperThreadState
(
)
.
threads
(
lock
)
.
empty
(
)
)
;
assertIdle
(
)
;
HelperThreadState
(
)
.
gcParallelWorklist
(
lock
)
.
insertBack
(
this
)
;
setDispatched
(
lock
)
;
HelperThreadState
(
)
.
notifyOne
(
GlobalHelperThreadState
:
:
PRODUCER
lock
)
;
}
void
js
:
:
GCParallelTask
:
:
start
(
)
{
AutoLockHelperThreadState
lock
;
startWithLockHeld
(
lock
)
;
}
void
js
:
:
GCParallelTask
:
:
startOrRunIfIdle
(
AutoLockHelperThreadState
&
lock
)
{
if
(
wasStarted
(
lock
)
)
{
return
;
}
joinWithLockHeld
(
lock
)
;
if
(
!
CanUseExtraThreads
(
)
)
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
runFromMainThread
(
)
;
return
;
}
startWithLockHeld
(
lock
)
;
}
void
js
:
:
GCParallelTask
:
:
join
(
)
{
AutoLockHelperThreadState
lock
;
joinWithLockHeld
(
lock
)
;
}
void
js
:
:
GCParallelTask
:
:
joinWithLockHeld
(
AutoLockHelperThreadState
&
lock
)
{
if
(
isIdle
(
lock
)
)
{
return
;
}
if
(
isDispatched
(
lock
)
)
{
cancelDispatchedTask
(
lock
)
;
AutoUnlockHelperThreadState
unlock
(
lock
)
;
runFromMainThread
(
)
;
return
;
}
joinRunningOrFinishedTask
(
lock
)
;
}
void
js
:
:
GCParallelTask
:
:
joinRunningOrFinishedTask
(
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
isRunning
(
lock
)
|
|
isFinishing
(
lock
)
|
|
isFinished
(
lock
)
)
;
while
(
!
isFinished
(
lock
)
)
{
HelperThreadState
(
)
.
wait
(
lock
GlobalHelperThreadState
:
:
CONSUMER
)
;
}
setIdle
(
lock
)
;
cancel_
=
false
;
}
void
js
:
:
GCParallelTask
:
:
cancelDispatchedTask
(
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
isDispatched
(
lock
)
)
;
MOZ_ASSERT
(
isInList
(
)
)
;
remove
(
)
;
setIdle
(
lock
)
;
}
static
inline
TimeDuration
TimeSince
(
TimeStamp
prev
)
{
TimeStamp
now
=
ReallyNow
(
)
;
MOZ_ASSERT
(
now
>
=
prev
)
;
if
(
now
<
prev
)
{
now
=
prev
;
}
return
now
-
prev
;
}
void
js
:
:
GCParallelTask
:
:
runFromMainThread
(
)
{
assertIdle
(
)
;
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessRuntime
(
gc
-
>
rt
)
)
;
runTask
(
)
;
}
void
js
:
:
GCParallelTask
:
:
runFromHelperThread
(
AutoLockHelperThreadState
&
lock
)
{
setRunning
(
lock
)
;
{
AutoUnlockHelperThreadState
parallelSection
(
lock
)
;
AutoSetHelperThreadContext
usesContext
;
AutoSetContextRuntime
ascr
(
gc
-
>
rt
)
;
gc
:
:
AutoSetThreadIsPerformingGC
performingGC
;
runTask
(
)
;
}
setFinished
(
lock
)
;
HelperThreadState
(
)
.
notifyAll
(
GlobalHelperThreadState
:
:
CONSUMER
lock
)
;
}
void
GCParallelTask
:
:
runTask
(
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
TimeStamp
timeStart
=
ReallyNow
(
)
;
run
(
)
;
duration_
=
TimeSince
(
timeStart
)
;
}
bool
js
:
:
GCParallelTask
:
:
isIdle
(
)
const
{
AutoLockHelperThreadState
lock
;
return
isIdle
(
lock
)
;
}
bool
js
:
:
GCParallelTask
:
:
wasStarted
(
)
const
{
AutoLockHelperThreadState
lock
;
return
wasStarted
(
lock
)
;
}
size_t
js
:
:
gc
:
:
GCRuntime
:
:
parallelWorkerCount
(
)
const
{
return
std
:
:
min
(
helperThreadCount
.
ref
(
)
MaxParallelWorkers
)
;
}
