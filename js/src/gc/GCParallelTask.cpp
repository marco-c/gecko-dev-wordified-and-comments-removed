#
include
"
gc
/
GCParallelTask
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
gc
/
GCContext
.
h
"
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
gc
/
ParallelWork
.
h
"
#
include
"
vm
/
HelperThreadState
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
Time
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
TimeDuration
;
using
mozilla
:
:
TimeStamp
;
js
:
:
GCParallelTask
:
:
~
GCParallelTask
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
isInList
(
)
)
;
assertIdle
(
)
;
}
void
js
:
:
GCParallelTask
:
:
startWithLockHeld
(
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
CanUseExtraThreads
(
)
)
;
MOZ_ASSERT
(
HelperThreadState
(
)
.
isInitialized
(
lock
)
)
;
assertIdle
(
)
;
setDispatched
(
lock
)
;
HelperThreadState
(
)
.
submitTask
(
this
lock
)
;
}
void
js
:
:
GCParallelTask
:
:
start
(
)
{
if
(
!
CanUseExtraThreads
(
)
)
{
runFromMainThread
(
)
;
return
;
}
AutoLockHelperThreadState
lock
;
startWithLockHeld
(
lock
)
;
}
void
js
:
:
GCParallelTask
:
:
startOrRunIfIdle
(
AutoLockHelperThreadState
&
lock
)
{
if
(
wasStarted
(
lock
)
)
{
return
;
}
joinWithLockHeld
(
lock
)
;
if
(
!
CanUseExtraThreads
(
)
)
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
runFromMainThread
(
)
;
return
;
}
startWithLockHeld
(
lock
)
;
}
void
js
:
:
GCParallelTask
:
:
cancelAndWait
(
)
{
MOZ_ASSERT
(
!
isCancelled
(
)
)
;
cancel_
=
true
;
join
(
)
;
cancel_
=
false
;
}
void
js
:
:
GCParallelTask
:
:
join
(
Maybe
<
TimeStamp
>
deadline
)
{
AutoLockHelperThreadState
lock
;
joinWithLockHeld
(
lock
deadline
)
;
}
void
js
:
:
GCParallelTask
:
:
joinWithLockHeld
(
AutoLockHelperThreadState
&
lock
Maybe
<
TimeStamp
>
deadline
)
{
if
(
isIdle
(
lock
)
)
{
return
;
}
if
(
isDispatched
(
lock
)
&
&
deadline
.
isNothing
(
)
)
{
cancelDispatchedTask
(
lock
)
;
AutoUnlockHelperThreadState
unlock
(
lock
)
;
runFromMainThread
(
)
;
}
else
{
joinNonIdleTask
(
deadline
lock
)
;
}
if
(
isIdle
(
lock
)
)
{
if
(
phaseKind
!
=
gcstats
:
:
PhaseKind
:
:
NONE
)
{
gc
-
>
stats
(
)
.
recordParallelPhase
(
phaseKind
duration
(
)
)
;
}
}
}
void
js
:
:
GCParallelTask
:
:
joinNonIdleTask
(
Maybe
<
TimeStamp
>
deadline
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
!
isIdle
(
lock
)
)
;
while
(
!
isFinished
(
lock
)
)
{
TimeDuration
timeout
=
TimeDuration
:
:
Forever
(
)
;
if
(
deadline
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
*
deadline
<
=
now
)
{
break
;
}
timeout
=
*
deadline
-
now
;
}
HelperThreadState
(
)
.
wait
(
lock
timeout
)
;
}
if
(
isFinished
(
lock
)
)
{
setIdle
(
lock
)
;
}
}
void
js
:
:
GCParallelTask
:
:
cancelDispatchedTask
(
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
isDispatched
(
lock
)
)
;
MOZ_ASSERT
(
isInList
(
)
)
;
remove
(
)
;
setIdle
(
lock
)
;
}
static
inline
TimeDuration
TimeSince
(
TimeStamp
prev
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
MOZ_ASSERT
(
now
>
=
prev
)
;
if
(
now
<
prev
)
{
now
=
prev
;
}
return
now
-
prev
;
}
void
js
:
:
GCParallelTask
:
:
runFromMainThread
(
)
{
assertIdle
(
)
;
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessRuntime
(
gc
-
>
rt
)
)
;
AutoLockHelperThreadState
lock
;
state_
=
State
:
:
Running
;
runTask
(
gc
-
>
rt
-
>
gcContext
(
)
lock
)
;
state_
=
State
:
:
Idle
;
}
class
MOZ_RAII
AutoGCContext
{
JS
:
:
GCContext
context
;
public
:
explicit
AutoGCContext
(
JSRuntime
*
runtime
)
:
context
(
runtime
)
{
MOZ_RELEASE_ASSERT
(
TlsGCContext
.
init
(
)
"
Failed
to
initialize
TLS
for
GC
context
"
)
;
MOZ_ASSERT
(
!
TlsGCContext
.
get
(
)
)
;
TlsGCContext
.
set
(
&
context
)
;
}
~
AutoGCContext
(
)
{
MOZ_ASSERT
(
TlsGCContext
.
get
(
)
=
=
&
context
)
;
TlsGCContext
.
set
(
nullptr
)
;
}
JS
:
:
GCContext
*
get
(
)
{
return
&
context
;
}
}
;
void
js
:
:
GCParallelTask
:
:
runHelperThreadTask
(
AutoLockHelperThreadState
&
lock
)
{
setRunning
(
lock
)
;
AutoGCContext
gcContext
(
gc
-
>
rt
)
;
runTask
(
gcContext
.
get
(
)
lock
)
;
setFinished
(
lock
)
;
}
void
GCParallelTask
:
:
runTask
(
JS
:
:
GCContext
*
gcx
AutoLockHelperThreadState
&
lock
)
{
AutoSetThreadGCUse
setUse
(
gcx
use
)
;
JS
:
:
AutoSuppressGCAnalysis
nogc
;
TimeStamp
timeStart
=
TimeStamp
:
:
Now
(
)
;
run
(
lock
)
;
duration_
=
TimeSince
(
timeStart
)
;
}
bool
js
:
:
GCParallelTask
:
:
isIdle
(
)
const
{
AutoLockHelperThreadState
lock
;
return
isIdle
(
lock
)
;
}
bool
js
:
:
GCParallelTask
:
:
wasStarted
(
)
const
{
AutoLockHelperThreadState
lock
;
return
wasStarted
(
lock
)
;
}
size_t
js
:
:
gc
:
:
GCRuntime
:
:
parallelWorkerCount
(
)
const
{
return
std
:
:
min
(
helperThreadCount
.
ref
(
)
MaxParallelWorkers
)
;
}
