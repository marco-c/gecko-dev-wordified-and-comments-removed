#
include
"
gc
/
GCParallelTask
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
gc
/
GCContext
.
h
"
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
gc
/
ParallelWork
.
h
"
#
include
"
vm
/
HelperThreadState
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
Time
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
TimeDuration
;
using
mozilla
:
:
TimeStamp
;
js
:
:
GCParallelTask
:
:
~
GCParallelTask
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
isInList
(
)
)
;
assertIdle
(
)
;
}
static
bool
ShouldMeasureTaskStartDelay
(
)
{
return
(
rand
(
)
%
100
)
=
=
0
;
}
void
js
:
:
GCParallelTask
:
:
startWithLockHeld
(
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
CanUseExtraThreads
(
)
)
;
MOZ_ASSERT
(
HelperThreadState
(
)
.
isInitialized
(
lock
)
)
;
assertIdle
(
)
;
maybeQueueTime_
=
TimeStamp
(
)
;
if
(
ShouldMeasureTaskStartDelay
(
)
)
{
maybeQueueTime_
=
TimeStamp
:
:
Now
(
)
;
}
gc
-
>
dispatchOrQueueParallelTask
(
this
lock
)
;
}
void
js
:
:
GCParallelTask
:
:
start
(
)
{
if
(
!
CanUseExtraThreads
(
)
)
{
runFromMainThread
(
)
;
return
;
}
AutoLockHelperThreadState
lock
;
startWithLockHeld
(
lock
)
;
}
void
js
:
:
GCParallelTask
:
:
startOrRunIfIdle
(
AutoLockHelperThreadState
&
lock
)
{
if
(
wasStarted
(
lock
)
)
{
return
;
}
joinWithLockHeld
(
lock
)
;
if
(
!
CanUseExtraThreads
(
)
)
{
runFromMainThread
(
lock
)
;
return
;
}
startWithLockHeld
(
lock
)
;
}
void
js
:
:
GCParallelTask
:
:
cancelAndWait
(
)
{
MOZ_ASSERT
(
!
isCancelled
(
)
)
;
cancel_
=
true
;
join
(
)
;
cancel_
=
false
;
}
void
js
:
:
GCParallelTask
:
:
join
(
Maybe
<
TimeStamp
>
deadline
)
{
AutoLockHelperThreadState
lock
;
joinWithLockHeld
(
lock
deadline
)
;
}
void
js
:
:
GCParallelTask
:
:
joinWithLockHeld
(
AutoLockHelperThreadState
&
lock
Maybe
<
TimeStamp
>
deadline
)
{
if
(
isIdle
(
lock
)
)
{
return
;
}
joinNonIdleTask
(
deadline
lock
)
;
if
(
isIdle
(
lock
)
)
{
recordDuration
(
)
;
}
}
void
GCParallelTask
:
:
recordDuration
(
)
{
if
(
phaseKind
!
=
gcstats
:
:
PhaseKind
:
:
NONE
)
{
gc
-
>
stats
(
)
.
recordParallelPhase
(
phaseKind
duration_
)
;
}
}
void
js
:
:
GCParallelTask
:
:
joinNonIdleTask
(
Maybe
<
TimeStamp
>
deadline
AutoLockHelperThreadState
&
lock
)
{
while
(
!
isFinished
(
lock
)
)
{
MOZ_ASSERT
(
!
isIdle
(
lock
)
)
;
TimeDuration
timeout
=
TimeDuration
:
:
Forever
(
)
;
if
(
deadline
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
*
deadline
<
=
now
)
{
break
;
}
timeout
=
*
deadline
-
now
;
}
HelperThreadState
(
)
.
wait
(
lock
timeout
)
;
}
if
(
isFinished
(
lock
)
)
{
setIdle
(
lock
)
;
}
}
void
js
:
:
GCParallelTask
:
:
runFromMainThread
(
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
isIdle
(
lock
)
)
;
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessRuntime
(
gc
-
>
rt
)
)
;
runTask
(
gc
-
>
rt
-
>
gcContext
(
)
lock
)
;
setIdle
(
lock
)
;
}
void
js
:
:
GCParallelTask
:
:
runFromMainThread
(
)
{
AutoLockHelperThreadState
lock
;
runFromMainThread
(
lock
)
;
}
class
MOZ_RAII
AutoGCContext
{
JS
:
:
GCContext
context
;
public
:
explicit
AutoGCContext
(
JSRuntime
*
runtime
)
:
context
(
runtime
)
{
MOZ_RELEASE_ASSERT
(
TlsGCContext
.
init
(
)
"
Failed
to
initialize
TLS
for
GC
context
"
)
;
MOZ_ASSERT
(
!
TlsGCContext
.
get
(
)
)
;
TlsGCContext
.
set
(
&
context
)
;
}
~
AutoGCContext
(
)
{
MOZ_ASSERT
(
TlsGCContext
.
get
(
)
=
=
&
context
)
;
TlsGCContext
.
set
(
nullptr
)
;
}
JS
:
:
GCContext
*
get
(
)
{
return
&
context
;
}
}
;
void
js
:
:
GCParallelTask
:
:
runHelperThreadTask
(
AutoLockHelperThreadState
&
lock
)
{
AutoGCContext
gcContext
(
gc
-
>
rt
)
;
runTask
(
gcContext
.
get
(
)
lock
)
;
MOZ_ASSERT
(
isFinished
(
lock
)
)
;
}
void
GCParallelTask
:
:
runTask
(
JS
:
:
GCContext
*
gcx
AutoLockHelperThreadState
&
lock
)
{
bool
wasDispatched
=
isDispatched
(
lock
)
;
setRunning
(
lock
)
;
AutoSetThreadGCUse
setUse
(
gcx
use
)
;
JS
:
:
AutoSuppressGCAnalysis
nogc
;
TimeStamp
timeStart
=
TimeStamp
:
:
Now
(
)
;
run
(
lock
)
;
duration_
=
TimeSince
(
timeStart
)
;
if
(
maybeQueueTime_
)
{
TimeDuration
delay
=
timeStart
-
maybeQueueTime_
;
gc
-
>
rt
-
>
metrics
(
)
.
GC_TASK_START_DELAY_US
(
delay
)
;
}
setFinished
(
lock
)
;
gc
-
>
onParallelTaskEnd
(
wasDispatched
lock
)
;
}
void
GCRuntime
:
:
dispatchOrQueueParallelTask
(
GCParallelTask
*
task
const
AutoLockHelperThreadState
&
lock
)
{
task
-
>
setQueued
(
lock
)
;
queuedParallelTasks
.
ref
(
)
.
insertBack
(
task
lock
)
;
maybeDispatchParallelTasks
(
lock
)
;
}
void
GCRuntime
:
:
maybeDispatchParallelTasks
(
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
maxParallelThreads
!
=
0
)
;
MOZ_ASSERT
(
dispatchedParallelTasks
<
=
maxParallelThreads
)
;
while
(
dispatchedParallelTasks
<
maxParallelThreads
&
&
!
queuedParallelTasks
.
ref
(
)
.
isEmpty
(
lock
)
)
{
GCParallelTask
*
task
=
queuedParallelTasks
.
ref
(
)
.
popFirst
(
lock
)
;
task
-
>
setDispatched
(
lock
)
;
HelperThreadState
(
)
.
submitTask
(
task
lock
)
;
dispatchedParallelTasks
+
+
;
}
}
void
GCRuntime
:
:
onParallelTaskEnd
(
bool
wasDispatched
const
AutoLockHelperThreadState
&
lock
)
{
if
(
wasDispatched
)
{
MOZ_ASSERT
(
dispatchedParallelTasks
!
=
0
)
;
dispatchedParallelTasks
-
-
;
}
maybeDispatchParallelTasks
(
lock
)
;
}
bool
js
:
:
GCParallelTask
:
:
isIdle
(
)
const
{
AutoLockHelperThreadState
lock
;
return
isIdle
(
lock
)
;
}
bool
js
:
:
GCParallelTask
:
:
wasStarted
(
)
const
{
AutoLockHelperThreadState
lock
;
return
wasStarted
(
lock
)
;
}
size_t
js
:
:
gc
:
:
GCRuntime
:
:
parallelWorkerCount
(
)
const
{
return
std
:
:
min
(
helperThreadCount
.
ref
(
)
MaxParallelWorkers
)
;
}
