#
ifndef
gc_Nursery_inl_h
#
define
gc_Nursery_inl_h
#
include
"
gc
/
Nursery
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
gc
/
RelocationOverlay
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
inline
JSRuntime
*
js
:
:
Nursery
:
:
runtime
(
)
const
{
return
gc
-
>
rt
;
}
template
<
typename
T
>
bool
js
:
:
Nursery
:
:
isInside
(
const
SharedMem
<
T
>
&
p
)
const
{
return
isInside
(
p
.
unwrap
(
)
)
;
}
MOZ_ALWAYS_INLINE
bool
js
:
:
Nursery
:
:
getForwardedPointer
(
js
:
:
gc
:
:
Cell
*
*
ref
)
{
js
:
:
gc
:
:
Cell
*
cell
=
(
*
ref
)
;
MOZ_ASSERT
(
IsInsideNursery
(
cell
)
)
;
if
(
!
cell
-
>
isForwarded
(
)
)
{
return
false
;
}
const
gc
:
:
RelocationOverlay
*
overlay
=
gc
:
:
RelocationOverlay
:
:
fromCell
(
cell
)
;
*
ref
=
overlay
-
>
forwardingAddress
(
)
;
return
true
;
}
inline
void
js
:
:
Nursery
:
:
maybeSetForwardingPointer
(
JSTracer
*
trc
void
*
oldData
void
*
newData
bool
direct
)
{
if
(
trc
-
>
isTenuringTracer
(
)
)
{
setForwardingPointerWhileTenuring
(
oldData
newData
direct
)
;
}
}
inline
void
js
:
:
Nursery
:
:
setForwardingPointerWhileTenuring
(
void
*
oldData
void
*
newData
bool
direct
)
{
if
(
isInside
(
oldData
)
)
{
setForwardingPointer
(
oldData
newData
direct
)
;
}
}
inline
void
js
:
:
Nursery
:
:
setSlotsForwardingPointer
(
HeapSlot
*
oldSlots
HeapSlot
*
newSlots
uint32_t
nslots
)
{
MOZ_ASSERT
(
nslots
>
0
)
;
setDirectForwardingPointer
(
oldSlots
newSlots
)
;
}
inline
void
js
:
:
Nursery
:
:
setElementsForwardingPointer
(
ObjectElements
*
oldHeader
ObjectElements
*
newHeader
uint32_t
capacity
)
{
setForwardingPointer
(
oldHeader
-
>
elements
(
)
newHeader
-
>
elements
(
)
capacity
>
0
)
;
}
inline
void
js
:
:
Nursery
:
:
setForwardingPointer
(
void
*
oldData
void
*
newData
bool
direct
)
{
if
(
direct
)
{
setDirectForwardingPointer
(
oldData
newData
)
;
return
;
}
setIndirectForwardingPointer
(
oldData
newData
)
;
}
inline
void
js
:
:
Nursery
:
:
setDirectForwardingPointer
(
void
*
oldData
void
*
newData
)
{
MOZ_ASSERT
(
isInside
(
oldData
)
)
;
MOZ_ASSERT
(
!
isInside
(
newData
)
)
;
new
(
oldData
)
BufferRelocationOverlay
{
newData
}
;
}
inline
void
*
js
:
:
Nursery
:
:
tryAllocateCell
(
gc
:
:
AllocSite
*
site
size_t
size
JS
:
:
TraceKind
kind
)
{
MOZ_ASSERT
(
size
%
gc
:
:
CellAlignBytes
=
=
0
)
;
MOZ_ASSERT
(
size_t
(
kind
)
<
gc
:
:
NurseryTraceKinds
)
;
MOZ_ASSERT_IF
(
kind
=
=
JS
:
:
TraceKind
:
:
String
canAllocateStrings
(
)
)
;
MOZ_ASSERT_IF
(
kind
=
=
JS
:
:
TraceKind
:
:
BigInt
canAllocateBigInts
(
)
)
;
void
*
ptr
=
tryAllocate
(
sizeof
(
gc
:
:
NurseryCellHeader
)
+
size
)
;
if
(
MOZ_UNLIKELY
(
!
ptr
)
)
{
return
nullptr
;
}
new
(
ptr
)
gc
:
:
NurseryCellHeader
(
site
kind
)
;
void
*
cell
=
reinterpret_cast
<
void
*
>
(
uintptr_t
(
ptr
)
+
sizeof
(
gc
:
:
NurseryCellHeader
)
)
;
if
(
!
cell
)
{
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Successful
allocation
cannot
result
in
nullptr
"
)
;
}
uint32_t
allocCount
=
site
-
>
incAllocCount
(
)
;
if
(
allocCount
=
=
1
)
{
pretenuringNursery
.
insertIntoAllocatedList
(
site
)
;
}
MOZ_ASSERT_IF
(
site
-
>
isNormal
(
)
site
-
>
isInAllocatedList
(
)
)
;
gc
:
:
gcprobes
:
:
NurseryAlloc
(
cell
kind
)
;
return
cell
;
}
inline
void
*
js
:
:
Nursery
:
:
tryAllocate
(
size_t
size
)
{
MOZ_ASSERT
(
isEnabled
(
)
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
MOZ_ASSERT_IF
(
currentChunk_
=
=
startChunk_
position
(
)
>
=
startPosition_
)
;
MOZ_ASSERT
(
size
%
gc
:
:
CellAlignBytes
=
=
0
)
;
MOZ_ASSERT
(
position
(
)
%
gc
:
:
CellAlignBytes
=
=
0
)
;
if
(
MOZ_UNLIKELY
(
currentEnd
(
)
<
position
(
)
+
size
)
)
{
return
nullptr
;
}
void
*
ptr
=
reinterpret_cast
<
void
*
>
(
position
(
)
)
;
if
(
!
ptr
)
{
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Successful
allocation
cannot
result
in
nullptr
"
)
;
}
position_
=
position
(
)
+
size
;
DebugOnlyPoison
(
ptr
JS_ALLOCATED_NURSERY_PATTERN
size
MemCheckKind
:
:
MakeUndefined
)
;
return
ptr
;
}
namespace
js
{
template
<
typename
T
>
static
inline
T
*
AllocateCellBuffer
(
JSContext
*
cx
gc
:
:
Cell
*
cell
uint32_t
count
)
{
size_t
nbytes
=
RoundUp
(
count
*
sizeof
(
T
)
sizeof
(
Value
)
)
;
auto
*
buffer
=
static_cast
<
T
*
>
(
cx
-
>
nursery
(
)
.
allocateBuffer
(
cell
-
>
zone
(
)
cell
nbytes
)
)
;
if
(
!
buffer
)
{
ReportOutOfMemory
(
cx
)
;
}
return
buffer
;
}
template
<
typename
T
>
static
inline
T
*
ReallocateCellBuffer
(
JSContext
*
cx
gc
:
:
Cell
*
cell
T
*
oldBuffer
uint32_t
oldCount
uint32_t
newCount
)
{
size_t
oldBytes
=
RoundUp
(
oldCount
*
sizeof
(
T
)
sizeof
(
Value
)
)
;
size_t
newBytes
=
RoundUp
(
newCount
*
sizeof
(
T
)
sizeof
(
Value
)
)
;
T
*
buffer
=
static_cast
<
T
*
>
(
cx
-
>
nursery
(
)
.
reallocateBuffer
(
cell
-
>
zone
(
)
cell
oldBuffer
oldBytes
newBytes
)
)
;
if
(
!
buffer
)
{
ReportOutOfMemory
(
cx
)
;
}
return
buffer
;
}
}
#
endif
