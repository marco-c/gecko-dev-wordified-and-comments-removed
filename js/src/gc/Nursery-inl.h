#
ifndef
gc_Nursery_inl_h
#
define
gc_Nursery_inl_h
#
include
"
gc
/
Nursery
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
gc
/
RelocationOverlay
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
namespace
gc
{
struct
Cell
;
}
}
inline
JSRuntime
*
js
:
:
Nursery
:
:
runtime
(
)
const
{
return
gc
-
>
rt
;
}
template
<
typename
T
>
bool
js
:
:
Nursery
:
:
isInside
(
const
SharedMem
<
T
>
&
p
)
const
{
return
isInside
(
p
.
unwrap
(
)
)
;
}
inline
bool
js
:
:
Nursery
:
:
shouldTenure
(
gc
:
:
Cell
*
cell
)
{
MOZ_ASSERT
(
semispaceEnabled
(
)
)
;
MOZ_ASSERT
(
inCollectedRegion
(
cell
)
)
;
size_t
offset
=
fromSpace
.
offsetFromAddress
(
uintptr_t
(
cell
)
)
;
MOZ_ASSERT
(
offset
>
=
fromSpace
.
offsetFromExclusiveAddress
(
fromSpace
.
startPosition_
)
)
;
return
offset
<
=
tenureThreshold_
;
}
inline
bool
js
:
:
Nursery
:
:
inCollectedRegion
(
gc
:
:
Cell
*
cell
)
const
{
if
(
!
IsInsideNursery
(
cell
)
)
{
return
false
;
}
if
(
!
semispaceEnabled
(
)
)
{
return
true
;
}
return
fromSpace
.
isInside
(
cell
)
;
}
inline
bool
js
:
:
Nursery
:
:
inCollectedRegion
(
void
*
ptr
)
const
{
if
(
!
semispaceEnabled
(
)
)
{
return
toSpace
.
isInside
(
ptr
)
;
}
return
fromSpace
.
isInside
(
ptr
)
;
}
inline
size_t
js
:
:
Nursery
:
:
Space
:
:
offsetFromExclusiveAddress
(
uintptr_t
addr
)
const
{
if
(
(
addr
&
gc
:
:
ChunkMask
)
=
=
0
)
{
return
offsetFromAddress
(
addr
-
1
)
+
1
;
}
return
offsetFromAddress
(
addr
)
;
}
inline
size_t
js
:
:
Nursery
:
:
Space
:
:
offsetFromAddress
(
uintptr_t
addr
)
const
{
uintptr_t
chunkAddr
=
addr
&
~
gc
:
:
ChunkMask
;
uint32_t
chunkIndex
=
INT32_MAX
;
for
(
size_t
i
=
0
;
i
<
chunks_
.
length
(
)
;
i
+
+
)
{
if
(
uintptr_t
(
chunks_
[
i
]
)
=
=
chunkAddr
)
{
chunkIndex
=
i
;
break
;
}
}
MOZ_ASSERT
(
chunkIndex
<
chunks_
.
length
(
)
"
Nursery
chunk
containing
|
addr
|
not
found
"
)
;
uint32_t
offset
=
addr
&
gc
:
:
ChunkMask
;
MOZ_ASSERT
(
offset
>
=
sizeof
(
gc
:
:
ChunkBase
)
)
;
MOZ_ASSERT
(
offset
<
gc
:
:
ChunkSize
)
;
return
(
chunkIndex
<
<
gc
:
:
ChunkShift
)
|
offset
;
}
MOZ_ALWAYS_INLINE
bool
js
:
:
Nursery
:
:
getForwardedPointer
(
js
:
:
gc
:
:
Cell
*
*
ref
)
{
js
:
:
gc
:
:
Cell
*
cell
=
(
*
ref
)
;
MOZ_ASSERT
(
IsInsideNursery
(
cell
)
)
;
if
(
!
cell
-
>
isForwarded
(
)
)
{
return
false
;
}
const
gc
:
:
RelocationOverlay
*
overlay
=
gc
:
:
RelocationOverlay
:
:
fromCell
(
cell
)
;
*
ref
=
overlay
-
>
forwardingAddress
(
)
;
return
true
;
}
inline
void
js
:
:
Nursery
:
:
maybeSetForwardingPointer
(
JSTracer
*
trc
void
*
oldData
void
*
newData
bool
direct
)
{
if
(
trc
-
>
isTenuringTracer
(
)
)
{
setForwardingPointerWhileTenuring
(
oldData
newData
direct
)
;
}
}
inline
void
js
:
:
Nursery
:
:
setForwardingPointerWhileTenuring
(
void
*
oldData
void
*
newData
bool
direct
)
{
if
(
isInside
(
oldData
)
)
{
setForwardingPointer
(
oldData
newData
direct
)
;
}
}
inline
void
js
:
:
Nursery
:
:
setSlotsForwardingPointer
(
HeapSlot
*
oldSlots
HeapSlot
*
newSlots
uint32_t
nslots
)
{
MOZ_ASSERT
(
nslots
>
0
)
;
setDirectForwardingPointer
(
oldSlots
newSlots
)
;
}
inline
void
js
:
:
Nursery
:
:
setElementsForwardingPointer
(
ObjectElements
*
oldHeader
ObjectElements
*
newHeader
uint32_t
capacity
)
{
setForwardingPointer
(
oldHeader
-
>
elements
(
)
newHeader
-
>
elements
(
)
capacity
>
0
)
;
}
inline
void
js
:
:
Nursery
:
:
setForwardingPointer
(
void
*
oldData
void
*
newData
bool
direct
)
{
if
(
direct
)
{
setDirectForwardingPointer
(
oldData
newData
)
;
return
;
}
setIndirectForwardingPointer
(
oldData
newData
)
;
}
inline
void
js
:
:
Nursery
:
:
setDirectForwardingPointer
(
void
*
oldData
void
*
newData
)
{
MOZ_ASSERT
(
isInside
(
oldData
)
)
;
MOZ_ASSERT_IF
(
isInside
(
newData
)
!
inCollectedRegion
(
newData
)
)
;
new
(
oldData
)
BufferRelocationOverlay
{
newData
}
;
}
inline
void
*
js
:
:
Nursery
:
:
tryAllocateCell
(
gc
:
:
AllocSite
*
site
size_t
size
JS
:
:
TraceKind
kind
)
{
MOZ_ASSERT
(
size
%
gc
:
:
CellAlignBytes
=
=
0
)
;
MOZ_ASSERT
(
size_t
(
kind
)
<
gc
:
:
NurseryTraceKinds
)
;
MOZ_ASSERT_IF
(
kind
=
=
JS
:
:
TraceKind
:
:
String
canAllocateStrings
(
)
)
;
MOZ_ASSERT_IF
(
kind
=
=
JS
:
:
TraceKind
:
:
BigInt
canAllocateBigInts
(
)
)
;
void
*
ptr
=
tryAllocate
(
sizeof
(
gc
:
:
NurseryCellHeader
)
+
size
)
;
if
(
MOZ_UNLIKELY
(
!
ptr
)
)
{
return
nullptr
;
}
new
(
ptr
)
gc
:
:
NurseryCellHeader
(
site
kind
)
;
void
*
cell
=
reinterpret_cast
<
void
*
>
(
uintptr_t
(
ptr
)
+
sizeof
(
gc
:
:
NurseryCellHeader
)
)
;
if
(
!
cell
)
{
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Successful
allocation
cannot
result
in
nullptr
"
)
;
}
uint32_t
allocCount
=
site
-
>
incAllocCount
(
)
;
if
(
allocCount
=
=
1
)
{
pretenuringNursery
.
insertIntoAllocatedList
(
site
)
;
}
MOZ_ASSERT_IF
(
site
-
>
isNormal
(
)
site
-
>
isInAllocatedList
(
)
)
;
gc
:
:
gcprobes
:
:
NurseryAlloc
(
cell
kind
)
;
return
cell
;
}
inline
void
*
js
:
:
Nursery
:
:
tryAllocate
(
size_t
size
)
{
MOZ_ASSERT
(
isEnabled
(
)
)
;
MOZ_ASSERT_IF
(
JS
:
:
RuntimeHeapIsBusy
(
)
JS
:
:
RuntimeHeapIsMinorCollecting
(
)
)
;
MOZ_ASSERT_IF
(
currentChunk
(
)
=
=
startChunk
(
)
position
(
)
>
=
startPosition
(
)
)
;
MOZ_ASSERT
(
size
%
gc
:
:
CellAlignBytes
=
=
0
)
;
MOZ_ASSERT
(
position
(
)
%
gc
:
:
CellAlignBytes
=
=
0
)
;
if
(
MOZ_UNLIKELY
(
currentEnd
(
)
<
position
(
)
+
size
)
)
{
return
nullptr
;
}
void
*
ptr
=
reinterpret_cast
<
void
*
>
(
position
(
)
)
;
if
(
!
ptr
)
{
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Successful
allocation
cannot
result
in
nullptr
"
)
;
}
toSpace
.
position_
=
position
(
)
+
size
;
DebugOnlyPoison
(
ptr
JS_ALLOCATED_NURSERY_PATTERN
size
MemCheckKind
:
:
MakeUndefined
)
;
return
ptr
;
}
inline
bool
js
:
:
Nursery
:
:
registerTrailer
(
PointerAndUint7
blockAndListID
size_t
nBytes
)
{
MOZ_ASSERT
(
toSpace
.
trailersAdded_
.
length
(
)
=
=
toSpace
.
trailersRemoved_
.
length
(
)
)
;
MOZ_ASSERT
(
nBytes
>
0
)
;
if
(
MOZ_UNLIKELY
(
!
toSpace
.
trailersAdded_
.
append
(
blockAndListID
)
)
)
{
return
false
;
}
if
(
MOZ_UNLIKELY
(
!
toSpace
.
trailersRemoved_
.
append
(
nullptr
)
)
)
{
toSpace
.
trailersAdded_
.
popBack
(
)
;
return
false
;
}
toSpace
.
trailerBytes_
+
=
nBytes
;
if
(
MOZ_UNLIKELY
(
toSpace
.
trailerBytes_
>
capacity
(
)
*
8
)
)
{
requestMinorGC
(
JS
:
:
GCReason
:
:
NURSERY_TRAILERS
)
;
}
return
true
;
}
inline
void
js
:
:
Nursery
:
:
unregisterTrailer
(
void
*
block
)
{
MOZ_ASSERT
(
prevSpace
-
>
trailersRemovedUsed_
<
prevSpace
-
>
trailersRemoved_
.
length
(
)
)
;
prevSpace
-
>
trailersRemoved_
[
prevSpace
-
>
trailersRemovedUsed_
]
=
block
;
prevSpace
-
>
trailersRemovedUsed_
+
+
;
}
namespace
js
{
template
<
typename
T
>
static
inline
T
*
AllocateCellBuffer
(
JSContext
*
cx
gc
:
:
Cell
*
cell
uint32_t
count
)
{
size_t
nbytes
=
RoundUp
(
count
*
sizeof
(
T
)
sizeof
(
Value
)
)
;
auto
*
buffer
=
static_cast
<
T
*
>
(
cx
-
>
nursery
(
)
.
allocateBuffer
(
cell
-
>
zone
(
)
cell
nbytes
js
:
:
MallocArena
)
)
;
if
(
!
buffer
)
{
ReportOutOfMemory
(
cx
)
;
}
return
buffer
;
}
template
<
typename
T
>
static
inline
T
*
ReallocateCellBuffer
(
JSContext
*
cx
gc
:
:
Cell
*
cell
T
*
oldBuffer
uint32_t
oldCount
uint32_t
newCount
arena_id_t
arenaId
)
{
size_t
oldBytes
=
RoundUp
(
oldCount
*
sizeof
(
T
)
sizeof
(
Value
)
)
;
size_t
newBytes
=
RoundUp
(
newCount
*
sizeof
(
T
)
sizeof
(
Value
)
)
;
T
*
buffer
=
static_cast
<
T
*
>
(
cx
-
>
nursery
(
)
.
reallocateBuffer
(
cell
-
>
zone
(
)
cell
oldBuffer
oldBytes
newBytes
arenaId
)
)
;
if
(
!
buffer
)
{
ReportOutOfMemory
(
cx
)
;
}
return
buffer
;
}
}
#
endif
