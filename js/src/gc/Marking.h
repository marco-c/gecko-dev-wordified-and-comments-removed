#
ifndef
gc_Marking_h
#
define
gc_Marking_h
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
vm
/
TaggedProto
.
h
"
class
JSLinearString
;
class
JSRope
;
class
JSTracer
;
namespace
js
{
class
BaseShape
;
class
GCMarker
;
class
LazyScript
;
class
NativeObject
;
class
ObjectGroup
;
class
Shape
;
class
WeakMapBase
;
namespace
jit
{
class
JitCode
;
}
#
ifdef
DEBUG
bool
IsBufferGrayRootsTracer
(
JSTracer
*
trc
)
;
bool
IsUnmarkGrayTracer
(
JSTracer
*
trc
)
;
#
endif
namespace
gc
{
class
Arena
;
struct
Cell
;
class
TenuredCell
;
void
PushArena
(
GCMarker
*
gcmarker
Arena
*
arena
)
;
template
<
typename
T
>
bool
IsMarkedInternal
(
JSRuntime
*
rt
T
*
thing
)
;
template
<
typename
T
>
bool
IsMarkedInternal
(
JSRuntime
*
rt
T
*
*
thing
)
;
template
<
typename
T
>
bool
IsAboutToBeFinalizedInternal
(
T
*
thingp
)
;
template
<
typename
T
>
bool
IsAboutToBeFinalizedInternal
(
T
*
*
thingp
)
;
template
<
typename
T
>
inline
bool
IsMarkedUnbarriered
(
JSRuntime
*
rt
T
*
thingp
)
{
return
IsMarkedInternal
(
rt
ConvertToBase
(
thingp
)
)
;
}
template
<
typename
T
>
inline
bool
IsMarked
(
JSRuntime
*
rt
WriteBarrieredBase
<
T
>
*
thingp
)
{
return
IsMarkedInternal
(
rt
ConvertToBase
(
thingp
-
>
unsafeUnbarrieredForTracing
(
)
)
)
;
}
template
<
typename
T
>
inline
bool
IsAboutToBeFinalizedUnbarriered
(
T
*
thingp
)
{
return
IsAboutToBeFinalizedInternal
(
ConvertToBase
(
thingp
)
)
;
}
template
<
typename
T
>
inline
bool
IsAboutToBeFinalized
(
WriteBarrieredBase
<
T
>
*
thingp
)
{
return
IsAboutToBeFinalizedInternal
(
ConvertToBase
(
thingp
-
>
unsafeUnbarrieredForTracing
(
)
)
)
;
}
template
<
typename
T
>
inline
bool
IsAboutToBeFinalized
(
ReadBarrieredBase
<
T
>
*
thingp
)
{
return
IsAboutToBeFinalizedInternal
(
ConvertToBase
(
thingp
-
>
unsafeUnbarrieredForTracing
(
)
)
)
;
}
bool
IsAboutToBeFinalizedDuringSweep
(
TenuredCell
&
tenured
)
;
inline
Cell
*
ToMarkable
(
const
Value
&
v
)
{
if
(
v
.
isGCThing
(
)
)
return
(
Cell
*
)
v
.
toGCThing
(
)
;
return
nullptr
;
}
inline
Cell
*
ToMarkable
(
Cell
*
cell
)
{
return
cell
;
}
template
<
typename
S
typename
T
>
struct
RewrapTaggedPointer
{
}
;
#
define
DECLARE_REWRAP
(
S
T
method
prefix
)
\
template
<
>
struct
RewrapTaggedPointer
<
S
T
>
{
\
static
S
wrap
(
T
*
thing
)
{
return
method
(
prefix
thing
)
;
}
\
}
DECLARE_REWRAP
(
JS
:
:
Value
JSObject
JS
:
:
ObjectOrNullValue
)
;
DECLARE_REWRAP
(
JS
:
:
Value
JSString
JS
:
:
StringValue
)
;
DECLARE_REWRAP
(
JS
:
:
Value
JS
:
:
Symbol
JS
:
:
SymbolValue
)
;
#
ifdef
ENABLE_BIGINT
DECLARE_REWRAP
(
JS
:
:
Value
JS
:
:
BigInt
JS
:
:
BigIntValue
)
;
#
endif
DECLARE_REWRAP
(
jsid
JSString
NON_INTEGER_ATOM_TO_JSID
(
JSAtom
*
)
)
;
DECLARE_REWRAP
(
jsid
JS
:
:
Symbol
SYMBOL_TO_JSID
)
;
DECLARE_REWRAP
(
js
:
:
TaggedProto
JSObject
js
:
:
TaggedProto
)
;
#
undef
DECLARE_REWRAP
template
<
typename
T
>
struct
IsPrivateGCThingInValue
:
public
mozilla
:
:
EnableIf
<
mozilla
:
:
IsBaseOf
<
Cell
T
>
:
:
value
&
&
!
mozilla
:
:
IsBaseOf
<
JSObject
T
>
:
:
value
&
&
!
mozilla
:
:
IsBaseOf
<
JSString
T
>
:
:
value
&
&
!
mozilla
:
:
IsBaseOf
<
JS
:
:
Symbol
T
>
:
:
value
#
ifdef
ENABLE_BIGINT
&
&
!
mozilla
:
:
IsBaseOf
<
JS
:
:
BigInt
T
>
:
:
value
#
endif
T
>
{
static_assert
(
!
mozilla
:
:
IsSame
<
Cell
T
>
:
:
value
&
&
!
mozilla
:
:
IsSame
<
TenuredCell
T
>
:
:
value
"
T
must
not
be
Cell
or
TenuredCell
"
)
;
}
;
template
<
typename
T
>
struct
RewrapTaggedPointer
<
Value
T
>
{
static
Value
wrap
(
typename
IsPrivateGCThingInValue
<
T
>
:
:
Type
*
thing
)
{
return
JS
:
:
PrivateGCThingValue
(
thing
)
;
}
}
;
}
bool
UnmarkGrayShapeRecursively
(
Shape
*
shape
)
;
template
<
typename
T
>
void
CheckTracedThing
(
JSTracer
*
trc
T
*
thing
)
;
template
<
typename
T
>
void
CheckTracedThing
(
JSTracer
*
trc
T
thing
)
;
namespace
gc
{
template
<
typename
T
>
inline
bool
IsForwarded
(
const
T
*
t
)
;
inline
bool
IsForwarded
(
const
JS
:
:
Value
&
value
)
;
template
<
typename
T
>
inline
T
*
Forwarded
(
const
T
*
t
)
;
inline
Value
Forwarded
(
const
JS
:
:
Value
&
value
)
;
template
<
typename
T
>
inline
T
MaybeForwarded
(
T
t
)
;
#
ifdef
JSGC_HASH_TABLE_CHECKS
template
<
typename
T
>
inline
bool
IsGCThingValidAfterMovingGC
(
T
*
t
)
;
template
<
typename
T
>
inline
void
CheckGCThingAfterMovingGC
(
T
*
t
)
;
template
<
typename
T
>
inline
void
CheckGCThingAfterMovingGC
(
const
ReadBarriered
<
T
*
>
&
t
)
;
inline
void
CheckValueAfterMovingGC
(
const
JS
:
:
Value
&
value
)
;
#
endif
}
}
#
endif
