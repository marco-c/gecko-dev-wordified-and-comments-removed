#
ifndef
gc_Marking_h
#
define
gc_Marking_h
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
vm
/
TaggedProto
.
h
"
class
JSLinearString
;
class
JSRope
;
class
JSTracer
;
namespace
js
{
class
BaseShape
;
class
GCMarker
;
class
LazyScript
;
class
NativeObject
;
class
ObjectGroup
;
class
Shape
;
class
WeakMapBase
;
namespace
jit
{
class
JitCode
;
}
#
ifdef
DEBUG
bool
IsBufferGrayRootsTracer
(
JSTracer
*
trc
)
;
bool
IsUnmarkGrayTracer
(
JSTracer
*
trc
)
;
#
endif
namespace
gc
{
class
Arena
;
struct
Cell
;
class
TenuredCell
;
void
PushArena
(
GCMarker
*
gcmarker
Arena
*
arena
)
;
template
<
typename
T
>
bool
IsMarkedInternal
(
JSRuntime
*
rt
T
*
thing
)
;
template
<
typename
T
>
bool
IsMarkedInternal
(
JSRuntime
*
rt
T
*
*
thing
)
;
template
<
typename
T
>
bool
IsMarkedBlackInternal
(
JSRuntime
*
rt
T
*
thing
)
;
template
<
typename
T
>
bool
IsMarkedBlackInternal
(
JSRuntime
*
rt
T
*
*
thing
)
;
template
<
typename
T
>
bool
IsAboutToBeFinalizedInternal
(
T
*
thingp
)
;
template
<
typename
T
>
bool
IsAboutToBeFinalizedInternal
(
T
*
*
thingp
)
;
template
<
typename
T
>
inline
bool
IsMarkedUnbarriered
(
JSRuntime
*
rt
T
*
thingp
)
{
return
IsMarkedInternal
(
rt
ConvertToBase
(
thingp
)
)
;
}
template
<
typename
T
>
inline
bool
IsMarked
(
JSRuntime
*
rt
WriteBarrieredBase
<
T
>
*
thingp
)
{
return
IsMarkedInternal
(
rt
ConvertToBase
(
thingp
-
>
unsafeUnbarrieredForTracing
(
)
)
)
;
}
template
<
typename
T
>
inline
bool
IsMarkedBlackUnbarriered
(
JSRuntime
*
rt
T
*
thingp
)
{
return
IsMarkedBlackInternal
(
rt
ConvertToBase
(
thingp
)
)
;
}
template
<
typename
T
>
inline
bool
IsMarkedBlack
(
JSRuntime
*
rt
WriteBarrieredBase
<
T
>
*
thingp
)
{
return
IsMarkedBlackInternal
(
rt
ConvertToBase
(
thingp
-
>
unsafeUnbarrieredForTracing
(
)
)
)
;
}
template
<
typename
T
>
inline
bool
IsAboutToBeFinalizedUnbarriered
(
T
*
thingp
)
{
return
IsAboutToBeFinalizedInternal
(
ConvertToBase
(
thingp
)
)
;
}
template
<
typename
T
>
inline
bool
IsAboutToBeFinalized
(
WriteBarrieredBase
<
T
>
*
thingp
)
{
return
IsAboutToBeFinalizedInternal
(
ConvertToBase
(
thingp
-
>
unsafeUnbarrieredForTracing
(
)
)
)
;
}
template
<
typename
T
>
inline
bool
IsAboutToBeFinalized
(
ReadBarrieredBase
<
T
>
*
thingp
)
{
return
IsAboutToBeFinalizedInternal
(
ConvertToBase
(
thingp
-
>
unsafeUnbarrieredForTracing
(
)
)
)
;
}
bool
IsAboutToBeFinalizedDuringSweep
(
TenuredCell
&
tenured
)
;
inline
Cell
*
ToMarkable
(
const
Value
&
v
)
{
if
(
v
.
isGCThing
(
)
)
{
return
(
Cell
*
)
v
.
toGCThing
(
)
;
}
return
nullptr
;
}
inline
Cell
*
ToMarkable
(
Cell
*
cell
)
{
return
cell
;
}
}
bool
UnmarkGrayShapeRecursively
(
Shape
*
shape
)
;
template
<
typename
T
>
void
CheckTracedThing
(
JSTracer
*
trc
T
*
thing
)
;
template
<
typename
T
>
void
CheckTracedThing
(
JSTracer
*
trc
T
thing
)
;
namespace
gc
{
template
<
typename
T
>
inline
bool
IsForwarded
(
const
T
*
t
)
;
inline
bool
IsForwarded
(
const
JS
:
:
Value
&
value
)
;
template
<
typename
T
>
inline
T
*
Forwarded
(
const
T
*
t
)
;
inline
Value
Forwarded
(
const
JS
:
:
Value
&
value
)
;
template
<
typename
T
>
inline
T
MaybeForwarded
(
T
t
)
;
#
ifdef
JSGC_HASH_TABLE_CHECKS
template
<
typename
T
>
inline
bool
IsGCThingValidAfterMovingGC
(
T
*
t
)
;
template
<
typename
T
>
inline
void
CheckGCThingAfterMovingGC
(
T
*
t
)
;
template
<
typename
T
>
inline
void
CheckGCThingAfterMovingGC
(
const
ReadBarriered
<
T
*
>
&
t
)
;
inline
void
CheckValueAfterMovingGC
(
const
JS
:
:
Value
&
value
)
;
#
endif
}
}
#
endif
