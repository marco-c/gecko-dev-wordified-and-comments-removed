#
ifndef
gc_ParallelMarking_h
#
define
gc_ParallelMarking_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
BitSet
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
gc
/
GCMarker
.
h
"
#
include
"
gc
/
GCParallelTask
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
threading
/
ConditionVariable
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
namespace
js
{
class
AutoLockHelperThreadState
;
namespace
gc
{
class
ParallelMarker
;
using
ParallelTaskBitset
=
mozilla
:
:
BitSet
<
MaxParallelWorkers
uint32_t
>
;
class
alignas
(
TypicalCacheLineSize
)
ParallelMarkTask
:
public
GCParallelTask
{
public
:
friend
class
ParallelMarker
;
ParallelMarkTask
(
ParallelMarker
*
pm
GCMarker
*
marker
MarkColor
color
uint32_t
id
const
JS
:
:
SliceBudget
&
budget
)
;
~
ParallelMarkTask
(
)
;
void
run
(
AutoLockHelperThreadState
&
lock
)
override
;
using
AtomicCount
=
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
Relaxed
>
;
AtomicCount
&
waitingTaskCountRef
(
)
;
void
donateWork
(
)
;
void
recordDuration
(
)
override
;
private
:
bool
tryMarking
(
AutoLockHelperThreadState
&
lock
)
;
bool
requestWork
(
AutoLockHelperThreadState
&
lock
)
;
void
waitUntilResumed
(
AutoLockHelperThreadState
&
lock
)
;
void
resume
(
)
;
void
resumeOnFinish
(
const
AutoLockHelperThreadState
&
lock
)
;
bool
hasWork
(
)
const
;
ParallelMarker
*
const
pm
;
GCMarker
*
const
marker
;
AutoSetMarkColor
color
;
JS
:
:
SliceBudget
budget
;
ConditionVariable
resumed
;
const
uint32_t
id
;
HelperThreadLockData
<
bool
>
isWaiting
;
MainThreadOrGCTaskData
<
mozilla
:
:
TimeDuration
>
markTime
;
MainThreadOrGCTaskData
<
mozilla
:
:
TimeDuration
>
waitTime
;
}
;
class
MOZ_STACK_CLASS
ParallelMarker
{
public
:
static
bool
mark
(
GCRuntime
*
gc
const
JS
:
:
SliceBudget
&
sliceBudget
)
;
bool
hasWaitingTasks
(
)
const
{
return
!
waitingTasks
.
IsEmpty
(
)
;
}
void
donateWorkFrom
(
GCMarker
*
src
)
;
private
:
static
bool
markOneColor
(
GCRuntime
*
gc
MarkColor
color
const
JS
:
:
SliceBudget
&
sliceBudget
)
;
explicit
ParallelMarker
(
GCRuntime
*
gc
MarkColor
color
)
;
bool
mark
(
const
JS
:
:
SliceBudget
&
sliceBudget
)
;
bool
hasWork
(
MarkColor
color
)
const
;
void
addTask
(
ParallelMarkTask
*
task
const
AutoLockHelperThreadState
&
lock
)
;
void
addTaskToWaitingList
(
ParallelMarkTask
*
task
const
AutoLockHelperThreadState
&
lock
)
;
#
ifdef
DEBUG
bool
isTaskInWaitingList
(
const
ParallelMarkTask
*
task
const
AutoLockHelperThreadState
&
lock
)
const
;
#
endif
ParallelMarkTask
*
takeWaitingTask
(
)
;
bool
hasActiveTasks
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
!
activeTasks
.
ref
(
)
.
IsEmpty
(
)
;
}
void
setTaskActive
(
ParallelMarkTask
*
task
const
AutoLockHelperThreadState
&
lock
)
;
void
setTaskInactive
(
ParallelMarkTask
*
task
const
AutoLockHelperThreadState
&
lock
)
;
size_t
workerCount
(
)
const
;
friend
class
ParallelMarkTask
;
GCRuntime
*
const
gc
;
mozilla
:
:
Maybe
<
ParallelMarkTask
>
tasks
[
MaxParallelWorkers
]
;
using
WaitingTaskSet
=
mozilla
:
:
BitSet
<
MaxParallelWorkers
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
Relaxed
>
>
;
WaitingTaskSet
waitingTasks
;
HelperThreadLockData
<
ParallelTaskBitset
>
activeTasks
;
const
MarkColor
color
;
}
;
inline
ParallelMarkTask
:
:
AtomicCount
&
ParallelMarkTask
:
:
waitingTaskCountRef
(
)
{
return
pm
-
>
waitingTasks
.
Storage
(
)
[
0
]
;
}
}
}
#
endif
