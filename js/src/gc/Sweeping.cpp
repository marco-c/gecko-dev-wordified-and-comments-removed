#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
builtin
/
FinalizationRegistryObject
.
h
"
#
include
"
builtin
/
WeakRefObject
.
h
"
#
include
"
debugger
/
DebugAPI
.
h
"
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
gc
/
FinalizationObservers
.
h
"
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
gc
/
GCLock
.
h
"
#
include
"
gc
/
GCProbes
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
gc
/
ParallelWork
.
h
"
#
include
"
gc
/
Statistics
.
h
"
#
include
"
gc
/
TraceKind
.
h
"
#
include
"
gc
/
WeakMap
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
jit
/
JitZone
.
h
"
#
include
"
proxy
/
DeadObjectProxy
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
HelperThreads
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
Time
.
h
"
#
include
"
vm
/
WrapperObject
.
h
"
#
include
"
gc
/
PrivateIterators
-
inl
.
h
"
#
include
"
vm
/
GeckoProfiler
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
PropMap
-
inl
.
h
"
#
include
"
vm
/
Shape
-
inl
.
h
"
#
include
"
vm
/
StringType
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
mozilla
:
:
TimeStamp
;
struct
js
:
:
gc
:
:
FinalizePhase
{
gcstats
:
:
PhaseKind
statsPhase
;
AllocKinds
kinds
;
}
;
static
constexpr
FinalizePhase
ForegroundObjectFinalizePhase
=
{
gcstats
:
:
PhaseKind
:
:
FINALIZE_OBJECT
{
AllocKind
:
:
OBJECT0
AllocKind
:
:
OBJECT2
AllocKind
:
:
OBJECT4
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT16
}
}
;
static
constexpr
FinalizePhase
ForegroundNonObjectFinalizePhase
=
{
gcstats
:
:
PhaseKind
:
:
FINALIZE_NON_OBJECT
{
AllocKind
:
:
SCRIPT
AllocKind
:
:
JITCODE
}
}
;
static
constexpr
FinalizePhase
BackgroundFinalizePhases
[
]
=
{
{
gcstats
:
:
PhaseKind
:
:
FINALIZE_OBJECT
{
AllocKind
:
:
FUNCTION
AllocKind
:
:
FUNCTION_EXTENDED
AllocKind
:
:
OBJECT0_BACKGROUND
AllocKind
:
:
OBJECT2_BACKGROUND
AllocKind
:
:
ARRAYBUFFER4
AllocKind
:
:
OBJECT4_BACKGROUND
AllocKind
:
:
ARRAYBUFFER8
AllocKind
:
:
OBJECT8_BACKGROUND
AllocKind
:
:
ARRAYBUFFER12
AllocKind
:
:
OBJECT12_BACKGROUND
AllocKind
:
:
ARRAYBUFFER16
AllocKind
:
:
OBJECT16_BACKGROUND
}
}
{
gcstats
:
:
PhaseKind
:
:
FINALIZE_NON_OBJECT
{
AllocKind
:
:
SCOPE
AllocKind
:
:
REGEXP_SHARED
AllocKind
:
:
FAT_INLINE_STRING
AllocKind
:
:
STRING
AllocKind
:
:
EXTERNAL_STRING
AllocKind
:
:
FAT_INLINE_ATOM
AllocKind
:
:
ATOM
AllocKind
:
:
SYMBOL
AllocKind
:
:
BIGINT
AllocKind
:
:
SHAPE
AllocKind
:
:
BASE_SHAPE
AllocKind
:
:
GETTER_SETTER
AllocKind
:
:
COMPACT_PROP_MAP
AllocKind
:
:
NORMAL_PROP_MAP
AllocKind
:
:
DICT_PROP_MAP
}
}
}
;
template
<
typename
T
>
inline
size_t
Arena
:
:
finalize
(
JS
:
:
GCContext
*
gcx
AllocKind
thingKind
size_t
thingSize
)
{
MOZ_ASSERT
(
thingSize
%
CellAlignBytes
=
=
0
)
;
MOZ_ASSERT
(
thingSize
>
=
MinCellSize
)
;
MOZ_ASSERT
(
thingSize
<
=
255
)
;
MOZ_ASSERT
(
allocated
(
)
)
;
MOZ_ASSERT
(
thingKind
=
=
getAllocKind
(
)
)
;
MOZ_ASSERT
(
thingSize
=
=
getThingSize
(
)
)
;
MOZ_ASSERT
(
!
onDelayedMarkingList_
)
;
uint_fast16_t
firstThing
=
firstThingOffset
(
thingKind
)
;
uint_fast16_t
firstThingOrSuccessorOfLastMarkedThing
=
firstThing
;
uint_fast16_t
lastThing
=
ArenaSize
-
thingSize
;
FreeSpan
newListHead
;
FreeSpan
*
newListTail
=
&
newListHead
;
size_t
nmarked
=
0
nfinalized
=
0
;
for
(
ArenaCellIterUnderFinalize
cell
(
this
)
;
!
cell
.
done
(
)
;
cell
.
next
(
)
)
{
T
*
t
=
cell
.
as
<
T
>
(
)
;
if
(
TenuredThingIsMarkedAny
(
t
)
)
{
uint_fast16_t
thing
=
uintptr_t
(
t
)
&
ArenaMask
;
if
(
thing
!
=
firstThingOrSuccessorOfLastMarkedThing
)
{
newListTail
-
>
initBounds
(
firstThingOrSuccessorOfLastMarkedThing
thing
-
thingSize
this
)
;
newListTail
=
newListTail
-
>
nextSpanUnchecked
(
this
)
;
}
firstThingOrSuccessorOfLastMarkedThing
=
thing
+
thingSize
;
nmarked
+
+
;
}
else
{
t
-
>
finalize
(
gcx
)
;
AlwaysPoison
(
t
JS_SWEPT_TENURED_PATTERN
thingSize
MemCheckKind
:
:
MakeUndefined
)
;
gcprobes
:
:
TenuredFinalize
(
t
)
;
nfinalized
+
+
;
}
}
if
constexpr
(
std
:
:
is_same_v
<
T
JSObject
>
)
{
if
(
isNewlyCreated_
)
{
zone
-
>
pretenuring
.
updateCellCountsInNewlyCreatedArenas
(
nmarked
+
nfinalized
nmarked
)
;
}
}
isNewlyCreated_
=
0
;
if
(
thingKind
=
=
AllocKind
:
:
STRING
|
|
thingKind
=
=
AllocKind
:
:
FAT_INLINE_STRING
)
{
zone
-
>
markedStrings
+
=
nmarked
;
zone
-
>
finalizedStrings
+
=
nfinalized
;
}
if
(
nmarked
=
=
0
)
{
MOZ_ASSERT
(
newListTail
=
=
&
newListHead
)
;
DebugOnlyPoison
(
data
JS_SWEPT_TENURED_PATTERN
sizeof
(
data
)
MemCheckKind
:
:
MakeUndefined
)
;
return
nmarked
;
}
MOZ_ASSERT
(
firstThingOrSuccessorOfLastMarkedThing
!
=
firstThing
)
;
uint_fast16_t
lastMarkedThing
=
firstThingOrSuccessorOfLastMarkedThing
-
thingSize
;
if
(
lastThing
=
=
lastMarkedThing
)
{
newListTail
-
>
initAsEmpty
(
)
;
}
else
{
newListTail
-
>
initFinal
(
firstThingOrSuccessorOfLastMarkedThing
lastThing
this
)
;
}
firstFreeSpan
=
newListHead
;
#
ifdef
DEBUG
size_t
nfree
=
numFreeThings
(
thingSize
)
;
MOZ_ASSERT
(
nfree
+
nmarked
=
=
thingsPerArena
(
thingKind
)
)
;
#
endif
return
nmarked
;
}
template
<
typename
T
>
static
inline
bool
FinalizeTypedArenas
(
JS
:
:
GCContext
*
gcx
ArenaList
&
src
SortedArenaList
&
dest
AllocKind
thingKind
SliceBudget
&
budget
)
{
MOZ_ASSERT
(
gcx
-
>
isFinalizing
(
)
)
;
size_t
thingSize
=
Arena
:
:
thingSize
(
thingKind
)
;
size_t
thingsPerArena
=
Arena
:
:
thingsPerArena
(
thingKind
)
;
size_t
markCount
=
0
;
auto
updateMarkCount
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
GCRuntime
*
gc
=
&
gcx
-
>
runtimeFromAnyThread
(
)
-
>
gc
;
gc
-
>
stats
(
)
.
addCount
(
gcstats
:
:
COUNT_CELLS_MARKED
markCount
)
;
}
)
;
while
(
Arena
*
arena
=
src
.
takeFirstArena
(
)
)
{
size_t
nmarked
=
arena
-
>
finalize
<
T
>
(
gcx
thingKind
thingSize
)
;
size_t
nfree
=
thingsPerArena
-
nmarked
;
markCount
+
=
nmarked
;
if
(
nmarked
)
{
dest
.
insertAt
(
arena
nfree
)
;
}
else
{
arena
-
>
chunk
(
)
-
>
recycleArena
(
arena
dest
thingsPerArena
)
;
}
budget
.
step
(
thingsPerArena
)
;
if
(
budget
.
isOverBudget
(
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
FinalizeArenas
(
JS
:
:
GCContext
*
gcx
ArenaList
&
src
SortedArenaList
&
dest
AllocKind
thingKind
SliceBudget
&
budget
)
{
switch
(
thingKind
)
{
#
define
EXPAND_CASE
(
allocKind
traceKind
type
sizedType
bgFinal
nursery
\
compact
)
\
case
AllocKind
:
:
allocKind
:
\
return
FinalizeTypedArenas
<
type
>
(
gcx
src
dest
thingKind
budget
)
;
FOR_EACH_ALLOCKIND
(
EXPAND_CASE
)
#
undef
EXPAND_CASE
default
:
MOZ_CRASH
(
"
Invalid
alloc
kind
"
)
;
}
}
void
GCRuntime
:
:
initBackgroundSweep
(
Zone
*
zone
JS
:
:
GCContext
*
gcx
const
FinalizePhase
&
phase
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
phase
.
statsPhase
)
;
for
(
auto
kind
:
phase
.
kinds
)
{
zone
-
>
arenas
.
initBackgroundSweep
(
kind
)
;
}
}
void
ArenaLists
:
:
initBackgroundSweep
(
AllocKind
thingKind
)
{
MOZ_ASSERT
(
IsBackgroundFinalized
(
thingKind
)
)
;
MOZ_ASSERT
(
concurrentUse
(
thingKind
)
=
=
ConcurrentUse
:
:
None
)
;
if
(
!
collectingArenaList
(
thingKind
)
.
isEmpty
(
)
)
{
concurrentUse
(
thingKind
)
=
ConcurrentUse
:
:
BackgroundFinalize
;
}
}
void
GCRuntime
:
:
backgroundFinalize
(
JS
:
:
GCContext
*
gcx
Zone
*
zone
AllocKind
kind
Arena
*
*
empty
)
{
MOZ_ASSERT
(
empty
)
;
ArenaLists
*
lists
=
&
zone
-
>
arenas
;
ArenaList
&
arenas
=
lists
-
>
collectingArenaList
(
kind
)
;
if
(
arenas
.
isEmpty
(
)
)
{
MOZ_ASSERT
(
lists
-
>
concurrentUse
(
kind
)
=
=
ArenaLists
:
:
ConcurrentUse
:
:
None
)
;
return
;
}
SortedArenaList
finalizedSorted
(
Arena
:
:
thingsPerArena
(
kind
)
)
;
auto
unlimited
=
SliceBudget
:
:
unlimited
(
)
;
FinalizeArenas
(
gcx
arenas
finalizedSorted
kind
unlimited
)
;
MOZ_ASSERT
(
arenas
.
isEmpty
(
)
)
;
finalizedSorted
.
extractEmpty
(
empty
)
;
{
AutoLockGC
lock
(
rt
)
;
MOZ_ASSERT
(
lists
-
>
concurrentUse
(
kind
)
=
=
ArenaLists
:
:
ConcurrentUse
:
:
BackgroundFinalize
)
;
lists
-
>
mergeFinalizedArenas
(
kind
finalizedSorted
)
;
}
lists
-
>
concurrentUse
(
kind
)
=
ArenaLists
:
:
ConcurrentUse
:
:
None
;
}
void
ArenaLists
:
:
mergeFinalizedArenas
(
AllocKind
kind
SortedArenaList
&
finalizedArenas
)
{
#
ifdef
DEBUG
if
(
IsBackgroundFinalized
(
kind
)
)
{
runtimeFromAnyThread
(
)
-
>
gc
.
assertCurrentThreadHasLockedGC
(
)
;
}
#
endif
ArenaList
&
arenas
=
arenaList
(
kind
)
;
ArenaList
allocatedDuringCollection
=
std
:
:
move
(
arenas
)
;
arenas
=
finalizedArenas
.
toArenaList
(
)
;
arenas
.
insertListWithCursorAtEnd
(
allocatedDuringCollection
)
;
collectingArenaList
(
kind
)
.
clear
(
)
;
}
void
ArenaLists
:
:
queueForegroundThingsForSweep
(
)
{
gcCompactPropMapArenasToUpdate
=
collectingArenaList
(
AllocKind
:
:
COMPACT_PROP_MAP
)
.
head
(
)
;
gcNormalPropMapArenasToUpdate
=
collectingArenaList
(
AllocKind
:
:
NORMAL_PROP_MAP
)
.
head
(
)
;
}
void
GCRuntime
:
:
sweepBackgroundThings
(
ZoneList
&
zones
)
{
if
(
zones
.
isEmpty
(
)
)
{
return
;
}
JS
:
:
GCContext
*
gcx
=
TlsGCContext
.
get
(
)
;
MOZ_ASSERT
(
gcx
-
>
isFinalizing
(
)
)
;
while
(
!
zones
.
isEmpty
(
)
)
{
Zone
*
zone
=
zones
.
removeFront
(
)
;
MOZ_ASSERT
(
zone
-
>
isGCFinished
(
)
)
;
TimeStamp
startTime
=
TimeStamp
:
:
Now
(
)
;
Arena
*
emptyArenas
=
zone
-
>
arenas
.
takeSweptEmptyArenas
(
)
;
for
(
auto
phase
:
BackgroundFinalizePhases
)
{
for
(
auto
kind
:
phase
.
kinds
)
{
backgroundFinalize
(
gcx
zone
kind
&
emptyArenas
)
;
}
}
static
const
size_t
LockReleasePeriod
=
32
;
while
(
emptyArenas
)
{
AutoLockGC
lock
(
this
)
;
for
(
size_t
i
=
0
;
i
<
LockReleasePeriod
&
&
emptyArenas
;
i
+
+
)
{
Arena
*
arena
=
emptyArenas
;
emptyArenas
=
emptyArenas
-
>
next
;
releaseArena
(
arena
lock
)
;
}
}
TimeStamp
endTime
=
TimeStamp
:
:
Now
(
)
;
zone
-
>
perZoneGCTime
+
=
endTime
-
startTime
;
}
}
void
GCRuntime
:
:
assertBackgroundSweepingFinished
(
)
{
#
ifdef
DEBUG
{
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
backgroundSweepZones
.
ref
(
)
.
isEmpty
(
)
)
;
}
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
auto
kind
:
AllAllocKinds
(
)
)
{
MOZ_ASSERT_IF
(
state
(
)
!
=
State
:
:
Prepare
&
&
state
(
)
!
=
State
:
:
Mark
&
&
state
(
)
!
=
State
:
:
Sweep
zone
-
>
arenas
.
collectingArenaList
(
kind
)
.
isEmpty
(
)
)
;
MOZ_ASSERT
(
zone
-
>
arenas
.
doneBackgroundFinalize
(
kind
)
)
;
}
}
#
endif
}
void
GCRuntime
:
:
queueZonesAndStartBackgroundSweep
(
ZoneList
&
&
zones
)
{
{
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
!
requestSliceAfterBackgroundTask
)
;
backgroundSweepZones
.
ref
(
)
.
appendList
(
std
:
:
move
(
zones
)
)
;
if
(
useBackgroundThreads
)
{
sweepTask
.
startOrRunIfIdle
(
lock
)
;
}
}
if
(
!
useBackgroundThreads
)
{
sweepTask
.
join
(
)
;
sweepTask
.
runFromMainThread
(
)
;
}
}
BackgroundSweepTask
:
:
BackgroundSweepTask
(
GCRuntime
*
gc
)
:
GCParallelTask
(
gc
gcstats
:
:
PhaseKind
:
:
SWEEP
GCUse
:
:
Finalizing
)
{
}
void
BackgroundSweepTask
:
:
run
(
AutoLockHelperThreadState
&
lock
)
{
gc
-
>
sweepFromBackgroundThread
(
lock
)
;
}
void
GCRuntime
:
:
sweepFromBackgroundThread
(
AutoLockHelperThreadState
&
lock
)
{
do
{
ZoneList
zones
;
zones
.
appendList
(
std
:
:
move
(
backgroundSweepZones
.
ref
(
)
)
)
;
AutoUnlockHelperThreadState
unlock
(
lock
)
;
sweepBackgroundThings
(
zones
)
;
}
while
(
!
backgroundSweepZones
.
ref
(
)
.
isEmpty
(
)
)
;
maybeRequestGCAfterBackgroundTask
(
lock
)
;
}
void
GCRuntime
:
:
waitBackgroundSweepEnd
(
)
{
sweepTask
.
join
(
)
;
if
(
state
(
)
!
=
State
:
:
Sweep
)
{
assertBackgroundSweepingFinished
(
)
;
}
}
void
GCRuntime
:
:
startBackgroundFree
(
)
{
AutoLockHelperThreadState
lock
;
freeTask
.
startOrRunIfIdle
(
lock
)
;
}
BackgroundFreeTask
:
:
BackgroundFreeTask
(
GCRuntime
*
gc
)
:
GCParallelTask
(
gc
gcstats
:
:
PhaseKind
:
:
NONE
)
{
}
void
BackgroundFreeTask
:
:
run
(
AutoLockHelperThreadState
&
lock
)
{
gc
-
>
freeFromBackgroundThread
(
lock
)
;
}
void
GCRuntime
:
:
freeFromBackgroundThread
(
AutoLockHelperThreadState
&
lock
)
{
do
{
LifoAlloc
lifoBlocks
(
JSContext
:
:
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
)
;
lifoBlocks
.
transferFrom
(
&
lifoBlocksToFree
.
ref
(
)
)
;
Nursery
:
:
BufferSet
buffers
;
std
:
:
swap
(
buffers
buffersToFreeAfterMinorGC
.
ref
(
)
)
;
AutoUnlockHelperThreadState
unlock
(
lock
)
;
lifoBlocks
.
freeAll
(
)
;
JS
:
:
GCContext
*
gcx
=
TlsGCContext
.
get
(
)
;
for
(
Nursery
:
:
BufferSet
:
:
Range
r
=
buffers
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
gcx
-
>
freeUntracked
(
r
.
front
(
)
)
;
}
}
while
(
!
lifoBlocksToFree
.
ref
(
)
.
isEmpty
(
)
|
|
!
buffersToFreeAfterMinorGC
.
ref
(
)
.
empty
(
)
)
;
}
void
GCRuntime
:
:
waitBackgroundFreeEnd
(
)
{
freeTask
.
join
(
)
;
}
template
<
class
ZoneIterT
>
IncrementalProgress
GCRuntime
:
:
markWeakReferences
(
SliceBudget
&
incrementalBudget
)
{
MOZ_ASSERT
(
!
marker
(
)
.
isWeakMarking
(
)
)
;
gcstats
:
:
AutoPhase
ap1
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK_WEAK
)
;
auto
unlimited
=
SliceBudget
:
:
unlimited
(
)
;
SliceBudget
&
budget
=
marker
(
)
.
incrementalWeakMapMarkingEnabled
?
incrementalBudget
:
unlimited
;
auto
leaveOnExit
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
marker
(
)
.
leaveWeakMarkingMode
(
)
;
}
)
;
if
(
marker
(
)
.
enterWeakMarkingMode
(
)
)
{
while
(
processTestMarkQueue
(
)
=
=
QueueYielded
)
{
}
;
if
(
!
marker
(
)
.
incrementalWeakMapMarkingEnabled
)
{
for
(
ZoneIterT
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
zone
-
>
gcEphemeronEdges
(
)
.
clear
(
)
)
{
oomUnsafe
.
crash
(
"
clearing
weak
keys
when
entering
weak
marking
mode
"
)
;
}
}
}
for
(
ZoneIterT
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
enterWeakMarkingMode
(
&
marker
(
)
budget
)
=
=
NotFinished
)
{
return
NotFinished
;
}
}
}
bool
markedAny
=
true
;
while
(
markedAny
)
{
if
(
!
marker
(
)
.
markUntilBudgetExhausted
(
budget
)
)
{
MOZ_ASSERT
(
marker
(
)
.
incrementalWeakMapMarkingEnabled
)
;
return
NotFinished
;
}
markedAny
=
false
;
if
(
!
marker
(
)
.
isWeakMarking
(
)
)
{
for
(
ZoneIterT
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
markedAny
|
=
WeakMapBase
:
:
markZoneIteratively
(
zone
&
marker
(
)
)
;
}
}
markedAny
|
=
jit
:
:
JitRuntime
:
:
MarkJitcodeGlobalTableIteratively
(
&
marker
(
)
)
;
}
assertNoMarkingWork
(
)
;
return
Finished
;
}
IncrementalProgress
GCRuntime
:
:
markWeakReferencesInCurrentGroup
(
SliceBudget
&
budget
)
{
return
markWeakReferences
<
SweepGroupZonesIter
>
(
budget
)
;
}
template
<
class
ZoneIterT
>
IncrementalProgress
GCRuntime
:
:
markGrayRoots
(
SliceBudget
&
budget
gcstats
:
:
PhaseKind
phase
)
{
MOZ_ASSERT
(
marker
(
)
.
markColor
(
)
=
=
MarkColor
:
:
Gray
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
phase
)
;
AutoUpdateLiveCompartments
updateLive
(
this
)
;
marker
(
)
.
setRootMarkingMode
(
true
)
;
auto
guard
=
mozilla
:
:
MakeScopeExit
(
[
this
]
(
)
{
marker
(
)
.
setRootMarkingMode
(
false
)
;
}
)
;
IncrementalProgress
result
=
traceEmbeddingGrayRoots
(
marker
(
)
.
tracer
(
)
budget
)
;
if
(
result
=
=
NotFinished
)
{
return
NotFinished
;
}
Compartment
:
:
traceIncomingCrossCompartmentEdgesForZoneGC
(
marker
(
)
.
tracer
(
)
Compartment
:
:
GrayEdges
)
;
return
Finished
;
}
IncrementalProgress
GCRuntime
:
:
markAllWeakReferences
(
)
{
SliceBudget
budget
=
SliceBudget
:
:
unlimited
(
)
;
return
markWeakReferences
<
GCZonesIter
>
(
budget
)
;
}
void
GCRuntime
:
:
markAllGrayReferences
(
gcstats
:
:
PhaseKind
phase
)
{
SliceBudget
budget
=
SliceBudget
:
:
unlimited
(
)
;
markGrayRoots
<
GCZonesIter
>
(
budget
phase
)
;
drainMarkStack
(
)
;
}
void
GCRuntime
:
:
dropStringWrappers
(
)
{
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
dropStringWrappersOnGC
(
)
;
}
}
bool
Compartment
:
:
findSweepGroupEdges
(
)
{
Zone
*
source
=
zone
(
)
;
for
(
WrappedObjectCompartmentEnum
e
(
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Compartment
*
targetComp
=
e
.
front
(
)
;
Zone
*
target
=
targetComp
-
>
zone
(
)
;
if
(
!
target
-
>
isGCMarking
(
)
|
|
source
-
>
hasSweepGroupEdgeTo
(
target
)
)
{
continue
;
}
for
(
ObjectWrapperEnum
e
(
this
targetComp
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
JSObject
*
key
=
e
.
front
(
)
.
mutableKey
(
)
;
MOZ_ASSERT
(
key
-
>
zone
(
)
=
=
target
)
;
if
(
key
-
>
isMarkedBlack
(
)
)
{
continue
;
}
if
(
!
source
-
>
addSweepGroupEdgeTo
(
target
)
)
{
return
false
;
}
break
;
}
}
return
true
;
}
bool
Zone
:
:
findSweepGroupEdges
(
Zone
*
atomsZone
)
{
MOZ_ASSERT_IF
(
this
!
=
atomsZone
!
isAtomsZone
(
)
)
;
#
ifdef
DEBUG
if
(
FinalizationObservers
*
observers
=
finalizationObservers
(
)
)
{
observers
-
>
checkTables
(
)
;
}
#
endif
if
(
atomsZone
-
>
wasGCStarted
(
)
&
&
!
addSweepGroupEdgeTo
(
atomsZone
)
)
{
return
false
;
}
for
(
CompartmentsInZoneIter
comp
(
this
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
if
(
!
comp
-
>
findSweepGroupEdges
(
)
)
{
return
false
;
}
}
return
WeakMapBase
:
:
findSweepGroupEdgesForZone
(
this
)
;
}
bool
GCRuntime
:
:
addEdgesForMarkQueue
(
)
{
#
ifdef
DEBUG
JS
:
:
Zone
*
prevZone
=
nullptr
;
for
(
size_t
i
=
0
;
i
<
testMarkQueue
.
length
(
)
;
i
+
+
)
{
Value
val
=
testMarkQueue
[
i
]
.
get
(
)
;
if
(
!
val
.
isObject
(
)
)
{
continue
;
}
JSObject
*
obj
=
&
val
.
toObject
(
)
;
JS
:
:
Zone
*
zone
=
obj
-
>
zone
(
)
;
if
(
!
zone
-
>
isGCMarking
(
)
)
{
continue
;
}
if
(
prevZone
&
&
prevZone
!
=
zone
)
{
if
(
!
prevZone
-
>
addSweepGroupEdgeTo
(
zone
)
)
{
return
false
;
}
}
prevZone
=
zone
;
}
#
endif
return
true
;
}
bool
GCRuntime
:
:
findSweepGroupEdges
(
)
{
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zone
-
>
findSweepGroupEdges
(
atomsZone
(
)
)
)
{
return
false
;
}
}
if
(
!
addEdgesForMarkQueue
(
)
)
{
return
false
;
}
return
DebugAPI
:
:
findSweepGroupEdges
(
rt
)
;
}
void
GCRuntime
:
:
groupZonesForSweeping
(
JS
:
:
GCReason
reason
)
{
#
ifdef
DEBUG
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
zone
-
>
gcSweepGroupEdges
(
)
.
empty
(
)
)
;
}
#
endif
JSContext
*
cx
=
rt
-
>
mainContextFromOwnThread
(
)
;
ZoneComponentFinder
finder
(
cx
)
;
if
(
!
isIncremental
|
|
!
findSweepGroupEdges
(
)
)
{
finder
.
useOneComponent
(
)
;
}
if
(
useZeal
&
&
hasIncrementalTwoSliceZealMode
(
)
)
{
finder
.
useOneComponent
(
)
;
}
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
zone
-
>
isGCMarking
(
)
)
;
finder
.
addNode
(
zone
)
;
}
sweepGroups
=
finder
.
getResultsList
(
)
;
currentSweepGroup
=
sweepGroups
;
sweepGroupIndex
=
1
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
clearSweepGroupEdges
(
)
;
}
#
ifdef
DEBUG
unsigned
idx
=
sweepGroupIndex
;
for
(
Zone
*
head
=
currentSweepGroup
;
head
;
head
=
head
-
>
nextGroup
(
)
)
{
for
(
Zone
*
zone
=
head
;
zone
;
zone
=
zone
-
>
nextNodeInGroup
(
)
)
{
MOZ_ASSERT
(
zone
-
>
isGCMarking
(
)
)
;
zone
-
>
gcSweepGroupIndex
=
idx
;
}
idx
+
+
;
}
MOZ_ASSERT_IF
(
!
isIncremental
!
currentSweepGroup
-
>
nextGroup
(
)
)
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
zone
-
>
gcSweepGroupEdges
(
)
.
empty
(
)
)
;
}
#
endif
}
void
GCRuntime
:
:
getNextSweepGroup
(
)
{
currentSweepGroup
=
currentSweepGroup
-
>
nextGroup
(
)
;
+
+
sweepGroupIndex
;
if
(
!
currentSweepGroup
)
{
abortSweepAfterCurrentGroup
=
false
;
return
;
}
MOZ_ASSERT_IF
(
abortSweepAfterCurrentGroup
!
isIncremental
)
;
if
(
!
isIncremental
)
{
ZoneComponentFinder
:
:
mergeGroups
(
currentSweepGroup
)
;
}
for
(
Zone
*
zone
=
currentSweepGroup
;
zone
;
zone
=
zone
-
>
nextNodeInGroup
(
)
)
{
MOZ_ASSERT
(
zone
-
>
gcState
(
)
=
=
zone
-
>
initialMarkingState
(
)
)
;
MOZ_ASSERT
(
!
zone
-
>
isQueuedForBackgroundSweep
(
)
)
;
}
if
(
abortSweepAfterCurrentGroup
)
{
markTask
.
join
(
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
!
zone
-
>
gcNextGraphComponent
)
;
zone
-
>
changeGCState
(
zone
-
>
initialMarkingState
(
)
Zone
:
:
NoGC
)
;
zone
-
>
arenas
.
unmarkPreMarkedFreeCells
(
)
;
zone
-
>
arenas
.
mergeArenasFromCollectingLists
(
)
;
zone
-
>
clearGCSliceThresholds
(
)
;
}
for
(
SweepGroupCompartmentsIter
comp
(
rt
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
resetGrayList
(
comp
)
;
}
abortSweepAfterCurrentGroup
=
false
;
currentSweepGroup
=
nullptr
;
}
}
static
bool
IsGrayListObject
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
obj
)
;
return
obj
-
>
is
<
CrossCompartmentWrapperObject
>
(
)
&
&
!
IsDeadProxyObject
(
obj
)
;
}
unsigned
ProxyObject
:
:
grayLinkReservedSlot
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
IsGrayListObject
(
obj
)
)
;
return
CrossCompartmentWrapperObject
:
:
GrayLinkReservedSlot
;
}
#
ifdef
DEBUG
static
void
AssertNotOnGrayList
(
JSObject
*
obj
)
{
MOZ_ASSERT_IF
(
IsGrayListObject
(
obj
)
GetProxyReservedSlot
(
obj
ProxyObject
:
:
grayLinkReservedSlot
(
obj
)
)
.
isUndefined
(
)
)
;
}
#
endif
static
void
AssertNoWrappersInGrayList
(
JSRuntime
*
rt
)
{
#
ifdef
DEBUG
for
(
CompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
MOZ_ASSERT
(
!
c
-
>
gcIncomingGrayPointers
)
;
for
(
Compartment
:
:
ObjectWrapperEnum
e
(
c
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
AssertNotOnGrayList
(
e
.
front
(
)
.
value
(
)
.
unbarrieredGet
(
)
)
;
}
}
#
endif
}
static
JSObject
*
CrossCompartmentPointerReferent
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
IsGrayListObject
(
obj
)
)
;
return
&
obj
-
>
as
<
ProxyObject
>
(
)
.
private_
(
)
.
toObject
(
)
;
}
static
JSObject
*
NextIncomingCrossCompartmentPointer
(
JSObject
*
prev
bool
unlink
)
{
unsigned
slot
=
ProxyObject
:
:
grayLinkReservedSlot
(
prev
)
;
JSObject
*
next
=
GetProxyReservedSlot
(
prev
slot
)
.
toObjectOrNull
(
)
;
MOZ_ASSERT_IF
(
next
IsGrayListObject
(
next
)
)
;
if
(
unlink
)
{
SetProxyReservedSlot
(
prev
slot
UndefinedValue
(
)
)
;
}
return
next
;
}
void
js
:
:
gc
:
:
DelayCrossCompartmentGrayMarking
(
GCMarker
*
maybeMarker
JSObject
*
src
)
{
MOZ_ASSERT_IF
(
!
maybeMarker
!
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
MOZ_ASSERT
(
IsGrayListObject
(
src
)
)
;
MOZ_ASSERT
(
src
-
>
isMarkedGray
(
)
)
;
AutoTouchingGrayThings
tgt
;
mozilla
:
:
Maybe
<
AutoLockGC
>
lock
;
if
(
maybeMarker
&
&
maybeMarker
-
>
isParallelMarking
(
)
)
{
lock
.
emplace
(
maybeMarker
-
>
runtime
(
)
)
;
}
unsigned
slot
=
ProxyObject
:
:
grayLinkReservedSlot
(
src
)
;
JSObject
*
dest
=
CrossCompartmentPointerReferent
(
src
)
;
Compartment
*
comp
=
dest
-
>
compartment
(
)
;
if
(
GetProxyReservedSlot
(
src
slot
)
.
isUndefined
(
)
)
{
SetProxyReservedSlot
(
src
slot
ObjectOrNullValue
(
comp
-
>
gcIncomingGrayPointers
)
)
;
comp
-
>
gcIncomingGrayPointers
=
src
;
}
else
{
MOZ_ASSERT
(
GetProxyReservedSlot
(
src
slot
)
.
isObjectOrNull
(
)
)
;
}
#
ifdef
DEBUG
JSObject
*
obj
=
comp
-
>
gcIncomingGrayPointers
;
bool
found
=
false
;
while
(
obj
)
{
if
(
obj
=
=
src
)
{
found
=
true
;
}
obj
=
NextIncomingCrossCompartmentPointer
(
obj
false
)
;
}
MOZ_ASSERT
(
found
)
;
#
endif
}
void
GCRuntime
:
:
markIncomingGrayCrossCompartmentPointers
(
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK_INCOMING_GRAY
)
;
for
(
SweepGroupCompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
MOZ_ASSERT
(
c
-
>
zone
(
)
-
>
isGCMarkingBlackAndGray
(
)
)
;
MOZ_ASSERT_IF
(
c
-
>
gcIncomingGrayPointers
IsGrayListObject
(
c
-
>
gcIncomingGrayPointers
)
)
;
for
(
JSObject
*
src
=
c
-
>
gcIncomingGrayPointers
;
src
;
src
=
NextIncomingCrossCompartmentPointer
(
src
true
)
)
{
JSObject
*
dst
=
CrossCompartmentPointerReferent
(
src
)
;
MOZ_ASSERT
(
dst
-
>
compartment
(
)
=
=
c
)
;
MOZ_ASSERT_IF
(
src
-
>
asTenured
(
)
.
isMarkedBlack
(
)
dst
-
>
asTenured
(
)
.
isMarkedBlack
(
)
)
;
if
(
src
-
>
asTenured
(
)
.
isMarkedGray
(
)
)
{
TraceManuallyBarrieredEdge
(
marker
(
)
.
tracer
(
)
&
dst
"
cross
-
compartment
gray
pointer
"
)
;
}
}
c
-
>
gcIncomingGrayPointers
=
nullptr
;
}
}
static
bool
RemoveFromGrayList
(
JSObject
*
wrapper
)
{
AutoTouchingGrayThings
tgt
;
if
(
!
IsGrayListObject
(
wrapper
)
)
{
return
false
;
}
unsigned
slot
=
ProxyObject
:
:
grayLinkReservedSlot
(
wrapper
)
;
if
(
GetProxyReservedSlot
(
wrapper
slot
)
.
isUndefined
(
)
)
{
return
false
;
}
JSObject
*
tail
=
GetProxyReservedSlot
(
wrapper
slot
)
.
toObjectOrNull
(
)
;
SetProxyReservedSlot
(
wrapper
slot
UndefinedValue
(
)
)
;
Compartment
*
comp
=
CrossCompartmentPointerReferent
(
wrapper
)
-
>
compartment
(
)
;
JSObject
*
obj
=
comp
-
>
gcIncomingGrayPointers
;
if
(
obj
=
=
wrapper
)
{
comp
-
>
gcIncomingGrayPointers
=
tail
;
return
true
;
}
while
(
obj
)
{
unsigned
slot
=
ProxyObject
:
:
grayLinkReservedSlot
(
obj
)
;
JSObject
*
next
=
GetProxyReservedSlot
(
obj
slot
)
.
toObjectOrNull
(
)
;
if
(
next
=
=
wrapper
)
{
js
:
:
detail
:
:
SetProxyReservedSlotUnchecked
(
obj
slot
ObjectOrNullValue
(
tail
)
)
;
return
true
;
}
obj
=
next
;
}
MOZ_CRASH
(
"
object
not
found
in
gray
link
list
"
)
;
}
void
GCRuntime
:
:
resetGrayList
(
Compartment
*
comp
)
{
JSObject
*
src
=
comp
-
>
gcIncomingGrayPointers
;
while
(
src
)
{
src
=
NextIncomingCrossCompartmentPointer
(
src
true
)
;
}
comp
-
>
gcIncomingGrayPointers
=
nullptr
;
}
#
ifdef
DEBUG
static
bool
HasIncomingCrossCompartmentPointers
(
JSRuntime
*
rt
)
{
for
(
SweepGroupCompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
if
(
c
-
>
gcIncomingGrayPointers
)
{
return
true
;
}
}
return
false
;
}
#
endif
void
js
:
:
NotifyGCNukeWrapper
(
JSContext
*
cx
JSObject
*
wrapper
)
{
MOZ_ASSERT
(
IsCrossCompartmentWrapper
(
wrapper
)
)
;
RemoveFromGrayList
(
wrapper
)
;
JSObject
*
target
=
UncheckedUnwrapWithoutExpose
(
wrapper
)
;
if
(
target
-
>
is
<
WeakRefObject
>
(
)
)
{
WeakRefObject
*
weakRef
=
&
target
-
>
as
<
WeakRefObject
>
(
)
;
if
(
weakRef
-
>
target
(
)
)
{
cx
-
>
runtime
(
)
-
>
gc
.
nukeWeakRefWrapper
(
wrapper
weakRef
)
;
}
}
if
(
target
-
>
is
<
FinalizationRecordObject
>
(
)
)
{
auto
*
record
=
&
target
-
>
as
<
FinalizationRecordObject
>
(
)
;
cx
-
>
runtime
(
)
-
>
gc
.
nukeFinalizationRecordWrapper
(
wrapper
record
)
;
}
}
enum
{
JS_GC_SWAP_OBJECT_A_REMOVED
=
1
<
<
0
JS_GC_SWAP_OBJECT_B_REMOVED
=
1
<
<
1
}
;
unsigned
js
:
:
NotifyGCPreSwap
(
JSObject
*
a
JSObject
*
b
)
{
return
(
RemoveFromGrayList
(
a
)
?
JS_GC_SWAP_OBJECT_A_REMOVED
:
0
)
|
(
RemoveFromGrayList
(
b
)
?
JS_GC_SWAP_OBJECT_B_REMOVED
:
0
)
;
}
void
js
:
:
NotifyGCPostSwap
(
JSObject
*
a
JSObject
*
b
unsigned
removedFlags
)
{
if
(
removedFlags
&
JS_GC_SWAP_OBJECT_A_REMOVED
)
{
DelayCrossCompartmentGrayMarking
(
nullptr
b
)
;
}
if
(
removedFlags
&
JS_GC_SWAP_OBJECT_B_REMOVED
)
{
DelayCrossCompartmentGrayMarking
(
nullptr
a
)
;
}
}
static
inline
void
MaybeCheckWeakMapMarking
(
GCRuntime
*
gc
)
{
#
if
defined
(
JS_GC_ZEAL
)
|
|
defined
(
DEBUG
)
bool
shouldCheck
;
#
if
defined
(
DEBUG
)
shouldCheck
=
true
;
#
else
shouldCheck
=
gc
-
>
hasZealMode
(
ZealMode
:
:
CheckWeakMapMarking
)
;
#
endif
if
(
shouldCheck
)
{
for
(
SweepGroupZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_RELEASE_ASSERT
(
WeakMapBase
:
:
checkMarkingForZone
(
zone
)
)
;
}
}
#
endif
}
IncrementalProgress
GCRuntime
:
:
beginMarkingSweepGroup
(
JS
:
:
GCContext
*
gcx
SliceBudget
&
budget
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
markOnBackgroundThreadDuringSweeping
)
;
assertNoMarkingWork
(
)
;
for
(
auto
&
marker
:
markers
)
{
MOZ_ASSERT
(
marker
-
>
markColor
(
)
=
=
MarkColor
:
:
Black
)
;
}
MOZ_ASSERT
(
cellsToAssertNotGray
.
ref
(
)
.
empty
(
)
)
;
#
endif
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
changeGCState
(
zone
-
>
initialMarkingState
(
)
Zone
:
:
MarkBlackAndGray
)
;
}
AutoSetMarkColor
setColorGray
(
marker
(
)
MarkColor
:
:
Gray
)
;
markIncomingGrayCrossCompartmentPointers
(
)
;
return
Finished
;
}
IncrementalProgress
GCRuntime
:
:
markGrayRootsInCurrentGroup
(
JS
:
:
GCContext
*
gcx
SliceBudget
&
budget
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK
)
;
AutoSetMarkColor
setColorGray
(
marker
(
)
MarkColor
:
:
Gray
)
;
return
markGrayRoots
<
SweepGroupZonesIter
>
(
budget
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK_GRAY
)
;
}
IncrementalProgress
GCRuntime
:
:
markGray
(
JS
:
:
GCContext
*
gcx
SliceBudget
&
budget
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK
)
;
if
(
markUntilBudgetExhausted
(
budget
AllowParallelMarking
)
=
=
NotFinished
)
{
return
NotFinished
;
}
return
Finished
;
}
IncrementalProgress
GCRuntime
:
:
endMarkingSweepGroup
(
JS
:
:
GCContext
*
gcx
SliceBudget
&
budget
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
markOnBackgroundThreadDuringSweeping
)
;
assertNoMarkingWork
(
)
;
for
(
auto
&
marker
:
markers
)
{
MOZ_ASSERT
(
marker
-
>
markColor
(
)
=
=
MarkColor
:
:
Black
)
;
}
MOZ_ASSERT
(
!
HasIncomingCrossCompartmentPointers
(
rt
)
)
;
#
endif
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK
)
;
if
(
markWeakReferencesInCurrentGroup
(
budget
)
=
=
NotFinished
)
{
return
NotFinished
;
}
AutoSetMarkColor
setColorGray
(
marker
(
)
MarkColor
:
:
Gray
)
;
if
(
markWeakReferencesInCurrentGroup
(
budget
)
=
=
NotFinished
)
{
return
NotFinished
;
}
MOZ_ASSERT
(
marker
(
)
.
isDrained
(
)
)
;
safeToYield
=
false
;
MaybeCheckWeakMapMarking
(
this
)
;
return
Finished
;
}
class
ImmediateSweepWeakCacheTask
:
public
GCParallelTask
{
Zone
*
zone
;
JS
:
:
detail
:
:
WeakCacheBase
&
cache
;
ImmediateSweepWeakCacheTask
(
const
ImmediateSweepWeakCacheTask
&
)
=
delete
;
public
:
ImmediateSweepWeakCacheTask
(
GCRuntime
*
gc
Zone
*
zone
JS
:
:
detail
:
:
WeakCacheBase
&
wc
)
:
GCParallelTask
(
gc
gcstats
:
:
PhaseKind
:
:
SWEEP_WEAK_CACHES
)
zone
(
zone
)
cache
(
wc
)
{
}
ImmediateSweepWeakCacheTask
(
ImmediateSweepWeakCacheTask
&
&
other
)
:
GCParallelTask
(
std
:
:
move
(
other
)
)
zone
(
other
.
zone
)
cache
(
other
.
cache
)
{
}
void
run
(
AutoLockHelperThreadState
&
lock
)
override
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
AutoSetThreadIsSweeping
threadIsSweeping
(
zone
)
;
SweepingTracer
trc
(
gc
-
>
rt
)
;
cache
.
traceWeak
(
&
trc
&
gc
-
>
storeBuffer
(
)
)
;
}
}
;
void
GCRuntime
:
:
updateAtomsBitmap
(
)
{
DenseBitmap
marked
;
if
(
atomMarking
.
computeBitmapFromChunkMarkBits
(
rt
marked
)
)
{
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
atomMarking
.
refineZoneBitmapForCollectedZone
(
zone
marked
)
;
}
}
else
{
}
atomMarking
.
markAtomsUsedByUncollectedZones
(
rt
)
;
SweepingTracer
trc
(
rt
)
;
rt
-
>
symbolRegistry
(
)
.
traceWeak
(
&
trc
)
;
}
void
GCRuntime
:
:
sweepCCWrappers
(
)
{
SweepingTracer
trc
(
rt
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
traceWeakCCWEdges
(
&
trc
)
;
}
}
void
GCRuntime
:
:
sweepRealmGlobals
(
)
{
SweepingTracer
trc
(
rt
)
;
for
(
SweepGroupRealmsIter
r
(
this
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
r
-
>
zone
(
)
)
;
r
-
>
traceWeakGlobalEdge
(
&
trc
)
;
}
}
void
GCRuntime
:
:
sweepMisc
(
)
{
SweepingTracer
trc
(
rt
)
;
for
(
SweepGroupRealmsIter
r
(
this
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
r
-
>
zone
(
)
)
;
r
-
>
traceWeakSavedStacks
(
&
trc
)
;
r
-
>
traceWeakRegExps
(
&
trc
)
;
}
for
(
SweepGroupCompartmentsIter
c
(
this
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
c
-
>
zone
(
)
)
;
c
-
>
traceWeakNativeIterators
(
&
trc
)
;
}
}
void
GCRuntime
:
:
sweepCompressionTasks
(
)
{
JSRuntime
*
runtime
=
rt
;
AutoLockHelperThreadState
lock
;
AttachFinishedCompressions
(
runtime
lock
)
;
SweepPendingCompressions
(
lock
)
;
}
void
GCRuntime
:
:
sweepWeakMaps
(
)
{
SweepingTracer
trc
(
rt
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
zone
-
>
gcEphemeronEdges
(
)
.
clear
(
)
)
{
oomUnsafe
.
crash
(
"
clearing
weak
keys
in
beginSweepingSweepGroup
(
)
"
)
;
}
AutoLockStoreBuffer
lock
(
&
storeBuffer
(
)
)
;
zone
-
>
sweepWeakMaps
(
&
trc
)
;
}
}
void
GCRuntime
:
:
sweepUniqueIds
(
)
{
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
zone
)
;
zone
-
>
sweepUniqueIds
(
)
;
}
}
void
JS
:
:
Zone
:
:
sweepUniqueIds
(
)
{
SweepingTracer
trc
(
runtimeFromAnyThread
(
)
)
;
uniqueIds
(
)
.
traceWeak
(
&
trc
)
;
}
bool
UniqueIdGCPolicy
:
:
traceWeak
(
JSTracer
*
trc
Cell
*
*
keyp
uint64_t
*
valuep
)
{
MOZ_ASSERT
(
trc
-
>
kind
(
)
=
=
JS
:
:
TracerKind
:
:
Sweeping
)
;
return
(
*
keyp
)
-
>
isMarkedAny
(
)
;
}
void
GCRuntime
:
:
sweepFinalizationObserversOnMainThread
(
)
{
gcstats
:
:
AutoPhase
ap1
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_COMPARTMENTS
)
;
gcstats
:
:
AutoPhase
ap2
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_FINALIZATION_OBSERVERS
)
;
SweepingTracer
trc
(
rt
)
;
AutoLockStoreBuffer
lock
(
&
storeBuffer
(
)
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
traceWeakFinalizationObserverEdges
(
&
trc
zone
)
;
}
}
void
GCRuntime
:
:
startTask
(
GCParallelTask
&
task
AutoLockHelperThreadState
&
lock
)
{
if
(
!
CanUseExtraThreads
(
)
)
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
task
.
runFromMainThread
(
)
;
stats
(
)
.
recordParallelPhase
(
task
.
phaseKind
task
.
duration
(
)
)
;
return
;
}
task
.
startWithLockHeld
(
lock
)
;
}
void
GCRuntime
:
:
joinTask
(
GCParallelTask
&
task
AutoLockHelperThreadState
&
lock
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
JOIN_PARALLEL_TASKS
)
;
task
.
joinWithLockHeld
(
lock
)
;
}
void
GCRuntime
:
:
sweepDebuggerOnMainThread
(
JS
:
:
GCContext
*
gcx
)
{
SweepingTracer
trc
(
rt
)
;
AutoLockStoreBuffer
lock
(
&
storeBuffer
(
)
)
;
DebugAPI
:
:
sweepAll
(
gcx
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_COMPARTMENTS
)
;
{
gcstats
:
:
AutoPhase
ap2
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_MISC
)
;
for
(
SweepGroupRealmsIter
r
(
rt
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
r
-
>
traceWeakDebugEnvironmentEdges
(
&
trc
)
;
}
}
}
void
GCRuntime
:
:
sweepJitDataOnMainThread
(
JS
:
:
GCContext
*
gcx
)
{
SweepingTracer
trc
(
rt
)
;
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_JIT_DATA
)
;
if
(
initialState
!
=
State
:
:
NotActive
)
{
js
:
:
CancelOffThreadIonCompile
(
rt
JS
:
:
Zone
:
:
Sweep
)
;
}
jit
:
:
JitRuntime
:
:
TraceWeakJitcodeGlobalTable
(
rt
&
trc
)
;
}
if
(
initialState
!
=
State
:
:
NotActive
)
{
gcstats
:
:
AutoPhase
apdc
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_DISCARD_CODE
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
discardJitCode
(
gcx
)
;
}
}
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_JIT_DATA
)
;
for
(
SweepGroupRealmsIter
r
(
rt
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
r
-
>
traceWeakEdgesInJitRealm
(
&
trc
)
;
}
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
jit
:
:
JitZone
*
jitZone
=
zone
-
>
jitZone
(
)
)
{
jitZone
-
>
traceWeak
(
&
trc
)
;
}
}
}
}
using
WeakCacheTaskVector
=
mozilla
:
:
Vector
<
ImmediateSweepWeakCacheTask
0
SystemAllocPolicy
>
;
template
<
typename
Functor
>
static
inline
bool
IterateWeakCaches
(
JSRuntime
*
rt
Functor
f
)
{
for
(
SweepGroupZonesIter
zone
(
rt
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
JS
:
:
detail
:
:
WeakCacheBase
*
cache
:
zone
-
>
weakCaches
(
)
)
{
if
(
!
f
(
cache
zone
.
get
(
)
)
)
{
return
false
;
}
}
}
for
(
JS
:
:
detail
:
:
WeakCacheBase
*
cache
:
rt
-
>
weakCaches
(
)
)
{
if
(
!
f
(
cache
nullptr
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
PrepareWeakCacheTasks
(
JSRuntime
*
rt
WeakCacheTaskVector
*
immediateTasks
)
{
MOZ_ASSERT
(
immediateTasks
-
>
empty
(
)
)
;
GCRuntime
*
gc
=
&
rt
-
>
gc
;
bool
ok
=
IterateWeakCaches
(
rt
[
&
]
(
JS
:
:
detail
:
:
WeakCacheBase
*
cache
Zone
*
zone
)
{
if
(
cache
-
>
empty
(
)
)
{
return
true
;
}
if
(
zone
&
&
cache
-
>
setIncrementalBarrierTracer
(
&
gc
-
>
sweepingTracer
)
)
{
return
true
;
}
return
immediateTasks
-
>
emplaceBack
(
gc
zone
*
cache
)
;
}
)
;
if
(
!
ok
)
{
immediateTasks
-
>
clearAndFree
(
)
;
}
return
ok
;
}
static
void
SweepAllWeakCachesOnMainThread
(
JSRuntime
*
rt
)
{
gcstats
:
:
AutoPhase
ap
(
rt
-
>
gc
.
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_WEAK_CACHES
)
;
SweepingTracer
trc
(
rt
)
;
IterateWeakCaches
(
rt
[
&
]
(
JS
:
:
detail
:
:
WeakCacheBase
*
cache
Zone
*
zone
)
{
if
(
cache
-
>
needsIncrementalBarrier
(
)
)
{
cache
-
>
setIncrementalBarrierTracer
(
nullptr
)
;
}
cache
-
>
traceWeak
(
&
trc
&
rt
-
>
gc
.
storeBuffer
(
)
)
;
return
true
;
}
)
;
}
void
GCRuntime
:
:
sweepEmbeddingWeakPointers
(
JS
:
:
GCContext
*
gcx
)
{
using
namespace
gcstats
;
AutoLockStoreBuffer
lock
(
&
storeBuffer
(
)
)
;
AutoPhase
ap
(
stats
(
)
PhaseKind
:
:
FINALIZE_START
)
;
callFinalizeCallbacks
(
gcx
JSFINALIZE_GROUP_PREPARE
)
;
{
AutoPhase
ap2
(
stats
(
)
PhaseKind
:
:
WEAK_ZONES_CALLBACK
)
;
callWeakPointerZonesCallbacks
(
&
sweepingTracer
)
;
}
{
AutoPhase
ap2
(
stats
(
)
PhaseKind
:
:
WEAK_COMPARTMENT_CALLBACK
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
callWeakPointerCompartmentCallbacks
(
&
sweepingTracer
comp
)
;
}
}
}
callFinalizeCallbacks
(
gcx
JSFINALIZE_GROUP_START
)
;
}
IncrementalProgress
GCRuntime
:
:
beginSweepingSweepGroup
(
JS
:
:
GCContext
*
gcx
SliceBudget
&
budget
)
{
using
namespace
gcstats
;
AutoSCC
scc
(
stats
(
)
sweepGroupIndex
)
;
bool
sweepingAtoms
=
false
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
changeGCState
(
Zone
:
:
MarkBlackAndGray
Zone
:
:
Sweep
)
;
zone
-
>
arenas
.
checkSweepStateNotInUse
(
)
;
zone
-
>
arenas
.
unmarkPreMarkedFreeCells
(
)
;
zone
-
>
arenas
.
clearFreeLists
(
)
;
if
(
zone
-
>
isAtomsZone
(
)
)
{
sweepingAtoms
=
true
;
}
}
#
ifdef
JS_GC_ZEAL
validateIncrementalMarking
(
)
;
#
endif
#
ifdef
DEBUG
for
(
auto
cell
:
cellsToAssertNotGray
.
ref
(
)
)
{
JS
:
:
AssertCellIsNotGray
(
cell
)
;
}
cellsToAssertNotGray
.
ref
(
)
.
clearAndFree
(
)
;
#
endif
if
(
sweepingAtoms
)
{
AutoPhase
ap
(
stats
(
)
PhaseKind
:
:
UPDATE_ATOMS_BITMAP
)
;
updateAtomsBitmap
(
)
;
}
AutoSetThreadIsSweeping
threadIsSweeping
;
sweepDebuggerOnMainThread
(
gcx
)
;
sweepFinalizationObserversOnMainThread
(
)
;
sweepRealmGlobals
(
)
;
sweepEmbeddingWeakPointers
(
gcx
)
;
{
AutoLockHelperThreadState
lock
;
AutoPhase
ap
(
stats
(
)
PhaseKind
:
:
SWEEP_COMPARTMENTS
)
;
AutoRunParallelTask
sweepCCWrappers
(
this
&
GCRuntime
:
:
sweepCCWrappers
PhaseKind
:
:
SWEEP_CC_WRAPPER
GCUse
:
:
Sweeping
lock
)
;
AutoRunParallelTask
sweepMisc
(
this
&
GCRuntime
:
:
sweepMisc
PhaseKind
:
:
SWEEP_MISC
GCUse
:
:
Sweeping
lock
)
;
AutoRunParallelTask
sweepCompTasks
(
this
&
GCRuntime
:
:
sweepCompressionTasks
PhaseKind
:
:
SWEEP_COMPRESSION
GCUse
:
:
Sweeping
lock
)
;
AutoRunParallelTask
sweepWeakMaps
(
this
&
GCRuntime
:
:
sweepWeakMaps
PhaseKind
:
:
SWEEP_WEAKMAPS
GCUse
:
:
Sweeping
lock
)
;
AutoRunParallelTask
sweepUniqueIds
(
this
&
GCRuntime
:
:
sweepUniqueIds
PhaseKind
:
:
SWEEP_UNIQUEIDS
GCUse
:
:
Sweeping
lock
)
;
WeakCacheTaskVector
sweepCacheTasks
;
bool
canSweepWeakCachesOffThread
=
PrepareWeakCacheTasks
(
rt
&
sweepCacheTasks
)
;
if
(
canSweepWeakCachesOffThread
)
{
weakCachesToSweep
.
ref
(
)
.
emplace
(
currentSweepGroup
)
;
for
(
auto
&
task
:
sweepCacheTasks
)
{
startTask
(
task
lock
)
;
}
}
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
sweepJitDataOnMainThread
(
gcx
)
;
if
(
!
canSweepWeakCachesOffThread
)
{
MOZ_ASSERT
(
sweepCacheTasks
.
empty
(
)
)
;
SweepAllWeakCachesOnMainThread
(
rt
)
;
}
}
for
(
auto
&
task
:
sweepCacheTasks
)
{
joinTask
(
task
lock
)
;
}
}
if
(
sweepingAtoms
)
{
startSweepingAtomsTable
(
)
;
}
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
const
auto
&
phase
:
BackgroundFinalizePhases
)
{
initBackgroundSweep
(
zone
gcx
phase
)
;
}
zone
-
>
arenas
.
queueForegroundThingsForSweep
(
)
;
}
MOZ_ASSERT
(
!
sweepZone
)
;
safeToYield
=
true
;
markOnBackgroundThreadDuringSweeping
=
CanUseExtraThreads
(
)
;
return
Finished
;
}
#
ifdef
JS_GC_ZEAL
bool
GCRuntime
:
:
shouldYieldForZeal
(
ZealMode
mode
)
{
bool
yield
=
useZeal
&
&
hasZealMode
(
mode
)
;
bool
firstSweepSlice
=
initialState
!
=
State
:
:
Sweep
;
if
(
mode
=
=
ZealMode
:
:
IncrementalMultipleSlices
&
&
!
firstSweepSlice
)
{
yield
=
false
;
}
return
yield
;
}
#
endif
IncrementalProgress
GCRuntime
:
:
endSweepingSweepGroup
(
JS
:
:
GCContext
*
gcx
SliceBudget
&
budget
)
{
if
(
joinBackgroundMarkTask
(
)
=
=
NotFinished
)
{
return
NotFinished
;
}
assertNoMarkingWork
(
)
;
markOnBackgroundThreadDuringSweeping
=
false
;
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
FINALIZE_END
)
;
AutoLockStoreBuffer
lock
(
&
storeBuffer
(
)
)
;
callFinalizeCallbacks
(
gcx
JSFINALIZE_GROUP_END
)
;
}
startBackgroundFree
(
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
jit
:
:
JitZone
*
jitZone
=
zone
-
>
jitZone
(
)
)
{
jitZone
-
>
execAlloc
(
)
.
purge
(
)
;
}
AutoLockGC
lock
(
this
)
;
zone
-
>
changeGCState
(
Zone
:
:
Sweep
Zone
:
:
Finished
)
;
zone
-
>
arenas
.
unmarkPreMarkedFreeCells
(
)
;
zone
-
>
arenas
.
checkNoArenasToUpdate
(
)
;
zone
-
>
pretenuring
.
clearCellCountsInNewlyCreatedArenas
(
)
;
}
ZoneList
zones
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
isAtomsZone
(
)
)
{
zones
.
append
(
zone
)
;
}
else
{
zones
.
prepend
(
zone
)
;
}
}
queueZonesAndStartBackgroundSweep
(
std
:
:
move
(
zones
)
)
;
return
Finished
;
}
IncrementalProgress
GCRuntime
:
:
markDuringSweeping
(
JS
:
:
GCContext
*
gcx
SliceBudget
&
budget
)
{
MOZ_ASSERT
(
markTask
.
isIdle
(
)
)
;
if
(
markOnBackgroundThreadDuringSweeping
)
{
if
(
!
marker
(
)
.
isDrained
(
)
)
{
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
markTask
.
isIdle
(
lock
)
)
;
markTask
.
setBudget
(
budget
)
;
markTask
.
startOrRunIfIdle
(
lock
)
;
}
return
Finished
;
}
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK
)
;
return
markUntilBudgetExhausted
(
budget
AllowParallelMarking
)
;
}
void
GCRuntime
:
:
beginSweepPhase
(
JS
:
:
GCReason
reason
AutoGCSession
&
session
)
{
MOZ_ASSERT
(
!
abortSweepAfterCurrentGroup
)
;
MOZ_ASSERT
(
!
markOnBackgroundThreadDuringSweeping
)
;
#
ifdef
DEBUG
releaseHeldRelocatedArenas
(
)
;
verifyAllChunks
(
)
;
#
endif
#
ifdef
JS_GC_ZEAL
computeNonIncrementalMarkingForValidation
(
session
)
;
#
endif
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP
)
;
AssertNoWrappersInGrayList
(
rt
)
;
dropStringWrappers
(
)
;
groupZonesForSweeping
(
reason
)
;
sweepActions
-
>
assertFinished
(
)
;
}
bool
GCRuntime
:
:
foregroundFinalize
(
JS
:
:
GCContext
*
gcx
Zone
*
zone
AllocKind
thingKind
SliceBudget
&
sliceBudget
SortedArenaList
&
sweepList
)
{
ArenaLists
&
lists
=
zone
-
>
arenas
;
lists
.
checkNoArenasToUpdateForKind
(
thingKind
)
;
if
(
!
FinalizeArenas
(
gcx
lists
.
collectingArenaList
(
thingKind
)
sweepList
thingKind
sliceBudget
)
)
{
lists
.
setIncrementalSweptArenas
(
thingKind
sweepList
)
;
return
false
;
}
sweepList
.
extractEmpty
(
&
lists
.
savedEmptyArenas
.
ref
(
)
)
;
lists
.
mergeFinalizedArenas
(
thingKind
sweepList
)
;
lists
.
clearIncrementalSweptArenas
(
)
;
return
true
;
}
BackgroundMarkTask
:
:
BackgroundMarkTask
(
GCRuntime
*
gc
)
:
GCParallelTask
(
gc
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK
GCUse
:
:
Marking
)
budget
(
SliceBudget
:
:
unlimited
(
)
)
{
}
void
js
:
:
gc
:
:
BackgroundMarkTask
:
:
run
(
AutoLockHelperThreadState
&
lock
)
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
gc
-
>
sweepMarkResult
=
gc
-
>
markUntilBudgetExhausted
(
this
-
>
budget
GCRuntime
:
:
SingleThreadedMarking
DontReportMarkTime
)
;
}
IncrementalProgress
GCRuntime
:
:
joinBackgroundMarkTask
(
)
{
AutoLockHelperThreadState
lock
;
if
(
markTask
.
isIdle
(
lock
)
)
{
return
Finished
;
}
joinTask
(
markTask
lock
)
;
IncrementalProgress
result
=
sweepMarkResult
;
sweepMarkResult
=
Finished
;
return
result
;
}
template
<
typename
T
>
static
void
SweepThing
(
JS
:
:
GCContext
*
gcx
T
*
thing
)
{
if
(
!
TenuredThingIsMarkedAny
(
thing
)
)
{
thing
-
>
sweep
(
gcx
)
;
}
}
template
<
typename
T
>
static
bool
SweepArenaList
(
JS
:
:
GCContext
*
gcx
Arena
*
*
arenasToSweep
SliceBudget
&
sliceBudget
)
{
while
(
Arena
*
arena
=
*
arenasToSweep
)
{
MOZ_ASSERT
(
arena
-
>
zone
-
>
isGCSweeping
(
)
)
;
for
(
ArenaCellIterUnderGC
cell
(
arena
)
;
!
cell
.
done
(
)
;
cell
.
next
(
)
)
{
SweepThing
(
gcx
cell
.
as
<
T
>
(
)
)
;
}
Arena
*
next
=
arena
-
>
next
;
MOZ_ASSERT_IF
(
next
next
-
>
zone
=
=
arena
-
>
zone
)
;
*
arenasToSweep
=
next
;
AllocKind
kind
=
MapTypeToAllocKind
<
T
>
:
:
kind
;
sliceBudget
.
step
(
Arena
:
:
thingsPerArena
(
kind
)
)
;
if
(
sliceBudget
.
isOverBudget
(
)
)
{
return
false
;
}
}
return
true
;
}
void
GCRuntime
:
:
startSweepingAtomsTable
(
)
{
auto
&
maybeAtoms
=
maybeAtomsToSweep
.
ref
(
)
;
MOZ_ASSERT
(
maybeAtoms
.
isNothing
(
)
)
;
AtomsTable
*
atomsTable
=
rt
-
>
atomsForSweeping
(
)
;
if
(
!
atomsTable
)
{
return
;
}
if
(
!
atomsTable
-
>
startIncrementalSweep
(
maybeAtoms
)
)
{
SweepingTracer
trc
(
rt
)
;
atomsTable
-
>
traceWeak
(
&
trc
)
;
}
}
IncrementalProgress
GCRuntime
:
:
sweepAtomsTable
(
JS
:
:
GCContext
*
gcx
SliceBudget
&
budget
)
{
if
(
!
atomsZone
(
)
-
>
isGCSweeping
(
)
)
{
return
Finished
;
}
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_ATOMS_TABLE
)
;
auto
&
maybeAtoms
=
maybeAtomsToSweep
.
ref
(
)
;
if
(
!
maybeAtoms
)
{
return
Finished
;
}
if
(
!
rt
-
>
atomsForSweeping
(
)
-
>
sweepIncrementally
(
maybeAtoms
.
ref
(
)
budget
)
)
{
return
NotFinished
;
}
maybeAtoms
.
reset
(
)
;
return
Finished
;
}
static
size_t
IncrementalSweepWeakCache
(
GCRuntime
*
gc
const
WeakCacheToSweep
&
item
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
item
.
zone
)
;
JS
:
:
detail
:
:
WeakCacheBase
*
cache
=
item
.
cache
;
MOZ_ASSERT
(
cache
-
>
needsIncrementalBarrier
(
)
)
;
SweepingTracer
trc
(
gc
-
>
rt
)
;
size_t
steps
=
cache
-
>
traceWeak
(
&
trc
&
gc
-
>
storeBuffer
(
)
)
;
cache
-
>
setIncrementalBarrierTracer
(
nullptr
)
;
return
steps
;
}
WeakCacheSweepIterator
:
:
WeakCacheSweepIterator
(
JS
:
:
Zone
*
sweepGroup
)
:
sweepZone
(
sweepGroup
)
sweepCache
(
sweepZone
-
>
weakCaches
(
)
.
getFirst
(
)
)
{
settle
(
)
;
}
bool
WeakCacheSweepIterator
:
:
done
(
)
const
{
return
!
sweepZone
;
}
WeakCacheToSweep
WeakCacheSweepIterator
:
:
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
{
sweepCache
sweepZone
}
;
}
void
WeakCacheSweepIterator
:
:
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
sweepCache
=
sweepCache
-
>
getNext
(
)
;
settle
(
)
;
}
void
WeakCacheSweepIterator
:
:
settle
(
)
{
while
(
sweepZone
)
{
while
(
sweepCache
&
&
!
sweepCache
-
>
needsIncrementalBarrier
(
)
)
{
sweepCache
=
sweepCache
-
>
getNext
(
)
;
}
if
(
sweepCache
)
{
break
;
}
sweepZone
=
sweepZone
-
>
nextNodeInGroup
(
)
;
if
(
sweepZone
)
{
sweepCache
=
sweepZone
-
>
weakCaches
(
)
.
getFirst
(
)
;
}
}
MOZ_ASSERT
(
(
!
sweepZone
&
&
!
sweepCache
)
|
|
(
sweepCache
&
&
sweepCache
-
>
needsIncrementalBarrier
(
)
)
)
;
}
IncrementalProgress
GCRuntime
:
:
sweepWeakCaches
(
JS
:
:
GCContext
*
gcx
SliceBudget
&
budget
)
{
if
(
weakCachesToSweep
.
ref
(
)
.
isNothing
(
)
)
{
return
Finished
;
}
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_COMPARTMENTS
)
;
WeakCacheSweepIterator
&
work
=
weakCachesToSweep
.
ref
(
)
.
ref
(
)
;
AutoLockHelperThreadState
lock
;
{
AutoRunParallelWork
runWork
(
this
IncrementalSweepWeakCache
gcstats
:
:
PhaseKind
:
:
SWEEP_WEAK_CACHES
GCUse
:
:
Sweeping
work
budget
lock
)
;
AutoUnlockHelperThreadState
unlock
(
lock
)
;
}
if
(
work
.
done
(
)
)
{
weakCachesToSweep
.
ref
(
)
.
reset
(
)
;
return
Finished
;
}
return
NotFinished
;
}
IncrementalProgress
GCRuntime
:
:
finalizeAllocKind
(
JS
:
:
GCContext
*
gcx
SliceBudget
&
budget
)
{
MOZ_ASSERT
(
sweepZone
-
>
isGCSweeping
(
)
)
;
size_t
thingsPerArena
=
Arena
:
:
thingsPerArena
(
sweepAllocKind
)
;
auto
&
sweepList
=
incrementalSweepList
.
ref
(
)
;
sweepList
.
setThingsPerArena
(
thingsPerArena
)
;
AutoSetThreadIsFinalizing
threadIsFinalizing
(
gcx
)
;
if
(
!
foregroundFinalize
(
gcx
sweepZone
sweepAllocKind
budget
sweepList
)
)
{
return
NotFinished
;
}
sweepList
.
reset
(
thingsPerArena
)
;
return
Finished
;
}
IncrementalProgress
GCRuntime
:
:
sweepPropMapTree
(
JS
:
:
GCContext
*
gcx
SliceBudget
&
budget
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_PROP_MAP
)
;
ArenaLists
&
al
=
sweepZone
-
>
arenas
;
if
(
!
SweepArenaList
<
CompactPropMap
>
(
gcx
&
al
.
gcCompactPropMapArenasToUpdate
.
ref
(
)
budget
)
)
{
return
NotFinished
;
}
if
(
!
SweepArenaList
<
NormalPropMap
>
(
gcx
&
al
.
gcNormalPropMapArenasToUpdate
.
ref
(
)
budget
)
)
{
return
NotFinished
;
}
return
Finished
;
}
template
<
typename
Container
>
class
ContainerIter
{
using
Iter
=
decltype
(
std
:
:
declval
<
const
Container
>
(
)
.
begin
(
)
)
;
using
Elem
=
decltype
(
*
std
:
:
declval
<
Iter
>
(
)
)
;
Iter
iter
;
const
Iter
end
;
public
:
explicit
ContainerIter
(
const
Container
&
container
)
:
iter
(
container
.
begin
(
)
)
end
(
container
.
end
(
)
)
{
}
bool
done
(
)
const
{
return
iter
=
=
end
;
}
Elem
get
(
)
const
{
return
*
iter
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
+
+
iter
;
}
}
;
template
<
typename
Iter
>
struct
IncrementalIter
{
using
State
=
mozilla
:
:
Maybe
<
Iter
>
;
using
Elem
=
decltype
(
std
:
:
declval
<
Iter
>
(
)
.
get
(
)
)
;
private
:
State
&
maybeIter
;
public
:
template
<
typename
.
.
.
Args
>
explicit
IncrementalIter
(
State
&
maybeIter
Args
&
&
.
.
.
args
)
:
maybeIter
(
maybeIter
)
{
if
(
maybeIter
.
isNothing
(
)
)
{
maybeIter
.
emplace
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
~
IncrementalIter
(
)
{
if
(
done
(
)
)
{
maybeIter
.
reset
(
)
;
}
}
bool
done
(
)
const
{
return
maybeIter
.
ref
(
)
.
done
(
)
;
}
Elem
get
(
)
const
{
return
maybeIter
.
ref
(
)
.
get
(
)
;
}
void
next
(
)
{
maybeIter
.
ref
(
)
.
next
(
)
;
}
}
;
class
js
:
:
gc
:
:
SweepGroupsIter
{
GCRuntime
*
gc
;
public
:
explicit
SweepGroupsIter
(
JSRuntime
*
rt
)
:
gc
(
&
rt
-
>
gc
)
{
MOZ_ASSERT
(
gc
-
>
currentSweepGroup
)
;
}
bool
done
(
)
const
{
return
!
gc
-
>
currentSweepGroup
;
}
Zone
*
get
(
)
const
{
return
gc
-
>
currentSweepGroup
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
gc
-
>
getNextSweepGroup
(
)
;
}
}
;
namespace
sweepaction
{
class
SweepActionCall
final
:
public
SweepAction
{
using
Method
=
IncrementalProgress
(
GCRuntime
:
:
*
)
(
JS
:
:
GCContext
*
gcx
SliceBudget
&
budget
)
;
Method
method
;
public
:
explicit
SweepActionCall
(
Method
m
)
:
method
(
m
)
{
}
IncrementalProgress
run
(
Args
&
args
)
override
{
return
(
args
.
gc
-
>
*
method
)
(
args
.
gcx
args
.
budget
)
;
}
void
assertFinished
(
)
const
override
{
}
}
;
class
SweepActionMaybeYield
final
:
public
SweepAction
{
#
ifdef
JS_GC_ZEAL
ZealMode
mode
;
bool
isYielding
;
#
endif
public
:
explicit
SweepActionMaybeYield
(
ZealMode
mode
)
#
ifdef
JS_GC_ZEAL
:
mode
(
mode
)
isYielding
(
false
)
#
endif
{
}
IncrementalProgress
run
(
Args
&
args
)
override
{
#
ifdef
JS_GC_ZEAL
if
(
!
isYielding
&
&
args
.
gc
-
>
shouldYieldForZeal
(
mode
)
)
{
isYielding
=
true
;
return
NotFinished
;
}
isYielding
=
false
;
#
endif
return
Finished
;
}
void
assertFinished
(
)
const
override
{
MOZ_ASSERT
(
!
isYielding
)
;
}
#
ifndef
JS_GC_ZEAL
bool
shouldSkip
(
)
override
{
return
true
;
}
#
endif
}
;
class
SweepActionSequence
final
:
public
SweepAction
{
using
ActionVector
=
Vector
<
UniquePtr
<
SweepAction
>
0
SystemAllocPolicy
>
;
using
Iter
=
IncrementalIter
<
ContainerIter
<
ActionVector
>
>
;
ActionVector
actions
;
typename
Iter
:
:
State
iterState
;
public
:
bool
init
(
UniquePtr
<
SweepAction
>
*
acts
size_t
count
)
{
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
auto
&
action
=
acts
[
i
]
;
if
(
!
action
)
{
return
false
;
}
if
(
action
-
>
shouldSkip
(
)
)
{
continue
;
}
if
(
!
actions
.
emplaceBack
(
std
:
:
move
(
action
)
)
)
{
return
false
;
}
}
return
true
;
}
IncrementalProgress
run
(
Args
&
args
)
override
{
for
(
Iter
iter
(
iterState
actions
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
if
(
iter
.
get
(
)
-
>
run
(
args
)
=
=
NotFinished
)
{
return
NotFinished
;
}
}
return
Finished
;
}
void
assertFinished
(
)
const
override
{
MOZ_ASSERT
(
iterState
.
isNothing
(
)
)
;
for
(
const
auto
&
action
:
actions
)
{
action
-
>
assertFinished
(
)
;
}
}
}
;
template
<
typename
Iter
typename
Init
>
class
SweepActionForEach
final
:
public
SweepAction
{
using
Elem
=
decltype
(
std
:
:
declval
<
Iter
>
(
)
.
get
(
)
)
;
using
IncrIter
=
IncrementalIter
<
Iter
>
;
Init
iterInit
;
Elem
*
elemOut
;
UniquePtr
<
SweepAction
>
action
;
typename
IncrIter
:
:
State
iterState
;
public
:
SweepActionForEach
(
const
Init
&
init
Elem
*
maybeElemOut
UniquePtr
<
SweepAction
>
action
)
:
iterInit
(
init
)
elemOut
(
maybeElemOut
)
action
(
std
:
:
move
(
action
)
)
{
}
IncrementalProgress
run
(
Args
&
args
)
override
{
MOZ_ASSERT_IF
(
elemOut
*
elemOut
=
=
Elem
(
)
)
;
auto
clearElem
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
setElem
(
Elem
(
)
)
;
}
)
;
for
(
IncrIter
iter
(
iterState
iterInit
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
setElem
(
iter
.
get
(
)
)
;
if
(
action
-
>
run
(
args
)
=
=
NotFinished
)
{
return
NotFinished
;
}
}
return
Finished
;
}
void
assertFinished
(
)
const
override
{
MOZ_ASSERT
(
iterState
.
isNothing
(
)
)
;
MOZ_ASSERT_IF
(
elemOut
*
elemOut
=
=
Elem
(
)
)
;
action
-
>
assertFinished
(
)
;
}
private
:
void
setElem
(
const
Elem
&
value
)
{
if
(
elemOut
)
{
*
elemOut
=
value
;
}
}
}
;
static
UniquePtr
<
SweepAction
>
Call
(
IncrementalProgress
(
GCRuntime
:
:
*
method
)
(
JS
:
:
GCContext
*
gcx
SliceBudget
&
budget
)
)
{
return
MakeUnique
<
SweepActionCall
>
(
method
)
;
}
static
UniquePtr
<
SweepAction
>
MaybeYield
(
ZealMode
zealMode
)
{
return
MakeUnique
<
SweepActionMaybeYield
>
(
zealMode
)
;
}
template
<
typename
.
.
.
Rest
>
static
UniquePtr
<
SweepAction
>
Sequence
(
UniquePtr
<
SweepAction
>
first
Rest
.
.
.
rest
)
{
UniquePtr
<
SweepAction
>
actions
[
]
=
{
std
:
:
move
(
first
)
std
:
:
move
(
rest
)
.
.
.
}
;
auto
seq
=
MakeUnique
<
SweepActionSequence
>
(
)
;
if
(
!
seq
|
|
!
seq
-
>
init
(
actions
std
:
:
size
(
actions
)
)
)
{
return
nullptr
;
}
return
UniquePtr
<
SweepAction
>
(
std
:
:
move
(
seq
)
)
;
}
static
UniquePtr
<
SweepAction
>
RepeatForSweepGroup
(
JSRuntime
*
rt
UniquePtr
<
SweepAction
>
action
)
{
if
(
!
action
)
{
return
nullptr
;
}
using
Action
=
SweepActionForEach
<
SweepGroupsIter
JSRuntime
*
>
;
return
js
:
:
MakeUnique
<
Action
>
(
rt
nullptr
std
:
:
move
(
action
)
)
;
}
static
UniquePtr
<
SweepAction
>
ForEachZoneInSweepGroup
(
JSRuntime
*
rt
Zone
*
*
zoneOut
UniquePtr
<
SweepAction
>
action
)
{
if
(
!
action
)
{
return
nullptr
;
}
using
Action
=
SweepActionForEach
<
SweepGroupZonesIter
JSRuntime
*
>
;
return
js
:
:
MakeUnique
<
Action
>
(
rt
zoneOut
std
:
:
move
(
action
)
)
;
}
static
UniquePtr
<
SweepAction
>
ForEachAllocKind
(
AllocKinds
kinds
AllocKind
*
kindOut
UniquePtr
<
SweepAction
>
action
)
{
if
(
!
action
)
{
return
nullptr
;
}
using
Action
=
SweepActionForEach
<
ContainerIter
<
AllocKinds
>
AllocKinds
>
;
return
js
:
:
MakeUnique
<
Action
>
(
kinds
kindOut
std
:
:
move
(
action
)
)
;
}
}
bool
GCRuntime
:
:
initSweepActions
(
)
{
using
namespace
sweepaction
;
using
sweepaction
:
:
Call
;
sweepActions
.
ref
(
)
=
RepeatForSweepGroup
(
rt
Sequence
(
Call
(
&
GCRuntime
:
:
beginMarkingSweepGroup
)
Call
(
&
GCRuntime
:
:
markGrayRootsInCurrentGroup
)
MaybeYield
(
ZealMode
:
:
YieldWhileGrayMarking
)
Call
(
&
GCRuntime
:
:
markGray
)
Call
(
&
GCRuntime
:
:
endMarkingSweepGroup
)
Call
(
&
GCRuntime
:
:
beginSweepingSweepGroup
)
MaybeYield
(
ZealMode
:
:
IncrementalMultipleSlices
)
MaybeYield
(
ZealMode
:
:
YieldBeforeSweepingAtoms
)
Call
(
&
GCRuntime
:
:
sweepAtomsTable
)
MaybeYield
(
ZealMode
:
:
YieldBeforeSweepingCaches
)
Call
(
&
GCRuntime
:
:
sweepWeakCaches
)
ForEachZoneInSweepGroup
(
rt
&
sweepZone
.
ref
(
)
Sequence
(
MaybeYield
(
ZealMode
:
:
YieldBeforeSweepingObjects
)
ForEachAllocKind
(
ForegroundObjectFinalizePhase
.
kinds
&
sweepAllocKind
.
ref
(
)
Call
(
&
GCRuntime
:
:
finalizeAllocKind
)
)
MaybeYield
(
ZealMode
:
:
YieldBeforeSweepingNonObjects
)
ForEachAllocKind
(
ForegroundNonObjectFinalizePhase
.
kinds
&
sweepAllocKind
.
ref
(
)
Call
(
&
GCRuntime
:
:
finalizeAllocKind
)
)
MaybeYield
(
ZealMode
:
:
YieldBeforeSweepingPropMapTrees
)
Call
(
&
GCRuntime
:
:
sweepPropMapTree
)
)
)
Call
(
&
GCRuntime
:
:
endSweepingSweepGroup
)
)
)
;
return
sweepActions
!
=
nullptr
;
}
IncrementalProgress
GCRuntime
:
:
performSweepActions
(
SliceBudget
&
budget
)
{
AutoMajorGCProfilerEntry
s
(
this
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP
)
;
JS
:
:
GCContext
*
gcx
=
rt
-
>
gcContext
(
)
;
AutoSetThreadIsSweeping
threadIsSweeping
(
gcx
)
;
AutoPoisonFreedJitCode
pjc
(
gcx
)
;
AutoDisableBarriers
disableBarriers
(
this
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
initialState
<
=
State
:
:
Sweep
)
;
if
(
initialState
!
=
State
:
:
Sweep
)
{
assertNoMarkingWork
(
)
;
}
#
endif
if
(
initialState
=
=
State
:
:
Sweep
&
&
markDuringSweeping
(
gcx
budget
)
=
=
NotFinished
)
{
return
NotFinished
;
}
SweepAction
:
:
Args
args
{
this
gcx
budget
}
;
IncrementalProgress
sweepProgress
=
sweepActions
-
>
run
(
args
)
;
IncrementalProgress
markProgress
=
joinBackgroundMarkTask
(
)
;
if
(
sweepProgress
=
=
Finished
&
&
markProgress
=
=
Finished
)
{
return
Finished
;
}
MOZ_ASSERT
(
isIncremental
)
;
return
NotFinished
;
}
bool
GCRuntime
:
:
allCCVisibleZonesWereCollected
(
)
{
for
(
ZonesIter
zone
(
this
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zone
-
>
isCollecting
(
)
&
&
!
zone
-
>
arenas
.
arenaListsAreEmpty
(
)
)
{
return
false
;
}
}
return
true
;
}
void
GCRuntime
:
:
endSweepPhase
(
bool
destroyingRuntime
)
{
MOZ_ASSERT
(
!
markOnBackgroundThreadDuringSweeping
)
;
sweepActions
-
>
assertFinished
(
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP
)
;
MOZ_ASSERT_IF
(
destroyingRuntime
!
useBackgroundThreads
)
;
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
DESTROY
)
;
SweepScriptData
(
rt
)
;
}
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
FINALIZE_END
)
;
AutoLockStoreBuffer
lock
(
&
storeBuffer
(
)
)
;
callFinalizeCallbacks
(
rt
-
>
gcContext
(
)
JSFINALIZE_COLLECTION_END
)
;
if
(
allCCVisibleZonesWereCollected
(
)
)
{
grayBitsValid
=
true
;
}
}
if
(
isIncremental
)
{
findDeadCompartments
(
)
;
}
#
ifdef
JS_GC_ZEAL
finishMarkingValidation
(
)
;
#
endif
#
ifdef
DEBUG
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
auto
i
:
AllAllocKinds
(
)
)
{
MOZ_ASSERT_IF
(
!
IsBackgroundFinalized
(
i
)
|
|
!
useBackgroundThreads
zone
-
>
arenas
.
collectingArenaList
(
i
)
.
isEmpty
(
)
)
;
}
}
#
endif
AssertNoWrappersInGrayList
(
rt
)
;
}
