#
ifndef
gc_GCMarker_h
#
define
gc_GCMarker_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
XorShift128PlusRNG
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
class
JSRope
;
namespace
JS
{
class
SliceBudget
;
}
namespace
js
{
class
GCMarker
;
class
WeakMapBase
;
#
ifdef
DEBUG
static
const
size_t
MARK_STACK_BASE_CAPACITY
=
4
;
#
else
static
const
size_t
MARK_STACK_BASE_CAPACITY
=
4096
;
#
endif
enum
class
SlotsOrElementsKind
{
Unused
=
0
Elements
FixedSlots
DynamicSlots
}
;
namespace
gc
{
enum
IncrementalProgress
{
NotFinished
=
0
Finished
}
;
class
AutoSetMarkColor
;
class
AutoUpdateMarkStackRanges
;
struct
Cell
;
class
MarkStackIter
;
class
ParallelMarkTask
;
class
UnmarkGrayTracer
;
struct
EphemeronEdge
{
MarkColor
color
;
Cell
*
target
;
EphemeronEdge
(
MarkColor
color_
Cell
*
cell
)
:
color
(
color_
)
target
(
cell
)
{
}
}
;
using
EphemeronEdgeVector
=
Vector
<
EphemeronEdge
2
js
:
:
SystemAllocPolicy
>
;
using
EphemeronEdgeTable
=
HashMap
<
Cell
*
EphemeronEdgeVector
PointerHasher
<
Cell
*
>
js
:
:
SystemAllocPolicy
>
;
class
MarkStack
{
public
:
enum
Tag
{
SlotsOrElementsRangeTag
=
0
ObjectTag
SymbolTag
JitCodeTag
ScriptTag
TempRopeTag
LastTag
=
TempRopeTag
}
;
static
const
uintptr_t
TagMask
=
7
;
static_assert
(
TagMask
>
=
uintptr_t
(
LastTag
)
"
The
tag
mask
must
subsume
the
tags
.
"
)
;
static_assert
(
TagMask
<
=
gc
:
:
CellAlignMask
"
The
tag
mask
must
be
embeddable
in
a
Cell
*
.
"
)
;
class
TaggedPtr
{
uintptr_t
bits
;
Cell
*
ptr
(
)
const
;
explicit
TaggedPtr
(
uintptr_t
bits
)
;
public
:
TaggedPtr
(
Tag
tag
Cell
*
ptr
)
;
static
TaggedPtr
fromBits
(
uintptr_t
bits
)
;
uintptr_t
asBits
(
)
const
;
Tag
tag
(
)
const
;
template
<
typename
T
>
T
*
as
(
)
const
;
JSObject
*
asRangeObject
(
)
const
;
JSRope
*
asTempRope
(
)
const
;
void
assertValid
(
)
const
;
}
;
class
SlotsOrElementsRange
{
uintptr_t
startAndKind_
;
TaggedPtr
ptr_
;
static
constexpr
size_t
StartShift
=
2
;
static
constexpr
size_t
KindMask
=
(
1
<
<
StartShift
)
-
1
;
SlotsOrElementsRange
(
uintptr_t
startAndKind
uintptr_t
ptr
)
;
public
:
SlotsOrElementsRange
(
SlotsOrElementsKind
kind
JSObject
*
obj
size_t
start
)
;
static
SlotsOrElementsRange
fromBits
(
uintptr_t
startAndKind
uintptr_t
ptr
)
;
void
assertValid
(
)
const
;
uintptr_t
asBits0
(
)
const
;
uintptr_t
asBits1
(
)
const
;
SlotsOrElementsKind
kind
(
)
const
;
size_t
start
(
)
const
;
TaggedPtr
ptr
(
)
const
;
void
setStart
(
size_t
newStart
)
;
void
setEmpty
(
)
;
}
;
MarkStack
(
)
;
~
MarkStack
(
)
;
MarkStack
(
const
MarkStack
&
other
)
=
delete
;
MarkStack
&
operator
=
(
const
MarkStack
&
other
)
=
delete
;
void
swap
(
MarkStack
&
other
)
;
size_t
capacity
(
)
const
{
return
capacity_
;
}
#
ifdef
JS_GC_ZEAL
void
setMaxCapacity
(
size_t
maxCapacity
)
;
#
endif
size_t
position
(
)
const
{
return
topIndex_
;
}
[
[
nodiscard
]
]
bool
init
(
)
;
[
[
nodiscard
]
]
bool
resetStackCapacity
(
)
;
template
<
typename
T
>
[
[
nodiscard
]
]
bool
push
(
T
*
ptr
)
;
void
infalliblePush
(
const
SlotsOrElementsRange
&
range
)
;
void
infalliblePush
(
JSObject
*
obj
SlotsOrElementsKind
kind
size_t
start
)
;
[
[
nodiscard
]
]
bool
push
(
const
TaggedPtr
&
ptr
)
;
void
infalliblePush
(
const
TaggedPtr
&
ptr
)
;
[
[
nodiscard
]
]
bool
pushTempRope
(
JSRope
*
rope
)
;
bool
isEmpty
(
)
const
{
return
position
(
)
=
=
0
;
}
bool
hasEntries
(
)
const
{
return
!
isEmpty
(
)
;
}
Tag
peekTag
(
)
const
;
TaggedPtr
popPtr
(
)
;
SlotsOrElementsRange
popSlotsOrElementsRange
(
)
;
void
clearAndResetCapacity
(
)
;
void
clearAndFreeStack
(
)
;
void
poisonUnused
(
)
;
[
[
nodiscard
]
]
bool
ensureSpace
(
size_t
count
)
;
static
size_t
moveWork
(
GCMarker
*
marker
MarkStack
&
dst
MarkStack
&
src
bool
allowDistribute
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
uintptr_t
at
(
size_t
index
)
const
{
MOZ_ASSERT
(
topIndex_
<
=
capacity_
)
;
MOZ_ASSERT
(
index
<
topIndex_
)
;
return
stack_
[
index
]
;
}
uintptr_t
*
ptr
(
size_t
index
)
{
MOZ_ASSERT
(
topIndex_
<
=
capacity_
)
;
MOZ_ASSERT
(
index
<
=
topIndex_
)
;
return
stack_
+
index
;
}
uintptr_t
*
end
(
)
{
return
ptr
(
topIndex_
)
;
}
[
[
nodiscard
]
]
bool
enlarge
(
size_t
count
)
;
[
[
nodiscard
]
]
bool
resize
(
size_t
newCapacity
)
;
TaggedPtr
peekPtr
(
)
const
;
[
[
nodiscard
]
]
bool
pushTaggedPtr
(
Tag
tag
Cell
*
ptr
)
;
bool
indexIsEntryBase
(
size_t
index
)
const
;
MainThreadOrGCTaskData
<
uintptr_t
*
>
stack_
;
MainThreadOrGCTaskData
<
size_t
>
capacity_
;
MainThreadOrGCTaskData
<
size_t
>
topIndex_
;
#
ifdef
JS_GC_ZEAL
MainThreadOrGCTaskData
<
size_t
>
maxCapacity_
{
SIZE_MAX
}
;
#
endif
#
ifdef
DEBUG
MainThreadOrGCTaskData
<
bool
>
elementsRangesAreValid
;
friend
class
js
:
:
GCMarker
;
#
endif
friend
class
MarkStackIter
;
}
;
static_assert
(
unsigned
(
SlotsOrElementsKind
:
:
Unused
)
=
=
unsigned
(
MarkStack
:
:
SlotsOrElementsRangeTag
)
"
To
split
the
mark
stack
we
depend
on
being
able
to
tell
the
"
"
difference
between
SlotsOrElementsRange
:
:
startAndKind_
and
a
"
"
tagged
SlotsOrElementsRange
"
)
;
class
MOZ_STACK_CLASS
MarkStackIter
{
MarkStack
&
stack_
;
size_t
pos_
;
public
:
explicit
MarkStackIter
(
MarkStack
&
stack
)
;
bool
done
(
)
const
;
void
next
(
)
;
MarkStack
:
:
Tag
peekTag
(
)
const
;
MarkStack
:
:
TaggedPtr
peekPtr
(
)
const
;
bool
isSlotsOrElementsRange
(
)
const
;
MarkStack
:
:
SlotsOrElementsRange
slotsOrElementsRange
(
)
const
;
void
setSlotsOrElementsRange
(
const
MarkStack
:
:
SlotsOrElementsRange
&
range
)
;
private
:
size_t
position
(
)
const
;
}
;
namespace
MarkingOptions
{
enum
:
uint32_t
{
None
=
0
MarkRootCompartments
=
1
ParallelMarking
=
2
MarkImplicitEdges
=
4
}
;
}
constexpr
uint32_t
NormalMarkingOptions
=
MarkingOptions
:
:
MarkImplicitEdges
;
template
<
uint32_t
markingOptions
>
class
MarkingTracerT
:
public
GenericTracerImpl
<
MarkingTracerT
<
markingOptions
>
>
{
public
:
MarkingTracerT
(
JSRuntime
*
runtime
GCMarker
*
marker
)
;
virtual
~
MarkingTracerT
(
)
=
default
;
template
<
typename
T
>
void
onEdge
(
T
*
*
thingp
const
char
*
name
)
;
friend
class
GenericTracerImpl
<
MarkingTracerT
<
markingOptions
>
>
;
GCMarker
*
getMarker
(
)
;
}
;
using
MarkingTracer
=
MarkingTracerT
<
MarkingOptions
:
:
None
>
;
using
RootMarkingTracer
=
MarkingTracerT
<
MarkingOptions
:
:
MarkRootCompartments
>
;
using
WeakMarkingTracer
=
MarkingTracerT
<
MarkingOptions
:
:
MarkImplicitEdges
>
;
using
ParallelMarkingTracer
=
MarkingTracerT
<
MarkingOptions
:
:
ParallelMarking
>
;
enum
ShouldReportMarkTime
:
bool
{
ReportMarkTime
=
true
DontReportMarkTime
=
false
}
;
}
class
GCMarker
{
enum
MarkingState
:
uint8_t
{
NotActive
RootMarking
RegularMarking
ParallelMarking
WeakMarking
}
;
public
:
explicit
GCMarker
(
JSRuntime
*
rt
)
;
[
[
nodiscard
]
]
bool
init
(
)
;
JSRuntime
*
runtime
(
)
{
return
runtime_
;
}
JSTracer
*
tracer
(
)
{
return
tracer_
.
match
(
[
]
(
auto
&
t
)
-
>
JSTracer
*
{
return
&
t
;
}
)
;
}
#
ifdef
JS_GC_ZEAL
void
setMaxCapacity
(
size_t
maxCap
)
{
stack
.
setMaxCapacity
(
maxCap
)
;
}
#
endif
bool
isActive
(
)
const
{
return
state
!
=
NotActive
;
}
bool
isRegularMarking
(
)
const
{
return
state
=
=
RegularMarking
;
}
bool
isParallelMarking
(
)
const
{
return
state
=
=
ParallelMarking
;
}
bool
isWeakMarking
(
)
const
{
return
state
=
=
WeakMarking
;
}
gc
:
:
MarkColor
markColor
(
)
const
{
return
markColor_
;
}
bool
isDrained
(
)
const
{
return
stack
.
isEmpty
(
)
&
&
otherStack
.
isEmpty
(
)
;
}
bool
hasEntriesForCurrentColor
(
)
{
return
stack
.
hasEntries
(
)
;
}
bool
hasBlackEntries
(
)
const
{
return
hasEntries
(
gc
:
:
MarkColor
:
:
Black
)
;
}
bool
hasGrayEntries
(
)
const
{
return
hasEntries
(
gc
:
:
MarkColor
:
:
Gray
)
;
}
bool
hasEntries
(
gc
:
:
MarkColor
color
)
const
;
bool
canDonateWork
(
)
const
;
bool
shouldDonateWork
(
)
const
;
void
start
(
)
;
void
stop
(
)
;
void
reset
(
)
;
[
[
nodiscard
]
]
bool
markUntilBudgetExhausted
(
JS
:
:
SliceBudget
&
budget
gc
:
:
ShouldReportMarkTime
reportTime
=
gc
:
:
ReportMarkTime
)
;
void
setRootMarkingMode
(
bool
newState
)
;
bool
enterWeakMarkingMode
(
)
;
void
leaveWeakMarkingMode
(
)
;
void
enterParallelMarkingMode
(
)
;
void
leaveParallelMarkingMode
(
)
;
void
abortLinearWeakMarking
(
)
;
#
ifdef
DEBUG
void
setCheckAtomMarking
(
bool
check
)
;
bool
shouldCheckCompartments
(
)
{
return
strictCompartmentChecking
;
}
bool
markOneObjectForTest
(
JSObject
*
obj
)
;
#
endif
bool
markCurrentColorInParallel
(
gc
:
:
ParallelMarkTask
*
task
JS
:
:
SliceBudget
&
budget
)
;
template
<
uint32_t
markingOptions
gc
:
:
MarkColor
>
bool
markOneColor
(
JS
:
:
SliceBudget
&
budget
)
;
static
size_t
moveWork
(
GCMarker
*
dst
GCMarker
*
src
bool
allowDistribute
)
;
[
[
nodiscard
]
]
bool
initStack
(
)
;
void
resetStackCapacity
(
)
;
void
freeStack
(
)
;
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
static
GCMarker
*
fromTracer
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
trc
-
>
isMarkingTracer
(
)
)
;
auto
*
marker
=
reinterpret_cast
<
GCMarker
*
>
(
uintptr_t
(
trc
)
-
offsetof
(
GCMarker
tracer_
)
)
;
MOZ_ASSERT
(
marker
-
>
tracer
(
)
=
=
trc
)
;
return
marker
;
}
template
<
uint32_t
typename
T
>
void
markAndTraverse
(
T
*
thing
)
;
template
<
typename
T
>
void
markImplicitEdges
(
T
*
markedThing
)
;
private
:
void
setMarkColor
(
gc
:
:
MarkColor
newColor
)
;
friend
class
js
:
:
gc
:
:
AutoSetMarkColor
;
template
<
typename
Tracer
>
void
setMarkingStateAndTracer
(
MarkingState
prev
MarkingState
next
)
;
void
updateRangesAtStartOfSlice
(
)
;
void
updateRangesAtEndOfSlice
(
)
;
friend
class
gc
:
:
AutoUpdateMarkStackRanges
;
template
<
uint32_t
markingOptions
>
bool
processMarkStackTop
(
JS
:
:
SliceBudget
&
budget
)
;
friend
class
gc
:
:
GCRuntime
;
template
<
uint32_t
markingOptions
typename
S
>
void
markAndTraverseObjectEdge
(
S
source
JSObject
*
target
)
{
markAndTraverseEdge
<
markingOptions
>
(
source
target
)
;
}
template
<
uint32_t
markingOptions
typename
S
>
void
markAndTraverseStringEdge
(
S
source
JSString
*
target
)
{
markAndTraverseEdge
<
markingOptions
>
(
source
target
)
;
}
template
<
uint32_t
markingOptions
typename
S
typename
T
>
void
markAndTraverseEdge
(
S
*
source
T
*
target
)
;
template
<
uint32_t
markingOptions
typename
S
typename
T
>
void
markAndTraverseEdge
(
S
*
source
const
T
&
target
)
;
template
<
uint32_t
markingOptions
>
bool
markAndTraversePrivateGCThing
(
JSObject
*
source
gc
:
:
Cell
*
target
)
;
template
<
uint32_t
markingOptions
>
bool
markAndTraverseSymbol
(
JSObject
*
source
JS
:
:
Symbol
*
target
)
;
template
<
typename
S
typename
T
>
void
checkTraversedEdge
(
S
source
T
*
target
)
;
template
<
uint32_t
markingOptions
typename
T
>
[
[
nodiscard
]
]
bool
mark
(
T
*
thing
)
;
#
define
DEFINE_TRAVERSE_METHOD
(
_1
Type
_2
_3
)
\
template
<
uint32_t
>
\
void
traverse
(
Type
*
thing
)
;
JS_FOR_EACH_TRACEKIND
(
DEFINE_TRAVERSE_METHOD
)
#
undef
DEFINE_TRAVERSE_METHOD
template
<
uint32_t
markingOptions
typename
T
>
void
traceChildren
(
T
*
thing
)
;
template
<
uint32_t
markingOptions
typename
T
>
void
scanChildren
(
T
*
thing
)
;
template
<
uint32_t
markingOptions
typename
T
>
void
pushThing
(
T
*
thing
)
;
template
<
uint32_t
markingOptions
>
void
eagerlyMarkChildren
(
JSLinearString
*
str
)
;
template
<
uint32_t
markingOptions
>
void
eagerlyMarkChildren
(
JSRope
*
rope
)
;
template
<
uint32_t
markingOptions
>
void
eagerlyMarkChildren
(
JSString
*
str
)
;
template
<
uint32_t
markingOptions
>
void
eagerlyMarkChildren
(
Shape
*
shape
)
;
template
<
uint32_t
markingOptions
>
void
eagerlyMarkChildren
(
PropMap
*
map
)
;
template
<
uint32_t
markingOptions
>
void
eagerlyMarkChildren
(
Scope
*
scope
)
;
template
<
typename
T
>
inline
void
pushTaggedPtr
(
T
*
ptr
)
;
inline
void
pushValueRange
(
JSObject
*
obj
SlotsOrElementsKind
kind
size_t
start
size_t
end
)
;
void
markEphemeronEdges
(
gc
:
:
EphemeronEdgeVector
&
edges
gc
:
:
MarkColor
srcColor
)
;
friend
class
JS
:
:
Zone
;
#
ifdef
DEBUG
void
checkZone
(
void
*
p
)
;
#
else
void
checkZone
(
void
*
p
)
{
}
#
endif
template
<
uint32_t
markingOptions
>
bool
doMarking
(
JS
:
:
SliceBudget
&
budget
gc
:
:
ShouldReportMarkTime
reportTime
)
;
void
delayMarkingChildrenOnOOM
(
gc
:
:
Cell
*
cell
)
;
mozilla
:
:
Variant
<
gc
:
:
MarkingTracer
gc
:
:
RootMarkingTracer
gc
:
:
WeakMarkingTracer
gc
:
:
ParallelMarkingTracer
>
tracer_
;
JSRuntime
*
const
runtime_
;
gc
:
:
MarkStack
stack
;
gc
:
:
MarkStack
otherStack
;
MainThreadOrGCTaskData
<
bool
>
haveSwappedStacks
;
MainThreadOrGCTaskData
<
gc
:
:
MarkColor
>
markColor_
;
Vector
<
JS
:
:
GCCellPtr
0
SystemAllocPolicy
>
unmarkGrayStack
;
friend
class
gc
:
:
UnmarkGrayTracer
;
MainThreadOrGCTaskData
<
MarkingState
>
state
;
MainThreadOrGCTaskData
<
bool
>
haveAllImplicitEdges
;
public
:
MainThreadOrGCTaskData
<
bool
>
incrementalWeakMapMarkingEnabled
;
MainThreadOrGCTaskData
<
mozilla
:
:
non_crypto
:
:
XorShift128PlusRNG
>
random
;
#
ifdef
DEBUG
private
:
MainThreadOrGCTaskData
<
bool
>
started
;
MainThreadOrGCTaskData
<
bool
>
checkAtomMarking
;
MainThreadOrGCTaskData
<
bool
>
strictCompartmentChecking
;
public
:
MainThreadOrGCTaskData
<
Compartment
*
>
tracingCompartment
;
MainThreadOrGCTaskData
<
Zone
*
>
tracingZone
;
#
endif
}
;
namespace
gc
{
class
MOZ_RAII
AutoSetMarkColor
{
GCMarker
&
marker_
;
MarkColor
initialColor_
;
public
:
AutoSetMarkColor
(
GCMarker
&
marker
MarkColor
newColor
)
:
marker_
(
marker
)
initialColor_
(
marker
.
markColor
(
)
)
{
marker_
.
setMarkColor
(
newColor
)
;
}
AutoSetMarkColor
(
GCMarker
&
marker
CellColor
newColor
)
:
AutoSetMarkColor
(
marker
AsMarkColor
(
newColor
)
)
{
}
~
AutoSetMarkColor
(
)
{
marker_
.
setMarkColor
(
initialColor_
)
;
}
}
;
}
}
#
endif
