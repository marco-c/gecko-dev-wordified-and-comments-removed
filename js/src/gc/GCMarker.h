#
ifndef
gc_GCMarker_h
#
define
gc_GCMarker_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
ds
/
OrderedHashTable
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
class
JSRope
;
namespace
js
{
class
GCMarker
;
class
SliceBudget
;
class
WeakMapBase
;
static
const
size_t
MARK_STACK_BASE_CAPACITY
=
4096
;
enum
class
SlotsOrElementsKind
{
Elements
FixedSlots
DynamicSlots
}
;
namespace
gc
{
enum
IncrementalProgress
{
NotFinished
=
0
Finished
}
;
struct
Cell
;
struct
EphemeronEdgeTableHashPolicy
{
using
Lookup
=
Cell
*
;
static
HashNumber
hash
(
const
Lookup
&
v
const
mozilla
:
:
HashCodeScrambler
&
hcs
)
{
return
hcs
.
scramble
(
mozilla
:
:
HashGeneric
(
v
)
)
;
}
static
bool
match
(
Cell
*
const
&
k
const
Lookup
&
l
)
{
return
k
=
=
l
;
}
static
bool
isEmpty
(
Cell
*
const
&
v
)
{
return
!
v
;
}
static
void
makeEmpty
(
Cell
*
*
vp
)
{
*
vp
=
nullptr
;
}
}
;
struct
EphemeronEdge
{
CellColor
color
;
Cell
*
target
;
EphemeronEdge
(
CellColor
color_
Cell
*
cell
)
:
color
(
color_
)
target
(
cell
)
{
}
}
;
using
EphemeronEdgeVector
=
Vector
<
EphemeronEdge
2
js
:
:
SystemAllocPolicy
>
;
using
EphemeronEdgeTable
=
OrderedHashMap
<
Cell
*
EphemeronEdgeVector
EphemeronEdgeTableHashPolicy
js
:
:
SystemAllocPolicy
>
;
class
MarkStack
{
public
:
enum
Tag
{
SlotsOrElementsRangeTag
ObjectTag
JitCodeTag
ScriptTag
TempRopeTag
LastTag
=
TempRopeTag
}
;
static
const
uintptr_t
TagMask
=
7
;
static_assert
(
TagMask
>
=
uintptr_t
(
LastTag
)
"
The
tag
mask
must
subsume
the
tags
.
"
)
;
static_assert
(
TagMask
<
=
gc
:
:
CellAlignMask
"
The
tag
mask
must
be
embeddable
in
a
Cell
*
.
"
)
;
class
TaggedPtr
{
uintptr_t
bits
;
Cell
*
ptr
(
)
const
;
public
:
TaggedPtr
(
)
=
default
;
TaggedPtr
(
Tag
tag
Cell
*
ptr
)
;
Tag
tag
(
)
const
;
template
<
typename
T
>
T
*
as
(
)
const
;
JSObject
*
asRangeObject
(
)
const
;
JSRope
*
asTempRope
(
)
const
;
void
assertValid
(
)
const
;
}
;
struct
SlotsOrElementsRange
{
SlotsOrElementsRange
(
SlotsOrElementsKind
kind
JSObject
*
obj
size_t
start
)
;
void
assertValid
(
)
const
;
SlotsOrElementsKind
kind
(
)
const
;
size_t
start
(
)
const
;
TaggedPtr
ptr
(
)
const
;
static
constexpr
size_t
StartShift
=
2
;
static
constexpr
size_t
KindMask
=
(
1
<
<
StartShift
)
-
1
;
private
:
uintptr_t
startAndKind_
;
TaggedPtr
ptr_
;
}
;
explicit
MarkStack
(
)
;
~
MarkStack
(
)
;
size_t
capacity
(
)
{
return
stack
(
)
.
length
(
)
;
}
size_t
position
(
)
const
{
return
topIndex_
;
}
[
[
nodiscard
]
]
bool
init
(
)
;
[
[
nodiscard
]
]
bool
resetStackCapacity
(
)
;
#
ifdef
JS_GC_ZEAL
void
setMaxCapacity
(
size_t
maxCapacity
)
;
#
endif
template
<
typename
T
>
[
[
nodiscard
]
]
bool
push
(
T
*
ptr
)
;
[
[
nodiscard
]
]
bool
push
(
JSObject
*
obj
SlotsOrElementsKind
kind
size_t
start
)
;
[
[
nodiscard
]
]
bool
push
(
const
SlotsOrElementsRange
&
array
)
;
[
[
nodiscard
]
]
bool
pushTempRope
(
JSRope
*
ptr
)
;
bool
isEmpty
(
)
const
{
return
topIndex_
=
=
0
;
}
Tag
peekTag
(
)
const
;
TaggedPtr
popPtr
(
)
;
SlotsOrElementsRange
popSlotsOrElementsRange
(
)
;
void
clear
(
)
;
void
poisonUnused
(
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
using
StackVector
=
Vector
<
TaggedPtr
0
SystemAllocPolicy
>
;
const
StackVector
&
stack
(
)
const
{
return
stack_
.
ref
(
)
;
}
StackVector
&
stack
(
)
{
return
stack_
.
ref
(
)
;
}
[
[
nodiscard
]
]
bool
ensureSpace
(
size_t
count
)
;
[
[
nodiscard
]
]
bool
enlarge
(
size_t
count
)
;
[
[
nodiscard
]
]
bool
resize
(
size_t
newCapacity
)
;
TaggedPtr
*
topPtr
(
)
;
const
TaggedPtr
&
peekPtr
(
)
const
;
[
[
nodiscard
]
]
bool
pushTaggedPtr
(
Tag
tag
Cell
*
ptr
)
;
MainThreadOrGCTaskData
<
StackVector
>
stack_
;
MainThreadOrGCTaskData
<
size_t
>
topIndex_
;
#
ifdef
JS_GC_ZEAL
MainThreadOrGCTaskData
<
size_t
>
maxCapacity_
{
SIZE_MAX
}
;
#
endif
#
ifdef
DEBUG
mutable
size_t
iteratorCount_
=
0
;
#
endif
}
;
namespace
MarkingOptions
{
enum
:
uint32_t
{
None
=
0
MarkRootCompartments
=
1
}
;
}
template
<
uint32_t
markingOptions
>
class
MarkingTracerT
:
public
GenericTracerImpl
<
MarkingTracerT
<
markingOptions
>
>
{
public
:
explicit
MarkingTracerT
(
JSRuntime
*
runtime
)
;
virtual
~
MarkingTracerT
(
)
=
default
;
template
<
typename
T
>
void
onEdge
(
T
*
*
thingp
const
char
*
name
)
;
friend
class
GenericTracerImpl
<
MarkingTracerT
<
markingOptions
>
>
;
GCMarker
*
getMarker
(
)
;
}
;
using
MarkingTracer
=
MarkingTracerT
<
MarkingOptions
:
:
None
>
;
using
RootMarkingTracer
=
MarkingTracerT
<
MarkingOptions
:
:
MarkRootCompartments
>
;
}
class
GCMarker
{
enum
MarkingState
:
uint8_t
{
NotActive
RootMarking
RegularMarking
WeakMarking
IterativeMarking
}
;
public
:
explicit
GCMarker
(
JSRuntime
*
rt
)
;
[
[
nodiscard
]
]
bool
init
(
)
;
JSRuntime
*
runtime
(
)
{
return
runtime_
;
}
JSTracer
*
tracer
(
)
{
return
tracer_
.
match
(
[
]
(
auto
&
t
)
-
>
JSTracer
*
{
return
&
t
;
}
)
;
}
#
ifdef
JS_GC_ZEAL
void
setMaxCapacity
(
size_t
maxCap
)
{
stack
.
setMaxCapacity
(
maxCap
)
;
}
#
endif
bool
isActive
(
)
const
{
return
state
!
=
NotActive
;
}
void
start
(
)
;
void
stop
(
)
;
void
reset
(
)
;
template
<
typename
T
>
void
markAndTraverse
(
T
*
thing
)
;
template
<
typename
T
>
void
traverse
(
T
*
thing
)
;
template
<
typename
S
typename
T
>
void
markAndTraverseEdge
(
S
source
T
*
target
)
;
template
<
typename
S
typename
T
>
void
markAndTraverseEdge
(
S
source
const
T
&
target
)
;
template
<
typename
S
>
void
markAndTraverseObjectEdge
(
S
source
JSObject
*
target
)
{
markAndTraverseEdge
(
source
target
)
;
}
template
<
typename
S
>
void
markAndTraverseStringEdge
(
S
source
JSString
*
target
)
{
markAndTraverseEdge
(
source
target
)
;
}
template
<
typename
S
typename
T
>
void
checkTraversedEdge
(
S
source
T
*
target
)
;
#
ifdef
DEBUG
void
setCheckAtomMarking
(
bool
check
)
;
#
endif
void
setMarkColor
(
gc
:
:
MarkColor
newColor
)
;
gc
:
:
MarkColor
markColor
(
)
const
{
return
markColor_
;
}
void
setRootMarkingMode
(
bool
newState
)
;
bool
enterWeakMarkingMode
(
)
;
void
leaveWeakMarkingMode
(
)
;
void
abortLinearWeakMarking
(
)
{
if
(
state
=
=
WeakMarking
)
{
leaveWeakMarkingMode
(
)
;
}
state
=
IterativeMarking
;
}
void
delayMarkingChildrenOnOOM
(
gc
:
:
Cell
*
cell
)
;
void
delayMarkingChildren
(
gc
:
:
Cell
*
cell
)
;
void
severWeakDelegate
(
JSObject
*
key
JSObject
*
delegate
)
;
void
restoreWeakDelegate
(
JSObject
*
key
JSObject
*
delegate
)
;
bool
isDrained
(
)
;
enum
ShouldReportMarkTime
:
bool
{
ReportMarkTime
=
true
DontReportMarkTime
=
false
}
;
[
[
nodiscard
]
]
bool
markUntilBudgetExhausted
(
SliceBudget
&
budget
ShouldReportMarkTime
reportTime
=
ReportMarkTime
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
#
ifdef
DEBUG
bool
shouldCheckCompartments
(
)
{
return
strictCompartmentChecking
;
}
#
endif
void
markEphemeronEdges
(
gc
:
:
EphemeronEdgeVector
&
edges
gc
:
:
CellColor
srcColor
)
;
static
GCMarker
*
fromTracer
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
trc
-
>
isMarkingTracer
(
)
)
;
auto
*
marker
=
reinterpret_cast
<
GCMarker
*
>
(
uintptr_t
(
trc
)
-
offsetof
(
GCMarker
tracer_
)
)
;
MOZ_ASSERT
(
marker
-
>
tracer
(
)
=
=
trc
)
;
return
marker
;
}
template
<
typename
T
>
void
markImplicitEdges
(
T
*
oldThing
)
;
bool
isRegularMarking
(
)
const
{
return
state
=
=
RegularMarking
;
}
bool
isWeakMarking
(
)
const
{
return
state
=
=
WeakMarking
;
}
bool
isMarkStackEmpty
(
)
{
return
stack
.
isEmpty
(
)
;
}
bool
hasBlackEntries
(
)
const
{
return
stack
.
position
(
)
>
grayPosition
;
}
bool
hasGrayEntries
(
)
const
{
return
grayPosition
>
0
&
&
!
stack
.
isEmpty
(
)
;
}
private
:
#
ifdef
DEBUG
void
checkZone
(
void
*
p
)
;
#
else
void
checkZone
(
void
*
p
)
{
}
#
endif
inline
void
repush
(
JSObject
*
obj
)
;
template
<
typename
T
>
void
traceChildren
(
T
*
thing
)
;
template
<
typename
T
>
void
scanChildren
(
T
*
thing
)
;
template
<
typename
T
>
void
pushThing
(
T
*
thing
)
;
template
<
typename
T
>
void
markImplicitEdgesHelper
(
T
oldThing
)
;
void
eagerlyMarkChildren
(
JSLinearString
*
str
)
;
void
eagerlyMarkChildren
(
JSRope
*
rope
)
;
void
eagerlyMarkChildren
(
JSString
*
str
)
;
void
eagerlyMarkChildren
(
Shape
*
shape
)
;
void
eagerlyMarkChildren
(
PropMap
*
map
)
;
void
eagerlyMarkChildren
(
Scope
*
scope
)
;
template
<
typename
T
>
void
dispatchToTraceChildren
(
T
*
thing
)
;
template
<
typename
T
>
[
[
nodiscard
]
]
bool
mark
(
T
*
thing
)
;
template
<
typename
T
>
inline
void
pushTaggedPtr
(
T
*
ptr
)
;
inline
void
pushValueRange
(
JSObject
*
obj
SlotsOrElementsKind
kind
size_t
start
size_t
end
)
;
void
processMarkStackTop
(
SliceBudget
&
budget
)
;
friend
class
gc
:
:
GCRuntime
;
void
markDelayedChildren
(
gc
:
:
Arena
*
arena
)
;
void
markAllDelayedChildren
(
ShouldReportMarkTime
reportTime
)
;
void
processDelayedMarkingList
(
gc
:
:
MarkColor
color
)
;
bool
hasDelayedChildren
(
)
const
{
return
!
!
delayedMarkingList
;
}
void
rebuildDelayedMarkingList
(
)
;
void
appendToDelayedMarkingList
(
gc
:
:
Arena
*
*
listTail
gc
:
:
Arena
*
arena
)
;
template
<
typename
F
>
void
forEachDelayedMarkingArena
(
F
&
&
f
)
;
mozilla
:
:
Variant
<
gc
:
:
MarkingTracer
gc
:
:
RootMarkingTracer
>
tracer_
;
JSRuntime
*
const
runtime_
;
gc
:
:
MarkStack
stack
;
MainThreadOrGCTaskData
<
size_t
>
grayPosition
;
MainThreadOrGCTaskData
<
gc
:
:
MarkColor
>
markColor_
;
MainThreadOrGCTaskData
<
js
:
:
gc
:
:
Arena
*
>
delayedMarkingList
;
MainThreadOrGCTaskData
<
bool
>
delayedMarkingWorkAdded
;
MainThreadOrGCTaskData
<
MarkingState
>
state
;
public
:
MainThreadOrGCTaskData
<
bool
>
incrementalWeakMapMarkingEnabled
;
#
ifdef
DEBUG
private
:
MainThreadOrGCTaskData
<
size_t
>
markLaterArenas
;
MainThreadOrGCTaskData
<
bool
>
started
;
MainThreadOrGCTaskData
<
bool
>
checkAtomMarking
;
MainThreadOrGCTaskData
<
bool
>
strictCompartmentChecking
;
public
:
MainThreadOrGCTaskData
<
Compartment
*
>
tracingCompartment
;
MainThreadOrGCTaskData
<
Zone
*
>
tracingZone
;
#
endif
}
;
namespace
gc
{
class
MOZ_RAII
AutoSetMarkColor
{
GCMarker
&
marker_
;
MarkColor
initialColor_
;
public
:
AutoSetMarkColor
(
GCMarker
&
marker
MarkColor
newColor
)
:
marker_
(
marker
)
initialColor_
(
marker
.
markColor
(
)
)
{
marker_
.
setMarkColor
(
newColor
)
;
}
AutoSetMarkColor
(
GCMarker
&
marker
CellColor
newColor
)
:
AutoSetMarkColor
(
marker
newColor
.
asMarkColor
(
)
)
{
}
~
AutoSetMarkColor
(
)
{
marker_
.
setMarkColor
(
initialColor_
)
;
}
}
;
}
}
#
endif
