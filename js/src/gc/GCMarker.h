#
ifndef
gc_GCMarker_h
#
define
gc_GCMarker_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
ds
/
OrderedHashTable
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
class
JSRope
;
namespace
js
{
class
AutoAccessAtomsZone
;
class
WeakMapBase
;
static
const
size_t
NON_INCREMENTAL_MARK_STACK_BASE_CAPACITY
=
4096
;
static
const
size_t
INCREMENTAL_MARK_STACK_BASE_CAPACITY
=
32768
;
static
const
size_t
SMALL_MARK_STACK_BASE_CAPACITY
=
256
;
enum
class
SlotsOrElementsKind
{
Elements
FixedSlots
DynamicSlots
}
;
namespace
gc
{
enum
IncrementalProgress
{
NotFinished
=
0
Finished
}
;
class
BarrierTracer
;
struct
Cell
;
using
BarrierBuffer
=
Vector
<
JS
:
:
GCCellPtr
0
SystemAllocPolicy
>
;
struct
EphemeronEdgeTableHashPolicy
{
using
Lookup
=
Cell
*
;
static
HashNumber
hash
(
const
Lookup
&
v
const
mozilla
:
:
HashCodeScrambler
&
hcs
)
{
return
hcs
.
scramble
(
mozilla
:
:
HashGeneric
(
v
)
)
;
}
static
bool
match
(
Cell
*
const
&
k
const
Lookup
&
l
)
{
return
k
=
=
l
;
}
static
bool
isEmpty
(
Cell
*
const
&
v
)
{
return
!
v
;
}
static
void
makeEmpty
(
Cell
*
*
vp
)
{
*
vp
=
nullptr
;
}
}
;
struct
EphemeronEdge
{
CellColor
color
;
Cell
*
target
;
EphemeronEdge
(
CellColor
color_
Cell
*
cell
)
:
color
(
color_
)
target
(
cell
)
{
}
}
;
using
EphemeronEdgeVector
=
Vector
<
EphemeronEdge
2
js
:
:
SystemAllocPolicy
>
;
using
EphemeronEdgeTable
=
OrderedHashMap
<
Cell
*
EphemeronEdgeVector
EphemeronEdgeTableHashPolicy
js
:
:
SystemAllocPolicy
>
;
class
MarkStack
{
public
:
enum
Tag
{
SlotsOrElementsRangeTag
ObjectTag
GroupTag
JitCodeTag
ScriptTag
TempRopeTag
LastTag
=
TempRopeTag
}
;
static
const
uintptr_t
TagMask
=
7
;
static_assert
(
TagMask
>
=
uintptr_t
(
LastTag
)
"
The
tag
mask
must
subsume
the
tags
.
"
)
;
static_assert
(
TagMask
<
=
gc
:
:
CellAlignMask
"
The
tag
mask
must
be
embeddable
in
a
Cell
*
.
"
)
;
class
TaggedPtr
{
uintptr_t
bits
;
Cell
*
ptr
(
)
const
;
public
:
TaggedPtr
(
)
=
default
;
TaggedPtr
(
Tag
tag
Cell
*
ptr
)
;
Tag
tag
(
)
const
;
template
<
typename
T
>
T
*
as
(
)
const
;
JSObject
*
asRangeObject
(
)
const
;
JSRope
*
asTempRope
(
)
const
;
void
assertValid
(
)
const
;
}
;
struct
SlotsOrElementsRange
{
SlotsOrElementsRange
(
SlotsOrElementsKind
kind
JSObject
*
obj
size_t
start
)
;
void
assertValid
(
)
const
;
SlotsOrElementsKind
kind
(
)
const
;
size_t
start
(
)
const
;
TaggedPtr
ptr
(
)
const
;
static
constexpr
size_t
StartShift
=
2
;
static
constexpr
size_t
KindMask
=
(
1
<
<
StartShift
)
-
1
;
private
:
uintptr_t
startAndKind_
;
TaggedPtr
ptr_
;
}
;
explicit
MarkStack
(
size_t
maxCapacity
=
DefaultCapacity
)
;
~
MarkStack
(
)
;
static
const
size_t
DefaultCapacity
=
SIZE_MAX
;
size_t
capacity
(
)
{
return
stack
(
)
.
length
(
)
;
}
size_t
position
(
)
const
{
return
topIndex_
;
}
enum
StackType
{
MainStack
AuxiliaryStack
}
;
[
[
nodiscard
]
]
bool
init
(
StackType
which
bool
incrementalGCEnabled
)
;
[
[
nodiscard
]
]
bool
setStackCapacity
(
StackType
which
bool
incrementalGCEnabled
)
;
size_t
maxCapacity
(
)
const
{
return
maxCapacity_
;
}
void
setMaxCapacity
(
size_t
maxCapacity
)
;
template
<
typename
T
>
[
[
nodiscard
]
]
bool
push
(
T
*
ptr
)
;
[
[
nodiscard
]
]
bool
push
(
JSObject
*
obj
SlotsOrElementsKind
kind
size_t
start
)
;
[
[
nodiscard
]
]
bool
push
(
const
SlotsOrElementsRange
&
array
)
;
[
[
nodiscard
]
]
bool
pushTempRope
(
JSRope
*
ptr
)
;
bool
isEmpty
(
)
const
{
return
topIndex_
=
=
0
;
}
Tag
peekTag
(
)
const
;
TaggedPtr
popPtr
(
)
;
SlotsOrElementsRange
popSlotsOrElementsRange
(
)
;
void
clear
(
)
{
stack
(
)
.
clearAndFree
(
)
;
mozilla
:
:
Unused
<
<
stack
(
)
.
resize
(
NON_INCREMENTAL_MARK_STACK_BASE_CAPACITY
)
;
topIndex_
=
0
;
}
void
poisonUnused
(
)
;
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
using
StackVector
=
Vector
<
TaggedPtr
0
SystemAllocPolicy
>
;
const
StackVector
&
stack
(
)
const
{
return
stack_
.
ref
(
)
;
}
StackVector
&
stack
(
)
{
return
stack_
.
ref
(
)
;
}
[
[
nodiscard
]
]
bool
ensureSpace
(
size_t
count
)
;
[
[
nodiscard
]
]
bool
enlarge
(
size_t
count
)
;
[
[
nodiscard
]
]
bool
resize
(
size_t
newCapacity
)
;
TaggedPtr
*
topPtr
(
)
;
const
TaggedPtr
&
peekPtr
(
)
const
;
[
[
nodiscard
]
]
bool
pushTaggedPtr
(
Tag
tag
Cell
*
ptr
)
;
MainThreadOrGCTaskData
<
size_t
>
topIndex_
;
MainThreadOrGCTaskData
<
size_t
>
maxCapacity_
;
MainThreadOrGCTaskData
<
StackVector
>
stack_
;
#
ifdef
DEBUG
mutable
size_t
iteratorCount_
;
#
endif
friend
class
MarkStackIter
;
}
;
class
MarkStackIter
{
MarkStack
&
stack_
;
size_t
pos_
;
public
:
explicit
MarkStackIter
(
MarkStack
&
stack
)
;
~
MarkStackIter
(
)
;
bool
done
(
)
const
;
MarkStack
:
:
Tag
peekTag
(
)
const
;
MarkStack
:
:
TaggedPtr
peekPtr
(
)
const
;
MarkStack
:
:
SlotsOrElementsRange
peekSlotsOrElementsRange
(
)
const
;
void
next
(
)
;
void
nextPtr
(
)
;
void
nextArray
(
)
;
private
:
size_t
position
(
)
const
;
}
;
}
enum
MarkingState
:
uint8_t
{
NotActive
RegularMarking
WeakMarking
IterativeMarking
}
;
class
GCMarker
final
:
public
JSTracer
{
public
:
explicit
GCMarker
(
JSRuntime
*
rt
)
;
[
[
nodiscard
]
]
bool
init
(
)
;
void
setMaxCapacity
(
size_t
maxCap
)
{
stack
.
setMaxCapacity
(
maxCap
)
;
}
size_t
maxCapacity
(
)
const
{
return
stack
.
maxCapacity
(
)
;
}
bool
isActive
(
)
const
{
return
state
!
=
MarkingState
:
:
NotActive
;
}
void
start
(
)
;
void
stop
(
)
;
void
reset
(
)
;
template
<
typename
T
>
void
markAndTraverse
(
T
*
thing
)
;
template
<
typename
T
>
void
traverse
(
T
*
thing
)
;
template
<
typename
S
typename
T
>
void
markAndTraverseEdge
(
S
source
T
*
target
)
;
template
<
typename
S
typename
T
>
void
markAndTraverseEdge
(
S
source
const
T
&
target
)
;
template
<
typename
S
>
void
markAndTraverseObjectEdge
(
S
source
JSObject
*
target
)
{
markAndTraverseEdge
(
source
target
)
;
}
template
<
typename
S
>
void
markAndTraverseStringEdge
(
S
source
JSString
*
target
)
{
markAndTraverseEdge
(
source
target
)
;
}
template
<
typename
S
typename
T
>
void
checkTraversedEdge
(
S
source
T
*
target
)
;
#
ifdef
DEBUG
void
setCheckAtomMarking
(
bool
check
)
;
#
endif
void
setMarkColor
(
gc
:
:
MarkColor
newColor
)
;
void
setMarkColorUnchecked
(
gc
:
:
MarkColor
newColor
)
;
gc
:
:
MarkColor
markColor
(
)
const
{
return
color
;
}
void
setMainStackColor
(
gc
:
:
MarkColor
newColor
)
;
bool
enterWeakMarkingMode
(
)
;
void
leaveWeakMarkingMode
(
)
;
void
abortLinearWeakMarking
(
)
{
if
(
state
=
=
MarkingState
:
:
WeakMarking
)
{
leaveWeakMarkingMode
(
)
;
}
state
=
MarkingState
:
:
IterativeMarking
;
}
void
delayMarkingChildrenOnOOM
(
gc
:
:
Cell
*
cell
)
;
void
delayMarkingChildren
(
gc
:
:
Cell
*
cell
)
;
void
severWeakDelegate
(
JSObject
*
key
JSObject
*
delegate
)
;
void
restoreWeakDelegate
(
JSObject
*
key
JSObject
*
delegate
)
;
bool
isDrained
(
)
;
enum
MarkQueueProgress
{
QueueYielded
QueueComplete
QueueSuspended
}
;
MarkQueueProgress
processMarkQueue
(
)
;
enum
ShouldReportMarkTime
:
bool
{
ReportMarkTime
=
true
DontReportMarkTime
=
false
}
;
[
[
nodiscard
]
]
bool
markUntilBudgetExhausted
(
SliceBudget
&
budget
ShouldReportMarkTime
reportTime
=
ReportMarkTime
)
;
void
setIncrementalGCEnabled
(
bool
enabled
)
{
mozilla
:
:
Unused
<
<
stack
.
setStackCapacity
(
gc
:
:
MarkStack
:
:
MainStack
enabled
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
#
ifdef
DEBUG
bool
shouldCheckCompartments
(
)
{
return
strictCompartmentChecking
;
}
#
endif
void
markEphemeronEdges
(
gc
:
:
EphemeronEdgeVector
&
edges
)
;
size_t
getMarkCount
(
)
const
{
return
markCount
;
}
void
clearMarkCount
(
)
{
markCount
=
0
;
}
static
GCMarker
*
fromTracer
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
trc
-
>
isMarkingTracer
(
)
)
;
return
static_cast
<
GCMarker
*
>
(
trc
)
;
}
template
<
typename
T
>
void
markImplicitEdges
(
T
*
oldThing
)
;
bool
isWeakMarking
(
)
const
{
return
state
=
=
MarkingState
:
:
WeakMarking
;
}
private
:
#
ifdef
DEBUG
void
checkZone
(
void
*
p
)
;
#
else
void
checkZone
(
void
*
p
)
{
}
#
endif
inline
void
repush
(
JSObject
*
obj
)
;
template
<
typename
T
>
void
traceChildren
(
T
*
thing
)
;
template
<
typename
T
>
void
scanChildren
(
T
*
thing
)
;
template
<
typename
T
>
void
pushThing
(
T
*
thing
)
;
template
<
typename
T
>
void
markImplicitEdgesHelper
(
T
oldThing
)
;
void
eagerlyMarkChildren
(
JSLinearString
*
str
)
;
void
eagerlyMarkChildren
(
JSRope
*
rope
)
;
void
eagerlyMarkChildren
(
JSString
*
str
)
;
void
eagerlyMarkChildren
(
Shape
*
shape
)
;
void
eagerlyMarkChildren
(
Scope
*
scope
)
;
void
lazilyMarkChildren
(
ObjectGroup
*
group
)
;
template
<
typename
T
>
void
dispatchToTraceChildren
(
T
*
thing
)
;
template
<
typename
T
>
[
[
nodiscard
]
]
bool
mark
(
T
*
thing
)
;
template
<
typename
T
>
inline
void
pushTaggedPtr
(
T
*
ptr
)
;
inline
void
pushValueRange
(
JSObject
*
obj
SlotsOrElementsKind
kind
size_t
start
size_t
end
)
;
gc
:
:
MarkStack
&
getStack
(
gc
:
:
MarkColor
which
)
{
return
which
=
=
mainStackColor
?
stack
:
auxStack
;
}
const
gc
:
:
MarkStack
&
getStack
(
gc
:
:
MarkColor
which
)
const
{
return
which
=
=
mainStackColor
?
stack
:
auxStack
;
}
gc
:
:
MarkStack
&
currentStack
(
)
{
MOZ_ASSERT
(
currentStackPtr
)
;
return
*
currentStackPtr
;
}
bool
isMarkStackEmpty
(
)
{
return
stack
.
isEmpty
(
)
&
&
auxStack
.
isEmpty
(
)
;
}
bool
hasBlackEntries
(
)
const
{
return
!
getStack
(
gc
:
:
MarkColor
:
:
Black
)
.
isEmpty
(
)
;
}
bool
hasGrayEntries
(
)
const
{
return
!
getStack
(
gc
:
:
MarkColor
:
:
Gray
)
.
isEmpty
(
)
;
}
inline
void
processMarkStackTop
(
SliceBudget
&
budget
)
;
void
markDelayedChildren
(
gc
:
:
Arena
*
arena
gc
:
:
MarkColor
color
)
;
[
[
nodiscard
]
]
bool
markAllDelayedChildren
(
SliceBudget
&
budget
ShouldReportMarkTime
reportTime
)
;
bool
processDelayedMarkingList
(
gc
:
:
MarkColor
color
SliceBudget
&
budget
)
;
bool
hasDelayedChildren
(
)
const
{
return
!
!
delayedMarkingList
;
}
void
rebuildDelayedMarkingList
(
)
;
void
appendToDelayedMarkingList
(
gc
:
:
Arena
*
*
listTail
gc
:
:
Arena
*
arena
)
;
template
<
typename
F
>
void
forEachDelayedMarkingArena
(
F
&
&
f
)
;
gc
:
:
BarrierBuffer
&
barrierBuffer
(
)
{
return
barrierBuffer_
.
ref
(
)
;
}
bool
traceBarrieredCells
(
SliceBudget
&
budget
)
;
void
traceBarrieredCell
(
JS
:
:
GCCellPtr
cell
)
;
MainThreadOrGCTaskData
<
gc
:
:
BarrierBuffer
>
barrierBuffer_
;
friend
class
gc
:
:
BarrierTracer
;
gc
:
:
MarkStack
stack
;
gc
:
:
MarkStack
auxStack
;
MainThreadOrGCTaskData
<
gc
:
:
MarkColor
>
color
;
MainThreadOrGCTaskData
<
gc
:
:
MarkColor
>
mainStackColor
;
MainThreadOrGCTaskData
<
gc
:
:
MarkStack
*
>
currentStackPtr
;
MainThreadOrGCTaskData
<
js
:
:
gc
:
:
Arena
*
>
delayedMarkingList
;
MainThreadOrGCTaskData
<
bool
>
delayedMarkingWorkAdded
;
size_t
markCount
;
MainThreadOrGCTaskData
<
MarkingState
>
state
;
public
:
MainThreadOrGCTaskData
<
bool
>
incrementalWeakMapMarkingEnabled
;
#
ifdef
DEBUG
private
:
MainThreadOrGCTaskData
<
size_t
>
markLaterArenas
;
MainThreadOrGCTaskData
<
bool
>
started
;
MainThreadOrGCTaskData
<
bool
>
checkAtomMarking
;
mozilla
:
:
Maybe
<
js
:
:
gc
:
:
MarkColor
>
queueMarkColor
;
MainThreadOrGCTaskData
<
bool
>
strictCompartmentChecking
;
public
:
MainThreadOrGCTaskData
<
Compartment
*
>
tracingCompartment
;
MainThreadOrGCTaskData
<
Zone
*
>
tracingZone
;
JS
:
:
WeakCache
<
GCVector
<
JS
:
:
Heap
<
JS
:
:
Value
>
0
SystemAllocPolicy
>
>
markQueue
;
size_t
queuePos
;
#
endif
}
;
namespace
gc
{
class
MOZ_RAII
AutoSetMarkColor
{
GCMarker
&
marker_
;
MarkColor
initialColor_
;
public
:
AutoSetMarkColor
(
GCMarker
&
marker
MarkColor
newColor
)
:
marker_
(
marker
)
initialColor_
(
marker
.
markColor
(
)
)
{
marker_
.
setMarkColor
(
newColor
)
;
}
AutoSetMarkColor
(
GCMarker
&
marker
CellColor
newColor
)
:
AutoSetMarkColor
(
marker
newColor
.
asMarkColor
(
)
)
{
}
~
AutoSetMarkColor
(
)
{
marker_
.
setMarkColor
(
initialColor_
)
;
}
}
;
}
}
#
endif
