#
include
"
gc
/
Pretenuring
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
gc
/
PublicIterators
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
Invalidation
.
h
"
#
include
"
js
/
Prefs
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
gc
/
PrivateIterators
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
static
constexpr
size_t
NormalSiteAttentionThreshold
=
500
;
static
constexpr
size_t
UnknownSiteAttentionThreshold
=
30000
;
static
constexpr
size_t
MaxAllocSitesPerMinorGC
=
500
;
static
constexpr
size_t
MaxInvalidationCount
=
5
;
static
constexpr
size_t
MinCellsRequiredForSurvivalRate
=
100
;
static
constexpr
double
LowYoungSurvivalThreshold
=
0
.
05
;
static
constexpr
size_t
LowYoungSurvivalCountBeforeRecovery
=
2
;
static
constexpr
double
HighNurserySurvivalPromotionThreshold
=
0
.
6
;
static
constexpr
size_t
HighNurserySurvivalOptimizedAllocThreshold
=
10000
;
static
constexpr
size_t
HighNurserySurvivalCountBeforeRecovery
=
2
;
AllocSite
*
const
AllocSite
:
:
EndSentinel
=
reinterpret_cast
<
AllocSite
*
>
(
1
)
;
JSScript
*
const
AllocSite
:
:
WasmScript
=
reinterpret_cast
<
JSScript
*
>
(
AllocSite
:
:
STATE_MASK
+
1
)
;
void
AllocSite
:
:
staticAsserts
(
)
{
static_assert
(
jit
:
:
BaselineMaxScriptLength
<
=
MaxValidPCOffset
)
;
}
bool
PretenuringNursery
:
:
canCreateAllocSite
(
)
{
MOZ_ASSERT
(
allocSitesCreated
<
=
MaxAllocSitesPerMinorGC
)
;
return
JS
:
:
Prefs
:
:
site_based_pretenuring
(
)
&
&
allocSitesCreated
<
MaxAllocSitesPerMinorGC
;
}
size_t
PretenuringNursery
:
:
doPretenuring
(
GCRuntime
*
gc
JS
:
:
GCReason
reason
bool
validPromotionRate
double
promotionRate
bool
reportInfo
size_t
reportThreshold
)
{
size_t
sitesActive
=
0
;
size_t
sitesPretenured
=
0
;
size_t
sitesInvalidated
=
0
;
size_t
zonesWithHighNurserySurvival
=
0
;
totalAllocCount_
=
0
;
for
(
ZonesIter
zone
(
gc
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
auto
&
count
:
zone
-
>
pretenuring
.
nurseryAllocCounts
)
{
count
=
0
;
}
}
if
(
validPromotionRate
)
{
for
(
ZonesIter
zone
(
gc
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
bool
highNurserySurvivalRate
=
promotionRate
>
HighNurserySurvivalPromotionThreshold
&
&
zone
-
>
optimizedAllocSite
(
)
-
>
nurseryPromotedCount
>
=
HighNurserySurvivalOptimizedAllocThreshold
;
zone
-
>
pretenuring
.
noteHighNurserySurvivalRate
(
highNurserySurvivalRate
)
;
if
(
highNurserySurvivalRate
)
{
zonesWithHighNurserySurvival
+
+
;
}
}
}
if
(
reportInfo
)
{
AllocSite
:
:
printInfoHeader
(
gc
reason
promotionRate
)
;
}
AllocSite
*
site
=
allocatedSites
;
allocatedSites
=
AllocSite
:
:
EndSentinel
;
while
(
site
!
=
AllocSite
:
:
EndSentinel
)
{
AllocSite
*
next
=
site
-
>
nextNurseryAllocated
;
site
-
>
nextNurseryAllocated
=
nullptr
;
if
(
site
-
>
isNormal
(
)
)
{
sitesActive
+
+
;
updateTotalAllocCounts
(
site
)
;
auto
result
=
site
-
>
processSite
(
gc
NormalSiteAttentionThreshold
reportInfo
reportThreshold
)
;
if
(
result
=
=
AllocSite
:
:
WasPretenured
|
|
result
=
=
AllocSite
:
:
WasPretenuredAndInvalidated
)
{
sitesPretenured
+
+
;
if
(
site
-
>
hasScript
(
)
)
{
site
-
>
script
(
)
-
>
realm
(
)
-
>
numAllocSitesPretenured
+
+
;
}
}
if
(
result
=
=
AllocSite
:
:
WasPretenuredAndInvalidated
)
{
sitesInvalidated
+
+
;
}
}
else
if
(
site
-
>
isMissing
(
)
)
{
sitesActive
+
+
;
updateTotalAllocCounts
(
site
)
;
site
-
>
processMissingSite
(
reportInfo
reportThreshold
)
;
}
site
=
next
;
}
for
(
ZonesIter
zone
(
gc
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
auto
&
site
:
zone
-
>
pretenuring
.
unknownAllocSites
)
{
updateTotalAllocCounts
(
&
site
)
;
if
(
site
.
traceKind
(
)
=
=
JS
:
:
TraceKind
:
:
Object
)
{
site
.
processCatchAllSite
(
reportInfo
reportThreshold
)
;
}
else
{
site
.
processSite
(
gc
UnknownSiteAttentionThreshold
reportInfo
reportThreshold
)
;
}
}
updateTotalAllocCounts
(
zone
-
>
optimizedAllocSite
(
)
)
;
zone
-
>
optimizedAllocSite
(
)
-
>
processCatchAllSite
(
reportInfo
reportThreshold
)
;
for
(
AllocSite
&
site
:
zone
-
>
pretenuring
.
promotedAllocSites
)
{
site
.
resetNurseryAllocations
(
)
;
}
}
if
(
reportInfo
)
{
AllocSite
:
:
printInfoFooter
(
allocSitesCreated
sitesActive
sitesPretenured
sitesInvalidated
)
;
if
(
zonesWithHighNurserySurvival
)
{
fprintf
(
stderr
"
%
zu
zones
with
high
nursery
survival
rate
\
n
"
zonesWithHighNurserySurvival
)
;
}
}
allocSitesCreated
=
0
;
return
sitesPretenured
;
}
AllocSite
:
:
SiteResult
AllocSite
:
:
processSite
(
GCRuntime
*
gc
size_t
attentionThreshold
bool
reportInfo
size_t
reportThreshold
)
{
MOZ_ASSERT
(
isNormal
(
)
|
|
isUnknown
(
)
)
;
MOZ_ASSERT
(
nurseryAllocCount
>
=
nurseryPromotedCount
)
;
SiteResult
result
=
NoChange
;
bool
hasPromotionRate
=
false
;
double
promotionRate
=
0
.
0
;
bool
wasInvalidated
=
false
;
if
(
nurseryAllocCount
>
attentionThreshold
)
{
promotionRate
=
double
(
nurseryPromotedCount
)
/
double
(
nurseryAllocCount
)
;
hasPromotionRate
=
true
;
AllocSite
:
:
State
prevState
=
state
(
)
;
updateStateOnMinorGC
(
promotionRate
)
;
AllocSite
:
:
State
newState
=
state
(
)
;
if
(
prevState
=
=
AllocSite
:
:
State
:
:
Unknown
&
&
newState
=
=
AllocSite
:
:
State
:
:
LongLived
)
{
result
=
WasPretenured
;
if
(
isNormal
(
)
&
&
hasScript
(
)
)
{
wasInvalidated
=
invalidateScript
(
gc
)
;
if
(
wasInvalidated
)
{
result
=
WasPretenuredAndInvalidated
;
}
}
}
}
if
(
reportInfo
&
&
allocCount
(
)
>
=
reportThreshold
)
{
printInfo
(
hasPromotionRate
promotionRate
wasInvalidated
)
;
}
resetNurseryAllocations
(
)
;
return
result
;
}
void
AllocSite
:
:
processMissingSite
(
bool
reportInfo
size_t
reportThreshold
)
{
MOZ_ASSERT
(
isMissing
(
)
)
;
MOZ_ASSERT
(
nurseryAllocCount
>
=
nurseryPromotedCount
)
;
AllocSite
*
unknownSite
=
zone
(
)
-
>
unknownAllocSite
(
traceKind
(
)
)
;
unknownSite
-
>
nurseryAllocCount
+
=
nurseryAllocCount
;
unknownSite
-
>
nurseryPromotedCount
+
=
nurseryPromotedCount
;
bool
hasPromotionRate
=
false
;
double
promotionRate
=
0
.
0
;
if
(
nurseryAllocCount
>
NormalSiteAttentionThreshold
)
{
promotionRate
=
double
(
nurseryPromotedCount
)
/
double
(
nurseryAllocCount
)
;
hasPromotionRate
=
true
;
updateStateOnMinorGC
(
promotionRate
)
;
}
if
(
reportInfo
&
&
allocCount
(
)
>
=
reportThreshold
)
{
printInfo
(
hasPromotionRate
promotionRate
false
)
;
}
resetNurseryAllocations
(
)
;
}
void
AllocSite
:
:
processCatchAllSite
(
bool
reportInfo
size_t
reportThreshold
)
{
MOZ_ASSERT
(
isUnknown
(
)
|
|
isOptimized
(
)
)
;
if
(
!
hasNurseryAllocations
(
)
)
{
return
;
}
if
(
reportInfo
&
&
allocCount
(
)
>
=
reportThreshold
)
{
printInfo
(
false
0
.
0
false
)
;
}
resetNurseryAllocations
(
)
;
}
void
PretenuringNursery
:
:
updateTotalAllocCounts
(
AllocSite
*
site
)
{
JS
:
:
TraceKind
kind
=
site
-
>
traceKind
(
)
;
totalAllocCount_
+
=
site
-
>
nurseryAllocCount
;
PretenuringZone
&
zone
=
site
-
>
zone
(
)
-
>
pretenuring
;
zone
.
nurseryAllocCount
(
kind
)
+
=
site
-
>
nurseryAllocCount
;
}
bool
AllocSite
:
:
invalidateScript
(
GCRuntime
*
gc
)
{
CancelOffThreadIonCompile
(
script
(
)
)
;
if
(
!
script
(
)
-
>
hasIonScript
(
)
)
{
return
false
;
}
if
(
invalidationLimitReached
(
)
)
{
MOZ_ASSERT
(
state
(
)
=
=
State
:
:
Unknown
)
;
return
false
;
}
invalidationCount
+
+
;
if
(
invalidationLimitReached
(
)
)
{
setState
(
State
:
:
Unknown
)
;
}
JSContext
*
cx
=
gc
-
>
rt
-
>
mainContextFromOwnThread
(
)
;
jit
:
:
Invalidate
(
cx
script
(
)
false
true
)
;
return
true
;
}
bool
AllocSite
:
:
invalidationLimitReached
(
)
const
{
MOZ_ASSERT
(
invalidationCount
<
=
MaxInvalidationCount
)
;
return
invalidationCount
=
=
MaxInvalidationCount
;
}
void
PretenuringNursery
:
:
maybeStopPretenuring
(
GCRuntime
*
gc
)
{
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
double
rate
;
if
(
zone
-
>
pretenuring
.
calculateYoungTenuredSurvivalRate
(
&
rate
)
)
{
bool
lowYoungSurvivalRate
=
rate
<
LowYoungSurvivalThreshold
;
zone
-
>
pretenuring
.
noteLowYoungTenuredSurvivalRate
(
lowYoungSurvivalRate
)
;
}
}
}
void
AllocSite
:
:
updateStateOnMinorGC
(
double
promotionRate
)
{
if
(
invalidationLimitReached
(
)
)
{
MOZ_ASSERT
(
state
(
)
=
=
State
:
:
Unknown
)
;
return
;
}
bool
highPromotionRate
=
promotionRate
>
=
0
.
9
;
switch
(
state
(
)
)
{
case
State
:
:
Unknown
:
if
(
highPromotionRate
)
{
setState
(
State
:
:
LongLived
)
;
}
else
{
setState
(
State
:
:
ShortLived
)
;
}
break
;
case
State
:
:
ShortLived
:
{
if
(
highPromotionRate
)
{
setState
(
State
:
:
Unknown
)
;
}
break
;
}
case
State
:
:
LongLived
:
{
if
(
!
highPromotionRate
)
{
setState
(
State
:
:
Unknown
)
;
}
break
;
}
}
}
bool
AllocSite
:
:
maybeResetState
(
)
{
if
(
invalidationLimitReached
(
)
)
{
MOZ_ASSERT
(
state
(
)
=
=
State
:
:
Unknown
)
;
return
false
;
}
invalidationCount
+
+
;
setState
(
State
:
:
Unknown
)
;
return
true
;
}
void
AllocSite
:
:
trace
(
JSTracer
*
trc
)
{
if
(
hasScript
(
)
)
{
JSScript
*
s
=
script
(
)
;
TraceManuallyBarrieredEdge
(
trc
&
s
"
AllocSite
script
"
)
;
if
(
s
!
=
script
(
)
)
{
setScript
(
s
)
;
}
}
}
bool
AllocSite
:
:
traceWeak
(
JSTracer
*
trc
)
{
if
(
hasScript
(
)
)
{
JSScript
*
s
=
script
(
)
;
if
(
!
TraceManuallyBarrieredWeakEdge
(
trc
&
s
"
AllocSite
script
"
)
)
{
return
false
;
}
if
(
s
!
=
script
(
)
)
{
setScript
(
s
)
;
}
}
return
true
;
}
bool
AllocSite
:
:
needsSweep
(
JSTracer
*
trc
)
const
{
if
(
hasScript
(
)
)
{
JSScript
*
s
=
script
(
)
;
return
IsAboutToBeFinalizedUnbarriered
(
s
)
;
}
return
false
;
}
bool
PretenuringZone
:
:
calculateYoungTenuredSurvivalRate
(
double
*
rateOut
)
{
MOZ_ASSERT
(
allocCountInNewlyCreatedArenas
>
=
survivorCountInNewlyCreatedArenas
)
;
if
(
allocCountInNewlyCreatedArenas
<
MinCellsRequiredForSurvivalRate
)
{
return
false
;
}
*
rateOut
=
double
(
survivorCountInNewlyCreatedArenas
)
/
double
(
allocCountInNewlyCreatedArenas
)
;
return
true
;
}
void
PretenuringZone
:
:
noteLowYoungTenuredSurvivalRate
(
bool
lowYoungSurvivalRate
)
{
if
(
lowYoungSurvivalRate
)
{
lowYoungTenuredSurvivalCount
+
+
;
}
else
{
lowYoungTenuredSurvivalCount
=
0
;
}
}
void
PretenuringZone
:
:
noteHighNurserySurvivalRate
(
bool
highNurserySurvivalRate
)
{
if
(
highNurserySurvivalRate
)
{
highNurserySurvivalCount
+
+
;
}
else
{
highNurserySurvivalCount
=
0
;
}
}
bool
PretenuringZone
:
:
shouldResetNurseryAllocSites
(
)
{
bool
shouldReset
=
highNurserySurvivalCount
>
=
HighNurserySurvivalCountBeforeRecovery
;
if
(
shouldReset
)
{
highNurserySurvivalCount
=
0
;
}
return
shouldReset
;
}
bool
PretenuringZone
:
:
shouldResetPretenuredAllocSites
(
)
{
bool
shouldReset
=
lowYoungTenuredSurvivalCount
>
=
LowYoungSurvivalCountBeforeRecovery
;
if
(
shouldReset
)
{
lowYoungTenuredSurvivalCount
=
0
;
}
return
shouldReset
;
}
static
const
char
*
AllocSiteKindName
(
AllocSite
:
:
Kind
kind
)
{
switch
(
kind
)
{
case
AllocSite
:
:
Kind
:
:
Normal
:
return
"
normal
"
;
case
AllocSite
:
:
Kind
:
:
Unknown
:
return
"
unknown
"
;
case
AllocSite
:
:
Kind
:
:
Optimized
:
return
"
optimized
"
;
case
AllocSite
:
:
Kind
:
:
Missing
:
return
"
missing
"
;
default
:
MOZ_CRASH
(
"
Bad
AllocSite
kind
"
)
;
}
}
void
AllocSite
:
:
printInfoHeader
(
GCRuntime
*
gc
JS
:
:
GCReason
reason
double
promotionRate
)
{
fprintf
(
stderr
"
Pretenuring
info
after
minor
GC
%
zu
for
%
s
reason
with
promotion
"
"
rate
%
4
.
1f
%
%
:
\
n
"
size_t
(
gc
-
>
minorGCCount
(
)
)
ExplainGCReason
(
reason
)
promotionRate
*
100
.
0
)
;
fprintf
(
stderr
"
%
-
16s
%
-
16s
%
-
20s
%
-
12s
%
-
9s
%
-
9s
%
-
8s
%
-
8s
%
-
6s
%
-
10s
\
n
"
"
Site
"
"
Zone
"
"
Location
"
"
BytecodeOp
"
"
SiteKind
"
"
TraceKind
"
"
NAllocs
"
"
Promotes
"
"
PRate
"
"
State
"
)
;
}
static
const
char
*
FindBaseName
(
const
char
*
filename
)
{
#
ifdef
XP_WIN
constexpr
char
PathSeparator
=
'
\
\
'
;
#
else
constexpr
char
PathSeparator
=
'
/
'
;
#
endif
const
char
*
lastSep
=
strrchr
(
filename
PathSeparator
)
;
if
(
!
lastSep
)
{
return
filename
;
}
return
lastSep
+
1
;
}
void
AllocSite
:
:
printInfo
(
bool
hasPromotionRate
double
promotionRate
bool
wasInvalidated
)
const
{
fprintf
(
stderr
"
%
16p
%
16p
"
this
zone
(
)
)
;
char
location
[
21
]
=
{
'
\
0
'
}
;
char
opName
[
13
]
=
{
'
\
0
'
}
;
if
(
hasScript
(
)
)
{
uint32_t
line
=
PCToLineNumber
(
script
(
)
script
(
)
-
>
offsetToPC
(
pcOffset
(
)
)
)
;
const
char
*
scriptName
=
FindBaseName
(
script
(
)
-
>
filename
(
)
)
;
SprintfLiteral
(
location
"
%
s
:
%
u
"
scriptName
line
)
;
BytecodeLocation
location
=
script
(
)
-
>
offsetToLocation
(
pcOffset
(
)
)
;
SprintfLiteral
(
opName
"
%
s
"
CodeName
(
location
.
getOp
(
)
)
)
;
}
fprintf
(
stderr
"
%
-
20s
%
-
12s
"
location
opName
)
;
fprintf
(
stderr
"
%
-
9s
"
AllocSiteKindName
(
kind
(
)
)
)
;
const
char
*
traceKindName
=
"
"
;
if
(
!
isOptimized
(
)
)
{
traceKindName
=
JS
:
:
GCTraceKindToAscii
(
traceKind
(
)
)
;
}
fprintf
(
stderr
"
%
-
9s
"
traceKindName
)
;
char
buffer
[
16
]
=
{
'
\
0
'
}
;
if
(
!
isOptimized
(
)
)
{
SprintfLiteral
(
buffer
"
%
8
"
PRIu32
nurseryAllocCount
)
;
}
fprintf
(
stderr
"
%
8s
"
buffer
)
;
fprintf
(
stderr
"
%
8
"
PRIu32
nurseryPromotedCount
)
;
buffer
[
0
]
=
'
\
0
'
;
if
(
hasPromotionRate
)
{
SprintfLiteral
(
buffer
"
%
5
.
1f
%
%
"
std
:
:
min
(
1
.
0
promotionRate
)
*
100
)
;
}
fprintf
(
stderr
"
%
6s
"
buffer
)
;
const
char
*
state
=
"
"
;
if
(
!
isOptimized
(
)
)
{
state
=
stateName
(
)
;
}
fprintf
(
stderr
"
%
-
10s
"
state
)
;
if
(
wasInvalidated
)
{
fprintf
(
stderr
"
invalidated
"
)
;
}
fprintf
(
stderr
"
\
n
"
)
;
}
void
AllocSite
:
:
printInfoFooter
(
size_t
sitesCreated
size_t
sitesActive
size_t
sitesPretenured
size_t
sitesInvalidated
)
{
fprintf
(
stderr
"
%
zu
alloc
sites
created
%
zu
active
%
zu
pretenured
%
zu
"
"
invalidated
\
n
"
sitesCreated
sitesActive
sitesPretenured
sitesInvalidated
)
;
}
const
char
*
AllocSite
:
:
stateName
(
)
const
{
switch
(
state
(
)
)
{
case
State
:
:
ShortLived
:
return
"
ShortLived
"
;
case
State
:
:
Unknown
:
return
"
Unknown
"
;
case
State
:
:
LongLived
:
return
"
LongLived
"
;
}
MOZ_CRASH
(
"
Unknown
state
"
)
;
}
#
ifdef
JS_GC_ZEAL
AllocSite
*
js
:
:
gc
:
:
GetOrCreateMissingAllocSite
(
JSContext
*
cx
JSScript
*
script
uint32_t
pcOffset
JS
:
:
TraceKind
traceKind
)
{
Zone
*
zone
=
cx
-
>
zone
(
)
;
auto
&
missingSites
=
zone
-
>
missingSites
;
if
(
!
missingSites
)
{
missingSites
=
MakeUnique
<
MissingAllocSites
>
(
zone
)
;
if
(
!
missingSites
)
{
return
nullptr
;
}
}
auto
scriptPtr
=
missingSites
-
>
scriptMap
.
lookupForAdd
(
script
)
;
if
(
!
scriptPtr
&
&
!
missingSites
-
>
scriptMap
.
add
(
scriptPtr
script
MissingAllocSites
:
:
SiteMap
(
)
)
)
{
return
nullptr
;
}
auto
&
siteMap
=
scriptPtr
-
>
value
(
)
;
auto
sitePtr
=
siteMap
.
lookupForAdd
(
pcOffset
)
;
if
(
!
sitePtr
)
{
UniquePtr
<
AllocSite
>
site
=
MakeUnique
<
AllocSite
>
(
zone
script
pcOffset
traceKind
AllocSite
:
:
Kind
:
:
Missing
)
;
if
(
!
site
|
|
!
siteMap
.
add
(
sitePtr
pcOffset
std
:
:
move
(
site
)
)
)
{
return
nullptr
;
}
}
return
sitePtr
-
>
value
(
)
.
get
(
)
;
}
#
endif
