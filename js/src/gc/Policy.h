#
ifndef
gc_Policy_h
#
define
gc_Policy_h
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
js
/
GCPolicyAPI
.
h
"
class
JSLinearString
;
namespace
js
{
class
AccessorShape
;
class
ArgumentsObject
;
class
ArrayBufferObject
;
class
ArrayBufferObjectMaybeShared
;
class
ArrayBufferViewObject
;
class
ArrayObject
;
class
BaseShape
;
class
DebugEnvironmentProxy
;
class
DebuggerFrame
;
class
ExportEntryObject
;
class
EnvironmentObject
;
class
GlobalObject
;
class
ImportEntryObject
;
class
LazyScript
;
class
LexicalEnvironmentObject
;
class
ModuleEnvironmentObject
;
class
ModuleNamespaceObject
;
class
ModuleObject
;
class
NativeObject
;
class
ObjectGroup
;
class
PlainObject
;
class
PropertyName
;
class
RegExpObject
;
class
SavedFrame
;
class
Scope
;
class
EnvironmentObject
;
class
RequestedModuleObject
;
class
ScriptSourceObject
;
class
Shape
;
class
SharedArrayBufferObject
;
class
StructTypeDescr
;
class
UnownedBaseShape
;
class
WasmGlobalObject
;
class
WasmFunctionScope
;
class
WasmMemoryObject
;
namespace
jit
{
class
JitCode
;
}
}
#
define
FOR_EACH_INTERNAL_GC_POINTER_TYPE
(
D
)
\
D
(
JSFlatString
*
)
\
D
(
JSLinearString
*
)
\
D
(
js
:
:
AccessorShape
*
)
\
D
(
js
:
:
ArgumentsObject
*
)
\
D
(
js
:
:
ArrayBufferObject
*
)
\
D
(
js
:
:
ArrayBufferObjectMaybeShared
*
)
\
D
(
js
:
:
ArrayBufferViewObject
*
)
\
D
(
js
:
:
ArrayObject
*
)
\
D
(
js
:
:
BaseShape
*
)
\
D
(
js
:
:
DebugEnvironmentProxy
*
)
\
D
(
js
:
:
DebuggerFrame
*
)
\
D
(
js
:
:
ExportEntryObject
*
)
\
D
(
js
:
:
EnvironmentObject
*
)
\
D
(
js
:
:
GlobalObject
*
)
\
D
(
js
:
:
ImportEntryObject
*
)
\
D
(
js
:
:
LazyScript
*
)
\
D
(
js
:
:
LexicalEnvironmentObject
*
)
\
D
(
js
:
:
ModuleEnvironmentObject
*
)
\
D
(
js
:
:
ModuleNamespaceObject
*
)
\
D
(
js
:
:
ModuleObject
*
)
\
D
(
js
:
:
NativeObject
*
)
\
D
(
js
:
:
ObjectGroup
*
)
\
D
(
js
:
:
PlainObject
*
)
\
D
(
js
:
:
PropertyName
*
)
\
D
(
js
:
:
RegExpObject
*
)
\
D
(
js
:
:
RegExpShared
*
)
\
D
(
js
:
:
RequestedModuleObject
*
)
\
D
(
js
:
:
SavedFrame
*
)
\
D
(
js
:
:
Scope
*
)
\
D
(
js
:
:
ScriptSourceObject
*
)
\
D
(
js
:
:
Shape
*
)
\
D
(
js
:
:
SharedArrayBufferObject
*
)
\
D
(
js
:
:
StructTypeDescr
*
)
\
D
(
js
:
:
UnownedBaseShape
*
)
\
D
(
js
:
:
WasmFunctionScope
*
)
\
D
(
js
:
:
WasmInstanceObject
*
)
\
D
(
js
:
:
WasmMemoryObject
*
)
\
D
(
js
:
:
WasmTableObject
*
)
\
D
(
js
:
:
WasmGlobalObject
*
)
\
D
(
js
:
:
jit
:
:
JitCode
*
)
#
define
FOR_EACH_INTERNAL_TAGGED_GC_POINTER_TYPE
(
D
)
\
D
(
js
:
:
TaggedProto
)
#
define
FOR_EACH_GC_POINTER_TYPE
(
D
)
\
FOR_EACH_PUBLIC_GC_POINTER_TYPE
(
D
)
\
FOR_EACH_PUBLIC_TAGGED_GC_POINTER_TYPE
(
D
)
\
FOR_EACH_INTERNAL_GC_POINTER_TYPE
(
D
)
\
FOR_EACH_INTERNAL_TAGGED_GC_POINTER_TYPE
(
D
)
namespace
js
{
template
<
typename
T
>
struct
InternalGCPointerPolicy
:
public
JS
:
:
GCPointerPolicy
<
T
>
{
using
Type
=
typename
mozilla
:
:
RemovePointer
<
T
>
:
:
Type
;
#
define
IS_BASE_OF_OR
(
_1
BaseType
_2
)
mozilla
:
:
IsBaseOf
<
BaseType
Type
>
:
:
value
|
|
static_assert
(
JS_FOR_EACH_TRACEKIND
(
IS_BASE_OF_OR
)
false
"
InternalGCPointerPolicy
must
only
be
used
for
GC
thing
pointers
"
)
;
#
undef
IS_BASE_OF_OR
static
void
preBarrier
(
T
v
)
{
if
(
v
)
Type
:
:
writeBarrierPre
(
v
)
;
}
static
void
postBarrier
(
T
*
vp
T
prev
T
next
)
{
if
(
*
vp
)
Type
:
:
writeBarrierPost
(
vp
prev
next
)
;
}
static
void
readBarrier
(
T
v
)
{
if
(
v
)
Type
:
:
readBarrier
(
v
)
;
}
static
void
trace
(
JSTracer
*
trc
T
*
vp
const
char
*
name
)
{
if
(
*
vp
)
TraceManuallyBarrieredEdge
(
trc
vp
name
)
;
}
}
;
}
namespace
JS
{
template
<
typename
T
>
struct
GCPolicy
<
T
*
>
:
public
js
:
:
InternalGCPointerPolicy
<
T
*
>
{
}
;
template
<
typename
T
>
struct
GCPolicy
<
T
*
const
>
:
public
js
:
:
InternalGCPointerPolicy
<
T
*
const
>
{
}
;
template
<
typename
T
>
struct
GCPolicy
<
js
:
:
HeapPtr
<
T
>
>
{
static
void
trace
(
JSTracer
*
trc
js
:
:
HeapPtr
<
T
>
*
thingp
const
char
*
name
)
{
js
:
:
TraceEdge
(
trc
thingp
name
)
;
}
static
bool
needsSweep
(
js
:
:
HeapPtr
<
T
>
*
thingp
)
{
return
js
:
:
gc
:
:
IsAboutToBeFinalized
(
thingp
)
;
}
}
;
template
<
typename
T
>
struct
GCPolicy
<
js
:
:
ReadBarriered
<
T
>
>
{
static
void
trace
(
JSTracer
*
trc
js
:
:
ReadBarriered
<
T
>
*
thingp
const
char
*
name
)
{
js
:
:
TraceEdge
(
trc
thingp
name
)
;
}
static
bool
needsSweep
(
js
:
:
ReadBarriered
<
T
>
*
thingp
)
{
return
js
:
:
gc
:
:
IsAboutToBeFinalized
(
thingp
)
;
}
}
;
}
#
endif
