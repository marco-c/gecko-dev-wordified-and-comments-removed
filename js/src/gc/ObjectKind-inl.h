#
ifndef
gc_ObjectKind_inl_h
#
define
gc_ObjectKind_inl_h
#
include
"
util
/
Memory
.
h
"
#
include
"
vm
/
NativeObject
.
h
"
namespace
js
{
namespace
gc
{
inline
constexpr
AllocKind
slotsToThingKind
[
]
=
{
AllocKind
:
:
OBJECT0
AllocKind
:
:
OBJECT2
AllocKind
:
:
OBJECT2
AllocKind
:
:
OBJECT4
AllocKind
:
:
OBJECT4
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT16
AllocKind
:
:
OBJECT16
AllocKind
:
:
OBJECT16
AllocKind
:
:
OBJECT16
}
;
extern
const
uint32_t
slotsToAllocKindBytes
[
]
;
static
constexpr
AllocKind
GetGCObjectKind
(
size_t
numSlots
)
{
if
(
numSlots
>
=
std
:
:
size
(
slotsToThingKind
)
)
{
return
AllocKind
:
:
OBJECT16
;
}
return
slotsToThingKind
[
numSlots
]
;
}
static
inline
AllocKind
GetGCObjectKind
(
const
JSClass
*
clasp
)
{
MOZ_ASSERT
(
!
clasp
-
>
isProxyObject
(
)
"
Proxies
should
use
GetProxyGCObjectKind
"
)
;
MOZ_ASSERT
(
!
clasp
-
>
isJSFunction
(
)
)
;
uint32_t
nslots
=
JSCLASS_RESERVED_SLOTS
(
clasp
)
;
return
GetGCObjectKind
(
nslots
)
;
}
static
constexpr
bool
CanUseFixedElementsForArray
(
size_t
numElements
)
{
if
(
numElements
>
NativeObject
:
:
MAX_DENSE_ELEMENTS_COUNT
)
{
return
false
;
}
size_t
numSlots
=
numElements
+
ObjectElements
:
:
VALUES_PER_HEADER
;
return
numSlots
<
std
:
:
size
(
slotsToThingKind
)
;
}
static
constexpr
AllocKind
GetGCArrayKind
(
size_t
numElements
)
{
static_assert
(
ObjectElements
:
:
VALUES_PER_HEADER
=
=
2
)
;
if
(
!
CanUseFixedElementsForArray
(
numElements
)
)
{
return
AllocKind
:
:
OBJECT2
;
}
return
slotsToThingKind
[
numElements
+
ObjectElements
:
:
VALUES_PER_HEADER
]
;
}
static
inline
AllocKind
GetGCObjectFixedSlotsKind
(
size_t
numFixedSlots
)
{
MOZ_ASSERT
(
numFixedSlots
<
std
:
:
size
(
slotsToThingKind
)
)
;
return
slotsToThingKind
[
numFixedSlots
]
;
}
static
inline
AllocKind
GetGCObjectKindForBytes
(
size_t
nbytes
)
{
MOZ_ASSERT
(
nbytes
<
=
JSObject
:
:
MAX_BYTE_SIZE
)
;
if
(
nbytes
<
=
sizeof
(
NativeObject
)
)
{
return
AllocKind
:
:
OBJECT0
;
}
nbytes
-
=
sizeof
(
NativeObject
)
;
size_t
dataSlots
=
AlignBytes
(
nbytes
sizeof
(
Value
)
)
/
sizeof
(
Value
)
;
MOZ_ASSERT
(
nbytes
<
=
dataSlots
*
sizeof
(
Value
)
)
;
return
GetGCObjectKind
(
dataSlots
)
;
}
static
constexpr
size_t
GetGCKindSlots
(
AllocKind
thingKind
)
{
switch
(
thingKind
)
{
case
AllocKind
:
:
OBJECT0
:
case
AllocKind
:
:
OBJECT0_BACKGROUND
:
return
0
;
case
AllocKind
:
:
OBJECT2
:
case
AllocKind
:
:
OBJECT2_BACKGROUND
:
return
2
;
case
AllocKind
:
:
FUNCTION
:
case
AllocKind
:
:
OBJECT4
:
case
AllocKind
:
:
OBJECT4_BACKGROUND
:
return
4
;
case
AllocKind
:
:
FUNCTION_EXTENDED
:
return
7
;
case
AllocKind
:
:
OBJECT8
:
case
AllocKind
:
:
OBJECT8_BACKGROUND
:
return
8
;
case
AllocKind
:
:
OBJECT12
:
case
AllocKind
:
:
OBJECT12_BACKGROUND
:
return
12
;
case
AllocKind
:
:
OBJECT16
:
case
AllocKind
:
:
OBJECT16_BACKGROUND
:
return
16
;
default
:
MOZ_CRASH
(
"
Bad
object
alloc
kind
"
)
;
}
}
static
inline
size_t
GetGCKindBytes
(
AllocKind
thingKind
)
{
return
sizeof
(
JSObject_Slots0
)
+
GetGCKindSlots
(
thingKind
)
*
sizeof
(
Value
)
;
}
static
inline
bool
CanUseBackgroundAllocKind
(
const
JSClass
*
clasp
)
{
return
!
clasp
-
>
hasFinalize
(
)
|
|
(
clasp
-
>
flags
&
JSCLASS_BACKGROUND_FINALIZE
)
;
}
static
inline
bool
CanChangeToBackgroundAllocKind
(
AllocKind
kind
const
JSClass
*
clasp
)
{
MOZ_ASSERT
(
IsObjectAllocKind
(
kind
)
)
;
if
(
IsBackgroundFinalized
(
kind
)
)
{
return
false
;
}
return
CanUseBackgroundAllocKind
(
clasp
)
;
}
static
inline
AllocKind
ForegroundToBackgroundAllocKind
(
AllocKind
fgKind
)
{
MOZ_ASSERT
(
IsObjectAllocKind
(
fgKind
)
)
;
MOZ_ASSERT
(
IsForegroundFinalized
(
fgKind
)
)
;
AllocKind
bgKind
=
AllocKind
(
size_t
(
fgKind
)
+
1
)
;
MOZ_ASSERT
(
IsObjectAllocKind
(
bgKind
)
)
;
MOZ_ASSERT
(
IsBackgroundFinalized
(
bgKind
)
)
;
MOZ_ASSERT
(
GetGCKindSlots
(
bgKind
)
=
=
GetGCKindSlots
(
fgKind
)
)
;
return
bgKind
;
}
}
}
#
endif
