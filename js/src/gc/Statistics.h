#
ifndef
gc_Statistics_h
#
define
gc_Statistics_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
js
/
Vector
.
h
"
namespace
js
{
class
JS_PUBLIC_API
Sprinter
;
class
JSONPrinter
;
namespace
gcstats
{
#
include
"
gc
/
StatsPhasesGenerated
.
h
"
enum
Count
{
COUNT_NEW_CHUNK
COUNT_DESTROY_CHUNK
COUNT_MINOR_GC
COUNT_STOREBUFFER_OVERFLOW
COUNT_ARENA_RELOCATED
COUNT_CELLS_MARKED
COUNT_PARALLEL_MARK_INTERRUPTIONS
COUNT_LIMIT
}
;
enum
Stat
{
STAT_STRINGS_TENURED
STAT_STRINGS_DEDUPLICATED
STAT_BIGINTS_TENURED
STAT_LIMIT
}
;
struct
ZoneGCStats
{
size_t
collectedZoneCount
=
0
;
size_t
zoneCount
=
0
;
size_t
sweptZoneCount
=
0
;
size_t
collectedCompartmentCount
=
0
;
size_t
compartmentCount
=
0
;
size_t
sweptCompartmentCount
=
0
;
size_t
realmCount
=
0
;
ZoneGCStats
(
)
=
default
;
}
;
struct
Trigger
{
size_t
amount
=
0
;
size_t
threshold
=
0
;
}
;
#
define
FOR_EACH_GC_PROFILE_TIME
(
_
)
\
_
(
Total
"
total
"
PhaseKind
:
:
NONE
)
\
_
(
Background
"
bgwrk
"
PhaseKind
:
:
NONE
)
\
_
(
MinorForMajor
"
evct4m
"
PhaseKind
:
:
EVICT_NURSERY_FOR_MAJOR_GC
)
\
_
(
WaitBgThread
"
waitBG
"
PhaseKind
:
:
WAIT_BACKGROUND_THREAD
)
\
_
(
Prepare
"
prep
"
PhaseKind
:
:
PREPARE
)
\
_
(
Mark
"
mark
"
PhaseKind
:
:
MARK
)
\
_
(
Sweep
"
sweep
"
PhaseKind
:
:
SWEEP
)
\
_
(
Compact
"
cmpct
"
PhaseKind
:
:
COMPACT
)
\
_
(
Decommit
"
dcmmt
"
PhaseKind
:
:
DECOMMIT
)
static
const
char
*
const
MajorGCProfilePrefix
=
"
MajorGC
:
"
;
static
const
char
*
const
MinorGCProfilePrefix
=
"
MinorGC
:
"
;
const
char
*
ExplainAbortReason
(
GCAbortReason
reason
)
;
struct
Statistics
{
template
<
typename
T
size_t
Length
>
using
Array
=
mozilla
:
:
Array
<
T
Length
>
;
template
<
typename
IndexType
typename
ValueType
IndexType
SizeAsEnumValue
>
using
EnumeratedArray
=
mozilla
:
:
EnumeratedArray
<
IndexType
ValueType
size_t
(
SizeAsEnumValue
)
>
;
using
TimeDuration
=
mozilla
:
:
TimeDuration
;
using
TimeStamp
=
mozilla
:
:
TimeStamp
;
using
PhaseTimes
=
EnumeratedArray
<
Phase
TimeDuration
Phase
:
:
LIMIT
>
;
using
PhaseKindTimes
=
EnumeratedArray
<
PhaseKind
TimeDuration
PhaseKind
:
:
LIMIT
>
;
using
PhaseTimeStamps
=
EnumeratedArray
<
Phase
TimeStamp
Phase
:
:
LIMIT
>
;
[
[
nodiscard
]
]
static
bool
initialize
(
)
;
explicit
Statistics
(
gc
:
:
GCRuntime
*
gc
)
;
~
Statistics
(
)
;
Statistics
(
const
Statistics
&
)
=
delete
;
Statistics
&
operator
=
(
const
Statistics
&
)
=
delete
;
void
beginPhase
(
PhaseKind
phaseKind
)
;
void
endPhase
(
PhaseKind
phaseKind
)
;
void
recordParallelPhase
(
PhaseKind
phaseKind
TimeDuration
duration
)
;
void
suspendPhases
(
PhaseKind
suspension
=
PhaseKind
:
:
EXPLICIT_SUSPENSION
)
;
void
resumePhases
(
)
;
void
beginSlice
(
const
ZoneGCStats
&
zoneStats
JS
:
:
GCOptions
options
const
JS
:
:
SliceBudget
&
budget
JS
:
:
GCReason
reason
bool
budgetWasIncreased
)
;
void
endSlice
(
)
;
[
[
nodiscard
]
]
bool
startTimingMutator
(
)
;
[
[
nodiscard
]
]
bool
stopTimingMutator
(
double
&
mutator_ms
double
&
gc_ms
)
;
void
sweptZone
(
)
{
+
+
zoneStats
.
sweptZoneCount
;
}
void
sweptCompartment
(
)
{
+
+
zoneStats
.
sweptCompartmentCount
;
}
void
reset
(
GCAbortReason
reason
)
{
MOZ_ASSERT
(
reason
!
=
GCAbortReason
:
:
None
)
;
if
(
!
aborted
)
{
slices_
.
back
(
)
.
resetReason
=
reason
;
}
}
void
measureInitialHeapSizes
(
)
;
void
nonincremental
(
GCAbortReason
reason
)
{
MOZ_ASSERT
(
reason
!
=
GCAbortReason
:
:
None
)
;
nonincrementalReason_
=
reason
;
log
(
"
Non
-
incremental
reason
:
%
s
"
nonincrementalReason
(
)
)
;
}
bool
nonincremental
(
)
const
{
return
nonincrementalReason_
!
=
GCAbortReason
:
:
None
;
}
const
char
*
nonincrementalReason
(
)
const
{
return
ExplainAbortReason
(
nonincrementalReason_
)
;
}
void
count
(
Count
s
)
{
counts
[
s
]
+
+
;
}
void
addCount
(
Count
s
uint32_t
count
)
{
counts
[
s
]
+
=
count
;
}
uint32_t
getCount
(
Count
s
)
const
{
return
uint32_t
(
counts
[
s
]
)
;
}
void
setStat
(
Stat
s
uint32_t
value
)
{
stats
[
s
]
=
value
;
}
uint32_t
getStat
(
Stat
s
)
const
{
return
stats
[
s
]
;
}
void
recordTrigger
(
size_t
amount
size_t
threshold
)
{
recordedTrigger
=
mozilla
:
:
Some
(
Trigger
{
amount
threshold
}
)
;
}
bool
hasTrigger
(
)
const
{
return
recordedTrigger
.
isSome
(
)
;
}
void
setAllocsSinceMinorGCTenured
(
uint32_t
allocs
)
{
tenuredAllocsSinceMinorGC
=
allocs
;
}
uint32_t
allocsSinceMinorGCTenured
(
)
{
return
tenuredAllocsSinceMinorGC
;
}
void
beginNurseryCollection
(
)
;
void
endNurseryCollection
(
)
;
TimeStamp
beginSCC
(
)
;
void
endSCC
(
unsigned
scc
TimeStamp
start
)
;
UniqueChars
formatCompactSliceMessage
(
)
const
;
UniqueChars
formatCompactSummaryMessage
(
)
const
;
UniqueChars
formatDetailedMessage
(
)
const
;
JS
:
:
GCSliceCallback
setSliceCallback
(
JS
:
:
GCSliceCallback
callback
)
;
TimeDuration
clearMaxGCPauseAccumulator
(
)
;
TimeDuration
getMaxGCPauseSinceClear
(
)
;
PhaseKind
currentPhaseKind
(
)
const
;
static
const
size_t
MAX_SUSPENDED_PHASES
=
MAX_PHASE_NESTING
*
3
;
struct
SliceData
{
SliceData
(
const
JS
:
:
SliceBudget
&
budget
mozilla
:
:
Maybe
<
Trigger
>
trigger
JS
:
:
GCReason
reason
TimeStamp
start
size_t
startFaults
gc
:
:
State
initialState
)
;
JS
:
:
SliceBudget
budget
;
JS
:
:
GCReason
reason
=
JS
:
:
GCReason
:
:
NO_REASON
;
mozilla
:
:
Maybe
<
Trigger
>
trigger
;
gc
:
:
State
initialState
=
gc
:
:
State
:
:
NotActive
;
gc
:
:
State
finalState
=
gc
:
:
State
:
:
NotActive
;
GCAbortReason
resetReason
=
GCAbortReason
:
:
None
;
TimeStamp
start
;
TimeStamp
end
;
size_t
startFaults
=
0
;
size_t
endFaults
=
0
;
PhaseTimes
phaseTimes
;
PhaseKindTimes
totalParallelTimes
;
PhaseKindTimes
maxParallelTimes
;
TimeDuration
duration
(
)
const
;
bool
wasReset
(
)
const
{
return
resetReason
!
=
GCAbortReason
:
:
None
;
}
}
;
using
SliceDataVector
=
Vector
<
SliceData
8
SystemAllocPolicy
>
;
const
SliceDataVector
&
slices
(
)
const
{
return
slices_
;
}
const
SliceData
&
sliceAt
(
size_t
index
)
const
{
return
slices_
[
index
]
;
}
const
SliceData
*
lastSlice
(
)
const
{
if
(
slices_
.
length
(
)
=
=
0
)
{
return
nullptr
;
}
return
&
slices_
.
back
(
)
;
}
TimeStamp
start
(
)
const
{
return
slices_
[
0
]
.
start
;
}
TimeStamp
end
(
)
const
{
return
slices_
.
back
(
)
.
end
;
}
TimeStamp
creationTime
(
)
const
{
return
creationTime_
;
}
TimeDuration
totalGCTime
(
)
const
{
return
totalGCTime_
;
}
size_t
initialCollectedBytes
(
)
const
{
return
preCollectedGCHeapBytes
;
}
FILE
*
profileFile
(
)
const
{
return
gcProfileFile
;
}
void
maybePrintProfileHeaders
(
)
;
void
printProfileHeader
(
)
;
void
printTotalProfileTimes
(
)
;
UniqueChars
renderJsonMessage
(
)
const
;
UniqueChars
renderJsonSlice
(
size_t
sliceNum
)
const
;
UniqueChars
renderNurseryJson
(
)
const
;
bool
bufferAllocStatsEnabled
(
)
const
{
return
enableBufferAllocStats_
;
}
#
ifdef
DEBUG
void
log
(
const
char
*
fmt
.
.
.
)
;
#
else
void
log
(
const
char
*
fmt
.
.
.
)
{
}
;
#
endif
private
:
gc
:
:
GCRuntime
*
const
gc
;
FILE
*
gcTimerFile
;
FILE
*
gcDebugFile
;
FILE
*
gcProfileFile
;
ZoneGCStats
zoneStats
;
JS
:
:
GCOptions
gcOptions
=
JS
:
:
GCOptions
:
:
Normal
;
GCAbortReason
nonincrementalReason_
;
SliceDataVector
slices_
;
PhaseTimeStamps
phaseStartTimes
;
#
ifdef
DEBUG
PhaseTimeStamps
phaseEndTimes
;
#
endif
TimeStamp
creationTime_
;
TimeStamp
timedGCStart
;
TimeDuration
timedGCTime
;
PhaseTimes
phaseTimes
;
TimeDuration
totalGCTime_
;
EnumeratedArray
<
Count
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
COUNT_LIMIT
>
counts
;
EnumeratedArray
<
Stat
uint32_t
STAT_LIMIT
>
stats
;
uint32_t
tenuredAllocsSinceMinorGC
;
size_t
preTotalGCHeapBytes
;
size_t
postTotalGCHeapBytes
;
size_t
preCollectedGCHeapBytes
;
size_t
preTotalMallocHeapBytes
;
size_t
postTotalMallocHeapBytes
;
mozilla
:
:
Maybe
<
Trigger
>
recordedTrigger
;
uint64_t
startingMinorGCNumber
;
uint64_t
startingMajorGCNumber
;
uint64_t
startingSliceNumber
;
mutable
TimeDuration
maxPauseInInterval
;
Vector
<
Phase
MAX_PHASE_NESTING
SystemAllocPolicy
>
phaseStack
;
Vector
<
Phase
MAX_SUSPENDED_PHASES
SystemAllocPolicy
>
suspendedPhases
;
Vector
<
TimeDuration
0
SystemAllocPolicy
>
sccTimes
;
TimeDuration
timeSinceLastGC
;
JS
:
:
GCSliceCallback
sliceCallback
;
bool
aborted
;
enum
class
ProfileKey
{
#
define
DEFINE_PROFILE_KEY
(
name
_1
_2
)
name
FOR_EACH_GC_PROFILE_TIME
(
DEFINE_PROFILE_KEY
)
#
undef
DEFINE_PROFILE_KEY
KeyCount
}
;
using
ProfileDurations
=
EnumeratedArray
<
ProfileKey
TimeDuration
ProfileKey
:
:
KeyCount
>
;
bool
enableProfiling_
=
false
;
bool
profileWorkers_
=
false
;
bool
enableBufferAllocStats_
=
false
;
TimeDuration
profileThreshold_
;
ProfileDurations
totalTimes_
;
uint64_t
sliceCount_
;
char
formatBuffer_
[
32
]
;
static
constexpr
int
FormatBufferLength
=
sizeof
(
formatBuffer_
)
;
JSContext
*
context
(
)
;
Phase
currentPhase
(
)
const
;
Phase
lookupChildPhase
(
PhaseKind
phaseKind
)
const
;
void
beginGC
(
JS
:
:
GCOptions
options
const
TimeStamp
&
currentTime
)
;
void
endGC
(
)
;
void
sendGCTelemetry
(
)
;
void
sendSliceTelemetry
(
const
SliceData
&
slice
)
;
TimeDuration
sumTotalParallelTime
(
PhaseKind
phaseKind
)
const
;
void
recordPhaseBegin
(
Phase
phase
)
;
void
recordPhaseEnd
(
Phase
phase
)
;
void
gcDuration
(
TimeDuration
*
total
TimeDuration
*
maxPause
)
const
;
void
sccDurations
(
TimeDuration
*
total
TimeDuration
*
maxPause
)
const
;
void
printStats
(
)
;
template
<
typename
Fn
>
void
reportLongestPhaseInMajorGC
(
PhaseKind
longest
Fn
reportFn
)
;
UniqueChars
formatCompactSlicePhaseTimes
(
const
PhaseTimes
&
phaseTimes
)
const
;
UniqueChars
formatDetailedDescription
(
)
const
;
UniqueChars
formatDetailedSliceDescription
(
unsigned
i
const
SliceData
&
slice
)
const
;
UniqueChars
formatDetailedPhaseTimes
(
const
PhaseTimes
&
phaseTimes
)
const
;
UniqueChars
formatDetailedTotals
(
)
const
;
void
formatJsonDescription
(
JSONPrinter
&
)
const
;
void
formatJsonSliceDescription
(
unsigned
i
const
SliceData
&
slice
JSONPrinter
&
)
const
;
void
formatJsonPhaseTimes
(
const
PhaseTimes
&
phaseTimes
JSONPrinter
&
)
const
;
void
formatJsonSlice
(
size_t
sliceNum
JSONPrinter
&
)
const
;
double
computeMMU
(
TimeDuration
window
)
const
;
void
printSliceProfile
(
)
;
ProfileDurations
getProfileTimes
(
const
SliceData
&
slice
)
const
;
void
updateTotalProfileTimes
(
const
ProfileDurations
&
times
)
;
const
char
*
formatGCStates
(
const
SliceData
&
slice
)
;
const
char
*
formatGCFlags
(
const
SliceData
&
slice
)
;
const
char
*
formatBudget
(
const
SliceData
&
slice
)
;
const
char
*
formatTotalSlices
(
)
;
size_t
getMallocHeapSize
(
)
;
void
getBufferedAllocatorStats
(
Zone
*
zone
size_t
&
mediumChunks
size_t
&
mediumTenuredChunks
size_t
&
largeNurseryAllocs
size_t
&
largeTenuredAllocs
)
;
static
void
printProfileTimes
(
const
ProfileDurations
&
times
Sprinter
&
sprinter
)
;
}
;
struct
MOZ_RAII
AutoGCSlice
{
AutoGCSlice
(
Statistics
&
stats
const
ZoneGCStats
&
zoneStats
JS
:
:
GCOptions
options
const
JS
:
:
SliceBudget
&
budget
JS
:
:
GCReason
reason
bool
budgetWasIncreased
)
:
stats
(
stats
)
{
stats
.
beginSlice
(
zoneStats
options
budget
reason
budgetWasIncreased
)
;
}
~
AutoGCSlice
(
)
{
stats
.
endSlice
(
)
;
}
Statistics
&
stats
;
}
;
struct
MOZ_RAII
AutoPhase
{
AutoPhase
(
Statistics
&
stats
PhaseKind
phaseKind
)
:
stats
(
stats
)
phaseKind
(
phaseKind
)
enabled
(
true
)
{
stats
.
beginPhase
(
phaseKind
)
;
}
AutoPhase
(
Statistics
&
stats
bool
condition
PhaseKind
phaseKind
)
:
stats
(
stats
)
phaseKind
(
phaseKind
)
enabled
(
condition
)
{
if
(
enabled
)
{
stats
.
beginPhase
(
phaseKind
)
;
}
}
~
AutoPhase
(
)
{
if
(
enabled
)
{
stats
.
endPhase
(
phaseKind
)
;
}
}
Statistics
&
stats
;
PhaseKind
phaseKind
;
bool
enabled
;
}
;
struct
MOZ_RAII
AutoSCC
{
AutoSCC
(
Statistics
&
stats
unsigned
scc
)
:
stats
(
stats
)
scc
(
scc
)
{
start
=
stats
.
beginSCC
(
)
;
}
~
AutoSCC
(
)
{
stats
.
endSCC
(
scc
start
)
;
}
Statistics
&
stats
;
unsigned
scc
;
mozilla
:
:
TimeStamp
start
;
}
;
void
ReadProfileEnv
(
const
char
*
envName
const
char
*
helpText
bool
*
enableOut
bool
*
workersOut
mozilla
:
:
TimeDuration
*
thresholdOut
)
;
}
struct
StringStats
{
uint64_t
deduplicatedStrings
=
0
;
uint64_t
deduplicatedChars
=
0
;
uint64_t
deduplicatedBytes
=
0
;
uint64_t
tenuredBytes
=
0
;
StringStats
&
operator
+
=
(
const
StringStats
&
other
)
{
deduplicatedStrings
+
=
other
.
deduplicatedStrings
;
deduplicatedChars
+
=
other
.
deduplicatedChars
;
deduplicatedBytes
+
=
other
.
deduplicatedBytes
;
tenuredBytes
+
=
other
.
tenuredBytes
;
return
*
this
;
}
void
noteTenured
(
size_t
mallocBytes
)
{
tenuredBytes
+
=
mallocBytes
;
}
void
noteDeduplicated
(
size_t
numChars
size_t
mallocBytes
)
{
deduplicatedStrings
+
+
;
deduplicatedChars
+
=
numChars
;
deduplicatedBytes
+
=
mallocBytes
;
}
}
;
}
#
endif
