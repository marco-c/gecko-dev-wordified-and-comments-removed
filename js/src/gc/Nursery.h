#
ifndef
gc_Nursery_h
#
define
gc_Nursery_h
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
gc
/
GCParallelTask
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Vector
.
h
"
#
define
FOR_EACH_NURSERY_PROFILE_TIME
(
_
)
\
_
(
Total
"
total
"
)
\
_
(
CancelIonCompilations
"
canIon
"
)
\
_
(
TraceValues
"
mkVals
"
)
\
_
(
TraceCells
"
mkClls
"
)
\
_
(
TraceSlots
"
mkSlts
"
)
\
_
(
TraceWholeCells
"
mcWCll
"
)
\
_
(
TraceGenericEntries
"
mkGnrc
"
)
\
_
(
CheckHashTables
"
ckTbls
"
)
\
_
(
MarkRuntime
"
mkRntm
"
)
\
_
(
MarkDebugger
"
mkDbgr
"
)
\
_
(
SweepCaches
"
swpCch
"
)
\
_
(
CollectToFP
"
collct
"
)
\
_
(
ObjectsTenuredCallback
"
tenCB
"
)
\
_
(
Sweep
"
sweep
"
)
\
_
(
UpdateJitActivations
"
updtIn
"
)
\
_
(
FreeMallocedBuffers
"
frSlts
"
)
\
_
(
ClearStoreBuffer
"
clrSB
"
)
\
_
(
ClearNursery
"
clear
"
)
\
_
(
Pretenure
"
pretnr
"
)
template
<
typename
T
>
class
SharedMem
;
namespace
js
{
class
AutoLockGCBgAlloc
;
class
ObjectElements
;
class
PlainObject
;
class
NativeObject
;
class
Nursery
;
struct
NurseryChunk
;
class
HeapSlot
;
class
JSONPrinter
;
class
MapObject
;
class
SetObject
;
namespace
gc
{
class
AutoMaybeStartBackgroundAllocation
;
class
AutoTraceSession
;
struct
Cell
;
class
GCSchedulingTunables
;
class
MinorCollectionTracer
;
class
RelocationOverlay
;
struct
TenureCountCache
;
enum
class
AllocKind
:
uint8_t
;
class
TenuredCell
;
}
namespace
jit
{
class
MacroAssembler
;
}
class
NurseryDecommitTask
:
public
GCParallelTaskHelper
<
NurseryDecommitTask
>
{
public
:
explicit
NurseryDecommitTask
(
JSRuntime
*
rt
)
:
GCParallelTaskHelper
(
rt
)
{
}
void
queueChunk
(
NurseryChunk
*
chunk
const
AutoLockHelperThreadState
&
lock
)
;
void
queueRange
(
size_t
newCapacity
NurseryChunk
&
chunk
const
AutoLockHelperThreadState
&
lock
)
;
void
run
(
)
;
void
decommitChunk
(
gc
:
:
Chunk
*
chunk
)
;
void
decommitRange
(
AutoLockHelperThreadState
&
lock
)
;
private
:
MainThreadOrGCTaskData
<
gc
:
:
Chunk
*
>
queue
;
MainThreadOrGCTaskData
<
NurseryChunk
*
>
partialChunk
;
MainThreadOrGCTaskData
<
size_t
>
partialCapacity
;
gc
:
:
Chunk
*
popChunk
(
const
AutoLockHelperThreadState
&
lock
)
;
}
;
class
TenuringTracer
:
public
JSTracer
{
friend
class
Nursery
;
Nursery
&
nursery_
;
size_t
tenuredSize
;
size_t
tenuredCells
;
gc
:
:
RelocationOverlay
*
objHead
;
gc
:
:
RelocationOverlay
*
*
objTail
;
gc
:
:
RelocationOverlay
*
stringHead
;
gc
:
:
RelocationOverlay
*
*
stringTail
;
TenuringTracer
(
JSRuntime
*
rt
Nursery
*
nursery
)
;
public
:
Nursery
&
nursery
(
)
{
return
nursery_
;
}
template
<
typename
T
>
void
traverse
(
T
*
*
thingp
)
;
template
<
typename
T
>
void
traverse
(
T
*
thingp
)
;
void
traceObject
(
JSObject
*
src
)
;
void
traceObjectSlots
(
NativeObject
*
nobj
uint32_t
start
uint32_t
length
)
;
void
traceSlots
(
JS
:
:
Value
*
vp
uint32_t
nslots
)
;
void
traceString
(
JSString
*
src
)
;
private
:
inline
void
insertIntoObjectFixupList
(
gc
:
:
RelocationOverlay
*
entry
)
;
inline
void
insertIntoStringFixupList
(
gc
:
:
RelocationOverlay
*
entry
)
;
template
<
typename
T
>
inline
T
*
allocTenured
(
JS
:
:
Zone
*
zone
gc
:
:
AllocKind
kind
)
;
inline
JSObject
*
movePlainObjectToTenured
(
PlainObject
*
src
)
;
JSObject
*
moveToTenuredSlow
(
JSObject
*
src
)
;
JSString
*
moveToTenured
(
JSString
*
src
)
;
size_t
moveElementsToTenured
(
NativeObject
*
dst
NativeObject
*
src
gc
:
:
AllocKind
dstKind
)
;
size_t
moveSlotsToTenured
(
NativeObject
*
dst
NativeObject
*
src
)
;
size_t
moveStringToTenured
(
JSString
*
dst
JSString
*
src
gc
:
:
AllocKind
dstKind
)
;
void
traceSlots
(
JS
:
:
Value
*
vp
JS
:
:
Value
*
end
)
;
}
;
inline
bool
CanNurseryAllocateFinalizedClass
(
const
js
:
:
Class
*
const
clasp
)
{
MOZ_ASSERT
(
clasp
-
>
hasFinalize
(
)
)
;
return
clasp
-
>
flags
&
JSCLASS_SKIP_NURSERY_FINALIZE
;
}
class
Nursery
{
public
:
static
const
size_t
Alignment
=
gc
:
:
ChunkSize
;
static
const
size_t
ChunkShift
=
gc
:
:
ChunkShift
;
static
const
size_t
SubChunkStep
=
gc
:
:
ArenaSize
;
struct
alignas
(
gc
:
:
CellAlignBytes
)
CellAlignedByte
{
char
byte
;
}
;
struct
StringLayout
{
JS
:
:
Zone
*
zone
;
CellAlignedByte
cell
;
}
;
using
BufferSet
=
HashSet
<
void
*
PointerHasher
<
void
*
>
SystemAllocPolicy
>
;
explicit
Nursery
(
JSRuntime
*
rt
)
;
~
Nursery
(
)
;
MOZ_MUST_USE
bool
init
(
uint32_t
maxNurseryBytes
AutoLockGCBgAlloc
&
lock
)
;
unsigned
chunkCountLimit
(
)
const
{
return
chunkCountLimit_
;
}
unsigned
allocatedChunkCount
(
)
const
{
return
chunks_
.
length
(
)
;
}
unsigned
maxChunkCount
(
)
const
{
MOZ_ASSERT
(
capacity
(
)
)
;
return
JS_HOWMANY
(
capacity
(
)
gc
:
:
ChunkSize
)
;
}
void
enable
(
)
;
void
disable
(
)
;
bool
isEnabled
(
)
const
{
return
capacity
(
)
!
=
0
;
}
void
enableStrings
(
)
;
void
disableStrings
(
)
;
bool
canAllocateStrings
(
)
const
{
return
canAllocateStrings_
;
}
bool
isEmpty
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isInside
(
gc
:
:
Cell
*
cellp
)
const
=
delete
;
MOZ_ALWAYS_INLINE
bool
isInside
(
const
void
*
p
)
const
{
for
(
auto
chunk
:
chunks_
)
{
if
(
uintptr_t
(
p
)
-
uintptr_t
(
chunk
)
<
gc
:
:
ChunkSize
)
{
return
true
;
}
}
return
false
;
}
template
<
typename
T
>
inline
bool
isInside
(
const
SharedMem
<
T
>
&
p
)
const
;
JSObject
*
allocateObject
(
JSContext
*
cx
size_t
size
size_t
numDynamic
const
js
:
:
Class
*
clasp
)
;
gc
:
:
Cell
*
allocateString
(
JS
:
:
Zone
*
zone
size_t
size
gc
:
:
AllocKind
kind
)
;
static
JS
:
:
Zone
*
getStringZone
(
const
JSString
*
str
)
{
#
ifdef
DEBUG
auto
cell
=
reinterpret_cast
<
const
js
:
:
gc
:
:
Cell
*
>
(
str
)
;
MOZ_ASSERT
(
js
:
:
gc
:
:
IsInsideNursery
(
cell
)
"
getStringZone
must
be
passed
a
nursery
string
"
)
;
#
endif
auto
layout
=
reinterpret_cast
<
const
uint8_t
*
>
(
str
)
-
offsetof
(
StringLayout
cell
)
;
return
reinterpret_cast
<
const
StringLayout
*
>
(
layout
)
-
>
zone
;
}
static
size_t
stringHeaderSize
(
)
{
return
offsetof
(
StringLayout
cell
)
;
}
void
*
allocateBuffer
(
JS
:
:
Zone
*
zone
size_t
nbytes
)
;
void
*
allocateBuffer
(
JSObject
*
obj
size_t
nbytes
)
;
void
*
allocateBufferSameLocation
(
JSObject
*
obj
size_t
nbytes
)
;
void
*
allocateZeroedBuffer
(
JS
:
:
Zone
*
zone
size_t
nbytes
arena_id_t
arena
=
js
:
:
MallocArena
)
;
void
*
allocateZeroedBuffer
(
JSObject
*
obj
size_t
nbytes
arena_id_t
arena
=
js
:
:
MallocArena
)
;
void
*
reallocateBuffer
(
JSObject
*
obj
void
*
oldBuffer
size_t
oldBytes
size_t
newBytes
)
;
void
freeBuffer
(
void
*
buffer
)
;
static
const
size_t
MaxNurseryBufferSize
=
1024
;
void
collect
(
JS
:
:
GCReason
reason
)
;
MOZ_ALWAYS_INLINE
MOZ_MUST_USE
static
bool
getForwardedPointer
(
js
:
:
gc
:
:
Cell
*
*
ref
)
;
void
forwardBufferPointer
(
HeapSlot
*
*
pSlotsElems
)
;
inline
void
maybeSetForwardingPointer
(
JSTracer
*
trc
void
*
oldData
void
*
newData
bool
direct
)
;
inline
void
setForwardingPointerWhileTenuring
(
void
*
oldData
void
*
newData
bool
direct
)
;
bool
registerMallocedBuffer
(
void
*
buffer
)
;
void
removeMallocedBuffer
(
void
*
buffer
)
{
MOZ_ASSERT
(
mallocedBuffers
.
has
(
buffer
)
)
;
mallocedBuffers
.
remove
(
buffer
)
;
}
MOZ_MUST_USE
bool
addedUniqueIdToCell
(
gc
:
:
Cell
*
cell
)
{
MOZ_ASSERT
(
IsInsideNursery
(
cell
)
)
;
MOZ_ASSERT
(
isEnabled
(
)
)
;
return
cellsWithUid_
.
append
(
cell
)
;
}
MOZ_MUST_USE
bool
queueDictionaryModeObjectToSweep
(
NativeObject
*
obj
)
;
size_t
sizeOfMallocedBuffers
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
total
=
0
;
for
(
BufferSet
:
:
Range
r
=
mallocedBuffers
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
total
+
=
mallocSizeOf
(
r
.
front
(
)
)
;
}
total
+
=
mallocedBuffers
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
return
total
;
}
size_t
spaceToEnd
(
unsigned
chunkCount
)
const
;
size_t
capacity
(
)
const
{
return
capacity_
;
}
size_t
committed
(
)
const
{
return
spaceToEnd
(
allocatedChunkCount
(
)
)
;
}
MOZ_ALWAYS_INLINE
size_t
usedSpace
(
)
const
{
return
capacity
(
)
-
freeSpace
(
)
;
}
MOZ_ALWAYS_INLINE
size_t
freeSpace
(
)
const
{
MOZ_ASSERT
(
isEnabled
(
)
)
;
MOZ_ASSERT
(
currentEnd_
-
position_
<
=
NurseryChunkUsableSize
)
;
MOZ_ASSERT
(
currentChunk_
<
maxChunkCount
(
)
)
;
return
(
currentEnd_
-
position_
)
+
(
maxChunkCount
(
)
-
currentChunk_
-
1
)
*
gc
:
:
ChunkSize
;
}
#
ifdef
JS_GC_ZEAL
void
enterZealMode
(
)
;
void
leaveZealMode
(
)
;
#
endif
void
renderProfileJSON
(
JSONPrinter
&
json
)
const
;
static
void
printProfileHeader
(
)
;
void
printTotalProfileTimes
(
)
;
void
*
addressOfPosition
(
)
const
{
return
(
void
*
*
)
&
position_
;
}
const
void
*
addressOfCurrentEnd
(
)
const
{
return
(
void
*
*
)
&
currentEnd_
;
}
const
void
*
addressOfCurrentStringEnd
(
)
const
{
return
(
void
*
)
&
currentStringEnd_
;
}
void
requestMinorGC
(
JS
:
:
GCReason
reason
)
const
;
bool
minorGCRequested
(
)
const
{
return
minorGCTriggerReason_
!
=
JS
:
:
GCReason
:
:
NO_REASON
;
}
JS
:
:
GCReason
minorGCTriggerReason
(
)
const
{
return
minorGCTriggerReason_
;
}
void
clearMinorGCRequest
(
)
{
minorGCTriggerReason_
=
JS
:
:
GCReason
:
:
NO_REASON
;
}
bool
shouldCollect
(
)
const
;
bool
enableProfiling
(
)
const
{
return
enableProfiling_
;
}
bool
addMapWithNurseryMemory
(
MapObject
*
obj
)
{
MOZ_ASSERT_IF
(
!
mapsWithNurseryMemory_
.
empty
(
)
mapsWithNurseryMemory_
.
back
(
)
!
=
obj
)
;
return
mapsWithNurseryMemory_
.
append
(
obj
)
;
}
bool
addSetWithNurseryMemory
(
SetObject
*
obj
)
{
MOZ_ASSERT_IF
(
!
setsWithNurseryMemory_
.
empty
(
)
setsWithNurseryMemory_
.
back
(
)
!
=
obj
)
;
return
setsWithNurseryMemory_
.
append
(
obj
)
;
}
static
const
size_t
NurseryChunkUsableSize
=
gc
:
:
ChunkSize
-
gc
:
:
ChunkTrailerSize
;
void
joinDecommitTask
(
)
{
decommitTask
.
join
(
)
;
}
private
:
JSRuntime
*
runtime_
;
Vector
<
NurseryChunk
*
0
SystemAllocPolicy
>
chunks_
;
uintptr_t
position_
;
unsigned
currentStartChunk_
;
uintptr_t
currentStartPosition_
;
uintptr_t
currentEnd_
;
uintptr_t
currentStringEnd_
;
unsigned
currentChunk_
;
size_t
capacity_
;
unsigned
chunkCountLimit_
;
mozilla
:
:
TimeDuration
timeInChunkAlloc_
;
mozilla
:
:
TimeDuration
profileThreshold_
;
bool
enableProfiling_
;
bool
canAllocateStrings_
;
int64_t
reportTenurings_
;
mutable
JS
:
:
GCReason
minorGCTriggerReason_
;
enum
class
ProfileKey
{
#
define
DEFINE_TIME_KEY
(
name
text
)
name
FOR_EACH_NURSERY_PROFILE_TIME
(
DEFINE_TIME_KEY
)
#
undef
DEFINE_TIME_KEY
KeyCount
}
;
using
ProfileTimes
=
mozilla
:
:
EnumeratedArray
<
ProfileKey
ProfileKey
:
:
KeyCount
mozilla
:
:
TimeStamp
>
;
using
ProfileDurations
=
mozilla
:
:
EnumeratedArray
<
ProfileKey
ProfileKey
:
:
KeyCount
mozilla
:
:
TimeDuration
>
;
ProfileTimes
startTimes_
;
ProfileDurations
profileDurations_
;
ProfileDurations
totalDurations_
;
struct
{
JS
:
:
GCReason
reason
=
JS
:
:
GCReason
:
:
NO_REASON
;
size_t
nurseryCapacity
=
0
;
size_t
nurseryCommitted
=
0
;
size_t
nurseryUsedBytes
=
0
;
size_t
tenuredBytes
=
0
;
size_t
tenuredCells
=
0
;
}
previousGC
;
float
calcPromotionRate
(
bool
*
validForTenuring
)
const
;
BufferSet
mallocedBuffers
;
typedef
HashMap
<
void
*
void
*
PointerHasher
<
void
*
>
SystemAllocPolicy
>
ForwardedBufferMap
;
ForwardedBufferMap
forwardedBuffers
;
using
CellsWithUniqueIdVector
=
Vector
<
gc
:
:
Cell
*
8
SystemAllocPolicy
>
;
CellsWithUniqueIdVector
cellsWithUid_
;
using
NativeObjectVector
=
Vector
<
NativeObject
*
0
SystemAllocPolicy
>
;
NativeObjectVector
dictionaryModeObjects_
;
Vector
<
MapObject
*
0
SystemAllocPolicy
>
mapsWithNurseryMemory_
;
Vector
<
SetObject
*
0
SystemAllocPolicy
>
setsWithNurseryMemory_
;
NurseryDecommitTask
decommitTask
;
#
ifdef
JS_GC_ZEAL
struct
Canary
;
Canary
*
lastCanary_
;
#
endif
NurseryChunk
&
chunk
(
unsigned
index
)
const
{
return
*
chunks_
[
index
]
;
}
void
setCurrentChunk
(
unsigned
chunkno
)
;
void
poisonAndInitCurrentChunk
(
size_t
extent
=
NurseryChunkUsableSize
)
;
void
setCurrentEnd
(
)
;
void
setStartPosition
(
)
;
MOZ_MUST_USE
bool
allocateNextChunk
(
unsigned
chunkno
AutoLockGCBgAlloc
&
lock
)
;
MOZ_ALWAYS_INLINE
uintptr_t
currentEnd
(
)
const
;
uintptr_t
position
(
)
const
{
return
position_
;
}
MOZ_ALWAYS_INLINE
bool
isSubChunkMode
(
)
const
;
JSRuntime
*
runtime
(
)
const
{
return
runtime_
;
}
gcstats
:
:
Statistics
&
stats
(
)
const
;
const
js
:
:
gc
:
:
GCSchedulingTunables
&
tunables
(
)
const
;
void
*
allocate
(
size_t
size
)
;
void
doCollection
(
JS
:
:
GCReason
reason
gc
:
:
TenureCountCache
&
tenureCounts
)
;
float
doPretenuring
(
JSRuntime
*
rt
JS
:
:
GCReason
reason
gc
:
:
TenureCountCache
&
tenureCounts
)
;
void
collectToFixedPoint
(
TenuringTracer
&
trc
gc
:
:
TenureCountCache
&
tenureCounts
)
;
inline
void
setForwardingPointer
(
void
*
oldData
void
*
newData
bool
direct
)
;
inline
void
setDirectForwardingPointer
(
void
*
oldData
void
*
newData
)
;
void
setIndirectForwardingPointer
(
void
*
oldData
void
*
newData
)
;
inline
void
setSlotsForwardingPointer
(
HeapSlot
*
oldSlots
HeapSlot
*
newSlots
uint32_t
nslots
)
;
inline
void
setElementsForwardingPointer
(
ObjectElements
*
oldHeader
ObjectElements
*
newHeader
uint32_t
capacity
)
;
void
sweep
(
JSTracer
*
trc
)
;
void
clear
(
)
;
void
sweepDictionaryModeObjects
(
)
;
void
sweepMapAndSetObjects
(
)
;
void
maybeResizeNursery
(
JS
:
:
GCReason
reason
)
;
bool
maybeResizeExact
(
JS
:
:
GCReason
reason
)
;
size_t
roundSize
(
size_t
size
)
const
;
void
growAllocableSpace
(
size_t
newCapacity
)
;
void
shrinkAllocableSpace
(
size_t
newCapacity
)
;
void
minimizeAllocableSpace
(
)
;
void
freeChunksFrom
(
unsigned
firstFreeChunk
)
;
void
maybeClearProfileDurations
(
)
;
void
startProfile
(
ProfileKey
key
)
;
void
endProfile
(
ProfileKey
key
)
;
static
void
printProfileDurations
(
const
ProfileDurations
&
times
)
;
friend
class
TenuringTracer
;
friend
class
gc
:
:
MinorCollectionTracer
;
friend
class
jit
:
:
MacroAssembler
;
friend
struct
NurseryChunk
;
}
;
}
#
endif
