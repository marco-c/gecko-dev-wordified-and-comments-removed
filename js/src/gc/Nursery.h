#
ifndef
gc_Nursery_h
#
define
gc_Nursery_h
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
gc
/
GCParallelTask
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
util
/
Text
.
h
"
#
define
FOR_EACH_NURSERY_PROFILE_TIME
(
_
)
\
_
(
Total
"
total
"
)
\
_
(
TraceValues
"
mkVals
"
)
\
_
(
TraceCells
"
mkClls
"
)
\
_
(
TraceSlots
"
mkSlts
"
)
\
_
(
TraceWholeCells
"
mcWCll
"
)
\
_
(
TraceGenericEntries
"
mkGnrc
"
)
\
_
(
CheckHashTables
"
ckTbls
"
)
\
_
(
MarkRuntime
"
mkRntm
"
)
\
_
(
MarkDebugger
"
mkDbgr
"
)
\
_
(
SweepCaches
"
swpCch
"
)
\
_
(
CollectToObjFP
"
colObj
"
)
\
_
(
CollectToStrFP
"
colStr
"
)
\
_
(
ObjectsTenuredCallback
"
tenCB
"
)
\
_
(
Sweep
"
sweep
"
)
\
_
(
UpdateJitActivations
"
updtIn
"
)
\
_
(
FreeMallocedBuffers
"
frSlts
"
)
\
_
(
ClearStoreBuffer
"
clrSB
"
)
\
_
(
ClearNursery
"
clear
"
)
\
_
(
PurgeStringToAtomCache
"
pStoA
"
)
\
_
(
Pretenure
"
pretnr
"
)
template
<
typename
T
>
class
SharedMem
;
namespace
js
{
struct
StringStats
;
class
AutoLockGCBgAlloc
;
class
ObjectElements
;
class
PlainObject
;
class
NativeObject
;
struct
NurseryChunk
;
class
HeapSlot
;
class
JSONPrinter
;
class
MapObject
;
class
SetObject
;
class
TenuringTracer
;
namespace
gc
{
class
AutoGCSession
;
class
AutoMaybeStartBackgroundAllocation
;
class
AutoTraceSession
;
struct
Cell
;
class
GCSchedulingTunables
;
class
MinorCollectionTracer
;
class
RelocationOverlay
;
class
StringRelocationOverlay
;
enum
class
AllocKind
:
uint8_t
;
}
namespace
jit
{
class
MacroAssembler
;
}
class
NurseryDecommitTask
:
public
GCParallelTask
{
public
:
explicit
NurseryDecommitTask
(
gc
:
:
GCRuntime
*
gc
)
;
bool
reserveSpaceForBytes
(
size_t
nbytes
)
;
bool
isEmpty
(
const
AutoLockHelperThreadState
&
lock
)
const
;
void
queueChunk
(
NurseryChunk
*
chunk
const
AutoLockHelperThreadState
&
lock
)
;
void
queueRange
(
size_t
newCapacity
NurseryChunk
&
chunk
const
AutoLockHelperThreadState
&
lock
)
;
private
:
using
NurseryChunkVector
=
Vector
<
NurseryChunk
*
0
SystemAllocPolicy
>
;
void
run
(
AutoLockHelperThreadState
&
lock
)
override
;
NurseryChunkVector
&
chunksToDecommit
(
)
{
return
chunksToDecommit_
.
ref
(
)
;
}
const
NurseryChunkVector
&
chunksToDecommit
(
)
const
{
return
chunksToDecommit_
.
ref
(
)
;
}
MainThreadOrGCTaskData
<
NurseryChunkVector
>
chunksToDecommit_
;
MainThreadOrGCTaskData
<
NurseryChunk
*
>
partialChunk
;
MainThreadOrGCTaskData
<
size_t
>
partialCapacity
;
}
;
inline
bool
CanNurseryAllocateFinalizedClass
(
const
JSClass
*
const
clasp
)
{
MOZ_ASSERT
(
clasp
-
>
hasFinalize
(
)
)
;
return
clasp
-
>
flags
&
JSCLASS_SKIP_NURSERY_FINALIZE
;
}
class
Nursery
{
public
:
static
const
size_t
Alignment
=
gc
:
:
ChunkSize
;
static
const
size_t
ChunkShift
=
gc
:
:
ChunkShift
;
using
BufferRelocationOverlay
=
void
*
;
using
BufferSet
=
HashSet
<
void
*
PointerHasher
<
void
*
>
SystemAllocPolicy
>
;
explicit
Nursery
(
gc
:
:
GCRuntime
*
gc
)
;
~
Nursery
(
)
;
[
[
nodiscard
]
]
bool
init
(
AutoLockGCBgAlloc
&
lock
)
;
unsigned
allocatedChunkCount
(
)
const
{
return
chunks_
.
length
(
)
;
}
unsigned
maxChunkCount
(
)
const
{
MOZ_ASSERT
(
capacity
(
)
)
;
return
HowMany
(
capacity
(
)
gc
:
:
ChunkSize
)
;
}
void
enable
(
)
;
void
disable
(
)
;
bool
isEnabled
(
)
const
{
return
capacity
(
)
!
=
0
;
}
void
enableStrings
(
)
;
void
disableStrings
(
)
;
bool
canAllocateStrings
(
)
const
{
return
canAllocateStrings_
;
}
void
enableBigInts
(
)
;
void
disableBigInts
(
)
;
bool
canAllocateBigInts
(
)
const
{
return
canAllocateBigInts_
;
}
bool
isEmpty
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isInside
(
gc
:
:
Cell
*
cellp
)
const
=
delete
;
MOZ_ALWAYS_INLINE
bool
isInside
(
const
void
*
p
)
const
{
for
(
auto
chunk
:
chunks_
)
{
if
(
uintptr_t
(
p
)
-
uintptr_t
(
chunk
)
<
gc
:
:
ChunkSize
)
{
return
true
;
}
}
return
false
;
}
template
<
typename
T
>
inline
bool
isInside
(
const
SharedMem
<
T
>
&
p
)
const
;
JSObject
*
allocateObject
(
gc
:
:
AllocSite
*
site
size_t
size
size_t
numDynamicSlots
const
JSClass
*
clasp
)
;
gc
:
:
Cell
*
allocateCell
(
gc
:
:
AllocSite
*
site
size_t
size
JS
:
:
TraceKind
kind
)
;
gc
:
:
Cell
*
allocateBigInt
(
gc
:
:
AllocSite
*
site
size_t
size
)
{
return
allocateCell
(
site
size
JS
:
:
TraceKind
:
:
BigInt
)
;
}
gc
:
:
Cell
*
allocateString
(
gc
:
:
AllocSite
*
site
size_t
size
)
;
static
size_t
nurseryCellHeaderSize
(
)
{
return
sizeof
(
gc
:
:
NurseryCellHeader
)
;
}
void
*
allocateBuffer
(
JS
:
:
Zone
*
zone
size_t
nbytes
)
;
void
*
allocateBuffer
(
JSObject
*
obj
size_t
nbytes
)
;
void
*
allocateBufferSameLocation
(
JSObject
*
obj
size_t
nbytes
)
;
void
*
allocateZeroedBuffer
(
JS
:
:
Zone
*
zone
size_t
nbytes
arena_id_t
arena
=
js
:
:
MallocArena
)
;
void
*
allocateZeroedBuffer
(
JSObject
*
obj
size_t
nbytes
arena_id_t
arena
=
js
:
:
MallocArena
)
;
void
*
reallocateBuffer
(
JS
:
:
Zone
*
zone
gc
:
:
Cell
*
cell
void
*
oldBuffer
size_t
oldBytes
size_t
newBytes
)
;
void
*
allocateBuffer
(
JS
:
:
BigInt
*
bi
size_t
nbytes
)
;
void
freeBuffer
(
void
*
buffer
size_t
nbytes
)
;
static
const
size_t
MaxNurseryBufferSize
=
1024
;
void
collect
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
static
bool
getForwardedPointer
(
js
:
:
gc
:
:
Cell
*
*
ref
)
;
void
forwardBufferPointer
(
uintptr_t
*
pSlotsElems
)
;
inline
void
maybeSetForwardingPointer
(
JSTracer
*
trc
void
*
oldData
void
*
newData
bool
direct
)
;
inline
void
setForwardingPointerWhileTenuring
(
void
*
oldData
void
*
newData
bool
direct
)
;
[
[
nodiscard
]
]
bool
registerMallocedBuffer
(
void
*
buffer
size_t
nbytes
)
;
void
removeMallocedBuffer
(
void
*
buffer
size_t
nbytes
)
{
MOZ_ASSERT
(
mallocedBuffers
.
has
(
buffer
)
)
;
MOZ_ASSERT
(
nbytes
>
0
)
;
MOZ_ASSERT
(
mallocedBufferBytes
>
=
nbytes
)
;
mallocedBuffers
.
remove
(
buffer
)
;
mallocedBufferBytes
-
=
nbytes
;
}
void
removeMallocedBufferDuringMinorGC
(
void
*
buffer
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsMinorCollecting
(
)
)
;
MOZ_ASSERT
(
mallocedBuffers
.
has
(
buffer
)
)
;
mallocedBuffers
.
remove
(
buffer
)
;
}
[
[
nodiscard
]
]
bool
addedUniqueIdToCell
(
gc
:
:
Cell
*
cell
)
{
MOZ_ASSERT
(
IsInsideNursery
(
cell
)
)
;
MOZ_ASSERT
(
isEnabled
(
)
)
;
return
cellsWithUid_
.
append
(
cell
)
;
}
size_t
sizeOfMallocedBuffers
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
total
=
0
;
for
(
BufferSet
:
:
Range
r
=
mallocedBuffers
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
total
+
=
mallocSizeOf
(
r
.
front
(
)
)
;
}
total
+
=
mallocedBuffers
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
return
total
;
}
size_t
spaceToEnd
(
unsigned
chunkCount
)
const
;
size_t
capacity
(
)
const
{
return
capacity_
;
}
size_t
committed
(
)
const
{
return
spaceToEnd
(
allocatedChunkCount
(
)
)
;
}
MOZ_ALWAYS_INLINE
size_t
usedSpace
(
)
const
{
return
capacity
(
)
-
freeSpace
(
)
;
}
MOZ_ALWAYS_INLINE
size_t
freeSpace
(
)
const
{
MOZ_ASSERT
(
isEnabled
(
)
)
;
MOZ_ASSERT
(
currentEnd_
-
position_
<
=
NurseryChunkUsableSize
)
;
MOZ_ASSERT
(
currentChunk_
<
maxChunkCount
(
)
)
;
return
(
currentEnd_
-
position_
)
+
(
maxChunkCount
(
)
-
currentChunk_
-
1
)
*
gc
:
:
ChunkSize
;
}
#
ifdef
JS_GC_ZEAL
void
enterZealMode
(
)
;
void
leaveZealMode
(
)
;
#
endif
void
renderProfileJSON
(
JSONPrinter
&
json
)
const
;
void
printProfileHeader
(
)
;
void
printTotalProfileTimes
(
)
;
void
*
addressOfPosition
(
)
const
{
return
(
void
*
*
)
&
position_
;
}
const
void
*
addressOfCurrentEnd
(
)
const
{
return
(
void
*
*
)
&
currentEnd_
;
}
const
void
*
addressOfCurrentStringEnd
(
)
const
{
return
(
void
*
)
&
currentStringEnd_
;
}
const
void
*
addressOfCurrentBigIntEnd
(
)
const
{
return
(
void
*
)
&
currentBigIntEnd_
;
}
void
*
addressOfNurseryAllocatedSites
(
)
{
return
pretenuringNursery
.
addressOfAllocatedSites
(
)
;
}
void
requestMinorGC
(
JS
:
:
GCReason
reason
)
const
;
bool
minorGCRequested
(
)
const
{
return
minorGCTriggerReason_
!
=
JS
:
:
GCReason
:
:
NO_REASON
;
}
JS
:
:
GCReason
minorGCTriggerReason
(
)
const
{
return
minorGCTriggerReason_
;
}
void
clearMinorGCRequest
(
)
{
minorGCTriggerReason_
=
JS
:
:
GCReason
:
:
NO_REASON
;
}
bool
shouldCollect
(
)
const
;
bool
isNearlyFull
(
)
const
;
bool
isUnderused
(
)
const
;
bool
enableProfiling
(
)
const
{
return
enableProfiling_
;
}
bool
addMapWithNurseryMemory
(
MapObject
*
obj
)
{
MOZ_ASSERT_IF
(
!
mapsWithNurseryMemory_
.
empty
(
)
mapsWithNurseryMemory_
.
back
(
)
!
=
obj
)
;
return
mapsWithNurseryMemory_
.
append
(
obj
)
;
}
bool
addSetWithNurseryMemory
(
SetObject
*
obj
)
{
MOZ_ASSERT_IF
(
!
setsWithNurseryMemory_
.
empty
(
)
setsWithNurseryMemory_
.
back
(
)
!
=
obj
)
;
return
setsWithNurseryMemory_
.
append
(
obj
)
;
}
static
const
size_t
NurseryChunkUsableSize
=
gc
:
:
ChunkSize
-
sizeof
(
gc
:
:
ChunkBase
)
;
void
joinDecommitTask
(
)
{
decommitTask
.
join
(
)
;
}
mozilla
:
:
TimeStamp
collectionStartTime
(
)
{
return
startTimes_
[
ProfileKey
:
:
Total
]
;
}
bool
canCreateAllocSite
(
)
{
return
pretenuringNursery
.
canCreateAllocSite
(
)
;
}
void
noteAllocSiteCreated
(
)
{
pretenuringNursery
.
noteAllocSiteCreated
(
)
;
}
bool
reportPretenuring
(
)
const
{
return
reportPretenuring_
;
}
void
maybeStopPretenuring
(
gc
:
:
GCRuntime
*
gc
)
{
pretenuringNursery
.
maybeStopPretenuring
(
gc
)
;
}
static
size_t
roundSize
(
size_t
size
)
;
private
:
gc
:
:
GCRuntime
*
const
gc
;
Vector
<
NurseryChunk
*
0
SystemAllocPolicy
>
chunks_
;
uintptr_t
position_
;
unsigned
currentStartChunk_
;
uintptr_t
currentStartPosition_
;
uintptr_t
currentEnd_
;
uintptr_t
currentStringEnd_
;
uintptr_t
currentBigIntEnd_
;
unsigned
currentChunk_
;
size_t
capacity_
;
gc
:
:
PretenuringNursery
pretenuringNursery
;
mozilla
:
:
TimeDuration
timeInChunkAlloc_
;
bool
enableProfiling_
;
bool
profileWorkers_
;
mozilla
:
:
TimeDuration
profileThreshold_
;
bool
canAllocateStrings_
;
bool
canAllocateBigInts_
;
bool
reportDeduplications_
;
bool
reportPretenuring_
;
size_t
reportPretenuringThreshold_
;
mutable
JS
:
:
GCReason
minorGCTriggerReason_
;
enum
class
ProfileKey
{
#
define
DEFINE_TIME_KEY
(
name
text
)
name
FOR_EACH_NURSERY_PROFILE_TIME
(
DEFINE_TIME_KEY
)
#
undef
DEFINE_TIME_KEY
KeyCount
}
;
using
ProfileTimes
=
mozilla
:
:
EnumeratedArray
<
ProfileKey
ProfileKey
:
:
KeyCount
mozilla
:
:
TimeStamp
>
;
using
ProfileDurations
=
mozilla
:
:
EnumeratedArray
<
ProfileKey
ProfileKey
:
:
KeyCount
mozilla
:
:
TimeDuration
>
;
ProfileTimes
startTimes_
;
ProfileDurations
profileDurations_
;
ProfileDurations
totalDurations_
;
struct
PreviousGC
{
JS
:
:
GCReason
reason
=
JS
:
:
GCReason
:
:
NO_REASON
;
size_t
nurseryCapacity
=
0
;
size_t
nurseryCommitted
=
0
;
size_t
nurseryUsedBytes
=
0
;
size_t
nurseryUsedChunkCount
=
0
;
size_t
tenuredBytes
=
0
;
size_t
tenuredCells
=
0
;
mozilla
:
:
TimeStamp
endTime
;
}
;
PreviousGC
previousGC
;
bool
hasRecentGrowthData
;
double
smoothedTargetSize
;
double
calcPromotionRate
(
bool
*
validForTenuring
)
const
;
BufferSet
mallocedBuffers
;
size_t
mallocedBufferBytes
=
0
;
typedef
HashMap
<
void
*
void
*
PointerHasher
<
void
*
>
SystemAllocPolicy
>
ForwardedBufferMap
;
ForwardedBufferMap
forwardedBuffers
;
using
CellsWithUniqueIdVector
=
Vector
<
gc
:
:
Cell
*
8
SystemAllocPolicy
>
;
CellsWithUniqueIdVector
cellsWithUid_
;
template
<
typename
Key
>
struct
DeduplicationStringHasher
{
using
Lookup
=
Key
;
static
inline
HashNumber
hash
(
const
Lookup
&
lookup
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
HashNumber
strHash
;
if
(
lookup
-
>
asLinear
(
)
.
hasLatin1Chars
(
)
)
{
strHash
=
mozilla
:
:
HashString
(
lookup
-
>
asLinear
(
)
.
latin1Chars
(
nogc
)
lookup
-
>
length
(
)
)
;
}
else
{
MOZ_ASSERT
(
lookup
-
>
asLinear
(
)
.
hasTwoByteChars
(
)
)
;
strHash
=
mozilla
:
:
HashString
(
lookup
-
>
asLinear
(
)
.
twoByteChars
(
nogc
)
lookup
-
>
length
(
)
)
;
}
return
mozilla
:
:
HashGeneric
(
strHash
lookup
-
>
zone
(
)
lookup
-
>
flags
(
)
)
;
}
static
MOZ_ALWAYS_INLINE
bool
match
(
const
Key
&
key
const
Lookup
&
lookup
)
{
if
(
!
key
-
>
sameLengthAndFlags
(
*
lookup
)
|
|
key
-
>
asTenured
(
)
.
zone
(
)
!
=
lookup
-
>
zone
(
)
|
|
key
-
>
asTenured
(
)
.
getAllocKind
(
)
!
=
lookup
-
>
getAllocKind
(
)
)
{
return
false
;
}
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
key
-
>
asLinear
(
)
.
hasLatin1Chars
(
)
)
{
MOZ_ASSERT
(
lookup
-
>
asLinear
(
)
.
hasLatin1Chars
(
)
)
;
return
EqualChars
(
key
-
>
asLinear
(
)
.
latin1Chars
(
nogc
)
lookup
-
>
asLinear
(
)
.
latin1Chars
(
nogc
)
lookup
-
>
length
(
)
)
;
}
else
{
MOZ_ASSERT
(
key
-
>
asLinear
(
)
.
hasTwoByteChars
(
)
)
;
MOZ_ASSERT
(
lookup
-
>
asLinear
(
)
.
hasTwoByteChars
(
)
)
;
return
EqualChars
(
key
-
>
asLinear
(
)
.
twoByteChars
(
nogc
)
lookup
-
>
asLinear
(
)
.
twoByteChars
(
nogc
)
lookup
-
>
length
(
)
)
;
}
}
}
;
using
StringDeDupSet
=
HashSet
<
JSString
*
DeduplicationStringHasher
<
JSString
*
>
SystemAllocPolicy
>
;
mozilla
:
:
Maybe
<
StringDeDupSet
>
stringDeDupSet
;
Vector
<
MapObject
*
0
SystemAllocPolicy
>
mapsWithNurseryMemory_
;
Vector
<
SetObject
*
0
SystemAllocPolicy
>
setsWithNurseryMemory_
;
NurseryDecommitTask
decommitTask
;
#
ifdef
JS_GC_ZEAL
struct
Canary
;
Canary
*
lastCanary_
;
#
endif
NurseryChunk
&
chunk
(
unsigned
index
)
const
{
return
*
chunks_
[
index
]
;
}
void
setCurrentChunk
(
unsigned
chunkno
)
;
bool
initFirstChunk
(
AutoLockGCBgAlloc
&
lock
)
;
void
poisonAndInitCurrentChunk
(
size_t
extent
=
gc
:
:
ChunkSize
)
;
void
setCurrentEnd
(
)
;
void
setStartPosition
(
)
;
[
[
nodiscard
]
]
bool
allocateNextChunk
(
unsigned
chunkno
AutoLockGCBgAlloc
&
lock
)
;
MOZ_ALWAYS_INLINE
uintptr_t
currentEnd
(
)
const
;
uintptr_t
position
(
)
const
{
return
position_
;
}
MOZ_ALWAYS_INLINE
bool
isSubChunkMode
(
)
const
;
JSRuntime
*
runtime
(
)
const
;
gcstats
:
:
Statistics
&
stats
(
)
const
;
const
js
:
:
gc
:
:
GCSchedulingTunables
&
tunables
(
)
const
;
void
*
allocate
(
size_t
size
)
;
void
*
moveToNextChunkAndAllocate
(
size_t
size
)
;
#
ifdef
JS_GC_ZEAL
void
writeCanary
(
uintptr_t
address
)
;
#
endif
struct
CollectionResult
{
size_t
tenuredBytes
;
size_t
tenuredCells
;
}
;
CollectionResult
doCollection
(
JS
:
:
GCReason
reason
)
;
void
traceRoots
(
gc
:
:
AutoGCSession
&
session
TenuringTracer
&
mover
)
;
size_t
doPretenuring
(
JSRuntime
*
rt
JS
:
:
GCReason
reason
bool
validPromotionRate
double
promotionRate
)
;
inline
void
setForwardingPointer
(
void
*
oldData
void
*
newData
bool
direct
)
;
inline
void
setDirectForwardingPointer
(
void
*
oldData
void
*
newData
)
;
void
setIndirectForwardingPointer
(
void
*
oldData
void
*
newData
)
;
inline
void
setSlotsForwardingPointer
(
HeapSlot
*
oldSlots
HeapSlot
*
newSlots
uint32_t
nslots
)
;
inline
void
setElementsForwardingPointer
(
ObjectElements
*
oldHeader
ObjectElements
*
newHeader
uint32_t
capacity
)
;
#
ifdef
DEBUG
bool
checkForwardingPointerLocation
(
void
*
ptr
bool
expectedInside
)
;
#
endif
void
sweep
(
)
;
void
clear
(
)
;
void
sweepMapAndSetObjects
(
)
;
void
maybeResizeNursery
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
;
size_t
targetSize
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
;
void
clearRecentGrowthData
(
)
;
void
growAllocableSpace
(
size_t
newCapacity
)
;
void
shrinkAllocableSpace
(
size_t
newCapacity
)
;
void
minimizeAllocableSpace
(
)
;
void
freeChunksFrom
(
unsigned
firstFreeChunk
)
;
void
sendTelemetry
(
JS
:
:
GCReason
reason
mozilla
:
:
TimeDuration
totalTime
bool
wasEmpty
double
promotionRate
size_t
sitesPretenured
)
;
void
printCollectionProfile
(
JS
:
:
GCReason
reason
double
promotionRate
)
;
void
printDeduplicationData
(
js
:
:
StringStats
&
prev
js
:
:
StringStats
&
curr
)
;
void
maybeClearProfileDurations
(
)
;
void
startProfile
(
ProfileKey
key
)
;
void
endProfile
(
ProfileKey
key
)
;
static
void
printProfileDurations
(
FILE
*
file
const
ProfileDurations
&
times
)
;
mozilla
:
:
TimeStamp
collectionStartTime
(
)
const
;
mozilla
:
:
TimeStamp
lastCollectionEndTime
(
)
const
;
friend
class
TenuringTracer
;
friend
class
gc
:
:
MinorCollectionTracer
;
friend
class
jit
:
:
MacroAssembler
;
friend
struct
NurseryChunk
;
}
;
}
#
endif
