#
ifndef
gc_Nursery_h
#
define
gc_Nursery_h
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
<
tuple
>
#
include
"
ds
/
LifoAlloc
.
h
"
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
gc
/
GCProbes
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
gc
/
MallocedBlockCache
.
h
"
#
include
"
gc
/
Pretenuring
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
#
define
FOR_EACH_NURSERY_PROFILE_TIME
(
_
)
\
_
(
Total
"
total
"
)
\
_
(
TraceValues
"
mkVals
"
)
\
_
(
TraceCells
"
mkClls
"
)
\
_
(
TraceSlots
"
mkSlts
"
)
\
_
(
TraceWasmAnyRefs
"
mkWars
"
)
\
_
(
TraceWholeCells
"
mcWCll
"
)
\
_
(
TraceGenericEntries
"
mkGnrc
"
)
\
_
(
CheckHashTables
"
ckTbls
"
)
\
_
(
MarkRuntime
"
mkRntm
"
)
\
_
(
MarkDebugger
"
mkDbgr
"
)
\
_
(
SweepCaches
"
swpCch
"
)
\
_
(
CollectToObjFP
"
colObj
"
)
\
_
(
CollectToStrFP
"
colStr
"
)
\
_
(
ObjectsTenuredCallback
"
tenCB
"
)
\
_
(
Sweep
"
sweep
"
)
\
_
(
UpdateJitActivations
"
updtIn
"
)
\
_
(
FreeMallocedBuffers
"
frSlts
"
)
\
_
(
FreeTrailerBlocks
"
frTrBs
"
)
\
_
(
ClearNursery
"
clear
"
)
\
_
(
PurgeStringToAtomCache
"
pStoA
"
)
\
_
(
Pretenure
"
pretnr
"
)
template
<
typename
T
>
class
SharedMem
;
namespace
mozilla
{
class
StringBuffer
;
}
;
namespace
js
{
struct
StringStats
;
class
AutoLockGCBgAlloc
;
class
ObjectElements
;
struct
NurseryChunk
;
class
HeapSlot
;
class
JSONPrinter
;
class
MapObject
;
class
SetObject
;
class
JS_PUBLIC_API
Sprinter
;
namespace
gc
{
class
AutoGCSession
;
struct
Cell
;
class
GCSchedulingTunables
;
class
StoreBuffer
;
class
TenuringTracer
;
struct
CellSweepSet
{
UniquePtr
<
LifoAlloc
>
storage_
;
ArenaCellSet
*
head_
=
nullptr
;
void
sweep
(
)
;
}
;
}
class
Nursery
{
public
:
explicit
Nursery
(
gc
:
:
GCRuntime
*
gc
)
;
~
Nursery
(
)
;
[
[
nodiscard
]
]
bool
init
(
AutoLockGCBgAlloc
&
lock
)
;
void
enable
(
)
;
void
disable
(
)
;
bool
isEnabled
(
)
const
{
return
capacity
(
)
!
=
0
;
}
void
enableStrings
(
)
;
void
disableStrings
(
)
;
bool
canAllocateStrings
(
)
const
{
return
canAllocateStrings_
;
}
void
enableBigInts
(
)
;
void
disableBigInts
(
)
;
bool
canAllocateBigInts
(
)
const
{
return
canAllocateBigInts_
;
}
void
setSemispaceEnabled
(
bool
enabled
)
;
bool
semispaceEnabled
(
)
const
{
return
semispaceEnabled_
;
}
bool
isEmpty
(
)
const
;
bool
isInside
(
gc
:
:
Cell
*
cellp
)
const
=
delete
;
inline
bool
isInside
(
const
void
*
p
)
const
;
template
<
typename
T
>
inline
bool
isInside
(
const
SharedMem
<
T
>
&
p
)
const
;
void
*
allocateCell
(
gc
:
:
AllocSite
*
site
size_t
size
JS
:
:
TraceKind
kind
)
;
inline
void
*
tryAllocateCell
(
gc
:
:
AllocSite
*
site
size_t
size
JS
:
:
TraceKind
kind
)
;
[
[
nodiscard
]
]
JS
:
:
GCReason
handleAllocationFailure
(
)
;
static
size_t
nurseryCellHeaderSize
(
)
{
return
sizeof
(
gc
:
:
NurseryCellHeader
)
;
}
std
:
:
tuple
<
void
*
bool
>
allocateBuffer
(
JS
:
:
Zone
*
zone
size_t
nbytes
arena_id_t
arenaId
)
;
void
*
tryAllocateNurseryBuffer
(
JS
:
:
Zone
*
zone
size_t
nbytes
arena_id_t
arenaId
)
;
void
*
allocateBuffer
(
JS
:
:
Zone
*
zone
gc
:
:
Cell
*
owner
size_t
nbytes
arena_id_t
arenaId
)
;
void
*
allocateBufferSameLocation
(
gc
:
:
Cell
*
owner
size_t
nbytes
arena_id_t
arenaId
)
;
std
:
:
tuple
<
void
*
bool
>
allocateZeroedBuffer
(
JS
:
:
Zone
*
zone
size_t
nbytes
arena_id_t
arena
)
;
void
*
allocateZeroedBuffer
(
gc
:
:
Cell
*
owner
size_t
nbytes
arena_id_t
arena
)
;
void
*
reallocateBuffer
(
JS
:
:
Zone
*
zone
gc
:
:
Cell
*
cell
void
*
oldBuffer
size_t
oldBytes
size_t
newBytes
arena_id_t
arena
)
;
void
freeBuffer
(
void
*
buffer
size_t
nbytes
)
;
static
const
size_t
MaxNurseryBufferSize
=
1024
;
void
collect
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
static
bool
getForwardedPointer
(
js
:
:
gc
:
:
Cell
*
*
ref
)
;
void
forwardBufferPointer
(
uintptr_t
*
pSlotsElems
)
;
inline
void
maybeSetForwardingPointer
(
JSTracer
*
trc
void
*
oldData
void
*
newData
bool
direct
)
;
inline
void
setForwardingPointerWhileTenuring
(
void
*
oldData
void
*
newData
bool
direct
)
;
enum
WasBufferMoved
:
bool
{
BufferNotMoved
=
false
BufferMoved
=
true
}
;
WasBufferMoved
maybeMoveRawBufferOnPromotion
(
void
*
*
bufferp
gc
:
:
Cell
*
owner
size_t
nbytes
MemoryUse
use
arena_id_t
arena
)
;
template
<
typename
T
>
WasBufferMoved
maybeMoveBufferOnPromotion
(
T
*
*
bufferp
gc
:
:
Cell
*
owner
size_t
nbytes
MemoryUse
use
arena_id_t
arena
)
{
return
maybeMoveRawBufferOnPromotion
(
reinterpret_cast
<
void
*
*
>
(
bufferp
)
owner
nbytes
use
arena
)
;
}
template
<
typename
T
>
WasBufferMoved
maybeMoveBufferOnPromotion
(
T
*
*
bufferp
gc
:
:
Cell
*
owner
size_t
nbytes
MemoryUse
use
)
{
return
maybeMoveBufferOnPromotion
(
bufferp
owner
nbytes
use
MallocArena
)
;
}
[
[
nodiscard
]
]
bool
registerMallocedBuffer
(
void
*
buffer
size_t
nbytes
)
;
void
removeMallocedBuffer
(
void
*
buffer
size_t
nbytes
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsMinorCollecting
(
)
)
;
MOZ_ASSERT
(
toSpace
.
mallocedBuffers
.
has
(
buffer
)
)
;
MOZ_ASSERT
(
nbytes
>
0
)
;
MOZ_ASSERT
(
toSpace
.
mallocedBufferBytes
>
=
nbytes
)
;
toSpace
.
mallocedBuffers
.
remove
(
buffer
)
;
toSpace
.
mallocedBufferBytes
-
=
nbytes
;
}
void
removeMallocedBufferDuringMinorGC
(
void
*
buffer
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsMinorCollecting
(
)
)
;
MOZ_ASSERT
(
fromSpace
.
mallocedBuffers
.
has
(
buffer
)
)
;
fromSpace
.
mallocedBuffers
.
remove
(
buffer
)
;
}
[
[
nodiscard
]
]
bool
addedUniqueIdToCell
(
gc
:
:
Cell
*
cell
)
{
MOZ_ASSERT
(
IsInsideNursery
(
cell
)
)
;
MOZ_ASSERT
(
isEnabled
(
)
)
;
return
cellsWithUid_
.
append
(
cell
)
;
}
[
[
nodiscard
]
]
inline
bool
addStringBuffer
(
JSLinearString
*
s
)
;
[
[
nodiscard
]
]
inline
bool
addExtensibleStringBuffer
(
JSLinearString
*
s
mozilla
:
:
StringBuffer
*
buffer
)
;
inline
void
removeExtensibleStringBuffer
(
JSLinearString
*
s
)
;
size_t
sizeOfMallocedBuffers
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
[
[
nodiscard
]
]
inline
bool
registerTrailer
(
PointerAndUint7
blockAndListID
size_t
nBytes
)
;
inline
void
unregisterTrailer
(
void
*
block
)
;
size_t
sizeOfTrailerBlockSets
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
totalCapacity
(
)
const
;
size_t
totalCommitted
(
)
const
;
#
ifdef
JS_GC_ZEAL
void
enterZealMode
(
)
;
void
leaveZealMode
(
)
;
#
endif
void
renderProfileJSON
(
JSONPrinter
&
json
)
const
;
void
printProfileHeader
(
)
;
void
printTotalProfileTimes
(
)
;
void
*
addressOfPosition
(
)
const
{
return
(
void
*
*
)
&
toSpace
.
position_
;
}
static
constexpr
int32_t
offsetOfCurrentEndFromPosition
(
)
{
return
offsetof
(
Nursery
toSpace
.
currentEnd_
)
-
offsetof
(
Nursery
toSpace
.
position_
)
;
}
void
*
addressOfNurseryAllocatedSites
(
)
{
return
pretenuringNursery
.
addressOfAllocatedSites
(
)
;
}
void
requestMinorGC
(
JS
:
:
GCReason
reason
)
;
bool
minorGCRequested
(
)
const
{
return
minorGCTriggerReason_
!
=
JS
:
:
GCReason
:
:
NO_REASON
;
}
JS
:
:
GCReason
minorGCTriggerReason
(
)
const
{
return
minorGCTriggerReason_
;
}
bool
wantEagerCollection
(
)
const
;
bool
enableProfiling
(
)
const
{
return
enableProfiling_
;
}
bool
addMapWithNurseryMemory
(
MapObject
*
obj
)
{
MOZ_ASSERT_IF
(
!
mapsWithNurseryMemory_
.
empty
(
)
mapsWithNurseryMemory_
.
back
(
)
!
=
obj
)
;
return
mapsWithNurseryMemory_
.
append
(
obj
)
;
}
bool
addSetWithNurseryMemory
(
SetObject
*
obj
)
{
MOZ_ASSERT_IF
(
!
setsWithNurseryMemory_
.
empty
(
)
setsWithNurseryMemory_
.
back
(
)
!
=
obj
)
;
return
setsWithNurseryMemory_
.
append
(
obj
)
;
}
void
joinDecommitTask
(
)
;
mozilla
:
:
TimeStamp
collectionStartTime
(
)
{
return
startTimes_
[
ProfileKey
:
:
Total
]
;
}
bool
canCreateAllocSite
(
)
{
return
pretenuringNursery
.
canCreateAllocSite
(
)
;
}
void
noteAllocSiteCreated
(
)
{
pretenuringNursery
.
noteAllocSiteCreated
(
)
;
}
bool
reportPretenuring
(
)
const
{
return
pretenuringReportFilter_
.
enabled
;
}
void
maybeStopPretenuring
(
gc
:
:
GCRuntime
*
gc
)
{
pretenuringNursery
.
maybeStopPretenuring
(
gc
)
;
}
void
setAllocFlagsForZone
(
JS
:
:
Zone
*
zone
)
;
bool
shouldTenureEverything
(
JS
:
:
GCReason
reason
)
;
inline
bool
inCollectedRegion
(
gc
:
:
Cell
*
cell
)
const
;
inline
bool
inCollectedRegion
(
void
*
ptr
)
const
;
void
trackMallocedBufferOnPromotion
(
void
*
buffer
gc
:
:
Cell
*
owner
size_t
nbytes
MemoryUse
use
)
;
void
trackTrailerOnPromotion
(
void
*
buffer
gc
:
:
Cell
*
owner
size_t
nbytes
size_t
overhead
MemoryUse
use
)
;
static
size_t
roundSize
(
size_t
size
)
;
gc
:
:
MallocedBlockCache
&
mallocedBlockCache
(
)
{
return
mallocedBlockCache_
;
}
size_t
sizeOfMallocedBlockCache
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocedBlockCache_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
mozilla
:
:
TimeStamp
lastCollectionEndTime
(
)
const
;
private
:
struct
Space
;
enum
class
ProfileKey
{
#
define
DEFINE_TIME_KEY
(
name
text
)
name
FOR_EACH_NURSERY_PROFILE_TIME
(
DEFINE_TIME_KEY
)
#
undef
DEFINE_TIME_KEY
KeyCount
}
;
using
ProfileTimes
=
mozilla
:
:
EnumeratedArray
<
ProfileKey
mozilla
:
:
TimeStamp
size_t
(
ProfileKey
:
:
KeyCount
)
>
;
using
ProfileDurations
=
mozilla
:
:
EnumeratedArray
<
ProfileKey
mozilla
:
:
TimeDuration
size_t
(
ProfileKey
:
:
KeyCount
)
>
;
size_t
capacity
(
)
const
{
return
capacity_
;
}
uint32_t
maxChunkCount
(
)
const
{
MOZ_ASSERT
(
toSpace
.
maxChunkCount_
)
;
return
toSpace
.
maxChunkCount_
;
}
unsigned
allocatedChunkCount
(
)
const
{
return
toSpace
.
chunks_
.
length
(
)
;
}
uint32_t
currentChunk
(
)
const
{
return
toSpace
.
currentChunk_
;
}
uint32_t
startChunk
(
)
const
{
return
toSpace
.
startChunk_
;
}
uintptr_t
startPosition
(
)
const
{
return
toSpace
.
startPosition_
;
}
MOZ_ALWAYS_INLINE
size_t
usedSpace
(
)
const
{
return
capacity
(
)
-
freeSpace
(
)
;
}
MOZ_ALWAYS_INLINE
size_t
freeSpace
(
)
const
{
MOZ_ASSERT
(
isEnabled
(
)
)
;
MOZ_ASSERT
(
currentChunk
(
)
<
maxChunkCount
(
)
)
;
return
(
currentEnd
(
)
-
position
(
)
)
+
(
maxChunkCount
(
)
-
currentChunk
(
)
-
1
)
*
gc
:
:
ChunkSize
;
}
inline
void
addMallocedBufferBytes
(
size_t
nbytes
)
;
double
calcPromotionRate
(
bool
*
validForTenuring
)
const
;
void
freeTrailerBlocks
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
;
NurseryChunk
&
chunk
(
unsigned
index
)
const
{
return
*
toSpace
.
chunks_
[
index
]
;
}
void
moveToStartOfChunk
(
unsigned
chunkno
)
;
bool
initFirstChunk
(
AutoLockGCBgAlloc
&
lock
)
;
void
setCapacity
(
size_t
newCapacity
)
;
void
poisonAndInitCurrentChunk
(
)
;
void
setCurrentEnd
(
)
;
void
setStartToCurrentPosition
(
)
;
[
[
nodiscard
]
]
bool
allocateNextChunk
(
AutoLockGCBgAlloc
&
lock
)
;
uintptr_t
position
(
)
const
{
return
toSpace
.
position_
;
}
uintptr_t
currentEnd
(
)
const
{
return
toSpace
.
currentEnd_
;
}
MOZ_ALWAYS_INLINE
bool
isSubChunkMode
(
)
const
;
JSRuntime
*
runtime
(
)
const
;
gcstats
:
:
Statistics
&
stats
(
)
const
;
const
js
:
:
gc
:
:
GCSchedulingTunables
&
tunables
(
)
const
;
void
getAllocFlagsForZone
(
JS
:
:
Zone
*
zone
bool
*
allocObjectsOut
bool
*
allocStringsOut
bool
*
allocBigIntsOut
)
;
void
updateAllZoneAllocFlags
(
)
;
void
updateAllocFlagsForZone
(
JS
:
:
Zone
*
zone
)
;
void
discardCodeAndSetJitFlagsForZone
(
JS
:
:
Zone
*
zone
)
;
void
*
allocate
(
size_t
size
)
;
inline
void
*
tryAllocate
(
size_t
size
)
;
[
[
nodiscard
]
]
bool
moveToNextChunk
(
)
;
bool
freeSpaceIsBelowEagerThreshold
(
)
const
;
bool
isUnderused
(
)
const
;
struct
CollectionResult
{
size_t
tenuredBytes
;
size_t
tenuredCells
;
}
;
CollectionResult
doCollection
(
gc
:
:
AutoGCSession
&
session
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
;
void
swapSpaces
(
)
;
void
traceRoots
(
gc
:
:
AutoGCSession
&
session
gc
:
:
TenuringTracer
&
mover
)
;
size_t
doPretenuring
(
JSRuntime
*
rt
JS
:
:
GCReason
reason
bool
validPromotionRate
double
promotionRate
)
;
inline
void
setForwardingPointer
(
void
*
oldData
void
*
newData
bool
direct
)
;
inline
void
setDirectForwardingPointer
(
void
*
oldData
void
*
newData
)
;
void
setIndirectForwardingPointer
(
void
*
oldData
void
*
newData
)
;
inline
void
setSlotsForwardingPointer
(
HeapSlot
*
oldSlots
HeapSlot
*
newSlots
uint32_t
nslots
)
;
inline
void
setElementsForwardingPointer
(
ObjectElements
*
oldHeader
ObjectElements
*
newHeader
uint32_t
capacity
)
;
#
ifdef
DEBUG
bool
checkForwardingPointerInsideNursery
(
void
*
ptr
)
;
#
endif
void
sweep
(
)
;
void
setNewExtentAndPosition
(
)
;
void
clear
(
)
;
void
clearMapAndSetNurseryRanges
(
)
;
void
sweepMapAndSetObjects
(
)
;
void
sweepStringsWithBuffer
(
)
;
void
*
allocateBuffer
(
JS
:
:
Zone
*
zone
size_t
nbytes
)
;
size_t
maxSpaceSize
(
)
const
;
size_t
minSpaceSize
(
)
const
;
void
maybeResizeNursery
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
;
size_t
targetSize
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
;
void
clearRecentGrowthData
(
)
;
void
growAllocableSpace
(
size_t
newCapacity
)
;
void
shrinkAllocableSpace
(
size_t
newCapacity
)
;
void
minimizeAllocableSpace
(
)
;
void
freeChunksFrom
(
Space
&
space
unsigned
firstFreeChunk
)
;
inline
bool
shouldTenure
(
gc
:
:
Cell
*
cell
)
;
void
sendTelemetry
(
JS
:
:
GCReason
reason
mozilla
:
:
TimeDuration
totalTime
bool
wasEmpty
double
promotionRate
size_t
sitesPretenured
)
;
void
printCollectionProfile
(
JS
:
:
GCReason
reason
double
promotionRate
)
;
void
printDeduplicationData
(
js
:
:
StringStats
&
prev
js
:
:
StringStats
&
curr
)
;
void
maybeClearProfileDurations
(
)
;
void
startProfile
(
ProfileKey
key
)
;
void
endProfile
(
ProfileKey
key
)
;
static
void
printProfileDurations
(
const
ProfileDurations
&
times
Sprinter
&
sprinter
)
;
mozilla
:
:
TimeStamp
collectionStartTime
(
)
const
;
private
:
using
BufferRelocationOverlay
=
void
*
;
using
BufferSet
=
HashSet
<
void
*
PointerHasher
<
void
*
>
SystemAllocPolicy
>
;
struct
Space
{
uintptr_t
position_
=
0
;
uintptr_t
currentEnd_
=
0
;
Vector
<
NurseryChunk
*
0
SystemAllocPolicy
>
chunks_
;
uint32_t
currentChunk_
=
0
;
uint32_t
maxChunkCount_
=
0
;
uint32_t
startChunk_
=
0
;
uintptr_t
startPosition_
=
0
;
BufferSet
mallocedBuffers
;
size_t
mallocedBufferBytes
=
0
;
Vector
<
PointerAndUint7
0
SystemAllocPolicy
>
trailersAdded_
;
Vector
<
void
*
0
SystemAllocPolicy
>
trailersRemoved_
;
size_t
trailersRemovedUsed_
=
0
;
size_t
trailerBytes_
=
0
;
gc
:
:
ChunkKind
kind
;
explicit
Space
(
gc
:
:
ChunkKind
kind
)
;
inline
bool
isEmpty
(
)
const
;
inline
bool
isInside
(
const
void
*
p
)
const
;
inline
size_t
offsetFromAddress
(
uintptr_t
addr
)
const
;
inline
size_t
offsetFromExclusiveAddress
(
uintptr_t
addr
)
const
;
void
setKind
(
gc
:
:
ChunkKind
newKind
)
;
void
clear
(
Nursery
*
nursery
)
;
void
moveToStartOfChunk
(
Nursery
*
nursery
unsigned
chunkno
)
;
void
setCurrentEnd
(
Nursery
*
nursery
)
;
void
setStartToCurrentPosition
(
)
;
bool
commitSubChunkRegion
(
size_t
oldCapacity
size_t
newCapacity
)
;
void
decommitSubChunkRegion
(
Nursery
*
nursery
size_t
oldCapacity
size_t
newCapacity
)
;
void
freeTrailerBlocks
(
gc
:
:
MallocedBlockCache
&
mallocedBlockCache
)
;
#
ifdef
DEBUG
void
checkKind
(
gc
:
:
ChunkKind
expected
)
const
;
size_t
findChunkIndex
(
uintptr_t
chunkAddr
)
const
;
#
endif
}
;
Space
toSpace
;
Space
fromSpace
;
gc
:
:
GCRuntime
*
const
gc
;
size_t
capacity_
;
uintptr_t
tenureThreshold_
=
0
;
gc
:
:
PretenuringNursery
pretenuringNursery
;
mozilla
:
:
TimeDuration
timeInChunkAlloc_
;
bool
enableProfiling_
=
false
;
bool
profileWorkers_
=
false
;
mozilla
:
:
TimeDuration
profileThreshold_
;
bool
semispaceEnabled_
;
bool
canAllocateStrings_
;
bool
canAllocateBigInts_
;
bool
reportDeduplications_
;
#
ifdef
JS_GC_ZEAL
bool
reportPromotion_
;
#
endif
gc
:
:
AllocSiteFilter
pretenuringReportFilter_
;
JS
:
:
GCReason
minorGCTriggerReason_
;
uintptr_t
prevPosition_
;
ProfileTimes
startTimes_
;
ProfileDurations
profileDurations_
;
ProfileDurations
totalDurations_
;
struct
PreviousGC
{
JS
:
:
GCReason
reason
=
JS
:
:
GCReason
:
:
NO_REASON
;
size_t
nurseryCapacity
=
0
;
size_t
nurseryCommitted
=
0
;
size_t
nurseryUsedBytes
=
0
;
size_t
nurseryUsedChunkCount
=
0
;
size_t
tenuredBytes
=
0
;
size_t
tenuredCells
=
0
;
mozilla
:
:
TimeStamp
endTime
;
}
;
PreviousGC
previousGC
;
bool
hasRecentGrowthData
;
double
smoothedTargetSize
;
using
ForwardedBufferMap
=
HashMap
<
void
*
void
*
PointerHasher
<
void
*
>
SystemAllocPolicy
>
;
ForwardedBufferMap
forwardedBuffers
;
gc
:
:
CellSweepSet
cellsToSweep
;
using
CellsWithUniqueIdVector
=
JS
:
:
GCVector
<
gc
:
:
Cell
*
8
SystemAllocPolicy
>
;
CellsWithUniqueIdVector
cellsWithUid_
;
using
MapObjectVector
=
Vector
<
MapObject
*
0
SystemAllocPolicy
>
;
MapObjectVector
mapsWithNurseryMemory_
;
using
SetObjectVector
=
Vector
<
SetObject
*
0
SystemAllocPolicy
>
;
SetObjectVector
setsWithNurseryMemory_
;
using
StringAndBuffer
=
std
:
:
pair
<
JSLinearString
*
mozilla
:
:
StringBuffer
*
>
;
using
StringAndBufferVector
=
JS
:
:
GCVector
<
StringAndBuffer
8
SystemAllocPolicy
>
;
StringAndBufferVector
stringBuffers_
;
using
ExtensibleStringBuffers
=
HashMap
<
JSLinearString
*
mozilla
:
:
StringBuffer
*
js
:
:
PointerHasher
<
JSLinearString
*
>
js
:
:
SystemAllocPolicy
>
;
ExtensibleStringBuffers
extensibleStringBuffers_
;
using
StringBufferVector
=
Vector
<
mozilla
:
:
StringBuffer
*
8
SystemAllocPolicy
>
;
StringBufferVector
stringBuffersToReleaseAfterMinorGC_
;
UniquePtr
<
NurseryDecommitTask
>
decommitTask
;
gc
:
:
MallocedBlockCache
mallocedBlockCache_
;
bool
tenuredEverything
;
friend
class
gc
:
:
GCRuntime
;
friend
class
gc
:
:
TenuringTracer
;
friend
struct
NurseryChunk
;
}
;
MOZ_ALWAYS_INLINE
bool
Nursery
:
:
isInside
(
const
void
*
p
)
const
{
return
toSpace
.
isInside
(
p
)
|
|
fromSpace
.
isInside
(
p
)
;
}
MOZ_ALWAYS_INLINE
bool
Nursery
:
:
Space
:
:
isInside
(
const
void
*
p
)
const
{
for
(
auto
*
chunk
:
chunks_
)
{
if
(
uintptr_t
(
p
)
-
uintptr_t
(
chunk
)
<
gc
:
:
ChunkSize
)
{
return
true
;
}
}
return
false
;
}
}
#
endif
