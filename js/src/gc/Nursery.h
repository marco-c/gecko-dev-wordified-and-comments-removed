#
ifndef
gc_Nursery_h
#
define
gc_Nursery_h
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
gc
/
GCProbes
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
gc
/
MallocedBlockCache
.
h
"
#
include
"
gc
/
Pretenuring
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Vector
.
h
"
#
define
FOR_EACH_NURSERY_PROFILE_TIME
(
_
)
\
_
(
Total
"
total
"
)
\
_
(
TraceValues
"
mkVals
"
)
\
_
(
TraceCells
"
mkClls
"
)
\
_
(
TraceSlots
"
mkSlts
"
)
\
_
(
TraceWasmAnyRefs
"
mkWars
"
)
\
_
(
TraceWholeCells
"
mcWCll
"
)
\
_
(
TraceGenericEntries
"
mkGnrc
"
)
\
_
(
CheckHashTables
"
ckTbls
"
)
\
_
(
MarkRuntime
"
mkRntm
"
)
\
_
(
MarkDebugger
"
mkDbgr
"
)
\
_
(
SweepCaches
"
swpCch
"
)
\
_
(
CollectToObjFP
"
colObj
"
)
\
_
(
CollectToStrFP
"
colStr
"
)
\
_
(
ObjectsTenuredCallback
"
tenCB
"
)
\
_
(
Sweep
"
sweep
"
)
\
_
(
UpdateJitActivations
"
updtIn
"
)
\
_
(
FreeMallocedBuffers
"
frSlts
"
)
\
_
(
FreeTrailerBlocks
"
frTrBs
"
)
\
_
(
ClearStoreBuffer
"
clrSB
"
)
\
_
(
ClearNursery
"
clear
"
)
\
_
(
PurgeStringToAtomCache
"
pStoA
"
)
\
_
(
Pretenure
"
pretnr
"
)
template
<
typename
T
>
class
SharedMem
;
namespace
js
{
struct
StringStats
;
class
AutoLockGCBgAlloc
;
class
ObjectElements
;
struct
NurseryChunk
;
class
HeapSlot
;
class
JSONPrinter
;
class
MapObject
;
class
SetObject
;
class
JS_PUBLIC_API
Sprinter
;
namespace
gc
{
class
AutoGCSession
;
struct
Cell
;
class
GCSchedulingTunables
;
class
TenuringTracer
;
}
class
Nursery
{
public
:
explicit
Nursery
(
gc
:
:
GCRuntime
*
gc
)
;
~
Nursery
(
)
;
[
[
nodiscard
]
]
bool
init
(
AutoLockGCBgAlloc
&
lock
)
;
unsigned
allocatedChunkCount
(
)
const
{
return
chunks_
.
length
(
)
;
}
unsigned
maxChunkCount
(
)
const
{
MOZ_ASSERT
(
capacity
(
)
)
;
return
HowMany
(
capacity
(
)
gc
:
:
ChunkSize
)
;
}
void
enable
(
)
;
void
disable
(
)
;
bool
isEnabled
(
)
const
{
return
capacity
(
)
!
=
0
;
}
void
enableStrings
(
)
;
void
disableStrings
(
)
;
bool
canAllocateStrings
(
)
const
{
return
canAllocateStrings_
;
}
void
enableBigInts
(
)
;
void
disableBigInts
(
)
;
bool
canAllocateBigInts
(
)
const
{
return
canAllocateBigInts_
;
}
bool
isEmpty
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isInside
(
gc
:
:
Cell
*
cellp
)
const
=
delete
;
MOZ_ALWAYS_INLINE
bool
isInside
(
const
void
*
p
)
const
{
for
(
auto
*
chunk
:
chunks_
)
{
if
(
uintptr_t
(
p
)
-
uintptr_t
(
chunk
)
<
gc
:
:
ChunkSize
)
{
return
true
;
}
}
return
false
;
}
template
<
typename
T
>
inline
bool
isInside
(
const
SharedMem
<
T
>
&
p
)
const
;
void
*
allocateCell
(
gc
:
:
AllocSite
*
site
size_t
size
JS
:
:
TraceKind
kind
)
;
void
*
tryAllocateCell
(
gc
:
:
AllocSite
*
site
size_t
size
JS
:
:
TraceKind
kind
)
{
MOZ_ASSERT
(
size
%
gc
:
:
CellAlignBytes
=
=
0
)
;
MOZ_ASSERT
(
size_t
(
kind
)
<
gc
:
:
NurseryTraceKinds
)
;
MOZ_ASSERT_IF
(
kind
=
=
JS
:
:
TraceKind
:
:
String
canAllocateStrings
(
)
)
;
MOZ_ASSERT_IF
(
kind
=
=
JS
:
:
TraceKind
:
:
BigInt
canAllocateBigInts
(
)
)
;
void
*
ptr
=
tryAllocate
(
sizeof
(
gc
:
:
NurseryCellHeader
)
+
size
)
;
if
(
MOZ_UNLIKELY
(
!
ptr
)
)
{
return
nullptr
;
}
new
(
ptr
)
gc
:
:
NurseryCellHeader
(
site
kind
)
;
void
*
cell
=
reinterpret_cast
<
void
*
>
(
uintptr_t
(
ptr
)
+
sizeof
(
gc
:
:
NurseryCellHeader
)
)
;
if
(
!
cell
)
{
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Successful
allocation
cannot
result
in
nullptr
"
)
;
}
uint32_t
allocCount
=
site
-
>
incAllocCount
(
)
;
if
(
allocCount
=
=
1
)
{
pretenuringNursery
.
insertIntoAllocatedList
(
site
)
;
}
MOZ_ASSERT_IF
(
site
-
>
isNormal
(
)
site
-
>
isInAllocatedList
(
)
)
;
gc
:
:
gcprobes
:
:
NurseryAlloc
(
cell
kind
)
;
return
cell
;
}
[
[
nodiscard
]
]
JS
:
:
GCReason
handleAllocationFailure
(
)
;
static
size_t
nurseryCellHeaderSize
(
)
{
return
sizeof
(
gc
:
:
NurseryCellHeader
)
;
}
void
*
allocateBuffer
(
JS
:
:
Zone
*
zone
size_t
nbytes
)
;
void
*
allocateBuffer
(
JS
:
:
Zone
*
zone
JSObject
*
obj
size_t
nbytes
)
;
void
*
allocateBufferSameLocation
(
JSObject
*
obj
size_t
nbytes
)
;
void
*
allocateZeroedBuffer
(
JS
:
:
Zone
*
zone
size_t
nbytes
arena_id_t
arena
=
js
:
:
MallocArena
)
;
void
*
allocateZeroedBuffer
(
JSObject
*
obj
size_t
nbytes
arena_id_t
arena
=
js
:
:
MallocArena
)
;
void
*
reallocateBuffer
(
JS
:
:
Zone
*
zone
gc
:
:
Cell
*
cell
void
*
oldBuffer
size_t
oldBytes
size_t
newBytes
)
;
void
*
allocateBuffer
(
JS
:
:
BigInt
*
bi
size_t
nbytes
)
;
void
freeBuffer
(
void
*
buffer
size_t
nbytes
)
;
static
const
size_t
MaxNurseryBufferSize
=
1024
;
void
collect
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
static
bool
getForwardedPointer
(
js
:
:
gc
:
:
Cell
*
*
ref
)
;
void
forwardBufferPointer
(
uintptr_t
*
pSlotsElems
)
;
inline
void
maybeSetForwardingPointer
(
JSTracer
*
trc
void
*
oldData
void
*
newData
bool
direct
)
;
inline
void
setForwardingPointerWhileTenuring
(
void
*
oldData
void
*
newData
bool
direct
)
;
[
[
nodiscard
]
]
bool
registerMallocedBuffer
(
void
*
buffer
size_t
nbytes
)
;
void
removeMallocedBuffer
(
void
*
buffer
size_t
nbytes
)
{
MOZ_ASSERT
(
mallocedBuffers
.
has
(
buffer
)
)
;
MOZ_ASSERT
(
nbytes
>
0
)
;
MOZ_ASSERT
(
mallocedBufferBytes
>
=
nbytes
)
;
mallocedBuffers
.
remove
(
buffer
)
;
mallocedBufferBytes
-
=
nbytes
;
}
void
removeMallocedBufferDuringMinorGC
(
void
*
buffer
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsMinorCollecting
(
)
)
;
MOZ_ASSERT
(
mallocedBuffers
.
has
(
buffer
)
)
;
mallocedBuffers
.
remove
(
buffer
)
;
}
[
[
nodiscard
]
]
bool
addedUniqueIdToCell
(
gc
:
:
Cell
*
cell
)
{
MOZ_ASSERT
(
IsInsideNursery
(
cell
)
)
;
MOZ_ASSERT
(
isEnabled
(
)
)
;
return
cellsWithUid_
.
append
(
cell
)
;
}
size_t
sizeOfMallocedBuffers
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
[
[
nodiscard
]
]
inline
bool
registerTrailer
(
PointerAndUint7
blockAndListID
size_t
nBytes
)
{
MOZ_ASSERT
(
trailersAdded_
.
length
(
)
=
=
trailersRemoved_
.
length
(
)
)
;
MOZ_ASSERT
(
nBytes
>
0
)
;
if
(
MOZ_UNLIKELY
(
!
trailersAdded_
.
append
(
blockAndListID
)
)
)
{
return
false
;
}
if
(
MOZ_UNLIKELY
(
!
trailersRemoved_
.
append
(
nullptr
)
)
)
{
trailersAdded_
.
popBack
(
)
;
return
false
;
}
trailerBytes_
+
=
nBytes
;
if
(
MOZ_UNLIKELY
(
trailerBytes_
>
capacity
(
)
*
8
)
)
{
requestMinorGC
(
JS
:
:
GCReason
:
:
NURSERY_TRAILERS
)
;
}
return
true
;
}
void
inline
unregisterTrailer
(
void
*
block
)
{
MOZ_ASSERT
(
trailersRemovedUsed_
<
trailersRemoved_
.
length
(
)
)
;
trailersRemoved_
[
trailersRemovedUsed_
]
=
block
;
trailersRemovedUsed_
+
+
;
}
size_t
sizeOfTrailerBlockSets
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
capacity
(
)
const
{
return
capacity_
;
}
size_t
committed
(
)
const
{
return
std
:
:
min
(
capacity_
allocatedChunkCount
(
)
*
gc
:
:
ChunkSize
)
;
}
MOZ_ALWAYS_INLINE
size_t
usedSpace
(
)
const
{
return
capacity
(
)
-
freeSpace
(
)
;
}
MOZ_ALWAYS_INLINE
size_t
freeSpace
(
)
const
{
MOZ_ASSERT
(
isEnabled
(
)
)
;
MOZ_ASSERT
(
currentEnd_
-
position_
<
=
NurseryChunkUsableSize
)
;
MOZ_ASSERT
(
currentChunk_
<
maxChunkCount
(
)
)
;
return
(
currentEnd_
-
position_
)
+
(
maxChunkCount
(
)
-
currentChunk_
-
1
)
*
gc
:
:
ChunkSize
;
}
#
ifdef
JS_GC_ZEAL
void
enterZealMode
(
)
;
void
leaveZealMode
(
)
;
#
endif
void
renderProfileJSON
(
JSONPrinter
&
json
)
const
;
void
printProfileHeader
(
)
;
void
printTotalProfileTimes
(
)
;
void
*
addressOfPosition
(
)
const
{
return
(
void
*
*
)
&
position_
;
}
static
constexpr
int32_t
offsetOfCurrentEndFromPosition
(
)
{
return
offsetof
(
Nursery
currentEnd_
)
-
offsetof
(
Nursery
position_
)
;
}
void
*
addressOfNurseryAllocatedSites
(
)
{
return
pretenuringNursery
.
addressOfAllocatedSites
(
)
;
}
void
requestMinorGC
(
JS
:
:
GCReason
reason
)
;
bool
minorGCRequested
(
)
const
{
return
minorGCTriggerReason_
!
=
JS
:
:
GCReason
:
:
NO_REASON
;
}
JS
:
:
GCReason
minorGCTriggerReason
(
)
const
{
return
minorGCTriggerReason_
;
}
bool
shouldCollect
(
)
const
;
bool
isNearlyFull
(
)
const
;
bool
isUnderused
(
)
const
;
bool
enableProfiling
(
)
const
{
return
enableProfiling_
;
}
bool
addMapWithNurseryMemory
(
MapObject
*
obj
)
{
MOZ_ASSERT_IF
(
!
mapsWithNurseryMemory_
.
empty
(
)
mapsWithNurseryMemory_
.
back
(
)
!
=
obj
)
;
return
mapsWithNurseryMemory_
.
append
(
obj
)
;
}
bool
addSetWithNurseryMemory
(
SetObject
*
obj
)
{
MOZ_ASSERT_IF
(
!
setsWithNurseryMemory_
.
empty
(
)
setsWithNurseryMemory_
.
back
(
)
!
=
obj
)
;
return
setsWithNurseryMemory_
.
append
(
obj
)
;
}
static
const
size_t
NurseryChunkUsableSize
=
gc
:
:
ChunkSize
-
sizeof
(
gc
:
:
ChunkBase
)
;
void
joinDecommitTask
(
)
;
mozilla
:
:
TimeStamp
collectionStartTime
(
)
{
return
startTimes_
[
ProfileKey
:
:
Total
]
;
}
bool
canCreateAllocSite
(
)
{
return
pretenuringNursery
.
canCreateAllocSite
(
)
;
}
void
noteAllocSiteCreated
(
)
{
pretenuringNursery
.
noteAllocSiteCreated
(
)
;
}
bool
reportPretenuring
(
)
const
{
return
reportPretenuring_
;
}
void
maybeStopPretenuring
(
gc
:
:
GCRuntime
*
gc
)
{
pretenuringNursery
.
maybeStopPretenuring
(
gc
)
;
}
void
setAllocFlagsForZone
(
JS
:
:
Zone
*
zone
)
;
static
size_t
roundSize
(
size_t
size
)
;
gc
:
:
MallocedBlockCache
&
mallocedBlockCache
(
)
{
return
mallocedBlockCache_
;
}
size_t
sizeOfMallocedBlockCache
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocedBlockCache_
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
mozilla
:
:
TimeStamp
lastCollectionEndTime
(
)
const
;
private
:
uintptr_t
position_
;
uintptr_t
currentEnd_
;
gc
:
:
GCRuntime
*
const
gc
;
Vector
<
NurseryChunk
*
0
SystemAllocPolicy
>
chunks_
;
uint32_t
currentChunk_
;
uint32_t
startChunk_
;
uintptr_t
startPosition_
;
size_t
capacity_
;
gc
:
:
PretenuringNursery
pretenuringNursery
;
mozilla
:
:
TimeDuration
timeInChunkAlloc_
;
bool
enableProfiling_
=
false
;
bool
profileWorkers_
=
false
;
mozilla
:
:
TimeDuration
profileThreshold_
;
bool
canAllocateStrings_
;
bool
canAllocateBigInts_
;
bool
reportDeduplications_
;
bool
reportPretenuring_
;
size_t
reportPretenuringThreshold_
;
JS
:
:
GCReason
minorGCTriggerReason_
;
uintptr_t
prevPosition_
;
enum
class
ProfileKey
{
#
define
DEFINE_TIME_KEY
(
name
text
)
name
FOR_EACH_NURSERY_PROFILE_TIME
(
DEFINE_TIME_KEY
)
#
undef
DEFINE_TIME_KEY
KeyCount
}
;
using
ProfileTimes
=
mozilla
:
:
EnumeratedArray
<
ProfileKey
ProfileKey
:
:
KeyCount
mozilla
:
:
TimeStamp
>
;
using
ProfileDurations
=
mozilla
:
:
EnumeratedArray
<
ProfileKey
ProfileKey
:
:
KeyCount
mozilla
:
:
TimeDuration
>
;
ProfileTimes
startTimes_
;
ProfileDurations
profileDurations_
;
ProfileDurations
totalDurations_
;
struct
PreviousGC
{
JS
:
:
GCReason
reason
=
JS
:
:
GCReason
:
:
NO_REASON
;
size_t
nurseryCapacity
=
0
;
size_t
nurseryCommitted
=
0
;
size_t
nurseryUsedBytes
=
0
;
size_t
nurseryUsedChunkCount
=
0
;
size_t
tenuredBytes
=
0
;
size_t
tenuredCells
=
0
;
mozilla
:
:
TimeStamp
endTime
;
}
;
PreviousGC
previousGC
;
bool
hasRecentGrowthData
;
double
smoothedTargetSize
;
double
calcPromotionRate
(
bool
*
validForTenuring
)
const
;
using
BufferRelocationOverlay
=
void
*
;
using
BufferSet
=
HashSet
<
void
*
PointerHasher
<
void
*
>
SystemAllocPolicy
>
;
BufferSet
mallocedBuffers
;
size_t
mallocedBufferBytes
=
0
;
Vector
<
PointerAndUint7
0
SystemAllocPolicy
>
trailersAdded_
;
Vector
<
void
*
0
SystemAllocPolicy
>
trailersRemoved_
;
size_t
trailersRemovedUsed_
=
0
;
size_t
trailerBytes_
=
0
;
void
freeTrailerBlocks
(
)
;
using
ForwardedBufferMap
=
HashMap
<
void
*
void
*
PointerHasher
<
void
*
>
SystemAllocPolicy
>
;
ForwardedBufferMap
forwardedBuffers
;
using
CellsWithUniqueIdVector
=
Vector
<
gc
:
:
Cell
*
8
SystemAllocPolicy
>
;
CellsWithUniqueIdVector
cellsWithUid_
;
Vector
<
MapObject
*
0
SystemAllocPolicy
>
mapsWithNurseryMemory_
;
Vector
<
SetObject
*
0
SystemAllocPolicy
>
setsWithNurseryMemory_
;
UniquePtr
<
NurseryDecommitTask
>
decommitTask
;
gc
:
:
MallocedBlockCache
mallocedBlockCache_
;
NurseryChunk
&
chunk
(
unsigned
index
)
const
{
return
*
chunks_
[
index
]
;
}
void
moveToStartOfChunk
(
unsigned
chunkno
)
;
bool
initFirstChunk
(
AutoLockGCBgAlloc
&
lock
)
;
void
poisonAndInitCurrentChunk
(
size_t
extent
=
gc
:
:
ChunkSize
)
;
void
setCurrentEnd
(
)
;
void
setStartToCurrentPosition
(
)
;
[
[
nodiscard
]
]
bool
allocateNextChunk
(
unsigned
chunkno
AutoLockGCBgAlloc
&
lock
)
;
uintptr_t
currentEnd
(
)
const
{
return
currentEnd_
;
}
uintptr_t
position
(
)
const
{
return
position_
;
}
MOZ_ALWAYS_INLINE
bool
isSubChunkMode
(
)
const
;
JSRuntime
*
runtime
(
)
const
;
gcstats
:
:
Statistics
&
stats
(
)
const
;
const
js
:
:
gc
:
:
GCSchedulingTunables
&
tunables
(
)
const
;
void
getAllocFlagsForZone
(
JS
:
:
Zone
*
zone
bool
*
allocObjectsOut
bool
*
allocStringsOut
bool
*
allocBigIntsOut
)
;
void
updateAllZoneAllocFlags
(
)
;
void
updateAllocFlagsForZone
(
JS
:
:
Zone
*
zone
)
;
void
discardCodeAndSetJitFlagsForZone
(
JS
:
:
Zone
*
zone
)
;
void
*
allocate
(
size_t
size
)
;
void
*
tryAllocate
(
size_t
size
)
{
MOZ_ASSERT
(
isEnabled
(
)
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
MOZ_ASSERT_IF
(
currentChunk_
=
=
startChunk_
position
(
)
>
=
startPosition_
)
;
MOZ_ASSERT
(
size
%
gc
:
:
CellAlignBytes
=
=
0
)
;
MOZ_ASSERT
(
position
(
)
%
gc
:
:
CellAlignBytes
=
=
0
)
;
if
(
MOZ_UNLIKELY
(
currentEnd
(
)
<
position
(
)
+
size
)
)
{
return
nullptr
;
}
void
*
ptr
=
reinterpret_cast
<
void
*
>
(
position
(
)
)
;
if
(
!
ptr
)
{
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Successful
allocation
cannot
result
in
nullptr
"
)
;
}
position_
=
position
(
)
+
size
;
DebugOnlyPoison
(
ptr
JS_ALLOCATED_NURSERY_PATTERN
size
MemCheckKind
:
:
MakeUndefined
)
;
return
ptr
;
}
[
[
nodiscard
]
]
bool
moveToNextChunk
(
)
;
struct
CollectionResult
{
size_t
tenuredBytes
;
size_t
tenuredCells
;
}
;
CollectionResult
doCollection
(
gc
:
:
AutoGCSession
&
session
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
;
void
traceRoots
(
gc
:
:
AutoGCSession
&
session
gc
:
:
TenuringTracer
&
mover
)
;
size_t
doPretenuring
(
JSRuntime
*
rt
JS
:
:
GCReason
reason
bool
validPromotionRate
double
promotionRate
)
;
inline
void
setForwardingPointer
(
void
*
oldData
void
*
newData
bool
direct
)
;
inline
void
setDirectForwardingPointer
(
void
*
oldData
void
*
newData
)
;
void
setIndirectForwardingPointer
(
void
*
oldData
void
*
newData
)
;
inline
void
setSlotsForwardingPointer
(
HeapSlot
*
oldSlots
HeapSlot
*
newSlots
uint32_t
nslots
)
;
inline
void
setElementsForwardingPointer
(
ObjectElements
*
oldHeader
ObjectElements
*
newHeader
uint32_t
capacity
)
;
#
ifdef
DEBUG
bool
checkForwardingPointerLocation
(
void
*
ptr
bool
expectedInside
)
;
#
endif
void
sweep
(
)
;
void
clear
(
)
;
void
sweepMapAndSetObjects
(
)
;
void
maybeResizeNursery
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
;
size_t
targetSize
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
;
void
clearRecentGrowthData
(
)
;
void
growAllocableSpace
(
size_t
newCapacity
)
;
void
shrinkAllocableSpace
(
size_t
newCapacity
)
;
void
minimizeAllocableSpace
(
)
;
void
freeChunksFrom
(
unsigned
firstFreeChunk
)
;
void
sendTelemetry
(
JS
:
:
GCReason
reason
mozilla
:
:
TimeDuration
totalTime
bool
wasEmpty
double
promotionRate
size_t
sitesPretenured
)
;
void
printCollectionProfile
(
JS
:
:
GCReason
reason
double
promotionRate
)
;
void
printDeduplicationData
(
js
:
:
StringStats
&
prev
js
:
:
StringStats
&
curr
)
;
void
maybeClearProfileDurations
(
)
;
void
startProfile
(
ProfileKey
key
)
;
void
endProfile
(
ProfileKey
key
)
;
static
void
printProfileDurations
(
const
ProfileDurations
&
times
Sprinter
&
sprinter
)
;
mozilla
:
:
TimeStamp
collectionStartTime
(
)
const
;
friend
class
gc
:
:
GCRuntime
;
friend
class
gc
:
:
TenuringTracer
;
friend
struct
NurseryChunk
;
}
;
}
#
endif
