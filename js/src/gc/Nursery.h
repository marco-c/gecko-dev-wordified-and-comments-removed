#
ifndef
gc_Nursery_h
#
define
gc_Nursery_h
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
jsalloc
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
ds
/
BitArray
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
gc
/
Memory
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
vm
/
SharedMem
.
h
"
#
define
FOR_EACH_NURSERY_PROFILE_TIME
(
_
)
\
_
(
Total
"
total
"
)
\
_
(
CancelIonCompilations
"
canIon
"
)
\
_
(
TraceValues
"
mkVals
"
)
\
_
(
TraceCells
"
mkClls
"
)
\
_
(
TraceSlots
"
mkSlts
"
)
\
_
(
TraceWholeCells
"
mcWCll
"
)
\
_
(
TraceGenericEntries
"
mkGnrc
"
)
\
_
(
CheckHashTables
"
ckTbls
"
)
\
_
(
MarkRuntime
"
mkRntm
"
)
\
_
(
MarkDebugger
"
mkDbgr
"
)
\
_
(
ClearNewObjectCache
"
clrNOC
"
)
\
_
(
CollectToFP
"
collct
"
)
\
_
(
ObjectsTenuredCallback
"
tenCB
"
)
\
_
(
SweepArrayBufferViewList
"
swpABO
"
)
\
_
(
UpdateJitActivations
"
updtIn
"
)
\
_
(
FreeMallocedBuffers
"
frSlts
"
)
\
_
(
ClearStoreBuffer
"
clrSB
"
)
\
_
(
Sweep
"
sweep
"
)
\
_
(
Resize
"
resize
"
)
\
_
(
Pretenure
"
pretnr
"
)
namespace
JS
{
struct
Zone
;
}
namespace
js
{
class
ObjectElements
;
class
NativeObject
;
class
Nursery
;
class
HeapSlot
;
class
ZoneGroup
;
void
SetGCZeal
(
JSRuntime
*
uint8_t
uint32_t
)
;
namespace
gc
{
class
AutoMaybeStartBackgroundAllocation
;
struct
Cell
;
class
MinorCollectionTracer
;
class
RelocationOverlay
;
struct
TenureCountCache
;
}
namespace
jit
{
class
MacroAssembler
;
}
class
TenuringTracer
:
public
JSTracer
{
friend
class
Nursery
;
Nursery
&
nursery_
;
size_t
tenuredSize
;
gc
:
:
RelocationOverlay
*
head
;
gc
:
:
RelocationOverlay
*
*
tail
;
TenuringTracer
(
JSRuntime
*
rt
Nursery
*
nursery
)
;
public
:
const
Nursery
&
nursery
(
)
const
{
return
nursery_
;
}
template
<
typename
T
>
void
traverse
(
T
*
*
thingp
)
;
template
<
typename
T
>
void
traverse
(
T
*
thingp
)
;
void
insertIntoFixupList
(
gc
:
:
RelocationOverlay
*
entry
)
;
void
traceObject
(
JSObject
*
src
)
;
void
traceObjectSlots
(
NativeObject
*
nobj
uint32_t
start
uint32_t
length
)
;
void
traceSlots
(
JS
:
:
Value
*
vp
uint32_t
nslots
)
{
traceSlots
(
vp
vp
+
nslots
)
;
}
private
:
Nursery
&
nursery
(
)
{
return
nursery_
;
}
JSObject
*
moveToTenured
(
JSObject
*
src
)
;
size_t
moveObjectToTenured
(
JSObject
*
dst
JSObject
*
src
gc
:
:
AllocKind
dstKind
)
;
size_t
moveElementsToTenured
(
NativeObject
*
dst
NativeObject
*
src
gc
:
:
AllocKind
dstKind
)
;
size_t
moveSlotsToTenured
(
NativeObject
*
dst
NativeObject
*
src
gc
:
:
AllocKind
dstKind
)
;
void
traceSlots
(
JS
:
:
Value
*
vp
JS
:
:
Value
*
end
)
;
}
;
inline
bool
CanNurseryAllocateFinalizedClass
(
const
js
:
:
Class
*
const
clasp
)
{
MOZ_ASSERT
(
clasp
-
>
hasFinalize
(
)
)
;
return
clasp
-
>
flags
&
JSCLASS_SKIP_NURSERY_FINALIZE
;
}
class
Nursery
{
public
:
static
const
size_t
Alignment
=
gc
:
:
ChunkSize
;
static
const
size_t
ChunkShift
=
gc
:
:
ChunkShift
;
explicit
Nursery
(
ZoneGroup
*
group
)
;
~
Nursery
(
)
;
MOZ_MUST_USE
bool
init
(
uint32_t
maxNurseryBytes
AutoLockGC
&
lock
)
;
unsigned
maxChunks
(
)
const
{
return
maxNurseryChunks_
;
}
unsigned
numChunks
(
)
const
{
return
chunks_
.
length
(
)
;
}
bool
exists
(
)
const
{
return
maxChunks
(
)
!
=
0
;
}
size_t
nurserySize
(
)
const
{
return
maxChunks
(
)
<
<
ChunkShift
;
}
void
enable
(
)
;
void
disable
(
)
;
bool
isEnabled
(
)
const
{
return
numChunks
(
)
!
=
0
;
}
bool
isEmpty
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isInside
(
gc
:
:
Cell
*
cellp
)
const
=
delete
;
MOZ_ALWAYS_INLINE
bool
isInside
(
const
void
*
p
)
const
{
for
(
auto
chunk
:
chunks_
)
{
if
(
uintptr_t
(
p
)
-
chunk
-
>
start
(
)
<
gc
:
:
ChunkSize
)
return
true
;
}
return
false
;
}
template
<
typename
T
>
bool
isInside
(
const
SharedMem
<
T
>
&
p
)
const
{
return
isInside
(
p
.
unwrap
(
)
)
;
}
JSObject
*
allocateObject
(
JSContext
*
cx
size_t
size
size_t
numDynamic
const
js
:
:
Class
*
clasp
)
;
void
*
allocateBuffer
(
JS
:
:
Zone
*
zone
size_t
nbytes
)
;
void
*
allocateBuffer
(
JSObject
*
obj
size_t
nbytes
)
;
void
*
reallocateBuffer
(
JSObject
*
obj
void
*
oldBuffer
size_t
oldBytes
size_t
newBytes
)
;
void
freeBuffer
(
void
*
buffer
)
;
static
const
size_t
MaxNurseryBufferSize
=
1024
;
void
collect
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
MOZ_ALWAYS_INLINE
MOZ_MUST_USE
static
bool
getForwardedPointer
(
JSObject
*
*
ref
)
;
void
forwardBufferPointer
(
HeapSlot
*
*
pSlotsElems
)
;
void
maybeSetForwardingPointer
(
JSTracer
*
trc
void
*
oldData
void
*
newData
bool
direct
)
{
if
(
trc
-
>
isTenuringTracer
(
)
&
&
isInside
(
oldData
)
)
setForwardingPointer
(
oldData
newData
direct
)
;
}
void
removeMallocedBuffer
(
void
*
buffer
)
{
mallocedBuffers
.
remove
(
buffer
)
;
}
void
waitBackgroundFreeEnd
(
)
;
MOZ_MUST_USE
bool
addedUniqueIdToCell
(
gc
:
:
Cell
*
cell
)
{
if
(
!
IsInsideNursery
(
cell
)
|
|
!
isEnabled
(
)
)
return
true
;
MOZ_ASSERT
(
cellsWithUid_
.
initialized
(
)
)
;
MOZ_ASSERT
(
!
cellsWithUid_
.
has
(
cell
)
)
;
return
cellsWithUid_
.
put
(
cell
)
;
}
using
SweepThunk
=
void
(
*
)
(
void
*
data
)
;
void
queueSweepAction
(
SweepThunk
thunk
void
*
data
)
;
MOZ_MUST_USE
bool
queueDictionaryModeObjectToSweep
(
NativeObject
*
obj
)
;
size_t
sizeOfHeapCommitted
(
)
const
{
return
numChunks
(
)
*
gc
:
:
ChunkSize
;
}
size_t
sizeOfMallocedBuffers
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
if
(
!
mallocedBuffers
.
initialized
(
)
)
return
0
;
size_t
total
=
0
;
for
(
MallocedBuffersSet
:
:
Range
r
=
mallocedBuffers
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
total
+
=
mallocSizeOf
(
r
.
front
(
)
)
;
total
+
=
mallocedBuffers
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
return
total
;
}
size_t
spaceToEnd
(
)
const
;
MOZ_ALWAYS_INLINE
size_t
freeSpace
(
)
const
{
MOZ_ASSERT
(
currentEnd_
-
position_
<
=
NurseryChunkUsableSize
)
;
return
(
currentEnd_
-
position_
)
+
(
numChunks
(
)
-
currentChunk_
-
1
)
*
NurseryChunkUsableSize
;
}
#
ifdef
JS_GC_ZEAL
void
enterZealMode
(
)
;
void
leaveZealMode
(
)
;
#
endif
static
void
printProfileHeader
(
)
;
void
printTotalProfileTimes
(
)
;
void
*
addressOfCurrentEnd
(
)
const
{
return
(
void
*
)
&
currentEnd_
;
}
void
*
addressOfPosition
(
)
const
{
return
(
void
*
)
&
position_
;
}
void
requestMinorGC
(
JS
:
:
gcreason
:
:
Reason
reason
)
const
;
bool
minorGCRequested
(
)
const
{
return
minorGCTriggerReason_
!
=
JS
:
:
gcreason
:
:
NO_REASON
;
}
JS
:
:
gcreason
:
:
Reason
minorGCTriggerReason
(
)
const
{
return
minorGCTriggerReason_
;
}
void
clearMinorGCRequest
(
)
{
minorGCTriggerReason_
=
JS
:
:
gcreason
:
:
NO_REASON
;
}
bool
enableProfiling
(
)
const
{
return
enableProfiling_
;
}
private
:
static
const
size_t
NurseryChunkUsableSize
=
gc
:
:
ChunkSize
-
sizeof
(
gc
:
:
ChunkTrailer
)
;
struct
NurseryChunk
{
char
data
[
NurseryChunkUsableSize
]
;
gc
:
:
ChunkTrailer
trailer
;
static
NurseryChunk
*
fromChunk
(
gc
:
:
Chunk
*
chunk
)
;
void
init
(
ZoneGroup
*
group
)
;
void
poisonAndInit
(
ZoneGroup
*
group
uint8_t
poison
)
;
uintptr_t
start
(
)
const
{
return
uintptr_t
(
&
data
)
;
}
uintptr_t
end
(
)
const
{
return
uintptr_t
(
&
trailer
)
;
}
gc
:
:
Chunk
*
toChunk
(
JSRuntime
*
rt
)
;
}
;
static_assert
(
sizeof
(
NurseryChunk
)
=
=
gc
:
:
ChunkSize
"
Nursery
chunk
size
must
match
gc
:
:
Chunk
size
.
"
)
;
ZoneGroup
*
zoneGroup_
;
Vector
<
NurseryChunk
*
0
SystemAllocPolicy
>
chunks_
;
uintptr_t
position_
;
unsigned
currentStartChunk_
;
uintptr_t
currentStartPosition_
;
uintptr_t
currentEnd_
;
unsigned
currentChunk_
;
unsigned
maxNurseryChunks_
;
double
previousPromotionRate_
;
mozilla
:
:
TimeDuration
profileThreshold_
;
bool
enableProfiling_
;
int64_t
reportTenurings_
;
mutable
JS
:
:
gcreason
:
:
Reason
minorGCTriggerReason_
;
enum
class
ProfileKey
{
#
define
DEFINE_TIME_KEY
(
name
text
)
\
name
FOR_EACH_NURSERY_PROFILE_TIME
(
DEFINE_TIME_KEY
)
#
undef
DEFINE_TIME_KEY
KeyCount
}
;
using
ProfileTimes
=
mozilla
:
:
EnumeratedArray
<
ProfileKey
ProfileKey
:
:
KeyCount
mozilla
:
:
TimeStamp
>
;
using
ProfileDurations
=
mozilla
:
:
EnumeratedArray
<
ProfileKey
ProfileKey
:
:
KeyCount
mozilla
:
:
TimeDuration
>
;
ProfileTimes
startTimes_
;
ProfileDurations
profileDurations_
;
ProfileDurations
totalDurations_
;
uint64_t
minorGcCount_
;
typedef
HashSet
<
void
*
PointerHasher
<
void
*
3
>
SystemAllocPolicy
>
MallocedBuffersSet
;
MallocedBuffersSet
mallocedBuffers
;
struct
FreeMallocedBuffersTask
;
FreeMallocedBuffersTask
*
freeMallocedBuffersTask
;
typedef
HashMap
<
void
*
void
*
PointerHasher
<
void
*
1
>
SystemAllocPolicy
>
ForwardedBufferMap
;
ForwardedBufferMap
forwardedBuffers
;
using
CellsWithUniqueIdSet
=
HashSet
<
gc
:
:
Cell
*
PointerHasher
<
gc
:
:
Cell
*
3
>
SystemAllocPolicy
>
;
CellsWithUniqueIdSet
cellsWithUid_
;
struct
SweepAction
;
SweepAction
*
sweepActions_
;
using
NativeObjectVector
=
Vector
<
NativeObject
*
0
SystemAllocPolicy
>
;
NativeObjectVector
dictionaryModeObjects_
;
#
ifdef
JS_GC_ZEAL
struct
Canary
;
Canary
*
lastCanary_
;
#
endif
NurseryChunk
*
allocChunk
(
)
;
NurseryChunk
&
chunk
(
unsigned
index
)
const
{
return
*
chunks_
[
index
]
;
}
void
setCurrentChunk
(
unsigned
chunkno
)
;
void
setStartPosition
(
)
;
void
updateNumChunks
(
unsigned
newCount
)
;
void
updateNumChunksLocked
(
unsigned
newCount
gc
:
:
AutoMaybeStartBackgroundAllocation
&
maybeBgAlloc
AutoLockGC
&
lock
)
;
MOZ_ALWAYS_INLINE
uintptr_t
allocationEnd
(
)
const
{
MOZ_ASSERT
(
numChunks
(
)
>
0
)
;
return
chunks_
.
back
(
)
-
>
end
(
)
;
}
MOZ_ALWAYS_INLINE
uintptr_t
currentEnd
(
)
const
{
MOZ_ASSERT
(
currentEnd_
=
=
chunk
(
currentChunk_
)
.
end
(
)
)
;
return
currentEnd_
;
}
uintptr_t
position
(
)
const
{
return
position_
;
}
ZoneGroup
*
zoneGroup
(
)
const
{
return
zoneGroup_
;
}
gc
:
:
TenuredCell
*
allocateFromTenured
(
JS
:
:
Zone
*
zone
gc
:
:
AllocKind
thingKind
)
;
void
*
allocate
(
size_t
size
)
;
double
doCollection
(
JS
:
:
gcreason
:
:
Reason
reason
gc
:
:
TenureCountCache
&
tenureCounts
)
;
void
collectToFixedPoint
(
TenuringTracer
&
trc
gc
:
:
TenureCountCache
&
tenureCounts
)
;
void
setForwardingPointer
(
void
*
oldData
void
*
newData
bool
direct
)
;
void
setSlotsForwardingPointer
(
HeapSlot
*
oldSlots
HeapSlot
*
newSlots
uint32_t
nslots
)
;
void
setElementsForwardingPointer
(
ObjectElements
*
oldHeader
ObjectElements
*
newHeader
uint32_t
nelems
)
;
void
freeMallocedBuffers
(
)
;
void
sweep
(
)
;
void
runSweepActions
(
)
;
void
sweepDictionaryModeObjects
(
)
;
void
maybeResizeNursery
(
JS
:
:
gcreason
:
:
Reason
reason
double
promotionRate
)
;
void
growAllocableSpace
(
)
;
void
shrinkAllocableSpace
(
)
;
void
minimizeAllocableSpace
(
)
;
void
maybeClearProfileDurations
(
)
;
void
startProfile
(
ProfileKey
key
)
;
void
endProfile
(
ProfileKey
key
)
;
void
maybeStartProfile
(
ProfileKey
key
)
;
void
maybeEndProfile
(
ProfileKey
key
)
;
static
void
printProfileDurations
(
const
ProfileDurations
&
times
)
;
friend
class
TenuringTracer
;
friend
class
gc
:
:
MinorCollectionTracer
;
friend
class
jit
:
:
MacroAssembler
;
}
;
}
#
endif
