#
ifndef
gc_GCContext_h
#
define
gc_GCContext_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
jit
/
ExecutableAllocator
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
struct
JS_PUBLIC_API
JSRuntime
;
namespace
js
{
class
AutoTouchingGrayThings
;
namespace
gc
{
class
AutoSetThreadGCUse
;
class
AutoSetThreadIsPerformingGC
;
enum
class
GCUse
{
None
Marking
Sweeping
Finalizing
}
;
}
}
namespace
JS
{
class
GCContext
{
using
Cell
=
js
:
:
gc
:
:
Cell
;
using
MemoryUse
=
js
:
:
MemoryUse
;
JSRuntime
*
const
runtime_
;
const
bool
isMainThread_
;
js
:
:
jit
:
:
JitPoisonRangeVector
jitPoisonRanges
;
bool
isCollecting_
=
false
;
friend
class
js
:
:
gc
:
:
AutoSetThreadIsPerformingGC
;
#
ifdef
DEBUG
js
:
:
gc
:
:
GCUse
gcUse_
=
js
:
:
gc
:
:
GCUse
:
:
None
;
Zone
*
gcSweepZone_
=
nullptr
;
size_t
isTouchingGrayThings_
=
false
;
friend
class
js
:
:
gc
:
:
AutoSetThreadGCUse
;
friend
class
js
:
:
AutoTouchingGrayThings
;
#
endif
public
:
explicit
GCContext
(
JSRuntime
*
maybeRuntime
bool
isMainThread
)
;
~
GCContext
(
)
;
JSRuntime
*
runtime
(
)
const
{
MOZ_ASSERT
(
isMainThread_
)
;
return
runtimeFromAnyThread
(
)
;
}
JSRuntime
*
runtimeFromAnyThread
(
)
const
{
MOZ_ASSERT
(
runtime_
)
;
return
runtime_
;
}
bool
onMainThread
(
)
const
{
return
isMainThread_
;
}
bool
isCollecting
(
)
const
{
return
isCollecting_
;
}
#
ifdef
DEBUG
js
:
:
gc
:
:
GCUse
gcUse
(
)
const
{
return
gcUse_
;
}
Zone
*
gcSweepZone
(
)
const
{
return
gcSweepZone_
;
}
bool
isTouchingGrayThings
(
)
const
{
return
isTouchingGrayThings_
;
}
#
endif
void
freeUntracked
(
void
*
p
)
{
js_free
(
p
)
;
}
void
free_
(
Cell
*
cell
void
*
p
size_t
nbytes
MemoryUse
use
)
;
bool
appendJitPoisonRange
(
const
js
:
:
jit
:
:
JitPoisonRange
&
range
)
{
return
jitPoisonRanges
.
append
(
range
)
;
}
bool
hasJitCodeToPoison
(
)
const
{
return
!
jitPoisonRanges
.
empty
(
)
;
}
void
poisonJitCode
(
)
;
template
<
class
T
>
void
deleteUntracked
(
T
*
p
)
{
if
(
p
)
{
p
-
>
~
T
(
)
;
js_free
(
p
)
;
}
}
template
<
class
T
>
void
delete_
(
Cell
*
cell
T
*
p
MemoryUse
use
)
{
delete_
(
cell
p
sizeof
(
T
)
use
)
;
}
template
<
class
T
>
void
delete_
(
Cell
*
cell
T
*
p
size_t
nbytes
MemoryUse
use
)
{
if
(
p
)
{
p
-
>
~
T
(
)
;
free_
(
cell
p
nbytes
use
)
;
}
}
template
<
class
T
>
void
release
(
Cell
*
cell
T
*
p
MemoryUse
use
)
{
release
(
cell
p
sizeof
(
T
)
use
)
;
}
template
<
class
T
>
void
release
(
Cell
*
cell
T
*
p
size_t
nbytes
MemoryUse
use
)
;
void
removeCellMemory
(
Cell
*
cell
size_t
nbytes
MemoryUse
use
)
;
}
;
}
namespace
js
{
extern
MOZ_THREAD_LOCAL
(
JS
:
:
GCContext
*
)
TlsGCContext
;
inline
JS
:
:
GCContext
*
MaybeGetGCContext
(
)
{
if
(
!
TlsGCContext
.
init
(
)
)
{
return
nullptr
;
}
return
TlsGCContext
.
get
(
)
;
}
class
MOZ_RAII
AutoTouchingGrayThings
{
public
:
#
ifdef
DEBUG
AutoTouchingGrayThings
(
)
{
TlsGCContext
.
get
(
)
-
>
isTouchingGrayThings_
+
+
;
}
~
AutoTouchingGrayThings
(
)
{
JS
:
:
GCContext
*
gcx
=
TlsGCContext
.
get
(
)
;
MOZ_ASSERT
(
gcx
-
>
isTouchingGrayThings_
)
;
gcx
-
>
isTouchingGrayThings_
-
-
;
}
#
else
AutoTouchingGrayThings
(
)
{
}
#
endif
}
;
#
ifdef
DEBUG
inline
bool
CurrentThreadIsGCMarking
(
)
{
JS
:
:
GCContext
*
gcx
=
MaybeGetGCContext
(
)
;
return
gcx
&
&
gcx
-
>
gcUse
(
)
=
=
gc
:
:
GCUse
:
:
Marking
;
}
inline
bool
CurrentThreadIsGCSweeping
(
)
{
JS
:
:
GCContext
*
gcx
=
MaybeGetGCContext
(
)
;
return
gcx
&
&
gcx
-
>
gcUse
(
)
=
=
gc
:
:
GCUse
:
:
Sweeping
;
}
inline
bool
CurrentThreadIsGCFinalizing
(
)
{
JS
:
:
GCContext
*
gcx
=
MaybeGetGCContext
(
)
;
return
gcx
&
&
gcx
-
>
gcUse
(
)
=
=
gc
:
:
GCUse
:
:
Finalizing
;
}
inline
bool
CurrentThreadIsTouchingGrayThings
(
)
{
JS
:
:
GCContext
*
gcx
=
MaybeGetGCContext
(
)
;
return
gcx
&
&
gcx
-
>
isTouchingGrayThings
(
)
;
}
inline
bool
CurrentThreadIsPerformingGC
(
)
{
JS
:
:
GCContext
*
gcx
=
MaybeGetGCContext
(
)
;
return
gcx
&
&
gcx
-
>
isCollecting
(
)
;
}
#
endif
}
#
endif
