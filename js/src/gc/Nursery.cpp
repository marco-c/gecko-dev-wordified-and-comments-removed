#
include
"
gc
/
Nursery
-
inl
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
algorithm
>
#
include
"
builtin
/
MapObject
.
h
"
#
include
"
debugger
/
DebugAPI
.
h
"
#
include
"
gc
/
FreeOp
.
h
"
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
gc
/
Memory
.
h
"
#
include
"
gc
/
PublicIterators
.
h
"
#
include
"
jit
/
JitFrames
.
h
"
#
include
"
jit
/
JitRealm
.
h
"
#
include
"
util
/
Poison
.
h
"
#
include
"
vm
/
ArrayObject
.
h
"
#
if
defined
(
DEBUG
)
#
include
"
vm
/
EnvironmentObject
.
h
"
#
endif
#
include
"
vm
/
JSONPrinter
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
Time
.
h
"
#
include
"
vm
/
TypedArrayObject
.
h
"
#
include
"
vm
/
TypeInference
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
gc
/
Zone
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
gc
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
PodCopy
;
using
mozilla
:
:
TimeDuration
;
using
mozilla
:
:
TimeStamp
;
#
ifdef
JS_GC_ZEAL
constexpr
uintptr_t
CanaryMagicValue
=
0xDEADB15D
;
struct
js
:
:
Nursery
:
:
Canary
{
uintptr_t
magicValue
;
Canary
*
next
;
}
;
#
endif
namespace
js
{
struct
NurseryChunk
{
char
data
[
Nursery
:
:
NurseryChunkUsableSize
]
;
gc
:
:
ChunkTrailer
trailer
;
static
NurseryChunk
*
fromChunk
(
gc
:
:
Chunk
*
chunk
)
;
void
poisonAndInit
(
JSRuntime
*
rt
size_t
size
=
ChunkSize
)
;
void
poisonRange
(
size_t
from
size_t
size
uint8_t
value
MemCheckKind
checkKind
)
;
void
poisonAfterEvict
(
size_t
extent
=
ChunkSize
)
;
void
markPagesUnusedHard
(
size_t
from
)
;
MOZ_MUST_USE
bool
markPagesInUseHard
(
size_t
to
)
;
uintptr_t
start
(
)
const
{
return
uintptr_t
(
&
data
)
;
}
uintptr_t
end
(
)
const
{
return
uintptr_t
(
&
trailer
)
;
}
gc
:
:
Chunk
*
toChunk
(
GCRuntime
*
gc
)
;
}
;
static_assert
(
sizeof
(
js
:
:
NurseryChunk
)
=
=
gc
:
:
ChunkSize
"
Nursery
chunk
size
must
match
gc
:
:
Chunk
size
.
"
)
;
}
inline
void
js
:
:
NurseryChunk
:
:
poisonAndInit
(
JSRuntime
*
rt
size_t
size
)
{
poisonRange
(
0
size
JS_FRESH_NURSERY_PATTERN
MemCheckKind
:
:
MakeUndefined
)
;
MOZ_MAKE_MEM_UNDEFINED
(
&
trailer
sizeof
(
trailer
)
)
;
new
(
&
trailer
)
gc
:
:
ChunkTrailer
(
rt
&
rt
-
>
gc
.
storeBuffer
(
)
)
;
}
inline
void
js
:
:
NurseryChunk
:
:
poisonRange
(
size_t
from
size_t
size
uint8_t
value
MemCheckKind
checkKind
)
{
MOZ_ASSERT
(
from
<
=
js
:
:
Nursery
:
:
NurseryChunkUsableSize
)
;
MOZ_ASSERT
(
from
+
size
<
=
ChunkSize
)
;
uint8_t
*
start
=
reinterpret_cast
<
uint8_t
*
>
(
this
)
+
from
;
MOZ_MAKE_MEM_UNDEFINED
(
start
size
)
;
Poison
(
start
value
size
checkKind
)
;
}
inline
void
js
:
:
NurseryChunk
:
:
poisonAfterEvict
(
size_t
extent
)
{
MOZ_ASSERT
(
extent
<
=
ChunkSize
)
;
poisonRange
(
0
extent
JS_SWEPT_NURSERY_PATTERN
MemCheckKind
:
:
MakeNoAccess
)
;
}
inline
void
js
:
:
NurseryChunk
:
:
markPagesUnusedHard
(
size_t
from
)
{
MOZ_ASSERT
(
from
<
ChunkSize
-
ArenaSize
)
;
MarkPagesUnusedHard
(
reinterpret_cast
<
void
*
>
(
start
(
)
+
from
)
ChunkSize
-
ArenaSize
-
from
)
;
}
inline
bool
js
:
:
NurseryChunk
:
:
markPagesInUseHard
(
size_t
to
)
{
MOZ_ASSERT
(
to
<
=
ChunkSize
-
ArenaSize
)
;
return
MarkPagesInUseHard
(
reinterpret_cast
<
void
*
>
(
start
(
)
)
to
)
;
}
inline
js
:
:
NurseryChunk
*
js
:
:
NurseryChunk
:
:
fromChunk
(
Chunk
*
chunk
)
{
return
reinterpret_cast
<
NurseryChunk
*
>
(
chunk
)
;
}
inline
Chunk
*
js
:
:
NurseryChunk
:
:
toChunk
(
GCRuntime
*
gc
)
{
auto
chunk
=
reinterpret_cast
<
Chunk
*
>
(
this
)
;
chunk
-
>
init
(
gc
)
;
return
chunk
;
}
void
js
:
:
NurseryDecommitTask
:
:
queueChunk
(
NurseryChunk
*
nchunk
const
AutoLockHelperThreadState
&
lock
)
{
Chunk
*
chunk
=
nchunk
-
>
toChunk
(
gc
)
;
chunk
-
>
info
.
prev
=
nullptr
;
chunk
-
>
info
.
next
=
queue
;
queue
=
chunk
;
}
void
js
:
:
NurseryDecommitTask
:
:
queueRange
(
size_t
newCapacity
NurseryChunk
&
newChunk
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
!
partialChunk
|
|
partialChunk
=
=
&
newChunk
)
;
if
(
RoundUp
(
newCapacity
SystemPageSize
(
)
)
>
=
RoundDown
(
Nursery
:
:
NurseryChunkUsableSize
SystemPageSize
(
)
)
)
{
partialChunk
=
nullptr
;
return
;
}
partialChunk
=
&
newChunk
;
partialCapacity
=
newCapacity
;
}
Chunk
*
js
:
:
NurseryDecommitTask
:
:
popChunk
(
const
AutoLockHelperThreadState
&
lock
)
{
if
(
!
queue
)
{
return
nullptr
;
}
Chunk
*
chunk
=
queue
;
queue
=
chunk
-
>
info
.
next
;
chunk
-
>
info
.
next
=
nullptr
;
MOZ_ASSERT
(
chunk
-
>
info
.
prev
=
=
nullptr
)
;
return
chunk
;
}
void
js
:
:
NurseryDecommitTask
:
:
run
(
)
{
Chunk
*
chunk
;
{
AutoLockHelperThreadState
lock
;
while
(
(
chunk
=
popChunk
(
lock
)
)
|
|
partialChunk
)
{
if
(
chunk
)
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
decommitChunk
(
chunk
)
;
continue
;
}
if
(
partialChunk
)
{
decommitRange
(
lock
)
;
continue
;
}
}
setFinishing
(
lock
)
;
}
}
void
js
:
:
NurseryDecommitTask
:
:
decommitChunk
(
Chunk
*
chunk
)
{
chunk
-
>
decommitAllArenas
(
)
;
{
AutoLockGC
lock
(
gc
)
;
gc
-
>
recycleChunk
(
chunk
lock
)
;
}
}
void
js
:
:
NurseryDecommitTask
:
:
decommitRange
(
AutoLockHelperThreadState
&
lock
)
{
NurseryChunk
*
thisPartialChunk
=
partialChunk
;
size_t
thisPartialCapacity
=
partialCapacity
;
partialChunk
=
nullptr
;
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
thisPartialChunk
-
>
markPagesUnusedHard
(
thisPartialCapacity
)
;
}
}
js
:
:
Nursery
:
:
Nursery
(
GCRuntime
*
gc
)
:
gc
(
gc
)
position_
(
0
)
currentStartChunk_
(
0
)
currentStartPosition_
(
0
)
currentEnd_
(
0
)
currentStringEnd_
(
0
)
currentChunk_
(
0
)
capacity_
(
0
)
timeInChunkAlloc_
(
0
)
profileThreshold_
(
0
)
enableProfiling_
(
false
)
canAllocateStrings_
(
true
)
reportTenurings_
(
0
)
minorGCTriggerReason_
(
JS
:
:
GCReason
:
:
NO_REASON
)
decommitTask
(
gc
)
#
ifdef
JS_GC_ZEAL
lastCanary_
(
nullptr
)
#
endif
{
const
char
*
env
=
getenv
(
"
MOZ_NURSERY_STRINGS
"
)
;
if
(
env
&
&
*
env
)
{
canAllocateStrings_
=
(
*
env
=
=
'
1
'
)
;
}
}
bool
js
:
:
Nursery
:
:
init
(
AutoLockGCBgAlloc
&
lock
)
{
if
(
mozilla
:
:
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
return
true
;
}
capacity_
=
roundSize
(
tunables
(
)
.
gcMinNurseryBytes
(
)
)
;
if
(
!
allocateNextChunk
(
0
lock
)
)
{
capacity_
=
0
;
return
false
;
}
setCurrentChunk
(
0
)
;
setStartPosition
(
)
;
poisonAndInitCurrentChunk
(
)
;
char
*
env
=
getenv
(
"
JS_GC_PROFILE_NURSERY
"
)
;
if
(
env
)
{
if
(
0
=
=
strcmp
(
env
"
help
"
)
)
{
fprintf
(
stderr
"
JS_GC_PROFILE_NURSERY
=
N
\
n
"
"
\
tReport
minor
GC
'
s
taking
at
least
N
microseconds
.
\
n
"
)
;
exit
(
0
)
;
}
enableProfiling_
=
true
;
profileThreshold_
=
TimeDuration
:
:
FromMicroseconds
(
atoi
(
env
)
)
;
}
env
=
getenv
(
"
JS_GC_REPORT_TENURING
"
)
;
if
(
env
)
{
if
(
0
=
=
strcmp
(
env
"
help
"
)
)
{
fprintf
(
stderr
"
JS_GC_REPORT_TENURING
=
N
\
n
"
"
\
tAfter
a
minor
GC
report
any
ObjectGroups
with
at
least
N
"
"
instances
tenured
.
\
n
"
)
;
exit
(
0
)
;
}
reportTenurings_
=
atoi
(
env
)
;
}
if
(
!
gc
-
>
storeBuffer
(
)
.
enable
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
isEnabled
(
)
)
;
return
true
;
}
js
:
:
Nursery
:
:
~
Nursery
(
)
{
disable
(
)
;
}
void
js
:
:
Nursery
:
:
enable
(
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
MOZ_ASSERT
(
!
gc
-
>
isVerifyPreBarriersEnabled
(
)
)
;
if
(
isEnabled
(
)
|
|
mozilla
:
:
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
return
;
}
{
AutoLockGCBgAlloc
lock
(
gc
)
;
capacity_
=
roundSize
(
tunables
(
)
.
gcMinNurseryBytes
(
)
)
;
if
(
!
allocateNextChunk
(
0
lock
)
)
{
capacity_
=
0
;
return
;
}
}
setCurrentChunk
(
0
)
;
setStartPosition
(
)
;
poisonAndInitCurrentChunk
(
)
;
#
ifdef
JS_GC_ZEAL
if
(
gc
-
>
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
)
{
enterZealMode
(
)
;
}
#
endif
MOZ_ALWAYS_TRUE
(
gc
-
>
storeBuffer
(
)
.
enable
(
)
)
;
}
void
js
:
:
Nursery
:
:
disable
(
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
if
(
!
isEnabled
(
)
)
{
return
;
}
decommitTask
.
join
(
)
;
freeChunksFrom
(
0
)
;
capacity_
=
0
;
currentEnd_
=
0
;
currentStringEnd_
=
0
;
position_
=
0
;
gc
-
>
storeBuffer
(
)
.
disable
(
)
;
decommitTask
.
join
(
)
;
}
void
js
:
:
Nursery
:
:
enableStrings
(
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
canAllocateStrings_
=
true
;
currentStringEnd_
=
currentEnd_
;
}
void
js
:
:
Nursery
:
:
disableStrings
(
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
canAllocateStrings_
=
false
;
currentStringEnd_
=
0
;
}
bool
js
:
:
Nursery
:
:
isEmpty
(
)
const
{
if
(
!
isEnabled
(
)
)
{
return
true
;
}
if
(
!
gc
-
>
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
)
{
MOZ_ASSERT
(
currentStartChunk_
=
=
0
)
;
MOZ_ASSERT
(
currentStartPosition_
=
=
chunk
(
0
)
.
start
(
)
)
;
}
return
position
(
)
=
=
currentStartPosition_
;
}
#
ifdef
JS_GC_ZEAL
void
js
:
:
Nursery
:
:
enterZealMode
(
)
{
if
(
isEnabled
(
)
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
if
(
isSubChunkMode
(
)
)
{
decommitTask
.
join
(
)
;
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
chunk
(
0
)
.
markPagesInUseHard
(
ChunkSize
-
ArenaSize
)
)
{
oomUnsafe
.
crash
(
"
Out
of
memory
trying
to
extend
chunk
for
zeal
mode
"
)
;
}
}
chunk
(
0
)
.
poisonRange
(
capacity_
NurseryChunkUsableSize
-
capacity_
JS_FRESH_NURSERY_PATTERN
MemCheckKind
:
:
MakeUndefined
)
;
}
capacity_
=
RoundUp
(
tunables
(
)
.
gcMaxNurseryBytes
(
)
ChunkSize
)
;
setCurrentEnd
(
)
;
}
}
void
js
:
:
Nursery
:
:
leaveZealMode
(
)
{
if
(
isEnabled
(
)
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
setCurrentChunk
(
0
)
;
setStartPosition
(
)
;
poisonAndInitCurrentChunk
(
)
;
}
}
#
endif
JSObject
*
js
:
:
Nursery
:
:
allocateObject
(
JSContext
*
cx
size_t
size
size_t
nDynamicSlots
const
JSClass
*
clasp
)
{
MOZ_ASSERT
(
size
>
=
sizeof
(
RelocationOverlay
)
)
;
MOZ_ASSERT_IF
(
clasp
-
>
hasFinalize
(
)
CanNurseryAllocateFinalizedClass
(
clasp
)
|
|
clasp
-
>
isProxy
(
)
)
;
JSObject
*
obj
=
static_cast
<
JSObject
*
>
(
allocate
(
size
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
HeapSlot
*
slots
=
nullptr
;
if
(
nDynamicSlots
)
{
MOZ_ASSERT
(
clasp
-
>
isNative
(
)
)
;
slots
=
static_cast
<
HeapSlot
*
>
(
allocateBuffer
(
cx
-
>
zone
(
)
nDynamicSlots
*
sizeof
(
HeapSlot
)
)
)
;
if
(
!
slots
)
{
return
nullptr
;
}
}
if
(
nDynamicSlots
)
{
static_cast
<
NativeObject
*
>
(
obj
)
-
>
initSlots
(
slots
)
;
}
gcTracer
.
traceNurseryAlloc
(
obj
size
)
;
return
obj
;
}
Cell
*
js
:
:
Nursery
:
:
allocateString
(
Zone
*
zone
size_t
size
AllocKind
kind
)
{
MOZ_ASSERT
(
size
>
=
sizeof
(
RelocationOverlay
)
)
;
size_t
allocSize
=
RoundUp
(
sizeof
(
StringLayout
)
-
1
+
size
CellAlignBytes
)
;
auto
header
=
static_cast
<
StringLayout
*
>
(
allocate
(
allocSize
)
)
;
if
(
!
header
)
{
return
nullptr
;
}
header
-
>
zone
=
zone
;
auto
cell
=
reinterpret_cast
<
Cell
*
>
(
&
header
-
>
cell
)
;
gcTracer
.
traceNurseryAlloc
(
cell
kind
)
;
return
cell
;
}
void
*
js
:
:
Nursery
:
:
allocate
(
size_t
size
)
{
MOZ_ASSERT
(
isEnabled
(
)
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime
(
)
)
)
;
MOZ_ASSERT_IF
(
currentChunk_
=
=
currentStartChunk_
position
(
)
>
=
currentStartPosition_
)
;
MOZ_ASSERT
(
position
(
)
%
CellAlignBytes
=
=
0
)
;
MOZ_ASSERT
(
size
%
CellAlignBytes
=
=
0
)
;
#
ifdef
JS_GC_ZEAL
static
const
size_t
CanarySize
=
(
sizeof
(
Nursery
:
:
Canary
)
+
CellAlignBytes
-
1
)
&
~
CellAlignMask
;
if
(
gc
-
>
hasZealMode
(
ZealMode
:
:
CheckNursery
)
)
{
size
+
=
CanarySize
;
}
#
endif
if
(
currentEnd
(
)
<
position
(
)
+
size
)
{
unsigned
chunkno
=
currentChunk_
+
1
;
MOZ_ASSERT
(
chunkno
<
=
maxChunkCount
(
)
)
;
MOZ_ASSERT
(
chunkno
<
=
allocatedChunkCount
(
)
)
;
if
(
chunkno
=
=
maxChunkCount
(
)
)
{
return
nullptr
;
}
if
(
MOZ_UNLIKELY
(
chunkno
=
=
allocatedChunkCount
(
)
)
)
{
mozilla
:
:
TimeStamp
start
=
ReallyNow
(
)
;
{
AutoLockGCBgAlloc
lock
(
gc
)
;
if
(
!
allocateNextChunk
(
chunkno
lock
)
)
{
return
nullptr
;
}
}
timeInChunkAlloc_
+
=
ReallyNow
(
)
-
start
;
MOZ_ASSERT
(
chunkno
<
allocatedChunkCount
(
)
)
;
}
setCurrentChunk
(
chunkno
)
;
poisonAndInitCurrentChunk
(
)
;
}
void
*
thing
=
(
void
*
)
position
(
)
;
position_
=
position
(
)
+
size
;
stats
(
)
.
noteNurseryAlloc
(
)
;
DebugOnlyPoison
(
thing
JS_ALLOCATED_NURSERY_PATTERN
size
MemCheckKind
:
:
MakeUndefined
)
;
#
ifdef
JS_GC_ZEAL
if
(
gc
-
>
hasZealMode
(
ZealMode
:
:
CheckNursery
)
)
{
auto
canary
=
reinterpret_cast
<
Canary
*
>
(
position
(
)
-
CanarySize
)
;
canary
-
>
magicValue
=
CanaryMagicValue
;
canary
-
>
next
=
nullptr
;
if
(
lastCanary_
)
{
MOZ_ASSERT
(
!
lastCanary_
-
>
next
)
;
lastCanary_
-
>
next
=
canary
;
}
lastCanary_
=
canary
;
}
#
endif
return
thing
;
}
void
*
js
:
:
Nursery
:
:
allocateBuffer
(
Zone
*
zone
size_t
nbytes
)
{
MOZ_ASSERT
(
nbytes
>
0
)
;
if
(
nbytes
<
=
MaxNurseryBufferSize
)
{
void
*
buffer
=
allocate
(
nbytes
)
;
if
(
buffer
)
{
return
buffer
;
}
}
void
*
buffer
=
zone
-
>
pod_malloc
<
uint8_t
>
(
nbytes
)
;
if
(
buffer
&
&
!
registerMallocedBuffer
(
buffer
)
)
{
js_free
(
buffer
)
;
return
nullptr
;
}
return
buffer
;
}
void
*
js
:
:
Nursery
:
:
allocateBuffer
(
JSObject
*
obj
size_t
nbytes
)
{
MOZ_ASSERT
(
obj
)
;
MOZ_ASSERT
(
nbytes
>
0
)
;
if
(
!
IsInsideNursery
(
obj
)
)
{
return
obj
-
>
zone
(
)
-
>
pod_malloc
<
uint8_t
>
(
nbytes
)
;
}
return
allocateBuffer
(
obj
-
>
zone
(
)
nbytes
)
;
}
void
*
js
:
:
Nursery
:
:
allocateBufferSameLocation
(
JSObject
*
obj
size_t
nbytes
)
{
MOZ_ASSERT
(
obj
)
;
MOZ_ASSERT
(
nbytes
>
0
)
;
MOZ_ASSERT
(
nbytes
<
=
MaxNurseryBufferSize
)
;
if
(
!
IsInsideNursery
(
obj
)
)
{
return
obj
-
>
zone
(
)
-
>
pod_malloc
<
uint8_t
>
(
nbytes
)
;
}
return
allocate
(
nbytes
)
;
}
void
*
js
:
:
Nursery
:
:
allocateZeroedBuffer
(
Zone
*
zone
size_t
nbytes
arena_id_t
arena
)
{
MOZ_ASSERT
(
nbytes
>
0
)
;
if
(
nbytes
<
=
MaxNurseryBufferSize
)
{
void
*
buffer
=
allocate
(
nbytes
)
;
if
(
buffer
)
{
memset
(
buffer
0
nbytes
)
;
return
buffer
;
}
}
void
*
buffer
=
zone
-
>
pod_arena_calloc
<
uint8_t
>
(
arena
nbytes
)
;
if
(
buffer
&
&
!
registerMallocedBuffer
(
buffer
)
)
{
js_free
(
buffer
)
;
return
nullptr
;
}
return
buffer
;
}
void
*
js
:
:
Nursery
:
:
allocateZeroedBuffer
(
JSObject
*
obj
size_t
nbytes
arena_id_t
arena
)
{
MOZ_ASSERT
(
obj
)
;
MOZ_ASSERT
(
nbytes
>
0
)
;
if
(
!
IsInsideNursery
(
obj
)
)
{
return
obj
-
>
zone
(
)
-
>
pod_arena_calloc
<
uint8_t
>
(
arena
nbytes
)
;
}
return
allocateZeroedBuffer
(
obj
-
>
zone
(
)
nbytes
arena
)
;
}
void
*
js
:
:
Nursery
:
:
reallocateBuffer
(
JSObject
*
obj
void
*
oldBuffer
size_t
oldBytes
size_t
newBytes
)
{
if
(
!
IsInsideNursery
(
obj
)
)
{
return
obj
-
>
zone
(
)
-
>
pod_realloc
<
uint8_t
>
(
(
uint8_t
*
)
oldBuffer
oldBytes
newBytes
)
;
}
if
(
!
isInside
(
oldBuffer
)
)
{
void
*
newBuffer
=
obj
-
>
zone
(
)
-
>
pod_realloc
<
uint8_t
>
(
(
uint8_t
*
)
oldBuffer
oldBytes
newBytes
)
;
if
(
newBuffer
&
&
oldBuffer
!
=
newBuffer
)
{
MOZ_ALWAYS_TRUE
(
mallocedBuffers
.
rekeyAs
(
oldBuffer
newBuffer
newBuffer
)
)
;
}
return
newBuffer
;
}
if
(
newBytes
<
oldBytes
)
{
return
oldBuffer
;
}
void
*
newBuffer
=
allocateBuffer
(
obj
-
>
zone
(
)
newBytes
)
;
if
(
newBuffer
)
{
PodCopy
(
(
uint8_t
*
)
newBuffer
(
uint8_t
*
)
oldBuffer
oldBytes
)
;
}
return
newBuffer
;
}
void
js
:
:
Nursery
:
:
freeBuffer
(
void
*
buffer
)
{
if
(
!
isInside
(
buffer
)
)
{
removeMallocedBuffer
(
buffer
)
;
js_free
(
buffer
)
;
}
}
void
Nursery
:
:
setIndirectForwardingPointer
(
void
*
oldData
void
*
newData
)
{
MOZ_ASSERT
(
isInside
(
oldData
)
)
;
MOZ_ASSERT
(
!
isInside
(
newData
)
|
|
(
uintptr_t
(
newData
)
&
ChunkMask
)
=
=
0
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
#
ifdef
DEBUG
if
(
ForwardedBufferMap
:
:
Ptr
p
=
forwardedBuffers
.
lookup
(
oldData
)
)
{
MOZ_ASSERT
(
p
-
>
value
(
)
=
=
newData
)
;
}
#
endif
if
(
!
forwardedBuffers
.
put
(
oldData
newData
)
)
{
oomUnsafe
.
crash
(
"
Nursery
:
:
setForwardingPointer
"
)
;
}
}
#
ifdef
DEBUG
static
bool
IsWriteableAddress
(
void
*
ptr
)
{
volatile
uint64_t
*
vPtr
=
reinterpret_cast
<
volatile
uint64_t
*
>
(
ptr
)
;
*
vPtr
=
*
vPtr
;
return
true
;
}
#
endif
void
js
:
:
Nursery
:
:
forwardBufferPointer
(
HeapSlot
*
*
pSlotsElems
)
{
HeapSlot
*
old
=
*
pSlotsElems
;
if
(
!
isInside
(
old
)
)
{
return
;
}
do
{
if
(
ForwardedBufferMap
:
:
Ptr
p
=
forwardedBuffers
.
lookup
(
old
)
)
{
*
pSlotsElems
=
reinterpret_cast
<
HeapSlot
*
>
(
p
-
>
value
(
)
)
;
break
;
}
*
pSlotsElems
=
*
reinterpret_cast
<
HeapSlot
*
*
>
(
old
)
;
}
while
(
false
)
;
MOZ_ASSERT
(
!
isInside
(
*
pSlotsElems
)
)
;
MOZ_ASSERT
(
IsWriteableAddress
(
*
pSlotsElems
)
)
;
}
js
:
:
TenuringTracer
:
:
TenuringTracer
(
JSRuntime
*
rt
Nursery
*
nursery
)
:
JSTracer
(
rt
JSTracer
:
:
TracerKindTag
:
:
Tenuring
TraceWeakMapKeysValues
)
nursery_
(
*
nursery
)
tenuredSize
(
0
)
tenuredCells
(
0
)
objHead
(
nullptr
)
objTail
(
&
objHead
)
stringHead
(
nullptr
)
stringTail
(
&
stringHead
)
{
}
inline
float
js
:
:
Nursery
:
:
calcPromotionRate
(
bool
*
validForTenuring
)
const
{
float
used
=
float
(
previousGC
.
nurseryUsedBytes
)
;
float
capacity
=
float
(
previousGC
.
nurseryCapacity
)
;
float
tenured
=
float
(
previousGC
.
tenuredBytes
)
;
float
rate
;
if
(
previousGC
.
nurseryUsedBytes
>
0
)
{
if
(
validForTenuring
)
{
*
validForTenuring
=
used
>
capacity
*
0
.
9f
;
}
rate
=
tenured
/
used
;
}
else
{
if
(
validForTenuring
)
{
*
validForTenuring
=
false
;
}
rate
=
0
.
0f
;
}
return
rate
;
}
void
js
:
:
Nursery
:
:
renderProfileJSON
(
JSONPrinter
&
json
)
const
{
if
(
!
isEnabled
(
)
)
{
json
.
beginObject
(
)
;
json
.
property
(
"
status
"
"
nursery
disabled
"
)
;
json
.
endObject
(
)
;
return
;
}
if
(
previousGC
.
reason
=
=
JS
:
:
GCReason
:
:
NO_REASON
)
{
json
.
beginObject
(
)
;
json
.
property
(
"
status
"
"
nursery
empty
"
)
;
json
.
endObject
(
)
;
return
;
}
json
.
beginObject
(
)
;
json
.
property
(
"
status
"
"
complete
"
)
;
json
.
property
(
"
reason
"
JS
:
:
ExplainGCReason
(
previousGC
.
reason
)
)
;
json
.
property
(
"
bytes_tenured
"
previousGC
.
tenuredBytes
)
;
json
.
property
(
"
cells_tenured
"
previousGC
.
tenuredCells
)
;
json
.
property
(
"
strings_tenured
"
stats
(
)
.
getStat
(
gcstats
:
:
STAT_STRINGS_TENURED
)
)
;
json
.
property
(
"
bytes_used
"
previousGC
.
nurseryUsedBytes
)
;
json
.
property
(
"
cur_capacity
"
previousGC
.
nurseryCapacity
)
;
const
size_t
newCapacity
=
capacity
(
)
;
if
(
newCapacity
!
=
previousGC
.
nurseryCapacity
)
{
json
.
property
(
"
new_capacity
"
newCapacity
)
;
}
if
(
previousGC
.
nurseryCommitted
!
=
previousGC
.
nurseryCapacity
)
{
json
.
property
(
"
lazy_capacity
"
previousGC
.
nurseryCommitted
)
;
}
if
(
!
timeInChunkAlloc_
.
IsZero
(
)
)
{
json
.
property
(
"
chunk_alloc_us
"
timeInChunkAlloc_
json
.
MICROSECONDS
)
;
}
if
(
runtime
(
)
-
>
geckoProfiler
(
)
.
enabled
(
)
)
{
json
.
property
(
"
cells_allocated_nursery
"
stats
(
)
.
allocsSinceMinorGCNursery
(
)
)
;
json
.
property
(
"
cells_allocated_tenured
"
stats
(
)
.
allocsSinceMinorGCTenured
(
)
)
;
}
if
(
stats
(
)
.
getStat
(
gcstats
:
:
STAT_OBJECT_GROUPS_PRETENURED
)
)
{
json
.
property
(
"
groups_pretenured
"
stats
(
)
.
getStat
(
gcstats
:
:
STAT_OBJECT_GROUPS_PRETENURED
)
)
;
}
if
(
stats
(
)
.
getStat
(
gcstats
:
:
STAT_NURSERY_STRING_REALMS_DISABLED
)
)
{
json
.
property
(
"
nursery_string_realms_disabled
"
stats
(
)
.
getStat
(
gcstats
:
:
STAT_NURSERY_STRING_REALMS_DISABLED
)
)
;
}
json
.
beginObjectProperty
(
"
phase_times
"
)
;
#
define
EXTRACT_NAME
(
name
text
)
#
name
static
const
char
*
const
names
[
]
=
{
FOR_EACH_NURSERY_PROFILE_TIME
(
EXTRACT_NAME
)
#
undef
EXTRACT_NAME
"
"
}
;
size_t
i
=
0
;
for
(
auto
time
:
profileDurations_
)
{
json
.
property
(
names
[
i
+
+
]
time
json
.
MICROSECONDS
)
;
}
json
.
endObject
(
)
;
json
.
endObject
(
)
;
}
void
js
:
:
Nursery
:
:
printProfileHeader
(
)
{
fprintf
(
stderr
"
MinorGC
:
Reason
PRate
Size
"
)
;
#
define
PRINT_HEADER
(
name
text
)
fprintf
(
stderr
"
%
6s
"
text
)
;
FOR_EACH_NURSERY_PROFILE_TIME
(
PRINT_HEADER
)
#
undef
PRINT_HEADER
fprintf
(
stderr
"
\
n
"
)
;
}
void
js
:
:
Nursery
:
:
printProfileDurations
(
const
ProfileDurations
&
times
)
{
for
(
auto
time
:
times
)
{
fprintf
(
stderr
"
%
6
"
PRIi64
static_cast
<
int64_t
>
(
time
.
ToMicroseconds
(
)
)
)
;
}
fprintf
(
stderr
"
\
n
"
)
;
}
void
js
:
:
Nursery
:
:
printTotalProfileTimes
(
)
{
if
(
enableProfiling_
)
{
fprintf
(
stderr
"
MinorGC
TOTALS
:
%
7
"
PRIu64
"
collections
:
"
gc
-
>
minorGCCount
(
)
)
;
printProfileDurations
(
totalDurations_
)
;
}
}
void
js
:
:
Nursery
:
:
maybeClearProfileDurations
(
)
{
for
(
auto
&
duration
:
profileDurations_
)
{
duration
=
mozilla
:
:
TimeDuration
(
)
;
}
}
inline
void
js
:
:
Nursery
:
:
startProfile
(
ProfileKey
key
)
{
startTimes_
[
key
]
=
ReallyNow
(
)
;
}
inline
void
js
:
:
Nursery
:
:
endProfile
(
ProfileKey
key
)
{
profileDurations_
[
key
]
=
ReallyNow
(
)
-
startTimes_
[
key
]
;
totalDurations_
[
key
]
+
=
profileDurations_
[
key
]
;
}
bool
js
:
:
Nursery
:
:
shouldCollect
(
)
const
{
if
(
isEmpty
(
)
)
{
return
false
;
}
if
(
minorGCRequested
(
)
)
{
return
true
;
}
bool
belowBytesThreshold
=
freeSpace
(
)
<
tunables
(
)
.
nurseryFreeThresholdForIdleCollection
(
)
;
bool
belowFractionThreshold
=
float
(
freeSpace
(
)
)
/
float
(
capacity
(
)
)
<
tunables
(
)
.
nurseryFreeThresholdForIdleCollectionFraction
(
)
;
return
belowBytesThreshold
&
&
belowFractionThreshold
;
}
static
inline
bool
IsFullStoreBufferReason
(
JS
:
:
GCReason
reason
JS
:
:
GCReason
typeReason
)
{
return
reason
=
=
typeReason
|
|
reason
=
=
JS
:
:
GCReason
:
:
FULL_WHOLE_CELL_BUFFER
|
|
reason
=
=
JS
:
:
GCReason
:
:
FULL_GENERIC_BUFFER
|
|
reason
=
=
JS
:
:
GCReason
:
:
FULL_VALUE_BUFFER
|
|
reason
=
=
JS
:
:
GCReason
:
:
FULL_SLOT_BUFFER
|
|
reason
=
=
JS
:
:
GCReason
:
:
FULL_SHAPE_BUFFER
;
}
void
js
:
:
Nursery
:
:
collect
(
JS
:
:
GCReason
reason
)
{
JSRuntime
*
rt
=
runtime
(
)
;
MOZ_ASSERT
(
!
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
;
mozilla
:
:
recordreplay
:
:
AutoDisallowThreadEvents
disallow
;
if
(
!
isEnabled
(
)
|
|
isEmpty
(
)
)
{
gc
-
>
storeBuffer
(
)
.
clear
(
)
;
}
if
(
!
isEnabled
(
)
)
{
return
;
}
#
ifdef
JS_GC_ZEAL
if
(
gc
-
>
hasZealMode
(
ZealMode
:
:
CheckNursery
)
)
{
for
(
auto
canary
=
lastCanary_
;
canary
;
canary
=
canary
-
>
next
)
{
MOZ_ASSERT
(
canary
-
>
magicValue
=
=
CanaryMagicValue
)
;
}
}
lastCanary_
=
nullptr
;
#
endif
stats
(
)
.
beginNurseryCollection
(
reason
)
;
gcTracer
.
traceMinorGCStart
(
)
;
maybeClearProfileDurations
(
)
;
startProfile
(
ProfileKey
:
:
Total
)
;
MOZ_ASSERT
(
!
IsNurseryAllocable
(
AllocKind
:
:
OBJECT_GROUP
)
)
;
TenureCountCache
tenureCounts
;
previousGC
.
reason
=
JS
:
:
GCReason
:
:
NO_REASON
;
if
(
!
isEmpty
(
)
)
{
doCollection
(
reason
tenureCounts
)
;
}
else
{
previousGC
.
nurseryUsedBytes
=
0
;
previousGC
.
nurseryCapacity
=
capacity
(
)
;
previousGC
.
nurseryCommitted
=
committed
(
)
;
previousGC
.
tenuredBytes
=
0
;
previousGC
.
tenuredCells
=
0
;
}
maybeResizeNursery
(
reason
)
;
if
(
isEnabled
(
)
&
&
previousGC
.
nurseryUsedBytes
)
{
poisonAndInitCurrentChunk
(
previousGC
.
nurseryUsedBytes
)
;
}
const
float
promotionRate
=
doPretenuring
(
rt
reason
tenureCounts
)
;
if
(
gc
-
>
heapSize
.
bytes
(
)
>
=
tunables
(
)
.
gcMaxBytes
(
)
)
{
disable
(
)
;
}
endProfile
(
ProfileKey
:
:
Total
)
;
gc
-
>
incMinorGcNumber
(
)
;
TimeDuration
totalTime
=
profileDurations_
[
ProfileKey
:
:
Total
]
;
rt
-
>
addTelemetry
(
JS_TELEMETRY_GC_MINOR_US
totalTime
.
ToMicroseconds
(
)
)
;
rt
-
>
addTelemetry
(
JS_TELEMETRY_GC_MINOR_REASON
uint32_t
(
reason
)
)
;
if
(
totalTime
.
ToMilliseconds
(
)
>
1
.
0
)
{
rt
-
>
addTelemetry
(
JS_TELEMETRY_GC_MINOR_REASON_LONG
uint32_t
(
reason
)
)
;
}
rt
-
>
addTelemetry
(
JS_TELEMETRY_GC_NURSERY_BYTES
committed
(
)
)
;
stats
(
)
.
endNurseryCollection
(
reason
)
;
gcTracer
.
traceMinorGCEnd
(
)
;
timeInChunkAlloc_
=
mozilla
:
:
TimeDuration
(
)
;
if
(
enableProfiling_
&
&
totalTime
>
=
profileThreshold_
)
{
stats
(
)
.
maybePrintProfileHeaders
(
)
;
fprintf
(
stderr
"
MinorGC
:
%
20s
%
5
.
1f
%
%
%
5zu
"
JS
:
:
ExplainGCReason
(
reason
)
promotionRate
*
100
capacity
(
)
/
1024
)
;
printProfileDurations
(
profileDurations_
)
;
if
(
reportTenurings_
)
{
for
(
auto
&
entry
:
tenureCounts
.
entries
)
{
if
(
entry
.
count
>
=
reportTenurings_
)
{
fprintf
(
stderr
"
%
d
x
"
entry
.
count
)
;
AutoSweepObjectGroup
sweep
(
entry
.
group
)
;
entry
.
group
-
>
print
(
sweep
)
;
}
}
}
}
}
void
js
:
:
Nursery
:
:
doCollection
(
JS
:
:
GCReason
reason
TenureCountCache
&
tenureCounts
)
{
JSRuntime
*
rt
=
runtime
(
)
;
AutoGCSession
session
(
gc
JS
:
:
HeapState
:
:
MinorCollecting
)
;
AutoSetThreadIsPerformingGC
performingGC
;
AutoStopVerifyingBarriers
av
(
rt
false
)
;
AutoDisableProxyCheck
disableStrictProxyChecking
;
mozilla
:
:
DebugOnly
<
AutoEnterOOMUnsafeRegion
>
oomUnsafeRegion
;
const
size_t
initialNurseryCapacity
=
capacity
(
)
;
const
size_t
initialNurseryUsedBytes
=
usedSpace
(
)
;
TenuringTracer
mover
(
rt
this
)
;
StoreBuffer
&
sb
=
gc
-
>
storeBuffer
(
)
;
startProfile
(
ProfileKey
:
:
CancelIonCompilations
)
;
if
(
sb
.
cancelIonCompilations
(
)
)
{
js
:
:
CancelOffThreadIonCompilesUsingNurseryPointers
(
rt
)
;
}
endProfile
(
ProfileKey
:
:
CancelIonCompilations
)
;
startProfile
(
ProfileKey
:
:
TraceValues
)
;
sb
.
traceValues
(
mover
)
;
endProfile
(
ProfileKey
:
:
TraceValues
)
;
startProfile
(
ProfileKey
:
:
TraceCells
)
;
sb
.
traceCells
(
mover
)
;
endProfile
(
ProfileKey
:
:
TraceCells
)
;
startProfile
(
ProfileKey
:
:
TraceSlots
)
;
sb
.
traceSlots
(
mover
)
;
endProfile
(
ProfileKey
:
:
TraceSlots
)
;
startProfile
(
ProfileKey
:
:
TraceWholeCells
)
;
sb
.
traceWholeCells
(
mover
)
;
endProfile
(
ProfileKey
:
:
TraceWholeCells
)
;
startProfile
(
ProfileKey
:
:
TraceGenericEntries
)
;
sb
.
traceGenericEntries
(
&
mover
)
;
endProfile
(
ProfileKey
:
:
TraceGenericEntries
)
;
startProfile
(
ProfileKey
:
:
MarkRuntime
)
;
gc
-
>
traceRuntimeForMinorGC
(
&
mover
session
)
;
endProfile
(
ProfileKey
:
:
MarkRuntime
)
;
startProfile
(
ProfileKey
:
:
MarkDebugger
)
;
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_ROOTS
)
;
DebugAPI
:
:
traceAllForMovingGC
(
&
mover
)
;
}
endProfile
(
ProfileKey
:
:
MarkDebugger
)
;
startProfile
(
ProfileKey
:
:
SweepCaches
)
;
gc
-
>
purgeRuntimeForMinorGC
(
)
;
endProfile
(
ProfileKey
:
:
SweepCaches
)
;
startProfile
(
ProfileKey
:
:
CollectToFP
)
;
collectToFixedPoint
(
mover
tenureCounts
)
;
endProfile
(
ProfileKey
:
:
CollectToFP
)
;
startProfile
(
ProfileKey
:
:
Sweep
)
;
sweep
(
&
mover
)
;
endProfile
(
ProfileKey
:
:
Sweep
)
;
startProfile
(
ProfileKey
:
:
UpdateJitActivations
)
;
js
:
:
jit
:
:
UpdateJitActivationsForMinorGC
(
rt
)
;
forwardedBuffers
.
clearAndCompact
(
)
;
endProfile
(
ProfileKey
:
:
UpdateJitActivations
)
;
startProfile
(
ProfileKey
:
:
ObjectsTenuredCallback
)
;
gc
-
>
callObjectsTenuredCallback
(
)
;
endProfile
(
ProfileKey
:
:
ObjectsTenuredCallback
)
;
startProfile
(
ProfileKey
:
:
FreeMallocedBuffers
)
;
gc
-
>
queueBuffersForFreeAfterMinorGC
(
mallocedBuffers
)
;
endProfile
(
ProfileKey
:
:
FreeMallocedBuffers
)
;
startProfile
(
ProfileKey
:
:
ClearNursery
)
;
clear
(
)
;
endProfile
(
ProfileKey
:
:
ClearNursery
)
;
startProfile
(
ProfileKey
:
:
ClearStoreBuffer
)
;
gc
-
>
storeBuffer
(
)
.
clear
(
)
;
endProfile
(
ProfileKey
:
:
ClearStoreBuffer
)
;
startProfile
(
ProfileKey
:
:
CheckHashTables
)
;
#
ifdef
JS_GC_ZEAL
if
(
gc
-
>
hasZealMode
(
ZealMode
:
:
CheckHashTablesOnMinorGC
)
)
{
gc
-
>
checkHashTablesAfterMovingGC
(
)
;
}
#
endif
endProfile
(
ProfileKey
:
:
CheckHashTables
)
;
previousGC
.
reason
=
reason
;
previousGC
.
nurseryCapacity
=
initialNurseryCapacity
;
previousGC
.
nurseryCommitted
=
spaceToEnd
(
allocatedChunkCount
(
)
)
;
previousGC
.
nurseryUsedBytes
=
initialNurseryUsedBytes
;
previousGC
.
tenuredBytes
=
mover
.
tenuredSize
;
previousGC
.
tenuredCells
=
mover
.
tenuredCells
;
}
float
js
:
:
Nursery
:
:
doPretenuring
(
JSRuntime
*
rt
JS
:
:
GCReason
reason
TenureCountCache
&
tenureCounts
)
{
startProfile
(
ProfileKey
:
:
Pretenure
)
;
bool
validPromotionRate
;
const
float
promotionRate
=
calcPromotionRate
(
&
validPromotionRate
)
;
uint32_t
pretenureCount
=
0
;
bool
attempt
=
tunables
(
)
.
attemptPretenuring
(
)
;
bool
pretenureObj
pretenureStr
;
if
(
attempt
)
{
bool
shouldPretenure
=
validPromotionRate
&
&
promotionRate
>
tunables
(
)
.
pretenureThreshold
(
)
&
&
previousGC
.
nurseryUsedBytes
>
=
4
*
1024
*
1024
;
pretenureObj
=
shouldPretenure
|
|
IsFullStoreBufferReason
(
reason
JS
:
:
GCReason
:
:
FULL_CELL_PTR_OBJ_BUFFER
)
;
pretenureStr
=
shouldPretenure
|
|
IsFullStoreBufferReason
(
reason
JS
:
:
GCReason
:
:
FULL_CELL_PTR_STR_BUFFER
)
;
}
else
{
pretenureObj
=
false
;
pretenureStr
=
false
;
}
if
(
pretenureObj
)
{
JSContext
*
cx
=
rt
-
>
mainContextFromOwnThread
(
)
;
uint32_t
threshold
=
tunables
(
)
.
pretenureGroupThreshold
(
)
;
for
(
auto
&
entry
:
tenureCounts
.
entries
)
{
if
(
entry
.
count
<
threshold
)
{
continue
;
}
ObjectGroup
*
group
=
entry
.
group
;
AutoRealm
ar
(
cx
group
)
;
AutoSweepObjectGroup
sweep
(
group
)
;
if
(
group
-
>
canPreTenure
(
sweep
)
)
{
group
-
>
setShouldPreTenure
(
sweep
cx
)
;
pretenureCount
+
+
;
}
}
}
stats
(
)
.
setStat
(
gcstats
:
:
STAT_OBJECT_GROUPS_PRETENURED
pretenureCount
)
;
mozilla
:
:
Maybe
<
AutoGCSession
>
session
;
uint32_t
numStringsTenured
=
0
;
uint32_t
numNurseryStringRealmsDisabled
=
0
;
for
(
ZonesIter
zone
(
gc
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
pretenureStr
&
&
zone
-
>
allocNurseryStrings
&
&
zone
-
>
tenuredStrings
>
=
30
*
1000
)
{
if
(
!
session
.
isSome
(
)
)
{
session
.
emplace
(
gc
JS
:
:
HeapState
:
:
MinorCollecting
)
;
}
CancelOffThreadIonCompile
(
zone
)
;
bool
preserving
=
zone
-
>
isPreservingCode
(
)
;
zone
-
>
setPreservingCode
(
false
)
;
zone
-
>
discardJitCode
(
rt
-
>
defaultFreeOp
(
)
)
;
zone
-
>
setPreservingCode
(
preserving
)
;
for
(
RealmsInZoneIter
r
(
zone
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
if
(
jit
:
:
JitRealm
*
jitRealm
=
r
-
>
jitRealm
(
)
)
{
jitRealm
-
>
discardStubs
(
)
;
jitRealm
-
>
setStringsCanBeInNursery
(
false
)
;
numNurseryStringRealmsDisabled
+
+
;
}
}
zone
-
>
allocNurseryStrings
=
false
;
}
numStringsTenured
+
=
zone
-
>
tenuredStrings
;
zone
-
>
tenuredStrings
=
0
;
}
session
.
reset
(
)
;
stats
(
)
.
setStat
(
gcstats
:
:
STAT_NURSERY_STRING_REALMS_DISABLED
numNurseryStringRealmsDisabled
)
;
stats
(
)
.
setStat
(
gcstats
:
:
STAT_STRINGS_TENURED
numStringsTenured
)
;
endProfile
(
ProfileKey
:
:
Pretenure
)
;
rt
-
>
addTelemetry
(
JS_TELEMETRY_GC_PRETENURE_COUNT
pretenureCount
)
;
rt
-
>
addTelemetry
(
JS_TELEMETRY_GC_NURSERY_PROMOTION_RATE
promotionRate
*
100
)
;
return
promotionRate
;
}
bool
js
:
:
Nursery
:
:
registerMallocedBuffer
(
void
*
buffer
)
{
MOZ_ASSERT
(
buffer
)
;
return
mallocedBuffers
.
putNew
(
buffer
)
;
}
void
js
:
:
Nursery
:
:
sweep
(
JSTracer
*
trc
)
{
for
(
Cell
*
cell
:
cellsWithUid_
)
{
JSObject
*
obj
=
static_cast
<
JSObject
*
>
(
cell
)
;
if
(
!
IsForwarded
(
obj
)
)
{
obj
-
>
zone
(
)
-
>
removeUniqueId
(
obj
)
;
}
else
{
JSObject
*
dst
=
Forwarded
(
obj
)
;
dst
-
>
zone
(
)
-
>
transferUniqueId
(
dst
obj
)
;
}
}
cellsWithUid_
.
clear
(
)
;
for
(
CompartmentsIter
c
(
runtime
(
)
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
c
-
>
sweepAfterMinorGC
(
trc
)
;
}
for
(
ZonesIter
zone
(
trc
-
>
runtime
(
)
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
sweepAfterMinorGC
(
trc
)
;
}
sweepDictionaryModeObjects
(
)
;
sweepMapAndSetObjects
(
)
;
}
void
js
:
:
Nursery
:
:
clear
(
)
{
unsigned
firstClearChunk
;
if
(
gc
-
>
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
)
{
firstClearChunk
=
currentStartChunk_
;
}
else
{
MOZ_ASSERT
(
currentStartChunk_
=
=
0
)
;
firstClearChunk
=
1
;
}
for
(
unsigned
i
=
firstClearChunk
;
i
<
currentChunk_
;
+
+
i
)
{
chunk
(
i
)
.
poisonAfterEvict
(
)
;
}
if
(
currentChunk_
>
=
firstClearChunk
)
{
chunk
(
currentChunk_
)
.
poisonAfterEvict
(
position
(
)
-
chunk
(
currentChunk_
)
.
start
(
)
)
;
}
MOZ_ASSERT
(
maxChunkCount
(
)
>
0
)
;
if
(
!
gc
-
>
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
|
|
(
gc
-
>
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
&
&
currentChunk_
+
1
=
=
maxChunkCount
(
)
)
)
{
setCurrentChunk
(
0
)
;
}
setStartPosition
(
)
;
}
size_t
js
:
:
Nursery
:
:
spaceToEnd
(
unsigned
chunkCount
)
const
{
if
(
chunkCount
=
=
0
)
{
return
0
;
}
unsigned
lastChunk
=
chunkCount
-
1
;
MOZ_ASSERT
(
lastChunk
>
=
currentStartChunk_
)
;
MOZ_ASSERT
(
currentStartPosition_
-
chunk
(
currentStartChunk_
)
.
start
(
)
<
=
NurseryChunkUsableSize
)
;
size_t
bytes
;
if
(
chunkCount
!
=
1
)
{
bytes
=
(
chunk
(
currentStartChunk_
)
.
end
(
)
-
currentStartPosition_
)
+
(
(
lastChunk
-
currentStartChunk_
)
*
ChunkSize
)
;
}
else
{
bytes
=
currentEnd_
-
currentStartPosition_
;
}
MOZ_ASSERT
(
bytes
<
=
maxChunkCount
(
)
*
ChunkSize
)
;
return
bytes
;
}
MOZ_ALWAYS_INLINE
void
js
:
:
Nursery
:
:
setCurrentChunk
(
unsigned
chunkno
)
{
MOZ_ASSERT
(
chunkno
<
allocatedChunkCount
(
)
)
;
currentChunk_
=
chunkno
;
position_
=
chunk
(
chunkno
)
.
start
(
)
;
setCurrentEnd
(
)
;
}
void
js
:
:
Nursery
:
:
poisonAndInitCurrentChunk
(
size_t
extent
)
{
if
(
gc
-
>
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
|
|
!
isSubChunkMode
(
)
)
{
chunk
(
currentChunk_
)
.
poisonAndInit
(
runtime
(
)
)
;
}
else
{
extent
=
std
:
:
min
(
capacity_
extent
)
;
MOZ_ASSERT
(
extent
<
=
NurseryChunkUsableSize
)
;
chunk
(
currentChunk_
)
.
poisonAndInit
(
runtime
(
)
extent
)
;
}
}
MOZ_ALWAYS_INLINE
void
js
:
:
Nursery
:
:
setCurrentEnd
(
)
{
MOZ_ASSERT_IF
(
isSubChunkMode
(
)
currentChunk_
=
=
0
&
&
currentEnd_
<
=
chunk
(
0
)
.
end
(
)
)
;
currentEnd_
=
chunk
(
currentChunk_
)
.
start
(
)
+
std
:
:
min
(
{
capacity_
NurseryChunkUsableSize
}
)
;
if
(
canAllocateStrings_
)
{
currentStringEnd_
=
currentEnd_
;
}
}
bool
js
:
:
Nursery
:
:
allocateNextChunk
(
const
unsigned
chunkno
AutoLockGCBgAlloc
&
lock
)
{
const
unsigned
priorCount
=
allocatedChunkCount
(
)
;
const
unsigned
newCount
=
priorCount
+
1
;
MOZ_ASSERT
(
(
chunkno
=
=
currentChunk_
+
1
)
|
|
(
chunkno
=
=
0
&
&
allocatedChunkCount
(
)
=
=
0
)
)
;
MOZ_ASSERT
(
chunkno
=
=
allocatedChunkCount
(
)
)
;
MOZ_ASSERT
(
chunkno
<
HowMany
(
capacity
(
)
ChunkSize
)
)
;
if
(
!
chunks_
.
resize
(
newCount
)
)
{
return
false
;
}
Chunk
*
newChunk
;
newChunk
=
gc
-
>
getOrAllocChunk
(
lock
)
;
if
(
!
newChunk
)
{
chunks_
.
shrinkTo
(
priorCount
)
;
return
false
;
}
chunks_
[
chunkno
]
=
NurseryChunk
:
:
fromChunk
(
newChunk
)
;
return
true
;
}
MOZ_ALWAYS_INLINE
void
js
:
:
Nursery
:
:
setStartPosition
(
)
{
currentStartChunk_
=
currentChunk_
;
currentStartPosition_
=
position
(
)
;
}
void
js
:
:
Nursery
:
:
maybeResizeNursery
(
JS
:
:
GCReason
reason
)
{
if
(
maybeResizeExact
(
reason
)
)
{
return
;
}
const
float
promotionRate
=
float
(
previousGC
.
tenuredBytes
)
/
float
(
previousGC
.
nurseryCapacity
)
;
static
const
float
GrowThreshold
=
0
.
03f
;
static
const
float
ShrinkThreshold
=
0
.
01f
;
static
const
float
PromotionGoal
=
(
GrowThreshold
+
ShrinkThreshold
)
/
2
.
0f
;
const
float
factor
=
promotionRate
/
PromotionGoal
;
MOZ_ASSERT
(
factor
>
=
0
.
0f
)
;
#
ifdef
DEBUG
static
const
float
SizeMaxPlusOne
=
2
.
0f
*
float
(
1ULL
<
<
(
sizeof
(
void
*
)
*
CHAR_BIT
-
1
)
)
;
MOZ_ASSERT
(
(
float
(
capacity
(
)
)
*
factor
)
<
SizeMaxPlusOne
)
;
#
endif
size_t
newCapacity
=
size_t
(
float
(
capacity
(
)
)
*
factor
)
;
const
size_t
minNurseryBytes
=
roundSize
(
tunables
(
)
.
gcMinNurseryBytes
(
)
)
;
MOZ_ASSERT
(
minNurseryBytes
>
=
ArenaSize
)
;
const
size_t
maxNurseryBytes
=
roundSize
(
tunables
(
)
.
gcMaxNurseryBytes
(
)
)
;
MOZ_ASSERT
(
maxNurseryBytes
>
=
ArenaSize
)
;
size_t
lowLimit
=
std
:
:
max
(
minNurseryBytes
capacity
(
)
/
2
)
;
size_t
highLimit
=
std
:
:
min
(
maxNurseryBytes
(
CheckedInt
<
size_t
>
(
capacity
(
)
)
*
2
)
.
value
(
)
)
;
newCapacity
=
roundSize
(
mozilla
:
:
Clamp
(
newCapacity
lowLimit
highLimit
)
)
;
if
(
capacity
(
)
<
maxNurseryBytes
&
&
promotionRate
>
GrowThreshold
&
&
newCapacity
>
capacity
(
)
)
{
growAllocableSpace
(
newCapacity
)
;
}
else
if
(
capacity
(
)
>
=
minNurseryBytes
+
SubChunkStep
&
&
promotionRate
<
ShrinkThreshold
&
&
newCapacity
<
capacity
(
)
)
{
shrinkAllocableSpace
(
newCapacity
)
;
}
}
bool
js
:
:
Nursery
:
:
maybeResizeExact
(
JS
:
:
GCReason
reason
)
{
if
(
gc
:
:
IsOOMReason
(
reason
)
|
|
gc
-
>
systemHasLowMemory
(
)
)
{
minimizeAllocableSpace
(
)
;
return
true
;
}
#
ifdef
JS_GC_ZEAL
if
(
gc
-
>
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
)
{
return
true
;
}
#
endif
MOZ_ASSERT
(
tunables
(
)
.
gcMaxNurseryBytes
(
)
>
=
ArenaSize
)
;
const
size_t
newMaxNurseryBytes
=
roundSize
(
tunables
(
)
.
gcMaxNurseryBytes
(
)
)
;
MOZ_ASSERT
(
newMaxNurseryBytes
>
=
ArenaSize
)
;
if
(
capacity_
>
newMaxNurseryBytes
)
{
shrinkAllocableSpace
(
newMaxNurseryBytes
)
;
return
true
;
}
const
size_t
newMinNurseryBytes
=
roundSize
(
tunables
(
)
.
gcMinNurseryBytes
(
)
)
;
MOZ_ASSERT
(
newMinNurseryBytes
>
=
ArenaSize
)
;
if
(
newMinNurseryBytes
>
capacity
(
)
)
{
MOZ_ASSERT
(
newMinNurseryBytes
<
=
roundSize
(
tunables
(
)
.
gcMaxNurseryBytes
(
)
)
)
;
growAllocableSpace
(
newMinNurseryBytes
)
;
return
true
;
}
return
false
;
}
size_t
js
:
:
Nursery
:
:
roundSize
(
size_t
size
)
{
if
(
size
>
=
ChunkSize
)
{
size
=
Round
(
size
ChunkSize
)
;
}
else
{
size
=
std
:
:
min
(
Round
(
size
SubChunkStep
)
RoundDown
(
NurseryChunkUsableSize
SubChunkStep
)
)
;
}
MOZ_ASSERT
(
size
>
=
ArenaSize
)
;
return
size
;
}
void
js
:
:
Nursery
:
:
growAllocableSpace
(
size_t
newCapacity
)
{
MOZ_ASSERT_IF
(
!
isSubChunkMode
(
)
newCapacity
>
currentChunk_
*
ChunkSize
)
;
MOZ_ASSERT
(
newCapacity
<
=
roundSize
(
tunables
(
)
.
gcMaxNurseryBytes
(
)
)
)
;
MOZ_ASSERT
(
newCapacity
>
capacity
(
)
)
;
if
(
isSubChunkMode
(
)
)
{
decommitTask
.
join
(
)
;
MOZ_ASSERT
(
currentChunk_
=
=
0
)
;
if
(
!
chunk
(
0
)
.
markPagesInUseHard
(
std
:
:
min
(
newCapacity
ChunkSize
-
ArenaSize
)
)
)
{
return
;
}
size_t
poisonSize
=
std
:
:
min
(
{
newCapacity
NurseryChunkUsableSize
}
)
-
capacity
(
)
;
MOZ_ASSERT
(
capacity
(
)
+
poisonSize
<
=
NurseryChunkUsableSize
)
;
chunk
(
0
)
.
poisonRange
(
capacity
(
)
poisonSize
JS_FRESH_NURSERY_PATTERN
MemCheckKind
:
:
MakeUndefined
)
;
}
capacity_
=
newCapacity
;
setCurrentEnd
(
)
;
}
void
js
:
:
Nursery
:
:
freeChunksFrom
(
const
unsigned
firstFreeChunk
)
{
MOZ_ASSERT
(
firstFreeChunk
<
chunks_
.
length
(
)
)
;
unsigned
firstChunkToDecommit
=
firstFreeChunk
;
if
(
(
firstChunkToDecommit
=
=
0
)
&
&
isSubChunkMode
(
)
)
{
MOZ_ASSERT
(
currentChunk_
=
=
0
)
;
if
(
!
chunk
(
0
)
.
markPagesInUseHard
(
ChunkSize
-
ArenaSize
)
)
{
UnmapPages
(
static_cast
<
void
*
>
(
&
chunk
(
0
)
)
ChunkSize
)
;
firstChunkToDecommit
=
1
;
}
}
{
AutoLockHelperThreadState
lock
;
for
(
size_t
i
=
firstChunkToDecommit
;
i
<
chunks_
.
length
(
)
;
i
+
+
)
{
decommitTask
.
queueChunk
(
chunks_
[
i
]
lock
)
;
}
decommitTask
.
startOrRunIfIdle
(
lock
)
;
}
chunks_
.
shrinkTo
(
firstFreeChunk
)
;
}
void
js
:
:
Nursery
:
:
shrinkAllocableSpace
(
size_t
newCapacity
)
{
#
ifdef
JS_GC_ZEAL
if
(
gc
-
>
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
)
{
return
;
}
#
endif
MOZ_ASSERT
(
newCapacity
!
=
0
)
;
if
(
newCapacity
=
=
capacity_
)
{
return
;
}
MOZ_ASSERT
(
newCapacity
<
capacity_
)
;
unsigned
newCount
=
HowMany
(
newCapacity
ChunkSize
)
;
if
(
newCount
<
allocatedChunkCount
(
)
)
{
freeChunksFrom
(
newCount
)
;
}
size_t
oldCapacity
=
capacity_
;
capacity_
=
newCapacity
;
setCurrentEnd
(
)
;
if
(
isSubChunkMode
(
)
)
{
MOZ_ASSERT
(
currentChunk_
=
=
0
)
;
chunk
(
0
)
.
poisonRange
(
newCapacity
std
:
:
min
(
{
oldCapacity
NurseryChunkUsableSize
}
)
-
newCapacity
JS_SWEPT_NURSERY_PATTERN
MemCheckKind
:
:
MakeNoAccess
)
;
AutoLockHelperThreadState
lock
;
decommitTask
.
queueRange
(
capacity_
chunk
(
0
)
lock
)
;
decommitTask
.
startOrRunIfIdle
(
lock
)
;
}
}
void
js
:
:
Nursery
:
:
minimizeAllocableSpace
(
)
{
if
(
capacity_
<
roundSize
(
tunables
(
)
.
gcMinNurseryBytes
(
)
)
)
{
return
;
}
shrinkAllocableSpace
(
roundSize
(
tunables
(
)
.
gcMinNurseryBytes
(
)
)
)
;
}
bool
js
:
:
Nursery
:
:
queueDictionaryModeObjectToSweep
(
NativeObject
*
obj
)
{
MOZ_ASSERT
(
IsInsideNursery
(
obj
)
)
;
return
dictionaryModeObjects_
.
append
(
obj
)
;
}
uintptr_t
js
:
:
Nursery
:
:
currentEnd
(
)
const
{
MOZ_ASSERT_IF
(
isSubChunkMode
(
)
currentChunk_
=
=
0
)
;
MOZ_ASSERT_IF
(
isSubChunkMode
(
)
currentEnd_
<
=
chunk
(
currentChunk_
)
.
end
(
)
)
;
MOZ_ASSERT_IF
(
!
isSubChunkMode
(
)
currentEnd_
=
=
chunk
(
currentChunk_
)
.
end
(
)
)
;
MOZ_ASSERT
(
currentEnd_
!
=
chunk
(
currentChunk_
)
.
start
(
)
)
;
return
currentEnd_
;
}
gcstats
:
:
Statistics
&
js
:
:
Nursery
:
:
stats
(
)
const
{
return
gc
-
>
stats
(
)
;
}
MOZ_ALWAYS_INLINE
const
js
:
:
gc
:
:
GCSchedulingTunables
&
js
:
:
Nursery
:
:
tunables
(
)
const
{
return
gc
-
>
tunables
;
}
bool
js
:
:
Nursery
:
:
isSubChunkMode
(
)
const
{
return
capacity
(
)
<
=
NurseryChunkUsableSize
;
}
void
js
:
:
Nursery
:
:
sweepDictionaryModeObjects
(
)
{
for
(
auto
obj
:
dictionaryModeObjects_
)
{
if
(
!
IsForwarded
(
obj
)
)
{
obj
-
>
sweepDictionaryListPointer
(
)
;
}
else
{
Forwarded
(
obj
)
-
>
updateDictionaryListPointerAfterMinorGC
(
obj
)
;
}
}
dictionaryModeObjects_
.
clear
(
)
;
}
void
js
:
:
Nursery
:
:
sweepMapAndSetObjects
(
)
{
auto
fop
=
runtime
(
)
-
>
defaultFreeOp
(
)
;
for
(
auto
mapobj
:
mapsWithNurseryMemory_
)
{
MapObject
:
:
sweepAfterMinorGC
(
fop
mapobj
)
;
}
mapsWithNurseryMemory_
.
clearAndFree
(
)
;
for
(
auto
setobj
:
setsWithNurseryMemory_
)
{
SetObject
:
:
sweepAfterMinorGC
(
fop
setobj
)
;
}
setsWithNurseryMemory_
.
clearAndFree
(
)
;
}
JS_PUBLIC_API
void
JS
:
:
EnableNurseryStrings
(
JSContext
*
cx
)
{
AutoEmptyNursery
empty
(
cx
)
;
ReleaseAllJITCode
(
cx
-
>
defaultFreeOp
(
)
)
;
cx
-
>
runtime
(
)
-
>
gc
.
nursery
(
)
.
enableStrings
(
)
;
}
JS_PUBLIC_API
void
JS
:
:
DisableNurseryStrings
(
JSContext
*
cx
)
{
AutoEmptyNursery
empty
(
cx
)
;
ReleaseAllJITCode
(
cx
-
>
defaultFreeOp
(
)
)
;
cx
-
>
runtime
(
)
-
>
gc
.
nursery
(
)
.
disableStrings
(
)
;
}
