#
ifndef
gc_Barrier_h
#
define
gc_Barrier_h
#
include
"
NamespaceImports
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
gc
/
StoreBuffer
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
class
JSAtom
;
struct
JSCompartment
;
class
JSFlatString
;
class
JSLinearString
;
namespace
JS
{
class
Symbol
;
}
namespace
js
{
class
AccessorShape
;
class
ArrayObject
;
class
ArgumentsObject
;
class
ArrayBufferObjectMaybeShared
;
class
ArrayBufferObject
;
class
ArrayBufferViewObject
;
class
SharedArrayBufferObject
;
class
BaseShape
;
class
DebugScopeObject
;
class
GlobalObject
;
class
LazyScript
;
class
ModuleObject
;
class
ModuleEnvironmentObject
;
class
ModuleNamespaceObject
;
class
NativeObject
;
class
NestedScopeObject
;
class
PlainObject
;
class
PropertyName
;
class
SavedFrame
;
class
ScopeObject
;
class
ScriptSourceObject
;
class
Shape
;
class
UnownedBaseShape
;
class
ObjectGroup
;
namespace
jit
{
class
JitCode
;
}
#
ifdef
DEBUG
bool
CurrentThreadIsIonCompiling
(
)
;
bool
CurrentThreadIsIonCompilingSafeForMinorGC
(
)
;
bool
CurrentThreadIsGCSweeping
(
)
;
bool
CurrentThreadCanSkipPostBarrier
(
bool
inNursery
)
;
#
endif
namespace
gc
{
void
MarkValueForBarrier
(
JSTracer
*
trc
Value
*
v
const
char
*
name
)
;
void
MarkIdForBarrier
(
JSTracer
*
trc
jsid
*
idp
const
char
*
name
)
;
}
template
<
typename
T
>
struct
InternalBarrierMethods
{
}
;
template
<
typename
T
>
struct
InternalBarrierMethods
<
T
*
>
{
static
bool
isMarkable
(
T
*
v
)
{
return
v
!
=
nullptr
;
}
static
bool
isMarkableTaggedPointer
(
T
*
v
)
{
return
!
IsNullTaggedPointer
(
v
)
;
}
static
void
preBarrier
(
T
*
v
)
{
T
:
:
writeBarrierPre
(
v
)
;
}
static
void
postBarrier
(
T
*
*
vp
T
*
prev
T
*
next
)
{
T
:
:
writeBarrierPost
(
vp
prev
next
)
;
}
static
void
readBarrier
(
T
*
v
)
{
T
:
:
readBarrier
(
v
)
;
}
static
bool
isInsideNursery
(
T
*
v
)
{
return
IsInsideNursery
(
v
)
;
}
}
;
template
<
typename
S
>
struct
PreBarrierFunctor
:
public
VoidDefaultAdaptor
<
S
>
{
template
<
typename
T
>
void
operator
(
)
(
T
*
t
)
;
}
;
template
<
typename
S
>
struct
ReadBarrierFunctor
:
public
VoidDefaultAdaptor
<
S
>
{
template
<
typename
T
>
void
operator
(
)
(
T
*
t
)
;
}
;
template
<
>
struct
InternalBarrierMethods
<
Value
>
{
static
bool
isMarkable
(
Value
v
)
{
return
v
.
isMarkable
(
)
;
}
static
bool
isMarkableTaggedPointer
(
Value
v
)
{
return
isMarkable
(
v
)
;
}
static
void
preBarrier
(
Value
v
)
{
DispatchTyped
(
PreBarrierFunctor
<
Value
>
(
)
v
)
;
}
static
void
postBarrier
(
Value
*
vp
const
Value
&
prev
const
Value
&
next
)
{
MOZ_ASSERT
(
!
CurrentThreadIsIonCompiling
(
)
)
;
MOZ_ASSERT
(
vp
)
;
js
:
:
gc
:
:
StoreBuffer
*
sb
;
if
(
next
.
isObject
(
)
&
&
(
sb
=
reinterpret_cast
<
gc
:
:
Cell
*
>
(
&
next
.
toObject
(
)
)
-
>
storeBuffer
(
)
)
)
{
if
(
prev
.
isObject
(
)
&
&
reinterpret_cast
<
gc
:
:
Cell
*
>
(
&
prev
.
toObject
(
)
)
-
>
storeBuffer
(
)
)
return
;
sb
-
>
putValue
(
vp
)
;
return
;
}
if
(
prev
.
isObject
(
)
&
&
(
sb
=
reinterpret_cast
<
gc
:
:
Cell
*
>
(
&
prev
.
toObject
(
)
)
-
>
storeBuffer
(
)
)
)
sb
-
>
unputValue
(
vp
)
;
}
static
void
readBarrier
(
const
Value
&
v
)
{
DispatchTyped
(
ReadBarrierFunctor
<
Value
>
(
)
v
)
;
}
static
bool
isInsideNursery
(
const
Value
&
v
)
{
return
v
.
isMarkable
(
)
&
&
IsInsideNursery
(
v
.
toGCThing
(
)
)
;
}
}
;
template
<
>
struct
InternalBarrierMethods
<
jsid
>
{
static
bool
isMarkable
(
jsid
id
)
{
return
JSID_IS_STRING
(
id
)
|
|
JSID_IS_SYMBOL
(
id
)
;
}
static
bool
isMarkableTaggedPointer
(
jsid
id
)
{
return
isMarkable
(
id
)
;
}
static
void
preBarrier
(
jsid
id
)
{
DispatchTyped
(
PreBarrierFunctor
<
jsid
>
(
)
id
)
;
}
static
void
postBarrier
(
jsid
*
idp
jsid
prev
jsid
next
)
{
}
static
bool
isInsideNursery
(
jsid
id
)
{
return
false
;
}
}
;
template
<
typename
T
>
class
BarrieredBaseMixins
{
}
;
template
<
typename
T
>
class
BarrieredBase
:
public
BarrieredBaseMixins
<
T
>
{
protected
:
explicit
BarrieredBase
(
T
v
)
:
value
(
v
)
{
}
T
value
;
public
:
T
*
unsafeUnbarrieredForTracing
(
)
{
return
&
value
;
}
}
;
template
<
class
T
>
class
WriteBarrieredBase
:
public
BarrieredBase
<
T
>
{
protected
:
explicit
WriteBarrieredBase
(
T
v
)
:
BarrieredBase
<
T
>
(
v
)
{
}
public
:
DECLARE_POINTER_COMPARISON_OPS
(
T
)
;
DECLARE_POINTER_CONSTREF_OPS
(
T
)
;
const
T
&
get
(
)
const
{
return
this
-
>
value
;
}
void
unsafeSet
(
T
v
)
{
this
-
>
value
=
v
;
}
static
void
writeBarrierPre
(
const
T
&
v
)
{
InternalBarrierMethods
<
T
>
:
:
preBarrier
(
v
)
;
}
protected
:
void
pre
(
)
{
InternalBarrierMethods
<
T
>
:
:
preBarrier
(
this
-
>
value
)
;
}
void
post
(
T
prev
T
next
)
{
InternalBarrierMethods
<
T
>
:
:
postBarrier
(
&
this
-
>
value
prev
next
)
;
}
}
;
template
<
class
T
>
class
PreBarriered
:
public
WriteBarrieredBase
<
T
>
{
public
:
PreBarriered
(
)
:
WriteBarrieredBase
<
T
>
(
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
)
{
}
MOZ_IMPLICIT
PreBarriered
(
T
v
)
:
WriteBarrieredBase
<
T
>
(
v
)
{
}
explicit
PreBarriered
(
const
PreBarriered
<
T
>
&
v
)
:
WriteBarrieredBase
<
T
>
(
v
.
value
)
{
}
~
PreBarriered
(
)
{
this
-
>
pre
(
)
;
}
void
init
(
T
v
)
{
this
-
>
value
=
v
;
}
void
clear
(
)
{
this
-
>
pre
(
)
;
this
-
>
value
=
nullptr
;
}
DECLARE_POINTER_ASSIGN_OPS
(
PreBarriered
T
)
;
private
:
void
set
(
const
T
&
v
)
{
this
-
>
pre
(
)
;
this
-
>
value
=
v
;
}
}
;
template
<
class
T
>
class
GCPtr
:
public
WriteBarrieredBase
<
T
>
{
public
:
GCPtr
(
)
:
WriteBarrieredBase
<
T
>
(
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
)
{
}
explicit
GCPtr
(
T
v
)
:
WriteBarrieredBase
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
v
)
;
}
explicit
GCPtr
(
const
GCPtr
<
T
>
&
v
)
:
WriteBarrieredBase
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
v
)
;
}
#
ifdef
DEBUG
~
GCPtr
(
)
{
bool
inNursery
=
InternalBarrierMethods
<
T
>
:
:
isInsideNursery
(
this
-
>
value
)
;
MOZ_ASSERT
(
CurrentThreadIsGCSweeping
(
)
|
|
CurrentThreadCanSkipPostBarrier
(
inNursery
)
)
;
Poison
(
this
JS_FREED_HEAP_PTR_PATTERN
sizeof
(
*
this
)
)
;
}
#
endif
void
init
(
T
v
)
{
this
-
>
value
=
v
;
this
-
>
post
(
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
v
)
;
}
DECLARE_POINTER_ASSIGN_OPS
(
GCPtr
T
)
;
T
unbarrieredGet
(
)
const
{
return
this
-
>
value
;
}
private
:
void
set
(
const
T
&
v
)
{
this
-
>
pre
(
)
;
T
tmp
=
this
-
>
value
;
this
-
>
value
=
v
;
this
-
>
post
(
tmp
this
-
>
value
)
;
}
GCPtr
(
GCPtr
<
T
>
&
&
)
=
delete
;
GCPtr
<
T
>
&
operator
=
(
GCPtr
<
T
>
&
&
)
=
delete
;
}
;
template
<
class
T
>
class
HeapPtr
:
public
WriteBarrieredBase
<
T
>
{
public
:
HeapPtr
(
)
:
WriteBarrieredBase
<
T
>
(
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
)
{
}
MOZ_IMPLICIT
HeapPtr
(
const
T
&
v
)
:
WriteBarrieredBase
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
this
-
>
value
)
;
}
MOZ_IMPLICIT
HeapPtr
(
const
HeapPtr
<
T
>
&
v
)
:
WriteBarrieredBase
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
this
-
>
value
)
;
}
~
HeapPtr
(
)
{
this
-
>
pre
(
)
;
this
-
>
post
(
this
-
>
value
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
)
;
}
void
init
(
T
v
)
{
this
-
>
value
=
v
;
this
-
>
post
(
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
this
-
>
value
)
;
}
DECLARE_POINTER_ASSIGN_OPS
(
HeapPtr
T
)
;
template
<
class
T1
class
T2
>
friend
inline
void
BarrieredSetPair
(
Zone
*
zone
HeapPtr
<
T1
*
>
&
v1
T1
*
val1
HeapPtr
<
T2
*
>
&
v2
T2
*
val2
)
;
protected
:
void
set
(
const
T
&
v
)
{
this
-
>
pre
(
)
;
postBarrieredSet
(
v
)
;
}
void
postBarrieredSet
(
const
T
&
v
)
{
T
tmp
=
this
-
>
value
;
this
-
>
value
=
v
;
this
-
>
post
(
tmp
this
-
>
value
)
;
}
}
;
template
<
typename
T
>
class
ReadBarrieredBase
:
public
BarrieredBase
<
T
>
{
protected
:
explicit
ReadBarrieredBase
(
T
v
)
:
BarrieredBase
<
T
>
(
v
)
{
}
protected
:
void
read
(
)
const
{
InternalBarrierMethods
<
T
>
:
:
readBarrier
(
this
-
>
value
)
;
}
void
post
(
T
prev
T
next
)
{
InternalBarrierMethods
<
T
>
:
:
postBarrier
(
&
this
-
>
value
prev
next
)
;
}
}
;
template
<
typename
T
>
class
ReadBarriered
:
public
ReadBarrieredBase
<
T
>
{
public
:
ReadBarriered
(
)
:
ReadBarrieredBase
<
T
>
(
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
)
{
}
MOZ_IMPLICIT
ReadBarriered
(
const
T
&
v
)
:
ReadBarrieredBase
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
v
)
;
}
explicit
ReadBarriered
(
const
ReadBarriered
&
v
)
:
ReadBarrieredBase
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
v
.
get
(
)
)
;
}
ReadBarriered
(
ReadBarriered
&
&
v
)
:
ReadBarrieredBase
<
T
>
(
mozilla
:
:
Forward
<
ReadBarriered
<
T
>
>
(
v
)
)
{
this
-
>
post
(
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
v
.
value
)
;
}
~
ReadBarriered
(
)
{
this
-
>
post
(
this
-
>
value
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
)
;
}
ReadBarriered
&
operator
=
(
const
ReadBarriered
&
v
)
{
T
prior
=
this
-
>
value
;
this
-
>
value
=
v
.
value
;
this
-
>
post
(
prior
v
.
value
)
;
return
*
this
;
}
const
T
get
(
)
const
{
if
(
!
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
this
-
>
value
)
)
return
JS
:
:
GCPolicy
<
T
>
:
:
initial
(
)
;
this
-
>
read
(
)
;
return
this
-
>
value
;
}
const
T
unbarrieredGet
(
)
const
{
return
this
-
>
value
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
this
-
>
value
)
;
}
operator
const
T
(
)
const
{
return
get
(
)
;
}
const
T
operator
-
>
(
)
const
{
return
get
(
)
;
}
T
*
unsafeGet
(
)
{
return
&
this
-
>
value
;
}
T
const
*
unsafeGet
(
)
const
{
return
&
this
-
>
value
;
}
void
set
(
const
T
&
v
)
{
T
tmp
=
this
-
>
value
;
this
-
>
value
=
v
;
this
-
>
post
(
tmp
v
)
;
}
}
;
template
<
typename
T
>
using
WeakRef
=
ReadBarriered
<
T
>
;
template
<
>
class
BarrieredBaseMixins
<
JS
:
:
Value
>
:
public
ValueOperations
<
WriteBarrieredBase
<
JS
:
:
Value
>
>
{
}
;
class
HeapSlot
:
public
WriteBarrieredBase
<
Value
>
{
public
:
enum
Kind
{
Slot
=
0
Element
=
1
}
;
explicit
HeapSlot
(
)
=
delete
;
explicit
HeapSlot
(
NativeObject
*
obj
Kind
kind
uint32_t
slot
const
Value
&
v
)
:
WriteBarrieredBase
<
Value
>
(
v
)
{
post
(
obj
kind
slot
v
)
;
}
explicit
HeapSlot
(
NativeObject
*
obj
Kind
kind
uint32_t
slot
const
HeapSlot
&
s
)
:
WriteBarrieredBase
<
Value
>
(
s
.
value
)
{
post
(
obj
kind
slot
s
)
;
}
~
HeapSlot
(
)
{
pre
(
)
;
}
void
init
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
v
)
{
value
=
v
;
post
(
owner
kind
slot
v
)
;
}
#
ifdef
DEBUG
bool
preconditionForSet
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
)
const
;
bool
preconditionForWriteBarrierPost
(
NativeObject
*
obj
Kind
kind
uint32_t
slot
const
Value
&
target
)
const
;
#
endif
void
set
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
v
)
{
MOZ_ASSERT
(
preconditionForSet
(
owner
kind
slot
)
)
;
pre
(
)
;
value
=
v
;
post
(
owner
kind
slot
v
)
;
}
static
void
writeBarrierPost
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
target
)
{
reinterpret_cast
<
HeapSlot
*
>
(
const_cast
<
Value
*
>
(
&
target
)
)
-
>
post
(
owner
kind
slot
target
)
;
}
private
:
void
post
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
target
)
{
MOZ_ASSERT
(
preconditionForWriteBarrierPost
(
owner
kind
slot
target
)
)
;
if
(
this
-
>
value
.
isObject
(
)
)
{
gc
:
:
Cell
*
cell
=
reinterpret_cast
<
gc
:
:
Cell
*
>
(
&
this
-
>
value
.
toObject
(
)
)
;
if
(
cell
-
>
storeBuffer
(
)
)
cell
-
>
storeBuffer
(
)
-
>
putSlot
(
owner
kind
slot
1
)
;
}
}
}
;
class
HeapSlotArray
{
HeapSlot
*
array
;
#
ifdef
DEBUG
bool
allowWrite_
;
#
endif
public
:
explicit
HeapSlotArray
(
HeapSlot
*
array
bool
allowWrite
)
:
array
(
array
)
#
ifdef
DEBUG
allowWrite_
(
allowWrite
)
#
endif
{
}
operator
const
Value
*
(
)
const
{
JS_STATIC_ASSERT
(
sizeof
(
GCPtr
<
Value
>
)
=
=
sizeof
(
Value
)
)
;
JS_STATIC_ASSERT
(
sizeof
(
HeapSlot
)
=
=
sizeof
(
Value
)
)
;
return
reinterpret_cast
<
const
Value
*
>
(
array
)
;
}
operator
HeapSlot
*
(
)
const
{
MOZ_ASSERT
(
allowWrite
(
)
)
;
return
array
;
}
HeapSlotArray
operator
+
(
int
offset
)
const
{
return
HeapSlotArray
(
array
+
offset
allowWrite
(
)
)
;
}
HeapSlotArray
operator
+
(
uint32_t
offset
)
const
{
return
HeapSlotArray
(
array
+
offset
allowWrite
(
)
)
;
}
private
:
bool
allowWrite
(
)
const
{
#
ifdef
DEBUG
return
allowWrite_
;
#
else
return
true
;
#
endif
}
}
;
template
<
class
T1
class
T2
>
static
inline
void
BarrieredSetPair
(
Zone
*
zone
HeapPtr
<
T1
*
>
&
v1
T1
*
val1
HeapPtr
<
T2
*
>
&
v2
T2
*
val2
)
{
if
(
T1
:
:
needWriteBarrierPre
(
zone
)
)
{
v1
.
pre
(
)
;
v2
.
pre
(
)
;
}
v1
.
postBarrieredSet
(
val1
)
;
v2
.
postBarrieredSet
(
val2
)
;
}
template
<
typename
T
>
class
ImmutableTenuredPtr
{
T
value
;
public
:
operator
T
(
)
const
{
return
value
;
}
T
operator
-
>
(
)
const
{
return
value
;
}
operator
Handle
<
T
>
(
)
const
{
return
Handle
<
T
>
:
:
fromMarkedLocation
(
&
value
)
;
}
void
init
(
T
ptr
)
{
MOZ_ASSERT
(
ptr
-
>
isTenured
(
)
)
;
value
=
ptr
;
}
T
get
(
)
const
{
return
value
;
}
const
T
*
address
(
)
{
return
&
value
;
}
}
;
template
<
typename
T
>
struct
MovableCellHasher
<
PreBarriered
<
T
>
>
{
using
Key
=
PreBarriered
<
T
>
;
using
Lookup
=
T
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hasHash
(
l
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
ensureHash
(
l
)
;
}
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
match
(
k
l
)
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unsafeSet
(
newKey
)
;
}
}
;
template
<
typename
T
>
struct
MovableCellHasher
<
HeapPtr
<
T
>
>
{
using
Key
=
HeapPtr
<
T
>
;
using
Lookup
=
T
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hasHash
(
l
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
ensureHash
(
l
)
;
}
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
match
(
k
l
)
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unsafeSet
(
newKey
)
;
}
}
;
template
<
typename
T
>
struct
MovableCellHasher
<
ReadBarriered
<
T
>
>
{
using
Key
=
ReadBarriered
<
T
>
;
using
Lookup
=
T
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hasHash
(
l
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
ensureHash
(
l
)
;
}
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
match
(
k
.
unbarrieredGet
(
)
l
)
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unsafeSet
(
newKey
)
;
}
}
;
template
<
class
T
>
struct
GCPtrHasher
{
typedef
GCPtr
<
T
>
Key
;
typedef
T
Lookup
;
static
HashNumber
hash
(
Lookup
obj
)
{
return
DefaultHasher
<
T
>
:
:
hash
(
obj
)
;
}
static
bool
match
(
const
Key
&
k
Lookup
l
)
{
return
k
.
get
(
)
=
=
l
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unsafeSet
(
newKey
)
;
}
}
;
template
<
class
T
>
struct
DefaultHasher
<
GCPtr
<
T
>
>
:
GCPtrHasher
<
T
>
{
}
;
template
<
class
T
>
struct
PreBarrieredHasher
{
typedef
PreBarriered
<
T
>
Key
;
typedef
T
Lookup
;
static
HashNumber
hash
(
Lookup
obj
)
{
return
DefaultHasher
<
T
>
:
:
hash
(
obj
)
;
}
static
bool
match
(
const
Key
&
k
Lookup
l
)
{
return
k
.
get
(
)
=
=
l
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unsafeSet
(
newKey
)
;
}
}
;
template
<
class
T
>
struct
DefaultHasher
<
PreBarriered
<
T
>
>
:
PreBarrieredHasher
<
T
>
{
}
;
template
<
class
T
>
struct
ReadBarrieredHasher
{
typedef
ReadBarriered
<
T
>
Key
;
typedef
T
Lookup
;
static
HashNumber
hash
(
Lookup
obj
)
{
return
DefaultHasher
<
T
>
:
:
hash
(
obj
)
;
}
static
bool
match
(
const
Key
&
k
Lookup
l
)
{
return
k
.
unbarrieredGet
(
)
=
=
l
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
set
(
newKey
.
unbarrieredGet
(
)
)
;
}
}
;
template
<
class
T
>
struct
DefaultHasher
<
ReadBarriered
<
T
>
>
:
ReadBarrieredHasher
<
T
>
{
}
;
class
ArrayObject
;
class
ArrayBufferObject
;
class
NestedScopeObject
;
class
DebugScopeObject
;
class
GlobalObject
;
class
ScriptSourceObject
;
class
Shape
;
class
BaseShape
;
class
UnownedBaseShape
;
class
WasmInstanceObject
;
namespace
jit
{
class
JitCode
;
}
typedef
PreBarriered
<
JSObject
*
>
PreBarrieredObject
;
typedef
PreBarriered
<
JSScript
*
>
PreBarrieredScript
;
typedef
PreBarriered
<
jit
:
:
JitCode
*
>
PreBarrieredJitCode
;
typedef
PreBarriered
<
JSString
*
>
PreBarrieredString
;
typedef
PreBarriered
<
JSAtom
*
>
PreBarrieredAtom
;
typedef
GCPtr
<
NativeObject
*
>
GCPtrNativeObject
;
typedef
GCPtr
<
ArrayObject
*
>
GCPtrArrayObject
;
typedef
GCPtr
<
ArrayBufferObjectMaybeShared
*
>
GCPtrArrayBufferObjectMaybeShared
;
typedef
GCPtr
<
ArrayBufferObject
*
>
GCPtrArrayBufferObject
;
typedef
GCPtr
<
BaseShape
*
>
GCPtrBaseShape
;
typedef
GCPtr
<
JSAtom
*
>
GCPtrAtom
;
typedef
GCPtr
<
JSFlatString
*
>
GCPtrFlatString
;
typedef
GCPtr
<
JSFunction
*
>
GCPtrFunction
;
typedef
GCPtr
<
JSLinearString
*
>
GCPtrLinearString
;
typedef
GCPtr
<
JSObject
*
>
GCPtrObject
;
typedef
GCPtr
<
JSScript
*
>
GCPtrScript
;
typedef
GCPtr
<
JSString
*
>
GCPtrString
;
typedef
GCPtr
<
ModuleObject
*
>
GCPtrModuleObject
;
typedef
GCPtr
<
ModuleEnvironmentObject
*
>
GCPtrModuleEnvironmentObject
;
typedef
GCPtr
<
ModuleNamespaceObject
*
>
GCPtrModuleNamespaceObject
;
typedef
GCPtr
<
PlainObject
*
>
GCPtrPlainObject
;
typedef
GCPtr
<
PropertyName
*
>
GCPtrPropertyName
;
typedef
GCPtr
<
Shape
*
>
GCPtrShape
;
typedef
GCPtr
<
UnownedBaseShape
*
>
GCPtrUnownedBaseShape
;
typedef
GCPtr
<
jit
:
:
JitCode
*
>
GCPtrJitCode
;
typedef
GCPtr
<
ObjectGroup
*
>
GCPtrObjectGroup
;
typedef
PreBarriered
<
Value
>
PreBarrieredValue
;
typedef
GCPtr
<
Value
>
GCPtrValue
;
typedef
PreBarriered
<
jsid
>
PreBarrieredId
;
typedef
GCPtr
<
jsid
>
GCPtrId
;
typedef
ImmutableTenuredPtr
<
PropertyName
*
>
ImmutablePropertyNamePtr
;
typedef
ImmutableTenuredPtr
<
JS
:
:
Symbol
*
>
ImmutableSymbolPtr
;
typedef
ReadBarriered
<
DebugScopeObject
*
>
ReadBarrieredDebugScopeObject
;
typedef
ReadBarriered
<
GlobalObject
*
>
ReadBarrieredGlobalObject
;
typedef
ReadBarriered
<
JSObject
*
>
ReadBarrieredObject
;
typedef
ReadBarriered
<
JSFunction
*
>
ReadBarrieredFunction
;
typedef
ReadBarriered
<
JSScript
*
>
ReadBarrieredScript
;
typedef
ReadBarriered
<
ScriptSourceObject
*
>
ReadBarrieredScriptSourceObject
;
typedef
ReadBarriered
<
Shape
*
>
ReadBarrieredShape
;
typedef
ReadBarriered
<
jit
:
:
JitCode
*
>
ReadBarrieredJitCode
;
typedef
ReadBarriered
<
ObjectGroup
*
>
ReadBarrieredObjectGroup
;
typedef
ReadBarriered
<
JS
:
:
Symbol
*
>
ReadBarrieredSymbol
;
typedef
ReadBarriered
<
WasmInstanceObject
*
>
ReadBarrieredWasmInstanceObject
;
typedef
ReadBarriered
<
Value
>
ReadBarrieredValue
;
}
#
endif
