#
ifndef
gc_Barrier_h
#
define
gc_Barrier_h
#
include
"
NamespaceImports
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
gc
/
StoreBuffer
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
class
JSAtom
;
struct
JSCompartment
;
class
JSFlatString
;
class
JSLinearString
;
namespace
JS
{
class
Symbol
;
}
namespace
js
{
class
AccessorShape
;
class
ArrayObject
;
class
ArgumentsObject
;
class
ArrayBufferObjectMaybeShared
;
class
ArrayBufferObject
;
class
ArrayBufferViewObject
;
class
SharedArrayBufferObject
;
class
BaseShape
;
class
DebugScopeObject
;
class
GlobalObject
;
class
LazyScript
;
class
ModuleEnvironmentObject
;
class
ModuleNamespaceObject
;
class
NativeObject
;
class
NestedScopeObject
;
class
PlainObject
;
class
PropertyName
;
class
SavedFrame
;
class
ScopeObject
;
class
ScriptSourceObject
;
class
Shape
;
class
UnownedBaseShape
;
class
ObjectGroup
;
namespace
jit
{
class
JitCode
;
}
#
ifdef
DEBUG
bool
CurrentThreadIsIonCompiling
(
)
;
bool
CurrentThreadIsIonCompilingSafeForMinorGC
(
)
;
bool
CurrentThreadIsGCSweeping
(
)
;
bool
CurrentThreadIsHandlingInitFailure
(
)
;
#
endif
namespace
gc
{
void
MarkValueForBarrier
(
JSTracer
*
trc
Value
*
v
const
char
*
name
)
;
void
MarkIdForBarrier
(
JSTracer
*
trc
jsid
*
idp
const
char
*
name
)
;
}
template
<
typename
T
>
struct
InternalGCMethods
{
}
;
template
<
typename
T
>
struct
InternalGCMethods
<
T
*
>
{
static
bool
isMarkable
(
T
*
v
)
{
return
v
!
=
nullptr
;
}
static
bool
isMarkableTaggedPointer
(
T
*
v
)
{
return
!
IsNullTaggedPointer
(
v
)
;
}
static
void
preBarrier
(
T
*
v
)
{
T
:
:
writeBarrierPre
(
v
)
;
}
static
void
postBarrier
(
T
*
*
vp
T
*
prev
T
*
next
)
{
T
:
:
writeBarrierPost
(
vp
prev
next
)
;
}
static
void
readBarrier
(
T
*
v
)
{
T
:
:
readBarrier
(
v
)
;
}
}
;
template
<
typename
S
>
struct
PreBarrierFunctor
:
VoidDefaultAdaptor
<
S
>
{
template
<
typename
T
>
void
operator
(
)
(
T
*
t
)
;
}
;
template
<
typename
S
>
struct
ReadBarrierFunctor
:
public
VoidDefaultAdaptor
<
S
>
{
template
<
typename
T
>
void
operator
(
)
(
T
*
t
)
;
}
;
template
<
>
struct
InternalGCMethods
<
Value
>
{
static
bool
isMarkable
(
Value
v
)
{
return
v
.
isMarkable
(
)
;
}
static
bool
isMarkableTaggedPointer
(
Value
v
)
{
return
isMarkable
(
v
)
;
}
static
void
preBarrier
(
Value
v
)
{
DispatchTyped
(
PreBarrierFunctor
<
Value
>
(
)
v
)
;
}
static
void
postBarrier
(
Value
*
vp
const
Value
&
prev
const
Value
&
next
)
{
MOZ_ASSERT
(
!
CurrentThreadIsIonCompiling
(
)
)
;
MOZ_ASSERT
(
vp
)
;
js
:
:
gc
:
:
StoreBuffer
*
sb
;
if
(
next
.
isObject
(
)
&
&
(
sb
=
reinterpret_cast
<
gc
:
:
Cell
*
>
(
&
next
.
toObject
(
)
)
-
>
storeBuffer
(
)
)
)
{
if
(
prev
.
isObject
(
)
&
&
reinterpret_cast
<
gc
:
:
Cell
*
>
(
&
prev
.
toObject
(
)
)
-
>
storeBuffer
(
)
)
return
;
sb
-
>
putValue
(
vp
)
;
return
;
}
if
(
prev
.
isObject
(
)
&
&
(
sb
=
reinterpret_cast
<
gc
:
:
Cell
*
>
(
&
prev
.
toObject
(
)
)
-
>
storeBuffer
(
)
)
)
sb
-
>
unputValue
(
vp
)
;
}
static
void
readBarrier
(
const
Value
&
v
)
{
DispatchTyped
(
ReadBarrierFunctor
<
Value
>
(
)
v
)
;
}
}
;
template
<
>
struct
InternalGCMethods
<
jsid
>
{
static
bool
isMarkable
(
jsid
id
)
{
return
JSID_IS_STRING
(
id
)
|
|
JSID_IS_SYMBOL
(
id
)
;
}
static
bool
isMarkableTaggedPointer
(
jsid
id
)
{
return
isMarkable
(
id
)
;
}
static
void
preBarrier
(
jsid
id
)
{
DispatchTyped
(
PreBarrierFunctor
<
jsid
>
(
)
id
)
;
}
static
void
postBarrier
(
jsid
*
idp
jsid
prev
jsid
next
)
{
}
}
;
template
<
typename
T
>
class
BarrieredBaseMixins
{
}
;
template
<
typename
T
>
class
BarrieredBase
:
public
BarrieredBaseMixins
<
T
>
{
protected
:
explicit
BarrieredBase
(
T
v
)
:
value
(
v
)
{
#
ifdef
DEBUG
assertTypeConstraints
(
)
;
#
endif
}
T
value
;
public
:
T
*
unsafeUnbarrieredForTracing
(
)
{
return
&
value
;
}
private
:
#
ifdef
DEBUG
void
assertTypeConstraints
(
)
const
;
#
endif
}
;
template
<
class
T
>
class
WriteBarrieredBase
:
public
BarrieredBase
<
T
>
{
protected
:
explicit
WriteBarrieredBase
(
T
v
)
:
BarrieredBase
<
T
>
(
v
)
{
}
public
:
DECLARE_POINTER_COMPARISON_OPS
(
T
)
;
DECLARE_POINTER_CONSTREF_OPS
(
T
)
;
const
T
&
get
(
)
const
{
return
this
-
>
value
;
}
void
unsafeSet
(
T
v
)
{
this
-
>
value
=
v
;
}
static
void
writeBarrierPre
(
const
T
&
v
)
{
InternalGCMethods
<
T
>
:
:
preBarrier
(
v
)
;
}
protected
:
void
pre
(
)
{
InternalGCMethods
<
T
>
:
:
preBarrier
(
this
-
>
value
)
;
}
void
post
(
T
prev
T
next
)
{
InternalGCMethods
<
T
>
:
:
postBarrier
(
&
this
-
>
value
prev
next
)
;
}
}
;
template
<
class
T
>
class
PreBarriered
:
public
WriteBarrieredBase
<
T
>
{
public
:
PreBarriered
(
)
:
WriteBarrieredBase
<
T
>
(
GCMethods
<
T
>
:
:
initial
(
)
)
{
}
MOZ_IMPLICIT
PreBarriered
(
T
v
)
:
WriteBarrieredBase
<
T
>
(
v
)
{
}
explicit
PreBarriered
(
const
PreBarriered
<
T
>
&
v
)
:
WriteBarrieredBase
<
T
>
(
v
.
value
)
{
}
~
PreBarriered
(
)
{
this
-
>
pre
(
)
;
}
void
init
(
T
v
)
{
this
-
>
value
=
v
;
}
void
clear
(
)
{
this
-
>
pre
(
)
;
this
-
>
value
=
nullptr
;
}
DECLARE_POINTER_ASSIGN_OPS
(
PreBarriered
T
)
;
private
:
void
set
(
const
T
&
v
)
{
this
-
>
pre
(
)
;
this
-
>
value
=
v
;
}
}
;
template
<
class
T
>
class
HeapPtr
:
public
WriteBarrieredBase
<
T
>
{
public
:
HeapPtr
(
)
:
WriteBarrieredBase
<
T
>
(
GCMethods
<
T
>
:
:
initial
(
)
)
{
}
explicit
HeapPtr
(
T
v
)
:
WriteBarrieredBase
<
T
>
(
v
)
{
this
-
>
post
(
GCMethods
<
T
>
:
:
initial
(
)
v
)
;
}
explicit
HeapPtr
(
const
HeapPtr
<
T
>
&
v
)
:
WriteBarrieredBase
<
T
>
(
v
)
{
this
-
>
post
(
GCMethods
<
T
>
:
:
initial
(
)
v
)
;
}
#
ifdef
DEBUG
~
HeapPtr
(
)
{
MOZ_ASSERT
(
CurrentThreadIsGCSweeping
(
)
|
|
CurrentThreadIsHandlingInitFailure
(
)
)
;
}
#
endif
void
init
(
T
v
)
{
this
-
>
value
=
v
;
this
-
>
post
(
GCMethods
<
T
>
:
:
initial
(
)
v
)
;
}
DECLARE_POINTER_ASSIGN_OPS
(
HeapPtr
T
)
;
T
unbarrieredGet
(
)
const
{
return
this
-
>
value
;
}
private
:
void
set
(
const
T
&
v
)
{
this
-
>
pre
(
)
;
T
tmp
=
this
-
>
value
;
this
-
>
value
=
v
;
this
-
>
post
(
tmp
this
-
>
value
)
;
}
HeapPtr
(
HeapPtr
<
T
>
&
&
)
=
delete
;
HeapPtr
<
T
>
&
operator
=
(
HeapPtr
<
T
>
&
&
)
=
delete
;
}
;
template
<
class
T
>
class
RelocatablePtr
:
public
WriteBarrieredBase
<
T
>
{
public
:
RelocatablePtr
(
)
:
WriteBarrieredBase
<
T
>
(
GCMethods
<
T
>
:
:
initial
(
)
)
{
}
MOZ_IMPLICIT
RelocatablePtr
(
const
T
&
v
)
:
WriteBarrieredBase
<
T
>
(
v
)
{
this
-
>
post
(
GCMethods
<
T
>
:
:
initial
(
)
this
-
>
value
)
;
}
MOZ_IMPLICIT
RelocatablePtr
(
const
RelocatablePtr
<
T
>
&
v
)
:
WriteBarrieredBase
<
T
>
(
v
)
{
this
-
>
post
(
GCMethods
<
T
>
:
:
initial
(
)
this
-
>
value
)
;
}
~
RelocatablePtr
(
)
{
this
-
>
pre
(
)
;
this
-
>
post
(
this
-
>
value
GCMethods
<
T
>
:
:
initial
(
)
)
;
}
void
init
(
T
v
)
{
this
-
>
value
=
v
;
this
-
>
post
(
GCMethods
<
T
>
:
:
initial
(
)
this
-
>
value
)
;
}
DECLARE_POINTER_ASSIGN_OPS
(
RelocatablePtr
T
)
;
template
<
class
T1
class
T2
>
friend
inline
void
BarrieredSetPair
(
Zone
*
zone
RelocatablePtr
<
T1
*
>
&
v1
T1
*
val1
RelocatablePtr
<
T2
*
>
&
v2
T2
*
val2
)
;
protected
:
void
set
(
const
T
&
v
)
{
this
-
>
pre
(
)
;
postBarrieredSet
(
v
)
;
}
void
postBarrieredSet
(
const
T
&
v
)
{
T
tmp
=
this
-
>
value
;
this
-
>
value
=
v
;
this
-
>
post
(
tmp
this
-
>
value
)
;
}
}
;
template
<
typename
T
>
class
ReadBarrieredBase
:
public
BarrieredBase
<
T
>
{
protected
:
explicit
ReadBarrieredBase
(
T
v
)
:
BarrieredBase
<
T
>
(
v
)
{
}
protected
:
void
read
(
)
const
{
InternalGCMethods
<
T
>
:
:
readBarrier
(
this
-
>
value
)
;
}
void
post
(
T
prev
T
next
)
{
InternalGCMethods
<
T
>
:
:
postBarrier
(
&
this
-
>
value
prev
next
)
;
}
}
;
template
<
typename
T
>
class
ReadBarriered
:
public
ReadBarrieredBase
<
T
>
{
public
:
ReadBarriered
(
)
:
ReadBarrieredBase
<
T
>
(
GCMethods
<
T
>
:
:
initial
(
)
)
{
}
MOZ_IMPLICIT
ReadBarriered
(
const
T
&
v
)
:
ReadBarrieredBase
<
T
>
(
v
)
{
this
-
>
post
(
GCMethods
<
T
>
:
:
initial
(
)
v
)
;
}
explicit
ReadBarriered
(
const
ReadBarriered
&
v
)
:
ReadBarrieredBase
<
T
>
(
v
)
{
this
-
>
post
(
GCMethods
<
T
>
:
:
initial
(
)
v
.
get
(
)
)
;
}
ReadBarriered
(
ReadBarriered
&
&
v
)
:
ReadBarrieredBase
<
T
>
(
mozilla
:
:
Forward
<
ReadBarriered
<
T
>
>
(
v
)
)
{
this
-
>
post
(
GCMethods
<
T
>
:
:
initial
(
)
v
.
value
)
;
}
~
ReadBarriered
(
)
{
this
-
>
post
(
this
-
>
value
GCMethods
<
T
>
:
:
initial
(
)
)
;
}
ReadBarriered
&
operator
=
(
const
ReadBarriered
&
v
)
{
T
prior
=
this
-
>
value
;
this
-
>
value
=
v
.
value
;
this
-
>
post
(
prior
v
.
value
)
;
return
*
this
;
}
const
T
get
(
)
const
{
if
(
!
InternalGCMethods
<
T
>
:
:
isMarkable
(
this
-
>
value
)
)
return
GCMethods
<
T
>
:
:
initial
(
)
;
this
-
>
read
(
)
;
return
this
-
>
value
;
}
const
T
unbarrieredGet
(
)
const
{
return
this
-
>
value
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
this
-
>
value
)
;
}
operator
const
T
(
)
const
{
return
get
(
)
;
}
const
T
operator
-
>
(
)
const
{
return
get
(
)
;
}
T
*
unsafeGet
(
)
{
return
&
this
-
>
value
;
}
T
const
*
unsafeGet
(
)
const
{
return
&
this
-
>
value
;
}
void
set
(
const
T
&
v
)
{
T
tmp
=
this
-
>
value
;
this
-
>
value
=
v
;
this
-
>
post
(
tmp
v
)
;
}
}
;
template
<
typename
T
>
using
WeakRef
=
ReadBarriered
<
T
>
;
template
<
>
class
BarrieredBaseMixins
<
JS
:
:
Value
>
:
public
ValueOperations
<
WriteBarrieredBase
<
JS
:
:
Value
>
>
{
}
;
class
HeapSlot
:
public
WriteBarrieredBase
<
Value
>
{
public
:
enum
Kind
{
Slot
=
0
Element
=
1
}
;
explicit
HeapSlot
(
)
=
delete
;
explicit
HeapSlot
(
NativeObject
*
obj
Kind
kind
uint32_t
slot
const
Value
&
v
)
:
WriteBarrieredBase
<
Value
>
(
v
)
{
post
(
obj
kind
slot
v
)
;
}
explicit
HeapSlot
(
NativeObject
*
obj
Kind
kind
uint32_t
slot
const
HeapSlot
&
s
)
:
WriteBarrieredBase
<
Value
>
(
s
.
value
)
{
post
(
obj
kind
slot
s
)
;
}
~
HeapSlot
(
)
{
pre
(
)
;
}
void
init
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
v
)
{
value
=
v
;
post
(
owner
kind
slot
v
)
;
}
#
ifdef
DEBUG
bool
preconditionForSet
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
)
;
bool
preconditionForWriteBarrierPost
(
NativeObject
*
obj
Kind
kind
uint32_t
slot
Value
target
)
const
;
#
endif
void
set
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
v
)
{
MOZ_ASSERT
(
preconditionForSet
(
owner
kind
slot
)
)
;
pre
(
)
;
value
=
v
;
post
(
owner
kind
slot
v
)
;
}
static
void
writeBarrierPost
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
target
)
{
reinterpret_cast
<
HeapSlot
*
>
(
const_cast
<
Value
*
>
(
&
target
)
)
-
>
post
(
owner
kind
slot
target
)
;
}
private
:
void
post
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
target
)
{
MOZ_ASSERT
(
preconditionForWriteBarrierPost
(
owner
kind
slot
target
)
)
;
if
(
this
-
>
value
.
isObject
(
)
)
{
gc
:
:
Cell
*
cell
=
reinterpret_cast
<
gc
:
:
Cell
*
>
(
&
this
-
>
value
.
toObject
(
)
)
;
if
(
cell
-
>
storeBuffer
(
)
)
cell
-
>
storeBuffer
(
)
-
>
putSlot
(
owner
kind
slot
1
)
;
}
}
}
;
class
HeapSlotArray
{
HeapSlot
*
array
;
#
ifdef
DEBUG
bool
allowWrite_
;
#
endif
public
:
explicit
HeapSlotArray
(
HeapSlot
*
array
bool
allowWrite
)
:
array
(
array
)
#
ifdef
DEBUG
allowWrite_
(
allowWrite
)
#
endif
{
}
operator
const
Value
*
(
)
const
{
JS_STATIC_ASSERT
(
sizeof
(
HeapPtr
<
Value
>
)
=
=
sizeof
(
Value
)
)
;
JS_STATIC_ASSERT
(
sizeof
(
HeapSlot
)
=
=
sizeof
(
Value
)
)
;
return
reinterpret_cast
<
const
Value
*
>
(
array
)
;
}
operator
HeapSlot
*
(
)
const
{
MOZ_ASSERT
(
allowWrite
(
)
)
;
return
array
;
}
HeapSlotArray
operator
+
(
int
offset
)
const
{
return
HeapSlotArray
(
array
+
offset
allowWrite
(
)
)
;
}
HeapSlotArray
operator
+
(
uint32_t
offset
)
const
{
return
HeapSlotArray
(
array
+
offset
allowWrite
(
)
)
;
}
private
:
bool
allowWrite
(
)
const
{
#
ifdef
DEBUG
return
allowWrite_
;
#
else
return
true
;
#
endif
}
}
;
template
<
class
T1
class
T2
>
static
inline
void
BarrieredSetPair
(
Zone
*
zone
RelocatablePtr
<
T1
*
>
&
v1
T1
*
val1
RelocatablePtr
<
T2
*
>
&
v2
T2
*
val2
)
{
if
(
T1
:
:
needWriteBarrierPre
(
zone
)
)
{
v1
.
pre
(
)
;
v2
.
pre
(
)
;
}
v1
.
postBarrieredSet
(
val1
)
;
v2
.
postBarrieredSet
(
val2
)
;
}
template
<
typename
T
>
class
ImmutableTenuredPtr
{
T
value
;
public
:
operator
T
(
)
const
{
return
value
;
}
T
operator
-
>
(
)
const
{
return
value
;
}
operator
Handle
<
T
>
(
)
const
{
return
Handle
<
T
>
:
:
fromMarkedLocation
(
&
value
)
;
}
void
init
(
T
ptr
)
{
MOZ_ASSERT
(
ptr
-
>
isTenured
(
)
)
;
value
=
ptr
;
}
T
get
(
)
const
{
return
value
;
}
const
T
*
address
(
)
{
return
&
value
;
}
}
;
template
<
typename
T
>
struct
MovableCellHasher
<
PreBarriered
<
T
>
>
{
using
Key
=
PreBarriered
<
T
>
;
using
Lookup
=
T
;
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
match
(
k
l
)
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unsafeSet
(
newKey
)
;
}
}
;
template
<
typename
T
>
struct
MovableCellHasher
<
RelocatablePtr
<
T
>
>
{
using
Key
=
RelocatablePtr
<
T
>
;
using
Lookup
=
T
;
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
match
(
k
l
)
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unsafeSet
(
newKey
)
;
}
}
;
template
<
typename
T
>
struct
MovableCellHasher
<
ReadBarriered
<
T
>
>
{
using
Key
=
ReadBarriered
<
T
>
;
using
Lookup
=
T
;
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
match
(
k
.
unbarrieredGet
(
)
l
)
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unsafeSet
(
newKey
)
;
}
}
;
template
<
class
T
>
struct
HeapPtrHasher
{
typedef
HeapPtr
<
T
>
Key
;
typedef
T
Lookup
;
static
HashNumber
hash
(
Lookup
obj
)
{
return
DefaultHasher
<
T
>
:
:
hash
(
obj
)
;
}
static
bool
match
(
const
Key
&
k
Lookup
l
)
{
return
k
.
get
(
)
=
=
l
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unsafeSet
(
newKey
)
;
}
}
;
template
<
class
T
>
struct
DefaultHasher
<
HeapPtr
<
T
>
>
:
HeapPtrHasher
<
T
>
{
}
;
template
<
class
T
>
struct
PreBarrieredHasher
{
typedef
PreBarriered
<
T
>
Key
;
typedef
T
Lookup
;
static
HashNumber
hash
(
Lookup
obj
)
{
return
DefaultHasher
<
T
>
:
:
hash
(
obj
)
;
}
static
bool
match
(
const
Key
&
k
Lookup
l
)
{
return
k
.
get
(
)
=
=
l
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unsafeSet
(
newKey
)
;
}
}
;
template
<
class
T
>
struct
DefaultHasher
<
PreBarriered
<
T
>
>
:
PreBarrieredHasher
<
T
>
{
}
;
template
<
class
T
>
struct
ReadBarrieredHasher
{
typedef
ReadBarriered
<
T
>
Key
;
typedef
T
Lookup
;
static
HashNumber
hash
(
Lookup
obj
)
{
return
DefaultHasher
<
T
>
:
:
hash
(
obj
)
;
}
static
bool
match
(
const
Key
&
k
Lookup
l
)
{
return
k
.
unbarrieredGet
(
)
=
=
l
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
set
(
newKey
.
unbarrieredGet
(
)
)
;
}
}
;
template
<
class
T
>
struct
DefaultHasher
<
ReadBarriered
<
T
>
>
:
ReadBarrieredHasher
<
T
>
{
}
;
class
ArrayObject
;
class
ArrayBufferObject
;
class
NestedScopeObject
;
class
DebugScopeObject
;
class
GlobalObject
;
class
ScriptSourceObject
;
class
Shape
;
class
BaseShape
;
class
UnownedBaseShape
;
namespace
jit
{
class
JitCode
;
}
typedef
PreBarriered
<
JSObject
*
>
PreBarrieredObject
;
typedef
PreBarriered
<
JSScript
*
>
PreBarrieredScript
;
typedef
PreBarriered
<
jit
:
:
JitCode
*
>
PreBarrieredJitCode
;
typedef
PreBarriered
<
JSString
*
>
PreBarrieredString
;
typedef
PreBarriered
<
JSAtom
*
>
PreBarrieredAtom
;
typedef
RelocatablePtr
<
JSObject
*
>
RelocatablePtrObject
;
typedef
RelocatablePtr
<
JSFunction
*
>
RelocatablePtrFunction
;
typedef
RelocatablePtr
<
PlainObject
*
>
RelocatablePtrPlainObject
;
typedef
RelocatablePtr
<
JSScript
*
>
RelocatablePtrScript
;
typedef
RelocatablePtr
<
NativeObject
*
>
RelocatablePtrNativeObject
;
typedef
RelocatablePtr
<
NestedScopeObject
*
>
RelocatablePtrNestedScopeObject
;
typedef
RelocatablePtr
<
Shape
*
>
RelocatablePtrShape
;
typedef
RelocatablePtr
<
ObjectGroup
*
>
RelocatablePtrObjectGroup
;
typedef
RelocatablePtr
<
jit
:
:
JitCode
*
>
RelocatablePtrJitCode
;
typedef
RelocatablePtr
<
JSLinearString
*
>
RelocatablePtrLinearString
;
typedef
RelocatablePtr
<
JSString
*
>
RelocatablePtrString
;
typedef
RelocatablePtr
<
JSAtom
*
>
RelocatablePtrAtom
;
typedef
RelocatablePtr
<
ArrayBufferObjectMaybeShared
*
>
RelocatablePtrArrayBufferObjectMaybeShared
;
typedef
HeapPtr
<
NativeObject
*
>
HeapPtrNativeObject
;
typedef
HeapPtr
<
ArrayObject
*
>
HeapPtrArrayObject
;
typedef
HeapPtr
<
ArrayBufferObjectMaybeShared
*
>
HeapPtrArrayBufferObjectMaybeShared
;
typedef
HeapPtr
<
ArrayBufferObject
*
>
HeapPtrArrayBufferObject
;
typedef
HeapPtr
<
BaseShape
*
>
HeapPtrBaseShape
;
typedef
HeapPtr
<
JSAtom
*
>
HeapPtrAtom
;
typedef
HeapPtr
<
JSFlatString
*
>
HeapPtrFlatString
;
typedef
HeapPtr
<
JSFunction
*
>
HeapPtrFunction
;
typedef
HeapPtr
<
JSLinearString
*
>
HeapPtrLinearString
;
typedef
HeapPtr
<
JSObject
*
>
HeapPtrObject
;
typedef
HeapPtr
<
JSScript
*
>
HeapPtrScript
;
typedef
HeapPtr
<
JSString
*
>
HeapPtrString
;
typedef
HeapPtr
<
ModuleEnvironmentObject
*
>
HeapPtrModuleEnvironmentObject
;
typedef
HeapPtr
<
ModuleNamespaceObject
*
>
HeapPtrModuleNamespaceObject
;
typedef
HeapPtr
<
PlainObject
*
>
HeapPtrPlainObject
;
typedef
HeapPtr
<
PropertyName
*
>
HeapPtrPropertyName
;
typedef
HeapPtr
<
Shape
*
>
HeapPtrShape
;
typedef
HeapPtr
<
UnownedBaseShape
*
>
HeapPtrUnownedBaseShape
;
typedef
HeapPtr
<
jit
:
:
JitCode
*
>
HeapPtrJitCode
;
typedef
HeapPtr
<
ObjectGroup
*
>
HeapPtrObjectGroup
;
typedef
PreBarriered
<
Value
>
PreBarrieredValue
;
typedef
RelocatablePtr
<
Value
>
RelocatableValue
;
typedef
HeapPtr
<
Value
>
HeapValue
;
typedef
PreBarriered
<
jsid
>
PreBarrieredId
;
typedef
RelocatablePtr
<
jsid
>
RelocatableId
;
typedef
HeapPtr
<
jsid
>
HeapId
;
typedef
ImmutableTenuredPtr
<
PropertyName
*
>
ImmutablePropertyNamePtr
;
typedef
ImmutableTenuredPtr
<
JS
:
:
Symbol
*
>
ImmutableSymbolPtr
;
typedef
ReadBarriered
<
DebugScopeObject
*
>
ReadBarrieredDebugScopeObject
;
typedef
ReadBarriered
<
GlobalObject
*
>
ReadBarrieredGlobalObject
;
typedef
ReadBarriered
<
JSObject
*
>
ReadBarrieredObject
;
typedef
ReadBarriered
<
JSScript
*
>
ReadBarrieredScript
;
typedef
ReadBarriered
<
ScriptSourceObject
*
>
ReadBarrieredScriptSourceObject
;
typedef
ReadBarriered
<
Shape
*
>
ReadBarrieredShape
;
typedef
ReadBarriered
<
jit
:
:
JitCode
*
>
ReadBarrieredJitCode
;
typedef
ReadBarriered
<
ObjectGroup
*
>
ReadBarrieredObjectGroup
;
typedef
ReadBarriered
<
JS
:
:
Symbol
*
>
ReadBarrieredSymbol
;
typedef
ReadBarriered
<
Value
>
ReadBarrieredValue
;
}
#
endif
