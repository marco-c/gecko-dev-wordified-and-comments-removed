#
ifndef
gc_Barrier_h
#
define
gc_Barrier_h
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
<
type_traits
>
#
include
"
NamespaceImports
.
h
"
#
include
"
gc
/
Cell
.
h
"
#
include
"
gc
/
StoreBuffer
.
h
"
#
include
"
js
/
ComparisonOperators
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
util
/
Poison
.
h
"
namespace
js
{
class
NativeObject
;
namespace
gc
{
void
ValueReadBarrier
(
const
Value
&
v
)
;
void
ValuePreWriteBarrier
(
const
Value
&
v
)
;
void
IdPreWriteBarrier
(
jsid
id
)
;
void
CellPtrPreWriteBarrier
(
JS
:
:
GCCellPtr
thing
)
;
}
#
ifdef
DEBUG
bool
CurrentThreadIsTouchingGrayThings
(
)
;
bool
IsMarkedBlack
(
JSObject
*
obj
)
;
#
endif
struct
MOZ_RAII
AutoTouchingGrayThings
{
#
ifdef
DEBUG
AutoTouchingGrayThings
(
)
;
~
AutoTouchingGrayThings
(
)
;
#
else
AutoTouchingGrayThings
(
)
{
}
#
endif
}
;
template
<
typename
T
>
struct
InternalBarrierMethods
{
}
;
template
<
typename
T
>
struct
InternalBarrierMethods
<
T
*
>
{
static
bool
isMarkable
(
const
T
*
v
)
{
return
v
!
=
nullptr
;
}
static
void
preBarrier
(
T
*
v
)
{
gc
:
:
PreWriteBarrier
(
v
)
;
}
static
void
postBarrier
(
T
*
*
vp
T
*
prev
T
*
next
)
{
gc
:
:
PostWriteBarrier
(
vp
prev
next
)
;
}
static
void
readBarrier
(
T
*
v
)
{
gc
:
:
ReadBarrier
(
v
)
;
}
#
ifdef
DEBUG
static
void
assertThingIsNotGray
(
T
*
v
)
{
return
T
:
:
assertThingIsNotGray
(
v
)
;
}
#
endif
}
;
template
<
>
struct
InternalBarrierMethods
<
Value
>
{
static
bool
isMarkable
(
const
Value
&
v
)
{
return
v
.
isGCThing
(
)
;
}
static
void
preBarrier
(
const
Value
&
v
)
{
if
(
v
.
isGCThing
(
)
)
{
gc
:
:
ValuePreWriteBarrier
(
v
)
;
}
}
static
MOZ_ALWAYS_INLINE
void
postBarrier
(
Value
*
vp
const
Value
&
prev
const
Value
&
next
)
{
MOZ_ASSERT
(
!
CurrentThreadIsIonCompiling
(
)
)
;
MOZ_ASSERT
(
vp
)
;
js
:
:
gc
:
:
StoreBuffer
*
sb
;
if
(
(
next
.
isObject
(
)
|
|
next
.
isString
(
)
|
|
next
.
isBigInt
(
)
)
&
&
(
sb
=
next
.
toGCThing
(
)
-
>
storeBuffer
(
)
)
)
{
if
(
(
prev
.
isObject
(
)
|
|
prev
.
isString
(
)
|
|
prev
.
isBigInt
(
)
)
&
&
prev
.
toGCThing
(
)
-
>
storeBuffer
(
)
)
{
return
;
}
sb
-
>
putValue
(
vp
)
;
return
;
}
if
(
(
prev
.
isObject
(
)
|
|
prev
.
isString
(
)
|
|
prev
.
isBigInt
(
)
)
&
&
(
sb
=
prev
.
toGCThing
(
)
-
>
storeBuffer
(
)
)
)
{
sb
-
>
unputValue
(
vp
)
;
}
}
static
void
readBarrier
(
const
Value
&
v
)
{
if
(
v
.
isGCThing
(
)
)
{
gc
:
:
ValueReadBarrier
(
v
)
;
}
}
#
ifdef
DEBUG
static
void
assertThingIsNotGray
(
const
Value
&
v
)
{
JS
:
:
AssertValueIsNotGray
(
v
)
;
}
#
endif
}
;
template
<
>
struct
InternalBarrierMethods
<
jsid
>
{
static
bool
isMarkable
(
jsid
id
)
{
return
id
.
isGCThing
(
)
;
}
static
void
preBarrier
(
jsid
id
)
{
if
(
id
.
isGCThing
(
)
)
{
gc
:
:
IdPreWriteBarrier
(
id
)
;
}
}
static
void
postBarrier
(
jsid
*
idp
jsid
prev
jsid
next
)
{
}
#
ifdef
DEBUG
static
void
assertThingIsNotGray
(
jsid
id
)
{
JS
:
:
AssertIdIsNotGray
(
id
)
;
}
#
endif
}
;
template
<
typename
T
>
static
inline
void
AssertTargetIsNotGray
(
const
T
&
v
)
{
#
ifdef
DEBUG
if
(
!
CurrentThreadIsTouchingGrayThings
(
)
)
{
InternalBarrierMethods
<
T
>
:
:
assertThingIsNotGray
(
v
)
;
}
#
endif
}
template
<
typename
T
>
class
MOZ_NON_MEMMOVABLE
BarrieredBase
{
protected
:
explicit
BarrieredBase
(
const
T
&
v
)
:
value
(
v
)
{
}
BarrieredBase
(
const
BarrieredBase
<
T
>
&
other
)
=
default
;
T
value
;
public
:
using
ElementType
=
T
;
T
*
unbarrieredAddress
(
)
const
{
return
const_cast
<
T
*
>
(
&
value
)
;
}
}
;
template
<
class
T
>
class
WriteBarriered
:
public
BarrieredBase
<
T
>
public
WrappedPtrOperations
<
T
WriteBarriered
<
T
>
>
{
protected
:
using
BarrieredBase
<
T
>
:
:
value
;
explicit
WriteBarriered
(
const
T
&
v
)
:
BarrieredBase
<
T
>
(
v
)
{
}
public
:
DECLARE_POINTER_CONSTREF_OPS
(
T
)
;
const
T
&
get
(
)
const
{
return
this
-
>
value
;
}
void
unbarrieredSet
(
const
T
&
v
)
{
this
-
>
value
=
v
;
}
static
void
preWriteBarrier
(
const
T
&
v
)
{
InternalBarrierMethods
<
T
>
:
:
preBarrier
(
v
)
;
}
protected
:
void
pre
(
)
{
InternalBarrierMethods
<
T
>
:
:
preBarrier
(
this
-
>
value
)
;
}
MOZ_ALWAYS_INLINE
void
post
(
const
T
&
prev
const
T
&
next
)
{
InternalBarrierMethods
<
T
>
:
:
postBarrier
(
&
this
-
>
value
prev
next
)
;
}
}
;
#
define
DECLARE_POINTER_ASSIGN_AND_MOVE_OPS
(
Wrapper
T
)
\
DECLARE_POINTER_ASSIGN_OPS
(
Wrapper
T
)
\
Wrapper
<
T
>
&
operator
=
(
Wrapper
<
T
>
&
&
other
)
{
\
setUnchecked
(
other
.
release
(
)
)
;
\
return
*
this
;
\
}
template
<
class
T
>
class
PreBarriered
:
public
WriteBarriered
<
T
>
{
public
:
PreBarriered
(
)
:
WriteBarriered
<
T
>
(
JS
:
:
SafelyInitialized
<
T
>
(
)
)
{
}
MOZ_IMPLICIT
PreBarriered
(
const
T
&
v
)
:
WriteBarriered
<
T
>
(
v
)
{
}
explicit
PreBarriered
(
const
PreBarriered
<
T
>
&
other
)
:
WriteBarriered
<
T
>
(
other
.
value
)
{
}
PreBarriered
(
PreBarriered
<
T
>
&
&
other
)
:
WriteBarriered
<
T
>
(
other
.
release
(
)
)
{
}
~
PreBarriered
(
)
{
this
-
>
pre
(
)
;
}
void
init
(
const
T
&
v
)
{
this
-
>
value
=
v
;
}
void
clear
(
)
{
set
(
JS
:
:
SafelyInitialized
<
T
>
(
)
)
;
}
DECLARE_POINTER_ASSIGN_AND_MOVE_OPS
(
PreBarriered
T
)
;
void
set
(
const
T
&
v
)
{
AssertTargetIsNotGray
(
v
)
;
setUnchecked
(
v
)
;
}
private
:
void
setUnchecked
(
const
T
&
v
)
{
this
-
>
pre
(
)
;
this
-
>
value
=
v
;
}
T
release
(
)
{
T
tmp
=
this
-
>
value
;
this
-
>
value
=
JS
:
:
SafelyInitialized
<
T
>
(
)
;
return
tmp
;
}
}
;
}
namespace
JS
{
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
js
:
:
PreBarriered
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
js
:
:
PreBarriered
<
T
>
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
}
namespace
js
{
template
<
class
T
>
class
GCPtr
:
public
WriteBarriered
<
T
>
{
public
:
GCPtr
(
)
:
WriteBarriered
<
T
>
(
JS
:
:
SafelyInitialized
<
T
>
(
)
)
{
}
explicit
GCPtr
(
const
T
&
v
)
:
WriteBarriered
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
(
)
v
)
;
}
explicit
GCPtr
(
const
GCPtr
<
T
>
&
v
)
:
WriteBarriered
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
(
)
v
)
;
}
#
ifdef
DEBUG
~
GCPtr
(
)
{
MOZ_ASSERT
(
CurrentThreadIsGCSweeping
(
)
|
|
CurrentThreadIsGCFinalizing
(
)
)
;
Poison
(
this
JS_FREED_HEAP_PTR_PATTERN
sizeof
(
*
this
)
MemCheckKind
:
:
MakeNoAccess
)
;
}
#
endif
void
init
(
const
T
&
v
)
{
AssertTargetIsNotGray
(
v
)
;
this
-
>
value
=
v
;
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
(
)
v
)
;
}
DECLARE_POINTER_ASSIGN_OPS
(
GCPtr
T
)
;
void
set
(
const
T
&
v
)
{
AssertTargetIsNotGray
(
v
)
;
setUnchecked
(
v
)
;
}
private
:
void
setUnchecked
(
const
T
&
v
)
{
this
-
>
pre
(
)
;
T
tmp
=
this
-
>
value
;
this
-
>
value
=
v
;
this
-
>
post
(
tmp
this
-
>
value
)
;
}
GCPtr
(
GCPtr
<
T
>
&
&
)
=
delete
;
GCPtr
<
T
>
&
operator
=
(
GCPtr
<
T
>
&
&
)
=
delete
;
}
;
}
namespace
JS
{
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
js
:
:
GCPtr
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
js
:
:
GCPtr
<
T
>
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
}
namespace
js
{
template
<
class
T
>
class
HeapPtr
:
public
WriteBarriered
<
T
>
{
public
:
HeapPtr
(
)
:
WriteBarriered
<
T
>
(
JS
:
:
SafelyInitialized
<
T
>
(
)
)
{
}
MOZ_IMPLICIT
HeapPtr
(
const
T
&
v
)
:
WriteBarriered
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
(
)
this
-
>
value
)
;
}
MOZ_IMPLICIT
HeapPtr
(
const
HeapPtr
<
T
>
&
other
)
:
WriteBarriered
<
T
>
(
other
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
(
)
this
-
>
value
)
;
}
HeapPtr
(
HeapPtr
<
T
>
&
&
other
)
:
WriteBarriered
<
T
>
(
other
.
release
(
)
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
(
)
this
-
>
value
)
;
}
~
HeapPtr
(
)
{
this
-
>
pre
(
)
;
this
-
>
post
(
this
-
>
value
JS
:
:
SafelyInitialized
<
T
>
(
)
)
;
}
void
init
(
const
T
&
v
)
{
MOZ_ASSERT
(
this
-
>
value
=
=
JS
:
:
SafelyInitialized
<
T
>
(
)
)
;
AssertTargetIsNotGray
(
v
)
;
this
-
>
value
=
v
;
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
(
)
this
-
>
value
)
;
}
DECLARE_POINTER_ASSIGN_AND_MOVE_OPS
(
HeapPtr
T
)
;
void
set
(
const
T
&
v
)
{
AssertTargetIsNotGray
(
v
)
;
setUnchecked
(
v
)
;
}
template
<
class
T1
class
T2
>
friend
inline
void
BarrieredSetPair
(
Zone
*
zone
HeapPtr
<
T1
*
>
&
v1
T1
*
val1
HeapPtr
<
T2
*
>
&
v2
T2
*
val2
)
;
protected
:
void
setUnchecked
(
const
T
&
v
)
{
this
-
>
pre
(
)
;
postBarrieredSet
(
v
)
;
}
void
postBarrieredSet
(
const
T
&
v
)
{
T
tmp
=
this
-
>
value
;
this
-
>
value
=
v
;
this
-
>
post
(
tmp
this
-
>
value
)
;
}
T
release
(
)
{
T
tmp
=
this
-
>
value
;
postBarrieredSet
(
JS
:
:
SafelyInitialized
<
T
>
(
)
)
;
return
tmp
;
}
}
;
}
namespace
JS
{
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
js
:
:
HeapPtr
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
js
:
:
HeapPtr
<
T
>
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
}
namespace
js
{
template
<
typename
T
>
class
ReadBarriered
:
public
BarrieredBase
<
T
>
{
protected
:
explicit
ReadBarriered
(
const
T
&
v
)
:
BarrieredBase
<
T
>
(
v
)
{
}
void
read
(
)
const
{
InternalBarrierMethods
<
T
>
:
:
readBarrier
(
this
-
>
value
)
;
}
void
post
(
const
T
&
prev
const
T
&
next
)
{
InternalBarrierMethods
<
T
>
:
:
postBarrier
(
&
this
-
>
value
prev
next
)
;
}
}
;
template
<
typename
T
>
class
WeakHeapPtr
:
public
ReadBarriered
<
T
>
public
WrappedPtrOperations
<
T
WeakHeapPtr
<
T
>
>
{
protected
:
using
ReadBarriered
<
T
>
:
:
value
;
public
:
WeakHeapPtr
(
)
:
ReadBarriered
<
T
>
(
JS
:
:
SafelyInitialized
<
T
>
(
)
)
{
}
MOZ_IMPLICIT
WeakHeapPtr
(
const
T
&
v
)
:
ReadBarriered
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
(
)
v
)
;
}
explicit
WeakHeapPtr
(
const
WeakHeapPtr
&
other
)
:
ReadBarriered
<
T
>
(
other
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
(
)
value
)
;
}
WeakHeapPtr
(
WeakHeapPtr
&
&
other
)
:
ReadBarriered
<
T
>
(
other
.
release
(
)
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
(
)
value
)
;
}
~
WeakHeapPtr
(
)
{
this
-
>
post
(
this
-
>
value
JS
:
:
SafelyInitialized
<
T
>
(
)
)
;
}
WeakHeapPtr
&
operator
=
(
const
WeakHeapPtr
&
v
)
{
AssertTargetIsNotGray
(
v
.
value
)
;
T
prior
=
this
-
>
value
;
this
-
>
value
=
v
.
value
;
this
-
>
post
(
prior
v
.
value
)
;
return
*
this
;
}
const
T
&
get
(
)
const
{
if
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
this
-
>
value
)
)
{
this
-
>
read
(
)
;
}
return
this
-
>
value
;
}
const
T
&
unbarrieredGet
(
)
const
{
return
this
-
>
value
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
this
-
>
value
)
;
}
operator
const
T
&
(
)
const
{
return
get
(
)
;
}
const
T
&
operator
-
>
(
)
const
{
return
get
(
)
;
}
void
set
(
const
T
&
v
)
{
AssertTargetIsNotGray
(
v
)
;
setUnchecked
(
v
)
;
}
void
unbarrieredSet
(
const
T
&
v
)
{
AssertTargetIsNotGray
(
v
)
;
this
-
>
value
=
v
;
}
private
:
void
setUnchecked
(
const
T
&
v
)
{
T
tmp
=
this
-
>
value
;
this
-
>
value
=
v
;
this
-
>
post
(
tmp
v
)
;
}
T
release
(
)
{
T
tmp
=
value
;
set
(
JS
:
:
SafelyInitialized
<
T
>
(
)
)
;
return
tmp
;
}
}
;
}
namespace
JS
{
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
js
:
:
WeakHeapPtr
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
js
:
:
WeakHeapPtr
<
T
>
&
v
)
{
return
v
.
unbarrieredGet
(
)
;
}
}
;
}
}
namespace
js
{
class
HeapSlot
:
public
WriteBarriered
<
Value
>
{
public
:
enum
Kind
{
Slot
=
0
Element
=
1
}
;
void
init
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
v
)
{
value
=
v
;
post
(
owner
kind
slot
v
)
;
}
void
initAsUndefined
(
)
{
value
.
setUndefined
(
)
;
}
void
destroy
(
)
{
pre
(
)
;
}
#
ifdef
DEBUG
bool
preconditionForSet
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
)
const
;
void
assertPreconditionForPostWriteBarrier
(
NativeObject
*
obj
Kind
kind
uint32_t
slot
const
Value
&
target
)
const
;
#
endif
MOZ_ALWAYS_INLINE
void
set
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
v
)
{
MOZ_ASSERT
(
preconditionForSet
(
owner
kind
slot
)
)
;
pre
(
)
;
value
=
v
;
post
(
owner
kind
slot
v
)
;
}
private
:
void
post
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
target
)
{
#
ifdef
DEBUG
assertPreconditionForPostWriteBarrier
(
owner
kind
slot
target
)
;
#
endif
if
(
this
-
>
value
.
isObject
(
)
|
|
this
-
>
value
.
isString
(
)
|
|
this
-
>
value
.
isBigInt
(
)
)
{
gc
:
:
Cell
*
cell
=
this
-
>
value
.
toGCThing
(
)
;
if
(
cell
-
>
storeBuffer
(
)
)
{
cell
-
>
storeBuffer
(
)
-
>
putSlot
(
owner
kind
slot
1
)
;
}
}
}
}
;
}
namespace
JS
{
namespace
detail
{
template
<
>
struct
DefineComparisonOps
<
js
:
:
HeapSlot
>
:
std
:
:
true_type
{
static
const
Value
&
get
(
const
js
:
:
HeapSlot
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
}
namespace
js
{
class
HeapSlotArray
{
HeapSlot
*
array
;
public
:
explicit
HeapSlotArray
(
HeapSlot
*
array
)
:
array
(
array
)
{
}
HeapSlot
*
begin
(
)
const
{
return
array
;
}
operator
const
Value
*
(
)
const
{
static_assert
(
sizeof
(
GCPtr
<
Value
>
)
=
=
sizeof
(
Value
)
)
;
static_assert
(
sizeof
(
HeapSlot
)
=
=
sizeof
(
Value
)
)
;
return
reinterpret_cast
<
const
Value
*
>
(
array
)
;
}
operator
HeapSlot
*
(
)
const
{
return
begin
(
)
;
}
HeapSlotArray
operator
+
(
int
offset
)
const
{
return
HeapSlotArray
(
array
+
offset
)
;
}
HeapSlotArray
operator
+
(
uint32_t
offset
)
const
{
return
HeapSlotArray
(
array
+
offset
)
;
}
}
;
template
<
class
T1
class
T2
>
static
inline
void
BarrieredSetPair
(
Zone
*
zone
HeapPtr
<
T1
*
>
&
v1
T1
*
val1
HeapPtr
<
T2
*
>
&
v2
T2
*
val2
)
{
AssertTargetIsNotGray
(
val1
)
;
AssertTargetIsNotGray
(
val2
)
;
if
(
T1
:
:
needPreWriteBarrier
(
zone
)
)
{
v1
.
pre
(
)
;
v2
.
pre
(
)
;
}
v1
.
postBarrieredSet
(
val1
)
;
v2
.
postBarrieredSet
(
val2
)
;
}
template
<
typename
T
>
class
MOZ_HEAP_CLASS
ImmutableTenuredPtr
{
T
value
;
public
:
operator
T
(
)
const
{
return
value
;
}
T
operator
-
>
(
)
const
{
return
value
;
}
operator
Handle
<
T
>
(
)
const
{
return
toHandle
(
)
;
}
Handle
<
T
>
toHandle
(
)
const
{
return
Handle
<
T
>
:
:
fromMarkedLocation
(
&
value
)
;
}
void
init
(
T
ptr
)
{
MOZ_ASSERT
(
ptr
-
>
isTenured
(
)
)
;
AssertTargetIsNotGray
(
ptr
)
;
value
=
ptr
;
}
T
get
(
)
const
{
return
value
;
}
const
T
*
address
(
)
{
return
&
value
;
}
}
;
#
if
MOZ_IS_GCC
template
struct
JS_PUBLIC_API
MovableCellHasher
<
JSObject
*
>
;
#
endif
template
<
typename
T
>
struct
MovableCellHasher
<
PreBarriered
<
T
>
>
{
using
Key
=
PreBarriered
<
T
>
;
using
Lookup
=
T
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hasHash
(
l
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
ensureHash
(
l
)
;
}
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
match
(
k
l
)
;
}
}
;
template
<
typename
T
>
struct
MovableCellHasher
<
HeapPtr
<
T
>
>
{
using
Key
=
HeapPtr
<
T
>
;
using
Lookup
=
T
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hasHash
(
l
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
ensureHash
(
l
)
;
}
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
match
(
k
l
)
;
}
}
;
template
<
typename
T
>
struct
MovableCellHasher
<
WeakHeapPtr
<
T
>
>
{
using
Key
=
WeakHeapPtr
<
T
>
;
using
Lookup
=
T
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hasHash
(
l
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
ensureHash
(
l
)
;
}
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
match
(
k
.
unbarrieredGet
(
)
l
)
;
}
}
;
template
<
class
T
>
struct
HeapPtrHasher
{
using
Key
=
HeapPtr
<
T
>
;
using
Lookup
=
T
;
static
HashNumber
hash
(
Lookup
obj
)
{
return
DefaultHasher
<
T
>
:
:
hash
(
obj
)
;
}
static
bool
match
(
const
Key
&
k
Lookup
l
)
{
return
k
.
get
(
)
=
=
l
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unbarrieredSet
(
newKey
)
;
}
}
;
template
<
class
T
>
struct
PreBarrieredHasher
{
using
Key
=
PreBarriered
<
T
>
;
using
Lookup
=
T
;
static
HashNumber
hash
(
Lookup
obj
)
{
return
DefaultHasher
<
T
>
:
:
hash
(
obj
)
;
}
static
bool
match
(
const
Key
&
k
Lookup
l
)
{
return
k
.
get
(
)
=
=
l
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unbarrieredSet
(
newKey
)
;
}
}
;
template
<
class
T
>
struct
WeakHeapPtrHasher
{
using
Key
=
WeakHeapPtr
<
T
>
;
using
Lookup
=
T
;
static
HashNumber
hash
(
Lookup
obj
)
{
return
DefaultHasher
<
T
>
:
:
hash
(
obj
)
;
}
static
bool
match
(
const
Key
&
k
Lookup
l
)
{
return
k
.
unbarrieredGet
(
)
=
=
l
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
set
(
newKey
.
unbarrieredGet
(
)
)
;
}
}
;
}
namespace
mozilla
{
template
<
class
T
>
struct
DefaultHasher
<
js
:
:
HeapPtr
<
T
>
>
:
js
:
:
HeapPtrHasher
<
T
>
{
}
;
template
<
class
T
>
struct
DefaultHasher
<
js
:
:
GCPtr
<
T
>
>
{
}
;
template
<
class
T
>
struct
DefaultHasher
<
js
:
:
PreBarriered
<
T
>
>
:
js
:
:
PreBarrieredHasher
<
T
>
{
}
;
template
<
class
T
>
struct
DefaultHasher
<
js
:
:
WeakHeapPtr
<
T
>
>
:
js
:
:
WeakHeapPtrHasher
<
T
>
{
}
;
}
namespace
js
{
class
ArrayObject
;
class
DebugEnvironmentProxy
;
class
GlobalObject
;
class
PropertyName
;
class
Scope
;
class
ScriptSourceObject
;
class
Shape
;
class
BaseShape
;
class
GetterSetter
;
class
PropMap
;
class
WasmInstanceObject
;
class
WasmTableObject
;
namespace
jit
{
class
JitCode
;
}
using
PreBarrieredId
=
PreBarriered
<
jsid
>
;
using
PreBarrieredObject
=
PreBarriered
<
JSObject
*
>
;
using
PreBarrieredValue
=
PreBarriered
<
Value
>
;
using
GCPtrNativeObject
=
GCPtr
<
NativeObject
*
>
;
using
GCPtrArrayObject
=
GCPtr
<
ArrayObject
*
>
;
using
GCPtrAtom
=
GCPtr
<
JSAtom
*
>
;
using
GCPtrBigInt
=
GCPtr
<
BigInt
*
>
;
using
GCPtrFunction
=
GCPtr
<
JSFunction
*
>
;
using
GCPtrLinearString
=
GCPtr
<
JSLinearString
*
>
;
using
GCPtrObject
=
GCPtr
<
JSObject
*
>
;
using
GCPtrScript
=
GCPtr
<
JSScript
*
>
;
using
GCPtrString
=
GCPtr
<
JSString
*
>
;
using
GCPtrShape
=
GCPtr
<
Shape
*
>
;
using
GCPtrGetterSetter
=
GCPtr
<
GetterSetter
*
>
;
using
GCPtrPropMap
=
GCPtr
<
PropMap
*
>
;
using
GCPtrValue
=
GCPtr
<
Value
>
;
using
GCPtrId
=
GCPtr
<
jsid
>
;
using
ImmutablePropertyNamePtr
=
ImmutableTenuredPtr
<
PropertyName
*
>
;
using
ImmutableSymbolPtr
=
ImmutableTenuredPtr
<
JS
:
:
Symbol
*
>
;
using
WeakHeapPtrDebugEnvironmentProxy
=
WeakHeapPtr
<
DebugEnvironmentProxy
*
>
;
using
WeakHeapPtrGlobalObject
=
WeakHeapPtr
<
GlobalObject
*
>
;
using
WeakHeapPtrObject
=
WeakHeapPtr
<
JSObject
*
>
;
using
WeakHeapPtrScript
=
WeakHeapPtr
<
JSScript
*
>
;
using
WeakHeapPtrScriptSourceObject
=
WeakHeapPtr
<
ScriptSourceObject
*
>
;
using
WeakHeapPtrShape
=
WeakHeapPtr
<
Shape
*
>
;
using
WeakHeapPtrJitCode
=
WeakHeapPtr
<
jit
:
:
JitCode
*
>
;
using
WeakHeapPtrSymbol
=
WeakHeapPtr
<
JS
:
:
Symbol
*
>
;
using
WeakHeapPtrWasmInstanceObject
=
WeakHeapPtr
<
WasmInstanceObject
*
>
;
using
WeakHeapPtrWasmTableObject
=
WeakHeapPtr
<
WasmTableObject
*
>
;
using
HeapPtrJitCode
=
HeapPtr
<
jit
:
:
JitCode
*
>
;
using
HeapPtrNativeObject
=
HeapPtr
<
NativeObject
*
>
;
using
HeapPtrObject
=
HeapPtr
<
JSObject
*
>
;
using
HeapPtrRegExpShared
=
HeapPtr
<
RegExpShared
*
>
;
using
HeapPtrValue
=
HeapPtr
<
Value
>
;
}
#
endif
