#
ifndef
gc_Barrier_h
#
define
gc_Barrier_h
#
include
<
type_traits
>
#
include
"
NamespaceImports
.
h
"
#
include
"
gc
/
Cell
.
h
"
#
include
"
gc
/
StoreBuffer
.
h
"
#
include
"
js
/
ComparisonOperators
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
util
/
Poison
.
h
"
namespace
js
{
class
NativeObject
;
namespace
gc
{
inline
void
ValueReadBarrier
(
const
Value
&
v
)
{
MOZ_ASSERT
(
v
.
isGCThing
(
)
)
;
ReadBarrierImpl
(
v
.
toGCThing
(
)
)
;
}
inline
void
ValuePreWriteBarrier
(
const
Value
&
v
)
{
MOZ_ASSERT
(
v
.
isGCThing
(
)
)
;
PreWriteBarrierImpl
(
v
.
toGCThing
(
)
)
;
}
inline
void
IdPreWriteBarrier
(
jsid
id
)
{
MOZ_ASSERT
(
id
.
isGCThing
(
)
)
;
PreWriteBarrierImpl
(
&
id
.
toGCThing
(
)
-
>
asTenured
(
)
)
;
}
inline
void
CellPtrPreWriteBarrier
(
JS
:
:
GCCellPtr
thing
)
{
MOZ_ASSERT
(
thing
)
;
PreWriteBarrierImpl
(
thing
.
asCell
(
)
)
;
}
}
#
ifdef
DEBUG
bool
CurrentThreadIsTouchingGrayThings
(
)
;
bool
IsMarkedBlack
(
JSObject
*
obj
)
;
#
endif
template
<
typename
T
typename
Enable
=
void
>
struct
InternalBarrierMethods
{
}
;
template
<
typename
T
>
struct
InternalBarrierMethods
<
T
*
>
{
static_assert
(
std
:
:
is_base_of_v
<
gc
:
:
Cell
T
>
"
Expected
a
GC
thing
type
"
)
;
static
bool
isMarkable
(
const
T
*
v
)
{
return
v
!
=
nullptr
;
}
static
void
preBarrier
(
T
*
v
)
{
gc
:
:
PreWriteBarrier
(
v
)
;
}
static
void
postBarrier
(
T
*
*
vp
T
*
prev
T
*
next
)
{
gc
:
:
PostWriteBarrier
(
vp
prev
next
)
;
}
static
void
readBarrier
(
T
*
v
)
{
gc
:
:
ReadBarrier
(
v
)
;
}
#
ifdef
DEBUG
static
void
assertThingIsNotGray
(
T
*
v
)
{
return
T
:
:
assertThingIsNotGray
(
v
)
;
}
#
endif
}
;
template
<
>
struct
InternalBarrierMethods
<
Value
>
{
static
bool
isMarkable
(
const
Value
&
v
)
{
return
v
.
isGCThing
(
)
;
}
static
void
preBarrier
(
const
Value
&
v
)
{
if
(
v
.
isGCThing
(
)
)
{
gc
:
:
ValuePreWriteBarrier
(
v
)
;
}
}
static
MOZ_ALWAYS_INLINE
void
postBarrier
(
Value
*
vp
const
Value
&
prev
const
Value
&
next
)
{
MOZ_ASSERT
(
!
CurrentThreadIsIonCompiling
(
)
)
;
MOZ_ASSERT
(
vp
)
;
js
:
:
gc
:
:
StoreBuffer
*
sb
;
if
(
next
.
isGCThing
(
)
&
&
(
sb
=
next
.
toGCThing
(
)
-
>
storeBuffer
(
)
)
)
{
if
(
prev
.
isGCThing
(
)
&
&
prev
.
toGCThing
(
)
-
>
storeBuffer
(
)
)
{
return
;
}
sb
-
>
putValue
(
vp
)
;
return
;
}
if
(
prev
.
isGCThing
(
)
&
&
(
sb
=
prev
.
toGCThing
(
)
-
>
storeBuffer
(
)
)
)
{
sb
-
>
unputValue
(
vp
)
;
}
}
static
void
readBarrier
(
const
Value
&
v
)
{
if
(
v
.
isGCThing
(
)
)
{
gc
:
:
ValueReadBarrier
(
v
)
;
}
}
#
ifdef
DEBUG
static
void
assertThingIsNotGray
(
const
Value
&
v
)
{
JS
:
:
AssertValueIsNotGray
(
v
)
;
}
#
endif
}
;
template
<
>
struct
InternalBarrierMethods
<
jsid
>
{
static
bool
isMarkable
(
jsid
id
)
{
return
id
.
isGCThing
(
)
;
}
static
void
preBarrier
(
jsid
id
)
{
if
(
id
.
isGCThing
(
)
)
{
gc
:
:
IdPreWriteBarrier
(
id
)
;
}
}
static
void
postBarrier
(
jsid
*
idp
jsid
prev
jsid
next
)
{
}
#
ifdef
DEBUG
static
void
assertThingIsNotGray
(
jsid
id
)
{
JS
:
:
AssertIdIsNotGray
(
id
)
;
}
#
endif
}
;
template
<
typename
T
>
struct
InternalBarrierMethods
<
T
EnableIfABOVType
<
T
>
>
{
using
BM
=
BarrierMethods
<
T
>
;
static
bool
isMarkable
(
const
T
&
thing
)
{
return
bool
(
thing
)
;
}
static
void
preBarrier
(
const
T
&
thing
)
{
gc
:
:
PreWriteBarrier
(
thing
.
asObjectUnbarriered
(
)
)
;
}
static
void
postBarrier
(
T
*
tp
const
T
&
prev
const
T
&
next
)
{
BM
:
:
postWriteBarrier
(
tp
prev
next
)
;
}
static
void
readBarrier
(
const
T
&
thing
)
{
BM
:
:
readBarrier
(
thing
)
;
}
#
ifdef
DEBUG
static
void
assertThingIsNotGray
(
const
T
&
thing
)
{
JSObject
*
obj
=
thing
.
asObjectUnbarriered
(
)
;
if
(
obj
)
{
JS
:
:
AssertValueIsNotGray
(
JS
:
:
ObjectValue
(
*
obj
)
)
;
}
}
#
endif
}
;
template
<
typename
T
>
static
inline
void
AssertTargetIsNotGray
(
const
T
&
v
)
{
#
ifdef
DEBUG
if
(
!
CurrentThreadIsTouchingGrayThings
(
)
)
{
InternalBarrierMethods
<
T
>
:
:
assertThingIsNotGray
(
v
)
;
}
#
endif
}
template
<
typename
T
>
class
MOZ_NON_MEMMOVABLE
BarrieredBase
{
protected
:
explicit
BarrieredBase
(
const
T
&
v
)
:
value
(
v
)
{
}
BarrieredBase
(
const
BarrieredBase
<
T
>
&
other
)
=
default
;
T
value
;
public
:
using
ElementType
=
T
;
T
*
unbarrieredAddress
(
)
const
{
return
const_cast
<
T
*
>
(
&
value
)
;
}
}
;
template
<
class
T
>
class
WriteBarriered
:
public
BarrieredBase
<
T
>
public
WrappedPtrOperations
<
T
WriteBarriered
<
T
>
>
{
protected
:
using
BarrieredBase
<
T
>
:
:
value
;
explicit
WriteBarriered
(
const
T
&
v
)
:
BarrieredBase
<
T
>
(
v
)
{
}
public
:
DECLARE_POINTER_CONSTREF_OPS
(
T
)
;
const
T
&
get
(
)
const
{
return
this
-
>
value
;
}
void
unbarrieredSet
(
const
T
&
v
)
{
this
-
>
value
=
v
;
}
static
void
preWriteBarrier
(
const
T
&
v
)
{
InternalBarrierMethods
<
T
>
:
:
preBarrier
(
v
)
;
}
protected
:
void
pre
(
)
{
InternalBarrierMethods
<
T
>
:
:
preBarrier
(
this
-
>
value
)
;
}
MOZ_ALWAYS_INLINE
void
post
(
const
T
&
prev
const
T
&
next
)
{
InternalBarrierMethods
<
T
>
:
:
postBarrier
(
&
this
-
>
value
prev
next
)
;
}
}
;
#
define
DECLARE_POINTER_ASSIGN_AND_MOVE_OPS
(
Wrapper
T
)
\
DECLARE_POINTER_ASSIGN_OPS
(
Wrapper
T
)
\
Wrapper
<
T
>
&
operator
=
(
Wrapper
<
T
>
&
&
other
)
{
\
setUnchecked
(
other
.
release
(
)
)
;
\
return
*
this
;
\
}
template
<
class
T
>
class
PreBarriered
:
public
WriteBarriered
<
T
>
{
public
:
PreBarriered
(
)
:
WriteBarriered
<
T
>
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
)
{
}
MOZ_IMPLICIT
PreBarriered
(
const
T
&
v
)
:
WriteBarriered
<
T
>
(
v
)
{
}
explicit
PreBarriered
(
const
PreBarriered
<
T
>
&
other
)
:
WriteBarriered
<
T
>
(
other
.
value
)
{
}
PreBarriered
(
PreBarriered
<
T
>
&
&
other
)
:
WriteBarriered
<
T
>
(
other
.
release
(
)
)
{
}
~
PreBarriered
(
)
{
this
-
>
pre
(
)
;
}
void
init
(
const
T
&
v
)
{
this
-
>
value
=
v
;
}
void
clear
(
)
{
set
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
)
;
}
DECLARE_POINTER_ASSIGN_AND_MOVE_OPS
(
PreBarriered
T
)
;
void
set
(
const
T
&
v
)
{
AssertTargetIsNotGray
(
v
)
;
setUnchecked
(
v
)
;
}
private
:
void
setUnchecked
(
const
T
&
v
)
{
this
-
>
pre
(
)
;
this
-
>
value
=
v
;
}
T
release
(
)
{
T
tmp
=
this
-
>
value
;
this
-
>
value
=
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
;
return
tmp
;
}
}
;
}
namespace
JS
{
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
js
:
:
PreBarriered
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
js
:
:
PreBarriered
<
T
>
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
}
namespace
js
{
template
<
class
T
>
class
GCPtr
:
public
WriteBarriered
<
T
>
{
public
:
GCPtr
(
)
:
WriteBarriered
<
T
>
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
)
{
}
explicit
GCPtr
(
const
T
&
v
)
:
WriteBarriered
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
v
)
;
}
explicit
GCPtr
(
const
GCPtr
<
T
>
&
v
)
:
WriteBarriered
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
v
)
;
}
#
ifdef
DEBUG
~
GCPtr
(
)
{
MOZ_ASSERT
(
CurrentThreadIsGCSweeping
(
)
|
|
CurrentThreadIsGCFinalizing
(
)
)
;
Poison
(
this
JS_FREED_HEAP_PTR_PATTERN
sizeof
(
*
this
)
MemCheckKind
:
:
MakeNoAccess
)
;
}
#
endif
void
init
(
const
T
&
v
)
{
AssertTargetIsNotGray
(
v
)
;
this
-
>
value
=
v
;
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
v
)
;
}
DECLARE_POINTER_ASSIGN_OPS
(
GCPtr
T
)
;
void
set
(
const
T
&
v
)
{
AssertTargetIsNotGray
(
v
)
;
setUnchecked
(
v
)
;
}
private
:
void
setUnchecked
(
const
T
&
v
)
{
this
-
>
pre
(
)
;
T
tmp
=
this
-
>
value
;
this
-
>
value
=
v
;
this
-
>
post
(
tmp
this
-
>
value
)
;
}
GCPtr
(
GCPtr
<
T
>
&
&
)
=
delete
;
GCPtr
<
T
>
&
operator
=
(
GCPtr
<
T
>
&
&
)
=
delete
;
}
;
}
namespace
JS
{
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
js
:
:
GCPtr
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
js
:
:
GCPtr
<
T
>
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
}
namespace
js
{
template
<
class
T
>
class
HeapPtr
:
public
WriteBarriered
<
T
>
{
public
:
HeapPtr
(
)
:
WriteBarriered
<
T
>
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
)
{
}
MOZ_IMPLICIT
HeapPtr
(
const
T
&
v
)
:
WriteBarriered
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
this
-
>
value
)
;
}
MOZ_IMPLICIT
HeapPtr
(
const
HeapPtr
<
T
>
&
other
)
:
WriteBarriered
<
T
>
(
other
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
this
-
>
value
)
;
}
HeapPtr
(
HeapPtr
<
T
>
&
&
other
)
:
WriteBarriered
<
T
>
(
other
.
release
(
)
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
this
-
>
value
)
;
}
~
HeapPtr
(
)
{
this
-
>
pre
(
)
;
this
-
>
post
(
this
-
>
value
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
)
;
}
void
init
(
const
T
&
v
)
{
MOZ_ASSERT
(
this
-
>
value
=
=
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
)
;
AssertTargetIsNotGray
(
v
)
;
this
-
>
value
=
v
;
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
this
-
>
value
)
;
}
DECLARE_POINTER_ASSIGN_AND_MOVE_OPS
(
HeapPtr
T
)
;
void
set
(
const
T
&
v
)
{
AssertTargetIsNotGray
(
v
)
;
setUnchecked
(
v
)
;
}
template
<
class
T1
class
T2
>
friend
inline
void
BarrieredSetPair
(
Zone
*
zone
HeapPtr
<
T1
*
>
&
v1
T1
*
val1
HeapPtr
<
T2
*
>
&
v2
T2
*
val2
)
;
protected
:
void
setUnchecked
(
const
T
&
v
)
{
this
-
>
pre
(
)
;
postBarrieredSet
(
v
)
;
}
void
postBarrieredSet
(
const
T
&
v
)
{
T
tmp
=
this
-
>
value
;
this
-
>
value
=
v
;
this
-
>
post
(
tmp
this
-
>
value
)
;
}
T
release
(
)
{
T
tmp
=
this
-
>
value
;
postBarrieredSet
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
)
;
return
tmp
;
}
}
;
template
<
class
T
>
class
GCStructPtr
:
public
BarrieredBase
<
T
>
{
public
:
static
constexpr
uintptr_t
MaxTaggedPointer
=
0x2
;
GCStructPtr
(
)
:
BarrieredBase
<
T
>
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
)
{
}
MOZ_IMPLICIT
GCStructPtr
(
const
T
&
v
)
:
BarrieredBase
<
T
>
(
v
)
{
}
GCStructPtr
(
const
GCStructPtr
<
T
>
&
other
)
:
BarrieredBase
<
T
>
(
other
)
{
}
GCStructPtr
(
GCStructPtr
<
T
>
&
&
other
)
:
BarrieredBase
<
T
>
(
other
.
release
(
)
)
{
}
~
GCStructPtr
(
)
{
MOZ_ASSERT_IF
(
isTraceable
(
)
CurrentThreadIsGCSweeping
(
)
|
|
CurrentThreadIsGCFinalizing
(
)
)
;
}
void
init
(
const
T
&
v
)
{
MOZ_ASSERT
(
this
-
>
get
(
)
=
=
JS
:
:
SafelyInitialized
<
T
>
(
)
)
;
AssertTargetIsNotGray
(
v
)
;
this
-
>
value
=
v
;
}
void
set
(
JS
:
:
Zone
*
zone
const
T
&
v
)
{
pre
(
zone
)
;
this
-
>
value
=
v
;
}
T
get
(
)
const
{
return
this
-
>
value
;
}
operator
T
(
)
const
{
return
get
(
)
;
}
T
operator
-
>
(
)
const
{
return
get
(
)
;
}
protected
:
bool
isTraceable
(
)
const
{
return
uintptr_t
(
get
(
)
)
>
MaxTaggedPointer
;
}
void
pre
(
JS
:
:
Zone
*
zone
)
{
if
(
isTraceable
(
)
)
{
PreWriteBarrier
(
zone
get
(
)
)
;
}
}
}
;
}
namespace
JS
{
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
js
:
:
HeapPtr
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
js
:
:
HeapPtr
<
T
>
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
}
namespace
js
{
template
<
typename
T
>
class
ReadBarriered
:
public
BarrieredBase
<
T
>
{
protected
:
explicit
ReadBarriered
(
const
T
&
v
)
:
BarrieredBase
<
T
>
(
v
)
{
}
void
read
(
)
const
{
InternalBarrierMethods
<
T
>
:
:
readBarrier
(
this
-
>
value
)
;
}
void
post
(
const
T
&
prev
const
T
&
next
)
{
InternalBarrierMethods
<
T
>
:
:
postBarrier
(
&
this
-
>
value
prev
next
)
;
}
}
;
template
<
typename
T
>
class
WeakHeapPtr
:
public
ReadBarriered
<
T
>
public
WrappedPtrOperations
<
T
WeakHeapPtr
<
T
>
>
{
protected
:
using
ReadBarriered
<
T
>
:
:
value
;
public
:
WeakHeapPtr
(
)
:
ReadBarriered
<
T
>
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
)
{
}
MOZ_IMPLICIT
WeakHeapPtr
(
const
T
&
v
)
:
ReadBarriered
<
T
>
(
v
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
v
)
;
}
explicit
WeakHeapPtr
(
const
WeakHeapPtr
&
other
)
:
ReadBarriered
<
T
>
(
other
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
value
)
;
}
WeakHeapPtr
(
WeakHeapPtr
&
&
other
)
:
ReadBarriered
<
T
>
(
other
.
release
(
)
)
{
this
-
>
post
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
value
)
;
}
~
WeakHeapPtr
(
)
{
this
-
>
post
(
this
-
>
value
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
)
;
}
WeakHeapPtr
&
operator
=
(
const
WeakHeapPtr
&
v
)
{
AssertTargetIsNotGray
(
v
.
value
)
;
T
prior
=
this
-
>
value
;
this
-
>
value
=
v
.
value
;
this
-
>
post
(
prior
v
.
value
)
;
return
*
this
;
}
const
T
&
get
(
)
const
{
if
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
this
-
>
value
)
)
{
this
-
>
read
(
)
;
}
return
this
-
>
value
;
}
const
T
&
unbarrieredGet
(
)
const
{
return
this
-
>
value
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
this
-
>
value
)
;
}
operator
const
T
&
(
)
const
{
return
get
(
)
;
}
const
T
&
operator
-
>
(
)
const
{
return
get
(
)
;
}
void
set
(
const
T
&
v
)
{
AssertTargetIsNotGray
(
v
)
;
setUnchecked
(
v
)
;
}
void
unbarrieredSet
(
const
T
&
v
)
{
AssertTargetIsNotGray
(
v
)
;
this
-
>
value
=
v
;
}
private
:
void
setUnchecked
(
const
T
&
v
)
{
T
tmp
=
this
-
>
value
;
this
-
>
value
=
v
;
this
-
>
post
(
tmp
v
)
;
}
T
release
(
)
{
T
tmp
=
value
;
set
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
)
;
return
tmp
;
}
}
;
template
<
typename
T
>
class
UnsafeBarePtr
:
public
BarrieredBase
<
T
>
{
public
:
UnsafeBarePtr
(
)
:
BarrieredBase
<
T
>
(
JS
:
:
SafelyInitialized
<
T
>
:
:
create
(
)
)
{
}
MOZ_IMPLICIT
UnsafeBarePtr
(
T
v
)
:
BarrieredBase
<
T
>
(
v
)
{
}
const
T
&
get
(
)
const
{
return
this
-
>
value
;
}
void
set
(
T
newValue
)
{
this
-
>
value
=
newValue
;
}
DECLARE_POINTER_CONSTREF_OPS
(
T
)
;
}
;
}
namespace
JS
{
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
js
:
:
WeakHeapPtr
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
js
:
:
WeakHeapPtr
<
T
>
&
v
)
{
return
v
.
unbarrieredGet
(
)
;
}
}
;
}
}
namespace
js
{
class
HeapSlot
:
public
WriteBarriered
<
Value
>
{
public
:
enum
Kind
{
Slot
=
0
Element
=
1
}
;
void
init
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
v
)
{
value
=
v
;
post
(
owner
kind
slot
v
)
;
}
void
initAsUndefined
(
)
{
value
.
setUndefined
(
)
;
}
void
destroy
(
)
{
pre
(
)
;
}
#
ifdef
DEBUG
bool
preconditionForSet
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
)
const
;
void
assertPreconditionForPostWriteBarrier
(
NativeObject
*
obj
Kind
kind
uint32_t
slot
const
Value
&
target
)
const
;
#
endif
MOZ_ALWAYS_INLINE
void
set
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
v
)
{
MOZ_ASSERT
(
preconditionForSet
(
owner
kind
slot
)
)
;
pre
(
)
;
value
=
v
;
post
(
owner
kind
slot
v
)
;
}
private
:
void
post
(
NativeObject
*
owner
Kind
kind
uint32_t
slot
const
Value
&
target
)
{
#
ifdef
DEBUG
assertPreconditionForPostWriteBarrier
(
owner
kind
slot
target
)
;
#
endif
if
(
this
-
>
value
.
isGCThing
(
)
)
{
gc
:
:
Cell
*
cell
=
this
-
>
value
.
toGCThing
(
)
;
if
(
cell
-
>
storeBuffer
(
)
)
{
cell
-
>
storeBuffer
(
)
-
>
putSlot
(
owner
kind
slot
1
)
;
}
}
}
}
;
}
namespace
JS
{
namespace
detail
{
template
<
>
struct
DefineComparisonOps
<
js
:
:
HeapSlot
>
:
std
:
:
true_type
{
static
const
Value
&
get
(
const
js
:
:
HeapSlot
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
}
namespace
js
{
class
HeapSlotArray
{
HeapSlot
*
array
;
public
:
explicit
HeapSlotArray
(
HeapSlot
*
array
)
:
array
(
array
)
{
}
HeapSlot
*
begin
(
)
const
{
return
array
;
}
operator
const
Value
*
(
)
const
{
static_assert
(
sizeof
(
GCPtr
<
Value
>
)
=
=
sizeof
(
Value
)
)
;
static_assert
(
sizeof
(
HeapSlot
)
=
=
sizeof
(
Value
)
)
;
return
reinterpret_cast
<
const
Value
*
>
(
array
)
;
}
operator
HeapSlot
*
(
)
const
{
return
begin
(
)
;
}
HeapSlotArray
operator
+
(
int
offset
)
const
{
return
HeapSlotArray
(
array
+
offset
)
;
}
HeapSlotArray
operator
+
(
uint32_t
offset
)
const
{
return
HeapSlotArray
(
array
+
offset
)
;
}
}
;
template
<
class
T1
class
T2
>
static
inline
void
BarrieredSetPair
(
Zone
*
zone
HeapPtr
<
T1
*
>
&
v1
T1
*
val1
HeapPtr
<
T2
*
>
&
v2
T2
*
val2
)
{
AssertTargetIsNotGray
(
val1
)
;
AssertTargetIsNotGray
(
val2
)
;
if
(
T1
:
:
needPreWriteBarrier
(
zone
)
)
{
v1
.
pre
(
)
;
v2
.
pre
(
)
;
}
v1
.
postBarrieredSet
(
val1
)
;
v2
.
postBarrieredSet
(
val2
)
;
}
template
<
typename
T
>
class
MOZ_HEAP_CLASS
ImmutableTenuredPtr
{
T
value
;
public
:
operator
T
(
)
const
{
return
value
;
}
T
operator
-
>
(
)
const
{
return
value
;
}
operator
Handle
<
T
>
(
)
const
{
return
toHandle
(
)
;
}
Handle
<
T
>
toHandle
(
)
const
{
return
Handle
<
T
>
:
:
fromMarkedLocation
(
&
value
)
;
}
void
init
(
T
ptr
)
{
MOZ_ASSERT
(
ptr
-
>
isTenured
(
)
)
;
AssertTargetIsNotGray
(
ptr
)
;
value
=
ptr
;
}
T
get
(
)
const
{
return
value
;
}
const
T
*
address
(
)
{
return
&
value
;
}
}
;
#
if
MOZ_IS_GCC
template
struct
JS_PUBLIC_API
MovableCellHasher
<
JSObject
*
>
;
#
endif
template
<
typename
T
>
struct
MovableCellHasher
<
PreBarriered
<
T
>
>
{
using
Key
=
PreBarriered
<
T
>
;
using
Lookup
=
T
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hasHash
(
l
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
ensureHash
(
l
)
;
}
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
match
(
k
l
)
;
}
}
;
template
<
typename
T
>
struct
MovableCellHasher
<
HeapPtr
<
T
>
>
{
using
Key
=
HeapPtr
<
T
>
;
using
Lookup
=
T
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hasHash
(
l
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
ensureHash
(
l
)
;
}
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
match
(
k
l
)
;
}
}
;
template
<
typename
T
>
struct
MovableCellHasher
<
WeakHeapPtr
<
T
>
>
{
using
Key
=
WeakHeapPtr
<
T
>
;
using
Lookup
=
T
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hasHash
(
l
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
ensureHash
(
l
)
;
}
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
match
(
k
.
unbarrieredGet
(
)
l
)
;
}
}
;
template
<
class
T
>
struct
HeapPtrHasher
{
using
Key
=
HeapPtr
<
T
>
;
using
Lookup
=
T
;
static
HashNumber
hash
(
Lookup
obj
)
{
return
DefaultHasher
<
T
>
:
:
hash
(
obj
)
;
}
static
bool
match
(
const
Key
&
k
Lookup
l
)
{
return
k
.
get
(
)
=
=
l
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unbarrieredSet
(
newKey
)
;
}
}
;
template
<
class
T
>
struct
PreBarrieredHasher
{
using
Key
=
PreBarriered
<
T
>
;
using
Lookup
=
T
;
static
HashNumber
hash
(
Lookup
obj
)
{
return
DefaultHasher
<
T
>
:
:
hash
(
obj
)
;
}
static
bool
match
(
const
Key
&
k
Lookup
l
)
{
return
k
.
get
(
)
=
=
l
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unbarrieredSet
(
newKey
)
;
}
}
;
template
<
class
T
>
struct
WeakHeapPtrHasher
{
using
Key
=
WeakHeapPtr
<
T
>
;
using
Lookup
=
T
;
static
HashNumber
hash
(
Lookup
obj
)
{
return
DefaultHasher
<
T
>
:
:
hash
(
obj
)
;
}
static
bool
match
(
const
Key
&
k
Lookup
l
)
{
return
k
.
unbarrieredGet
(
)
=
=
l
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
set
(
newKey
.
unbarrieredGet
(
)
)
;
}
}
;
template
<
class
T
>
struct
UnsafeBarePtrHasher
{
using
Key
=
UnsafeBarePtr
<
T
>
;
using
Lookup
=
T
;
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
DefaultHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
Lookup
l
)
{
return
k
.
get
(
)
=
=
l
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
set
(
newKey
.
get
(
)
)
;
}
}
;
}
namespace
mozilla
{
template
<
class
T
>
struct
DefaultHasher
<
js
:
:
HeapPtr
<
T
>
>
:
js
:
:
HeapPtrHasher
<
T
>
{
}
;
template
<
class
T
>
struct
DefaultHasher
<
js
:
:
GCPtr
<
T
>
>
{
}
;
template
<
class
T
>
struct
DefaultHasher
<
js
:
:
PreBarriered
<
T
>
>
:
js
:
:
PreBarrieredHasher
<
T
>
{
}
;
template
<
class
T
>
struct
DefaultHasher
<
js
:
:
WeakHeapPtr
<
T
>
>
:
js
:
:
WeakHeapPtrHasher
<
T
>
{
}
;
template
<
class
T
>
struct
DefaultHasher
<
js
:
:
UnsafeBarePtr
<
T
>
>
:
js
:
:
UnsafeBarePtrHasher
<
T
>
{
}
;
}
#
endif
