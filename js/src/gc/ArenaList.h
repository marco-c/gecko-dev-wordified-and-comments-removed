#
ifndef
gc_ArenaList_h
#
define
gc_ArenaList_h
#
include
"
gc
/
Heap
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
namespace
JS
{
struct
Zone
;
}
namespace
js
{
class
Nursery
;
class
TenuringTracer
;
namespace
gc
{
struct
FinalizePhase
;
struct
SortedArenaListSegment
{
Arena
*
head
;
Arena
*
*
tailp
;
void
clear
(
)
{
head
=
nullptr
;
tailp
=
&
head
;
}
bool
isEmpty
(
)
const
{
return
tailp
=
=
&
head
;
}
void
append
(
Arena
*
arena
)
{
MOZ_ASSERT
(
arena
)
;
MOZ_ASSERT_IF
(
head
head
-
>
getAllocKind
(
)
=
=
arena
-
>
getAllocKind
(
)
)
;
*
tailp
=
arena
;
tailp
=
&
arena
-
>
next
;
}
void
linkTo
(
Arena
*
arena
)
{
*
tailp
=
arena
;
}
}
;
class
ArenaList
{
Arena
*
head_
;
Arena
*
*
cursorp_
;
void
copy
(
const
ArenaList
&
other
)
{
other
.
check
(
)
;
head_
=
other
.
head_
;
cursorp_
=
other
.
isCursorAtHead
(
)
?
&
head_
:
other
.
cursorp_
;
check
(
)
;
}
public
:
ArenaList
(
)
{
clear
(
)
;
}
ArenaList
(
const
ArenaList
&
other
)
{
copy
(
other
)
;
}
ArenaList
&
operator
=
(
const
ArenaList
&
other
)
{
copy
(
other
)
;
return
*
this
;
}
explicit
ArenaList
(
const
SortedArenaListSegment
&
segment
)
{
head_
=
segment
.
head
;
cursorp_
=
segment
.
isEmpty
(
)
?
&
head_
:
segment
.
tailp
;
check
(
)
;
}
void
check
(
)
const
{
#
ifdef
DEBUG
MOZ_ASSERT_IF
(
!
head_
cursorp_
=
=
&
head_
)
;
Arena
*
cursor
=
*
cursorp_
;
MOZ_ASSERT_IF
(
cursor
cursor
-
>
hasFreeThings
(
)
)
;
#
endif
}
void
clear
(
)
{
head_
=
nullptr
;
cursorp_
=
&
head_
;
check
(
)
;
}
ArenaList
copyAndClear
(
)
{
ArenaList
result
=
*
this
;
clear
(
)
;
return
result
;
}
bool
isEmpty
(
)
const
{
check
(
)
;
return
!
head_
;
}
Arena
*
head
(
)
const
{
check
(
)
;
return
head_
;
}
bool
isCursorAtHead
(
)
const
{
check
(
)
;
return
cursorp_
=
=
&
head_
;
}
bool
isCursorAtEnd
(
)
const
{
check
(
)
;
return
!
*
cursorp_
;
}
void
moveCursorToEnd
(
)
{
while
(
!
isCursorAtEnd
(
)
)
cursorp_
=
&
(
*
cursorp_
)
-
>
next
;
}
Arena
*
arenaAfterCursor
(
)
const
{
check
(
)
;
return
*
cursorp_
;
}
Arena
*
takeNextArena
(
)
{
check
(
)
;
Arena
*
arena
=
*
cursorp_
;
if
(
!
arena
)
return
nullptr
;
cursorp_
=
&
arena
-
>
next
;
check
(
)
;
return
arena
;
}
void
insertAtCursor
(
Arena
*
a
)
{
check
(
)
;
a
-
>
next
=
*
cursorp_
;
*
cursorp_
=
a
;
if
(
!
a
-
>
hasFreeThings
(
)
)
cursorp_
=
&
a
-
>
next
;
check
(
)
;
}
void
insertBeforeCursor
(
Arena
*
a
)
{
check
(
)
;
a
-
>
next
=
*
cursorp_
;
*
cursorp_
=
a
;
cursorp_
=
&
a
-
>
next
;
check
(
)
;
}
ArenaList
&
insertListWithCursorAtEnd
(
const
ArenaList
&
other
)
{
check
(
)
;
other
.
check
(
)
;
MOZ_ASSERT
(
other
.
isCursorAtEnd
(
)
)
;
if
(
other
.
isCursorAtHead
(
)
)
return
*
this
;
*
other
.
cursorp_
=
*
cursorp_
;
*
cursorp_
=
other
.
head_
;
cursorp_
=
other
.
cursorp_
;
check
(
)
;
return
*
this
;
}
Arena
*
removeRemainingArenas
(
Arena
*
*
arenap
)
;
Arena
*
*
pickArenasToRelocate
(
size_t
&
arenaTotalOut
size_t
&
relocTotalOut
)
;
Arena
*
relocateArenas
(
Arena
*
toRelocate
Arena
*
relocated
js
:
:
SliceBudget
&
sliceBudget
gcstats
:
:
Statistics
&
stats
)
;
}
;
class
SortedArenaList
{
public
:
static
const
size_t
MinThingSize
=
16
;
static_assert
(
ArenaSize
<
=
4096
"
When
increasing
the
Arena
size
please
consider
how
"
\
"
this
will
affect
the
size
of
a
SortedArenaList
.
"
)
;
static_assert
(
MinThingSize
>
=
16
"
When
decreasing
the
minimum
thing
size
please
consider
"
\
"
how
this
will
affect
the
size
of
a
SortedArenaList
.
"
)
;
private
:
static
const
size_t
MaxThingsPerArena
=
(
ArenaSize
-
ArenaHeaderSize
)
/
MinThingSize
;
size_t
thingsPerArena_
;
SortedArenaListSegment
segments
[
MaxThingsPerArena
+
1
]
;
Arena
*
headAt
(
size_t
n
)
{
return
segments
[
n
]
.
head
;
}
Arena
*
*
tailAt
(
size_t
n
)
{
return
segments
[
n
]
.
tailp
;
}
public
:
explicit
SortedArenaList
(
size_t
thingsPerArena
=
MaxThingsPerArena
)
{
reset
(
thingsPerArena
)
;
}
void
setThingsPerArena
(
size_t
thingsPerArena
)
{
MOZ_ASSERT
(
thingsPerArena
&
&
thingsPerArena
<
=
MaxThingsPerArena
)
;
thingsPerArena_
=
thingsPerArena
;
}
void
reset
(
size_t
thingsPerArena
=
MaxThingsPerArena
)
{
setThingsPerArena
(
thingsPerArena
)
;
for
(
size_t
i
=
0
;
i
<
=
thingsPerArena
;
+
+
i
)
segments
[
i
]
.
clear
(
)
;
}
void
insertAt
(
Arena
*
arena
size_t
nfree
)
{
MOZ_ASSERT
(
nfree
<
=
thingsPerArena_
)
;
segments
[
nfree
]
.
append
(
arena
)
;
}
void
extractEmpty
(
Arena
*
*
empty
)
{
SortedArenaListSegment
&
segment
=
segments
[
thingsPerArena_
]
;
if
(
segment
.
head
)
{
*
segment
.
tailp
=
*
empty
;
*
empty
=
segment
.
head
;
segment
.
clear
(
)
;
}
}
ArenaList
toArenaList
(
)
{
size_t
tailIndex
=
0
;
for
(
size_t
headIndex
=
1
;
headIndex
<
=
thingsPerArena_
;
+
+
headIndex
)
{
if
(
headAt
(
headIndex
)
)
{
segments
[
tailIndex
]
.
linkTo
(
headAt
(
headIndex
)
)
;
tailIndex
=
headIndex
;
}
}
segments
[
tailIndex
]
.
linkTo
(
nullptr
)
;
return
ArenaList
(
segments
[
0
]
)
;
}
}
;
enum
class
ShouldCheckThresholds
{
DontCheckThresholds
=
0
CheckThresholds
=
1
}
;
class
ArenaLists
{
JSRuntime
*
const
runtime_
;
ZoneGroupData
<
AllAllocKindArray
<
FreeSpan
*
>
>
freeLists_
;
FreeSpan
*
&
freeLists
(
AllocKind
i
)
{
return
freeLists_
.
ref
(
)
[
i
]
;
}
FreeSpan
*
freeLists
(
AllocKind
i
)
const
{
return
freeLists_
.
ref
(
)
[
i
]
;
}
static
FreeSpan
placeholder
;
ZoneGroupOrGCTaskData
<
AllAllocKindArray
<
ArenaList
>
>
arenaLists_
;
ArenaList
&
arenaLists
(
AllocKind
i
)
{
return
arenaLists_
.
ref
(
)
[
i
]
;
}
const
ArenaList
&
arenaLists
(
AllocKind
i
)
const
{
return
arenaLists_
.
ref
(
)
[
i
]
;
}
enum
BackgroundFinalizeStateEnum
{
BFS_DONE
BFS_RUN
}
;
typedef
mozilla
:
:
Atomic
<
BackgroundFinalizeStateEnum
mozilla
:
:
SequentiallyConsistent
>
BackgroundFinalizeState
;
UnprotectedData
<
AllAllocKindArray
<
BackgroundFinalizeState
>
>
backgroundFinalizeState_
;
BackgroundFinalizeState
&
backgroundFinalizeState
(
AllocKind
i
)
{
return
backgroundFinalizeState_
.
ref
(
)
[
i
]
;
}
const
BackgroundFinalizeState
&
backgroundFinalizeState
(
AllocKind
i
)
const
{
return
backgroundFinalizeState_
.
ref
(
)
[
i
]
;
}
ActiveThreadOrGCTaskData
<
AllAllocKindArray
<
Arena
*
>
>
arenaListsToSweep_
;
Arena
*
&
arenaListsToSweep
(
AllocKind
i
)
{
return
arenaListsToSweep_
.
ref
(
)
[
i
]
;
}
Arena
*
arenaListsToSweep
(
AllocKind
i
)
const
{
return
arenaListsToSweep_
.
ref
(
)
[
i
]
;
}
ZoneGroupOrGCTaskData
<
AllocKind
>
incrementalSweptArenaKind
;
ZoneGroupOrGCTaskData
<
ArenaList
>
incrementalSweptArenas
;
ZoneGroupData
<
Arena
*
>
gcShapeArenasToUpdate
;
ZoneGroupData
<
Arena
*
>
gcAccessorShapeArenasToUpdate
;
ZoneGroupData
<
Arena
*
>
gcScriptArenasToUpdate
;
ZoneGroupData
<
Arena
*
>
gcObjectGroupArenasToUpdate
;
ZoneGroupData
<
ObjectAllocKindArray
<
ArenaList
>
>
savedObjectArenas_
;
ArenaList
&
savedObjectArenas
(
AllocKind
i
)
{
return
savedObjectArenas_
.
ref
(
)
[
i
]
;
}
ZoneGroupData
<
Arena
*
>
savedEmptyObjectArenas
;
public
:
explicit
ArenaLists
(
JSRuntime
*
rt
ZoneGroup
*
group
)
;
~
ArenaLists
(
)
;
const
void
*
addressOfFreeList
(
AllocKind
thingKind
)
const
{
return
reinterpret_cast
<
const
void
*
>
(
&
freeLists_
.
refNoCheck
(
)
[
thingKind
]
)
;
}
Arena
*
getFirstArena
(
AllocKind
thingKind
)
const
{
return
arenaLists
(
thingKind
)
.
head
(
)
;
}
Arena
*
getFirstArenaToSweep
(
AllocKind
thingKind
)
const
{
return
arenaListsToSweep
(
thingKind
)
;
}
Arena
*
getFirstSweptArena
(
AllocKind
thingKind
)
const
{
if
(
thingKind
!
=
incrementalSweptArenaKind
.
ref
(
)
)
return
nullptr
;
return
incrementalSweptArenas
.
ref
(
)
.
head
(
)
;
}
Arena
*
getArenaAfterCursor
(
AllocKind
thingKind
)
const
{
return
arenaLists
(
thingKind
)
.
arenaAfterCursor
(
)
;
}
bool
arenaListsAreEmpty
(
)
const
{
for
(
auto
i
:
AllAllocKinds
(
)
)
{
if
(
backgroundFinalizeState
(
i
)
!
=
BFS_DONE
)
return
false
;
if
(
!
arenaLists
(
i
)
.
isEmpty
(
)
)
return
false
;
}
return
true
;
}
void
unmarkAll
(
)
{
for
(
auto
i
:
AllAllocKinds
(
)
)
{
MOZ_ASSERT
(
backgroundFinalizeState
(
i
)
=
=
BFS_DONE
)
;
for
(
Arena
*
arena
=
arenaLists
(
i
)
.
head
(
)
;
arena
;
arena
=
arena
-
>
next
)
arena
-
>
unmarkAll
(
)
;
}
}
bool
doneBackgroundFinalize
(
AllocKind
kind
)
const
{
return
backgroundFinalizeState
(
kind
)
=
=
BFS_DONE
;
}
bool
needBackgroundFinalizeWait
(
AllocKind
kind
)
const
{
return
backgroundFinalizeState
(
kind
)
!
=
BFS_DONE
;
}
void
purge
(
)
{
for
(
auto
i
:
AllAllocKinds
(
)
)
freeLists
(
i
)
=
&
placeholder
;
}
inline
void
prepareForIncrementalGC
(
)
;
bool
arenaIsInUse
(
Arena
*
arena
AllocKind
kind
)
const
{
MOZ_ASSERT
(
arena
)
;
return
arena
=
=
freeLists
(
kind
)
-
>
getArenaUnchecked
(
)
;
}
MOZ_ALWAYS_INLINE
TenuredCell
*
allocateFromFreeList
(
AllocKind
thingKind
size_t
thingSize
)
{
return
freeLists
(
thingKind
)
-
>
allocate
(
thingSize
)
;
}
void
adoptArenas
(
JSRuntime
*
runtime
ArenaLists
*
fromArenaLists
bool
targetZoneIsCollecting
)
;
bool
containsArena
(
JSRuntime
*
runtime
Arena
*
arena
)
;
void
checkEmptyFreeLists
(
)
{
#
ifdef
DEBUG
for
(
auto
i
:
AllAllocKinds
(
)
)
checkEmptyFreeList
(
i
)
;
#
endif
}
bool
checkEmptyArenaLists
(
)
{
bool
empty
=
true
;
#
ifdef
DEBUG
for
(
auto
i
:
AllAllocKinds
(
)
)
{
if
(
!
checkEmptyArenaList
(
i
)
)
empty
=
false
;
}
#
endif
return
empty
;
}
void
checkEmptyFreeList
(
AllocKind
kind
)
{
MOZ_ASSERT
(
freeLists
(
kind
)
-
>
isEmpty
(
)
)
;
}
bool
checkEmptyArenaList
(
AllocKind
kind
)
;
bool
relocateArenas
(
JS
:
:
Zone
*
zone
Arena
*
&
relocatedListOut
JS
:
:
gcreason
:
:
Reason
reason
js
:
:
SliceBudget
&
sliceBudget
gcstats
:
:
Statistics
&
stats
)
;
void
queueForegroundObjectsForSweep
(
FreeOp
*
fop
)
;
void
queueForegroundThingsForSweep
(
FreeOp
*
fop
)
;
void
mergeForegroundSweptObjectArenas
(
)
;
bool
foregroundFinalize
(
FreeOp
*
fop
AllocKind
thingKind
js
:
:
SliceBudget
&
sliceBudget
SortedArenaList
&
sweepList
)
;
static
void
backgroundFinalize
(
FreeOp
*
fop
Arena
*
listHead
Arena
*
*
empty
)
;
enum
KeepArenasEnum
{
RELEASE_ARENAS
KEEP_ARENAS
}
;
private
:
inline
void
queueForForegroundSweep
(
FreeOp
*
fop
const
FinalizePhase
&
phase
)
;
inline
void
queueForBackgroundSweep
(
FreeOp
*
fop
const
FinalizePhase
&
phase
)
;
inline
void
queueForForegroundSweep
(
FreeOp
*
fop
AllocKind
thingKind
)
;
inline
void
queueForBackgroundSweep
(
FreeOp
*
fop
AllocKind
thingKind
)
;
inline
void
mergeSweptArenas
(
AllocKind
thingKind
)
;
TenuredCell
*
allocateFromArena
(
JS
:
:
Zone
*
zone
AllocKind
thingKind
ShouldCheckThresholds
checkThresholds
)
;
inline
TenuredCell
*
allocateFromArenaInner
(
JS
:
:
Zone
*
zone
Arena
*
arena
AllocKind
kind
)
;
friend
class
GCRuntime
;
friend
class
js
:
:
Nursery
;
friend
class
js
:
:
TenuringTracer
;
}
;
}
}
#
endif
