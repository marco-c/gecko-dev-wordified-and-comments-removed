#
ifndef
gc_ArenaList_h
#
define
gc_ArenaList_h
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
namespace
js
{
class
Nursery
;
class
TenuringTracer
;
namespace
gcstats
{
struct
Statistics
;
}
namespace
gc
{
class
Arena
;
class
BackgroundUnmarkTask
;
struct
FinalizePhase
;
class
FreeSpan
;
class
TenuredCell
;
struct
SortedArenaListSegment
{
Arena
*
head
;
Arena
*
*
tailp
;
void
clear
(
)
{
head
=
nullptr
;
tailp
=
&
head
;
}
bool
isEmpty
(
)
const
{
return
tailp
=
=
&
head
;
}
inline
void
append
(
Arena
*
arena
)
;
void
linkTo
(
Arena
*
arena
)
{
*
tailp
=
arena
;
}
}
;
class
ArenaList
{
Arena
*
head_
;
Arena
*
*
cursorp_
;
inline
void
moveFrom
(
ArenaList
&
other
)
;
public
:
inline
ArenaList
(
)
;
inline
ArenaList
(
ArenaList
&
&
other
)
;
inline
~
ArenaList
(
)
;
inline
ArenaList
&
operator
=
(
ArenaList
&
&
other
)
;
ArenaList
(
const
ArenaList
&
other
)
=
delete
;
ArenaList
&
operator
=
(
const
ArenaList
&
other
)
=
delete
;
inline
explicit
ArenaList
(
const
SortedArenaListSegment
&
segment
)
;
inline
void
check
(
)
const
;
inline
void
clear
(
)
;
inline
bool
isEmpty
(
)
const
;
inline
Arena
*
head
(
)
const
;
inline
bool
isCursorAtHead
(
)
const
;
inline
bool
isCursorAtEnd
(
)
const
;
inline
Arena
*
arenaAfterCursor
(
)
const
;
inline
Arena
*
takeNextArena
(
)
;
inline
void
insertAtCursor
(
Arena
*
a
)
;
inline
void
insertBeforeCursor
(
Arena
*
a
)
;
inline
ArenaList
&
insertListWithCursorAtEnd
(
ArenaList
&
other
)
;
inline
Arena
*
takeFirstArena
(
)
;
Arena
*
removeRemainingArenas
(
Arena
*
*
arenap
)
;
Arena
*
*
pickArenasToRelocate
(
size_t
&
arenaTotalOut
size_t
&
relocTotalOut
)
;
Arena
*
relocateArenas
(
Arena
*
toRelocate
Arena
*
relocated
js
:
:
SliceBudget
&
sliceBudget
gcstats
:
:
Statistics
&
stats
)
;
#
ifdef
DEBUG
void
dump
(
)
;
#
endif
}
;
class
SortedArenaList
{
public
:
static
const
size_t
MinThingSize
=
16
;
static_assert
(
ArenaSize
<
=
4096
"
When
increasing
the
Arena
size
please
consider
how
"
"
this
will
affect
the
size
of
a
SortedArenaList
.
"
)
;
static_assert
(
MinThingSize
>
=
16
"
When
decreasing
the
minimum
thing
size
please
consider
"
"
how
this
will
affect
the
size
of
a
SortedArenaList
.
"
)
;
private
:
static
const
size_t
MaxThingsPerArena
=
(
ArenaSize
-
ArenaHeaderSize
)
/
MinThingSize
;
size_t
thingsPerArena_
;
SortedArenaListSegment
segments
[
MaxThingsPerArena
+
1
]
;
Arena
*
headAt
(
size_t
n
)
{
return
segments
[
n
]
.
head
;
}
Arena
*
*
tailAt
(
size_t
n
)
{
return
segments
[
n
]
.
tailp
;
}
public
:
inline
explicit
SortedArenaList
(
size_t
thingsPerArena
=
MaxThingsPerArena
)
;
inline
void
setThingsPerArena
(
size_t
thingsPerArena
)
;
inline
void
reset
(
size_t
thingsPerArena
=
MaxThingsPerArena
)
;
inline
void
insertAt
(
Arena
*
arena
size_t
nfree
)
;
inline
void
extractEmpty
(
Arena
*
*
empty
)
;
inline
ArenaList
toArenaList
(
)
;
}
;
enum
class
ShouldCheckThresholds
{
DontCheckThresholds
=
0
CheckThresholds
=
1
}
;
class
FreeLists
{
AllAllocKindArray
<
FreeSpan
*
>
freeLists_
;
public
:
static
FreeSpan
emptySentinel
;
FreeLists
(
)
;
#
ifdef
DEBUG
inline
bool
allEmpty
(
)
const
;
inline
bool
isEmpty
(
AllocKind
kind
)
const
;
#
endif
inline
void
clear
(
)
;
MOZ_ALWAYS_INLINE
TenuredCell
*
allocate
(
AllocKind
kind
)
;
inline
TenuredCell
*
setArenaAndAllocate
(
Arena
*
arena
AllocKind
kind
)
;
inline
void
unmarkPreMarkedFreeCells
(
AllocKind
kind
)
;
FreeSpan
*
*
addressOfFreeList
(
AllocKind
thingKind
)
{
return
&
freeLists_
[
thingKind
]
;
}
}
;
class
ArenaLists
{
enum
class
ConcurrentUse
:
uint32_t
{
None
BackgroundFinalize
ParallelUnmark
}
;
using
ConcurrentUseState
=
mozilla
:
:
Atomic
<
ConcurrentUse
mozilla
:
:
SequentiallyConsistent
>
;
JS
:
:
Zone
*
zone_
;
UnprotectedData
<
AllAllocKindArray
<
ConcurrentUseState
>
>
concurrentUseState_
;
ZoneData
<
FreeLists
>
freeLists_
;
ArenaListData
<
AllAllocKindArray
<
ArenaList
>
>
arenaLists_
;
ZoneOrGCTaskData
<
AllAllocKindArray
<
ArenaList
>
>
collectingArenaLists_
;
ZoneOrGCTaskData
<
AllocKind
>
incrementalSweptArenaKind
;
ZoneOrGCTaskData
<
ArenaList
>
incrementalSweptArenas
;
ZoneData
<
Arena
*
>
gcCompactPropMapArenasToUpdate
;
ZoneData
<
Arena
*
>
gcNormalPropMapArenasToUpdate
;
ZoneOrGCTaskData
<
Arena
*
>
savedEmptyArenas
;
public
:
explicit
ArenaLists
(
JS
:
:
Zone
*
zone
)
;
~
ArenaLists
(
)
;
FreeLists
&
freeLists
(
)
{
return
freeLists_
.
ref
(
)
;
}
const
FreeLists
&
freeLists
(
)
const
{
return
freeLists_
.
ref
(
)
;
}
FreeSpan
*
*
addressOfFreeList
(
AllocKind
thingKind
)
{
return
freeLists_
.
refNoCheck
(
)
.
addressOfFreeList
(
thingKind
)
;
}
inline
Arena
*
getFirstArena
(
AllocKind
thingKind
)
const
;
inline
Arena
*
getFirstCollectingArena
(
AllocKind
thingKind
)
const
;
inline
Arena
*
getFirstSweptArena
(
AllocKind
thingKind
)
const
;
inline
Arena
*
getArenaAfterCursor
(
AllocKind
thingKind
)
const
;
inline
bool
arenaListsAreEmpty
(
)
const
;
inline
bool
doneBackgroundFinalize
(
AllocKind
kind
)
const
;
inline
bool
needBackgroundFinalizeWait
(
AllocKind
kind
)
const
;
inline
void
clearFreeLists
(
)
;
inline
void
unmarkPreMarkedFreeCells
(
)
;
MOZ_ALWAYS_INLINE
TenuredCell
*
allocateFromFreeList
(
AllocKind
thingKind
)
;
inline
void
checkEmptyFreeLists
(
)
;
inline
void
checkEmptyArenaLists
(
)
;
inline
void
checkEmptyFreeList
(
AllocKind
kind
)
;
void
checkEmptyArenaList
(
AllocKind
kind
)
;
bool
relocateArenas
(
Arena
*
&
relocatedListOut
JS
:
:
GCReason
reason
js
:
:
SliceBudget
&
sliceBudget
gcstats
:
:
Statistics
&
stats
)
;
void
queueForegroundObjectsForSweep
(
JSFreeOp
*
fop
)
;
void
queueForegroundThingsForSweep
(
)
;
Arena
*
takeSweptEmptyArenas
(
)
;
void
setIncrementalSweptArenas
(
AllocKind
kind
SortedArenaList
&
arenas
)
;
void
clearIncrementalSweptArenas
(
)
;
void
mergeFinalizedArenas
(
AllocKind
thingKind
SortedArenaList
&
finalizedArenas
)
;
void
setParallelUnmarkEnabled
(
bool
enabled
)
;
void
moveArenasToCollectingLists
(
)
;
void
mergeArenasFromCollectingLists
(
)
;
void
checkGCStateNotInUse
(
)
;
void
checkSweepStateNotInUse
(
)
;
void
checkNoArenasToUpdate
(
)
;
void
checkNoArenasToUpdateForKind
(
AllocKind
kind
)
;
private
:
ArenaList
&
arenaList
(
AllocKind
i
)
{
return
arenaLists_
.
ref
(
)
[
i
]
;
}
const
ArenaList
&
arenaList
(
AllocKind
i
)
const
{
return
arenaLists_
.
ref
(
)
[
i
]
;
}
ArenaList
&
collectingArenaList
(
AllocKind
i
)
{
return
collectingArenaLists_
.
ref
(
)
[
i
]
;
}
const
ArenaList
&
collectingArenaList
(
AllocKind
i
)
const
{
return
collectingArenaLists_
.
ref
(
)
[
i
]
;
}
ConcurrentUseState
&
concurrentUse
(
AllocKind
i
)
{
return
concurrentUseState_
.
ref
(
)
[
i
]
;
}
ConcurrentUse
concurrentUse
(
AllocKind
i
)
const
{
return
concurrentUseState_
.
ref
(
)
[
i
]
;
}
inline
JSRuntime
*
runtime
(
)
;
inline
JSRuntime
*
runtimeFromAnyThread
(
)
;
void
initBackgroundSweep
(
AllocKind
thingKind
)
;
TenuredCell
*
refillFreeListAndAllocate
(
FreeLists
&
freeLists
AllocKind
thingKind
ShouldCheckThresholds
checkThresholds
)
;
friend
class
BackgroundUnmarkTask
;
friend
class
GCRuntime
;
friend
class
js
:
:
Nursery
;
friend
class
js
:
:
TenuringTracer
;
}
;
}
}
#
endif
