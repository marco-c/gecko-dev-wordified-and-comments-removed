#
ifndef
gc_ArenaList_h
#
define
gc_ArenaList_h
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
namespace
js
{
class
FreeOp
;
class
Nursery
;
class
TenuringTracer
;
namespace
gcstats
{
struct
Statistics
;
}
namespace
gc
{
class
Arena
;
struct
FinalizePhase
;
class
FreeSpan
;
class
TenuredCell
;
struct
SortedArenaListSegment
{
Arena
*
head
;
Arena
*
*
tailp
;
void
clear
(
)
{
head
=
nullptr
;
tailp
=
&
head
;
}
bool
isEmpty
(
)
const
{
return
tailp
=
=
&
head
;
}
inline
void
append
(
Arena
*
arena
)
;
void
linkTo
(
Arena
*
arena
)
{
*
tailp
=
arena
;
}
}
;
class
ArenaList
{
Arena
*
head_
;
Arena
*
*
cursorp_
;
inline
void
copy
(
const
ArenaList
&
other
)
;
public
:
inline
ArenaList
(
)
;
inline
ArenaList
(
const
ArenaList
&
other
)
;
inline
ArenaList
&
operator
=
(
const
ArenaList
&
other
)
;
inline
explicit
ArenaList
(
const
SortedArenaListSegment
&
segment
)
;
inline
void
check
(
)
const
;
inline
void
clear
(
)
;
inline
ArenaList
copyAndClear
(
)
;
inline
bool
isEmpty
(
)
const
;
inline
Arena
*
head
(
)
const
;
inline
bool
isCursorAtHead
(
)
const
;
inline
bool
isCursorAtEnd
(
)
const
;
inline
void
moveCursorToEnd
(
)
;
inline
Arena
*
arenaAfterCursor
(
)
const
;
inline
Arena
*
takeNextArena
(
)
;
inline
void
insertAtCursor
(
Arena
*
a
)
;
inline
void
insertBeforeCursor
(
Arena
*
a
)
;
inline
ArenaList
&
insertListWithCursorAtEnd
(
const
ArenaList
&
other
)
;
Arena
*
removeRemainingArenas
(
Arena
*
*
arenap
)
;
Arena
*
*
pickArenasToRelocate
(
size_t
&
arenaTotalOut
size_t
&
relocTotalOut
)
;
Arena
*
relocateArenas
(
Arena
*
toRelocate
Arena
*
relocated
js
:
:
SliceBudget
&
sliceBudget
gcstats
:
:
Statistics
&
stats
)
;
}
;
class
SortedArenaList
{
public
:
static
const
size_t
MinThingSize
=
16
;
static_assert
(
ArenaSize
<
=
4096
"
When
increasing
the
Arena
size
please
consider
how
"
\
"
this
will
affect
the
size
of
a
SortedArenaList
.
"
)
;
static_assert
(
MinThingSize
>
=
16
"
When
decreasing
the
minimum
thing
size
please
consider
"
\
"
how
this
will
affect
the
size
of
a
SortedArenaList
.
"
)
;
private
:
static
const
size_t
MaxThingsPerArena
=
(
ArenaSize
-
ArenaHeaderSize
)
/
MinThingSize
;
size_t
thingsPerArena_
;
SortedArenaListSegment
segments
[
MaxThingsPerArena
+
1
]
;
Arena
*
headAt
(
size_t
n
)
{
return
segments
[
n
]
.
head
;
}
Arena
*
*
tailAt
(
size_t
n
)
{
return
segments
[
n
]
.
tailp
;
}
public
:
inline
explicit
SortedArenaList
(
size_t
thingsPerArena
=
MaxThingsPerArena
)
;
inline
void
setThingsPerArena
(
size_t
thingsPerArena
)
;
inline
void
reset
(
size_t
thingsPerArena
=
MaxThingsPerArena
)
;
inline
void
insertAt
(
Arena
*
arena
size_t
nfree
)
;
inline
void
extractEmpty
(
Arena
*
*
empty
)
;
inline
ArenaList
toArenaList
(
)
;
}
;
enum
class
ShouldCheckThresholds
{
DontCheckThresholds
=
0
CheckThresholds
=
1
}
;
class
FreeLists
{
AllAllocKindArray
<
FreeSpan
*
>
freeLists_
;
public
:
static
FreeSpan
emptySentinel
;
FreeLists
(
)
;
#
ifdef
DEBUG
inline
bool
allEmpty
(
)
const
;
inline
bool
isEmpty
(
AllocKind
kind
)
const
;
#
endif
inline
void
clear
(
AllocKind
i
)
;
MOZ_ALWAYS_INLINE
TenuredCell
*
allocate
(
AllocKind
kind
)
;
inline
TenuredCell
*
setArenaAndAllocate
(
Arena
*
arena
AllocKind
kind
)
;
inline
void
unmarkPreMarkedFreeCells
(
AllocKind
kind
)
;
const
void
*
addressOfFreeList
(
AllocKind
thingKind
)
const
{
return
&
freeLists_
[
thingKind
]
;
}
}
;
class
ArenaLists
{
JS
:
:
Zone
*
zone_
;
ZoneData
<
FreeLists
>
freeLists_
;
ZoneOrGCTaskData
<
AllAllocKindArray
<
ArenaList
>
>
arenaLists_
;
ArenaList
&
arenaLists
(
AllocKind
i
)
{
return
arenaLists_
.
ref
(
)
[
i
]
;
}
const
ArenaList
&
arenaLists
(
AllocKind
i
)
const
{
return
arenaLists_
.
ref
(
)
[
i
]
;
}
enum
BackgroundFinalizeStateEnum
{
BFS_DONE
BFS_RUN
}
;
typedef
mozilla
:
:
Atomic
<
BackgroundFinalizeStateEnum
mozilla
:
:
SequentiallyConsistent
>
BackgroundFinalizeState
;
UnprotectedData
<
AllAllocKindArray
<
BackgroundFinalizeState
>
>
backgroundFinalizeState_
;
BackgroundFinalizeState
&
backgroundFinalizeState
(
AllocKind
i
)
{
return
backgroundFinalizeState_
.
ref
(
)
[
i
]
;
}
const
BackgroundFinalizeState
&
backgroundFinalizeState
(
AllocKind
i
)
const
{
return
backgroundFinalizeState_
.
ref
(
)
[
i
]
;
}
MainThreadOrGCTaskData
<
AllAllocKindArray
<
Arena
*
>
>
arenaListsToSweep_
;
Arena
*
&
arenaListsToSweep
(
AllocKind
i
)
{
return
arenaListsToSweep_
.
ref
(
)
[
i
]
;
}
Arena
*
arenaListsToSweep
(
AllocKind
i
)
const
{
return
arenaListsToSweep_
.
ref
(
)
[
i
]
;
}
ZoneOrGCTaskData
<
AllocKind
>
incrementalSweptArenaKind
;
ZoneOrGCTaskData
<
ArenaList
>
incrementalSweptArenas
;
ZoneData
<
Arena
*
>
gcShapeArenasToUpdate
;
ZoneData
<
Arena
*
>
gcAccessorShapeArenasToUpdate
;
ZoneData
<
Arena
*
>
gcScriptArenasToUpdate
;
ZoneData
<
Arena
*
>
gcObjectGroupArenasToUpdate
;
ZoneData
<
Arena
*
>
savedEmptyArenas
;
public
:
explicit
ArenaLists
(
JS
:
:
Zone
*
zone
)
;
~
ArenaLists
(
)
;
FreeLists
&
freeLists
(
)
{
return
freeLists_
.
ref
(
)
;
}
const
FreeLists
&
freeLists
(
)
const
{
return
freeLists_
.
ref
(
)
;
}
const
void
*
addressOfFreeList
(
AllocKind
thingKind
)
const
{
return
freeLists_
.
refNoCheck
(
)
.
addressOfFreeList
(
thingKind
)
;
}
inline
Arena
*
getFirstArena
(
AllocKind
thingKind
)
const
;
inline
Arena
*
getFirstArenaToSweep
(
AllocKind
thingKind
)
const
;
inline
Arena
*
getFirstSweptArena
(
AllocKind
thingKind
)
const
;
inline
Arena
*
getArenaAfterCursor
(
AllocKind
thingKind
)
const
;
inline
bool
arenaListsAreEmpty
(
)
const
;
inline
void
unmarkAll
(
)
;
inline
bool
doneBackgroundFinalize
(
AllocKind
kind
)
const
;
inline
bool
needBackgroundFinalizeWait
(
AllocKind
kind
)
const
;
inline
void
clearFreeLists
(
)
;
inline
void
unmarkPreMarkedFreeCells
(
)
;
MOZ_ALWAYS_INLINE
TenuredCell
*
allocateFromFreeList
(
AllocKind
thingKind
)
;
void
adoptArenas
(
ArenaLists
*
fromArenaLists
bool
targetZoneIsCollecting
)
;
inline
void
checkEmptyFreeLists
(
)
;
inline
bool
checkEmptyArenaLists
(
)
;
inline
void
checkEmptyFreeList
(
AllocKind
kind
)
;
bool
checkEmptyArenaList
(
AllocKind
kind
)
;
bool
relocateArenas
(
Arena
*
&
relocatedListOut
JS
:
:
gcreason
:
:
Reason
reason
js
:
:
SliceBudget
&
sliceBudget
gcstats
:
:
Statistics
&
stats
)
;
void
queueForegroundObjectsForSweep
(
FreeOp
*
fop
)
;
void
queueForegroundThingsForSweep
(
)
;
void
releaseForegroundSweptEmptyArenas
(
)
;
bool
foregroundFinalize
(
FreeOp
*
fop
AllocKind
thingKind
js
:
:
SliceBudget
&
sliceBudget
SortedArenaList
&
sweepList
)
;
static
void
backgroundFinalize
(
FreeOp
*
fop
Arena
*
listHead
Arena
*
*
empty
)
;
enum
KeepArenasEnum
{
RELEASE_ARENAS
KEEP_ARENAS
}
;
private
:
inline
JSRuntime
*
runtime
(
)
;
inline
JSRuntime
*
runtimeFromAnyThread
(
)
;
inline
void
queueForForegroundSweep
(
FreeOp
*
fop
const
FinalizePhase
&
phase
)
;
inline
void
queueForBackgroundSweep
(
FreeOp
*
fop
const
FinalizePhase
&
phase
)
;
inline
void
queueForForegroundSweep
(
AllocKind
thingKind
)
;
inline
void
queueForBackgroundSweep
(
AllocKind
thingKind
)
;
TenuredCell
*
refillFreeListAndAllocate
(
FreeLists
&
freeLists
AllocKind
thingKind
ShouldCheckThresholds
checkThresholds
)
;
friend
class
GCRuntime
;
friend
class
js
:
:
Nursery
;
friend
class
js
:
:
TenuringTracer
;
}
;
}
}
#
endif
