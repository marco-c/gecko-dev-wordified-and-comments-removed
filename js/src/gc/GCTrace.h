#
ifndef
gc_GCTrace_h
#
define
gc_GCTrace_h
#
include
"
gc
/
Heap
.
h
"
namespace
js
{
class
ObjectGroup
;
namespace
gc
{
class
GCTrace
{
public
:
GCTrace
(
)
{
}
;
#
ifdef
JS_GC_TRACE
MOZ_MUST_USE
bool
initTrace
(
GCRuntime
&
gc
)
;
void
finishTrace
(
)
;
bool
traceEnabled
(
)
;
void
traceNurseryAlloc
(
Cell
*
thing
size_t
size
)
;
void
traceNurseryAlloc
(
Cell
*
thing
AllocKind
kind
)
;
void
traceTenuredAlloc
(
Cell
*
thing
AllocKind
kind
)
;
void
traceCreateObject
(
JSObject
*
object
)
;
void
traceMinorGCStart
(
)
;
void
tracePromoteToTenured
(
Cell
*
src
Cell
*
dst
)
;
void
traceMinorGCEnd
(
)
;
void
traceMajorGCStart
(
)
;
void
traceTenuredFinalize
(
Cell
*
thing
)
;
void
traceMajorGCEnd
(
)
;
void
traceTypeNewScript
(
js
:
:
ObjectGroup
*
group
)
;
private
:
FILE
*
gcTraceFile
=
nullptr
;
HashSet
<
const
JSClass
*
DefaultHasher
<
const
JSClass
*
>
SystemAllocPolicy
>
tracedClasses
;
HashSet
<
const
ObjectGroup
*
DefaultHasher
<
const
ObjectGroup
*
>
SystemAllocPolicy
>
tracedGroups
;
void
maybeTraceClass
(
const
JSClass
*
clasp
)
;
void
maybeTraceGroup
(
ObjectGroup
*
group
)
;
#
else
MOZ_MUST_USE
bool
initTrace
(
GCRuntime
&
gc
)
{
return
true
;
}
void
finishTrace
(
)
{
}
bool
traceEnabled
(
)
{
return
false
;
}
void
traceNurseryAlloc
(
Cell
*
thing
size_t
size
)
{
}
void
traceNurseryAlloc
(
Cell
*
thing
AllocKind
kind
)
{
}
void
traceTenuredAlloc
(
Cell
*
thing
AllocKind
kind
)
{
}
void
traceCreateObject
(
JSObject
*
object
)
{
}
void
traceMinorGCStart
(
)
{
}
void
tracePromoteToTenured
(
Cell
*
src
Cell
*
dst
)
{
}
void
traceMinorGCEnd
(
)
{
}
void
traceMajorGCStart
(
)
{
}
void
traceTenuredFinalize
(
Cell
*
thing
)
{
}
void
traceMajorGCEnd
(
)
{
}
void
traceTypeNewScript
(
js
:
:
ObjectGroup
*
group
)
{
}
#
endif
}
;
extern
GCTrace
gcTracer
;
}
}
#
endif
