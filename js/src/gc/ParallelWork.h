#
ifndef
gc_ParallelWork_h
#
define
gc_ParallelWork_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
algorithm
>
#
include
"
gc
/
GC
.
h
"
#
include
"
gc
/
GCParallelTask
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
vm
/
HelperThreads
.
h
"
namespace
js
{
namespace
gcstats
{
enum
class
PhaseKind
:
uint8_t
;
}
namespace
gc
{
template
<
typename
WorkItem
>
using
ParallelWorkFunc
=
size_t
(
*
)
(
GCRuntime
*
const
WorkItem
&
)
;
template
<
typename
WorkItem
typename
WorkItemIterator
>
class
ParallelWorker
:
public
GCParallelTask
{
public
:
using
WorkFunc
=
ParallelWorkFunc
<
WorkItem
>
;
ParallelWorker
(
GCRuntime
*
gc
gcstats
:
:
PhaseKind
phaseKind
GCUse
use
WorkFunc
func
WorkItemIterator
&
work
const
SliceBudget
&
budget
AutoLockHelperThreadState
&
lock
)
:
GCParallelTask
(
gc
phaseKind
use
)
func_
(
func
)
work_
(
work
)
budget_
(
budget
)
item_
(
work
.
get
(
)
)
{
work
.
next
(
)
;
}
void
run
(
AutoLockHelperThreadState
&
lock
)
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
for
(
;
;
)
{
size_t
steps
=
func_
(
gc
item_
)
;
budget_
.
step
(
std
:
:
max
(
steps
size_t
(
1
)
)
)
;
if
(
budget_
.
isOverBudget
(
)
)
{
break
;
}
AutoLockHelperThreadState
lock
;
if
(
work
(
)
.
done
(
)
)
{
break
;
}
item_
=
work
(
)
.
get
(
)
;
work
(
)
.
next
(
)
;
}
}
private
:
WorkItemIterator
&
work
(
)
{
return
work_
.
ref
(
)
;
}
WorkFunc
func_
;
HelperThreadLockData
<
WorkItemIterator
&
>
work_
;
SliceBudget
budget_
;
WorkItem
item_
;
}
;
static
constexpr
size_t
MaxParallelWorkers
=
8
;
extern
size_t
ParallelWorkerCount
(
)
;
template
<
typename
WorkItem
typename
WorkItemIterator
>
class
MOZ_RAII
AutoRunParallelWork
{
public
:
using
Worker
=
ParallelWorker
<
WorkItem
WorkItemIterator
>
;
using
WorkFunc
=
ParallelWorkFunc
<
WorkItem
>
;
AutoRunParallelWork
(
GCRuntime
*
gc
WorkFunc
func
gcstats
:
:
PhaseKind
phaseKind
GCUse
use
WorkItemIterator
&
work
const
SliceBudget
&
budget
AutoLockHelperThreadState
&
lock
)
:
gc
(
gc
)
phaseKind
(
phaseKind
)
lock
(
lock
)
tasksStarted
(
0
)
{
size_t
workerCount
=
gc
-
>
parallelWorkerCount
(
)
;
MOZ_ASSERT
(
workerCount
<
=
MaxParallelWorkers
)
;
MOZ_ASSERT_IF
(
workerCount
=
=
0
work
.
done
(
)
)
;
for
(
size_t
i
=
0
;
i
<
workerCount
&
&
!
work
.
done
(
)
;
i
+
+
)
{
tasks
[
i
]
.
emplace
(
gc
phaseKind
use
func
work
budget
lock
)
;
gc
-
>
startTask
(
*
tasks
[
i
]
lock
)
;
tasksStarted
+
+
;
}
}
~
AutoRunParallelWork
(
)
{
gHelperThreadLock
.
assertOwnedByCurrentThread
(
)
;
for
(
size_t
i
=
0
;
i
<
tasksStarted
;
i
+
+
)
{
gc
-
>
joinTask
(
*
tasks
[
i
]
lock
)
;
}
for
(
size_t
i
=
tasksStarted
;
i
<
MaxParallelWorkers
;
i
+
+
)
{
MOZ_ASSERT
(
tasks
[
i
]
.
isNothing
(
)
)
;
}
}
private
:
GCRuntime
*
gc
;
gcstats
:
:
PhaseKind
phaseKind
;
AutoLockHelperThreadState
&
lock
;
size_t
tasksStarted
;
mozilla
:
:
Maybe
<
Worker
>
tasks
[
MaxParallelWorkers
]
;
}
;
}
}
#
endif
