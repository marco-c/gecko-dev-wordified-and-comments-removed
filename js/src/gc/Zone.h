#
ifndef
gc_Zone_h
#
define
gc_Zone_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
ds
/
SplayTree
.
h
"
#
include
"
gc
/
FindSCCs
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
vm
/
MallocProvider
.
h
"
#
include
"
vm
/
TypeInference
.
h
"
namespace
js
{
namespace
jit
{
class
JitZone
;
}
namespace
gc
{
class
ZoneHeapThreshold
{
GCLockData
<
double
>
gcHeapGrowthFactor_
;
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
Relaxed
>
gcTriggerBytes_
;
public
:
ZoneHeapThreshold
(
)
:
gcHeapGrowthFactor_
(
3
.
0
)
gcTriggerBytes_
(
0
)
{
}
double
gcHeapGrowthFactor
(
)
const
{
return
gcHeapGrowthFactor_
;
}
size_t
gcTriggerBytes
(
)
const
{
return
gcTriggerBytes_
;
}
double
allocTrigger
(
bool
highFrequencyGC
)
const
;
void
updateAfterGC
(
size_t
lastBytes
JSGCInvocationKind
gckind
const
GCSchedulingTunables
&
tunables
const
GCSchedulingState
&
state
const
AutoLockGC
&
lock
)
;
void
updateForRemovedArena
(
const
GCSchedulingTunables
&
tunables
)
;
private
:
static
double
computeZoneHeapGrowthFactorForHeapSize
(
size_t
lastBytes
const
GCSchedulingTunables
&
tunables
const
GCSchedulingState
&
state
)
;
static
size_t
computeZoneTriggerBytes
(
double
growthFactor
size_t
lastBytes
JSGCInvocationKind
gckind
const
GCSchedulingTunables
&
tunables
const
AutoLockGC
&
lock
)
;
}
;
struct
ZoneComponentFinder
:
public
ComponentFinder
<
JS
:
:
Zone
ZoneComponentFinder
>
{
ZoneComponentFinder
(
uintptr_t
sl
AutoLockForExclusiveAccess
&
lock
)
:
ComponentFinder
<
JS
:
:
Zone
ZoneComponentFinder
>
(
sl
)
lock
(
lock
)
{
}
AutoLockForExclusiveAccess
&
lock
;
}
;
struct
UniqueIdGCPolicy
{
static
bool
needsSweep
(
Cell
*
*
cell
uint64_t
*
value
)
;
}
;
using
UniqueIdMap
=
GCHashMap
<
Cell
*
uint64_t
PointerHasher
<
Cell
*
3
>
SystemAllocPolicy
UniqueIdGCPolicy
>
;
extern
uint64_t
NextCellUniqueId
(
JSRuntime
*
rt
)
;
template
<
typename
T
>
class
ZoneCellIter
;
}
}
namespace
JS
{
struct
Zone
:
public
JS
:
:
shadow
:
:
Zone
public
js
:
:
gc
:
:
GraphNodeBase
<
JS
:
:
Zone
>
public
js
:
:
MallocProvider
<
JS
:
:
Zone
>
{
explicit
Zone
(
JSRuntime
*
rt
js
:
:
ZoneGroup
*
group
)
;
~
Zone
(
)
;
MOZ_MUST_USE
bool
init
(
bool
isSystem
)
;
private
:
js
:
:
ZoneGroup
*
const
group_
;
public
:
js
:
:
ZoneGroup
*
group
(
)
const
{
return
group_
;
}
static
size_t
offsetOfGroup
(
)
{
return
offsetof
(
Zone
group_
)
;
}
void
findOutgoingEdges
(
js
:
:
gc
:
:
ZoneComponentFinder
&
finder
)
;
void
discardJitCode
(
js
:
:
FreeOp
*
fop
bool
discardBaselineCode
=
true
)
;
void
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
size_t
*
typePool
size_t
*
baselineStubsOptimized
size_t
*
uniqueIdMap
size_t
*
shapeTables
size_t
*
atomsMarkBitmaps
)
;
void
resetGCMallocBytes
(
)
;
void
setGCMaxMallocBytes
(
size_t
value
)
;
void
updateMallocCounter
(
size_t
nbytes
)
{
gcMallocBytes
-
=
ptrdiff_t
(
nbytes
)
;
if
(
MOZ_UNLIKELY
(
isTooMuchMalloc
(
)
)
)
onTooMuchMalloc
(
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
js
:
:
gc
:
:
ZoneCellIter
<
T
>
cellIter
(
Args
&
&
.
.
.
args
)
{
return
js
:
:
gc
:
:
ZoneCellIter
<
T
>
(
const_cast
<
Zone
*
>
(
this
)
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
;
}
bool
isTooMuchMalloc
(
)
const
{
return
gcMallocBytes
<
=
0
;
}
void
onTooMuchMalloc
(
)
;
MOZ_MUST_USE
void
*
onOutOfMemory
(
js
:
:
AllocFunction
allocFunc
size_t
nbytes
void
*
reallocPtr
=
nullptr
)
{
if
(
!
js
:
:
CurrentThreadCanAccessRuntime
(
runtime_
)
)
return
nullptr
;
return
runtimeFromMainThread
(
)
-
>
onOutOfMemory
(
allocFunc
nbytes
reallocPtr
)
;
}
void
reportAllocationOverflow
(
)
{
js
:
:
ReportAllocationOverflow
(
nullptr
)
;
}
void
beginSweepTypes
(
js
:
:
FreeOp
*
fop
bool
releaseTypes
)
;
bool
hasMarkedCompartments
(
)
;
void
scheduleGC
(
)
{
MOZ_ASSERT
(
!
CurrentThreadIsHeapBusy
(
)
)
;
gcScheduled_
=
true
;
}
void
unscheduleGC
(
)
{
gcScheduled_
=
false
;
}
bool
isGCScheduled
(
)
{
return
gcScheduled_
&
&
canCollect
(
)
;
}
void
setPreservingCode
(
bool
preserving
)
{
gcPreserveCode_
=
preserving
;
}
bool
isPreservingCode
(
)
const
{
return
gcPreserveCode_
;
}
bool
canCollect
(
)
;
void
notifyObservingDebuggers
(
)
;
enum
GCState
{
NoGC
Mark
MarkGray
Sweep
Finished
Compact
}
;
void
setGCState
(
GCState
state
)
{
MOZ_ASSERT
(
CurrentThreadIsHeapBusy
(
)
)
;
MOZ_ASSERT_IF
(
state
!
=
NoGC
canCollect
(
)
)
;
gcState_
=
state
;
if
(
state
=
=
Finished
)
notifyObservingDebuggers
(
)
;
}
bool
isCollecting
(
)
const
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtimeFromMainThread
(
)
)
)
;
return
isCollectingFromAnyThread
(
)
;
}
bool
isCollectingFromAnyThread
(
)
const
{
if
(
CurrentThreadIsHeapCollecting
(
)
)
return
gcState_
!
=
NoGC
;
else
return
needsIncrementalBarrier
(
)
;
}
bool
requireGCTracer
(
)
const
{
JSRuntime
*
rt
=
runtimeFromAnyThread
(
)
;
return
CurrentThreadIsHeapMajorCollecting
(
)
&
&
!
rt
-
>
gc
.
isHeapCompacting
(
)
&
&
gcState_
!
=
NoGC
;
}
bool
isGCMarking
(
)
{
if
(
CurrentThreadIsHeapCollecting
(
)
)
return
gcState_
=
=
Mark
|
|
gcState_
=
=
MarkGray
;
else
return
needsIncrementalBarrier
(
)
;
}
GCState
gcState
(
)
const
{
return
gcState_
;
}
bool
wasGCStarted
(
)
const
{
return
gcState_
!
=
NoGC
;
}
bool
isGCMarkingBlack
(
)
{
return
gcState_
=
=
Mark
;
}
bool
isGCMarkingGray
(
)
{
return
gcState_
=
=
MarkGray
;
}
bool
isGCSweeping
(
)
{
return
gcState_
=
=
Sweep
;
}
bool
isGCFinished
(
)
{
return
gcState_
=
=
Finished
;
}
bool
isGCCompacting
(
)
{
return
gcState_
=
=
Compact
;
}
bool
isGCSweepingOrCompacting
(
)
{
return
gcState_
=
=
Sweep
|
|
gcState_
=
=
Compact
;
}
uint64_t
gcNumber
(
)
;
bool
compileBarriers
(
)
const
{
return
compileBarriers
(
needsIncrementalBarrier
(
)
)
;
}
bool
compileBarriers
(
bool
needsIncrementalBarrier
)
const
{
return
needsIncrementalBarrier
|
|
runtimeFromMainThread
(
)
-
>
hasZealMode
(
js
:
:
gc
:
:
ZealMode
:
:
VerifierPre
)
;
}
enum
ShouldUpdateJit
{
DontUpdateJit
UpdateJit
}
;
void
setNeedsIncrementalBarrier
(
bool
needs
ShouldUpdateJit
updateJit
)
;
const
bool
*
addressOfNeedsIncrementalBarrier
(
)
const
{
return
&
needsIncrementalBarrier_
;
}
js
:
:
jit
:
:
JitZone
*
getJitZone
(
JSContext
*
cx
)
{
return
jitZone_
?
jitZone_
:
createJitZone
(
cx
)
;
}
js
:
:
jit
:
:
JitZone
*
jitZone
(
)
{
return
jitZone_
;
}
bool
isAtomsZone
(
)
const
{
return
runtimeFromAnyThread
(
)
-
>
isAtomsZone
(
this
)
;
}
bool
isSelfHostingZone
(
)
const
{
return
runtimeFromAnyThread
(
)
-
>
isSelfHostingZone
(
this
)
;
}
void
prepareForCompacting
(
)
;
#
ifdef
DEBUG
unsigned
lastZoneGroupIndex
(
)
{
return
gcLastZoneGroupIndex
;
}
#
endif
using
DebuggerVector
=
js
:
:
Vector
<
js
:
:
Debugger
*
0
js
:
:
SystemAllocPolicy
>
;
private
:
js
:
:
ZoneGroupData
<
DebuggerVector
*
>
debuggers
;
void
sweepBreakpoints
(
js
:
:
FreeOp
*
fop
)
;
void
sweepUniqueIds
(
js
:
:
FreeOp
*
fop
)
;
void
sweepWeakMaps
(
)
;
void
sweepCompartments
(
js
:
:
FreeOp
*
fop
bool
keepAtleastOne
bool
lastGC
)
;
js
:
:
jit
:
:
JitZone
*
createJitZone
(
JSContext
*
cx
)
;
bool
isQueuedForBackgroundSweep
(
)
{
return
isOnList
(
)
;
}
js
:
:
ZoneGroupData
<
js
:
:
gc
:
:
UniqueIdMap
>
uniqueIds_
;
js
:
:
gc
:
:
UniqueIdMap
&
uniqueIds
(
)
{
return
uniqueIds_
.
ref
(
)
;
}
public
:
bool
hasDebuggers
(
)
const
{
return
debuggers
&
&
debuggers
-
>
length
(
)
;
}
DebuggerVector
*
getDebuggers
(
)
const
{
return
debuggers
;
}
DebuggerVector
*
getOrCreateDebuggers
(
JSContext
*
cx
)
;
void
clearTables
(
)
;
js
:
:
ZoneGroupData
<
bool
>
suppressAllocationMetadataBuilder
;
js
:
:
gc
:
:
ArenaLists
arenas
;
js
:
:
TypeZone
types
;
private
:
js
:
:
ZoneGroupData
<
mozilla
:
:
LinkedList
<
js
:
:
WeakMapBase
>
>
gcWeakMapList_
;
public
:
mozilla
:
:
LinkedList
<
js
:
:
WeakMapBase
>
&
gcWeakMapList
(
)
{
return
gcWeakMapList_
.
ref
(
)
;
}
typedef
js
:
:
Vector
<
JSCompartment
*
1
js
:
:
SystemAllocPolicy
>
CompartmentVector
;
private
:
js
:
:
ActiveThreadOrGCTaskData
<
CompartmentVector
>
compartments_
;
public
:
CompartmentVector
&
compartments
(
)
{
return
compartments_
.
ref
(
)
;
}
typedef
js
:
:
Vector
<
js
:
:
gc
:
:
Cell
*
0
js
:
:
SystemAllocPolicy
>
GrayRootVector
;
private
:
js
:
:
ZoneGroupData
<
GrayRootVector
>
gcGrayRoots_
;
public
:
GrayRootVector
&
gcGrayRoots
(
)
{
return
gcGrayRoots_
.
ref
(
)
;
}
using
WeakEdges
=
js
:
:
Vector
<
js
:
:
gc
:
:
TenuredCell
*
*
0
js
:
:
SystemAllocPolicy
>
;
private
:
js
:
:
ZoneGroupData
<
WeakEdges
>
gcWeakRefs_
;
public
:
WeakEdges
&
gcWeakRefs
(
)
{
return
gcWeakRefs_
.
ref
(
)
;
}
private
:
js
:
:
ZoneGroupData
<
mozilla
:
:
LinkedList
<
WeakCache
<
void
*
>
>
>
weakCaches_
;
public
:
mozilla
:
:
LinkedList
<
WeakCache
<
void
*
>
>
&
weakCaches
(
)
{
return
weakCaches_
.
ref
(
)
;
}
void
registerWeakCache
(
WeakCache
<
void
*
>
*
cachep
)
{
weakCaches
(
)
.
insertBack
(
cachep
)
;
}
private
:
js
:
:
ZoneGroupData
<
js
:
:
gc
:
:
WeakKeyTable
>
gcWeakKeys_
;
public
:
js
:
:
gc
:
:
WeakKeyTable
&
gcWeakKeys
(
)
{
return
gcWeakKeys_
.
ref
(
)
;
}
private
:
js
:
:
ZoneGroupData
<
ZoneSet
>
gcZoneGroupEdges_
;
public
:
ZoneSet
&
gcZoneGroupEdges
(
)
{
return
gcZoneGroupEdges_
.
ref
(
)
;
}
using
TypeDescrObjectSet
=
js
:
:
GCHashSet
<
JSObject
*
js
:
:
MovableCellHasher
<
JSObject
*
>
js
:
:
SystemAllocPolicy
>
;
private
:
js
:
:
ZoneGroupData
<
JS
:
:
WeakCache
<
TypeDescrObjectSet
>
>
typeDescrObjects_
;
public
:
JS
:
:
WeakCache
<
TypeDescrObjectSet
>
&
typeDescrObjects
(
)
{
return
typeDescrObjects_
.
ref
(
)
;
}
bool
addTypeDescrObject
(
JSContext
*
cx
HandleObject
obj
)
;
mozilla
:
:
Atomic
<
ptrdiff_t
mozilla
:
:
ReleaseAcquire
>
gcMallocBytes
;
js
:
:
ActiveThreadData
<
size_t
>
gcMaxMallocBytes
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
gcMallocGCTriggered
;
private
:
js
:
:
ZoneGroupOrGCTaskData
<
js
:
:
gc
:
:
AtomMarkingRuntime
:
:
Bitmap
>
markedAtoms_
;
public
:
js
:
:
gc
:
:
AtomMarkingRuntime
:
:
Bitmap
&
markedAtoms
(
)
{
return
markedAtoms_
.
ref
(
)
;
}
js
:
:
gc
:
:
HeapUsage
usage
;
js
:
:
gc
:
:
ZoneHeapThreshold
threshold
;
js
:
:
UnprotectedData
<
size_t
>
gcDelayBytes
;
private
:
js
:
:
ZoneGroupData
<
js
:
:
PropertyTree
>
propertyTree_
;
public
:
js
:
:
PropertyTree
&
propertyTree
(
)
{
return
propertyTree_
.
ref
(
)
;
}
private
:
js
:
:
ZoneGroupData
<
JS
:
:
WeakCache
<
js
:
:
BaseShapeSet
>
>
baseShapes_
;
public
:
JS
:
:
WeakCache
<
js
:
:
BaseShapeSet
>
&
baseShapes
(
)
{
return
baseShapes_
.
ref
(
)
;
}
private
:
js
:
:
ZoneGroupData
<
JS
:
:
WeakCache
<
js
:
:
InitialShapeSet
>
>
initialShapes_
;
public
:
JS
:
:
WeakCache
<
js
:
:
InitialShapeSet
>
&
initialShapes
(
)
{
return
initialShapes_
.
ref
(
)
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkInitialShapesTableAfterMovingGC
(
)
;
void
checkBaseShapeTableAfterMovingGC
(
)
;
#
endif
void
fixupInitialShapeTable
(
)
;
void
fixupAfterMovingGC
(
)
;
js
:
:
ZoneGroupData
<
void
*
>
data
;
js
:
:
ZoneGroupData
<
bool
>
isSystem
;
mozilla
:
:
Atomic
<
bool
>
usedByExclusiveThread
;
#
ifdef
DEBUG
js
:
:
ZoneGroupData
<
unsigned
>
gcLastZoneGroupIndex
;
#
endif
static
js
:
:
HashNumber
UniqueIdToHash
(
uint64_t
uid
)
{
return
js
:
:
HashNumber
(
uid
>
>
32
)
^
js
:
:
HashNumber
(
uid
&
0xFFFFFFFF
)
;
}
MOZ_MUST_USE
bool
getHashCode
(
js
:
:
gc
:
:
Cell
*
cell
js
:
:
HashNumber
*
hashp
)
{
uint64_t
uid
;
if
(
!
getUniqueId
(
cell
&
uid
)
)
return
false
;
*
hashp
=
UniqueIdToHash
(
uid
)
;
return
true
;
}
MOZ_MUST_USE
bool
getUniqueId
(
js
:
:
gc
:
:
Cell
*
cell
uint64_t
*
uidp
)
{
MOZ_ASSERT
(
uidp
)
;
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessZone
(
this
)
)
;
auto
p
=
uniqueIds
(
)
.
lookupForAdd
(
cell
)
;
if
(
p
)
{
*
uidp
=
p
-
>
value
(
)
;
return
true
;
}
*
uidp
=
js
:
:
gc
:
:
NextCellUniqueId
(
runtimeFromAnyThread
(
)
)
;
if
(
!
uniqueIds
(
)
.
add
(
p
cell
*
uidp
)
)
return
false
;
if
(
!
group
(
)
-
>
nursery
(
)
.
addedUniqueIdToCell
(
cell
)
)
{
uniqueIds
(
)
.
remove
(
cell
)
;
return
false
;
}
return
true
;
}
js
:
:
HashNumber
getHashCodeInfallible
(
js
:
:
gc
:
:
Cell
*
cell
)
{
return
UniqueIdToHash
(
getUniqueIdInfallible
(
cell
)
)
;
}
uint64_t
getUniqueIdInfallible
(
js
:
:
gc
:
:
Cell
*
cell
)
{
uint64_t
uid
;
js
:
:
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
getUniqueId
(
cell
&
uid
)
)
oomUnsafe
.
crash
(
"
failed
to
allocate
uid
"
)
;
return
uid
;
}
MOZ_MUST_USE
bool
hasUniqueId
(
js
:
:
gc
:
:
Cell
*
cell
)
{
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessZone
(
this
)
)
;
return
uniqueIds
(
)
.
has
(
cell
)
;
}
void
transferUniqueId
(
js
:
:
gc
:
:
Cell
*
tgt
js
:
:
gc
:
:
Cell
*
src
)
{
MOZ_ASSERT
(
src
!
=
tgt
)
;
MOZ_ASSERT
(
!
IsInsideNursery
(
tgt
)
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtimeFromMainThread
(
)
)
)
;
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessZone
(
this
)
)
;
uniqueIds
(
)
.
rekeyIfMoved
(
src
tgt
)
;
}
void
removeUniqueId
(
js
:
:
gc
:
:
Cell
*
cell
)
{
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessZone
(
this
)
)
;
uniqueIds
(
)
.
remove
(
cell
)
;
}
void
adoptUniqueIds
(
JS
:
:
Zone
*
source
)
{
js
:
:
AutoEnterOOMUnsafeRegion
oomUnsafe
;
for
(
js
:
:
gc
:
:
UniqueIdMap
:
:
Enum
e
(
source
-
>
uniqueIds
(
)
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
MOZ_ASSERT
(
!
uniqueIds
(
)
.
has
(
e
.
front
(
)
.
key
(
)
)
)
;
if
(
!
uniqueIds
(
)
.
put
(
e
.
front
(
)
.
key
(
)
e
.
front
(
)
.
value
(
)
)
)
oomUnsafe
.
crash
(
"
failed
to
transfer
unique
ids
from
off
-
main
-
thread
"
)
;
}
source
-
>
uniqueIds
(
)
.
clear
(
)
;
}
JSContext
*
contextFromMainThread
(
)
{
return
runtime_
-
>
contextFromMainThread
(
)
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
checkUniqueIdTableAfterMovingGC
(
)
;
#
endif
bool
keepShapeTables
(
)
const
{
return
keepShapeTables_
;
}
void
setKeepShapeTables
(
bool
b
)
{
keepShapeTables_
=
b
;
}
private
:
js
:
:
ZoneGroupData
<
js
:
:
jit
:
:
JitZone
*
>
jitZone_
;
js
:
:
UnprotectedData
<
GCState
>
gcState_
;
js
:
:
ActiveThreadData
<
bool
>
gcScheduled_
;
js
:
:
ZoneGroupData
<
bool
>
gcPreserveCode_
;
js
:
:
ZoneGroupData
<
bool
>
jitUsingBarriers_
;
js
:
:
ZoneGroupData
<
bool
>
keepShapeTables_
;
friend
class
js
:
:
gc
:
:
ZoneList
;
static
Zone
*
const
NotOnList
;
js
:
:
ZoneGroupOrGCTaskData
<
Zone
*
>
listNext_
;
bool
isOnList
(
)
const
;
Zone
*
nextZone
(
)
const
;
friend
bool
js
:
:
CurrentThreadCanAccessZone
(
Zone
*
zone
)
;
friend
class
js
:
:
gc
:
:
GCRuntime
;
}
;
}
namespace
js
{
class
ZoneGroupsIter
{
gc
:
:
AutoEnterIteration
iterMarker
;
ZoneGroup
*
*
it
;
ZoneGroup
*
*
end
;
public
:
explicit
ZoneGroupsIter
(
JSRuntime
*
rt
)
:
iterMarker
(
&
rt
-
>
gc
)
{
it
=
rt
-
>
gc
.
groups
.
ref
(
)
.
begin
(
)
;
end
=
rt
-
>
gc
.
groups
.
ref
(
)
.
end
(
)
;
}
bool
done
(
)
const
{
return
it
=
=
end
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
it
+
+
;
}
ZoneGroup
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
*
it
;
}
operator
ZoneGroup
*
(
)
const
{
return
get
(
)
;
}
ZoneGroup
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
enum
ZoneSelector
{
WithAtoms
SkipAtoms
}
;
class
ZonesInGroupIter
{
gc
:
:
AutoEnterIteration
iterMarker
;
JS
:
:
Zone
*
*
it
;
JS
:
:
Zone
*
*
end
;
public
:
explicit
ZonesInGroupIter
(
ZoneGroup
*
group
)
:
iterMarker
(
&
group
-
>
runtime
-
>
gc
)
{
it
=
group
-
>
zones
(
)
.
begin
(
)
;
end
=
group
-
>
zones
(
)
.
end
(
)
;
}
bool
done
(
)
const
{
return
it
=
=
end
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
it
+
+
;
}
JS
:
:
Zone
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
*
it
;
}
operator
JS
:
:
Zone
*
(
)
const
{
return
get
(
)
;
}
JS
:
:
Zone
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
class
ZonesIter
{
ZoneGroupsIter
group
;
Maybe
<
ZonesInGroupIter
>
zone
;
JS
:
:
Zone
*
atomsZone
;
public
:
ZonesIter
(
JSRuntime
*
rt
ZoneSelector
selector
)
:
group
(
rt
)
atomsZone
(
selector
=
=
WithAtoms
?
rt
-
>
gc
.
atomsZone
.
ref
(
)
:
nullptr
)
{
if
(
!
atomsZone
&
&
!
done
(
)
)
next
(
)
;
}
bool
atAtomsZone
(
JSRuntime
*
rt
)
const
{
return
!
!
atomsZone
;
}
bool
done
(
)
const
{
return
!
atomsZone
&
&
group
.
done
(
)
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
atomsZone
)
atomsZone
=
nullptr
;
while
(
!
group
.
done
(
)
)
{
if
(
zone
.
isSome
(
)
)
zone
.
ref
(
)
.
next
(
)
;
else
zone
.
emplace
(
group
)
;
if
(
zone
.
ref
(
)
.
done
(
)
)
{
zone
.
reset
(
)
;
group
.
next
(
)
;
}
else
if
(
!
zone
.
ref
(
)
.
get
(
)
-
>
usedByExclusiveThread
)
{
break
;
}
}
}
JS
:
:
Zone
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
atomsZone
?
atomsZone
:
zone
.
ref
(
)
.
get
(
)
;
}
operator
JS
:
:
Zone
*
(
)
const
{
return
get
(
)
;
}
JS
:
:
Zone
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
struct
CompartmentsInZoneIter
{
explicit
CompartmentsInZoneIter
(
JS
:
:
Zone
*
zone
)
:
zone
(
zone
)
{
it
=
zone
-
>
compartments
(
)
.
begin
(
)
;
}
bool
done
(
)
const
{
MOZ_ASSERT
(
it
)
;
return
it
<
zone
-
>
compartments
(
)
.
begin
(
)
|
|
it
>
=
zone
-
>
compartments
(
)
.
end
(
)
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
it
+
+
;
}
JSCompartment
*
get
(
)
const
{
MOZ_ASSERT
(
it
)
;
return
*
it
;
}
operator
JSCompartment
*
(
)
const
{
return
get
(
)
;
}
JSCompartment
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
private
:
JS
:
:
Zone
*
zone
;
JSCompartment
*
*
it
;
CompartmentsInZoneIter
(
)
:
zone
(
nullptr
)
it
(
nullptr
)
{
}
friend
class
mozilla
:
:
Maybe
<
CompartmentsInZoneIter
>
;
}
;
template
<
class
ZonesIterT
>
class
CompartmentsIterT
{
gc
:
:
AutoEnterIteration
iterMarker
;
ZonesIterT
zone
;
mozilla
:
:
Maybe
<
CompartmentsInZoneIter
>
comp
;
public
:
explicit
CompartmentsIterT
(
JSRuntime
*
rt
)
:
iterMarker
(
&
rt
-
>
gc
)
zone
(
rt
)
{
if
(
zone
.
done
(
)
)
comp
.
emplace
(
)
;
else
comp
.
emplace
(
zone
)
;
}
CompartmentsIterT
(
JSRuntime
*
rt
ZoneSelector
selector
)
:
iterMarker
(
&
rt
-
>
gc
)
zone
(
rt
selector
)
{
if
(
zone
.
done
(
)
)
comp
.
emplace
(
)
;
else
comp
.
emplace
(
zone
)
;
}
bool
done
(
)
const
{
return
zone
.
done
(
)
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
!
comp
.
ref
(
)
.
done
(
)
)
;
comp
-
>
next
(
)
;
if
(
comp
-
>
done
(
)
)
{
comp
.
reset
(
)
;
zone
.
next
(
)
;
if
(
!
zone
.
done
(
)
)
comp
.
emplace
(
zone
)
;
}
}
JSCompartment
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
*
comp
;
}
operator
JSCompartment
*
(
)
const
{
return
get
(
)
;
}
JSCompartment
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
typedef
CompartmentsIterT
<
ZonesIter
>
CompartmentsIter
;
class
ZoneAllocPolicy
{
Zone
*
const
zone
;
public
:
MOZ_IMPLICIT
ZoneAllocPolicy
(
Zone
*
zone
)
:
zone
(
zone
)
{
}
template
<
typename
T
>
T
*
maybe_pod_malloc
(
size_t
numElems
)
{
return
zone
-
>
maybe_pod_malloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_calloc
(
size_t
numElems
)
{
return
zone
-
>
maybe_pod_calloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_realloc
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
return
zone
-
>
maybe_pod_realloc
<
T
>
(
p
oldSize
newSize
)
;
}
template
<
typename
T
>
T
*
pod_malloc
(
size_t
numElems
)
{
return
zone
-
>
pod_malloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
pod_calloc
(
size_t
numElems
)
{
return
zone
-
>
pod_calloc
<
T
>
(
numElems
)
;
}
template
<
typename
T
>
T
*
pod_realloc
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
return
zone
-
>
pod_realloc
<
T
>
(
p
oldSize
newSize
)
;
}
void
free_
(
void
*
p
)
{
js_free
(
p
)
;
}
void
reportAllocOverflow
(
)
const
{
}
MOZ_MUST_USE
bool
checkSimulatedOOM
(
)
const
{
return
!
js
:
:
oom
:
:
ShouldFailWithOOM
(
)
;
}
}
;
template
<
typename
T
>
struct
GCManagedDeletePolicy
{
void
operator
(
)
(
const
T
*
ptr
)
{
if
(
ptr
)
{
JSRuntime
*
rt
=
TlsContext
.
get
(
)
-
>
runtime
(
)
;
if
(
CurrentThreadCanAccessRuntime
(
rt
)
&
&
rt
-
>
zoneGroupFromMainThread
(
)
-
>
nursery
(
)
.
isEnabled
(
)
)
{
rt
-
>
zoneGroupFromMainThread
(
)
-
>
callAfterMinorGC
(
deletePtr
const_cast
<
T
*
>
(
ptr
)
)
;
}
else
{
gc
:
:
AutoSetThreadIsSweeping
threadIsSweeping
;
js_delete
(
const_cast
<
T
*
>
(
ptr
)
)
;
}
}
}
private
:
static
void
deletePtr
(
void
*
data
)
{
js_delete
(
reinterpret_cast
<
T
*
>
(
data
)
)
;
}
}
;
}
namespace
JS
{
template
<
>
struct
DeletePolicy
<
js
:
:
FunctionScope
:
:
Data
>
:
public
js
:
:
GCManagedDeletePolicy
<
js
:
:
FunctionScope
:
:
Data
>
{
}
;
template
<
>
struct
DeletePolicy
<
js
:
:
ModuleScope
:
:
Data
>
:
public
js
:
:
GCManagedDeletePolicy
<
js
:
:
ModuleScope
:
:
Data
>
{
}
;
}
#
endif
