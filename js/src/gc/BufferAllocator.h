#
ifndef
gc_BufferAllocator_h
#
define
gc_BufferAllocator_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
BitSet
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
<
cstdint
>
#
include
<
stddef
.
h
>
#
include
<
utility
>
#
include
"
jstypes
.
h
"
#
include
"
ds
/
SlimLinkedList
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
threading
/
LockGuard
.
h
"
#
include
"
threading
/
Mutex
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
class
JS_PUBLIC_API
JSTracer
;
namespace
JS
{
class
JS_PUBLIC_API
Zone
;
}
namespace
js
{
class
GCMarker
;
class
Nursery
;
namespace
gc
{
enum
class
AllocKind
:
uint8_t
;
struct
BufferChunk
;
struct
Cell
;
class
GCRuntime
;
struct
MediumBuffer
;
struct
LargeBuffer
;
class
BufferAllocator
:
public
SlimLinkedListElement
<
BufferAllocator
>
{
public
:
static
constexpr
size_t
MinMediumAllocShift
=
8
;
static
constexpr
size_t
MaxMediumAllocShift
=
19
;
static
constexpr
size_t
MediumAllocClasses
=
MaxMediumAllocShift
-
MinMediumAllocShift
+
1
;
class
AutoLock
:
public
LockGuard
<
Mutex
>
{
public
:
explicit
AutoLock
(
GCRuntime
*
gc
)
;
explicit
AutoLock
(
BufferAllocator
*
allocator
)
;
friend
class
UnlockGuard
<
AutoLock
>
;
}
;
using
MaybeLock
=
mozilla
:
:
Maybe
<
AutoLock
>
;
private
:
using
BufferChunkList
=
SlimLinkedList
<
BufferChunk
>
;
struct
FreeRegion
;
using
FreeList
=
SlimLinkedList
<
FreeRegion
>
;
class
FreeLists
{
using
FreeListArray
=
mozilla
:
:
Array
<
FreeList
MediumAllocClasses
>
;
FreeListArray
lists
;
mozilla
:
:
BitSet
<
MediumAllocClasses
uint32_t
>
available
;
public
:
FreeLists
(
)
=
default
;
FreeLists
(
FreeLists
&
&
other
)
;
FreeLists
&
operator
=
(
FreeLists
&
&
other
)
;
using
const_iterator
=
FreeListArray
:
:
const_iterator
;
auto
begin
(
)
const
{
return
lists
.
begin
(
)
;
}
auto
end
(
)
const
{
return
lists
.
end
(
)
;
}
size_t
getFirstAvailableSizeClass
(
size_t
minSizeClass
)
const
;
FreeRegion
*
getFirstRegion
(
size_t
sizeClass
)
;
void
pushFront
(
size_t
sizeClass
FreeRegion
*
region
)
;
void
pushBack
(
size_t
sizeClass
FreeRegion
*
region
)
;
void
append
(
FreeLists
&
&
other
)
;
void
prepend
(
FreeLists
&
&
other
)
;
void
remove
(
size_t
sizeClass
FreeRegion
*
region
)
;
void
clear
(
)
;
template
<
typename
Pred
>
void
eraseIf
(
Pred
&
&
pred
)
;
void
assertEmpty
(
)
const
;
void
assertContains
(
size_t
sizeClass
FreeRegion
*
region
)
const
;
void
checkAvailable
(
)
const
;
}
;
using
LargeAllocList
=
SlimLinkedList
<
LargeBuffer
>
;
using
LargeAllocMap
=
mozilla
:
:
HashMap
<
void
*
LargeBuffer
*
PointerHasher
<
void
*
>
>
;
enum
class
State
:
uint8_t
{
NotCollecting
Marking
Sweeping
}
;
enum
class
OwnerKind
:
uint8_t
{
Tenured
=
0
Nursery
None
}
;
MainThreadOrGCTaskData
<
JS
:
:
Zone
*
>
zone
;
MainThreadData
<
BufferChunkList
>
mediumMixedChunks
;
MainThreadData
<
BufferChunkList
>
mediumTenuredChunks
;
MainThreadData
<
FreeLists
>
mediumFreeLists
;
MainThreadOrGCTaskData
<
BufferChunkList
>
mediumMixedChunksToSweep
;
MainThreadOrGCTaskData
<
BufferChunkList
>
mediumTenuredChunksToSweep
;
MutexData
<
BufferChunkList
>
sweptMediumMixedChunks
;
MutexData
<
BufferChunkList
>
sweptMediumTenuredChunks
;
MutexData
<
FreeLists
>
sweptMediumNurseryFreeLists
;
MutexData
<
FreeLists
>
sweptMediumTenuredFreeLists
;
MainThreadData
<
LargeAllocList
>
largeNurseryAllocs
;
MainThreadData
<
LargeAllocList
>
largeTenuredAllocs
;
MainThreadOrGCTaskData
<
LargeAllocMap
>
largeAllocMap
;
MainThreadOrGCTaskData
<
LargeAllocList
>
largeNurseryAllocsToSweep
;
MainThreadOrGCTaskData
<
LargeAllocList
>
largeTenuredAllocsToSweep
;
MutexData
<
LargeAllocList
>
sweptLargeTenuredAllocs
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
sweptChunksAvailable
;
MainThreadData
<
State
>
minorState
;
MainThreadData
<
State
>
majorState
;
MutexData
<
bool
>
minorSweepingFinished
;
MutexData
<
bool
>
majorSweepingFinished
;
MainThreadData
<
bool
>
majorStartedWhileMinorSweeping
;
MainThreadData
<
bool
>
majorFinishedWhileMinorSweeping
;
public
:
explicit
BufferAllocator
(
JS
:
:
Zone
*
zone
)
;
~
BufferAllocator
(
)
;
static
inline
size_t
GetGoodAllocSize
(
size_t
requiredBytes
)
;
static
inline
size_t
GetGoodElementCount
(
size_t
requiredElements
size_t
elementSize
)
;
static
inline
size_t
GetGoodPower2AllocSize
(
size_t
requiredBytes
)
;
static
inline
size_t
GetGoodPower2ElementCount
(
size_t
requiredElements
size_t
elementSize
)
;
static
bool
IsBufferAlloc
(
void
*
alloc
)
;
void
*
alloc
(
size_t
bytes
bool
nurseryOwned
)
;
void
*
allocInGC
(
size_t
bytes
bool
nurseryOwned
)
;
void
*
realloc
(
void
*
ptr
size_t
bytes
bool
nurseryOwned
)
;
void
free
(
void
*
ptr
)
;
size_t
getAllocSize
(
void
*
ptr
)
;
bool
isNurseryOwned
(
void
*
ptr
)
;
void
startMinorCollection
(
MaybeLock
&
lock
)
;
bool
startMinorSweeping
(
)
;
void
sweepForMinorCollection
(
)
;
void
startMajorCollection
(
MaybeLock
&
lock
)
;
void
startMajorSweeping
(
MaybeLock
&
lock
)
;
void
sweepForMajorCollection
(
bool
shouldDecommit
)
;
void
finishMajorCollection
(
const
AutoLock
&
lock
)
;
void
clearAllocatedDuringCollectionState
(
const
AutoLock
&
lock
)
;
void
clearMarkStateAfterBarrierVerification
(
)
;
void
maybeMergeSweptData
(
)
;
void
maybeMergeSweptData
(
MaybeLock
&
lock
)
;
void
mergeSweptData
(
)
;
void
mergeSweptData
(
const
AutoLock
&
lock
)
;
void
abortMajorSweeping
(
const
AutoLock
&
lock
)
;
bool
isEmpty
(
)
const
;
void
traceEdge
(
JSTracer
*
trc
Cell
*
owner
void
*
*
bufferp
const
char
*
name
)
;
bool
markTenuredAlloc
(
void
*
alloc
)
;
bool
isMarkedBlack
(
void
*
alloc
)
;
bool
isPointerWithinMediumOrLargeBuffer
(
void
*
ptr
)
;
Mutex
&
lock
(
)
const
;
size_t
getSizeOfNurseryBuffers
(
)
;
void
addSizeOfExcludingThis
(
size_t
*
usedBytesOut
size_t
*
freeBytesOut
size_t
*
adminBytesOut
)
;
static
void
printStatsHeader
(
FILE
*
file
)
;
static
void
printStats
(
GCRuntime
*
gc
mozilla
:
:
TimeStamp
creationTime
bool
isMajorGC
FILE
*
file
)
;
void
getStats
(
size_t
&
usedBytes
size_t
&
freeBytes
size_t
&
adminBytes
size_t
&
mediumNurseryChunkCount
size_t
&
mediumTenuredChunkCount
size_t
&
freeRegions
size_t
&
largeNurseryAllocCount
size_t
&
largeTenuredAllocCount
)
;
#
ifdef
DEBUG
void
checkGCStateNotInUse
(
)
;
void
checkGCStateNotInUse
(
MaybeLock
&
lock
)
;
void
checkGCStateNotInUse
(
const
AutoLock
&
lock
)
;
#
endif
private
:
void
markNurseryOwnedAlloc
(
void
*
alloc
bool
ownerWasTenured
)
;
friend
class
js
:
:
Nursery
;
static
inline
bool
IsSmallAllocSize
(
size_t
bytes
)
;
static
bool
IsSmallAlloc
(
void
*
alloc
)
;
void
*
allocSmall
(
size_t
bytes
bool
nurseryOwned
)
;
void
*
allocSmallInGC
(
size_t
bytes
bool
nurseryOwned
)
;
static
AllocKind
AllocKindForSmallAlloc
(
size_t
bytes
)
;
static
bool
IsMediumAlloc
(
void
*
alloc
)
;
void
*
allocMedium
(
size_t
bytes
bool
nurseryOwned
bool
inGC
)
;
void
*
bumpAllocOrRetry
(
size_t
sizeClass
bool
inGC
)
;
void
*
bumpAlloc
(
size_t
sizeClass
)
;
void
*
allocFromRegion
(
FreeRegion
*
region
size_t
requestedBytes
size_t
sizeClass
)
;
void
updateFreeListsAfterAlloc
(
FreeLists
*
freeLists
FreeRegion
*
region
size_t
sizeClass
)
;
void
recommitRegion
(
FreeRegion
*
region
)
;
bool
allocNewChunk
(
bool
inGC
)
;
bool
sweepChunk
(
BufferChunk
*
chunk
OwnerKind
ownerKindToSweep
bool
shouldDecommit
FreeLists
&
freeLists
)
;
void
addSweptRegion
(
BufferChunk
*
chunk
uintptr_t
freeStart
uintptr_t
freeEnd
bool
shouldDecommit
bool
expectUnchanged
FreeLists
&
freeLists
)
;
void
freeMedium
(
void
*
alloc
)
;
bool
growMedium
(
MediumBuffer
*
header
size_t
newBytes
)
;
bool
shrinkMedium
(
MediumBuffer
*
header
size_t
newBytes
)
;
FreeRegion
*
findFollowingFreeRegion
(
uintptr_t
start
)
;
FreeRegion
*
findPrecedingFreeRegion
(
uintptr_t
start
)
;
enum
class
ListPosition
{
Front
Back
}
;
FreeRegion
*
addFreeRegion
(
FreeLists
*
freeLists
size_t
sizeClass
uintptr_t
start
uintptr_t
end
bool
anyDecommitted
ListPosition
position
bool
expectUnchanged
=
false
)
;
void
updateFreeRegionStart
(
FreeLists
*
freeLists
FreeRegion
*
region
uintptr_t
newStart
)
;
FreeLists
*
getChunkFreeLists
(
BufferChunk
*
chunk
)
;
bool
isSweepingChunk
(
BufferChunk
*
chunk
)
;
static
size_t
SizeClassForAlloc
(
size_t
bytes
)
;
static
size_t
SizeClassForFreeRegion
(
size_t
bytes
)
;
static
size_t
SizeClassBytes
(
size_t
sizeClass
)
;
friend
struct
MediumBuffer
;
static
inline
bool
IsLargeAllocSize
(
size_t
bytes
)
;
static
bool
IsLargeAlloc
(
void
*
alloc
)
;
void
*
allocLarge
(
size_t
bytes
bool
nurseryOwned
bool
inGC
)
;
bool
sweepLargeTenured
(
LargeBuffer
*
header
)
;
void
freeLarge
(
void
*
alloc
)
;
bool
shrinkLarge
(
LargeBuffer
*
header
size_t
newBytes
)
;
void
unmapLarge
(
LargeBuffer
*
header
bool
isSweeping
MaybeLock
&
lock
)
;
bool
markLargeAlloc
(
void
*
alloc
)
;
bool
isLargeAllocMarked
(
void
*
alloc
)
;
LargeBuffer
*
lookupLargeBuffer
(
void
*
alloc
)
;
LargeBuffer
*
lookupLargeBuffer
(
void
*
alloc
MaybeLock
&
lock
)
;
bool
needLockToAccessBufferMap
(
)
const
;
void
updateHeapSize
(
size_t
bytes
bool
checkThresholds
bool
updateRetainedSize
)
;
#
ifdef
DEBUG
void
checkChunkListGCStateNotInUse
(
BufferChunkList
&
chunks
bool
hasNurseryOwnedAllocs
bool
allowAllocatedDuringCollection
)
;
void
checkChunkGCStateNotInUse
(
BufferChunk
*
chunk
bool
allowAllocatedDuringCollection
)
;
void
checkAllocListGCStateNotInUse
(
LargeAllocList
&
list
bool
isNurseryOwned
)
;
void
verifyChunk
(
BufferChunk
*
chunk
bool
hasNurseryOwnedAllocs
)
;
void
verifyFreeRegion
(
BufferChunk
*
chunk
uintptr_t
endOffset
size_t
expectedSize
)
;
#
endif
}
;
#
ifdef
DEBUG
static
constexpr
uint16_t
MediumBufferCheckValue
=
0xBFA1
;
static
constexpr
uint32_t
LargeBufferCheckValue
=
0xBFA110C2
;
static
constexpr
uint32_t
FreeRegionCheckValue
=
0xBFA110C3
;
#
endif
struct
alignas
(
CellAlignBytes
)
MediumBuffer
{
uint8_t
sizeClass
;
bool
isNurseryOwned
=
false
;
#
ifdef
DEBUG
uint16_t
checkValue
=
MediumBufferCheckValue
;
#
endif
MediumBuffer
(
uint8_t
sizeClass
bool
nurseryOwned
)
;
static
MediumBuffer
*
from
(
BufferChunk
*
chunk
uintptr_t
offset
)
;
void
check
(
)
const
;
size_t
bytesIncludingHeader
(
)
const
;
size_t
allocBytes
(
)
const
;
void
*
data
(
)
;
}
;
struct
alignas
(
CellAlignBytes
)
LargeBuffer
:
public
SlimLinkedListElement
<
LargeBuffer
>
{
JS
:
:
Zone
*
const
zone
;
void
*
alloc
;
size_t
bytes
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
marked
;
bool
isNurseryOwned
;
bool
allocatedDuringCollection
=
false
;
#
ifdef
DEBUG
uint32_t
checkValue
=
LargeBufferCheckValue
;
#
endif
inline
LargeBuffer
(
JS
:
:
Zone
*
zone
void
*
ptr
size_t
bytes
bool
nurseryOwned
)
;
inline
void
check
(
)
const
;
inline
bool
markAtomic
(
)
;
inline
void
*
data
(
)
{
return
alloc
;
}
inline
size_t
allocBytes
(
)
const
{
return
bytes
;
}
bool
isPointerWithinAllocation
(
void
*
ptr
)
const
;
}
;
}
}
#
endif
