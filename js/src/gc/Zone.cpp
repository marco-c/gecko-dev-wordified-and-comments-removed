#
include
"
gc
/
Zone
-
inl
.
h
"
#
include
"
js
/
shadow
/
Zone
.
h
"
#
include
<
type_traits
>
#
include
"
gc
/
FinalizationObservers
.
h
"
#
include
"
gc
/
GCContext
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
gc
/
PublicIterators
.
h
"
#
include
"
jit
/
BaselineIC
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
Invalidation
.
h
"
#
include
"
jit
/
Ion
.
h
"
#
include
"
jit
/
JitZone
.
h
"
#
include
"
vm
/
Runtime
.
h
"
#
include
"
vm
/
Time
.
h
"
#
include
"
wasm
/
WasmInstance
.
h
"
#
include
"
debugger
/
DebugAPI
-
inl
.
h
"
#
include
"
gc
/
GC
-
inl
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
gc
/
Nursery
-
inl
.
h
"
#
include
"
gc
/
WeakMap
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
Zone
*
const
Zone
:
:
NotOnList
=
reinterpret_cast
<
Zone
*
>
(
1
)
;
ZoneAllocator
:
:
ZoneAllocator
(
JSRuntime
*
rt
Kind
kind
)
:
JS
:
:
shadow
:
:
Zone
(
rt
&
rt
-
>
gc
.
barrierTracer
kind
)
jitHeapThreshold
(
jit
:
:
MaxCodeBytesPerProcess
*
0
.
8
)
{
}
ZoneAllocator
:
:
~
ZoneAllocator
(
)
{
#
ifdef
DEBUG
mallocTracker
.
checkEmptyOnDestroy
(
)
;
MOZ_ASSERT
(
gcHeapSize
.
bytes
(
)
=
=
0
)
;
MOZ_ASSERT
(
mallocHeapSize
.
bytes
(
)
=
=
0
)
;
MOZ_ASSERT
(
jitHeapSize
.
bytes
(
)
=
=
0
)
;
#
endif
}
void
ZoneAllocator
:
:
fixupAfterMovingGC
(
)
{
#
ifdef
DEBUG
mallocTracker
.
fixupAfterMovingGC
(
)
;
#
endif
}
void
js
:
:
ZoneAllocator
:
:
updateSchedulingStateOnGCStart
(
)
{
gcHeapSize
.
updateOnGCStart
(
)
;
mallocHeapSize
.
updateOnGCStart
(
)
;
jitHeapSize
.
updateOnGCStart
(
)
;
perZoneGCTime
=
mozilla
:
:
TimeDuration
(
)
;
}
void
js
:
:
ZoneAllocator
:
:
updateGCStartThresholds
(
GCRuntime
&
gc
)
{
bool
isAtomsZone
=
JS
:
:
Zone
:
:
from
(
this
)
-
>
isAtomsZone
(
)
;
gcHeapThreshold
.
updateStartThreshold
(
gcHeapSize
.
retainedBytes
(
)
gc
.
tunables
gc
.
schedulingState
isAtomsZone
)
;
mallocHeapThreshold
.
updateStartThreshold
(
mallocHeapSize
.
retainedBytes
(
)
gc
.
tunables
gc
.
schedulingState
)
;
}
void
js
:
:
ZoneAllocator
:
:
setGCSliceThresholds
(
GCRuntime
&
gc
bool
waitingOnBGTask
)
{
gcHeapThreshold
.
setSliceThreshold
(
this
gcHeapSize
gc
.
tunables
waitingOnBGTask
)
;
mallocHeapThreshold
.
setSliceThreshold
(
this
mallocHeapSize
gc
.
tunables
waitingOnBGTask
)
;
jitHeapThreshold
.
setSliceThreshold
(
this
jitHeapSize
gc
.
tunables
waitingOnBGTask
)
;
}
void
js
:
:
ZoneAllocator
:
:
clearGCSliceThresholds
(
)
{
gcHeapThreshold
.
clearSliceThreshold
(
)
;
mallocHeapThreshold
.
clearSliceThreshold
(
)
;
jitHeapThreshold
.
clearSliceThreshold
(
)
;
}
bool
ZoneAllocator
:
:
addSharedMemory
(
void
*
mem
size_t
nbytes
MemoryUse
use
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
auto
ptr
=
sharedMemoryUseCounts
.
lookupForAdd
(
mem
)
;
MOZ_ASSERT_IF
(
ptr
ptr
-
>
value
(
)
.
use
=
=
use
)
;
if
(
!
ptr
&
&
!
sharedMemoryUseCounts
.
add
(
ptr
mem
gc
:
:
SharedMemoryUse
(
use
)
)
)
{
return
false
;
}
ptr
-
>
value
(
)
.
count
+
+
;
if
(
nbytes
>
ptr
-
>
value
(
)
.
nbytes
)
{
mallocHeapSize
.
addBytes
(
nbytes
-
ptr
-
>
value
(
)
.
nbytes
)
;
ptr
-
>
value
(
)
.
nbytes
=
nbytes
;
}
maybeTriggerGCOnMalloc
(
)
;
return
true
;
}
void
ZoneAllocator
:
:
removeSharedMemory
(
void
*
mem
size_t
nbytes
MemoryUse
use
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
MOZ_ASSERT
(
CurrentThreadIsGCFinalizing
(
)
)
;
auto
ptr
=
sharedMemoryUseCounts
.
lookup
(
mem
)
;
MOZ_ASSERT
(
ptr
)
;
MOZ_ASSERT
(
ptr
-
>
value
(
)
.
count
!
=
0
)
;
MOZ_ASSERT
(
ptr
-
>
value
(
)
.
use
=
=
use
)
;
MOZ_ASSERT
(
ptr
-
>
value
(
)
.
nbytes
>
=
nbytes
)
;
ptr
-
>
value
(
)
.
count
-
-
;
if
(
ptr
-
>
value
(
)
.
count
=
=
0
)
{
mallocHeapSize
.
removeBytes
(
ptr
-
>
value
(
)
.
nbytes
true
)
;
sharedMemoryUseCounts
.
remove
(
ptr
)
;
}
}
template
<
TrackingKind
kind
>
void
js
:
:
TrackedAllocPolicy
<
kind
>
:
:
decMemory
(
size_t
nbytes
)
{
bool
updateRetainedSize
=
false
;
if
constexpr
(
kind
=
=
TrackingKind
:
:
Cell
)
{
JS
:
:
GCContext
*
gcx
=
TlsGCContext
.
get
(
)
;
updateRetainedSize
=
gcx
-
>
isFinalizing
(
)
;
}
zone_
-
>
decNonGCMemory
(
this
nbytes
MemoryUse
:
:
TrackedAllocPolicy
updateRetainedSize
)
;
}
namespace
js
{
template
class
TrackedAllocPolicy
<
TrackingKind
:
:
Zone
>
;
template
class
TrackedAllocPolicy
<
TrackingKind
:
:
Cell
>
;
}
JS
:
:
Zone
:
:
Zone
(
JSRuntime
*
rt
Kind
kind
)
:
ZoneAllocator
(
rt
kind
)
arenas
(
this
)
data
(
this
nullptr
)
tenuredBigInts
(
this
0
)
nurseryAllocatedStrings
(
this
0
)
markedStrings
(
this
0
)
finalizedStrings
(
this
0
)
allocNurseryStrings
(
this
true
)
allocNurseryBigInts
(
this
true
)
suppressAllocationMetadataBuilder
(
this
false
)
previousGCStringStats
(
this
)
stringStats
(
this
)
pretenuring
(
this
)
uniqueIds_
(
this
)
gcWeakMapList_
(
this
)
compartments_
(
)
crossZoneStringWrappers_
(
this
)
weakCaches_
(
this
)
gcEphemeronEdges_
(
this
SystemAllocPolicy
(
)
rt
-
>
randomHashCodeScrambler
(
)
)
gcNurseryEphemeronEdges_
(
this
SystemAllocPolicy
(
)
rt
-
>
randomHashCodeScrambler
(
)
)
rttValueObjects_
(
this
this
)
markedAtoms_
(
this
)
atomCache_
(
this
)
externalStringCache_
(
this
)
functionToStringCache_
(
this
)
shapeZone_
(
this
this
)
finalizationObservers_
(
this
)
jitZone_
(
this
nullptr
)
gcScheduled_
(
false
)
gcScheduledSaved_
(
false
)
gcPreserveCode_
(
false
)
keepPropMapTables_
(
this
false
)
wasCollected_
(
false
)
listNext_
(
NotOnList
)
keptObjects
(
this
this
)
{
MOZ_ASSERT
(
reinterpret_cast
<
JS
:
:
shadow
:
:
Zone
*
>
(
this
)
=
=
static_cast
<
JS
:
:
shadow
:
:
Zone
*
>
(
this
)
)
;
MOZ_ASSERT_IF
(
isAtomsZone
(
)
!
rt
-
>
unsafeAtomsZone
(
)
)
;
updateGCStartThresholds
(
rt
-
>
gc
)
;
}
Zone
:
:
~
Zone
(
)
{
MOZ_ASSERT_IF
(
regExps_
.
ref
(
)
regExps
(
)
.
empty
(
)
)
;
DebugAPI
:
:
deleteDebugScriptMap
(
debugScriptMap
)
;
js_delete
(
finalizationObservers_
.
ref
(
)
.
release
(
)
)
;
MOZ_ASSERT
(
gcWeakMapList
(
)
.
isEmpty
(
)
)
;
JSRuntime
*
rt
=
runtimeFromAnyThread
(
)
;
if
(
this
=
=
rt
-
>
gc
.
systemZone
)
{
MOZ_ASSERT
(
isSystemZone
(
)
)
;
rt
-
>
gc
.
systemZone
=
nullptr
;
}
js_delete
(
jitZone_
.
ref
(
)
)
;
}
bool
Zone
:
:
init
(
)
{
regExps_
.
ref
(
)
=
make_unique
<
RegExpZone
>
(
this
)
;
return
regExps_
.
ref
(
)
&
&
gcEphemeronEdges
(
)
.
init
(
)
&
&
gcNurseryEphemeronEdges
(
)
.
init
(
)
;
}
void
Zone
:
:
setNeedsIncrementalBarrier
(
bool
needs
)
{
needsIncrementalBarrier_
=
needs
;
}
void
Zone
:
:
changeGCState
(
GCState
prev
GCState
next
)
{
MOZ_ASSERT
(
RuntimeHeapIsBusy
(
)
)
;
MOZ_ASSERT
(
gcState
(
)
=
=
prev
)
;
bool
barriersDisabled
=
isGCMarking
(
)
&
&
!
needsIncrementalBarrier
(
)
;
gcState_
=
next
;
if
(
!
barriersDisabled
)
{
needsIncrementalBarrier_
=
isGCMarking
(
)
;
}
}
template
<
class
Pred
>
static
void
EraseIf
(
js
:
:
gc
:
:
EphemeronEdgeVector
&
entries
Pred
pred
)
{
auto
*
begin
=
entries
.
begin
(
)
;
auto
*
const
end
=
entries
.
end
(
)
;
auto
*
newEnd
=
begin
;
for
(
auto
*
p
=
begin
;
p
!
=
end
;
p
+
+
)
{
if
(
!
pred
(
*
p
)
)
{
*
newEnd
+
+
=
*
p
;
}
}
size_t
removed
=
end
-
newEnd
;
entries
.
shrinkBy
(
removed
)
;
}
static
void
SweepEphemeronEdgesWhileMinorSweeping
(
js
:
:
gc
:
:
EphemeronEdgeVector
&
entries
)
{
EraseIf
(
entries
[
]
(
js
:
:
gc
:
:
EphemeronEdge
&
edge
)
-
>
bool
{
return
IsAboutToBeFinalizedDuringMinorSweep
(
&
edge
.
target
)
;
}
)
;
}
void
Zone
:
:
sweepAfterMinorGC
(
JSTracer
*
trc
)
{
sweepEphemeronTablesAfterMinorGC
(
)
;
crossZoneStringWrappers
(
)
.
sweepAfterMinorGC
(
trc
)
;
for
(
CompartmentsInZoneIter
comp
(
this
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
comp
-
>
sweepAfterMinorGC
(
trc
)
;
}
}
void
Zone
:
:
sweepEphemeronTablesAfterMinorGC
(
)
{
for
(
auto
r
=
gcNurseryEphemeronEdges
(
)
.
mutableAll
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
gc
:
:
Cell
*
key
=
r
.
front
(
)
.
key
;
MOZ_ASSERT
(
!
key
-
>
isTenured
(
)
)
;
if
(
!
Nursery
:
:
getForwardedPointer
(
&
key
)
)
{
continue
;
}
EphemeronEdgeVector
&
entries
=
r
.
front
(
)
.
value
;
SweepEphemeronEdgesWhileMinorSweeping
(
entries
)
;
EphemeronEdgeTable
&
tenuredEdges
=
gcEphemeronEdges
(
)
;
auto
*
entry
=
tenuredEdges
.
get
(
key
)
;
if
(
!
entry
)
{
if
(
!
tenuredEdges
.
put
(
key
gc
:
:
EphemeronEdgeVector
(
)
)
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
oomUnsafe
.
crash
(
"
Failed
to
tenure
weak
keys
entry
"
)
;
}
entry
=
tenuredEdges
.
get
(
key
)
;
}
if
(
!
entry
-
>
value
.
appendAll
(
entries
)
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
oomUnsafe
.
crash
(
"
Failed
to
tenure
weak
keys
entry
"
)
;
}
JSObject
*
delegate
=
gc
:
:
detail
:
:
GetDelegate
(
key
-
>
as
<
JSObject
>
(
)
)
;
if
(
!
delegate
)
{
continue
;
}
MOZ_ASSERT
(
delegate
-
>
isTenured
(
)
)
;
auto
*
p
=
delegate
-
>
zone
(
)
-
>
gcEphemeronEdges
(
)
.
get
(
delegate
)
;
if
(
p
)
{
SweepEphemeronEdgesWhileMinorSweeping
(
p
-
>
value
)
;
}
}
if
(
!
gcNurseryEphemeronEdges
(
)
.
clear
(
)
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
oomUnsafe
.
crash
(
"
OOM
while
clearing
gcNurseryEphemeronEdges
.
"
)
;
}
}
void
Zone
:
:
traceWeakCCWEdges
(
JSTracer
*
trc
)
{
crossZoneStringWrappers
(
)
.
traceWeak
(
trc
)
;
for
(
CompartmentsInZoneIter
comp
(
this
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
comp
-
>
traceCrossCompartmentObjectWrapperEdges
(
trc
)
;
}
}
void
Zone
:
:
fixupAllCrossCompartmentWrappersAfterMovingGC
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
trc
-
>
runtime
(
)
-
>
gc
.
isHeapCompacting
(
)
)
;
for
(
ZonesIter
zone
(
trc
-
>
runtime
(
)
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
crossZoneStringWrappers
(
)
.
traceWeak
(
trc
)
;
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
comp
-
>
fixupCrossCompartmentObjectWrappersAfterMovingGC
(
trc
)
;
}
}
}
void
Zone
:
:
dropStringWrappersOnGC
(
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
crossZoneStringWrappers
(
)
.
clear
(
)
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
Zone
:
:
checkAllCrossCompartmentWrappersAfterMovingGC
(
)
{
checkStringWrappersAfterMovingGC
(
)
;
for
(
CompartmentsInZoneIter
comp
(
this
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
comp
-
>
checkObjectWrappersAfterMovingGC
(
)
;
}
}
void
Zone
:
:
checkStringWrappersAfterMovingGC
(
)
{
for
(
StringWrapperMap
:
:
Enum
e
(
crossZoneStringWrappers
(
)
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
auto
key
=
e
.
front
(
)
.
key
(
)
;
CheckGCThingAfterMovingGC
(
key
.
get
(
)
)
;
auto
ptr
=
crossZoneStringWrappers
(
)
.
lookup
(
key
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
e
.
front
(
)
)
;
}
}
#
endif
void
Zone
:
:
discardJitCode
(
JS
:
:
GCContext
*
gcx
const
DiscardOptions
&
options
)
{
if
(
!
jitZone
(
)
)
{
return
;
}
if
(
isPreservingCode
(
)
)
{
return
;
}
if
(
options
.
discardJitScripts
&
&
options
.
discardBaselineCode
)
{
lastDiscardedCodeTime_
=
ReallyNow
(
)
;
}
if
(
options
.
discardBaselineCode
|
|
options
.
discardJitScripts
)
{
#
ifdef
DEBUG
for
(
auto
iter
=
cellIter
<
BaseScript
>
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
BaseScript
*
base
=
iter
.
unbarrieredGet
(
)
;
if
(
jit
:
:
JitScript
*
jitScript
=
base
-
>
maybeJitScript
(
)
)
{
MOZ_ASSERT
(
!
jitScript
-
>
active
(
)
)
;
}
}
#
endif
jit
:
:
MarkActiveJitScripts
(
this
)
;
}
jit
:
:
InvalidateAll
(
gcx
this
)
;
for
(
auto
base
=
cellIterUnsafe
<
BaseScript
>
(
)
;
!
base
.
done
(
)
;
base
.
next
(
)
)
{
jit
:
:
JitScript
*
jitScript
=
base
-
>
maybeJitScript
(
)
;
if
(
!
jitScript
)
{
continue
;
}
JSScript
*
script
=
base
-
>
asJSScript
(
)
;
jit
:
:
FinishInvalidation
(
gcx
script
)
;
if
(
options
.
discardBaselineCode
)
{
if
(
jitScript
-
>
hasBaselineScript
(
)
&
&
!
jitScript
-
>
active
(
)
)
{
jit
:
:
FinishDiscardBaselineScript
(
gcx
script
)
;
}
}
#
ifdef
JS_CACHEIR_SPEW
maybeUpdateWarmUpCount
(
script
)
;
#
endif
script
-
>
resetWarmUpCounterForGC
(
)
;
if
(
options
.
discardJitScripts
)
{
script
-
>
maybeReleaseJitScript
(
gcx
)
;
jitScript
=
script
-
>
maybeJitScript
(
)
;
if
(
!
jitScript
)
{
if
(
!
script
-
>
realm
(
)
-
>
collectCoverageForDebug
(
)
&
&
!
gcx
-
>
runtime
(
)
-
>
profilingScripts
)
{
script
-
>
destroyScriptCounts
(
)
;
}
continue
;
}
}
if
(
options
.
discardBaselineCode
)
{
jitScript
-
>
purgeOptimizedStubs
(
script
)
;
}
if
(
options
.
resetNurseryAllocSites
|
|
options
.
resetPretenuredAllocSites
)
{
jitScript
-
>
resetAllocSites
(
options
.
resetNurseryAllocSites
options
.
resetPretenuredAllocSites
)
;
}
jitScript
-
>
resetActive
(
)
;
}
if
(
options
.
discardBaselineCode
)
{
jitZone
(
)
-
>
optimizedStubSpace
(
)
-
>
freeAllAfterMinorGC
(
this
)
;
jitZone
(
)
-
>
purgeIonCacheIRStubInfo
(
)
;
}
}
void
JS
:
:
Zone
:
:
resetAllocSitesAndInvalidate
(
bool
resetNurserySites
bool
resetPretenuredSites
)
{
MOZ_ASSERT
(
resetNurserySites
|
|
resetPretenuredSites
)
;
if
(
!
jitZone
(
)
)
{
return
;
}
JSContext
*
cx
=
runtime_
-
>
mainContextFromOwnThread
(
)
;
for
(
auto
base
=
cellIterUnsafe
<
BaseScript
>
(
)
;
!
base
.
done
(
)
;
base
.
next
(
)
)
{
jit
:
:
JitScript
*
jitScript
=
base
-
>
maybeJitScript
(
)
;
if
(
!
jitScript
)
{
continue
;
}
if
(
!
jitScript
-
>
resetAllocSites
(
resetNurserySites
resetPretenuredSites
)
)
{
continue
;
}
JSScript
*
script
=
base
-
>
asJSScript
(
)
;
CancelOffThreadIonCompile
(
script
)
;
if
(
!
script
-
>
hasIonScript
(
)
)
{
continue
;
}
jit
:
:
Invalidate
(
cx
script
true
true
)
;
}
}
void
JS
:
:
Zone
:
:
beforeClearDelegateInternal
(
JSObject
*
wrapper
JSObject
*
delegate
)
{
MOZ_ASSERT
(
js
:
:
gc
:
:
detail
:
:
GetDelegate
(
wrapper
)
=
=
delegate
)
;
MOZ_ASSERT
(
needsIncrementalBarrier
(
)
)
;
MOZ_ASSERT
(
!
RuntimeFromMainThreadIsHeapMajorCollecting
(
this
)
)
;
runtimeFromMainThread
(
)
-
>
gc
.
marker
.
severWeakDelegate
(
wrapper
delegate
)
;
}
void
JS
:
:
Zone
:
:
afterAddDelegateInternal
(
JSObject
*
wrapper
)
{
MOZ_ASSERT
(
!
RuntimeFromMainThreadIsHeapMajorCollecting
(
this
)
)
;
JSObject
*
delegate
=
js
:
:
gc
:
:
detail
:
:
GetDelegate
(
wrapper
)
;
if
(
delegate
)
{
runtimeFromMainThread
(
)
-
>
gc
.
marker
.
restoreWeakDelegate
(
wrapper
delegate
)
;
}
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
JS
:
:
Zone
:
:
checkUniqueIdTableAfterMovingGC
(
)
{
for
(
auto
r
=
uniqueIds
(
)
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
js
:
:
gc
:
:
CheckGCThingAfterMovingGC
(
r
.
front
(
)
.
key
(
)
)
;
}
}
#
endif
uint64_t
Zone
:
:
gcNumber
(
)
{
return
runtimeFromMainThread
(
)
-
>
gc
.
gcNumber
(
)
;
}
js
:
:
jit
:
:
JitZone
*
Zone
:
:
createJitZone
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
!
jitZone_
)
;
MOZ_ASSERT
(
cx
-
>
runtime
(
)
-
>
hasJitRuntime
(
)
)
;
UniquePtr
<
jit
:
:
JitZone
>
jitZone
(
cx
-
>
new_
<
js
:
:
jit
:
:
JitZone
>
(
)
)
;
if
(
!
jitZone
)
{
return
nullptr
;
}
jitZone_
=
jitZone
.
release
(
)
;
return
jitZone_
;
}
bool
Zone
:
:
hasMarkedRealms
(
)
{
for
(
RealmsInZoneIter
realm
(
this
)
;
!
realm
.
done
(
)
;
realm
.
next
(
)
)
{
if
(
realm
-
>
marked
(
)
)
{
return
true
;
}
}
return
false
;
}
void
Zone
:
:
notifyObservingDebuggers
(
)
{
AutoAssertNoGC
nogc
;
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsCollecting
(
)
"
This
method
should
be
called
during
GC
.
"
)
;
JSRuntime
*
rt
=
runtimeFromMainThread
(
)
;
for
(
RealmsInZoneIter
realms
(
this
)
;
!
realms
.
done
(
)
;
realms
.
next
(
)
)
{
GlobalObject
*
global
=
realms
-
>
unsafeUnbarrieredMaybeGlobal
(
)
;
if
(
!
global
)
{
continue
;
}
DebugAPI
:
:
notifyParticipatesInGC
(
global
rt
-
>
gc
.
majorGCCount
(
)
)
;
}
}
bool
Zone
:
:
isOnList
(
)
const
{
return
listNext_
!
=
NotOnList
;
}
Zone
*
Zone
:
:
nextZone
(
)
const
{
MOZ_ASSERT
(
isOnList
(
)
)
;
return
listNext_
;
}
void
Zone
:
:
fixupAfterMovingGC
(
)
{
ZoneAllocator
:
:
fixupAfterMovingGC
(
)
;
shapeZone
(
)
.
fixupPropMapShapeTableAfterMovingGC
(
)
;
}
bool
Zone
:
:
addRttValueObject
(
JSContext
*
cx
HandleObject
obj
)
{
MOZ_ASSERT
(
!
IsInsideNursery
(
obj
)
)
;
if
(
!
rttValueObjects
(
)
.
put
(
obj
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
void
Zone
:
:
purgeAtomCache
(
)
{
atomCache
(
)
.
clearAndCompact
(
)
;
for
(
RealmsInZoneIter
r
(
this
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
r
-
>
dtoaCache
.
purge
(
)
;
}
}
void
Zone
:
:
addSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
JS
:
:
CodeSizes
*
code
size_t
*
regexpZone
size_t
*
jitZone
size_t
*
baselineStubsOptimized
size_t
*
uniqueIdMap
size_t
*
initialPropMapTable
size_t
*
shapeTables
size_t
*
atomsMarkBitmaps
size_t
*
compartmentObjects
size_t
*
crossCompartmentWrappersTables
size_t
*
compartmentsPrivateData
size_t
*
scriptCountsMapArg
)
{
*
regexpZone
+
=
regExps
(
)
.
sizeOfIncludingThis
(
mallocSizeOf
)
;
if
(
jitZone_
)
{
jitZone_
-
>
addSizeOfIncludingThis
(
mallocSizeOf
code
jitZone
baselineStubsOptimized
)
;
}
*
uniqueIdMap
+
=
uniqueIds
(
)
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
shapeZone
(
)
.
addSizeOfExcludingThis
(
mallocSizeOf
initialPropMapTable
shapeTables
)
;
*
atomsMarkBitmaps
+
=
markedAtoms
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
*
crossCompartmentWrappersTables
+
=
crossZoneStringWrappers
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
for
(
CompartmentsInZoneIter
comp
(
this
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
comp
-
>
addSizeOfIncludingThis
(
mallocSizeOf
compartmentObjects
crossCompartmentWrappersTables
compartmentsPrivateData
)
;
}
if
(
scriptCountsMap
)
{
*
scriptCountsMapArg
+
=
scriptCountsMap
-
>
shallowSizeOfIncludingThis
(
mallocSizeOf
)
;
for
(
auto
r
=
scriptCountsMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
*
scriptCountsMapArg
+
=
r
.
front
(
)
.
value
(
)
-
>
sizeOfIncludingThis
(
mallocSizeOf
)
;
}
}
}
void
*
ZoneAllocator
:
:
onOutOfMemory
(
js
:
:
AllocFunction
allocFunc
arena_id_t
arena
size_t
nbytes
void
*
reallocPtr
)
{
if
(
!
js
:
:
CurrentThreadCanAccessRuntime
(
runtime_
)
)
{
return
nullptr
;
}
JS
:
:
AutoSuppressGCAnalysis
suppress
;
return
runtimeFromMainThread
(
)
-
>
onOutOfMemory
(
allocFunc
arena
nbytes
reallocPtr
)
;
}
void
ZoneAllocator
:
:
reportAllocationOverflow
(
)
const
{
js
:
:
ReportAllocationOverflow
(
nullptr
)
;
}
ZoneList
:
:
ZoneList
(
)
:
head
(
nullptr
)
tail
(
nullptr
)
{
}
ZoneList
:
:
ZoneList
(
Zone
*
zone
)
:
head
(
zone
)
tail
(
zone
)
{
MOZ_RELEASE_ASSERT
(
!
zone
-
>
isOnList
(
)
)
;
zone
-
>
listNext_
=
nullptr
;
}
ZoneList
:
:
~
ZoneList
(
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
}
void
ZoneList
:
:
check
(
)
const
{
#
ifdef
DEBUG
MOZ_ASSERT
(
(
head
=
=
nullptr
)
=
=
(
tail
=
=
nullptr
)
)
;
if
(
!
head
)
{
return
;
}
Zone
*
zone
=
head
;
for
(
;
;
)
{
MOZ_ASSERT
(
zone
&
&
zone
-
>
isOnList
(
)
)
;
if
(
zone
=
=
tail
)
break
;
zone
=
zone
-
>
listNext_
;
}
MOZ_ASSERT
(
!
zone
-
>
listNext_
)
;
#
endif
}
bool
ZoneList
:
:
isEmpty
(
)
const
{
return
head
=
=
nullptr
;
}
Zone
*
ZoneList
:
:
front
(
)
const
{
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
MOZ_ASSERT
(
head
-
>
isOnList
(
)
)
;
return
head
;
}
void
ZoneList
:
:
append
(
Zone
*
zone
)
{
ZoneList
singleZone
(
zone
)
;
transferFrom
(
singleZone
)
;
}
void
ZoneList
:
:
transferFrom
(
ZoneList
&
other
)
{
check
(
)
;
other
.
check
(
)
;
if
(
!
other
.
head
)
{
return
;
}
MOZ_ASSERT
(
tail
!
=
other
.
tail
)
;
if
(
tail
)
{
tail
-
>
listNext_
=
other
.
head
;
}
else
{
head
=
other
.
head
;
}
tail
=
other
.
tail
;
other
.
head
=
nullptr
;
other
.
tail
=
nullptr
;
}
Zone
*
ZoneList
:
:
removeFront
(
)
{
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
check
(
)
;
Zone
*
front
=
head
;
head
=
head
-
>
listNext_
;
if
(
!
head
)
{
tail
=
nullptr
;
}
front
-
>
listNext_
=
Zone
:
:
NotOnList
;
return
front
;
}
void
ZoneList
:
:
clear
(
)
{
while
(
!
isEmpty
(
)
)
{
removeFront
(
)
;
}
}
JS_PUBLIC_API
void
JS
:
:
shadow
:
:
RegisterWeakCache
(
JS
:
:
Zone
*
zone
detail
:
:
WeakCacheBase
*
cachep
)
{
zone
-
>
registerWeakCache
(
cachep
)
;
}
void
Zone
:
:
traceRootsInMajorGC
(
JSTracer
*
trc
)
{
if
(
trc
-
>
isMarkingTracer
(
)
&
&
!
isGCMarking
(
)
)
{
return
;
}
traceScriptTableRoots
(
trc
)
;
if
(
FinalizationObservers
*
observers
=
finalizationObservers
(
)
)
{
observers
-
>
traceRoots
(
trc
)
;
}
}
void
Zone
:
:
traceScriptTableRoots
(
JSTracer
*
trc
)
{
static_assert
(
std
:
:
is_convertible_v
<
BaseScript
*
gc
:
:
TenuredCell
*
>
"
BaseScript
must
not
be
nursery
-
allocated
for
script
-
table
"
"
tracing
to
work
"
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsMinorCollecting
(
)
)
;
if
(
scriptCountsMap
&
&
trc
-
>
runtime
(
)
-
>
profilingScripts
)
{
for
(
ScriptCountsMap
:
:
Range
r
=
scriptCountsMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
BaseScript
*
script
=
r
.
front
(
)
.
key
(
)
;
MOZ_ASSERT
(
script
-
>
hasScriptCounts
(
)
)
;
TraceRoot
(
trc
&
script
"
profilingScripts
"
)
;
}
}
if
(
debugScriptMap
)
{
DebugAPI
:
:
traceDebugScriptMap
(
trc
debugScriptMap
)
;
}
}
void
Zone
:
:
fixupScriptMapsAfterMovingGC
(
JSTracer
*
trc
)
{
if
(
scriptCountsMap
)
{
scriptCountsMap
-
>
traceWeak
(
trc
)
;
}
if
(
scriptLCovMap
)
{
scriptLCovMap
-
>
traceWeak
(
trc
)
;
}
#
ifdef
MOZ_VTUNE
if
(
scriptVTuneIdMap
)
{
scriptVTuneIdMap
-
>
traceWeak
(
trc
)
;
}
#
endif
#
ifdef
JS_CACHEIR_SPEW
if
(
scriptFinalWarmUpCountMap
)
{
scriptFinalWarmUpCountMap
-
>
traceWeak
(
trc
)
;
}
#
endif
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
Zone
:
:
checkScriptMapsAfterMovingGC
(
)
{
if
(
scriptCountsMap
)
{
for
(
auto
r
=
scriptCountsMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
BaseScript
*
script
=
r
.
front
(
)
.
key
(
)
;
MOZ_ASSERT
(
script
-
>
zone
(
)
=
=
this
)
;
CheckGCThingAfterMovingGC
(
script
)
;
auto
ptr
=
scriptCountsMap
-
>
lookup
(
script
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
if
(
scriptLCovMap
)
{
for
(
auto
r
=
scriptLCovMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
BaseScript
*
script
=
r
.
front
(
)
.
key
(
)
;
MOZ_ASSERT
(
script
-
>
zone
(
)
=
=
this
)
;
CheckGCThingAfterMovingGC
(
script
)
;
auto
ptr
=
scriptLCovMap
-
>
lookup
(
script
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
#
ifdef
MOZ_VTUNE
if
(
scriptVTuneIdMap
)
{
for
(
auto
r
=
scriptVTuneIdMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
BaseScript
*
script
=
r
.
front
(
)
.
key
(
)
;
MOZ_ASSERT
(
script
-
>
zone
(
)
=
=
this
)
;
CheckGCThingAfterMovingGC
(
script
)
;
auto
ptr
=
scriptVTuneIdMap
-
>
lookup
(
script
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
#
endif
#
ifdef
JS_CACHEIR_SPEW
if
(
scriptFinalWarmUpCountMap
)
{
for
(
auto
r
=
scriptFinalWarmUpCountMap
-
>
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
BaseScript
*
script
=
r
.
front
(
)
.
key
(
)
;
MOZ_ASSERT
(
script
-
>
zone
(
)
=
=
this
)
;
CheckGCThingAfterMovingGC
(
script
)
;
auto
ptr
=
scriptFinalWarmUpCountMap
-
>
lookup
(
script
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
#
endif
}
#
endif
void
Zone
:
:
clearScriptCounts
(
Realm
*
realm
)
{
if
(
!
scriptCountsMap
)
{
return
;
}
for
(
auto
i
=
scriptCountsMap
-
>
modIter
(
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
BaseScript
*
script
=
i
.
get
(
)
.
key
(
)
;
if
(
script
-
>
realm
(
)
!
=
realm
)
{
continue
;
}
if
(
script
-
>
hasBaselineScript
(
)
)
{
continue
;
}
script
-
>
clearHasScriptCounts
(
)
;
i
.
remove
(
)
;
}
}
void
Zone
:
:
clearScriptLCov
(
Realm
*
realm
)
{
if
(
!
scriptLCovMap
)
{
return
;
}
for
(
auto
i
=
scriptLCovMap
-
>
modIter
(
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
BaseScript
*
script
=
i
.
get
(
)
.
key
(
)
;
if
(
script
-
>
realm
(
)
=
=
realm
)
{
i
.
remove
(
)
;
}
}
}
void
Zone
:
:
clearRootsForShutdownGC
(
)
{
if
(
finalizationObservers
(
)
)
{
finalizationObservers
(
)
-
>
clearRecords
(
)
;
}
clearKeptObjects
(
)
;
}
void
Zone
:
:
finishRoots
(
)
{
for
(
RealmsInZoneIter
r
(
this
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
r
-
>
finishRoots
(
)
;
}
}
void
Zone
:
:
traceKeptObjects
(
JSTracer
*
trc
)
{
keptObjects
.
ref
(
)
.
trace
(
trc
)
;
}
bool
Zone
:
:
keepDuringJob
(
HandleObject
target
)
{
return
keptObjects
.
ref
(
)
.
put
(
target
)
;
}
void
Zone
:
:
clearKeptObjects
(
)
{
keptObjects
.
ref
(
)
.
clear
(
)
;
}
bool
Zone
:
:
ensureFinalizationObservers
(
)
{
if
(
finalizationObservers_
.
ref
(
)
)
{
return
true
;
}
finalizationObservers_
=
js
:
:
MakeUnique
<
FinalizationObservers
>
(
this
)
;
return
bool
(
finalizationObservers_
.
ref
(
)
)
;
}
