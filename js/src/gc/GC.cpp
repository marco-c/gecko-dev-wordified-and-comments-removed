#
include
"
gc
/
GC
-
inl
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
<
algorithm
>
#
include
<
initializer_list
>
#
include
<
iterator
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
utility
>
#
include
"
jsapi
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
debugger
/
DebugAPI
.
h
"
#
include
"
gc
/
ClearEdgesTracer
.
h
"
#
include
"
gc
/
GCContext
.
h
"
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
gc
/
GCLock
.
h
"
#
include
"
gc
/
GCProbes
.
h
"
#
include
"
gc
/
Memory
.
h
"
#
include
"
gc
/
ParallelMarking
.
h
"
#
include
"
gc
/
ParallelWork
.
h
"
#
include
"
gc
/
WeakMap
.
h
"
#
include
"
jit
/
ExecutableAllocator
.
h
"
#
include
"
jit
/
JitCode
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
jit
/
ProcessExecutableMemory
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
Printer
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
util
/
DifferentialTesting
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
EnvironmentObject
.
h
"
#
include
"
vm
/
GetterSetter
.
h
"
#
include
"
vm
/
HelperThreadState
.
h
"
#
include
"
vm
/
JitActivation
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
PropMap
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
SymbolType
.
h
"
#
include
"
vm
/
Time
.
h
"
#
include
"
gc
/
Heap
-
inl
.
h
"
#
include
"
gc
/
Nursery
-
inl
.
h
"
#
include
"
gc
/
ObjectKind
-
inl
.
h
"
#
include
"
gc
/
PrivateIterators
-
inl
.
h
"
#
include
"
vm
/
GeckoProfiler
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
Realm
-
inl
.
h
"
#
include
"
vm
/
Stack
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
mozilla
:
:
MakeScopeExit
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
using
mozilla
:
:
TimeDuration
;
using
mozilla
:
:
TimeStamp
;
using
JS
:
:
AutoGCRooter
;
const
AllocKind
gc
:
:
slotsToThingKind
[
]
=
{
AllocKind
:
:
OBJECT0
AllocKind
:
:
OBJECT2
AllocKind
:
:
OBJECT2
AllocKind
:
:
OBJECT4
AllocKind
:
:
OBJECT4
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT16
AllocKind
:
:
OBJECT16
AllocKind
:
:
OBJECT16
AllocKind
:
:
OBJECT16
}
;
static_assert
(
std
:
:
size
(
slotsToThingKind
)
=
=
SLOTS_TO_THING_KIND_LIMIT
"
We
have
defined
a
slot
count
for
each
kind
.
"
)
;
MOZ_THREAD_LOCAL
(
JS
:
:
GCContext
*
)
js
:
:
TlsGCContext
;
JS
:
:
GCContext
:
:
GCContext
(
JSRuntime
*
runtime
)
:
runtime_
(
runtime
)
{
}
JS
:
:
GCContext
:
:
~
GCContext
(
)
{
MOZ_ASSERT
(
!
hasJitCodeToPoison
(
)
)
;
MOZ_ASSERT
(
!
isCollecting
(
)
)
;
MOZ_ASSERT
(
gcUse
(
)
=
=
GCUse
:
:
None
)
;
MOZ_ASSERT
(
!
gcSweepZone
(
)
)
;
MOZ_ASSERT
(
!
isTouchingGrayThings
(
)
)
;
}
void
JS
:
:
GCContext
:
:
poisonJitCode
(
)
{
if
(
hasJitCodeToPoison
(
)
)
{
jit
:
:
ExecutableAllocator
:
:
poisonCode
(
runtime
(
)
jitPoisonRanges
)
;
jitPoisonRanges
.
clearAndFree
(
)
;
}
}
#
ifdef
DEBUG
void
GCRuntime
:
:
verifyAllChunks
(
)
{
AutoLockGC
lock
(
this
)
;
fullChunks
(
lock
)
.
verifyChunks
(
)
;
availableChunks
(
lock
)
.
verifyChunks
(
)
;
emptyChunks
(
lock
)
.
verifyChunks
(
)
;
}
#
endif
void
GCRuntime
:
:
setMinEmptyChunkCount
(
uint32_t
value
const
AutoLockGC
&
lock
)
{
minEmptyChunkCount_
=
value
;
if
(
minEmptyChunkCount_
>
maxEmptyChunkCount_
)
{
maxEmptyChunkCount_
=
minEmptyChunkCount_
;
}
MOZ_ASSERT
(
maxEmptyChunkCount_
>
=
minEmptyChunkCount_
)
;
}
void
GCRuntime
:
:
setMaxEmptyChunkCount
(
uint32_t
value
const
AutoLockGC
&
lock
)
{
maxEmptyChunkCount_
=
value
;
if
(
minEmptyChunkCount_
>
maxEmptyChunkCount_
)
{
minEmptyChunkCount_
=
maxEmptyChunkCount_
;
}
MOZ_ASSERT
(
maxEmptyChunkCount_
>
=
minEmptyChunkCount_
)
;
}
inline
bool
GCRuntime
:
:
tooManyEmptyChunks
(
const
AutoLockGC
&
lock
)
{
return
emptyChunks
(
lock
)
.
count
(
)
>
minEmptyChunkCount
(
lock
)
;
}
ChunkPool
GCRuntime
:
:
expireEmptyChunkPool
(
const
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
emptyChunks
(
lock
)
.
verify
(
)
)
;
MOZ_ASSERT
(
minEmptyChunkCount
(
lock
)
<
=
maxEmptyChunkCount
(
lock
)
)
;
ChunkPool
expired
;
while
(
tooManyEmptyChunks
(
lock
)
)
{
TenuredChunk
*
chunk
=
emptyChunks
(
lock
)
.
pop
(
)
;
prepareToFreeChunk
(
chunk
-
>
info
)
;
expired
.
push
(
chunk
)
;
}
MOZ_ASSERT
(
expired
.
verify
(
)
)
;
MOZ_ASSERT
(
emptyChunks
(
lock
)
.
verify
(
)
)
;
MOZ_ASSERT
(
emptyChunks
(
lock
)
.
count
(
)
<
=
maxEmptyChunkCount
(
lock
)
)
;
MOZ_ASSERT
(
emptyChunks
(
lock
)
.
count
(
)
<
=
minEmptyChunkCount
(
lock
)
)
;
return
expired
;
}
static
void
FreeChunkPool
(
ChunkPool
&
pool
)
{
for
(
ChunkPool
:
:
Iter
iter
(
pool
)
;
!
iter
.
done
(
)
;
)
{
TenuredChunk
*
chunk
=
iter
.
get
(
)
;
iter
.
next
(
)
;
pool
.
remove
(
chunk
)
;
MOZ_ASSERT
(
chunk
-
>
unused
(
)
)
;
UnmapPages
(
static_cast
<
void
*
>
(
chunk
)
ChunkSize
)
;
}
MOZ_ASSERT
(
pool
.
count
(
)
=
=
0
)
;
}
void
GCRuntime
:
:
freeEmptyChunks
(
const
AutoLockGC
&
lock
)
{
FreeChunkPool
(
emptyChunks
(
lock
)
)
;
}
inline
void
GCRuntime
:
:
prepareToFreeChunk
(
TenuredChunkInfo
&
info
)
{
MOZ_ASSERT
(
numArenasFreeCommitted
>
=
info
.
numArenasFreeCommitted
)
;
numArenasFreeCommitted
-
=
info
.
numArenasFreeCommitted
;
stats
(
)
.
count
(
gcstats
:
:
COUNT_DESTROY_CHUNK
)
;
#
ifdef
DEBUG
info
.
numArenasFreeCommitted
=
0
;
#
endif
}
void
GCRuntime
:
:
releaseArena
(
Arena
*
arena
const
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
arena
-
>
allocated
(
)
)
;
MOZ_ASSERT
(
!
arena
-
>
onDelayedMarkingList
(
)
)
;
MOZ_ASSERT
(
TlsGCContext
.
get
(
)
-
>
isFinalizing
(
)
)
;
arena
-
>
zone
-
>
gcHeapSize
.
removeGCArena
(
heapSize
)
;
arena
-
>
release
(
lock
)
;
arena
-
>
chunk
(
)
-
>
releaseArena
(
this
arena
lock
)
;
}
GCRuntime
:
:
GCRuntime
(
JSRuntime
*
rt
)
:
rt
(
rt
)
systemZone
(
nullptr
)
mainThreadContext
(
rt
)
heapState_
(
JS
:
:
HeapState
:
:
Idle
)
stats_
(
this
)
sweepingTracer
(
rt
)
fullGCRequested
(
false
)
helperThreadRatio
(
TuningDefaults
:
:
HelperThreadRatio
)
maxHelperThreads
(
TuningDefaults
:
:
MaxHelperThreads
)
helperThreadCount
(
1
)
createBudgetCallback
(
nullptr
)
minEmptyChunkCount_
(
TuningDefaults
:
:
MinEmptyChunkCount
)
maxEmptyChunkCount_
(
TuningDefaults
:
:
MaxEmptyChunkCount
)
rootsHash
(
256
)
nextCellUniqueId_
(
LargestTaggedNullCellPointer
+
1
)
numArenasFreeCommitted
(
0
)
verifyPreData
(
nullptr
)
lastGCStartTime_
(
TimeStamp
:
:
Now
(
)
)
lastGCEndTime_
(
TimeStamp
:
:
Now
(
)
)
incrementalGCEnabled
(
TuningDefaults
:
:
IncrementalGCEnabled
)
perZoneGCEnabled
(
TuningDefaults
:
:
PerZoneGCEnabled
)
numActiveZoneIters
(
0
)
cleanUpEverything
(
false
)
grayBitsValid
(
true
)
majorGCTriggerReason
(
JS
:
:
GCReason
:
:
NO_REASON
)
minorGCNumber
(
0
)
majorGCNumber
(
0
)
number
(
0
)
sliceNumber
(
0
)
isFull
(
false
)
incrementalState
(
gc
:
:
State
:
:
NotActive
)
initialState
(
gc
:
:
State
:
:
NotActive
)
useZeal
(
false
)
lastMarkSlice
(
false
)
safeToYield
(
true
)
markOnBackgroundThreadDuringSweeping
(
false
)
useBackgroundThreads
(
false
)
#
ifdef
DEBUG
hadShutdownGC
(
false
)
#
endif
requestSliceAfterBackgroundTask
(
false
)
lifoBlocksToFree
(
(
size_t
)
JSContext
:
:
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
)
lifoBlocksToFreeAfterMinorGC
(
(
size_t
)
JSContext
:
:
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
)
sweepGroupIndex
(
0
)
sweepGroups
(
nullptr
)
currentSweepGroup
(
nullptr
)
sweepZone
(
nullptr
)
abortSweepAfterCurrentGroup
(
false
)
sweepMarkResult
(
IncrementalProgress
:
:
NotFinished
)
#
ifdef
DEBUG
testMarkQueue
(
rt
)
#
endif
startedCompacting
(
false
)
zonesCompacted
(
0
)
#
ifdef
DEBUG
relocatedArenasToRelease
(
nullptr
)
#
endif
#
ifdef
JS_GC_ZEAL
markingValidator
(
nullptr
)
#
endif
defaultTimeBudgetMS_
(
TuningDefaults
:
:
DefaultTimeBudgetMS
)
incrementalAllowed
(
true
)
compactingEnabled
(
TuningDefaults
:
:
CompactingEnabled
)
parallelMarkingEnabled
(
TuningDefaults
:
:
ParallelMarkingEnabled
)
rootsRemoved
(
false
)
#
ifdef
JS_GC_ZEAL
zealModeBits
(
0
)
zealFrequency
(
0
)
nextScheduled
(
0
)
deterministicOnly
(
false
)
zealSliceBudget
(
0
)
selectedForMarking
(
rt
)
#
endif
fullCompartmentChecks
(
false
)
gcCallbackDepth
(
0
)
alwaysPreserveCode
(
false
)
lowMemoryState
(
false
)
lock
(
mutexid
:
:
GCLock
)
storeBufferLock
(
mutexid
:
:
StoreBuffer
)
delayedMarkingLock
(
mutexid
:
:
GCDelayedMarkingLock
)
allocTask
(
this
emptyChunks_
.
ref
(
)
)
unmarkTask
(
this
)
markTask
(
this
)
sweepTask
(
this
)
freeTask
(
this
)
decommitTask
(
this
)
nursery_
(
this
)
storeBuffer_
(
rt
)
lastAllocRateUpdateTime
(
TimeStamp
:
:
Now
(
)
)
{
}
using
CharRange
=
mozilla
:
:
Range
<
const
char
>
;
using
CharRangeVector
=
Vector
<
CharRange
0
SystemAllocPolicy
>
;
static
bool
SplitStringBy
(
const
CharRange
&
text
char
delimiter
CharRangeVector
*
result
)
{
auto
start
=
text
.
begin
(
)
;
for
(
auto
ptr
=
start
;
ptr
!
=
text
.
end
(
)
;
ptr
+
+
)
{
if
(
*
ptr
=
=
delimiter
)
{
if
(
!
result
-
>
emplaceBack
(
start
ptr
)
)
{
return
false
;
}
start
=
ptr
+
1
;
}
}
return
result
-
>
emplaceBack
(
start
text
.
end
(
)
)
;
}
static
bool
ParseTimeDuration
(
const
CharRange
&
text
TimeDuration
*
durationOut
)
{
const
char
*
str
=
text
.
begin
(
)
.
get
(
)
;
char
*
end
;
long
millis
=
strtol
(
str
&
end
10
)
;
*
durationOut
=
TimeDuration
:
:
FromMilliseconds
(
double
(
millis
)
)
;
return
str
!
=
end
&
&
end
=
=
text
.
end
(
)
.
get
(
)
;
}
static
void
PrintProfileHelpAndExit
(
const
char
*
envName
const
char
*
helpText
)
{
fprintf
(
stderr
"
%
s
=
N
[
(
main
|
all
)
]
\
n
"
envName
)
;
fprintf
(
stderr
"
%
s
"
helpText
)
;
exit
(
0
)
;
}
void
js
:
:
gc
:
:
ReadProfileEnv
(
const
char
*
envName
const
char
*
helpText
bool
*
enableOut
bool
*
workersOut
TimeDuration
*
thresholdOut
)
{
*
enableOut
=
false
;
*
workersOut
=
false
;
*
thresholdOut
=
TimeDuration
:
:
Zero
(
)
;
const
char
*
env
=
getenv
(
envName
)
;
if
(
!
env
)
{
return
;
}
if
(
strcmp
(
env
"
help
"
)
=
=
0
)
{
PrintProfileHelpAndExit
(
envName
helpText
)
;
}
CharRangeVector
parts
;
auto
text
=
CharRange
(
env
strlen
(
env
)
)
;
if
(
!
SplitStringBy
(
text
'
'
&
parts
)
)
{
MOZ_CRASH
(
"
OOM
parsing
environment
variable
"
)
;
}
if
(
parts
.
length
(
)
=
=
0
|
|
parts
.
length
(
)
>
2
)
{
PrintProfileHelpAndExit
(
envName
helpText
)
;
}
*
enableOut
=
true
;
if
(
!
ParseTimeDuration
(
parts
[
0
]
thresholdOut
)
)
{
PrintProfileHelpAndExit
(
envName
helpText
)
;
}
if
(
parts
.
length
(
)
=
=
2
)
{
const
char
*
threads
=
parts
[
1
]
.
begin
(
)
.
get
(
)
;
if
(
strcmp
(
threads
"
all
"
)
=
=
0
)
{
*
workersOut
=
true
;
}
else
if
(
strcmp
(
threads
"
main
"
)
!
=
0
)
{
PrintProfileHelpAndExit
(
envName
helpText
)
;
}
}
}
bool
js
:
:
gc
:
:
ShouldPrintProfile
(
JSRuntime
*
runtime
bool
enable
bool
profileWorkers
TimeDuration
threshold
TimeDuration
duration
)
{
return
enable
&
&
(
runtime
-
>
isMainRuntime
(
)
|
|
profileWorkers
)
&
&
duration
>
=
threshold
;
}
#
ifdef
JS_GC_ZEAL
void
GCRuntime
:
:
getZealBits
(
uint32_t
*
zealBits
uint32_t
*
frequency
uint32_t
*
scheduled
)
{
*
zealBits
=
zealModeBits
;
*
frequency
=
zealFrequency
;
*
scheduled
=
nextScheduled
;
}
const
char
gc
:
:
ZealModeHelpText
[
]
=
"
Specifies
how
zealous
the
garbage
collector
should
be
.
Some
of
these
"
"
modes
can
\
n
"
"
be
set
simultaneously
by
passing
multiple
level
options
e
.
g
.
\
"
2
;
4
\
"
"
"
will
activate
\
n
"
"
both
modes
2
and
4
.
Modes
can
be
specified
by
name
or
number
.
\
n
"
"
\
n
"
"
Values
:
\
n
"
"
0
:
(
None
)
Normal
amount
of
collection
(
resets
all
modes
)
\
n
"
"
1
:
(
RootsChange
)
Collect
when
roots
are
added
or
removed
\
n
"
"
2
:
(
Alloc
)
Collect
when
every
N
allocations
(
default
:
100
)
\
n
"
"
4
:
(
VerifierPre
)
Verify
pre
write
barriers
between
instructions
\
n
"
"
6
:
(
YieldBeforeRootMarking
)
Incremental
GC
in
two
slices
that
yields
"
"
before
root
marking
\
n
"
"
7
:
(
GenerationalGC
)
Collect
the
nursery
every
N
nursery
allocations
\
n
"
"
8
:
(
YieldBeforeMarking
)
Incremental
GC
in
two
slices
that
yields
"
"
between
\
n
"
"
the
root
marking
and
marking
phases
\
n
"
"
9
:
(
YieldBeforeSweeping
)
Incremental
GC
in
two
slices
that
yields
"
"
between
\
n
"
"
the
marking
and
sweeping
phases
\
n
"
"
10
:
(
IncrementalMultipleSlices
)
Incremental
GC
in
many
slices
\
n
"
"
11
:
(
IncrementalMarkingValidator
)
Verify
incremental
marking
\
n
"
"
12
:
(
ElementsBarrier
)
Use
the
individual
element
post
-
write
barrier
\
n
"
"
regardless
of
elements
size
\
n
"
"
13
:
(
CheckHashTablesOnMinorGC
)
Check
internal
hashtables
on
minor
GC
\
n
"
"
14
:
(
Compact
)
Perform
a
shrinking
collection
every
N
allocations
\
n
"
"
15
:
(
CheckHeapAfterGC
)
Walk
the
heap
to
check
its
integrity
after
"
"
every
GC
\
n
"
"
17
:
(
YieldBeforeSweepingAtoms
)
Incremental
GC
in
two
slices
that
"
"
yields
\
n
"
"
before
sweeping
the
atoms
table
\
n
"
"
18
:
(
CheckGrayMarking
)
Check
gray
marking
invariants
after
every
GC
\
n
"
"
19
:
(
YieldBeforeSweepingCaches
)
Incremental
GC
in
two
slices
that
"
"
yields
\
n
"
"
before
sweeping
weak
caches
\
n
"
"
21
:
(
YieldBeforeSweepingObjects
)
Incremental
GC
in
two
slices
that
"
"
yields
\
n
"
"
before
sweeping
foreground
finalized
objects
\
n
"
"
22
:
(
YieldBeforeSweepingNonObjects
)
Incremental
GC
in
two
slices
that
"
"
yields
\
n
"
"
before
sweeping
non
-
object
GC
things
\
n
"
"
23
:
(
YieldBeforeSweepingPropMapTrees
)
Incremental
GC
in
two
slices
"
"
that
"
"
yields
\
n
"
"
before
sweeping
shape
trees
\
n
"
"
24
:
(
CheckWeakMapMarking
)
Check
weak
map
marking
invariants
after
"
"
every
GC
\
n
"
"
25
:
(
YieldWhileGrayMarking
)
Incremental
GC
in
two
slices
that
yields
\
n
"
"
during
gray
marking
\
n
"
;
static
const
mozilla
:
:
EnumSet
<
ZealMode
>
IncrementalSliceZealModes
=
{
ZealMode
:
:
YieldBeforeRootMarking
ZealMode
:
:
YieldBeforeMarking
ZealMode
:
:
YieldBeforeSweeping
ZealMode
:
:
IncrementalMultipleSlices
ZealMode
:
:
YieldBeforeSweepingAtoms
ZealMode
:
:
YieldBeforeSweepingCaches
ZealMode
:
:
YieldBeforeSweepingObjects
ZealMode
:
:
YieldBeforeSweepingNonObjects
ZealMode
:
:
YieldBeforeSweepingPropMapTrees
}
;
void
GCRuntime
:
:
setZeal
(
uint8_t
zeal
uint32_t
frequency
)
{
MOZ_ASSERT
(
zeal
<
=
unsigned
(
ZealMode
:
:
Limit
)
)
;
if
(
verifyPreData
)
{
VerifyBarriers
(
rt
PreBarrierVerifier
)
;
}
if
(
zeal
=
=
0
)
{
if
(
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
)
{
evictNursery
(
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
nursery
(
)
.
leaveZealMode
(
)
;
}
if
(
isIncrementalGCInProgress
(
)
)
{
finishGC
(
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
}
ZealMode
zealMode
=
ZealMode
(
zeal
)
;
if
(
zealMode
=
=
ZealMode
:
:
GenerationalGC
)
{
evictNursery
(
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
nursery
(
)
.
enterZealMode
(
)
;
}
if
(
IncrementalSliceZealModes
.
contains
(
zealMode
)
)
{
for
(
auto
mode
:
IncrementalSliceZealModes
)
{
clearZealMode
(
mode
)
;
}
}
bool
schedule
=
zealMode
>
=
ZealMode
:
:
Alloc
;
if
(
zeal
!
=
0
)
{
zealModeBits
|
=
1
<
<
unsigned
(
zeal
)
;
}
else
{
zealModeBits
=
0
;
}
zealFrequency
=
frequency
;
nextScheduled
=
schedule
?
frequency
:
0
;
}
void
GCRuntime
:
:
unsetZeal
(
uint8_t
zeal
)
{
MOZ_ASSERT
(
zeal
<
=
unsigned
(
ZealMode
:
:
Limit
)
)
;
ZealMode
zealMode
=
ZealMode
(
zeal
)
;
if
(
!
hasZealMode
(
zealMode
)
)
{
return
;
}
if
(
verifyPreData
)
{
VerifyBarriers
(
rt
PreBarrierVerifier
)
;
}
if
(
zealMode
=
=
ZealMode
:
:
GenerationalGC
)
{
evictNursery
(
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
nursery
(
)
.
leaveZealMode
(
)
;
}
clearZealMode
(
zealMode
)
;
if
(
zealModeBits
=
=
0
)
{
if
(
isIncrementalGCInProgress
(
)
)
{
finishGC
(
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
zealFrequency
=
0
;
nextScheduled
=
0
;
}
}
void
GCRuntime
:
:
setNextScheduled
(
uint32_t
count
)
{
nextScheduled
=
count
;
}
static
bool
ParseZealModeName
(
const
CharRange
&
text
uint32_t
*
modeOut
)
{
struct
ModeInfo
{
const
char
*
name
;
size_t
length
;
uint32_t
value
;
}
;
static
const
ModeInfo
zealModes
[
]
=
{
{
"
None
"
0
}
#
define
ZEAL_MODE
(
name
value
)
{
#
name
strlen
(
#
name
)
value
}
JS_FOR_EACH_ZEAL_MODE
(
ZEAL_MODE
)
#
undef
ZEAL_MODE
}
;
for
(
auto
mode
:
zealModes
)
{
if
(
text
.
length
(
)
=
=
mode
.
length
&
&
memcmp
(
text
.
begin
(
)
.
get
(
)
mode
.
name
mode
.
length
)
=
=
0
)
{
*
modeOut
=
mode
.
value
;
return
true
;
}
}
return
false
;
}
static
bool
ParseZealModeNumericParam
(
const
CharRange
&
text
uint32_t
*
paramOut
)
{
if
(
text
.
length
(
)
=
=
0
)
{
return
false
;
}
for
(
auto
c
:
text
)
{
if
(
!
mozilla
:
:
IsAsciiDigit
(
c
)
)
{
return
false
;
}
}
*
paramOut
=
atoi
(
text
.
begin
(
)
.
get
(
)
)
;
return
true
;
}
static
bool
PrintZealHelpAndFail
(
)
{
fprintf
(
stderr
"
Format
:
JS_GC_ZEAL
=
level
(
;
level
)
*
[
N
]
\
n
"
)
;
fputs
(
ZealModeHelpText
stderr
)
;
return
false
;
}
bool
GCRuntime
:
:
parseAndSetZeal
(
const
char
*
str
)
{
auto
text
=
CharRange
(
str
strlen
(
str
)
)
;
CharRangeVector
parts
;
if
(
!
SplitStringBy
(
text
'
'
&
parts
)
)
{
return
false
;
}
if
(
parts
.
length
(
)
=
=
0
|
|
parts
.
length
(
)
>
2
)
{
return
PrintZealHelpAndFail
(
)
;
}
uint32_t
frequency
=
JS_DEFAULT_ZEAL_FREQ
;
if
(
parts
.
length
(
)
=
=
2
&
&
!
ParseZealModeNumericParam
(
parts
[
1
]
&
frequency
)
)
{
return
PrintZealHelpAndFail
(
)
;
}
CharRangeVector
modes
;
if
(
!
SplitStringBy
(
parts
[
0
]
'
;
'
&
modes
)
)
{
return
false
;
}
for
(
const
auto
&
descr
:
modes
)
{
uint32_t
mode
;
if
(
!
ParseZealModeName
(
descr
&
mode
)
&
&
!
(
ParseZealModeNumericParam
(
descr
&
mode
)
&
&
mode
<
=
unsigned
(
ZealMode
:
:
Limit
)
)
)
{
return
PrintZealHelpAndFail
(
)
;
}
setZeal
(
mode
frequency
)
;
}
return
true
;
}
const
char
*
js
:
:
gc
:
:
AllocKindName
(
AllocKind
kind
)
{
static
const
char
*
const
names
[
]
=
{
#
define
EXPAND_THING_NAME
(
allocKind
_1
_2
_3
_4
_5
_6
)
#
allocKind
FOR_EACH_ALLOCKIND
(
EXPAND_THING_NAME
)
#
undef
EXPAND_THING_NAME
}
;
static_assert
(
std
:
:
size
(
names
)
=
=
AllocKindCount
"
names
array
should
have
an
entry
for
every
AllocKind
"
)
;
size_t
i
=
size_t
(
kind
)
;
MOZ_ASSERT
(
i
<
std
:
:
size
(
names
)
)
;
return
names
[
i
]
;
}
void
js
:
:
gc
:
:
DumpArenaInfo
(
)
{
fprintf
(
stderr
"
Arena
header
size
:
%
zu
\
n
\
n
"
ArenaHeaderSize
)
;
fprintf
(
stderr
"
GC
thing
kinds
:
\
n
"
)
;
fprintf
(
stderr
"
%
25s
%
8s
%
8s
%
8s
\
n
"
"
AllocKind
:
"
"
Size
:
"
"
Count
:
"
"
Padding
:
"
)
;
for
(
auto
kind
:
AllAllocKinds
(
)
)
{
fprintf
(
stderr
"
%
25s
%
8zu
%
8zu
%
8zu
\
n
"
AllocKindName
(
kind
)
Arena
:
:
thingSize
(
kind
)
Arena
:
:
thingsPerArena
(
kind
)
Arena
:
:
firstThingOffset
(
kind
)
-
ArenaHeaderSize
)
;
}
}
#
endif
bool
GCRuntime
:
:
init
(
uint32_t
maxbytes
)
{
MOZ_ASSERT
(
!
wasInitialized
(
)
)
;
MOZ_ASSERT
(
SystemPageSize
(
)
)
;
Arena
:
:
checkLookupTables
(
)
;
if
(
!
TlsGCContext
.
init
(
)
)
{
return
false
;
}
TlsGCContext
.
set
(
&
mainThreadContext
.
ref
(
)
)
;
updateHelperThreadCount
(
)
;
#
ifdef
JS_GC_ZEAL
const
char
*
size
=
getenv
(
"
JSGC_MARK_STACK_LIMIT
"
)
;
if
(
size
)
{
maybeMarkStackLimit
=
atoi
(
size
)
;
}
#
endif
if
(
!
updateMarkersVector
(
)
)
{
return
false
;
}
{
AutoLockGCBgAlloc
lock
(
this
)
;
MOZ_ALWAYS_TRUE
(
tunables
.
setParameter
(
JSGC_MAX_BYTES
maxbytes
)
)
;
if
(
!
nursery
(
)
.
init
(
lock
)
)
{
return
false
;
}
}
#
ifdef
JS_GC_ZEAL
const
char
*
zealSpec
=
getenv
(
"
JS_GC_ZEAL
"
)
;
if
(
zealSpec
&
&
zealSpec
[
0
]
&
&
!
parseAndSetZeal
(
zealSpec
)
)
{
return
false
;
}
#
endif
for
(
auto
&
marker
:
markers
)
{
if
(
!
marker
-
>
init
(
)
)
{
return
false
;
}
}
if
(
!
initSweepActions
(
)
)
{
return
false
;
}
UniquePtr
<
Zone
>
zone
=
MakeUnique
<
Zone
>
(
rt
Zone
:
:
AtomsZone
)
;
if
(
!
zone
|
|
!
zone
-
>
init
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
zone
-
>
isAtomsZone
(
)
)
;
MOZ_ASSERT
(
zones
(
)
.
empty
(
)
)
;
MOZ_ALWAYS_TRUE
(
zones
(
)
.
reserve
(
1
)
)
;
zones
(
)
.
infallibleAppend
(
zone
.
release
(
)
)
;
gcprobes
:
:
Init
(
this
)
;
initialized
=
true
;
return
true
;
}
void
GCRuntime
:
:
finish
(
)
{
MOZ_ASSERT
(
inPageLoadCount
=
=
0
)
;
MOZ_ASSERT
(
!
sharedAtomsZone_
)
;
if
(
nursery
(
)
.
isEnabled
(
)
)
{
nursery
(
)
.
disable
(
)
;
}
sweepTask
.
join
(
)
;
markTask
.
join
(
)
;
freeTask
.
join
(
)
;
allocTask
.
cancelAndWait
(
)
;
decommitTask
.
cancelAndWait
(
)
;
#
ifdef
JS_GC_ZEAL
finishVerifier
(
)
;
#
endif
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
rt
-
>
gcContext
(
)
zone
)
;
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
for
(
RealmsInCompartmentIter
realm
(
comp
)
;
!
realm
.
done
(
)
;
realm
.
next
(
)
)
{
js_delete
(
realm
.
get
(
)
)
;
}
comp
-
>
realms
(
)
.
clear
(
)
;
js_delete
(
comp
.
get
(
)
)
;
}
zone
-
>
compartments
(
)
.
clear
(
)
;
js_delete
(
zone
.
get
(
)
)
;
}
zones
(
)
.
clear
(
)
;
FreeChunkPool
(
fullChunks_
.
ref
(
)
)
;
FreeChunkPool
(
availableChunks_
.
ref
(
)
)
;
FreeChunkPool
(
emptyChunks_
.
ref
(
)
)
;
TlsGCContext
.
set
(
nullptr
)
;
gcprobes
:
:
Finish
(
this
)
;
nursery
(
)
.
printTotalProfileTimes
(
)
;
stats
(
)
.
printTotalProfileTimes
(
)
;
}
bool
GCRuntime
:
:
freezeSharedAtomsZone
(
)
{
MOZ_ASSERT
(
rt
-
>
isMainRuntime
(
)
)
;
MOZ_ASSERT
(
!
sharedAtomsZone_
)
;
MOZ_ASSERT
(
zones
(
)
.
length
(
)
=
=
1
)
;
MOZ_ASSERT
(
atomsZone
(
)
)
;
MOZ_ASSERT
(
!
atomsZone
(
)
-
>
wasGCStarted
(
)
)
;
MOZ_ASSERT
(
!
atomsZone
(
)
-
>
needsIncrementalBarrier
(
)
)
;
AutoAssertEmptyNursery
nurseryIsEmpty
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
atomsZone
(
)
-
>
arenas
.
clearFreeLists
(
)
;
for
(
auto
kind
:
AllAllocKinds
(
)
)
{
for
(
auto
thing
=
atomsZone
(
)
-
>
cellIterUnsafe
<
TenuredCell
>
(
kind
nurseryIsEmpty
)
;
!
thing
.
done
(
)
;
thing
.
next
(
)
)
{
TenuredCell
*
cell
=
thing
.
getCell
(
)
;
MOZ_ASSERT
(
(
cell
-
>
is
<
JSString
>
(
)
&
&
cell
-
>
as
<
JSString
>
(
)
-
>
isPermanentAndMayBeShared
(
)
)
|
|
(
cell
-
>
is
<
JS
:
:
Symbol
>
(
)
&
&
cell
-
>
as
<
JS
:
:
Symbol
>
(
)
-
>
isPermanentAndMayBeShared
(
)
)
)
;
cell
-
>
markBlack
(
)
;
}
}
sharedAtomsZone_
=
atomsZone
(
)
;
zones
(
)
.
clear
(
)
;
UniquePtr
<
Zone
>
zone
=
MakeUnique
<
Zone
>
(
rt
Zone
:
:
AtomsZone
)
;
if
(
!
zone
|
|
!
zone
-
>
init
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
zone
-
>
isAtomsZone
(
)
)
;
zones
(
)
.
infallibleAppend
(
zone
.
release
(
)
)
;
return
true
;
}
void
GCRuntime
:
:
restoreSharedAtomsZone
(
)
{
if
(
!
sharedAtomsZone_
)
{
return
;
}
MOZ_ASSERT
(
rt
-
>
isMainRuntime
(
)
)
;
MOZ_ASSERT
(
rt
-
>
childRuntimeCount
=
=
0
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
zones
(
)
.
append
(
sharedAtomsZone_
)
)
{
oomUnsafe
.
crash
(
"
restoreSharedAtomsZone
"
)
;
}
sharedAtomsZone_
=
nullptr
;
}
bool
GCRuntime
:
:
setParameter
(
JSContext
*
cx
JSGCParamKey
key
uint32_t
value
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
AutoStopVerifyingBarriers
pauseVerification
(
rt
false
)
;
FinishGC
(
cx
)
;
waitBackgroundSweepEnd
(
)
;
AutoLockGC
lock
(
this
)
;
return
setParameter
(
key
value
lock
)
;
}
static
bool
IsGCThreadParameter
(
JSGCParamKey
key
)
{
return
key
=
=
JSGC_HELPER_THREAD_RATIO
|
|
key
=
=
JSGC_MAX_HELPER_THREADS
|
|
key
=
=
JSGC_MARKING_THREAD_COUNT
;
}
bool
GCRuntime
:
:
setParameter
(
JSGCParamKey
key
uint32_t
value
AutoLockGC
&
lock
)
{
switch
(
key
)
{
case
JSGC_SLICE_TIME_BUDGET_MS
:
defaultTimeBudgetMS_
=
value
;
break
;
case
JSGC_INCREMENTAL_GC_ENABLED
:
setIncrementalGCEnabled
(
value
!
=
0
)
;
break
;
case
JSGC_PER_ZONE_GC_ENABLED
:
perZoneGCEnabled
=
value
!
=
0
;
break
;
case
JSGC_COMPACTING_ENABLED
:
compactingEnabled
=
value
!
=
0
;
break
;
case
JSGC_PARALLEL_MARKING_ENABLED
:
parallelMarkingEnabled
=
rt
-
>
isMainRuntime
(
)
&
&
value
!
=
0
;
return
initOrDisableParallelMarking
(
)
;
case
JSGC_INCREMENTAL_WEAKMAP_ENABLED
:
for
(
auto
&
marker
:
markers
)
{
marker
-
>
incrementalWeakMapMarkingEnabled
=
value
!
=
0
;
}
break
;
case
JSGC_MIN_EMPTY_CHUNK_COUNT
:
setMinEmptyChunkCount
(
value
lock
)
;
break
;
case
JSGC_MAX_EMPTY_CHUNK_COUNT
:
setMaxEmptyChunkCount
(
value
lock
)
;
break
;
default
:
if
(
IsGCThreadParameter
(
key
)
)
{
return
setThreadParameter
(
key
value
lock
)
;
}
if
(
!
tunables
.
setParameter
(
key
value
)
)
{
return
false
;
}
updateAllGCStartThresholds
(
)
;
}
return
true
;
}
bool
GCRuntime
:
:
setThreadParameter
(
JSGCParamKey
key
uint32_t
value
AutoLockGC
&
lock
)
{
if
(
rt
-
>
parentRuntime
)
{
return
false
;
}
switch
(
key
)
{
case
JSGC_HELPER_THREAD_RATIO
:
if
(
value
=
=
0
)
{
return
false
;
}
helperThreadRatio
=
double
(
value
)
/
100
.
0
;
break
;
case
JSGC_MAX_HELPER_THREADS
:
if
(
value
=
=
0
)
{
return
false
;
}
maxHelperThreads
=
value
;
break
;
case
JSGC_MARKING_THREAD_COUNT
:
markingThreadCount
=
std
:
:
min
(
size_t
(
value
)
MaxParallelWorkers
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
parameter
key
"
)
;
}
updateHelperThreadCount
(
)
;
initOrDisableParallelMarking
(
)
;
return
true
;
}
void
GCRuntime
:
:
resetParameter
(
JSContext
*
cx
JSGCParamKey
key
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
AutoStopVerifyingBarriers
pauseVerification
(
rt
false
)
;
FinishGC
(
cx
)
;
waitBackgroundSweepEnd
(
)
;
AutoLockGC
lock
(
this
)
;
resetParameter
(
key
lock
)
;
}
void
GCRuntime
:
:
resetParameter
(
JSGCParamKey
key
AutoLockGC
&
lock
)
{
switch
(
key
)
{
case
JSGC_SLICE_TIME_BUDGET_MS
:
defaultTimeBudgetMS_
=
TuningDefaults
:
:
DefaultTimeBudgetMS
;
break
;
case
JSGC_INCREMENTAL_GC_ENABLED
:
setIncrementalGCEnabled
(
TuningDefaults
:
:
IncrementalGCEnabled
)
;
break
;
case
JSGC_PER_ZONE_GC_ENABLED
:
perZoneGCEnabled
=
TuningDefaults
:
:
PerZoneGCEnabled
;
break
;
case
JSGC_COMPACTING_ENABLED
:
compactingEnabled
=
TuningDefaults
:
:
CompactingEnabled
;
break
;
case
JSGC_PARALLEL_MARKING_ENABLED
:
parallelMarkingEnabled
=
TuningDefaults
:
:
ParallelMarkingEnabled
;
initOrDisableParallelMarking
(
)
;
break
;
case
JSGC_INCREMENTAL_WEAKMAP_ENABLED
:
for
(
auto
&
marker
:
markers
)
{
marker
-
>
incrementalWeakMapMarkingEnabled
=
TuningDefaults
:
:
IncrementalWeakMapMarkingEnabled
;
}
break
;
case
JSGC_MIN_EMPTY_CHUNK_COUNT
:
setMinEmptyChunkCount
(
TuningDefaults
:
:
MinEmptyChunkCount
lock
)
;
break
;
case
JSGC_MAX_EMPTY_CHUNK_COUNT
:
setMaxEmptyChunkCount
(
TuningDefaults
:
:
MaxEmptyChunkCount
lock
)
;
break
;
default
:
if
(
IsGCThreadParameter
(
key
)
)
{
resetThreadParameter
(
key
lock
)
;
return
;
}
tunables
.
resetParameter
(
key
)
;
updateAllGCStartThresholds
(
)
;
}
}
void
GCRuntime
:
:
resetThreadParameter
(
JSGCParamKey
key
AutoLockGC
&
lock
)
{
if
(
rt
-
>
parentRuntime
)
{
return
;
}
switch
(
key
)
{
case
JSGC_HELPER_THREAD_RATIO
:
helperThreadRatio
=
TuningDefaults
:
:
HelperThreadRatio
;
break
;
case
JSGC_MAX_HELPER_THREADS
:
maxHelperThreads
=
TuningDefaults
:
:
MaxHelperThreads
;
break
;
case
JSGC_MARKING_THREAD_COUNT
:
markingThreadCount
=
0
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
parameter
key
"
)
;
}
updateHelperThreadCount
(
)
;
initOrDisableParallelMarking
(
)
;
}
uint32_t
GCRuntime
:
:
getParameter
(
JSGCParamKey
key
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
AutoLockGC
lock
(
this
)
;
return
getParameter
(
key
lock
)
;
}
uint32_t
GCRuntime
:
:
getParameter
(
JSGCParamKey
key
const
AutoLockGC
&
lock
)
{
switch
(
key
)
{
case
JSGC_BYTES
:
return
uint32_t
(
heapSize
.
bytes
(
)
)
;
case
JSGC_NURSERY_BYTES
:
return
nursery
(
)
.
capacity
(
)
;
case
JSGC_NUMBER
:
return
uint32_t
(
number
)
;
case
JSGC_MAJOR_GC_NUMBER
:
return
uint32_t
(
majorGCNumber
)
;
case
JSGC_MINOR_GC_NUMBER
:
return
uint32_t
(
minorGCNumber
)
;
case
JSGC_INCREMENTAL_GC_ENABLED
:
return
incrementalGCEnabled
;
case
JSGC_PER_ZONE_GC_ENABLED
:
return
perZoneGCEnabled
;
case
JSGC_UNUSED_CHUNKS
:
return
uint32_t
(
emptyChunks
(
lock
)
.
count
(
)
)
;
case
JSGC_TOTAL_CHUNKS
:
return
uint32_t
(
fullChunks
(
lock
)
.
count
(
)
+
availableChunks
(
lock
)
.
count
(
)
+
emptyChunks
(
lock
)
.
count
(
)
)
;
case
JSGC_SLICE_TIME_BUDGET_MS
:
MOZ_RELEASE_ASSERT
(
defaultTimeBudgetMS_
>
=
0
)
;
MOZ_RELEASE_ASSERT
(
defaultTimeBudgetMS_
<
=
UINT32_MAX
)
;
return
uint32_t
(
defaultTimeBudgetMS_
)
;
case
JSGC_MIN_EMPTY_CHUNK_COUNT
:
return
minEmptyChunkCount
(
lock
)
;
case
JSGC_MAX_EMPTY_CHUNK_COUNT
:
return
maxEmptyChunkCount
(
lock
)
;
case
JSGC_COMPACTING_ENABLED
:
return
compactingEnabled
;
case
JSGC_PARALLEL_MARKING_ENABLED
:
return
parallelMarkingEnabled
;
case
JSGC_INCREMENTAL_WEAKMAP_ENABLED
:
return
marker
(
)
.
incrementalWeakMapMarkingEnabled
;
case
JSGC_CHUNK_BYTES
:
return
ChunkSize
;
case
JSGC_HELPER_THREAD_RATIO
:
MOZ_ASSERT
(
helperThreadRatio
>
0
.
0
)
;
return
uint32_t
(
helperThreadRatio
*
100
.
0
)
;
case
JSGC_MAX_HELPER_THREADS
:
MOZ_ASSERT
(
maxHelperThreads
<
=
UINT32_MAX
)
;
return
maxHelperThreads
;
case
JSGC_HELPER_THREAD_COUNT
:
return
helperThreadCount
;
case
JSGC_MARKING_THREAD_COUNT
:
return
markingThreadCount
;
case
JSGC_SYSTEM_PAGE_SIZE_KB
:
return
SystemPageSize
(
)
/
1024
;
default
:
return
tunables
.
getParameter
(
key
)
;
}
}
#
ifdef
JS_GC_ZEAL
void
GCRuntime
:
:
setMarkStackLimit
(
size_t
limit
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
maybeMarkStackLimit
=
limit
;
AutoUnlockGC
unlock
(
lock
)
;
AutoStopVerifyingBarriers
pauseVerification
(
rt
false
)
;
for
(
auto
&
marker
:
markers
)
{
marker
-
>
setMaxCapacity
(
limit
)
;
}
}
#
endif
void
GCRuntime
:
:
setIncrementalGCEnabled
(
bool
enabled
)
{
incrementalGCEnabled
=
enabled
;
}
void
GCRuntime
:
:
updateHelperThreadCount
(
)
{
if
(
!
CanUseExtraThreads
(
)
)
{
MOZ_ASSERT
(
helperThreadCount
=
=
1
)
;
return
;
}
static
constexpr
size_t
SpareThreadsDuringParallelMarking
=
2
;
if
(
rt
-
>
parentRuntime
)
{
helperThreadCount
=
rt
-
>
parentRuntime
-
>
gc
.
helperThreadCount
;
return
;
}
size_t
cpuCount
=
GetHelperThreadCPUCount
(
)
;
helperThreadCount
=
std
:
:
clamp
(
size_t
(
double
(
cpuCount
)
*
helperThreadRatio
.
ref
(
)
)
size_t
(
1
)
maxHelperThreads
.
ref
(
)
)
;
size_t
targetCount
=
std
:
:
max
(
helperThreadCount
.
ref
(
)
markingThreadCount
.
ref
(
)
+
SpareThreadsDuringParallelMarking
)
;
AutoLockHelperThreadState
lock
;
(
void
)
HelperThreadState
(
)
.
ensureThreadCount
(
targetCount
lock
)
;
size_t
availableThreadCount
=
GetHelperThreadCount
(
)
;
MOZ_ASSERT
(
availableThreadCount
!
=
0
)
;
targetCount
=
std
:
:
min
(
targetCount
availableThreadCount
)
;
helperThreadCount
=
std
:
:
min
(
helperThreadCount
.
ref
(
)
availableThreadCount
)
;
markingThreadCount
=
std
:
:
min
(
markingThreadCount
.
ref
(
)
availableThreadCount
-
SpareThreadsDuringParallelMarking
)
;
HelperThreadState
(
)
.
setGCParallelThreadCount
(
targetCount
lock
)
;
}
size_t
GCRuntime
:
:
markingWorkerCount
(
)
const
{
if
(
!
CanUseExtraThreads
(
)
|
|
!
parallelMarkingEnabled
)
{
return
1
;
}
if
(
markingThreadCount
)
{
return
markingThreadCount
;
}
return
2
;
}
#
ifdef
DEBUG
void
GCRuntime
:
:
assertNoMarkingWork
(
)
const
{
for
(
const
auto
&
marker
:
markers
)
{
MOZ_ASSERT
(
marker
-
>
isDrained
(
)
)
;
}
MOZ_ASSERT
(
!
hasDelayedMarking
(
)
)
;
}
#
endif
bool
GCRuntime
:
:
initOrDisableParallelMarking
(
)
{
MOZ_ASSERT
(
markers
.
length
(
)
!
=
0
)
;
if
(
!
updateMarkersVector
(
)
)
{
parallelMarkingEnabled
=
false
;
return
false
;
}
return
true
;
}
static
size_t
GetGCParallelThreadCount
(
)
{
AutoLockHelperThreadState
lock
;
return
HelperThreadState
(
)
.
getGCParallelThreadCount
(
lock
)
;
}
bool
GCRuntime
:
:
updateMarkersVector
(
)
{
MOZ_ASSERT
(
helperThreadCount
>
=
1
"
There
must
always
be
at
least
one
mark
task
"
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
assertNoMarkingWork
(
)
;
size_t
targetCount
=
std
:
:
min
(
markingWorkerCount
(
)
GetGCParallelThreadCount
(
)
)
;
if
(
markers
.
length
(
)
>
targetCount
)
{
return
markers
.
resize
(
targetCount
)
;
}
while
(
markers
.
length
(
)
<
targetCount
)
{
auto
marker
=
MakeUnique
<
GCMarker
>
(
rt
)
;
if
(
!
marker
)
{
return
false
;
}
#
ifdef
JS_GC_ZEAL
if
(
maybeMarkStackLimit
)
{
marker
-
>
setMaxCapacity
(
maybeMarkStackLimit
)
;
}
#
endif
if
(
!
marker
-
>
init
(
)
)
{
return
false
;
}
if
(
!
markers
.
emplaceBack
(
std
:
:
move
(
marker
)
)
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
F
>
static
bool
EraseCallback
(
CallbackVector
<
F
>
&
vector
F
callback
)
{
for
(
Callback
<
F
>
*
p
=
vector
.
begin
(
)
;
p
!
=
vector
.
end
(
)
;
p
+
+
)
{
if
(
p
-
>
op
=
=
callback
)
{
vector
.
erase
(
p
)
;
return
true
;
}
}
return
false
;
}
template
<
typename
F
>
static
bool
EraseCallback
(
CallbackVector
<
F
>
&
vector
F
callback
void
*
data
)
{
for
(
Callback
<
F
>
*
p
=
vector
.
begin
(
)
;
p
!
=
vector
.
end
(
)
;
p
+
+
)
{
if
(
p
-
>
op
=
=
callback
&
&
p
-
>
data
=
=
data
)
{
vector
.
erase
(
p
)
;
return
true
;
}
}
return
false
;
}
bool
GCRuntime
:
:
addBlackRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
{
AssertHeapIsIdle
(
)
;
return
blackRootTracers
.
ref
(
)
.
append
(
Callback
<
JSTraceDataOp
>
(
traceOp
data
)
)
;
}
void
GCRuntime
:
:
removeBlackRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
{
MOZ_ALWAYS_TRUE
(
EraseCallback
(
blackRootTracers
.
ref
(
)
traceOp
)
)
;
}
void
GCRuntime
:
:
setGrayRootsTracer
(
JSGrayRootsTracer
traceOp
void
*
data
)
{
AssertHeapIsIdle
(
)
;
grayRootTracer
.
ref
(
)
=
{
traceOp
data
}
;
}
void
GCRuntime
:
:
clearBlackAndGrayRootTracers
(
)
{
MOZ_ASSERT
(
rt
-
>
isBeingDestroyed
(
)
)
;
blackRootTracers
.
ref
(
)
.
clear
(
)
;
setGrayRootsTracer
(
nullptr
nullptr
)
;
}
void
GCRuntime
:
:
setGCCallback
(
JSGCCallback
callback
void
*
data
)
{
gcCallback
.
ref
(
)
=
{
callback
data
}
;
}
void
GCRuntime
:
:
callGCCallback
(
JSGCStatus
status
JS
:
:
GCReason
reason
)
const
{
const
auto
&
callback
=
gcCallback
.
ref
(
)
;
MOZ_ASSERT
(
callback
.
op
)
;
callback
.
op
(
rt
-
>
mainContextFromOwnThread
(
)
status
reason
callback
.
data
)
;
}
void
GCRuntime
:
:
setObjectsTenuredCallback
(
JSObjectsTenuredCallback
callback
void
*
data
)
{
tenuredCallback
.
ref
(
)
=
{
callback
data
}
;
}
void
GCRuntime
:
:
callObjectsTenuredCallback
(
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
const
auto
&
callback
=
tenuredCallback
.
ref
(
)
;
if
(
callback
.
op
)
{
callback
.
op
(
rt
-
>
mainContextFromOwnThread
(
)
callback
.
data
)
;
}
}
bool
GCRuntime
:
:
addFinalizeCallback
(
JSFinalizeCallback
callback
void
*
data
)
{
return
finalizeCallbacks
.
ref
(
)
.
append
(
Callback
<
JSFinalizeCallback
>
(
callback
data
)
)
;
}
void
GCRuntime
:
:
removeFinalizeCallback
(
JSFinalizeCallback
callback
)
{
MOZ_ALWAYS_TRUE
(
EraseCallback
(
finalizeCallbacks
.
ref
(
)
callback
)
)
;
}
void
GCRuntime
:
:
callFinalizeCallbacks
(
JS
:
:
GCContext
*
gcx
JSFinalizeStatus
status
)
const
{
for
(
const
auto
&
p
:
finalizeCallbacks
.
ref
(
)
)
{
p
.
op
(
gcx
status
p
.
data
)
;
}
}
void
GCRuntime
:
:
setHostCleanupFinalizationRegistryCallback
(
JSHostCleanupFinalizationRegistryCallback
callback
void
*
data
)
{
hostCleanupFinalizationRegistryCallback
.
ref
(
)
=
{
callback
data
}
;
}
void
GCRuntime
:
:
callHostCleanupFinalizationRegistryCallback
(
JSFunction
*
doCleanup
GlobalObject
*
incumbentGlobal
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
const
auto
&
callback
=
hostCleanupFinalizationRegistryCallback
.
ref
(
)
;
if
(
callback
.
op
)
{
callback
.
op
(
doCleanup
incumbentGlobal
callback
.
data
)
;
}
}
bool
GCRuntime
:
:
addWeakPointerZonesCallback
(
JSWeakPointerZonesCallback
callback
void
*
data
)
{
return
updateWeakPointerZonesCallbacks
.
ref
(
)
.
append
(
Callback
<
JSWeakPointerZonesCallback
>
(
callback
data
)
)
;
}
void
GCRuntime
:
:
removeWeakPointerZonesCallback
(
JSWeakPointerZonesCallback
callback
)
{
MOZ_ALWAYS_TRUE
(
EraseCallback
(
updateWeakPointerZonesCallbacks
.
ref
(
)
callback
)
)
;
}
void
GCRuntime
:
:
callWeakPointerZonesCallbacks
(
JSTracer
*
trc
)
const
{
for
(
auto
const
&
p
:
updateWeakPointerZonesCallbacks
.
ref
(
)
)
{
p
.
op
(
trc
p
.
data
)
;
}
}
bool
GCRuntime
:
:
addWeakPointerCompartmentCallback
(
JSWeakPointerCompartmentCallback
callback
void
*
data
)
{
return
updateWeakPointerCompartmentCallbacks
.
ref
(
)
.
append
(
Callback
<
JSWeakPointerCompartmentCallback
>
(
callback
data
)
)
;
}
void
GCRuntime
:
:
removeWeakPointerCompartmentCallback
(
JSWeakPointerCompartmentCallback
callback
)
{
MOZ_ALWAYS_TRUE
(
EraseCallback
(
updateWeakPointerCompartmentCallbacks
.
ref
(
)
callback
)
)
;
}
void
GCRuntime
:
:
callWeakPointerCompartmentCallbacks
(
JSTracer
*
trc
JS
:
:
Compartment
*
comp
)
const
{
for
(
auto
const
&
p
:
updateWeakPointerCompartmentCallbacks
.
ref
(
)
)
{
p
.
op
(
trc
comp
p
.
data
)
;
}
}
JS
:
:
GCSliceCallback
GCRuntime
:
:
setSliceCallback
(
JS
:
:
GCSliceCallback
callback
)
{
return
stats
(
)
.
setSliceCallback
(
callback
)
;
}
bool
GCRuntime
:
:
addNurseryCollectionCallback
(
JS
:
:
GCNurseryCollectionCallback
callback
void
*
data
)
{
return
nurseryCollectionCallbacks
.
ref
(
)
.
append
(
Callback
<
JS
:
:
GCNurseryCollectionCallback
>
(
callback
data
)
)
;
}
void
GCRuntime
:
:
removeNurseryCollectionCallback
(
JS
:
:
GCNurseryCollectionCallback
callback
void
*
data
)
{
MOZ_ALWAYS_TRUE
(
EraseCallback
(
nurseryCollectionCallbacks
.
ref
(
)
callback
data
)
)
;
}
void
GCRuntime
:
:
callNurseryCollectionCallbacks
(
JS
:
:
GCNurseryProgress
progress
JS
:
:
GCReason
reason
)
{
for
(
auto
const
&
p
:
nurseryCollectionCallbacks
.
ref
(
)
)
{
p
.
op
(
rt
-
>
mainContextFromOwnThread
(
)
progress
reason
p
.
data
)
;
}
}
JS
:
:
DoCycleCollectionCallback
GCRuntime
:
:
setDoCycleCollectionCallback
(
JS
:
:
DoCycleCollectionCallback
callback
)
{
const
auto
prior
=
gcDoCycleCollectionCallback
.
ref
(
)
;
gcDoCycleCollectionCallback
.
ref
(
)
=
{
callback
nullptr
}
;
return
prior
.
op
;
}
void
GCRuntime
:
:
callDoCycleCollectionCallback
(
JSContext
*
cx
)
{
const
auto
&
callback
=
gcDoCycleCollectionCallback
.
ref
(
)
;
if
(
callback
.
op
)
{
callback
.
op
(
cx
)
;
}
}
bool
GCRuntime
:
:
addRoot
(
Value
*
vp
const
char
*
name
)
{
MOZ_ASSERT
(
vp
)
;
Value
value
=
*
vp
;
if
(
value
.
isGCThing
(
)
)
{
ValuePreWriteBarrier
(
value
)
;
}
return
rootsHash
.
ref
(
)
.
put
(
vp
name
)
;
}
void
GCRuntime
:
:
removeRoot
(
Value
*
vp
)
{
rootsHash
.
ref
(
)
.
remove
(
vp
)
;
notifyRootsRemoved
(
)
;
}
bool
js
:
:
gc
:
:
IsCurrentlyAnimating
(
const
TimeStamp
&
lastAnimationTime
const
TimeStamp
&
currentTime
)
{
static
const
auto
oneSecond
=
TimeDuration
:
:
FromSeconds
(
1
)
;
return
!
lastAnimationTime
.
IsNull
(
)
&
&
currentTime
<
(
lastAnimationTime
+
oneSecond
)
;
}
static
bool
DiscardedCodeRecently
(
Zone
*
zone
const
TimeStamp
&
currentTime
)
{
static
const
auto
thirtySeconds
=
TimeDuration
:
:
FromSeconds
(
30
)
;
return
!
zone
-
>
lastDiscardedCodeTime
(
)
.
IsNull
(
)
&
&
currentTime
<
(
zone
-
>
lastDiscardedCodeTime
(
)
+
thirtySeconds
)
;
}
bool
GCRuntime
:
:
shouldCompact
(
)
{
if
(
!
isShrinkingGC
(
)
|
|
!
isCompactingGCEnabled
(
)
)
{
return
false
;
}
if
(
initialReason
=
=
JS
:
:
GCReason
:
:
USER_INACTIVE
|
|
initialReason
=
=
JS
:
:
GCReason
:
:
MEM_PRESSURE
)
{
return
true
;
}
return
!
isIncremental
|
|
!
IsCurrentlyAnimating
(
rt
-
>
lastAnimationTime
TimeStamp
:
:
Now
(
)
)
;
}
bool
GCRuntime
:
:
isCompactingGCEnabled
(
)
const
{
return
compactingEnabled
&
&
rt
-
>
mainContextFromOwnThread
(
)
-
>
compactingDisabledCount
=
=
0
;
}
JS_PUBLIC_API
void
JS
:
:
SetCreateGCSliceBudgetCallback
(
JSContext
*
cx
JS
:
:
CreateSliceBudgetCallback
cb
)
{
cx
-
>
runtime
(
)
-
>
gc
.
createBudgetCallback
=
cb
;
}
void
TimeBudget
:
:
setDeadlineFromNow
(
)
{
deadline
=
TimeStamp
:
:
Now
(
)
+
budget
;
}
SliceBudget
:
:
SliceBudget
(
TimeBudget
time
InterruptRequestFlag
*
interrupt
)
:
counter
(
StepsPerExpensiveCheck
)
interruptRequested
(
interrupt
)
budget
(
TimeBudget
(
time
)
)
{
budget
.
as
<
TimeBudget
>
(
)
.
setDeadlineFromNow
(
)
;
}
SliceBudget
:
:
SliceBudget
(
WorkBudget
work
)
:
counter
(
work
.
budget
)
interruptRequested
(
nullptr
)
budget
(
work
)
{
}
int
SliceBudget
:
:
describe
(
char
*
buffer
size_t
maxlen
)
const
{
if
(
isUnlimited
(
)
)
{
return
snprintf
(
buffer
maxlen
"
unlimited
"
)
;
}
if
(
isWorkBudget
(
)
)
{
return
snprintf
(
buffer
maxlen
"
work
(
%
"
PRId64
"
)
"
workBudget
(
)
)
;
}
const
char
*
interruptStr
=
"
"
;
if
(
interruptRequested
)
{
interruptStr
=
interrupted
?
"
INTERRUPTED
"
:
"
interruptible
"
;
}
const
char
*
extra
=
"
"
;
if
(
idle
)
{
extra
=
extended
?
"
(
started
idle
but
extended
)
"
:
"
(
idle
)
"
;
}
return
snprintf
(
buffer
maxlen
"
%
s
%
"
PRId64
"
ms
%
s
"
interruptStr
timeBudget
(
)
extra
)
;
}
bool
SliceBudget
:
:
checkOverBudget
(
)
{
MOZ_ASSERT
(
counter
<
=
0
)
;
MOZ_ASSERT
(
!
isUnlimited
(
)
)
;
if
(
isWorkBudget
(
)
)
{
return
true
;
}
if
(
interruptRequested
&
&
*
interruptRequested
)
{
interrupted
=
true
;
}
if
(
interrupted
)
{
return
true
;
}
if
(
TimeStamp
:
:
Now
(
)
>
=
budget
.
as
<
TimeBudget
>
(
)
.
deadline
)
{
return
true
;
}
counter
=
StepsPerExpensiveCheck
;
return
false
;
}
void
GCRuntime
:
:
requestMajorGC
(
JS
:
:
GCReason
reason
)
{
MOZ_ASSERT_IF
(
reason
!
=
JS
:
:
GCReason
:
:
BG_TASK_FINISHED
!
CurrentThreadIsPerformingGC
(
)
)
;
if
(
majorGCRequested
(
)
)
{
return
;
}
majorGCTriggerReason
=
reason
;
rt
-
>
mainContextFromAnyThread
(
)
-
>
requestInterrupt
(
InterruptReason
:
:
MajorGC
)
;
}
bool
GCRuntime
:
:
triggerGC
(
JS
:
:
GCReason
reason
)
{
if
(
!
CurrentThreadCanAccessRuntime
(
rt
)
)
{
return
false
;
}
if
(
JS
:
:
RuntimeHeapIsCollecting
(
)
)
{
return
false
;
}
JS
:
:
PrepareForFullGC
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
requestMajorGC
(
reason
)
;
return
true
;
}
void
GCRuntime
:
:
maybeTriggerGCAfterAlloc
(
Zone
*
zone
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
TriggerResult
trigger
=
checkHeapThreshold
(
zone
zone
-
>
gcHeapSize
zone
-
>
gcHeapThreshold
)
;
if
(
trigger
.
shouldTrigger
)
{
triggerZoneGC
(
zone
JS
:
:
GCReason
:
:
ALLOC_TRIGGER
trigger
.
usedBytes
trigger
.
thresholdBytes
)
;
}
}
void
js
:
:
gc
:
:
MaybeMallocTriggerZoneGC
(
JSRuntime
*
rt
ZoneAllocator
*
zoneAlloc
const
HeapSize
&
heap
const
HeapThreshold
&
threshold
JS
:
:
GCReason
reason
)
{
rt
-
>
gc
.
maybeTriggerGCAfterMalloc
(
Zone
:
:
from
(
zoneAlloc
)
heap
threshold
reason
)
;
}
void
GCRuntime
:
:
maybeTriggerGCAfterMalloc
(
Zone
*
zone
)
{
if
(
maybeTriggerGCAfterMalloc
(
zone
zone
-
>
mallocHeapSize
zone
-
>
mallocHeapThreshold
JS
:
:
GCReason
:
:
TOO_MUCH_MALLOC
)
)
{
return
;
}
maybeTriggerGCAfterMalloc
(
zone
zone
-
>
jitHeapSize
zone
-
>
jitHeapThreshold
JS
:
:
GCReason
:
:
TOO_MUCH_JIT_CODE
)
;
}
bool
GCRuntime
:
:
maybeTriggerGCAfterMalloc
(
Zone
*
zone
const
HeapSize
&
heap
const
HeapThreshold
&
threshold
JS
:
:
GCReason
reason
)
{
if
(
heapState
(
)
!
=
JS
:
:
HeapState
:
:
Idle
)
{
return
false
;
}
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
TriggerResult
trigger
=
checkHeapThreshold
(
zone
heap
threshold
)
;
if
(
!
trigger
.
shouldTrigger
)
{
return
false
;
}
triggerZoneGC
(
zone
reason
trigger
.
usedBytes
trigger
.
thresholdBytes
)
;
return
true
;
}
TriggerResult
GCRuntime
:
:
checkHeapThreshold
(
Zone
*
zone
const
HeapSize
&
heapSize
const
HeapThreshold
&
heapThreshold
)
{
MOZ_ASSERT_IF
(
heapThreshold
.
hasSliceThreshold
(
)
zone
-
>
wasGCStarted
(
)
)
;
size_t
usedBytes
=
heapSize
.
bytes
(
)
;
size_t
thresholdBytes
=
heapThreshold
.
hasSliceThreshold
(
)
?
heapThreshold
.
sliceBytes
(
)
:
heapThreshold
.
startBytes
(
)
;
MOZ_ASSERT
(
thresholdBytes
<
=
heapThreshold
.
incrementalLimitBytes
(
)
)
;
return
TriggerResult
{
usedBytes
>
=
thresholdBytes
usedBytes
thresholdBytes
}
;
}
bool
GCRuntime
:
:
triggerZoneGC
(
Zone
*
zone
JS
:
:
GCReason
reason
size_t
used
size_t
threshold
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
if
(
JS
:
:
RuntimeHeapIsBusy
(
)
)
{
return
false
;
}
#
ifdef
JS_GC_ZEAL
if
(
hasZealMode
(
ZealMode
:
:
Alloc
)
)
{
MOZ_RELEASE_ASSERT
(
triggerGC
(
reason
)
)
;
return
true
;
}
#
endif
if
(
zone
-
>
isAtomsZone
(
)
)
{
stats
(
)
.
recordTrigger
(
used
threshold
)
;
MOZ_RELEASE_ASSERT
(
triggerGC
(
reason
)
)
;
return
true
;
}
stats
(
)
.
recordTrigger
(
used
threshold
)
;
zone
-
>
scheduleGC
(
)
;
requestMajorGC
(
reason
)
;
return
true
;
}
void
GCRuntime
:
:
maybeGC
(
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
#
ifdef
JS_GC_ZEAL
if
(
hasZealMode
(
ZealMode
:
:
Alloc
)
|
|
hasZealMode
(
ZealMode
:
:
RootsChange
)
)
{
JS
:
:
PrepareForFullGC
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
gc
(
JS
:
:
GCOptions
:
:
Normal
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
return
;
}
#
endif
(
void
)
gcIfRequestedImpl
(
true
)
;
}
JS
:
:
GCReason
GCRuntime
:
:
wantMajorGC
(
bool
eagerOk
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
if
(
majorGCRequested
(
)
)
{
return
majorGCTriggerReason
;
}
if
(
isIncrementalGCInProgress
(
)
|
|
!
eagerOk
)
{
return
JS
:
:
GCReason
:
:
NO_REASON
;
}
JS
:
:
GCReason
reason
=
JS
:
:
GCReason
:
:
NO_REASON
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
checkEagerAllocTrigger
(
zone
-
>
gcHeapSize
zone
-
>
gcHeapThreshold
)
|
|
checkEagerAllocTrigger
(
zone
-
>
mallocHeapSize
zone
-
>
mallocHeapThreshold
)
)
{
zone
-
>
scheduleGC
(
)
;
reason
=
JS
:
:
GCReason
:
:
EAGER_ALLOC_TRIGGER
;
}
}
return
reason
;
}
bool
GCRuntime
:
:
checkEagerAllocTrigger
(
const
HeapSize
&
size
const
HeapThreshold
&
threshold
)
{
size_t
thresholdBytes
=
threshold
.
eagerAllocTrigger
(
schedulingState
.
inHighFrequencyGCMode
(
)
)
;
size_t
usedBytes
=
size
.
bytes
(
)
;
if
(
usedBytes
<
=
1024
*
1024
|
|
usedBytes
<
thresholdBytes
)
{
return
false
;
}
stats
(
)
.
recordTrigger
(
usedBytes
thresholdBytes
)
;
return
true
;
}
bool
GCRuntime
:
:
shouldDecommit
(
)
const
{
if
(
cleanUpEverything
)
{
return
true
;
}
return
!
schedulingState
.
inHighFrequencyGCMode
(
)
;
}
void
GCRuntime
:
:
startDecommit
(
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
DECOMMIT
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
MOZ_ASSERT
(
decommitTask
.
isIdle
(
)
)
;
{
AutoLockGC
lock
(
this
)
;
MOZ_ASSERT
(
fullChunks
(
lock
)
.
verify
(
)
)
;
MOZ_ASSERT
(
availableChunks
(
lock
)
.
verify
(
)
)
;
MOZ_ASSERT
(
emptyChunks
(
lock
)
.
verify
(
)
)
;
for
(
ChunkPool
:
:
Iter
chunk
(
emptyChunks
(
lock
)
)
;
!
chunk
.
done
(
)
;
chunk
.
next
(
)
)
{
MOZ_ASSERT
(
chunk
-
>
unused
(
)
)
;
}
}
#
endif
if
(
!
shouldDecommit
(
)
)
{
return
;
}
{
AutoLockGC
lock
(
this
)
;
if
(
availableChunks
(
lock
)
.
empty
(
)
&
&
!
tooManyEmptyChunks
(
lock
)
&
&
emptyChunks
(
lock
)
.
empty
(
)
)
{
return
;
}
}
#
ifdef
DEBUG
{
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
!
requestSliceAfterBackgroundTask
)
;
}
#
endif
if
(
useBackgroundThreads
)
{
decommitTask
.
start
(
)
;
return
;
}
decommitTask
.
runFromMainThread
(
)
;
}
BackgroundDecommitTask
:
:
BackgroundDecommitTask
(
GCRuntime
*
gc
)
:
GCParallelTask
(
gc
gcstats
:
:
PhaseKind
:
:
DECOMMIT
)
{
}
void
js
:
:
gc
:
:
BackgroundDecommitTask
:
:
run
(
AutoLockHelperThreadState
&
lock
)
{
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
ChunkPool
emptyChunksToFree
;
{
AutoLockGC
gcLock
(
gc
)
;
emptyChunksToFree
=
gc
-
>
expireEmptyChunkPool
(
gcLock
)
;
}
FreeChunkPool
(
emptyChunksToFree
)
;
{
AutoLockGC
gcLock
(
gc
)
;
gc
-
>
availableChunks
(
gcLock
)
.
sort
(
)
;
if
(
DecommitEnabled
(
)
)
{
gc
-
>
decommitEmptyChunks
(
cancel_
gcLock
)
;
gc
-
>
decommitFreeArenas
(
cancel_
gcLock
)
;
}
}
}
gc
-
>
maybeRequestGCAfterBackgroundTask
(
lock
)
;
}
static
inline
bool
CanDecommitWholeChunk
(
TenuredChunk
*
chunk
)
{
return
chunk
-
>
unused
(
)
&
&
chunk
-
>
info
.
numArenasFreeCommitted
!
=
0
;
}
void
GCRuntime
:
:
decommitEmptyChunks
(
const
bool
&
cancel
AutoLockGC
&
lock
)
{
Vector
<
TenuredChunk
*
0
SystemAllocPolicy
>
chunksToDecommit
;
for
(
ChunkPool
:
:
Iter
chunk
(
emptyChunks
(
lock
)
)
;
!
chunk
.
done
(
)
;
chunk
.
next
(
)
)
{
if
(
CanDecommitWholeChunk
(
chunk
)
&
&
!
chunksToDecommit
.
append
(
chunk
)
)
{
onOutOfMallocMemory
(
lock
)
;
return
;
}
}
for
(
TenuredChunk
*
chunk
:
chunksToDecommit
)
{
if
(
cancel
)
{
break
;
}
if
(
!
CanDecommitWholeChunk
(
chunk
)
)
{
continue
;
}
emptyChunks
(
lock
)
.
remove
(
chunk
)
;
{
AutoUnlockGC
unlock
(
lock
)
;
chunk
-
>
decommitAllArenas
(
)
;
MOZ_ASSERT
(
chunk
-
>
info
.
numArenasFreeCommitted
=
=
0
)
;
}
emptyChunks
(
lock
)
.
push
(
chunk
)
;
}
}
void
GCRuntime
:
:
decommitFreeArenas
(
const
bool
&
cancel
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
DecommitEnabled
(
)
)
;
Vector
<
TenuredChunk
*
0
SystemAllocPolicy
>
chunksToDecommit
;
for
(
ChunkPool
:
:
Iter
chunk
(
availableChunks
(
lock
)
)
;
!
chunk
.
done
(
)
;
chunk
.
next
(
)
)
{
if
(
chunk
-
>
info
.
numArenasFreeCommitted
!
=
0
&
&
!
chunksToDecommit
.
append
(
chunk
)
)
{
onOutOfMallocMemory
(
lock
)
;
return
;
}
}
for
(
TenuredChunk
*
chunk
:
chunksToDecommit
)
{
chunk
-
>
decommitFreeArenas
(
this
cancel
lock
)
;
}
}
void
GCRuntime
:
:
decommitFreeArenasWithoutUnlocking
(
const
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
DecommitEnabled
(
)
)
;
for
(
ChunkPool
:
:
Iter
chunk
(
availableChunks
(
lock
)
)
;
!
chunk
.
done
(
)
;
chunk
.
next
(
)
)
{
chunk
-
>
decommitFreeArenasWithoutUnlocking
(
lock
)
;
}
MOZ_ASSERT
(
availableChunks
(
lock
)
.
verify
(
)
)
;
}
void
GCRuntime
:
:
maybeRequestGCAfterBackgroundTask
(
const
AutoLockHelperThreadState
&
lock
)
{
if
(
requestSliceAfterBackgroundTask
)
{
requestSliceAfterBackgroundTask
=
false
;
requestMajorGC
(
JS
:
:
GCReason
:
:
BG_TASK_FINISHED
)
;
}
}
void
GCRuntime
:
:
cancelRequestedGCAfterBackgroundTask
(
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
#
ifdef
DEBUG
{
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
!
requestSliceAfterBackgroundTask
)
;
}
#
endif
majorGCTriggerReason
.
compareExchange
(
JS
:
:
GCReason
:
:
BG_TASK_FINISHED
JS
:
:
GCReason
:
:
NO_REASON
)
;
}
bool
GCRuntime
:
:
isWaitingOnBackgroundTask
(
)
const
{
AutoLockHelperThreadState
lock
;
return
requestSliceAfterBackgroundTask
;
}
void
GCRuntime
:
:
queueUnusedLifoBlocksForFree
(
LifoAlloc
*
lifo
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
AutoLockHelperThreadState
lock
;
lifoBlocksToFree
.
ref
(
)
.
transferUnusedFrom
(
lifo
)
;
}
void
GCRuntime
:
:
queueAllLifoBlocksForFreeAfterMinorGC
(
LifoAlloc
*
lifo
)
{
lifoBlocksToFreeAfterMinorGC
.
ref
(
)
.
transferFrom
(
lifo
)
;
}
void
GCRuntime
:
:
queueBuffersForFreeAfterMinorGC
(
Nursery
:
:
BufferSet
&
buffers
)
{
AutoLockHelperThreadState
lock
;
if
(
!
buffersToFreeAfterMinorGC
.
ref
(
)
.
empty
(
)
)
{
MOZ_ASSERT
(
!
freeTask
.
isIdle
(
lock
)
)
;
freeTask
.
joinWithLockHeld
(
lock
)
;
}
MOZ_ASSERT
(
buffersToFreeAfterMinorGC
.
ref
(
)
.
empty
(
)
)
;
std
:
:
swap
(
buffersToFreeAfterMinorGC
.
ref
(
)
buffers
)
;
}
void
Realm
:
:
destroy
(
JS
:
:
GCContext
*
gcx
)
{
JSRuntime
*
rt
=
gcx
-
>
runtime
(
)
;
if
(
auto
callback
=
rt
-
>
destroyRealmCallback
)
{
callback
(
gcx
this
)
;
}
if
(
principals
(
)
)
{
JS_DropPrincipals
(
rt
-
>
mainContextFromOwnThread
(
)
principals
(
)
)
;
}
gcx
-
>
deleteUntracked
(
this
)
;
}
void
Compartment
:
:
destroy
(
JS
:
:
GCContext
*
gcx
)
{
JSRuntime
*
rt
=
gcx
-
>
runtime
(
)
;
if
(
auto
callback
=
rt
-
>
destroyCompartmentCallback
)
{
callback
(
gcx
this
)
;
}
gcx
-
>
deleteUntracked
(
this
)
;
rt
-
>
gc
.
stats
(
)
.
sweptCompartment
(
)
;
}
void
Zone
:
:
destroy
(
JS
:
:
GCContext
*
gcx
)
{
MOZ_ASSERT
(
compartments
(
)
.
empty
(
)
)
;
JSRuntime
*
rt
=
gcx
-
>
runtime
(
)
;
if
(
auto
callback
=
rt
-
>
destroyZoneCallback
)
{
callback
(
gcx
this
)
;
}
gcx
-
>
deleteUntracked
(
this
)
;
gcx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
sweptZone
(
)
;
}
void
Zone
:
:
sweepCompartments
(
JS
:
:
GCContext
*
gcx
bool
keepAtleastOne
bool
destroyingRuntime
)
{
MOZ_ASSERT_IF
(
!
isAtomsZone
(
)
!
compartments
(
)
.
empty
(
)
)
;
MOZ_ASSERT_IF
(
destroyingRuntime
!
keepAtleastOne
)
;
Compartment
*
*
read
=
compartments
(
)
.
begin
(
)
;
Compartment
*
*
end
=
compartments
(
)
.
end
(
)
;
Compartment
*
*
write
=
read
;
while
(
read
<
end
)
{
Compartment
*
comp
=
*
read
+
+
;
bool
keepAtleastOneRealm
=
read
=
=
end
&
&
keepAtleastOne
;
comp
-
>
sweepRealms
(
gcx
keepAtleastOneRealm
destroyingRuntime
)
;
if
(
!
comp
-
>
realms
(
)
.
empty
(
)
)
{
*
write
+
+
=
comp
;
keepAtleastOne
=
false
;
}
else
{
comp
-
>
destroy
(
gcx
)
;
}
}
compartments
(
)
.
shrinkTo
(
write
-
compartments
(
)
.
begin
(
)
)
;
MOZ_ASSERT_IF
(
keepAtleastOne
!
compartments
(
)
.
empty
(
)
)
;
MOZ_ASSERT_IF
(
destroyingRuntime
compartments
(
)
.
empty
(
)
)
;
}
void
Compartment
:
:
sweepRealms
(
JS
:
:
GCContext
*
gcx
bool
keepAtleastOne
bool
destroyingRuntime
)
{
MOZ_ASSERT
(
!
realms
(
)
.
empty
(
)
)
;
MOZ_ASSERT_IF
(
destroyingRuntime
!
keepAtleastOne
)
;
Realm
*
*
read
=
realms
(
)
.
begin
(
)
;
Realm
*
*
end
=
realms
(
)
.
end
(
)
;
Realm
*
*
write
=
read
;
while
(
read
<
end
)
{
Realm
*
realm
=
*
read
+
+
;
bool
dontDelete
=
read
=
=
end
&
&
keepAtleastOne
;
if
(
(
realm
-
>
marked
(
)
|
|
dontDelete
)
&
&
!
destroyingRuntime
)
{
*
write
+
+
=
realm
;
keepAtleastOne
=
false
;
}
else
{
realm
-
>
destroy
(
gcx
)
;
}
}
realms
(
)
.
shrinkTo
(
write
-
realms
(
)
.
begin
(
)
)
;
MOZ_ASSERT_IF
(
keepAtleastOne
!
realms
(
)
.
empty
(
)
)
;
MOZ_ASSERT_IF
(
destroyingRuntime
realms
(
)
.
empty
(
)
)
;
}
void
GCRuntime
:
:
sweepZones
(
JS
:
:
GCContext
*
gcx
bool
destroyingRuntime
)
{
MOZ_ASSERT_IF
(
destroyingRuntime
numActiveZoneIters
=
=
0
)
;
if
(
numActiveZoneIters
)
{
return
;
}
assertBackgroundSweepingFinished
(
)
;
MOZ_ASSERT
(
zones
(
)
[
0
]
-
>
isAtomsZone
(
)
)
;
Zone
*
*
read
=
zones
(
)
.
begin
(
)
+
1
;
Zone
*
*
end
=
zones
(
)
.
end
(
)
;
Zone
*
*
write
=
read
;
while
(
read
<
end
)
{
Zone
*
zone
=
*
read
+
+
;
if
(
zone
-
>
wasGCStarted
(
)
)
{
MOZ_ASSERT
(
!
zone
-
>
isQueuedForBackgroundSweep
(
)
)
;
AutoSetThreadIsSweeping
threadIsSweeping
(
zone
)
;
const
bool
zoneIsDead
=
zone
-
>
arenas
.
arenaListsAreEmpty
(
)
&
&
!
zone
-
>
hasMarkedRealms
(
)
;
MOZ_ASSERT_IF
(
destroyingRuntime
zoneIsDead
)
;
if
(
zoneIsDead
)
{
zone
-
>
arenas
.
checkEmptyFreeLists
(
)
;
zone
-
>
sweepCompartments
(
gcx
false
destroyingRuntime
)
;
MOZ_ASSERT
(
zone
-
>
compartments
(
)
.
empty
(
)
)
;
zone
-
>
destroy
(
gcx
)
;
continue
;
}
zone
-
>
sweepCompartments
(
gcx
true
destroyingRuntime
)
;
}
*
write
+
+
=
zone
;
}
zones
(
)
.
shrinkTo
(
write
-
zones
(
)
.
begin
(
)
)
;
}
void
ArenaLists
:
:
checkEmptyArenaList
(
AllocKind
kind
)
{
MOZ_ASSERT
(
arenaList
(
kind
)
.
isEmpty
(
)
)
;
}
void
GCRuntime
:
:
purgeRuntimeForMinorGC
(
)
{
for
(
ZonesIter
zone
(
this
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
externalStringCache
(
)
.
purge
(
)
;
zone
-
>
functionToStringCache
(
)
.
purge
(
)
;
}
}
void
GCRuntime
:
:
purgeRuntime
(
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
PURGE
)
;
for
(
GCRealmsIter
realm
(
rt
)
;
!
realm
.
done
(
)
;
realm
.
next
(
)
)
{
realm
-
>
purge
(
)
;
}
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
purgeAtomCache
(
)
;
zone
-
>
externalStringCache
(
)
.
purge
(
)
;
zone
-
>
functionToStringCache
(
)
.
purge
(
)
;
zone
-
>
boundPrefixCache
(
)
.
clearAndCompact
(
)
;
zone
-
>
shapeZone
(
)
.
purgeShapeCaches
(
rt
-
>
gcContext
(
)
)
;
}
JSContext
*
cx
=
rt
-
>
mainContextFromOwnThread
(
)
;
queueUnusedLifoBlocksForFree
(
&
cx
-
>
tempLifoAlloc
(
)
)
;
cx
-
>
interpreterStack
(
)
.
purge
(
rt
)
;
cx
-
>
frontendCollectionPool
(
)
.
purge
(
)
;
rt
-
>
caches
(
)
.
purge
(
)
;
if
(
rt
-
>
isMainRuntime
(
)
)
{
SharedImmutableStringsCache
:
:
getSingleton
(
)
.
purge
(
)
;
}
MOZ_ASSERT
(
marker
(
)
.
unmarkGrayStack
.
empty
(
)
)
;
marker
(
)
.
unmarkGrayStack
.
clearAndFree
(
)
;
}
bool
GCRuntime
:
:
shouldPreserveJITCode
(
Realm
*
realm
const
TimeStamp
&
currentTime
JS
:
:
GCReason
reason
bool
canAllocateMoreCode
bool
isActiveCompartment
)
{
if
(
cleanUpEverything
)
{
return
false
;
}
if
(
!
canAllocateMoreCode
)
{
return
false
;
}
if
(
isActiveCompartment
)
{
return
true
;
}
if
(
alwaysPreserveCode
)
{
return
true
;
}
if
(
realm
-
>
preserveJitCode
(
)
)
{
return
true
;
}
if
(
IsCurrentlyAnimating
(
realm
-
>
lastAnimationTime
currentTime
)
&
&
DiscardedCodeRecently
(
realm
-
>
zone
(
)
currentTime
)
)
{
return
true
;
}
if
(
reason
=
=
JS
:
:
GCReason
:
:
DEBUG_GC
)
{
return
true
;
}
return
false
;
}
#
ifdef
DEBUG
class
CompartmentCheckTracer
final
:
public
JS
:
:
CallbackTracer
{
void
onChild
(
JS
:
:
GCCellPtr
thing
const
char
*
name
)
override
;
bool
edgeIsInCrossCompartmentMap
(
JS
:
:
GCCellPtr
dst
)
;
public
:
explicit
CompartmentCheckTracer
(
JSRuntime
*
rt
)
:
JS
:
:
CallbackTracer
(
rt
JS
:
:
TracerKind
:
:
CompartmentCheck
JS
:
:
WeakEdgeTraceAction
:
:
Skip
)
{
}
Cell
*
src
=
nullptr
;
JS
:
:
TraceKind
srcKind
=
JS
:
:
TraceKind
:
:
Null
;
Zone
*
zone
=
nullptr
;
Compartment
*
compartment
=
nullptr
;
}
;
static
bool
InCrossCompartmentMap
(
JSRuntime
*
rt
JSObject
*
src
JS
:
:
GCCellPtr
dst
)
{
Compartment
*
srccomp
=
src
-
>
compartment
(
)
;
if
(
dst
.
is
<
JSObject
>
(
)
)
{
if
(
ObjectWrapperMap
:
:
Ptr
p
=
srccomp
-
>
lookupWrapper
(
&
dst
.
as
<
JSObject
>
(
)
)
)
{
if
(
*
p
-
>
value
(
)
.
unsafeGet
(
)
=
=
src
)
{
return
true
;
}
}
}
if
(
DebugAPI
:
:
edgeIsInDebuggerWeakmap
(
rt
src
dst
)
)
{
return
true
;
}
return
false
;
}
void
CompartmentCheckTracer
:
:
onChild
(
JS
:
:
GCCellPtr
thing
const
char
*
name
)
{
Compartment
*
comp
=
MapGCThingTyped
(
thing
[
]
(
auto
t
)
{
return
t
-
>
maybeCompartment
(
)
;
}
)
;
if
(
comp
&
&
compartment
)
{
MOZ_ASSERT
(
comp
=
=
compartment
|
|
edgeIsInCrossCompartmentMap
(
thing
)
)
;
}
else
{
TenuredCell
*
tenured
=
&
thing
.
asCell
(
)
-
>
asTenured
(
)
;
Zone
*
thingZone
=
tenured
-
>
zoneFromAnyThread
(
)
;
MOZ_ASSERT
(
thingZone
=
=
zone
|
|
thingZone
-
>
isAtomsZone
(
)
)
;
}
}
bool
CompartmentCheckTracer
:
:
edgeIsInCrossCompartmentMap
(
JS
:
:
GCCellPtr
dst
)
{
return
srcKind
=
=
JS
:
:
TraceKind
:
:
Object
&
&
InCrossCompartmentMap
(
runtime
(
)
static_cast
<
JSObject
*
>
(
src
)
dst
)
;
}
static
bool
IsPartiallyInitializedObject
(
Cell
*
cell
)
{
if
(
!
cell
-
>
is
<
JSObject
>
(
)
)
{
return
false
;
}
JSObject
*
obj
=
cell
-
>
as
<
JSObject
>
(
)
;
if
(
!
obj
-
>
is
<
NativeObject
>
(
)
)
{
return
false
;
}
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
size_t
nDynamicSlots
=
NativeObject
:
:
calculateDynamicSlots
(
nobj
-
>
numFixedSlots
(
)
nobj
-
>
slotSpan
(
)
nobj
-
>
getClass
(
)
)
;
return
nDynamicSlots
!
=
0
&
&
!
nobj
-
>
hasDynamicSlots
(
)
;
}
void
GCRuntime
:
:
checkForCompartmentMismatches
(
)
{
JSContext
*
cx
=
rt
-
>
mainContextFromOwnThread
(
)
;
if
(
cx
-
>
disableStrictProxyCheckingCount
)
{
return
;
}
CompartmentCheckTracer
trc
(
rt
)
;
AutoAssertEmptyNursery
empty
(
cx
)
;
for
(
ZonesIter
zone
(
this
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
trc
.
zone
=
zone
;
for
(
auto
thingKind
:
AllAllocKinds
(
)
)
{
for
(
auto
i
=
zone
-
>
cellIterUnsafe
<
TenuredCell
>
(
thingKind
empty
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
if
(
IsPartiallyInitializedObject
(
i
.
getCell
(
)
)
)
{
continue
;
}
trc
.
src
=
i
.
getCell
(
)
;
trc
.
srcKind
=
MapAllocToTraceKind
(
thingKind
)
;
trc
.
compartment
=
MapGCThingTyped
(
trc
.
src
trc
.
srcKind
[
]
(
auto
t
)
{
return
t
-
>
maybeCompartment
(
)
;
}
)
;
JS
:
:
TraceChildren
(
&
trc
JS
:
:
GCCellPtr
(
trc
.
src
trc
.
srcKind
)
)
;
}
}
}
}
#
endif
static
bool
ShouldCleanUpEverything
(
JS
:
:
GCOptions
options
)
{
return
options
=
=
JS
:
:
GCOptions
:
:
Shutdown
|
|
options
=
=
JS
:
:
GCOptions
:
:
Shrink
;
}
static
bool
ShouldUseBackgroundThreads
(
bool
isIncremental
JS
:
:
GCReason
reason
)
{
bool
shouldUse
=
isIncremental
&
&
CanUseExtraThreads
(
)
;
MOZ_ASSERT_IF
(
reason
=
=
JS
:
:
GCReason
:
:
DESTROY_RUNTIME
!
shouldUse
)
;
return
shouldUse
;
}
void
GCRuntime
:
:
startCollection
(
JS
:
:
GCReason
reason
)
{
checkGCStateNotInUse
(
)
;
MOZ_ASSERT_IF
(
isShuttingDown
(
)
isShutdownGC
(
)
|
|
reason
=
=
JS
:
:
GCReason
:
:
XPCONNECT_SHUTDOWN
)
;
initialReason
=
reason
;
cleanUpEverything
=
ShouldCleanUpEverything
(
gcOptions
(
)
)
;
isCompacting
=
shouldCompact
(
)
;
rootsRemoved
=
false
;
sweepGroupIndex
=
0
;
lastGCStartTime_
=
TimeStamp
:
:
Now
(
)
;
#
ifdef
DEBUG
if
(
isShutdownGC
(
)
)
{
hadShutdownGC
=
true
;
}
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
gcSweepGroupIndex
=
0
;
}
#
endif
}
static
void
RelazifyFunctions
(
Zone
*
zone
AllocKind
kind
)
{
MOZ_ASSERT
(
kind
=
=
AllocKind
:
:
FUNCTION
|
|
kind
=
=
AllocKind
:
:
FUNCTION_EXTENDED
)
;
JSRuntime
*
rt
=
zone
-
>
runtimeFromMainThread
(
)
;
AutoAssertEmptyNursery
empty
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
for
(
auto
i
=
zone
-
>
cellIterUnsafe
<
JSObject
>
(
kind
empty
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
JSFunction
*
fun
=
&
i
-
>
as
<
JSFunction
>
(
)
;
if
(
fun
-
>
isIncomplete
(
)
)
{
continue
;
}
if
(
fun
-
>
hasBytecode
(
)
)
{
fun
-
>
maybeRelazify
(
rt
)
;
}
}
}
static
bool
ShouldCollectZone
(
Zone
*
zone
JS
:
:
GCReason
reason
)
{
if
(
reason
=
=
JS
:
:
GCReason
:
:
COMPARTMENT_REVIVED
)
{
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
if
(
comp
-
>
gcState
.
scheduledForDestruction
)
{
return
true
;
}
}
return
false
;
}
return
zone
-
>
isGCScheduled
(
)
;
}
bool
GCRuntime
:
:
prepareZonesForCollection
(
JS
:
:
GCReason
reason
bool
*
isFullOut
)
{
#
ifdef
DEBUG
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
!
zone
-
>
isCollecting
(
)
)
;
MOZ_ASSERT_IF
(
!
zone
-
>
isAtomsZone
(
)
!
zone
-
>
compartments
(
)
.
empty
(
)
)
;
for
(
auto
i
:
AllAllocKinds
(
)
)
{
MOZ_ASSERT
(
zone
-
>
arenas
.
collectingArenaList
(
i
)
.
isEmpty
(
)
)
;
}
}
#
endif
*
isFullOut
=
true
;
bool
any
=
false
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
bool
shouldCollect
=
ShouldCollectZone
(
zone
reason
)
;
if
(
shouldCollect
)
{
any
=
true
;
zone
-
>
changeGCState
(
Zone
:
:
NoGC
Zone
:
:
Prepare
)
;
}
else
{
*
isFullOut
=
false
;
}
zone
-
>
setWasCollected
(
shouldCollect
)
;
}
return
any
;
}
void
GCRuntime
:
:
discardJITCodeForGC
(
)
{
size_t
nurserySiteResetCount
=
0
;
size_t
pretenuredSiteResetCount
=
0
;
js
:
:
CancelOffThreadIonCompile
(
rt
JS
:
:
Zone
:
:
Prepare
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_DISCARD_CODE
)
;
PretenuringZone
&
pz
=
zone
-
>
pretenuring
;
bool
resetNurserySites
=
pz
.
shouldResetNurseryAllocSites
(
)
;
bool
resetPretenuredSites
=
pz
.
shouldResetPretenuredAllocSites
(
)
;
if
(
!
zone
-
>
isPreservingCode
(
)
)
{
Zone
:
:
DiscardOptions
options
;
options
.
discardJitScripts
=
true
;
options
.
resetNurseryAllocSites
=
resetNurserySites
;
options
.
resetPretenuredAllocSites
=
resetPretenuredSites
;
zone
-
>
discardJitCode
(
rt
-
>
gcContext
(
)
options
)
;
}
else
if
(
resetNurserySites
|
|
resetPretenuredSites
)
{
zone
-
>
resetAllocSitesAndInvalidate
(
resetNurserySites
resetPretenuredSites
)
;
}
if
(
resetNurserySites
)
{
nurserySiteResetCount
+
+
;
}
if
(
resetPretenuredSites
)
{
pretenuredSiteResetCount
+
+
;
}
}
if
(
nursery
(
)
.
reportPretenuring
(
)
)
{
if
(
nurserySiteResetCount
)
{
fprintf
(
stderr
"
GC
reset
nursery
alloc
sites
and
invalidated
code
in
%
zu
zones
\
n
"
nurserySiteResetCount
)
;
}
if
(
pretenuredSiteResetCount
)
{
fprintf
(
stderr
"
GC
reset
pretenured
alloc
sites
and
invalidated
code
in
%
zu
zones
\
n
"
pretenuredSiteResetCount
)
;
}
}
}
void
GCRuntime
:
:
relazifyFunctionsForShrinkingGC
(
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
RELAZIFY_FUNCTIONS
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
RelazifyFunctions
(
zone
AllocKind
:
:
FUNCTION
)
;
RelazifyFunctions
(
zone
AllocKind
:
:
FUNCTION_EXTENDED
)
;
}
}
void
GCRuntime
:
:
purgePropMapTablesForShrinkingGC
(
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
PURGE_PROP_MAP_TABLES
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
canRelocateZone
(
zone
)
|
|
zone
-
>
keepPropMapTables
(
)
)
{
continue
;
}
for
(
auto
map
=
zone
-
>
cellIterUnsafe
<
NormalPropMap
>
(
)
;
!
map
.
done
(
)
;
map
.
next
(
)
)
{
if
(
map
-
>
asLinked
(
)
-
>
hasTable
(
)
)
{
map
-
>
asLinked
(
)
-
>
purgeTable
(
rt
-
>
gcContext
(
)
)
;
}
}
for
(
auto
map
=
zone
-
>
cellIterUnsafe
<
DictionaryPropMap
>
(
)
;
!
map
.
done
(
)
;
map
.
next
(
)
)
{
if
(
map
-
>
asLinked
(
)
-
>
hasTable
(
)
)
{
map
-
>
asLinked
(
)
-
>
purgeTable
(
rt
-
>
gcContext
(
)
)
;
}
}
}
}
void
GCRuntime
:
:
purgeSourceURLsForShrinkingGC
(
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
PURGE_SOURCE_URLS
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
canRelocateZone
(
zone
)
|
|
zone
-
>
isSystemZone
(
)
)
{
continue
;
}
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
for
(
RealmsInCompartmentIter
realm
(
comp
)
;
!
realm
.
done
(
)
;
realm
.
next
(
)
)
{
GlobalObject
*
global
=
realm
.
get
(
)
-
>
unsafeUnbarrieredMaybeGlobal
(
)
;
if
(
global
)
{
global
-
>
clearSourceURLSHolder
(
)
;
}
}
}
}
}
void
GCRuntime
:
:
unmarkWeakMaps
(
)
{
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
WeakMapBase
:
:
unmarkZone
(
zone
)
;
}
}
bool
GCRuntime
:
:
beginPreparePhase
(
JS
:
:
GCReason
reason
AutoGCSession
&
session
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
PREPARE
)
;
if
(
!
prepareZonesForCollection
(
reason
&
isFull
.
ref
(
)
)
)
{
return
false
;
}
unmarkTask
.
initZones
(
)
;
if
(
useBackgroundThreads
)
{
unmarkTask
.
start
(
)
;
}
else
{
unmarkTask
.
runFromMainThread
(
)
;
}
if
(
!
isShutdownGC
(
)
&
&
reason
!
=
JS
:
:
GCReason
:
:
XPCONNECT_SHUTDOWN
)
{
StartHandlingCompressionsOnGC
(
rt
)
;
}
return
true
;
}
BackgroundUnmarkTask
:
:
BackgroundUnmarkTask
(
GCRuntime
*
gc
)
:
GCParallelTask
(
gc
gcstats
:
:
PhaseKind
:
:
UNMARK
)
{
}
void
BackgroundUnmarkTask
:
:
initZones
(
)
{
MOZ_ASSERT
(
isIdle
(
)
)
;
MOZ_ASSERT
(
zones
.
empty
(
)
)
;
MOZ_ASSERT
(
!
isCancelled
(
)
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zones
.
append
(
zone
.
get
(
)
)
)
{
oomUnsafe
.
crash
(
"
BackgroundUnmarkTask
:
:
initZones
"
)
;
}
zone
-
>
arenas
.
clearFreeLists
(
)
;
zone
-
>
arenas
.
moveArenasToCollectingLists
(
)
;
}
}
void
BackgroundUnmarkTask
:
:
run
(
AutoLockHelperThreadState
&
helperTheadLock
)
{
AutoUnlockHelperThreadState
unlock
(
helperTheadLock
)
;
for
(
Zone
*
zone
:
zones
)
{
for
(
auto
kind
:
AllAllocKinds
(
)
)
{
ArenaList
&
arenas
=
zone
-
>
arenas
.
collectingArenaList
(
kind
)
;
for
(
ArenaListIter
arena
(
arenas
.
head
(
)
)
;
!
arena
.
done
(
)
;
arena
.
next
(
)
)
{
arena
-
>
unmarkAll
(
)
;
if
(
isCancelled
(
)
)
{
break
;
}
}
}
}
zones
.
clear
(
)
;
}
void
GCRuntime
:
:
endPreparePhase
(
JS
:
:
GCReason
reason
)
{
MOZ_ASSERT
(
unmarkTask
.
isIdle
(
)
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
arenas
.
clearFreeLists
(
)
;
zone
-
>
setPreservingCode
(
false
)
;
#
ifdef
JS_GC_ZEAL
if
(
hasZealMode
(
ZealMode
:
:
YieldBeforeRootMarking
)
)
{
for
(
auto
kind
:
AllAllocKinds
(
)
)
{
for
(
ArenaIter
arena
(
zone
kind
)
;
!
arena
.
done
(
)
;
arena
.
next
(
)
)
{
arena
-
>
checkNoMarkedCells
(
)
;
}
}
}
#
endif
}
bool
canAllocateMoreCode
=
jit
:
:
CanLikelyAllocateMoreExecutableMemory
(
)
;
auto
currentTime
=
TimeStamp
:
:
Now
(
)
;
Compartment
*
activeCompartment
=
nullptr
;
jit
:
:
JitActivationIterator
activation
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
if
(
!
activation
.
done
(
)
)
{
activeCompartment
=
activation
-
>
compartment
(
)
;
}
for
(
CompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
c
-
>
gcState
.
scheduledForDestruction
=
false
;
c
-
>
gcState
.
maybeAlive
=
false
;
c
-
>
gcState
.
hasEnteredRealm
=
false
;
if
(
c
-
>
invisibleToDebugger
(
)
)
{
c
-
>
gcState
.
maybeAlive
=
true
;
}
bool
isActiveCompartment
=
c
=
=
activeCompartment
;
for
(
RealmsInCompartmentIter
r
(
c
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
if
(
r
-
>
shouldTraceGlobal
(
)
|
|
!
r
-
>
zone
(
)
-
>
isGCScheduled
(
)
)
{
c
-
>
gcState
.
maybeAlive
=
true
;
}
if
(
shouldPreserveJITCode
(
r
currentTime
reason
canAllocateMoreCode
isActiveCompartment
)
)
{
r
-
>
zone
(
)
-
>
setPreservingCode
(
true
)
;
}
if
(
r
-
>
hasBeenEnteredIgnoringJit
(
)
)
{
c
-
>
gcState
.
hasEnteredRealm
=
true
;
}
}
}
{
gcstats
:
:
AutoPhase
ap1
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
PREPARE
)
;
AutoLockHelperThreadState
helperLock
;
AutoRunParallelTask
unmarkWeakMaps
(
this
&
GCRuntime
:
:
unmarkWeakMaps
gcstats
:
:
PhaseKind
:
:
UNMARK_WEAKMAPS
GCUse
:
:
Unspecified
helperLock
)
;
AutoUnlockHelperThreadState
unlock
(
helperLock
)
;
discardJITCodeForGC
(
)
;
haveDiscardedJITCodeThisSlice
=
true
;
if
(
isShrinkingGC
(
)
)
{
relazifyFunctionsForShrinkingGC
(
)
;
purgePropMapTablesForShrinkingGC
(
)
;
purgeSourceURLsForShrinkingGC
(
)
;
}
purgeRuntime
(
)
;
startBackgroundFreeAfterMinorGC
(
)
;
if
(
isShutdownGC
(
)
)
{
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
clearRootsForShutdownGC
(
)
;
}
#
ifdef
DEBUG
testMarkQueue
.
clear
(
)
;
queuePos
=
0
;
#
endif
}
}
#
ifdef
DEBUG
if
(
fullCompartmentChecks
)
{
checkForCompartmentMismatches
(
)
;
}
#
endif
}
AutoUpdateLiveCompartments
:
:
AutoUpdateLiveCompartments
(
GCRuntime
*
gc
)
:
gc
(
gc
)
{
for
(
GCCompartmentsIter
c
(
gc
-
>
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
c
-
>
gcState
.
hasMarkedCells
=
false
;
}
}
AutoUpdateLiveCompartments
:
:
~
AutoUpdateLiveCompartments
(
)
{
for
(
GCCompartmentsIter
c
(
gc
-
>
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
if
(
c
-
>
gcState
.
hasMarkedCells
)
{
c
-
>
gcState
.
maybeAlive
=
true
;
}
}
}
Zone
:
:
GCState
Zone
:
:
initialMarkingState
(
)
const
{
if
(
isAtomsZone
(
)
)
{
return
MarkBlackAndGray
;
}
return
MarkBlackOnly
;
}
void
GCRuntime
:
:
beginMarkPhase
(
AutoGCSession
&
session
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK
)
;
incMajorGcNumber
(
)
;
#
ifdef
DEBUG
queuePos
=
0
;
queueMarkColor
.
reset
(
)
;
#
endif
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
changeGCState
(
Zone
:
:
Prepare
zone
-
>
initialMarkingState
(
)
)
;
zone
-
>
arenas
.
mergeArenasFromCollectingLists
(
)
;
zone
-
>
arenas
.
moveArenasToCollectingLists
(
)
;
for
(
RealmsInZoneIter
realm
(
zone
)
;
!
realm
.
done
(
)
;
realm
.
next
(
)
)
{
realm
-
>
clearAllocatedDuringGC
(
)
;
}
}
updateSchedulingStateOnGCStart
(
)
;
stats
(
)
.
measureInitialHeapSize
(
)
;
useParallelMarking
=
SingleThreadedMarking
;
if
(
canMarkInParallel
(
)
&
&
initParallelMarkers
(
)
)
{
useParallelMarking
=
AllowParallelMarking
;
}
MOZ_ASSERT
(
!
hasDelayedMarking
(
)
)
;
for
(
auto
&
marker
:
markers
)
{
marker
-
>
start
(
)
;
}
if
(
rt
-
>
isBeingDestroyed
(
)
)
{
checkNoRuntimeRoots
(
session
)
;
}
else
{
AutoUpdateLiveCompartments
updateLive
(
this
)
;
marker
(
)
.
setRootMarkingMode
(
true
)
;
traceRuntimeForMajorGC
(
marker
(
)
.
tracer
(
)
session
)
;
marker
(
)
.
setRootMarkingMode
(
false
)
;
}
}
void
GCRuntime
:
:
findDeadCompartments
(
)
{
gcstats
:
:
AutoPhase
ap1
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
FIND_DEAD_COMPARTMENTS
)
;
Vector
<
Compartment
*
0
js
:
:
SystemAllocPolicy
>
workList
;
for
(
CompartmentsIter
comp
(
rt
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
if
(
comp
-
>
gcState
.
maybeAlive
)
{
if
(
!
workList
.
append
(
comp
)
)
{
return
;
}
}
}
while
(
!
workList
.
empty
(
)
)
{
Compartment
*
comp
=
workList
.
popCopy
(
)
;
for
(
Compartment
:
:
WrappedObjectCompartmentEnum
e
(
comp
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Compartment
*
dest
=
e
.
front
(
)
;
if
(
!
dest
-
>
gcState
.
maybeAlive
)
{
dest
-
>
gcState
.
maybeAlive
=
true
;
if
(
!
workList
.
append
(
dest
)
)
{
return
;
}
}
}
}
for
(
GCCompartmentsIter
comp
(
rt
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
MOZ_ASSERT
(
!
comp
-
>
gcState
.
scheduledForDestruction
)
;
if
(
!
comp
-
>
gcState
.
maybeAlive
)
{
comp
-
>
gcState
.
scheduledForDestruction
=
true
;
}
}
}
void
GCRuntime
:
:
updateSchedulingStateOnGCStart
(
)
{
heapSize
.
updateOnGCStart
(
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
updateSchedulingStateOnGCStart
(
)
;
}
}
inline
bool
GCRuntime
:
:
canMarkInParallel
(
)
const
{
MOZ_ASSERT
(
state
(
)
>
=
gc
:
:
State
:
:
MarkRoots
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
if
(
oom
:
:
simulator
.
targetThread
(
)
=
=
THREAD_TYPE_GCPARALLEL
)
{
return
false
;
}
#
endif
return
markers
.
length
(
)
>
1
&
&
stats
(
)
.
initialCollectedBytes
(
)
>
=
tunables
.
parallelMarkingThresholdBytes
(
)
;
}
bool
GCRuntime
:
:
initParallelMarkers
(
)
{
MOZ_ASSERT
(
canMarkInParallel
(
)
)
;
for
(
size_t
i
=
1
;
i
<
markers
.
length
(
)
;
i
+
+
)
{
if
(
!
markers
[
i
]
-
>
initStack
(
)
)
{
return
false
;
}
}
return
true
;
}
IncrementalProgress
GCRuntime
:
:
markUntilBudgetExhausted
(
SliceBudget
&
sliceBudget
ParallelMarking
allowParallelMarking
ShouldReportMarkTime
reportTime
)
{
AutoMajorGCProfilerEntry
s
(
this
)
;
if
(
initialState
!
=
State
:
:
Mark
)
{
sliceBudget
.
forceCheck
(
)
;
if
(
sliceBudget
.
isOverBudget
(
)
)
{
return
NotFinished
;
}
}
if
(
processTestMarkQueue
(
)
=
=
QueueYielded
)
{
return
NotFinished
;
}
if
(
allowParallelMarking
)
{
MOZ_ASSERT
(
canMarkInParallel
(
)
)
;
MOZ_ASSERT
(
parallelMarkingEnabled
)
;
MOZ_ASSERT
(
reportTime
)
;
MOZ_ASSERT
(
!
isBackgroundMarking
(
)
)
;
ParallelMarker
pm
(
this
)
;
if
(
!
pm
.
mark
(
sliceBudget
)
)
{
return
NotFinished
;
}
assertNoMarkingWork
(
)
;
return
Finished
;
}
#
ifdef
DEBUG
AutoSetThreadIsMarking
threadIsMarking
;
#
endif
return
marker
(
)
.
markUntilBudgetExhausted
(
sliceBudget
reportTime
)
?
Finished
:
NotFinished
;
}
void
GCRuntime
:
:
drainMarkStack
(
)
{
auto
unlimited
=
SliceBudget
:
:
unlimited
(
)
;
MOZ_RELEASE_ASSERT
(
marker
(
)
.
markUntilBudgetExhausted
(
unlimited
)
)
;
}
#
ifdef
DEBUG
const
GCVector
<
HeapPtr
<
JS
:
:
Value
>
0
SystemAllocPolicy
>
&
GCRuntime
:
:
getTestMarkQueue
(
)
const
{
return
testMarkQueue
.
get
(
)
;
}
bool
GCRuntime
:
:
appendTestMarkQueue
(
const
JS
:
:
Value
&
value
)
{
return
testMarkQueue
.
append
(
value
)
;
}
void
GCRuntime
:
:
clearTestMarkQueue
(
)
{
testMarkQueue
.
clear
(
)
;
queuePos
=
0
;
}
size_t
GCRuntime
:
:
testMarkQueuePos
(
)
const
{
return
queuePos
;
}
#
endif
GCRuntime
:
:
MarkQueueProgress
GCRuntime
:
:
processTestMarkQueue
(
)
{
#
ifdef
DEBUG
if
(
testMarkQueue
.
empty
(
)
)
{
return
QueueComplete
;
}
if
(
queueMarkColor
=
=
mozilla
:
:
Some
(
MarkColor
:
:
Gray
)
&
&
state
(
)
!
=
State
:
:
Sweep
)
{
return
QueueSuspended
;
}
if
(
queueMarkColor
=
=
mozilla
:
:
Some
(
MarkColor
:
:
Gray
)
&
&
marker
(
)
.
hasBlackEntries
(
)
)
{
return
QueueSuspended
;
}
bool
willRevertToGray
=
marker
(
)
.
markColor
(
)
=
=
MarkColor
:
:
Gray
;
AutoSetMarkColor
autoRevertColor
(
marker
(
)
queueMarkColor
.
valueOr
(
marker
(
)
.
markColor
(
)
)
)
;
while
(
queuePos
<
testMarkQueue
.
length
(
)
)
{
Value
val
=
testMarkQueue
[
queuePos
+
+
]
.
get
(
)
;
if
(
val
.
isObject
(
)
)
{
JSObject
*
obj
=
&
val
.
toObject
(
)
;
JS
:
:
Zone
*
zone
=
obj
-
>
zone
(
)
;
if
(
!
zone
-
>
isGCMarking
(
)
|
|
obj
-
>
isMarkedAtLeast
(
marker
(
)
.
markColor
(
)
)
)
{
continue
;
}
if
(
state
(
)
=
=
State
:
:
Sweep
&
&
initialState
!
=
State
:
:
Sweep
)
{
if
(
zone
-
>
gcSweepGroupIndex
<
getCurrentSweepGroupIndex
(
)
)
{
continue
;
}
if
(
zone
-
>
gcSweepGroupIndex
>
getCurrentSweepGroupIndex
(
)
)
{
queuePos
-
-
;
return
QueueSuspended
;
}
}
if
(
marker
(
)
.
markColor
(
)
=
=
MarkColor
:
:
Gray
&
&
zone
-
>
isGCMarkingBlackOnly
(
)
)
{
queuePos
-
-
;
return
QueueSuspended
;
}
if
(
marker
(
)
.
markColor
(
)
=
=
MarkColor
:
:
Black
&
&
willRevertToGray
)
{
queuePos
-
-
;
return
QueueSuspended
;
}
size_t
oldPosition
=
marker
(
)
.
stack
.
position
(
)
;
marker
(
)
.
markAndTraverse
<
NormalMarkingOptions
>
(
obj
)
;
if
(
marker
(
)
.
stack
.
position
(
)
=
=
oldPosition
)
{
MOZ_ASSERT
(
obj
-
>
asTenured
(
)
.
arena
(
)
-
>
onDelayedMarkingList
(
)
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
oomUnsafe
.
crash
(
"
Overflowed
stack
while
marking
test
queue
"
)
;
}
SliceBudget
unlimited
=
SliceBudget
:
:
unlimited
(
)
;
marker
(
)
.
processMarkStackTop
<
NormalMarkingOptions
>
(
unlimited
)
;
}
else
if
(
val
.
isString
(
)
)
{
JSLinearString
*
str
=
&
val
.
toString
(
)
-
>
asLinear
(
)
;
if
(
js
:
:
StringEqualsLiteral
(
str
"
yield
"
)
&
&
isIncrementalGc
(
)
)
{
return
QueueYielded
;
}
if
(
js
:
:
StringEqualsLiteral
(
str
"
enter
-
weak
-
marking
-
mode
"
)
|
|
js
:
:
StringEqualsLiteral
(
str
"
abort
-
weak
-
marking
-
mode
"
)
)
{
if
(
marker
(
)
.
isRegularMarking
(
)
)
{
queuePos
-
-
;
return
QueueSuspended
;
}
if
(
js
:
:
StringEqualsLiteral
(
str
"
abort
-
weak
-
marking
-
mode
"
)
)
{
marker
(
)
.
abortLinearWeakMarking
(
)
;
}
}
else
if
(
js
:
:
StringEqualsLiteral
(
str
"
drain
"
)
)
{
auto
unlimited
=
SliceBudget
:
:
unlimited
(
)
;
MOZ_RELEASE_ASSERT
(
marker
(
)
.
markUntilBudgetExhausted
(
unlimited
DontReportMarkTime
)
)
;
}
else
if
(
js
:
:
StringEqualsLiteral
(
str
"
set
-
color
-
gray
"
)
)
{
queueMarkColor
=
mozilla
:
:
Some
(
MarkColor
:
:
Gray
)
;
if
(
state
(
)
!
=
State
:
:
Sweep
|
|
marker
(
)
.
hasBlackEntries
(
)
)
{
queuePos
-
-
;
return
QueueSuspended
;
}
marker
(
)
.
setMarkColor
(
MarkColor
:
:
Gray
)
;
}
else
if
(
js
:
:
StringEqualsLiteral
(
str
"
set
-
color
-
black
"
)
)
{
queueMarkColor
=
mozilla
:
:
Some
(
MarkColor
:
:
Black
)
;
marker
(
)
.
setMarkColor
(
MarkColor
:
:
Black
)
;
}
else
if
(
js
:
:
StringEqualsLiteral
(
str
"
unset
-
color
"
)
)
{
queueMarkColor
.
reset
(
)
;
}
}
}
#
endif
return
QueueComplete
;
}
static
bool
IsEmergencyGC
(
JS
:
:
GCReason
reason
)
{
return
reason
=
=
JS
:
:
GCReason
:
:
LAST_DITCH
|
|
reason
=
=
JS
:
:
GCReason
:
:
MEM_PRESSURE
;
}
void
GCRuntime
:
:
finishCollection
(
JS
:
:
GCReason
reason
)
{
assertBackgroundSweepingFinished
(
)
;
MOZ_ASSERT
(
!
hasDelayedMarking
(
)
)
;
for
(
size_t
i
=
0
;
i
<
markers
.
length
(
)
;
i
+
+
)
{
const
auto
&
marker
=
markers
[
i
]
;
marker
-
>
stop
(
)
;
if
(
i
=
=
0
)
{
marker
-
>
resetStackCapacity
(
)
;
}
else
{
marker
-
>
freeStack
(
)
;
}
}
maybeStopPretenuring
(
)
;
if
(
IsEmergencyGC
(
reason
)
)
{
waitBackgroundFreeEnd
(
)
;
}
TimeStamp
currentTime
=
TimeStamp
:
:
Now
(
)
;
updateSchedulingStateAfterCollection
(
currentTime
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
changeGCState
(
Zone
:
:
Finished
Zone
:
:
NoGC
)
;
zone
-
>
notifyObservingDebuggers
(
)
;
}
#
ifdef
JS_GC_ZEAL
clearSelectedForMarking
(
)
;
#
endif
schedulingState
.
updateHighFrequencyMode
(
lastGCEndTime_
currentTime
tunables
)
;
lastGCEndTime_
=
currentTime
;
checkGCStateNotInUse
(
)
;
}
void
GCRuntime
:
:
checkGCStateNotInUse
(
)
{
#
ifdef
DEBUG
for
(
auto
&
marker
:
markers
)
{
MOZ_ASSERT
(
!
marker
-
>
isActive
(
)
)
;
MOZ_ASSERT
(
marker
-
>
isDrained
(
)
)
;
}
MOZ_ASSERT
(
!
hasDelayedMarking
(
)
)
;
MOZ_ASSERT
(
!
lastMarkSlice
)
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
wasCollected
(
)
)
{
zone
-
>
arenas
.
checkGCStateNotInUse
(
)
;
}
MOZ_ASSERT
(
!
zone
-
>
wasGCStarted
(
)
)
;
MOZ_ASSERT
(
!
zone
-
>
needsIncrementalBarrier
(
)
)
;
MOZ_ASSERT
(
!
zone
-
>
isOnList
(
)
)
;
}
MOZ_ASSERT
(
zonesToMaybeCompact
.
ref
(
)
.
isEmpty
(
)
)
;
MOZ_ASSERT
(
cellsToAssertNotGray
.
ref
(
)
.
empty
(
)
)
;
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
!
requestSliceAfterBackgroundTask
)
;
MOZ_ASSERT
(
unmarkTask
.
isIdle
(
lock
)
)
;
MOZ_ASSERT
(
markTask
.
isIdle
(
lock
)
)
;
MOZ_ASSERT
(
sweepTask
.
isIdle
(
lock
)
)
;
MOZ_ASSERT
(
decommitTask
.
isIdle
(
lock
)
)
;
#
endif
}
void
GCRuntime
:
:
maybeStopPretenuring
(
)
{
nursery
(
)
.
maybeStopPretenuring
(
this
)
;
size_t
zonesWhereStringsEnabled
=
0
;
size_t
zonesWhereBigIntsEnabled
=
0
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
nurseryStringsDisabled
|
|
zone
-
>
nurseryBigIntsDisabled
)
{
if
(
zone
-
>
pretenuring
.
shouldResetPretenuredAllocSites
(
)
)
{
zone
-
>
unknownAllocSite
(
JS
:
:
TraceKind
:
:
String
)
-
>
maybeResetState
(
)
;
zone
-
>
unknownAllocSite
(
JS
:
:
TraceKind
:
:
BigInt
)
-
>
maybeResetState
(
)
;
if
(
zone
-
>
nurseryStringsDisabled
)
{
zone
-
>
nurseryStringsDisabled
=
false
;
zonesWhereStringsEnabled
+
+
;
}
if
(
zone
-
>
nurseryBigIntsDisabled
)
{
zone
-
>
nurseryBigIntsDisabled
=
false
;
zonesWhereBigIntsEnabled
+
+
;
}
nursery
(
)
.
updateAllocFlagsForZone
(
zone
)
;
}
}
}
if
(
nursery
(
)
.
reportPretenuring
(
)
)
{
if
(
zonesWhereStringsEnabled
)
{
fprintf
(
stderr
"
GC
re
-
enabled
nursery
string
allocation
in
%
zu
zones
\
n
"
zonesWhereStringsEnabled
)
;
}
if
(
zonesWhereBigIntsEnabled
)
{
fprintf
(
stderr
"
GC
re
-
enabled
nursery
big
int
allocation
in
%
zu
zones
\
n
"
zonesWhereBigIntsEnabled
)
;
}
}
}
void
GCRuntime
:
:
updateSchedulingStateAfterCollection
(
TimeStamp
currentTime
)
{
TimeDuration
totalGCTime
=
stats
(
)
.
totalGCTime
(
)
;
size_t
totalInitialBytes
=
stats
(
)
.
initialCollectedBytes
(
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
tunables
.
balancedHeapLimitsEnabled
(
)
&
&
totalInitialBytes
!
=
0
)
{
zone
-
>
updateCollectionRate
(
totalGCTime
totalInitialBytes
)
;
}
zone
-
>
clearGCSliceThresholds
(
)
;
zone
-
>
updateGCStartThresholds
(
*
this
)
;
}
}
void
GCRuntime
:
:
updateAllGCStartThresholds
(
)
{
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
updateGCStartThresholds
(
*
this
)
;
}
}
void
GCRuntime
:
:
updateAllocationRates
(
)
{
TimeStamp
currentTime
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
totalTime
=
currentTime
-
lastAllocRateUpdateTime
;
if
(
collectorTimeSinceAllocRateUpdate
>
=
totalTime
)
{
return
;
}
TimeDuration
mutatorTime
=
totalTime
-
collectorTimeSinceAllocRateUpdate
;
for
(
AllZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
updateAllocationRate
(
mutatorTime
)
;
zone
-
>
updateGCStartThresholds
(
*
this
)
;
}
lastAllocRateUpdateTime
=
currentTime
;
collectorTimeSinceAllocRateUpdate
=
TimeDuration
:
:
Zero
(
)
;
}
static
const
char
*
GCHeapStateToLabel
(
JS
:
:
HeapState
heapState
)
{
switch
(
heapState
)
{
case
JS
:
:
HeapState
:
:
MinorCollecting
:
return
"
js
:
:
Nursery
:
:
collect
"
;
case
JS
:
:
HeapState
:
:
MajorCollecting
:
return
"
js
:
:
GCRuntime
:
:
collect
"
;
default
:
MOZ_CRASH
(
"
Unexpected
heap
state
when
pushing
GC
profiling
stack
frame
"
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Should
have
exhausted
every
JS
:
:
HeapState
variant
!
"
)
;
return
nullptr
;
}
static
JS
:
:
ProfilingCategoryPair
GCHeapStateToProfilingCategory
(
JS
:
:
HeapState
heapState
)
{
return
heapState
=
=
JS
:
:
HeapState
:
:
MinorCollecting
?
JS
:
:
ProfilingCategoryPair
:
:
GCCC_MinorGC
:
JS
:
:
ProfilingCategoryPair
:
:
GCCC_MajorGC
;
}
AutoHeapSession
:
:
AutoHeapSession
(
GCRuntime
*
gc
JS
:
:
HeapState
heapState
)
:
gc
(
gc
)
prevState
(
gc
-
>
heapState_
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
gc
-
>
rt
)
)
;
MOZ_ASSERT
(
prevState
=
=
JS
:
:
HeapState
:
:
Idle
|
|
(
prevState
=
=
JS
:
:
HeapState
:
:
MajorCollecting
&
&
heapState
=
=
JS
:
:
HeapState
:
:
MinorCollecting
)
)
;
MOZ_ASSERT
(
heapState
!
=
JS
:
:
HeapState
:
:
Idle
)
;
gc
-
>
heapState_
=
heapState
;
if
(
heapState
=
=
JS
:
:
HeapState
:
:
MinorCollecting
|
|
heapState
=
=
JS
:
:
HeapState
:
:
MajorCollecting
)
{
profilingStackFrame
.
emplace
(
gc
-
>
rt
-
>
mainContextFromOwnThread
(
)
GCHeapStateToLabel
(
heapState
)
GCHeapStateToProfilingCategory
(
heapState
)
)
;
}
}
AutoHeapSession
:
:
~
AutoHeapSession
(
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
gc
-
>
heapState_
=
prevState
;
}
static
const
char
*
MajorGCStateToLabel
(
State
state
)
{
switch
(
state
)
{
case
State
:
:
Mark
:
return
"
js
:
:
GCRuntime
:
:
markUntilBudgetExhausted
"
;
case
State
:
:
Sweep
:
return
"
js
:
:
GCRuntime
:
:
performSweepActions
"
;
case
State
:
:
Compact
:
return
"
js
:
:
GCRuntime
:
:
compactPhase
"
;
default
:
MOZ_CRASH
(
"
Unexpected
heap
state
when
pushing
GC
profiling
stack
frame
"
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Should
have
exhausted
every
State
variant
!
"
)
;
return
nullptr
;
}
static
JS
:
:
ProfilingCategoryPair
MajorGCStateToProfilingCategory
(
State
state
)
{
switch
(
state
)
{
case
State
:
:
Mark
:
return
JS
:
:
ProfilingCategoryPair
:
:
GCCC_MajorGC_Mark
;
case
State
:
:
Sweep
:
return
JS
:
:
ProfilingCategoryPair
:
:
GCCC_MajorGC_Sweep
;
case
State
:
:
Compact
:
return
JS
:
:
ProfilingCategoryPair
:
:
GCCC_MajorGC_Compact
;
default
:
MOZ_CRASH
(
"
Unexpected
heap
state
when
pushing
GC
profiling
stack
frame
"
)
;
}
}
AutoMajorGCProfilerEntry
:
:
AutoMajorGCProfilerEntry
(
GCRuntime
*
gc
)
:
AutoGeckoProfilerEntry
(
gc
-
>
rt
-
>
mainContextFromAnyThread
(
)
MajorGCStateToLabel
(
gc
-
>
state
(
)
)
MajorGCStateToProfilingCategory
(
gc
-
>
state
(
)
)
)
{
MOZ_ASSERT
(
gc
-
>
heapState
(
)
=
=
JS
:
:
HeapState
:
:
MajorCollecting
)
;
}
GCRuntime
:
:
IncrementalResult
GCRuntime
:
:
resetIncrementalGC
(
GCAbortReason
reason
)
{
MOZ_ASSERT
(
reason
!
=
GCAbortReason
:
:
None
)
;
if
(
incrementalState
=
=
State
:
:
NotActive
)
{
return
IncrementalResult
:
:
Ok
;
}
AutoGCSession
session
(
this
JS
:
:
HeapState
:
:
MajorCollecting
)
;
switch
(
incrementalState
)
{
case
State
:
:
NotActive
:
case
State
:
:
MarkRoots
:
case
State
:
:
Finish
:
MOZ_CRASH
(
"
Unexpected
GC
state
in
resetIncrementalGC
"
)
;
break
;
case
State
:
:
Prepare
:
unmarkTask
.
cancelAndWait
(
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
changeGCState
(
Zone
:
:
Prepare
Zone
:
:
NoGC
)
;
zone
-
>
clearGCSliceThresholds
(
)
;
zone
-
>
arenas
.
clearFreeLists
(
)
;
zone
-
>
arenas
.
mergeArenasFromCollectingLists
(
)
;
}
incrementalState
=
State
:
:
NotActive
;
checkGCStateNotInUse
(
)
;
break
;
case
State
:
:
Mark
:
{
for
(
auto
&
marker
:
markers
)
{
marker
-
>
reset
(
)
;
}
resetDelayedMarking
(
)
;
for
(
GCCompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
resetGrayList
(
c
)
;
}
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
changeGCState
(
zone
-
>
initialMarkingState
(
)
Zone
:
:
NoGC
)
;
zone
-
>
clearGCSliceThresholds
(
)
;
zone
-
>
arenas
.
unmarkPreMarkedFreeCells
(
)
;
zone
-
>
arenas
.
mergeArenasFromCollectingLists
(
)
;
}
{
AutoLockHelperThreadState
lock
;
lifoBlocksToFree
.
ref
(
)
.
freeAll
(
)
;
}
lastMarkSlice
=
false
;
incrementalState
=
State
:
:
Finish
;
#
ifdef
DEBUG
for
(
auto
&
marker
:
markers
)
{
MOZ_ASSERT
(
!
marker
-
>
shouldCheckCompartments
(
)
)
;
}
#
endif
break
;
}
case
State
:
:
Sweep
:
{
for
(
CompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
c
-
>
gcState
.
scheduledForDestruction
=
false
;
}
abortSweepAfterCurrentGroup
=
true
;
isCompacting
=
false
;
break
;
}
case
State
:
:
Finalize
:
{
isCompacting
=
false
;
break
;
}
case
State
:
:
Compact
:
{
MOZ_ASSERT
(
isCompacting
)
;
startedCompacting
=
true
;
zonesToMaybeCompact
.
ref
(
)
.
clear
(
)
;
break
;
}
case
State
:
:
Decommit
:
{
break
;
}
}
stats
(
)
.
reset
(
reason
)
;
return
IncrementalResult
:
:
ResetIncremental
;
}
AutoDisableBarriers
:
:
AutoDisableBarriers
(
GCRuntime
*
gc
)
:
gc
(
gc
)
{
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
isGCMarking
(
)
)
{
MOZ_ASSERT
(
zone
-
>
needsIncrementalBarrier
(
)
)
;
zone
-
>
setNeedsIncrementalBarrier
(
false
)
;
}
MOZ_ASSERT
(
!
zone
-
>
needsIncrementalBarrier
(
)
)
;
}
}
AutoDisableBarriers
:
:
~
AutoDisableBarriers
(
)
{
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
!
zone
-
>
needsIncrementalBarrier
(
)
)
;
if
(
zone
-
>
isGCMarking
(
)
)
{
zone
-
>
setNeedsIncrementalBarrier
(
true
)
;
}
}
}
static
bool
NeedToCollectNursery
(
GCRuntime
*
gc
)
{
return
!
gc
-
>
nursery
(
)
.
isEmpty
(
)
|
|
!
gc
-
>
storeBuffer
(
)
.
isEmpty
(
)
;
}
#
ifdef
DEBUG
static
const
char
*
DescribeBudget
(
const
SliceBudget
&
budget
)
{
constexpr
size_t
length
=
32
;
static
char
buffer
[
length
]
;
budget
.
describe
(
buffer
length
)
;
return
buffer
;
}
#
endif
static
bool
ShouldPauseMutatorWhileWaiting
(
const
SliceBudget
&
budget
JS
:
:
GCReason
reason
bool
budgetWasIncreased
)
{
return
budget
.
isTimeBudget
(
)
&
&
(
reason
=
=
JS
:
:
GCReason
:
:
ALLOC_TRIGGER
|
|
reason
=
=
JS
:
:
GCReason
:
:
TOO_MUCH_MALLOC
)
&
&
budgetWasIncreased
;
}
void
GCRuntime
:
:
incrementalSlice
(
SliceBudget
&
budget
JS
:
:
GCReason
reason
bool
budgetWasIncreased
)
{
MOZ_ASSERT_IF
(
isIncrementalGCInProgress
(
)
isIncremental
)
;
AutoSetThreadIsPerformingGC
performingGC
(
rt
-
>
gcContext
(
)
)
;
AutoGCSession
session
(
this
JS
:
:
HeapState
:
:
MajorCollecting
)
;
bool
destroyingRuntime
=
(
reason
=
=
JS
:
:
GCReason
:
:
DESTROY_RUNTIME
)
;
initialState
=
incrementalState
;
isIncremental
=
!
budget
.
isUnlimited
(
)
;
useBackgroundThreads
=
ShouldUseBackgroundThreads
(
isIncremental
reason
)
;
haveDiscardedJITCodeThisSlice
=
false
;
#
ifdef
JS_GC_ZEAL
useZeal
=
isIncremental
&
&
reason
=
=
JS
:
:
GCReason
:
:
DEBUG_GC
;
#
endif
#
ifdef
DEBUG
stats
(
)
.
log
(
"
Incremental
:
%
d
lastMarkSlice
:
%
d
useZeal
:
%
d
budget
:
%
s
"
"
budgetWasIncreased
:
%
d
"
bool
(
isIncremental
)
bool
(
lastMarkSlice
)
bool
(
useZeal
)
DescribeBudget
(
budget
)
budgetWasIncreased
)
;
#
endif
if
(
useZeal
&
&
hasIncrementalTwoSliceZealMode
(
)
)
{
stats
(
)
.
log
(
"
Using
unlimited
budget
for
two
-
slice
zeal
mode
"
)
;
budget
=
SliceBudget
:
:
unlimited
(
)
;
}
bool
shouldPauseMutator
=
ShouldPauseMutatorWhileWaiting
(
budget
reason
budgetWasIncreased
)
;
switch
(
incrementalState
)
{
case
State
:
:
NotActive
:
startCollection
(
reason
)
;
incrementalState
=
State
:
:
Prepare
;
if
(
!
beginPreparePhase
(
reason
session
)
)
{
incrementalState
=
State
:
:
NotActive
;
break
;
}
if
(
useZeal
&
&
hasZealMode
(
ZealMode
:
:
YieldBeforeRootMarking
)
)
{
break
;
}
[
[
fallthrough
]
]
;
case
State
:
:
Prepare
:
if
(
waitForBackgroundTask
(
unmarkTask
budget
shouldPauseMutator
DontTriggerSliceWhenFinished
)
=
=
NotFinished
)
{
break
;
}
incrementalState
=
State
:
:
MarkRoots
;
[
[
fallthrough
]
]
;
case
State
:
:
MarkRoots
:
if
(
NeedToCollectNursery
(
this
)
)
{
collectNurseryFromMajorGC
(
reason
)
;
}
endPreparePhase
(
reason
)
;
beginMarkPhase
(
session
)
;
incrementalState
=
State
:
:
Mark
;
if
(
useZeal
&
&
hasZealMode
(
ZealMode
:
:
YieldBeforeMarking
)
&
&
isIncremental
)
{
break
;
}
[
[
fallthrough
]
]
;
case
State
:
:
Mark
:
if
(
mightSweepInThisSlice
(
budget
.
isUnlimited
(
)
)
)
{
rt
-
>
mainContextFromOwnThread
(
)
-
>
traceWrapperGCRooters
(
marker
(
)
.
tracer
(
)
)
;
}
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK
)
;
if
(
markUntilBudgetExhausted
(
budget
useParallelMarking
)
=
=
NotFinished
)
{
break
;
}
}
assertNoMarkingWork
(
)
;
if
(
isIncremental
&
&
!
lastMarkSlice
)
{
if
(
(
initialState
=
=
State
:
:
Mark
&
&
!
(
useZeal
&
&
hasZealMode
(
ZealMode
:
:
YieldBeforeMarking
)
)
)
|
|
(
useZeal
&
&
hasZealMode
(
ZealMode
:
:
YieldBeforeSweeping
)
)
)
{
lastMarkSlice
=
true
;
stats
(
)
.
log
(
"
Yielding
before
starting
sweeping
"
)
;
break
;
}
}
incrementalState
=
State
:
:
Sweep
;
lastMarkSlice
=
false
;
beginSweepPhase
(
reason
session
)
;
[
[
fallthrough
]
]
;
case
State
:
:
Sweep
:
if
(
storeBuffer
(
)
.
mayHavePointersToDeadCells
(
)
)
{
collectNurseryFromMajorGC
(
reason
)
;
}
if
(
initialState
=
=
State
:
:
Sweep
)
{
rt
-
>
mainContextFromOwnThread
(
)
-
>
traceWrapperGCRooters
(
marker
(
)
.
tracer
(
)
)
;
}
if
(
performSweepActions
(
budget
)
=
=
NotFinished
)
{
break
;
}
endSweepPhase
(
destroyingRuntime
)
;
incrementalState
=
State
:
:
Finalize
;
[
[
fallthrough
]
]
;
case
State
:
:
Finalize
:
if
(
waitForBackgroundTask
(
sweepTask
budget
shouldPauseMutator
TriggerSliceWhenFinished
)
=
=
NotFinished
)
{
break
;
}
assertBackgroundSweepingFinished
(
)
;
{
gcstats
:
:
AutoPhase
ap1
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP
)
;
gcstats
:
:
AutoPhase
ap2
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
DESTROY
)
;
sweepZones
(
rt
-
>
gcContext
(
)
destroyingRuntime
)
;
}
MOZ_ASSERT
(
!
startedCompacting
)
;
incrementalState
=
State
:
:
Compact
;
if
(
isCompacting
&
&
!
budget
.
isUnlimited
(
)
)
{
break
;
}
[
[
fallthrough
]
]
;
case
State
:
:
Compact
:
if
(
isCompacting
)
{
if
(
NeedToCollectNursery
(
this
)
)
{
collectNurseryFromMajorGC
(
reason
)
;
}
storeBuffer
(
)
.
checkEmpty
(
)
;
if
(
!
startedCompacting
)
{
beginCompactPhase
(
)
;
}
if
(
compactPhase
(
reason
budget
session
)
=
=
NotFinished
)
{
break
;
}
endCompactPhase
(
)
;
}
startDecommit
(
)
;
incrementalState
=
State
:
:
Decommit
;
[
[
fallthrough
]
]
;
case
State
:
:
Decommit
:
if
(
waitForBackgroundTask
(
decommitTask
budget
shouldPauseMutator
TriggerSliceWhenFinished
)
=
=
NotFinished
)
{
break
;
}
incrementalState
=
State
:
:
Finish
;
[
[
fallthrough
]
]
;
case
State
:
:
Finish
:
finishCollection
(
reason
)
;
incrementalState
=
State
:
:
NotActive
;
break
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
safeToYield
)
;
for
(
auto
&
marker
:
markers
)
{
MOZ_ASSERT
(
marker
-
>
markColor
(
)
=
=
MarkColor
:
:
Black
)
;
}
MOZ_ASSERT
(
!
rt
-
>
gcContext
(
)
-
>
hasJitCodeToPoison
(
)
)
;
#
endif
}
void
GCRuntime
:
:
collectNurseryFromMajorGC
(
JS
:
:
GCReason
reason
)
{
collectNursery
(
gcOptions
(
)
reason
gcstats
:
:
PhaseKind
:
:
EVICT_NURSERY_FOR_MAJOR_GC
)
;
}
bool
GCRuntime
:
:
hasForegroundWork
(
)
const
{
switch
(
incrementalState
)
{
case
State
:
:
NotActive
:
return
false
;
case
State
:
:
Prepare
:
return
!
unmarkTask
.
wasStarted
(
)
;
case
State
:
:
Finalize
:
return
!
isBackgroundSweeping
(
)
;
case
State
:
:
Decommit
:
return
!
decommitTask
.
wasStarted
(
)
;
default
:
return
true
;
}
}
IncrementalProgress
GCRuntime
:
:
waitForBackgroundTask
(
GCParallelTask
&
task
const
SliceBudget
&
budget
bool
shouldPauseMutator
ShouldTriggerSliceWhenFinished
triggerSlice
)
{
if
(
budget
.
isUnlimited
(
)
|
|
shouldPauseMutator
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
WAIT_BACKGROUND_THREAD
)
;
Maybe
<
TimeStamp
>
deadline
;
if
(
budget
.
isTimeBudget
(
)
)
{
deadline
.
emplace
(
budget
.
deadline
(
)
)
;
}
task
.
join
(
deadline
)
;
}
if
(
!
budget
.
isUnlimited
(
)
)
{
AutoLockHelperThreadState
lock
;
if
(
task
.
wasStarted
(
lock
)
)
{
if
(
triggerSlice
)
{
requestSliceAfterBackgroundTask
=
true
;
}
return
NotFinished
;
}
task
.
joinWithLockHeld
(
lock
)
;
}
MOZ_ASSERT
(
task
.
isIdle
(
)
)
;
if
(
triggerSlice
)
{
cancelRequestedGCAfterBackgroundTask
(
)
;
}
return
Finished
;
}
GCAbortReason
gc
:
:
IsIncrementalGCUnsafe
(
JSRuntime
*
rt
)
{
MOZ_ASSERT
(
!
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
;
if
(
!
rt
-
>
gc
.
isIncrementalGCAllowed
(
)
)
{
return
GCAbortReason
:
:
IncrementalDisabled
;
}
return
GCAbortReason
:
:
None
;
}
inline
void
GCRuntime
:
:
checkZoneIsScheduled
(
Zone
*
zone
JS
:
:
GCReason
reason
const
char
*
trigger
)
{
#
ifdef
DEBUG
if
(
zone
-
>
isGCScheduled
(
)
)
{
return
;
}
fprintf
(
stderr
"
checkZoneIsScheduled
:
Zone
%
p
not
scheduled
as
expected
in
%
s
GC
"
"
for
%
s
trigger
\
n
"
zone
JS
:
:
ExplainGCReason
(
reason
)
trigger
)
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
fprintf
(
stderr
"
Zone
%
p
:
%
s
%
s
\
n
"
zone
.
get
(
)
zone
-
>
isAtomsZone
(
)
?
"
atoms
"
:
"
"
zone
-
>
isGCScheduled
(
)
?
"
scheduled
"
:
"
"
)
;
}
fflush
(
stderr
)
;
MOZ_CRASH
(
"
Zone
not
scheduled
"
)
;
#
endif
}
GCRuntime
:
:
IncrementalResult
GCRuntime
:
:
budgetIncrementalGC
(
bool
nonincrementalByAPI
JS
:
:
GCReason
reason
SliceBudget
&
budget
)
{
if
(
nonincrementalByAPI
)
{
stats
(
)
.
nonincremental
(
GCAbortReason
:
:
NonIncrementalRequested
)
;
budget
=
SliceBudget
:
:
unlimited
(
)
;
if
(
reason
!
=
JS
:
:
GCReason
:
:
ALLOC_TRIGGER
)
{
return
resetIncrementalGC
(
GCAbortReason
:
:
NonIncrementalRequested
)
;
}
return
IncrementalResult
:
:
Ok
;
}
if
(
reason
=
=
JS
:
:
GCReason
:
:
ABORT_GC
)
{
budget
=
SliceBudget
:
:
unlimited
(
)
;
stats
(
)
.
nonincremental
(
GCAbortReason
:
:
AbortRequested
)
;
return
resetIncrementalGC
(
GCAbortReason
:
:
AbortRequested
)
;
}
if
(
!
budget
.
isUnlimited
(
)
)
{
GCAbortReason
unsafeReason
=
IsIncrementalGCUnsafe
(
rt
)
;
if
(
unsafeReason
=
=
GCAbortReason
:
:
None
)
{
if
(
reason
=
=
JS
:
:
GCReason
:
:
COMPARTMENT_REVIVED
)
{
unsafeReason
=
GCAbortReason
:
:
CompartmentRevived
;
}
else
if
(
!
incrementalGCEnabled
)
{
unsafeReason
=
GCAbortReason
:
:
ModeChange
;
}
}
if
(
unsafeReason
!
=
GCAbortReason
:
:
None
)
{
budget
=
SliceBudget
:
:
unlimited
(
)
;
stats
(
)
.
nonincremental
(
unsafeReason
)
;
return
resetIncrementalGC
(
unsafeReason
)
;
}
}
GCAbortReason
resetReason
=
GCAbortReason
:
:
None
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
gcHeapSize
.
bytes
(
)
>
=
zone
-
>
gcHeapThreshold
.
incrementalLimitBytes
(
)
)
{
checkZoneIsScheduled
(
zone
reason
"
GC
bytes
"
)
;
budget
=
SliceBudget
:
:
unlimited
(
)
;
stats
(
)
.
nonincremental
(
GCAbortReason
:
:
GCBytesTrigger
)
;
if
(
zone
-
>
wasGCStarted
(
)
&
&
zone
-
>
gcState
(
)
>
Zone
:
:
Sweep
)
{
resetReason
=
GCAbortReason
:
:
GCBytesTrigger
;
}
}
if
(
zone
-
>
mallocHeapSize
.
bytes
(
)
>
=
zone
-
>
mallocHeapThreshold
.
incrementalLimitBytes
(
)
)
{
checkZoneIsScheduled
(
zone
reason
"
malloc
bytes
"
)
;
budget
=
SliceBudget
:
:
unlimited
(
)
;
stats
(
)
.
nonincremental
(
GCAbortReason
:
:
MallocBytesTrigger
)
;
if
(
zone
-
>
wasGCStarted
(
)
&
&
zone
-
>
gcState
(
)
>
Zone
:
:
Sweep
)
{
resetReason
=
GCAbortReason
:
:
MallocBytesTrigger
;
}
}
if
(
zone
-
>
jitHeapSize
.
bytes
(
)
>
=
zone
-
>
jitHeapThreshold
.
incrementalLimitBytes
(
)
)
{
checkZoneIsScheduled
(
zone
reason
"
JIT
code
bytes
"
)
;
budget
=
SliceBudget
:
:
unlimited
(
)
;
stats
(
)
.
nonincremental
(
GCAbortReason
:
:
JitCodeBytesTrigger
)
;
if
(
zone
-
>
wasGCStarted
(
)
&
&
zone
-
>
gcState
(
)
>
Zone
:
:
Sweep
)
{
resetReason
=
GCAbortReason
:
:
JitCodeBytesTrigger
;
}
}
if
(
isIncrementalGCInProgress
(
)
&
&
zone
-
>
isGCScheduled
(
)
!
=
zone
-
>
wasGCStarted
(
)
)
{
budget
=
SliceBudget
:
:
unlimited
(
)
;
resetReason
=
GCAbortReason
:
:
ZoneChange
;
}
}
if
(
resetReason
!
=
GCAbortReason
:
:
None
)
{
return
resetIncrementalGC
(
resetReason
)
;
}
return
IncrementalResult
:
:
Ok
;
}
bool
GCRuntime
:
:
maybeIncreaseSliceBudget
(
SliceBudget
&
budget
)
{
if
(
js
:
:
SupportDifferentialTesting
(
)
)
{
return
false
;
}
if
(
!
budget
.
isTimeBudget
(
)
|
|
!
isIncrementalGCInProgress
(
)
)
{
return
false
;
}
bool
wasIncreasedForLongCollections
=
maybeIncreaseSliceBudgetForLongCollections
(
budget
)
;
bool
wasIncreasedForUgentCollections
=
maybeIncreaseSliceBudgetForUrgentCollections
(
budget
)
;
return
wasIncreasedForLongCollections
|
|
wasIncreasedForUgentCollections
;
}
static
bool
ExtendBudget
(
SliceBudget
&
budget
double
newDuration
)
{
long
millis
=
lround
(
newDuration
)
;
if
(
millis
<
=
budget
.
timeBudget
(
)
)
{
return
false
;
}
bool
idleTriggered
=
budget
.
idle
;
budget
=
SliceBudget
(
TimeBudget
(
millis
)
nullptr
)
;
budget
.
idle
=
idleTriggered
;
budget
.
extended
=
true
;
return
true
;
}
bool
GCRuntime
:
:
maybeIncreaseSliceBudgetForLongCollections
(
SliceBudget
&
budget
)
{
struct
BudgetAtTime
{
double
time
;
double
budget
;
}
;
const
BudgetAtTime
MinBudgetStart
{
1500
0
.
0
}
;
const
BudgetAtTime
MinBudgetEnd
{
2500
100
.
0
}
;
double
totalTime
=
(
TimeStamp
:
:
Now
(
)
-
lastGCStartTime
(
)
)
.
ToMilliseconds
(
)
;
double
minBudget
=
LinearInterpolate
(
totalTime
MinBudgetStart
.
time
MinBudgetStart
.
budget
MinBudgetEnd
.
time
MinBudgetEnd
.
budget
)
;
return
ExtendBudget
(
budget
minBudget
)
;
}
bool
GCRuntime
:
:
maybeIncreaseSliceBudgetForUrgentCollections
(
SliceBudget
&
budget
)
{
size_t
minBytesRemaining
=
SIZE_MAX
;
for
(
AllZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zone
-
>
wasGCStarted
(
)
)
{
continue
;
}
size_t
gcBytesRemaining
=
zone
-
>
gcHeapThreshold
.
incrementalBytesRemaining
(
zone
-
>
gcHeapSize
)
;
minBytesRemaining
=
std
:
:
min
(
minBytesRemaining
gcBytesRemaining
)
;
size_t
mallocBytesRemaining
=
zone
-
>
mallocHeapThreshold
.
incrementalBytesRemaining
(
zone
-
>
mallocHeapSize
)
;
minBytesRemaining
=
std
:
:
min
(
minBytesRemaining
mallocBytesRemaining
)
;
}
if
(
minBytesRemaining
<
tunables
.
urgentThresholdBytes
(
)
&
&
minBytesRemaining
!
=
0
)
{
double
fractionRemaining
=
double
(
minBytesRemaining
)
/
double
(
tunables
.
urgentThresholdBytes
(
)
)
;
double
minBudget
=
double
(
defaultSliceBudgetMS
(
)
)
/
fractionRemaining
;
return
ExtendBudget
(
budget
minBudget
)
;
}
return
false
;
}
static
void
ScheduleZones
(
GCRuntime
*
gc
JS
:
:
GCReason
reason
)
{
for
(
ZonesIter
zone
(
gc
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
gc
-
>
tunables
.
balancedHeapLimitsEnabled
(
)
&
&
zone
-
>
isGCScheduled
(
)
&
&
zone
-
>
smoothedCollectionRate
.
ref
(
)
.
isNothing
(
)
&
&
reason
=
=
JS
:
:
GCReason
:
:
ALLOC_TRIGGER
&
&
zone
-
>
gcHeapSize
.
bytes
(
)
<
zone
-
>
gcHeapThreshold
.
startBytes
(
)
)
{
zone
-
>
unscheduleGC
(
)
;
}
if
(
gc
-
>
isShutdownGC
(
)
)
{
zone
-
>
scheduleGC
(
)
;
}
if
(
!
gc
-
>
isPerZoneGCEnabled
(
)
)
{
zone
-
>
scheduleGC
(
)
;
}
if
(
gc
-
>
isIncrementalGCInProgress
(
)
&
&
zone
-
>
wasGCStarted
(
)
)
{
zone
-
>
scheduleGC
(
)
;
}
bool
inHighFrequencyMode
=
gc
-
>
schedulingState
.
inHighFrequencyGCMode
(
)
;
if
(
zone
-
>
gcHeapSize
.
bytes
(
)
>
=
zone
-
>
gcHeapThreshold
.
eagerAllocTrigger
(
inHighFrequencyMode
)
|
|
zone
-
>
mallocHeapSize
.
bytes
(
)
>
=
zone
-
>
mallocHeapThreshold
.
eagerAllocTrigger
(
inHighFrequencyMode
)
|
|
zone
-
>
jitHeapSize
.
bytes
(
)
>
=
zone
-
>
jitHeapThreshold
.
startBytes
(
)
)
{
zone
-
>
scheduleGC
(
)
;
}
}
}
static
void
UnscheduleZones
(
GCRuntime
*
gc
)
{
for
(
ZonesIter
zone
(
gc
-
>
rt
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
unscheduleGC
(
)
;
}
}
class
js
:
:
gc
:
:
AutoCallGCCallbacks
{
GCRuntime
&
gc_
;
JS
:
:
GCReason
reason_
;
public
:
explicit
AutoCallGCCallbacks
(
GCRuntime
&
gc
JS
:
:
GCReason
reason
)
:
gc_
(
gc
)
reason_
(
reason
)
{
gc_
.
maybeCallGCCallback
(
JSGC_BEGIN
reason
)
;
}
~
AutoCallGCCallbacks
(
)
{
gc_
.
maybeCallGCCallback
(
JSGC_END
reason_
)
;
}
}
;
void
GCRuntime
:
:
maybeCallGCCallback
(
JSGCStatus
status
JS
:
:
GCReason
reason
)
{
if
(
!
gcCallback
.
ref
(
)
.
op
)
{
return
;
}
if
(
isIncrementalGCInProgress
(
)
)
{
return
;
}
if
(
gcCallbackDepth
=
=
0
)
{
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
gcScheduledSaved_
=
zone
-
>
gcScheduled_
;
}
}
JS
:
:
GCOptions
options
=
gcOptions
(
)
;
maybeGcOptions
=
Nothing
(
)
;
bool
savedFullGCRequested
=
fullGCRequested
;
fullGCRequested
=
false
;
gcCallbackDepth
+
+
;
callGCCallback
(
status
reason
)
;
MOZ_ASSERT
(
gcCallbackDepth
!
=
0
)
;
gcCallbackDepth
-
-
;
maybeGcOptions
=
Some
(
options
)
;
fullGCRequested
=
(
status
=
=
JSGC_END
)
?
false
:
savedFullGCRequested
;
if
(
gcCallbackDepth
=
=
0
)
{
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
gcScheduled_
=
zone
-
>
gcScheduled_
|
|
zone
-
>
gcScheduledSaved_
;
}
}
}
MOZ_NEVER_INLINE
GCRuntime
:
:
IncrementalResult
GCRuntime
:
:
gcCycle
(
bool
nonincrementalByAPI
const
SliceBudget
&
budgetArg
JS
:
:
GCReason
reason
)
{
rt
-
>
mainContextFromOwnThread
(
)
-
>
verifyIsSafeToGC
(
)
;
MOZ_ASSERT
(
!
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
;
MOZ_ASSERT
(
reason
!
=
JS
:
:
GCReason
:
:
RESET
)
;
if
(
!
isIncrementalGCInProgress
(
)
)
{
assertBackgroundSweepingFinished
(
)
;
MOZ_ASSERT
(
decommitTask
.
isIdle
(
)
)
;
}
AutoCallGCCallbacks
callCallbacks
(
*
this
reason
)
;
SliceBudget
budget
(
budgetArg
)
;
bool
budgetWasIncreased
=
maybeIncreaseSliceBudget
(
budget
)
;
ScheduleZones
(
this
reason
)
;
auto
updateCollectorTime
=
MakeScopeExit
(
[
&
]
{
if
(
const
gcstats
:
:
Statistics
:
:
SliceData
*
slice
=
stats
(
)
.
lastSlice
(
)
)
{
collectorTimeSinceAllocRateUpdate
+
=
slice
-
>
duration
(
)
;
}
}
)
;
gcstats
:
:
AutoGCSlice
agc
(
stats
(
)
scanZonesBeforeGC
(
)
gcOptions
(
)
budget
reason
budgetWasIncreased
)
;
IncrementalResult
result
=
budgetIncrementalGC
(
nonincrementalByAPI
reason
budget
)
;
if
(
result
=
=
IncrementalResult
:
:
ResetIncremental
)
{
if
(
incrementalState
=
=
State
:
:
NotActive
)
{
return
result
;
}
reason
=
JS
:
:
GCReason
:
:
RESET
;
}
majorGCTriggerReason
=
JS
:
:
GCReason
:
:
NO_REASON
;
MOZ_ASSERT
(
!
stats
(
)
.
hasTrigger
(
)
)
;
incGcNumber
(
)
;
incGcSliceNumber
(
)
;
gcprobes
:
:
MajorGCStart
(
)
;
incrementalSlice
(
budget
reason
budgetWasIncreased
)
;
gcprobes
:
:
MajorGCEnd
(
)
;
MOZ_ASSERT_IF
(
result
=
=
IncrementalResult
:
:
ResetIncremental
!
isIncrementalGCInProgress
(
)
)
;
return
result
;
}
inline
bool
GCRuntime
:
:
mightSweepInThisSlice
(
bool
nonIncremental
)
{
MOZ_ASSERT
(
incrementalState
<
State
:
:
Sweep
)
;
return
nonIncremental
|
|
lastMarkSlice
|
|
hasIncrementalTwoSliceZealMode
(
)
;
}
#
ifdef
JS_GC_ZEAL
static
bool
IsDeterministicGCReason
(
JS
:
:
GCReason
reason
)
{
switch
(
reason
)
{
case
JS
:
:
GCReason
:
:
API
:
case
JS
:
:
GCReason
:
:
DESTROY_RUNTIME
:
case
JS
:
:
GCReason
:
:
LAST_DITCH
:
case
JS
:
:
GCReason
:
:
TOO_MUCH_MALLOC
:
case
JS
:
:
GCReason
:
:
TOO_MUCH_WASM_MEMORY
:
case
JS
:
:
GCReason
:
:
TOO_MUCH_JIT_CODE
:
case
JS
:
:
GCReason
:
:
ALLOC_TRIGGER
:
case
JS
:
:
GCReason
:
:
DEBUG_GC
:
case
JS
:
:
GCReason
:
:
CC_FORCED
:
case
JS
:
:
GCReason
:
:
SHUTDOWN_CC
:
case
JS
:
:
GCReason
:
:
ABORT_GC
:
case
JS
:
:
GCReason
:
:
DISABLE_GENERATIONAL_GC
:
case
JS
:
:
GCReason
:
:
FINISH_GC
:
case
JS
:
:
GCReason
:
:
PREPARE_FOR_TRACING
:
return
true
;
default
:
return
false
;
}
}
#
endif
gcstats
:
:
ZoneGCStats
GCRuntime
:
:
scanZonesBeforeGC
(
)
{
gcstats
:
:
ZoneGCStats
zoneStats
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zoneStats
.
zoneCount
+
+
;
zoneStats
.
compartmentCount
+
=
zone
-
>
compartments
(
)
.
length
(
)
;
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
zoneStats
.
realmCount
+
=
comp
-
>
realms
(
)
.
length
(
)
;
}
if
(
zone
-
>
isGCScheduled
(
)
)
{
zoneStats
.
collectedZoneCount
+
+
;
zoneStats
.
collectedCompartmentCount
+
=
zone
-
>
compartments
(
)
.
length
(
)
;
}
}
return
zoneStats
;
}
void
GCRuntime
:
:
maybeDoCycleCollection
(
)
{
const
static
float
ExcessiveGrayRealms
=
0
.
8f
;
const
static
size_t
LimitGrayRealms
=
200
;
size_t
realmsTotal
=
0
;
size_t
realmsGray
=
0
;
for
(
RealmsIter
realm
(
rt
)
;
!
realm
.
done
(
)
;
realm
.
next
(
)
)
{
+
+
realmsTotal
;
GlobalObject
*
global
=
realm
-
>
unsafeUnbarrieredMaybeGlobal
(
)
;
if
(
global
&
&
global
-
>
isMarkedGray
(
)
)
{
+
+
realmsGray
;
}
}
float
grayFraction
=
float
(
realmsGray
)
/
float
(
realmsTotal
)
;
if
(
grayFraction
>
ExcessiveGrayRealms
|
|
realmsGray
>
LimitGrayRealms
)
{
callDoCycleCollectionCallback
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
}
}
void
GCRuntime
:
:
checkCanCallAPI
(
)
{
MOZ_RELEASE_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
MOZ_RELEASE_ASSERT
(
!
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
}
bool
GCRuntime
:
:
checkIfGCAllowedInCurrentState
(
JS
:
:
GCReason
reason
)
{
if
(
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
{
return
false
;
}
if
(
rt
-
>
isBeingDestroyed
(
)
&
&
!
isShutdownGC
(
)
)
{
return
false
;
}
#
ifdef
JS_GC_ZEAL
if
(
deterministicOnly
&
&
!
IsDeterministicGCReason
(
reason
)
)
{
return
false
;
}
#
endif
return
true
;
}
bool
GCRuntime
:
:
shouldRepeatForDeadZone
(
JS
:
:
GCReason
reason
)
{
MOZ_ASSERT_IF
(
reason
=
=
JS
:
:
GCReason
:
:
COMPARTMENT_REVIVED
!
isIncremental
)
;
MOZ_ASSERT
(
!
isIncrementalGCInProgress
(
)
)
;
if
(
!
isIncremental
)
{
return
false
;
}
for
(
CompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
if
(
c
-
>
gcState
.
scheduledForDestruction
)
{
return
true
;
}
}
return
false
;
}
struct
MOZ_RAII
AutoSetZoneSliceThresholds
{
explicit
AutoSetZoneSliceThresholds
(
GCRuntime
*
gc
)
:
gc
(
gc
)
{
for
(
ZonesIter
zone
(
gc
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
zone
-
>
wasGCStarted
(
)
=
=
zone
-
>
gcHeapThreshold
.
hasSliceThreshold
(
)
)
;
MOZ_ASSERT
(
zone
-
>
wasGCStarted
(
)
=
=
zone
-
>
mallocHeapThreshold
.
hasSliceThreshold
(
)
)
;
}
}
~
AutoSetZoneSliceThresholds
(
)
{
bool
waitingOnBGTask
=
gc
-
>
isWaitingOnBackgroundTask
(
)
;
for
(
ZonesIter
zone
(
gc
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
wasGCStarted
(
)
)
{
zone
-
>
setGCSliceThresholds
(
*
gc
waitingOnBGTask
)
;
}
else
{
MOZ_ASSERT
(
!
zone
-
>
gcHeapThreshold
.
hasSliceThreshold
(
)
)
;
MOZ_ASSERT
(
!
zone
-
>
mallocHeapThreshold
.
hasSliceThreshold
(
)
)
;
}
}
}
GCRuntime
*
gc
;
}
;
void
GCRuntime
:
:
collect
(
bool
nonincrementalByAPI
const
SliceBudget
&
budget
JS
:
:
GCReason
reason
)
{
TimeStamp
startTime
=
TimeStamp
:
:
Now
(
)
;
auto
timer
=
MakeScopeExit
(
[
&
]
{
if
(
Realm
*
realm
=
rt
-
>
mainContextFromOwnThread
(
)
-
>
realm
(
)
)
{
realm
-
>
timers
.
gcTime
+
=
TimeStamp
:
:
Now
(
)
-
startTime
;
}
}
)
;
auto
clearGCOptions
=
MakeScopeExit
(
[
&
]
{
if
(
!
isIncrementalGCInProgress
(
)
)
{
maybeGcOptions
=
Nothing
(
)
;
}
}
)
;
MOZ_ASSERT
(
reason
!
=
JS
:
:
GCReason
:
:
NO_REASON
)
;
checkCanCallAPI
(
)
;
if
(
!
checkIfGCAllowedInCurrentState
(
reason
)
)
{
return
;
}
stats
(
)
.
log
(
"
GC
slice
starting
in
state
%
s
"
StateName
(
incrementalState
)
)
;
AutoStopVerifyingBarriers
av
(
rt
isShutdownGC
(
)
)
;
AutoMaybeLeaveAtomsZone
leaveAtomsZone
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
AutoSetZoneSliceThresholds
sliceThresholds
(
this
)
;
schedulingState
.
updateHighFrequencyModeForReason
(
reason
)
;
if
(
!
isIncrementalGCInProgress
(
)
&
&
tunables
.
balancedHeapLimitsEnabled
(
)
)
{
updateAllocationRates
(
)
;
}
bool
repeat
;
do
{
IncrementalResult
cycleResult
=
gcCycle
(
nonincrementalByAPI
budget
reason
)
;
if
(
reason
=
=
JS
:
:
GCReason
:
:
ABORT_GC
)
{
MOZ_ASSERT
(
!
isIncrementalGCInProgress
(
)
)
;
stats
(
)
.
log
(
"
GC
aborted
by
request
"
)
;
break
;
}
repeat
=
false
;
if
(
!
isIncrementalGCInProgress
(
)
)
{
if
(
cycleResult
=
=
ResetIncremental
)
{
repeat
=
true
;
}
else
if
(
rootsRemoved
&
&
isShutdownGC
(
)
)
{
JS
:
:
PrepareForFullGC
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
repeat
=
true
;
reason
=
JS
:
:
GCReason
:
:
ROOTS_REMOVED
;
}
else
if
(
shouldRepeatForDeadZone
(
reason
)
)
{
repeat
=
true
;
reason
=
JS
:
:
GCReason
:
:
COMPARTMENT_REVIVED
;
}
}
}
while
(
repeat
)
;
if
(
reason
=
=
JS
:
:
GCReason
:
:
COMPARTMENT_REVIVED
)
{
maybeDoCycleCollection
(
)
;
}
#
ifdef
JS_GC_ZEAL
if
(
hasZealMode
(
ZealMode
:
:
CheckHeapAfterGC
)
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
TRACE_HEAP
)
;
CheckHeapAfterGC
(
rt
)
;
}
if
(
hasZealMode
(
ZealMode
:
:
CheckGrayMarking
)
&
&
!
isIncrementalGCInProgress
(
)
)
{
MOZ_RELEASE_ASSERT
(
CheckGrayMarkingState
(
rt
)
)
;
}
#
endif
stats
(
)
.
log
(
"
GC
slice
ending
in
state
%
s
"
StateName
(
incrementalState
)
)
;
UnscheduleZones
(
this
)
;
}
SliceBudget
GCRuntime
:
:
defaultBudget
(
JS
:
:
GCReason
reason
int64_t
millis
)
{
if
(
millis
=
=
0
)
{
millis
=
defaultSliceBudgetMS
(
)
;
}
if
(
createBudgetCallback
)
{
return
createBudgetCallback
(
reason
millis
)
;
}
if
(
millis
=
=
0
)
{
return
SliceBudget
:
:
unlimited
(
)
;
}
return
SliceBudget
(
TimeBudget
(
millis
)
)
;
}
void
GCRuntime
:
:
gc
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
)
{
if
(
!
isIncrementalGCInProgress
(
)
)
{
setGCOptions
(
options
)
;
}
collect
(
true
SliceBudget
:
:
unlimited
(
)
reason
)
;
}
void
GCRuntime
:
:
startGC
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
const
js
:
:
SliceBudget
&
budget
)
{
MOZ_ASSERT
(
!
isIncrementalGCInProgress
(
)
)
;
setGCOptions
(
options
)
;
if
(
!
JS
:
:
IsIncrementalGCEnabled
(
rt
-
>
mainContextFromOwnThread
(
)
)
)
{
collect
(
true
SliceBudget
:
:
unlimited
(
)
reason
)
;
return
;
}
collect
(
false
budget
reason
)
;
}
void
GCRuntime
:
:
setGCOptions
(
JS
:
:
GCOptions
options
)
{
MOZ_ASSERT
(
maybeGcOptions
=
=
Nothing
(
)
)
;
maybeGcOptions
=
Some
(
options
)
;
}
void
GCRuntime
:
:
gcSlice
(
JS
:
:
GCReason
reason
const
js
:
:
SliceBudget
&
budget
)
{
MOZ_ASSERT
(
isIncrementalGCInProgress
(
)
)
;
collect
(
false
budget
reason
)
;
}
void
GCRuntime
:
:
finishGC
(
JS
:
:
GCReason
reason
)
{
MOZ_ASSERT
(
isIncrementalGCInProgress
(
)
)
;
if
(
!
IsOOMReason
(
initialReason
)
)
{
if
(
incrementalState
=
=
State
:
:
Compact
)
{
abortGC
(
)
;
return
;
}
isCompacting
=
false
;
}
collect
(
false
SliceBudget
:
:
unlimited
(
)
reason
)
;
}
void
GCRuntime
:
:
abortGC
(
)
{
MOZ_ASSERT
(
isIncrementalGCInProgress
(
)
)
;
checkCanCallAPI
(
)
;
MOZ_ASSERT
(
!
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
;
collect
(
false
SliceBudget
:
:
unlimited
(
)
JS
:
:
GCReason
:
:
ABORT_GC
)
;
}
static
bool
ZonesSelected
(
GCRuntime
*
gc
)
{
for
(
ZonesIter
zone
(
gc
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
isGCScheduled
(
)
)
{
return
true
;
}
}
return
false
;
}
void
GCRuntime
:
:
startDebugGC
(
JS
:
:
GCOptions
options
const
SliceBudget
&
budget
)
{
MOZ_ASSERT
(
!
isIncrementalGCInProgress
(
)
)
;
setGCOptions
(
options
)
;
if
(
!
ZonesSelected
(
this
)
)
{
JS
:
:
PrepareForFullGC
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
}
collect
(
false
budget
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
void
GCRuntime
:
:
debugGCSlice
(
const
SliceBudget
&
budget
)
{
MOZ_ASSERT
(
isIncrementalGCInProgress
(
)
)
;
if
(
!
ZonesSelected
(
this
)
)
{
JS
:
:
PrepareForIncrementalGC
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
}
collect
(
false
budget
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
void
js
:
:
PrepareForDebugGC
(
JSRuntime
*
rt
)
{
if
(
!
ZonesSelected
(
&
rt
-
>
gc
)
)
{
JS
:
:
PrepareForFullGC
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
}
}
void
GCRuntime
:
:
onOutOfMallocMemory
(
)
{
allocTask
.
cancelAndWait
(
)
;
decommitTask
.
join
(
)
;
nursery
(
)
.
joinDecommitTask
(
)
;
sweepTask
.
join
(
)
;
AutoLockGC
lock
(
this
)
;
onOutOfMallocMemory
(
lock
)
;
}
void
GCRuntime
:
:
onOutOfMallocMemory
(
const
AutoLockGC
&
lock
)
{
#
ifdef
DEBUG
releaseHeldRelocatedArenasWithoutUnlocking
(
lock
)
;
#
endif
freeEmptyChunks
(
lock
)
;
if
(
DecommitEnabled
(
)
)
{
decommitFreeArenasWithoutUnlocking
(
lock
)
;
}
}
void
GCRuntime
:
:
minorGC
(
JS
:
:
GCReason
reason
gcstats
:
:
PhaseKind
phase
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
MOZ_ASSERT_IF
(
reason
=
=
JS
:
:
GCReason
:
:
EVICT_NURSERY
!
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
;
if
(
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
{
return
;
}
incGcNumber
(
)
;
collectNursery
(
JS
:
:
GCOptions
:
:
Normal
reason
phase
)
;
#
ifdef
JS_GC_ZEAL
if
(
hasZealMode
(
ZealMode
:
:
CheckHeapAfterGC
)
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
phase
)
;
CheckHeapAfterGC
(
rt
)
;
}
#
endif
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
maybeTriggerGCAfterAlloc
(
zone
)
;
maybeTriggerGCAfterMalloc
(
zone
)
;
}
}
void
GCRuntime
:
:
collectNursery
(
JS
:
:
GCOptions
options
JS
:
:
GCReason
reason
gcstats
:
:
PhaseKind
phase
)
{
AutoMaybeLeaveAtomsZone
leaveAtomsZone
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
uint32_t
numAllocs
=
0
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
numAllocs
+
=
zone
-
>
getAndResetTenuredAllocsSinceMinorGC
(
)
;
}
stats
(
)
.
setAllocsSinceMinorGCTenured
(
numAllocs
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
phase
)
;
nursery
(
)
.
collect
(
options
reason
)
;
MOZ_ASSERT
(
nursery
(
)
.
isEmpty
(
)
)
;
startBackgroundFreeAfterMinorGC
(
)
;
}
void
GCRuntime
:
:
startBackgroundFreeAfterMinorGC
(
)
{
MOZ_ASSERT
(
nursery
(
)
.
isEmpty
(
)
)
;
{
AutoLockHelperThreadState
lock
;
lifoBlocksToFree
.
ref
(
)
.
transferFrom
(
&
lifoBlocksToFreeAfterMinorGC
.
ref
(
)
)
;
if
(
lifoBlocksToFree
.
ref
(
)
.
isEmpty
(
)
&
&
buffersToFreeAfterMinorGC
.
ref
(
)
.
empty
(
)
)
{
return
;
}
}
startBackgroundFree
(
)
;
}
bool
GCRuntime
:
:
gcIfRequestedImpl
(
bool
eagerOk
)
{
if
(
nursery
(
)
.
minorGCRequested
(
)
)
{
minorGC
(
nursery
(
)
.
minorGCTriggerReason
(
)
)
;
}
JS
:
:
GCReason
reason
=
wantMajorGC
(
eagerOk
)
;
if
(
reason
=
=
JS
:
:
GCReason
:
:
NO_REASON
)
{
return
false
;
}
SliceBudget
budget
=
defaultBudget
(
reason
0
)
;
if
(
!
isIncrementalGCInProgress
(
)
)
{
startGC
(
JS
:
:
GCOptions
:
:
Normal
reason
budget
)
;
}
else
{
gcSlice
(
reason
budget
)
;
}
return
true
;
}
void
js
:
:
gc
:
:
FinishGC
(
JSContext
*
cx
JS
:
:
GCReason
reason
)
{
MOZ_ASSERT
(
!
cx
-
>
suppressGC
)
;
MOZ_ASSERT
(
cx
-
>
isNurseryAllocAllowed
(
)
)
;
if
(
JS
:
:
IsIncrementalGCInProgress
(
cx
)
)
{
JS
:
:
PrepareForIncrementalGC
(
cx
)
;
JS
:
:
FinishIncrementalGC
(
cx
reason
)
;
}
}
void
js
:
:
gc
:
:
WaitForBackgroundTasks
(
JSContext
*
cx
)
{
cx
-
>
runtime
(
)
-
>
gc
.
waitForBackgroundTasks
(
)
;
}
void
GCRuntime
:
:
waitForBackgroundTasks
(
)
{
MOZ_ASSERT
(
!
isIncrementalGCInProgress
(
)
)
;
MOZ_ASSERT
(
sweepTask
.
isIdle
(
)
)
;
MOZ_ASSERT
(
decommitTask
.
isIdle
(
)
)
;
MOZ_ASSERT
(
markTask
.
isIdle
(
)
)
;
allocTask
.
join
(
)
;
freeTask
.
join
(
)
;
nursery
(
)
.
joinDecommitTask
(
)
;
}
Realm
*
js
:
:
NewRealm
(
JSContext
*
cx
JSPrincipals
*
principals
const
JS
:
:
RealmOptions
&
options
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
JS_AbortIfWrongThread
(
cx
)
;
UniquePtr
<
Zone
>
zoneHolder
;
UniquePtr
<
Compartment
>
compHolder
;
Compartment
*
comp
=
nullptr
;
Zone
*
zone
=
nullptr
;
JS
:
:
CompartmentSpecifier
compSpec
=
options
.
creationOptions
(
)
.
compartmentSpecifier
(
)
;
switch
(
compSpec
)
{
case
JS
:
:
CompartmentSpecifier
:
:
NewCompartmentInSystemZone
:
zone
=
rt
-
>
gc
.
systemZone
;
break
;
case
JS
:
:
CompartmentSpecifier
:
:
NewCompartmentInExistingZone
:
zone
=
options
.
creationOptions
(
)
.
zone
(
)
;
MOZ_ASSERT
(
zone
)
;
break
;
case
JS
:
:
CompartmentSpecifier
:
:
ExistingCompartment
:
comp
=
options
.
creationOptions
(
)
.
compartment
(
)
;
zone
=
comp
-
>
zone
(
)
;
break
;
case
JS
:
:
CompartmentSpecifier
:
:
NewCompartmentAndZone
:
break
;
}
if
(
!
zone
)
{
Zone
:
:
Kind
kind
=
Zone
:
:
NormalZone
;
const
JSPrincipals
*
trusted
=
rt
-
>
trustedPrincipals
(
)
;
if
(
compSpec
=
=
JS
:
:
CompartmentSpecifier
:
:
NewCompartmentInSystemZone
|
|
(
principals
&
&
principals
=
=
trusted
)
)
{
kind
=
Zone
:
:
SystemZone
;
}
zoneHolder
=
MakeUnique
<
Zone
>
(
cx
-
>
runtime
(
)
kind
)
;
if
(
!
zoneHolder
|
|
!
zoneHolder
-
>
init
(
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
zone
=
zoneHolder
.
get
(
)
;
}
bool
invisibleToDebugger
=
options
.
creationOptions
(
)
.
invisibleToDebugger
(
)
;
if
(
comp
)
{
MOZ_ASSERT
(
comp
-
>
invisibleToDebugger
(
)
=
=
invisibleToDebugger
)
;
}
else
{
compHolder
=
cx
-
>
make_unique
<
JS
:
:
Compartment
>
(
zone
invisibleToDebugger
)
;
if
(
!
compHolder
)
{
return
nullptr
;
}
comp
=
compHolder
.
get
(
)
;
}
UniquePtr
<
Realm
>
realm
(
cx
-
>
new_
<
Realm
>
(
comp
options
)
)
;
if
(
!
realm
)
{
return
nullptr
;
}
realm
-
>
init
(
cx
principals
)
;
if
(
!
compHolder
)
{
MOZ_RELEASE_ASSERT
(
realm
-
>
isSystem
(
)
=
=
IsSystemCompartment
(
comp
)
)
;
}
AutoLockGC
lock
(
rt
)
;
if
(
!
comp
-
>
realms
(
)
.
reserve
(
comp
-
>
realms
(
)
.
length
(
)
+
1
)
|
|
(
compHolder
&
&
!
zone
-
>
compartments
(
)
.
reserve
(
zone
-
>
compartments
(
)
.
length
(
)
+
1
)
)
|
|
(
zoneHolder
&
&
!
rt
-
>
gc
.
zones
(
)
.
reserve
(
rt
-
>
gc
.
zones
(
)
.
length
(
)
+
1
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
comp
-
>
realms
(
)
.
infallibleAppend
(
realm
.
get
(
)
)
;
if
(
compHolder
)
{
zone
-
>
compartments
(
)
.
infallibleAppend
(
compHolder
.
release
(
)
)
;
}
if
(
zoneHolder
)
{
rt
-
>
gc
.
zones
(
)
.
infallibleAppend
(
zoneHolder
.
release
(
)
)
;
if
(
compSpec
=
=
JS
:
:
CompartmentSpecifier
:
:
NewCompartmentInSystemZone
)
{
MOZ_RELEASE_ASSERT
(
!
rt
-
>
gc
.
systemZone
)
;
MOZ_ASSERT
(
zone
-
>
isSystemZone
(
)
)
;
rt
-
>
gc
.
systemZone
=
zone
;
}
}
return
realm
.
release
(
)
;
}
void
GCRuntime
:
:
runDebugGC
(
)
{
#
ifdef
JS_GC_ZEAL
if
(
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
{
return
;
}
if
(
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
)
{
return
minorGC
(
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
PrepareForDebugGC
(
rt
)
;
auto
budget
=
SliceBudget
:
:
unlimited
(
)
;
if
(
hasZealMode
(
ZealMode
:
:
IncrementalMultipleSlices
)
)
{
if
(
!
isIncrementalGCInProgress
(
)
)
{
zealSliceBudget
=
zealFrequency
/
2
;
}
else
{
zealSliceBudget
*
=
2
;
}
budget
=
SliceBudget
(
WorkBudget
(
zealSliceBudget
)
)
;
js
:
:
gc
:
:
State
initialState
=
incrementalState
;
if
(
!
isIncrementalGCInProgress
(
)
)
{
setGCOptions
(
JS
:
:
GCOptions
:
:
Shrink
)
;
}
collect
(
false
budget
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
if
(
(
initialState
=
=
State
:
:
Mark
&
&
incrementalState
=
=
State
:
:
Sweep
)
|
|
(
initialState
=
=
State
:
:
Sweep
&
&
incrementalState
=
=
State
:
:
Compact
)
)
{
zealSliceBudget
=
zealFrequency
/
2
;
}
}
else
if
(
hasIncrementalTwoSliceZealMode
(
)
)
{
budget
=
SliceBudget
(
WorkBudget
(
1
)
)
;
if
(
!
isIncrementalGCInProgress
(
)
)
{
setGCOptions
(
JS
:
:
GCOptions
:
:
Normal
)
;
}
collect
(
false
budget
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
else
if
(
hasZealMode
(
ZealMode
:
:
Compact
)
)
{
gc
(
JS
:
:
GCOptions
:
:
Shrink
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
else
{
gc
(
JS
:
:
GCOptions
:
:
Normal
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
#
endif
}
void
GCRuntime
:
:
setFullCompartmentChecks
(
bool
enabled
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsMajorCollecting
(
)
)
;
fullCompartmentChecks
=
enabled
;
}
void
GCRuntime
:
:
notifyRootsRemoved
(
)
{
rootsRemoved
=
true
;
#
ifdef
JS_GC_ZEAL
if
(
hasZealMode
(
ZealMode
:
:
RootsChange
)
)
{
nextScheduled
=
1
;
}
#
endif
}
#
ifdef
JS_GC_ZEAL
bool
GCRuntime
:
:
selectForMarking
(
JSObject
*
object
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsMajorCollecting
(
)
)
;
return
selectedForMarking
.
ref
(
)
.
get
(
)
.
append
(
object
)
;
}
void
GCRuntime
:
:
clearSelectedForMarking
(
)
{
selectedForMarking
.
ref
(
)
.
get
(
)
.
clearAndFree
(
)
;
}
void
GCRuntime
:
:
setDeterministic
(
bool
enabled
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsMajorCollecting
(
)
)
;
deterministicOnly
=
enabled
;
}
#
endif
#
ifdef
DEBUG
AutoAssertNoNurseryAlloc
:
:
AutoAssertNoNurseryAlloc
(
)
{
TlsContext
.
get
(
)
-
>
disallowNurseryAlloc
(
)
;
}
AutoAssertNoNurseryAlloc
:
:
~
AutoAssertNoNurseryAlloc
(
)
{
TlsContext
.
get
(
)
-
>
allowNurseryAlloc
(
)
;
}
#
endif
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
GCRuntime
:
:
checkHashTablesAfterMovingGC
(
)
{
rt
-
>
geckoProfiler
(
)
.
checkStringsMapAfterMovingGC
(
)
;
if
(
rt
-
>
hasJitRuntime
(
)
&
&
rt
-
>
jitRuntime
(
)
-
>
hasInterpreterEntryMap
(
)
)
{
rt
-
>
jitRuntime
(
)
-
>
getInterpreterEntryMap
(
)
-
>
checkScriptsAfterMovingGC
(
)
;
}
for
(
ZonesIter
zone
(
this
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
checkUniqueIdTableAfterMovingGC
(
)
;
zone
-
>
shapeZone
(
)
.
checkTablesAfterMovingGC
(
)
;
zone
-
>
checkAllCrossCompartmentWrappersAfterMovingGC
(
)
;
zone
-
>
checkScriptMapsAfterMovingGC
(
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
for
(
auto
map
=
zone
-
>
cellIterUnsafe
<
NormalPropMap
>
(
)
;
!
map
.
done
(
)
;
map
.
next
(
)
)
{
if
(
PropMapTable
*
table
=
map
-
>
asLinked
(
)
-
>
maybeTable
(
nogc
)
)
{
table
-
>
checkAfterMovingGC
(
)
;
}
}
for
(
auto
map
=
zone
-
>
cellIterUnsafe
<
DictionaryPropMap
>
(
)
;
!
map
.
done
(
)
;
map
.
next
(
)
)
{
if
(
PropMapTable
*
table
=
map
-
>
asLinked
(
)
-
>
maybeTable
(
nogc
)
)
{
table
-
>
checkAfterMovingGC
(
)
;
}
}
}
for
(
CompartmentsIter
c
(
this
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
for
(
RealmsInCompartmentIter
r
(
c
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
r
-
>
dtoaCache
.
checkCacheAfterMovingGC
(
)
;
if
(
r
-
>
debugEnvs
(
)
)
{
r
-
>
debugEnvs
(
)
-
>
checkHashTablesAfterMovingGC
(
)
;
}
}
}
}
#
endif
#
ifdef
DEBUG
bool
GCRuntime
:
:
hasZone
(
Zone
*
target
)
{
for
(
AllZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
=
=
target
)
{
return
true
;
}
}
return
false
;
}
#
endif
void
AutoAssertEmptyNursery
:
:
checkCondition
(
JSContext
*
cx
)
{
if
(
!
noAlloc
)
{
noAlloc
.
emplace
(
)
;
}
this
-
>
cx
=
cx
;
MOZ_ASSERT
(
cx
-
>
nursery
(
)
.
isEmpty
(
)
)
;
}
AutoEmptyNursery
:
:
AutoEmptyNursery
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
!
cx
-
>
suppressGC
)
;
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
suspendPhases
(
)
;
cx
-
>
runtime
(
)
-
>
gc
.
evictNursery
(
JS
:
:
GCReason
:
:
EVICT_NURSERY
)
;
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
resumePhases
(
)
;
checkCondition
(
cx
)
;
}
#
ifdef
DEBUG
namespace
js
{
extern
JS_PUBLIC_API
void
DumpString
(
JSString
*
str
js
:
:
GenericPrinter
&
out
)
;
}
void
js
:
:
gc
:
:
Cell
:
:
dump
(
js
:
:
GenericPrinter
&
out
)
const
{
switch
(
getTraceKind
(
)
)
{
case
JS
:
:
TraceKind
:
:
Object
:
reinterpret_cast
<
const
JSObject
*
>
(
this
)
-
>
dump
(
out
)
;
break
;
case
JS
:
:
TraceKind
:
:
String
:
js
:
:
DumpString
(
reinterpret_cast
<
JSString
*
>
(
const_cast
<
Cell
*
>
(
this
)
)
out
)
;
break
;
case
JS
:
:
TraceKind
:
:
Shape
:
reinterpret_cast
<
const
Shape
*
>
(
this
)
-
>
dump
(
out
)
;
break
;
default
:
out
.
printf
(
"
%
s
(
%
p
)
\
n
"
JS
:
:
GCTraceKindToAscii
(
getTraceKind
(
)
)
(
void
*
)
this
)
;
}
}
void
js
:
:
gc
:
:
Cell
:
:
dump
(
)
const
{
js
:
:
Fprinter
out
(
stderr
)
;
dump
(
out
)
;
}
#
endif
JS_PUBLIC_API
bool
js
:
:
gc
:
:
detail
:
:
CanCheckGrayBits
(
const
TenuredCell
*
cell
)
{
MOZ_ASSERT
(
cell
)
;
auto
*
runtime
=
cell
-
>
runtimeFromAnyThread
(
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime
)
)
;
if
(
!
runtime
-
>
gc
.
areGrayBitsValid
(
)
)
{
return
false
;
}
JS
:
:
Zone
*
zone
=
cell
-
>
zone
(
)
;
if
(
runtime
-
>
gc
.
isIncrementalGCInProgress
(
)
&
&
!
zone
-
>
wasGCStarted
(
)
)
{
return
false
;
}
return
!
zone
-
>
isGCPreparing
(
)
;
}
JS_PUBLIC_API
bool
js
:
:
gc
:
:
detail
:
:
CellIsMarkedGrayIfKnown
(
const
TenuredCell
*
cell
)
{
MOZ_ASSERT_IF
(
cell
-
>
isPermanentAndMayBeShared
(
)
cell
-
>
isMarkedBlack
(
)
)
;
if
(
!
cell
-
>
isMarkedGray
(
)
)
{
return
false
;
}
return
CanCheckGrayBits
(
cell
)
;
}
#
ifdef
DEBUG
JS_PUBLIC_API
void
js
:
:
gc
:
:
detail
:
:
AssertCellIsNotGray
(
const
Cell
*
cell
)
{
if
(
!
cell
-
>
isTenured
(
)
)
{
return
;
}
const
auto
*
tc
=
&
cell
-
>
asTenured
(
)
;
if
(
!
tc
-
>
isMarkedGray
(
)
|
|
!
CanCheckGrayBits
(
tc
)
)
{
return
;
}
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsCycleCollecting
(
)
)
;
if
(
tc
-
>
zone
(
)
-
>
isGCMarkingBlackAndGray
(
)
)
{
if
(
!
tc
-
>
isMarkedBlack
(
)
)
{
JSRuntime
*
rt
=
tc
-
>
zone
(
)
-
>
runtimeFromMainThread
(
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
rt
-
>
gc
.
cellsToAssertNotGray
.
ref
(
)
.
append
(
cell
)
)
{
oomUnsafe
.
crash
(
"
Can
'
t
append
to
delayed
gray
checks
list
"
)
;
}
}
return
;
}
MOZ_ASSERT
(
!
tc
-
>
isMarkedGray
(
)
)
;
}
extern
JS_PUBLIC_API
bool
js
:
:
gc
:
:
detail
:
:
ObjectIsMarkedBlack
(
const
JSObject
*
obj
)
{
return
obj
-
>
isMarkedBlack
(
)
;
}
#
endif
js
:
:
gc
:
:
ClearEdgesTracer
:
:
ClearEdgesTracer
(
JSRuntime
*
rt
)
:
GenericTracerImpl
(
rt
JS
:
:
TracerKind
:
:
ClearEdges
JS
:
:
WeakMapTraceAction
:
:
TraceKeysAndValues
)
{
}
template
<
typename
T
>
void
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onEdge
(
T
*
*
thingp
const
char
*
name
)
{
T
*
thing
=
*
thingp
;
MOZ_ASSERT
(
!
IsInsideNursery
(
thing
)
)
;
InternalBarrierMethods
<
T
*
>
:
:
preBarrier
(
thing
)
;
*
thingp
=
nullptr
;
}
void
GCRuntime
:
:
setPerformanceHint
(
PerformanceHint
hint
)
{
if
(
hint
=
=
PerformanceHint
:
:
InPageLoad
)
{
inPageLoadCount
+
+
;
}
else
{
MOZ_ASSERT
(
inPageLoadCount
)
;
inPageLoadCount
-
-
;
}
}
