#
include
"
gc
/
GC
-
inl
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
MacroForEach
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
algorithm
>
#
include
<
initializer_list
>
#
include
<
string
.
h
>
#
ifndef
XP_WIN
#
include
<
sys
/
mman
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
builtin
/
FinalizationGroupObject
.
h
"
#
include
"
debugger
/
DebugAPI
.
h
"
#
include
"
gc
/
FindSCCs
.
h
"
#
include
"
gc
/
FreeOp
.
h
"
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
gc
/
GCLock
.
h
"
#
include
"
gc
/
GCTrace
.
h
"
#
include
"
gc
/
Memory
.
h
"
#
include
"
gc
/
Policy
.
h
"
#
include
"
gc
/
WeakMap
.
h
"
#
include
"
jit
/
BaselineJIT
.
h
"
#
include
"
jit
/
IonCode
.
h
"
#
include
"
jit
/
JitcodeMap
.
h
"
#
include
"
jit
/
JitRealm
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
proxy
/
DeadObjectProxy
.
h
"
#
include
"
util
/
Poison
.
h
"
#
include
"
util
/
Windows
.
h
"
#
include
"
vm
/
BigIntType
.
h
"
#
include
"
vm
/
GeckoProfiler
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Printer
.
h
"
#
include
"
vm
/
ProxyObject
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
Shape
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
SymbolType
.
h
"
#
include
"
vm
/
Time
.
h
"
#
include
"
vm
/
TraceLogging
.
h
"
#
include
"
vm
/
WrapperObject
.
h
"
#
include
"
gc
/
Heap
-
inl
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
gc
/
Nursery
-
inl
.
h
"
#
include
"
gc
/
PrivateIterators
-
inl
.
h
"
#
include
"
gc
/
Zone
-
inl
.
h
"
#
include
"
vm
/
GeckoProfiler
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
JSScript
-
inl
.
h
"
#
include
"
vm
/
Stack
-
inl
.
h
"
#
include
"
vm
/
StringType
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
mozilla
:
:
ArrayLength
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
using
mozilla
:
:
Swap
;
using
mozilla
:
:
TimeDuration
;
using
mozilla
:
:
TimeStamp
;
using
JS
:
:
AutoGCRooter
;
static
constexpr
int
IGC_MARK_SLICE_MULTIPLIER
=
2
;
const
AllocKind
gc
:
:
slotsToThingKind
[
]
=
{
AllocKind
:
:
OBJECT0
AllocKind
:
:
OBJECT2
AllocKind
:
:
OBJECT2
AllocKind
:
:
OBJECT4
AllocKind
:
:
OBJECT4
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT16
AllocKind
:
:
OBJECT16
AllocKind
:
:
OBJECT16
AllocKind
:
:
OBJECT16
}
;
static_assert
(
js
:
:
detail
:
:
LIFO_ALLOC_ALIGN
>
BitMask
(
Cell
:
:
ReservedBits
)
"
Cell
:
:
ReservedBits
should
support
LifoAlloc
"
)
;
static_assert
(
CellAlignBytes
>
BitMask
(
Cell
:
:
ReservedBits
)
"
Cell
:
:
ReservedBits
should
support
gc
:
:
Cell
"
)
;
static_assert
(
sizeof
(
uintptr_t
)
>
BitMask
(
Cell
:
:
ReservedBits
)
"
Cell
:
:
ReservedBits
should
support
small
malloc
/
aligned
globals
"
)
;
static_assert
(
js
:
:
jit
:
:
CodeAlignment
>
BitMask
(
Cell
:
:
ReservedBits
)
"
Cell
:
:
ReservedBits
should
support
JIT
code
"
)
;
static_assert
(
mozilla
:
:
ArrayLength
(
slotsToThingKind
)
=
=
SLOTS_TO_THING_KIND_LIMIT
"
We
have
defined
a
slot
count
for
each
kind
.
"
)
;
#
define
CHECK_THING_SIZE
(
allocKind
traceKind
type
sizedType
bgFinal
\
nursery
compact
)
\
static_assert
(
sizeof
(
sizedType
)
>
=
SortedArenaList
:
:
MinThingSize
\
#
sizedType
"
is
smaller
than
SortedArenaList
:
:
MinThingSize
!
"
)
;
\
static_assert
(
sizeof
(
sizedType
)
>
=
sizeof
(
FreeSpan
)
\
#
sizedType
"
is
smaller
than
FreeSpan
"
)
;
\
static_assert
(
sizeof
(
sizedType
)
%
CellAlignBytes
=
=
0
\
"
Size
of
"
#
sizedType
"
is
not
a
multiple
of
CellAlignBytes
"
)
;
\
static_assert
(
sizeof
(
sizedType
)
>
=
MinCellSize
\
"
Size
of
"
#
sizedType
"
is
smaller
than
the
minimum
size
"
)
;
FOR_EACH_ALLOCKIND
(
CHECK_THING_SIZE
)
;
#
undef
CHECK_THING_SIZE
const
uint32_t
Arena
:
:
ThingSizes
[
]
=
{
#
define
EXPAND_THING_SIZE
(
allocKind
traceKind
type
sizedType
bgFinal
\
nursery
compact
)
\
sizeof
(
sizedType
)
FOR_EACH_ALLOCKIND
(
EXPAND_THING_SIZE
)
#
undef
EXPAND_THING_SIZE
}
;
FreeSpan
FreeLists
:
:
emptySentinel
;
#
undef
CHECK_THING_SIZE_INNER
#
undef
CHECK_THING_SIZE
#
define
OFFSET
(
type
)
\
uint32_t
(
ArenaHeaderSize
+
(
ArenaSize
-
ArenaHeaderSize
)
%
sizeof
(
type
)
)
const
uint32_t
Arena
:
:
FirstThingOffsets
[
]
=
{
#
define
EXPAND_FIRST_THING_OFFSET
(
allocKind
traceKind
type
sizedType
\
bgFinal
nursery
compact
)
\
OFFSET
(
sizedType
)
FOR_EACH_ALLOCKIND
(
EXPAND_FIRST_THING_OFFSET
)
#
undef
EXPAND_FIRST_THING_OFFSET
}
;
#
undef
OFFSET
#
define
COUNT
(
type
)
uint32_t
(
(
ArenaSize
-
ArenaHeaderSize
)
/
sizeof
(
type
)
)
const
uint32_t
Arena
:
:
ThingsPerArena
[
]
=
{
#
define
EXPAND_THINGS_PER_ARENA
(
allocKind
traceKind
type
sizedType
\
bgFinal
nursery
compact
)
\
COUNT
(
sizedType
)
FOR_EACH_ALLOCKIND
(
EXPAND_THINGS_PER_ARENA
)
#
undef
EXPAND_THINGS_PER_ARENA
}
;
#
undef
COUNT
struct
js
:
:
gc
:
:
FinalizePhase
{
gcstats
:
:
PhaseKind
statsPhase
;
AllocKinds
kinds
;
}
;
static
constexpr
FinalizePhase
ForegroundObjectFinalizePhase
=
{
gcstats
:
:
PhaseKind
:
:
SWEEP_OBJECT
{
AllocKind
:
:
OBJECT0
AllocKind
:
:
OBJECT2
AllocKind
:
:
OBJECT4
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT16
}
}
;
static
constexpr
FinalizePhase
ForegroundNonObjectFinalizePhase
=
{
gcstats
:
:
PhaseKind
:
:
SWEEP_SCRIPT
{
AllocKind
:
:
SCRIPT
AllocKind
:
:
JITCODE
}
}
;
static
constexpr
FinalizePhase
BackgroundFinalizePhases
[
]
=
{
{
gcstats
:
:
PhaseKind
:
:
SWEEP_SCRIPT
{
AllocKind
:
:
LAZY_SCRIPT
}
}
{
gcstats
:
:
PhaseKind
:
:
SWEEP_OBJECT
{
AllocKind
:
:
FUNCTION
AllocKind
:
:
FUNCTION_EXTENDED
AllocKind
:
:
OBJECT0_BACKGROUND
AllocKind
:
:
OBJECT2_BACKGROUND
AllocKind
:
:
ARRAYBUFFER4
AllocKind
:
:
OBJECT4_BACKGROUND
AllocKind
:
:
ARRAYBUFFER8
AllocKind
:
:
OBJECT8_BACKGROUND
AllocKind
:
:
ARRAYBUFFER12
AllocKind
:
:
OBJECT12_BACKGROUND
AllocKind
:
:
ARRAYBUFFER16
AllocKind
:
:
OBJECT16_BACKGROUND
}
}
{
gcstats
:
:
PhaseKind
:
:
SWEEP_SCOPE
{
AllocKind
:
:
SCOPE
}
}
{
gcstats
:
:
PhaseKind
:
:
SWEEP_REGEXP_SHARED
{
AllocKind
:
:
REGEXP_SHARED
}
}
{
gcstats
:
:
PhaseKind
:
:
SWEEP_STRING
{
AllocKind
:
:
FAT_INLINE_STRING
AllocKind
:
:
STRING
AllocKind
:
:
EXTERNAL_STRING
AllocKind
:
:
FAT_INLINE_ATOM
AllocKind
:
:
ATOM
AllocKind
:
:
SYMBOL
AllocKind
:
:
BIGINT
}
}
{
gcstats
:
:
PhaseKind
:
:
SWEEP_SHAPE
{
AllocKind
:
:
SHAPE
AllocKind
:
:
ACCESSOR_SHAPE
AllocKind
:
:
BASE_SHAPE
AllocKind
:
:
OBJECT_GROUP
}
}
}
;
void
Arena
:
:
unmarkAll
(
)
{
uintptr_t
*
word
=
chunk
(
)
-
>
bitmap
.
arenaBits
(
this
)
;
memset
(
word
0
ArenaBitmapWords
*
sizeof
(
uintptr_t
)
)
;
}
void
Arena
:
:
unmarkPreMarkedFreeCells
(
)
{
for
(
ArenaFreeCellIter
iter
(
this
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
TenuredCell
*
cell
=
iter
.
getCell
(
)
;
MOZ_ASSERT
(
cell
-
>
isMarkedBlack
(
)
)
;
cell
-
>
unmark
(
)
;
}
}
#
ifdef
DEBUG
void
Arena
:
:
checkNoMarkedFreeCells
(
)
{
for
(
ArenaFreeCellIter
iter
(
this
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
MOZ_ASSERT
(
!
iter
.
getCell
(
)
-
>
isMarkedAny
(
)
)
;
}
}
#
endif
void
Arena
:
:
staticAsserts
(
)
{
static_assert
(
size_t
(
AllocKind
:
:
LIMIT
)
<
=
255
"
We
must
be
able
to
fit
the
allockind
into
uint8_t
.
"
)
;
static_assert
(
mozilla
:
:
ArrayLength
(
ThingSizes
)
=
=
size_t
(
AllocKind
:
:
LIMIT
)
"
We
haven
'
t
defined
all
thing
sizes
.
"
)
;
static_assert
(
mozilla
:
:
ArrayLength
(
FirstThingOffsets
)
=
=
size_t
(
AllocKind
:
:
LIMIT
)
"
We
haven
'
t
defined
all
offsets
.
"
)
;
static_assert
(
mozilla
:
:
ArrayLength
(
ThingsPerArena
)
=
=
size_t
(
AllocKind
:
:
LIMIT
)
"
We
haven
'
t
defined
all
counts
.
"
)
;
}
template
<
typename
T
>
inline
size_t
Arena
:
:
finalize
(
JSFreeOp
*
fop
AllocKind
thingKind
size_t
thingSize
)
{
MOZ_ASSERT
(
thingSize
%
CellAlignBytes
=
=
0
)
;
MOZ_ASSERT
(
thingSize
>
=
MinCellSize
)
;
MOZ_ASSERT
(
thingSize
<
=
255
)
;
MOZ_ASSERT
(
allocated
(
)
)
;
MOZ_ASSERT
(
thingKind
=
=
getAllocKind
(
)
)
;
MOZ_ASSERT
(
thingSize
=
=
getThingSize
(
)
)
;
MOZ_ASSERT
(
!
onDelayedMarkingList_
)
;
uint_fast16_t
firstThing
=
firstThingOffset
(
thingKind
)
;
uint_fast16_t
firstThingOrSuccessorOfLastMarkedThing
=
firstThing
;
uint_fast16_t
lastThing
=
ArenaSize
-
thingSize
;
FreeSpan
newListHead
;
FreeSpan
*
newListTail
=
&
newListHead
;
size_t
nmarked
=
0
;
for
(
ArenaCellIterUnderFinalize
i
(
this
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
T
*
t
=
i
.
get
<
T
>
(
)
;
if
(
t
-
>
asTenured
(
)
.
isMarkedAny
(
)
)
{
uint_fast16_t
thing
=
uintptr_t
(
t
)
&
ArenaMask
;
if
(
thing
!
=
firstThingOrSuccessorOfLastMarkedThing
)
{
newListTail
-
>
initBounds
(
firstThingOrSuccessorOfLastMarkedThing
thing
-
thingSize
this
)
;
newListTail
=
newListTail
-
>
nextSpanUnchecked
(
this
)
;
}
firstThingOrSuccessorOfLastMarkedThing
=
thing
+
thingSize
;
nmarked
+
+
;
}
else
{
t
-
>
finalize
(
fop
)
;
AlwaysPoison
(
t
JS_SWEPT_TENURED_PATTERN
thingSize
MemCheckKind
:
:
MakeUndefined
)
;
gcTracer
.
traceTenuredFinalize
(
t
)
;
}
}
if
(
nmarked
=
=
0
)
{
MOZ_ASSERT
(
newListTail
=
=
&
newListHead
)
;
DebugOnlyPoison
(
data
JS_SWEPT_TENURED_PATTERN
sizeof
(
data
)
MemCheckKind
:
:
MakeUndefined
)
;
return
nmarked
;
}
MOZ_ASSERT
(
firstThingOrSuccessorOfLastMarkedThing
!
=
firstThing
)
;
uint_fast16_t
lastMarkedThing
=
firstThingOrSuccessorOfLastMarkedThing
-
thingSize
;
if
(
lastThing
=
=
lastMarkedThing
)
{
newListTail
-
>
initAsEmpty
(
)
;
}
else
{
newListTail
-
>
initFinal
(
firstThingOrSuccessorOfLastMarkedThing
lastThing
this
)
;
}
firstFreeSpan
=
newListHead
;
#
ifdef
DEBUG
size_t
nfree
=
numFreeThings
(
thingSize
)
;
MOZ_ASSERT
(
nfree
+
nmarked
=
=
thingsPerArena
(
thingKind
)
)
;
#
endif
return
nmarked
;
}
template
<
typename
T
>
static
inline
bool
FinalizeTypedArenas
(
JSFreeOp
*
fop
Arena
*
*
src
SortedArenaList
&
dest
AllocKind
thingKind
SliceBudget
&
budget
)
{
Maybe
<
AutoLockGC
>
maybeLock
;
if
(
fop
-
>
onMainThread
(
)
)
{
maybeLock
.
emplace
(
fop
-
>
runtime
(
)
)
;
}
size_t
thingSize
=
Arena
:
:
thingSize
(
thingKind
)
;
size_t
thingsPerArena
=
Arena
:
:
thingsPerArena
(
thingKind
)
;
while
(
Arena
*
arena
=
*
src
)
{
*
src
=
arena
-
>
next
;
size_t
nmarked
=
arena
-
>
finalize
<
T
>
(
fop
thingKind
thingSize
)
;
size_t
nfree
=
thingsPerArena
-
nmarked
;
if
(
nmarked
)
{
dest
.
insertAt
(
arena
nfree
)
;
}
else
{
arena
-
>
chunk
(
)
-
>
recycleArena
(
arena
dest
thingsPerArena
)
;
}
budget
.
step
(
thingsPerArena
)
;
if
(
budget
.
isOverBudget
(
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
FinalizeArenas
(
JSFreeOp
*
fop
Arena
*
*
src
SortedArenaList
&
dest
AllocKind
thingKind
SliceBudget
&
budget
)
{
switch
(
thingKind
)
{
#
define
EXPAND_CASE
(
allocKind
traceKind
type
sizedType
bgFinal
nursery
\
compact
)
\
case
AllocKind
:
:
allocKind
:
\
return
FinalizeTypedArenas
<
type
>
(
fop
src
dest
thingKind
budget
)
;
FOR_EACH_ALLOCKIND
(
EXPAND_CASE
)
#
undef
EXPAND_CASE
default
:
MOZ_CRASH
(
"
Invalid
alloc
kind
"
)
;
}
}
Chunk
*
ChunkPool
:
:
pop
(
)
{
MOZ_ASSERT
(
bool
(
head_
)
=
=
bool
(
count_
)
)
;
if
(
!
count_
)
{
return
nullptr
;
}
return
remove
(
head_
)
;
}
void
ChunkPool
:
:
push
(
Chunk
*
chunk
)
{
MOZ_ASSERT
(
!
chunk
-
>
info
.
next
)
;
MOZ_ASSERT
(
!
chunk
-
>
info
.
prev
)
;
chunk
-
>
info
.
next
=
head_
;
if
(
head_
)
{
head_
-
>
info
.
prev
=
chunk
;
}
head_
=
chunk
;
+
+
count_
;
}
Chunk
*
ChunkPool
:
:
remove
(
Chunk
*
chunk
)
{
MOZ_ASSERT
(
count_
>
0
)
;
MOZ_ASSERT
(
contains
(
chunk
)
)
;
if
(
head_
=
=
chunk
)
{
head_
=
chunk
-
>
info
.
next
;
}
if
(
chunk
-
>
info
.
prev
)
{
chunk
-
>
info
.
prev
-
>
info
.
next
=
chunk
-
>
info
.
next
;
}
if
(
chunk
-
>
info
.
next
)
{
chunk
-
>
info
.
next
-
>
info
.
prev
=
chunk
-
>
info
.
prev
;
}
chunk
-
>
info
.
next
=
chunk
-
>
info
.
prev
=
nullptr
;
-
-
count_
;
return
chunk
;
}
void
ChunkPool
:
:
sort
(
)
{
if
(
!
isSorted
(
)
)
{
head_
=
mergeSort
(
head
(
)
count
(
)
)
;
Chunk
*
prev
=
nullptr
;
for
(
Chunk
*
cur
=
head_
;
cur
;
cur
=
cur
-
>
info
.
next
)
{
cur
-
>
info
.
prev
=
prev
;
prev
=
cur
;
}
}
MOZ_ASSERT
(
verify
(
)
)
;
MOZ_ASSERT
(
isSorted
(
)
)
;
}
Chunk
*
ChunkPool
:
:
mergeSort
(
Chunk
*
list
size_t
count
)
{
MOZ_ASSERT
(
bool
(
list
)
=
=
bool
(
count
)
)
;
if
(
count
<
2
)
{
return
list
;
}
size_t
half
=
count
/
2
;
Chunk
*
front
=
list
;
Chunk
*
back
;
{
Chunk
*
cur
=
list
;
for
(
size_t
i
=
0
;
i
<
half
-
1
;
i
+
+
)
{
MOZ_ASSERT
(
cur
)
;
cur
=
cur
-
>
info
.
next
;
}
back
=
cur
-
>
info
.
next
;
cur
-
>
info
.
next
=
nullptr
;
}
front
=
mergeSort
(
front
half
)
;
back
=
mergeSort
(
back
count
-
half
)
;
list
=
nullptr
;
Chunk
*
*
cur
=
&
list
;
while
(
front
|
|
back
)
{
if
(
!
front
)
{
*
cur
=
back
;
break
;
}
if
(
!
back
)
{
*
cur
=
front
;
break
;
}
if
(
front
-
>
info
.
numArenasFree
<
=
back
-
>
info
.
numArenasFree
)
{
*
cur
=
front
;
front
=
front
-
>
info
.
next
;
cur
=
&
(
*
cur
)
-
>
info
.
next
;
}
else
{
*
cur
=
back
;
back
=
back
-
>
info
.
next
;
cur
=
&
(
*
cur
)
-
>
info
.
next
;
}
}
return
list
;
}
bool
ChunkPool
:
:
isSorted
(
)
const
{
uint32_t
last
=
1
;
for
(
Chunk
*
cursor
=
head_
;
cursor
;
cursor
=
cursor
-
>
info
.
next
)
{
if
(
cursor
-
>
info
.
numArenasFree
<
last
)
{
return
false
;
}
last
=
cursor
-
>
info
.
numArenasFree
;
}
return
true
;
}
#
ifdef
DEBUG
bool
ChunkPool
:
:
contains
(
Chunk
*
chunk
)
const
{
verify
(
)
;
for
(
Chunk
*
cursor
=
head_
;
cursor
;
cursor
=
cursor
-
>
info
.
next
)
{
if
(
cursor
=
=
chunk
)
{
return
true
;
}
}
return
false
;
}
bool
ChunkPool
:
:
verify
(
)
const
{
MOZ_ASSERT
(
bool
(
head_
)
=
=
bool
(
count_
)
)
;
uint32_t
count
=
0
;
for
(
Chunk
*
cursor
=
head_
;
cursor
;
cursor
=
cursor
-
>
info
.
next
+
+
count
)
{
MOZ_ASSERT_IF
(
cursor
-
>
info
.
prev
cursor
-
>
info
.
prev
-
>
info
.
next
=
=
cursor
)
;
MOZ_ASSERT_IF
(
cursor
-
>
info
.
next
cursor
-
>
info
.
next
-
>
info
.
prev
=
=
cursor
)
;
}
MOZ_ASSERT
(
count_
=
=
count
)
;
return
true
;
}
#
endif
void
ChunkPool
:
:
Iter
:
:
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
current_
=
current_
-
>
info
.
next
;
}
ChunkPool
GCRuntime
:
:
expireEmptyChunkPool
(
const
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
emptyChunks
(
lock
)
.
verify
(
)
)
;
MOZ_ASSERT
(
tunables
.
minEmptyChunkCount
(
lock
)
<
=
tunables
.
maxEmptyChunkCount
(
)
)
;
ChunkPool
expired
;
while
(
emptyChunks
(
lock
)
.
count
(
)
>
tunables
.
minEmptyChunkCount
(
lock
)
)
{
Chunk
*
chunk
=
emptyChunks
(
lock
)
.
pop
(
)
;
prepareToFreeChunk
(
chunk
-
>
info
)
;
expired
.
push
(
chunk
)
;
}
MOZ_ASSERT
(
expired
.
verify
(
)
)
;
MOZ_ASSERT
(
emptyChunks
(
lock
)
.
verify
(
)
)
;
MOZ_ASSERT
(
emptyChunks
(
lock
)
.
count
(
)
<
=
tunables
.
maxEmptyChunkCount
(
)
)
;
MOZ_ASSERT
(
emptyChunks
(
lock
)
.
count
(
)
<
=
tunables
.
minEmptyChunkCount
(
lock
)
)
;
return
expired
;
}
static
void
FreeChunkPool
(
ChunkPool
&
pool
)
{
for
(
ChunkPool
:
:
Iter
iter
(
pool
)
;
!
iter
.
done
(
)
;
)
{
Chunk
*
chunk
=
iter
.
get
(
)
;
iter
.
next
(
)
;
pool
.
remove
(
chunk
)
;
MOZ_ASSERT
(
!
chunk
-
>
info
.
numArenasFreeCommitted
)
;
UnmapPages
(
static_cast
<
void
*
>
(
chunk
)
ChunkSize
)
;
}
MOZ_ASSERT
(
pool
.
count
(
)
=
=
0
)
;
}
void
GCRuntime
:
:
freeEmptyChunks
(
const
AutoLockGC
&
lock
)
{
FreeChunkPool
(
emptyChunks
(
lock
)
)
;
}
inline
void
GCRuntime
:
:
prepareToFreeChunk
(
ChunkInfo
&
info
)
{
MOZ_ASSERT
(
numArenasFreeCommitted
>
=
info
.
numArenasFreeCommitted
)
;
numArenasFreeCommitted
-
=
info
.
numArenasFreeCommitted
;
stats
(
)
.
count
(
gcstats
:
:
COUNT_DESTROY_CHUNK
)
;
#
ifdef
DEBUG
info
.
numArenasFreeCommitted
=
0
;
#
endif
}
inline
void
GCRuntime
:
:
updateOnArenaFree
(
)
{
+
+
numArenasFreeCommitted
;
}
void
Chunk
:
:
addArenaToFreeList
(
GCRuntime
*
gc
Arena
*
arena
)
{
MOZ_ASSERT
(
!
arena
-
>
allocated
(
)
)
;
arena
-
>
next
=
info
.
freeArenasHead
;
info
.
freeArenasHead
=
arena
;
+
+
info
.
numArenasFreeCommitted
;
+
+
info
.
numArenasFree
;
gc
-
>
updateOnArenaFree
(
)
;
}
void
Chunk
:
:
addArenaToDecommittedList
(
const
Arena
*
arena
)
{
+
+
info
.
numArenasFree
;
decommittedArenas
.
set
(
Chunk
:
:
arenaIndex
(
arena
-
>
address
(
)
)
)
;
}
void
Chunk
:
:
recycleArena
(
Arena
*
arena
SortedArenaList
&
dest
size_t
thingsPerArena
)
{
arena
-
>
setAsFullyUnused
(
)
;
dest
.
insertAt
(
arena
thingsPerArena
)
;
}
void
Chunk
:
:
releaseArena
(
GCRuntime
*
gc
Arena
*
arena
const
AutoLockGC
&
lock
)
{
addArenaToFreeList
(
gc
arena
)
;
updateChunkListAfterFree
(
gc
lock
)
;
}
bool
Chunk
:
:
decommitOneFreeArena
(
GCRuntime
*
gc
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
info
.
numArenasFreeCommitted
>
0
)
;
Arena
*
arena
=
fetchNextFreeArena
(
gc
)
;
updateChunkListAfterAlloc
(
gc
lock
)
;
bool
ok
;
{
AutoUnlockGC
unlock
(
lock
)
;
ok
=
MarkPagesUnusedSoft
(
arena
ArenaSize
)
;
}
if
(
ok
)
{
addArenaToDecommittedList
(
arena
)
;
}
else
{
addArenaToFreeList
(
gc
arena
)
;
}
updateChunkListAfterFree
(
gc
lock
)
;
return
ok
;
}
void
Chunk
:
:
decommitFreeArenasWithoutUnlocking
(
const
AutoLockGC
&
lock
)
{
for
(
size_t
i
=
0
;
i
<
ArenasPerChunk
;
+
+
i
)
{
if
(
decommittedArenas
.
get
(
i
)
|
|
arenas
[
i
]
.
allocated
(
)
)
{
continue
;
}
if
(
MarkPagesUnusedSoft
(
&
arenas
[
i
]
ArenaSize
)
)
{
info
.
numArenasFreeCommitted
-
-
;
decommittedArenas
.
set
(
i
)
;
}
}
}
void
Chunk
:
:
updateChunkListAfterAlloc
(
GCRuntime
*
gc
const
AutoLockGC
&
lock
)
{
if
(
MOZ_UNLIKELY
(
!
hasAvailableArenas
(
)
)
)
{
gc
-
>
availableChunks
(
lock
)
.
remove
(
this
)
;
gc
-
>
fullChunks
(
lock
)
.
push
(
this
)
;
}
}
void
Chunk
:
:
updateChunkListAfterFree
(
GCRuntime
*
gc
const
AutoLockGC
&
lock
)
{
if
(
info
.
numArenasFree
=
=
1
)
{
gc
-
>
fullChunks
(
lock
)
.
remove
(
this
)
;
gc
-
>
availableChunks
(
lock
)
.
push
(
this
)
;
}
else
if
(
!
unused
(
)
)
{
MOZ_ASSERT
(
gc
-
>
availableChunks
(
lock
)
.
contains
(
this
)
)
;
}
else
{
MOZ_ASSERT
(
unused
(
)
)
;
gc
-
>
availableChunks
(
lock
)
.
remove
(
this
)
;
decommitAllArenas
(
)
;
MOZ_ASSERT
(
info
.
numArenasFreeCommitted
=
=
0
)
;
gc
-
>
recycleChunk
(
this
lock
)
;
}
}
void
GCRuntime
:
:
releaseArena
(
Arena
*
arena
const
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
arena
-
>
allocated
(
)
)
;
MOZ_ASSERT
(
!
arena
-
>
onDelayedMarkingList
(
)
)
;
arena
-
>
zone
-
>
gcHeapSize
.
removeGCArena
(
)
;
arena
-
>
release
(
lock
)
;
arena
-
>
chunk
(
)
-
>
releaseArena
(
this
arena
lock
)
;
}
GCRuntime
:
:
GCRuntime
(
JSRuntime
*
rt
)
:
rt
(
rt
)
systemZone
(
nullptr
)
atomsZone
(
nullptr
)
heapState_
(
JS
:
:
HeapState
:
:
Idle
)
stats_
(
this
)
marker
(
rt
)
heapSize
(
nullptr
)
rootsHash
(
256
)
nextCellUniqueId_
(
LargestTaggedNullCellPointer
+
1
)
numArenasFreeCommitted
(
0
)
verifyPreData
(
nullptr
)
chunkAllocationSinceLastGC
(
false
)
lastGCStartTime_
(
ReallyNow
(
)
)
lastGCEndTime_
(
ReallyNow
(
)
)
mode
(
TuningDefaults
:
:
Mode
)
numActiveZoneIters
(
0
)
cleanUpEverything
(
false
)
grayBufferState
(
GCRuntime
:
:
GrayBufferState
:
:
Unused
)
grayBitsValid
(
false
)
majorGCTriggerReason
(
JS
:
:
GCReason
:
:
NO_REASON
)
fullGCForAtomsRequested_
(
false
)
minorGCNumber
(
0
)
majorGCNumber
(
0
)
number
(
0
)
sliceNumber
(
0
)
isFull
(
false
)
incrementalState
(
gc
:
:
State
:
:
NotActive
)
initialState
(
gc
:
:
State
:
:
NotActive
)
#
ifdef
JS_GC_ZEAL
useZeal
(
false
)
#
endif
lastMarkSlice
(
false
)
safeToYield
(
true
)
sweepOnBackgroundThread
(
false
)
lifoBlocksToFree
(
(
size_t
)
JSContext
:
:
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
)
lifoBlocksToFreeAfterMinorGC
(
(
size_t
)
JSContext
:
:
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
)
sweepGroupIndex
(
0
)
sweepGroups
(
nullptr
)
currentSweepGroup
(
nullptr
)
sweepZone
(
nullptr
)
hasMarkedGrayRoots
(
false
)
abortSweepAfterCurrentGroup
(
false
)
sweepMarkTaskStarted
(
false
)
sweepMarkResult
(
IncrementalProgress
:
:
NotFinished
)
startedCompacting
(
false
)
relocatedArenasToRelease
(
nullptr
)
#
ifdef
JS_GC_ZEAL
markingValidator
(
nullptr
)
#
endif
defaultTimeBudgetMS_
(
TuningDefaults
:
:
DefaultTimeBudgetMS
)
incrementalAllowed
(
true
)
compactingEnabled
(
TuningDefaults
:
:
CompactingEnabled
)
rootsRemoved
(
false
)
#
ifdef
JS_GC_ZEAL
zealModeBits
(
0
)
zealFrequency
(
0
)
nextScheduled
(
0
)
deterministicOnly
(
false
)
incrementalLimit
(
0
)
selectedForMarking
(
rt
)
#
endif
fullCompartmentChecks
(
false
)
gcCallbackDepth
(
0
)
alwaysPreserveCode
(
false
)
lowMemoryState
(
false
)
lock
(
mutexid
:
:
GCLock
)
allocTask
(
this
emptyChunks_
.
ref
(
)
)
sweepTask
(
this
)
freeTask
(
this
)
decommitTask
(
this
)
sweepMarkTask
(
this
)
nursery_
(
this
)
storeBuffer_
(
rt
nursery
(
)
)
{
setGCMode
(
JSGC_MODE_GLOBAL
)
;
}
#
ifdef
JS_GC_ZEAL
void
GCRuntime
:
:
getZealBits
(
uint32_t
*
zealBits
uint32_t
*
frequency
uint32_t
*
scheduled
)
{
*
zealBits
=
zealModeBits
;
*
frequency
=
zealFrequency
;
*
scheduled
=
nextScheduled
;
}
const
char
gc
:
:
ZealModeHelpText
[
]
=
"
Specifies
how
zealous
the
garbage
collector
should
be
.
Some
of
these
"
"
modes
can
\
n
"
"
be
set
simultaneously
by
passing
multiple
level
options
e
.
g
.
\
"
2
;
4
\
"
"
"
will
activate
\
n
"
"
both
modes
2
and
4
.
Modes
can
be
specified
by
name
or
number
.
\
n
"
"
\
n
"
"
Values
:
\
n
"
"
0
:
(
None
)
Normal
amount
of
collection
(
resets
all
modes
)
\
n
"
"
1
:
(
RootsChange
)
Collect
when
roots
are
added
or
removed
\
n
"
"
2
:
(
Alloc
)
Collect
when
every
N
allocations
(
default
:
100
)
\
n
"
"
4
:
(
VerifierPre
)
Verify
pre
write
barriers
between
instructions
\
n
"
"
7
:
(
GenerationalGC
)
Collect
the
nursery
every
N
nursery
allocations
\
n
"
"
8
:
(
YieldBeforeMarking
)
Incremental
GC
in
two
slices
that
yields
"
"
between
\
n
"
"
the
root
marking
and
marking
phases
\
n
"
"
9
:
(
YieldBeforeSweeping
)
Incremental
GC
in
two
slices
that
yields
"
"
between
\
n
"
"
the
marking
and
sweeping
phases
\
n
"
"
10
:
(
IncrementalMultipleSlices
)
Incremental
GC
in
many
slices
\
n
"
"
11
:
(
IncrementalMarkingValidator
)
Verify
incremental
marking
\
n
"
"
12
:
(
ElementsBarrier
)
Use
the
individual
element
post
-
write
barrier
\
n
"
"
regardless
of
elements
size
\
n
"
"
13
:
(
CheckHashTablesOnMinorGC
)
Check
internal
hashtables
on
minor
GC
\
n
"
"
14
:
(
Compact
)
Perform
a
shrinking
collection
every
N
allocations
\
n
"
"
15
:
(
CheckHeapAfterGC
)
Walk
the
heap
to
check
its
integrity
after
"
"
every
GC
\
n
"
"
16
:
(
CheckNursery
)
Check
nursery
integrity
on
minor
GC
\
n
"
"
17
:
(
YieldBeforeSweepingAtoms
)
Incremental
GC
in
two
slices
that
"
"
yields
\
n
"
"
before
sweeping
the
atoms
table
\
n
"
"
18
:
(
CheckGrayMarking
)
Check
gray
marking
invariants
after
every
GC
\
n
"
"
19
:
(
YieldBeforeSweepingCaches
)
Incremental
GC
in
two
slices
that
"
"
yields
\
n
"
"
before
sweeping
weak
caches
\
n
"
"
20
:
(
YieldBeforeSweepingTypes
)
Incremental
GC
in
two
slices
that
"
"
yields
\
n
"
"
before
sweeping
type
information
\
n
"
"
21
:
(
YieldBeforeSweepingObjects
)
Incremental
GC
in
two
slices
that
"
"
yields
\
n
"
"
before
sweeping
foreground
finalized
objects
\
n
"
"
22
:
(
YieldBeforeSweepingNonObjects
)
Incremental
GC
in
two
slices
that
"
"
yields
\
n
"
"
before
sweeping
non
-
object
GC
things
\
n
"
"
23
:
(
YieldBeforeSweepingShapeTrees
)
Incremental
GC
in
two
slices
that
"
"
yields
\
n
"
"
before
sweeping
shape
trees
\
n
"
"
24
:
(
CheckWeakMapMarking
)
Check
weak
map
marking
invariants
after
"
"
every
GC
\
n
"
"
25
:
(
YieldWhileGrayMarking
)
Incremental
GC
in
two
slices
that
yields
\
n
"
"
during
gray
marking
\
n
"
;
static
const
mozilla
:
:
EnumSet
<
ZealMode
>
IncrementalSliceZealModes
=
{
ZealMode
:
:
YieldBeforeMarking
ZealMode
:
:
YieldBeforeSweeping
ZealMode
:
:
IncrementalMultipleSlices
ZealMode
:
:
YieldBeforeSweepingAtoms
ZealMode
:
:
YieldBeforeSweepingCaches
ZealMode
:
:
YieldBeforeSweepingTypes
ZealMode
:
:
YieldBeforeSweepingObjects
ZealMode
:
:
YieldBeforeSweepingNonObjects
ZealMode
:
:
YieldBeforeSweepingShapeTrees
}
;
void
GCRuntime
:
:
setZeal
(
uint8_t
zeal
uint32_t
frequency
)
{
MOZ_ASSERT
(
zeal
<
=
unsigned
(
ZealMode
:
:
Limit
)
)
;
if
(
verifyPreData
)
{
VerifyBarriers
(
rt
PreBarrierVerifier
)
;
}
if
(
zeal
=
=
0
)
{
if
(
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
)
{
evictNursery
(
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
nursery
(
)
.
leaveZealMode
(
)
;
}
if
(
isIncrementalGCInProgress
(
)
)
{
finishGC
(
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
}
ZealMode
zealMode
=
ZealMode
(
zeal
)
;
if
(
zealMode
=
=
ZealMode
:
:
GenerationalGC
)
{
evictNursery
(
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
nursery
(
)
.
enterZealMode
(
)
;
}
if
(
IncrementalSliceZealModes
.
contains
(
zealMode
)
)
{
for
(
auto
mode
:
IncrementalSliceZealModes
)
{
clearZealMode
(
mode
)
;
}
}
bool
schedule
=
zealMode
>
=
ZealMode
:
:
Alloc
;
if
(
zeal
!
=
0
)
{
zealModeBits
|
=
1
<
<
unsigned
(
zeal
)
;
}
else
{
zealModeBits
=
0
;
}
zealFrequency
=
frequency
;
nextScheduled
=
schedule
?
frequency
:
0
;
}
void
GCRuntime
:
:
unsetZeal
(
uint8_t
zeal
)
{
MOZ_ASSERT
(
zeal
<
=
unsigned
(
ZealMode
:
:
Limit
)
)
;
ZealMode
zealMode
=
ZealMode
(
zeal
)
;
if
(
!
hasZealMode
(
zealMode
)
)
{
return
;
}
if
(
verifyPreData
)
{
VerifyBarriers
(
rt
PreBarrierVerifier
)
;
}
if
(
zealMode
=
=
ZealMode
:
:
GenerationalGC
)
{
evictNursery
(
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
nursery
(
)
.
leaveZealMode
(
)
;
}
clearZealMode
(
zealMode
)
;
if
(
zealModeBits
=
=
0
)
{
if
(
isIncrementalGCInProgress
(
)
)
{
finishGC
(
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
zealFrequency
=
0
;
nextScheduled
=
0
;
}
}
void
GCRuntime
:
:
setNextScheduled
(
uint32_t
count
)
{
nextScheduled
=
count
;
}
using
CharRange
=
mozilla
:
:
Range
<
const
char
>
;
using
CharRangeVector
=
Vector
<
CharRange
0
SystemAllocPolicy
>
;
static
bool
ParseZealModeName
(
CharRange
text
uint32_t
*
modeOut
)
{
struct
ModeInfo
{
const
char
*
name
;
size_t
length
;
uint32_t
value
;
}
;
static
const
ModeInfo
zealModes
[
]
=
{
{
"
None
"
0
}
#
define
ZEAL_MODE
(
name
value
)
{
#
name
strlen
(
#
name
)
value
}
JS_FOR_EACH_ZEAL_MODE
(
ZEAL_MODE
)
#
undef
ZEAL_MODE
}
;
for
(
auto
mode
:
zealModes
)
{
if
(
text
.
length
(
)
=
=
mode
.
length
&
&
memcmp
(
text
.
begin
(
)
.
get
(
)
mode
.
name
mode
.
length
)
=
=
0
)
{
*
modeOut
=
mode
.
value
;
return
true
;
}
}
return
false
;
}
static
bool
ParseZealModeNumericParam
(
CharRange
text
uint32_t
*
paramOut
)
{
if
(
text
.
length
(
)
=
=
0
)
{
return
false
;
}
for
(
auto
c
:
text
)
{
if
(
!
mozilla
:
:
IsAsciiDigit
(
c
)
)
{
return
false
;
}
}
*
paramOut
=
atoi
(
text
.
begin
(
)
.
get
(
)
)
;
return
true
;
}
static
bool
SplitStringBy
(
CharRange
text
char
delimiter
CharRangeVector
*
result
)
{
auto
start
=
text
.
begin
(
)
;
for
(
auto
ptr
=
start
;
ptr
!
=
text
.
end
(
)
;
ptr
+
+
)
{
if
(
*
ptr
=
=
delimiter
)
{
if
(
!
result
-
>
emplaceBack
(
start
ptr
)
)
{
return
false
;
}
start
=
ptr
+
1
;
}
}
return
result
-
>
emplaceBack
(
start
text
.
end
(
)
)
;
}
static
bool
PrintZealHelpAndFail
(
)
{
fprintf
(
stderr
"
Format
:
JS_GC_ZEAL
=
level
(
;
level
)
*
[
N
]
\
n
"
)
;
fputs
(
ZealModeHelpText
stderr
)
;
return
false
;
}
bool
GCRuntime
:
:
parseAndSetZeal
(
const
char
*
str
)
{
auto
text
=
CharRange
(
str
strlen
(
str
)
)
;
CharRangeVector
parts
;
if
(
!
SplitStringBy
(
text
'
'
&
parts
)
)
{
return
false
;
}
if
(
parts
.
length
(
)
=
=
0
|
|
parts
.
length
(
)
>
2
)
{
return
PrintZealHelpAndFail
(
)
;
}
uint32_t
frequency
=
JS_DEFAULT_ZEAL_FREQ
;
if
(
parts
.
length
(
)
=
=
2
&
&
!
ParseZealModeNumericParam
(
parts
[
1
]
&
frequency
)
)
{
return
PrintZealHelpAndFail
(
)
;
}
CharRangeVector
modes
;
if
(
!
SplitStringBy
(
parts
[
0
]
'
;
'
&
modes
)
)
{
return
false
;
}
for
(
const
auto
&
descr
:
modes
)
{
uint32_t
mode
;
if
(
!
ParseZealModeName
(
descr
&
mode
)
&
&
!
(
ParseZealModeNumericParam
(
descr
&
mode
)
&
&
mode
<
=
unsigned
(
ZealMode
:
:
Limit
)
)
)
{
return
PrintZealHelpAndFail
(
)
;
}
setZeal
(
mode
frequency
)
;
}
return
true
;
}
const
char
*
js
:
:
gc
:
:
AllocKindName
(
AllocKind
kind
)
{
static
const
char
*
const
names
[
]
=
{
#
define
EXPAND_THING_NAME
(
allocKind
_1
_2
_3
_4
_5
_6
)
#
allocKind
FOR_EACH_ALLOCKIND
(
EXPAND_THING_NAME
)
#
undef
EXPAND_THING_NAME
}
;
static_assert
(
ArrayLength
(
names
)
=
=
size_t
(
AllocKind
:
:
LIMIT
)
"
names
array
should
have
an
entry
for
every
AllocKind
"
)
;
size_t
i
=
size_t
(
kind
)
;
MOZ_ASSERT
(
i
<
ArrayLength
(
names
)
)
;
return
names
[
i
]
;
}
void
js
:
:
gc
:
:
DumpArenaInfo
(
)
{
fprintf
(
stderr
"
Arena
header
size
:
%
zu
\
n
\
n
"
ArenaHeaderSize
)
;
fprintf
(
stderr
"
GC
thing
kinds
:
\
n
"
)
;
fprintf
(
stderr
"
%
25s
%
8s
%
8s
%
8s
\
n
"
"
AllocKind
:
"
"
Size
:
"
"
Count
:
"
"
Padding
:
"
)
;
for
(
auto
kind
:
AllAllocKinds
(
)
)
{
fprintf
(
stderr
"
%
25s
%
8zu
%
8zu
%
8zu
\
n
"
AllocKindName
(
kind
)
Arena
:
:
thingSize
(
kind
)
Arena
:
:
thingsPerArena
(
kind
)
Arena
:
:
firstThingOffset
(
kind
)
-
ArenaHeaderSize
)
;
}
}
#
endif
bool
GCRuntime
:
:
init
(
uint32_t
maxbytes
)
{
MOZ_ASSERT
(
SystemPageSize
(
)
)
;
{
AutoLockGCBgAlloc
lock
(
this
)
;
MOZ_ALWAYS_TRUE
(
tunables
.
setParameter
(
JSGC_MAX_BYTES
maxbytes
lock
)
)
;
const
char
*
size
=
getenv
(
"
JSGC_MARK_STACK_LIMIT
"
)
;
if
(
size
)
{
setMarkStackLimit
(
atoi
(
size
)
lock
)
;
}
if
(
!
nursery
(
)
.
init
(
lock
)
)
{
return
false
;
}
const
char
*
pretenureThresholdStr
=
getenv
(
"
JSGC_PRETENURE_THRESHOLD
"
)
;
if
(
pretenureThresholdStr
&
&
pretenureThresholdStr
[
0
]
)
{
char
*
last
;
long
pretenureThreshold
=
strtol
(
pretenureThresholdStr
&
last
10
)
;
if
(
last
[
0
]
|
|
!
tunables
.
setParameter
(
JSGC_PRETENURE_THRESHOLD
pretenureThreshold
lock
)
)
{
fprintf
(
stderr
"
Invalid
value
for
JSGC_PRETENURE_THRESHOLD
:
%
s
\
n
"
pretenureThresholdStr
)
;
}
}
}
#
ifdef
JS_GC_ZEAL
const
char
*
zealSpec
=
getenv
(
"
JS_GC_ZEAL
"
)
;
if
(
zealSpec
&
&
zealSpec
[
0
]
&
&
!
parseAndSetZeal
(
zealSpec
)
)
{
return
false
;
}
#
endif
if
(
!
gcTracer
.
initTrace
(
*
this
)
)
{
return
false
;
}
if
(
!
marker
.
init
(
mode
)
)
{
return
false
;
}
if
(
!
initSweepActions
(
)
)
{
return
false
;
}
return
true
;
}
void
GCRuntime
:
:
finish
(
)
{
if
(
nursery
(
)
.
isEnabled
(
)
)
{
nursery
(
)
.
disable
(
)
;
}
sweepTask
.
join
(
)
;
freeTask
.
join
(
)
;
allocTask
.
cancelAndWait
(
)
;
decommitTask
.
cancelAndWait
(
)
;
#
ifdef
JS_GC_ZEAL
finishVerifier
(
)
;
#
endif
if
(
rt
-
>
gcInitialized
)
{
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
zone
)
;
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
for
(
RealmsInCompartmentIter
realm
(
comp
)
;
!
realm
.
done
(
)
;
realm
.
next
(
)
)
{
js_delete
(
realm
.
get
(
)
)
;
}
comp
-
>
realms
(
)
.
clear
(
)
;
js_delete
(
comp
.
get
(
)
)
;
}
zone
-
>
compartments
(
)
.
clear
(
)
;
js_delete
(
zone
.
get
(
)
)
;
}
}
zones
(
)
.
clear
(
)
;
FreeChunkPool
(
fullChunks_
.
ref
(
)
)
;
FreeChunkPool
(
availableChunks_
.
ref
(
)
)
;
FreeChunkPool
(
emptyChunks_
.
ref
(
)
)
;
gcTracer
.
finishTrace
(
)
;
nursery
(
)
.
printTotalProfileTimes
(
)
;
stats
(
)
.
printTotalProfileTimes
(
)
;
}
bool
GCRuntime
:
:
setParameter
(
JSGCParamKey
key
uint32_t
value
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
waitBackgroundSweepEnd
(
)
;
AutoLockGC
lock
(
this
)
;
return
setParameter
(
key
value
lock
)
;
}
bool
GCRuntime
:
:
setParameter
(
JSGCParamKey
key
uint32_t
value
AutoLockGC
&
lock
)
{
switch
(
key
)
{
case
JSGC_SLICE_TIME_BUDGET_MS
:
defaultTimeBudgetMS_
=
value
?
value
:
SliceBudget
:
:
UnlimitedTimeBudget
;
break
;
case
JSGC_MARK_STACK_LIMIT
:
if
(
value
=
=
0
)
{
return
false
;
}
setMarkStackLimit
(
value
lock
)
;
break
;
case
JSGC_MODE
:
if
(
mode
!
=
JSGC_MODE_GLOBAL
&
&
mode
!
=
JSGC_MODE_ZONE
&
&
mode
!
=
JSGC_MODE_INCREMENTAL
&
&
mode
!
=
JSGC_MODE_ZONE_INCREMENTAL
)
{
return
false
;
}
mode
=
JSGCMode
(
value
)
;
break
;
case
JSGC_COMPACTING_ENABLED
:
compactingEnabled
=
value
!
=
0
;
break
;
default
:
if
(
!
tunables
.
setParameter
(
key
value
lock
)
)
{
return
false
;
}
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
updateGCThresholds
(
*
this
GC_NORMAL
lock
)
;
}
}
return
true
;
}
void
GCRuntime
:
:
resetParameter
(
JSGCParamKey
key
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
waitBackgroundSweepEnd
(
)
;
AutoLockGC
lock
(
this
)
;
resetParameter
(
key
lock
)
;
}
void
GCRuntime
:
:
resetParameter
(
JSGCParamKey
key
AutoLockGC
&
lock
)
{
switch
(
key
)
{
case
JSGC_SLICE_TIME_BUDGET_MS
:
defaultTimeBudgetMS_
=
TuningDefaults
:
:
DefaultTimeBudgetMS
;
break
;
case
JSGC_MARK_STACK_LIMIT
:
setMarkStackLimit
(
MarkStack
:
:
DefaultCapacity
lock
)
;
break
;
case
JSGC_MODE
:
mode
=
TuningDefaults
:
:
Mode
;
break
;
case
JSGC_COMPACTING_ENABLED
:
compactingEnabled
=
TuningDefaults
:
:
CompactingEnabled
;
break
;
default
:
tunables
.
resetParameter
(
key
lock
)
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
updateGCThresholds
(
*
this
GC_NORMAL
lock
)
;
}
}
}
uint32_t
GCRuntime
:
:
getParameter
(
JSGCParamKey
key
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
AutoLockGC
lock
(
this
)
;
return
getParameter
(
key
lock
)
;
}
uint32_t
GCRuntime
:
:
getParameter
(
JSGCParamKey
key
const
AutoLockGC
&
lock
)
{
switch
(
key
)
{
case
JSGC_MAX_BYTES
:
return
uint32_t
(
tunables
.
gcMaxBytes
(
)
)
;
case
JSGC_MIN_NURSERY_BYTES
:
MOZ_ASSERT
(
tunables
.
gcMinNurseryBytes
(
)
<
UINT32_MAX
)
;
return
uint32_t
(
tunables
.
gcMinNurseryBytes
(
)
)
;
case
JSGC_MAX_NURSERY_BYTES
:
MOZ_ASSERT
(
tunables
.
gcMaxNurseryBytes
(
)
<
UINT32_MAX
)
;
return
uint32_t
(
tunables
.
gcMaxNurseryBytes
(
)
)
;
case
JSGC_BYTES
:
return
uint32_t
(
heapSize
.
bytes
(
)
)
;
case
JSGC_NURSERY_BYTES
:
return
nursery
(
)
.
capacity
(
)
;
case
JSGC_NUMBER
:
return
uint32_t
(
number
)
;
case
JSGC_MODE
:
return
uint32_t
(
mode
)
;
case
JSGC_UNUSED_CHUNKS
:
return
uint32_t
(
emptyChunks
(
lock
)
.
count
(
)
)
;
case
JSGC_TOTAL_CHUNKS
:
return
uint32_t
(
fullChunks
(
lock
)
.
count
(
)
+
availableChunks
(
lock
)
.
count
(
)
+
emptyChunks
(
lock
)
.
count
(
)
)
;
case
JSGC_SLICE_TIME_BUDGET_MS
:
if
(
defaultTimeBudgetMS_
.
ref
(
)
=
=
SliceBudget
:
:
UnlimitedTimeBudget
)
{
return
0
;
}
else
{
MOZ_RELEASE_ASSERT
(
defaultTimeBudgetMS_
>
=
0
)
;
MOZ_RELEASE_ASSERT
(
defaultTimeBudgetMS_
<
=
UINT32_MAX
)
;
return
uint32_t
(
defaultTimeBudgetMS_
)
;
}
case
JSGC_MARK_STACK_LIMIT
:
return
marker
.
maxCapacity
(
)
;
case
JSGC_HIGH_FREQUENCY_TIME_LIMIT
:
return
tunables
.
highFrequencyThreshold
(
)
.
ToMilliseconds
(
)
;
case
JSGC_HIGH_FREQUENCY_LOW_LIMIT
:
return
tunables
.
highFrequencyLowLimitBytes
(
)
/
1024
/
1024
;
case
JSGC_HIGH_FREQUENCY_HIGH_LIMIT
:
return
tunables
.
highFrequencyHighLimitBytes
(
)
/
1024
/
1024
;
case
JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX
:
return
uint32_t
(
tunables
.
highFrequencyHeapGrowthMax
(
)
*
100
)
;
case
JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN
:
return
uint32_t
(
tunables
.
highFrequencyHeapGrowthMin
(
)
*
100
)
;
case
JSGC_LOW_FREQUENCY_HEAP_GROWTH
:
return
uint32_t
(
tunables
.
lowFrequencyHeapGrowth
(
)
*
100
)
;
case
JSGC_DYNAMIC_HEAP_GROWTH
:
return
tunables
.
isDynamicHeapGrowthEnabled
(
)
;
case
JSGC_DYNAMIC_MARK_SLICE
:
return
tunables
.
isDynamicMarkSliceEnabled
(
)
;
case
JSGC_ALLOCATION_THRESHOLD
:
return
tunables
.
gcZoneAllocThresholdBase
(
)
/
1024
/
1024
;
case
JSGC_NON_INCREMENTAL_FACTOR
:
return
uint32_t
(
tunables
.
nonIncrementalFactor
(
)
*
100
)
;
case
JSGC_AVOID_INTERRUPT_FACTOR
:
return
uint32_t
(
tunables
.
avoidInterruptFactor
(
)
*
100
)
;
case
JSGC_MIN_EMPTY_CHUNK_COUNT
:
return
tunables
.
minEmptyChunkCount
(
lock
)
;
case
JSGC_MAX_EMPTY_CHUNK_COUNT
:
return
tunables
.
maxEmptyChunkCount
(
)
;
case
JSGC_COMPACTING_ENABLED
:
return
compactingEnabled
;
case
JSGC_NURSERY_FREE_THRESHOLD_FOR_IDLE_COLLECTION
:
return
tunables
.
nurseryFreeThresholdForIdleCollection
(
)
;
case
JSGC_NURSERY_FREE_THRESHOLD_FOR_IDLE_COLLECTION_PERCENT
:
return
uint32_t
(
tunables
.
nurseryFreeThresholdForIdleCollectionFraction
(
)
*
100
.
0f
)
;
case
JSGC_PRETENURE_THRESHOLD
:
return
uint32_t
(
tunables
.
pretenureThreshold
(
)
*
100
)
;
case
JSGC_PRETENURE_GROUP_THRESHOLD
:
return
tunables
.
pretenureGroupThreshold
(
)
;
case
JSGC_MIN_LAST_DITCH_GC_PERIOD
:
return
tunables
.
minLastDitchGCPeriod
(
)
.
ToSeconds
(
)
;
case
JSGC_ZONE_ALLOC_DELAY_KB
:
return
tunables
.
zoneAllocDelayBytes
(
)
/
1024
;
case
JSGC_MALLOC_THRESHOLD_BASE
:
return
tunables
.
mallocThresholdBase
(
)
/
1024
/
1024
;
case
JSGC_MALLOC_GROWTH_FACTOR
:
return
uint32_t
(
tunables
.
mallocGrowthFactor
(
)
*
100
)
;
default
:
MOZ_CRASH
(
"
Unknown
parameter
key
"
)
;
}
}
void
GCRuntime
:
:
setMarkStackLimit
(
size_t
limit
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
AutoUnlockGC
unlock
(
lock
)
;
AutoStopVerifyingBarriers
pauseVerification
(
rt
false
)
;
marker
.
setMaxCapacity
(
limit
)
;
}
bool
GCRuntime
:
:
addBlackRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
{
AssertHeapIsIdle
(
)
;
return
!
!
blackRootTracers
.
ref
(
)
.
append
(
Callback
<
JSTraceDataOp
>
(
traceOp
data
)
)
;
}
void
GCRuntime
:
:
removeBlackRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
{
for
(
size_t
i
=
0
;
i
<
blackRootTracers
.
ref
(
)
.
length
(
)
;
i
+
+
)
{
Callback
<
JSTraceDataOp
>
*
e
=
&
blackRootTracers
.
ref
(
)
[
i
]
;
if
(
e
-
>
op
=
=
traceOp
&
&
e
-
>
data
=
=
data
)
{
blackRootTracers
.
ref
(
)
.
erase
(
e
)
;
break
;
}
}
}
void
GCRuntime
:
:
setGrayRootsTracer
(
JSTraceDataOp
traceOp
void
*
data
)
{
AssertHeapIsIdle
(
)
;
grayRootTracer
.
op
=
traceOp
;
grayRootTracer
.
data
=
data
;
}
void
GCRuntime
:
:
clearBlackAndGrayRootTracers
(
)
{
MOZ_ASSERT
(
rt
-
>
isBeingDestroyed
(
)
)
;
blackRootTracers
.
ref
(
)
.
clear
(
)
;
setGrayRootsTracer
(
nullptr
nullptr
)
;
}
void
GCRuntime
:
:
setGCCallback
(
JSGCCallback
callback
void
*
data
)
{
gcCallback
.
op
=
callback
;
gcCallback
.
data
=
data
;
}
void
GCRuntime
:
:
callGCCallback
(
JSGCStatus
status
)
const
{
MOZ_ASSERT
(
gcCallback
.
op
)
;
gcCallback
.
op
(
rt
-
>
mainContextFromOwnThread
(
)
status
gcCallback
.
data
)
;
}
void
GCRuntime
:
:
setObjectsTenuredCallback
(
JSObjectsTenuredCallback
callback
void
*
data
)
{
tenuredCallback
.
op
=
callback
;
tenuredCallback
.
data
=
data
;
}
void
GCRuntime
:
:
callObjectsTenuredCallback
(
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
if
(
tenuredCallback
.
op
)
{
tenuredCallback
.
op
(
rt
-
>
mainContextFromOwnThread
(
)
tenuredCallback
.
data
)
;
}
}
bool
GCRuntime
:
:
addFinalizeCallback
(
JSFinalizeCallback
callback
void
*
data
)
{
return
finalizeCallbacks
.
ref
(
)
.
append
(
Callback
<
JSFinalizeCallback
>
(
callback
data
)
)
;
}
void
GCRuntime
:
:
removeFinalizeCallback
(
JSFinalizeCallback
callback
)
{
for
(
Callback
<
JSFinalizeCallback
>
*
p
=
finalizeCallbacks
.
ref
(
)
.
begin
(
)
;
p
<
finalizeCallbacks
.
ref
(
)
.
end
(
)
;
p
+
+
)
{
if
(
p
-
>
op
=
=
callback
)
{
finalizeCallbacks
.
ref
(
)
.
erase
(
p
)
;
break
;
}
}
}
void
GCRuntime
:
:
callFinalizeCallbacks
(
JSFreeOp
*
fop
JSFinalizeStatus
status
)
const
{
for
(
auto
&
p
:
finalizeCallbacks
.
ref
(
)
)
{
p
.
op
(
fop
status
p
.
data
)
;
}
}
void
GCRuntime
:
:
setHostCleanupFinalizationGroupCallback
(
JSHostCleanupFinalizationGroupCallback
callback
void
*
data
)
{
hostCleanupFinalizationGroupCallback
=
{
callback
data
}
;
}
void
GCRuntime
:
:
callHostCleanupFinalizationGroupCallback
(
FinalizationGroupObject
*
group
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
auto
&
callback
=
hostCleanupFinalizationGroupCallback
;
if
(
callback
.
op
)
{
callback
.
op
(
group
callback
.
data
)
;
}
}
bool
GCRuntime
:
:
addWeakPointerZonesCallback
(
JSWeakPointerZonesCallback
callback
void
*
data
)
{
return
updateWeakPointerZonesCallbacks
.
ref
(
)
.
append
(
Callback
<
JSWeakPointerZonesCallback
>
(
callback
data
)
)
;
}
void
GCRuntime
:
:
removeWeakPointerZonesCallback
(
JSWeakPointerZonesCallback
callback
)
{
for
(
auto
&
p
:
updateWeakPointerZonesCallbacks
.
ref
(
)
)
{
if
(
p
.
op
=
=
callback
)
{
updateWeakPointerZonesCallbacks
.
ref
(
)
.
erase
(
&
p
)
;
break
;
}
}
}
void
GCRuntime
:
:
callWeakPointerZonesCallbacks
(
)
const
{
JSContext
*
cx
=
rt
-
>
mainContextFromOwnThread
(
)
;
for
(
auto
const
&
p
:
updateWeakPointerZonesCallbacks
.
ref
(
)
)
{
p
.
op
(
cx
p
.
data
)
;
}
}
bool
GCRuntime
:
:
addWeakPointerCompartmentCallback
(
JSWeakPointerCompartmentCallback
callback
void
*
data
)
{
return
updateWeakPointerCompartmentCallbacks
.
ref
(
)
.
append
(
Callback
<
JSWeakPointerCompartmentCallback
>
(
callback
data
)
)
;
}
void
GCRuntime
:
:
removeWeakPointerCompartmentCallback
(
JSWeakPointerCompartmentCallback
callback
)
{
for
(
auto
&
p
:
updateWeakPointerCompartmentCallbacks
.
ref
(
)
)
{
if
(
p
.
op
=
=
callback
)
{
updateWeakPointerCompartmentCallbacks
.
ref
(
)
.
erase
(
&
p
)
;
break
;
}
}
}
void
GCRuntime
:
:
callWeakPointerCompartmentCallbacks
(
JS
:
:
Compartment
*
comp
)
const
{
JSContext
*
cx
=
rt
-
>
mainContextFromOwnThread
(
)
;
for
(
auto
const
&
p
:
updateWeakPointerCompartmentCallbacks
.
ref
(
)
)
{
p
.
op
(
cx
comp
p
.
data
)
;
}
}
JS
:
:
GCSliceCallback
GCRuntime
:
:
setSliceCallback
(
JS
:
:
GCSliceCallback
callback
)
{
return
stats
(
)
.
setSliceCallback
(
callback
)
;
}
JS
:
:
GCNurseryCollectionCallback
GCRuntime
:
:
setNurseryCollectionCallback
(
JS
:
:
GCNurseryCollectionCallback
callback
)
{
return
stats
(
)
.
setNurseryCollectionCallback
(
callback
)
;
}
JS
:
:
DoCycleCollectionCallback
GCRuntime
:
:
setDoCycleCollectionCallback
(
JS
:
:
DoCycleCollectionCallback
callback
)
{
auto
prior
=
gcDoCycleCollectionCallback
;
gcDoCycleCollectionCallback
=
Callback
<
JS
:
:
DoCycleCollectionCallback
>
(
callback
nullptr
)
;
return
prior
.
op
;
}
void
GCRuntime
:
:
callDoCycleCollectionCallback
(
JSContext
*
cx
)
{
if
(
gcDoCycleCollectionCallback
.
op
)
{
gcDoCycleCollectionCallback
.
op
(
cx
)
;
}
}
bool
GCRuntime
:
:
addRoot
(
Value
*
vp
const
char
*
name
)
{
if
(
isIncrementalGCInProgress
(
)
)
{
GCPtrValue
:
:
writeBarrierPre
(
*
vp
)
;
}
return
rootsHash
.
ref
(
)
.
put
(
vp
name
)
;
}
void
GCRuntime
:
:
removeRoot
(
Value
*
vp
)
{
rootsHash
.
ref
(
)
.
remove
(
vp
)
;
notifyRootsRemoved
(
)
;
}
extern
JS_FRIEND_API
bool
js
:
:
AddRawValueRoot
(
JSContext
*
cx
Value
*
vp
const
char
*
name
)
{
MOZ_ASSERT
(
vp
)
;
MOZ_ASSERT
(
name
)
;
bool
ok
=
cx
-
>
runtime
(
)
-
>
gc
.
addRoot
(
vp
name
)
;
if
(
!
ok
)
{
JS_ReportOutOfMemory
(
cx
)
;
}
return
ok
;
}
extern
JS_FRIEND_API
void
js
:
:
RemoveRawValueRoot
(
JSContext
*
cx
Value
*
vp
)
{
cx
-
>
runtime
(
)
-
>
gc
.
removeRoot
(
vp
)
;
}
bool
js
:
:
gc
:
:
IsCurrentlyAnimating
(
const
TimeStamp
&
lastAnimationTime
const
TimeStamp
&
currentTime
)
{
static
const
auto
oneSecond
=
TimeDuration
:
:
FromSeconds
(
1
)
;
return
!
lastAnimationTime
.
IsNull
(
)
&
&
currentTime
<
(
lastAnimationTime
+
oneSecond
)
;
}
bool
GCRuntime
:
:
shouldCompact
(
)
{
if
(
invocationKind
!
=
GC_SHRINK
|
|
!
isCompactingGCEnabled
(
)
)
{
return
false
;
}
if
(
initialReason
=
=
JS
:
:
GCReason
:
:
USER_INACTIVE
|
|
initialReason
=
=
JS
:
:
GCReason
:
:
MEM_PRESSURE
)
{
return
true
;
}
return
!
isIncremental
|
|
!
IsCurrentlyAnimating
(
rt
-
>
lastAnimationTime
TimeStamp
:
:
Now
(
)
)
;
}
bool
GCRuntime
:
:
isCompactingGCEnabled
(
)
const
{
return
compactingEnabled
&
&
rt
-
>
mainContextFromOwnThread
(
)
-
>
compactingDisabledCount
=
=
0
&
&
!
mozilla
:
:
recordreplay
:
:
IsRecordingOrReplaying
(
)
;
}
AutoDisableCompactingGC
:
:
AutoDisableCompactingGC
(
JSContext
*
cx
)
:
cx
(
cx
)
{
+
+
cx
-
>
compactingDisabledCount
;
if
(
cx
-
>
runtime
(
)
-
>
gc
.
isIncrementalGCInProgress
(
)
&
&
cx
-
>
runtime
(
)
-
>
gc
.
isCompactingGc
(
)
)
{
FinishGC
(
cx
)
;
}
}
AutoDisableCompactingGC
:
:
~
AutoDisableCompactingGC
(
)
{
MOZ_ASSERT
(
cx
-
>
compactingDisabledCount
>
0
)
;
-
-
cx
-
>
compactingDisabledCount
;
}
static
bool
CanRelocateZone
(
Zone
*
zone
)
{
return
!
zone
-
>
isAtomsZone
(
)
&
&
!
zone
-
>
isSelfHostingZone
(
)
;
}
Arena
*
ArenaList
:
:
removeRemainingArenas
(
Arena
*
*
arenap
)
{
#
ifdef
DEBUG
for
(
Arena
*
arena
=
*
arenap
;
arena
;
arena
=
arena
-
>
next
)
{
MOZ_ASSERT
(
cursorp_
!
=
&
arena
-
>
next
)
;
}
#
endif
Arena
*
remainingArenas
=
*
arenap
;
*
arenap
=
nullptr
;
check
(
)
;
return
remainingArenas
;
}
static
bool
ShouldRelocateAllArenas
(
JS
:
:
GCReason
reason
)
{
return
reason
=
=
JS
:
:
GCReason
:
:
DEBUG_GC
;
}
Arena
*
*
ArenaList
:
:
pickArenasToRelocate
(
size_t
&
arenaTotalOut
size_t
&
relocTotalOut
)
{
check
(
)
;
if
(
isCursorAtEnd
(
)
)
{
return
nullptr
;
}
Arena
*
*
arenap
=
cursorp_
;
size_t
previousFreeCells
=
0
;
size_t
followingUsedCells
=
0
;
size_t
fullArenaCount
=
0
;
size_t
nonFullArenaCount
=
0
;
size_t
arenaIndex
=
0
;
for
(
Arena
*
arena
=
head_
;
arena
!
=
*
cursorp_
;
arena
=
arena
-
>
next
)
{
fullArenaCount
+
+
;
}
for
(
Arena
*
arena
=
*
cursorp_
;
arena
;
arena
=
arena
-
>
next
)
{
followingUsedCells
+
=
arena
-
>
countUsedCells
(
)
;
nonFullArenaCount
+
+
;
}
mozilla
:
:
DebugOnly
<
size_t
>
lastFreeCells
(
0
)
;
size_t
cellsPerArena
=
Arena
:
:
thingsPerArena
(
(
*
arenap
)
-
>
getAllocKind
(
)
)
;
while
(
*
arenap
)
{
Arena
*
arena
=
*
arenap
;
if
(
followingUsedCells
<
=
previousFreeCells
)
{
break
;
}
size_t
freeCells
=
arena
-
>
countFreeCells
(
)
;
size_t
usedCells
=
cellsPerArena
-
freeCells
;
followingUsedCells
-
=
usedCells
;
#
ifdef
DEBUG
MOZ_ASSERT
(
freeCells
>
=
lastFreeCells
)
;
lastFreeCells
=
freeCells
;
#
endif
previousFreeCells
+
=
freeCells
;
arenap
=
&
arena
-
>
next
;
arenaIndex
+
+
;
}
size_t
relocCount
=
nonFullArenaCount
-
arenaIndex
;
MOZ_ASSERT
(
relocCount
<
nonFullArenaCount
)
;
MOZ_ASSERT
(
(
relocCount
=
=
0
)
=
=
(
!
*
arenap
)
)
;
arenaTotalOut
+
=
fullArenaCount
+
nonFullArenaCount
;
relocTotalOut
+
=
relocCount
;
return
arenap
;
}
#
ifdef
DEBUG
inline
bool
PtrIsInRange
(
const
void
*
ptr
const
void
*
start
size_t
length
)
{
return
uintptr_t
(
ptr
)
-
uintptr_t
(
start
)
<
length
;
}
#
endif
static
void
RelocateCell
(
Zone
*
zone
TenuredCell
*
src
AllocKind
thingKind
size_t
thingSize
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
(
TlsContext
.
get
(
)
)
;
MOZ_ASSERT
(
zone
=
=
src
-
>
zone
(
)
)
;
TenuredCell
*
dst
=
AllocateCellInGC
(
zone
thingKind
)
;
memcpy
(
dst
src
thingSize
)
;
src
-
>
zone
(
)
-
>
transferUniqueId
(
dst
src
)
;
if
(
IsObjectAllocKind
(
thingKind
)
)
{
JSObject
*
srcObj
=
static_cast
<
JSObject
*
>
(
static_cast
<
Cell
*
>
(
src
)
)
;
JSObject
*
dstObj
=
static_cast
<
JSObject
*
>
(
static_cast
<
Cell
*
>
(
dst
)
)
;
if
(
srcObj
-
>
isNative
(
)
)
{
NativeObject
*
srcNative
=
&
srcObj
-
>
as
<
NativeObject
>
(
)
;
NativeObject
*
dstNative
=
&
dstObj
-
>
as
<
NativeObject
>
(
)
;
if
(
srcNative
-
>
hasFixedElements
(
)
)
{
uint32_t
numShifted
=
srcNative
-
>
getElementsHeader
(
)
-
>
numShiftedElements
(
)
;
dstNative
-
>
setFixedElements
(
numShifted
)
;
}
if
(
srcNative
-
>
denseElementsAreCopyOnWrite
(
)
)
{
GCPtrNativeObject
&
owner
=
dstNative
-
>
getElementsHeader
(
)
-
>
ownerObject
(
)
;
if
(
owner
=
=
srcNative
)
{
owner
=
dstNative
;
}
}
}
else
if
(
srcObj
-
>
is
<
ProxyObject
>
(
)
)
{
if
(
srcObj
-
>
as
<
ProxyObject
>
(
)
.
usingInlineValueArray
(
)
)
{
dstObj
-
>
as
<
ProxyObject
>
(
)
.
setInlineValueArray
(
)
;
}
}
if
(
JSObjectMovedOp
op
=
srcObj
-
>
getClass
(
)
-
>
extObjectMovedOp
(
)
)
{
op
(
dstObj
srcObj
)
;
}
MOZ_ASSERT_IF
(
dstObj
-
>
isNative
(
)
!
PtrIsInRange
(
(
const
Value
*
)
dstObj
-
>
as
<
NativeObject
>
(
)
.
getDenseElements
(
)
src
thingSize
)
)
;
}
dst
-
>
copyMarkBitsFrom
(
src
)
;
RelocationOverlay
*
overlay
=
RelocationOverlay
:
:
fromCell
(
src
)
;
overlay
-
>
forwardTo
(
dst
)
;
}
static
void
RelocateArena
(
Arena
*
arena
SliceBudget
&
sliceBudget
)
{
MOZ_ASSERT
(
arena
-
>
allocated
(
)
)
;
MOZ_ASSERT
(
!
arena
-
>
onDelayedMarkingList
(
)
)
;
MOZ_ASSERT
(
arena
-
>
bufferedCells
(
)
-
>
isEmpty
(
)
)
;
Zone
*
zone
=
arena
-
>
zone
;
AllocKind
thingKind
=
arena
-
>
getAllocKind
(
)
;
size_t
thingSize
=
arena
-
>
getThingSize
(
)
;
for
(
ArenaCellIterUnderGC
i
(
arena
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
RelocateCell
(
zone
i
.
getCell
(
)
thingKind
thingSize
)
;
sliceBudget
.
step
(
)
;
}
#
ifdef
DEBUG
for
(
ArenaCellIterUnderGC
i
(
arena
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
TenuredCell
*
src
=
i
.
getCell
(
)
;
MOZ_ASSERT
(
src
-
>
isForwarded
(
)
)
;
TenuredCell
*
dest
=
Forwarded
(
src
)
;
MOZ_ASSERT
(
src
-
>
isMarkedBlack
(
)
=
=
dest
-
>
isMarkedBlack
(
)
)
;
MOZ_ASSERT
(
src
-
>
isMarkedGray
(
)
=
=
dest
-
>
isMarkedGray
(
)
)
;
}
#
endif
}
#
ifdef
DEBUG
static
inline
bool
CanProtectArenas
(
)
{
return
SystemPageSize
(
)
<
=
ArenaSize
;
}
#
endif
static
inline
bool
ShouldProtectRelocatedArenas
(
JS
:
:
GCReason
reason
)
{
#
ifdef
DEBUG
return
reason
=
=
JS
:
:
GCReason
:
:
DEBUG_GC
&
&
CanProtectArenas
(
)
;
#
else
return
false
;
#
endif
}
Arena
*
ArenaList
:
:
relocateArenas
(
Arena
*
toRelocate
Arena
*
relocated
SliceBudget
&
sliceBudget
gcstats
:
:
Statistics
&
stats
)
{
check
(
)
;
while
(
Arena
*
arena
=
toRelocate
)
{
toRelocate
=
arena
-
>
next
;
RelocateArena
(
arena
sliceBudget
)
;
arena
-
>
next
=
relocated
;
relocated
=
arena
;
stats
.
count
(
gcstats
:
:
COUNT_ARENA_RELOCATED
)
;
}
check
(
)
;
return
relocated
;
}
static
const
float
MIN_ZONE_RECLAIM_PERCENT
=
2
.
0
;
static
bool
ShouldRelocateZone
(
size_t
arenaCount
size_t
relocCount
JS
:
:
GCReason
reason
)
{
if
(
relocCount
=
=
0
)
{
return
false
;
}
if
(
IsOOMReason
(
reason
)
)
{
return
true
;
}
return
(
relocCount
*
100
.
0f
)
/
arenaCount
>
=
MIN_ZONE_RECLAIM_PERCENT
;
}
static
AllocKinds
CompactingAllocKinds
(
)
{
AllocKinds
result
;
for
(
AllocKind
kind
:
AllAllocKinds
(
)
)
{
if
(
IsCompactingKind
(
kind
)
)
{
result
+
=
kind
;
}
}
return
result
;
}
bool
ArenaLists
:
:
relocateArenas
(
Arena
*
&
relocatedListOut
JS
:
:
GCReason
reason
SliceBudget
&
sliceBudget
gcstats
:
:
Statistics
&
stats
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime
(
)
)
)
;
MOZ_ASSERT
(
runtime
(
)
-
>
gc
.
isHeapCompacting
(
)
)
;
MOZ_ASSERT
(
!
runtime
(
)
-
>
gc
.
isBackgroundSweeping
(
)
)
;
AllocKinds
allocKindsToRelocate
=
CompactingAllocKinds
(
)
;
clearFreeLists
(
)
;
if
(
ShouldRelocateAllArenas
(
reason
)
)
{
zone_
-
>
prepareForCompacting
(
)
;
for
(
auto
kind
:
allocKindsToRelocate
)
{
ArenaList
&
al
=
arenaLists
(
kind
)
;
Arena
*
allArenas
=
al
.
head
(
)
;
al
.
clear
(
)
;
relocatedListOut
=
al
.
relocateArenas
(
allArenas
relocatedListOut
sliceBudget
stats
)
;
}
}
else
{
size_t
arenaCount
=
0
;
size_t
relocCount
=
0
;
AllAllocKindArray
<
Arena
*
*
>
toRelocate
;
for
(
auto
kind
:
allocKindsToRelocate
)
{
toRelocate
[
kind
]
=
arenaLists
(
kind
)
.
pickArenasToRelocate
(
arenaCount
relocCount
)
;
}
if
(
!
ShouldRelocateZone
(
arenaCount
relocCount
reason
)
)
{
return
false
;
}
zone_
-
>
prepareForCompacting
(
)
;
for
(
auto
kind
:
allocKindsToRelocate
)
{
if
(
toRelocate
[
kind
]
)
{
ArenaList
&
al
=
arenaLists
(
kind
)
;
Arena
*
arenas
=
al
.
removeRemainingArenas
(
toRelocate
[
kind
]
)
;
relocatedListOut
=
al
.
relocateArenas
(
arenas
relocatedListOut
sliceBudget
stats
)
;
}
}
}
return
true
;
}
bool
GCRuntime
:
:
relocateArenas
(
Zone
*
zone
JS
:
:
GCReason
reason
Arena
*
&
relocatedListOut
SliceBudget
&
sliceBudget
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
COMPACT_MOVE
)
;
MOZ_ASSERT
(
!
zone
-
>
isPreservingCode
(
)
)
;
MOZ_ASSERT
(
CanRelocateZone
(
zone
)
)
;
js
:
:
CancelOffThreadIonCompile
(
rt
JS
:
:
Zone
:
:
Compact
)
;
if
(
!
zone
-
>
arenas
.
relocateArenas
(
relocatedListOut
reason
sliceBudget
stats
(
)
)
)
{
return
false
;
}
#
ifdef
DEBUG
for
(
auto
kind
:
CompactingAllocKinds
(
)
)
{
ArenaList
&
al
=
zone
-
>
arenas
.
arenaLists
(
kind
)
;
size_t
freeCells
=
0
;
for
(
Arena
*
arena
=
al
.
arenaAfterCursor
(
)
;
arena
;
arena
=
arena
-
>
next
)
{
freeCells
+
=
arena
-
>
countFreeCells
(
)
;
}
MOZ_ASSERT
(
freeCells
<
Arena
:
:
thingsPerArena
(
kind
)
)
;
}
#
endif
return
true
;
}
template
<
typename
T
>
inline
bool
MovingTracer
:
:
updateEdge
(
T
*
*
thingp
)
{
auto
thing
=
*
thingp
;
if
(
thing
-
>
runtimeFromAnyThread
(
)
=
=
runtime
(
)
&
&
IsForwarded
(
thing
)
)
{
*
thingp
=
Forwarded
(
thing
)
;
}
return
true
;
}
bool
MovingTracer
:
:
onObjectEdge
(
JSObject
*
*
objp
)
{
return
updateEdge
(
objp
)
;
}
bool
MovingTracer
:
:
onShapeEdge
(
Shape
*
*
shapep
)
{
return
updateEdge
(
shapep
)
;
}
bool
MovingTracer
:
:
onStringEdge
(
JSString
*
*
stringp
)
{
return
updateEdge
(
stringp
)
;
}
bool
MovingTracer
:
:
onScriptEdge
(
JSScript
*
*
scriptp
)
{
return
updateEdge
(
scriptp
)
;
}
bool
MovingTracer
:
:
onLazyScriptEdge
(
LazyScript
*
*
lazyp
)
{
return
updateEdge
(
lazyp
)
;
}
bool
MovingTracer
:
:
onBaseShapeEdge
(
BaseShape
*
*
basep
)
{
return
updateEdge
(
basep
)
;
}
bool
MovingTracer
:
:
onScopeEdge
(
Scope
*
*
scopep
)
{
return
updateEdge
(
scopep
)
;
}
bool
MovingTracer
:
:
onRegExpSharedEdge
(
RegExpShared
*
*
sharedp
)
{
return
updateEdge
(
sharedp
)
;
}
bool
MovingTracer
:
:
onBigIntEdge
(
BigInt
*
*
bip
)
{
return
updateEdge
(
bip
)
;
}
void
Zone
:
:
prepareForCompacting
(
)
{
JSFreeOp
*
fop
=
runtimeFromMainThread
(
)
-
>
defaultFreeOp
(
)
;
discardJitCode
(
fop
)
;
}
void
GCRuntime
:
:
sweepTypesAfterCompacting
(
Zone
*
zone
)
{
zone
-
>
beginSweepTypes
(
)
;
AutoClearTypeInferenceStateOnOOM
oom
(
zone
)
;
for
(
auto
script
=
zone
-
>
cellIterUnsafe
<
JSScript
>
(
)
;
!
script
.
done
(
)
;
script
.
next
(
)
)
{
AutoSweepJitScript
sweep
(
script
)
;
}
for
(
auto
group
=
zone
-
>
cellIterUnsafe
<
ObjectGroup
>
(
)
;
!
group
.
done
(
)
;
group
.
next
(
)
)
{
AutoSweepObjectGroup
sweep
(
group
)
;
}
zone
-
>
types
.
endSweep
(
rt
)
;
}
void
GCRuntime
:
:
sweepZoneAfterCompacting
(
MovingTracer
*
trc
Zone
*
zone
)
{
MOZ_ASSERT
(
zone
-
>
isCollecting
(
)
)
;
sweepTypesAfterCompacting
(
zone
)
;
sweepFinalizationGroups
(
zone
)
;
zone
-
>
sweepWeakMaps
(
)
;
for
(
auto
*
cache
:
zone
-
>
weakCaches
(
)
)
{
cache
-
>
sweep
(
)
;
}
if
(
jit
:
:
JitZone
*
jitZone
=
zone
-
>
jitZone
(
)
)
{
jitZone
-
>
traceWeak
(
trc
)
;
}
for
(
RealmsInZoneIter
r
(
zone
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
r
-
>
traceWeakObjectGroups
(
trc
)
;
r
-
>
traceWeakRegExps
(
trc
)
;
r
-
>
traceWeakSavedStacks
(
trc
)
;
r
-
>
tracekWeakVarNames
(
trc
)
;
r
-
>
traceWeakObjects
(
trc
)
;
r
-
>
traceWeakSelfHostingScriptSource
(
trc
)
;
r
-
>
sweepDebugEnvironments
(
)
;
r
-
>
traceWeakEdgesInJitRealm
(
trc
)
;
r
-
>
traceWeakObjectRealm
(
trc
)
;
r
-
>
traceWeakTemplateObjects
(
trc
)
;
}
}
template
<
typename
T
>
static
inline
void
UpdateCellPointers
(
MovingTracer
*
trc
T
*
cell
)
{
cell
-
>
fixupAfterMovingGC
(
)
;
cell
-
>
traceChildren
(
trc
)
;
}
template
<
typename
T
>
static
void
UpdateArenaPointersTyped
(
MovingTracer
*
trc
Arena
*
arena
)
{
for
(
ArenaCellIterUnderGC
i
(
arena
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
UpdateCellPointers
(
trc
reinterpret_cast
<
T
*
>
(
i
.
getCell
(
)
)
)
;
}
}
static
void
UpdateArenaPointers
(
MovingTracer
*
trc
Arena
*
arena
)
{
AllocKind
kind
=
arena
-
>
getAllocKind
(
)
;
switch
(
kind
)
{
#
define
EXPAND_CASE
(
allocKind
traceKind
type
sizedType
bgFinal
nursery
\
compact
)
\
case
AllocKind
:
:
allocKind
:
\
UpdateArenaPointersTyped
<
type
>
(
trc
arena
)
;
\
return
;
FOR_EACH_ALLOCKIND
(
EXPAND_CASE
)
#
undef
EXPAND_CASE
default
:
MOZ_CRASH
(
"
Invalid
alloc
kind
for
UpdateArenaPointers
"
)
;
}
}
namespace
js
{
namespace
gc
{
struct
ArenaListSegment
{
Arena
*
begin
;
Arena
*
end
;
}
;
struct
ArenasToUpdate
{
ArenasToUpdate
(
Zone
*
zone
AllocKinds
kinds
)
;
bool
done
(
)
{
return
kind
=
=
AllocKind
:
:
LIMIT
;
}
ArenaListSegment
getArenasToUpdate
(
AutoLockHelperThreadState
&
lock
unsigned
maxLength
)
;
private
:
AllocKinds
kinds
;
Zone
*
zone
;
AllocKind
kind
;
Arena
*
arena
;
AllocKind
nextAllocKind
(
AllocKind
i
)
{
return
AllocKind
(
uint8_t
(
i
)
+
1
)
;
}
Arena
*
next
(
AutoLockHelperThreadState
&
lock
)
;
}
;
ArenasToUpdate
:
:
ArenasToUpdate
(
Zone
*
zone
AllocKinds
kinds
)
:
kinds
(
kinds
)
zone
(
zone
)
kind
(
AllocKind
:
:
FIRST
)
arena
(
nullptr
)
{
MOZ_ASSERT
(
zone
-
>
isGCCompacting
(
)
)
;
}
Arena
*
ArenasToUpdate
:
:
next
(
AutoLockHelperThreadState
&
lock
)
{
for
(
;
kind
<
AllocKind
:
:
LIMIT
;
kind
=
nextAllocKind
(
kind
)
)
{
if
(
kinds
.
contains
(
kind
)
)
{
if
(
!
arena
)
{
arena
=
zone
-
>
arenas
.
getFirstArena
(
kind
)
;
}
else
{
arena
=
arena
-
>
next
;
}
if
(
arena
)
{
return
arena
;
}
}
}
MOZ_ASSERT
(
!
arena
)
;
MOZ_ASSERT
(
done
(
)
)
;
return
nullptr
;
}
ArenaListSegment
ArenasToUpdate
:
:
getArenasToUpdate
(
AutoLockHelperThreadState
&
lock
unsigned
maxLength
)
{
Arena
*
begin
=
next
(
lock
)
;
if
(
!
begin
)
{
return
{
nullptr
nullptr
}
;
}
Arena
*
last
=
begin
;
unsigned
count
=
1
;
while
(
last
-
>
next
&
&
count
<
maxLength
)
{
last
=
last
-
>
next
;
count
+
+
;
}
arena
=
last
;
return
{
begin
last
-
>
next
}
;
}
struct
UpdatePointersTask
:
public
GCParallelTaskHelper
<
UpdatePointersTask
>
{
#
ifdef
DEBUG
static
const
unsigned
MaxArenasToProcess
=
16
;
#
else
static
const
unsigned
MaxArenasToProcess
=
256
;
#
endif
UpdatePointersTask
(
GCRuntime
*
gc
ArenasToUpdate
*
source
AutoLockHelperThreadState
&
lock
)
:
GCParallelTaskHelper
(
gc
)
source_
(
source
)
{
arenas_
.
begin
=
nullptr
;
arenas_
.
end
=
nullptr
;
}
void
run
(
)
;
private
:
ArenasToUpdate
*
source_
;
ArenaListSegment
arenas_
;
bool
getArenasToUpdate
(
)
;
void
updateArenas
(
)
;
}
;
bool
UpdatePointersTask
:
:
getArenasToUpdate
(
)
{
AutoLockHelperThreadState
lock
;
arenas_
=
source_
-
>
getArenasToUpdate
(
lock
MaxArenasToProcess
)
;
return
arenas_
.
begin
!
=
nullptr
;
}
void
UpdatePointersTask
:
:
updateArenas
(
)
{
MovingTracer
trc
(
gc
-
>
rt
)
;
for
(
Arena
*
arena
=
arenas_
.
begin
;
arena
!
=
arenas_
.
end
;
arena
=
arena
-
>
next
)
{
UpdateArenaPointers
(
&
trc
arena
)
;
}
}
void
UpdatePointersTask
:
:
run
(
)
{
AutoDisableProxyCheck
noProxyCheck
;
while
(
getArenasToUpdate
(
)
)
{
updateArenas
(
)
;
}
}
}
}
static
const
size_t
MinCellUpdateBackgroundTasks
=
2
;
static
const
size_t
MaxCellUpdateBackgroundTasks
=
8
;
static
size_t
CellUpdateBackgroundTaskCount
(
)
{
if
(
!
CanUseExtraThreads
(
)
)
{
return
0
;
}
size_t
targetTaskCount
=
HelperThreadState
(
)
.
cpuCount
/
2
;
return
std
:
:
min
(
std
:
:
max
(
targetTaskCount
MinCellUpdateBackgroundTasks
)
MaxCellUpdateBackgroundTasks
)
;
}
static
bool
CanUpdateKindInBackground
(
AllocKind
kind
)
{
if
(
!
js
:
:
gc
:
:
IsBackgroundFinalized
(
kind
)
|
|
IsShapeAllocKind
(
kind
)
)
{
return
false
;
}
return
true
;
}
static
AllocKinds
ForegroundUpdateKinds
(
AllocKinds
kinds
)
{
AllocKinds
result
;
for
(
AllocKind
kind
:
kinds
)
{
if
(
!
CanUpdateKindInBackground
(
kind
)
)
{
result
+
=
kind
;
}
}
return
result
;
}
void
GCRuntime
:
:
updateTypeDescrObjects
(
MovingTracer
*
trc
Zone
*
zone
)
{
zone
-
>
typeDescrObjects
(
)
.
sweep
(
)
;
for
(
auto
r
=
zone
-
>
typeDescrObjects
(
)
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
NativeObject
*
obj
=
&
r
.
front
(
)
-
>
as
<
NativeObject
>
(
)
;
UpdateCellPointers
(
trc
obj
)
;
for
(
size_t
i
=
0
;
i
<
obj
-
>
slotSpan
(
)
;
i
+
+
)
{
Value
value
=
obj
-
>
getSlot
(
i
)
;
if
(
value
.
isObject
(
)
)
{
UpdateCellPointers
(
trc
&
value
.
toObject
(
)
)
;
}
}
}
}
void
GCRuntime
:
:
updateCellPointers
(
Zone
*
zone
AllocKinds
kinds
size_t
bgTaskCount
)
{
AllocKinds
fgKinds
=
bgTaskCount
=
=
0
?
kinds
:
ForegroundUpdateKinds
(
kinds
)
;
AllocKinds
bgKinds
=
kinds
-
fgKinds
;
ArenasToUpdate
fgArenas
(
zone
fgKinds
)
;
ArenasToUpdate
bgArenas
(
zone
bgKinds
)
;
Maybe
<
UpdatePointersTask
>
fgTask
;
Maybe
<
UpdatePointersTask
>
bgTasks
[
MaxCellUpdateBackgroundTasks
]
;
size_t
tasksStarted
=
0
;
{
AutoLockHelperThreadState
lock
;
fgTask
.
emplace
(
this
&
fgArenas
lock
)
;
for
(
size_t
i
=
0
;
i
<
bgTaskCount
&
&
!
bgArenas
.
done
(
)
;
i
+
+
)
{
bgTasks
[
i
]
.
emplace
(
this
&
bgArenas
lock
)
;
startTask
(
*
bgTasks
[
i
]
gcstats
:
:
PhaseKind
:
:
COMPACT_UPDATE_CELLS
lock
)
;
tasksStarted
+
+
;
}
}
fgTask
-
>
runFromMainThread
(
)
;
{
AutoLockHelperThreadState
lock
;
for
(
size_t
i
=
0
;
i
<
tasksStarted
;
i
+
+
)
{
joinTask
(
*
bgTasks
[
i
]
gcstats
:
:
PhaseKind
:
:
COMPACT_UPDATE_CELLS
lock
)
;
}
for
(
size_t
i
=
tasksStarted
;
i
<
MaxCellUpdateBackgroundTasks
;
i
+
+
)
{
MOZ_ASSERT
(
bgTasks
[
i
]
.
isNothing
(
)
)
;
}
}
}
static
constexpr
AllocKinds
UpdatePhaseOne
{
AllocKind
:
:
SCRIPT
AllocKind
:
:
BASE_SHAPE
AllocKind
:
:
SHAPE
AllocKind
:
:
ACCESSOR_SHAPE
AllocKind
:
:
OBJECT_GROUP
AllocKind
:
:
STRING
AllocKind
:
:
JITCODE
}
;
static
constexpr
AllocKinds
UpdatePhaseThree
{
AllocKind
:
:
LAZY_SCRIPT
AllocKind
:
:
SCOPE
AllocKind
:
:
FUNCTION
AllocKind
:
:
FUNCTION_EXTENDED
AllocKind
:
:
OBJECT0
AllocKind
:
:
OBJECT0_BACKGROUND
AllocKind
:
:
OBJECT2
AllocKind
:
:
OBJECT2_BACKGROUND
AllocKind
:
:
ARRAYBUFFER4
AllocKind
:
:
OBJECT4
AllocKind
:
:
OBJECT4_BACKGROUND
AllocKind
:
:
ARRAYBUFFER8
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT8_BACKGROUND
AllocKind
:
:
ARRAYBUFFER12
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT12_BACKGROUND
AllocKind
:
:
ARRAYBUFFER16
AllocKind
:
:
OBJECT16
AllocKind
:
:
OBJECT16_BACKGROUND
}
;
void
GCRuntime
:
:
updateAllCellPointers
(
MovingTracer
*
trc
Zone
*
zone
)
{
size_t
bgTaskCount
=
CellUpdateBackgroundTaskCount
(
)
;
updateCellPointers
(
zone
UpdatePhaseOne
bgTaskCount
)
;
updateTypeDescrObjects
(
trc
zone
)
;
updateCellPointers
(
zone
UpdatePhaseThree
bgTaskCount
)
;
}
void
GCRuntime
:
:
updateZonePointersToRelocatedCells
(
Zone
*
zone
)
{
MOZ_ASSERT
(
!
rt
-
>
isBeingDestroyed
(
)
)
;
MOZ_ASSERT
(
zone
-
>
isGCCompacting
(
)
)
;
AutoTouchingGrayThings
tgt
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
COMPACT_UPDATE
)
;
MovingTracer
trc
(
rt
)
;
zone
-
>
fixupAfterMovingGC
(
)
;
zone
-
>
fixupScriptMapsAfterMovingGC
(
&
trc
)
;
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
comp
-
>
fixupAfterMovingGC
(
&
trc
)
;
}
zone
-
>
externalStringCache
(
)
.
purge
(
)
;
zone
-
>
functionToStringCache
(
)
.
purge
(
)
;
updateAllCellPointers
(
&
trc
zone
)
;
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_ROOTS
)
;
WeakMapBase
:
:
traceZone
(
zone
&
trc
)
;
}
sweepZoneAfterCompacting
(
&
trc
zone
)
;
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
callWeakPointerCompartmentCallbacks
(
comp
)
;
}
}
void
GCRuntime
:
:
updateRuntimePointersToRelocatedCells
(
AutoGCSession
&
session
)
{
MOZ_ASSERT
(
!
rt
-
>
isBeingDestroyed
(
)
)
;
gcstats
:
:
AutoPhase
ap1
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
COMPACT_UPDATE
)
;
MovingTracer
trc
(
rt
)
;
Zone
:
:
fixupAllCrossCompartmentWrappersAfterMovingGC
(
&
trc
)
;
rt
-
>
geckoProfiler
(
)
.
fixupStringsMapAfterMovingGC
(
)
;
traceRuntimeForMajorGC
(
&
trc
session
)
;
{
gcstats
:
:
AutoPhase
ap2
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_ROOTS
)
;
DebugAPI
:
:
traceAllForMovingGC
(
&
trc
)
;
DebugAPI
:
:
traceCrossCompartmentEdges
(
&
trc
)
;
traceEmbeddingGrayRoots
(
&
trc
)
;
Compartment
:
:
traceIncomingCrossCompartmentEdgesForZoneGC
(
&
trc
Compartment
:
:
GrayEdges
)
;
}
DebugAPI
:
:
sweepAll
(
rt
-
>
defaultFreeOp
(
)
)
;
jit
:
:
JitRuntime
:
:
TraceWeakJitcodeGlobalTable
(
rt
&
trc
)
;
for
(
JS
:
:
detail
:
:
WeakCacheBase
*
cache
:
rt
-
>
weakCaches
(
)
)
{
cache
-
>
sweep
(
)
;
}
{
AutoLockHelperThreadState
lock
;
lifoBlocksToFree
.
ref
(
)
.
freeAll
(
)
;
}
callWeakPointerZonesCallbacks
(
)
;
}
void
GCRuntime
:
:
clearRelocatedArenas
(
Arena
*
arenaList
JS
:
:
GCReason
reason
)
{
AutoLockGC
lock
(
this
)
;
clearRelocatedArenasWithoutUnlocking
(
arenaList
reason
lock
)
;
}
void
GCRuntime
:
:
clearRelocatedArenasWithoutUnlocking
(
Arena
*
arenaList
JS
:
:
GCReason
reason
const
AutoLockGC
&
lock
)
{
while
(
arenaList
)
{
Arena
*
arena
=
arenaList
;
arenaList
=
arenaList
-
>
next
;
arena
-
>
unmarkAll
(
)
;
arena
-
>
setAsFullyUnused
(
)
;
AlwaysPoison
(
reinterpret_cast
<
void
*
>
(
arena
-
>
thingsStart
(
)
)
JS_MOVED_TENURED_PATTERN
arena
-
>
getThingsSpan
(
)
MemCheckKind
:
:
MakeNoAccess
)
;
bool
allArenasRelocated
=
ShouldRelocateAllArenas
(
reason
)
;
arena
-
>
zone
-
>
gcHeapSize
.
removeBytes
(
ArenaSize
!
allArenasRelocated
)
;
arena
-
>
release
(
lock
)
;
}
}
void
GCRuntime
:
:
protectAndHoldArenas
(
Arena
*
arenaList
)
{
for
(
Arena
*
arena
=
arenaList
;
arena
;
)
{
MOZ_ASSERT
(
!
arena
-
>
allocated
(
)
)
;
Arena
*
next
=
arena
-
>
next
;
if
(
!
next
)
{
arena
-
>
next
=
relocatedArenasToRelease
;
relocatedArenasToRelease
=
arenaList
;
}
ProtectPages
(
arena
ArenaSize
)
;
arena
=
next
;
}
}
void
GCRuntime
:
:
unprotectHeldRelocatedArenas
(
)
{
for
(
Arena
*
arena
=
relocatedArenasToRelease
;
arena
;
arena
=
arena
-
>
next
)
{
UnprotectPages
(
arena
ArenaSize
)
;
MOZ_ASSERT
(
!
arena
-
>
allocated
(
)
)
;
}
}
void
GCRuntime
:
:
releaseRelocatedArenas
(
Arena
*
arenaList
)
{
AutoLockGC
lock
(
this
)
;
releaseRelocatedArenasWithoutUnlocking
(
arenaList
lock
)
;
}
void
GCRuntime
:
:
releaseRelocatedArenasWithoutUnlocking
(
Arena
*
arenaList
const
AutoLockGC
&
lock
)
{
while
(
arenaList
)
{
Arena
*
arena
=
arenaList
;
arenaList
=
arenaList
-
>
next
;
arena
-
>
chunk
(
)
-
>
releaseArena
(
this
arena
lock
)
;
}
}
void
GCRuntime
:
:
releaseHeldRelocatedArenas
(
)
{
#
ifdef
DEBUG
unprotectHeldRelocatedArenas
(
)
;
Arena
*
arenas
=
relocatedArenasToRelease
;
relocatedArenasToRelease
=
nullptr
;
releaseRelocatedArenas
(
arenas
)
;
#
endif
}
void
GCRuntime
:
:
releaseHeldRelocatedArenasWithoutUnlocking
(
const
AutoLockGC
&
lock
)
{
#
ifdef
DEBUG
unprotectHeldRelocatedArenas
(
)
;
releaseRelocatedArenasWithoutUnlocking
(
relocatedArenasToRelease
lock
)
;
relocatedArenasToRelease
=
nullptr
;
#
endif
}
FreeLists
:
:
FreeLists
(
)
{
for
(
auto
i
:
AllAllocKinds
(
)
)
{
freeLists_
[
i
]
=
&
emptySentinel
;
}
}
ArenaLists
:
:
ArenaLists
(
Zone
*
zone
)
:
zone_
(
zone
)
freeLists_
(
zone
)
arenaLists_
(
zone
)
arenaListsToSweep_
(
)
incrementalSweptArenaKind
(
zone
AllocKind
:
:
LIMIT
)
incrementalSweptArenas
(
zone
)
gcShapeArenasToUpdate
(
zone
nullptr
)
gcAccessorShapeArenasToUpdate
(
zone
nullptr
)
gcScriptArenasToUpdate
(
zone
nullptr
)
gcObjectGroupArenasToUpdate
(
zone
nullptr
)
savedEmptyArenas
(
zone
nullptr
)
{
for
(
auto
i
:
AllAllocKinds
(
)
)
{
concurrentUse
(
i
)
=
ConcurrentUse
:
:
None
;
arenaListsToSweep
(
i
)
=
nullptr
;
}
}
void
ReleaseArenaList
(
JSRuntime
*
rt
Arena
*
arena
const
AutoLockGC
&
lock
)
{
Arena
*
next
;
for
(
;
arena
;
arena
=
next
)
{
next
=
arena
-
>
next
;
rt
-
>
gc
.
releaseArena
(
arena
lock
)
;
}
}
ArenaLists
:
:
~
ArenaLists
(
)
{
AutoLockGC
lock
(
runtime
(
)
)
;
for
(
auto
i
:
AllAllocKinds
(
)
)
{
MOZ_ASSERT
(
concurrentUse
(
i
)
=
=
ConcurrentUse
:
:
None
)
;
ReleaseArenaList
(
runtime
(
)
arenaLists
(
i
)
.
head
(
)
lock
)
;
}
ReleaseArenaList
(
runtime
(
)
incrementalSweptArenas
.
ref
(
)
.
head
(
)
lock
)
;
ReleaseArenaList
(
runtime
(
)
savedEmptyArenas
lock
)
;
}
void
ArenaLists
:
:
queueForForegroundSweep
(
JSFreeOp
*
fop
const
FinalizePhase
&
phase
)
{
gcstats
:
:
AutoPhase
ap
(
fop
-
>
runtime
(
)
-
>
gc
.
stats
(
)
phase
.
statsPhase
)
;
for
(
auto
kind
:
phase
.
kinds
)
{
queueForForegroundSweep
(
kind
)
;
}
}
void
ArenaLists
:
:
queueForForegroundSweep
(
AllocKind
thingKind
)
{
MOZ_ASSERT
(
!
IsBackgroundFinalized
(
thingKind
)
)
;
MOZ_ASSERT
(
concurrentUse
(
thingKind
)
=
=
ConcurrentUse
:
:
None
)
;
MOZ_ASSERT
(
!
arenaListsToSweep
(
thingKind
)
)
;
arenaListsToSweep
(
thingKind
)
=
arenaLists
(
thingKind
)
.
head
(
)
;
arenaLists
(
thingKind
)
.
clear
(
)
;
}
void
ArenaLists
:
:
queueForBackgroundSweep
(
JSFreeOp
*
fop
const
FinalizePhase
&
phase
)
{
gcstats
:
:
AutoPhase
ap
(
fop
-
>
runtime
(
)
-
>
gc
.
stats
(
)
phase
.
statsPhase
)
;
for
(
auto
kind
:
phase
.
kinds
)
{
queueForBackgroundSweep
(
kind
)
;
}
}
inline
void
ArenaLists
:
:
queueForBackgroundSweep
(
AllocKind
thingKind
)
{
MOZ_ASSERT
(
IsBackgroundFinalized
(
thingKind
)
)
;
ArenaList
*
al
=
&
arenaLists
(
thingKind
)
;
if
(
al
-
>
isEmpty
(
)
)
{
MOZ_ASSERT
(
concurrentUse
(
thingKind
)
=
=
ConcurrentUse
:
:
None
)
;
return
;
}
MOZ_ASSERT
(
concurrentUse
(
thingKind
)
=
=
ConcurrentUse
:
:
None
)
;
arenaListsToSweep
(
thingKind
)
=
al
-
>
head
(
)
;
al
-
>
clear
(
)
;
concurrentUse
(
thingKind
)
=
ConcurrentUse
:
:
BackgroundFinalize
;
}
void
ArenaLists
:
:
backgroundFinalize
(
JSFreeOp
*
fop
Arena
*
listHead
Arena
*
*
empty
)
{
MOZ_ASSERT
(
listHead
)
;
MOZ_ASSERT
(
empty
)
;
AllocKind
thingKind
=
listHead
-
>
getAllocKind
(
)
;
Zone
*
zone
=
listHead
-
>
zone
;
size_t
thingsPerArena
=
Arena
:
:
thingsPerArena
(
thingKind
)
;
SortedArenaList
finalizedSorted
(
thingsPerArena
)
;
auto
unlimited
=
SliceBudget
:
:
unlimited
(
)
;
FinalizeArenas
(
fop
&
listHead
finalizedSorted
thingKind
unlimited
)
;
MOZ_ASSERT
(
!
listHead
)
;
finalizedSorted
.
extractEmpty
(
empty
)
;
ArenaLists
*
lists
=
&
zone
-
>
arenas
;
ArenaList
*
al
=
&
lists
-
>
arenaLists
(
thingKind
)
;
ArenaList
finalized
=
finalizedSorted
.
toArenaList
(
)
;
{
AutoLockGC
lock
(
lists
-
>
runtimeFromAnyThread
(
)
)
;
MOZ_ASSERT
(
lists
-
>
concurrentUse
(
thingKind
)
=
=
ConcurrentUse
:
:
BackgroundFinalize
)
;
*
al
=
finalized
.
insertListWithCursorAtEnd
(
*
al
)
;
lists
-
>
arenaListsToSweep
(
thingKind
)
=
nullptr
;
}
lists
-
>
concurrentUse
(
thingKind
)
=
ConcurrentUse
:
:
None
;
}
void
ArenaLists
:
:
releaseForegroundSweptEmptyArenas
(
)
{
AutoLockGC
lock
(
runtime
(
)
)
;
ReleaseArenaList
(
runtime
(
)
savedEmptyArenas
lock
)
;
savedEmptyArenas
=
nullptr
;
}
void
ArenaLists
:
:
queueForegroundThingsForSweep
(
)
{
gcShapeArenasToUpdate
=
arenaListsToSweep
(
AllocKind
:
:
SHAPE
)
;
gcAccessorShapeArenasToUpdate
=
arenaListsToSweep
(
AllocKind
:
:
ACCESSOR_SHAPE
)
;
gcObjectGroupArenasToUpdate
=
arenaListsToSweep
(
AllocKind
:
:
OBJECT_GROUP
)
;
gcScriptArenasToUpdate
=
arenaListsToSweep
(
AllocKind
:
:
SCRIPT
)
;
}
TimeStamp
SliceBudget
:
:
unlimitedDeadline
;
void
SliceBudget
:
:
Init
(
)
{
MOZ_ASSERT
(
!
unlimitedDeadline
)
;
uint64_t
oneYearsInSeconds
=
365
*
24
*
60
*
60
;
unlimitedDeadline
=
ReallyNow
(
)
+
TimeDuration
:
:
FromSeconds
(
100
*
oneYearsInSeconds
)
;
}
SliceBudget
:
:
SliceBudget
(
)
:
timeBudget
(
UnlimitedTimeBudget
)
workBudget
(
UnlimitedWorkBudget
)
{
makeUnlimited
(
)
;
}
SliceBudget
:
:
SliceBudget
(
TimeBudget
time
)
:
timeBudget
(
time
)
workBudget
(
UnlimitedWorkBudget
)
{
if
(
time
.
budget
<
0
)
{
makeUnlimited
(
)
;
}
else
{
deadline
=
ReallyNow
(
)
+
TimeDuration
:
:
FromMilliseconds
(
time
.
budget
)
;
counter
=
CounterReset
;
}
}
SliceBudget
:
:
SliceBudget
(
WorkBudget
work
)
:
timeBudget
(
UnlimitedTimeBudget
)
workBudget
(
work
)
{
if
(
work
.
budget
<
0
)
{
makeUnlimited
(
)
;
}
else
{
deadline
=
TimeStamp
(
)
;
counter
=
work
.
budget
;
}
}
int
SliceBudget
:
:
describe
(
char
*
buffer
size_t
maxlen
)
const
{
if
(
isUnlimited
(
)
)
{
return
snprintf
(
buffer
maxlen
"
unlimited
"
)
;
}
else
if
(
isWorkBudget
(
)
)
{
return
snprintf
(
buffer
maxlen
"
work
(
%
"
PRId64
"
)
"
workBudget
.
budget
)
;
}
else
{
return
snprintf
(
buffer
maxlen
"
%
"
PRId64
"
ms
"
timeBudget
.
budget
)
;
}
}
bool
SliceBudget
:
:
checkOverBudget
(
)
{
if
(
deadline
.
IsNull
(
)
)
{
return
true
;
}
bool
over
=
ReallyNow
(
)
>
=
deadline
;
if
(
!
over
)
{
counter
=
CounterReset
;
}
return
over
;
}
void
GCRuntime
:
:
requestMajorGC
(
JS
:
:
GCReason
reason
)
{
MOZ_ASSERT
(
!
CurrentThreadIsPerformingGC
(
)
)
;
if
(
majorGCRequested
(
)
)
{
return
;
}
majorGCTriggerReason
=
reason
;
rt
-
>
mainContextFromOwnThread
(
)
-
>
requestInterrupt
(
InterruptReason
:
:
GC
)
;
}
void
Nursery
:
:
requestMinorGC
(
JS
:
:
GCReason
reason
)
const
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime
(
)
)
)
;
MOZ_ASSERT
(
!
CurrentThreadIsPerformingGC
(
)
)
;
if
(
minorGCRequested
(
)
)
{
return
;
}
minorGCTriggerReason_
=
reason
;
runtime
(
)
-
>
mainContextFromOwnThread
(
)
-
>
requestInterrupt
(
InterruptReason
:
:
GC
)
;
}
static
bool
RecordReplayCheckCanGC
(
JS
:
:
GCReason
reason
)
{
if
(
!
mozilla
:
:
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
return
true
;
}
switch
(
reason
)
{
case
JS
:
:
GCReason
:
:
EAGER_ALLOC_TRIGGER
:
case
JS
:
:
GCReason
:
:
LAST_DITCH
:
case
JS
:
:
GCReason
:
:
TOO_MUCH_MALLOC
:
case
JS
:
:
GCReason
:
:
ALLOC_TRIGGER
:
case
JS
:
:
GCReason
:
:
DELAYED_ATOMS_GC
:
case
JS
:
:
GCReason
:
:
TOO_MUCH_WASM_MEMORY
:
case
JS
:
:
GCReason
:
:
TOO_MUCH_JIT_CODE
:
case
JS
:
:
GCReason
:
:
INCREMENTAL_ALLOC_TRIGGER
:
return
false
;
default
:
break
;
}
mozilla
:
:
recordreplay
:
:
RecordReplayAssert
(
"
RecordReplayCheckCanGC
%
d
"
(
int
)
reason
)
;
return
true
;
}
bool
GCRuntime
:
:
triggerGC
(
JS
:
:
GCReason
reason
)
{
if
(
!
CurrentThreadCanAccessRuntime
(
rt
)
)
{
return
false
;
}
if
(
JS
:
:
RuntimeHeapIsCollecting
(
)
)
{
return
false
;
}
if
(
!
RecordReplayCheckCanGC
(
reason
)
)
{
return
false
;
}
JS
:
:
PrepareForFullGC
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
requestMajorGC
(
reason
)
;
return
true
;
}
void
GCRuntime
:
:
maybeAllocTriggerZoneGC
(
Zone
*
zone
size_t
nbytes
)
{
if
(
!
CurrentThreadCanAccessRuntime
(
rt
)
)
{
MOZ_ASSERT
(
zone
-
>
usedByHelperThread
(
)
|
|
zone
-
>
isAtomsZone
(
)
)
;
return
;
}
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
TriggerResult
trigger
=
checkHeapThreshold
(
zone
-
>
gcHeapSize
zone
-
>
gcHeapThreshold
zone
-
>
isCollecting
(
)
)
;
if
(
trigger
.
kind
=
=
TriggerKind
:
:
None
)
{
return
;
}
if
(
trigger
.
kind
=
=
TriggerKind
:
:
NonIncremental
)
{
triggerZoneGC
(
zone
JS
:
:
GCReason
:
:
ALLOC_TRIGGER
trigger
.
usedBytes
trigger
.
thresholdBytes
)
;
return
;
}
MOZ_ASSERT
(
trigger
.
kind
=
=
TriggerKind
:
:
Incremental
)
;
if
(
zone
-
>
gcDelayBytes
<
nbytes
)
{
zone
-
>
gcDelayBytes
=
0
;
}
else
{
zone
-
>
gcDelayBytes
-
=
nbytes
;
}
if
(
!
zone
-
>
gcDelayBytes
)
{
triggerZoneGC
(
zone
JS
:
:
GCReason
:
:
INCREMENTAL_ALLOC_TRIGGER
trigger
.
usedBytes
trigger
.
thresholdBytes
)
;
zone
-
>
gcDelayBytes
=
tunables
.
zoneAllocDelayBytes
(
)
;
}
}
void
js
:
:
gc
:
:
MaybeMallocTriggerZoneGC
(
JSRuntime
*
rt
ZoneAllocator
*
zoneAlloc
const
HeapSize
&
heap
const
HeapThreshold
&
threshold
JS
:
:
GCReason
reason
)
{
rt
-
>
gc
.
maybeMallocTriggerZoneGC
(
Zone
:
:
from
(
zoneAlloc
)
heap
threshold
reason
)
;
}
void
GCRuntime
:
:
maybeMallocTriggerZoneGC
(
Zone
*
zone
)
{
if
(
maybeMallocTriggerZoneGC
(
zone
zone
-
>
mallocHeapSize
zone
-
>
mallocHeapThreshold
JS
:
:
GCReason
:
:
TOO_MUCH_MALLOC
)
)
{
return
;
}
maybeMallocTriggerZoneGC
(
zone
zone
-
>
jitHeapSize
zone
-
>
jitHeapThreshold
JS
:
:
GCReason
:
:
TOO_MUCH_JIT_CODE
)
;
}
bool
GCRuntime
:
:
maybeMallocTriggerZoneGC
(
Zone
*
zone
const
HeapSize
&
heap
const
HeapThreshold
&
threshold
JS
:
:
GCReason
reason
)
{
if
(
!
CurrentThreadCanAccessRuntime
(
rt
)
)
{
MOZ_ASSERT
(
zone
-
>
usedByHelperThread
(
)
|
|
zone
-
>
isAtomsZone
(
)
|
|
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
return
false
;
}
if
(
rt
-
>
heapState
(
)
!
=
JS
:
:
HeapState
:
:
Idle
)
{
return
false
;
}
TriggerResult
trigger
=
checkHeapThreshold
(
heap
threshold
zone
-
>
isCollecting
(
)
)
;
if
(
trigger
.
kind
=
=
TriggerKind
:
:
None
)
{
return
false
;
}
if
(
trigger
.
kind
=
=
TriggerKind
:
:
Incremental
&
&
zone
-
>
wasGCStarted
(
)
)
{
MOZ_ASSERT
(
isIncrementalGCInProgress
(
)
)
;
return
false
;
}
triggerZoneGC
(
zone
reason
trigger
.
usedBytes
trigger
.
thresholdBytes
)
;
return
true
;
}
TriggerResult
GCRuntime
:
:
checkHeapThreshold
(
const
HeapSize
&
heapSize
const
HeapThreshold
&
heapThreshold
bool
isCollecting
)
{
size_t
usedBytes
=
heapSize
.
bytes
(
)
;
size_t
thresholdBytes
=
heapThreshold
.
bytes
(
)
;
if
(
usedBytes
<
thresholdBytes
)
{
return
TriggerResult
{
TriggerKind
:
:
None
0
0
}
;
}
size_t
niThreshold
=
thresholdBytes
*
tunables
.
nonIncrementalFactor
(
)
;
if
(
usedBytes
>
=
niThreshold
)
{
return
TriggerResult
{
TriggerKind
:
:
NonIncremental
usedBytes
niThreshold
}
;
}
if
(
isIncrementalGCInProgress
(
)
&
&
!
isCollecting
&
&
usedBytes
<
thresholdBytes
*
tunables
.
avoidInterruptFactor
(
)
)
{
return
TriggerResult
{
TriggerKind
:
:
None
0
0
}
;
}
return
TriggerResult
{
TriggerKind
:
:
Incremental
usedBytes
thresholdBytes
}
;
}
bool
GCRuntime
:
:
triggerZoneGC
(
Zone
*
zone
JS
:
:
GCReason
reason
size_t
used
size_t
threshold
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
if
(
JS
:
:
RuntimeHeapIsBusy
(
)
)
{
return
false
;
}
if
(
!
RecordReplayCheckCanGC
(
reason
)
)
{
return
false
;
}
#
ifdef
JS_GC_ZEAL
if
(
hasZealMode
(
ZealMode
:
:
Alloc
)
)
{
MOZ_RELEASE_ASSERT
(
triggerGC
(
reason
)
)
;
return
true
;
}
#
endif
if
(
zone
-
>
isAtomsZone
(
)
)
{
if
(
rt
-
>
hasHelperThreadZones
(
)
)
{
fullGCForAtomsRequested_
=
true
;
return
false
;
}
stats
(
)
.
recordTrigger
(
used
threshold
)
;
MOZ_RELEASE_ASSERT
(
triggerGC
(
reason
)
)
;
return
true
;
}
stats
(
)
.
recordTrigger
(
used
threshold
)
;
PrepareZoneForGC
(
zone
)
;
requestMajorGC
(
reason
)
;
return
true
;
}
void
GCRuntime
:
:
maybeGC
(
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
#
ifdef
JS_GC_ZEAL
if
(
hasZealMode
(
ZealMode
:
:
Alloc
)
|
|
hasZealMode
(
ZealMode
:
:
RootsChange
)
)
{
JS
:
:
PrepareForFullGC
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
gc
(
GC_NORMAL
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
return
;
}
#
endif
if
(
gcIfRequested
(
)
)
{
return
;
}
if
(
isIncrementalGCInProgress
(
)
)
{
return
;
}
bool
scheduledZones
=
false
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
checkEagerAllocTrigger
(
zone
-
>
gcHeapSize
zone
-
>
gcHeapThreshold
)
|
|
checkEagerAllocTrigger
(
zone
-
>
mallocHeapSize
zone
-
>
mallocHeapThreshold
)
)
{
zone
-
>
scheduleGC
(
)
;
scheduledZones
=
true
;
}
}
if
(
scheduledZones
)
{
startGC
(
GC_NORMAL
JS
:
:
GCReason
:
:
EAGER_ALLOC_TRIGGER
)
;
}
}
bool
GCRuntime
:
:
checkEagerAllocTrigger
(
const
HeapSize
&
size
const
HeapThreshold
&
threshold
)
{
float
thresholdBytes
=
threshold
.
eagerAllocTrigger
(
schedulingState
.
inHighFrequencyGCMode
(
)
)
;
float
usedBytes
=
size
.
bytes
(
)
;
if
(
usedBytes
<
=
1024
*
1024
|
|
usedBytes
<
thresholdBytes
)
{
return
false
;
}
stats
(
)
.
recordTrigger
(
usedBytes
thresholdBytes
)
;
return
true
;
}
void
GCRuntime
:
:
triggerFullGCForAtoms
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
fullGCForAtomsRequested_
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
MOZ_ASSERT
(
cx
-
>
canCollectAtoms
(
)
)
;
fullGCForAtomsRequested_
=
false
;
MOZ_RELEASE_ASSERT
(
triggerGC
(
JS
:
:
GCReason
:
:
DELAYED_ATOMS_GC
)
)
;
}
void
GCRuntime
:
:
decommitFreeArenasWithoutUnlocking
(
const
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
emptyChunks
(
lock
)
.
count
(
)
=
=
0
)
;
for
(
ChunkPool
:
:
Iter
chunk
(
availableChunks
(
lock
)
)
;
!
chunk
.
done
(
)
;
chunk
.
next
(
)
)
{
chunk
-
>
decommitFreeArenasWithoutUnlocking
(
lock
)
;
}
MOZ_ASSERT
(
availableChunks
(
lock
)
.
verify
(
)
)
;
}
void
GCRuntime
:
:
startDecommit
(
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
DECOMMIT
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
MOZ_ASSERT
(
decommitTask
.
isIdle
(
)
)
;
if
(
schedulingState
.
inHighFrequencyGCMode
(
)
&
&
!
cleanUpEverything
)
{
return
;
}
BackgroundDecommitTask
:
:
ChunkVector
toDecommit
;
{
AutoLockGC
lock
(
this
)
;
for
(
ChunkPool
:
:
Iter
chunk
(
emptyChunks
(
lock
)
)
;
!
chunk
.
done
(
)
;
chunk
.
next
(
)
)
{
MOZ_ASSERT
(
!
chunk
-
>
info
.
numArenasFreeCommitted
)
;
}
MOZ_ASSERT
(
availableChunks
(
lock
)
.
verify
(
)
)
;
availableChunks
(
lock
)
.
sort
(
)
;
for
(
ChunkPool
:
:
Iter
iter
(
availableChunks
(
lock
)
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
if
(
!
toDecommit
.
append
(
iter
.
get
(
)
)
)
{
return
onOutOfMallocMemory
(
lock
)
;
}
}
}
decommitTask
.
setChunksToScan
(
toDecommit
)
;
if
(
sweepOnBackgroundThread
)
{
decommitTask
.
start
(
)
;
return
;
}
decommitTask
.
runFromMainThread
(
)
;
}
void
js
:
:
gc
:
:
BackgroundDecommitTask
:
:
setChunksToScan
(
ChunkVector
&
chunks
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
gc
-
>
rt
)
)
;
MOZ_ASSERT
(
isIdle
(
)
)
;
MOZ_ASSERT
(
toDecommit
.
ref
(
)
.
empty
(
)
)
;
Swap
(
toDecommit
.
ref
(
)
chunks
)
;
}
void
js
:
:
gc
:
:
BackgroundDecommitTask
:
:
run
(
)
{
AutoLockGC
lock
(
gc
)
;
for
(
Chunk
*
chunk
:
toDecommit
.
ref
(
)
)
{
while
(
chunk
-
>
info
.
numArenasFreeCommitted
)
{
bool
ok
=
chunk
-
>
decommitOneFreeArena
(
gc
lock
)
;
if
(
cancel_
|
|
!
ok
)
{
break
;
}
}
}
toDecommit
.
ref
(
)
.
clearAndFree
(
)
;
ChunkPool
toFree
=
gc
-
>
expireEmptyChunkPool
(
lock
)
;
if
(
toFree
.
count
(
)
)
{
AutoUnlockGC
unlock
(
lock
)
;
FreeChunkPool
(
toFree
)
;
}
}
void
GCRuntime
:
:
sweepBackgroundThings
(
ZoneList
&
zones
LifoAlloc
&
freeBlocks
)
{
freeBlocks
.
freeAll
(
)
;
if
(
zones
.
isEmpty
(
)
)
{
return
;
}
JSFreeOp
fop
(
nullptr
)
;
while
(
!
zones
.
isEmpty
(
)
)
{
Zone
*
zone
=
zones
.
removeFront
(
)
;
Arena
*
emptyArenas
=
nullptr
;
AutoSetThreadIsSweeping
threadIsSweeping
(
zone
)
;
for
(
auto
phase
:
BackgroundFinalizePhases
)
{
for
(
auto
kind
:
phase
.
kinds
)
{
Arena
*
arenas
=
zone
-
>
arenas
.
arenaListsToSweep
(
kind
)
;
MOZ_RELEASE_ASSERT
(
uintptr_t
(
arenas
)
!
=
uintptr_t
(
-
1
)
)
;
if
(
arenas
)
{
ArenaLists
:
:
backgroundFinalize
(
&
fop
arenas
&
emptyArenas
)
;
}
}
}
static
const
size_t
LockReleasePeriod
=
32
;
while
(
emptyArenas
)
{
AutoLockGC
lock
(
this
)
;
for
(
size_t
i
=
0
;
i
<
LockReleasePeriod
&
&
emptyArenas
;
i
+
+
)
{
Arena
*
arena
=
emptyArenas
;
emptyArenas
=
emptyArenas
-
>
next
;
releaseArena
(
arena
lock
)
;
}
zone
-
>
updateGCThresholds
(
*
this
invocationKind
lock
)
;
}
}
}
void
GCRuntime
:
:
assertBackgroundSweepingFinished
(
)
{
#
ifdef
DEBUG
{
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
backgroundSweepZones
.
ref
(
)
.
isEmpty
(
)
)
;
}
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
auto
i
:
AllAllocKinds
(
)
)
{
MOZ_ASSERT
(
!
zone
-
>
arenas
.
arenaListsToSweep
(
i
)
)
;
MOZ_ASSERT
(
zone
-
>
arenas
.
doneBackgroundFinalize
(
i
)
)
;
}
}
#
endif
}
void
GCRuntime
:
:
queueZonesAndStartBackgroundSweep
(
ZoneList
&
zones
)
{
{
AutoLockHelperThreadState
lock
;
backgroundSweepZones
.
ref
(
)
.
transferFrom
(
zones
)
;
if
(
sweepOnBackgroundThread
)
{
sweepTask
.
startOrRunIfIdle
(
lock
)
;
}
}
if
(
!
sweepOnBackgroundThread
)
{
sweepTask
.
join
(
)
;
sweepTask
.
runFromMainThread
(
)
;
}
}
void
BackgroundSweepTask
:
:
run
(
)
{
AutoTraceLog
logSweeping
(
TraceLoggerForCurrentThread
(
)
TraceLogger_GCSweeping
)
;
AutoLockHelperThreadState
lock
;
gc
-
>
sweepFromBackgroundThread
(
lock
)
;
setFinishing
(
lock
)
;
}
void
GCRuntime
:
:
sweepFromBackgroundThread
(
AutoLockHelperThreadState
&
lock
)
{
do
{
ZoneList
zones
;
zones
.
transferFrom
(
backgroundSweepZones
.
ref
(
)
)
;
LifoAlloc
freeLifoAlloc
(
JSContext
:
:
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
)
;
freeLifoAlloc
.
transferFrom
(
&
lifoBlocksToFree
.
ref
(
)
)
;
AutoUnlockHelperThreadState
unlock
(
lock
)
;
sweepBackgroundThings
(
zones
freeLifoAlloc
)
;
}
while
(
!
backgroundSweepZones
.
ref
(
)
.
isEmpty
(
)
)
;
}
void
GCRuntime
:
:
waitBackgroundSweepEnd
(
)
{
sweepTask
.
join
(
)
;
if
(
!
isIncrementalGCInProgress
(
)
)
{
assertBackgroundSweepingFinished
(
)
;
}
}
void
GCRuntime
:
:
queueUnusedLifoBlocksForFree
(
LifoAlloc
*
lifo
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
AutoLockHelperThreadState
lock
;
lifoBlocksToFree
.
ref
(
)
.
transferUnusedFrom
(
lifo
)
;
}
void
GCRuntime
:
:
queueAllLifoBlocksForFree
(
LifoAlloc
*
lifo
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
AutoLockHelperThreadState
lock
;
lifoBlocksToFree
.
ref
(
)
.
transferFrom
(
lifo
)
;
}
void
GCRuntime
:
:
queueAllLifoBlocksForFreeAfterMinorGC
(
LifoAlloc
*
lifo
)
{
lifoBlocksToFreeAfterMinorGC
.
ref
(
)
.
transferFrom
(
lifo
)
;
}
void
GCRuntime
:
:
queueBuffersForFreeAfterMinorGC
(
Nursery
:
:
BufferSet
&
buffers
)
{
AutoLockHelperThreadState
lock
;
if
(
!
buffersToFreeAfterMinorGC
.
ref
(
)
.
empty
(
)
)
{
MOZ_ASSERT
(
!
freeTask
.
isIdle
(
lock
)
)
;
freeTask
.
joinWithLockHeld
(
lock
)
;
}
MOZ_ASSERT
(
buffersToFreeAfterMinorGC
.
ref
(
)
.
empty
(
)
)
;
mozilla
:
:
Swap
(
buffersToFreeAfterMinorGC
.
ref
(
)
buffers
)
;
}
void
GCRuntime
:
:
startBackgroundFree
(
)
{
AutoLockHelperThreadState
lock
;
freeTask
.
startOrRunIfIdle
(
lock
)
;
}
void
BackgroundFreeTask
:
:
run
(
)
{
AutoTraceLog
logFreeing
(
TraceLoggerForCurrentThread
(
)
TraceLogger_GCFree
)
;
AutoLockHelperThreadState
lock
;
gc
-
>
freeFromBackgroundThread
(
lock
)
;
setFinishing
(
lock
)
;
}
void
GCRuntime
:
:
freeFromBackgroundThread
(
AutoLockHelperThreadState
&
lock
)
{
do
{
LifoAlloc
lifoBlocks
(
JSContext
:
:
TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
)
;
lifoBlocks
.
transferFrom
(
&
lifoBlocksToFree
.
ref
(
)
)
;
Nursery
:
:
BufferSet
buffers
;
mozilla
:
:
Swap
(
buffers
buffersToFreeAfterMinorGC
.
ref
(
)
)
;
AutoUnlockHelperThreadState
unlock
(
lock
)
;
lifoBlocks
.
freeAll
(
)
;
JSFreeOp
*
fop
=
TlsContext
.
get
(
)
-
>
defaultFreeOp
(
)
;
for
(
Nursery
:
:
BufferSet
:
:
Range
r
=
buffers
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
fop
-
>
freeUntracked
(
r
.
front
(
)
)
;
}
}
while
(
!
lifoBlocksToFree
.
ref
(
)
.
isEmpty
(
)
|
|
!
buffersToFreeAfterMinorGC
.
ref
(
)
.
empty
(
)
)
;
}
void
GCRuntime
:
:
waitBackgroundFreeEnd
(
)
{
freeTask
.
join
(
)
;
}
bool
UniqueIdGCPolicy
:
:
needsSweep
(
Cell
*
*
cellp
uint64_t
*
)
{
Cell
*
cell
=
*
cellp
;
return
MapGCThingTyped
(
cell
cell
-
>
getTraceKind
(
)
[
]
(
auto
t
)
{
mozilla
:
:
DebugOnly
<
const
Cell
*
>
prior
=
t
;
bool
result
=
IsAboutToBeFinalizedUnbarriered
(
&
t
)
;
MOZ_ASSERT
(
t
=
=
prior
)
;
return
result
;
}
)
;
}
void
JS
:
:
Zone
:
:
sweepUniqueIds
(
)
{
uniqueIds
(
)
.
sweep
(
)
;
}
void
Realm
:
:
destroy
(
JSFreeOp
*
fop
)
{
JSRuntime
*
rt
=
fop
-
>
runtime
(
)
;
if
(
auto
callback
=
rt
-
>
destroyRealmCallback
)
{
callback
(
fop
this
)
;
}
if
(
principals
(
)
)
{
JS_DropPrincipals
(
rt
-
>
mainContextFromOwnThread
(
)
principals
(
)
)
;
}
fop
-
>
deleteUntracked
(
this
)
;
}
void
Compartment
:
:
destroy
(
JSFreeOp
*
fop
)
{
JSRuntime
*
rt
=
fop
-
>
runtime
(
)
;
if
(
auto
callback
=
rt
-
>
destroyCompartmentCallback
)
{
callback
(
fop
this
)
;
}
fop
-
>
deleteUntracked
(
this
)
;
rt
-
>
gc
.
stats
(
)
.
sweptCompartment
(
)
;
}
void
Zone
:
:
destroy
(
JSFreeOp
*
fop
)
{
MOZ_ASSERT
(
compartments
(
)
.
empty
(
)
)
;
fop
-
>
deleteUntracked
(
this
)
;
fop
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
sweptZone
(
)
;
}
void
Zone
:
:
sweepCompartments
(
JSFreeOp
*
fop
bool
keepAtleastOne
bool
destroyingRuntime
)
{
MOZ_ASSERT
(
!
compartments
(
)
.
empty
(
)
)
;
MOZ_ASSERT_IF
(
destroyingRuntime
!
keepAtleastOne
)
;
Compartment
*
*
read
=
compartments
(
)
.
begin
(
)
;
Compartment
*
*
end
=
compartments
(
)
.
end
(
)
;
Compartment
*
*
write
=
read
;
while
(
read
<
end
)
{
Compartment
*
comp
=
*
read
+
+
;
bool
keepAtleastOneRealm
=
read
=
=
end
&
&
keepAtleastOne
;
comp
-
>
sweepRealms
(
fop
keepAtleastOneRealm
destroyingRuntime
)
;
if
(
!
comp
-
>
realms
(
)
.
empty
(
)
)
{
*
write
+
+
=
comp
;
keepAtleastOne
=
false
;
}
else
{
comp
-
>
destroy
(
fop
)
;
}
}
compartments
(
)
.
shrinkTo
(
write
-
compartments
(
)
.
begin
(
)
)
;
MOZ_ASSERT_IF
(
keepAtleastOne
!
compartments
(
)
.
empty
(
)
)
;
MOZ_ASSERT_IF
(
destroyingRuntime
compartments
(
)
.
empty
(
)
)
;
}
void
Compartment
:
:
sweepRealms
(
JSFreeOp
*
fop
bool
keepAtleastOne
bool
destroyingRuntime
)
{
MOZ_ASSERT
(
!
realms
(
)
.
empty
(
)
)
;
MOZ_ASSERT_IF
(
destroyingRuntime
!
keepAtleastOne
)
;
Realm
*
*
read
=
realms
(
)
.
begin
(
)
;
Realm
*
*
end
=
realms
(
)
.
end
(
)
;
Realm
*
*
write
=
read
;
while
(
read
<
end
)
{
Realm
*
realm
=
*
read
+
+
;
bool
dontDelete
=
read
=
=
end
&
&
keepAtleastOne
;
if
(
(
realm
-
>
marked
(
)
|
|
dontDelete
)
&
&
!
destroyingRuntime
)
{
*
write
+
+
=
realm
;
keepAtleastOne
=
false
;
}
else
{
realm
-
>
destroy
(
fop
)
;
}
}
realms
(
)
.
shrinkTo
(
write
-
realms
(
)
.
begin
(
)
)
;
MOZ_ASSERT_IF
(
keepAtleastOne
!
realms
(
)
.
empty
(
)
)
;
MOZ_ASSERT_IF
(
destroyingRuntime
realms
(
)
.
empty
(
)
)
;
}
void
GCRuntime
:
:
deleteEmptyZone
(
Zone
*
zone
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
MOZ_ASSERT
(
zone
-
>
compartments
(
)
.
empty
(
)
)
;
for
(
auto
&
i
:
zones
(
)
)
{
if
(
i
=
=
zone
)
{
zones
(
)
.
erase
(
&
i
)
;
zone
-
>
destroy
(
rt
-
>
defaultFreeOp
(
)
)
;
return
;
}
}
MOZ_CRASH
(
"
Zone
not
found
"
)
;
}
void
GCRuntime
:
:
sweepZones
(
JSFreeOp
*
fop
bool
destroyingRuntime
)
{
MOZ_ASSERT_IF
(
destroyingRuntime
numActiveZoneIters
=
=
0
)
;
if
(
numActiveZoneIters
)
{
return
;
}
assertBackgroundSweepingFinished
(
)
;
Zone
*
*
read
=
zones
(
)
.
begin
(
)
;
Zone
*
*
end
=
zones
(
)
.
end
(
)
;
Zone
*
*
write
=
read
;
while
(
read
<
end
)
{
Zone
*
zone
=
*
read
+
+
;
if
(
zone
-
>
wasGCStarted
(
)
)
{
MOZ_ASSERT
(
!
zone
-
>
isQueuedForBackgroundSweep
(
)
)
;
const
bool
zoneIsDead
=
zone
-
>
arenas
.
arenaListsAreEmpty
(
)
&
&
!
zone
-
>
hasMarkedRealms
(
)
;
MOZ_ASSERT_IF
(
destroyingRuntime
zoneIsDead
)
;
if
(
zoneIsDead
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
zone
)
;
zone
-
>
arenas
.
checkEmptyFreeLists
(
)
;
zone
-
>
sweepCompartments
(
fop
false
destroyingRuntime
)
;
MOZ_ASSERT
(
zone
-
>
compartments
(
)
.
empty
(
)
)
;
MOZ_ASSERT
(
zone
-
>
typeDescrObjects
(
)
.
empty
(
)
)
;
zone
-
>
destroy
(
fop
)
;
continue
;
}
zone
-
>
sweepCompartments
(
fop
true
destroyingRuntime
)
;
}
*
write
+
+
=
zone
;
}
zones
(
)
.
shrinkTo
(
write
-
zones
(
)
.
begin
(
)
)
;
}
void
ArenaLists
:
:
checkEmptyArenaList
(
AllocKind
kind
)
{
MOZ_ASSERT
(
arenaLists
(
kind
)
.
isEmpty
(
)
)
;
}
class
MOZ_RAII
js
:
:
gc
:
:
AutoRunParallelTask
:
public
GCParallelTask
{
gcstats
:
:
PhaseKind
phase_
;
AutoLockHelperThreadState
&
lock_
;
public
:
AutoRunParallelTask
(
GCRuntime
*
gc
TaskFunc
func
gcstats
:
:
PhaseKind
phase
AutoLockHelperThreadState
&
lock
)
:
GCParallelTask
(
gc
func
)
phase_
(
phase
)
lock_
(
lock
)
{
gc
-
>
startTask
(
*
this
phase_
lock_
)
;
}
~
AutoRunParallelTask
(
)
{
gc
-
>
joinTask
(
*
this
phase_
lock_
)
;
}
}
;
void
GCRuntime
:
:
purgeRuntimeForMinorGC
(
)
{
MOZ_ASSERT
(
!
IsNurseryAllocable
(
AllocKind
:
:
EXTERNAL_STRING
)
)
;
for
(
ZonesIter
zone
(
this
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
functionToStringCache
(
)
.
purge
(
)
;
}
rt
-
>
caches
(
)
.
purgeForMinorGC
(
rt
)
;
}
void
GCRuntime
:
:
purgeRuntime
(
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
PURGE
)
;
for
(
GCRealmsIter
realm
(
rt
)
;
!
realm
.
done
(
)
;
realm
.
next
(
)
)
{
realm
-
>
purge
(
)
;
}
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
purgeAtomCacheOrDefer
(
)
;
zone
-
>
externalStringCache
(
)
.
purge
(
)
;
zone
-
>
functionToStringCache
(
)
.
purge
(
)
;
}
JSContext
*
cx
=
rt
-
>
mainContextFromOwnThread
(
)
;
queueUnusedLifoBlocksForFree
(
&
cx
-
>
tempLifoAlloc
(
)
)
;
cx
-
>
interpreterStack
(
)
.
purge
(
rt
)
;
cx
-
>
frontendCollectionPool
(
)
.
purge
(
)
;
rt
-
>
caches
(
)
.
purge
(
)
;
if
(
auto
cache
=
rt
-
>
maybeThisRuntimeSharedImmutableStrings
(
)
)
{
cache
-
>
purge
(
)
;
}
MOZ_ASSERT
(
unmarkGrayStack
.
empty
(
)
)
;
unmarkGrayStack
.
clearAndFree
(
)
;
if
(
!
rt
-
>
parentRuntime
)
{
HelperThreadState
(
)
.
triggerFreeUnusedMemory
(
)
;
}
}
bool
GCRuntime
:
:
shouldPreserveJITCode
(
Realm
*
realm
const
TimeStamp
&
currentTime
JS
:
:
GCReason
reason
bool
canAllocateMoreCode
)
{
if
(
cleanUpEverything
)
{
return
false
;
}
if
(
!
canAllocateMoreCode
)
{
return
false
;
}
if
(
alwaysPreserveCode
)
{
return
true
;
}
if
(
realm
-
>
preserveJitCode
(
)
)
{
return
true
;
}
if
(
IsCurrentlyAnimating
(
realm
-
>
lastAnimationTime
currentTime
)
)
{
return
true
;
}
if
(
reason
=
=
JS
:
:
GCReason
:
:
DEBUG_GC
)
{
return
true
;
}
return
false
;
}
#
ifdef
DEBUG
class
CompartmentCheckTracer
final
:
public
JS
:
:
CallbackTracer
{
bool
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
override
;
public
:
explicit
CompartmentCheckTracer
(
JSRuntime
*
rt
)
:
JS
:
:
CallbackTracer
(
rt
)
src
(
nullptr
)
zone
(
nullptr
)
compartment
(
nullptr
)
{
}
Cell
*
src
;
JS
:
:
TraceKind
srcKind
;
Zone
*
zone
;
Compartment
*
compartment
;
}
;
static
bool
InCrossCompartmentMap
(
JSRuntime
*
rt
JSObject
*
src
JS
:
:
GCCellPtr
dst
)
{
Compartment
*
srccomp
=
src
-
>
compartment
(
)
;
if
(
dst
.
is
<
JSObject
>
(
)
)
{
if
(
ObjectWrapperMap
:
:
Ptr
p
=
srccomp
-
>
lookupWrapper
(
&
dst
.
as
<
JSObject
>
(
)
)
)
{
if
(
*
p
-
>
value
(
)
.
unsafeGet
(
)
=
=
src
)
{
return
true
;
}
}
}
if
(
DebugAPI
:
:
edgeIsInDebuggerWeakmap
(
rt
src
dst
)
)
{
return
true
;
}
return
false
;
}
bool
CompartmentCheckTracer
:
:
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
{
Compartment
*
comp
=
MapGCThingTyped
(
thing
[
]
(
auto
t
)
{
return
t
-
>
maybeCompartment
(
)
;
}
)
;
if
(
comp
&
&
compartment
)
{
MOZ_ASSERT
(
comp
=
=
compartment
|
|
(
srcKind
=
=
JS
:
:
TraceKind
:
:
Object
&
&
InCrossCompartmentMap
(
runtime
(
)
static_cast
<
JSObject
*
>
(
src
)
thing
)
)
)
;
}
else
{
TenuredCell
*
tenured
=
TenuredCell
:
:
fromPointer
(
thing
.
asCell
(
)
)
;
Zone
*
thingZone
=
tenured
-
>
zoneFromAnyThread
(
)
;
MOZ_ASSERT
(
thingZone
=
=
zone
|
|
thingZone
-
>
isAtomsZone
(
)
)
;
}
return
true
;
}
void
GCRuntime
:
:
checkForCompartmentMismatches
(
)
{
JSContext
*
cx
=
rt
-
>
mainContextFromOwnThread
(
)
;
if
(
cx
-
>
disableStrictProxyCheckingCount
)
{
return
;
}
CompartmentCheckTracer
trc
(
rt
)
;
AutoAssertEmptyNursery
empty
(
cx
)
;
for
(
ZonesIter
zone
(
this
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
trc
.
zone
=
zone
;
for
(
auto
thingKind
:
AllAllocKinds
(
)
)
{
for
(
auto
i
=
zone
-
>
cellIterUnsafe
<
TenuredCell
>
(
thingKind
empty
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
trc
.
src
=
i
.
getCell
(
)
;
trc
.
srcKind
=
MapAllocToTraceKind
(
thingKind
)
;
trc
.
compartment
=
MapGCThingTyped
(
trc
.
src
trc
.
srcKind
[
]
(
auto
t
)
{
return
t
-
>
maybeCompartment
(
)
;
}
)
;
js
:
:
TraceChildren
(
&
trc
trc
.
src
trc
.
srcKind
)
;
}
}
}
}
#
endif
static
void
RelazifyFunctions
(
Zone
*
zone
AllocKind
kind
)
{
MOZ_ASSERT
(
kind
=
=
AllocKind
:
:
FUNCTION
|
|
kind
=
=
AllocKind
:
:
FUNCTION_EXTENDED
)
;
JSRuntime
*
rt
=
zone
-
>
runtimeFromMainThread
(
)
;
AutoAssertEmptyNursery
empty
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
for
(
auto
i
=
zone
-
>
cellIterUnsafe
<
JSObject
>
(
kind
empty
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
JSFunction
*
fun
=
&
i
-
>
as
<
JSFunction
>
(
)
;
if
(
fun
-
>
hasScript
(
)
)
{
fun
-
>
maybeRelazify
(
rt
)
;
}
}
}
static
bool
ShouldCollectZone
(
Zone
*
zone
JS
:
:
GCReason
reason
)
{
if
(
reason
=
=
JS
:
:
GCReason
:
:
COMPARTMENT_REVIVED
)
{
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
if
(
comp
-
>
gcState
.
scheduledForDestruction
)
{
return
true
;
}
}
return
false
;
}
if
(
!
zone
-
>
isGCScheduled
(
)
)
{
return
false
;
}
if
(
zone
-
>
isAtomsZone
(
)
)
{
return
TlsContext
.
get
(
)
-
>
canCollectAtoms
(
)
;
}
return
zone
-
>
canCollect
(
)
;
}
bool
GCRuntime
:
:
prepareZonesForCollection
(
JS
:
:
GCReason
reason
bool
*
isFullOut
)
{
#
ifdef
DEBUG
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
!
zone
-
>
isCollecting
(
)
)
;
MOZ_ASSERT_IF
(
!
zone
-
>
isAtomsZone
(
)
!
zone
-
>
compartments
(
)
.
empty
(
)
)
;
for
(
auto
i
:
AllAllocKinds
(
)
)
{
MOZ_ASSERT
(
!
zone
-
>
arenas
.
arenaListsToSweep
(
i
)
)
;
}
}
#
endif
*
isFullOut
=
true
;
bool
any
=
false
;
auto
currentTime
=
ReallyNow
(
)
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
bool
shouldCollect
=
ShouldCollectZone
(
zone
reason
)
;
if
(
shouldCollect
)
{
MOZ_ASSERT
(
zone
-
>
canCollect
(
)
)
;
any
=
true
;
zone
-
>
changeGCState
(
Zone
:
:
NoGC
Zone
:
:
MarkBlackOnly
)
;
}
else
{
*
isFullOut
=
false
;
}
zone
-
>
setWasCollected
(
shouldCollect
)
;
zone
-
>
setPreservingCode
(
false
)
;
}
bool
canAllocateMoreCode
=
jit
:
:
CanLikelyAllocateMoreExecutableMemory
(
)
;
for
(
CompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
c
-
>
gcState
.
scheduledForDestruction
=
false
;
c
-
>
gcState
.
maybeAlive
=
false
;
c
-
>
gcState
.
hasEnteredRealm
=
false
;
for
(
RealmsInCompartmentIter
r
(
c
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
if
(
r
-
>
shouldTraceGlobal
(
)
|
|
!
r
-
>
zone
(
)
-
>
isGCScheduled
(
)
)
{
c
-
>
gcState
.
maybeAlive
=
true
;
}
if
(
shouldPreserveJITCode
(
r
currentTime
reason
canAllocateMoreCode
)
)
{
r
-
>
zone
(
)
-
>
setPreservingCode
(
true
)
;
}
if
(
r
-
>
hasBeenEnteredIgnoringJit
(
)
)
{
c
-
>
gcState
.
hasEnteredRealm
=
true
;
}
}
}
if
(
!
cleanUpEverything
&
&
canAllocateMoreCode
)
{
jit
:
:
JitActivationIterator
activation
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
if
(
!
activation
.
done
(
)
)
{
activation
-
>
compartment
(
)
-
>
zone
(
)
-
>
setPreservingCode
(
true
)
;
}
}
MOZ_ASSERT_IF
(
reason
=
=
JS
:
:
GCReason
:
:
DELAYED_ATOMS_GC
atomsZone
-
>
isGCMarking
(
)
)
;
return
any
;
}
void
GCRuntime
:
:
discardJITCodeForGC
(
)
{
js
:
:
CancelOffThreadIonCompile
(
rt
JS
:
:
Zone
:
:
MarkBlackOnly
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_DISCARD_CODE
)
;
zone
-
>
discardJitCode
(
rt
-
>
defaultFreeOp
(
)
Zone
:
:
DiscardBaselineCode
Zone
:
:
DiscardJitScripts
)
;
}
}
void
GCRuntime
:
:
relazifyFunctionsForShrinkingGC
(
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
RELAZIFY_FUNCTIONS
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
isSelfHostingZone
(
)
)
{
continue
;
}
RelazifyFunctions
(
zone
AllocKind
:
:
FUNCTION
)
;
RelazifyFunctions
(
zone
AllocKind
:
:
FUNCTION_EXTENDED
)
;
}
}
void
GCRuntime
:
:
purgeShapeCachesForShrinkingGC
(
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
PURGE_SHAPE_CACHES
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
CanRelocateZone
(
zone
)
|
|
zone
-
>
keepShapeCaches
(
)
)
{
continue
;
}
for
(
auto
baseShape
=
zone
-
>
cellIterUnsafe
<
BaseShape
>
(
)
;
!
baseShape
.
done
(
)
;
baseShape
.
next
(
)
)
{
baseShape
-
>
maybePurgeCache
(
rt
-
>
defaultFreeOp
(
)
)
;
}
}
}
void
GCRuntime
:
:
purgeSourceURLsForShrinkingGC
(
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
PURGE_SOURCE_URLS
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
CanRelocateZone
(
zone
)
|
|
zone
-
>
isSystem
)
{
continue
;
}
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
for
(
RealmsInCompartmentIter
realm
(
comp
)
;
!
realm
.
done
(
)
;
realm
.
next
(
)
)
{
GlobalObject
*
global
=
realm
.
get
(
)
-
>
unsafeUnbarrieredMaybeGlobal
(
)
;
if
(
global
)
{
global
-
>
clearSourceURLSHolder
(
)
;
}
}
}
}
}
static
void
UnmarkCollectedZones
(
GCParallelTask
*
task
)
{
GCRuntime
*
gc
=
task
-
>
gc
;
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
arenas
.
unmarkAll
(
)
;
}
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
WeakMapBase
:
:
unmarkZone
(
zone
)
;
}
}
static
void
BufferGrayRoots
(
GCParallelTask
*
task
)
{
task
-
>
gc
-
>
bufferGrayRoots
(
)
;
}
bool
GCRuntime
:
:
beginMarkPhase
(
JS
:
:
GCReason
reason
AutoGCSession
&
session
)
{
#
ifdef
DEBUG
if
(
fullCompartmentChecks
)
{
checkForCompartmentMismatches
(
)
;
}
#
endif
if
(
!
prepareZonesForCollection
(
reason
&
isFull
.
ref
(
)
)
)
{
return
false
;
}
if
(
atomsZone
-
>
isCollecting
(
)
)
{
session
.
maybeCheckAtomsAccess
.
emplace
(
rt
)
;
}
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
arenas
.
clearFreeLists
(
)
;
}
marker
.
start
(
)
;
GCMarker
*
gcmarker
=
&
marker
;
gcmarker
-
>
clearMarkCount
(
)
;
{
gcstats
:
:
AutoPhase
ap1
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
PREPARE
)
;
AutoLockHelperThreadState
helperLock
;
AutoRunParallelTask
unmarkCollectedZones
(
this
UnmarkCollectedZones
gcstats
:
:
PhaseKind
:
:
UNMARK
helperLock
)
;
Maybe
<
AutoRunParallelTask
>
bufferGrayRoots
;
if
(
isIncremental
)
{
bufferGrayRoots
.
emplace
(
this
BufferGrayRoots
gcstats
:
:
PhaseKind
:
:
BUFFER_GRAY_ROOTS
helperLock
)
;
}
AutoUnlockHelperThreadState
unlock
(
helperLock
)
;
discardJITCodeForGC
(
)
;
startBackgroundFreeAfterMinorGC
(
)
;
if
(
invocationKind
=
=
GC_SHRINK
)
{
relazifyFunctionsForShrinkingGC
(
)
;
purgeShapeCachesForShrinkingGC
(
)
;
purgeSourceURLsForShrinkingGC
(
)
;
}
purgeRuntime
(
)
;
}
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK
)
;
if
(
rt
-
>
isBeingDestroyed
(
)
)
{
checkNoRuntimeRoots
(
session
)
;
}
else
{
traceRuntimeForMajorGC
(
gcmarker
session
)
;
}
if
(
isIncremental
)
{
findDeadCompartments
(
)
;
}
updateMemoryCountersOnGCStart
(
)
;
stats
(
)
.
measureInitialHeapSize
(
)
;
{
AutoLockHelperThreadState
helperLock
;
HelperThreadState
(
)
.
startHandlingCompressionTasks
(
helperLock
)
;
}
return
true
;
}
void
GCRuntime
:
:
findDeadCompartments
(
)
{
gcstats
:
:
AutoPhase
ap1
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_ROOTS
)
;
gcstats
:
:
AutoPhase
ap2
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_COMPARTMENTS
)
;
Vector
<
Compartment
*
0
js
:
:
SystemAllocPolicy
>
workList
;
for
(
CompartmentsIter
comp
(
rt
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
if
(
comp
-
>
gcState
.
maybeAlive
)
{
if
(
!
workList
.
append
(
comp
)
)
{
return
;
}
}
}
while
(
!
workList
.
empty
(
)
)
{
Compartment
*
comp
=
workList
.
popCopy
(
)
;
for
(
Compartment
:
:
WrappedObjectCompartmentEnum
e
(
comp
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Compartment
*
dest
=
e
.
front
(
)
;
if
(
!
dest
-
>
gcState
.
maybeAlive
)
{
dest
-
>
gcState
.
maybeAlive
=
true
;
if
(
!
workList
.
append
(
dest
)
)
{
return
;
}
}
}
}
for
(
GCCompartmentsIter
comp
(
rt
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
MOZ_ASSERT
(
!
comp
-
>
gcState
.
scheduledForDestruction
)
;
if
(
!
comp
-
>
gcState
.
maybeAlive
)
{
comp
-
>
gcState
.
scheduledForDestruction
=
true
;
}
}
}
void
GCRuntime
:
:
updateMemoryCountersOnGCStart
(
)
{
heapSize
.
updateOnGCStart
(
)
;
for
(
GCZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
updateMemoryCountersOnGCStart
(
)
;
}
}
template
<
class
ZoneIterT
>
void
GCRuntime
:
:
markWeakReferences
(
gcstats
:
:
PhaseKind
phase
)
{
MOZ_ASSERT
(
marker
.
isDrained
(
)
)
;
gcstats
:
:
AutoPhase
ap1
(
stats
(
)
phase
)
;
marker
.
enterWeakMarkingMode
(
)
;
drainMarkStack
(
)
;
for
(
;
;
)
{
bool
markedAny
=
false
;
if
(
!
marker
.
isWeakMarkingTracer
(
)
)
{
for
(
ZoneIterT
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
markedAny
|
=
WeakMapBase
:
:
markZoneIteratively
(
zone
&
marker
)
;
}
}
markedAny
|
=
DebugAPI
:
:
markIteratively
(
&
marker
)
;
markedAny
|
=
jit
:
:
JitRuntime
:
:
MarkJitcodeGlobalTableIteratively
(
&
marker
)
;
if
(
!
markedAny
)
{
break
;
}
drainMarkStack
(
)
;
}
MOZ_ASSERT
(
marker
.
isDrained
(
)
)
;
marker
.
leaveWeakMarkingMode
(
)
;
}
void
GCRuntime
:
:
markWeakReferencesInCurrentGroup
(
gcstats
:
:
PhaseKind
phase
)
{
markWeakReferences
<
SweepGroupZonesIter
>
(
phase
)
;
}
template
<
class
ZoneIterT
>
void
GCRuntime
:
:
markGrayRoots
(
gcstats
:
:
PhaseKind
phase
)
{
MOZ_ASSERT
(
marker
.
markColor
(
)
=
=
MarkColor
:
:
Gray
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
phase
)
;
if
(
hasValidGrayRootsBuffer
(
)
)
{
for
(
ZoneIterT
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
markBufferedGrayRoots
(
zone
)
;
}
}
else
{
MOZ_ASSERT
(
!
isIncremental
)
;
traceEmbeddingGrayRoots
(
&
marker
)
;
Compartment
:
:
traceIncomingCrossCompartmentEdgesForZoneGC
(
&
marker
Compartment
:
:
GrayEdges
)
;
}
}
void
GCRuntime
:
:
markAllWeakReferences
(
gcstats
:
:
PhaseKind
phase
)
{
markWeakReferences
<
GCZonesIter
>
(
phase
)
;
}
void
GCRuntime
:
:
markAllGrayReferences
(
gcstats
:
:
PhaseKind
phase
)
{
markGrayRoots
<
GCZonesIter
>
(
phase
)
;
drainMarkStack
(
)
;
}
#
ifdef
JS_GC_ZEAL
struct
GCChunkHasher
{
typedef
gc
:
:
Chunk
*
Lookup
;
static
HashNumber
hash
(
gc
:
:
Chunk
*
chunk
)
{
MOZ_ASSERT
(
!
(
uintptr_t
(
chunk
)
&
gc
:
:
ChunkMask
)
)
;
return
HashNumber
(
uintptr_t
(
chunk
)
>
>
gc
:
:
ChunkShift
)
;
}
static
bool
match
(
gc
:
:
Chunk
*
k
gc
:
:
Chunk
*
l
)
{
MOZ_ASSERT
(
!
(
uintptr_t
(
k
)
&
gc
:
:
ChunkMask
)
)
;
MOZ_ASSERT
(
!
(
uintptr_t
(
l
)
&
gc
:
:
ChunkMask
)
)
;
return
k
=
=
l
;
}
}
;
class
js
:
:
gc
:
:
MarkingValidator
{
public
:
explicit
MarkingValidator
(
GCRuntime
*
gc
)
;
void
nonIncrementalMark
(
AutoGCSession
&
session
)
;
void
validate
(
)
;
private
:
GCRuntime
*
gc
;
bool
initialized
;
using
BitmapMap
=
HashMap
<
Chunk
*
UniquePtr
<
ChunkBitmap
>
GCChunkHasher
SystemAllocPolicy
>
;
BitmapMap
map
;
}
;
js
:
:
gc
:
:
MarkingValidator
:
:
MarkingValidator
(
GCRuntime
*
gc
)
:
gc
(
gc
)
initialized
(
false
)
{
}
void
js
:
:
gc
:
:
MarkingValidator
:
:
nonIncrementalMark
(
AutoGCSession
&
session
)
{
JSRuntime
*
runtime
=
gc
-
>
rt
;
GCMarker
*
gcmarker
=
&
gc
-
>
marker
;
gc
-
>
waitBackgroundSweepEnd
(
)
;
HelperThreadState
(
)
.
waitForAllThreads
(
)
;
{
AutoLockGC
lock
(
gc
)
;
for
(
auto
chunk
=
gc
-
>
allNonEmptyChunks
(
lock
)
;
!
chunk
.
done
(
)
;
chunk
.
next
(
)
)
{
ChunkBitmap
*
bitmap
=
&
chunk
-
>
bitmap
;
auto
entry
=
MakeUnique
<
ChunkBitmap
>
(
)
;
if
(
!
entry
)
{
return
;
}
memcpy
(
(
void
*
)
entry
-
>
bitmap
(
void
*
)
bitmap
-
>
bitmap
sizeof
(
bitmap
-
>
bitmap
)
)
;
if
(
!
map
.
putNew
(
chunk
std
:
:
move
(
entry
)
)
)
{
return
;
}
}
}
WeakMapSet
markedWeakMaps
;
gc
:
:
WeakKeyTable
savedWeakKeys
(
SystemAllocPolicy
(
)
runtime
-
>
randomHashCodeScrambler
(
)
)
;
if
(
!
savedWeakKeys
.
init
(
)
)
{
return
;
}
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
WeakMapBase
:
:
saveZoneMarkedWeakMaps
(
zone
markedWeakMaps
)
)
{
return
;
}
AutoEnterOOMUnsafeRegion
oomUnsafe
;
for
(
gc
:
:
WeakKeyTable
:
:
Range
r
=
zone
-
>
gcWeakKeys
(
)
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
if
(
!
savedWeakKeys
.
put
(
std
:
:
move
(
r
.
front
(
)
.
key
)
std
:
:
move
(
r
.
front
(
)
.
value
)
)
)
{
oomUnsafe
.
crash
(
"
saving
weak
keys
table
for
validator
"
)
;
}
}
if
(
!
zone
-
>
gcWeakKeys
(
)
.
clear
(
)
)
{
oomUnsafe
.
crash
(
"
clearing
weak
keys
table
for
validator
"
)
;
}
}
initialized
=
true
;
js
:
:
gc
:
:
State
state
=
gc
-
>
incrementalState
;
gc
-
>
incrementalState
=
State
:
:
MarkRoots
;
{
gcstats
:
:
AutoPhase
ap
(
gc
-
>
stats
(
)
gcstats
:
:
PhaseKind
:
:
PREPARE
)
;
{
gcstats
:
:
AutoPhase
ap
(
gc
-
>
stats
(
)
gcstats
:
:
PhaseKind
:
:
UNMARK
)
;
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
WeakMapBase
:
:
unmarkZone
(
zone
)
;
}
MOZ_ASSERT
(
gcmarker
-
>
isDrained
(
)
)
;
gcmarker
-
>
reset
(
)
;
AutoLockGC
lock
(
gc
)
;
for
(
auto
chunk
=
gc
-
>
allNonEmptyChunks
(
lock
)
;
!
chunk
.
done
(
)
;
chunk
.
next
(
)
)
{
chunk
-
>
bitmap
.
clear
(
)
;
}
}
}
{
gcstats
:
:
AutoPhase
ap
(
gc
-
>
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK
)
;
gc
-
>
traceRuntimeForMajorGC
(
gcmarker
session
)
;
gc
-
>
incrementalState
=
State
:
:
Mark
;
gc
-
>
drainMarkStack
(
)
;
}
gc
-
>
incrementalState
=
State
:
:
Sweep
;
{
gcstats
:
:
AutoPhase
ap1
(
gc
-
>
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP
)
;
gcstats
:
:
AutoPhase
ap2
(
gc
-
>
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK
)
;
gc
-
>
markAllWeakReferences
(
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK_WEAK
)
;
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
changeGCState
(
Zone
:
:
MarkBlackOnly
Zone
:
:
MarkBlackAndGray
)
;
}
AutoSetMarkColor
setColorGray
(
*
gcmarker
MarkColor
:
:
Gray
)
;
gcmarker
-
>
setMainStackColor
(
MarkColor
:
:
Gray
)
;
gc
-
>
markAllGrayReferences
(
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK_GRAY
)
;
gc
-
>
markAllWeakReferences
(
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK_GRAY_WEAK
)
;
gc
-
>
marker
.
setMainStackColor
(
MarkColor
:
:
Black
)
;
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
changeGCState
(
Zone
:
:
MarkBlackAndGray
Zone
:
:
MarkBlackOnly
)
;
}
MOZ_ASSERT
(
gc
-
>
marker
.
isDrained
(
)
)
;
}
{
AutoLockGC
lock
(
gc
)
;
for
(
auto
chunk
=
gc
-
>
allNonEmptyChunks
(
lock
)
;
!
chunk
.
done
(
)
;
chunk
.
next
(
)
)
{
ChunkBitmap
*
bitmap
=
&
chunk
-
>
bitmap
;
ChunkBitmap
*
entry
=
map
.
lookup
(
chunk
)
-
>
value
(
)
.
get
(
)
;
Swap
(
*
entry
*
bitmap
)
;
}
}
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
WeakMapBase
:
:
unmarkZone
(
zone
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
zone
-
>
gcWeakKeys
(
)
.
clear
(
)
)
{
oomUnsafe
.
crash
(
"
clearing
weak
keys
table
for
validator
"
)
;
}
}
WeakMapBase
:
:
restoreMarkedWeakMaps
(
markedWeakMaps
)
;
for
(
gc
:
:
WeakKeyTable
:
:
Range
r
=
savedWeakKeys
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
Zone
*
zone
=
gc
:
:
TenuredCell
:
:
fromPointer
(
r
.
front
(
)
.
key
)
-
>
zone
(
)
;
if
(
!
zone
-
>
gcWeakKeys
(
)
.
put
(
std
:
:
move
(
r
.
front
(
)
.
key
)
std
:
:
move
(
r
.
front
(
)
.
value
)
)
)
{
oomUnsafe
.
crash
(
"
restoring
weak
keys
table
for
validator
"
)
;
}
}
gc
-
>
incrementalState
=
state
;
}
void
js
:
:
gc
:
:
MarkingValidator
:
:
validate
(
)
{
if
(
!
initialized
)
{
return
;
}
gc
-
>
waitBackgroundSweepEnd
(
)
;
AutoLockGC
lock
(
gc
-
>
rt
)
;
for
(
auto
chunk
=
gc
-
>
allNonEmptyChunks
(
lock
)
;
!
chunk
.
done
(
)
;
chunk
.
next
(
)
)
{
BitmapMap
:
:
Ptr
ptr
=
map
.
lookup
(
chunk
)
;
if
(
!
ptr
)
{
continue
;
}
ChunkBitmap
*
bitmap
=
ptr
-
>
value
(
)
.
get
(
)
;
ChunkBitmap
*
incBitmap
=
&
chunk
-
>
bitmap
;
for
(
size_t
i
=
0
;
i
<
ArenasPerChunk
;
i
+
+
)
{
if
(
chunk
-
>
decommittedArenas
.
get
(
i
)
)
{
continue
;
}
Arena
*
arena
=
&
chunk
-
>
arenas
[
i
]
;
if
(
!
arena
-
>
allocated
(
)
)
{
continue
;
}
if
(
!
arena
-
>
zone
-
>
isGCSweeping
(
)
)
{
continue
;
}
AllocKind
kind
=
arena
-
>
getAllocKind
(
)
;
uintptr_t
thing
=
arena
-
>
thingsStart
(
)
;
uintptr_t
end
=
arena
-
>
thingsEnd
(
)
;
while
(
thing
<
end
)
{
auto
cell
=
reinterpret_cast
<
TenuredCell
*
>
(
thing
)
;
if
(
bitmap
-
>
isMarkedAny
(
cell
)
)
{
MOZ_RELEASE_ASSERT
(
incBitmap
-
>
isMarkedAny
(
cell
)
)
;
}
if
(
!
bitmap
-
>
isMarkedGray
(
cell
)
)
{
MOZ_RELEASE_ASSERT
(
!
incBitmap
-
>
isMarkedGray
(
cell
)
)
;
}
thing
+
=
Arena
:
:
thingSize
(
kind
)
;
}
}
}
}
#
endif
void
GCRuntime
:
:
computeNonIncrementalMarkingForValidation
(
AutoGCSession
&
session
)
{
#
ifdef
JS_GC_ZEAL
MOZ_ASSERT
(
!
markingValidator
)
;
if
(
isIncremental
&
&
hasZealMode
(
ZealMode
:
:
IncrementalMarkingValidator
)
)
{
markingValidator
=
js_new
<
MarkingValidator
>
(
this
)
;
}
if
(
markingValidator
)
{
markingValidator
-
>
nonIncrementalMark
(
session
)
;
}
#
endif
}
void
GCRuntime
:
:
validateIncrementalMarking
(
)
{
#
ifdef
JS_GC_ZEAL
if
(
markingValidator
)
{
markingValidator
-
>
validate
(
)
;
}
#
endif
}
void
GCRuntime
:
:
finishMarkingValidation
(
)
{
#
ifdef
JS_GC_ZEAL
js_delete
(
markingValidator
.
ref
(
)
)
;
markingValidator
=
nullptr
;
#
endif
}
void
GCRuntime
:
:
dropStringWrappers
(
)
{
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
dropStringWrappersOnGC
(
)
;
}
}
bool
Compartment
:
:
findSweepGroupEdges
(
)
{
Zone
*
source
=
zone
(
)
;
for
(
WrappedObjectCompartmentEnum
e
(
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Compartment
*
targetComp
=
e
.
front
(
)
;
Zone
*
target
=
targetComp
-
>
zone
(
)
;
if
(
!
target
-
>
isGCMarking
(
)
|
|
source
-
>
hasSweepGroupEdgeTo
(
target
)
)
{
continue
;
}
for
(
ObjectWrapperEnum
e
(
this
targetComp
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
JSObject
*
key
=
e
.
front
(
)
.
mutableKey
(
)
;
MOZ_ASSERT
(
key
-
>
zone
(
)
=
=
target
)
;
if
(
key
-
>
asTenured
(
)
.
isMarkedBlack
(
)
)
{
continue
;
}
if
(
!
source
-
>
addSweepGroupEdgeTo
(
target
)
)
{
return
false
;
}
break
;
}
}
return
true
;
}
bool
Zone
:
:
findSweepGroupEdges
(
Zone
*
atomsZone
)
{
if
(
atomsZone
-
>
wasGCStarted
(
)
&
&
!
addSweepGroupEdgeTo
(
atomsZone
)
)
{
return
false
;
}
for
(
CompartmentsInZoneIter
comp
(
this
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
if
(
!
comp
-
>
findSweepGroupEdges
(
)
)
{
return
false
;
}
}
return
WeakMapBase
:
:
findSweepGroupEdgesForZone
(
this
)
;
}
static
bool
AddEdgesForMarkQueue
(
GCMarker
&
marker
)
{
#
ifdef
DEBUG
JS
:
:
Zone
*
prevZone
=
nullptr
;
for
(
size_t
i
=
0
;
i
<
marker
.
markQueue
.
length
(
)
;
i
+
+
)
{
Value
val
=
marker
.
markQueue
[
i
]
.
get
(
)
.
unbarrieredGet
(
)
;
if
(
!
val
.
isObject
(
)
)
{
continue
;
}
JSObject
*
obj
=
&
val
.
toObject
(
)
;
JS
:
:
Zone
*
zone
=
obj
-
>
zone
(
)
;
if
(
!
zone
-
>
isGCMarking
(
)
)
{
continue
;
}
if
(
prevZone
&
&
prevZone
!
=
zone
)
{
if
(
!
prevZone
-
>
addSweepGroupEdgeTo
(
zone
)
)
{
return
false
;
}
}
prevZone
=
zone
;
}
#
endif
return
true
;
}
bool
GCRuntime
:
:
findSweepGroupEdges
(
)
{
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zone
-
>
findSweepGroupEdges
(
atomsZone
)
)
{
return
false
;
}
}
if
(
!
AddEdgesForMarkQueue
(
marker
)
)
{
return
false
;
}
return
DebugAPI
:
:
findSweepGroupEdges
(
rt
)
;
}
void
GCRuntime
:
:
groupZonesForSweeping
(
JS
:
:
GCReason
reason
)
{
#
ifdef
DEBUG
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
zone
-
>
gcSweepGroupEdges
(
)
.
empty
(
)
)
;
}
#
endif
JSContext
*
cx
=
rt
-
>
mainContextFromOwnThread
(
)
;
ZoneComponentFinder
finder
(
cx
-
>
nativeStackLimit
[
JS
:
:
StackForSystemCode
]
)
;
if
(
!
isIncremental
|
|
!
findSweepGroupEdges
(
)
)
{
finder
.
useOneComponent
(
)
;
}
#
ifdef
JS_GC_ZEAL
if
(
useZeal
&
&
hasIncrementalTwoSliceZealMode
(
)
)
{
finder
.
useOneComponent
(
)
;
}
#
endif
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
zone
-
>
isGCMarking
(
)
)
;
finder
.
addNode
(
zone
)
;
}
sweepGroups
=
finder
.
getResultsList
(
)
;
currentSweepGroup
=
sweepGroups
;
sweepGroupIndex
=
1
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
clearSweepGroupEdges
(
)
;
}
#
ifdef
DEBUG
unsigned
idx
=
sweepGroupIndex
;
for
(
Zone
*
head
=
currentSweepGroup
;
head
;
head
=
head
-
>
nextGroup
(
)
)
{
for
(
Zone
*
zone
=
head
;
zone
;
zone
=
zone
-
>
nextNodeInGroup
(
)
)
{
MOZ_ASSERT
(
zone
-
>
isGCMarking
(
)
)
;
zone
-
>
gcSweepGroupIndex
=
idx
;
}
idx
+
+
;
}
MOZ_ASSERT_IF
(
!
isIncremental
!
currentSweepGroup
-
>
nextGroup
(
)
)
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
zone
-
>
gcSweepGroupEdges
(
)
.
empty
(
)
)
;
}
#
endif
}
static
void
ResetGrayList
(
Compartment
*
comp
)
;
void
GCRuntime
:
:
getNextSweepGroup
(
)
{
currentSweepGroup
=
currentSweepGroup
-
>
nextGroup
(
)
;
+
+
sweepGroupIndex
;
if
(
!
currentSweepGroup
)
{
abortSweepAfterCurrentGroup
=
false
;
return
;
}
MOZ_ASSERT_IF
(
abortSweepAfterCurrentGroup
!
isIncremental
)
;
if
(
!
isIncremental
)
{
ZoneComponentFinder
:
:
mergeGroups
(
currentSweepGroup
)
;
}
for
(
Zone
*
zone
=
currentSweepGroup
;
zone
;
zone
=
zone
-
>
nextNodeInGroup
(
)
)
{
MOZ_ASSERT
(
zone
-
>
isGCMarkingBlackOnly
(
)
)
;
MOZ_ASSERT
(
!
zone
-
>
isQueuedForBackgroundSweep
(
)
)
;
}
if
(
abortSweepAfterCurrentGroup
)
{
joinTask
(
sweepMarkTask
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
!
zone
-
>
gcNextGraphComponent
)
;
zone
-
>
setNeedsIncrementalBarrier
(
false
)
;
zone
-
>
changeGCState
(
Zone
:
:
MarkBlackOnly
Zone
:
:
NoGC
)
;
zone
-
>
arenas
.
unmarkPreMarkedFreeCells
(
)
;
zone
-
>
gcGrayRoots
(
)
.
Clear
(
)
;
}
for
(
SweepGroupCompartmentsIter
comp
(
rt
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
ResetGrayList
(
comp
)
;
}
abortSweepAfterCurrentGroup
=
false
;
currentSweepGroup
=
nullptr
;
}
hasMarkedGrayRoots
=
false
;
}
static
bool
IsGrayListObject
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
obj
)
;
return
obj
-
>
is
<
CrossCompartmentWrapperObject
>
(
)
&
&
!
IsDeadProxyObject
(
obj
)
;
}
unsigned
ProxyObject
:
:
grayLinkReservedSlot
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
IsGrayListObject
(
obj
)
)
;
return
CrossCompartmentWrapperObject
:
:
GrayLinkReservedSlot
;
}
#
ifdef
DEBUG
static
void
AssertNotOnGrayList
(
JSObject
*
obj
)
{
MOZ_ASSERT_IF
(
IsGrayListObject
(
obj
)
GetProxyReservedSlot
(
obj
ProxyObject
:
:
grayLinkReservedSlot
(
obj
)
)
.
isUndefined
(
)
)
;
}
#
endif
static
void
AssertNoWrappersInGrayList
(
JSRuntime
*
rt
)
{
#
ifdef
DEBUG
for
(
CompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
MOZ_ASSERT
(
!
c
-
>
gcIncomingGrayPointers
)
;
for
(
Compartment
:
:
ObjectWrapperEnum
e
(
c
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
AssertNotOnGrayList
(
e
.
front
(
)
.
value
(
)
.
unbarrieredGet
(
)
)
;
}
}
#
endif
}
static
JSObject
*
CrossCompartmentPointerReferent
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
IsGrayListObject
(
obj
)
)
;
return
&
obj
-
>
as
<
ProxyObject
>
(
)
.
private_
(
)
.
toObject
(
)
;
}
static
JSObject
*
NextIncomingCrossCompartmentPointer
(
JSObject
*
prev
bool
unlink
)
{
unsigned
slot
=
ProxyObject
:
:
grayLinkReservedSlot
(
prev
)
;
JSObject
*
next
=
GetProxyReservedSlot
(
prev
slot
)
.
toObjectOrNull
(
)
;
MOZ_ASSERT_IF
(
next
IsGrayListObject
(
next
)
)
;
if
(
unlink
)
{
SetProxyReservedSlot
(
prev
slot
UndefinedValue
(
)
)
;
}
return
next
;
}
void
js
:
:
gc
:
:
DelayCrossCompartmentGrayMarking
(
JSObject
*
src
)
{
MOZ_ASSERT
(
IsGrayListObject
(
src
)
)
;
MOZ_ASSERT
(
src
-
>
isMarkedGray
(
)
)
;
AutoTouchingGrayThings
tgt
;
unsigned
slot
=
ProxyObject
:
:
grayLinkReservedSlot
(
src
)
;
JSObject
*
dest
=
CrossCompartmentPointerReferent
(
src
)
;
Compartment
*
comp
=
dest
-
>
compartment
(
)
;
if
(
GetProxyReservedSlot
(
src
slot
)
.
isUndefined
(
)
)
{
SetProxyReservedSlot
(
src
slot
ObjectOrNullValue
(
comp
-
>
gcIncomingGrayPointers
)
)
;
comp
-
>
gcIncomingGrayPointers
=
src
;
}
else
{
MOZ_ASSERT
(
GetProxyReservedSlot
(
src
slot
)
.
isObjectOrNull
(
)
)
;
}
#
ifdef
DEBUG
JSObject
*
obj
=
comp
-
>
gcIncomingGrayPointers
;
bool
found
=
false
;
while
(
obj
)
{
if
(
obj
=
=
src
)
{
found
=
true
;
}
obj
=
NextIncomingCrossCompartmentPointer
(
obj
false
)
;
}
MOZ_ASSERT
(
found
)
;
#
endif
}
void
GCRuntime
:
:
markIncomingCrossCompartmentPointers
(
MarkColor
color
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
color
=
=
MarkColor
:
:
Black
?
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK_INCOMING_BLACK
:
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK_INCOMING_GRAY
)
;
bool
unlinkList
=
color
=
=
MarkColor
:
:
Gray
;
for
(
SweepGroupCompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
MOZ_ASSERT
(
c
-
>
zone
(
)
-
>
isGCMarking
(
)
)
;
MOZ_ASSERT_IF
(
color
=
=
MarkColor
:
:
Gray
c
-
>
zone
(
)
-
>
isGCMarkingBlackAndGray
(
)
)
;
MOZ_ASSERT_IF
(
c
-
>
gcIncomingGrayPointers
IsGrayListObject
(
c
-
>
gcIncomingGrayPointers
)
)
;
for
(
JSObject
*
src
=
c
-
>
gcIncomingGrayPointers
;
src
;
src
=
NextIncomingCrossCompartmentPointer
(
src
unlinkList
)
)
{
JSObject
*
dst
=
CrossCompartmentPointerReferent
(
src
)
;
MOZ_ASSERT
(
dst
-
>
compartment
(
)
=
=
c
)
;
if
(
color
=
=
MarkColor
:
:
Gray
)
{
if
(
IsMarkedUnbarriered
(
rt
&
src
)
&
&
src
-
>
asTenured
(
)
.
isMarkedGray
(
)
)
{
TraceManuallyBarrieredEdge
(
&
marker
&
dst
"
cross
-
compartment
gray
pointer
"
)
;
}
}
else
{
if
(
IsMarkedUnbarriered
(
rt
&
src
)
&
&
!
src
-
>
asTenured
(
)
.
isMarkedGray
(
)
)
{
TraceManuallyBarrieredEdge
(
&
marker
&
dst
"
cross
-
compartment
black
pointer
"
)
;
}
}
}
if
(
unlinkList
)
{
c
-
>
gcIncomingGrayPointers
=
nullptr
;
}
}
}
static
bool
RemoveFromGrayList
(
JSObject
*
wrapper
)
{
AutoTouchingGrayThings
tgt
;
if
(
!
IsGrayListObject
(
wrapper
)
)
{
return
false
;
}
unsigned
slot
=
ProxyObject
:
:
grayLinkReservedSlot
(
wrapper
)
;
if
(
GetProxyReservedSlot
(
wrapper
slot
)
.
isUndefined
(
)
)
{
return
false
;
}
JSObject
*
tail
=
GetProxyReservedSlot
(
wrapper
slot
)
.
toObjectOrNull
(
)
;
SetProxyReservedSlot
(
wrapper
slot
UndefinedValue
(
)
)
;
Compartment
*
comp
=
CrossCompartmentPointerReferent
(
wrapper
)
-
>
compartment
(
)
;
JSObject
*
obj
=
comp
-
>
gcIncomingGrayPointers
;
if
(
obj
=
=
wrapper
)
{
comp
-
>
gcIncomingGrayPointers
=
tail
;
return
true
;
}
while
(
obj
)
{
unsigned
slot
=
ProxyObject
:
:
grayLinkReservedSlot
(
obj
)
;
JSObject
*
next
=
GetProxyReservedSlot
(
obj
slot
)
.
toObjectOrNull
(
)
;
if
(
next
=
=
wrapper
)
{
js
:
:
detail
:
:
SetProxyReservedSlotUnchecked
(
obj
slot
ObjectOrNullValue
(
tail
)
)
;
return
true
;
}
obj
=
next
;
}
MOZ_CRASH
(
"
object
not
found
in
gray
link
list
"
)
;
}
static
void
ResetGrayList
(
Compartment
*
comp
)
{
JSObject
*
src
=
comp
-
>
gcIncomingGrayPointers
;
while
(
src
)
{
src
=
NextIncomingCrossCompartmentPointer
(
src
true
)
;
}
comp
-
>
gcIncomingGrayPointers
=
nullptr
;
}
#
ifdef
DEBUG
static
bool
HasIncomingCrossCompartmentPointers
(
JSRuntime
*
rt
)
{
for
(
SweepGroupCompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
if
(
c
-
>
gcIncomingGrayPointers
)
{
return
true
;
}
}
return
false
;
}
#
endif
void
js
:
:
NotifyGCNukeWrapper
(
JSObject
*
obj
)
{
RemoveFromGrayList
(
obj
)
;
}
enum
{
JS_GC_SWAP_OBJECT_A_REMOVED
=
1
<
<
0
JS_GC_SWAP_OBJECT_B_REMOVED
=
1
<
<
1
}
;
unsigned
js
:
:
NotifyGCPreSwap
(
JSObject
*
a
JSObject
*
b
)
{
return
(
RemoveFromGrayList
(
a
)
?
JS_GC_SWAP_OBJECT_A_REMOVED
:
0
)
|
(
RemoveFromGrayList
(
b
)
?
JS_GC_SWAP_OBJECT_B_REMOVED
:
0
)
;
}
void
js
:
:
NotifyGCPostSwap
(
JSObject
*
a
JSObject
*
b
unsigned
removedFlags
)
{
if
(
removedFlags
&
JS_GC_SWAP_OBJECT_A_REMOVED
)
{
DelayCrossCompartmentGrayMarking
(
b
)
;
}
if
(
removedFlags
&
JS_GC_SWAP_OBJECT_B_REMOVED
)
{
DelayCrossCompartmentGrayMarking
(
a
)
;
}
}
static
inline
void
MaybeCheckWeakMapMarking
(
GCRuntime
*
gc
)
{
#
if
defined
(
JS_GC_ZEAL
)
|
|
defined
(
DEBUG
)
bool
shouldCheck
;
#
if
defined
(
DEBUG
)
shouldCheck
=
true
;
#
else
shouldCheck
=
gc
-
>
hasZealMode
(
ZealMode
:
:
CheckWeakMapMarking
)
;
#
endif
if
(
shouldCheck
)
{
for
(
SweepGroupZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_RELEASE_ASSERT
(
WeakMapBase
:
:
checkMarkingForZone
(
zone
)
)
;
}
}
#
endif
}
IncrementalProgress
GCRuntime
:
:
markGrayReferencesInCurrentGroup
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
{
joinTask
(
sweepMarkTask
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK
)
;
if
(
sweepMarkTaskStarted
&
&
(
sweepMarkResult
=
=
NotFinished
)
)
{
return
NotFinished
;
}
MOZ_ASSERT
(
marker
.
markColor
(
)
=
=
MarkColor
:
:
Black
)
;
if
(
hasMarkedGrayRoots
)
{
return
Finished
;
}
MOZ_ASSERT
(
cellsToAssertNotGray
.
ref
(
)
.
empty
(
)
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK
)
;
markIncomingCrossCompartmentPointers
(
MarkColor
:
:
Black
)
;
drainMarkStack
(
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
changeGCState
(
Zone
:
:
MarkBlackOnly
Zone
:
:
MarkBlackAndGray
)
;
}
AutoSetMarkColor
setColorGray
(
marker
MarkColor
:
:
Gray
)
;
marker
.
setMainStackColor
(
MarkColor
:
:
Gray
)
;
markIncomingCrossCompartmentPointers
(
MarkColor
:
:
Gray
)
;
markGrayRoots
<
SweepGroupZonesIter
>
(
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK_GRAY
)
;
hasMarkedGrayRoots
=
true
;
#
ifdef
JS_GC_ZEAL
if
(
shouldYieldForZeal
(
ZealMode
:
:
YieldWhileGrayMarking
)
)
{
return
NotFinished
;
}
#
endif
if
(
markUntilBudgetExhausted
(
budget
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK_GRAY
)
=
=
NotFinished
)
{
return
NotFinished
;
}
marker
.
setMainStackColor
(
MarkColor
:
:
Black
)
;
return
Finished
;
}
IncrementalProgress
GCRuntime
:
:
endMarkingSweepGroup
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
{
joinTask
(
sweepMarkTask
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK
)
;
if
(
sweepMarkTaskStarted
&
&
(
sweepMarkResult
=
=
NotFinished
)
)
{
return
NotFinished
;
}
MOZ_ASSERT
(
marker
.
markColor
(
)
=
=
MarkColor
:
:
Black
)
;
MOZ_ASSERT
(
!
HasIncomingCrossCompartmentPointers
(
rt
)
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK
)
;
markWeakReferencesInCurrentGroup
(
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK_WEAK
)
;
AutoSetMarkColor
setColorGray
(
marker
MarkColor
:
:
Gray
)
;
marker
.
setMainStackColor
(
MarkColor
:
:
Gray
)
;
markWeakReferencesInCurrentGroup
(
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK_GRAY_WEAK
)
;
MOZ_ASSERT
(
marker
.
isDrained
(
)
)
;
safeToYield
=
false
;
MaybeCheckWeakMapMarking
(
this
)
;
return
Finished
;
}
class
ImmediateSweepWeakCacheTask
:
public
GCParallelTaskHelper
<
ImmediateSweepWeakCacheTask
>
{
Zone
*
zone
;
JS
:
:
detail
:
:
WeakCacheBase
&
cache
;
ImmediateSweepWeakCacheTask
(
const
ImmediateSweepWeakCacheTask
&
)
=
delete
;
public
:
ImmediateSweepWeakCacheTask
(
GCRuntime
*
gc
Zone
*
zone
JS
:
:
detail
:
:
WeakCacheBase
&
wc
)
:
GCParallelTaskHelper
(
gc
)
zone
(
zone
)
cache
(
wc
)
{
}
ImmediateSweepWeakCacheTask
(
ImmediateSweepWeakCacheTask
&
&
other
)
:
GCParallelTaskHelper
(
std
:
:
move
(
other
)
)
zone
(
other
.
zone
)
cache
(
other
.
cache
)
{
}
void
run
(
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
zone
)
;
cache
.
sweep
(
)
;
}
}
;
void
GCRuntime
:
:
updateAtomsBitmap
(
)
{
DenseBitmap
marked
;
if
(
atomMarking
.
computeBitmapFromChunkMarkBits
(
rt
marked
)
)
{
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
atomMarking
.
refineZoneBitmapForCollectedZone
(
zone
marked
)
;
}
}
else
{
}
atomMarking
.
markAtomsUsedByUncollectedZones
(
rt
)
;
rt
-
>
symbolRegistry
(
)
.
sweep
(
)
;
SweepingTracer
trc
(
rt
)
;
for
(
RealmsIter
realm
(
this
)
;
!
realm
.
done
(
)
;
realm
.
next
(
)
)
{
realm
-
>
tracekWeakVarNames
(
&
trc
)
;
}
}
static
void
SweepCCWrappers
(
GCParallelTask
*
task
)
{
AutoSetThreadIsSweeping
threadIsSweeping
;
for
(
SweepGroupZonesIter
zone
(
task
-
>
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
sweepAllCrossCompartmentWrappers
(
)
;
}
}
static
void
SweepObjectGroups
(
GCParallelTask
*
task
)
{
SweepingTracer
trc
(
task
-
>
gc
-
>
rt
)
;
for
(
SweepGroupRealmsIter
r
(
task
-
>
gc
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
r
-
>
zone
(
)
)
;
r
-
>
traceWeakObjectGroups
(
&
trc
)
;
}
}
static
void
SweepMisc
(
GCParallelTask
*
task
)
{
SweepingTracer
trc
(
task
-
>
gc
-
>
rt
)
;
for
(
SweepGroupRealmsIter
r
(
task
-
>
gc
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
r
-
>
zone
(
)
)
;
r
-
>
traceWeakObjects
(
&
trc
)
;
r
-
>
traceWeakTemplateObjects
(
&
trc
)
;
r
-
>
traceWeakSavedStacks
(
&
trc
)
;
r
-
>
traceWeakSelfHostingScriptSource
(
&
trc
)
;
r
-
>
traceWeakObjectRealm
(
&
trc
)
;
r
-
>
traceWeakRegExps
(
&
trc
)
;
}
}
static
void
SweepCompressionTasks
(
GCParallelTask
*
task
)
{
JSRuntime
*
runtime
=
task
-
>
gc
-
>
rt
;
AutoLockHelperThreadState
lock
;
AttachFinishedCompressions
(
runtime
lock
)
;
auto
&
pending
=
HelperThreadState
(
)
.
compressionPendingList
(
lock
)
;
for
(
size_t
i
=
0
;
i
<
pending
.
length
(
)
;
i
+
+
)
{
if
(
pending
[
i
]
-
>
shouldCancel
(
)
)
{
HelperThreadState
(
)
.
remove
(
pending
&
i
)
;
}
}
}
void
js
:
:
gc
:
:
SweepLazyScripts
(
GCParallelTask
*
task
)
{
for
(
SweepGroupZonesIter
zone
(
task
-
>
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
zone
)
;
for
(
auto
i
=
zone
-
>
cellIter
<
LazyScript
>
(
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
WeakHeapPtrScript
*
edge
=
&
i
.
unbarrieredGet
(
)
-
>
script_
;
if
(
*
edge
&
&
IsAboutToBeFinalized
(
edge
)
)
{
*
edge
=
nullptr
;
}
}
}
}
static
void
SweepWeakMaps
(
GCParallelTask
*
task
)
{
AutoSetThreadIsSweeping
threadIsSweeping
;
for
(
SweepGroupZonesIter
zone
(
task
-
>
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
zone
-
>
gcWeakKeys
(
)
.
clear
(
)
)
{
oomUnsafe
.
crash
(
"
clearing
weak
keys
in
beginSweepingSweepGroup
(
)
"
)
;
}
zone
-
>
sweepWeakMaps
(
)
;
}
}
static
void
SweepUniqueIds
(
GCParallelTask
*
task
)
{
for
(
SweepGroupZonesIter
zone
(
task
-
>
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
zone
)
;
zone
-
>
sweepUniqueIds
(
)
;
}
}
void
js
:
:
gc
:
:
SweepFinalizationGroups
(
GCParallelTask
*
task
)
{
for
(
SweepGroupZonesIter
zone
(
task
-
>
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
AutoSetThreadIsSweeping
threadIsSweeping
(
zone
)
;
task
-
>
gc
-
>
sweepFinalizationGroups
(
zone
)
;
}
}
void
GCRuntime
:
:
startTask
(
GCParallelTask
&
task
gcstats
:
:
PhaseKind
phase
AutoLockHelperThreadState
&
lock
)
{
if
(
!
CanUseExtraThreads
(
)
)
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
phase
)
;
task
.
runFromMainThread
(
)
;
return
;
}
task
.
startWithLockHeld
(
lock
)
;
}
void
GCRuntime
:
:
joinTask
(
GCParallelTask
&
task
gcstats
:
:
PhaseKind
phase
AutoLockHelperThreadState
&
lock
)
{
if
(
task
.
isIdle
(
lock
)
)
{
return
;
}
if
(
task
.
isDispatched
(
lock
)
)
{
task
.
cancelDispatchedTask
(
lock
)
;
AutoUnlockHelperThreadState
unlock
(
lock
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
phase
)
;
task
.
runFromMainThread
(
)
;
return
;
}
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
JOIN_PARALLEL_TASKS
)
;
task
.
joinRunningOrFinishedTask
(
lock
)
;
}
stats
(
)
.
recordParallelPhase
(
phase
task
.
duration
(
)
)
;
}
void
GCRuntime
:
:
joinTask
(
GCParallelTask
&
task
gcstats
:
:
PhaseKind
phase
)
{
AutoLockHelperThreadState
lock
;
joinTask
(
task
phase
lock
)
;
}
void
GCRuntime
:
:
sweepDebuggerOnMainThread
(
JSFreeOp
*
fop
)
{
DebugAPI
:
:
sweepAll
(
fop
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_COMPARTMENTS
)
;
{
gcstats
:
:
AutoPhase
ap2
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_MISC
)
;
for
(
SweepGroupRealmsIter
r
(
rt
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
r
-
>
sweepDebugEnvironments
(
)
;
}
}
}
void
GCRuntime
:
:
sweepJitDataOnMainThread
(
JSFreeOp
*
fop
)
{
SweepingTracer
trc
(
rt
)
;
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_JIT_DATA
)
;
if
(
initialState
!
=
State
:
:
NotActive
)
{
js
:
:
CancelOffThreadIonCompile
(
rt
JS
:
:
Zone
:
:
Sweep
)
;
}
jit
:
:
JitRuntime
:
:
TraceWeakJitcodeGlobalTable
(
rt
&
trc
)
;
}
if
(
initialState
!
=
State
:
:
NotActive
)
{
gcstats
:
:
AutoPhase
apdc
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_DISCARD_CODE
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
discardJitCode
(
fop
)
;
}
}
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_JIT_DATA
)
;
for
(
SweepGroupRealmsIter
r
(
rt
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
r
-
>
traceWeakEdgesInJitRealm
(
&
trc
)
;
}
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
jit
:
:
JitZone
*
jitZone
=
zone
-
>
jitZone
(
)
)
{
jitZone
-
>
traceWeak
(
&
trc
)
;
}
}
}
{
gcstats
:
:
AutoPhase
ap1
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_TYPES
)
;
gcstats
:
:
AutoPhase
ap2
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_TYPES_BEGIN
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
beginSweepTypes
(
)
;
}
}
}
using
WeakCacheTaskVector
=
mozilla
:
:
Vector
<
ImmediateSweepWeakCacheTask
0
SystemAllocPolicy
>
;
template
<
typename
Functor
>
static
inline
bool
IterateWeakCaches
(
JSRuntime
*
rt
Functor
f
)
{
for
(
SweepGroupZonesIter
zone
(
rt
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
JS
:
:
detail
:
:
WeakCacheBase
*
cache
:
zone
-
>
weakCaches
(
)
)
{
if
(
!
f
(
cache
zone
.
get
(
)
)
)
{
return
false
;
}
}
}
for
(
JS
:
:
detail
:
:
WeakCacheBase
*
cache
:
rt
-
>
weakCaches
(
)
)
{
if
(
!
f
(
cache
nullptr
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
PrepareWeakCacheTasks
(
JSRuntime
*
rt
WeakCacheTaskVector
*
immediateTasks
)
{
MOZ_ASSERT
(
immediateTasks
-
>
empty
(
)
)
;
bool
ok
=
IterateWeakCaches
(
rt
[
&
]
(
JS
:
:
detail
:
:
WeakCacheBase
*
cache
Zone
*
zone
)
{
if
(
!
cache
-
>
needsSweep
(
)
)
{
return
true
;
}
if
(
zone
&
&
cache
-
>
setNeedsIncrementalBarrier
(
true
)
)
{
return
true
;
}
return
immediateTasks
-
>
emplaceBack
(
&
rt
-
>
gc
zone
*
cache
)
;
}
)
;
if
(
!
ok
)
{
immediateTasks
-
>
clearAndFree
(
)
;
}
return
ok
;
}
static
void
SweepWeakCachesOnMainThread
(
JSRuntime
*
rt
)
{
gcstats
:
:
AutoPhase
ap
(
rt
-
>
gc
.
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_WEAK_CACHES
)
;
IterateWeakCaches
(
rt
[
&
]
(
JS
:
:
detail
:
:
WeakCacheBase
*
cache
Zone
*
zone
)
{
if
(
cache
-
>
needsIncrementalBarrier
(
)
)
{
cache
-
>
setNeedsIncrementalBarrier
(
false
)
;
}
cache
-
>
sweep
(
)
;
return
true
;
}
)
;
}
IncrementalProgress
GCRuntime
:
:
beginSweepingSweepGroup
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
{
using
namespace
gcstats
;
AutoSCC
scc
(
stats
(
)
sweepGroupIndex
)
;
bool
sweepingAtoms
=
false
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
changeGCState
(
Zone
:
:
MarkBlackAndGray
Zone
:
:
Sweep
)
;
zone
-
>
arenas
.
unmarkPreMarkedFreeCells
(
)
;
zone
-
>
arenas
.
clearFreeLists
(
)
;
if
(
zone
-
>
isAtomsZone
(
)
)
{
sweepingAtoms
=
true
;
}
}
validateIncrementalMarking
(
)
;
#
ifdef
DEBUG
for
(
auto
cell
:
cellsToAssertNotGray
.
ref
(
)
)
{
JS
:
:
AssertCellIsNotGray
(
cell
)
;
}
cellsToAssertNotGray
.
ref
(
)
.
clearAndFree
(
)
;
#
endif
{
AutoPhase
ap
(
stats
(
)
PhaseKind
:
:
FINALIZE_START
)
;
callFinalizeCallbacks
(
fop
JSFINALIZE_GROUP_PREPARE
)
;
{
AutoPhase
ap2
(
stats
(
)
PhaseKind
:
:
WEAK_ZONES_CALLBACK
)
;
callWeakPointerZonesCallbacks
(
)
;
}
{
AutoPhase
ap2
(
stats
(
)
PhaseKind
:
:
WEAK_COMPARTMENT_CALLBACK
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
callWeakPointerCompartmentCallbacks
(
comp
)
;
}
}
}
callFinalizeCallbacks
(
fop
JSFINALIZE_GROUP_START
)
;
}
if
(
sweepingAtoms
)
{
AutoPhase
ap
(
stats
(
)
PhaseKind
:
:
UPDATE_ATOMS_BITMAP
)
;
updateAtomsBitmap
(
)
;
}
AutoSetThreadIsSweeping
threadIsSweeping
;
sweepDebuggerOnMainThread
(
fop
)
;
{
AutoLockHelperThreadState
lock
;
AutoPhase
ap
(
stats
(
)
PhaseKind
:
:
SWEEP_COMPARTMENTS
)
;
AutoRunParallelTask
sweepCCWrappers
(
this
SweepCCWrappers
PhaseKind
:
:
SWEEP_CC_WRAPPER
lock
)
;
AutoRunParallelTask
sweepObjectGroups
(
this
SweepObjectGroups
PhaseKind
:
:
SWEEP_TYPE_OBJECT
lock
)
;
AutoRunParallelTask
sweepMisc
(
this
SweepMisc
PhaseKind
:
:
SWEEP_MISC
lock
)
;
AutoRunParallelTask
sweepCompTasks
(
this
SweepCompressionTasks
PhaseKind
:
:
SWEEP_COMPRESSION
lock
)
;
AutoRunParallelTask
sweepLazyScripts
(
this
SweepLazyScripts
PhaseKind
:
:
SWEEP_LAZYSCRIPTS
lock
)
;
AutoRunParallelTask
sweepWeakMaps
(
this
SweepWeakMaps
PhaseKind
:
:
SWEEP_WEAKMAPS
lock
)
;
AutoRunParallelTask
sweepUniqueIds
(
this
SweepUniqueIds
PhaseKind
:
:
SWEEP_UNIQUEIDS
lock
)
;
AutoRunParallelTask
sweepFinalizationGroups
(
this
SweepFinalizationGroups
PhaseKind
:
:
SWEEP_FINALIZATION_GROUPS
lock
)
;
WeakCacheTaskVector
sweepCacheTasks
;
if
(
!
PrepareWeakCacheTasks
(
rt
&
sweepCacheTasks
)
)
{
SweepWeakCachesOnMainThread
(
rt
)
;
}
for
(
auto
&
task
:
sweepCacheTasks
)
{
startTask
(
task
PhaseKind
:
:
SWEEP_WEAK_CACHES
lock
)
;
}
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
sweepJitDataOnMainThread
(
fop
)
;
}
for
(
auto
&
task
:
sweepCacheTasks
)
{
joinTask
(
task
PhaseKind
:
:
SWEEP_WEAK_CACHES
lock
)
;
}
}
if
(
sweepingAtoms
)
{
startSweepingAtomsTable
(
)
;
}
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
arenas
.
queueForForegroundSweep
(
fop
ForegroundObjectFinalizePhase
)
;
zone
-
>
arenas
.
queueForForegroundSweep
(
fop
ForegroundNonObjectFinalizePhase
)
;
for
(
unsigned
i
=
0
;
i
<
ArrayLength
(
BackgroundFinalizePhases
)
;
+
+
i
)
{
zone
-
>
arenas
.
queueForBackgroundSweep
(
fop
BackgroundFinalizePhases
[
i
]
)
;
}
zone
-
>
arenas
.
queueForegroundThingsForSweep
(
)
;
}
sweepCache
=
nullptr
;
safeToYield
=
true
;
return
Finished
;
}
#
ifdef
JS_GC_ZEAL
bool
GCRuntime
:
:
shouldYieldForZeal
(
ZealMode
mode
)
{
bool
yield
=
useZeal
&
&
isIncremental
&
&
hasZealMode
(
mode
)
;
bool
firstSweepSlice
=
initialState
!
=
State
:
:
Sweep
;
if
(
mode
=
=
ZealMode
:
:
IncrementalMultipleSlices
&
&
!
firstSweepSlice
)
{
yield
=
false
;
}
return
yield
;
}
#
endif
IncrementalProgress
GCRuntime
:
:
endSweepingSweepGroup
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
{
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
FINALIZE_END
)
;
JSFreeOp
fop
(
rt
)
;
callFinalizeCallbacks
(
&
fop
JSFINALIZE_GROUP_END
)
;
}
startBackgroundFree
(
)
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
jit
:
:
JitZone
*
jitZone
=
zone
-
>
jitZone
(
)
)
{
jitZone
-
>
execAlloc
(
)
.
purge
(
)
;
}
AutoLockGC
lock
(
this
)
;
zone
-
>
changeGCState
(
Zone
:
:
Sweep
Zone
:
:
Finished
)
;
zone
-
>
updateGCThresholds
(
*
this
invocationKind
lock
)
;
zone
-
>
arenas
.
unmarkPreMarkedFreeCells
(
)
;
}
bool
sweepAtomsZone
=
false
;
ZoneList
zones
;
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
isAtomsZone
(
)
)
{
sweepAtomsZone
=
true
;
}
else
{
zones
.
append
(
zone
)
;
}
}
if
(
sweepAtomsZone
)
{
zones
.
append
(
atomsZone
)
;
}
queueZonesAndStartBackgroundSweep
(
zones
)
;
return
Finished
;
}
void
GCRuntime
:
:
beginSweepPhase
(
JS
:
:
GCReason
reason
AutoGCSession
&
session
)
{
MOZ_ASSERT
(
!
abortSweepAfterCurrentGroup
)
;
releaseHeldRelocatedArenas
(
)
;
computeNonIncrementalMarkingForValidation
(
session
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP
)
;
hasMarkedGrayRoots
=
false
;
AssertNoWrappersInGrayList
(
rt
)
;
dropStringWrappers
(
)
;
groupZonesForSweeping
(
reason
)
;
sweepActions
-
>
assertFinished
(
)
;
}
bool
ArenaLists
:
:
foregroundFinalize
(
JSFreeOp
*
fop
AllocKind
thingKind
SliceBudget
&
sliceBudget
SortedArenaList
&
sweepList
)
{
if
(
!
arenaListsToSweep
(
thingKind
)
&
&
incrementalSweptArenas
.
ref
(
)
.
isEmpty
(
)
)
{
return
true
;
}
if
(
!
FinalizeArenas
(
fop
&
arenaListsToSweep
(
thingKind
)
sweepList
thingKind
sliceBudget
)
)
{
incrementalSweptArenaKind
=
thingKind
;
incrementalSweptArenas
=
sweepList
.
toArenaList
(
)
;
return
false
;
}
incrementalSweptArenas
.
ref
(
)
.
clear
(
)
;
sweepList
.
extractEmpty
(
&
savedEmptyArenas
.
ref
(
)
)
;
ArenaList
finalized
=
sweepList
.
toArenaList
(
)
;
arenaLists
(
thingKind
)
=
finalized
.
insertListWithCursorAtEnd
(
arenaLists
(
thingKind
)
)
;
return
true
;
}
void
js
:
:
gc
:
:
SweepMarkTask
:
:
run
(
)
{
gc
-
>
sweepMarkResult
=
gc
-
>
markUntilBudgetExhausted
(
this
-
>
budget
)
;
}
IncrementalProgress
GCRuntime
:
:
markUntilBudgetExhausted
(
SliceBudget
&
sliceBudget
gcstats
:
:
PhaseKind
phase
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
phase
)
;
return
markUntilBudgetExhausted
(
sliceBudget
)
;
}
IncrementalProgress
GCRuntime
:
:
markUntilBudgetExhausted
(
SliceBudget
&
sliceBudget
)
{
mozilla
:
:
recordreplay
:
:
AutoDisallowThreadEvents
disallow
;
#
ifdef
DEBUG
AutoSetThreadIsMarking
threadIsMarking
;
#
endif
if
(
marker
.
processMarkQueue
(
)
=
=
GCMarker
:
:
QueueYielded
)
{
return
NotFinished
;
}
return
marker
.
markUntilBudgetExhausted
(
sliceBudget
)
?
Finished
:
NotFinished
;
}
void
GCRuntime
:
:
drainMarkStack
(
)
{
auto
unlimited
=
SliceBudget
:
:
unlimited
(
)
;
MOZ_RELEASE_ASSERT
(
marker
.
markUntilBudgetExhausted
(
unlimited
)
)
;
}
static
void
SweepThing
(
JSFreeOp
*
fop
Shape
*
shape
)
{
if
(
!
shape
-
>
isMarkedAny
(
)
)
{
shape
-
>
sweep
(
fop
)
;
}
}
static
void
SweepThing
(
JSFreeOp
*
fop
JSScript
*
script
)
{
AutoSweepJitScript
sweep
(
script
)
;
}
static
void
SweepThing
(
JSFreeOp
*
fop
ObjectGroup
*
group
)
{
AutoSweepObjectGroup
sweep
(
group
)
;
}
template
<
typename
T
>
static
bool
SweepArenaList
(
JSFreeOp
*
fop
Arena
*
*
arenasToSweep
SliceBudget
&
sliceBudget
)
{
while
(
Arena
*
arena
=
*
arenasToSweep
)
{
for
(
ArenaCellIterUnderGC
i
(
arena
)
;
!
i
.
done
(
)
;
i
.
next
(
)
)
{
SweepThing
(
fop
i
.
get
<
T
>
(
)
)
;
}
*
arenasToSweep
=
(
*
arenasToSweep
)
-
>
next
;
AllocKind
kind
=
MapTypeToFinalizeKind
<
T
>
:
:
kind
;
sliceBudget
.
step
(
Arena
:
:
thingsPerArena
(
kind
)
)
;
if
(
sliceBudget
.
isOverBudget
(
)
)
{
return
false
;
}
}
return
true
;
}
IncrementalProgress
GCRuntime
:
:
sweepTypeInformation
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
{
gcstats
:
:
AutoPhase
ap1
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_COMPARTMENTS
)
;
gcstats
:
:
AutoPhase
ap2
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_TYPES
)
;
ArenaLists
&
al
=
sweepZone
-
>
arenas
;
AutoClearTypeInferenceStateOnOOM
oom
(
sweepZone
)
;
if
(
!
SweepArenaList
<
JSScript
>
(
fop
&
al
.
gcScriptArenasToUpdate
.
ref
(
)
budget
)
)
{
return
NotFinished
;
}
if
(
!
SweepArenaList
<
ObjectGroup
>
(
fop
&
al
.
gcObjectGroupArenasToUpdate
.
ref
(
)
budget
)
)
{
return
NotFinished
;
}
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_TYPES_END
)
;
sweepZone
-
>
types
.
endSweep
(
rt
)
;
}
return
Finished
;
}
IncrementalProgress
GCRuntime
:
:
releaseSweptEmptyArenas
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
{
for
(
SweepGroupZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
arenas
.
releaseForegroundSweptEmptyArenas
(
)
;
}
return
Finished
;
}
void
GCRuntime
:
:
startSweepingAtomsTable
(
)
{
auto
&
maybeAtoms
=
maybeAtomsToSweep
.
ref
(
)
;
MOZ_ASSERT
(
maybeAtoms
.
isNothing
(
)
)
;
AtomsTable
*
atomsTable
=
rt
-
>
atomsForSweeping
(
)
;
if
(
!
atomsTable
)
{
return
;
}
if
(
!
atomsTable
-
>
startIncrementalSweep
(
)
)
{
SweepingTracer
trc
(
rt
)
;
atomsTable
-
>
traceWeak
(
&
trc
)
;
return
;
}
maybeAtoms
.
emplace
(
*
atomsTable
)
;
}
IncrementalProgress
GCRuntime
:
:
sweepAtomsTable
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
{
if
(
!
atomsZone
-
>
isGCSweeping
(
)
)
{
return
Finished
;
}
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_ATOMS_TABLE
)
;
auto
&
maybeAtoms
=
maybeAtomsToSweep
.
ref
(
)
;
if
(
!
maybeAtoms
)
{
return
Finished
;
}
if
(
!
rt
-
>
atomsForSweeping
(
)
-
>
sweepIncrementally
(
maybeAtoms
.
ref
(
)
budget
)
)
{
return
NotFinished
;
}
maybeAtoms
.
reset
(
)
;
return
Finished
;
}
class
js
:
:
gc
:
:
WeakCacheSweepIterator
{
public
:
using
WeakCacheBase
=
JS
:
:
detail
:
:
WeakCacheBase
;
struct
Item
{
WeakCacheBase
*
cache
;
Zone
*
zone
;
}
;
private
:
JS
:
:
Zone
*
&
sweepZone
;
WeakCacheBase
*
&
sweepCache
;
public
:
explicit
WeakCacheSweepIterator
(
GCRuntime
*
gc
)
:
sweepZone
(
gc
-
>
sweepZone
.
ref
(
)
)
sweepCache
(
gc
-
>
sweepCache
.
ref
(
)
)
{
if
(
!
sweepZone
)
{
sweepZone
=
gc
-
>
currentSweepGroup
;
MOZ_ASSERT
(
!
sweepCache
)
;
sweepCache
=
sweepZone
-
>
weakCaches
(
)
.
getFirst
(
)
;
settle
(
)
;
}
checkState
(
)
;
}
bool
empty
(
AutoLockHelperThreadState
&
lock
)
{
return
!
sweepZone
;
}
Item
next
(
AutoLockHelperThreadState
&
lock
)
{
if
(
empty
(
lock
)
)
{
return
{
nullptr
nullptr
}
;
}
Item
result
{
sweepCache
sweepZone
}
;
sweepCache
=
sweepCache
-
>
getNext
(
)
;
settle
(
)
;
checkState
(
)
;
return
result
;
}
void
settle
(
)
{
while
(
sweepZone
)
{
while
(
sweepCache
&
&
!
sweepCache
-
>
needsIncrementalBarrier
(
)
)
{
sweepCache
=
sweepCache
-
>
getNext
(
)
;
}
if
(
sweepCache
)
{
break
;
}
sweepZone
=
sweepZone
-
>
nextNodeInGroup
(
)
;
if
(
sweepZone
)
{
sweepCache
=
sweepZone
-
>
weakCaches
(
)
.
getFirst
(
)
;
}
}
}
private
:
void
checkState
(
)
{
MOZ_ASSERT
(
(
!
sweepZone
&
&
!
sweepCache
)
|
|
(
sweepCache
&
&
sweepCache
-
>
needsIncrementalBarrier
(
)
)
)
;
}
}
;
class
IncrementalSweepWeakCacheTask
:
public
GCParallelTaskHelper
<
IncrementalSweepWeakCacheTask
>
{
WeakCacheSweepIterator
&
work_
;
SliceBudget
&
budget_
;
AutoLockHelperThreadState
&
lock_
;
WeakCacheSweepIterator
:
:
Item
item_
;
public
:
IncrementalSweepWeakCacheTask
(
GCRuntime
*
gc
WeakCacheSweepIterator
&
work
SliceBudget
&
budget
AutoLockHelperThreadState
&
lock
)
:
GCParallelTaskHelper
(
gc
)
work_
(
work
)
budget_
(
budget
)
lock_
(
lock
)
item_
(
work
.
next
(
lock
)
)
{
MOZ_ASSERT
(
item_
.
cache
)
;
gc
-
>
startTask
(
*
this
gcstats
:
:
PhaseKind
:
:
SWEEP_WEAK_CACHES
lock_
)
;
}
~
IncrementalSweepWeakCacheTask
(
)
{
gc
-
>
joinTask
(
*
this
gcstats
:
:
PhaseKind
:
:
SWEEP_WEAK_CACHES
lock_
)
;
}
void
run
(
)
{
do
{
JS
:
:
detail
:
:
WeakCacheBase
*
cache
=
item_
.
cache
;
AutoSetThreadIsSweeping
threadIsSweeping
(
item_
.
zone
)
;
MOZ_ASSERT
(
cache
-
>
needsIncrementalBarrier
(
)
)
;
size_t
steps
=
cache
-
>
sweep
(
)
;
cache
-
>
setNeedsIncrementalBarrier
(
false
)
;
AutoLockHelperThreadState
lock
;
budget_
.
step
(
steps
)
;
if
(
budget_
.
isOverBudget
(
)
)
{
break
;
}
item_
=
work_
.
next
(
lock
)
;
}
while
(
item_
.
cache
)
;
}
}
;
static
const
size_t
MaxWeakCacheSweepTasks
=
8
;
static
size_t
WeakCacheSweepTaskCount
(
)
{
size_t
targetTaskCount
=
HelperThreadState
(
)
.
cpuCount
;
return
std
:
:
min
(
targetTaskCount
MaxWeakCacheSweepTasks
)
;
}
IncrementalProgress
GCRuntime
:
:
sweepWeakCaches
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
{
WeakCacheSweepIterator
work
(
this
)
;
{
AutoLockHelperThreadState
lock
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_COMPARTMENTS
)
;
Maybe
<
IncrementalSweepWeakCacheTask
>
tasks
[
MaxWeakCacheSweepTasks
]
;
for
(
size_t
i
=
0
;
!
work
.
empty
(
lock
)
&
&
i
<
WeakCacheSweepTaskCount
(
)
;
i
+
+
)
{
tasks
[
i
]
.
emplace
(
this
work
budget
lock
)
;
}
}
AutoLockHelperThreadState
lock
;
return
work
.
empty
(
lock
)
?
Finished
:
NotFinished
;
}
IncrementalProgress
GCRuntime
:
:
finalizeAllocKind
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
{
size_t
thingsPerArena
=
Arena
:
:
thingsPerArena
(
sweepAllocKind
)
;
auto
&
sweepList
=
incrementalSweepList
.
ref
(
)
;
sweepList
.
setThingsPerArena
(
thingsPerArena
)
;
AutoSetThreadIsSweeping
threadIsSweeping
(
sweepZone
)
;
if
(
!
sweepZone
-
>
arenas
.
foregroundFinalize
(
fop
sweepAllocKind
budget
sweepList
)
)
{
return
NotFinished
;
}
sweepList
.
reset
(
thingsPerArena
)
;
return
Finished
;
}
IncrementalProgress
GCRuntime
:
:
sweepShapeTree
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP_SHAPE
)
;
ArenaLists
&
al
=
sweepZone
-
>
arenas
;
if
(
!
SweepArenaList
<
Shape
>
(
fop
&
al
.
gcShapeArenasToUpdate
.
ref
(
)
budget
)
)
{
return
NotFinished
;
}
if
(
!
SweepArenaList
<
AccessorShape
>
(
fop
&
al
.
gcAccessorShapeArenasToUpdate
.
ref
(
)
budget
)
)
{
return
NotFinished
;
}
return
Finished
;
}
template
<
typename
Container
>
class
ContainerIter
{
using
Iter
=
decltype
(
mozilla
:
:
DeclVal
<
const
Container
>
(
)
.
begin
(
)
)
;
using
Elem
=
decltype
(
*
mozilla
:
:
DeclVal
<
Iter
>
(
)
)
;
Iter
iter
;
const
Iter
end
;
public
:
explicit
ContainerIter
(
const
Container
&
container
)
:
iter
(
container
.
begin
(
)
)
end
(
container
.
end
(
)
)
{
}
bool
done
(
)
const
{
return
iter
=
=
end
;
}
Elem
get
(
)
const
{
return
*
iter
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
+
+
iter
;
}
}
;
template
<
typename
Iter
>
struct
IncrementalIter
{
using
State
=
Maybe
<
Iter
>
;
using
Elem
=
decltype
(
mozilla
:
:
DeclVal
<
Iter
>
(
)
.
get
(
)
)
;
private
:
State
&
maybeIter
;
public
:
template
<
typename
.
.
.
Args
>
explicit
IncrementalIter
(
State
&
maybeIter
Args
&
&
.
.
.
args
)
:
maybeIter
(
maybeIter
)
{
if
(
maybeIter
.
isNothing
(
)
)
{
maybeIter
.
emplace
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
~
IncrementalIter
(
)
{
if
(
done
(
)
)
{
maybeIter
.
reset
(
)
;
}
}
bool
done
(
)
const
{
return
maybeIter
.
ref
(
)
.
done
(
)
;
}
Elem
get
(
)
const
{
return
maybeIter
.
ref
(
)
.
get
(
)
;
}
void
next
(
)
{
maybeIter
.
ref
(
)
.
next
(
)
;
}
}
;
class
js
:
:
gc
:
:
SweepGroupsIter
{
GCRuntime
*
gc
;
public
:
explicit
SweepGroupsIter
(
JSRuntime
*
rt
)
:
gc
(
&
rt
-
>
gc
)
{
MOZ_ASSERT
(
gc
-
>
currentSweepGroup
)
;
}
bool
done
(
)
const
{
return
!
gc
-
>
currentSweepGroup
;
}
Zone
*
get
(
)
const
{
return
gc
-
>
currentSweepGroup
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
gc
-
>
getNextSweepGroup
(
)
;
}
}
;
namespace
sweepaction
{
class
SweepActionCall
final
:
public
SweepAction
{
using
Method
=
IncrementalProgress
(
GCRuntime
:
:
*
)
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
;
Method
method
;
public
:
explicit
SweepActionCall
(
Method
m
)
:
method
(
m
)
{
}
IncrementalProgress
run
(
Args
&
args
)
override
{
return
(
args
.
gc
-
>
*
method
)
(
args
.
fop
args
.
budget
)
;
}
void
assertFinished
(
)
const
override
{
}
}
;
class
SweepActionMaybeYield
final
:
public
SweepAction
{
#
ifdef
JS_GC_ZEAL
ZealMode
mode
;
bool
isYielding
;
#
endif
public
:
explicit
SweepActionMaybeYield
(
ZealMode
mode
)
#
ifdef
JS_GC_ZEAL
:
mode
(
mode
)
isYielding
(
false
)
#
endif
{
}
IncrementalProgress
run
(
Args
&
args
)
override
{
#
ifdef
JS_GC_ZEAL
if
(
!
isYielding
&
&
args
.
gc
-
>
shouldYieldForZeal
(
mode
)
)
{
isYielding
=
true
;
return
NotFinished
;
}
isYielding
=
false
;
#
endif
return
Finished
;
}
void
assertFinished
(
)
const
override
{
MOZ_ASSERT
(
!
isYielding
)
;
}
#
ifndef
JS_GC_ZEAL
bool
shouldSkip
(
)
override
{
return
true
;
}
#
endif
}
;
class
SweepActionSequence
final
:
public
SweepAction
{
using
ActionVector
=
Vector
<
UniquePtr
<
SweepAction
>
0
SystemAllocPolicy
>
;
using
Iter
=
IncrementalIter
<
ContainerIter
<
ActionVector
>
>
;
ActionVector
actions
;
typename
Iter
:
:
State
iterState
;
public
:
bool
init
(
UniquePtr
<
SweepAction
>
*
acts
size_t
count
)
{
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
auto
&
action
=
acts
[
i
]
;
if
(
!
action
)
{
return
false
;
}
if
(
action
-
>
shouldSkip
(
)
)
{
continue
;
}
if
(
!
actions
.
emplaceBack
(
std
:
:
move
(
action
)
)
)
{
return
false
;
}
}
return
true
;
}
IncrementalProgress
run
(
Args
&
args
)
override
{
for
(
Iter
iter
(
iterState
actions
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
if
(
iter
.
get
(
)
-
>
run
(
args
)
=
=
NotFinished
)
{
return
NotFinished
;
}
}
return
Finished
;
}
void
assertFinished
(
)
const
override
{
MOZ_ASSERT
(
iterState
.
isNothing
(
)
)
;
for
(
const
auto
&
action
:
actions
)
{
action
-
>
assertFinished
(
)
;
}
}
}
;
template
<
typename
Iter
typename
Init
>
class
SweepActionForEach
final
:
public
SweepAction
{
using
Elem
=
decltype
(
mozilla
:
:
DeclVal
<
Iter
>
(
)
.
get
(
)
)
;
using
IncrIter
=
IncrementalIter
<
Iter
>
;
Init
iterInit
;
Elem
*
elemOut
;
UniquePtr
<
SweepAction
>
action
;
typename
IncrIter
:
:
State
iterState
;
public
:
SweepActionForEach
(
const
Init
&
init
Elem
*
maybeElemOut
UniquePtr
<
SweepAction
>
action
)
:
iterInit
(
init
)
elemOut
(
maybeElemOut
)
action
(
std
:
:
move
(
action
)
)
{
}
IncrementalProgress
run
(
Args
&
args
)
override
{
MOZ_ASSERT_IF
(
elemOut
*
elemOut
=
=
Elem
(
)
)
;
auto
clearElem
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
setElem
(
Elem
(
)
)
;
}
)
;
for
(
IncrIter
iter
(
iterState
iterInit
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
setElem
(
iter
.
get
(
)
)
;
if
(
action
-
>
run
(
args
)
=
=
NotFinished
)
{
return
NotFinished
;
}
}
return
Finished
;
}
void
assertFinished
(
)
const
override
{
MOZ_ASSERT
(
iterState
.
isNothing
(
)
)
;
MOZ_ASSERT_IF
(
elemOut
*
elemOut
=
=
Elem
(
)
)
;
action
-
>
assertFinished
(
)
;
}
private
:
void
setElem
(
const
Elem
&
value
)
{
if
(
elemOut
)
{
*
elemOut
=
value
;
}
}
}
;
static
UniquePtr
<
SweepAction
>
Call
(
IncrementalProgress
(
GCRuntime
:
:
*
method
)
(
JSFreeOp
*
fop
SliceBudget
&
budget
)
)
{
return
MakeUnique
<
SweepActionCall
>
(
method
)
;
}
static
UniquePtr
<
SweepAction
>
MaybeYield
(
ZealMode
zealMode
)
{
return
MakeUnique
<
SweepActionMaybeYield
>
(
zealMode
)
;
}
template
<
typename
.
.
.
Rest
>
static
UniquePtr
<
SweepAction
>
Sequence
(
UniquePtr
<
SweepAction
>
first
Rest
.
.
.
rest
)
{
UniquePtr
<
SweepAction
>
actions
[
]
=
{
std
:
:
move
(
first
)
std
:
:
move
(
rest
)
.
.
.
}
;
auto
seq
=
MakeUnique
<
SweepActionSequence
>
(
)
;
if
(
!
seq
|
|
!
seq
-
>
init
(
actions
ArrayLength
(
actions
)
)
)
{
return
nullptr
;
}
return
UniquePtr
<
SweepAction
>
(
std
:
:
move
(
seq
)
)
;
}
static
UniquePtr
<
SweepAction
>
RepeatForSweepGroup
(
JSRuntime
*
rt
UniquePtr
<
SweepAction
>
action
)
{
if
(
!
action
)
{
return
nullptr
;
}
using
Action
=
SweepActionForEach
<
SweepGroupsIter
JSRuntime
*
>
;
return
js
:
:
MakeUnique
<
Action
>
(
rt
nullptr
std
:
:
move
(
action
)
)
;
}
static
UniquePtr
<
SweepAction
>
ForEachZoneInSweepGroup
(
JSRuntime
*
rt
Zone
*
*
zoneOut
UniquePtr
<
SweepAction
>
action
)
{
if
(
!
action
)
{
return
nullptr
;
}
using
Action
=
SweepActionForEach
<
SweepGroupZonesIter
JSRuntime
*
>
;
return
js
:
:
MakeUnique
<
Action
>
(
rt
zoneOut
std
:
:
move
(
action
)
)
;
}
static
UniquePtr
<
SweepAction
>
ForEachAllocKind
(
AllocKinds
kinds
AllocKind
*
kindOut
UniquePtr
<
SweepAction
>
action
)
{
if
(
!
action
)
{
return
nullptr
;
}
using
Action
=
SweepActionForEach
<
ContainerIter
<
AllocKinds
>
AllocKinds
>
;
return
js
:
:
MakeUnique
<
Action
>
(
kinds
kindOut
std
:
:
move
(
action
)
)
;
}
}
bool
GCRuntime
:
:
initSweepActions
(
)
{
using
namespace
sweepaction
;
using
sweepaction
:
:
Call
;
sweepActions
.
ref
(
)
=
RepeatForSweepGroup
(
rt
Sequence
(
Call
(
&
GCRuntime
:
:
markGrayReferencesInCurrentGroup
)
Call
(
&
GCRuntime
:
:
endMarkingSweepGroup
)
Call
(
&
GCRuntime
:
:
beginSweepingSweepGroup
)
MaybeYield
(
ZealMode
:
:
IncrementalMultipleSlices
)
MaybeYield
(
ZealMode
:
:
YieldBeforeSweepingAtoms
)
Call
(
&
GCRuntime
:
:
sweepAtomsTable
)
MaybeYield
(
ZealMode
:
:
YieldBeforeSweepingCaches
)
Call
(
&
GCRuntime
:
:
sweepWeakCaches
)
ForEachZoneInSweepGroup
(
rt
&
sweepZone
.
ref
(
)
Sequence
(
MaybeYield
(
ZealMode
:
:
YieldBeforeSweepingTypes
)
Call
(
&
GCRuntime
:
:
sweepTypeInformation
)
MaybeYield
(
ZealMode
:
:
YieldBeforeSweepingObjects
)
ForEachAllocKind
(
ForegroundObjectFinalizePhase
.
kinds
&
sweepAllocKind
.
ref
(
)
Call
(
&
GCRuntime
:
:
finalizeAllocKind
)
)
MaybeYield
(
ZealMode
:
:
YieldBeforeSweepingNonObjects
)
ForEachAllocKind
(
ForegroundNonObjectFinalizePhase
.
kinds
&
sweepAllocKind
.
ref
(
)
Call
(
&
GCRuntime
:
:
finalizeAllocKind
)
)
MaybeYield
(
ZealMode
:
:
YieldBeforeSweepingShapeTrees
)
Call
(
&
GCRuntime
:
:
sweepShapeTree
)
)
)
Call
(
&
GCRuntime
:
:
releaseSweptEmptyArenas
)
Call
(
&
GCRuntime
:
:
endSweepingSweepGroup
)
)
)
;
return
sweepActions
!
=
nullptr
;
}
IncrementalProgress
GCRuntime
:
:
performSweepActions
(
SliceBudget
&
budget
)
{
mozilla
:
:
recordreplay
:
:
AutoDisallowThreadEvents
disallow
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP
)
;
JSFreeOp
fop
(
rt
)
;
MOZ_ASSERT
(
initialState
<
=
State
:
:
Sweep
)
;
MOZ_ASSERT_IF
(
initialState
!
=
State
:
:
Sweep
marker
.
isDrained
(
)
)
;
MOZ_ASSERT
(
!
sweepMarkTaskStarted
)
;
if
(
initialState
=
=
State
:
:
Sweep
&
&
!
marker
.
isDrained
(
)
)
{
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
sweepMarkTask
.
isIdle
(
lock
)
)
;
sweepMarkTask
.
setBudget
(
budget
)
;
sweepMarkTask
.
startOrRunIfIdle
(
lock
)
;
sweepMarkTaskStarted
=
true
;
}
SweepAction
:
:
Args
args
{
this
&
fop
budget
}
;
IncrementalProgress
progress
=
sweepActions
-
>
run
(
args
)
;
if
(
sweepMarkTaskStarted
)
{
joinTask
(
sweepMarkTask
gcstats
:
:
PhaseKind
:
:
SWEEP_MARK
)
;
sweepMarkTaskStarted
=
false
;
if
(
sweepMarkResult
=
=
NotFinished
)
{
progress
=
NotFinished
;
}
}
return
progress
;
}
bool
GCRuntime
:
:
allCCVisibleZonesWereCollected
(
)
{
for
(
ZonesIter
zone
(
this
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zone
-
>
isCollecting
(
)
&
&
!
zone
-
>
usedByHelperThread
(
)
&
&
!
zone
-
>
arenas
.
arenaListsAreEmpty
(
)
)
{
return
false
;
}
}
return
true
;
}
void
GCRuntime
:
:
endSweepPhase
(
bool
destroyingRuntime
)
{
sweepActions
-
>
assertFinished
(
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP
)
;
JSFreeOp
fop
(
rt
)
;
MOZ_ASSERT_IF
(
destroyingRuntime
!
sweepOnBackgroundThread
)
;
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
DESTROY
)
;
SweepScriptData
(
rt
)
;
}
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
FINALIZE_END
)
;
callFinalizeCallbacks
(
&
fop
JSFINALIZE_COLLECTION_END
)
;
if
(
allCCVisibleZonesWereCollected
(
)
)
{
grayBitsValid
=
true
;
}
}
finishMarkingValidation
(
)
;
#
ifdef
DEBUG
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
for
(
auto
i
:
AllAllocKinds
(
)
)
{
MOZ_ASSERT_IF
(
!
IsBackgroundFinalized
(
i
)
|
|
!
sweepOnBackgroundThread
!
zone
-
>
arenas
.
arenaListsToSweep
(
i
)
)
;
}
}
#
endif
AssertNoWrappersInGrayList
(
rt
)
;
}
void
GCRuntime
:
:
beginCompactPhase
(
)
{
MOZ_ASSERT
(
!
isBackgroundSweeping
(
)
)
;
assertBackgroundSweepingFinished
(
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
COMPACT
)
;
MOZ_ASSERT
(
zonesToMaybeCompact
.
ref
(
)
.
isEmpty
(
)
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
CanRelocateZone
(
zone
)
)
{
zonesToMaybeCompact
.
ref
(
)
.
append
(
zone
)
;
}
}
MOZ_ASSERT
(
!
relocatedArenasToRelease
)
;
startedCompacting
=
true
;
}
IncrementalProgress
GCRuntime
:
:
compactPhase
(
JS
:
:
GCReason
reason
SliceBudget
&
sliceBudget
AutoGCSession
&
session
)
{
assertBackgroundSweepingFinished
(
)
;
MOZ_ASSERT
(
startedCompacting
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
COMPACT
)
;
AutoSuppressProfilerSampling
suppressSampling
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
ZoneList
relocatedZones
;
Arena
*
relocatedArenas
=
nullptr
;
while
(
!
zonesToMaybeCompact
.
ref
(
)
.
isEmpty
(
)
)
{
Zone
*
zone
=
zonesToMaybeCompact
.
ref
(
)
.
front
(
)
;
zonesToMaybeCompact
.
ref
(
)
.
removeFront
(
)
;
MOZ_ASSERT
(
nursery
(
)
.
isEmpty
(
)
)
;
zone
-
>
changeGCState
(
Zone
:
:
Finished
Zone
:
:
Compact
)
;
if
(
relocateArenas
(
zone
reason
relocatedArenas
sliceBudget
)
)
{
updateZonePointersToRelocatedCells
(
zone
)
;
relocatedZones
.
append
(
zone
)
;
}
else
{
zone
-
>
changeGCState
(
Zone
:
:
Compact
Zone
:
:
Finished
)
;
}
if
(
sliceBudget
.
isOverBudget
(
)
)
{
break
;
}
}
if
(
!
relocatedZones
.
isEmpty
(
)
)
{
updateRuntimePointersToRelocatedCells
(
session
)
;
do
{
Zone
*
zone
=
relocatedZones
.
front
(
)
;
relocatedZones
.
removeFront
(
)
;
zone
-
>
changeGCState
(
Zone
:
:
Compact
Zone
:
:
Finished
)
;
}
while
(
!
relocatedZones
.
isEmpty
(
)
)
;
}
clearRelocatedArenas
(
relocatedArenas
reason
)
;
if
(
ShouldProtectRelocatedArenas
(
reason
)
)
{
protectAndHoldArenas
(
relocatedArenas
)
;
}
else
{
releaseRelocatedArenas
(
relocatedArenas
)
;
}
rt
-
>
caches
(
)
.
purgeForCompaction
(
)
;
#
ifdef
DEBUG
checkHashTablesAfterMovingGC
(
)
;
#
endif
return
zonesToMaybeCompact
.
ref
(
)
.
isEmpty
(
)
?
Finished
:
NotFinished
;
}
void
GCRuntime
:
:
endCompactPhase
(
)
{
startedCompacting
=
false
;
}
void
GCRuntime
:
:
finishCollection
(
)
{
assertBackgroundSweepingFinished
(
)
;
MOZ_ASSERT
(
marker
.
isDrained
(
)
)
;
marker
.
stop
(
)
;
clearBufferedGrayRoots
(
)
;
auto
currentTime
=
ReallyNow
(
)
;
schedulingState
.
updateHighFrequencyMode
(
lastGCEndTime_
currentTime
tunables
)
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
isCollecting
(
)
)
{
zone
-
>
changeGCState
(
Zone
:
:
Finished
Zone
:
:
NoGC
)
;
zone
-
>
gcDelayBytes
=
0
;
zone
-
>
notifyObservingDebuggers
(
)
;
}
MOZ_ASSERT
(
!
zone
-
>
wasGCStarted
(
)
)
;
MOZ_ASSERT
(
!
zone
-
>
needsIncrementalBarrier
(
)
)
;
MOZ_ASSERT
(
!
zone
-
>
isOnList
(
)
)
;
}
MOZ_ASSERT
(
zonesToMaybeCompact
.
ref
(
)
.
isEmpty
(
)
)
;
MOZ_ASSERT
(
cellsToAssertNotGray
.
ref
(
)
.
empty
(
)
)
;
lastGCEndTime_
=
currentTime
;
}
static
const
char
*
HeapStateToLabel
(
JS
:
:
HeapState
heapState
)
{
switch
(
heapState
)
{
case
JS
:
:
HeapState
:
:
MinorCollecting
:
return
"
js
:
:
Nursery
:
:
collect
"
;
case
JS
:
:
HeapState
:
:
MajorCollecting
:
return
"
js
:
:
GCRuntime
:
:
collect
"
;
case
JS
:
:
HeapState
:
:
Tracing
:
return
"
JS_IterateCompartments
"
;
case
JS
:
:
HeapState
:
:
Idle
:
case
JS
:
:
HeapState
:
:
CycleCollecting
:
MOZ_CRASH
(
"
Should
never
have
an
Idle
or
CC
heap
state
when
pushing
GC
"
"
profiling
stack
frames
!
"
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Should
have
exhausted
every
JS
:
:
HeapState
variant
!
"
)
;
return
nullptr
;
}
AutoHeapSession
:
:
AutoHeapSession
(
GCRuntime
*
gc
JS
:
:
HeapState
heapState
)
:
gc
(
gc
)
prevState
(
gc
-
>
heapState_
)
profilingStackFrame
(
gc
-
>
rt
-
>
mainContextFromOwnThread
(
)
HeapStateToLabel
(
heapState
)
JS
:
:
ProfilingCategoryPair
:
:
GCCC
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
gc
-
>
rt
)
)
;
MOZ_ASSERT
(
prevState
=
=
JS
:
:
HeapState
:
:
Idle
)
;
MOZ_ASSERT
(
heapState
!
=
JS
:
:
HeapState
:
:
Idle
)
;
gc
-
>
heapState_
=
heapState
;
}
AutoHeapSession
:
:
~
AutoHeapSession
(
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
gc
-
>
heapState_
=
prevState
;
}
JS_PUBLIC_API
JS
:
:
HeapState
JS
:
:
RuntimeHeapState
(
)
{
return
TlsContext
.
get
(
)
-
>
runtime
(
)
-
>
gc
.
heapState
(
)
;
}
GCRuntime
:
:
IncrementalResult
GCRuntime
:
:
resetIncrementalGC
(
gc
:
:
AbortReason
reason
)
{
if
(
incrementalState
=
=
State
:
:
NotActive
)
{
return
IncrementalResult
:
:
Ok
;
}
AutoGCSession
session
(
this
JS
:
:
HeapState
:
:
MajorCollecting
)
;
switch
(
incrementalState
)
{
case
State
:
:
NotActive
:
case
State
:
:
MarkRoots
:
case
State
:
:
Finish
:
MOZ_CRASH
(
"
Unexpected
GC
state
in
resetIncrementalGC
"
)
;
break
;
case
State
:
:
Mark
:
{
marker
.
reset
(
)
;
clearBufferedGrayRoots
(
)
;
for
(
GCCompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
ResetGrayList
(
c
)
;
}
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
setNeedsIncrementalBarrier
(
false
)
;
zone
-
>
changeGCState
(
Zone
:
:
MarkBlackOnly
Zone
:
:
NoGC
)
;
zone
-
>
gcDelayBytes
=
0
;
zone
-
>
arenas
.
unmarkPreMarkedFreeCells
(
)
;
}
{
AutoLockHelperThreadState
lock
;
lifoBlocksToFree
.
ref
(
)
.
freeAll
(
)
;
}
lastMarkSlice
=
false
;
incrementalState
=
State
:
:
Finish
;
MOZ_ASSERT
(
!
marker
.
shouldCheckCompartments
(
)
)
;
break
;
}
case
State
:
:
Sweep
:
{
for
(
CompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
c
-
>
gcState
.
scheduledForDestruction
=
false
;
}
abortSweepAfterCurrentGroup
=
true
;
isCompacting
=
false
;
break
;
}
case
State
:
:
Finalize
:
{
isCompacting
=
false
;
break
;
}
case
State
:
:
Compact
:
{
MOZ_ASSERT
(
isCompacting
)
;
startedCompacting
=
true
;
zonesToMaybeCompact
.
ref
(
)
.
clear
(
)
;
break
;
}
case
State
:
:
Decommit
:
{
break
;
}
}
stats
(
)
.
reset
(
reason
)
;
return
IncrementalResult
:
:
ResetIncremental
;
}
namespace
{
class
AutoDisableBarriers
{
public
:
explicit
AutoDisableBarriers
(
GCRuntime
*
gc
)
;
~
AutoDisableBarriers
(
)
;
private
:
GCRuntime
*
gc
;
}
;
}
AutoDisableBarriers
:
:
AutoDisableBarriers
(
GCRuntime
*
gc
)
:
gc
(
gc
)
{
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
isGCMarking
(
)
)
{
MOZ_ASSERT
(
zone
-
>
needsIncrementalBarrier
(
)
)
;
zone
-
>
setNeedsIncrementalBarrier
(
false
)
;
}
MOZ_ASSERT
(
!
zone
-
>
needsIncrementalBarrier
(
)
)
;
}
}
AutoDisableBarriers
:
:
~
AutoDisableBarriers
(
)
{
for
(
ZonesIter
zone
(
gc
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
!
zone
-
>
needsIncrementalBarrier
(
)
)
;
if
(
zone
-
>
isGCMarking
(
)
)
{
zone
-
>
setNeedsIncrementalBarrier
(
true
)
;
}
}
}
static
bool
IsShutdownGC
(
JS
:
:
GCReason
reason
)
{
return
reason
=
=
JS
:
:
GCReason
:
:
SHUTDOWN_CC
|
|
reason
=
=
JS
:
:
GCReason
:
:
DESTROY_RUNTIME
;
}
static
bool
ShouldCleanUpEverything
(
JS
:
:
GCReason
reason
JSGCInvocationKind
gckind
)
{
return
IsShutdownGC
(
reason
)
|
|
gckind
=
=
GC_SHRINK
;
}
static
bool
ShouldSweepOnBackgroundThread
(
JS
:
:
GCReason
reason
)
{
return
reason
!
=
JS
:
:
GCReason
:
:
DESTROY_RUNTIME
&
&
!
gcTracer
.
traceEnabled
(
)
&
&
CanUseExtraThreads
(
)
;
}
void
GCRuntime
:
:
incrementalSlice
(
SliceBudget
&
budget
const
MaybeInvocationKind
&
gckind
JS
:
:
GCReason
reason
AutoGCSession
&
session
)
{
AutoDisableBarriers
disableBarriers
(
this
)
;
AutoSetThreadIsPerformingGC
performingGC
;
bool
destroyingRuntime
=
(
reason
=
=
JS
:
:
GCReason
:
:
DESTROY_RUNTIME
)
;
initialState
=
incrementalState
;
#
ifdef
JS_GC_ZEAL
useZeal
=
reason
=
=
JS
:
:
GCReason
:
:
DEBUG_GC
&
&
!
budget
.
isUnlimited
(
)
;
#
else
bool
useZeal
=
false
;
#
endif
#
ifdef
DEBUG
{
char
budgetBuffer
[
32
]
;
budget
.
describe
(
budgetBuffer
32
)
;
stats
(
)
.
writeLogMessage
(
"
Incremental
:
%
d
lastMarkSlice
:
%
d
useZeal
:
%
d
budget
:
%
s
"
bool
(
isIncremental
)
bool
(
lastMarkSlice
)
bool
(
useZeal
)
budgetBuffer
)
;
}
#
endif
MOZ_ASSERT_IF
(
isIncrementalGCInProgress
(
)
isIncremental
)
;
if
(
!
isIncremental
)
{
MOZ_ASSERT
(
nursery
(
)
.
isEmpty
(
)
)
;
storeBuffer
(
)
.
checkEmpty
(
)
;
}
isIncremental
=
!
budget
.
isUnlimited
(
)
;
if
(
useZeal
&
&
hasIncrementalTwoSliceZealMode
(
)
)
{
stats
(
)
.
writeLogMessage
(
"
Using
unlimited
budget
for
two
-
slice
zeal
mode
"
)
;
budget
.
makeUnlimited
(
)
;
}
incGcSliceNumber
(
)
;
switch
(
incrementalState
)
{
case
State
:
:
NotActive
:
incMajorGcNumber
(
)
;
invocationKind
=
gckind
.
valueOr
(
GC_NORMAL
)
;
initialReason
=
reason
;
cleanUpEverything
=
ShouldCleanUpEverything
(
reason
invocationKind
)
;
sweepOnBackgroundThread
=
ShouldSweepOnBackgroundThread
(
reason
)
;
isCompacting
=
shouldCompact
(
)
;
MOZ_ASSERT
(
!
lastMarkSlice
)
;
rootsRemoved
=
false
;
lastGCStartTime_
=
ReallyNow
(
)
;
#
ifdef
DEBUG
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
gcSweepGroupIndex
=
0
;
}
#
endif
incrementalState
=
State
:
:
MarkRoots
;
MOZ_FALLTHROUGH
;
case
State
:
:
MarkRoots
:
if
(
!
beginMarkPhase
(
reason
session
)
)
{
incrementalState
=
State
:
:
NotActive
;
return
;
}
if
(
isIncremental
&
&
!
hasValidGrayRootsBuffer
(
)
)
{
budget
.
makeUnlimited
(
)
;
isIncremental
=
false
;
stats
(
)
.
nonincremental
(
AbortReason
:
:
GrayRootBufferingFailed
)
;
}
incrementalState
=
State
:
:
Mark
;
if
(
isIncremental
&
&
useZeal
&
&
hasZealMode
(
ZealMode
:
:
YieldBeforeMarking
)
)
{
break
;
}
MOZ_FALLTHROUGH
;
case
State
:
:
Mark
:
AutoGCRooter
:
:
traceAllWrappers
(
rt
-
>
mainContextFromOwnThread
(
)
&
marker
)
;
if
(
markUntilBudgetExhausted
(
budget
gcstats
:
:
PhaseKind
:
:
MARK
)
=
=
NotFinished
)
{
break
;
}
MOZ_ASSERT
(
marker
.
isDrained
(
)
)
;
if
(
isIncremental
&
&
!
lastMarkSlice
)
{
if
(
(
initialState
=
=
State
:
:
Mark
&
&
!
(
useZeal
&
&
hasZealMode
(
ZealMode
:
:
YieldBeforeMarking
)
)
)
|
|
(
useZeal
&
&
hasZealMode
(
ZealMode
:
:
YieldBeforeSweeping
)
)
)
{
lastMarkSlice
=
true
;
stats
(
)
.
writeLogMessage
(
"
Yielding
before
starting
sweeping
"
)
;
break
;
}
}
incrementalState
=
State
:
:
Sweep
;
lastMarkSlice
=
false
;
beginSweepPhase
(
reason
session
)
;
MOZ_FALLTHROUGH
;
case
State
:
:
Sweep
:
MOZ_ASSERT
(
nursery
(
)
.
isEmpty
(
)
)
;
storeBuffer
(
)
.
checkEmpty
(
)
;
AutoGCRooter
:
:
traceAllWrappers
(
rt
-
>
mainContextFromOwnThread
(
)
&
marker
)
;
if
(
performSweepActions
(
budget
)
=
=
NotFinished
)
{
break
;
}
endSweepPhase
(
destroyingRuntime
)
;
incrementalState
=
State
:
:
Finalize
;
MOZ_FALLTHROUGH
;
case
State
:
:
Finalize
:
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
WAIT_BACKGROUND_THREAD
)
;
if
(
!
budget
.
isUnlimited
(
)
)
{
if
(
isBackgroundSweeping
(
)
)
{
break
;
}
}
else
{
waitBackgroundSweepEnd
(
)
;
}
}
{
gcstats
:
:
AutoPhase
ap1
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
SWEEP
)
;
gcstats
:
:
AutoPhase
ap2
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
DESTROY
)
;
JSFreeOp
fop
(
rt
)
;
sweepZones
(
&
fop
destroyingRuntime
)
;
}
MOZ_ASSERT
(
!
startedCompacting
)
;
incrementalState
=
State
:
:
Compact
;
if
(
isCompacting
&
&
!
budget
.
isUnlimited
(
)
)
{
break
;
}
MOZ_FALLTHROUGH
;
case
State
:
:
Compact
:
if
(
isCompacting
)
{
MOZ_ASSERT
(
nursery
(
)
.
isEmpty
(
)
)
;
storeBuffer
(
)
.
checkEmpty
(
)
;
if
(
!
startedCompacting
)
{
beginCompactPhase
(
)
;
}
if
(
compactPhase
(
reason
budget
session
)
=
=
NotFinished
)
{
break
;
}
endCompactPhase
(
)
;
}
startDecommit
(
)
;
incrementalState
=
State
:
:
Decommit
;
MOZ_FALLTHROUGH
;
case
State
:
:
Decommit
:
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
WAIT_BACKGROUND_THREAD
)
;
if
(
!
budget
.
isUnlimited
(
)
&
&
decommitTask
.
wasStarted
(
)
)
{
break
;
}
decommitTask
.
join
(
)
;
incrementalState
=
State
:
:
Finish
;
MOZ_FALLTHROUGH
;
}
case
State
:
:
Finish
:
finishCollection
(
)
;
incrementalState
=
State
:
:
NotActive
;
break
;
}
MOZ_ASSERT
(
safeToYield
)
;
MOZ_ASSERT
(
marker
.
markColor
(
)
=
=
MarkColor
:
:
Black
)
;
}
bool
GCRuntime
:
:
hasForegroundWork
(
)
const
{
switch
(
incrementalState
)
{
case
State
:
:
NotActive
:
return
false
;
case
State
:
:
Finalize
:
return
!
isBackgroundSweeping
(
)
;
case
State
:
:
Decommit
:
return
!
decommitTask
.
wasStarted
(
)
;
default
:
return
true
;
}
}
gc
:
:
AbortReason
gc
:
:
IsIncrementalGCUnsafe
(
JSRuntime
*
rt
)
{
MOZ_ASSERT
(
!
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
;
if
(
!
rt
-
>
gc
.
isIncrementalGCAllowed
(
)
)
{
return
gc
:
:
AbortReason
:
:
IncrementalDisabled
;
}
return
gc
:
:
AbortReason
:
:
None
;
}
inline
void
GCRuntime
:
:
checkZoneIsScheduled
(
Zone
*
zone
JS
:
:
GCReason
reason
const
char
*
trigger
)
{
#
ifdef
DEBUG
if
(
zone
-
>
isGCScheduled
(
)
)
{
return
;
}
fprintf
(
stderr
"
checkZoneIsScheduled
:
Zone
%
p
not
scheduled
as
expected
in
%
s
GC
"
"
for
%
s
trigger
\
n
"
zone
JS
:
:
ExplainGCReason
(
reason
)
trigger
)
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
fprintf
(
stderr
"
Zone
%
p
:
%
s
%
s
\
n
"
zone
.
get
(
)
zone
-
>
isAtomsZone
(
)
?
"
atoms
"
:
"
"
zone
-
>
isGCScheduled
(
)
?
"
scheduled
"
:
"
"
)
;
}
fflush
(
stderr
)
;
MOZ_CRASH
(
"
Zone
not
scheduled
"
)
;
#
endif
}
GCRuntime
:
:
IncrementalResult
GCRuntime
:
:
budgetIncrementalGC
(
bool
nonincrementalByAPI
JS
:
:
GCReason
reason
SliceBudget
&
budget
)
{
if
(
nonincrementalByAPI
)
{
stats
(
)
.
nonincremental
(
gc
:
:
AbortReason
:
:
NonIncrementalRequested
)
;
budget
.
makeUnlimited
(
)
;
if
(
reason
!
=
JS
:
:
GCReason
:
:
ALLOC_TRIGGER
)
{
return
resetIncrementalGC
(
gc
:
:
AbortReason
:
:
NonIncrementalRequested
)
;
}
return
IncrementalResult
:
:
Ok
;
}
if
(
reason
=
=
JS
:
:
GCReason
:
:
ABORT_GC
)
{
budget
.
makeUnlimited
(
)
;
stats
(
)
.
nonincremental
(
gc
:
:
AbortReason
:
:
AbortRequested
)
;
return
resetIncrementalGC
(
gc
:
:
AbortReason
:
:
AbortRequested
)
;
}
AbortReason
unsafeReason
=
IsIncrementalGCUnsafe
(
rt
)
;
if
(
unsafeReason
=
=
AbortReason
:
:
None
)
{
if
(
reason
=
=
JS
:
:
GCReason
:
:
COMPARTMENT_REVIVED
)
{
unsafeReason
=
gc
:
:
AbortReason
:
:
CompartmentRevived
;
}
else
if
(
mode
!
=
JSGC_MODE_INCREMENTAL
&
&
mode
!
=
JSGC_MODE_ZONE_INCREMENTAL
)
{
unsafeReason
=
gc
:
:
AbortReason
:
:
ModeChange
;
}
}
if
(
unsafeReason
!
=
AbortReason
:
:
None
)
{
budget
.
makeUnlimited
(
)
;
stats
(
)
.
nonincremental
(
unsafeReason
)
;
return
resetIncrementalGC
(
unsafeReason
)
;
}
AbortReason
resetReason
=
AbortReason
:
:
None
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zone
-
>
canCollect
(
)
)
{
continue
;
}
if
(
zone
-
>
gcHeapSize
.
bytes
(
)
>
=
zone
-
>
gcHeapThreshold
.
nonIncrementalTriggerBytes
(
tunables
)
)
{
checkZoneIsScheduled
(
zone
reason
"
GC
bytes
"
)
;
budget
.
makeUnlimited
(
)
;
stats
(
)
.
nonincremental
(
AbortReason
:
:
GCBytesTrigger
)
;
if
(
zone
-
>
wasGCStarted
(
)
&
&
zone
-
>
gcState
(
)
>
Zone
:
:
Sweep
)
{
resetReason
=
AbortReason
:
:
GCBytesTrigger
;
}
}
if
(
zone
-
>
mallocHeapSize
.
bytes
(
)
>
=
zone
-
>
mallocHeapThreshold
.
nonIncrementalTriggerBytes
(
tunables
)
)
{
checkZoneIsScheduled
(
zone
reason
"
malloc
bytes
"
)
;
budget
.
makeUnlimited
(
)
;
stats
(
)
.
nonincremental
(
AbortReason
:
:
MallocBytesTrigger
)
;
if
(
zone
-
>
wasGCStarted
(
)
&
&
zone
-
>
gcState
(
)
>
Zone
:
:
Sweep
)
{
resetReason
=
AbortReason
:
:
MallocBytesTrigger
;
}
}
if
(
zone
-
>
jitHeapSize
.
bytes
(
)
>
=
zone
-
>
jitHeapThreshold
.
nonIncrementalTriggerBytes
(
tunables
)
)
{
checkZoneIsScheduled
(
zone
reason
"
JIT
code
bytes
"
)
;
budget
.
makeUnlimited
(
)
;
stats
(
)
.
nonincremental
(
AbortReason
:
:
JitCodeBytesTrigger
)
;
if
(
zone
-
>
wasGCStarted
(
)
&
&
zone
-
>
gcState
(
)
>
Zone
:
:
Sweep
)
{
resetReason
=
AbortReason
:
:
JitCodeBytesTrigger
;
}
}
if
(
isIncrementalGCInProgress
(
)
&
&
zone
-
>
isGCScheduled
(
)
!
=
zone
-
>
wasGCStarted
(
)
)
{
budget
.
makeUnlimited
(
)
;
resetReason
=
AbortReason
:
:
ZoneChange
;
}
}
if
(
resetReason
!
=
AbortReason
:
:
None
)
{
return
resetIncrementalGC
(
resetReason
)
;
}
return
IncrementalResult
:
:
Ok
;
}
static
double
LinearInterpolate
(
double
x
double
x0
double
y0
double
x1
double
y1
)
{
MOZ_ASSERT
(
x0
<
x1
)
;
if
(
x
<
x0
)
{
return
y0
;
}
if
(
x
<
x1
)
{
return
y0
+
(
y1
-
y0
)
*
(
(
x
-
x0
)
/
(
x1
-
x0
)
)
;
}
return
y1
;
}
void
GCRuntime
:
:
maybeIncreaseSliceBudget
(
SliceBudget
&
budget
)
{
#
ifndef
JS_MORE_DETERMINISTIC
if
(
budget
.
isTimeBudget
(
)
&
&
!
budget
.
isUnlimited
(
)
&
&
isIncrementalGCInProgress
(
)
)
{
struct
BudgetAtTime
{
double
time
;
double
budget
;
}
;
const
BudgetAtTime
MinBudgetStart
{
1500
0
.
0
}
;
const
BudgetAtTime
MinBudgetEnd
{
2500
100
.
0
}
;
double
totalTime
=
(
ReallyNow
(
)
-
lastGCStartTime
(
)
)
.
ToMilliseconds
(
)
;
double
minBudget
=
LinearInterpolate
(
totalTime
MinBudgetStart
.
time
MinBudgetStart
.
budget
MinBudgetEnd
.
time
MinBudgetEnd
.
budget
)
;
if
(
budget
.
timeBudget
.
budget
<
minBudget
)
{
budget
=
SliceBudget
(
TimeBudget
(
minBudget
)
)
;
}
}
#
endif
}
static
void
ScheduleZones
(
GCRuntime
*
gc
)
{
for
(
ZonesIter
zone
(
gc
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zone
-
>
canCollect
(
)
)
{
continue
;
}
if
(
gc
-
>
gcMode
(
)
=
=
JSGC_MODE_GLOBAL
|
|
gc
-
>
gcMode
(
)
=
=
JSGC_MODE_INCREMENTAL
)
{
zone
-
>
scheduleGC
(
)
;
}
if
(
gc
-
>
isIncrementalGCInProgress
(
)
&
&
zone
-
>
wasGCStarted
(
)
)
{
zone
-
>
scheduleGC
(
)
;
}
bool
inHighFrequencyMode
=
gc
-
>
schedulingState
.
inHighFrequencyGCMode
(
)
;
if
(
zone
-
>
gcHeapSize
.
bytes
(
)
>
=
zone
-
>
gcHeapThreshold
.
eagerAllocTrigger
(
inHighFrequencyMode
)
|
|
zone
-
>
mallocHeapSize
.
bytes
(
)
>
=
zone
-
>
mallocHeapThreshold
.
eagerAllocTrigger
(
inHighFrequencyMode
)
|
|
zone
-
>
jitHeapSize
.
bytes
(
)
>
=
zone
-
>
jitHeapThreshold
.
bytes
(
)
)
{
zone
-
>
scheduleGC
(
)
;
}
}
}
static
void
UnscheduleZones
(
GCRuntime
*
gc
)
{
for
(
ZonesIter
zone
(
gc
-
>
rt
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
unscheduleGC
(
)
;
}
}
class
js
:
:
gc
:
:
AutoCallGCCallbacks
{
GCRuntime
&
gc_
;
public
:
explicit
AutoCallGCCallbacks
(
GCRuntime
&
gc
)
:
gc_
(
gc
)
{
gc_
.
maybeCallGCCallback
(
JSGC_BEGIN
)
;
}
~
AutoCallGCCallbacks
(
)
{
gc_
.
maybeCallGCCallback
(
JSGC_END
)
;
}
}
;
void
GCRuntime
:
:
maybeCallGCCallback
(
JSGCStatus
status
)
{
if
(
!
gcCallback
.
op
)
{
return
;
}
if
(
isIncrementalGCInProgress
(
)
)
{
return
;
}
if
(
gcCallbackDepth
=
=
0
)
{
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
gcScheduledSaved_
=
zone
-
>
gcScheduled_
;
}
}
gcCallbackDepth
+
+
;
callGCCallback
(
status
)
;
MOZ_ASSERT
(
gcCallbackDepth
!
=
0
)
;
gcCallbackDepth
-
-
;
if
(
gcCallbackDepth
=
=
0
)
{
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
gcScheduled_
=
zone
-
>
gcScheduled_
|
|
zone
-
>
gcScheduledSaved_
;
}
}
}
MOZ_NEVER_INLINE
GCRuntime
:
:
IncrementalResult
GCRuntime
:
:
gcCycle
(
bool
nonincrementalByAPI
SliceBudget
budget
const
MaybeInvocationKind
&
gckind
JS
:
:
GCReason
reason
)
{
rt
-
>
mainContextFromOwnThread
(
)
-
>
verifyIsSafeToGC
(
)
;
MOZ_ASSERT
(
!
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
;
AutoCallGCCallbacks
callCallbacks
(
*
this
)
;
maybeIncreaseSliceBudget
(
budget
)
;
ScheduleZones
(
this
)
;
gcstats
:
:
AutoGCSlice
agc
(
stats
(
)
scanZonesBeforeGC
(
)
gckind
.
valueOr
(
invocationKind
)
budget
reason
)
;
auto
result
=
budgetIncrementalGC
(
nonincrementalByAPI
reason
budget
)
;
if
(
result
=
=
IncrementalResult
:
:
ResetIncremental
)
{
reason
=
JS
:
:
GCReason
:
:
RESET
;
}
if
(
shouldCollectNurseryForSlice
(
nonincrementalByAPI
budget
)
)
{
minorGC
(
reason
gcstats
:
:
PhaseKind
:
:
EVICT_NURSERY_FOR_MAJOR_GC
)
;
}
else
{
+
+
number
;
}
AutoGCSession
session
(
this
JS
:
:
HeapState
:
:
MajorCollecting
)
;
majorGCTriggerReason
=
JS
:
:
GCReason
:
:
NO_REASON
;
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
WAIT_BACKGROUND_THREAD
)
;
if
(
!
isIncrementalGCInProgress
(
)
)
{
assertBackgroundSweepingFinished
(
)
;
MOZ_ASSERT
(
decommitTask
.
isIdle
(
)
)
;
}
allocTask
.
cancelAndWait
(
)
;
}
if
(
rt
-
>
activeGCInAtomsZone
(
)
)
{
session
.
maybeCheckAtomsAccess
.
emplace
(
rt
)
;
}
gcTracer
.
traceMajorGCStart
(
)
;
incrementalSlice
(
budget
gckind
reason
session
)
;
chunkAllocationSinceLastGC
=
false
;
#
ifdef
JS_GC_ZEAL
clearSelectedForMarking
(
)
;
#
endif
gcTracer
.
traceMajorGCEnd
(
)
;
MOZ_ASSERT_IF
(
result
=
=
IncrementalResult
:
:
ResetIncremental
!
isIncrementalGCInProgress
(
)
)
;
return
result
;
}
bool
GCRuntime
:
:
shouldCollectNurseryForSlice
(
bool
nonincrementalByAPI
SliceBudget
&
budget
)
{
if
(
!
nursery
(
)
.
isEnabled
(
)
)
{
return
false
;
}
switch
(
incrementalState
)
{
case
State
:
:
NotActive
:
case
State
:
:
Sweep
:
case
State
:
:
Compact
:
return
true
;
case
State
:
:
Mark
:
case
State
:
:
Finalize
:
case
State
:
:
Decommit
:
return
(
nonincrementalByAPI
|
|
budget
.
isUnlimited
(
)
|
|
lastMarkSlice
|
|
nursery
(
)
.
shouldCollect
(
)
|
|
hasIncrementalTwoSliceZealMode
(
)
)
;
case
State
:
:
Finish
:
return
false
;
case
State
:
:
MarkRoots
:
MOZ_CRASH
(
"
Unexpected
GC
state
"
)
;
}
return
false
;
}
#
ifdef
JS_GC_ZEAL
static
bool
IsDeterministicGCReason
(
JS
:
:
GCReason
reason
)
{
switch
(
reason
)
{
case
JS
:
:
GCReason
:
:
API
:
case
JS
:
:
GCReason
:
:
DESTROY_RUNTIME
:
case
JS
:
:
GCReason
:
:
LAST_DITCH
:
case
JS
:
:
GCReason
:
:
TOO_MUCH_MALLOC
:
case
JS
:
:
GCReason
:
:
TOO_MUCH_WASM_MEMORY
:
case
JS
:
:
GCReason
:
:
TOO_MUCH_JIT_CODE
:
case
JS
:
:
GCReason
:
:
ALLOC_TRIGGER
:
case
JS
:
:
GCReason
:
:
DEBUG_GC
:
case
JS
:
:
GCReason
:
:
CC_FORCED
:
case
JS
:
:
GCReason
:
:
SHUTDOWN_CC
:
case
JS
:
:
GCReason
:
:
ABORT_GC
:
case
JS
:
:
GCReason
:
:
DISABLE_GENERATIONAL_GC
:
case
JS
:
:
GCReason
:
:
FINISH_GC
:
case
JS
:
:
GCReason
:
:
PREPARE_FOR_TRACING
:
return
true
;
default
:
return
false
;
}
}
#
endif
gcstats
:
:
ZoneGCStats
GCRuntime
:
:
scanZonesBeforeGC
(
)
{
gcstats
:
:
ZoneGCStats
zoneStats
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zoneStats
.
zoneCount
+
+
;
zoneStats
.
compartmentCount
+
=
zone
-
>
compartments
(
)
.
length
(
)
;
if
(
zone
-
>
canCollect
(
)
)
{
zoneStats
.
collectableZoneCount
+
+
;
if
(
zone
-
>
isGCScheduled
(
)
)
{
zoneStats
.
collectedZoneCount
+
+
;
zoneStats
.
collectedCompartmentCount
+
=
zone
-
>
compartments
(
)
.
length
(
)
;
}
}
}
return
zoneStats
;
}
void
GCRuntime
:
:
maybeDoCycleCollection
(
)
{
const
static
float
ExcessiveGrayRealms
=
0
.
8f
;
const
static
size_t
LimitGrayRealms
=
200
;
size_t
realmsTotal
=
0
;
size_t
realmsGray
=
0
;
for
(
RealmsIter
realm
(
rt
)
;
!
realm
.
done
(
)
;
realm
.
next
(
)
)
{
+
+
realmsTotal
;
GlobalObject
*
global
=
realm
-
>
unsafeUnbarrieredMaybeGlobal
(
)
;
if
(
global
&
&
global
-
>
isMarkedGray
(
)
)
{
+
+
realmsGray
;
}
}
float
grayFraction
=
float
(
realmsGray
)
/
float
(
realmsTotal
)
;
if
(
grayFraction
>
ExcessiveGrayRealms
|
|
realmsGray
>
LimitGrayRealms
)
{
callDoCycleCollectionCallback
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
}
}
void
GCRuntime
:
:
checkCanCallAPI
(
)
{
MOZ_RELEASE_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
MOZ_RELEASE_ASSERT
(
!
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
}
bool
GCRuntime
:
:
checkIfGCAllowedInCurrentState
(
JS
:
:
GCReason
reason
)
{
if
(
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
{
return
false
;
}
if
(
rt
-
>
isBeingDestroyed
(
)
&
&
!
IsShutdownGC
(
reason
)
)
{
return
false
;
}
#
ifdef
JS_GC_ZEAL
if
(
deterministicOnly
&
&
!
IsDeterministicGCReason
(
reason
)
)
{
return
false
;
}
#
endif
return
true
;
}
bool
GCRuntime
:
:
shouldRepeatForDeadZone
(
JS
:
:
GCReason
reason
)
{
MOZ_ASSERT_IF
(
reason
=
=
JS
:
:
GCReason
:
:
COMPARTMENT_REVIVED
!
isIncremental
)
;
MOZ_ASSERT
(
!
isIncrementalGCInProgress
(
)
)
;
if
(
!
isIncremental
)
{
return
false
;
}
for
(
CompartmentsIter
c
(
rt
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
if
(
c
-
>
gcState
.
scheduledForDestruction
)
{
return
true
;
}
}
return
false
;
}
void
GCRuntime
:
:
collect
(
bool
nonincrementalByAPI
SliceBudget
budget
const
MaybeInvocationKind
&
gckindArg
JS
:
:
GCReason
reason
)
{
MOZ_ASSERT
(
reason
!
=
JS
:
:
GCReason
:
:
NO_REASON
)
;
MaybeInvocationKind
gckind
=
gckindArg
;
MOZ_ASSERT_IF
(
!
isIncrementalGCInProgress
(
)
gckind
.
isSome
(
)
)
;
checkCanCallAPI
(
)
;
if
(
!
checkIfGCAllowedInCurrentState
(
reason
)
)
{
return
;
}
stats
(
)
.
writeLogMessage
(
"
GC
starting
in
state
%
s
"
StateName
(
incrementalState
)
)
;
AutoTraceLog
logGC
(
TraceLoggerForCurrentThread
(
)
TraceLogger_GC
)
;
AutoStopVerifyingBarriers
av
(
rt
IsShutdownGC
(
reason
)
)
;
AutoEnqueuePendingParseTasksAfterGC
aept
(
*
this
)
;
AutoMaybeLeaveAtomsZone
leaveAtomsZone
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
#
ifdef
DEBUG
if
(
IsShutdownGC
(
reason
)
)
{
marker
.
markQueue
.
clear
(
)
;
marker
.
queuePos
=
0
;
}
#
endif
bool
repeat
;
do
{
IncrementalResult
cycleResult
=
gcCycle
(
nonincrementalByAPI
budget
gckind
reason
)
;
if
(
reason
=
=
JS
:
:
GCReason
:
:
ABORT_GC
)
{
MOZ_ASSERT
(
!
isIncrementalGCInProgress
(
)
)
;
stats
(
)
.
writeLogMessage
(
"
GC
aborted
by
request
"
)
;
break
;
}
repeat
=
false
;
if
(
!
isIncrementalGCInProgress
(
)
)
{
if
(
cycleResult
=
=
ResetIncremental
)
{
repeat
=
true
;
}
else
if
(
rootsRemoved
&
&
IsShutdownGC
(
reason
)
)
{
JS
:
:
PrepareForFullGC
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
repeat
=
true
;
reason
=
JS
:
:
GCReason
:
:
ROOTS_REMOVED
;
}
else
if
(
shouldRepeatForDeadZone
(
reason
)
)
{
repeat
=
true
;
reason
=
JS
:
:
GCReason
:
:
COMPARTMENT_REVIVED
;
}
}
if
(
repeat
)
{
gckind
=
Some
(
invocationKind
)
;
}
}
while
(
repeat
)
;
if
(
reason
=
=
JS
:
:
GCReason
:
:
COMPARTMENT_REVIVED
)
{
maybeDoCycleCollection
(
)
;
}
#
ifdef
JS_GC_ZEAL
if
(
hasZealMode
(
ZealMode
:
:
CheckHeapAfterGC
)
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
TRACE_HEAP
)
;
CheckHeapAfterGC
(
rt
)
;
}
if
(
hasZealMode
(
ZealMode
:
:
CheckGrayMarking
)
&
&
!
isIncrementalGCInProgress
(
)
)
{
MOZ_RELEASE_ASSERT
(
CheckGrayMarkingState
(
rt
)
)
;
}
#
endif
stats
(
)
.
writeLogMessage
(
"
GC
ending
in
state
%
s
"
StateName
(
incrementalState
)
)
;
UnscheduleZones
(
this
)
;
}
js
:
:
AutoEnqueuePendingParseTasksAfterGC
:
:
~
AutoEnqueuePendingParseTasksAfterGC
(
)
{
if
(
!
OffThreadParsingMustWaitForGC
(
gc_
.
rt
)
)
{
EnqueuePendingParseTasksAfterGC
(
gc_
.
rt
)
;
}
}
SliceBudget
GCRuntime
:
:
defaultBudget
(
JS
:
:
GCReason
reason
int64_t
millis
)
{
if
(
millis
=
=
0
)
{
if
(
reason
=
=
JS
:
:
GCReason
:
:
ALLOC_TRIGGER
)
{
millis
=
defaultSliceBudgetMS
(
)
;
}
else
if
(
schedulingState
.
inHighFrequencyGCMode
(
)
&
&
tunables
.
isDynamicMarkSliceEnabled
(
)
)
{
millis
=
defaultSliceBudgetMS
(
)
*
IGC_MARK_SLICE_MULTIPLIER
;
}
else
{
millis
=
defaultSliceBudgetMS
(
)
;
}
}
return
SliceBudget
(
TimeBudget
(
millis
)
)
;
}
void
GCRuntime
:
:
gc
(
JSGCInvocationKind
gckind
JS
:
:
GCReason
reason
)
{
if
(
!
RecordReplayCheckCanGC
(
reason
)
)
{
return
;
}
collect
(
true
SliceBudget
:
:
unlimited
(
)
mozilla
:
:
Some
(
gckind
)
reason
)
;
}
void
GCRuntime
:
:
startGC
(
JSGCInvocationKind
gckind
JS
:
:
GCReason
reason
int64_t
millis
)
{
MOZ_ASSERT
(
!
isIncrementalGCInProgress
(
)
)
;
if
(
!
JS
:
:
IsIncrementalGCEnabled
(
rt
-
>
mainContextFromOwnThread
(
)
)
)
{
gc
(
gckind
reason
)
;
return
;
}
collect
(
false
defaultBudget
(
reason
millis
)
Some
(
gckind
)
reason
)
;
}
void
GCRuntime
:
:
gcSlice
(
JS
:
:
GCReason
reason
int64_t
millis
)
{
MOZ_ASSERT
(
isIncrementalGCInProgress
(
)
)
;
collect
(
false
defaultBudget
(
reason
millis
)
Nothing
(
)
reason
)
;
}
void
GCRuntime
:
:
finishGC
(
JS
:
:
GCReason
reason
)
{
MOZ_ASSERT
(
isIncrementalGCInProgress
(
)
)
;
if
(
!
IsOOMReason
(
initialReason
)
)
{
if
(
incrementalState
=
=
State
:
:
Compact
)
{
abortGC
(
)
;
return
;
}
isCompacting
=
false
;
}
collect
(
false
SliceBudget
:
:
unlimited
(
)
Nothing
(
)
reason
)
;
}
void
GCRuntime
:
:
abortGC
(
)
{
MOZ_ASSERT
(
isIncrementalGCInProgress
(
)
)
;
checkCanCallAPI
(
)
;
MOZ_ASSERT
(
!
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
;
collect
(
false
SliceBudget
:
:
unlimited
(
)
Nothing
(
)
JS
:
:
GCReason
:
:
ABORT_GC
)
;
}
static
bool
ZonesSelected
(
GCRuntime
*
gc
)
{
for
(
ZonesIter
zone
(
gc
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
isGCScheduled
(
)
)
{
return
true
;
}
}
return
false
;
}
void
GCRuntime
:
:
startDebugGC
(
JSGCInvocationKind
gckind
SliceBudget
&
budget
)
{
MOZ_ASSERT
(
!
isIncrementalGCInProgress
(
)
)
;
if
(
!
ZonesSelected
(
this
)
)
{
JS
:
:
PrepareForFullGC
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
}
collect
(
false
budget
Some
(
gckind
)
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
void
GCRuntime
:
:
debugGCSlice
(
SliceBudget
&
budget
)
{
MOZ_ASSERT
(
isIncrementalGCInProgress
(
)
)
;
if
(
!
ZonesSelected
(
this
)
)
{
JS
:
:
PrepareForIncrementalGC
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
}
collect
(
false
budget
Nothing
(
)
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
void
js
:
:
PrepareForDebugGC
(
JSRuntime
*
rt
)
{
if
(
!
ZonesSelected
(
&
rt
-
>
gc
)
)
{
JS
:
:
PrepareForFullGC
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
}
}
void
GCRuntime
:
:
onOutOfMallocMemory
(
)
{
allocTask
.
cancelAndWait
(
)
;
decommitTask
.
join
(
)
;
nursery
(
)
.
joinDecommitTask
(
)
;
sweepTask
.
join
(
)
;
AutoLockGC
lock
(
this
)
;
onOutOfMallocMemory
(
lock
)
;
}
void
GCRuntime
:
:
onOutOfMallocMemory
(
const
AutoLockGC
&
lock
)
{
releaseHeldRelocatedArenasWithoutUnlocking
(
lock
)
;
freeEmptyChunks
(
lock
)
;
decommitFreeArenasWithoutUnlocking
(
lock
)
;
}
void
GCRuntime
:
:
minorGC
(
JS
:
:
GCReason
reason
gcstats
:
:
PhaseKind
phase
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
MOZ_ASSERT_IF
(
reason
=
=
JS
:
:
GCReason
:
:
EVICT_NURSERY
!
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
;
if
(
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
{
return
;
}
AutoMaybeLeaveAtomsZone
leaveAtomsZone
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
uint32_t
numAllocs
=
rt
-
>
mainContextFromOwnThread
(
)
-
>
getAndResetAllocsThisZoneSinceMinorGC
(
)
;
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
numAllocs
+
=
zone
-
>
getAndResetTenuredAllocsSinceMinorGC
(
)
;
}
stats
(
)
.
setAllocsSinceMinorGCTenured
(
numAllocs
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
phase
)
;
nursery
(
)
.
clearMinorGCRequest
(
)
;
TraceLoggerThread
*
logger
=
TraceLoggerForCurrentThread
(
)
;
AutoTraceLog
logMinorGC
(
logger
TraceLogger_MinorGC
)
;
nursery
(
)
.
collect
(
reason
)
;
MOZ_ASSERT
(
nursery
(
)
.
isEmpty
(
)
)
;
startBackgroundFreeAfterMinorGC
(
)
;
#
ifdef
JS_GC_ZEAL
if
(
hasZealMode
(
ZealMode
:
:
CheckHeapAfterGC
)
)
{
CheckHeapAfterGC
(
rt
)
;
}
#
endif
for
(
ZonesIter
zone
(
this
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
maybeAllocTriggerZoneGC
(
zone
)
;
maybeMallocTriggerZoneGC
(
zone
)
;
}
}
void
GCRuntime
:
:
startBackgroundFreeAfterMinorGC
(
)
{
MOZ_ASSERT
(
nursery
(
)
.
isEmpty
(
)
)
;
{
AutoLockHelperThreadState
lock
;
lifoBlocksToFree
.
ref
(
)
.
transferFrom
(
&
lifoBlocksToFreeAfterMinorGC
.
ref
(
)
)
;
if
(
lifoBlocksToFree
.
ref
(
)
.
isEmpty
(
)
&
&
buffersToFreeAfterMinorGC
.
ref
(
)
.
empty
(
)
)
{
return
;
}
}
startBackgroundFree
(
)
;
}
JS
:
:
AutoDisableGenerationalGC
:
:
AutoDisableGenerationalGC
(
JSContext
*
cx
)
:
cx
(
cx
)
{
if
(
!
cx
-
>
generationalDisabled
)
{
cx
-
>
runtime
(
)
-
>
gc
.
evictNursery
(
JS
:
:
GCReason
:
:
DISABLE_GENERATIONAL_GC
)
;
cx
-
>
nursery
(
)
.
disable
(
)
;
}
+
+
cx
-
>
generationalDisabled
;
}
JS
:
:
AutoDisableGenerationalGC
:
:
~
AutoDisableGenerationalGC
(
)
{
if
(
-
-
cx
-
>
generationalDisabled
=
=
0
&
&
cx
-
>
runtime
(
)
-
>
gc
.
tunables
.
gcMaxNurseryBytes
(
)
>
0
)
{
cx
-
>
nursery
(
)
.
enable
(
)
;
}
}
JS_PUBLIC_API
bool
JS
:
:
IsGenerationalGCEnabled
(
JSRuntime
*
rt
)
{
return
!
rt
-
>
mainContextFromOwnThread
(
)
-
>
generationalDisabled
;
}
bool
GCRuntime
:
:
gcIfRequested
(
)
{
if
(
nursery
(
)
.
minorGCRequested
(
)
)
{
minorGC
(
nursery
(
)
.
minorGCTriggerReason
(
)
)
;
}
if
(
majorGCRequested
(
)
)
{
if
(
majorGCTriggerReason
=
=
JS
:
:
GCReason
:
:
DELAYED_ATOMS_GC
&
&
!
rt
-
>
mainContextFromOwnThread
(
)
-
>
canCollectAtoms
(
)
)
{
majorGCTriggerReason
=
JS
:
:
GCReason
:
:
NO_REASON
;
return
false
;
}
if
(
!
isIncrementalGCInProgress
(
)
)
{
startGC
(
GC_NORMAL
majorGCTriggerReason
)
;
}
else
{
gcSlice
(
majorGCTriggerReason
)
;
}
return
true
;
}
return
false
;
}
void
js
:
:
gc
:
:
FinishGC
(
JSContext
*
cx
JS
:
:
GCReason
reason
)
{
MOZ_ASSERT
(
!
cx
-
>
suppressGC
)
;
MOZ_ASSERT
(
cx
-
>
isNurseryAllocAllowed
(
)
)
;
if
(
JS
:
:
IsIncrementalGCInProgress
(
cx
)
)
{
JS
:
:
PrepareForIncrementalGC
(
cx
)
;
JS
:
:
FinishIncrementalGC
(
cx
reason
)
;
}
cx
-
>
runtime
(
)
-
>
gc
.
waitBackgroundFreeEnd
(
)
;
}
Realm
*
js
:
:
NewRealm
(
JSContext
*
cx
JSPrincipals
*
principals
const
JS
:
:
RealmOptions
&
options
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
JS_AbortIfWrongThread
(
cx
)
;
UniquePtr
<
Zone
>
zoneHolder
;
UniquePtr
<
Compartment
>
compHolder
;
Compartment
*
comp
=
nullptr
;
Zone
*
zone
=
nullptr
;
JS
:
:
CompartmentSpecifier
compSpec
=
options
.
creationOptions
(
)
.
compartmentSpecifier
(
)
;
switch
(
compSpec
)
{
case
JS
:
:
CompartmentSpecifier
:
:
NewCompartmentInSystemZone
:
zone
=
rt
-
>
gc
.
systemZone
;
break
;
case
JS
:
:
CompartmentSpecifier
:
:
NewCompartmentInExistingZone
:
zone
=
options
.
creationOptions
(
)
.
zone
(
)
;
MOZ_ASSERT
(
zone
)
;
break
;
case
JS
:
:
CompartmentSpecifier
:
:
ExistingCompartment
:
comp
=
options
.
creationOptions
(
)
.
compartment
(
)
;
zone
=
comp
-
>
zone
(
)
;
break
;
case
JS
:
:
CompartmentSpecifier
:
:
NewCompartmentAndZone
:
break
;
}
if
(
!
zone
)
{
zoneHolder
=
MakeUnique
<
Zone
>
(
cx
-
>
runtime
(
)
)
;
if
(
!
zoneHolder
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
const
JSPrincipals
*
trusted
=
rt
-
>
trustedPrincipals
(
)
;
bool
isSystem
=
principals
&
&
principals
=
=
trusted
;
if
(
!
zoneHolder
-
>
init
(
isSystem
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
zone
=
zoneHolder
.
get
(
)
;
}
bool
invisibleToDebugger
=
options
.
creationOptions
(
)
.
invisibleToDebugger
(
)
;
if
(
comp
)
{
MOZ_ASSERT
(
comp
-
>
invisibleToDebugger
(
)
=
=
invisibleToDebugger
)
;
}
else
{
compHolder
=
cx
-
>
make_unique
<
JS
:
:
Compartment
>
(
zone
invisibleToDebugger
)
;
if
(
!
compHolder
)
{
return
nullptr
;
}
comp
=
compHolder
.
get
(
)
;
}
UniquePtr
<
Realm
>
realm
(
cx
-
>
new_
<
Realm
>
(
comp
options
)
)
;
if
(
!
realm
|
|
!
realm
-
>
init
(
cx
principals
)
)
{
return
nullptr
;
}
if
(
!
compHolder
)
{
MOZ_RELEASE_ASSERT
(
realm
-
>
isSystem
(
)
=
=
IsSystemCompartment
(
comp
)
)
;
}
AutoLockGC
lock
(
rt
)
;
if
(
!
comp
-
>
realms
(
)
.
reserve
(
comp
-
>
realms
(
)
.
length
(
)
+
1
)
|
|
(
compHolder
&
&
!
zone
-
>
compartments
(
)
.
reserve
(
zone
-
>
compartments
(
)
.
length
(
)
+
1
)
)
|
|
(
zoneHolder
&
&
!
rt
-
>
gc
.
zones
(
)
.
reserve
(
rt
-
>
gc
.
zones
(
)
.
length
(
)
+
1
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
comp
-
>
realms
(
)
.
infallibleAppend
(
realm
.
get
(
)
)
;
if
(
compHolder
)
{
zone
-
>
compartments
(
)
.
infallibleAppend
(
compHolder
.
release
(
)
)
;
}
if
(
zoneHolder
)
{
rt
-
>
gc
.
zones
(
)
.
infallibleAppend
(
zoneHolder
.
release
(
)
)
;
if
(
compSpec
=
=
JS
:
:
CompartmentSpecifier
:
:
NewCompartmentInSystemZone
)
{
MOZ_RELEASE_ASSERT
(
!
rt
-
>
gc
.
systemZone
)
;
rt
-
>
gc
.
systemZone
=
zone
;
zone
-
>
isSystem
=
true
;
}
}
return
realm
.
release
(
)
;
}
void
gc
:
:
MergeRealms
(
Realm
*
source
Realm
*
target
)
{
JSRuntime
*
rt
=
source
-
>
runtimeFromMainThread
(
)
;
rt
-
>
gc
.
mergeRealms
(
source
target
)
;
rt
-
>
gc
.
maybeAllocTriggerZoneGC
(
target
-
>
zone
(
)
)
;
rt
-
>
gc
.
maybeMallocTriggerZoneGC
(
target
-
>
zone
(
)
)
;
}
void
GCRuntime
:
:
mergeRealms
(
Realm
*
source
Realm
*
target
)
{
MOZ_ASSERT
(
source
-
>
creationOptions
(
)
.
mergeable
(
)
)
;
MOZ_ASSERT
(
source
-
>
creationOptions
(
)
.
invisibleToDebugger
(
)
)
;
MOZ_ASSERT
(
!
source
-
>
hasBeenEnteredIgnoringJit
(
)
)
;
MOZ_ASSERT
(
source
-
>
zone
(
)
-
>
compartments
(
)
.
length
(
)
=
=
1
)
;
JSContext
*
cx
=
rt
-
>
mainContextFromOwnThread
(
)
;
MOZ_ASSERT
(
!
source
-
>
zone
(
)
-
>
wasGCStarted
(
)
)
;
JS
:
:
AutoAssertNoGC
nogc
(
cx
)
;
AutoTraceSession
session
(
rt
)
;
source
-
>
clearTables
(
)
;
source
-
>
zone
(
)
-
>
clearTables
(
)
;
source
-
>
unsetIsDebuggee
(
)
;
if
(
source
-
>
needsDelazificationForDebugger
(
)
)
{
target
-
>
scheduleDelazificationForDebugger
(
)
;
}
releaseHeldRelocatedArenas
(
)
;
GlobalObject
*
global
=
target
-
>
maybeGlobal
(
)
;
MOZ_ASSERT
(
global
)
;
AssertTargetIsNotGray
(
global
)
;
for
(
auto
group
=
source
-
>
zone
(
)
-
>
cellIterUnsafe
<
ObjectGroup
>
(
)
;
!
group
.
done
(
)
;
group
.
next
(
)
)
{
TaggedProto
proto
(
group
-
>
proto
(
)
)
;
if
(
proto
.
isObject
(
)
)
{
JSObject
*
obj
=
proto
.
toObject
(
)
;
if
(
GlobalObject
:
:
isOffThreadPrototypePlaceholder
(
obj
)
)
{
JSObject
*
targetProto
=
global
-
>
getPrototypeForOffThreadPlaceholder
(
obj
)
;
MOZ_ASSERT
(
targetProto
-
>
isDelegate
(
)
)
;
MOZ_ASSERT_IF
(
targetProto
-
>
staticPrototypeIsImmutable
(
)
obj
-
>
staticPrototypeIsImmutable
(
)
)
;
MOZ_ASSERT_IF
(
targetProto
-
>
isNewGroupUnknown
(
)
obj
-
>
isNewGroupUnknown
(
)
)
;
group
-
>
setProtoUnchecked
(
TaggedProto
(
targetProto
)
)
;
}
}
group
-
>
setGeneration
(
target
-
>
zone
(
)
-
>
types
.
generation
)
;
group
-
>
realm_
=
target
;
}
bool
targetZoneIsCollecting
=
isIncrementalGCInProgress
(
)
&
&
target
-
>
zone
(
)
-
>
wasGCStarted
(
)
;
for
(
auto
thingKind
:
AllAllocKinds
(
)
)
{
for
(
ArenaIter
aiter
(
source
-
>
zone
(
)
thingKind
)
;
!
aiter
.
done
(
)
;
aiter
.
next
(
)
)
{
Arena
*
arena
=
aiter
.
get
(
)
;
arena
-
>
zone
=
target
-
>
zone
(
)
;
if
(
MOZ_UNLIKELY
(
targetZoneIsCollecting
)
)
{
for
(
ArenaCellIter
iter
(
arena
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
TenuredCell
*
cell
=
iter
.
getCell
(
)
;
MOZ_ASSERT
(
!
cell
-
>
isMarkedAny
(
)
)
;
cell
-
>
markBlack
(
)
;
}
}
}
}
for
(
RealmsInZoneIter
r
(
source
-
>
zone
(
)
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
MOZ_ASSERT
(
r
.
get
(
)
=
=
source
)
;
}
target
-
>
zone
(
)
-
>
arenas
.
adoptArenas
(
&
source
-
>
zone
(
)
-
>
arenas
targetZoneIsCollecting
)
;
target
-
>
zone
(
)
-
>
addTenuredAllocsSinceMinorGC
(
source
-
>
zone
(
)
-
>
getAndResetTenuredAllocsSinceMinorGC
(
)
)
;
target
-
>
zone
(
)
-
>
gcHeapSize
.
adopt
(
source
-
>
zone
(
)
-
>
gcHeapSize
)
;
target
-
>
zone
(
)
-
>
adoptUniqueIds
(
source
-
>
zone
(
)
)
;
target
-
>
zone
(
)
-
>
adoptMallocBytes
(
source
-
>
zone
(
)
)
;
target
-
>
zone
(
)
-
>
types
.
typeLifoAlloc
(
)
.
transferFrom
(
&
source
-
>
zone
(
)
-
>
types
.
typeLifoAlloc
(
)
)
;
MOZ_RELEASE_ASSERT
(
source
-
>
zone
(
)
-
>
types
.
sweepTypeLifoAlloc
.
ref
(
)
.
isEmpty
(
)
)
;
atomMarking
.
adoptMarkedAtoms
(
target
-
>
zone
(
)
source
-
>
zone
(
)
)
;
Zone
*
sourceZone
=
source
-
>
zone
(
)
;
MOZ_ASSERT
(
!
sourceZone
-
>
scriptLCovMap
)
;
MOZ_ASSERT
(
!
sourceZone
-
>
scriptCountsMap
)
;
MOZ_ASSERT
(
!
sourceZone
-
>
debugScriptMap
)
;
#
ifdef
MOZ_VTUNE
MOZ_ASSERT
(
!
sourceZone
-
>
scriptVTuneIdMap
)
;
#
endif
sourceZone
-
>
deleteEmptyCompartment
(
source
-
>
compartment
(
)
)
;
deleteEmptyZone
(
sourceZone
)
;
}
void
GCRuntime
:
:
runDebugGC
(
)
{
#
ifdef
JS_GC_ZEAL
if
(
rt
-
>
mainContextFromOwnThread
(
)
-
>
suppressGC
)
{
return
;
}
if
(
hasZealMode
(
ZealMode
:
:
GenerationalGC
)
)
{
return
minorGC
(
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
PrepareForDebugGC
(
rt
)
;
auto
budget
=
SliceBudget
:
:
unlimited
(
)
;
if
(
hasZealMode
(
ZealMode
:
:
IncrementalMultipleSlices
)
)
{
if
(
!
isIncrementalGCInProgress
(
)
)
{
incrementalLimit
=
zealFrequency
/
2
;
}
else
{
incrementalLimit
*
=
2
;
}
budget
=
SliceBudget
(
WorkBudget
(
incrementalLimit
)
)
;
js
:
:
gc
:
:
State
initialState
=
incrementalState
;
Maybe
<
JSGCInvocationKind
>
gckind
=
isIncrementalGCInProgress
(
)
?
Nothing
(
)
:
Some
(
GC_SHRINK
)
;
collect
(
false
budget
gckind
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
if
(
(
initialState
=
=
State
:
:
Mark
&
&
incrementalState
=
=
State
:
:
Sweep
)
|
|
(
initialState
=
=
State
:
:
Sweep
&
&
incrementalState
=
=
State
:
:
Compact
)
)
{
incrementalLimit
=
zealFrequency
/
2
;
}
}
else
if
(
hasIncrementalTwoSliceZealMode
(
)
)
{
budget
=
SliceBudget
(
WorkBudget
(
1
)
)
;
Maybe
<
JSGCInvocationKind
>
gckind
=
isIncrementalGCInProgress
(
)
?
Nothing
(
)
:
Some
(
GC_NORMAL
)
;
collect
(
false
budget
gckind
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
else
if
(
hasZealMode
(
ZealMode
:
:
Compact
)
)
{
gc
(
GC_SHRINK
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
else
{
gc
(
GC_NORMAL
JS
:
:
GCReason
:
:
DEBUG_GC
)
;
}
#
endif
}
void
GCRuntime
:
:
setFullCompartmentChecks
(
bool
enabled
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsMajorCollecting
(
)
)
;
fullCompartmentChecks
=
enabled
;
}
void
GCRuntime
:
:
notifyRootsRemoved
(
)
{
rootsRemoved
=
true
;
#
ifdef
JS_GC_ZEAL
if
(
hasZealMode
(
ZealMode
:
:
RootsChange
)
)
{
nextScheduled
=
1
;
}
#
endif
}
#
ifdef
JS_GC_ZEAL
bool
GCRuntime
:
:
selectForMarking
(
JSObject
*
object
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsMajorCollecting
(
)
)
;
return
selectedForMarking
.
ref
(
)
.
get
(
)
.
append
(
object
)
;
}
void
GCRuntime
:
:
clearSelectedForMarking
(
)
{
selectedForMarking
.
ref
(
)
.
get
(
)
.
clearAndFree
(
)
;
}
void
GCRuntime
:
:
setDeterministic
(
bool
enabled
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsMajorCollecting
(
)
)
;
deterministicOnly
=
enabled
;
}
#
endif
#
ifdef
DEBUG
void
PreventGCDuringInteractiveDebug
(
)
{
TlsContext
.
get
(
)
-
>
suppressGC
+
+
;
}
#
endif
void
js
:
:
ReleaseAllJITCode
(
JSFreeOp
*
fop
)
{
js
:
:
CancelOffThreadIonCompile
(
fop
-
>
runtime
(
)
)
;
for
(
ZonesIter
zone
(
fop
-
>
runtime
(
)
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
setPreservingCode
(
false
)
;
zone
-
>
discardJitCode
(
fop
)
;
}
for
(
RealmsIter
realm
(
fop
-
>
runtime
(
)
)
;
!
realm
.
done
(
)
;
realm
.
next
(
)
)
{
if
(
jit
:
:
JitRealm
*
jitRealm
=
realm
-
>
jitRealm
(
)
)
{
jitRealm
-
>
discardStubs
(
)
;
}
}
}
void
ArenaLists
:
:
adoptArenas
(
ArenaLists
*
fromArenaLists
bool
targetZoneIsCollecting
)
{
AutoLockGC
lock
(
runtime
(
)
)
;
fromArenaLists
-
>
clearFreeLists
(
)
;
for
(
auto
thingKind
:
AllAllocKinds
(
)
)
{
MOZ_ASSERT
(
fromArenaLists
-
>
concurrentUse
(
thingKind
)
=
=
ConcurrentUse
:
:
None
)
;
ArenaList
*
fromList
=
&
fromArenaLists
-
>
arenaLists
(
thingKind
)
;
ArenaList
*
toList
=
&
arenaLists
(
thingKind
)
;
fromList
-
>
check
(
)
;
toList
-
>
check
(
)
;
Arena
*
next
;
for
(
Arena
*
fromArena
=
fromList
-
>
head
(
)
;
fromArena
;
fromArena
=
next
)
{
next
=
fromArena
-
>
next
;
MOZ_ASSERT
(
!
fromArena
-
>
isEmpty
(
)
)
;
if
(
targetZoneIsCollecting
)
{
toList
-
>
insertBeforeCursor
(
fromArena
)
;
}
else
{
toList
-
>
insertAtCursor
(
fromArena
)
;
}
}
fromList
-
>
clear
(
)
;
toList
-
>
check
(
)
;
}
}
AutoSuppressGC
:
:
AutoSuppressGC
(
JSContext
*
cx
)
:
suppressGC_
(
cx
-
>
suppressGC
.
ref
(
)
)
{
suppressGC_
+
+
;
}
bool
js
:
:
UninlinedIsInsideNursery
(
const
gc
:
:
Cell
*
cell
)
{
return
IsInsideNursery
(
cell
)
;
}
#
ifdef
DEBUG
AutoDisableProxyCheck
:
:
AutoDisableProxyCheck
(
)
{
TlsContext
.
get
(
)
-
>
disableStrictProxyChecking
(
)
;
}
AutoDisableProxyCheck
:
:
~
AutoDisableProxyCheck
(
)
{
TlsContext
.
get
(
)
-
>
enableStrictProxyChecking
(
)
;
}
JS_FRIEND_API
void
JS
:
:
AssertGCThingMustBeTenured
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
obj
-
>
isTenured
(
)
&
&
(
!
IsNurseryAllocable
(
obj
-
>
asTenured
(
)
.
getAllocKind
(
)
)
|
|
obj
-
>
getClass
(
)
-
>
hasFinalize
(
)
)
)
;
}
JS_FRIEND_API
void
JS
:
:
AssertGCThingIsNotNurseryAllocable
(
Cell
*
cell
)
{
MOZ_ASSERT
(
cell
)
;
MOZ_ASSERT
(
!
cell
-
>
is
<
JSObject
>
(
)
&
&
!
cell
-
>
is
<
JSString
>
(
)
)
;
}
JS_FRIEND_API
void
js
:
:
gc
:
:
AssertGCThingHasType
(
js
:
:
gc
:
:
Cell
*
cell
JS
:
:
TraceKind
kind
)
{
if
(
!
cell
)
{
MOZ_ASSERT
(
kind
=
=
JS
:
:
TraceKind
:
:
Null
)
;
return
;
}
MOZ_ASSERT
(
IsCellPointerValid
(
cell
)
)
;
if
(
IsInsideNursery
(
cell
)
)
{
MOZ_ASSERT
(
kind
=
=
(
cell
-
>
nurseryCellIsString
(
)
?
JS
:
:
TraceKind
:
:
String
:
JS
:
:
TraceKind
:
:
Object
)
)
;
return
;
}
MOZ_ASSERT
(
MapAllocToTraceKind
(
cell
-
>
asTenured
(
)
.
getAllocKind
(
)
)
=
=
kind
)
;
}
#
endif
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
JS
:
:
AutoAssertNoGC
:
:
AutoAssertNoGC
(
JSContext
*
maybecx
)
:
cx_
(
maybecx
?
maybecx
:
TlsContext
.
get
(
)
)
{
if
(
cx_
)
{
cx_
-
>
inUnsafeRegion
+
+
;
}
}
JS
:
:
AutoAssertNoGC
:
:
~
AutoAssertNoGC
(
)
{
if
(
cx_
)
{
MOZ_ASSERT
(
cx_
-
>
inUnsafeRegion
>
0
)
;
cx_
-
>
inUnsafeRegion
-
-
;
}
}
#
endif
#
ifdef
DEBUG
AutoAssertNoNurseryAlloc
:
:
AutoAssertNoNurseryAlloc
(
)
{
TlsContext
.
get
(
)
-
>
disallowNurseryAlloc
(
)
;
}
AutoAssertNoNurseryAlloc
:
:
~
AutoAssertNoNurseryAlloc
(
)
{
TlsContext
.
get
(
)
-
>
allowNurseryAlloc
(
)
;
}
JS
:
:
AutoEnterCycleCollection
:
:
AutoEnterCycleCollection
(
JSRuntime
*
rt
)
:
runtime_
(
rt
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
runtime_
-
>
gc
.
heapState_
=
HeapState
:
:
CycleCollecting
;
}
JS
:
:
AutoEnterCycleCollection
:
:
~
AutoEnterCycleCollection
(
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsCycleCollecting
(
)
)
;
runtime_
-
>
gc
.
heapState_
=
HeapState
:
:
Idle
;
}
JS
:
:
AutoAssertGCCallback
:
:
AutoAssertGCCallback
(
)
:
AutoSuppressGCAnalysis
(
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
}
#
endif
JS_FRIEND_API
const
char
*
JS
:
:
GCTraceKindToAscii
(
JS
:
:
TraceKind
kind
)
{
switch
(
kind
)
{
#
define
MAP_NAME
(
name
_0
_1
_2
)
\
case
JS
:
:
TraceKind
:
:
name
:
\
return
"
JS
"
#
name
;
JS_FOR_EACH_TRACEKIND
(
MAP_NAME
)
;
#
undef
MAP_NAME
default
:
return
"
Invalid
"
;
}
}
JS_FRIEND_API
size_t
JS
:
:
GCTraceKindSize
(
JS
:
:
TraceKind
kind
)
{
switch
(
kind
)
{
#
define
MAP_SIZE
(
name
type
_0
_1
)
\
case
JS
:
:
TraceKind
:
:
name
:
\
return
sizeof
(
type
)
;
JS_FOR_EACH_TRACEKIND
(
MAP_SIZE
)
;
#
undef
MAP_SIZE
default
:
return
0
;
}
}
JS
:
:
GCCellPtr
:
:
GCCellPtr
(
const
Value
&
v
)
:
ptr
(
0
)
{
switch
(
v
.
type
(
)
)
{
case
ValueType
:
:
String
:
ptr
=
checkedCast
(
v
.
toString
(
)
JS
:
:
TraceKind
:
:
String
)
;
break
;
case
ValueType
:
:
Object
:
ptr
=
checkedCast
(
&
v
.
toObject
(
)
JS
:
:
TraceKind
:
:
Object
)
;
break
;
case
ValueType
:
:
Symbol
:
ptr
=
checkedCast
(
v
.
toSymbol
(
)
JS
:
:
TraceKind
:
:
Symbol
)
;
break
;
case
ValueType
:
:
BigInt
:
ptr
=
checkedCast
(
v
.
toBigInt
(
)
JS
:
:
TraceKind
:
:
BigInt
)
;
break
;
case
ValueType
:
:
PrivateGCThing
:
ptr
=
checkedCast
(
v
.
toGCThing
(
)
v
.
toGCThing
(
)
-
>
getTraceKind
(
)
)
;
break
;
case
ValueType
:
:
Double
:
case
ValueType
:
:
Int32
:
case
ValueType
:
:
Boolean
:
case
ValueType
:
:
Undefined
:
case
ValueType
:
:
Null
:
case
ValueType
:
:
Magic
:
{
MOZ_ASSERT
(
!
v
.
isGCThing
(
)
)
;
ptr
=
checkedCast
(
nullptr
JS
:
:
TraceKind
:
:
Null
)
;
break
;
}
}
}
JS
:
:
TraceKind
JS
:
:
GCCellPtr
:
:
outOfLineKind
(
)
const
{
MOZ_ASSERT
(
(
ptr
&
OutOfLineTraceKindMask
)
=
=
OutOfLineTraceKindMask
)
;
MOZ_ASSERT
(
asCell
(
)
-
>
isTenured
(
)
)
;
return
MapAllocToTraceKind
(
asCell
(
)
-
>
asTenured
(
)
.
getAllocKind
(
)
)
;
}
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
GCRuntime
:
:
checkHashTablesAfterMovingGC
(
)
{
rt
-
>
geckoProfiler
(
)
.
checkStringsMapAfterMovingGC
(
)
;
for
(
ZonesIter
zone
(
this
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
checkUniqueIdTableAfterMovingGC
(
)
;
zone
-
>
checkInitialShapesTableAfterMovingGC
(
)
;
zone
-
>
checkBaseShapeTableAfterMovingGC
(
)
;
zone
-
>
checkAllCrossCompartmentWrappersAfterMovingGC
(
)
;
zone
-
>
checkScriptMapsAfterMovingGC
(
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
for
(
auto
baseShape
=
zone
-
>
cellIterUnsafe
<
BaseShape
>
(
)
;
!
baseShape
.
done
(
)
;
baseShape
.
next
(
)
)
{
ShapeCachePtr
p
=
baseShape
-
>
getCache
(
nogc
)
;
p
.
checkAfterMovingGC
(
)
;
}
}
for
(
CompartmentsIter
c
(
this
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
for
(
RealmsInCompartmentIter
r
(
c
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
r
-
>
checkObjectGroupTablesAfterMovingGC
(
)
;
r
-
>
dtoaCache
.
checkCacheAfterMovingGC
(
)
;
if
(
r
-
>
debugEnvs
(
)
)
{
r
-
>
debugEnvs
(
)
-
>
checkHashTablesAfterMovingGC
(
)
;
}
}
}
}
#
endif
JS_PUBLIC_API
void
JS
:
:
PrepareZoneForGC
(
Zone
*
zone
)
{
zone
-
>
scheduleGC
(
)
;
}
JS_PUBLIC_API
void
JS
:
:
PrepareForFullGC
(
JSContext
*
cx
)
{
for
(
ZonesIter
zone
(
cx
-
>
runtime
(
)
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
zone
-
>
scheduleGC
(
)
;
}
}
JS_PUBLIC_API
void
JS
:
:
PrepareForIncrementalGC
(
JSContext
*
cx
)
{
if
(
!
JS
:
:
IsIncrementalGCInProgress
(
cx
)
)
{
return
;
}
for
(
ZonesIter
zone
(
cx
-
>
runtime
(
)
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
wasGCStarted
(
)
)
{
PrepareZoneForGC
(
zone
)
;
}
}
}
JS_PUBLIC_API
bool
JS
:
:
IsGCScheduled
(
JSContext
*
cx
)
{
for
(
ZonesIter
zone
(
cx
-
>
runtime
(
)
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
isGCScheduled
(
)
)
{
return
true
;
}
}
return
false
;
}
JS_PUBLIC_API
void
JS
:
:
SkipZoneForGC
(
Zone
*
zone
)
{
zone
-
>
unscheduleGC
(
)
;
}
JS_PUBLIC_API
void
JS
:
:
NonIncrementalGC
(
JSContext
*
cx
JSGCInvocationKind
gckind
GCReason
reason
)
{
MOZ_ASSERT
(
gckind
=
=
GC_NORMAL
|
|
gckind
=
=
GC_SHRINK
)
;
cx
-
>
runtime
(
)
-
>
gc
.
gc
(
gckind
reason
)
;
}
JS_PUBLIC_API
void
JS
:
:
StartIncrementalGC
(
JSContext
*
cx
JSGCInvocationKind
gckind
GCReason
reason
int64_t
millis
)
{
MOZ_ASSERT
(
gckind
=
=
GC_NORMAL
|
|
gckind
=
=
GC_SHRINK
)
;
cx
-
>
runtime
(
)
-
>
gc
.
startGC
(
gckind
reason
millis
)
;
}
JS_PUBLIC_API
void
JS
:
:
IncrementalGCSlice
(
JSContext
*
cx
GCReason
reason
int64_t
millis
)
{
cx
-
>
runtime
(
)
-
>
gc
.
gcSlice
(
reason
millis
)
;
}
JS_PUBLIC_API
bool
JS
:
:
IncrementalGCHasForegroundWork
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsBusy
(
)
)
;
CHECK_THREAD
(
cx
)
;
return
cx
-
>
runtime
(
)
-
>
gc
.
hasForegroundWork
(
)
;
}
JS_PUBLIC_API
void
JS
:
:
FinishIncrementalGC
(
JSContext
*
cx
GCReason
reason
)
{
cx
-
>
runtime
(
)
-
>
gc
.
finishGC
(
reason
)
;
}
JS_PUBLIC_API
void
JS
:
:
AbortIncrementalGC
(
JSContext
*
cx
)
{
if
(
IsIncrementalGCInProgress
(
cx
)
)
{
cx
-
>
runtime
(
)
-
>
gc
.
abortGC
(
)
;
}
}
char16_t
*
JS
:
:
GCDescription
:
:
formatSliceMessage
(
JSContext
*
cx
)
const
{
UniqueChars
cstr
=
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
formatCompactSliceMessage
(
)
;
size_t
nchars
=
strlen
(
cstr
.
get
(
)
)
;
UniqueTwoByteChars
out
(
js_pod_malloc
<
char16_t
>
(
nchars
+
1
)
)
;
if
(
!
out
)
{
return
nullptr
;
}
out
.
get
(
)
[
nchars
]
=
0
;
CopyAndInflateChars
(
out
.
get
(
)
cstr
.
get
(
)
nchars
)
;
return
out
.
release
(
)
;
}
char16_t
*
JS
:
:
GCDescription
:
:
formatSummaryMessage
(
JSContext
*
cx
)
const
{
UniqueChars
cstr
=
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
formatCompactSummaryMessage
(
)
;
size_t
nchars
=
strlen
(
cstr
.
get
(
)
)
;
UniqueTwoByteChars
out
(
js_pod_malloc
<
char16_t
>
(
nchars
+
1
)
)
;
if
(
!
out
)
{
return
nullptr
;
}
out
.
get
(
)
[
nchars
]
=
0
;
CopyAndInflateChars
(
out
.
get
(
)
cstr
.
get
(
)
nchars
)
;
return
out
.
release
(
)
;
}
JS
:
:
dbg
:
:
GarbageCollectionEvent
:
:
Ptr
JS
:
:
GCDescription
:
:
toGCEvent
(
JSContext
*
cx
)
const
{
return
JS
:
:
dbg
:
:
GarbageCollectionEvent
:
:
Create
(
cx
-
>
runtime
(
)
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
cx
-
>
runtime
(
)
-
>
gc
.
majorGCCount
(
)
)
;
}
char16_t
*
JS
:
:
GCDescription
:
:
formatJSONTelemetry
(
JSContext
*
cx
uint64_t
timestamp
)
const
{
UniqueChars
cstr
=
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
renderJsonMessage
(
timestamp
gcstats
:
:
Statistics
:
:
JSONUse
:
:
TELEMETRY
)
;
size_t
nchars
=
strlen
(
cstr
.
get
(
)
)
;
UniqueTwoByteChars
out
(
js_pod_malloc
<
char16_t
>
(
nchars
+
1
)
)
;
if
(
!
out
)
{
return
nullptr
;
}
out
.
get
(
)
[
nchars
]
=
0
;
CopyAndInflateChars
(
out
.
get
(
)
cstr
.
get
(
)
nchars
)
;
return
out
.
release
(
)
;
}
TimeStamp
JS
:
:
GCDescription
:
:
startTime
(
JSContext
*
cx
)
const
{
return
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
start
(
)
;
}
TimeStamp
JS
:
:
GCDescription
:
:
endTime
(
JSContext
*
cx
)
const
{
return
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
end
(
)
;
}
TimeStamp
JS
:
:
GCDescription
:
:
lastSliceStart
(
JSContext
*
cx
)
const
{
return
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
slices
(
)
.
back
(
)
.
start
;
}
TimeStamp
JS
:
:
GCDescription
:
:
lastSliceEnd
(
JSContext
*
cx
)
const
{
return
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
slices
(
)
.
back
(
)
.
end
;
}
JS
:
:
UniqueChars
JS
:
:
GCDescription
:
:
sliceToJSONProfiler
(
JSContext
*
cx
)
const
{
size_t
slices
=
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
slices
(
)
.
length
(
)
;
MOZ_ASSERT
(
slices
>
0
)
;
return
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
renderJsonSlice
(
slices
-
1
)
;
}
JS
:
:
UniqueChars
JS
:
:
GCDescription
:
:
formatJSONProfiler
(
JSContext
*
cx
)
const
{
return
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
renderJsonMessage
(
0
js
:
:
gcstats
:
:
Statistics
:
:
JSONUse
:
:
PROFILER
)
;
}
JS_PUBLIC_API
JS
:
:
UniqueChars
JS
:
:
MinorGcToJSON
(
JSContext
*
cx
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
return
rt
-
>
gc
.
stats
(
)
.
renderNurseryJson
(
)
;
}
JS_PUBLIC_API
JS
:
:
GCSliceCallback
JS
:
:
SetGCSliceCallback
(
JSContext
*
cx
GCSliceCallback
callback
)
{
return
cx
-
>
runtime
(
)
-
>
gc
.
setSliceCallback
(
callback
)
;
}
JS_PUBLIC_API
JS
:
:
DoCycleCollectionCallback
JS
:
:
SetDoCycleCollectionCallback
(
JSContext
*
cx
JS
:
:
DoCycleCollectionCallback
callback
)
{
return
cx
-
>
runtime
(
)
-
>
gc
.
setDoCycleCollectionCallback
(
callback
)
;
}
JS_PUBLIC_API
JS
:
:
GCNurseryCollectionCallback
JS
:
:
SetGCNurseryCollectionCallback
(
JSContext
*
cx
GCNurseryCollectionCallback
callback
)
{
return
cx
-
>
runtime
(
)
-
>
gc
.
setNurseryCollectionCallback
(
callback
)
;
}
JS_PUBLIC_API
void
JS
:
:
SetLowMemoryState
(
JSContext
*
cx
bool
newState
)
{
return
cx
-
>
runtime
(
)
-
>
gc
.
setLowMemoryState
(
newState
)
;
}
JS_PUBLIC_API
void
JS
:
:
DisableIncrementalGC
(
JSContext
*
cx
)
{
cx
-
>
runtime
(
)
-
>
gc
.
disallowIncrementalGC
(
)
;
}
JS_PUBLIC_API
bool
JS
:
:
IsIncrementalGCEnabled
(
JSContext
*
cx
)
{
return
cx
-
>
runtime
(
)
-
>
gc
.
isIncrementalGCEnabled
(
)
&
&
!
mozilla
:
:
recordreplay
:
:
IsRecordingOrReplaying
(
)
;
}
JS_PUBLIC_API
bool
JS
:
:
IsIncrementalGCInProgress
(
JSContext
*
cx
)
{
return
cx
-
>
runtime
(
)
-
>
gc
.
isIncrementalGCInProgress
(
)
;
}
JS_PUBLIC_API
bool
JS
:
:
IsIncrementalGCInProgress
(
JSRuntime
*
rt
)
{
return
rt
-
>
gc
.
isIncrementalGCInProgress
(
)
&
&
!
rt
-
>
gc
.
isVerifyPreBarriersEnabled
(
)
;
}
JS_PUBLIC_API
bool
JS
:
:
IsIncrementalBarrierNeeded
(
JSContext
*
cx
)
{
if
(
JS
:
:
RuntimeHeapIsBusy
(
)
)
{
return
false
;
}
auto
state
=
cx
-
>
runtime
(
)
-
>
gc
.
state
(
)
;
return
state
!
=
gc
:
:
State
:
:
NotActive
&
&
state
<
=
gc
:
:
State
:
:
Sweep
;
}
JS_PUBLIC_API
void
JS
:
:
IncrementalPreWriteBarrier
(
JSObject
*
obj
)
{
if
(
!
obj
)
{
return
;
}
JSObject
:
:
writeBarrierPre
(
obj
)
;
}
JS_PUBLIC_API
void
JS
:
:
IncrementalPreWriteBarrier
(
GCCellPtr
thing
)
{
if
(
!
thing
)
{
return
;
}
TenuredCell
:
:
writeBarrierPre
(
&
thing
.
asCell
(
)
-
>
asTenured
(
)
)
;
}
JS_PUBLIC_API
bool
JS
:
:
WasIncrementalGC
(
JSRuntime
*
rt
)
{
return
rt
-
>
gc
.
isIncrementalGc
(
)
;
}
uint64_t
js
:
:
gc
:
:
NextCellUniqueId
(
JSRuntime
*
rt
)
{
return
rt
-
>
gc
.
nextCellUniqueId
(
)
;
}
namespace
js
{
namespace
gc
{
namespace
MemInfo
{
static
bool
GCBytesGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setNumber
(
double
(
cx
-
>
runtime
(
)
-
>
gc
.
heapSize
.
bytes
(
)
)
)
;
return
true
;
}
static
bool
GCMaxBytesGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setNumber
(
double
(
cx
-
>
runtime
(
)
-
>
gc
.
tunables
.
gcMaxBytes
(
)
)
)
;
return
true
;
}
static
bool
GCHighFreqGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setBoolean
(
cx
-
>
runtime
(
)
-
>
gc
.
schedulingState
.
inHighFrequencyGCMode
(
)
)
;
return
true
;
}
static
bool
GCNumberGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setNumber
(
double
(
cx
-
>
runtime
(
)
-
>
gc
.
gcNumber
(
)
)
)
;
return
true
;
}
static
bool
MajorGCCountGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setNumber
(
double
(
cx
-
>
runtime
(
)
-
>
gc
.
majorGCCount
(
)
)
)
;
return
true
;
}
static
bool
MinorGCCountGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setNumber
(
double
(
cx
-
>
runtime
(
)
-
>
gc
.
minorGCCount
(
)
)
)
;
return
true
;
}
static
bool
GCSliceCountGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setNumber
(
double
(
cx
-
>
runtime
(
)
-
>
gc
.
gcSliceCount
(
)
)
)
;
return
true
;
}
static
bool
ZoneGCBytesGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setNumber
(
double
(
cx
-
>
zone
(
)
-
>
gcHeapSize
.
bytes
(
)
)
)
;
return
true
;
}
static
bool
ZoneGCTriggerBytesGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setNumber
(
double
(
cx
-
>
zone
(
)
-
>
gcHeapThreshold
.
bytes
(
)
)
)
;
return
true
;
}
static
bool
ZoneGCAllocTriggerGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
bool
highFrequency
=
cx
-
>
runtime
(
)
-
>
gc
.
schedulingState
.
inHighFrequencyGCMode
(
)
;
args
.
rval
(
)
.
setNumber
(
double
(
cx
-
>
zone
(
)
-
>
gcHeapThreshold
.
eagerAllocTrigger
(
highFrequency
)
)
)
;
return
true
;
}
static
bool
ZoneMallocBytesGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setNumber
(
double
(
cx
-
>
zone
(
)
-
>
mallocHeapSize
.
bytes
(
)
)
)
;
return
true
;
}
static
bool
ZoneMallocTriggerBytesGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setNumber
(
double
(
cx
-
>
zone
(
)
-
>
mallocHeapThreshold
.
bytes
(
)
)
)
;
return
true
;
}
static
bool
ZoneGCDelayBytesGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setNumber
(
double
(
cx
-
>
zone
(
)
-
>
gcDelayBytes
)
)
;
return
true
;
}
static
bool
ZoneGCNumberGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setNumber
(
double
(
cx
-
>
zone
(
)
-
>
gcNumber
(
)
)
)
;
return
true
;
}
#
ifdef
JS_MORE_DETERMINISTIC
static
bool
DummyGetter
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
#
endif
}
JSObject
*
NewMemoryInfoObject
(
JSContext
*
cx
)
{
RootedObject
obj
(
cx
JS_NewObject
(
cx
nullptr
)
)
;
if
(
!
obj
)
{
return
nullptr
;
}
using
namespace
MemInfo
;
struct
NamedGetter
{
const
char
*
name
;
JSNative
getter
;
}
getters
[
]
=
{
{
"
gcBytes
"
GCBytesGetter
}
{
"
gcMaxBytes
"
GCMaxBytesGetter
}
{
"
gcIsHighFrequencyMode
"
GCHighFreqGetter
}
{
"
gcNumber
"
GCNumberGetter
}
{
"
majorGCCount
"
MajorGCCountGetter
}
{
"
minorGCCount
"
MinorGCCountGetter
}
{
"
sliceCount
"
GCSliceCountGetter
}
}
;
for
(
auto
pair
:
getters
)
{
#
ifdef
JS_MORE_DETERMINISTIC
JSNative
getter
=
DummyGetter
;
#
else
JSNative
getter
=
pair
.
getter
;
#
endif
if
(
!
JS_DefineProperty
(
cx
obj
pair
.
name
getter
nullptr
JSPROP_ENUMERATE
)
)
{
return
nullptr
;
}
}
RootedObject
zoneObj
(
cx
JS_NewObject
(
cx
nullptr
)
)
;
if
(
!
zoneObj
)
{
return
nullptr
;
}
if
(
!
JS_DefineProperty
(
cx
obj
"
zone
"
zoneObj
JSPROP_ENUMERATE
)
)
{
return
nullptr
;
}
struct
NamedZoneGetter
{
const
char
*
name
;
JSNative
getter
;
}
zoneGetters
[
]
=
{
{
"
gcBytes
"
ZoneGCBytesGetter
}
{
"
gcTriggerBytes
"
ZoneGCTriggerBytesGetter
}
{
"
gcAllocTrigger
"
ZoneGCAllocTriggerGetter
}
{
"
mallocBytes
"
ZoneMallocBytesGetter
}
{
"
mallocTriggerBytes
"
ZoneMallocTriggerBytesGetter
}
{
"
delayBytes
"
ZoneGCDelayBytesGetter
}
{
"
gcNumber
"
ZoneGCNumberGetter
}
}
;
for
(
auto
pair
:
zoneGetters
)
{
#
ifdef
JS_MORE_DETERMINISTIC
JSNative
getter
=
DummyGetter
;
#
else
JSNative
getter
=
pair
.
getter
;
#
endif
if
(
!
JS_DefineProperty
(
cx
zoneObj
pair
.
name
getter
nullptr
JSPROP_ENUMERATE
)
)
{
return
nullptr
;
}
}
return
obj
;
}
const
char
*
StateName
(
State
state
)
{
switch
(
state
)
{
#
define
MAKE_CASE
(
name
)
\
case
State
:
:
name
:
\
return
#
name
;
GCSTATES
(
MAKE_CASE
)
#
undef
MAKE_CASE
}
MOZ_CRASH
(
"
Invalid
gc
:
:
State
enum
value
"
)
;
}
const
char
*
StateName
(
JS
:
:
Zone
:
:
GCState
state
)
{
switch
(
state
)
{
case
JS
:
:
Zone
:
:
NoGC
:
return
"
NoGC
"
;
case
JS
:
:
Zone
:
:
MarkBlackOnly
:
return
"
MarkBlackOnly
"
;
case
JS
:
:
Zone
:
:
MarkBlackAndGray
:
return
"
MarkBlackAndGray
"
;
case
JS
:
:
Zone
:
:
Sweep
:
return
"
Sweep
"
;
case
JS
:
:
Zone
:
:
Finished
:
return
"
Finished
"
;
case
JS
:
:
Zone
:
:
Compact
:
return
"
Compact
"
;
}
MOZ_CRASH
(
"
Invalid
Zone
:
:
GCState
enum
value
"
)
;
}
void
AutoAssertEmptyNursery
:
:
checkCondition
(
JSContext
*
cx
)
{
if
(
!
noAlloc
)
{
noAlloc
.
emplace
(
)
;
}
this
-
>
cx
=
cx
;
MOZ_ASSERT
(
cx
-
>
nursery
(
)
.
isEmpty
(
)
)
;
}
AutoEmptyNursery
:
:
AutoEmptyNursery
(
JSContext
*
cx
)
:
AutoAssertEmptyNursery
(
)
{
MOZ_ASSERT
(
!
cx
-
>
suppressGC
)
;
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
suspendPhases
(
)
;
cx
-
>
runtime
(
)
-
>
gc
.
evictNursery
(
JS
:
:
GCReason
:
:
EVICT_NURSERY
)
;
cx
-
>
runtime
(
)
-
>
gc
.
stats
(
)
.
resumePhases
(
)
;
checkCondition
(
cx
)
;
}
}
}
#
ifdef
DEBUG
namespace
js
{
extern
JS_FRIEND_API
void
DumpString
(
JSString
*
str
js
:
:
GenericPrinter
&
out
)
;
}
void
js
:
:
gc
:
:
Cell
:
:
dump
(
js
:
:
GenericPrinter
&
out
)
const
{
switch
(
getTraceKind
(
)
)
{
case
JS
:
:
TraceKind
:
:
Object
:
reinterpret_cast
<
const
JSObject
*
>
(
this
)
-
>
dump
(
out
)
;
break
;
case
JS
:
:
TraceKind
:
:
String
:
js
:
:
DumpString
(
reinterpret_cast
<
JSString
*
>
(
const_cast
<
Cell
*
>
(
this
)
)
out
)
;
break
;
case
JS
:
:
TraceKind
:
:
Shape
:
reinterpret_cast
<
const
Shape
*
>
(
this
)
-
>
dump
(
out
)
;
break
;
default
:
out
.
printf
(
"
%
s
(
%
p
)
\
n
"
JS
:
:
GCTraceKindToAscii
(
getTraceKind
(
)
)
(
void
*
)
this
)
;
}
}
void
js
:
:
gc
:
:
Cell
:
:
dump
(
)
const
{
js
:
:
Fprinter
out
(
stderr
)
;
dump
(
out
)
;
}
#
endif
static
inline
bool
CanCheckGrayBits
(
const
Cell
*
cell
)
{
MOZ_ASSERT
(
cell
)
;
if
(
!
cell
-
>
isTenured
(
)
)
{
return
false
;
}
auto
tc
=
&
cell
-
>
asTenured
(
)
;
auto
rt
=
tc
-
>
runtimeFromAnyThread
(
)
;
return
CurrentThreadCanAccessRuntime
(
rt
)
&
&
rt
-
>
gc
.
areGrayBitsValid
(
)
;
}
JS_PUBLIC_API
bool
js
:
:
gc
:
:
detail
:
:
CellIsMarkedGrayIfKnown
(
const
Cell
*
cell
)
{
if
(
!
CanCheckGrayBits
(
cell
)
)
{
return
false
;
}
auto
tc
=
&
cell
-
>
asTenured
(
)
;
MOZ_ASSERT
(
!
tc
-
>
zoneFromAnyThread
(
)
-
>
usedByHelperThread
(
)
)
;
auto
rt
=
tc
-
>
runtimeFromMainThread
(
)
;
if
(
rt
-
>
gc
.
isIncrementalGCInProgress
(
)
&
&
!
tc
-
>
zone
(
)
-
>
wasGCStarted
(
)
)
{
return
false
;
}
return
detail
:
:
CellIsMarkedGray
(
tc
)
;
}
#
ifdef
DEBUG
JS_PUBLIC_API
void
js
:
:
gc
:
:
detail
:
:
AssertCellIsNotGray
(
const
Cell
*
cell
)
{
if
(
!
CanCheckGrayBits
(
cell
)
)
{
return
;
}
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsCycleCollecting
(
)
)
;
auto
tc
=
&
cell
-
>
asTenured
(
)
;
if
(
tc
-
>
zone
(
)
-
>
isGCMarkingBlackAndGray
(
)
)
{
if
(
!
tc
-
>
isMarkedBlack
(
)
)
{
JSRuntime
*
rt
=
tc
-
>
zone
(
)
-
>
runtimeFromMainThread
(
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
rt
-
>
gc
.
cellsToAssertNotGray
.
ref
(
)
.
append
(
cell
)
)
{
oomUnsafe
.
crash
(
"
Can
'
t
append
to
delayed
gray
checks
list
"
)
;
}
}
return
;
}
MOZ_ASSERT
(
!
tc
-
>
isMarkedGray
(
)
)
;
}
extern
JS_PUBLIC_API
bool
js
:
:
gc
:
:
detail
:
:
ObjectIsMarkedBlack
(
const
JSObject
*
obj
)
{
return
obj
-
>
isMarkedBlack
(
)
;
}
#
endif
js
:
:
gc
:
:
ClearEdgesTracer
:
:
ClearEdgesTracer
(
JSRuntime
*
rt
)
:
CallbackTracer
(
rt
TraceWeakMapKeysValues
)
{
}
js
:
:
gc
:
:
ClearEdgesTracer
:
:
ClearEdgesTracer
(
)
:
ClearEdgesTracer
(
TlsContext
.
get
(
)
-
>
runtime
(
)
)
{
}
template
<
typename
S
>
inline
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
clearEdge
(
S
*
*
thingp
)
{
InternalBarrierMethods
<
S
*
>
:
:
preBarrier
(
*
thingp
)
;
InternalBarrierMethods
<
S
*
>
:
:
postBarrier
(
thingp
*
thingp
nullptr
)
;
*
thingp
=
nullptr
;
return
false
;
}
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onObjectEdge
(
JSObject
*
*
objp
)
{
return
clearEdge
(
objp
)
;
}
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onStringEdge
(
JSString
*
*
strp
)
{
return
clearEdge
(
strp
)
;
}
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onSymbolEdge
(
JS
:
:
Symbol
*
*
symp
)
{
return
clearEdge
(
symp
)
;
}
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onBigIntEdge
(
JS
:
:
BigInt
*
*
bip
)
{
return
clearEdge
(
bip
)
;
}
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onScriptEdge
(
JSScript
*
*
scriptp
)
{
return
clearEdge
(
scriptp
)
;
}
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onShapeEdge
(
js
:
:
Shape
*
*
shapep
)
{
return
clearEdge
(
shapep
)
;
}
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onObjectGroupEdge
(
js
:
:
ObjectGroup
*
*
groupp
)
{
return
clearEdge
(
groupp
)
;
}
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onBaseShapeEdge
(
js
:
:
BaseShape
*
*
basep
)
{
return
clearEdge
(
basep
)
;
}
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onJitCodeEdge
(
js
:
:
jit
:
:
JitCode
*
*
codep
)
{
return
clearEdge
(
codep
)
;
}
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onLazyScriptEdge
(
js
:
:
LazyScript
*
*
lazyp
)
{
return
clearEdge
(
lazyp
)
;
}
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onScopeEdge
(
js
:
:
Scope
*
*
scopep
)
{
return
clearEdge
(
scopep
)
;
}
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onRegExpSharedEdge
(
js
:
:
RegExpShared
*
*
sharedp
)
{
return
clearEdge
(
sharedp
)
;
}
bool
js
:
:
gc
:
:
ClearEdgesTracer
:
:
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
{
MOZ_CRASH
(
)
;
return
true
;
}
JS_PUBLIC_API
void
js
:
:
gc
:
:
FinalizeDeadNurseryObject
(
JSContext
*
cx
JSObject
*
obj
)
{
CHECK_THREAD
(
cx
)
;
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsMinorCollecting
(
)
)
;
MOZ_ASSERT
(
obj
)
;
MOZ_ASSERT
(
IsInsideNursery
(
obj
)
)
;
mozilla
:
:
DebugOnly
<
JSObject
*
>
prior
(
obj
)
;
MOZ_ASSERT
(
IsAboutToBeFinalizedUnbarriered
(
&
prior
)
)
;
MOZ_ASSERT
(
obj
=
=
prior
)
;
const
JSClass
*
jsClass
=
js
:
:
GetObjectClass
(
obj
)
;
jsClass
-
>
doFinalize
(
cx
-
>
defaultFreeOp
(
)
obj
)
;
}
