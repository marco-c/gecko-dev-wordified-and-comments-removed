#
ifndef
gc_StoreBuffer_inl_h
#
define
gc_StoreBuffer_inl_h
#
include
"
gc
/
StoreBuffer
.
h
"
#
include
"
gc
/
Heap
-
inl
.
h
"
namespace
js
{
namespace
gc
{
inline
size_t
ArenaCellSet
:
:
getCellIndex
(
const
TenuredCell
*
cell
)
{
uintptr_t
cellOffset
=
uintptr_t
(
cell
)
&
ArenaMask
;
MOZ_ASSERT
(
cellOffset
%
ArenaCellIndexBytes
=
=
0
)
;
return
cellOffset
/
ArenaCellIndexBytes
;
}
inline
void
ArenaCellSet
:
:
getWordIndexAndMask
(
size_t
cellIndex
size_t
*
wordp
uint32_t
*
maskp
)
{
BitArray
<
MaxArenaCellIndex
>
:
:
getIndexAndMask
(
cellIndex
wordp
maskp
)
;
}
inline
bool
ArenaCellSet
:
:
hasCell
(
size_t
cellIndex
)
const
{
MOZ_ASSERT
(
cellIndex
<
MaxArenaCellIndex
)
;
return
bits
.
get
(
cellIndex
)
;
}
inline
void
ArenaCellSet
:
:
putCell
(
size_t
cellIndex
)
{
MOZ_ASSERT
(
cellIndex
<
MaxArenaCellIndex
)
;
MOZ_ASSERT
(
arena
)
;
bits
.
set
(
cellIndex
)
;
check
(
)
;
}
inline
void
ArenaCellSet
:
:
check
(
)
const
{
#
ifdef
DEBUG
bool
bitsZero
=
bits
.
isAllClear
(
)
;
MOZ_ASSERT
(
isEmpty
(
)
=
=
bitsZero
)
;
MOZ_ASSERT
(
isEmpty
(
)
=
=
!
arena
)
;
if
(
!
isEmpty
(
)
)
{
MOZ_ASSERT
(
IsCellPointerValid
(
arena
)
)
;
JSRuntime
*
runtime
=
arena
-
>
zone
(
)
-
>
runtimeFromMainThread
(
)
;
uint64_t
minorGCCount
=
runtime
-
>
gc
.
minorGCCount
(
)
;
MOZ_ASSERT
(
minorGCCount
=
=
minorGCNumberAtCreation
|
|
minorGCCount
=
=
minorGCNumberAtCreation
+
1
)
;
}
#
endif
}
inline
void
StoreBuffer
:
:
WholeCellBuffer
:
:
put
(
const
Cell
*
cell
)
{
if
(
cell
!
=
last_
)
{
putDontCheckLast
(
cell
)
;
}
}
inline
void
StoreBuffer
:
:
WholeCellBuffer
:
:
putDontCheckLast
(
const
Cell
*
cell
)
{
MOZ_ASSERT
(
cell
-
>
isTenured
(
)
)
;
MOZ_ASSERT
(
cell
-
>
getTraceKind
(
)
!
=
JS
:
:
TraceKind
:
:
BigInt
)
;
Arena
*
arena
=
cell
-
>
asTenured
(
)
.
arena
(
)
;
ArenaCellSet
*
cells
=
arena
-
>
bufferedCells
(
)
;
if
(
cells
-
>
isEmpty
(
)
)
{
cells
=
allocateCellSet
(
arena
)
;
if
(
!
cells
)
{
return
;
}
}
cells
-
>
putCell
(
&
cell
-
>
asTenured
(
)
)
;
cells
-
>
check
(
)
;
last_
=
cell
;
}
inline
bool
StoreBuffer
:
:
isInWholeCellBuffer
(
Cell
*
cell
)
{
TenuredCell
*
tenured
=
&
cell
-
>
asTenured
(
)
;
gc
:
:
ArenaCellSet
*
cells
=
tenured
-
>
arena
(
)
-
>
bufferedCells
(
)
;
return
cells
&
&
cells
-
>
hasCell
(
tenured
)
;
}
inline
void
StoreBuffer
:
:
putWholeCell
(
Cell
*
cell
)
{
bufferWholeCell
.
put
(
cell
)
;
}
inline
void
StoreBuffer
:
:
putWholeCellDontCheckLast
(
Cell
*
cell
)
{
bufferWholeCell
.
putDontCheckLast
(
cell
)
;
}
}
}
#
endif
