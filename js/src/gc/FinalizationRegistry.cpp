#
include
"
builtin
/
FinalizationRegistryObject
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
gc
/
PrivateIterators
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
bool
GCRuntime
:
:
addFinalizationRegistry
(
JSContext
*
cx
FinalizationRegistryObject
*
registry
)
{
if
(
!
cx
-
>
zone
(
)
-
>
finalizationRegistries
(
)
.
put
(
registry
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
bool
GCRuntime
:
:
registerWithFinalizationRegistry
(
JSContext
*
cx
HandleObject
target
HandleObject
record
)
{
MOZ_ASSERT
(
!
IsCrossCompartmentWrapper
(
target
)
)
;
MOZ_ASSERT
(
UncheckedUnwrapWithoutExpose
(
record
)
-
>
is
<
FinalizationRecordObject
>
(
)
)
;
MOZ_ASSERT
(
target
-
>
compartment
(
)
=
=
record
-
>
compartment
(
)
)
;
auto
&
map
=
target
-
>
zone
(
)
-
>
finalizationRecordMap
(
)
;
auto
ptr
=
map
.
lookupForAdd
(
target
)
;
if
(
!
ptr
)
{
if
(
!
map
.
add
(
ptr
target
FinalizationRecordVector
(
target
-
>
zone
(
)
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
if
(
!
ptr
-
>
value
(
)
.
append
(
record
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
void
GCRuntime
:
:
markFinalizationRegistryRoots
(
JSTracer
*
trc
)
{
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
Zone
:
:
FinalizationRecordMap
&
map
=
zone
-
>
finalizationRecordMap
(
)
;
for
(
Zone
:
:
FinalizationRecordMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
e
.
front
(
)
.
value
(
)
.
trace
(
trc
)
;
}
}
}
static
FinalizationRecordObject
*
UnwrapFinalizationRecord
(
JSObject
*
obj
)
{
obj
=
UncheckedUnwrapWithoutExpose
(
obj
)
;
if
(
!
obj
-
>
is
<
FinalizationRecordObject
>
(
)
)
{
MOZ_ASSERT
(
JS_IsDeadWrapper
(
obj
)
)
;
return
nullptr
;
}
return
&
obj
-
>
as
<
FinalizationRecordObject
>
(
)
;
}
void
GCRuntime
:
:
sweepFinalizationRegistries
(
Zone
*
zone
)
{
Zone
:
:
FinalizationRegistrySet
&
set
=
zone
-
>
finalizationRegistries
(
)
;
for
(
Zone
:
:
FinalizationRegistrySet
:
:
Enum
e
(
set
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
if
(
IsAboutToBeFinalized
(
&
e
.
mutableFront
(
)
)
)
{
e
.
front
(
)
-
>
as
<
FinalizationRegistryObject
>
(
)
.
queue
(
)
-
>
setHasRegistry
(
false
)
;
e
.
removeFront
(
)
;
}
else
{
e
.
front
(
)
-
>
as
<
FinalizationRegistryObject
>
(
)
.
sweep
(
)
;
}
}
Zone
:
:
FinalizationRecordMap
&
map
=
zone
-
>
finalizationRecordMap
(
)
;
for
(
Zone
:
:
FinalizationRecordMap
:
:
Enum
e
(
map
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
FinalizationRecordVector
&
records
=
e
.
front
(
)
.
value
(
)
;
records
.
sweep
(
)
;
records
.
eraseIf
(
[
]
(
JSObject
*
obj
)
{
FinalizationRecordObject
*
record
=
UnwrapFinalizationRecord
(
obj
)
;
return
!
record
|
|
!
record
-
>
isActive
(
)
|
|
!
record
-
>
queue
(
)
-
>
hasRegistry
(
)
;
}
)
;
if
(
IsAboutToBeFinalized
(
&
e
.
front
(
)
.
mutableKey
(
)
)
)
{
for
(
JSObject
*
obj
:
records
)
{
FinalizationRecordObject
*
record
=
UnwrapFinalizationRecord
(
obj
)
;
FinalizationQueueObject
*
queue
=
record
-
>
queue
(
)
;
queue
-
>
queueRecordToBeCleanedUp
(
record
)
;
queueFinalizationRegistryForCleanup
(
queue
)
;
}
e
.
removeFront
(
)
;
}
}
}
void
GCRuntime
:
:
queueFinalizationRegistryForCleanup
(
FinalizationQueueObject
*
queue
)
{
if
(
queue
-
>
isQueuedForCleanup
(
)
)
{
return
;
}
JSObject
*
object
=
UncheckedUnwrapWithoutExpose
(
queue
-
>
incumbentObject
(
)
)
;
MOZ_ASSERT
(
object
)
;
GlobalObject
*
incumbentGlobal
=
&
object
-
>
nonCCWGlobal
(
)
;
callHostCleanupFinalizationRegistryCallback
(
queue
-
>
doCleanupFunction
(
)
incumbentGlobal
)
;
queue
-
>
setQueuedForCleanup
(
true
)
;
}
