#
ifndef
gc_GC_h
#
define
gc_GC_h
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
RealmIterators
.
h
"
#
include
"
js
/
RealmOptions
.
h
"
#
include
"
js
/
TraceKind
.
h
"
class
JSTracer
;
namespace
js
{
class
FatInlineAtom
;
class
NormalAtom
;
class
Nursery
;
namespace
gc
{
class
Arena
;
class
TenuredChunk
;
struct
Cell
;
}
extern
void
TraceRuntime
(
JSTracer
*
trc
)
;
extern
void
TraceRuntimeWithoutEviction
(
JSTracer
*
trc
)
;
extern
void
ReleaseAllJITCode
(
JSFreeOp
*
op
)
;
extern
void
PrepareForDebugGC
(
JSRuntime
*
rt
)
;
extern
void
NotifyGCNukeWrapper
(
JSContext
*
cx
JSObject
*
wrapper
)
;
extern
unsigned
NotifyGCPreSwap
(
JSObject
*
a
JSObject
*
b
)
;
extern
void
NotifyGCPostSwap
(
JSObject
*
a
JSObject
*
b
unsigned
preResult
)
;
using
IterateChunkCallback
=
void
(
*
)
(
JSRuntime
*
void
*
gc
:
:
TenuredChunk
*
const
JS
:
:
AutoRequireNoGC
&
)
;
using
IterateZoneCallback
=
void
(
*
)
(
JSRuntime
*
void
*
JS
:
:
Zone
*
const
JS
:
:
AutoRequireNoGC
&
)
;
using
IterateArenaCallback
=
void
(
*
)
(
JSRuntime
*
void
*
gc
:
:
Arena
*
JS
:
:
TraceKind
size_t
const
JS
:
:
AutoRequireNoGC
&
)
;
using
IterateCellCallback
=
void
(
*
)
(
JSRuntime
*
void
*
JS
:
:
GCCellPtr
size_t
const
JS
:
:
AutoRequireNoGC
&
)
;
extern
void
IterateHeapUnbarriered
(
JSContext
*
cx
void
*
data
IterateZoneCallback
zoneCallback
JS
:
:
IterateRealmCallback
realmCallback
IterateArenaCallback
arenaCallback
IterateCellCallback
cellCallback
)
;
extern
void
IterateHeapUnbarrieredForZone
(
JSContext
*
cx
JS
:
:
Zone
*
zone
void
*
data
IterateZoneCallback
zoneCallback
JS
:
:
IterateRealmCallback
realmCallback
IterateArenaCallback
arenaCallback
IterateCellCallback
cellCallback
)
;
extern
void
IterateChunks
(
JSContext
*
cx
void
*
data
IterateChunkCallback
chunkCallback
)
;
using
IterateScriptCallback
=
void
(
*
)
(
JSRuntime
*
void
*
BaseScript
*
const
JS
:
:
AutoRequireNoGC
&
)
;
extern
void
IterateScripts
(
JSContext
*
cx
JS
:
:
Realm
*
realm
void
*
data
IterateScriptCallback
scriptCallback
)
;
JS
:
:
Realm
*
NewRealm
(
JSContext
*
cx
JSPrincipals
*
principals
const
JS
:
:
RealmOptions
&
options
)
;
namespace
gc
{
void
FinishGC
(
JSContext
*
cx
JS
:
:
GCReason
=
JS
:
:
GCReason
:
:
FINISH_GC
)
;
void
WaitForBackgroundTasks
(
JSContext
*
cx
)
;
enum
VerifierType
{
PreBarrierVerifier
}
;
#
ifdef
JS_GC_ZEAL
extern
const
char
ZealModeHelpText
[
]
;
void
VerifyBarriers
(
JSRuntime
*
rt
VerifierType
type
)
;
void
MaybeVerifyBarriers
(
JSContext
*
cx
bool
always
=
false
)
;
void
DumpArenaInfo
(
)
;
#
else
static
inline
void
VerifyBarriers
(
JSRuntime
*
rt
VerifierType
type
)
{
}
static
inline
void
MaybeVerifyBarriers
(
JSContext
*
cx
bool
always
=
false
)
{
}
#
endif
class
MOZ_RAII
JS_HAZ_GC_SUPPRESSED
AutoSuppressGC
{
int32_t
&
suppressGC_
;
public
:
explicit
AutoSuppressGC
(
JSContext
*
cx
)
;
~
AutoSuppressGC
(
)
{
suppressGC_
-
-
;
}
}
;
const
char
*
StateName
(
State
state
)
;
}
class
MOZ_RAII
AutoDisableProxyCheck
{
public
:
#
ifdef
DEBUG
AutoDisableProxyCheck
(
)
;
~
AutoDisableProxyCheck
(
)
;
#
else
AutoDisableProxyCheck
(
)
{
}
#
endif
}
;
struct
MOZ_RAII
AutoDisableCompactingGC
{
explicit
AutoDisableCompactingGC
(
JSContext
*
cx
)
;
~
AutoDisableCompactingGC
(
)
;
private
:
JSContext
*
cx
;
}
;
}
#
endif
