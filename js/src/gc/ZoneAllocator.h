#
ifndef
gc_ZoneAllocator_h
#
define
gc_ZoneAllocator_h
#
include
"
gc
/
Scheduling
.
h
"
#
include
"
vm
/
Runtime
.
h
"
namespace
JS
{
class
Zone
;
}
namespace
js
{
namespace
gc
{
void
MaybeMallocTriggerZoneGC
(
JSRuntime
*
rt
ZoneAllocator
*
zoneAlloc
const
HeapSize
&
heap
const
ZoneThreshold
&
threshold
JS
:
:
GCReason
reason
)
;
}
class
ZoneAllocator
:
public
JS
:
:
shadow
:
:
Zone
public
js
:
:
MallocProvider
<
JS
:
:
Zone
>
{
protected
:
explicit
ZoneAllocator
(
JSRuntime
*
rt
)
;
~
ZoneAllocator
(
)
;
void
fixupAfterMovingGC
(
)
;
public
:
static
ZoneAllocator
*
from
(
JS
:
:
Zone
*
zone
)
{
return
reinterpret_cast
<
ZoneAllocator
*
>
(
zone
)
;
}
MOZ_MUST_USE
void
*
onOutOfMemory
(
js
:
:
AllocFunction
allocFunc
arena_id_t
arena
size_t
nbytes
void
*
reallocPtr
=
nullptr
)
;
void
reportAllocationOverflow
(
)
const
;
void
adoptMallocBytes
(
ZoneAllocator
*
other
)
{
gcMallocBytes
.
adopt
(
other
-
>
gcMallocBytes
)
;
gcJitBytes
.
adopt
(
other
-
>
gcJitBytes
)
;
#
ifdef
DEBUG
gcMallocTracker
.
adopt
(
other
-
>
gcMallocTracker
)
;
#
endif
}
void
updateMemoryCountersOnGCStart
(
)
;
void
updateGCThresholds
(
gc
:
:
GCRuntime
&
gc
JSGCInvocationKind
invocationKind
const
js
:
:
AutoLockGC
&
lock
)
;
void
addCellMemory
(
js
:
:
gc
:
:
Cell
*
cell
size_t
nbytes
js
:
:
MemoryUse
use
)
{
MOZ_ASSERT
(
cell
)
;
MOZ_ASSERT
(
nbytes
)
;
gcMallocBytes
.
addBytes
(
nbytes
)
;
#
ifdef
DEBUG
gcMallocTracker
.
trackMemory
(
cell
nbytes
use
)
;
#
endif
}
void
removeCellMemory
(
js
:
:
gc
:
:
Cell
*
cell
size_t
nbytes
js
:
:
MemoryUse
use
bool
wasSwept
=
false
)
{
MOZ_ASSERT
(
cell
)
;
MOZ_ASSERT
(
nbytes
)
;
MOZ_ASSERT_IF
(
CurrentThreadIsGCSweeping
(
)
wasSwept
)
;
gcMallocBytes
.
removeBytes
(
nbytes
wasSwept
)
;
#
ifdef
DEBUG
gcMallocTracker
.
untrackMemory
(
cell
nbytes
use
)
;
#
endif
}
void
swapCellMemory
(
js
:
:
gc
:
:
Cell
*
a
js
:
:
gc
:
:
Cell
*
b
js
:
:
MemoryUse
use
)
{
#
ifdef
DEBUG
gcMallocTracker
.
swapMemory
(
a
b
use
)
;
#
endif
}
#
ifdef
DEBUG
void
registerPolicy
(
js
:
:
ZoneAllocPolicy
*
policy
)
{
return
gcMallocTracker
.
registerPolicy
(
policy
)
;
}
void
unregisterPolicy
(
js
:
:
ZoneAllocPolicy
*
policy
)
{
return
gcMallocTracker
.
unregisterPolicy
(
policy
)
;
}
void
movePolicy
(
js
:
:
ZoneAllocPolicy
*
dst
js
:
:
ZoneAllocPolicy
*
src
)
{
return
gcMallocTracker
.
movePolicy
(
dst
src
)
;
}
#
endif
void
incPolicyMemory
(
js
:
:
ZoneAllocPolicy
*
policy
size_t
nbytes
)
{
MOZ_ASSERT
(
nbytes
)
;
gcMallocBytes
.
addBytes
(
nbytes
)
;
#
ifdef
DEBUG
gcMallocTracker
.
incPolicyMemory
(
policy
nbytes
)
;
#
endif
maybeMallocTriggerZoneGC
(
)
;
}
void
decPolicyMemory
(
js
:
:
ZoneAllocPolicy
*
policy
size_t
nbytes
bool
wasSwept
)
{
MOZ_ASSERT
(
nbytes
)
;
MOZ_ASSERT_IF
(
CurrentThreadIsGCSweeping
(
)
wasSwept
)
;
gcMallocBytes
.
removeBytes
(
nbytes
wasSwept
)
;
#
ifdef
DEBUG
gcMallocTracker
.
decPolicyMemory
(
policy
nbytes
)
;
#
endif
}
void
incJitMemory
(
size_t
nbytes
)
{
MOZ_ASSERT
(
nbytes
)
;
gcJitBytes
.
addBytes
(
nbytes
)
;
maybeTriggerZoneGC
(
gcJitBytes
gcJitThreshold
JS
:
:
GCReason
:
:
TOO_MUCH_JIT_CODE
)
;
}
void
decJitMemory
(
size_t
nbytes
)
{
MOZ_ASSERT
(
nbytes
)
;
gcJitBytes
.
removeBytes
(
nbytes
true
)
;
}
void
maybeMallocTriggerZoneGC
(
)
{
maybeTriggerZoneGC
(
gcMallocBytes
gcMallocThreshold
JS
:
:
GCReason
:
:
TOO_MUCH_MALLOC
)
;
}
private
:
void
maybeTriggerZoneGC
(
const
js
:
:
gc
:
:
HeapSize
&
heap
const
js
:
:
gc
:
:
ZoneThreshold
&
threshold
JS
:
:
GCReason
reason
)
{
JSRuntime
*
rt
=
runtimeFromAnyThread
(
)
;
float
factor
=
rt
-
>
gc
.
tunables
.
allocThresholdFactor
(
)
;
size_t
thresholdBytes
=
threshold
.
gcTriggerBytes
(
)
*
factor
;
if
(
heap
.
gcBytes
(
)
>
=
thresholdBytes
&
&
rt
-
>
heapState
(
)
=
=
JS
:
:
HeapState
:
:
Idle
)
{
gc
:
:
MaybeMallocTriggerZoneGC
(
rt
this
heap
threshold
reason
)
;
}
}
public
:
js
:
:
gc
:
:
HeapSize
zoneSize
;
js
:
:
gc
:
:
ZoneHeapThreshold
threshold
;
js
:
:
MainThreadData
<
size_t
>
gcDelayBytes
;
js
:
:
gc
:
:
HeapSize
gcMallocBytes
;
js
:
:
gc
:
:
ZoneMallocThreshold
gcMallocThreshold
;
js
:
:
gc
:
:
HeapSize
gcJitBytes
;
js
:
:
gc
:
:
ZoneFixedThreshold
gcJitThreshold
;
private
:
#
ifdef
DEBUG
js
:
:
gc
:
:
MemoryTracker
gcMallocTracker
;
#
endif
friend
class
js
:
:
gc
:
:
GCRuntime
;
}
;
class
ZoneAllocPolicy
:
public
MallocProvider
<
ZoneAllocPolicy
>
{
ZoneAllocator
*
zone_
;
#
ifdef
DEBUG
friend
class
js
:
:
gc
:
:
MemoryTracker
;
#
endif
public
:
MOZ_IMPLICIT
ZoneAllocPolicy
(
ZoneAllocator
*
z
)
:
zone_
(
z
)
{
#
ifdef
DEBUG
zone
(
)
-
>
registerPolicy
(
this
)
;
#
endif
}
MOZ_IMPLICIT
ZoneAllocPolicy
(
JS
:
:
Zone
*
z
)
:
ZoneAllocPolicy
(
ZoneAllocator
:
:
from
(
z
)
)
{
}
ZoneAllocPolicy
(
ZoneAllocPolicy
&
other
)
:
ZoneAllocPolicy
(
other
.
zone_
)
{
}
ZoneAllocPolicy
(
ZoneAllocPolicy
&
&
other
)
:
zone_
(
other
.
zone_
)
{
#
ifdef
DEBUG
zone
(
)
-
>
movePolicy
(
this
&
other
)
;
#
endif
other
.
zone_
=
nullptr
;
}
~
ZoneAllocPolicy
(
)
{
#
ifdef
DEBUG
if
(
zone_
)
{
zone_
-
>
unregisterPolicy
(
this
)
;
}
#
endif
}
ZoneAllocPolicy
&
operator
=
(
const
ZoneAllocPolicy
&
other
)
{
#
ifdef
DEBUG
zone
(
)
-
>
unregisterPolicy
(
this
)
;
#
endif
zone_
=
other
.
zone
(
)
;
#
ifdef
DEBUG
zone
(
)
-
>
registerPolicy
(
this
)
;
#
endif
return
*
this
;
}
ZoneAllocPolicy
&
operator
=
(
ZoneAllocPolicy
&
&
other
)
{
#
ifdef
DEBUG
zone
(
)
-
>
unregisterPolicy
(
this
)
;
zone
(
)
-
>
movePolicy
(
this
&
other
)
;
#
endif
other
.
zone_
=
nullptr
;
return
*
this
;
}
template
<
typename
T
>
void
free_
(
T
*
p
size_t
numElems
)
{
if
(
p
)
{
decMemory
(
numElems
*
sizeof
(
T
)
)
;
js_free
(
p
)
;
}
}
MOZ_MUST_USE
bool
checkSimulatedOOM
(
)
const
{
return
!
js
:
:
oom
:
:
ShouldFailWithOOM
(
)
;
}
void
reportAllocOverflow
(
)
const
{
reportAllocationOverflow
(
)
;
}
MOZ_MUST_USE
void
*
onOutOfMemory
(
js
:
:
AllocFunction
allocFunc
arena_id_t
arena
size_t
nbytes
void
*
reallocPtr
=
nullptr
)
{
return
zone
(
)
-
>
onOutOfMemory
(
allocFunc
arena
nbytes
reallocPtr
)
;
}
void
reportAllocationOverflow
(
)
const
{
zone
(
)
-
>
reportAllocationOverflow
(
)
;
}
void
updateMallocCounter
(
size_t
nbytes
)
{
zone
(
)
-
>
incPolicyMemory
(
this
nbytes
)
;
}
private
:
ZoneAllocator
*
zone
(
)
const
{
MOZ_ASSERT
(
zone_
)
;
return
zone_
;
}
void
decMemory
(
size_t
nbytes
)
;
}
;
inline
void
AddCellMemory
(
gc
:
:
TenuredCell
*
cell
size_t
nbytes
MemoryUse
use
)
{
if
(
nbytes
)
{
ZoneAllocator
:
:
from
(
cell
-
>
zone
(
)
)
-
>
addCellMemory
(
cell
nbytes
use
)
;
}
}
inline
void
AddCellMemory
(
gc
:
:
Cell
*
cell
size_t
nbytes
MemoryUse
use
)
{
if
(
cell
-
>
isTenured
(
)
)
{
AddCellMemory
(
&
cell
-
>
asTenured
(
)
nbytes
use
)
;
}
}
inline
void
RemoveCellMemory
(
gc
:
:
TenuredCell
*
cell
size_t
nbytes
MemoryUse
use
bool
wasSwept
=
false
)
{
if
(
nbytes
)
{
auto
zoneBase
=
ZoneAllocator
:
:
from
(
cell
-
>
zoneFromAnyThread
(
)
)
;
zoneBase
-
>
removeCellMemory
(
cell
nbytes
use
wasSwept
)
;
}
}
inline
void
RemoveCellMemory
(
gc
:
:
Cell
*
cell
size_t
nbytes
MemoryUse
use
bool
wasSwept
=
false
)
{
if
(
cell
-
>
isTenured
(
)
)
{
RemoveCellMemory
(
&
cell
-
>
asTenured
(
)
nbytes
use
wasSwept
)
;
}
}
inline
void
InitReservedSlot
(
NativeObject
*
obj
uint32_t
slot
void
*
ptr
size_t
nbytes
MemoryUse
use
)
{
AddCellMemory
(
obj
nbytes
use
)
;
obj
-
>
initReservedSlot
(
slot
PrivateValue
(
ptr
)
)
;
}
template
<
typename
T
>
inline
void
InitReservedSlot
(
NativeObject
*
obj
uint32_t
slot
T
*
ptr
MemoryUse
use
)
{
InitReservedSlot
(
obj
slot
ptr
sizeof
(
T
)
use
)
;
}
inline
void
InitObjectPrivate
(
NativeObject
*
obj
void
*
ptr
size_t
nbytes
MemoryUse
use
)
{
AddCellMemory
(
obj
nbytes
use
)
;
obj
-
>
initPrivate
(
ptr
)
;
}
template
<
typename
T
>
inline
void
InitObjectPrivate
(
NativeObject
*
obj
T
*
ptr
MemoryUse
use
)
{
InitObjectPrivate
(
obj
ptr
sizeof
(
T
)
use
)
;
}
}
#
endif
