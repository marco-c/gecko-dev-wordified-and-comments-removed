#
ifndef
gc_WeakMap_inl_h
#
define
gc_WeakMap_inl_h
#
include
"
gc
/
WeakMap
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
algorithm
>
#
include
<
type_traits
>
#
include
"
gc
/
GCLock
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
js
/
Prefs
.
h
"
#
include
"
js
/
TraceKind
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
SymbolType
.
h
"
#
include
"
gc
/
AtomMarking
-
inl
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
gc
/
StableCellHasher
-
inl
.
h
"
namespace
js
{
namespace
gc
:
:
detail
{
static
inline
bool
IsObject
(
JSObject
*
obj
)
{
return
true
;
}
static
inline
bool
IsObject
(
BaseScript
*
script
)
{
return
false
;
}
static
inline
bool
IsObject
(
const
JS
:
:
Value
&
value
)
{
return
value
.
isObject
(
)
;
}
static
inline
bool
IsSymbol
(
JSObject
*
obj
)
{
return
false
;
}
static
inline
bool
IsSymbol
(
BaseScript
*
script
)
{
return
false
;
}
static
inline
bool
IsSymbol
(
const
JS
:
:
Value
&
value
)
{
return
value
.
isSymbol
(
)
;
}
template
<
typename
T
>
static
CellColor
GetEffectiveColor
(
GCMarker
*
marker
const
T
&
item
)
{
static_assert
(
!
IsBarriered
<
T
>
:
:
value
"
Don
'
t
pass
wrapper
types
"
)
;
Cell
*
cell
=
ToMarkable
(
item
)
;
if
(
!
cell
-
>
isTenured
(
)
)
{
return
CellColor
:
:
Black
;
}
const
TenuredCell
&
t
=
cell
-
>
asTenured
(
)
;
if
(
!
t
.
zoneFromAnyThread
(
)
-
>
shouldMarkInZone
(
marker
-
>
markColor
(
)
)
)
{
return
CellColor
:
:
Black
;
}
MOZ_ASSERT
(
t
.
runtimeFromAnyThread
(
)
=
=
marker
-
>
runtime
(
)
)
;
return
t
.
color
(
)
;
}
template
<
typename
T
>
static
inline
JSObject
*
GetDelegate
(
const
T
&
key
)
{
static_assert
(
!
IsBarriered
<
T
>
:
:
value
"
Don
'
t
pass
wrapper
types
"
)
;
static_assert
(
!
std
:
:
is_same_v
<
T
gc
:
:
Cell
*
>
"
Don
'
t
pass
Cell
*
"
)
;
if
(
!
IsObject
(
key
)
)
{
return
nullptr
;
}
auto
*
obj
=
static_cast
<
JSObject
*
>
(
ToMarkable
(
key
)
)
;
JSObject
*
delegate
=
UncheckedUnwrapWithoutExpose
(
obj
)
;
if
(
delegate
=
=
obj
)
{
return
nullptr
;
}
return
delegate
;
}
}
template
<
class
K
class
V
class
AP
>
void
WeakMap
<
K
V
AP
>
:
:
assertMapIsSameZoneWithValue
(
const
BarrieredValue
&
v
)
{
#
ifdef
DEBUG
gc
:
:
Cell
*
cell
=
gc
:
:
ToMarkable
(
v
)
;
if
(
cell
)
{
Zone
*
cellZone
=
cell
-
>
zoneFromAnyThread
(
)
;
MOZ_ASSERT
(
zone
(
)
=
=
cellZone
|
|
cellZone
-
>
isAtomsZone
(
)
)
;
}
#
endif
}
template
<
class
K
class
V
class
AP
>
WeakMap
<
K
V
AP
>
:
:
WeakMap
(
JSContext
*
cx
JSObject
*
memOf
)
:
WeakMap
(
cx
-
>
zone
(
)
memOf
)
{
}
template
<
class
K
class
V
class
AP
>
WeakMap
<
K
V
AP
>
:
:
WeakMap
(
JS
:
:
Zone
*
zone
JSObject
*
memOf
)
:
WeakMapBase
(
memOf
zone
)
map_
(
zone
)
{
static_assert
(
std
:
:
is_same_v
<
typename
RemoveBarrier
<
K
>
:
:
Type
K
>
)
;
static_assert
(
std
:
:
is_same_v
<
typename
RemoveBarrier
<
V
>
:
:
Type
V
>
)
;
if
constexpr
(
std
:
:
is_pointer_v
<
K
>
)
{
using
NonPtrType
=
std
:
:
remove_pointer_t
<
K
>
;
static_assert
(
JS
:
:
IsCCTraceKind
(
NonPtrType
:
:
TraceKind
)
"
Object
'
s
TraceKind
should
be
added
to
CC
graph
.
"
)
;
}
zone
-
>
gcWeakMapList
(
)
.
insertFront
(
this
)
;
if
(
zone
-
>
gcState
(
)
>
Zone
:
:
Prepare
)
{
setMapColor
(
CellColor
:
:
Black
)
;
}
}
template
<
class
K
class
V
class
AP
>
WeakMap
<
K
V
AP
>
:
:
~
WeakMap
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT_IF
(
!
empty
(
)
CurrentThreadIsGCSweeping
(
)
|
|
CurrentThreadIsGCFinalizing
(
)
)
;
size_t
i
=
0
;
for
(
auto
r
=
all
(
)
;
!
r
.
empty
(
)
&
&
i
<
1000
;
r
.
popFront
(
)
i
+
+
)
{
K
key
=
r
.
front
(
)
.
key
(
)
;
MOZ_ASSERT_IF
(
gc
:
:
ToMarkable
(
key
)
!
IsInsideNursery
(
gc
:
:
ToMarkable
(
key
)
)
)
;
V
value
=
r
.
front
(
)
.
value
(
)
;
MOZ_ASSERT_IF
(
gc
:
:
ToMarkable
(
value
)
!
IsInsideNursery
(
gc
:
:
ToMarkable
(
value
)
)
)
;
}
#
endif
}
template
<
class
K
class
V
class
AP
>
bool
WeakMap
<
K
V
AP
>
:
:
markEntry
(
GCMarker
*
marker
gc
:
:
CellColor
mapColor
BarrieredKey
&
key
BarrieredValue
&
value
bool
populateWeakKeysTable
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
IsMarked
(
mapColor
)
)
;
if
(
marker
-
>
isParallelMarking
(
)
)
{
marker
-
>
runtime
(
)
-
>
gc
.
assertCurrentThreadHasLockedGC
(
)
;
}
#
endif
JSTracer
*
trc
=
marker
-
>
tracer
(
)
;
gc
:
:
Cell
*
keyCell
=
gc
:
:
ToMarkable
(
key
)
;
MOZ_ASSERT
(
keyCell
)
;
bool
keyIsSymbol
=
gc
:
:
detail
:
:
IsSymbol
(
key
.
get
(
)
)
;
MOZ_ASSERT
(
keyIsSymbol
=
=
(
keyCell
-
>
getTraceKind
(
)
=
=
JS
:
:
TraceKind
:
:
Symbol
)
)
;
if
(
keyIsSymbol
)
{
auto
*
sym
=
static_cast
<
JS
:
:
Symbol
*
>
(
keyCell
)
;
if
(
marker
-
>
runtime
(
)
-
>
gc
.
isSymbolReferencedByUncollectedZone
(
sym
)
)
{
TraceEdge
(
trc
&
key
"
WeakMap
symbol
key
"
)
;
}
}
bool
marked
=
false
;
CellColor
markColor
=
AsCellColor
(
marker
-
>
markColor
(
)
)
;
CellColor
keyColor
=
gc
:
:
detail
:
:
GetEffectiveColor
(
marker
key
.
get
(
)
)
;
JSObject
*
delegate
=
gc
:
:
detail
:
:
GetDelegate
(
key
.
get
(
)
)
;
if
(
delegate
)
{
CellColor
delegateColor
=
gc
:
:
detail
:
:
GetEffectiveColor
(
marker
delegate
)
;
CellColor
proxyPreserveColor
=
std
:
:
min
(
delegateColor
mapColor
)
;
if
(
keyColor
<
proxyPreserveColor
)
{
MOZ_ASSERT
(
markColor
>
=
proxyPreserveColor
)
;
if
(
markColor
=
=
proxyPreserveColor
)
{
TraceWeakMapKeyEdge
(
trc
zone
(
)
&
key
"
proxy
-
preserved
WeakMap
entry
key
"
)
;
MOZ_ASSERT
(
keyCell
-
>
color
(
)
>
=
proxyPreserveColor
)
;
marked
=
true
;
keyColor
=
proxyPreserveColor
;
}
}
}
gc
:
:
Cell
*
cellValue
=
gc
:
:
ToMarkable
(
value
)
;
if
(
IsMarked
(
keyColor
)
)
{
if
(
cellValue
)
{
CellColor
targetColor
=
std
:
:
min
(
mapColor
keyColor
)
;
CellColor
valueColor
=
gc
:
:
detail
:
:
GetEffectiveColor
(
marker
value
.
get
(
)
)
;
if
(
valueColor
<
targetColor
)
{
MOZ_ASSERT
(
markColor
>
=
targetColor
)
;
if
(
markColor
=
=
targetColor
)
{
TraceEdge
(
trc
&
value
"
WeakMap
entry
value
"
)
;
MOZ_ASSERT
(
cellValue
-
>
color
(
)
>
=
targetColor
)
;
marked
=
true
;
}
}
}
}
if
(
populateWeakKeysTable
)
{
MOZ_ASSERT
(
trc
-
>
weakMapAction
(
)
=
=
JS
:
:
WeakMapTraceAction
:
:
Expand
)
;
if
(
keyColor
<
mapColor
)
{
gc
:
:
TenuredCell
*
tenuredValue
=
nullptr
;
if
(
cellValue
&
&
cellValue
-
>
isTenured
(
)
)
{
tenuredValue
=
&
cellValue
-
>
asTenured
(
)
;
}
if
(
!
this
-
>
addEphemeronEdgesForEntry
(
AsMarkColor
(
mapColor
)
keyCell
delegate
tenuredValue
)
)
{
marker
-
>
abortLinearWeakMarking
(
)
;
}
}
}
return
marked
;
}
template
<
class
K
class
V
class
AP
>
void
WeakMap
<
K
V
AP
>
:
:
trace
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
isInList
(
)
)
;
TraceNullableEdge
(
trc
&
memberOf
"
WeakMap
owner
"
)
;
if
(
trc
-
>
isMarkingTracer
(
)
)
{
MOZ_ASSERT
(
trc
-
>
weakMapAction
(
)
=
=
JS
:
:
WeakMapTraceAction
:
:
Expand
)
;
GCMarker
*
marker
=
GCMarker
:
:
fromTracer
(
trc
)
;
if
(
markMap
(
marker
-
>
markColor
(
)
)
)
{
(
void
)
markEntries
(
marker
)
;
}
return
;
}
if
(
trc
-
>
weakMapAction
(
)
=
=
JS
:
:
WeakMapTraceAction
:
:
Skip
)
{
return
;
}
if
(
trc
-
>
weakMapAction
(
)
=
=
JS
:
:
WeakMapTraceAction
:
:
TraceKeysAndValues
)
{
for
(
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
TraceWeakMapKeyEdge
(
trc
zone
(
)
&
e
.
front
(
)
.
mutableKey
(
)
"
WeakMap
entry
key
"
)
;
}
}
for
(
Range
r
=
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
TraceEdge
(
trc
&
r
.
front
(
)
.
value
(
)
"
WeakMap
entry
value
"
)
;
}
}
template
<
class
K
class
V
class
AP
>
bool
WeakMap
<
K
V
AP
>
:
:
markEntries
(
GCMarker
*
marker
)
{
mozilla
:
:
Maybe
<
AutoLockGC
>
lock
;
if
(
marker
-
>
isParallelMarking
(
)
)
{
lock
.
emplace
(
marker
-
>
runtime
(
)
)
;
}
MOZ_ASSERT
(
IsMarked
(
mapColor
(
)
)
)
;
bool
markedAny
=
false
;
bool
populateWeakKeysTable
=
marker
-
>
incrementalWeakMapMarkingEnabled
|
|
marker
-
>
isWeakMarking
(
)
;
gc
:
:
CellColor
mapColor
=
this
-
>
mapColor
(
)
;
for
(
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
if
(
markEntry
(
marker
mapColor
e
.
front
(
)
.
mutableKey
(
)
e
.
front
(
)
.
value
(
)
populateWeakKeysTable
)
)
{
markedAny
=
true
;
}
}
return
markedAny
;
}
template
<
class
K
class
V
class
AP
>
void
WeakMap
<
K
V
AP
>
:
:
traceWeakEdges
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
zone
(
)
-
>
isGCSweeping
(
)
)
;
mayHaveSymbolKeys
=
false
;
mayHaveKeyDelegates
=
false
;
for
(
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
if
(
TraceWeakEdge
(
trc
&
e
.
front
(
)
.
mutableKey
(
)
"
WeakMap
key
"
)
)
{
keyWriteBarrier
(
e
.
front
(
)
.
key
(
)
)
;
}
else
{
e
.
removeFront
(
)
;
}
}
#
if
DEBUG
assertEntriesNotAboutToBeFinalized
(
)
;
#
endif
}
template
<
class
K
class
V
class
AP
>
void
WeakMap
<
K
V
AP
>
:
:
traceMappings
(
WeakMapTracer
*
tracer
)
{
for
(
Range
r
=
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
gc
:
:
Cell
*
key
=
gc
:
:
ToMarkable
(
r
.
front
(
)
.
key
(
)
)
;
gc
:
:
Cell
*
value
=
gc
:
:
ToMarkable
(
r
.
front
(
)
.
value
(
)
)
;
if
(
key
&
&
value
)
{
tracer
-
>
trace
(
memberOf
JS
:
:
GCCellPtr
(
r
.
front
(
)
.
key
(
)
.
get
(
)
)
JS
:
:
GCCellPtr
(
r
.
front
(
)
.
value
(
)
.
get
(
)
)
)
;
}
}
}
template
<
class
K
class
V
class
AP
>
bool
WeakMap
<
K
V
AP
>
:
:
findSweepGroupEdges
(
Zone
*
atomsZone
)
{
#
ifdef
DEBUG
if
(
!
mayHaveSymbolKeys
|
|
!
mayHaveKeyDelegates
)
{
for
(
Range
r
=
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
const
K
&
key
=
r
.
front
(
)
.
key
(
)
;
MOZ_ASSERT_IF
(
!
mayHaveKeyDelegates
!
gc
:
:
detail
:
:
GetDelegate
(
key
)
)
;
MOZ_ASSERT_IF
(
!
mayHaveSymbolKeys
!
gc
:
:
detail
:
:
IsSymbol
(
key
)
)
;
}
}
#
endif
if
(
mayHaveSymbolKeys
)
{
MOZ_ASSERT
(
JS
:
:
Prefs
:
:
experimental_symbols_as_weakmap_keys
(
)
)
;
if
(
atomsZone
-
>
isGCMarking
(
)
)
{
if
(
!
atomsZone
-
>
addSweepGroupEdgeTo
(
zone
(
)
)
)
{
return
false
;
}
}
}
if
(
mayHaveKeyDelegates
)
{
for
(
Range
r
=
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
const
K
&
key
=
r
.
front
(
)
.
key
(
)
;
JSObject
*
delegate
=
gc
:
:
detail
:
:
GetDelegate
(
key
)
;
if
(
delegate
)
{
Zone
*
delegateZone
=
delegate
-
>
zone
(
)
;
gc
:
:
Cell
*
keyCell
=
gc
:
:
ToMarkable
(
key
)
;
MOZ_ASSERT
(
keyCell
)
;
Zone
*
keyZone
=
keyCell
-
>
zone
(
)
;
if
(
delegateZone
!
=
keyZone
&
&
delegateZone
-
>
isGCMarking
(
)
&
&
keyZone
-
>
isGCMarking
(
)
)
{
if
(
!
delegateZone
-
>
addSweepGroupEdgeTo
(
keyZone
)
)
{
return
false
;
}
}
}
}
}
return
true
;
}
template
<
class
K
class
V
class
AP
>
size_t
WeakMap
<
K
V
AP
>
:
:
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
mallocSizeOf
(
this
)
+
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
}
#
if
DEBUG
template
<
class
K
class
V
class
AP
>
void
WeakMap
<
K
V
AP
>
:
:
assertEntriesNotAboutToBeFinalized
(
)
{
for
(
Range
r
=
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
K
k
=
r
.
front
(
)
.
key
(
)
;
MOZ_ASSERT
(
!
gc
:
:
IsAboutToBeFinalizedUnbarriered
(
k
)
)
;
JSObject
*
delegate
=
gc
:
:
detail
:
:
GetDelegate
(
k
)
;
if
(
delegate
)
{
MOZ_ASSERT
(
!
gc
:
:
IsAboutToBeFinalizedUnbarriered
(
delegate
)
"
weakmap
marking
depends
on
a
key
tracing
its
delegate
"
)
;
}
MOZ_ASSERT
(
!
gc
:
:
IsAboutToBeFinalized
(
r
.
front
(
)
.
value
(
)
)
)
;
}
}
#
endif
#
ifdef
JS_GC_ZEAL
template
<
class
K
class
V
class
AP
>
bool
WeakMap
<
K
V
AP
>
:
:
checkMarking
(
)
const
{
bool
ok
=
true
;
for
(
Range
r
=
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
gc
:
:
Cell
*
key
=
gc
:
:
ToMarkable
(
r
.
front
(
)
.
key
(
)
)
;
MOZ_RELEASE_ASSERT
(
key
)
;
gc
:
:
Cell
*
value
=
gc
:
:
ToMarkable
(
r
.
front
(
)
.
value
(
)
)
;
if
(
!
gc
:
:
CheckWeakMapEntryMarking
(
this
key
value
)
)
{
ok
=
false
;
}
}
return
ok
;
}
#
endif
#
ifdef
JSGC_HASH_TABLE_CHECKS
template
<
class
K
class
V
class
AP
>
void
WeakMap
<
K
V
AP
>
:
:
checkAfterMovingGC
(
)
const
{
for
(
Range
r
=
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
gc
:
:
Cell
*
key
=
gc
:
:
ToMarkable
(
r
.
front
(
)
.
key
(
)
)
;
gc
:
:
Cell
*
value
=
gc
:
:
ToMarkable
(
r
.
front
(
)
.
value
(
)
)
;
CheckGCThingAfterMovingGC
(
key
)
;
if
(
!
allowKeysInOtherZones
(
)
)
{
Zone
*
keyZone
=
key
-
>
zoneFromAnyThread
(
)
;
MOZ_RELEASE_ASSERT
(
keyZone
=
=
zone
(
)
|
|
keyZone
-
>
isAtomsZone
(
)
)
;
}
CheckGCThingAfterMovingGC
(
value
zone
(
)
)
;
auto
ptr
=
lookupUnbarriered
(
r
.
front
(
)
.
key
(
)
)
;
MOZ_RELEASE_ASSERT
(
ptr
.
found
(
)
&
&
&
*
ptr
=
=
&
r
.
front
(
)
)
;
}
}
#
endif
static
MOZ_ALWAYS_INLINE
bool
CanBeHeldWeakly
(
Value
value
)
{
if
(
value
.
isObject
(
)
)
{
return
true
;
}
bool
symbolsAsWeakMapKeysEnabled
=
JS
:
:
Prefs
:
:
experimental_symbols_as_weakmap_keys
(
)
;
if
(
symbolsAsWeakMapKeysEnabled
&
&
value
.
isSymbol
(
)
&
&
value
.
toSymbol
(
)
-
>
code
(
)
!
=
JS
:
:
SymbolCode
:
:
InSymbolRegistry
)
{
return
true
;
}
return
false
;
}
inline
HashNumber
GetSymbolHash
(
JS
:
:
Symbol
*
sym
)
{
return
sym
-
>
hash
(
)
;
}
}
#
endif
