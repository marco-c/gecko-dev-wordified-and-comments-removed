#
ifndef
gc_WeakMap_inl_h
#
define
gc_WeakMap_inl_h
#
include
"
gc
/
WeakMap
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
algorithm
>
#
include
<
type_traits
>
#
include
"
gc
/
Zone
.
h
"
#
include
"
js
/
TraceKind
.
h
"
#
include
"
vm
/
JSContext
.
h
"
namespace
js
{
namespace
gc
{
template
<
typename
T
>
inline
Cell
*
ToMarkable
(
WriteBarriered
<
T
>
*
thingp
)
{
return
ToMarkable
(
thingp
-
>
get
(
)
)
;
}
namespace
detail
{
template
<
typename
T
>
static
T
ExtractUnbarriered
(
const
WriteBarriered
<
T
>
&
v
)
{
return
v
.
get
(
)
;
}
template
<
typename
T
>
static
T
*
ExtractUnbarriered
(
T
*
v
)
{
return
v
;
}
template
<
typename
T
>
static
CellColor
GetEffectiveColor
(
JSRuntime
*
rt
const
T
&
item
)
{
Cell
*
cell
=
ToMarkable
(
item
)
;
if
(
!
cell
-
>
isTenured
(
)
)
{
return
CellColor
:
:
Black
;
}
const
TenuredCell
&
t
=
cell
-
>
asTenured
(
)
;
if
(
rt
!
=
t
.
runtimeFromAnyThread
(
)
)
{
return
CellColor
:
:
Black
;
}
if
(
!
t
.
zoneFromAnyThread
(
)
-
>
shouldMarkInZone
(
)
)
{
return
CellColor
:
:
Black
;
}
return
cell
-
>
color
(
)
;
}
static
MOZ_MAYBE_UNUSED
JSObject
*
GetDelegateInternal
(
gc
:
:
Cell
*
key
)
{
return
nullptr
;
}
static
JSObject
*
GetDelegateInternal
(
JSObject
*
key
)
{
JSObject
*
delegate
=
UncheckedUnwrapWithoutExpose
(
key
)
;
return
(
key
=
=
delegate
)
?
nullptr
:
delegate
;
}
template
<
typename
T
>
static
inline
JSObject
*
GetDelegate
(
const
T
&
key
)
{
return
GetDelegateInternal
(
ExtractUnbarriered
(
key
)
)
;
}
template
<
>
inline
JSObject
*
GetDelegate
(
gc
:
:
Cell
*
const
&
)
=
delete
;
}
}
template
<
class
K
class
V
>
void
WeakMap
<
K
V
>
:
:
assertMapIsSameZoneWithValue
(
const
V
&
v
)
{
#
ifdef
DEBUG
gc
:
:
Cell
*
cell
=
gc
:
:
ToMarkable
(
v
)
;
if
(
cell
)
{
Zone
*
cellZone
=
cell
-
>
zoneFromAnyThread
(
)
;
MOZ_ASSERT
(
zone
(
)
=
=
cellZone
|
|
cellZone
-
>
isAtomsZone
(
)
)
;
}
#
endif
}
template
<
class
K
class
V
>
WeakMap
<
K
V
>
:
:
WeakMap
(
JSContext
*
cx
JSObject
*
memOf
)
:
Base
(
cx
-
>
zone
(
)
)
WeakMapBase
(
memOf
cx
-
>
zone
(
)
)
{
using
ElemType
=
typename
K
:
:
ElementType
;
using
NonPtrType
=
std
:
:
remove_pointer_t
<
ElemType
>
;
static_assert
(
JS
:
:
IsCCTraceKind
(
NonPtrType
:
:
TraceKind
)
"
Object
'
s
TraceKind
should
be
added
to
CC
graph
.
"
)
;
zone
(
)
-
>
gcWeakMapList
(
)
.
insertFront
(
this
)
;
if
(
zone
(
)
-
>
wasGCStarted
(
)
)
{
mapColor
=
CellColor
:
:
Black
;
}
}
template
<
class
K
class
V
>
void
WeakMap
<
K
V
>
:
:
markKey
(
GCMarker
*
marker
gc
:
:
Cell
*
markedCell
gc
:
:
Cell
*
origKey
)
{
#
if
DEBUG
if
(
!
mapColor
)
{
fprintf
(
stderr
"
markKey
called
on
an
unmarked
map
%
p
"
this
)
;
Zone
*
zone
=
markedCell
-
>
asTenured
(
)
.
zoneFromAnyThread
(
)
;
fprintf
(
stderr
"
markedCell
=
%
p
from
zone
%
p
state
%
d
mark
%
d
\
n
"
markedCell
zone
zone
-
>
gcState
(
)
int
(
debug
:
:
GetMarkInfo
(
markedCell
)
)
)
;
zone
=
origKey
-
>
asTenured
(
)
.
zoneFromAnyThread
(
)
;
fprintf
(
stderr
"
origKey
=
%
p
from
zone
%
p
state
%
d
mark
%
d
\
n
"
origKey
zone
zone
-
>
gcState
(
)
int
(
debug
:
:
GetMarkInfo
(
markedCell
)
)
)
;
if
(
memberOf
)
{
zone
=
memberOf
-
>
asTenured
(
)
.
zoneFromAnyThread
(
)
;
fprintf
(
stderr
"
memberOf
=
%
p
from
zone
%
p
state
%
d
mark
%
d
\
n
"
memberOf
.
get
(
)
zone
zone
-
>
gcState
(
)
int
(
debug
:
:
GetMarkInfo
(
memberOf
.
get
(
)
)
)
)
;
}
}
#
endif
MOZ_ASSERT
(
mapColor
)
;
Ptr
p
=
Base
:
:
lookup
(
static_cast
<
Lookup
>
(
origKey
)
)
;
MOZ_ASSERT
(
p
.
found
(
)
)
;
mozilla
:
:
DebugOnly
<
gc
:
:
Cell
*
>
oldKey
=
gc
:
:
ToMarkable
(
p
-
>
key
(
)
)
;
MOZ_ASSERT
(
(
markedCell
=
=
oldKey
)
|
|
(
markedCell
=
=
gc
:
:
detail
:
:
GetDelegate
(
p
-
>
key
(
)
)
)
)
;
markEntry
(
marker
p
-
>
mutableKey
(
)
p
-
>
value
(
)
)
;
MOZ_ASSERT
(
oldKey
=
=
gc
:
:
ToMarkable
(
p
-
>
key
(
)
)
"
no
moving
GC
"
)
;
}
template
<
class
K
class
V
>
bool
WeakMap
<
K
V
>
:
:
markEntry
(
GCMarker
*
marker
K
&
key
V
&
value
)
{
bool
marked
=
false
;
JSRuntime
*
rt
=
zone
(
)
-
>
runtimeFromAnyThread
(
)
;
CellColor
keyColor
=
gc
:
:
detail
:
:
GetEffectiveColor
(
rt
key
)
;
JSObject
*
delegate
=
gc
:
:
detail
:
:
GetDelegate
(
key
)
;
if
(
delegate
)
{
CellColor
delegateColor
=
gc
:
:
detail
:
:
GetEffectiveColor
(
rt
delegate
)
;
CellColor
proxyPreserveColor
=
std
:
:
min
(
delegateColor
mapColor
)
;
if
(
keyColor
<
proxyPreserveColor
)
{
gc
:
:
AutoSetMarkColor
autoColor
(
*
marker
proxyPreserveColor
)
;
TraceWeakMapKeyEdge
(
marker
zone
(
)
&
key
"
proxy
-
preserved
WeakMap
entry
key
"
)
;
MOZ_ASSERT
(
key
-
>
color
(
)
>
=
proxyPreserveColor
)
;
marked
=
true
;
keyColor
=
proxyPreserveColor
;
}
}
if
(
keyColor
)
{
gc
:
:
Cell
*
cellValue
=
gc
:
:
ToMarkable
(
&
value
)
;
if
(
cellValue
)
{
gc
:
:
AutoSetMarkColor
autoColor
(
*
marker
std
:
:
min
(
mapColor
keyColor
)
)
;
CellColor
valueColor
=
gc
:
:
detail
:
:
GetEffectiveColor
(
rt
cellValue
)
;
if
(
valueColor
<
marker
-
>
markColor
(
)
)
{
TraceEdge
(
marker
&
value
"
WeakMap
entry
value
"
)
;
MOZ_ASSERT
(
cellValue
-
>
color
(
)
>
=
std
:
:
min
(
mapColor
keyColor
)
)
;
marked
=
true
;
}
}
}
return
marked
;
}
template
<
class
K
class
V
>
void
WeakMap
<
K
V
>
:
:
trace
(
JSTracer
*
trc
)
{
MOZ_ASSERT_IF
(
JS
:
:
RuntimeHeapIsBusy
(
)
isInList
(
)
)
;
TraceNullableEdge
(
trc
&
memberOf
"
WeakMap
owner
"
)
;
if
(
trc
-
>
isMarkingTracer
(
)
)
{
MOZ_ASSERT
(
trc
-
>
weakMapAction
(
)
=
=
JS
:
:
WeakMapTraceAction
:
:
Expand
)
;
auto
marker
=
GCMarker
:
:
fromTracer
(
trc
)
;
if
(
mapColor
<
marker
-
>
markColor
(
)
)
{
mapColor
=
marker
-
>
markColor
(
)
;
mozilla
:
:
Unused
<
<
markEntries
(
marker
)
;
}
return
;
}
if
(
trc
-
>
weakMapAction
(
)
=
=
JS
:
:
WeakMapTraceAction
:
:
Skip
)
{
return
;
}
if
(
trc
-
>
weakMapAction
(
)
=
=
JS
:
:
WeakMapTraceAction
:
:
TraceKeysAndValues
)
{
for
(
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
TraceWeakMapKeyEdge
(
trc
zone
(
)
&
e
.
front
(
)
.
mutableKey
(
)
"
WeakMap
entry
key
"
)
;
}
}
for
(
Range
r
=
Base
:
:
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
TraceEdge
(
trc
&
r
.
front
(
)
.
value
(
)
"
WeakMap
entry
value
"
)
;
}
}
template
<
class
K
class
V
>
void
WeakMap
<
K
V
>
:
:
forgetKey
(
UnbarrieredKey
key
)
{
if
(
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
{
JSRuntime
*
rt
=
zone
(
)
-
>
runtimeFromMainThread
(
)
;
if
(
JSObject
*
delegate
=
js
:
:
gc
:
:
detail
:
:
GetDelegate
(
key
)
)
{
js
:
:
gc
:
:
WeakKeyTable
&
weakKeys
=
delegate
-
>
zone
(
)
-
>
gcWeakKeys
(
delegate
)
;
rt
-
>
gc
.
marker
.
forgetWeakKey
(
weakKeys
this
delegate
key
)
;
}
else
{
js
:
:
gc
:
:
WeakKeyTable
&
weakKeys
=
key
-
>
zone
(
)
-
>
gcWeakKeys
(
key
)
;
rt
-
>
gc
.
marker
.
forgetWeakKey
(
weakKeys
this
key
key
)
;
}
}
}
template
<
class
K
class
V
>
void
WeakMap
<
K
V
>
:
:
clear
(
)
{
Base
:
:
clear
(
)
;
JSRuntime
*
rt
=
zone
(
)
-
>
runtimeFromMainThread
(
)
;
if
(
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
{
rt
-
>
gc
.
marker
.
forgetWeakMap
(
this
zone
(
)
)
;
}
}
inline
void
WeakMapBase
:
:
addWeakEntry
(
GCMarker
*
marker
gc
:
:
Cell
*
key
const
gc
:
:
WeakMarkable
&
markable
)
{
auto
&
weakKeys
=
key
-
>
zone
(
)
-
>
gcWeakKeys
(
key
)
;
auto
p
=
weakKeys
.
get
(
key
)
;
if
(
p
)
{
gc
:
:
WeakEntryVector
&
weakEntries
=
p
-
>
value
;
if
(
!
weakEntries
.
append
(
markable
)
)
{
marker
-
>
abortLinearWeakMarking
(
)
;
}
}
else
{
gc
:
:
WeakEntryVector
weakEntries
;
MOZ_ALWAYS_TRUE
(
weakEntries
.
append
(
markable
)
)
;
if
(
!
weakKeys
.
put
(
key
std
:
:
move
(
weakEntries
)
)
)
{
marker
-
>
abortLinearWeakMarking
(
)
;
}
}
}
template
<
class
K
class
V
>
bool
WeakMap
<
K
V
>
:
:
markEntries
(
GCMarker
*
marker
)
{
MOZ_ASSERT
(
mapColor
)
;
bool
markedAny
=
false
;
for
(
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
if
(
markEntry
(
marker
e
.
front
(
)
.
mutableKey
(
)
e
.
front
(
)
.
value
(
)
)
)
{
markedAny
=
true
;
}
if
(
!
marker
-
>
incrementalWeakMapMarkingEnabled
&
&
!
marker
-
>
isWeakMarking
(
)
)
{
continue
;
}
JSRuntime
*
rt
=
zone
(
)
-
>
runtimeFromAnyThread
(
)
;
CellColor
keyColor
=
gc
:
:
detail
:
:
GetEffectiveColor
(
rt
e
.
front
(
)
.
key
(
)
.
get
(
)
)
;
if
(
keyColor
<
mapColor
)
{
MOZ_ASSERT
(
marker
-
>
weakMapAction
(
)
=
=
JS
:
:
WeakMapTraceAction
:
:
Expand
)
;
gc
:
:
Cell
*
weakKey
=
gc
:
:
detail
:
:
ExtractUnbarriered
(
e
.
front
(
)
.
key
(
)
)
;
gc
:
:
WeakMarkable
markable
(
this
weakKey
)
;
if
(
JSObject
*
delegate
=
gc
:
:
detail
:
:
GetDelegate
(
e
.
front
(
)
.
key
(
)
)
)
{
addWeakEntry
(
marker
delegate
markable
)
;
}
else
{
addWeakEntry
(
marker
weakKey
markable
)
;
}
}
}
return
markedAny
;
}
template
<
class
K
class
V
>
void
WeakMap
<
K
V
>
:
:
postSeverDelegate
(
GCMarker
*
marker
JSObject
*
key
)
{
if
(
mapColor
)
{
gc
:
:
WeakMarkable
markable
(
this
key
)
;
addWeakEntry
(
marker
key
markable
)
;
}
}
template
<
class
K
class
V
>
void
WeakMap
<
K
V
>
:
:
postRestoreDelegate
(
GCMarker
*
marker
JSObject
*
key
JSObject
*
delegate
)
{
if
(
mapColor
)
{
gc
:
:
WeakMarkable
markable
(
this
key
)
;
addWeakEntry
(
marker
delegate
markable
)
;
}
}
template
<
class
K
class
V
>
void
WeakMap
<
K
V
>
:
:
sweep
(
)
{
for
(
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
if
(
gc
:
:
IsAboutToBeFinalized
(
&
e
.
front
(
)
.
mutableKey
(
)
)
)
{
e
.
removeFront
(
)
;
}
}
#
if
DEBUG
assertEntriesNotAboutToBeFinalized
(
)
;
#
endif
}
template
<
class
K
class
V
>
void
WeakMap
<
K
V
>
:
:
traceMappings
(
WeakMapTracer
*
tracer
)
{
for
(
Range
r
=
Base
:
:
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
gc
:
:
Cell
*
key
=
gc
:
:
ToMarkable
(
r
.
front
(
)
.
key
(
)
)
;
gc
:
:
Cell
*
value
=
gc
:
:
ToMarkable
(
r
.
front
(
)
.
value
(
)
)
;
if
(
key
&
&
value
)
{
tracer
-
>
trace
(
memberOf
JS
:
:
GCCellPtr
(
r
.
front
(
)
.
key
(
)
.
get
(
)
)
JS
:
:
GCCellPtr
(
r
.
front
(
)
.
value
(
)
.
get
(
)
)
)
;
}
}
}
template
<
class
K
class
V
>
bool
WeakMap
<
K
V
>
:
:
findSweepGroupEdges
(
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
for
(
Range
r
=
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
const
K
&
key
=
r
.
front
(
)
.
key
(
)
;
JSObject
*
delegate
=
gc
:
:
detail
:
:
GetDelegate
(
key
)
;
if
(
!
delegate
)
{
continue
;
}
Zone
*
delegateZone
=
delegate
-
>
zone
(
)
;
Zone
*
keyZone
=
key
-
>
zone
(
)
;
if
(
delegateZone
!
=
keyZone
&
&
delegateZone
-
>
isGCMarking
(
)
&
&
keyZone
-
>
isGCMarking
(
)
)
{
if
(
!
delegateZone
-
>
addSweepGroupEdgeTo
(
keyZone
)
)
{
return
false
;
}
}
}
return
true
;
}
#
if
DEBUG
template
<
class
K
class
V
>
void
WeakMap
<
K
V
>
:
:
assertEntriesNotAboutToBeFinalized
(
)
{
for
(
Range
r
=
Base
:
:
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
auto
k
=
gc
:
:
detail
:
:
ExtractUnbarriered
(
r
.
front
(
)
.
key
(
)
)
;
MOZ_ASSERT
(
!
gc
:
:
IsAboutToBeFinalizedUnbarriered
(
&
k
)
)
;
JSObject
*
delegate
=
gc
:
:
detail
:
:
GetDelegate
(
k
)
;
if
(
delegate
)
{
MOZ_ASSERT
(
!
gc
:
:
IsAboutToBeFinalizedUnbarriered
(
&
delegate
)
"
weakmap
marking
depends
on
a
key
tracing
its
delegate
"
)
;
}
MOZ_ASSERT
(
!
gc
:
:
IsAboutToBeFinalized
(
&
r
.
front
(
)
.
value
(
)
)
)
;
MOZ_ASSERT
(
k
=
=
r
.
front
(
)
.
key
(
)
)
;
}
}
#
endif
#
ifdef
JS_GC_ZEAL
template
<
class
K
class
V
>
bool
WeakMap
<
K
V
>
:
:
checkMarking
(
)
const
{
bool
ok
=
true
;
for
(
Range
r
=
Base
:
:
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
gc
:
:
Cell
*
key
=
gc
:
:
ToMarkable
(
r
.
front
(
)
.
key
(
)
)
;
gc
:
:
Cell
*
value
=
gc
:
:
ToMarkable
(
r
.
front
(
)
.
value
(
)
)
;
if
(
key
&
&
value
)
{
if
(
!
gc
:
:
CheckWeakMapEntryMarking
(
this
key
value
)
)
{
ok
=
false
;
}
}
}
return
ok
;
}
#
endif
}
#
endif
