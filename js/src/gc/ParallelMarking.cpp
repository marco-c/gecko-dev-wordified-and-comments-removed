#
include
"
gc
/
ParallelMarking
.
h
"
#
include
"
gc
/
GCLock
.
h
"
#
include
"
gc
/
ParallelWork
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
ParallelMarker
:
:
ParallelMarker
(
GCRuntime
*
gc
)
:
gc
(
gc
)
{
}
size_t
ParallelMarker
:
:
workerCount
(
)
const
{
return
gc
-
>
markers
.
length
(
)
;
}
bool
ParallelMarker
:
:
mark
(
SliceBudget
&
sliceBudget
)
{
if
(
markOneColor
(
MarkColor
:
:
Black
sliceBudget
)
=
=
NotFinished
)
{
return
false
;
}
MOZ_ASSERT
(
!
hasWork
(
MarkColor
:
:
Black
)
)
;
if
(
markOneColor
(
MarkColor
:
:
Gray
sliceBudget
)
=
=
NotFinished
)
{
return
false
;
}
MOZ_ASSERT
(
!
hasWork
(
MarkColor
:
:
Gray
)
)
;
if
(
gc
-
>
hasDelayedMarking
(
)
)
{
gc
-
>
markAllDelayedChildren
(
ReportMarkTime
)
;
}
return
true
;
}
bool
ParallelMarker
:
:
markOneColor
(
MarkColor
color
SliceBudget
&
sliceBudget
)
{
if
(
!
hasWork
(
color
)
)
{
return
true
;
}
MOZ_ASSERT
(
workerCount
(
)
<
=
MaxParallelWorkers
)
;
mozilla
:
:
Maybe
<
ParallelMarkTask
>
tasks
[
MaxParallelWorkers
]
;
for
(
size_t
i
=
0
;
i
<
workerCount
(
)
;
i
+
+
)
{
GCMarker
*
marker
=
gc
-
>
markers
[
i
]
.
get
(
)
;
tasks
[
i
]
.
emplace
(
this
marker
color
sliceBudget
)
;
if
(
!
marker
-
>
hasEntries
(
color
)
&
&
gc
-
>
marker
(
)
.
hasEntries
(
color
)
)
{
marker
-
>
stealWorkFrom
(
&
gc
-
>
marker
(
)
)
;
}
}
{
AutoLockGC
lock
(
gc
)
;
activeTasks
=
0
;
for
(
size_t
i
=
0
;
i
<
workerCount
(
)
;
i
+
+
)
{
ParallelMarkTask
&
task
=
*
tasks
[
i
]
;
if
(
task
.
hasWork
(
)
)
{
incActiveTasks
(
&
task
lock
)
;
}
}
}
{
AutoLockHelperThreadState
lock
;
for
(
size_t
i
=
0
;
i
<
workerCount
(
)
;
i
+
+
)
{
gc
-
>
startTask
(
*
tasks
[
i
]
lock
)
;
}
for
(
size_t
i
=
0
;
i
<
workerCount
(
)
;
i
+
+
)
{
gc
-
>
joinTask
(
*
tasks
[
i
]
lock
)
;
}
}
#
ifdef
DEBUG
{
AutoLockGC
lock
(
gc
)
;
MOZ_ASSERT
(
waitingTasks
.
ref
(
)
.
isEmpty
(
)
)
;
MOZ_ASSERT
(
waitingTaskCount
=
=
0
)
;
MOZ_ASSERT
(
activeTasks
=
=
0
)
;
}
#
endif
return
!
hasWork
(
color
)
;
}
bool
ParallelMarker
:
:
hasWork
(
MarkColor
color
)
const
{
for
(
const
auto
&
marker
:
gc
-
>
markers
)
{
if
(
marker
-
>
hasEntries
(
color
)
)
{
return
true
;
}
}
return
false
;
}
ParallelMarkTask
:
:
ParallelMarkTask
(
ParallelMarker
*
pm
GCMarker
*
marker
MarkColor
color
const
SliceBudget
&
budget
)
:
GCParallelTask
(
pm
-
>
gc
gcstats
:
:
PhaseKind
:
:
MARK
GCUse
:
:
Marking
)
pm
(
pm
)
marker
(
marker
)
color
(
*
marker
color
)
budget
(
budget
)
{
marker
-
>
enterParallelMarkingMode
(
pm
)
;
}
ParallelMarkTask
:
:
~
ParallelMarkTask
(
)
{
MOZ_ASSERT
(
!
isWaiting
.
refNoCheck
(
)
)
;
marker
-
>
leaveParallelMarkingMode
(
)
;
}
bool
ParallelMarkTask
:
:
hasWork
(
)
const
{
return
marker
-
>
hasEntries
(
marker
-
>
markColor
(
)
)
;
}
void
ParallelMarkTask
:
:
run
(
AutoLockHelperThreadState
&
lock
)
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
{
AutoLockGC
gcLock
(
pm
-
>
gc
)
;
markOrSteal
(
gcLock
)
;
MOZ_ASSERT
(
!
isWaiting
)
;
if
(
hasWork
(
)
)
{
pm
-
>
decActiveTasks
(
this
gcLock
)
;
}
}
}
void
ParallelMarkTask
:
:
markOrSteal
(
AutoLockGC
&
lock
)
{
for
(
;
;
)
{
if
(
hasWork
(
)
&
&
!
tryMarking
(
lock
)
)
{
return
;
}
while
(
!
hasWork
(
)
)
{
if
(
!
tryStealing
(
lock
)
)
{
return
;
}
}
}
}
bool
ParallelMarkTask
:
:
tryMarking
(
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
hasWork
(
)
)
;
MOZ_ASSERT
(
marker
-
>
isParallelMarking
(
)
)
;
{
AutoUnlockGC
unlock
(
lock
)
;
marker
-
>
markCurrentColorInParallel
(
budget
)
;
}
if
(
!
hasWork
(
)
)
{
pm
-
>
decActiveTasks
(
this
lock
)
;
}
return
!
budget
.
isOverBudget
(
)
;
}
bool
ParallelMarkTask
:
:
tryStealing
(
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
!
hasWork
(
)
)
;
if
(
!
pm
-
>
hasActiveTasks
(
lock
)
)
{
return
false
;
}
budget
.
stepAndForceCheck
(
)
;
if
(
budget
.
isOverBudget
(
)
)
{
return
false
;
}
waitUntilResumed
(
lock
)
;
if
(
hasWork
(
)
)
{
pm
-
>
incActiveTasks
(
this
lock
)
;
}
return
true
;
}
void
ParallelMarkTask
:
:
waitUntilResumed
(
AutoLockGC
&
lock
)
{
pm
-
>
addTaskToWaitingList
(
this
lock
)
;
MOZ_ASSERT
(
!
isWaiting
)
;
isWaiting
=
true
;
do
{
MOZ_ASSERT
(
pm
-
>
hasActiveTasks
(
lock
)
)
;
resumed
.
wait
(
lock
.
guard
(
)
)
;
}
while
(
isWaiting
)
;
MOZ_ASSERT
(
!
pm
-
>
isTaskInWaitingList
(
this
lock
)
)
;
}
void
ParallelMarkTask
:
:
resume
(
const
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
isWaiting
)
;
isWaiting
=
false
;
resumed
.
notify_all
(
)
;
}
void
ParallelMarker
:
:
addTaskToWaitingList
(
ParallelMarkTask
*
task
const
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
!
task
-
>
hasWork
(
)
)
;
MOZ_ASSERT
(
hasActiveTasks
(
lock
)
)
;
MOZ_ASSERT
(
!
isTaskInWaitingList
(
task
lock
)
)
;
MOZ_ASSERT
(
waitingTaskCount
<
workerCount
(
)
-
1
)
;
waitingTasks
.
ref
(
)
.
pushBack
(
task
)
;
waitingTaskCount
+
+
;
}
#
ifdef
DEBUG
bool
ParallelMarker
:
:
isTaskInWaitingList
(
const
ParallelMarkTask
*
task
const
AutoLockGC
&
lock
)
const
{
return
const_cast
<
ParallelMarkTaskList
&
>
(
waitingTasks
.
ref
(
)
)
.
ElementProbablyInList
(
const_cast
<
ParallelMarkTask
*
>
(
task
)
)
;
}
#
endif
void
ParallelMarker
:
:
incActiveTasks
(
ParallelMarkTask
*
task
const
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
task
-
>
hasWork
(
)
)
;
MOZ_ASSERT
(
activeTasks
<
workerCount
(
)
)
;
activeTasks
+
+
;
}
void
ParallelMarker
:
:
decActiveTasks
(
ParallelMarkTask
*
task
const
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
activeTasks
!
=
0
)
;
activeTasks
-
-
;
if
(
activeTasks
=
=
0
)
{
activeTasksAvailable
.
ref
(
)
.
notify_all
(
)
;
while
(
!
waitingTasks
.
ref
(
)
.
isEmpty
(
)
)
{
ParallelMarkTask
*
task
=
waitingTasks
.
ref
(
)
.
popFront
(
)
;
MOZ_ASSERT
(
waitingTaskCount
!
=
0
)
;
waitingTaskCount
-
-
;
task
-
>
resume
(
lock
)
;
}
}
}
void
ParallelMarker
:
:
stealWorkFrom
(
GCMarker
*
victim
)
{
AutoLockGC
lock
(
gc
)
;
if
(
waitingTaskCount
=
=
0
)
{
return
;
}
ParallelMarkTask
*
task
=
waitingTasks
.
ref
(
)
.
popFront
(
)
;
waitingTaskCount
-
-
;
MOZ_ASSERT
(
task
-
>
isWaiting
)
;
task
-
>
marker
-
>
stealWorkFrom
(
victim
)
;
task
-
>
resume
(
lock
)
;
}
