#
include
"
gc
/
ParallelMarking
.
h
"
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
gc
/
GCLock
.
h
"
#
include
"
vm
/
GeckoProfiler
.
h
"
#
include
"
vm
/
HelperThreadState
.
h
"
#
include
"
vm
/
Runtime
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
mozilla
:
:
TimeDuration
;
using
mozilla
:
:
TimeStamp
;
using
JS
:
:
SliceBudget
;
class
AutoAddTimeDuration
{
TimeStamp
start_
;
TimeDuration
&
result_
;
public
:
explicit
AutoAddTimeDuration
(
TimeDuration
&
result
)
:
start_
(
TimeStamp
:
:
Now
(
)
)
result_
(
result
)
{
}
TimeStamp
start
(
)
const
{
return
start_
;
}
~
AutoAddTimeDuration
(
)
{
result_
+
=
TimeSince
(
start_
)
;
}
}
;
ParallelMarker
:
:
ParallelMarker
(
GCRuntime
*
gc
)
:
gc
(
gc
)
{
}
size_t
ParallelMarker
:
:
workerCount
(
)
const
{
return
gc
-
>
markers
.
length
(
)
;
}
bool
ParallelMarker
:
:
mark
(
const
SliceBudget
&
sliceBudget
)
{
MOZ_ASSERT
(
workerCount
(
)
<
=
gc
-
>
getMaxParallelThreads
(
)
)
;
if
(
markOneColor
(
MarkColor
:
:
Black
sliceBudget
)
=
=
NotFinished
)
{
return
false
;
}
MOZ_ASSERT
(
!
hasWork
(
MarkColor
:
:
Black
)
)
;
if
(
markOneColor
(
MarkColor
:
:
Gray
sliceBudget
)
=
=
NotFinished
)
{
return
false
;
}
MOZ_ASSERT
(
!
hasWork
(
MarkColor
:
:
Gray
)
)
;
if
(
gc
-
>
hasDelayedMarking
(
)
)
{
gc
-
>
markAllDelayedChildren
(
ReportMarkTime
)
;
}
return
true
;
}
bool
ParallelMarker
:
:
markOneColor
(
MarkColor
color
const
SliceBudget
&
sliceBudget
)
{
if
(
!
hasWork
(
color
)
)
{
return
true
;
}
gcstats
:
:
AutoPhase
ap
(
gc
-
>
stats
(
)
gcstats
:
:
PhaseKind
:
:
PARALLEL_MARK
)
;
MOZ_ASSERT
(
workerCount
(
)
<
=
MaxParallelWorkers
)
;
mozilla
:
:
Maybe
<
ParallelMarkTask
>
tasks
[
MaxParallelWorkers
]
;
for
(
size_t
i
=
0
;
i
<
workerCount
(
)
;
i
+
+
)
{
GCMarker
*
marker
=
gc
-
>
markers
[
i
]
.
get
(
)
;
tasks
[
i
]
.
emplace
(
this
marker
color
i
sliceBudget
)
;
if
(
!
marker
-
>
hasEntriesForCurrentColor
(
)
&
&
gc
-
>
marker
(
)
.
canDonateWork
(
)
)
{
GCMarker
:
:
moveWork
(
marker
&
gc
-
>
marker
(
)
false
)
;
}
}
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
!
hasActiveTasks
(
lock
)
)
;
for
(
size_t
i
=
0
;
i
<
workerCount
(
)
;
i
+
+
)
{
ParallelMarkTask
&
task
=
*
tasks
[
i
]
;
if
(
task
.
hasWork
(
)
)
{
setTaskActive
(
&
task
lock
)
;
}
}
MOZ_RELEASE_ASSERT
(
gc
-
>
maxParallelThreads
>
=
workerCount
(
)
)
;
for
(
size_t
i
=
1
;
i
<
workerCount
(
)
;
i
+
+
)
{
ParallelMarkTask
&
task
=
*
tasks
[
i
]
;
gc
-
>
startTask
(
task
lock
)
;
}
tasks
[
0
]
-
>
runFromMainThread
(
lock
)
;
tasks
[
0
]
-
>
recordDuration
(
)
;
for
(
size_t
i
=
1
;
i
<
workerCount
(
)
;
i
+
+
)
{
gc
-
>
joinTask
(
*
tasks
[
i
]
lock
)
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
waitingTasks
.
ref
(
)
.
isEmpty
(
)
)
;
MOZ_ASSERT
(
waitingTaskCount
=
=
0
)
;
MOZ_ASSERT
(
!
hasActiveTasks
(
lock
)
)
;
#
endif
return
!
hasWork
(
color
)
;
}
bool
ParallelMarker
:
:
hasWork
(
MarkColor
color
)
const
{
for
(
const
auto
&
marker
:
gc
-
>
markers
)
{
if
(
marker
-
>
hasEntries
(
color
)
)
{
return
true
;
}
}
return
false
;
}
ParallelMarkTask
:
:
ParallelMarkTask
(
ParallelMarker
*
pm
GCMarker
*
marker
MarkColor
color
uint32_t
id
const
SliceBudget
&
budget
)
:
GCParallelTask
(
pm
-
>
gc
gcstats
:
:
PhaseKind
:
:
PARALLEL_MARK
GCUse
:
:
Marking
)
pm
(
pm
)
marker
(
marker
)
color
(
*
marker
color
)
budget
(
budget
)
id
(
id
)
{
marker
-
>
enterParallelMarkingMode
(
pm
)
;
}
ParallelMarkTask
:
:
~
ParallelMarkTask
(
)
{
MOZ_ASSERT
(
!
isWaiting
.
refNoCheck
(
)
)
;
marker
-
>
leaveParallelMarkingMode
(
)
;
}
bool
ParallelMarkTask
:
:
hasWork
(
)
const
{
return
marker
-
>
hasEntriesForCurrentColor
(
)
;
}
void
ParallelMarkTask
:
:
recordDuration
(
)
{
gc
-
>
stats
(
)
.
recordParallelPhase
(
gcstats
:
:
PhaseKind
:
:
PARALLEL_MARK_MARK
markTime
.
ref
(
)
)
;
gc
-
>
stats
(
)
.
recordParallelPhase
(
gcstats
:
:
PhaseKind
:
:
PARALLEL_MARK_WAIT
waitTime
.
ref
(
)
)
;
TimeDuration
other
=
duration
(
)
-
markTime
.
ref
(
)
-
waitTime
.
ref
(
)
;
if
(
other
<
TimeDuration
:
:
Zero
(
)
)
{
other
=
TimeDuration
:
:
Zero
(
)
;
}
gc
-
>
stats
(
)
.
recordParallelPhase
(
gcstats
:
:
PhaseKind
:
:
PARALLEL_MARK_OTHER
other
)
;
}
void
ParallelMarkTask
:
:
run
(
AutoLockHelperThreadState
&
lock
)
{
AutoUpdateMarkStackRanges
updateRanges
(
*
marker
)
;
for
(
;
;
)
{
if
(
hasWork
(
)
)
{
if
(
!
tryMarking
(
lock
)
)
{
return
;
}
}
else
{
if
(
!
requestWork
(
lock
)
)
{
return
;
}
}
}
MOZ_ASSERT
(
!
isWaiting
)
;
}
bool
ParallelMarkTask
:
:
tryMarking
(
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
hasWork
(
)
)
;
MOZ_ASSERT
(
marker
-
>
isParallelMarking
(
)
)
;
bool
finished
;
{
AutoUnlockHelperThreadState
unlock
(
lock
)
;
AutoAddTimeDuration
time
(
markTime
.
ref
(
)
)
;
finished
=
marker
-
>
markCurrentColorInParallel
(
budget
)
;
GeckoProfilerRuntime
&
profiler
=
gc
-
>
rt
-
>
geckoProfiler
(
)
;
if
(
profiler
.
enabled
(
)
)
{
profiler
.
markInterval
(
"
Parallel
marking
ran
"
time
.
start
(
)
nullptr
JS
:
:
ProfilingCategoryPair
:
:
GCCC
)
;
}
}
MOZ_ASSERT_IF
(
finished
!
hasWork
(
)
)
;
pm
-
>
setTaskInactive
(
this
lock
)
;
return
finished
;
}
bool
ParallelMarkTask
:
:
requestWork
(
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
!
hasWork
(
)
)
;
if
(
!
pm
-
>
hasActiveTasks
(
lock
)
)
{
return
false
;
}
budget
.
forceCheck
(
)
;
if
(
budget
.
isOverBudget
(
)
)
{
return
false
;
}
waitUntilResumed
(
lock
)
;
return
true
;
}
void
ParallelMarkTask
:
:
waitUntilResumed
(
AutoLockHelperThreadState
&
lock
)
{
AutoAddTimeDuration
time
(
waitTime
.
ref
(
)
)
;
pm
-
>
addTaskToWaitingList
(
this
lock
)
;
MOZ_ASSERT
(
!
isWaiting
)
;
isWaiting
=
true
;
do
{
MOZ_ASSERT
(
pm
-
>
hasActiveTasks
(
lock
)
)
;
resumed
.
wait
(
lock
)
;
}
while
(
isWaiting
)
;
MOZ_ASSERT
(
!
pm
-
>
isTaskInWaitingList
(
this
lock
)
)
;
GeckoProfilerRuntime
&
profiler
=
gc
-
>
rt
-
>
geckoProfiler
(
)
;
if
(
profiler
.
enabled
(
)
)
{
char
details
[
32
]
;
SprintfLiteral
(
details
"
markers
=
%
zu
"
pm
-
>
workerCount
(
)
)
;
profiler
.
markInterval
(
"
Parallel
marking
wait
"
time
.
start
(
)
details
JS
:
:
ProfilingCategoryPair
:
:
GCCC
)
;
}
}
void
ParallelMarkTask
:
:
resume
(
)
{
{
AutoLockHelperThreadState
lock
;
MOZ_ASSERT
(
isWaiting
)
;
isWaiting
=
false
;
if
(
hasWork
(
)
)
{
pm
-
>
setTaskActive
(
this
lock
)
;
}
}
resumed
.
notify_all
(
)
;
}
void
ParallelMarkTask
:
:
resumeOnFinish
(
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
isWaiting
)
;
MOZ_ASSERT
(
!
hasWork
(
)
)
;
isWaiting
=
false
;
resumed
.
notify_all
(
)
;
}
void
ParallelMarker
:
:
addTaskToWaitingList
(
ParallelMarkTask
*
task
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
!
task
-
>
hasWork
(
)
)
;
MOZ_ASSERT
(
hasActiveTasks
(
lock
)
)
;
MOZ_ASSERT
(
!
isTaskInWaitingList
(
task
lock
)
)
;
MOZ_ASSERT
(
waitingTaskCount
<
workerCount
(
)
-
1
)
;
waitingTasks
.
ref
(
)
.
pushBack
(
task
)
;
waitingTaskCount
+
+
;
}
#
ifdef
DEBUG
bool
ParallelMarker
:
:
isTaskInWaitingList
(
const
ParallelMarkTask
*
task
const
AutoLockHelperThreadState
&
lock
)
const
{
return
const_cast
<
ParallelMarkTaskList
&
>
(
waitingTasks
.
ref
(
)
)
.
ElementProbablyInList
(
const_cast
<
ParallelMarkTask
*
>
(
task
)
)
;
}
#
endif
void
ParallelMarker
:
:
setTaskActive
(
ParallelMarkTask
*
task
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
task
-
>
hasWork
(
)
)
;
uint32_t
id
=
task
-
>
id
;
MOZ_ASSERT
(
id
<
workerCount
(
)
)
;
MOZ_ASSERT
(
!
activeTasks
.
ref
(
)
[
id
]
)
;
activeTasks
.
ref
(
)
[
id
]
=
true
;
}
void
ParallelMarker
:
:
setTaskInactive
(
ParallelMarkTask
*
task
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
hasActiveTasks
(
lock
)
)
;
uint32_t
id
=
task
-
>
id
;
MOZ_ASSERT
(
id
<
workerCount
(
)
)
;
MOZ_ASSERT
(
activeTasks
.
ref
(
)
[
id
]
)
;
activeTasks
.
ref
(
)
[
id
]
=
false
;
if
(
!
hasActiveTasks
(
lock
)
)
{
while
(
!
waitingTasks
.
ref
(
)
.
isEmpty
(
)
)
{
ParallelMarkTask
*
task
=
waitingTasks
.
ref
(
)
.
popFront
(
)
;
MOZ_ASSERT
(
waitingTaskCount
!
=
0
)
;
waitingTaskCount
-
-
;
task
-
>
resumeOnFinish
(
lock
)
;
}
}
}
void
ParallelMarker
:
:
donateWorkFrom
(
GCMarker
*
src
)
{
GeckoProfilerRuntime
&
profiler
=
gc
-
>
rt
-
>
geckoProfiler
(
)
;
if
(
!
gHelperThreadLock
.
tryLock
(
)
)
{
if
(
profiler
.
enabled
(
)
)
{
profiler
.
markEvent
(
"
Parallel
marking
donate
failed
"
"
lock
already
held
"
)
;
}
return
;
}
if
(
waitingTaskCount
=
=
0
)
{
gHelperThreadLock
.
unlock
(
)
;
if
(
profiler
.
enabled
(
)
)
{
profiler
.
markEvent
(
"
Parallel
marking
donate
failed
"
"
no
tasks
waiting
"
)
;
}
return
;
}
ParallelMarkTask
*
waitingTask
=
waitingTasks
.
ref
(
)
.
popFront
(
)
;
waitingTaskCount
-
-
;
MOZ_ASSERT
(
waitingTask
-
>
isWaiting
)
;
gHelperThreadLock
.
unlock
(
)
;
MOZ_ASSERT
(
!
waitingTask
-
>
hasWork
(
)
)
;
size_t
wordsMoved
=
GCMarker
:
:
moveWork
(
waitingTask
-
>
marker
src
true
)
;
gc
-
>
stats
(
)
.
count
(
gcstats
:
:
COUNT_PARALLEL_MARK_INTERRUPTIONS
)
;
if
(
profiler
.
enabled
(
)
)
{
char
details
[
32
]
;
SprintfLiteral
(
details
"
words
=
%
zu
"
wordsMoved
)
;
profiler
.
markEvent
(
"
Parallel
marking
donated
work
"
details
JS
:
:
ProfilingCategoryPair
:
:
GCCC
)
;
}
waitingTask
-
>
resume
(
)
;
}
