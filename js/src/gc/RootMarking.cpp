#
include
"
mozilla
/
ArrayUtils
.
h
"
#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
memcheck
.
h
>
#
endif
#
include
"
jscntxt
.
h
"
#
include
"
jsgc
.
h
"
#
include
"
jsprf
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
jswatchpoint
.
h
"
#
include
"
builtin
/
MapObject
.
h
"
#
include
"
frontend
/
BytecodeCompiler
.
h
"
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
jit
/
MacroAssembler
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
vm
/
Debugger
.
h
"
#
include
"
vm
/
JSONParser
.
h
"
#
include
"
jsgcinlines
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
gc
/
Nursery
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
mozilla
:
:
ArrayEnd
;
using
JS
:
:
AutoGCRooter
;
typedef
RootedValueMap
:
:
Range
RootRange
;
typedef
RootedValueMap
:
:
Entry
RootEntry
;
typedef
RootedValueMap
:
:
Enum
RootEnum
;
template
<
typename
T
>
using
TraceFunction
=
void
(
*
)
(
JSTracer
*
trc
T
*
ref
const
char
*
name
)
;
struct
ConcreteTraceable
{
ConcreteTraceable
(
)
{
MOZ_CRASH
(
"
instantiation
of
ConcreteTraceable
"
)
;
}
void
trace
(
JSTracer
*
)
{
}
}
;
template
<
typename
T
TraceFunction
<
T
>
TraceFn
=
TraceNullableRoot
>
static
inline
void
TraceExactStackRootList
(
JSTracer
*
trc
JS
:
:
Rooted
<
void
*
>
*
rooter
const
char
*
name
)
{
while
(
rooter
)
{
T
*
addr
=
reinterpret_cast
<
JS
:
:
Rooted
<
T
>
*
>
(
rooter
)
-
>
address
(
)
;
TraceFn
(
trc
addr
name
)
;
rooter
=
rooter
-
>
previous
(
)
;
}
}
static
inline
void
TraceStackRoots
(
JSTracer
*
trc
JS
:
:
RootedListHeads
&
stackRoots
)
{
#
define
TRACE_ROOTS
(
name
type
_
)
\
TraceExactStackRootList
<
type
*
>
(
trc
stackRoots
[
JS
:
:
RootKind
:
:
name
]
"
exact
-
"
#
name
)
;
JS_FOR_EACH_TRACEKIND
(
TRACE_ROOTS
)
#
undef
TRACE_ROOTS
TraceExactStackRootList
<
jsid
>
(
trc
stackRoots
[
JS
:
:
RootKind
:
:
Id
]
"
exact
-
id
"
)
;
TraceExactStackRootList
<
Value
>
(
trc
stackRoots
[
JS
:
:
RootKind
:
:
Value
]
"
exact
-
value
"
)
;
TraceExactStackRootList
<
ConcreteTraceable
js
:
:
DispatchWrapper
<
ConcreteTraceable
>
:
:
TraceWrapped
>
(
trc
stackRoots
[
JS
:
:
RootKind
:
:
Traceable
]
"
Traceable
"
)
;
}
void
JS
:
:
RootingContext
:
:
traceStackRoots
(
JSTracer
*
trc
)
{
TraceStackRoots
(
trc
stackRoots_
)
;
}
static
void
TraceExactStackRoots
(
const
CooperatingContext
&
target
JSTracer
*
trc
)
{
target
.
context
(
)
-
>
traceStackRoots
(
trc
)
;
}
template
<
typename
T
TraceFunction
<
T
>
TraceFn
=
TraceNullableRoot
>
static
inline
void
TracePersistentRootedList
(
JSTracer
*
trc
mozilla
:
:
LinkedList
<
PersistentRooted
<
void
*
>
>
&
list
const
char
*
name
)
{
for
(
PersistentRooted
<
void
*
>
*
r
:
list
)
TraceFn
(
trc
reinterpret_cast
<
PersistentRooted
<
T
>
*
>
(
r
)
-
>
address
(
)
name
)
;
}
void
JSRuntime
:
:
tracePersistentRoots
(
JSTracer
*
trc
)
{
#
define
TRACE_ROOTS
(
name
type
_
)
\
TracePersistentRootedList
<
type
*
>
(
trc
heapRoots
.
ref
(
)
[
JS
:
:
RootKind
:
:
name
]
"
persistent
-
"
#
name
)
;
JS_FOR_EACH_TRACEKIND
(
TRACE_ROOTS
)
#
undef
TRACE_ROOTS
TracePersistentRootedList
<
jsid
>
(
trc
heapRoots
.
ref
(
)
[
JS
:
:
RootKind
:
:
Id
]
"
persistent
-
id
"
)
;
TracePersistentRootedList
<
Value
>
(
trc
heapRoots
.
ref
(
)
[
JS
:
:
RootKind
:
:
Value
]
"
persistent
-
value
"
)
;
TracePersistentRootedList
<
ConcreteTraceable
js
:
:
DispatchWrapper
<
ConcreteTraceable
>
:
:
TraceWrapped
>
(
trc
heapRoots
.
ref
(
)
[
JS
:
:
RootKind
:
:
Traceable
]
"
persistent
-
traceable
"
)
;
}
static
void
TracePersistentRooted
(
JSRuntime
*
rt
JSTracer
*
trc
)
{
rt
-
>
tracePersistentRoots
(
trc
)
;
}
template
<
typename
T
>
static
void
FinishPersistentRootedChain
(
mozilla
:
:
LinkedList
<
PersistentRooted
<
void
*
>
>
&
listArg
)
{
auto
&
list
=
reinterpret_cast
<
mozilla
:
:
LinkedList
<
PersistentRooted
<
T
>
>
&
>
(
listArg
)
;
while
(
!
list
.
isEmpty
(
)
)
list
.
getFirst
(
)
-
>
reset
(
)
;
}
void
JSRuntime
:
:
finishPersistentRoots
(
)
{
#
define
FINISH_ROOT_LIST
(
name
type
_
)
\
FinishPersistentRootedChain
<
type
*
>
(
heapRoots
.
ref
(
)
[
JS
:
:
RootKind
:
:
name
]
)
;
JS_FOR_EACH_TRACEKIND
(
FINISH_ROOT_LIST
)
#
undef
FINISH_ROOT_LIST
FinishPersistentRootedChain
<
jsid
>
(
heapRoots
.
ref
(
)
[
JS
:
:
RootKind
:
:
Id
]
)
;
FinishPersistentRootedChain
<
Value
>
(
heapRoots
.
ref
(
)
[
JS
:
:
RootKind
:
:
Value
]
)
;
}
inline
void
AutoGCRooter
:
:
trace
(
JSTracer
*
trc
)
{
switch
(
tag_
)
{
case
PARSER
:
frontend
:
:
TraceParser
(
trc
this
)
;
return
;
case
VALARRAY
:
{
AutoValueArray
<
1
>
*
array
=
static_cast
<
AutoValueArray
<
1
>
*
>
(
this
)
;
TraceRootRange
(
trc
array
-
>
length
(
)
array
-
>
begin
(
)
"
js
:
:
AutoValueArray
"
)
;
return
;
}
case
IONMASM
:
{
static_cast
<
js
:
:
jit
:
:
MacroAssembler
:
:
AutoRooter
*
>
(
this
)
-
>
masm
(
)
-
>
trace
(
trc
)
;
return
;
}
case
WRAPPER
:
{
TraceManuallyBarrieredEdge
(
trc
&
static_cast
<
AutoWrapperRooter
*
>
(
this
)
-
>
value
.
get
(
)
"
JS
:
:
AutoWrapperRooter
.
value
"
)
;
return
;
}
case
WRAPVECTOR
:
{
AutoWrapperVector
:
:
VectorImpl
&
vector
=
static_cast
<
AutoWrapperVector
*
>
(
this
)
-
>
vector
;
for
(
WrapperValue
*
p
=
vector
.
begin
(
)
;
p
<
vector
.
end
(
)
;
p
+
+
)
TraceManuallyBarrieredEdge
(
trc
&
p
-
>
get
(
)
"
js
:
:
AutoWrapperVector
.
vector
"
)
;
return
;
}
case
CUSTOM
:
static_cast
<
JS
:
:
CustomAutoRooter
*
>
(
this
)
-
>
trace
(
trc
)
;
return
;
}
MOZ_ASSERT
(
tag_
>
=
0
)
;
if
(
Value
*
vp
=
static_cast
<
AutoArrayRooter
*
>
(
this
)
-
>
array
)
TraceRootRange
(
trc
tag_
vp
"
JS
:
:
AutoArrayRooter
.
array
"
)
;
}
void
AutoGCRooter
:
:
traceAll
(
const
CooperatingContext
&
target
JSTracer
*
trc
)
{
for
(
AutoGCRooter
*
gcr
=
target
.
context
(
)
-
>
autoGCRooters_
;
gcr
;
gcr
=
gcr
-
>
down
)
gcr
-
>
trace
(
trc
)
;
}
void
AutoGCRooter
:
:
traceAllWrappers
(
const
CooperatingContext
&
target
JSTracer
*
trc
)
{
for
(
AutoGCRooter
*
gcr
=
target
.
context
(
)
-
>
autoGCRooters_
;
gcr
;
gcr
=
gcr
-
>
down
)
{
if
(
gcr
-
>
tag_
=
=
WRAPVECTOR
|
|
gcr
-
>
tag_
=
=
WRAPPER
)
gcr
-
>
trace
(
trc
)
;
}
}
void
StackShape
:
:
trace
(
JSTracer
*
trc
)
{
if
(
base
)
TraceRoot
(
trc
&
base
"
StackShape
base
"
)
;
TraceRoot
(
trc
(
jsid
*
)
&
propid
"
StackShape
id
"
)
;
if
(
(
attrs
&
JSPROP_GETTER
)
&
&
rawGetter
)
TraceRoot
(
trc
(
JSObject
*
*
)
&
rawGetter
"
StackShape
getter
"
)
;
if
(
(
attrs
&
JSPROP_SETTER
)
&
&
rawSetter
)
TraceRoot
(
trc
(
JSObject
*
*
)
&
rawSetter
"
StackShape
setter
"
)
;
}
void
PropertyDescriptor
:
:
trace
(
JSTracer
*
trc
)
{
if
(
obj
)
TraceRoot
(
trc
&
obj
"
Descriptor
:
:
obj
"
)
;
TraceRoot
(
trc
&
value
"
Descriptor
:
:
value
"
)
;
if
(
(
attrs
&
JSPROP_GETTER
)
&
&
getter
)
{
JSObject
*
tmp
=
JS_FUNC_TO_DATA_PTR
(
JSObject
*
getter
)
;
TraceRoot
(
trc
&
tmp
"
Descriptor
:
:
get
"
)
;
getter
=
JS_DATA_TO_FUNC_PTR
(
JSGetterOp
tmp
)
;
}
if
(
(
attrs
&
JSPROP_SETTER
)
&
&
setter
)
{
JSObject
*
tmp
=
JS_FUNC_TO_DATA_PTR
(
JSObject
*
setter
)
;
TraceRoot
(
trc
&
tmp
"
Descriptor
:
:
set
"
)
;
setter
=
JS_DATA_TO_FUNC_PTR
(
JSSetterOp
tmp
)
;
}
}
void
js
:
:
gc
:
:
GCRuntime
:
:
traceRuntimeForMajorGC
(
JSTracer
*
trc
AutoLockForExclusiveAccess
&
lock
)
{
if
(
rt
-
>
isBeingDestroyed
(
)
)
return
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_ROOTS
)
;
if
(
rt
-
>
atomsCompartment
(
lock
)
-
>
zone
(
)
-
>
isCollecting
(
)
)
traceRuntimeAtoms
(
trc
lock
)
;
JSCompartment
:
:
traceIncomingCrossCompartmentEdgesForZoneGC
(
trc
)
;
traceRuntimeCommon
(
trc
MarkRuntime
lock
)
;
}
void
js
:
:
gc
:
:
GCRuntime
:
:
traceRuntimeForMinorGC
(
JSTracer
*
trc
AutoLockForExclusiveAccess
&
lock
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_ROOTS
)
;
jit
:
:
JitRuntime
:
:
TraceJitcodeGlobalTableForMinorGC
(
trc
)
;
traceRuntimeCommon
(
trc
TraceRuntime
lock
)
;
}
void
js
:
:
TraceRuntime
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
!
trc
-
>
isMarkingTracer
(
)
)
;
JSRuntime
*
rt
=
trc
-
>
runtime
(
)
;
EvictAllNurseries
(
rt
)
;
AutoPrepareForTracing
prep
(
TlsContext
.
get
(
)
WithAtoms
)
;
gcstats
:
:
AutoPhase
ap
(
rt
-
>
gc
.
stats
(
)
gcstats
:
:
PhaseKind
:
:
TRACE_HEAP
)
;
rt
-
>
gc
.
traceRuntime
(
trc
prep
.
session
(
)
.
lock
)
;
}
void
js
:
:
gc
:
:
GCRuntime
:
:
traceRuntime
(
JSTracer
*
trc
AutoLockForExclusiveAccess
&
lock
)
{
MOZ_ASSERT
(
!
rt
-
>
isBeingDestroyed
(
)
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_ROOTS
)
;
traceRuntimeAtoms
(
trc
lock
)
;
traceRuntimeCommon
(
trc
TraceRuntime
lock
)
;
}
void
js
:
:
gc
:
:
GCRuntime
:
:
traceRuntimeAtoms
(
JSTracer
*
trc
AutoLockForExclusiveAccess
&
lock
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_RUNTIME_DATA
)
;
TracePermanentAtoms
(
trc
)
;
TraceAtoms
(
trc
lock
)
;
TraceWellKnownSymbols
(
trc
)
;
jit
:
:
JitRuntime
:
:
Trace
(
trc
lock
)
;
}
void
js
:
:
gc
:
:
GCRuntime
:
:
traceRuntimeCommon
(
JSTracer
*
trc
TraceOrMarkRuntime
traceOrMark
AutoLockForExclusiveAccess
&
lock
)
{
MOZ_ASSERT
(
!
TlsContext
.
get
(
)
-
>
suppressGC
)
;
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_STACK
)
;
JSContext
*
cx
=
TlsContext
.
get
(
)
;
for
(
const
CooperatingContext
&
target
:
rt
-
>
cooperatingContexts
(
)
)
{
TraceInterpreterActivations
(
cx
target
trc
)
;
jit
:
:
TraceJitActivations
(
cx
target
trc
)
;
wasm
:
:
TraceActivations
(
cx
target
trc
)
;
AutoGCRooter
:
:
traceAll
(
target
trc
)
;
TraceExactStackRoots
(
target
trc
)
;
}
for
(
RootRange
r
=
rootsHash
.
ref
(
)
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
const
RootEntry
&
entry
=
r
.
front
(
)
;
TraceRoot
(
trc
entry
.
key
(
)
entry
.
value
(
)
)
;
}
}
TracePersistentRooted
(
rt
trc
)
;
rt
-
>
traceSelfHostingGlobal
(
trc
)
;
rt
-
>
traceSharedIntlData
(
trc
)
;
for
(
const
CooperatingContext
&
target
:
rt
-
>
cooperatingContexts
(
)
)
target
.
context
(
)
-
>
trace
(
trc
)
;
for
(
CompartmentsIter
c
(
rt
SkipAtoms
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
c
-
>
traceRoots
(
trc
traceOrMark
)
;
HelperThreadState
(
)
.
trace
(
trc
)
;
if
(
!
JS
:
:
CurrentThreadIsHeapMinorCollecting
(
)
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_EMBEDDING
)
;
for
(
size_t
i
=
0
;
i
<
blackRootTracers
.
ref
(
)
.
length
(
)
;
i
+
+
)
{
const
Callback
<
JSTraceDataOp
>
&
e
=
blackRootTracers
.
ref
(
)
[
i
]
;
(
*
e
.
op
)
(
trc
e
.
data
)
;
}
if
(
JSTraceDataOp
op
=
grayRootTracer
.
op
)
{
if
(
traceOrMark
=
=
TraceRuntime
)
(
*
op
)
(
trc
grayRootTracer
.
data
)
;
}
}
}
#
ifdef
DEBUG
class
AssertNoRootsTracer
:
public
JS
:
:
CallbackTracer
{
void
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
override
{
MOZ_CRASH
(
"
There
should
not
be
any
roots
after
finishRoots
"
)
;
}
public
:
AssertNoRootsTracer
(
JSRuntime
*
rt
WeakMapTraceKind
weakTraceKind
)
:
JS
:
:
CallbackTracer
(
rt
weakTraceKind
)
{
}
}
;
#
endif
void
js
:
:
gc
:
:
GCRuntime
:
:
finishRoots
(
)
{
AutoNoteSingleThreadedRegion
anstr
;
rt
-
>
finishAtoms
(
)
;
if
(
rootsHash
.
ref
(
)
.
initialized
(
)
)
rootsHash
.
ref
(
)
.
clear
(
)
;
rt
-
>
finishPersistentRoots
(
)
;
rt
-
>
finishSelfHosting
(
)
;
for
(
CompartmentsIter
c
(
rt
SkipAtoms
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
c
-
>
finishRoots
(
)
;
#
ifdef
DEBUG
auto
prior
=
grayRootTracer
;
grayRootTracer
=
Callback
<
JSTraceDataOp
>
(
nullptr
nullptr
)
;
AssertNoRootsTracer
trc
(
rt
TraceWeakMapKeysValues
)
;
AutoPrepareForTracing
prep
(
TlsContext
.
get
(
)
WithAtoms
)
;
gcstats
:
:
AutoPhase
ap
(
rt
-
>
gc
.
stats
(
)
gcstats
:
:
PhaseKind
:
:
TRACE_HEAP
)
;
traceRuntime
(
&
trc
prep
.
session
(
)
.
lock
)
;
grayRootTracer
=
prior
;
#
endif
}
class
BufferGrayRootsTracer
final
:
public
JS
:
:
CallbackTracer
{
bool
bufferingGrayRootsFailed
;
void
onObjectEdge
(
JSObject
*
*
objp
)
override
{
bufferRoot
(
*
objp
)
;
}
void
onStringEdge
(
JSString
*
*
stringp
)
override
{
bufferRoot
(
*
stringp
)
;
}
void
onScriptEdge
(
JSScript
*
*
scriptp
)
override
{
bufferRoot
(
*
scriptp
)
;
}
void
onSymbolEdge
(
JS
:
:
Symbol
*
*
symbolp
)
override
{
bufferRoot
(
*
symbolp
)
;
}
void
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
override
{
MOZ_CRASH
(
"
Unexpected
gray
root
kind
"
)
;
}
template
<
typename
T
>
inline
void
bufferRoot
(
T
*
thing
)
;
public
:
explicit
BufferGrayRootsTracer
(
JSRuntime
*
rt
)
:
JS
:
:
CallbackTracer
(
rt
)
bufferingGrayRootsFailed
(
false
)
{
}
bool
failed
(
)
const
{
return
bufferingGrayRootsFailed
;
}
#
ifdef
DEBUG
TracerKind
getTracerKind
(
)
const
override
{
return
TracerKind
:
:
GrayBuffering
;
}
#
endif
}
;
#
ifdef
DEBUG
bool
js
:
:
IsBufferGrayRootsTracer
(
JSTracer
*
trc
)
{
return
trc
-
>
isCallbackTracer
(
)
&
&
trc
-
>
asCallbackTracer
(
)
-
>
getTracerKind
(
)
=
=
JS
:
:
CallbackTracer
:
:
TracerKind
:
:
GrayBuffering
;
}
#
endif
void
js
:
:
gc
:
:
GCRuntime
:
:
bufferGrayRoots
(
)
{
MOZ_ASSERT
(
grayBufferState
=
=
GrayBufferState
:
:
Unused
)
;
for
(
GCZonesIter
zone
(
rt
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
MOZ_ASSERT
(
zone
-
>
gcGrayRoots
(
)
.
empty
(
)
)
;
BufferGrayRootsTracer
grayBufferer
(
rt
)
;
if
(
JSTraceDataOp
op
=
grayRootTracer
.
op
)
(
*
op
)
(
&
grayBufferer
grayRootTracer
.
data
)
;
if
(
grayBufferer
.
failed
(
)
)
{
grayBufferState
=
GrayBufferState
:
:
Failed
;
resetBufferedGrayRoots
(
)
;
}
else
{
grayBufferState
=
GrayBufferState
:
:
Okay
;
}
}
template
<
typename
T
>
inline
void
BufferGrayRootsTracer
:
:
bufferRoot
(
T
*
thing
)
{
MOZ_ASSERT
(
JS
:
:
CurrentThreadIsHeapBusy
(
)
)
;
MOZ_ASSERT
(
thing
)
;
MOZ_ASSERT
(
thing
-
>
getTraceKind
(
)
<
=
JS
:
:
TraceKind
:
:
Null
)
;
TenuredCell
*
tenured
=
&
thing
-
>
asTenured
(
)
;
Zone
*
zone
=
tenured
-
>
zoneFromAnyThread
(
)
;
if
(
zone
-
>
isCollectingFromAnyThread
(
)
)
{
SetMaybeAliveFlag
(
thing
)
;
if
(
!
zone
-
>
gcGrayRoots
(
)
.
append
(
tenured
)
)
bufferingGrayRootsFailed
=
true
;
}
}
void
GCRuntime
:
:
markBufferedGrayRoots
(
JS
:
:
Zone
*
zone
)
{
MOZ_ASSERT
(
grayBufferState
=
=
GrayBufferState
:
:
Okay
)
;
MOZ_ASSERT
(
zone
-
>
isGCMarkingGray
(
)
|
|
zone
-
>
isGCCompacting
(
)
)
;
for
(
auto
cell
:
zone
-
>
gcGrayRoots
(
)
)
TraceManuallyBarrieredGenericPointerEdge
(
&
marker
&
cell
"
buffered
gray
root
"
)
;
}
void
GCRuntime
:
:
resetBufferedGrayRoots
(
)
const
{
MOZ_ASSERT
(
grayBufferState
!
=
GrayBufferState
:
:
Okay
"
Do
not
clear
the
gray
buffers
unless
we
are
Failed
or
becoming
Unused
"
)
;
for
(
GCZonesIter
zone
(
rt
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
zone
-
>
gcGrayRoots
(
)
.
clearAndFree
(
)
;
}
JS_PUBLIC_API
(
void
)
JS
:
:
AddPersistentRoot
(
JS
:
:
RootingContext
*
cx
RootKind
kind
PersistentRooted
<
void
*
>
*
root
)
{
static_cast
<
JSContext
*
>
(
cx
)
-
>
runtime
(
)
-
>
heapRoots
.
ref
(
)
[
kind
]
.
insertBack
(
root
)
;
}
JS_PUBLIC_API
(
void
)
JS
:
:
AddPersistentRoot
(
JSRuntime
*
rt
RootKind
kind
PersistentRooted
<
void
*
>
*
root
)
{
rt
-
>
heapRoots
.
ref
(
)
[
kind
]
.
insertBack
(
root
)
;
}
