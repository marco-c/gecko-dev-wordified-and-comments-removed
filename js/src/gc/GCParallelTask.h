#
ifndef
gc_GCParallelTask_h
#
define
gc_GCParallelTask_h
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
namespace
js
{
class
AutoLockHelperThreadState
;
struct
HelperThread
;
class
GCParallelTask
:
public
mozilla
:
:
LinkedListElement
<
GCParallelTask
>
public
RunnableTask
{
public
:
using
TaskFunc
=
void
(
*
)
(
GCParallelTask
*
)
;
gc
:
:
GCRuntime
*
const
gc
;
private
:
TaskFunc
func_
;
enum
class
State
{
Idle
Dispatched
Running
Finishing
Finished
}
;
UnprotectedData
<
State
>
state_
;
MainThreadOrGCTaskData
<
mozilla
:
:
TimeDuration
>
duration_
;
explicit
GCParallelTask
(
const
GCParallelTask
&
)
=
delete
;
protected
:
mozilla
:
:
Atomic
<
bool
mozilla
:
:
MemoryOrdering
:
:
ReleaseAcquire
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
cancel_
;
public
:
explicit
GCParallelTask
(
gc
:
:
GCRuntime
*
gc
TaskFunc
func
)
:
gc
(
gc
)
func_
(
func
)
state_
(
State
:
:
Idle
)
duration_
(
nullptr
)
cancel_
(
false
)
{
}
GCParallelTask
(
GCParallelTask
&
&
other
)
:
gc
(
other
.
gc
)
func_
(
other
.
func_
)
state_
(
other
.
state_
)
duration_
(
nullptr
)
cancel_
(
false
)
{
}
virtual
~
GCParallelTask
(
)
;
mozilla
:
:
TimeDuration
duration
(
)
const
{
return
duration_
;
}
void
start
(
)
;
void
join
(
)
;
void
startWithLockHeld
(
AutoLockHelperThreadState
&
lock
)
;
void
joinWithLockHeld
(
AutoLockHelperThreadState
&
lock
)
;
void
joinRunningOrFinishedTask
(
AutoLockHelperThreadState
&
lock
)
;
void
runFromMainThread
(
)
;
void
startOrRunIfIdle
(
AutoLockHelperThreadState
&
lock
)
;
void
cancelDispatchedTask
(
AutoLockHelperThreadState
&
lock
)
;
void
cancelAndWait
(
)
{
cancel_
=
true
;
join
(
)
;
}
bool
isIdle
(
)
const
;
bool
isIdle
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
state_
=
=
State
:
:
Idle
;
}
bool
wasStarted
(
)
const
;
bool
wasStarted
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
isDispatched
(
lock
)
|
|
isRunning
(
lock
)
;
}
bool
isDispatched
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
state_
=
=
State
:
:
Dispatched
;
}
ThreadType
threadType
(
)
override
{
return
ThreadType
:
:
THREAD_TYPE_GCPARALLEL
;
}
protected
:
void
setFinishing
(
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
isIdle
(
lock
)
|
|
isRunning
(
lock
)
)
;
if
(
isRunning
(
lock
)
)
{
state_
=
State
:
:
Finishing
;
}
}
private
:
void
assertIdle
(
)
const
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Idle
)
;
}
bool
isRunning
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
state_
=
=
State
:
:
Running
;
}
bool
isFinishing
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
state_
=
=
State
:
:
Finishing
;
}
bool
isFinished
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
state_
=
=
State
:
:
Finished
;
}
void
setDispatched
(
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
isIdle
(
lock
)
)
;
state_
=
State
:
:
Dispatched
;
}
void
setRunning
(
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
isDispatched
(
lock
)
)
;
state_
=
State
:
:
Running
;
}
void
setFinished
(
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
isRunning
(
lock
)
|
|
isFinishing
(
lock
)
)
;
state_
=
State
:
:
Finished
;
}
void
setIdle
(
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
isDispatched
(
lock
)
|
|
isFinished
(
lock
)
)
;
state_
=
State
:
:
Idle
;
}
void
runTask
(
)
override
;
friend
struct
HelperThread
;
void
runFromHelperThread
(
AutoLockHelperThreadState
&
locked
)
;
}
;
template
<
typename
Derived
>
class
GCParallelTaskHelper
:
public
GCParallelTask
{
public
:
explicit
GCParallelTaskHelper
(
gc
:
:
GCRuntime
*
gc
)
:
GCParallelTask
(
gc
&
runTaskTyped
)
{
}
GCParallelTaskHelper
(
GCParallelTaskHelper
&
&
other
)
:
GCParallelTask
(
std
:
:
move
(
other
)
)
{
}
private
:
static
void
runTaskTyped
(
GCParallelTask
*
task
)
{
static_cast
<
Derived
*
>
(
task
)
-
>
run
(
)
;
}
}
;
}
#
endif
