#
ifndef
gc_GCParallelTask_h
#
define
gc_GCParallelTask_h
#
include
"
mozilla
/
Move
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
namespace
js
{
class
AutoLockHelperThreadState
;
class
GCParallelTask
:
public
RunnableTask
{
public
:
using
TaskFunc
=
void
(
*
)
(
GCParallelTask
*
)
;
gc
:
:
GCRuntime
*
const
gc
;
private
:
TaskFunc
func_
;
enum
class
State
{
NotStarted
Dispatched
Finishing
Finished
}
;
UnprotectedData
<
State
>
state_
;
MainThreadOrGCTaskData
<
mozilla
:
:
TimeDuration
>
duration_
;
explicit
GCParallelTask
(
const
GCParallelTask
&
)
=
delete
;
protected
:
mozilla
:
:
Atomic
<
bool
mozilla
:
:
MemoryOrdering
:
:
ReleaseAcquire
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
cancel_
;
public
:
explicit
GCParallelTask
(
gc
:
:
GCRuntime
*
gc
TaskFunc
func
)
:
gc
(
gc
)
func_
(
func
)
state_
(
State
:
:
NotStarted
)
duration_
(
nullptr
)
cancel_
(
false
)
{
}
GCParallelTask
(
GCParallelTask
&
&
other
)
:
gc
(
other
.
gc
)
func_
(
other
.
func_
)
state_
(
other
.
state_
)
duration_
(
nullptr
)
cancel_
(
false
)
{
}
virtual
~
GCParallelTask
(
)
;
mozilla
:
:
TimeDuration
duration
(
)
const
{
return
duration_
;
}
MOZ_MUST_USE
bool
start
(
)
;
void
join
(
)
;
MOZ_MUST_USE
bool
startWithLockHeld
(
AutoLockHelperThreadState
&
locked
)
;
void
joinWithLockHeld
(
AutoLockHelperThreadState
&
locked
)
;
void
runFromMainThread
(
)
;
void
joinAndRunFromMainThread
(
)
;
void
startOrRunIfIdle
(
AutoLockHelperThreadState
&
lock
)
;
void
cancelAndWait
(
)
{
cancel_
=
true
;
join
(
)
;
}
bool
isRunningWithLockHeld
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
isDispatched
(
lock
)
;
}
bool
isRunning
(
)
const
;
void
runTask
(
)
override
{
func_
(
this
)
;
}
ThreadType
threadType
(
)
override
{
return
ThreadType
:
:
THREAD_TYPE_GCPARALLEL
;
}
bool
isNotStarted
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
state_
=
=
State
:
:
NotStarted
;
}
private
:
void
assertNotStarted
(
)
const
{
MOZ_ASSERT
(
state_
=
=
State
:
:
NotStarted
)
;
}
bool
isDispatched
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
state_
=
=
State
:
:
Dispatched
;
}
bool
isFinished
(
const
AutoLockHelperThreadState
&
lock
)
const
{
return
state_
=
=
State
:
:
Finished
;
}
void
setDispatched
(
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
NotStarted
)
;
state_
=
State
:
:
Dispatched
;
}
void
setFinished
(
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Dispatched
|
|
state_
=
=
State
:
:
Finishing
)
;
state_
=
State
:
:
Finished
;
}
void
setNotStarted
(
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
Finished
)
;
state_
=
State
:
:
NotStarted
;
}
protected
:
void
setFinishing
(
const
AutoLockHelperThreadState
&
lock
)
{
MOZ_ASSERT
(
state_
=
=
State
:
:
NotStarted
|
|
state_
=
=
State
:
:
Dispatched
)
;
if
(
state_
=
=
State
:
:
Dispatched
)
{
state_
=
State
:
:
Finishing
;
}
}
public
:
void
runFromHelperThread
(
AutoLockHelperThreadState
&
locked
)
;
}
;
template
<
typename
Derived
>
class
GCParallelTaskHelper
:
public
GCParallelTask
{
public
:
explicit
GCParallelTaskHelper
(
gc
:
:
GCRuntime
*
gc
)
:
GCParallelTask
(
gc
&
runTaskTyped
)
{
}
GCParallelTaskHelper
(
GCParallelTaskHelper
&
&
other
)
:
GCParallelTask
(
std
:
:
move
(
other
)
)
{
}
private
:
static
void
runTaskTyped
(
GCParallelTask
*
task
)
{
static_cast
<
Derived
*
>
(
task
)
-
>
run
(
)
;
}
}
;
}
#
endif
