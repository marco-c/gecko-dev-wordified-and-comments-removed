#
include
"
gc
/
AtomMarking
.
h
"
#
include
"
jscompartment
.
h
"
#
include
"
jsgcinlines
.
h
"
#
include
"
gc
/
Heap
-
inl
.
h
"
namespace
js
{
namespace
gc
{
static
inline
void
SetBit
(
uintptr_t
*
bitmap
size_t
bit
)
{
bitmap
[
bit
/
JS_BITS_PER_WORD
]
|
=
uintptr_t
(
1
)
<
<
(
bit
%
JS_BITS_PER_WORD
)
;
}
static
inline
bool
GetBit
(
uintptr_t
*
bitmap
size_t
bit
)
{
return
bitmap
[
bit
/
JS_BITS_PER_WORD
]
&
(
uintptr_t
(
1
)
<
<
(
bit
%
JS_BITS_PER_WORD
)
)
;
}
static
inline
bool
EnsureBitmapLength
(
AtomMarkingRuntime
:
:
Bitmap
&
bitmap
size_t
nwords
)
{
if
(
nwords
>
bitmap
.
length
(
)
)
{
size_t
needed
=
nwords
-
bitmap
.
length
(
)
;
if
(
needed
)
return
bitmap
.
appendN
(
0
needed
)
;
}
return
true
;
}
void
AtomMarkingRuntime
:
:
registerArena
(
Arena
*
arena
)
{
MOZ_ASSERT
(
arena
-
>
getThingSize
(
)
!
=
0
)
;
MOZ_ASSERT
(
arena
-
>
getThingSize
(
)
%
CellSize
=
=
0
)
;
MOZ_ASSERT
(
arena
-
>
zone
-
>
isAtomsZone
(
)
)
;
MOZ_ASSERT
(
arena
-
>
zone
-
>
runtimeFromAnyThread
(
)
-
>
currentThreadHasExclusiveAccess
(
)
)
;
if
(
freeArenaIndexes
.
ref
(
)
.
length
(
)
)
{
arena
-
>
atomBitmapStart
(
)
=
freeArenaIndexes
.
ref
(
)
.
popCopy
(
)
;
return
;
}
arena
-
>
atomBitmapStart
(
)
=
allocatedWords
;
allocatedWords
+
=
ArenaBitmapWords
;
}
void
AtomMarkingRuntime
:
:
unregisterArena
(
Arena
*
arena
)
{
MOZ_ASSERT
(
arena
-
>
zone
-
>
isAtomsZone
(
)
)
;
mozilla
:
:
Unused
<
<
freeArenaIndexes
.
ref
(
)
.
emplaceBack
(
arena
-
>
atomBitmapStart
(
)
)
;
}
bool
AtomMarkingRuntime
:
:
computeBitmapFromChunkMarkBits
(
JSRuntime
*
runtime
Bitmap
&
bitmap
)
{
MOZ_ASSERT
(
runtime
-
>
currentThreadHasExclusiveAccess
(
)
)
;
MOZ_ASSERT
(
bitmap
.
empty
(
)
)
;
if
(
!
EnsureBitmapLength
(
bitmap
allocatedWords
)
)
return
false
;
Zone
*
atomsZone
=
runtime
-
>
unsafeAtomsCompartment
(
)
-
>
zone
(
)
;
for
(
auto
thingKind
:
AllAllocKinds
(
)
)
{
for
(
ArenaIter
aiter
(
atomsZone
thingKind
)
;
!
aiter
.
done
(
)
;
aiter
.
next
(
)
)
{
Arena
*
arena
=
aiter
.
get
(
)
;
uintptr_t
*
chunkWords
=
arena
-
>
chunk
(
)
-
>
bitmap
.
arenaBits
(
arena
)
;
uintptr_t
*
bitmapWords
=
&
bitmap
[
arena
-
>
atomBitmapStart
(
)
]
;
mozilla
:
:
PodCopy
(
bitmapWords
chunkWords
ArenaBitmapWords
)
;
}
}
return
true
;
}
void
AtomMarkingRuntime
:
:
updateZoneBitmap
(
Zone
*
zone
const
Bitmap
&
bitmap
)
{
if
(
zone
-
>
isAtomsZone
(
)
)
return
;
MOZ_ASSERT
(
zone
-
>
markedAtoms
(
)
.
length
(
)
<
=
bitmap
.
length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
zone
-
>
markedAtoms
(
)
.
length
(
)
;
i
+
+
)
zone
-
>
markedAtoms
(
)
[
i
]
&
=
bitmap
[
i
]
;
}
static
void
AddBitmapToChunkMarkBits
(
JSRuntime
*
runtime
AtomMarkingRuntime
:
:
Bitmap
&
bitmap
)
{
static_assert
(
ArenaBitmapBits
=
=
ArenaBitmapWords
*
JS_BITS_PER_WORD
"
ArenaBitmapWords
must
evenly
divide
ArenaBitmapBits
"
)
;
Zone
*
atomsZone
=
runtime
-
>
unsafeAtomsCompartment
(
)
-
>
zone
(
)
;
for
(
auto
thingKind
:
AllAllocKinds
(
)
)
{
for
(
ArenaIter
aiter
(
atomsZone
thingKind
)
;
!
aiter
.
done
(
)
;
aiter
.
next
(
)
)
{
Arena
*
arena
=
aiter
.
get
(
)
;
uintptr_t
*
chunkWords
=
arena
-
>
chunk
(
)
-
>
bitmap
.
arenaBits
(
arena
)
;
if
(
bitmap
.
length
(
)
<
=
arena
-
>
atomBitmapStart
(
)
)
continue
;
MOZ_ASSERT
(
bitmap
.
length
(
)
>
=
arena
-
>
atomBitmapStart
(
)
+
ArenaBitmapWords
)
;
uintptr_t
*
bitmapWords
=
&
bitmap
[
arena
-
>
atomBitmapStart
(
)
]
;
for
(
size_t
i
=
0
;
i
<
ArenaBitmapWords
;
i
+
+
)
chunkWords
[
i
]
|
=
bitmapWords
[
i
]
;
}
}
}
void
AtomMarkingRuntime
:
:
updateChunkMarkBits
(
JSRuntime
*
runtime
)
{
MOZ_ASSERT
(
runtime
-
>
currentThreadHasExclusiveAccess
(
)
)
;
Bitmap
markedUnion
;
if
(
EnsureBitmapLength
(
markedUnion
allocatedWords
)
)
{
for
(
ZonesIter
zone
(
runtime
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zone
-
>
isCollectingFromAnyThread
(
)
)
{
MOZ_ASSERT
(
zone
-
>
markedAtoms
(
)
.
length
(
)
<
=
allocatedWords
)
;
for
(
size_t
i
=
0
;
i
<
zone
-
>
markedAtoms
(
)
.
length
(
)
;
i
+
+
)
markedUnion
[
i
]
|
=
zone
-
>
markedAtoms
(
)
[
i
]
;
}
}
AddBitmapToChunkMarkBits
(
runtime
markedUnion
)
;
}
else
{
for
(
ZonesIter
zone
(
runtime
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zone
-
>
isCollectingFromAnyThread
(
)
)
AddBitmapToChunkMarkBits
(
runtime
zone
-
>
markedAtoms
(
)
)
;
}
}
}
static
inline
size_t
GetAtomBit
(
TenuredCell
*
thing
)
{
MOZ_ASSERT
(
thing
-
>
zoneFromAnyThread
(
)
-
>
isAtomsZone
(
)
)
;
Arena
*
arena
=
thing
-
>
arena
(
)
;
size_t
arenaBit
=
(
reinterpret_cast
<
uintptr_t
>
(
thing
)
-
arena
-
>
address
(
)
)
/
CellSize
;
return
arena
-
>
atomBitmapStart
(
)
*
JS_BITS_PER_WORD
+
arenaBit
;
}
static
bool
ThingIsPermanent
(
TenuredCell
*
thing
)
{
JS
:
:
TraceKind
kind
=
thing
-
>
getTraceKind
(
)
;
if
(
kind
=
=
JS
:
:
TraceKind
:
:
String
&
&
static_cast
<
JSString
*
>
(
thing
)
-
>
isPermanentAtom
(
)
)
return
true
;
if
(
kind
=
=
JS
:
:
TraceKind
:
:
Symbol
&
&
static_cast
<
JS
:
:
Symbol
*
>
(
thing
)
-
>
isWellKnownSymbol
(
)
)
return
true
;
return
false
;
}
void
AtomMarkingRuntime
:
:
markAtom
(
JSContext
*
cx
TenuredCell
*
thing
)
{
if
(
!
thing
|
|
!
cx
-
>
zone
(
)
)
return
;
MOZ_ASSERT
(
!
cx
-
>
zone
(
)
-
>
isAtomsZone
(
)
)
;
if
(
ThingIsPermanent
(
thing
)
|
|
!
thing
-
>
zoneFromAnyThread
(
)
-
>
isAtomsZone
(
)
)
return
;
size_t
bit
=
GetAtomBit
(
thing
)
;
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
EnsureBitmapLength
(
cx
-
>
zone
(
)
-
>
markedAtoms
(
)
allocatedWords
)
)
oomUnsafe
.
crash
(
"
Atom
bitmap
OOM
"
)
;
}
SetBit
(
cx
-
>
zone
(
)
-
>
markedAtoms
(
)
.
begin
(
)
bit
)
;
if
(
!
cx
-
>
helperThread
(
)
)
{
TenuredCell
:
:
readBarrier
(
thing
)
;
}
}
void
AtomMarkingRuntime
:
:
markId
(
JSContext
*
cx
jsid
id
)
{
if
(
JSID_IS_GCTHING
(
id
)
)
markAtom
(
cx
&
JSID_TO_GCTHING
(
id
)
.
asCell
(
)
-
>
asTenured
(
)
)
;
}
void
AtomMarkingRuntime
:
:
markAtomValue
(
JSContext
*
cx
const
Value
&
value
)
{
if
(
value
.
isGCThing
(
)
)
{
Cell
*
thing
=
value
.
toGCThing
(
)
;
if
(
thing
&
&
!
IsInsideNursery
(
thing
)
)
markAtom
(
cx
&
thing
-
>
asTenured
(
)
)
;
}
}
void
AtomMarkingRuntime
:
:
adoptMarkedAtoms
(
Zone
*
target
Zone
*
source
)
{
MOZ_ASSERT
(
target
-
>
runtimeFromAnyThread
(
)
-
>
currentThreadHasExclusiveAccess
(
)
)
;
Bitmap
*
targetBitmap
=
&
target
-
>
markedAtoms
(
)
;
Bitmap
*
sourceBitmap
=
&
source
-
>
markedAtoms
(
)
;
if
(
targetBitmap
-
>
length
(
)
<
sourceBitmap
-
>
length
(
)
)
std
:
:
swap
(
targetBitmap
sourceBitmap
)
;
for
(
size_t
i
=
0
;
i
<
sourceBitmap
-
>
length
(
)
;
i
+
+
)
(
*
targetBitmap
)
[
i
]
|
=
(
*
sourceBitmap
)
[
i
]
;
if
(
targetBitmap
!
=
&
target
-
>
markedAtoms
(
)
)
target
-
>
markedAtoms
(
)
=
Move
(
source
-
>
markedAtoms
(
)
)
;
else
source
-
>
markedAtoms
(
)
.
clear
(
)
;
}
#
ifdef
DEBUG
bool
AtomMarkingRuntime
:
:
atomIsMarked
(
Zone
*
zone
Cell
*
thingArg
)
{
if
(
!
thingArg
|
|
IsInsideNursery
(
thingArg
)
)
return
true
;
TenuredCell
*
thing
=
&
thingArg
-
>
asTenured
(
)
;
if
(
!
zone
-
>
runtimeFromAnyThread
(
)
-
>
permanentAtoms
)
return
true
;
if
(
ThingIsPermanent
(
thing
)
|
|
!
thing
-
>
zoneFromAnyThread
(
)
-
>
isAtomsZone
(
)
)
return
true
;
JS
:
:
TraceKind
kind
=
thing
-
>
getTraceKind
(
)
;
if
(
kind
=
=
JS
:
:
TraceKind
:
:
String
)
{
JSAtom
*
atom
=
static_cast
<
JSAtom
*
>
(
thing
)
;
if
(
AtomIsPinnedInRuntime
(
zone
-
>
runtimeFromAnyThread
(
)
atom
)
)
return
true
;
}
size_t
bit
=
GetAtomBit
(
thing
)
;
if
(
bit
>
=
zone
-
>
markedAtoms
(
)
.
length
(
)
*
JS_BITS_PER_WORD
)
return
false
;
return
GetBit
(
zone
-
>
markedAtoms
(
)
.
begin
(
)
bit
)
;
}
bool
AtomMarkingRuntime
:
:
idIsMarked
(
Zone
*
zone
jsid
id
)
{
if
(
JSID_IS_GCTHING
(
id
)
)
return
atomIsMarked
(
zone
JSID_TO_GCTHING
(
id
)
.
asCell
(
)
)
;
return
true
;
}
bool
AtomMarkingRuntime
:
:
valueIsMarked
(
Zone
*
zone
const
Value
&
value
)
{
if
(
value
.
isGCThing
(
)
)
return
atomIsMarked
(
zone
value
.
toGCThing
(
)
)
;
return
true
;
}
#
endif
}
#
ifdef
DEBUG
bool
AtomIsMarked
(
Zone
*
zone
JSAtom
*
atom
)
{
return
zone
-
>
runtimeFromAnyThread
(
)
-
>
gc
.
atomMarking
.
atomIsMarked
(
zone
atom
)
;
}
bool
AtomIsMarked
(
Zone
*
zone
jsid
id
)
{
return
zone
-
>
runtimeFromAnyThread
(
)
-
>
gc
.
atomMarking
.
idIsMarked
(
zone
id
)
;
}
bool
AtomIsMarked
(
Zone
*
zone
const
Value
&
value
)
{
return
zone
-
>
runtimeFromAnyThread
(
)
-
>
gc
.
atomMarking
.
valueIsMarked
(
zone
value
)
;
}
#
endif
}
