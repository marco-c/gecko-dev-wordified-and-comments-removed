#
include
"
gc
/
AtomMarking
-
inl
.
h
"
#
include
<
type_traits
>
#
include
"
gc
/
GCLock
.
h
"
#
include
"
gc
/
PublicIterators
.
h
"
#
include
"
gc
/
GC
-
inl
.
h
"
#
include
"
gc
/
Heap
-
inl
.
h
"
#
include
"
gc
/
PrivateIterators
-
inl
.
h
"
namespace
js
{
namespace
gc
{
size_t
AtomMarkingRuntime
:
:
allocateIndex
(
GCRuntime
*
gc
)
{
if
(
freeArenaIndexes
.
ref
(
)
.
empty
(
)
)
{
mergePendingFreeArenaIndexes
(
gc
)
;
}
if
(
!
freeArenaIndexes
.
ref
(
)
.
empty
(
)
)
{
return
freeArenaIndexes
.
ref
(
)
.
popCopy
(
)
;
}
size_t
index
=
allocatedWords
;
allocatedWords
+
=
ArenaBitmapWords
;
return
index
;
}
void
AtomMarkingRuntime
:
:
freeIndex
(
size_t
index
const
AutoLockGC
&
lock
)
{
MOZ_ASSERT
(
(
index
%
ArenaBitmapWords
)
=
=
0
)
;
MOZ_ASSERT
(
index
<
allocatedWords
)
;
bool
wasEmpty
=
pendingFreeArenaIndexes
.
ref
(
)
.
empty
(
)
;
MOZ_ASSERT_IF
(
wasEmpty
!
hasPendingFreeArenaIndexes
)
;
if
(
!
pendingFreeArenaIndexes
.
ref
(
)
.
append
(
index
)
)
{
return
;
}
if
(
wasEmpty
)
{
hasPendingFreeArenaIndexes
=
true
;
}
}
void
AtomMarkingRuntime
:
:
mergePendingFreeArenaIndexes
(
GCRuntime
*
gc
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
gc
-
>
rt
)
)
;
if
(
!
hasPendingFreeArenaIndexes
)
{
return
;
}
AutoLockGC
lock
(
gc
)
;
MOZ_ASSERT
(
!
pendingFreeArenaIndexes
.
ref
(
)
.
empty
(
)
)
;
hasPendingFreeArenaIndexes
=
false
;
if
(
freeArenaIndexes
.
ref
(
)
.
empty
(
)
)
{
std
:
:
swap
(
freeArenaIndexes
.
ref
(
)
pendingFreeArenaIndexes
.
ref
(
)
)
;
return
;
}
(
void
)
freeArenaIndexes
.
ref
(
)
.
appendAll
(
pendingFreeArenaIndexes
.
ref
(
)
)
;
pendingFreeArenaIndexes
.
ref
(
)
.
clear
(
)
;
}
void
AtomMarkingRuntime
:
:
refineZoneBitmapsForCollectedZones
(
GCRuntime
*
gc
)
{
size_t
collectedZones
=
0
;
for
(
ZonesIter
zone
(
gc
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
isCollecting
(
)
)
{
collectedZones
+
+
;
}
}
DenseBitmap
marked
;
if
(
collectedZones
>
1
&
&
computeBitmapFromChunkMarkBits
(
gc
marked
)
)
{
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
refineZoneBitmapForCollectedZone
(
zone
marked
)
;
}
return
;
}
for
(
GCZonesIter
zone
(
gc
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
zone
-
>
isAtomsZone
(
)
)
{
continue
;
}
for
(
auto
thingKind
:
AllAllocKinds
(
)
)
{
for
(
ArenaIterInGC
aiter
(
gc
-
>
atomsZone
(
)
thingKind
)
;
!
aiter
.
done
(
)
;
aiter
.
next
(
)
)
{
Arena
*
arena
=
aiter
.
get
(
)
;
AtomicBitmapWord
*
chunkWords
=
arena
-
>
chunk
(
)
-
>
markBits
.
arenaBits
(
arena
)
;
zone
-
>
markedAtoms
(
)
.
bitwiseAndRangeWith
(
arena
-
>
atomBitmapStart
(
)
ArenaBitmapWords
chunkWords
)
;
}
}
}
}
bool
AtomMarkingRuntime
:
:
computeBitmapFromChunkMarkBits
(
GCRuntime
*
gc
DenseBitmap
&
bitmap
)
{
MOZ_ASSERT
(
CurrentThreadIsPerformingGC
(
)
)
;
if
(
!
bitmap
.
ensureSpace
(
allocatedWords
)
)
{
return
false
;
}
Zone
*
atomsZone
=
gc
-
>
atomsZone
(
)
;
for
(
auto
thingKind
:
AllAllocKinds
(
)
)
{
for
(
ArenaIterInGC
aiter
(
atomsZone
thingKind
)
;
!
aiter
.
done
(
)
;
aiter
.
next
(
)
)
{
Arena
*
arena
=
aiter
.
get
(
)
;
AtomicBitmapWord
*
chunkWords
=
arena
-
>
chunk
(
)
-
>
markBits
.
arenaBits
(
arena
)
;
bitmap
.
copyBitsFrom
(
arena
-
>
atomBitmapStart
(
)
ArenaBitmapWords
chunkWords
)
;
}
}
return
true
;
}
void
AtomMarkingRuntime
:
:
refineZoneBitmapForCollectedZone
(
Zone
*
zone
const
DenseBitmap
&
bitmap
)
{
MOZ_ASSERT
(
zone
-
>
isCollectingFromAnyThread
(
)
)
;
if
(
zone
-
>
isAtomsZone
(
)
)
{
return
;
}
zone
-
>
markedAtoms
(
)
.
bitwiseAndWith
(
bitmap
)
;
}
template
<
typename
Bitmap
>
static
void
BitwiseOrIntoChunkMarkBits
(
Zone
*
atomsZone
Bitmap
&
bitmap
)
{
static_assert
(
ArenaBitmapBits
=
=
ArenaBitmapWords
*
JS_BITS_PER_WORD
"
ArenaBitmapWords
must
evenly
divide
ArenaBitmapBits
"
)
;
for
(
auto
thingKind
:
AllAllocKinds
(
)
)
{
for
(
ArenaIterInGC
aiter
(
atomsZone
thingKind
)
;
!
aiter
.
done
(
)
;
aiter
.
next
(
)
)
{
Arena
*
arena
=
aiter
.
get
(
)
;
AtomicBitmapWord
*
chunkWords
=
arena
-
>
chunk
(
)
-
>
markBits
.
arenaBits
(
arena
)
;
bitmap
.
bitwiseOrRangeInto
(
arena
-
>
atomBitmapStart
(
)
ArenaBitmapWords
chunkWords
)
;
}
}
}
UniquePtr
<
DenseBitmap
>
AtomMarkingRuntime
:
:
getOrMarkAtomsUsedByUncollectedZones
(
GCRuntime
*
gc
)
{
MOZ_ASSERT
(
CurrentThreadIsPerformingGC
(
)
)
;
UniquePtr
<
DenseBitmap
>
markedUnion
=
MakeUnique
<
DenseBitmap
>
(
)
;
if
(
!
markedUnion
|
|
!
markedUnion
-
>
ensureSpace
(
allocatedWords
)
)
{
for
(
ZonesIter
zone
(
gc
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zone
-
>
isCollecting
(
)
)
{
BitwiseOrIntoChunkMarkBits
(
gc
-
>
atomsZone
(
)
zone
-
>
markedAtoms
(
)
)
;
}
}
return
nullptr
;
}
for
(
ZonesIter
zone
(
gc
SkipAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zone
-
>
isCollecting
(
)
)
{
zone
-
>
markedAtoms
(
)
.
bitwiseOrInto
(
*
markedUnion
)
;
}
}
return
markedUnion
;
}
void
AtomMarkingRuntime
:
:
markAtomsUsedByUncollectedZones
(
GCRuntime
*
gc
UniquePtr
<
DenseBitmap
>
markedUnion
)
{
BitwiseOrIntoChunkMarkBits
(
gc
-
>
atomsZone
(
)
*
markedUnion
)
;
}
template
<
typename
T
>
void
AtomMarkingRuntime
:
:
markAtom
(
JSContext
*
cx
T
*
thing
)
{
return
inlinedMarkAtom
(
cx
thing
)
;
}
template
void
AtomMarkingRuntime
:
:
markAtom
(
JSContext
*
cx
JSAtom
*
thing
)
;
template
void
AtomMarkingRuntime
:
:
markAtom
(
JSContext
*
cx
JS
:
:
Symbol
*
thing
)
;
void
AtomMarkingRuntime
:
:
markId
(
JSContext
*
cx
jsid
id
)
{
if
(
id
.
isAtom
(
)
)
{
markAtom
(
cx
id
.
toAtom
(
)
)
;
return
;
}
if
(
id
.
isSymbol
(
)
)
{
markAtom
(
cx
id
.
toSymbol
(
)
)
;
return
;
}
MOZ_ASSERT
(
!
id
.
isGCThing
(
)
)
;
}
void
AtomMarkingRuntime
:
:
markAtomValue
(
JSContext
*
cx
const
Value
&
value
)
{
if
(
value
.
isString
(
)
)
{
if
(
value
.
toString
(
)
-
>
isAtom
(
)
)
{
markAtom
(
cx
&
value
.
toString
(
)
-
>
asAtom
(
)
)
;
}
return
;
}
if
(
value
.
isSymbol
(
)
)
{
markAtom
(
cx
value
.
toSymbol
(
)
)
;
return
;
}
MOZ_ASSERT_IF
(
value
.
isGCThing
(
)
value
.
isObject
(
)
|
|
value
.
isPrivateGCThing
(
)
|
|
value
.
isBigInt
(
)
)
;
}
template
<
typename
T
>
bool
AtomMarkingRuntime
:
:
atomIsMarked
(
Zone
*
zone
T
*
thing
)
{
static_assert
(
std
:
:
is_same_v
<
T
JSAtom
>
|
|
std
:
:
is_same_v
<
T
JS
:
:
Symbol
>
"
Should
only
be
called
with
JSAtom
*
or
JS
:
:
Symbol
*
argument
"
)
;
MOZ_ASSERT
(
thing
)
;
MOZ_ASSERT
(
!
IsInsideNursery
(
thing
)
)
;
MOZ_ASSERT
(
thing
-
>
zoneFromAnyThread
(
)
-
>
isAtomsZone
(
)
)
;
if
(
!
zone
-
>
runtimeFromAnyThread
(
)
-
>
permanentAtomsPopulated
(
)
)
{
return
true
;
}
if
(
thing
-
>
isPermanentAndMayBeShared
(
)
)
{
return
true
;
}
if
constexpr
(
std
:
:
is_same_v
<
T
JSAtom
>
)
{
if
(
thing
-
>
isPinned
(
)
)
{
return
true
;
}
}
size_t
bit
=
GetAtomBit
(
&
thing
-
>
asTenured
(
)
)
;
return
zone
-
>
markedAtoms
(
)
.
readonlyThreadsafeGetBit
(
bit
)
;
}
template
bool
AtomMarkingRuntime
:
:
atomIsMarked
(
Zone
*
zone
JSAtom
*
thing
)
;
template
bool
AtomMarkingRuntime
:
:
atomIsMarked
(
Zone
*
zone
JS
:
:
Symbol
*
thing
)
;
#
ifdef
DEBUG
template
<
>
bool
AtomMarkingRuntime
:
:
atomIsMarked
(
Zone
*
zone
TenuredCell
*
thing
)
{
if
(
!
thing
)
{
return
true
;
}
if
(
thing
-
>
is
<
JSString
>
(
)
)
{
JSString
*
str
=
thing
-
>
as
<
JSString
>
(
)
;
if
(
!
str
-
>
isAtom
(
)
)
{
return
true
;
}
return
atomIsMarked
(
zone
&
str
-
>
asAtom
(
)
)
;
}
if
(
thing
-
>
is
<
JS
:
:
Symbol
>
(
)
)
{
return
atomIsMarked
(
zone
thing
-
>
as
<
JS
:
:
Symbol
>
(
)
)
;
}
return
true
;
}
bool
AtomMarkingRuntime
:
:
idIsMarked
(
Zone
*
zone
jsid
id
)
{
if
(
id
.
isAtom
(
)
)
{
return
atomIsMarked
(
zone
id
.
toAtom
(
)
)
;
}
if
(
id
.
isSymbol
(
)
)
{
return
atomIsMarked
(
zone
id
.
toSymbol
(
)
)
;
}
MOZ_ASSERT
(
!
id
.
isGCThing
(
)
)
;
return
true
;
}
bool
AtomMarkingRuntime
:
:
valueIsMarked
(
Zone
*
zone
const
Value
&
value
)
{
if
(
value
.
isString
(
)
)
{
if
(
value
.
toString
(
)
-
>
isAtom
(
)
)
{
return
atomIsMarked
(
zone
&
value
.
toString
(
)
-
>
asAtom
(
)
)
;
}
return
true
;
}
if
(
value
.
isSymbol
(
)
)
{
return
atomIsMarked
(
zone
value
.
toSymbol
(
)
)
;
}
MOZ_ASSERT_IF
(
value
.
isGCThing
(
)
value
.
isObject
(
)
|
|
value
.
isPrivateGCThing
(
)
|
|
value
.
isBigInt
(
)
)
;
return
true
;
}
#
endif
}
#
ifdef
DEBUG
bool
AtomIsMarked
(
Zone
*
zone
JSAtom
*
atom
)
{
return
zone
-
>
runtimeFromAnyThread
(
)
-
>
gc
.
atomMarking
.
atomIsMarked
(
zone
atom
)
;
}
bool
AtomIsMarked
(
Zone
*
zone
jsid
id
)
{
return
zone
-
>
runtimeFromAnyThread
(
)
-
>
gc
.
atomMarking
.
idIsMarked
(
zone
id
)
;
}
bool
AtomIsMarked
(
Zone
*
zone
const
Value
&
value
)
{
return
zone
-
>
runtimeFromAnyThread
(
)
-
>
gc
.
atomMarking
.
valueIsMarked
(
zone
value
)
;
}
#
endif
}
