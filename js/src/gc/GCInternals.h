#
ifndef
gc_GCInternals_h
#
define
gc_GCInternals_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
vm
/
HelperThreads
.
h
"
#
include
"
vm
/
Runtime
.
h
"
namespace
js
{
namespace
gc
{
void
FinishGC
(
JSRuntime
*
rt
)
;
class
MOZ_RAII
AutoTraceSession
{
public
:
explicit
AutoTraceSession
(
JSRuntime
*
rt
JS
:
:
HeapState
state
=
JS
:
:
HeapState
:
:
Tracing
)
;
~
AutoTraceSession
(
)
;
AutoLockForExclusiveAccess
lock
;
protected
:
JSRuntime
*
runtime
;
private
:
AutoTraceSession
(
const
AutoTraceSession
&
)
=
delete
;
void
operator
=
(
const
AutoTraceSession
&
)
=
delete
;
JS
:
:
HeapState
prevState
;
AutoSPSEntry
pseudoFrame
;
}
;
class
MOZ_RAII
AutoPrepareForTracing
{
mozilla
:
:
Maybe
<
AutoTraceSession
>
session_
;
public
:
AutoPrepareForTracing
(
JSRuntime
*
rt
ZoneSelector
selector
)
;
AutoTraceSession
&
session
(
)
{
return
session_
.
ref
(
)
;
}
}
;
class
IncrementalSafety
{
const
char
*
reason_
;
explicit
IncrementalSafety
(
const
char
*
reason
)
:
reason_
(
reason
)
{
}
public
:
static
IncrementalSafety
Safe
(
)
{
return
IncrementalSafety
(
nullptr
)
;
}
static
IncrementalSafety
Unsafe
(
const
char
*
reason
)
{
return
IncrementalSafety
(
reason
)
;
}
explicit
operator
bool
(
)
const
{
return
reason_
=
=
nullptr
;
}
const
char
*
reason
(
)
{
MOZ_ASSERT
(
reason_
)
;
return
reason_
;
}
}
;
IncrementalSafety
IsIncrementalGCSafe
(
JSRuntime
*
rt
)
;
#
ifdef
JS_GC_ZEAL
class
MOZ_RAII
AutoStopVerifyingBarriers
{
GCRuntime
*
gc
;
bool
restartPreVerifier
;
public
:
AutoStopVerifyingBarriers
(
JSRuntime
*
rt
bool
isShutdown
)
:
gc
(
&
rt
-
>
gc
)
{
if
(
gc
-
>
isVerifyPreBarriersEnabled
(
)
)
{
gc
-
>
endVerifyPreBarriers
(
)
;
restartPreVerifier
=
!
isShutdown
;
}
else
{
restartPreVerifier
=
false
;
}
}
~
AutoStopVerifyingBarriers
(
)
{
gcstats
:
:
Phase
outer
=
gc
-
>
stats
.
currentPhase
(
)
;
if
(
outer
!
=
gcstats
:
:
PHASE_NONE
)
gc
-
>
stats
.
endPhase
(
outer
)
;
MOZ_ASSERT
(
(
gc
-
>
stats
.
currentPhase
(
)
=
=
gcstats
:
:
PHASE_NONE
)
|
|
(
gc
-
>
stats
.
currentPhase
(
)
=
=
gcstats
:
:
PHASE_GC_BEGIN
)
|
|
(
gc
-
>
stats
.
currentPhase
(
)
=
=
gcstats
:
:
PHASE_GC_END
)
)
;
if
(
restartPreVerifier
)
gc
-
>
startVerifyPreBarriers
(
)
;
if
(
outer
!
=
gcstats
:
:
PHASE_NONE
)
gc
-
>
stats
.
beginPhase
(
outer
)
;
}
}
;
#
else
struct
MOZ_RAII
AutoStopVerifyingBarriers
{
AutoStopVerifyingBarriers
(
JSRuntime
*
bool
)
{
}
}
;
#
endif
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
CheckHashTablesAfterMovingGC
(
JSRuntime
*
rt
)
;
void
CheckHeapAfterMovingGC
(
JSRuntime
*
rt
AutoLockForExclusiveAccess
&
lock
)
;
#
endif
struct
MovingTracer
:
JS
:
:
CallbackTracer
{
explicit
MovingTracer
(
JSRuntime
*
rt
)
:
CallbackTracer
(
rt
TraceWeakMapKeysValues
)
{
}
void
onObjectEdge
(
JSObject
*
*
objp
)
override
;
void
onShapeEdge
(
Shape
*
*
shapep
)
override
;
void
onStringEdge
(
JSString
*
*
stringp
)
override
;
void
onScriptEdge
(
JSScript
*
*
scriptp
)
override
;
void
onLazyScriptEdge
(
LazyScript
*
*
lazyp
)
override
;
void
onBaseShapeEdge
(
BaseShape
*
*
basep
)
override
;
void
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
override
{
MOZ_ASSERT
(
!
RelocationOverlay
:
:
isCellForwarded
(
thing
.
asCell
(
)
)
)
;
}
#
ifdef
DEBUG
TracerKind
getTracerKind
(
)
const
override
{
return
TracerKind
:
:
Moving
;
}
#
endif
}
;
class
MOZ_RAII
AutoMaybeStartBackgroundAllocation
{
private
:
JSRuntime
*
runtime
;
public
:
AutoMaybeStartBackgroundAllocation
(
)
:
runtime
(
nullptr
)
{
}
void
tryToStartBackgroundAllocation
(
JSRuntime
*
rt
)
{
runtime
=
rt
;
}
~
AutoMaybeStartBackgroundAllocation
(
)
{
if
(
runtime
)
runtime
-
>
gc
.
startBackgroundAllocTaskIfIdle
(
)
;
}
}
;
struct
MOZ_RAII
AutoSetThreadIsSweeping
{
#
ifdef
DEBUG
AutoSetThreadIsSweeping
(
)
:
threadData_
(
js
:
:
TlsPerThreadData
.
get
(
)
)
{
MOZ_ASSERT
(
!
threadData_
-
>
gcSweeping
)
;
threadData_
-
>
gcSweeping
=
true
;
}
~
AutoSetThreadIsSweeping
(
)
{
MOZ_ASSERT
(
threadData_
-
>
gcSweeping
)
;
threadData_
-
>
gcSweeping
=
false
;
}
private
:
PerThreadData
*
threadData_
;
#
else
AutoSetThreadIsSweeping
(
)
{
}
#
endif
}
;
struct
TenureCount
{
ObjectGroup
*
group
;
int
count
;
}
;
struct
TenureCountCache
{
TenureCount
entries
[
16
]
;
TenureCountCache
(
)
{
mozilla
:
:
PodZero
(
this
)
;
}
TenureCount
&
findEntry
(
ObjectGroup
*
group
)
{
return
entries
[
PointerHasher
<
ObjectGroup
*
3
>
:
:
hash
(
group
)
%
mozilla
:
:
ArrayLength
(
entries
)
]
;
}
}
;
}
}
#
endif
