#
ifndef
gc_GCInternals_h
#
define
gc_GCInternals_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
gc
/
GC
.
h
"
#
include
"
vm
/
JSContext
.
h
"
namespace
js
{
namespace
gc
{
struct
MOZ_RAII
AutoAssertNoNurseryAlloc
{
#
ifdef
DEBUG
AutoAssertNoNurseryAlloc
(
)
;
~
AutoAssertNoNurseryAlloc
(
)
;
#
else
AutoAssertNoNurseryAlloc
(
)
{
}
#
endif
}
;
class
MOZ_RAII
AutoAssertEmptyNursery
{
protected
:
JSContext
*
cx
;
mozilla
:
:
Maybe
<
AutoAssertNoNurseryAlloc
>
noAlloc
;
void
checkCondition
(
JSContext
*
cx
)
;
AutoAssertEmptyNursery
(
)
:
cx
(
nullptr
)
{
}
public
:
explicit
AutoAssertEmptyNursery
(
JSContext
*
cx
)
:
cx
(
nullptr
)
{
checkCondition
(
cx
)
;
}
AutoAssertEmptyNursery
(
const
AutoAssertEmptyNursery
&
other
)
:
AutoAssertEmptyNursery
(
other
.
cx
)
{
}
}
;
class
MOZ_RAII
AutoEmptyNursery
:
public
AutoAssertEmptyNursery
{
public
:
explicit
AutoEmptyNursery
(
JSContext
*
cx
)
;
}
;
class
MOZ_RAII
AutoCheckCanAccessAtomsDuringGC
{
#
ifdef
DEBUG
JSRuntime
*
runtime
;
public
:
explicit
AutoCheckCanAccessAtomsDuringGC
(
JSRuntime
*
rt
)
:
runtime
(
rt
)
{
MOZ_ASSERT
(
JS
:
:
RuntimeHeapIsMajorCollecting
(
)
)
;
MOZ_ASSERT
(
!
rt
-
>
hasHelperThreadZones
(
)
)
;
runtime
-
>
setOffThreadParsingBlocked
(
true
)
;
}
~
AutoCheckCanAccessAtomsDuringGC
(
)
{
runtime
-
>
setOffThreadParsingBlocked
(
false
)
;
}
#
else
public
:
explicit
AutoCheckCanAccessAtomsDuringGC
(
JSRuntime
*
rt
)
{
}
#
endif
}
;
class
MOZ_RAII
AutoHeapSession
{
public
:
~
AutoHeapSession
(
)
;
protected
:
AutoHeapSession
(
GCRuntime
*
gc
JS
:
:
HeapState
state
)
;
private
:
AutoHeapSession
(
const
AutoHeapSession
&
)
=
delete
;
void
operator
=
(
const
AutoHeapSession
&
)
=
delete
;
GCRuntime
*
gc
;
JS
:
:
HeapState
prevState
;
mozilla
:
:
Maybe
<
AutoGeckoProfilerEntry
>
profilingStackFrame
;
}
;
class
MOZ_RAII
AutoGCSession
:
public
AutoHeapSession
{
public
:
explicit
AutoGCSession
(
GCRuntime
*
gc
JS
:
:
HeapState
state
)
:
AutoHeapSession
(
gc
state
)
{
}
AutoCheckCanAccessAtomsDuringGC
&
checkAtomsAccess
(
)
{
return
maybeCheckAtomsAccess
.
ref
(
)
;
}
mozilla
:
:
Maybe
<
AutoCheckCanAccessAtomsDuringGC
>
maybeCheckAtomsAccess
;
}
;
class
MOZ_RAII
AutoMajorGCProfilerEntry
:
public
AutoGeckoProfilerEntry
{
public
:
explicit
AutoMajorGCProfilerEntry
(
GCRuntime
*
gc
)
;
}
;
class
MOZ_RAII
AutoTraceSession
:
public
AutoLockAllAtoms
public
AutoHeapSession
{
public
:
explicit
AutoTraceSession
(
JSRuntime
*
rt
)
:
AutoLockAllAtoms
(
rt
)
AutoHeapSession
(
&
rt
-
>
gc
JS
:
:
HeapState
:
:
Tracing
)
{
}
}
;
struct
MOZ_RAII
AutoFinishGC
{
explicit
AutoFinishGC
(
JSContext
*
cx
JS
:
:
GCReason
reason
)
{
FinishGC
(
cx
reason
)
;
}
}
;
class
MOZ_RAII
AutoPrepareForTracing
:
private
AutoFinishGC
public
AutoTraceSession
{
public
:
explicit
AutoPrepareForTracing
(
JSContext
*
cx
)
:
AutoFinishGC
(
cx
JS
:
:
GCReason
:
:
PREPARE_FOR_TRACING
)
AutoTraceSession
(
cx
-
>
runtime
(
)
)
{
}
}
;
class
MOZ_RAII
AutoEmptyNurseryAndPrepareForTracing
:
private
AutoFinishGC
public
AutoEmptyNursery
public
AutoTraceSession
{
public
:
explicit
AutoEmptyNurseryAndPrepareForTracing
(
JSContext
*
cx
)
:
AutoFinishGC
(
cx
JS
:
:
GCReason
:
:
PREPARE_FOR_TRACING
)
AutoEmptyNursery
(
cx
)
AutoTraceSession
(
cx
-
>
runtime
(
)
)
{
}
}
;
class
AutoDisableBarriers
{
public
:
explicit
AutoDisableBarriers
(
GCRuntime
*
gc
)
;
~
AutoDisableBarriers
(
)
;
private
:
GCRuntime
*
gc
;
}
;
GCAbortReason
IsIncrementalGCUnsafe
(
JSRuntime
*
rt
)
;
#
ifdef
JS_GC_ZEAL
class
MOZ_RAII
AutoStopVerifyingBarriers
{
GCRuntime
*
gc
;
bool
restartPreVerifier
;
public
:
AutoStopVerifyingBarriers
(
JSRuntime
*
rt
bool
isShutdown
)
:
gc
(
&
rt
-
>
gc
)
{
if
(
gc
-
>
isVerifyPreBarriersEnabled
(
)
)
{
gc
-
>
endVerifyPreBarriers
(
)
;
restartPreVerifier
=
!
isShutdown
;
}
else
{
restartPreVerifier
=
false
;
}
}
~
AutoStopVerifyingBarriers
(
)
{
gcstats
:
:
PhaseKind
outer
=
gc
-
>
stats
(
)
.
currentPhaseKind
(
)
;
if
(
outer
!
=
gcstats
:
:
PhaseKind
:
:
NONE
)
{
gc
-
>
stats
(
)
.
endPhase
(
outer
)
;
}
MOZ_ASSERT
(
gc
-
>
stats
(
)
.
currentPhaseKind
(
)
=
=
gcstats
:
:
PhaseKind
:
:
NONE
)
;
if
(
restartPreVerifier
)
{
gc
-
>
startVerifyPreBarriers
(
)
;
}
if
(
outer
!
=
gcstats
:
:
PhaseKind
:
:
NONE
)
{
gc
-
>
stats
(
)
.
beginPhase
(
outer
)
;
}
}
}
;
#
else
struct
MOZ_RAII
AutoStopVerifyingBarriers
{
AutoStopVerifyingBarriers
(
JSRuntime
*
bool
)
{
}
}
;
#
endif
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
CheckHashTablesAfterMovingGC
(
JSRuntime
*
rt
)
;
void
CheckHeapAfterGC
(
JSRuntime
*
rt
)
;
#
endif
struct
MovingTracer
final
:
public
GenericTracer
{
explicit
MovingTracer
(
JSRuntime
*
rt
)
:
GenericTracer
(
rt
JS
:
:
TracerKind
:
:
Moving
JS
:
:
WeakMapTraceAction
:
:
TraceKeysAndValues
)
{
}
JSObject
*
onObjectEdge
(
JSObject
*
obj
)
override
;
Shape
*
onShapeEdge
(
Shape
*
shape
)
override
;
JSString
*
onStringEdge
(
JSString
*
string
)
override
;
js
:
:
BaseScript
*
onScriptEdge
(
js
:
:
BaseScript
*
script
)
override
;
BaseShape
*
onBaseShapeEdge
(
BaseShape
*
base
)
override
;
Scope
*
onScopeEdge
(
Scope
*
scope
)
override
;
RegExpShared
*
onRegExpSharedEdge
(
RegExpShared
*
shared
)
override
;
BigInt
*
onBigIntEdge
(
BigInt
*
bi
)
override
;
ObjectGroup
*
onObjectGroupEdge
(
ObjectGroup
*
group
)
override
;
JS
:
:
Symbol
*
onSymbolEdge
(
JS
:
:
Symbol
*
sym
)
override
;
jit
:
:
JitCode
*
onJitCodeEdge
(
jit
:
:
JitCode
*
jit
)
override
;
private
:
template
<
typename
T
>
T
*
onEdge
(
T
*
thingp
)
;
}
;
struct
SweepingTracer
final
:
public
GenericTracer
{
explicit
SweepingTracer
(
JSRuntime
*
rt
)
:
GenericTracer
(
rt
JS
:
:
TracerKind
:
:
Sweeping
JS
:
:
WeakMapTraceAction
:
:
TraceKeysAndValues
)
{
}
JSObject
*
onObjectEdge
(
JSObject
*
obj
)
override
;
Shape
*
onShapeEdge
(
Shape
*
shape
)
override
;
JSString
*
onStringEdge
(
JSString
*
string
)
override
;
js
:
:
BaseScript
*
onScriptEdge
(
js
:
:
BaseScript
*
script
)
override
;
BaseShape
*
onBaseShapeEdge
(
BaseShape
*
base
)
override
;
jit
:
:
JitCode
*
onJitCodeEdge
(
jit
:
:
JitCode
*
jit
)
override
;
Scope
*
onScopeEdge
(
Scope
*
scope
)
override
;
RegExpShared
*
onRegExpSharedEdge
(
RegExpShared
*
shared
)
override
;
BigInt
*
onBigIntEdge
(
BigInt
*
bi
)
override
;
js
:
:
ObjectGroup
*
onObjectGroupEdge
(
js
:
:
ObjectGroup
*
group
)
override
;
JS
:
:
Symbol
*
onSymbolEdge
(
JS
:
:
Symbol
*
sym
)
override
;
private
:
template
<
typename
T
>
T
*
onEdge
(
T
*
thingp
)
;
}
;
struct
TenureCount
{
ObjectGroup
*
group
;
unsigned
count
;
}
JS_HAZ_NON_GC_POINTER
;
extern
void
DelayCrossCompartmentGrayMarking
(
JSObject
*
src
)
;
inline
bool
IsOOMReason
(
JS
:
:
GCReason
reason
)
{
return
reason
=
=
JS
:
:
GCReason
:
:
LAST_DITCH
|
|
reason
=
=
JS
:
:
GCReason
:
:
MEM_PRESSURE
;
}
inline
bool
IsShutdownReason
(
JS
:
:
GCReason
reason
)
{
return
reason
=
=
JS
:
:
GCReason
:
:
WORKER_SHUTDOWN
|
|
reason
=
=
JS
:
:
GCReason
:
:
SHUTDOWN_CC
|
|
reason
=
=
JS
:
:
GCReason
:
:
DESTROY_RUNTIME
;
}
TenuredCell
*
AllocateCellInGC
(
JS
:
:
Zone
*
zone
AllocKind
thingKind
)
;
}
}
#
endif
