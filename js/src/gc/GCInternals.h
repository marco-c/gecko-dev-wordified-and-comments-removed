#
ifndef
gc_GCInternals_h
#
define
gc_GCInternals_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
vm
/
HelperThreads
.
h
"
#
include
"
vm
/
Runtime
.
h
"
namespace
js
{
namespace
gc
{
void
FinishGC
(
JSContext
*
cx
)
;
class
MOZ_RAII
AutoTraceSession
{
public
:
explicit
AutoTraceSession
(
JSRuntime
*
rt
JS
:
:
HeapState
state
=
JS
:
:
HeapState
:
:
Tracing
)
;
~
AutoTraceSession
(
)
;
AutoLockForExclusiveAccess
lock
;
protected
:
JSRuntime
*
runtime
;
private
:
AutoTraceSession
(
const
AutoTraceSession
&
)
=
delete
;
void
operator
=
(
const
AutoTraceSession
&
)
=
delete
;
JS
:
:
HeapState
prevState
;
AutoSPSEntry
pseudoFrame
;
}
;
class
MOZ_RAII
AutoPrepareForTracing
{
mozilla
:
:
Maybe
<
AutoTraceSession
>
session_
;
public
:
AutoPrepareForTracing
(
JSContext
*
cx
ZoneSelector
selector
)
;
AutoTraceSession
&
session
(
)
{
return
session_
.
ref
(
)
;
}
}
;
class
IncrementalSafety
{
const
char
*
reason_
;
explicit
IncrementalSafety
(
const
char
*
reason
)
:
reason_
(
reason
)
{
}
public
:
static
IncrementalSafety
Safe
(
)
{
return
IncrementalSafety
(
nullptr
)
;
}
static
IncrementalSafety
Unsafe
(
const
char
*
reason
)
{
return
IncrementalSafety
(
reason
)
;
}
explicit
operator
bool
(
)
const
{
return
reason_
=
=
nullptr
;
}
const
char
*
reason
(
)
{
MOZ_ASSERT
(
reason_
)
;
return
reason_
;
}
}
;
IncrementalSafety
IsIncrementalGCSafe
(
JSRuntime
*
rt
)
;
#
ifdef
JS_GC_ZEAL
class
MOZ_RAII
AutoStopVerifyingBarriers
{
GCRuntime
*
gc
;
bool
restartPreVerifier
;
public
:
AutoStopVerifyingBarriers
(
JSRuntime
*
rt
bool
isShutdown
)
:
gc
(
&
rt
-
>
gc
)
{
if
(
gc
-
>
isVerifyPreBarriersEnabled
(
)
)
{
gc
-
>
endVerifyPreBarriers
(
)
;
restartPreVerifier
=
!
isShutdown
;
}
else
{
restartPreVerifier
=
false
;
}
}
~
AutoStopVerifyingBarriers
(
)
{
gcstats
:
:
Phase
outer
=
gc
-
>
stats
.
currentPhase
(
)
;
if
(
outer
!
=
gcstats
:
:
PHASE_NONE
)
gc
-
>
stats
.
endPhase
(
outer
)
;
MOZ_ASSERT
(
(
gc
-
>
stats
.
currentPhase
(
)
=
=
gcstats
:
:
PHASE_NONE
)
|
|
(
gc
-
>
stats
.
currentPhase
(
)
=
=
gcstats
:
:
PHASE_GC_BEGIN
)
|
|
(
gc
-
>
stats
.
currentPhase
(
)
=
=
gcstats
:
:
PHASE_GC_END
)
)
;
if
(
restartPreVerifier
)
gc
-
>
startVerifyPreBarriers
(
)
;
if
(
outer
!
=
gcstats
:
:
PHASE_NONE
)
gc
-
>
stats
.
beginPhase
(
outer
)
;
}
}
;
#
else
struct
MOZ_RAII
AutoStopVerifyingBarriers
{
AutoStopVerifyingBarriers
(
JSRuntime
*
bool
)
{
}
}
;
#
endif
#
ifdef
JSGC_HASH_TABLE_CHECKS
void
CheckHashTablesAfterMovingGC
(
JSRuntime
*
rt
)
;
void
CheckHeapAfterGC
(
JSRuntime
*
rt
)
;
#
endif
struct
MovingTracer
:
JS
:
:
CallbackTracer
{
explicit
MovingTracer
(
JSRuntime
*
rt
)
:
CallbackTracer
(
rt
TraceWeakMapKeysValues
)
{
}
void
onObjectEdge
(
JSObject
*
*
objp
)
override
;
void
onShapeEdge
(
Shape
*
*
shapep
)
override
;
void
onStringEdge
(
JSString
*
*
stringp
)
override
;
void
onScriptEdge
(
JSScript
*
*
scriptp
)
override
;
void
onLazyScriptEdge
(
LazyScript
*
*
lazyp
)
override
;
void
onBaseShapeEdge
(
BaseShape
*
*
basep
)
override
;
void
onScopeEdge
(
Scope
*
*
basep
)
override
;
void
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
override
{
MOZ_ASSERT
(
!
RelocationOverlay
:
:
isCellForwarded
(
thing
.
asCell
(
)
)
)
;
}
#
ifdef
DEBUG
TracerKind
getTracerKind
(
)
const
override
{
return
TracerKind
:
:
Moving
;
}
#
endif
}
;
struct
TenureCount
{
ObjectGroup
*
group
;
int
count
;
}
;
struct
TenureCountCache
{
static
const
size_t
EntryShift
=
4
;
static
const
size_t
EntryCount
=
1
<
<
EntryShift
;
TenureCount
entries
[
EntryCount
]
;
TenureCountCache
(
)
{
mozilla
:
:
PodZero
(
this
)
;
}
HashNumber
hash
(
ObjectGroup
*
group
)
{
#
if
JS_BITS_PER_WORD
=
=
32
static
const
size_t
ZeroBits
=
3
;
#
else
static
const
size_t
ZeroBits
=
4
;
#
endif
uintptr_t
word
=
uintptr_t
(
group
)
;
MOZ_ASSERT
(
(
word
&
(
(
1
<
<
ZeroBits
)
-
1
)
)
=
=
0
)
;
word
>
>
=
ZeroBits
;
return
HashNumber
(
(
word
>
>
EntryShift
)
^
word
)
;
}
TenureCount
&
findEntry
(
ObjectGroup
*
group
)
{
return
entries
[
hash
(
group
)
%
EntryCount
]
;
}
}
;
}
}
#
endif
