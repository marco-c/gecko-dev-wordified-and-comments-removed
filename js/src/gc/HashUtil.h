#
ifndef
gc_HashUtil_h
#
define
gc_HashUtil_h
#
include
<
type_traits
>
#
include
"
gc
/
Zone
.
h
"
#
include
"
vm
/
JSContext
.
h
"
namespace
js
{
template
<
class
T
>
struct
DependentAddPtr
{
typedef
typename
T
:
:
AddPtr
AddPtr
;
typedef
typename
T
:
:
Entry
Entry
;
template
<
class
Lookup
>
DependentAddPtr
(
const
JSContext
*
cx
T
&
table
const
Lookup
&
lookup
)
:
addPtr
(
table
.
lookupForAdd
(
lookup
)
)
originalGcNumber
(
cx
-
>
zone
(
)
-
>
gcNumber
(
)
)
{
}
DependentAddPtr
(
DependentAddPtr
&
&
other
)
:
addPtr
(
other
.
addPtr
)
originalGcNumber
(
other
.
originalGcNumber
)
{
}
template
<
class
KeyInput
class
ValueInput
>
bool
add
(
JSContext
*
cx
T
&
table
const
KeyInput
&
key
const
ValueInput
&
value
)
{
refreshAddPtr
(
cx
table
key
)
;
if
(
!
table
.
relookupOrAdd
(
addPtr
key
value
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
template
<
class
KeyInput
>
void
remove
(
JSContext
*
cx
T
&
table
const
KeyInput
&
key
)
{
refreshAddPtr
(
cx
table
key
)
;
if
(
addPtr
)
{
table
.
remove
(
addPtr
)
;
}
}
bool
found
(
)
const
{
return
addPtr
.
found
(
)
;
}
explicit
operator
bool
(
)
const
{
return
found
(
)
;
}
const
Entry
&
operator
*
(
)
const
{
return
*
addPtr
;
}
const
Entry
*
operator
-
>
(
)
const
{
return
&
*
addPtr
;
}
private
:
AddPtr
addPtr
;
const
uint64_t
originalGcNumber
;
template
<
class
KeyInput
>
void
refreshAddPtr
(
JSContext
*
cx
T
&
table
const
KeyInput
&
key
)
{
bool
gcHappened
=
originalGcNumber
!
=
cx
-
>
zone
(
)
-
>
gcNumber
(
)
;
if
(
gcHappened
)
{
addPtr
=
table
.
lookupForAdd
(
key
)
;
}
}
DependentAddPtr
(
)
=
delete
;
DependentAddPtr
(
const
DependentAddPtr
&
)
=
delete
;
DependentAddPtr
&
operator
=
(
const
DependentAddPtr
&
)
=
delete
;
}
;
template
<
typename
T
typename
Lookup
>
inline
auto
MakeDependentAddPtr
(
const
JSContext
*
cx
T
&
table
const
Lookup
&
lookup
)
{
using
Ptr
=
DependentAddPtr
<
std
:
:
remove_reference_t
<
decltype
(
table
)
>
>
;
return
Ptr
(
cx
table
lookup
)
;
}
}
#
endif
