#
ifndef
gc_Pretenuring_h
#
define
gc_Pretenuring_h
#
include
<
algorithm
>
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
class
JS_PUBLIC_API
JSTracer
;
namespace
JS
{
enum
class
GCReason
;
}
namespace
js
{
namespace
gc
{
class
GCRuntime
;
class
PretenuringNursery
;
static
constexpr
size_t
NurseryTraceKinds
=
3
;
enum
class
CatchAllAllocSite
{
Unknown
Optimized
}
;
class
AllocSite
{
public
:
enum
class
State
:
uint32_t
{
ShortLived
=
0
Unknown
=
1
LongLived
=
2
}
;
static
constexpr
int32_t
LONG_LIVED_BIT
=
int32_t
(
State
:
:
LongLived
)
;
static_assert
(
(
LONG_LIVED_BIT
&
int32_t
(
State
:
:
Unknown
)
)
=
=
0
)
;
static_assert
(
(
AllocSite
:
:
LONG_LIVED_BIT
&
int32_t
(
State
:
:
ShortLived
)
)
=
=
0
)
;
private
:
JS
:
:
Zone
*
zone_
=
nullptr
;
uintptr_t
scriptAndState
=
uintptr_t
(
State
:
:
Unknown
)
;
static
constexpr
uintptr_t
STATE_MASK
=
BitMask
(
2
)
;
AllocSite
*
nextNurseryAllocated
=
nullptr
;
uint32_t
nurseryAllocCount
=
0
;
uint32_t
nurseryTenuredCount
:
24
;
uint32_t
invalidationCount
:
4
;
uint32_t
traceKind_
:
4
;
static
AllocSite
*
const
EndSentinel
;
static
JSScript
*
const
WasmScript
;
friend
class
PretenuringZone
;
friend
class
PretenuringNursery
;
uintptr_t
rawScript
(
)
const
{
return
scriptAndState
&
~
STATE_MASK
;
}
public
:
AllocSite
(
)
:
nurseryTenuredCount
(
0
)
invalidationCount
(
0
)
traceKind_
(
0
)
{
}
explicit
AllocSite
(
JS
:
:
Zone
*
zone
JS
:
:
TraceKind
kind
)
:
zone_
(
zone
)
nurseryTenuredCount
(
0
)
invalidationCount
(
0
)
traceKind_
(
uint32_t
(
kind
)
)
{
MOZ_ASSERT
(
traceKind_
<
NurseryTraceKinds
)
;
}
AllocSite
(
JS
:
:
Zone
*
zone
JSScript
*
script
JS
:
:
TraceKind
kind
)
:
AllocSite
(
zone
kind
)
{
MOZ_ASSERT
(
script
!
=
WasmScript
)
;
setScript
(
script
)
;
}
void
initUnknownSite
(
JS
:
:
Zone
*
zone
JS
:
:
TraceKind
kind
)
{
MOZ_ASSERT
(
!
zone_
&
&
scriptAndState
=
=
uintptr_t
(
State
:
:
Unknown
)
)
;
zone_
=
zone
;
nurseryTenuredCount
=
0
;
invalidationCount
=
0
;
traceKind_
=
uint32_t
(
kind
)
;
MOZ_ASSERT
(
traceKind_
<
NurseryTraceKinds
)
;
}
void
initWasm
(
JS
:
:
Zone
*
zone
)
{
MOZ_ASSERT
(
!
zone_
&
&
scriptAndState
=
=
uintptr_t
(
State
:
:
Unknown
)
)
;
zone_
=
zone
;
setScript
(
WasmScript
)
;
nurseryTenuredCount
=
0
;
invalidationCount
=
0
;
traceKind_
=
uint32_t
(
JS
:
:
TraceKind
:
:
Object
)
;
}
JS
:
:
Zone
*
zone
(
)
const
{
return
zone_
;
}
JS
:
:
TraceKind
traceKind
(
)
const
{
return
JS
:
:
TraceKind
(
traceKind_
)
;
}
State
state
(
)
const
{
return
State
(
scriptAndState
&
STATE_MASK
)
;
}
bool
hasScript
(
)
const
{
return
rawScript
(
)
!
=
uintptr_t
(
WasmScript
)
;
}
JSScript
*
script
(
)
const
{
MOZ_ASSERT
(
hasScript
(
)
)
;
return
reinterpret_cast
<
JSScript
*
>
(
rawScript
(
)
)
;
}
bool
isNormal
(
)
const
{
return
rawScript
(
)
!
=
0
;
}
enum
class
Kind
:
uint32_t
{
Normal
Unknown
Optimized
}
;
Kind
kind
(
)
const
;
bool
isInAllocatedList
(
)
const
{
return
nextNurseryAllocated
;
}
InitialHeap
initialHeap
(
)
const
{
return
state
(
)
=
=
State
:
:
LongLived
?
TenuredHeap
:
DefaultHeap
;
}
bool
hasNurseryAllocations
(
)
const
{
return
nurseryAllocCount
!
=
0
|
|
nurseryTenuredCount
!
=
0
;
}
void
resetNurseryAllocations
(
)
{
nurseryAllocCount
=
0
;
nurseryTenuredCount
=
0
;
}
uint32_t
incAllocCount
(
)
{
return
+
+
nurseryAllocCount
;
}
uint32_t
*
nurseryAllocCountAddress
(
)
{
return
&
nurseryAllocCount
;
}
void
incTenuredCount
(
)
{
nurseryTenuredCount
+
+
;
MOZ_ASSERT
(
nurseryTenuredCount
!
=
0
)
;
}
size_t
allocCount
(
)
const
{
return
std
:
:
max
(
nurseryAllocCount
nurseryTenuredCount
)
;
}
void
updateStateOnMinorGC
(
double
promotionRate
)
;
bool
maybeResetState
(
)
;
bool
invalidationLimitReached
(
)
const
;
bool
invalidateScript
(
GCRuntime
*
gc
)
;
void
trace
(
JSTracer
*
trc
)
;
static
void
printInfoHeader
(
JS
:
:
GCReason
reason
double
promotionRate
)
;
static
void
printInfoFooter
(
size_t
sitesCreated
size_t
sitesActive
size_t
sitesPretenured
size_t
sitesInvalidated
)
;
void
printInfo
(
bool
hasPromotionRate
double
promotionRate
bool
wasInvalidated
)
const
;
static
constexpr
size_t
offsetOfScriptAndState
(
)
{
return
offsetof
(
AllocSite
scriptAndState
)
;
}
static
constexpr
size_t
offsetOfNurseryAllocCount
(
)
{
return
offsetof
(
AllocSite
nurseryAllocCount
)
;
}
static
constexpr
size_t
offsetOfNextNurseryAllocated
(
)
{
return
offsetof
(
AllocSite
nextNurseryAllocated
)
;
}
private
:
void
setScript
(
JSScript
*
newScript
)
{
MOZ_ASSERT
(
(
uintptr_t
(
newScript
)
&
STATE_MASK
)
=
=
0
)
;
scriptAndState
=
uintptr_t
(
newScript
)
|
uintptr_t
(
state
(
)
)
;
}
void
setState
(
State
newState
)
{
MOZ_ASSERT
(
(
uintptr_t
(
newState
)
&
~
STATE_MASK
)
=
=
0
)
;
scriptAndState
=
rawScript
(
)
|
uintptr_t
(
newState
)
;
}
const
char
*
stateName
(
)
const
;
}
;
class
PretenuringZone
{
public
:
AllocSite
unknownAllocSites
[
NurseryTraceKinds
]
;
AllocSite
optimizedAllocSite
;
uint32_t
allocCountInNewlyCreatedArenas
=
0
;
uint32_t
survivorCountInNewlyCreatedArenas
=
0
;
uint32_t
lowYoungTenuredSurvivalCount
=
0
;
uint32_t
highNurserySurvivalCount
=
0
;
uint32_t
nurseryAllocCounts
[
NurseryTraceKinds
]
=
{
0
}
;
explicit
PretenuringZone
(
JS
:
:
Zone
*
zone
)
:
optimizedAllocSite
(
zone
JS
:
:
TraceKind
:
:
Object
)
{
for
(
uint32_t
i
=
0
;
i
<
NurseryTraceKinds
;
i
+
+
)
{
unknownAllocSites
[
i
]
.
initUnknownSite
(
zone
JS
:
:
TraceKind
(
i
)
)
;
}
}
AllocSite
&
unknownAllocSite
(
JS
:
:
TraceKind
kind
)
{
size_t
i
=
size_t
(
kind
)
;
MOZ_ASSERT
(
i
<
NurseryTraceKinds
)
;
return
unknownAllocSites
[
i
]
;
}
void
clearCellCountsInNewlyCreatedArenas
(
)
{
allocCountInNewlyCreatedArenas
=
0
;
survivorCountInNewlyCreatedArenas
=
0
;
}
void
updateCellCountsInNewlyCreatedArenas
(
uint32_t
allocCount
uint32_t
survivorCount
)
{
allocCountInNewlyCreatedArenas
+
=
allocCount
;
survivorCountInNewlyCreatedArenas
+
=
survivorCount
;
}
bool
calculateYoungTenuredSurvivalRate
(
double
*
rateOut
)
;
void
noteLowYoungTenuredSurvivalRate
(
bool
lowYoungSurvivalRate
)
;
void
noteHighNurserySurvivalRate
(
bool
highNurserySurvivalRate
)
;
bool
shouldResetNurseryAllocSites
(
)
;
bool
shouldResetPretenuredAllocSites
(
)
;
uint32_t
&
nurseryAllocCount
(
JS
:
:
TraceKind
kind
)
{
size_t
i
=
size_t
(
kind
)
;
MOZ_ASSERT
(
i
<
NurseryTraceKinds
)
;
return
nurseryAllocCounts
[
i
]
;
}
uint32_t
nurseryAllocCount
(
JS
:
:
TraceKind
kind
)
const
{
return
const_cast
<
PretenuringZone
*
>
(
this
)
-
>
nurseryAllocCount
(
kind
)
;
}
}
;
class
PretenuringNursery
{
gc
:
:
AllocSite
*
allocatedSites
;
size_t
allocSitesCreated
=
0
;
uint32_t
totalAllocCount_
=
0
;
public
:
PretenuringNursery
(
)
:
allocatedSites
(
AllocSite
:
:
EndSentinel
)
{
}
bool
hasAllocatedSites
(
)
const
{
return
allocatedSites
!
=
AllocSite
:
:
EndSentinel
;
}
bool
canCreateAllocSite
(
)
;
void
noteAllocSiteCreated
(
)
{
allocSitesCreated
+
+
;
}
void
insertIntoAllocatedList
(
AllocSite
*
site
)
{
MOZ_ASSERT
(
!
site
-
>
isInAllocatedList
(
)
)
;
site
-
>
nextNurseryAllocated
=
allocatedSites
;
allocatedSites
=
site
;
}
size_t
doPretenuring
(
GCRuntime
*
gc
JS
:
:
GCReason
reason
bool
validPromotionRate
double
promotionRate
bool
reportInfo
size_t
reportThreshold
)
;
void
maybeStopPretenuring
(
GCRuntime
*
gc
)
;
uint32_t
totalAllocCount
(
)
const
{
return
totalAllocCount_
;
}
void
*
addressOfAllocatedSites
(
)
{
return
&
allocatedSites
;
}
private
:
void
processSite
(
GCRuntime
*
gc
AllocSite
*
site
size_t
&
sitesActive
size_t
&
sitesPretenured
size_t
&
sitesInvalidated
bool
reportInfo
size_t
reportThreshold
)
;
void
processCatchAllSite
(
AllocSite
*
site
bool
reportInfo
size_t
reportThreshold
)
;
void
updateAllocCounts
(
AllocSite
*
site
)
;
}
;
}
}
#
endif
