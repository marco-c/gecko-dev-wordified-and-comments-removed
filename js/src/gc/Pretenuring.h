#
ifndef
gc_Pretenuring_h
#
define
gc_Pretenuring_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
algorithm
>
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
class
JS_PUBLIC_API
JSTracer
;
namespace
JS
{
enum
class
GCReason
;
}
namespace
js
{
namespace
gc
{
class
GCRuntime
;
class
PretenuringNursery
;
enum
class
CatchAllAllocSite
{
Unknown
Optimized
}
;
class
AllocSite
{
public
:
enum
class
State
:
uint32_t
{
ShortLived
=
0
Unknown
=
1
LongLived
=
2
}
;
static
constexpr
int32_t
LONG_LIVED_BIT
=
int32_t
(
State
:
:
LongLived
)
;
static_assert
(
(
LONG_LIVED_BIT
&
int32_t
(
State
:
:
Unknown
)
)
=
=
0
)
;
static_assert
(
(
AllocSite
:
:
LONG_LIVED_BIT
&
int32_t
(
State
:
:
ShortLived
)
)
=
=
0
)
;
private
:
JS
:
:
Zone
*
const
zone_
;
uintptr_t
scriptAndState
=
uintptr_t
(
State
:
:
Unknown
)
;
static
constexpr
uintptr_t
STATE_MASK
=
BitMask
(
2
)
;
AllocSite
*
nextNurseryAllocated
=
nullptr
;
uint32_t
nurseryAllocCount
=
0
;
uint32_t
nurseryTenuredCount
:
24
;
uint32_t
invalidationCount
:
8
;
static
AllocSite
*
const
EndSentinel
;
friend
class
PretenuringZone
;
friend
class
PretenuringNursery
;
public
:
explicit
AllocSite
(
JS
:
:
Zone
*
zone
)
:
zone_
(
zone
)
nurseryTenuredCount
(
0
)
invalidationCount
(
0
)
{
}
AllocSite
(
JS
:
:
Zone
*
zone
JSScript
*
script
)
:
AllocSite
(
zone
)
{
setScript
(
script
)
;
}
JS
:
:
Zone
*
zone
(
)
const
{
return
zone_
;
}
State
state
(
)
const
{
return
State
(
scriptAndState
&
STATE_MASK
)
;
}
JSScript
*
script
(
)
const
{
return
reinterpret_cast
<
JSScript
*
>
(
scriptAndState
&
~
STATE_MASK
)
;
}
bool
hasScript
(
)
const
{
return
script
(
)
;
}
enum
class
Kind
:
uint32_t
{
Normal
Unknown
Optimized
}
;
Kind
kind
(
)
const
;
bool
isInAllocatedList
(
)
const
{
return
nextNurseryAllocated
;
}
InitialHeap
initialHeap
(
)
const
{
return
state
(
)
=
=
State
:
:
LongLived
?
TenuredHeap
:
DefaultHeap
;
}
bool
hasNurseryAllocations
(
)
const
{
return
nurseryAllocCount
!
=
0
|
|
nurseryTenuredCount
!
=
0
;
}
void
resetNurseryAllocations
(
)
{
nurseryAllocCount
=
0
;
nurseryTenuredCount
=
0
;
}
void
incAllocCount
(
)
{
nurseryAllocCount
+
+
;
}
void
incTenuredCount
(
)
{
nurseryTenuredCount
+
+
;
MOZ_ASSERT
(
nurseryTenuredCount
!
=
0
)
;
}
size_t
allocCount
(
)
const
{
return
std
:
:
max
(
nurseryAllocCount
nurseryTenuredCount
)
;
}
void
updateStateOnMinorGC
(
double
promotionRate
)
;
bool
maybeResetState
(
)
;
bool
invalidationLimitReached
(
)
const
;
bool
invalidateScript
(
GCRuntime
*
gc
)
;
void
trace
(
JSTracer
*
trc
)
;
static
void
printInfoHeader
(
JS
:
:
GCReason
reason
double
promotionRate
)
;
static
void
printInfoFooter
(
size_t
sitesCreated
size_t
sitesActive
size_t
sitesPretenured
size_t
sitesInvalidated
)
;
void
printInfo
(
bool
hasPromotionRate
double
promotionRate
bool
wasInvalidated
)
const
;
static
constexpr
size_t
offsetOfScriptAndState
(
)
{
return
offsetof
(
AllocSite
scriptAndState
)
;
}
static
constexpr
size_t
offsetOfNurseryAllocCount
(
)
{
return
offsetof
(
AllocSite
nurseryAllocCount
)
;
}
static
constexpr
size_t
offsetOfNextNurseryAllocated
(
)
{
return
offsetof
(
AllocSite
nextNurseryAllocated
)
;
}
private
:
void
setScript
(
JSScript
*
newScript
)
{
MOZ_ASSERT
(
(
uintptr_t
(
newScript
)
&
STATE_MASK
)
=
=
0
)
;
scriptAndState
=
uintptr_t
(
newScript
)
|
uintptr_t
(
state
(
)
)
;
}
void
setState
(
State
newState
)
{
MOZ_ASSERT
(
(
uintptr_t
(
newState
)
&
~
STATE_MASK
)
=
=
0
)
;
scriptAndState
=
uintptr_t
(
script
(
)
)
|
uintptr_t
(
newState
)
;
}
const
char
*
stateName
(
)
const
;
}
;
class
PretenuringZone
{
public
:
explicit
PretenuringZone
(
JS
:
:
Zone
*
zone
)
:
unknownAllocSite
(
zone
)
optimizedAllocSite
(
zone
)
{
}
AllocSite
unknownAllocSite
;
AllocSite
optimizedAllocSite
;
uint32_t
allocCountInNewlyCreatedArenas
=
0
;
uint32_t
survivorCountInNewlyCreatedArenas
=
0
;
uint32_t
lowYoungTenuredSurvivalCount
=
0
;
uint32_t
highNurserySurvivalCount
=
0
;
void
clearCellCountsInNewlyCreatedArenas
(
)
{
allocCountInNewlyCreatedArenas
=
0
;
survivorCountInNewlyCreatedArenas
=
0
;
}
void
updateCellCountsInNewlyCreatedArenas
(
uint32_t
allocCount
uint32_t
survivorCount
)
{
allocCountInNewlyCreatedArenas
+
=
allocCount
;
survivorCountInNewlyCreatedArenas
+
=
survivorCount
;
}
bool
calculateYoungTenuredSurvivalRate
(
double
*
rateOut
)
;
void
noteLowYoungTenuredSurvivalRate
(
bool
lowYoungSurvivalRate
)
;
void
noteHighNurserySurvivalRate
(
bool
highNurserySurvivalRate
)
;
bool
shouldResetNurseryAllocSites
(
)
;
bool
shouldResetPretenuredAllocSites
(
)
;
}
;
class
PretenuringNursery
{
gc
:
:
AllocSite
*
allocatedSites
;
size_t
allocSitesCreated
=
0
;
public
:
PretenuringNursery
(
)
:
allocatedSites
(
AllocSite
:
:
EndSentinel
)
{
}
bool
hasAllocatedSites
(
)
const
{
return
allocatedSites
!
=
AllocSite
:
:
EndSentinel
;
}
bool
canCreateAllocSite
(
)
;
void
noteAllocSiteCreated
(
)
{
allocSitesCreated
+
+
;
}
void
insertIntoAllocatedList
(
AllocSite
*
site
)
{
MOZ_ASSERT
(
!
site
-
>
isInAllocatedList
(
)
)
;
site
-
>
nextNurseryAllocated
=
allocatedSites
;
allocatedSites
=
site
;
}
size_t
doPretenuring
(
GCRuntime
*
gc
JS
:
:
GCReason
reason
bool
validPromotionRate
double
promotionRate
bool
reportInfo
size_t
reportThreshold
)
;
void
maybeStopPretenuring
(
GCRuntime
*
gc
)
;
void
*
addressOfAllocatedSites
(
)
{
return
&
allocatedSites
;
}
private
:
void
reportAndResetCatchAllSite
(
AllocSite
*
site
bool
reportInfo
size_t
reportThreshold
)
;
}
;
}
}
#
endif
