#
ifndef
gc_Pretenuring_h
#
define
gc_Pretenuring_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
class
JS_PUBLIC_API
JSTracer
;
namespace
js
{
namespace
gc
{
class
GCRuntime
;
class
PretenuringNursery
;
enum
class
CatchAllAllocSite
{
Unknown
Optimized
}
;
class
AllocSite
{
public
:
enum
class
State
:
uint32_t
{
ShortLived
Unknown
LongLived
}
;
private
:
JS
:
:
Zone
*
const
zone_
;
JSScript
*
script_
=
nullptr
;
AllocSite
*
nextNurseryAllocated
=
nullptr
;
uint32_t
nurseryAllocCount
=
0
;
uint32_t
nurseryTenuredCount
=
0
;
mozilla
:
:
Atomic
<
State
mozilla
:
:
ReleaseAcquire
>
state_
{
State
:
:
Unknown
}
;
static
AllocSite
*
const
EndSentinel
;
friend
class
PretenuringZone
;
friend
class
PretenuringNursery
;
public
:
explicit
AllocSite
(
JS
:
:
Zone
*
zone
)
:
zone_
(
zone
)
{
}
AllocSite
(
JS
:
:
Zone
*
zone
JSScript
*
script
)
:
zone_
(
zone
)
script_
(
script
)
{
}
JS
:
:
Zone
*
zone
(
)
const
{
return
zone_
;
}
bool
hasScript
(
)
const
{
return
script_
;
}
JSScript
*
script
(
)
const
{
return
script_
;
}
enum
class
Kind
:
uint32_t
{
Normal
Unknown
Optimized
}
;
Kind
kind
(
)
const
;
bool
isInAllocatedList
(
)
const
{
return
nextNurseryAllocated
;
}
InitialHeap
initialHeap
(
)
const
{
return
state_
=
=
State
:
:
LongLived
?
TenuredHeap
:
DefaultHeap
;
}
bool
hasNurseryAllocations
(
)
const
{
return
nurseryAllocCount
!
=
0
|
|
nurseryTenuredCount
!
=
0
;
}
void
resetNurseryAllocations
(
)
{
nurseryAllocCount
=
0
;
nurseryTenuredCount
=
0
;
}
void
incAllocCount
(
)
{
nurseryAllocCount
+
+
;
}
void
incTenuredCount
(
)
{
nurseryTenuredCount
+
+
;
}
void
updateStateOnMinorGC
(
double
promotionRate
)
;
void
trace
(
JSTracer
*
trc
)
;
static
void
printInfoHeader
(
)
;
static
void
printInfoFooter
(
size_t
sitesCreated
size_t
sitesActive
)
;
void
printInfo
(
bool
hasPromotionRate
double
promotionRate
)
const
;
static
constexpr
size_t
offsetOfState
(
)
{
return
offsetof
(
AllocSite
state_
)
;
}
static
constexpr
size_t
offsetOfNurseryAllocCount
(
)
{
return
offsetof
(
AllocSite
nurseryAllocCount
)
;
}
static
constexpr
size_t
offsetOfNextNurseryAllocated
(
)
{
return
offsetof
(
AllocSite
nextNurseryAllocated
)
;
}
private
:
const
char
*
stateName
(
)
const
;
}
;
class
PretenuringZone
{
public
:
explicit
PretenuringZone
(
JS
:
:
Zone
*
zone
)
:
unknownAllocSite
(
zone
)
optimizedAllocSite
(
zone
)
{
}
AllocSite
unknownAllocSite
;
AllocSite
optimizedAllocSite
;
}
;
class
PretenuringNursery
{
gc
:
:
AllocSite
*
allocatedSites
;
size_t
allocSitesCreated
=
0
;
public
:
PretenuringNursery
(
)
:
allocatedSites
(
AllocSite
:
:
EndSentinel
)
{
}
bool
hasAllocatedSites
(
)
const
{
return
allocatedSites
!
=
AllocSite
:
:
EndSentinel
;
}
bool
canCreateAllocSite
(
)
;
void
noteAllocSiteCreated
(
)
{
allocSitesCreated
+
+
;
}
void
insertIntoAllocatedList
(
AllocSite
*
site
)
{
MOZ_ASSERT
(
!
site
-
>
isInAllocatedList
(
)
)
;
site
-
>
nextNurseryAllocated
=
allocatedSites
;
allocatedSites
=
site
;
}
void
doPretenuring
(
GCRuntime
*
gc
bool
reportInfo
)
;
void
*
addressOfAllocatedSites
(
)
{
return
&
allocatedSites
;
}
}
;
}
}
#
endif
