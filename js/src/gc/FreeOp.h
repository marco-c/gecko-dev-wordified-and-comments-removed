#
ifndef
gc_FreeOp_h
#
define
gc_FreeOp_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
jit
/
ExecutableAllocator
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
MemoryFunctions
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
struct
JS_PUBLIC_API
JSRuntime
;
namespace
js
{
namespace
gc
{
class
AutoSetThreadIsPerformingGC
;
}
}
class
JSFreeOp
{
using
Cell
=
js
:
:
gc
:
:
Cell
;
using
MemoryUse
=
js
:
:
MemoryUse
;
JSRuntime
*
runtime_
;
js
:
:
jit
:
:
JitPoisonRangeVector
jitPoisonRanges
;
const
bool
isDefault
;
bool
isCollecting_
;
friend
class
js
:
:
gc
:
:
AutoSetThreadIsPerformingGC
;
public
:
explicit
JSFreeOp
(
JSRuntime
*
maybeRuntime
bool
isDefault
=
false
)
;
~
JSFreeOp
(
)
;
JSRuntime
*
runtime
(
)
const
{
MOZ_ASSERT
(
runtime_
)
;
return
runtime_
;
}
bool
onMainThread
(
)
const
{
return
runtime_
!
=
nullptr
;
}
bool
maybeOnHelperThread
(
)
const
{
return
!
runtime_
;
}
bool
isDefaultFreeOp
(
)
const
{
return
isDefault
;
}
bool
isCollecting
(
)
const
{
return
isCollecting_
;
}
void
freeUntracked
(
void
*
p
)
{
js_free
(
p
)
;
}
void
free_
(
Cell
*
cell
void
*
p
size_t
nbytes
MemoryUse
use
)
;
bool
appendJitPoisonRange
(
const
js
:
:
jit
:
:
JitPoisonRange
&
range
)
{
MOZ_ASSERT
(
!
isDefaultFreeOp
(
)
)
;
return
jitPoisonRanges
.
append
(
range
)
;
}
template
<
class
T
>
void
deleteUntracked
(
T
*
p
)
{
if
(
p
)
{
p
-
>
~
T
(
)
;
js_free
(
p
)
;
}
}
template
<
class
T
>
void
delete_
(
Cell
*
cell
T
*
p
MemoryUse
use
)
{
delete_
(
cell
p
sizeof
(
T
)
use
)
;
}
template
<
class
T
>
void
delete_
(
Cell
*
cell
T
*
p
size_t
nbytes
MemoryUse
use
)
{
if
(
p
)
{
p
-
>
~
T
(
)
;
free_
(
cell
p
nbytes
use
)
;
}
}
template
<
class
T
>
void
release
(
Cell
*
cell
T
*
p
MemoryUse
use
)
{
release
(
cell
p
sizeof
(
T
)
use
)
;
}
template
<
class
T
>
void
release
(
Cell
*
cell
T
*
p
size_t
nbytes
MemoryUse
use
)
;
void
removeCellMemory
(
Cell
*
cell
size_t
nbytes
MemoryUse
use
)
;
}
;
#
endif
