#
ifndef
gc_FreeOp_h
#
define
gc_FreeOp_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
jit
/
ExecutableAllocator
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
MemoryFunctions
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
struct
JSRuntime
;
namespace
js
{
class
FreeOp
:
public
JSFreeOp
{
Vector
<
void
*
0
SystemAllocPolicy
>
freeLaterList
;
jit
:
:
JitPoisonRangeVector
jitPoisonRanges
;
const
bool
isDefault
;
public
:
static
FreeOp
*
get
(
JSFreeOp
*
fop
)
{
return
static_cast
<
FreeOp
*
>
(
fop
)
;
}
explicit
FreeOp
(
JSRuntime
*
maybeRuntime
bool
isDefault
=
false
)
;
~
FreeOp
(
)
;
bool
onMainThread
(
)
const
{
return
runtime_
!
=
nullptr
;
}
bool
maybeOnHelperThread
(
)
const
{
return
!
runtime_
;
}
bool
isDefaultFreeOp
(
)
const
{
return
isDefault
;
}
void
freeUntracked
(
void
*
p
)
{
js_free
(
p
)
;
}
void
free_
(
gc
:
:
Cell
*
cell
void
*
p
size_t
nbytes
MemoryUse
use
)
;
void
freeUntrackedLater
(
void
*
p
)
{
queueForFreeLater
(
p
)
;
}
void
freeLater
(
gc
:
:
Cell
*
cell
void
*
p
size_t
nbytes
MemoryUse
use
)
;
bool
appendJitPoisonRange
(
const
jit
:
:
JitPoisonRange
&
range
)
{
MOZ_ASSERT
(
!
isDefaultFreeOp
(
)
)
;
return
jitPoisonRanges
.
append
(
range
)
;
}
template
<
class
T
>
void
deleteUntracked
(
T
*
p
)
{
if
(
p
)
{
p
-
>
~
T
(
)
;
js_free
(
p
)
;
}
}
template
<
class
T
>
void
delete_
(
gc
:
:
Cell
*
cell
T
*
p
MemoryUse
use
)
{
delete_
(
cell
p
sizeof
(
T
)
use
)
;
}
template
<
class
T
>
void
delete_
(
gc
:
:
Cell
*
cell
T
*
p
size_t
nbytes
MemoryUse
use
)
{
if
(
p
)
{
p
-
>
~
T
(
)
;
free_
(
cell
p
nbytes
use
)
;
}
}
template
<
class
T
>
void
release
(
gc
:
:
Cell
*
cell
T
*
p
MemoryUse
use
)
{
release
(
cell
p
sizeof
(
T
)
use
)
;
}
template
<
class
T
>
void
release
(
gc
:
:
Cell
*
cell
T
*
p
size_t
nbytes
MemoryUse
use
)
;
private
:
void
queueForFreeLater
(
void
*
p
)
;
}
;
}
#
endif
