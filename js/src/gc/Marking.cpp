#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
<
algorithm
>
#
include
<
type_traits
>
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
jit
/
JitCode
.
h
"
#
include
"
js
/
GCTypeMacros
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
util
/
Poison
.
h
"
#
include
"
vm
/
GeneratorObject
.
h
"
#
include
"
gc
/
GC
-
inl
.
h
"
#
include
"
gc
/
PrivateIterators
-
inl
.
h
"
#
include
"
gc
/
TraceMethods
-
inl
.
h
"
#
include
"
gc
/
WeakMap
-
inl
.
h
"
#
include
"
vm
/
GeckoProfiler
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
JS
:
:
MapTypeToTraceKind
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
IntegerRange
;
using
mozilla
:
:
PodCopy
;
#
if
defined
(
DEBUG
)
template
<
typename
T
>
static
inline
bool
IsThingPoisoned
(
T
*
thing
)
{
const
uint8_t
poisonBytes
[
]
=
{
JS_FRESH_NURSERY_PATTERN
JS_SWEPT_NURSERY_PATTERN
JS_ALLOCATED_NURSERY_PATTERN
JS_FRESH_TENURED_PATTERN
JS_MOVED_TENURED_PATTERN
JS_SWEPT_TENURED_PATTERN
JS_ALLOCATED_TENURED_PATTERN
JS_FREED_HEAP_PTR_PATTERN
JS_FREED_CHUNK_PATTERN
JS_FREED_ARENA_PATTERN
JS_SWEPT_TI_PATTERN
JS_SWEPT_CODE_PATTERN
JS_RESET_VALUE_PATTERN
JS_POISONED_JSSCRIPT_DATA_PATTERN
JS_OOB_PARSE_NODE_PATTERN
JS_LIFO_UNDEFINED_PATTERN
JS_LIFO_UNINITIALIZED_PATTERN
}
;
uint32_t
*
p
=
reinterpret_cast
<
uint32_t
*
>
(
reinterpret_cast
<
FreeSpan
*
>
(
thing
)
+
1
)
;
if
(
(
*
p
&
1
)
=
=
0
)
{
return
false
;
}
for
(
const
uint8_t
pb
:
poisonBytes
)
{
const
uint32_t
pw
=
pb
|
(
pb
<
<
8
)
|
(
pb
<
<
16
)
|
(
pb
<
<
24
)
;
if
(
*
p
=
=
pw
)
{
return
true
;
}
}
return
false
;
}
#
endif
template
<
typename
T
>
static
inline
bool
IsOwnedByOtherRuntime
(
JSRuntime
*
rt
T
thing
)
{
bool
other
=
thing
-
>
runtimeFromAnyThread
(
)
!
=
rt
;
MOZ_ASSERT_IF
(
other
thing
-
>
isPermanentAndMayBeShared
(
)
)
;
return
other
;
}
#
ifdef
DEBUG
template
<
typename
T
>
void
js
:
:
CheckTracedThing
(
JSTracer
*
trc
T
*
thing
)
{
MOZ_ASSERT
(
trc
)
;
MOZ_ASSERT
(
thing
)
;
if
(
IsForwarded
(
thing
)
)
{
JS
:
:
TracerKind
kind
=
trc
-
>
kind
(
)
;
MOZ_ASSERT
(
kind
=
=
JS
:
:
TracerKind
:
:
Tenuring
|
|
kind
=
=
JS
:
:
TracerKind
:
:
MinorSweeping
|
|
kind
=
=
JS
:
:
TracerKind
:
:
Moving
)
;
thing
=
Forwarded
(
thing
)
;
}
if
(
IsInsideNursery
(
thing
)
)
{
return
;
}
Zone
*
zone
=
thing
-
>
zoneFromAnyThread
(
)
;
if
(
IsOwnedByOtherRuntime
(
trc
-
>
runtime
(
)
thing
)
)
{
MOZ_ASSERT
(
!
zone
-
>
wasGCStarted
(
)
)
;
MOZ_ASSERT
(
thing
-
>
isMarkedBlack
(
)
)
;
return
;
}
JSRuntime
*
rt
=
trc
-
>
runtime
(
)
;
MOZ_ASSERT
(
zone
-
>
runtimeFromAnyThread
(
)
=
=
rt
)
;
bool
isGcMarkingTracer
=
trc
-
>
isMarkingTracer
(
)
;
bool
isUnmarkGrayTracer
=
IsTracerKind
(
trc
JS
:
:
TracerKind
:
:
UnmarkGray
)
;
bool
isClearEdgesTracer
=
IsTracerKind
(
trc
JS
:
:
TracerKind
:
:
ClearEdges
)
;
if
(
TlsContext
.
get
(
)
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessZone
(
zone
)
)
;
}
else
{
MOZ_ASSERT
(
isGcMarkingTracer
|
|
isUnmarkGrayTracer
|
|
isClearEdgesTracer
|
|
IsTracerKind
(
trc
JS
:
:
TracerKind
:
:
Moving
)
|
|
IsTracerKind
(
trc
JS
:
:
TracerKind
:
:
Sweeping
)
)
;
MOZ_ASSERT_IF
(
!
isClearEdgesTracer
CurrentThreadIsPerformingGC
(
)
)
;
}
MOZ_ASSERT
(
thing
-
>
isAligned
(
)
)
;
MOZ_ASSERT
(
MapTypeToTraceKind
<
std
:
:
remove_pointer_t
<
T
>
>
:
:
kind
=
=
thing
-
>
getTraceKind
(
)
)
;
MOZ_ASSERT_IF
(
rt
-
>
heapState
(
)
!
=
JS
:
:
HeapState
:
:
Idle
&
&
!
zone
-
>
isGCSweeping
(
)
&
&
!
zone
-
>
isGCFinished
(
)
&
&
!
zone
-
>
isGCCompacting
(
)
!
IsThingPoisoned
(
thing
)
|
|
!
InFreeList
(
thing
-
>
asTenured
(
)
.
arena
(
)
thing
)
)
;
}
template
<
typename
T
>
void
js
:
:
CheckTracedThing
(
JSTracer
*
trc
const
T
&
thing
)
{
ApplyGCThingTyped
(
thing
[
trc
]
(
auto
t
)
{
CheckTracedThing
(
trc
t
)
;
}
)
;
}
template
<
typename
T
>
static
void
CheckMarkedThing
(
GCMarker
*
gcMarker
T
*
thing
)
{
Zone
*
zone
=
thing
-
>
zoneFromAnyThread
(
)
;
MOZ_ASSERT
(
zone
-
>
shouldMarkInZone
(
gcMarker
-
>
markColor
(
)
)
)
;
MOZ_ASSERT_IF
(
gcMarker
-
>
shouldCheckCompartments
(
)
zone
-
>
isCollectingFromAnyThread
(
)
|
|
zone
-
>
isAtomsZone
(
)
)
;
MOZ_ASSERT_IF
(
gcMarker
-
>
markColor
(
)
=
=
MarkColor
:
:
Gray
!
zone
-
>
isGCMarkingBlackOnly
(
)
|
|
zone
-
>
isAtomsZone
(
)
)
;
MOZ_ASSERT
(
!
(
zone
-
>
isGCSweeping
(
)
|
|
zone
-
>
isGCFinished
(
)
|
|
zone
-
>
isGCCompacting
(
)
)
)
;
Compartment
*
comp
=
thing
-
>
maybeCompartment
(
)
;
MOZ_ASSERT_IF
(
gcMarker
-
>
tracingCompartment
&
&
comp
gcMarker
-
>
tracingCompartment
=
=
comp
)
;
MOZ_ASSERT_IF
(
gcMarker
-
>
tracingZone
gcMarker
-
>
tracingZone
=
=
zone
|
|
zone
-
>
isAtomsZone
(
)
)
;
}
namespace
js
{
#
define
IMPL_CHECK_TRACED_THING
(
_
type
_1
_2
)
\
template
void
CheckTracedThing
<
type
>
(
JSTracer
*
type
*
)
;
JS_FOR_EACH_TRACEKIND
(
IMPL_CHECK_TRACED_THING
)
;
#
undef
IMPL_CHECK_TRACED_THING
template
void
CheckTracedThing
<
Value
>
(
JSTracer
*
const
Value
&
)
;
}
#
endif
static
inline
bool
ShouldMarkCrossCompartment
(
GCMarker
*
marker
JSObject
*
src
Cell
*
dstCell
)
{
MarkColor
color
=
marker
-
>
markColor
(
)
;
if
(
!
dstCell
-
>
isTenured
(
)
)
{
#
ifdef
DEBUG
if
(
color
!
=
MarkColor
:
:
Black
)
{
fprintf
(
stderr
"
ShouldMarkCrossCompartment
:
cross
compartment
edge
from
gray
"
"
object
to
nursery
thing
\
n
"
)
;
fprintf
(
stderr
"
src
:
"
)
;
src
-
>
dump
(
)
;
fprintf
(
stderr
"
dst
:
"
)
;
dstCell
-
>
dump
(
)
;
}
#
endif
MOZ_ASSERT
(
color
=
=
MarkColor
:
:
Black
)
;
return
false
;
}
TenuredCell
&
dst
=
dstCell
-
>
asTenured
(
)
;
JS
:
:
Zone
*
dstZone
=
dst
.
zone
(
)
;
if
(
!
src
-
>
zone
(
)
-
>
isGCMarking
(
)
&
&
!
dstZone
-
>
isGCMarking
(
)
)
{
return
false
;
}
if
(
color
=
=
MarkColor
:
:
Black
)
{
MOZ_ASSERT_IF
(
!
dst
.
isMarkedBlack
(
)
!
dstZone
-
>
isGCSweeping
(
)
)
;
if
(
dst
.
isMarkedGray
(
)
&
&
!
dstZone
-
>
isGCMarking
(
)
)
{
UnmarkGrayGCThingUnchecked
(
marker
-
>
runtime
(
)
JS
:
:
GCCellPtr
(
&
dst
dst
.
getTraceKind
(
)
)
)
;
return
false
;
}
return
dstZone
-
>
isGCMarking
(
)
;
}
else
{
MOZ_ASSERT_IF
(
!
dst
.
isMarkedAny
(
)
!
dstZone
-
>
isGCSweeping
(
)
)
;
if
(
dstZone
-
>
isGCMarkingBlackOnly
(
)
)
{
if
(
!
dst
.
isMarkedAny
(
)
)
{
DelayCrossCompartmentGrayMarking
(
src
)
;
}
return
false
;
}
return
dstZone
-
>
isGCMarkingBlackAndGray
(
)
;
}
}
static
bool
ShouldTraceCrossCompartment
(
JSTracer
*
trc
JSObject
*
src
Cell
*
dstCell
)
{
if
(
!
trc
-
>
isMarkingTracer
(
)
)
{
return
true
;
}
return
ShouldMarkCrossCompartment
(
GCMarker
:
:
fromTracer
(
trc
)
src
dstCell
)
;
}
static
bool
ShouldTraceCrossCompartment
(
JSTracer
*
trc
JSObject
*
src
const
Value
&
val
)
{
return
val
.
isGCThing
(
)
&
&
ShouldTraceCrossCompartment
(
trc
src
val
.
toGCThing
(
)
)
;
}
#
ifdef
DEBUG
inline
void
js
:
:
gc
:
:
AssertShouldMarkInZone
(
GCMarker
*
marker
Cell
*
thing
)
{
if
(
!
thing
-
>
isMarkedBlack
(
)
)
{
Zone
*
zone
=
thing
-
>
zone
(
)
;
MOZ_ASSERT
(
zone
-
>
isAtomsZone
(
)
|
|
zone
-
>
shouldMarkInZone
(
marker
-
>
markColor
(
)
)
)
;
}
}
void
js
:
:
gc
:
:
AssertRootMarkingPhase
(
JSTracer
*
trc
)
{
MOZ_ASSERT_IF
(
trc
-
>
isMarkingTracer
(
)
trc
-
>
runtime
(
)
-
>
gc
.
state
(
)
=
=
State
:
:
NotActive
|
|
trc
-
>
runtime
(
)
-
>
gc
.
state
(
)
=
=
State
:
:
MarkRoots
)
;
}
#
endif
template
<
typename
T
>
static
void
TraceExternalEdgeHelper
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
MOZ_ASSERT
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
*
thingp
)
)
;
TraceEdgeInternal
(
trc
ConvertToBase
(
thingp
)
name
)
;
}
JS_PUBLIC_API
void
js
:
:
UnsafeTraceManuallyBarrieredEdge
(
JSTracer
*
trc
JSObject
*
*
thingp
const
char
*
name
)
{
TraceEdgeInternal
(
trc
ConvertToBase
(
thingp
)
name
)
;
}
template
<
typename
T
>
static
void
TraceRootHelper
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
MOZ_ASSERT
(
thingp
)
;
js
:
:
TraceNullableRoot
(
trc
thingp
name
)
;
}
namespace
js
{
class
AbstractGeneratorObject
;
class
SavedFrame
;
}
#
define
DEFINE_TRACE_EXTERNAL_EDGE_FUNCTION
(
type
)
\
JS_PUBLIC_API
void
js
:
:
gc
:
:
TraceExternalEdge
(
JSTracer
*
trc
type
*
thingp
\
const
char
*
name
)
{
\
TraceExternalEdgeHelper
(
trc
thingp
name
)
;
\
}
JS_FOR_EACH_PUBLIC_GC_POINTER_TYPE
(
DEFINE_TRACE_EXTERNAL_EDGE_FUNCTION
)
JS_FOR_EACH_PUBLIC_TAGGED_GC_POINTER_TYPE
(
DEFINE_TRACE_EXTERNAL_EDGE_FUNCTION
)
#
undef
DEFINE_TRACE_EXTERNAL_EDGE_FUNCTION
#
define
DEFINE_UNSAFE_TRACE_ROOT_FUNCTION
(
type
)
\
JS_PUBLIC_API
void
JS
:
:
TraceRoot
(
JSTracer
*
trc
type
*
thingp
\
const
char
*
name
)
{
\
TraceRootHelper
(
trc
thingp
name
)
;
\
}
JS_FOR_EACH_PUBLIC_GC_POINTER_TYPE
(
DEFINE_UNSAFE_TRACE_ROOT_FUNCTION
)
JS_FOR_EACH_PUBLIC_TAGGED_GC_POINTER_TYPE
(
DEFINE_UNSAFE_TRACE_ROOT_FUNCTION
)
DEFINE_UNSAFE_TRACE_ROOT_FUNCTION
(
AbstractGeneratorObject
*
)
DEFINE_UNSAFE_TRACE_ROOT_FUNCTION
(
SavedFrame
*
)
#
undef
DEFINE_UNSAFE_TRACE_ROOT_FUNCTION
namespace
js
{
namespace
gc
{
#
define
INSTANTIATE_INTERNAL_TRACE_FUNCTIONS
(
type
)
\
template
bool
TraceEdgeInternal
<
type
>
(
JSTracer
*
type
*
const
char
*
)
;
\
template
void
TraceRangeInternal
<
type
>
(
JSTracer
*
size_t
len
type
*
\
const
char
*
)
;
#
define
INSTANTIATE_INTERNAL_TRACE_FUNCTIONS_FROM_TRACEKIND
(
_1
type
_2
_3
)
\
INSTANTIATE_INTERNAL_TRACE_FUNCTIONS
(
type
*
)
JS_FOR_EACH_TRACEKIND
(
INSTANTIATE_INTERNAL_TRACE_FUNCTIONS_FROM_TRACEKIND
)
JS_FOR_EACH_PUBLIC_TAGGED_GC_POINTER_TYPE
(
INSTANTIATE_INTERNAL_TRACE_FUNCTIONS
)
INSTANTIATE_INTERNAL_TRACE_FUNCTIONS
(
TaggedProto
)
#
undef
INSTANTIATE_INTERNAL_TRACE_FUNCTIONS_FROM_TRACEKIND
#
undef
INSTANTIATE_INTERNAL_TRACE_FUNCTIONS
}
}
class
MOZ_RAII
AutoSetTracingSource
{
#
ifdef
DEBUG
GCMarker
*
marker
=
nullptr
;
#
endif
public
:
template
<
typename
T
>
AutoSetTracingSource
(
JSTracer
*
trc
T
*
thing
)
{
#
ifdef
DEBUG
if
(
trc
-
>
isMarkingTracer
(
)
&
&
thing
)
{
marker
=
GCMarker
:
:
fromTracer
(
trc
)
;
MOZ_ASSERT
(
!
marker
-
>
tracingZone
)
;
marker
-
>
tracingZone
=
thing
-
>
asTenured
(
)
.
zone
(
)
;
MOZ_ASSERT
(
!
marker
-
>
tracingCompartment
)
;
marker
-
>
tracingCompartment
=
thing
-
>
maybeCompartment
(
)
;
}
#
endif
}
~
AutoSetTracingSource
(
)
{
#
ifdef
DEBUG
if
(
marker
)
{
marker
-
>
tracingZone
=
nullptr
;
marker
-
>
tracingCompartment
=
nullptr
;
}
#
endif
}
}
;
class
MOZ_RAII
AutoClearTracingSource
{
#
ifdef
DEBUG
GCMarker
*
marker
=
nullptr
;
JS
:
:
Zone
*
prevZone
=
nullptr
;
Compartment
*
prevCompartment
=
nullptr
;
#
endif
public
:
explicit
AutoClearTracingSource
(
JSTracer
*
trc
)
{
#
ifdef
DEBUG
if
(
trc
-
>
isMarkingTracer
(
)
)
{
marker
=
GCMarker
:
:
fromTracer
(
trc
)
;
prevZone
=
marker
-
>
tracingZone
;
marker
-
>
tracingZone
=
nullptr
;
prevCompartment
=
marker
-
>
tracingCompartment
;
marker
-
>
tracingCompartment
=
nullptr
;
}
#
endif
}
~
AutoClearTracingSource
(
)
{
#
ifdef
DEBUG
if
(
marker
)
{
marker
-
>
tracingZone
=
prevZone
;
marker
-
>
tracingCompartment
=
prevCompartment
;
}
#
endif
}
}
;
template
<
typename
T
>
void
js
:
:
TraceManuallyBarrieredCrossCompartmentEdge
(
JSTracer
*
trc
JSObject
*
src
T
*
dst
const
char
*
name
)
{
AutoClearTracingSource
acts
(
trc
)
;
if
(
ShouldTraceCrossCompartment
(
trc
src
*
dst
)
)
{
TraceEdgeInternal
(
trc
dst
name
)
;
}
}
template
void
js
:
:
TraceManuallyBarrieredCrossCompartmentEdge
<
Value
>
(
JSTracer
*
JSObject
*
Value
*
const
char
*
)
;
template
void
js
:
:
TraceManuallyBarrieredCrossCompartmentEdge
<
JSObject
*
>
(
JSTracer
*
JSObject
*
JSObject
*
*
const
char
*
)
;
template
void
js
:
:
TraceManuallyBarrieredCrossCompartmentEdge
<
BaseScript
*
>
(
JSTracer
*
JSObject
*
BaseScript
*
*
const
char
*
)
;
template
<
typename
T
>
void
js
:
:
TraceSameZoneCrossCompartmentEdge
(
JSTracer
*
trc
const
WriteBarriered
<
T
>
*
dst
const
char
*
name
)
{
#
ifdef
DEBUG
if
(
trc
-
>
isMarkingTracer
(
)
)
{
MOZ_ASSERT
(
(
*
dst
)
-
>
maybeCompartment
(
)
"
Use
TraceEdge
for
GC
things
without
a
compartment
"
)
;
GCMarker
*
gcMarker
=
GCMarker
:
:
fromTracer
(
trc
)
;
MOZ_ASSERT_IF
(
gcMarker
-
>
tracingZone
(
*
dst
)
-
>
zone
(
)
=
=
gcMarker
-
>
tracingZone
)
;
}
if
(
trc
-
>
kind
(
)
=
=
JS
:
:
TracerKind
:
:
CompartmentCheck
)
{
return
;
}
#
endif
AutoClearTracingSource
acts
(
trc
)
;
TraceEdgeInternal
(
trc
ConvertToBase
(
dst
-
>
unbarrieredAddress
(
)
)
name
)
;
}
template
void
js
:
:
TraceSameZoneCrossCompartmentEdge
(
JSTracer
*
const
WriteBarriered
<
Shape
*
>
*
const
char
*
)
;
template
<
typename
T
>
void
js
:
:
TraceWeakMapKeyEdgeInternal
(
JSTracer
*
trc
Zone
*
weakMapZone
T
*
*
thingp
const
char
*
name
)
{
#
ifdef
DEBUG
auto
thing
=
*
thingp
;
if
(
trc
-
>
isMarkingTracer
(
)
)
{
MOZ_ASSERT
(
weakMapZone
-
>
isGCMarking
(
)
)
;
MOZ_ASSERT
(
weakMapZone
-
>
gcState
(
)
=
=
thing
-
>
zone
(
)
-
>
gcState
(
)
)
;
}
#
endif
AutoClearTracingSource
acts
(
trc
)
;
TraceEdgeInternal
(
trc
thingp
name
)
;
}
template
void
js
:
:
TraceWeakMapKeyEdgeInternal
<
JSObject
>
(
JSTracer
*
Zone
*
JSObject
*
*
const
char
*
)
;
template
void
js
:
:
TraceWeakMapKeyEdgeInternal
<
BaseScript
>
(
JSTracer
*
Zone
*
BaseScript
*
*
const
char
*
)
;
static
Cell
*
TraceGenericPointerRootAndType
(
JSTracer
*
trc
Cell
*
thing
JS
:
:
TraceKind
kind
const
char
*
name
)
{
return
MapGCThingTyped
(
thing
kind
[
trc
name
]
(
auto
t
)
-
>
Cell
*
{
TraceRoot
(
trc
&
t
name
)
;
return
t
;
}
)
;
}
void
js
:
:
TraceGenericPointerRoot
(
JSTracer
*
trc
Cell
*
*
thingp
const
char
*
name
)
{
MOZ_ASSERT
(
thingp
)
;
Cell
*
thing
=
*
thingp
;
if
(
!
thing
)
{
return
;
}
Cell
*
traced
=
TraceGenericPointerRootAndType
(
trc
thing
thing
-
>
getTraceKind
(
)
name
)
;
if
(
traced
!
=
thing
)
{
*
thingp
=
traced
;
}
}
void
js
:
:
TraceManuallyBarrieredGenericPointerEdge
(
JSTracer
*
trc
Cell
*
*
thingp
const
char
*
name
)
{
MOZ_ASSERT
(
thingp
)
;
Cell
*
thing
=
*
thingp
;
if
(
!
*
thingp
)
{
return
;
}
auto
traced
=
MapGCThingTyped
(
thing
thing
-
>
getTraceKind
(
)
[
trc
name
]
(
auto
t
)
-
>
Cell
*
{
TraceManuallyBarrieredEdge
(
trc
&
t
name
)
;
return
t
;
}
)
;
if
(
traced
!
=
thing
)
{
*
thingp
=
traced
;
}
}
void
js
:
:
TraceGCCellPtrRoot
(
JSTracer
*
trc
JS
:
:
GCCellPtr
*
thingp
const
char
*
name
)
{
Cell
*
thing
=
thingp
-
>
asCell
(
)
;
if
(
!
thing
)
{
return
;
}
Cell
*
traced
=
TraceGenericPointerRootAndType
(
trc
thing
thingp
-
>
kind
(
)
name
)
;
if
(
!
traced
)
{
*
thingp
=
JS
:
:
GCCellPtr
(
)
;
}
else
if
(
traced
!
=
thingp
-
>
asCell
(
)
)
{
*
thingp
=
JS
:
:
GCCellPtr
(
traced
thingp
-
>
kind
(
)
)
;
}
}
template
<
typename
T
>
inline
bool
DoCallback
(
JSTracer
*
trc
T
*
*
thingp
const
char
*
name
)
{
CheckTracedThing
(
trc
*
thingp
)
;
DispatchToOnEdge
(
trc
thingp
name
)
;
return
*
thingp
;
}
template
<
typename
T
>
inline
bool
DoCallback
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
bool
ret
=
true
;
auto
thing
=
MapGCThingTyped
(
*
thingp
[
&
]
(
auto
thing
)
{
if
(
!
DoCallback
(
trc
&
thing
name
)
)
{
ret
=
false
;
return
TaggedPtr
<
T
>
:
:
empty
(
)
;
}
return
TaggedPtr
<
T
>
:
:
wrap
(
thing
)
;
}
)
;
if
(
thing
.
isSome
(
)
&
&
thing
.
value
(
)
!
=
*
thingp
)
{
*
thingp
=
thing
.
value
(
)
;
}
return
ret
;
}
template
<
typename
T
>
bool
js
:
:
gc
:
:
TraceEdgeInternal
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
#
define
IS_SAME_TYPE_OR
(
name
type
_
_1
)
std
:
:
is_same_v
<
type
*
T
>
|
|
static_assert
(
JS_FOR_EACH_TRACEKIND
(
IS_SAME_TYPE_OR
)
std
:
:
is_same_v
<
T
JS
:
:
Value
>
|
|
std
:
:
is_same_v
<
T
jsid
>
|
|
std
:
:
is_same_v
<
T
TaggedProto
>
"
Only
the
base
cell
layout
types
are
allowed
into
"
"
marking
/
tracing
internals
"
)
;
#
undef
IS_SAME_TYPE_OR
return
DoCallback
(
trc
thingp
name
)
;
}
template
<
typename
T
>
void
js
:
:
gc
:
:
TraceRangeInternal
(
JSTracer
*
trc
size_t
len
T
*
vec
const
char
*
name
)
{
JS
:
:
AutoTracingIndex
index
(
trc
)
;
for
(
auto
i
:
IntegerRange
(
len
)
)
{
if
(
InternalBarrierMethods
<
T
>
:
:
isMarkable
(
vec
[
i
]
)
)
{
TraceEdgeInternal
(
trc
&
vec
[
i
]
name
)
;
}
+
+
index
;
}
}
namespace
js
{
using
HasNoImplicitEdgesType
=
bool
;
template
<
typename
T
>
struct
ImplicitEdgeHolderType
{
using
Type
=
HasNoImplicitEdgesType
;
}
;
template
<
>
struct
ImplicitEdgeHolderType
<
JSObject
*
>
{
using
Type
=
JSObject
*
;
}
;
template
<
>
struct
ImplicitEdgeHolderType
<
BaseScript
*
>
{
using
Type
=
BaseScript
*
;
}
;
void
GCMarker
:
:
markEphemeronEdges
(
EphemeronEdgeVector
&
edges
gc
:
:
CellColor
srcColor
)
{
DebugOnly
<
size_t
>
initialLength
=
edges
.
length
(
)
;
for
(
auto
&
edge
:
edges
)
{
CellColor
targetColor
=
std
:
:
min
(
srcColor
edge
.
color
)
;
MOZ_ASSERT
(
CellColor
(
markColor
(
)
)
>
=
targetColor
)
;
if
(
targetColor
=
=
markColor
(
)
)
{
ApplyGCThingTyped
(
edge
.
target
edge
.
target
-
>
getTraceKind
(
)
[
this
]
(
auto
t
)
{
markAndTraverse
(
t
)
;
}
)
;
}
}
MOZ_ASSERT
(
edges
.
length
(
)
=
=
initialLength
)
;
if
(
srcColor
=
=
CellColor
:
:
Black
&
&
markColor
(
)
=
=
MarkColor
:
:
Black
)
{
edges
.
eraseIf
(
[
]
(
auto
&
edge
)
{
return
edge
.
color
=
=
MarkColor
:
:
Black
;
}
)
;
}
}
void
GCMarker
:
:
severWeakDelegate
(
JSObject
*
key
JSObject
*
delegate
)
{
JS
:
:
Zone
*
zone
=
delegate
-
>
zone
(
)
;
if
(
!
zone
-
>
needsIncrementalBarrier
(
)
)
{
MOZ_ASSERT
(
!
zone
-
>
gcEphemeronEdges
(
delegate
)
.
get
(
delegate
)
"
non
-
collecting
zone
should
not
have
populated
gcEphemeronEdges
"
)
;
return
;
}
auto
*
p
=
zone
-
>
gcEphemeronEdges
(
delegate
)
.
get
(
delegate
)
;
if
(
!
p
)
{
return
;
}
EphemeronEdgeVector
&
edges
=
p
-
>
value
;
MOZ_ASSERT
(
markColor
(
)
=
=
MarkColor
:
:
Black
)
;
markEphemeronEdges
(
edges
MarkColor
:
:
Black
)
;
}
void
GCMarker
:
:
restoreWeakDelegate
(
JSObject
*
key
JSObject
*
delegate
)
{
if
(
!
key
-
>
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
{
if
(
key
-
>
zone
(
)
-
>
gcEphemeronEdges
(
key
)
.
has
(
key
)
)
{
fprintf
(
stderr
"
key
zone
:
%
d
\
n
"
int
(
key
-
>
zone
(
)
-
>
gcState
(
)
)
)
;
#
ifdef
DEBUG
key
-
>
dump
(
)
;
#
endif
fprintf
(
stderr
"
delegate
zone
:
%
d
\
n
"
int
(
delegate
-
>
zone
(
)
-
>
gcState
(
)
)
)
;
#
ifdef
DEBUG
delegate
-
>
dump
(
)
;
#
endif
}
MOZ_ASSERT
(
!
key
-
>
zone
(
)
-
>
gcEphemeronEdges
(
key
)
.
has
(
key
)
"
non
-
collecting
zone
should
not
have
populated
gcEphemeronEdges
"
)
;
return
;
}
if
(
!
delegate
-
>
zone
(
)
-
>
needsIncrementalBarrier
(
)
)
{
return
;
}
auto
*
p
=
key
-
>
zone
(
)
-
>
gcEphemeronEdges
(
key
)
.
get
(
key
)
;
if
(
!
p
)
{
return
;
}
EphemeronEdgeVector
&
edges
=
p
-
>
value
;
MOZ_ASSERT
(
markColor
(
)
=
=
MarkColor
:
:
Black
)
;
markEphemeronEdges
(
edges
MarkColor
:
:
Black
)
;
}
template
<
typename
T
>
void
GCMarker
:
:
markImplicitEdgesHelper
(
T
markedThing
)
{
if
(
!
isWeakMarking
(
)
)
{
return
;
}
Zone
*
zone
=
markedThing
-
>
asTenured
(
)
.
zone
(
)
;
MOZ_ASSERT
(
zone
-
>
isGCMarking
(
)
)
;
MOZ_ASSERT
(
!
zone
-
>
isGCSweeping
(
)
)
;
auto
p
=
zone
-
>
gcEphemeronEdges
(
)
.
get
(
markedThing
)
;
if
(
!
p
)
{
return
;
}
EphemeronEdgeVector
&
edges
=
p
-
>
value
;
AutoClearTracingSource
acts
(
this
)
;
CellColor
thingColor
=
gc
:
:
detail
:
:
GetEffectiveColor
(
this
markedThing
)
;
markEphemeronEdges
(
edges
thingColor
)
;
}
template
<
>
void
GCMarker
:
:
markImplicitEdgesHelper
(
HasNoImplicitEdgesType
)
{
}
template
<
typename
T
>
void
GCMarker
:
:
markImplicitEdges
(
T
*
thing
)
{
markImplicitEdgesHelper
<
typename
ImplicitEdgeHolderType
<
T
*
>
:
:
Type
>
(
thing
)
;
}
template
void
GCMarker
:
:
markImplicitEdges
(
JSObject
*
)
;
template
void
GCMarker
:
:
markImplicitEdges
(
BaseScript
*
)
;
}
template
<
typename
T
>
static
inline
bool
ShouldMark
(
GCMarker
*
gcmarker
T
*
thing
)
{
if
(
!
thing
-
>
isTenured
(
)
)
{
return
false
;
}
Zone
*
zone
=
thing
-
>
asTenured
(
)
.
zoneFromAnyThread
(
)
;
return
zone
-
>
shouldMarkInZone
(
gcmarker
-
>
markColor
(
)
)
;
}
template
<
typename
T
>
void
GCMarker
:
:
onEdge
(
T
*
*
thingp
const
char
*
name
)
{
T
*
thing
=
*
thingp
;
if
(
!
ShouldMark
(
this
thing
)
)
{
MOZ_ASSERT
(
gc
:
:
detail
:
:
GetEffectiveColor
(
this
thing
)
=
=
js
:
:
gc
:
:
CellColor
:
:
Black
)
;
return
;
}
MOZ_ASSERT
(
!
IsOwnedByOtherRuntime
(
runtime
(
)
thing
)
)
;
#
ifdef
DEBUG
CheckMarkedThing
(
this
thing
)
;
#
endif
AutoClearTracingSource
acts
(
this
)
;
markAndTraverse
(
thing
)
;
SetCompartmentHasMarkedCells
(
thing
)
;
}
#
define
INSTANTIATE_ONEDGE_METHOD
(
name
type
_1
_2
)
\
template
void
GCMarker
:
:
onEdge
<
type
>
(
type
*
*
thingp
const
char
*
name
)
;
JS_FOR_EACH_TRACEKIND
(
INSTANTIATE_ONEDGE_METHOD
)
JS_PUBLIC_API
void
js
:
:
gc
:
:
PerformIncrementalReadBarrier
(
JS
:
:
GCCellPtr
thing
)
{
MOZ_ASSERT
(
thing
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
TenuredCell
*
cell
=
&
thing
.
asCell
(
)
-
>
asTenured
(
)
;
MOZ_ASSERT
(
!
cell
-
>
isMarkedBlack
(
)
)
;
Zone
*
zone
=
cell
-
>
zone
(
)
;
MOZ_ASSERT
(
zone
-
>
needsIncrementalBarrier
(
)
)
;
BarrierTracer
*
trc
=
BarrierTracer
:
:
fromTracer
(
zone
-
>
barrierTracer
(
)
)
;
trc
-
>
performBarrier
(
thing
)
;
}
void
js
:
:
gc
:
:
PerformIncrementalReadBarrier
(
TenuredCell
*
cell
)
{
MOZ_ASSERT
(
cell
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
if
(
cell
-
>
isMarkedBlack
(
)
)
{
return
;
}
Zone
*
zone
=
cell
-
>
zone
(
)
;
MOZ_ASSERT
(
zone
-
>
needsIncrementalBarrier
(
)
)
;
BarrierTracer
*
trc
=
BarrierTracer
:
:
fromTracer
(
zone
-
>
barrierTracer
(
)
)
;
trc
-
>
performBarrier
(
JS
:
:
GCCellPtr
(
cell
cell
-
>
getTraceKind
(
)
)
)
;
}
void
js
:
:
gc
:
:
PerformIncrementalPreWriteBarrier
(
TenuredCell
*
cell
)
{
Zone
*
zone
=
cell
-
>
zoneFromAnyThread
(
)
;
MOZ_ASSERT
(
zone
-
>
needsIncrementalBarrier
(
)
)
;
MOZ_ASSERT
(
cell
)
;
if
(
cell
-
>
isMarkedBlack
(
)
)
{
return
;
}
bool
checkThread
=
zone
-
>
isAtomsZone
(
)
;
JSRuntime
*
runtime
=
cell
-
>
runtimeFromAnyThread
(
)
;
if
(
checkThread
&
&
!
CurrentThreadCanAccessRuntime
(
runtime
)
)
{
MOZ_ASSERT
(
CurrentThreadIsGCFinalizing
(
)
)
;
return
;
}
MOZ_ASSERT
(
CurrentThreadIsMainThread
(
)
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsMajorCollecting
(
)
)
;
BarrierTracer
*
trc
=
BarrierTracer
:
:
fromTracer
(
zone
-
>
barrierTracer
(
)
)
;
trc
-
>
performBarrier
(
JS
:
:
GCCellPtr
(
cell
cell
-
>
getTraceKind
(
)
)
)
;
}
void
js
:
:
gc
:
:
PerformIncrementalBarrierDuringFlattening
(
JSString
*
str
)
{
TenuredCell
*
cell
=
&
str
-
>
asTenured
(
)
;
if
(
str
-
>
isRope
(
)
)
{
cell
-
>
markBlack
(
)
;
return
;
}
PerformIncrementalPreWriteBarrier
(
cell
)
;
}
template
<
typename
T
>
void
js
:
:
GCMarker
:
:
markAndTraverse
(
T
*
thing
)
{
if
(
mark
(
thing
)
)
{
MOZ_ASSERT_IF
(
thing
-
>
isPermanentAndMayBeShared
(
)
!
runtime
(
)
-
>
permanentAtomsPopulated
(
)
)
;
traverse
(
thing
)
;
}
}
template
<
typename
T
>
void
js
:
:
GCMarker
:
:
traceChildren
(
T
*
thing
)
{
MOZ_ASSERT
(
!
thing
-
>
isPermanentAndMayBeShared
(
)
)
;
MOZ_ASSERT
(
thing
-
>
isMarkedAny
(
)
)
;
AutoSetTracingSource
asts
(
this
thing
)
;
thing
-
>
traceChildren
(
this
)
;
}
namespace
js
{
template
<
>
void
GCMarker
:
:
traverse
(
BaseShape
*
thing
)
{
traceChildren
(
thing
)
;
}
template
<
>
void
GCMarker
:
:
traverse
(
GetterSetter
*
thing
)
{
traceChildren
(
thing
)
;
}
template
<
>
void
GCMarker
:
:
traverse
(
JS
:
:
Symbol
*
thing
)
{
traceChildren
(
thing
)
;
}
template
<
>
void
GCMarker
:
:
traverse
(
JS
:
:
BigInt
*
thing
)
{
traceChildren
(
thing
)
;
}
template
<
>
void
GCMarker
:
:
traverse
(
RegExpShared
*
thing
)
{
traceChildren
(
thing
)
;
}
}
template
<
typename
T
>
void
js
:
:
GCMarker
:
:
scanChildren
(
T
*
thing
)
{
MOZ_ASSERT
(
!
thing
-
>
isPermanentAndMayBeShared
(
)
)
;
MOZ_ASSERT
(
thing
-
>
isMarkedAny
(
)
)
;
eagerlyMarkChildren
(
thing
)
;
}
namespace
js
{
template
<
>
void
GCMarker
:
:
traverse
(
JSString
*
thing
)
{
scanChildren
(
thing
)
;
}
template
<
>
void
GCMarker
:
:
traverse
(
Shape
*
thing
)
{
scanChildren
(
thing
)
;
}
template
<
>
void
GCMarker
:
:
traverse
(
PropMap
*
thing
)
{
scanChildren
(
thing
)
;
}
template
<
>
void
GCMarker
:
:
traverse
(
js
:
:
Scope
*
thing
)
{
scanChildren
(
thing
)
;
}
}
template
<
typename
T
>
void
js
:
:
GCMarker
:
:
pushThing
(
T
*
thing
)
{
MOZ_ASSERT
(
!
thing
-
>
isPermanentAndMayBeShared
(
)
)
;
MOZ_ASSERT
(
thing
-
>
isMarkedAny
(
)
)
;
pushTaggedPtr
(
thing
)
;
}
namespace
js
{
template
<
>
void
GCMarker
:
:
traverse
(
JSObject
*
thing
)
{
pushThing
(
thing
)
;
}
template
<
>
void
GCMarker
:
:
traverse
(
jit
:
:
JitCode
*
thing
)
{
pushThing
(
thing
)
;
}
template
<
>
void
GCMarker
:
:
traverse
(
BaseScript
*
thing
)
{
pushThing
(
thing
)
;
}
}
#
ifdef
DEBUG
void
GCMarker
:
:
setCheckAtomMarking
(
bool
check
)
{
MOZ_ASSERT
(
check
!
=
checkAtomMarking
)
;
checkAtomMarking
=
check
;
}
#
endif
template
<
typename
S
typename
T
>
inline
void
GCMarker
:
:
checkTraversedEdge
(
S
source
T
*
target
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
source
-
>
isPermanentAndMayBeShared
(
)
)
;
if
(
target
-
>
isPermanentAndMayBeShared
(
)
)
{
Zone
*
zone
=
target
-
>
zoneFromAnyThread
(
)
;
MOZ_ASSERT
(
!
zone
-
>
wasGCStarted
(
)
)
;
MOZ_ASSERT
(
!
zone
-
>
needsIncrementalBarrier
(
)
)
;
MOZ_ASSERT
(
target
-
>
isMarkedBlack
(
)
)
;
MOZ_ASSERT
(
!
target
-
>
maybeCompartment
(
)
)
;
return
;
}
Zone
*
sourceZone
=
source
-
>
zone
(
)
;
Zone
*
targetZone
=
target
-
>
zone
(
)
;
MOZ_ASSERT_IF
(
targetZone
-
>
isAtomsZone
(
)
!
target
-
>
maybeCompartment
(
)
)
;
MOZ_ASSERT
(
targetZone
=
=
sourceZone
|
|
targetZone
-
>
isAtomsZone
(
)
)
;
if
(
checkAtomMarking
&
&
!
sourceZone
-
>
isAtomsZone
(
)
&
&
targetZone
-
>
isAtomsZone
(
)
)
{
MOZ_ASSERT
(
target
-
>
runtimeFromAnyThread
(
)
-
>
gc
.
atomMarking
.
atomIsMarked
(
sourceZone
reinterpret_cast
<
TenuredCell
*
>
(
target
)
)
)
;
}
MOZ_ASSERT_IF
(
source
-
>
maybeCompartment
(
)
&
&
target
-
>
maybeCompartment
(
)
source
-
>
maybeCompartment
(
)
=
=
target
-
>
maybeCompartment
(
)
)
;
#
endif
}
template
<
typename
S
typename
T
>
void
js
:
:
GCMarker
:
:
markAndTraverseEdge
(
S
source
T
*
target
)
{
checkTraversedEdge
(
source
target
)
;
markAndTraverse
(
target
)
;
}
template
<
typename
S
typename
T
>
void
js
:
:
GCMarker
:
:
markAndTraverseEdge
(
S
source
const
T
&
thing
)
{
ApplyGCThingTyped
(
thing
[
this
source
]
(
auto
t
)
{
this
-
>
markAndTraverseEdge
(
source
t
)
;
}
)
;
}
namespace
{
template
<
typename
T
>
struct
TraceKindCanBeGray
{
}
;
#
define
EXPAND_TRACEKIND_DEF
(
_
type
canBeGray
_1
)
\
template
<
>
\
struct
TraceKindCanBeGray
<
type
>
{
\
static
constexpr
bool
value
=
canBeGray
;
\
}
;
JS_FOR_EACH_TRACEKIND
(
EXPAND_TRACEKIND_DEF
)
#
undef
EXPAND_TRACEKIND_DEF
}
struct
TraceKindCanBeGrayFunctor
{
template
<
typename
T
>
bool
operator
(
)
(
)
{
return
TraceKindCanBeGray
<
T
>
:
:
value
;
}
}
;
static
bool
TraceKindCanBeMarkedGray
(
JS
:
:
TraceKind
kind
)
{
return
DispatchTraceKindTyped
(
TraceKindCanBeGrayFunctor
(
)
kind
)
;
}
template
<
typename
T
>
bool
js
:
:
GCMarker
:
:
mark
(
T
*
thing
)
{
if
(
!
thing
-
>
isTenured
(
)
)
{
return
false
;
}
AssertShouldMarkInZone
(
this
thing
)
;
MarkColor
color
=
TraceKindCanBeGray
<
T
>
:
:
value
?
markColor
(
)
:
MarkColor
:
:
Black
;
return
thing
-
>
asTenured
(
)
.
markIfUnmarked
(
color
)
;
}
static
inline
void
CallTraceHook
(
JSTracer
*
trc
JSObject
*
obj
)
{
const
JSClass
*
clasp
=
obj
-
>
getClass
(
)
;
MOZ_ASSERT
(
clasp
)
;
if
(
clasp
-
>
hasTrace
(
)
)
{
AutoSetTracingSource
asts
(
trc
obj
)
;
clasp
-
>
doTrace
(
trc
obj
)
;
}
}
GCMarker
:
:
MarkQueueProgress
GCMarker
:
:
processMarkQueue
(
)
{
#
ifdef
DEBUG
if
(
markQueue
.
empty
(
)
)
{
return
QueueComplete
;
}
GCRuntime
&
gcrt
=
runtime
(
)
-
>
gc
;
if
(
queueMarkColor
=
=
mozilla
:
:
Some
(
MarkColor
:
:
Gray
)
&
&
gcrt
.
state
(
)
!
=
State
:
:
Sweep
)
{
return
QueueSuspended
;
}
if
(
queueMarkColor
=
=
mozilla
:
:
Some
(
MarkColor
:
:
Gray
)
&
&
hasBlackEntries
(
)
)
{
return
QueueSuspended
;
}
bool
willRevertToGray
=
markColor
(
)
=
=
MarkColor
:
:
Gray
;
AutoSetMarkColor
autoRevertColor
(
*
this
queueMarkColor
.
valueOr
(
markColor
(
)
)
)
;
while
(
queuePos
<
markQueue
.
length
(
)
)
{
Value
val
=
markQueue
[
queuePos
+
+
]
.
get
(
)
;
if
(
val
.
isObject
(
)
)
{
JSObject
*
obj
=
&
val
.
toObject
(
)
;
JS
:
:
Zone
*
zone
=
obj
-
>
zone
(
)
;
if
(
!
zone
-
>
isGCMarking
(
)
|
|
obj
-
>
isMarkedAtLeast
(
markColor
(
)
)
)
{
continue
;
}
if
(
gcrt
.
state
(
)
=
=
State
:
:
Sweep
&
&
gcrt
.
initialState
!
=
State
:
:
Sweep
)
{
if
(
zone
-
>
gcSweepGroupIndex
<
gcrt
.
getCurrentSweepGroupIndex
(
)
)
{
continue
;
}
if
(
zone
-
>
gcSweepGroupIndex
>
gcrt
.
getCurrentSweepGroupIndex
(
)
)
{
queuePos
-
-
;
return
QueueSuspended
;
}
}
if
(
markColor
(
)
=
=
MarkColor
:
:
Gray
&
&
zone
-
>
isGCMarkingBlackOnly
(
)
)
{
queuePos
-
-
;
return
QueueSuspended
;
}
if
(
markColor
(
)
=
=
MarkColor
:
:
Black
&
&
willRevertToGray
)
{
queuePos
-
-
;
return
QueueSuspended
;
}
markAndTraverse
(
obj
)
;
if
(
isMarkStackEmpty
(
)
)
{
if
(
obj
-
>
asTenured
(
)
.
arena
(
)
-
>
onDelayedMarkingList
(
)
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
oomUnsafe
.
crash
(
"
mark
queue
OOM
"
)
;
}
}
if
(
isMarkStackEmpty
(
)
)
{
MOZ_ASSERT
(
obj
-
>
asTenured
(
)
.
arena
(
)
-
>
onDelayedMarkingList
(
)
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
oomUnsafe
.
crash
(
"
Overflowed
stack
while
marking
test
queue
"
)
;
}
SliceBudget
unlimited
=
SliceBudget
:
:
unlimited
(
)
;
processMarkStackTop
(
unlimited
)
;
}
else
if
(
val
.
isString
(
)
)
{
JSLinearString
*
str
=
&
val
.
toString
(
)
-
>
asLinear
(
)
;
if
(
js
:
:
StringEqualsLiteral
(
str
"
yield
"
)
&
&
gcrt
.
isIncrementalGc
(
)
)
{
return
QueueYielded
;
}
else
if
(
js
:
:
StringEqualsLiteral
(
str
"
enter
-
weak
-
marking
-
mode
"
)
|
|
js
:
:
StringEqualsLiteral
(
str
"
abort
-
weak
-
marking
-
mode
"
)
)
{
if
(
state
=
=
MarkingState
:
:
RegularMarking
)
{
queuePos
-
-
;
return
QueueSuspended
;
}
if
(
js
:
:
StringEqualsLiteral
(
str
"
abort
-
weak
-
marking
-
mode
"
)
)
{
abortLinearWeakMarking
(
)
;
}
}
else
if
(
js
:
:
StringEqualsLiteral
(
str
"
drain
"
)
)
{
auto
unlimited
=
SliceBudget
:
:
unlimited
(
)
;
MOZ_RELEASE_ASSERT
(
markUntilBudgetExhausted
(
unlimited
DontReportMarkTime
)
)
;
}
else
if
(
js
:
:
StringEqualsLiteral
(
str
"
set
-
color
-
gray
"
)
)
{
queueMarkColor
=
mozilla
:
:
Some
(
MarkColor
:
:
Gray
)
;
if
(
gcrt
.
state
(
)
!
=
State
:
:
Sweep
|
|
hasBlackEntries
(
)
)
{
queuePos
-
-
;
return
QueueSuspended
;
}
setMarkColor
(
MarkColor
:
:
Gray
)
;
}
else
if
(
js
:
:
StringEqualsLiteral
(
str
"
set
-
color
-
black
"
)
)
{
queueMarkColor
=
mozilla
:
:
Some
(
MarkColor
:
:
Black
)
;
setMarkColor
(
MarkColor
:
:
Black
)
;
}
else
if
(
js
:
:
StringEqualsLiteral
(
str
"
unset
-
color
"
)
)
{
queueMarkColor
.
reset
(
)
;
}
}
}
#
endif
return
QueueComplete
;
}
static
gcstats
:
:
PhaseKind
GrayMarkingPhaseForCurrentPhase
(
const
gcstats
:
:
Statistics
&
stats
)
{
using
namespace
gcstats
;
switch
(
stats
.
currentPhaseKind
(
)
)
{
case
PhaseKind
:
:
SWEEP_MARK
:
return
PhaseKind
:
:
SWEEP_MARK_GRAY
;
case
PhaseKind
:
:
SWEEP_MARK_WEAK
:
return
PhaseKind
:
:
SWEEP_MARK_GRAY_WEAK
;
default
:
MOZ_CRASH
(
"
Unexpected
current
phase
"
)
;
}
}
bool
GCMarker
:
:
markUntilBudgetExhausted
(
SliceBudget
&
budget
ShouldReportMarkTime
reportTime
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
strictCompartmentChecking
)
;
strictCompartmentChecking
=
true
;
auto
acc
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
strictCompartmentChecking
=
false
;
}
)
;
#
endif
if
(
budget
.
isOverBudget
(
)
)
{
return
false
;
}
AutoSetMarkColor
autoSetBlack
(
*
this
MarkColor
:
:
Black
)
;
while
(
!
isDrained
(
)
)
{
if
(
!
traceBarrieredCells
(
budget
)
)
{
return
false
;
}
while
(
hasBlackEntries
(
)
)
{
MOZ_ASSERT
(
markColor
(
)
=
=
MarkColor
:
:
Black
)
;
processMarkStackTop
(
budget
)
;
if
(
budget
.
isOverBudget
(
)
)
{
return
false
;
}
}
if
(
hasGrayEntries
(
)
)
{
mozilla
:
:
Maybe
<
gcstats
:
:
AutoPhase
>
ap
;
if
(
reportTime
)
{
auto
&
stats
=
runtime
(
)
-
>
gc
.
stats
(
)
;
ap
.
emplace
(
stats
GrayMarkingPhaseForCurrentPhase
(
stats
)
)
;
}
AutoSetMarkColor
autoSetGray
(
*
this
MarkColor
:
:
Gray
)
;
do
{
processMarkStackTop
(
budget
)
;
MOZ_ASSERT
(
!
hasBlackEntries
(
)
)
;
if
(
budget
.
isOverBudget
(
)
)
{
return
false
;
}
}
while
(
hasGrayEntries
(
)
)
;
}
if
(
!
barrierBuffer
(
)
.
empty
(
)
)
{
continue
;
}
MOZ_ASSERT
(
!
hasBlackEntries
(
)
&
&
!
hasGrayEntries
(
)
)
;
MOZ_ASSERT
(
barrierBuffer
(
)
.
empty
(
)
)
;
if
(
hasDelayedChildren
(
)
&
&
!
markAllDelayedChildren
(
budget
reportTime
)
)
{
return
false
;
}
}
return
true
;
}
static
inline
void
CheckForCompartmentMismatch
(
JSObject
*
obj
JSObject
*
obj2
)
{
#
ifdef
DEBUG
if
(
MOZ_UNLIKELY
(
obj
-
>
compartment
(
)
!
=
obj2
-
>
compartment
(
)
)
)
{
fprintf
(
stderr
"
Compartment
mismatch
in
pointer
from
%
s
object
slot
to
%
s
object
\
n
"
obj
-
>
getClass
(
)
-
>
name
obj2
-
>
getClass
(
)
-
>
name
)
;
MOZ_CRASH
(
"
Compartment
mismatch
"
)
;
}
#
endif
}
static
inline
size_t
NumUsedFixedSlots
(
NativeObject
*
obj
)
{
return
std
:
:
min
(
obj
-
>
numFixedSlots
(
)
obj
-
>
slotSpan
(
)
)
;
}
static
inline
size_t
NumUsedDynamicSlots
(
NativeObject
*
obj
)
{
size_t
nfixed
=
obj
-
>
numFixedSlots
(
)
;
size_t
nslots
=
obj
-
>
slotSpan
(
)
;
if
(
nslots
<
nfixed
)
{
return
0
;
}
return
nslots
-
nfixed
;
}
inline
void
GCMarker
:
:
processMarkStackTop
(
SliceBudget
&
budget
)
{
JSObject
*
obj
;
SlotsOrElementsKind
kind
;
HeapSlot
*
base
;
size_t
index
;
size_t
end
;
switch
(
stack
.
peekTag
(
)
)
{
case
MarkStack
:
:
SlotsOrElementsRangeTag
:
{
auto
range
=
stack
.
popSlotsOrElementsRange
(
)
;
obj
=
range
.
ptr
(
)
.
asRangeObject
(
)
;
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
kind
=
range
.
kind
(
)
;
index
=
range
.
start
(
)
;
switch
(
kind
)
{
case
SlotsOrElementsKind
:
:
FixedSlots
:
{
base
=
nobj
-
>
fixedSlots
(
)
;
end
=
NumUsedFixedSlots
(
nobj
)
;
break
;
}
case
SlotsOrElementsKind
:
:
DynamicSlots
:
{
base
=
nobj
-
>
slots_
;
end
=
NumUsedDynamicSlots
(
nobj
)
;
break
;
}
case
SlotsOrElementsKind
:
:
Elements
:
{
base
=
nobj
-
>
getDenseElements
(
)
;
size_t
numShifted
=
nobj
-
>
getElementsHeader
(
)
-
>
numShiftedElements
(
)
;
size_t
initlen
=
nobj
-
>
getDenseInitializedLength
(
)
;
index
=
std
:
:
max
(
index
numShifted
)
-
numShifted
;
end
=
initlen
;
break
;
}
}
goto
scan_value_range
;
}
case
MarkStack
:
:
ObjectTag
:
{
obj
=
stack
.
popPtr
(
)
.
as
<
JSObject
>
(
)
;
AssertShouldMarkInZone
(
this
obj
)
;
goto
scan_obj
;
}
case
MarkStack
:
:
JitCodeTag
:
{
auto
code
=
stack
.
popPtr
(
)
.
as
<
jit
:
:
JitCode
>
(
)
;
AutoSetTracingSource
asts
(
this
code
)
;
return
code
-
>
traceChildren
(
this
)
;
}
case
MarkStack
:
:
ScriptTag
:
{
auto
script
=
stack
.
popPtr
(
)
.
as
<
BaseScript
>
(
)
;
AutoSetTracingSource
asts
(
this
script
)
;
return
script
-
>
traceChildren
(
this
)
;
}
default
:
MOZ_CRASH
(
"
Invalid
tag
in
mark
stack
"
)
;
}
return
;
scan_value_range
:
while
(
index
<
end
)
{
budget
.
step
(
)
;
if
(
budget
.
isOverBudget
(
)
)
{
pushValueRange
(
obj
kind
index
end
)
;
return
;
}
const
Value
&
v
=
base
[
index
]
;
index
+
+
;
if
(
v
.
isString
(
)
)
{
markAndTraverseEdge
(
obj
v
.
toString
(
)
)
;
}
else
if
(
v
.
hasObjectPayload
(
)
)
{
JSObject
*
obj2
=
&
v
.
getObjectPayload
(
)
;
#
ifdef
DEBUG
if
(
!
obj2
)
{
fprintf
(
stderr
"
processMarkStackTop
found
ObjectValue
(
nullptr
)
"
"
at
%
zu
Values
from
end
of
range
in
object
:
\
n
"
size_t
(
end
-
(
index
-
1
)
)
)
;
obj
-
>
dump
(
)
;
}
#
endif
CheckForCompartmentMismatch
(
obj
obj2
)
;
if
(
mark
(
obj2
)
)
{
pushValueRange
(
obj
kind
index
end
)
;
obj
=
obj2
;
goto
scan_obj
;
}
}
else
if
(
v
.
isSymbol
(
)
)
{
markAndTraverseEdge
(
obj
v
.
toSymbol
(
)
)
;
}
else
if
(
v
.
isBigInt
(
)
)
{
markAndTraverseEdge
(
obj
v
.
toBigInt
(
)
)
;
}
else
if
(
v
.
isPrivateGCThing
(
)
)
{
Cell
*
cell
=
v
.
toGCThing
(
)
;
markAndTraverseEdge
(
obj
JS
:
:
GCCellPtr
(
cell
cell
-
>
getTraceKind
(
)
)
)
;
}
}
return
;
scan_obj
:
{
AssertShouldMarkInZone
(
this
obj
)
;
budget
.
step
(
)
;
if
(
budget
.
isOverBudget
(
)
)
{
repush
(
obj
)
;
return
;
}
markImplicitEdges
(
obj
)
;
markAndTraverseEdge
(
obj
obj
-
>
shape
(
)
)
;
CallTraceHook
(
this
obj
)
;
if
(
!
obj
-
>
is
<
NativeObject
>
(
)
)
{
return
;
}
NativeObject
*
nobj
=
&
obj
-
>
as
<
NativeObject
>
(
)
;
unsigned
nslots
=
nobj
-
>
slotSpan
(
)
;
do
{
if
(
nobj
-
>
hasEmptyElements
(
)
)
{
break
;
}
base
=
nobj
-
>
getDenseElements
(
)
;
kind
=
SlotsOrElementsKind
:
:
Elements
;
index
=
0
;
end
=
nobj
-
>
getDenseInitializedLength
(
)
;
if
(
!
nslots
)
{
goto
scan_value_range
;
}
pushValueRange
(
nobj
kind
index
end
)
;
}
while
(
false
)
;
unsigned
nfixed
=
nobj
-
>
numFixedSlots
(
)
;
base
=
nobj
-
>
fixedSlots
(
)
;
kind
=
SlotsOrElementsKind
:
:
FixedSlots
;
index
=
0
;
if
(
nslots
>
nfixed
)
{
pushValueRange
(
nobj
kind
index
nfixed
)
;
kind
=
SlotsOrElementsKind
:
:
DynamicSlots
;
base
=
nobj
-
>
slots_
;
end
=
nslots
-
nfixed
;
goto
scan_value_range
;
}
MOZ_ASSERT
(
nslots
<
=
nobj
-
>
numFixedSlots
(
)
)
;
end
=
nslots
;
goto
scan_value_range
;
}
}
static_assert
(
sizeof
(
MarkStack
:
:
TaggedPtr
)
=
=
sizeof
(
uintptr_t
)
"
A
TaggedPtr
should
be
the
same
size
as
a
pointer
"
)
;
static_assert
(
(
sizeof
(
MarkStack
:
:
SlotsOrElementsRange
)
%
sizeof
(
uintptr_t
)
)
=
=
0
"
SlotsOrElementsRange
size
should
be
a
multiple
of
"
"
the
pointer
size
"
)
;
static
const
size_t
ValueRangeWords
=
sizeof
(
MarkStack
:
:
SlotsOrElementsRange
)
/
sizeof
(
uintptr_t
)
;
template
<
typename
T
>
struct
MapTypeToMarkStackTag
{
}
;
template
<
>
struct
MapTypeToMarkStackTag
<
JSObject
*
>
{
static
const
auto
value
=
MarkStack
:
:
ObjectTag
;
}
;
template
<
>
struct
MapTypeToMarkStackTag
<
jit
:
:
JitCode
*
>
{
static
const
auto
value
=
MarkStack
:
:
JitCodeTag
;
}
;
template
<
>
struct
MapTypeToMarkStackTag
<
BaseScript
*
>
{
static
const
auto
value
=
MarkStack
:
:
ScriptTag
;
}
;
static
inline
bool
TagIsRangeTag
(
MarkStack
:
:
Tag
tag
)
{
return
tag
=
=
MarkStack
:
:
SlotsOrElementsRangeTag
;
}
inline
MarkStack
:
:
TaggedPtr
:
:
TaggedPtr
(
Tag
tag
Cell
*
ptr
)
:
bits
(
tag
|
uintptr_t
(
ptr
)
)
{
assertValid
(
)
;
}
inline
MarkStack
:
:
Tag
MarkStack
:
:
TaggedPtr
:
:
tag
(
)
const
{
auto
tag
=
Tag
(
bits
&
TagMask
)
;
MOZ_ASSERT
(
tag
<
=
LastTag
)
;
return
tag
;
}
inline
Cell
*
MarkStack
:
:
TaggedPtr
:
:
ptr
(
)
const
{
return
reinterpret_cast
<
Cell
*
>
(
bits
&
~
TagMask
)
;
}
inline
void
MarkStack
:
:
TaggedPtr
:
:
assertValid
(
)
const
{
(
void
)
tag
(
)
;
MOZ_ASSERT
(
IsCellPointerValid
(
ptr
(
)
)
)
;
}
template
<
typename
T
>
inline
T
*
MarkStack
:
:
TaggedPtr
:
:
as
(
)
const
{
MOZ_ASSERT
(
tag
(
)
=
=
MapTypeToMarkStackTag
<
T
*
>
:
:
value
)
;
MOZ_ASSERT
(
ptr
(
)
-
>
isTenured
(
)
)
;
MOZ_ASSERT
(
ptr
(
)
-
>
is
<
T
>
(
)
)
;
return
static_cast
<
T
*
>
(
ptr
(
)
)
;
}
inline
JSObject
*
MarkStack
:
:
TaggedPtr
:
:
asRangeObject
(
)
const
{
MOZ_ASSERT
(
TagIsRangeTag
(
tag
(
)
)
)
;
MOZ_ASSERT
(
ptr
(
)
-
>
isTenured
(
)
)
;
return
ptr
(
)
-
>
as
<
JSObject
>
(
)
;
}
inline
JSRope
*
MarkStack
:
:
TaggedPtr
:
:
asTempRope
(
)
const
{
MOZ_ASSERT
(
tag
(
)
=
=
TempRopeTag
)
;
return
&
ptr
(
)
-
>
as
<
JSString
>
(
)
-
>
asRope
(
)
;
}
inline
MarkStack
:
:
SlotsOrElementsRange
:
:
SlotsOrElementsRange
(
SlotsOrElementsKind
kindArg
JSObject
*
obj
size_t
startArg
)
:
startAndKind_
(
(
startArg
<
<
StartShift
)
|
size_t
(
kindArg
)
)
ptr_
(
SlotsOrElementsRangeTag
obj
)
{
assertValid
(
)
;
MOZ_ASSERT
(
kind
(
)
=
=
kindArg
)
;
MOZ_ASSERT
(
start
(
)
=
=
startArg
)
;
}
inline
void
MarkStack
:
:
SlotsOrElementsRange
:
:
assertValid
(
)
const
{
ptr_
.
assertValid
(
)
;
MOZ_ASSERT
(
TagIsRangeTag
(
ptr_
.
tag
(
)
)
)
;
}
inline
SlotsOrElementsKind
MarkStack
:
:
SlotsOrElementsRange
:
:
kind
(
)
const
{
return
SlotsOrElementsKind
(
startAndKind_
&
KindMask
)
;
}
inline
size_t
MarkStack
:
:
SlotsOrElementsRange
:
:
start
(
)
const
{
return
startAndKind_
>
>
StartShift
;
}
inline
MarkStack
:
:
TaggedPtr
MarkStack
:
:
SlotsOrElementsRange
:
:
ptr
(
)
const
{
return
ptr_
;
}
MarkStack
:
:
MarkStack
(
size_t
maxCapacity
)
:
topIndex_
(
0
)
maxCapacity_
(
maxCapacity
)
#
ifdef
DEBUG
iteratorCount_
(
0
)
#
endif
{
}
MarkStack
:
:
~
MarkStack
(
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
MOZ_ASSERT
(
iteratorCount_
=
=
0
)
;
}
bool
MarkStack
:
:
init
(
bool
incrementalGCEnabled
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
return
setStackCapacity
(
incrementalGCEnabled
)
;
}
bool
MarkStack
:
:
setStackCapacity
(
bool
incrementalGCEnabled
)
{
size_t
capacity
;
if
(
incrementalGCEnabled
)
{
capacity
=
INCREMENTAL_MARK_STACK_BASE_CAPACITY
;
}
else
{
capacity
=
NON_INCREMENTAL_MARK_STACK_BASE_CAPACITY
;
}
if
(
capacity
>
maxCapacity_
)
{
capacity
=
maxCapacity_
;
}
return
resize
(
capacity
)
;
}
void
MarkStack
:
:
setMaxCapacity
(
size_t
maxCapacity
)
{
MOZ_ASSERT
(
maxCapacity
!
=
0
)
;
MOZ_ASSERT
(
isEmpty
(
)
)
;
maxCapacity_
=
maxCapacity
;
if
(
capacity
(
)
>
maxCapacity_
)
{
(
void
)
resize
(
maxCapacity_
)
;
}
}
inline
MarkStack
:
:
TaggedPtr
*
MarkStack
:
:
topPtr
(
)
{
return
&
stack
(
)
[
topIndex_
]
;
}
inline
bool
MarkStack
:
:
pushTaggedPtr
(
Tag
tag
Cell
*
ptr
)
{
if
(
!
ensureSpace
(
1
)
)
{
return
false
;
}
*
topPtr
(
)
=
TaggedPtr
(
tag
ptr
)
;
topIndex_
+
+
;
return
true
;
}
template
<
typename
T
>
inline
bool
MarkStack
:
:
push
(
T
*
ptr
)
{
return
pushTaggedPtr
(
MapTypeToMarkStackTag
<
T
*
>
:
:
value
ptr
)
;
}
inline
bool
MarkStack
:
:
pushTempRope
(
JSRope
*
rope
)
{
return
pushTaggedPtr
(
TempRopeTag
rope
)
;
}
inline
bool
MarkStack
:
:
push
(
JSObject
*
obj
SlotsOrElementsKind
kind
size_t
start
)
{
return
push
(
SlotsOrElementsRange
(
kind
obj
start
)
)
;
}
inline
bool
MarkStack
:
:
push
(
const
SlotsOrElementsRange
&
array
)
{
array
.
assertValid
(
)
;
if
(
!
ensureSpace
(
ValueRangeWords
)
)
{
return
false
;
}
*
reinterpret_cast
<
SlotsOrElementsRange
*
>
(
topPtr
(
)
)
=
array
;
topIndex_
+
=
ValueRangeWords
;
MOZ_ASSERT
(
position
(
)
<
=
capacity
(
)
)
;
MOZ_ASSERT
(
TagIsRangeTag
(
peekTag
(
)
)
)
;
return
true
;
}
inline
const
MarkStack
:
:
TaggedPtr
&
MarkStack
:
:
peekPtr
(
)
const
{
return
stack
(
)
[
topIndex_
-
1
]
;
}
inline
MarkStack
:
:
Tag
MarkStack
:
:
peekTag
(
)
const
{
return
peekPtr
(
)
.
tag
(
)
;
}
inline
MarkStack
:
:
TaggedPtr
MarkStack
:
:
popPtr
(
)
{
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
MOZ_ASSERT
(
!
TagIsRangeTag
(
peekTag
(
)
)
)
;
peekPtr
(
)
.
assertValid
(
)
;
topIndex_
-
-
;
return
*
topPtr
(
)
;
}
inline
MarkStack
:
:
SlotsOrElementsRange
MarkStack
:
:
popSlotsOrElementsRange
(
)
{
MOZ_ASSERT
(
TagIsRangeTag
(
peekTag
(
)
)
)
;
MOZ_ASSERT
(
position
(
)
>
=
ValueRangeWords
)
;
topIndex_
-
=
ValueRangeWords
;
const
auto
&
array
=
*
reinterpret_cast
<
SlotsOrElementsRange
*
>
(
topPtr
(
)
)
;
array
.
assertValid
(
)
;
return
array
;
}
inline
bool
MarkStack
:
:
ensureSpace
(
size_t
count
)
{
if
(
MOZ_LIKELY
(
(
topIndex_
+
count
)
<
=
capacity
(
)
)
)
{
return
!
js
:
:
oom
:
:
ShouldFailWithOOM
(
)
;
}
return
enlarge
(
count
)
;
}
MOZ_NEVER_INLINE
bool
MarkStack
:
:
enlarge
(
size_t
count
)
{
size_t
newCapacity
=
std
:
:
min
(
maxCapacity_
.
ref
(
)
capacity
(
)
*
2
)
;
if
(
newCapacity
<
capacity
(
)
+
count
)
{
return
false
;
}
return
resize
(
newCapacity
)
;
}
bool
MarkStack
:
:
resize
(
size_t
newCapacity
)
{
MOZ_ASSERT
(
newCapacity
!
=
0
)
;
if
(
!
stack
(
)
.
resize
(
newCapacity
)
)
{
return
false
;
}
poisonUnused
(
)
;
return
true
;
}
inline
void
MarkStack
:
:
poisonUnused
(
)
{
static_assert
(
(
JS_FRESH_MARK_STACK_PATTERN
&
TagMask
)
>
LastTag
"
The
mark
stack
poison
pattern
must
not
look
like
a
valid
"
"
tagged
pointer
"
)
;
AlwaysPoison
(
stack
(
)
.
begin
(
)
+
topIndex_
JS_FRESH_MARK_STACK_PATTERN
stack
(
)
.
capacity
(
)
-
topIndex_
MemCheckKind
:
:
MakeUndefined
)
;
}
size_t
MarkStack
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
stack
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
MarkStackIter
:
:
MarkStackIter
(
MarkStack
&
stack
)
:
stack_
(
stack
)
pos_
(
stack
.
position
(
)
)
{
#
ifdef
DEBUG
stack
.
iteratorCount_
+
+
;
#
endif
}
MarkStackIter
:
:
~
MarkStackIter
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
stack_
.
iteratorCount_
)
;
stack_
.
iteratorCount_
-
-
;
#
endif
}
inline
size_t
MarkStackIter
:
:
position
(
)
const
{
return
pos_
;
}
inline
bool
MarkStackIter
:
:
done
(
)
const
{
return
position
(
)
=
=
0
;
}
inline
MarkStack
:
:
TaggedPtr
MarkStackIter
:
:
peekPtr
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
stack_
.
stack
(
)
[
pos_
-
1
]
;
}
inline
MarkStack
:
:
Tag
MarkStackIter
:
:
peekTag
(
)
const
{
return
peekPtr
(
)
.
tag
(
)
;
}
inline
void
MarkStackIter
:
:
nextPtr
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
!
TagIsRangeTag
(
peekTag
(
)
)
)
;
pos_
-
-
;
}
inline
void
MarkStackIter
:
:
next
(
)
{
if
(
TagIsRangeTag
(
peekTag
(
)
)
)
{
nextArray
(
)
;
}
else
{
nextPtr
(
)
;
}
}
inline
void
MarkStackIter
:
:
nextArray
(
)
{
MOZ_ASSERT
(
TagIsRangeTag
(
peekTag
(
)
)
)
;
MOZ_ASSERT
(
position
(
)
>
=
ValueRangeWords
)
;
pos_
-
=
ValueRangeWords
;
}
GCMarker
:
:
GCMarker
(
JSRuntime
*
rt
)
:
GenericTracerImpl
(
rt
JS
:
:
TracerKind
:
:
Marking
JS
:
:
TraceOptions
(
JS
:
:
WeakMapTraceAction
:
:
Expand
JS
:
:
WeakEdgeTraceAction
:
:
Skip
)
)
stack
(
)
grayPosition
(
0
)
color
(
MarkColor
:
:
Black
)
delayedMarkingList
(
nullptr
)
delayedMarkingWorkAdded
(
false
)
state
(
MarkingState
:
:
NotActive
)
incrementalWeakMapMarkingEnabled
(
TuningDefaults
:
:
IncrementalWeakMapMarkingEnabled
)
#
ifdef
DEBUG
markLaterArenas
(
0
)
checkAtomMarking
(
true
)
strictCompartmentChecking
(
false
)
markQueue
(
rt
)
queuePos
(
0
)
#
endif
{
}
bool
GCMarker
:
:
init
(
)
{
bool
incrementalGCEnabled
=
runtime
(
)
-
>
gc
.
isIncrementalGCEnabled
(
)
;
return
stack
.
init
(
incrementalGCEnabled
)
;
}
bool
GCMarker
:
:
isDrained
(
)
{
return
barrierBuffer
(
)
.
empty
(
)
&
&
isMarkStackEmpty
(
)
&
&
!
delayedMarkingList
;
}
void
GCMarker
:
:
start
(
)
{
MOZ_ASSERT
(
state
=
=
MarkingState
:
:
NotActive
)
;
state
=
MarkingState
:
:
RegularMarking
;
color
=
MarkColor
:
:
Black
;
#
ifdef
DEBUG
queuePos
=
0
;
queueMarkColor
.
reset
(
)
;
#
endif
MOZ_ASSERT
(
!
delayedMarkingList
)
;
MOZ_ASSERT
(
markLaterArenas
=
=
0
)
;
}
static
void
ClearEphemeronEdges
(
JSRuntime
*
rt
)
{
AutoEnterOOMUnsafeRegion
oomUnsafe
;
for
(
GCZonesIter
zone
(
rt
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zone
-
>
gcEphemeronEdges
(
)
.
clear
(
)
)
{
oomUnsafe
.
crash
(
"
clearing
weak
keys
in
GCMarker
:
:
stop
(
)
"
)
;
}
if
(
!
zone
-
>
gcNurseryEphemeronEdges
(
)
.
clear
(
)
)
{
oomUnsafe
.
crash
(
"
clearing
(
nursery
)
weak
keys
in
GCMarker
:
:
stop
(
)
"
)
;
}
}
}
void
GCMarker
:
:
stop
(
)
{
MOZ_ASSERT
(
isDrained
(
)
)
;
MOZ_ASSERT
(
!
delayedMarkingList
)
;
MOZ_ASSERT
(
markLaterArenas
=
=
0
)
;
if
(
state
=
=
MarkingState
:
:
NotActive
)
{
return
;
}
state
=
MarkingState
:
:
NotActive
;
barrierBuffer
(
)
.
clearAndFree
(
)
;
stack
.
clear
(
)
;
ClearEphemeronEdges
(
runtime
(
)
)
;
}
template
<
typename
F
>
inline
void
GCMarker
:
:
forEachDelayedMarkingArena
(
F
&
&
f
)
{
Arena
*
arena
=
delayedMarkingList
;
Arena
*
next
;
while
(
arena
)
{
next
=
arena
-
>
getNextDelayedMarking
(
)
;
f
(
arena
)
;
arena
=
next
;
}
}
void
GCMarker
:
:
reset
(
)
{
color
=
MarkColor
:
:
Black
;
barrierBuffer
(
)
.
clearAndFree
(
)
;
stack
.
clear
(
)
;
ClearEphemeronEdges
(
runtime
(
)
)
;
MOZ_ASSERT
(
isMarkStackEmpty
(
)
)
;
forEachDelayedMarkingArena
(
[
&
]
(
Arena
*
arena
)
{
MOZ_ASSERT
(
arena
-
>
onDelayedMarkingList
(
)
)
;
arena
-
>
clearDelayedMarkingState
(
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
markLaterArenas
)
;
markLaterArenas
-
-
;
#
endif
}
)
;
delayedMarkingList
=
nullptr
;
MOZ_ASSERT
(
isDrained
(
)
)
;
MOZ_ASSERT
(
!
markLaterArenas
)
;
}
void
GCMarker
:
:
setMarkColor
(
gc
:
:
MarkColor
newColor
)
{
if
(
color
=
=
newColor
)
{
return
;
}
MOZ_ASSERT
(
runtime
(
)
-
>
gc
.
state
(
)
=
=
State
:
:
Sweep
)
;
MOZ_ASSERT
(
!
hasBlackEntries
(
)
)
;
color
=
newColor
;
if
(
color
=
=
MarkColor
:
:
Black
)
{
grayPosition
=
stack
.
position
(
)
;
}
else
{
grayPosition
=
SIZE_MAX
;
}
}
template
<
typename
T
>
inline
void
GCMarker
:
:
pushTaggedPtr
(
T
*
ptr
)
{
checkZone
(
ptr
)
;
if
(
!
stack
.
push
(
ptr
)
)
{
delayMarkingChildrenOnOOM
(
ptr
)
;
}
}
void
GCMarker
:
:
pushValueRange
(
JSObject
*
obj
SlotsOrElementsKind
kind
size_t
start
size_t
end
)
{
checkZone
(
obj
)
;
MOZ_ASSERT
(
obj
-
>
is
<
NativeObject
>
(
)
)
;
MOZ_ASSERT
(
start
<
=
end
)
;
if
(
start
=
=
end
)
{
return
;
}
if
(
!
stack
.
push
(
obj
kind
start
)
)
{
delayMarkingChildrenOnOOM
(
obj
)
;
}
}
void
GCMarker
:
:
repush
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
obj
-
>
asTenured
(
)
.
isMarkedAtLeast
(
markColor
(
)
)
)
;
pushTaggedPtr
(
obj
)
;
}
bool
GCMarker
:
:
enterWeakMarkingMode
(
)
{
MOZ_ASSERT
(
weakMapAction
(
)
=
=
JS
:
:
WeakMapTraceAction
:
:
Expand
)
;
MOZ_ASSERT
(
state
!
=
MarkingState
:
:
WeakMarking
)
;
if
(
state
=
=
MarkingState
:
:
IterativeMarking
)
{
return
false
;
}
state
=
MarkingState
:
:
WeakMarking
;
while
(
processMarkQueue
(
)
=
=
QueueYielded
)
{
}
;
return
true
;
}
IncrementalProgress
JS
:
:
Zone
:
:
enterWeakMarkingMode
(
GCMarker
*
marker
SliceBudget
&
budget
)
{
MOZ_ASSERT
(
marker
-
>
isWeakMarking
(
)
)
;
if
(
!
marker
-
>
incrementalWeakMapMarkingEnabled
)
{
for
(
WeakMapBase
*
m
:
gcWeakMapList
(
)
)
{
if
(
m
-
>
mapColor
)
{
(
void
)
m
-
>
markEntries
(
marker
)
;
}
}
return
IncrementalProgress
:
:
Finished
;
}
if
(
!
isGCMarking
(
)
)
{
return
IncrementalProgress
:
:
Finished
;
}
MOZ_ASSERT
(
gcNurseryEphemeronEdges
(
)
.
count
(
)
=
=
0
)
;
EphemeronEdgeTable
:
:
MutableRange
r
=
gcEphemeronEdges
(
)
.
mutableAll
(
)
;
while
(
!
r
.
empty
(
)
)
{
Cell
*
src
=
r
.
front
(
)
.
key
;
CellColor
srcColor
=
gc
:
:
detail
:
:
GetEffectiveColor
(
marker
src
)
;
auto
&
edges
=
r
.
front
(
)
.
value
;
r
.
popFront
(
)
;
if
(
edges
.
length
(
)
>
0
)
{
uint32_t
steps
=
edges
.
length
(
)
;
marker
-
>
markEphemeronEdges
(
edges
srcColor
)
;
budget
.
step
(
steps
)
;
if
(
budget
.
isOverBudget
(
)
)
{
return
NotFinished
;
}
}
}
return
IncrementalProgress
:
:
Finished
;
}
void
GCMarker
:
:
leaveWeakMarkingMode
(
)
{
MOZ_ASSERT
(
state
=
=
MarkingState
:
:
WeakMarking
|
|
state
=
=
MarkingState
:
:
IterativeMarking
)
;
if
(
state
!
=
MarkingState
:
:
IterativeMarking
)
{
state
=
MarkingState
:
:
RegularMarking
;
}
}
MOZ_NEVER_INLINE
void
GCMarker
:
:
delayMarkingChildrenOnOOM
(
Cell
*
cell
)
{
delayMarkingChildren
(
cell
)
;
}
void
GCMarker
:
:
delayMarkingChildren
(
Cell
*
cell
)
{
Arena
*
arena
=
cell
-
>
asTenured
(
)
.
arena
(
)
;
if
(
!
arena
-
>
onDelayedMarkingList
(
)
)
{
arena
-
>
setNextDelayedMarkingArena
(
delayedMarkingList
)
;
delayedMarkingList
=
arena
;
#
ifdef
DEBUG
markLaterArenas
+
+
;
#
endif
}
JS
:
:
TraceKind
kind
=
MapAllocToTraceKind
(
arena
-
>
getAllocKind
(
)
)
;
MarkColor
colorToMark
=
TraceKindCanBeMarkedGray
(
kind
)
?
color
:
MarkColor
:
:
Black
;
if
(
!
arena
-
>
hasDelayedMarking
(
colorToMark
)
)
{
arena
-
>
setHasDelayedMarking
(
colorToMark
true
)
;
delayedMarkingWorkAdded
=
true
;
}
}
void
GCMarker
:
:
markDelayedChildren
(
Arena
*
arena
MarkColor
color
)
{
JS
:
:
TraceKind
kind
=
MapAllocToTraceKind
(
arena
-
>
getAllocKind
(
)
)
;
MOZ_ASSERT_IF
(
color
=
=
MarkColor
:
:
Gray
TraceKindCanBeMarkedGray
(
kind
)
)
;
AutoSetMarkColor
setColor
(
*
this
color
)
;
for
(
ArenaCellIterUnderGC
cell
(
arena
)
;
!
cell
.
done
(
)
;
cell
.
next
(
)
)
{
if
(
cell
-
>
isMarked
(
color
)
)
{
JS
:
:
TraceChildren
(
this
JS
:
:
GCCellPtr
(
cell
kind
)
)
;
}
}
}
bool
GCMarker
:
:
processDelayedMarkingList
(
MarkColor
color
SliceBudget
&
budget
)
{
do
{
delayedMarkingWorkAdded
=
false
;
for
(
Arena
*
arena
=
delayedMarkingList
;
arena
;
arena
=
arena
-
>
getNextDelayedMarking
(
)
)
{
if
(
!
arena
-
>
hasDelayedMarking
(
color
)
)
{
continue
;
}
arena
-
>
setHasDelayedMarking
(
color
false
)
;
markDelayedChildren
(
arena
color
)
;
budget
.
step
(
150
)
;
if
(
budget
.
isOverBudget
(
)
)
{
return
false
;
}
}
}
while
(
delayedMarkingWorkAdded
)
;
return
true
;
}
bool
GCMarker
:
:
markAllDelayedChildren
(
SliceBudget
&
budget
ShouldReportMarkTime
reportTime
)
{
MOZ_ASSERT
(
isMarkStackEmpty
(
)
)
;
MOZ_ASSERT
(
markColor
(
)
=
=
MarkColor
:
:
Black
)
;
MOZ_ASSERT
(
delayedMarkingList
)
;
GCRuntime
&
gc
=
runtime
(
)
-
>
gc
;
mozilla
:
:
Maybe
<
gcstats
:
:
AutoPhase
>
ap
;
if
(
reportTime
)
{
ap
.
emplace
(
gc
.
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_DELAYED
)
;
}
const
MarkColor
colors
[
]
=
{
MarkColor
:
:
Black
MarkColor
:
:
Gray
}
;
for
(
MarkColor
color
:
colors
)
{
bool
finished
=
processDelayedMarkingList
(
color
budget
)
;
rebuildDelayedMarkingList
(
)
;
if
(
!
finished
)
{
return
false
;
}
}
MOZ_ASSERT
(
!
delayedMarkingList
)
;
MOZ_ASSERT
(
!
markLaterArenas
)
;
return
true
;
}
void
GCMarker
:
:
rebuildDelayedMarkingList
(
)
{
Arena
*
listTail
=
nullptr
;
forEachDelayedMarkingArena
(
[
&
]
(
Arena
*
arena
)
{
if
(
!
arena
-
>
hasAnyDelayedMarking
(
)
)
{
arena
-
>
clearDelayedMarkingState
(
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
markLaterArenas
)
;
markLaterArenas
-
-
;
#
endif
return
;
}
appendToDelayedMarkingList
(
&
listTail
arena
)
;
}
)
;
appendToDelayedMarkingList
(
&
listTail
nullptr
)
;
}
inline
void
GCMarker
:
:
appendToDelayedMarkingList
(
Arena
*
*
listTail
Arena
*
arena
)
{
if
(
*
listTail
)
{
(
*
listTail
)
-
>
updateNextDelayedMarkingArena
(
arena
)
;
}
else
{
delayedMarkingList
=
arena
;
}
*
listTail
=
arena
;
}
#
ifdef
DEBUG
void
GCMarker
:
:
checkZone
(
void
*
p
)
{
MOZ_ASSERT
(
state
!
=
MarkingState
:
:
NotActive
)
;
DebugOnly
<
Cell
*
>
cell
=
static_cast
<
Cell
*
>
(
p
)
;
MOZ_ASSERT_IF
(
cell
-
>
isTenured
(
)
cell
-
>
asTenured
(
)
.
zone
(
)
-
>
isCollectingFromAnyThread
(
)
)
;
}
#
endif
size_t
GCMarker
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
size
=
stack
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
size
+
=
barrierBuffer_
.
ref
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
return
size
;
}
template
<
typename
T
>
static
inline
void
CheckIsMarkedThing
(
T
*
thing
)
{
#
define
IS_SAME_TYPE_OR
(
name
type
_
_1
)
std
:
:
is_same_v
<
type
T
>
|
|
static_assert
(
JS_FOR_EACH_TRACEKIND
(
IS_SAME_TYPE_OR
)
false
"
Only
the
base
cell
layout
types
are
allowed
into
"
"
marking
/
tracing
internals
"
)
;
#
undef
IS_SAME_TYPE_OR
#
ifdef
DEBUG
MOZ_ASSERT
(
thing
)
;
Zone
*
zone
=
thing
-
>
zoneFromAnyThread
(
)
;
if
(
thing
-
>
isPermanentAndMayBeShared
(
)
)
{
MOZ_ASSERT
(
!
zone
-
>
wasGCStarted
(
)
)
;
MOZ_ASSERT
(
!
zone
-
>
needsIncrementalBarrier
(
)
)
;
MOZ_ASSERT
(
thing
-
>
isMarkedBlack
(
)
)
;
return
;
}
JS
:
:
GCContext
*
gcx
=
TlsGCContext
.
get
(
)
;
MOZ_ASSERT
(
gcx
-
>
gcUse
(
)
!
=
GCUse
:
:
Finalizing
)
;
if
(
gcx
-
>
gcUse
(
)
=
=
GCUse
:
:
Sweeping
|
|
gcx
-
>
gcUse
(
)
=
=
GCUse
:
:
Marking
)
{
MOZ_ASSERT_IF
(
gcx
-
>
gcSweepZone
(
)
gcx
-
>
gcSweepZone
(
)
=
=
zone
|
|
zone
-
>
isAtomsZone
(
)
)
;
return
;
}
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
thing
-
>
runtimeFromAnyThread
(
)
)
|
|
CurrentThreadCanAccessZone
(
thing
-
>
zoneFromAnyThread
(
)
)
)
;
#
endif
}
template
<
typename
T
>
bool
js
:
:
gc
:
:
IsMarkedInternal
(
JSRuntime
*
rt
T
*
thing
)
{
MOZ_ASSERT
(
!
CurrentThreadIsGCFinalizing
(
)
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsMinorCollecting
(
)
)
;
MOZ_ASSERT
(
thing
)
;
CheckIsMarkedThing
(
thing
)
;
MOZ_ASSERT
(
!
IsForwarded
(
thing
)
)
;
TenuredCell
*
cell
=
&
thing
-
>
asTenured
(
)
;
Zone
*
zone
=
cell
-
>
zoneFromAnyThread
(
)
;
#
ifdef
DEBUG
if
(
IsOwnedByOtherRuntime
(
rt
thing
)
)
{
MOZ_ASSERT
(
!
zone
-
>
wasGCStarted
(
)
)
;
MOZ_ASSERT
(
thing
-
>
isMarkedBlack
(
)
)
;
}
#
endif
return
!
zone
-
>
isGCMarking
(
)
|
|
cell
-
>
isMarkedAny
(
)
;
}
template
<
typename
T
>
bool
js
:
:
gc
:
:
IsAboutToBeFinalizedInternal
(
T
*
thing
)
{
MOZ_ASSERT
(
!
CurrentThreadIsGCFinalizing
(
)
)
;
MOZ_ASSERT
(
thing
)
;
CheckIsMarkedThing
(
thing
)
;
MOZ_ASSERT
(
!
IsForwarded
(
thing
)
)
;
if
(
!
thing
-
>
isTenured
(
)
)
{
return
false
;
}
TenuredCell
*
cell
=
&
thing
-
>
asTenured
(
)
;
Zone
*
zone
=
cell
-
>
zoneFromAnyThread
(
)
;
#
ifdef
DEBUG
JSRuntime
*
rt
=
TlsGCContext
.
get
(
)
-
>
runtimeFromAnyThread
(
)
;
if
(
IsOwnedByOtherRuntime
(
rt
thing
)
)
{
MOZ_ASSERT
(
!
zone
-
>
wasGCStarted
(
)
)
;
MOZ_ASSERT
(
thing
-
>
isMarkedBlack
(
)
)
;
}
#
endif
return
zone
-
>
isGCSweeping
(
)
&
&
!
cell
-
>
isMarkedAny
(
)
;
}
template
<
typename
T
>
bool
js
:
:
gc
:
:
IsAboutToBeFinalizedInternal
(
const
T
&
thing
)
{
bool
dying
=
false
;
ApplyGCThingTyped
(
thing
[
&
dying
]
(
auto
t
)
{
dying
=
IsAboutToBeFinalizedInternal
(
t
)
;
}
)
;
return
dying
;
}
SweepingTracer
:
:
SweepingTracer
(
JSRuntime
*
rt
)
:
GenericTracerImpl
(
rt
JS
:
:
TracerKind
:
:
Sweeping
JS
:
:
WeakMapTraceAction
:
:
TraceKeysAndValues
)
{
}
template
<
typename
T
>
inline
void
SweepingTracer
:
:
onEdge
(
T
*
*
thingp
const
char
*
name
)
{
T
*
thing
=
*
thingp
;
CheckIsMarkedThing
(
thing
)
;
if
(
!
thing
-
>
isTenured
(
)
)
{
return
;
}
TenuredCell
*
cell
=
&
thing
-
>
asTenured
(
)
;
Zone
*
zone
=
cell
-
>
zoneFromAnyThread
(
)
;
#
ifdef
DEBUG
if
(
IsOwnedByOtherRuntime
(
runtime
(
)
thing
)
)
{
MOZ_ASSERT
(
!
zone
-
>
wasGCStarted
(
)
)
;
MOZ_ASSERT
(
thing
-
>
isMarkedBlack
(
)
)
;
}
#
endif
if
(
zone
-
>
isGCSweeping
(
)
&
&
!
cell
-
>
isMarkedAny
(
)
)
{
*
thingp
=
nullptr
;
}
}
namespace
js
{
namespace
gc
{
template
<
typename
T
>
JS_PUBLIC_API
bool
TraceWeakEdge
(
JSTracer
*
trc
JS
:
:
Heap
<
T
>
*
thingp
)
{
return
TraceEdgeInternal
(
trc
gc
:
:
ConvertToBase
(
thingp
-
>
unsafeGet
(
)
)
"
JS
:
:
Heap
edge
"
)
;
}
template
<
typename
T
>
JS_PUBLIC_API
bool
EdgeNeedsSweepUnbarrieredSlow
(
T
*
thingp
)
{
return
IsAboutToBeFinalizedInternal
(
*
ConvertToBase
(
thingp
)
)
;
}
#
define
INSTANTIATE_ALL_VALID_HEAP_TRACE_FUNCTIONS
(
type
)
\
template
JS_PUBLIC_API
bool
TraceWeakEdge
<
type
>
(
JSTracer
*
trc
\
JS
:
:
Heap
<
type
>
*
)
;
\
template
JS_PUBLIC_API
bool
EdgeNeedsSweepUnbarrieredSlow
<
type
>
(
type
*
)
;
JS_FOR_EACH_PUBLIC_GC_POINTER_TYPE
(
INSTANTIATE_ALL_VALID_HEAP_TRACE_FUNCTIONS
)
JS_FOR_EACH_PUBLIC_TAGGED_GC_POINTER_TYPE
(
INSTANTIATE_ALL_VALID_HEAP_TRACE_FUNCTIONS
)
#
define
INSTANTIATE_INTERNAL_IS_MARKED_FUNCTION
(
type
)
\
template
bool
IsMarkedInternal
(
JSRuntime
*
rt
type
thing
)
;
#
define
INSTANTIATE_INTERNAL_IATBF_FUNCTION
(
type
)
\
template
bool
IsAboutToBeFinalizedInternal
(
type
thingp
)
;
#
define
INSTANTIATE_INTERNAL_MARKING_FUNCTIONS_FROM_TRACEKIND
(
_1
type
_2
\
_3
)
\
INSTANTIATE_INTERNAL_IS_MARKED_FUNCTION
(
type
*
)
\
INSTANTIATE_INTERNAL_IATBF_FUNCTION
(
type
*
)
JS_FOR_EACH_TRACEKIND
(
INSTANTIATE_INTERNAL_MARKING_FUNCTIONS_FROM_TRACEKIND
)
#
define
INSTANTIATE_IATBF_FUNCTION_FOR_TAGGED_POINTER
(
type
)
\
INSTANTIATE_INTERNAL_IATBF_FUNCTION
(
const
type
&
)
JS_FOR_EACH_PUBLIC_TAGGED_GC_POINTER_TYPE
(
INSTANTIATE_IATBF_FUNCTION_FOR_TAGGED_POINTER
)
#
undef
INSTANTIATE_INTERNAL_IS_MARKED_FUNCTION
#
undef
INSTANTIATE_INTERNAL_IATBF_FUNCTION
#
undef
INSTANTIATE_INTERNAL_MARKING_FUNCTIONS_FROM_TRACEKIND
#
undef
INSTANTIATE_IATBF_FUNCTION_FOR_TAGGED_POINTER
}
}
#
ifdef
DEBUG
struct
AssertNonGrayTracer
final
:
public
JS
:
:
CallbackTracer
{
explicit
AssertNonGrayTracer
(
JSRuntime
*
rt
)
:
JS
:
:
CallbackTracer
(
rt
JS
:
:
TracerKind
:
:
UnmarkGray
)
{
}
void
onChild
(
JS
:
:
GCCellPtr
thing
const
char
*
name
)
override
{
MOZ_ASSERT
(
!
thing
.
asCell
(
)
-
>
isMarkedGray
(
)
)
;
}
}
;
#
endif
class
UnmarkGrayTracer
final
:
public
JS
:
:
CallbackTracer
{
public
:
explicit
UnmarkGrayTracer
(
JSRuntime
*
rt
)
:
JS
:
:
CallbackTracer
(
rt
JS
:
:
TracerKind
:
:
UnmarkGray
JS
:
:
WeakMapTraceAction
:
:
Skip
)
unmarkedAny
(
false
)
oom
(
false
)
stack
(
rt
-
>
gc
.
unmarkGrayStack
)
{
}
void
unmark
(
JS
:
:
GCCellPtr
cell
)
;
bool
unmarkedAny
;
bool
oom
;
private
:
Vector
<
JS
:
:
GCCellPtr
0
SystemAllocPolicy
>
&
stack
;
void
onChild
(
JS
:
:
GCCellPtr
thing
const
char
*
name
)
override
;
}
;
void
UnmarkGrayTracer
:
:
onChild
(
JS
:
:
GCCellPtr
thing
const
char
*
name
)
{
Cell
*
cell
=
thing
.
asCell
(
)
;
if
(
!
cell
-
>
isTenured
(
)
|
|
!
TraceKindCanBeMarkedGray
(
cell
-
>
asTenured
(
)
.
getTraceKind
(
)
)
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
cell
-
>
isMarkedGray
(
)
)
;
AssertNonGrayTracer
nongray
(
runtime
(
)
)
;
JS
:
:
TraceChildren
(
&
nongray
thing
)
;
#
endif
return
;
}
TenuredCell
&
tenured
=
cell
-
>
asTenured
(
)
;
Zone
*
zone
=
tenured
.
zone
(
)
;
if
(
zone
-
>
isGCPreparing
(
)
)
{
return
;
}
if
(
zone
-
>
isGCMarking
(
)
)
{
if
(
!
cell
-
>
isMarkedBlack
(
)
)
{
BarrierTracer
*
trc
=
&
runtime
(
)
-
>
gc
.
barrierTracer
;
trc
-
>
performBarrier
(
thing
)
;
unmarkedAny
=
true
;
}
return
;
}
if
(
!
tenured
.
isMarkedGray
(
)
)
{
return
;
}
tenured
.
markBlack
(
)
;
unmarkedAny
=
true
;
if
(
!
stack
.
append
(
thing
)
)
{
oom
=
true
;
}
}
void
UnmarkGrayTracer
:
:
unmark
(
JS
:
:
GCCellPtr
cell
)
{
MOZ_ASSERT
(
stack
.
empty
(
)
)
;
onChild
(
cell
"
unmarking
root
"
)
;
while
(
!
stack
.
empty
(
)
&
&
!
oom
)
{
TraceChildren
(
this
stack
.
popCopy
(
)
)
;
}
if
(
oom
)
{
stack
.
clear
(
)
;
runtime
(
)
-
>
gc
.
setGrayBitsInvalid
(
)
;
return
;
}
}
bool
js
:
:
gc
:
:
UnmarkGrayGCThingUnchecked
(
JSRuntime
*
rt
JS
:
:
GCCellPtr
thing
)
{
MOZ_ASSERT
(
thing
)
;
MOZ_ASSERT
(
thing
.
asCell
(
)
-
>
isMarkedGray
(
)
)
;
mozilla
:
:
Maybe
<
AutoGeckoProfilerEntry
>
profilingStackFrame
;
if
(
JSContext
*
cx
=
TlsContext
.
get
(
)
)
{
profilingStackFrame
.
emplace
(
cx
"
UnmarkGrayGCThing
"
JS
:
:
ProfilingCategoryPair
:
:
GCCC_UnmarkGray
)
;
}
UnmarkGrayTracer
unmarker
(
rt
)
;
unmarker
.
unmark
(
thing
)
;
return
unmarker
.
unmarkedAny
;
}
JS_PUBLIC_API
bool
JS
:
:
UnmarkGrayGCThingRecursively
(
JS
:
:
GCCellPtr
thing
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsCycleCollecting
(
)
)
;
JSRuntime
*
rt
=
thing
.
asCell
(
)
-
>
runtimeFromMainThread
(
)
;
if
(
thing
.
asCell
(
)
-
>
zone
(
)
-
>
isGCPreparing
(
)
)
{
return
false
;
}
return
UnmarkGrayGCThingUnchecked
(
rt
thing
)
;
}
void
js
:
:
gc
:
:
UnmarkGrayGCThingRecursively
(
TenuredCell
*
cell
)
{
JS
:
:
UnmarkGrayGCThingRecursively
(
JS
:
:
GCCellPtr
(
cell
cell
-
>
getTraceKind
(
)
)
)
;
}
bool
js
:
:
UnmarkGrayShapeRecursively
(
Shape
*
shape
)
{
return
JS
:
:
UnmarkGrayGCThingRecursively
(
JS
:
:
GCCellPtr
(
shape
)
)
;
}
#
ifdef
DEBUG
Cell
*
js
:
:
gc
:
:
UninlinedForwarded
(
const
Cell
*
cell
)
{
return
Forwarded
(
cell
)
;
}
#
endif
#
ifdef
DEBUG
static
bool
CellHasChildren
(
JS
:
:
GCCellPtr
cell
)
{
struct
Tracer
:
public
JS
:
:
CallbackTracer
{
bool
hasChildren
=
false
;
explicit
Tracer
(
JSRuntime
*
runtime
)
:
JS
:
:
CallbackTracer
(
runtime
)
{
}
void
onChild
(
JS
:
:
GCCellPtr
thing
const
char
*
name
)
{
hasChildren
=
true
;
}
}
;
Tracer
trc
(
cell
.
asCell
(
)
-
>
runtimeFromMainThread
(
)
)
;
JS
:
:
TraceChildren
(
&
trc
cell
)
;
return
trc
.
hasChildren
;
}
#
endif
static
bool
CellMayHaveChildren
(
JS
:
:
GCCellPtr
cell
)
{
bool
mayHaveChildren
;
switch
(
cell
.
kind
(
)
)
{
case
JS
:
:
TraceKind
:
:
BigInt
:
mayHaveChildren
=
false
;
break
;
case
JS
:
:
TraceKind
:
:
String
:
{
JSString
*
string
=
&
cell
.
as
<
JSString
>
(
)
;
mayHaveChildren
=
string
-
>
hasBase
(
)
|
|
string
-
>
isRope
(
)
;
break
;
}
default
:
mayHaveChildren
=
true
;
break
;
}
MOZ_ASSERT_IF
(
!
mayHaveChildren
!
CellHasChildren
(
cell
)
)
;
return
mayHaveChildren
;
}
BarrierTracer
*
BarrierTracer
:
:
fromTracer
(
JSTracer
*
trc
)
{
MOZ_ASSERT
(
trc
-
>
kind
(
)
=
=
JS
:
:
TracerKind
:
:
Barrier
)
;
return
static_cast
<
BarrierTracer
*
>
(
trc
)
;
}
BarrierTracer
:
:
BarrierTracer
(
JSRuntime
*
rt
)
:
GenericTracerImpl
(
rt
JS
:
:
TracerKind
:
:
Barrier
JS
:
:
WeakEdgeTraceAction
:
:
Skip
)
marker
(
rt
-
>
gc
.
marker
)
{
}
template
<
typename
T
>
void
BarrierTracer
:
:
onEdge
(
T
*
*
thingp
const
char
*
name
)
{
T
*
thing
=
*
thingp
;
PreWriteBarrier
(
thing
)
;
}
constexpr
static
size_t
MaxBarrierBufferSize
=
4096
;
void
BarrierTracer
:
:
performBarrier
(
JS
:
:
GCCellPtr
cell
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime
(
)
)
)
;
MOZ_ASSERT
(
!
runtime
(
)
-
>
gc
.
isBackgroundMarking
(
)
)
;
MOZ_ASSERT
(
!
cell
.
asCell
(
)
-
>
isForwarded
(
)
)
;
MOZ_ASSERT
(
!
cell
.
asCell
(
)
-
>
asTenured
(
)
.
isMarkedBlack
(
)
)
;
cell
.
asCell
(
)
-
>
asTenured
(
)
.
markBlack
(
)
;
bool
requiresTracing
=
CellMayHaveChildren
(
cell
)
;
if
(
!
requiresTracing
)
{
return
;
}
BarrierBuffer
&
buffer
=
marker
.
barrierBuffer
(
)
;
if
(
buffer
.
length
(
)
>
=
MaxBarrierBufferSize
|
|
!
buffer
.
append
(
cell
)
)
{
handleBufferFull
(
cell
)
;
}
}
void
BarrierTracer
:
:
handleBufferFull
(
JS
:
:
GCCellPtr
cell
)
{
SliceBudget
budget
=
SliceBudget
:
:
unlimited
(
)
;
marker
.
traceBarrieredCells
(
budget
)
;
marker
.
traceBarrieredCell
(
cell
)
;
}
bool
GCMarker
:
:
traceBarrieredCells
(
SliceBudget
&
budget
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime
(
)
)
|
|
CurrentThreadIsGCMarking
(
)
)
;
MOZ_ASSERT
(
markColor
(
)
=
=
MarkColor
:
:
Black
)
;
mozilla
:
:
Maybe
<
AutoGeckoProfilerEntry
>
profilingStackFrame
;
if
(
JSContext
*
cx
=
TlsContext
.
get
(
)
)
{
profilingStackFrame
.
emplace
(
cx
"
GCMarker
:
:
traceBarrieredCells
"
JS
:
:
ProfilingCategoryPair
:
:
GCCC_Barrier
)
;
}
BarrierBuffer
&
buffer
=
barrierBuffer
(
)
;
while
(
!
buffer
.
empty
(
)
)
{
traceBarrieredCell
(
buffer
.
popCopy
(
)
)
;
budget
.
step
(
)
;
if
(
budget
.
isOverBudget
(
)
)
{
return
false
;
}
}
return
true
;
}
void
GCMarker
:
:
traceBarrieredCell
(
JS
:
:
GCCellPtr
cell
)
{
MOZ_ASSERT
(
markColor
(
)
=
=
gc
:
:
MarkColor
:
:
Black
)
;
MOZ_ASSERT
(
cell
.
asCell
(
)
-
>
isTenured
(
)
)
;
MOZ_ASSERT
(
cell
.
asCell
(
)
-
>
isMarkedBlack
(
)
)
;
MOZ_ASSERT
(
!
cell
.
asCell
(
)
-
>
isForwarded
(
)
)
;
ApplyGCThingTyped
(
cell
[
this
]
(
auto
thing
)
{
MOZ_ASSERT
(
ShouldMark
(
this
thing
)
)
;
MOZ_ASSERT
(
thing
-
>
isMarkedBlack
(
)
)
;
if
constexpr
(
std
:
:
is_same_v
<
decltype
(
thing
)
JSString
*
>
)
{
if
(
thing
-
>
isRope
(
)
&
&
thing
-
>
asRope
(
)
.
isBeingFlattened
(
)
)
{
return
;
}
}
CheckTracedThing
(
this
thing
)
;
AutoClearTracingSource
acts
(
this
)
;
traverse
(
thing
)
;
}
)
;
}
namespace
js
{
namespace
debug
{
MarkInfo
GetMarkInfo
(
Cell
*
rawCell
)
{
if
(
!
rawCell
-
>
isTenured
(
)
)
{
return
MarkInfo
:
:
NURSERY
;
}
TenuredCell
*
cell
=
&
rawCell
-
>
asTenured
(
)
;
if
(
cell
-
>
isMarkedGray
(
)
)
{
return
MarkInfo
:
:
GRAY
;
}
if
(
cell
-
>
isMarkedBlack
(
)
)
{
return
MarkInfo
:
:
BLACK
;
}
return
MarkInfo
:
:
UNMARKED
;
}
uintptr_t
*
GetMarkWordAddress
(
Cell
*
cell
)
{
if
(
!
cell
-
>
isTenured
(
)
)
{
return
nullptr
;
}
MarkBitmapWord
*
wordp
;
uintptr_t
mask
;
TenuredChunkBase
*
chunk
=
gc
:
:
detail
:
:
GetCellChunkBase
(
&
cell
-
>
asTenured
(
)
)
;
chunk
-
>
markBits
.
getMarkWordAndMask
(
&
cell
-
>
asTenured
(
)
ColorBit
:
:
BlackBit
&
wordp
&
mask
)
;
return
reinterpret_cast
<
uintptr_t
*
>
(
wordp
)
;
}
uintptr_t
GetMarkMask
(
Cell
*
cell
uint32_t
colorBit
)
{
MOZ_ASSERT
(
colorBit
=
=
0
|
|
colorBit
=
=
1
)
;
if
(
!
cell
-
>
isTenured
(
)
)
{
return
0
;
}
ColorBit
bit
=
colorBit
=
=
0
?
ColorBit
:
:
BlackBit
:
ColorBit
:
:
GrayOrBlackBit
;
MarkBitmapWord
*
wordp
;
uintptr_t
mask
;
TenuredChunkBase
*
chunk
=
gc
:
:
detail
:
:
GetCellChunkBase
(
&
cell
-
>
asTenured
(
)
)
;
chunk
-
>
markBits
.
getMarkWordAndMask
(
&
cell
-
>
asTenured
(
)
bit
&
wordp
&
mask
)
;
return
mask
;
}
}
}
