#
include
"
gc
/
MallocedBlockCache
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
using
js
:
:
PointerAndUint7
;
using
js
:
:
gc
:
:
MallocedBlockCache
;
MallocedBlockCache
:
:
~
MallocedBlockCache
(
)
{
clear
(
)
;
}
PointerAndUint7
MallocedBlockCache
:
:
alloc
(
size_t
size
)
{
MOZ_ASSERT
(
size
>
0
)
;
size
=
js
:
:
RoundUp
(
size
STEP
)
;
size_t
i
=
size
/
STEP
;
if
(
MOZ_UNLIKELY
(
i
>
=
NUM_LISTS
)
)
{
void
*
p
=
js_malloc
(
size
)
;
return
PointerAndUint7
(
p
OVERSIZE_BLOCK_LIST_ID
)
;
}
MOZ_ASSERT
(
i
>
=
1
&
&
i
<
NUM_LISTS
)
;
MOZ_ASSERT
(
i
*
STEP
=
=
size
)
;
if
(
MOZ_LIKELY
(
!
lists
[
i
]
.
empty
(
)
)
)
{
void
*
block
=
lists
[
i
]
.
popCopy
(
)
;
return
PointerAndUint7
(
block
i
)
;
}
void
*
p
=
js_malloc
(
size
)
;
if
(
MOZ_UNLIKELY
(
!
p
)
)
{
return
PointerAndUint7
(
nullptr
0
)
;
}
return
PointerAndUint7
(
p
i
)
;
}
void
MallocedBlockCache
:
:
free
(
PointerAndUint7
blockAndListID
)
{
void
*
block
=
blockAndListID
.
pointer
(
)
;
uint32_t
listID
=
blockAndListID
.
uint7
(
)
;
MOZ_ASSERT
(
block
)
;
MOZ_ASSERT
(
listID
<
NUM_LISTS
)
;
if
(
MOZ_UNLIKELY
(
listID
=
=
OVERSIZE_BLOCK_LIST_ID
)
)
{
js_free
(
block
)
;
return
;
}
memset
(
block
JS_NOTINUSE_TRAILER_PATTERN
listID
*
STEP
)
;
MOZ_MAKE_MEM_UNDEFINED
(
block
listID
*
STEP
)
;
if
(
MOZ_UNLIKELY
(
!
lists
[
listID
]
.
append
(
block
)
)
)
{
js_free
(
block
)
;
}
}
void
MallocedBlockCache
:
:
preen
(
float
percentOfBlocksToDiscard
)
{
MOZ_ASSERT
(
percentOfBlocksToDiscard
>
=
0
.
0
&
&
percentOfBlocksToDiscard
<
=
100
.
0
)
;
MOZ_ASSERT
(
lists
[
OVERSIZE_BLOCK_LIST_ID
]
.
empty
(
)
)
;
for
(
size_t
listID
=
1
;
listID
<
NUM_LISTS
;
listID
+
+
)
{
MallocedBlockVector
&
list
=
lists
[
listID
]
;
size_t
numToFree
=
size_t
(
float
(
list
.
length
(
)
)
*
(
percentOfBlocksToDiscard
/
100
.
0
)
)
;
MOZ_RELEASE_ASSERT
(
numToFree
<
=
list
.
length
(
)
)
;
while
(
numToFree
>
0
)
{
void
*
block
=
list
.
popCopy
(
)
;
MOZ_ASSERT
(
block
)
;
js_free
(
block
)
;
numToFree
-
-
;
}
}
}
void
MallocedBlockCache
:
:
clear
(
)
{
MOZ_ASSERT
(
lists
[
OVERSIZE_BLOCK_LIST_ID
]
.
empty
(
)
)
;
for
(
size_t
i
=
1
;
i
<
NUM_LISTS
;
i
+
+
)
{
MallocedBlockVector
&
list
=
lists
[
i
]
;
for
(
size_t
j
=
0
;
j
<
list
.
length
(
)
;
j
+
+
)
{
MOZ_ASSERT
(
list
[
j
]
)
;
js_free
(
list
[
j
]
)
;
list
[
j
]
=
nullptr
;
}
list
.
clear
(
)
;
}
}
size_t
MallocedBlockCache
:
:
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
MOZ_ASSERT
(
lists
[
OVERSIZE_BLOCK_LIST_ID
]
.
empty
(
)
)
;
size_t
nBytes
=
0
;
for
(
size_t
listID
=
0
;
listID
<
NUM_LISTS
;
listID
+
+
)
{
const
MallocedBlockVector
&
list
=
lists
[
listID
]
;
nBytes
+
=
list
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
for
(
size_t
i
=
0
;
i
<
list
.
length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
list
[
i
]
)
;
nBytes
+
=
mallocSizeOf
(
list
[
i
]
)
;
}
}
return
nBytes
;
}
