#
ifndef
gc_PublicIterators_h
#
define
gc_PublicIterators_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
gc
/
Zone
.
h
"
namespace
js
{
class
ZoneGroupsIter
{
gc
:
:
AutoEnterIteration
iterMarker
;
ZoneGroup
*
*
it
;
ZoneGroup
*
*
end
;
public
:
explicit
ZoneGroupsIter
(
JSRuntime
*
rt
)
:
iterMarker
(
&
rt
-
>
gc
)
{
it
=
rt
-
>
gc
.
groups
(
)
.
begin
(
)
;
end
=
rt
-
>
gc
.
groups
(
)
.
end
(
)
;
if
(
!
done
(
)
&
&
(
*
it
)
-
>
usedByHelperThread
(
)
)
next
(
)
;
}
bool
done
(
)
const
{
return
it
=
=
end
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
do
{
it
+
+
;
}
while
(
!
done
(
)
&
&
(
*
it
)
-
>
usedByHelperThread
(
)
)
;
}
ZoneGroup
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
*
it
;
}
operator
ZoneGroup
*
(
)
const
{
return
get
(
)
;
}
ZoneGroup
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
enum
ZoneSelector
{
WithAtoms
SkipAtoms
}
;
class
ZonesInGroupIter
{
gc
:
:
AutoEnterIteration
iterMarker
;
JS
:
:
Zone
*
*
it
;
JS
:
:
Zone
*
*
end
;
public
:
explicit
ZonesInGroupIter
(
ZoneGroup
*
group
)
:
iterMarker
(
&
group
-
>
runtime
-
>
gc
)
{
it
=
group
-
>
zones
(
)
.
begin
(
)
;
end
=
group
-
>
zones
(
)
.
end
(
)
;
}
bool
done
(
)
const
{
return
it
=
=
end
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
it
+
+
;
}
JS
:
:
Zone
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
*
it
;
}
operator
JS
:
:
Zone
*
(
)
const
{
return
get
(
)
;
}
JS
:
:
Zone
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
class
ZonesIter
{
ZoneGroupsIter
group
;
mozilla
:
:
Maybe
<
ZonesInGroupIter
>
zone
;
JS
:
:
Zone
*
atomsZone
;
public
:
ZonesIter
(
JSRuntime
*
rt
ZoneSelector
selector
)
:
group
(
rt
)
atomsZone
(
selector
=
=
WithAtoms
?
rt
-
>
gc
.
atomsZone
.
ref
(
)
:
nullptr
)
{
if
(
!
atomsZone
&
&
!
done
(
)
)
next
(
)
;
}
bool
done
(
)
const
{
return
!
atomsZone
&
&
group
.
done
(
)
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
atomsZone
)
atomsZone
=
nullptr
;
while
(
!
group
.
done
(
)
)
{
if
(
zone
.
isSome
(
)
)
zone
.
ref
(
)
.
next
(
)
;
else
zone
.
emplace
(
group
)
;
if
(
zone
.
ref
(
)
.
done
(
)
)
{
zone
.
reset
(
)
;
group
.
next
(
)
;
}
else
{
break
;
}
}
}
JS
:
:
Zone
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
atomsZone
?
atomsZone
:
zone
.
ref
(
)
.
get
(
)
;
}
operator
JS
:
:
Zone
*
(
)
const
{
return
get
(
)
;
}
JS
:
:
Zone
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
struct
CompartmentsInZoneIter
{
explicit
CompartmentsInZoneIter
(
JS
:
:
Zone
*
zone
)
:
zone
(
zone
)
{
it
=
zone
-
>
compartments
(
)
.
begin
(
)
;
}
bool
done
(
)
const
{
MOZ_ASSERT
(
it
)
;
return
it
<
zone
-
>
compartments
(
)
.
begin
(
)
|
|
it
>
=
zone
-
>
compartments
(
)
.
end
(
)
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
it
+
+
;
}
JSCompartment
*
get
(
)
const
{
MOZ_ASSERT
(
it
)
;
return
*
it
;
}
operator
JSCompartment
*
(
)
const
{
return
get
(
)
;
}
JSCompartment
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
private
:
JS
:
:
Zone
*
zone
;
JSCompartment
*
*
it
;
CompartmentsInZoneIter
(
)
:
zone
(
nullptr
)
it
(
nullptr
)
{
}
friend
class
mozilla
:
:
Maybe
<
CompartmentsInZoneIter
>
;
}
;
template
<
class
ZonesIterT
>
class
CompartmentsIterT
{
gc
:
:
AutoEnterIteration
iterMarker
;
ZonesIterT
zone
;
mozilla
:
:
Maybe
<
CompartmentsInZoneIter
>
comp
;
public
:
explicit
CompartmentsIterT
(
JSRuntime
*
rt
)
:
iterMarker
(
&
rt
-
>
gc
)
zone
(
rt
)
{
if
(
zone
.
done
(
)
)
comp
.
emplace
(
)
;
else
comp
.
emplace
(
zone
)
;
}
CompartmentsIterT
(
JSRuntime
*
rt
ZoneSelector
selector
)
:
iterMarker
(
&
rt
-
>
gc
)
zone
(
rt
selector
)
{
if
(
zone
.
done
(
)
)
comp
.
emplace
(
)
;
else
comp
.
emplace
(
zone
)
;
}
bool
done
(
)
const
{
return
zone
.
done
(
)
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
MOZ_ASSERT
(
!
comp
.
ref
(
)
.
done
(
)
)
;
comp
-
>
next
(
)
;
if
(
comp
-
>
done
(
)
)
{
comp
.
reset
(
)
;
zone
.
next
(
)
;
if
(
!
zone
.
done
(
)
)
comp
.
emplace
(
zone
)
;
}
}
JSCompartment
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
*
comp
;
}
operator
JSCompartment
*
(
)
const
{
return
get
(
)
;
}
JSCompartment
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
typedef
CompartmentsIterT
<
ZonesIter
>
CompartmentsIter
;
}
#
endif
