#
ifndef
gc_AtomMarking_h
#
define
gc_AtomMarking_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
NamespaceImports
.
h
"
#
include
"
js
/
Vector
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
namespace
js
{
class
AutoLockGC
;
class
DenseBitmap
;
namespace
gc
{
class
Arena
;
class
GCRuntime
;
class
AtomMarkingRuntime
{
js
:
:
MainThreadData
<
Vector
<
size_t
0
SystemAllocPolicy
>
>
freeArenaIndexes
;
js
:
:
GCLockData
<
Vector
<
size_t
0
SystemAllocPolicy
>
>
pendingFreeArenaIndexes
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
hasPendingFreeArenaIndexes
;
inline
void
markChildren
(
JSContext
*
cx
JSAtom
*
)
;
inline
void
markChildren
(
JSContext
*
cx
JS
:
:
Symbol
*
symbol
)
;
public
:
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
SequentiallyConsistent
>
allocatedWords
;
AtomMarkingRuntime
(
)
:
allocatedWords
(
0
)
{
}
size_t
allocateIndex
(
GCRuntime
*
gc
)
;
void
freeIndex
(
size_t
index
const
AutoLockGC
&
lock
)
;
void
mergePendingFreeArenaIndexes
(
GCRuntime
*
gc
)
;
void
refineZoneBitmapsForCollectedZones
(
GCRuntime
*
gc
)
;
void
markAtomsUsedByUncollectedZones
(
GCRuntime
*
gc
)
;
private
:
bool
computeBitmapFromChunkMarkBits
(
GCRuntime
*
gc
DenseBitmap
&
bitmap
)
;
void
refineZoneBitmapForCollectedZone
(
Zone
*
zone
const
DenseBitmap
&
bitmap
)
;
public
:
template
<
typename
T
>
void
markAtom
(
JSContext
*
cx
T
*
thing
)
;
template
<
typename
T
bool
Fallible
>
MOZ_ALWAYS_INLINE
bool
inlinedMarkAtomInternal
(
JSContext
*
cx
T
*
thing
)
;
template
<
typename
T
>
MOZ_ALWAYS_INLINE
void
inlinedMarkAtom
(
JSContext
*
cx
T
*
thing
)
;
template
<
typename
T
>
MOZ_ALWAYS_INLINE
bool
inlinedMarkAtomFallible
(
JSContext
*
cx
T
*
thing
)
;
void
markId
(
JSContext
*
cx
jsid
id
)
;
void
markAtomValue
(
JSContext
*
cx
const
Value
&
value
)
;
#
ifdef
DEBUG
template
<
typename
T
>
bool
atomIsMarked
(
Zone
*
zone
T
*
thing
)
;
bool
idIsMarked
(
Zone
*
zone
jsid
id
)
;
bool
valueIsMarked
(
Zone
*
zone
const
Value
&
value
)
;
#
endif
}
;
}
}
#
endif
