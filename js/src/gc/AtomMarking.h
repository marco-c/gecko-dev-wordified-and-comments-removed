#
ifndef
gc_AtomMarking_h
#
define
gc_AtomMarking_h
#
include
"
NamespaceImports
.
h
"
#
include
"
ds
/
Bitmap
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
#
include
"
vm
/
SymbolType
.
h
"
namespace
js
{
namespace
gc
{
class
Arena
;
class
AtomMarkingRuntime
{
js
:
:
GCLockData
<
Vector
<
size_t
0
SystemAllocPolicy
>
>
freeArenaIndexes
;
void
markChildren
(
JSContext
*
cx
JSAtom
*
)
{
}
void
markChildren
(
JSContext
*
cx
JS
:
:
Symbol
*
symbol
)
{
if
(
JSAtom
*
description
=
symbol
-
>
description
(
)
)
markAtom
(
cx
description
)
;
}
public
:
mozilla
:
:
Atomic
<
size_t
mozilla
:
:
SequentiallyConsistent
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
allocatedWords
;
AtomMarkingRuntime
(
)
:
allocatedWords
(
0
)
{
}
void
registerArena
(
Arena
*
arena
const
AutoLockGC
&
lock
)
;
void
unregisterArena
(
Arena
*
arena
const
AutoLockGC
&
lock
)
;
bool
computeBitmapFromChunkMarkBits
(
JSRuntime
*
runtime
DenseBitmap
&
bitmap
)
;
void
refineZoneBitmapForCollectedZone
(
Zone
*
zone
const
DenseBitmap
&
bitmap
)
;
void
markAtomsUsedByUncollectedZones
(
JSRuntime
*
runtime
)
;
template
<
typename
T
>
void
markAtom
(
JSContext
*
cx
T
*
thing
)
;
template
<
typename
T
>
MOZ_ALWAYS_INLINE
void
inlinedMarkAtom
(
JSContext
*
cx
T
*
thing
)
;
void
markId
(
JSContext
*
cx
jsid
id
)
;
void
markAtomValue
(
JSContext
*
cx
const
Value
&
value
)
;
void
adoptMarkedAtoms
(
Zone
*
target
Zone
*
source
)
;
#
ifdef
DEBUG
template
<
typename
T
>
bool
atomIsMarked
(
Zone
*
zone
T
*
thing
)
;
bool
idIsMarked
(
Zone
*
zone
jsid
id
)
;
bool
valueIsMarked
(
Zone
*
zone
const
Value
&
value
)
;
#
endif
}
;
}
}
#
endif
