#
ifndef
gc_AtomMarking_h
#
define
gc_AtomMarking_h
#
include
"
NamespaceImports
.
h
"
#
include
"
ds
/
Bitmap
.
h
"
#
include
"
threading
/
ProtectedData
.
h
"
#
include
"
vm
/
SymbolType
.
h
"
namespace
js
{
namespace
gc
{
class
Arena
;
class
AtomMarkingRuntime
{
js
:
:
ExclusiveAccessLockOrGCTaskData
<
Vector
<
size_t
0
SystemAllocPolicy
>
>
freeArenaIndexes
;
void
markChildren
(
JSContext
*
cx
JSAtom
*
)
{
}
void
markChildren
(
JSContext
*
cx
JS
:
:
Symbol
*
symbol
)
{
if
(
JSAtom
*
description
=
symbol
-
>
description
(
)
)
markAtom
(
cx
description
)
;
}
public
:
mozilla
:
:
Atomic
<
size_t
>
allocatedWords
;
AtomMarkingRuntime
(
)
:
allocatedWords
(
0
)
{
}
void
registerArena
(
Arena
*
arena
)
;
void
unregisterArena
(
Arena
*
arena
)
;
bool
computeBitmapFromChunkMarkBits
(
JSRuntime
*
runtime
DenseBitmap
&
bitmap
)
;
void
updateZoneBitmap
(
Zone
*
zone
const
DenseBitmap
&
bitmap
)
;
void
updateChunkMarkBits
(
JSRuntime
*
runtime
)
;
template
<
typename
T
>
void
markAtom
(
JSContext
*
cx
T
*
thing
)
;
template
<
typename
T
>
MOZ_ALWAYS_INLINE
void
inlinedMarkAtom
(
JSContext
*
cx
T
*
thing
)
;
void
markId
(
JSContext
*
cx
jsid
id
)
;
void
markAtomValue
(
JSContext
*
cx
const
Value
&
value
)
;
void
adoptMarkedAtoms
(
Zone
*
target
Zone
*
source
)
;
#
ifdef
DEBUG
template
<
typename
T
>
bool
atomIsMarked
(
Zone
*
zone
T
*
thing
)
;
bool
idIsMarked
(
Zone
*
zone
jsid
id
)
;
bool
valueIsMarked
(
Zone
*
zone
const
Value
&
value
)
;
#
endif
}
;
}
}
#
endif
