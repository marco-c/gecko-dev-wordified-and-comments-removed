#
include
"
gc
/
BufferAllocator
-
inl
.
h
"
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
util
/
Poison
.
h
"
#
include
"
gc
/
Heap
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
static
constexpr
size_t
MinAllocSize
=
MinCellSize
;
static
constexpr
size_t
MinMediumAllocSize
=
1
<
<
BufferAllocator
:
:
MinMediumAllocShift
;
namespace
js
:
:
gc
{
bool
SmallBuffer
:
:
isNurseryOwned
(
)
const
{
return
header_
.
get
(
)
&
NURSERY_OWNED_BIT
;
}
void
SmallBuffer
:
:
setNurseryOwned
(
bool
value
)
{
header_
.
set
(
value
?
NURSERY_OWNED_BIT
:
0
)
;
}
}
BufferAllocator
:
:
BufferAllocator
(
Zone
*
zone
)
:
zone
(
zone
)
{
}
bool
BufferAllocator
:
:
IsSmallAllocSize
(
size_t
bytes
)
{
return
mozilla
:
:
RoundUpPow2
(
bytes
+
sizeof
(
SmallBuffer
)
)
<
MinMediumAllocSize
;
}
size_t
BufferAllocator
:
:
GetGoodAllocSize
(
size_t
requiredBytes
)
{
requiredBytes
=
std
:
:
max
(
requiredBytes
MinAllocSize
)
;
MOZ_ASSERT
(
requiredBytes
<
MinMediumAllocSize
)
;
size_t
headerSize
=
sizeof
(
SmallBuffer
)
;
return
mozilla
:
:
RoundUpPow2
(
requiredBytes
+
headerSize
)
-
headerSize
;
}
size_t
BufferAllocator
:
:
GetGoodPower2AllocSize
(
size_t
requiredBytes
)
{
requiredBytes
=
std
:
:
max
(
requiredBytes
MinAllocSize
)
;
MOZ_ASSERT
(
requiredBytes
<
MinMediumAllocSize
)
;
size_t
headerSize
=
sizeof
(
SmallBuffer
)
;
return
mozilla
:
:
RoundUpPow2
(
requiredBytes
+
headerSize
)
-
headerSize
;
}
size_t
BufferAllocator
:
:
GetGoodElementCount
(
size_t
requiredElements
size_t
elementSize
)
{
size_t
requiredBytes
=
requiredElements
*
elementSize
;
size_t
goodSize
=
GetGoodAllocSize
(
requiredBytes
)
;
return
goodSize
/
elementSize
;
}
size_t
BufferAllocator
:
:
GetGoodPower2ElementCount
(
size_t
requiredElements
size_t
elementSize
)
{
size_t
requiredBytes
=
requiredElements
*
elementSize
;
size_t
goodSize
=
GetGoodPower2AllocSize
(
requiredBytes
)
;
return
goodSize
/
elementSize
;
}
void
*
BufferAllocator
:
:
alloc
(
size_t
bytes
bool
nurseryOwned
)
{
if
(
IsSmallAllocSize
(
bytes
)
)
{
return
allocSmall
(
bytes
nurseryOwned
)
;
}
MOZ_CRASH
(
"
Not
yet
implemented
"
)
;
}
void
*
BufferAllocator
:
:
allocInGC
(
size_t
bytes
bool
nurseryOwned
)
{
if
(
IsSmallAllocSize
(
bytes
)
)
{
return
allocSmallInGC
(
bytes
nurseryOwned
)
;
}
MOZ_CRASH
(
"
Not
yet
implemented
"
)
;
}
void
*
BufferAllocator
:
:
realloc
(
void
*
ptr
size_t
bytes
bool
nurseryOwned
)
{
if
(
!
ptr
)
{
return
alloc
(
bytes
nurseryOwned
)
;
}
MOZ_ASSERT
(
GetAllocZone
(
ptr
)
=
=
zone
)
;
MOZ_ASSERT
(
IsNurseryOwned
(
ptr
)
=
=
nurseryOwned
)
;
size_t
currentBytes
=
GetAllocSize
(
ptr
)
;
bytes
=
GetGoodAllocSize
(
bytes
)
;
if
(
bytes
=
=
currentBytes
)
{
return
ptr
;
}
void
*
newPtr
=
alloc
(
bytes
nurseryOwned
)
;
if
(
!
newPtr
)
{
return
nullptr
;
}
size_t
bytesToCopy
=
std
:
:
min
(
bytes
currentBytes
)
;
memcpy
(
newPtr
ptr
bytesToCopy
)
;
free
(
ptr
)
;
return
newPtr
;
}
template
<
typename
HeaderT
>
static
HeaderT
*
GetHeaderFromAlloc
(
void
*
alloc
)
{
return
reinterpret_cast
<
HeaderT
*
>
(
uintptr_t
(
alloc
)
-
sizeof
(
HeaderT
)
)
;
}
void
BufferAllocator
:
:
free
(
void
*
ptr
)
{
MOZ_ASSERT
(
ptr
)
;
MOZ_ASSERT
(
GetAllocZone
(
ptr
)
=
=
zone
)
;
DebugOnlyPoison
(
ptr
JS_FREED_BUFFER_PATTERN
GetAllocSize
(
ptr
)
MemCheckKind
:
:
MakeUndefined
)
;
}
bool
BufferAllocator
:
:
IsBufferAlloc
(
void
*
alloc
)
{
ChunkKind
chunkKind
=
detail
:
:
GetGCAddressChunkBase
(
alloc
)
-
>
getKind
(
)
;
if
(
chunkKind
=
=
ChunkKind
:
:
TenuredArenas
)
{
auto
*
arena
=
reinterpret_cast
<
Arena
*
>
(
uintptr_t
(
alloc
)
&
~
ArenaMask
)
;
return
IsBufferAllocKind
(
arena
-
>
getAllocKind
(
)
)
;
}
return
false
;
}
size_t
BufferAllocator
:
:
GetAllocSize
(
void
*
alloc
)
{
if
(
IsSmallAlloc
(
alloc
)
)
{
auto
*
cell
=
GetHeaderFromAlloc
<
SmallBuffer
>
(
alloc
)
;
return
cell
-
>
arena
(
)
-
>
getThingSize
(
)
-
sizeof
(
SmallBuffer
)
;
}
MOZ_CRASH
(
"
Not
yet
implemented
"
)
;
}
JS
:
:
Zone
*
BufferAllocator
:
:
GetAllocZone
(
void
*
alloc
)
{
if
(
IsSmallAlloc
(
alloc
)
)
{
auto
*
cell
=
GetHeaderFromAlloc
<
SmallBuffer
>
(
alloc
)
;
return
cell
-
>
zone
(
)
;
}
MOZ_CRASH
(
"
Not
yet
implemented
"
)
;
}
bool
BufferAllocator
:
:
IsNurseryOwned
(
void
*
alloc
)
{
if
(
IsSmallAlloc
(
alloc
)
)
{
auto
*
cell
=
GetHeaderFromAlloc
<
SmallBuffer
>
(
alloc
)
;
return
cell
-
>
isNurseryOwned
(
)
;
}
MOZ_CRASH
(
"
Not
yet
implemented
"
)
;
}
void
BufferAllocator
:
:
markNurseryOwned
(
void
*
alloc
bool
ownerWasTenured
)
{
MOZ_ASSERT
(
alloc
)
;
MOZ_ASSERT
(
IsNurseryOwned
(
alloc
)
)
;
MOZ_ASSERT
(
GetAllocZone
(
alloc
)
=
=
zone
)
;
if
(
IsSmallAlloc
(
alloc
)
)
{
auto
*
cell
=
GetHeaderFromAlloc
<
SmallBuffer
>
(
alloc
)
;
if
(
ownerWasTenured
)
{
cell
-
>
setNurseryOwned
(
false
)
;
}
return
;
}
MOZ_CRASH
(
"
Not
yet
implemented
"
)
;
}
bool
BufferAllocator
:
:
IsMarkedBlack
(
void
*
alloc
)
{
if
(
IsSmallAlloc
(
alloc
)
)
{
auto
*
cell
=
GetHeaderFromAlloc
<
SmallBuffer
>
(
alloc
)
;
MOZ_ASSERT
(
!
cell
-
>
isMarkedGray
(
)
)
;
return
cell
-
>
isMarkedBlack
(
)
;
}
MOZ_CRASH
(
"
Not
yet
implemented
"
)
;
}
void
BufferAllocator
:
:
TraceEdge
(
JSTracer
*
trc
Cell
*
owner
void
*
buffer
const
char
*
name
)
{
MOZ_ASSERT
(
owner
)
;
MOZ_ASSERT
(
buffer
)
;
if
(
js
:
:
gc
:
:
detail
:
:
GetGCAddressChunkBase
(
buffer
)
-
>
isNurseryChunk
(
)
)
{
return
;
}
MOZ_ASSERT
(
IsBufferAlloc
(
buffer
)
)
;
if
(
IsSmallAlloc
(
buffer
)
)
{
auto
*
cell
=
GetHeaderFromAlloc
<
SmallBuffer
>
(
buffer
)
;
TraceManuallyBarrieredEdge
(
trc
&
cell
name
)
;
MOZ_ASSERT
(
cell
-
>
data
(
)
=
=
buffer
)
;
return
;
}
MOZ_CRASH
(
"
Not
yet
implemented
"
)
;
}
bool
BufferAllocator
:
:
MarkTenuredAlloc
(
void
*
alloc
)
{
MOZ_ASSERT
(
alloc
)
;
MOZ_ASSERT
(
!
IsNurseryOwned
(
alloc
)
)
;
if
(
IsSmallAlloc
(
alloc
)
)
{
auto
*
cell
=
GetHeaderFromAlloc
<
SmallBuffer
>
(
alloc
)
;
return
cell
-
>
markIfUnmarkedAtomic
(
MarkColor
:
:
Black
)
;
}
MOZ_CRASH
(
"
Not
yet
implemented
"
)
;
}
void
*
BufferAllocator
:
:
allocSmall
(
size_t
bytes
bool
nurseryOwned
)
{
AllocKind
kind
=
AllocKindForSmallAlloc
(
bytes
)
;
void
*
ptr
=
CellAllocator
:
:
AllocTenuredCellUnchecked
<
NoGC
>
(
zone
kind
)
;
if
(
!
ptr
)
{
return
nullptr
;
}
auto
*
cell
=
new
(
ptr
)
SmallBuffer
(
)
;
cell
-
>
setNurseryOwned
(
nurseryOwned
)
;
MOZ_ASSERT
(
cell
-
>
isNurseryOwned
(
)
=
=
nurseryOwned
)
;
void
*
alloc
=
cell
-
>
data
(
)
;
MOZ_ASSERT
(
IsSmallAlloc
(
alloc
)
)
;
MOZ_ASSERT
(
GetAllocSize
(
alloc
)
>
=
bytes
)
;
MOZ_ASSERT
(
GetAllocSize
(
alloc
)
<
2
*
(
bytes
+
sizeof
(
SmallBuffer
)
)
)
;
return
alloc
;
}
void
*
BufferAllocator
:
:
allocSmallInGC
(
size_t
bytes
bool
nurseryOwned
)
{
AllocKind
kind
=
AllocKindForSmallAlloc
(
bytes
)
;
void
*
ptr
=
AllocateTenuredCellInGC
(
zone
kind
)
;
if
(
!
ptr
)
{
return
nullptr
;
}
auto
*
cell
=
new
(
ptr
)
SmallBuffer
(
)
;
cell
-
>
setNurseryOwned
(
nurseryOwned
)
;
void
*
alloc
=
cell
-
>
data
(
)
;
MOZ_ASSERT
(
GetAllocSize
(
alloc
)
>
=
bytes
)
;
MOZ_ASSERT
(
GetAllocSize
(
alloc
)
<
2
*
(
bytes
+
sizeof
(
SmallBuffer
)
)
)
;
return
alloc
;
}
AllocKind
BufferAllocator
:
:
AllocKindForSmallAlloc
(
size_t
bytes
)
{
bytes
=
std
:
:
max
(
bytes
MinAllocSize
)
;
size_t
totalBytes
=
bytes
+
sizeof
(
SmallBuffer
)
;
MOZ_ASSERT
(
totalBytes
<
MinMediumAllocSize
)
;
size_t
logBytes
=
mozilla
:
:
CeilingLog2
(
totalBytes
)
;
MOZ_ASSERT
(
totalBytes
<
=
(
size_t
(
1
)
<
<
logBytes
)
)
;
MOZ_ASSERT
(
logBytes
>
=
mozilla
:
:
CeilingLog2
(
MinAllocSize
)
)
;
size_t
kindIndex
=
logBytes
-
mozilla
:
:
CeilingLog2
(
MinAllocSize
)
;
AllocKind
kind
=
AllocKind
(
size_t
(
AllocKind
:
:
BUFFER_FIRST
)
+
kindIndex
)
;
MOZ_ASSERT
(
IsValidAllocKind
(
kind
)
)
;
MOZ_ASSERT
(
kind
<
=
AllocKind
:
:
BUFFER_LAST
)
;
return
kind
;
}
bool
BufferAllocator
:
:
IsSmallAlloc
(
void
*
alloc
)
{
MOZ_ASSERT
(
IsBufferAlloc
(
alloc
)
)
;
ChunkBase
*
chunk
=
detail
:
:
GetGCAddressChunkBase
(
alloc
)
;
return
chunk
-
>
getKind
(
)
=
=
ChunkKind
:
:
TenuredArenas
;
}
JS
:
:
ubi
:
:
Node
:
:
Size
JS
:
:
ubi
:
:
Concrete
<
SmallBuffer
>
:
:
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
get
(
)
.
arena
(
)
-
>
getThingSize
(
)
;
}
const
char16_t
JS
:
:
ubi
:
:
Concrete
<
SmallBuffer
>
:
:
concreteTypeName
[
]
=
u
"
SmallBuffer
"
;
