#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
memcheck
.
h
>
#
endif
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
jscntxt
.
h
"
#
include
"
jsgc
.
h
"
#
include
"
jsprf
.
h
"
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
jscntxtinlines
.
h
"
#
include
"
jsgcinlines
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
#
ifdef
JS_GC_ZEAL
struct
EdgeValue
{
void
*
thing
;
JS
:
:
TraceKind
kind
;
const
char
*
label
;
}
;
struct
VerifyNode
{
void
*
thing
;
JS
:
:
TraceKind
kind
;
uint32_t
count
;
EdgeValue
edges
[
1
]
;
}
;
typedef
HashMap
<
void
*
VerifyNode
*
DefaultHasher
<
void
*
>
SystemAllocPolicy
>
NodeMap
;
class
js
:
:
VerifyPreTracer
final
:
public
JS
:
:
CallbackTracer
{
JS
:
:
AutoDisableGenerationalGC
noggc
;
void
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
override
;
public
:
uint64_t
number
;
int
count
;
VerifyNode
*
curnode
;
VerifyNode
*
root
;
char
*
edgeptr
;
char
*
term
;
NodeMap
nodemap
;
explicit
VerifyPreTracer
(
JSRuntime
*
rt
)
:
JS
:
:
CallbackTracer
(
rt
)
noggc
(
TlsContext
.
get
(
)
)
number
(
rt
-
>
gc
.
gcNumber
(
)
)
count
(
0
)
curnode
(
nullptr
)
root
(
nullptr
)
edgeptr
(
nullptr
)
term
(
nullptr
)
{
}
~
VerifyPreTracer
(
)
{
js_free
(
root
)
;
}
}
;
void
VerifyPreTracer
:
:
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
{
MOZ_ASSERT
(
!
IsInsideNursery
(
thing
.
asCell
(
)
)
)
;
if
(
thing
.
asCell
(
)
-
>
asTenured
(
)
.
runtimeFromAnyThread
(
)
!
=
runtime
(
)
)
return
;
edgeptr
+
=
sizeof
(
EdgeValue
)
;
if
(
edgeptr
>
=
term
)
{
edgeptr
=
term
;
return
;
}
VerifyNode
*
node
=
curnode
;
uint32_t
i
=
node
-
>
count
;
node
-
>
edges
[
i
]
.
thing
=
thing
.
asCell
(
)
;
node
-
>
edges
[
i
]
.
kind
=
thing
.
kind
(
)
;
node
-
>
edges
[
i
]
.
label
=
contextName
(
)
;
node
-
>
count
+
+
;
}
static
VerifyNode
*
MakeNode
(
VerifyPreTracer
*
trc
void
*
thing
JS
:
:
TraceKind
kind
)
{
NodeMap
:
:
AddPtr
p
=
trc
-
>
nodemap
.
lookupForAdd
(
thing
)
;
if
(
!
p
)
{
VerifyNode
*
node
=
(
VerifyNode
*
)
trc
-
>
edgeptr
;
trc
-
>
edgeptr
+
=
sizeof
(
VerifyNode
)
-
sizeof
(
EdgeValue
)
;
if
(
trc
-
>
edgeptr
>
=
trc
-
>
term
)
{
trc
-
>
edgeptr
=
trc
-
>
term
;
return
nullptr
;
}
node
-
>
thing
=
thing
;
node
-
>
count
=
0
;
node
-
>
kind
=
kind
;
if
(
!
trc
-
>
nodemap
.
add
(
p
thing
node
)
)
{
trc
-
>
edgeptr
=
trc
-
>
term
;
return
nullptr
;
}
return
node
;
}
return
nullptr
;
}
static
VerifyNode
*
NextNode
(
VerifyNode
*
node
)
{
if
(
node
-
>
count
=
=
0
)
return
(
VerifyNode
*
)
(
(
char
*
)
node
+
sizeof
(
VerifyNode
)
-
sizeof
(
EdgeValue
)
)
;
else
return
(
VerifyNode
*
)
(
(
char
*
)
node
+
sizeof
(
VerifyNode
)
+
sizeof
(
EdgeValue
)
*
(
node
-
>
count
-
1
)
)
;
}
void
gc
:
:
GCRuntime
:
:
startVerifyPreBarriers
(
)
{
if
(
verifyPreData
|
|
isIncrementalGCInProgress
(
)
)
return
;
if
(
IsIncrementalGCUnsafe
(
rt
)
!
=
AbortReason
:
:
None
|
|
TlsContext
.
get
(
)
-
>
keepAtoms
|
|
rt
-
>
hasHelperThreadZones
(
)
|
|
rt
-
>
cooperatingContexts
(
)
.
length
(
)
!
=
1
)
{
return
;
}
number
+
+
;
VerifyPreTracer
*
trc
=
js_new
<
VerifyPreTracer
>
(
rt
)
;
if
(
!
trc
)
return
;
AutoPrepareForTracing
prep
(
TlsContext
.
get
(
)
WithAtoms
)
;
for
(
auto
chunk
=
allNonEmptyChunks
(
)
;
!
chunk
.
done
(
)
;
chunk
.
next
(
)
)
chunk
-
>
bitmap
.
clear
(
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PHASE_TRACE_HEAP
)
;
const
size_t
size
=
64
*
1024
*
1024
;
trc
-
>
root
=
(
VerifyNode
*
)
js_malloc
(
size
)
;
if
(
!
trc
-
>
root
)
goto
oom
;
trc
-
>
edgeptr
=
(
char
*
)
trc
-
>
root
;
trc
-
>
term
=
trc
-
>
edgeptr
+
size
;
if
(
!
trc
-
>
nodemap
.
init
(
)
)
goto
oom
;
trc
-
>
curnode
=
MakeNode
(
trc
nullptr
JS
:
:
TraceKind
(
0
)
)
;
incrementalState
=
State
:
:
MarkRoots
;
traceRuntime
(
trc
prep
.
session
(
)
.
lock
)
;
VerifyNode
*
node
;
node
=
trc
-
>
curnode
;
if
(
trc
-
>
edgeptr
=
=
trc
-
>
term
)
goto
oom
;
while
(
(
char
*
)
node
<
trc
-
>
edgeptr
)
{
for
(
uint32_t
i
=
0
;
i
<
node
-
>
count
;
i
+
+
)
{
EdgeValue
&
e
=
node
-
>
edges
[
i
]
;
VerifyNode
*
child
=
MakeNode
(
trc
e
.
thing
e
.
kind
)
;
if
(
child
)
{
trc
-
>
curnode
=
child
;
js
:
:
TraceChildren
(
trc
e
.
thing
e
.
kind
)
;
}
if
(
trc
-
>
edgeptr
=
=
trc
-
>
term
)
goto
oom
;
}
node
=
NextNode
(
node
)
;
}
verifyPreData
=
trc
;
incrementalState
=
State
:
:
Mark
;
marker
.
start
(
)
;
for
(
ZonesIter
zone
(
rt
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
MOZ_ASSERT
(
!
zone
-
>
usedByHelperThread
(
)
)
;
PurgeJITCaches
(
zone
)
;
zone
-
>
setNeedsIncrementalBarrier
(
true
Zone
:
:
UpdateJit
)
;
zone
-
>
arenas
.
purge
(
)
;
}
return
;
oom
:
incrementalState
=
State
:
:
NotActive
;
js_delete
(
trc
)
;
verifyPreData
=
nullptr
;
}
static
bool
IsMarkedOrAllocated
(
TenuredCell
*
cell
)
{
return
cell
-
>
isMarked
(
)
|
|
cell
-
>
arena
(
)
-
>
allocatedDuringIncremental
;
}
struct
CheckEdgeTracer
:
public
JS
:
:
CallbackTracer
{
VerifyNode
*
node
;
explicit
CheckEdgeTracer
(
JSRuntime
*
rt
)
:
JS
:
:
CallbackTracer
(
rt
)
node
(
nullptr
)
{
}
void
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
override
;
}
;
static
const
uint32_t
MAX_VERIFIER_EDGES
=
1000
;
void
CheckEdgeTracer
:
:
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
{
if
(
thing
.
asCell
(
)
-
>
asTenured
(
)
.
runtimeFromAnyThread
(
)
!
=
runtime
(
)
)
return
;
if
(
node
-
>
count
>
MAX_VERIFIER_EDGES
)
return
;
for
(
uint32_t
i
=
0
;
i
<
node
-
>
count
;
i
+
+
)
{
if
(
node
-
>
edges
[
i
]
.
thing
=
=
thing
.
asCell
(
)
)
{
MOZ_ASSERT
(
node
-
>
edges
[
i
]
.
kind
=
=
thing
.
kind
(
)
)
;
node
-
>
edges
[
i
]
.
thing
=
nullptr
;
return
;
}
}
}
void
js
:
:
gc
:
:
AssertSafeToSkipBarrier
(
TenuredCell
*
thing
)
{
mozilla
:
:
DebugOnly
<
Zone
*
>
zone
=
thing
-
>
zoneFromAnyThread
(
)
;
MOZ_ASSERT
(
!
zone
-
>
needsIncrementalBarrier
(
)
|
|
zone
-
>
isAtomsZone
(
)
)
;
}
static
bool
IsMarkedOrAllocated
(
const
EdgeValue
&
edge
)
{
if
(
!
edge
.
thing
|
|
IsMarkedOrAllocated
(
TenuredCell
:
:
fromPointer
(
edge
.
thing
)
)
)
return
true
;
if
(
edge
.
kind
=
=
JS
:
:
TraceKind
:
:
String
&
&
static_cast
<
JSString
*
>
(
edge
.
thing
)
-
>
isPermanentAtom
(
)
)
return
true
;
if
(
edge
.
kind
=
=
JS
:
:
TraceKind
:
:
Symbol
&
&
static_cast
<
JS
:
:
Symbol
*
>
(
edge
.
thing
)
-
>
isWellKnownSymbol
(
)
)
return
true
;
return
false
;
}
void
gc
:
:
GCRuntime
:
:
endVerifyPreBarriers
(
)
{
VerifyPreTracer
*
trc
=
verifyPreData
;
if
(
!
trc
)
return
;
MOZ_ASSERT
(
!
JS
:
:
IsGenerationalGCEnabled
(
rt
)
)
;
AutoPrepareForTracing
prep
(
rt
-
>
activeContextFromOwnThread
(
)
SkipAtoms
)
;
bool
compartmentCreated
=
false
;
for
(
ZonesIter
zone
(
rt
WithAtoms
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
!
zone
-
>
needsIncrementalBarrier
(
)
)
compartmentCreated
=
true
;
zone
-
>
setNeedsIncrementalBarrier
(
false
Zone
:
:
UpdateJit
)
;
PurgeJITCaches
(
zone
)
;
}
MOZ_ASSERT
(
trc
-
>
number
=
=
number
)
;
number
+
+
;
verifyPreData
=
nullptr
;
incrementalState
=
State
:
:
NotActive
;
if
(
!
compartmentCreated
&
&
IsIncrementalGCUnsafe
(
rt
)
=
=
AbortReason
:
:
None
&
&
!
TlsContext
.
get
(
)
-
>
keepAtoms
&
&
!
rt
-
>
hasHelperThreadZones
(
)
)
{
CheckEdgeTracer
cetrc
(
rt
)
;
VerifyNode
*
node
=
NextNode
(
trc
-
>
root
)
;
while
(
(
char
*
)
node
<
trc
-
>
edgeptr
)
{
cetrc
.
node
=
node
;
js
:
:
TraceChildren
(
&
cetrc
node
-
>
thing
node
-
>
kind
)
;
if
(
node
-
>
count
<
=
MAX_VERIFIER_EDGES
)
{
for
(
uint32_t
i
=
0
;
i
<
node
-
>
count
;
i
+
+
)
{
EdgeValue
&
edge
=
node
-
>
edges
[
i
]
;
if
(
!
IsMarkedOrAllocated
(
edge
)
)
{
char
msgbuf
[
1024
]
;
SprintfLiteral
(
msgbuf
"
[
barrier
verifier
]
Unmarked
edge
:
%
s
%
p
'
%
s
'
edge
to
%
s
%
p
"
JS
:
:
GCTraceKindToAscii
(
node
-
>
kind
)
node
-
>
thing
edge
.
label
JS
:
:
GCTraceKindToAscii
(
edge
.
kind
)
edge
.
thing
)
;
MOZ_ReportAssertionFailure
(
msgbuf
__FILE__
__LINE__
)
;
MOZ_CRASH
(
)
;
}
}
}
node
=
NextNode
(
node
)
;
}
}
marker
.
reset
(
)
;
marker
.
stop
(
)
;
js_delete
(
trc
)
;
}
void
gc
:
:
GCRuntime
:
:
verifyPreBarriers
(
)
{
if
(
verifyPreData
)
endVerifyPreBarriers
(
)
;
else
startVerifyPreBarriers
(
)
;
}
void
gc
:
:
VerifyBarriers
(
JSRuntime
*
rt
VerifierType
type
)
{
if
(
type
=
=
PreBarrierVerifier
)
rt
-
>
gc
.
verifyPreBarriers
(
)
;
}
void
gc
:
:
GCRuntime
:
:
maybeVerifyPreBarriers
(
bool
always
)
{
if
(
!
hasZealMode
(
ZealMode
:
:
VerifierPre
)
)
return
;
if
(
TlsContext
.
get
(
)
-
>
suppressGC
)
return
;
if
(
verifyPreData
)
{
if
(
+
+
verifyPreData
-
>
count
<
zealFrequency
&
&
!
always
)
return
;
endVerifyPreBarriers
(
)
;
}
startVerifyPreBarriers
(
)
;
}
void
js
:
:
gc
:
:
MaybeVerifyBarriers
(
JSContext
*
cx
bool
always
)
{
GCRuntime
*
gc
=
&
cx
-
>
runtime
(
)
-
>
gc
;
gc
-
>
maybeVerifyPreBarriers
(
always
)
;
}
void
js
:
:
gc
:
:
GCRuntime
:
:
finishVerifier
(
)
{
if
(
verifyPreData
)
{
js_delete
(
verifyPreData
.
ref
(
)
)
;
verifyPreData
=
nullptr
;
}
}
#
endif
#
if
defined
(
JSGC_HASH_TABLE_CHECKS
)
|
|
defined
(
DEBUG
)
class
HeapCheckTracerBase
:
public
JS
:
:
CallbackTracer
{
public
:
explicit
HeapCheckTracerBase
(
JSRuntime
*
rt
WeakMapTraceKind
weakTraceKind
)
;
bool
init
(
)
;
bool
traceHeap
(
AutoLockForExclusiveAccess
&
lock
)
;
virtual
void
checkCell
(
Cell
*
cell
)
=
0
;
protected
:
void
dumpCellPath
(
)
;
Cell
*
parentCell
(
)
{
return
parentIndex
=
=
-
1
?
nullptr
:
stack
[
parentIndex
]
.
thing
.
asCell
(
)
;
}
size_t
failures
;
private
:
void
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
override
;
struct
WorkItem
{
WorkItem
(
JS
:
:
GCCellPtr
thing
const
char
*
name
int
parentIndex
)
:
thing
(
thing
)
name
(
name
)
parentIndex
(
parentIndex
)
processed
(
false
)
{
}
JS
:
:
GCCellPtr
thing
;
const
char
*
name
;
int
parentIndex
;
bool
processed
;
}
;
JSRuntime
*
rt
;
bool
oom
;
HashSet
<
Cell
*
DefaultHasher
<
Cell
*
>
SystemAllocPolicy
>
visited
;
Vector
<
WorkItem
0
SystemAllocPolicy
>
stack
;
int
parentIndex
;
}
;
HeapCheckTracerBase
:
:
HeapCheckTracerBase
(
JSRuntime
*
rt
WeakMapTraceKind
weakTraceKind
)
:
CallbackTracer
(
rt
weakTraceKind
)
failures
(
0
)
rt
(
rt
)
oom
(
false
)
parentIndex
(
-
1
)
{
#
ifdef
DEBUG
setCheckEdges
(
false
)
;
#
endif
}
bool
HeapCheckTracerBase
:
:
init
(
)
{
return
visited
.
init
(
)
;
}
void
HeapCheckTracerBase
:
:
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
{
Cell
*
cell
=
thing
.
asCell
(
)
;
checkCell
(
cell
)
;
if
(
visited
.
lookup
(
cell
)
)
return
;
if
(
!
visited
.
put
(
cell
)
)
{
oom
=
true
;
return
;
}
if
(
cell
-
>
runtimeFromAnyThread
(
)
!
=
rt
)
return
;
Zone
*
zone
=
thing
.
is
<
JSObject
>
(
)
?
thing
.
as
<
JSObject
>
(
)
.
zone
(
)
:
cell
-
>
asTenured
(
)
.
zone
(
)
;
if
(
zone
-
>
group
(
)
&
&
zone
-
>
group
(
)
-
>
usedByHelperThread
)
return
;
WorkItem
item
(
thing
contextName
(
)
parentIndex
)
;
if
(
!
stack
.
append
(
item
)
)
oom
=
true
;
}
bool
HeapCheckTracerBase
:
:
traceHeap
(
AutoLockForExclusiveAccess
&
lock
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
if
(
!
rt
-
>
isBeingDestroyed
(
)
)
rt
-
>
gc
.
traceRuntime
(
this
lock
)
;
while
(
!
stack
.
empty
(
)
&
&
!
oom
)
{
WorkItem
item
=
stack
.
back
(
)
;
if
(
item
.
processed
)
{
stack
.
popBack
(
)
;
}
else
{
parentIndex
=
stack
.
length
(
)
-
1
;
stack
.
back
(
)
.
processed
=
true
;
TraceChildren
(
this
item
.
thing
)
;
}
}
return
!
oom
;
}
void
HeapCheckTracerBase
:
:
dumpCellPath
(
)
{
const
char
*
name
=
contextName
(
)
;
for
(
int
index
=
parentIndex
;
index
!
=
-
1
;
index
=
stack
[
index
]
.
parentIndex
)
{
const
WorkItem
&
parent
=
stack
[
index
]
;
Cell
*
cell
=
parent
.
thing
.
asCell
(
)
;
fprintf
(
stderr
"
from
%
s
%
p
%
s
edge
\
n
"
GCTraceKindToAscii
(
cell
-
>
getTraceKind
(
)
)
cell
name
)
;
name
=
parent
.
name
;
}
fprintf
(
stderr
"
from
root
%
s
\
n
"
name
)
;
}
#
endif
#
ifdef
JSGC_HASH_TABLE_CHECKS
class
CheckHeapTracer
final
:
public
HeapCheckTracerBase
{
public
:
explicit
CheckHeapTracer
(
JSRuntime
*
rt
)
;
void
check
(
AutoLockForExclusiveAccess
&
lock
)
;
private
:
void
checkCell
(
Cell
*
cell
)
override
;
}
;
CheckHeapTracer
:
:
CheckHeapTracer
(
JSRuntime
*
rt
)
:
HeapCheckTracerBase
(
rt
TraceWeakMapKeysValues
)
{
}
inline
static
bool
IsValidGCThingPointer
(
Cell
*
cell
)
{
return
(
uintptr_t
(
cell
)
&
CellMask
)
=
=
0
;
}
void
CheckHeapTracer
:
:
checkCell
(
Cell
*
cell
)
{
if
(
!
IsValidGCThingPointer
(
cell
)
|
|
!
IsGCThingValidAfterMovingGC
(
cell
)
)
{
failures
+
+
;
fprintf
(
stderr
"
Bad
pointer
%
p
\
n
"
cell
)
;
dumpCellPath
(
)
;
}
}
void
CheckHeapTracer
:
:
check
(
AutoLockForExclusiveAccess
&
lock
)
{
if
(
!
traceHeap
(
lock
)
)
return
;
if
(
failures
)
fprintf
(
stderr
"
Heap
check
:
%
"
PRIuSIZE
"
failure
(
s
)
\
n
"
failures
)
;
MOZ_RELEASE_ASSERT
(
failures
=
=
0
)
;
}
void
js
:
:
gc
:
:
CheckHeapAfterGC
(
JSRuntime
*
rt
)
{
AutoTraceSession
session
(
rt
JS
:
:
HeapState
:
:
Tracing
)
;
CheckHeapTracer
tracer
(
rt
)
;
if
(
tracer
.
init
(
)
)
tracer
.
check
(
session
.
lock
)
;
}
#
endif
#
ifdef
DEBUG
class
CheckGrayMarkingTracer
final
:
public
HeapCheckTracerBase
{
public
:
explicit
CheckGrayMarkingTracer
(
JSRuntime
*
rt
)
;
bool
check
(
AutoLockForExclusiveAccess
&
lock
)
;
private
:
void
checkCell
(
Cell
*
cell
)
override
;
}
;
CheckGrayMarkingTracer
:
:
CheckGrayMarkingTracer
(
JSRuntime
*
rt
)
:
HeapCheckTracerBase
(
rt
DoNotTraceWeakMaps
)
{
setTraceWeakEdges
(
false
)
;
}
void
CheckGrayMarkingTracer
:
:
checkCell
(
Cell
*
cell
)
{
Cell
*
parent
=
parentCell
(
)
;
if
(
!
cell
-
>
isTenured
(
)
|
|
!
parent
|
|
!
parent
-
>
isTenured
(
)
)
return
;
TenuredCell
*
tenuredCell
=
&
cell
-
>
asTenured
(
)
;
TenuredCell
*
tenuredParent
=
&
parent
-
>
asTenured
(
)
;
if
(
tenuredParent
-
>
isMarked
(
BLACK
)
&
&
!
tenuredParent
-
>
isMarked
(
GRAY
)
&
&
tenuredCell
-
>
isMarked
(
GRAY
)
)
{
failures
+
+
;
fprintf
(
stderr
"
Found
black
to
gray
edge
%
p
\
n
"
cell
)
;
dumpCellPath
(
)
;
}
}
bool
CheckGrayMarkingTracer
:
:
check
(
AutoLockForExclusiveAccess
&
lock
)
{
if
(
!
traceHeap
(
lock
)
)
return
true
;
return
failures
=
=
0
;
}
JS_FRIEND_API
(
bool
)
js
:
:
CheckGrayMarkingState
(
JSContext
*
cx
)
{
JSRuntime
*
rt
=
cx
-
>
runtime
(
)
;
MOZ_ASSERT
(
!
JS
:
:
CurrentThreadIsHeapCollecting
(
)
)
;
MOZ_ASSERT
(
!
rt
-
>
gc
.
isIncrementalGCInProgress
(
)
)
;
if
(
!
rt
-
>
gc
.
areGrayBitsValid
(
)
)
return
true
;
gcstats
:
:
AutoPhase
ap
(
rt
-
>
gc
.
stats
(
)
gcstats
:
:
PHASE_TRACE_HEAP
)
;
AutoTraceSession
session
(
rt
JS
:
:
HeapState
:
:
Tracing
)
;
CheckGrayMarkingTracer
tracer
(
rt
)
;
if
(
!
tracer
.
init
(
)
)
return
true
;
return
tracer
.
check
(
session
.
lock
)
;
}
#
endif
