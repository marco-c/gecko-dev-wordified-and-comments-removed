#
include
"
gc
/
FinalizationObservers
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
builtin
/
FinalizationRegistryObject
.
h
"
#
include
"
builtin
/
WeakRefObject
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
gc
/
WeakMap
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
Zone
*
js
:
:
gc
:
:
GetWeakTargetZone
(
const
Value
&
value
)
{
MOZ_ASSERT
(
CanBeHeldWeakly
(
value
)
)
;
return
value
.
toGCThing
(
)
-
>
zone
(
)
;
}
ObserverListPtr
ObserverListPtr
:
:
fromValue
(
Value
value
)
{
MOZ_ASSERT
(
value
.
isDouble
(
)
)
;
return
ObserverListPtr
(
value
)
;
}
ObserverListPtr
:
:
ObserverListPtr
(
ObserverListObject
*
element
)
:
ObserverListPtr
(
element
ElementKind
)
{
}
ObserverListPtr
:
:
ObserverListPtr
(
ObserverList
*
list
)
:
ObserverListPtr
(
list
ListHeadKind
)
{
}
ObserverListPtr
:
:
ObserverListPtr
(
void
*
ptr
Kind
kind
)
:
value
(
PrivateValue
(
uintptr_t
(
ptr
)
|
kind
)
)
{
MOZ_ASSERT
(
(
uintptr_t
(
ptr
)
&
KindMask
)
=
=
0
)
;
}
ObserverListPtr
:
:
ObserverListPtr
(
Value
value
)
:
value
(
value
)
{
}
template
<
typename
F
>
auto
ObserverListPtr
:
:
map
(
F
&
&
func
)
const
{
if
(
isElement
(
)
)
{
return
func
(
asElement
(
)
)
;
}
return
func
(
asList
(
)
)
;
}
bool
ObserverListPtr
:
:
isElement
(
)
const
{
return
kind
(
)
=
=
ElementKind
;
}
ObserverListPtr
:
:
Kind
ObserverListPtr
:
:
kind
(
)
const
{
uintptr_t
bits
=
uintptr_t
(
value
.
toPrivate
(
)
)
;
return
static_cast
<
Kind
>
(
bits
&
KindMask
)
;
}
void
*
ObserverListPtr
:
:
ptr
(
)
const
{
uintptr_t
bits
=
uintptr_t
(
value
.
toPrivate
(
)
)
;
return
reinterpret_cast
<
void
*
>
(
bits
&
~
KindMask
)
;
}
ObserverListObject
*
ObserverListPtr
:
:
asElement
(
)
const
{
MOZ_ASSERT
(
isElement
(
)
)
;
return
static_cast
<
ObserverListObject
*
>
(
ptr
(
)
)
;
}
ObserverList
*
ObserverListPtr
:
:
asList
(
)
const
{
MOZ_ASSERT
(
!
isElement
(
)
)
;
return
static_cast
<
ObserverList
*
>
(
ptr
(
)
)
;
}
ObserverListPtr
ObserverListPtr
:
:
getNext
(
)
const
{
return
map
(
[
]
(
auto
*
element
)
{
return
element
-
>
getNext
(
)
;
}
)
;
}
ObserverListPtr
ObserverListPtr
:
:
getPrev
(
)
const
{
return
map
(
[
]
(
auto
*
element
)
{
return
element
-
>
getPrev
(
)
;
}
)
;
}
void
ObserverListPtr
:
:
setNext
(
ObserverListPtr
next
)
{
map
(
[
next
]
(
auto
*
element
)
{
element
-
>
setNext
(
next
)
;
}
)
;
}
void
ObserverListPtr
:
:
setPrev
(
ObserverListPtr
prev
)
{
map
(
[
prev
]
(
auto
*
element
)
{
element
-
>
setPrev
(
prev
)
;
}
)
;
}
class
ObserverList
:
:
Iter
{
using
Ptr
=
ObserverListPtr
;
const
Ptr
end
;
Ptr
ptr
;
Ptr
nextPtr
;
public
:
explicit
Iter
(
ObserverList
&
list
)
:
end
(
&
list
)
ptr
(
end
.
getNext
(
)
)
nextPtr
(
ptr
.
getNext
(
)
)
{
MOZ_ASSERT
(
list
.
isEmpty
(
)
=
=
done
(
)
)
;
}
bool
done
(
)
const
{
return
ptr
=
=
end
;
}
ObserverListObject
*
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
ptr
.
asElement
(
)
;
}
void
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
ptr
=
nextPtr
;
nextPtr
=
ptr
.
getNext
(
)
;
}
operator
ObserverListObject
*
(
)
const
{
return
get
(
)
;
}
ObserverListObject
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
}
;
ObserverList
:
:
ObserverList
(
)
:
next
(
this
)
prev
(
this
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
}
ObserverList
:
:
~
ObserverList
(
)
{
MOZ_ASSERT
(
isEmpty
(
)
)
;
}
ObserverList
:
:
ObserverList
(
ObserverList
&
&
other
)
:
ObserverList
(
)
{
MOZ_ASSERT
(
&
other
!
=
this
)
;
*
this
=
std
:
:
move
(
other
)
;
}
ObserverList
&
ObserverList
:
:
operator
=
(
ObserverList
&
&
other
)
{
MOZ_ASSERT
(
&
other
!
=
this
)
;
MOZ_ASSERT
(
isEmpty
(
)
)
;
AutoTouchingGrayThings
atgt
;
if
(
other
.
isEmpty
(
)
)
{
return
*
this
;
}
next
=
other
.
next
;
prev
=
other
.
prev
;
MOZ_ASSERT
(
next
.
getPrev
(
)
.
asList
(
)
=
=
&
other
)
;
MOZ_ASSERT
(
prev
.
getNext
(
)
.
asList
(
)
=
=
&
other
)
;
next
.
setPrev
(
this
)
;
prev
.
setNext
(
this
)
;
other
.
next
=
&
other
;
other
.
prev
=
&
other
;
MOZ_ASSERT
(
other
.
isEmpty
(
)
)
;
return
*
this
;
}
bool
ObserverList
:
:
isEmpty
(
)
const
{
ObserverListPtr
thisLink
=
const_cast
<
ObserverList
*
>
(
this
)
;
MOZ_ASSERT
(
(
getNext
(
)
=
=
thisLink
)
=
=
(
getPrev
(
)
=
=
thisLink
)
)
;
return
getNext
(
)
=
=
thisLink
;
}
ObserverListObject
*
ObserverList
:
:
getFirst
(
)
const
{
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
return
next
.
asElement
(
)
;
}
ObserverList
:
:
Iter
ObserverList
:
:
iter
(
)
{
return
Iter
(
*
this
)
;
}
void
ObserverList
:
:
insertFront
(
ObserverListObject
*
obj
)
{
MOZ_ASSERT
(
!
obj
-
>
isInList
(
)
)
;
AutoTouchingGrayThings
atgt
;
Ptr
oldNext
=
getNext
(
)
;
setNext
(
obj
)
;
obj
-
>
setNext
(
oldNext
)
;
oldNext
.
setPrev
(
obj
)
;
obj
-
>
setPrev
(
this
)
;
}
void
ObserverList
:
:
setNext
(
Ptr
link
)
{
next
=
link
;
}
void
ObserverList
:
:
setPrev
(
Ptr
link
)
{
prev
=
link
;
}
const
ClassExtension
ObserverListObject
:
:
classExtension_
=
{
ObserverListObject
:
:
objectMoved
}
;
bool
ObserverListObject
:
:
isInList
(
)
const
{
bool
inList
=
!
getReservedSlot
(
NextSlot
)
.
isUndefined
(
)
;
MOZ_ASSERT
(
inList
=
=
!
getReservedSlot
(
PrevSlot
)
.
isUndefined
(
)
)
;
return
inList
;
}
size_t
ObserverListObject
:
:
objectMoved
(
JSObject
*
obj
JSObject
*
old
)
{
auto
*
self
=
static_cast
<
ObserverListObject
*
>
(
obj
)
;
self
-
>
objectMovedFrom
(
static_cast
<
ObserverListObject
*
>
(
old
)
)
;
return
0
;
}
void
ObserverListObject
:
:
objectMovedFrom
(
ObserverListObject
*
old
)
{
AutoTouchingGrayThings
atgt
;
if
(
!
isInList
(
)
)
{
return
;
}
#
ifdef
DEBUG
Ptr
oldPtr
=
old
;
MOZ_ASSERT
(
getNext
(
)
!
=
oldPtr
)
;
MOZ_ASSERT
(
getPrev
(
)
!
=
oldPtr
)
;
MOZ_ASSERT
(
getNext
(
)
.
getPrev
(
)
=
=
oldPtr
)
;
MOZ_ASSERT
(
getPrev
(
)
.
getNext
(
)
=
=
oldPtr
)
;
#
endif
getNext
(
)
.
setPrev
(
this
)
;
getPrev
(
)
.
setNext
(
this
)
;
}
void
ObserverListObject
:
:
unlink
(
)
{
AutoTouchingGrayThings
atgt
;
if
(
!
isInList
(
)
)
{
return
;
}
Ptr
next
=
getNext
(
)
;
Ptr
prev
=
getPrev
(
)
;
#
ifdef
DEBUG
Ptr
thisPtr
=
this
;
MOZ_ASSERT
(
prev
.
getNext
(
)
=
=
thisPtr
)
;
MOZ_ASSERT
(
next
.
getPrev
(
)
=
=
thisPtr
)
;
#
endif
next
.
setPrev
(
prev
)
;
prev
.
setNext
(
next
)
;
setReservedSlot
(
NextSlot
UndefinedValue
(
)
)
;
setReservedSlot
(
PrevSlot
UndefinedValue
(
)
)
;
MOZ_ASSERT
(
!
isInList
(
)
)
;
}
ObserverListPtr
ObserverListObject
:
:
getNext
(
)
const
{
Value
value
=
getReservedSlot
(
NextSlot
)
;
return
Ptr
:
:
fromValue
(
value
)
;
}
ObserverListPtr
ObserverListObject
:
:
getPrev
(
)
const
{
Value
value
=
getReservedSlot
(
PrevSlot
)
;
return
Ptr
:
:
fromValue
(
value
)
;
}
void
ObserverListObject
:
:
setNext
(
Ptr
next
)
{
setReservedSlot
(
NextSlot
next
.
asValue
(
)
)
;
}
void
ObserverListObject
:
:
setPrev
(
Ptr
prev
)
{
setReservedSlot
(
PrevSlot
prev
.
asValue
(
)
)
;
}
FinalizationObservers
:
:
FinalizationObservers
(
Zone
*
zone
)
:
registries
(
zone
)
recordMap
(
zone
)
weakRefMap
(
zone
)
{
}
FinalizationObservers
:
:
~
FinalizationObservers
(
)
{
MOZ_ASSERT
(
registries
.
empty
(
)
)
;
MOZ_ASSERT
(
recordMap
.
empty
(
)
)
;
}
bool
GCRuntime
:
:
addFinalizationRegistry
(
JSContext
*
cx
Handle
<
FinalizationRegistryObject
*
>
registry
)
{
if
(
!
cx
-
>
zone
(
)
-
>
ensureFinalizationObservers
(
)
|
|
!
cx
-
>
zone
(
)
-
>
finalizationObservers
(
)
-
>
addRegistry
(
registry
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
bool
FinalizationObservers
:
:
addRegistry
(
Handle
<
FinalizationRegistryObject
*
>
registry
)
{
return
registries
.
put
(
registry
)
;
}
bool
GCRuntime
:
:
registerWithFinalizationRegistry
(
JSContext
*
cx
HandleValue
target
Handle
<
FinalizationRecordObject
*
>
record
)
{
MOZ_ASSERT_IF
(
target
.
isObject
(
)
!
IsCrossCompartmentWrapper
(
&
target
.
toObject
(
)
)
)
;
Zone
*
zone
=
GetWeakTargetZone
(
target
)
;
if
(
!
zone
-
>
ensureFinalizationObservers
(
)
|
|
!
zone
-
>
finalizationObservers
(
)
-
>
addRecord
(
target
record
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
bool
FinalizationObservers
:
:
addRecord
(
HandleValue
target
Handle
<
FinalizationRecordObject
*
>
record
)
{
auto
ptr
=
recordMap
.
lookupForAdd
(
target
)
;
if
(
!
ptr
&
&
!
recordMap
.
add
(
ptr
target
ObserverList
(
)
)
)
{
return
false
;
}
ptr
-
>
value
(
)
.
insertFront
(
record
)
;
record
-
>
setInRecordMap
(
true
)
;
return
true
;
}
void
FinalizationObservers
:
:
clearRecords
(
)
{
for
(
RecordMap
:
:
Enum
e
(
recordMap
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
ObserverList
&
records
=
e
.
front
(
)
.
value
(
)
;
for
(
auto
iter
=
records
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
iter
-
>
unlink
(
)
;
}
}
recordMap
.
clear
(
)
;
}
void
GCRuntime
:
:
traceWeakFinalizationObserverEdges
(
JSTracer
*
trc
Zone
*
zone
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
trc
-
>
runtime
(
)
)
)
;
FinalizationObservers
*
observers
=
zone
-
>
finalizationObservers
(
)
;
if
(
observers
)
{
observers
-
>
traceWeakEdges
(
trc
)
;
}
}
void
FinalizationObservers
:
:
traceWeakEdges
(
JSTracer
*
trc
)
{
AutoTouchingGrayThings
atgt
;
traceWeakWeakRefEdges
(
trc
)
;
traceWeakFinalizationRegistryEdges
(
trc
)
;
}
void
FinalizationObservers
:
:
traceWeakFinalizationRegistryEdges
(
JSTracer
*
trc
)
{
GCRuntime
*
gc
=
&
trc
-
>
runtime
(
)
-
>
gc
;
for
(
RegistrySet
:
:
Enum
e
(
registries
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
auto
result
=
TraceWeakEdge
(
trc
&
e
.
mutableFront
(
)
"
FinalizationRegistry
"
)
;
if
(
result
.
isDead
(
)
)
{
auto
*
registry
=
result
.
initialTarget
(
)
;
registry
-
>
queue
(
)
-
>
setHasRegistry
(
false
)
;
e
.
removeFront
(
)
;
}
else
{
FinalizationRegistryObject
*
registry
=
result
.
finalTarget
(
)
;
registry
-
>
traceWeak
(
trc
)
;
FinalizationQueueObject
*
queue
=
registry
-
>
queue
(
)
;
if
(
queue
-
>
hasRecordsToCleanUp
(
)
)
{
MOZ_ASSERT
(
shouldQueueFinalizationRegistryForCleanup
(
queue
)
)
;
gc
-
>
queueFinalizationRegistryForCleanup
(
queue
)
;
}
}
}
for
(
RecordMap
:
:
Enum
e
(
recordMap
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
ObserverList
&
records
=
e
.
front
(
)
.
value
(
)
;
for
(
auto
iter
=
records
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
auto
*
record
=
&
iter
-
>
as
<
FinalizationRecordObject
>
(
)
;
MOZ_ASSERT
(
record
-
>
isInRecordMap
(
)
)
;
auto
result
=
TraceManuallyBarrieredWeakEdge
(
trc
&
record
"
FinalizationRecord
"
)
;
if
(
result
.
isDead
(
)
)
{
record
=
result
.
initialTarget
(
)
;
record
-
>
setInRecordMap
(
false
)
;
record
-
>
unlink
(
)
;
}
}
if
(
!
TraceWeakEdge
(
trc
&
e
.
front
(
)
.
mutableKey
(
)
"
FinalizationRecord
target
"
)
)
{
for
(
auto
iter
=
records
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
auto
*
record
=
&
iter
-
>
as
<
FinalizationRecordObject
>
(
)
;
record
-
>
setInRecordMap
(
false
)
;
record
-
>
unlink
(
)
;
FinalizationQueueObject
*
queue
=
record
-
>
queue
(
)
;
queue
-
>
queueRecordToBeCleanedUp
(
record
)
;
if
(
shouldQueueFinalizationRegistryForCleanup
(
queue
)
)
{
gc
-
>
queueFinalizationRegistryForCleanup
(
queue
)
;
}
}
e
.
removeFront
(
)
;
}
}
}
bool
FinalizationObservers
:
:
shouldQueueFinalizationRegistryForCleanup
(
FinalizationQueueObject
*
queue
)
{
Zone
*
zone
=
queue
-
>
zone
(
)
;
return
!
zone
-
>
wasGCStarted
(
)
|
|
zone
-
>
gcState
(
)
>
=
Zone
:
:
Sweep
;
}
void
GCRuntime
:
:
queueFinalizationRegistryForCleanup
(
FinalizationQueueObject
*
queue
)
{
MOZ_ASSERT
(
!
IsAboutToBeFinalizedUnbarriered
(
queue
)
)
;
MOZ_ASSERT
(
!
IsAboutToBeFinalizedUnbarriered
(
queue
-
>
doCleanupFunction
(
)
)
)
;
if
(
queue
-
>
isQueuedForCleanup
(
)
)
{
return
;
}
JSObject
*
unwrappedHostDefineData
=
nullptr
;
if
(
JSObject
*
wrapped
=
queue
-
>
getHostDefinedData
(
)
)
{
unwrappedHostDefineData
=
UncheckedUnwrapWithoutExpose
(
wrapped
)
;
MOZ_ASSERT
(
unwrappedHostDefineData
)
;
if
(
JS_IsDeadWrapper
(
unwrappedHostDefineData
)
)
{
return
;
}
}
callHostCleanupFinalizationRegistryCallback
(
queue
-
>
doCleanupFunction
(
)
unwrappedHostDefineData
)
;
AutoTouchingGrayThings
atgt
;
queue
-
>
setQueuedForCleanup
(
true
)
;
}
bool
GCRuntime
:
:
registerWeakRef
(
JSContext
*
cx
HandleValue
target
Handle
<
WeakRefObject
*
>
weakRef
)
{
MOZ_ASSERT_IF
(
target
.
isObject
(
)
!
IsCrossCompartmentWrapper
(
&
target
.
toObject
(
)
)
)
;
Zone
*
zone
=
GetWeakTargetZone
(
target
)
;
if
(
!
zone
-
>
ensureFinalizationObservers
(
)
|
|
!
zone
-
>
finalizationObservers
(
)
-
>
addWeakRefTarget
(
target
weakRef
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
bool
FinalizationObservers
:
:
addWeakRefTarget
(
HandleValue
target
Handle
<
WeakRefObject
*
>
weakRef
)
{
auto
ptr
=
weakRefMap
.
lookupForAdd
(
target
)
;
if
(
!
ptr
&
&
!
weakRefMap
.
relookupOrAdd
(
ptr
target
ObserverList
(
)
)
)
{
return
false
;
}
ptr
-
>
value
(
)
.
insertFront
(
weakRef
)
;
return
true
;
}
void
FinalizationObservers
:
:
removeWeakRefTarget
(
Handle
<
Value
>
target
Handle
<
WeakRefObject
*
>
weakRef
)
{
MOZ_ASSERT
(
CanBeHeldWeakly
(
target
)
)
;
MOZ_ASSERT
(
weakRef
-
>
target
(
)
=
=
target
)
;
MOZ_ASSERT
(
weakRef
-
>
isInList
(
)
)
;
weakRef
-
>
clearTargetAndUnlink
(
)
;
auto
ptr
=
weakRefMap
.
lookup
(
target
)
;
MOZ_ASSERT
(
ptr
)
;
ObserverList
&
list
=
ptr
-
>
value
(
)
;
if
(
list
.
isEmpty
(
)
)
{
weakRefMap
.
remove
(
ptr
)
;
}
}
void
FinalizationObservers
:
:
traceWeakWeakRefEdges
(
JSTracer
*
trc
)
{
for
(
WeakRefMap
:
:
Enum
e
(
weakRefMap
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
ObserverList
&
weakRefs
=
e
.
front
(
)
.
value
(
)
;
auto
result
=
TraceWeakEdge
(
trc
&
e
.
front
(
)
.
mutableKey
(
)
"
WeakRef
target
"
)
;
if
(
result
.
isDead
(
)
)
{
while
(
!
weakRefs
.
isEmpty
(
)
)
{
auto
*
weakRef
=
&
weakRefs
.
getFirst
(
)
-
>
as
<
WeakRefObject
>
(
)
;
weakRef
-
>
clearTargetAndUnlink
(
)
;
}
e
.
removeFront
(
)
;
}
else
if
(
result
.
finalTarget
(
)
!
=
result
.
initialTarget
(
)
)
{
traceWeakWeakRefList
(
trc
weakRefs
result
.
finalTarget
(
)
)
;
}
}
}
void
FinalizationObservers
:
:
traceWeakWeakRefList
(
JSTracer
*
trc
ObserverList
&
weakRefs
Value
target
)
{
MOZ_ASSERT
(
!
IsForwarded
(
target
.
toGCThing
(
)
)
)
;
for
(
auto
iter
=
weakRefs
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
auto
*
weakRef
=
&
iter
.
get
(
)
-
>
as
<
WeakRefObject
>
(
)
;
MOZ_ASSERT
(
!
IsForwarded
(
weakRef
)
)
;
if
(
weakRef
-
>
target
(
)
!
=
target
)
{
MOZ_ASSERT
(
MaybeForwarded
(
weakRef
-
>
target
(
)
.
toGCThing
(
)
)
=
=
target
.
toGCThing
(
)
)
;
weakRef
-
>
setTargetUnbarriered
(
target
)
;
}
}
}
