#
include
"
gc
/
FinalizationObservers
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
builtin
/
FinalizationRegistryObject
.
h
"
#
include
"
builtin
/
WeakRefObject
.
h
"
#
include
"
gc
/
GCRuntime
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
gc
/
WeakMap
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
NativeObject
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
FinalizationObservers
:
:
FinalizationObservers
(
Zone
*
zone
)
:
zone
(
zone
)
registries
(
zone
)
recordMap
(
zone
)
crossZoneRecords
(
zone
)
weakRefMap
(
zone
)
crossZoneWeakRefs
(
zone
)
{
}
FinalizationObservers
:
:
~
FinalizationObservers
(
)
{
MOZ_ASSERT
(
registries
.
empty
(
)
)
;
MOZ_ASSERT
(
recordMap
.
empty
(
)
)
;
MOZ_ASSERT
(
crossZoneRecords
.
empty
(
)
)
;
MOZ_ASSERT
(
crossZoneWeakRefs
.
empty
(
)
)
;
}
bool
GCRuntime
:
:
addFinalizationRegistry
(
JSContext
*
cx
Handle
<
FinalizationRegistryObject
*
>
registry
)
{
if
(
!
cx
-
>
zone
(
)
-
>
ensureFinalizationObservers
(
)
|
|
!
cx
-
>
zone
(
)
-
>
finalizationObservers
(
)
-
>
addRegistry
(
registry
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
bool
FinalizationObservers
:
:
addRegistry
(
Handle
<
FinalizationRegistryObject
*
>
registry
)
{
return
registries
.
put
(
registry
)
;
}
bool
GCRuntime
:
:
registerWithFinalizationRegistry
(
JSContext
*
cx
HandleObject
target
HandleObject
record
)
{
MOZ_ASSERT
(
!
IsCrossCompartmentWrapper
(
target
)
)
;
MOZ_ASSERT
(
UncheckedUnwrapWithoutExpose
(
record
)
-
>
is
<
FinalizationRecordObject
>
(
)
)
;
MOZ_ASSERT
(
target
-
>
compartment
(
)
=
=
record
-
>
compartment
(
)
)
;
Zone
*
zone
=
cx
-
>
zone
(
)
;
if
(
!
zone
-
>
ensureFinalizationObservers
(
)
|
|
!
zone
-
>
finalizationObservers
(
)
-
>
addRecord
(
target
record
)
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
true
;
}
bool
FinalizationObservers
:
:
addRecord
(
HandleObject
target
HandleObject
record
)
{
MOZ_ASSERT
(
target
-
>
zone
(
)
=
=
zone
)
;
FinalizationRecordObject
*
unwrappedRecord
=
&
UncheckedUnwrapWithoutExpose
(
record
)
-
>
as
<
FinalizationRecordObject
>
(
)
;
Zone
*
registryZone
=
unwrappedRecord
-
>
zone
(
)
;
bool
crossZone
=
registryZone
!
=
zone
;
if
(
crossZone
&
&
!
addCrossZoneWrapper
(
crossZoneRecords
record
)
)
{
return
false
;
}
auto
wrapperGuard
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
if
(
crossZone
)
{
removeCrossZoneWrapper
(
crossZoneRecords
record
)
;
}
}
)
;
GlobalObject
*
registryGlobal
=
&
unwrappedRecord
-
>
global
(
)
;
auto
*
globalData
=
registryGlobal
-
>
getOrCreateFinalizationRegistryData
(
)
;
if
(
!
globalData
|
|
!
globalData
-
>
addRecord
(
unwrappedRecord
)
)
{
return
false
;
}
auto
globalDataGuard
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
globalData
-
>
removeRecord
(
unwrappedRecord
)
;
}
)
;
auto
ptr
=
recordMap
.
lookupForAdd
(
target
)
;
if
(
!
ptr
&
&
!
recordMap
.
add
(
ptr
target
RecordVector
(
zone
)
)
)
{
return
false
;
}
if
(
!
ptr
-
>
value
(
)
.
append
(
record
)
)
{
return
false
;
}
unwrappedRecord
-
>
setInRecordMap
(
true
)
;
globalDataGuard
.
release
(
)
;
wrapperGuard
.
release
(
)
;
return
true
;
}
bool
FinalizationObservers
:
:
addCrossZoneWrapper
(
WrapperWeakSet
&
weakSet
JSObject
*
wrapper
)
{
MOZ_ASSERT
(
IsCrossCompartmentWrapper
(
wrapper
)
)
;
MOZ_ASSERT
(
UncheckedUnwrapWithoutExpose
(
wrapper
)
-
>
zone
(
)
!
=
zone
)
;
auto
ptr
=
weakSet
.
lookupForAdd
(
wrapper
)
;
MOZ_ASSERT
(
!
ptr
)
;
return
weakSet
.
add
(
ptr
wrapper
UndefinedValue
(
)
)
;
}
void
FinalizationObservers
:
:
removeCrossZoneWrapper
(
WrapperWeakSet
&
weakSet
JSObject
*
wrapper
)
{
MOZ_ASSERT
(
IsCrossCompartmentWrapper
(
wrapper
)
)
;
MOZ_ASSERT
(
UncheckedUnwrapWithoutExpose
(
wrapper
)
-
>
zone
(
)
!
=
zone
)
;
auto
ptr
=
weakSet
.
lookupForAdd
(
wrapper
)
;
MOZ_ASSERT
(
ptr
)
;
weakSet
.
remove
(
ptr
)
;
}
static
FinalizationRecordObject
*
UnwrapFinalizationRecord
(
JSObject
*
obj
)
{
obj
=
UncheckedUnwrapWithoutExpose
(
obj
)
;
if
(
!
obj
-
>
is
<
FinalizationRecordObject
>
(
)
)
{
MOZ_ASSERT
(
JS_IsDeadWrapper
(
obj
)
)
;
return
nullptr
;
}
return
&
obj
-
>
as
<
FinalizationRecordObject
>
(
)
;
}
void
FinalizationObservers
:
:
clearRecords
(
)
{
#
ifdef
DEBUG
checkTables
(
)
;
#
endif
recordMap
.
clear
(
)
;
crossZoneRecords
.
clear
(
)
;
}
void
GCRuntime
:
:
traceWeakFinalizationObserverEdges
(
JSTracer
*
trc
Zone
*
zone
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
trc
-
>
runtime
(
)
)
)
;
FinalizationObservers
*
observers
=
zone
-
>
finalizationObservers
(
)
;
if
(
observers
)
{
observers
-
>
traceWeakEdges
(
trc
)
;
}
}
void
FinalizationObservers
:
:
traceRoots
(
JSTracer
*
trc
)
{
crossZoneRecords
.
trace
(
trc
)
;
crossZoneWeakRefs
.
trace
(
trc
)
;
}
void
FinalizationObservers
:
:
traceWeakEdges
(
JSTracer
*
trc
)
{
AutoTouchingGrayThings
atgt
;
traceWeakWeakRefEdges
(
trc
)
;
traceWeakFinalizationRegistryEdges
(
trc
)
;
}
void
FinalizationObservers
:
:
traceWeakFinalizationRegistryEdges
(
JSTracer
*
trc
)
{
GCRuntime
*
gc
=
&
trc
-
>
runtime
(
)
-
>
gc
;
for
(
RegistrySet
:
:
Enum
e
(
registries
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
auto
result
=
TraceWeakEdge
(
trc
&
e
.
mutableFront
(
)
"
FinalizationRegistry
"
)
;
if
(
result
.
isDead
(
)
)
{
auto
*
registry
=
&
result
.
initialTarget
(
)
-
>
as
<
FinalizationRegistryObject
>
(
)
;
registry
-
>
queue
(
)
-
>
setHasRegistry
(
false
)
;
e
.
removeFront
(
)
;
}
else
{
result
.
finalTarget
(
)
-
>
as
<
FinalizationRegistryObject
>
(
)
.
traceWeak
(
trc
)
;
}
}
for
(
RecordMap
:
:
Enum
e
(
recordMap
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
RecordVector
&
records
=
e
.
front
(
)
.
value
(
)
;
records
.
mutableEraseIf
(
[
&
]
(
HeapPtr
<
JSObject
*
>
&
heapPtr
)
{
auto
result
=
TraceWeakEdge
(
trc
&
heapPtr
"
FinalizationRecord
"
)
;
JSObject
*
obj
=
result
.
isLive
(
)
?
result
.
finalTarget
(
)
:
result
.
initialTarget
(
)
;
FinalizationRecordObject
*
record
=
UnwrapFinalizationRecord
(
obj
)
;
MOZ_ASSERT_IF
(
record
record
-
>
isInRecordMap
(
)
)
;
bool
shouldRemove
=
!
result
.
isLive
(
)
|
|
shouldRemoveRecord
(
record
)
;
if
(
shouldRemove
&
&
record
&
&
record
-
>
isInRecordMap
(
)
)
{
updateForRemovedRecord
(
obj
record
)
;
}
return
shouldRemove
;
}
)
;
#
ifdef
DEBUG
for
(
JSObject
*
obj
:
records
)
{
MOZ_ASSERT
(
UnwrapFinalizationRecord
(
obj
)
-
>
isInRecordMap
(
)
)
;
}
#
endif
if
(
!
TraceWeakEdge
(
trc
&
e
.
front
(
)
.
mutableKey
(
)
"
FinalizationRecord
target
"
)
)
{
for
(
JSObject
*
obj
:
records
)
{
FinalizationRecordObject
*
record
=
UnwrapFinalizationRecord
(
obj
)
;
FinalizationQueueObject
*
queue
=
record
-
>
queue
(
)
;
updateForRemovedRecord
(
obj
record
)
;
queue
-
>
queueRecordToBeCleanedUp
(
record
)
;
gc
-
>
queueFinalizationRegistryForCleanup
(
queue
)
;
}
e
.
removeFront
(
)
;
}
}
}
bool
FinalizationObservers
:
:
shouldRemoveRecord
(
FinalizationRecordObject
*
record
)
{
return
!
record
|
|
!
record
-
>
isRegistered
(
)
|
|
!
record
-
>
queue
(
)
-
>
hasRegistry
(
)
;
}
void
FinalizationObservers
:
:
updateForRemovedRecord
(
JSObject
*
wrapper
FinalizationRecordObject
*
record
)
{
MOZ_ASSERT
(
record
-
>
isInRecordMap
(
)
)
;
Zone
*
registryZone
=
record
-
>
zone
(
)
;
if
(
registryZone
!
=
zone
)
{
removeCrossZoneWrapper
(
crossZoneRecords
wrapper
)
;
}
GlobalObject
*
registryGlobal
=
&
record
-
>
global
(
)
;
auto
*
globalData
=
registryGlobal
-
>
maybeFinalizationRegistryData
(
)
;
globalData
-
>
removeRecord
(
record
)
;
AutoTouchingGrayThings
atgt
;
record
-
>
setInRecordMap
(
false
)
;
}
void
GCRuntime
:
:
nukeFinalizationRecordWrapper
(
JSObject
*
wrapper
FinalizationRecordObject
*
record
)
{
if
(
record
-
>
isInRecordMap
(
)
)
{
FinalizationRegistryObject
:
:
unregisterRecord
(
record
)
;
FinalizationObservers
*
observers
=
wrapper
-
>
zone
(
)
-
>
finalizationObservers
(
)
;
observers
-
>
updateForRemovedRecord
(
wrapper
record
)
;
}
}
void
GCRuntime
:
:
queueFinalizationRegistryForCleanup
(
FinalizationQueueObject
*
queue
)
{
if
(
queue
-
>
isQueuedForCleanup
(
)
)
{
return
;
}
JSObject
*
object
=
UncheckedUnwrapWithoutExpose
(
queue
-
>
incumbentObject
(
)
)
;
MOZ_ASSERT
(
object
)
;
GlobalObject
*
incumbentGlobal
=
&
object
-
>
nonCCWGlobal
(
)
;
callHostCleanupFinalizationRegistryCallback
(
queue
-
>
doCleanupFunction
(
)
incumbentGlobal
)
;
AutoTouchingGrayThings
atgt
;
queue
-
>
setQueuedForCleanup
(
true
)
;
}
bool
GCRuntime
:
:
registerWeakRef
(
HandleObject
target
HandleObject
weakRef
)
{
MOZ_ASSERT
(
!
IsCrossCompartmentWrapper
(
target
)
)
;
MOZ_ASSERT
(
UncheckedUnwrap
(
weakRef
)
-
>
is
<
WeakRefObject
>
(
)
)
;
MOZ_ASSERT_IF
(
target
-
>
zone
(
)
!
=
weakRef
-
>
zone
(
)
target
-
>
compartment
(
)
=
=
weakRef
-
>
compartment
(
)
)
;
Zone
*
zone
=
target
-
>
zone
(
)
;
return
zone
-
>
ensureFinalizationObservers
(
)
&
&
zone
-
>
finalizationObservers
(
)
-
>
addWeakRefTarget
(
target
weakRef
)
;
}
bool
FinalizationObservers
:
:
addWeakRefTarget
(
HandleObject
target
HandleObject
weakRef
)
{
WeakRefObject
*
unwrappedWeakRef
=
&
UncheckedUnwrapWithoutExpose
(
weakRef
)
-
>
as
<
WeakRefObject
>
(
)
;
Zone
*
weakRefZone
=
unwrappedWeakRef
-
>
zone
(
)
;
bool
crossZone
=
weakRefZone
!
=
zone
;
if
(
crossZone
&
&
!
addCrossZoneWrapper
(
crossZoneWeakRefs
weakRef
)
)
{
return
false
;
}
auto
wrapperGuard
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
if
(
crossZone
)
{
removeCrossZoneWrapper
(
crossZoneWeakRefs
weakRef
)
;
}
}
)
;
auto
ptr
=
weakRefMap
.
lookupForAdd
(
target
)
;
if
(
!
ptr
&
&
!
weakRefMap
.
add
(
ptr
target
WeakRefHeapPtrVector
(
zone
)
)
)
{
return
false
;
}
if
(
!
ptr
-
>
value
(
)
.
emplaceBack
(
weakRef
)
)
{
return
false
;
}
wrapperGuard
.
release
(
)
;
return
true
;
}
void
GCRuntime
:
:
nukeWeakRefWrapper
(
JSObject
*
wrapper
WeakRefObject
*
weakRef
)
{
JSObject
*
target
=
weakRef
-
>
target
(
)
;
if
(
!
target
)
{
return
;
}
FinalizationObservers
*
observers
=
target
-
>
zone
(
)
-
>
finalizationObservers
(
)
;
if
(
observers
)
{
observers
-
>
unregisterWeakRefWrapper
(
wrapper
weakRef
)
;
}
}
void
FinalizationObservers
:
:
unregisterWeakRefWrapper
(
JSObject
*
wrapper
WeakRefObject
*
weakRef
)
{
JSObject
*
target
=
weakRef
-
>
target
(
)
;
MOZ_ASSERT
(
target
)
;
bool
removed
=
false
;
WeakRefHeapPtrVector
&
weakRefs
=
weakRefMap
.
lookup
(
target
)
-
>
value
(
)
;
weakRefs
.
eraseIf
(
[
wrapper
&
removed
]
(
JSObject
*
obj
)
{
bool
remove
=
obj
=
=
wrapper
;
if
(
remove
)
{
removed
=
true
;
}
return
remove
;
}
)
;
if
(
removed
)
{
updateForRemovedWeakRef
(
wrapper
weakRef
)
;
}
}
void
FinalizationObservers
:
:
updateForRemovedWeakRef
(
JSObject
*
wrapper
WeakRefObject
*
weakRef
)
{
weakRef
-
>
clearTarget
(
)
;
Zone
*
weakRefZone
=
weakRef
-
>
zone
(
)
;
if
(
weakRefZone
!
=
zone
)
{
removeCrossZoneWrapper
(
crossZoneWeakRefs
wrapper
)
;
}
}
static
WeakRefObject
*
UnwrapWeakRef
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
!
JS_IsDeadWrapper
(
obj
)
)
;
obj
=
UncheckedUnwrapWithoutExpose
(
obj
)
;
return
&
obj
-
>
as
<
WeakRefObject
>
(
)
;
}
void
FinalizationObservers
:
:
traceWeakWeakRefEdges
(
JSTracer
*
trc
)
{
for
(
WeakRefMap
:
:
Enum
e
(
weakRefMap
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
auto
result
=
TraceWeakEdge
(
trc
&
e
.
front
(
)
.
mutableKey
(
)
"
WeakRef
target
"
)
;
if
(
result
.
isDead
(
)
)
{
for
(
JSObject
*
obj
:
e
.
front
(
)
.
value
(
)
)
{
updateForRemovedWeakRef
(
obj
UnwrapWeakRef
(
obj
)
)
;
}
e
.
removeFront
(
)
;
}
else
{
traceWeakWeakRefVector
(
trc
e
.
front
(
)
.
value
(
)
result
.
finalTarget
(
)
)
;
}
}
}
void
FinalizationObservers
:
:
traceWeakWeakRefVector
(
JSTracer
*
trc
WeakRefHeapPtrVector
&
weakRefs
JSObject
*
target
)
{
weakRefs
.
mutableEraseIf
(
[
&
]
(
HeapPtr
<
JSObject
*
>
&
obj
)
-
>
bool
{
auto
result
=
TraceWeakEdge
(
trc
&
obj
"
WeakRef
"
)
;
if
(
result
.
isDead
(
)
)
{
JSObject
*
wrapper
=
result
.
initialTarget
(
)
;
updateForRemovedWeakRef
(
wrapper
UnwrapWeakRef
(
wrapper
)
)
;
}
else
{
UnwrapWeakRef
(
result
.
finalTarget
(
)
)
-
>
setTargetUnbarriered
(
target
)
;
}
return
result
.
isDead
(
)
;
}
)
;
}
#
ifdef
DEBUG
void
FinalizationObservers
:
:
checkTables
(
)
const
{
size_t
recordCount
=
0
;
for
(
auto
r
=
recordMap
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
for
(
JSObject
*
object
:
r
.
front
(
)
.
value
(
)
)
{
FinalizationRecordObject
*
record
=
UnwrapFinalizationRecord
(
object
)
;
if
(
record
&
&
record
-
>
isInRecordMap
(
)
&
&
record
-
>
zone
(
)
!
=
zone
)
{
MOZ_ASSERT
(
crossZoneRecords
.
has
(
object
)
)
;
recordCount
+
+
;
}
}
}
MOZ_ASSERT
(
crossZoneRecords
.
count
(
)
=
=
recordCount
)
;
size_t
weakRefCount
=
0
;
for
(
auto
r
=
weakRefMap
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
for
(
JSObject
*
object
:
r
.
front
(
)
.
value
(
)
)
{
WeakRefObject
*
weakRef
=
UnwrapWeakRef
(
object
)
;
if
(
weakRef
&
&
weakRef
-
>
zone
(
)
!
=
zone
)
{
MOZ_ASSERT
(
crossZoneWeakRefs
.
has
(
object
)
)
;
weakRefCount
+
+
;
}
}
}
MOZ_ASSERT
(
crossZoneWeakRefs
.
count
(
)
=
=
weakRefCount
)
;
}
#
endif
FinalizationRegistryGlobalData
:
:
FinalizationRegistryGlobalData
(
Zone
*
zone
)
:
recordSet
(
zone
)
{
}
bool
FinalizationRegistryGlobalData
:
:
addRecord
(
FinalizationRecordObject
*
record
)
{
return
recordSet
.
putNew
(
record
)
;
}
void
FinalizationRegistryGlobalData
:
:
removeRecord
(
FinalizationRecordObject
*
record
)
{
MOZ_ASSERT_IF
(
!
record
-
>
runtimeFromMainThread
(
)
-
>
gc
.
isShuttingDown
(
)
recordSet
.
has
(
record
)
)
;
recordSet
.
remove
(
record
)
;
}
void
FinalizationRegistryGlobalData
:
:
trace
(
JSTracer
*
trc
)
{
recordSet
.
trace
(
trc
)
;
}
