#
ifndef
gc_Cell_h
#
define
gc_Cell_h
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
#
include
"
js
/
TraceKind
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
JS
{
namespace
shadow
{
struct
Zone
;
}
enum
class
TraceKind
;
}
namespace
js
{
class
GenericPrinter
;
extern
bool
RuntimeFromMainThreadIsHeapMajorCollecting
(
JS
:
:
shadow
:
:
Zone
*
shadowZone
)
;
#
ifdef
DEBUG
extern
bool
CurrentThreadIsIonCompiling
(
)
;
extern
bool
CurrentThreadIsGCMarking
(
)
;
#
endif
extern
void
TraceManuallyBarrieredGenericPointerEdge
(
JSTracer
*
trc
gc
:
:
Cell
*
*
thingp
const
char
*
name
)
;
namespace
gc
{
class
Arena
;
enum
class
AllocKind
:
uint8_t
;
struct
Chunk
;
class
StoreBuffer
;
class
TenuredCell
;
class
CellColor
{
public
:
enum
Color
{
White
=
0
Gray
=
1
Black
=
2
}
;
CellColor
(
)
:
color
(
White
)
{
}
MOZ_IMPLICIT
CellColor
(
MarkColor
markColor
)
:
color
(
markColor
=
=
MarkColor
:
:
Black
?
Black
:
Gray
)
{
}
MOZ_IMPLICIT
constexpr
CellColor
(
Color
c
)
:
color
(
c
)
{
}
MarkColor
asMarkColor
(
)
const
{
MOZ_ASSERT
(
color
!
=
White
)
;
return
color
=
=
Black
?
MarkColor
:
:
Black
:
MarkColor
:
:
Gray
;
}
bool
operator
<
(
const
CellColor
other
)
const
{
return
color
<
other
.
color
;
}
bool
operator
>
(
const
CellColor
other
)
const
{
return
color
>
other
.
color
;
}
bool
operator
<
=
(
const
CellColor
other
)
const
{
return
color
<
=
other
.
color
;
}
bool
operator
>
=
(
const
CellColor
other
)
const
{
return
color
>
=
other
.
color
;
}
bool
operator
!
=
(
const
CellColor
other
)
const
{
return
color
!
=
other
.
color
;
}
bool
operator
=
=
(
const
CellColor
other
)
const
{
return
color
=
=
other
.
color
;
}
explicit
operator
bool
(
)
const
{
return
color
!
=
White
;
}
#
if
defined
(
JS_GC_ZEAL
)
|
|
defined
(
DEBUG
)
const
char
*
name
(
)
const
{
switch
(
color
)
{
case
CellColor
:
:
White
:
return
"
white
"
;
case
CellColor
:
:
Black
:
return
"
black
"
;
case
CellColor
:
:
Gray
:
return
"
gray
"
;
default
:
MOZ_CRASH
(
"
Unexpected
cell
color
"
)
;
}
}
#
endif
private
:
Color
color
;
}
;
class
CellHeader
{
public
:
static_assert
(
gc
:
:
CellFlagBitsReservedForGC
>
=
3
"
Not
enough
flag
bits
reserved
for
GC
"
)
;
static
constexpr
uintptr_t
RESERVED_MASK
=
BitMask
(
gc
:
:
CellFlagBitsReservedForGC
)
;
static
constexpr
uintptr_t
FORWARD_BIT
=
Bit
(
0
)
;
static
constexpr
uintptr_t
JSSTRING_BIT
=
Bit
(
1
)
;
static
constexpr
uintptr_t
BIGINT_BIT
=
Bit
(
2
)
;
protected
:
uintptr_t
flags
(
)
const
{
return
header_
&
RESERVED_MASK
;
}
uintptr_t
header_
;
}
;
struct
alignas
(
gc
:
:
CellAlignBytes
)
Cell
{
public
:
MOZ_ALWAYS_INLINE
bool
isTenured
(
)
const
{
return
!
IsInsideNursery
(
this
)
;
}
MOZ_ALWAYS_INLINE
const
TenuredCell
&
asTenured
(
)
const
;
MOZ_ALWAYS_INLINE
TenuredCell
&
asTenured
(
)
;
MOZ_ALWAYS_INLINE
bool
isMarkedAny
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isMarkedBlack
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isMarkedGray
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isMarked
(
gc
:
:
MarkColor
color
)
const
;
MOZ_ALWAYS_INLINE
bool
isMarkedAtLeast
(
gc
:
:
MarkColor
color
)
const
;
MOZ_ALWAYS_INLINE
CellColor
color
(
)
const
{
return
isMarkedBlack
(
)
?
CellColor
:
:
Black
:
isMarkedGray
(
)
?
CellColor
:
:
Gray
:
CellColor
:
:
White
;
}
inline
JSRuntime
*
runtimeFromMainThread
(
)
const
;
inline
JSRuntime
*
runtimeFromAnyThread
(
)
const
;
inline
JS
:
:
Compartment
*
maybeCompartment
(
)
const
{
return
nullptr
;
}
inline
StoreBuffer
*
storeBuffer
(
)
const
;
inline
JS
:
:
TraceKind
getTraceKind
(
)
const
;
static
MOZ_ALWAYS_INLINE
bool
needWriteBarrierPre
(
JS
:
:
Zone
*
zone
)
;
inline
bool
isForwarded
(
)
const
{
uintptr_t
firstWord
=
*
reinterpret_cast
<
const
uintptr_t
*
>
(
this
)
;
return
firstWord
&
CellHeader
:
:
FORWARD_BIT
;
}
inline
bool
nurseryCellIsString
(
)
const
{
MOZ_ASSERT
(
!
isTenured
(
)
)
;
uintptr_t
firstWord
=
*
reinterpret_cast
<
const
uintptr_t
*
>
(
this
)
;
return
firstWord
&
CellHeader
:
:
JSSTRING_BIT
;
}
inline
bool
nurseryCellIsBigInt
(
)
const
{
MOZ_ASSERT
(
!
isTenured
(
)
)
;
uintptr_t
firstWord
=
*
reinterpret_cast
<
const
uintptr_t
*
>
(
this
)
;
return
firstWord
&
CellHeader
:
:
BIGINT_BIT
;
}
template
<
class
T
>
inline
bool
is
(
)
const
{
return
getTraceKind
(
)
=
=
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
;
}
template
<
class
T
>
inline
T
*
as
(
)
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
static_cast
<
T
*
>
(
this
)
;
}
template
<
class
T
>
inline
const
T
*
as
(
)
const
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
static_cast
<
const
T
*
>
(
this
)
;
}
#
ifdef
DEBUG
static
inline
void
assertThingIsNotGray
(
Cell
*
cell
)
;
inline
bool
isAligned
(
)
const
;
void
dump
(
GenericPrinter
&
out
)
const
;
void
dump
(
)
const
;
#
endif
protected
:
uintptr_t
address
(
)
const
;
inline
Chunk
*
chunk
(
)
const
;
}
JS_HAZ_GC_THING
;
class
TenuredCell
:
public
Cell
{
public
:
MOZ_ALWAYS_INLINE
bool
isTenured
(
)
const
{
MOZ_ASSERT
(
!
IsInsideNursery
(
this
)
)
;
return
true
;
}
MOZ_ALWAYS_INLINE
bool
isMarkedAny
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isMarkedBlack
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isMarkedGray
(
)
const
;
MOZ_ALWAYS_INLINE
CellColor
color
(
)
const
{
return
isMarkedBlack
(
)
?
CellColor
:
:
Black
:
isMarkedGray
(
)
?
CellColor
:
:
Gray
:
CellColor
:
:
White
;
}
MOZ_ALWAYS_INLINE
bool
markIfUnmarked
(
MarkColor
color
=
MarkColor
:
:
Black
)
const
;
MOZ_ALWAYS_INLINE
void
markBlack
(
)
const
;
MOZ_ALWAYS_INLINE
void
copyMarkBitsFrom
(
const
TenuredCell
*
src
)
;
MOZ_ALWAYS_INLINE
void
unmark
(
)
;
inline
Arena
*
arena
(
)
const
;
inline
AllocKind
getAllocKind
(
)
const
;
inline
JS
:
:
TraceKind
getTraceKind
(
)
const
;
inline
JS
:
:
Zone
*
zone
(
)
const
;
inline
JS
:
:
Zone
*
zoneFromAnyThread
(
)
const
;
inline
bool
isInsideZone
(
JS
:
:
Zone
*
zone
)
const
;
MOZ_ALWAYS_INLINE
JS
:
:
shadow
:
:
Zone
*
shadowZone
(
)
const
{
return
JS
:
:
shadow
:
:
Zone
:
:
from
(
zone
(
)
)
;
}
MOZ_ALWAYS_INLINE
JS
:
:
shadow
:
:
Zone
*
shadowZoneFromAnyThread
(
)
const
{
return
JS
:
:
shadow
:
:
Zone
:
:
from
(
zoneFromAnyThread
(
)
)
;
}
template
<
class
T
>
inline
bool
is
(
)
const
{
return
getTraceKind
(
)
=
=
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
;
}
template
<
class
T
>
inline
T
*
as
(
)
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
static_cast
<
T
*
>
(
this
)
;
}
template
<
class
T
>
inline
const
T
*
as
(
)
const
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
static_cast
<
const
T
*
>
(
this
)
;
}
static
MOZ_ALWAYS_INLINE
void
readBarrier
(
TenuredCell
*
thing
)
;
static
MOZ_ALWAYS_INLINE
void
writeBarrierPre
(
TenuredCell
*
thing
)
;
static
void
MOZ_ALWAYS_INLINE
writeBarrierPost
(
void
*
cellp
TenuredCell
*
prior
TenuredCell
*
next
)
;
void
fixupAfterMovingGC
(
)
{
}
#
ifdef
DEBUG
inline
bool
isAligned
(
)
const
;
#
endif
}
;
MOZ_ALWAYS_INLINE
const
TenuredCell
&
Cell
:
:
asTenured
(
)
const
{
MOZ_ASSERT
(
isTenured
(
)
)
;
return
*
static_cast
<
const
TenuredCell
*
>
(
this
)
;
}
MOZ_ALWAYS_INLINE
TenuredCell
&
Cell
:
:
asTenured
(
)
{
MOZ_ASSERT
(
isTenured
(
)
)
;
return
*
static_cast
<
TenuredCell
*
>
(
this
)
;
}
MOZ_ALWAYS_INLINE
bool
Cell
:
:
isMarkedAny
(
)
const
{
return
!
isTenured
(
)
|
|
asTenured
(
)
.
isMarkedAny
(
)
;
}
MOZ_ALWAYS_INLINE
bool
Cell
:
:
isMarkedBlack
(
)
const
{
return
!
isTenured
(
)
|
|
asTenured
(
)
.
isMarkedBlack
(
)
;
}
MOZ_ALWAYS_INLINE
bool
Cell
:
:
isMarkedGray
(
)
const
{
return
isTenured
(
)
&
&
asTenured
(
)
.
isMarkedGray
(
)
;
}
MOZ_ALWAYS_INLINE
bool
Cell
:
:
isMarked
(
gc
:
:
MarkColor
color
)
const
{
return
color
=
=
MarkColor
:
:
Gray
?
isMarkedGray
(
)
:
isMarkedBlack
(
)
;
}
MOZ_ALWAYS_INLINE
bool
Cell
:
:
isMarkedAtLeast
(
gc
:
:
MarkColor
color
)
const
{
return
color
=
=
MarkColor
:
:
Gray
?
isMarkedAny
(
)
:
isMarkedBlack
(
)
;
}
inline
JSRuntime
*
Cell
:
:
runtimeFromMainThread
(
)
const
{
JSRuntime
*
rt
=
chunk
(
)
-
>
trailer
.
runtime
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
return
rt
;
}
inline
JSRuntime
*
Cell
:
:
runtimeFromAnyThread
(
)
const
{
return
chunk
(
)
-
>
trailer
.
runtime
;
}
inline
uintptr_t
Cell
:
:
address
(
)
const
{
uintptr_t
addr
=
uintptr_t
(
this
)
;
MOZ_ASSERT
(
addr
%
CellAlignBytes
=
=
0
)
;
MOZ_ASSERT
(
Chunk
:
:
withinValidRange
(
addr
)
)
;
return
addr
;
}
Chunk
*
Cell
:
:
chunk
(
)
const
{
uintptr_t
addr
=
uintptr_t
(
this
)
;
MOZ_ASSERT
(
addr
%
CellAlignBytes
=
=
0
)
;
addr
&
=
~
ChunkMask
;
return
reinterpret_cast
<
Chunk
*
>
(
addr
)
;
}
inline
StoreBuffer
*
Cell
:
:
storeBuffer
(
)
const
{
return
chunk
(
)
-
>
trailer
.
storeBuffer
;
}
#
ifdef
DEBUG
extern
Cell
*
UninlinedForwarded
(
const
Cell
*
cell
)
;
#
endif
inline
JS
:
:
TraceKind
Cell
:
:
getTraceKind
(
)
const
{
if
(
isTenured
(
)
)
{
MOZ_ASSERT_IF
(
isForwarded
(
)
UninlinedForwarded
(
this
)
-
>
getTraceKind
(
)
=
=
asTenured
(
)
.
getTraceKind
(
)
)
;
return
asTenured
(
)
.
getTraceKind
(
)
;
}
if
(
nurseryCellIsString
(
)
)
{
MOZ_ASSERT_IF
(
isForwarded
(
)
UninlinedForwarded
(
this
)
-
>
getTraceKind
(
)
=
=
JS
:
:
TraceKind
:
:
String
)
;
return
JS
:
:
TraceKind
:
:
String
;
}
if
(
nurseryCellIsBigInt
(
)
)
{
MOZ_ASSERT_IF
(
isForwarded
(
)
UninlinedForwarded
(
this
)
-
>
getTraceKind
(
)
=
=
JS
:
:
TraceKind
:
:
BigInt
)
;
return
JS
:
:
TraceKind
:
:
BigInt
;
}
MOZ_ASSERT_IF
(
isForwarded
(
)
UninlinedForwarded
(
this
)
-
>
getTraceKind
(
)
=
=
JS
:
:
TraceKind
:
:
Object
)
;
return
JS
:
:
TraceKind
:
:
Object
;
}
MOZ_ALWAYS_INLINE
bool
Cell
:
:
needWriteBarrierPre
(
JS
:
:
Zone
*
zone
)
{
return
JS
:
:
shadow
:
:
Zone
:
:
from
(
zone
)
-
>
needsIncrementalBarrier
(
)
;
}
bool
TenuredCell
:
:
isMarkedAny
(
)
const
{
MOZ_ASSERT
(
arena
(
)
-
>
allocated
(
)
)
;
return
chunk
(
)
-
>
bitmap
.
isMarkedAny
(
this
)
;
}
bool
TenuredCell
:
:
isMarkedBlack
(
)
const
{
MOZ_ASSERT
(
arena
(
)
-
>
allocated
(
)
)
;
return
chunk
(
)
-
>
bitmap
.
isMarkedBlack
(
this
)
;
}
bool
TenuredCell
:
:
isMarkedGray
(
)
const
{
MOZ_ASSERT
(
arena
(
)
-
>
allocated
(
)
)
;
return
chunk
(
)
-
>
bitmap
.
isMarkedGray
(
this
)
;
}
bool
TenuredCell
:
:
markIfUnmarked
(
MarkColor
color
)
const
{
return
chunk
(
)
-
>
bitmap
.
markIfUnmarked
(
this
color
)
;
}
void
TenuredCell
:
:
markBlack
(
)
const
{
chunk
(
)
-
>
bitmap
.
markBlack
(
this
)
;
}
void
TenuredCell
:
:
copyMarkBitsFrom
(
const
TenuredCell
*
src
)
{
ChunkBitmap
&
bitmap
=
chunk
(
)
-
>
bitmap
;
bitmap
.
copyMarkBit
(
this
src
ColorBit
:
:
BlackBit
)
;
bitmap
.
copyMarkBit
(
this
src
ColorBit
:
:
GrayOrBlackBit
)
;
}
void
TenuredCell
:
:
unmark
(
)
{
chunk
(
)
-
>
bitmap
.
unmark
(
this
)
;
}
inline
Arena
*
TenuredCell
:
:
arena
(
)
const
{
MOZ_ASSERT
(
isTenured
(
)
)
;
uintptr_t
addr
=
address
(
)
;
addr
&
=
~
ArenaMask
;
return
reinterpret_cast
<
Arena
*
>
(
addr
)
;
}
AllocKind
TenuredCell
:
:
getAllocKind
(
)
const
{
return
arena
(
)
-
>
getAllocKind
(
)
;
}
JS
:
:
TraceKind
TenuredCell
:
:
getTraceKind
(
)
const
{
return
MapAllocToTraceKind
(
getAllocKind
(
)
)
;
}
JS
:
:
Zone
*
TenuredCell
:
:
zone
(
)
const
{
JS
:
:
Zone
*
zone
=
arena
(
)
-
>
zone
;
MOZ_ASSERT
(
CurrentThreadIsGCMarking
(
)
|
|
CurrentThreadCanAccessZone
(
zone
)
)
;
return
zone
;
}
JS
:
:
Zone
*
TenuredCell
:
:
zoneFromAnyThread
(
)
const
{
return
arena
(
)
-
>
zone
;
}
bool
TenuredCell
:
:
isInsideZone
(
JS
:
:
Zone
*
zone
)
const
{
return
zone
=
=
arena
(
)
-
>
zone
;
}
MOZ_ALWAYS_INLINE
void
TenuredCell
:
:
readBarrier
(
TenuredCell
*
thing
)
{
MOZ_ASSERT
(
!
CurrentThreadIsIonCompiling
(
)
)
;
MOZ_ASSERT
(
thing
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessZone
(
thing
-
>
zoneFromAnyThread
(
)
)
)
;
MOZ_ASSERT_IF
(
CurrentThreadCanAccessRuntime
(
thing
-
>
runtimeFromAnyThread
(
)
)
!
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
JS
:
:
shadow
:
:
Zone
*
shadowZone
=
thing
-
>
shadowZoneFromAnyThread
(
)
;
if
(
shadowZone
-
>
needsIncrementalBarrier
(
)
)
{
MOZ_ASSERT
(
!
RuntimeFromMainThreadIsHeapMajorCollecting
(
shadowZone
)
)
;
Cell
*
tmp
=
thing
;
TraceManuallyBarrieredGenericPointerEdge
(
shadowZone
-
>
barrierTracer
(
)
&
tmp
"
read
barrier
"
)
;
MOZ_ASSERT
(
tmp
=
=
thing
)
;
}
if
(
thing
-
>
isMarkedGray
(
)
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
thing
-
>
runtimeFromAnyThread
(
)
)
)
;
if
(
!
JS
:
:
RuntimeHeapIsCollecting
(
)
)
{
JS
:
:
UnmarkGrayGCThingRecursively
(
JS
:
:
GCCellPtr
(
thing
thing
-
>
getTraceKind
(
)
)
)
;
}
}
}
void
AssertSafeToSkipBarrier
(
TenuredCell
*
thing
)
;
MOZ_ALWAYS_INLINE
void
TenuredCell
:
:
writeBarrierPre
(
TenuredCell
*
thing
)
{
MOZ_ASSERT
(
!
CurrentThreadIsIonCompiling
(
)
)
;
if
(
!
thing
)
{
return
;
}
#
ifdef
JS_GC_ZEAL
if
(
!
CurrentThreadCanAccessRuntime
(
thing
-
>
runtimeFromAnyThread
(
)
)
)
{
AssertSafeToSkipBarrier
(
thing
)
;
return
;
}
#
endif
JS
:
:
shadow
:
:
Zone
*
shadowZone
=
thing
-
>
shadowZoneFromAnyThread
(
)
;
if
(
shadowZone
-
>
needsIncrementalBarrier
(
)
)
{
MOZ_ASSERT
(
!
RuntimeFromMainThreadIsHeapMajorCollecting
(
shadowZone
)
)
;
Cell
*
tmp
=
thing
;
TraceManuallyBarrieredGenericPointerEdge
(
shadowZone
-
>
barrierTracer
(
)
&
tmp
"
pre
barrier
"
)
;
MOZ_ASSERT
(
tmp
=
=
thing
)
;
}
}
static
MOZ_ALWAYS_INLINE
void
AssertValidToSkipBarrier
(
TenuredCell
*
thing
)
{
MOZ_ASSERT
(
!
IsInsideNursery
(
thing
)
)
;
MOZ_ASSERT_IF
(
thing
MapAllocToTraceKind
(
thing
-
>
getAllocKind
(
)
)
!
=
JS
:
:
TraceKind
:
:
Object
&
&
MapAllocToTraceKind
(
thing
-
>
getAllocKind
(
)
)
!
=
JS
:
:
TraceKind
:
:
String
)
;
}
MOZ_ALWAYS_INLINE
void
TenuredCell
:
:
writeBarrierPost
(
void
*
cellp
TenuredCell
*
prior
TenuredCell
*
next
)
{
AssertValidToSkipBarrier
(
next
)
;
}
#
ifdef
DEBUG
void
Cell
:
:
assertThingIsNotGray
(
Cell
*
cell
)
{
JS
:
:
AssertCellIsNotGray
(
cell
)
;
}
bool
Cell
:
:
isAligned
(
)
const
{
if
(
!
isTenured
(
)
)
{
return
true
;
}
return
asTenured
(
)
.
isAligned
(
)
;
}
bool
TenuredCell
:
:
isAligned
(
)
const
{
return
Arena
:
:
isAligned
(
address
(
)
arena
(
)
-
>
getThingSize
(
)
)
;
}
#
endif
class
CellHeaderWithLengthAndFlags
:
public
CellHeader
{
#
if
JS_BITS_PER_WORD
=
=
32
uint32_t
length_
;
#
endif
public
:
uint32_t
lengthField
(
)
const
{
#
if
JS_BITS_PER_WORD
=
=
32
return
length_
;
#
else
return
uint32_t
(
header_
>
>
32
)
;
#
endif
}
uint32_t
flagsField
(
)
const
{
return
uint32_t
(
header_
)
;
}
void
setFlagBit
(
uint32_t
flag
)
{
header_
|
=
uintptr_t
(
flag
)
;
}
void
clearFlagBit
(
uint32_t
flag
)
{
header_
&
=
~
uintptr_t
(
flag
)
;
}
void
toggleFlagBit
(
uint32_t
flag
)
{
header_
^
=
uintptr_t
(
flag
)
;
}
void
setLengthAndFlags
(
uint32_t
len
uint32_t
flags
)
{
#
if
JS_BITS_PER_WORD
=
=
32
header_
=
flags
;
length_
=
len
;
#
else
header_
=
(
uint64_t
(
len
)
<
<
32
)
|
uint64_t
(
flags
)
;
#
endif
}
void
setTemporaryGCUnsafeData
(
uintptr_t
data
)
{
header_
=
data
;
}
uintptr_t
unsetTemporaryGCUnsafeData
(
uint32_t
len
uint32_t
flags
)
{
uintptr_t
data
=
header_
;
setLengthAndFlags
(
len
flags
)
;
return
data
;
}
static
constexpr
size_t
offsetOfRawFlagsField
(
)
{
return
offsetof
(
CellHeaderWithLengthAndFlags
header_
)
;
}
#
if
JS_BITS_PER_WORD
=
=
32
static
constexpr
size_t
offsetOfFlags
(
)
{
return
offsetof
(
CellHeaderWithLengthAndFlags
header_
)
;
}
static
constexpr
size_t
offsetOfLength
(
)
{
return
offsetof
(
CellHeaderWithLengthAndFlags
length_
)
;
}
#
elif
MOZ_LITTLE_ENDIAN
(
)
static
constexpr
size_t
offsetOfFlags
(
)
{
return
offsetof
(
CellHeaderWithLengthAndFlags
header_
)
;
}
static
constexpr
size_t
offsetOfLength
(
)
{
return
offsetof
(
CellHeaderWithLengthAndFlags
header_
)
+
sizeof
(
uint32_t
)
;
}
#
else
static
constexpr
size_t
offsetOfFlags
(
)
{
return
offsetof
(
CellHeaderWithLengthAndFlags
header_
)
+
sizeof
(
uint32_t
)
;
}
static
constexpr
size_t
offsetOfLength
(
)
{
return
offsetof
(
CellHeaderWithLengthAndFlags
header_
)
;
}
#
endif
}
;
template
<
class
PtrT
>
class
CellHeaderWithNonGCPointer
:
public
CellHeader
{
static_assert
(
!
std
:
:
is_pointer
<
PtrT
>
:
:
value
"
PtrT
should
be
the
type
of
the
referent
not
of
the
pointer
"
)
;
static_assert
(
!
std
:
:
is_base_of
<
Cell
PtrT
>
:
:
value
"
Don
'
t
use
CellHeaderWithNonGCPointer
for
pointers
to
GC
things
"
)
;
public
:
CellHeaderWithNonGCPointer
(
)
=
default
;
explicit
CellHeaderWithNonGCPointer
(
PtrT
*
initial
)
:
CellHeader
(
)
{
uintptr_t
data
=
uintptr_t
(
initial
)
;
MOZ_ASSERT
(
(
data
&
RESERVED_MASK
)
=
=
0
)
;
header_
=
data
;
}
PtrT
*
ptr
(
)
const
{
MOZ_ASSERT
(
flags
(
)
=
=
0
)
;
return
reinterpret_cast
<
PtrT
*
>
(
header_
)
;
}
void
setPtr
(
PtrT
*
newValue
)
{
uintptr_t
data
=
uintptr_t
(
newValue
)
;
MOZ_ASSERT
(
flags
(
)
=
=
0
)
;
MOZ_ASSERT
(
(
data
&
RESERVED_MASK
)
=
=
0
)
;
header_
=
data
;
}
static
constexpr
size_t
offsetOfPtr
(
)
{
return
offsetof
(
CellHeaderWithNonGCPointer
header_
)
;
}
}
;
template
<
class
PtrT
>
class
CellHeaderWithTenuredGCPointer
:
public
CellHeader
{
static_assert
(
!
std
:
:
is_pointer
<
PtrT
>
:
:
value
"
PtrT
should
be
the
type
of
the
referent
not
of
the
pointer
"
)
;
static_assert
(
std
:
:
is_base_of
<
Cell
PtrT
>
:
:
value
"
Only
use
CellHeaderWithTenuredGCPointer
for
pointers
to
GC
things
"
)
;
public
:
CellHeaderWithTenuredGCPointer
(
)
=
default
;
explicit
CellHeaderWithTenuredGCPointer
(
PtrT
*
initial
)
:
CellHeader
(
)
{
initPtr
(
initial
)
;
}
void
initPtr
(
PtrT
*
initial
)
{
MOZ_ASSERT
(
!
IsInsideNursery
(
initial
)
)
;
uintptr_t
data
=
uintptr_t
(
initial
)
;
MOZ_ASSERT
(
(
data
&
RESERVED_MASK
)
=
=
0
)
;
this
-
>
header_
=
data
;
}
PtrT
*
ptr
(
)
const
{
MOZ_ASSERT
(
flags
(
)
=
=
0
)
;
return
reinterpret_cast
<
PtrT
*
>
(
this
-
>
header_
)
;
}
void
setPtr
(
PtrT
*
newValue
)
{
MOZ_ASSERT
(
!
IsInsideNursery
(
newValue
)
)
;
PtrT
:
:
writeBarrierPre
(
ptr
(
)
)
;
unsafeSetPtr
(
newValue
)
;
}
void
unsafeSetPtr
(
PtrT
*
newValue
)
{
uintptr_t
data
=
uintptr_t
(
newValue
)
;
MOZ_ASSERT
(
flags
(
)
=
=
0
)
;
MOZ_ASSERT
(
(
data
&
RESERVED_MASK
)
=
=
0
)
;
this
-
>
header_
=
data
;
}
static
constexpr
size_t
offsetOfPtr
(
)
{
return
offsetof
(
CellHeaderWithTenuredGCPointer
header_
)
;
}
}
;
}
}
#
endif
