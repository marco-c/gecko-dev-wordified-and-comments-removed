#
ifndef
gc_Cell_h
#
define
gc_Cell_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
<
type_traits
>
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
#
include
"
js
/
shadow
/
Zone
.
h
"
#
include
"
js
/
TraceKind
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
JS
{
enum
class
TraceKind
;
}
namespace
js
{
class
GenericPrinter
;
extern
bool
RuntimeFromMainThreadIsHeapMajorCollecting
(
JS
:
:
shadow
:
:
Zone
*
shadowZone
)
;
#
ifdef
DEBUG
extern
bool
CurrentThreadIsIonCompiling
(
)
;
extern
bool
CurrentThreadIsGCMarking
(
)
;
extern
bool
CurrentThreadIsGCSweeping
(
)
;
extern
bool
CurrentThreadIsGCFinalizing
(
)
;
extern
bool
RuntimeIsVerifyingPreBarriers
(
JSRuntime
*
runtime
)
;
#
endif
extern
void
TraceManuallyBarrieredGenericPointerEdge
(
JSTracer
*
trc
gc
:
:
Cell
*
*
thingp
const
char
*
name
)
;
namespace
gc
{
class
Arena
;
enum
class
AllocKind
:
uint8_t
;
class
StoreBuffer
;
class
TenuredCell
;
extern
void
PerformIncrementalBarrier
(
TenuredCell
*
cell
)
;
extern
void
PerformIncrementalBarrierDuringFlattening
(
JSString
*
str
)
;
extern
void
UnmarkGrayGCThingRecursively
(
TenuredCell
*
cell
)
;
class
CellColor
{
public
:
enum
Color
{
White
=
0
Gray
=
1
Black
=
2
}
;
CellColor
(
)
:
color
(
White
)
{
}
MOZ_IMPLICIT
CellColor
(
MarkColor
markColor
)
:
color
(
markColor
=
=
MarkColor
:
:
Black
?
Black
:
Gray
)
{
}
MOZ_IMPLICIT
constexpr
CellColor
(
Color
c
)
:
color
(
c
)
{
}
MarkColor
asMarkColor
(
)
const
{
MOZ_ASSERT
(
color
!
=
White
)
;
return
color
=
=
Black
?
MarkColor
:
:
Black
:
MarkColor
:
:
Gray
;
}
bool
operator
<
(
const
CellColor
other
)
const
{
return
color
<
other
.
color
;
}
bool
operator
>
(
const
CellColor
other
)
const
{
return
color
>
other
.
color
;
}
bool
operator
<
=
(
const
CellColor
other
)
const
{
return
color
<
=
other
.
color
;
}
bool
operator
>
=
(
const
CellColor
other
)
const
{
return
color
>
=
other
.
color
;
}
bool
operator
!
=
(
const
CellColor
other
)
const
{
return
color
!
=
other
.
color
;
}
bool
operator
=
=
(
const
CellColor
other
)
const
{
return
color
=
=
other
.
color
;
}
explicit
operator
bool
(
)
const
{
return
color
!
=
White
;
}
#
if
defined
(
JS_GC_ZEAL
)
|
|
defined
(
DEBUG
)
const
char
*
name
(
)
const
{
switch
(
color
)
{
case
CellColor
:
:
White
:
return
"
white
"
;
case
CellColor
:
:
Black
:
return
"
black
"
;
case
CellColor
:
:
Gray
:
return
"
gray
"
;
default
:
MOZ_CRASH
(
"
Unexpected
cell
color
"
)
;
}
}
#
endif
private
:
Color
color
;
}
;
struct
Cell
{
protected
:
mozilla
:
:
Atomic
<
uintptr_t
mozilla
:
:
MemoryOrdering
:
:
Relaxed
>
header_
;
public
:
static_assert
(
gc
:
:
CellFlagBitsReservedForGC
>
=
3
"
Not
enough
flag
bits
reserved
for
GC
"
)
;
static
constexpr
uintptr_t
RESERVED_MASK
=
BitMask
(
gc
:
:
CellFlagBitsReservedForGC
)
;
static
constexpr
uintptr_t
FORWARD_BIT
=
Bit
(
0
)
;
bool
isForwarded
(
)
const
{
return
header_
&
FORWARD_BIT
;
}
uintptr_t
flags
(
)
const
{
return
header_
&
RESERVED_MASK
;
}
MOZ_ALWAYS_INLINE
bool
isTenured
(
)
const
{
return
!
IsInsideNursery
(
this
)
;
}
MOZ_ALWAYS_INLINE
const
TenuredCell
&
asTenured
(
)
const
;
MOZ_ALWAYS_INLINE
TenuredCell
&
asTenured
(
)
;
MOZ_ALWAYS_INLINE
bool
isMarkedAny
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isMarkedBlack
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isMarkedGray
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isMarked
(
gc
:
:
MarkColor
color
)
const
;
MOZ_ALWAYS_INLINE
bool
isMarkedAtLeast
(
gc
:
:
MarkColor
color
)
const
;
MOZ_ALWAYS_INLINE
CellColor
color
(
)
const
{
return
isMarkedBlack
(
)
?
CellColor
:
:
Black
:
isMarkedGray
(
)
?
CellColor
:
:
Gray
:
CellColor
:
:
White
;
}
inline
JSRuntime
*
runtimeFromMainThread
(
)
const
;
inline
JSRuntime
*
runtimeFromAnyThread
(
)
const
;
inline
JS
:
:
Compartment
*
maybeCompartment
(
)
const
{
return
nullptr
;
}
inline
StoreBuffer
*
storeBuffer
(
)
const
;
inline
JS
:
:
TraceKind
getTraceKind
(
)
const
;
static
MOZ_ALWAYS_INLINE
bool
needPreWriteBarrier
(
JS
:
:
Zone
*
zone
)
;
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
JS
:
:
IsBaseTraceType_v
<
T
>
>
>
inline
bool
is
(
)
const
{
return
getTraceKind
(
)
=
=
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
;
}
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
JS
:
:
IsBaseTraceType_v
<
T
>
>
>
inline
T
*
as
(
)
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
static_cast
<
T
*
>
(
this
)
;
}
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
JS
:
:
IsBaseTraceType_v
<
T
>
>
>
inline
const
T
*
as
(
)
const
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
static_cast
<
const
T
*
>
(
this
)
;
}
inline
JS
:
:
Zone
*
zone
(
)
const
;
inline
JS
:
:
Zone
*
zoneFromAnyThread
(
)
const
;
inline
JS
:
:
Zone
*
nurseryZone
(
)
const
;
inline
JS
:
:
Zone
*
nurseryZoneFromAnyThread
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isPermanentAndMayBeShared
(
)
const
{
return
false
;
}
#
ifdef
DEBUG
static
inline
void
assertThingIsNotGray
(
Cell
*
cell
)
;
inline
bool
isAligned
(
)
const
;
void
dump
(
GenericPrinter
&
out
)
const
;
void
dump
(
)
const
;
#
endif
protected
:
uintptr_t
address
(
)
const
;
inline
TenuredChunk
*
chunk
(
)
const
;
private
:
void
operator
delete
(
void
*
)
=
delete
;
}
JS_HAZ_GC_THING
;
class
TenuredCell
:
public
Cell
{
public
:
MOZ_ALWAYS_INLINE
bool
isTenured
(
)
const
{
MOZ_ASSERT
(
!
IsInsideNursery
(
this
)
)
;
return
true
;
}
MOZ_ALWAYS_INLINE
bool
isMarkedAny
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isMarkedBlack
(
)
const
;
MOZ_ALWAYS_INLINE
bool
isMarkedGray
(
)
const
;
MOZ_ALWAYS_INLINE
CellColor
color
(
)
const
{
return
isMarkedBlack
(
)
?
CellColor
:
:
Black
:
isMarkedGray
(
)
?
CellColor
:
:
Gray
:
CellColor
:
:
White
;
}
MOZ_ALWAYS_INLINE
bool
markIfUnmarked
(
MarkColor
color
=
MarkColor
:
:
Black
)
const
;
MOZ_ALWAYS_INLINE
void
markBlack
(
)
const
;
MOZ_ALWAYS_INLINE
void
copyMarkBitsFrom
(
const
TenuredCell
*
src
)
;
MOZ_ALWAYS_INLINE
void
unmark
(
)
;
inline
Arena
*
arena
(
)
const
;
inline
AllocKind
getAllocKind
(
)
const
;
inline
JS
:
:
TraceKind
getTraceKind
(
)
const
;
inline
JS
:
:
Zone
*
zone
(
)
const
;
inline
JS
:
:
Zone
*
zoneFromAnyThread
(
)
const
;
inline
bool
isInsideZone
(
JS
:
:
Zone
*
zone
)
const
;
MOZ_ALWAYS_INLINE
JS
:
:
shadow
:
:
Zone
*
shadowZone
(
)
const
{
return
JS
:
:
shadow
:
:
Zone
:
:
from
(
zone
(
)
)
;
}
MOZ_ALWAYS_INLINE
JS
:
:
shadow
:
:
Zone
*
shadowZoneFromAnyThread
(
)
const
{
return
JS
:
:
shadow
:
:
Zone
:
:
from
(
zoneFromAnyThread
(
)
)
;
}
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
JS
:
:
IsBaseTraceType_v
<
T
>
>
>
inline
bool
is
(
)
const
{
return
getTraceKind
(
)
=
=
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
;
}
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
JS
:
:
IsBaseTraceType_v
<
T
>
>
>
inline
T
*
as
(
)
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
static_cast
<
T
*
>
(
this
)
;
}
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
JS
:
:
IsBaseTraceType_v
<
T
>
>
>
inline
const
T
*
as
(
)
const
{
MOZ_ASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
static_cast
<
const
T
*
>
(
this
)
;
}
void
fixupAfterMovingGC
(
)
{
}
#
ifdef
DEBUG
inline
bool
isAligned
(
)
const
;
#
endif
}
;
MOZ_ALWAYS_INLINE
const
TenuredCell
&
Cell
:
:
asTenured
(
)
const
{
MOZ_ASSERT
(
isTenured
(
)
)
;
return
*
static_cast
<
const
TenuredCell
*
>
(
this
)
;
}
MOZ_ALWAYS_INLINE
TenuredCell
&
Cell
:
:
asTenured
(
)
{
MOZ_ASSERT
(
isTenured
(
)
)
;
return
*
static_cast
<
TenuredCell
*
>
(
this
)
;
}
MOZ_ALWAYS_INLINE
bool
Cell
:
:
isMarkedAny
(
)
const
{
return
!
isTenured
(
)
|
|
asTenured
(
)
.
isMarkedAny
(
)
;
}
MOZ_ALWAYS_INLINE
bool
Cell
:
:
isMarkedBlack
(
)
const
{
return
!
isTenured
(
)
|
|
asTenured
(
)
.
isMarkedBlack
(
)
;
}
MOZ_ALWAYS_INLINE
bool
Cell
:
:
isMarkedGray
(
)
const
{
return
isTenured
(
)
&
&
asTenured
(
)
.
isMarkedGray
(
)
;
}
MOZ_ALWAYS_INLINE
bool
Cell
:
:
isMarked
(
gc
:
:
MarkColor
color
)
const
{
return
color
=
=
MarkColor
:
:
Gray
?
isMarkedGray
(
)
:
isMarkedBlack
(
)
;
}
MOZ_ALWAYS_INLINE
bool
Cell
:
:
isMarkedAtLeast
(
gc
:
:
MarkColor
color
)
const
{
return
color
=
=
MarkColor
:
:
Gray
?
isMarkedAny
(
)
:
isMarkedBlack
(
)
;
}
inline
JSRuntime
*
Cell
:
:
runtimeFromMainThread
(
)
const
{
JSRuntime
*
rt
=
chunk
(
)
-
>
runtime
;
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
rt
)
)
;
return
rt
;
}
inline
JSRuntime
*
Cell
:
:
runtimeFromAnyThread
(
)
const
{
return
chunk
(
)
-
>
runtime
;
}
inline
uintptr_t
Cell
:
:
address
(
)
const
{
uintptr_t
addr
=
uintptr_t
(
this
)
;
MOZ_ASSERT
(
addr
%
CellAlignBytes
=
=
0
)
;
MOZ_ASSERT
(
TenuredChunk
:
:
withinValidRange
(
addr
)
)
;
return
addr
;
}
TenuredChunk
*
Cell
:
:
chunk
(
)
const
{
uintptr_t
addr
=
uintptr_t
(
this
)
;
MOZ_ASSERT
(
addr
%
CellAlignBytes
=
=
0
)
;
addr
&
=
~
ChunkMask
;
return
reinterpret_cast
<
TenuredChunk
*
>
(
addr
)
;
}
inline
StoreBuffer
*
Cell
:
:
storeBuffer
(
)
const
{
return
chunk
(
)
-
>
storeBuffer
;
}
JS
:
:
Zone
*
Cell
:
:
zone
(
)
const
{
if
(
isTenured
(
)
)
{
return
asTenured
(
)
.
zone
(
)
;
}
return
nurseryZone
(
)
;
}
JS
:
:
Zone
*
Cell
:
:
zoneFromAnyThread
(
)
const
{
if
(
isTenured
(
)
)
{
return
asTenured
(
)
.
zoneFromAnyThread
(
)
;
}
return
nurseryZoneFromAnyThread
(
)
;
}
JS
:
:
Zone
*
Cell
:
:
nurseryZone
(
)
const
{
JS
:
:
Zone
*
zone
=
nurseryZoneFromAnyThread
(
)
;
MOZ_ASSERT
(
CurrentThreadIsGCMarking
(
)
|
|
CurrentThreadCanAccessZone
(
zone
)
)
;
return
zone
;
}
JS
:
:
Zone
*
Cell
:
:
nurseryZoneFromAnyThread
(
)
const
{
return
NurseryCellHeader
:
:
from
(
this
)
-
>
zone
(
)
;
}
#
ifdef
DEBUG
extern
Cell
*
UninlinedForwarded
(
const
Cell
*
cell
)
;
#
endif
inline
JS
:
:
TraceKind
Cell
:
:
getTraceKind
(
)
const
{
if
(
isTenured
(
)
)
{
MOZ_ASSERT_IF
(
isForwarded
(
)
UninlinedForwarded
(
this
)
-
>
getTraceKind
(
)
=
=
asTenured
(
)
.
getTraceKind
(
)
)
;
return
asTenured
(
)
.
getTraceKind
(
)
;
}
return
NurseryCellHeader
:
:
from
(
this
)
-
>
traceKind
(
)
;
}
MOZ_ALWAYS_INLINE
bool
Cell
:
:
needPreWriteBarrier
(
JS
:
:
Zone
*
zone
)
{
return
JS
:
:
shadow
:
:
Zone
:
:
from
(
zone
)
-
>
needsIncrementalBarrier
(
)
;
}
bool
TenuredCell
:
:
isMarkedAny
(
)
const
{
MOZ_ASSERT
(
arena
(
)
-
>
allocated
(
)
)
;
return
chunk
(
)
-
>
markBits
.
isMarkedAny
(
this
)
;
}
bool
TenuredCell
:
:
isMarkedBlack
(
)
const
{
MOZ_ASSERT
(
arena
(
)
-
>
allocated
(
)
)
;
return
chunk
(
)
-
>
markBits
.
isMarkedBlack
(
this
)
;
}
bool
TenuredCell
:
:
isMarkedGray
(
)
const
{
MOZ_ASSERT
(
arena
(
)
-
>
allocated
(
)
)
;
return
chunk
(
)
-
>
markBits
.
isMarkedGray
(
this
)
;
}
bool
TenuredCell
:
:
markIfUnmarked
(
MarkColor
color
)
const
{
return
chunk
(
)
-
>
markBits
.
markIfUnmarked
(
this
color
)
;
}
void
TenuredCell
:
:
markBlack
(
)
const
{
chunk
(
)
-
>
markBits
.
markBlack
(
this
)
;
}
void
TenuredCell
:
:
copyMarkBitsFrom
(
const
TenuredCell
*
src
)
{
MarkBitmap
&
markBits
=
chunk
(
)
-
>
markBits
;
markBits
.
copyMarkBit
(
this
src
ColorBit
:
:
BlackBit
)
;
markBits
.
copyMarkBit
(
this
src
ColorBit
:
:
GrayOrBlackBit
)
;
}
void
TenuredCell
:
:
unmark
(
)
{
chunk
(
)
-
>
markBits
.
unmark
(
this
)
;
}
inline
Arena
*
TenuredCell
:
:
arena
(
)
const
{
MOZ_ASSERT
(
isTenured
(
)
)
;
uintptr_t
addr
=
address
(
)
;
addr
&
=
~
ArenaMask
;
return
reinterpret_cast
<
Arena
*
>
(
addr
)
;
}
AllocKind
TenuredCell
:
:
getAllocKind
(
)
const
{
return
arena
(
)
-
>
getAllocKind
(
)
;
}
JS
:
:
TraceKind
TenuredCell
:
:
getTraceKind
(
)
const
{
return
MapAllocToTraceKind
(
getAllocKind
(
)
)
;
}
JS
:
:
Zone
*
TenuredCell
:
:
zone
(
)
const
{
JS
:
:
Zone
*
zone
=
arena
(
)
-
>
zone
;
MOZ_ASSERT
(
CurrentThreadIsGCMarking
(
)
|
|
CurrentThreadCanAccessZone
(
zone
)
)
;
return
zone
;
}
JS
:
:
Zone
*
TenuredCell
:
:
zoneFromAnyThread
(
)
const
{
return
arena
(
)
-
>
zone
;
}
bool
TenuredCell
:
:
isInsideZone
(
JS
:
:
Zone
*
zone
)
const
{
return
zone
=
=
arena
(
)
-
>
zone
;
}
template
<
typename
T
>
MOZ_ALWAYS_INLINE
void
ReadBarrier
(
T
*
thing
)
{
static_assert
(
std
:
:
is_base_of_v
<
Cell
T
>
)
;
static_assert
(
!
std
:
:
is_same_v
<
Cell
T
>
&
&
!
std
:
:
is_same_v
<
TenuredCell
T
>
)
;
if
(
thing
&
&
!
thing
-
>
isPermanentAndMayBeShared
(
)
)
{
ReadBarrierImpl
(
thing
)
;
}
}
MOZ_ALWAYS_INLINE
void
ReadBarrierImpl
(
TenuredCell
*
thing
)
{
MOZ_ASSERT
(
!
CurrentThreadIsIonCompiling
(
)
)
;
MOZ_ASSERT
(
!
CurrentThreadIsGCMarking
(
)
)
;
MOZ_ASSERT
(
thing
)
;
MOZ_ASSERT
(
CurrentThreadCanAccessZone
(
thing
-
>
zoneFromAnyThread
(
)
)
)
;
mozilla
:
:
DebugOnly
<
JSRuntime
*
>
runtime
=
thing
-
>
runtimeFromAnyThread
(
)
;
MOZ_ASSERT_IF
(
CurrentThreadCanAccessRuntime
(
runtime
)
!
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
JS
:
:
shadow
:
:
Zone
*
shadowZone
=
thing
-
>
shadowZoneFromAnyThread
(
)
;
if
(
shadowZone
-
>
needsIncrementalBarrier
(
)
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime
)
)
;
PerformIncrementalBarrier
(
thing
)
;
return
;
}
if
(
thing
-
>
isMarkedGray
(
)
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime
)
)
;
UnmarkGrayGCThingRecursively
(
thing
)
;
}
}
MOZ_ALWAYS_INLINE
void
ReadBarrierImpl
(
Cell
*
thing
)
{
MOZ_ASSERT
(
!
CurrentThreadIsGCMarking
(
)
)
;
if
(
thing
-
>
isTenured
(
)
)
{
ReadBarrierImpl
(
&
thing
-
>
asTenured
(
)
)
;
}
}
MOZ_ALWAYS_INLINE
void
PreWriteBarrierImpl
(
TenuredCell
*
thing
)
{
MOZ_ASSERT
(
!
CurrentThreadIsIonCompiling
(
)
)
;
MOZ_ASSERT
(
!
CurrentThreadIsGCMarking
(
)
)
;
if
(
!
thing
)
{
return
;
}
JS
:
:
shadow
:
:
Zone
*
zone
=
thing
-
>
shadowZoneFromAnyThread
(
)
;
if
(
!
zone
-
>
needsIncrementalBarrier
(
)
)
{
return
;
}
bool
checkThread
=
zone
-
>
isAtomsZone
(
)
;
#
ifdef
JS_GC_ZEAL
checkThread
=
checkThread
|
|
zone
-
>
isSelfHostingZone
(
)
;
#
endif
JSRuntime
*
runtime
=
thing
-
>
runtimeFromAnyThread
(
)
;
if
(
checkThread
&
&
!
CurrentThreadCanAccessRuntime
(
runtime
)
)
{
MOZ_ASSERT
(
CurrentThreadIsGCFinalizing
(
)
|
|
RuntimeIsVerifyingPreBarriers
(
runtime
)
)
;
return
;
}
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime
)
)
;
MOZ_ASSERT
(
!
RuntimeFromMainThreadIsHeapMajorCollecting
(
zone
)
)
;
PerformIncrementalBarrier
(
thing
)
;
}
MOZ_ALWAYS_INLINE
void
PreWriteBarrierImpl
(
Cell
*
thing
)
{
MOZ_ASSERT
(
!
CurrentThreadIsGCMarking
(
)
)
;
if
(
thing
&
&
thing
-
>
isTenured
(
)
)
{
PreWriteBarrierImpl
(
&
thing
-
>
asTenured
(
)
)
;
}
}
template
<
typename
T
>
MOZ_ALWAYS_INLINE
void
PreWriteBarrier
(
T
*
thing
)
{
static_assert
(
std
:
:
is_base_of_v
<
Cell
T
>
)
;
static_assert
(
!
std
:
:
is_same_v
<
Cell
T
>
&
&
!
std
:
:
is_same_v
<
TenuredCell
T
>
)
;
if
(
thing
&
&
!
thing
-
>
isPermanentAndMayBeShared
(
)
)
{
PreWriteBarrierImpl
(
thing
)
;
}
}
template
<
typename
T
typename
F
>
MOZ_ALWAYS_INLINE
void
PreWriteBarrier
(
JS
:
:
Zone
*
zone
T
*
data
const
F
&
traceFn
)
{
MOZ_ASSERT
(
!
CurrentThreadIsIonCompiling
(
)
)
;
MOZ_ASSERT
(
!
CurrentThreadIsGCMarking
(
)
)
;
auto
*
shadowZone
=
JS
:
:
shadow
:
:
Zone
:
:
from
(
zone
)
;
if
(
!
shadowZone
-
>
needsIncrementalBarrier
(
)
)
{
return
;
}
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
shadowZone
-
>
runtimeFromAnyThread
(
)
)
)
;
MOZ_ASSERT
(
!
RuntimeFromMainThreadIsHeapMajorCollecting
(
shadowZone
)
)
;
traceFn
(
shadowZone
-
>
barrierTracer
(
)
data
)
;
}
template
<
typename
T
>
MOZ_ALWAYS_INLINE
void
PreWriteBarrier
(
JS
:
:
Zone
*
zone
T
*
data
)
{
PreWriteBarrier
(
zone
data
[
]
(
JSTracer
*
trc
T
*
data
)
{
data
-
>
trace
(
trc
)
;
}
)
;
}
#
ifdef
DEBUG
void
Cell
:
:
assertThingIsNotGray
(
Cell
*
cell
)
{
JS
:
:
AssertCellIsNotGray
(
cell
)
;
}
bool
Cell
:
:
isAligned
(
)
const
{
if
(
!
isTenured
(
)
)
{
return
true
;
}
return
asTenured
(
)
.
isAligned
(
)
;
}
bool
TenuredCell
:
:
isAligned
(
)
const
{
return
Arena
:
:
isAligned
(
address
(
)
arena
(
)
-
>
getThingSize
(
)
)
;
}
#
endif
class
alignas
(
gc
:
:
CellAlignBytes
)
CellWithLengthAndFlags
:
public
Cell
{
#
if
JS_BITS_PER_WORD
=
=
32
uint32_t
length_
;
#
endif
protected
:
uint32_t
headerLengthField
(
)
const
{
#
if
JS_BITS_PER_WORD
=
=
32
return
length_
;
#
else
return
uint32_t
(
header_
>
>
32
)
;
#
endif
}
uint32_t
headerFlagsField
(
)
const
{
return
uint32_t
(
header_
)
;
}
void
setHeaderFlagBit
(
uint32_t
flag
)
{
MOZ_ASSERT
(
(
flag
&
RESERVED_MASK
)
=
=
0
)
;
header_
|
=
uintptr_t
(
flag
)
;
}
void
clearHeaderFlagBit
(
uint32_t
flag
)
{
MOZ_ASSERT
(
(
flag
&
RESERVED_MASK
)
=
=
0
)
;
header_
&
=
~
uintptr_t
(
flag
)
;
}
void
toggleHeaderFlagBit
(
uint32_t
flag
)
{
MOZ_ASSERT
(
(
flag
&
RESERVED_MASK
)
=
=
0
)
;
header_
^
=
uintptr_t
(
flag
)
;
}
void
setHeaderLengthAndFlags
(
uint32_t
len
uint32_t
flags
)
{
MOZ_ASSERT
(
(
flags
&
RESERVED_MASK
)
=
=
0
)
;
#
if
JS_BITS_PER_WORD
=
=
32
header_
=
flags
;
length_
=
len
;
#
else
header_
=
(
uint64_t
(
len
)
<
<
32
)
|
uint64_t
(
flags
)
;
#
endif
}
public
:
static
constexpr
size_t
offsetOfRawHeaderFlagsField
(
)
{
return
offsetof
(
CellWithLengthAndFlags
header_
)
;
}
#
if
JS_BITS_PER_WORD
=
=
32
static
constexpr
size_t
offsetOfHeaderFlags
(
)
{
return
offsetof
(
CellWithLengthAndFlags
header_
)
;
}
static
constexpr
size_t
offsetOfHeaderLength
(
)
{
return
offsetof
(
CellWithLengthAndFlags
length_
)
;
}
#
elif
MOZ_LITTLE_ENDIAN
(
)
static
constexpr
size_t
offsetOfHeaderFlags
(
)
{
return
offsetof
(
CellWithLengthAndFlags
header_
)
;
}
static
constexpr
size_t
offsetOfHeaderLength
(
)
{
return
offsetof
(
CellWithLengthAndFlags
header_
)
+
sizeof
(
uint32_t
)
;
}
#
else
static
constexpr
size_t
offsetOfHeaderFlags
(
)
{
return
offsetof
(
CellWithLengthAndFlags
header_
)
+
sizeof
(
uint32_t
)
;
}
static
constexpr
size_t
offsetOfHeaderLength
(
)
{
return
offsetof
(
CellWithLengthAndFlags
header_
)
;
}
#
endif
}
;
template
<
class
PtrT
>
class
alignas
(
gc
:
:
CellAlignBytes
)
TenuredCellWithNonGCPointer
:
public
TenuredCell
{
static_assert
(
!
std
:
:
is_pointer_v
<
PtrT
>
"
PtrT
should
be
the
type
of
the
referent
not
of
the
pointer
"
)
;
static_assert
(
!
std
:
:
is_base_of_v
<
Cell
PtrT
>
"
Don
'
t
use
TenuredCellWithNonGCPointer
for
pointers
to
GC
things
"
)
;
protected
:
TenuredCellWithNonGCPointer
(
)
=
default
;
explicit
TenuredCellWithNonGCPointer
(
PtrT
*
initial
)
{
uintptr_t
data
=
uintptr_t
(
initial
)
;
MOZ_ASSERT
(
(
data
&
RESERVED_MASK
)
=
=
0
)
;
header_
=
data
;
}
PtrT
*
headerPtr
(
)
const
{
MOZ_ASSERT
(
flags
(
)
=
=
0
)
;
return
reinterpret_cast
<
PtrT
*
>
(
uintptr_t
(
header_
)
)
;
}
void
setHeaderPtr
(
PtrT
*
newValue
)
{
uintptr_t
data
=
uintptr_t
(
newValue
)
;
MOZ_ASSERT
(
flags
(
)
=
=
0
)
;
MOZ_ASSERT
(
(
data
&
RESERVED_MASK
)
=
=
0
)
;
header_
=
data
;
}
public
:
static
constexpr
size_t
offsetOfHeaderPtr
(
)
{
return
offsetof
(
TenuredCellWithNonGCPointer
header_
)
;
}
}
;
class
alignas
(
gc
:
:
CellAlignBytes
)
TenuredCellWithFlags
:
public
TenuredCell
{
protected
:
TenuredCellWithFlags
(
)
=
default
;
explicit
TenuredCellWithFlags
(
uintptr_t
initial
)
{
MOZ_ASSERT
(
(
initial
&
RESERVED_MASK
)
=
=
0
)
;
header_
=
initial
;
}
uintptr_t
headerFlagsField
(
)
const
{
MOZ_ASSERT
(
flags
(
)
=
=
0
)
;
return
header_
;
}
void
setHeaderFlagBits
(
uintptr_t
flags
)
{
MOZ_ASSERT
(
(
flags
&
RESERVED_MASK
)
=
=
0
)
;
header_
|
=
flags
;
}
void
clearHeaderFlagBits
(
uintptr_t
flags
)
{
MOZ_ASSERT
(
(
flags
&
RESERVED_MASK
)
=
=
0
)
;
header_
&
=
~
flags
;
}
}
;
template
<
class
BaseCell
class
PtrT
>
class
alignas
(
gc
:
:
CellAlignBytes
)
CellWithTenuredGCPointer
:
public
BaseCell
{
static
void
staticAsserts
(
)
{
static_assert
(
std
:
:
is_same_v
<
BaseCell
Cell
>
|
|
std
:
:
is_same_v
<
BaseCell
TenuredCell
>
"
BaseCell
must
be
either
Cell
or
TenuredCell
"
)
;
static_assert
(
!
std
:
:
is_pointer_v
<
PtrT
>
"
PtrT
should
be
the
type
of
the
referent
not
of
the
pointer
"
)
;
static_assert
(
std
:
:
is_base_of_v
<
Cell
PtrT
>
"
Only
use
CellWithTenuredGCPointer
for
pointers
to
GC
things
"
)
;
}
protected
:
CellWithTenuredGCPointer
(
)
=
default
;
explicit
CellWithTenuredGCPointer
(
PtrT
*
initial
)
{
initHeaderPtr
(
initial
)
;
}
void
initHeaderPtr
(
PtrT
*
initial
)
{
MOZ_ASSERT
(
!
IsInsideNursery
(
initial
)
)
;
uintptr_t
data
=
uintptr_t
(
initial
)
;
MOZ_ASSERT
(
(
data
&
Cell
:
:
RESERVED_MASK
)
=
=
0
)
;
this
-
>
header_
=
data
;
}
void
setHeaderPtr
(
PtrT
*
newValue
)
{
MOZ_ASSERT
(
!
IsInsideNursery
(
newValue
)
)
;
PreWriteBarrier
(
headerPtr
(
)
)
;
unbarrieredSetHeaderPtr
(
newValue
)
;
}
public
:
PtrT
*
headerPtr
(
)
const
{
staticAsserts
(
)
;
MOZ_ASSERT
(
this
-
>
flags
(
)
=
=
0
)
;
return
reinterpret_cast
<
PtrT
*
>
(
uintptr_t
(
this
-
>
header_
)
)
;
}
void
unbarrieredSetHeaderPtr
(
PtrT
*
newValue
)
{
uintptr_t
data
=
uintptr_t
(
newValue
)
;
MOZ_ASSERT
(
this
-
>
flags
(
)
=
=
0
)
;
MOZ_ASSERT
(
(
data
&
Cell
:
:
RESERVED_MASK
)
=
=
0
)
;
this
-
>
header_
=
data
;
}
static
constexpr
size_t
offsetOfHeaderPtr
(
)
{
return
offsetof
(
CellWithTenuredGCPointer
header_
)
;
}
}
;
void
CellHeaderPostWriteBarrier
(
JSObject
*
*
ptr
JSObject
*
prev
JSObject
*
next
)
;
template
<
class
PtrT
>
class
alignas
(
gc
:
:
CellAlignBytes
)
TenuredCellWithGCPointer
:
public
TenuredCell
{
static
void
staticAsserts
(
)
{
static_assert
(
!
std
:
:
is_pointer_v
<
PtrT
>
"
PtrT
should
be
the
type
of
the
referent
not
of
the
pointer
"
)
;
static_assert
(
std
:
:
is_base_of_v
<
Cell
PtrT
>
"
Only
use
TenuredCellWithGCPointer
for
pointers
to
GC
things
"
)
;
static_assert
(
!
std
:
:
is_base_of_v
<
TenuredCell
PtrT
>
"
Don
'
t
use
TenuredCellWithGCPointer
for
always
-
tenured
GC
things
"
)
;
}
protected
:
TenuredCellWithGCPointer
(
)
=
default
;
explicit
TenuredCellWithGCPointer
(
PtrT
*
initial
)
{
initHeaderPtr
(
initial
)
;
}
void
initHeaderPtr
(
PtrT
*
initial
)
{
uintptr_t
data
=
uintptr_t
(
initial
)
;
MOZ_ASSERT
(
(
data
&
Cell
:
:
RESERVED_MASK
)
=
=
0
)
;
this
-
>
header_
=
data
;
if
(
IsInsideNursery
(
initial
)
)
{
CellHeaderPostWriteBarrier
(
headerPtrAddress
(
)
nullptr
initial
)
;
}
}
PtrT
*
*
headerPtrAddress
(
)
{
MOZ_ASSERT
(
this
-
>
flags
(
)
=
=
0
)
;
return
reinterpret_cast
<
PtrT
*
*
>
(
&
this
-
>
header_
)
;
}
public
:
PtrT
*
headerPtr
(
)
const
{
MOZ_ASSERT
(
this
-
>
flags
(
)
=
=
0
)
;
return
reinterpret_cast
<
PtrT
*
>
(
uintptr_t
(
this
-
>
header_
)
)
;
}
void
unbarrieredSetHeaderPtr
(
PtrT
*
newValue
)
{
uintptr_t
data
=
uintptr_t
(
newValue
)
;
MOZ_ASSERT
(
this
-
>
flags
(
)
=
=
0
)
;
MOZ_ASSERT
(
(
data
&
Cell
:
:
RESERVED_MASK
)
=
=
0
)
;
this
-
>
header_
=
data
;
}
static
constexpr
size_t
offsetOfHeaderPtr
(
)
{
return
offsetof
(
TenuredCellWithGCPointer
header_
)
;
}
}
;
}
}
#
endif
