#
ifndef
gc_Allocator_inl_h
#
define
gc_Allocator_inl_h
#
include
"
gc
/
Allocator
.
h
"
#
include
"
gc
/
Cell
.
h
"
#
include
"
gc
/
Nursery
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
namespace
js
{
namespace
gc
{
template
<
typename
T
AllowGC
allowGC
typename
.
.
.
Args
>
T
*
CellAllocator
:
:
NewCell
(
JS
:
:
RootingContext
*
rcx
Args
&
&
.
.
.
args
)
{
static_assert
(
std
:
:
is_base_of_v
<
gc
:
:
Cell
T
>
)
;
if
constexpr
(
std
:
:
is_base_of_v
<
JSObject
T
>
)
{
return
NewObject
<
T
allowGC
>
(
rcx
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
else
if
constexpr
(
std
:
:
is_base_of_v
<
JS
:
:
BigInt
T
>
)
{
return
NewBigInt
<
T
allowGC
>
(
rcx
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
else
if
constexpr
(
std
:
:
is_base_of_v
<
JSString
T
>
&
&
!
std
:
:
is_base_of_v
<
JSAtom
T
>
&
&
!
std
:
:
is_base_of_v
<
JSExternalString
T
>
)
{
return
NewString
<
T
allowGC
>
(
rcx
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
else
{
return
NewTenuredCell
<
T
allowGC
>
(
rcx
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
template
<
typename
T
AllowGC
allowGC
typename
.
.
.
Args
>
T
*
CellAllocator
:
:
NewString
(
JS
:
:
RootingContext
*
rcx
gc
:
:
Heap
heap
Args
&
&
.
.
.
args
)
{
static_assert
(
std
:
:
is_base_of_v
<
JSString
T
>
)
;
gc
:
:
AllocKind
kind
=
gc
:
:
MapTypeToAllocKind
<
T
>
:
:
kind
;
void
*
ptr
=
AllocNurseryOrTenuredCell
<
JS
:
:
TraceKind
:
:
String
allowGC
>
(
rcx
kind
sizeof
(
T
)
heap
nullptr
)
;
if
(
MOZ_UNLIKELY
(
!
ptr
)
)
{
return
nullptr
;
}
return
new
(
mozilla
:
:
KnownNotNull
ptr
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
AllowGC
allowGC
>
T
*
CellAllocator
:
:
NewBigInt
(
JS
:
:
RootingContext
*
rcx
Heap
heap
)
{
void
*
ptr
=
AllocNurseryOrTenuredCell
<
JS
:
:
TraceKind
:
:
BigInt
allowGC
>
(
rcx
gc
:
:
AllocKind
:
:
BIGINT
sizeof
(
T
)
heap
nullptr
)
;
if
(
MOZ_UNLIKELY
(
!
ptr
)
)
{
return
nullptr
;
}
return
new
(
mozilla
:
:
KnownNotNull
ptr
)
T
(
)
;
}
template
<
typename
T
AllowGC
allowGC
>
T
*
CellAllocator
:
:
NewObject
(
JS
:
:
RootingContext
*
rcx
gc
:
:
AllocKind
kind
gc
:
:
Heap
heap
const
JSClass
*
clasp
gc
:
:
AllocSite
*
site
)
{
MOZ_ASSERT
(
IsObjectAllocKind
(
kind
)
)
;
MOZ_ASSERT_IF
(
heap
!
=
gc
:
:
Heap
:
:
Tenured
&
&
clasp
-
>
hasFinalize
(
)
&
&
!
clasp
-
>
isProxyObject
(
)
CanNurseryAllocateFinalizedClass
(
clasp
)
)
;
size_t
thingSize
=
JSObject
:
:
thingSize
(
kind
)
;
void
*
cell
=
AllocNurseryOrTenuredCell
<
JS
:
:
TraceKind
:
:
Object
allowGC
>
(
rcx
kind
thingSize
heap
site
)
;
if
(
MOZ_UNLIKELY
(
!
cell
)
)
{
return
nullptr
;
}
return
new
(
mozilla
:
:
KnownNotNull
cell
)
T
(
)
;
}
template
<
JS
:
:
TraceKind
traceKind
AllowGC
allowGC
>
void
*
CellAllocator
:
:
AllocNurseryOrTenuredCell
(
JS
:
:
RootingContext
*
rcx
gc
:
:
AllocKind
allocKind
size_t
thingSize
gc
:
:
Heap
heap
AllocSite
*
site
)
{
MOZ_ASSERT
(
IsNurseryAllocable
(
allocKind
)
)
;
MOZ_ASSERT
(
MapAllocToTraceKind
(
allocKind
)
=
=
traceKind
)
;
MOZ_ASSERT
(
thingSize
=
=
Arena
:
:
thingSize
(
allocKind
)
)
;
MOZ_ASSERT_IF
(
site
&
&
site
-
>
initialHeap
(
)
=
=
Heap
:
:
Tenured
heap
=
=
Heap
:
:
Tenured
)
;
if
(
!
PreAllocChecks
<
allowGC
>
(
rcx
allocKind
)
)
{
return
nullptr
;
}
JS
:
:
Zone
*
zone
=
rcx
-
>
zoneUnchecked
(
)
;
gc
:
:
Heap
minHeapToTenure
=
CheckedHeap
(
zone
-
>
minHeapToTenure
(
traceKind
)
)
;
if
(
CheckedHeap
(
heap
)
<
minHeapToTenure
)
{
if
(
!
site
)
{
site
=
zone
-
>
unknownAllocSite
(
traceKind
)
;
}
void
*
ptr
=
rcx
-
>
nursery
(
)
.
tryAllocateCell
(
site
thingSize
traceKind
)
;
if
(
MOZ_LIKELY
(
ptr
)
)
{
return
ptr
;
}
return
RetryNurseryAlloc
<
allowGC
>
(
rcx
traceKind
allocKind
thingSize
site
)
;
}
return
TryNewTenuredCell
<
allowGC
>
(
rcx
allocKind
thingSize
)
;
}
MOZ_ALWAYS_INLINE
gc
:
:
Heap
CellAllocator
:
:
CheckedHeap
(
gc
:
:
Heap
heap
)
{
if
(
heap
>
Heap
:
:
Tenured
)
{
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Bad
gc
:
:
Heap
value
"
)
;
}
return
heap
;
}
template
<
typename
T
AllowGC
allowGC
typename
.
.
.
Args
>
T
*
CellAllocator
:
:
NewTenuredCell
(
JS
:
:
RootingContext
*
rcx
Args
&
&
.
.
.
args
)
{
gc
:
:
AllocKind
kind
=
gc
:
:
MapTypeToAllocKind
<
T
>
:
:
kind
;
void
*
cell
=
AllocTenuredCell
<
allowGC
>
(
rcx
kind
sizeof
(
T
)
)
;
if
(
MOZ_UNLIKELY
(
!
cell
)
)
{
return
nullptr
;
}
return
new
(
mozilla
:
:
KnownNotNull
cell
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
}
#
endif
