#
ifndef
gc_Allocator_h
#
define
gc_Allocator_h
#
include
<
stddef
.
h
>
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
js
{
namespace
gc
{
class
AllocSite
;
struct
Cell
;
class
TenuredCell
;
}
enum
AllowGC
{
NoGC
=
0
CanGC
=
1
}
;
template
<
AllowGC
allowGC
=
CanGC
>
gc
:
:
TenuredCell
*
AllocateTenuredImpl
(
JSContext
*
cx
gc
:
:
AllocKind
kind
size_t
size
)
;
template
<
AllowGC
allowGC
=
CanGC
>
gc
:
:
Cell
*
AllocateStringCell
(
JSContext
*
cx
gc
:
:
AllocKind
kind
size_t
size
gc
:
:
InitialHeap
heap
)
;
template
<
typename
T
AllowGC
allowGC
=
CanGC
>
T
*
Allocate
(
JSContext
*
cx
)
{
static_assert
(
std
:
:
is_base_of_v
<
gc
:
:
Cell
T
>
)
;
gc
:
:
AllocKind
kind
=
gc
:
:
MapTypeToAllocKind
<
T
>
:
:
kind
;
gc
:
:
Cell
*
cell
=
AllocateTenuredImpl
<
allowGC
>
(
cx
kind
sizeof
(
T
)
)
;
return
static_cast
<
T
*
>
(
cell
)
;
}
template
<
AllowGC
allowGC
=
CanGC
>
JSObject
*
AllocateObject
(
JSContext
*
cx
gc
:
:
AllocKind
kind
size_t
nDynamicSlots
gc
:
:
InitialHeap
heap
const
JSClass
*
clasp
gc
:
:
AllocSite
*
site
=
nullptr
)
;
template
<
typename
StringT
AllowGC
allowGC
=
CanGC
>
StringT
*
AllocateString
(
JSContext
*
cx
gc
:
:
InitialHeap
heap
)
{
static_assert
(
std
:
:
is_base_of_v
<
JSString
StringT
>
)
;
gc
:
:
AllocKind
kind
=
gc
:
:
MapTypeToAllocKind
<
StringT
>
:
:
kind
;
gc
:
:
Cell
*
cell
=
AllocateStringCell
<
allowGC
>
(
cx
kind
sizeof
(
StringT
)
heap
)
;
if
(
!
cell
)
{
return
nullptr
;
}
return
StringT
:
:
emplace
(
cell
)
;
}
template
<
AllowGC
allowGC
=
CanGC
>
JS
:
:
BigInt
*
AllocateBigInt
(
JSContext
*
cx
gc
:
:
InitialHeap
heap
)
;
}
#
endif
