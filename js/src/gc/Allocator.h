#
ifndef
gc_Allocator_h
#
define
gc_Allocator_h
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
<
stdint
.
h
>
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
gc
/
Cell
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
js
{
enum
AllowGC
{
NoGC
=
0
CanGC
=
1
}
;
namespace
gc
{
class
AllocSite
;
struct
Cell
;
class
TenuredCell
;
class
CellAllocator
{
public
:
template
<
typename
T
js
:
:
AllowGC
allowGC
=
CanGC
typename
.
.
.
Args
>
static
T
*
NewCell
(
JSContext
*
cx
Args
&
&
.
.
.
args
)
;
private
:
template
<
JS
:
:
TraceKind
traceKind
AllowGC
allowGC
=
CanGC
>
static
void
*
AllocateNurseryOrTenuredCell
(
JSContext
*
cx
gc
:
:
AllocKind
allocKind
gc
:
:
InitialHeap
heap
AllocSite
*
site
)
;
template
<
AllowGC
allowGC
=
CanGC
>
static
void
*
AllocateTenuredCell
(
JSContext
*
cx
gc
:
:
AllocKind
kind
size_t
size
)
;
template
<
typename
T
AllowGC
allowGC
=
CanGC
typename
.
.
.
Args
>
static
T
*
AllocateString
(
JSContext
*
cx
gc
:
:
InitialHeap
heap
Args
&
&
.
.
.
args
)
{
static_assert
(
std
:
:
is_base_of_v
<
JSString
T
>
)
;
gc
:
:
AllocKind
kind
=
gc
:
:
MapTypeToAllocKind
<
T
>
:
:
kind
;
void
*
ptr
=
AllocateNurseryOrTenuredCell
<
JS
:
:
TraceKind
:
:
String
allowGC
>
(
cx
kind
heap
nullptr
)
;
if
(
!
ptr
)
{
return
nullptr
;
}
return
new
(
mozilla
:
:
KnownNotNull
ptr
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
T
AllowGC
allowGC
>
static
T
*
AllocateBigInt
(
JSContext
*
cx
InitialHeap
heap
)
{
void
*
ptr
=
AllocateNurseryOrTenuredCell
<
JS
:
:
TraceKind
:
:
BigInt
allowGC
>
(
cx
gc
:
:
AllocKind
:
:
BIGINT
heap
nullptr
)
;
if
(
ptr
)
{
return
new
(
mozilla
:
:
KnownNotNull
ptr
)
T
(
)
;
}
return
nullptr
;
}
template
<
typename
T
AllowGC
allowGC
=
CanGC
>
static
T
*
AllocateObject
(
JSContext
*
cx
gc
:
:
AllocKind
kind
gc
:
:
InitialHeap
heap
const
JSClass
*
clasp
gc
:
:
AllocSite
*
site
=
nullptr
)
{
MOZ_ASSERT
(
IsObjectAllocKind
(
kind
)
)
;
MOZ_ASSERT_IF
(
heap
!
=
gc
:
:
TenuredHeap
&
&
clasp
-
>
hasFinalize
(
)
&
&
!
clasp
-
>
isProxyObject
(
)
CanNurseryAllocateFinalizedClass
(
clasp
)
)
;
void
*
cell
=
AllocateNurseryOrTenuredCell
<
JS
:
:
TraceKind
:
:
Object
allowGC
>
(
cx
kind
heap
site
)
;
if
(
!
cell
)
{
return
nullptr
;
}
return
new
(
mozilla
:
:
KnownNotNull
cell
)
T
(
)
;
}
template
<
typename
T
AllowGC
allowGC
=
CanGC
typename
.
.
.
Args
>
static
T
*
AllocateTenured
(
JSContext
*
cx
Args
&
&
.
.
.
args
)
{
gc
:
:
AllocKind
kind
=
gc
:
:
MapTypeToAllocKind
<
T
>
:
:
kind
;
void
*
cell
=
AllocateTenuredCell
<
allowGC
>
(
cx
kind
sizeof
(
T
)
)
;
if
(
!
cell
)
{
return
nullptr
;
}
return
new
(
mozilla
:
:
KnownNotNull
cell
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
;
}
template
<
typename
T
AllowGC
allowGC
typename
.
.
.
Args
>
T
*
gc
:
:
CellAllocator
:
:
NewCell
(
JSContext
*
cx
Args
&
&
.
.
.
args
)
{
static_assert
(
std
:
:
is_base_of_v
<
gc
:
:
Cell
T
>
)
;
if
constexpr
(
std
:
:
is_base_of_v
<
JSObject
T
>
)
{
return
AllocateObject
<
T
allowGC
>
(
cx
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
else
if
constexpr
(
std
:
:
is_base_of_v
<
JS
:
:
BigInt
T
>
)
{
return
AllocateBigInt
<
T
allowGC
>
(
cx
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
else
if
constexpr
(
std
:
:
is_base_of_v
<
JSString
T
>
&
&
!
std
:
:
is_base_of_v
<
JSAtom
T
>
&
&
!
std
:
:
is_base_of_v
<
JSExternalString
T
>
)
{
return
AllocateString
<
T
allowGC
>
(
cx
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
else
{
return
AllocateTenured
<
T
allowGC
>
(
cx
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
}
#
endif
