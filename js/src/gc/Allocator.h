#
ifndef
gc_Allocator_h
#
define
gc_Allocator_h
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
<
stdint
.
h
>
#
include
"
gc
/
AllocKind
.
h
"
#
include
"
gc
/
GCEnum
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
js
{
namespace
gc
{
class
AllocSite
;
struct
Cell
;
class
BufferAllocator
;
class
TenuredCell
;
class
TenuringTracer
;
class
CellAllocator
{
public
:
template
<
typename
T
AllowGC
allowGC
=
CanGC
typename
.
.
.
Args
>
static
inline
T
*
NewCell
(
JSContext
*
cx
Args
&
&
.
.
.
args
)
;
friend
class
BufferAllocator
;
private
:
template
<
typename
T
AllowGC
allowGC
typename
.
.
.
Args
>
static
T
*
NewString
(
JSContext
*
cx
Heap
heap
Args
&
&
.
.
.
args
)
;
template
<
typename
T
AllowGC
allowGC
>
static
T
*
NewBigInt
(
JSContext
*
cx
Heap
heap
)
;
template
<
typename
T
AllowGC
allowGC
>
static
T
*
NewObject
(
JSContext
*
cx
AllocKind
kind
Heap
heap
const
JSClass
*
clasp
AllocSite
*
site
=
nullptr
)
;
template
<
typename
T
AllowGC
allowGC
typename
.
.
.
Args
>
static
T
*
NewTenuredCell
(
JSContext
*
cx
Args
&
&
.
.
.
args
)
;
template
<
JS
:
:
TraceKind
traceKind
AllowGC
allowGC
>
static
void
*
AllocNurseryOrTenuredCell
(
JSContext
*
cx
AllocKind
allocKind
size_t
thingSize
Heap
heap
AllocSite
*
site
)
;
friend
class
TenuringTracer
;
template
<
AllowGC
allowGC
>
static
void
*
RetryNurseryAlloc
(
JSContext
*
cx
JS
:
:
TraceKind
traceKind
AllocKind
allocKind
size_t
thingSize
AllocSite
*
site
)
;
template
<
AllowGC
allowGC
>
static
void
*
AllocTenuredCellForNurseryAlloc
(
JSContext
*
cx
AllocKind
kind
)
;
template
<
AllowGC
allowGC
>
static
void
*
AllocTenuredCell
(
JSContext
*
cx
AllocKind
kind
)
;
template
<
AllowGC
allowGC
>
static
void
*
AllocTenuredCellUnchecked
(
JS
:
:
Zone
*
zone
AllocKind
kind
)
;
static
void
*
RetryTenuredAlloc
(
JS
:
:
Zone
*
zone
AllocKind
kind
)
;
#
ifdef
JS_GC_ZEAL
static
AllocSite
*
MaybeGenerateMissingAllocSite
(
JSContext
*
cx
JS
:
:
TraceKind
traceKind
AllocSite
*
site
)
;
#
endif
#
ifdef
DEBUG
static
void
CheckIncrementalZoneState
(
JS
:
:
Zone
*
zone
void
*
ptr
)
;
#
endif
static
inline
Heap
CheckedHeap
(
Heap
heap
)
;
}
;
size_t
GetGoodAllocSize
(
size_t
requiredBytes
)
;
size_t
GetGoodPower2AllocSize
(
size_t
requiredBytes
)
;
size_t
GetGoodElementCount
(
size_t
requiredCount
size_t
elementSize
)
;
size_t
GetGoodPower2ElementCount
(
size_t
requiredCount
size_t
elementSize
)
;
void
*
AllocBuffer
(
JS
:
:
Zone
*
zone
size_t
bytes
bool
nurseryOwned
)
;
void
*
ReallocBuffer
(
JS
:
:
Zone
*
zone
void
*
alloc
size_t
oldBytes
size_t
newBytes
bool
nurseryOwned
)
;
void
FreeBuffer
(
JS
:
:
Zone
*
zone
void
*
alloc
)
;
bool
IsBufferAlloc
(
void
*
alloc
)
;
bool
IsNurseryOwned
(
JS
:
:
Zone
*
zone
void
*
alloc
)
;
size_t
GetAllocSize
(
JS
:
:
Zone
*
zone
void
*
alloc
)
;
void
*
AllocBufferInGC
(
JS
:
:
Zone
*
zone
size_t
bytes
bool
nurseryOwned
)
;
bool
IsBufferAllocMarkedBlack
(
JS
:
:
Zone
*
zone
void
*
alloc
)
;
void
TraceBufferEdgeInternal
(
JSTracer
*
trc
Cell
*
owner
void
*
*
bufferp
const
char
*
name
)
;
void
MarkTenuredBuffer
(
JS
:
:
Zone
*
zone
void
*
alloc
)
;
}
}
#
endif
