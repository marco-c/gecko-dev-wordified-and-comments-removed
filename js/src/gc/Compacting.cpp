#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
debugger
/
DebugAPI
.
h
"
#
include
"
gc
/
ArenaList
.
h
"
#
include
"
gc
/
GCInternals
.
h
"
#
include
"
gc
/
GCLock
.
h
"
#
include
"
gc
/
ParallelWork
.
h
"
#
include
"
gc
/
Zone
.
h
"
#
include
"
jit
/
JitCode
.
h
"
#
include
"
jit
/
JitRuntime
.
h
"
#
include
"
jit
/
JitZone
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
vm
/
HelperThreads
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
wasm
/
WasmGcObject
.
h
"
#
include
"
gc
/
Heap
-
inl
.
h
"
#
include
"
gc
/
Marking
-
inl
.
h
"
#
include
"
gc
/
PrivateIterators
-
inl
.
h
"
#
include
"
gc
/
StableCellHasher
-
inl
.
h
"
#
include
"
gc
/
TraceMethods
-
inl
.
h
"
#
include
"
vm
/
GeckoProfiler
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
mozilla
:
:
Maybe
;
using
JS
:
:
SliceBudget
;
bool
GCRuntime
:
:
canRelocateZone
(
Zone
*
zone
)
const
{
return
!
zone
-
>
isAtomsZone
(
)
;
}
void
GCRuntime
:
:
beginCompactPhase
(
)
{
MOZ_ASSERT
(
!
isBackgroundSweeping
(
)
)
;
assertBackgroundSweepingFinished
(
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
COMPACT
)
;
MOZ_ASSERT
(
zonesToMaybeCompact
.
ref
(
)
.
isEmpty
(
)
)
;
for
(
GCZonesIter
zone
(
this
)
;
!
zone
.
done
(
)
;
zone
.
next
(
)
)
{
if
(
canRelocateZone
(
zone
)
)
{
zonesToMaybeCompact
.
ref
(
)
.
append
(
zone
)
;
}
}
startedCompacting
=
true
;
zonesCompacted
=
0
;
#
ifdef
DEBUG
AutoLockGC
lock
(
this
)
;
MOZ_ASSERT
(
!
relocatedArenasToRelease
)
;
#
endif
}
IncrementalProgress
GCRuntime
:
:
compactPhase
(
JS
:
:
GCReason
reason
SliceBudget
&
sliceBudget
AutoGCSession
&
session
)
{
assertBackgroundSweepingFinished
(
)
;
MOZ_ASSERT
(
startedCompacting
)
;
AutoMajorGCProfilerEntry
s
(
this
)
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
COMPACT
)
;
AutoSuppressProfilerSampling
suppressSampling
(
rt
-
>
mainContextFromOwnThread
(
)
)
;
ZoneList
relocatedZones
;
Arena
*
relocatedArenas
=
nullptr
;
while
(
!
zonesToMaybeCompact
.
ref
(
)
.
isEmpty
(
)
)
{
Zone
*
zone
=
zonesToMaybeCompact
.
ref
(
)
.
front
(
)
;
zonesToMaybeCompact
.
ref
(
)
.
removeFront
(
)
;
MOZ_ASSERT
(
nursery
(
)
.
isEmpty
(
)
)
;
zone
-
>
changeGCState
(
Zone
:
:
Finished
Zone
:
:
Compact
)
;
if
(
relocateArenas
(
zone
reason
relocatedArenas
sliceBudget
)
)
{
updateZonePointersToRelocatedCells
(
zone
)
;
relocatedZones
.
append
(
zone
)
;
zonesCompacted
+
+
;
}
else
{
zone
-
>
changeGCState
(
Zone
:
:
Compact
Zone
:
:
Finished
)
;
}
if
(
sliceBudget
.
isOverBudget
(
)
)
{
break
;
}
}
if
(
!
relocatedZones
.
isEmpty
(
)
)
{
updateRuntimePointersToRelocatedCells
(
session
)
;
do
{
Zone
*
zone
=
relocatedZones
.
front
(
)
;
relocatedZones
.
removeFront
(
)
;
zone
-
>
changeGCState
(
Zone
:
:
Compact
Zone
:
:
Finished
)
;
}
while
(
!
relocatedZones
.
isEmpty
(
)
)
;
}
clearRelocatedArenas
(
relocatedArenas
reason
)
;
#
ifdef
DEBUG
protectOrReleaseRelocatedArenas
(
relocatedArenas
reason
)
;
#
else
releaseRelocatedArenas
(
relocatedArenas
)
;
#
endif
rt
-
>
caches
(
)
.
purgeForCompaction
(
)
;
#
ifdef
DEBUG
checkHashTablesAfterMovingGC
(
)
;
#
endif
return
zonesToMaybeCompact
.
ref
(
)
.
isEmpty
(
)
?
Finished
:
NotFinished
;
}
void
GCRuntime
:
:
endCompactPhase
(
)
{
startedCompacting
=
false
;
}
static
bool
ShouldRelocateAllArenas
(
JS
:
:
GCReason
reason
)
{
return
reason
=
=
JS
:
:
GCReason
:
:
DEBUG_GC
;
}
std
:
:
pair
<
Arena
*
Arena
*
>
ArenaList
:
:
pickArenasToRelocate
(
AllocKind
kind
size_t
&
arenaTotalOut
size_t
&
relocTotalOut
)
{
if
(
!
hasNonFullArenas
(
)
)
{
return
{
nullptr
nullptr
}
;
}
size_t
fullArenaCount
=
0
;
size_t
nonFullArenaCount
=
0
;
size_t
totalUsedCells
=
0
;
Arena
*
lastNonFullArena
=
nullptr
;
Iterator
arena
=
iter
(
)
;
for
(
;
!
arena
.
done
(
)
;
arena
.
next
(
)
)
{
if
(
arena
-
>
isFull
(
)
)
{
break
;
}
MOZ_ASSERT
(
!
arena
-
>
isFull
(
)
)
;
nonFullArenaCount
+
+
;
totalUsedCells
+
=
arena
-
>
countUsedCells
(
)
;
lastNonFullArena
=
arena
.
get
(
)
;
}
for
(
;
!
arena
.
done
(
)
;
arena
.
next
(
)
)
{
fullArenaCount
+
+
;
}
size_t
previousFreeCells
=
0
;
size_t
followingUsedCells
=
totalUsedCells
;
size_t
relocCount
=
nonFullArenaCount
;
Arena
*
prev
=
nullptr
;
const
size_t
cellsPerArena
=
Arena
:
:
thingsPerArena
(
kind
)
;
for
(
arena
=
iter
(
)
;
prev
!
=
lastNonFullArena
;
prev
=
arena
.
get
(
)
arena
.
next
(
)
)
{
if
(
followingUsedCells
<
=
previousFreeCells
)
{
break
;
}
size_t
freeCells
=
arena
-
>
countFreeCells
(
)
;
MOZ_ASSERT
(
freeCells
!
=
0
)
;
size_t
usedCells
=
cellsPerArena
-
freeCells
;
followingUsedCells
-
=
usedCells
;
previousFreeCells
+
=
freeCells
;
MOZ_ASSERT
(
relocCount
!
=
0
)
;
relocCount
-
-
;
}
MOZ_ASSERT
(
(
relocCount
=
=
0
)
=
=
(
prev
=
=
lastNonFullArena
)
)
;
arenaTotalOut
+
=
fullArenaCount
+
nonFullArenaCount
;
relocTotalOut
+
=
relocCount
;
if
(
relocCount
=
=
0
)
{
return
{
nullptr
nullptr
}
;
}
return
{
prev
lastNonFullArena
}
;
}
#
ifdef
DEBUG
inline
bool
PtrIsInRange
(
const
void
*
ptr
const
void
*
start
size_t
length
)
{
return
uintptr_t
(
ptr
)
-
uintptr_t
(
start
)
<
length
;
}
#
endif
static
void
RelocateCell
(
Zone
*
zone
TenuredCell
*
src
AllocKind
thingKind
size_t
thingSize
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
MOZ_ASSERT
(
zone
=
=
src
-
>
zone
(
)
)
;
TenuredCell
*
dst
=
reinterpret_cast
<
TenuredCell
*
>
(
AllocateTenuredCellInGC
(
zone
thingKind
)
)
;
memcpy
(
dst
src
thingSize
)
;
gc
:
:
TransferUniqueId
(
dst
src
)
;
if
(
IsObjectAllocKind
(
thingKind
)
)
{
auto
*
srcObj
=
static_cast
<
JSObject
*
>
(
static_cast
<
Cell
*
>
(
src
)
)
;
auto
*
dstObj
=
static_cast
<
JSObject
*
>
(
static_cast
<
Cell
*
>
(
dst
)
)
;
if
(
srcObj
-
>
is
<
NativeObject
>
(
)
)
{
NativeObject
*
srcNative
=
&
srcObj
-
>
as
<
NativeObject
>
(
)
;
NativeObject
*
dstNative
=
&
dstObj
-
>
as
<
NativeObject
>
(
)
;
if
(
srcNative
-
>
hasFixedElements
(
)
)
{
uint32_t
numShifted
=
srcNative
-
>
getElementsHeader
(
)
-
>
numShiftedElements
(
)
;
dstNative
-
>
setFixedElements
(
numShifted
)
;
}
}
else
if
(
srcObj
-
>
is
<
ProxyObject
>
(
)
)
{
if
(
srcObj
-
>
as
<
ProxyObject
>
(
)
.
usingInlineValueArray
(
)
)
{
dstObj
-
>
as
<
ProxyObject
>
(
)
.
setInlineValueArray
(
)
;
}
}
if
(
JSObjectMovedOp
op
=
srcObj
-
>
getClass
(
)
-
>
extObjectMovedOp
(
)
)
{
op
(
dstObj
srcObj
)
;
}
MOZ_ASSERT_IF
(
dstObj
-
>
is
<
NativeObject
>
(
)
!
PtrIsInRange
(
(
const
Value
*
)
dstObj
-
>
as
<
NativeObject
>
(
)
.
getDenseElements
(
)
src
thingSize
)
)
;
}
dst
-
>
copyMarkBitsFrom
(
src
)
;
#
ifdef
DEBUG
bool
poison
=
true
;
if
(
IsObjectAllocKind
(
thingKind
)
)
{
JSObject
*
srcObj
=
static_cast
<
JSObject
*
>
(
static_cast
<
Cell
*
>
(
src
)
)
;
poison
=
!
(
srcObj
-
>
is
<
WasmArrayObject
>
(
)
&
&
srcObj
-
>
as
<
WasmArrayObject
>
(
)
.
isDataInline
(
)
)
;
}
if
(
poison
)
{
AlwaysPoison
(
reinterpret_cast
<
uint8_t
*
>
(
src
)
+
sizeof
(
uintptr_t
)
JS_MOVED_TENURED_PATTERN
thingSize
-
sizeof
(
uintptr_t
)
MemCheckKind
:
:
MakeNoAccess
)
;
}
#
endif
RelocationOverlay
:
:
forwardCell
(
src
dst
)
;
}
static
void
RelocateArena
(
Arena
*
arena
SliceBudget
&
sliceBudget
)
{
MOZ_ASSERT
(
arena
-
>
allocated
(
)
)
;
MOZ_ASSERT
(
!
arena
-
>
onDelayedMarkingList
(
)
)
;
MOZ_ASSERT
(
arena
-
>
bufferedCells
(
)
-
>
isEmpty
(
)
)
;
Zone
*
zone
=
arena
-
>
zone
(
)
;
AllocKind
thingKind
=
arena
-
>
getAllocKind
(
)
;
size_t
thingSize
=
arena
-
>
getThingSize
(
)
;
for
(
ArenaCellIterUnderGC
cell
(
arena
)
;
!
cell
.
done
(
)
;
cell
.
next
(
)
)
{
RelocateCell
(
zone
cell
thingKind
thingSize
)
;
sliceBudget
.
step
(
)
;
}
#
ifdef
DEBUG
for
(
ArenaCellIterUnderGC
cell
(
arena
)
;
!
cell
.
done
(
)
;
cell
.
next
(
)
)
{
TenuredCell
*
src
=
cell
;
MOZ_ASSERT
(
src
-
>
isForwarded
(
)
)
;
TenuredCell
*
dest
=
Forwarded
(
src
)
;
MOZ_ASSERT
(
src
-
>
isMarkedBlack
(
)
=
=
dest
-
>
isMarkedBlack
(
)
)
;
MOZ_ASSERT
(
src
-
>
isMarkedGray
(
)
=
=
dest
-
>
isMarkedGray
(
)
)
;
}
#
endif
}
Arena
*
ArenaList
:
:
relocateArenas
(
Arena
*
toRelocate
Arena
*
relocated
SliceBudget
&
sliceBudget
gcstats
:
:
Statistics
&
stats
)
{
while
(
Arena
*
arena
=
toRelocate
)
{
toRelocate
=
arena
-
>
next
;
RelocateArena
(
arena
sliceBudget
)
;
arena
-
>
next
=
relocated
;
relocated
=
arena
;
stats
.
count
(
gcstats
:
:
COUNT_ARENA_RELOCATED
)
;
}
return
relocated
;
}
static
const
double
MIN_ZONE_RECLAIM_PERCENT
=
2
.
0
;
static
bool
ShouldRelocateZone
(
size_t
arenaCount
size_t
relocCount
JS
:
:
GCReason
reason
)
{
if
(
relocCount
=
=
0
)
{
return
false
;
}
if
(
IsOOMReason
(
reason
)
)
{
return
true
;
}
double
relocFraction
=
double
(
relocCount
)
/
double
(
arenaCount
)
;
return
relocFraction
*
100
.
0
>
=
MIN_ZONE_RECLAIM_PERCENT
;
}
static
AllocKinds
CompactingAllocKinds
(
)
{
AllocKinds
result
;
for
(
AllocKind
kind
:
AllAllocKinds
(
)
)
{
if
(
IsCompactingKind
(
kind
)
)
{
result
+
=
kind
;
}
}
return
result
;
}
bool
ArenaLists
:
:
relocateArenas
(
Arena
*
&
relocatedListOut
JS
:
:
GCReason
reason
SliceBudget
&
sliceBudget
gcstats
:
:
Statistics
&
stats
)
{
MOZ_ASSERT
(
CurrentThreadCanAccessRuntime
(
runtime
(
)
)
)
;
MOZ_ASSERT
(
runtime
(
)
-
>
gc
.
isHeapCompacting
(
)
)
;
MOZ_ASSERT
(
!
runtime
(
)
-
>
gc
.
isBackgroundSweeping
(
)
)
;
AllocKinds
allocKindsToRelocate
=
CompactingAllocKinds
(
)
;
clearFreeLists
(
)
;
if
(
ShouldRelocateAllArenas
(
reason
)
)
{
zone_
-
>
prepareForMovingGC
(
)
;
for
(
auto
kind
:
allocKindsToRelocate
)
{
ArenaList
&
al
=
arenaList
(
kind
)
;
Arena
*
allArenas
=
al
.
release
(
)
;
relocatedListOut
=
al
.
relocateArenas
(
allArenas
relocatedListOut
sliceBudget
stats
)
;
}
}
else
{
size_t
arenaCount
=
0
;
size_t
relocCount
=
0
;
AllAllocKindArray
<
std
:
:
pair
<
Arena
*
Arena
*
>
>
rangeToRelocate
;
for
(
auto
kind
:
allocKindsToRelocate
)
{
rangeToRelocate
[
kind
]
=
arenaList
(
kind
)
.
pickArenasToRelocate
(
kind
arenaCount
relocCount
)
;
}
if
(
!
ShouldRelocateZone
(
arenaCount
relocCount
reason
)
)
{
return
false
;
}
zone_
-
>
prepareForMovingGC
(
)
;
for
(
auto
kind
:
allocKindsToRelocate
)
{
if
(
rangeToRelocate
[
kind
]
.
first
)
{
ArenaList
&
al
=
arenaList
(
kind
)
;
const
auto
&
range
=
rangeToRelocate
[
kind
]
;
Arena
*
arenas
=
al
.
removeRange
(
range
.
first
range
.
second
)
;
relocatedListOut
=
al
.
relocateArenas
(
arenas
relocatedListOut
sliceBudget
stats
)
;
}
}
}
return
true
;
}
bool
GCRuntime
:
:
relocateArenas
(
Zone
*
zone
JS
:
:
GCReason
reason
Arena
*
&
relocatedListOut
SliceBudget
&
sliceBudget
)
{
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
COMPACT_MOVE
)
;
MOZ_ASSERT
(
!
zone
-
>
isPreservingCode
(
)
)
;
MOZ_ASSERT
(
canRelocateZone
(
zone
)
)
;
js
:
:
CancelOffThreadCompile
(
rt
JS
:
:
Zone
:
:
Compact
)
;
if
(
!
zone
-
>
arenas
.
relocateArenas
(
relocatedListOut
reason
sliceBudget
stats
(
)
)
)
{
return
false
;
}
#
ifdef
DEBUG
for
(
auto
kind
:
CompactingAllocKinds
(
)
)
{
ArenaList
&
al
=
zone
-
>
arenas
.
arenaList
(
kind
)
;
size_t
freeCells
=
0
;
for
(
auto
arena
=
al
.
iter
(
)
;
!
arena
.
done
(
)
;
arena
.
next
(
)
)
{
if
(
arena
-
>
isFull
(
)
)
{
break
;
}
freeCells
+
=
arena
-
>
countFreeCells
(
)
;
}
MOZ_ASSERT
(
freeCells
<
Arena
:
:
thingsPerArena
(
kind
)
)
;
}
#
endif
return
true
;
}
MovingTracer
:
:
MovingTracer
(
JSRuntime
*
rt
)
:
GenericTracerImpl
(
rt
JS
:
:
TracerKind
:
:
Moving
JS
:
:
WeakMapTraceAction
:
:
TraceKeysAndValues
)
{
}
template
<
typename
T
>
inline
void
MovingTracer
:
:
onEdge
(
T
*
*
thingp
const
char
*
name
)
{
T
*
thing
=
*
thingp
;
if
(
IsForwarded
(
thing
)
)
{
MOZ_ASSERT
(
thing
-
>
runtimeFromAnyThread
(
)
=
=
runtime
(
)
)
;
*
thingp
=
Forwarded
(
thing
)
;
}
}
void
GCRuntime
:
:
sweepZoneAfterCompacting
(
MovingTracer
*
trc
Zone
*
zone
)
{
MOZ_ASSERT
(
zone
-
>
isGCCompacting
(
)
)
;
zone
-
>
traceWeakMaps
(
trc
)
;
zone
-
>
sweepObjectsWithWeakPointers
(
trc
)
;
traceWeakFinalizationObserverEdges
(
trc
zone
)
;
for
(
auto
*
cache
:
zone
-
>
weakCaches
(
)
)
{
cache
-
>
traceWeak
(
trc
JS
:
:
detail
:
:
WeakCacheBase
:
:
DontLockStoreBuffer
)
;
}
if
(
jit
:
:
JitZone
*
jitZone
=
zone
-
>
jitZone
(
)
)
{
jitZone
-
>
traceWeak
(
trc
zone
)
;
}
for
(
CompartmentsInZoneIter
c
(
zone
)
;
!
c
.
done
(
)
;
c
.
next
(
)
)
{
c
-
>
traceWeakNativeIterators
(
trc
)
;
for
(
RealmsInCompartmentIter
r
(
c
)
;
!
r
.
done
(
)
;
r
.
next
(
)
)
{
r
-
>
traceWeakSavedStacks
(
trc
)
;
r
-
>
traceWeakGlobalEdge
(
trc
)
;
r
-
>
traceWeakDebugEnvironmentEdges
(
trc
)
;
}
}
}
template
<
typename
T
>
static
inline
void
UpdateCellPointers
(
MovingTracer
*
trc
T
*
cell
)
{
MOZ_ASSERT
(
!
cell
-
>
isForwarded
(
)
)
;
cell
-
>
fixupAfterMovingGC
(
)
;
cell
-
>
traceChildren
(
trc
)
;
}
template
<
typename
T
>
static
void
UpdateArenaPointersTyped
(
MovingTracer
*
trc
Arena
*
arena
)
{
for
(
ArenaCellIterUnderGC
cell
(
arena
)
;
!
cell
.
done
(
)
;
cell
.
next
(
)
)
{
UpdateCellPointers
(
trc
cell
.
as
<
T
>
(
)
)
;
}
}
static
bool
CanUpdateKindInBackground
(
AllocKind
kind
)
{
return
js
:
:
gc
:
:
IsBackgroundFinalized
(
kind
)
&
&
!
IsShapeAllocKind
(
kind
)
&
&
kind
!
=
AllocKind
:
:
BASE_SHAPE
;
}
static
void
UpdateArenaPointers
(
MovingTracer
*
trc
Arena
*
arena
)
{
AllocKind
kind
=
arena
-
>
getAllocKind
(
)
;
MOZ_ASSERT_IF
(
!
CanUpdateKindInBackground
(
kind
)
CurrentThreadCanAccessRuntime
(
trc
-
>
runtime
(
)
)
)
;
switch
(
kind
)
{
#
define
EXPAND_CASE
(
allocKind
traceKind
type
sizedType
bgFinal
nursery
\
compact
)
\
case
AllocKind
:
:
allocKind
:
\
UpdateArenaPointersTyped
<
type
>
(
trc
arena
)
;
\
return
;
FOR_EACH_ALLOCKIND
(
EXPAND_CASE
)
#
undef
EXPAND_CASE
default
:
MOZ_CRASH
(
"
Invalid
alloc
kind
for
UpdateArenaPointers
"
)
;
}
}
struct
ArenaListSegment
{
Arena
*
begin
;
Arena
*
end
;
}
;
static
size_t
UpdateArenaListSegmentPointers
(
GCRuntime
*
gc
const
ArenaListSegment
&
arenas
)
{
MOZ_ASSERT
(
arenas
.
begin
)
;
MovingTracer
trc
(
gc
-
>
rt
)
;
size_t
count
=
0
;
Arena
*
arena
=
arenas
.
begin
;
do
{
UpdateArenaPointers
(
&
trc
arena
)
;
count
+
+
;
arena
=
arena
-
>
next
;
}
while
(
arena
!
=
arenas
.
end
)
;
return
count
*
256
;
}
class
ArenasToUpdate
{
#
ifdef
DEBUG
static
const
unsigned
MaxArenasToProcess
=
16
;
#
else
static
const
unsigned
MaxArenasToProcess
=
256
;
#
endif
public
:
ArenasToUpdate
(
Zone
*
zone
const
AllocKinds
&
kinds
)
:
kinds
(
kinds
)
zone
(
zone
)
{
settle
(
)
;
}
bool
done
(
)
const
{
MOZ_ASSERT_IF
(
!
segmentBegin
endOfArenaList
)
;
return
!
segmentBegin
;
}
ArenaListSegment
get
(
)
const
{
MOZ_ASSERT
(
!
done
(
)
)
;
return
{
segmentBegin
segmentEnd
}
;
}
void
next
(
)
;
private
:
AllocKinds
kinds
;
Zone
*
zone
;
AllocKind
kind
=
AllocKind
:
:
FIRST
;
Arena
*
segmentBegin
=
nullptr
;
Arena
*
segmentEnd
=
nullptr
;
bool
endOfArenaList
=
true
;
static
AllocKind
nextAllocKind
(
AllocKind
i
)
{
return
AllocKind
(
uint8_t
(
i
)
+
1
)
;
}
void
settle
(
)
;
void
findSegmentEnd
(
)
;
}
;
void
ArenasToUpdate
:
:
settle
(
)
{
MOZ_ASSERT
(
!
segmentBegin
)
;
MOZ_ASSERT
(
endOfArenaList
)
;
for
(
;
kind
<
AllocKind
:
:
LIMIT
;
kind
=
nextAllocKind
(
kind
)
)
{
if
(
!
kinds
.
contains
(
kind
)
)
{
continue
;
}
Arena
*
arena
=
zone
-
>
arenas
.
getFirstArena
(
kind
)
;
if
(
arena
)
{
segmentBegin
=
arena
;
endOfArenaList
=
false
;
findSegmentEnd
(
)
;
break
;
}
}
}
void
ArenasToUpdate
:
:
findSegmentEnd
(
)
{
MOZ_ASSERT
(
segmentBegin
)
;
MOZ_ASSERT
(
!
endOfArenaList
)
;
Arena
*
arena
=
segmentBegin
;
Arena
*
firstArena
=
zone
-
>
arenas
.
getFirstArena
(
kind
)
;
for
(
size_t
i
=
0
;
i
<
MaxArenasToProcess
;
i
+
+
)
{
arena
=
arena
-
>
next
;
if
(
arena
=
=
firstArena
)
{
endOfArenaList
=
true
;
break
;
}
}
segmentEnd
=
arena
;
}
void
ArenasToUpdate
:
:
next
(
)
{
MOZ_ASSERT
(
!
done
(
)
)
;
if
(
!
endOfArenaList
)
{
segmentBegin
=
segmentEnd
;
findSegmentEnd
(
)
;
return
;
}
segmentBegin
=
nullptr
;
kind
=
nextAllocKind
(
kind
)
;
settle
(
)
;
}
static
AllocKinds
ForegroundUpdateKinds
(
AllocKinds
kinds
)
{
AllocKinds
result
;
for
(
AllocKind
kind
:
kinds
)
{
if
(
!
CanUpdateKindInBackground
(
kind
)
)
{
result
+
=
kind
;
}
}
return
result
;
}
void
GCRuntime
:
:
updateCellPointers
(
Zone
*
zone
AllocKinds
kinds
)
{
AllocKinds
fgKinds
=
ForegroundUpdateKinds
(
kinds
)
;
AllocKinds
bgKinds
=
kinds
-
fgKinds
;
ArenasToUpdate
fgArenas
(
zone
fgKinds
)
;
ArenasToUpdate
bgArenas
(
zone
bgKinds
)
;
AutoLockHelperThreadState
lock
;
AutoRunParallelWork
bgTasks
(
this
UpdateArenaListSegmentPointers
gcstats
:
:
PhaseKind
:
:
COMPACT_UPDATE_CELLS
GCUse
:
:
Unspecified
bgArenas
SliceBudget
:
:
unlimited
(
)
lock
)
;
AutoUnlockHelperThreadState
unlock
(
lock
)
;
for
(
;
!
fgArenas
.
done
(
)
;
fgArenas
.
next
(
)
)
{
UpdateArenaListSegmentPointers
(
this
fgArenas
.
get
(
)
)
;
}
}
static
constexpr
AllocKinds
UpdatePhaseOne
{
AllocKind
:
:
SCRIPT
AllocKind
:
:
BASE_SHAPE
AllocKind
:
:
SHAPE
AllocKind
:
:
STRING
AllocKind
:
:
JITCODE
AllocKind
:
:
REGEXP_SHARED
AllocKind
:
:
SCOPE
AllocKind
:
:
GETTER_SETTER
AllocKind
:
:
COMPACT_PROP_MAP
AllocKind
:
:
NORMAL_PROP_MAP
AllocKind
:
:
DICT_PROP_MAP
}
;
static
constexpr
AllocKinds
UpdatePhaseTwo
{
AllocKind
:
:
FUNCTION
AllocKind
:
:
FUNCTION_EXTENDED
AllocKind
:
:
OBJECT0
AllocKind
:
:
OBJECT0_FOREGROUND
AllocKind
:
:
OBJECT0_BACKGROUND
AllocKind
:
:
OBJECT2
AllocKind
:
:
OBJECT2_FOREGROUND
AllocKind
:
:
OBJECT2_BACKGROUND
AllocKind
:
:
ARRAYBUFFER4
AllocKind
:
:
OBJECT4
AllocKind
:
:
OBJECT4_FOREGROUND
AllocKind
:
:
OBJECT4_BACKGROUND
AllocKind
:
:
ARRAYBUFFER8
AllocKind
:
:
OBJECT8
AllocKind
:
:
OBJECT8_FOREGROUND
AllocKind
:
:
OBJECT8_BACKGROUND
AllocKind
:
:
ARRAYBUFFER12
AllocKind
:
:
OBJECT12
AllocKind
:
:
OBJECT12_FOREGROUND
AllocKind
:
:
OBJECT12_BACKGROUND
AllocKind
:
:
ARRAYBUFFER16
AllocKind
:
:
OBJECT16
AllocKind
:
:
OBJECT16_FOREGROUND
AllocKind
:
:
OBJECT16_BACKGROUND
}
;
void
GCRuntime
:
:
updateAllCellPointers
(
MovingTracer
*
trc
Zone
*
zone
)
{
updateCellPointers
(
zone
UpdatePhaseOne
)
;
updateCellPointers
(
zone
UpdatePhaseTwo
)
;
}
void
GCRuntime
:
:
updateZonePointersToRelocatedCells
(
Zone
*
zone
)
{
MOZ_ASSERT
(
!
rt
-
>
isBeingDestroyed
(
)
)
;
MOZ_ASSERT
(
zone
-
>
isGCCompacting
(
)
)
;
AutoTouchingGrayThings
tgt
;
gcstats
:
:
AutoPhase
ap
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
COMPACT_UPDATE
)
;
MovingTracer
trc
(
rt
)
;
zone
-
>
fixupAfterMovingGC
(
)
;
zone
-
>
fixupScriptMapsAfterMovingGC
(
&
trc
)
;
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
comp
-
>
fixupAfterMovingGC
(
&
trc
)
;
}
zone
-
>
externalStringCache
(
)
.
purge
(
)
;
zone
-
>
functionToStringCache
(
)
.
purge
(
)
;
zone
-
>
shapeZone
(
)
.
purgeShapeCaches
(
rt
-
>
gcContext
(
)
)
;
rt
-
>
caches
(
)
.
stringToAtomCache
.
purge
(
)
;
updateAllCellPointers
(
&
trc
zone
)
;
sweepZoneAfterCompacting
(
&
trc
zone
)
;
for
(
CompartmentsInZoneIter
comp
(
zone
)
;
!
comp
.
done
(
)
;
comp
.
next
(
)
)
{
callWeakPointerCompartmentCallbacks
(
&
trc
comp
)
;
}
}
void
GCRuntime
:
:
updateRuntimePointersToRelocatedCells
(
AutoGCSession
&
session
)
{
MOZ_ASSERT
(
!
rt
-
>
isBeingDestroyed
(
)
)
;
gcstats
:
:
AutoPhase
ap1
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
COMPACT_UPDATE
)
;
MovingTracer
trc
(
rt
)
;
Zone
:
:
fixupAllCrossCompartmentWrappersAfterMovingGC
(
&
trc
)
;
rt
-
>
geckoProfiler
(
)
.
fixupStringsMapAfterMovingGC
(
)
;
traceRuntimeForMajorGC
(
&
trc
session
)
;
jit
:
:
UpdateJitActivationsForCompactingGC
(
rt
)
;
{
gcstats
:
:
AutoPhase
ap2
(
stats
(
)
gcstats
:
:
PhaseKind
:
:
MARK_ROOTS
)
;
DebugAPI
:
:
traceAllForMovingGC
(
&
trc
)
;
DebugAPI
:
:
traceCrossCompartmentEdges
(
&
trc
)
;
traceEmbeddingGrayRoots
(
&
trc
)
;
Compartment
:
:
traceIncomingCrossCompartmentEdgesForZoneGC
(
&
trc
Compartment
:
:
GrayEdges
)
;
}
jit
:
:
JitRuntime
:
:
TraceWeakJitcodeGlobalTable
(
rt
&
trc
)
;
for
(
JS
:
:
detail
:
:
WeakCacheBase
*
cache
:
rt
-
>
weakCaches
(
)
)
{
cache
-
>
traceWeak
(
&
trc
JS
:
:
detail
:
:
WeakCacheBase
:
:
DontLockStoreBuffer
)
;
}
if
(
rt
-
>
hasJitRuntime
(
)
&
&
rt
-
>
jitRuntime
(
)
-
>
hasInterpreterEntryMap
(
)
)
{
rt
-
>
jitRuntime
(
)
-
>
getInterpreterEntryMap
(
)
-
>
updateScriptsAfterMovingGC
(
)
;
}
{
AutoLockHelperThreadState
lock
;
lifoBlocksToFree
.
ref
(
)
.
freeAll
(
)
;
}
callWeakPointerZonesCallbacks
(
&
trc
)
;
}
void
GCRuntime
:
:
clearRelocatedArenas
(
Arena
*
arenaList
JS
:
:
GCReason
reason
)
{
AutoLockGC
lock
(
this
)
;
clearRelocatedArenasWithoutUnlocking
(
arenaList
reason
lock
)
;
}
void
GCRuntime
:
:
clearRelocatedArenasWithoutUnlocking
(
Arena
*
arenaList
JS
:
:
GCReason
reason
const
AutoLockGC
&
lock
)
{
while
(
arenaList
)
{
Arena
*
arena
=
arenaList
;
arenaList
=
arenaList
-
>
next
;
arena
-
>
unmarkAll
(
)
;
arena
-
>
setAsFullyUnused
(
)
;
#
ifdef
DEBUG
SetMemCheckKind
(
reinterpret_cast
<
void
*
>
(
arena
-
>
thingsStart
(
)
)
arena
-
>
getThingsSpan
(
)
MemCheckKind
:
:
MakeUndefined
)
;
#
endif
AlwaysPoison
(
reinterpret_cast
<
void
*
>
(
arena
-
>
thingsStart
(
)
)
JS_MOVED_TENURED_PATTERN
arena
-
>
getThingsSpan
(
)
MemCheckKind
:
:
MakeNoAccess
)
;
bool
allArenasRelocated
=
ShouldRelocateAllArenas
(
reason
)
;
bool
updateRetainedSize
=
!
allArenasRelocated
&
&
!
arena
-
>
isNewlyCreated
(
)
;
Zone
*
zone
=
arena
-
>
zone
(
)
;
zone
-
>
gcHeapSize
.
removeBytes
(
ArenaSize
updateRetainedSize
heapSize
)
;
MOZ_ASSERT
(
!
zone
-
>
isAtomsZone
(
)
)
;
arena
-
>
release
(
)
;
}
}
#
ifdef
DEBUG
static
inline
bool
CanProtectArenas
(
)
{
return
SystemPageSize
(
)
<
=
ArenaSize
;
}
static
inline
bool
ShouldProtectRelocatedArenas
(
JS
:
:
GCReason
reason
)
{
return
reason
=
=
JS
:
:
GCReason
:
:
DEBUG_GC
&
&
CanProtectArenas
(
)
;
}
void
GCRuntime
:
:
protectOrReleaseRelocatedArenas
(
Arena
*
arenaList
JS
:
:
GCReason
reason
)
{
if
(
ShouldProtectRelocatedArenas
(
reason
)
)
{
protectAndHoldArenas
(
arenaList
)
;
return
;
}
releaseRelocatedArenas
(
arenaList
)
;
}
void
GCRuntime
:
:
protectAndHoldArenas
(
Arena
*
arenaList
)
{
for
(
Arena
*
arena
=
arenaList
;
arena
;
)
{
MOZ_ASSERT
(
!
arena
-
>
allocated
(
)
)
;
Arena
*
next
=
arena
-
>
next
;
if
(
!
next
)
{
AutoLockGC
lock
(
this
)
;
arena
-
>
next
=
relocatedArenasToRelease
;
relocatedArenasToRelease
=
arenaList
;
}
ProtectPages
(
arena
ArenaSize
)
;
arena
=
next
;
}
}
void
GCRuntime
:
:
unprotectHeldRelocatedArenas
(
const
AutoLockGC
&
lock
)
{
for
(
Arena
*
arena
=
relocatedArenasToRelease
;
arena
;
arena
=
arena
-
>
next
)
{
UnprotectPages
(
arena
ArenaSize
)
;
MOZ_ASSERT
(
!
arena
-
>
allocated
(
)
)
;
}
}
void
GCRuntime
:
:
releaseHeldRelocatedArenas
(
)
{
AutoLockGC
lock
(
this
)
;
unprotectHeldRelocatedArenas
(
lock
)
;
Arena
*
arenas
=
relocatedArenasToRelease
;
relocatedArenasToRelease
=
nullptr
;
releaseRelocatedArenasWithoutUnlocking
(
arenas
lock
)
;
}
void
GCRuntime
:
:
releaseHeldRelocatedArenasWithoutUnlocking
(
const
AutoLockGC
&
lock
)
{
unprotectHeldRelocatedArenas
(
lock
)
;
releaseRelocatedArenasWithoutUnlocking
(
relocatedArenasToRelease
lock
)
;
relocatedArenasToRelease
=
nullptr
;
}
#
endif
void
GCRuntime
:
:
releaseRelocatedArenas
(
Arena
*
arenaList
)
{
AutoLockGC
lock
(
this
)
;
releaseRelocatedArenasWithoutUnlocking
(
arenaList
lock
)
;
}
void
GCRuntime
:
:
releaseRelocatedArenasWithoutUnlocking
(
Arena
*
arenaList
const
AutoLockGC
&
lock
)
{
while
(
arenaList
)
{
Arena
*
arena
=
arenaList
;
arenaList
=
arenaList
-
>
next
;
arena
-
>
chunk
(
)
-
>
releaseArena
(
this
arena
lock
)
;
}
}
