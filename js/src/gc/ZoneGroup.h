#
ifndef
gc_ZoneGroup_h
#
define
gc_ZoneGroup_h
#
include
"
jsgc
.
h
"
#
include
"
gc
/
Statistics
.
h
"
#
include
"
vm
/
Caches
.
h
"
#
include
"
vm
/
Stack
.
h
"
namespace
js
{
namespace
jit
{
class
JitZoneGroup
;
}
class
AutoKeepAtoms
;
typedef
Vector
<
JS
:
:
Zone
*
4
SystemAllocPolicy
>
ZoneVector
;
class
ZoneGroup
{
public
:
JSRuntime
*
const
runtime
;
private
:
UnprotectedData
<
CooperatingContext
>
ownerContext_
;
ZoneGroupData
<
size_t
>
enterCount
;
public
:
CooperatingContext
&
ownerContext
(
)
{
return
ownerContext_
.
ref
(
)
;
}
void
*
addressOfOwnerContext
(
)
{
return
&
ownerContext_
.
ref
(
)
.
cx
;
}
void
enter
(
)
;
void
leave
(
)
;
bool
ownedByCurrentThread
(
)
;
private
:
ActiveThreadOrGCTaskData
<
ZoneVector
>
zones_
;
public
:
ZoneVector
&
zones
(
)
{
return
zones_
.
ref
(
)
;
}
explicit
ZoneGroup
(
JSRuntime
*
runtime
)
;
~
ZoneGroup
(
)
;
bool
init
(
size_t
maxNurseryBytes
)
;
private
:
ZoneGroupData
<
Nursery
>
nursery_
;
ZoneGroupData
<
gc
:
:
StoreBuffer
>
storeBuffer_
;
public
:
Nursery
&
nursery
(
)
{
return
nursery_
.
ref
(
)
;
}
gc
:
:
StoreBuffer
&
storeBuffer
(
)
{
return
storeBuffer_
.
ref
(
)
;
}
ActiveThreadData
<
LifoAlloc
>
blocksToFreeAfterMinorGC
;
void
minorGC
(
JS
:
:
gcreason
:
:
Reason
reason
gcstats
:
:
Phase
phase
=
gcstats
:
:
PHASE_MINOR_GC
)
JS_HAZ_GC_CALL
;
void
evictNursery
(
JS
:
:
gcreason
:
:
Reason
reason
=
JS
:
:
gcreason
:
:
EVICT_NURSERY
)
{
minorGC
(
reason
gcstats
:
:
PHASE_EVICT_NURSERY
)
;
}
void
freeAllLifoBlocksAfterMinorGC
(
LifoAlloc
*
lifo
)
;
const
void
*
addressOfNurseryPosition
(
)
{
return
nursery_
.
refNoCheck
(
)
.
addressOfPosition
(
)
;
}
const
void
*
addressOfNurseryCurrentEnd
(
)
{
return
nursery_
.
refNoCheck
(
)
.
addressOfCurrentEnd
(
)
;
}
void
callAfterMinorGC
(
void
(
*
thunk
)
(
void
*
data
)
void
*
data
)
{
nursery
(
)
.
queueSweepAction
(
thunk
data
)
;
}
inline
bool
isCollecting
(
)
;
inline
bool
isGCScheduled
(
)
;
private
:
ZoneGroupData
<
ZoneGroupCaches
>
caches_
;
public
:
ZoneGroupCaches
&
caches
(
)
{
return
caches_
.
ref
(
)
;
}
#
ifdef
DEBUG
private
:
ZoneGroupData
<
uint32_t
>
ionBailAfter_
;
public
:
void
*
addressOfIonBailAfter
(
)
{
return
&
ionBailAfter_
;
}
void
setIonBailAfter
(
uint32_t
after
)
{
ionBailAfter_
=
after
;
}
#
endif
ZoneGroupData
<
jit
:
:
JitZoneGroup
*
>
jitZoneGroup
;
private
:
ZoneGroupData
<
mozilla
:
:
LinkedList
<
js
:
:
Debugger
>
>
debuggerList_
;
public
:
mozilla
:
:
LinkedList
<
js
:
:
Debugger
>
&
debuggerList
(
)
{
return
debuggerList_
.
ref
(
)
;
}
}
;
class
MOZ_RAII
AutoAccessZoneGroup
{
ZoneGroup
*
group
;
public
:
explicit
AutoAccessZoneGroup
(
ZoneGroup
*
group
)
:
group
(
group
)
{
group
-
>
enter
(
)
;
}
~
AutoAccessZoneGroup
(
)
{
group
-
>
leave
(
)
;
}
}
;
class
MOZ_RAII
AutoAccessZoneGroups
{
Vector
<
ZoneGroup
*
4
SystemAllocPolicy
>
acquiredGroups
;
public
:
AutoAccessZoneGroups
(
)
{
}
~
AutoAccessZoneGroups
(
)
{
for
(
size_t
i
=
0
;
i
<
acquiredGroups
.
length
(
)
;
i
+
+
)
acquiredGroups
[
i
]
-
>
leave
(
)
;
}
void
access
(
ZoneGroup
*
group
)
{
group
-
>
enter
(
)
;
AutoEnterOOMUnsafeRegion
oomUnsafe
;
if
(
!
acquiredGroups
.
append
(
group
)
)
oomUnsafe
.
crash
(
"
acquiredGroups
.
append
failed
"
)
;
}
}
;
}
#
endif
