#
ifndef
gc_ZoneGroup_h
#
define
gc_ZoneGroup_h
#
include
"
gc
/
Statistics
.
h
"
#
include
"
vm
/
Caches
.
h
"
#
include
"
vm
/
Stack
.
h
"
namespace
js
{
namespace
jit
{
class
JitZoneGroup
;
}
class
AutoKeepAtoms
;
typedef
Vector
<
JS
:
:
Zone
*
4
SystemAllocPolicy
>
ZoneVector
;
class
ZoneGroup
{
public
:
JSRuntime
*
const
runtime
;
private
:
UnprotectedData
<
JSContext
*
>
helperThreadOwnerContext_
;
public
:
bool
ownedByCurrentHelperThread
(
)
;
void
setHelperThreadOwnerContext
(
JSContext
*
cx
)
;
private
:
ZoneGroupOrGCTaskData
<
ZoneVector
>
zones_
;
public
:
ZoneVector
&
zones
(
)
{
return
zones_
.
ref
(
)
;
}
private
:
enum
class
HelperThreadUse
:
uint32_t
{
None
Pending
Active
}
;
mozilla
:
:
Atomic
<
HelperThreadUse
>
helperThreadUse
;
public
:
bool
createdForHelperThread
(
)
const
{
return
helperThreadUse
!
=
HelperThreadUse
:
:
None
;
}
bool
usedByHelperThread
(
)
const
{
return
helperThreadUse
=
=
HelperThreadUse
:
:
Active
;
}
void
setCreatedForHelperThread
(
)
{
MOZ_ASSERT
(
helperThreadUse
=
=
HelperThreadUse
:
:
None
)
;
helperThreadUse
=
HelperThreadUse
:
:
Pending
;
}
void
setUsedByHelperThread
(
)
{
MOZ_ASSERT
(
helperThreadUse
=
=
HelperThreadUse
:
:
Pending
)
;
helperThreadUse
=
HelperThreadUse
:
:
Active
;
}
void
clearUsedByHelperThread
(
)
{
MOZ_ASSERT
(
helperThreadUse
!
=
HelperThreadUse
:
:
None
)
;
helperThreadUse
=
HelperThreadUse
:
:
None
;
}
explicit
ZoneGroup
(
JSRuntime
*
runtime
)
;
~
ZoneGroup
(
)
;
void
deleteEmptyZone
(
Zone
*
zone
)
;
}
;
}
#
endif
