#
ifndef
gc_ZoneGroup_h
#
define
gc_ZoneGroup_h
#
include
"
jsgc
.
h
"
#
include
"
gc
/
Statistics
.
h
"
#
include
"
vm
/
Caches
.
h
"
#
include
"
vm
/
Stack
.
h
"
namespace
js
{
namespace
jit
{
class
JitZoneGroup
;
}
class
AutoKeepAtoms
;
typedef
Vector
<
JS
:
:
Zone
*
4
SystemAllocPolicy
>
ZoneVector
;
class
ZoneGroup
{
public
:
JSRuntime
*
const
runtime
;
private
:
UnprotectedData
<
CooperatingContext
>
ownerContext_
;
UnprotectedData
<
size_t
>
enterCount
;
public
:
CooperatingContext
&
ownerContext
(
)
{
return
ownerContext_
.
ref
(
)
;
}
void
*
addressOfOwnerContext
(
)
{
return
&
ownerContext_
.
ref
(
)
.
cx
;
}
void
enter
(
)
;
void
leave
(
)
;
bool
ownedByCurrentThread
(
)
;
private
:
ZoneGroupOrGCTaskData
<
ZoneVector
>
zones_
;
public
:
ZoneVector
&
zones
(
)
{
return
zones_
.
ref
(
)
;
}
mozilla
:
:
Atomic
<
bool
>
usedByHelperThread
;
explicit
ZoneGroup
(
JSRuntime
*
runtime
)
;
~
ZoneGroup
(
)
;
bool
init
(
)
;
inline
Nursery
&
nursery
(
)
;
inline
gc
:
:
StoreBuffer
&
storeBuffer
(
)
;
inline
void
callAfterMinorGC
(
void
(
*
thunk
)
(
void
*
data
)
void
*
data
)
;
inline
bool
isCollecting
(
)
;
inline
bool
isGCScheduled
(
)
;
#
ifdef
DEBUG
private
:
ZoneGroupData
<
uint32_t
>
ionBailAfter_
;
public
:
void
*
addressOfIonBailAfter
(
)
{
return
&
ionBailAfter_
;
}
void
setIonBailAfter
(
uint32_t
after
)
{
ionBailAfter_
=
after
;
}
#
endif
ZoneGroupData
<
jit
:
:
JitZoneGroup
*
>
jitZoneGroup
;
private
:
ZoneGroupData
<
mozilla
:
:
LinkedList
<
js
:
:
Debugger
>
>
debuggerList_
;
public
:
mozilla
:
:
LinkedList
<
js
:
:
Debugger
>
&
debuggerList
(
)
{
return
debuggerList_
.
ref
(
)
;
}
}
;
}
#
endif
