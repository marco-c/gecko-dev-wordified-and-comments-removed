#
include
"
jsatominlines
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
RangedPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
string
.
h
>
#
include
"
jscntxt
.
h
"
#
include
"
jsstr
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
vm
/
Symbol
.
h
"
#
include
"
vm
/
Xdr
.
h
"
#
include
"
jscntxtinlines
.
h
"
#
include
"
jscompartmentinlines
.
h
"
#
include
"
jsobjinlines
.
h
"
#
include
"
gc
/
AtomMarking
-
inl
.
h
"
#
include
"
vm
/
String
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
gc
;
using
mozilla
:
:
ArrayEnd
;
using
mozilla
:
:
ArrayLength
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
RangedPtr
;
const
char
*
js
:
:
AtomToPrintableString
(
JSContext
*
cx
JSAtom
*
atom
JSAutoByteString
*
bytes
)
{
JSString
*
str
=
QuoteString
(
cx
atom
0
)
;
if
(
!
str
)
return
nullptr
;
return
bytes
-
>
encodeLatin1
(
cx
str
)
;
}
#
define
DEFINE_PROTO_STRING
(
name
code
init
clasp
)
const
char
js_
#
#
name
#
#
_str
[
]
=
#
name
;
JS_FOR_EACH_PROTOTYPE
(
DEFINE_PROTO_STRING
)
#
undef
DEFINE_PROTO_STRING
#
define
CONST_CHAR_STR
(
idpart
id
text
)
const
char
js_
#
#
idpart
#
#
_str
[
]
=
text
;
FOR_EACH_COMMON_PROPERTYNAME
(
CONST_CHAR_STR
)
#
undef
CONST_CHAR_STR
const
char
js_getter_str
[
]
=
"
getter
"
;
const
char
js_send_str
[
]
=
"
send
"
;
const
char
js_setter_str
[
]
=
"
setter
"
;
static
const
uint32_t
JS_STRING_HASH_COUNT
=
64
;
MOZ_ALWAYS_INLINE
AtomSet
:
:
Ptr
js
:
:
FrozenAtomSet
:
:
readonlyThreadsafeLookup
(
const
AtomSet
:
:
Lookup
&
l
)
const
{
return
mSet
-
>
readonlyThreadsafeLookup
(
l
)
;
}
struct
CommonNameInfo
{
const
char
*
str
;
size_t
length
;
}
;
bool
JSRuntime
:
:
initializeAtoms
(
JSContext
*
cx
)
{
atoms_
=
cx
-
>
new_
<
AtomSet
>
(
)
;
if
(
!
atoms_
|
|
!
atoms_
-
>
init
(
JS_STRING_HASH_COUNT
)
)
return
false
;
MOZ_ASSERT
(
!
permanentAtoms
)
;
if
(
parentRuntime
)
{
staticStrings
=
parentRuntime
-
>
staticStrings
;
commonNames
=
parentRuntime
-
>
commonNames
;
emptyString
=
parentRuntime
-
>
emptyString
;
permanentAtoms
=
parentRuntime
-
>
permanentAtoms
;
wellKnownSymbols
=
parentRuntime
-
>
wellKnownSymbols
;
return
true
;
}
staticStrings
=
cx
-
>
new_
<
StaticStrings
>
(
)
;
if
(
!
staticStrings
|
|
!
staticStrings
-
>
init
(
cx
)
)
return
false
;
static
const
CommonNameInfo
cachedNames
[
]
=
{
#
define
COMMON_NAME_INFO
(
idpart
id
text
)
{
js_
#
#
idpart
#
#
_str
sizeof
(
text
)
-
1
}
FOR_EACH_COMMON_PROPERTYNAME
(
COMMON_NAME_INFO
)
#
undef
COMMON_NAME_INFO
#
define
COMMON_NAME_INFO
(
name
code
init
clasp
)
{
js_
#
#
name
#
#
_str
sizeof
(
#
name
)
-
1
}
JS_FOR_EACH_PROTOTYPE
(
COMMON_NAME_INFO
)
#
undef
COMMON_NAME_INFO
#
define
COMMON_NAME_INFO
(
name
)
{
#
name
sizeof
(
#
name
)
-
1
}
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
COMMON_NAME_INFO
)
#
undef
COMMON_NAME_INFO
#
define
COMMON_NAME_INFO
(
name
)
{
"
Symbol
.
"
#
name
sizeof
(
"
Symbol
.
"
#
name
)
-
1
}
JS_FOR_EACH_WELL_KNOWN_SYMBOL
(
COMMON_NAME_INFO
)
#
undef
COMMON_NAME_INFO
}
;
commonNames
=
cx
-
>
new_
<
JSAtomState
>
(
)
;
if
(
!
commonNames
)
return
false
;
ImmutablePropertyNamePtr
*
names
=
reinterpret_cast
<
ImmutablePropertyNamePtr
*
>
(
commonNames
.
ref
(
)
)
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
cachedNames
)
;
i
+
+
names
+
+
)
{
JSAtom
*
atom
=
Atomize
(
cx
cachedNames
[
i
]
.
str
cachedNames
[
i
]
.
length
PinAtom
)
;
if
(
!
atom
)
return
false
;
names
-
>
init
(
atom
-
>
asPropertyName
(
)
)
;
}
MOZ_ASSERT
(
uintptr_t
(
names
)
=
=
uintptr_t
(
commonNames
+
1
)
)
;
emptyString
=
commonNames
-
>
empty
;
wellKnownSymbols
=
cx
-
>
new_
<
WellKnownSymbols
>
(
)
;
if
(
!
wellKnownSymbols
)
return
false
;
ImmutablePropertyNamePtr
*
descriptions
=
commonNames
-
>
wellKnownSymbolDescriptions
(
)
;
ImmutableSymbolPtr
*
symbols
=
reinterpret_cast
<
ImmutableSymbolPtr
*
>
(
wellKnownSymbols
.
ref
(
)
)
;
for
(
size_t
i
=
0
;
i
<
JS
:
:
WellKnownSymbolLimit
;
i
+
+
)
{
JS
:
:
Symbol
*
symbol
=
JS
:
:
Symbol
:
:
new_
(
cx
JS
:
:
SymbolCode
(
i
)
descriptions
[
i
]
)
;
if
(
!
symbol
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
symbols
[
i
]
.
init
(
symbol
)
;
}
return
true
;
}
void
JSRuntime
:
:
finishAtoms
(
)
{
js_delete
(
atoms_
.
ref
(
)
)
;
if
(
!
parentRuntime
)
{
js_delete
(
staticStrings
.
ref
(
)
)
;
js_delete
(
commonNames
.
ref
(
)
)
;
js_delete
(
permanentAtoms
.
ref
(
)
)
;
js_delete
(
wellKnownSymbols
.
ref
(
)
)
;
}
atoms_
=
nullptr
;
staticStrings
=
nullptr
;
commonNames
=
nullptr
;
permanentAtoms
=
nullptr
;
wellKnownSymbols
=
nullptr
;
emptyString
=
nullptr
;
}
void
js
:
:
TraceAtoms
(
JSTracer
*
trc
AutoLockForExclusiveAccess
&
lock
)
{
JSRuntime
*
rt
=
trc
-
>
runtime
(
)
;
if
(
rt
-
>
atomsAreFinished
(
)
)
return
;
for
(
AtomSet
:
:
Enum
e
(
rt
-
>
atoms
(
lock
)
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
const
AtomStateEntry
&
entry
=
e
.
front
(
)
;
if
(
!
entry
.
isPinned
(
)
)
continue
;
JSAtom
*
atom
=
entry
.
asPtrUnbarriered
(
)
;
TraceRoot
(
trc
&
atom
"
interned_atom
"
)
;
MOZ_ASSERT
(
entry
.
asPtrUnbarriered
(
)
=
=
atom
)
;
}
}
void
js
:
:
TracePermanentAtoms
(
JSTracer
*
trc
)
{
JSRuntime
*
rt
=
trc
-
>
runtime
(
)
;
if
(
rt
-
>
parentRuntime
)
return
;
if
(
rt
-
>
staticStrings
)
rt
-
>
staticStrings
-
>
trace
(
trc
)
;
if
(
rt
-
>
permanentAtoms
)
{
for
(
FrozenAtomSet
:
:
Range
r
(
rt
-
>
permanentAtoms
-
>
all
(
)
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
const
AtomStateEntry
&
entry
=
r
.
front
(
)
;
JSAtom
*
atom
=
entry
.
asPtrUnbarriered
(
)
;
TraceProcessGlobalRoot
(
trc
atom
"
permanent_table
"
)
;
}
}
}
void
js
:
:
TraceWellKnownSymbols
(
JSTracer
*
trc
)
{
JSRuntime
*
rt
=
trc
-
>
runtime
(
)
;
if
(
rt
-
>
parentRuntime
)
return
;
if
(
WellKnownSymbols
*
wks
=
rt
-
>
wellKnownSymbols
)
{
for
(
size_t
i
=
0
;
i
<
JS
:
:
WellKnownSymbolLimit
;
i
+
+
)
TraceProcessGlobalRoot
(
trc
wks
-
>
get
(
i
)
.
get
(
)
"
well_known_symbol
"
)
;
}
}
void
JSRuntime
:
:
sweepAtoms
(
)
{
if
(
atoms_
)
atoms_
-
>
sweep
(
)
;
}
bool
JSRuntime
:
:
transformToPermanentAtoms
(
JSContext
*
cx
)
{
MOZ_ASSERT
(
!
parentRuntime
)
;
MOZ_ASSERT
(
!
permanentAtoms
)
;
permanentAtoms
=
cx
-
>
new_
<
FrozenAtomSet
>
(
atoms_
)
;
atoms_
=
cx
-
>
new_
<
AtomSet
>
(
)
;
if
(
!
atoms_
|
|
!
atoms_
-
>
init
(
JS_STRING_HASH_COUNT
)
)
return
false
;
for
(
FrozenAtomSet
:
:
Range
r
(
permanentAtoms
-
>
all
(
)
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
AtomStateEntry
entry
=
r
.
front
(
)
;
JSAtom
*
atom
=
entry
.
asPtr
(
cx
)
;
atom
-
>
morphIntoPermanentAtom
(
)
;
}
return
true
;
}
bool
AtomIsPinned
(
JSContext
*
cx
JSAtom
*
atom
)
{
if
(
StaticStrings
:
:
isStatic
(
atom
)
)
return
true
;
AtomHasher
:
:
Lookup
lookup
(
atom
)
;
MOZ_ASSERT
(
cx
-
>
isPermanentAtomsInitialized
(
)
)
;
AtomSet
:
:
Ptr
p
=
cx
-
>
permanentAtoms
(
)
.
readonlyThreadsafeLookup
(
lookup
)
;
if
(
p
)
return
true
;
AutoLockForExclusiveAccess
lock
(
cx
)
;
p
=
cx
-
>
runtime
(
)
-
>
atoms
(
lock
)
.
lookup
(
lookup
)
;
if
(
!
p
)
return
false
;
return
p
-
>
isPinned
(
)
;
}
#
ifdef
DEBUG
bool
AtomIsPinnedInRuntime
(
JSRuntime
*
rt
JSAtom
*
atom
)
{
Maybe
<
AutoLockForExclusiveAccess
>
lock
;
if
(
!
rt
-
>
currentThreadHasExclusiveAccess
(
)
)
lock
.
emplace
(
rt
)
;
AtomHasher
:
:
Lookup
lookup
(
atom
)
;
AtomSet
:
:
Ptr
p
=
rt
-
>
unsafeAtoms
(
)
.
lookup
(
lookup
)
;
MOZ_ASSERT
(
p
)
;
return
p
-
>
isPinned
(
)
;
}
#
endif
template
<
typename
CharT
>
MOZ_ALWAYS_INLINE
static
JSAtom
*
AtomizeAndCopyChars
(
JSContext
*
cx
const
CharT
*
tbchars
size_t
length
PinningBehavior
pin
const
Maybe
<
uint32_t
>
&
indexValue
)
{
if
(
JSAtom
*
s
=
cx
-
>
staticStrings
(
)
.
lookup
(
tbchars
length
)
)
return
s
;
AtomHasher
:
:
Lookup
lookup
(
tbchars
length
)
;
Zone
*
zone
=
cx
-
>
zone
(
)
;
Maybe
<
AtomSet
:
:
AddPtr
>
zonePtr
;
if
(
MOZ_LIKELY
(
zone
&
&
pin
=
=
DoNotPinAtom
)
)
{
zonePtr
.
emplace
(
zone
-
>
atomCache
(
)
.
lookupForAdd
(
lookup
)
)
;
if
(
zonePtr
.
ref
(
)
)
{
JSAtom
*
atom
=
zonePtr
.
ref
(
)
-
>
asPtrUnbarriered
(
)
;
MOZ_ASSERT
(
AtomIsMarked
(
zone
atom
)
)
;
return
atom
;
}
}
if
(
cx
-
>
isPermanentAtomsInitialized
(
)
)
{
AtomSet
:
:
Ptr
pp
=
cx
-
>
permanentAtoms
(
)
.
readonlyThreadsafeLookup
(
lookup
)
;
if
(
pp
)
{
JSAtom
*
atom
=
pp
-
>
asPtr
(
cx
)
;
if
(
zonePtr
)
mozilla
:
:
Unused
<
<
zone
-
>
atomCache
(
)
.
add
(
*
zonePtr
AtomStateEntry
(
atom
false
)
)
;
return
atom
;
}
}
if
(
MOZ_UNLIKELY
(
!
JSString
:
:
validateLength
(
cx
length
)
)
)
return
nullptr
;
AutoLockForExclusiveAccess
lock
(
cx
)
;
AtomSet
&
atoms
=
cx
-
>
atoms
(
lock
)
;
AtomSet
:
:
AddPtr
p
=
atoms
.
lookupForAdd
(
lookup
)
;
if
(
p
)
{
JSAtom
*
atom
=
p
-
>
asPtr
(
cx
)
;
p
-
>
setPinned
(
bool
(
pin
)
)
;
cx
-
>
atomMarking
(
)
.
inlinedMarkAtom
(
cx
atom
)
;
if
(
zonePtr
)
mozilla
:
:
Unused
<
<
zone
-
>
atomCache
(
)
.
add
(
*
zonePtr
AtomStateEntry
(
atom
false
)
)
;
return
atom
;
}
JSAtom
*
atom
;
{
AutoAtomsCompartment
ac
(
cx
lock
)
;
JSFlatString
*
flat
=
NewStringCopyN
<
NoGC
>
(
cx
tbchars
length
)
;
if
(
!
flat
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
atom
=
flat
-
>
morphAtomizedStringIntoAtom
(
lookup
.
hash
)
;
MOZ_ASSERT
(
atom
-
>
hash
(
)
=
=
lookup
.
hash
)
;
if
(
indexValue
)
atom
-
>
maybeInitializeIndex
(
*
indexValue
true
)
;
if
(
!
atoms
.
add
(
p
AtomStateEntry
(
atom
bool
(
pin
)
)
)
)
{
ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
}
cx
-
>
atomMarking
(
)
.
inlinedMarkAtom
(
cx
atom
)
;
if
(
zonePtr
)
mozilla
:
:
Unused
<
<
zone
-
>
atomCache
(
)
.
add
(
*
zonePtr
AtomStateEntry
(
atom
false
)
)
;
return
atom
;
}
template
JSAtom
*
AtomizeAndCopyChars
(
JSContext
*
cx
const
char16_t
*
tbchars
size_t
length
PinningBehavior
pin
const
Maybe
<
uint32_t
>
&
indexValue
)
;
template
JSAtom
*
AtomizeAndCopyChars
(
JSContext
*
cx
const
Latin1Char
*
tbchars
size_t
length
PinningBehavior
pin
const
Maybe
<
uint32_t
>
&
indexValue
)
;
JSAtom
*
js
:
:
AtomizeString
(
JSContext
*
cx
JSString
*
str
js
:
:
PinningBehavior
pin
)
{
if
(
str
-
>
isAtom
(
)
)
{
JSAtom
&
atom
=
str
-
>
asAtom
(
)
;
if
(
pin
!
=
PinAtom
|
|
js
:
:
StaticStrings
:
:
isStatic
(
&
atom
)
)
return
&
atom
;
AtomHasher
:
:
Lookup
lookup
(
&
atom
)
;
MOZ_ASSERT
(
cx
-
>
isPermanentAtomsInitialized
(
)
)
;
AtomSet
:
:
Ptr
p
=
cx
-
>
permanentAtoms
(
)
.
readonlyThreadsafeLookup
(
lookup
)
;
if
(
p
)
return
&
atom
;
AutoLockForExclusiveAccess
lock
(
cx
)
;
p
=
cx
-
>
atoms
(
lock
)
.
lookup
(
lookup
)
;
MOZ_ASSERT
(
p
)
;
MOZ_ASSERT
(
p
-
>
asPtrUnbarriered
(
)
=
=
&
atom
)
;
MOZ_ASSERT
(
pin
=
=
PinAtom
)
;
p
-
>
setPinned
(
bool
(
pin
)
)
;
return
&
atom
;
}
JSLinearString
*
linear
=
str
-
>
ensureLinear
(
cx
)
;
if
(
!
linear
)
return
nullptr
;
Maybe
<
uint32_t
>
indexValue
;
if
(
str
-
>
hasIndexValue
(
)
)
indexValue
.
emplace
(
str
-
>
getIndexValue
(
)
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
return
linear
-
>
hasLatin1Chars
(
)
?
AtomizeAndCopyChars
(
cx
linear
-
>
latin1Chars
(
nogc
)
linear
-
>
length
(
)
pin
indexValue
)
:
AtomizeAndCopyChars
(
cx
linear
-
>
twoByteChars
(
nogc
)
linear
-
>
length
(
)
pin
indexValue
)
;
}
JSAtom
*
js
:
:
Atomize
(
JSContext
*
cx
const
char
*
bytes
size_t
length
PinningBehavior
pin
const
Maybe
<
uint32_t
>
&
indexValue
)
{
CHECK_REQUEST
(
cx
)
;
const
Latin1Char
*
chars
=
reinterpret_cast
<
const
Latin1Char
*
>
(
bytes
)
;
return
AtomizeAndCopyChars
(
cx
chars
length
pin
indexValue
)
;
}
template
<
typename
CharT
>
JSAtom
*
js
:
:
AtomizeChars
(
JSContext
*
cx
const
CharT
*
chars
size_t
length
PinningBehavior
pin
)
{
CHECK_REQUEST
(
cx
)
;
return
AtomizeAndCopyChars
(
cx
chars
length
pin
Nothing
(
)
)
;
}
template
JSAtom
*
js
:
:
AtomizeChars
(
JSContext
*
cx
const
Latin1Char
*
chars
size_t
length
PinningBehavior
pin
)
;
template
JSAtom
*
js
:
:
AtomizeChars
(
JSContext
*
cx
const
char16_t
*
chars
size_t
length
PinningBehavior
pin
)
;
JSAtom
*
js
:
:
AtomizeUTF8Chars
(
JSContext
*
cx
const
char
*
utf8Chars
size_t
utf8ByteLength
)
{
UTF8Chars
utf8
(
utf8Chars
utf8ByteLength
)
;
size_t
length
;
UniqueTwoByteChars
chars
(
JS
:
:
UTF8CharsToNewTwoByteCharsZ
(
cx
utf8
&
length
)
.
get
(
)
)
;
if
(
!
chars
)
return
nullptr
;
return
AtomizeChars
(
cx
chars
.
get
(
)
length
)
;
}
bool
js
:
:
IndexToIdSlow
(
JSContext
*
cx
uint32_t
index
MutableHandleId
idp
)
{
MOZ_ASSERT
(
index
>
JSID_INT_MAX
)
;
char16_t
buf
[
UINT32_CHAR_BUFFER_LENGTH
]
;
RangedPtr
<
char16_t
>
end
(
ArrayEnd
(
buf
)
buf
ArrayEnd
(
buf
)
)
;
RangedPtr
<
char16_t
>
start
=
BackfillIndexInCharBuffer
(
index
end
)
;
JSAtom
*
atom
=
AtomizeChars
(
cx
start
.
get
(
)
end
-
start
)
;
if
(
!
atom
)
return
false
;
idp
.
set
(
JSID_FROM_BITS
(
(
size_t
)
atom
)
)
;
return
true
;
}
template
<
AllowGC
allowGC
>
static
JSAtom
*
ToAtomSlow
(
JSContext
*
cx
typename
MaybeRooted
<
Value
allowGC
>
:
:
HandleType
arg
)
{
MOZ_ASSERT
(
!
arg
.
isString
(
)
)
;
Value
v
=
arg
;
if
(
!
v
.
isPrimitive
(
)
)
{
MOZ_ASSERT
(
!
cx
-
>
helperThread
(
)
)
;
if
(
!
allowGC
)
return
nullptr
;
RootedValue
v2
(
cx
v
)
;
if
(
!
ToPrimitive
(
cx
JSTYPE_STRING
&
v2
)
)
return
nullptr
;
v
=
v2
;
}
if
(
v
.
isString
(
)
)
{
JSAtom
*
atom
=
AtomizeString
(
cx
v
.
toString
(
)
)
;
if
(
!
allowGC
&
&
!
atom
)
cx
-
>
recoverFromOutOfMemory
(
)
;
return
atom
;
}
if
(
v
.
isInt32
(
)
)
{
JSAtom
*
atom
=
Int32ToAtom
(
cx
v
.
toInt32
(
)
)
;
if
(
!
allowGC
&
&
!
atom
)
cx
-
>
recoverFromOutOfMemory
(
)
;
return
atom
;
}
if
(
v
.
isDouble
(
)
)
{
JSAtom
*
atom
=
NumberToAtom
(
cx
v
.
toDouble
(
)
)
;
if
(
!
allowGC
&
&
!
atom
)
cx
-
>
recoverFromOutOfMemory
(
)
;
return
atom
;
}
if
(
v
.
isBoolean
(
)
)
return
v
.
toBoolean
(
)
?
cx
-
>
names
(
)
.
true_
:
cx
-
>
names
(
)
.
false_
;
if
(
v
.
isNull
(
)
)
return
cx
-
>
names
(
)
.
null
;
if
(
v
.
isSymbol
(
)
)
{
MOZ_ASSERT
(
!
cx
-
>
helperThread
(
)
)
;
if
(
allowGC
)
{
JS_ReportErrorNumberASCII
(
cx
GetErrorMessage
nullptr
JSMSG_SYMBOL_TO_STRING
)
;
}
return
nullptr
;
}
MOZ_ASSERT
(
v
.
isUndefined
(
)
)
;
return
cx
-
>
names
(
)
.
undefined
;
}
template
<
AllowGC
allowGC
>
JSAtom
*
js
:
:
ToAtom
(
JSContext
*
cx
typename
MaybeRooted
<
Value
allowGC
>
:
:
HandleType
v
)
{
if
(
!
v
.
isString
(
)
)
return
ToAtomSlow
<
allowGC
>
(
cx
v
)
;
JSString
*
str
=
v
.
toString
(
)
;
if
(
str
-
>
isAtom
(
)
)
return
&
str
-
>
asAtom
(
)
;
JSAtom
*
atom
=
AtomizeString
(
cx
str
)
;
if
(
!
atom
&
&
!
allowGC
)
{
MOZ_ASSERT_IF
(
!
cx
-
>
helperThread
(
)
cx
-
>
isThrowingOutOfMemory
(
)
)
;
cx
-
>
recoverFromOutOfMemory
(
)
;
}
return
atom
;
}
template
JSAtom
*
js
:
:
ToAtom
<
CanGC
>
(
JSContext
*
cx
HandleValue
v
)
;
template
JSAtom
*
js
:
:
ToAtom
<
NoGC
>
(
JSContext
*
cx
const
Value
&
v
)
;
template
<
XDRMode
mode
>
bool
js
:
:
XDRAtom
(
XDRState
<
mode
>
*
xdr
MutableHandleAtom
atomp
)
{
if
(
mode
=
=
XDR_ENCODE
)
{
static_assert
(
JSString
:
:
MAX_LENGTH
<
=
INT32_MAX
"
String
length
must
fit
in
31
bits
"
)
;
uint32_t
length
=
atomp
-
>
length
(
)
;
uint32_t
lengthAndEncoding
=
(
length
<
<
1
)
|
uint32_t
(
atomp
-
>
hasLatin1Chars
(
)
)
;
if
(
!
xdr
-
>
codeUint32
(
&
lengthAndEncoding
)
)
return
false
;
JS
:
:
AutoCheckCannotGC
nogc
;
return
atomp
-
>
hasLatin1Chars
(
)
?
xdr
-
>
codeChars
(
atomp
-
>
latin1Chars
(
nogc
)
length
)
:
xdr
-
>
codeChars
(
const_cast
<
char16_t
*
>
(
atomp
-
>
twoByteChars
(
nogc
)
)
length
)
;
}
uint32_t
lengthAndEncoding
;
if
(
!
xdr
-
>
codeUint32
(
&
lengthAndEncoding
)
)
return
false
;
uint32_t
length
=
lengthAndEncoding
>
>
1
;
bool
latin1
=
lengthAndEncoding
&
0x1
;
JSContext
*
cx
=
xdr
-
>
cx
(
)
;
JSAtom
*
atom
;
if
(
latin1
)
{
const
Latin1Char
*
chars
=
nullptr
;
if
(
length
)
chars
=
reinterpret_cast
<
const
Latin1Char
*
>
(
xdr
-
>
buf
.
read
(
length
)
)
;
atom
=
AtomizeChars
(
cx
chars
length
)
;
}
else
{
#
if
MOZ_LITTLE_ENDIAN
const
char16_t
*
chars
=
nullptr
;
if
(
length
)
chars
=
reinterpret_cast
<
const
char16_t
*
>
(
xdr
-
>
buf
.
read
(
length
*
sizeof
(
char16_t
)
)
)
;
atom
=
AtomizeChars
(
cx
chars
length
)
;
#
else
char16_t
*
chars
;
char16_t
stackChars
[
256
]
;
if
(
length
<
=
ArrayLength
(
stackChars
)
)
{
chars
=
stackChars
;
}
else
{
chars
=
cx
-
>
pod_malloc
<
char16_t
>
(
length
)
;
if
(
!
chars
)
return
false
;
}
JS_ALWAYS_TRUE
(
xdr
-
>
codeChars
(
chars
length
)
)
;
atom
=
AtomizeChars
(
cx
chars
length
)
;
if
(
chars
!
=
stackChars
)
js_free
(
chars
)
;
#
endif
}
if
(
!
atom
)
return
false
;
atomp
.
set
(
atom
)
;
return
true
;
}
template
bool
js
:
:
XDRAtom
(
XDRState
<
XDR_ENCODE
>
*
xdr
MutableHandleAtom
atomp
)
;
template
bool
js
:
:
XDRAtom
(
XDRState
<
XDR_DECODE
>
*
xdr
MutableHandleAtom
atomp
)
;
