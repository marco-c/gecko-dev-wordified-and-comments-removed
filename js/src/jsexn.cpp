#
include
"
jsexn
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
<
new
>
#
include
<
stdarg
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
utility
>
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
frontend
/
FrontendContext
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
Object
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
SavedFrameAPI
.
h
"
#
include
"
js
/
Stack
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
js
/
Warnings
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
util
/
Memory
.
h
"
#
include
"
util
/
StringBuffer
.
h
"
#
include
"
vm
/
Compartment
.
h
"
#
include
"
vm
/
ErrorObject
.
h
"
#
include
"
vm
/
FrameIter
.
h
"
#
include
"
vm
/
JSAtom
.
h
"
#
include
"
vm
/
JSContext
.
h
"
#
include
"
vm
/
JSObject
.
h
"
#
include
"
vm
/
JSScript
.
h
"
#
include
"
vm
/
Realm
.
h
"
#
include
"
vm
/
SavedFrame
.
h
"
#
include
"
vm
/
SavedStacks
.
h
"
#
include
"
vm
/
SelfHosting
.
h
"
#
include
"
vm
/
Stack
.
h
"
#
include
"
vm
/
StringType
.
h
"
#
include
"
vm
/
SymbolType
.
h
"
#
include
"
vm
/
WellKnownAtom
.
h
"
#
include
"
wasm
/
WasmJS
.
h
"
#
include
"
vm
/
Compartment
-
inl
.
h
"
#
include
"
vm
/
ErrorObject
-
inl
.
h
"
#
include
"
vm
/
JSContext
-
inl
.
h
"
#
include
"
vm
/
JSObject
-
inl
.
h
"
#
include
"
vm
/
ObjectOperations
-
inl
.
h
"
#
include
"
vm
/
SavedStacks
-
inl
.
h
"
using
namespace
js
;
using
JS
:
:
SavedFrameSelfHosted
;
size_t
ExtraMallocSize
(
JSErrorReport
*
report
)
{
if
(
report
-
>
linebuf
(
)
)
{
return
(
report
-
>
linebufLength
(
)
+
1
)
*
sizeof
(
char16_t
)
+
1
;
}
return
0
;
}
size_t
ExtraMallocSize
(
JSErrorNotes
:
:
Note
*
note
)
{
return
0
;
}
bool
CopyExtraData
(
JSContext
*
cx
uint8_t
*
*
cursor
JSErrorReport
*
copy
JSErrorReport
*
report
)
{
if
(
report
-
>
linebuf
(
)
)
{
size_t
alignment_backlog
=
0
;
if
(
size_t
(
*
cursor
)
%
2
)
{
(
*
cursor
)
+
+
;
}
else
{
alignment_backlog
=
1
;
}
size_t
linebufSize
=
(
report
-
>
linebufLength
(
)
+
1
)
*
sizeof
(
char16_t
)
;
const
char16_t
*
linebufCopy
=
(
const
char16_t
*
)
(
*
cursor
)
;
js_memcpy
(
*
cursor
report
-
>
linebuf
(
)
linebufSize
)
;
*
cursor
+
=
linebufSize
+
alignment_backlog
;
copy
-
>
initBorrowedLinebuf
(
linebufCopy
report
-
>
linebufLength
(
)
report
-
>
tokenOffset
(
)
)
;
}
copy
-
>
isMuted
=
report
-
>
isMuted
;
copy
-
>
exnType
=
report
-
>
exnType
;
copy
-
>
isWarning_
=
report
-
>
isWarning_
;
if
(
report
-
>
notes
)
{
auto
copiedNotes
=
report
-
>
notes
-
>
copy
(
cx
)
;
if
(
!
copiedNotes
)
{
return
false
;
}
copy
-
>
notes
=
std
:
:
move
(
copiedNotes
)
;
}
else
{
copy
-
>
notes
.
reset
(
nullptr
)
;
}
return
true
;
}
bool
CopyExtraData
(
JSContext
*
cx
uint8_t
*
*
cursor
JSErrorNotes
:
:
Note
*
copy
JSErrorNotes
:
:
Note
*
report
)
{
return
true
;
}
template
<
typename
T
>
static
UniquePtr
<
T
>
CopyErrorHelper
(
JSContext
*
cx
T
*
report
)
{
static_assert
(
sizeof
(
T
)
%
sizeof
(
const
char
*
)
=
=
0
)
;
static_assert
(
sizeof
(
const
char
*
)
%
sizeof
(
char16_t
)
=
=
0
)
;
size_t
filenameSize
=
report
-
>
filename
?
strlen
(
report
-
>
filename
)
+
1
:
0
;
size_t
messageSize
=
0
;
if
(
report
-
>
message
(
)
)
{
messageSize
=
strlen
(
report
-
>
message
(
)
.
c_str
(
)
)
+
1
;
}
size_t
mallocSize
=
sizeof
(
T
)
+
messageSize
+
filenameSize
+
ExtraMallocSize
(
report
)
;
uint8_t
*
cursor
=
cx
-
>
pod_calloc
<
uint8_t
>
(
mallocSize
)
;
if
(
!
cursor
)
{
return
nullptr
;
}
UniquePtr
<
T
>
copy
(
new
(
cursor
)
T
(
)
)
;
cursor
+
=
sizeof
(
T
)
;
if
(
report
-
>
message
(
)
)
{
copy
-
>
initBorrowedMessage
(
(
const
char
*
)
cursor
)
;
js_memcpy
(
cursor
report
-
>
message
(
)
.
c_str
(
)
messageSize
)
;
cursor
+
=
messageSize
;
}
if
(
report
-
>
filename
)
{
copy
-
>
filename
=
(
const
char
*
)
cursor
;
js_memcpy
(
cursor
report
-
>
filename
filenameSize
)
;
cursor
+
=
filenameSize
;
}
if
(
!
CopyExtraData
(
cx
&
cursor
copy
.
get
(
)
report
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
cursor
=
=
(
uint8_t
*
)
copy
.
get
(
)
+
mallocSize
)
;
copy
-
>
errorMessageName
=
report
-
>
errorMessageName
;
copy
-
>
sourceId
=
report
-
>
sourceId
;
copy
-
>
lineno
=
report
-
>
lineno
;
copy
-
>
column
=
report
-
>
column
;
copy
-
>
errorNumber
=
report
-
>
errorNumber
;
return
copy
;
}
UniquePtr
<
JSErrorNotes
:
:
Note
>
js
:
:
CopyErrorNote
(
JSContext
*
cx
JSErrorNotes
:
:
Note
*
note
)
{
return
CopyErrorHelper
(
cx
note
)
;
}
UniquePtr
<
JSErrorReport
>
js
:
:
CopyErrorReport
(
JSContext
*
cx
JSErrorReport
*
report
)
{
return
CopyErrorHelper
(
cx
report
)
;
}
struct
SuppressErrorsGuard
{
JSContext
*
cx
;
JS
:
:
WarningReporter
prevReporter
;
JS
:
:
AutoSaveExceptionState
prevState
;
explicit
SuppressErrorsGuard
(
JSContext
*
cx
)
:
cx
(
cx
)
prevReporter
(
JS
:
:
SetWarningReporter
(
cx
nullptr
)
)
prevState
(
cx
)
{
}
~
SuppressErrorsGuard
(
)
{
JS
:
:
SetWarningReporter
(
cx
prevReporter
)
;
}
}
;
static
const
size_t
MAX_REPORTED_STACK_DEPTH
=
1u
<
<
7
;
bool
js
:
:
CaptureStack
(
JSContext
*
cx
MutableHandleObject
stack
)
{
return
CaptureCurrentStack
(
cx
stack
JS
:
:
StackCapture
(
JS
:
:
MaxFrames
(
MAX_REPORTED_STACK_DEPTH
)
)
)
;
}
JSString
*
js
:
:
ComputeStackString
(
JSContext
*
cx
)
{
SuppressErrorsGuard
seg
(
cx
)
;
RootedObject
stack
(
cx
)
;
if
(
!
CaptureStack
(
cx
&
stack
)
)
{
return
nullptr
;
}
RootedString
str
(
cx
)
;
if
(
!
BuildStackString
(
cx
cx
-
>
realm
(
)
-
>
principals
(
)
stack
&
str
)
)
{
return
nullptr
;
}
return
str
.
get
(
)
;
}
JSErrorReport
*
js
:
:
ErrorFromException
(
JSContext
*
cx
HandleObject
objArg
)
{
RootedObject
obj
(
cx
UncheckedUnwrap
(
objArg
)
)
;
if
(
!
obj
-
>
is
<
ErrorObject
>
(
)
)
{
return
nullptr
;
}
JSErrorReport
*
report
=
obj
-
>
as
<
ErrorObject
>
(
)
.
getOrCreateErrorReport
(
cx
)
;
if
(
!
report
)
{
MOZ_ASSERT
(
cx
-
>
isThrowingOutOfMemory
(
)
)
;
cx
-
>
recoverFromOutOfMemory
(
)
;
}
return
report
;
}
JS_PUBLIC_API
JSObject
*
JS
:
:
ExceptionStackOrNull
(
HandleObject
objArg
)
{
ErrorObject
*
errorObject
=
objArg
-
>
maybeUnwrapIf
<
ErrorObject
>
(
)
;
if
(
errorObject
)
{
return
errorObject
-
>
stack
(
)
;
}
WasmExceptionObject
*
wasmObject
=
objArg
-
>
maybeUnwrapIf
<
WasmExceptionObject
>
(
)
;
if
(
wasmObject
)
{
return
wasmObject
-
>
stack
(
)
;
}
return
nullptr
;
}
JS_PUBLIC_API
JSLinearString
*
js
:
:
GetErrorTypeName
(
JSContext
*
cx
int16_t
exnType
)
{
if
(
exnType
<
0
|
|
exnType
>
=
JSEXN_LIMIT
|
|
exnType
=
=
JSEXN_INTERNALERR
|
|
exnType
=
=
JSEXN_WARN
|
|
exnType
=
=
JSEXN_NOTE
)
{
return
nullptr
;
}
JSProtoKey
key
=
GetExceptionProtoKey
(
JSExnType
(
exnType
)
)
;
return
ClassName
(
key
cx
)
;
}
void
js
:
:
ErrorToException
(
JSContext
*
cx
JSErrorReport
*
reportp
JSErrorCallback
callback
void
*
userRef
)
{
MOZ_ASSERT
(
!
reportp
-
>
isWarning
(
)
)
;
JSErrNum
errorNumber
=
static_cast
<
JSErrNum
>
(
reportp
-
>
errorNumber
)
;
if
(
!
callback
)
{
callback
=
GetErrorMessage
;
}
const
JSErrorFormatString
*
errorString
=
callback
(
userRef
errorNumber
)
;
JSExnType
exnType
=
errorString
?
static_cast
<
JSExnType
>
(
errorString
-
>
exnType
)
:
JSEXN_ERR
;
MOZ_ASSERT
(
exnType
<
JSEXN_ERROR_LIMIT
)
;
if
(
cx
-
>
generatingError
)
{
return
;
}
cx
-
>
generatingError
=
true
;
auto
restore
=
mozilla
:
:
MakeScopeExit
(
[
cx
]
{
cx
-
>
generatingError
=
false
;
}
)
;
RootedString
messageStr
(
cx
reportp
-
>
newMessageString
(
cx
)
)
;
if
(
!
messageStr
)
{
return
;
}
Rooted
<
JSString
*
>
fileName
(
cx
)
;
if
(
const
char
*
filename
=
reportp
-
>
filename
)
{
fileName
=
JS_NewStringCopyUTF8N
(
cx
JS
:
:
UTF8Chars
(
filename
strlen
(
filename
)
)
)
;
if
(
!
fileName
)
{
return
;
}
}
else
{
fileName
=
cx
-
>
emptyString
(
)
;
}
uint32_t
sourceId
=
reportp
-
>
sourceId
;
uint32_t
lineNumber
=
reportp
-
>
lineno
;
uint32_t
columnNumber
=
reportp
-
>
column
;
auto
cause
=
JS
:
:
NothingHandleValue
;
RootedObject
stack
(
cx
)
;
if
(
!
CaptureStack
(
cx
&
stack
)
)
{
return
;
}
UniquePtr
<
JSErrorReport
>
report
=
CopyErrorReport
(
cx
reportp
)
;
if
(
!
report
)
{
return
;
}
ErrorObject
*
errObject
=
ErrorObject
:
:
create
(
cx
exnType
stack
fileName
sourceId
lineNumber
columnNumber
std
:
:
move
(
report
)
messageStr
cause
)
;
if
(
!
errObject
)
{
return
;
}
RootedValue
errValue
(
cx
ObjectValue
(
*
errObject
)
)
;
Rooted
<
SavedFrame
*
>
nstack
(
cx
)
;
if
(
stack
)
{
nstack
=
&
stack
-
>
as
<
SavedFrame
>
(
)
;
}
cx
-
>
setPendingException
(
errValue
nstack
)
;
}
using
SniffingBehavior
=
JS
:
:
ErrorReportBuilder
:
:
SniffingBehavior
;
static
bool
IsDuckTypedErrorObject
(
JSContext
*
cx
HandleObject
exnObject
const
char
*
*
filename_strp
)
{
AutoClearPendingException
acpe
(
cx
)
;
bool
found
;
if
(
!
JS_HasProperty
(
cx
exnObject
js_message_str
&
found
)
|
|
!
found
)
{
return
false
;
}
const
char
*
filename_str
=
*
filename_strp
;
if
(
!
JS_HasProperty
(
cx
exnObject
filename_str
&
found
)
)
{
return
false
;
}
if
(
!
found
)
{
filename_str
=
js_fileName_str
;
if
(
!
JS_HasProperty
(
cx
exnObject
filename_str
&
found
)
|
|
!
found
)
{
return
false
;
}
}
if
(
!
JS_HasProperty
(
cx
exnObject
js_lineNumber_str
&
found
)
|
|
!
found
)
{
return
false
;
}
*
filename_strp
=
filename_str
;
return
true
;
}
static
bool
GetPropertyNoException
(
JSContext
*
cx
HandleObject
obj
SniffingBehavior
behavior
Handle
<
PropertyName
*
>
name
MutableHandleValue
vp
)
{
if
(
GetPropertyPure
(
cx
obj
NameToId
(
name
)
vp
.
address
(
)
)
)
{
return
true
;
}
if
(
behavior
=
=
SniffingBehavior
:
:
WithSideEffects
)
{
AutoClearPendingException
acpe
(
cx
)
;
return
GetProperty
(
cx
obj
obj
name
vp
)
;
}
return
false
;
}
static
JSString
*
FormatErrorMessage
(
JSContext
*
cx
HandleString
name
HandleString
message
)
{
if
(
name
&
&
message
)
{
AutoClearPendingException
acpe
(
cx
)
;
JSStringBuilder
sb
(
cx
)
;
if
(
!
sb
.
append
(
name
)
|
|
!
sb
.
append
(
"
:
"
)
|
|
!
sb
.
append
(
message
)
)
{
return
nullptr
;
}
return
sb
.
finishString
(
)
;
}
return
name
?
name
:
message
;
}
static
JSString
*
ErrorReportToString
(
JSContext
*
cx
HandleObject
exn
JSErrorReport
*
reportp
SniffingBehavior
behavior
)
{
RootedString
name
(
cx
)
;
RootedValue
nameV
(
cx
)
;
if
(
GetPropertyNoException
(
cx
exn
behavior
cx
-
>
names
(
)
.
name
&
nameV
)
&
&
nameV
.
isString
(
)
)
{
name
=
nameV
.
toString
(
)
;
}
if
(
!
name
)
{
JSExnType
type
=
static_cast
<
JSExnType
>
(
reportp
-
>
exnType
)
;
if
(
type
!
=
JSEXN_WARN
&
&
type
!
=
JSEXN_NOTE
)
{
name
=
ClassName
(
GetExceptionProtoKey
(
type
)
cx
)
;
}
}
RootedString
message
(
cx
)
;
RootedValue
messageV
(
cx
)
;
if
(
GetPropertyNoException
(
cx
exn
behavior
cx
-
>
names
(
)
.
message
&
messageV
)
&
&
messageV
.
isString
(
)
)
{
message
=
messageV
.
toString
(
)
;
}
if
(
!
message
)
{
message
=
reportp
-
>
newMessageString
(
cx
)
;
if
(
!
message
)
{
return
nullptr
;
}
}
return
FormatErrorMessage
(
cx
name
message
)
;
}
JS
:
:
ErrorReportBuilder
:
:
ErrorReportBuilder
(
JSContext
*
cx
)
:
reportp
(
nullptr
)
exnObject
(
cx
)
{
}
JS
:
:
ErrorReportBuilder
:
:
~
ErrorReportBuilder
(
)
=
default
;
bool
JS
:
:
ErrorReportBuilder
:
:
init
(
JSContext
*
cx
const
JS
:
:
ExceptionStack
&
exnStack
SniffingBehavior
sniffingBehavior
)
{
MOZ_ASSERT
(
!
cx
-
>
isExceptionPending
(
)
)
;
MOZ_ASSERT
(
!
reportp
)
;
if
(
exnStack
.
exception
(
)
.
isObject
(
)
)
{
exnObject
=
&
exnStack
.
exception
(
)
.
toObject
(
)
;
reportp
=
ErrorFromException
(
cx
exnObject
)
;
}
RootedString
str
(
cx
)
;
if
(
reportp
)
{
str
=
ErrorReportToString
(
cx
exnObject
reportp
sniffingBehavior
)
;
}
else
if
(
exnStack
.
exception
(
)
.
isSymbol
(
)
)
{
RootedValue
strVal
(
cx
)
;
if
(
js
:
:
SymbolDescriptiveString
(
cx
exnStack
.
exception
(
)
.
toSymbol
(
)
&
strVal
)
)
{
str
=
strVal
.
toString
(
)
;
}
else
{
str
=
nullptr
;
}
}
else
if
(
exnObject
&
&
sniffingBehavior
=
=
NoSideEffects
)
{
str
=
cx
-
>
names
(
)
.
Object
;
}
else
{
str
=
js
:
:
ToString
<
CanGC
>
(
cx
exnStack
.
exception
(
)
)
;
}
if
(
!
str
)
{
cx
-
>
clearPendingException
(
)
;
}
const
char
*
filename_str
=
"
filename
"
;
if
(
!
reportp
&
&
exnObject
&
&
sniffingBehavior
=
=
WithSideEffects
&
&
IsDuckTypedErrorObject
(
cx
exnObject
&
filename_str
)
)
{
RootedValue
val
(
cx
)
;
RootedString
name
(
cx
)
;
if
(
JS_GetProperty
(
cx
exnObject
js_name_str
&
val
)
&
&
val
.
isString
(
)
)
{
name
=
val
.
toString
(
)
;
}
else
{
cx
-
>
clearPendingException
(
)
;
}
RootedString
msg
(
cx
)
;
if
(
JS_GetProperty
(
cx
exnObject
js_message_str
&
val
)
&
&
val
.
isString
(
)
)
{
msg
=
val
.
toString
(
)
;
}
else
{
cx
-
>
clearPendingException
(
)
;
}
str
=
FormatErrorMessage
(
cx
name
msg
)
;
{
AutoClearPendingException
acpe
(
cx
)
;
if
(
JS_GetProperty
(
cx
exnObject
filename_str
&
val
)
)
{
RootedString
tmp
(
cx
js
:
:
ToString
<
CanGC
>
(
cx
val
)
)
;
if
(
tmp
)
{
filename
=
JS_EncodeStringToUTF8
(
cx
tmp
)
;
}
}
}
if
(
!
filename
)
{
filename
=
DuplicateString
(
"
"
)
;
if
(
!
filename
)
{
ReportOutOfMemory
(
cx
)
;
return
false
;
}
}
uint32_t
lineno
;
if
(
!
JS_GetProperty
(
cx
exnObject
js_lineNumber_str
&
val
)
|
|
!
ToUint32
(
cx
val
&
lineno
)
)
{
cx
-
>
clearPendingException
(
)
;
lineno
=
0
;
}
uint32_t
column
;
if
(
!
JS_GetProperty
(
cx
exnObject
js_columnNumber_str
&
val
)
|
|
!
ToUint32
(
cx
val
&
column
)
)
{
cx
-
>
clearPendingException
(
)
;
column
=
0
;
}
reportp
=
&
ownedReport
;
new
(
reportp
)
JSErrorReport
(
)
;
ownedReport
.
filename
=
filename
.
get
(
)
;
ownedReport
.
lineno
=
lineno
;
ownedReport
.
exnType
=
JSEXN_INTERNALERR
;
ownedReport
.
column
=
column
;
if
(
str
)
{
if
(
auto
utf8
=
JS_EncodeStringToUTF8
(
cx
str
)
)
{
ownedReport
.
initOwnedMessage
(
utf8
.
release
(
)
)
;
}
else
{
cx
-
>
clearPendingException
(
)
;
str
=
nullptr
;
}
}
}
const
char
*
utf8Message
=
nullptr
;
if
(
str
)
{
toStringResultBytesStorage
=
JS_EncodeStringToUTF8
(
cx
str
)
;
utf8Message
=
toStringResultBytesStorage
.
get
(
)
;
if
(
!
utf8Message
)
{
cx
-
>
clearPendingException
(
)
;
}
}
if
(
!
utf8Message
)
{
utf8Message
=
"
unknown
(
can
'
t
convert
to
string
)
"
;
}
if
(
!
reportp
)
{
if
(
!
populateUncaughtExceptionReportUTF8
(
cx
exnStack
.
stack
(
)
utf8Message
)
)
{
return
false
;
}
}
else
{
toStringResult_
=
JS
:
:
ConstUTF8CharsZ
(
utf8Message
strlen
(
utf8Message
)
)
;
}
return
true
;
}
bool
JS
:
:
ErrorReportBuilder
:
:
populateUncaughtExceptionReportUTF8
(
JSContext
*
cx
HandleObject
stack
.
.
.
)
{
va_list
ap
;
va_start
(
ap
stack
)
;
bool
ok
=
populateUncaughtExceptionReportUTF8VA
(
cx
stack
ap
)
;
va_end
(
ap
)
;
return
ok
;
}
bool
JS
:
:
ErrorReportBuilder
:
:
populateUncaughtExceptionReportUTF8VA
(
JSContext
*
cx
HandleObject
stack
va_list
ap
)
{
new
(
&
ownedReport
)
JSErrorReport
(
)
;
ownedReport
.
isWarning_
=
false
;
ownedReport
.
errorNumber
=
JSMSG_UNCAUGHT_EXCEPTION
;
bool
skippedAsync
;
Rooted
<
SavedFrame
*
>
frame
(
cx
UnwrapSavedFrame
(
cx
cx
-
>
realm
(
)
-
>
principals
(
)
stack
SavedFrameSelfHosted
:
:
Exclude
skippedAsync
)
)
;
if
(
frame
)
{
filename
=
StringToNewUTF8CharsZ
(
cx
*
frame
-
>
getSource
(
)
)
;
if
(
!
filename
)
{
return
false
;
}
ownedReport
.
filename
=
filename
.
get
(
)
;
ownedReport
.
sourceId
=
frame
-
>
getSourceId
(
)
;
ownedReport
.
lineno
=
frame
-
>
getLine
(
)
;
ownedReport
.
column
=
frame
-
>
isWasm
(
)
?
1
:
frame
-
>
getColumn
(
)
;
ownedReport
.
isMuted
=
frame
-
>
getMutedErrors
(
)
;
}
else
{
NonBuiltinFrameIter
iter
(
cx
cx
-
>
realm
(
)
-
>
principals
(
)
)
;
if
(
!
iter
.
done
(
)
)
{
ownedReport
.
filename
=
iter
.
filename
(
)
;
uint32_t
column
;
ownedReport
.
sourceId
=
iter
.
hasScript
(
)
?
iter
.
script
(
)
-
>
scriptSource
(
)
-
>
id
(
)
:
0
;
ownedReport
.
lineno
=
iter
.
computeLine
(
&
column
)
;
ownedReport
.
column
=
FixupColumnForDisplay
(
column
)
;
ownedReport
.
isMuted
=
iter
.
mutedErrors
(
)
;
}
}
AutoReportFrontendContext
fc
(
cx
)
;
if
(
!
ExpandErrorArgumentsVA
(
&
fc
GetErrorMessage
nullptr
JSMSG_UNCAUGHT_EXCEPTION
ArgumentsAreUTF8
&
ownedReport
ap
)
)
{
return
false
;
}
toStringResult_
=
ownedReport
.
message
(
)
;
reportp
=
&
ownedReport
;
return
true
;
}
JSObject
*
js
:
:
CopyErrorObject
(
JSContext
*
cx
Handle
<
ErrorObject
*
>
err
)
{
UniquePtr
<
JSErrorReport
>
copyReport
;
if
(
JSErrorReport
*
errorReport
=
err
-
>
getErrorReport
(
)
)
{
copyReport
=
CopyErrorReport
(
cx
errorReport
)
;
if
(
!
copyReport
)
{
return
nullptr
;
}
}
RootedString
message
(
cx
err
-
>
getMessage
(
)
)
;
if
(
message
&
&
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
message
)
)
{
return
nullptr
;
}
RootedString
fileName
(
cx
err
-
>
fileName
(
cx
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
fileName
)
)
{
return
nullptr
;
}
RootedObject
stack
(
cx
err
-
>
stack
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
stack
)
)
{
return
nullptr
;
}
if
(
stack
&
&
JS_IsDeadWrapper
(
stack
)
)
{
stack
=
nullptr
;
}
Rooted
<
mozilla
:
:
Maybe
<
Value
>
>
cause
(
cx
mozilla
:
:
Nothing
(
)
)
;
if
(
auto
maybeCause
=
err
-
>
getCause
(
)
)
{
RootedValue
errorCause
(
cx
maybeCause
.
value
(
)
)
;
if
(
!
cx
-
>
compartment
(
)
-
>
wrap
(
cx
&
errorCause
)
)
{
return
nullptr
;
}
cause
=
mozilla
:
:
Some
(
errorCause
.
get
(
)
)
;
}
uint32_t
sourceId
=
err
-
>
sourceId
(
)
;
uint32_t
lineNumber
=
err
-
>
lineNumber
(
)
;
uint32_t
columnNumber
=
err
-
>
columnNumber
(
)
;
JSExnType
errorType
=
err
-
>
type
(
)
;
return
ErrorObject
:
:
create
(
cx
errorType
stack
fileName
sourceId
lineNumber
columnNumber
std
:
:
move
(
copyReport
)
message
cause
)
;
}
JS_PUBLIC_API
bool
JS
:
:
CreateError
(
JSContext
*
cx
JSExnType
type
HandleObject
stack
HandleString
fileName
uint32_t
lineNumber
uint32_t
columnNumber
JSErrorReport
*
report
HandleString
message
Handle
<
mozilla
:
:
Maybe
<
Value
>
>
cause
MutableHandleValue
rval
)
{
cx
-
>
check
(
stack
fileName
message
)
;
AssertObjectIsSavedFrameOrWrapper
(
cx
stack
)
;
js
:
:
UniquePtr
<
JSErrorReport
>
rep
;
if
(
report
)
{
rep
=
CopyErrorReport
(
cx
report
)
;
if
(
!
rep
)
{
return
false
;
}
}
JSObject
*
obj
=
js
:
:
ErrorObject
:
:
create
(
cx
type
stack
fileName
0
lineNumber
columnNumber
std
:
:
move
(
rep
)
message
cause
)
;
if
(
!
obj
)
{
return
false
;
}
rval
.
setObject
(
*
obj
)
;
return
true
;
}
const
char
*
js
:
:
ValueToSourceForError
(
JSContext
*
cx
HandleValue
val
UniqueChars
&
bytes
)
{
if
(
val
.
isUndefined
(
)
)
{
return
"
undefined
"
;
}
if
(
val
.
isNull
(
)
)
{
return
"
null
"
;
}
AutoClearPendingException
acpe
(
cx
)
;
RootedString
str
(
cx
JS_ValueToSource
(
cx
val
)
)
;
if
(
!
str
)
{
return
"
<
<
error
converting
value
to
string
>
>
"
;
}
JSStringBuilder
sb
(
cx
)
;
if
(
val
.
hasObjectPayload
(
)
)
{
RootedObject
valObj
(
cx
&
val
.
getObjectPayload
(
)
)
;
ESClass
cls
;
if
(
!
JS
:
:
GetBuiltinClass
(
cx
valObj
&
cls
)
)
{
return
"
<
<
error
determining
class
of
value
>
>
"
;
}
const
char
*
s
;
if
(
cls
=
=
ESClass
:
:
Array
)
{
s
=
"
the
array
"
;
}
else
if
(
cls
=
=
ESClass
:
:
ArrayBuffer
)
{
s
=
"
the
array
buffer
"
;
}
else
if
(
JS_IsArrayBufferViewObject
(
valObj
)
)
{
s
=
"
the
typed
array
"
;
#
ifdef
ENABLE_RECORD_TUPLE
}
else
if
(
cls
=
=
ESClass
:
:
Record
)
{
s
=
"
the
record
"
;
}
else
if
(
cls
=
=
ESClass
:
:
Tuple
)
{
s
=
"
the
tuple
"
;
#
endif
}
else
{
s
=
"
the
object
"
;
}
if
(
!
sb
.
append
(
s
strlen
(
s
)
)
)
{
return
"
<
<
error
converting
value
to
string
>
>
"
;
}
}
else
if
(
val
.
isNumber
(
)
)
{
if
(
!
sb
.
append
(
"
the
number
"
)
)
{
return
"
<
<
error
converting
value
to
string
>
>
"
;
}
}
else
if
(
val
.
isString
(
)
)
{
if
(
!
sb
.
append
(
"
the
string
"
)
)
{
return
"
<
<
error
converting
value
to
string
>
>
"
;
}
}
else
if
(
val
.
isBigInt
(
)
)
{
if
(
!
sb
.
append
(
"
the
BigInt
"
)
)
{
return
"
<
<
error
converting
value
to
string
>
>
"
;
}
}
else
{
MOZ_ASSERT
(
val
.
isBoolean
(
)
|
|
val
.
isSymbol
(
)
)
;
bytes
=
StringToNewUTF8CharsZ
(
cx
*
str
)
;
return
bytes
.
get
(
)
;
}
if
(
!
sb
.
append
(
str
)
)
{
return
"
<
<
error
converting
value
to
string
>
>
"
;
}
str
=
sb
.
finishString
(
)
;
if
(
!
str
)
{
return
"
<
<
error
converting
value
to
string
>
>
"
;
}
bytes
=
StringToNewUTF8CharsZ
(
cx
*
str
)
;
return
bytes
.
get
(
)
;
}
bool
js
:
:
GetInternalError
(
JSContext
*
cx
unsigned
errorNumber
MutableHandleValue
error
)
{
FixedInvokeArgs
<
1
>
args
(
cx
)
;
args
[
0
]
.
set
(
Int32Value
(
errorNumber
)
)
;
return
CallSelfHostedFunction
(
cx
cx
-
>
names
(
)
.
GetInternalError
NullHandleValue
args
error
)
;
}
bool
js
:
:
GetTypeError
(
JSContext
*
cx
unsigned
errorNumber
MutableHandleValue
error
)
{
FixedInvokeArgs
<
1
>
args
(
cx
)
;
args
[
0
]
.
set
(
Int32Value
(
errorNumber
)
)
;
return
CallSelfHostedFunction
(
cx
cx
-
>
names
(
)
.
GetTypeError
NullHandleValue
args
error
)
;
}
bool
js
:
:
GetAggregateError
(
JSContext
*
cx
unsigned
errorNumber
MutableHandleValue
error
)
{
FixedInvokeArgs
<
1
>
args
(
cx
)
;
args
[
0
]
.
set
(
Int32Value
(
errorNumber
)
)
;
return
CallSelfHostedFunction
(
cx
cx
-
>
names
(
)
.
GetAggregateError
NullHandleValue
args
error
)
;
}
JS_PUBLIC_API
mozilla
:
:
Maybe
<
Value
>
JS
:
:
GetExceptionCause
(
JSObject
*
exc
)
{
if
(
!
exc
-
>
is
<
ErrorObject
>
(
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
auto
&
error
=
exc
-
>
as
<
ErrorObject
>
(
)
;
return
error
.
getCause
(
)
;
}
