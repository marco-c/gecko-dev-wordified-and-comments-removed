#
ifndef
js_Value_h
#
define
js_Value_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
<
limits
>
#
include
"
js
-
config
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Utility
.
h
"
namespace
JS
{
class
Value
;
}
#
define
JSVAL_INT_BITS
32
#
define
JSVAL_INT_MIN
(
(
int32_t
)
0x80000000
)
#
define
JSVAL_INT_MAX
(
(
int32_t
)
0x7fffffff
)
#
if
defined
(
JS_PUNBOX64
)
#
define
JSVAL_TAG_SHIFT
47
#
endif
#
if
defined
(
_MSC_VER
)
#
define
JS_ENUM_HEADER
(
id
type
)
enum
id
:
type
#
define
JS_ENUM_FOOTER
(
id
)
#
else
#
define
JS_ENUM_HEADER
(
id
type
)
enum
id
#
define
JS_ENUM_FOOTER
(
id
)
__attribute__
(
(
packed
)
)
#
endif
JS_ENUM_HEADER
(
JSValueType
uint8_t
)
{
JSVAL_TYPE_DOUBLE
=
0x00
JSVAL_TYPE_INT32
=
0x01
JSVAL_TYPE_UNDEFINED
=
0x02
JSVAL_TYPE_BOOLEAN
=
0x03
JSVAL_TYPE_MAGIC
=
0x04
JSVAL_TYPE_STRING
=
0x05
JSVAL_TYPE_SYMBOL
=
0x06
JSVAL_TYPE_PRIVATE_GCTHING
=
0x07
JSVAL_TYPE_NULL
=
0x08
JSVAL_TYPE_OBJECT
=
0x0c
JSVAL_TYPE_UNKNOWN
=
0x20
JSVAL_TYPE_MISSING
=
0x21
}
JS_ENUM_FOOTER
(
JSValueType
)
;
static_assert
(
sizeof
(
JSValueType
)
=
=
1
"
compiler
typed
enum
support
is
apparently
buggy
"
)
;
#
if
defined
(
JS_NUNBOX32
)
JS_ENUM_HEADER
(
JSValueTag
uint32_t
)
{
JSVAL_TAG_CLEAR
=
0xFFFFFF80
JSVAL_TAG_INT32
=
JSVAL_TAG_CLEAR
|
JSVAL_TYPE_INT32
JSVAL_TAG_UNDEFINED
=
JSVAL_TAG_CLEAR
|
JSVAL_TYPE_UNDEFINED
JSVAL_TAG_STRING
=
JSVAL_TAG_CLEAR
|
JSVAL_TYPE_STRING
JSVAL_TAG_SYMBOL
=
JSVAL_TAG_CLEAR
|
JSVAL_TYPE_SYMBOL
JSVAL_TAG_BOOLEAN
=
JSVAL_TAG_CLEAR
|
JSVAL_TYPE_BOOLEAN
JSVAL_TAG_MAGIC
=
JSVAL_TAG_CLEAR
|
JSVAL_TYPE_MAGIC
JSVAL_TAG_NULL
=
JSVAL_TAG_CLEAR
|
JSVAL_TYPE_NULL
JSVAL_TAG_OBJECT
=
JSVAL_TAG_CLEAR
|
JSVAL_TYPE_OBJECT
JSVAL_TAG_PRIVATE_GCTHING
=
JSVAL_TAG_CLEAR
|
JSVAL_TYPE_PRIVATE_GCTHING
}
JS_ENUM_FOOTER
(
JSValueTag
)
;
static_assert
(
sizeof
(
JSValueTag
)
=
=
sizeof
(
uint32_t
)
"
compiler
typed
enum
support
is
apparently
buggy
"
)
;
#
elif
defined
(
JS_PUNBOX64
)
JS_ENUM_HEADER
(
JSValueTag
uint32_t
)
{
JSVAL_TAG_MAX_DOUBLE
=
0x1FFF0
JSVAL_TAG_INT32
=
JSVAL_TAG_MAX_DOUBLE
|
JSVAL_TYPE_INT32
JSVAL_TAG_UNDEFINED
=
JSVAL_TAG_MAX_DOUBLE
|
JSVAL_TYPE_UNDEFINED
JSVAL_TAG_STRING
=
JSVAL_TAG_MAX_DOUBLE
|
JSVAL_TYPE_STRING
JSVAL_TAG_SYMBOL
=
JSVAL_TAG_MAX_DOUBLE
|
JSVAL_TYPE_SYMBOL
JSVAL_TAG_BOOLEAN
=
JSVAL_TAG_MAX_DOUBLE
|
JSVAL_TYPE_BOOLEAN
JSVAL_TAG_MAGIC
=
JSVAL_TAG_MAX_DOUBLE
|
JSVAL_TYPE_MAGIC
JSVAL_TAG_NULL
=
JSVAL_TAG_MAX_DOUBLE
|
JSVAL_TYPE_NULL
JSVAL_TAG_OBJECT
=
JSVAL_TAG_MAX_DOUBLE
|
JSVAL_TYPE_OBJECT
JSVAL_TAG_PRIVATE_GCTHING
=
JSVAL_TAG_MAX_DOUBLE
|
JSVAL_TYPE_PRIVATE_GCTHING
}
JS_ENUM_FOOTER
(
JSValueTag
)
;
static_assert
(
sizeof
(
JSValueTag
)
=
=
sizeof
(
uint32_t
)
"
compiler
typed
enum
support
is
apparently
buggy
"
)
;
JS_ENUM_HEADER
(
JSValueShiftedTag
uint64_t
)
{
JSVAL_SHIFTED_TAG_MAX_DOUBLE
=
(
(
(
(
uint64_t
)
JSVAL_TAG_MAX_DOUBLE
)
<
<
JSVAL_TAG_SHIFT
)
|
0xFFFFFFFF
)
JSVAL_SHIFTED_TAG_INT32
=
(
(
(
uint64_t
)
JSVAL_TAG_INT32
)
<
<
JSVAL_TAG_SHIFT
)
JSVAL_SHIFTED_TAG_UNDEFINED
=
(
(
(
uint64_t
)
JSVAL_TAG_UNDEFINED
)
<
<
JSVAL_TAG_SHIFT
)
JSVAL_SHIFTED_TAG_STRING
=
(
(
(
uint64_t
)
JSVAL_TAG_STRING
)
<
<
JSVAL_TAG_SHIFT
)
JSVAL_SHIFTED_TAG_SYMBOL
=
(
(
(
uint64_t
)
JSVAL_TAG_SYMBOL
)
<
<
JSVAL_TAG_SHIFT
)
JSVAL_SHIFTED_TAG_BOOLEAN
=
(
(
(
uint64_t
)
JSVAL_TAG_BOOLEAN
)
<
<
JSVAL_TAG_SHIFT
)
JSVAL_SHIFTED_TAG_MAGIC
=
(
(
(
uint64_t
)
JSVAL_TAG_MAGIC
)
<
<
JSVAL_TAG_SHIFT
)
JSVAL_SHIFTED_TAG_NULL
=
(
(
(
uint64_t
)
JSVAL_TAG_NULL
)
<
<
JSVAL_TAG_SHIFT
)
JSVAL_SHIFTED_TAG_OBJECT
=
(
(
(
uint64_t
)
JSVAL_TAG_OBJECT
)
<
<
JSVAL_TAG_SHIFT
)
JSVAL_SHIFTED_TAG_PRIVATE_GCTHING
=
(
(
(
uint64_t
)
JSVAL_TAG_PRIVATE_GCTHING
)
<
<
JSVAL_TAG_SHIFT
)
}
JS_ENUM_FOOTER
(
JSValueShiftedTag
)
;
static_assert
(
sizeof
(
JSValueShiftedTag
)
=
=
sizeof
(
uint64_t
)
"
compiler
typed
enum
support
is
apparently
buggy
"
)
;
#
endif
#
undef
JS_ENUM_HEADER
#
undef
JS_ENUM_FOOTER
#
if
defined
(
JS_NUNBOX32
)
#
define
JSVAL_TYPE_TO_TAG
(
type
)
(
(
JSValueTag
)
(
JSVAL_TAG_CLEAR
|
(
type
)
)
)
#
define
JSVAL_LOWER_INCL_TAG_OF_OBJ_OR_NULL_SET
JSVAL_TAG_NULL
#
define
JSVAL_UPPER_EXCL_TAG_OF_PRIMITIVE_SET
JSVAL_TAG_OBJECT
#
define
JSVAL_UPPER_INCL_TAG_OF_NUMBER_SET
JSVAL_TAG_INT32
#
define
JSVAL_LOWER_INCL_TAG_OF_GCTHING_SET
JSVAL_TAG_STRING
#
elif
defined
(
JS_PUNBOX64
)
#
define
JSVAL_PAYLOAD_MASK
0x00007FFFFFFFFFFFLL
#
define
JSVAL_TAG_MASK
0xFFFF800000000000LL
#
define
JSVAL_TYPE_TO_TAG
(
type
)
(
(
JSValueTag
)
(
JSVAL_TAG_MAX_DOUBLE
|
(
type
)
)
)
#
define
JSVAL_TYPE_TO_SHIFTED_TAG
(
type
)
(
(
(
uint64_t
)
JSVAL_TYPE_TO_TAG
(
type
)
)
<
<
JSVAL_TAG_SHIFT
)
#
define
JSVAL_LOWER_INCL_TAG_OF_OBJ_OR_NULL_SET
JSVAL_TAG_NULL
#
define
JSVAL_UPPER_EXCL_TAG_OF_PRIMITIVE_SET
JSVAL_TAG_OBJECT
#
define
JSVAL_UPPER_INCL_TAG_OF_NUMBER_SET
JSVAL_TAG_INT32
#
define
JSVAL_LOWER_INCL_TAG_OF_GCTHING_SET
JSVAL_TAG_STRING
#
define
JSVAL_LOWER_INCL_SHIFTED_TAG_OF_OBJ_OR_NULL_SET
JSVAL_SHIFTED_TAG_NULL
#
define
JSVAL_UPPER_EXCL_SHIFTED_TAG_OF_PRIMITIVE_SET
JSVAL_SHIFTED_TAG_OBJECT
#
define
JSVAL_UPPER_EXCL_SHIFTED_TAG_OF_NUMBER_SET
JSVAL_SHIFTED_TAG_UNDEFINED
#
define
JSVAL_LOWER_INCL_SHIFTED_TAG_OF_GCTHING_SET
JSVAL_SHIFTED_TAG_STRING
#
endif
typedef
enum
JSWhyMagic
{
JS_ELEMENTS_HOLE
JS_NO_ITER_VALUE
JS_GENERATOR_CLOSING
JS_NO_CONSTANT
JS_THIS_POISON
JS_ARG_POISON
JS_SERIALIZE_NO_NODE
JS_LAZY_ARGUMENTS
JS_OPTIMIZED_ARGUMENTS
JS_IS_CONSTRUCTING
JS_BLOCK_NEEDS_CLONE
JS_HASH_KEY_EMPTY
JS_ION_ERROR
JS_ION_BAILOUT
JS_OPTIMIZED_OUT
JS_UNINITIALIZED_LEXICAL
JS_GENERIC_MAGIC
JS_WHY_MAGIC_COUNT
}
JSWhyMagic
;
#
if
MOZ_LITTLE_ENDIAN
#
if
defined
(
JS_NUNBOX32
)
union
MOZ_NON_PARAM
alignas
(
8
)
jsval_layout
{
uint64_t
asBits
;
struct
{
union
{
int32_t
i32
;
uint32_t
u32
;
uint32_t
boo
;
JSString
*
str
;
JS
:
:
Symbol
*
sym
;
JSObject
*
obj
;
js
:
:
gc
:
:
Cell
*
cell
;
void
*
ptr
;
JSWhyMagic
why
;
size_t
word
;
uintptr_t
uintptr
;
}
payload
;
JSValueTag
tag
;
}
s
;
double
asDouble
;
void
*
asPtr
;
}
;
#
elif
defined
(
JS_PUNBOX64
)
union
MOZ_NON_PARAM
alignas
(
8
)
jsval_layout
{
uint64_t
asBits
;
#
if
!
defined
(
_WIN64
)
struct
{
uint64_t
payload47
:
47
;
JSValueTag
tag
:
17
;
}
debugView
;
#
endif
struct
{
union
{
int32_t
i32
;
uint32_t
u32
;
JSWhyMagic
why
;
}
payload
;
}
s
;
double
asDouble
;
void
*
asPtr
;
size_t
asWord
;
uintptr_t
asUIntPtr
;
}
;
#
endif
#
else
#
if
defined
(
JS_NUNBOX32
)
union
MOZ_NON_PARAM
alignas
(
8
)
jsval_layout
{
uint64_t
asBits
;
struct
{
JSValueTag
tag
;
union
{
int32_t
i32
;
uint32_t
u32
;
uint32_t
boo
;
JSString
*
str
;
JS
:
:
Symbol
*
sym
;
JSObject
*
obj
;
js
:
:
gc
:
:
Cell
*
cell
;
void
*
ptr
;
JSWhyMagic
why
;
size_t
word
;
uintptr_t
uintptr
;
}
payload
;
}
s
;
double
asDouble
;
void
*
asPtr
;
}
;
#
elif
defined
(
JS_PUNBOX64
)
union
MOZ_NON_PARAM
alignas
(
8
)
jsval_layout
{
uint64_t
asBits
;
struct
{
JSValueTag
tag
:
17
;
uint64_t
payload47
:
47
;
}
debugView
;
struct
{
uint32_t
padding
;
union
{
int32_t
i32
;
uint32_t
u32
;
JSWhyMagic
why
;
}
payload
;
}
s
;
double
asDouble
;
void
*
asPtr
;
size_t
asWord
;
uintptr_t
asUIntPtr
;
}
;
#
endif
#
endif
JS_STATIC_ASSERT
(
sizeof
(
jsval_layout
)
=
=
8
)
;
#
if
defined
(
__clang__
)
#
if
__has_feature
(
cxx_constexpr
)
&
&
__has_feature
(
cxx_defaulted_functions
)
#
define
JS_VALUE_IS_CONSTEXPR
#
endif
#
elif
defined
(
__GNUC__
)
#
if
MOZ_GCC_VERSION_AT_LEAST
(
4
7
3
)
#
define
JS_VALUE_IS_CONSTEXPR
#
endif
#
endif
#
if
defined
(
JS_VALUE_IS_CONSTEXPR
)
#
define
JS_VALUE_CONSTEXPR
constexpr
#
define
JS_VALUE_CONSTEXPR_VAR
constexpr
#
else
#
define
JS_VALUE_CONSTEXPR
#
define
JS_VALUE_CONSTEXPR_VAR
const
#
endif
#
if
defined
(
JS_NUNBOX32
)
static
inline
int32_t
JSVAL_TO_INT32_IMPL
(
const
jsval_layout
&
l
)
{
return
l
.
s
.
payload
.
i32
;
}
static
inline
JSString
*
JSVAL_TO_STRING_IMPL
(
const
jsval_layout
&
l
)
{
return
l
.
s
.
payload
.
str
;
}
static
inline
JS
:
:
Symbol
*
JSVAL_TO_SYMBOL_IMPL
(
const
jsval_layout
&
l
)
{
return
l
.
s
.
payload
.
sym
;
}
static
inline
bool
JSVAL_TO_BOOLEAN_IMPL
(
const
jsval_layout
&
l
)
{
return
bool
(
l
.
s
.
payload
.
boo
)
;
}
static
inline
JSObject
*
JSVAL_TO_OBJECT_IMPL
(
const
jsval_layout
&
l
)
{
return
l
.
s
.
payload
.
obj
;
}
static
inline
void
*
JSVAL_TO_PRIVATE_PTR_IMPL
(
const
jsval_layout
&
l
)
{
return
l
.
s
.
payload
.
ptr
;
}
static
inline
js
:
:
gc
:
:
Cell
*
JSVAL_TO_GCTHING_IMPL
(
const
jsval_layout
&
l
)
{
return
l
.
s
.
payload
.
cell
;
}
static
inline
JSValueType
JSVAL_EXTRACT_NON_DOUBLE_TYPE_IMPL
(
const
jsval_layout
&
l
)
{
uint32_t
type
=
l
.
s
.
tag
&
0xF
;
MOZ_ASSERT
(
type
>
JSVAL_TYPE_DOUBLE
)
;
return
(
JSValueType
)
type
;
}
#
elif
defined
(
JS_PUNBOX64
)
static
inline
int32_t
JSVAL_TO_INT32_IMPL
(
const
jsval_layout
&
l
)
{
return
(
int32_t
)
l
.
asBits
;
}
static
inline
JSString
*
JSVAL_TO_STRING_IMPL
(
const
jsval_layout
&
l
)
{
return
(
JSString
*
)
(
l
.
asBits
&
JSVAL_PAYLOAD_MASK
)
;
}
static
inline
JS
:
:
Symbol
*
JSVAL_TO_SYMBOL_IMPL
(
const
jsval_layout
&
l
)
{
return
(
JS
:
:
Symbol
*
)
(
l
.
asBits
&
JSVAL_PAYLOAD_MASK
)
;
}
static
inline
bool
JSVAL_TO_BOOLEAN_IMPL
(
const
jsval_layout
&
l
)
{
return
(
bool
)
(
l
.
asBits
&
JSVAL_PAYLOAD_MASK
)
;
}
static
inline
JSObject
*
JSVAL_TO_OBJECT_IMPL
(
const
jsval_layout
&
l
)
{
uint64_t
ptrBits
=
l
.
asBits
&
JSVAL_PAYLOAD_MASK
;
MOZ_ASSERT
(
(
ptrBits
&
0x7
)
=
=
0
)
;
return
(
JSObject
*
)
ptrBits
;
}
static
inline
js
:
:
gc
:
:
Cell
*
JSVAL_TO_GCTHING_IMPL
(
const
jsval_layout
&
l
)
{
uint64_t
ptrBits
=
l
.
asBits
&
JSVAL_PAYLOAD_MASK
;
MOZ_ASSERT
(
(
ptrBits
&
0x7
)
=
=
0
)
;
return
reinterpret_cast
<
js
:
:
gc
:
:
Cell
*
>
(
ptrBits
)
;
}
static
inline
void
*
JSVAL_TO_PRIVATE_PTR_IMPL
(
const
jsval_layout
&
l
)
{
MOZ_ASSERT
(
(
l
.
asBits
&
0x8000000000000000LL
)
=
=
0
)
;
return
(
void
*
)
(
l
.
asBits
<
<
1
)
;
}
static
inline
JSValueType
JSVAL_EXTRACT_NON_DOUBLE_TYPE_IMPL
(
const
jsval_layout
&
l
)
{
uint64_t
type
=
(
l
.
asBits
>
>
JSVAL_TAG_SHIFT
)
&
0xF
;
MOZ_ASSERT
(
type
>
JSVAL_TYPE_DOUBLE
)
;
return
(
JSValueType
)
type
;
}
#
endif
static
inline
jsval_layout
JSVAL_TO_IMPL
(
const
JS
:
:
Value
&
v
)
;
static
inline
JS_VALUE_CONSTEXPR
JS
:
:
Value
IMPL_TO_JSVAL
(
const
jsval_layout
&
l
)
;
namespace
JS
{
static
inline
JS_VALUE_CONSTEXPR
JS
:
:
Value
UndefinedValue
(
)
;
static
inline
JS
:
:
Value
PoisonedObjectValue
(
JSObject
*
obj
)
;
static
MOZ_ALWAYS_INLINE
double
GenericNaN
(
)
{
return
mozilla
:
:
SpecificNaN
<
double
>
(
0
0x8000000000000ULL
)
;
}
#
if
defined
(
_MSC_VER
)
#
pragma
optimize
(
"
g
"
off
)
#
endif
static
inline
double
CanonicalizeNaN
(
double
d
)
{
if
(
MOZ_UNLIKELY
(
mozilla
:
:
IsNaN
(
d
)
)
)
return
GenericNaN
(
)
;
return
d
;
}
#
if
defined
(
_MSC_VER
)
#
pragma
optimize
(
"
"
on
)
#
endif
class
Value
{
public
:
#
if
defined
(
JS_NUNBOX32
)
using
PayloadType
=
uint32_t
;
#
elif
defined
(
JS_PUNBOX64
)
using
PayloadType
=
uint64_t
;
#
endif
#
if
defined
(
JS_VALUE_IS_CONSTEXPR
)
Value
(
)
=
default
;
Value
(
const
Value
&
v
)
=
default
;
#
endif
template
<
typename
T
>
static
bool
isNumberRepresentable
(
const
T
t
)
{
return
T
(
double
(
t
)
)
=
=
t
;
}
void
setNull
(
)
{
data
.
asBits
=
bitsFromTagAndPayload
(
JSVAL_TAG_NULL
0
)
;
}
void
setUndefined
(
)
{
data
.
asBits
=
bitsFromTagAndPayload
(
JSVAL_TAG_UNDEFINED
0
)
;
}
void
setInt32
(
int32_t
i
)
{
data
.
asBits
=
bitsFromTagAndPayload
(
JSVAL_TAG_INT32
uint32_t
(
i
)
)
;
}
int32_t
&
getInt32Ref
(
)
{
MOZ_ASSERT
(
isInt32
(
)
)
;
return
data
.
s
.
payload
.
i32
;
}
void
setDouble
(
double
d
)
{
setDoubleNoCheck
(
d
)
;
MOZ_ASSERT
(
isDouble
(
)
)
;
}
void
setDoubleNoCheck
(
double
d
)
{
data
.
asDouble
=
d
;
}
void
setNaN
(
)
{
setDouble
(
GenericNaN
(
)
)
;
}
double
&
getDoubleRef
(
)
{
MOZ_ASSERT
(
isDouble
(
)
)
;
return
data
.
asDouble
;
}
void
setString
(
JSString
*
str
)
{
MOZ_ASSERT
(
uintptr_t
(
str
)
>
0x1000
)
;
data
.
asBits
=
bitsFromTagAndPayload
(
JSVAL_TAG_STRING
PayloadType
(
str
)
)
;
}
void
setSymbol
(
JS
:
:
Symbol
*
sym
)
{
MOZ_ASSERT
(
uintptr_t
(
sym
)
>
0x1000
)
;
data
.
asBits
=
bitsFromTagAndPayload
(
JSVAL_TAG_SYMBOL
PayloadType
(
sym
)
)
;
}
void
setObject
(
JSObject
&
obj
)
{
MOZ_ASSERT
(
uintptr_t
(
&
obj
)
>
0x1000
|
|
uintptr_t
(
&
obj
)
=
=
0x48
)
;
#
if
defined
(
JS_PUNBOX64
)
MOZ_ASSERT
(
(
(
(
uintptr_t
)
&
obj
)
>
>
JSVAL_TAG_SHIFT
)
=
=
0
)
;
#
endif
setObjectNoCheck
(
&
obj
)
;
}
private
:
void
setObjectNoCheck
(
JSObject
*
obj
)
{
data
.
asBits
=
bitsFromTagAndPayload
(
JSVAL_TAG_OBJECT
PayloadType
(
obj
)
)
;
}
friend
inline
Value
PoisonedObjectValue
(
JSObject
*
obj
)
;
public
:
void
setBoolean
(
bool
b
)
{
data
.
asBits
=
bitsFromTagAndPayload
(
JSVAL_TAG_BOOLEAN
uint32_t
(
b
)
)
;
}
void
setMagic
(
JSWhyMagic
why
)
{
data
.
asBits
=
bitsFromTagAndPayload
(
JSVAL_TAG_MAGIC
uint32_t
(
why
)
)
;
}
void
setMagicUint32
(
uint32_t
payload
)
{
data
.
asBits
=
bitsFromTagAndPayload
(
JSVAL_TAG_MAGIC
payload
)
;
}
bool
setNumber
(
uint32_t
ui
)
{
if
(
ui
>
JSVAL_INT_MAX
)
{
setDouble
(
(
double
)
ui
)
;
return
false
;
}
else
{
setInt32
(
(
int32_t
)
ui
)
;
return
true
;
}
}
bool
setNumber
(
double
d
)
{
int32_t
i
;
if
(
mozilla
:
:
NumberIsInt32
(
d
&
i
)
)
{
setInt32
(
i
)
;
return
true
;
}
setDouble
(
d
)
;
return
false
;
}
void
setObjectOrNull
(
JSObject
*
arg
)
{
if
(
arg
)
setObject
(
*
arg
)
;
else
setNull
(
)
;
}
void
swap
(
Value
&
rhs
)
{
uint64_t
tmp
=
rhs
.
data
.
asBits
;
rhs
.
data
.
asBits
=
data
.
asBits
;
data
.
asBits
=
tmp
;
}
private
:
JSValueTag
toTag
(
)
const
{
#
if
defined
(
JS_NUNBOX32
)
return
data
.
s
.
tag
;
#
elif
defined
(
JS_PUNBOX64
)
return
JSValueTag
(
data
.
asBits
>
>
JSVAL_TAG_SHIFT
)
;
#
endif
}
public
:
bool
isUndefined
(
)
const
{
#
if
defined
(
JS_NUNBOX32
)
return
toTag
(
)
=
=
JSVAL_TAG_UNDEFINED
;
#
elif
defined
(
JS_PUNBOX64
)
return
data
.
asBits
=
=
JSVAL_SHIFTED_TAG_UNDEFINED
;
#
endif
}
bool
isNull
(
)
const
{
#
if
defined
(
JS_NUNBOX32
)
return
toTag
(
)
=
=
JSVAL_TAG_NULL
;
#
elif
defined
(
JS_PUNBOX64
)
return
data
.
asBits
=
=
JSVAL_SHIFTED_TAG_NULL
;
#
endif
}
bool
isNullOrUndefined
(
)
const
{
return
isNull
(
)
|
|
isUndefined
(
)
;
}
bool
isInt32
(
)
const
{
return
toTag
(
)
=
=
JSVAL_TAG_INT32
;
}
bool
isInt32
(
int32_t
i32
)
const
{
return
data
.
asBits
=
=
bitsFromTagAndPayload
(
JSVAL_TAG_INT32
uint32_t
(
i32
)
)
;
}
bool
isDouble
(
)
const
{
#
if
defined
(
JS_NUNBOX32
)
return
uint32_t
(
toTag
(
)
)
<
=
uint32_t
(
JSVAL_TAG_CLEAR
)
;
#
elif
defined
(
JS_PUNBOX64
)
return
(
data
.
asBits
|
mozilla
:
:
DoubleTypeTraits
:
:
kSignBit
)
<
=
JSVAL_SHIFTED_TAG_MAX_DOUBLE
;
#
endif
}
bool
isNumber
(
)
const
{
#
if
defined
(
JS_NUNBOX32
)
MOZ_ASSERT
(
toTag
(
)
!
=
JSVAL_TAG_CLEAR
)
;
return
uint32_t
(
toTag
(
)
)
<
=
uint32_t
(
JSVAL_UPPER_INCL_TAG_OF_NUMBER_SET
)
;
#
elif
defined
(
JS_PUNBOX64
)
return
data
.
asBits
<
JSVAL_UPPER_EXCL_SHIFTED_TAG_OF_NUMBER_SET
;
#
endif
}
bool
isString
(
)
const
{
return
toTag
(
)
=
=
JSVAL_TAG_STRING
;
}
bool
isSymbol
(
)
const
{
return
toTag
(
)
=
=
JSVAL_TAG_SYMBOL
;
}
bool
isObject
(
)
const
{
#
if
defined
(
JS_NUNBOX32
)
return
toTag
(
)
=
=
JSVAL_TAG_OBJECT
;
#
elif
defined
(
JS_PUNBOX64
)
MOZ_ASSERT
(
(
data
.
asBits
>
>
JSVAL_TAG_SHIFT
)
<
=
JSVAL_TAG_OBJECT
)
;
return
data
.
asBits
>
=
JSVAL_SHIFTED_TAG_OBJECT
;
#
endif
}
bool
isPrimitive
(
)
const
{
#
if
defined
(
JS_NUNBOX32
)
return
uint32_t
(
toTag
(
)
)
<
uint32_t
(
JSVAL_UPPER_EXCL_TAG_OF_PRIMITIVE_SET
)
;
#
elif
defined
(
JS_PUNBOX64
)
return
data
.
asBits
<
JSVAL_UPPER_EXCL_SHIFTED_TAG_OF_PRIMITIVE_SET
;
#
endif
}
bool
isObjectOrNull
(
)
const
{
MOZ_ASSERT
(
uint32_t
(
toTag
(
)
)
<
=
uint32_t
(
JSVAL_TAG_OBJECT
)
)
;
#
if
defined
(
JS_NUNBOX32
)
return
uint32_t
(
toTag
(
)
)
>
=
uint32_t
(
JSVAL_LOWER_INCL_TAG_OF_OBJ_OR_NULL_SET
)
;
#
elif
defined
(
JS_PUNBOX64
)
return
data
.
asBits
>
=
JSVAL_LOWER_INCL_SHIFTED_TAG_OF_OBJ_OR_NULL_SET
;
#
endif
}
bool
isGCThing
(
)
const
{
#
if
defined
(
JS_NUNBOX32
)
return
uint32_t
(
toTag
(
)
)
>
=
uint32_t
(
JSVAL_LOWER_INCL_TAG_OF_GCTHING_SET
)
;
#
elif
defined
(
JS_PUNBOX64
)
return
data
.
asBits
>
=
JSVAL_LOWER_INCL_SHIFTED_TAG_OF_GCTHING_SET
;
#
endif
}
bool
isBoolean
(
)
const
{
return
toTag
(
)
=
=
JSVAL_TAG_BOOLEAN
;
}
bool
isTrue
(
)
const
{
return
data
.
asBits
=
=
bitsFromTagAndPayload
(
JSVAL_TAG_BOOLEAN
uint32_t
(
true
)
)
;
}
bool
isFalse
(
)
const
{
return
data
.
asBits
=
=
bitsFromTagAndPayload
(
JSVAL_TAG_BOOLEAN
uint32_t
(
false
)
)
;
}
bool
isMagic
(
)
const
{
return
toTag
(
)
=
=
JSVAL_TAG_MAGIC
;
}
bool
isMagic
(
JSWhyMagic
why
)
const
{
MOZ_ASSERT_IF
(
isMagic
(
)
data
.
s
.
payload
.
why
=
=
why
)
;
return
isMagic
(
)
;
}
bool
isMarkable
(
)
const
{
return
isGCThing
(
)
&
&
!
isNull
(
)
;
}
JS
:
:
TraceKind
traceKind
(
)
const
{
MOZ_ASSERT
(
isMarkable
(
)
)
;
static_assert
(
(
JSVAL_TAG_STRING
&
0x03
)
=
=
size_t
(
JS
:
:
TraceKind
:
:
String
)
"
Value
type
tags
must
correspond
with
JS
:
:
TraceKinds
.
"
)
;
static_assert
(
(
JSVAL_TAG_SYMBOL
&
0x03
)
=
=
size_t
(
JS
:
:
TraceKind
:
:
Symbol
)
"
Value
type
tags
must
correspond
with
JS
:
:
TraceKinds
.
"
)
;
static_assert
(
(
JSVAL_TAG_OBJECT
&
0x03
)
=
=
size_t
(
JS
:
:
TraceKind
:
:
Object
)
"
Value
type
tags
must
correspond
with
JS
:
:
TraceKinds
.
"
)
;
if
(
MOZ_UNLIKELY
(
isPrivateGCThing
(
)
)
)
return
JS
:
:
GCThingTraceKind
(
JSVAL_TO_GCTHING_IMPL
(
data
)
)
;
return
JS
:
:
TraceKind
(
toTag
(
)
&
0x03
)
;
}
JSWhyMagic
whyMagic
(
)
const
{
MOZ_ASSERT
(
isMagic
(
)
)
;
return
data
.
s
.
payload
.
why
;
}
uint32_t
magicUint32
(
)
const
{
MOZ_ASSERT
(
isMagic
(
)
)
;
return
data
.
s
.
payload
.
u32
;
}
bool
operator
=
=
(
const
Value
&
rhs
)
const
{
return
data
.
asBits
=
=
rhs
.
data
.
asBits
;
}
bool
operator
!
=
(
const
Value
&
rhs
)
const
{
return
data
.
asBits
!
=
rhs
.
data
.
asBits
;
}
friend
inline
bool
SameType
(
const
Value
&
lhs
const
Value
&
rhs
)
;
int32_t
toInt32
(
)
const
{
MOZ_ASSERT
(
isInt32
(
)
)
;
return
JSVAL_TO_INT32_IMPL
(
data
)
;
}
double
toDouble
(
)
const
{
MOZ_ASSERT
(
isDouble
(
)
)
;
return
data
.
asDouble
;
}
double
toNumber
(
)
const
{
MOZ_ASSERT
(
isNumber
(
)
)
;
return
isDouble
(
)
?
toDouble
(
)
:
double
(
toInt32
(
)
)
;
}
JSString
*
toString
(
)
const
{
MOZ_ASSERT
(
isString
(
)
)
;
return
JSVAL_TO_STRING_IMPL
(
data
)
;
}
JS
:
:
Symbol
*
toSymbol
(
)
const
{
MOZ_ASSERT
(
isSymbol
(
)
)
;
return
JSVAL_TO_SYMBOL_IMPL
(
data
)
;
}
JSObject
&
toObject
(
)
const
{
MOZ_ASSERT
(
isObject
(
)
)
;
return
*
JSVAL_TO_OBJECT_IMPL
(
data
)
;
}
JSObject
*
toObjectOrNull
(
)
const
{
MOZ_ASSERT
(
isObjectOrNull
(
)
)
;
return
JSVAL_TO_OBJECT_IMPL
(
data
)
;
}
js
:
:
gc
:
:
Cell
*
toGCThing
(
)
const
{
MOZ_ASSERT
(
isGCThing
(
)
)
;
return
JSVAL_TO_GCTHING_IMPL
(
data
)
;
}
GCCellPtr
toGCCellPtr
(
)
const
{
return
GCCellPtr
(
toGCThing
(
)
traceKind
(
)
)
;
}
bool
toBoolean
(
)
const
{
MOZ_ASSERT
(
isBoolean
(
)
)
;
return
JSVAL_TO_BOOLEAN_IMPL
(
data
)
;
}
uint32_t
payloadAsRawUint32
(
)
const
{
MOZ_ASSERT
(
!
isDouble
(
)
)
;
return
data
.
s
.
payload
.
u32
;
}
uint64_t
asRawBits
(
)
const
{
return
data
.
asBits
;
}
JSValueType
extractNonDoubleType
(
)
const
{
return
JSVAL_EXTRACT_NON_DOUBLE_TYPE_IMPL
(
data
)
;
}
void
setPrivate
(
void
*
ptr
)
{
MOZ_ASSERT
(
(
uintptr_t
(
ptr
)
&
1
)
=
=
0
)
;
#
if
defined
(
JS_NUNBOX32
)
data
.
s
.
tag
=
JSValueTag
(
0
)
;
data
.
s
.
payload
.
ptr
=
ptr
;
#
elif
defined
(
JS_PUNBOX64
)
data
.
asBits
=
uintptr_t
(
ptr
)
>
>
1
;
#
endif
MOZ_ASSERT
(
isDouble
(
)
)
;
}
void
*
toPrivate
(
)
const
{
MOZ_ASSERT
(
isDouble
(
)
)
;
return
JSVAL_TO_PRIVATE_PTR_IMPL
(
data
)
;
}
void
setPrivateUint32
(
uint32_t
ui
)
{
MOZ_ASSERT
(
uint32_t
(
int32_t
(
ui
)
)
=
=
ui
)
;
setInt32
(
int32_t
(
ui
)
)
;
}
uint32_t
toPrivateUint32
(
)
const
{
return
uint32_t
(
toInt32
(
)
)
;
}
void
setPrivateGCThing
(
js
:
:
gc
:
:
Cell
*
cell
)
{
MOZ_ASSERT
(
JS
:
:
GCThingTraceKind
(
cell
)
!
=
JS
:
:
TraceKind
:
:
String
"
Private
GC
thing
Values
must
not
be
strings
.
Make
a
StringValue
instead
.
"
)
;
MOZ_ASSERT
(
JS
:
:
GCThingTraceKind
(
cell
)
!
=
JS
:
:
TraceKind
:
:
Symbol
"
Private
GC
thing
Values
must
not
be
symbols
.
Make
a
SymbolValue
instead
.
"
)
;
MOZ_ASSERT
(
JS
:
:
GCThingTraceKind
(
cell
)
!
=
JS
:
:
TraceKind
:
:
Object
"
Private
GC
thing
Values
must
not
be
objects
.
Make
an
ObjectValue
instead
.
"
)
;
MOZ_ASSERT
(
uintptr_t
(
cell
)
>
0x1000
)
;
#
if
defined
(
JS_PUNBOX64
)
MOZ_ASSERT
(
(
(
(
uintptr_t
)
cell
)
>
>
JSVAL_TAG_SHIFT
)
=
=
0
)
;
#
endif
data
.
asBits
=
bitsFromTagAndPayload
(
JSVAL_TAG_PRIVATE_GCTHING
PayloadType
(
cell
)
)
;
}
bool
isPrivateGCThing
(
)
const
{
return
toTag
(
)
=
=
JSVAL_TAG_PRIVATE_GCTHING
;
}
void
setUnmarkedPtr
(
void
*
ptr
)
{
data
.
asPtr
=
ptr
;
}
void
*
toUnmarkedPtr
(
)
const
{
return
data
.
asPtr
;
}
const
size_t
*
payloadWord
(
)
const
{
#
if
defined
(
JS_NUNBOX32
)
return
&
data
.
s
.
payload
.
word
;
#
elif
defined
(
JS_PUNBOX64
)
return
&
data
.
asWord
;
#
endif
}
const
uintptr_t
*
payloadUIntPtr
(
)
const
{
#
if
defined
(
JS_NUNBOX32
)
return
&
data
.
s
.
payload
.
uintptr
;
#
elif
defined
(
JS_PUNBOX64
)
return
&
data
.
asUIntPtr
;
#
endif
}
#
if
!
defined
(
_MSC_VER
)
&
&
!
defined
(
__sparc
)
private
:
#
endif
jsval_layout
data
;
private
:
#
if
defined
(
JS_VALUE_IS_CONSTEXPR
)
explicit
JS_VALUE_CONSTEXPR
Value
(
uint64_t
asBits
)
:
data
(
{
.
asBits
=
asBits
}
)
{
}
MOZ_IMPLICIT
JS_VALUE_CONSTEXPR
Value
(
const
jsval_layout
&
layout
)
:
data
(
layout
)
{
}
#
endif
void
staticAssertions
(
)
{
JS_STATIC_ASSERT
(
sizeof
(
JSValueType
)
=
=
1
)
;
JS_STATIC_ASSERT
(
sizeof
(
JSValueTag
)
=
=
4
)
;
JS_STATIC_ASSERT
(
sizeof
(
JSWhyMagic
)
<
=
4
)
;
JS_STATIC_ASSERT
(
sizeof
(
Value
)
=
=
8
)
;
}
friend
jsval_layout
(
:
:
JSVAL_TO_IMPL
)
(
const
Value
&
)
;
friend
Value
JS_VALUE_CONSTEXPR
(
:
:
IMPL_TO_JSVAL
)
(
const
jsval_layout
&
l
)
;
friend
Value
JS_VALUE_CONSTEXPR
(
JS
:
:
UndefinedValue
)
(
)
;
public
:
static
JS_VALUE_CONSTEXPR
uint64_t
bitsFromTagAndPayload
(
JSValueTag
tag
PayloadType
payload
)
{
#
if
defined
(
JS_NUNBOX32
)
return
(
uint64_t
(
uint32_t
(
tag
)
)
<
<
32
)
|
payload
;
#
elif
defined
(
JS_PUNBOX64
)
return
(
uint64_t
(
uint32_t
(
tag
)
)
<
<
JSVAL_TAG_SHIFT
)
|
payload
;
#
endif
}
static
JS_VALUE_CONSTEXPR
Value
fromTagAndPayload
(
JSValueTag
tag
PayloadType
payload
)
{
return
fromRawBits
(
bitsFromTagAndPayload
(
tag
payload
)
)
;
}
static
JS_VALUE_CONSTEXPR
Value
fromRawBits
(
uint64_t
asBits
)
{
#
if
defined
(
JS_VALUE_IS_CONSTEXPR
)
return
Value
(
asBits
)
;
#
else
Value
v
;
v
.
data
.
asBits
=
asBits
;
return
v
;
#
endif
}
static
JS_VALUE_CONSTEXPR
Value
fromInt32
(
int32_t
i
)
{
return
fromTagAndPayload
(
JSVAL_TAG_INT32
uint32_t
(
i
)
)
;
}
}
JS_HAZ_GC_POINTER
;
inline
bool
IsOptimizedPlaceholderMagicValue
(
const
Value
&
v
)
{
if
(
v
.
isMagic
(
)
)
{
MOZ_ASSERT
(
v
.
whyMagic
(
)
=
=
JS_OPTIMIZED_ARGUMENTS
|
|
v
.
whyMagic
(
)
=
=
JS_OPTIMIZED_OUT
)
;
return
true
;
}
return
false
;
}
static
MOZ_ALWAYS_INLINE
void
ExposeValueToActiveJS
(
const
Value
&
v
)
{
if
(
v
.
isMarkable
(
)
)
js
:
:
gc
:
:
ExposeGCThingToActiveJS
(
GCCellPtr
(
v
)
)
;
}
static
inline
Value
NullValue
(
)
{
Value
v
;
v
.
setNull
(
)
;
return
v
;
}
static
inline
JS_VALUE_CONSTEXPR
Value
UndefinedValue
(
)
{
return
Value
:
:
fromTagAndPayload
(
JSVAL_TAG_UNDEFINED
0
)
;
}
static
inline
JS_VALUE_CONSTEXPR
Value
Int32Value
(
int32_t
i32
)
{
return
Value
:
:
fromInt32
(
i32
)
;
}
static
inline
Value
DoubleValue
(
double
dbl
)
{
Value
v
;
v
.
setDouble
(
dbl
)
;
return
v
;
}
static
inline
JS_VALUE_CONSTEXPR
Value
CanonicalizedDoubleValue
(
double
d
)
{
#
if
defined
(
JS_VALUE_IS_CONSTEXPR
)
return
IMPL_TO_JSVAL
(
MOZ_UNLIKELY
(
mozilla
:
:
IsNaN
(
d
)
)
?
(
jsval_layout
)
{
.
asBits
=
0x7FF8000000000000LL
}
:
(
jsval_layout
)
{
.
asDouble
=
d
}
)
;
#
else
jsval_layout
l
;
if
(
MOZ_UNLIKELY
(
d
!
=
d
)
)
l
.
asBits
=
0x7FF8000000000000LL
;
else
l
.
asDouble
=
d
;
return
IMPL_TO_JSVAL
(
l
)
;
#
endif
}
static
inline
Value
DoubleNaNValue
(
)
{
Value
v
;
v
.
setNaN
(
)
;
return
v
;
}
static
inline
Value
Float32Value
(
float
f
)
{
Value
v
;
v
.
setDouble
(
f
)
;
return
v
;
}
static
inline
Value
StringValue
(
JSString
*
str
)
{
Value
v
;
v
.
setString
(
str
)
;
return
v
;
}
static
inline
Value
SymbolValue
(
JS
:
:
Symbol
*
sym
)
{
Value
v
;
v
.
setSymbol
(
sym
)
;
return
v
;
}
static
inline
Value
BooleanValue
(
bool
boo
)
{
Value
v
;
v
.
setBoolean
(
boo
)
;
return
v
;
}
static
inline
Value
TrueValue
(
)
{
Value
v
;
v
.
setBoolean
(
true
)
;
return
v
;
}
static
inline
Value
FalseValue
(
)
{
Value
v
;
v
.
setBoolean
(
false
)
;
return
v
;
}
static
inline
Value
ObjectValue
(
JSObject
&
obj
)
{
Value
v
;
v
.
setObject
(
obj
)
;
return
v
;
}
static
inline
Value
ObjectValueCrashOnTouch
(
)
{
Value
v
;
v
.
setObject
(
*
reinterpret_cast
<
JSObject
*
>
(
0x48
)
)
;
return
v
;
}
static
inline
Value
MagicValue
(
JSWhyMagic
why
)
{
Value
v
;
v
.
setMagic
(
why
)
;
return
v
;
}
static
inline
Value
MagicValueUint32
(
uint32_t
payload
)
{
Value
v
;
v
.
setMagicUint32
(
payload
)
;
return
v
;
}
static
inline
Value
NumberValue
(
float
f
)
{
Value
v
;
v
.
setNumber
(
f
)
;
return
v
;
}
static
inline
Value
NumberValue
(
double
dbl
)
{
Value
v
;
v
.
setNumber
(
dbl
)
;
return
v
;
}
static
inline
Value
NumberValue
(
int8_t
i
)
{
return
Int32Value
(
i
)
;
}
static
inline
Value
NumberValue
(
uint8_t
i
)
{
return
Int32Value
(
i
)
;
}
static
inline
Value
NumberValue
(
int16_t
i
)
{
return
Int32Value
(
i
)
;
}
static
inline
Value
NumberValue
(
uint16_t
i
)
{
return
Int32Value
(
i
)
;
}
static
inline
Value
NumberValue
(
int32_t
i
)
{
return
Int32Value
(
i
)
;
}
static
inline
JS_VALUE_CONSTEXPR
Value
NumberValue
(
uint32_t
i
)
{
return
i
<
=
JSVAL_INT_MAX
?
Int32Value
(
int32_t
(
i
)
)
:
CanonicalizedDoubleValue
(
double
(
i
)
)
;
}
namespace
detail
{
template
<
bool
Signed
>
class
MakeNumberValue
{
public
:
template
<
typename
T
>
static
inline
Value
create
(
const
T
t
)
{
Value
v
;
if
(
JSVAL_INT_MIN
<
=
t
&
&
t
<
=
JSVAL_INT_MAX
)
v
.
setInt32
(
int32_t
(
t
)
)
;
else
v
.
setDouble
(
double
(
t
)
)
;
return
v
;
}
}
;
template
<
>
class
MakeNumberValue
<
false
>
{
public
:
template
<
typename
T
>
static
inline
Value
create
(
const
T
t
)
{
Value
v
;
if
(
t
<
=
JSVAL_INT_MAX
)
v
.
setInt32
(
int32_t
(
t
)
)
;
else
v
.
setDouble
(
double
(
t
)
)
;
return
v
;
}
}
;
}
template
<
typename
T
>
static
inline
Value
NumberValue
(
const
T
t
)
{
MOZ_ASSERT
(
Value
:
:
isNumberRepresentable
(
t
)
"
value
creation
would
be
lossy
"
)
;
return
detail
:
:
MakeNumberValue
<
std
:
:
numeric_limits
<
T
>
:
:
is_signed
>
:
:
create
(
t
)
;
}
static
inline
Value
ObjectOrNullValue
(
JSObject
*
obj
)
{
Value
v
;
v
.
setObjectOrNull
(
obj
)
;
return
v
;
}
static
inline
Value
PrivateValue
(
void
*
ptr
)
{
Value
v
;
v
.
setPrivate
(
ptr
)
;
return
v
;
}
static
inline
Value
PrivateUint32Value
(
uint32_t
ui
)
{
Value
v
;
v
.
setPrivateUint32
(
ui
)
;
return
v
;
}
static
inline
Value
PrivateGCThingValue
(
js
:
:
gc
:
:
Cell
*
cell
)
{
Value
v
;
v
.
setPrivateGCThing
(
cell
)
;
return
v
;
}
static
inline
Value
PoisonedObjectValue
(
JSObject
*
obj
)
{
Value
v
;
v
.
setObjectNoCheck
(
obj
)
;
return
v
;
}
inline
bool
SameType
(
const
Value
&
lhs
const
Value
&
rhs
)
{
#
if
defined
(
JS_NUNBOX32
)
JSValueTag
ltag
=
lhs
.
toTag
(
)
rtag
=
rhs
.
toTag
(
)
;
return
ltag
=
=
rtag
|
|
(
ltag
<
JSVAL_TAG_CLEAR
&
&
rtag
<
JSVAL_TAG_CLEAR
)
;
#
elif
defined
(
JS_PUNBOX64
)
return
(
lhs
.
isDouble
(
)
&
&
rhs
.
isDouble
(
)
)
|
|
(
(
(
lhs
.
data
.
asBits
^
rhs
.
data
.
asBits
)
&
0xFFFF800000000000ULL
)
=
=
0
)
;
#
endif
}
}
namespace
JS
{
JS_PUBLIC_API
(
void
)
HeapValuePostBarrier
(
Value
*
valuep
const
Value
&
prev
const
Value
&
next
)
;
template
<
>
struct
GCPolicy
<
JS
:
:
Value
>
{
static
Value
initial
(
)
{
return
UndefinedValue
(
)
;
}
static
void
trace
(
JSTracer
*
trc
Value
*
v
const
char
*
name
)
{
js
:
:
UnsafeTraceManuallyBarrieredEdge
(
trc
v
name
)
;
}
static
bool
isTenured
(
const
Value
&
thing
)
{
return
!
thing
.
isGCThing
(
)
|
|
!
IsInsideNursery
(
thing
.
toGCThing
(
)
)
;
}
}
;
}
namespace
js
{
template
<
>
struct
BarrierMethods
<
JS
:
:
Value
>
{
static
gc
:
:
Cell
*
asGCThingOrNull
(
const
JS
:
:
Value
&
v
)
{
return
v
.
isMarkable
(
)
?
v
.
toGCThing
(
)
:
nullptr
;
}
static
void
postBarrier
(
JS
:
:
Value
*
v
const
JS
:
:
Value
&
prev
const
JS
:
:
Value
&
next
)
{
JS
:
:
HeapValuePostBarrier
(
v
prev
next
)
;
}
static
void
exposeToJS
(
const
JS
:
:
Value
&
v
)
{
JS
:
:
ExposeValueToActiveJS
(
v
)
;
}
}
;
template
<
class
Outer
>
class
MutableValueOperations
;
template
<
class
Outer
>
class
ValueOperations
{
friend
class
MutableValueOperations
<
Outer
>
;
const
JS
:
:
Value
&
value
(
)
const
{
return
static_cast
<
const
Outer
*
>
(
this
)
-
>
get
(
)
;
}
public
:
bool
isUndefined
(
)
const
{
return
value
(
)
.
isUndefined
(
)
;
}
bool
isNull
(
)
const
{
return
value
(
)
.
isNull
(
)
;
}
bool
isBoolean
(
)
const
{
return
value
(
)
.
isBoolean
(
)
;
}
bool
isTrue
(
)
const
{
return
value
(
)
.
isTrue
(
)
;
}
bool
isFalse
(
)
const
{
return
value
(
)
.
isFalse
(
)
;
}
bool
isNumber
(
)
const
{
return
value
(
)
.
isNumber
(
)
;
}
bool
isInt32
(
)
const
{
return
value
(
)
.
isInt32
(
)
;
}
bool
isInt32
(
int32_t
i32
)
const
{
return
value
(
)
.
isInt32
(
i32
)
;
}
bool
isDouble
(
)
const
{
return
value
(
)
.
isDouble
(
)
;
}
bool
isString
(
)
const
{
return
value
(
)
.
isString
(
)
;
}
bool
isSymbol
(
)
const
{
return
value
(
)
.
isSymbol
(
)
;
}
bool
isObject
(
)
const
{
return
value
(
)
.
isObject
(
)
;
}
bool
isMagic
(
)
const
{
return
value
(
)
.
isMagic
(
)
;
}
bool
isMagic
(
JSWhyMagic
why
)
const
{
return
value
(
)
.
isMagic
(
why
)
;
}
bool
isMarkable
(
)
const
{
return
value
(
)
.
isMarkable
(
)
;
}
bool
isPrimitive
(
)
const
{
return
value
(
)
.
isPrimitive
(
)
;
}
bool
isGCThing
(
)
const
{
return
value
(
)
.
isGCThing
(
)
;
}
bool
isNullOrUndefined
(
)
const
{
return
value
(
)
.
isNullOrUndefined
(
)
;
}
bool
isObjectOrNull
(
)
const
{
return
value
(
)
.
isObjectOrNull
(
)
;
}
bool
toBoolean
(
)
const
{
return
value
(
)
.
toBoolean
(
)
;
}
double
toNumber
(
)
const
{
return
value
(
)
.
toNumber
(
)
;
}
int32_t
toInt32
(
)
const
{
return
value
(
)
.
toInt32
(
)
;
}
double
toDouble
(
)
const
{
return
value
(
)
.
toDouble
(
)
;
}
JSString
*
toString
(
)
const
{
return
value
(
)
.
toString
(
)
;
}
JS
:
:
Symbol
*
toSymbol
(
)
const
{
return
value
(
)
.
toSymbol
(
)
;
}
JSObject
&
toObject
(
)
const
{
return
value
(
)
.
toObject
(
)
;
}
JSObject
*
toObjectOrNull
(
)
const
{
return
value
(
)
.
toObjectOrNull
(
)
;
}
gc
:
:
Cell
*
toGCThing
(
)
const
{
return
value
(
)
.
toGCThing
(
)
;
}
JS
:
:
TraceKind
traceKind
(
)
const
{
return
value
(
)
.
traceKind
(
)
;
}
void
*
toPrivate
(
)
const
{
return
value
(
)
.
toPrivate
(
)
;
}
uint32_t
toPrivateUint32
(
)
const
{
return
value
(
)
.
toPrivateUint32
(
)
;
}
uint64_t
asRawBits
(
)
const
{
return
value
(
)
.
asRawBits
(
)
;
}
JSValueType
extractNonDoubleType
(
)
const
{
return
value
(
)
.
extractNonDoubleType
(
)
;
}
JSWhyMagic
whyMagic
(
)
const
{
return
value
(
)
.
whyMagic
(
)
;
}
uint32_t
magicUint32
(
)
const
{
return
value
(
)
.
magicUint32
(
)
;
}
}
;
template
<
class
Outer
>
class
MutableValueOperations
:
public
ValueOperations
<
Outer
>
{
JS
:
:
Value
&
value
(
)
{
return
static_cast
<
Outer
*
>
(
this
)
-
>
get
(
)
;
}
public
:
void
setNull
(
)
{
value
(
)
.
setNull
(
)
;
}
void
setUndefined
(
)
{
value
(
)
.
setUndefined
(
)
;
}
void
setInt32
(
int32_t
i
)
{
value
(
)
.
setInt32
(
i
)
;
}
void
setDouble
(
double
d
)
{
value
(
)
.
setDouble
(
d
)
;
}
void
setNaN
(
)
{
setDouble
(
JS
:
:
GenericNaN
(
)
)
;
}
void
setBoolean
(
bool
b
)
{
value
(
)
.
setBoolean
(
b
)
;
}
void
setMagic
(
JSWhyMagic
why
)
{
value
(
)
.
setMagic
(
why
)
;
}
bool
setNumber
(
uint32_t
ui
)
{
return
value
(
)
.
setNumber
(
ui
)
;
}
bool
setNumber
(
double
d
)
{
return
value
(
)
.
setNumber
(
d
)
;
}
void
setString
(
JSString
*
str
)
{
this
-
>
value
(
)
.
setString
(
str
)
;
}
void
setSymbol
(
JS
:
:
Symbol
*
sym
)
{
this
-
>
value
(
)
.
setSymbol
(
sym
)
;
}
void
setObject
(
JSObject
&
obj
)
{
this
-
>
value
(
)
.
setObject
(
obj
)
;
}
void
setObjectOrNull
(
JSObject
*
arg
)
{
this
-
>
value
(
)
.
setObjectOrNull
(
arg
)
;
}
void
setPrivate
(
void
*
ptr
)
{
this
-
>
value
(
)
.
setPrivate
(
ptr
)
;
}
void
setPrivateUint32
(
uint32_t
ui
)
{
this
-
>
value
(
)
.
setPrivateUint32
(
ui
)
;
}
void
setPrivateGCThing
(
js
:
:
gc
:
:
Cell
*
cell
)
{
this
-
>
value
(
)
.
setPrivateGCThing
(
cell
)
;
}
}
;
template
<
>
class
HeapBase
<
JS
:
:
Value
>
:
public
ValueOperations
<
JS
:
:
Heap
<
JS
:
:
Value
>
>
{
typedef
JS
:
:
Heap
<
JS
:
:
Value
>
Outer
;
friend
class
ValueOperations
<
Outer
>
;
void
setBarriered
(
const
JS
:
:
Value
&
v
)
{
*
static_cast
<
JS
:
:
Heap
<
JS
:
:
Value
>
*
>
(
this
)
=
v
;
}
public
:
void
setNull
(
)
{
setBarriered
(
JS
:
:
NullValue
(
)
)
;
}
void
setUndefined
(
)
{
setBarriered
(
JS
:
:
UndefinedValue
(
)
)
;
}
void
setInt32
(
int32_t
i
)
{
setBarriered
(
JS
:
:
Int32Value
(
i
)
)
;
}
void
setDouble
(
double
d
)
{
setBarriered
(
JS
:
:
DoubleValue
(
d
)
)
;
}
void
setNaN
(
)
{
setDouble
(
JS
:
:
GenericNaN
(
)
)
;
}
void
setBoolean
(
bool
b
)
{
setBarriered
(
JS
:
:
BooleanValue
(
b
)
)
;
}
void
setMagic
(
JSWhyMagic
why
)
{
setBarriered
(
JS
:
:
MagicValue
(
why
)
)
;
}
void
setString
(
JSString
*
str
)
{
setBarriered
(
JS
:
:
StringValue
(
str
)
)
;
}
void
setSymbol
(
JS
:
:
Symbol
*
sym
)
{
setBarriered
(
JS
:
:
SymbolValue
(
sym
)
)
;
}
void
setObject
(
JSObject
&
obj
)
{
setBarriered
(
JS
:
:
ObjectValue
(
obj
)
)
;
}
void
setPrivateGCThing
(
js
:
:
gc
:
:
Cell
*
cell
)
{
setBarriered
(
JS
:
:
PrivateGCThingValue
(
cell
)
)
;
}
bool
setNumber
(
uint32_t
ui
)
{
if
(
ui
>
JSVAL_INT_MAX
)
{
setDouble
(
(
double
)
ui
)
;
return
false
;
}
else
{
setInt32
(
(
int32_t
)
ui
)
;
return
true
;
}
}
bool
setNumber
(
double
d
)
{
int32_t
i
;
if
(
mozilla
:
:
NumberIsInt32
(
d
&
i
)
)
{
setInt32
(
i
)
;
return
true
;
}
setDouble
(
d
)
;
return
false
;
}
void
setObjectOrNull
(
JSObject
*
arg
)
{
if
(
arg
)
setObject
(
*
arg
)
;
else
setNull
(
)
;
}
}
;
template
<
>
class
HandleBase
<
JS
:
:
Value
>
:
public
ValueOperations
<
JS
:
:
Handle
<
JS
:
:
Value
>
>
{
}
;
template
<
>
class
MutableHandleBase
<
JS
:
:
Value
>
:
public
MutableValueOperations
<
JS
:
:
MutableHandle
<
JS
:
:
Value
>
>
{
}
;
template
<
>
class
RootedBase
<
JS
:
:
Value
>
:
public
MutableValueOperations
<
JS
:
:
Rooted
<
JS
:
:
Value
>
>
{
}
;
template
<
>
class
PersistentRootedBase
<
JS
:
:
Value
>
:
public
MutableValueOperations
<
JS
:
:
PersistentRooted
<
JS
:
:
Value
>
>
{
}
;
template
<
typename
F
typename
.
.
.
Args
>
auto
DispatchTyped
(
F
f
const
JS
:
:
Value
&
val
Args
&
&
.
.
.
args
)
-
>
decltype
(
f
(
static_cast
<
JSObject
*
>
(
nullptr
)
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
)
{
if
(
val
.
isString
(
)
)
return
f
(
val
.
toString
(
)
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
;
if
(
val
.
isObject
(
)
)
return
f
(
&
val
.
toObject
(
)
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
;
if
(
val
.
isSymbol
(
)
)
return
f
(
val
.
toSymbol
(
)
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
;
if
(
MOZ_UNLIKELY
(
val
.
isPrivateGCThing
(
)
)
)
return
DispatchTyped
(
f
val
.
toGCCellPtr
(
)
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
;
MOZ_ASSERT
(
!
val
.
isMarkable
(
)
)
;
return
F
:
:
defaultValue
(
val
)
;
}
template
<
class
S
>
struct
VoidDefaultAdaptor
{
static
void
defaultValue
(
const
S
&
)
{
}
}
;
template
<
class
S
>
struct
IdentityDefaultAdaptor
{
static
S
defaultValue
(
const
S
&
v
)
{
return
v
;
}
}
;
template
<
class
S
bool
v
>
struct
BoolDefaultAdaptor
{
static
bool
defaultValue
(
const
S
&
)
{
return
v
;
}
}
;
}
inline
jsval_layout
JSVAL_TO_IMPL
(
const
JS
:
:
Value
&
v
)
{
return
v
.
data
;
}
inline
JS_VALUE_CONSTEXPR
JS
:
:
Value
IMPL_TO_JSVAL
(
const
jsval_layout
&
l
)
{
#
if
defined
(
JS_VALUE_IS_CONSTEXPR
)
return
JS
:
:
Value
(
l
)
;
#
else
JS
:
:
Value
v
;
v
.
data
=
l
;
return
v
;
#
endif
}
namespace
JS
{
#
ifdef
JS_DEBUG
namespace
detail
{
struct
ValueAlignmentTester
{
char
c
;
JS
:
:
Value
v
;
}
;
static_assert
(
sizeof
(
ValueAlignmentTester
)
=
=
16
"
JS
:
:
Value
must
be
16
-
byte
-
aligned
"
)
;
struct
LayoutAlignmentTester
{
char
c
;
jsval_layout
l
;
}
;
static_assert
(
sizeof
(
LayoutAlignmentTester
)
=
=
16
"
jsval_layout
must
be
16
-
byte
-
aligned
"
)
;
}
#
endif
}
static_assert
(
sizeof
(
jsval_layout
)
=
=
sizeof
(
JS
:
:
Value
)
"
jsval_layout
and
JS
:
:
Value
must
have
identical
layouts
"
)
;
namespace
JS
{
extern
JS_PUBLIC_DATA
(
const
HandleValue
)
NullHandleValue
;
extern
JS_PUBLIC_DATA
(
const
HandleValue
)
UndefinedHandleValue
;
extern
JS_PUBLIC_DATA
(
const
HandleValue
)
TrueHandleValue
;
extern
JS_PUBLIC_DATA
(
const
HandleValue
)
FalseHandleValue
;
}
#
undef
JS_VALUE_IS_CONSTEXPR
#
endif
