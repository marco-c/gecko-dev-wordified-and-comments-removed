#
ifndef
js_RegExpFlags_h
#
define
js_RegExpFlags_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
ostream
>
#
include
<
stdint
.
h
>
namespace
JS
{
class
RegExpFlag
{
public
:
static
constexpr
uint8_t
HasIndices
=
0b0100
'
0000
;
static
constexpr
uint8_t
Global
=
0b0000
'
0010
;
static
constexpr
uint8_t
IgnoreCase
=
0b0000
'
0001
;
static
constexpr
uint8_t
Multiline
=
0b0000
'
0100
;
static
constexpr
uint8_t
DotAll
=
0b0010
'
0000
;
static
constexpr
uint8_t
Unicode
=
0b0001
'
0000
;
static
constexpr
uint8_t
UnicodeSets
=
0b1000
'
0000
;
static
constexpr
uint8_t
Sticky
=
0b0000
'
1000
;
static
constexpr
uint8_t
NoFlags
=
0b0000
'
0000
;
static
constexpr
uint8_t
AllFlags
=
0b1111
'
1111
;
}
;
class
RegExpFlags
{
public
:
using
Flag
=
uint8_t
;
private
:
Flag
flags_
;
public
:
RegExpFlags
(
)
=
default
;
MOZ_IMPLICIT
RegExpFlags
(
Flag
flags
)
:
flags_
(
flags
)
{
MOZ_ASSERT
(
(
flags
&
RegExpFlag
:
:
AllFlags
)
=
=
flags
"
flags
must
not
contain
unrecognized
flags
"
)
;
}
RegExpFlags
(
const
RegExpFlags
&
)
=
default
;
RegExpFlags
&
operator
=
(
const
RegExpFlags
&
)
=
default
;
bool
operator
=
=
(
const
RegExpFlags
&
other
)
const
{
return
flags_
=
=
other
.
flags_
;
}
bool
operator
!
=
(
const
RegExpFlags
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
RegExpFlags
&
operator
&
=
(
const
RegExpFlags
&
rhs
)
{
flags_
&
=
rhs
.
flags_
;
return
*
this
;
}
RegExpFlags
&
operator
|
=
(
const
RegExpFlags
&
rhs
)
{
flags_
|
=
rhs
.
flags_
;
return
*
this
;
}
RegExpFlags
operator
&
(
Flag
flag
)
const
{
return
RegExpFlags
(
flags_
&
flag
)
;
}
RegExpFlags
operator
|
(
Flag
flag
)
const
{
return
RegExpFlags
(
flags_
|
flag
)
;
}
RegExpFlags
operator
^
(
Flag
flag
)
const
{
return
RegExpFlags
(
flags_
^
flag
)
;
}
RegExpFlags
operator
~
(
)
const
{
return
RegExpFlags
(
~
flags_
&
RegExpFlag
:
:
AllFlags
)
;
}
bool
hasIndices
(
)
const
{
return
flags_
&
RegExpFlag
:
:
HasIndices
;
}
bool
global
(
)
const
{
return
flags_
&
RegExpFlag
:
:
Global
;
}
bool
ignoreCase
(
)
const
{
return
flags_
&
RegExpFlag
:
:
IgnoreCase
;
}
bool
multiline
(
)
const
{
return
flags_
&
RegExpFlag
:
:
Multiline
;
}
bool
dotAll
(
)
const
{
return
flags_
&
RegExpFlag
:
:
DotAll
;
}
bool
unicode
(
)
const
{
return
flags_
&
RegExpFlag
:
:
Unicode
;
}
bool
unicodeSets
(
)
const
{
return
flags_
&
RegExpFlag
:
:
UnicodeSets
;
}
bool
sticky
(
)
const
{
return
flags_
&
RegExpFlag
:
:
Sticky
;
}
explicit
operator
bool
(
)
const
{
return
flags_
!
=
0
;
}
Flag
value
(
)
const
{
return
flags_
;
}
constexpr
operator
Flag
(
)
const
{
return
flags_
;
}
void
set
(
Flag
flags
bool
value
)
{
if
(
value
)
{
flags_
|
=
flags
;
}
else
{
flags_
&
=
~
flags
;
}
}
}
;
inline
RegExpFlags
&
operator
&
=
(
RegExpFlags
&
flags
RegExpFlags
:
:
Flag
flag
)
{
flags
=
flags
&
flag
;
return
flags
;
}
inline
RegExpFlags
&
operator
|
=
(
RegExpFlags
&
flags
RegExpFlags
:
:
Flag
flag
)
{
flags
=
flags
|
flag
;
return
flags
;
}
inline
RegExpFlags
&
operator
^
=
(
RegExpFlags
&
flags
RegExpFlags
:
:
Flag
flag
)
{
flags
=
flags
^
flag
;
return
flags
;
}
inline
RegExpFlags
operator
&
(
const
RegExpFlags
&
lhs
const
RegExpFlags
&
rhs
)
{
RegExpFlags
result
=
lhs
;
result
&
=
rhs
;
return
lhs
;
}
inline
RegExpFlags
operator
|
(
const
RegExpFlags
&
lhs
const
RegExpFlags
&
rhs
)
{
RegExpFlags
result
=
lhs
;
result
|
=
rhs
;
return
result
;
}
inline
bool
MaybeParseRegExpFlag
(
char
c
RegExpFlags
:
:
Flag
*
flag
)
{
switch
(
c
)
{
case
'
d
'
:
*
flag
=
RegExpFlag
:
:
HasIndices
;
return
true
;
case
'
g
'
:
*
flag
=
RegExpFlag
:
:
Global
;
return
true
;
case
'
i
'
:
*
flag
=
RegExpFlag
:
:
IgnoreCase
;
return
true
;
case
'
m
'
:
*
flag
=
RegExpFlag
:
:
Multiline
;
return
true
;
case
'
s
'
:
*
flag
=
RegExpFlag
:
:
DotAll
;
return
true
;
case
'
u
'
:
*
flag
=
RegExpFlag
:
:
Unicode
;
return
true
;
case
'
v
'
:
*
flag
=
RegExpFlag
:
:
UnicodeSets
;
return
true
;
case
'
y
'
:
*
flag
=
RegExpFlag
:
:
Sticky
;
return
true
;
default
:
return
false
;
}
}
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
RegExpFlags
flags
)
;
}
#
endif
