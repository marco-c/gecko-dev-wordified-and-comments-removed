#
ifndef
js_Utility_h
#
define
js_Utility_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Compiler
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WrappingOperations
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
ifdef
JS_OOM_DO_BACKTRACES
#
include
<
execinfo
.
h
>
#
include
<
stdio
.
h
>
#
endif
#
include
"
jstypes
.
h
"
#
include
"
mozmemory
.
h
"
namespace
JS
{
}
namespace
mozilla
{
}
namespace
js
{
}
#
define
JS_STATIC_ASSERT
(
cond
)
static_assert
(
cond
"
JS_STATIC_ASSERT
"
)
#
define
JS_STATIC_ASSERT_IF
(
cond
expr
)
MOZ_STATIC_ASSERT_IF
(
cond
expr
"
JS_STATIC_ASSERT_IF
"
)
extern
MOZ_NORETURN
MOZ_COLD
JS_PUBLIC_API
(
void
)
JS_Assert
(
const
char
*
s
const
char
*
file
int
ln
)
;
#
if
defined
JS_USE_CUSTOM_ALLOCATOR
#
include
"
jscustomallocator
.
h
"
#
else
namespace
js
{
enum
ThreadType
{
THREAD_TYPE_NONE
=
0
THREAD_TYPE_MAIN
THREAD_TYPE_WASM
THREAD_TYPE_ION
THREAD_TYPE_PARSE
THREAD_TYPE_COMPRESS
THREAD_TYPE_GCHELPER
THREAD_TYPE_GCPARALLEL
THREAD_TYPE_PROMISE_TASK
THREAD_TYPE_ION_FREE
THREAD_TYPE_WASM_TIER2
THREAD_TYPE_WORKER
THREAD_TYPE_MAX
}
;
namespace
oom
{
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
const
ThreadType
FirstThreadTypeToTest
=
THREAD_TYPE_MAIN
;
const
ThreadType
LastThreadTypeToTest
=
THREAD_TYPE_WASM_TIER2
;
extern
bool
InitThreadType
(
void
)
;
extern
void
SetThreadType
(
ThreadType
)
;
extern
JS_FRIEND_API
(
uint32_t
)
GetThreadType
(
void
)
;
#
else
inline
bool
InitThreadType
(
void
)
{
return
true
;
}
inline
void
SetThreadType
(
ThreadType
t
)
{
}
;
inline
uint32_t
GetThreadType
(
void
)
{
return
0
;
}
#
endif
}
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
#
ifdef
JS_OOM_BREAKPOINT
#
if
defined
(
_MSC_VER
)
static
MOZ_NEVER_INLINE
void
js_failedAllocBreakpoint
(
)
{
__asm
{
}
;
}
#
else
static
MOZ_NEVER_INLINE
void
js_failedAllocBreakpoint
(
)
{
asm
(
"
"
)
;
}
#
endif
#
define
JS_OOM_CALL_BP_FUNC
(
)
js_failedAllocBreakpoint
(
)
#
else
#
define
JS_OOM_CALL_BP_FUNC
(
)
do
{
}
while
(
0
)
#
endif
namespace
js
{
namespace
oom
{
extern
JS_PUBLIC_DATA
(
uint32_t
)
targetThread
;
extern
JS_PUBLIC_DATA
(
uint64_t
)
maxAllocations
;
extern
JS_PUBLIC_DATA
(
uint64_t
)
counter
;
extern
JS_PUBLIC_DATA
(
bool
)
failAlways
;
extern
void
SimulateOOMAfter
(
uint64_t
allocations
uint32_t
thread
bool
always
)
;
extern
void
ResetSimulatedOOM
(
)
;
inline
bool
IsThreadSimulatingOOM
(
)
{
return
js
:
:
oom
:
:
targetThread
&
&
js
:
:
oom
:
:
targetThread
=
=
js
:
:
oom
:
:
GetThreadType
(
)
;
}
inline
bool
IsSimulatedOOMAllocation
(
)
{
return
IsThreadSimulatingOOM
(
)
&
&
(
counter
=
=
maxAllocations
|
|
(
counter
>
maxAllocations
&
&
failAlways
)
)
;
}
inline
bool
ShouldFailWithOOM
(
)
{
if
(
!
IsThreadSimulatingOOM
(
)
)
return
false
;
counter
+
+
;
if
(
IsSimulatedOOMAllocation
(
)
)
{
JS_OOM_CALL_BP_FUNC
(
)
;
return
true
;
}
return
false
;
}
inline
bool
HadSimulatedOOM
(
)
{
return
counter
>
=
maxAllocations
;
}
extern
JS_PUBLIC_DATA
(
uint32_t
)
stackTargetThread
;
extern
JS_PUBLIC_DATA
(
uint64_t
)
maxStackChecks
;
extern
JS_PUBLIC_DATA
(
uint64_t
)
stackCheckCounter
;
extern
JS_PUBLIC_DATA
(
bool
)
stackCheckFailAlways
;
extern
void
SimulateStackOOMAfter
(
uint64_t
checks
uint32_t
thread
bool
always
)
;
extern
void
ResetSimulatedStackOOM
(
)
;
inline
bool
IsThreadSimulatingStackOOM
(
)
{
return
js
:
:
oom
:
:
stackTargetThread
&
&
js
:
:
oom
:
:
stackTargetThread
=
=
js
:
:
oom
:
:
GetThreadType
(
)
;
}
inline
bool
IsSimulatedStackOOMCheck
(
)
{
return
IsThreadSimulatingStackOOM
(
)
&
&
(
stackCheckCounter
=
=
maxStackChecks
|
|
(
stackCheckCounter
>
maxStackChecks
&
&
stackCheckFailAlways
)
)
;
}
inline
bool
ShouldFailWithStackOOM
(
)
{
if
(
!
IsThreadSimulatingStackOOM
(
)
)
return
false
;
stackCheckCounter
+
+
;
if
(
IsSimulatedStackOOMCheck
(
)
)
{
JS_OOM_CALL_BP_FUNC
(
)
;
return
true
;
}
return
false
;
}
inline
bool
HadSimulatedStackOOM
(
)
{
return
stackCheckCounter
>
=
maxStackChecks
;
}
extern
JS_PUBLIC_DATA
(
uint32_t
)
interruptTargetThread
;
extern
JS_PUBLIC_DATA
(
uint64_t
)
maxInterruptChecks
;
extern
JS_PUBLIC_DATA
(
uint64_t
)
interruptCheckCounter
;
extern
JS_PUBLIC_DATA
(
bool
)
interruptCheckFailAlways
;
extern
void
SimulateInterruptAfter
(
uint64_t
checks
uint32_t
thread
bool
always
)
;
extern
void
ResetSimulatedInterrupt
(
)
;
inline
bool
IsThreadSimulatingInterrupt
(
)
{
return
js
:
:
oom
:
:
interruptTargetThread
&
&
js
:
:
oom
:
:
interruptTargetThread
=
=
js
:
:
oom
:
:
GetThreadType
(
)
;
}
inline
bool
IsSimulatedInterruptCheck
(
)
{
return
IsThreadSimulatingInterrupt
(
)
&
&
(
interruptCheckCounter
=
=
maxInterruptChecks
|
|
(
interruptCheckCounter
>
maxInterruptChecks
&
&
interruptCheckFailAlways
)
)
;
}
inline
bool
ShouldFailWithInterrupt
(
)
{
if
(
!
IsThreadSimulatingInterrupt
(
)
)
return
false
;
interruptCheckCounter
+
+
;
if
(
IsSimulatedInterruptCheck
(
)
)
{
JS_OOM_CALL_BP_FUNC
(
)
;
return
true
;
}
return
false
;
}
inline
bool
HadSimulatedInterrupt
(
)
{
return
interruptCheckCounter
>
=
maxInterruptChecks
;
}
}
}
#
define
JS_OOM_POSSIBLY_FAIL
(
)
\
do
{
\
if
(
js
:
:
oom
:
:
ShouldFailWithOOM
(
)
)
\
return
nullptr
;
\
}
while
(
0
)
#
define
JS_OOM_POSSIBLY_FAIL_BOOL
(
)
\
do
{
\
if
(
js
:
:
oom
:
:
ShouldFailWithOOM
(
)
)
\
return
false
;
\
}
while
(
0
)
#
define
JS_STACK_OOM_POSSIBLY_FAIL
(
)
\
do
{
\
if
(
js
:
:
oom
:
:
ShouldFailWithStackOOM
(
)
)
\
return
false
;
\
}
while
(
0
)
#
define
JS_STACK_OOM_POSSIBLY_FAIL_REPORT
(
)
\
do
{
\
if
(
js
:
:
oom
:
:
ShouldFailWithStackOOM
(
)
)
{
\
ReportOverRecursed
(
cx
)
;
\
return
false
;
\
}
\
}
while
(
0
)
#
define
JS_INTERRUPT_POSSIBLY_FAIL
(
)
\
do
{
\
if
(
MOZ_UNLIKELY
(
js
:
:
oom
:
:
ShouldFailWithInterrupt
(
)
)
)
{
\
cx
-
>
requestInterrupt
(
js
:
:
InterruptReason
:
:
CallbackUrgent
)
;
\
return
cx
-
>
handleInterrupt
(
)
;
\
}
\
}
while
(
0
)
#
else
#
define
JS_OOM_POSSIBLY_FAIL
(
)
do
{
}
while
(
0
)
#
define
JS_OOM_POSSIBLY_FAIL_BOOL
(
)
do
{
}
while
(
0
)
#
define
JS_STACK_OOM_POSSIBLY_FAIL
(
)
do
{
}
while
(
0
)
#
define
JS_STACK_OOM_POSSIBLY_FAIL_REPORT
(
)
do
{
}
while
(
0
)
#
define
JS_INTERRUPT_POSSIBLY_FAIL
(
)
do
{
}
while
(
0
)
namespace
js
{
namespace
oom
{
static
inline
bool
IsSimulatedOOMAllocation
(
)
{
return
false
;
}
static
inline
bool
ShouldFailWithOOM
(
)
{
return
false
;
}
}
}
#
endif
namespace
js
{
struct
MOZ_RAII
JS_PUBLIC_DATA
(
AutoEnterOOMUnsafeRegion
)
{
MOZ_NORETURN
MOZ_COLD
void
crash
(
const
char
*
reason
)
;
MOZ_NORETURN
MOZ_COLD
void
crash
(
size_t
size
const
char
*
reason
)
;
using
AnnotateOOMAllocationSizeCallback
=
void
(
*
)
(
size_t
)
;
static
AnnotateOOMAllocationSizeCallback
annotateOOMSizeCallback
;
static
void
setAnnotateOOMAllocationSizeCallback
(
AnnotateOOMAllocationSizeCallback
callback
)
{
annotateOOMSizeCallback
=
callback
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
AutoEnterOOMUnsafeRegion
(
)
:
oomEnabled_
(
oom
:
:
IsThreadSimulatingOOM
(
)
&
&
oom
:
:
maxAllocations
!
=
UINT64_MAX
)
oomAfter_
(
0
)
{
if
(
oomEnabled_
)
{
MOZ_ALWAYS_TRUE
(
owner_
.
compareExchange
(
nullptr
this
)
)
;
oomAfter_
=
int64_t
(
oom
:
:
maxAllocations
)
-
int64_t
(
oom
:
:
counter
)
;
oom
:
:
maxAllocations
=
UINT64_MAX
;
}
}
~
AutoEnterOOMUnsafeRegion
(
)
{
if
(
oomEnabled_
)
{
MOZ_ASSERT
(
oom
:
:
maxAllocations
=
=
UINT64_MAX
)
;
int64_t
maxAllocations
=
int64_t
(
oom
:
:
counter
)
+
oomAfter_
;
MOZ_ASSERT
(
maxAllocations
>
=
0
"
alloc
count
+
oom
limit
exceeds
range
your
oom
limit
is
probably
too
large
"
)
;
oom
:
:
maxAllocations
=
uint64_t
(
maxAllocations
)
;
MOZ_ALWAYS_TRUE
(
owner_
.
compareExchange
(
this
nullptr
)
)
;
}
}
private
:
static
mozilla
:
:
Atomic
<
AutoEnterOOMUnsafeRegion
*
>
owner_
;
bool
oomEnabled_
;
int64_t
oomAfter_
;
#
endif
}
;
}
namespace
js
{
extern
JS_PUBLIC_DATA
(
arena_id_t
)
MallocArena
;
extern
JS_PUBLIC_DATA
(
arena_id_t
)
ArrayBufferContentsArena
;
extern
void
InitMallocAllocator
(
)
;
extern
void
ShutDownMallocAllocator
(
)
;
}
static
inline
void
*
js_arena_malloc
(
arena_id_t
arena
size_t
bytes
)
{
JS_OOM_POSSIBLY_FAIL
(
)
;
return
moz_arena_malloc
(
arena
bytes
)
;
}
static
inline
void
*
js_malloc
(
size_t
bytes
)
{
return
js_arena_malloc
(
js
:
:
MallocArena
bytes
)
;
}
static
inline
void
*
js_arena_calloc
(
arena_id_t
arena
size_t
nmemb
size_t
size
)
{
JS_OOM_POSSIBLY_FAIL
(
)
;
return
moz_arena_calloc
(
arena
nmemb
size
)
;
}
static
inline
void
*
js_calloc
(
size_t
bytes
)
{
return
js_arena_calloc
(
js
:
:
MallocArena
bytes
1
)
;
}
static
inline
void
*
js_calloc
(
size_t
nmemb
size_t
size
)
{
return
js_arena_calloc
(
js
:
:
MallocArena
nmemb
size
)
;
}
static
inline
void
*
js_arena_realloc
(
arena_id_t
arena
void
*
p
size_t
bytes
)
{
MOZ_ASSERT
(
bytes
!
=
0
)
;
JS_OOM_POSSIBLY_FAIL
(
)
;
return
moz_arena_realloc
(
arena
p
bytes
)
;
}
static
inline
void
*
js_realloc
(
void
*
p
size_t
bytes
)
{
return
js_arena_realloc
(
js
:
:
MallocArena
p
bytes
)
;
}
static
inline
void
js_free
(
void
*
p
)
{
free
(
p
)
;
}
#
endif
#
include
<
new
>
#
define
JS_DECLARE_NEW_METHODS
(
NEWNAME
ALLOCATOR
QUALIFIERS
)
\
template
<
class
T
typename
.
.
.
Args
>
\
QUALIFIERS
T
*
\
NEWNAME
(
Args
&
&
.
.
.
args
)
MOZ_HEAP_ALLOCATOR
{
\
void
*
memory
=
ALLOCATOR
(
sizeof
(
T
)
)
;
\
return
MOZ_LIKELY
(
memory
)
\
?
new
(
memory
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
\
:
nullptr
;
\
}
#
define
JS_DECLARE_MAKE_METHODS
(
MAKENAME
NEWNAME
QUALIFIERS
)
\
template
<
class
T
typename
.
.
.
Args
>
\
QUALIFIERS
mozilla
:
:
UniquePtr
<
T
JS
:
:
DeletePolicy
<
T
>
>
\
MAKENAME
(
Args
&
&
.
.
.
args
)
MOZ_HEAP_ALLOCATOR
{
\
T
*
ptr
=
NEWNAME
<
T
>
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
\
return
mozilla
:
:
UniquePtr
<
T
JS
:
:
DeletePolicy
<
T
>
>
(
ptr
)
;
\
}
JS_DECLARE_NEW_METHODS
(
js_new
js_malloc
static
MOZ_ALWAYS_INLINE
)
namespace
js
{
template
<
typename
T
>
MOZ_MUST_USE
inline
bool
CalculateAllocSize
(
size_t
numElems
size_t
*
bytesOut
)
{
*
bytesOut
=
numElems
*
sizeof
(
T
)
;
return
(
numElems
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
sizeof
(
T
)
>
:
:
value
)
=
=
0
;
}
template
<
typename
T
typename
Extra
>
MOZ_MUST_USE
inline
bool
CalculateAllocSizeWithExtra
(
size_t
numExtra
size_t
*
bytesOut
)
{
*
bytesOut
=
sizeof
(
T
)
+
numExtra
*
sizeof
(
Extra
)
;
return
(
numExtra
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
sizeof
(
Extra
)
>
:
:
value
)
=
=
0
&
&
*
bytesOut
>
=
sizeof
(
T
)
;
}
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
void
js_delete
(
const
T
*
p
)
{
if
(
p
)
{
p
-
>
~
T
(
)
;
js_free
(
const_cast
<
T
*
>
(
p
)
)
;
}
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
void
js_delete_poison
(
const
T
*
p
)
{
if
(
p
)
{
p
-
>
~
T
(
)
;
memset
(
static_cast
<
void
*
>
(
const_cast
<
T
*
>
(
p
)
)
0x3B
sizeof
(
T
)
)
;
js_free
(
const_cast
<
T
*
>
(
p
)
)
;
}
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
T
*
js_pod_arena_malloc
(
arena_id_t
arena
size_t
numElems
)
{
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
js
:
:
CalculateAllocSize
<
T
>
(
numElems
&
bytes
)
)
)
return
nullptr
;
return
static_cast
<
T
*
>
(
js_arena_malloc
(
arena
bytes
)
)
;
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
T
*
js_pod_malloc
(
size_t
numElems
)
{
return
js_pod_arena_malloc
<
T
>
(
js
:
:
MallocArena
numElems
)
;
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
T
*
js_pod_malloc
(
)
{
return
js_pod_malloc
<
T
>
(
sizeof
(
T
)
)
;
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
T
*
js_pod_arena_calloc
(
arena_id_t
arena
size_t
numElems
)
{
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
js
:
:
CalculateAllocSize
<
T
>
(
numElems
&
bytes
)
)
)
return
nullptr
;
return
static_cast
<
T
*
>
(
js_arena_calloc
(
arena
bytes
1
)
)
;
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
T
*
js_pod_calloc
(
size_t
numElems
)
{
return
js_pod_arena_calloc
<
T
>
(
js
:
:
MallocArena
numElems
)
;
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
T
*
js_pod_calloc
(
)
{
return
js_pod_calloc
<
T
>
(
sizeof
(
T
)
)
;
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
T
*
js_pod_realloc
(
T
*
prior
size_t
oldSize
size_t
newSize
)
{
MOZ_ASSERT
(
!
(
oldSize
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
sizeof
(
T
)
>
:
:
value
)
)
;
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
js
:
:
CalculateAllocSize
<
T
>
(
newSize
&
bytes
)
)
)
return
nullptr
;
return
static_cast
<
T
*
>
(
js_realloc
(
prior
bytes
)
)
;
}
namespace
JS
{
template
<
typename
T
>
struct
DeletePolicy
{
constexpr
DeletePolicy
(
)
{
}
template
<
typename
U
>
MOZ_IMPLICIT
DeletePolicy
(
DeletePolicy
<
U
>
other
typename
mozilla
:
:
EnableIf
<
mozilla
:
:
IsConvertible
<
U
*
T
*
>
:
:
value
int
>
:
:
Type
dummy
=
0
)
{
}
void
operator
(
)
(
const
T
*
ptr
)
{
js_delete
(
const_cast
<
T
*
>
(
ptr
)
)
;
}
}
;
struct
FreePolicy
{
void
operator
(
)
(
const
void
*
ptr
)
{
js_free
(
const_cast
<
void
*
>
(
ptr
)
)
;
}
}
;
typedef
mozilla
:
:
UniquePtr
<
char
[
]
JS
:
:
FreePolicy
>
UniqueChars
;
typedef
mozilla
:
:
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
UniqueTwoByteChars
;
}
namespace
js
{
typedef
uint32_t
HashNumber
;
const
unsigned
HashNumberSizeBits
=
32
;
namespace
detail
{
inline
HashNumber
ScrambleHashCode
(
HashNumber
h
)
{
static
const
HashNumber
goldenRatio
=
0x9E3779B9U
;
return
mozilla
:
:
WrappingMultiply
(
h
goldenRatio
)
;
}
}
}
#
ifndef
HAVE_STATIC_ANNOTATIONS
#
define
HAVE_STATIC_ANNOTATIONS
#
ifdef
XGILL_PLUGIN
#
define
STATIC_PRECONDITION
(
COND
)
__attribute__
(
(
precondition
(
#
COND
)
)
)
#
define
STATIC_PRECONDITION_ASSUME
(
COND
)
__attribute__
(
(
precondition_assume
(
#
COND
)
)
)
#
define
STATIC_POSTCONDITION
(
COND
)
__attribute__
(
(
postcondition
(
#
COND
)
)
)
#
define
STATIC_POSTCONDITION_ASSUME
(
COND
)
__attribute__
(
(
postcondition_assume
(
#
COND
)
)
)
#
define
STATIC_INVARIANT
(
COND
)
__attribute__
(
(
invariant
(
#
COND
)
)
)
#
define
STATIC_INVARIANT_ASSUME
(
COND
)
__attribute__
(
(
invariant_assume
(
#
COND
)
)
)
#
define
STATIC_ASSUME
(
COND
)
\
JS_BEGIN_MACRO
\
__attribute__
(
(
assume_static
(
#
COND
)
unused
)
)
\
int
STATIC_PASTE1
(
assume_static_
__COUNTER__
)
;
\
JS_END_MACRO
#
else
#
define
STATIC_PRECONDITION
(
COND
)
#
define
STATIC_PRECONDITION_ASSUME
(
COND
)
#
define
STATIC_POSTCONDITION
(
COND
)
#
define
STATIC_POSTCONDITION_ASSUME
(
COND
)
#
define
STATIC_INVARIANT
(
COND
)
#
define
STATIC_INVARIANT_ASSUME
(
COND
)
#
define
STATIC_ASSUME
(
COND
)
JS_BEGIN_MACRO
/
*
nothing
*
/
JS_END_MACRO
#
endif
#
define
STATIC_SKIP_INFERENCE
STATIC_INVARIANT
(
skip_inference
(
)
)
#
endif
#
endif
