#
ifndef
js_Utility_h
#
define
js_Utility_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Compiler
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Scoped
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
ifdef
JS_OOM_DO_BACKTRACES
#
include
<
execinfo
.
h
>
#
include
<
stdio
.
h
>
#
endif
#
include
"
jstypes
.
h
"
namespace
JS
{
}
namespace
mozilla
{
}
namespace
js
{
}
#
define
JS_FRESH_NURSERY_PATTERN
0x2F
#
define
JS_SWEPT_NURSERY_PATTERN
0x2B
#
define
JS_ALLOCATED_NURSERY_PATTERN
0x2D
#
define
JS_FRESH_TENURED_PATTERN
0x4F
#
define
JS_MOVED_TENURED_PATTERN
0x49
#
define
JS_SWEPT_TENURED_PATTERN
0x4B
#
define
JS_ALLOCATED_TENURED_PATTERN
0x4D
#
define
JS_EMPTY_STOREBUFFER_PATTERN
0x1B
#
define
JS_SWEPT_CODE_PATTERN
0x3B
#
define
JS_SWEPT_FRAME_PATTERN
0x5B
#
define
JS_STATIC_ASSERT
(
cond
)
static_assert
(
cond
"
JS_STATIC_ASSERT
"
)
#
define
JS_STATIC_ASSERT_IF
(
cond
expr
)
MOZ_STATIC_ASSERT_IF
(
cond
expr
"
JS_STATIC_ASSERT_IF
"
)
extern
MOZ_NORETURN
MOZ_COLD
JS_PUBLIC_API
(
void
)
JS_Assert
(
const
char
*
s
const
char
*
file
int
ln
)
;
#
if
defined
JS_USE_CUSTOM_ALLOCATOR
#
include
"
jscustomallocator
.
h
"
#
else
namespace
js
{
namespace
oom
{
enum
ThreadType
{
THREAD_TYPE_NONE
=
0
THREAD_TYPE_MAIN
THREAD_TYPE_ASMJS
THREAD_TYPE_ION
THREAD_TYPE_PARSE
THREAD_TYPE_COMPRESS
THREAD_TYPE_GCHELPER
THREAD_TYPE_GCPARALLEL
THREAD_TYPE_MAX
}
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
extern
bool
InitThreadType
(
void
)
;
extern
void
SetThreadType
(
ThreadType
)
;
extern
uint32_t
GetThreadType
(
void
)
;
#
else
inline
bool
InitThreadType
(
void
)
{
return
true
;
}
inline
void
SetThreadType
(
ThreadType
t
)
{
}
;
inline
uint32_t
GetThreadType
(
void
)
{
return
0
;
}
#
endif
}
}
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
extern
JS_PUBLIC_DATA
(
uint32_t
)
OOM_maxAllocations
;
extern
JS_PUBLIC_DATA
(
uint32_t
)
OOM_counter
;
extern
JS_PUBLIC_DATA
(
bool
)
OOM_failAlways
;
#
ifdef
JS_OOM_BREAKPOINT
static
MOZ_NEVER_INLINE
void
js_failedAllocBreakpoint
(
)
{
asm
(
"
"
)
;
}
#
define
JS_OOM_CALL_BP_FUNC
(
)
js_failedAllocBreakpoint
(
)
#
else
#
define
JS_OOM_CALL_BP_FUNC
(
)
do
{
}
while
(
0
)
#
endif
namespace
js
{
namespace
oom
{
extern
JS_PUBLIC_DATA
(
uint32_t
)
targetThread
;
static
inline
bool
IsThreadSimulatingOOM
(
)
{
return
js
:
:
oom
:
:
targetThread
&
&
js
:
:
oom
:
:
targetThread
=
=
js
:
:
oom
:
:
GetThreadType
(
)
;
}
static
inline
bool
IsSimulatedOOMAllocation
(
)
{
return
IsThreadSimulatingOOM
(
)
&
&
(
OOM_counter
=
=
OOM_maxAllocations
|
|
(
OOM_counter
>
OOM_maxAllocations
&
&
OOM_failAlways
)
)
;
}
static
inline
bool
ShouldFailWithOOM
(
)
{
if
(
!
IsThreadSimulatingOOM
(
)
)
return
false
;
OOM_counter
+
+
;
if
(
IsSimulatedOOMAllocation
(
)
)
{
JS_OOM_CALL_BP_FUNC
(
)
;
return
true
;
}
return
false
;
}
}
}
#
define
JS_OOM_POSSIBLY_FAIL
(
)
\
do
{
\
if
(
js
:
:
oom
:
:
ShouldFailWithOOM
(
)
)
\
return
nullptr
;
\
}
while
(
0
)
#
define
JS_OOM_POSSIBLY_FAIL_BOOL
(
)
\
do
{
\
if
(
js
:
:
oom
:
:
ShouldFailWithOOM
(
)
)
\
return
false
;
\
}
while
(
0
)
#
else
#
define
JS_OOM_POSSIBLY_FAIL
(
)
do
{
}
while
(
0
)
#
define
JS_OOM_POSSIBLY_FAIL_BOOL
(
)
do
{
}
while
(
0
)
namespace
js
{
namespace
oom
{
static
inline
bool
IsSimulatedOOMAllocation
(
)
{
return
false
;
}
static
inline
bool
ShouldFailWithOOM
(
)
{
return
false
;
}
}
}
#
endif
namespace
js
{
struct
MOZ_RAII
AutoEnterOOMUnsafeRegion
{
MOZ_NORETURN
MOZ_COLD
void
crash
(
const
char
*
reason
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
JS_OOM_BREAKPOINT
)
AutoEnterOOMUnsafeRegion
(
)
:
oomEnabled_
(
oom
:
:
IsThreadSimulatingOOM
(
)
&
&
OOM_maxAllocations
!
=
UINT32_MAX
)
oomAfter_
(
0
)
{
if
(
oomEnabled_
)
{
oomAfter_
=
int64_t
(
OOM_maxAllocations
)
-
OOM_counter
;
OOM_maxAllocations
=
UINT32_MAX
;
}
}
~
AutoEnterOOMUnsafeRegion
(
)
{
if
(
oomEnabled_
)
{
MOZ_ASSERT
(
OOM_maxAllocations
=
=
UINT32_MAX
)
;
int64_t
maxAllocations
=
OOM_counter
+
oomAfter_
;
MOZ_ASSERT
(
maxAllocations
>
=
0
&
&
maxAllocations
<
UINT32_MAX
"
alloc
count
+
oom
limit
exceeds
range
your
oom
limit
is
probably
too
large
"
)
;
OOM_maxAllocations
=
uint32_t
(
maxAllocations
)
;
}
}
private
:
bool
oomEnabled_
;
int64_t
oomAfter_
;
#
endif
}
;
}
static
inline
void
*
js_malloc
(
size_t
bytes
)
{
JS_OOM_POSSIBLY_FAIL
(
)
;
return
malloc
(
bytes
)
;
}
static
inline
void
*
js_calloc
(
size_t
bytes
)
{
JS_OOM_POSSIBLY_FAIL
(
)
;
return
calloc
(
bytes
1
)
;
}
static
inline
void
*
js_calloc
(
size_t
nmemb
size_t
size
)
{
JS_OOM_POSSIBLY_FAIL
(
)
;
return
calloc
(
nmemb
size
)
;
}
static
inline
void
*
js_realloc
(
void
*
p
size_t
bytes
)
{
MOZ_ASSERT
(
bytes
!
=
0
)
;
JS_OOM_POSSIBLY_FAIL
(
)
;
return
realloc
(
p
bytes
)
;
}
static
inline
void
js_free
(
void
*
p
)
{
free
(
p
)
;
}
static
inline
char
*
js_strdup
(
const
char
*
s
)
{
JS_OOM_POSSIBLY_FAIL
(
)
;
return
strdup
(
s
)
;
}
#
endif
#
include
<
new
>
#
define
JS_DECLARE_NEW_METHODS
(
NEWNAME
ALLOCATOR
QUALIFIERS
)
\
template
<
class
T
typename
.
.
.
Args
>
\
QUALIFIERS
T
*
\
NEWNAME
(
Args
&
&
.
.
.
args
)
MOZ_HEAP_ALLOCATOR
{
\
void
*
memory
=
ALLOCATOR
(
sizeof
(
T
)
)
;
\
return
MOZ_LIKELY
(
memory
)
\
?
new
(
memory
)
T
(
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
\
:
nullptr
;
\
}
#
define
JS_DECLARE_MAKE_METHODS
(
MAKENAME
NEWNAME
QUALIFIERS
)
\
template
<
class
T
typename
.
.
.
Args
>
\
QUALIFIERS
mozilla
:
:
UniquePtr
<
T
JS
:
:
DeletePolicy
<
T
>
>
\
MAKENAME
(
Args
&
&
.
.
.
args
)
MOZ_HEAP_ALLOCATOR
{
\
T
*
ptr
=
NEWNAME
<
T
>
(
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
;
\
return
mozilla
:
:
UniquePtr
<
T
JS
:
:
DeletePolicy
<
T
>
>
(
ptr
)
;
\
}
JS_DECLARE_NEW_METHODS
(
js_new
js_malloc
static
MOZ_ALWAYS_INLINE
)
namespace
js
{
template
<
typename
T
>
MOZ_WARN_UNUSED_RESULT
inline
bool
CalculateAllocSize
(
size_t
numElems
size_t
*
bytesOut
)
{
*
bytesOut
=
numElems
*
sizeof
(
T
)
;
return
(
numElems
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
sizeof
(
T
)
>
:
:
value
)
=
=
0
;
}
template
<
typename
T
typename
Extra
>
MOZ_WARN_UNUSED_RESULT
inline
bool
CalculateAllocSizeWithExtra
(
size_t
numExtra
size_t
*
bytesOut
)
{
*
bytesOut
=
sizeof
(
T
)
+
numExtra
*
sizeof
(
Extra
)
;
return
(
numExtra
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
sizeof
(
Extra
)
>
:
:
value
)
=
=
0
&
&
*
bytesOut
>
=
sizeof
(
T
)
;
}
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
void
js_delete
(
const
T
*
p
)
{
if
(
p
)
{
p
-
>
~
T
(
)
;
js_free
(
const_cast
<
T
*
>
(
p
)
)
;
}
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
void
js_delete_poison
(
const
T
*
p
)
{
if
(
p
)
{
p
-
>
~
T
(
)
;
memset
(
const_cast
<
T
*
>
(
p
)
0x3B
sizeof
(
T
)
)
;
js_free
(
const_cast
<
T
*
>
(
p
)
)
;
}
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
T
*
js_pod_malloc
(
)
{
return
static_cast
<
T
*
>
(
js_malloc
(
sizeof
(
T
)
)
)
;
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
T
*
js_pod_calloc
(
)
{
return
static_cast
<
T
*
>
(
js_calloc
(
sizeof
(
T
)
)
)
;
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
T
*
js_pod_malloc
(
size_t
numElems
)
{
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
js
:
:
CalculateAllocSize
<
T
>
(
numElems
&
bytes
)
)
)
return
nullptr
;
return
static_cast
<
T
*
>
(
js_malloc
(
bytes
)
)
;
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
T
*
js_pod_calloc
(
size_t
numElems
)
{
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
js
:
:
CalculateAllocSize
<
T
>
(
numElems
&
bytes
)
)
)
return
nullptr
;
return
static_cast
<
T
*
>
(
js_calloc
(
bytes
)
)
;
}
template
<
class
T
>
static
MOZ_ALWAYS_INLINE
T
*
js_pod_realloc
(
T
*
prior
size_t
oldSize
size_t
newSize
)
{
MOZ_ASSERT
(
!
(
oldSize
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
sizeof
(
T
)
>
:
:
value
)
)
;
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
js
:
:
CalculateAllocSize
<
T
>
(
newSize
&
bytes
)
)
)
return
nullptr
;
return
static_cast
<
T
*
>
(
js_realloc
(
prior
bytes
)
)
;
}
namespace
js
{
template
<
typename
T
>
struct
ScopedFreePtrTraits
{
typedef
T
*
type
;
static
T
*
empty
(
)
{
return
nullptr
;
}
static
void
release
(
T
*
ptr
)
{
js_free
(
ptr
)
;
}
}
;
SCOPED_TEMPLATE
(
ScopedJSFreePtr
ScopedFreePtrTraits
)
template
<
typename
T
>
struct
ScopedDeletePtrTraits
:
public
ScopedFreePtrTraits
<
T
>
{
static
void
release
(
T
*
ptr
)
{
js_delete
(
ptr
)
;
}
}
;
SCOPED_TEMPLATE
(
ScopedJSDeletePtr
ScopedDeletePtrTraits
)
template
<
typename
T
>
struct
ScopedReleasePtrTraits
:
public
ScopedFreePtrTraits
<
T
>
{
static
void
release
(
T
*
ptr
)
{
if
(
ptr
)
ptr
-
>
release
(
)
;
}
}
;
SCOPED_TEMPLATE
(
ScopedReleasePtr
ScopedReleasePtrTraits
)
}
namespace
JS
{
template
<
typename
T
>
struct
DeletePolicy
{
MOZ_CONSTEXPR
DeletePolicy
(
)
{
}
template
<
typename
U
>
MOZ_IMPLICIT
DeletePolicy
(
DeletePolicy
<
U
>
other
typename
mozilla
:
:
EnableIf
<
mozilla
:
:
IsConvertible
<
U
*
T
*
>
:
:
value
int
>
:
:
Type
dummy
=
0
)
{
}
void
operator
(
)
(
const
T
*
ptr
)
{
js_delete
(
const_cast
<
T
*
>
(
ptr
)
)
;
}
}
;
struct
FreePolicy
{
void
operator
(
)
(
const
void
*
ptr
)
{
js_free
(
const_cast
<
void
*
>
(
ptr
)
)
;
}
}
;
typedef
mozilla
:
:
UniquePtr
<
char
[
]
JS
:
:
FreePolicy
>
UniqueChars
;
typedef
mozilla
:
:
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
UniqueTwoByteChars
;
}
namespace
js
{
typedef
uint32_t
HashNumber
;
const
unsigned
HashNumberSizeBits
=
32
;
namespace
detail
{
inline
HashNumber
ScrambleHashCode
(
HashNumber
h
)
{
static
const
HashNumber
goldenRatio
=
0x9E3779B9U
;
return
h
*
goldenRatio
;
}
}
}
#
ifndef
HAVE_STATIC_ANNOTATIONS
#
define
HAVE_STATIC_ANNOTATIONS
#
ifdef
XGILL_PLUGIN
#
define
STATIC_PRECONDITION
(
COND
)
__attribute__
(
(
precondition
(
#
COND
)
)
)
#
define
STATIC_PRECONDITION_ASSUME
(
COND
)
__attribute__
(
(
precondition_assume
(
#
COND
)
)
)
#
define
STATIC_POSTCONDITION
(
COND
)
__attribute__
(
(
postcondition
(
#
COND
)
)
)
#
define
STATIC_POSTCONDITION_ASSUME
(
COND
)
__attribute__
(
(
postcondition_assume
(
#
COND
)
)
)
#
define
STATIC_INVARIANT
(
COND
)
__attribute__
(
(
invariant
(
#
COND
)
)
)
#
define
STATIC_INVARIANT_ASSUME
(
COND
)
__attribute__
(
(
invariant_assume
(
#
COND
)
)
)
#
define
STATIC_ASSUME
(
COND
)
\
JS_BEGIN_MACRO
\
__attribute__
(
(
assume_static
(
#
COND
)
unused
)
)
\
int
STATIC_PASTE1
(
assume_static_
__COUNTER__
)
;
\
JS_END_MACRO
#
else
#
define
STATIC_PRECONDITION
(
COND
)
#
define
STATIC_PRECONDITION_ASSUME
(
COND
)
#
define
STATIC_POSTCONDITION
(
COND
)
#
define
STATIC_POSTCONDITION_ASSUME
(
COND
)
#
define
STATIC_INVARIANT
(
COND
)
#
define
STATIC_INVARIANT_ASSUME
(
COND
)
#
define
STATIC_ASSUME
(
COND
)
JS_BEGIN_MACRO
/
*
nothing
*
/
JS_END_MACRO
#
endif
#
define
STATIC_SKIP_INFERENCE
STATIC_INVARIANT
(
skip_inference
(
)
)
#
endif
#
endif
