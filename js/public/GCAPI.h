#
ifndef
js_GCAPI_h
#
define
js_GCAPI_h
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
namespace
js
{
namespace
gc
{
class
GCRuntime
;
}
namespace
gcstats
{
struct
Statistics
;
}
}
typedef
enum
JSGCMode
{
JSGC_MODE_GLOBAL
=
0
JSGC_MODE_ZONE
=
1
JSGC_MODE_INCREMENTAL
=
2
}
JSGCMode
;
typedef
enum
JSGCInvocationKind
{
GC_NORMAL
=
0
GC_SHRINK
=
1
}
JSGCInvocationKind
;
namespace
JS
{
#
define
GCREASONS
(
D
)
\
D
(
API
)
\
D
(
EAGER_ALLOC_TRIGGER
)
\
D
(
DESTROY_RUNTIME
)
\
D
(
ROOTS_REMOVED
)
\
D
(
LAST_DITCH
)
\
D
(
TOO_MUCH_MALLOC
)
\
D
(
ALLOC_TRIGGER
)
\
D
(
DEBUG_GC
)
\
D
(
COMPARTMENT_REVIVED
)
\
D
(
RESET
)
\
D
(
OUT_OF_NURSERY
)
\
D
(
EVICT_NURSERY
)
\
D
(
DELAYED_ATOMS_GC
)
\
D
(
SHARED_MEMORY_LIMIT
)
\
D
(
UNUSED1
)
\
D
(
INCREMENTAL_TOO_SLOW
)
\
D
(
ABORT_GC
)
\
D
(
FULL_WHOLE_CELL_BUFFER
)
\
D
(
FULL_GENERIC_BUFFER
)
\
D
(
FULL_VALUE_BUFFER
)
\
D
(
FULL_CELL_PTR_BUFFER
)
\
D
(
FULL_SLOT_BUFFER
)
\
D
(
FULL_SHAPE_BUFFER
)
\
\
/
*
These
are
reserved
for
future
use
.
*
/
\
D
(
RESERVED0
)
\
D
(
RESERVED1
)
\
D
(
RESERVED2
)
\
D
(
RESERVED3
)
\
D
(
RESERVED4
)
\
D
(
RESERVED5
)
\
D
(
RESERVED6
)
\
D
(
RESERVED7
)
\
D
(
RESERVED8
)
\
D
(
RESERVED9
)
\
\
/
*
Reasons
from
Firefox
*
/
\
D
(
DOM_WINDOW_UTILS
)
\
D
(
COMPONENT_UTILS
)
\
D
(
MEM_PRESSURE
)
\
D
(
CC_WAITING
)
\
D
(
CC_FORCED
)
\
D
(
LOAD_END
)
\
D
(
POST_COMPARTMENT
)
\
D
(
PAGE_HIDE
)
\
D
(
NSJSCONTEXT_DESTROY
)
\
D
(
SET_NEW_DOCUMENT
)
\
D
(
SET_DOC_SHELL
)
\
D
(
DOM_UTILS
)
\
D
(
DOM_IPC
)
\
D
(
DOM_WORKER
)
\
D
(
INTER_SLICE_GC
)
\
D
(
REFRESH_FRAME
)
\
D
(
FULL_GC_TIMER
)
\
D
(
SHUTDOWN_CC
)
\
D
(
UNUSED2
)
\
D
(
USER_INACTIVE
)
\
D
(
XPCONNECT_SHUTDOWN
)
namespace
gcreason
{
enum
Reason
{
#
define
MAKE_REASON
(
name
)
name
GCREASONS
(
MAKE_REASON
)
#
undef
MAKE_REASON
NO_REASON
NUM_REASONS
NUM_TELEMETRY_REASONS
=
100
}
;
extern
JS_PUBLIC_API
(
const
char
*
)
ExplainReason
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
}
extern
JS_PUBLIC_API
(
void
)
PrepareZoneForGC
(
Zone
*
zone
)
;
extern
JS_PUBLIC_API
(
void
)
PrepareForFullGC
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
void
)
PrepareForIncrementalGC
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
bool
)
IsGCScheduled
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
void
)
SkipZoneForGC
(
Zone
*
zone
)
;
extern
JS_PUBLIC_API
(
void
)
GCForReason
(
JSContext
*
cx
JSGCInvocationKind
gckind
gcreason
:
:
Reason
reason
)
;
extern
JS_PUBLIC_API
(
void
)
StartIncrementalGC
(
JSContext
*
cx
JSGCInvocationKind
gckind
gcreason
:
:
Reason
reason
int64_t
millis
=
0
)
;
extern
JS_PUBLIC_API
(
void
)
IncrementalGCSlice
(
JSContext
*
cx
gcreason
:
:
Reason
reason
int64_t
millis
=
0
)
;
extern
JS_PUBLIC_API
(
void
)
FinishIncrementalGC
(
JSContext
*
cx
gcreason
:
:
Reason
reason
)
;
extern
JS_PUBLIC_API
(
void
)
AbortIncrementalGC
(
JSContext
*
cx
)
;
namespace
dbg
{
class
GarbageCollectionEvent
{
uint64_t
majorGCNumber_
;
const
char
*
reason
;
const
char
*
nonincrementalReason
;
struct
Collection
{
mozilla
:
:
TimeStamp
startTimestamp
;
mozilla
:
:
TimeStamp
endTimestamp
;
}
;
mozilla
:
:
Vector
<
Collection
>
collections
;
GarbageCollectionEvent
(
const
GarbageCollectionEvent
&
rhs
)
=
delete
;
GarbageCollectionEvent
&
operator
=
(
const
GarbageCollectionEvent
&
rhs
)
=
delete
;
public
:
explicit
GarbageCollectionEvent
(
uint64_t
majorGCNum
)
:
majorGCNumber_
(
majorGCNum
)
reason
(
nullptr
)
nonincrementalReason
(
nullptr
)
collections
(
)
{
}
using
Ptr
=
js
:
:
UniquePtr
<
GarbageCollectionEvent
>
;
static
Ptr
Create
(
JSRuntime
*
rt
:
:
js
:
:
gcstats
:
:
Statistics
&
stats
uint64_t
majorGCNumber
)
;
JSObject
*
toJSObject
(
JSContext
*
cx
)
const
;
uint64_t
majorGCNumber
(
)
const
{
return
majorGCNumber_
;
}
}
;
}
enum
GCProgress
{
GC_CYCLE_BEGIN
GC_SLICE_BEGIN
GC_SLICE_END
GC_CYCLE_END
}
;
struct
JS_PUBLIC_API
(
GCDescription
)
{
bool
isZone_
;
bool
isComplete_
;
JSGCInvocationKind
invocationKind_
;
gcreason
:
:
Reason
reason_
;
GCDescription
(
bool
isZone
bool
isComplete
JSGCInvocationKind
kind
gcreason
:
:
Reason
reason
)
:
isZone_
(
isZone
)
isComplete_
(
isComplete
)
invocationKind_
(
kind
)
reason_
(
reason
)
{
}
char16_t
*
formatSliceMessage
(
JSContext
*
cx
)
const
;
char16_t
*
formatSummaryMessage
(
JSContext
*
cx
)
const
;
char16_t
*
formatJSON
(
JSContext
*
cx
uint64_t
timestamp
)
const
;
mozilla
:
:
TimeStamp
startTime
(
JSContext
*
cx
)
const
;
mozilla
:
:
TimeStamp
endTime
(
JSContext
*
cx
)
const
;
mozilla
:
:
TimeStamp
lastSliceStart
(
JSContext
*
cx
)
const
;
mozilla
:
:
TimeStamp
lastSliceEnd
(
JSContext
*
cx
)
const
;
JS
:
:
UniqueChars
sliceToJSON
(
JSContext
*
cx
)
const
;
JS
:
:
UniqueChars
summaryToJSON
(
JSContext
*
cx
)
const
;
JS
:
:
dbg
:
:
GarbageCollectionEvent
:
:
Ptr
toGCEvent
(
JSContext
*
cx
)
const
;
}
;
extern
JS_PUBLIC_API
(
UniqueChars
)
MinorGcToJSON
(
JSContext
*
cx
)
;
typedef
void
(
*
GCSliceCallback
)
(
JSContext
*
cx
GCProgress
progress
const
GCDescription
&
desc
)
;
extern
JS_PUBLIC_API
(
GCSliceCallback
)
SetGCSliceCallback
(
JSContext
*
cx
GCSliceCallback
callback
)
;
enum
class
GCNurseryProgress
{
GC_NURSERY_COLLECTION_START
GC_NURSERY_COLLECTION_END
}
;
using
GCNurseryCollectionCallback
=
void
(
*
)
(
JSContext
*
cx
GCNurseryProgress
progress
gcreason
:
:
Reason
reason
)
;
extern
JS_PUBLIC_API
(
GCNurseryCollectionCallback
)
SetGCNurseryCollectionCallback
(
JSContext
*
cx
GCNurseryCollectionCallback
callback
)
;
typedef
void
(
*
DoCycleCollectionCallback
)
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
DoCycleCollectionCallback
)
SetDoCycleCollectionCallback
(
JSContext
*
cx
DoCycleCollectionCallback
callback
)
;
extern
JS_PUBLIC_API
(
void
)
DisableIncrementalGC
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
bool
)
IsIncrementalGCEnabled
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
bool
)
IsIncrementalGCInProgress
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
bool
)
IsIncrementalGCInProgress
(
JSRuntime
*
rt
)
;
extern
JS_PUBLIC_API
(
bool
)
IsIncrementalBarrierNeeded
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
void
)
IncrementalPreWriteBarrier
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
(
void
)
IncrementalReadBarrier
(
GCCellPtr
thing
)
;
extern
JS_PUBLIC_API
(
bool
)
WasIncrementalGC
(
JSRuntime
*
rt
)
;
class
JS_PUBLIC_API
(
AutoDisableGenerationalGC
)
{
JSContext
*
cx
;
public
:
explicit
AutoDisableGenerationalGC
(
JSContext
*
cx
)
;
~
AutoDisableGenerationalGC
(
)
;
}
;
extern
JS_PUBLIC_API
(
bool
)
IsGenerationalGCEnabled
(
JSRuntime
*
rt
)
;
extern
JS_PUBLIC_API
(
size_t
)
GetGCNumber
(
)
;
class
JS_PUBLIC_API
(
AutoRequireNoGC
)
{
protected
:
AutoRequireNoGC
(
)
{
}
~
AutoRequireNoGC
(
)
{
}
}
;
class
JS_PUBLIC_API
(
AutoAssertNoGC
)
:
public
AutoRequireNoGC
{
JSContext
*
cx_
;
public
:
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
explicit
AutoAssertNoGC
(
JSContext
*
cx
=
nullptr
)
;
~
AutoAssertNoGC
(
)
;
#
else
explicit
AutoAssertNoGC
(
JSContext
*
cx
=
nullptr
)
{
}
~
AutoAssertNoGC
(
)
{
}
#
endif
}
;
#
ifdef
DEBUG
class
JS_PUBLIC_API
(
AutoSuppressGCAnalysis
)
:
public
AutoAssertNoGC
{
public
:
explicit
AutoSuppressGCAnalysis
(
JSContext
*
cx
=
nullptr
)
:
AutoAssertNoGC
(
cx
)
{
}
}
JS_HAZ_GC_SUPPRESSED
;
#
else
class
JS_PUBLIC_API
(
AutoSuppressGCAnalysis
)
:
public
AutoRequireNoGC
{
public
:
explicit
AutoSuppressGCAnalysis
(
JSContext
*
cx
=
nullptr
)
{
}
}
JS_HAZ_GC_SUPPRESSED
;
#
endif
class
JS_PUBLIC_API
(
AutoAssertGCCallback
)
:
public
AutoSuppressGCAnalysis
{
public
:
#
ifdef
DEBUG
AutoAssertGCCallback
(
)
;
#
else
AutoAssertGCCallback
(
)
{
}
#
endif
}
;
#
ifdef
DEBUG
class
JS_PUBLIC_API
(
AutoCheckCannotGC
)
:
public
AutoAssertNoGC
{
public
:
explicit
AutoCheckCannotGC
(
JSContext
*
cx
=
nullptr
)
:
AutoAssertNoGC
(
cx
)
{
}
}
JS_HAZ_GC_INVALIDATED
;
#
else
class
JS_PUBLIC_API
(
AutoCheckCannotGC
)
:
public
AutoRequireNoGC
{
public
:
explicit
AutoCheckCannotGC
(
JSContext
*
cx
=
nullptr
)
{
}
}
JS_HAZ_GC_INVALIDATED
;
#
endif
extern
JS_FRIEND_API
(
bool
)
UnmarkGrayGCThingRecursively
(
GCCellPtr
thing
)
;
}
namespace
js
{
namespace
gc
{
static
MOZ_ALWAYS_INLINE
void
ExposeGCThingToActiveJS
(
JS
:
:
GCCellPtr
thing
)
{
if
(
IsInsideNursery
(
thing
.
asCell
(
)
)
)
return
;
if
(
thing
.
mayBeOwnedByOtherRuntime
(
)
)
return
;
if
(
IsIncrementalBarrierNeededOnTenuredGCThing
(
thing
)
)
JS
:
:
IncrementalReadBarrier
(
thing
)
;
else
if
(
js
:
:
gc
:
:
detail
:
:
TenuredCellIsMarkedGray
(
thing
.
asCell
(
)
)
)
JS
:
:
UnmarkGrayGCThingRecursively
(
thing
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
detail
:
:
TenuredCellIsMarkedGray
(
thing
.
asCell
(
)
)
)
;
}
template
<
typename
T
>
extern
JS_PUBLIC_API
(
bool
)
EdgeNeedsSweepUnbarrieredSlow
(
T
*
thingp
)
;
static
MOZ_ALWAYS_INLINE
bool
EdgeNeedsSweepUnbarriered
(
JSObject
*
*
objp
)
{
MOZ_ASSERT
(
!
JS
:
:
CurrentThreadIsHeapMinorCollecting
(
)
)
;
if
(
IsInsideNursery
(
reinterpret_cast
<
Cell
*
>
(
*
objp
)
)
)
return
false
;
auto
zone
=
JS
:
:
shadow
:
:
Zone
:
:
asShadowZone
(
detail
:
:
GetGCThingZone
(
uintptr_t
(
*
objp
)
)
)
;
if
(
!
zone
-
>
isGCSweepingOrCompacting
(
)
)
return
false
;
return
EdgeNeedsSweepUnbarrieredSlow
(
objp
)
;
}
}
}
namespace
JS
{
static
MOZ_ALWAYS_INLINE
void
ExposeObjectToActiveJS
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
obj
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
EdgeNeedsSweepUnbarrieredSlow
(
&
obj
)
)
;
js
:
:
gc
:
:
ExposeGCThingToActiveJS
(
GCCellPtr
(
obj
)
)
;
}
static
MOZ_ALWAYS_INLINE
void
ExposeScriptToActiveJS
(
JSScript
*
script
)
{
MOZ_ASSERT
(
!
js
:
:
gc
:
:
EdgeNeedsSweepUnbarrieredSlow
(
&
script
)
)
;
js
:
:
gc
:
:
ExposeGCThingToActiveJS
(
GCCellPtr
(
script
)
)
;
}
extern
JS_FRIEND_API
(
void
)
NotifyGCRootsRemoved
(
JSContext
*
cx
)
;
extern
JS_FRIEND_API
(
void
)
NotifyDidPaint
(
JSContext
*
cx
)
;
}
#
endif
