#
ifndef
js_GCAPI_h
#
define
js_GCAPI_h
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
struct
JSCompartment
;
struct
JSContext
;
struct
JSFreeOp
;
class
JSObject
;
struct
JSRuntime
;
class
JSString
;
#
ifdef
JS_BROKEN_GCC_ATTRIBUTE_WARNING
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wattributes
"
#
endif
class
JS_PUBLIC_API
(
JSTracer
)
;
#
ifdef
JS_BROKEN_GCC_ATTRIBUTE_WARNING
#
pragma
GCC
diagnostic
pop
#
endif
namespace
js
{
namespace
gc
{
class
GCRuntime
;
}
namespace
gcstats
{
struct
Statistics
;
}
}
typedef
enum
JSGCMode
{
JSGC_MODE_GLOBAL
=
0
JSGC_MODE_ZONE
=
1
JSGC_MODE_INCREMENTAL
=
2
}
JSGCMode
;
typedef
enum
JSGCInvocationKind
{
GC_NORMAL
=
0
GC_SHRINK
=
1
}
JSGCInvocationKind
;
typedef
enum
JSGCParamKey
{
JSGC_MAX_BYTES
=
0
JSGC_MAX_MALLOC_BYTES
=
1
JSGC_MAX_NURSERY_BYTES
=
2
JSGC_BYTES
=
3
JSGC_NUMBER
=
4
JSGC_MODE
=
6
JSGC_UNUSED_CHUNKS
=
7
JSGC_TOTAL_CHUNKS
=
8
JSGC_SLICE_TIME_BUDGET
=
9
JSGC_MARK_STACK_LIMIT
=
10
JSGC_HIGH_FREQUENCY_TIME_LIMIT
=
11
JSGC_HIGH_FREQUENCY_LOW_LIMIT
=
12
JSGC_HIGH_FREQUENCY_HIGH_LIMIT
=
13
JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX
=
14
JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN
=
15
JSGC_LOW_FREQUENCY_HEAP_GROWTH
=
16
JSGC_DYNAMIC_HEAP_GROWTH
=
17
JSGC_DYNAMIC_MARK_SLICE
=
18
JSGC_ALLOCATION_THRESHOLD
=
19
JSGC_MIN_EMPTY_CHUNK_COUNT
=
21
JSGC_MAX_EMPTY_CHUNK_COUNT
=
22
JSGC_COMPACTING_ENABLED
=
23
JSGC_REFRESH_FRAME_SLICES_ENABLED
=
24
JSGC_ALLOCATION_THRESHOLD_FACTOR
=
25
JSGC_ALLOCATION_THRESHOLD_FACTOR_AVOID_INTERRUPT
=
26
}
JSGCParamKey
;
typedef
void
(
*
JSTraceDataOp
)
(
JSTracer
*
trc
void
*
data
)
;
typedef
enum
JSGCStatus
{
JSGC_BEGIN
JSGC_END
}
JSGCStatus
;
typedef
void
(
*
JSGCCallback
)
(
JSContext
*
cx
JSGCStatus
status
void
*
data
)
;
typedef
void
(
*
JSObjectsTenuredCallback
)
(
JSContext
*
cx
void
*
data
)
;
typedef
enum
JSFinalizeStatus
{
JSFINALIZE_GROUP_PREPARE
JSFINALIZE_GROUP_START
JSFINALIZE_GROUP_END
JSFINALIZE_COLLECTION_END
}
JSFinalizeStatus
;
typedef
void
(
*
JSFinalizeCallback
)
(
JSFreeOp
*
fop
JSFinalizeStatus
status
void
*
data
)
;
typedef
void
(
*
JSWeakPointerZonesCallback
)
(
JSContext
*
cx
void
*
data
)
;
typedef
void
(
*
JSWeakPointerCompartmentCallback
)
(
JSContext
*
cx
JSCompartment
*
comp
void
*
data
)
;
struct
JSStringFinalizer
{
void
(
*
finalize
)
(
const
JSStringFinalizer
*
fin
char16_t
*
chars
)
;
}
;
namespace
JS
{
struct
Zone
;
#
define
GCREASONS
(
D
)
\
D
(
API
)
\
D
(
EAGER_ALLOC_TRIGGER
)
\
D
(
DESTROY_RUNTIME
)
\
D
(
ROOTS_REMOVED
)
\
D
(
LAST_DITCH
)
\
D
(
TOO_MUCH_MALLOC
)
\
D
(
ALLOC_TRIGGER
)
\
D
(
DEBUG_GC
)
\
D
(
COMPARTMENT_REVIVED
)
\
D
(
RESET
)
\
D
(
OUT_OF_NURSERY
)
\
D
(
EVICT_NURSERY
)
\
D
(
DELAYED_ATOMS_GC
)
\
D
(
SHARED_MEMORY_LIMIT
)
\
D
(
IDLE_TIME_COLLECTION
)
\
D
(
INCREMENTAL_TOO_SLOW
)
\
D
(
ABORT_GC
)
\
D
(
FULL_WHOLE_CELL_BUFFER
)
\
D
(
FULL_GENERIC_BUFFER
)
\
D
(
FULL_VALUE_BUFFER
)
\
D
(
FULL_CELL_PTR_BUFFER
)
\
D
(
FULL_SLOT_BUFFER
)
\
D
(
FULL_SHAPE_BUFFER
)
\
\
/
*
These
are
reserved
for
future
use
.
*
/
\
D
(
RESERVED0
)
\
D
(
RESERVED1
)
\
D
(
RESERVED2
)
\
D
(
RESERVED3
)
\
D
(
RESERVED4
)
\
D
(
RESERVED5
)
\
D
(
RESERVED6
)
\
D
(
RESERVED7
)
\
D
(
RESERVED8
)
\
D
(
RESERVED9
)
\
\
/
*
Reasons
from
Firefox
*
/
\
D
(
DOM_WINDOW_UTILS
)
\
D
(
COMPONENT_UTILS
)
\
D
(
MEM_PRESSURE
)
\
D
(
CC_WAITING
)
\
D
(
CC_FORCED
)
\
D
(
LOAD_END
)
\
D
(
POST_COMPARTMENT
)
\
D
(
PAGE_HIDE
)
\
D
(
NSJSCONTEXT_DESTROY
)
\
D
(
SET_NEW_DOCUMENT
)
\
D
(
SET_DOC_SHELL
)
\
D
(
DOM_UTILS
)
\
D
(
DOM_IPC
)
\
D
(
DOM_WORKER
)
\
D
(
INTER_SLICE_GC
)
\
D
(
REFRESH_FRAME
)
\
D
(
FULL_GC_TIMER
)
\
D
(
SHUTDOWN_CC
)
\
D
(
UNUSED2
)
\
D
(
USER_INACTIVE
)
\
D
(
XPCONNECT_SHUTDOWN
)
\
D
(
DOCSHELL
)
\
D
(
HTML_PARSER
)
namespace
gcreason
{
enum
Reason
{
#
define
MAKE_REASON
(
name
)
name
GCREASONS
(
MAKE_REASON
)
#
undef
MAKE_REASON
NO_REASON
NUM_REASONS
NUM_TELEMETRY_REASONS
=
100
}
;
extern
JS_PUBLIC_API
(
const
char
*
)
ExplainReason
(
JS
:
:
gcreason
:
:
Reason
reason
)
;
}
extern
JS_PUBLIC_API
(
void
)
PrepareZoneForGC
(
Zone
*
zone
)
;
extern
JS_PUBLIC_API
(
void
)
PrepareForFullGC
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
void
)
PrepareForIncrementalGC
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
bool
)
IsGCScheduled
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
void
)
SkipZoneForGC
(
Zone
*
zone
)
;
extern
JS_PUBLIC_API
(
void
)
GCForReason
(
JSContext
*
cx
JSGCInvocationKind
gckind
gcreason
:
:
Reason
reason
)
;
extern
JS_PUBLIC_API
(
void
)
StartIncrementalGC
(
JSContext
*
cx
JSGCInvocationKind
gckind
gcreason
:
:
Reason
reason
int64_t
millis
=
0
)
;
extern
JS_PUBLIC_API
(
void
)
IncrementalGCSlice
(
JSContext
*
cx
gcreason
:
:
Reason
reason
int64_t
millis
=
0
)
;
extern
JS_PUBLIC_API
(
void
)
FinishIncrementalGC
(
JSContext
*
cx
gcreason
:
:
Reason
reason
)
;
extern
JS_PUBLIC_API
(
void
)
AbortIncrementalGC
(
JSContext
*
cx
)
;
namespace
dbg
{
class
GarbageCollectionEvent
{
uint64_t
majorGCNumber_
;
const
char
*
reason
;
const
char
*
nonincrementalReason
;
struct
Collection
{
mozilla
:
:
TimeStamp
startTimestamp
;
mozilla
:
:
TimeStamp
endTimestamp
;
}
;
mozilla
:
:
Vector
<
Collection
>
collections
;
GarbageCollectionEvent
(
const
GarbageCollectionEvent
&
rhs
)
=
delete
;
GarbageCollectionEvent
&
operator
=
(
const
GarbageCollectionEvent
&
rhs
)
=
delete
;
public
:
explicit
GarbageCollectionEvent
(
uint64_t
majorGCNum
)
:
majorGCNumber_
(
majorGCNum
)
reason
(
nullptr
)
nonincrementalReason
(
nullptr
)
collections
(
)
{
}
using
Ptr
=
js
:
:
UniquePtr
<
GarbageCollectionEvent
>
;
static
Ptr
Create
(
JSRuntime
*
rt
:
:
js
:
:
gcstats
:
:
Statistics
&
stats
uint64_t
majorGCNumber
)
;
JSObject
*
toJSObject
(
JSContext
*
cx
)
const
;
uint64_t
majorGCNumber
(
)
const
{
return
majorGCNumber_
;
}
}
;
}
enum
GCProgress
{
GC_CYCLE_BEGIN
GC_SLICE_BEGIN
GC_SLICE_END
GC_CYCLE_END
}
;
struct
JS_PUBLIC_API
(
GCDescription
)
{
bool
isZone_
;
bool
isComplete_
;
JSGCInvocationKind
invocationKind_
;
gcreason
:
:
Reason
reason_
;
GCDescription
(
bool
isZone
bool
isComplete
JSGCInvocationKind
kind
gcreason
:
:
Reason
reason
)
:
isZone_
(
isZone
)
isComplete_
(
isComplete
)
invocationKind_
(
kind
)
reason_
(
reason
)
{
}
char16_t
*
formatSliceMessage
(
JSContext
*
cx
)
const
;
char16_t
*
formatSummaryMessage
(
JSContext
*
cx
)
const
;
char16_t
*
formatJSON
(
JSContext
*
cx
uint64_t
timestamp
)
const
;
mozilla
:
:
TimeStamp
startTime
(
JSContext
*
cx
)
const
;
mozilla
:
:
TimeStamp
endTime
(
JSContext
*
cx
)
const
;
mozilla
:
:
TimeStamp
lastSliceStart
(
JSContext
*
cx
)
const
;
mozilla
:
:
TimeStamp
lastSliceEnd
(
JSContext
*
cx
)
const
;
JS
:
:
UniqueChars
sliceToJSON
(
JSContext
*
cx
)
const
;
JS
:
:
UniqueChars
summaryToJSON
(
JSContext
*
cx
)
const
;
JS
:
:
dbg
:
:
GarbageCollectionEvent
:
:
Ptr
toGCEvent
(
JSContext
*
cx
)
const
;
}
;
extern
JS_PUBLIC_API
(
UniqueChars
)
MinorGcToJSON
(
JSContext
*
cx
)
;
typedef
void
(
*
GCSliceCallback
)
(
JSContext
*
cx
GCProgress
progress
const
GCDescription
&
desc
)
;
extern
JS_PUBLIC_API
(
GCSliceCallback
)
SetGCSliceCallback
(
JSContext
*
cx
GCSliceCallback
callback
)
;
enum
class
GCNurseryProgress
{
GC_NURSERY_COLLECTION_START
GC_NURSERY_COLLECTION_END
}
;
using
GCNurseryCollectionCallback
=
void
(
*
)
(
JSContext
*
cx
GCNurseryProgress
progress
gcreason
:
:
Reason
reason
)
;
extern
JS_PUBLIC_API
(
GCNurseryCollectionCallback
)
SetGCNurseryCollectionCallback
(
JSContext
*
cx
GCNurseryCollectionCallback
callback
)
;
typedef
void
(
*
DoCycleCollectionCallback
)
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
DoCycleCollectionCallback
)
SetDoCycleCollectionCallback
(
JSContext
*
cx
DoCycleCollectionCallback
callback
)
;
extern
JS_PUBLIC_API
(
void
)
DisableIncrementalGC
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
bool
)
IsIncrementalGCEnabled
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
bool
)
IsIncrementalGCInProgress
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
bool
)
IsIncrementalGCInProgress
(
JSRuntime
*
rt
)
;
extern
JS_PUBLIC_API
(
bool
)
WasIncrementalGC
(
JSRuntime
*
rt
)
;
class
JS_PUBLIC_API
(
AutoDisableGenerationalGC
)
{
JSContext
*
cx
;
public
:
explicit
AutoDisableGenerationalGC
(
JSContext
*
cx
)
;
~
AutoDisableGenerationalGC
(
)
;
}
;
extern
JS_PUBLIC_API
(
bool
)
IsGenerationalGCEnabled
(
JSRuntime
*
rt
)
;
extern
JS_PUBLIC_API
(
size_t
)
GetGCNumber
(
)
;
class
JS_PUBLIC_API
(
AutoRequireNoGC
)
{
protected
:
AutoRequireNoGC
(
)
{
}
~
AutoRequireNoGC
(
)
{
}
}
;
class
JS_PUBLIC_API
(
AutoAssertNoGC
)
:
public
AutoRequireNoGC
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
JSContext
*
cx_
;
public
:
explicit
AutoAssertNoGC
(
JSContext
*
cx
=
nullptr
)
;
~
AutoAssertNoGC
(
)
;
#
else
public
:
explicit
AutoAssertNoGC
(
JSContext
*
cx
=
nullptr
)
{
}
~
AutoAssertNoGC
(
)
{
}
#
endif
}
;
#
ifdef
DEBUG
class
JS_PUBLIC_API
(
AutoSuppressGCAnalysis
)
:
public
AutoAssertNoGC
{
public
:
explicit
AutoSuppressGCAnalysis
(
JSContext
*
cx
=
nullptr
)
:
AutoAssertNoGC
(
cx
)
{
}
}
JS_HAZ_GC_SUPPRESSED
;
#
else
class
JS_PUBLIC_API
(
AutoSuppressGCAnalysis
)
:
public
AutoRequireNoGC
{
public
:
explicit
AutoSuppressGCAnalysis
(
JSContext
*
cx
=
nullptr
)
{
}
}
JS_HAZ_GC_SUPPRESSED
;
#
endif
class
JS_PUBLIC_API
(
AutoAssertGCCallback
)
:
public
AutoSuppressGCAnalysis
{
public
:
#
ifdef
DEBUG
AutoAssertGCCallback
(
)
;
#
else
AutoAssertGCCallback
(
)
{
}
#
endif
}
;
#
ifdef
DEBUG
class
JS_PUBLIC_API
(
AutoCheckCannotGC
)
:
public
AutoAssertNoGC
{
public
:
explicit
AutoCheckCannotGC
(
JSContext
*
cx
=
nullptr
)
:
AutoAssertNoGC
(
cx
)
{
}
}
JS_HAZ_GC_INVALIDATED
;
#
else
class
JS_PUBLIC_API
(
AutoCheckCannotGC
)
:
public
AutoRequireNoGC
{
public
:
explicit
AutoCheckCannotGC
(
JSContext
*
cx
=
nullptr
)
{
}
}
JS_HAZ_GC_INVALIDATED
;
#
endif
extern
JS_FRIEND_API
(
void
)
NotifyGCRootsRemoved
(
JSContext
*
cx
)
;
}
extern
JS_PUBLIC_API
(
bool
)
JS_AddExtraGCRootsTracer
(
JSContext
*
cx
JSTraceDataOp
traceOp
void
*
data
)
;
extern
JS_PUBLIC_API
(
void
)
JS_RemoveExtraGCRootsTracer
(
JSContext
*
cx
JSTraceDataOp
traceOp
void
*
data
)
;
extern
JS_PUBLIC_API
(
void
)
JS_GC
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
void
)
JS_MaybeGC
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
(
void
)
JS_SetGCCallback
(
JSContext
*
cx
JSGCCallback
cb
void
*
data
)
;
extern
JS_PUBLIC_API
(
void
)
JS_SetObjectsTenuredCallback
(
JSContext
*
cx
JSObjectsTenuredCallback
cb
void
*
data
)
;
extern
JS_PUBLIC_API
(
bool
)
JS_AddFinalizeCallback
(
JSContext
*
cx
JSFinalizeCallback
cb
void
*
data
)
;
extern
JS_PUBLIC_API
(
void
)
JS_RemoveFinalizeCallback
(
JSContext
*
cx
JSFinalizeCallback
cb
)
;
extern
JS_PUBLIC_API
(
bool
)
JS_AddWeakPointerZonesCallback
(
JSContext
*
cx
JSWeakPointerZonesCallback
cb
void
*
data
)
;
extern
JS_PUBLIC_API
(
void
)
JS_RemoveWeakPointerZonesCallback
(
JSContext
*
cx
JSWeakPointerZonesCallback
cb
)
;
extern
JS_PUBLIC_API
(
bool
)
JS_AddWeakPointerCompartmentCallback
(
JSContext
*
cx
JSWeakPointerCompartmentCallback
cb
void
*
data
)
;
extern
JS_PUBLIC_API
(
void
)
JS_RemoveWeakPointerCompartmentCallback
(
JSContext
*
cx
JSWeakPointerCompartmentCallback
cb
)
;
namespace
JS
{
template
<
typename
T
>
class
Heap
;
}
extern
JS_PUBLIC_API
(
void
)
JS_UpdateWeakPointerAfterGC
(
JS
:
:
Heap
<
JSObject
*
>
*
objp
)
;
extern
JS_PUBLIC_API
(
void
)
JS_UpdateWeakPointerAfterGCUnbarriered
(
JSObject
*
*
objp
)
;
extern
JS_PUBLIC_API
(
void
)
JS_SetGCParameter
(
JSContext
*
cx
JSGCParamKey
key
uint32_t
value
)
;
extern
JS_PUBLIC_API
(
void
)
JS_ResetGCParameter
(
JSContext
*
cx
JSGCParamKey
key
)
;
extern
JS_PUBLIC_API
(
uint32_t
)
JS_GetGCParameter
(
JSContext
*
cx
JSGCParamKey
key
)
;
extern
JS_PUBLIC_API
(
void
)
JS_SetGCParametersBasedOnAvailableMemory
(
JSContext
*
cx
uint32_t
availMem
)
;
extern
JS_PUBLIC_API
(
JSString
*
)
JS_NewExternalString
(
JSContext
*
cx
const
char16_t
*
chars
size_t
length
const
JSStringFinalizer
*
fin
)
;
extern
JS_PUBLIC_API
(
JSString
*
)
JS_NewMaybeExternalString
(
JSContext
*
cx
const
char16_t
*
chars
size_t
length
const
JSStringFinalizer
*
fin
bool
*
allocatedExternal
)
;
extern
JS_PUBLIC_API
(
bool
)
JS_IsExternalString
(
JSString
*
str
)
;
extern
JS_PUBLIC_API
(
const
JSStringFinalizer
*
)
JS_GetExternalStringFinalizer
(
JSString
*
str
)
;
namespace
JS
{
extern
JS_PUBLIC_API
(
bool
)
IsIdleGCTaskNeeded
(
JSRuntime
*
rt
)
;
extern
JS_PUBLIC_API
(
void
)
RunIdleTimeGCTask
(
JSRuntime
*
rt
)
;
}
namespace
js
{
namespace
gc
{
extern
JS_PUBLIC_API
(
JSObject
*
)
NewMemoryInfoObject
(
JSContext
*
cx
)
;
}
}
#
endif
