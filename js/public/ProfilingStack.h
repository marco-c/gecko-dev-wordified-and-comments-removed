#
ifndef
js_ProfilingStack_h
#
define
js_ProfilingStack_h
#
include
<
algorithm
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Utility
.
h
"
#
ifdef
JS_BROKEN_GCC_ATTRIBUTE_WARNING
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wattributes
"
#
endif
class
JS_PUBLIC_API
(
JSTracer
)
;
#
ifdef
JS_BROKEN_GCC_ATTRIBUTE_WARNING
#
pragma
GCC
diagnostic
pop
#
endif
class
ProfilingStack
;
namespace
js
{
class
ProfilingStackFrame
{
mozilla
:
:
Atomic
<
const
char
*
mozilla
:
:
ReleaseAcquire
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
label_
;
mozilla
:
:
Atomic
<
const
char
*
mozilla
:
:
ReleaseAcquire
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
dynamicString_
;
mozilla
:
:
Atomic
<
void
*
mozilla
:
:
ReleaseAcquire
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
spOrScript
;
mozilla
:
:
Atomic
<
int32_t
mozilla
:
:
ReleaseAcquire
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
lineOrPcOffset
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
kindAndCategory_
;
static
int32_t
pcToOffset
(
JSScript
*
aScript
jsbytecode
*
aPc
)
;
public
:
ProfilingStackFrame
(
)
=
default
;
ProfilingStackFrame
&
operator
=
(
const
ProfilingStackFrame
&
other
)
{
label_
=
other
.
label
(
)
;
dynamicString_
=
other
.
dynamicString
(
)
;
void
*
spScript
=
other
.
spOrScript
;
spOrScript
=
spScript
;
int32_t
offset
=
other
.
lineOrPcOffset
;
lineOrPcOffset
=
offset
;
uint32_t
kindAndCategory
=
other
.
kindAndCategory_
;
kindAndCategory_
=
kindAndCategory
;
return
*
this
;
}
enum
class
Kind
:
uint32_t
{
LABEL
=
0
SP_MARKER
=
1
JS_NORMAL
=
2
JS_OSR
=
3
KIND_BITCOUNT
=
2
KIND_MASK
=
(
1
<
<
KIND_BITCOUNT
)
-
1
}
;
enum
class
Category
:
uint32_t
{
IDLE
OTHER
LAYOUT
JS
GCCC
NETWORK
GRAPHICS
DOM
FIRST
=
OTHER
LAST
=
DOM
}
;
static_assert
(
uint32_t
(
Category
:
:
LAST
)
<
=
(
UINT32_MAX
>
>
uint32_t
(
Kind
:
:
KIND_BITCOUNT
)
)
"
Too
many
categories
to
fit
into
u32
with
two
bits
reserved
for
the
kind
"
)
;
bool
isLabelFrame
(
)
const
{
return
kind
(
)
=
=
Kind
:
:
LABEL
;
}
bool
isSpMarkerFrame
(
)
const
{
return
kind
(
)
=
=
Kind
:
:
SP_MARKER
;
}
bool
isJsFrame
(
)
const
{
Kind
k
=
kind
(
)
;
return
k
=
=
Kind
:
:
JS_NORMAL
|
|
k
=
=
Kind
:
:
JS_OSR
;
}
void
setLabel
(
const
char
*
aLabel
)
{
label_
=
aLabel
;
}
const
char
*
label
(
)
const
{
return
label_
;
}
const
char
*
dynamicString
(
)
const
{
return
dynamicString_
;
}
void
initLabelFrame
(
const
char
*
aLabel
const
char
*
aDynamicString
void
*
sp
uint32_t
aLine
Category
aCategory
)
{
label_
=
aLabel
;
dynamicString_
=
aDynamicString
;
spOrScript
=
sp
;
lineOrPcOffset
=
static_cast
<
int32_t
>
(
aLine
)
;
kindAndCategory_
=
uint32_t
(
Kind
:
:
LABEL
)
|
(
uint32_t
(
aCategory
)
<
<
uint32_t
(
Kind
:
:
KIND_BITCOUNT
)
)
;
MOZ_ASSERT
(
isLabelFrame
(
)
)
;
}
void
initSpMarkerFrame
(
void
*
sp
)
{
label_
=
"
"
;
dynamicString_
=
nullptr
;
spOrScript
=
sp
;
lineOrPcOffset
=
0
;
kindAndCategory_
=
uint32_t
(
Kind
:
:
SP_MARKER
)
|
(
uint32_t
(
Category
:
:
OTHER
)
<
<
uint32_t
(
Kind
:
:
KIND_BITCOUNT
)
)
;
MOZ_ASSERT
(
isSpMarkerFrame
(
)
)
;
}
void
initJsFrame
(
const
char
*
aLabel
const
char
*
aDynamicString
JSScript
*
aScript
jsbytecode
*
aPc
)
{
label_
=
aLabel
;
dynamicString_
=
aDynamicString
;
spOrScript
=
aScript
;
lineOrPcOffset
=
pcToOffset
(
aScript
aPc
)
;
kindAndCategory_
=
uint32_t
(
Kind
:
:
JS_NORMAL
)
|
(
uint32_t
(
Category
:
:
JS
)
<
<
uint32_t
(
Kind
:
:
KIND_BITCOUNT
)
)
;
MOZ_ASSERT
(
isJsFrame
(
)
)
;
}
void
setKind
(
Kind
aKind
)
{
kindAndCategory_
=
uint32_t
(
aKind
)
|
(
uint32_t
(
category
(
)
)
<
<
uint32_t
(
Kind
:
:
KIND_BITCOUNT
)
)
;
}
Kind
kind
(
)
const
{
return
Kind
(
kindAndCategory_
&
uint32_t
(
Kind
:
:
KIND_MASK
)
)
;
}
Category
category
(
)
const
{
return
Category
(
kindAndCategory_
>
>
uint32_t
(
Kind
:
:
KIND_BITCOUNT
)
)
;
}
void
*
stackAddress
(
)
const
{
MOZ_ASSERT
(
!
isJsFrame
(
)
)
;
return
spOrScript
;
}
JS_PUBLIC_API
(
JSScript
*
)
script
(
)
const
;
uint32_t
line
(
)
const
{
MOZ_ASSERT
(
!
isJsFrame
(
)
)
;
return
static_cast
<
uint32_t
>
(
lineOrPcOffset
)
;
}
JSScript
*
rawScript
(
)
const
{
MOZ_ASSERT
(
isJsFrame
(
)
)
;
void
*
script
=
spOrScript
;
return
static_cast
<
JSScript
*
>
(
script
)
;
}
JS_FRIEND_API
(
jsbytecode
*
)
pc
(
)
const
;
void
setPC
(
jsbytecode
*
pc
)
;
void
trace
(
JSTracer
*
trc
)
;
static
const
int32_t
NullPCOffset
=
-
1
;
}
;
JS_FRIEND_API
(
void
)
SetContextProfilingStack
(
JSContext
*
cx
ProfilingStack
*
profilingStack
)
;
JS_FRIEND_API
(
void
)
EnableContextProfilingStack
(
JSContext
*
cx
bool
enabled
)
;
JS_FRIEND_API
(
void
)
RegisterContextProfilingEventMarker
(
JSContext
*
cx
void
(
*
fn
)
(
const
char
*
)
)
;
}
namespace
JS
{
typedef
ProfilingStack
*
(
*
RegisterThreadCallback
)
(
const
char
*
threadName
void
*
stackBase
)
;
typedef
void
(
*
UnregisterThreadCallback
)
(
)
;
JS_FRIEND_API
(
void
)
SetProfilingThreadCallbacks
(
RegisterThreadCallback
registerThread
UnregisterThreadCallback
unregisterThread
)
;
}
class
ProfilingStack
final
{
public
:
ProfilingStack
(
)
:
stackPointer
(
0
)
{
}
~
ProfilingStack
(
)
;
void
pushLabelFrame
(
const
char
*
label
const
char
*
dynamicString
void
*
sp
uint32_t
line
js
:
:
ProfilingStackFrame
:
:
Category
category
)
{
uint32_t
oldStackPointer
=
stackPointer
;
if
(
MOZ_LIKELY
(
capacity
>
oldStackPointer
)
|
|
MOZ_LIKELY
(
ensureCapacitySlow
(
)
)
)
frames
[
oldStackPointer
]
.
initLabelFrame
(
label
dynamicString
sp
line
category
)
;
stackPointer
=
oldStackPointer
+
1
;
}
void
pushSpMarkerFrame
(
void
*
sp
)
{
uint32_t
oldStackPointer
=
stackPointer
;
if
(
MOZ_LIKELY
(
capacity
>
oldStackPointer
)
|
|
MOZ_LIKELY
(
ensureCapacitySlow
(
)
)
)
frames
[
oldStackPointer
]
.
initSpMarkerFrame
(
sp
)
;
stackPointer
=
oldStackPointer
+
1
;
}
void
pushJsFrame
(
const
char
*
label
const
char
*
dynamicString
JSScript
*
script
jsbytecode
*
pc
)
{
uint32_t
oldStackPointer
=
stackPointer
;
if
(
MOZ_LIKELY
(
capacity
>
oldStackPointer
)
|
|
MOZ_LIKELY
(
ensureCapacitySlow
(
)
)
)
frames
[
oldStackPointer
]
.
initJsFrame
(
label
dynamicString
script
pc
)
;
stackPointer
=
oldStackPointer
+
1
;
}
void
pop
(
)
{
MOZ_ASSERT
(
stackPointer
>
0
)
;
uint32_t
oldStackPointer
=
stackPointer
;
stackPointer
=
oldStackPointer
-
1
;
}
uint32_t
stackSize
(
)
const
{
return
std
:
:
min
(
uint32_t
(
stackPointer
)
stackCapacity
(
)
)
;
}
uint32_t
stackCapacity
(
)
const
{
return
capacity
;
}
private
:
MOZ_COLD
MOZ_MUST_USE
bool
ensureCapacitySlow
(
)
;
ProfilingStack
(
const
ProfilingStack
&
)
=
delete
;
void
operator
=
(
const
ProfilingStack
&
)
=
delete
;
ProfilingStack
(
ProfilingStack
&
&
)
=
delete
;
void
operator
=
(
ProfilingStack
&
&
)
=
delete
;
uint32_t
capacity
=
0
;
public
:
mozilla
:
:
Atomic
<
js
:
:
ProfilingStackFrame
*
mozilla
:
:
SequentiallyConsistent
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
frames
{
nullptr
}
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
stackPointer
;
}
;
namespace
js
{
class
AutoGeckoProfilerEntry
;
class
GeckoProfilerEntryMarker
;
class
GeckoProfilerBaselineOSRMarker
;
class
GeckoProfilerThread
{
friend
class
AutoGeckoProfilerEntry
;
friend
class
GeckoProfilerEntryMarker
;
friend
class
GeckoProfilerBaselineOSRMarker
;
ProfilingStack
*
profilingStack_
;
public
:
GeckoProfilerThread
(
)
;
uint32_t
stackPointer
(
)
{
MOZ_ASSERT
(
installed
(
)
)
;
return
profilingStack_
-
>
stackPointer
;
}
ProfilingStackFrame
*
stack
(
)
{
return
profilingStack_
-
>
frames
;
}
ProfilingStack
*
getProfilingStack
(
)
{
return
profilingStack_
;
}
bool
installed
(
)
{
return
profilingStack_
!
=
nullptr
;
}
void
setProfilingStack
(
ProfilingStack
*
profilingStack
)
;
void
trace
(
JSTracer
*
trc
)
;
bool
enter
(
JSContext
*
cx
JSScript
*
script
JSFunction
*
maybeFun
)
;
void
exit
(
JSScript
*
script
JSFunction
*
maybeFun
)
;
inline
void
updatePC
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
)
;
}
;
}
#
endif
