#
ifndef
js_ProfilingStack_h
#
define
js_ProfilingStack_h
#
include
<
algorithm
>
#
include
<
stdint
.
h
>
#
include
"
jsbytecode
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Utility
.
h
"
struct
JSRuntime
;
class
JSTracer
;
class
PseudoStack
;
namespace
js
{
class
ProfileEntry
{
mozilla
:
:
Atomic
<
const
char
*
mozilla
:
:
ReleaseAcquire
>
label_
;
mozilla
:
:
Atomic
<
const
char
*
mozilla
:
:
ReleaseAcquire
>
dynamicString_
;
mozilla
:
:
Atomic
<
void
*
mozilla
:
:
ReleaseAcquire
>
spOrScript
;
mozilla
:
:
Atomic
<
int32_t
mozilla
:
:
ReleaseAcquire
>
lineOrPcOffset
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
kindAndCategory_
;
static
int32_t
pcToOffset
(
JSScript
*
aScript
jsbytecode
*
aPc
)
;
public
:
enum
class
Kind
:
uint32_t
{
CPP_NORMAL
=
0
CPP_MARKER_FOR_JS
=
1
JS_NORMAL
=
2
JS_OSR
=
3
KIND_MASK
=
0x3
}
;
enum
class
Category
:
uint32_t
{
OTHER
=
1u
<
<
4
CSS
=
1u
<
<
5
JS
=
1u
<
<
6
GC
=
1u
<
<
7
CC
=
1u
<
<
8
NETWORK
=
1u
<
<
9
GRAPHICS
=
1u
<
<
10
STORAGE
=
1u
<
<
11
EVENTS
=
1u
<
<
12
FIRST
=
OTHER
LAST
=
EVENTS
CATEGORY_MASK
=
~
uint32_t
(
Kind
:
:
KIND_MASK
)
}
;
static_assert
(
(
uint32_t
(
Category
:
:
FIRST
)
&
uint32_t
(
Kind
:
:
KIND_MASK
)
)
=
=
0
"
Category
overlaps
with
Kind
"
)
;
bool
isCpp
(
)
const
{
Kind
k
=
kind
(
)
;
return
k
=
=
Kind
:
:
CPP_NORMAL
|
|
k
=
=
Kind
:
:
CPP_MARKER_FOR_JS
;
}
bool
isJs
(
)
const
{
Kind
k
=
kind
(
)
;
return
k
=
=
Kind
:
:
JS_NORMAL
|
|
k
=
=
Kind
:
:
JS_OSR
;
}
void
setLabel
(
const
char
*
aLabel
)
{
label_
=
aLabel
;
}
const
char
*
label
(
)
const
{
return
label_
;
}
const
char
*
dynamicString
(
)
const
{
return
dynamicString_
;
}
void
initCppFrame
(
const
char
*
aLabel
const
char
*
aDynamicString
void
*
sp
uint32_t
aLine
Kind
aKind
Category
aCategory
)
{
label_
=
aLabel
;
dynamicString_
=
aDynamicString
;
spOrScript
=
sp
;
lineOrPcOffset
=
static_cast
<
int32_t
>
(
aLine
)
;
kindAndCategory_
=
uint32_t
(
aKind
)
|
uint32_t
(
aCategory
)
;
MOZ_ASSERT
(
isCpp
(
)
)
;
}
void
initJsFrame
(
const
char
*
aLabel
const
char
*
aDynamicString
JSScript
*
aScript
jsbytecode
*
aPc
)
{
label_
=
aLabel
;
dynamicString_
=
aDynamicString
;
spOrScript
=
aScript
;
lineOrPcOffset
=
pcToOffset
(
aScript
aPc
)
;
kindAndCategory_
=
uint32_t
(
Kind
:
:
JS_NORMAL
)
|
uint32_t
(
Category
:
:
JS
)
;
MOZ_ASSERT
(
isJs
(
)
)
;
}
void
setKind
(
Kind
aKind
)
{
kindAndCategory_
=
uint32_t
(
aKind
)
|
uint32_t
(
category
(
)
)
;
}
Kind
kind
(
)
const
{
return
Kind
(
kindAndCategory_
&
uint32_t
(
Kind
:
:
KIND_MASK
)
)
;
}
Category
category
(
)
const
{
return
Category
(
kindAndCategory_
&
uint32_t
(
Category
:
:
CATEGORY_MASK
)
)
;
}
void
*
stackAddress
(
)
const
{
MOZ_ASSERT
(
!
isJs
(
)
)
;
return
spOrScript
;
}
JS_PUBLIC_API
(
JSScript
*
)
script
(
)
const
;
uint32_t
line
(
)
const
{
MOZ_ASSERT
(
!
isJs
(
)
)
;
return
static_cast
<
uint32_t
>
(
lineOrPcOffset
)
;
}
JSScript
*
rawScript
(
)
const
{
MOZ_ASSERT
(
isJs
(
)
)
;
void
*
script
=
spOrScript
;
return
static_cast
<
JSScript
*
>
(
script
)
;
}
JS_FRIEND_API
(
jsbytecode
*
)
pc
(
)
const
;
void
setPC
(
jsbytecode
*
pc
)
;
void
trace
(
JSTracer
*
trc
)
;
static
const
int32_t
NullPCOffset
=
-
1
;
}
;
JS_FRIEND_API
(
void
)
SetContextProfilingStack
(
JSContext
*
cx
PseudoStack
*
pseudoStack
)
;
JS_FRIEND_API
(
void
)
EnableContextProfilingStack
(
JSContext
*
cx
bool
enabled
)
;
JS_FRIEND_API
(
void
)
RegisterContextProfilingEventMarker
(
JSContext
*
cx
void
(
*
fn
)
(
const
char
*
)
)
;
}
class
PseudoStack
{
public
:
PseudoStack
(
)
:
stackPointer
(
0
)
{
}
~
PseudoStack
(
)
{
MOZ_RELEASE_ASSERT
(
stackPointer
=
=
0
)
;
}
void
pushCppFrame
(
const
char
*
label
const
char
*
dynamicString
void
*
sp
uint32_t
line
js
:
:
ProfileEntry
:
:
Kind
kind
js
:
:
ProfileEntry
:
:
Category
category
)
{
if
(
stackPointer
<
MaxEntries
)
{
entries
[
stackPointer
]
.
initCppFrame
(
label
dynamicString
sp
line
kind
category
)
;
}
uint32_t
oldStackPointer
=
stackPointer
;
stackPointer
=
oldStackPointer
+
1
;
}
void
pushJsFrame
(
const
char
*
label
const
char
*
dynamicString
JSScript
*
script
jsbytecode
*
pc
)
{
if
(
stackPointer
<
MaxEntries
)
{
entries
[
stackPointer
]
.
initJsFrame
(
label
dynamicString
script
pc
)
;
}
uint32_t
oldStackPointer
=
stackPointer
;
stackPointer
=
oldStackPointer
+
1
;
}
void
pop
(
)
{
MOZ_ASSERT
(
stackPointer
>
0
)
;
uint32_t
oldStackPointer
=
stackPointer
;
stackPointer
=
oldStackPointer
-
1
;
}
uint32_t
stackSize
(
)
const
{
return
std
:
:
min
(
uint32_t
(
stackPointer
)
uint32_t
(
MaxEntries
)
)
;
}
private
:
PseudoStack
(
const
PseudoStack
&
)
=
delete
;
void
operator
=
(
const
PseudoStack
&
)
=
delete
;
public
:
static
const
uint32_t
MaxEntries
=
1024
;
js
:
:
ProfileEntry
entries
[
MaxEntries
]
;
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
ReleaseAcquire
>
stackPointer
;
}
;
namespace
js
{
class
AutoGeckoProfilerEntry
;
class
GeckoProfilerEntryMarker
;
class
GeckoProfilerBaselineOSRMarker
;
class
GeckoProfilerThread
{
friend
class
AutoGeckoProfilerEntry
;
friend
class
GeckoProfilerEntryMarker
;
friend
class
GeckoProfilerBaselineOSRMarker
;
PseudoStack
*
pseudoStack_
;
public
:
GeckoProfilerThread
(
)
;
uint32_t
stackPointer
(
)
{
MOZ_ASSERT
(
installed
(
)
)
;
return
pseudoStack_
-
>
stackPointer
;
}
ProfileEntry
*
stack
(
)
{
return
pseudoStack_
-
>
entries
;
}
PseudoStack
*
getPseudoStack
(
)
{
return
pseudoStack_
;
}
bool
installed
(
)
{
return
pseudoStack_
!
=
nullptr
;
}
void
setProfilingStack
(
PseudoStack
*
pseudoStack
)
;
void
trace
(
JSTracer
*
trc
)
;
bool
enter
(
JSContext
*
cx
JSScript
*
script
JSFunction
*
maybeFun
)
;
void
exit
(
JSScript
*
script
JSFunction
*
maybeFun
)
;
inline
void
updatePC
(
JSContext
*
cx
JSScript
*
script
jsbytecode
*
pc
)
;
}
;
}
#
endif
