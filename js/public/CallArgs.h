#
ifndef
js_CallArgs_h
#
define
js_CallArgs_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
typedef
bool
(
*
JSNative
)
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
namespace
JS
{
extern
JS_PUBLIC_DATA
(
const
HandleValue
)
UndefinedHandleValue
;
namespace
detail
{
extern
JS_PUBLIC_API
(
Value
)
ComputeThis
(
JSContext
*
cx
JS
:
:
Value
*
vp
)
;
#
ifdef
JS_DEBUG
extern
JS_PUBLIC_API
(
void
)
CheckIsValidConstructible
(
const
Value
&
v
)
;
#
endif
class
MOZ_STACK_CLASS
IncludeUsedRval
{
protected
:
#
ifdef
JS_DEBUG
mutable
bool
usedRval_
;
void
setUsedRval
(
)
const
{
usedRval_
=
true
;
}
void
clearUsedRval
(
)
const
{
usedRval_
=
false
;
}
void
assertUnusedRval
(
)
const
{
MOZ_ASSERT
(
!
usedRval_
)
;
}
#
else
void
setUsedRval
(
)
const
{
}
void
clearUsedRval
(
)
const
{
}
void
assertUnusedRval
(
)
const
{
}
#
endif
}
;
class
MOZ_STACK_CLASS
NoUsedRval
{
protected
:
void
setUsedRval
(
)
const
{
}
void
clearUsedRval
(
)
const
{
}
void
assertUnusedRval
(
)
const
{
}
}
;
template
<
class
WantUsedRval
>
class
MOZ_STACK_CLASS
CallArgsBase
:
public
WantUsedRval
{
static_assert
(
mozilla
:
:
IsSame
<
WantUsedRval
IncludeUsedRval
>
:
:
value
|
|
mozilla
:
:
IsSame
<
WantUsedRval
NoUsedRval
>
:
:
value
"
WantUsedRval
can
only
be
IncludeUsedRval
or
NoUsedRval
"
)
;
protected
:
Value
*
argv_
;
unsigned
argc_
;
bool
constructing_
;
public
:
HandleValue
calleev
(
)
const
{
this
-
>
assertUnusedRval
(
)
;
return
HandleValue
:
:
fromMarkedLocation
(
&
argv_
[
-
2
]
)
;
}
JSObject
&
callee
(
)
const
{
return
calleev
(
)
.
toObject
(
)
;
}
bool
isConstructing
(
)
const
{
if
(
!
argv_
[
-
1
]
.
isMagic
(
)
)
return
false
;
#
ifdef
JS_DEBUG
if
(
!
this
-
>
usedRval_
)
CheckIsValidConstructible
(
calleev
(
)
)
;
#
endif
return
true
;
}
MutableHandleValue
newTarget
(
)
const
{
MOZ_ASSERT
(
constructing_
)
;
return
MutableHandleValue
:
:
fromMarkedLocation
(
&
this
-
>
argv_
[
argc_
]
)
;
}
HandleValue
thisv
(
)
const
{
return
HandleValue
:
:
fromMarkedLocation
(
&
argv_
[
-
1
]
)
;
}
Value
computeThis
(
JSContext
*
cx
)
const
{
if
(
thisv
(
)
.
isObject
(
)
)
return
thisv
(
)
;
return
ComputeThis
(
cx
base
(
)
)
;
}
unsigned
length
(
)
const
{
return
argc_
;
}
MutableHandleValue
operator
[
]
(
unsigned
i
)
const
{
MOZ_ASSERT
(
i
<
argc_
)
;
return
MutableHandleValue
:
:
fromMarkedLocation
(
&
this
-
>
argv_
[
i
]
)
;
}
HandleValue
get
(
unsigned
i
)
const
{
return
i
<
length
(
)
?
HandleValue
:
:
fromMarkedLocation
(
&
this
-
>
argv_
[
i
]
)
:
UndefinedHandleValue
;
}
bool
hasDefined
(
unsigned
i
)
const
{
return
i
<
argc_
&
&
!
this
-
>
argv_
[
i
]
.
isUndefined
(
)
;
}
MutableHandleValue
rval
(
)
const
{
this
-
>
setUsedRval
(
)
;
return
MutableHandleValue
:
:
fromMarkedLocation
(
&
argv_
[
-
2
]
)
;
}
public
:
void
setCallee
(
const
Value
&
aCalleev
)
const
{
this
-
>
clearUsedRval
(
)
;
argv_
[
-
2
]
=
aCalleev
;
}
void
setThis
(
const
Value
&
aThisv
)
const
{
argv_
[
-
1
]
=
aThisv
;
}
MutableHandleValue
mutableThisv
(
)
const
{
return
MutableHandleValue
:
:
fromMarkedLocation
(
&
argv_
[
-
1
]
)
;
}
public
:
Value
*
array
(
)
const
{
return
argv_
;
}
Value
*
end
(
)
const
{
return
argv_
+
argc_
+
constructing_
;
}
public
:
Value
*
base
(
)
const
{
return
argv_
-
2
;
}
Value
*
spAfterCall
(
)
const
{
this
-
>
setUsedRval
(
)
;
return
argv_
-
1
;
}
}
;
}
class
MOZ_STACK_CLASS
CallArgs
:
public
detail
:
:
CallArgsBase
<
detail
:
:
IncludeUsedRval
>
{
private
:
friend
CallArgs
CallArgsFromVp
(
unsigned
argc
Value
*
vp
)
;
friend
CallArgs
CallArgsFromSp
(
unsigned
stackSlots
Value
*
sp
bool
constructing
)
;
static
CallArgs
create
(
unsigned
argc
Value
*
argv
bool
constructing
)
{
CallArgs
args
;
args
.
clearUsedRval
(
)
;
args
.
argv_
=
argv
;
args
.
argc_
=
argc
;
args
.
constructing_
=
constructing
;
#
ifdef
DEBUG
for
(
unsigned
i
=
0
;
i
<
argc
;
+
+
i
)
MOZ_ASSERT_IF
(
argv
[
i
]
.
isMarkable
(
)
!
GCThingIsMarkedGray
(
GCCellPtr
(
argv
[
i
]
)
)
)
;
#
endif
return
args
;
}
public
:
bool
requireAtLeast
(
JSContext
*
cx
const
char
*
fnname
unsigned
required
)
const
;
}
;
MOZ_ALWAYS_INLINE
CallArgs
CallArgsFromVp
(
unsigned
argc
Value
*
vp
)
{
return
CallArgs
:
:
create
(
argc
vp
+
2
vp
[
1
]
.
isMagic
(
JS_IS_CONSTRUCTING
)
)
;
}
MOZ_ALWAYS_INLINE
CallArgs
CallArgsFromSp
(
unsigned
stackSlots
Value
*
sp
bool
constructing
=
false
)
{
return
CallArgs
:
:
create
(
stackSlots
-
constructing
sp
-
stackSlots
constructing
)
;
}
}
MOZ_ALWAYS_INLINE
JS
:
:
Value
JS_THIS
(
JSContext
*
cx
JS
:
:
Value
*
vp
)
{
return
vp
[
1
]
.
isPrimitive
(
)
?
JS
:
:
detail
:
:
ComputeThis
(
cx
vp
)
:
vp
[
1
]
;
}
#
define
JS_THIS_OBJECT
(
cx
vp
)
(
JS_THIS
(
cx
vp
)
.
toObjectOrNull
(
)
)
#
define
JS_THIS_VALUE
(
cx
vp
)
(
(
vp
)
[
1
]
)
#
endif
