#
ifndef
js_Promise_h
#
define
js_Promise_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
namespace
JS
{
class
JS_PUBLIC_API
AutoDebuggerJobQueueInterruption
;
class
JS_PUBLIC_API
JobQueue
{
public
:
virtual
~
JobQueue
(
)
=
default
;
virtual
JSObject
*
getIncumbentGlobal
(
JSContext
*
cx
)
=
0
;
virtual
bool
enqueuePromiseJob
(
JSContext
*
cx
JS
:
:
HandleObject
promise
JS
:
:
HandleObject
job
JS
:
:
HandleObject
allocationSite
JS
:
:
HandleObject
incumbentGlobal
)
=
0
;
virtual
void
runJobs
(
JSContext
*
cx
)
=
0
;
virtual
bool
empty
(
)
const
=
0
;
protected
:
friend
class
AutoDebuggerJobQueueInterruption
;
class
SavedJobQueue
{
public
:
virtual
~
SavedJobQueue
(
)
=
default
;
}
;
virtual
js
:
:
UniquePtr
<
SavedJobQueue
>
saveJobQueue
(
JSContext
*
)
=
0
;
}
;
extern
JS_PUBLIC_API
void
SetJobQueue
(
JSContext
*
cx
JobQueue
*
queue
)
;
class
MOZ_RAII
JS_PUBLIC_API
AutoDebuggerJobQueueInterruption
{
public
:
explicit
AutoDebuggerJobQueueInterruption
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
;
~
AutoDebuggerJobQueueInterruption
(
)
;
bool
init
(
JSContext
*
cx
)
;
bool
initialized
(
)
const
{
return
!
!
saved
;
}
void
runJobs
(
)
;
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
;
JSContext
*
cx
;
js
:
:
UniquePtr
<
JobQueue
:
:
SavedJobQueue
>
saved
;
}
;
enum
class
PromiseRejectionHandlingState
{
Unhandled
Handled
}
;
typedef
void
(
*
PromiseRejectionTrackerCallback
)
(
JSContext
*
cx
JS
:
:
HandleObject
promise
JS
:
:
PromiseRejectionHandlingState
state
void
*
data
)
;
extern
JS_PUBLIC_API
void
SetPromiseRejectionTrackerCallback
(
JSContext
*
cx
PromiseRejectionTrackerCallback
callback
void
*
data
=
nullptr
)
;
extern
JS_PUBLIC_API
void
JobQueueIsEmpty
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
JobQueueMayNotBeEmpty
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
JSObject
*
NewPromiseObject
(
JSContext
*
cx
JS
:
:
HandleObject
executor
JS
:
:
HandleObject
proto
=
nullptr
)
;
extern
JS_PUBLIC_API
bool
IsPromiseObject
(
JS
:
:
HandleObject
obj
)
;
extern
JS_PUBLIC_API
JSObject
*
GetPromiseConstructor
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
JSObject
*
GetPromisePrototype
(
JSContext
*
cx
)
;
enum
class
PromiseState
{
Pending
Fulfilled
Rejected
}
;
extern
JS_PUBLIC_API
PromiseState
GetPromiseState
(
JS
:
:
HandleObject
promise
)
;
JS_PUBLIC_API
uint64_t
GetPromiseID
(
JS
:
:
HandleObject
promise
)
;
extern
JS_PUBLIC_API
JS
:
:
Value
GetPromiseResult
(
JS
:
:
HandleObject
promise
)
;
extern
JS_PUBLIC_API
bool
GetPromiseIsHandled
(
JS
:
:
HandleObject
promise
)
;
extern
JS_PUBLIC_API
JSObject
*
GetPromiseAllocationSite
(
JS
:
:
HandleObject
promise
)
;
extern
JS_PUBLIC_API
JSObject
*
GetPromiseResolutionSite
(
JS
:
:
HandleObject
promise
)
;
#
ifdef
DEBUG
extern
JS_PUBLIC_API
void
DumpPromiseAllocationSite
(
JSContext
*
cx
JS
:
:
HandleObject
promise
)
;
extern
JS_PUBLIC_API
void
DumpPromiseResolutionSite
(
JSContext
*
cx
JS
:
:
HandleObject
promise
)
;
#
endif
extern
JS_PUBLIC_API
JSObject
*
CallOriginalPromiseResolve
(
JSContext
*
cx
JS
:
:
HandleValue
resolutionValue
)
;
extern
JS_PUBLIC_API
JSObject
*
CallOriginalPromiseReject
(
JSContext
*
cx
JS
:
:
HandleValue
rejectionValue
)
;
extern
JS_PUBLIC_API
bool
ResolvePromise
(
JSContext
*
cx
JS
:
:
HandleObject
promiseObj
JS
:
:
HandleValue
resolutionValue
)
;
extern
JS_PUBLIC_API
bool
RejectPromise
(
JSContext
*
cx
JS
:
:
HandleObject
promiseObj
JS
:
:
HandleValue
rejectionValue
)
;
extern
JS_PUBLIC_API
JSObject
*
CallOriginalPromiseThen
(
JSContext
*
cx
JS
:
:
HandleObject
promise
JS
:
:
HandleObject
onFulfilled
JS
:
:
HandleObject
onRejected
)
;
extern
JS_PUBLIC_API
bool
AddPromiseReactions
(
JSContext
*
cx
JS
:
:
HandleObject
promise
JS
:
:
HandleObject
onFulfilled
JS
:
:
HandleObject
onRejected
)
;
enum
class
PromiseUserInputEventHandlingState
{
DontCare
HadUserInteractionAtCreation
DidntHaveUserInteractionAtCreation
}
;
extern
JS_PUBLIC_API
PromiseUserInputEventHandlingState
GetPromiseUserInputEventHandlingState
(
JS
:
:
HandleObject
promise
)
;
extern
JS_PUBLIC_API
bool
SetPromiseUserInputEventHandlingState
(
JS
:
:
HandleObject
promise
JS
:
:
PromiseUserInputEventHandlingState
state
)
;
extern
JS_PUBLIC_API
JSObject
*
GetWaitForAllPromise
(
JSContext
*
cx
const
JS
:
:
AutoObjectVector
&
promises
)
;
class
JS_PUBLIC_API
Dispatchable
{
protected
:
Dispatchable
(
)
=
default
;
virtual
~
Dispatchable
(
)
=
default
;
public
:
enum
MaybeShuttingDown
{
NotShuttingDown
ShuttingDown
}
;
virtual
void
run
(
JSContext
*
cx
MaybeShuttingDown
maybeShuttingDown
)
=
0
;
}
;
typedef
bool
(
*
DispatchToEventLoopCallback
)
(
void
*
closure
Dispatchable
*
dispatchable
)
;
extern
JS_PUBLIC_API
void
InitDispatchToEventLoop
(
JSContext
*
cx
DispatchToEventLoopCallback
callback
void
*
closure
)
;
extern
JS_PUBLIC_API
void
ShutdownAsyncTasks
(
JSContext
*
cx
)
;
}
#
endif
