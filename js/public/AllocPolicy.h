#
ifndef
js_AllocPolicy_h
#
define
js_AllocPolicy_h
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Utility
.
h
"
extern
MOZ_COLD
JS_PUBLIC_API
void
JS_ReportOutOfMemory
(
JSContext
*
cx
)
;
namespace
js
{
class
FrontendContext
;
using
ErrorContext
=
FrontendContext
;
enum
class
AllocFunction
{
Malloc
Calloc
Realloc
}
;
class
AllocPolicyBase
{
public
:
template
<
typename
T
>
T
*
maybe_pod_arena_malloc
(
arena_id_t
arenaId
size_t
numElems
)
{
return
js_pod_arena_malloc
<
T
>
(
arenaId
numElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_arena_calloc
(
arena_id_t
arenaId
size_t
numElems
)
{
return
js_pod_arena_calloc
<
T
>
(
arenaId
numElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_arena_realloc
(
arena_id_t
arenaId
T
*
p
size_t
oldSize
size_t
newSize
)
{
return
js_pod_arena_realloc
<
T
>
(
arenaId
p
oldSize
newSize
)
;
}
template
<
typename
T
>
T
*
pod_arena_malloc
(
arena_id_t
arenaId
size_t
numElems
)
{
return
maybe_pod_arena_malloc
<
T
>
(
arenaId
numElems
)
;
}
template
<
typename
T
>
T
*
pod_arena_calloc
(
arena_id_t
arenaId
size_t
numElems
)
{
return
maybe_pod_arena_calloc
<
T
>
(
arenaId
numElems
)
;
}
template
<
typename
T
>
T
*
pod_arena_realloc
(
arena_id_t
arenaId
T
*
p
size_t
oldSize
size_t
newSize
)
{
return
maybe_pod_arena_realloc
<
T
>
(
arenaId
p
oldSize
newSize
)
;
}
template
<
typename
T
>
T
*
maybe_pod_malloc
(
size_t
numElems
)
{
return
maybe_pod_arena_malloc
<
T
>
(
js
:
:
MallocArena
numElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_calloc
(
size_t
numElems
)
{
return
maybe_pod_arena_calloc
<
T
>
(
js
:
:
MallocArena
numElems
)
;
}
template
<
typename
T
>
T
*
maybe_pod_realloc
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
return
maybe_pod_arena_realloc
<
T
>
(
js
:
:
MallocArena
p
oldSize
newSize
)
;
}
template
<
typename
T
>
T
*
pod_malloc
(
size_t
numElems
)
{
return
pod_arena_malloc
<
T
>
(
js
:
:
MallocArena
numElems
)
;
}
template
<
typename
T
>
T
*
pod_calloc
(
size_t
numElems
)
{
return
pod_arena_calloc
<
T
>
(
js
:
:
MallocArena
numElems
)
;
}
template
<
typename
T
>
T
*
pod_realloc
(
T
*
p
size_t
oldSize
size_t
newSize
)
{
return
pod_arena_realloc
<
T
>
(
js
:
:
MallocArena
p
oldSize
newSize
)
;
}
template
<
typename
T
>
void
free_
(
T
*
p
size_t
numElems
=
0
)
{
js_free
(
p
)
;
}
}
;
class
SystemAllocPolicy
:
public
AllocPolicyBase
{
public
:
void
reportAllocOverflow
(
)
const
{
}
bool
checkSimulatedOOM
(
)
const
{
return
!
js
:
:
oom
:
:
ShouldFailWithOOM
(
)
;
}
}
;
MOZ_COLD
JS_PUBLIC_API
void
ReportOutOfMemory
(
JSContext
*
cx
)
;
MOZ_COLD
JS_PUBLIC_API
void
ReportOutOfMemory
(
ErrorContext
*
ec
)
;
class
JS_PUBLIC_API
TempAllocPolicy
:
public
AllocPolicyBase
{
static
constexpr
uintptr_t
JsContextTag
=
0x1
;
uintptr_t
const
context_bits_
;
MOZ_ALWAYS_INLINE
bool
hasJSContext
(
)
const
{
return
(
context_bits_
&
JsContextTag
)
=
=
JsContextTag
;
}
MOZ_ALWAYS_INLINE
JSContext
*
cx
(
)
const
{
MOZ_ASSERT
(
hasJSContext
(
)
)
;
return
reinterpret_cast
<
JSContext
*
>
(
context_bits_
^
JsContextTag
)
;
}
MOZ_ALWAYS_INLINE
ErrorContext
*
ec
(
)
const
{
MOZ_ASSERT
(
!
hasJSContext
(
)
)
;
return
reinterpret_cast
<
ErrorContext
*
>
(
context_bits_
)
;
}
void
*
onOutOfMemory
(
arena_id_t
arenaId
AllocFunction
allocFunc
size_t
nbytes
void
*
reallocPtr
=
nullptr
)
;
template
<
typename
T
>
T
*
onOutOfMemoryTyped
(
arena_id_t
arenaId
AllocFunction
allocFunc
size_t
numElems
void
*
reallocPtr
=
nullptr
)
{
size_t
bytes
;
if
(
MOZ_UNLIKELY
(
!
CalculateAllocSize
<
T
>
(
numElems
&
bytes
)
)
)
{
return
nullptr
;
}
return
static_cast
<
T
*
>
(
onOutOfMemory
(
arenaId
allocFunc
bytes
reallocPtr
)
)
;
}
#
ifdef
DEBUG
void
assertNotJSContextOnHelperThread
(
)
const
;
#
else
MOZ_ALWAYS_INLINE
void
assertNotJSContextOnHelperThread
(
)
const
{
}
#
endif
public
:
MOZ_IMPLICIT
TempAllocPolicy
(
JSContext
*
cx
)
:
context_bits_
(
uintptr_t
(
cx
)
|
JsContextTag
)
{
MOZ_ASSERT
(
(
uintptr_t
(
cx
)
&
JsContextTag
)
=
=
0
)
;
}
MOZ_IMPLICIT
TempAllocPolicy
(
ErrorContext
*
ec
)
:
context_bits_
(
uintptr_t
(
ec
)
)
{
MOZ_ASSERT
(
(
uintptr_t
(
ec
)
&
JsContextTag
)
=
=
0
)
;
}
template
<
typename
T
>
T
*
pod_arena_malloc
(
arena_id_t
arenaId
size_t
numElems
)
{
assertNotJSContextOnHelperThread
(
)
;
T
*
p
=
this
-
>
maybe_pod_arena_malloc
<
T
>
(
arenaId
numElems
)
;
if
(
MOZ_UNLIKELY
(
!
p
)
)
{
p
=
onOutOfMemoryTyped
<
T
>
(
arenaId
AllocFunction
:
:
Malloc
numElems
)
;
}
return
p
;
}
template
<
typename
T
>
T
*
pod_arena_calloc
(
arena_id_t
arenaId
size_t
numElems
)
{
assertNotJSContextOnHelperThread
(
)
;
T
*
p
=
this
-
>
maybe_pod_arena_calloc
<
T
>
(
arenaId
numElems
)
;
if
(
MOZ_UNLIKELY
(
!
p
)
)
{
p
=
onOutOfMemoryTyped
<
T
>
(
arenaId
AllocFunction
:
:
Calloc
numElems
)
;
}
return
p
;
}
template
<
typename
T
>
T
*
pod_arena_realloc
(
arena_id_t
arenaId
T
*
prior
size_t
oldSize
size_t
newSize
)
{
assertNotJSContextOnHelperThread
(
)
;
T
*
p2
=
this
-
>
maybe_pod_arena_realloc
<
T
>
(
arenaId
prior
oldSize
newSize
)
;
if
(
MOZ_UNLIKELY
(
!
p2
)
)
{
p2
=
onOutOfMemoryTyped
<
T
>
(
arenaId
AllocFunction
:
:
Realloc
newSize
prior
)
;
}
return
p2
;
}
template
<
typename
T
>
T
*
pod_malloc
(
size_t
numElems
)
{
return
pod_arena_malloc
<
T
>
(
js
:
:
MallocArena
numElems
)
;
}
template
<
typename
T
>
T
*
pod_calloc
(
size_t
numElems
)
{
return
pod_arena_calloc
<
T
>
(
js
:
:
MallocArena
numElems
)
;
}
template
<
typename
T
>
T
*
pod_realloc
(
T
*
prior
size_t
oldSize
size_t
newSize
)
{
return
pod_arena_realloc
<
T
>
(
js
:
:
MallocArena
prior
oldSize
newSize
)
;
}
template
<
typename
T
>
void
free_
(
T
*
p
size_t
numElems
=
0
)
{
js_free
(
p
)
;
}
void
reportAllocOverflow
(
)
const
;
bool
checkSimulatedOOM
(
)
const
{
if
(
js
:
:
oom
:
:
ShouldFailWithOOM
(
)
)
{
if
(
hasJSContext
(
)
)
{
ReportOutOfMemory
(
cx
(
)
)
;
}
else
{
ReportOutOfMemory
(
ec
(
)
)
;
}
return
false
;
}
return
true
;
}
}
;
class
MallocAllocPolicy
:
public
AllocPolicyBase
{
public
:
void
reportAllocOverflow
(
)
const
{
}
[
[
nodiscard
]
]
bool
checkSimulatedOOM
(
)
const
{
return
true
;
}
}
;
}
#
endif
