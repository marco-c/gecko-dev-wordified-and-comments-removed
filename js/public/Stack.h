#
ifndef
js_Stack_h
#
define
js_Stack_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
utility
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
Principals
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
JS
{
using
NativeStackSize
=
size_t
;
using
NativeStackBase
=
uintptr_t
;
using
NativeStackLimit
=
uintptr_t
;
#
if
JS_STACK_GROWTH_DIRECTION
>
0
constexpr
NativeStackLimit
NativeStackLimitMin
=
0
;
constexpr
NativeStackLimit
NativeStackLimitMax
=
UINTPTR_MAX
;
#
else
constexpr
NativeStackLimit
NativeStackLimitMin
=
UINTPTR_MAX
;
constexpr
NativeStackLimit
NativeStackLimitMax
=
0
;
#
endif
#
ifdef
__wasi__
constexpr
NativeStackLimit
WASINativeStackLimit
=
1024
;
#
endif
inline
NativeStackLimit
GetNativeStackLimit
(
NativeStackBase
base
NativeStackSize
size
)
{
#
if
JS_STACK_GROWTH_DIRECTION
>
0
MOZ_ASSERT
(
base
<
=
size_t
(
-
1
)
-
size
)
;
return
base
+
size
-
1
;
#
else
MOZ_ASSERT
(
base
>
=
size
)
;
return
base
-
(
size
-
1
)
;
#
endif
}
}
extern
JS_PUBLIC_API
void
JS_SetNativeStackQuota
(
JSContext
*
cx
JS
:
:
NativeStackSize
systemCodeStackSize
JS
:
:
NativeStackSize
trustedScriptStackSize
=
0
JS
:
:
NativeStackSize
untrustedScriptStackSize
=
0
)
;
namespace
js
{
enum
class
StackFormat
{
SpiderMonkey
V8
Default
}
;
extern
JS_PUBLIC_API
void
SetStackFormat
(
JSContext
*
cx
StackFormat
format
)
;
extern
JS_PUBLIC_API
StackFormat
GetStackFormat
(
JSContext
*
cx
)
;
}
namespace
JS
{
struct
AllFrames
{
}
;
struct
MaxFrames
{
uint32_t
maxFrames
;
explicit
MaxFrames
(
uint32_t
max
)
:
maxFrames
(
max
)
{
MOZ_ASSERT
(
max
>
0
)
;
}
}
;
struct
JS_PUBLIC_API
FirstSubsumedFrame
{
JSContext
*
cx
;
JSPrincipals
*
principals
;
bool
ignoreSelfHosted
;
explicit
FirstSubsumedFrame
(
JSContext
*
cx
bool
ignoreSelfHostedFrames
=
true
)
;
explicit
FirstSubsumedFrame
(
JSContext
*
ctx
JSPrincipals
*
p
bool
ignoreSelfHostedFrames
=
true
)
:
cx
(
ctx
)
principals
(
p
)
ignoreSelfHosted
(
ignoreSelfHostedFrames
)
{
if
(
principals
)
{
JS_HoldPrincipals
(
principals
)
;
}
}
FirstSubsumedFrame
(
const
FirstSubsumedFrame
&
)
=
delete
;
FirstSubsumedFrame
&
operator
=
(
const
FirstSubsumedFrame
&
)
=
delete
;
FirstSubsumedFrame
&
operator
=
(
FirstSubsumedFrame
&
&
)
=
delete
;
FirstSubsumedFrame
(
FirstSubsumedFrame
&
&
rhs
)
:
principals
(
rhs
.
principals
)
ignoreSelfHosted
(
rhs
.
ignoreSelfHosted
)
{
MOZ_ASSERT
(
this
!
=
&
rhs
"
self
move
disallowed
"
)
;
rhs
.
principals
=
nullptr
;
}
~
FirstSubsumedFrame
(
)
{
if
(
principals
)
{
JS_DropPrincipals
(
cx
principals
)
;
}
}
}
;
using
StackCapture
=
mozilla
:
:
Variant
<
AllFrames
MaxFrames
FirstSubsumedFrame
>
;
extern
JS_PUBLIC_API
bool
CaptureCurrentStack
(
JSContext
*
cx
MutableHandleObject
stackp
StackCapture
&
&
capture
=
StackCapture
(
AllFrames
(
)
)
)
;
extern
JS_PUBLIC_API
bool
IsAsyncStackCaptureEnabledForRealm
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
bool
CopyAsyncStack
(
JSContext
*
cx
HandleObject
asyncStack
HandleString
asyncCause
MutableHandleObject
stackp
const
mozilla
:
:
Maybe
<
size_t
>
&
maxFrameCount
)
;
extern
JS_PUBLIC_API
bool
BuildStackString
(
JSContext
*
cx
JSPrincipals
*
principals
HandleObject
stack
MutableHandleString
stringp
size_t
indent
=
0
js
:
:
StackFormat
stackFormat
=
js
:
:
StackFormat
:
:
Default
)
;
}
#
endif
