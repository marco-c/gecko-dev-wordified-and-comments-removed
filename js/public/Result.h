#
ifndef
js_Result_h
#
define
js_Result_h
#
include
"
mozilla
/
Result
.
h
"
#
define
JS_TRY_BOOL_TO_RESULT
(
cx
expr
)
\
do
{
\
bool
ok_
=
(
expr
)
;
\
if
(
!
ok_
)
return
(
cx
)
-
>
boolToResult
(
ok_
)
;
\
}
while
(
0
)
#
define
JS_TRY_OR_RETURN_FALSE
(
cx
expr
)
\
do
{
\
auto
tmpResult_
=
(
expr
)
;
\
if
(
tmpResult_
.
isErr
(
)
)
return
(
cx
)
-
>
resultToBool
(
tmpResult_
)
;
\
}
while
(
0
)
#
define
JS_TRY_OR_RETURN_NULL
(
cx
expr
)
\
do
{
\
auto
tmpResult_
=
(
expr
)
;
\
if
(
tmpResult_
.
isErr
(
)
)
{
\
MOZ_ALWAYS_FALSE
(
(
cx
)
-
>
resultToBool
(
tmpResult_
)
)
;
\
return
nullptr
;
\
}
\
}
while
(
0
)
#
define
JS_TRY_VAR_OR_RETURN_FALSE
(
cx
target
expr
)
\
do
{
\
auto
tmpResult_
=
(
expr
)
;
\
if
(
tmpResult_
.
isErr
(
)
)
return
(
cx
)
-
>
resultToBool
(
tmpResult_
)
;
\
(
target
)
=
tmpResult_
.
unwrap
(
)
;
\
}
while
(
0
)
#
define
JS_TRY_VAR_OR_RETURN_NULL
(
cx
target
expr
)
\
do
{
\
auto
tmpResult_
=
(
expr
)
;
\
if
(
tmpResult_
.
isErr
(
)
)
{
\
MOZ_ALWAYS_FALSE
(
(
cx
)
-
>
resultToBool
(
tmpResult_
)
)
;
\
return
nullptr
;
\
}
\
(
target
)
=
tmpResult_
.
unwrap
(
)
;
\
}
while
(
0
)
namespace
JS
{
using
mozilla
:
:
Ok
;
struct
Error
{
int
dummy
;
}
;
struct
OOM
:
public
Error
{
}
;
template
<
typename
V
=
Ok
typename
E
=
Error
&
>
using
Result
=
mozilla
:
:
Result
<
V
E
>
;
static_assert
(
sizeof
(
Result
<
>
)
=
=
sizeof
(
uintptr_t
)
"
Result
<
>
should
be
pointer
-
sized
"
)
;
static_assert
(
sizeof
(
Result
<
int
*
Error
&
>
)
=
=
sizeof
(
uintptr_t
)
"
Result
<
V
*
Error
&
>
should
be
pointer
-
sized
"
)
;
}
#
endif
