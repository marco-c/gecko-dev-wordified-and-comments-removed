#
ifndef
js_TraceLoggerAPI_h
#
define
js_TraceLoggerAPI_h
#
include
"
jstypes
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
mozilla
{
class
JSONWriteFunc
;
class
TimeStamp
;
}
;
namespace
JS
{
class
AutoTraceLoggerLockGuard
{
public
:
AutoTraceLoggerLockGuard
(
)
;
~
AutoTraceLoggerLockGuard
(
)
;
}
;
struct
TraceLoggerDictionaryImpl
{
using
ImplType
=
char
;
static
size_t
NextChunk
(
JSContext
*
cx
size_t
*
dataIndex
ImplType
buffer
[
]
size_t
bufferSize
)
;
}
;
struct
TraceLoggerIdImpl
{
using
ImplType
=
uint32_t
;
static
size_t
NextChunk
(
JSContext
*
cx
size_t
*
dataIndex
ImplType
buffer
[
]
size_t
bufferSize
)
;
}
;
struct
TraceLoggerLineNoImpl
{
using
ImplType
=
int32_t
;
static
size_t
NextChunk
(
JSContext
*
cx
size_t
*
dataIndex
ImplType
buffer
[
]
size_t
bufferSize
)
;
}
;
struct
TraceLoggerColNoImpl
{
using
ImplType
=
int32_t
;
static
size_t
NextChunk
(
JSContext
*
cx
size_t
*
dataIndex
ImplType
buffer
[
]
size_t
bufferSize
)
;
}
;
struct
TraceLoggerTimeStampImpl
{
using
ImplType
=
mozilla
:
:
TimeStamp
;
static
size_t
NextChunk
(
JSContext
*
cx
size_t
*
dataIndex
ImplType
buffer
[
]
size_t
bufferSize
)
;
}
;
struct
TraceLoggerDurationImpl
{
using
ImplType
=
double
;
static
size_t
NextChunk
(
JSContext
*
cx
size_t
*
dataIndex
ImplType
buffer
[
]
size_t
bufferSize
)
;
}
;
template
<
class
T
>
class
TraceLoggerCollectorBuffer
{
using
ImplType
=
typename
T
:
:
ImplType
;
public
:
class
Iterator
{
public
:
Iterator
(
ImplType
*
buffer
size_t
index
)
:
iteratorIndex
(
index
)
buf
(
buffer
)
{
}
Iterator
operator
+
+
(
)
{
iteratorIndex
+
+
;
return
*
this
;
}
bool
operator
!
=
(
const
Iterator
&
other
)
const
{
return
iteratorIndex
!
=
other
.
iteratorIndex
;
}
ImplType
operator
*
(
)
const
{
return
buf
[
iteratorIndex
]
;
}
private
:
size_t
iteratorIndex
;
ImplType
*
buf
;
}
;
explicit
TraceLoggerCollectorBuffer
(
AutoTraceLoggerLockGuard
&
lockGuard
JSContext
*
cx
=
nullptr
size_t
length
=
4096
)
:
cx_
(
cx
)
length_
(
length
)
dataIndex_
(
0
)
bufferIndex_
(
0
)
{
buffer_
=
js_pod_malloc
<
ImplType
>
(
length
)
;
}
~
TraceLoggerCollectorBuffer
(
)
{
js_free
(
buffer_
)
;
}
Iterator
begin
(
)
const
{
return
Iterator
(
buffer_
0
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
buffer_
bufferIndex_
)
;
}
ImplType
*
internalBuffer
(
)
const
{
return
buffer_
;
}
bool
NextChunk
(
)
{
bufferIndex_
=
T
:
:
NextChunk
(
cx_
&
dataIndex_
buffer_
length_
)
;
return
(
bufferIndex_
!
=
0
)
?
true
:
false
;
}
private
:
JSContext
*
cx_
;
size_t
length_
;
size_t
dataIndex_
;
size_t
bufferIndex_
;
ImplType
*
buffer_
;
}
;
#
ifdef
JS_TRACE_LOGGING
extern
JS_PUBLIC_API
bool
InitTraceLogger
(
)
;
extern
JS_PUBLIC_API
bool
TraceLoggerSupported
(
)
;
extern
JS_PUBLIC_API
void
StartTraceLogger
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
StopTraceLogger
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
ResetTraceLogger
(
void
)
;
extern
JS_PUBLIC_API
void
SpewTraceLoggerThread
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
SpewTraceLoggerForCurrentProcess
(
)
;
#
else
inline
bool
InitTraceLogger
(
)
{
return
true
;
}
inline
bool
TraceLoggerSupported
(
)
{
return
false
;
}
inline
void
StartTraceLogger
(
JSContext
*
cx
)
{
}
inline
void
StopTraceLogger
(
JSContext
*
cx
)
{
}
inline
void
ResetTraceLogger
(
void
)
{
}
inline
void
SpewTraceLoggerThread
(
JSContext
*
cx
)
{
}
inline
void
SpewTraceLoggerForCurrentProcess
(
)
{
}
inline
size_t
TraceLoggerDictionaryImpl
:
:
NextChunk
(
JSContext
*
cx
size_t
*
dataIndex
ImplType
buffer
[
]
size_t
bufferSize
)
{
return
0
;
}
inline
size_t
TraceLoggerIdImpl
:
:
NextChunk
(
JSContext
*
cx
size_t
*
dataIndex
ImplType
buffer
[
]
size_t
bufferSize
)
{
return
0
;
}
inline
size_t
TraceLoggerTimeStampImpl
:
:
NextChunk
(
JSContext
*
cx
size_t
*
dataIndex
ImplType
buffer
[
]
size_t
bufferSize
)
{
return
0
;
}
inline
size_t
TraceLoggerDurationImpl
:
:
NextChunk
(
JSContext
*
cx
size_t
*
dataIndex
ImplType
buffer
[
]
size_t
bufferSize
)
{
return
0
;
}
inline
size_t
TraceLoggerLineNoImpl
:
:
NextChunk
(
JSContext
*
cx
size_t
*
dataIndex
ImplType
buffer
[
]
size_t
bufferSize
)
{
return
0
;
}
inline
size_t
TraceLoggerColNoImpl
:
:
NextChunk
(
JSContext
*
cx
size_t
*
dataIndex
ImplType
buffer
[
]
size_t
bufferSize
)
{
return
0
;
}
inline
AutoTraceLoggerLockGuard
:
:
AutoTraceLoggerLockGuard
(
)
{
}
inline
AutoTraceLoggerLockGuard
:
:
~
AutoTraceLoggerLockGuard
(
)
{
}
#
endif
using
TraceLoggerDictionaryBuffer
=
TraceLoggerCollectorBuffer
<
JS
:
:
TraceLoggerDictionaryImpl
>
;
using
TraceLoggerIdBuffer
=
TraceLoggerCollectorBuffer
<
JS
:
:
TraceLoggerIdImpl
>
;
using
TraceLoggerTimeStampBuffer
=
TraceLoggerCollectorBuffer
<
JS
:
:
TraceLoggerTimeStampImpl
>
;
using
TraceLoggerDurationBuffer
=
TraceLoggerCollectorBuffer
<
JS
:
:
TraceLoggerDurationImpl
>
;
using
TraceLoggerLineNoBuffer
=
TraceLoggerCollectorBuffer
<
JS
:
:
TraceLoggerLineNoImpl
>
;
using
TraceLoggerColNoBuffer
=
TraceLoggerCollectorBuffer
<
JS
:
:
TraceLoggerColNoImpl
>
;
}
;
#
endif
