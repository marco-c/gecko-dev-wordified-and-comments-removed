#
ifndef
js_UbiNodeCensus_h
#
define
js_UbiNodeCensus_h
#
include
"
mozilla
/
Move
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
js
/
UbiNodeBreadthFirst
.
h
"
namespace
JS
{
namespace
ubi
{
struct
Census
;
class
CountBase
;
struct
CountDeleter
{
void
operator
(
)
(
CountBase
*
)
;
}
;
using
CountBasePtr
=
UniquePtr
<
CountBase
CountDeleter
>
;
struct
CountType
{
explicit
CountType
(
Census
&
census
)
:
census
(
census
)
{
}
virtual
~
CountType
(
)
{
}
virtual
void
destructCount
(
CountBase
&
count
)
=
0
;
virtual
CountBasePtr
makeCount
(
)
=
0
;
virtual
void
traceCount
(
CountBase
&
count
JSTracer
*
trc
)
=
0
;
virtual
bool
count
(
CountBase
&
count
const
Node
&
node
)
=
0
;
virtual
bool
report
(
CountBase
&
count
MutableHandleValue
report
)
=
0
;
protected
:
Census
&
census
;
}
;
using
CountTypePtr
=
UniquePtr
<
CountType
JS
:
:
DeletePolicy
<
CountType
>
>
;
class
CountBase
{
CountType
&
type
;
protected
:
~
CountBase
(
)
{
}
public
:
explicit
CountBase
(
CountType
&
type
)
:
type
(
type
)
total_
(
0
)
{
}
bool
count
(
const
Node
&
node
)
{
return
type
.
count
(
*
this
node
)
;
}
bool
report
(
MutableHandleValue
report
)
{
return
type
.
report
(
*
this
report
)
;
}
void
destruct
(
)
{
return
type
.
destructCount
(
*
this
)
;
}
void
trace
(
JSTracer
*
trc
)
{
type
.
traceCount
(
*
this
trc
)
;
}
size_t
total_
;
}
;
class
RootedCount
:
JS
:
:
CustomAutoRooter
{
CountBasePtr
count
;
void
trace
(
JSTracer
*
trc
)
override
{
count
-
>
trace
(
trc
)
;
}
public
:
RootedCount
(
JSContext
*
cx
CountBasePtr
&
&
count
)
:
CustomAutoRooter
(
cx
)
count
(
Move
(
count
)
)
{
}
CountBase
*
operator
-
>
(
)
const
{
return
count
.
get
(
)
;
}
explicit
operator
bool
(
)
const
{
return
count
.
get
(
)
;
}
operator
CountBasePtr
&
(
)
{
return
count
;
}
}
;
struct
Census
{
JSContext
*
const
cx
;
JS
:
:
ZoneSet
targetZones
;
Zone
*
atomsZone
;
explicit
Census
(
JSContext
*
cx
)
:
cx
(
cx
)
atomsZone
(
nullptr
)
{
}
bool
init
(
)
;
template
<
typename
T
typename
.
.
.
Args
>
T
*
new_
(
Args
&
&
.
.
.
args
)
MOZ_HEAP_ALLOCATOR
{
void
*
memory
=
js_malloc
(
sizeof
(
T
)
)
;
if
(
MOZ_UNLIKELY
(
!
memory
)
)
{
return
nullptr
;
}
return
new
(
memory
)
T
(
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
;
}
}
;
class
CensusHandler
{
Census
&
census
;
CountBasePtr
&
rootCount
;
public
:
CensusHandler
(
Census
&
census
CountBasePtr
&
rootCount
)
:
census
(
census
)
rootCount
(
rootCount
)
{
}
bool
report
(
MutableHandleValue
report
)
{
return
rootCount
-
>
report
(
report
)
;
}
class
NodeData
{
}
;
bool
operator
(
)
(
BreadthFirst
<
CensusHandler
>
&
traversal
Node
origin
const
Edge
&
edge
NodeData
*
referentData
bool
first
)
;
}
;
using
CensusTraversal
=
BreadthFirst
<
CensusHandler
>
;
bool
ParseCensusOptions
(
JSContext
*
cx
Census
&
census
HandleObject
options
CountTypePtr
&
outResult
)
;
}
}
#
endif
