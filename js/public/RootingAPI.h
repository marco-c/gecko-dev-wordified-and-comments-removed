#
ifndef
js_RootingAPI_h
#
define
js_RootingAPI_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
jspubtd
.
h
"
#
include
"
js
/
ComparisonOperators
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
#
include
"
js
/
GCPolicyAPI
.
h
"
#
include
"
js
/
GCTypeMacros
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
ProfilingStack
.
h
"
#
include
"
js
/
Realm
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Utility
.
h
"
namespace
js
{
template
<
typename
T
>
struct
BarrierMethods
{
}
;
template
<
typename
Element
typename
Wrapper
>
class
WrappedPtrOperations
{
}
;
template
<
typename
Element
typename
Wrapper
>
class
MutableWrappedPtrOperations
:
public
WrappedPtrOperations
<
Element
Wrapper
>
{
}
;
template
<
typename
T
typename
Wrapper
>
class
RootedBase
:
public
MutableWrappedPtrOperations
<
T
Wrapper
>
{
}
;
template
<
typename
T
typename
Wrapper
>
class
HandleBase
:
public
WrappedPtrOperations
<
T
Wrapper
>
{
}
;
template
<
typename
T
typename
Wrapper
>
class
MutableHandleBase
:
public
MutableWrappedPtrOperations
<
T
Wrapper
>
{
}
;
template
<
typename
T
typename
Wrapper
>
class
HeapBase
:
public
MutableWrappedPtrOperations
<
T
Wrapper
>
{
}
;
template
<
typename
T
>
struct
IsHeapConstructibleType
{
static
constexpr
bool
value
=
false
;
}
;
#
define
DECLARE_IS_HEAP_CONSTRUCTIBLE_TYPE
(
T
)
\
template
<
>
\
struct
IsHeapConstructibleType
<
T
>
{
\
static
constexpr
bool
value
=
true
;
\
}
;
JS_FOR_EACH_PUBLIC_GC_POINTER_TYPE
(
DECLARE_IS_HEAP_CONSTRUCTIBLE_TYPE
)
JS_FOR_EACH_PUBLIC_TAGGED_GC_POINTER_TYPE
(
DECLARE_IS_HEAP_CONSTRUCTIBLE_TYPE
)
#
undef
DECLARE_IS_HEAP_CONSTRUCTIBLE_TYPE
template
<
typename
T
typename
Wrapper
>
class
PersistentRootedBase
:
public
MutableWrappedPtrOperations
<
T
Wrapper
>
{
}
;
namespace
gc
{
struct
Cell
;
template
<
typename
T
>
struct
PersistentRootedMarker
;
}
#
define
DECLARE_POINTER_CONSTREF_OPS
(
T
)
\
operator
const
T
&
(
)
const
{
return
get
(
)
;
}
\
const
T
&
operator
-
>
(
)
const
{
return
get
(
)
;
}
#
define
DECLARE_POINTER_ASSIGN_OPS
(
Wrapper
T
)
\
Wrapper
<
T
>
&
operator
=
(
const
T
&
p
)
{
\
set
(
p
)
;
\
return
*
this
;
\
}
\
Wrapper
<
T
>
&
operator
=
(
T
&
&
p
)
{
\
set
(
std
:
:
move
(
p
)
)
;
\
return
*
this
;
\
}
\
Wrapper
<
T
>
&
operator
=
(
const
Wrapper
<
T
>
&
other
)
{
\
set
(
other
.
get
(
)
)
;
\
return
*
this
;
\
}
#
define
DELETE_ASSIGNMENT_OPS
(
Wrapper
T
)
\
template
<
typename
S
>
\
Wrapper
<
T
>
&
operator
=
(
S
)
=
delete
;
\
Wrapper
<
T
>
&
operator
=
(
const
Wrapper
<
T
>
&
)
=
delete
;
#
define
DECLARE_NONPOINTER_ACCESSOR_METHODS
(
ptr
)
\
const
T
*
address
(
)
const
{
return
&
(
ptr
)
;
}
\
const
T
&
get
(
)
const
{
return
(
ptr
)
;
}
#
define
DECLARE_NONPOINTER_MUTABLE_ACCESSOR_METHODS
(
ptr
)
\
T
*
address
(
)
{
return
&
(
ptr
)
;
}
\
T
&
get
(
)
{
return
(
ptr
)
;
}
}
namespace
JS
{
JS_FRIEND_API
void
HeapObjectPostWriteBarrier
(
JSObject
*
*
objp
JSObject
*
prev
JSObject
*
next
)
;
JS_FRIEND_API
void
HeapStringPostWriteBarrier
(
JSString
*
*
objp
JSString
*
prev
JSString
*
next
)
;
JS_FRIEND_API
void
HeapBigIntPostWriteBarrier
(
JS
:
:
BigInt
*
*
bip
JS
:
:
BigInt
*
prev
JS
:
:
BigInt
*
next
)
;
JS_FRIEND_API
void
HeapObjectWriteBarriers
(
JSObject
*
*
objp
JSObject
*
prev
JSObject
*
next
)
;
JS_FRIEND_API
void
HeapStringWriteBarriers
(
JSString
*
*
objp
JSString
*
prev
JSString
*
next
)
;
JS_FRIEND_API
void
HeapBigIntWriteBarriers
(
JS
:
:
BigInt
*
*
bip
JS
:
:
BigInt
*
prev
JS
:
:
BigInt
*
next
)
;
JS_FRIEND_API
void
HeapScriptWriteBarriers
(
JSScript
*
*
objp
JSScript
*
prev
JSScript
*
next
)
;
template
<
typename
T
>
inline
T
SafelyInitialized
(
)
{
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
|
|
\
(
defined
(
XP_UNIX
)
&
&
!
defined
(
__clang__
)
)
constexpr
bool
IsPointer
=
std
:
:
is_pointer_v
<
T
>
;
constexpr
bool
IsNonTriviallyDefaultConstructibleClassOrUnion
=
(
std
:
:
is_class_v
<
T
>
|
|
std
:
:
is_union_v
<
T
>
)
&
&
!
std
:
:
is_trivially_default_constructible_v
<
T
>
;
static_assert
(
IsPointer
|
|
IsNonTriviallyDefaultConstructibleClassOrUnion
"
T
(
)
must
evaluate
to
a
safely
-
initialized
T
"
)
;
#
endif
return
T
(
)
;
}
#
ifdef
JS_DEBUG
extern
JS_FRIEND_API
void
AssertGCThingMustBeTenured
(
JSObject
*
obj
)
;
extern
JS_FRIEND_API
void
AssertGCThingIsNotNurseryAllocable
(
js
:
:
gc
:
:
Cell
*
cell
)
;
#
else
inline
void
AssertGCThingMustBeTenured
(
JSObject
*
obj
)
{
}
inline
void
AssertGCThingIsNotNurseryAllocable
(
js
:
:
gc
:
:
Cell
*
cell
)
{
}
#
endif
template
<
typename
T
>
class
MOZ_NON_MEMMOVABLE
Heap
:
public
js
:
:
HeapBase
<
T
Heap
<
T
>
>
{
static_assert
(
js
:
:
IsHeapConstructibleType
<
T
>
:
:
value
"
Type
T
must
be
a
public
GC
pointer
type
"
)
;
public
:
using
ElementType
=
T
;
Heap
(
)
:
ptr
(
SafelyInitialized
<
T
>
(
)
)
{
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
Heap
<
T
>
)
"
Heap
<
T
>
must
be
binary
compatible
with
T
.
"
)
;
}
explicit
Heap
(
const
T
&
p
)
{
init
(
p
)
;
}
explicit
Heap
(
const
Heap
<
T
>
&
other
)
{
init
(
other
.
ptr
)
;
}
Heap
&
operator
=
(
Heap
<
T
>
&
&
other
)
{
set
(
other
.
unbarrieredGet
(
)
)
;
other
.
set
(
SafelyInitialized
<
T
>
(
)
)
;
return
*
this
;
}
~
Heap
(
)
{
postWriteBarrier
(
ptr
SafelyInitialized
<
T
>
(
)
)
;
}
DECLARE_POINTER_CONSTREF_OPS
(
T
)
;
DECLARE_POINTER_ASSIGN_OPS
(
Heap
T
)
;
const
T
*
address
(
)
const
{
return
&
ptr
;
}
void
exposeToActiveJS
(
)
const
{
js
:
:
BarrierMethods
<
T
>
:
:
exposeToJS
(
ptr
)
;
}
const
T
&
get
(
)
const
{
exposeToActiveJS
(
)
;
return
ptr
;
}
const
T
&
unbarrieredGet
(
)
const
{
return
ptr
;
}
void
set
(
const
T
&
newPtr
)
{
T
tmp
=
ptr
;
ptr
=
newPtr
;
postWriteBarrier
(
tmp
ptr
)
;
}
T
*
unsafeGet
(
)
{
return
&
ptr
;
}
void
unbarrieredSet
(
const
T
&
newPtr
)
{
ptr
=
newPtr
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
js
:
:
BarrierMethods
<
T
>
:
:
asGCThingOrNull
(
ptr
)
)
;
}
explicit
operator
bool
(
)
{
return
bool
(
js
:
:
BarrierMethods
<
T
>
:
:
asGCThingOrNull
(
ptr
)
)
;
}
private
:
void
init
(
const
T
&
newPtr
)
{
ptr
=
newPtr
;
postWriteBarrier
(
SafelyInitialized
<
T
>
(
)
ptr
)
;
}
void
postWriteBarrier
(
const
T
&
prev
const
T
&
next
)
{
js
:
:
BarrierMethods
<
T
>
:
:
postWriteBarrier
(
&
ptr
prev
next
)
;
}
T
ptr
;
}
;
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
Heap
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
Heap
<
T
>
&
v
)
{
return
v
.
unbarrieredGet
(
)
;
}
}
;
}
static
MOZ_ALWAYS_INLINE
bool
ObjectIsTenured
(
JSObject
*
obj
)
{
return
!
js
:
:
gc
:
:
IsInsideNursery
(
reinterpret_cast
<
js
:
:
gc
:
:
Cell
*
>
(
obj
)
)
;
}
static
MOZ_ALWAYS_INLINE
bool
ObjectIsTenured
(
const
Heap
<
JSObject
*
>
&
obj
)
{
return
ObjectIsTenured
(
obj
.
unbarrieredGet
(
)
)
;
}
static
MOZ_ALWAYS_INLINE
bool
ObjectIsMarkedGray
(
JSObject
*
obj
)
{
auto
cell
=
reinterpret_cast
<
js
:
:
gc
:
:
Cell
*
>
(
obj
)
;
return
js
:
:
gc
:
:
detail
:
:
CellIsMarkedGrayIfKnown
(
cell
)
;
}
static
MOZ_ALWAYS_INLINE
bool
ObjectIsMarkedGray
(
const
JS
:
:
Heap
<
JSObject
*
>
&
obj
)
{
return
ObjectIsMarkedGray
(
obj
.
unbarrieredGet
(
)
)
;
}
#
ifdef
DEBUG
inline
void
AssertCellIsNotGray
(
const
js
:
:
gc
:
:
Cell
*
maybeCell
)
{
if
(
maybeCell
)
{
js
:
:
gc
:
:
detail
:
:
AssertCellIsNotGray
(
maybeCell
)
;
}
}
inline
void
AssertObjectIsNotGray
(
JSObject
*
maybeObj
)
{
AssertCellIsNotGray
(
reinterpret_cast
<
js
:
:
gc
:
:
Cell
*
>
(
maybeObj
)
)
;
}
inline
void
AssertObjectIsNotGray
(
const
JS
:
:
Heap
<
JSObject
*
>
&
obj
)
{
AssertObjectIsNotGray
(
obj
.
unbarrieredGet
(
)
)
;
}
#
else
inline
void
AssertCellIsNotGray
(
js
:
:
gc
:
:
Cell
*
maybeCell
)
{
}
inline
void
AssertObjectIsNotGray
(
JSObject
*
maybeObj
)
{
}
inline
void
AssertObjectIsNotGray
(
const
JS
:
:
Heap
<
JSObject
*
>
&
obj
)
{
}
#
endif
template
<
typename
T
>
class
TenuredHeap
:
public
js
:
:
HeapBase
<
T
TenuredHeap
<
T
>
>
{
public
:
using
ElementType
=
T
;
TenuredHeap
(
)
:
bits
(
0
)
{
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
TenuredHeap
<
T
>
)
"
TenuredHeap
<
T
>
must
be
binary
compatible
with
T
.
"
)
;
}
explicit
TenuredHeap
(
T
p
)
:
bits
(
0
)
{
setPtr
(
p
)
;
}
explicit
TenuredHeap
(
const
TenuredHeap
<
T
>
&
p
)
:
bits
(
0
)
{
setPtr
(
p
.
getPtr
(
)
)
;
}
void
setPtr
(
T
newPtr
)
{
MOZ_ASSERT
(
(
reinterpret_cast
<
uintptr_t
>
(
newPtr
)
&
flagsMask
)
=
=
0
)
;
MOZ_ASSERT
(
js
:
:
gc
:
:
IsCellPointerValidOrNull
(
newPtr
)
)
;
if
(
newPtr
)
{
AssertGCThingMustBeTenured
(
newPtr
)
;
}
bits
=
(
bits
&
flagsMask
)
|
reinterpret_cast
<
uintptr_t
>
(
newPtr
)
;
}
void
setFlags
(
uintptr_t
flagsToSet
)
{
MOZ_ASSERT
(
(
flagsToSet
&
~
flagsMask
)
=
=
0
)
;
bits
|
=
flagsToSet
;
}
void
unsetFlags
(
uintptr_t
flagsToUnset
)
{
MOZ_ASSERT
(
(
flagsToUnset
&
~
flagsMask
)
=
=
0
)
;
bits
&
=
~
flagsToUnset
;
}
bool
hasFlag
(
uintptr_t
flag
)
const
{
MOZ_ASSERT
(
(
flag
&
~
flagsMask
)
=
=
0
)
;
return
(
bits
&
flag
)
!
=
0
;
}
T
unbarrieredGetPtr
(
)
const
{
return
reinterpret_cast
<
T
>
(
bits
&
~
flagsMask
)
;
}
uintptr_t
getFlags
(
)
const
{
return
bits
&
flagsMask
;
}
void
exposeToActiveJS
(
)
const
{
js
:
:
BarrierMethods
<
T
>
:
:
exposeToJS
(
unbarrieredGetPtr
(
)
)
;
}
T
getPtr
(
)
const
{
exposeToActiveJS
(
)
;
return
unbarrieredGetPtr
(
)
;
}
operator
T
(
)
const
{
return
getPtr
(
)
;
}
T
operator
-
>
(
)
const
{
return
getPtr
(
)
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
js
:
:
BarrierMethods
<
T
>
:
:
asGCThingOrNull
(
unbarrieredGetPtr
(
)
)
)
;
}
explicit
operator
bool
(
)
{
return
bool
(
js
:
:
BarrierMethods
<
T
>
:
:
asGCThingOrNull
(
unbarrieredGetPtr
(
)
)
)
;
}
TenuredHeap
<
T
>
&
operator
=
(
T
p
)
{
setPtr
(
p
)
;
return
*
this
;
}
TenuredHeap
<
T
>
&
operator
=
(
const
TenuredHeap
<
T
>
&
other
)
{
bits
=
other
.
bits
;
return
*
this
;
}
private
:
enum
{
maskBits
=
3
flagsMask
=
(
1
<
<
maskBits
)
-
1
}
;
uintptr_t
bits
;
}
;
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
TenuredHeap
<
T
>
>
:
std
:
:
true_type
{
static
const
T
get
(
const
TenuredHeap
<
T
>
&
v
)
{
return
v
.
unbarrieredGetPtr
(
)
;
}
}
;
}
template
<
typename
T
>
void
swap
(
TenuredHeap
<
T
>
&
aX
TenuredHeap
<
T
>
&
aY
)
{
T
tmp
=
aX
;
aX
=
aY
;
aY
=
tmp
;
}
template
<
typename
T
>
void
swap
(
Heap
<
T
>
&
aX
Heap
<
T
>
&
aY
)
{
T
tmp
=
aX
;
aX
=
aY
;
aY
=
tmp
;
}
static
MOZ_ALWAYS_INLINE
bool
ObjectIsMarkedGray
(
const
JS
:
:
TenuredHeap
<
JSObject
*
>
&
obj
)
{
return
ObjectIsMarkedGray
(
obj
.
unbarrieredGetPtr
(
)
)
;
}
template
<
typename
T
>
class
MutableHandle
;
template
<
typename
T
>
class
Rooted
;
template
<
typename
T
>
class
PersistentRooted
;
template
<
typename
T
>
class
MOZ_NONHEAP_CLASS
Handle
:
public
js
:
:
HandleBase
<
T
Handle
<
T
>
>
{
friend
class
MutableHandle
<
T
>
;
public
:
using
ElementType
=
T
;
template
<
typename
S
>
MOZ_IMPLICIT
Handle
(
Handle
<
S
>
handle
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
S
T
>
int
>
dummy
=
0
)
{
static_assert
(
sizeof
(
Handle
<
T
>
)
=
=
sizeof
(
T
*
)
"
Handle
must
be
binary
compatible
with
T
*
.
"
)
;
ptr
=
reinterpret_cast
<
const
T
*
>
(
handle
.
address
(
)
)
;
}
MOZ_IMPLICIT
Handle
(
decltype
(
nullptr
)
)
{
static_assert
(
std
:
:
is_pointer_v
<
T
>
"
nullptr_t
overload
not
valid
for
non
-
pointer
types
"
)
;
static
void
*
const
ConstNullValue
=
nullptr
;
ptr
=
reinterpret_cast
<
const
T
*
>
(
&
ConstNullValue
)
;
}
MOZ_IMPLICIT
Handle
(
MutableHandle
<
T
>
handle
)
{
ptr
=
handle
.
address
(
)
;
}
static
constexpr
Handle
fromMarkedLocation
(
const
T
*
p
)
{
return
Handle
(
p
DeliberatelyChoosingThisOverload
ImUsingThisOnlyInFromFromMarkedLocation
)
;
}
template
<
typename
S
>
inline
MOZ_IMPLICIT
Handle
(
const
Rooted
<
S
>
&
root
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
S
T
>
int
>
dummy
=
0
)
;
template
<
typename
S
>
inline
MOZ_IMPLICIT
Handle
(
const
PersistentRooted
<
S
>
&
root
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
S
T
>
int
>
dummy
=
0
)
;
template
<
typename
S
>
inline
MOZ_IMPLICIT
Handle
(
MutableHandle
<
S
>
&
root
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
S
T
>
int
>
dummy
=
0
)
;
DECLARE_POINTER_CONSTREF_OPS
(
T
)
;
DECLARE_NONPOINTER_ACCESSOR_METHODS
(
*
ptr
)
;
private
:
Handle
(
)
=
default
;
DELETE_ASSIGNMENT_OPS
(
Handle
T
)
;
enum
Disambiguator
{
DeliberatelyChoosingThisOverload
=
42
}
;
enum
CallerIdentity
{
ImUsingThisOnlyInFromFromMarkedLocation
=
17
}
;
constexpr
Handle
(
const
T
*
p
Disambiguator
CallerIdentity
)
:
ptr
(
p
)
{
}
const
T
*
ptr
;
}
;
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
Handle
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
Handle
<
T
>
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
template
<
typename
T
>
class
MOZ_STACK_CLASS
MutableHandle
:
public
js
:
:
MutableHandleBase
<
T
MutableHandle
<
T
>
>
{
public
:
using
ElementType
=
T
;
inline
MOZ_IMPLICIT
MutableHandle
(
Rooted
<
T
>
*
root
)
;
inline
MOZ_IMPLICIT
MutableHandle
(
PersistentRooted
<
T
>
*
root
)
;
private
:
MutableHandle
(
decltype
(
nullptr
)
)
=
delete
;
public
:
void
set
(
const
T
&
v
)
{
*
ptr
=
v
;
MOZ_ASSERT
(
GCPolicy
<
T
>
:
:
isValid
(
*
ptr
)
)
;
}
void
set
(
T
&
&
v
)
{
*
ptr
=
std
:
:
move
(
v
)
;
MOZ_ASSERT
(
GCPolicy
<
T
>
:
:
isValid
(
*
ptr
)
)
;
}
static
MutableHandle
fromMarkedLocation
(
T
*
p
)
{
MutableHandle
h
;
h
.
ptr
=
p
;
return
h
;
}
DECLARE_POINTER_CONSTREF_OPS
(
T
)
;
DECLARE_NONPOINTER_ACCESSOR_METHODS
(
*
ptr
)
;
DECLARE_NONPOINTER_MUTABLE_ACCESSOR_METHODS
(
*
ptr
)
;
private
:
MutableHandle
(
)
=
default
;
DELETE_ASSIGNMENT_OPS
(
MutableHandle
T
)
;
T
*
ptr
;
}
;
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
MutableHandle
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
MutableHandle
<
T
>
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
}
namespace
js
{
namespace
detail
{
template
<
typename
T
>
struct
PtrBarrierMethodsBase
{
static
T
*
initial
(
)
{
return
nullptr
;
}
static
gc
:
:
Cell
*
asGCThingOrNull
(
T
*
v
)
{
if
(
!
v
)
{
return
nullptr
;
}
MOZ_ASSERT
(
uintptr_t
(
v
)
>
32
)
;
return
reinterpret_cast
<
gc
:
:
Cell
*
>
(
v
)
;
}
static
void
exposeToJS
(
T
*
t
)
{
if
(
t
)
{
js
:
:
gc
:
:
ExposeGCThingToActiveJS
(
JS
:
:
GCCellPtr
(
t
)
)
;
}
}
}
;
}
template
<
typename
T
>
struct
BarrierMethods
<
T
*
>
:
public
detail
:
:
PtrBarrierMethodsBase
<
T
>
{
static
void
postWriteBarrier
(
T
*
*
vp
T
*
prev
T
*
next
)
{
if
(
next
)
{
JS
:
:
AssertGCThingIsNotNurseryAllocable
(
reinterpret_cast
<
js
:
:
gc
:
:
Cell
*
>
(
next
)
)
;
}
}
}
;
template
<
>
struct
BarrierMethods
<
JSObject
*
>
:
public
detail
:
:
PtrBarrierMethodsBase
<
JSObject
>
{
static
void
postWriteBarrier
(
JSObject
*
*
vp
JSObject
*
prev
JSObject
*
next
)
{
JS
:
:
HeapObjectPostWriteBarrier
(
vp
prev
next
)
;
}
static
void
exposeToJS
(
JSObject
*
obj
)
{
if
(
obj
)
{
JS
:
:
ExposeObjectToActiveJS
(
obj
)
;
}
}
}
;
template
<
>
struct
BarrierMethods
<
JSFunction
*
>
:
public
detail
:
:
PtrBarrierMethodsBase
<
JSFunction
>
{
static
void
postWriteBarrier
(
JSFunction
*
*
vp
JSFunction
*
prev
JSFunction
*
next
)
{
JS
:
:
HeapObjectPostWriteBarrier
(
reinterpret_cast
<
JSObject
*
*
>
(
vp
)
reinterpret_cast
<
JSObject
*
>
(
prev
)
reinterpret_cast
<
JSObject
*
>
(
next
)
)
;
}
static
void
exposeToJS
(
JSFunction
*
fun
)
{
if
(
fun
)
{
JS
:
:
ExposeObjectToActiveJS
(
reinterpret_cast
<
JSObject
*
>
(
fun
)
)
;
}
}
}
;
template
<
>
struct
BarrierMethods
<
JSString
*
>
:
public
detail
:
:
PtrBarrierMethodsBase
<
JSString
>
{
static
void
postWriteBarrier
(
JSString
*
*
vp
JSString
*
prev
JSString
*
next
)
{
JS
:
:
HeapStringPostWriteBarrier
(
vp
prev
next
)
;
}
}
;
template
<
>
struct
BarrierMethods
<
JS
:
:
BigInt
*
>
:
public
detail
:
:
PtrBarrierMethodsBase
<
JS
:
:
BigInt
>
{
static
void
postWriteBarrier
(
JS
:
:
BigInt
*
*
vp
JS
:
:
BigInt
*
prev
JS
:
:
BigInt
*
next
)
{
JS
:
:
HeapBigIntPostWriteBarrier
(
vp
prev
next
)
;
}
}
;
template
<
typename
T
>
struct
JS_PUBLIC_API
MovableCellHasher
{
using
Key
=
T
;
using
Lookup
=
T
;
static
bool
hasHash
(
const
Lookup
&
l
)
;
static
bool
ensureHash
(
const
Lookup
&
l
)
;
static
HashNumber
hash
(
const
Lookup
&
l
)
;
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
;
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
=
newKey
;
}
}
;
template
<
typename
T
>
struct
JS_PUBLIC_API
MovableCellHasher
<
JS
:
:
Heap
<
T
>
>
{
using
Key
=
JS
:
:
Heap
<
T
>
;
using
Lookup
=
T
;
static
bool
hasHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hasHash
(
l
)
;
}
static
bool
ensureHash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
ensureHash
(
l
)
;
}
static
HashNumber
hash
(
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
hash
(
l
)
;
}
static
bool
match
(
const
Key
&
k
const
Lookup
&
l
)
{
return
MovableCellHasher
<
T
>
:
:
match
(
k
.
unbarrieredGet
(
)
l
)
;
}
static
void
rekey
(
Key
&
k
const
Key
&
newKey
)
{
k
.
unsafeSet
(
newKey
)
;
}
}
;
}
namespace
mozilla
{
template
<
typename
T
>
struct
FallibleHashMethods
<
js
:
:
MovableCellHasher
<
T
>
>
{
template
<
typename
Lookup
>
static
bool
hasHash
(
Lookup
&
&
l
)
{
return
js
:
:
MovableCellHasher
<
T
>
:
:
hasHash
(
std
:
:
forward
<
Lookup
>
(
l
)
)
;
}
template
<
typename
Lookup
>
static
bool
ensureHash
(
Lookup
&
&
l
)
{
return
js
:
:
MovableCellHasher
<
T
>
:
:
ensureHash
(
std
:
:
forward
<
Lookup
>
(
l
)
)
;
}
}
;
}
namespace
js
{
template
<
typename
T
>
class
alignas
(
8
)
DispatchWrapper
{
static_assert
(
JS
:
:
MapTypeToRootKind
<
T
>
:
:
kind
=
=
JS
:
:
RootKind
:
:
Traceable
"
DispatchWrapper
is
intended
only
for
usage
with
a
Traceable
"
)
;
using
TraceFn
=
void
(
*
)
(
JSTracer
*
T
*
const
char
*
)
;
TraceFn
tracer
;
alignas
(
gc
:
:
CellAlignBytes
)
T
storage
;
public
:
template
<
typename
U
>
MOZ_IMPLICIT
DispatchWrapper
(
U
&
&
initial
)
:
tracer
(
&
JS
:
:
GCPolicy
<
T
>
:
:
trace
)
storage
(
std
:
:
forward
<
U
>
(
initial
)
)
{
}
T
*
operator
&
(
)
{
return
&
storage
;
}
const
T
*
operator
&
(
)
const
{
return
&
storage
;
}
operator
T
&
(
)
{
return
storage
;
}
operator
const
T
&
(
)
const
{
return
storage
;
}
static
void
TraceWrapped
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
{
auto
wrapper
=
reinterpret_cast
<
DispatchWrapper
*
>
(
uintptr_t
(
thingp
)
-
offsetof
(
DispatchWrapper
storage
)
)
;
wrapper
-
>
tracer
(
trc
&
wrapper
-
>
storage
name
)
;
}
}
;
}
namespace
JS
{
class
JS_PUBLIC_API
AutoGCRooter
;
enum
class
AutoGCRooterKind
:
uint8_t
{
Parser
BinASTParser
WrapperVector
Wrapper
Custom
Limit
}
;
template
<
>
struct
MapTypeToRootKind
<
void
*
>
{
static
const
RootKind
kind
=
RootKind
:
:
Traceable
;
}
;
using
RootedListHeads
=
mozilla
:
:
EnumeratedArray
<
RootKind
RootKind
:
:
Limit
Rooted
<
void
*
>
*
>
;
using
AutoRooterListHeads
=
mozilla
:
:
EnumeratedArray
<
AutoGCRooterKind
AutoGCRooterKind
:
:
Limit
AutoGCRooter
*
>
;
class
RootingContext
{
RootedListHeads
stackRoots_
;
template
<
typename
T
>
friend
class
Rooted
;
AutoRooterListHeads
autoGCRooters_
;
friend
class
AutoGCRooter
;
js
:
:
GeckoProfilerThread
geckoProfiler_
;
public
:
RootingContext
(
)
;
void
traceStackRoots
(
JSTracer
*
trc
)
;
void
traceAllGCRooters
(
JSTracer
*
trc
)
;
void
traceWrapperGCRooters
(
JSTracer
*
trc
)
;
static
void
traceGCRooterList
(
JSTracer
*
trc
AutoGCRooter
*
head
)
;
void
checkNoGCRooters
(
)
;
js
:
:
GeckoProfilerThread
&
geckoProfiler
(
)
{
return
geckoProfiler_
;
}
protected
:
Realm
*
realm_
;
Zone
*
zone_
;
public
:
uintptr_t
nativeStackLimit
[
StackKindCount
]
;
static
const
RootingContext
*
get
(
const
JSContext
*
cx
)
{
return
reinterpret_cast
<
const
RootingContext
*
>
(
cx
)
;
}
static
RootingContext
*
get
(
JSContext
*
cx
)
{
return
reinterpret_cast
<
RootingContext
*
>
(
cx
)
;
}
friend
JS
:
:
Realm
*
js
:
:
GetContextRealm
(
const
JSContext
*
cx
)
;
friend
JS
:
:
Zone
*
js
:
:
GetContextZone
(
const
JSContext
*
cx
)
;
}
;
class
JS_PUBLIC_API
AutoGCRooter
{
public
:
using
Kind
=
AutoGCRooterKind
;
AutoGCRooter
(
JSContext
*
cx
Kind
kind
)
:
AutoGCRooter
(
JS
:
:
RootingContext
:
:
get
(
cx
)
kind
)
{
}
AutoGCRooter
(
RootingContext
*
cx
Kind
kind
)
:
down
(
cx
-
>
autoGCRooters_
[
kind
]
)
stackTop
(
&
cx
-
>
autoGCRooters_
[
kind
]
)
kind_
(
kind
)
{
MOZ_ASSERT
(
this
!
=
*
stackTop
)
;
*
stackTop
=
this
;
}
~
AutoGCRooter
(
)
{
MOZ_ASSERT
(
this
=
=
*
stackTop
)
;
*
stackTop
=
down
;
}
void
trace
(
JSTracer
*
trc
)
;
private
:
friend
class
RootingContext
;
AutoGCRooter
*
const
down
;
AutoGCRooter
*
*
const
stackTop
;
Kind
kind_
;
AutoGCRooter
(
AutoGCRooter
&
ida
)
=
delete
;
void
operator
=
(
AutoGCRooter
&
ida
)
=
delete
;
}
JS_HAZ_ROOTED_BASE
;
namespace
detail
{
template
<
typename
T
>
using
MaybeWrapped
=
std
:
:
conditional_t
<
MapTypeToRootKind
<
T
>
:
:
kind
=
=
JS
:
:
RootKind
:
:
Traceable
js
:
:
DispatchWrapper
<
T
>
T
>
;
struct
FallbackOverload
{
}
;
struct
PreferredOverload
:
FallbackOverload
{
}
;
using
OverloadSelector
=
PreferredOverload
;
}
template
<
typename
T
>
class
MOZ_RAII
Rooted
:
public
js
:
:
RootedBase
<
T
Rooted
<
T
>
>
{
inline
void
registerWithRootLists
(
RootedListHeads
&
roots
)
{
this
-
>
stack
=
&
roots
[
JS
:
:
MapTypeToRootKind
<
T
>
:
:
kind
]
;
this
-
>
prev
=
*
stack
;
*
stack
=
reinterpret_cast
<
Rooted
<
void
*
>
*
>
(
this
)
;
}
inline
RootedListHeads
&
rootLists
(
RootingContext
*
cx
)
{
return
cx
-
>
stackRoots_
;
}
inline
RootedListHeads
&
rootLists
(
JSContext
*
cx
)
{
return
rootLists
(
RootingContext
:
:
get
(
cx
)
)
;
}
struct
CtorDispatcher
{
}
;
template
<
typename
RootingContext
>
Rooted
(
const
RootingContext
&
cx
CtorDispatcher
detail
:
:
FallbackOverload
)
:
Rooted
(
cx
SafelyInitialized
<
T
>
(
)
)
{
}
template
<
typename
RootingContext
typename
=
std
:
:
enable_if_t
<
std
:
:
is_constructible_v
<
T
RootingContext
>
>
>
Rooted
(
const
RootingContext
&
cx
CtorDispatcher
detail
:
:
PreferredOverload
)
:
Rooted
(
cx
T
(
cx
)
)
{
}
public
:
using
ElementType
=
T
;
template
<
typename
RootingContext
>
explicit
Rooted
(
const
RootingContext
&
cx
)
:
Rooted
(
cx
CtorDispatcher
(
)
detail
:
:
OverloadSelector
(
)
)
{
}
template
<
typename
RootingContext
typename
S
>
Rooted
(
const
RootingContext
&
cx
S
&
&
initial
)
:
ptr
(
std
:
:
forward
<
S
>
(
initial
)
)
{
MOZ_ASSERT
(
GCPolicy
<
T
>
:
:
isValid
(
ptr
)
)
;
registerWithRootLists
(
rootLists
(
cx
)
)
;
}
~
Rooted
(
)
{
MOZ_ASSERT
(
*
stack
=
=
reinterpret_cast
<
Rooted
<
void
*
>
*
>
(
this
)
)
;
*
stack
=
prev
;
}
Rooted
<
T
>
*
previous
(
)
{
return
reinterpret_cast
<
Rooted
<
T
>
*
>
(
prev
)
;
}
void
set
(
const
T
&
value
)
{
ptr
=
value
;
MOZ_ASSERT
(
GCPolicy
<
T
>
:
:
isValid
(
ptr
)
)
;
}
void
set
(
T
&
&
value
)
{
ptr
=
std
:
:
move
(
value
)
;
MOZ_ASSERT
(
GCPolicy
<
T
>
:
:
isValid
(
ptr
)
)
;
}
DECLARE_POINTER_CONSTREF_OPS
(
T
)
;
DECLARE_POINTER_ASSIGN_OPS
(
Rooted
T
)
;
DECLARE_NONPOINTER_ACCESSOR_METHODS
(
ptr
)
;
DECLARE_NONPOINTER_MUTABLE_ACCESSOR_METHODS
(
ptr
)
;
private
:
Rooted
<
void
*
>
*
*
stack
;
Rooted
<
void
*
>
*
prev
;
detail
:
:
MaybeWrapped
<
T
>
ptr
;
Rooted
(
const
Rooted
&
)
=
delete
;
}
JS_HAZ_ROOTED
;
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
Rooted
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
Rooted
<
T
>
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
}
namespace
js
{
inline
JS
:
:
Realm
*
GetContextRealm
(
const
JSContext
*
cx
)
{
return
JS
:
:
RootingContext
:
:
get
(
cx
)
-
>
realm_
;
}
inline
JS
:
:
Compartment
*
GetContextCompartment
(
const
JSContext
*
cx
)
{
if
(
JS
:
:
Realm
*
realm
=
GetContextRealm
(
cx
)
)
{
return
GetCompartmentForRealm
(
realm
)
;
}
return
nullptr
;
}
inline
JS
:
:
Zone
*
GetContextZone
(
const
JSContext
*
cx
)
{
return
JS
:
:
RootingContext
:
:
get
(
cx
)
-
>
zone_
;
}
inline
ProfilingStack
*
GetContextProfilingStackIfEnabled
(
JSContext
*
cx
)
{
return
JS
:
:
RootingContext
:
:
get
(
cx
)
-
>
geckoProfiler
(
)
.
getProfilingStackIfEnabled
(
)
;
}
template
<
typename
Container
>
class
RootedBase
<
JSObject
*
Container
>
:
public
MutableWrappedPtrOperations
<
JSObject
*
Container
>
{
public
:
template
<
class
U
>
JS
:
:
Handle
<
U
*
>
as
(
)
const
;
}
;
template
<
typename
Container
>
class
HandleBase
<
JSObject
*
Container
>
:
public
WrappedPtrOperations
<
JSObject
*
Container
>
{
public
:
template
<
class
U
>
JS
:
:
Handle
<
U
*
>
as
(
)
const
;
}
;
}
namespace
JS
{
template
<
typename
T
>
template
<
typename
S
>
inline
Handle
<
T
>
:
:
Handle
(
const
Rooted
<
S
>
&
root
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
S
T
>
int
>
dummy
)
{
ptr
=
reinterpret_cast
<
const
T
*
>
(
root
.
address
(
)
)
;
}
template
<
typename
T
>
template
<
typename
S
>
inline
Handle
<
T
>
:
:
Handle
(
const
PersistentRooted
<
S
>
&
root
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
S
T
>
int
>
dummy
)
{
ptr
=
reinterpret_cast
<
const
T
*
>
(
root
.
address
(
)
)
;
}
template
<
typename
T
>
template
<
typename
S
>
inline
Handle
<
T
>
:
:
Handle
(
MutableHandle
<
S
>
&
root
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
S
T
>
int
>
dummy
)
{
ptr
=
reinterpret_cast
<
const
T
*
>
(
root
.
address
(
)
)
;
}
template
<
typename
T
>
inline
MutableHandle
<
T
>
:
:
MutableHandle
(
Rooted
<
T
>
*
root
)
{
static_assert
(
sizeof
(
MutableHandle
<
T
>
)
=
=
sizeof
(
T
*
)
"
MutableHandle
must
be
binary
compatible
with
T
*
.
"
)
;
ptr
=
root
-
>
address
(
)
;
}
template
<
typename
T
>
inline
MutableHandle
<
T
>
:
:
MutableHandle
(
PersistentRooted
<
T
>
*
root
)
{
static_assert
(
sizeof
(
MutableHandle
<
T
>
)
=
=
sizeof
(
T
*
)
"
MutableHandle
must
be
binary
compatible
with
T
*
.
"
)
;
ptr
=
root
-
>
address
(
)
;
}
JS_PUBLIC_API
void
AddPersistentRoot
(
RootingContext
*
cx
RootKind
kind
PersistentRooted
<
void
*
>
*
root
)
;
JS_PUBLIC_API
void
AddPersistentRoot
(
JSRuntime
*
rt
RootKind
kind
PersistentRooted
<
void
*
>
*
root
)
;
template
<
typename
T
>
class
PersistentRooted
:
public
js
:
:
RootedBase
<
T
PersistentRooted
<
T
>
>
private
mozilla
:
:
LinkedListElement
<
PersistentRooted
<
T
>
>
{
using
ListBase
=
mozilla
:
:
LinkedListElement
<
PersistentRooted
<
T
>
>
;
friend
class
mozilla
:
:
LinkedList
<
PersistentRooted
>
;
friend
class
mozilla
:
:
LinkedListElement
<
PersistentRooted
>
;
void
registerWithRootLists
(
RootingContext
*
cx
)
{
MOZ_ASSERT
(
!
initialized
(
)
)
;
JS
:
:
RootKind
kind
=
JS
:
:
MapTypeToRootKind
<
T
>
:
:
kind
;
AddPersistentRoot
(
cx
kind
reinterpret_cast
<
JS
:
:
PersistentRooted
<
void
*
>
*
>
(
this
)
)
;
}
void
registerWithRootLists
(
JSRuntime
*
rt
)
{
MOZ_ASSERT
(
!
initialized
(
)
)
;
JS
:
:
RootKind
kind
=
JS
:
:
MapTypeToRootKind
<
T
>
:
:
kind
;
AddPersistentRoot
(
rt
kind
reinterpret_cast
<
JS
:
:
PersistentRooted
<
void
*
>
*
>
(
this
)
)
;
}
public
:
using
ElementType
=
T
;
PersistentRooted
(
)
:
ptr
(
SafelyInitialized
<
T
>
(
)
)
{
}
explicit
PersistentRooted
(
RootingContext
*
cx
)
:
ptr
(
SafelyInitialized
<
T
>
(
)
)
{
registerWithRootLists
(
cx
)
;
}
explicit
PersistentRooted
(
JSContext
*
cx
)
:
ptr
(
SafelyInitialized
<
T
>
(
)
)
{
registerWithRootLists
(
RootingContext
:
:
get
(
cx
)
)
;
}
template
<
typename
U
>
PersistentRooted
(
RootingContext
*
cx
U
&
&
initial
)
:
ptr
(
std
:
:
forward
<
U
>
(
initial
)
)
{
registerWithRootLists
(
cx
)
;
}
template
<
typename
U
>
PersistentRooted
(
JSContext
*
cx
U
&
&
initial
)
:
ptr
(
std
:
:
forward
<
U
>
(
initial
)
)
{
registerWithRootLists
(
RootingContext
:
:
get
(
cx
)
)
;
}
explicit
PersistentRooted
(
JSRuntime
*
rt
)
:
ptr
(
SafelyInitialized
<
T
>
(
)
)
{
registerWithRootLists
(
rt
)
;
}
template
<
typename
U
>
PersistentRooted
(
JSRuntime
*
rt
U
&
&
initial
)
:
ptr
(
std
:
:
forward
<
U
>
(
initial
)
)
{
registerWithRootLists
(
rt
)
;
}
PersistentRooted
(
const
PersistentRooted
&
rhs
)
:
mozilla
:
:
LinkedListElement
<
PersistentRooted
<
T
>
>
(
)
ptr
(
rhs
.
ptr
)
{
const_cast
<
PersistentRooted
&
>
(
rhs
)
.
setNext
(
this
)
;
}
bool
initialized
(
)
{
return
ListBase
:
:
isInList
(
)
;
}
void
init
(
RootingContext
*
cx
)
{
init
(
cx
SafelyInitialized
<
T
>
(
)
)
;
}
void
init
(
JSContext
*
cx
)
{
init
(
RootingContext
:
:
get
(
cx
)
)
;
}
template
<
typename
U
>
void
init
(
RootingContext
*
cx
U
&
&
initial
)
{
ptr
=
std
:
:
forward
<
U
>
(
initial
)
;
registerWithRootLists
(
cx
)
;
}
template
<
typename
U
>
void
init
(
JSContext
*
cx
U
&
&
initial
)
{
ptr
=
std
:
:
forward
<
U
>
(
initial
)
;
registerWithRootLists
(
RootingContext
:
:
get
(
cx
)
)
;
}
void
reset
(
)
{
if
(
initialized
(
)
)
{
set
(
SafelyInitialized
<
T
>
(
)
)
;
ListBase
:
:
remove
(
)
;
}
}
DECLARE_POINTER_CONSTREF_OPS
(
T
)
;
DECLARE_POINTER_ASSIGN_OPS
(
PersistentRooted
T
)
;
DECLARE_NONPOINTER_ACCESSOR_METHODS
(
ptr
)
;
T
*
address
(
)
{
MOZ_ASSERT
(
initialized
(
)
)
;
return
&
ptr
;
}
T
&
get
(
)
{
MOZ_ASSERT
(
initialized
(
)
)
;
return
ptr
;
}
template
<
typename
U
>
void
set
(
U
&
&
value
)
{
MOZ_ASSERT
(
initialized
(
)
)
;
ptr
=
std
:
:
forward
<
U
>
(
value
)
;
}
private
:
detail
:
:
MaybeWrapped
<
T
>
ptr
;
}
JS_HAZ_ROOTED
;
namespace
detail
{
template
<
typename
T
>
struct
DefineComparisonOps
<
PersistentRooted
<
T
>
>
:
std
:
:
true_type
{
static
const
T
&
get
(
const
PersistentRooted
<
T
>
&
v
)
{
return
v
.
get
(
)
;
}
}
;
}
}
namespace
js
{
template
<
typename
T
typename
D
typename
Container
>
class
WrappedPtrOperations
<
UniquePtr
<
T
D
>
Container
>
{
const
UniquePtr
<
T
D
>
&
uniquePtr
(
)
const
{
return
static_cast
<
const
Container
*
>
(
this
)
-
>
get
(
)
;
}
public
:
explicit
operator
bool
(
)
const
{
return
!
!
uniquePtr
(
)
;
}
T
*
get
(
)
const
{
return
uniquePtr
(
)
.
get
(
)
;
}
T
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
T
&
operator
*
(
)
const
{
return
*
uniquePtr
(
)
;
}
}
;
template
<
typename
T
typename
D
typename
Container
>
class
MutableWrappedPtrOperations
<
UniquePtr
<
T
D
>
Container
>
:
public
WrappedPtrOperations
<
UniquePtr
<
T
D
>
Container
>
{
UniquePtr
<
T
D
>
&
uniquePtr
(
)
{
return
static_cast
<
Container
*
>
(
this
)
-
>
get
(
)
;
}
public
:
MOZ_MUST_USE
typename
UniquePtr
<
T
D
>
:
:
Pointer
release
(
)
{
return
uniquePtr
(
)
.
release
(
)
;
}
void
reset
(
T
*
ptr
=
T
(
)
)
{
uniquePtr
(
)
.
reset
(
ptr
)
;
}
}
;
template
<
typename
T
typename
Container
>
class
WrappedPtrOperations
<
mozilla
:
:
Maybe
<
T
>
Container
>
{
const
mozilla
:
:
Maybe
<
T
>
&
maybe
(
)
const
{
return
static_cast
<
const
Container
*
>
(
this
)
-
>
get
(
)
;
}
public
:
bool
isSome
(
)
const
{
return
maybe
(
)
.
isSome
(
)
;
}
bool
isNothing
(
)
const
{
return
maybe
(
)
.
isNothing
(
)
;
}
const
T
value
(
)
const
{
return
maybe
(
)
.
value
(
)
;
}
const
T
*
operator
-
>
(
)
const
{
return
maybe
(
)
.
ptr
(
)
;
}
const
T
&
operator
*
(
)
const
{
return
maybe
(
)
.
ref
(
)
;
}
}
;
template
<
typename
T
typename
Container
>
class
MutableWrappedPtrOperations
<
mozilla
:
:
Maybe
<
T
>
Container
>
:
public
WrappedPtrOperations
<
mozilla
:
:
Maybe
<
T
>
Container
>
{
mozilla
:
:
Maybe
<
T
>
&
maybe
(
)
{
return
static_cast
<
Container
*
>
(
this
)
-
>
get
(
)
;
}
public
:
T
*
operator
-
>
(
)
{
return
maybe
(
)
.
ptr
(
)
;
}
T
&
operator
*
(
)
{
return
maybe
(
)
.
ref
(
)
;
}
void
reset
(
)
{
return
maybe
(
)
.
reset
(
)
;
}
}
;
namespace
gc
{
template
<
typename
T
typename
TraceCallbacks
>
void
CallTraceCallbackOnNonHeap
(
T
*
v
const
TraceCallbacks
&
aCallbacks
const
char
*
aName
void
*
aClosure
)
{
static_assert
(
sizeof
(
T
)
=
=
sizeof
(
JS
:
:
Heap
<
T
>
)
"
T
and
Heap
<
T
>
must
be
compatible
.
"
)
;
MOZ_ASSERT
(
v
)
;
mozilla
:
:
DebugOnly
<
Cell
*
>
cell
=
BarrierMethods
<
T
>
:
:
asGCThingOrNull
(
*
v
)
;
MOZ_ASSERT
(
cell
)
;
MOZ_ASSERT
(
!
IsInsideNursery
(
cell
)
)
;
JS
:
:
Heap
<
T
>
*
asHeapT
=
reinterpret_cast
<
JS
:
:
Heap
<
T
>
*
>
(
v
)
;
aCallbacks
.
Trace
(
asHeapT
aName
aClosure
)
;
}
}
}
#
endif
