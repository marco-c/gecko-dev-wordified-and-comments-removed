#
ifndef
GCHashTable_h
#
define
GCHashTable_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
js
/
GCPolicyAPI
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
SweepingAPI
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
namespace
JS
{
template
<
typename
Key
typename
Value
>
struct
DefaultMapSweepPolicy
{
static
bool
needsSweep
(
Key
*
key
Value
*
value
)
{
return
GCPolicy
<
Key
>
:
:
needsSweep
(
key
)
|
|
GCPolicy
<
Value
>
:
:
needsSweep
(
value
)
;
}
static
bool
traceWeak
(
JSTracer
*
trc
Key
*
key
Value
*
value
)
{
return
GCPolicy
<
Key
>
:
:
traceWeak
(
trc
key
)
&
&
GCPolicy
<
Value
>
:
:
traceWeak
(
trc
value
)
;
}
}
;
template
<
typename
Key
typename
Value
typename
HashPolicy
=
js
:
:
DefaultHasher
<
Key
>
typename
AllocPolicy
=
js
:
:
TempAllocPolicy
typename
MapSweepPolicy
=
DefaultMapSweepPolicy
<
Key
Value
>
>
class
GCHashMap
:
public
js
:
:
HashMap
<
Key
Value
HashPolicy
AllocPolicy
>
{
using
Base
=
js
:
:
HashMap
<
Key
Value
HashPolicy
AllocPolicy
>
;
public
:
explicit
GCHashMap
(
AllocPolicy
a
=
AllocPolicy
(
)
)
:
Base
(
std
:
:
move
(
a
)
)
{
}
explicit
GCHashMap
(
size_t
length
)
:
Base
(
length
)
{
}
GCHashMap
(
AllocPolicy
a
size_t
length
)
:
Base
(
std
:
:
move
(
a
)
length
)
{
}
void
trace
(
JSTracer
*
trc
)
{
for
(
typename
Base
:
:
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
GCPolicy
<
Value
>
:
:
trace
(
trc
&
e
.
front
(
)
.
value
(
)
"
hashmap
value
"
)
;
GCPolicy
<
Key
>
:
:
trace
(
trc
&
e
.
front
(
)
.
mutableKey
(
)
"
hashmap
key
"
)
;
}
}
bool
needsSweep
(
)
const
{
return
!
this
-
>
empty
(
)
;
}
void
sweep
(
)
{
for
(
typename
Base
:
:
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
if
(
MapSweepPolicy
:
:
needsSweep
(
&
e
.
front
(
)
.
mutableKey
(
)
&
e
.
front
(
)
.
value
(
)
)
)
{
e
.
removeFront
(
)
;
}
}
}
void
traceWeak
(
JSTracer
*
trc
)
{
for
(
typename
Base
:
:
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
if
(
!
MapSweepPolicy
:
:
traceWeak
(
trc
&
e
.
front
(
)
.
mutableKey
(
)
&
e
.
front
(
)
.
value
(
)
)
)
{
e
.
removeFront
(
)
;
}
}
}
GCHashMap
(
GCHashMap
&
&
rhs
)
:
Base
(
std
:
:
move
(
rhs
)
)
{
}
void
operator
=
(
GCHashMap
&
&
rhs
)
{
MOZ_ASSERT
(
this
!
=
&
rhs
"
self
-
move
assignment
is
prohibited
"
)
;
Base
:
:
operator
=
(
std
:
:
move
(
rhs
)
)
;
}
private
:
GCHashMap
(
const
GCHashMap
&
hm
)
=
delete
;
GCHashMap
&
operator
=
(
const
GCHashMap
&
hm
)
=
delete
;
}
MOZ_INHERIT_TYPE_ANNOTATIONS_FROM_TEMPLATE_ARGS
;
}
namespace
js
{
template
<
typename
Key
typename
Value
typename
HashPolicy
=
DefaultHasher
<
Key
>
typename
AllocPolicy
=
TempAllocPolicy
typename
MapSweepPolicy
=
JS
:
:
DefaultMapSweepPolicy
<
Key
Value
>
>
class
GCRekeyableHashMap
:
public
JS
:
:
GCHashMap
<
Key
Value
HashPolicy
AllocPolicy
MapSweepPolicy
>
{
using
Base
=
JS
:
:
GCHashMap
<
Key
Value
HashPolicy
AllocPolicy
>
;
public
:
explicit
GCRekeyableHashMap
(
AllocPolicy
a
=
AllocPolicy
(
)
)
:
Base
(
std
:
:
move
(
a
)
)
{
}
explicit
GCRekeyableHashMap
(
size_t
length
)
:
Base
(
length
)
{
}
GCRekeyableHashMap
(
AllocPolicy
a
size_t
length
)
:
Base
(
std
:
:
move
(
a
)
length
)
{
}
void
sweep
(
)
{
for
(
typename
Base
:
:
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Key
key
(
e
.
front
(
)
.
key
(
)
)
;
if
(
MapSweepPolicy
:
:
needsSweep
(
&
key
&
e
.
front
(
)
.
value
(
)
)
)
{
e
.
removeFront
(
)
;
}
else
if
(
!
HashPolicy
:
:
match
(
key
e
.
front
(
)
.
key
(
)
)
)
{
e
.
rekeyFront
(
key
)
;
}
}
}
void
traceWeak
(
JSTracer
*
trc
)
{
for
(
typename
Base
:
:
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
Key
key
(
e
.
front
(
)
.
key
(
)
)
;
if
(
!
MapSweepPolicy
:
:
traceWeak
(
trc
&
key
&
e
.
front
(
)
.
value
(
)
)
)
{
e
.
removeFront
(
)
;
}
else
if
(
!
HashPolicy
:
:
match
(
key
e
.
front
(
)
.
key
(
)
)
)
{
e
.
rekeyFront
(
key
)
;
}
}
}
GCRekeyableHashMap
(
GCRekeyableHashMap
&
&
rhs
)
:
Base
(
std
:
:
move
(
rhs
)
)
{
}
void
operator
=
(
GCRekeyableHashMap
&
&
rhs
)
{
MOZ_ASSERT
(
this
!
=
&
rhs
"
self
-
move
assignment
is
prohibited
"
)
;
Base
:
:
operator
=
(
std
:
:
move
(
rhs
)
)
;
}
}
MOZ_INHERIT_TYPE_ANNOTATIONS_FROM_TEMPLATE_ARGS
;
template
<
typename
Wrapper
typename
.
.
.
Args
>
class
WrappedPtrOperations
<
JS
:
:
GCHashMap
<
Args
.
.
.
>
Wrapper
>
{
using
Map
=
JS
:
:
GCHashMap
<
Args
.
.
.
>
;
using
Lookup
=
typename
Map
:
:
Lookup
;
const
Map
&
map
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
using
AddPtr
=
typename
Map
:
:
AddPtr
;
using
Ptr
=
typename
Map
:
:
Ptr
;
using
Range
=
typename
Map
:
:
Range
;
Ptr
lookup
(
const
Lookup
&
l
)
const
{
return
map
(
)
.
lookup
(
l
)
;
}
Range
all
(
)
const
{
return
map
(
)
.
all
(
)
;
}
bool
empty
(
)
const
{
return
map
(
)
.
empty
(
)
;
}
uint32_t
count
(
)
const
{
return
map
(
)
.
count
(
)
;
}
size_t
capacity
(
)
const
{
return
map
(
)
.
capacity
(
)
;
}
bool
has
(
const
Lookup
&
l
)
const
{
return
map
(
)
.
lookup
(
l
)
.
found
(
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
map
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
map
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
template
<
typename
Wrapper
typename
.
.
.
Args
>
class
MutableWrappedPtrOperations
<
JS
:
:
GCHashMap
<
Args
.
.
.
>
Wrapper
>
:
public
WrappedPtrOperations
<
JS
:
:
GCHashMap
<
Args
.
.
.
>
Wrapper
>
{
using
Map
=
JS
:
:
GCHashMap
<
Args
.
.
.
>
;
using
Lookup
=
typename
Map
:
:
Lookup
;
Map
&
map
(
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
using
AddPtr
=
typename
Map
:
:
AddPtr
;
struct
Enum
:
public
Map
:
:
Enum
{
explicit
Enum
(
Wrapper
&
o
)
:
Map
:
:
Enum
(
o
.
map
(
)
)
{
}
}
;
using
Ptr
=
typename
Map
:
:
Ptr
;
using
Range
=
typename
Map
:
:
Range
;
void
clear
(
)
{
map
(
)
.
clear
(
)
;
}
void
clearAndCompact
(
)
{
map
(
)
.
clearAndCompact
(
)
;
}
void
remove
(
Ptr
p
)
{
map
(
)
.
remove
(
p
)
;
}
AddPtr
lookupForAdd
(
const
Lookup
&
l
)
{
return
map
(
)
.
lookupForAdd
(
l
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
bool
add
(
AddPtr
&
p
KeyInput
&
&
k
ValueInput
&
&
v
)
{
return
map
(
)
.
add
(
p
std
:
:
forward
<
KeyInput
>
(
k
)
std
:
:
forward
<
ValueInput
>
(
v
)
)
;
}
template
<
typename
KeyInput
>
bool
add
(
AddPtr
&
p
KeyInput
&
&
k
)
{
return
map
(
)
.
add
(
p
std
:
:
forward
<
KeyInput
>
(
k
)
Map
:
:
Value
(
)
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
bool
relookupOrAdd
(
AddPtr
&
p
KeyInput
&
&
k
ValueInput
&
&
v
)
{
return
map
(
)
.
relookupOrAdd
(
p
k
std
:
:
forward
<
KeyInput
>
(
k
)
std
:
:
forward
<
ValueInput
>
(
v
)
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
bool
put
(
KeyInput
&
&
k
ValueInput
&
&
v
)
{
return
map
(
)
.
put
(
std
:
:
forward
<
KeyInput
>
(
k
)
std
:
:
forward
<
ValueInput
>
(
v
)
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
bool
putNew
(
KeyInput
&
&
k
ValueInput
&
&
v
)
{
return
map
(
)
.
putNew
(
std
:
:
forward
<
KeyInput
>
(
k
)
std
:
:
forward
<
ValueInput
>
(
v
)
)
;
}
}
;
}
namespace
JS
{
template
<
typename
T
typename
HashPolicy
=
js
:
:
DefaultHasher
<
T
>
typename
AllocPolicy
=
js
:
:
TempAllocPolicy
>
class
GCHashSet
:
public
js
:
:
HashSet
<
T
HashPolicy
AllocPolicy
>
{
using
Base
=
js
:
:
HashSet
<
T
HashPolicy
AllocPolicy
>
;
public
:
explicit
GCHashSet
(
AllocPolicy
a
=
AllocPolicy
(
)
)
:
Base
(
std
:
:
move
(
a
)
)
{
}
explicit
GCHashSet
(
size_t
length
)
:
Base
(
length
)
{
}
GCHashSet
(
AllocPolicy
a
size_t
length
)
:
Base
(
std
:
:
move
(
a
)
length
)
{
}
void
trace
(
JSTracer
*
trc
)
{
for
(
typename
Base
:
:
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
GCPolicy
<
T
>
:
:
trace
(
trc
&
e
.
mutableFront
(
)
"
hashset
element
"
)
;
}
}
bool
needsSweep
(
)
const
{
return
!
this
-
>
empty
(
)
;
}
void
sweep
(
)
{
for
(
typename
Base
:
:
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
if
(
GCPolicy
<
T
>
:
:
needsSweep
(
&
e
.
mutableFront
(
)
)
)
{
e
.
removeFront
(
)
;
}
}
}
void
traceWeak
(
JSTracer
*
trc
)
{
for
(
typename
Base
:
:
Enum
e
(
*
this
)
;
!
e
.
empty
(
)
;
e
.
popFront
(
)
)
{
if
(
!
GCPolicy
<
T
>
:
:
traceWeak
(
trc
&
e
.
mutableFront
(
)
)
)
{
e
.
removeFront
(
)
;
}
}
}
GCHashSet
(
GCHashSet
&
&
rhs
)
:
Base
(
std
:
:
move
(
rhs
)
)
{
}
void
operator
=
(
GCHashSet
&
&
rhs
)
{
MOZ_ASSERT
(
this
!
=
&
rhs
"
self
-
move
assignment
is
prohibited
"
)
;
Base
:
:
operator
=
(
std
:
:
move
(
rhs
)
)
;
}
private
:
GCHashSet
(
const
GCHashSet
&
hs
)
=
delete
;
GCHashSet
&
operator
=
(
const
GCHashSet
&
hs
)
=
delete
;
}
MOZ_INHERIT_TYPE_ANNOTATIONS_FROM_TEMPLATE_ARGS
;
}
namespace
js
{
template
<
typename
Wrapper
typename
.
.
.
Args
>
class
WrappedPtrOperations
<
JS
:
:
GCHashSet
<
Args
.
.
.
>
Wrapper
>
{
using
Set
=
JS
:
:
GCHashSet
<
Args
.
.
.
>
;
const
Set
&
set
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
using
Lookup
=
typename
Set
:
:
Lookup
;
using
AddPtr
=
typename
Set
:
:
AddPtr
;
using
Entry
=
typename
Set
:
:
Entry
;
using
Ptr
=
typename
Set
:
:
Ptr
;
using
Range
=
typename
Set
:
:
Range
;
Ptr
lookup
(
const
Lookup
&
l
)
const
{
return
set
(
)
.
lookup
(
l
)
;
}
Range
all
(
)
const
{
return
set
(
)
.
all
(
)
;
}
bool
empty
(
)
const
{
return
set
(
)
.
empty
(
)
;
}
uint32_t
count
(
)
const
{
return
set
(
)
.
count
(
)
;
}
size_t
capacity
(
)
const
{
return
set
(
)
.
capacity
(
)
;
}
bool
has
(
const
Lookup
&
l
)
const
{
return
set
(
)
.
lookup
(
l
)
.
found
(
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
set
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
set
(
)
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
}
;
template
<
typename
Wrapper
typename
.
.
.
Args
>
class
MutableWrappedPtrOperations
<
JS
:
:
GCHashSet
<
Args
.
.
.
>
Wrapper
>
:
public
WrappedPtrOperations
<
JS
:
:
GCHashSet
<
Args
.
.
.
>
Wrapper
>
{
using
Set
=
JS
:
:
GCHashSet
<
Args
.
.
.
>
;
using
Lookup
=
typename
Set
:
:
Lookup
;
Set
&
set
(
)
{
return
static_cast
<
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
using
AddPtr
=
typename
Set
:
:
AddPtr
;
using
Entry
=
typename
Set
:
:
Entry
;
struct
Enum
:
public
Set
:
:
Enum
{
explicit
Enum
(
Wrapper
&
o
)
:
Set
:
:
Enum
(
o
.
set
(
)
)
{
}
}
;
using
Ptr
=
typename
Set
:
:
Ptr
;
using
Range
=
typename
Set
:
:
Range
;
void
clear
(
)
{
set
(
)
.
clear
(
)
;
}
void
clearAndCompact
(
)
{
set
(
)
.
clearAndCompact
(
)
;
}
MOZ_MUST_USE
bool
reserve
(
uint32_t
len
)
{
return
set
(
)
.
reserve
(
len
)
;
}
void
remove
(
Ptr
p
)
{
set
(
)
.
remove
(
p
)
;
}
void
remove
(
const
Lookup
&
l
)
{
set
(
)
.
remove
(
l
)
;
}
AddPtr
lookupForAdd
(
const
Lookup
&
l
)
{
return
set
(
)
.
lookupForAdd
(
l
)
;
}
template
<
typename
TInput
>
bool
add
(
AddPtr
&
p
TInput
&
&
t
)
{
return
set
(
)
.
add
(
p
std
:
:
forward
<
TInput
>
(
t
)
)
;
}
template
<
typename
TInput
>
bool
relookupOrAdd
(
AddPtr
&
p
const
Lookup
&
l
TInput
&
&
t
)
{
return
set
(
)
.
relookupOrAdd
(
p
l
std
:
:
forward
<
TInput
>
(
t
)
)
;
}
template
<
typename
TInput
>
bool
put
(
TInput
&
&
t
)
{
return
set
(
)
.
put
(
std
:
:
forward
<
TInput
>
(
t
)
)
;
}
template
<
typename
TInput
>
bool
putNew
(
TInput
&
&
t
)
{
return
set
(
)
.
putNew
(
std
:
:
forward
<
TInput
>
(
t
)
)
;
}
template
<
typename
TInput
>
bool
putNew
(
const
Lookup
&
l
TInput
&
&
t
)
{
return
set
(
)
.
putNew
(
l
std
:
:
forward
<
TInput
>
(
t
)
)
;
}
}
;
}
namespace
JS
{
template
<
typename
Key
typename
Value
typename
HashPolicy
typename
AllocPolicy
typename
MapSweepPolicy
>
class
WeakCache
<
GCHashMap
<
Key
Value
HashPolicy
AllocPolicy
MapSweepPolicy
>
>
:
protected
detail
:
:
WeakCacheBase
{
using
Map
=
GCHashMap
<
Key
Value
HashPolicy
AllocPolicy
MapSweepPolicy
>
;
using
Self
=
WeakCache
<
Map
>
;
Map
map
;
bool
needsBarrier
;
public
:
template
<
typename
.
.
.
Args
>
explicit
WeakCache
(
Zone
*
zone
Args
&
&
.
.
.
args
)
:
WeakCacheBase
(
zone
)
map
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
needsBarrier
(
false
)
{
}
template
<
typename
.
.
.
Args
>
explicit
WeakCache
(
JSRuntime
*
rt
Args
&
&
.
.
.
args
)
:
WeakCacheBase
(
rt
)
map
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
needsBarrier
(
false
)
{
}
~
WeakCache
(
)
{
MOZ_ASSERT
(
!
needsBarrier
)
;
}
bool
needsSweep
(
)
override
{
return
map
.
needsSweep
(
)
;
}
size_t
sweep
(
)
override
{
size_t
steps
=
map
.
count
(
)
;
map
.
sweep
(
)
;
return
steps
;
}
bool
setNeedsIncrementalBarrier
(
bool
needs
)
override
{
MOZ_ASSERT
(
needsBarrier
!
=
needs
)
;
needsBarrier
=
needs
;
return
true
;
}
bool
needsIncrementalBarrier
(
)
const
override
{
return
needsBarrier
;
}
private
:
using
Entry
=
typename
Map
:
:
Entry
;
static
bool
entryNeedsSweep
(
const
Entry
&
prior
)
{
Key
key
(
prior
.
key
(
)
)
;
Value
value
(
prior
.
value
(
)
)
;
bool
result
=
MapSweepPolicy
:
:
needsSweep
(
&
key
&
value
)
;
MOZ_ASSERT
(
prior
.
key
(
)
=
=
key
)
;
MOZ_ASSERT
(
prior
.
value
(
)
=
=
value
)
;
return
result
;
}
public
:
using
Lookup
=
typename
Map
:
:
Lookup
;
using
Ptr
=
typename
Map
:
:
Ptr
;
using
AddPtr
=
typename
Map
:
:
AddPtr
;
struct
Range
{
explicit
Range
(
const
typename
Map
:
:
Range
&
r
)
:
range
(
r
)
{
settle
(
)
;
}
Range
(
)
{
}
bool
empty
(
)
const
{
return
range
.
empty
(
)
;
}
const
Entry
&
front
(
)
const
{
return
range
.
front
(
)
;
}
void
popFront
(
)
{
range
.
popFront
(
)
;
settle
(
)
;
}
private
:
typename
Map
:
:
Range
range
;
void
settle
(
)
{
while
(
!
empty
(
)
&
&
entryNeedsSweep
(
front
(
)
)
)
{
popFront
(
)
;
}
}
}
;
struct
Enum
:
public
Map
:
:
Enum
{
explicit
Enum
(
Self
&
cache
)
:
Map
:
:
Enum
(
cache
.
map
)
{
MOZ_ASSERT
(
!
cache
.
needsBarrier
)
;
}
}
;
Ptr
lookup
(
const
Lookup
&
l
)
const
{
Ptr
ptr
=
map
.
lookup
(
l
)
;
if
(
needsBarrier
&
&
ptr
&
&
entryNeedsSweep
(
*
ptr
)
)
{
const_cast
<
Map
&
>
(
map
)
.
remove
(
ptr
)
;
return
Ptr
(
)
;
}
return
ptr
;
}
AddPtr
lookupForAdd
(
const
Lookup
&
l
)
{
AddPtr
ptr
=
map
.
lookupForAdd
(
l
)
;
if
(
needsBarrier
&
&
ptr
&
&
entryNeedsSweep
(
*
ptr
)
)
{
const_cast
<
Map
&
>
(
map
)
.
remove
(
ptr
)
;
return
map
.
lookupForAdd
(
l
)
;
}
return
ptr
;
}
Range
all
(
)
const
{
return
Range
(
map
.
all
(
)
)
;
}
bool
empty
(
)
const
{
MOZ_ASSERT
(
!
needsBarrier
)
;
return
map
.
empty
(
)
;
}
uint32_t
count
(
)
const
{
MOZ_ASSERT
(
!
needsBarrier
)
;
return
map
.
count
(
)
;
}
size_t
capacity
(
)
const
{
return
map
.
capacity
(
)
;
}
bool
has
(
const
Lookup
&
l
)
const
{
return
lookup
(
l
)
.
found
(
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
map
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
map
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
}
void
clear
(
)
{
MOZ_ASSERT
(
!
needsBarrier
)
;
map
.
clear
(
)
;
}
void
clearAndCompact
(
)
{
MOZ_ASSERT
(
!
needsBarrier
)
;
map
.
clearAndCompact
(
)
;
}
void
remove
(
Ptr
p
)
{
map
.
remove
(
p
)
;
}
void
remove
(
const
Lookup
&
l
)
{
Ptr
p
=
lookup
(
l
)
;
if
(
p
)
{
remove
(
p
)
;
}
}
template
<
typename
KeyInput
typename
ValueInput
>
bool
add
(
AddPtr
&
p
KeyInput
&
&
k
ValueInput
&
&
v
)
{
return
map
.
add
(
p
std
:
:
forward
<
KeyInput
>
(
k
)
std
:
:
forward
<
ValueInput
>
(
v
)
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
bool
relookupOrAdd
(
AddPtr
&
p
KeyInput
&
&
k
ValueInput
&
&
v
)
{
return
map
.
relookupOrAdd
(
p
std
:
:
forward
<
KeyInput
>
(
k
)
std
:
:
forward
<
ValueInput
>
(
v
)
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
bool
put
(
KeyInput
&
&
k
ValueInput
&
&
v
)
{
return
map
.
put
(
std
:
:
forward
<
KeyInput
>
(
k
)
std
:
:
forward
<
ValueInput
>
(
v
)
)
;
}
template
<
typename
KeyInput
typename
ValueInput
>
bool
putNew
(
KeyInput
&
&
k
ValueInput
&
&
v
)
{
return
map
.
putNew
(
std
:
:
forward
<
KeyInput
>
(
k
)
std
:
:
forward
<
ValueInput
>
(
v
)
)
;
}
}
JS_HAZ_NON_GC_POINTER
;
template
<
typename
T
typename
HashPolicy
typename
AllocPolicy
>
class
WeakCache
<
GCHashSet
<
T
HashPolicy
AllocPolicy
>
>
:
protected
detail
:
:
WeakCacheBase
{
using
Set
=
GCHashSet
<
T
HashPolicy
AllocPolicy
>
;
using
Self
=
WeakCache
<
Set
>
;
Set
set
;
bool
needsBarrier
;
public
:
using
Entry
=
typename
Set
:
:
Entry
;
template
<
typename
.
.
.
Args
>
explicit
WeakCache
(
Zone
*
zone
Args
&
&
.
.
.
args
)
:
WeakCacheBase
(
zone
)
set
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
needsBarrier
(
false
)
{
}
template
<
typename
.
.
.
Args
>
explicit
WeakCache
(
JSRuntime
*
rt
Args
&
&
.
.
.
args
)
:
WeakCacheBase
(
rt
)
set
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
needsBarrier
(
false
)
{
}
size_t
sweep
(
)
override
{
size_t
steps
=
set
.
count
(
)
;
set
.
sweep
(
)
;
return
steps
;
}
bool
needsSweep
(
)
override
{
return
set
.
needsSweep
(
)
;
}
bool
setNeedsIncrementalBarrier
(
bool
needs
)
override
{
MOZ_ASSERT
(
needsBarrier
!
=
needs
)
;
needsBarrier
=
needs
;
return
true
;
}
bool
needsIncrementalBarrier
(
)
const
override
{
return
needsBarrier
;
}
private
:
static
bool
entryNeedsSweep
(
const
Entry
&
prior
)
{
Entry
entry
(
prior
)
;
bool
result
=
GCPolicy
<
T
>
:
:
needsSweep
(
&
entry
)
;
MOZ_ASSERT
(
prior
=
=
entry
)
;
return
result
;
}
public
:
using
Lookup
=
typename
Set
:
:
Lookup
;
using
Ptr
=
typename
Set
:
:
Ptr
;
using
AddPtr
=
typename
Set
:
:
AddPtr
;
struct
Range
{
explicit
Range
(
const
typename
Set
:
:
Range
&
r
)
:
range
(
r
)
{
settle
(
)
;
}
Range
(
)
{
}
bool
empty
(
)
const
{
return
range
.
empty
(
)
;
}
const
Entry
&
front
(
)
const
{
return
range
.
front
(
)
;
}
void
popFront
(
)
{
range
.
popFront
(
)
;
settle
(
)
;
}
private
:
typename
Set
:
:
Range
range
;
void
settle
(
)
{
while
(
!
empty
(
)
&
&
entryNeedsSweep
(
front
(
)
)
)
{
popFront
(
)
;
}
}
}
;
struct
Enum
:
public
Set
:
:
Enum
{
explicit
Enum
(
Self
&
cache
)
:
Set
:
:
Enum
(
cache
.
set
)
{
MOZ_ASSERT
(
!
cache
.
needsBarrier
)
;
}
}
;
Ptr
lookup
(
const
Lookup
&
l
)
const
{
Ptr
ptr
=
set
.
lookup
(
l
)
;
if
(
needsBarrier
&
&
ptr
&
&
entryNeedsSweep
(
*
ptr
)
)
{
const_cast
<
Set
&
>
(
set
)
.
remove
(
ptr
)
;
return
Ptr
(
)
;
}
return
ptr
;
}
AddPtr
lookupForAdd
(
const
Lookup
&
l
)
{
AddPtr
ptr
=
set
.
lookupForAdd
(
l
)
;
if
(
needsBarrier
&
&
ptr
&
&
entryNeedsSweep
(
*
ptr
)
)
{
const_cast
<
Set
&
>
(
set
)
.
remove
(
ptr
)
;
return
set
.
lookupForAdd
(
l
)
;
}
return
ptr
;
}
Range
all
(
)
const
{
return
Range
(
set
.
all
(
)
)
;
}
bool
empty
(
)
const
{
MOZ_ASSERT
(
!
needsBarrier
)
;
return
set
.
empty
(
)
;
}
uint32_t
count
(
)
const
{
MOZ_ASSERT
(
!
needsBarrier
)
;
return
set
.
count
(
)
;
}
size_t
capacity
(
)
const
{
return
set
.
capacity
(
)
;
}
bool
has
(
const
Lookup
&
l
)
const
{
return
lookup
(
l
)
.
found
(
)
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
set
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
set
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
}
void
clear
(
)
{
MOZ_ASSERT
(
!
needsBarrier
)
;
set
.
clear
(
)
;
}
void
clearAndCompact
(
)
{
MOZ_ASSERT
(
!
needsBarrier
)
;
set
.
clearAndCompact
(
)
;
}
void
remove
(
Ptr
p
)
{
set
.
remove
(
p
)
;
}
void
remove
(
const
Lookup
&
l
)
{
Ptr
p
=
lookup
(
l
)
;
if
(
p
)
{
remove
(
p
)
;
}
}
template
<
typename
TInput
>
bool
add
(
AddPtr
&
p
TInput
&
&
t
)
{
return
set
.
add
(
p
std
:
:
forward
<
TInput
>
(
t
)
)
;
}
template
<
typename
TInput
>
bool
relookupOrAdd
(
AddPtr
&
p
const
Lookup
&
l
TInput
&
&
t
)
{
return
set
.
relookupOrAdd
(
p
l
std
:
:
forward
<
TInput
>
(
t
)
)
;
}
template
<
typename
TInput
>
bool
put
(
TInput
&
&
t
)
{
return
set
.
put
(
std
:
:
forward
<
TInput
>
(
t
)
)
;
}
template
<
typename
TInput
>
bool
putNew
(
TInput
&
&
t
)
{
return
set
.
putNew
(
std
:
:
forward
<
TInput
>
(
t
)
)
;
}
template
<
typename
TInput
>
bool
putNew
(
const
Lookup
&
l
TInput
&
&
t
)
{
return
set
.
putNew
(
l
std
:
:
forward
<
TInput
>
(
t
)
)
;
}
}
JS_HAZ_NON_GC_POINTER
;
}
#
endif
