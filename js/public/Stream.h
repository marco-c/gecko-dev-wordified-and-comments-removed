#
ifndef
js_Stream_h
#
define
js_Stream_h
#
include
<
stddef
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
JS
{
class
JS_PUBLIC_API
ReadableStreamUnderlyingSource
{
public
:
virtual
~
ReadableStreamUnderlyingSource
(
)
{
}
virtual
void
requestData
(
JSContext
*
cx
HandleObject
stream
size_t
desiredSize
)
=
0
;
virtual
void
writeIntoReadRequestBuffer
(
JSContext
*
cx
HandleObject
stream
void
*
buffer
size_t
length
size_t
*
bytesWritten
)
=
0
;
virtual
Value
cancel
(
JSContext
*
cx
HandleObject
stream
HandleValue
reason
)
=
0
;
virtual
void
onClosed
(
JSContext
*
cx
HandleObject
stream
)
=
0
;
virtual
void
onErrored
(
JSContext
*
cx
HandleObject
stream
HandleValue
reason
)
=
0
;
virtual
void
finalize
(
)
=
0
;
}
;
extern
JS_PUBLIC_API
JSObject
*
NewReadableDefaultStreamObject
(
JSContext
*
cx
HandleObject
underlyingSource
=
nullptr
HandleFunction
size
=
nullptr
double
highWaterMark
=
1
HandleObject
proto
=
nullptr
)
;
extern
JS_PUBLIC_API
JSObject
*
NewReadableExternalSourceStreamObject
(
JSContext
*
cx
ReadableStreamUnderlyingSource
*
underlyingSource
void
*
nsISupportsObject_alreadyAddreffed
=
nullptr
HandleObject
proto
=
nullptr
)
;
extern
JS_PUBLIC_API
bool
ReadableStreamGetExternalUnderlyingSource
(
JSContext
*
cx
HandleObject
stream
ReadableStreamUnderlyingSource
*
*
source
)
;
extern
JS_PUBLIC_API
bool
ReadableStreamReleaseExternalUnderlyingSource
(
JSContext
*
cx
HandleObject
stream
)
;
extern
JS_PUBLIC_API
bool
ReadableStreamUpdateDataAvailableFromSource
(
JSContext
*
cx
HandleObject
stream
uint32_t
availableData
)
;
extern
JS_PUBLIC_API
void
ReadableStreamReleaseCCObject
(
JSObject
*
stream
)
;
extern
JS_PUBLIC_API
bool
IsReadableStream
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
bool
IsReadableStreamReader
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
bool
IsReadableStreamDefaultReader
(
JSObject
*
obj
)
;
enum
class
ReadableStreamMode
{
Default
Byte
ExternalSource
}
;
extern
JS_PUBLIC_API
bool
ReadableStreamGetMode
(
JSContext
*
cx
HandleObject
stream
ReadableStreamMode
*
mode
)
;
enum
class
ReadableStreamReaderMode
{
Default
}
;
extern
JS_PUBLIC_API
bool
ReadableStreamIsReadable
(
JSContext
*
cx
HandleObject
stream
bool
*
result
)
;
extern
JS_PUBLIC_API
bool
ReadableStreamIsLocked
(
JSContext
*
cx
HandleObject
stream
bool
*
result
)
;
extern
JS_PUBLIC_API
bool
ReadableStreamIsDisturbed
(
JSContext
*
cx
HandleObject
stream
bool
*
result
)
;
extern
JS_PUBLIC_API
JSObject
*
ReadableStreamCancel
(
JSContext
*
cx
HandleObject
stream
HandleValue
reason
)
;
extern
JS_PUBLIC_API
JSObject
*
ReadableStreamGetReader
(
JSContext
*
cx
HandleObject
stream
ReadableStreamReaderMode
mode
)
;
extern
JS_PUBLIC_API
bool
ReadableStreamTee
(
JSContext
*
cx
HandleObject
stream
MutableHandleObject
branch1Stream
MutableHandleObject
branch2Stream
)
;
extern
JS_PUBLIC_API
bool
ReadableStreamGetDesiredSize
(
JSContext
*
cx
JSObject
*
stream
bool
*
hasValue
double
*
value
)
;
extern
JS_PUBLIC_API
bool
ReadableStreamClose
(
JSContext
*
cx
HandleObject
stream
)
;
extern
JS_PUBLIC_API
bool
ReadableStreamReaderIsClosed
(
JSContext
*
cx
HandleObject
reader
bool
*
result
)
;
extern
JS_PUBLIC_API
bool
ReadableStreamEnqueue
(
JSContext
*
cx
HandleObject
stream
HandleValue
chunk
)
;
extern
JS_PUBLIC_API
bool
ReadableStreamError
(
JSContext
*
cx
HandleObject
stream
HandleValue
error
)
;
extern
JS_PUBLIC_API
bool
ReadableStreamReaderCancel
(
JSContext
*
cx
HandleObject
reader
HandleValue
reason
)
;
extern
JS_PUBLIC_API
bool
ReadableStreamReaderReleaseLock
(
JSContext
*
cx
HandleObject
reader
)
;
extern
JS_PUBLIC_API
JSObject
*
ReadableStreamDefaultReaderRead
(
JSContext
*
cx
HandleObject
reader
)
;
}
#
endif
