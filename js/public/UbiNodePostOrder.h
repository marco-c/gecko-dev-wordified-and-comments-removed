#
ifndef
js_UbiNodePostOrder_h
#
define
js_UbiNodePostOrder_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
js
/
Vector
.
h
"
namespace
JS
{
namespace
ubi
{
struct
PostOrder
{
private
:
struct
OriginAndEdges
{
Node
origin
;
EdgeVector
edges
;
OriginAndEdges
(
const
Node
&
node
EdgeVector
&
&
edges
)
:
origin
(
node
)
edges
(
std
:
:
move
(
edges
)
)
{
}
OriginAndEdges
(
const
OriginAndEdges
&
rhs
)
=
delete
;
OriginAndEdges
&
operator
=
(
const
OriginAndEdges
&
rhs
)
=
delete
;
OriginAndEdges
(
OriginAndEdges
&
&
rhs
)
:
origin
(
rhs
.
origin
)
edges
(
std
:
:
move
(
rhs
.
edges
)
)
{
MOZ_ASSERT
(
&
rhs
!
=
this
"
self
-
move
disallowed
"
)
;
}
OriginAndEdges
&
operator
=
(
OriginAndEdges
&
&
rhs
)
{
this
-
>
~
OriginAndEdges
(
)
;
new
(
this
)
OriginAndEdges
(
std
:
:
move
(
rhs
)
)
;
return
*
this
;
}
}
;
using
Stack
=
js
:
:
Vector
<
OriginAndEdges
256
js
:
:
SystemAllocPolicy
>
;
using
Set
=
js
:
:
HashSet
<
Node
js
:
:
DefaultHasher
<
Node
>
js
:
:
SystemAllocPolicy
>
;
JSContext
*
cx
;
Set
seen
;
Stack
stack
;
#
ifdef
DEBUG
bool
traversed
;
#
endif
private
:
MOZ_MUST_USE
bool
fillEdgesFromRange
(
EdgeVector
&
edges
js
:
:
UniquePtr
<
EdgeRange
>
&
range
)
{
MOZ_ASSERT
(
range
)
;
for
(
;
!
range
-
>
empty
(
)
;
range
-
>
popFront
(
)
)
{
if
(
!
edges
.
append
(
std
:
:
move
(
range
-
>
front
(
)
)
)
)
return
false
;
}
return
true
;
}
MOZ_MUST_USE
bool
pushForTraversing
(
const
Node
&
node
)
{
EdgeVector
edges
;
auto
range
=
node
.
edges
(
cx
false
)
;
return
range
&
&
fillEdgesFromRange
(
edges
range
)
&
&
stack
.
append
(
OriginAndEdges
(
node
std
:
:
move
(
edges
)
)
)
;
}
public
:
PostOrder
(
JSContext
*
cx
AutoCheckCannotGC
&
)
:
cx
(
cx
)
seen
(
)
stack
(
)
#
ifdef
DEBUG
traversed
(
false
)
#
endif
{
}
MOZ_MUST_USE
bool
init
(
)
{
return
seen
.
init
(
)
;
}
MOZ_MUST_USE
bool
addStart
(
const
Node
&
node
)
{
if
(
!
seen
.
put
(
node
)
)
return
false
;
return
pushForTraversing
(
node
)
;
}
template
<
typename
NodeVisitor
typename
EdgeVisitor
>
MOZ_MUST_USE
bool
traverse
(
NodeVisitor
onNode
EdgeVisitor
onEdge
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
traversed
"
Can
only
traverse
(
)
once
!
"
)
;
traversed
=
true
;
#
endif
while
(
!
stack
.
empty
(
)
)
{
auto
&
origin
=
stack
.
back
(
)
.
origin
;
auto
&
edges
=
stack
.
back
(
)
.
edges
;
if
(
edges
.
empty
(
)
)
{
if
(
!
onNode
(
origin
)
)
return
false
;
stack
.
popBack
(
)
;
continue
;
}
Edge
edge
=
std
:
:
move
(
edges
.
back
(
)
)
;
edges
.
popBack
(
)
;
if
(
!
onEdge
(
origin
edge
)
)
return
false
;
auto
ptr
=
seen
.
lookupForAdd
(
edge
.
referent
)
;
if
(
ptr
)
continue
;
if
(
!
seen
.
add
(
ptr
edge
.
referent
)
|
|
!
pushForTraversing
(
edge
.
referent
)
)
{
return
false
;
}
}
return
true
;
}
}
;
}
}
#
endif
