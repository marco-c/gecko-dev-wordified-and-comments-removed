#
ifndef
js_ColumnNumber_h
#
define
js_ColumnNumber_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
limits
>
#
include
<
stdint
.
h
>
namespace
JS
{
struct
WasmFunctionIndex
{
static
constexpr
uint32_t
Limit
=
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
/
2
;
static
constexpr
uint32_t
DefaultBinarySourceColumnNumberZeroOrigin
=
0
;
static
constexpr
uint32_t
DefaultBinarySourceColumnNumberOneOrigin
=
1
;
private
:
uint32_t
value_
=
0
;
public
:
constexpr
WasmFunctionIndex
(
)
=
default
;
constexpr
WasmFunctionIndex
(
const
WasmFunctionIndex
&
other
)
=
default
;
inline
explicit
WasmFunctionIndex
(
uint32_t
value
)
:
value_
(
value
)
{
MOZ_ASSERT
(
valid
(
)
)
;
}
uint32_t
value
(
)
const
{
return
value_
;
}
bool
valid
(
)
const
{
return
value_
<
=
Limit
;
}
}
;
struct
ColumnNumberOffset
{
private
:
int32_t
value_
=
0
;
public
:
constexpr
ColumnNumberOffset
(
)
=
default
;
constexpr
ColumnNumberOffset
(
const
ColumnNumberOffset
&
other
)
=
default
;
inline
explicit
ColumnNumberOffset
(
int32_t
value
)
:
value_
(
value
)
{
}
static
constexpr
ColumnNumberOffset
zero
(
)
{
return
ColumnNumberOffset
(
)
;
}
bool
operator
=
=
(
const
ColumnNumberOffset
&
rhs
)
const
{
return
value_
=
=
rhs
.
value_
;
}
bool
operator
!
=
(
const
ColumnNumberOffset
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
int32_t
value
(
)
const
{
return
value_
;
}
}
;
namespace
detail
{
template
<
typename
T
>
struct
TaggedColumnNumberWithOrigin
;
template
<
uint32_t
Origin
uint32_t
LimitValue
=
0
>
struct
ColumnNumberWithOrigin
{
static_assert
(
Origin
=
=
0
|
|
Origin
=
=
1
)
;
protected
:
uint32_t
value_
=
Origin
;
template
<
typename
T
>
friend
struct
TaggedColumnNumberWithOrigin
;
public
:
constexpr
ColumnNumberWithOrigin
(
)
=
default
;
ColumnNumberWithOrigin
(
const
ColumnNumberWithOrigin
&
other
)
=
default
;
ColumnNumberWithOrigin
&
operator
=
(
const
ColumnNumberWithOrigin
&
other
)
=
default
;
explicit
ColumnNumberWithOrigin
(
uint32_t
value
)
:
value_
(
value
)
{
MOZ_ASSERT
(
valid
(
)
)
;
}
static
constexpr
ColumnNumberWithOrigin
<
Origin
LimitValue
>
zero
(
)
{
return
ColumnNumberWithOrigin
<
Origin
LimitValue
>
(
)
;
}
bool
operator
=
=
(
const
ColumnNumberWithOrigin
<
Origin
LimitValue
>
&
rhs
)
const
{
return
value_
=
=
rhs
.
value_
;
}
bool
operator
!
=
(
const
ColumnNumberWithOrigin
<
Origin
LimitValue
>
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
ColumnNumberWithOrigin
<
Origin
LimitValue
>
operator
+
(
const
ColumnNumberOffset
&
offset
)
const
{
MOZ_ASSERT
(
valid
(
)
)
;
MOZ_ASSERT
(
ptrdiff_t
(
value_
)
+
offset
.
value
(
)
>
=
0
)
;
return
ColumnNumberWithOrigin
<
Origin
LimitValue
>
(
value_
+
offset
.
value
(
)
)
;
}
ColumnNumberWithOrigin
<
Origin
LimitValue
>
operator
-
(
const
ColumnNumberOffset
&
offset
)
const
{
MOZ_ASSERT
(
valid
(
)
)
;
MOZ_ASSERT
(
ptrdiff_t
(
value_
)
-
offset
.
value
(
)
>
=
0
)
;
return
ColumnNumberWithOrigin
<
Origin
LimitValue
>
(
value_
-
offset
.
value
(
)
)
;
}
ColumnNumberOffset
operator
-
(
const
ColumnNumberWithOrigin
<
Origin
LimitValue
>
&
other
)
const
{
MOZ_ASSERT
(
valid
(
)
)
;
return
ColumnNumberOffset
(
int32_t
(
value_
)
-
int32_t
(
other
.
value_
)
)
;
}
ColumnNumberWithOrigin
<
Origin
LimitValue
>
&
operator
+
=
(
const
ColumnNumberOffset
&
offset
)
{
MOZ_ASSERT
(
valid
(
)
)
;
MOZ_ASSERT
(
ptrdiff_t
(
value_
)
+
offset
.
value
(
)
>
=
0
)
;
value_
+
=
offset
.
value
(
)
;
MOZ_ASSERT
(
valid
(
)
)
;
return
*
this
;
}
ColumnNumberWithOrigin
<
Origin
LimitValue
>
&
operator
-
=
(
const
ColumnNumberOffset
&
offset
)
{
MOZ_ASSERT
(
valid
(
)
)
;
MOZ_ASSERT
(
ptrdiff_t
(
value_
)
-
offset
.
value
(
)
>
=
0
)
;
value_
-
=
offset
.
value
(
)
;
MOZ_ASSERT
(
valid
(
)
)
;
return
*
this
;
}
bool
operator
<
(
const
ColumnNumberWithOrigin
<
Origin
LimitValue
>
&
rhs
)
const
{
MOZ_ASSERT
(
valid
(
)
)
;
MOZ_ASSERT
(
rhs
.
valid
(
)
)
;
return
value_
<
rhs
.
value_
;
}
bool
operator
<
=
(
const
ColumnNumberWithOrigin
<
Origin
LimitValue
>
&
rhs
)
const
{
MOZ_ASSERT
(
valid
(
)
)
;
MOZ_ASSERT
(
rhs
.
valid
(
)
)
;
return
value_
<
=
rhs
.
value_
;
}
bool
operator
>
(
const
ColumnNumberWithOrigin
<
Origin
LimitValue
>
&
rhs
)
const
{
MOZ_ASSERT
(
valid
(
)
)
;
MOZ_ASSERT
(
rhs
.
valid
(
)
)
;
return
value_
>
rhs
.
value_
;
}
bool
operator
>
=
(
const
ColumnNumberWithOrigin
<
Origin
LimitValue
>
&
rhs
)
const
{
MOZ_ASSERT
(
valid
(
)
)
;
MOZ_ASSERT
(
rhs
.
valid
(
)
)
;
return
value_
>
=
rhs
.
value_
;
}
uint32_t
zeroOriginValue
(
)
const
{
MOZ_ASSERT
(
valid
(
)
)
;
if
constexpr
(
Origin
=
=
0
)
{
return
value_
;
}
if
(
value_
=
=
0
)
{
return
0
;
}
return
value_
-
1
;
}
uint32_t
oneOriginValue
(
)
const
{
MOZ_ASSERT
(
valid
(
)
)
;
if
constexpr
(
Origin
=
=
0
)
{
return
value_
+
1
;
}
return
value_
;
}
uint32_t
*
addressOfValueForTranscode
(
)
{
return
&
value_
;
}
bool
valid
(
)
const
{
if
constexpr
(
LimitValue
=
=
0
)
{
return
true
;
}
return
value_
<
=
LimitValue
;
}
}
;
static
constexpr
uint32_t
ColumnNumberZeroOriginLimit
=
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
/
2
-
1
;
static
constexpr
uint32_t
ColumnNumberOneOriginLimit
=
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
/
2
;
}
struct
LimitedColumnNumberZeroOrigin
:
public
detail
:
:
ColumnNumberWithOrigin
<
0
detail
:
:
ColumnNumberZeroOriginLimit
>
{
private
:
using
Base
=
detail
:
:
ColumnNumberWithOrigin
<
0
detail
:
:
ColumnNumberZeroOriginLimit
>
;
public
:
static
constexpr
uint32_t
Limit
=
detail
:
:
ColumnNumberZeroOriginLimit
;
static_assert
(
uint32_t
(
Limit
+
Limit
)
>
Limit
"
Adding
Limit
should
not
overflow
"
)
;
using
Base
:
:
Base
;
LimitedColumnNumberZeroOrigin
(
)
=
default
;
LimitedColumnNumberZeroOrigin
(
const
LimitedColumnNumberZeroOrigin
&
other
)
=
default
;
MOZ_IMPLICIT
LimitedColumnNumberZeroOrigin
(
const
Base
&
other
)
:
Base
(
other
)
{
}
explicit
LimitedColumnNumberZeroOrigin
(
const
detail
:
:
ColumnNumberWithOrigin
<
1
detail
:
:
ColumnNumberOneOriginLimit
>
&
other
)
:
Base
(
other
.
zeroOriginValue
(
)
)
{
}
static
LimitedColumnNumberZeroOrigin
limit
(
)
{
return
LimitedColumnNumberZeroOrigin
(
Limit
)
;
}
static
LimitedColumnNumberZeroOrigin
fromUnlimited
(
uint32_t
value
)
{
if
(
value
>
Limit
)
{
return
LimitedColumnNumberZeroOrigin
(
Limit
)
;
}
return
LimitedColumnNumberZeroOrigin
(
value
)
;
}
static
LimitedColumnNumberZeroOrigin
fromUnlimited
(
const
ColumnNumberWithOrigin
<
0
0
>
&
value
)
{
return
fromUnlimited
(
value
.
zeroOriginValue
(
)
)
;
}
}
;
struct
LimitedColumnNumberOneOrigin
:
public
detail
:
:
ColumnNumberWithOrigin
<
1
detail
:
:
ColumnNumberOneOriginLimit
>
{
private
:
using
Base
=
detail
:
:
ColumnNumberWithOrigin
<
1
detail
:
:
ColumnNumberOneOriginLimit
>
;
public
:
static
constexpr
uint32_t
Limit
=
detail
:
:
ColumnNumberOneOriginLimit
;
static_assert
(
uint32_t
(
Limit
+
Limit
)
>
Limit
"
Adding
Limit
should
not
overflow
"
)
;
using
Base
:
:
Base
;
LimitedColumnNumberOneOrigin
(
)
=
default
;
LimitedColumnNumberOneOrigin
(
const
LimitedColumnNumberOneOrigin
&
other
)
=
default
;
MOZ_IMPLICIT
LimitedColumnNumberOneOrigin
(
const
Base
&
other
)
:
Base
(
other
)
{
}
explicit
LimitedColumnNumberOneOrigin
(
const
detail
:
:
ColumnNumberWithOrigin
<
0
detail
:
:
ColumnNumberZeroOriginLimit
>
&
other
)
:
Base
(
other
.
oneOriginValue
(
)
)
{
}
static
LimitedColumnNumberOneOrigin
limit
(
)
{
return
LimitedColumnNumberOneOrigin
(
Limit
)
;
}
static
LimitedColumnNumberOneOrigin
fromUnlimited
(
uint32_t
value
)
{
if
(
value
>
Limit
)
{
return
LimitedColumnNumberOneOrigin
(
Limit
)
;
}
return
LimitedColumnNumberOneOrigin
(
value
)
;
}
static
LimitedColumnNumberOneOrigin
fromUnlimited
(
const
ColumnNumberWithOrigin
<
1
0
>
&
value
)
{
return
fromUnlimited
(
value
.
oneOriginValue
(
)
)
;
}
}
;
struct
ColumnNumberZeroOrigin
:
public
detail
:
:
ColumnNumberWithOrigin
<
0
>
{
private
:
using
Base
=
detail
:
:
ColumnNumberWithOrigin
<
0
>
;
public
:
using
Base
:
:
Base
;
using
Base
:
:
operator
=
;
ColumnNumberZeroOrigin
(
)
=
default
;
ColumnNumberZeroOrigin
(
const
ColumnNumberZeroOrigin
&
other
)
=
default
;
ColumnNumberZeroOrigin
&
operator
=
(
ColumnNumberZeroOrigin
&
)
=
default
;
MOZ_IMPLICIT
ColumnNumberZeroOrigin
(
const
Base
&
other
)
:
Base
(
other
)
{
}
explicit
ColumnNumberZeroOrigin
(
const
detail
:
:
ColumnNumberWithOrigin
<
1
>
&
other
)
:
Base
(
other
.
zeroOriginValue
(
)
)
{
}
explicit
ColumnNumberZeroOrigin
(
const
LimitedColumnNumberZeroOrigin
&
other
)
:
Base
(
other
.
zeroOriginValue
(
)
)
{
}
explicit
ColumnNumberZeroOrigin
(
const
LimitedColumnNumberOneOrigin
&
other
)
:
Base
(
other
.
zeroOriginValue
(
)
)
{
}
}
;
struct
ColumnNumberOneOrigin
:
public
detail
:
:
ColumnNumberWithOrigin
<
1
>
{
private
:
using
Base
=
detail
:
:
ColumnNumberWithOrigin
<
1
>
;
public
:
using
Base
:
:
Base
;
using
Base
:
:
operator
=
;
ColumnNumberOneOrigin
(
)
=
default
;
ColumnNumberOneOrigin
(
const
ColumnNumberOneOrigin
&
other
)
=
default
;
ColumnNumberOneOrigin
&
operator
=
(
ColumnNumberOneOrigin
&
)
=
default
;
MOZ_IMPLICIT
ColumnNumberOneOrigin
(
const
Base
&
other
)
:
Base
(
other
)
{
}
explicit
ColumnNumberOneOrigin
(
const
detail
:
:
ColumnNumberWithOrigin
<
0
>
&
other
)
:
Base
(
other
.
oneOriginValue
(
)
)
{
}
explicit
ColumnNumberOneOrigin
(
const
LimitedColumnNumberZeroOrigin
&
other
)
:
Base
(
other
.
oneOriginValue
(
)
)
{
}
explicit
ColumnNumberOneOrigin
(
const
LimitedColumnNumberOneOrigin
&
other
)
:
Base
(
other
.
oneOriginValue
(
)
)
{
}
}
;
namespace
detail
{
template
<
typename
LimitedColumnNumberT
>
struct
TaggedColumnNumberWithOrigin
{
static
constexpr
uint32_t
WasmFunctionTag
=
1u
<
<
31
;
static_assert
(
(
WasmFunctionIndex
:
:
Limit
&
WasmFunctionTag
)
=
=
0
)
;
static_assert
(
(
LimitedColumnNumberT
:
:
Limit
&
WasmFunctionTag
)
=
=
0
)
;
protected
:
uint32_t
value_
=
0
;
explicit
TaggedColumnNumberWithOrigin
(
uint32_t
value
)
:
value_
(
value
)
{
}
public
:
constexpr
TaggedColumnNumberWithOrigin
(
)
=
default
;
TaggedColumnNumberWithOrigin
(
const
TaggedColumnNumberWithOrigin
<
LimitedColumnNumberT
>
&
other
)
=
default
;
explicit
TaggedColumnNumberWithOrigin
(
const
LimitedColumnNumberT
&
other
)
:
value_
(
other
.
value_
)
{
MOZ_ASSERT
(
isLimitedColumnNumber
(
)
)
;
}
explicit
TaggedColumnNumberWithOrigin
(
const
WasmFunctionIndex
&
other
)
:
value_
(
other
.
value
(
)
|
WasmFunctionTag
)
{
MOZ_ASSERT
(
isWasmFunctionIndex
(
)
)
;
}
static
TaggedColumnNumberWithOrigin
<
LimitedColumnNumberT
>
fromRaw
(
uint32_t
value
)
{
return
TaggedColumnNumberWithOrigin
<
LimitedColumnNumberT
>
(
value
)
;
}
bool
operator
=
=
(
const
TaggedColumnNumberWithOrigin
<
LimitedColumnNumberT
>
&
rhs
)
const
{
return
value_
=
=
rhs
.
value_
;
}
bool
operator
!
=
(
const
TaggedColumnNumberWithOrigin
<
LimitedColumnNumberT
>
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
isLimitedColumnNumber
(
)
const
{
return
!
isWasmFunctionIndex
(
)
;
}
bool
isWasmFunctionIndex
(
)
const
{
return
!
!
(
value_
&
WasmFunctionTag
)
;
}
LimitedColumnNumberT
toLimitedColumnNumber
(
)
const
{
MOZ_ASSERT
(
isLimitedColumnNumber
(
)
)
;
return
LimitedColumnNumberT
(
value_
)
;
}
WasmFunctionIndex
toWasmFunctionIndex
(
)
const
{
MOZ_ASSERT
(
isWasmFunctionIndex
(
)
)
;
return
WasmFunctionIndex
(
value_
&
~
WasmFunctionTag
)
;
}
uint32_t
zeroOriginValue
(
)
const
{
return
isWasmFunctionIndex
(
)
?
WasmFunctionIndex
:
:
DefaultBinarySourceColumnNumberZeroOrigin
:
toLimitedColumnNumber
(
)
.
zeroOriginValue
(
)
;
}
uint32_t
oneOriginValue
(
)
const
{
return
isWasmFunctionIndex
(
)
?
WasmFunctionIndex
:
:
DefaultBinarySourceColumnNumberOneOrigin
:
toLimitedColumnNumber
(
)
.
oneOriginValue
(
)
;
}
uint32_t
rawValue
(
)
const
{
return
value_
;
}
uint32_t
*
addressOfValueForTranscode
(
)
{
return
&
value_
;
}
}
;
}
class
TaggedColumnNumberZeroOrigin
:
public
detail
:
:
TaggedColumnNumberWithOrigin
<
LimitedColumnNumberZeroOrigin
>
{
private
:
using
Base
=
detail
:
:
TaggedColumnNumberWithOrigin
<
LimitedColumnNumberZeroOrigin
>
;
public
:
using
Base
:
:
Base
;
using
Base
:
:
WasmFunctionTag
;
TaggedColumnNumberZeroOrigin
(
)
=
default
;
TaggedColumnNumberZeroOrigin
(
const
TaggedColumnNumberZeroOrigin
&
other
)
=
default
;
MOZ_IMPLICIT
TaggedColumnNumberZeroOrigin
(
const
Base
&
other
)
:
Base
(
other
)
{
}
explicit
TaggedColumnNumberZeroOrigin
(
const
detail
:
:
TaggedColumnNumberWithOrigin
<
LimitedColumnNumberOneOrigin
>
&
other
)
:
Base
(
other
.
isWasmFunctionIndex
(
)
?
other
.
rawValue
(
)
:
other
.
zeroOriginValue
(
)
)
{
}
}
;
class
TaggedColumnNumberOneOrigin
:
public
detail
:
:
TaggedColumnNumberWithOrigin
<
LimitedColumnNumberOneOrigin
>
{
private
:
using
Base
=
detail
:
:
TaggedColumnNumberWithOrigin
<
LimitedColumnNumberOneOrigin
>
;
public
:
using
Base
:
:
Base
;
using
Base
:
:
WasmFunctionTag
;
TaggedColumnNumberOneOrigin
(
)
=
default
;
TaggedColumnNumberOneOrigin
(
const
TaggedColumnNumberOneOrigin
&
other
)
=
default
;
MOZ_IMPLICIT
TaggedColumnNumberOneOrigin
(
const
Base
&
other
)
:
Base
(
other
)
{
}
explicit
TaggedColumnNumberOneOrigin
(
const
detail
:
:
TaggedColumnNumberWithOrigin
<
LimitedColumnNumberZeroOrigin
>
&
other
)
:
Base
(
other
.
isWasmFunctionIndex
(
)
?
other
.
rawValue
(
)
:
other
.
oneOriginValue
(
)
)
{
}
static
TaggedColumnNumberOneOrigin
forDifferentialTesting
(
)
{
return
TaggedColumnNumberOneOrigin
(
LimitedColumnNumberOneOrigin
(
0
)
)
;
}
}
;
}
#
endif
