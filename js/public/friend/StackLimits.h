#
ifndef
js_friend_StackLimits_h
#
define
js_friend_StackLimits_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Utility
.
h
"
struct
JS_PUBLIC_API
JSContext
;
#
ifndef
JS_STACK_GROWTH_DIRECTION
#
ifdef
__hppa
#
define
JS_STACK_GROWTH_DIRECTION
(
1
)
#
else
#
define
JS_STACK_GROWTH_DIRECTION
(
-
1
)
#
endif
#
endif
#
if
JS_STACK_GROWTH_DIRECTION
>
0
#
define
JS_CHECK_STACK_SIZE
(
limit
sp
)
(
MOZ_LIKELY
(
(
uintptr_t
)
(
sp
)
<
(
limit
)
)
)
#
else
#
define
JS_CHECK_STACK_SIZE
(
limit
sp
)
(
MOZ_LIKELY
(
(
uintptr_t
)
(
sp
)
>
(
limit
)
)
)
#
endif
namespace
js
{
namespace
detail
{
extern
JS_FRIEND_API
bool
RunningWithTrustedPrincipals
(
JSContext
*
cx
)
;
MOZ_ALWAYS_INLINE
uintptr_t
GetNativeStackLimitHelper
(
JSContext
*
cx
JS
:
:
StackKind
kind
int
extraAllowance
)
{
uintptr_t
limit
=
JS
:
:
RootingContext
:
:
get
(
cx
)
-
>
nativeStackLimit
[
kind
]
;
#
if
JS_STACK_GROWTH_DIRECTION
>
0
limit
+
=
extraAllowance
;
#
else
limit
-
=
extraAllowance
;
#
endif
return
limit
;
}
}
class
MOZ_RAII
AutoCheckRecursionLimit
{
public
:
explicit
MOZ_ALWAYS_INLINE
AutoCheckRecursionLimit
(
JSContext
*
cx
)
{
}
AutoCheckRecursionLimit
(
const
AutoCheckRecursionLimit
&
)
=
delete
;
void
operator
=
(
const
AutoCheckRecursionLimit
&
)
=
delete
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
check
(
JSContext
*
cx
)
const
;
}
;
extern
MOZ_COLD
JS_FRIEND_API
void
ReportOverRecursed
(
JSContext
*
maybecx
)
;
MOZ_ALWAYS_INLINE
uintptr_t
GetNativeStackLimit
(
JSContext
*
cx
)
{
JS
:
:
StackKind
kind
=
detail
:
:
RunningWithTrustedPrincipals
(
cx
)
?
JS
:
:
StackForTrustedScript
:
JS
:
:
StackForUntrustedScript
;
return
detail
:
:
GetNativeStackLimitHelper
(
cx
kind
0
)
;
}
MOZ_ALWAYS_INLINE
bool
CheckRecursionLimit
(
JSContext
*
cx
uintptr_t
limit
)
{
int
stackDummy
;
JS_STACK_OOM_POSSIBLY_FAIL_REPORT
(
)
;
if
(
!
JS_CHECK_STACK_SIZE
(
limit
&
stackDummy
)
)
{
ReportOverRecursed
(
cx
)
;
return
false
;
}
return
true
;
}
MOZ_ALWAYS_INLINE
bool
CheckRecursionLimitDontReport
(
uintptr_t
limit
)
{
int
stackDummy
;
JS_STACK_OOM_POSSIBLY_FAIL
(
)
;
return
JS_CHECK_STACK_SIZE
(
limit
&
stackDummy
)
;
}
MOZ_ALWAYS_INLINE
bool
AutoCheckRecursionLimit
:
:
check
(
JSContext
*
cx
)
const
{
JS_STACK_OOM_POSSIBLY_FAIL_REPORT
(
)
;
uintptr_t
untrustedLimit
=
detail
:
:
GetNativeStackLimitHelper
(
cx
JS
:
:
StackForUntrustedScript
0
)
;
if
(
MOZ_LIKELY
(
CheckRecursionLimitDontReport
(
untrustedLimit
)
)
)
{
return
true
;
}
return
CheckRecursionLimit
(
cx
GetNativeStackLimit
(
cx
)
)
;
}
MOZ_ALWAYS_INLINE
bool
CheckRecursionLimitDontReport
(
JSContext
*
cx
)
{
return
CheckRecursionLimitDontReport
(
GetNativeStackLimit
(
cx
)
)
;
}
MOZ_ALWAYS_INLINE
bool
CheckRecursionLimitWithStackPointerDontReport
(
JSContext
*
cx
void
*
sp
)
{
JS_STACK_OOM_POSSIBLY_FAIL
(
)
;
return
JS_CHECK_STACK_SIZE
(
GetNativeStackLimit
(
cx
)
sp
)
;
}
MOZ_ALWAYS_INLINE
bool
CheckRecursionLimitWithStackPointer
(
JSContext
*
cx
void
*
sp
)
{
JS_STACK_OOM_POSSIBLY_FAIL_REPORT
(
)
;
if
(
!
JS_CHECK_STACK_SIZE
(
GetNativeStackLimit
(
cx
)
sp
)
)
{
ReportOverRecursed
(
cx
)
;
return
false
;
}
return
true
;
}
MOZ_ALWAYS_INLINE
bool
CheckRecursionLimitWithExtra
(
JSContext
*
cx
size_t
extra
)
{
char
stackDummy
;
char
*
sp
=
&
stackDummy
;
#
if
JS_STACK_GROWTH_DIRECTION
>
0
sp
+
=
extra
;
#
else
sp
-
=
extra
;
#
endif
return
CheckRecursionLimitWithStackPointer
(
cx
sp
)
;
}
MOZ_ALWAYS_INLINE
bool
CheckSystemRecursionLimit
(
JSContext
*
cx
)
{
return
CheckRecursionLimit
(
cx
detail
:
:
GetNativeStackLimitHelper
(
cx
JS
:
:
StackForSystemCode
0
)
)
;
}
MOZ_ALWAYS_INLINE
bool
CheckRecursionLimitConservative
(
JSContext
*
cx
)
{
return
CheckRecursionLimit
(
cx
detail
:
:
GetNativeStackLimitHelper
(
cx
JS
:
:
StackForUntrustedScript
-
1024
*
int
(
sizeof
(
size_t
)
)
)
)
;
}
MOZ_ALWAYS_INLINE
bool
CheckRecursionLimitConservativeDontReport
(
JSContext
*
cx
)
{
return
CheckRecursionLimitDontReport
(
detail
:
:
GetNativeStackLimitHelper
(
cx
JS
:
:
StackForUntrustedScript
-
1024
*
int
(
sizeof
(
size_t
)
)
)
)
;
}
}
#
endif
