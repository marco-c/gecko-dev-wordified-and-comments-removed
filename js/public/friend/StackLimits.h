#
ifndef
js_friend_StackLimits_h
#
define
js_friend_StackLimits_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Utility
.
h
"
struct
JS_PUBLIC_API
JSContext
;
#
ifndef
JS_STACK_GROWTH_DIRECTION
#
ifdef
__hppa
#
define
JS_STACK_GROWTH_DIRECTION
(
1
)
#
else
#
define
JS_STACK_GROWTH_DIRECTION
(
-
1
)
#
endif
#
endif
namespace
js
{
class
ErrorContext
;
#
ifdef
__wasi__
extern
MOZ_COLD
JS_PUBLIC_API
void
IncWasiRecursionDepth
(
JSContext
*
ec
)
;
extern
MOZ_COLD
JS_PUBLIC_API
void
DecWasiRecursionDepth
(
JSContext
*
ec
)
;
extern
MOZ_COLD
JS_PUBLIC_API
bool
CheckWasiRecursionLimit
(
JSContext
*
ec
)
;
extern
MOZ_COLD
JS_PUBLIC_API
void
IncWasiRecursionDepth
(
ErrorContext
*
ec
)
;
extern
MOZ_COLD
JS_PUBLIC_API
void
DecWasiRecursionDepth
(
ErrorContext
*
ec
)
;
extern
MOZ_COLD
JS_PUBLIC_API
bool
CheckWasiRecursionLimit
(
ErrorContext
*
ec
)
;
#
endif
class
MOZ_RAII
AutoCheckRecursionLimit
{
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
checkLimitImpl
(
uintptr_t
limit
void
*
sp
)
const
;
MOZ_ALWAYS_INLINE
uintptr_t
getStackLimitSlow
(
JSContext
*
cx
)
const
;
MOZ_ALWAYS_INLINE
uintptr_t
getStackLimitHelper
(
JSContext
*
cx
JS
:
:
StackKind
kind
int
extraAllowance
)
const
;
JS_PUBLIC_API
JS
:
:
StackKind
stackKindForCurrentPrincipal
(
JSContext
*
cx
)
const
;
#
ifdef
__wasi__
mozilla
:
:
Variant
<
JSContext
*
ErrorContext
*
>
context_
;
#
endif
public
:
explicit
MOZ_ALWAYS_INLINE
AutoCheckRecursionLimit
(
JSContext
*
cx
)
#
ifdef
__wasi__
:
context_
(
mozilla
:
:
AsVariant
(
cx
)
)
#
endif
{
#
ifdef
__wasi__
incWasiRecursionDepth
(
)
;
#
endif
}
explicit
MOZ_ALWAYS_INLINE
AutoCheckRecursionLimit
(
ErrorContext
*
ec
)
#
ifdef
__wasi__
:
context_
(
mozilla
:
:
AsVariant
(
ec
)
)
#
endif
{
#
ifdef
__wasi__
incWasiRecursionDepth
(
)
;
#
endif
}
MOZ_ALWAYS_INLINE
~
AutoCheckRecursionLimit
(
)
{
#
ifdef
__wasi__
decWasiRecursionDepth
(
)
;
#
endif
}
#
ifdef
__wasi__
MOZ_ALWAYS_INLINE
void
incWasiRecursionDepth
(
)
{
if
(
context_
.
is
<
JSContext
*
>
(
)
)
{
JSContext
*
cx
=
context_
.
as
<
JSContext
*
>
(
)
;
IncWasiRecursionDepth
(
cx
)
;
}
else
{
ErrorContext
*
ec
=
context_
.
as
<
ErrorContext
*
>
(
)
;
IncWasiRecursionDepth
(
ec
)
;
}
}
MOZ_ALWAYS_INLINE
void
decWasiRecursionDepth
(
)
{
if
(
context_
.
is
<
JSContext
*
>
(
)
)
{
JSContext
*
cx
=
context_
.
as
<
JSContext
*
>
(
)
;
DecWasiRecursionDepth
(
cx
)
;
}
else
{
ErrorContext
*
ec
=
context_
.
as
<
ErrorContext
*
>
(
)
;
DecWasiRecursionDepth
(
ec
)
;
}
}
MOZ_ALWAYS_INLINE
bool
checkWasiRecursionLimit
(
)
const
{
if
(
context_
.
is
<
JSContext
*
>
(
)
)
{
JSContext
*
cx
=
context_
.
as
<
JSContext
*
>
(
)
;
if
(
!
CheckWasiRecursionLimit
(
cx
)
)
{
return
false
;
}
}
else
{
ErrorContext
*
ec
=
context_
.
as
<
ErrorContext
*
>
(
)
;
if
(
!
CheckWasiRecursionLimit
(
ec
)
)
{
return
false
;
}
}
return
true
;
}
#
endif
AutoCheckRecursionLimit
(
const
AutoCheckRecursionLimit
&
)
=
delete
;
void
operator
=
(
const
AutoCheckRecursionLimit
&
)
=
delete
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
check
(
JSContext
*
cx
)
const
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
check
(
ErrorContext
*
ec
uintptr_t
limit
)
const
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
checkDontReport
(
JSContext
*
cx
)
const
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
checkDontReport
(
uintptr_t
limit
)
const
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
checkWithExtra
(
JSContext
*
cx
size_t
extra
)
const
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
checkWithStackPointerDontReport
(
JSContext
*
cx
void
*
sp
)
const
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
checkWithStackPointerDontReport
(
uintptr_t
limit
void
*
sp
)
const
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
checkConservative
(
JSContext
*
cx
)
const
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
checkConservativeDontReport
(
JSContext
*
cx
)
const
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
checkSystem
(
JSContext
*
cx
)
const
;
[
[
nodiscard
]
]
MOZ_ALWAYS_INLINE
bool
checkSystemDontReport
(
JSContext
*
cx
)
const
;
}
;
extern
MOZ_COLD
JS_PUBLIC_API
void
ReportOverRecursed
(
JSContext
*
maybecx
)
;
extern
MOZ_COLD
JS_PUBLIC_API
void
ReportOverRecursed
(
ErrorContext
*
ec
)
;
MOZ_ALWAYS_INLINE
bool
AutoCheckRecursionLimit
:
:
checkLimitImpl
(
uintptr_t
limit
void
*
sp
)
const
{
JS_STACK_OOM_POSSIBLY_FAIL
(
)
;
#
ifdef
__wasi__
if
(
!
checkWasiRecursionLimit
(
)
)
{
return
false
;
}
#
endif
#
if
JS_STACK_GROWTH_DIRECTION
>
0
return
MOZ_LIKELY
(
uintptr_t
(
sp
)
<
limit
)
;
#
else
return
MOZ_LIKELY
(
uintptr_t
(
sp
)
>
limit
)
;
#
endif
}
MOZ_ALWAYS_INLINE
uintptr_t
AutoCheckRecursionLimit
:
:
getStackLimitSlow
(
JSContext
*
cx
)
const
{
JS
:
:
StackKind
kind
=
stackKindForCurrentPrincipal
(
cx
)
;
return
getStackLimitHelper
(
cx
kind
0
)
;
}
MOZ_ALWAYS_INLINE
uintptr_t
AutoCheckRecursionLimit
:
:
getStackLimitHelper
(
JSContext
*
cx
JS
:
:
StackKind
kind
int
extraAllowance
)
const
{
uintptr_t
limit
=
JS
:
:
RootingContext
:
:
get
(
cx
)
-
>
nativeStackLimit
[
kind
]
;
#
if
JS_STACK_GROWTH_DIRECTION
>
0
limit
+
=
extraAllowance
;
#
else
limit
-
=
extraAllowance
;
#
endif
return
limit
;
}
MOZ_ALWAYS_INLINE
bool
AutoCheckRecursionLimit
:
:
check
(
JSContext
*
cx
)
const
{
if
(
MOZ_UNLIKELY
(
!
checkDontReport
(
cx
)
)
)
{
ReportOverRecursed
(
cx
)
;
return
false
;
}
return
true
;
}
MOZ_ALWAYS_INLINE
bool
AutoCheckRecursionLimit
:
:
check
(
ErrorContext
*
ec
uintptr_t
limit
)
const
{
if
(
MOZ_UNLIKELY
(
!
checkDontReport
(
limit
)
)
)
{
ReportOverRecursed
(
ec
)
;
return
false
;
}
return
true
;
}
MOZ_ALWAYS_INLINE
bool
AutoCheckRecursionLimit
:
:
checkDontReport
(
JSContext
*
cx
)
const
{
int
stackDummy
;
return
checkWithStackPointerDontReport
(
cx
&
stackDummy
)
;
}
MOZ_ALWAYS_INLINE
bool
AutoCheckRecursionLimit
:
:
checkDontReport
(
uintptr_t
limit
)
const
{
int
stackDummy
;
return
checkWithStackPointerDontReport
(
limit
&
stackDummy
)
;
}
MOZ_ALWAYS_INLINE
bool
AutoCheckRecursionLimit
:
:
checkWithStackPointerDontReport
(
JSContext
*
cx
void
*
sp
)
const
{
uintptr_t
untrustedLimit
=
getStackLimitHelper
(
cx
JS
:
:
StackForUntrustedScript
0
)
;
if
(
MOZ_LIKELY
(
checkLimitImpl
(
untrustedLimit
sp
)
)
)
{
return
true
;
}
return
checkLimitImpl
(
getStackLimitSlow
(
cx
)
sp
)
;
}
MOZ_ALWAYS_INLINE
bool
AutoCheckRecursionLimit
:
:
checkWithStackPointerDontReport
(
uintptr_t
limit
void
*
sp
)
const
{
return
checkLimitImpl
(
limit
sp
)
;
}
MOZ_ALWAYS_INLINE
bool
AutoCheckRecursionLimit
:
:
checkWithExtra
(
JSContext
*
cx
size_t
extra
)
const
{
char
stackDummy
;
char
*
sp
=
&
stackDummy
;
#
if
JS_STACK_GROWTH_DIRECTION
>
0
sp
+
=
extra
;
#
else
sp
-
=
extra
;
#
endif
if
(
MOZ_UNLIKELY
(
!
checkWithStackPointerDontReport
(
cx
sp
)
)
)
{
ReportOverRecursed
(
cx
)
;
return
false
;
}
return
true
;
}
MOZ_ALWAYS_INLINE
bool
AutoCheckRecursionLimit
:
:
checkSystem
(
JSContext
*
cx
)
const
{
if
(
MOZ_UNLIKELY
(
!
checkSystemDontReport
(
cx
)
)
)
{
ReportOverRecursed
(
cx
)
;
return
false
;
}
return
true
;
}
MOZ_ALWAYS_INLINE
bool
AutoCheckRecursionLimit
:
:
checkSystemDontReport
(
JSContext
*
cx
)
const
{
uintptr_t
limit
=
getStackLimitHelper
(
cx
JS
:
:
StackForSystemCode
0
)
;
int
stackDummy
;
return
checkLimitImpl
(
limit
&
stackDummy
)
;
}
MOZ_ALWAYS_INLINE
bool
AutoCheckRecursionLimit
:
:
checkConservative
(
JSContext
*
cx
)
const
{
if
(
MOZ_UNLIKELY
(
!
checkConservativeDontReport
(
cx
)
)
)
{
ReportOverRecursed
(
cx
)
;
return
false
;
}
return
true
;
}
MOZ_ALWAYS_INLINE
bool
AutoCheckRecursionLimit
:
:
checkConservativeDontReport
(
JSContext
*
cx
)
const
{
uintptr_t
limit
=
getStackLimitHelper
(
cx
JS
:
:
StackForUntrustedScript
-
1024
*
int
(
sizeof
(
size_t
)
)
)
;
int
stackDummy
;
return
checkLimitImpl
(
limit
&
stackDummy
)
;
}
}
#
endif
