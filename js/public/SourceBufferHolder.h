#
ifndef
js_SourceBufferHolder_h
#
define
js_SourceBufferHolder_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
js
/
Utility
.
h
"
namespace
JS
{
namespace
detail
{
MOZ_COLD
extern
JS_PUBLIC_API
(
void
)
ReportSourceTooLong
(
JSContext
*
cx
)
;
}
class
SourceBufferHolder
final
{
private
:
const
char16_t
*
data_
=
nullptr
;
size_t
length_
=
0
;
bool
ownsChars_
=
false
;
public
:
SourceBufferHolder
(
)
=
default
;
SourceBufferHolder
(
SourceBufferHolder
&
&
other
)
:
data_
(
other
.
data_
)
length_
(
other
.
length_
)
ownsChars_
(
other
.
ownsChars_
)
{
other
.
data_
=
nullptr
;
other
.
length_
=
0
;
other
.
ownsChars_
=
false
;
}
~
SourceBufferHolder
(
)
{
if
(
ownsChars_
)
{
js_free
(
const_cast
<
char16_t
*
>
(
data_
)
)
;
}
}
enum
Ownership
{
NoOwnership
GiveOwnership
}
;
MOZ_IS_CLASS_INIT
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
const
char16_t
*
data
size_t
dataLength
Ownership
ownership
)
{
MOZ_ASSERT_IF
(
data
=
=
nullptr
dataLength
=
=
0
)
;
static
const
char16_t
nonNullData
[
]
=
u
"
"
;
if
(
data
)
{
data_
=
data
;
length_
=
static_cast
<
uint32_t
>
(
dataLength
)
;
ownsChars_
=
ownership
=
=
GiveOwnership
;
}
else
{
data_
=
nonNullData
;
length_
=
0
;
ownsChars_
=
false
;
}
if
(
MOZ_UNLIKELY
(
dataLength
>
UINT32_MAX
)
)
{
detail
:
:
ReportSourceTooLong
(
cx
)
;
return
false
;
}
return
true
;
}
MOZ_IS_CLASS_INIT
MOZ_MUST_USE
bool
init
(
JSContext
*
cx
UniqueTwoByteChars
data
size_t
dataLength
)
{
return
init
(
cx
data
.
release
(
)
dataLength
GiveOwnership
)
;
}
const
char16_t
*
get
(
)
const
{
return
data_
;
}
uint32_t
length
(
)
const
{
return
length_
;
}
bool
ownsChars
(
)
const
{
return
ownsChars_
;
}
char16_t
*
take
(
)
{
MOZ_ASSERT
(
ownsChars_
)
;
ownsChars_
=
false
;
return
const_cast
<
char16_t
*
>
(
data_
)
;
}
private
:
SourceBufferHolder
(
SourceBufferHolder
&
)
=
delete
;
SourceBufferHolder
&
operator
=
(
SourceBufferHolder
&
)
=
delete
;
}
;
}
#
endif
