#
ifndef
js_UbiNodeBreadthFirst_h
#
define
js_UbiNodeBreadthFirst_h
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
js
/
Vector
.
h
"
namespace
JS
{
namespace
ubi
{
template
<
typename
Handler
>
struct
BreadthFirst
{
BreadthFirst
(
JSContext
*
cx
Handler
&
handler
const
JS
:
:
AutoRequireNoGC
&
noGC
)
:
wantNames
(
true
)
cx
(
cx
)
visited
(
)
handler
(
handler
)
pending
(
)
traversalBegun
(
false
)
stopRequested
(
false
)
abandonRequested
(
false
)
markReferentAsVisited
(
false
)
{
}
bool
addStart
(
Node
node
)
{
return
pending
.
append
(
node
)
;
}
bool
addStartVisited
(
Node
node
)
{
typename
NodeMap
:
:
AddPtr
ptr
=
visited
.
lookupForAdd
(
node
)
;
if
(
!
ptr
&
&
!
visited
.
add
(
ptr
node
typename
Handler
:
:
NodeData
(
)
)
)
{
return
false
;
}
return
addStart
(
node
)
;
}
bool
wantNames
;
bool
traverse
(
)
{
MOZ_ASSERT
(
!
traversalBegun
)
;
traversalBegun
=
true
;
while
(
!
pending
.
empty
(
)
)
{
Node
origin
=
pending
.
front
(
)
;
pending
.
popFront
(
)
;
auto
range
=
origin
.
edges
(
cx
wantNames
)
;
if
(
!
range
)
{
return
false
;
}
for
(
;
!
range
-
>
empty
(
)
;
range
-
>
popFront
(
)
)
{
MOZ_ASSERT
(
!
stopRequested
)
;
Edge
&
edge
=
range
-
>
front
(
)
;
typename
NodeMap
:
:
AddPtr
a
=
visited
.
lookupForAdd
(
edge
.
referent
)
;
bool
first
=
!
a
;
typename
Handler
:
:
NodeData
nodeData
;
typename
Handler
:
:
NodeData
*
nodeDataPtr
=
first
?
&
nodeData
:
&
a
-
>
value
(
)
;
markReferentAsVisited
=
true
;
if
(
!
handler
(
*
this
origin
edge
nodeDataPtr
first
)
)
{
return
false
;
}
if
(
first
&
&
markReferentAsVisited
)
{
if
(
!
visited
.
add
(
a
edge
.
referent
std
:
:
move
(
nodeData
)
)
)
{
return
false
;
}
}
if
(
stopRequested
)
{
return
true
;
}
if
(
abandonRequested
)
{
abandonRequested
=
false
;
}
else
if
(
first
)
{
if
(
!
pending
.
append
(
edge
.
referent
)
)
{
return
false
;
}
}
}
}
return
true
;
}
void
stop
(
)
{
stopRequested
=
true
;
}
void
abandonReferent
(
)
{
abandonRequested
=
true
;
}
void
doNotMarkReferentAsVisited
(
)
{
markReferentAsVisited
=
false
;
}
JSContext
*
cx
;
using
NodeMap
=
js
:
:
HashMap
<
Node
typename
Handler
:
:
NodeData
js
:
:
DefaultHasher
<
Node
>
js
:
:
SystemAllocPolicy
>
;
NodeMap
visited
;
private
:
Handler
&
handler
;
template
<
typename
T
>
class
Queue
{
js
:
:
Vector
<
T
0
js
:
:
SystemAllocPolicy
>
head
tail
;
size_t
frontIndex
;
public
:
Queue
(
)
:
head
(
)
tail
(
)
frontIndex
(
0
)
{
}
bool
empty
(
)
{
return
frontIndex
>
=
head
.
length
(
)
;
}
T
&
front
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
return
head
[
frontIndex
]
;
}
void
popFront
(
)
{
MOZ_ASSERT
(
!
empty
(
)
)
;
frontIndex
+
+
;
if
(
frontIndex
>
=
head
.
length
(
)
)
{
head
.
clearAndFree
(
)
;
head
.
swap
(
tail
)
;
frontIndex
=
0
;
}
}
bool
append
(
const
T
&
elt
)
{
return
frontIndex
=
=
0
?
head
.
append
(
elt
)
:
tail
.
append
(
elt
)
;
}
}
;
Queue
<
Node
>
pending
;
bool
traversalBegun
;
bool
stopRequested
;
bool
abandonRequested
;
bool
markReferentAsVisited
;
}
;
}
}
#
endif
