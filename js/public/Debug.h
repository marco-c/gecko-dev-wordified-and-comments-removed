#
ifndef
js_Debug_h
#
define
js_Debug_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
<
utility
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
js
{
class
Debugger
;
}
extern
JS_PUBLIC_API
bool
JS_DefineDebuggerObject
(
JSContext
*
cx
JS
:
:
HandleObject
obj
)
;
namespace
JS
{
namespace
dbg
{
class
BuilderOrigin
;
class
Builder
{
PersistentRootedObject
debuggerObject
;
js
:
:
Debugger
*
debugger
;
#
ifdef
DEBUG
void
assertBuilt
(
JSObject
*
obj
)
;
#
else
void
assertBuilt
(
JSObject
*
obj
)
{
}
#
endif
protected
:
template
<
typename
T
>
class
BuiltThing
{
friend
class
BuilderOrigin
;
protected
:
Builder
&
owner
;
PersistentRooted
<
T
>
value
;
BuiltThing
(
JSContext
*
cx
Builder
&
owner_
T
value_
=
SafelyInitialized
<
T
>
:
:
create
(
)
)
:
owner
(
owner_
)
value
(
cx
value_
)
{
owner
.
assertBuilt
(
value_
)
;
}
js
:
:
Debugger
*
debugger
(
)
const
{
return
owner
.
debugger
;
}
JSObject
*
debuggerObject
(
)
const
{
return
owner
.
debuggerObject
;
}
public
:
BuiltThing
(
const
BuiltThing
&
rhs
)
:
owner
(
rhs
.
owner
)
value
(
rhs
.
value
)
{
}
BuiltThing
&
operator
=
(
const
BuiltThing
&
rhs
)
{
MOZ_ASSERT
(
&
owner
=
=
&
rhs
.
owner
)
;
owner
.
assertBuilt
(
rhs
.
value
)
;
value
=
rhs
.
value
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
value
;
}
private
:
BuiltThing
(
)
=
delete
;
}
;
public
:
class
Object
:
private
BuiltThing
<
JSObject
*
>
{
friend
class
Builder
;
friend
class
BuilderOrigin
;
typedef
BuiltThing
<
JSObject
*
>
Base
;
Object
(
JSContext
*
cx
Builder
&
owner_
HandleObject
obj
)
:
Base
(
cx
owner_
obj
.
get
(
)
)
{
}
bool
definePropertyToTrusted
(
JSContext
*
cx
const
char
*
name
JS
:
:
MutableHandleValue
value
)
;
public
:
Object
(
JSContext
*
cx
Builder
&
owner_
)
:
Base
(
cx
owner_
nullptr
)
{
}
Object
(
const
Object
&
rhs
)
=
default
;
bool
defineProperty
(
JSContext
*
cx
const
char
*
name
JS
:
:
HandleValue
value
)
;
bool
defineProperty
(
JSContext
*
cx
const
char
*
name
JS
:
:
HandleObject
value
)
;
bool
defineProperty
(
JSContext
*
cx
const
char
*
name
Object
&
value
)
;
using
Base
:
:
operator
bool
;
}
;
Object
newObject
(
JSContext
*
cx
)
;
protected
:
Builder
(
JSContext
*
cx
js
:
:
Debugger
*
debugger
)
;
}
;
class
BuilderOrigin
:
public
Builder
{
template
<
typename
T
>
T
unwrapAny
(
const
BuiltThing
<
T
>
&
thing
)
{
MOZ_ASSERT
(
&
thing
.
owner
=
=
this
)
;
return
thing
.
value
.
get
(
)
;
}
public
:
BuilderOrigin
(
JSContext
*
cx
js
:
:
Debugger
*
debugger_
)
:
Builder
(
cx
debugger_
)
{
}
JSObject
*
unwrap
(
Object
&
object
)
{
return
unwrapAny
(
object
)
;
}
}
;
JS_PUBLIC_API
void
SetDebuggerMallocSizeOf
(
JSContext
*
cx
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
JS_PUBLIC_API
mozilla
:
:
MallocSizeOf
GetDebuggerMallocSizeOf
(
JSContext
*
cx
)
;
JS_PUBLIC_API
bool
FireOnGarbageCollectionHookRequired
(
JSContext
*
cx
)
;
JS_PUBLIC_API
bool
FireOnGarbageCollectionHook
(
JSContext
*
cx
GarbageCollectionEvent
:
:
Ptr
&
&
data
)
;
JS_PUBLIC_API
bool
IsDebugger
(
JSObject
&
obj
)
;
JS_PUBLIC_API
bool
GetDebuggeeGlobals
(
JSContext
*
cx
JSObject
&
dbgObj
MutableHandleObjectVector
vector
)
;
class
MOZ_STACK_CLASS
JS_PUBLIC_API
AutoEntryMonitor
{
JSContext
*
cx_
;
AutoEntryMonitor
*
savedMonitor_
;
public
:
explicit
AutoEntryMonitor
(
JSContext
*
cx
)
;
~
AutoEntryMonitor
(
)
;
virtual
void
Entry
(
JSContext
*
cx
JSFunction
*
function
HandleValue
asyncStack
const
char
*
asyncCause
)
=
0
;
virtual
void
Entry
(
JSContext
*
cx
JSScript
*
script
HandleValue
asyncStack
const
char
*
asyncCause
)
=
0
;
virtual
void
Exit
(
JSContext
*
cx
)
{
}
}
;
}
}
#
endif
