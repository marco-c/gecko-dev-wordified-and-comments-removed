#
ifndef
js_Debug_h
#
define
js_Debug_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BaseProfilerUtils
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
<
utility
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
js
{
class
Debugger
;
}
extern
JS_PUBLIC_API
bool
JS_DefineDebuggerObject
(
JSContext
*
cx
JS
:
:
HandleObject
obj
)
;
extern
JS_PUBLIC_API
void
JS_TracerEnterLabelLatin1
(
JSContext
*
cx
const
char
*
label
)
;
extern
JS_PUBLIC_API
void
JS_TracerEnterLabelTwoByte
(
JSContext
*
cx
const
char16_t
*
label
)
;
extern
JS_PUBLIC_API
bool
JS_TracerIsTracing
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
JS_TracerLeaveLabelLatin1
(
JSContext
*
cx
const
char
*
label
)
;
extern
JS_PUBLIC_API
void
JS_TracerLeaveLabelTwoByte
(
JSContext
*
cx
const
char16_t
*
label
)
;
#
ifdef
MOZ_EXECUTION_TRACING
extern
JS_PUBLIC_API
bool
JS_TracerBeginTracing
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
bool
JS_TracerEndTracing
(
JSContext
*
cx
)
;
namespace
JS
{
struct
ExecutionTrace
{
enum
class
EventKind
:
uint8_t
{
FunctionEnter
=
0
FunctionLeave
=
1
LabelEnter
=
2
LabelLeave
=
3
Error
=
4
}
;
enum
class
ImplementationType
:
uint8_t
{
Interpreter
=
0
Baseline
=
1
Ion
=
2
Wasm
=
3
}
;
struct
TracedEvent
{
EventKind
kind
;
union
{
struct
{
ImplementationType
implementation
;
uint32_t
lineNumber
;
uint32_t
column
;
uint32_t
scriptId
;
uint64_t
realmID
;
uint32_t
functionNameId
;
}
functionEvent
;
struct
{
size_t
label
;
}
labelEvent
;
}
;
double
time
;
}
;
struct
TracedJSContext
{
mozilla
:
:
baseprofiler
:
:
BaseProfilerThreadId
id
;
mozilla
:
:
HashMap
<
uint32_t
size_t
>
scriptUrls
;
mozilla
:
:
HashMap
<
uint32_t
size_t
>
atoms
;
mozilla
:
:
Vector
<
TracedEvent
>
events
;
}
;
mozilla
:
:
Vector
<
char
>
stringBuffer
;
mozilla
:
:
Vector
<
TracedJSContext
>
contexts
;
}
;
}
extern
JS_PUBLIC_API
bool
JS_TracerSnapshotTrace
(
JS
:
:
ExecutionTrace
&
trace
)
;
#
endif
namespace
JS
{
namespace
dbg
{
class
BuilderOrigin
;
class
Builder
{
PersistentRootedObject
debuggerObject
;
js
:
:
Debugger
*
debugger
;
#
ifdef
DEBUG
void
assertBuilt
(
JSObject
*
obj
)
;
#
else
void
assertBuilt
(
JSObject
*
obj
)
{
}
#
endif
protected
:
template
<
typename
T
>
class
BuiltThing
{
friend
class
BuilderOrigin
;
protected
:
Builder
&
owner
;
PersistentRooted
<
T
>
value
;
BuiltThing
(
JSContext
*
cx
Builder
&
owner_
T
value_
=
SafelyInitialized
<
T
>
:
:
create
(
)
)
:
owner
(
owner_
)
value
(
cx
value_
)
{
owner
.
assertBuilt
(
value_
)
;
}
js
:
:
Debugger
*
debugger
(
)
const
{
return
owner
.
debugger
;
}
JSObject
*
debuggerObject
(
)
const
{
return
owner
.
debuggerObject
;
}
public
:
BuiltThing
(
const
BuiltThing
&
rhs
)
:
owner
(
rhs
.
owner
)
value
(
rhs
.
value
)
{
}
BuiltThing
&
operator
=
(
const
BuiltThing
&
rhs
)
{
MOZ_ASSERT
(
&
owner
=
=
&
rhs
.
owner
)
;
owner
.
assertBuilt
(
rhs
.
value
)
;
value
=
rhs
.
value
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
value
;
}
private
:
BuiltThing
(
)
=
delete
;
}
;
public
:
class
Object
:
private
BuiltThing
<
JSObject
*
>
{
friend
class
Builder
;
friend
class
BuilderOrigin
;
typedef
BuiltThing
<
JSObject
*
>
Base
;
Object
(
JSContext
*
cx
Builder
&
owner_
HandleObject
obj
)
:
Base
(
cx
owner_
obj
.
get
(
)
)
{
}
bool
definePropertyToTrusted
(
JSContext
*
cx
const
char
*
name
JS
:
:
MutableHandleValue
value
)
;
public
:
Object
(
JSContext
*
cx
Builder
&
owner_
)
:
Base
(
cx
owner_
nullptr
)
{
}
Object
(
const
Object
&
rhs
)
=
default
;
bool
defineProperty
(
JSContext
*
cx
const
char
*
name
JS
:
:
HandleValue
value
)
;
bool
defineProperty
(
JSContext
*
cx
const
char
*
name
JS
:
:
HandleObject
value
)
;
bool
defineProperty
(
JSContext
*
cx
const
char
*
name
Object
&
value
)
;
using
Base
:
:
operator
bool
;
}
;
Object
newObject
(
JSContext
*
cx
)
;
protected
:
Builder
(
JSContext
*
cx
js
:
:
Debugger
*
debugger
)
;
}
;
class
BuilderOrigin
:
public
Builder
{
template
<
typename
T
>
T
unwrapAny
(
const
BuiltThing
<
T
>
&
thing
)
{
MOZ_ASSERT
(
&
thing
.
owner
=
=
this
)
;
return
thing
.
value
.
get
(
)
;
}
public
:
BuilderOrigin
(
JSContext
*
cx
js
:
:
Debugger
*
debugger_
)
:
Builder
(
cx
debugger_
)
{
}
JSObject
*
unwrap
(
Object
&
object
)
{
return
unwrapAny
(
object
)
;
}
}
;
JS_PUBLIC_API
void
SetDebuggerMallocSizeOf
(
JSContext
*
cx
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
JS_PUBLIC_API
mozilla
:
:
MallocSizeOf
GetDebuggerMallocSizeOf
(
JSContext
*
cx
)
;
JS_PUBLIC_API
bool
FireOnGarbageCollectionHookRequired
(
JSContext
*
cx
)
;
JS_PUBLIC_API
bool
FireOnGarbageCollectionHook
(
JSContext
*
cx
GarbageCollectionEvent
:
:
Ptr
&
&
data
)
;
JS_PUBLIC_API
bool
IsDebugger
(
JSObject
&
obj
)
;
JS_PUBLIC_API
bool
GetDebuggeeGlobals
(
JSContext
*
cx
JSObject
&
dbgObj
MutableHandleObjectVector
vector
)
;
bool
ShouldAvoidSideEffects
(
JSContext
*
cx
)
;
}
}
#
endif
