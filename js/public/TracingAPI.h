#
ifndef
js_TracingAPI_h
#
define
js_TracingAPI_h
#
include
"
js
/
GCTypeMacros
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
TraceKind
.
h
"
class
JS_PUBLIC_API
JSTracer
;
namespace
JS
{
class
JS_PUBLIC_API
CallbackTracer
;
template
<
typename
T
>
class
Heap
;
template
<
typename
T
>
class
TenuredHeap
;
JS_PUBLIC_API
const
char
*
GCTraceKindToAscii
(
JS
:
:
TraceKind
kind
)
;
JS_PUBLIC_API
size_t
GCTraceKindSize
(
JS
:
:
TraceKind
kind
)
;
enum
class
TracerKind
{
Marking
Generic
Tenuring
Moving
GrayBuffering
ClearEdges
Sweeping
Barrier
Callback
UnmarkGray
VerifyTraceProtoAndIface
}
;
enum
class
WeakMapTraceAction
{
Skip
Expand
TraceValues
TraceKeysAndValues
}
;
enum
class
WeakEdgeTraceAction
{
Skip
Trace
}
;
enum
class
IdTraceAction
{
CanSkip
Trace
}
;
struct
TraceOptions
{
JS
:
:
WeakMapTraceAction
weakMapAction
=
WeakMapTraceAction
:
:
TraceValues
;
JS
:
:
WeakEdgeTraceAction
weakEdgeAction
=
WeakEdgeTraceAction
:
:
Trace
;
JS
:
:
IdTraceAction
idAction
=
IdTraceAction
:
:
Trace
;
TraceOptions
(
)
=
default
;
TraceOptions
(
JS
:
:
WeakMapTraceAction
weakMapActionArg
JS
:
:
WeakEdgeTraceAction
weakEdgeActionArg
JS
:
:
IdTraceAction
idActionArg
=
IdTraceAction
:
:
Trace
)
:
weakMapAction
(
weakMapActionArg
)
weakEdgeAction
(
weakEdgeActionArg
)
idAction
(
idActionArg
)
{
}
MOZ_IMPLICIT
TraceOptions
(
JS
:
:
WeakMapTraceAction
weakMapActionArg
)
:
weakMapAction
(
weakMapActionArg
)
{
}
MOZ_IMPLICIT
TraceOptions
(
JS
:
:
WeakEdgeTraceAction
weakEdgeActionArg
)
:
weakEdgeAction
(
weakEdgeActionArg
)
{
}
MOZ_IMPLICIT
TraceOptions
(
JS
:
:
IdTraceAction
idActionArg
)
:
idAction
(
idActionArg
)
{
}
}
;
class
AutoTracingName
;
class
AutoTracingIndex
;
class
TracingContext
{
public
:
const
char
*
name
(
)
const
{
MOZ_ASSERT
(
name_
)
;
return
name_
;
}
constexpr
static
size_t
InvalidIndex
=
size_t
(
-
1
)
;
size_t
index
(
)
const
{
return
index_
;
}
void
getEdgeName
(
char
*
buffer
size_t
bufferSize
)
;
class
Functor
{
public
:
virtual
void
operator
(
)
(
TracingContext
*
tcx
char
*
buf
size_t
bufsize
)
=
0
;
}
;
private
:
friend
class
AutoTracingName
;
const
char
*
name_
=
nullptr
;
friend
class
AutoTracingIndex
;
size_t
index_
=
InvalidIndex
;
friend
class
AutoTracingDetails
;
Functor
*
functor_
=
nullptr
;
}
;
}
namespace
js
{
class
GenericTracer
;
}
class
JS_PUBLIC_API
JSTracer
{
public
:
JSRuntime
*
runtime
(
)
const
{
return
runtime_
;
}
JS
:
:
TracerKind
kind
(
)
const
{
return
kind_
;
}
bool
isMarkingTracer
(
)
const
{
return
kind_
=
=
JS
:
:
TracerKind
:
:
Marking
;
}
bool
isTenuringTracer
(
)
const
{
return
kind_
=
=
JS
:
:
TracerKind
:
:
Tenuring
;
}
bool
isGenericTracer
(
)
const
{
return
kind_
>
=
JS
:
:
TracerKind
:
:
Generic
;
}
bool
isCallbackTracer
(
)
const
{
return
kind_
>
=
JS
:
:
TracerKind
:
:
Callback
;
}
inline
js
:
:
GenericTracer
*
asGenericTracer
(
)
;
inline
JS
:
:
CallbackTracer
*
asCallbackTracer
(
)
;
JS
:
:
WeakMapTraceAction
weakMapAction
(
)
const
{
return
options_
.
weakMapAction
;
}
bool
traceWeakEdges
(
)
const
{
return
options_
.
weakEdgeAction
=
=
JS
:
:
WeakEdgeTraceAction
:
:
Trace
;
}
bool
canSkipJsids
(
)
const
{
return
options_
.
idAction
=
=
JS
:
:
IdTraceAction
:
:
CanSkip
;
}
JS
:
:
TracingContext
&
context
(
)
{
return
context_
;
}
uint32_t
gcNumberForMarking
(
)
const
;
protected
:
JSTracer
(
JSRuntime
*
rt
JS
:
:
TracerKind
kind
JS
:
:
TraceOptions
options
=
JS
:
:
TraceOptions
(
)
)
:
runtime_
(
rt
)
kind_
(
kind
)
options_
(
options
)
{
}
private
:
JSRuntime
*
const
runtime_
;
const
JS
:
:
TracerKind
kind_
;
const
JS
:
:
TraceOptions
options_
;
JS
:
:
TracingContext
context_
;
}
;
namespace
js
{
class
GenericTracer
:
public
JSTracer
{
public
:
GenericTracer
(
JSRuntime
*
rt
JS
:
:
TracerKind
kind
=
JS
:
:
TracerKind
:
:
Generic
JS
:
:
TraceOptions
options
=
JS
:
:
TraceOptions
(
)
)
:
JSTracer
(
rt
kind
options
)
{
MOZ_ASSERT
(
isGenericTracer
(
)
)
;
}
virtual
JSObject
*
onObjectEdge
(
JSObject
*
obj
)
=
0
;
virtual
JSString
*
onStringEdge
(
JSString
*
str
)
=
0
;
virtual
JS
:
:
Symbol
*
onSymbolEdge
(
JS
:
:
Symbol
*
sym
)
=
0
;
virtual
JS
:
:
BigInt
*
onBigIntEdge
(
JS
:
:
BigInt
*
bi
)
=
0
;
virtual
js
:
:
BaseScript
*
onScriptEdge
(
js
:
:
BaseScript
*
script
)
=
0
;
virtual
js
:
:
Shape
*
onShapeEdge
(
js
:
:
Shape
*
shape
)
=
0
;
virtual
js
:
:
RegExpShared
*
onRegExpSharedEdge
(
js
:
:
RegExpShared
*
shared
)
=
0
;
virtual
js
:
:
GetterSetter
*
onGetterSetterEdge
(
js
:
:
GetterSetter
*
gs
)
=
0
;
virtual
js
:
:
PropMap
*
onPropMapEdge
(
js
:
:
PropMap
*
map
)
=
0
;
virtual
js
:
:
BaseShape
*
onBaseShapeEdge
(
js
:
:
BaseShape
*
base
)
=
0
;
virtual
js
:
:
jit
:
:
JitCode
*
onJitCodeEdge
(
js
:
:
jit
:
:
JitCode
*
code
)
=
0
;
virtual
js
:
:
Scope
*
onScopeEdge
(
js
:
:
Scope
*
scope
)
=
0
;
}
;
}
namespace
JS
{
class
JS_PUBLIC_API
CallbackTracer
:
public
js
:
:
GenericTracer
{
public
:
CallbackTracer
(
JSRuntime
*
rt
JS
:
:
TracerKind
kind
=
JS
:
:
TracerKind
:
:
Callback
JS
:
:
TraceOptions
options
=
JS
:
:
TraceOptions
(
)
)
:
GenericTracer
(
rt
kind
options
)
{
MOZ_ASSERT
(
isCallbackTracer
(
)
)
;
}
CallbackTracer
(
JSContext
*
cx
JS
:
:
TracerKind
kind
=
JS
:
:
TracerKind
:
:
Callback
JS
:
:
TraceOptions
options
=
JS
:
:
TraceOptions
(
)
)
;
virtual
void
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
=
0
;
private
:
virtual
JSObject
*
onObjectEdge
(
JSObject
*
obj
)
{
onChild
(
JS
:
:
GCCellPtr
(
obj
)
)
;
return
obj
;
}
virtual
JSString
*
onStringEdge
(
JSString
*
str
)
{
onChild
(
JS
:
:
GCCellPtr
(
str
)
)
;
return
str
;
}
virtual
JS
:
:
Symbol
*
onSymbolEdge
(
JS
:
:
Symbol
*
sym
)
{
onChild
(
JS
:
:
GCCellPtr
(
sym
)
)
;
return
sym
;
}
virtual
JS
:
:
BigInt
*
onBigIntEdge
(
JS
:
:
BigInt
*
bi
)
{
onChild
(
JS
:
:
GCCellPtr
(
bi
)
)
;
return
bi
;
}
virtual
js
:
:
BaseScript
*
onScriptEdge
(
js
:
:
BaseScript
*
script
)
{
onChild
(
JS
:
:
GCCellPtr
(
script
)
)
;
return
script
;
}
virtual
js
:
:
Shape
*
onShapeEdge
(
js
:
:
Shape
*
shape
)
{
onChild
(
JS
:
:
GCCellPtr
(
shape
JS
:
:
TraceKind
:
:
Shape
)
)
;
return
shape
;
}
virtual
js
:
:
BaseShape
*
onBaseShapeEdge
(
js
:
:
BaseShape
*
base
)
{
onChild
(
JS
:
:
GCCellPtr
(
base
JS
:
:
TraceKind
:
:
BaseShape
)
)
;
return
base
;
}
virtual
js
:
:
GetterSetter
*
onGetterSetterEdge
(
js
:
:
GetterSetter
*
gs
)
{
onChild
(
JS
:
:
GCCellPtr
(
gs
JS
:
:
TraceKind
:
:
GetterSetter
)
)
;
return
gs
;
}
virtual
js
:
:
PropMap
*
onPropMapEdge
(
js
:
:
PropMap
*
map
)
{
onChild
(
JS
:
:
GCCellPtr
(
map
JS
:
:
TraceKind
:
:
PropMap
)
)
;
return
map
;
}
virtual
js
:
:
jit
:
:
JitCode
*
onJitCodeEdge
(
js
:
:
jit
:
:
JitCode
*
code
)
{
onChild
(
JS
:
:
GCCellPtr
(
code
JS
:
:
TraceKind
:
:
JitCode
)
)
;
return
code
;
}
virtual
js
:
:
Scope
*
onScopeEdge
(
js
:
:
Scope
*
scope
)
{
onChild
(
JS
:
:
GCCellPtr
(
scope
JS
:
:
TraceKind
:
:
Scope
)
)
;
return
scope
;
}
virtual
js
:
:
RegExpShared
*
onRegExpSharedEdge
(
js
:
:
RegExpShared
*
shared
)
{
onChild
(
JS
:
:
GCCellPtr
(
shared
JS
:
:
TraceKind
:
:
RegExpShared
)
)
;
return
shared
;
}
}
;
class
MOZ_RAII
AutoTracingName
{
JSTracer
*
trc_
;
public
:
AutoTracingName
(
JSTracer
*
trc
const
char
*
name
)
:
trc_
(
trc
)
{
MOZ_ASSERT
(
name
)
;
MOZ_ASSERT
(
!
trc_
-
>
context
(
)
.
name_
)
;
trc_
-
>
context
(
)
.
name_
=
name
;
}
~
AutoTracingName
(
)
{
MOZ_ASSERT
(
trc_
-
>
context
(
)
.
name_
)
;
trc_
-
>
context
(
)
.
name_
=
nullptr
;
}
}
;
class
MOZ_RAII
AutoTracingIndex
{
JSTracer
*
trc_
;
public
:
explicit
AutoTracingIndex
(
JSTracer
*
trc
size_t
initial
=
0
)
:
trc_
(
trc
)
{
MOZ_ASSERT
(
trc_
-
>
context
(
)
.
index_
=
=
TracingContext
:
:
InvalidIndex
)
;
trc_
-
>
context
(
)
.
index_
=
initial
;
}
~
AutoTracingIndex
(
)
{
MOZ_ASSERT
(
trc_
-
>
context
(
)
.
index_
!
=
TracingContext
:
:
InvalidIndex
)
;
trc_
-
>
context
(
)
.
index_
=
TracingContext
:
:
InvalidIndex
;
}
void
operator
+
+
(
)
{
MOZ_ASSERT
(
trc_
-
>
context
(
)
.
index_
!
=
TracingContext
:
:
InvalidIndex
)
;
+
+
trc_
-
>
context
(
)
.
index_
;
}
}
;
class
MOZ_RAII
AutoTracingDetails
{
JSTracer
*
trc_
;
public
:
AutoTracingDetails
(
JSTracer
*
trc
TracingContext
:
:
Functor
&
func
)
:
trc_
(
trc
)
{
MOZ_ASSERT
(
trc_
-
>
context
(
)
.
functor_
=
=
nullptr
)
;
trc_
-
>
context
(
)
.
functor_
=
&
func
;
}
~
AutoTracingDetails
(
)
{
MOZ_ASSERT
(
trc_
-
>
context
(
)
.
functor_
)
;
trc_
-
>
context
(
)
.
functor_
=
nullptr
;
}
}
;
class
MOZ_RAII
AutoClearTracingContext
{
JSTracer
*
trc_
;
TracingContext
prev_
;
public
:
explicit
AutoClearTracingContext
(
JSTracer
*
trc
)
:
trc_
(
trc
)
prev_
(
trc
-
>
context
(
)
)
{
trc_
-
>
context
(
)
=
TracingContext
(
)
;
}
~
AutoClearTracingContext
(
)
{
trc_
-
>
context
(
)
=
prev_
;
}
}
;
}
js
:
:
GenericTracer
*
JSTracer
:
:
asGenericTracer
(
)
{
MOZ_ASSERT
(
isGenericTracer
(
)
)
;
return
static_cast
<
js
:
:
GenericTracer
*
>
(
this
)
;
}
JS
:
:
CallbackTracer
*
JSTracer
:
:
asCallbackTracer
(
)
{
MOZ_ASSERT
(
isCallbackTracer
(
)
)
;
return
static_cast
<
JS
:
:
CallbackTracer
*
>
(
this
)
;
}
namespace
js
{
class
AbstractGeneratorObject
;
class
SavedFrame
;
namespace
gc
{
#
define
JS_DECLARE_TRACE_EXTERNAL_EDGE
(
type
)
\
extern
JS_PUBLIC_API
void
TraceExternalEdge
(
JSTracer
*
trc
type
*
thingp
\
const
char
*
name
)
;
JS_FOR_EACH_PUBLIC_GC_POINTER_TYPE
(
JS_DECLARE_TRACE_EXTERNAL_EDGE
)
JS_FOR_EACH_PUBLIC_TAGGED_GC_POINTER_TYPE
(
JS_DECLARE_TRACE_EXTERNAL_EDGE
)
#
undef
JS_DECLARE_TRACE_EXTERNAL_EDGE
}
}
namespace
JS
{
template
<
typename
T
>
inline
void
TraceEdge
(
JSTracer
*
trc
JS
:
:
Heap
<
T
>
*
thingp
const
char
*
name
)
{
MOZ_ASSERT
(
thingp
)
;
if
(
*
thingp
)
{
js
:
:
gc
:
:
TraceExternalEdge
(
trc
thingp
-
>
unsafeGet
(
)
name
)
;
}
}
template
<
typename
T
>
inline
void
TraceEdge
(
JSTracer
*
trc
JS
:
:
TenuredHeap
<
T
>
*
thingp
const
char
*
name
)
{
MOZ_ASSERT
(
thingp
)
;
if
(
T
ptr
=
thingp
-
>
unbarrieredGetPtr
(
)
)
{
js
:
:
gc
:
:
TraceExternalEdge
(
trc
&
ptr
name
)
;
thingp
-
>
unbarrieredSetPtr
(
ptr
)
;
}
}
#
define
JS_DECLARE_UNSAFE_TRACE_ROOT
(
type
)
\
extern
JS_PUBLIC_API
void
UnsafeTraceRoot
(
JSTracer
*
trc
type
*
edgep
\
const
char
*
name
)
;
JS_FOR_EACH_PUBLIC_GC_POINTER_TYPE
(
JS_DECLARE_UNSAFE_TRACE_ROOT
)
JS_FOR_EACH_PUBLIC_TAGGED_GC_POINTER_TYPE
(
JS_DECLARE_UNSAFE_TRACE_ROOT
)
JS_DECLARE_UNSAFE_TRACE_ROOT
(
js
:
:
AbstractGeneratorObject
*
)
JS_DECLARE_UNSAFE_TRACE_ROOT
(
js
:
:
SavedFrame
*
)
#
undef
JS_DECLARE_UNSAFE_TRACE_ROOT
extern
JS_PUBLIC_API
void
TraceChildren
(
JSTracer
*
trc
GCCellPtr
thing
)
;
}
namespace
js
{
inline
bool
IsTracerKind
(
JSTracer
*
trc
JS
:
:
TracerKind
kind
)
{
return
trc
-
>
kind
(
)
=
=
kind
;
}
extern
JS_PUBLIC_API
void
UnsafeTraceManuallyBarrieredEdge
(
JSTracer
*
trc
JSObject
*
*
edgep
const
char
*
name
)
;
template
<
typename
T
>
inline
bool
TraceManuallyBarrieredWeakEdge
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
;
template
<
typename
T
>
class
WeakHeapPtr
;
template
<
typename
T
>
inline
bool
TraceWeakEdge
(
JSTracer
*
trc
WeakHeapPtr
<
T
>
*
thingp
const
char
*
name
)
;
namespace
gc
{
template
<
typename
T
>
extern
JS_PUBLIC_API
bool
EdgeNeedsSweep
(
JS
:
:
Heap
<
T
>
*
edgep
)
;
template
<
typename
T
>
bool
IsAboutToBeFinalizedUnbarriered
(
T
*
thingp
)
;
}
#
ifdef
DEBUG
extern
JS_PUBLIC_API
bool
RuntimeIsBeingDestroyed
(
)
;
#
endif
}
#
endif
