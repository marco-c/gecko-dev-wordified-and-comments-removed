#
ifndef
js_TracingAPI_h
#
define
js_TracingAPI_h
#
include
"
js
/
GCTypeMacros
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
TraceKind
.
h
"
class
JS_PUBLIC_API
JSTracer
;
namespace
JS
{
class
JS_PUBLIC_API
CallbackTracer
;
template
<
typename
T
>
class
Heap
;
template
<
typename
T
>
class
TenuredHeap
;
JS_FRIEND_API
const
char
*
GCTraceKindToAscii
(
JS
:
:
TraceKind
kind
)
;
JS_FRIEND_API
size_t
GCTraceKindSize
(
JS
:
:
TraceKind
kind
)
;
enum
class
TracerKind
{
Marking
Tenuring
Generic
Moving
GrayBuffering
ClearEdges
Sweeping
Callback
UnmarkGray
VerifyTraceProtoAndIface
}
;
enum
class
WeakMapTraceAction
{
Skip
Expand
TraceValues
TraceKeysAndValues
}
;
class
AutoTracingName
;
class
AutoTracingIndex
;
class
AutoTracingCallback
;
class
TracingContext
{
public
:
const
char
*
name
(
)
const
{
MOZ_ASSERT
(
name_
)
;
return
name_
;
}
constexpr
static
size_t
InvalidIndex
=
size_t
(
-
1
)
;
size_t
index
(
)
const
{
return
index_
;
}
void
getEdgeName
(
char
*
buffer
size_t
bufferSize
)
;
class
Functor
{
public
:
virtual
void
operator
(
)
(
TracingContext
*
tcx
char
*
buf
size_t
bufsize
)
=
0
;
}
;
private
:
friend
class
AutoTracingName
;
const
char
*
name_
=
nullptr
;
friend
class
AutoTracingIndex
;
size_t
index_
=
InvalidIndex
;
friend
class
AutoTracingDetails
;
Functor
*
functor_
=
nullptr
;
}
;
}
namespace
js
{
class
GenericTracer
;
}
class
JS_PUBLIC_API
JSTracer
{
public
:
JSRuntime
*
runtime
(
)
const
{
return
runtime_
;
}
JS
:
:
TracingContext
*
maybeContext
(
)
{
return
maybeContext_
;
}
JS
:
:
TracerKind
kind
(
)
const
{
return
kind_
;
}
bool
isMarkingTracer
(
)
const
{
return
kind_
=
=
JS
:
:
TracerKind
:
:
Marking
;
}
bool
isTenuringTracer
(
)
const
{
return
kind_
=
=
JS
:
:
TracerKind
:
:
Tenuring
;
}
bool
isGenericTracer
(
)
const
{
return
kind_
>
=
JS
:
:
TracerKind
:
:
Generic
;
}
bool
isCallbackTracer
(
)
const
{
return
kind_
>
=
JS
:
:
TracerKind
:
:
Callback
;
}
JS
:
:
WeakMapTraceAction
weakMapAction
(
)
const
{
return
weakMapAction_
;
}
inline
js
:
:
GenericTracer
*
asGenericTracer
(
)
;
inline
JS
:
:
CallbackTracer
*
asCallbackTracer
(
)
;
bool
traceWeakEdges
(
)
const
{
return
traceWeakEdges_
;
}
bool
canSkipJsids
(
)
const
{
return
canSkipJsids_
;
}
#
ifdef
DEBUG
bool
checkEdges
(
)
{
return
checkEdges_
;
}
#
endif
uint32_t
gcNumberForMarking
(
)
const
;
protected
:
JSTracer
(
JSRuntime
*
rt
JS
:
:
TracerKind
kind
JS
:
:
WeakMapTraceAction
weakMapAction
=
JS
:
:
WeakMapTraceAction
:
:
TraceValues
)
:
runtime_
(
rt
)
kind_
(
kind
)
weakMapAction_
(
weakMapAction
)
{
}
void
setContext
(
JS
:
:
TracingContext
*
tcx
)
{
maybeContext_
=
tcx
;
}
void
setTraceWeakEdges
(
bool
value
)
{
traceWeakEdges_
=
value
;
}
void
setCanSkipJsids
(
bool
value
)
{
canSkipJsids_
=
value
;
}
#
ifdef
DEBUG
void
setCheckEdges
(
bool
check
)
{
checkEdges_
=
check
;
}
#
endif
private
:
JSRuntime
*
const
runtime_
;
JS
:
:
TracingContext
*
maybeContext_
=
nullptr
;
const
JS
:
:
TracerKind
kind_
;
const
JS
:
:
WeakMapTraceAction
weakMapAction_
;
bool
traceWeakEdges_
=
true
;
bool
canSkipJsids_
=
false
;
#
ifdef
DEBUG
bool
checkEdges_
=
true
;
#
endif
}
;
namespace
js
{
class
GenericTracer
:
public
JSTracer
{
public
:
GenericTracer
(
JSRuntime
*
rt
JS
:
:
TracerKind
kind
=
JS
:
:
TracerKind
:
:
Generic
JS
:
:
WeakMapTraceAction
weakMapAction
=
JS
:
:
WeakMapTraceAction
:
:
TraceValues
)
:
JSTracer
(
rt
kind
weakMapAction
)
{
MOZ_ASSERT
(
isGenericTracer
(
)
)
;
}
virtual
bool
onObjectEdge
(
JSObject
*
*
objp
)
=
0
;
virtual
bool
onStringEdge
(
JSString
*
*
strp
)
=
0
;
virtual
bool
onSymbolEdge
(
JS
:
:
Symbol
*
*
symp
)
=
0
;
virtual
bool
onBigIntEdge
(
JS
:
:
BigInt
*
*
bip
)
=
0
;
virtual
bool
onScriptEdge
(
js
:
:
BaseScript
*
*
scriptp
)
=
0
;
virtual
bool
onShapeEdge
(
js
:
:
Shape
*
*
shapep
)
=
0
;
virtual
bool
onRegExpSharedEdge
(
js
:
:
RegExpShared
*
*
sharedp
)
=
0
;
virtual
bool
onObjectGroupEdge
(
js
:
:
ObjectGroup
*
*
groupp
)
=
0
;
virtual
bool
onBaseShapeEdge
(
js
:
:
BaseShape
*
*
basep
)
=
0
;
virtual
bool
onJitCodeEdge
(
js
:
:
jit
:
:
JitCode
*
*
codep
)
=
0
;
virtual
bool
onScopeEdge
(
js
:
:
Scope
*
*
scopep
)
=
0
;
bool
dispatchToOnEdge
(
JSObject
*
*
objp
)
{
return
onObjectEdge
(
objp
)
;
}
bool
dispatchToOnEdge
(
JSString
*
*
strp
)
{
return
onStringEdge
(
strp
)
;
}
bool
dispatchToOnEdge
(
JS
:
:
Symbol
*
*
symp
)
{
return
onSymbolEdge
(
symp
)
;
}
bool
dispatchToOnEdge
(
JS
:
:
BigInt
*
*
bip
)
{
return
onBigIntEdge
(
bip
)
;
}
bool
dispatchToOnEdge
(
js
:
:
BaseScript
*
*
scriptp
)
{
return
onScriptEdge
(
scriptp
)
;
}
bool
dispatchToOnEdge
(
js
:
:
Shape
*
*
shapep
)
{
return
onShapeEdge
(
shapep
)
;
}
bool
dispatchToOnEdge
(
js
:
:
ObjectGroup
*
*
groupp
)
{
return
onObjectGroupEdge
(
groupp
)
;
}
bool
dispatchToOnEdge
(
js
:
:
BaseShape
*
*
basep
)
{
return
onBaseShapeEdge
(
basep
)
;
}
bool
dispatchToOnEdge
(
js
:
:
jit
:
:
JitCode
*
*
codep
)
{
return
onJitCodeEdge
(
codep
)
;
}
bool
dispatchToOnEdge
(
js
:
:
Scope
*
*
scopep
)
{
return
onScopeEdge
(
scopep
)
;
}
bool
dispatchToOnEdge
(
js
:
:
RegExpShared
*
*
sharedp
)
{
return
onRegExpSharedEdge
(
sharedp
)
;
}
}
;
}
namespace
JS
{
class
JS_PUBLIC_API
CallbackTracer
:
public
js
:
:
GenericTracer
{
public
:
CallbackTracer
(
JSRuntime
*
rt
JS
:
:
TracerKind
kind
=
JS
:
:
TracerKind
:
:
Callback
WeakMapTraceAction
weakMapAction
=
WeakMapTraceAction
:
:
TraceValues
)
:
GenericTracer
(
rt
kind
weakMapAction
)
{
MOZ_ASSERT
(
isCallbackTracer
(
)
)
;
setContext
(
&
context_
)
;
}
CallbackTracer
(
JSContext
*
cx
JS
:
:
TracerKind
kind
=
JS
:
:
TracerKind
:
:
Callback
WeakMapTraceAction
weakMapAction
=
WeakMapTraceAction
:
:
TraceValues
)
;
TracingContext
&
context
(
)
{
return
context_
;
}
virtual
void
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
=
0
;
private
:
virtual
bool
onObjectEdge
(
JSObject
*
*
objp
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
objp
)
)
;
return
true
;
}
virtual
bool
onStringEdge
(
JSString
*
*
strp
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
strp
)
)
;
return
true
;
}
virtual
bool
onSymbolEdge
(
JS
:
:
Symbol
*
*
symp
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
symp
)
)
;
return
true
;
}
virtual
bool
onBigIntEdge
(
JS
:
:
BigInt
*
*
bip
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
bip
)
)
;
return
true
;
}
virtual
bool
onScriptEdge
(
js
:
:
BaseScript
*
*
scriptp
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
scriptp
)
)
;
return
true
;
}
virtual
bool
onShapeEdge
(
js
:
:
Shape
*
*
shapep
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
shapep
JS
:
:
TraceKind
:
:
Shape
)
)
;
return
true
;
}
virtual
bool
onObjectGroupEdge
(
js
:
:
ObjectGroup
*
*
groupp
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
groupp
JS
:
:
TraceKind
:
:
ObjectGroup
)
)
;
return
true
;
}
virtual
bool
onBaseShapeEdge
(
js
:
:
BaseShape
*
*
basep
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
basep
JS
:
:
TraceKind
:
:
BaseShape
)
)
;
return
true
;
}
virtual
bool
onJitCodeEdge
(
js
:
:
jit
:
:
JitCode
*
*
codep
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
codep
JS
:
:
TraceKind
:
:
JitCode
)
)
;
return
true
;
}
virtual
bool
onScopeEdge
(
js
:
:
Scope
*
*
scopep
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
scopep
JS
:
:
TraceKind
:
:
Scope
)
)
;
return
true
;
}
virtual
bool
onRegExpSharedEdge
(
js
:
:
RegExpShared
*
*
sharedp
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
sharedp
JS
:
:
TraceKind
:
:
RegExpShared
)
)
;
return
true
;
}
TracingContext
context_
;
}
;
class
MOZ_RAII
AutoTracingName
{
TracingContext
*
tcx_
=
nullptr
;
const
char
*
prior_
=
nullptr
;
public
:
AutoTracingName
(
JSTracer
*
trc
const
char
*
name
)
{
MOZ_ASSERT
(
name
)
;
if
(
TracingContext
*
tcx
=
trc
-
>
maybeContext
(
)
)
{
tcx_
=
tcx
;
prior_
=
tcx_
-
>
name_
;
tcx_
-
>
name_
=
name
;
}
}
~
AutoTracingName
(
)
{
if
(
tcx_
)
{
MOZ_ASSERT
(
tcx_
-
>
name_
)
;
tcx_
-
>
name_
=
prior_
;
}
}
}
;
class
MOZ_RAII
AutoTracingIndex
{
TracingContext
*
tcx_
=
nullptr
;
public
:
explicit
AutoTracingIndex
(
JSTracer
*
trc
size_t
initial
=
0
)
{
if
(
TracingContext
*
tcx
=
trc
-
>
maybeContext
(
)
)
{
tcx_
=
tcx
;
MOZ_ASSERT
(
tcx_
-
>
index_
=
=
TracingContext
:
:
InvalidIndex
)
;
tcx_
-
>
index_
=
initial
;
}
}
~
AutoTracingIndex
(
)
{
if
(
tcx_
)
{
MOZ_ASSERT
(
tcx_
-
>
index_
!
=
TracingContext
:
:
InvalidIndex
)
;
tcx_
-
>
index_
=
TracingContext
:
:
InvalidIndex
;
}
}
void
operator
+
+
(
)
{
if
(
tcx_
)
{
MOZ_ASSERT
(
tcx_
-
>
index_
!
=
TracingContext
:
:
InvalidIndex
)
;
+
+
tcx_
-
>
index_
;
}
}
}
;
class
MOZ_RAII
AutoTracingDetails
{
TracingContext
*
tcx_
=
nullptr
;
public
:
AutoTracingDetails
(
JSTracer
*
trc
TracingContext
:
:
Functor
&
func
)
{
if
(
TracingContext
*
tcx
=
trc
-
>
maybeContext
(
)
)
{
tcx_
=
tcx
;
MOZ_ASSERT
(
tcx_
-
>
functor_
=
=
nullptr
)
;
tcx_
-
>
functor_
=
&
func
;
}
}
~
AutoTracingDetails
(
)
{
if
(
tcx_
)
{
MOZ_ASSERT
(
tcx_
-
>
functor_
)
;
tcx_
-
>
functor_
=
nullptr
;
}
}
}
;
}
js
:
:
GenericTracer
*
JSTracer
:
:
asGenericTracer
(
)
{
MOZ_ASSERT
(
isGenericTracer
(
)
)
;
return
static_cast
<
js
:
:
GenericTracer
*
>
(
this
)
;
}
JS
:
:
CallbackTracer
*
JSTracer
:
:
asCallbackTracer
(
)
{
MOZ_ASSERT
(
isCallbackTracer
(
)
)
;
return
static_cast
<
JS
:
:
CallbackTracer
*
>
(
this
)
;
}
namespace
js
{
class
AbstractGeneratorObject
;
class
SavedFrame
;
namespace
gc
{
#
define
JS_DECLARE_TRACE_EXTERNAL_EDGE
(
type
)
\
extern
JS_PUBLIC_API
void
TraceExternalEdge
(
JSTracer
*
trc
type
*
thingp
\
const
char
*
name
)
;
JS_FOR_EACH_PUBLIC_GC_POINTER_TYPE
(
JS_DECLARE_TRACE_EXTERNAL_EDGE
)
JS_FOR_EACH_PUBLIC_TAGGED_GC_POINTER_TYPE
(
JS_DECLARE_TRACE_EXTERNAL_EDGE
)
#
undef
JS_DECLARE_TRACE_EXTERNAL_EDGE
}
}
namespace
JS
{
template
<
typename
T
>
inline
void
TraceEdge
(
JSTracer
*
trc
JS
:
:
Heap
<
T
>
*
thingp
const
char
*
name
)
{
MOZ_ASSERT
(
thingp
)
;
if
(
*
thingp
)
{
js
:
:
gc
:
:
TraceExternalEdge
(
trc
thingp
-
>
unsafeGet
(
)
name
)
;
}
}
template
<
typename
T
>
inline
void
TraceEdge
(
JSTracer
*
trc
JS
:
:
TenuredHeap
<
T
>
*
thingp
const
char
*
name
)
{
MOZ_ASSERT
(
thingp
)
;
if
(
T
ptr
=
thingp
-
>
unbarrieredGetPtr
(
)
)
{
js
:
:
gc
:
:
TraceExternalEdge
(
trc
&
ptr
name
)
;
thingp
-
>
setPtr
(
ptr
)
;
}
}
#
define
JS_DECLARE_UNSAFE_TRACE_ROOT
(
type
)
\
extern
JS_PUBLIC_API
void
UnsafeTraceRoot
(
JSTracer
*
trc
type
*
edgep
\
const
char
*
name
)
;
JS_FOR_EACH_PUBLIC_GC_POINTER_TYPE
(
JS_DECLARE_UNSAFE_TRACE_ROOT
)
JS_FOR_EACH_PUBLIC_TAGGED_GC_POINTER_TYPE
(
JS_DECLARE_UNSAFE_TRACE_ROOT
)
JS_DECLARE_UNSAFE_TRACE_ROOT
(
js
:
:
AbstractGeneratorObject
*
)
JS_DECLARE_UNSAFE_TRACE_ROOT
(
js
:
:
SavedFrame
*
)
#
undef
JS_DECLARE_UNSAFE_TRACE_ROOT
extern
JS_PUBLIC_API
void
TraceChildren
(
JSTracer
*
trc
GCCellPtr
thing
)
;
}
namespace
js
{
inline
bool
IsTracerKind
(
JSTracer
*
trc
JS
:
:
TracerKind
kind
)
{
return
trc
-
>
kind
(
)
=
=
kind
;
}
extern
JS_PUBLIC_API
void
UnsafeTraceManuallyBarrieredEdge
(
JSTracer
*
trc
JSObject
*
*
edgep
const
char
*
name
)
;
template
<
typename
T
>
inline
bool
TraceManuallyBarrieredWeakEdge
(
JSTracer
*
trc
T
*
thingp
const
char
*
name
)
;
template
<
typename
T
>
class
BarrieredBase
;
template
<
typename
T
>
inline
bool
TraceWeakEdge
(
JSTracer
*
trc
BarrieredBase
<
T
>
*
thingp
const
char
*
name
)
;
namespace
gc
{
template
<
typename
T
>
extern
JS_PUBLIC_API
bool
EdgeNeedsSweep
(
JS
:
:
Heap
<
T
>
*
edgep
)
;
template
<
typename
T
>
bool
IsAboutToBeFinalizedUnbarriered
(
T
*
thingp
)
;
}
#
ifdef
DEBUG
extern
JS_FRIEND_API
bool
RuntimeIsBeingDestroyed
(
)
;
#
endif
}
#
endif
