#
ifndef
js_TracingAPI_h
#
define
js_TracingAPI_h
#
include
"
jsalloc
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
TraceKind
.
h
"
class
JS_PUBLIC_API
(
JSTracer
)
;
namespace
JS
{
class
JS_PUBLIC_API
(
CallbackTracer
)
;
template
<
typename
T
>
class
Heap
;
template
<
typename
T
>
class
TenuredHeap
;
JS_FRIEND_API
(
const
char
*
)
GCTraceKindToAscii
(
JS
:
:
TraceKind
kind
)
;
}
enum
WeakMapTraceKind
{
DoNotTraceWeakMaps
ExpandWeakMaps
TraceWeakMapValues
TraceWeakMapKeysValues
}
;
class
JS_PUBLIC_API
(
JSTracer
)
{
public
:
JSRuntime
*
runtime
(
)
const
{
return
runtime_
;
}
WeakMapTraceKind
weakMapAction
(
)
const
{
return
weakMapAction_
;
}
enum
class
TracerKindTag
{
Marking
WeakMarking
Tenuring
Callback
}
;
bool
isMarkingTracer
(
)
const
{
return
tag_
=
=
TracerKindTag
:
:
Marking
|
|
tag_
=
=
TracerKindTag
:
:
WeakMarking
;
}
bool
isWeakMarkingTracer
(
)
const
{
return
tag_
=
=
TracerKindTag
:
:
WeakMarking
;
}
bool
isTenuringTracer
(
)
const
{
return
tag_
=
=
TracerKindTag
:
:
Tenuring
;
}
bool
isCallbackTracer
(
)
const
{
return
tag_
=
=
TracerKindTag
:
:
Callback
;
}
inline
JS
:
:
CallbackTracer
*
asCallbackTracer
(
)
;
protected
:
JSTracer
(
JSRuntime
*
rt
TracerKindTag
tag
WeakMapTraceKind
weakTraceKind
=
TraceWeakMapValues
)
:
runtime_
(
rt
)
weakMapAction_
(
weakTraceKind
)
tag_
(
tag
)
{
}
private
:
JSRuntime
*
runtime_
;
WeakMapTraceKind
weakMapAction_
;
protected
:
TracerKindTag
tag_
;
}
;
namespace
JS
{
class
AutoTracingName
;
class
AutoTracingIndex
;
class
AutoTracingCallback
;
class
JS_PUBLIC_API
(
CallbackTracer
)
:
public
JSTracer
{
public
:
CallbackTracer
(
JSRuntime
*
rt
WeakMapTraceKind
weakTraceKind
=
TraceWeakMapValues
)
:
JSTracer
(
rt
JSTracer
:
:
TracerKindTag
:
:
Callback
weakTraceKind
)
contextName_
(
nullptr
)
contextIndex_
(
InvalidIndex
)
contextFunctor_
(
nullptr
)
{
}
virtual
void
onObjectEdge
(
JSObject
*
*
objp
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
objp
)
)
;
}
virtual
void
onStringEdge
(
JSString
*
*
strp
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
strp
)
)
;
}
virtual
void
onSymbolEdge
(
JS
:
:
Symbol
*
*
symp
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
symp
)
)
;
}
virtual
void
onScriptEdge
(
JSScript
*
*
scriptp
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
scriptp
)
)
;
}
virtual
void
onShapeEdge
(
js
:
:
Shape
*
*
shapep
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
shapep
JS
:
:
TraceKind
:
:
Shape
)
)
;
}
virtual
void
onObjectGroupEdge
(
js
:
:
ObjectGroup
*
*
groupp
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
groupp
JS
:
:
TraceKind
:
:
ObjectGroup
)
)
;
}
virtual
void
onBaseShapeEdge
(
js
:
:
BaseShape
*
*
basep
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
basep
JS
:
:
TraceKind
:
:
BaseShape
)
)
;
}
virtual
void
onJitCodeEdge
(
js
:
:
jit
:
:
JitCode
*
*
codep
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
codep
JS
:
:
TraceKind
:
:
JitCode
)
)
;
}
virtual
void
onLazyScriptEdge
(
js
:
:
LazyScript
*
*
lazyp
)
{
onChild
(
JS
:
:
GCCellPtr
(
*
lazyp
JS
:
:
TraceKind
:
:
LazyScript
)
)
;
}
virtual
void
onChild
(
const
JS
:
:
GCCellPtr
&
thing
)
=
0
;
const
char
*
contextName
(
)
const
{
MOZ_ASSERT
(
contextName_
)
;
return
contextName_
;
}
const
static
size_t
InvalidIndex
=
size_t
(
-
1
)
;
size_t
contextIndex
(
)
const
{
return
contextIndex_
;
}
void
getTracingEdgeName
(
char
*
buffer
size_t
bufferSize
)
;
class
ContextFunctor
{
public
:
virtual
void
operator
(
)
(
CallbackTracer
*
trc
char
*
buf
size_t
bufsize
)
=
0
;
}
;
#
ifdef
DEBUG
enum
class
TracerKind
{
DoNotCare
Moving
GrayBuffering
VerifyTraceProtoAndIface
}
;
virtual
TracerKind
getTracerKind
(
)
const
{
return
TracerKind
:
:
DoNotCare
;
}
#
endif
void
dispatchToOnEdge
(
JSObject
*
*
objp
)
{
onObjectEdge
(
objp
)
;
}
void
dispatchToOnEdge
(
JSString
*
*
strp
)
{
onStringEdge
(
strp
)
;
}
void
dispatchToOnEdge
(
JS
:
:
Symbol
*
*
symp
)
{
onSymbolEdge
(
symp
)
;
}
void
dispatchToOnEdge
(
JSScript
*
*
scriptp
)
{
onScriptEdge
(
scriptp
)
;
}
void
dispatchToOnEdge
(
js
:
:
Shape
*
*
shapep
)
{
onShapeEdge
(
shapep
)
;
}
void
dispatchToOnEdge
(
js
:
:
ObjectGroup
*
*
groupp
)
{
onObjectGroupEdge
(
groupp
)
;
}
void
dispatchToOnEdge
(
js
:
:
BaseShape
*
*
basep
)
{
onBaseShapeEdge
(
basep
)
;
}
void
dispatchToOnEdge
(
js
:
:
jit
:
:
JitCode
*
*
codep
)
{
onJitCodeEdge
(
codep
)
;
}
void
dispatchToOnEdge
(
js
:
:
LazyScript
*
*
lazyp
)
{
onLazyScriptEdge
(
lazyp
)
;
}
private
:
friend
class
AutoTracingName
;
const
char
*
contextName_
;
friend
class
AutoTracingIndex
;
size_t
contextIndex_
;
friend
class
AutoTracingDetails
;
ContextFunctor
*
contextFunctor_
;
}
;
class
MOZ_RAII
AutoTracingName
{
CallbackTracer
*
trc_
;
const
char
*
prior_
;
public
:
AutoTracingName
(
CallbackTracer
*
trc
const
char
*
name
)
:
trc_
(
trc
)
prior_
(
trc
-
>
contextName_
)
{
MOZ_ASSERT
(
name
)
;
trc
-
>
contextName_
=
name
;
}
~
AutoTracingName
(
)
{
MOZ_ASSERT
(
trc_
-
>
contextName_
)
;
trc_
-
>
contextName_
=
prior_
;
}
}
;
class
MOZ_RAII
AutoTracingIndex
{
CallbackTracer
*
trc_
;
public
:
explicit
AutoTracingIndex
(
JSTracer
*
trc
size_t
initial
=
0
)
:
trc_
(
nullptr
)
{
if
(
trc
-
>
isCallbackTracer
(
)
)
{
trc_
=
trc
-
>
asCallbackTracer
(
)
;
MOZ_ASSERT
(
trc_
-
>
contextIndex_
=
=
CallbackTracer
:
:
InvalidIndex
)
;
trc_
-
>
contextIndex_
=
initial
;
}
}
~
AutoTracingIndex
(
)
{
if
(
trc_
)
{
MOZ_ASSERT
(
trc_
-
>
contextIndex_
!
=
CallbackTracer
:
:
InvalidIndex
)
;
trc_
-
>
contextIndex_
=
CallbackTracer
:
:
InvalidIndex
;
}
}
void
operator
+
+
(
)
{
if
(
trc_
)
{
MOZ_ASSERT
(
trc_
-
>
contextIndex_
!
=
CallbackTracer
:
:
InvalidIndex
)
;
+
+
trc_
-
>
contextIndex_
;
}
}
}
;
class
MOZ_RAII
AutoTracingDetails
{
CallbackTracer
*
trc_
;
public
:
AutoTracingDetails
(
JSTracer
*
trc
CallbackTracer
:
:
ContextFunctor
&
func
)
:
trc_
(
nullptr
)
{
if
(
trc
-
>
isCallbackTracer
(
)
)
{
trc_
=
trc
-
>
asCallbackTracer
(
)
;
MOZ_ASSERT
(
trc_
-
>
contextFunctor_
=
=
nullptr
)
;
trc_
-
>
contextFunctor_
=
&
func
;
}
}
~
AutoTracingDetails
(
)
{
if
(
trc_
)
{
MOZ_ASSERT
(
trc_
-
>
contextFunctor_
)
;
trc_
-
>
contextFunctor_
=
nullptr
;
}
}
}
;
}
JS
:
:
CallbackTracer
*
JSTracer
:
:
asCallbackTracer
(
)
{
MOZ_ASSERT
(
isCallbackTracer
(
)
)
;
return
static_cast
<
JS
:
:
CallbackTracer
*
>
(
this
)
;
}
namespace
JS
{
template
<
typename
T
>
extern
JS_PUBLIC_API
(
void
)
TraceEdge
(
JSTracer
*
trc
JS
:
:
Heap
<
T
>
*
edgep
const
char
*
name
)
;
template
<
typename
T
>
extern
JS_PUBLIC_API
(
void
)
TraceNullableEdge
(
JSTracer
*
trc
JS
:
:
Heap
<
T
>
*
edgep
const
char
*
name
)
;
extern
JS_PUBLIC_API
(
void
)
TraceNullableEdge
(
JSTracer
*
trc
JS
:
:
TenuredHeap
<
JSObject
*
>
*
edgep
const
char
*
name
)
;
template
<
typename
T
>
extern
JS_PUBLIC_API
(
void
)
UnsafeTraceRoot
(
JSTracer
*
trc
T
*
edgep
const
char
*
name
)
;
extern
JS_PUBLIC_API
(
void
)
TraceChildren
(
JSTracer
*
trc
GCCellPtr
thing
)
;
typedef
js
:
:
HashSet
<
Zone
*
js
:
:
DefaultHasher
<
Zone
*
>
js
:
:
SystemAllocPolicy
>
ZoneSet
;
}
extern
JS_PUBLIC_API
(
void
)
JS_TraceIncomingCCWs
(
JSTracer
*
trc
const
JS
:
:
ZoneSet
&
zones
)
;
extern
JS_PUBLIC_API
(
void
)
JS_GetTraceThingInfo
(
char
*
buf
size_t
bufsize
JSTracer
*
trc
void
*
thing
JS
:
:
TraceKind
kind
bool
includeDetails
)
;
namespace
js
{
template
<
typename
T
>
extern
JS_PUBLIC_API
(
void
)
UnsafeTraceManuallyBarrieredEdge
(
JSTracer
*
trc
T
*
edgep
const
char
*
name
)
;
namespace
gc
{
template
<
typename
T
>
extern
JS_PUBLIC_API
(
bool
)
EdgeNeedsSweep
(
JS
:
:
Heap
<
T
>
*
edgep
)
;
}
template
<
typename
>
struct
DefaultGCPolicy
;
template
<
typename
T
>
struct
StructGCPolicy
{
static
void
trace
(
JSTracer
*
trc
T
*
t
const
char
*
name
)
{
t
-
>
trace
(
trc
)
;
}
static
bool
needsSweep
(
T
*
t
)
{
return
t
-
>
needsSweep
(
)
;
}
}
;
template
<
typename
T
>
struct
IgnoreGCPolicy
{
static
void
trace
(
JSTracer
*
trc
T
*
t
const
char
*
name
)
{
}
static
bool
needsSweep
(
T
*
v
)
{
return
false
;
}
}
;
template
<
typename
T
>
struct
DefaultGCPolicy
:
public
StructGCPolicy
<
T
>
{
}
;
template
<
>
struct
DefaultGCPolicy
<
jsid
>
{
static
void
trace
(
JSTracer
*
trc
jsid
*
idp
const
char
*
name
)
{
js
:
:
UnsafeTraceManuallyBarrieredEdge
(
trc
idp
name
)
;
}
}
;
template
<
>
struct
DefaultGCPolicy
<
JS
:
:
Value
>
{
static
void
trace
(
JSTracer
*
trc
JS
:
:
Value
*
v
const
char
*
name
)
{
js
:
:
UnsafeTraceManuallyBarrieredEdge
(
trc
v
name
)
;
}
}
;
template
<
>
struct
DefaultGCPolicy
<
uint32_t
>
:
public
IgnoreGCPolicy
<
uint32_t
>
{
}
;
template
<
>
struct
DefaultGCPolicy
<
uint64_t
>
:
public
IgnoreGCPolicy
<
uint64_t
>
{
}
;
template
<
typename
T
>
struct
DefaultGCPolicy
<
JS
:
:
Heap
<
T
>
>
{
static
void
trace
(
JSTracer
*
trc
JS
:
:
Heap
<
T
>
*
thingp
const
char
*
name
)
{
JS
:
:
TraceEdge
(
trc
thingp
name
)
;
}
static
bool
needsSweep
(
JS
:
:
Heap
<
T
>
*
thingp
)
{
return
gc
:
:
EdgeNeedsSweep
(
thingp
)
;
}
}
;
}
#
endif
