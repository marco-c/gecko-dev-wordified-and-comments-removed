#
ifndef
js_ErrorReport_h
#
define
js_ErrorReport_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
iterator
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
#
include
"
js
/
Vector
.
h
"
struct
JS_PUBLIC_API
JSContext
;
class
JS_PUBLIC_API
JSString
;
enum
JSExnType
{
JSEXN_ERR
JSEXN_FIRST
=
JSEXN_ERR
JSEXN_INTERNALERR
JSEXN_EVALERR
JSEXN_RANGEERR
JSEXN_REFERENCEERR
JSEXN_SYNTAXERR
JSEXN_TYPEERR
JSEXN_URIERR
JSEXN_DEBUGGEEWOULDRUN
JSEXN_WASMCOMPILEERROR
JSEXN_WASMLINKERROR
JSEXN_WASMRUNTIMEERROR
JSEXN_ERROR_LIMIT
JSEXN_WARN
=
JSEXN_ERROR_LIMIT
JSEXN_NOTE
JSEXN_LIMIT
}
;
struct
JSErrorFormatString
{
const
char
*
name
;
const
char
*
format
;
uint16_t
argCount
;
int16_t
exnType
;
}
;
using
JSErrorCallback
=
const
JSErrorFormatString
*
(
*
)
(
void
*
userRef
const
unsigned
errorNumber
)
;
class
JSErrorBase
{
private
:
JS
:
:
ConstUTF8CharsZ
message_
;
public
:
const
char
*
filename
;
unsigned
sourceId
;
unsigned
lineno
;
unsigned
column
;
unsigned
errorNumber
;
private
:
bool
ownsMessage_
:
1
;
public
:
JSErrorBase
(
)
:
filename
(
nullptr
)
sourceId
(
0
)
lineno
(
0
)
column
(
0
)
errorNumber
(
0
)
ownsMessage_
(
false
)
{
}
~
JSErrorBase
(
)
{
freeMessage
(
)
;
}
public
:
const
JS
:
:
ConstUTF8CharsZ
message
(
)
const
{
return
message_
;
}
void
initOwnedMessage
(
const
char
*
messageArg
)
{
initBorrowedMessage
(
messageArg
)
;
ownsMessage_
=
true
;
}
void
initBorrowedMessage
(
const
char
*
messageArg
)
{
MOZ_ASSERT
(
!
message_
)
;
message_
=
JS
:
:
ConstUTF8CharsZ
(
messageArg
strlen
(
messageArg
)
)
;
}
JSString
*
newMessageString
(
JSContext
*
cx
)
;
private
:
void
freeMessage
(
)
;
}
;
class
JSErrorNotes
{
public
:
class
Note
final
:
public
JSErrorBase
{
}
;
private
:
js
:
:
Vector
<
js
:
:
UniquePtr
<
Note
>
1
js
:
:
SystemAllocPolicy
>
notes_
;
public
:
JSErrorNotes
(
)
;
~
JSErrorNotes
(
)
;
bool
addNoteASCII
(
JSContext
*
cx
const
char
*
filename
unsigned
sourceId
unsigned
lineno
unsigned
column
JSErrorCallback
errorCallback
void
*
userRef
const
unsigned
errorNumber
.
.
.
)
;
bool
addNoteLatin1
(
JSContext
*
cx
const
char
*
filename
unsigned
sourceId
unsigned
lineno
unsigned
column
JSErrorCallback
errorCallback
void
*
userRef
const
unsigned
errorNumber
.
.
.
)
;
bool
addNoteUTF8
(
JSContext
*
cx
const
char
*
filename
unsigned
sourceId
unsigned
lineno
unsigned
column
JSErrorCallback
errorCallback
void
*
userRef
const
unsigned
errorNumber
.
.
.
)
;
JS_PUBLIC_API
size_t
length
(
)
;
js
:
:
UniquePtr
<
JSErrorNotes
>
copy
(
JSContext
*
cx
)
;
class
iterator
final
{
private
:
js
:
:
UniquePtr
<
Note
>
*
note_
;
public
:
using
iterator_category
=
std
:
:
input_iterator_tag
;
using
value_type
=
js
:
:
UniquePtr
<
Note
>
;
using
difference_type
=
ptrdiff_t
;
using
pointer
=
value_type
*
;
using
reference
=
value_type
&
;
explicit
iterator
(
js
:
:
UniquePtr
<
Note
>
*
note
=
nullptr
)
:
note_
(
note
)
{
}
bool
operator
=
=
(
iterator
other
)
const
{
return
note_
=
=
other
.
note_
;
}
bool
operator
!
=
(
iterator
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
iterator
&
operator
+
+
(
)
{
note_
+
+
;
return
*
this
;
}
reference
operator
*
(
)
{
return
*
note_
;
}
}
;
JS_PUBLIC_API
iterator
begin
(
)
;
JS_PUBLIC_API
iterator
end
(
)
;
}
;
class
JSErrorReport
:
public
JSErrorBase
{
private
:
const
char16_t
*
linebuf_
;
size_t
linebufLength_
;
size_t
tokenOffset_
;
public
:
js
:
:
UniquePtr
<
JSErrorNotes
>
notes
;
unsigned
flags
;
int16_t
exnType
;
bool
isMuted
:
1
;
private
:
bool
ownsLinebuf_
:
1
;
public
:
JSErrorReport
(
)
:
linebuf_
(
nullptr
)
linebufLength_
(
0
)
tokenOffset_
(
0
)
notes
(
nullptr
)
flags
(
0
)
exnType
(
0
)
isMuted
(
false
)
ownsLinebuf_
(
false
)
{
}
~
JSErrorReport
(
)
{
freeLinebuf
(
)
;
}
public
:
const
char16_t
*
linebuf
(
)
const
{
return
linebuf_
;
}
size_t
linebufLength
(
)
const
{
return
linebufLength_
;
}
size_t
tokenOffset
(
)
const
{
return
tokenOffset_
;
}
void
initOwnedLinebuf
(
const
char16_t
*
linebufArg
size_t
linebufLengthArg
size_t
tokenOffsetArg
)
{
initBorrowedLinebuf
(
linebufArg
linebufLengthArg
tokenOffsetArg
)
;
ownsLinebuf_
=
true
;
}
void
initBorrowedLinebuf
(
const
char16_t
*
linebufArg
size_t
linebufLengthArg
size_t
tokenOffsetArg
)
;
private
:
void
freeLinebuf
(
)
;
}
;
#
define
JSREPORT_ERROR
0x0
/
*
pseudo
-
flag
for
default
case
*
/
#
define
JSREPORT_WARNING
0x1
/
*
reported
via
JS
:
:
Warn
*
*
/
#
define
JSREPORT_EXCEPTION
0x2
/
*
exception
was
thrown
*
/
#
define
JSREPORT_STRICT
0x4
/
*
error
or
warning
due
to
strict
option
*
/
#
define
JSREPORT_USER_1
0x8
/
*
user
-
defined
flag
*
/
#
define
JSREPORT_IS_WARNING
(
flags
)
(
(
(
flags
)
&
JSREPORT_WARNING
)
!
=
0
)
#
define
JSREPORT_IS_EXCEPTION
(
flags
)
(
(
(
flags
)
&
JSREPORT_EXCEPTION
)
!
=
0
)
#
define
JSREPORT_IS_STRICT
(
flags
)
(
(
(
flags
)
&
JSREPORT_STRICT
)
!
=
0
)
#
endif
