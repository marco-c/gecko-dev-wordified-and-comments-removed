#
ifndef
js_OffThreadScriptCompilation_h
#
define
js_OffThreadScriptCompilation_h
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
<
stddef
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
Transcoding
.
h
"
struct
JS_PUBLIC_API
JSContext
;
class
JS_PUBLIC_API
JSScript
;
namespace
JS
{
template
<
typename
UnitT
>
class
SourceText
;
}
namespace
mozilla
{
union
Utf8Unit
;
}
namespace
JS
{
class
OffThreadToken
;
using
OffThreadCompileCallback
=
void
(
*
)
(
OffThreadToken
*
token
void
*
callbackData
)
;
extern
JS_PUBLIC_API
bool
CanCompileOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
size_t
length
)
;
extern
JS_PUBLIC_API
OffThreadToken
*
CompileOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
SourceText
<
char16_t
>
&
srcBuf
OffThreadCompileCallback
callback
void
*
callbackData
)
;
extern
JS_PUBLIC_API
OffThreadToken
*
CompileOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
SourceText
<
mozilla
:
:
Utf8Unit
>
&
srcBuf
OffThreadCompileCallback
callback
void
*
callbackData
)
;
extern
JS_PUBLIC_API
JSScript
*
FinishOffThreadScript
(
JSContext
*
cx
OffThreadToken
*
token
)
;
extern
JS_PUBLIC_API
JSScript
*
FinishOffThreadScriptAndStartIncrementalEncoding
(
JSContext
*
cx
OffThreadToken
*
token
)
;
extern
JS_PUBLIC_API
void
CancelOffThreadScript
(
JSContext
*
cx
OffThreadToken
*
token
)
;
extern
JS_PUBLIC_API
void
CancelOffThreadCompileToStencil
(
JSContext
*
cx
OffThreadToken
*
token
)
;
extern
JS_PUBLIC_API
OffThreadToken
*
CompileOffThreadModule
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
SourceText
<
char16_t
>
&
srcBuf
OffThreadCompileCallback
callback
void
*
callbackData
)
;
extern
JS_PUBLIC_API
OffThreadToken
*
CompileOffThreadModule
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
SourceText
<
mozilla
:
:
Utf8Unit
>
&
srcBuf
OffThreadCompileCallback
callback
void
*
callbackData
)
;
extern
JS_PUBLIC_API
JSObject
*
FinishOffThreadModule
(
JSContext
*
cx
OffThreadToken
*
token
)
;
extern
JS_PUBLIC_API
void
CancelOffThreadModule
(
JSContext
*
cx
OffThreadToken
*
token
)
;
extern
JS_PUBLIC_API
bool
CanDecodeOffThread
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
size_t
length
)
;
extern
JS_PUBLIC_API
OffThreadToken
*
DecodeOffThreadScript
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
mozilla
:
:
Vector
<
uint8_t
>
&
buffer
size_t
cursor
OffThreadCompileCallback
callback
void
*
callbackData
)
;
extern
JS_PUBLIC_API
OffThreadToken
*
DecodeOffThreadScript
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
mozilla
:
:
Range
<
uint8_t
>
&
range
OffThreadCompileCallback
callback
void
*
callbackData
)
;
extern
JS_PUBLIC_API
JSScript
*
FinishOffThreadScriptDecoder
(
JSContext
*
cx
OffThreadToken
*
token
)
;
extern
JS_PUBLIC_API
void
CancelOffThreadScriptDecoder
(
JSContext
*
cx
OffThreadToken
*
token
)
;
extern
JS_PUBLIC_API
void
CancelMultiOffThreadScriptsDecoder
(
JSContext
*
cx
OffThreadToken
*
token
)
;
extern
JS_PUBLIC_API
void
SetUseOffThreadParseGlobal
(
bool
value
)
;
}
namespace
js
{
extern
bool
UseOffThreadParseGlobal
(
)
;
}
#
endif
