#
ifndef
js_experimental_CompileScript_h
#
define
js_experimental_CompileScript_h
#
include
"
jspubtd
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
experimental
/
JSStencil
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
#
include
"
js
/
Modules
.
h
"
#
include
"
js
/
Stack
.
h
"
#
include
"
js
/
UniquePtr
.
h
"
namespace
js
{
class
FrontendContext
;
namespace
frontend
{
struct
CompilationInput
;
}
}
namespace
JS
{
using
FrontendContext
=
js
:
:
FrontendContext
;
JS_PUBLIC_API
JS
:
:
FrontendContext
*
NewFrontendContext
(
)
;
JS_PUBLIC_API
void
DestroyFrontendContext
(
JS
:
:
FrontendContext
*
fc
)
;
JS_PUBLIC_API
void
SetNativeStackQuota
(
JS
:
:
FrontendContext
*
fc
JS
:
:
NativeStackSize
stackSize
)
;
JS_PUBLIC_API
JS
:
:
NativeStackSize
ThreadStackQuotaForSize
(
size_t
stackSize
)
;
JS_PUBLIC_API
bool
HadFrontendErrors
(
JS
:
:
FrontendContext
*
fc
)
;
JS_PUBLIC_API
bool
ConvertFrontendErrorsToRuntimeErrors
(
JSContext
*
cx
JS
:
:
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
;
JS_PUBLIC_API
const
JSErrorReport
*
GetFrontendErrorReport
(
JS
:
:
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
;
JS_PUBLIC_API
bool
HadFrontendOverRecursed
(
JS
:
:
FrontendContext
*
fc
)
;
JS_PUBLIC_API
bool
HadFrontendOutOfMemory
(
JS
:
:
FrontendContext
*
fc
)
;
JS_PUBLIC_API
bool
HadFrontendAllocationOverflow
(
JS
:
:
FrontendContext
*
fc
)
;
JS_PUBLIC_API
void
ClearFrontendErrors
(
JS
:
:
FrontendContext
*
fc
)
;
JS_PUBLIC_API
size_t
GetFrontendWarningCount
(
JS
:
:
FrontendContext
*
fc
)
;
JS_PUBLIC_API
const
JSErrorReport
*
GetFrontendWarningAt
(
JS
:
:
FrontendContext
*
fc
size_t
index
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
;
struct
CompilationStorage
{
private
:
JS_HAZ_NON_GC_POINTER
js
:
:
frontend
:
:
CompilationInput
*
input_
=
nullptr
;
bool
isBorrowed_
=
false
;
public
:
CompilationStorage
(
)
=
default
;
explicit
CompilationStorage
(
js
:
:
frontend
:
:
CompilationInput
*
input
)
:
input_
(
input
)
isBorrowed_
(
true
)
{
}
CompilationStorage
(
CompilationStorage
&
&
other
)
:
input_
(
other
.
input_
)
isBorrowed_
(
other
.
isBorrowed_
)
{
other
.
input_
=
nullptr
;
}
~
CompilationStorage
(
)
;
private
:
CompilationStorage
(
const
CompilationStorage
&
other
)
=
delete
;
void
operator
=
(
const
CompilationStorage
&
aOther
)
=
delete
;
public
:
bool
hasInput
(
)
{
return
!
!
input_
;
}
bool
allocateInput
(
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
;
js
:
:
frontend
:
:
CompilationInput
&
getInput
(
)
{
MOZ_ASSERT
(
hasInput
(
)
)
;
return
*
input_
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
void
trace
(
JSTracer
*
trc
)
;
}
;
extern
JS_PUBLIC_API
already_AddRefed
<
JS
:
:
Stencil
>
CompileGlobalScriptToStencil
(
JS
:
:
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
&
srcBuf
JS
:
:
CompilationStorage
&
compileStorage
)
;
extern
JS_PUBLIC_API
already_AddRefed
<
JS
:
:
Stencil
>
CompileGlobalScriptToStencil
(
JS
:
:
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
JS
:
:
CompilationStorage
&
compileStorage
)
;
extern
JS_PUBLIC_API
already_AddRefed
<
JS
:
:
Stencil
>
CompileModuleScriptToStencil
(
JS
:
:
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
&
srcBuf
JS
:
:
CompilationStorage
&
compileStorage
)
;
extern
JS_PUBLIC_API
already_AddRefed
<
JS
:
:
Stencil
>
CompileModuleScriptToStencil
(
JS
:
:
FrontendContext
*
fc
const
JS
:
:
ReadOnlyCompileOptions
&
options
JS
:
:
SourceText
<
char16_t
>
&
srcBuf
JS
:
:
CompilationStorage
&
compileStorage
)
;
extern
JS_PUBLIC_API
bool
PrepareForInstantiate
(
JS
:
:
FrontendContext
*
fc
JS
:
:
Stencil
&
stencil
JS
:
:
InstantiationStorage
&
storage
)
;
}
#
endif
