#
ifndef
js_experimental_TypedData_h
#
define
js_experimental_TypedData_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
Object
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
ScalarType
.
h
"
#
include
"
js
/
Wrapper
.
h
"
struct
JSClass
;
class
JS_PUBLIC_API
JSObject
;
namespace
JS
{
class
JS_PUBLIC_API
AutoRequireNoGC
;
}
#
define
JS_FOR_EACH_TYPED_ARRAY
(
MACRO
)
\
MACRO
(
int8_t
int8_t
Int8
)
\
MACRO
(
uint8_t
uint8_t
Uint8
)
\
MACRO
(
int16_t
int16_t
Int16
)
\
MACRO
(
uint16_t
uint16_t
Uint16
)
\
MACRO
(
int32_t
int32_t
Int32
)
\
MACRO
(
uint32_t
uint32_t
Uint32
)
\
MACRO
(
float
float
Float32
)
\
MACRO
(
double
double
Float64
)
\
MACRO
(
uint8_t
js
:
:
uint8_clamped
Uint8Clamped
)
\
MACRO
(
int64_t
int64_t
BigInt64
)
\
MACRO
(
uint64_t
uint64_t
BigUint64
)
\
MACRO
(
uint16_t
js
:
:
float16
Float16
)
#
define
DECLARE_TYPED_ARRAY_CREATION_API
(
ExternalType
NativeType
Name
)
\
extern
JS_PUBLIC_API
JSObject
*
JS_New
#
#
Name
#
#
Array
(
JSContext
*
cx
\
size_t
nelements
)
;
\
extern
JS_PUBLIC_API
JSObject
*
JS_New
#
#
Name
#
#
ArrayFromArray
(
\
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
array
)
;
\
extern
JS_PUBLIC_API
JSObject
*
JS_New
#
#
Name
#
#
ArrayWithBuffer
(
\
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
arrayBuffer
size_t
byteOffset
\
int64_t
length
)
;
JS_FOR_EACH_TYPED_ARRAY
(
DECLARE_TYPED_ARRAY_CREATION_API
)
#
undef
DECLARE_TYPED_ARRAY_CREATION_API
extern
JS_PUBLIC_API
bool
JS_IsTypedArrayObject
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
bool
JS_IsArrayBufferViewObject
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
bool
JS_GetTypedArraySharedness
(
JSObject
*
obj
)
;
namespace
js
{
extern
JS_PUBLIC_API
JSObject
*
UnwrapArrayBufferView
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
JSObject
*
UnwrapReadableStream
(
JSObject
*
obj
)
;
namespace
detail
{
constexpr
size_t
TypedArrayLengthSlot
=
1
;
constexpr
size_t
TypedArrayDataSlot
=
3
;
}
extern
JS_PUBLIC_API
void
GetArrayBufferViewLengthAndData
(
JSObject
*
obj
size_t
*
length
bool
*
isSharedMemory
uint8_t
*
*
data
)
;
}
#
define
DECLARE_GET_OBJECT_AS
(
ExternalType
NativeType
Name
)
\
extern
JS_PUBLIC_API
JSObject
*
JS_GetObjectAs
#
#
Name
#
#
Array
(
\
JSObject
*
maybeWrapped
size_t
*
length
bool
*
isSharedMemory
\
ExternalType
*
*
data
)
;
JS_FOR_EACH_TYPED_ARRAY
(
DECLARE_GET_OBJECT_AS
)
#
undef
DECLARE_GET_OBJECT_AS
extern
JS_PUBLIC_API
JSObject
*
JS_GetObjectAsArrayBufferView
(
JSObject
*
obj
size_t
*
length
bool
*
isSharedMemory
uint8_t
*
*
data
)
;
extern
JS_PUBLIC_API
JS
:
:
Scalar
:
:
Type
JS_GetArrayBufferViewType
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
size_t
JS_GetTypedArrayLength
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
size_t
JS_GetTypedArrayByteOffset
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
size_t
JS_GetTypedArrayByteLength
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
size_t
JS_GetArrayBufferViewByteLength
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
size_t
JS_GetArrayBufferViewByteOffset
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
void
*
JS_GetArrayBufferViewData
(
JSObject
*
obj
bool
*
isSharedMemory
const
JS
:
:
AutoRequireNoGC
&
)
;
extern
JS_PUBLIC_API
uint8_t
*
JS_GetArrayBufferViewFixedData
(
JSObject
*
obj
uint8_t
*
buffer
size_t
bufSize
)
;
extern
JS_PUBLIC_API
size_t
JS_MaxMovableTypedArraySize
(
)
;
extern
JS_PUBLIC_API
JSObject
*
JS_GetArrayBufferViewBuffer
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
bool
*
isSharedMemory
)
;
JS_PUBLIC_API
JSObject
*
JS_NewDataView
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
buffer
size_t
byteOffset
size_t
byteLength
)
;
namespace
JS
{
JS_PUBLIC_API
bool
IsLargeArrayBufferView
(
JSObject
*
obj
)
;
JS_PUBLIC_API
bool
IsResizableArrayBufferView
(
JSObject
*
obj
)
;
JS_PUBLIC_API
bool
PinArrayBufferOrViewLength
(
JSObject
*
obj
bool
pin
)
;
JS_PUBLIC_API
bool
EnsureNonInlineArrayBufferOrView
(
JSContext
*
cx
JSObject
*
obj
)
;
namespace
detail
{
template
<
JS
:
:
Scalar
:
:
Type
ArrayType
>
struct
ExternalTypeOf
{
}
;
#
define
DEFINE_ELEMENT_TYPES
(
ExternalT
NativeT
Name
)
\
template
<
>
\
struct
ExternalTypeOf
<
JS
:
:
Scalar
:
:
Name
>
{
\
using
Type
=
ExternalT
;
\
}
;
JS_FOR_EACH_TYPED_ARRAY
(
DEFINE_ELEMENT_TYPES
)
#
undef
DEFINE_ELEMENT_TYPES
template
<
JS
:
:
Scalar
:
:
Type
ArrayType
>
using
ExternalTypeOf_t
=
typename
ExternalTypeOf
<
ArrayType
>
:
:
Type
;
}
class
JS_PUBLIC_API
ArrayBufferOrView
{
public
:
using
DataType
=
uint8_t
;
protected
:
JSObject
*
obj
;
explicit
ArrayBufferOrView
(
JSObject
*
unwrapped
)
:
obj
(
unwrapped
)
{
}
public
:
explicit
operator
bool
(
)
const
{
return
!
!
obj
;
}
static
inline
ArrayBufferOrView
fromObject
(
JSObject
*
unwrapped
)
;
static
ArrayBufferOrView
unwrap
(
JSObject
*
maybeWrapped
)
;
void
trace
(
JSTracer
*
trc
)
{
if
(
obj
)
{
js
:
:
gc
:
:
TraceExternalEdge
(
trc
&
obj
"
ArrayBufferOrView
object
"
)
;
}
}
bool
isDetached
(
)
const
;
bool
isResizable
(
)
const
;
void
exposeToActiveJS
(
)
const
{
if
(
obj
)
{
js
:
:
BarrierMethods
<
JSObject
*
>
:
:
exposeToJS
(
obj
)
;
}
}
JSObject
*
asObject
(
)
const
{
exposeToActiveJS
(
)
;
return
obj
;
}
JSObject
*
asObjectUnbarriered
(
)
const
{
return
obj
;
}
JSObject
*
*
addressOfObject
(
)
{
return
&
obj
;
}
bool
operator
=
=
(
const
ArrayBufferOrView
&
other
)
const
{
return
obj
=
=
other
.
asObjectUnbarriered
(
)
;
}
bool
operator
!
=
(
const
ArrayBufferOrView
&
other
)
const
{
return
obj
!
=
other
.
asObjectUnbarriered
(
)
;
}
}
;
class
JS_PUBLIC_API
ArrayBuffer
:
public
ArrayBufferOrView
{
static
const
JSClass
*
const
FixedLengthUnsharedClass
;
static
const
JSClass
*
const
ResizableUnsharedClass
;
static
const
JSClass
*
const
FixedLengthSharedClass
;
static
const
JSClass
*
const
GrowableSharedClass
;
protected
:
explicit
ArrayBuffer
(
JSObject
*
unwrapped
)
:
ArrayBufferOrView
(
unwrapped
)
{
}
public
:
static
ArrayBuffer
fromObject
(
JSObject
*
unwrapped
)
{
if
(
unwrapped
)
{
const
JSClass
*
clasp
=
GetClass
(
unwrapped
)
;
if
(
clasp
=
=
FixedLengthUnsharedClass
|
|
clasp
=
=
ResizableUnsharedClass
|
|
clasp
=
=
FixedLengthSharedClass
|
|
clasp
=
=
GrowableSharedClass
)
{
return
ArrayBuffer
(
unwrapped
)
;
}
}
return
ArrayBuffer
(
nullptr
)
;
}
static
ArrayBuffer
unwrap
(
JSObject
*
maybeWrapped
)
;
static
ArrayBuffer
create
(
JSContext
*
cx
size_t
nbytes
)
;
mozilla
:
:
Span
<
uint8_t
>
getData
(
bool
*
isSharedMemory
const
JS
:
:
AutoRequireNoGC
&
)
;
}
;
class
JS_PUBLIC_API
ArrayBufferView
:
public
ArrayBufferOrView
{
protected
:
explicit
ArrayBufferView
(
JSObject
*
unwrapped
)
:
ArrayBufferOrView
(
unwrapped
)
{
}
public
:
static
inline
ArrayBufferView
fromObject
(
JSObject
*
unwrapped
)
;
static
ArrayBufferView
unwrap
(
JSObject
*
maybeWrapped
)
{
if
(
!
maybeWrapped
)
{
return
ArrayBufferView
(
nullptr
)
;
}
ArrayBufferView
view
=
fromObject
(
maybeWrapped
)
;
if
(
view
)
{
return
view
;
}
return
fromObject
(
js
:
:
CheckedUnwrapStatic
(
maybeWrapped
)
)
;
}
bool
isDetached
(
)
const
;
bool
isResizable
(
)
const
;
mozilla
:
:
Span
<
uint8_t
>
getData
(
bool
*
isSharedMemory
const
JS
:
:
AutoRequireNoGC
&
)
;
size_t
getByteLength
(
const
JS
:
:
AutoRequireNoGC
&
)
;
}
;
class
JS_PUBLIC_API
DataView
:
public
ArrayBufferView
{
static
const
JSClass
*
const
FixedLengthClassPtr
;
static
const
JSClass
*
const
ResizableClassPtr
;
protected
:
explicit
DataView
(
JSObject
*
unwrapped
)
:
ArrayBufferView
(
unwrapped
)
{
}
public
:
static
DataView
fromObject
(
JSObject
*
unwrapped
)
{
if
(
unwrapped
)
{
const
JSClass
*
clasp
=
GetClass
(
unwrapped
)
;
if
(
clasp
=
=
FixedLengthClassPtr
|
|
clasp
=
=
ResizableClassPtr
)
{
return
DataView
(
unwrapped
)
;
}
}
return
DataView
(
nullptr
)
;
}
static
DataView
unwrap
(
JSObject
*
maybeWrapped
)
{
if
(
!
maybeWrapped
)
{
return
DataView
(
nullptr
)
;
}
DataView
view
=
fromObject
(
maybeWrapped
)
;
if
(
view
)
{
return
view
;
}
return
fromObject
(
js
:
:
CheckedUnwrapStatic
(
maybeWrapped
)
)
;
}
}
;
class
JS_PUBLIC_API
TypedArray_base
:
public
ArrayBufferView
{
protected
:
explicit
TypedArray_base
(
JSObject
*
unwrapped
)
:
ArrayBufferView
(
unwrapped
)
{
}
static
const
JSClass
*
const
fixedLengthClasses
;
static
const
JSClass
*
const
resizableClasses
;
public
:
static
TypedArray_base
fromObject
(
JSObject
*
unwrapped
)
;
static
TypedArray_base
unwrap
(
JSObject
*
maybeWrapped
)
{
if
(
!
maybeWrapped
)
{
return
TypedArray_base
(
nullptr
)
;
}
TypedArray_base
view
=
fromObject
(
maybeWrapped
)
;
if
(
view
)
{
return
view
;
}
return
fromObject
(
js
:
:
CheckedUnwrapStatic
(
maybeWrapped
)
)
;
}
}
;
template
<
JS
:
:
Scalar
:
:
Type
TypedArrayElementType
>
class
JS_PUBLIC_API
TypedArray
:
public
TypedArray_base
{
static
const
JSClass
*
fixedLengthClasp
(
)
{
return
&
TypedArray_base
:
:
fixedLengthClasses
[
static_cast
<
int
>
(
TypedArrayElementType
)
]
;
}
static
const
JSClass
*
resizableClasp
(
)
{
return
&
TypedArray_base
:
:
resizableClasses
[
static_cast
<
int
>
(
TypedArrayElementType
)
]
;
}
protected
:
explicit
TypedArray
(
JSObject
*
unwrapped
)
:
TypedArray_base
(
unwrapped
)
{
}
public
:
using
DataType
=
detail
:
:
ExternalTypeOf_t
<
TypedArrayElementType
>
;
static
constexpr
JS
:
:
Scalar
:
:
Type
Scalar
=
TypedArrayElementType
;
static
TypedArray
create
(
JSContext
*
cx
size_t
nelements
)
;
static
TypedArray
fromArray
(
JSContext
*
cx
HandleObject
other
)
;
static
TypedArray
fromBuffer
(
JSContext
*
cx
HandleObject
arrayBuffer
size_t
byteOffset
int64_t
length
)
;
static
TypedArray
fromObject
(
JSObject
*
unwrapped
)
{
if
(
unwrapped
)
{
const
JSClass
*
clasp
=
GetClass
(
unwrapped
)
;
if
(
clasp
=
=
fixedLengthClasp
(
)
|
|
clasp
=
=
resizableClasp
(
)
)
{
return
TypedArray
(
unwrapped
)
;
}
}
return
TypedArray
(
nullptr
)
;
}
static
TypedArray
unwrap
(
JSObject
*
maybeWrapped
)
{
if
(
!
maybeWrapped
)
{
return
TypedArray
(
nullptr
)
;
}
TypedArray
view
=
fromObject
(
maybeWrapped
)
;
if
(
view
)
{
return
view
;
}
return
fromObject
(
js
:
:
CheckedUnwrapStatic
(
maybeWrapped
)
)
;
}
mozilla
:
:
Span
<
DataType
>
getData
(
bool
*
isSharedMemory
const
JS
:
:
AutoRequireNoGC
&
nogc
)
;
}
;
ArrayBufferOrView
ArrayBufferOrView
:
:
fromObject
(
JSObject
*
unwrapped
)
{
if
(
ArrayBuffer
:
:
fromObject
(
unwrapped
)
|
|
ArrayBufferView
:
:
fromObject
(
unwrapped
)
)
{
return
ArrayBufferOrView
(
unwrapped
)
;
}
return
ArrayBufferOrView
(
nullptr
)
;
}
ArrayBufferView
ArrayBufferView
:
:
fromObject
(
JSObject
*
unwrapped
)
{
if
(
TypedArray_base
:
:
fromObject
(
unwrapped
)
|
|
DataView
:
:
fromObject
(
unwrapped
)
)
{
return
ArrayBufferView
(
unwrapped
)
;
}
return
ArrayBufferView
(
nullptr
)
;
}
}
#
define
JS_DEFINE_DATA_AND_LENGTH_ACCESSOR
(
ExternalType
NativeType
Name
)
\
extern
JS_PUBLIC_API
ExternalType
*
JS_Get
#
#
Name
#
#
ArrayData
(
\
JSObject
*
maybeWrapped
bool
*
isSharedMemory
\
const
JS
:
:
AutoRequireNoGC
&
)
;
\
\
namespace
js
{
\
inline
void
Get
#
#
Name
#
#
ArrayLengthAndData
(
JSObject
*
unwrapped
\
size_t
*
length
\
bool
*
isSharedMemory
\
ExternalType
*
*
data
)
{
\
MOZ_ASSERT
(
JS
:
:
TypedArray
<
JS
:
:
Scalar
:
:
Name
>
:
:
fromObject
(
unwrapped
)
)
;
\
const
JS
:
:
Value
&
lenSlot
=
\
JS
:
:
GetReservedSlot
(
unwrapped
detail
:
:
TypedArrayLengthSlot
)
;
\
*
length
=
size_t
(
lenSlot
.
toPrivate
(
)
)
;
\
*
isSharedMemory
=
JS_GetTypedArraySharedness
(
unwrapped
)
;
\
*
data
=
JS
:
:
GetMaybePtrFromReservedSlot
<
ExternalType
>
(
\
unwrapped
detail
:
:
TypedArrayDataSlot
)
;
\
}
\
\
JS_PUBLIC_API
JSObject
*
Unwrap
#
#
Name
#
#
Array
(
JSObject
*
maybeWrapped
)
;
\
}
/
*
namespace
js
*
/
JS_FOR_EACH_TYPED_ARRAY
(
JS_DEFINE_DATA_AND_LENGTH_ACCESSOR
)
#
undef
JS_DEFINE_DATA_AND_LENGTH_ACCESSOR
namespace
JS
{
#
define
IMPL_TYPED_ARRAY_CLASS
(
ExternalType
NativeType
Name
)
\
template
<
>
\
inline
JS
:
:
TypedArray
<
JS
:
:
Scalar
:
:
Name
>
\
JS
:
:
TypedArray
<
JS
:
:
Scalar
:
:
Name
>
:
:
create
(
JSContext
*
cx
size_t
nelements
)
{
\
return
fromObject
(
JS_New
#
#
Name
#
#
Array
(
cx
nelements
)
)
;
\
}
;
\
\
template
<
>
\
inline
JS
:
:
TypedArray
<
JS
:
:
Scalar
:
:
Name
>
\
JS
:
:
TypedArray
<
JS
:
:
Scalar
:
:
Name
>
:
:
fromArray
(
JSContext
*
cx
\
HandleObject
other
)
{
\
return
fromObject
(
JS_New
#
#
Name
#
#
ArrayFromArray
(
cx
other
)
)
;
\
}
;
\
\
template
<
>
\
inline
JS
:
:
TypedArray
<
JS
:
:
Scalar
:
:
Name
>
\
JS
:
:
TypedArray
<
JS
:
:
Scalar
:
:
Name
>
:
:
fromBuffer
(
\
JSContext
*
cx
HandleObject
arrayBuffer
size_t
byteOffset
\
int64_t
length
)
{
\
return
fromObject
(
\
JS_New
#
#
Name
#
#
ArrayWithBuffer
(
cx
arrayBuffer
byteOffset
length
)
)
;
\
}
;
JS_FOR_EACH_TYPED_ARRAY
(
IMPL_TYPED_ARRAY_CLASS
)
#
undef
IMPL_TYPED_ARRAY_CLASS
#
define
JS_DECLARE_CLASS_ALIAS
(
ExternalType
NativeType
Name
)
\
using
Name
#
#
Array
=
TypedArray
<
js
:
:
Scalar
:
:
Name
>
;
JS_FOR_EACH_TYPED_ARRAY
(
JS_DECLARE_CLASS_ALIAS
)
#
undef
JS_DECLARE_CLASS_ALIAS
}
namespace
js
{
template
<
typename
T
>
using
EnableIfABOVType
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
JS
:
:
ArrayBufferOrView
T
>
>
;
template
<
typename
T
typename
Wrapper
>
class
WrappedPtrOperations
<
T
Wrapper
EnableIfABOVType
<
T
>
>
{
auto
get
(
)
const
{
return
static_cast
<
const
Wrapper
*
>
(
this
)
-
>
get
(
)
;
}
public
:
explicit
operator
bool
(
)
const
{
return
bool
(
get
(
)
)
;
}
JSObject
*
asObject
(
)
const
{
return
get
(
)
.
asObject
(
)
;
}
bool
isDetached
(
)
const
{
return
get
(
)
.
isDetached
(
)
;
}
bool
isSharedMemory
(
)
const
{
return
get
(
)
.
isSharedMemory
(
)
;
}
mozilla
:
:
Span
<
typename
T
:
:
DataType
>
getData
(
bool
*
isSharedMemory
const
JS
:
:
AutoRequireNoGC
&
nogc
)
{
return
get
(
)
.
getData
(
isSharedMemory
nogc
)
;
}
}
;
template
<
typename
T
>
struct
IsHeapConstructibleType
<
T
EnableIfABOVType
<
T
>
>
:
public
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
BarrierMethods
<
T
EnableIfABOVType
<
T
>
>
{
static
gc
:
:
Cell
*
asGCThingOrNull
(
T
view
)
{
return
reinterpret_cast
<
gc
:
:
Cell
*
>
(
view
.
asObjectUnbarriered
(
)
)
;
}
static
void
writeBarriers
(
T
*
viewp
T
prev
T
next
)
{
BarrierMethods
<
JSObject
*
>
:
:
writeBarriers
(
viewp
-
>
addressOfObject
(
)
prev
.
asObjectUnbarriered
(
)
next
.
asObjectUnbarriered
(
)
)
;
}
static
void
postWriteBarrier
(
T
*
viewp
T
prev
T
next
)
{
BarrierMethods
<
JSObject
*
>
:
:
postWriteBarrier
(
viewp
-
>
addressOfObject
(
)
prev
.
asObjectUnbarriered
(
)
next
.
asObjectUnbarriered
(
)
)
;
}
static
void
exposeToJS
(
T
view
)
{
view
.
exposeToActiveJS
(
)
;
}
static
void
readBarrier
(
T
view
)
{
JSObject
*
obj
=
view
.
asObjectUnbarriered
(
)
;
if
(
obj
)
{
js
:
:
gc
:
:
IncrementalReadBarrier
(
JS
:
:
GCCellPtr
(
obj
)
)
;
}
}
}
;
}
namespace
JS
{
template
<
typename
T
>
struct
SafelyInitialized
<
T
js
:
:
EnableIfABOVType
<
T
>
>
{
static
T
create
(
)
{
return
T
:
:
fromObject
(
nullptr
)
;
}
}
;
}
#
define
DECLARE_IS_ARRAY_TEST
(
_1
_2
Name
)
\
inline
JS_PUBLIC_API
bool
JS_Is
#
#
Name
#
#
Array
(
JSObject
*
maybeWrapped
)
{
\
return
JS
:
:
TypedArray
<
js
:
:
Scalar
:
:
Name
>
:
:
unwrap
(
maybeWrapped
)
.
asObject
(
)
;
\
}
JS_FOR_EACH_TYPED_ARRAY
(
DECLARE_IS_ARRAY_TEST
)
#
undef
DECLARE_IS_ARRAY_TEST
#
endif
