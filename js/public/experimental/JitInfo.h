#
ifndef
js_experimental_JitInfo_h
#
define
js_experimental_JitInfo_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
js
/
CallArgs
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
namespace
js
{
namespace
jit
{
enum
class
InlinableNative
:
uint16_t
;
}
}
class
JSJitGetterCallArgs
:
protected
JS
:
:
MutableHandle
<
JS
:
:
Value
>
{
public
:
explicit
JSJitGetterCallArgs
(
const
JS
:
:
CallArgs
&
args
)
:
JS
:
:
MutableHandle
<
JS
:
:
Value
>
(
args
.
rval
(
)
)
{
}
explicit
JSJitGetterCallArgs
(
JS
:
:
Rooted
<
JS
:
:
Value
>
*
rooted
)
:
JS
:
:
MutableHandle
<
JS
:
:
Value
>
(
rooted
)
{
}
explicit
JSJitGetterCallArgs
(
JS
:
:
MutableHandle
<
JS
:
:
Value
>
handle
)
:
JS
:
:
MutableHandle
<
JS
:
:
Value
>
(
handle
)
{
}
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
(
)
{
return
*
this
;
}
}
;
class
JSJitSetterCallArgs
:
protected
JS
:
:
MutableHandle
<
JS
:
:
Value
>
{
public
:
explicit
JSJitSetterCallArgs
(
const
JS
:
:
CallArgs
&
args
)
:
JS
:
:
MutableHandle
<
JS
:
:
Value
>
(
args
[
0
]
)
{
}
explicit
JSJitSetterCallArgs
(
JS
:
:
Rooted
<
JS
:
:
Value
>
*
rooted
)
:
JS
:
:
MutableHandle
<
JS
:
:
Value
>
(
rooted
)
{
}
JS
:
:
MutableHandle
<
JS
:
:
Value
>
operator
[
]
(
unsigned
i
)
{
MOZ_ASSERT
(
i
=
=
0
)
;
return
*
this
;
}
unsigned
length
(
)
const
{
return
1
;
}
}
;
struct
JSJitMethodCallArgsTraits
;
class
JSJitMethodCallArgs
:
protected
JS
:
:
detail
:
:
CallArgsBase
<
JS
:
:
detail
:
:
NoUsedRval
>
{
private
:
using
Base
=
JS
:
:
detail
:
:
CallArgsBase
<
JS
:
:
detail
:
:
NoUsedRval
>
;
friend
struct
JSJitMethodCallArgsTraits
;
public
:
explicit
JSJitMethodCallArgs
(
const
JS
:
:
CallArgs
&
args
)
{
argv_
=
args
.
array
(
)
;
argc_
=
args
.
length
(
)
;
}
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
(
)
const
{
return
Base
:
:
rval
(
)
;
}
unsigned
length
(
)
const
{
return
Base
:
:
length
(
)
;
}
JS
:
:
MutableHandle
<
JS
:
:
Value
>
operator
[
]
(
unsigned
i
)
const
{
return
Base
:
:
operator
[
]
(
i
)
;
}
bool
hasDefined
(
unsigned
i
)
const
{
return
Base
:
:
hasDefined
(
i
)
;
}
JSObject
&
callee
(
)
const
{
return
argv_
[
-
2
]
.
toObject
(
)
;
}
JS
:
:
Handle
<
JS
:
:
Value
>
get
(
unsigned
i
)
const
{
return
Base
:
:
get
(
i
)
;
}
bool
requireAtLeast
(
JSContext
*
cx
const
char
*
fnname
unsigned
required
)
const
{
return
Base
:
:
requireAtLeast
(
cx
fnname
required
)
;
}
}
;
struct
JSJitMethodCallArgsTraits
{
static
constexpr
size_t
offsetOfArgv
=
offsetof
(
JSJitMethodCallArgs
argv_
)
;
static
constexpr
size_t
offsetOfArgc
=
offsetof
(
JSJitMethodCallArgs
argc_
)
;
}
;
using
JSJitGetterOp
=
bool
(
*
)
(
JSContext
*
JS
:
:
Handle
<
JSObject
*
>
void
*
JSJitGetterCallArgs
)
;
using
JSJitSetterOp
=
bool
(
*
)
(
JSContext
*
JS
:
:
Handle
<
JSObject
*
>
void
*
JSJitSetterCallArgs
)
;
using
JSJitMethodOp
=
bool
(
*
)
(
JSContext
*
JS
:
:
Handle
<
JSObject
*
>
void
*
const
JSJitMethodCallArgs
&
)
;
class
JSJitInfo
{
public
:
enum
OpType
{
Getter
Setter
Method
StaticMethod
InlinableNative
IgnoresReturnValueNative
OpTypeCount
}
;
enum
ArgType
{
String
=
(
1
<
<
0
)
Integer
=
(
1
<
<
1
)
Double
=
(
1
<
<
2
)
Boolean
=
(
1
<
<
3
)
Object
=
(
1
<
<
4
)
Null
=
(
1
<
<
5
)
Numeric
=
Integer
|
Double
Primitive
=
Numeric
|
Boolean
|
Null
|
String
ObjectOrNull
=
Object
|
Null
Any
=
ObjectOrNull
|
Primitive
ArgTypeListEnd
=
(
1
<
<
31
)
}
;
static_assert
(
Any
&
String
"
Any
must
include
String
"
)
;
static_assert
(
Any
&
Integer
"
Any
must
include
Integer
"
)
;
static_assert
(
Any
&
Double
"
Any
must
include
Double
"
)
;
static_assert
(
Any
&
Boolean
"
Any
must
include
Boolean
"
)
;
static_assert
(
Any
&
Object
"
Any
must
include
Object
"
)
;
static_assert
(
Any
&
Null
"
Any
must
include
Null
"
)
;
enum
AliasSet
{
AliasNone
AliasDOMSets
AliasEverything
AliasSetCount
}
;
bool
needsOuterizedThisObject
(
)
const
{
return
type
(
)
!
=
Getter
&
&
type
(
)
!
=
Setter
;
}
bool
isTypedMethodJitInfo
(
)
const
{
return
isTypedMethod
;
}
OpType
type
(
)
const
{
return
OpType
(
type_
)
;
}
AliasSet
aliasSet
(
)
const
{
return
AliasSet
(
aliasSet_
)
;
}
JSValueType
returnType
(
)
const
{
return
JSValueType
(
returnType_
)
;
}
union
{
JSJitGetterOp
getter
;
JSJitSetterOp
setter
;
JSJitMethodOp
method
;
JSNative
staticMethod
;
JSNative
ignoresReturnValueMethod
;
}
;
static
unsigned
offsetOfIgnoresReturnValueNative
(
)
{
return
offsetof
(
JSJitInfo
ignoresReturnValueMethod
)
;
}
union
{
uint16_t
protoID
;
js
:
:
jit
:
:
InlinableNative
inlinableNative
;
}
;
union
{
uint16_t
depth
;
uint16_t
nativeOp
;
}
;
static
constexpr
size_t
OpTypeBits
=
4
;
static
constexpr
size_t
AliasSetBits
=
4
;
static
constexpr
size_t
ReturnTypeBits
=
8
;
static
constexpr
size_t
SlotIndexBits
=
10
;
uint32_t
type_
:
OpTypeBits
;
uint32_t
aliasSet_
:
AliasSetBits
;
uint32_t
returnType_
:
ReturnTypeBits
;
static_assert
(
OpTypeCount
<
=
(
1
<
<
OpTypeBits
)
"
Not
enough
space
for
OpType
"
)
;
static_assert
(
AliasSetCount
<
=
(
1
<
<
AliasSetBits
)
"
Not
enough
space
for
AliasSet
"
)
;
static_assert
(
(
sizeof
(
JSValueType
)
*
8
)
<
=
ReturnTypeBits
"
Not
enough
space
for
JSValueType
"
)
;
uint32_t
isInfallible
:
1
;
uint32_t
isMovable
:
1
;
uint32_t
isEliminatable
:
1
;
uint32_t
isAlwaysInSlot
:
1
;
uint32_t
isLazilyCachedInSlot
:
1
;
uint32_t
isTypedMethod
:
1
;
uint32_t
slotIndex
:
SlotIndexBits
;
static
constexpr
size_t
maxSlotIndex
=
(
1
<
<
SlotIndexBits
)
-
1
;
}
;
static_assert
(
sizeof
(
JSJitInfo
)
=
=
(
sizeof
(
void
*
)
+
2
*
sizeof
(
uint32_t
)
)
"
There
are
several
thousand
instances
of
JSJitInfo
stored
in
"
"
a
binary
.
Please
don
'
t
increase
its
space
requirements
without
"
"
verifying
that
there
is
no
other
way
forward
(
better
packing
"
"
smaller
datatypes
for
fields
subclassing
etc
.
)
.
"
)
;
struct
JSTypedMethodJitInfo
{
JSJitInfo
base
;
const
JSJitInfo
:
:
ArgType
*
const
argTypes
;
}
;
#
endif
