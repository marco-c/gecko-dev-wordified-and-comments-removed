#
ifndef
GCPolicyAPI_h
#
define
GCPolicyAPI_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
js
/
TraceKind
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
define
FOR_EACH_PUBLIC_GC_POINTER_TYPE
(
D
)
\
D
(
JS
:
:
Symbol
*
)
\
D
(
JS
:
:
BigInt
*
)
\
D
(
JSAtom
*
)
\
D
(
JSFunction
*
)
\
D
(
JSObject
*
)
\
D
(
JSScript
*
)
\
D
(
JSString
*
)
#
define
FOR_EACH_PUBLIC_TAGGED_GC_POINTER_TYPE
(
D
)
\
D
(
JS
:
:
Value
)
\
D
(
jsid
)
#
define
FOR_EACH_PUBLIC_AGGREGATE_GC_POINTER_TYPE
(
D
)
D
(
JSPropertyDescriptor
)
namespace
JS
{
template
<
typename
T
>
struct
StructGCPolicy
{
static_assert
(
!
mozilla
:
:
IsPointer
<
T
>
:
:
value
"
Pointer
type
not
allowed
for
StructGCPolicy
"
)
;
static
void
trace
(
JSTracer
*
trc
T
*
tp
const
char
*
name
)
{
tp
-
>
trace
(
trc
)
;
}
static
void
sweep
(
T
*
tp
)
{
return
tp
-
>
sweep
(
)
;
}
static
bool
needsSweep
(
T
*
tp
)
{
return
tp
-
>
needsSweep
(
)
;
}
static
bool
isValid
(
const
T
&
tp
)
{
return
true
;
}
}
;
template
<
typename
T
>
struct
GCPolicy
:
public
StructGCPolicy
<
T
>
{
}
;
template
<
typename
T
>
struct
IgnoreGCPolicy
{
static
void
trace
(
JSTracer
*
trc
T
*
t
const
char
*
name
)
{
}
static
bool
needsSweep
(
T
*
v
)
{
return
false
;
}
static
bool
isValid
(
const
T
&
v
)
{
return
true
;
}
}
;
template
<
>
struct
GCPolicy
<
uint32_t
>
:
public
IgnoreGCPolicy
<
uint32_t
>
{
}
;
template
<
>
struct
GCPolicy
<
uint64_t
>
:
public
IgnoreGCPolicy
<
uint64_t
>
{
}
;
template
<
typename
T
>
struct
GCPointerPolicy
{
static_assert
(
mozilla
:
:
IsPointer
<
T
>
:
:
value
"
Non
-
pointer
type
not
allowed
for
GCPointerPolicy
"
)
;
static
void
trace
(
JSTracer
*
trc
T
*
vp
const
char
*
name
)
{
if
(
*
vp
)
{
js
:
:
UnsafeTraceManuallyBarrieredEdge
(
trc
vp
name
)
;
}
}
static
bool
needsSweep
(
T
*
vp
)
{
if
(
*
vp
)
{
return
js
:
:
gc
:
:
IsAboutToBeFinalizedUnbarriered
(
vp
)
;
}
return
false
;
}
static
bool
isValid
(
T
v
)
{
return
js
:
:
gc
:
:
IsCellPointerValidOrNull
(
v
)
;
}
}
;
#
define
EXPAND_SPECIALIZE_GCPOLICY
(
Type
)
\
template
<
>
\
struct
GCPolicy
<
Type
>
:
public
GCPointerPolicy
<
Type
>
{
}
;
\
template
<
>
\
struct
GCPolicy
<
Type
const
>
:
public
GCPointerPolicy
<
Type
const
>
{
}
;
FOR_EACH_PUBLIC_GC_POINTER_TYPE
(
EXPAND_SPECIALIZE_GCPOLICY
)
#
undef
EXPAND_SPECIALIZE_GCPOLICY
template
<
typename
T
>
struct
NonGCPointerPolicy
{
static
void
trace
(
JSTracer
*
trc
T
*
vp
const
char
*
name
)
{
if
(
*
vp
)
{
(
*
vp
)
-
>
trace
(
trc
)
;
}
}
static
bool
needsSweep
(
T
*
vp
)
{
if
(
*
vp
)
{
return
(
*
vp
)
-
>
needsSweep
(
)
;
}
return
false
;
}
static
bool
isValid
(
T
v
)
{
return
true
;
}
}
;
template
<
typename
T
>
struct
GCPolicy
<
JS
:
:
Heap
<
T
>
>
{
static
void
trace
(
JSTracer
*
trc
JS
:
:
Heap
<
T
>
*
thingp
const
char
*
name
)
{
TraceEdge
(
trc
thingp
name
)
;
}
static
bool
needsSweep
(
JS
:
:
Heap
<
T
>
*
thingp
)
{
return
*
thingp
&
&
js
:
:
gc
:
:
EdgeNeedsSweep
(
thingp
)
;
}
}
;
template
<
typename
T
typename
D
>
struct
GCPolicy
<
mozilla
:
:
UniquePtr
<
T
D
>
>
{
static
void
trace
(
JSTracer
*
trc
mozilla
:
:
UniquePtr
<
T
D
>
*
tp
const
char
*
name
)
{
if
(
tp
-
>
get
(
)
)
{
GCPolicy
<
T
>
:
:
trace
(
trc
tp
-
>
get
(
)
name
)
;
}
}
static
bool
needsSweep
(
mozilla
:
:
UniquePtr
<
T
D
>
*
tp
)
{
if
(
tp
-
>
get
(
)
)
{
return
GCPolicy
<
T
>
:
:
needsSweep
(
tp
-
>
get
(
)
)
;
}
return
false
;
}
static
bool
isValid
(
const
mozilla
:
:
UniquePtr
<
T
D
>
&
t
)
{
if
(
t
.
get
(
)
)
{
return
GCPolicy
<
T
>
:
:
isValid
(
*
t
.
get
(
)
)
;
}
return
true
;
}
}
;
template
<
typename
T
>
struct
GCPolicy
<
mozilla
:
:
Maybe
<
T
>
>
{
static
void
trace
(
JSTracer
*
trc
mozilla
:
:
Maybe
<
T
>
*
tp
const
char
*
name
)
{
if
(
tp
-
>
isSome
(
)
)
{
GCPolicy
<
T
>
:
:
trace
(
trc
tp
-
>
ptr
(
)
name
)
;
}
}
static
bool
needsSweep
(
mozilla
:
:
Maybe
<
T
>
*
tp
)
{
if
(
tp
-
>
isSome
(
)
)
{
return
GCPolicy
<
T
>
:
:
needsSweep
(
tp
-
>
ptr
(
)
)
;
}
return
false
;
}
static
bool
isValid
(
const
mozilla
:
:
Maybe
<
T
>
&
t
)
{
if
(
t
.
isSome
(
)
)
{
return
GCPolicy
<
T
>
:
:
isValid
(
t
.
ref
(
)
)
;
}
return
true
;
}
}
;
template
<
>
struct
GCPolicy
<
JS
:
:
Realm
*
>
;
namespace
detail
{
struct
FallbackOverload
{
}
;
struct
PreferredOverload
:
FallbackOverload
{
}
;
using
OverloadSelector
=
PreferredOverload
;
template
<
typename
T
>
struct
GCPolicyWithIsValid
:
GCPolicy
<
T
>
{
template
<
typename
U
=
T
typename
=
decltype
(
GCPolicy
<
U
>
:
:
isValid
)
>
static
bool
isValidPicker
(
const
T
&
t
detail
:
:
PreferredOverload
)
{
return
GCPolicy
<
T
>
:
:
isValid
(
t
)
;
}
static
bool
isValidPicker
(
const
T
&
t
detail
:
:
FallbackOverload
)
{
return
true
;
}
static
bool
isValid
(
const
T
&
t
)
{
return
isValidPicker
(
t
detail
:
:
OverloadSelector
(
)
)
;
}
}
;
}
}
#
endif
