#
ifndef
GCPolicyAPI_h
#
define
GCPolicyAPI_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
type_traits
>
#
include
"
js
/
GCTypeMacros
.
h
"
#
include
"
js
/
TraceKind
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
JS
{
template
<
typename
T
>
struct
StructGCPolicy
{
static_assert
(
!
std
:
:
is_pointer_v
<
T
>
"
Pointer
type
not
allowed
for
StructGCPolicy
"
)
;
static
void
trace
(
JSTracer
*
trc
T
*
tp
const
char
*
name
)
{
tp
-
>
trace
(
trc
)
;
}
static
bool
traceWeak
(
JSTracer
*
trc
T
*
tp
)
{
return
tp
-
>
traceWeak
(
trc
)
;
}
static
bool
isValid
(
const
T
&
tp
)
{
return
true
;
}
}
;
template
<
typename
T
>
struct
GCPolicy
:
public
StructGCPolicy
<
T
>
{
}
;
template
<
typename
T
>
struct
IgnoreGCPolicy
{
static
void
trace
(
JSTracer
*
trc
T
*
t
const
char
*
name
)
{
}
static
bool
traceWeak
(
JSTracer
*
T
*
v
)
{
return
true
;
}
static
bool
isValid
(
const
T
&
v
)
{
return
true
;
}
}
;
template
<
>
struct
GCPolicy
<
uint32_t
>
:
public
IgnoreGCPolicy
<
uint32_t
>
{
}
;
template
<
>
struct
GCPolicy
<
uint64_t
>
:
public
IgnoreGCPolicy
<
uint64_t
>
{
}
;
template
<
>
struct
GCPolicy
<
bool
>
:
public
IgnoreGCPolicy
<
bool
>
{
}
;
template
<
typename
T
>
struct
GCPointerPolicy
{
static_assert
(
std
:
:
is_pointer_v
<
T
>
"
Non
-
pointer
type
not
allowed
for
GCPointerPolicy
"
)
;
static
void
trace
(
JSTracer
*
trc
T
*
vp
const
char
*
name
)
{
TraceRoot
(
trc
vp
name
)
;
}
static
bool
isTenured
(
T
v
)
{
return
!
v
|
|
!
js
:
:
gc
:
:
IsInsideNursery
(
v
)
;
}
static
bool
isValid
(
T
v
)
{
return
js
:
:
gc
:
:
IsCellPointerValidOrNull
(
v
)
;
}
}
;
#
define
EXPAND_SPECIALIZE_GCPOLICY
(
Type
)
\
template
<
>
\
struct
GCPolicy
<
Type
>
:
public
GCPointerPolicy
<
Type
>
{
}
;
\
template
<
>
\
struct
GCPolicy
<
Type
const
>
:
public
GCPointerPolicy
<
Type
const
>
{
}
;
JS_FOR_EACH_PUBLIC_GC_POINTER_TYPE
(
EXPAND_SPECIALIZE_GCPOLICY
)
#
undef
EXPAND_SPECIALIZE_GCPOLICY
template
<
typename
T
>
struct
NonGCPointerPolicy
{
static
void
trace
(
JSTracer
*
trc
T
*
vp
const
char
*
name
)
{
if
(
*
vp
)
{
(
*
vp
)
-
>
trace
(
trc
)
;
}
}
static
bool
traceWeak
(
JSTracer
*
trc
T
*
vp
)
{
if
(
*
vp
)
{
return
(
*
vp
)
-
>
traceWeak
(
trc
)
;
}
return
true
;
}
static
bool
isValid
(
T
v
)
{
return
true
;
}
}
;
template
<
typename
T
>
struct
GCPolicy
<
JS
:
:
Heap
<
T
>
>
{
static
void
trace
(
JSTracer
*
trc
JS
:
:
Heap
<
T
>
*
thingp
const
char
*
name
)
{
TraceEdge
(
trc
thingp
name
)
;
}
static
bool
traceWeak
(
JSTracer
*
trc
JS
:
:
Heap
<
T
>
*
thingp
)
{
return
!
*
thingp
|
|
js
:
:
gc
:
:
TraceWeakEdge
(
trc
thingp
)
;
}
}
;
template
<
typename
T
typename
D
>
struct
GCPolicy
<
mozilla
:
:
UniquePtr
<
T
D
>
>
{
static
void
trace
(
JSTracer
*
trc
mozilla
:
:
UniquePtr
<
T
D
>
*
tp
const
char
*
name
)
{
if
(
tp
-
>
get
(
)
)
{
GCPolicy
<
T
>
:
:
trace
(
trc
tp
-
>
get
(
)
name
)
;
}
}
static
bool
traceWeak
(
JSTracer
*
trc
mozilla
:
:
UniquePtr
<
T
D
>
*
tp
)
{
if
(
tp
-
>
get
(
)
)
{
return
GCPolicy
<
T
>
:
:
traceWeak
(
trc
tp
-
>
get
(
)
)
;
}
return
true
;
}
static
bool
isValid
(
const
mozilla
:
:
UniquePtr
<
T
D
>
&
t
)
{
if
(
t
.
get
(
)
)
{
return
GCPolicy
<
T
>
:
:
isValid
(
*
t
.
get
(
)
)
;
}
return
true
;
}
}
;
template
<
>
struct
GCPolicy
<
mozilla
:
:
Nothing
>
:
public
IgnoreGCPolicy
<
mozilla
:
:
Nothing
>
{
}
;
template
<
typename
T
>
struct
GCPolicy
<
mozilla
:
:
Maybe
<
T
>
>
{
static
void
trace
(
JSTracer
*
trc
mozilla
:
:
Maybe
<
T
>
*
tp
const
char
*
name
)
{
if
(
tp
-
>
isSome
(
)
)
{
GCPolicy
<
T
>
:
:
trace
(
trc
tp
-
>
ptr
(
)
name
)
;
}
}
static
bool
traceWeak
(
JSTracer
*
trc
mozilla
:
:
Maybe
<
T
>
*
tp
)
{
if
(
tp
-
>
isSome
(
)
)
{
return
GCPolicy
<
T
>
:
:
traceWeak
(
trc
tp
-
>
ptr
(
)
)
;
}
return
true
;
}
static
bool
isValid
(
const
mozilla
:
:
Maybe
<
T
>
&
t
)
{
if
(
t
.
isSome
(
)
)
{
return
GCPolicy
<
T
>
:
:
isValid
(
t
.
ref
(
)
)
;
}
return
true
;
}
}
;
template
<
typename
T1
typename
T2
>
struct
GCPolicy
<
std
:
:
pair
<
T1
T2
>
>
{
static
void
trace
(
JSTracer
*
trc
std
:
:
pair
<
T1
T2
>
*
tp
const
char
*
name
)
{
GCPolicy
<
T1
>
:
:
trace
(
trc
&
tp
-
>
first
name
)
;
GCPolicy
<
T2
>
:
:
trace
(
trc
&
tp
-
>
second
name
)
;
}
static
bool
traceWeak
(
JSTracer
*
trc
std
:
:
pair
<
T1
T2
>
*
tp
)
{
return
GCPolicy
<
T1
>
:
:
traceWeak
(
trc
&
tp
-
>
first
)
&
&
GCPolicy
<
T2
>
:
:
traceWeak
(
trc
&
tp
-
>
second
)
;
}
static
bool
isValid
(
const
std
:
:
pair
<
T1
T2
>
&
t
)
{
return
GCPolicy
<
T1
>
:
:
isValid
(
t
.
first
)
&
&
GCPolicy
<
T2
>
:
:
isValid
(
t
.
second
)
;
}
}
;
template
<
>
struct
GCPolicy
<
JS
:
:
Realm
*
>
;
template
<
>
struct
GCPolicy
<
mozilla
:
:
Ok
>
:
public
IgnoreGCPolicy
<
mozilla
:
:
Ok
>
{
}
;
template
<
typename
V
typename
E
>
struct
GCPolicy
<
mozilla
:
:
Result
<
V
E
>
>
{
static
void
trace
(
JSTracer
*
trc
mozilla
:
:
Result
<
V
E
>
*
tp
const
char
*
name
)
{
if
(
tp
-
>
isOk
(
)
)
{
V
tmp
=
tp
-
>
unwrap
(
)
;
JS
:
:
GCPolicy
<
V
>
:
:
trace
(
trc
&
tmp
"
Result
value
"
)
;
tp
-
>
updateAfterTracing
(
std
:
:
move
(
tmp
)
)
;
}
if
(
tp
-
>
isErr
(
)
)
{
E
tmp
=
tp
-
>
unwrapErr
(
)
;
JS
:
:
GCPolicy
<
E
>
:
:
trace
(
trc
&
tmp
"
Result
error
"
)
;
tp
-
>
updateErrorAfterTracing
(
std
:
:
move
(
tmp
)
)
;
}
}
static
bool
isValid
(
const
mozilla
:
:
Result
<
V
E
>
&
t
)
{
return
true
;
}
}
;
}
#
endif
