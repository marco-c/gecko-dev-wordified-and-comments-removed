#
ifndef
js_UbiNode_h
#
define
js_UbiNode_h
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
RangedPtr
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
HashTable
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Vector
.
h
"
class
JSAtom
;
namespace
JS
{
namespace
ubi
{
class
Edge
;
class
EdgeRange
;
class
StackFrame
;
}
}
namespace
mozilla
{
template
<
>
class
DefaultDelete
<
JS
:
:
ubi
:
:
EdgeRange
>
:
public
JS
:
:
DeletePolicy
<
JS
:
:
ubi
:
:
EdgeRange
>
{
}
;
template
<
>
class
DefaultDelete
<
JS
:
:
ubi
:
:
StackFrame
>
:
public
JS
:
:
DeletePolicy
<
JS
:
:
ubi
:
:
StackFrame
>
{
}
;
}
namespace
JS
{
namespace
ubi
{
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Move
;
using
mozilla
:
:
RangedPtr
;
using
mozilla
:
:
UniquePtr
;
using
mozilla
:
:
Variant
;
using
AtomOrTwoByteChars
=
Variant
<
JSAtom
*
const
char16_t
*
>
;
class
BaseStackFrame
{
friend
class
StackFrame
;
BaseStackFrame
(
const
StackFrame
&
)
=
delete
;
BaseStackFrame
&
operator
=
(
const
StackFrame
&
)
=
delete
;
protected
:
void
*
ptr
;
explicit
BaseStackFrame
(
void
*
ptr
)
:
ptr
(
ptr
)
{
}
public
:
virtual
uint64_t
identifier
(
)
const
{
return
reinterpret_cast
<
uint64_t
>
(
ptr
)
;
}
virtual
StackFrame
parent
(
)
const
=
0
;
virtual
uint32_t
line
(
)
const
=
0
;
virtual
uint32_t
column
(
)
const
=
0
;
virtual
AtomOrTwoByteChars
source
(
)
const
=
0
;
virtual
AtomOrTwoByteChars
functionDisplayName
(
)
const
=
0
;
virtual
bool
isSystem
(
)
const
=
0
;
virtual
bool
isSelfHosted
(
)
const
=
0
;
virtual
bool
constructSavedFrameStack
(
JSContext
*
cx
MutableHandleObject
outSavedFrameStack
)
const
=
0
;
virtual
void
trace
(
JSTracer
*
trc
)
=
0
;
}
;
template
<
typename
T
>
class
ConcreteStackFrame
;
class
StackFrame
:
public
JS
:
:
Traceable
{
mozilla
:
:
AlignedStorage2
<
BaseStackFrame
>
storage
;
BaseStackFrame
*
base
(
)
{
return
storage
.
addr
(
)
;
}
const
BaseStackFrame
*
base
(
)
const
{
return
storage
.
addr
(
)
;
}
template
<
typename
T
>
void
construct
(
T
*
ptr
)
{
static_assert
(
mozilla
:
:
IsBaseOf
<
BaseStackFrame
ConcreteStackFrame
<
T
>
>
:
:
value
"
ConcreteStackFrame
<
T
>
must
inherit
from
BaseStackFrame
"
)
;
static_assert
(
sizeof
(
ConcreteStackFrame
<
T
>
)
=
=
sizeof
(
*
base
(
)
)
"
ubi
:
:
ConcreteStackFrame
<
T
>
specializations
must
be
the
same
size
as
"
"
ubi
:
:
BaseStackFrame
"
)
;
ConcreteStackFrame
<
T
>
:
:
construct
(
base
(
)
ptr
)
;
}
struct
ConstructFunctor
;
public
:
StackFrame
(
)
{
construct
<
void
>
(
nullptr
)
;
}
template
<
typename
T
>
MOZ_IMPLICIT
StackFrame
(
T
*
ptr
)
{
construct
(
ptr
)
;
}
template
<
typename
T
>
StackFrame
&
operator
=
(
T
*
ptr
)
{
construct
(
ptr
)
;
return
*
this
;
}
template
<
typename
T
>
explicit
StackFrame
(
const
JS
:
:
Handle
<
T
*
>
&
handle
)
{
construct
(
handle
.
get
(
)
)
;
}
template
<
typename
T
>
StackFrame
&
operator
=
(
const
JS
:
:
Handle
<
T
*
>
&
handle
)
{
construct
(
handle
.
get
(
)
)
;
return
*
this
;
}
template
<
typename
T
>
explicit
StackFrame
(
const
JS
:
:
Rooted
<
T
*
>
&
root
)
{
construct
(
root
.
get
(
)
)
;
}
template
<
typename
T
>
StackFrame
&
operator
=
(
const
JS
:
:
Rooted
<
T
*
>
&
root
)
{
construct
(
root
.
get
(
)
)
;
return
*
this
;
}
StackFrame
(
const
StackFrame
&
rhs
)
{
memcpy
(
storage
.
u
.
mBytes
rhs
.
storage
.
u
.
mBytes
sizeof
(
storage
.
u
)
)
;
}
StackFrame
&
operator
=
(
const
StackFrame
&
rhs
)
{
memcpy
(
storage
.
u
.
mBytes
rhs
.
storage
.
u
.
mBytes
sizeof
(
storage
.
u
)
)
;
return
*
this
;
}
bool
operator
=
=
(
const
StackFrame
&
rhs
)
const
{
return
base
(
)
-
>
ptr
=
=
rhs
.
base
(
)
-
>
ptr
;
}
bool
operator
!
=
(
const
StackFrame
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
explicit
operator
bool
(
)
const
{
return
base
(
)
-
>
ptr
!
=
nullptr
;
}
size_t
source
(
RangedPtr
<
char16_t
>
destination
size_t
length
)
const
;
size_t
functionDisplayName
(
RangedPtr
<
char16_t
>
destination
size_t
length
)
const
;
size_t
sourceLength
(
)
;
size_t
functionDisplayNameLength
(
)
;
static
void
trace
(
StackFrame
*
frame
JSTracer
*
trc
)
{
if
(
frame
)
frame
-
>
trace
(
trc
)
;
}
void
trace
(
JSTracer
*
trc
)
{
base
(
)
-
>
trace
(
trc
)
;
}
uint64_t
identifier
(
)
const
{
return
base
(
)
-
>
identifier
(
)
;
}
uint32_t
line
(
)
const
{
return
base
(
)
-
>
line
(
)
;
}
uint32_t
column
(
)
const
{
return
base
(
)
-
>
column
(
)
;
}
AtomOrTwoByteChars
source
(
)
const
{
return
base
(
)
-
>
source
(
)
;
}
AtomOrTwoByteChars
functionDisplayName
(
)
const
{
return
base
(
)
-
>
functionDisplayName
(
)
;
}
StackFrame
parent
(
)
const
{
return
base
(
)
-
>
parent
(
)
;
}
bool
isSystem
(
)
const
{
return
base
(
)
-
>
isSystem
(
)
;
}
bool
isSelfHosted
(
)
const
{
return
base
(
)
-
>
isSelfHosted
(
)
;
}
bool
constructSavedFrameStack
(
JSContext
*
cx
MutableHandleObject
outSavedFrameStack
)
const
{
return
base
(
)
-
>
constructSavedFrameStack
(
cx
outSavedFrameStack
)
;
}
struct
HashPolicy
{
using
Lookup
=
JS
:
:
ubi
:
:
StackFrame
;
static
js
:
:
HashNumber
hash
(
const
Lookup
&
lookup
)
{
return
lookup
.
identifier
(
)
;
}
static
bool
match
(
const
StackFrame
&
key
const
Lookup
&
lookup
)
{
return
key
=
=
lookup
;
}
static
void
rekey
(
StackFrame
&
k
const
StackFrame
&
newKey
)
{
k
=
newKey
;
}
}
;
}
;
template
<
>
class
ConcreteStackFrame
<
void
>
:
public
BaseStackFrame
{
explicit
ConcreteStackFrame
(
void
*
ptr
)
:
BaseStackFrame
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
void
*
)
{
new
(
storage
)
ConcreteStackFrame
(
nullptr
)
;
}
uint64_t
identifier
(
)
const
override
{
return
0
;
}
void
trace
(
JSTracer
*
trc
)
override
{
}
bool
constructSavedFrameStack
(
JSContext
*
cx
MutableHandleObject
out
)
const
override
{
out
.
set
(
nullptr
)
;
return
true
;
}
uint32_t
line
(
)
const
override
{
MOZ_CRASH
(
"
null
JS
:
:
ubi
:
:
StackFrame
"
)
;
}
uint32_t
column
(
)
const
override
{
MOZ_CRASH
(
"
null
JS
:
:
ubi
:
:
StackFrame
"
)
;
}
AtomOrTwoByteChars
source
(
)
const
override
{
MOZ_CRASH
(
"
null
JS
:
:
ubi
:
:
StackFrame
"
)
;
}
AtomOrTwoByteChars
functionDisplayName
(
)
const
override
{
MOZ_CRASH
(
"
null
JS
:
:
ubi
:
:
StackFrame
"
)
;
}
StackFrame
parent
(
)
const
override
{
MOZ_CRASH
(
"
null
JS
:
:
ubi
:
:
StackFrame
"
)
;
}
bool
isSystem
(
)
const
override
{
MOZ_CRASH
(
"
null
JS
:
:
ubi
:
:
StackFrame
"
)
;
}
bool
isSelfHosted
(
)
const
override
{
MOZ_CRASH
(
"
null
JS
:
:
ubi
:
:
StackFrame
"
)
;
}
}
;
bool
ConstructSavedFrameStackSlow
(
JSContext
*
cx
JS
:
:
ubi
:
:
StackFrame
&
frame
MutableHandleObject
outSavedFrameStack
)
;
enum
class
CoarseType
:
uint32_t
{
Other
=
0
Object
=
1
Script
=
2
String
=
3
FIRST
=
Other
LAST
=
String
}
;
inline
uint32_t
CoarseTypeToUint32
(
CoarseType
type
)
{
return
static_cast
<
uint32_t
>
(
type
)
;
}
inline
bool
Uint32IsValidCoarseType
(
uint32_t
n
)
{
auto
first
=
static_cast
<
uint32_t
>
(
CoarseType
:
:
FIRST
)
;
auto
last
=
static_cast
<
uint32_t
>
(
CoarseType
:
:
LAST
)
;
MOZ_ASSERT
(
first
<
last
)
;
return
first
<
=
n
&
&
n
<
=
last
;
}
inline
CoarseType
Uint32ToCoarseType
(
uint32_t
n
)
{
MOZ_ASSERT
(
Uint32IsValidCoarseType
(
n
)
)
;
return
static_cast
<
CoarseType
>
(
n
)
;
}
class
Base
{
friend
class
Node
;
protected
:
void
*
ptr
;
explicit
Base
(
void
*
ptr
)
:
ptr
(
ptr
)
{
}
public
:
bool
operator
=
=
(
const
Base
&
rhs
)
const
{
return
ptr
=
=
rhs
.
ptr
;
}
bool
operator
!
=
(
const
Base
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
using
Id
=
uint64_t
;
virtual
Id
identifier
(
)
const
{
return
reinterpret_cast
<
Id
>
(
ptr
)
;
}
virtual
bool
isLive
(
)
const
{
return
true
;
}
;
virtual
CoarseType
coarseType
(
)
const
{
return
CoarseType
:
:
Other
;
}
virtual
const
char16_t
*
typeName
(
)
const
=
0
;
using
Size
=
uint64_t
;
virtual
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeof
)
const
{
return
1
;
}
virtual
UniquePtr
<
EdgeRange
>
edges
(
JSContext
*
cx
bool
wantNames
)
const
=
0
;
virtual
JS
:
:
Zone
*
zone
(
)
const
{
return
nullptr
;
}
virtual
JSCompartment
*
compartment
(
)
const
{
return
nullptr
;
}
virtual
bool
hasAllocationStack
(
)
const
{
return
false
;
}
virtual
StackFrame
allocationStack
(
)
const
{
MOZ_CRASH
(
"
Concrete
classes
that
have
an
allocation
stack
must
override
both
"
"
hasAllocationStack
and
allocationStack
.
"
)
;
}
virtual
const
char
*
jsObjectClassName
(
)
const
{
return
nullptr
;
}
virtual
bool
jsObjectConstructorName
(
JSContext
*
cx
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
&
outName
)
const
{
outName
.
reset
(
nullptr
)
;
return
true
;
}
private
:
Base
(
const
Base
&
rhs
)
=
delete
;
Base
&
operator
=
(
const
Base
&
rhs
)
=
delete
;
}
;
template
<
typename
Referent
>
struct
Concrete
{
static
const
char16_t
concreteTypeName
[
]
;
static
void
construct
(
void
*
storage
Referent
*
referent
)
;
}
;
class
Node
{
mozilla
:
:
AlignedStorage2
<
Base
>
storage
;
Base
*
base
(
)
{
return
storage
.
addr
(
)
;
}
const
Base
*
base
(
)
const
{
return
storage
.
addr
(
)
;
}
template
<
typename
T
>
void
construct
(
T
*
ptr
)
{
static_assert
(
sizeof
(
Concrete
<
T
>
)
=
=
sizeof
(
*
base
(
)
)
"
ubi
:
:
Base
specializations
must
be
the
same
size
as
ubi
:
:
Base
"
)
;
Concrete
<
T
>
:
:
construct
(
base
(
)
ptr
)
;
}
struct
ConstructFunctor
;
public
:
Node
(
)
{
construct
<
void
>
(
nullptr
)
;
}
template
<
typename
T
>
MOZ_IMPLICIT
Node
(
T
*
ptr
)
{
construct
(
ptr
)
;
}
template
<
typename
T
>
Node
&
operator
=
(
T
*
ptr
)
{
construct
(
ptr
)
;
return
*
this
;
}
template
<
typename
T
>
MOZ_IMPLICIT
Node
(
const
Rooted
<
T
*
>
&
root
)
{
construct
(
root
.
get
(
)
)
;
}
template
<
typename
T
>
Node
&
operator
=
(
const
Rooted
<
T
*
>
&
root
)
{
construct
(
root
.
get
(
)
)
;
return
*
this
;
}
MOZ_IMPLICIT
Node
(
JS
:
:
HandleValue
value
)
;
explicit
Node
(
const
JS
:
:
GCCellPtr
&
thing
)
;
Node
(
const
Node
&
rhs
)
{
memcpy
(
storage
.
u
.
mBytes
rhs
.
storage
.
u
.
mBytes
sizeof
(
storage
.
u
)
)
;
}
Node
&
operator
=
(
const
Node
&
rhs
)
{
memcpy
(
storage
.
u
.
mBytes
rhs
.
storage
.
u
.
mBytes
sizeof
(
storage
.
u
)
)
;
return
*
this
;
}
bool
operator
=
=
(
const
Node
&
rhs
)
const
{
return
*
base
(
)
=
=
*
rhs
.
base
(
)
;
}
bool
operator
!
=
(
const
Node
&
rhs
)
const
{
return
*
base
(
)
!
=
*
rhs
.
base
(
)
;
}
explicit
operator
bool
(
)
const
{
return
base
(
)
-
>
ptr
!
=
nullptr
;
}
bool
isLive
(
)
const
{
return
base
(
)
-
>
isLive
(
)
;
}
template
<
typename
T
>
static
const
char16_t
*
canonicalTypeName
(
)
{
return
Concrete
<
T
>
:
:
concreteTypeName
;
}
template
<
typename
T
>
bool
is
(
)
const
{
return
base
(
)
-
>
typeName
(
)
=
=
canonicalTypeName
<
T
>
(
)
;
}
template
<
typename
T
>
T
*
as
(
)
const
{
MOZ_ASSERT
(
isLive
(
)
)
;
MOZ_ASSERT
(
is
<
T
>
(
)
)
;
return
static_cast
<
T
*
>
(
base
(
)
-
>
ptr
)
;
}
template
<
typename
T
>
T
*
asOrNull
(
)
const
{
MOZ_ASSERT
(
isLive
(
)
)
;
return
is
<
T
>
(
)
?
static_cast
<
T
*
>
(
base
(
)
-
>
ptr
)
:
nullptr
;
}
JS
:
:
Value
exposeToJS
(
)
const
;
CoarseType
coarseType
(
)
const
{
return
base
(
)
-
>
coarseType
(
)
;
}
const
char16_t
*
typeName
(
)
const
{
return
base
(
)
-
>
typeName
(
)
;
}
JS
:
:
Zone
*
zone
(
)
const
{
return
base
(
)
-
>
zone
(
)
;
}
JSCompartment
*
compartment
(
)
const
{
return
base
(
)
-
>
compartment
(
)
;
}
const
char
*
jsObjectClassName
(
)
const
{
return
base
(
)
-
>
jsObjectClassName
(
)
;
}
bool
jsObjectConstructorName
(
JSContext
*
cx
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
&
outName
)
const
{
return
base
(
)
-
>
jsObjectConstructorName
(
cx
outName
)
;
}
using
Size
=
Base
:
:
Size
;
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeof
)
const
{
return
base
(
)
-
>
size
(
mallocSizeof
)
;
}
UniquePtr
<
EdgeRange
>
edges
(
JSContext
*
cx
bool
wantNames
=
true
)
const
{
return
base
(
)
-
>
edges
(
cx
wantNames
)
;
}
bool
hasAllocationStack
(
)
const
{
return
base
(
)
-
>
hasAllocationStack
(
)
;
}
StackFrame
allocationStack
(
)
const
{
return
base
(
)
-
>
allocationStack
(
)
;
}
using
Id
=
Base
:
:
Id
;
Id
identifier
(
)
const
{
return
base
(
)
-
>
identifier
(
)
;
}
class
HashPolicy
{
typedef
js
:
:
PointerHasher
<
void
*
mozilla
:
:
tl
:
:
FloorLog2
<
sizeof
(
void
*
)
>
:
:
value
>
PtrHash
;
public
:
typedef
Node
Lookup
;
static
js
:
:
HashNumber
hash
(
const
Lookup
&
l
)
{
return
PtrHash
:
:
hash
(
l
.
base
(
)
-
>
ptr
)
;
}
static
bool
match
(
const
Node
&
k
const
Lookup
&
l
)
{
return
k
=
=
l
;
}
static
void
rekey
(
Node
&
k
const
Node
&
newKey
)
{
k
=
newKey
;
}
}
;
}
;
class
Edge
{
public
:
Edge
(
)
:
name
(
nullptr
)
referent
(
)
{
}
Edge
(
char16_t
*
name
const
Node
&
referent
)
{
this
-
>
name
=
name
;
this
-
>
referent
=
referent
;
}
Edge
(
Edge
&
&
rhs
)
{
name
=
rhs
.
name
;
referent
=
rhs
.
referent
;
rhs
.
name
=
nullptr
;
}
Edge
&
operator
=
(
Edge
&
&
rhs
)
{
MOZ_ASSERT
(
&
rhs
!
=
this
)
;
this
-
>
~
Edge
(
)
;
new
(
this
)
Edge
(
mozilla
:
:
Move
(
rhs
)
)
;
return
*
this
;
}
~
Edge
(
)
{
js_free
(
const_cast
<
char16_t
*
>
(
name
)
)
;
}
Edge
(
const
Edge
&
)
=
delete
;
Edge
&
operator
=
(
const
Edge
&
)
=
delete
;
const
char16_t
*
name
;
Node
referent
;
}
;
class
EdgeRange
{
protected
:
Edge
*
front_
;
EdgeRange
(
)
:
front_
(
nullptr
)
{
}
public
:
virtual
~
EdgeRange
(
)
{
}
bool
empty
(
)
const
{
return
!
front_
;
}
const
Edge
&
front
(
)
{
return
*
front_
;
}
virtual
void
popFront
(
)
=
0
;
private
:
EdgeRange
(
const
EdgeRange
&
)
=
delete
;
EdgeRange
&
operator
=
(
const
EdgeRange
&
)
=
delete
;
}
;
typedef
mozilla
:
:
Vector
<
Edge
8
js
:
:
TempAllocPolicy
>
EdgeVector
;
class
PreComputedEdgeRange
:
public
EdgeRange
{
EdgeVector
&
edges
;
size_t
i
;
void
settle
(
)
{
front_
=
i
<
edges
.
length
(
)
?
&
edges
[
i
]
:
nullptr
;
}
public
:
explicit
PreComputedEdgeRange
(
JSContext
*
cx
EdgeVector
&
edges
)
:
edges
(
edges
)
i
(
0
)
{
settle
(
)
;
}
void
popFront
(
)
override
{
MOZ_ASSERT
(
!
empty
(
)
)
;
i
+
+
;
settle
(
)
;
}
}
;
class
MOZ_STACK_CLASS
RootList
{
Maybe
<
AutoCheckCannotGC
>
&
noGC
;
JSContext
*
cx
;
public
:
EdgeVector
edges
;
bool
wantNames
;
RootList
(
JSContext
*
cx
Maybe
<
AutoCheckCannotGC
>
&
noGC
bool
wantNames
=
false
)
;
bool
init
(
)
;
bool
init
(
ZoneSet
&
debuggees
)
;
bool
init
(
HandleObject
debuggees
)
;
bool
initialized
(
)
{
return
noGC
.
isSome
(
)
;
}
bool
addRoot
(
Node
node
const
char16_t
*
edgeName
=
nullptr
)
;
}
;
template
<
>
struct
Concrete
<
RootList
>
:
public
Base
{
UniquePtr
<
EdgeRange
>
edges
(
JSContext
*
cx
bool
wantNames
)
const
override
;
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
protected
:
explicit
Concrete
(
RootList
*
ptr
)
:
Base
(
ptr
)
{
}
RootList
&
get
(
)
const
{
return
*
static_cast
<
RootList
*
>
(
ptr
)
;
}
public
:
static
const
char16_t
concreteTypeName
[
]
;
static
void
construct
(
void
*
storage
RootList
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
}
;
template
<
typename
Referent
>
class
TracerConcrete
:
public
Base
{
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
UniquePtr
<
EdgeRange
>
edges
(
JSContext
*
bool
wantNames
)
const
override
;
JS
:
:
Zone
*
zone
(
)
const
override
;
protected
:
explicit
TracerConcrete
(
Referent
*
ptr
)
:
Base
(
ptr
)
{
}
Referent
&
get
(
)
const
{
return
*
static_cast
<
Referent
*
>
(
ptr
)
;
}
public
:
static
const
char16_t
concreteTypeName
[
]
;
static
void
construct
(
void
*
storage
Referent
*
ptr
)
{
new
(
storage
)
TracerConcrete
(
ptr
)
;
}
}
;
template
<
typename
Referent
>
class
TracerConcreteWithCompartment
:
public
TracerConcrete
<
Referent
>
{
typedef
TracerConcrete
<
Referent
>
TracerBase
;
JSCompartment
*
compartment
(
)
const
override
;
protected
:
explicit
TracerConcreteWithCompartment
(
Referent
*
ptr
)
:
TracerBase
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
Referent
*
ptr
)
{
new
(
storage
)
TracerConcreteWithCompartment
(
ptr
)
;
}
}
;
template
<
>
struct
Concrete
<
JS
:
:
Symbol
>
:
TracerConcrete
<
JS
:
:
Symbol
>
{
}
;
template
<
>
struct
Concrete
<
JSScript
>
:
TracerConcreteWithCompartment
<
JSScript
>
{
CoarseType
coarseType
(
)
const
final
{
return
CoarseType
:
:
Script
;
}
protected
:
explicit
Concrete
(
JSScript
*
ptr
)
:
TracerConcreteWithCompartment
<
JSScript
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
JSScript
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
}
;
template
<
>
class
Concrete
<
JSObject
>
:
public
TracerConcreteWithCompartment
<
JSObject
>
{
const
char
*
jsObjectClassName
(
)
const
override
;
bool
jsObjectConstructorName
(
JSContext
*
cx
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
&
outName
)
const
override
;
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
bool
hasAllocationStack
(
)
const
override
;
StackFrame
allocationStack
(
)
const
override
;
CoarseType
coarseType
(
)
const
final
{
return
CoarseType
:
:
Object
;
}
protected
:
explicit
Concrete
(
JSObject
*
ptr
)
:
TracerConcreteWithCompartment
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
JSObject
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
}
;
template
<
>
struct
Concrete
<
JSString
>
:
TracerConcrete
<
JSString
>
{
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
CoarseType
coarseType
(
)
const
final
{
return
CoarseType
:
:
String
;
}
protected
:
explicit
Concrete
(
JSString
*
ptr
)
:
TracerConcrete
<
JSString
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
JSString
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
}
;
template
<
>
class
Concrete
<
void
>
:
public
Base
{
const
char16_t
*
typeName
(
)
const
override
;
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
UniquePtr
<
EdgeRange
>
edges
(
JSContext
*
cx
bool
wantNames
)
const
override
;
JS
:
:
Zone
*
zone
(
)
const
override
;
JSCompartment
*
compartment
(
)
const
override
;
CoarseType
coarseType
(
)
const
final
;
explicit
Concrete
(
void
*
ptr
)
:
Base
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
void
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
static
const
char16_t
concreteTypeName
[
]
;
}
;
}
}
namespace
js
{
template
<
>
struct
DefaultHasher
<
JS
:
:
ubi
:
:
Node
>
:
JS
:
:
ubi
:
:
Node
:
:
HashPolicy
{
}
;
template
<
>
struct
DefaultHasher
<
JS
:
:
ubi
:
:
StackFrame
>
:
JS
:
:
ubi
:
:
StackFrame
:
:
HashPolicy
{
}
;
}
#
endif
