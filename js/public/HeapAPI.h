#
ifndef
js_HeapAPI_h
#
define
js_HeapAPI_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
BitSet
.
h
"
#
include
<
limits
.
h
>
#
include
<
type_traits
>
#
include
"
jspubtd
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
#
include
"
js
/
shadow
/
String
.
h
"
#
include
"
js
/
shadow
/
Symbol
.
h
"
#
include
"
js
/
shadow
/
Zone
.
h
"
#
include
"
js
/
TraceKind
.
h
"
#
include
"
js
/
Utility
.
h
"
#
ifndef
JS_BITS_PER_WORD
#
error
\
"
JS_BITS_PER_WORD
must
be
defined
.
Did
you
forget
to
include
js
-
config
.
h
?
"
#
endif
struct
JSExternalStringCallbacks
;
namespace
js
{
class
NurseryDecommitTask
;
JS_FRIEND_API
bool
CurrentThreadCanAccessZone
(
JS
:
:
Zone
*
zone
)
;
namespace
gc
{
class
Arena
;
struct
Cell
;
struct
Chunk
;
class
StoreBuffer
;
class
TenuredCell
;
const
size_t
ArenaShift
=
12
;
const
size_t
ArenaSize
=
size_t
(
1
)
<
<
ArenaShift
;
const
size_t
ArenaMask
=
ArenaSize
-
1
;
#
ifdef
JS_GC_SMALL_CHUNK_SIZE
const
size_t
ChunkShift
=
18
;
#
else
const
size_t
ChunkShift
=
20
;
#
endif
const
size_t
ChunkSize
=
size_t
(
1
)
<
<
ChunkShift
;
const
size_t
ChunkMask
=
ChunkSize
-
1
;
const
size_t
CellAlignShift
=
3
;
const
size_t
CellAlignBytes
=
size_t
(
1
)
<
<
CellAlignShift
;
const
size_t
CellAlignMask
=
CellAlignBytes
-
1
;
const
size_t
CellBytesPerMarkBit
=
CellAlignBytes
;
const
size_t
MarkBitsPerCell
=
2
;
const
size_t
ArenaBitmapBits
=
ArenaSize
/
CellBytesPerMarkBit
;
const
size_t
ArenaBitmapBytes
=
HowMany
(
ArenaBitmapBits
8
)
;
const
size_t
ArenaBitmapWords
=
HowMany
(
ArenaBitmapBits
JS_BITS_PER_WORD
)
;
enum
class
ChunkLocation
:
uint32_t
{
Invalid
=
0
Nursery
=
1
TenuredHeap
=
2
}
;
class
alignas
(
CellAlignBytes
)
ChunkHeader
{
public
:
ChunkHeader
(
JSRuntime
*
rt
StoreBuffer
*
sb
)
:
location
(
ChunkLocation
:
:
Nursery
)
storeBuffer
(
sb
)
runtime
(
rt
)
{
}
explicit
ChunkHeader
(
JSRuntime
*
rt
)
:
location
(
ChunkLocation
:
:
TenuredHeap
)
storeBuffer
(
nullptr
)
runtime
(
rt
)
{
}
ChunkLocation
location
;
uint32_t
:
32
;
StoreBuffer
*
storeBuffer
;
JSRuntime
*
runtime
;
}
;
struct
ChunkInfo
{
void
init
(
)
{
next
=
prev
=
nullptr
;
}
private
:
friend
class
ChunkPool
;
friend
class
js
:
:
NurseryDecommitTask
;
Chunk
*
next
;
Chunk
*
prev
;
public
:
Arena
*
freeArenasHead
;
#
if
JS_BITS_PER_WORD
=
=
32
char
padding
[
24
]
;
#
endif
uint32_t
lastDecommittedArenaOffset
;
uint32_t
numArenasFree
;
uint32_t
numArenasFreeCommitted
;
}
;
const
size_t
BitsPerArenaWithHeaders
=
(
ArenaSize
+
ArenaBitmapBytes
)
*
CHAR_BIT
+
1
;
const
size_t
ChunkBitsAvailable
=
(
ChunkSize
-
sizeof
(
ChunkHeader
)
-
sizeof
(
ChunkInfo
)
)
*
CHAR_BIT
;
const
size_t
ArenasPerChunk
=
ChunkBitsAvailable
/
BitsPerArenaWithHeaders
;
const
size_t
CalculatedChunkSizeRequired
=
sizeof
(
ChunkHeader
)
+
sizeof
(
ChunkInfo
)
+
RoundUp
(
ArenasPerChunk
*
ArenaBitmapBytes
sizeof
(
uintptr_t
)
)
+
RoundUp
(
ArenasPerChunk
sizeof
(
uint32_t
)
*
CHAR_BIT
)
/
CHAR_BIT
+
ArenasPerChunk
*
ArenaSize
;
static_assert
(
CalculatedChunkSizeRequired
<
=
ChunkSize
"
Calculated
ArenasPerChunk
is
too
large
"
)
;
const
size_t
CalculatedChunkPadSize
=
ChunkSize
-
CalculatedChunkSizeRequired
;
static_assert
(
CalculatedChunkPadSize
*
CHAR_BIT
<
BitsPerArenaWithHeaders
"
Calculated
ArenasPerChunk
is
too
small
"
)
;
#
ifdef
JS_GC_SMALL_CHUNK_SIZE
static_assert
(
ArenasPerChunk
=
=
62
"
Do
not
accidentally
change
our
heap
'
s
density
.
"
)
;
#
else
static_assert
(
ArenasPerChunk
=
=
252
"
Do
not
accidentally
change
our
heap
'
s
density
.
"
)
;
#
endif
using
MarkBitmapWord
=
mozilla
:
:
Atomic
<
uintptr_t
mozilla
:
:
Relaxed
>
;
enum
class
ColorBit
:
uint32_t
{
BlackBit
=
0
GrayOrBlackBit
=
1
}
;
enum
class
MarkColor
:
uint8_t
{
Gray
=
1
Black
=
2
}
;
struct
ChunkBitmap
{
static
constexpr
size_t
WordCount
=
ArenaBitmapWords
*
ArenasPerChunk
;
MarkBitmapWord
bitmap
[
WordCount
]
;
static
inline
void
GetMarkWordAndMask
(
const
TenuredCell
*
cell
ColorBit
colorBit
MarkBitmapWord
*
*
wordp
uintptr_t
*
maskp
)
;
inline
bool
markBit
(
const
TenuredCell
*
cell
ColorBit
colorBit
)
;
inline
bool
isMarkedAny
(
const
TenuredCell
*
cell
)
;
inline
bool
isMarkedBlack
(
const
TenuredCell
*
cell
)
;
inline
bool
isMarkedGray
(
const
TenuredCell
*
cell
)
;
inline
bool
markIfUnmarked
(
const
TenuredCell
*
cell
MarkColor
color
)
;
inline
void
markBlack
(
const
TenuredCell
*
cell
)
;
inline
void
copyMarkBit
(
TenuredCell
*
dst
const
TenuredCell
*
src
ColorBit
colorBit
)
;
inline
void
unmark
(
const
TenuredCell
*
cell
)
;
inline
void
clear
(
)
;
inline
MarkBitmapWord
*
arenaBits
(
Arena
*
arena
)
;
}
;
static_assert
(
ArenaBitmapBytes
*
ArenasPerChunk
=
=
sizeof
(
ChunkBitmap
)
"
Ensure
our
ChunkBitmap
actually
covers
all
arenas
.
"
)
;
using
PerArenaBitmap
=
mozilla
:
:
BitSet
<
ArenasPerChunk
uint32_t
>
;
class
ChunkBase
{
public
:
ChunkHeader
header
;
ChunkInfo
info
;
ChunkBitmap
bitmap
;
PerArenaBitmap
decommittedArenas
;
}
;
const
size_t
ArenaCellIndexBytes
=
CellAlignBytes
;
const
size_t
MaxArenaCellIndex
=
ArenaSize
/
CellAlignBytes
;
const
size_t
MarkBitmapWordBits
=
sizeof
(
MarkBitmapWord
)
*
CHAR_BIT
;
constexpr
size_t
FirstArenaAdjustmentBits
=
RoundUp
(
sizeof
(
gc
:
:
ChunkBase
)
ArenaSize
)
/
gc
:
:
CellBytesPerMarkBit
;
static_assert
(
(
FirstArenaAdjustmentBits
%
MarkBitmapWordBits
)
=
=
0
)
;
constexpr
size_t
FirstArenaAdjustmentWords
=
FirstArenaAdjustmentBits
/
MarkBitmapWordBits
;
const
size_t
ChunkRuntimeOffset
=
offsetof
(
ChunkBase
header
)
+
offsetof
(
ChunkHeader
runtime
)
;
const
size_t
ChunkLocationOffset
=
offsetof
(
ChunkBase
header
)
+
offsetof
(
ChunkHeader
location
)
;
const
size_t
ChunkStoreBufferOffset
=
offsetof
(
ChunkBase
header
)
+
offsetof
(
ChunkHeader
storeBuffer
)
;
const
size_t
ChunkMarkBitmapOffset
=
offsetof
(
ChunkBase
bitmap
)
;
const
size_t
ArenaZoneOffset
=
sizeof
(
size_t
)
;
const
size_t
ArenaHeaderSize
=
sizeof
(
size_t
)
+
2
*
sizeof
(
uintptr_t
)
+
sizeof
(
size_t
)
+
sizeof
(
uintptr_t
)
;
const
size_t
CellFlagBitsReservedForGC
=
3
;
const
size_t
JSClassAlignBytes
=
size_t
(
1
)
<
<
CellFlagBitsReservedForGC
;
#
ifdef
JS_DEBUG
extern
JS_FRIEND_API
void
AssertGCThingHasType
(
js
:
:
gc
:
:
Cell
*
cell
JS
:
:
TraceKind
kind
)
;
#
else
inline
void
AssertGCThingHasType
(
js
:
:
gc
:
:
Cell
*
cell
JS
:
:
TraceKind
kind
)
{
}
#
endif
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
js
:
:
gc
:
:
Cell
*
cell
)
;
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
js
:
:
gc
:
:
TenuredCell
*
cell
)
;
}
}
namespace
JS
{
enum
class
HeapState
{
Idle
Tracing
MajorCollecting
MinorCollecting
CycleCollecting
}
;
JS_PUBLIC_API
HeapState
RuntimeHeapState
(
)
;
static
inline
bool
RuntimeHeapIsBusy
(
)
{
return
RuntimeHeapState
(
)
!
=
HeapState
:
:
Idle
;
}
static
inline
bool
RuntimeHeapIsTracing
(
)
{
return
RuntimeHeapState
(
)
=
=
HeapState
:
:
Tracing
;
}
static
inline
bool
RuntimeHeapIsMajorCollecting
(
)
{
return
RuntimeHeapState
(
)
=
=
HeapState
:
:
MajorCollecting
;
}
static
inline
bool
RuntimeHeapIsMinorCollecting
(
)
{
return
RuntimeHeapState
(
)
=
=
HeapState
:
:
MinorCollecting
;
}
static
inline
bool
RuntimeHeapIsCollecting
(
HeapState
state
)
{
return
state
=
=
HeapState
:
:
MajorCollecting
|
|
state
=
=
HeapState
:
:
MinorCollecting
;
}
static
inline
bool
RuntimeHeapIsCollecting
(
)
{
return
RuntimeHeapIsCollecting
(
RuntimeHeapState
(
)
)
;
}
static
inline
bool
RuntimeHeapIsCycleCollecting
(
)
{
return
RuntimeHeapState
(
)
=
=
HeapState
:
:
CycleCollecting
;
}
enum
StackKind
{
StackForSystemCode
StackForTrustedScript
StackForUntrustedScript
StackKindCount
}
;
const
uint32_t
DefaultNurseryMaxBytes
=
16
*
js
:
:
gc
:
:
ChunkSize
;
const
uint32_t
DefaultHeapMaxBytes
=
32
*
1024
*
1024
;
class
JS_FRIEND_API
GCCellPtr
{
public
:
GCCellPtr
(
)
:
GCCellPtr
(
nullptr
)
{
}
GCCellPtr
(
void
*
gcthing
JS
:
:
TraceKind
traceKind
)
:
ptr
(
checkedCast
(
gcthing
traceKind
)
)
{
}
MOZ_IMPLICIT
GCCellPtr
(
decltype
(
nullptr
)
)
:
ptr
(
checkedCast
(
nullptr
JS
:
:
TraceKind
:
:
Null
)
)
{
}
template
<
typename
T
>
explicit
GCCellPtr
(
T
*
p
)
:
ptr
(
checkedCast
(
p
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
)
)
{
}
explicit
GCCellPtr
(
JSFunction
*
p
)
:
ptr
(
checkedCast
(
p
JS
:
:
TraceKind
:
:
Object
)
)
{
}
explicit
GCCellPtr
(
JSScript
*
p
)
:
ptr
(
checkedCast
(
p
JS
:
:
TraceKind
:
:
Script
)
)
{
}
explicit
GCCellPtr
(
const
Value
&
v
)
;
JS
:
:
TraceKind
kind
(
)
const
{
JS
:
:
TraceKind
traceKind
=
JS
:
:
TraceKind
(
ptr
&
OutOfLineTraceKindMask
)
;
if
(
uintptr_t
(
traceKind
)
!
=
OutOfLineTraceKindMask
)
{
return
traceKind
;
}
return
outOfLineKind
(
)
;
}
explicit
operator
bool
(
)
const
{
MOZ_ASSERT
(
bool
(
asCell
(
)
)
=
=
(
kind
(
)
!
=
JS
:
:
TraceKind
:
:
Null
)
)
;
return
asCell
(
)
;
}
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
JS
:
:
IsBaseTraceType_v
<
T
>
>
>
bool
is
(
)
const
{
return
kind
(
)
=
=
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
;
}
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
JS
:
:
IsBaseTraceType_v
<
T
>
>
>
T
&
as
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
)
;
return
*
reinterpret_cast
<
T
*
>
(
asCell
(
)
)
;
}
js
:
:
gc
:
:
Cell
*
asCell
(
)
const
{
return
reinterpret_cast
<
js
:
:
gc
:
:
Cell
*
>
(
ptr
&
~
OutOfLineTraceKindMask
)
;
}
uint64_t
unsafeAsInteger
(
)
const
{
return
static_cast
<
uint64_t
>
(
unsafeAsUIntPtr
(
)
)
;
}
uintptr_t
unsafeAsUIntPtr
(
)
const
{
MOZ_ASSERT
(
asCell
(
)
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
IsInsideNursery
(
asCell
(
)
)
)
;
return
reinterpret_cast
<
uintptr_t
>
(
asCell
(
)
)
;
}
MOZ_ALWAYS_INLINE
bool
mayBeOwnedByOtherRuntime
(
)
const
{
if
(
!
is
<
JSString
>
(
)
&
&
!
is
<
JS
:
:
Symbol
>
(
)
)
{
return
false
;
}
if
(
is
<
JSString
>
(
)
)
{
return
JS
:
:
shadow
:
:
String
:
:
isPermanentAtom
(
asCell
(
)
)
;
}
MOZ_ASSERT
(
is
<
JS
:
:
Symbol
>
(
)
)
;
return
JS
:
:
shadow
:
:
Symbol
:
:
isWellKnownSymbol
(
asCell
(
)
)
;
}
private
:
static
uintptr_t
checkedCast
(
void
*
p
JS
:
:
TraceKind
traceKind
)
{
auto
*
cell
=
static_cast
<
js
:
:
gc
:
:
Cell
*
>
(
p
)
;
MOZ_ASSERT
(
(
uintptr_t
(
p
)
&
OutOfLineTraceKindMask
)
=
=
0
)
;
AssertGCThingHasType
(
cell
traceKind
)
;
MOZ_ASSERT_IF
(
uintptr_t
(
traceKind
)
>
=
OutOfLineTraceKindMask
(
uintptr_t
(
traceKind
)
&
OutOfLineTraceKindMask
)
=
=
OutOfLineTraceKindMask
)
;
return
uintptr_t
(
p
)
|
(
uintptr_t
(
traceKind
)
&
OutOfLineTraceKindMask
)
;
}
JS
:
:
TraceKind
outOfLineKind
(
)
const
;
uintptr_t
ptr
;
}
JS_HAZ_GC_POINTER
;
template
<
typename
F
>
auto
MapGCThingTyped
(
GCCellPtr
thing
F
&
&
f
)
{
switch
(
thing
.
kind
(
)
)
{
#
define
JS_EXPAND_DEF
(
name
type
_
_1
)
\
case
JS
:
:
TraceKind
:
:
name
:
\
return
f
(
&
thing
.
as
<
type
>
(
)
)
;
JS_FOR_EACH_TRACEKIND
(
JS_EXPAND_DEF
)
;
#
undef
JS_EXPAND_DEF
default
:
MOZ_CRASH
(
"
Invalid
trace
kind
in
MapGCThingTyped
for
GCCellPtr
.
"
)
;
}
}
template
<
typename
F
>
void
ApplyGCThingTyped
(
GCCellPtr
thing
F
&
&
f
)
{
MapGCThingTyped
(
thing
f
)
;
}
}
inline
bool
operator
=
=
(
const
JS
:
:
GCCellPtr
&
ptr1
const
JS
:
:
GCCellPtr
&
ptr2
)
{
return
ptr1
.
asCell
(
)
=
=
ptr2
.
asCell
(
)
;
}
inline
bool
operator
!
=
(
const
JS
:
:
GCCellPtr
&
ptr1
const
JS
:
:
GCCellPtr
&
ptr2
)
{
return
!
(
ptr1
=
=
ptr2
)
;
}
namespace
js
{
namespace
gc
{
MOZ_ALWAYS_INLINE
void
ChunkBitmap
:
:
GetMarkWordAndMask
(
const
TenuredCell
*
cell
ColorBit
colorBit
MarkBitmapWord
*
*
wordp
uintptr_t
*
maskp
)
{
MOZ_ASSERT
(
size_t
(
colorBit
)
<
MarkBitsPerCell
)
;
auto
*
chunk
=
reinterpret_cast
<
ChunkBase
*
>
(
uintptr_t
(
cell
)
&
~
ChunkMask
)
;
size_t
offset
=
uintptr_t
(
cell
)
&
ChunkMask
;
const
size_t
bit
=
offset
/
CellBytesPerMarkBit
+
size_t
(
colorBit
)
;
size_t
word
=
bit
/
MarkBitmapWordBits
-
FirstArenaAdjustmentWords
;
MOZ_ASSERT
(
word
<
WordCount
)
;
*
wordp
=
&
chunk
-
>
bitmap
.
bitmap
[
word
]
;
*
maskp
=
uintptr_t
(
1
)
<
<
(
bit
%
MarkBitmapWordBits
)
;
}
namespace
detail
{
static
MOZ_ALWAYS_INLINE
ChunkHeader
*
GetCellChunkHeader
(
const
Cell
*
cell
)
{
MOZ_ASSERT
(
cell
)
;
return
reinterpret_cast
<
ChunkHeader
*
>
(
uintptr_t
(
cell
)
&
~
ChunkMask
)
;
}
static
MOZ_ALWAYS_INLINE
JS
:
:
Zone
*
GetTenuredGCThingZone
(
const
uintptr_t
addr
)
{
MOZ_ASSERT
(
addr
)
;
const
uintptr_t
zone_addr
=
(
addr
&
~
ArenaMask
)
|
ArenaZoneOffset
;
return
*
reinterpret_cast
<
JS
:
:
Zone
*
*
>
(
zone_addr
)
;
}
static
MOZ_ALWAYS_INLINE
bool
TenuredCellIsMarkedGray
(
const
TenuredCell
*
cell
)
{
MOZ_ASSERT
(
cell
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
IsInsideNursery
(
cell
)
)
;
MarkBitmapWord
*
grayWord
;
uintptr_t
grayMask
;
ChunkBitmap
:
:
GetMarkWordAndMask
(
cell
js
:
:
gc
:
:
ColorBit
:
:
GrayOrBlackBit
&
grayWord
&
grayMask
)
;
if
(
!
(
*
grayWord
&
grayMask
)
)
{
return
false
;
}
MarkBitmapWord
*
blackWord
;
uintptr_t
blackMask
;
ChunkBitmap
:
:
GetMarkWordAndMask
(
cell
js
:
:
gc
:
:
ColorBit
:
:
BlackBit
&
blackWord
&
blackMask
)
;
return
!
(
*
blackWord
&
blackMask
)
;
}
static
MOZ_ALWAYS_INLINE
bool
CellIsMarkedGray
(
const
Cell
*
cell
)
{
MOZ_ASSERT
(
cell
)
;
if
(
js
:
:
gc
:
:
IsInsideNursery
(
cell
)
)
{
return
false
;
}
return
TenuredCellIsMarkedGray
(
reinterpret_cast
<
const
TenuredCell
*
>
(
cell
)
)
;
}
extern
JS_PUBLIC_API
bool
CellIsMarkedGrayIfKnown
(
const
Cell
*
cell
)
;
#
ifdef
DEBUG
extern
JS_PUBLIC_API
void
AssertCellIsNotGray
(
const
Cell
*
cell
)
;
extern
JS_PUBLIC_API
bool
ObjectIsMarkedBlack
(
const
JSObject
*
obj
)
;
#
endif
MOZ_ALWAYS_INLINE
ChunkLocation
GetCellLocation
(
const
Cell
*
cell
)
{
return
GetCellChunkHeader
(
cell
)
-
>
location
;
}
MOZ_ALWAYS_INLINE
bool
CellHasStoreBuffer
(
const
Cell
*
cell
)
{
return
GetCellChunkHeader
(
cell
)
-
>
storeBuffer
;
}
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
Cell
*
cell
)
{
if
(
!
cell
)
{
return
false
;
}
auto
location
=
detail
:
:
GetCellLocation
(
cell
)
;
MOZ_ASSERT
(
location
=
=
ChunkLocation
:
:
Nursery
|
|
location
=
=
ChunkLocation
:
:
TenuredHeap
)
;
return
location
=
=
ChunkLocation
:
:
Nursery
;
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
TenuredCell
*
cell
)
{
MOZ_ASSERT_IF
(
cell
detail
:
:
GetCellLocation
(
reinterpret_cast
<
const
Cell
*
>
(
cell
)
)
=
=
ChunkLocation
:
:
TenuredHeap
)
;
return
false
;
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
JSObject
*
obj
)
{
return
IsInsideNursery
(
reinterpret_cast
<
const
Cell
*
>
(
obj
)
)
;
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
JSString
*
str
)
{
return
IsInsideNursery
(
reinterpret_cast
<
const
Cell
*
>
(
str
)
)
;
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
JS
:
:
BigInt
*
bi
)
{
return
IsInsideNursery
(
reinterpret_cast
<
const
Cell
*
>
(
bi
)
)
;
}
MOZ_ALWAYS_INLINE
bool
IsCellPointerValid
(
const
void
*
ptr
)
{
auto
addr
=
uintptr_t
(
ptr
)
;
if
(
addr
<
ChunkSize
|
|
addr
%
CellAlignBytes
!
=
0
)
{
return
false
;
}
auto
*
cell
=
reinterpret_cast
<
const
Cell
*
>
(
ptr
)
;
auto
location
=
detail
:
:
GetCellLocation
(
cell
)
;
if
(
location
=
=
ChunkLocation
:
:
TenuredHeap
)
{
return
!
!
detail
:
:
GetTenuredGCThingZone
(
addr
)
;
}
if
(
location
=
=
ChunkLocation
:
:
Nursery
)
{
return
detail
:
:
CellHasStoreBuffer
(
cell
)
;
}
return
false
;
}
MOZ_ALWAYS_INLINE
bool
IsCellPointerValidOrNull
(
const
void
*
cell
)
{
if
(
!
cell
)
{
return
true
;
}
return
IsCellPointerValid
(
cell
)
;
}
}
}
namespace
JS
{
static
MOZ_ALWAYS_INLINE
Zone
*
GetTenuredGCThingZone
(
GCCellPtr
thing
)
{
MOZ_ASSERT
(
!
js
:
:
gc
:
:
IsInsideNursery
(
thing
.
asCell
(
)
)
)
;
return
js
:
:
gc
:
:
detail
:
:
GetTenuredGCThingZone
(
thing
.
unsafeAsUIntPtr
(
)
)
;
}
extern
JS_PUBLIC_API
Zone
*
GetNurseryCellZone
(
js
:
:
gc
:
:
Cell
*
cell
)
;
static
MOZ_ALWAYS_INLINE
Zone
*
GetGCThingZone
(
GCCellPtr
thing
)
{
if
(
!
js
:
:
gc
:
:
IsInsideNursery
(
thing
.
asCell
(
)
)
)
{
return
js
:
:
gc
:
:
detail
:
:
GetTenuredGCThingZone
(
thing
.
unsafeAsUIntPtr
(
)
)
;
}
return
GetNurseryCellZone
(
thing
.
asCell
(
)
)
;
}
static
MOZ_ALWAYS_INLINE
Zone
*
GetStringZone
(
JSString
*
str
)
{
if
(
!
js
:
:
gc
:
:
IsInsideNursery
(
str
)
)
{
return
js
:
:
gc
:
:
detail
:
:
GetTenuredGCThingZone
(
reinterpret_cast
<
uintptr_t
>
(
str
)
)
;
}
return
GetNurseryCellZone
(
reinterpret_cast
<
js
:
:
gc
:
:
Cell
*
>
(
str
)
)
;
}
extern
JS_PUBLIC_API
Zone
*
GetObjectZone
(
JSObject
*
obj
)
;
static
MOZ_ALWAYS_INLINE
bool
GCThingIsMarkedGray
(
GCCellPtr
thing
)
{
if
(
thing
.
mayBeOwnedByOtherRuntime
(
)
)
{
return
false
;
}
return
js
:
:
gc
:
:
detail
:
:
CellIsMarkedGrayIfKnown
(
thing
.
asCell
(
)
)
;
}
extern
JS_PUBLIC_API
JS
:
:
TraceKind
GCThingTraceKind
(
void
*
thing
)
;
extern
JS_PUBLIC_API
void
EnableNurseryStrings
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
DisableNurseryStrings
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
EnableNurseryBigInts
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
DisableNurseryBigInts
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
bool
IsIncrementalBarrierNeeded
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
IncrementalPreWriteBarrier
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
void
IncrementalPreWriteBarrier
(
GCCellPtr
thing
)
;
extern
JS_FRIEND_API
bool
UnmarkGrayGCThingRecursively
(
GCCellPtr
thing
)
;
}
namespace
js
{
namespace
gc
{
extern
JS_PUBLIC_API
void
PerformIncrementalReadBarrier
(
JS
:
:
GCCellPtr
thing
)
;
static
MOZ_ALWAYS_INLINE
void
ExposeGCThingToActiveJS
(
JS
:
:
GCCellPtr
thing
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
if
(
IsInsideNursery
(
thing
.
asCell
(
)
)
)
{
return
;
}
auto
*
cell
=
reinterpret_cast
<
TenuredCell
*
>
(
thing
.
asCell
(
)
)
;
if
(
thing
.
mayBeOwnedByOtherRuntime
(
)
)
{
return
;
}
auto
*
zone
=
JS
:
:
shadow
:
:
Zone
:
:
from
(
JS
:
:
GetTenuredGCThingZone
(
thing
)
)
;
if
(
zone
-
>
needsIncrementalBarrier
(
)
)
{
PerformIncrementalReadBarrier
(
thing
)
;
}
else
if
(
!
zone
-
>
isGCPreparing
(
)
&
&
detail
:
:
TenuredCellIsMarkedGray
(
cell
)
)
{
MOZ_ALWAYS_TRUE
(
JS
:
:
UnmarkGrayGCThingRecursively
(
thing
)
)
;
}
MOZ_ASSERT_IF
(
!
zone
-
>
isGCPreparing
(
)
!
detail
:
:
TenuredCellIsMarkedGray
(
cell
)
)
;
}
template
<
typename
T
>
extern
JS_PUBLIC_API
bool
EdgeNeedsSweepUnbarrieredSlow
(
T
*
thingp
)
;
static
MOZ_ALWAYS_INLINE
bool
EdgeNeedsSweepUnbarriered
(
JSObject
*
*
objp
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsMinorCollecting
(
)
)
;
if
(
IsInsideNursery
(
*
objp
)
)
{
return
false
;
}
auto
zone
=
JS
:
:
shadow
:
:
Zone
:
:
from
(
detail
:
:
GetTenuredGCThingZone
(
uintptr_t
(
*
objp
)
)
)
;
if
(
!
zone
-
>
isGCSweepingOrCompacting
(
)
)
{
return
false
;
}
return
EdgeNeedsSweepUnbarrieredSlow
(
objp
)
;
}
}
}
namespace
JS
{
static
MOZ_ALWAYS_INLINE
void
ExposeObjectToActiveJS
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
obj
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
EdgeNeedsSweepUnbarrieredSlow
(
&
obj
)
)
;
js
:
:
gc
:
:
ExposeGCThingToActiveJS
(
GCCellPtr
(
obj
)
)
;
}
}
#
endif
