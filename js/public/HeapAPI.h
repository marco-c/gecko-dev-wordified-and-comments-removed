#
ifndef
js_HeapAPI_h
#
define
js_HeapAPI_h
#
include
<
limits
.
h
>
#
include
"
jspubtd
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
#
include
"
js
/
TraceKind
.
h
"
#
include
"
js
/
Utility
.
h
"
#
ifndef
JS_BITS_PER_WORD
#
error
\
"
JS_BITS_PER_WORD
must
be
defined
.
Did
you
forget
to
include
js
-
config
.
h
?
"
#
endif
struct
JSExternalStringCallbacks
;
namespace
js
{
JS_FRIEND_API
bool
CurrentThreadCanAccessZone
(
JS
:
:
Zone
*
zone
)
;
namespace
gc
{
struct
Cell
;
const
size_t
ArenaShift
=
12
;
const
size_t
ArenaSize
=
size_t
(
1
)
<
<
ArenaShift
;
const
size_t
ArenaMask
=
ArenaSize
-
1
;
#
ifdef
JS_GC_SMALL_CHUNK_SIZE
const
size_t
ChunkShift
=
18
;
#
else
const
size_t
ChunkShift
=
20
;
#
endif
const
size_t
ChunkSize
=
size_t
(
1
)
<
<
ChunkShift
;
const
size_t
ChunkMask
=
ChunkSize
-
1
;
const
size_t
CellAlignShift
=
3
;
const
size_t
CellAlignBytes
=
size_t
(
1
)
<
<
CellAlignShift
;
const
size_t
CellAlignMask
=
CellAlignBytes
-
1
;
const
size_t
ArenaCellIndexBytes
=
CellAlignBytes
;
const
size_t
MaxArenaCellIndex
=
ArenaSize
/
CellAlignBytes
;
const
size_t
ChunkRuntimeOffset
=
ChunkSize
-
sizeof
(
void
*
)
;
const
size_t
ChunkTrailerSize
=
2
*
sizeof
(
uintptr_t
)
+
sizeof
(
uint64_t
)
;
const
size_t
ChunkLocationOffset
=
ChunkSize
-
ChunkTrailerSize
;
const
size_t
ChunkStoreBufferOffset
=
ChunkSize
-
ChunkTrailerSize
+
sizeof
(
uint64_t
)
;
const
size_t
ArenaZoneOffset
=
sizeof
(
size_t
)
;
const
size_t
ArenaAllocKindOffset
=
ArenaZoneOffset
+
2
*
sizeof
(
uintptr_t
)
;
const
size_t
ArenaMarkBitsOffset
=
ArenaAllocKindOffset
+
2
*
sizeof
(
uintptr_t
)
;
const
size_t
ArenaHeaderSize
=
sizeof
(
size_t
)
+
2
*
sizeof
(
uintptr_t
)
+
sizeof
(
size_t
)
+
sizeof
(
uintptr_t
)
;
enum
class
ColorBit
:
uint32_t
{
BlackBit
=
0
GrayOrBlackBit
=
1
}
;
const
size_t
MarkBitMaskBlack
=
1
<
<
size_t
(
ColorBit
:
:
BlackBit
)
;
const
size_t
MarkBitMaskGrayOrBlack
=
1
<
<
size_t
(
ColorBit
:
:
GrayOrBlackBit
)
;
const
size_t
MarkBitMaskBothBits
=
MarkBitMaskBlack
|
MarkBitMaskGrayOrBlack
;
enum
class
ChunkLocation
:
uint32_t
{
Invalid
=
0
Nursery
=
1
TenuredHeap
=
2
}
;
extern
JS_PUBLIC_DATA
const
uint16_t
ReciprocalOfThingSize
[
]
;
const
size_t
ReciprocalThingSizeShift
=
12
;
#
ifdef
JS_DEBUG
extern
JS_FRIEND_API
void
AssertGCThingHasType
(
js
:
:
gc
:
:
Cell
*
cell
JS
:
:
TraceKind
kind
)
;
#
else
inline
void
AssertGCThingHasType
(
js
:
:
gc
:
:
Cell
*
cell
JS
:
:
TraceKind
kind
)
{
}
#
endif
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
js
:
:
gc
:
:
Cell
*
cell
)
;
}
}
namespace
JS
{
enum
class
HeapState
{
Idle
Tracing
MajorCollecting
MinorCollecting
CycleCollecting
}
;
JS_PUBLIC_API
HeapState
RuntimeHeapState
(
)
;
static
inline
bool
RuntimeHeapIsBusy
(
)
{
return
RuntimeHeapState
(
)
!
=
HeapState
:
:
Idle
;
}
static
inline
bool
RuntimeHeapIsTracing
(
)
{
return
RuntimeHeapState
(
)
=
=
HeapState
:
:
Tracing
;
}
static
inline
bool
RuntimeHeapIsMajorCollecting
(
)
{
return
RuntimeHeapState
(
)
=
=
HeapState
:
:
MajorCollecting
;
}
static
inline
bool
RuntimeHeapIsMinorCollecting
(
)
{
return
RuntimeHeapState
(
)
=
=
HeapState
:
:
MinorCollecting
;
}
static
inline
bool
RuntimeHeapIsCollecting
(
HeapState
state
)
{
return
state
=
=
HeapState
:
:
MajorCollecting
|
|
state
=
=
HeapState
:
:
MinorCollecting
;
}
static
inline
bool
RuntimeHeapIsCollecting
(
)
{
return
RuntimeHeapIsCollecting
(
RuntimeHeapState
(
)
)
;
}
static
inline
bool
RuntimeHeapIsCycleCollecting
(
)
{
return
RuntimeHeapState
(
)
=
=
HeapState
:
:
CycleCollecting
;
}
enum
StackKind
{
StackForSystemCode
StackForTrustedScript
StackForUntrustedScript
StackKindCount
}
;
const
uint32_t
DefaultNurseryMaxBytes
=
16
*
js
:
:
gc
:
:
ChunkSize
;
const
uint32_t
DefaultHeapMaxBytes
=
32
*
1024
*
1024
;
namespace
shadow
{
struct
Zone
{
enum
GCState
:
uint8_t
{
NoGC
MarkBlackOnly
MarkBlackAndGray
Sweep
Finished
Compact
}
;
protected
:
JSRuntime
*
const
runtime_
;
JSTracer
*
const
barrierTracer_
;
uint32_t
needsIncrementalBarrier_
;
GCState
gcState_
;
Zone
(
JSRuntime
*
runtime
JSTracer
*
barrierTracerArg
)
:
runtime_
(
runtime
)
barrierTracer_
(
barrierTracerArg
)
needsIncrementalBarrier_
(
0
)
gcState_
(
NoGC
)
{
}
public
:
bool
needsIncrementalBarrier
(
)
const
{
return
needsIncrementalBarrier_
;
}
JSTracer
*
barrierTracer
(
)
{
MOZ_ASSERT
(
needsIncrementalBarrier_
)
;
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
return
barrierTracer_
;
}
JSRuntime
*
runtimeFromMainThread
(
)
const
{
MOZ_ASSERT
(
js
:
:
CurrentThreadCanAccessRuntime
(
runtime_
)
)
;
return
runtime_
;
}
JSRuntime
*
runtimeFromAnyThread
(
)
const
{
return
runtime_
;
}
GCState
gcState
(
)
const
{
return
gcState_
;
}
bool
wasGCStarted
(
)
const
{
return
gcState_
!
=
NoGC
;
}
bool
isGCMarkingBlackOnly
(
)
const
{
return
gcState_
=
=
MarkBlackOnly
;
}
bool
isGCMarkingBlackAndGray
(
)
const
{
return
gcState_
=
=
MarkBlackAndGray
;
}
bool
isGCSweeping
(
)
const
{
return
gcState_
=
=
Sweep
;
}
bool
isGCFinished
(
)
const
{
return
gcState_
=
=
Finished
;
}
bool
isGCCompacting
(
)
const
{
return
gcState_
=
=
Compact
;
}
bool
isGCMarking
(
)
const
{
return
isGCMarkingBlackOnly
(
)
|
|
isGCMarkingBlackAndGray
(
)
;
}
bool
isGCSweepingOrCompacting
(
)
const
{
return
gcState_
=
=
Sweep
|
|
gcState_
=
=
Compact
;
}
static
MOZ_ALWAYS_INLINE
JS
:
:
shadow
:
:
Zone
*
from
(
JS
:
:
Zone
*
zone
)
{
return
reinterpret_cast
<
JS
:
:
shadow
:
:
Zone
*
>
(
zone
)
;
}
}
;
struct
String
{
static
const
uint32_t
NON_ATOM_BIT
=
js
:
:
Bit
(
1
)
;
static
const
uint32_t
LINEAR_BIT
=
js
:
:
Bit
(
4
)
;
static
const
uint32_t
INLINE_CHARS_BIT
=
js
:
:
Bit
(
6
)
;
static
const
uint32_t
LATIN1_CHARS_BIT
=
js
:
:
Bit
(
9
)
;
static
const
uint32_t
EXTERNAL_FLAGS
=
LINEAR_BIT
|
NON_ATOM_BIT
|
js
:
:
Bit
(
8
)
;
static
const
uint32_t
TYPE_FLAGS_MASK
=
js
:
:
BitMask
(
9
)
-
js
:
:
Bit
(
2
)
-
js
:
:
Bit
(
0
)
;
static
const
uint32_t
PERMANENT_ATOM_MASK
=
NON_ATOM_BIT
|
js
:
:
Bit
(
8
)
;
static
const
uint32_t
PERMANENT_ATOM_FLAGS
=
js
:
:
Bit
(
8
)
;
uintptr_t
flags_
;
#
if
JS_BITS_PER_WORD
=
=
32
uint32_t
length_
;
#
endif
union
{
const
JS
:
:
Latin1Char
*
nonInlineCharsLatin1
;
const
char16_t
*
nonInlineCharsTwoByte
;
JS
:
:
Latin1Char
inlineStorageLatin1
[
1
]
;
char16_t
inlineStorageTwoByte
[
1
]
;
}
;
const
JSExternalStringCallbacks
*
externalCallbacks
;
inline
uint32_t
flags
(
)
const
{
return
uint32_t
(
flags_
)
;
}
inline
uint32_t
length
(
)
const
{
#
if
JS_BITS_PER_WORD
=
=
32
return
length_
;
#
else
return
uint32_t
(
flags_
>
>
32
)
;
#
endif
}
static
bool
isPermanentAtom
(
const
js
:
:
gc
:
:
Cell
*
cell
)
{
uint32_t
flags
=
reinterpret_cast
<
const
String
*
>
(
cell
)
-
>
flags
(
)
;
return
(
flags
&
PERMANENT_ATOM_MASK
)
=
=
PERMANENT_ATOM_FLAGS
;
}
}
;
struct
Symbol
{
void
*
_1
;
uint32_t
code_
;
static
const
uint32_t
WellKnownAPILimit
=
0x80000000
;
static
bool
isWellKnownSymbol
(
const
js
:
:
gc
:
:
Cell
*
cell
)
{
return
reinterpret_cast
<
const
Symbol
*
>
(
cell
)
-
>
code_
<
WellKnownAPILimit
;
}
}
;
}
class
JS_FRIEND_API
GCCellPtr
{
public
:
GCCellPtr
(
)
:
GCCellPtr
(
nullptr
)
{
}
GCCellPtr
(
void
*
gcthing
JS
:
:
TraceKind
traceKind
)
:
ptr
(
checkedCast
(
gcthing
traceKind
)
)
{
}
MOZ_IMPLICIT
GCCellPtr
(
decltype
(
nullptr
)
)
:
ptr
(
checkedCast
(
nullptr
JS
:
:
TraceKind
:
:
Null
)
)
{
}
template
<
typename
T
>
explicit
GCCellPtr
(
T
*
p
)
:
ptr
(
checkedCast
(
p
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
)
)
{
}
explicit
GCCellPtr
(
JSFunction
*
p
)
:
ptr
(
checkedCast
(
p
JS
:
:
TraceKind
:
:
Object
)
)
{
}
explicit
GCCellPtr
(
const
Value
&
v
)
;
JS
:
:
TraceKind
kind
(
)
const
{
JS
:
:
TraceKind
traceKind
=
JS
:
:
TraceKind
(
ptr
&
OutOfLineTraceKindMask
)
;
if
(
uintptr_t
(
traceKind
)
!
=
OutOfLineTraceKindMask
)
{
return
traceKind
;
}
return
outOfLineKind
(
)
;
}
explicit
operator
bool
(
)
const
{
MOZ_ASSERT
(
bool
(
asCell
(
)
)
=
=
(
kind
(
)
!
=
JS
:
:
TraceKind
:
:
Null
)
)
;
return
asCell
(
)
;
}
template
<
typename
T
>
bool
is
(
)
const
{
return
kind
(
)
=
=
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
;
}
template
<
typename
T
>
T
&
as
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
)
;
return
*
reinterpret_cast
<
T
*
>
(
asCell
(
)
)
;
}
js
:
:
gc
:
:
Cell
*
asCell
(
)
const
{
return
reinterpret_cast
<
js
:
:
gc
:
:
Cell
*
>
(
ptr
&
~
OutOfLineTraceKindMask
)
;
}
uint64_t
unsafeAsInteger
(
)
const
{
return
static_cast
<
uint64_t
>
(
unsafeAsUIntPtr
(
)
)
;
}
uintptr_t
unsafeAsUIntPtr
(
)
const
{
MOZ_ASSERT
(
asCell
(
)
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
IsInsideNursery
(
asCell
(
)
)
)
;
return
reinterpret_cast
<
uintptr_t
>
(
asCell
(
)
)
;
}
MOZ_ALWAYS_INLINE
bool
mayBeOwnedByOtherRuntime
(
)
const
{
if
(
!
is
<
JSString
>
(
)
&
&
!
is
<
JS
:
:
Symbol
>
(
)
)
{
return
false
;
}
if
(
is
<
JSString
>
(
)
)
{
return
JS
:
:
shadow
:
:
String
:
:
isPermanentAtom
(
asCell
(
)
)
;
}
MOZ_ASSERT
(
is
<
JS
:
:
Symbol
>
(
)
)
;
return
JS
:
:
shadow
:
:
Symbol
:
:
isWellKnownSymbol
(
asCell
(
)
)
;
}
private
:
static
uintptr_t
checkedCast
(
void
*
p
JS
:
:
TraceKind
traceKind
)
{
js
:
:
gc
:
:
Cell
*
cell
=
static_cast
<
js
:
:
gc
:
:
Cell
*
>
(
p
)
;
MOZ_ASSERT
(
(
uintptr_t
(
p
)
&
OutOfLineTraceKindMask
)
=
=
0
)
;
AssertGCThingHasType
(
cell
traceKind
)
;
MOZ_ASSERT_IF
(
uintptr_t
(
traceKind
)
>
=
OutOfLineTraceKindMask
(
uintptr_t
(
traceKind
)
&
OutOfLineTraceKindMask
)
=
=
OutOfLineTraceKindMask
)
;
return
uintptr_t
(
p
)
|
(
uintptr_t
(
traceKind
)
&
OutOfLineTraceKindMask
)
;
}
JS
:
:
TraceKind
outOfLineKind
(
)
const
;
uintptr_t
ptr
;
}
JS_HAZ_GC_POINTER
;
template
<
typename
F
>
auto
MapGCThingTyped
(
GCCellPtr
thing
F
&
&
f
)
{
switch
(
thing
.
kind
(
)
)
{
#
define
JS_EXPAND_DEF
(
name
type
_
_1
)
\
case
JS
:
:
TraceKind
:
:
name
:
\
return
f
(
&
thing
.
as
<
type
>
(
)
)
;
JS_FOR_EACH_TRACEKIND
(
JS_EXPAND_DEF
)
;
#
undef
JS_EXPAND_DEF
default
:
MOZ_CRASH
(
"
Invalid
trace
kind
in
MapGCThingTyped
for
GCCellPtr
.
"
)
;
}
}
template
<
typename
F
>
void
ApplyGCThingTyped
(
GCCellPtr
thing
F
&
&
f
)
{
MapGCThingTyped
(
thing
f
)
;
}
}
inline
bool
operator
=
=
(
const
JS
:
:
GCCellPtr
&
ptr1
const
JS
:
:
GCCellPtr
&
ptr2
)
{
return
ptr1
.
asCell
(
)
=
=
ptr2
.
asCell
(
)
;
}
inline
bool
operator
!
=
(
const
JS
:
:
GCCellPtr
&
ptr1
const
JS
:
:
GCCellPtr
&
ptr2
)
{
return
!
(
ptr1
=
=
ptr2
)
;
}
namespace
js
{
namespace
gc
{
namespace
detail
{
static
MOZ_ALWAYS_INLINE
uint32_t
GetReciprocalOfTenuredCellSize
(
uintptr_t
addr
)
{
MOZ_ASSERT
(
addr
)
;
uint8_t
kind
=
*
reinterpret_cast
<
uint8_t
*
>
(
(
addr
&
~
ArenaMask
)
+
ArenaAllocKindOffset
)
;
return
ReciprocalOfThingSize
[
kind
]
;
}
static
MOZ_ALWAYS_INLINE
uint8_t
*
GetArenaMarkBits
(
uintptr_t
addr
)
{
MOZ_ASSERT
(
addr
)
;
return
reinterpret_cast
<
uint8_t
*
>
(
(
addr
&
~
ArenaMask
)
+
ArenaMarkBitsOffset
)
;
}
static
MOZ_ALWAYS_INLINE
uint8_t
*
GetTenuredCellMarkBits
(
uintptr_t
addr
)
{
size_t
offset
=
addr
&
ArenaMask
;
size_t
reciprocal
=
GetReciprocalOfTenuredCellSize
(
addr
)
;
size_t
index
=
(
(
offset
^
ArenaMask
)
*
reciprocal
)
>
>
ReciprocalThingSizeShift
;
return
GetArenaMarkBits
(
addr
)
+
index
;
}
static
MOZ_ALWAYS_INLINE
JS
:
:
Zone
*
GetGCThingZone
(
const
uintptr_t
addr
)
{
MOZ_ASSERT
(
addr
)
;
const
uintptr_t
zone_addr
=
(
addr
&
~
ArenaMask
)
|
ArenaZoneOffset
;
return
*
reinterpret_cast
<
JS
:
:
Zone
*
*
>
(
zone_addr
)
;
}
static
MOZ_ALWAYS_INLINE
bool
TenuredCellIsMarkedGray
(
const
Cell
*
cell
)
{
MOZ_ASSERT
(
cell
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
IsInsideNursery
(
cell
)
)
;
uint8_t
*
markBitsPtr
=
GetTenuredCellMarkBits
(
uintptr_t
(
cell
)
)
;
size_t
mask
=
MarkBitMaskBlack
|
MarkBitMaskGrayOrBlack
;
return
(
*
markBitsPtr
&
mask
)
=
=
MarkBitMaskGrayOrBlack
;
}
static
MOZ_ALWAYS_INLINE
bool
CellIsMarkedGray
(
const
Cell
*
cell
)
{
MOZ_ASSERT
(
cell
)
;
if
(
js
:
:
gc
:
:
IsInsideNursery
(
cell
)
)
{
return
false
;
}
return
TenuredCellIsMarkedGray
(
cell
)
;
}
extern
JS_PUBLIC_API
bool
CellIsMarkedGrayIfKnown
(
const
Cell
*
cell
)
;
#
ifdef
DEBUG
extern
JS_PUBLIC_API
void
AssertCellIsNotGray
(
const
Cell
*
cell
)
;
extern
JS_PUBLIC_API
bool
ObjectIsMarkedBlack
(
const
JSObject
*
obj
)
;
#
endif
MOZ_ALWAYS_INLINE
ChunkLocation
GetCellLocation
(
const
void
*
cell
)
{
uintptr_t
addr
=
uintptr_t
(
cell
)
;
addr
&
=
~
js
:
:
gc
:
:
ChunkMask
;
addr
|
=
js
:
:
gc
:
:
ChunkLocationOffset
;
return
*
reinterpret_cast
<
ChunkLocation
*
>
(
addr
)
;
}
MOZ_ALWAYS_INLINE
bool
NurseryCellHasStoreBuffer
(
const
void
*
cell
)
{
uintptr_t
addr
=
uintptr_t
(
cell
)
;
addr
&
=
~
js
:
:
gc
:
:
ChunkMask
;
addr
|
=
js
:
:
gc
:
:
ChunkStoreBufferOffset
;
return
*
reinterpret_cast
<
void
*
*
>
(
addr
)
!
=
nullptr
;
}
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
Cell
*
cell
)
{
if
(
!
cell
)
{
return
false
;
}
auto
location
=
detail
:
:
GetCellLocation
(
cell
)
;
MOZ_ASSERT
(
location
=
=
ChunkLocation
:
:
Nursery
|
|
location
=
=
ChunkLocation
:
:
TenuredHeap
)
;
return
location
=
=
ChunkLocation
:
:
Nursery
;
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
JSObject
*
obj
)
{
return
IsInsideNursery
(
reinterpret_cast
<
const
Cell
*
>
(
obj
)
)
;
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
JSString
*
str
)
{
return
IsInsideNursery
(
reinterpret_cast
<
const
Cell
*
>
(
str
)
)
;
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
JS
:
:
BigInt
*
bi
)
{
return
IsInsideNursery
(
reinterpret_cast
<
const
Cell
*
>
(
bi
)
)
;
}
MOZ_ALWAYS_INLINE
bool
IsCellPointerValid
(
const
void
*
cell
)
{
auto
addr
=
uintptr_t
(
cell
)
;
if
(
addr
<
ChunkSize
|
|
addr
%
CellAlignBytes
!
=
0
)
{
return
false
;
}
auto
location
=
detail
:
:
GetCellLocation
(
cell
)
;
if
(
location
=
=
ChunkLocation
:
:
TenuredHeap
)
{
return
!
!
detail
:
:
GetGCThingZone
(
addr
)
;
}
if
(
location
=
=
ChunkLocation
:
:
Nursery
)
{
return
detail
:
:
NurseryCellHasStoreBuffer
(
cell
)
;
}
return
false
;
}
MOZ_ALWAYS_INLINE
bool
IsCellPointerValidOrNull
(
const
void
*
cell
)
{
if
(
!
cell
)
{
return
true
;
}
return
IsCellPointerValid
(
cell
)
;
}
}
}
namespace
JS
{
static
MOZ_ALWAYS_INLINE
Zone
*
GetTenuredGCThingZone
(
GCCellPtr
thing
)
{
MOZ_ASSERT
(
!
js
:
:
gc
:
:
IsInsideNursery
(
thing
.
asCell
(
)
)
)
;
return
js
:
:
gc
:
:
detail
:
:
GetGCThingZone
(
thing
.
unsafeAsUIntPtr
(
)
)
;
}
extern
JS_PUBLIC_API
Zone
*
GetNurseryStringZone
(
JSString
*
str
)
;
static
MOZ_ALWAYS_INLINE
Zone
*
GetStringZone
(
JSString
*
str
)
{
if
(
!
js
:
:
gc
:
:
IsInsideNursery
(
str
)
)
{
return
js
:
:
gc
:
:
detail
:
:
GetGCThingZone
(
reinterpret_cast
<
uintptr_t
>
(
str
)
)
;
}
return
GetNurseryStringZone
(
str
)
;
}
extern
JS_PUBLIC_API
Zone
*
GetObjectZone
(
JSObject
*
obj
)
;
static
MOZ_ALWAYS_INLINE
bool
GCThingIsMarkedGray
(
GCCellPtr
thing
)
{
if
(
thing
.
mayBeOwnedByOtherRuntime
(
)
)
{
return
false
;
}
return
js
:
:
gc
:
:
detail
:
:
CellIsMarkedGrayIfKnown
(
thing
.
asCell
(
)
)
;
}
extern
JS_PUBLIC_API
JS
:
:
TraceKind
GCThingTraceKind
(
void
*
thing
)
;
extern
JS_PUBLIC_API
void
EnableNurseryStrings
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
DisableNurseryStrings
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
EnableNurseryBigInts
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
DisableNurseryBigInts
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
bool
IsIncrementalBarrierNeeded
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
IncrementalPreWriteBarrier
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
void
IncrementalPreWriteBarrier
(
GCCellPtr
thing
)
;
extern
JS_FRIEND_API
bool
UnmarkGrayGCThingRecursively
(
GCCellPtr
thing
)
;
}
namespace
js
{
namespace
gc
{
extern
JS_PUBLIC_API
void
PerformIncrementalReadBarrier
(
JS
:
:
GCCellPtr
thing
)
;
static
MOZ_ALWAYS_INLINE
bool
IsIncrementalBarrierNeededOnTenuredGCThing
(
const
JS
:
:
GCCellPtr
thing
)
{
MOZ_ASSERT
(
thing
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
IsInsideNursery
(
thing
.
asCell
(
)
)
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
JS
:
:
Zone
*
zone
=
JS
:
:
GetTenuredGCThingZone
(
thing
)
;
return
JS
:
:
shadow
:
:
Zone
:
:
from
(
zone
)
-
>
needsIncrementalBarrier
(
)
;
}
static
MOZ_ALWAYS_INLINE
void
ExposeGCThingToActiveJS
(
JS
:
:
GCCellPtr
thing
)
{
if
(
IsInsideNursery
(
thing
.
asCell
(
)
)
)
{
return
;
}
if
(
thing
.
mayBeOwnedByOtherRuntime
(
)
)
{
return
;
}
if
(
IsIncrementalBarrierNeededOnTenuredGCThing
(
thing
)
)
{
PerformIncrementalReadBarrier
(
thing
)
;
}
else
if
(
detail
:
:
TenuredCellIsMarkedGray
(
thing
.
asCell
(
)
)
)
{
JS
:
:
UnmarkGrayGCThingRecursively
(
thing
)
;
}
MOZ_ASSERT
(
!
detail
:
:
TenuredCellIsMarkedGray
(
thing
.
asCell
(
)
)
)
;
}
template
<
typename
T
>
extern
JS_PUBLIC_API
bool
EdgeNeedsSweepUnbarrieredSlow
(
T
*
thingp
)
;
static
MOZ_ALWAYS_INLINE
bool
EdgeNeedsSweepUnbarriered
(
JSObject
*
*
objp
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsMinorCollecting
(
)
)
;
if
(
IsInsideNursery
(
*
objp
)
)
{
return
false
;
}
auto
zone
=
JS
:
:
shadow
:
:
Zone
:
:
from
(
detail
:
:
GetGCThingZone
(
uintptr_t
(
*
objp
)
)
)
;
if
(
!
zone
-
>
isGCSweepingOrCompacting
(
)
)
{
return
false
;
}
return
EdgeNeedsSweepUnbarrieredSlow
(
objp
)
;
}
}
}
namespace
JS
{
static
MOZ_ALWAYS_INLINE
void
ExposeObjectToActiveJS
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
obj
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
EdgeNeedsSweepUnbarrieredSlow
(
&
obj
)
)
;
js
:
:
gc
:
:
ExposeGCThingToActiveJS
(
GCCellPtr
(
obj
)
)
;
}
}
#
endif
