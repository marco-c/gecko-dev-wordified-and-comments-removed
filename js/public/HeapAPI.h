#
ifndef
js_HeapAPI_h
#
define
js_HeapAPI_h
#
include
<
limits
.
h
>
#
include
<
type_traits
>
#
include
"
jspubtd
.
h
"
#
include
"
js
/
GCAnnotations
.
h
"
#
include
"
js
/
shadow
/
String
.
h
"
#
include
"
js
/
shadow
/
Symbol
.
h
"
#
include
"
js
/
shadow
/
Zone
.
h
"
#
include
"
js
/
TraceKind
.
h
"
#
include
"
js
/
Utility
.
h
"
#
ifndef
JS_BITS_PER_WORD
#
error
\
"
JS_BITS_PER_WORD
must
be
defined
.
Did
you
forget
to
include
js
-
config
.
h
?
"
#
endif
struct
JSExternalStringCallbacks
;
namespace
js
{
JS_FRIEND_API
bool
CurrentThreadCanAccessZone
(
JS
:
:
Zone
*
zone
)
;
namespace
gc
{
struct
Cell
;
class
TenuredCell
;
const
size_t
ArenaShift
=
12
;
const
size_t
ArenaSize
=
size_t
(
1
)
<
<
ArenaShift
;
const
size_t
ArenaMask
=
ArenaSize
-
1
;
#
ifdef
JS_GC_SMALL_CHUNK_SIZE
const
size_t
ChunkShift
=
18
;
#
else
const
size_t
ChunkShift
=
20
;
#
endif
const
size_t
ChunkSize
=
size_t
(
1
)
<
<
ChunkShift
;
const
size_t
ChunkMask
=
ChunkSize
-
1
;
const
size_t
CellAlignShift
=
3
;
const
size_t
CellAlignBytes
=
size_t
(
1
)
<
<
CellAlignShift
;
const
size_t
CellAlignMask
=
CellAlignBytes
-
1
;
const
size_t
CellBytesPerMarkBit
=
CellAlignBytes
;
const
size_t
ArenaCellIndexBytes
=
CellAlignBytes
;
const
size_t
MaxArenaCellIndex
=
ArenaSize
/
CellAlignBytes
;
#
ifdef
JS_GC_SMALL_CHUNK_SIZE
const
size_t
ChunkMarkBitmapOffset
=
258104
;
const
size_t
ChunkMarkBitmapBits
=
31744
;
#
else
const
size_t
ChunkMarkBitmapOffset
=
1032352
;
const
size_t
ChunkMarkBitmapBits
=
129024
;
#
endif
const
size_t
ChunkRuntimeOffset
=
ChunkSize
-
sizeof
(
void
*
)
;
const
size_t
ChunkTrailerSize
=
2
*
sizeof
(
uintptr_t
)
+
sizeof
(
uint64_t
)
;
const
size_t
ChunkLocationOffset
=
ChunkSize
-
ChunkTrailerSize
;
const
size_t
ChunkStoreBufferOffset
=
ChunkSize
-
ChunkTrailerSize
+
sizeof
(
uint64_t
)
;
const
size_t
ArenaZoneOffset
=
sizeof
(
size_t
)
;
const
size_t
ArenaHeaderSize
=
sizeof
(
size_t
)
+
2
*
sizeof
(
uintptr_t
)
+
sizeof
(
size_t
)
+
sizeof
(
uintptr_t
)
;
const
size_t
CellFlagBitsReservedForGC
=
3
;
const
size_t
JSClassAlignBytes
=
size_t
(
1
)
<
<
CellFlagBitsReservedForGC
;
enum
class
ColorBit
:
uint32_t
{
BlackBit
=
0
GrayOrBlackBit
=
1
}
;
enum
class
ChunkLocation
:
uint32_t
{
Invalid
=
0
Nursery
=
1
TenuredHeap
=
2
}
;
#
ifdef
JS_DEBUG
extern
JS_FRIEND_API
void
AssertGCThingHasType
(
js
:
:
gc
:
:
Cell
*
cell
JS
:
:
TraceKind
kind
)
;
#
else
inline
void
AssertGCThingHasType
(
js
:
:
gc
:
:
Cell
*
cell
JS
:
:
TraceKind
kind
)
{
}
#
endif
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
js
:
:
gc
:
:
Cell
*
cell
)
;
}
}
namespace
JS
{
enum
class
HeapState
{
Idle
Tracing
MajorCollecting
MinorCollecting
CycleCollecting
}
;
JS_PUBLIC_API
HeapState
RuntimeHeapState
(
)
;
static
inline
bool
RuntimeHeapIsBusy
(
)
{
return
RuntimeHeapState
(
)
!
=
HeapState
:
:
Idle
;
}
static
inline
bool
RuntimeHeapIsTracing
(
)
{
return
RuntimeHeapState
(
)
=
=
HeapState
:
:
Tracing
;
}
static
inline
bool
RuntimeHeapIsMajorCollecting
(
)
{
return
RuntimeHeapState
(
)
=
=
HeapState
:
:
MajorCollecting
;
}
static
inline
bool
RuntimeHeapIsMinorCollecting
(
)
{
return
RuntimeHeapState
(
)
=
=
HeapState
:
:
MinorCollecting
;
}
static
inline
bool
RuntimeHeapIsCollecting
(
HeapState
state
)
{
return
state
=
=
HeapState
:
:
MajorCollecting
|
|
state
=
=
HeapState
:
:
MinorCollecting
;
}
static
inline
bool
RuntimeHeapIsCollecting
(
)
{
return
RuntimeHeapIsCollecting
(
RuntimeHeapState
(
)
)
;
}
static
inline
bool
RuntimeHeapIsCycleCollecting
(
)
{
return
RuntimeHeapState
(
)
=
=
HeapState
:
:
CycleCollecting
;
}
enum
StackKind
{
StackForSystemCode
StackForTrustedScript
StackForUntrustedScript
StackKindCount
}
;
const
uint32_t
DefaultNurseryMaxBytes
=
16
*
js
:
:
gc
:
:
ChunkSize
;
const
uint32_t
DefaultHeapMaxBytes
=
32
*
1024
*
1024
;
class
JS_FRIEND_API
GCCellPtr
{
public
:
GCCellPtr
(
)
:
GCCellPtr
(
nullptr
)
{
}
GCCellPtr
(
void
*
gcthing
JS
:
:
TraceKind
traceKind
)
:
ptr
(
checkedCast
(
gcthing
traceKind
)
)
{
}
MOZ_IMPLICIT
GCCellPtr
(
decltype
(
nullptr
)
)
:
ptr
(
checkedCast
(
nullptr
JS
:
:
TraceKind
:
:
Null
)
)
{
}
template
<
typename
T
>
explicit
GCCellPtr
(
T
*
p
)
:
ptr
(
checkedCast
(
p
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
)
)
{
}
explicit
GCCellPtr
(
JSFunction
*
p
)
:
ptr
(
checkedCast
(
p
JS
:
:
TraceKind
:
:
Object
)
)
{
}
explicit
GCCellPtr
(
JSScript
*
p
)
:
ptr
(
checkedCast
(
p
JS
:
:
TraceKind
:
:
Script
)
)
{
}
explicit
GCCellPtr
(
const
Value
&
v
)
;
JS
:
:
TraceKind
kind
(
)
const
{
JS
:
:
TraceKind
traceKind
=
JS
:
:
TraceKind
(
ptr
&
OutOfLineTraceKindMask
)
;
if
(
uintptr_t
(
traceKind
)
!
=
OutOfLineTraceKindMask
)
{
return
traceKind
;
}
return
outOfLineKind
(
)
;
}
explicit
operator
bool
(
)
const
{
MOZ_ASSERT
(
bool
(
asCell
(
)
)
=
=
(
kind
(
)
!
=
JS
:
:
TraceKind
:
:
Null
)
)
;
return
asCell
(
)
;
}
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
JS
:
:
IsBaseTraceType_v
<
T
>
>
>
bool
is
(
)
const
{
return
kind
(
)
=
=
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
;
}
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
JS
:
:
IsBaseTraceType_v
<
T
>
>
>
T
&
as
(
)
const
{
MOZ_ASSERT
(
kind
(
)
=
=
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
)
;
return
*
reinterpret_cast
<
T
*
>
(
asCell
(
)
)
;
}
js
:
:
gc
:
:
Cell
*
asCell
(
)
const
{
return
reinterpret_cast
<
js
:
:
gc
:
:
Cell
*
>
(
ptr
&
~
OutOfLineTraceKindMask
)
;
}
uint64_t
unsafeAsInteger
(
)
const
{
return
static_cast
<
uint64_t
>
(
unsafeAsUIntPtr
(
)
)
;
}
uintptr_t
unsafeAsUIntPtr
(
)
const
{
MOZ_ASSERT
(
asCell
(
)
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
IsInsideNursery
(
asCell
(
)
)
)
;
return
reinterpret_cast
<
uintptr_t
>
(
asCell
(
)
)
;
}
MOZ_ALWAYS_INLINE
bool
mayBeOwnedByOtherRuntime
(
)
const
{
if
(
!
is
<
JSString
>
(
)
&
&
!
is
<
JS
:
:
Symbol
>
(
)
)
{
return
false
;
}
if
(
is
<
JSString
>
(
)
)
{
return
JS
:
:
shadow
:
:
String
:
:
isPermanentAtom
(
asCell
(
)
)
;
}
MOZ_ASSERT
(
is
<
JS
:
:
Symbol
>
(
)
)
;
return
JS
:
:
shadow
:
:
Symbol
:
:
isWellKnownSymbol
(
asCell
(
)
)
;
}
private
:
static
uintptr_t
checkedCast
(
void
*
p
JS
:
:
TraceKind
traceKind
)
{
auto
*
cell
=
static_cast
<
js
:
:
gc
:
:
Cell
*
>
(
p
)
;
MOZ_ASSERT
(
(
uintptr_t
(
p
)
&
OutOfLineTraceKindMask
)
=
=
0
)
;
AssertGCThingHasType
(
cell
traceKind
)
;
MOZ_ASSERT_IF
(
uintptr_t
(
traceKind
)
>
=
OutOfLineTraceKindMask
(
uintptr_t
(
traceKind
)
&
OutOfLineTraceKindMask
)
=
=
OutOfLineTraceKindMask
)
;
return
uintptr_t
(
p
)
|
(
uintptr_t
(
traceKind
)
&
OutOfLineTraceKindMask
)
;
}
JS
:
:
TraceKind
outOfLineKind
(
)
const
;
uintptr_t
ptr
;
}
JS_HAZ_GC_POINTER
;
template
<
typename
F
>
auto
MapGCThingTyped
(
GCCellPtr
thing
F
&
&
f
)
{
switch
(
thing
.
kind
(
)
)
{
#
define
JS_EXPAND_DEF
(
name
type
_
_1
)
\
case
JS
:
:
TraceKind
:
:
name
:
\
return
f
(
&
thing
.
as
<
type
>
(
)
)
;
JS_FOR_EACH_TRACEKIND
(
JS_EXPAND_DEF
)
;
#
undef
JS_EXPAND_DEF
default
:
MOZ_CRASH
(
"
Invalid
trace
kind
in
MapGCThingTyped
for
GCCellPtr
.
"
)
;
}
}
template
<
typename
F
>
void
ApplyGCThingTyped
(
GCCellPtr
thing
F
&
&
f
)
{
MapGCThingTyped
(
thing
f
)
;
}
}
inline
bool
operator
=
=
(
const
JS
:
:
GCCellPtr
&
ptr1
const
JS
:
:
GCCellPtr
&
ptr2
)
{
return
ptr1
.
asCell
(
)
=
=
ptr2
.
asCell
(
)
;
}
inline
bool
operator
!
=
(
const
JS
:
:
GCCellPtr
&
ptr1
const
JS
:
:
GCCellPtr
&
ptr2
)
{
return
!
(
ptr1
=
=
ptr2
)
;
}
namespace
js
{
namespace
gc
{
namespace
detail
{
static
MOZ_ALWAYS_INLINE
uintptr_t
*
GetGCThingMarkBitmap
(
const
uintptr_t
addr
)
{
MOZ_ASSERT
(
addr
)
;
const
uintptr_t
bmap_addr
=
(
addr
&
~
ChunkMask
)
|
ChunkMarkBitmapOffset
;
return
reinterpret_cast
<
uintptr_t
*
>
(
bmap_addr
)
;
}
static
MOZ_ALWAYS_INLINE
void
GetGCThingMarkWordAndMask
(
const
uintptr_t
addr
ColorBit
colorBit
uintptr_t
*
*
wordp
uintptr_t
*
maskp
)
{
MOZ_ASSERT
(
addr
)
;
const
size_t
bit
=
(
addr
&
js
:
:
gc
:
:
ChunkMask
)
/
js
:
:
gc
:
:
CellBytesPerMarkBit
+
static_cast
<
uint32_t
>
(
colorBit
)
;
MOZ_ASSERT
(
bit
<
js
:
:
gc
:
:
ChunkMarkBitmapBits
)
;
uintptr_t
*
bitmap
=
GetGCThingMarkBitmap
(
addr
)
;
const
uintptr_t
nbits
=
sizeof
(
*
bitmap
)
*
CHAR_BIT
;
*
maskp
=
uintptr_t
(
1
)
<
<
(
bit
%
nbits
)
;
*
wordp
=
&
bitmap
[
bit
/
nbits
]
;
}
static
MOZ_ALWAYS_INLINE
JS
:
:
Zone
*
GetTenuredGCThingZone
(
const
uintptr_t
addr
)
{
MOZ_ASSERT
(
addr
)
;
const
uintptr_t
zone_addr
=
(
addr
&
~
ArenaMask
)
|
ArenaZoneOffset
;
return
*
reinterpret_cast
<
JS
:
:
Zone
*
*
>
(
zone_addr
)
;
}
static
MOZ_ALWAYS_INLINE
bool
TenuredCellIsMarkedGray
(
const
Cell
*
cell
)
{
MOZ_ASSERT
(
cell
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
IsInsideNursery
(
cell
)
)
;
uintptr_t
*
grayWord
grayMask
;
js
:
:
gc
:
:
detail
:
:
GetGCThingMarkWordAndMask
(
uintptr_t
(
cell
)
js
:
:
gc
:
:
ColorBit
:
:
GrayOrBlackBit
&
grayWord
&
grayMask
)
;
if
(
!
(
*
grayWord
&
grayMask
)
)
{
return
false
;
}
uintptr_t
*
blackWord
blackMask
;
js
:
:
gc
:
:
detail
:
:
GetGCThingMarkWordAndMask
(
uintptr_t
(
cell
)
js
:
:
gc
:
:
ColorBit
:
:
BlackBit
&
blackWord
&
blackMask
)
;
return
!
(
*
blackWord
&
blackMask
)
;
}
static
MOZ_ALWAYS_INLINE
bool
CellIsMarkedGray
(
const
Cell
*
cell
)
{
MOZ_ASSERT
(
cell
)
;
if
(
js
:
:
gc
:
:
IsInsideNursery
(
cell
)
)
{
return
false
;
}
return
TenuredCellIsMarkedGray
(
cell
)
;
}
extern
JS_PUBLIC_API
bool
CellIsMarkedGrayIfKnown
(
const
Cell
*
cell
)
;
#
ifdef
DEBUG
extern
JS_PUBLIC_API
void
AssertCellIsNotGray
(
const
Cell
*
cell
)
;
extern
JS_PUBLIC_API
bool
ObjectIsMarkedBlack
(
const
JSObject
*
obj
)
;
#
endif
MOZ_ALWAYS_INLINE
ChunkLocation
GetCellLocation
(
const
void
*
cell
)
{
uintptr_t
addr
=
uintptr_t
(
cell
)
;
addr
&
=
~
js
:
:
gc
:
:
ChunkMask
;
addr
|
=
js
:
:
gc
:
:
ChunkLocationOffset
;
return
*
reinterpret_cast
<
ChunkLocation
*
>
(
addr
)
;
}
MOZ_ALWAYS_INLINE
bool
NurseryCellHasStoreBuffer
(
const
void
*
cell
)
{
uintptr_t
addr
=
uintptr_t
(
cell
)
;
addr
&
=
~
js
:
:
gc
:
:
ChunkMask
;
addr
|
=
js
:
:
gc
:
:
ChunkStoreBufferOffset
;
return
*
reinterpret_cast
<
void
*
*
>
(
addr
)
!
=
nullptr
;
}
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
Cell
*
cell
)
{
if
(
!
cell
)
{
return
false
;
}
auto
location
=
detail
:
:
GetCellLocation
(
cell
)
;
MOZ_ASSERT
(
location
=
=
ChunkLocation
:
:
Nursery
|
|
location
=
=
ChunkLocation
:
:
TenuredHeap
)
;
return
location
=
=
ChunkLocation
:
:
Nursery
;
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
TenuredCell
*
cell
)
{
MOZ_ASSERT_IF
(
cell
detail
:
:
GetCellLocation
(
cell
)
=
=
ChunkLocation
:
:
TenuredHeap
)
;
return
false
;
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
JSObject
*
obj
)
{
return
IsInsideNursery
(
reinterpret_cast
<
const
Cell
*
>
(
obj
)
)
;
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
JSString
*
str
)
{
return
IsInsideNursery
(
reinterpret_cast
<
const
Cell
*
>
(
str
)
)
;
}
MOZ_ALWAYS_INLINE
bool
IsInsideNursery
(
const
JS
:
:
BigInt
*
bi
)
{
return
IsInsideNursery
(
reinterpret_cast
<
const
Cell
*
>
(
bi
)
)
;
}
MOZ_ALWAYS_INLINE
bool
IsCellPointerValid
(
const
void
*
cell
)
{
auto
addr
=
uintptr_t
(
cell
)
;
if
(
addr
<
ChunkSize
|
|
addr
%
CellAlignBytes
!
=
0
)
{
return
false
;
}
auto
location
=
detail
:
:
GetCellLocation
(
cell
)
;
if
(
location
=
=
ChunkLocation
:
:
TenuredHeap
)
{
return
!
!
detail
:
:
GetTenuredGCThingZone
(
addr
)
;
}
if
(
location
=
=
ChunkLocation
:
:
Nursery
)
{
return
detail
:
:
NurseryCellHasStoreBuffer
(
cell
)
;
}
return
false
;
}
MOZ_ALWAYS_INLINE
bool
IsCellPointerValidOrNull
(
const
void
*
cell
)
{
if
(
!
cell
)
{
return
true
;
}
return
IsCellPointerValid
(
cell
)
;
}
}
}
namespace
JS
{
static
MOZ_ALWAYS_INLINE
Zone
*
GetTenuredGCThingZone
(
GCCellPtr
thing
)
{
MOZ_ASSERT
(
!
js
:
:
gc
:
:
IsInsideNursery
(
thing
.
asCell
(
)
)
)
;
return
js
:
:
gc
:
:
detail
:
:
GetTenuredGCThingZone
(
thing
.
unsafeAsUIntPtr
(
)
)
;
}
extern
JS_PUBLIC_API
Zone
*
GetNurseryCellZone
(
js
:
:
gc
:
:
Cell
*
cell
)
;
static
MOZ_ALWAYS_INLINE
Zone
*
GetGCThingZone
(
GCCellPtr
thing
)
{
if
(
!
js
:
:
gc
:
:
IsInsideNursery
(
thing
.
asCell
(
)
)
)
{
return
js
:
:
gc
:
:
detail
:
:
GetTenuredGCThingZone
(
thing
.
unsafeAsUIntPtr
(
)
)
;
}
return
GetNurseryCellZone
(
thing
.
asCell
(
)
)
;
}
static
MOZ_ALWAYS_INLINE
Zone
*
GetStringZone
(
JSString
*
str
)
{
if
(
!
js
:
:
gc
:
:
IsInsideNursery
(
str
)
)
{
return
js
:
:
gc
:
:
detail
:
:
GetTenuredGCThingZone
(
reinterpret_cast
<
uintptr_t
>
(
str
)
)
;
}
return
GetNurseryCellZone
(
reinterpret_cast
<
js
:
:
gc
:
:
Cell
*
>
(
str
)
)
;
}
extern
JS_PUBLIC_API
Zone
*
GetObjectZone
(
JSObject
*
obj
)
;
static
MOZ_ALWAYS_INLINE
bool
GCThingIsMarkedGray
(
GCCellPtr
thing
)
{
if
(
thing
.
mayBeOwnedByOtherRuntime
(
)
)
{
return
false
;
}
return
js
:
:
gc
:
:
detail
:
:
CellIsMarkedGrayIfKnown
(
thing
.
asCell
(
)
)
;
}
extern
JS_PUBLIC_API
JS
:
:
TraceKind
GCThingTraceKind
(
void
*
thing
)
;
extern
JS_PUBLIC_API
void
EnableNurseryStrings
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
DisableNurseryStrings
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
EnableNurseryBigInts
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
DisableNurseryBigInts
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
bool
IsIncrementalBarrierNeeded
(
JSContext
*
cx
)
;
extern
JS_PUBLIC_API
void
IncrementalPreWriteBarrier
(
JSObject
*
obj
)
;
extern
JS_PUBLIC_API
void
IncrementalPreWriteBarrier
(
GCCellPtr
thing
)
;
extern
JS_FRIEND_API
bool
UnmarkGrayGCThingRecursively
(
GCCellPtr
thing
)
;
}
namespace
js
{
namespace
gc
{
extern
JS_PUBLIC_API
void
PerformIncrementalReadBarrier
(
JS
:
:
GCCellPtr
thing
)
;
static
MOZ_ALWAYS_INLINE
bool
IsIncrementalBarrierNeededOnTenuredGCThing
(
const
JS
:
:
GCCellPtr
thing
)
{
MOZ_ASSERT
(
thing
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
IsInsideNursery
(
thing
.
asCell
(
)
)
)
;
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsCollecting
(
)
)
;
JS
:
:
Zone
*
zone
=
JS
:
:
GetTenuredGCThingZone
(
thing
)
;
return
JS
:
:
shadow
:
:
Zone
:
:
from
(
zone
)
-
>
needsIncrementalBarrier
(
)
;
}
static
MOZ_ALWAYS_INLINE
void
ExposeGCThingToActiveJS
(
JS
:
:
GCCellPtr
thing
)
{
if
(
IsInsideNursery
(
thing
.
asCell
(
)
)
)
{
return
;
}
if
(
thing
.
mayBeOwnedByOtherRuntime
(
)
)
{
return
;
}
if
(
IsIncrementalBarrierNeededOnTenuredGCThing
(
thing
)
)
{
PerformIncrementalReadBarrier
(
thing
)
;
}
else
if
(
detail
:
:
TenuredCellIsMarkedGray
(
thing
.
asCell
(
)
)
)
{
JS
:
:
UnmarkGrayGCThingRecursively
(
thing
)
;
}
MOZ_ASSERT
(
!
detail
:
:
TenuredCellIsMarkedGray
(
thing
.
asCell
(
)
)
)
;
}
template
<
typename
T
>
extern
JS_PUBLIC_API
bool
EdgeNeedsSweepUnbarrieredSlow
(
T
*
thingp
)
;
static
MOZ_ALWAYS_INLINE
bool
EdgeNeedsSweepUnbarriered
(
JSObject
*
*
objp
)
{
MOZ_ASSERT
(
!
JS
:
:
RuntimeHeapIsMinorCollecting
(
)
)
;
if
(
IsInsideNursery
(
*
objp
)
)
{
return
false
;
}
auto
zone
=
JS
:
:
shadow
:
:
Zone
:
:
from
(
detail
:
:
GetTenuredGCThingZone
(
uintptr_t
(
*
objp
)
)
)
;
if
(
!
zone
-
>
isGCSweepingOrCompacting
(
)
)
{
return
false
;
}
return
EdgeNeedsSweepUnbarrieredSlow
(
objp
)
;
}
}
}
namespace
JS
{
static
MOZ_ALWAYS_INLINE
void
ExposeObjectToActiveJS
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
obj
)
;
MOZ_ASSERT
(
!
js
:
:
gc
:
:
EdgeNeedsSweepUnbarrieredSlow
(
&
obj
)
)
;
js
:
:
gc
:
:
ExposeGCThingToActiveJS
(
GCCellPtr
(
obj
)
)
;
}
}
#
endif
