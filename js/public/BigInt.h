#
ifndef
js_BigInt_h
#
define
js_BigInt_h
#
include
"
mozilla
/
Span
.
h
"
#
include
<
limits
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
"
jstypes
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
namespace
mozilla
{
template
<
typename
T
>
class
Range
;
}
namespace
JS
{
class
JS_PUBLIC_API
BigInt
;
namespace
detail
{
using
Int64Limits
=
std
:
:
numeric_limits
<
int64_t
>
;
using
Uint64Limits
=
std
:
:
numeric_limits
<
uint64_t
>
;
extern
JS_PUBLIC_API
BigInt
*
BigIntFromInt64
(
JSContext
*
cx
int64_t
num
)
;
extern
JS_PUBLIC_API
BigInt
*
BigIntFromUint64
(
JSContext
*
cx
uint64_t
num
)
;
extern
JS_PUBLIC_API
BigInt
*
BigIntFromBool
(
JSContext
*
cx
bool
b
)
;
template
<
typename
T
typename
=
void
>
struct
NumberToBigIntConverter
;
template
<
typename
SignedIntT
>
struct
NumberToBigIntConverter
<
SignedIntT
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
SignedIntT
>
&
&
std
:
:
is_signed_v
<
SignedIntT
>
&
&
Int64Limits
:
:
min
(
)
<
=
std
:
:
numeric_limits
<
SignedIntT
>
:
:
min
(
)
&
&
std
:
:
numeric_limits
<
SignedIntT
>
:
:
max
(
)
<
=
Int64Limits
:
:
max
(
)
>
>
{
static
BigInt
*
convert
(
JSContext
*
cx
SignedIntT
num
)
{
return
BigIntFromInt64
(
cx
num
)
;
}
}
;
template
<
typename
UnsignedIntT
>
struct
NumberToBigIntConverter
<
UnsignedIntT
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
UnsignedIntT
>
&
&
std
:
:
is_unsigned_v
<
UnsignedIntT
>
&
&
std
:
:
numeric_limits
<
UnsignedIntT
>
:
:
max
(
)
<
=
Uint64Limits
:
:
max
(
)
>
>
{
static
BigInt
*
convert
(
JSContext
*
cx
UnsignedIntT
num
)
{
return
BigIntFromUint64
(
cx
num
)
;
}
}
;
template
<
>
struct
NumberToBigIntConverter
<
bool
>
{
static
BigInt
*
convert
(
JSContext
*
cx
bool
b
)
{
return
BigIntFromBool
(
cx
b
)
;
}
}
;
extern
JS_PUBLIC_API
bool
BigIntIsInt64
(
BigInt
*
bi
int64_t
*
result
)
;
extern
JS_PUBLIC_API
bool
BigIntIsUint64
(
BigInt
*
bi
uint64_t
*
result
)
;
template
<
typename
T
typename
=
void
>
struct
BigIntToNumberChecker
;
template
<
typename
SignedIntT
>
struct
BigIntToNumberChecker
<
SignedIntT
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
SignedIntT
>
&
&
std
:
:
is_signed_v
<
SignedIntT
>
&
&
Int64Limits
:
:
min
(
)
<
=
std
:
:
numeric_limits
<
SignedIntT
>
:
:
min
(
)
&
&
std
:
:
numeric_limits
<
SignedIntT
>
:
:
max
(
)
<
=
Int64Limits
:
:
max
(
)
>
>
{
using
TypeLimits
=
std
:
:
numeric_limits
<
SignedIntT
>
;
static
bool
fits
(
BigInt
*
bi
SignedIntT
*
result
)
{
int64_t
innerResult
;
if
(
!
BigIntIsInt64
(
bi
&
innerResult
)
)
{
return
false
;
}
if
(
TypeLimits
:
:
min
(
)
<
=
innerResult
&
&
innerResult
<
=
TypeLimits
:
:
max
(
)
)
{
*
result
=
SignedIntT
(
innerResult
)
;
return
true
;
}
return
false
;
}
}
;
template
<
typename
UnsignedIntT
>
struct
BigIntToNumberChecker
<
UnsignedIntT
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
UnsignedIntT
>
&
&
std
:
:
is_unsigned_v
<
UnsignedIntT
>
&
&
std
:
:
numeric_limits
<
UnsignedIntT
>
:
:
max
(
)
<
=
Uint64Limits
:
:
max
(
)
>
>
{
static
bool
fits
(
BigInt
*
bi
UnsignedIntT
*
result
)
{
uint64_t
innerResult
;
if
(
!
BigIntIsUint64
(
bi
&
innerResult
)
)
{
return
false
;
}
if
(
innerResult
<
=
std
:
:
numeric_limits
<
UnsignedIntT
>
:
:
max
(
)
)
{
*
result
=
UnsignedIntT
(
innerResult
)
;
return
true
;
}
return
false
;
}
}
;
}
template
<
typename
NumericT
>
static
inline
BigInt
*
NumberToBigInt
(
JSContext
*
cx
NumericT
val
)
{
return
detail
:
:
NumberToBigIntConverter
<
NumericT
>
:
:
convert
(
cx
val
)
;
}
extern
JS_PUBLIC_API
BigInt
*
NumberToBigInt
(
JSContext
*
cx
double
num
)
;
extern
JS_PUBLIC_API
BigInt
*
StringToBigInt
(
JSContext
*
cx
mozilla
:
:
Range
<
const
Latin1Char
>
chars
)
;
extern
JS_PUBLIC_API
BigInt
*
StringToBigInt
(
JSContext
*
cx
mozilla
:
:
Range
<
const
char16_t
>
chars
)
;
extern
JS_PUBLIC_API
BigInt
*
SimpleStringToBigInt
(
JSContext
*
cx
mozilla
:
:
Span
<
const
char
>
chars
uint8_t
radix
)
;
extern
JS_PUBLIC_API
BigInt
*
ToBigInt
(
JSContext
*
cx
Handle
<
Value
>
val
)
;
extern
JS_PUBLIC_API
int64_t
ToBigInt64
(
BigInt
*
bi
)
;
extern
JS_PUBLIC_API
uint64_t
ToBigUint64
(
BigInt
*
bi
)
;
extern
JS_PUBLIC_API
double
BigIntToNumber
(
BigInt
*
bi
)
;
extern
JS_PUBLIC_API
bool
BigIntIsNegative
(
BigInt
*
bi
)
;
template
<
typename
NumericT
>
static
inline
bool
BigIntFits
(
BigInt
*
bi
NumericT
*
out
)
{
return
detail
:
:
BigIntToNumberChecker
<
NumericT
>
:
:
fits
(
bi
out
)
;
}
extern
JS_PUBLIC_API
bool
BigIntFitsNumber
(
BigInt
*
bi
double
*
out
)
;
extern
JS_PUBLIC_API
JSString
*
BigIntToString
(
JSContext
*
cx
Handle
<
BigInt
*
>
bi
uint8_t
radix
)
;
}
#
endif
