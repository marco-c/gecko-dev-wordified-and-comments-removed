#
ifndef
js_SliceBudget_h
#
define
js_SliceBudget_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
<
stdint
.
h
>
namespace
js
{
struct
JS_PUBLIC_API
(
TimeBudget
)
{
int64_t
budget
;
explicit
TimeBudget
(
int64_t
milliseconds
)
{
budget
=
milliseconds
;
}
}
;
struct
JS_PUBLIC_API
(
WorkBudget
)
{
int64_t
budget
;
explicit
WorkBudget
(
int64_t
work
)
{
budget
=
work
;
}
}
;
class
JS_PUBLIC_API
(
SliceBudget
)
{
static
const
int64_t
unlimitedDeadline
=
INT64_MAX
;
static
const
intptr_t
unlimitedStartCounter
=
INTPTR_MAX
;
bool
checkOverBudget
(
JSContext
*
maybeCx
)
;
SliceBudget
(
)
;
public
:
TimeBudget
timeBudget
;
WorkBudget
workBudget
;
int64_t
deadline
;
mozilla
:
:
Atomic
<
intptr_t
mozilla
:
:
Relaxed
>
counter
;
static
const
intptr_t
CounterReset
=
1000
;
static
const
int64_t
UnlimitedTimeBudget
=
-
1
;
static
const
int64_t
UnlimitedWorkBudget
=
-
1
;
static
SliceBudget
unlimited
(
)
{
return
SliceBudget
(
)
;
}
explicit
SliceBudget
(
TimeBudget
time
)
;
explicit
SliceBudget
(
WorkBudget
work
)
;
SliceBudget
(
const
SliceBudget
&
other
)
:
timeBudget
(
other
.
timeBudget
)
workBudget
(
other
.
workBudget
)
deadline
(
other
.
deadline
)
counter
(
other
.
counter
)
{
}
SliceBudget
&
operator
=
(
const
SliceBudget
&
other
)
{
timeBudget
=
other
.
timeBudget
;
workBudget
=
other
.
workBudget
;
deadline
=
other
.
deadline
;
counter
=
intptr_t
(
other
.
counter
)
;
return
*
this
;
}
void
makeUnlimited
(
)
{
deadline
=
unlimitedDeadline
;
counter
=
unlimitedStartCounter
;
}
void
requestFullCheck
(
)
{
counter
=
0
;
}
void
step
(
intptr_t
amt
=
1
)
{
counter
-
=
amt
;
}
bool
isOverBudget
(
JSContext
*
maybeCx
=
nullptr
)
{
if
(
counter
>
0
)
return
false
;
return
checkOverBudget
(
maybeCx
)
;
}
bool
isWorkBudget
(
)
const
{
return
deadline
=
=
0
;
}
bool
isTimeBudget
(
)
const
{
return
deadline
>
0
&
&
!
isUnlimited
(
)
;
}
bool
isUnlimited
(
)
const
{
return
deadline
=
=
unlimitedDeadline
;
}
int
describe
(
char
*
buffer
size_t
maxlen
)
const
;
}
;
}
#
endif
