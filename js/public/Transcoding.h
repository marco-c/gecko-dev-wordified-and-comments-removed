#
ifndef
js_Transcoding_h
#
define
js_Transcoding_h
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
js
/
TypeDecls
.
h
"
namespace
JS
{
class
ReadOnlyCompileOptions
;
using
TranscodeBuffer
=
mozilla
:
:
Vector
<
uint8_t
>
;
using
TranscodeRange
=
mozilla
:
:
Range
<
uint8_t
>
;
struct
TranscodeSource
final
{
TranscodeSource
(
const
TranscodeRange
&
range_
const
char
*
file
uint32_t
line
)
:
range
(
range_
)
filename
(
file
)
lineno
(
line
)
{
}
const
TranscodeRange
range
;
const
char
*
filename
;
const
uint32_t
lineno
;
}
;
using
TranscodeSources
=
mozilla
:
:
Vector
<
TranscodeSource
>
;
enum
TranscodeResult
:
uint8_t
{
TranscodeResult_Ok
=
0
TranscodeResult_Failure
=
0x10
TranscodeResult_Failure_BadBuildId
=
TranscodeResult_Failure
|
0x1
TranscodeResult_Failure_RunOnceNotSupported
=
TranscodeResult_Failure
|
0x2
TranscodeResult_Failure_AsmJSNotSupported
=
TranscodeResult_Failure
|
0x3
TranscodeResult_Failure_BadDecode
=
TranscodeResult_Failure
|
0x4
TranscodeResult_Failure_WrongCompileOption
=
TranscodeResult_Failure
|
0x5
TranscodeResult_Failure_NotInterpretedFun
=
TranscodeResult_Failure
|
0x6
TranscodeResult_Throw
=
0x20
}
;
static
constexpr
size_t
BytecodeOffsetAlignment
=
4
;
static_assert
(
BytecodeOffsetAlignment
<
=
alignof
(
std
:
:
max_align_t
)
"
Alignment
condition
requires
a
custom
allocator
.
"
)
;
inline
size_t
AlignTranscodingBytecodeOffset
(
size_t
offset
)
{
size_t
extra
=
offset
%
BytecodeOffsetAlignment
;
if
(
extra
=
=
0
)
{
return
offset
;
}
size_t
padding
=
BytecodeOffsetAlignment
-
extra
;
return
offset
+
padding
;
}
inline
bool
IsTranscodingBytecodeOffsetAligned
(
size_t
offset
)
{
return
offset
%
BytecodeOffsetAlignment
=
=
0
;
}
inline
bool
IsTranscodingBytecodeAligned
(
void
*
offset
)
{
return
IsTranscodingBytecodeOffsetAligned
(
size_t
(
offset
)
)
;
}
extern
JS_PUBLIC_API
TranscodeResult
EncodeScript
(
JSContext
*
cx
TranscodeBuffer
&
buffer
Handle
<
JSScript
*
>
script
)
;
extern
JS_PUBLIC_API
TranscodeResult
DecodeScript
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
TranscodeBuffer
&
buffer
MutableHandle
<
JSScript
*
>
scriptp
size_t
cursorIndex
=
0
)
;
extern
JS_PUBLIC_API
TranscodeResult
DecodeScript
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
const
TranscodeRange
&
range
MutableHandle
<
JSScript
*
>
scriptp
)
;
extern
JS_PUBLIC_API
TranscodeResult
DecodeScriptMaybeStencil
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
TranscodeBuffer
&
buffer
MutableHandle
<
JSScript
*
>
scriptp
size_t
cursorIndex
=
0
)
;
extern
JS_PUBLIC_API
TranscodeResult
DecodeScriptAndStartIncrementalEncoding
(
JSContext
*
cx
const
ReadOnlyCompileOptions
&
options
TranscodeBuffer
&
buffer
MutableHandle
<
JSScript
*
>
scriptp
size_t
cursorIndex
=
0
)
;
extern
JS_PUBLIC_API
bool
FinishIncrementalEncoding
(
JSContext
*
cx
Handle
<
JSScript
*
>
script
TranscodeBuffer
&
buffer
)
;
extern
JS_PUBLIC_API
bool
CheckCompileOptionsMatch
(
const
ReadOnlyCompileOptions
&
options
JSScript
*
script
)
;
}
#
endif
