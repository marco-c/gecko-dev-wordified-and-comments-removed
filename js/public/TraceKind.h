#
ifndef
js_TraceKind_h
#
define
js_TraceKind_h
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
class
JSLinearString
;
namespace
js
{
class
BaseScript
;
class
BaseShape
;
class
ObjectGroup
;
class
RegExpShared
;
class
Shape
;
class
Scope
;
namespace
jit
{
class
JitCode
;
}
}
namespace
JS
{
enum
class
TraceKind
{
Object
=
0x00
BigInt
=
0x01
String
=
0x02
Symbol
=
0x03
Shape
=
0x04
ObjectGroup
=
0x05
Null
=
0x06
BaseShape
=
0x0F
JitCode
=
0x1F
Script
=
0x2F
Scope
=
0x3F
RegExpShared
=
0x4F
}
;
const
static
uintptr_t
OutOfLineTraceKindMask
=
0x07
;
#
define
ASSERT_TRACE_KIND
(
tk
)
\
static_assert
(
\
(
uintptr_t
(
tk
)
&
OutOfLineTraceKindMask
)
=
=
OutOfLineTraceKindMask
\
"
mask
bits
are
set
"
)
ASSERT_TRACE_KIND
(
JS
:
:
TraceKind
:
:
BaseShape
)
;
ASSERT_TRACE_KIND
(
JS
:
:
TraceKind
:
:
JitCode
)
;
ASSERT_TRACE_KIND
(
JS
:
:
TraceKind
:
:
Script
)
;
ASSERT_TRACE_KIND
(
JS
:
:
TraceKind
:
:
Scope
)
;
ASSERT_TRACE_KIND
(
JS
:
:
TraceKind
:
:
RegExpShared
)
;
#
undef
ASSERT_TRACE_KIND
template
<
typename
T
>
struct
MapTypeToTraceKind
{
static
const
JS
:
:
TraceKind
kind
=
T
:
:
TraceKind
;
}
;
#
define
JS_FOR_EACH_TRACEKIND
(
D
)
\
D
(
BaseShape
js
:
:
BaseShape
true
false
)
\
D
(
JitCode
js
:
:
jit
:
:
JitCode
true
false
)
\
D
(
Scope
js
:
:
Scope
true
true
)
\
D
(
Object
JSObject
true
true
)
\
D
(
ObjectGroup
js
:
:
ObjectGroup
true
false
)
\
D
(
Script
js
:
:
BaseScript
true
true
)
\
D
(
Shape
js
:
:
Shape
true
false
)
\
D
(
String
JSString
false
false
)
\
D
(
Symbol
JS
:
:
Symbol
false
false
)
\
D
(
BigInt
JS
:
:
BigInt
false
false
)
\
D
(
RegExpShared
js
:
:
RegExpShared
true
true
)
inline
constexpr
bool
IsCCTraceKind
(
JS
:
:
TraceKind
aKind
)
{
switch
(
aKind
)
{
#
define
JS_EXPAND_DEF
(
name
_1
_2
inCCGraph
)
\
case
JS
:
:
TraceKind
:
:
name
:
\
return
inCCGraph
;
JS_FOR_EACH_TRACEKIND
(
JS_EXPAND_DEF
)
;
#
undef
JS_EXPAND_DEF
default
:
return
false
;
}
}
template
<
typename
T
>
struct
IsBaseTraceType
:
std
:
:
false_type
{
}
;
#
define
JS_EXPAND_DEF
(
_
type
_1
_2
)
\
template
<
>
\
struct
IsBaseTraceType
<
type
>
:
std
:
:
true_type
{
}
;
JS_FOR_EACH_TRACEKIND
(
JS_EXPAND_DEF
)
;
#
undef
JS_EXPAND_DEF
template
<
typename
T
>
inline
constexpr
bool
IsBaseTraceType_v
=
IsBaseTraceType
<
T
>
:
:
value
;
#
define
JS_EXPAND_DEF
(
name
type
_
_1
)
\
template
<
>
\
struct
MapTypeToTraceKind
<
type
>
{
\
static
const
JS
:
:
TraceKind
kind
=
JS
:
:
TraceKind
:
:
name
;
\
}
;
JS_FOR_EACH_TRACEKIND
(
JS_EXPAND_DEF
)
;
#
undef
JS_EXPAND_DEF
template
<
>
struct
MapTypeToTraceKind
<
JSLinearString
>
{
static
const
JS
:
:
TraceKind
kind
=
JS
:
:
TraceKind
:
:
String
;
}
;
template
<
>
struct
MapTypeToTraceKind
<
JSFunction
>
{
static
const
JS
:
:
TraceKind
kind
=
JS
:
:
TraceKind
:
:
Object
;
}
;
template
<
>
struct
MapTypeToTraceKind
<
JSScript
>
{
static
const
JS
:
:
TraceKind
kind
=
JS
:
:
TraceKind
:
:
Script
;
}
;
enum
class
RootKind
:
int8_t
{
#
define
EXPAND_ROOT_KIND
(
name
_0
_1
_2
)
name
JS_FOR_EACH_TRACEKIND
(
EXPAND_ROOT_KIND
)
#
undef
EXPAND_ROOT_KIND
Id
Value
Traceable
Limit
}
;
template
<
TraceKind
traceKind
>
struct
MapTraceKindToRootKind
{
}
;
#
define
JS_EXPAND_DEF
(
name
_0
_1
_2
)
\
template
<
>
\
struct
MapTraceKindToRootKind
<
JS
:
:
TraceKind
:
:
name
>
{
\
static
const
JS
:
:
RootKind
kind
=
JS
:
:
RootKind
:
:
name
;
\
}
;
JS_FOR_EACH_TRACEKIND
(
JS_EXPAND_DEF
)
#
undef
JS_EXPAND_DEF
template
<
typename
T
>
struct
MapTypeToRootKind
{
static
const
JS
:
:
RootKind
kind
=
JS
:
:
RootKind
:
:
Traceable
;
}
;
template
<
typename
T
>
struct
MapTypeToRootKind
<
T
*
>
{
static
const
JS
:
:
RootKind
kind
=
JS
:
:
MapTraceKindToRootKind
<
JS
:
:
MapTypeToTraceKind
<
T
>
:
:
kind
>
:
:
kind
;
}
;
template
<
>
struct
MapTypeToRootKind
<
JS
:
:
Realm
*
>
{
static
const
JS
:
:
RootKind
kind
=
JS
:
:
RootKind
:
:
Traceable
;
}
;
template
<
typename
T
>
struct
MapTypeToRootKind
<
mozilla
:
:
UniquePtr
<
T
>
>
{
static
const
JS
:
:
RootKind
kind
=
JS
:
:
MapTypeToRootKind
<
T
>
:
:
kind
;
}
;
template
<
>
struct
MapTypeToRootKind
<
JS
:
:
Value
>
{
static
const
JS
:
:
RootKind
kind
=
JS
:
:
RootKind
:
:
Value
;
}
;
template
<
>
struct
MapTypeToRootKind
<
jsid
>
{
static
const
JS
:
:
RootKind
kind
=
JS
:
:
RootKind
:
:
Id
;
}
;
template
<
typename
F
typename
.
.
.
Args
>
auto
DispatchTraceKindTyped
(
F
f
JS
:
:
TraceKind
traceKind
Args
&
&
.
.
.
args
)
{
switch
(
traceKind
)
{
#
define
JS_EXPAND_DEF
(
name
type
_
_1
)
\
case
JS
:
:
TraceKind
:
:
name
:
\
return
f
.
template
operator
(
)
<
type
>
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
JS_FOR_EACH_TRACEKIND
(
JS_EXPAND_DEF
)
;
#
undef
JS_EXPAND_DEF
default
:
MOZ_CRASH
(
"
Invalid
trace
kind
in
DispatchTraceKindTyped
.
"
)
;
}
}
template
<
typename
F
>
auto
MapGCThingTyped
(
void
*
thing
JS
:
:
TraceKind
traceKind
F
&
&
f
)
{
switch
(
traceKind
)
{
#
define
JS_EXPAND_DEF
(
name
type
_
_1
)
\
case
JS
:
:
TraceKind
:
:
name
:
\
return
f
(
static_cast
<
type
*
>
(
thing
)
)
;
JS_FOR_EACH_TRACEKIND
(
JS_EXPAND_DEF
)
;
#
undef
JS_EXPAND_DEF
default
:
MOZ_CRASH
(
"
Invalid
trace
kind
in
MapGCThingTyped
.
"
)
;
}
}
template
<
typename
F
>
void
ApplyGCThingTyped
(
void
*
thing
JS
:
:
TraceKind
traceKind
F
&
&
f
)
{
MapGCThingTyped
(
thing
traceKind
std
:
:
move
(
f
)
)
;
}
}
#
endif
