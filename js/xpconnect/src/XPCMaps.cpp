#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
js
/
HashTable
.
h
"
using
namespace
mozilla
;
static
PLDHashNumber
HashNativeKey
(
const
void
*
data
)
{
return
static_cast
<
const
XPCNativeSetKey
*
>
(
data
)
-
>
Hash
(
)
;
}
void
JSObject2WrappedJSMap
:
:
UpdateWeakPointersAfterGC
(
)
{
nsTArray
<
RefPtr
<
nsXPCWrappedJS
>
>
dying
;
for
(
auto
iter
=
mTable
.
modIter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
nsXPCWrappedJS
*
wrapper
=
iter
.
get
(
)
.
value
(
)
;
MOZ_ASSERT
(
wrapper
"
found
a
null
JS
wrapper
!
"
)
;
while
(
wrapper
)
{
if
(
wrapper
-
>
IsSubjectToFinalization
(
)
)
{
wrapper
-
>
UpdateObjectPointerAfterGC
(
)
;
if
(
!
wrapper
-
>
GetJSObjectPreserveColor
(
)
)
{
dying
.
AppendElement
(
dont_AddRef
(
wrapper
)
)
;
}
}
wrapper
=
wrapper
-
>
GetNextWrapper
(
)
;
}
JSObject
*
obj
=
iter
.
get
(
)
.
key
(
)
.
unbarrieredGet
(
)
;
JS_UpdateWeakPointerAfterGCUnbarriered
(
&
obj
)
;
if
(
!
obj
)
{
iter
.
remove
(
)
;
}
else
{
iter
.
get
(
)
.
mutableKey
(
)
=
obj
;
}
}
}
void
JSObject2WrappedJSMap
:
:
ShutdownMarker
(
)
{
for
(
auto
iter
=
mTable
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
nsXPCWrappedJS
*
wrapper
=
iter
.
get
(
)
.
value
(
)
;
MOZ_ASSERT
(
wrapper
"
found
a
null
JS
wrapper
!
"
)
;
MOZ_ASSERT
(
wrapper
-
>
IsValid
(
)
"
found
an
invalid
JS
wrapper
!
"
)
;
wrapper
-
>
SystemIsBeingShutDown
(
)
;
}
}
size_t
JSObject2WrappedJSMap
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
n
=
mallocSizeOf
(
this
)
;
n
+
=
mTable
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
return
n
;
}
size_t
JSObject2WrappedJSMap
:
:
SizeOfWrappedJS
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
n
=
0
;
for
(
auto
iter
=
mTable
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
n
+
=
iter
.
get
(
)
.
value
(
)
-
>
SizeOfIncludingThis
(
mallocSizeOf
)
;
}
return
n
;
}
Native2WrappedNativeMap
:
:
Native2WrappedNativeMap
(
)
:
mMap
(
XPC_NATIVE_MAP_LENGTH
)
{
}
size_t
Native2WrappedNativeMap
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
n
=
mallocSizeOf
(
this
)
;
n
+
=
mMap
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
for
(
auto
iter
=
mMap
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
n
+
=
mallocSizeOf
(
iter
.
get
(
)
.
value
(
)
)
;
}
return
n
;
}
IID2NativeInterfaceMap
:
:
IID2NativeInterfaceMap
(
)
:
mMap
(
XPC_NATIVE_INTERFACE_MAP_LENGTH
)
{
}
size_t
IID2NativeInterfaceMap
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
n
=
mallocSizeOf
(
this
)
;
n
+
=
mMap
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
for
(
auto
iter
=
mMap
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
n
+
=
iter
.
get
(
)
.
value
(
)
-
>
SizeOfIncludingThis
(
mallocSizeOf
)
;
}
return
n
;
}
ClassInfo2NativeSetMap
:
:
ClassInfo2NativeSetMap
(
)
:
mMap
(
XPC_NATIVE_SET_MAP_LENGTH
)
{
}
size_t
ClassInfo2NativeSetMap
:
:
ShallowSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
size_t
n
=
mallocSizeOf
(
this
)
;
n
+
=
mMap
.
shallowSizeOfExcludingThis
(
mallocSizeOf
)
;
return
n
;
}
ClassInfo2WrappedNativeProtoMap
:
:
ClassInfo2WrappedNativeProtoMap
(
)
:
mTable
(
PLDHashTable
:
:
StubOps
(
)
sizeof
(
Entry
)
XPC_NATIVE_PROTO_MAP_LENGTH
)
{
}
size_t
ClassInfo2WrappedNativeProtoMap
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
n
=
mallocSizeOf
(
this
)
;
n
+
=
mTable
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
;
for
(
auto
iter
=
mTable
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
ClassInfo2WrappedNativeProtoMap
:
:
Entry
*
>
(
iter
.
Get
(
)
)
;
n
+
=
mallocSizeOf
(
entry
-
>
value
)
;
}
return
n
;
}
bool
NativeSetMap
:
:
Entry
:
:
Match
(
const
PLDHashEntryHdr
*
entry
const
void
*
key
)
{
auto
Key
=
static_cast
<
const
XPCNativeSetKey
*
>
(
key
)
;
XPCNativeSet
*
SetInTable
=
(
(
Entry
*
)
entry
)
-
>
key_value
;
XPCNativeSet
*
Set
=
Key
-
>
GetBaseSet
(
)
;
XPCNativeInterface
*
Addition
=
Key
-
>
GetAddition
(
)
;
if
(
!
Set
)
{
return
(
SetInTable
-
>
GetInterfaceCount
(
)
=
=
1
&
&
SetInTable
-
>
GetInterfaceAt
(
0
)
=
=
Addition
)
|
|
(
SetInTable
-
>
GetInterfaceCount
(
)
=
=
2
&
&
SetInTable
-
>
GetInterfaceAt
(
1
)
=
=
Addition
)
;
}
if
(
!
Addition
&
&
Set
=
=
SetInTable
)
{
return
true
;
}
uint16_t
count
=
Set
-
>
GetInterfaceCount
(
)
;
if
(
count
+
(
Addition
?
1
:
0
)
!
=
SetInTable
-
>
GetInterfaceCount
(
)
)
{
return
false
;
}
XPCNativeInterface
*
*
CurrentInTable
=
SetInTable
-
>
GetInterfaceArray
(
)
;
XPCNativeInterface
*
*
Current
=
Set
-
>
GetInterfaceArray
(
)
;
for
(
uint16_t
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
*
(
Current
+
+
)
!
=
*
(
CurrentInTable
+
+
)
)
{
return
false
;
}
}
return
!
Addition
|
|
Addition
=
=
*
(
CurrentInTable
+
+
)
;
}
const
struct
PLDHashTableOps
NativeSetMap
:
:
Entry
:
:
sOps
=
{
HashNativeKey
Match
PLDHashTable
:
:
MoveEntryStub
PLDHashTable
:
:
ClearEntryStub
}
;
NativeSetMap
:
:
NativeSetMap
(
)
:
mTable
(
&
Entry
:
:
sOps
sizeof
(
Entry
)
XPC_NATIVE_SET_MAP_LENGTH
)
{
}
size_t
NativeSetMap
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
n
=
mallocSizeOf
(
this
)
;
n
+
=
mTable
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
;
for
(
auto
iter
=
mTable
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
NativeSetMap
:
:
Entry
*
>
(
iter
.
Get
(
)
)
;
n
+
=
entry
-
>
key_value
-
>
SizeOfIncludingThis
(
mallocSizeOf
)
;
}
return
n
;
}
XPCWrappedNativeProtoMap
:
:
XPCWrappedNativeProtoMap
(
)
:
mTable
(
PLDHashTable
:
:
StubOps
(
)
sizeof
(
PLDHashEntryStub
)
XPC_DYING_NATIVE_PROTO_MAP_LENGTH
)
{
}
