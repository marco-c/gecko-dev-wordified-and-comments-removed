#
ifndef
xpcpublic_h
#
define
xpcpublic_h
#
include
"
jsapi
.
h
"
#
include
"
js
/
BuildId
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
Object
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
js
/
String
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
dom
/
JSSlots
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
class
nsGlobalWindowInner
;
class
nsIGlobalObject
;
class
nsIPrincipal
;
class
nsIHandleReportCallback
;
struct
nsXPTInterfaceInfo
;
namespace
mozilla
{
class
BasePrincipal
;
namespace
dom
{
class
Exception
;
}
}
using
xpcGCCallback
=
void
(
*
)
(
JSGCStatus
)
;
namespace
xpc
{
class
Scriptability
{
public
:
explicit
Scriptability
(
JS
:
:
Realm
*
realm
)
;
bool
Allowed
(
)
;
bool
IsImmuneToScriptPolicy
(
)
;
void
Block
(
)
;
void
Unblock
(
)
;
void
SetDocShellAllowsScript
(
bool
aAllowed
)
;
static
Scriptability
&
Get
(
JSObject
*
aScope
)
;
private
:
uint32_t
mScriptBlocks
;
bool
mDocShellAllowsScript
;
bool
mImmuneToScriptPolicy
;
bool
mScriptBlockedByPolicy
;
}
;
JSObject
*
TransplantObject
(
JSContext
*
cx
JS
:
:
HandleObject
origobj
JS
:
:
HandleObject
target
)
;
JSObject
*
TransplantObjectRetainingXrayExpandos
(
JSContext
*
cx
JS
:
:
HandleObject
origobj
JS
:
:
HandleObject
target
)
;
JSObject
*
TransplantObjectNukingXrayWaiver
(
JSContext
*
cx
JS
:
:
HandleObject
origObj
JS
:
:
HandleObject
target
)
;
bool
IsUAWidgetCompartment
(
JS
:
:
Compartment
*
compartment
)
;
bool
IsUAWidgetScope
(
JS
:
:
Realm
*
realm
)
;
bool
IsInUAWidgetScope
(
JSObject
*
obj
)
;
bool
MightBeWebContentCompartment
(
JS
:
:
Compartment
*
compartment
)
;
void
SetCompartmentChangedDocumentDomain
(
JS
:
:
Compartment
*
compartment
)
;
JSObject
*
GetUAWidgetScope
(
JSContext
*
cx
nsIPrincipal
*
principal
)
;
JSObject
*
GetUAWidgetScope
(
JSContext
*
cx
JSObject
*
contentScope
)
;
bool
AllowContentXBLScope
(
JS
:
:
Realm
*
realm
)
;
JSObject
*
NACScope
(
JSObject
*
global
)
;
bool
IsSandboxPrototypeProxy
(
JSObject
*
obj
)
;
bool
IsReflector
(
JSObject
*
obj
JSContext
*
cx
)
;
bool
IsXrayWrapper
(
JSObject
*
obj
)
;
JSObject
*
XrayAwareCalleeGlobal
(
JSObject
*
fun
)
;
void
TraceXPCGlobal
(
JSTracer
*
trc
JSObject
*
obj
)
;
nsresult
InitClassesWithNewWrappedGlobal
(
JSContext
*
aJSContext
nsISupports
*
aCOMObj
nsIPrincipal
*
aPrincipal
uint32_t
aFlags
JS
:
:
RealmOptions
&
aOptions
JS
:
:
MutableHandleObject
aNewGlobal
)
;
enum
InitClassesFlag
{
INIT_JS_STANDARD_CLASSES
=
1
<
<
0
DONT_FIRE_ONNEWGLOBALHOOK
=
1
<
<
1
OMIT_COMPONENTS_OBJECT
=
1
<
<
2
}
;
}
namespace
JS
{
struct
RuntimeStats
;
}
#
define
XPC_WRAPPER_FLAGS
(
JSCLASS_HAS_PRIVATE
|
JSCLASS_FOREGROUND_FINALIZE
)
#
define
XPCONNECT_GLOBAL_FLAGS_WITH_EXTRA_SLOTS
(
n
)
\
JSCLASS_DOM_GLOBAL
|
JSCLASS_HAS_PRIVATE
|
JSCLASS_PRIVATE_IS_NSISUPPORTS
|
\
JSCLASS_GLOBAL_FLAGS_WITH_SLOTS
(
DOM_GLOBAL_SLOTS
+
n
)
#
define
XPCONNECT_GLOBAL_EXTRA_SLOT_OFFSET
\
(
JSCLASS_GLOBAL_SLOT_COUNT
+
DOM_GLOBAL_SLOTS
)
#
define
XPCONNECT_GLOBAL_FLAGS
XPCONNECT_GLOBAL_FLAGS_WITH_EXTRA_SLOTS
(
0
)
inline
JSObject
*
xpc_FastGetCachedWrapper
(
JSContext
*
cx
nsWrapperCache
*
cache
JS
:
:
MutableHandleValue
vp
)
{
if
(
cache
)
{
JSObject
*
wrapper
=
cache
-
>
GetWrapper
(
)
;
if
(
wrapper
&
&
JS
:
:
GetCompartment
(
wrapper
)
=
=
js
:
:
GetContextCompartment
(
cx
)
)
{
vp
.
setObject
(
*
wrapper
)
;
return
wrapper
;
}
}
return
nullptr
;
}
extern
void
xpc_TryUnmarkWrappedGrayObject
(
nsISupports
*
aWrappedJS
)
;
extern
void
xpc_UnmarkSkippableJSHolders
(
)
;
extern
bool
xpc_DumpJSStack
(
bool
showArgs
bool
showLocals
bool
showThisProps
)
;
extern
JS
:
:
UniqueChars
xpc_PrintJSStack
(
JSContext
*
cx
bool
showArgs
bool
showLocals
bool
showThisProps
)
;
class
XPCStringConvert
{
public
:
static
bool
ReadableToJSVal
(
JSContext
*
cx
const
nsAString
&
readable
nsStringBuffer
*
*
sharedBuffer
JS
:
:
MutableHandleValue
vp
)
;
static
MOZ_ALWAYS_INLINE
bool
StringBufferToJSVal
(
JSContext
*
cx
nsStringBuffer
*
buf
uint32_t
length
JS
:
:
MutableHandleValue
rval
bool
*
sharedBuffer
)
{
JSString
*
str
=
JS_NewMaybeExternalString
(
cx
static_cast
<
char16_t
*
>
(
buf
-
>
Data
(
)
)
length
&
sDOMStringExternalString
sharedBuffer
)
;
if
(
!
str
)
{
return
false
;
}
rval
.
setString
(
str
)
;
return
true
;
}
static
inline
bool
StringLiteralToJSVal
(
JSContext
*
cx
const
char16_t
*
literal
uint32_t
length
JS
:
:
MutableHandleValue
rval
)
{
bool
ignored
;
JSString
*
str
=
JS_NewMaybeExternalString
(
cx
literal
length
&
sLiteralExternalString
&
ignored
)
;
if
(
!
str
)
{
return
false
;
}
rval
.
setString
(
str
)
;
return
true
;
}
static
inline
bool
DynamicAtomToJSVal
(
JSContext
*
cx
nsDynamicAtom
*
atom
JS
:
:
MutableHandleValue
rval
)
{
bool
sharedAtom
;
JSString
*
str
=
JS_NewMaybeExternalString
(
cx
atom
-
>
GetUTF16String
(
)
atom
-
>
GetLength
(
)
&
sDynamicAtomExternalString
&
sharedAtom
)
;
if
(
!
str
)
{
return
false
;
}
if
(
sharedAtom
)
{
static_cast
<
nsAtom
*
>
(
atom
)
-
>
AddRef
(
)
;
}
rval
.
setString
(
str
)
;
return
true
;
}
static
MOZ_ALWAYS_INLINE
bool
MaybeGetExternalStringChars
(
JSString
*
str
const
JSExternalStringCallbacks
*
desiredCallbacks
const
char16_t
*
*
chars
)
{
const
JSExternalStringCallbacks
*
callbacks
;
return
JS
:
:
IsExternalString
(
str
&
callbacks
chars
)
&
&
callbacks
=
=
desiredCallbacks
;
}
static
MOZ_ALWAYS_INLINE
bool
MaybeGetLiteralStringChars
(
JSString
*
str
const
char16_t
*
*
chars
)
{
return
MaybeGetExternalStringChars
(
str
&
sLiteralExternalString
chars
)
;
}
static
MOZ_ALWAYS_INLINE
bool
MaybeGetDOMStringChars
(
JSString
*
str
const
char16_t
*
*
chars
)
{
return
MaybeGetExternalStringChars
(
str
&
sDOMStringExternalString
chars
)
;
}
private
:
struct
LiteralExternalString
:
public
JSExternalStringCallbacks
{
void
finalize
(
char16_t
*
aChars
)
const
override
;
size_t
sizeOfBuffer
(
const
char16_t
*
aChars
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
;
}
;
struct
DOMStringExternalString
:
public
JSExternalStringCallbacks
{
void
finalize
(
char16_t
*
aChars
)
const
override
;
size_t
sizeOfBuffer
(
const
char16_t
*
aChars
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
;
}
;
struct
DynamicAtomExternalString
:
public
JSExternalStringCallbacks
{
void
finalize
(
char16_t
*
aChars
)
const
override
;
size_t
sizeOfBuffer
(
const
char16_t
*
aChars
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
;
}
;
static
const
LiteralExternalString
sLiteralExternalString
;
static
const
DOMStringExternalString
sDOMStringExternalString
;
static
const
DynamicAtomExternalString
sDynamicAtomExternalString
;
XPCStringConvert
(
)
=
delete
;
}
;
class
nsIAddonInterposition
;
namespace
xpc
{
bool
Base64Encode
(
JSContext
*
cx
JS
:
:
HandleValue
val
JS
:
:
MutableHandleValue
out
)
;
bool
Base64Decode
(
JSContext
*
cx
JS
:
:
HandleValue
val
JS
:
:
MutableHandleValue
out
)
;
bool
NonVoidStringToJsval
(
JSContext
*
cx
nsAString
&
str
JS
:
:
MutableHandleValue
rval
)
;
inline
bool
StringToJsval
(
JSContext
*
cx
nsAString
&
str
JS
:
:
MutableHandleValue
rval
)
{
if
(
str
.
IsVoid
(
)
)
{
rval
.
setNull
(
)
;
return
true
;
}
return
NonVoidStringToJsval
(
cx
str
rval
)
;
}
inline
bool
NonVoidStringToJsval
(
JSContext
*
cx
const
nsAString
&
str
JS
:
:
MutableHandleValue
rval
)
{
nsString
mutableCopy
;
if
(
!
mutableCopy
.
Assign
(
str
mozilla
:
:
fallible
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
NonVoidStringToJsval
(
cx
mutableCopy
rval
)
;
}
inline
bool
StringToJsval
(
JSContext
*
cx
const
nsAString
&
str
JS
:
:
MutableHandleValue
rval
)
{
nsString
mutableCopy
;
if
(
!
mutableCopy
.
Assign
(
str
mozilla
:
:
fallible
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
StringToJsval
(
cx
mutableCopy
rval
)
;
}
inline
bool
NonVoidStringToJsval
(
JSContext
*
cx
mozilla
:
:
dom
:
:
DOMString
&
str
JS
:
:
MutableHandleValue
rval
)
{
if
(
str
.
IsEmpty
(
)
)
{
rval
.
set
(
JS_GetEmptyStringValue
(
cx
)
)
;
return
true
;
}
if
(
str
.
HasStringBuffer
(
)
)
{
uint32_t
length
=
str
.
StringBufferLength
(
)
;
nsStringBuffer
*
buf
=
str
.
StringBuffer
(
)
;
bool
shared
;
if
(
!
XPCStringConvert
:
:
StringBufferToJSVal
(
cx
buf
length
rval
&
shared
)
)
{
return
false
;
}
if
(
shared
)
{
str
.
RelinquishBufferOwnership
(
)
;
}
return
true
;
}
if
(
str
.
HasLiteral
(
)
)
{
return
XPCStringConvert
:
:
StringLiteralToJSVal
(
cx
str
.
Literal
(
)
str
.
LiteralLength
(
)
rval
)
;
}
if
(
str
.
HasAtom
(
)
)
{
return
XPCStringConvert
:
:
DynamicAtomToJSVal
(
cx
str
.
Atom
(
)
rval
)
;
}
return
NonVoidStringToJsval
(
cx
str
.
AsAString
(
)
rval
)
;
}
MOZ_ALWAYS_INLINE
bool
StringToJsval
(
JSContext
*
cx
mozilla
:
:
dom
:
:
DOMString
&
str
JS
:
:
MutableHandleValue
rval
)
{
if
(
str
.
IsNull
(
)
)
{
rval
.
setNull
(
)
;
return
true
;
}
return
NonVoidStringToJsval
(
cx
str
rval
)
;
}
mozilla
:
:
BasePrincipal
*
GetRealmPrincipal
(
JS
:
:
Realm
*
realm
)
;
void
NukeAllWrappersForRealm
(
JSContext
*
cx
JS
:
:
Realm
*
realm
js
:
:
NukeReferencesToWindow
nukeReferencesToWindow
=
js
:
:
NukeWindowReferences
)
;
void
SetLocationForGlobal
(
JSObject
*
global
const
nsACString
&
location
)
;
void
SetLocationForGlobal
(
JSObject
*
global
nsIURI
*
locationURI
)
;
class
ZoneStatsExtras
{
public
:
ZoneStatsExtras
(
)
=
default
;
nsCString
pathPrefix
;
private
:
ZoneStatsExtras
(
const
ZoneStatsExtras
&
other
)
=
delete
;
ZoneStatsExtras
&
operator
=
(
const
ZoneStatsExtras
&
other
)
=
delete
;
}
;
class
RealmStatsExtras
{
public
:
RealmStatsExtras
(
)
=
default
;
nsCString
jsPathPrefix
;
nsCString
domPathPrefix
;
nsCOMPtr
<
nsIURI
>
location
;
private
:
RealmStatsExtras
(
const
RealmStatsExtras
&
other
)
=
delete
;
RealmStatsExtras
&
operator
=
(
const
RealmStatsExtras
&
other
)
=
delete
;
}
;
void
ReportJSRuntimeExplicitTreeStats
(
const
JS
:
:
RuntimeStats
&
rtStats
const
nsACString
&
rtPath
nsIHandleReportCallback
*
handleReport
nsISupports
*
data
bool
anonymize
size_t
*
rtTotal
=
nullptr
)
;
bool
Throw
(
JSContext
*
cx
nsresult
rv
)
;
already_AddRefed
<
nsISupports
>
ReflectorToISupportsStatic
(
JSObject
*
reflector
)
;
already_AddRefed
<
nsISupports
>
ReflectorToISupportsDynamic
(
JSObject
*
reflector
JSContext
*
cx
)
;
JSObject
*
UnprivilegedJunkScope
(
)
;
JSObject
*
UnprivilegedJunkScope
(
const
mozilla
:
:
fallible_t
&
)
;
bool
IsUnprivilegedJunkScope
(
JSObject
*
)
;
JSObject
*
PrivilegedJunkScope
(
)
;
JSObject
*
CompilationScope
(
)
;
nsIGlobalObject
*
NativeGlobal
(
JSObject
*
obj
)
;
nsIGlobalObject
*
CurrentNativeGlobal
(
JSContext
*
cx
)
;
nsGlobalWindowInner
*
WindowOrNull
(
JSObject
*
aObj
)
;
nsGlobalWindowInner
*
WindowGlobalOrNull
(
JSObject
*
aObj
)
;
nsGlobalWindowInner
*
CurrentWindowOrNull
(
JSContext
*
cx
)
;
class
MOZ_RAII
AutoScriptActivity
{
bool
mActive
;
bool
mOldValue
;
public
:
explicit
AutoScriptActivity
(
bool
aActive
)
;
~
AutoScriptActivity
(
)
;
}
;
bool
ShouldDiscardSystemSource
(
)
;
void
SetPrefableRealmOptions
(
JS
:
:
RealmOptions
&
options
)
;
class
ErrorBase
{
public
:
nsString
mErrorMsg
;
nsString
mFileName
;
uint32_t
mSourceId
;
uint32_t
mLineNumber
;
uint32_t
mColumn
;
ErrorBase
(
)
:
mSourceId
(
0
)
mLineNumber
(
0
)
mColumn
(
0
)
{
}
void
Init
(
JSErrorBase
*
aReport
)
;
void
AppendErrorDetailsTo
(
nsCString
&
error
)
;
}
;
class
ErrorNote
:
public
ErrorBase
{
public
:
void
Init
(
JSErrorNotes
:
:
Note
*
aNote
)
;
static
void
ErrorNoteToMessageString
(
JSErrorNotes
:
:
Note
*
aNote
nsAString
&
aString
)
;
void
LogToStderr
(
)
;
}
;
class
ErrorReport
:
public
ErrorBase
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ErrorReport
)
;
nsTArray
<
ErrorNote
>
mNotes
;
nsCString
mCategory
;
nsString
mSourceLine
;
nsString
mErrorMsgName
;
uint64_t
mWindowID
;
bool
mIsWarning
;
bool
mIsMuted
;
bool
mIsPromiseRejection
;
ErrorReport
(
)
:
mWindowID
(
0
)
mIsWarning
(
false
)
mIsMuted
(
false
)
mIsPromiseRejection
(
false
)
{
}
void
Init
(
JSErrorReport
*
aReport
const
char
*
aToStringResult
bool
aIsChrome
uint64_t
aWindowID
)
;
void
Init
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
Exception
*
aException
bool
aIsChrome
uint64_t
aWindowID
)
;
void
LogToConsole
(
)
;
void
LogToConsoleWithStack
(
nsGlobalWindowInner
*
aWin
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aException
JS
:
:
HandleObject
aStack
JS
:
:
HandleObject
aStackGlobal
)
;
static
void
ErrorReportToMessageString
(
JSErrorReport
*
aReport
nsAString
&
aString
)
;
void
LogToStderr
(
)
;
bool
IsWarning
(
)
const
{
return
mIsWarning
;
}
;
private
:
~
ErrorReport
(
)
=
default
;
}
;
void
DispatchScriptErrorEvent
(
nsPIDOMWindowInner
*
win
JS
:
:
RootingContext
*
rootingCx
xpc
:
:
ErrorReport
*
xpcReport
JS
:
:
Handle
<
JS
:
:
Value
>
exception
JS
:
:
Handle
<
JSObject
*
>
exceptionStack
)
;
void
FindExceptionStackForConsoleReport
(
nsPIDOMWindowInner
*
win
JS
:
:
HandleValue
exceptionValue
JS
:
:
HandleObject
exceptionStack
JS
:
:
MutableHandleObject
stackObj
JS
:
:
MutableHandleObject
stackGlobal
)
;
extern
void
GetCurrentRealmName
(
JSContext
*
nsCString
&
name
)
;
void
AddGCCallback
(
xpcGCCallback
cb
)
;
void
RemoveGCCallback
(
xpcGCCallback
cb
)
;
#
if
defined
(
XP_DARWIN
)
&
&
defined
(
__aarch64__
)
const
size_t
kAutomationPageSize
=
16384
;
#
else
const
size_t
kAutomationPageSize
=
4096
;
#
endif
struct
alignas
(
kAutomationPageSize
)
ReadOnlyPage
final
{
bool
mNonLocalConnectionsDisabled
=
false
;
bool
mTurnOffAllSecurityPref
=
false
;
static
void
Init
(
)
;
#
ifdef
MOZ_TSAN
static
ReadOnlyPage
sInstance
;
#
else
static
const
volatile
ReadOnlyPage
sInstance
;
#
endif
private
:
constexpr
ReadOnlyPage
(
)
=
default
;
ReadOnlyPage
(
const
ReadOnlyPage
&
)
=
delete
;
void
operator
=
(
const
ReadOnlyPage
&
)
=
delete
;
static
void
Write
(
const
volatile
bool
*
aPtr
bool
aValue
)
;
}
;
inline
bool
AreNonLocalConnectionsDisabled
(
)
{
return
ReadOnlyPage
:
:
sInstance
.
mNonLocalConnectionsDisabled
;
}
inline
bool
IsInAutomation
(
)
{
if
(
!
ReadOnlyPage
:
:
sInstance
.
mTurnOffAllSecurityPref
)
{
return
false
;
}
MOZ_RELEASE_ASSERT
(
AreNonLocalConnectionsDisabled
(
)
)
;
return
true
;
}
void
InitializeJSContext
(
)
;
mozilla
:
:
Maybe
<
nsID
>
JSValue2ID
(
JSContext
*
aCx
JS
:
:
HandleValue
aVal
)
;
bool
ID2JSValue
(
JSContext
*
aCx
const
nsID
&
aId
JS
:
:
MutableHandleValue
aVal
)
;
bool
IfaceID2JSValue
(
JSContext
*
aCx
const
nsXPTInterfaceInfo
&
aInfo
JS
:
:
MutableHandleValue
aVal
)
;
bool
ContractID2JSValue
(
JSContext
*
aCx
JSString
*
aContract
JS
:
:
MutableHandleValue
aVal
)
;
class
JSStackFrameBase
{
public
:
virtual
void
Clear
(
)
=
0
;
}
;
void
RegisterJSStackFrame
(
JS
:
:
Realm
*
aRealm
JSStackFrameBase
*
aStackFrame
)
;
void
UnregisterJSStackFrame
(
JS
:
:
Realm
*
aRealm
JSStackFrameBase
*
aStackFrame
)
;
void
NukeJSStackFrames
(
JS
:
:
Realm
*
aRealm
)
;
bool
IsCrossOriginWhitelistedProp
(
JSContext
*
cx
JS
:
:
HandleId
id
)
;
bool
AppendCrossOriginWhitelistedPropNames
(
JSContext
*
cx
JS
:
:
MutableHandleIdVector
props
)
;
}
namespace
mozilla
{
namespace
dom
{
bool
IsNotUAWidget
(
JSContext
*
cx
JSObject
*
)
;
bool
IsChromeOrUAWidget
(
JSContext
*
cx
JSObject
*
)
;
bool
ThreadSafeIsChromeOrUAWidget
(
JSContext
*
cx
JSObject
*
obj
)
;
}
bool
GetBuildId
(
JS
:
:
BuildIdCharVector
*
aBuildID
)
;
}
#
endif
