#
ifndef
xpcpublic_h
#
define
xpcpublic_h
#
include
"
jsapi
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
Proxy
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsStringGlue
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
dom
/
JSSlots
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
class
nsGlobalWindow
;
class
nsIPrincipal
;
class
nsScriptNameSpaceManager
;
class
nsIHandleReportCallback
;
namespace
mozilla
{
namespace
dom
{
class
Exception
;
}
}
typedef
void
(
*
xpcGCCallback
)
(
JSGCStatus
status
)
;
namespace
xpc
{
class
Scriptability
{
public
:
explicit
Scriptability
(
JSCompartment
*
c
)
;
bool
Allowed
(
)
;
bool
IsImmuneToScriptPolicy
(
)
;
void
Block
(
)
;
void
Unblock
(
)
;
void
SetDocShellAllowsScript
(
bool
aAllowed
)
;
static
Scriptability
&
Get
(
JSObject
*
aScope
)
;
private
:
uint32_t
mScriptBlocks
;
bool
mDocShellAllowsScript
;
bool
mImmuneToScriptPolicy
;
bool
mScriptBlockedByPolicy
;
}
;
JSObject
*
TransplantObject
(
JSContext
*
cx
JS
:
:
HandleObject
origobj
JS
:
:
HandleObject
target
)
;
JSObject
*
TransplantObjectRetainingXrayExpandos
(
JSContext
*
cx
JS
:
:
HandleObject
origobj
JS
:
:
HandleObject
target
)
;
bool
IsContentXBLCompartment
(
JSCompartment
*
compartment
)
;
bool
IsContentXBLScope
(
JS
:
:
Realm
*
realm
)
;
bool
IsInContentXBLScope
(
JSObject
*
obj
)
;
JSObject
*
GetXBLScope
(
JSContext
*
cx
JSObject
*
contentScope
)
;
inline
JSObject
*
GetXBLScopeOrGlobal
(
JSContext
*
cx
JSObject
*
obj
)
{
if
(
IsInContentXBLScope
(
obj
)
)
return
js
:
:
GetGlobalForObjectCrossCompartment
(
obj
)
;
return
GetXBLScope
(
cx
obj
)
;
}
JSObject
*
GetScopeForXBLExecution
(
JSContext
*
cx
JS
:
:
HandleObject
obj
JSAddonId
*
addonId
)
;
bool
AllowContentXBLScope
(
JS
:
:
Realm
*
realm
)
;
bool
UseContentXBLScope
(
JS
:
:
Realm
*
realm
)
;
void
ClearContentXBLScope
(
JSObject
*
global
)
;
bool
IsAddonCompartment
(
JSCompartment
*
c
)
;
bool
IsInAddonScope
(
JSObject
*
obj
)
;
JSObject
*
GetAddonScope
(
JSContext
*
cx
JS
:
:
HandleObject
contentScope
JSAddonId
*
addonId
)
;
bool
IsSandboxPrototypeProxy
(
JSObject
*
obj
)
;
bool
IsReflector
(
JSObject
*
obj
)
;
bool
IsXrayWrapper
(
JSObject
*
obj
)
;
JSObject
*
XrayAwareCalleeGlobal
(
JSObject
*
fun
)
;
bool
XrayAwareCalleeGlobalForSpecializedGetters
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
thisObj
JS
:
:
MutableHandle
<
JSObject
*
>
global
)
;
void
TraceXPCGlobal
(
JSTracer
*
trc
JSObject
*
obj
)
;
nsresult
InitClassesWithNewWrappedGlobal
(
JSContext
*
aJSContext
nsISupports
*
aCOMObj
nsIPrincipal
*
aPrincipal
uint32_t
aFlags
JS
:
:
CompartmentOptions
&
aOptions
JS
:
:
MutableHandleObject
aNewGlobal
)
;
enum
InitClassesFlag
{
INIT_JS_STANDARD_CLASSES
=
1
<
<
0
DONT_FIRE_ONNEWGLOBALHOOK
=
1
<
<
1
OMIT_COMPONENTS_OBJECT
=
1
<
<
2
}
;
}
namespace
JS
{
struct
RuntimeStats
;
}
#
define
XPC_WRAPPER_FLAGS
(
JSCLASS_HAS_PRIVATE
|
JSCLASS_FOREGROUND_FINALIZE
)
#
define
XPCONNECT_GLOBAL_FLAGS_WITH_EXTRA_SLOTS
(
n
)
\
JSCLASS_DOM_GLOBAL
|
JSCLASS_HAS_PRIVATE
|
\
JSCLASS_PRIVATE_IS_NSISUPPORTS
|
\
JSCLASS_GLOBAL_FLAGS_WITH_SLOTS
(
DOM_GLOBAL_SLOTS
+
n
)
#
define
XPCONNECT_GLOBAL_EXTRA_SLOT_OFFSET
(
JSCLASS_GLOBAL_SLOT_COUNT
+
DOM_GLOBAL_SLOTS
)
#
define
XPCONNECT_GLOBAL_FLAGS
XPCONNECT_GLOBAL_FLAGS_WITH_EXTRA_SLOTS
(
0
)
inline
JSObject
*
xpc_FastGetCachedWrapper
(
JSContext
*
cx
nsWrapperCache
*
cache
JS
:
:
MutableHandleValue
vp
)
{
if
(
cache
)
{
JSObject
*
wrapper
=
cache
-
>
GetWrapper
(
)
;
if
(
wrapper
&
&
js
:
:
GetObjectCompartment
(
wrapper
)
=
=
js
:
:
GetContextCompartment
(
cx
)
)
{
vp
.
setObject
(
*
wrapper
)
;
return
wrapper
;
}
}
return
nullptr
;
}
extern
void
xpc_MarkInCCGeneration
(
nsISupports
*
aVariant
uint32_t
aGeneration
)
;
extern
void
xpc_TryUnmarkWrappedGrayObject
(
nsISupports
*
aWrappedJS
)
;
extern
void
xpc_UnmarkSkippableJSHolders
(
)
;
class
XPCStringConvert
{
public
:
static
bool
ReadableToJSVal
(
JSContext
*
cx
const
nsAString
&
readable
nsStringBuffer
*
*
sharedBuffer
JS
:
:
MutableHandleValue
vp
)
;
static
MOZ_ALWAYS_INLINE
bool
StringBufferToJSVal
(
JSContext
*
cx
nsStringBuffer
*
buf
uint32_t
length
JS
:
:
MutableHandleValue
rval
bool
*
sharedBuffer
)
{
JSString
*
str
=
JS_NewMaybeExternalString
(
cx
static_cast
<
char16_t
*
>
(
buf
-
>
Data
(
)
)
length
&
sDOMStringFinalizer
sharedBuffer
)
;
if
(
!
str
)
{
return
false
;
}
rval
.
setString
(
str
)
;
return
true
;
}
static
MOZ_ALWAYS_INLINE
bool
IsLiteral
(
JSString
*
str
)
{
return
JS_IsExternalString
(
str
)
&
&
JS_GetExternalStringFinalizer
(
str
)
=
=
&
sLiteralFinalizer
;
}
static
MOZ_ALWAYS_INLINE
bool
IsDOMString
(
JSString
*
str
)
{
return
JS_IsExternalString
(
str
)
&
&
JS_GetExternalStringFinalizer
(
str
)
=
=
&
sDOMStringFinalizer
;
}
private
:
static
const
JSStringFinalizer
sLiteralFinalizer
sDOMStringFinalizer
;
static
void
FinalizeLiteral
(
const
JSStringFinalizer
*
fin
char16_t
*
chars
)
;
static
void
FinalizeDOMString
(
const
JSStringFinalizer
*
fin
char16_t
*
chars
)
;
XPCStringConvert
(
)
=
delete
;
}
;
class
nsIAddonInterposition
;
namespace
xpc
{
bool
Base64Encode
(
JSContext
*
cx
JS
:
:
HandleValue
val
JS
:
:
MutableHandleValue
out
)
;
bool
Base64Decode
(
JSContext
*
cx
JS
:
:
HandleValue
val
JS
:
:
MutableHandleValue
out
)
;
bool
NonVoidStringToJsval
(
JSContext
*
cx
nsAString
&
str
JS
:
:
MutableHandleValue
rval
)
;
inline
bool
StringToJsval
(
JSContext
*
cx
nsAString
&
str
JS
:
:
MutableHandleValue
rval
)
{
if
(
str
.
IsVoid
(
)
)
{
rval
.
setNull
(
)
;
return
true
;
}
return
NonVoidStringToJsval
(
cx
str
rval
)
;
}
inline
bool
NonVoidStringToJsval
(
JSContext
*
cx
const
nsAString
&
str
JS
:
:
MutableHandleValue
rval
)
{
nsString
mutableCopy
;
if
(
!
mutableCopy
.
Assign
(
str
mozilla
:
:
fallible
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
NonVoidStringToJsval
(
cx
mutableCopy
rval
)
;
}
inline
bool
StringToJsval
(
JSContext
*
cx
const
nsAString
&
str
JS
:
:
MutableHandleValue
rval
)
{
nsString
mutableCopy
;
if
(
!
mutableCopy
.
Assign
(
str
mozilla
:
:
fallible
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
StringToJsval
(
cx
mutableCopy
rval
)
;
}
inline
bool
NonVoidStringToJsval
(
JSContext
*
cx
mozilla
:
:
dom
:
:
DOMString
&
str
JS
:
:
MutableHandleValue
rval
)
{
if
(
!
str
.
HasStringBuffer
(
)
)
{
return
NonVoidStringToJsval
(
cx
str
.
AsAString
(
)
rval
)
;
}
uint32_t
length
=
str
.
StringBufferLength
(
)
;
if
(
length
=
=
0
)
{
rval
.
set
(
JS_GetEmptyStringValue
(
cx
)
)
;
return
true
;
}
nsStringBuffer
*
buf
=
str
.
StringBuffer
(
)
;
bool
shared
;
if
(
!
XPCStringConvert
:
:
StringBufferToJSVal
(
cx
buf
length
rval
&
shared
)
)
{
return
false
;
}
if
(
shared
)
{
str
.
RelinquishBufferOwnership
(
)
;
}
return
true
;
}
MOZ_ALWAYS_INLINE
bool
StringToJsval
(
JSContext
*
cx
mozilla
:
:
dom
:
:
DOMString
&
str
JS
:
:
MutableHandleValue
rval
)
{
if
(
str
.
IsNull
(
)
)
{
rval
.
setNull
(
)
;
return
true
;
}
return
NonVoidStringToJsval
(
cx
str
rval
)
;
}
nsIPrincipal
*
GetCompartmentPrincipal
(
JSCompartment
*
compartment
)
;
void
NukeAllWrappersForCompartment
(
JSContext
*
cx
JSCompartment
*
compartment
js
:
:
NukeReferencesToWindow
nukeReferencesToWindow
=
js
:
:
NukeWindowReferences
)
;
void
SetLocationForGlobal
(
JSObject
*
global
const
nsACString
&
location
)
;
void
SetLocationForGlobal
(
JSObject
*
global
nsIURI
*
locationURI
)
;
class
ZoneStatsExtras
{
public
:
ZoneStatsExtras
(
)
{
}
nsCString
pathPrefix
;
private
:
ZoneStatsExtras
(
const
ZoneStatsExtras
&
other
)
=
delete
;
ZoneStatsExtras
&
operator
=
(
const
ZoneStatsExtras
&
other
)
=
delete
;
}
;
class
CompartmentStatsExtras
{
public
:
CompartmentStatsExtras
(
)
{
}
nsCString
jsPathPrefix
;
nsCString
domPathPrefix
;
nsCOMPtr
<
nsIURI
>
location
;
private
:
CompartmentStatsExtras
(
const
CompartmentStatsExtras
&
other
)
=
delete
;
CompartmentStatsExtras
&
operator
=
(
const
CompartmentStatsExtras
&
other
)
=
delete
;
}
;
void
ReportJSRuntimeExplicitTreeStats
(
const
JS
:
:
RuntimeStats
&
rtStats
const
nsACString
&
rtPath
nsIHandleReportCallback
*
handleReport
nsISupports
*
data
bool
anonymize
size_t
*
rtTotal
=
nullptr
)
;
bool
Throw
(
JSContext
*
cx
nsresult
rv
)
;
already_AddRefed
<
nsISupports
>
UnwrapReflectorToISupports
(
JSObject
*
reflector
)
;
JSObject
*
UnprivilegedJunkScope
(
)
;
JSObject
*
PrivilegedJunkScope
(
)
;
JSObject
*
CompilationScope
(
)
;
nsIGlobalObject
*
NativeGlobal
(
JSObject
*
aObj
)
;
nsGlobalWindow
*
WindowOrNull
(
JSObject
*
aObj
)
;
nsGlobalWindow
*
WindowGlobalOrNull
(
JSObject
*
aObj
)
;
nsGlobalWindow
*
AddonWindowOrNull
(
JSObject
*
aObj
)
;
nsGlobalWindow
*
CurrentWindowOrNull
(
JSContext
*
cx
)
;
void
SimulateActivityCallback
(
bool
aActive
)
;
bool
ShouldDiscardSystemSource
(
)
;
bool
SharedMemoryEnabled
(
)
;
bool
SetAddonInterposition
(
const
nsACString
&
addonId
nsIAddonInterposition
*
interposition
)
;
bool
AllowCPOWsInAddon
(
const
nsACString
&
addonId
bool
allow
)
;
bool
ExtraWarningsForSystemJS
(
)
;
class
ErrorBase
{
public
:
nsString
mErrorMsg
;
nsString
mFileName
;
uint32_t
mLineNumber
;
uint32_t
mColumn
;
ErrorBase
(
)
:
mLineNumber
(
0
)
mColumn
(
0
)
{
}
void
Init
(
JSErrorBase
*
aReport
)
;
void
AppendErrorDetailsTo
(
nsCString
&
error
)
;
}
;
class
ErrorNote
:
public
ErrorBase
{
public
:
void
Init
(
JSErrorNotes
:
:
Note
*
aNote
)
;
static
void
ErrorNoteToMessageString
(
JSErrorNotes
:
:
Note
*
aNote
nsAString
&
aString
)
;
void
LogToStderr
(
)
;
}
;
class
ErrorReport
:
public
ErrorBase
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ErrorReport
)
;
nsTArray
<
ErrorNote
>
mNotes
;
nsCString
mCategory
;
nsString
mSourceLine
;
nsString
mErrorMsgName
;
uint64_t
mWindowID
;
uint32_t
mFlags
;
bool
mIsMuted
;
ErrorReport
(
)
:
mWindowID
(
0
)
mFlags
(
0
)
mIsMuted
(
false
)
{
}
void
Init
(
JSErrorReport
*
aReport
const
char
*
aToStringResult
bool
aIsChrome
uint64_t
aWindowID
)
;
void
Init
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
Exception
*
aException
bool
aIsChrome
uint64_t
aWindowID
)
;
void
LogToConsole
(
)
;
void
LogToConsoleWithStack
(
JS
:
:
HandleObject
aStack
)
;
static
void
ErrorReportToMessageString
(
JSErrorReport
*
aReport
nsAString
&
aString
)
;
void
LogToStderr
(
)
;
private
:
~
ErrorReport
(
)
{
}
}
;
void
DispatchScriptErrorEvent
(
nsPIDOMWindowInner
*
win
JS
:
:
RootingContext
*
rootingCx
xpc
:
:
ErrorReport
*
xpcReport
JS
:
:
Handle
<
JS
:
:
Value
>
exception
)
;
JSObject
*
FindExceptionStackForConsoleReport
(
nsPIDOMWindowInner
*
win
JS
:
:
HandleValue
exceptionValue
)
;
extern
void
GetCurrentCompartmentName
(
JSContext
*
nsCString
&
name
)
;
void
AddGCCallback
(
xpcGCCallback
cb
)
;
void
RemoveGCCallback
(
xpcGCCallback
cb
)
;
inline
bool
AreNonLocalConnectionsDisabled
(
)
{
static
int
disabledForTest
=
-
1
;
if
(
disabledForTest
=
=
-
1
)
{
char
*
s
=
getenv
(
"
MOZ_DISABLE_NONLOCAL_CONNECTIONS
"
)
;
if
(
s
)
{
disabledForTest
=
*
s
!
=
'
0
'
;
}
else
{
disabledForTest
=
0
;
}
}
return
disabledForTest
;
}
inline
bool
IsInAutomation
(
)
{
const
char
*
prefName
=
"
security
.
turn_off_all_security_so_that_viruses_can_take_over_this_computer
"
;
return
mozilla
:
:
Preferences
:
:
GetBool
(
prefName
)
&
&
AreNonLocalConnectionsDisabled
(
)
;
}
void
CreateCooperativeContext
(
)
;
void
DestroyCooperativeContext
(
)
;
void
YieldCooperativeContext
(
)
;
void
ResumeCooperativeContext
(
)
;
}
namespace
mozilla
{
namespace
dom
{
bool
IsChromeOrXBL
(
JSContext
*
cx
JSObject
*
)
;
bool
ThreadSafeIsChromeOrXBL
(
JSContext
*
cx
JSObject
*
obj
)
;
}
}
#
endif
