#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
XPCWrapper
.
h
"
#
include
"
XPCJSMemoryReporter
.
h
"
#
include
"
WrapperFactory
.
h
"
#
include
"
mozJSComponentLoader
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIMemoryInfoDumper
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIDebug2
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
amIAddonManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsCycleCollectionNoteRootCallback
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
nsScriptLoader
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsprf
.
h
"
#
include
"
js
/
MemoryMetrics
.
h
"
#
include
"
mozilla
/
dom
/
GeneratedAtomList
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
mozilla
/
jsipc
/
CrossProcessObjectWrappers
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ProcessHangMonitor
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
AccessCheck
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsAboutProtocolUtils
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
ifdef
MOZ_CRASHREPORTER
#
include
"
nsExceptionHandler
.
h
"
#
endif
#
if
defined
(
MOZ_JEMALLOC4
)
#
include
"
mozmemory
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
endif
using
namespace
mozilla
;
using
namespace
xpc
;
using
namespace
JS
;
using
mozilla
:
:
dom
:
:
PerThreadAtomCache
;
using
mozilla
:
:
dom
:
:
AutoEntryScript
;
static
void
WatchdogMain
(
void
*
arg
)
;
class
Watchdog
;
class
WatchdogManager
;
class
AutoLockWatchdog
{
Watchdog
*
const
mWatchdog
;
public
:
explicit
AutoLockWatchdog
(
Watchdog
*
aWatchdog
)
;
~
AutoLockWatchdog
(
)
;
}
;
class
Watchdog
{
public
:
explicit
Watchdog
(
WatchdogManager
*
aManager
)
:
mManager
(
aManager
)
mLock
(
nullptr
)
mWakeup
(
nullptr
)
mThread
(
nullptr
)
mHibernating
(
false
)
mInitialized
(
false
)
mShuttingDown
(
false
)
mMinScriptRunTimeSeconds
(
1
)
{
}
~
Watchdog
(
)
{
MOZ_ASSERT
(
!
Initialized
(
)
)
;
}
WatchdogManager
*
Manager
(
)
{
return
mManager
;
}
bool
Initialized
(
)
{
return
mInitialized
;
}
bool
ShuttingDown
(
)
{
return
mShuttingDown
;
}
PRLock
*
GetLock
(
)
{
return
mLock
;
}
bool
Hibernating
(
)
{
return
mHibernating
;
}
void
WakeUp
(
)
{
MOZ_ASSERT
(
Initialized
(
)
)
;
MOZ_ASSERT
(
Hibernating
(
)
)
;
mHibernating
=
false
;
PR_NotifyCondVar
(
mWakeup
)
;
}
void
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mLock
=
PR_NewLock
(
)
;
if
(
!
mLock
)
NS_RUNTIMEABORT
(
"
PR_NewLock
failed
.
"
)
;
mWakeup
=
PR_NewCondVar
(
mLock
)
;
if
(
!
mWakeup
)
NS_RUNTIMEABORT
(
"
PR_NewCondVar
failed
.
"
)
;
{
AutoLockWatchdog
lock
(
this
)
;
mThread
=
PR_CreateThread
(
PR_USER_THREAD
WatchdogMain
this
PR_PRIORITY_NORMAL
PR_GLOBAL_THREAD
PR_JOINABLE_THREAD
0
)
;
if
(
!
mThread
)
NS_RUNTIMEABORT
(
"
PR_CreateThread
failed
!
"
)
;
mInitialized
=
true
;
}
}
void
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
Initialized
(
)
)
;
{
AutoLockWatchdog
lock
(
this
)
;
mShuttingDown
=
true
;
PR_NotifyCondVar
(
mWakeup
)
;
}
PR_JoinThread
(
mThread
)
;
MOZ_ASSERT
(
!
mShuttingDown
)
;
mThread
=
nullptr
;
PR_DestroyCondVar
(
mWakeup
)
;
mWakeup
=
nullptr
;
PR_DestroyLock
(
mLock
)
;
mLock
=
nullptr
;
mInitialized
=
false
;
}
void
SetMinScriptRunTimeSeconds
(
int32_t
seconds
)
{
MOZ_ASSERT
(
seconds
>
0
)
;
mMinScriptRunTimeSeconds
=
seconds
;
}
void
Hibernate
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mHibernating
=
true
;
Sleep
(
PR_INTERVAL_NO_TIMEOUT
)
;
}
void
Sleep
(
PRIntervalTime
timeout
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ALWAYS_TRUE
(
PR_WaitCondVar
(
mWakeup
timeout
)
=
=
PR_SUCCESS
)
;
}
void
Finished
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mShuttingDown
=
false
;
}
int32_t
MinScriptRunTimeSeconds
(
)
{
return
mMinScriptRunTimeSeconds
;
}
private
:
WatchdogManager
*
mManager
;
PRLock
*
mLock
;
PRCondVar
*
mWakeup
;
PRThread
*
mThread
;
bool
mHibernating
;
bool
mInitialized
;
bool
mShuttingDown
;
mozilla
:
:
Atomic
<
int32_t
>
mMinScriptRunTimeSeconds
;
}
;
#
define
PREF_MAX_SCRIPT_RUN_TIME_CONTENT
"
dom
.
max_script_run_time
"
#
define
PREF_MAX_SCRIPT_RUN_TIME_CHROME
"
dom
.
max_chrome_script_run_time
"
class
WatchdogManager
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
explicit
WatchdogManager
(
XPCJSContext
*
aContext
)
:
mContext
(
aContext
)
mContextState
(
CONTEXT_INACTIVE
)
{
PodArrayZero
(
mTimestamps
)
;
mTimestamps
[
TimestampContextStateChange
]
=
PR_Now
(
)
;
RefreshWatchdog
(
)
;
mozilla
:
:
Preferences
:
:
AddStrongObserver
(
this
"
dom
.
use_watchdog
"
)
;
mozilla
:
:
Preferences
:
:
AddStrongObserver
(
this
PREF_MAX_SCRIPT_RUN_TIME_CONTENT
)
;
mozilla
:
:
Preferences
:
:
AddStrongObserver
(
this
PREF_MAX_SCRIPT_RUN_TIME_CHROME
)
;
}
protected
:
virtual
~
WatchdogManager
(
)
{
MOZ_ASSERT
(
!
mWatchdog
)
;
mozilla
:
:
Preferences
:
:
RemoveObserver
(
this
"
dom
.
use_watchdog
"
)
;
mozilla
:
:
Preferences
:
:
RemoveObserver
(
this
PREF_MAX_SCRIPT_RUN_TIME_CONTENT
)
;
mozilla
:
:
Preferences
:
:
RemoveObserver
(
this
PREF_MAX_SCRIPT_RUN_TIME_CHROME
)
;
}
public
:
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
RefreshWatchdog
(
)
;
return
NS_OK
;
}
void
RecordContextActivity
(
bool
active
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Maybe
<
AutoLockWatchdog
>
lock
;
if
(
mWatchdog
)
lock
.
emplace
(
mWatchdog
)
;
mTimestamps
[
TimestampContextStateChange
]
=
PR_Now
(
)
;
mContextState
=
active
?
CONTEXT_ACTIVE
:
CONTEXT_INACTIVE
;
if
(
active
&
&
mWatchdog
&
&
mWatchdog
-
>
Hibernating
(
)
)
mWatchdog
-
>
WakeUp
(
)
;
}
bool
IsContextActive
(
)
{
return
mContextState
=
=
CONTEXT_ACTIVE
;
}
PRTime
TimeSinceLastContextStateChange
(
)
{
return
PR_Now
(
)
-
GetTimestamp
(
TimestampContextStateChange
)
;
}
void
RecordTimestamp
(
WatchdogTimestampCategory
aCategory
)
{
Maybe
<
AutoLockWatchdog
>
maybeLock
;
if
(
NS_IsMainThread
(
)
&
&
mWatchdog
)
maybeLock
.
emplace
(
mWatchdog
)
;
mTimestamps
[
aCategory
]
=
PR_Now
(
)
;
}
PRTime
GetTimestamp
(
WatchdogTimestampCategory
aCategory
)
{
Maybe
<
AutoLockWatchdog
>
maybeLock
;
if
(
NS_IsMainThread
(
)
&
&
mWatchdog
)
maybeLock
.
emplace
(
mWatchdog
)
;
return
mTimestamps
[
aCategory
]
;
}
XPCJSContext
*
Context
(
)
{
return
mContext
;
}
Watchdog
*
GetWatchdog
(
)
{
return
mWatchdog
;
}
void
RefreshWatchdog
(
)
{
bool
wantWatchdog
=
Preferences
:
:
GetBool
(
"
dom
.
use_watchdog
"
true
)
;
if
(
wantWatchdog
!
=
!
!
mWatchdog
)
{
if
(
wantWatchdog
)
StartWatchdog
(
)
;
else
StopWatchdog
(
)
;
}
if
(
mWatchdog
)
{
int32_t
contentTime
=
Preferences
:
:
GetInt
(
PREF_MAX_SCRIPT_RUN_TIME_CONTENT
10
)
;
if
(
contentTime
<
=
0
)
contentTime
=
INT32_MAX
;
int32_t
chromeTime
=
Preferences
:
:
GetInt
(
PREF_MAX_SCRIPT_RUN_TIME_CHROME
20
)
;
if
(
chromeTime
<
=
0
)
chromeTime
=
INT32_MAX
;
mWatchdog
-
>
SetMinScriptRunTimeSeconds
(
std
:
:
min
(
contentTime
chromeTime
)
)
;
}
}
void
StartWatchdog
(
)
{
MOZ_ASSERT
(
!
mWatchdog
)
;
mWatchdog
=
new
Watchdog
(
this
)
;
mWatchdog
-
>
Init
(
)
;
}
void
StopWatchdog
(
)
{
MOZ_ASSERT
(
mWatchdog
)
;
mWatchdog
-
>
Shutdown
(
)
;
mWatchdog
=
nullptr
;
}
private
:
XPCJSContext
*
mContext
;
nsAutoPtr
<
Watchdog
>
mWatchdog
;
enum
{
CONTEXT_ACTIVE
CONTEXT_INACTIVE
}
mContextState
;
PRTime
mTimestamps
[
TimestampCount
]
;
}
;
NS_IMPL_ISUPPORTS
(
WatchdogManager
nsIObserver
)
AutoLockWatchdog
:
:
AutoLockWatchdog
(
Watchdog
*
aWatchdog
)
:
mWatchdog
(
aWatchdog
)
{
PR_Lock
(
mWatchdog
-
>
GetLock
(
)
)
;
}
AutoLockWatchdog
:
:
~
AutoLockWatchdog
(
)
{
PR_Unlock
(
mWatchdog
-
>
GetLock
(
)
)
;
}
static
void
WatchdogMain
(
void
*
arg
)
{
mozilla
:
:
AutoProfilerRegister
registerThread
(
"
JS
Watchdog
"
)
;
NS_SetCurrentThreadName
(
"
JS
Watchdog
"
)
;
Watchdog
*
self
=
static_cast
<
Watchdog
*
>
(
arg
)
;
WatchdogManager
*
manager
=
self
-
>
Manager
(
)
;
AutoLockWatchdog
lock
(
self
)
;
MOZ_ASSERT
(
self
-
>
Initialized
(
)
)
;
MOZ_ASSERT
(
!
self
-
>
ShuttingDown
(
)
)
;
while
(
!
self
-
>
ShuttingDown
(
)
)
{
if
(
manager
-
>
IsContextActive
(
)
|
|
manager
-
>
TimeSinceLastContextStateChange
(
)
<
=
PRTime
(
2
*
PR_USEC_PER_SEC
)
)
{
self
-
>
Sleep
(
PR_TicksPerSecond
(
)
)
;
}
else
{
manager
-
>
RecordTimestamp
(
TimestampWatchdogHibernateStart
)
;
self
-
>
Hibernate
(
)
;
manager
-
>
RecordTimestamp
(
TimestampWatchdogHibernateStop
)
;
}
manager
-
>
RecordTimestamp
(
TimestampWatchdogWakeup
)
;
PRTime
usecs
=
self
-
>
MinScriptRunTimeSeconds
(
)
*
PR_USEC_PER_SEC
/
2
;
if
(
manager
-
>
IsContextActive
(
)
&
&
manager
-
>
TimeSinceLastContextStateChange
(
)
>
=
usecs
)
{
bool
debuggerAttached
=
false
;
nsCOMPtr
<
nsIDebug2
>
dbg
=
do_GetService
(
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
)
;
if
(
dbg
)
dbg
-
>
GetIsDebuggerAttached
(
&
debuggerAttached
)
;
if
(
!
debuggerAttached
)
JS_RequestInterruptCallback
(
manager
-
>
Context
(
)
-
>
Context
(
)
)
;
}
}
self
-
>
Finished
(
)
;
}
PRTime
XPCJSContext
:
:
GetWatchdogTimestamp
(
WatchdogTimestampCategory
aCategory
)
{
return
mWatchdogManager
-
>
GetTimestamp
(
aCategory
)
;
}
void
xpc
:
:
SimulateActivityCallback
(
bool
aActive
)
{
XPCJSContext
:
:
ActivityCallback
(
XPCJSContext
:
:
Get
(
)
aActive
)
;
}
void
XPCJSContext
:
:
ActivityCallback
(
void
*
arg
bool
active
)
{
if
(
!
active
)
{
ProcessHangMonitor
:
:
ClearHang
(
)
;
}
XPCJSContext
*
self
=
static_cast
<
XPCJSContext
*
>
(
arg
)
;
self
-
>
mWatchdogManager
-
>
RecordContextActivity
(
active
)
;
}
bool
XPCJSContext
:
:
InterruptCallback
(
JSContext
*
cx
)
{
XPCJSContext
*
self
=
XPCJSContext
:
:
Get
(
)
;
profiler_js_interrupt_callback
(
)
;
if
(
self
-
>
mSlowScriptCheckpoint
.
IsNull
(
)
)
{
self
-
>
mSlowScriptCheckpoint
=
TimeStamp
:
:
NowLoRes
(
)
;
self
-
>
mSlowScriptSecondHalf
=
false
;
self
-
>
mSlowScriptActualWait
=
mozilla
:
:
TimeDuration
(
)
;
self
-
>
mTimeoutAccumulated
=
false
;
return
true
;
}
if
(
!
nsContentUtils
:
:
IsInitialized
(
)
)
return
true
;
TimeDuration
duration
=
TimeStamp
:
:
NowLoRes
(
)
-
self
-
>
mSlowScriptCheckpoint
;
bool
chrome
=
nsContentUtils
:
:
IsSystemCaller
(
cx
)
;
const
char
*
prefName
=
chrome
?
PREF_MAX_SCRIPT_RUN_TIME_CHROME
:
PREF_MAX_SCRIPT_RUN_TIME_CONTENT
;
int32_t
limit
=
Preferences
:
:
GetInt
(
prefName
chrome
?
20
:
10
)
;
if
(
limit
=
=
0
|
|
duration
.
ToSeconds
(
)
<
limit
/
2
.
0
)
return
true
;
self
-
>
mSlowScriptActualWait
+
=
duration
;
if
(
!
self
-
>
mSlowScriptSecondHalf
)
{
self
-
>
mSlowScriptCheckpoint
=
TimeStamp
:
:
NowLoRes
(
)
;
self
-
>
mSlowScriptSecondHalf
=
true
;
return
true
;
}
RootedObject
global
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
RefPtr
<
nsGlobalWindow
>
win
=
WindowOrNull
(
global
)
;
if
(
!
win
&
&
IsSandbox
(
global
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
!
JS_GetPrototype
(
cx
global
&
proto
)
)
return
false
;
if
(
proto
&
&
IsSandboxPrototypeProxy
(
proto
)
&
&
(
proto
=
js
:
:
CheckedUnwrap
(
proto
false
)
)
)
{
win
=
WindowGlobalOrNull
(
proto
)
;
}
}
if
(
!
win
)
{
NS_WARNING
(
"
No
active
window
"
)
;
return
true
;
}
if
(
win
-
>
IsDying
(
)
)
{
return
false
;
}
if
(
win
-
>
GetIsPrerendered
(
)
)
{
mozilla
:
:
dom
:
:
HandlePrerenderingViolation
(
win
-
>
AsInner
(
)
)
;
return
false
;
}
if
(
!
chrome
&
&
!
self
-
>
mTimeoutAccumulated
)
{
uint32_t
delay
=
uint32_t
(
self
-
>
mSlowScriptActualWait
.
ToMilliseconds
(
)
-
(
limit
*
1000
.
0
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SLOW_SCRIPT_NOTIFY_DELAY
delay
)
;
self
-
>
mTimeoutAccumulated
=
true
;
}
nsGlobalWindow
:
:
SlowScriptResponse
response
=
win
-
>
ShowSlowScriptDialog
(
)
;
if
(
response
=
=
nsGlobalWindow
:
:
KillSlowScript
)
{
if
(
Preferences
:
:
GetBool
(
"
dom
.
global_stop_script
"
true
)
)
xpc
:
:
Scriptability
:
:
Get
(
global
)
.
Block
(
)
;
return
false
;
}
if
(
response
!
=
nsGlobalWindow
:
:
ContinueSlowScriptAndKeepNotifying
)
self
-
>
mSlowScriptCheckpoint
=
TimeStamp
:
:
NowLoRes
(
)
;
if
(
response
=
=
nsGlobalWindow
:
:
AlwaysContinueSlowScript
)
Preferences
:
:
SetInt
(
prefName
0
)
;
return
true
;
}
XPCJSContext
:
:
~
XPCJSContext
(
)
{
MOZ_ASSERT
(
MaybeContext
(
)
)
;
js
:
:
SetActivityCallback
(
Context
(
)
nullptr
nullptr
)
;
SetPendingException
(
nullptr
)
;
xpc_DelocalizeContext
(
Context
(
)
)
;
if
(
mWatchdogManager
-
>
GetWatchdog
(
)
)
mWatchdogManager
-
>
StopWatchdog
(
)
;
if
(
mCallContext
)
mCallContext
-
>
SystemIsBeingShutDown
(
)
;
auto
rtPrivate
=
static_cast
<
PerThreadAtomCache
*
>
(
JS_GetContextPrivate
(
Context
(
)
)
)
;
delete
rtPrivate
;
JS_SetContextPrivate
(
Context
(
)
nullptr
)
;
#
ifdef
MOZ_GECKO_PROFILER
profiler_clear_js_context
(
)
;
#
endif
}
XPCJSContext
:
:
XPCJSContext
(
)
:
mCallContext
(
nullptr
)
mAutoRoots
(
nullptr
)
mResolveName
(
JSID_VOID
)
mResolvingWrapper
(
nullptr
)
mWatchdogManager
(
new
WatchdogManager
(
this
)
)
mSlowScriptSecondHalf
(
false
)
mTimeoutAccumulated
(
false
)
mPendingResult
(
NS_OK
)
{
}
#
ifdef
XP_WIN
static
size_t
GetWindowsStackSize
(
)
{
const
uint8_t
*
stackTop
;
#
ifdef
_WIN64
PNT_TIB64
pTib
=
reinterpret_cast
<
PNT_TIB64
>
(
NtCurrentTeb
(
)
)
;
stackTop
=
reinterpret_cast
<
const
uint8_t
*
>
(
pTib
-
>
StackBase
)
;
#
else
PNT_TIB
pTib
=
reinterpret_cast
<
PNT_TIB
>
(
NtCurrentTeb
(
)
)
;
stackTop
=
reinterpret_cast
<
const
uint8_t
*
>
(
pTib
-
>
StackBase
)
;
#
endif
MEMORY_BASIC_INFORMATION
mbi
;
if
(
!
VirtualQuery
(
&
mbi
&
mbi
sizeof
(
mbi
)
)
)
MOZ_CRASH
(
"
VirtualQuery
failed
"
)
;
const
uint8_t
*
stackBottom
=
reinterpret_cast
<
const
uint8_t
*
>
(
mbi
.
AllocationBase
)
;
size_t
stackSize
=
size_t
(
stackTop
-
stackBottom
)
;
MOZ_RELEASE_ASSERT
(
stackSize
>
=
1
*
1024
*
1024
)
;
MOZ_RELEASE_ASSERT
(
stackSize
<
=
32
*
1024
*
1024
)
;
return
stackSize
-
10
*
sizeof
(
uintptr_t
)
*
1024
;
}
#
endif
XPCJSRuntime
*
XPCJSContext
:
:
Runtime
(
)
const
{
return
static_cast
<
XPCJSRuntime
*
>
(
CycleCollectedJSContext
:
:
Runtime
(
)
)
;
}
CycleCollectedJSRuntime
*
XPCJSContext
:
:
CreateRuntime
(
JSContext
*
aCx
)
{
return
new
XPCJSRuntime
(
aCx
)
;
}
nsresult
XPCJSContext
:
:
Initialize
(
)
{
nsresult
rv
=
CycleCollectedJSContext
:
:
Initialize
(
nullptr
JS
:
:
DefaultHeapMaxBytes
JS
:
:
DefaultNurseryBytes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
Context
(
)
)
;
JSContext
*
cx
=
Context
(
)
;
auto
cxPrivate
=
new
PerThreadAtomCache
(
)
;
memset
(
cxPrivate
0
sizeof
(
PerThreadAtomCache
)
)
;
JS_SetContextPrivate
(
cx
cxPrivate
)
;
const
size_t
kSystemCodeBuffer
=
10
*
1024
;
const
size_t
kDefaultStackQuota
=
128
*
sizeof
(
size_t
)
*
1024
;
#
if
defined
(
XP_MACOSX
)
|
|
defined
(
DARWIN
)
const
size_t
kStackQuota
=
7
*
1024
*
1024
;
const
size_t
kTrustedScriptBuffer
=
180
*
1024
;
#
elif
defined
(
MOZ_ASAN
)
const
size_t
kStackQuota
=
2
*
kDefaultStackQuota
;
const
size_t
kTrustedScriptBuffer
=
450
*
1024
;
#
elif
defined
(
XP_WIN
)
const
size_t
kStackQuota
=
GetWindowsStackSize
(
)
;
const
size_t
kTrustedScriptBuffer
=
(
sizeof
(
size_t
)
=
=
8
)
?
180
*
1024
:
120
*
1024
;
#
elif
defined
(
ANDROID
)
const
size_t
kStackQuota
=
kDefaultStackQuota
+
kDefaultStackQuota
/
2
;
const
size_t
kTrustedScriptBuffer
=
sizeof
(
size_t
)
*
12800
;
#
elif
defined
(
DEBUG
)
const
size_t
kStackQuota
=
2
*
kDefaultStackQuota
;
const
size_t
kTrustedScriptBuffer
=
sizeof
(
size_t
)
*
12800
;
#
else
const
size_t
kStackQuota
=
kDefaultStackQuota
;
const
size_t
kTrustedScriptBuffer
=
sizeof
(
size_t
)
*
12800
;
#
endif
(
void
)
kDefaultStackQuota
;
JS_SetNativeStackQuota
(
cx
kStackQuota
kStackQuota
-
kSystemCodeBuffer
kStackQuota
-
kSystemCodeBuffer
-
kTrustedScriptBuffer
)
;
#
ifdef
MOZ_GECKO_PROFILER
profiler_set_js_context
(
cx
)
;
#
endif
js
:
:
SetActivityCallback
(
cx
ActivityCallback
this
)
;
JS_AddInterruptCallback
(
cx
InterruptCallback
)
;
if
(
!
xpc_LocalizeContext
(
cx
)
)
NS_RUNTIMEABORT
(
"
xpc_LocalizeContext
failed
.
"
)
;
Runtime
(
)
-
>
Initialize
(
)
;
return
NS_OK
;
}
XPCJSContext
*
XPCJSContext
:
:
newXPCJSContext
(
)
{
XPCJSContext
*
self
=
new
XPCJSContext
(
)
;
nsresult
rv
=
self
-
>
Initialize
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_RUNTIMEABORT
(
"
new
XPCJSContext
failed
to
initialize
.
"
)
;
delete
self
;
return
nullptr
;
}
if
(
self
-
>
Context
(
)
)
return
self
;
NS_RUNTIMEABORT
(
"
new
XPCJSContext
failed
to
initialize
.
"
)
;
return
nullptr
;
}
void
XPCJSContext
:
:
BeforeProcessTask
(
bool
aMightBlock
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aMightBlock
)
{
if
(
Promise
:
:
PerformMicroTaskCheckpoint
(
)
)
{
NS_DispatchToMainThread
(
new
Runnable
(
"
Empty_microtask_runnable
"
)
)
;
}
}
mSlowScriptCheckpoint
=
mozilla
:
:
TimeStamp
:
:
NowLoRes
(
)
;
mSlowScriptSecondHalf
=
false
;
mSlowScriptActualWait
=
mozilla
:
:
TimeDuration
(
)
;
mTimeoutAccumulated
=
false
;
js
:
:
ResetPerformanceMonitoring
(
Get
(
)
-
>
Context
(
)
)
;
CycleCollectedJSContext
:
:
BeforeProcessTask
(
aMightBlock
)
;
}
void
XPCJSContext
:
:
AfterProcessTask
(
uint32_t
aNewRecursionDepth
)
{
mSlowScriptCheckpoint
=
mozilla
:
:
TimeStamp
(
)
;
mSlowScriptSecondHalf
=
false
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsJSContext
:
:
MaybePokeCC
(
)
;
CycleCollectedJSContext
:
:
AfterProcessTask
(
aNewRecursionDepth
)
;
js
:
:
FlushPerformanceMonitoring
(
Get
(
)
-
>
Context
(
)
)
;
mozilla
:
:
jsipc
:
:
AfterProcessTask
(
)
;
}
