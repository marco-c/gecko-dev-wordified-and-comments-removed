#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
XPCWrapper
.
h
"
#
include
"
XPCJSMemoryReporter
.
h
"
#
include
"
WrapperFactory
.
h
"
#
include
"
mozJSComponentLoader
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIDebug2
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
ifdef
FUZZING
#
include
"
mozilla
/
StaticPrefs_fuzzing
.
h
"
#
endif
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_javascript
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsCycleCollectionNoteRootCallback
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
ContextOptions
.
h
"
#
include
"
js
/
MemoryMetrics
.
h
"
#
include
"
js
/
OffThreadScriptCompilation
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
mozilla
/
extensions
/
WebExtensionPolicy
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ProcessHangMonitor
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
SystemPrincipal
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
AccessCheck
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsAboutProtocolUtils
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
ExpandedPrincipal
.
h
"
#
if
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
#
include
<
algorithm
>
#
include
<
sys
/
resource
.
h
>
#
endif
#
ifdef
XP_WIN
#
include
<
algorithm
>
#
include
<
windows
.
h
>
#
endif
using
namespace
mozilla
;
using
namespace
xpc
;
using
namespace
JS
;
#
if
!
defined
(
PTHREAD_STACK_MIN
)
#
define
PTHREAD_STACK_MIN
0
#
endif
static
constexpr
size_t
kWatchdogStackSize
=
PTHREAD_STACK_MIN
<
32
*
1024
?
32
*
1024
:
PTHREAD_STACK_MIN
;
static
void
WatchdogMain
(
void
*
arg
)
;
class
Watchdog
;
class
WatchdogManager
;
class
MOZ_RAII
AutoLockWatchdog
final
{
Watchdog
*
const
mWatchdog
;
public
:
explicit
AutoLockWatchdog
(
Watchdog
*
aWatchdog
)
;
~
AutoLockWatchdog
(
)
;
}
;
class
Watchdog
{
public
:
explicit
Watchdog
(
WatchdogManager
*
aManager
)
:
mManager
(
aManager
)
mLock
(
nullptr
)
mWakeup
(
nullptr
)
mThread
(
nullptr
)
mHibernating
(
false
)
mInitialized
(
false
)
mShuttingDown
(
false
)
mMinScriptRunTimeSeconds
(
1
)
{
}
~
Watchdog
(
)
{
MOZ_ASSERT
(
!
Initialized
(
)
)
;
}
WatchdogManager
*
Manager
(
)
{
return
mManager
;
}
bool
Initialized
(
)
{
return
mInitialized
;
}
bool
ShuttingDown
(
)
{
return
mShuttingDown
;
}
PRLock
*
GetLock
(
)
{
return
mLock
;
}
bool
Hibernating
(
)
{
return
mHibernating
;
}
void
WakeUp
(
)
{
MOZ_ASSERT
(
Initialized
(
)
)
;
MOZ_ASSERT
(
Hibernating
(
)
)
;
mHibernating
=
false
;
PR_NotifyCondVar
(
mWakeup
)
;
}
void
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mLock
=
PR_NewLock
(
)
;
if
(
!
mLock
)
{
MOZ_CRASH
(
"
PR_NewLock
failed
.
"
)
;
}
mWakeup
=
PR_NewCondVar
(
mLock
)
;
if
(
!
mWakeup
)
{
MOZ_CRASH
(
"
PR_NewCondVar
failed
.
"
)
;
}
{
nsCOMPtr
<
nsIDebug2
>
dbg
=
do_GetService
(
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
)
;
Unused
<
<
dbg
;
}
{
AutoLockWatchdog
lock
(
this
)
;
mThread
=
PR_CreateThread
(
PR_USER_THREAD
WatchdogMain
this
PR_PRIORITY_NORMAL
PR_GLOBAL_THREAD
PR_JOINABLE_THREAD
kWatchdogStackSize
)
;
if
(
!
mThread
)
{
MOZ_CRASH
(
"
PR_CreateThread
failed
!
"
)
;
}
mInitialized
=
true
;
}
}
void
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
Initialized
(
)
)
;
{
AutoLockWatchdog
lock
(
this
)
;
mShuttingDown
=
true
;
PR_NotifyCondVar
(
mWakeup
)
;
}
PR_JoinThread
(
mThread
)
;
MOZ_ASSERT
(
!
mShuttingDown
)
;
mThread
=
nullptr
;
PR_DestroyCondVar
(
mWakeup
)
;
mWakeup
=
nullptr
;
PR_DestroyLock
(
mLock
)
;
mLock
=
nullptr
;
mInitialized
=
false
;
}
void
SetMinScriptRunTimeSeconds
(
int32_t
seconds
)
{
MOZ_ASSERT
(
seconds
>
0
)
;
mMinScriptRunTimeSeconds
=
seconds
;
}
void
Hibernate
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mHibernating
=
true
;
Sleep
(
PR_INTERVAL_NO_TIMEOUT
)
;
}
void
Sleep
(
PRIntervalTime
timeout
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ALWAYS_TRUE
(
PR_WaitCondVar
(
mWakeup
timeout
)
=
=
PR_SUCCESS
)
;
}
void
Finished
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mShuttingDown
=
false
;
}
int32_t
MinScriptRunTimeSeconds
(
)
{
return
mMinScriptRunTimeSeconds
;
}
private
:
WatchdogManager
*
mManager
;
PRLock
*
mLock
;
PRCondVar
*
mWakeup
;
PRThread
*
mThread
;
bool
mHibernating
;
bool
mInitialized
;
bool
mShuttingDown
;
mozilla
:
:
Atomic
<
int32_t
>
mMinScriptRunTimeSeconds
;
}
;
#
define
PREF_MAX_SCRIPT_RUN_TIME_CONTENT
"
dom
.
max_script_run_time
"
#
define
PREF_MAX_SCRIPT_RUN_TIME_CHROME
"
dom
.
max_chrome_script_run_time
"
#
define
PREF_MAX_SCRIPT_RUN_TIME_EXT_CONTENT
\
"
dom
.
max_ext_content_script_run_time
"
static
const
char
*
gCallbackPrefs
[
]
=
{
"
dom
.
use_watchdog
"
PREF_MAX_SCRIPT_RUN_TIME_CONTENT
PREF_MAX_SCRIPT_RUN_TIME_CHROME
PREF_MAX_SCRIPT_RUN_TIME_EXT_CONTENT
nullptr
}
;
class
WatchdogManager
{
public
:
explicit
WatchdogManager
(
)
{
PodArrayZero
(
mTimestamps
)
;
Preferences
:
:
RegisterCallbacks
(
PrefsChanged
gCallbackPrefs
this
)
;
}
virtual
~
WatchdogManager
(
)
{
MOZ_ASSERT
(
!
mWatchdog
)
;
}
private
:
static
void
PrefsChanged
(
const
char
*
aPref
void
*
aSelf
)
{
static_cast
<
WatchdogManager
*
>
(
aSelf
)
-
>
RefreshWatchdog
(
)
;
}
public
:
void
Shutdown
(
)
{
Preferences
:
:
UnregisterCallbacks
(
PrefsChanged
gCallbackPrefs
this
)
;
}
void
RegisterContext
(
XPCJSContext
*
aContext
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AutoLockWatchdog
lock
(
mWatchdog
.
get
(
)
)
;
if
(
aContext
-
>
mActive
=
=
XPCJSContext
:
:
CONTEXT_ACTIVE
)
{
mActiveContexts
.
insertBack
(
aContext
)
;
}
else
{
mInactiveContexts
.
insertBack
(
aContext
)
;
}
RefreshWatchdog
(
)
;
}
void
UnregisterContext
(
XPCJSContext
*
aContext
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AutoLockWatchdog
lock
(
mWatchdog
.
get
(
)
)
;
aContext
-
>
LinkedListElement
<
XPCJSContext
>
:
:
remove
(
)
;
#
ifdef
DEBUG
if
(
mActiveContexts
.
isEmpty
(
)
&
&
mInactiveContexts
.
isEmpty
(
)
)
{
MOZ_ASSERT
(
!
mWatchdog
)
;
}
#
endif
}
void
RecordContextActivity
(
XPCJSContext
*
aContext
bool
active
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AutoLockWatchdog
lock
(
mWatchdog
.
get
(
)
)
;
aContext
-
>
mLastStateChange
=
PR_Now
(
)
;
aContext
-
>
mActive
=
active
?
XPCJSContext
:
:
CONTEXT_ACTIVE
:
XPCJSContext
:
:
CONTEXT_INACTIVE
;
UpdateContextLists
(
aContext
)
;
if
(
active
&
&
mWatchdog
&
&
mWatchdog
-
>
Hibernating
(
)
)
{
mWatchdog
-
>
WakeUp
(
)
;
}
}
bool
IsAnyContextActive
(
)
{
return
!
mActiveContexts
.
isEmpty
(
)
;
}
PRTime
TimeSinceLastActiveContext
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
PR_ASSERT_CURRENT_THREAD_OWNS_LOCK
(
mWatchdog
-
>
GetLock
(
)
)
;
MOZ_ASSERT
(
mActiveContexts
.
isEmpty
(
)
)
;
MOZ_ASSERT
(
!
mInactiveContexts
.
isEmpty
(
)
)
;
return
PR_Now
(
)
-
mInactiveContexts
.
getLast
(
)
-
>
mLastStateChange
;
}
void
RecordTimestamp
(
WatchdogTimestampCategory
aCategory
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
PR_ASSERT_CURRENT_THREAD_OWNS_LOCK
(
mWatchdog
-
>
GetLock
(
)
)
;
MOZ_ASSERT
(
aCategory
!
=
TimestampContextStateChange
"
Use
RecordContextActivity
to
update
this
"
)
;
mTimestamps
[
aCategory
]
=
PR_Now
(
)
;
}
PRTime
GetContextTimestamp
(
XPCJSContext
*
aContext
const
AutoLockWatchdog
&
aProofOfLock
)
{
return
aContext
-
>
mLastStateChange
;
}
PRTime
GetTimestamp
(
WatchdogTimestampCategory
aCategory
const
AutoLockWatchdog
&
aProofOfLock
)
{
MOZ_ASSERT
(
aCategory
!
=
TimestampContextStateChange
"
Use
GetContextTimestamp
to
retrieve
this
"
)
;
return
mTimestamps
[
aCategory
]
;
}
Watchdog
*
GetWatchdog
(
)
{
return
mWatchdog
.
get
(
)
;
}
void
RefreshWatchdog
(
)
{
bool
wantWatchdog
=
Preferences
:
:
GetBool
(
"
dom
.
use_watchdog
"
true
)
;
if
(
wantWatchdog
!
=
!
!
mWatchdog
)
{
if
(
wantWatchdog
)
{
StartWatchdog
(
)
;
}
else
{
StopWatchdog
(
)
;
}
}
if
(
mWatchdog
)
{
int32_t
contentTime
=
StaticPrefs
:
:
dom_max_script_run_time
(
)
;
if
(
contentTime
<
=
0
)
{
contentTime
=
INT32_MAX
;
}
int32_t
chromeTime
=
StaticPrefs
:
:
dom_max_chrome_script_run_time
(
)
;
if
(
chromeTime
<
=
0
)
{
chromeTime
=
INT32_MAX
;
}
int32_t
extTime
=
StaticPrefs
:
:
dom_max_ext_content_script_run_time
(
)
;
if
(
extTime
<
=
0
)
{
extTime
=
INT32_MAX
;
}
mWatchdog
-
>
SetMinScriptRunTimeSeconds
(
std
:
:
min
(
{
contentTime
chromeTime
extTime
}
)
)
;
}
}
void
StartWatchdog
(
)
{
MOZ_ASSERT
(
!
mWatchdog
)
;
mWatchdog
=
mozilla
:
:
MakeUnique
<
Watchdog
>
(
this
)
;
mWatchdog
-
>
Init
(
)
;
}
void
StopWatchdog
(
)
{
MOZ_ASSERT
(
mWatchdog
)
;
mWatchdog
-
>
Shutdown
(
)
;
mWatchdog
=
nullptr
;
}
template
<
class
Callback
>
void
ForAllActiveContexts
(
Callback
&
&
aCallback
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
PR_ASSERT_CURRENT_THREAD_OWNS_LOCK
(
mWatchdog
-
>
GetLock
(
)
)
;
for
(
auto
*
context
=
mActiveContexts
.
getFirst
(
)
;
context
;
context
=
context
-
>
LinkedListElement
<
XPCJSContext
>
:
:
getNext
(
)
)
{
if
(
!
aCallback
(
context
)
)
{
return
;
}
}
}
private
:
void
UpdateContextLists
(
XPCJSContext
*
aContext
)
{
aContext
-
>
LinkedListElement
<
XPCJSContext
>
:
:
remove
(
)
;
auto
&
list
=
aContext
-
>
mActive
=
=
XPCJSContext
:
:
CONTEXT_ACTIVE
?
mActiveContexts
:
mInactiveContexts
;
MOZ_ASSERT_IF
(
!
list
.
isEmpty
(
)
list
.
getLast
(
)
-
>
mLastStateChange
<
aContext
-
>
mLastStateChange
)
;
list
.
insertBack
(
aContext
)
;
}
LinkedList
<
XPCJSContext
>
mActiveContexts
;
LinkedList
<
XPCJSContext
>
mInactiveContexts
;
mozilla
:
:
UniquePtr
<
Watchdog
>
mWatchdog
;
PRTime
mTimestamps
[
kWatchdogTimestampCategoryCount
-
1
]
;
}
;
AutoLockWatchdog
:
:
AutoLockWatchdog
(
Watchdog
*
aWatchdog
)
:
mWatchdog
(
aWatchdog
)
{
if
(
mWatchdog
)
{
PR_Lock
(
mWatchdog
-
>
GetLock
(
)
)
;
}
}
AutoLockWatchdog
:
:
~
AutoLockWatchdog
(
)
{
if
(
mWatchdog
)
{
PR_Unlock
(
mWatchdog
-
>
GetLock
(
)
)
;
}
}
static
void
WatchdogMain
(
void
*
arg
)
{
AUTO_PROFILER_REGISTER_THREAD
(
"
JS
Watchdog
"
)
;
Unused
<
<
NS_GetCurrentThread
(
)
;
NS_SetCurrentThreadName
(
"
JS
Watchdog
"
)
;
Watchdog
*
self
=
static_cast
<
Watchdog
*
>
(
arg
)
;
WatchdogManager
*
manager
=
self
-
>
Manager
(
)
;
AutoLockWatchdog
lock
(
self
)
;
MOZ_ASSERT
(
self
-
>
Initialized
(
)
)
;
while
(
!
self
-
>
ShuttingDown
(
)
)
{
if
(
manager
-
>
IsAnyContextActive
(
)
|
|
manager
-
>
TimeSinceLastActiveContext
(
)
<
=
PRTime
(
2
*
PR_USEC_PER_SEC
)
)
{
self
-
>
Sleep
(
PR_TicksPerSecond
(
)
)
;
}
else
{
manager
-
>
RecordTimestamp
(
TimestampWatchdogHibernateStart
)
;
self
-
>
Hibernate
(
)
;
manager
-
>
RecordTimestamp
(
TimestampWatchdogHibernateStop
)
;
}
manager
-
>
RecordTimestamp
(
TimestampWatchdogWakeup
)
;
if
(
!
self
-
>
ShuttingDown
(
)
&
&
manager
-
>
IsAnyContextActive
(
)
)
{
bool
debuggerAttached
=
false
;
nsCOMPtr
<
nsIDebug2
>
dbg
=
do_GetService
(
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
)
;
if
(
dbg
)
{
dbg
-
>
GetIsDebuggerAttached
(
&
debuggerAttached
)
;
}
if
(
debuggerAttached
)
{
continue
;
}
PRTime
usecs
=
self
-
>
MinScriptRunTimeSeconds
(
)
*
PR_USEC_PER_SEC
/
2
;
manager
-
>
ForAllActiveContexts
(
[
usecs
manager
&
lock
]
(
XPCJSContext
*
aContext
)
-
>
bool
{
auto
timediff
=
PR_Now
(
)
-
manager
-
>
GetContextTimestamp
(
aContext
lock
)
;
if
(
timediff
>
usecs
)
{
JS_RequestInterruptCallback
(
aContext
-
>
Context
(
)
)
;
return
true
;
}
return
false
;
}
)
;
}
}
self
-
>
Finished
(
)
;
}
PRTime
XPCJSContext
:
:
GetWatchdogTimestamp
(
WatchdogTimestampCategory
aCategory
)
{
AutoLockWatchdog
lock
(
mWatchdogManager
-
>
GetWatchdog
(
)
)
;
return
aCategory
=
=
TimestampContextStateChange
?
mWatchdogManager
-
>
GetContextTimestamp
(
this
lock
)
:
mWatchdogManager
-
>
GetTimestamp
(
aCategory
lock
)
;
}
bool
XPCJSContext
:
:
RecordScriptActivity
(
bool
aActive
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
XPCJSContext
*
xpccx
=
XPCJSContext
:
:
Get
(
)
;
if
(
!
xpccx
)
{
MOZ_ASSERT
(
!
aActive
)
;
return
false
;
}
bool
oldValue
=
xpccx
-
>
SetHasScriptActivity
(
aActive
)
;
if
(
aActive
=
=
oldValue
)
{
return
oldValue
;
}
if
(
!
aActive
)
{
ProcessHangMonitor
:
:
ClearHang
(
)
;
}
xpccx
-
>
mWatchdogManager
-
>
RecordContextActivity
(
xpccx
aActive
)
;
return
oldValue
;
}
AutoScriptActivity
:
:
AutoScriptActivity
(
bool
aActive
)
:
mActive
(
aActive
)
mOldValue
(
XPCJSContext
:
:
RecordScriptActivity
(
aActive
)
)
{
}
AutoScriptActivity
:
:
~
AutoScriptActivity
(
)
{
MOZ_ALWAYS_TRUE
(
mActive
=
=
XPCJSContext
:
:
RecordScriptActivity
(
mOldValue
)
)
;
}
static
const
double
sChromeSlowScriptTelemetryCutoff
(
10
.
0
)
;
static
bool
sTelemetryEventEnabled
(
false
)
;
bool
XPCJSContext
:
:
InterruptCallback
(
JSContext
*
cx
)
{
XPCJSContext
*
self
=
XPCJSContext
:
:
Get
(
)
;
PROFILER_JS_INTERRUPT_CALLBACK
(
)
;
#
ifdef
MOZ_GECKO_PROFILER
nsDependentCString
filename
(
"
unknown
file
"
)
;
JS
:
:
AutoFilename
scriptFilename
;
if
(
JS
:
:
DescribeScriptedCaller
(
cx
&
scriptFilename
)
)
{
if
(
const
char
*
file
=
scriptFilename
.
get
(
)
)
{
filename
.
Assign
(
file
strlen
(
file
)
)
;
}
PROFILER_MARKER_TEXT
(
"
JS
:
:
InterruptCallback
"
JS
{
}
filename
)
;
}
#
endif
if
(
self
-
>
mSlowScriptCheckpoint
.
IsNull
(
)
)
{
self
-
>
mSlowScriptCheckpoint
=
TimeStamp
:
:
NowLoRes
(
)
;
self
-
>
mSlowScriptSecondHalf
=
false
;
self
-
>
mSlowScriptActualWait
=
mozilla
:
:
TimeDuration
(
)
;
self
-
>
mTimeoutAccumulated
=
false
;
self
-
>
mExecutedChromeScript
=
false
;
return
true
;
}
if
(
!
nsContentUtils
:
:
IsInitialized
(
)
)
{
return
true
;
}
TimeStamp
now
=
TimeStamp
:
:
NowLoRes
(
)
;
TimeDuration
duration
=
now
-
self
-
>
mSlowScriptCheckpoint
;
int32_t
limit
;
nsString
addonId
;
const
char
*
prefName
;
auto
principal
=
BasePrincipal
:
:
Cast
(
nsContentUtils
:
:
SubjectPrincipal
(
cx
)
)
;
bool
chrome
=
principal
-
>
Is
<
SystemPrincipal
>
(
)
;
if
(
chrome
)
{
prefName
=
PREF_MAX_SCRIPT_RUN_TIME_CHROME
;
limit
=
StaticPrefs
:
:
dom_max_chrome_script_run_time
(
)
;
self
-
>
mExecutedChromeScript
=
true
;
}
else
if
(
auto
policy
=
principal
-
>
ContentScriptAddonPolicy
(
)
)
{
policy
-
>
GetId
(
addonId
)
;
prefName
=
PREF_MAX_SCRIPT_RUN_TIME_EXT_CONTENT
;
limit
=
StaticPrefs
:
:
dom_max_ext_content_script_run_time
(
)
;
}
else
{
prefName
=
PREF_MAX_SCRIPT_RUN_TIME_CONTENT
;
limit
=
StaticPrefs
:
:
dom_max_script_run_time
(
)
;
}
if
(
limit
=
=
0
&
&
chrome
&
&
duration
.
ToSeconds
(
)
>
sChromeSlowScriptTelemetryCutoff
/
2
.
0
)
{
self
-
>
mSlowScriptSecondHalf
=
true
;
return
true
;
}
if
(
limit
=
=
0
|
|
duration
.
ToSeconds
(
)
<
limit
/
2
.
0
)
{
return
true
;
}
self
-
>
mSlowScriptCheckpoint
=
now
;
self
-
>
mSlowScriptActualWait
+
=
duration
;
if
(
!
self
-
>
mSlowScriptSecondHalf
)
{
self
-
>
mSlowScriptSecondHalf
=
true
;
return
true
;
}
if
(
XRE_IsContentProcess
(
)
&
&
StaticPrefs
:
:
dom_max_script_run_time_require_critical_input
(
)
)
{
ContentChild
*
contentChild
=
ContentChild
:
:
GetSingleton
(
)
;
mozilla
:
:
ipc
:
:
MessageChannel
*
channel
=
contentChild
?
contentChild
-
>
GetIPCChannel
(
)
:
nullptr
;
if
(
channel
)
{
bool
foundInputEvent
=
false
;
channel
-
>
PeekMessages
(
[
&
foundInputEvent
]
(
const
IPC
:
:
Message
&
aMsg
)
-
>
bool
{
if
(
nsContentUtils
:
:
IsMessageCriticalInputEvent
(
aMsg
)
)
{
foundInputEvent
=
true
;
return
false
;
}
return
true
;
}
)
;
if
(
!
foundInputEvent
)
{
return
true
;
}
}
}
if
(
chrome
&
&
limit
=
=
2
&
&
xpc
:
:
IsInAutomation
(
)
)
{
return
true
;
}
RootedObject
global
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
RefPtr
<
nsGlobalWindowInner
>
win
=
WindowOrNull
(
global
)
;
if
(
!
win
)
{
win
=
SandboxWindowOrNull
(
global
cx
)
;
}
if
(
!
win
)
{
NS_WARNING
(
"
No
active
window
"
)
;
return
true
;
}
if
(
win
-
>
IsDying
(
)
)
{
return
false
;
}
if
(
!
chrome
&
&
!
self
-
>
mTimeoutAccumulated
)
{
uint32_t
delay
=
uint32_t
(
self
-
>
mSlowScriptActualWait
.
ToMilliseconds
(
)
-
(
limit
*
1000
.
0
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SLOW_SCRIPT_NOTIFY_DELAY
delay
)
;
self
-
>
mTimeoutAccumulated
=
true
;
}
nsGlobalWindowInner
:
:
SlowScriptResponse
response
=
win
-
>
ShowSlowScriptDialog
(
cx
addonId
self
-
>
mSlowScriptActualWait
.
ToMilliseconds
(
)
)
;
if
(
response
=
=
nsGlobalWindowInner
:
:
KillSlowScript
)
{
if
(
Preferences
:
:
GetBool
(
"
dom
.
global_stop_script
"
true
)
)
{
xpc
:
:
Scriptability
:
:
Get
(
global
)
.
Block
(
)
;
}
return
false
;
}
if
(
response
=
=
nsGlobalWindowInner
:
:
KillScriptGlobal
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
IsSandbox
(
global
)
|
|
!
obs
)
{
return
false
;
}
nsIXPConnect
*
xpc
=
nsContentUtils
:
:
XPConnect
(
)
;
JS
:
:
RootedObject
wrapper
(
cx
JS_NewPlainObject
(
cx
)
)
;
nsCOMPtr
<
nsISupports
>
supports
;
if
(
!
wrapper
|
|
!
JS_DefineProperty
(
cx
wrapper
"
wrappedJSObject
"
global
JSPROP_ENUMERATE
)
|
|
NS_FAILED
(
xpc
-
>
WrapJS
(
cx
wrapper
NS_GET_IID
(
nsISupports
)
getter_AddRefs
(
supports
)
)
)
)
{
return
false
;
}
obs
-
>
NotifyObservers
(
supports
"
kill
-
content
-
script
-
sandbox
"
nullptr
)
;
return
false
;
}
if
(
response
!
=
nsGlobalWindowInner
:
:
ContinueSlowScriptAndKeepNotifying
)
{
self
-
>
mSlowScriptCheckpoint
=
TimeStamp
:
:
NowLoRes
(
)
;
}
if
(
response
=
=
nsGlobalWindowInner
:
:
AlwaysContinueSlowScript
)
{
Preferences
:
:
SetInt
(
prefName
0
)
;
}
return
true
;
}
#
define
JS_OPTIONS_DOT_STR
"
javascript
.
options
.
"
static
mozilla
:
:
Atomic
<
bool
>
sDiscardSystemSource
(
false
)
;
bool
xpc
:
:
ShouldDiscardSystemSource
(
)
{
return
sDiscardSystemSource
;
}
static
mozilla
:
:
Atomic
<
bool
>
sSharedMemoryEnabled
(
false
)
;
static
mozilla
:
:
Atomic
<
bool
>
sStreamsEnabled
(
false
)
;
static
mozilla
:
:
Atomic
<
bool
>
sPropertyErrorMessageFixEnabled
(
false
)
;
static
mozilla
:
:
Atomic
<
bool
>
sWeakRefsEnabled
(
false
)
;
static
mozilla
:
:
Atomic
<
bool
>
sWeakRefsExposeCleanupSome
(
false
)
;
static
mozilla
:
:
Atomic
<
bool
>
sIteratorHelpersEnabled
(
false
)
;
static
JS
:
:
WeakRefSpecifier
GetWeakRefsEnabled
(
)
{
if
(
!
sWeakRefsEnabled
)
{
return
JS
:
:
WeakRefSpecifier
:
:
Disabled
;
}
if
(
sWeakRefsExposeCleanupSome
)
{
return
JS
:
:
WeakRefSpecifier
:
:
EnabledWithCleanupSome
;
}
return
JS
:
:
WeakRefSpecifier
:
:
EnabledWithoutCleanupSome
;
}
void
xpc
:
:
SetPrefableRealmOptions
(
JS
:
:
RealmOptions
&
options
)
{
options
.
creationOptions
(
)
.
setSharedMemoryAndAtomicsEnabled
(
sSharedMemoryEnabled
)
.
setCoopAndCoepEnabled
(
StaticPrefs
:
:
browser_tabs_remote_useCrossOriginOpenerPolicy
(
)
&
&
StaticPrefs
:
:
browser_tabs_remote_useCrossOriginEmbedderPolicy
(
)
)
.
setStreamsEnabled
(
sStreamsEnabled
)
.
setWritableStreamsEnabled
(
StaticPrefs
:
:
javascript_options_writable_streams
(
)
)
.
setPropertyErrorMessageFixEnabled
(
sPropertyErrorMessageFixEnabled
)
.
setWeakRefsEnabled
(
GetWeakRefsEnabled
(
)
)
.
setIteratorHelpersEnabled
(
sIteratorHelpersEnabled
)
;
}
static
void
LoadStartupJSPrefs
(
XPCJSContext
*
xpccx
)
{
JSContext
*
cx
=
xpccx
-
>
Context
(
)
;
bool
useJitForTrustedPrincipals
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
jit_trustedprincipals
"
false
)
;
bool
disableWasmHugeMemory
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_disable_huge_memory
"
false
)
;
bool
offthreadIonCompilation
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
ion
.
offthread_compilation
"
)
;
#
ifdef
DEBUG
bool
fullJitDebugChecks
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
jit
.
full_debug_checks
"
)
;
#
endif
bool
spectreIndexMasking
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
spectre
.
index_masking
"
)
;
bool
spectreObjectMitigations
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
spectre
.
object_mitigations
"
)
;
bool
spectreStringMitigations
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
spectre
.
string_mitigations
"
)
;
bool
spectreValueMasking
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
spectre
.
value_masking
"
)
;
bool
spectreJitToCxxCalls
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
spectre
.
jit_to_C
+
+
_calls
"
)
;
bool
safeMode
=
false
;
nsCOMPtr
<
nsIXULRuntime
>
xr
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
xr
)
{
xr
-
>
GetInSafeMode
(
&
safeMode
)
;
}
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_BASELINE_INTERPRETER_ENABLE
StaticPrefs
:
:
javascript_options_blinterp_DoNotUseDirectly
(
)
)
;
if
(
safeMode
)
{
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_BASELINE_ENABLE
false
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_ION_ENABLE
false
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_JIT_TRUSTEDPRINCIPALS_ENABLE
false
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_NATIVE_REGEXP_ENABLE
false
)
;
}
else
{
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_BASELINE_ENABLE
StaticPrefs
:
:
javascript_options_baselinejit_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_ION_ENABLE
StaticPrefs
:
:
javascript_options_ion_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_JIT_TRUSTEDPRINCIPALS_ENABLE
useJitForTrustedPrincipals
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_NATIVE_REGEXP_ENABLE
StaticPrefs
:
:
javascript_options_native_regexp_DoNotUseDirectly
(
)
)
;
}
JS_SetOffthreadIonCompilationEnabled
(
cx
offthreadIonCompilation
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_BASELINE_INTERPRETER_WARMUP_TRIGGER
StaticPrefs
:
:
javascript_options_blinterp_threshold_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_BASELINE_WARMUP_TRIGGER
StaticPrefs
:
:
javascript_options_baselinejit_threshold_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_ION_NORMAL_WARMUP_TRIGGER
StaticPrefs
:
:
javascript_options_ion_threshold_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_ION_FREQUENT_BAILOUT_THRESHOLD
StaticPrefs
:
:
javascript_options_ion_frequent_bailout_threshold_DoNotUseDirectly
(
)
)
;
#
ifdef
DEBUG
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_FULL_DEBUG_CHECKS
fullJitDebugChecks
)
;
#
endif
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_SPECTRE_INDEX_MASKING
spectreIndexMasking
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_SPECTRE_OBJECT_MITIGATIONS
spectreObjectMitigations
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_SPECTRE_STRING_MITIGATIONS
spectreStringMitigations
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_SPECTRE_VALUE_MASKING
spectreValueMasking
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_SPECTRE_JIT_TO_CXX_CALLS
spectreJitToCxxCalls
)
;
if
(
disableWasmHugeMemory
)
{
bool
disabledHugeMemory
=
JS
:
:
DisableWasmHugeMemory
(
)
;
MOZ_RELEASE_ASSERT
(
disabledHugeMemory
)
;
}
JS
:
:
SetLargeArrayBuffersEnabled
(
StaticPrefs
:
:
javascript_options_large_arraybuffers
(
)
)
;
}
static
void
ReloadPrefsCallback
(
const
char
*
pref
void
*
aXpccx
)
{
auto
xpccx
=
static_cast
<
XPCJSContext
*
>
(
aXpccx
)
;
JSContext
*
cx
=
xpccx
-
>
Context
(
)
;
bool
useAsmJS
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
asmjs
"
)
;
bool
useWasm
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm
"
)
;
bool
useWasmTrustedPrincipals
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_trustedprincipals
"
)
;
bool
useWasmOptimizing
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_optimizingjit
"
)
;
bool
useWasmBaseline
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_baselinejit
"
)
;
bool
useWasmReftypes
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_reftypes
"
)
;
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
bool
useWasmFunctionReferences
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_function_references
"
)
;
#
endif
#
ifdef
ENABLE_WASM_GC
bool
useWasmGc
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_gc
"
)
;
#
endif
#
ifdef
ENABLE_WASM_MULTI_VALUE
bool
useWasmMultiValue
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_multi_value
"
)
;
#
endif
#
ifdef
ENABLE_WASM_SIMD
bool
useWasmSimd
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_simd
"
)
;
#
endif
#
ifdef
ENABLE_WASM_SIMD_WORMHOLE
bool
useWasmSimdWormhole
=
false
;
#
ifdef
EARLY_BETA_OR_EARLIER
useWasmSimdWormhole
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_simd_wormhole
"
)
;
#
endif
#
endif
bool
useWasmVerbose
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_verbose
"
)
;
bool
throwOnAsmJSValidationFailure
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
throw_on_asmjs_validation_failure
"
)
;
bool
parallelParsing
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
parallel_parsing
"
)
;
sDiscardSystemSource
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
discardSystemSource
"
)
;
bool
useSourcePragmas
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
source_pragmas
"
)
;
bool
useAsyncStack
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
asyncstack
"
)
;
bool
useAsyncStackCaptureDebuggeeOnly
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
asyncstack_capture_debuggee_only
"
)
;
bool
throwOnDebuggeeWouldRun
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
throw_on_debuggee_would_run
"
)
;
bool
dumpStackOnDebuggeeWouldRun
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
dump_stack_on_debuggee_would_run
"
)
;
sSharedMemoryEnabled
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
shared_memory
"
)
;
sStreamsEnabled
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
streams
"
)
;
sPropertyErrorMessageFixEnabled
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
property_error_message_fix
"
)
;
sWeakRefsEnabled
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
weakrefs
"
)
;
sWeakRefsExposeCleanupSome
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
experimental
.
weakrefs
.
expose_cleanupSome
"
)
;
bool
privateFieldsEnabled
=
false
;
bool
privateMethodsEnabled
=
false
;
#
ifdef
NIGHTLY_BUILD
sIteratorHelpersEnabled
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
experimental
.
iterator_helpers
"
)
;
privateFieldsEnabled
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
experimental
.
private_fields
"
)
;
privateMethodsEnabled
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
experimental
.
private_methods
"
)
;
#
endif
bool
topLevelAwaitEnabled
=
false
;
#
ifdef
NIGHTLY_BUILD
topLevelAwaitEnabled
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
experimental
.
top_level_await
"
)
;
#
endif
#
ifdef
JS_GC_ZEAL
int32_t
zeal
=
Preferences
:
:
GetInt
(
JS_OPTIONS_DOT_STR
"
gczeal
"
-
1
)
;
int32_t
zeal_frequency
=
Preferences
:
:
GetInt
(
JS_OPTIONS_DOT_STR
"
gczeal
.
frequency
"
JS_DEFAULT_ZEAL_FREQ
)
;
if
(
zeal
>
=
0
)
{
JS_SetGCZeal
(
cx
(
uint8_t
)
zeal
zeal_frequency
)
;
}
#
endif
#
ifdef
FUZZING
bool
fuzzingEnabled
=
StaticPrefs
:
:
fuzzing_enabled
(
)
;
#
endif
JS
:
:
ContextOptionsRef
(
cx
)
.
setAsmJS
(
useAsmJS
)
#
ifdef
FUZZING
.
setFuzzing
(
fuzzingEnabled
)
#
endif
.
setWasm
(
useWasm
)
.
setWasmForTrustedPrinciples
(
useWasmTrustedPrincipals
)
#
ifdef
ENABLE_WASM_CRANELIFT
.
setWasmCranelift
(
useWasmOptimizing
)
#
else
.
setWasmIon
(
useWasmOptimizing
)
#
endif
.
setWasmBaseline
(
useWasmBaseline
)
.
setWasmReftypes
(
useWasmReftypes
)
#
ifdef
ENABLE_WASM_FUNCTION_REFERENCES
.
setWasmFunctionReferences
(
useWasmFunctionReferences
)
#
endif
#
ifdef
ENABLE_WASM_GC
.
setWasmGc
(
useWasmGc
)
#
endif
#
ifdef
ENABLE_WASM_MULTI_VALUE
.
setWasmMultiValue
(
useWasmMultiValue
)
#
endif
#
ifdef
ENABLE_WASM_SIMD
.
setWasmSimd
(
useWasmSimd
)
#
endif
#
ifdef
ENABLE_WASM_SIMD_WORMHOLE
.
setWasmSimdWormhole
(
useWasmSimdWormhole
)
#
endif
.
setWasmVerbose
(
useWasmVerbose
)
.
setThrowOnAsmJSValidationFailure
(
throwOnAsmJSValidationFailure
)
.
setSourcePragmas
(
useSourcePragmas
)
.
setAsyncStack
(
useAsyncStack
)
.
setAsyncStackCaptureDebuggeeOnly
(
useAsyncStackCaptureDebuggeeOnly
)
.
setThrowOnDebuggeeWouldRun
(
throwOnDebuggeeWouldRun
)
.
setDumpStackOnDebuggeeWouldRun
(
dumpStackOnDebuggeeWouldRun
)
.
setPrivateClassFields
(
privateFieldsEnabled
)
.
setPrivateClassMethods
(
privateMethodsEnabled
)
.
setTopLevelAwait
(
topLevelAwaitEnabled
)
;
nsCOMPtr
<
nsIXULRuntime
>
xr
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
xr
)
{
bool
safeMode
=
false
;
xr
-
>
GetInSafeMode
(
&
safeMode
)
;
if
(
safeMode
)
{
JS
:
:
ContextOptionsRef
(
cx
)
.
disableOptionsForSafeMode
(
)
;
}
}
JS_SetParallelParsingEnabled
(
cx
parallelParsing
)
;
}
XPCJSContext
:
:
~
XPCJSContext
(
)
{
MOZ_COUNT_DTOR_INHERITED
(
XPCJSContext
CycleCollectedJSContext
)
;
MOZ_ASSERT
(
MaybeContext
(
)
)
;
Preferences
:
:
UnregisterPrefixCallback
(
ReloadPrefsCallback
JS_OPTIONS_DOT_STR
this
)
;
#
ifdef
FUZZING
Preferences
:
:
UnregisterCallback
(
ReloadPrefsCallback
"
fuzzing
.
enabled
"
this
)
;
#
endif
SetPendingException
(
nullptr
)
;
if
(
-
-
sInstanceCount
=
=
0
)
{
if
(
mWatchdogManager
-
>
GetWatchdog
(
)
)
{
mWatchdogManager
-
>
StopWatchdog
(
)
;
}
mWatchdogManager
-
>
UnregisterContext
(
this
)
;
mWatchdogManager
-
>
Shutdown
(
)
;
sWatchdogInstance
=
nullptr
;
}
else
{
mWatchdogManager
-
>
UnregisterContext
(
this
)
;
}
if
(
mCallContext
)
{
mCallContext
-
>
SystemIsBeingShutDown
(
)
;
}
PROFILER_CLEAR_JS_CONTEXT
(
)
;
}
XPCJSContext
:
:
XPCJSContext
(
)
:
mCallContext
(
nullptr
)
mAutoRoots
(
nullptr
)
mResolveName
(
JSID_VOID
)
mResolvingWrapper
(
nullptr
)
mWatchdogManager
(
GetWatchdogManager
(
)
)
mSlowScriptSecondHalf
(
false
)
mTimeoutAccumulated
(
false
)
mExecutedChromeScript
(
false
)
mHasScriptActivity
(
false
)
mPendingResult
(
NS_OK
)
mActive
(
CONTEXT_INACTIVE
)
mLastStateChange
(
PR_Now
(
)
)
{
MOZ_COUNT_CTOR_INHERITED
(
XPCJSContext
CycleCollectedJSContext
)
;
MOZ_ASSERT
(
mWatchdogManager
)
;
+
+
sInstanceCount
;
mWatchdogManager
-
>
RegisterContext
(
this
)
;
}
XPCJSContext
*
XPCJSContext
:
:
Get
(
)
{
nsXPConnect
*
xpc
=
static_cast
<
nsXPConnect
*
>
(
nsXPConnect
:
:
XPConnect
(
)
)
;
return
xpc
?
xpc
-
>
GetContext
(
)
:
nullptr
;
}
#
ifdef
XP_WIN
static
size_t
GetWindowsStackSize
(
)
{
const
uint8_t
*
stackTop
;
#
ifdef
_WIN64
PNT_TIB64
pTib
=
reinterpret_cast
<
PNT_TIB64
>
(
NtCurrentTeb
(
)
)
;
stackTop
=
reinterpret_cast
<
const
uint8_t
*
>
(
pTib
-
>
StackBase
)
;
#
else
PNT_TIB
pTib
=
reinterpret_cast
<
PNT_TIB
>
(
NtCurrentTeb
(
)
)
;
stackTop
=
reinterpret_cast
<
const
uint8_t
*
>
(
pTib
-
>
StackBase
)
;
#
endif
MEMORY_BASIC_INFORMATION
mbi
;
if
(
!
VirtualQuery
(
&
mbi
&
mbi
sizeof
(
mbi
)
)
)
{
MOZ_CRASH
(
"
VirtualQuery
failed
"
)
;
}
const
uint8_t
*
stackBottom
=
reinterpret_cast
<
const
uint8_t
*
>
(
mbi
.
AllocationBase
)
;
size_t
stackSize
=
size_t
(
stackTop
-
stackBottom
)
;
MOZ_RELEASE_ASSERT
(
stackSize
>
=
1
*
1024
*
1024
)
;
MOZ_RELEASE_ASSERT
(
stackSize
<
=
32
*
1024
*
1024
)
;
return
stackSize
-
10
*
sizeof
(
uintptr_t
)
*
1024
;
}
#
endif
XPCJSRuntime
*
XPCJSContext
:
:
Runtime
(
)
const
{
return
static_cast
<
XPCJSRuntime
*
>
(
CycleCollectedJSContext
:
:
Runtime
(
)
)
;
}
CycleCollectedJSRuntime
*
XPCJSContext
:
:
CreateRuntime
(
JSContext
*
aCx
)
{
return
new
XPCJSRuntime
(
aCx
)
;
}
nsresult
XPCJSContext
:
:
Initialize
(
)
{
nsresult
rv
=
CycleCollectedJSContext
:
:
Initialize
(
nullptr
JS
:
:
DefaultHeapMaxBytes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
Context
(
)
)
;
JSContext
*
cx
=
Context
(
)
;
const
size_t
kSystemCodeBuffer
=
10
*
1024
;
const
size_t
kDefaultStackQuota
=
128
*
sizeof
(
size_t
)
*
1024
;
#
if
defined
(
XP_MACOSX
)
|
|
defined
(
DARWIN
)
const
size_t
kUncappedStackQuota
=
7
*
1024
*
1024
;
const
size_t
kTrustedScriptBuffer
=
180
*
1024
;
#
elif
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
const
size_t
kStackQuotaMax
=
8
*
1024
*
1024
;
#
if
defined
(
MOZ_ASAN
)
|
|
defined
(
DEBUG
)
const
size_t
kStackQuotaMin
=
2
*
kDefaultStackQuota
;
#
else
const
size_t
kStackQuotaMin
=
kDefaultStackQuota
;
#
endif
const
size_t
kStackSafeMargin
=
128
*
1024
;
struct
rlimit
rlim
;
const
size_t
kUncappedStackQuota
=
getrlimit
(
RLIMIT_STACK
&
rlim
)
=
=
0
?
std
:
:
max
(
std
:
:
min
(
size_t
(
rlim
.
rlim_cur
-
kStackSafeMargin
)
kStackQuotaMax
-
kStackSafeMargin
)
kStackQuotaMin
)
:
kStackQuotaMin
;
#
if
defined
(
MOZ_ASAN
)
const
size_t
kTrustedScriptBuffer
=
450
*
1024
;
#
else
const
size_t
kTrustedScriptBuffer
=
180
*
1024
;
#
endif
#
elif
defined
(
XP_WIN
)
const
size_t
kUncappedStackQuota
=
GetWindowsStackSize
(
)
;
#
if
defined
(
MOZ_ASAN
)
const
size_t
kTrustedScriptBuffer
=
450
*
1024
;
#
else
const
size_t
kTrustedScriptBuffer
=
(
sizeof
(
size_t
)
=
=
8
)
?
180
*
1024
:
120
*
1024
;
#
endif
#
elif
defined
(
MOZ_ASAN
)
const
size_t
kUncappedStackQuota
=
2
*
kDefaultStackQuota
;
const
size_t
kTrustedScriptBuffer
=
450
*
1024
;
#
elif
defined
(
ANDROID
)
const
size_t
kUncappedStackQuota
=
kDefaultStackQuota
+
kDefaultStackQuota
/
2
;
const
size_t
kTrustedScriptBuffer
=
sizeof
(
size_t
)
*
12800
;
#
else
#
if
defined
(
DEBUG
)
const
size_t
kUncappedStackQuota
=
2
*
kDefaultStackQuota
;
#
else
const
size_t
kUncappedStackQuota
=
kDefaultStackQuota
;
#
endif
const
size_t
kTrustedScriptBuffer
=
sizeof
(
size_t
)
*
12800
;
#
endif
(
void
)
kDefaultStackQuota
;
const
size_t
kStackQuotaCap
=
StaticPrefs
:
:
javascript_options_main_thread_stack_quota_cap
(
)
;
const
size_t
kStackQuota
=
std
:
:
min
(
kUncappedStackQuota
kStackQuotaCap
)
;
JS_SetNativeStackQuota
(
cx
kStackQuota
kStackQuota
-
kSystemCodeBuffer
kStackQuota
-
kSystemCodeBuffer
-
kTrustedScriptBuffer
)
;
PROFILER_SET_JS_CONTEXT
(
cx
)
;
JS_AddInterruptCallback
(
cx
InterruptCallback
)
;
Runtime
(
)
-
>
Initialize
(
cx
)
;
LoadStartupJSPrefs
(
this
)
;
ReloadPrefsCallback
(
nullptr
this
)
;
Preferences
:
:
RegisterPrefixCallback
(
ReloadPrefsCallback
JS_OPTIONS_DOT_STR
this
)
;
#
ifdef
FUZZING
Preferences
:
:
RegisterCallback
(
ReloadPrefsCallback
"
fuzzing
.
enabled
"
this
)
;
#
endif
if
(
!
nsContentUtils
:
:
InitJSBytecodeMimeType
(
)
)
{
NS_ABORT_OOM
(
0
)
;
}
if
(
!
JS
:
:
InitSelfHostedCode
(
cx
)
)
{
if
(
!
JS_IsExceptionPending
(
cx
)
|
|
JS_IsThrowingOutOfMemory
(
cx
)
)
{
NS_ABORT_OOM
(
0
)
;
}
MOZ_CRASH
(
"
InitSelfHostedCode
failed
"
)
;
}
MOZ_RELEASE_ASSERT
(
Runtime
(
)
-
>
InitializeStrings
(
cx
)
"
InitializeStrings
failed
"
)
;
return
NS_OK
;
}
uint32_t
XPCJSContext
:
:
sInstanceCount
;
StaticAutoPtr
<
WatchdogManager
>
XPCJSContext
:
:
sWatchdogInstance
;
WatchdogManager
*
XPCJSContext
:
:
GetWatchdogManager
(
)
{
if
(
sWatchdogInstance
)
{
return
sWatchdogInstance
;
}
MOZ_ASSERT
(
sInstanceCount
=
=
0
)
;
sWatchdogInstance
=
new
WatchdogManager
(
)
;
return
sWatchdogInstance
;
}
XPCJSContext
*
XPCJSContext
:
:
NewXPCJSContext
(
)
{
XPCJSContext
*
self
=
new
XPCJSContext
(
)
;
nsresult
rv
=
self
-
>
Initialize
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
new
XPCJSContext
failed
to
initialize
.
"
)
;
}
if
(
self
-
>
Context
(
)
)
{
return
self
;
}
MOZ_CRASH
(
"
new
XPCJSContext
failed
to
initialize
.
"
)
;
}
void
XPCJSContext
:
:
BeforeProcessTask
(
bool
aMightBlock
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mSlowScriptCheckpoint
=
mozilla
:
:
TimeStamp
:
:
NowLoRes
(
)
;
mSlowScriptSecondHalf
=
false
;
mSlowScriptActualWait
=
mozilla
:
:
TimeDuration
(
)
;
mTimeoutAccumulated
=
false
;
mExecutedChromeScript
=
false
;
CycleCollectedJSContext
:
:
BeforeProcessTask
(
aMightBlock
)
;
}
void
XPCJSContext
:
:
AfterProcessTask
(
uint32_t
aNewRecursionDepth
)
{
if
(
mSlowScriptSecondHalf
&
&
XRE_IsE10sParentProcess
(
)
)
{
double
hangDuration
=
(
mozilla
:
:
TimeStamp
:
:
NowLoRes
(
)
-
mSlowScriptCheckpoint
+
mSlowScriptActualWait
)
.
ToSeconds
(
)
;
double
limit
=
sChromeSlowScriptTelemetryCutoff
;
if
(
xpc
:
:
IsInAutomation
(
)
)
{
double
prefLimit
=
StaticPrefs
:
:
dom_max_chrome_script_run_time
(
)
;
if
(
prefLimit
>
0
)
{
limit
=
std
:
:
min
(
prefLimit
sChromeSlowScriptTelemetryCutoff
)
;
}
}
if
(
hangDuration
>
limit
)
{
if
(
!
sTelemetryEventEnabled
)
{
sTelemetryEventEnabled
=
true
;
Telemetry
:
:
SetEventRecordingEnabled
(
"
slow_script_warning
"
_ns
true
)
;
}
auto
uriType
=
mExecutedChromeScript
?
"
browser
"
_ns
:
"
content
"
_ns
;
nsCString
durationStr
;
durationStr
.
AppendFloat
(
hangDuration
)
;
auto
extra
=
Some
<
nsTArray
<
Telemetry
:
:
EventExtraEntry
>
>
(
{
Telemetry
:
:
EventExtraEntry
{
"
hang_duration
"
_ns
durationStr
}
Telemetry
:
:
EventExtraEntry
{
"
uri_type
"
_ns
uriType
}
}
)
;
Telemetry
:
:
RecordEvent
(
Telemetry
:
:
EventID
:
:
Slow_script_warning_Shown_Browser
Nothing
(
)
extra
)
;
}
}
mSlowScriptCheckpoint
=
mozilla
:
:
TimeStamp
(
)
;
mSlowScriptSecondHalf
=
false
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsJSContext
:
:
MaybePokeCC
(
)
;
CycleCollectedJSContext
:
:
AfterProcessTask
(
aNewRecursionDepth
)
;
SetPendingException
(
nullptr
)
;
}
bool
XPCJSContext
:
:
IsSystemCaller
(
)
const
{
return
nsContentUtils
:
:
IsSystemCaller
(
Context
(
)
)
;
}
