#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
XPCWrapper
.
h
"
#
include
"
XPCJSMemoryReporter
.
h
"
#
include
"
XPCSelfHostedShmem
.
h
"
#
include
"
WrapperFactory
.
h
"
#
include
"
mozJSModuleLoader
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIDebug2
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
MemoryTelemetry
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
ifdef
FUZZING
#
include
"
mozilla
/
StaticPrefs_fuzzing
.
h
"
#
endif
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_javascript
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
glean
/
JsXpconnectMetrics
.
h
"
#
include
"
mozilla
/
scache
/
StartupCache
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsCycleCollectionNoteRootCallback
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
ContextOptions
.
h
"
#
include
"
js
/
experimental
/
LoggingInterface
.
h
"
#
include
"
js
/
HelperThreadAPI
.
h
"
#
include
"
js
/
Initialization
.
h
"
#
include
"
js
/
MemoryMetrics
.
h
"
#
include
"
js
/
Prefs
.
h
"
#
include
"
js
/
WasmFeatures
.
h
"
#
include
"
fmt
/
format
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
mozilla
/
dom
/
WakeLockBinding
.
h
"
#
include
"
mozilla
/
extensions
/
WebExtensionPolicy
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ProcessHangMonitor
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
SystemPrincipal
.
h
"
#
include
"
mozilla
/
TaskController
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
AccessCheck
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsAboutProtocolUtils
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
ExpandedPrincipal
.
h
"
#
if
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
#
include
<
algorithm
>
#
include
<
sys
/
resource
.
h
>
#
endif
#
ifdef
XP_WIN
#
include
<
algorithm
>
#
include
<
windows
.
h
>
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
xpc
;
using
namespace
JS
;
#
if
!
defined
(
PTHREAD_STACK_MIN
)
#
define
PTHREAD_STACK_MIN
0
#
endif
static
void
WatchdogMain
(
void
*
arg
)
;
class
Watchdog
;
class
WatchdogManager
;
class
MOZ_RAII
AutoLockWatchdog
final
{
Watchdog
*
const
mWatchdog
;
public
:
explicit
AutoLockWatchdog
(
Watchdog
*
aWatchdog
)
;
~
AutoLockWatchdog
(
)
;
}
;
class
Watchdog
{
public
:
explicit
Watchdog
(
WatchdogManager
*
aManager
)
:
mManager
(
aManager
)
mLock
(
nullptr
)
mWakeup
(
nullptr
)
mThread
(
nullptr
)
mHibernating
(
false
)
mInitialized
(
false
)
mShuttingDown
(
false
)
mMinScriptRunTimeSeconds
(
1
)
{
}
~
Watchdog
(
)
{
MOZ_ASSERT
(
!
Initialized
(
)
)
;
}
WatchdogManager
*
Manager
(
)
{
return
mManager
;
}
bool
Initialized
(
)
{
return
mInitialized
;
}
bool
ShuttingDown
(
)
{
return
mShuttingDown
;
}
PRLock
*
GetLock
(
)
{
return
mLock
;
}
bool
Hibernating
(
)
{
return
mHibernating
;
}
void
WakeUp
(
)
{
MOZ_ASSERT
(
Initialized
(
)
)
;
MOZ_ASSERT
(
Hibernating
(
)
)
;
mHibernating
=
false
;
PR_NotifyCondVar
(
mWakeup
)
;
}
void
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mLock
=
PR_NewLock
(
)
;
if
(
!
mLock
)
{
MOZ_CRASH
(
"
PR_NewLock
failed
.
"
)
;
}
mWakeup
=
PR_NewCondVar
(
mLock
)
;
if
(
!
mWakeup
)
{
MOZ_CRASH
(
"
PR_NewCondVar
failed
.
"
)
;
}
{
nsCOMPtr
<
nsIDebug2
>
dbg
=
do_GetService
(
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
)
;
Unused
<
<
dbg
;
}
{
AutoLockWatchdog
lock
(
this
)
;
size_t
watchdogStackSize
=
PTHREAD_STACK_MIN
;
watchdogStackSize
=
std
:
:
max
<
size_t
>
(
32
*
1024
watchdogStackSize
)
;
mThread
=
PR_CreateThread
(
PR_USER_THREAD
WatchdogMain
this
PR_PRIORITY_NORMAL
PR_GLOBAL_THREAD
PR_JOINABLE_THREAD
watchdogStackSize
)
;
if
(
!
mThread
)
{
MOZ_CRASH
(
"
PR_CreateThread
failed
!
"
)
;
}
mInitialized
=
true
;
}
}
void
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
Initialized
(
)
)
;
{
AutoLockWatchdog
lock
(
this
)
;
mShuttingDown
=
true
;
PR_NotifyCondVar
(
mWakeup
)
;
}
PR_JoinThread
(
mThread
)
;
MOZ_ASSERT
(
!
mShuttingDown
)
;
mThread
=
nullptr
;
PR_DestroyCondVar
(
mWakeup
)
;
mWakeup
=
nullptr
;
PR_DestroyLock
(
mLock
)
;
mLock
=
nullptr
;
mInitialized
=
false
;
}
void
SetMinScriptRunTimeSeconds
(
int32_t
seconds
)
{
MOZ_ASSERT
(
seconds
>
0
)
;
mMinScriptRunTimeSeconds
=
seconds
;
}
void
Hibernate
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mHibernating
=
true
;
Sleep
(
PR_INTERVAL_NO_TIMEOUT
)
;
}
void
Sleep
(
PRIntervalTime
timeout
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
AUTO_PROFILER_THREAD_SLEEP
;
MOZ_ALWAYS_TRUE
(
PR_WaitCondVar
(
mWakeup
timeout
)
=
=
PR_SUCCESS
)
;
}
void
Finished
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mShuttingDown
=
false
;
}
int32_t
MinScriptRunTimeSeconds
(
)
{
return
mMinScriptRunTimeSeconds
;
}
private
:
WatchdogManager
*
mManager
;
PRLock
*
mLock
;
PRCondVar
*
mWakeup
;
PRThread
*
mThread
;
bool
mHibernating
;
bool
mInitialized
;
bool
mShuttingDown
;
mozilla
:
:
Atomic
<
int32_t
>
mMinScriptRunTimeSeconds
;
}
;
#
define
PREF_MAX_SCRIPT_RUN_TIME_CONTENT
"
dom
.
max_script_run_time
"
#
define
PREF_MAX_SCRIPT_RUN_TIME_CHROME
"
dom
.
max_chrome_script_run_time
"
#
define
PREF_MAX_SCRIPT_RUN_TIME_EXT_CONTENT
\
"
dom
.
max_ext_content_script_run_time
"
static
const
char
*
gCallbackPrefs
[
]
=
{
"
dom
.
use_watchdog
"
PREF_MAX_SCRIPT_RUN_TIME_CONTENT
PREF_MAX_SCRIPT_RUN_TIME_CHROME
PREF_MAX_SCRIPT_RUN_TIME_EXT_CONTENT
nullptr
}
;
class
WatchdogManager
{
public
:
explicit
WatchdogManager
(
)
{
PodArrayZero
(
mTimestamps
)
;
Preferences
:
:
RegisterCallbacks
(
PrefsChanged
gCallbackPrefs
this
)
;
}
virtual
~
WatchdogManager
(
)
{
MOZ_ASSERT
(
!
mWatchdog
)
;
}
private
:
static
void
PrefsChanged
(
const
char
*
aPref
void
*
aSelf
)
{
static_cast
<
WatchdogManager
*
>
(
aSelf
)
-
>
RefreshWatchdog
(
)
;
}
public
:
void
Shutdown
(
)
{
Preferences
:
:
UnregisterCallbacks
(
PrefsChanged
gCallbackPrefs
this
)
;
}
void
RegisterContext
(
XPCJSContext
*
aContext
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AutoLockWatchdog
lock
(
mWatchdog
.
get
(
)
)
;
if
(
aContext
-
>
mActive
=
=
XPCJSContext
:
:
CONTEXT_ACTIVE
)
{
mActiveContexts
.
insertBack
(
aContext
)
;
}
else
{
mInactiveContexts
.
insertBack
(
aContext
)
;
}
RefreshWatchdog
(
)
;
}
void
UnregisterContext
(
XPCJSContext
*
aContext
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AutoLockWatchdog
lock
(
mWatchdog
.
get
(
)
)
;
aContext
-
>
LinkedListElement
<
XPCJSContext
>
:
:
remove
(
)
;
#
ifdef
DEBUG
if
(
mActiveContexts
.
isEmpty
(
)
&
&
mInactiveContexts
.
isEmpty
(
)
)
{
MOZ_ASSERT
(
!
mWatchdog
)
;
}
#
endif
}
void
RecordContextActivity
(
XPCJSContext
*
aContext
bool
active
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AutoLockWatchdog
lock
(
mWatchdog
.
get
(
)
)
;
aContext
-
>
mLastStateChange
=
PR_Now
(
)
;
aContext
-
>
mActive
=
active
?
XPCJSContext
:
:
CONTEXT_ACTIVE
:
XPCJSContext
:
:
CONTEXT_INACTIVE
;
UpdateContextLists
(
aContext
)
;
if
(
active
&
&
mWatchdog
&
&
mWatchdog
-
>
Hibernating
(
)
)
{
mWatchdog
-
>
WakeUp
(
)
;
}
}
bool
IsAnyContextActive
(
)
{
return
!
mActiveContexts
.
isEmpty
(
)
;
}
PRTime
TimeSinceLastActiveContext
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
PR_ASSERT_CURRENT_THREAD_OWNS_LOCK
(
mWatchdog
-
>
GetLock
(
)
)
;
MOZ_ASSERT
(
mActiveContexts
.
isEmpty
(
)
)
;
MOZ_ASSERT
(
!
mInactiveContexts
.
isEmpty
(
)
)
;
return
PR_Now
(
)
-
mInactiveContexts
.
getLast
(
)
-
>
mLastStateChange
;
}
void
RecordTimestamp
(
WatchdogTimestampCategory
aCategory
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
PR_ASSERT_CURRENT_THREAD_OWNS_LOCK
(
mWatchdog
-
>
GetLock
(
)
)
;
MOZ_ASSERT
(
aCategory
!
=
TimestampContextStateChange
"
Use
RecordContextActivity
to
update
this
"
)
;
mTimestamps
[
aCategory
]
=
PR_Now
(
)
;
}
PRTime
GetContextTimestamp
(
XPCJSContext
*
aContext
const
AutoLockWatchdog
&
aProofOfLock
)
{
return
aContext
-
>
mLastStateChange
;
}
PRTime
GetTimestamp
(
WatchdogTimestampCategory
aCategory
const
AutoLockWatchdog
&
aProofOfLock
)
{
MOZ_ASSERT
(
aCategory
!
=
TimestampContextStateChange
"
Use
GetContextTimestamp
to
retrieve
this
"
)
;
return
mTimestamps
[
aCategory
]
;
}
Watchdog
*
GetWatchdog
(
)
{
return
mWatchdog
.
get
(
)
;
}
void
RefreshWatchdog
(
)
{
bool
wantWatchdog
=
Preferences
:
:
GetBool
(
"
dom
.
use_watchdog
"
true
)
;
if
(
wantWatchdog
!
=
!
!
mWatchdog
)
{
if
(
wantWatchdog
)
{
StartWatchdog
(
)
;
}
else
{
StopWatchdog
(
)
;
}
}
if
(
mWatchdog
)
{
int32_t
contentTime
=
StaticPrefs
:
:
dom_max_script_run_time
(
)
;
if
(
contentTime
<
=
0
)
{
contentTime
=
INT32_MAX
;
}
int32_t
chromeTime
=
StaticPrefs
:
:
dom_max_chrome_script_run_time
(
)
;
if
(
chromeTime
<
=
0
)
{
chromeTime
=
INT32_MAX
;
}
int32_t
extTime
=
StaticPrefs
:
:
dom_max_ext_content_script_run_time
(
)
;
if
(
extTime
<
=
0
)
{
extTime
=
INT32_MAX
;
}
mWatchdog
-
>
SetMinScriptRunTimeSeconds
(
std
:
:
min
(
{
contentTime
chromeTime
extTime
}
)
)
;
}
}
void
StartWatchdog
(
)
{
MOZ_ASSERT
(
!
mWatchdog
)
;
mWatchdog
=
mozilla
:
:
MakeUnique
<
Watchdog
>
(
this
)
;
mWatchdog
-
>
Init
(
)
;
}
void
StopWatchdog
(
)
{
MOZ_ASSERT
(
mWatchdog
)
;
mWatchdog
-
>
Shutdown
(
)
;
mWatchdog
=
nullptr
;
}
template
<
class
Callback
>
void
ForAllActiveContexts
(
Callback
&
&
aCallback
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
PR_ASSERT_CURRENT_THREAD_OWNS_LOCK
(
mWatchdog
-
>
GetLock
(
)
)
;
for
(
auto
*
context
=
mActiveContexts
.
getFirst
(
)
;
context
;
context
=
context
-
>
LinkedListElement
<
XPCJSContext
>
:
:
getNext
(
)
)
{
if
(
!
aCallback
(
context
)
)
{
return
;
}
}
}
private
:
void
UpdateContextLists
(
XPCJSContext
*
aContext
)
{
aContext
-
>
LinkedListElement
<
XPCJSContext
>
:
:
remove
(
)
;
auto
&
list
=
aContext
-
>
mActive
=
=
XPCJSContext
:
:
CONTEXT_ACTIVE
?
mActiveContexts
:
mInactiveContexts
;
MOZ_ASSERT_IF
(
!
list
.
isEmpty
(
)
list
.
getLast
(
)
-
>
mLastStateChange
<
aContext
-
>
mLastStateChange
)
;
list
.
insertBack
(
aContext
)
;
}
LinkedList
<
XPCJSContext
>
mActiveContexts
;
LinkedList
<
XPCJSContext
>
mInactiveContexts
;
mozilla
:
:
UniquePtr
<
Watchdog
>
mWatchdog
;
PRTime
mTimestamps
[
kWatchdogTimestampCategoryCount
-
1
]
;
}
;
AutoLockWatchdog
:
:
AutoLockWatchdog
(
Watchdog
*
aWatchdog
)
:
mWatchdog
(
aWatchdog
)
{
if
(
mWatchdog
)
{
PR_Lock
(
mWatchdog
-
>
GetLock
(
)
)
;
}
}
AutoLockWatchdog
:
:
~
AutoLockWatchdog
(
)
{
if
(
mWatchdog
)
{
PR_Unlock
(
mWatchdog
-
>
GetLock
(
)
)
;
}
}
static
void
WatchdogMain
(
void
*
arg
)
{
AUTO_PROFILER_REGISTER_THREAD
(
"
JS
Watchdog
"
)
;
Unused
<
<
NS_GetCurrentThread
(
)
;
NS_SetCurrentThreadName
(
"
JS
Watchdog
"
)
;
Watchdog
*
self
=
static_cast
<
Watchdog
*
>
(
arg
)
;
WatchdogManager
*
manager
=
self
-
>
Manager
(
)
;
AutoLockWatchdog
lock
(
self
)
;
MOZ_ASSERT
(
self
-
>
Initialized
(
)
)
;
while
(
!
self
-
>
ShuttingDown
(
)
)
{
if
(
manager
-
>
IsAnyContextActive
(
)
|
|
manager
-
>
TimeSinceLastActiveContext
(
)
<
=
PRTime
(
2
*
PR_USEC_PER_SEC
)
)
{
self
-
>
Sleep
(
PR_TicksPerSecond
(
)
)
;
}
else
{
manager
-
>
RecordTimestamp
(
TimestampWatchdogHibernateStart
)
;
self
-
>
Hibernate
(
)
;
manager
-
>
RecordTimestamp
(
TimestampWatchdogHibernateStop
)
;
}
manager
-
>
RecordTimestamp
(
TimestampWatchdogWakeup
)
;
if
(
!
self
-
>
ShuttingDown
(
)
&
&
manager
-
>
IsAnyContextActive
(
)
)
{
bool
debuggerAttached
=
false
;
nsCOMPtr
<
nsIDebug2
>
dbg
=
do_GetService
(
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
)
;
if
(
dbg
)
{
dbg
-
>
GetIsDebuggerAttached
(
&
debuggerAttached
)
;
}
if
(
debuggerAttached
)
{
continue
;
}
PRTime
usecs
=
self
-
>
MinScriptRunTimeSeconds
(
)
*
PR_USEC_PER_SEC
/
2
;
manager
-
>
ForAllActiveContexts
(
[
usecs
manager
&
lock
]
(
XPCJSContext
*
aContext
)
-
>
bool
{
auto
timediff
=
PR_Now
(
)
-
manager
-
>
GetContextTimestamp
(
aContext
lock
)
;
if
(
timediff
>
usecs
)
{
JS_RequestInterruptCallback
(
aContext
-
>
Context
(
)
)
;
return
true
;
}
return
false
;
}
)
;
}
}
self
-
>
Finished
(
)
;
}
PRTime
XPCJSContext
:
:
GetWatchdogTimestamp
(
WatchdogTimestampCategory
aCategory
)
{
AutoLockWatchdog
lock
(
mWatchdogManager
-
>
GetWatchdog
(
)
)
;
return
aCategory
=
=
TimestampContextStateChange
?
mWatchdogManager
-
>
GetContextTimestamp
(
this
lock
)
:
mWatchdogManager
-
>
GetTimestamp
(
aCategory
lock
)
;
}
bool
XPCJSContext
:
:
RecordScriptActivity
(
bool
aActive
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
XPCJSContext
*
xpccx
=
XPCJSContext
:
:
Get
(
)
;
if
(
!
xpccx
)
{
MOZ_ASSERT
(
!
aActive
)
;
return
false
;
}
bool
oldValue
=
xpccx
-
>
SetHasScriptActivity
(
aActive
)
;
if
(
aActive
=
=
oldValue
)
{
return
oldValue
;
}
if
(
!
aActive
)
{
ProcessHangMonitor
:
:
ClearHang
(
)
;
}
xpccx
-
>
mWatchdogManager
-
>
RecordContextActivity
(
xpccx
aActive
)
;
return
oldValue
;
}
AutoScriptActivity
:
:
AutoScriptActivity
(
bool
aActive
)
:
mActive
(
aActive
)
mOldValue
(
XPCJSContext
:
:
RecordScriptActivity
(
aActive
)
)
{
}
AutoScriptActivity
:
:
~
AutoScriptActivity
(
)
{
MOZ_ALWAYS_TRUE
(
mActive
=
=
XPCJSContext
:
:
RecordScriptActivity
(
mOldValue
)
)
;
}
static
const
double
sChromeSlowScriptTelemetryCutoff
(
10
.
0
)
;
bool
XPCJSContext
:
:
InterruptCallback
(
JSContext
*
cx
)
{
XPCJSContext
*
self
=
XPCJSContext
:
:
Get
(
)
;
PROFILER_JS_INTERRUPT_CALLBACK
(
)
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
nsDependentCString
filename
(
"
unknown
file
"
)
;
JS
:
:
AutoFilename
scriptFilename
;
if
(
JS
:
:
DescribeScriptedCaller
(
&
scriptFilename
cx
)
)
{
if
(
const
char
*
file
=
scriptFilename
.
get
(
)
)
{
filename
.
Assign
(
file
strlen
(
file
)
)
;
}
PROFILER_MARKER_TEXT
(
"
JS
:
:
InterruptCallback
"
JS
{
}
filename
)
;
}
}
if
(
self
-
>
mSlowScriptCheckpoint
.
IsNull
(
)
)
{
self
-
>
mSlowScriptCheckpoint
=
TimeStamp
:
:
NowLoRes
(
)
;
self
-
>
mSlowScriptSecondHalf
=
false
;
self
-
>
mSlowScriptActualWait
=
mozilla
:
:
TimeDuration
(
)
;
self
-
>
mTimeoutAccumulated
=
false
;
self
-
>
mExecutedChromeScript
=
false
;
return
true
;
}
if
(
!
nsContentUtils
:
:
IsInitialized
(
)
)
{
return
true
;
}
TimeStamp
now
=
TimeStamp
:
:
NowLoRes
(
)
;
TimeDuration
duration
=
now
-
self
-
>
mSlowScriptCheckpoint
;
int32_t
limit
;
nsString
addonId
;
const
char
*
prefName
;
auto
principal
=
BasePrincipal
:
:
Cast
(
nsContentUtils
:
:
SubjectPrincipal
(
cx
)
)
;
bool
chrome
=
principal
-
>
Is
<
SystemPrincipal
>
(
)
;
if
(
chrome
)
{
prefName
=
PREF_MAX_SCRIPT_RUN_TIME_CHROME
;
limit
=
StaticPrefs
:
:
dom_max_chrome_script_run_time
(
)
;
self
-
>
mExecutedChromeScript
=
true
;
}
else
if
(
auto
policy
=
principal
-
>
ContentScriptAddonPolicy
(
)
)
{
policy
-
>
GetId
(
addonId
)
;
prefName
=
PREF_MAX_SCRIPT_RUN_TIME_EXT_CONTENT
;
limit
=
StaticPrefs
:
:
dom_max_ext_content_script_run_time
(
)
;
}
else
{
prefName
=
PREF_MAX_SCRIPT_RUN_TIME_CONTENT
;
limit
=
StaticPrefs
:
:
dom_max_script_run_time
(
)
;
}
if
(
limit
=
=
0
&
&
chrome
&
&
duration
.
ToSeconds
(
)
>
sChromeSlowScriptTelemetryCutoff
/
2
.
0
)
{
self
-
>
mSlowScriptSecondHalf
=
true
;
return
true
;
}
if
(
limit
=
=
0
|
|
duration
.
ToSeconds
(
)
<
limit
/
2
.
0
)
{
return
true
;
}
self
-
>
mSlowScriptCheckpoint
=
now
;
self
-
>
mSlowScriptActualWait
+
=
duration
;
if
(
!
self
-
>
mSlowScriptSecondHalf
)
{
self
-
>
mSlowScriptSecondHalf
=
true
;
return
true
;
}
if
(
XRE_IsContentProcess
(
)
&
&
StaticPrefs
:
:
dom_max_script_run_time_require_critical_input
(
)
)
{
ContentChild
*
contentChild
=
ContentChild
:
:
GetSingleton
(
)
;
mozilla
:
:
ipc
:
:
MessageChannel
*
channel
=
contentChild
?
contentChild
-
>
GetIPCChannel
(
)
:
nullptr
;
if
(
channel
)
{
bool
foundInputEvent
=
false
;
channel
-
>
PeekMessages
(
[
&
foundInputEvent
]
(
const
IPC
:
:
Message
&
aMsg
)
-
>
bool
{
if
(
nsContentUtils
:
:
IsMessageCriticalInputEvent
(
aMsg
)
)
{
foundInputEvent
=
true
;
return
false
;
}
return
true
;
}
)
;
if
(
!
foundInputEvent
)
{
return
true
;
}
}
}
if
(
chrome
&
&
limit
=
=
2
&
&
xpc
:
:
IsInAutomation
(
)
)
{
return
true
;
}
RootedObject
global
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
RefPtr
<
nsGlobalWindowInner
>
win
=
WindowOrNull
(
global
)
;
if
(
!
win
)
{
win
=
SandboxWindowOrNull
(
global
cx
)
;
}
if
(
!
win
)
{
NS_WARNING
(
"
No
active
window
"
)
;
return
true
;
}
if
(
win
-
>
IsDying
(
)
)
{
return
false
;
}
if
(
!
chrome
&
&
!
self
-
>
mTimeoutAccumulated
)
{
TimeDuration
delay
=
self
-
>
mSlowScriptActualWait
-
TimeDuration
:
:
FromSeconds
(
limit
)
;
glean
:
:
slow_script_warning
:
:
notify_delay
.
AccumulateRawDuration
(
delay
)
;
self
-
>
mTimeoutAccumulated
=
true
;
}
nsGlobalWindowInner
:
:
SlowScriptResponse
response
=
win
-
>
ShowSlowScriptDialog
(
cx
addonId
self
-
>
mSlowScriptActualWait
.
ToMilliseconds
(
)
)
;
if
(
response
=
=
nsGlobalWindowInner
:
:
KillSlowScript
)
{
if
(
Preferences
:
:
GetBool
(
"
dom
.
global_stop_script
"
true
)
)
{
xpc
:
:
Scriptability
:
:
Get
(
global
)
.
Block
(
)
;
}
if
(
nsCOMPtr
<
Document
>
doc
=
win
-
>
GetExtantDoc
(
)
)
{
doc
-
>
UnlockAllWakeLocks
(
WakeLockType
:
:
Screen
)
;
}
return
false
;
}
if
(
response
!
=
nsGlobalWindowInner
:
:
ContinueSlowScriptAndKeepNotifying
)
{
self
-
>
mSlowScriptCheckpoint
=
TimeStamp
:
:
NowLoRes
(
)
;
}
if
(
response
=
=
nsGlobalWindowInner
:
:
AlwaysContinueSlowScript
)
{
Preferences
:
:
SetInt
(
prefName
0
)
;
}
return
true
;
}
#
define
JS_OPTIONS_DOT_STR
"
javascript
.
options
.
"
static
mozilla
:
:
Atomic
<
bool
>
sDiscardSystemSource
(
false
)
;
bool
xpc
:
:
ShouldDiscardSystemSource
(
)
{
return
sDiscardSystemSource
;
}
static
mozilla
:
:
Atomic
<
bool
>
sSharedMemoryEnabled
(
false
)
;
static
mozilla
:
:
Atomic
<
bool
>
sStreamsEnabled
(
false
)
;
void
xpc
:
:
SetPrefableRealmOptions
(
JS
:
:
RealmOptions
&
options
)
{
options
.
creationOptions
(
)
.
setSharedMemoryAndAtomicsEnabled
(
sSharedMemoryEnabled
)
.
setCoopAndCoepEnabled
(
StaticPrefs
:
:
browser_tabs_remote_useCrossOriginOpenerPolicy
(
)
&
&
StaticPrefs
:
:
browser_tabs_remote_useCrossOriginEmbedderPolicy
(
)
)
;
}
void
xpc
:
:
SetPrefableCompileOptions
(
JS
:
:
PrefableCompileOptions
&
options
)
{
options
.
setSourcePragmas
(
StaticPrefs
:
:
javascript_options_source_pragmas
(
)
)
.
setImportAttributes
(
StaticPrefs
:
:
javascript_options_experimental_import_attributes
(
)
)
.
setAsmJS
(
StaticPrefs
:
:
javascript_options_asmjs
(
)
)
.
setThrowOnAsmJSValidationFailure
(
StaticPrefs
:
:
javascript_options_throw_on_asmjs_validation_failure
(
)
)
;
}
void
xpc
:
:
SetPrefableContextOptions
(
JS
:
:
ContextOptions
&
options
)
{
options
#
ifdef
FUZZING
.
setFuzzing
(
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
fuzzing
.
enabled
"
)
)
#
endif
.
setWasm
(
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm
"
)
)
.
setWasmForTrustedPrinciples
(
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_trustedprincipals
"
)
)
.
setWasmIon
(
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_optimizingjit
"
)
)
.
setWasmBaseline
(
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_baselinejit
"
)
)
.
setWasmVerbose
(
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
wasm_verbose
"
)
)
.
setAsyncStack
(
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
asyncstack
"
)
)
.
setAsyncStackCaptureDebuggeeOnly
(
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
asyncstack_capture_debuggee_only
"
)
)
;
SetPrefableCompileOptions
(
options
.
compileOptions
(
)
)
;
}
static
bool
sSelfHostedUseSharedMemory
=
false
;
static
void
LoadStartupJSPrefs
(
XPCJSContext
*
xpccx
)
{
JSContext
*
cx
=
xpccx
-
>
Context
(
)
;
bool
useJitForTrustedPrincipals
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
jit_trustedprincipals
"
false
)
;
bool
safeMode
=
false
;
nsCOMPtr
<
nsIXULRuntime
>
xr
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
xr
)
{
xr
-
>
GetInSafeMode
(
&
safeMode
)
;
}
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_BASELINE_INTERPRETER_ENABLE
StaticPrefs
:
:
javascript_options_blinterp_DoNotUseDirectly
(
)
)
;
if
(
safeMode
)
{
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_BASELINE_ENABLE
false
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_ION_ENABLE
false
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_JIT_TRUSTEDPRINCIPALS_ENABLE
false
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_NATIVE_REGEXP_ENABLE
false
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_JIT_HINTS_ENABLE
false
)
;
sSelfHostedUseSharedMemory
=
false
;
}
else
{
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_BASELINE_ENABLE
StaticPrefs
:
:
javascript_options_baselinejit_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_ION_ENABLE
StaticPrefs
:
:
javascript_options_ion_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_JIT_TRUSTEDPRINCIPALS_ENABLE
useJitForTrustedPrincipals
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_NATIVE_REGEXP_ENABLE
StaticPrefs
:
:
javascript_options_native_regexp_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_JIT_HINTS_ENABLE
XRE_IsContentProcess
(
)
?
StaticPrefs
:
:
javascript_options_jithints_DoNotUseDirectly
(
)
:
false
)
;
sSelfHostedUseSharedMemory
=
StaticPrefs
:
:
javascript_options_self_hosted_use_shared_memory_DoNotUseDirectly
(
)
;
}
#
ifdef
NIGHTLY_BUILD
JS_SetOffthreadBaselineCompilationEnabled
(
cx
StaticPrefs
:
:
javascript_options_experimental_baselinejit_offthread_compilation_DoNotUseDirectly
(
)
)
;
#
endif
JS_SetOffthreadIonCompilationEnabled
(
cx
StaticPrefs
:
:
javascript_options_ion_offthread_compilation_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_BASELINE_INTERPRETER_WARMUP_TRIGGER
StaticPrefs
:
:
javascript_options_blinterp_threshold_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_BASELINE_WARMUP_TRIGGER
StaticPrefs
:
:
javascript_options_baselinejit_threshold_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_ION_NORMAL_WARMUP_TRIGGER
StaticPrefs
:
:
javascript_options_ion_threshold_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_ION_FREQUENT_BAILOUT_THRESHOLD
StaticPrefs
:
:
javascript_options_ion_frequent_bailout_threshold_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_INLINING_BYTECODE_MAX_LENGTH
StaticPrefs
:
:
javascript_options_inlining_bytecode_max_length_DoNotUseDirectly
(
)
)
;
#
ifdef
DEBUG
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_FULL_DEBUG_CHECKS
StaticPrefs
:
:
javascript_options_jit_full_debug_checks_DoNotUseDirectly
(
)
)
;
#
endif
#
if
!
defined
(
JS_CODEGEN_MIPS64
)
&
&
!
defined
(
JS_CODEGEN_RISCV64
)
&
&
\
!
defined
(
JS_CODEGEN_LOONG64
)
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_SPECTRE_INDEX_MASKING
StaticPrefs
:
:
javascript_options_spectre_index_masking_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_SPECTRE_OBJECT_MITIGATIONS
StaticPrefs
:
:
javascript_options_spectre_object_mitigations_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_SPECTRE_STRING_MITIGATIONS
StaticPrefs
:
:
javascript_options_spectre_string_mitigations_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_SPECTRE_VALUE_MASKING
StaticPrefs
:
:
javascript_options_spectre_value_masking_DoNotUseDirectly
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_SPECTRE_JIT_TO_CXX_CALLS
StaticPrefs
:
:
javascript_options_spectre_jit_to_cxx_calls_DoNotUseDirectly
(
)
)
;
#
endif
bool
writeProtectCode
=
true
;
if
(
XRE_IsContentProcess
(
)
)
{
writeProtectCode
=
StaticPrefs
:
:
javascript_options_content_process_write_protect_code
(
)
;
}
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_WRITE_PROTECT_CODE
writeProtectCode
)
;
}
static
void
ReloadPrefsCallback
(
const
char
*
pref
void
*
aXpccx
)
{
SET_NON_STARTUP_JS_PREFS_FROM_BROWSER_PREFS
;
auto
xpccx
=
static_cast
<
XPCJSContext
*
>
(
aXpccx
)
;
JSContext
*
cx
=
xpccx
-
>
Context
(
)
;
sDiscardSystemSource
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
discardSystemSource
"
)
;
sSharedMemoryEnabled
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
shared_memory
"
)
;
sStreamsEnabled
=
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
streams
"
)
;
#
ifdef
JS_GC_ZEAL
int32_t
zeal
=
Preferences
:
:
GetInt
(
JS_OPTIONS_DOT_STR
"
mem
.
gc_zeal
.
mode
"
-
1
)
;
int32_t
zeal_frequency
=
Preferences
:
:
GetInt
(
JS_OPTIONS_DOT_STR
"
mem
.
gc_zeal
.
frequency
"
JS
:
:
BrowserDefaultGCZealFrequency
)
;
if
(
zeal
>
=
0
)
{
JS
:
:
SetGCZeal
(
cx
(
uint8_t
)
zeal
zeal_frequency
)
;
}
#
endif
auto
&
contextOptions
=
JS
:
:
ContextOptionsRef
(
cx
)
;
SetPrefableContextOptions
(
contextOptions
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_REGEXP_DUPLICATE_NAMED_GROUPS
StaticPrefs
:
:
javascript_options_experimental_regexp_duplicate_named_groups
(
)
)
;
JS_SetGlobalJitCompilerOption
(
cx
JSJITCOMPILER_REGEXP_MODIFIERS
StaticPrefs
:
:
javascript_options_experimental_regexp_modifiers
(
)
)
;
contextOptions
.
setThrowOnDebuggeeWouldRun
(
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
throw_on_debuggee_would_run
"
)
)
.
setDumpStackOnDebuggeeWouldRun
(
Preferences
:
:
GetBool
(
JS_OPTIONS_DOT_STR
"
dump_stack_on_debuggee_would_run
"
)
)
;
nsCOMPtr
<
nsIXULRuntime
>
xr
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
xr
)
{
bool
safeMode
=
false
;
xr
-
>
GetInSafeMode
(
&
safeMode
)
;
if
(
safeMode
)
{
contextOptions
.
disableOptionsForSafeMode
(
)
;
}
}
}
XPCJSContext
:
:
~
XPCJSContext
(
)
{
MOZ_COUNT_DTOR_INHERITED
(
XPCJSContext
CycleCollectedJSContext
)
;
MOZ_ASSERT
(
MaybeContext
(
)
)
;
Preferences
:
:
UnregisterPrefixCallback
(
ReloadPrefsCallback
JS_OPTIONS_DOT_STR
this
)
;
#
ifdef
FUZZING
Preferences
:
:
UnregisterCallback
(
ReloadPrefsCallback
"
fuzzing
.
enabled
"
this
)
;
#
endif
SetPendingException
(
nullptr
)
;
if
(
-
-
sInstanceCount
=
=
0
)
{
if
(
mWatchdogManager
-
>
GetWatchdog
(
)
)
{
mWatchdogManager
-
>
StopWatchdog
(
)
;
}
mWatchdogManager
-
>
UnregisterContext
(
this
)
;
mWatchdogManager
-
>
Shutdown
(
)
;
sWatchdogInstance
=
nullptr
;
}
else
{
mWatchdogManager
-
>
UnregisterContext
(
this
)
;
}
if
(
mCallContext
)
{
mCallContext
-
>
SystemIsBeingShutDown
(
)
;
}
PROFILER_CLEAR_JS_CONTEXT
(
)
;
}
XPCJSContext
:
:
XPCJSContext
(
)
:
mCallContext
(
nullptr
)
mAutoRoots
(
nullptr
)
mResolveName
(
JS
:
:
PropertyKey
:
:
Void
(
)
)
mResolvingWrapper
(
nullptr
)
mWatchdogManager
(
GetWatchdogManager
(
)
)
mSlowScriptSecondHalf
(
false
)
mTimeoutAccumulated
(
false
)
mExecutedChromeScript
(
false
)
mHasScriptActivity
(
false
)
mPendingResult
(
NS_OK
)
mActive
(
CONTEXT_INACTIVE
)
mLastStateChange
(
PR_Now
(
)
)
{
MOZ_COUNT_CTOR_INHERITED
(
XPCJSContext
CycleCollectedJSContext
)
;
MOZ_ASSERT
(
mWatchdogManager
)
;
+
+
sInstanceCount
;
mWatchdogManager
-
>
RegisterContext
(
this
)
;
}
XPCJSContext
*
XPCJSContext
:
:
Get
(
)
{
nsXPConnect
*
xpc
=
static_cast
<
nsXPConnect
*
>
(
nsXPConnect
:
:
XPConnect
(
)
)
;
return
xpc
?
xpc
-
>
GetContext
(
)
:
nullptr
;
}
#
ifdef
XP_WIN
static
size_t
GetWindowsStackSize
(
)
{
const
uint8_t
*
stackTop
;
#
ifdef
_WIN64
PNT_TIB64
pTib
=
reinterpret_cast
<
PNT_TIB64
>
(
NtCurrentTeb
(
)
)
;
stackTop
=
reinterpret_cast
<
const
uint8_t
*
>
(
pTib
-
>
StackBase
)
;
#
else
PNT_TIB
pTib
=
reinterpret_cast
<
PNT_TIB
>
(
NtCurrentTeb
(
)
)
;
stackTop
=
reinterpret_cast
<
const
uint8_t
*
>
(
pTib
-
>
StackBase
)
;
#
endif
MEMORY_BASIC_INFORMATION
mbi
;
if
(
!
VirtualQuery
(
&
mbi
&
mbi
sizeof
(
mbi
)
)
)
{
MOZ_CRASH
(
"
VirtualQuery
failed
"
)
;
}
const
uint8_t
*
stackBottom
=
reinterpret_cast
<
const
uint8_t
*
>
(
mbi
.
AllocationBase
)
;
size_t
stackSize
=
size_t
(
stackTop
-
stackBottom
)
;
MOZ_RELEASE_ASSERT
(
stackSize
>
=
1
*
1024
*
1024
)
;
MOZ_RELEASE_ASSERT
(
stackSize
<
=
32
*
1024
*
1024
)
;
return
stackSize
-
10
*
sizeof
(
uintptr_t
)
*
1024
;
}
#
endif
XPCJSRuntime
*
XPCJSContext
:
:
Runtime
(
)
const
{
return
static_cast
<
XPCJSRuntime
*
>
(
CycleCollectedJSContext
:
:
Runtime
(
)
)
;
}
CycleCollectedJSRuntime
*
XPCJSContext
:
:
CreateRuntime
(
JSContext
*
aCx
)
{
return
new
XPCJSRuntime
(
aCx
)
;
}
class
HelperThreadTaskHandler
:
public
Task
{
JS
:
:
HelperThreadTask
*
mTask
;
public
:
explicit
HelperThreadTaskHandler
(
JS
:
:
HelperThreadTask
*
aTask
)
:
Task
(
Kind
:
:
OffMainThreadOnly
EventQueuePriority
:
:
Normal
)
mTask
(
aTask
)
{
}
TaskResult
Run
(
)
override
{
JS
:
:
RunHelperThreadTask
(
mTask
)
;
return
TaskResult
:
:
Complete
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
bool
GetName
(
nsACString
&
aName
)
override
{
const
char
*
taskName
=
JS
:
:
GetHelperThreadTaskName
(
mTask
)
;
aName
.
AssignLiteral
(
taskName
strlen
(
taskName
)
)
;
return
true
;
}
#
endif
private
:
~
HelperThreadTaskHandler
(
)
=
default
;
}
;
static
void
DispatchOffThreadTask
(
JS
:
:
HelperThreadTask
*
aTask
)
{
TaskController
:
:
Get
(
)
-
>
AddTask
(
MakeAndAddRef
<
HelperThreadTaskHandler
>
(
aTask
)
)
;
}
static
constexpr
char
kSelfHostCacheKey
[
]
=
"
js
.
self
-
hosted
"
;
static
bool
CreateSelfHostedSharedMemory
(
JSContext
*
aCx
JS
:
:
SelfHostedCache
aBuf
)
{
if
(
auto
*
sc
=
scache
:
:
StartupCache
:
:
GetSingleton
(
)
)
{
UniqueFreePtr
<
char
[
]
>
copy
(
static_cast
<
char
*
>
(
malloc
(
aBuf
.
LengthBytes
(
)
)
)
)
;
if
(
copy
)
{
memcpy
(
copy
.
get
(
)
aBuf
.
Elements
(
)
aBuf
.
LengthBytes
(
)
)
;
sc
-
>
PutBuffer
(
kSelfHostCacheKey
std
:
:
move
(
copy
)
aBuf
.
LengthBytes
(
)
)
;
}
}
auto
&
shm
=
xpc
:
:
SelfHostedShmem
:
:
GetSingleton
(
)
;
MOZ_RELEASE_ASSERT
(
shm
.
Content
(
)
.
IsEmpty
(
)
)
;
shm
.
InitFromParent
(
aBuf
)
;
return
true
;
}
static
JS
:
:
OpaqueLogger
GetLoggerByName
(
const
char
*
name
)
{
LogModule
*
tmp
=
LogModule
:
:
Get
(
name
)
;
return
static_cast
<
JS
:
:
OpaqueLogger
>
(
tmp
)
;
}
MOZ_FORMAT_PRINTF
(
3
0
)
static
void
LogPrintVA
(
JS
:
:
OpaqueLogger
aLogger
mozilla
:
:
LogLevel
level
const
char
*
aFmt
va_list
ap
)
{
LogModule
*
logmod
=
static_cast
<
LogModule
*
>
(
aLogger
)
;
logmod
-
>
Printv
(
level
aFmt
ap
)
;
}
static
void
LogPrintFMT
(
JS
:
:
OpaqueLogger
aLogger
mozilla
:
:
LogLevel
level
fmt
:
:
string_view
fmt
fmt
:
:
format_args
args
)
{
LogModule
*
logmod
=
static_cast
<
LogModule
*
>
(
aLogger
)
;
logmod
-
>
PrintvFmt
(
level
fmt
args
)
;
}
static
AtomicLogLevel
&
GetLevelRef
(
JS
:
:
OpaqueLogger
aLogger
)
{
LogModule
*
logmod
=
static_cast
<
LogModule
*
>
(
aLogger
)
;
return
logmod
-
>
LevelRef
(
)
;
}
static
JS
:
:
LoggingInterface
loggingInterface
=
{
GetLoggerByName
LogPrintVA
LogPrintFMT
GetLevelRef
}
;
nsresult
XPCJSContext
:
:
Initialize
(
)
{
if
(
StaticPrefs
:
:
javascript_options_external_thread_pool_DoNotUseDirectly
(
)
)
{
size_t
threadCount
=
TaskController
:
:
GetPoolThreadCount
(
)
;
size_t
stackSize
=
TaskController
:
:
GetThreadStackSize
(
)
;
SetHelperThreadTaskCallback
(
&
DispatchOffThreadTask
threadCount
stackSize
)
;
}
if
(
!
JS
:
:
SetLoggingInterface
(
loggingInterface
)
)
{
MOZ_CRASH
(
"
Failed
to
install
logging
interface
"
)
;
}
nsresult
rv
=
CycleCollectedJSContext
:
:
Initialize
(
nullptr
JS
:
:
DefaultHeapMaxBytes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
Context
(
)
)
;
JSContext
*
cx
=
Context
(
)
;
const
size_t
kSystemCodeBuffer
=
10
*
1024
;
const
size_t
kDefaultStackQuota
=
128
*
sizeof
(
size_t
)
*
1024
;
#
if
defined
(
XP_MACOSX
)
|
|
defined
(
DARWIN
)
const
size_t
kUncappedStackQuota
=
7
*
1024
*
1024
;
const
size_t
kTrustedScriptBuffer
=
180
*
1024
;
#
elif
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
const
size_t
kStackQuotaMax
=
8
*
1024
*
1024
;
#
if
defined
(
MOZ_ASAN
)
|
|
defined
(
DEBUG
)
const
size_t
kStackQuotaMin
=
2
*
kDefaultStackQuota
;
#
else
const
size_t
kStackQuotaMin
=
kDefaultStackQuota
;
#
endif
const
size_t
kStackSafeMargin
=
128
*
1024
;
struct
rlimit
rlim
;
const
size_t
kUncappedStackQuota
=
getrlimit
(
RLIMIT_STACK
&
rlim
)
=
=
0
?
std
:
:
clamp
(
size_t
(
rlim
.
rlim_cur
-
kStackSafeMargin
)
kStackQuotaMin
kStackQuotaMax
-
kStackSafeMargin
)
:
kStackQuotaMin
;
#
if
defined
(
MOZ_ASAN
)
const
size_t
kTrustedScriptBuffer
=
450
*
1024
;
#
else
const
size_t
kTrustedScriptBuffer
=
180
*
1024
;
#
endif
#
elif
defined
(
XP_WIN
)
const
size_t
kUncappedStackQuota
=
GetWindowsStackSize
(
)
;
#
if
defined
(
MOZ_ASAN
)
const
size_t
kTrustedScriptBuffer
=
450
*
1024
;
#
else
const
size_t
kTrustedScriptBuffer
=
(
sizeof
(
size_t
)
=
=
8
)
?
180
*
1024
:
120
*
1024
;
#
endif
#
elif
defined
(
MOZ_ASAN
)
const
size_t
kUncappedStackQuota
=
2
*
kDefaultStackQuota
;
const
size_t
kTrustedScriptBuffer
=
450
*
1024
;
#
elif
defined
(
ANDROID
)
const
size_t
kUncappedStackQuota
=
kDefaultStackQuota
+
kDefaultStackQuota
/
2
;
const
size_t
kTrustedScriptBuffer
=
sizeof
(
size_t
)
*
12800
;
#
else
#
if
defined
(
DEBUG
)
const
size_t
kUncappedStackQuota
=
2
*
kDefaultStackQuota
;
#
else
const
size_t
kUncappedStackQuota
=
kDefaultStackQuota
;
#
endif
const
size_t
kTrustedScriptBuffer
=
sizeof
(
size_t
)
*
12800
;
#
endif
(
void
)
kDefaultStackQuota
;
const
size_t
kStackQuotaCap
=
StaticPrefs
:
:
javascript_options_main_thread_stack_quota_cap
(
)
;
const
size_t
kStackQuota
=
std
:
:
min
(
kUncappedStackQuota
kStackQuotaCap
)
;
JS_SetNativeStackQuota
(
cx
kStackQuota
kStackQuota
-
kSystemCodeBuffer
kStackQuota
-
kSystemCodeBuffer
-
kTrustedScriptBuffer
)
;
PROFILER_SET_JS_CONTEXT
(
this
)
;
JS_AddInterruptCallback
(
cx
InterruptCallback
)
;
Runtime
(
)
-
>
Initialize
(
cx
)
;
LoadStartupJSPrefs
(
this
)
;
ReloadPrefsCallback
(
nullptr
this
)
;
Preferences
:
:
RegisterPrefixCallback
(
ReloadPrefsCallback
JS_OPTIONS_DOT_STR
this
)
;
#
ifdef
FUZZING
Preferences
:
:
RegisterCallback
(
ReloadPrefsCallback
"
fuzzing
.
enabled
"
this
)
;
#
endif
if
(
!
nsContentUtils
:
:
InitJSBytecodeMimeType
(
)
)
{
NS_ABORT_OOM
(
0
)
;
}
auto
&
shm
=
xpc
:
:
SelfHostedShmem
:
:
GetSingleton
(
)
;
JS
:
:
SelfHostedWriter
writer
=
nullptr
;
if
(
XRE_IsParentProcess
(
)
&
&
sSelfHostedUseSharedMemory
)
{
if
(
auto
*
sc
=
scache
:
:
StartupCache
:
:
GetSingleton
(
)
)
{
const
char
*
buf
=
nullptr
;
uint32_t
len
=
0
;
if
(
NS_SUCCEEDED
(
sc
-
>
GetBuffer
(
kSelfHostCacheKey
&
buf
&
len
)
)
)
{
shm
.
InitFromParent
(
AsBytes
(
mozilla
:
:
Span
(
buf
len
)
)
)
;
}
}
if
(
shm
.
Content
(
)
.
IsEmpty
(
)
)
{
writer
=
CreateSelfHostedSharedMemory
;
}
}
if
(
!
JS
:
:
InitSelfHostedCode
(
cx
shm
.
Content
(
)
writer
)
)
{
if
(
!
JS_IsExceptionPending
(
cx
)
|
|
JS_IsThrowingOutOfMemory
(
cx
)
)
{
NS_ABORT_OOM
(
0
)
;
}
MOZ_CRASH
(
"
InitSelfHostedCode
failed
"
)
;
}
MOZ_RELEASE_ASSERT
(
Runtime
(
)
-
>
InitializeStrings
(
cx
)
"
InitializeStrings
failed
"
)
;
return
NS_OK
;
}
uint32_t
XPCJSContext
:
:
sInstanceCount
;
StaticAutoPtr
<
WatchdogManager
>
XPCJSContext
:
:
sWatchdogInstance
;
WatchdogManager
*
XPCJSContext
:
:
GetWatchdogManager
(
)
{
if
(
sWatchdogInstance
)
{
return
sWatchdogInstance
;
}
MOZ_ASSERT
(
sInstanceCount
=
=
0
)
;
sWatchdogInstance
=
new
WatchdogManager
(
)
;
return
sWatchdogInstance
;
}
XPCJSContext
*
XPCJSContext
:
:
NewXPCJSContext
(
)
{
XPCJSContext
*
self
=
new
XPCJSContext
(
)
;
nsresult
rv
=
self
-
>
Initialize
(
)
;
if
(
rv
=
=
NS_ERROR_OUT_OF_MEMORY
)
{
mozalloc_handle_oom
(
0
)
;
}
else
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
new
XPCJSContext
failed
to
initialize
.
"
)
;
}
if
(
self
-
>
Context
(
)
)
{
return
self
;
}
MOZ_CRASH
(
"
new
XPCJSContext
failed
to
initialize
.
"
)
;
}
void
XPCJSContext
:
:
BeforeProcessTask
(
bool
aMightBlock
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mSlowScriptCheckpoint
=
mozilla
:
:
TimeStamp
:
:
NowLoRes
(
)
;
mSlowScriptSecondHalf
=
false
;
mSlowScriptActualWait
=
mozilla
:
:
TimeDuration
(
)
;
mTimeoutAccumulated
=
false
;
mExecutedChromeScript
=
false
;
CycleCollectedJSContext
:
:
BeforeProcessTask
(
aMightBlock
)
;
}
void
XPCJSContext
:
:
AfterProcessTask
(
uint32_t
aNewRecursionDepth
)
{
if
(
mSlowScriptSecondHalf
&
&
XRE_IsE10sParentProcess
(
)
)
{
double
hangDuration
=
(
mozilla
:
:
TimeStamp
:
:
NowLoRes
(
)
-
mSlowScriptCheckpoint
+
mSlowScriptActualWait
)
.
ToSeconds
(
)
;
double
limit
=
sChromeSlowScriptTelemetryCutoff
;
if
(
xpc
:
:
IsInAutomation
(
)
)
{
double
prefLimit
=
StaticPrefs
:
:
dom_max_chrome_script_run_time
(
)
;
if
(
prefLimit
>
0
)
{
limit
=
std
:
:
min
(
prefLimit
sChromeSlowScriptTelemetryCutoff
)
;
}
}
if
(
hangDuration
>
limit
)
{
nsCString
durationStr
;
durationStr
.
AppendFloat
(
hangDuration
)
;
glean
:
:
slow_script_warning
:
:
ShownBrowserExtra
extra
=
{
.
hangDuration
=
Some
(
durationStr
)
.
uriType
=
Some
(
mExecutedChromeScript
?
"
browser
"
_ns
:
"
content
"
_ns
)
}
;
glean
:
:
slow_script_warning
:
:
shown_browser
.
Record
(
Some
(
extra
)
)
;
}
}
mSlowScriptCheckpoint
=
mozilla
:
:
TimeStamp
(
)
;
mSlowScriptSecondHalf
=
false
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsJSContext
:
:
MaybePokeCC
(
)
;
CycleCollectedJSContext
:
:
AfterProcessTask
(
aNewRecursionDepth
)
;
if
(
AppShutdown
:
:
GetCurrentShutdownPhase
(
)
=
=
ShutdownPhase
:
:
NotInShutdown
)
{
MemoryTelemetry
:
:
Get
(
)
.
Poke
(
)
;
}
SetPendingException
(
nullptr
)
;
}
void
XPCJSContext
:
:
MaybePokeGC
(
)
{
nsJSContext
:
:
MaybePokeGC
(
)
;
}
bool
XPCJSContext
:
:
IsSystemCaller
(
)
const
{
return
nsContentUtils
:
:
IsSystemCaller
(
Context
(
)
)
;
}
