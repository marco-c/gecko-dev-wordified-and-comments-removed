#
include
"
nsAutoPtr
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
xpcpublic
.
h
"
using
namespace
JS
;
void
XPCStringConvert
:
:
FinalizeLiteral
(
const
JSStringFinalizer
*
fin
char16_t
*
chars
)
{
}
const
JSStringFinalizer
XPCStringConvert
:
:
sLiteralFinalizer
=
{
XPCStringConvert
:
:
FinalizeLiteral
}
;
void
XPCStringConvert
:
:
FinalizeDOMString
(
const
JSStringFinalizer
*
fin
char16_t
*
chars
)
{
nsStringBuffer
*
buf
=
nsStringBuffer
:
:
FromData
(
chars
)
;
buf
-
>
Release
(
)
;
}
const
JSStringFinalizer
XPCStringConvert
:
:
sDOMStringFinalizer
=
{
XPCStringConvert
:
:
FinalizeDOMString
}
;
void
XPCStringConvert
:
:
FinalizeDynamicAtom
(
const
JSStringFinalizer
*
fin
char16_t
*
chars
)
{
nsDynamicAtom
*
atom
=
nsDynamicAtom
:
:
FromChars
(
chars
)
;
static_cast
<
nsAtom
*
>
(
atom
)
-
>
Release
(
)
;
}
const
JSStringFinalizer
XPCStringConvert
:
:
sDynamicAtomFinalizer
=
{
XPCStringConvert
:
:
FinalizeDynamicAtom
}
;
bool
XPCStringConvert
:
:
ReadableToJSVal
(
JSContext
*
cx
const
nsAString
&
readable
nsStringBuffer
*
*
sharedBuffer
MutableHandleValue
vp
)
{
*
sharedBuffer
=
nullptr
;
uint32_t
length
=
readable
.
Length
(
)
;
if
(
readable
.
IsLiteral
(
)
)
{
return
StringLiteralToJSVal
(
cx
readable
.
BeginReading
(
)
length
vp
)
;
}
nsStringBuffer
*
buf
=
nsStringBuffer
:
:
FromString
(
readable
)
;
if
(
buf
)
{
bool
shared
;
if
(
!
StringBufferToJSVal
(
cx
buf
length
vp
&
shared
)
)
return
false
;
if
(
shared
)
*
sharedBuffer
=
buf
;
return
true
;
}
JSString
*
str
=
JS_NewUCStringCopyN
(
cx
readable
.
BeginReading
(
)
length
)
;
if
(
!
str
)
return
false
;
vp
.
setString
(
str
)
;
return
true
;
}
namespace
xpc
{
bool
NonVoidStringToJsval
(
JSContext
*
cx
nsAString
&
str
MutableHandleValue
rval
)
{
nsStringBuffer
*
sharedBuffer
;
if
(
!
XPCStringConvert
:
:
ReadableToJSVal
(
cx
str
&
sharedBuffer
rval
)
)
return
false
;
if
(
sharedBuffer
)
{
str
.
ForgetSharedBuffer
(
)
;
}
return
true
;
}
}
