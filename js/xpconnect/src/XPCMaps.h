#
ifndef
xpcmaps_h___
#
define
xpcmaps_h___
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
js
/
GCHashTable
.
h
"
class
JSObject2WrappedJSMap
{
using
Map
=
js
:
:
HashMap
<
JS
:
:
Heap
<
JSObject
*
>
nsXPCWrappedJS
*
js
:
:
MovableCellHasher
<
JS
:
:
Heap
<
JSObject
*
>
>
InfallibleAllocPolicy
>
;
public
:
static
JSObject2WrappedJSMap
*
newMap
(
int
length
)
{
auto
*
map
=
new
JSObject2WrappedJSMap
(
)
;
if
(
!
map
-
>
mTable
.
init
(
length
)
)
{
NS_ABORT_OOM
(
length
*
2
*
sizeof
(
Map
:
:
Entry
)
)
;
}
return
map
;
}
inline
nsXPCWrappedJS
*
Find
(
JSObject
*
Obj
)
{
MOZ_ASSERT
(
Obj
"
bad
param
"
)
;
Map
:
:
Ptr
p
=
mTable
.
lookup
(
Obj
)
;
return
p
?
p
-
>
value
(
)
:
nullptr
;
}
#
ifdef
DEBUG
inline
bool
HasWrapper
(
nsXPCWrappedJS
*
wrapper
)
{
for
(
auto
iter
=
mTable
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
if
(
iter
.
get
(
)
.
value
(
)
=
=
wrapper
)
return
true
;
}
return
false
;
}
#
endif
inline
nsXPCWrappedJS
*
Add
(
JSContext
*
cx
nsXPCWrappedJS
*
wrapper
)
{
MOZ_ASSERT
(
wrapper
"
bad
param
"
)
;
JSObject
*
obj
=
wrapper
-
>
GetJSObjectPreserveColor
(
)
;
Map
:
:
AddPtr
p
=
mTable
.
lookupForAdd
(
obj
)
;
if
(
p
)
return
p
-
>
value
(
)
;
if
(
!
mTable
.
add
(
p
obj
wrapper
)
)
return
nullptr
;
return
wrapper
;
}
inline
void
Remove
(
nsXPCWrappedJS
*
wrapper
)
{
MOZ_ASSERT
(
wrapper
"
bad
param
"
)
;
mTable
.
remove
(
wrapper
-
>
GetJSObjectPreserveColor
(
)
)
;
}
inline
uint32_t
Count
(
)
{
return
mTable
.
count
(
)
;
}
inline
void
Dump
(
int16_t
depth
)
{
for
(
auto
iter
=
mTable
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
iter
.
get
(
)
.
value
(
)
-
>
DebugDump
(
depth
)
;
}
void
UpdateWeakPointersAfterGC
(
)
;
void
ShutdownMarker
(
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
size_t
SizeOfWrappedJS
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
JSObject2WrappedJSMap
(
)
{
}
Map
mTable
;
}
;
class
Native2WrappedNativeMap
{
public
:
struct
Entry
:
public
PLDHashEntryHdr
{
nsISupports
*
key
;
XPCWrappedNative
*
value
;
}
;
static
Native2WrappedNativeMap
*
newMap
(
int
length
)
;
inline
XPCWrappedNative
*
Find
(
nsISupports
*
Obj
)
const
{
MOZ_ASSERT
(
Obj
"
bad
param
"
)
;
auto
entry
=
static_cast
<
Entry
*
>
(
mTable
.
Search
(
Obj
)
)
;
return
entry
?
entry
-
>
value
:
nullptr
;
}
inline
XPCWrappedNative
*
Add
(
XPCWrappedNative
*
wrapper
)
{
MOZ_ASSERT
(
wrapper
"
bad
param
"
)
;
nsISupports
*
obj
=
wrapper
-
>
GetIdentityObject
(
)
;
MOZ_ASSERT
(
!
Find
(
obj
)
"
wrapper
already
in
new
scope
!
"
)
;
auto
entry
=
static_cast
<
Entry
*
>
(
mTable
.
Add
(
obj
mozilla
:
:
fallible
)
)
;
if
(
!
entry
)
return
nullptr
;
if
(
entry
-
>
key
)
return
entry
-
>
value
;
entry
-
>
key
=
obj
;
entry
-
>
value
=
wrapper
;
return
wrapper
;
}
inline
void
Remove
(
XPCWrappedNative
*
wrapper
)
{
MOZ_ASSERT
(
wrapper
"
bad
param
"
)
;
#
ifdef
DEBUG
XPCWrappedNative
*
wrapperInMap
=
Find
(
wrapper
-
>
GetIdentityObject
(
)
)
;
MOZ_ASSERT
(
!
wrapperInMap
|
|
wrapperInMap
=
=
wrapper
"
About
to
remove
a
different
wrapper
with
the
same
"
"
nsISupports
identity
!
This
will
most
likely
cause
serious
"
"
problems
!
"
)
;
#
endif
mTable
.
Remove
(
wrapper
-
>
GetIdentityObject
(
)
)
;
}
inline
void
Clear
(
)
{
mTable
.
Clear
(
)
;
}
inline
uint32_t
Count
(
)
{
return
mTable
.
EntryCount
(
)
;
}
PLDHashTable
:
:
Iterator
Iter
(
)
{
return
mTable
.
Iter
(
)
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
Native2WrappedNativeMap
(
)
;
explicit
Native2WrappedNativeMap
(
int
size
)
;
private
:
PLDHashTable
mTable
;
}
;
class
IID2WrappedJSClassMap
{
public
:
struct
Entry
:
public
PLDHashEntryHdr
{
const
nsIID
*
key
;
nsXPCWrappedJSClass
*
value
;
static
const
struct
PLDHashTableOps
sOps
;
}
;
static
IID2WrappedJSClassMap
*
newMap
(
int
length
)
;
inline
nsXPCWrappedJSClass
*
Find
(
REFNSIID
iid
)
const
{
auto
entry
=
static_cast
<
Entry
*
>
(
mTable
.
Search
(
&
iid
)
)
;
return
entry
?
entry
-
>
value
:
nullptr
;
}
inline
nsXPCWrappedJSClass
*
Add
(
nsXPCWrappedJSClass
*
clazz
)
{
MOZ_ASSERT
(
clazz
"
bad
param
"
)
;
const
nsIID
*
iid
=
&
clazz
-
>
GetIID
(
)
;
auto
entry
=
static_cast
<
Entry
*
>
(
mTable
.
Add
(
iid
mozilla
:
:
fallible
)
)
;
if
(
!
entry
)
return
nullptr
;
if
(
entry
-
>
key
)
return
entry
-
>
value
;
entry
-
>
key
=
iid
;
entry
-
>
value
=
clazz
;
return
clazz
;
}
inline
void
Remove
(
nsXPCWrappedJSClass
*
clazz
)
{
MOZ_ASSERT
(
clazz
"
bad
param
"
)
;
mTable
.
Remove
(
&
clazz
-
>
GetIID
(
)
)
;
}
inline
uint32_t
Count
(
)
{
return
mTable
.
EntryCount
(
)
;
}
#
ifdef
DEBUG
PLDHashTable
:
:
Iterator
Iter
(
)
{
return
mTable
.
Iter
(
)
;
}
#
endif
private
:
IID2WrappedJSClassMap
(
)
;
explicit
IID2WrappedJSClassMap
(
int
size
)
;
private
:
PLDHashTable
mTable
;
}
;
class
IID2NativeInterfaceMap
{
public
:
struct
Entry
:
public
PLDHashEntryHdr
{
const
nsIID
*
key
;
XPCNativeInterface
*
value
;
static
const
struct
PLDHashTableOps
sOps
;
}
;
static
IID2NativeInterfaceMap
*
newMap
(
int
length
)
;
inline
XPCNativeInterface
*
Find
(
REFNSIID
iid
)
const
{
auto
entry
=
static_cast
<
Entry
*
>
(
mTable
.
Search
(
&
iid
)
)
;
return
entry
?
entry
-
>
value
:
nullptr
;
}
inline
XPCNativeInterface
*
Add
(
XPCNativeInterface
*
iface
)
{
MOZ_ASSERT
(
iface
"
bad
param
"
)
;
const
nsIID
*
iid
=
iface
-
>
GetIID
(
)
;
auto
entry
=
static_cast
<
Entry
*
>
(
mTable
.
Add
(
iid
mozilla
:
:
fallible
)
)
;
if
(
!
entry
)
return
nullptr
;
if
(
entry
-
>
key
)
return
entry
-
>
value
;
entry
-
>
key
=
iid
;
entry
-
>
value
=
iface
;
return
iface
;
}
inline
void
Remove
(
XPCNativeInterface
*
iface
)
{
MOZ_ASSERT
(
iface
"
bad
param
"
)
;
mTable
.
Remove
(
iface
-
>
GetIID
(
)
)
;
}
inline
uint32_t
Count
(
)
{
return
mTable
.
EntryCount
(
)
;
}
PLDHashTable
:
:
Iterator
Iter
(
)
{
return
mTable
.
Iter
(
)
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
IID2NativeInterfaceMap
(
)
;
explicit
IID2NativeInterfaceMap
(
int
size
)
;
private
:
PLDHashTable
mTable
;
}
;
class
ClassInfo2NativeSetMap
{
public
:
struct
Entry
:
public
PLDHashEntryHdr
{
nsIClassInfo
*
key
;
XPCNativeSet
*
value
;
static
const
PLDHashTableOps
sOps
;
private
:
static
bool
Match
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
;
static
void
Clear
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
;
}
;
static
ClassInfo2NativeSetMap
*
newMap
(
int
length
)
;
inline
XPCNativeSet
*
Find
(
nsIClassInfo
*
info
)
const
{
auto
entry
=
static_cast
<
Entry
*
>
(
mTable
.
Search
(
info
)
)
;
return
entry
?
entry
-
>
value
:
nullptr
;
}
inline
XPCNativeSet
*
Add
(
nsIClassInfo
*
info
XPCNativeSet
*
set
)
{
MOZ_ASSERT
(
info
"
bad
param
"
)
;
auto
entry
=
static_cast
<
Entry
*
>
(
mTable
.
Add
(
info
mozilla
:
:
fallible
)
)
;
if
(
!
entry
)
return
nullptr
;
if
(
entry
-
>
key
)
return
entry
-
>
value
;
entry
-
>
key
=
info
;
NS_ADDREF
(
entry
-
>
value
=
set
)
;
return
set
;
}
inline
void
Remove
(
nsIClassInfo
*
info
)
{
MOZ_ASSERT
(
info
"
bad
param
"
)
;
mTable
.
Remove
(
info
)
;
}
inline
uint32_t
Count
(
)
{
return
mTable
.
EntryCount
(
)
;
}
size_t
ShallowSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
private
:
ClassInfo2NativeSetMap
(
)
;
explicit
ClassInfo2NativeSetMap
(
int
size
)
;
private
:
PLDHashTable
mTable
;
}
;
class
ClassInfo2WrappedNativeProtoMap
{
public
:
struct
Entry
:
public
PLDHashEntryHdr
{
nsIClassInfo
*
key
;
XPCWrappedNativeProto
*
value
;
}
;
static
ClassInfo2WrappedNativeProtoMap
*
newMap
(
int
length
)
;
inline
XPCWrappedNativeProto
*
Find
(
nsIClassInfo
*
info
)
const
{
auto
entry
=
static_cast
<
Entry
*
>
(
mTable
.
Search
(
info
)
)
;
return
entry
?
entry
-
>
value
:
nullptr
;
}
inline
XPCWrappedNativeProto
*
Add
(
nsIClassInfo
*
info
XPCWrappedNativeProto
*
proto
)
{
MOZ_ASSERT
(
info
"
bad
param
"
)
;
auto
entry
=
static_cast
<
Entry
*
>
(
mTable
.
Add
(
info
mozilla
:
:
fallible
)
)
;
if
(
!
entry
)
return
nullptr
;
if
(
entry
-
>
key
)
return
entry
-
>
value
;
entry
-
>
key
=
info
;
entry
-
>
value
=
proto
;
return
proto
;
}
inline
void
Remove
(
nsIClassInfo
*
info
)
{
MOZ_ASSERT
(
info
"
bad
param
"
)
;
mTable
.
Remove
(
info
)
;
}
inline
void
Clear
(
)
{
mTable
.
Clear
(
)
;
}
inline
uint32_t
Count
(
)
{
return
mTable
.
EntryCount
(
)
;
}
PLDHashTable
:
:
Iterator
Iter
(
)
{
return
mTable
.
Iter
(
)
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
ClassInfo2WrappedNativeProtoMap
(
)
;
explicit
ClassInfo2WrappedNativeProtoMap
(
int
size
)
;
private
:
PLDHashTable
mTable
;
}
;
class
NativeSetMap
{
public
:
struct
Entry
:
public
PLDHashEntryHdr
{
XPCNativeSet
*
key_value
;
static
bool
Match
(
const
PLDHashEntryHdr
*
entry
const
void
*
key
)
;
static
const
struct
PLDHashTableOps
sOps
;
}
;
static
NativeSetMap
*
newMap
(
int
length
)
;
inline
XPCNativeSet
*
Find
(
XPCNativeSetKey
*
key
)
const
{
auto
entry
=
static_cast
<
Entry
*
>
(
mTable
.
Search
(
key
)
)
;
return
entry
?
entry
-
>
key_value
:
nullptr
;
}
inline
XPCNativeSet
*
Add
(
const
XPCNativeSetKey
*
key
XPCNativeSet
*
set
)
{
MOZ_ASSERT
(
key
"
bad
param
"
)
;
MOZ_ASSERT
(
set
"
bad
param
"
)
;
auto
entry
=
static_cast
<
Entry
*
>
(
mTable
.
Add
(
key
mozilla
:
:
fallible
)
)
;
if
(
!
entry
)
return
nullptr
;
if
(
entry
-
>
key_value
)
return
entry
-
>
key_value
;
entry
-
>
key_value
=
set
;
return
set
;
}
bool
AddNew
(
const
XPCNativeSetKey
*
key
XPCNativeSet
*
set
)
{
XPCNativeSet
*
set2
=
Add
(
key
set
)
;
if
(
!
set2
)
{
return
false
;
}
#
ifdef
DEBUG
XPCNativeSetKey
key2
(
set
)
;
MOZ_ASSERT
(
key
-
>
Hash
(
)
=
=
key2
.
Hash
(
)
)
;
MOZ_ASSERT
(
set2
=
=
set
"
Should
not
have
found
an
existing
entry
"
)
;
#
endif
return
true
;
}
inline
void
Remove
(
XPCNativeSet
*
set
)
{
MOZ_ASSERT
(
set
"
bad
param
"
)
;
XPCNativeSetKey
key
(
set
)
;
mTable
.
Remove
(
&
key
)
;
}
inline
uint32_t
Count
(
)
{
return
mTable
.
EntryCount
(
)
;
}
PLDHashTable
:
:
Iterator
Iter
(
)
{
return
mTable
.
Iter
(
)
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
;
private
:
NativeSetMap
(
)
;
explicit
NativeSetMap
(
int
size
)
;
private
:
PLDHashTable
mTable
;
}
;
class
XPCWrappedNativeProtoMap
{
public
:
typedef
PLDHashEntryStub
Entry
;
static
XPCWrappedNativeProtoMap
*
newMap
(
int
length
)
;
inline
XPCWrappedNativeProto
*
Add
(
XPCWrappedNativeProto
*
proto
)
{
MOZ_ASSERT
(
proto
"
bad
param
"
)
;
auto
entry
=
static_cast
<
PLDHashEntryStub
*
>
(
mTable
.
Add
(
proto
mozilla
:
:
fallible
)
)
;
if
(
!
entry
)
return
nullptr
;
if
(
entry
-
>
key
)
return
(
XPCWrappedNativeProto
*
)
entry
-
>
key
;
entry
-
>
key
=
proto
;
return
proto
;
}
inline
void
Remove
(
XPCWrappedNativeProto
*
proto
)
{
MOZ_ASSERT
(
proto
"
bad
param
"
)
;
mTable
.
Remove
(
proto
)
;
}
inline
uint32_t
Count
(
)
{
return
mTable
.
EntryCount
(
)
;
}
PLDHashTable
:
:
Iterator
Iter
(
)
{
return
mTable
.
Iter
(
)
;
}
private
:
XPCWrappedNativeProtoMap
(
)
;
explicit
XPCWrappedNativeProtoMap
(
int
size
)
;
private
:
PLDHashTable
mTable
;
}
;
class
JSObject2JSObjectMap
{
using
Map
=
JS
:
:
GCHashMap
<
JS
:
:
Heap
<
JSObject
*
>
JS
:
:
Heap
<
JSObject
*
>
js
:
:
MovableCellHasher
<
JS
:
:
Heap
<
JSObject
*
>
>
js
:
:
SystemAllocPolicy
>
;
public
:
static
JSObject2JSObjectMap
*
newMap
(
int
length
)
{
auto
*
map
=
new
JSObject2JSObjectMap
(
)
;
if
(
!
map
-
>
mTable
.
init
(
length
)
)
{
NS_ABORT_OOM
(
length
*
2
*
sizeof
(
Map
:
:
Entry
)
)
;
}
return
map
;
}
inline
JSObject
*
Find
(
JSObject
*
key
)
{
MOZ_ASSERT
(
key
"
bad
param
"
)
;
if
(
Map
:
:
Ptr
p
=
mTable
.
lookup
(
key
)
)
return
p
-
>
value
(
)
;
return
nullptr
;
}
inline
JSObject
*
Add
(
JSContext
*
cx
JSObject
*
key
JSObject
*
value
)
{
MOZ_ASSERT
(
key
"
bad
param
"
)
;
Map
:
:
AddPtr
p
=
mTable
.
lookupForAdd
(
key
)
;
if
(
p
)
return
p
-
>
value
(
)
;
if
(
!
mTable
.
add
(
p
key
value
)
)
return
nullptr
;
MOZ_ASSERT
(
xpc
:
:
RealmPrivate
:
:
Get
(
key
)
-
>
scope
-
>
mWaiverWrapperMap
=
=
this
)
;
return
value
;
}
inline
void
Remove
(
JSObject
*
key
)
{
MOZ_ASSERT
(
key
"
bad
param
"
)
;
mTable
.
remove
(
key
)
;
}
inline
uint32_t
Count
(
)
{
return
mTable
.
count
(
)
;
}
void
Sweep
(
)
{
mTable
.
sweep
(
)
;
}
private
:
JSObject2JSObjectMap
(
)
{
}
Map
mTable
;
}
;
#
endif
