#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
XPCWrapper
.
h
"
#
include
"
XPCJSMemoryReporter
.
h
"
#
include
"
XrayWrapper
.
h
"
#
include
"
WrapperFactory
.
h
"
#
include
"
mozJSComponentLoader
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsIMemoryInfoDumper
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIDebug2
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsCycleCollectionNoteRootCallback
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
MemoryMetrics
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
js
/
UbiNodeUtils
.
h
"
#
include
"
mozilla
/
dom
/
GeneratedAtomList
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
mozilla
/
jsipc
/
CrossProcessObjectWrappers
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ProcessHangMonitor
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
AccessCheck
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsAboutProtocolUtils
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
NodeUbiReporting
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
endif
using
namespace
mozilla
;
using
namespace
xpc
;
using
namespace
JS
;
using
mozilla
:
:
dom
:
:
PerThreadAtomCache
;
using
mozilla
:
:
dom
:
:
AutoEntryScript
;
const
char
*
const
XPCJSRuntime
:
:
mStrings
[
]
=
{
"
constructor
"
"
toString
"
"
toSource
"
"
lastResult
"
"
returnCode
"
"
value
"
"
QueryInterface
"
"
Components
"
"
Cc
"
"
Ci
"
"
Cr
"
"
Cu
"
"
wrappedJSObject
"
"
Object
"
"
Function
"
"
prototype
"
"
createInstance
"
"
item
"
"
__proto__
"
"
eval
"
"
controllers
"
"
Controllers
"
"
realFrameElement
"
"
length
"
"
name
"
"
undefined
"
"
"
"
fileName
"
"
lineNumber
"
"
columnNumber
"
"
stack
"
"
message
"
"
lastIndex
"
"
then
"
"
isInstance
"
}
;
class
AsyncFreeSnowWhite
:
public
Runnable
{
public
:
NS_IMETHOD
Run
(
)
override
{
AUTO_PROFILER_LABEL
(
"
AsyncFreeSnowWhite
:
:
Run
"
GCCC
)
;
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
bool
hadSnowWhiteObjects
=
nsCycleCollector_doDeferredDeletion
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CYCLE_COLLECTOR_ASYNC_SNOW_WHITE_FREEING
uint32_t
(
(
TimeStamp
:
:
Now
(
)
-
start
)
.
ToMilliseconds
(
)
)
)
;
if
(
hadSnowWhiteObjects
&
&
!
mContinuation
)
{
mContinuation
=
true
;
if
(
NS_FAILED
(
Dispatch
(
)
)
)
{
mActive
=
false
;
}
}
else
{
mActive
=
false
;
}
return
NS_OK
;
}
void
RecordReplayRun
(
)
{
mActive
=
recordreplay
:
:
RecordReplayValue
(
mActive
)
;
mPurge
=
recordreplay
:
:
RecordReplayValue
(
mPurge
)
;
mContinuation
=
recordreplay
:
:
RecordReplayValue
(
mContinuation
)
;
Run
(
)
;
}
nsresult
Dispatch
(
)
{
if
(
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
recordreplay
:
:
ActivateTrigger
(
this
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIRunnable
>
self
(
this
)
;
return
NS_IdleDispatchToCurrentThread
(
self
.
forget
(
)
2500
)
;
}
void
Start
(
bool
aContinuation
=
false
bool
aPurge
=
false
)
{
if
(
mContinuation
)
{
mContinuation
=
aContinuation
;
}
mPurge
=
aPurge
;
if
(
!
mActive
&
&
NS_SUCCEEDED
(
Dispatch
(
)
)
)
{
mActive
=
true
;
}
}
struct
RawSelfPtr
{
AsyncFreeSnowWhite
*
mPtr
;
}
;
AsyncFreeSnowWhite
(
)
:
Runnable
(
"
AsyncFreeSnowWhite
"
)
mContinuation
(
false
)
mActive
(
false
)
mPurge
(
false
)
{
if
(
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
RawSelfPtr
ptr
;
ptr
.
mPtr
=
this
;
recordreplay
:
:
RegisterTrigger
(
this
[
=
]
(
)
{
ptr
.
mPtr
-
>
RecordReplayRun
(
)
;
}
)
;
}
}
~
AsyncFreeSnowWhite
(
)
{
if
(
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
recordreplay
:
:
UnregisterTrigger
(
this
)
;
}
}
public
:
bool
mContinuation
;
bool
mActive
;
bool
mPurge
;
}
;
namespace
xpc
{
CompartmentPrivate
:
:
CompartmentPrivate
(
JS
:
:
Compartment
*
c
)
:
wantXrays
(
false
)
allowWaivers
(
true
)
isWebExtensionContentScript
(
false
)
allowCPOWs
(
false
)
isContentXBLCompartment
(
false
)
isSandboxCompartment
(
false
)
universalXPConnectEnabled
(
false
)
forcePermissiveCOWs
(
false
)
wasNuked
(
false
)
mWrappedJSMap
(
JSObject2WrappedJSMap
:
:
newMap
(
XPC_JS_MAP_LENGTH
)
)
{
MOZ_COUNT_CTOR
(
xpc
:
:
CompartmentPrivate
)
;
mozilla
:
:
PodArrayZero
(
wrapperDenialWarnings
)
;
}
CompartmentPrivate
:
:
~
CompartmentPrivate
(
)
{
MOZ_COUNT_DTOR
(
xpc
:
:
CompartmentPrivate
)
;
delete
mWrappedJSMap
;
}
void
CompartmentPrivate
:
:
SystemIsBeingShutDown
(
)
{
mWrappedJSMap
-
>
ShutdownMarker
(
)
;
}
RealmPrivate
:
:
RealmPrivate
(
JS
:
:
Realm
*
realm
)
:
scriptability
(
realm
)
scope
(
nullptr
)
{
}
static
bool
TryParseLocationURICandidate
(
const
nsACString
&
uristr
RealmPrivate
:
:
LocationHint
aLocationHint
nsIURI
*
*
aURI
)
{
static
NS_NAMED_LITERAL_CSTRING
(
kGRE
"
resource
:
static
NS_NAMED_LITERAL_CSTRING
(
kToolkit
"
chrome
:
static
NS_NAMED_LITERAL_CSTRING
(
kBrowser
"
chrome
:
if
(
aLocationHint
=
=
RealmPrivate
:
:
LocationHintAddon
)
{
if
(
StringBeginsWith
(
uristr
kGRE
)
|
|
StringBeginsWith
(
uristr
kToolkit
)
|
|
StringBeginsWith
(
uristr
kBrowser
)
)
return
false
;
if
(
StringBeginsWith
(
uristr
NS_LITERAL_CSTRING
(
"
xb
"
)
)
)
return
false
;
}
nsCOMPtr
<
nsIURI
>
uri
;
if
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
uri
)
uristr
)
)
)
return
false
;
nsAutoCString
scheme
;
if
(
NS_FAILED
(
uri
-
>
GetScheme
(
scheme
)
)
)
return
false
;
if
(
scheme
.
EqualsLiteral
(
"
data
"
)
|
|
scheme
.
EqualsLiteral
(
"
blob
"
)
)
return
false
;
uri
.
forget
(
aURI
)
;
return
true
;
}
bool
RealmPrivate
:
:
TryParseLocationURI
(
RealmPrivate
:
:
LocationHint
aLocationHint
nsIURI
*
*
aURI
)
{
if
(
!
aURI
)
return
false
;
if
(
location
.
IsEmpty
(
)
)
return
false
;
static
const
nsDependentCString
from
(
"
(
from
:
"
)
;
static
const
nsDependentCString
arrow
(
"
-
>
"
)
;
static
const
size_t
fromLength
=
from
.
Length
(
)
;
static
const
size_t
arrowLength
=
arrow
.
Length
(
)
;
int32_t
idx
=
location
.
Find
(
from
)
;
if
(
idx
<
0
)
return
TryParseLocationURICandidate
(
location
aLocationHint
aURI
)
;
if
(
TryParseLocationURICandidate
(
Substring
(
location
0
idx
)
aLocationHint
aURI
)
)
return
true
;
int32_t
ridx
=
location
.
RFind
(
NS_LITERAL_CSTRING
(
"
:
"
)
)
;
nsAutoCString
chain
(
Substring
(
location
idx
+
fromLength
ridx
-
idx
-
fromLength
)
)
;
for
(
;
;
)
{
idx
=
chain
.
RFind
(
arrow
)
;
if
(
idx
<
0
)
{
return
TryParseLocationURICandidate
(
chain
aLocationHint
aURI
)
;
}
if
(
TryParseLocationURICandidate
(
Substring
(
chain
idx
+
arrowLength
)
aLocationHint
aURI
)
)
return
true
;
chain
=
Substring
(
chain
0
idx
)
;
}
MOZ_CRASH
(
"
Chain
parser
loop
does
not
terminate
"
)
;
}
static
bool
PrincipalImmuneToScriptPolicy
(
nsIPrincipal
*
aPrincipal
)
{
if
(
nsXPConnect
:
:
SecurityManager
(
)
-
>
IsSystemPrincipal
(
aPrincipal
)
)
return
true
;
auto
principal
=
BasePrincipal
:
:
Cast
(
aPrincipal
)
;
if
(
principal
-
>
Is
<
ExpandedPrincipal
>
(
)
)
{
return
true
;
}
if
(
principal
-
>
AddonPolicy
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsIURI
>
principalURI
;
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
principalURI
)
)
;
MOZ_ASSERT
(
principalURI
)
;
bool
isAbout
;
nsresult
rv
=
principalURI
-
>
SchemeIs
(
"
about
"
&
isAbout
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isAbout
)
{
nsCOMPtr
<
nsIAboutModule
>
module
;
rv
=
NS_GetAboutModule
(
principalURI
getter_AddRefs
(
module
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uint32_t
flags
;
rv
=
module
-
>
GetURIFlags
(
principalURI
&
flags
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
flags
&
nsIAboutModule
:
:
ALLOW_SCRIPT
)
)
{
return
true
;
}
}
}
return
false
;
}
Scriptability
:
:
Scriptability
(
JS
:
:
Realm
*
realm
)
:
mScriptBlocks
(
0
)
mDocShellAllowsScript
(
true
)
mScriptBlockedByPolicy
(
false
)
{
nsIPrincipal
*
prin
=
nsJSPrincipals
:
:
get
(
JS
:
:
GetRealmPrincipals
(
realm
)
)
;
mImmuneToScriptPolicy
=
PrincipalImmuneToScriptPolicy
(
prin
)
;
if
(
!
mImmuneToScriptPolicy
)
{
nsCOMPtr
<
nsIURI
>
codebase
;
nsresult
rv
=
prin
-
>
GetURI
(
getter_AddRefs
(
codebase
)
)
;
bool
policyAllows
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
codebase
&
&
NS_SUCCEEDED
(
nsXPConnect
:
:
SecurityManager
(
)
-
>
PolicyAllowsScript
(
codebase
&
policyAllows
)
)
)
{
mScriptBlockedByPolicy
=
!
policyAllows
;
}
else
{
mScriptBlockedByPolicy
=
true
;
}
}
}
bool
Scriptability
:
:
Allowed
(
)
{
return
mDocShellAllowsScript
&
&
!
mScriptBlockedByPolicy
&
&
mScriptBlocks
=
=
0
;
}
bool
Scriptability
:
:
IsImmuneToScriptPolicy
(
)
{
return
mImmuneToScriptPolicy
;
}
void
Scriptability
:
:
Block
(
)
{
+
+
mScriptBlocks
;
}
void
Scriptability
:
:
Unblock
(
)
{
MOZ_ASSERT
(
mScriptBlocks
>
0
)
;
-
-
mScriptBlocks
;
}
void
Scriptability
:
:
SetDocShellAllowsScript
(
bool
aAllowed
)
{
mDocShellAllowsScript
=
aAllowed
|
|
mImmuneToScriptPolicy
;
}
Scriptability
&
Scriptability
:
:
Get
(
JSObject
*
aScope
)
{
return
RealmPrivate
:
:
Get
(
aScope
)
-
>
scriptability
;
}
bool
IsContentXBLCompartment
(
JS
:
:
Compartment
*
compartment
)
{
CompartmentPrivate
*
priv
=
CompartmentPrivate
:
:
Get
(
compartment
)
;
return
priv
&
&
priv
-
>
isContentXBLCompartment
;
}
bool
IsContentXBLScope
(
JS
:
:
Realm
*
realm
)
{
return
IsContentXBLCompartment
(
JS
:
:
GetCompartmentForRealm
(
realm
)
)
;
}
bool
IsInContentXBLScope
(
JSObject
*
obj
)
{
return
IsContentXBLCompartment
(
js
:
:
GetObjectCompartment
(
obj
)
)
;
}
bool
IsInSandboxCompartment
(
JSObject
*
obj
)
{
JS
:
:
Compartment
*
comp
=
js
:
:
GetObjectCompartment
(
obj
)
;
CompartmentPrivate
*
priv
=
CompartmentPrivate
:
:
Get
(
comp
)
;
return
priv
&
&
priv
-
>
isSandboxCompartment
;
}
bool
IsUniversalXPConnectEnabled
(
JS
:
:
Compartment
*
compartment
)
{
CompartmentPrivate
*
priv
=
CompartmentPrivate
:
:
Get
(
compartment
)
;
if
(
!
priv
)
return
false
;
return
priv
-
>
universalXPConnectEnabled
;
}
bool
IsUniversalXPConnectEnabled
(
JSContext
*
cx
)
{
JS
:
:
Compartment
*
compartment
=
js
:
:
GetContextCompartment
(
cx
)
;
if
(
!
compartment
)
return
false
;
return
IsUniversalXPConnectEnabled
(
compartment
)
;
}
bool
EnableUniversalXPConnect
(
JSContext
*
cx
)
{
JS
:
:
Compartment
*
compartment
=
js
:
:
GetContextCompartment
(
cx
)
;
if
(
!
compartment
)
return
true
;
if
(
AccessCheck
:
:
isChrome
(
compartment
)
)
return
true
;
CompartmentPrivate
*
priv
=
CompartmentPrivate
:
:
Get
(
compartment
)
;
if
(
!
priv
)
return
true
;
if
(
priv
-
>
universalXPConnectEnabled
)
return
true
;
priv
-
>
universalXPConnectEnabled
=
true
;
bool
ok
=
js
:
:
RecomputeWrappers
(
cx
js
:
:
SingleCompartment
(
compartment
)
js
:
:
AllCompartments
(
)
)
;
NS_ENSURE_TRUE
(
ok
false
)
;
Realm
*
realm
=
GetCurrentRealmOrNull
(
cx
)
;
XPCWrappedNativeScope
*
scope
=
RealmPrivate
:
:
Get
(
realm
)
-
>
scope
;
if
(
!
scope
)
return
true
;
scope
-
>
ForcePrivilegedComponents
(
)
;
return
scope
-
>
AttachComponentsObject
(
cx
)
;
}
JSObject
*
UnprivilegedJunkScope
(
)
{
return
XPCJSRuntime
:
:
Get
(
)
-
>
UnprivilegedJunkScope
(
)
;
}
JSObject
*
PrivilegedJunkScope
(
)
{
return
XPCJSRuntime
:
:
Get
(
)
-
>
LoaderGlobal
(
)
;
}
JSObject
*
CompilationScope
(
)
{
return
XPCJSRuntime
:
:
Get
(
)
-
>
LoaderGlobal
(
)
;
}
nsGlobalWindowInner
*
WindowOrNull
(
JSObject
*
aObj
)
{
MOZ_ASSERT
(
aObj
)
;
MOZ_ASSERT
(
!
js
:
:
IsWrapper
(
aObj
)
)
;
nsGlobalWindowInner
*
win
=
nullptr
;
UNWRAP_NON_WRAPPER_OBJECT
(
Window
aObj
win
)
;
return
win
;
}
nsGlobalWindowInner
*
WindowGlobalOrNull
(
JSObject
*
aObj
)
{
MOZ_ASSERT
(
aObj
)
;
JSObject
*
glob
=
JS
:
:
GetNonCCWObjectGlobal
(
aObj
)
;
return
WindowOrNull
(
glob
)
;
}
nsGlobalWindowInner
*
CurrentWindowOrNull
(
JSContext
*
cx
)
{
JSObject
*
glob
=
JS
:
:
CurrentGlobalOrNull
(
cx
)
;
return
glob
?
WindowOrNull
(
glob
)
:
nullptr
;
}
void
NukeAllWrappersForCompartment
(
JSContext
*
cx
JS
:
:
Compartment
*
compartment
js
:
:
NukeReferencesToWindow
nukeReferencesToWindow
)
{
js
:
:
NukeCrossCompartmentWrappers
(
cx
js
:
:
AllCompartments
(
)
compartment
nukeReferencesToWindow
js
:
:
NukeAllReferences
)
;
xpc
:
:
CompartmentPrivate
:
:
Get
(
compartment
)
-
>
wasNuked
=
true
;
auto
blockScriptability
=
[
]
(
JSContext
*
void
*
Handle
<
Realm
*
>
realm
)
{
xpc
:
:
RealmPrivate
:
:
Get
(
realm
)
-
>
scriptability
.
Block
(
)
;
}
;
JS
:
:
IterateRealmsInCompartment
(
cx
compartment
nullptr
blockScriptability
)
;
}
}
static
void
CompartmentDestroyedCallback
(
JSFreeOp
*
fop
JS
:
:
Compartment
*
compartment
)
{
nsAutoPtr
<
CompartmentPrivate
>
priv
(
CompartmentPrivate
:
:
Get
(
compartment
)
)
;
JS_SetCompartmentPrivate
(
compartment
nullptr
)
;
}
static
size_t
CompartmentSizeOfIncludingThisCallback
(
MallocSizeOf
mallocSizeOf
JS
:
:
Compartment
*
compartment
)
{
CompartmentPrivate
*
priv
=
CompartmentPrivate
:
:
Get
(
compartment
)
;
return
priv
?
priv
-
>
SizeOfIncludingThis
(
mallocSizeOf
)
:
0
;
}
bool
XPCJSRuntime
:
:
UsefulToMergeZones
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
false
;
}
void
XPCJSRuntime
:
:
TraceNativeBlackRoots
(
JSTracer
*
trc
)
{
for
(
CycleCollectedJSContext
*
ccx
:
Contexts
(
)
)
{
auto
*
cx
=
static_cast
<
const
XPCJSContext
*
>
(
ccx
)
;
if
(
AutoMarkingPtr
*
roots
=
cx
-
>
mAutoRoots
)
roots
-
>
TraceJSAll
(
trc
)
;
}
dom
:
:
TraceBlackJS
(
trc
nsXPConnect
:
:
XPConnect
(
)
-
>
IsShuttingDown
(
)
)
;
}
void
XPCJSRuntime
:
:
TraceAdditionalNativeGrayRoots
(
JSTracer
*
trc
)
{
XPCWrappedNativeScope
:
:
TraceWrappedNativesInAllScopes
(
trc
)
;
for
(
XPCRootSetElem
*
e
=
mVariantRoots
;
e
;
e
=
e
-
>
GetNextRoot
(
)
)
static_cast
<
XPCTraceableVariant
*
>
(
e
)
-
>
TraceJS
(
trc
)
;
for
(
XPCRootSetElem
*
e
=
mWrappedJSRoots
;
e
;
e
=
e
-
>
GetNextRoot
(
)
)
static_cast
<
nsXPCWrappedJS
*
>
(
e
)
-
>
TraceJS
(
trc
)
;
}
void
XPCJSRuntime
:
:
TraverseAdditionalNativeRoots
(
nsCycleCollectionNoteRootCallback
&
cb
)
{
XPCWrappedNativeScope
:
:
SuspectAllWrappers
(
cb
)
;
for
(
XPCRootSetElem
*
e
=
mVariantRoots
;
e
;
e
=
e
-
>
GetNextRoot
(
)
)
{
XPCTraceableVariant
*
v
=
static_cast
<
XPCTraceableVariant
*
>
(
e
)
;
if
(
nsCCUncollectableMarker
:
:
InGeneration
(
cb
v
-
>
CCGeneration
(
)
)
)
{
JS
:
:
Value
val
=
v
-
>
GetJSValPreserveColor
(
)
;
if
(
val
.
isObject
(
)
&
&
!
JS
:
:
ObjectIsMarkedGray
(
&
val
.
toObject
(
)
)
)
continue
;
}
cb
.
NoteXPCOMRoot
(
v
XPCTraceableVariant
:
:
NS_CYCLE_COLLECTION_INNERCLASS
:
:
GetParticipant
(
)
)
;
}
for
(
XPCRootSetElem
*
e
=
mWrappedJSRoots
;
e
;
e
=
e
-
>
GetNextRoot
(
)
)
{
cb
.
NoteXPCOMRoot
(
ToSupports
(
static_cast
<
nsXPCWrappedJS
*
>
(
e
)
)
nsXPCWrappedJS
:
:
NS_CYCLE_COLLECTION_INNERCLASS
:
:
GetParticipant
(
)
)
;
}
}
void
XPCJSRuntime
:
:
UnmarkSkippableJSHolders
(
)
{
CycleCollectedJSRuntime
:
:
UnmarkSkippableJSHolders
(
)
;
}
void
XPCJSRuntime
:
:
PrepareForForgetSkippable
(
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
cycle
-
collector
-
forget
-
skippable
"
nullptr
)
;
}
}
void
XPCJSRuntime
:
:
BeginCycleCollectionCallback
(
)
{
nsJSContext
:
:
BeginCycleCollectionCallback
(
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
cycle
-
collector
-
begin
"
nullptr
)
;
}
}
void
XPCJSRuntime
:
:
EndCycleCollectionCallback
(
CycleCollectorResults
&
aResults
)
{
nsJSContext
:
:
EndCycleCollectionCallback
(
aResults
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
cycle
-
collector
-
end
"
nullptr
)
;
}
}
void
XPCJSRuntime
:
:
DispatchDeferredDeletion
(
bool
aContinuation
bool
aPurge
)
{
mAsyncSnowWhiteFreer
-
>
Start
(
aContinuation
aPurge
)
;
}
void
xpc_UnmarkSkippableJSHolders
(
)
{
if
(
nsXPConnect
:
:
GetRuntimeInstance
(
)
)
{
nsXPConnect
:
:
GetRuntimeInstance
(
)
-
>
UnmarkSkippableJSHolders
(
)
;
}
}
void
XPCJSRuntime
:
:
GCSliceCallback
(
JSContext
*
cx
JS
:
:
GCProgress
progress
const
JS
:
:
GCDescription
&
desc
)
{
XPCJSRuntime
*
self
=
nsXPConnect
:
:
GetRuntimeInstance
(
)
;
if
(
!
self
)
return
;
CrashReporter
:
:
SetGarbageCollecting
(
progress
=
=
JS
:
:
GC_CYCLE_BEGIN
)
;
if
(
self
-
>
mPrevGCSliceCallback
)
(
*
self
-
>
mPrevGCSliceCallback
)
(
cx
progress
desc
)
;
}
void
XPCJSRuntime
:
:
DoCycleCollectionCallback
(
JSContext
*
cx
)
{
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
"
XPCJSRuntime
:
:
DoCycleCollectionCallback
"
[
]
(
)
{
nsJSContext
:
:
CycleCollectNow
(
nullptr
)
;
}
)
)
;
XPCJSRuntime
*
self
=
nsXPConnect
:
:
GetRuntimeInstance
(
)
;
if
(
!
self
)
return
;
if
(
self
-
>
mPrevDoCycleCollectionCallback
)
(
*
self
-
>
mPrevDoCycleCollectionCallback
)
(
cx
)
;
}
void
XPCJSRuntime
:
:
CustomGCCallback
(
JSGCStatus
status
)
{
nsTArray
<
xpcGCCallback
>
callbacks
(
extraGCCallbacks
)
;
for
(
uint32_t
i
=
0
;
i
<
callbacks
.
Length
(
)
;
+
+
i
)
callbacks
[
i
]
(
status
)
;
}
void
XPCJSRuntime
:
:
FinalizeCallback
(
JSFreeOp
*
fop
JSFinalizeStatus
status
void
*
data
)
{
XPCJSRuntime
*
self
=
nsXPConnect
:
:
GetRuntimeInstance
(
)
;
if
(
!
self
)
return
;
switch
(
status
)
{
case
JSFINALIZE_GROUP_PREPARE
:
{
MOZ_ASSERT
(
!
self
-
>
mDoingFinalization
"
bad
state
"
)
;
MOZ_ASSERT
(
!
self
-
>
mGCIsRunning
"
bad
state
"
)
;
self
-
>
mGCIsRunning
=
true
;
self
-
>
mDoingFinalization
=
true
;
break
;
}
case
JSFINALIZE_GROUP_START
:
{
MOZ_ASSERT
(
self
-
>
mDoingFinalization
"
bad
state
"
)
;
MOZ_ASSERT
(
self
-
>
mGCIsRunning
"
bad
state
"
)
;
self
-
>
mGCIsRunning
=
false
;
break
;
}
case
JSFINALIZE_GROUP_END
:
{
XPCWrappedNativeScope
:
:
KillDyingScopes
(
)
;
MOZ_ASSERT
(
self
-
>
mDoingFinalization
"
bad
state
"
)
;
self
-
>
mDoingFinalization
=
false
;
break
;
}
case
JSFINALIZE_COLLECTION_END
:
{
MOZ_ASSERT
(
!
self
-
>
mGCIsRunning
"
bad
state
"
)
;
self
-
>
mGCIsRunning
=
true
;
for
(
CycleCollectedJSContext
*
ccx
:
self
-
>
Contexts
(
)
)
{
auto
*
cx
=
static_cast
<
const
XPCJSContext
*
>
(
ccx
)
;
if
(
AutoMarkingPtr
*
roots
=
cx
-
>
mAutoRoots
)
roots
-
>
MarkAfterJSFinalizeAll
(
)
;
XPCCallContext
*
ccxp
=
cx
-
>
GetCallContext
(
)
;
while
(
ccxp
)
{
if
(
ccxp
-
>
CanGetTearOff
(
)
)
{
XPCWrappedNativeTearOff
*
to
=
ccxp
-
>
GetTearOff
(
)
;
if
(
to
)
to
-
>
Mark
(
)
;
}
ccxp
=
ccxp
-
>
GetPrevCallContext
(
)
;
}
}
XPCWrappedNativeScope
:
:
SweepAllWrappedNativeTearOffs
(
)
;
for
(
auto
i
=
self
-
>
mDyingWrappedNativeProtoMap
-
>
Iter
(
)
;
!
i
.
Done
(
)
;
i
.
Next
(
)
)
{
auto
entry
=
static_cast
<
XPCWrappedNativeProtoMap
:
:
Entry
*
>
(
i
.
Get
(
)
)
;
delete
static_cast
<
const
XPCWrappedNativeProto
*
>
(
entry
-
>
key
)
;
i
.
Remove
(
)
;
}
MOZ_ASSERT
(
self
-
>
mGCIsRunning
"
bad
state
"
)
;
self
-
>
mGCIsRunning
=
false
;
break
;
}
}
}
void
XPCJSRuntime
:
:
WeakPointerZonesCallback
(
JSContext
*
cx
void
*
data
)
{
XPCJSRuntime
*
self
=
static_cast
<
XPCJSRuntime
*
>
(
data
)
;
self
-
>
mWrappedJSMap
-
>
UpdateWeakPointersAfterGC
(
)
;
XPCWrappedNativeScope
:
:
UpdateWeakPointersInAllScopesAfterGC
(
)
;
}
void
XPCJSRuntime
:
:
WeakPointerCompartmentCallback
(
JSContext
*
cx
JS
:
:
Compartment
*
comp
void
*
data
)
{
CompartmentPrivate
*
xpcComp
=
CompartmentPrivate
:
:
Get
(
comp
)
;
if
(
xpcComp
)
xpcComp
-
>
UpdateWeakPointersAfterGC
(
)
;
}
void
CompartmentPrivate
:
:
UpdateWeakPointersAfterGC
(
)
{
mWrappedJSMap
-
>
UpdateWeakPointersAfterGC
(
)
;
}
void
XPCJSRuntime
:
:
CustomOutOfMemoryCallback
(
)
{
if
(
!
Preferences
:
:
GetBool
(
"
memory
.
dump_reports_on_oom
"
)
)
{
return
;
}
nsCOMPtr
<
nsIMemoryInfoDumper
>
dumper
=
do_GetService
(
"
mozilla
.
org
/
memory
-
info
-
dumper
;
1
"
)
;
if
(
!
dumper
)
{
return
;
}
dumper
-
>
DumpMemoryInfoToTempDir
(
NS_LITERAL_STRING
(
"
due
-
to
-
JS
-
OOM
"
)
false
false
)
;
}
void
XPCJSRuntime
:
:
OnLargeAllocationFailure
(
)
{
CycleCollectedJSRuntime
:
:
SetLargeAllocationFailure
(
OOMState
:
:
Reporting
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
memory
-
pressure
"
u
"
heap
-
minimize
"
)
;
}
CycleCollectedJSRuntime
:
:
SetLargeAllocationFailure
(
OOMState
:
:
Reported
)
;
}
class
LargeAllocationFailureRunnable
final
:
public
Runnable
{
Mutex
mMutex
;
CondVar
mCondVar
;
bool
mWaiting
;
virtual
~
LargeAllocationFailureRunnable
(
)
{
MOZ_ASSERT
(
!
mWaiting
)
;
}
protected
:
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
XPCJSRuntime
:
:
Get
(
)
-
>
OnLargeAllocationFailure
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mWaiting
)
;
mWaiting
=
false
;
mCondVar
.
Notify
(
)
;
return
NS_OK
;
}
public
:
LargeAllocationFailureRunnable
(
)
:
mozilla
:
:
Runnable
(
"
LargeAllocationFailureRunnable
"
)
mMutex
(
"
LargeAllocationFailureRunnable
:
:
mMutex
"
)
mCondVar
(
mMutex
"
LargeAllocationFailureRunnable
:
:
mCondVar
"
)
mWaiting
(
true
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
}
void
BlockUntilDone
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
while
(
mWaiting
)
{
mCondVar
.
Wait
(
)
;
}
}
}
;
static
void
OnLargeAllocationFailureCallback
(
)
{
if
(
NS_IsMainThread
(
)
)
{
XPCJSRuntime
:
:
Get
(
)
-
>
OnLargeAllocationFailure
(
)
;
return
;
}
RefPtr
<
LargeAllocationFailureRunnable
>
r
=
new
LargeAllocationFailureRunnable
;
if
(
NS_WARN_IF
(
NS_FAILED
(
NS_DispatchToMainThread
(
r
)
)
)
)
{
return
;
}
r
-
>
BlockUntilDone
(
)
;
}
size_t
XPCJSRuntime
:
:
SizeOfIncludingThis
(
MallocSizeOf
mallocSizeOf
)
{
size_t
n
=
0
;
n
+
=
mallocSizeOf
(
this
)
;
n
+
=
mWrappedJSMap
-
>
SizeOfIncludingThis
(
mallocSizeOf
)
;
n
+
=
mIID2NativeInterfaceMap
-
>
SizeOfIncludingThis
(
mallocSizeOf
)
;
n
+
=
mClassInfo2NativeSetMap
-
>
ShallowSizeOfIncludingThis
(
mallocSizeOf
)
;
n
+
=
mNativeSetMap
-
>
SizeOfIncludingThis
(
mallocSizeOf
)
;
n
+
=
CycleCollectedJSRuntime
:
:
SizeOfExcludingThis
(
mallocSizeOf
)
;
return
n
;
}
size_t
CompartmentPrivate
:
:
SizeOfIncludingThis
(
MallocSizeOf
mallocSizeOf
)
{
size_t
n
=
mallocSizeOf
(
this
)
;
n
+
=
mWrappedJSMap
-
>
SizeOfIncludingThis
(
mallocSizeOf
)
;
n
+
=
mWrappedJSMap
-
>
SizeOfWrappedJS
(
mallocSizeOf
)
;
return
n
;
}
void
XPCJSRuntime
:
:
SystemIsBeingShutDown
(
)
{
mWrappedJSRoots
=
nullptr
;
}
void
XPCJSRuntime
:
:
Shutdown
(
JSContext
*
cx
)
{
JS_RemoveFinalizeCallback
(
cx
FinalizeCallback
)
;
JS_RemoveWeakPointerZonesCallback
(
cx
WeakPointerZonesCallback
)
;
JS_RemoveWeakPointerCompartmentCallback
(
cx
WeakPointerCompartmentCallback
)
;
xpc_DelocalizeRuntime
(
JS_GetRuntime
(
cx
)
)
;
JS
:
:
SetGCSliceCallback
(
cx
mPrevGCSliceCallback
)
;
mWrappedJSMap
-
>
ShutdownMarker
(
)
;
delete
mWrappedJSMap
;
mWrappedJSMap
=
nullptr
;
delete
mWrappedJSClassMap
;
mWrappedJSClassMap
=
nullptr
;
delete
mIID2NativeInterfaceMap
;
mIID2NativeInterfaceMap
=
nullptr
;
delete
mClassInfo2NativeSetMap
;
mClassInfo2NativeSetMap
=
nullptr
;
delete
mNativeSetMap
;
mNativeSetMap
=
nullptr
;
delete
mDyingWrappedNativeProtoMap
;
mDyingWrappedNativeProtoMap
=
nullptr
;
CycleCollectedJSRuntime
:
:
Shutdown
(
cx
)
;
}
XPCJSRuntime
:
:
~
XPCJSRuntime
(
)
{
MOZ_COUNT_DTOR_INHERITED
(
XPCJSRuntime
CycleCollectedJSRuntime
)
;
}
static
void
GetRealmName
(
JS
:
:
Realm
*
realm
nsCString
&
name
int
*
anonymizeID
bool
replaceSlashes
)
{
if
(
*
anonymizeID
&
&
!
js
:
:
IsSystemRealm
(
realm
)
)
{
name
.
AppendPrintf
(
"
<
anonymized
-
%
d
>
"
*
anonymizeID
)
;
*
anonymizeID
+
=
1
;
}
else
if
(
JSPrincipals
*
principals
=
JS
:
:
GetRealmPrincipals
(
realm
)
)
{
nsresult
rv
=
nsJSPrincipals
:
:
get
(
principals
)
-
>
GetScriptLocation
(
name
)
;
if
(
NS_FAILED
(
rv
)
)
{
name
.
AssignLiteral
(
"
(
unknown
)
"
)
;
}
RealmPrivate
*
realmPrivate
=
RealmPrivate
:
:
Get
(
realm
)
;
if
(
realmPrivate
)
{
const
nsACString
&
location
=
realmPrivate
-
>
GetLocation
(
)
;
if
(
!
location
.
IsEmpty
(
)
&
&
!
location
.
Equals
(
name
)
)
{
name
.
AppendLiteral
(
"
"
)
;
name
.
Append
(
location
)
;
}
}
if
(
*
anonymizeID
)
{
static
const
char
*
filePrefix
=
"
file
:
/
/
"
;
int
filePos
=
name
.
Find
(
filePrefix
)
;
if
(
filePos
>
=
0
)
{
int
pathPos
=
filePos
+
strlen
(
filePrefix
)
;
int
lastSlashPos
=
-
1
;
for
(
int
i
=
pathPos
;
i
<
int
(
name
.
Length
(
)
)
;
i
+
+
)
{
if
(
name
[
i
]
=
=
'
/
'
|
|
name
[
i
]
=
=
'
\
\
'
)
{
lastSlashPos
=
i
;
}
}
if
(
lastSlashPos
!
=
-
1
)
{
name
.
ReplaceASCII
(
pathPos
lastSlashPos
-
pathPos
"
<
anonymized
>
"
)
;
}
else
{
name
.
Truncate
(
pathPos
)
;
name
+
=
"
<
anonymized
?
!
>
"
;
}
}
static
const
char
*
ownedByPrefix
=
"
inProcessTabChildGlobal
?
ownedBy
=
"
;
int
ownedByPos
=
name
.
Find
(
ownedByPrefix
)
;
if
(
ownedByPos
>
=
0
)
{
const
char
*
chrome
=
"
chrome
:
"
;
int
ownerPos
=
ownedByPos
+
strlen
(
ownedByPrefix
)
;
const
nsDependentCSubstring
&
ownerFirstPart
=
Substring
(
name
ownerPos
strlen
(
chrome
)
)
;
if
(
!
ownerFirstPart
.
EqualsASCII
(
chrome
)
)
{
name
.
Truncate
(
ownerPos
)
;
name
+
=
"
<
anonymized
>
"
;
}
}
}
if
(
replaceSlashes
)
name
.
ReplaceChar
(
'
/
'
'
\
\
'
)
;
}
else
{
name
.
AssignLiteral
(
"
null
-
principal
"
)
;
}
}
extern
void
xpc
:
:
GetCurrentRealmName
(
JSContext
*
cx
nsCString
&
name
)
{
RootedObject
global
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
if
(
!
global
)
{
name
.
AssignLiteral
(
"
no
global
"
)
;
return
;
}
JS
:
:
Realm
*
realm
=
GetNonCCWObjectRealm
(
global
)
;
int
anonymizeID
=
0
;
GetRealmName
(
realm
name
&
anonymizeID
false
)
;
}
void
xpc
:
:
AddGCCallback
(
xpcGCCallback
cb
)
{
XPCJSRuntime
:
:
Get
(
)
-
>
AddGCCallback
(
cb
)
;
}
void
xpc
:
:
RemoveGCCallback
(
xpcGCCallback
cb
)
{
XPCJSRuntime
:
:
Get
(
)
-
>
RemoveGCCallback
(
cb
)
;
}
static
int64_t
JSMainRuntimeGCHeapDistinguishedAmount
(
)
{
JSContext
*
cx
=
danger
:
:
GetJSContext
(
)
;
return
int64_t
(
JS_GetGCParameter
(
cx
JSGC_TOTAL_CHUNKS
)
)
*
js
:
:
gc
:
:
ChunkSize
;
}
static
int64_t
JSMainRuntimeTemporaryPeakDistinguishedAmount
(
)
{
JSContext
*
cx
=
danger
:
:
GetJSContext
(
)
;
return
JS
:
:
PeakSizeOfTemporary
(
cx
)
;
}
static
int64_t
JSMainRuntimeRealmsSystemDistinguishedAmount
(
)
{
JSContext
*
cx
=
danger
:
:
GetJSContext
(
)
;
return
JS
:
:
SystemRealmCount
(
cx
)
;
}
static
int64_t
JSMainRuntimeRealmsUserDistinguishedAmount
(
)
{
JSContext
*
cx
=
XPCJSContext
:
:
Get
(
)
-
>
Context
(
)
;
return
JS
:
:
UserRealmCount
(
cx
)
;
}
class
JSMainRuntimeTemporaryPeakReporter
final
:
public
nsIMemoryReporter
{
~
JSMainRuntimeTemporaryPeakReporter
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
MOZ_COLLECT_REPORT
(
"
js
-
main
-
runtime
-
temporary
-
peak
"
KIND_OTHER
UNITS_BYTES
JSMainRuntimeTemporaryPeakDistinguishedAmount
(
)
"
Peak
transient
data
size
in
the
main
JSRuntime
(
the
current
size
"
"
of
which
is
reported
as
"
"
'
explicit
/
js
-
non
-
window
/
runtime
/
temporary
'
)
.
"
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
JSMainRuntimeTemporaryPeakReporter
nsIMemoryReporter
)
#
define
SUNDRIES_THRESHOLD
js
:
:
MemoryReportingSundriesThreshold
(
)
#
define
REPORT
(
_path
_kind
_units
_amount
_desc
)
\
handleReport
-
>
Callback
(
EmptyCString
(
)
_path
\
nsIMemoryReporter
:
:
_kind
\
nsIMemoryReporter
:
:
_units
_amount
\
NS_LITERAL_CSTRING
(
_desc
)
data
)
;
\
#
define
REPORT_BYTES
(
_path
_kind
_amount
_desc
)
\
REPORT
(
_path
_kind
UNITS_BYTES
_amount
_desc
)
;
#
define
REPORT_GC_BYTES
(
_path
_amount
_desc
)
\
do
{
\
size_t
amount
=
_amount
;
/
*
evaluate
_amount
only
once
*
/
\
handleReport
-
>
Callback
(
EmptyCString
(
)
_path
\
nsIMemoryReporter
:
:
KIND_NONHEAP
\
nsIMemoryReporter
:
:
UNITS_BYTES
amount
\
NS_LITERAL_CSTRING
(
_desc
)
data
)
;
\
gcTotal
+
=
amount
;
\
}
while
(
0
)
#
define
ZRREPORT_BYTES
(
_path
_amount
_desc
)
\
do
{
\
/
*
Assign
_descLiteral
plus
"
"
into
a
char
*
to
prove
that
it
'
s
*
/
\
/
*
actually
a
literal
.
*
/
\
size_t
amount
=
_amount
;
/
*
evaluate
_amount
only
once
*
/
\
if
(
amount
>
=
SUNDRIES_THRESHOLD
)
{
\
handleReport
-
>
Callback
(
EmptyCString
(
)
_path
\
nsIMemoryReporter
:
:
KIND_HEAP
\
nsIMemoryReporter
:
:
UNITS_BYTES
amount
\
NS_LITERAL_CSTRING
(
_desc
)
data
)
;
\
}
else
{
\
sundriesMallocHeap
+
=
amount
;
\
}
\
}
while
(
0
)
#
define
ZRREPORT_GC_BYTES
(
_path
_amount
_desc
)
\
do
{
\
size_t
amount
=
_amount
;
/
*
evaluate
_amount
only
once
*
/
\
if
(
amount
>
=
SUNDRIES_THRESHOLD
)
{
\
handleReport
-
>
Callback
(
EmptyCString
(
)
_path
\
nsIMemoryReporter
:
:
KIND_NONHEAP
\
nsIMemoryReporter
:
:
UNITS_BYTES
amount
\
NS_LITERAL_CSTRING
(
_desc
)
data
)
;
\
gcTotal
+
=
amount
;
\
}
else
{
\
sundriesGCHeap
+
=
amount
;
\
}
\
}
while
(
0
)
#
define
RREPORT_BYTES
(
_path
_kind
_amount
_desc
)
\
do
{
\
size_t
amount
=
_amount
;
/
*
evaluate
_amount
only
once
*
/
\
handleReport
-
>
Callback
(
EmptyCString
(
)
_path
\
nsIMemoryReporter
:
:
_kind
\
nsIMemoryReporter
:
:
UNITS_BYTES
amount
\
NS_LITERAL_CSTRING
(
_desc
)
data
)
;
\
rtTotal
+
=
amount
;
\
}
while
(
0
)
#
define
MREPORT_BYTES
(
_path
_kind
_amount
_desc
)
\
do
{
\
size_t
amount
=
_amount
;
/
*
evaluate
_amount
only
once
*
/
\
handleReport
-
>
Callback
(
EmptyCString
(
)
_path
\
nsIMemoryReporter
:
:
_kind
\
nsIMemoryReporter
:
:
UNITS_BYTES
amount
\
NS_LITERAL_CSTRING
(
_desc
)
data
)
;
\
gcThingTotal
+
=
amount
;
\
}
while
(
0
)
MOZ_DEFINE_MALLOC_SIZE_OF
(
JSMallocSizeOf
)
namespace
xpc
{
static
void
ReportZoneStats
(
const
JS
:
:
ZoneStats
&
zStats
const
xpc
:
:
ZoneStatsExtras
&
extras
nsIHandleReportCallback
*
handleReport
nsISupports
*
data
bool
anonymize
size_t
*
gcTotalOut
=
nullptr
)
{
const
nsCString
&
pathPrefix
=
extras
.
pathPrefix
;
size_t
gcTotal
=
0
sundriesGCHeap
=
0
sundriesMallocHeap
=
0
;
MOZ_ASSERT
(
!
gcTotalOut
=
=
zStats
.
isTotals
)
;
ZRREPORT_GC_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
symbols
/
gc
-
heap
"
)
zStats
.
symbolsGCHeap
"
Symbols
.
"
)
;
ZRREPORT_GC_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
gc
-
heap
-
arena
-
admin
"
)
zStats
.
gcHeapArenaAdmin
"
Bookkeeping
information
and
alignment
padding
within
GC
arenas
.
"
)
;
ZRREPORT_GC_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
unused
-
gc
-
things
"
)
zStats
.
unusedGCThings
.
totalSize
(
)
"
Unused
GC
thing
cells
within
non
-
empty
arenas
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
unique
-
id
-
map
"
)
zStats
.
uniqueIdMap
"
Address
-
independent
cell
identities
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
shape
-
tables
"
)
zStats
.
shapeTables
"
Tables
storing
shape
information
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
compartments
/
compartment
-
objects
"
)
zStats
.
compartmentObjects
"
The
JS
:
:
Compartment
objects
in
this
zone
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
compartments
/
cross
-
compartment
-
wrapper
-
tables
"
)
zStats
.
crossCompartmentWrappersTables
"
The
cross
-
compartment
wrapper
tables
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
compartments
/
private
-
data
"
)
zStats
.
compartmentsPrivateData
"
Extra
data
attached
to
each
compartment
by
XPConnect
including
"
"
its
wrapped
-
js
.
"
)
;
ZRREPORT_GC_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
lazy
-
scripts
/
gc
-
heap
"
)
zStats
.
lazyScriptsGCHeap
"
Scripts
that
haven
'
t
executed
yet
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
lazy
-
scripts
/
malloc
-
heap
"
)
zStats
.
lazyScriptsMallocHeap
"
Lazy
script
tables
containing
closed
-
over
bindings
or
inner
functions
.
"
)
;
ZRREPORT_GC_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
jit
-
codes
-
gc
-
heap
"
)
zStats
.
jitCodesGCHeap
"
References
to
executable
code
pools
used
by
the
JITs
.
"
)
;
ZRREPORT_GC_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
object
-
groups
/
gc
-
heap
"
)
zStats
.
objectGroupsGCHeap
"
Classification
and
type
inference
information
about
objects
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
object
-
groups
/
malloc
-
heap
"
)
zStats
.
objectGroupsMallocHeap
"
Object
group
addenda
.
"
)
;
ZRREPORT_GC_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
scopes
/
gc
-
heap
"
)
zStats
.
scopesGCHeap
"
Scope
information
for
scripts
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
scopes
/
malloc
-
heap
"
)
zStats
.
scopesMallocHeap
"
Arrays
of
binding
names
and
other
binding
-
related
data
.
"
)
;
ZRREPORT_GC_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
regexp
-
shareds
/
gc
-
heap
"
)
zStats
.
regExpSharedsGCHeap
"
Shared
compiled
regexp
data
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
regexp
-
shareds
/
malloc
-
heap
"
)
zStats
.
regExpSharedsMallocHeap
"
Shared
compiled
regexp
data
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
type
-
pool
"
)
zStats
.
typePool
"
Type
sets
and
related
data
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
regexp
-
zone
"
)
zStats
.
regexpZone
"
The
regexp
zone
and
regexp
data
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
jit
-
zone
"
)
zStats
.
jitZone
"
The
JIT
zone
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
baseline
/
optimized
-
stubs
"
)
zStats
.
baselineStubsOptimized
"
The
Baseline
JIT
'
s
optimized
IC
stubs
(
excluding
code
)
.
"
)
;
ZRREPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
jit
-
cached
-
cfg
"
)
zStats
.
cachedCFG
"
The
cached
CFG
to
construct
Ion
code
out
of
it
.
"
)
;
size_t
stringsNotableAboutMemoryGCHeap
=
0
;
size_t
stringsNotableAboutMemoryMallocHeap
=
0
;
#
define
MAYBE_INLINE
\
"
The
characters
may
be
inline
or
on
the
malloc
heap
.
"
#
define
MAYBE_OVERALLOCATED
\
"
Sometimes
over
-
allocated
to
simplify
string
concatenation
.
"
for
(
size_t
i
=
0
;
i
<
zStats
.
notableStrings
.
length
(
)
;
i
+
+
)
{
const
JS
:
:
NotableStringInfo
&
info
=
zStats
.
notableStrings
[
i
]
;
MOZ_ASSERT
(
!
zStats
.
isTotals
)
;
MOZ_ASSERT
(
!
anonymize
)
;
nsDependentCString
notableString
(
info
.
buffer
)
;
#
define
STRING_LENGTH
"
string
(
length
=
"
if
(
FindInReadable
(
NS_LITERAL_CSTRING
(
STRING_LENGTH
)
notableString
)
)
{
stringsNotableAboutMemoryGCHeap
+
=
info
.
gcHeapLatin1
;
stringsNotableAboutMemoryGCHeap
+
=
info
.
gcHeapTwoByte
;
stringsNotableAboutMemoryMallocHeap
+
=
info
.
mallocHeapLatin1
;
stringsNotableAboutMemoryMallocHeap
+
=
info
.
mallocHeapTwoByte
;
continue
;
}
nsCString
escapedString
(
notableString
)
;
escapedString
.
ReplaceSubstring
(
"
/
"
"
\
\
"
)
;
bool
truncated
=
notableString
.
Length
(
)
<
info
.
length
;
nsCString
path
=
pathPrefix
+
nsPrintfCString
(
"
strings
/
"
STRING_LENGTH
"
%
zu
copies
=
%
d
\
"
%
s
\
"
%
s
)
/
"
info
.
length
info
.
numCopies
escapedString
.
get
(
)
truncated
?
"
(
truncated
)
"
:
"
"
)
;
if
(
info
.
gcHeapLatin1
>
0
)
{
REPORT_GC_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
gc
-
heap
/
latin1
"
)
info
.
gcHeapLatin1
"
Latin1
strings
.
"
MAYBE_INLINE
)
;
}
if
(
info
.
gcHeapTwoByte
>
0
)
{
REPORT_GC_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
gc
-
heap
/
two
-
byte
"
)
info
.
gcHeapTwoByte
"
TwoByte
strings
.
"
MAYBE_INLINE
)
;
}
if
(
info
.
mallocHeapLatin1
>
0
)
{
REPORT_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
malloc
-
heap
/
latin1
"
)
KIND_HEAP
info
.
mallocHeapLatin1
"
Non
-
inline
Latin1
string
characters
.
"
MAYBE_OVERALLOCATED
)
;
}
if
(
info
.
mallocHeapTwoByte
>
0
)
{
REPORT_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
malloc
-
heap
/
two
-
byte
"
)
KIND_HEAP
info
.
mallocHeapTwoByte
"
Non
-
inline
TwoByte
string
characters
.
"
MAYBE_OVERALLOCATED
)
;
}
}
nsCString
nonNotablePath
=
pathPrefix
;
nonNotablePath
+
=
(
zStats
.
isTotals
|
|
anonymize
)
?
NS_LITERAL_CSTRING
(
"
strings
/
"
)
:
NS_LITERAL_CSTRING
(
"
strings
/
string
(
<
non
-
notable
strings
>
)
/
"
)
;
if
(
zStats
.
stringInfo
.
gcHeapLatin1
>
0
)
{
REPORT_GC_BYTES
(
nonNotablePath
+
NS_LITERAL_CSTRING
(
"
gc
-
heap
/
latin1
"
)
zStats
.
stringInfo
.
gcHeapLatin1
"
Latin1
strings
.
"
MAYBE_INLINE
)
;
}
if
(
zStats
.
stringInfo
.
gcHeapTwoByte
>
0
)
{
REPORT_GC_BYTES
(
nonNotablePath
+
NS_LITERAL_CSTRING
(
"
gc
-
heap
/
two
-
byte
"
)
zStats
.
stringInfo
.
gcHeapTwoByte
"
TwoByte
strings
.
"
MAYBE_INLINE
)
;
}
if
(
zStats
.
stringInfo
.
mallocHeapLatin1
>
0
)
{
REPORT_BYTES
(
nonNotablePath
+
NS_LITERAL_CSTRING
(
"
malloc
-
heap
/
latin1
"
)
KIND_HEAP
zStats
.
stringInfo
.
mallocHeapLatin1
"
Non
-
inline
Latin1
string
characters
.
"
MAYBE_OVERALLOCATED
)
;
}
if
(
zStats
.
stringInfo
.
mallocHeapTwoByte
>
0
)
{
REPORT_BYTES
(
nonNotablePath
+
NS_LITERAL_CSTRING
(
"
malloc
-
heap
/
two
-
byte
"
)
KIND_HEAP
zStats
.
stringInfo
.
mallocHeapTwoByte
"
Non
-
inline
TwoByte
string
characters
.
"
MAYBE_OVERALLOCATED
)
;
}
if
(
stringsNotableAboutMemoryGCHeap
>
0
)
{
MOZ_ASSERT
(
!
zStats
.
isTotals
)
;
REPORT_GC_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
strings
/
string
(
<
about
-
memory
>
)
/
gc
-
heap
"
)
stringsNotableAboutMemoryGCHeap
"
Strings
that
contain
the
characters
'
"
STRING_LENGTH
"
'
which
"
"
are
probably
from
about
:
memory
itself
.
"
MAYBE_INLINE
"
We
filter
them
out
rather
than
display
them
because
displaying
"
"
them
would
create
even
more
such
strings
every
time
about
:
memory
"
"
is
refreshed
.
"
)
;
}
if
(
stringsNotableAboutMemoryMallocHeap
>
0
)
{
MOZ_ASSERT
(
!
zStats
.
isTotals
)
;
REPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
strings
/
string
(
<
about
-
memory
>
)
/
malloc
-
heap
"
)
KIND_HEAP
stringsNotableAboutMemoryMallocHeap
"
Non
-
inline
string
characters
of
strings
that
contain
the
"
"
characters
'
"
STRING_LENGTH
"
'
which
are
probably
from
"
"
about
:
memory
itself
.
"
MAYBE_OVERALLOCATED
"
We
filter
them
out
rather
than
display
them
because
displaying
"
"
them
would
create
even
more
such
strings
every
time
about
:
memory
"
"
is
refreshed
.
"
)
;
}
const
JS
:
:
ShapeInfo
&
shapeInfo
=
zStats
.
shapeInfo
;
if
(
shapeInfo
.
shapesGCHeapTree
>
0
)
{
REPORT_GC_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
shapes
/
gc
-
heap
/
tree
"
)
shapeInfo
.
shapesGCHeapTree
"
Shapes
in
a
property
tree
.
"
)
;
}
if
(
shapeInfo
.
shapesGCHeapDict
>
0
)
{
REPORT_GC_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
shapes
/
gc
-
heap
/
dict
"
)
shapeInfo
.
shapesGCHeapDict
"
Shapes
in
dictionary
mode
.
"
)
;
}
if
(
shapeInfo
.
shapesGCHeapBase
>
0
)
{
REPORT_GC_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
shapes
/
gc
-
heap
/
base
"
)
shapeInfo
.
shapesGCHeapBase
"
Base
shapes
which
collate
data
common
to
many
shapes
.
"
)
;
}
if
(
shapeInfo
.
shapesMallocHeapTreeTables
>
0
)
{
REPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
shapes
/
malloc
-
heap
/
tree
-
tables
"
)
KIND_HEAP
shapeInfo
.
shapesMallocHeapTreeTables
"
Property
tables
of
shapes
in
a
property
tree
.
"
)
;
}
if
(
shapeInfo
.
shapesMallocHeapDictTables
>
0
)
{
REPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
shapes
/
malloc
-
heap
/
dict
-
tables
"
)
KIND_HEAP
shapeInfo
.
shapesMallocHeapDictTables
"
Property
tables
of
shapes
in
dictionary
mode
.
"
)
;
}
if
(
shapeInfo
.
shapesMallocHeapTreeKids
>
0
)
{
REPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
shapes
/
malloc
-
heap
/
tree
-
kids
"
)
KIND_HEAP
shapeInfo
.
shapesMallocHeapTreeKids
"
Kid
hashes
of
shapes
in
a
property
tree
.
"
)
;
}
if
(
sundriesGCHeap
>
0
)
{
REPORT_GC_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
sundries
/
gc
-
heap
"
)
sundriesGCHeap
"
The
sum
of
all
'
gc
-
heap
'
measurements
that
are
too
small
to
be
"
"
worth
showing
individually
.
"
)
;
}
if
(
sundriesMallocHeap
>
0
)
{
REPORT_BYTES
(
pathPrefix
+
NS_LITERAL_CSTRING
(
"
sundries
/
malloc
-
heap
"
)
KIND_HEAP
sundriesMallocHeap
"
The
sum
of
all
'
malloc
-
heap
'
measurements
that
are
too
small
to
"
"
be
worth
showing
individually
.
"
)
;
}
if
(
gcTotalOut
)
*
gcTotalOut
+
=
gcTotal
;
#
undef
STRING_LENGTH
}
static
void
ReportClassStats
(
const
ClassInfo
&
classInfo
const
nsACString
&
path
nsIHandleReportCallback
*
handleReport
nsISupports
*
data
size_t
&
gcTotal
)
{
if
(
classInfo
.
objectsGCHeap
>
0
)
{
REPORT_GC_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
objects
/
gc
-
heap
"
)
classInfo
.
objectsGCHeap
"
Objects
including
fixed
slots
.
"
)
;
}
if
(
classInfo
.
objectsMallocHeapSlots
>
0
)
{
REPORT_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
objects
/
malloc
-
heap
/
slots
"
)
KIND_HEAP
classInfo
.
objectsMallocHeapSlots
"
Non
-
fixed
object
slots
.
"
)
;
}
if
(
classInfo
.
objectsMallocHeapElementsNormal
>
0
)
{
REPORT_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
objects
/
malloc
-
heap
/
elements
/
normal
"
)
KIND_HEAP
classInfo
.
objectsMallocHeapElementsNormal
"
Normal
(
non
-
wasm
)
indexed
elements
.
"
)
;
}
if
(
classInfo
.
objectsMallocHeapElementsAsmJS
>
0
)
{
REPORT_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
objects
/
malloc
-
heap
/
elements
/
asm
.
js
"
)
KIND_HEAP
classInfo
.
objectsMallocHeapElementsAsmJS
"
asm
.
js
array
buffer
elements
allocated
in
the
malloc
heap
.
"
)
;
}
if
(
classInfo
.
objectsMallocHeapMisc
>
0
)
{
REPORT_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
objects
/
malloc
-
heap
/
misc
"
)
KIND_HEAP
classInfo
.
objectsMallocHeapMisc
"
Miscellaneous
object
data
.
"
)
;
}
if
(
classInfo
.
objectsNonHeapElementsNormal
>
0
)
{
REPORT_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
objects
/
non
-
heap
/
elements
/
normal
"
)
KIND_NONHEAP
classInfo
.
objectsNonHeapElementsNormal
"
Memory
-
mapped
non
-
shared
array
buffer
elements
.
"
)
;
}
if
(
classInfo
.
objectsNonHeapElementsShared
>
0
)
{
REPORT_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
objects
/
non
-
heap
/
elements
/
shared
"
)
KIND_NONHEAP
classInfo
.
objectsNonHeapElementsShared
"
Memory
-
mapped
shared
array
buffer
elements
.
These
elements
are
"
"
shared
between
one
or
more
runtimes
;
the
reported
size
is
divided
"
"
by
the
buffer
'
s
refcount
.
"
)
;
}
if
(
classInfo
.
objectsNonHeapElementsWasm
>
0
)
{
REPORT_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
objects
/
non
-
heap
/
elements
/
wasm
"
)
KIND_NONHEAP
classInfo
.
objectsNonHeapElementsWasm
"
wasm
/
asm
.
js
array
buffer
elements
allocated
outside
both
the
"
"
malloc
heap
and
the
GC
heap
.
"
)
;
}
if
(
classInfo
.
objectsNonHeapCodeWasm
>
0
)
{
REPORT_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
objects
/
non
-
heap
/
code
/
wasm
"
)
KIND_NONHEAP
classInfo
.
objectsNonHeapCodeWasm
"
AOT
-
compiled
wasm
/
asm
.
js
code
.
"
)
;
}
if
(
classInfo
.
wasmGuardPages
>
0
)
{
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
wasm
-
guard
-
pages
"
)
KIND_OTHER
classInfo
.
wasmGuardPages
"
Guard
pages
mapped
after
the
end
of
wasm
memories
reserved
for
"
"
optimization
tricks
but
not
committed
and
thus
never
contributing
"
"
to
RSS
only
vsize
.
"
)
;
}
}
static
void
ReportRealmStats
(
const
JS
:
:
RealmStats
&
realmStats
const
xpc
:
:
RealmStatsExtras
&
extras
nsIHandleReportCallback
*
handleReport
nsISupports
*
data
size_t
*
gcTotalOut
=
nullptr
)
{
static
const
nsDependentCString
addonPrefix
(
"
explicit
/
add
-
ons
/
"
)
;
size_t
gcTotal
=
0
sundriesGCHeap
=
0
sundriesMallocHeap
=
0
;
nsAutoCString
realmJSPathPrefix
(
extras
.
jsPathPrefix
)
;
nsAutoCString
realmDOMPathPrefix
(
extras
.
domPathPrefix
)
;
MOZ_ASSERT
(
!
gcTotalOut
=
=
realmStats
.
isTotals
)
;
nsCString
nonNotablePath
=
realmJSPathPrefix
;
nonNotablePath
+
=
realmStats
.
isTotals
?
NS_LITERAL_CSTRING
(
"
classes
/
"
)
:
NS_LITERAL_CSTRING
(
"
classes
/
class
(
<
non
-
notable
classes
>
)
/
"
)
;
ReportClassStats
(
realmStats
.
classInfo
nonNotablePath
handleReport
data
gcTotal
)
;
for
(
size_t
i
=
0
;
i
<
realmStats
.
notableClasses
.
length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
!
realmStats
.
isTotals
)
;
const
JS
:
:
NotableClassInfo
&
classInfo
=
realmStats
.
notableClasses
[
i
]
;
nsCString
classPath
=
realmJSPathPrefix
+
nsPrintfCString
(
"
classes
/
class
(
%
s
)
/
"
classInfo
.
className_
)
;
ReportClassStats
(
classInfo
classPath
handleReport
data
gcTotal
)
;
}
ZRREPORT_BYTES
(
realmDOMPathPrefix
+
NS_LITERAL_CSTRING
(
"
orphan
-
nodes
"
)
realmStats
.
objectsPrivate
"
Orphan
DOM
nodes
i
.
e
.
those
that
are
only
reachable
from
JavaScript
"
"
objects
.
"
)
;
ZRREPORT_GC_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
scripts
/
gc
-
heap
"
)
realmStats
.
scriptsGCHeap
"
JSScript
instances
.
There
is
one
per
user
-
defined
function
in
a
"
"
script
and
one
for
the
top
-
level
code
in
a
script
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
scripts
/
malloc
-
heap
/
data
"
)
realmStats
.
scriptsMallocHeapData
"
Various
variable
-
length
tables
in
JSScripts
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
baseline
/
data
"
)
realmStats
.
baselineData
"
The
Baseline
JIT
'
s
compilation
data
(
BaselineScripts
)
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
baseline
/
fallback
-
stubs
"
)
realmStats
.
baselineStubsFallback
"
The
Baseline
JIT
'
s
fallback
IC
stubs
(
excluding
code
)
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
ion
-
data
"
)
realmStats
.
ionData
"
The
IonMonkey
JIT
'
s
compilation
data
(
IonScripts
)
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
type
-
inference
/
type
-
scripts
"
)
realmStats
.
typeInferenceTypeScripts
"
Type
sets
associated
with
scripts
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
type
-
inference
/
allocation
-
site
-
tables
"
)
realmStats
.
typeInferenceAllocationSiteTables
"
Tables
of
type
objects
associated
with
allocation
sites
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
type
-
inference
/
array
-
type
-
tables
"
)
realmStats
.
typeInferenceArrayTypeTables
"
Tables
of
type
objects
associated
with
array
literals
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
type
-
inference
/
object
-
type
-
tables
"
)
realmStats
.
typeInferenceObjectTypeTables
"
Tables
of
type
objects
associated
with
object
literals
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
realm
-
object
"
)
realmStats
.
realmObject
"
The
JS
:
:
Realm
object
itself
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
realm
-
tables
"
)
realmStats
.
realmTables
"
Realm
-
wide
tables
storing
object
group
information
and
wasm
instances
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
inner
-
views
"
)
realmStats
.
innerViewsTable
"
The
table
for
array
buffer
inner
views
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
lazy
-
array
-
buffers
"
)
realmStats
.
lazyArrayBuffersTable
"
The
table
for
typed
object
lazy
array
buffers
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
object
-
metadata
"
)
realmStats
.
objectMetadataTable
"
The
table
used
by
debugging
tools
for
tracking
object
metadata
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
saved
-
stacks
-
set
"
)
realmStats
.
savedStacksSet
"
The
saved
stacks
set
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
non
-
syntactic
-
lexical
-
scopes
-
table
"
)
realmStats
.
nonSyntacticLexicalScopesTable
"
The
non
-
syntactic
lexical
scopes
table
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
jit
-
realm
"
)
realmStats
.
jitRealm
"
The
JIT
realm
.
"
)
;
ZRREPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
script
-
counts
-
map
"
)
realmStats
.
scriptCountsMap
"
Profiling
-
related
information
for
scripts
.
"
)
;
if
(
sundriesGCHeap
>
0
)
{
REPORT_GC_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
sundries
/
gc
-
heap
"
)
sundriesGCHeap
"
The
sum
of
all
'
gc
-
heap
'
measurements
that
are
too
small
to
be
"
"
worth
showing
individually
.
"
)
;
}
if
(
sundriesMallocHeap
>
0
)
{
REPORT_BYTES
(
realmJSPathPrefix
+
NS_LITERAL_CSTRING
(
"
sundries
/
malloc
-
heap
"
)
KIND_HEAP
sundriesMallocHeap
"
The
sum
of
all
'
malloc
-
heap
'
measurements
that
are
too
small
to
"
"
be
worth
showing
individually
.
"
)
;
}
if
(
gcTotalOut
)
*
gcTotalOut
+
=
gcTotal
;
}
static
void
ReportScriptSourceStats
(
const
ScriptSourceInfo
&
scriptSourceInfo
const
nsACString
&
path
nsIHandleReportCallback
*
handleReport
nsISupports
*
data
size_t
&
rtTotal
)
{
if
(
scriptSourceInfo
.
misc
>
0
)
{
RREPORT_BYTES
(
path
+
NS_LITERAL_CSTRING
(
"
misc
"
)
KIND_HEAP
scriptSourceInfo
.
misc
"
Miscellaneous
data
relating
to
JavaScript
source
code
.
"
)
;
}
}
void
ReportJSRuntimeExplicitTreeStats
(
const
JS
:
:
RuntimeStats
&
rtStats
const
nsACString
&
rtPath
nsIHandleReportCallback
*
handleReport
nsISupports
*
data
bool
anonymize
size_t
*
rtTotalOut
)
{
size_t
gcTotal
=
0
;
for
(
size_t
i
=
0
;
i
<
rtStats
.
zoneStatsVector
.
length
(
)
;
i
+
+
)
{
const
JS
:
:
ZoneStats
&
zStats
=
rtStats
.
zoneStatsVector
[
i
]
;
const
xpc
:
:
ZoneStatsExtras
*
extras
=
static_cast
<
const
xpc
:
:
ZoneStatsExtras
*
>
(
zStats
.
extra
)
;
ReportZoneStats
(
zStats
*
extras
handleReport
data
anonymize
&
gcTotal
)
;
}
for
(
size_t
i
=
0
;
i
<
rtStats
.
realmStatsVector
.
length
(
)
;
i
+
+
)
{
const
JS
:
:
RealmStats
&
realmStats
=
rtStats
.
realmStatsVector
[
i
]
;
const
xpc
:
:
RealmStatsExtras
*
extras
=
static_cast
<
const
xpc
:
:
RealmStatsExtras
*
>
(
realmStats
.
extra
)
;
ReportRealmStats
(
realmStats
*
extras
handleReport
data
&
gcTotal
)
;
}
size_t
rtTotal
=
0
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
runtime
-
object
"
)
KIND_HEAP
rtStats
.
runtime
.
object
"
The
JSRuntime
object
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
atoms
-
table
"
)
KIND_HEAP
rtStats
.
runtime
.
atomsTable
"
The
atoms
table
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
atoms
-
mark
-
bitmaps
"
)
KIND_HEAP
rtStats
.
runtime
.
atomsMarkBitmaps
"
Mark
bitmaps
for
atoms
held
by
each
zone
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
contexts
"
)
KIND_HEAP
rtStats
.
runtime
.
contexts
"
JSContext
objects
and
structures
that
belong
to
them
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
temporary
"
)
KIND_HEAP
rtStats
.
runtime
.
temporary
"
Transient
data
(
mostly
parse
nodes
)
held
by
the
JSRuntime
during
"
"
compilation
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
interpreter
-
stack
"
)
KIND_HEAP
rtStats
.
runtime
.
interpreterStack
"
JS
interpreter
frames
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
shared
-
immutable
-
strings
-
cache
"
)
KIND_HEAP
rtStats
.
runtime
.
sharedImmutableStringsCache
"
Immutable
strings
(
such
as
JS
scripts
'
source
text
)
shared
across
all
JSRuntimes
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
shared
-
intl
-
data
"
)
KIND_HEAP
rtStats
.
runtime
.
sharedIntlData
"
Shared
internationalization
data
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
uncompressed
-
source
-
cache
"
)
KIND_HEAP
rtStats
.
runtime
.
uncompressedSourceCache
"
The
uncompressed
source
code
cache
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
script
-
data
"
)
KIND_HEAP
rtStats
.
runtime
.
scriptData
"
The
table
holding
script
data
shared
in
the
runtime
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
tracelogger
"
)
KIND_HEAP
rtStats
.
runtime
.
tracelogger
"
The
memory
used
for
the
tracelogger
(
per
-
runtime
)
.
"
)
;
nsCString
nonNotablePath
=
rtPath
+
nsPrintfCString
(
"
runtime
/
script
-
sources
/
source
(
scripts
=
%
d
<
non
-
notable
files
>
)
/
"
rtStats
.
runtime
.
scriptSourceInfo
.
numScripts
)
;
ReportScriptSourceStats
(
rtStats
.
runtime
.
scriptSourceInfo
nonNotablePath
handleReport
data
rtTotal
)
;
for
(
size_t
i
=
0
;
i
<
rtStats
.
runtime
.
notableScriptSources
.
length
(
)
;
i
+
+
)
{
const
JS
:
:
NotableScriptSourceInfo
&
scriptSourceInfo
=
rtStats
.
runtime
.
notableScriptSources
[
i
]
;
nsCString
escapedFilename
;
if
(
anonymize
)
{
escapedFilename
.
AppendPrintf
(
"
<
anonymized
-
source
-
%
d
>
"
int
(
i
)
)
;
}
else
{
nsDependentCString
filename
(
scriptSourceInfo
.
filename_
)
;
escapedFilename
.
Append
(
filename
)
;
escapedFilename
.
ReplaceSubstring
(
"
/
"
"
\
\
"
)
;
}
nsCString
notablePath
=
rtPath
+
nsPrintfCString
(
"
runtime
/
script
-
sources
/
source
(
scripts
=
%
d
%
s
)
/
"
scriptSourceInfo
.
numScripts
escapedFilename
.
get
(
)
)
;
ReportScriptSourceStats
(
scriptSourceInfo
notablePath
handleReport
data
rtTotal
)
;
}
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
code
/
ion
"
)
KIND_NONHEAP
rtStats
.
runtime
.
code
.
ion
"
Code
generated
by
the
IonMonkey
JIT
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
code
/
baseline
"
)
KIND_NONHEAP
rtStats
.
runtime
.
code
.
baseline
"
Code
generated
by
the
Baseline
JIT
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
code
/
regexp
"
)
KIND_NONHEAP
rtStats
.
runtime
.
code
.
regexp
"
Code
generated
by
the
regexp
JIT
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
code
/
other
"
)
KIND_NONHEAP
rtStats
.
runtime
.
code
.
other
"
Code
generated
by
the
JITs
for
wrappers
and
trampolines
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
code
/
unused
"
)
KIND_NONHEAP
rtStats
.
runtime
.
code
.
unused
"
Memory
allocated
by
one
of
the
JITs
to
hold
code
but
which
is
"
"
currently
unused
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
gc
/
marker
"
)
KIND_HEAP
rtStats
.
runtime
.
gc
.
marker
"
The
GC
mark
stack
and
gray
roots
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
gc
/
nursery
-
committed
"
)
KIND_NONHEAP
rtStats
.
runtime
.
gc
.
nurseryCommitted
"
Memory
being
used
by
the
GC
'
s
nursery
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
gc
/
nursery
-
malloced
-
buffers
"
)
KIND_HEAP
rtStats
.
runtime
.
gc
.
nurseryMallocedBuffers
"
Out
-
of
-
line
slots
and
elements
belonging
to
objects
in
the
nursery
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
gc
/
store
-
buffer
/
vals
"
)
KIND_HEAP
rtStats
.
runtime
.
gc
.
storeBufferVals
"
Values
in
the
store
buffer
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
gc
/
store
-
buffer
/
cells
"
)
KIND_HEAP
rtStats
.
runtime
.
gc
.
storeBufferCells
"
Cells
in
the
store
buffer
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
gc
/
store
-
buffer
/
slots
"
)
KIND_HEAP
rtStats
.
runtime
.
gc
.
storeBufferSlots
"
Slots
in
the
store
buffer
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
gc
/
store
-
buffer
/
whole
-
cells
"
)
KIND_HEAP
rtStats
.
runtime
.
gc
.
storeBufferWholeCells
"
Whole
cells
in
the
store
buffer
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
gc
/
store
-
buffer
/
generics
"
)
KIND_HEAP
rtStats
.
runtime
.
gc
.
storeBufferGenerics
"
Generic
things
in
the
store
buffer
.
"
)
;
RREPORT_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
runtime
/
jit
-
lazylink
"
)
KIND_HEAP
rtStats
.
runtime
.
jitLazyLink
"
IonMonkey
compilations
waiting
for
lazy
linking
.
"
)
;
if
(
rtTotalOut
)
*
rtTotalOut
=
rtTotal
;
nsCString
rtPath2
(
rtPath
)
;
rtPath2
.
ReplaceLiteral
(
0
strlen
(
"
explicit
"
)
"
decommitted
"
)
;
REPORT_GC_BYTES
(
rtPath2
+
NS_LITERAL_CSTRING
(
"
gc
-
heap
/
decommitted
-
arenas
"
)
rtStats
.
gcHeapDecommittedArenas
"
GC
arenas
in
non
-
empty
chunks
that
is
decommitted
i
.
e
.
it
takes
up
"
"
address
space
but
no
physical
memory
or
swap
space
.
"
)
;
REPORT_GC_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
gc
-
heap
/
unused
-
chunks
"
)
rtStats
.
gcHeapUnusedChunks
"
Empty
GC
chunks
which
will
soon
be
released
unless
claimed
for
new
"
"
allocations
.
"
)
;
REPORT_GC_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
gc
-
heap
/
unused
-
arenas
"
)
rtStats
.
gcHeapUnusedArenas
"
Empty
GC
arenas
within
non
-
empty
chunks
.
"
)
;
REPORT_GC_BYTES
(
rtPath
+
NS_LITERAL_CSTRING
(
"
gc
-
heap
/
chunk
-
admin
"
)
rtStats
.
gcHeapChunkAdmin
"
Bookkeeping
information
within
GC
chunks
.
"
)
;
MOZ_ASSERT
(
gcTotal
=
=
rtStats
.
gcHeapChunkTotal
)
;
}
}
class
JSMainRuntimeRealmsReporter
final
:
public
nsIMemoryReporter
{
~
JSMainRuntimeRealmsReporter
(
)
{
}
public
:
NS_DECL_ISUPPORTS
struct
Data
{
int
anonymizeID
;
js
:
:
Vector
<
nsCString
0
js
:
:
SystemAllocPolicy
>
paths
;
}
;
static
void
RealmCallback
(
JSContext
*
cx
void
*
vdata
Handle
<
Realm
*
>
realm
)
{
Data
*
data
=
static_cast
<
Data
*
>
(
vdata
)
;
nsCString
path
;
GetRealmName
(
realm
path
&
data
-
>
anonymizeID
true
)
;
path
.
Insert
(
js
:
:
IsSystemRealm
(
realm
)
?
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
realms
/
system
/
"
)
:
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
realms
/
user
/
"
)
0
)
;
mozilla
:
:
Unused
<
<
data
-
>
paths
.
append
(
path
)
;
}
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
handleReport
nsISupports
*
data
bool
anonymize
)
override
{
Data
d
;
d
.
anonymizeID
=
anonymize
?
1
:
0
;
JS
:
:
IterateRealms
(
XPCJSContext
:
:
Get
(
)
-
>
Context
(
)
&
d
RealmCallback
)
;
for
(
size_t
i
=
0
;
i
<
d
.
paths
.
length
(
)
;
i
+
+
)
REPORT
(
nsCString
(
d
.
paths
[
i
]
)
KIND_OTHER
UNITS_COUNT
1
"
A
live
realm
in
the
main
JSRuntime
.
"
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
JSMainRuntimeRealmsReporter
nsIMemoryReporter
)
MOZ_DEFINE_MALLOC_SIZE_OF
(
OrphanMallocSizeOf
)
namespace
xpc
{
class
OrphanReporter
:
public
JS
:
:
ObjectPrivateVisitor
{
public
:
explicit
OrphanReporter
(
GetISupportsFun
aGetISupports
)
:
JS
:
:
ObjectPrivateVisitor
(
aGetISupports
)
mState
(
OrphanMallocSizeOf
)
{
}
virtual
size_t
sizeOfIncludingThis
(
nsISupports
*
aSupports
)
override
{
size_t
n
=
0
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aSupports
)
;
if
(
node
&
&
!
node
-
>
IsInComposedDoc
(
)
&
&
!
(
node
-
>
IsElement
(
)
&
&
node
-
>
AsElement
(
)
-
>
IsInNamespace
(
kNameSpaceID_XBL
)
)
)
{
nsCOMPtr
<
nsINode
>
orphanTree
=
node
-
>
SubtreeRoot
(
)
;
if
(
orphanTree
&
&
!
mState
.
HaveSeenPtr
(
orphanTree
.
get
(
)
)
)
{
n
+
=
SizeOfTreeIncludingThis
(
orphanTree
)
;
}
}
return
n
;
}
size_t
SizeOfTreeIncludingThis
(
nsINode
*
tree
)
{
size_t
nodeSize
=
0
;
nsWindowSizes
sizes
(
mState
)
;
tree
-
>
AddSizeOfIncludingThis
(
sizes
&
nodeSize
)
;
for
(
nsIContent
*
child
=
tree
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextNode
(
tree
)
)
child
-
>
AddSizeOfIncludingThis
(
sizes
&
nodeSize
)
;
return
nodeSize
+
sizes
.
getTotalSize
(
)
;
}
private
:
SizeOfState
mState
;
}
;
#
ifdef
DEBUG
static
bool
StartsWithExplicit
(
nsACString
&
s
)
{
return
StringBeginsWith
(
s
NS_LITERAL_CSTRING
(
"
explicit
/
"
)
)
;
}
#
endif
class
XPCJSRuntimeStats
:
public
JS
:
:
RuntimeStats
{
WindowPaths
*
mWindowPaths
;
WindowPaths
*
mTopWindowPaths
;
int
mAnonymizeID
;
public
:
XPCJSRuntimeStats
(
WindowPaths
*
windowPaths
WindowPaths
*
topWindowPaths
bool
anonymize
)
:
JS
:
:
RuntimeStats
(
JSMallocSizeOf
)
mWindowPaths
(
windowPaths
)
mTopWindowPaths
(
topWindowPaths
)
mAnonymizeID
(
anonymize
?
1
:
0
)
{
}
~
XPCJSRuntimeStats
(
)
{
for
(
size_t
i
=
0
;
i
!
=
realmStatsVector
.
length
(
)
;
+
+
i
)
delete
static_cast
<
xpc
:
:
RealmStatsExtras
*
>
(
realmStatsVector
[
i
]
.
extra
)
;
for
(
size_t
i
=
0
;
i
!
=
zoneStatsVector
.
length
(
)
;
+
+
i
)
delete
static_cast
<
xpc
:
:
ZoneStatsExtras
*
>
(
zoneStatsVector
[
i
]
.
extra
)
;
}
virtual
void
initExtraZoneStats
(
JS
:
:
Zone
*
zone
JS
:
:
ZoneStats
*
zStats
)
override
{
AutoSafeJSContext
cx
;
xpc
:
:
ZoneStatsExtras
*
extras
=
new
xpc
:
:
ZoneStatsExtras
;
extras
-
>
pathPrefix
.
AssignLiteral
(
"
explicit
/
js
-
non
-
window
/
zones
/
"
)
;
Rooted
<
Realm
*
>
realm
(
cx
js
:
:
GetAnyRealmInZone
(
zone
)
)
;
if
(
realm
)
{
RootedObject
global
(
cx
JS
:
:
GetRealmGlobalOrNull
(
realm
)
)
;
if
(
global
)
{
RefPtr
<
nsGlobalWindowInner
>
window
;
if
(
NS_SUCCEEDED
(
UNWRAP_OBJECT
(
Window
global
window
)
)
)
{
if
(
mTopWindowPaths
-
>
Get
(
window
-
>
WindowID
(
)
&
extras
-
>
pathPrefix
)
)
extras
-
>
pathPrefix
.
AppendLiteral
(
"
/
js
-
"
)
;
}
}
}
extras
-
>
pathPrefix
+
=
nsPrintfCString
(
"
zone
(
0x
%
p
)
/
"
(
void
*
)
zone
)
;
MOZ_ASSERT
(
StartsWithExplicit
(
extras
-
>
pathPrefix
)
)
;
zStats
-
>
extra
=
extras
;
}
virtual
void
initExtraRealmStats
(
Handle
<
Realm
*
>
realm
JS
:
:
RealmStats
*
realmStats
)
override
{
xpc
:
:
RealmStatsExtras
*
extras
=
new
xpc
:
:
RealmStatsExtras
;
nsCString
rName
;
GetRealmName
(
realm
rName
&
mAnonymizeID
true
)
;
AutoSafeJSContext
cx
;
bool
needZone
=
true
;
RootedObject
global
(
cx
JS
:
:
GetRealmGlobalOrNull
(
realm
)
)
;
if
(
global
)
{
RefPtr
<
nsGlobalWindowInner
>
window
;
if
(
NS_SUCCEEDED
(
UNWRAP_OBJECT
(
Window
global
window
)
)
)
{
if
(
mWindowPaths
-
>
Get
(
window
-
>
WindowID
(
)
&
extras
-
>
jsPathPrefix
)
)
{
extras
-
>
domPathPrefix
.
Assign
(
extras
-
>
jsPathPrefix
)
;
extras
-
>
domPathPrefix
.
AppendLiteral
(
"
/
dom
/
"
)
;
extras
-
>
jsPathPrefix
.
AppendLiteral
(
"
/
js
-
"
)
;
needZone
=
false
;
}
else
{
extras
-
>
jsPathPrefix
.
AssignLiteral
(
"
explicit
/
js
-
non
-
window
/
zones
/
"
)
;
extras
-
>
domPathPrefix
.
AssignLiteral
(
"
explicit
/
dom
/
unknown
-
window
-
global
?
!
/
"
)
;
}
}
else
{
extras
-
>
jsPathPrefix
.
AssignLiteral
(
"
explicit
/
js
-
non
-
window
/
zones
/
"
)
;
extras
-
>
domPathPrefix
.
AssignLiteral
(
"
explicit
/
dom
/
non
-
window
-
global
?
!
/
"
)
;
}
}
else
{
extras
-
>
jsPathPrefix
.
AssignLiteral
(
"
explicit
/
js
-
non
-
window
/
zones
/
"
)
;
extras
-
>
domPathPrefix
.
AssignLiteral
(
"
explicit
/
dom
/
no
-
global
?
!
/
"
)
;
}
if
(
needZone
)
extras
-
>
jsPathPrefix
+
=
nsPrintfCString
(
"
zone
(
0x
%
p
)
/
"
(
void
*
)
js
:
:
GetRealmZone
(
realm
)
)
;
extras
-
>
jsPathPrefix
+
=
NS_LITERAL_CSTRING
(
"
realm
(
"
)
+
rName
+
NS_LITERAL_CSTRING
(
"
)
/
"
)
;
MOZ_ASSERT
(
StartsWithExplicit
(
extras
-
>
jsPathPrefix
)
)
;
MOZ_ASSERT
(
StartsWithExplicit
(
extras
-
>
domPathPrefix
)
)
;
realmStats
-
>
extra
=
extras
;
}
}
;
void
JSReporter
:
:
CollectReports
(
WindowPaths
*
windowPaths
WindowPaths
*
topWindowPaths
nsIHandleReportCallback
*
handleReport
nsISupports
*
data
bool
anonymize
)
{
XPCJSRuntime
*
xpcrt
=
nsXPConnect
:
:
GetRuntimeInstance
(
)
;
XPCJSRuntimeStats
rtStats
(
windowPaths
topWindowPaths
anonymize
)
;
OrphanReporter
orphanReporter
(
XPCConvert
:
:
GetISupportsFromJSObject
)
;
JSContext
*
cx
=
XPCJSContext
:
:
Get
(
)
-
>
Context
(
)
;
if
(
!
JS
:
:
CollectRuntimeStats
(
cx
&
rtStats
&
orphanReporter
anonymize
)
)
{
return
;
}
JS
:
:
GlobalStats
gStats
(
JSMallocSizeOf
)
;
if
(
!
JS
:
:
CollectGlobalStats
(
&
gStats
)
)
return
;
size_t
xpcJSRuntimeSize
=
xpcrt
-
>
SizeOfIncludingThis
(
JSMallocSizeOf
)
;
size_t
wrappedJSSize
=
xpcrt
-
>
GetMultiCompartmentWrappedJSMap
(
)
-
>
SizeOfWrappedJS
(
JSMallocSizeOf
)
;
XPCWrappedNativeScope
:
:
ScopeSizeInfo
sizeInfo
(
JSMallocSizeOf
)
;
XPCWrappedNativeScope
:
:
AddSizeOfAllScopesIncludingThis
(
&
sizeInfo
)
;
mozJSComponentLoader
*
loader
=
mozJSComponentLoader
:
:
Get
(
)
;
size_t
jsComponentLoaderSize
=
loader
?
loader
-
>
SizeOfIncludingThis
(
JSMallocSizeOf
)
:
0
;
size_t
rtTotal
=
0
;
xpc
:
:
ReportJSRuntimeExplicitTreeStats
(
rtStats
NS_LITERAL_CSTRING
(
"
explicit
/
js
-
non
-
window
/
"
)
handleReport
data
anonymize
&
rtTotal
)
;
xpc
:
:
RealmStatsExtras
realmExtrasTotal
;
realmExtrasTotal
.
jsPathPrefix
.
AssignLiteral
(
"
js
-
main
-
runtime
/
realms
/
"
)
;
realmExtrasTotal
.
domPathPrefix
.
AssignLiteral
(
"
window
-
objects
/
dom
/
"
)
;
ReportRealmStats
(
rtStats
.
realmTotals
realmExtrasTotal
handleReport
data
)
;
xpc
:
:
ZoneStatsExtras
zExtrasTotal
;
zExtrasTotal
.
pathPrefix
.
AssignLiteral
(
"
js
-
main
-
runtime
/
zones
/
"
)
;
ReportZoneStats
(
rtStats
.
zTotals
zExtrasTotal
handleReport
data
anonymize
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
/
runtime
"
)
KIND_OTHER
rtTotal
"
The
sum
of
all
measurements
under
'
explicit
/
js
-
non
-
window
/
runtime
/
'
.
"
)
;
REPORT
(
NS_LITERAL_CSTRING
(
"
js
-
helper
-
threads
/
idle
"
)
KIND_OTHER
UNITS_COUNT
gStats
.
helperThread
.
idleThreadCount
"
The
current
number
of
idle
JS
HelperThreads
.
"
)
;
REPORT
(
NS_LITERAL_CSTRING
(
"
js
-
helper
-
threads
/
active
"
)
KIND_OTHER
UNITS_COUNT
gStats
.
helperThread
.
activeThreadCount
"
The
current
number
of
active
JS
HelperThreads
.
Memory
held
by
these
is
"
"
not
reported
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
wasm
-
runtime
"
)
KIND_OTHER
rtStats
.
runtime
.
wasmRuntime
"
The
memory
used
for
wasm
runtime
bookkeeping
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
/
gc
-
heap
/
unused
-
chunks
"
)
KIND_OTHER
rtStats
.
gcHeapUnusedChunks
"
The
same
as
'
explicit
/
js
-
non
-
window
/
gc
-
heap
/
unused
-
chunks
'
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
/
gc
-
heap
/
unused
-
arenas
"
)
KIND_OTHER
rtStats
.
gcHeapUnusedArenas
"
The
same
as
'
explicit
/
js
-
non
-
window
/
gc
-
heap
/
unused
-
arenas
'
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
/
gc
-
heap
/
chunk
-
admin
"
)
KIND_OTHER
rtStats
.
gcHeapChunkAdmin
"
The
same
as
'
explicit
/
js
-
non
-
window
/
gc
-
heap
/
chunk
-
admin
'
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
unused
/
chunks
"
)
KIND_OTHER
rtStats
.
gcHeapUnusedChunks
"
The
same
as
'
explicit
/
js
-
non
-
window
/
gc
-
heap
/
unused
-
chunks
'
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
unused
/
arenas
"
)
KIND_OTHER
rtStats
.
gcHeapUnusedArenas
"
The
same
as
'
explicit
/
js
-
non
-
window
/
gc
-
heap
/
unused
-
arenas
'
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
unused
/
gc
-
things
/
objects
"
)
KIND_OTHER
rtStats
.
zTotals
.
unusedGCThings
.
object
"
Unused
object
cells
within
non
-
empty
arenas
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
unused
/
gc
-
things
/
strings
"
)
KIND_OTHER
rtStats
.
zTotals
.
unusedGCThings
.
string
"
Unused
string
cells
within
non
-
empty
arenas
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
unused
/
gc
-
things
/
symbols
"
)
KIND_OTHER
rtStats
.
zTotals
.
unusedGCThings
.
symbol
"
Unused
symbol
cells
within
non
-
empty
arenas
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
unused
/
gc
-
things
/
shapes
"
)
KIND_OTHER
rtStats
.
zTotals
.
unusedGCThings
.
shape
"
Unused
shape
cells
within
non
-
empty
arenas
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
unused
/
gc
-
things
/
base
-
shapes
"
)
KIND_OTHER
rtStats
.
zTotals
.
unusedGCThings
.
baseShape
"
Unused
base
shape
cells
within
non
-
empty
arenas
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
unused
/
gc
-
things
/
object
-
groups
"
)
KIND_OTHER
rtStats
.
zTotals
.
unusedGCThings
.
objectGroup
"
Unused
object
group
cells
within
non
-
empty
arenas
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
unused
/
gc
-
things
/
scopes
"
)
KIND_OTHER
rtStats
.
zTotals
.
unusedGCThings
.
scope
"
Unused
scope
cells
within
non
-
empty
arenas
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
unused
/
gc
-
things
/
scripts
"
)
KIND_OTHER
rtStats
.
zTotals
.
unusedGCThings
.
script
"
Unused
script
cells
within
non
-
empty
arenas
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
unused
/
gc
-
things
/
lazy
-
scripts
"
)
KIND_OTHER
rtStats
.
zTotals
.
unusedGCThings
.
lazyScript
"
Unused
lazy
script
cells
within
non
-
empty
arenas
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
unused
/
gc
-
things
/
jitcode
"
)
KIND_OTHER
rtStats
.
zTotals
.
unusedGCThings
.
jitcode
"
Unused
jitcode
cells
within
non
-
empty
arenas
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
unused
/
gc
-
things
/
regexp
-
shareds
"
)
KIND_OTHER
rtStats
.
zTotals
.
unusedGCThings
.
regExpShared
"
Unused
regexpshared
cells
within
non
-
empty
arenas
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
used
/
chunk
-
admin
"
)
KIND_OTHER
rtStats
.
gcHeapChunkAdmin
"
The
same
as
'
explicit
/
js
-
non
-
window
/
gc
-
heap
/
chunk
-
admin
'
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
used
/
arena
-
admin
"
)
KIND_OTHER
rtStats
.
zTotals
.
gcHeapArenaAdmin
"
The
same
as
'
js
-
main
-
runtime
/
zones
/
gc
-
heap
-
arena
-
admin
'
.
"
)
;
size_t
gcThingTotal
=
0
;
MREPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
used
/
gc
-
things
/
objects
"
)
KIND_OTHER
rtStats
.
realmTotals
.
classInfo
.
objectsGCHeap
"
Used
object
cells
.
"
)
;
MREPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
used
/
gc
-
things
/
strings
"
)
KIND_OTHER
rtStats
.
zTotals
.
stringInfo
.
sizeOfLiveGCThings
(
)
"
Used
string
cells
.
"
)
;
MREPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
used
/
gc
-
things
/
symbols
"
)
KIND_OTHER
rtStats
.
zTotals
.
symbolsGCHeap
"
Used
symbol
cells
.
"
)
;
MREPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
used
/
gc
-
things
/
shapes
"
)
KIND_OTHER
rtStats
.
zTotals
.
shapeInfo
.
shapesGCHeapTree
+
rtStats
.
zTotals
.
shapeInfo
.
shapesGCHeapDict
"
Used
shape
cells
.
"
)
;
MREPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
used
/
gc
-
things
/
base
-
shapes
"
)
KIND_OTHER
rtStats
.
zTotals
.
shapeInfo
.
shapesGCHeapBase
"
Used
base
shape
cells
.
"
)
;
MREPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
used
/
gc
-
things
/
object
-
groups
"
)
KIND_OTHER
rtStats
.
zTotals
.
objectGroupsGCHeap
"
Used
object
group
cells
.
"
)
;
MREPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
used
/
gc
-
things
/
scopes
"
)
KIND_OTHER
rtStats
.
zTotals
.
scopesGCHeap
"
Used
scope
cells
.
"
)
;
MREPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
used
/
gc
-
things
/
scripts
"
)
KIND_OTHER
rtStats
.
realmTotals
.
scriptsGCHeap
"
Used
script
cells
.
"
)
;
MREPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
used
/
gc
-
things
/
lazy
-
scripts
"
)
KIND_OTHER
rtStats
.
zTotals
.
lazyScriptsGCHeap
"
Used
lazy
script
cells
.
"
)
;
MREPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
used
/
gc
-
things
/
jitcode
"
)
KIND_OTHER
rtStats
.
zTotals
.
jitCodesGCHeap
"
Used
jitcode
cells
.
"
)
;
MREPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
js
-
main
-
runtime
-
gc
-
heap
-
committed
/
used
/
gc
-
things
/
regexp
-
shareds
"
)
KIND_OTHER
rtStats
.
zTotals
.
regExpSharedsGCHeap
"
Used
regexpshared
cells
.
"
)
;
MOZ_ASSERT
(
gcThingTotal
=
=
rtStats
.
gcHeapGCThings
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
explicit
/
xpconnect
/
runtime
"
)
KIND_HEAP
xpcJSRuntimeSize
"
The
XPConnect
runtime
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
explicit
/
xpconnect
/
wrappedjs
"
)
KIND_HEAP
wrappedJSSize
"
Wrappers
used
to
implement
XPIDL
interfaces
with
JS
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
explicit
/
xpconnect
/
scopes
"
)
KIND_HEAP
sizeInfo
.
mScopeAndMapSize
"
XPConnect
scopes
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
explicit
/
xpconnect
/
proto
-
iface
-
cache
"
)
KIND_HEAP
sizeInfo
.
mProtoAndIfaceCacheSize
"
Prototype
and
interface
binding
caches
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
explicit
/
xpconnect
/
js
-
component
-
loader
"
)
KIND_HEAP
jsComponentLoaderSize
"
XPConnect
'
s
JS
component
loader
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
explicit
/
js
-
non
-
window
/
tracelogger
"
)
KIND_HEAP
gStats
.
tracelogger
"
The
memory
used
for
the
tracelogger
including
the
graph
and
events
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
explicit
/
js
-
non
-
window
/
helper
-
thread
/
heap
-
other
"
)
KIND_HEAP
gStats
.
helperThread
.
stateData
"
Memory
used
by
HelperThreadState
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
explicit
/
js
-
non
-
window
/
helper
-
thread
/
parse
-
task
"
)
KIND_HEAP
gStats
.
helperThread
.
parseTask
"
The
memory
used
by
ParseTasks
waiting
in
HelperThreadState
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
explicit
/
js
-
non
-
window
/
helper
-
thread
/
ion
-
builder
"
)
KIND_HEAP
gStats
.
helperThread
.
ionBuilder
"
The
memory
used
by
IonBuilders
waiting
in
HelperThreadState
.
"
)
;
REPORT_BYTES
(
NS_LITERAL_CSTRING
(
"
explicit
/
js
-
non
-
window
/
helper
-
thread
/
wasm
-
compile
"
)
KIND_HEAP
gStats
.
helperThread
.
parseTask
"
The
memory
used
by
Wasm
compilations
waiting
in
HelperThreadState
.
"
)
;
}
static
nsresult
JSSizeOfTab
(
JSObject
*
objArg
size_t
*
jsObjectsSize
size_t
*
jsStringsSize
size_t
*
jsPrivateSize
size_t
*
jsOtherSize
)
{
JSContext
*
cx
=
XPCJSContext
:
:
Get
(
)
-
>
Context
(
)
;
JS
:
:
RootedObject
obj
(
cx
objArg
)
;
TabSizes
sizes
;
OrphanReporter
orphanReporter
(
XPCConvert
:
:
GetISupportsFromJSObject
)
;
NS_ENSURE_TRUE
(
JS
:
:
AddSizeOfTab
(
cx
obj
moz_malloc_size_of
&
orphanReporter
&
sizes
)
NS_ERROR_OUT_OF_MEMORY
)
;
*
jsObjectsSize
=
sizes
.
objects
;
*
jsStringsSize
=
sizes
.
strings
;
*
jsPrivateSize
=
sizes
.
private_
;
*
jsOtherSize
=
sizes
.
other
;
return
NS_OK
;
}
}
static
void
AccumulateTelemetryCallback
(
int
id
uint32_t
sample
const
char
*
key
)
{
switch
(
id
)
{
case
JS_TELEMETRY_GC_REASON
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_REASON_2
sample
)
;
break
;
case
JS_TELEMETRY_GC_IS_ZONE_GC
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_IS_COMPARTMENTAL
sample
)
;
break
;
case
JS_TELEMETRY_GC_MS
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_MS
sample
)
;
break
;
case
JS_TELEMETRY_GC_BUDGET_MS
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_BUDGET_MS
sample
)
;
break
;
case
JS_TELEMETRY_GC_BUDGET_OVERRUN
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_BUDGET_OVERRUN
sample
)
;
break
;
case
JS_TELEMETRY_GC_ANIMATION_MS
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_ANIMATION_MS
sample
)
;
break
;
case
JS_TELEMETRY_GC_MAX_PAUSE_MS_2
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_MAX_PAUSE_MS_2
sample
)
;
break
;
case
JS_TELEMETRY_GC_MARK_MS
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_MARK_MS
sample
)
;
break
;
case
JS_TELEMETRY_GC_SWEEP_MS
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_SWEEP_MS
sample
)
;
break
;
case
JS_TELEMETRY_GC_COMPACT_MS
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_COMPACT_MS
sample
)
;
break
;
case
JS_TELEMETRY_GC_MARK_ROOTS_MS
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_MARK_ROOTS_MS
sample
)
;
break
;
case
JS_TELEMETRY_GC_MARK_GRAY_MS
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_MARK_GRAY_MS
sample
)
;
break
;
case
JS_TELEMETRY_GC_SLICE_MS
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_SLICE_MS
sample
)
;
break
;
case
JS_TELEMETRY_GC_SLOW_PHASE
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_SLOW_PHASE
sample
)
;
break
;
case
JS_TELEMETRY_GC_SLOW_TASK
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_SLOW_TASK
sample
)
;
break
;
case
JS_TELEMETRY_GC_MMU_50
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_MMU_50
sample
)
;
break
;
case
JS_TELEMETRY_GC_RESET
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_RESET
sample
)
;
break
;
case
JS_TELEMETRY_GC_RESET_REASON
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_RESET_REASON
sample
)
;
break
;
case
JS_TELEMETRY_GC_INCREMENTAL_DISABLED
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_INCREMENTAL_DISABLED
sample
)
;
break
;
case
JS_TELEMETRY_GC_NON_INCREMENTAL
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_NON_INCREMENTAL
sample
)
;
break
;
case
JS_TELEMETRY_GC_NON_INCREMENTAL_REASON
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_NON_INCREMENTAL_REASON
sample
)
;
break
;
case
JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_SCC_SWEEP_TOTAL_MS
sample
)
;
break
;
case
JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_SCC_SWEEP_MAX_PAUSE_MS
sample
)
;
break
;
case
JS_TELEMETRY_GC_MINOR_REASON
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_MINOR_REASON
sample
)
;
break
;
case
JS_TELEMETRY_GC_MINOR_REASON_LONG
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_MINOR_REASON_LONG
sample
)
;
break
;
case
JS_TELEMETRY_GC_MINOR_US
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_MINOR_US
sample
)
;
break
;
case
JS_TELEMETRY_GC_NURSERY_BYTES
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_NURSERY_BYTES
sample
)
;
break
;
case
JS_TELEMETRY_GC_PRETENURE_COUNT
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_PRETENURE_COUNT
sample
)
;
break
;
case
JS_TELEMETRY_PRIVILEGED_PARSER_COMPILE_LAZY_AFTER_MS
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
JS_PRIVILEGED_PARSER_COMPILE_LAZY_AFTER_MS
sample
)
;
break
;
case
JS_TELEMETRY_WEB_PARSER_COMPILE_LAZY_AFTER_MS
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
JS_WEB_PARSER_COMPILE_LAZY_AFTER_MS
sample
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
JS_TELEMETRY
id
"
)
;
}
}
static
void
SetUseCounterCallback
(
JSObject
*
obj
JSUseCounter
counter
)
{
switch
(
counter
)
{
case
JSUseCounter
:
:
ASMJS
:
SetDocumentAndPageUseCounter
(
obj
eUseCounter_custom_JS_asmjs
)
;
break
;
case
JSUseCounter
:
:
WASM
:
SetDocumentAndPageUseCounter
(
obj
eUseCounter_custom_JS_wasm
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
JSUseCounter
id
"
)
;
}
}
static
void
GetRealmNameCallback
(
JSContext
*
cx
Handle
<
Realm
*
>
realm
char
*
buf
size_t
bufsize
)
{
nsCString
name
;
int
anonymizeID
=
0
;
GetRealmName
(
realm
name
&
anonymizeID
false
)
;
if
(
name
.
Length
(
)
>
=
bufsize
)
name
.
Truncate
(
bufsize
-
1
)
;
memcpy
(
buf
name
.
get
(
)
name
.
Length
(
)
+
1
)
;
}
static
void
DestroyRealm
(
JSFreeOp
*
fop
JS
:
:
Realm
*
realm
)
{
mozilla
:
:
UniquePtr
<
RealmPrivate
>
priv
(
RealmPrivate
:
:
Get
(
realm
)
)
;
JS
:
:
SetRealmPrivate
(
realm
nullptr
)
;
}
static
bool
PreserveWrapper
(
JSContext
*
cx
JSObject
*
obj
)
{
MOZ_ASSERT
(
cx
)
;
MOZ_ASSERT
(
obj
)
;
MOZ_ASSERT
(
IS_WN_REFLECTOR
(
obj
)
|
|
mozilla
:
:
dom
:
:
IsDOMObject
(
obj
)
)
;
return
mozilla
:
:
dom
:
:
IsDOMObject
(
obj
)
&
&
mozilla
:
:
dom
:
:
TryPreserveWrapper
(
obj
)
;
}
static
nsresult
ReadSourceFromFilename
(
JSContext
*
cx
const
char
*
filename
char16_t
*
*
src
size_t
*
len
)
{
nsresult
rv
;
const
char
*
arrow
;
while
(
(
arrow
=
strstr
(
filename
"
-
>
"
)
)
)
filename
=
arrow
+
strlen
(
"
-
>
"
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
filename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIChannel
>
scriptChannel
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
scriptChannel
)
uri
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
actualUri
;
rv
=
scriptChannel
-
>
GetURI
(
getter_AddRefs
(
actualUri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCString
scheme
;
rv
=
actualUri
-
>
GetScheme
(
scheme
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
scheme
.
EqualsLiteral
(
"
file
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
jar
"
)
)
return
NS_OK
;
scriptChannel
-
>
SetContentType
(
NS_LITERAL_CSTRING
(
"
text
/
plain
"
)
)
;
nsCOMPtr
<
nsIInputStream
>
scriptStream
;
rv
=
scriptChannel
-
>
Open2
(
getter_AddRefs
(
scriptStream
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint64_t
rawLen
;
rv
=
scriptStream
-
>
Available
(
&
rawLen
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
rawLen
)
return
NS_ERROR_FAILURE
;
if
(
rawLen
>
UINT32_MAX
)
return
NS_ERROR_FILE_TOO_BIG
;
auto
buf
=
MakeUniqueFallible
<
unsigned
char
[
]
>
(
rawLen
)
;
if
(
!
buf
)
return
NS_ERROR_OUT_OF_MEMORY
;
unsigned
char
*
ptr
=
buf
.
get
(
)
;
unsigned
char
*
end
=
ptr
+
rawLen
;
while
(
ptr
<
end
)
{
uint32_t
bytesRead
;
rv
=
scriptStream
-
>
Read
(
reinterpret_cast
<
char
*
>
(
ptr
)
end
-
ptr
&
bytesRead
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
MOZ_ASSERT
(
bytesRead
>
0
"
stream
promised
more
bytes
before
EOF
"
)
;
ptr
+
=
bytesRead
;
}
rv
=
ScriptLoader
:
:
ConvertToUTF16
(
scriptChannel
buf
.
get
(
)
rawLen
EmptyString
(
)
nullptr
*
src
*
len
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
*
src
)
return
NS_ERROR_FAILURE
;
JS_updateMallocCounter
(
cx
*
len
)
;
return
NS_OK
;
}
class
XPCJSSourceHook
:
public
js
:
:
SourceHook
{
bool
load
(
JSContext
*
cx
const
char
*
filename
char16_t
*
*
src
size_t
*
length
)
override
{
*
src
=
nullptr
;
*
length
=
0
;
if
(
!
nsContentUtils
:
:
IsSystemCaller
(
cx
)
)
return
true
;
if
(
!
filename
)
return
true
;
nsresult
rv
=
ReadSourceFromFilename
(
cx
filename
src
length
)
;
if
(
NS_FAILED
(
rv
)
)
{
xpc
:
:
Throw
(
cx
rv
)
;
return
false
;
}
return
true
;
}
}
;
static
const
JSWrapObjectCallbacks
WrapObjectCallbacks
=
{
xpc
:
:
WrapperFactory
:
:
Rewrap
xpc
:
:
WrapperFactory
:
:
PrepareForWrapping
}
;
XPCJSRuntime
:
:
XPCJSRuntime
(
JSContext
*
aCx
)
:
CycleCollectedJSRuntime
(
aCx
)
mWrappedJSMap
(
JSObject2WrappedJSMap
:
:
newMap
(
XPC_JS_MAP_LENGTH
)
)
mWrappedJSClassMap
(
IID2WrappedJSClassMap
:
:
newMap
(
XPC_JS_CLASS_MAP_LENGTH
)
)
mIID2NativeInterfaceMap
(
IID2NativeInterfaceMap
:
:
newMap
(
XPC_NATIVE_INTERFACE_MAP_LENGTH
)
)
mClassInfo2NativeSetMap
(
ClassInfo2NativeSetMap
:
:
newMap
(
XPC_NATIVE_SET_MAP_LENGTH
)
)
mNativeSetMap
(
NativeSetMap
:
:
newMap
(
XPC_NATIVE_SET_MAP_LENGTH
)
)
mDyingWrappedNativeProtoMap
(
XPCWrappedNativeProtoMap
:
:
newMap
(
XPC_DYING_NATIVE_PROTO_MAP_LENGTH
)
)
mGCIsRunning
(
false
)
mNativesToReleaseArray
(
)
mDoingFinalization
(
false
)
mVariantRoots
(
nullptr
)
mWrappedJSRoots
(
nullptr
)
mAsyncSnowWhiteFreer
(
new
AsyncFreeSnowWhite
(
)
)
{
MOZ_COUNT_CTOR_INHERITED
(
XPCJSRuntime
CycleCollectedJSRuntime
)
;
}
XPCJSRuntime
*
XPCJSRuntime
:
:
Get
(
)
{
return
nsXPConnect
:
:
GetRuntimeInstance
(
)
;
}
namespace
JS
{
namespace
ubi
{
class
ReflectorNode
:
public
Concrete
<
JSObject
>
{
protected
:
explicit
ReflectorNode
(
JSObject
*
ptr
)
:
Concrete
<
JSObject
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
JSObject
*
ptr
)
{
new
(
storage
)
ReflectorNode
(
ptr
)
;
}
js
:
:
UniquePtr
<
JS
:
:
ubi
:
:
EdgeRange
>
edges
(
JSContext
*
cx
bool
wantNames
)
const
override
;
}
;
js
:
:
UniquePtr
<
EdgeRange
>
ReflectorNode
:
:
edges
(
JSContext
*
cx
bool
wantNames
)
const
{
js
:
:
UniquePtr
<
SimpleEdgeRange
>
range
(
static_cast
<
SimpleEdgeRange
*
>
(
Concrete
<
JSObject
>
:
:
edges
(
cx
wantNames
)
.
release
(
)
)
)
;
if
(
!
range
)
{
return
nullptr
;
}
nsISupports
*
supp
=
UnwrapDOMObjectToISupports
(
&
get
(
)
)
;
if
(
supp
)
{
nsCOMPtr
<
nsINode
>
node
;
UNWRAP_OBJECT
(
Node
&
get
(
)
node
)
;
if
(
node
)
{
char16_t
*
edgeName
=
nullptr
;
if
(
wantNames
)
{
edgeName
=
NS_strdup
(
u
"
Reflected
Node
"
)
;
}
if
(
!
range
-
>
addEdge
(
Edge
(
edgeName
node
.
get
(
)
)
)
)
{
return
nullptr
;
}
}
}
return
range
;
}
}
}
void
ConstructUbiNode
(
void
*
storage
JSObject
*
ptr
)
{
JS
:
:
ubi
:
:
ReflectorNode
:
:
construct
(
storage
ptr
)
;
}
void
XPCJSRuntime
:
:
Initialize
(
JSContext
*
cx
)
{
mUnprivilegedJunkScope
.
init
(
cx
nullptr
)
;
mLoaderGlobal
.
init
(
cx
nullptr
)
;
mStrIDs
[
0
]
=
JSID_VOID
;
JS_SetGCParameter
(
cx
JSGC_MAX_BYTES
0xffffffff
)
;
JS_SetDestroyCompartmentCallback
(
cx
CompartmentDestroyedCallback
)
;
JS_SetSizeOfIncludingThisCompartmentCallback
(
cx
CompartmentSizeOfIncludingThisCallback
)
;
JS
:
:
SetDestroyRealmCallback
(
cx
DestroyRealm
)
;
JS
:
:
SetRealmNameCallback
(
cx
GetRealmNameCallback
)
;
mPrevGCSliceCallback
=
JS
:
:
SetGCSliceCallback
(
cx
GCSliceCallback
)
;
mPrevDoCycleCollectionCallback
=
JS
:
:
SetDoCycleCollectionCallback
(
cx
DoCycleCollectionCallback
)
;
JS_AddFinalizeCallback
(
cx
FinalizeCallback
nullptr
)
;
JS_AddWeakPointerZonesCallback
(
cx
WeakPointerZonesCallback
this
)
;
JS_AddWeakPointerCompartmentCallback
(
cx
WeakPointerCompartmentCallback
this
)
;
JS_SetWrapObjectCallbacks
(
cx
&
WrapObjectCallbacks
)
;
js
:
:
SetPreserveWrapperCallback
(
cx
PreserveWrapper
)
;
JS_InitReadPrincipalsCallback
(
cx
nsJSPrincipals
:
:
ReadPrincipals
)
;
JS_SetAccumulateTelemetryCallback
(
cx
AccumulateTelemetryCallback
)
;
JS_SetSetUseCounterCallback
(
cx
SetUseCounterCallback
)
;
js
:
:
SetWindowProxyClass
(
cx
&
OuterWindowProxyClass
)
;
js
:
:
SetXrayJitInfo
(
&
gXrayJitInfo
)
;
JS
:
:
SetProcessLargeAllocationFailureCallback
(
OnLargeAllocationFailureCallback
)
;
mozilla
:
:
UniquePtr
<
XPCJSSourceHook
>
hook
(
new
XPCJSSourceHook
)
;
js
:
:
SetSourceHook
(
cx
std
:
:
move
(
hook
)
)
;
RegisterStrongMemoryReporter
(
new
JSMainRuntimeRealmsReporter
(
)
)
;
RegisterStrongMemoryReporter
(
new
JSMainRuntimeTemporaryPeakReporter
(
)
)
;
RegisterJSMainRuntimeGCHeapDistinguishedAmount
(
JSMainRuntimeGCHeapDistinguishedAmount
)
;
RegisterJSMainRuntimeTemporaryPeakDistinguishedAmount
(
JSMainRuntimeTemporaryPeakDistinguishedAmount
)
;
RegisterJSMainRuntimeRealmsSystemDistinguishedAmount
(
JSMainRuntimeRealmsSystemDistinguishedAmount
)
;
RegisterJSMainRuntimeRealmsUserDistinguishedAmount
(
JSMainRuntimeRealmsUserDistinguishedAmount
)
;
mozilla
:
:
RegisterJSSizeOfTab
(
JSSizeOfTab
)
;
JS
:
:
ubi
:
:
SetConstructUbiNodeForDOMObjectCallback
(
cx
&
ConstructUbiNode
)
;
xpc_LocalizeRuntime
(
JS_GetRuntime
(
cx
)
)
;
}
bool
XPCJSRuntime
:
:
InitializeStrings
(
JSContext
*
cx
)
{
JSAutoRequest
ar
(
cx
)
;
if
(
JSID_IS_VOID
(
mStrIDs
[
0
]
)
)
{
RootedString
str
(
cx
)
;
for
(
unsigned
i
=
0
;
i
<
XPCJSContext
:
:
IDX_TOTAL_COUNT
;
i
+
+
)
{
str
=
JS_AtomizeAndPinString
(
cx
mStrings
[
i
]
)
;
if
(
!
str
)
{
mStrIDs
[
0
]
=
JSID_VOID
;
return
false
;
}
mStrIDs
[
i
]
=
INTERNED_STRING_TO_JSID
(
cx
str
)
;
mStrJSVals
[
i
]
.
setString
(
str
)
;
}
if
(
!
mozilla
:
:
dom
:
:
DefineStaticJSVals
(
cx
)
)
{
return
false
;
}
}
return
true
;
}
bool
XPCJSRuntime
:
:
DescribeCustomObjects
(
JSObject
*
obj
const
js
:
:
Class
*
clasp
char
(
&
name
)
[
72
]
)
const
{
if
(
clasp
!
=
&
XPC_WN_Proto_JSClass
)
{
return
false
;
}
XPCWrappedNativeProto
*
p
=
static_cast
<
XPCWrappedNativeProto
*
>
(
xpc_GetJSPrivate
(
obj
)
)
;
nsCOMPtr
<
nsIXPCScriptable
>
scr
=
p
-
>
GetScriptable
(
)
;
if
(
!
scr
)
{
return
false
;
}
SprintfLiteral
(
name
"
JS
Object
(
%
s
-
%
s
)
"
clasp
-
>
name
scr
-
>
GetJSClass
(
)
-
>
name
)
;
return
true
;
}
bool
XPCJSRuntime
:
:
NoteCustomGCThingXPCOMChildren
(
const
js
:
:
Class
*
clasp
JSObject
*
obj
nsCycleCollectionTraversalCallback
&
cb
)
const
{
if
(
clasp
!
=
&
XPC_WN_Tearoff_JSClass
)
{
return
false
;
}
XPCWrappedNativeTearOff
*
to
=
static_cast
<
XPCWrappedNativeTearOff
*
>
(
xpc_GetJSPrivate
(
obj
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
xpc_GetJSPrivate
(
obj
)
-
>
mNative
"
)
;
cb
.
NoteXPCOMChild
(
to
-
>
GetNative
(
)
)
;
return
true
;
}
void
XPCJSRuntime
:
:
DebugDump
(
int16_t
depth
)
{
#
ifdef
DEBUG
depth
-
-
;
XPC_LOG_ALWAYS
(
(
"
XPCJSRuntime
%
p
"
this
)
)
;
XPC_LOG_INDENT
(
)
;
XPC_LOG_ALWAYS
(
(
"
mWrappedJSClassMap
%
p
with
%
d
wrapperclasses
(
s
)
"
mWrappedJSClassMap
mWrappedJSClassMap
-
>
Count
(
)
)
)
;
if
(
depth
&
&
mWrappedJSClassMap
-
>
Count
(
)
)
{
XPC_LOG_INDENT
(
)
;
for
(
auto
i
=
mWrappedJSClassMap
-
>
Iter
(
)
;
!
i
.
Done
(
)
;
i
.
Next
(
)
)
{
auto
entry
=
static_cast
<
IID2WrappedJSClassMap
:
:
Entry
*
>
(
i
.
Get
(
)
)
;
entry
-
>
value
-
>
DebugDump
(
depth
)
;
}
XPC_LOG_OUTDENT
(
)
;
}
XPC_LOG_ALWAYS
(
(
"
mWrappedJSMap
%
p
with
%
d
wrappers
(
s
)
"
mWrappedJSMap
mWrappedJSMap
-
>
Count
(
)
)
)
;
if
(
depth
&
&
mWrappedJSMap
-
>
Count
(
)
)
{
XPC_LOG_INDENT
(
)
;
mWrappedJSMap
-
>
Dump
(
depth
)
;
XPC_LOG_OUTDENT
(
)
;
}
XPC_LOG_ALWAYS
(
(
"
mIID2NativeInterfaceMap
%
p
with
%
d
interface
(
s
)
"
mIID2NativeInterfaceMap
mIID2NativeInterfaceMap
-
>
Count
(
)
)
)
;
XPC_LOG_ALWAYS
(
(
"
mClassInfo2NativeSetMap
%
p
with
%
d
sets
(
s
)
"
mClassInfo2NativeSetMap
mClassInfo2NativeSetMap
-
>
Count
(
)
)
)
;
XPC_LOG_ALWAYS
(
(
"
mNativeSetMap
%
p
with
%
d
sets
(
s
)
"
mNativeSetMap
mNativeSetMap
-
>
Count
(
)
)
)
;
if
(
depth
&
&
mNativeSetMap
-
>
Count
(
)
)
{
XPC_LOG_INDENT
(
)
;
for
(
auto
i
=
mNativeSetMap
-
>
Iter
(
)
;
!
i
.
Done
(
)
;
i
.
Next
(
)
)
{
auto
entry
=
static_cast
<
NativeSetMap
:
:
Entry
*
>
(
i
.
Get
(
)
)
;
entry
-
>
key_value
-
>
DebugDump
(
depth
)
;
}
XPC_LOG_OUTDENT
(
)
;
}
XPC_LOG_OUTDENT
(
)
;
#
endif
}
void
XPCRootSetElem
:
:
AddToRootSet
(
XPCRootSetElem
*
*
listHead
)
{
MOZ_ASSERT
(
!
mSelfp
"
Must
be
not
linked
"
)
;
mSelfp
=
listHead
;
mNext
=
*
listHead
;
if
(
mNext
)
{
MOZ_ASSERT
(
mNext
-
>
mSelfp
=
=
listHead
"
Must
be
list
start
"
)
;
mNext
-
>
mSelfp
=
&
mNext
;
}
*
listHead
=
this
;
}
void
XPCRootSetElem
:
:
RemoveFromRootSet
(
)
{
JS
:
:
NotifyGCRootsRemoved
(
XPCJSContext
:
:
Get
(
)
-
>
Context
(
)
)
;
MOZ_ASSERT
(
mSelfp
"
Must
be
linked
"
)
;
MOZ_ASSERT
(
*
mSelfp
=
=
this
"
Link
invariant
"
)
;
*
mSelfp
=
mNext
;
if
(
mNext
)
mNext
-
>
mSelfp
=
mSelfp
;
#
ifdef
DEBUG
mSelfp
=
nullptr
;
mNext
=
nullptr
;
#
endif
}
void
XPCJSRuntime
:
:
AddGCCallback
(
xpcGCCallback
cb
)
{
MOZ_ASSERT
(
cb
"
null
callback
"
)
;
extraGCCallbacks
.
AppendElement
(
cb
)
;
}
void
XPCJSRuntime
:
:
RemoveGCCallback
(
xpcGCCallback
cb
)
{
MOZ_ASSERT
(
cb
"
null
callback
"
)
;
bool
found
=
extraGCCallbacks
.
RemoveElement
(
cb
)
;
if
(
!
found
)
{
NS_ERROR
(
"
Removing
a
callback
which
was
never
added
.
"
)
;
}
}
void
XPCJSRuntime
:
:
InitSingletonScopes
(
)
{
JSContext
*
cx
=
XPCJSContext
:
:
Get
(
)
-
>
Context
(
)
;
JSAutoRequest
ar
(
cx
)
;
RootedValue
v
(
cx
)
;
nsresult
rv
;
SandboxOptions
unprivilegedJunkScopeOptions
;
unprivilegedJunkScopeOptions
.
sandboxName
.
AssignLiteral
(
"
XPConnect
Junk
Compartment
"
)
;
unprivilegedJunkScopeOptions
.
invisibleToDebugger
=
true
;
rv
=
CreateSandboxObject
(
cx
&
v
nullptr
unprivilegedJunkScopeOptions
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
mUnprivilegedJunkScope
=
js
:
:
UncheckedUnwrap
(
&
v
.
toObject
(
)
)
;
}
void
XPCJSRuntime
:
:
DeleteSingletonScopes
(
)
{
RefPtr
<
SandboxPrivate
>
sandbox
=
SandboxPrivate
:
:
GetPrivate
(
mUnprivilegedJunkScope
)
;
sandbox
-
>
ReleaseWrapper
(
sandbox
)
;
mUnprivilegedJunkScope
=
nullptr
;
mLoaderGlobal
=
nullptr
;
}
JSObject
*
XPCJSRuntime
:
:
LoaderGlobal
(
)
{
if
(
!
mLoaderGlobal
)
{
RefPtr
<
mozJSComponentLoader
>
loader
=
mozJSComponentLoader
:
:
GetOrCreate
(
)
;
dom
:
:
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
mLoaderGlobal
=
loader
-
>
GetSharedGlobal
(
jsapi
.
cx
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
JS_IsExceptionPending
(
jsapi
.
cx
(
)
)
)
;
}
return
mLoaderGlobal
;
}
