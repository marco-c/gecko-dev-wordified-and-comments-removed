#
include
"
xpcprivate
.
h
"
#
include
"
js
/
Object
.
h
"
#
include
"
pratom
.
h
"
#
include
"
XPCMaps
.
h
"
using
namespace
mozilla
;
#
ifdef
DEBUG
int32_t
XPCWrappedNativeProto
:
:
gDEBUG_LiveProtoCount
=
0
;
#
endif
XPCWrappedNativeProto
:
:
XPCWrappedNativeProto
(
XPCWrappedNativeScope
*
Scope
nsIClassInfo
*
ClassInfo
RefPtr
<
XPCNativeSet
>
&
&
Set
)
:
mScope
(
Scope
)
mJSProtoObject
(
nullptr
)
mClassInfo
(
ClassInfo
)
mSet
(
std
:
:
move
(
Set
)
)
{
MOZ_COUNT_CTOR
(
XPCWrappedNativeProto
)
;
MOZ_ASSERT
(
mScope
)
;
#
ifdef
DEBUG
gDEBUG_LiveProtoCount
+
+
;
#
endif
}
XPCWrappedNativeProto
:
:
~
XPCWrappedNativeProto
(
)
{
MOZ_ASSERT
(
!
mJSProtoObject
"
JSProtoObject
still
alive
"
)
;
MOZ_COUNT_DTOR
(
XPCWrappedNativeProto
)
;
#
ifdef
DEBUG
gDEBUG_LiveProtoCount
-
-
;
#
endif
XPCNativeSet
:
:
ClearCacheEntryForClassInfo
(
mClassInfo
)
;
DeferredFinalize
(
mClassInfo
.
forget
(
)
.
take
(
)
)
;
}
bool
XPCWrappedNativeProto
:
:
Init
(
JSContext
*
cx
nsIXPCScriptable
*
scriptable
)
{
mScriptable
=
scriptable
;
JS
:
:
RootedObject
proto
(
cx
JS
:
:
GetRealmObjectPrototype
(
cx
)
)
;
mJSProtoObject
=
JS_NewObjectWithGivenProto
(
cx
&
XPC_WN_Proto_JSClass
proto
)
;
bool
success
=
!
!
mJSProtoObject
;
if
(
success
)
{
JS
:
:
SetReservedSlot
(
mJSProtoObject
ProtoSlot
JS
:
:
PrivateValue
(
this
)
)
;
}
return
success
;
}
void
XPCWrappedNativeProto
:
:
JSProtoObjectFinalized
(
JS
:
:
GCContext
*
gcx
JSObject
*
obj
)
{
MOZ_ASSERT
(
obj
=
=
mJSProtoObject
"
huh
?
"
)
;
#
ifdef
DEBUG
ClassInfo2WrappedNativeProtoMap
*
map
=
GetScope
(
)
-
>
GetWrappedNativeProtoMap
(
)
;
MOZ_ASSERT
(
map
-
>
Find
(
mClassInfo
)
!
=
this
)
;
#
endif
MOZ_ALWAYS_TRUE
(
GetRuntime
(
)
-
>
GetDyingWrappedNativeProtos
(
)
.
append
(
this
)
)
;
mJSProtoObject
=
nullptr
;
}
void
XPCWrappedNativeProto
:
:
JSProtoObjectMoved
(
JSObject
*
obj
const
JSObject
*
old
)
{
MOZ_ASSERT
(
mJSProtoObject
=
=
old
)
;
mJSProtoObject
.
unbarrieredSet
(
obj
)
;
}
void
XPCWrappedNativeProto
:
:
SystemIsBeingShutDown
(
)
{
if
(
mJSProtoObject
)
{
JS
:
:
SetReservedSlot
(
mJSProtoObject
ProtoSlot
JS
:
:
UndefinedValue
(
)
)
;
mJSProtoObject
=
nullptr
;
}
}
XPCWrappedNativeProto
*
XPCWrappedNativeProto
:
:
GetNewOrUsed
(
JSContext
*
cx
XPCWrappedNativeScope
*
scope
nsIClassInfo
*
classInfo
nsIXPCScriptable
*
scriptable
)
{
MOZ_ASSERT
(
scope
"
bad
param
"
)
;
MOZ_ASSERT
(
classInfo
"
bad
param
"
)
;
AutoMarkingWrappedNativeProtoPtr
proto
(
cx
)
;
ClassInfo2WrappedNativeProtoMap
*
map
=
nullptr
;
map
=
scope
-
>
GetWrappedNativeProtoMap
(
)
;
proto
=
map
-
>
Find
(
classInfo
)
;
if
(
proto
)
{
return
proto
;
}
RefPtr
<
XPCNativeSet
>
set
=
XPCNativeSet
:
:
GetNewOrUsed
(
cx
classInfo
)
;
if
(
!
set
)
{
return
nullptr
;
}
proto
=
new
XPCWrappedNativeProto
(
scope
classInfo
std
:
:
move
(
set
)
)
;
if
(
!
proto
-
>
Init
(
cx
scriptable
)
)
{
delete
proto
.
get
(
)
;
return
nullptr
;
}
map
-
>
Add
(
classInfo
proto
)
;
return
proto
;
}
void
XPCWrappedNativeProto
:
:
DebugDump
(
int16_t
depth
)
{
#
ifdef
DEBUG
depth
-
-
;
XPC_LOG_ALWAYS
(
(
"
XPCWrappedNativeProto
%
p
"
this
)
)
;
XPC_LOG_INDENT
(
)
;
XPC_LOG_ALWAYS
(
(
"
gDEBUG_LiveProtoCount
is
%
d
"
gDEBUG_LiveProtoCount
)
)
;
XPC_LOG_ALWAYS
(
(
"
mScope
%
p
"
mScope
)
)
;
XPC_LOG_ALWAYS
(
(
"
mJSProtoObject
%
p
"
mJSProtoObject
.
get
(
)
)
)
;
XPC_LOG_ALWAYS
(
(
"
mSet
%
p
"
mSet
.
get
(
)
)
)
;
XPC_LOG_ALWAYS
(
(
"
mScriptable
%
p
"
mScriptable
.
get
(
)
)
)
;
if
(
depth
&
&
mScriptable
)
{
XPC_LOG_INDENT
(
)
;
XPC_LOG_ALWAYS
(
(
"
mFlags
of
%
x
"
mScriptable
-
>
GetScriptableFlags
(
)
)
)
;
XPC_LOG_ALWAYS
(
(
"
mJSClass
%
p
"
mScriptable
-
>
GetJSClass
(
)
)
)
;
XPC_LOG_OUTDENT
(
)
;
}
XPC_LOG_OUTDENT
(
)
;
#
endif
}
