#
ifndef
loader_AutoMemMap_h
#
define
loader_AutoMemMap_h
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RangedPtr
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptor
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
<
prio
.
h
>
class
nsIFile
;
namespace
mozilla
{
namespace
loader
{
using
mozilla
:
:
ipc
:
:
FileDescriptor
;
class
AutoMemMap
{
public
:
AutoMemMap
(
)
=
default
;
~
AutoMemMap
(
)
;
Result
<
Ok
nsresult
>
init
(
nsIFile
*
file
int
flags
=
PR_RDONLY
int
mode
=
0
PRFileMapProtect
prot
=
PR_PROT_READONLY
)
;
Result
<
Ok
nsresult
>
init
(
const
ipc
:
:
FileDescriptor
&
file
PRFileMapProtect
prot
=
PR_PROT_READONLY
size_t
expectedSize
=
0
)
;
Result
<
Ok
nsresult
>
initWithHandle
(
const
ipc
:
:
FileDescriptor
&
file
size_t
size
PRFileMapProtect
prot
=
PR_PROT_READONLY
)
;
void
reset
(
)
;
bool
initialized
(
)
{
return
addr
;
}
uint32_t
size
(
)
const
{
return
size_
;
}
template
<
typename
T
=
void
>
RangedPtr
<
T
>
get
(
)
{
MOZ_ASSERT
(
addr
)
;
return
{
static_cast
<
T
*
>
(
addr
)
size_
}
;
}
template
<
typename
T
=
void
>
const
RangedPtr
<
T
>
get
(
)
const
{
MOZ_ASSERT
(
addr
)
;
return
{
static_cast
<
T
*
>
(
addr
)
size_
}
;
}
size_t
nonHeapSizeOfExcludingThis
(
)
{
return
size_
;
}
FileDescriptor
cloneFileDescriptor
(
)
const
;
FileDescriptor
cloneHandle
(
)
const
;
void
setPersistent
(
)
{
persistent_
=
true
;
}
private
:
Result
<
Ok
nsresult
>
initInternal
(
PRFileMapProtect
prot
=
PR_PROT_READONLY
size_t
expectedSize
=
0
)
;
AutoFDClose
fd
;
PRFileMap
*
fileMap
=
nullptr
;
#
ifdef
XP_WIN
void
*
handle_
=
nullptr
;
#
endif
uint32_t
size_
=
0
;
void
*
addr
=
nullptr
;
bool
persistent_
=
0
;
AutoMemMap
(
const
AutoMemMap
&
)
=
delete
;
void
operator
=
(
const
AutoMemMap
&
)
=
delete
;
}
;
}
}
#
endif
