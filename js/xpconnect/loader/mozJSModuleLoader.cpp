#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
<
cstdarg
>
#
include
"
mozilla
/
Logging
.
h
"
#
ifdef
ANDROID
#
include
<
android
/
log
.
h
>
#
endif
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
endif
#
include
"
jsapi
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
friend
/
JSMEnvironment
.
h
"
#
include
"
js
/
loader
/
ModuleLoadRequest
.
h
"
#
include
"
js
/
Object
.
h
"
#
include
"
js
/
Printf
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
mozJSModuleLoader
.
h
"
#
include
"
mozJSLoaderUtils
.
h
"
#
include
"
nsIFileURL
.
h
"
#
include
"
nsIJARURI
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
WrapperFactory
.
h
"
#
include
"
JSMEnvironmentProxy
.
h
"
#
include
"
ModuleEnvironmentProxy
.
h
"
#
include
"
JSServices
.
h
"
#
include
"
mozilla
/
scache
/
StartupCache
.
h
"
#
include
"
mozilla
/
scache
/
StartupCacheUtils
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
MacroForEach
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
ScriptPreloader
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
dom
/
AutoEntryScript
.
h
"
#
include
"
mozilla
/
dom
/
ReferrerPolicyBinding
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
scache
;
using
namespace
mozilla
:
:
loader
;
using
namespace
xpc
;
using
namespace
JS
;
#
define
JS_CACHE_PREFIX
(
aScopeType
aCompilationTarget
)
\
"
jsloader
/
"
aScopeType
"
/
"
aCompilationTarget
#
define
XPC_SERIALIZATION_BUFFER_SIZE
(
64
*
1024
)
#
define
XPC_DESERIALIZATION_BUFFER_SIZE
(
12
*
8192
)
static
LazyLogModule
gJSCLLog
(
"
JSModuleLoader
"
)
;
#
define
LOG
(
args
)
MOZ_LOG
(
gJSCLLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
ERROR_SCOPE_OBJ
"
%
s
-
Second
argument
must
be
an
object
.
"
#
define
ERROR_NO_TARGET_OBJECT
"
%
s
-
Couldn
'
t
find
target
object
for
import
.
"
#
define
ERROR_NOT_PRESENT
"
%
s
-
EXPORTED_SYMBOLS
is
not
present
.
"
#
define
ERROR_NOT_AN_ARRAY
"
%
s
-
EXPORTED_SYMBOLS
is
not
an
array
.
"
#
define
ERROR_GETTING_ARRAY_LENGTH
\
"
%
s
-
Error
getting
array
length
of
EXPORTED_SYMBOLS
.
"
#
define
ERROR_ARRAY_ELEMENT
"
%
s
-
EXPORTED_SYMBOLS
[
%
d
]
is
not
a
string
.
"
#
define
ERROR_GETTING_SYMBOL
"
%
s
-
Could
not
get
symbol
'
%
s
'
.
"
#
define
ERROR_SETTING_SYMBOL
"
%
s
-
Could
not
set
symbol
'
%
s
'
on
target
object
.
"
#
define
ERROR_UNINITIALIZED_SYMBOL
\
"
%
s
-
Symbol
'
%
s
'
accessed
before
initialization
.
Cyclic
import
?
"
static
constexpr
char
JSM_Suffix
[
]
=
"
.
jsm
"
;
static
constexpr
size_t
JSM_SuffixLength
=
mozilla
:
:
ArrayLength
(
JSM_Suffix
)
-
1
;
static
constexpr
char
JSM_JS_Suffix
[
]
=
"
.
jsm
.
js
"
;
static
constexpr
size_t
JSM_JS_SuffixLength
=
mozilla
:
:
ArrayLength
(
JSM_JS_Suffix
)
-
1
;
static
constexpr
char
JS_Suffix
[
]
=
"
.
js
"
;
static
constexpr
size_t
JS_SuffixLength
=
mozilla
:
:
ArrayLength
(
JS_Suffix
)
-
1
;
static
constexpr
char
MJS_Suffix
[
]
=
"
.
sys
.
mjs
"
;
static
constexpr
size_t
MJS_SuffixLength
=
mozilla
:
:
ArrayLength
(
MJS_Suffix
)
-
1
;
static
bool
IsJSM
(
const
nsACString
&
aLocation
)
{
if
(
aLocation
.
Length
(
)
<
JSM_SuffixLength
)
{
return
false
;
}
const
auto
ext
=
Substring
(
aLocation
aLocation
.
Length
(
)
-
JSM_SuffixLength
)
;
return
ext
=
=
JSM_Suffix
;
}
static
bool
IsJS
(
const
nsACString
&
aLocation
)
{
if
(
aLocation
.
Length
(
)
<
JS_SuffixLength
)
{
return
false
;
}
const
auto
ext
=
Substring
(
aLocation
aLocation
.
Length
(
)
-
JS_SuffixLength
)
;
return
ext
=
=
JS_Suffix
;
}
static
bool
IsJSM_JS
(
const
nsACString
&
aLocation
)
{
if
(
aLocation
.
Length
(
)
<
JSM_JS_SuffixLength
)
{
return
false
;
}
const
auto
ext
=
Substring
(
aLocation
aLocation
.
Length
(
)
-
JSM_JS_SuffixLength
)
;
return
ext
=
=
JSM_JS_Suffix
;
}
static
bool
IsMJS
(
const
nsACString
&
aLocation
)
{
if
(
aLocation
.
Length
(
)
<
MJS_SuffixLength
)
{
return
false
;
}
const
auto
ext
=
Substring
(
aLocation
aLocation
.
Length
(
)
-
MJS_SuffixLength
)
;
return
ext
=
=
MJS_Suffix
;
}
static
void
MJSToJSM
(
const
nsACString
&
aLocation
nsAutoCString
&
aOut
)
{
MOZ_ASSERT
(
IsMJS
(
aLocation
)
)
;
aOut
=
Substring
(
aLocation
0
aLocation
.
Length
(
)
-
MJS_SuffixLength
)
;
aOut
+
=
JSM_Suffix
;
}
static
bool
TryToMJS
(
const
nsACString
&
aLocation
nsAutoCString
&
aOut
)
{
if
(
IsJSM
(
aLocation
)
)
{
aOut
=
Substring
(
aLocation
0
aLocation
.
Length
(
)
-
JSM_SuffixLength
)
;
aOut
+
=
MJS_Suffix
;
return
true
;
}
if
(
IsJSM_JS
(
aLocation
)
)
{
aOut
=
Substring
(
aLocation
0
aLocation
.
Length
(
)
-
JSM_JS_SuffixLength
)
;
aOut
+
=
MJS_Suffix
;
return
true
;
}
if
(
IsJS
(
aLocation
)
)
{
aOut
=
Substring
(
aLocation
0
aLocation
.
Length
(
)
-
JS_SuffixLength
)
;
aOut
+
=
MJS_Suffix
;
return
true
;
}
return
false
;
}
static
bool
Dump
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
if
(
!
nsJSUtils
:
:
DumpEnabled
(
)
)
{
return
true
;
}
CallArgs
args
=
CallArgsFromVp
(
argc
vp
)
;
if
(
args
.
length
(
)
=
=
0
)
{
return
true
;
}
RootedString
str
(
cx
JS
:
:
ToString
(
cx
args
[
0
]
)
)
;
if
(
!
str
)
{
return
false
;
}
JS
:
:
UniqueChars
utf8str
=
JS_EncodeStringToUTF8
(
cx
str
)
;
if
(
!
utf8str
)
{
return
false
;
}
MOZ_LOG
(
nsContentUtils
:
:
DOMDumpLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
[
Backstage
.
Dump
]
%
s
"
utf8str
.
get
(
)
)
)
;
#
ifdef
ANDROID
__android_log_print
(
ANDROID_LOG_INFO
"
Gecko
"
"
%
s
"
utf8str
.
get
(
)
)
;
#
endif
#
ifdef
XP_WIN
if
(
IsDebuggerPresent
(
)
)
{
nsAutoJSString
wstr
;
if
(
!
wstr
.
init
(
cx
str
)
)
{
return
false
;
}
OutputDebugStringW
(
wstr
.
get
(
)
)
;
}
#
endif
fputs
(
utf8str
.
get
(
)
stdout
)
;
fflush
(
stdout
)
;
return
true
;
}
static
bool
Debug
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
{
#
ifdef
DEBUG
return
Dump
(
cx
argc
vp
)
;
#
else
return
true
;
#
endif
}
static
const
JSFunctionSpec
gGlobalFun
[
]
=
{
JS_FN
(
"
dump
"
Dump
1
0
)
JS_FN
(
"
debug
"
Debug
1
0
)
JS_FN
(
"
atob
"
Atob
1
0
)
JS_FN
(
"
btoa
"
Btoa
1
0
)
JS_FS_END
}
;
class
MOZ_STACK_CLASS
JSCLContextHelper
{
public
:
explicit
JSCLContextHelper
(
JSContext
*
aCx
)
;
~
JSCLContextHelper
(
)
;
void
reportErrorAfterPop
(
UniqueChars
&
&
buf
)
;
private
:
JSContext
*
mContext
;
UniqueChars
mBuf
;
JSCLContextHelper
(
const
JSCLContextHelper
&
)
=
delete
;
const
JSCLContextHelper
&
operator
=
(
const
JSCLContextHelper
&
)
=
delete
;
}
;
static
nsresult
MOZ_FORMAT_PRINTF
(
2
3
)
ReportOnCallerUTF8
(
JSContext
*
callerContext
const
char
*
format
.
.
.
)
{
if
(
!
callerContext
)
{
return
NS_ERROR_FAILURE
;
}
va_list
ap
;
va_start
(
ap
format
)
;
UniqueChars
buf
=
JS_vsmprintf
(
format
ap
)
;
if
(
!
buf
)
{
va_end
(
ap
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
JS_ReportErrorUTF8
(
callerContext
"
%
s
"
buf
.
get
(
)
)
;
va_end
(
ap
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
mozJSModuleLoader
nsIMemoryReporter
)
mozJSModuleLoader
:
:
mozJSModuleLoader
(
)
:
mImports
(
16
)
mInProgressImports
(
16
)
mFallbackImports
(
16
)
mLocations
(
16
)
mInitialized
(
false
)
mLoaderGlobal
(
dom
:
:
RootingCx
(
)
)
mServicesObj
(
dom
:
:
RootingCx
(
)
)
{
MOZ_ASSERT
(
!
sSelf
"
mozJSModuleLoader
should
be
a
singleton
"
)
;
}
#
define
ENSURE_DEP
(
name
)
\
{
\
nsresult
rv
=
Ensure
#
#
name
(
)
;
\
NS_ENSURE_SUCCESS
(
rv
rv
)
;
\
}
#
define
ENSURE_DEPS
(
.
.
.
)
MOZ_FOR_EACH
(
ENSURE_DEP
(
)
(
__VA_ARGS__
)
)
;
#
define
BEGIN_ENSURE
(
self
.
.
.
)
\
{
\
if
(
m
#
#
self
)
return
NS_OK
;
\
ENSURE_DEPS
(
__VA_ARGS__
)
;
\
}
class
MOZ_STACK_CLASS
ModuleLoaderInfo
{
public
:
explicit
ModuleLoaderInfo
(
const
nsACString
&
aLocation
)
:
mLocation
(
&
aLocation
)
mIsModule
(
false
)
{
}
explicit
ModuleLoaderInfo
(
nsIURI
*
aURI
bool
aIsModule
)
:
mLocation
(
nullptr
)
mURI
(
aURI
)
mIsModule
(
aIsModule
)
{
}
nsIIOService
*
IOService
(
)
{
MOZ_ASSERT
(
mIOService
)
;
return
mIOService
;
}
nsresult
EnsureIOService
(
)
{
if
(
mIOService
)
{
return
NS_OK
;
}
nsresult
rv
;
mIOService
=
do_GetIOService
(
&
rv
)
;
return
rv
;
}
nsIURI
*
URI
(
)
{
MOZ_ASSERT
(
mURI
)
;
return
mURI
;
}
nsresult
EnsureURI
(
)
{
BEGIN_ENSURE
(
URI
IOService
)
;
MOZ_ASSERT
(
mLocation
)
;
return
mIOService
-
>
NewURI
(
*
mLocation
nullptr
nullptr
getter_AddRefs
(
mURI
)
)
;
}
nsIChannel
*
ScriptChannel
(
)
{
MOZ_ASSERT
(
mScriptChannel
)
;
return
mScriptChannel
;
}
nsresult
EnsureScriptChannel
(
)
{
BEGIN_ENSURE
(
ScriptChannel
IOService
URI
)
;
bool
skipCheckForBrokenURLOrZeroSized
=
!
IsModule
(
)
;
return
NS_NewChannel
(
getter_AddRefs
(
mScriptChannel
)
mURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
nsIContentPolicy
:
:
TYPE_SCRIPT
nullptr
nullptr
nullptr
nullptr
nsIRequest
:
:
LOAD_NORMAL
mIOService
0
skipCheckForBrokenURLOrZeroSized
)
;
}
nsIURI
*
ResolvedURI
(
)
{
MOZ_ASSERT
(
mResolvedURI
)
;
return
mResolvedURI
;
}
nsresult
EnsureResolvedURI
(
)
{
BEGIN_ENSURE
(
ResolvedURI
URI
)
;
return
ResolveURI
(
mURI
getter_AddRefs
(
mResolvedURI
)
)
;
}
const
nsACString
&
Key
(
)
{
MOZ_ASSERT
(
mLocation
)
;
return
*
mLocation
;
}
[
[
nodiscard
]
]
nsresult
GetLocation
(
nsCString
&
aLocation
)
{
nsresult
rv
=
EnsureURI
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
mURI
-
>
GetSpec
(
aLocation
)
;
}
bool
IsModule
(
)
const
{
return
mIsModule
;
}
private
:
const
nsACString
*
mLocation
;
nsCOMPtr
<
nsIIOService
>
mIOService
;
nsCOMPtr
<
nsIURI
>
mURI
;
nsCOMPtr
<
nsIChannel
>
mScriptChannel
;
nsCOMPtr
<
nsIURI
>
mResolvedURI
;
const
bool
mIsModule
;
}
;
template
<
typename
.
.
.
Args
>
static
nsresult
ReportOnCallerUTF8
(
JSCLContextHelper
&
helper
const
char
*
format
ModuleLoaderInfo
&
info
Args
.
.
.
args
)
{
nsCString
location
;
MOZ_TRY
(
info
.
GetLocation
(
location
)
)
;
UniqueChars
buf
=
JS_smprintf
(
format
location
.
get
(
)
args
.
.
.
)
;
if
(
!
buf
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
helper
.
reportErrorAfterPop
(
std
:
:
move
(
buf
)
)
;
return
NS_ERROR_FAILURE
;
}
#
undef
BEGIN_ENSURE
#
undef
ENSURE_DEPS
#
undef
ENSURE_DEP
mozJSModuleLoader
:
:
~
mozJSModuleLoader
(
)
{
MOZ_ASSERT
(
!
mInitialized
"
UnloadModules
(
)
was
not
explicitly
called
before
cleaning
up
"
"
mozJSModuleLoader
"
)
;
if
(
mInitialized
)
{
UnloadModules
(
)
;
}
sSelf
=
nullptr
;
}
StaticRefPtr
<
mozJSModuleLoader
>
mozJSModuleLoader
:
:
sSelf
;
void
mozJSModuleLoader
:
:
FindTargetObject
(
JSContext
*
aCx
MutableHandleObject
aTargetObject
)
{
aTargetObject
.
set
(
JS
:
:
GetJSMEnvironmentOfScriptedCaller
(
aCx
)
)
;
if
(
!
aTargetObject
|
|
!
IsLoaderGlobal
(
JS
:
:
GetNonCCWObjectGlobal
(
aTargetObject
)
)
)
{
aTargetObject
.
set
(
JS
:
:
GetScriptedCallerGlobal
(
aCx
)
)
;
if
(
JS
:
:
GetCompartment
(
aTargetObject
)
!
=
js
:
:
GetContextCompartment
(
aCx
)
)
{
aTargetObject
.
set
(
nullptr
)
;
}
}
}
void
mozJSModuleLoader
:
:
InitStatics
(
)
{
MOZ_ASSERT
(
!
sSelf
)
;
sSelf
=
new
mozJSModuleLoader
(
)
;
RegisterWeakMemoryReporter
(
sSelf
)
;
}
void
mozJSModuleLoader
:
:
Unload
(
)
{
if
(
sSelf
)
{
sSelf
-
>
UnloadModules
(
)
;
if
(
sSelf
-
>
mModuleLoader
)
{
sSelf
-
>
mModuleLoader
-
>
Shutdown
(
)
;
sSelf
-
>
mModuleLoader
=
nullptr
;
}
}
}
void
mozJSModuleLoader
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
sSelf
)
;
UnregisterWeakMemoryReporter
(
sSelf
)
;
sSelf
=
nullptr
;
}
template
<
class
Key
class
Data
class
UserData
class
Converter
>
static
size_t
SizeOfTableExcludingThis
(
const
nsBaseHashtable
<
Key
Data
UserData
Converter
>
&
aTable
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
entry
:
aTable
)
{
n
+
=
entry
.
GetKey
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
n
+
=
entry
.
GetData
(
)
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
size_t
mozJSModuleLoader
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
SizeOfTableExcludingThis
(
mImports
aMallocSizeOf
)
;
n
+
=
mLocations
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
n
+
=
SizeOfTableExcludingThis
(
mInProgressImports
aMallocSizeOf
)
;
n
+
=
SizeOfTableExcludingThis
(
mFallbackImports
aMallocSizeOf
)
;
return
n
;
}
static
nsAutoCString
MangleURL
(
const
char
*
aURL
bool
aAnonymize
)
{
nsAutoCString
url
(
aURL
)
;
if
(
aAnonymize
)
{
static
nsCString
greDirURI
;
if
(
greDirURI
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIFile
>
file
;
Unused
<
<
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
file
)
)
;
if
(
file
)
{
nsCOMPtr
<
nsIURI
>
uri
;
NS_NewFileURI
(
getter_AddRefs
(
uri
)
file
)
;
if
(
uri
)
{
uri
-
>
GetSpec
(
greDirURI
)
;
RunOnShutdown
(
[
&
]
(
)
{
greDirURI
.
Truncate
(
0
)
;
}
)
;
}
}
}
url
.
ReplaceSubstring
(
greDirURI
"
<
GREDir
>
/
"
_ns
)
;
if
(
FindInReadable
(
"
file
:
"
_ns
url
)
)
{
if
(
StringBeginsWith
(
url
"
jar
:
file
:
"
_ns
)
)
{
int32_t
idx
=
url
.
RFindChar
(
'
!
'
)
;
url
=
"
jar
:
file
:
/
/
<
anonymized
>
!
"
_ns
+
Substring
(
url
idx
)
;
}
else
{
int32_t
idx
=
url
.
RFindChar
(
'
/
'
)
;
url
=
"
file
:
/
/
<
anonymized
>
/
"
_ns
+
Substring
(
url
idx
)
;
}
}
}
url
.
ReplaceChar
(
'
/
'
'
\
\
'
)
;
return
url
;
}
NS_IMETHODIMP
mozJSModuleLoader
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
for
(
const
auto
&
entry
:
mImports
.
Values
(
)
)
{
nsAutoCString
path
(
"
js
-
module
-
loader
/
modules
/
"
)
;
path
.
Append
(
MangleURL
(
entry
-
>
location
aAnonymize
)
)
;
aHandleReport
-
>
Callback
(
"
"
_ns
path
KIND_NONHEAP
UNITS_COUNT
1
"
Loaded
JS
modules
"
_ns
aData
)
;
}
return
NS_OK
;
}
void
mozJSModuleLoader
:
:
CreateLoaderGlobal
(
JSContext
*
aCx
const
nsACString
&
aLocation
MutableHandleObject
aGlobal
)
{
auto
backstagePass
=
MakeRefPtr
<
BackstagePass
>
(
)
;
RealmOptions
options
;
options
.
creationOptions
(
)
.
setFreezeBuiltins
(
true
)
.
setNewCompartmentInSystemZone
(
)
;
xpc
:
:
SetPrefableRealmOptions
(
options
)
;
RootedObject
global
(
aCx
)
;
#
ifdef
DEBUG
mIsInitializingLoaderGlobal
=
true
;
#
endif
nsresult
rv
=
xpc
:
:
InitClassesWithNewWrappedGlobal
(
aCx
static_cast
<
nsIGlobalObject
*
>
(
backstagePass
)
nsContentUtils
:
:
GetSystemPrincipal
(
)
xpc
:
:
DONT_FIRE_ONNEWGLOBALHOOK
options
&
global
)
;
#
ifdef
DEBUG
mIsInitializingLoaderGlobal
=
false
;
#
endif
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
NS_ENSURE_TRUE_VOID
(
global
)
;
backstagePass
-
>
SetGlobalObject
(
global
)
;
JSAutoRealm
ar
(
aCx
global
)
;
if
(
!
JS_DefineFunctions
(
aCx
global
gGlobalFun
)
)
{
return
;
}
if
(
!
CreateJSServices
(
aCx
)
)
{
return
;
}
if
(
!
DefineJSServices
(
aCx
global
)
)
{
return
;
}
xpc
:
:
SetLocationForGlobal
(
global
aLocation
)
;
MOZ_ASSERT
(
!
mModuleLoader
)
;
RefPtr
<
ComponentScriptLoader
>
scriptLoader
=
new
ComponentScriptLoader
;
mModuleLoader
=
new
ComponentModuleLoader
(
scriptLoader
backstagePass
)
;
backstagePass
-
>
InitModuleLoader
(
mModuleLoader
)
;
aGlobal
.
set
(
global
)
;
}
JSObject
*
mozJSModuleLoader
:
:
GetSharedGlobal
(
JSContext
*
aCx
)
{
if
(
!
mLoaderGlobal
)
{
JS
:
:
RootedObject
globalObj
(
aCx
)
;
CreateLoaderGlobal
(
aCx
"
shared
JSM
global
"
_ns
&
globalObj
)
;
MOZ_RELEASE_ASSERT
(
globalObj
)
;
mLoaderGlobal
=
globalObj
;
dom
:
:
AutoEntryScript
aes
(
globalObj
"
module
loader
report
global
"
)
;
JS_FireOnNewGlobalObject
(
aes
.
cx
(
)
globalObj
)
;
}
return
mLoaderGlobal
;
}
nsresult
mozJSModuleLoader
:
:
LoadSingleModuleScript
(
JSContext
*
aCx
nsIURI
*
aURI
MutableHandleScript
aScriptOut
)
{
ModuleLoaderInfo
info
(
aURI
true
)
;
nsresult
rv
=
info
.
EnsureResolvedURI
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
sourceFile
;
rv
=
GetSourceFile
(
info
.
ResolvedURI
(
)
getter_AddRefs
(
sourceFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
realFile
=
LocationIsRealFile
(
aURI
)
;
RootedScript
script
(
aCx
)
;
return
GetScriptForLocation
(
aCx
info
sourceFile
realFile
aScriptOut
)
;
}
nsresult
mozJSModuleLoader
:
:
GetSourceFile
(
nsIURI
*
aResolvedURI
nsIFile
*
*
aSourceFileOut
)
{
nsCOMPtr
<
nsIJARURI
>
jarURI
;
nsresult
rv
=
NS_OK
;
jarURI
=
do_QueryInterface
(
aResolvedURI
&
rv
)
;
nsCOMPtr
<
nsIFileURL
>
baseFileURL
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIURI
>
baseURI
;
while
(
jarURI
)
{
jarURI
-
>
GetJARFile
(
getter_AddRefs
(
baseURI
)
)
;
jarURI
=
do_QueryInterface
(
baseURI
&
rv
)
;
}
baseFileURL
=
do_QueryInterface
(
baseURI
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
baseFileURL
=
do_QueryInterface
(
aResolvedURI
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
baseFileURL
-
>
GetFile
(
aSourceFileOut
)
;
}
bool
mozJSModuleLoader
:
:
LocationIsRealFile
(
nsIURI
*
aURI
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIFileURL
>
fileURL
=
do_QueryInterface
(
aURI
&
rv
)
;
nsCOMPtr
<
nsIFile
>
testFile
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
fileURL
-
>
GetFile
(
getter_AddRefs
(
testFile
)
)
;
}
return
bool
(
testFile
)
;
}
JSObject
*
mozJSModuleLoader
:
:
PrepareObjectForLocation
(
JSContext
*
aCx
nsIFile
*
aModuleFile
nsIURI
*
aURI
bool
aRealFile
)
{
RootedObject
globalObj
(
aCx
GetSharedGlobal
(
aCx
)
)
;
NS_ENSURE_TRUE
(
globalObj
nullptr
)
;
JSAutoRealm
ar
(
aCx
globalObj
)
;
RootedObject
thisObj
(
aCx
JS
:
:
NewJSMEnvironment
(
aCx
)
)
;
NS_ENSURE_TRUE
(
thisObj
nullptr
)
;
if
(
aRealFile
)
{
if
(
XRE_IsParentProcess
(
)
)
{
RootedObject
locationObj
(
aCx
)
;
nsresult
rv
=
nsXPConnect
:
:
XPConnect
(
)
-
>
WrapNative
(
aCx
thisObj
aModuleFile
NS_GET_IID
(
nsIFile
)
locationObj
.
address
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
NS_ENSURE_TRUE
(
locationObj
nullptr
)
;
if
(
!
JS_DefineProperty
(
aCx
thisObj
"
__LOCATION__
"
locationObj
0
)
)
{
return
nullptr
;
}
}
}
nsAutoCString
nativePath
;
NS_ENSURE_SUCCESS
(
aURI
-
>
GetSpec
(
nativePath
)
nullptr
)
;
RootedString
exposedUri
(
aCx
JS_NewStringCopyN
(
aCx
nativePath
.
get
(
)
nativePath
.
Length
(
)
)
)
;
NS_ENSURE_TRUE
(
exposedUri
nullptr
)
;
if
(
!
JS_DefineProperty
(
aCx
thisObj
"
__URI__
"
exposedUri
0
)
)
{
return
nullptr
;
}
return
thisObj
;
}
static
mozilla
:
:
Result
<
nsCString
nsresult
>
ReadScript
(
ModuleLoaderInfo
&
aInfo
)
{
MOZ_TRY
(
aInfo
.
EnsureScriptChannel
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
scriptStream
;
MOZ_TRY
(
NS_MaybeOpenChannelUsingOpen
(
aInfo
.
ScriptChannel
(
)
getter_AddRefs
(
scriptStream
)
)
)
;
uint64_t
len64
;
uint32_t
bytesRead
;
MOZ_TRY
(
scriptStream
-
>
Available
(
&
len64
)
)
;
NS_ENSURE_TRUE
(
len64
<
UINT32_MAX
Err
(
NS_ERROR_FILE_TOO_BIG
)
)
;
NS_ENSURE_TRUE
(
len64
Err
(
NS_ERROR_FAILURE
)
)
;
uint32_t
len
=
(
uint32_t
)
len64
;
nsCString
str
;
if
(
!
str
.
SetLength
(
len
fallible
)
)
{
return
Err
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
MOZ_TRY
(
scriptStream
-
>
Read
(
str
.
BeginWriting
(
)
len
&
bytesRead
)
)
;
if
(
bytesRead
!
=
len
)
{
return
Err
(
NS_BASE_STREAM_OSERROR
)
;
}
return
std
:
:
move
(
str
)
;
}
nsresult
mozJSModuleLoader
:
:
ObjectForLocation
(
ModuleLoaderInfo
&
aInfo
nsIFile
*
aModuleFile
MutableHandleObject
aObject
MutableHandleScript
aTableScript
char
*
*
aLocation
bool
aPropagateExceptions
MutableHandleValue
aException
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
on
main
thread
.
"
)
;
dom
:
:
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
nsresult
rv
=
aInfo
.
EnsureURI
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
realFile
=
LocationIsRealFile
(
aInfo
.
URI
(
)
)
;
RootedObject
obj
(
cx
PrepareObjectForLocation
(
cx
aModuleFile
aInfo
.
URI
(
)
realFile
)
)
;
NS_ENSURE_TRUE
(
obj
NS_ERROR_FAILURE
)
;
MOZ_ASSERT
(
!
JS_IsGlobalObject
(
obj
)
)
;
JSAutoRealm
ar
(
cx
obj
)
;
RootedScript
script
(
cx
)
;
rv
=
GetScriptForLocation
(
cx
aInfo
aModuleFile
realFile
&
script
aLocation
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
aPropagateExceptions
&
&
jsapi
.
HasException
(
)
)
{
if
(
!
jsapi
.
StealException
(
aException
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
return
rv
;
}
aObject
.
set
(
obj
)
;
aTableScript
.
set
(
script
)
;
{
AutoAllowLegacyScriptExecution
exemption
;
dom
:
:
AutoEntryScript
aes
(
CurrentGlobalOrNull
(
cx
)
"
module
loader
load
module
"
)
;
JSContext
*
aescx
=
aes
.
cx
(
)
;
bool
executeOk
=
false
;
if
(
JS_IsGlobalObject
(
obj
)
)
{
JS
:
:
RootedValue
rval
(
cx
)
;
executeOk
=
JS_ExecuteScript
(
aescx
script
&
rval
)
;
}
else
{
executeOk
=
JS
:
:
ExecuteInJSMEnvironment
(
aescx
script
obj
)
;
}
if
(
!
executeOk
)
{
if
(
aPropagateExceptions
&
&
aes
.
HasException
(
)
)
{
Unused
<
<
aes
.
StealException
(
aException
)
;
}
aObject
.
set
(
nullptr
)
;
aTableScript
.
set
(
nullptr
)
;
return
NS_ERROR_FAILURE
;
}
}
return
rv
;
}
nsresult
mozJSModuleLoader
:
:
GetScriptForLocation
(
JSContext
*
aCx
ModuleLoaderInfo
&
aInfo
nsIFile
*
aModuleFile
bool
aUseMemMap
MutableHandleScript
aScriptOut
char
*
*
aLocationOut
)
{
MOZ_ASSERT
(
!
JS_IsExceptionPending
(
aCx
)
)
;
aScriptOut
.
set
(
nullptr
)
;
nsAutoCString
nativePath
;
nsresult
rv
=
aInfo
.
URI
(
)
-
>
GetSpec
(
nativePath
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
storeIntoStartupCache
=
false
;
StartupCache
*
cache
=
StartupCache
:
:
GetSingleton
(
)
;
aInfo
.
EnsureResolvedURI
(
)
;
nsAutoCString
cachePath
;
if
(
aInfo
.
IsModule
(
)
)
{
rv
=
PathifyURI
(
JS_CACHE_PREFIX
(
"
non
-
syntactic
"
"
module
"
)
aInfo
.
ResolvedURI
(
)
cachePath
)
;
}
else
{
rv
=
PathifyURI
(
JS_CACHE_PREFIX
(
"
non
-
syntactic
"
"
script
"
)
aInfo
.
ResolvedURI
(
)
cachePath
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
JS
:
:
DecodeOptions
decodeOptions
;
ScriptPreloader
:
:
FillDecodeOptionsForCachedStencil
(
decodeOptions
)
;
RefPtr
<
JS
:
:
Stencil
>
stencil
=
ScriptPreloader
:
:
GetSingleton
(
)
.
GetCachedStencil
(
aCx
decodeOptions
cachePath
)
;
if
(
!
stencil
&
&
cache
)
{
ReadCachedStencil
(
cache
cachePath
aCx
decodeOptions
getter_AddRefs
(
stencil
)
)
;
if
(
!
stencil
)
{
JS_ClearPendingException
(
aCx
)
;
storeIntoStartupCache
=
true
;
}
}
if
(
stencil
)
{
LOG
(
(
"
Successfully
loaded
%
s
from
cache
\
n
"
nativePath
.
get
(
)
)
)
;
}
else
{
LOG
(
(
"
Slow
loading
%
s
\
n
"
nativePath
.
get
(
)
)
)
;
CompileOptions
options
(
aCx
)
;
ScriptPreloader
:
:
FillCompileOptionsForCachedStencil
(
options
)
;
options
.
setFileAndLine
(
nativePath
.
get
(
)
1
)
;
if
(
aInfo
.
IsModule
(
)
)
{
options
.
setModule
(
)
;
options
.
topLevelAwait
=
false
;
options
.
deoptimizeModuleGlobalVars
=
true
;
}
else
{
options
.
setForceStrictMode
(
)
;
options
.
setNonSyntacticScope
(
true
)
;
}
if
(
!
storeIntoStartupCache
&
&
!
ScriptPreloader
:
:
GetSingleton
(
)
.
Active
(
)
)
{
options
.
setSourceIsLazy
(
false
)
;
}
if
(
aUseMemMap
)
{
AutoMemMap
map
;
MOZ_TRY
(
map
.
init
(
aModuleFile
)
)
;
auto
buf
=
map
.
get
<
char
>
(
)
;
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
srcBuf
;
if
(
srcBuf
.
init
(
aCx
buf
.
get
(
)
map
.
size
(
)
JS
:
:
SourceOwnership
:
:
Borrowed
)
)
{
stencil
=
CompileStencil
(
aCx
options
srcBuf
aInfo
.
IsModule
(
)
)
;
}
}
else
{
nsCString
str
;
MOZ_TRY_VAR
(
str
ReadScript
(
aInfo
)
)
;
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
srcBuf
;
if
(
srcBuf
.
init
(
aCx
str
.
get
(
)
str
.
Length
(
)
JS
:
:
SourceOwnership
:
:
Borrowed
)
)
{
stencil
=
CompileStencil
(
aCx
options
srcBuf
aInfo
.
IsModule
(
)
)
;
}
}
#
ifdef
DEBUG
JS
:
:
InstantiateOptions
instantiateOptions
(
options
)
;
instantiateOptions
.
assertDefault
(
)
;
#
endif
if
(
!
stencil
)
{
return
NS_ERROR_FAILURE
;
}
}
aScriptOut
.
set
(
InstantiateStencil
(
aCx
stencil
aInfo
.
IsModule
(
)
)
)
;
if
(
!
aScriptOut
)
{
return
NS_ERROR_FAILURE
;
}
ScriptPreloader
:
:
GetSingleton
(
)
.
NoteStencil
(
nativePath
cachePath
stencil
)
;
if
(
storeIntoStartupCache
)
{
MOZ_ASSERT
(
stencil
)
;
rv
=
WriteCachedStencil
(
cache
cachePath
aCx
stencil
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
Successfully
wrote
to
cache
\
n
"
)
)
;
}
else
{
LOG
(
(
"
Failed
to
write
to
cache
\
n
"
)
)
;
}
}
if
(
aLocationOut
)
{
*
aLocationOut
=
ToNewCString
(
nativePath
mozilla
:
:
fallible
)
;
if
(
!
*
aLocationOut
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
return
NS_OK
;
}
void
mozJSModuleLoader
:
:
UnloadModules
(
)
{
mInitialized
=
false
;
if
(
mLoaderGlobal
)
{
MOZ_ASSERT
(
JS_HasExtensibleLexicalEnvironment
(
mLoaderGlobal
)
)
;
JS
:
:
RootedObject
lexicalEnv
(
dom
:
:
RootingCx
(
)
JS_ExtensibleLexicalEnvironment
(
mLoaderGlobal
)
)
;
JS_SetAllNonReservedSlotsToUndefined
(
lexicalEnv
)
;
JS_SetAllNonReservedSlotsToUndefined
(
mLoaderGlobal
)
;
mLoaderGlobal
=
nullptr
;
}
mServicesObj
=
nullptr
;
mFallbackImports
.
Clear
(
)
;
mInProgressImports
.
Clear
(
)
;
mImports
.
Clear
(
)
;
mLocations
.
Clear
(
)
;
}
already_AddRefed
<
Stencil
>
mozJSModuleLoader
:
:
CompileStencil
(
JSContext
*
aCx
const
JS
:
:
CompileOptions
&
aOptions
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
&
aSource
bool
aIsModule
)
{
if
(
aIsModule
)
{
return
CompileModuleScriptToStencil
(
aCx
aOptions
aSource
)
;
}
return
CompileGlobalScriptToStencil
(
aCx
aOptions
aSource
)
;
}
JSScript
*
mozJSModuleLoader
:
:
InstantiateStencil
(
JSContext
*
aCx
JS
:
:
Stencil
*
aStencil
bool
aIsModule
)
{
JS
:
:
InstantiateOptions
instantiateOptions
;
if
(
aIsModule
)
{
RootedObject
module
(
aCx
)
;
module
=
JS
:
:
InstantiateModuleStencil
(
aCx
instantiateOptions
aStencil
)
;
if
(
!
module
)
{
return
nullptr
;
}
return
JS
:
:
GetModuleScript
(
module
)
;
}
return
JS
:
:
InstantiateGlobalStencil
(
aCx
instantiateOptions
aStencil
)
;
}
nsresult
mozJSModuleLoader
:
:
ImportInto
(
const
nsACString
&
registryLocation
HandleValue
targetValArg
JSContext
*
cx
uint8_t
optionalArgc
MutableHandleValue
retval
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsCallerChrome
(
)
)
;
RootedValue
targetVal
(
cx
targetValArg
)
;
RootedObject
targetObject
(
cx
nullptr
)
;
if
(
optionalArgc
)
{
if
(
targetVal
.
isObject
(
)
)
{
if
(
WrapperFactory
:
:
IsXrayWrapper
(
&
targetVal
.
toObject
(
)
)
&
&
!
WrapperFactory
:
:
WaiveXrayAndWrap
(
cx
&
targetVal
)
)
{
return
NS_ERROR_FAILURE
;
}
targetObject
=
&
targetVal
.
toObject
(
)
;
}
else
if
(
!
targetVal
.
isNull
(
)
)
{
return
ReportOnCallerUTF8
(
cx
ERROR_SCOPE_OBJ
PromiseFlatCString
(
registryLocation
)
.
get
(
)
)
;
}
}
else
{
FindTargetObject
(
cx
&
targetObject
)
;
if
(
!
targetObject
)
{
return
ReportOnCallerUTF8
(
cx
ERROR_NO_TARGET_OBJECT
PromiseFlatCString
(
registryLocation
)
.
get
(
)
)
;
}
}
js
:
:
AssertSameCompartment
(
cx
targetObject
)
;
RootedObject
global
(
cx
)
;
nsresult
rv
=
ImportInto
(
registryLocation
targetObject
cx
&
global
)
;
if
(
global
)
{
if
(
!
JS_WrapObject
(
cx
&
global
)
)
{
NS_ERROR
(
"
can
'
t
wrap
return
value
"
)
;
return
NS_ERROR_FAILURE
;
}
retval
.
setObject
(
*
global
)
;
}
return
rv
;
}
nsresult
mozJSModuleLoader
:
:
IsModuleLoaded
(
const
nsACString
&
aLocation
bool
*
retval
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsCallerChrome
(
)
)
;
mInitialized
=
true
;
ModuleLoaderInfo
info
(
aLocation
)
;
if
(
mImports
.
Get
(
info
.
Key
(
)
)
)
{
*
retval
=
true
;
return
NS_OK
;
}
if
(
mModuleLoader
)
{
nsAutoCString
mjsLocation
;
if
(
!
TryToMJS
(
aLocation
mjsLocation
)
)
{
*
retval
=
false
;
return
NS_OK
;
}
ModuleLoaderInfo
mjsInfo
(
mjsLocation
)
;
nsresult
rv
=
mjsInfo
.
EnsureURI
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mModuleLoader
-
>
IsModuleFetched
(
mjsInfo
.
URI
(
)
)
)
{
*
retval
=
true
;
return
NS_OK
;
}
}
*
retval
=
false
;
return
NS_OK
;
}
nsresult
mozJSModuleLoader
:
:
IsJSModuleLoaded
(
const
nsACString
&
aLocation
bool
*
retval
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsCallerChrome
(
)
)
;
mInitialized
=
true
;
ModuleLoaderInfo
info
(
aLocation
)
;
if
(
mImports
.
Get
(
info
.
Key
(
)
)
)
{
*
retval
=
true
;
return
NS_OK
;
}
*
retval
=
false
;
return
NS_OK
;
}
nsresult
mozJSModuleLoader
:
:
IsESModuleLoaded
(
const
nsACString
&
aLocation
bool
*
retval
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsCallerChrome
(
)
)
;
mInitialized
=
true
;
ModuleLoaderInfo
info
(
aLocation
)
;
nsresult
rv
=
info
.
EnsureURI
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mModuleLoader
-
>
IsModuleFetched
(
info
.
URI
(
)
)
)
{
*
retval
=
true
;
return
NS_OK
;
}
*
retval
=
false
;
return
NS_OK
;
}
void
mozJSModuleLoader
:
:
GetLoadedModules
(
nsTArray
<
nsCString
>
&
aLoadedModules
)
{
aLoadedModules
.
SetCapacity
(
mImports
.
Count
(
)
)
;
for
(
const
auto
&
data
:
mImports
.
Values
(
)
)
{
aLoadedModules
.
AppendElement
(
data
-
>
location
)
;
}
}
nsresult
mozJSModuleLoader
:
:
GetLoadedESModules
(
nsTArray
<
nsCString
>
&
aLoadedModules
)
{
return
mModuleLoader
-
>
GetFetchedModuleURLs
(
aLoadedModules
)
;
}
nsresult
mozJSModuleLoader
:
:
GetLoadedJSAndESModules
(
nsTArray
<
nsCString
>
&
aLoadedModules
)
{
GetLoadedModules
(
aLoadedModules
)
;
nsTArray
<
nsCString
>
modules
;
nsresult
rv
=
GetLoadedESModules
(
modules
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
const
auto
&
location
:
modules
)
{
if
(
IsMJS
(
location
)
)
{
nsAutoCString
jsmLocation
;
MJSToJSM
(
location
jsmLocation
)
;
aLoadedModules
.
AppendElement
(
jsmLocation
)
;
}
}
return
NS_OK
;
}
nsresult
mozJSModuleLoader
:
:
GetModuleImportStack
(
const
nsACString
&
aLocation
nsACString
&
retval
)
{
#
ifdef
STARTUP_RECORDER_ENABLED
MOZ_ASSERT
(
nsContentUtils
:
:
IsCallerChrome
(
)
)
;
MOZ_ASSERT
(
mInitialized
)
;
ModuleLoaderInfo
info
(
aLocation
)
;
ModuleEntry
*
mod
;
if
(
!
mImports
.
Get
(
info
.
Key
(
)
&
mod
)
)
{
return
NS_ERROR_FAILURE
;
}
retval
=
mod
-
>
importStack
;
return
NS_OK
;
#
else
return
NS_ERROR_NOT_IMPLEMENTED
;
#
endif
}
nsresult
mozJSModuleLoader
:
:
ImportInto
(
const
nsACString
&
aLocation
HandleObject
targetObj
JSContext
*
cx
MutableHandleObject
vp
)
{
vp
.
set
(
nullptr
)
;
JS
:
:
RootedObject
exports
(
cx
)
;
MOZ_TRY
(
Import
(
cx
aLocation
vp
&
exports
!
targetObj
)
)
;
if
(
targetObj
)
{
JS
:
:
Rooted
<
JS
:
:
IdVector
>
ids
(
cx
JS
:
:
IdVector
(
cx
)
)
;
if
(
!
JS_Enumerate
(
cx
exports
&
ids
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
JS
:
:
RootedValue
value
(
cx
)
;
JS
:
:
RootedId
id
(
cx
)
;
for
(
jsid
idVal
:
ids
)
{
id
=
idVal
;
if
(
!
JS_GetPropertyById
(
cx
exports
id
&
value
)
|
|
!
JS_SetPropertyById
(
cx
targetObj
id
value
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
return
NS_OK
;
}
nsresult
mozJSModuleLoader
:
:
ExtractExports
(
JSContext
*
aCx
ModuleLoaderInfo
&
aInfo
ModuleEntry
*
aMod
JS
:
:
MutableHandleObject
aExports
)
{
JSCLContextHelper
cxhelper
(
aCx
)
;
dom
:
:
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JSAutoRealm
ar
(
cx
aMod
-
>
obj
)
;
RootedValue
symbols
(
cx
)
;
{
RootedObject
obj
(
cx
ResolveModuleObjectProperty
(
cx
aMod
-
>
obj
"
EXPORTED_SYMBOLS
"
)
)
;
if
(
!
obj
|
|
!
JS_GetProperty
(
cx
obj
"
EXPORTED_SYMBOLS
"
&
symbols
)
)
{
return
ReportOnCallerUTF8
(
cxhelper
ERROR_NOT_PRESENT
aInfo
)
;
}
}
bool
isArray
;
if
(
!
JS
:
:
IsArrayObject
(
cx
symbols
&
isArray
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
isArray
)
{
return
ReportOnCallerUTF8
(
cxhelper
ERROR_NOT_AN_ARRAY
aInfo
)
;
}
RootedObject
symbolsObj
(
cx
&
symbols
.
toObject
(
)
)
;
uint32_t
symbolCount
=
0
;
if
(
!
JS
:
:
GetArrayLength
(
cx
symbolsObj
&
symbolCount
)
)
{
return
ReportOnCallerUTF8
(
cxhelper
ERROR_GETTING_ARRAY_LENGTH
aInfo
)
;
}
#
ifdef
DEBUG
nsAutoCString
logBuffer
;
#
endif
aExports
.
set
(
JS_NewPlainObject
(
cx
)
)
;
if
(
!
aExports
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
bool
missing
=
false
;
RootedValue
value
(
cx
)
;
RootedId
symbolId
(
cx
)
;
RootedObject
symbolHolder
(
cx
)
;
for
(
uint32_t
i
=
0
;
i
<
symbolCount
;
+
+
i
)
{
if
(
!
JS_GetElement
(
cx
symbolsObj
i
&
value
)
|
|
!
value
.
isString
(
)
|
|
!
JS_ValueToId
(
cx
value
&
symbolId
)
)
{
return
ReportOnCallerUTF8
(
cxhelper
ERROR_ARRAY_ELEMENT
aInfo
i
)
;
}
symbolHolder
=
ResolveModuleObjectPropertyById
(
cx
aMod
-
>
obj
symbolId
)
;
if
(
!
symbolHolder
|
|
!
JS_GetPropertyById
(
cx
symbolHolder
symbolId
&
value
)
)
{
RootedString
symbolStr
(
cx
symbolId
.
toString
(
)
)
;
JS
:
:
UniqueChars
bytes
=
JS_EncodeStringToUTF8
(
cx
symbolStr
)
;
if
(
!
bytes
)
{
return
NS_ERROR_FAILURE
;
}
return
ReportOnCallerUTF8
(
cxhelper
ERROR_GETTING_SYMBOL
aInfo
bytes
.
get
(
)
)
;
}
if
(
value
.
isMagic
(
JS_UNINITIALIZED_LEXICAL
)
)
{
RootedString
symbolStr
(
cx
symbolId
.
toString
(
)
)
;
JS
:
:
UniqueChars
bytes
=
JS_EncodeStringToUTF8
(
cx
symbolStr
)
;
if
(
!
bytes
)
{
return
NS_ERROR_FAILURE
;
}
return
ReportOnCallerUTF8
(
cxhelper
ERROR_UNINITIALIZED_SYMBOL
aInfo
bytes
.
get
(
)
)
;
}
if
(
value
.
isUndefined
(
)
)
{
missing
=
true
;
}
if
(
!
JS_SetPropertyById
(
cx
aExports
symbolId
value
)
)
{
RootedString
symbolStr
(
cx
symbolId
.
toString
(
)
)
;
JS
:
:
UniqueChars
bytes
=
JS_EncodeStringToUTF8
(
cx
symbolStr
)
;
if
(
!
bytes
)
{
return
NS_ERROR_FAILURE
;
}
return
ReportOnCallerUTF8
(
cxhelper
ERROR_GETTING_SYMBOL
aInfo
bytes
.
get
(
)
)
;
}
#
ifdef
DEBUG
if
(
i
=
=
0
)
{
logBuffer
.
AssignLiteral
(
"
Installing
symbols
[
"
)
;
}
JS
:
:
UniqueChars
bytes
=
JS_EncodeStringToLatin1
(
cx
symbolId
.
toString
(
)
)
;
if
(
!
!
bytes
)
{
logBuffer
.
Append
(
bytes
.
get
(
)
)
;
}
logBuffer
.
Append
(
'
'
)
;
if
(
i
=
=
symbolCount
-
1
)
{
nsCString
location
;
MOZ_TRY
(
aInfo
.
GetLocation
(
location
)
)
;
LOG
(
(
"
%
s
]
from
%
s
\
n
"
logBuffer
.
get
(
)
location
.
get
(
)
)
)
;
}
#
endif
}
if
(
!
missing
)
{
aMod
-
>
exports
=
aExports
;
}
return
NS_OK
;
}
bool
mozJSModuleLoader
:
:
IsTrustedScheme
(
nsIURI
*
aURI
)
{
return
aURI
-
>
SchemeIs
(
"
resource
"
)
|
|
aURI
-
>
SchemeIs
(
"
chrome
"
)
;
}
nsresult
mozJSModuleLoader
:
:
Import
(
JSContext
*
aCx
const
nsACString
&
aLocation
JS
:
:
MutableHandleObject
aModuleGlobal
JS
:
:
MutableHandleObject
aModuleExports
bool
aIgnoreExports
)
{
mInitialized
=
true
;
AUTO_PROFILER_MARKER_TEXT
(
"
ChromeUtils
.
import
"
JS
MarkerOptions
(
MarkerStack
:
:
Capture
(
)
MarkerInnerWindowIdFromJSContext
(
aCx
)
)
aLocation
)
;
ModuleLoaderInfo
info
(
aLocation
)
;
nsresult
rv
;
ModuleEntry
*
mod
;
UniquePtr
<
ModuleEntry
>
newEntry
;
if
(
!
mImports
.
Get
(
info
.
Key
(
)
&
mod
)
&
&
!
mInProgressImports
.
Get
(
info
.
Key
(
)
&
mod
)
)
{
if
(
PastShutdownPhase
(
ShutdownPhase
:
:
XPCOMShutdownFinal
)
)
{
return
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
}
bool
aFound
;
rv
=
TryCachedFallbackToImportESModule
(
aCx
aLocation
aModuleGlobal
aModuleExports
aIgnoreExports
&
aFound
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aFound
)
{
return
NS_OK
;
}
newEntry
=
MakeUnique
<
ModuleEntry
>
(
RootingContext
:
:
get
(
aCx
)
)
;
MOZ_TRY
(
info
.
EnsureResolvedURI
(
)
)
;
if
(
!
IsTrustedScheme
(
info
.
URI
(
)
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
nsCOMPtr
<
nsIFile
>
sourceFile
;
rv
=
GetSourceFile
(
info
.
ResolvedURI
(
)
getter_AddRefs
(
sourceFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
info
.
ResolvedURI
(
)
-
>
GetSpec
(
newEntry
-
>
resolvedURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCString
*
existingPath
;
if
(
mLocations
.
Get
(
newEntry
-
>
resolvedURL
&
existingPath
)
&
&
*
existingPath
!
=
info
.
Key
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mLocations
.
InsertOrUpdate
(
newEntry
-
>
resolvedURL
MakeUnique
<
nsCString
>
(
info
.
Key
(
)
)
)
;
RootedValue
exception
(
aCx
)
;
{
mInProgressImports
.
InsertOrUpdate
(
info
.
Key
(
)
newEntry
.
get
(
)
)
;
auto
cleanup
=
MakeScopeExit
(
[
&
]
(
)
{
mInProgressImports
.
Remove
(
info
.
Key
(
)
)
;
}
)
;
rv
=
ObjectForLocation
(
info
sourceFile
&
newEntry
-
>
obj
&
newEntry
-
>
thisObjectKey
&
newEntry
-
>
location
true
&
exception
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
mLocations
.
Remove
(
newEntry
-
>
resolvedURL
)
;
if
(
!
exception
.
isUndefined
(
)
)
{
if
(
!
JS_WrapValue
(
aCx
&
exception
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
JS_SetPendingException
(
aCx
exception
)
;
return
NS_ERROR_FAILURE
;
}
if
(
rv
=
=
NS_ERROR_FILE_NOT_FOUND
)
{
return
TryFallbackToImportESModule
(
aCx
aLocation
aModuleGlobal
aModuleExports
aIgnoreExports
)
;
}
return
NS_ERROR_FILE_NOT_FOUND
;
}
#
ifdef
STARTUP_RECORDER_ENABLED
if
(
Preferences
:
:
GetBool
(
"
browser
.
startup
.
record
"
false
)
)
{
newEntry
-
>
importStack
=
xpc_PrintJSStack
(
aCx
false
false
false
)
.
get
(
)
;
}
#
endif
mod
=
newEntry
.
get
(
)
;
}
MOZ_ASSERT
(
mod
-
>
obj
"
Import
table
contains
entry
with
no
object
"
)
;
JS
:
:
RootedObject
globalProxy
(
aCx
)
;
{
JSAutoRealm
ar
(
aCx
mod
-
>
obj
)
;
globalProxy
=
CreateJSMEnvironmentProxy
(
aCx
mod
-
>
obj
)
;
if
(
!
globalProxy
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
!
JS_WrapObject
(
aCx
&
globalProxy
)
)
{
return
NS_ERROR_FAILURE
;
}
aModuleGlobal
.
set
(
globalProxy
)
;
JS
:
:
RootedObject
exports
(
aCx
mod
-
>
exports
)
;
if
(
!
exports
&
&
!
aIgnoreExports
)
{
MOZ_TRY
(
ExtractExports
(
aCx
info
mod
&
exports
)
)
;
}
if
(
exports
&
&
!
JS_WrapObject
(
aCx
&
exports
)
)
{
mLocations
.
Remove
(
newEntry
-
>
resolvedURL
)
;
return
NS_ERROR_FAILURE
;
}
aModuleExports
.
set
(
exports
)
;
if
(
newEntry
)
{
mImports
.
InsertOrUpdate
(
info
.
Key
(
)
std
:
:
move
(
newEntry
)
)
;
}
return
NS_OK
;
}
nsresult
mozJSModuleLoader
:
:
TryFallbackToImportESModule
(
JSContext
*
aCx
const
nsACString
&
aLocation
JS
:
:
MutableHandleObject
aModuleGlobal
JS
:
:
MutableHandleObject
aModuleExports
bool
aIgnoreExports
)
{
nsAutoCString
mjsLocation
;
if
(
!
TryToMJS
(
aLocation
mjsLocation
)
)
{
return
NS_ERROR_FILE_NOT_FOUND
;
}
JS
:
:
RootedObject
moduleNamespace
(
aCx
)
;
nsresult
rv
=
ImportESModule
(
aCx
mjsLocation
&
moduleNamespace
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
JS
:
:
RootedObject
globalProxy
(
aCx
)
;
{
JSAutoRealm
ar
(
aCx
moduleNamespace
)
;
JS
:
:
RootedObject
moduleObject
(
aCx
JS
:
:
GetModuleForNamespace
(
aCx
moduleNamespace
)
)
;
if
(
!
moduleObject
)
{
return
NS_ERROR_FAILURE
;
}
globalProxy
=
CreateModuleEnvironmentProxy
(
aCx
moduleObject
)
;
if
(
!
globalProxy
)
{
return
NS_ERROR_FAILURE
;
}
ModuleLoaderInfo
info
(
aLocation
)
;
auto
newEntry
=
MakeUnique
<
FallbackModuleEntry
>
(
RootingContext
:
:
get
(
aCx
)
)
;
newEntry
-
>
globalProxy
=
globalProxy
;
newEntry
-
>
moduleNamespace
=
moduleNamespace
;
mFallbackImports
.
InsertOrUpdate
(
info
.
Key
(
)
std
:
:
move
(
newEntry
)
)
;
}
if
(
!
JS_WrapObject
(
aCx
&
globalProxy
)
)
{
return
NS_ERROR_FAILURE
;
}
aModuleGlobal
.
set
(
globalProxy
)
;
if
(
!
aIgnoreExports
)
{
JS
:
:
RootedObject
exports
(
aCx
moduleNamespace
)
;
if
(
!
JS_WrapObject
(
aCx
&
exports
)
)
{
return
NS_ERROR_FAILURE
;
}
aModuleExports
.
set
(
exports
)
;
}
return
NS_OK
;
}
nsresult
mozJSModuleLoader
:
:
TryCachedFallbackToImportESModule
(
JSContext
*
aCx
const
nsACString
&
aLocation
JS
:
:
MutableHandleObject
aModuleGlobal
JS
:
:
MutableHandleObject
aModuleExports
bool
aIgnoreExports
bool
*
aFound
)
{
ModuleLoaderInfo
info
(
aLocation
)
;
FallbackModuleEntry
*
fallbackMod
;
if
(
!
mFallbackImports
.
Get
(
info
.
Key
(
)
&
fallbackMod
)
)
{
*
aFound
=
false
;
return
NS_OK
;
}
JS
:
:
RootedObject
globalProxy
(
aCx
fallbackMod
-
>
globalProxy
)
;
if
(
!
JS_WrapObject
(
aCx
&
globalProxy
)
)
{
return
NS_ERROR_FAILURE
;
}
aModuleGlobal
.
set
(
globalProxy
)
;
if
(
!
aIgnoreExports
)
{
JS
:
:
RootedObject
exports
(
aCx
fallbackMod
-
>
moduleNamespace
)
;
if
(
!
JS_WrapObject
(
aCx
&
exports
)
)
{
return
NS_ERROR_FAILURE
;
}
aModuleExports
.
set
(
exports
)
;
}
*
aFound
=
true
;
return
NS_OK
;
}
nsresult
mozJSModuleLoader
:
:
ImportESModule
(
JSContext
*
aCx
const
nsACString
&
aLocation
JS
:
:
MutableHandleObject
aModuleNamespace
)
{
using
namespace
JS
:
:
loader
;
MOZ_ASSERT
(
mModuleLoader
)
;
nsCString
str
(
aLocation
)
;
AUTO_PROFILER_MARKER_TEXT
(
"
ChromeUtils
.
importESModule
"
JS
MarkerOptions
(
MarkerStack
:
:
Capture
(
)
MarkerInnerWindowIdFromJSContext
(
aCx
)
)
aLocation
)
;
RootedObject
globalObj
(
aCx
GetSharedGlobal
(
aCx
)
)
;
NS_ENSURE_TRUE
(
globalObj
NS_ERROR_FAILURE
)
;
MOZ_ASSERT
(
xpc
:
:
Scriptability
:
:
Get
(
globalObj
)
.
Allowed
(
)
)
;
JSAutoRealm
ar
(
aCx
globalObj
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aLocation
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
mModuleLoader
-
>
GetGlobalObject
(
)
-
>
PrincipalOrNull
(
)
;
MOZ_ASSERT
(
principal
)
;
RefPtr
<
ScriptFetchOptions
>
options
=
new
ScriptFetchOptions
(
CORS_NONE
dom
:
:
ReferrerPolicy
:
:
No_referrer
principal
)
;
RefPtr
<
ComponentLoadContext
>
context
=
new
ComponentLoadContext
(
)
;
RefPtr
<
VisitedURLSet
>
visitedSet
=
ModuleLoadRequest
:
:
NewVisitedSetForTopLevelImport
(
uri
)
;
RefPtr
<
ModuleLoadRequest
>
request
=
new
ModuleLoadRequest
(
uri
options
dom
:
:
SRIMetadata
(
)
nullptr
context
true
false
mModuleLoader
visitedSet
nullptr
)
;
rv
=
request
-
>
StartModuleLoad
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mModuleLoader
-
>
ProcessRequests
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
request
-
>
IsReadyToRun
(
)
)
;
if
(
!
request
-
>
mModuleScript
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
request
-
>
InstantiateModuleGraph
(
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
mModuleLoader
-
>
EvaluateModuleInContext
(
aCx
request
JS
:
:
ThrowModuleErrorsSync
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
JS_IsExceptionPending
(
aCx
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
ModuleScript
>
moduleScript
=
request
-
>
mModuleScript
;
JS
:
:
Rooted
<
JSObject
*
>
module
(
aCx
moduleScript
-
>
ModuleRecord
(
)
)
;
aModuleNamespace
.
set
(
JS
:
:
GetModuleNamespace
(
aCx
module
)
)
;
return
NS_OK
;
}
nsresult
mozJSModuleLoader
:
:
Unload
(
const
nsACString
&
aLocation
)
{
if
(
!
mInitialized
)
{
return
NS_OK
;
}
ModuleLoaderInfo
info
(
aLocation
)
;
ModuleEntry
*
mod
;
if
(
mImports
.
Get
(
info
.
Key
(
)
&
mod
)
)
{
mLocations
.
Remove
(
mod
-
>
resolvedURL
)
;
mImports
.
Remove
(
info
.
Key
(
)
)
;
}
return
NS_OK
;
}
bool
mozJSModuleLoader
:
:
CreateJSServices
(
JSContext
*
aCx
)
{
JSObject
*
services
=
NewJSServices
(
aCx
)
;
if
(
!
services
)
{
return
false
;
}
mServicesObj
=
services
;
return
true
;
}
bool
mozJSModuleLoader
:
:
DefineJSServices
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
{
if
(
!
mServicesObj
)
{
MOZ_ASSERT
(
!
mLoaderGlobal
)
;
MOZ_ASSERT
(
mIsInitializingLoaderGlobal
)
;
return
true
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
services
(
aCx
ObjectValue
(
*
mServicesObj
)
)
;
if
(
!
JS_WrapValue
(
aCx
&
services
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
PropertyKey
>
servicesId
(
aCx
XPCJSContext
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_SERVICES
)
)
;
return
JS_DefinePropertyById
(
aCx
aGlobal
servicesId
services
0
)
;
}
size_t
mozJSModuleLoader
:
:
ModuleEntry
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
aMallocSizeOf
(
location
)
;
return
n
;
}
JSCLContextHelper
:
:
JSCLContextHelper
(
JSContext
*
aCx
)
:
mContext
(
aCx
)
mBuf
(
nullptr
)
{
}
JSCLContextHelper
:
:
~
JSCLContextHelper
(
)
{
if
(
mBuf
)
{
JS_ReportErrorUTF8
(
mContext
"
%
s
"
mBuf
.
get
(
)
)
;
}
}
void
JSCLContextHelper
:
:
reportErrorAfterPop
(
UniqueChars
&
&
buf
)
{
MOZ_ASSERT
(
!
mBuf
"
Already
called
reportErrorAfterPop
"
)
;
mBuf
=
std
:
:
move
(
buf
)
;
}
