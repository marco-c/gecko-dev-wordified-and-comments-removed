#
include
"
mozJSSubScriptLoader
.
h
"
#
include
"
mozJSComponentLoader
.
h
"
#
include
"
mozJSLoaderUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIFileURL
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
jswrapper
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
mozilla
/
ScriptPreloader
.
h
"
#
include
"
mozilla
/
scache
/
StartupCache
.
h
"
#
include
"
mozilla
/
scache
/
StartupCacheUtils
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsStringGlue
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
using
namespace
mozilla
:
:
scache
;
using
namespace
JS
;
using
namespace
xpc
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
class
MOZ_STACK_CLASS
LoadSubScriptOptions
:
public
OptionsBase
{
public
:
explicit
LoadSubScriptOptions
(
JSContext
*
cx
=
xpc_GetSafeJSContext
(
)
JSObject
*
options
=
nullptr
)
:
OptionsBase
(
cx
options
)
target
(
cx
)
charset
(
NullString
(
)
)
ignoreCache
(
false
)
async
(
false
)
wantReturnValue
(
false
)
{
}
virtual
bool
Parse
(
)
{
return
ParseObject
(
"
target
"
&
target
)
&
&
ParseString
(
"
charset
"
charset
)
&
&
ParseBoolean
(
"
ignoreCache
"
&
ignoreCache
)
&
&
ParseBoolean
(
"
async
"
&
async
)
&
&
ParseBoolean
(
"
wantReturnValue
"
&
wantReturnValue
)
;
}
RootedObject
target
;
nsString
charset
;
bool
ignoreCache
;
bool
async
;
bool
wantReturnValue
;
}
;
#
define
LOAD_ERROR_NOSERVICE
"
Error
creating
IO
Service
.
"
#
define
LOAD_ERROR_NOURI
"
Error
creating
URI
(
invalid
URL
scheme
?
)
"
#
define
LOAD_ERROR_NOSCHEME
"
Failed
to
get
URI
scheme
.
This
is
bad
.
"
#
define
LOAD_ERROR_URI_NOT_LOCAL
"
Trying
to
load
a
non
-
local
URI
.
"
#
define
LOAD_ERROR_NOSTREAM
"
Error
opening
input
stream
(
invalid
filename
?
)
"
#
define
LOAD_ERROR_NOCONTENT
"
ContentLength
not
available
(
not
a
local
URL
?
)
"
#
define
LOAD_ERROR_BADCHARSET
"
Error
converting
to
specified
charset
"
#
define
LOAD_ERROR_BADREAD
"
File
Read
Error
.
"
#
define
LOAD_ERROR_READUNDERFLOW
"
File
Read
Error
(
underflow
.
)
"
#
define
LOAD_ERROR_NOPRINCIPALS
"
Failed
to
get
principals
.
"
#
define
LOAD_ERROR_NOSPEC
"
Failed
to
get
URI
spec
.
This
is
bad
.
"
#
define
LOAD_ERROR_CONTENTTOOBIG
"
ContentLength
is
too
large
"
mozJSSubScriptLoader
:
:
mozJSSubScriptLoader
(
)
{
}
mozJSSubScriptLoader
:
:
~
mozJSSubScriptLoader
(
)
{
}
NS_IMPL_ISUPPORTS
(
mozJSSubScriptLoader
mozIJSSubScriptLoader
)
static
void
ReportError
(
JSContext
*
cx
const
nsACString
&
msg
)
{
NS_ConvertUTF8toUTF16
ucMsg
(
msg
)
;
RootedValue
exn
(
cx
)
;
if
(
xpc
:
:
NonVoidStringToJsval
(
cx
ucMsg
&
exn
)
)
{
JS_SetPendingException
(
cx
exn
)
;
}
}
static
void
ReportError
(
JSContext
*
cx
const
char
*
origMsg
nsIURI
*
uri
)
{
if
(
!
uri
)
{
ReportError
(
cx
nsDependentCString
(
origMsg
)
)
;
return
;
}
nsAutoCString
spec
;
nsresult
rv
=
uri
-
>
GetSpec
(
spec
)
;
if
(
NS_FAILED
(
rv
)
)
spec
.
Assign
(
"
(
unknown
)
"
)
;
nsAutoCString
msg
(
origMsg
)
;
msg
.
Append
(
"
:
"
)
;
msg
.
Append
(
spec
)
;
ReportError
(
cx
msg
)
;
}
static
bool
PrepareScript
(
nsIURI
*
uri
JSContext
*
cx
HandleObject
targetObj
const
char
*
uriStr
const
nsAString
&
charset
const
char
*
buf
int64_t
len
bool
reuseGlobal
bool
wantReturnValue
MutableHandleScript
script
MutableHandleFunction
function
)
{
JS
:
:
CompileOptions
options
(
cx
)
;
options
.
setFileAndLine
(
uriStr
reuseGlobal
?
0
:
1
)
.
setVersion
(
JSVERSION_LATEST
)
.
setNoScriptRval
(
!
wantReturnValue
)
;
if
(
!
charset
.
IsVoid
(
)
)
{
char16_t
*
scriptBuf
=
nullptr
;
size_t
scriptLength
=
0
;
nsresult
rv
=
ScriptLoader
:
:
ConvertToUTF16
(
nullptr
reinterpret_cast
<
const
uint8_t
*
>
(
buf
)
len
charset
nullptr
scriptBuf
scriptLength
)
;
JS
:
:
SourceBufferHolder
srcBuf
(
scriptBuf
scriptLength
JS
:
:
SourceBufferHolder
:
:
GiveOwnership
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReportError
(
cx
LOAD_ERROR_BADCHARSET
uri
)
;
return
false
;
}
if
(
!
reuseGlobal
)
{
if
(
JS_IsGlobalObject
(
targetObj
)
)
{
return
JS
:
:
Compile
(
cx
options
srcBuf
script
)
;
}
return
JS
:
:
CompileForNonSyntacticScope
(
cx
options
srcBuf
script
)
;
}
AutoObjectVector
envChain
(
cx
)
;
if
(
!
JS_IsGlobalObject
(
targetObj
)
&
&
!
envChain
.
append
(
targetObj
)
)
{
return
false
;
}
return
JS
:
:
CompileFunction
(
cx
envChain
options
nullptr
0
nullptr
srcBuf
function
)
;
}
if
(
!
reuseGlobal
)
{
options
.
setSourceIsLazy
(
true
)
;
if
(
JS_IsGlobalObject
(
targetObj
)
)
{
return
JS
:
:
Compile
(
cx
options
buf
len
script
)
;
}
return
JS
:
:
CompileForNonSyntacticScope
(
cx
options
buf
len
script
)
;
}
AutoObjectVector
envChain
(
cx
)
;
if
(
!
JS_IsGlobalObject
(
targetObj
)
&
&
!
envChain
.
append
(
targetObj
)
)
{
return
false
;
}
return
JS
:
:
CompileFunction
(
cx
envChain
options
nullptr
0
nullptr
buf
len
function
)
;
}
static
bool
EvalScript
(
JSContext
*
cx
HandleObject
targetObj
MutableHandleValue
retval
nsIURI
*
uri
bool
startupCache
bool
preloadCache
MutableHandleScript
script
HandleFunction
function
)
{
if
(
function
)
{
script
.
set
(
JS_GetFunctionScript
(
cx
function
)
)
;
}
if
(
function
)
{
if
(
!
JS_CallFunction
(
cx
targetObj
function
JS
:
:
HandleValueArray
:
:
empty
(
)
retval
)
)
{
return
false
;
}
}
else
{
if
(
JS_IsGlobalObject
(
targetObj
)
)
{
if
(
!
JS
:
:
CloneAndExecuteScript
(
cx
script
retval
)
)
{
return
false
;
}
}
else
{
JS
:
:
AutoObjectVector
envChain
(
cx
)
;
if
(
!
envChain
.
append
(
targetObj
)
)
{
return
false
;
}
if
(
!
JS
:
:
CloneAndExecuteScript
(
cx
envChain
script
retval
)
)
{
return
false
;
}
}
}
JSAutoCompartment
rac
(
cx
targetObj
)
;
if
(
!
JS_WrapValue
(
cx
retval
)
)
{
return
false
;
}
if
(
script
&
&
(
startupCache
|
|
preloadCache
)
)
{
nsAutoCString
cachePath
;
JSVersion
version
=
JS_GetVersion
(
cx
)
;
cachePath
.
AppendPrintf
(
"
jssubloader
/
%
d
"
version
)
;
PathifyURI
(
uri
cachePath
)
;
nsCOMPtr
<
nsIScriptSecurityManager
>
secman
=
do_GetService
(
NS_SCRIPTSECURITYMANAGER_CONTRACTID
)
;
if
(
!
secman
)
{
return
false
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
secman
-
>
GetSystemPrincipal
(
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
principal
)
{
ReportError
(
cx
LOAD_ERROR_NOPRINCIPALS
uri
)
;
return
false
;
}
nsCString
uriStr
;
if
(
preloadCache
&
&
NS_SUCCEEDED
(
uri
-
>
GetSpec
(
uriStr
)
)
)
{
ScriptPreloader
:
:
GetSingleton
(
)
.
NoteScript
(
uriStr
cachePath
script
)
;
}
if
(
startupCache
)
{
JSAutoCompartment
ac
(
cx
script
)
;
WriteCachedScript
(
StartupCache
:
:
GetSingleton
(
)
cachePath
cx
principal
script
)
;
}
}
return
true
;
}
class
AsyncScriptLoader
:
public
nsIIncrementalStreamLoaderObserver
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_NSIINCREMENTALSTREAMLOADEROBSERVER
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
AsyncScriptLoader
)
AsyncScriptLoader
(
nsIChannel
*
aChannel
bool
aReuseGlobal
bool
aWantReturnValue
JSObject
*
aTargetObj
const
nsAString
&
aCharset
bool
aCache
Promise
*
aPromise
)
:
mChannel
(
aChannel
)
mTargetObj
(
aTargetObj
)
mPromise
(
aPromise
)
mCharset
(
aCharset
)
mReuseGlobal
(
aReuseGlobal
)
mWantReturnValue
(
aWantReturnValue
)
mCache
(
aCache
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
}
private
:
virtual
~
AsyncScriptLoader
(
)
{
mozilla
:
:
DropJSObjects
(
this
)
;
}
RefPtr
<
nsIChannel
>
mChannel
;
Heap
<
JSObject
*
>
mTargetObj
;
RefPtr
<
Promise
>
mPromise
;
nsString
mCharset
;
bool
mReuseGlobal
;
bool
mWantReturnValue
;
bool
mCache
;
}
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
AsyncScriptLoader
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
AsyncScriptLoader
)
NS_INTERFACE_MAP_ENTRY
(
nsIIncrementalStreamLoaderObserver
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
AsyncScriptLoader
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPromise
)
tmp
-
>
mTargetObj
=
nullptr
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
AsyncScriptLoader
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPromise
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
AsyncScriptLoader
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mTargetObj
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
AsyncScriptLoader
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
AsyncScriptLoader
)
class
MOZ_STACK_CLASS
AutoRejectPromise
{
public
:
AutoRejectPromise
(
AutoEntryScript
&
aAutoEntryScript
Promise
*
aPromise
nsIGlobalObject
*
aGlobalObject
)
:
mAutoEntryScript
(
aAutoEntryScript
)
mPromise
(
aPromise
)
mGlobalObject
(
aGlobalObject
)
{
}
~
AutoRejectPromise
(
)
{
if
(
mPromise
)
{
JSContext
*
cx
=
mAutoEntryScript
.
cx
(
)
;
RootedValue
rejectionValue
(
cx
JS
:
:
UndefinedValue
(
)
)
;
if
(
mAutoEntryScript
.
HasException
(
)
)
{
Unused
<
<
mAutoEntryScript
.
PeekException
(
&
rejectionValue
)
;
}
mPromise
-
>
MaybeReject
(
cx
rejectionValue
)
;
}
}
void
ResolvePromise
(
HandleValue
aResolveValue
)
{
mPromise
-
>
MaybeResolve
(
aResolveValue
)
;
mPromise
=
nullptr
;
}
private
:
AutoEntryScript
&
mAutoEntryScript
;
RefPtr
<
Promise
>
mPromise
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobalObject
;
}
;
NS_IMETHODIMP
AsyncScriptLoader
:
:
OnIncrementalData
(
nsIIncrementalStreamLoader
*
aLoader
nsISupports
*
aContext
uint32_t
aDataLength
const
uint8_t
*
aData
uint32_t
*
aConsumedData
)
{
return
NS_OK
;
}
NS_IMETHODIMP
AsyncScriptLoader
:
:
OnStreamComplete
(
nsIIncrementalStreamLoader
*
aLoader
nsISupports
*
aContext
nsresult
aStatus
uint32_t
aLength
const
uint8_t
*
aBuf
)
{
nsCOMPtr
<
nsIURI
>
uri
;
mChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
globalObject
=
xpc
:
:
NativeGlobal
(
mTargetObj
)
;
AutoEntryScript
aes
(
globalObject
"
async
loadSubScript
"
)
;
AutoRejectPromise
autoPromise
(
aes
mPromise
globalObject
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
if
(
NS_FAILED
(
aStatus
)
)
{
ReportError
(
cx
"
Unable
to
load
script
.
"
uri
)
;
}
NS_ENSURE_SUCCESS
(
aStatus
NS_OK
)
;
if
(
aLength
=
=
0
)
{
ReportError
(
cx
LOAD_ERROR_NOCONTENT
uri
)
;
return
NS_OK
;
}
if
(
aLength
>
INT32_MAX
)
{
ReportError
(
cx
LOAD_ERROR_CONTENTTOOBIG
uri
)
;
return
NS_OK
;
}
RootedFunction
function
(
cx
)
;
RootedScript
script
(
cx
)
;
nsAutoCString
spec
;
nsresult
rv
=
uri
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RootedObject
targetObj
(
cx
mTargetObj
)
;
if
(
!
PrepareScript
(
uri
cx
targetObj
spec
.
get
(
)
mCharset
reinterpret_cast
<
const
char
*
>
(
aBuf
)
aLength
mReuseGlobal
mWantReturnValue
&
script
&
function
)
)
{
return
NS_OK
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
retval
(
cx
)
;
if
(
EvalScript
(
cx
targetObj
&
retval
uri
mCache
mCache
&
&
!
mWantReturnValue
&
script
function
)
)
{
autoPromise
.
ResolvePromise
(
retval
)
;
}
return
NS_OK
;
}
nsresult
mozJSSubScriptLoader
:
:
ReadScriptAsync
(
nsIURI
*
uri
HandleObject
targetObj
const
nsAString
&
charset
nsIIOService
*
serv
bool
reuseGlobal
bool
wantReturnValue
bool
cache
MutableHandleValue
retval
)
{
nsCOMPtr
<
nsIGlobalObject
>
globalObject
=
xpc
:
:
NativeGlobal
(
targetObj
)
;
ErrorResult
result
;
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
globalObject
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
globalObject
result
)
;
if
(
result
.
Failed
(
)
)
{
return
result
.
StealNSResult
(
)
;
}
DebugOnly
<
bool
>
asJS
=
ToJSValue
(
jsapi
.
cx
(
)
promise
retval
)
;
MOZ_ASSERT
(
asJS
"
Should
not
fail
to
convert
the
promise
to
a
JS
value
"
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
uri
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
nullptr
nullptr
nsIRequest
:
:
LOAD_NORMAL
serv
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
return
rv
;
}
channel
-
>
SetContentType
(
NS_LITERAL_CSTRING
(
"
application
/
javascript
"
)
)
;
RefPtr
<
AsyncScriptLoader
>
loadObserver
=
new
AsyncScriptLoader
(
channel
reuseGlobal
wantReturnValue
targetObj
charset
cache
promise
)
;
nsCOMPtr
<
nsIIncrementalStreamLoader
>
loader
;
rv
=
NS_NewIncrementalStreamLoader
(
getter_AddRefs
(
loader
)
loadObserver
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIStreamListener
>
listener
=
loader
.
get
(
)
;
return
channel
-
>
AsyncOpen2
(
listener
)
;
}
bool
mozJSSubScriptLoader
:
:
ReadScript
(
nsIURI
*
uri
JSContext
*
cx
HandleObject
targetObj
const
nsAString
&
charset
const
char
*
uriStr
nsIIOService
*
serv
bool
reuseGlobal
bool
wantReturnValue
MutableHandleScript
script
MutableHandleFunction
function
)
{
script
.
set
(
nullptr
)
;
function
.
set
(
nullptr
)
;
nsCOMPtr
<
nsIChannel
>
chan
;
nsCOMPtr
<
nsIInputStream
>
instream
;
nsresult
rv
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
chan
)
uri
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
nullptr
nullptr
nsIRequest
:
:
LOAD_NORMAL
serv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
chan
-
>
SetContentType
(
NS_LITERAL_CSTRING
(
"
application
/
javascript
"
)
)
;
rv
=
chan
-
>
Open2
(
getter_AddRefs
(
instream
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
ReportError
(
cx
LOAD_ERROR_NOSTREAM
uri
)
;
return
false
;
}
int64_t
len
=
-
1
;
rv
=
chan
-
>
GetContentLength
(
&
len
)
;
if
(
NS_FAILED
(
rv
)
|
|
len
=
=
-
1
)
{
ReportError
(
cx
LOAD_ERROR_NOCONTENT
uri
)
;
return
false
;
}
if
(
len
>
INT32_MAX
)
{
ReportError
(
cx
LOAD_ERROR_CONTENTTOOBIG
uri
)
;
return
false
;
}
nsCString
buf
;
rv
=
NS_ReadInputStreamToString
(
instream
buf
len
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
PrepareScript
(
uri
cx
targetObj
uriStr
charset
buf
.
get
(
)
len
reuseGlobal
wantReturnValue
script
function
)
;
}
NS_IMETHODIMP
mozJSSubScriptLoader
:
:
LoadSubScript
(
const
nsAString
&
url
HandleValue
target
const
nsAString
&
charset
JSContext
*
cx
MutableHandleValue
retval
)
{
LoadSubScriptOptions
options
(
cx
)
;
options
.
charset
=
charset
;
options
.
target
=
target
.
isObject
(
)
?
&
target
.
toObject
(
)
:
nullptr
;
return
DoLoadSubScriptWithOptions
(
url
options
cx
retval
)
;
}
NS_IMETHODIMP
mozJSSubScriptLoader
:
:
LoadSubScriptWithOptions
(
const
nsAString
&
url
HandleValue
optionsVal
JSContext
*
cx
MutableHandleValue
retval
)
{
if
(
!
optionsVal
.
isObject
(
)
)
return
NS_ERROR_INVALID_ARG
;
LoadSubScriptOptions
options
(
cx
&
optionsVal
.
toObject
(
)
)
;
if
(
!
options
.
Parse
(
)
)
return
NS_ERROR_INVALID_ARG
;
return
DoLoadSubScriptWithOptions
(
url
options
cx
retval
)
;
}
nsresult
mozJSSubScriptLoader
:
:
DoLoadSubScriptWithOptions
(
const
nsAString
&
url
LoadSubScriptOptions
&
options
JSContext
*
cx
MutableHandleValue
retval
)
{
nsresult
rv
=
NS_OK
;
if
(
!
mSystemPrincipal
)
{
nsCOMPtr
<
nsIScriptSecurityManager
>
secman
=
do_GetService
(
NS_SCRIPTSECURITYMANAGER_CONTRACTID
)
;
if
(
!
secman
)
return
NS_OK
;
rv
=
secman
-
>
GetSystemPrincipal
(
getter_AddRefs
(
mSystemPrincipal
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
mSystemPrincipal
)
return
rv
;
}
RootedObject
targetObj
(
cx
)
;
mozJSComponentLoader
*
loader
=
mozJSComponentLoader
:
:
Get
(
)
;
loader
-
>
FindTargetObject
(
cx
&
targetObj
)
;
bool
reusingGlobal
=
!
JS_IsGlobalObject
(
targetObj
)
;
if
(
options
.
target
)
targetObj
=
options
.
target
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
mSystemPrincipal
;
RootedObject
result_obj
(
cx
targetObj
)
;
targetObj
=
JS_FindCompilationScope
(
cx
targetObj
)
;
if
(
!
targetObj
)
return
NS_ERROR_FAILURE
;
if
(
targetObj
!
=
result_obj
)
principal
=
GetObjectPrincipal
(
targetObj
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsAutoCString
uriStr
;
nsAutoCString
scheme
;
JS
:
:
AutoFilename
filename
;
if
(
!
JS
:
:
DescribeScriptedCaller
(
cx
&
filename
)
)
{
return
NS_ERROR_FAILURE
;
}
JSAutoCompartment
ac
(
cx
targetObj
)
;
bool
ignoreCache
=
options
.
ignoreCache
|
|
principal
!
=
mSystemPrincipal
;
StartupCache
*
cache
=
ignoreCache
?
nullptr
:
StartupCache
:
:
GetSingleton
(
)
;
nsCOMPtr
<
nsIIOService
>
serv
=
do_GetService
(
NS_IOSERVICE_CONTRACTID
)
;
if
(
!
serv
)
{
ReportError
(
cx
NS_LITERAL_CSTRING
(
LOAD_ERROR_NOSERVICE
)
)
;
return
NS_OK
;
}
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
NS_LossyConvertUTF16toASCII
(
url
)
.
get
(
)
nullptr
serv
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReportError
(
cx
NS_LITERAL_CSTRING
(
LOAD_ERROR_NOURI
)
)
;
return
NS_OK
;
}
rv
=
uri
-
>
GetSpec
(
uriStr
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReportError
(
cx
NS_LITERAL_CSTRING
(
LOAD_ERROR_NOSPEC
)
)
;
return
NS_OK
;
}
rv
=
uri
-
>
GetScheme
(
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReportError
(
cx
LOAD_ERROR_NOSCHEME
uri
)
;
return
NS_OK
;
}
if
(
!
scheme
.
EqualsLiteral
(
"
chrome
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
app
"
)
)
{
nsCOMPtr
<
nsIURI
>
innerURI
=
NS_GetInnermostURI
(
uri
)
;
nsCOMPtr
<
nsIFileURL
>
fileURL
=
do_QueryInterface
(
innerURI
)
;
if
(
!
fileURL
)
{
ReportError
(
cx
LOAD_ERROR_URI_NOT_LOCAL
uri
)
;
return
NS_OK
;
}
nsAutoCString
tmp
(
filename
.
get
(
)
)
;
tmp
.
AppendLiteral
(
"
-
>
"
)
;
tmp
.
Append
(
uriStr
)
;
uriStr
=
tmp
;
}
JSVersion
version
=
JS_GetVersion
(
cx
)
;
nsAutoCString
cachePath
;
cachePath
.
AppendPrintf
(
"
jssubloader
/
%
d
"
version
)
;
PathifyURI
(
uri
cachePath
)
;
RootedFunction
function
(
cx
)
;
RootedScript
script
(
cx
)
;
if
(
!
options
.
ignoreCache
)
{
if
(
!
options
.
wantReturnValue
)
script
=
ScriptPreloader
:
:
GetSingleton
(
)
.
GetCachedScript
(
cx
cachePath
)
;
if
(
!
script
&
&
cache
)
rv
=
ReadCachedScript
(
cache
cachePath
cx
mSystemPrincipal
&
script
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
script
)
{
JS_ClearPendingException
(
cx
)
;
}
}
if
(
!
script
&
&
options
.
async
)
{
return
ReadScriptAsync
(
uri
targetObj
options
.
charset
serv
reusingGlobal
options
.
wantReturnValue
!
!
cache
retval
)
;
}
if
(
!
script
)
{
if
(
!
ReadScript
(
uri
cx
targetObj
options
.
charset
static_cast
<
const
char
*
>
(
uriStr
.
get
(
)
)
serv
reusingGlobal
options
.
wantReturnValue
&
script
&
function
)
)
{
return
NS_OK
;
}
}
else
{
cache
=
nullptr
;
}
Unused
<
<
EvalScript
(
cx
targetObj
retval
uri
!
!
cache
!
ignoreCache
&
&
!
options
.
wantReturnValue
&
script
function
)
;
return
NS_OK
;
}
class
ScriptPrecompiler
:
public
nsIIncrementalStreamLoaderObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIINCREMENTALSTREAMLOADEROBSERVER
ScriptPrecompiler
(
nsIObserver
*
aObserver
nsIPrincipal
*
aPrincipal
nsIChannel
*
aChannel
)
:
mObserver
(
aObserver
)
mPrincipal
(
aPrincipal
)
mChannel
(
aChannel
)
mScriptBuf
(
nullptr
)
mScriptLength
(
0
)
{
}
static
void
OffThreadCallback
(
void
*
aToken
void
*
aData
)
;
void
SendObserverNotification
(
)
;
private
:
virtual
~
ScriptPrecompiler
(
)
{
if
(
mScriptBuf
)
{
js_free
(
mScriptBuf
)
;
}
}
RefPtr
<
nsIObserver
>
mObserver
;
RefPtr
<
nsIPrincipal
>
mPrincipal
;
RefPtr
<
nsIChannel
>
mChannel
;
char16_t
*
mScriptBuf
;
size_t
mScriptLength
;
}
;
NS_IMPL_ISUPPORTS
(
ScriptPrecompiler
nsIIncrementalStreamLoaderObserver
)
;
class
NotifyPrecompilationCompleteRunnable
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
explicit
NotifyPrecompilationCompleteRunnable
(
ScriptPrecompiler
*
aPrecompiler
)
:
mPrecompiler
(
aPrecompiler
)
mToken
(
nullptr
)
{
}
void
SetToken
(
void
*
aToken
)
{
MOZ_ASSERT
(
aToken
&
&
!
mToken
)
;
mToken
=
aToken
;
}
protected
:
RefPtr
<
ScriptPrecompiler
>
mPrecompiler
;
void
*
mToken
;
}
;
class
AutoSendObserverNotification
{
public
:
explicit
AutoSendObserverNotification
(
ScriptPrecompiler
*
aPrecompiler
)
:
mPrecompiler
(
aPrecompiler
)
{
}
~
AutoSendObserverNotification
(
)
{
if
(
mPrecompiler
)
{
mPrecompiler
-
>
SendObserverNotification
(
)
;
}
}
void
Disarm
(
)
{
mPrecompiler
=
nullptr
;
}
private
:
ScriptPrecompiler
*
mPrecompiler
;
}
;
NS_IMETHODIMP
NotifyPrecompilationCompleteRunnable
:
:
Run
(
void
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mPrecompiler
)
;
AutoSendObserverNotification
notifier
(
mPrecompiler
)
;
if
(
mToken
)
{
JSContext
*
cx
=
XPCJSContext
:
:
Get
(
)
-
>
Context
(
)
;
NS_ENSURE_TRUE
(
cx
NS_ERROR_FAILURE
)
;
JS
:
:
CancelOffThreadScript
(
cx
mToken
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ScriptPrecompiler
:
:
OnIncrementalData
(
nsIIncrementalStreamLoader
*
aLoader
nsISupports
*
aContext
uint32_t
aDataLength
const
uint8_t
*
aData
uint32_t
*
aConsumedData
)
{
return
NS_OK
;
}
NS_IMETHODIMP
ScriptPrecompiler
:
:
OnStreamComplete
(
nsIIncrementalStreamLoader
*
aLoader
nsISupports
*
aContext
nsresult
aStatus
uint32_t
aLength
const
uint8_t
*
aString
)
{
AutoSendObserverNotification
notifier
(
this
)
;
NS_ENSURE_SUCCESS
(
aStatus
NS_OK
)
;
nsAutoString
hintCharset
;
nsresult
rv
=
ScriptLoader
:
:
ConvertToUTF16
(
mChannel
aString
aLength
hintCharset
nullptr
mScriptBuf
mScriptLength
)
;
NS_ENSURE_SUCCESS
(
rv
NS_OK
)
;
AutoSafeJSContext
cx
;
RootedValue
v
(
cx
)
;
SandboxOptions
sandboxOptions
;
sandboxOptions
.
sandboxName
.
AssignASCII
(
"
asm
.
js
precompilation
"
)
;
sandboxOptions
.
invisibleToDebugger
=
true
;
sandboxOptions
.
discardSource
=
true
;
rv
=
CreateSandboxObject
(
cx
&
v
mPrincipal
sandboxOptions
)
;
NS_ENSURE_SUCCESS
(
rv
NS_OK
)
;
JSAutoCompartment
ac
(
cx
js
:
:
UncheckedUnwrap
(
&
v
.
toObject
(
)
)
)
;
JS
:
:
CompileOptions
options
(
cx
JSVERSION_DEFAULT
)
;
options
.
forceAsync
=
true
;
nsCOMPtr
<
nsIURI
>
uri
;
mChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
nsAutoCString
spec
;
uri
-
>
GetSpec
(
spec
)
;
options
.
setFile
(
spec
.
get
(
)
)
;
if
(
!
JS
:
:
CanCompileOffThread
(
cx
options
mScriptLength
)
)
{
NS_WARNING
(
"
Can
'
t
compile
script
off
thread
!
"
)
;
return
NS_OK
;
}
RefPtr
<
NotifyPrecompilationCompleteRunnable
>
runnable
=
new
NotifyPrecompilationCompleteRunnable
(
this
)
;
if
(
!
JS
:
:
CompileOffThread
(
cx
options
mScriptBuf
mScriptLength
OffThreadCallback
static_cast
<
void
*
>
(
runnable
)
)
)
{
NS_WARNING
(
"
Failed
to
compile
script
off
thread
!
"
)
;
return
NS_OK
;
}
Unused
<
<
runnable
.
forget
(
)
;
notifier
.
Disarm
(
)
;
return
NS_OK
;
}
void
ScriptPrecompiler
:
:
OffThreadCallback
(
void
*
aToken
void
*
aData
)
{
RefPtr
<
NotifyPrecompilationCompleteRunnable
>
runnable
=
dont_AddRef
(
static_cast
<
NotifyPrecompilationCompleteRunnable
*
>
(
aData
)
)
;
runnable
-
>
SetToken
(
aToken
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
void
ScriptPrecompiler
:
:
SendObserverNotification
(
)
{
MOZ_ASSERT
(
mChannel
&
&
mObserver
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIURI
>
uri
;
mChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
mObserver
-
>
Observe
(
uri
"
script
-
precompiled
"
nullptr
)
;
}
NS_IMETHODIMP
mozJSSubScriptLoader
:
:
PrecompileScript
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
nsIObserver
*
aObserver
)
{
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
ScriptPrecompiler
>
loadObserver
=
new
ScriptPrecompiler
(
aObserver
aPrincipal
channel
)
;
nsCOMPtr
<
nsIIncrementalStreamLoader
>
loader
;
rv
=
NS_NewIncrementalStreamLoader
(
getter_AddRefs
(
loader
)
loadObserver
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIStreamListener
>
listener
=
loader
.
get
(
)
;
rv
=
channel
-
>
AsyncOpen2
(
listener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
