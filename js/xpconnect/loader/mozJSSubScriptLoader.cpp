#
include
"
mozJSSubScriptLoader
.
h
"
#
include
"
js
/
experimental
/
JSStencil
.
h
"
#
include
"
mozJSComponentLoader
.
h
"
#
include
"
mozJSLoaderUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
friend
/
JSMEnvironment
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
mozilla
/
ContentPrincipal
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
ScriptPreloader
.
h
"
#
include
"
mozilla
/
SystemPrincipal
.
h
"
#
include
"
mozilla
/
scache
/
StartupCache
.
h
"
#
include
"
mozilla
/
scache
/
StartupCacheUtils
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsString
.
h
"
using
namespace
mozilla
:
:
scache
;
using
namespace
JS
;
using
namespace
xpc
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
class
MOZ_STACK_CLASS
LoadSubScriptOptions
:
public
OptionsBase
{
public
:
explicit
LoadSubScriptOptions
(
JSContext
*
cx
=
xpc_GetSafeJSContext
(
)
JSObject
*
options
=
nullptr
)
:
OptionsBase
(
cx
options
)
target
(
cx
)
ignoreCache
(
false
)
wantReturnValue
(
false
)
{
}
virtual
bool
Parse
(
)
override
{
return
ParseObject
(
"
target
"
&
target
)
&
&
ParseBoolean
(
"
ignoreCache
"
&
ignoreCache
)
&
&
ParseBoolean
(
"
wantReturnValue
"
&
wantReturnValue
)
;
}
RootedObject
target
;
bool
ignoreCache
;
bool
wantReturnValue
;
}
;
#
define
LOAD_ERROR_NOSERVICE
"
Error
creating
IO
Service
.
"
#
define
LOAD_ERROR_NOURI
"
Error
creating
URI
(
invalid
URL
scheme
?
)
"
#
define
LOAD_ERROR_NOSCHEME
"
Failed
to
get
URI
scheme
.
This
is
bad
.
"
#
define
LOAD_ERROR_URI_NOT_LOCAL
"
Trying
to
load
a
non
-
local
URI
.
"
#
define
LOAD_ERROR_NOSTREAM
"
Error
opening
input
stream
(
invalid
filename
?
)
"
#
define
LOAD_ERROR_NOCONTENT
"
ContentLength
not
available
(
not
a
local
URL
?
)
"
#
define
LOAD_ERROR_BADCHARSET
"
Error
converting
to
specified
charset
"
#
define
LOAD_ERROR_NOSPEC
"
Failed
to
get
URI
spec
.
This
is
bad
.
"
#
define
LOAD_ERROR_CONTENTTOOBIG
"
ContentLength
is
too
large
"
mozJSSubScriptLoader
:
:
mozJSSubScriptLoader
(
)
=
default
;
mozJSSubScriptLoader
:
:
~
mozJSSubScriptLoader
(
)
=
default
;
NS_IMPL_ISUPPORTS
(
mozJSSubScriptLoader
mozIJSSubScriptLoader
)
#
define
JSSUB_CACHE_PREFIX
(
aType
)
"
jssubloader
/
"
aType
static
void
SubscriptCachePath
(
JSContext
*
cx
nsIURI
*
uri
JS
:
:
HandleObject
targetObj
nsACString
&
cachePath
)
{
if
(
!
JS_IsGlobalObject
(
targetObj
)
)
{
cachePath
.
AssignLiteral
(
JSSUB_CACHE_PREFIX
(
"
non
-
syntactic
"
)
)
;
}
else
{
cachePath
.
AssignLiteral
(
JSSUB_CACHE_PREFIX
(
"
global
"
)
)
;
}
PathifyURI
(
uri
cachePath
)
;
}
static
void
ReportError
(
JSContext
*
cx
const
nsACString
&
msg
)
{
NS_ConvertUTF8toUTF16
ucMsg
(
msg
)
;
RootedValue
exn
(
cx
)
;
if
(
xpc
:
:
NonVoidStringToJsval
(
cx
ucMsg
&
exn
)
)
{
JS_SetPendingException
(
cx
exn
)
;
}
}
static
void
ReportError
(
JSContext
*
cx
const
char
*
origMsg
nsIURI
*
uri
)
{
if
(
!
uri
)
{
ReportError
(
cx
nsDependentCString
(
origMsg
)
)
;
return
;
}
nsAutoCString
spec
;
nsresult
rv
=
uri
-
>
GetSpec
(
spec
)
;
if
(
NS_FAILED
(
rv
)
)
{
spec
.
AssignLiteral
(
"
(
unknown
)
"
)
;
}
nsAutoCString
msg
(
origMsg
)
;
msg
.
AppendLiteral
(
"
:
"
)
;
msg
.
Append
(
spec
)
;
ReportError
(
cx
msg
)
;
}
static
bool
EvalStencil
(
JSContext
*
cx
HandleObject
targetObj
HandleObject
loadScope
MutableHandleValue
retval
nsIURI
*
uri
bool
storeIntoStartupCache
bool
storeIntoPreloadCache
const
ReadOnlyCompileOptions
&
options
JS
:
:
Stencil
*
stencil
)
{
MOZ_ASSERT
(
!
js
:
:
IsWrapper
(
targetObj
)
)
;
JS
:
:
RootedScript
script
(
cx
JS
:
:
InstantiateGlobalStencil
(
cx
options
stencil
)
)
;
if
(
!
script
)
{
return
false
;
}
if
(
JS_IsGlobalObject
(
targetObj
)
)
{
if
(
!
JS
:
:
CloneAndExecuteScript
(
cx
script
retval
)
)
{
return
false
;
}
}
else
if
(
JS
:
:
IsJSMEnvironment
(
targetObj
)
)
{
if
(
!
JS
:
:
ExecuteInJSMEnvironment
(
cx
script
targetObj
)
)
{
return
false
;
}
retval
.
setUndefined
(
)
;
}
else
{
JS
:
:
RootedObjectVector
envChain
(
cx
)
;
if
(
!
envChain
.
append
(
targetObj
)
)
{
return
false
;
}
if
(
!
loadScope
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
JSObject
*
targetGlobal
=
JS
:
:
GetNonCCWObjectGlobal
(
targetObj
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mozJSComponentLoader
:
:
Get
(
)
-
>
IsLoaderGlobal
(
targetGlobal
)
"
Don
'
t
load
subscript
into
target
in
a
shared
-
global
JSM
"
)
;
#
endif
if
(
!
JS
:
:
CloneAndExecuteScript
(
cx
envChain
script
retval
)
)
{
return
false
;
}
}
else
if
(
JS_IsGlobalObject
(
loadScope
)
)
{
if
(
!
JS
:
:
CloneAndExecuteScript
(
cx
envChain
script
retval
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
JS
:
:
IsJSMEnvironment
(
loadScope
)
)
;
if
(
!
JS
:
:
ExecuteInJSMEnvironment
(
cx
script
loadScope
envChain
)
)
{
return
false
;
}
retval
.
setUndefined
(
)
;
}
}
JSAutoRealm
rar
(
cx
targetObj
)
;
if
(
!
JS_WrapValue
(
cx
retval
)
)
{
return
false
;
}
if
(
script
&
&
(
storeIntoStartupCache
|
|
storeIntoPreloadCache
)
)
{
nsAutoCString
cachePath
;
SubscriptCachePath
(
cx
uri
targetObj
cachePath
)
;
nsCString
uriStr
;
if
(
storeIntoPreloadCache
&
&
NS_SUCCEEDED
(
uri
-
>
GetSpec
(
uriStr
)
)
)
{
ScriptPreloader
:
:
GetSingleton
(
)
.
NoteScript
(
uriStr
cachePath
script
)
;
}
if
(
storeIntoStartupCache
)
{
JSAutoRealm
ar
(
cx
script
)
;
WriteCachedStencil
(
StartupCache
:
:
GetSingleton
(
)
cachePath
cx
options
stencil
)
;
}
}
return
true
;
}
bool
mozJSSubScriptLoader
:
:
ReadStencil
(
JS
:
:
Stencil
*
*
stencilOut
nsIURI
*
uri
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
nsIIOService
*
serv
bool
useCompilationScope
)
{
nsCOMPtr
<
nsIChannel
>
chan
;
nsCOMPtr
<
nsIInputStream
>
instream
;
nsresult
rv
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
chan
)
uri
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
nullptr
nullptr
nullptr
nullptr
nsIRequest
:
:
LOAD_NORMAL
serv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
chan
-
>
SetContentType
(
"
application
/
javascript
"
_ns
)
;
rv
=
chan
-
>
Open
(
getter_AddRefs
(
instream
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
ReportError
(
cx
LOAD_ERROR_NOSTREAM
uri
)
;
return
false
;
}
int64_t
len
=
-
1
;
rv
=
chan
-
>
GetContentLength
(
&
len
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReportError
(
cx
LOAD_ERROR_NOCONTENT
uri
)
;
return
false
;
}
if
(
len
>
INT32_MAX
)
{
ReportError
(
cx
LOAD_ERROR_CONTENTTOOBIG
uri
)
;
return
false
;
}
nsCString
buf
;
rv
=
NS_ReadInputStreamToString
(
instream
buf
len
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
len
<
0
)
{
len
=
buf
.
Length
(
)
;
}
#
ifdef
DEBUG
int64_t
currentLength
=
-
1
;
MOZ_ASSERT
(
chan
-
>
GetContentLength
(
&
currentLength
)
=
=
NS_OK
)
;
MOZ_ASSERT
(
currentLength
=
=
len
)
;
#
endif
Maybe
<
JSAutoRealm
>
ar
;
if
(
useCompilationScope
)
{
ar
.
emplace
(
cx
xpc
:
:
CompilationScope
(
)
)
;
}
JS
:
:
SourceText
<
Utf8Unit
>
srcBuf
;
if
(
!
srcBuf
.
init
(
cx
buf
.
get
(
)
len
JS
:
:
SourceOwnership
:
:
Borrowed
)
)
{
return
false
;
}
RefPtr
<
JS
:
:
Stencil
>
stencil
=
JS
:
:
CompileGlobalScriptToStencil
(
cx
options
srcBuf
)
;
stencil
.
forget
(
stencilOut
)
;
return
*
stencilOut
;
}
NS_IMETHODIMP
mozJSSubScriptLoader
:
:
LoadSubScript
(
const
nsAString
&
url
HandleValue
target
JSContext
*
cx
MutableHandleValue
retval
)
{
LoadSubScriptOptions
options
(
cx
)
;
options
.
target
=
target
.
isObject
(
)
?
&
target
.
toObject
(
)
:
nullptr
;
return
DoLoadSubScriptWithOptions
(
url
options
cx
retval
)
;
}
NS_IMETHODIMP
mozJSSubScriptLoader
:
:
LoadSubScriptWithOptions
(
const
nsAString
&
url
HandleValue
optionsVal
JSContext
*
cx
MutableHandleValue
retval
)
{
if
(
!
optionsVal
.
isObject
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
LoadSubScriptOptions
options
(
cx
&
optionsVal
.
toObject
(
)
)
;
if
(
!
options
.
Parse
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
DoLoadSubScriptWithOptions
(
url
options
cx
retval
)
;
}
nsresult
mozJSSubScriptLoader
:
:
DoLoadSubScriptWithOptions
(
const
nsAString
&
url
LoadSubScriptOptions
&
options
JSContext
*
cx
MutableHandleValue
retval
)
{
nsresult
rv
=
NS_OK
;
RootedObject
targetObj
(
cx
)
;
RootedObject
loadScope
(
cx
)
;
mozJSComponentLoader
*
loader
=
mozJSComponentLoader
:
:
Get
(
)
;
loader
-
>
FindTargetObject
(
cx
&
loadScope
)
;
if
(
options
.
target
)
{
targetObj
=
options
.
target
;
}
else
{
targetObj
=
loadScope
;
}
targetObj
=
JS_FindCompilationScope
(
cx
targetObj
)
;
if
(
!
targetObj
|
|
!
loadScope
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
js
:
:
IsWrapper
(
targetObj
)
"
JS_FindCompilationScope
must
unwrap
"
)
;
if
(
js
:
:
GetNonCCWObjectRealm
(
loadScope
)
!
=
js
:
:
GetNonCCWObjectRealm
(
targetObj
)
)
{
loadScope
=
nullptr
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsAutoCString
uriStr
;
nsAutoCString
scheme
;
JS
:
:
AutoFilename
filename
;
if
(
!
JS
:
:
DescribeScriptedCaller
(
cx
&
filename
)
)
{
return
NS_ERROR_FAILURE
;
}
JSAutoRealm
ar
(
cx
targetObj
)
;
nsCOMPtr
<
nsIIOService
>
serv
=
do_GetService
(
NS_IOSERVICE_CONTRACTID
)
;
if
(
!
serv
)
{
ReportError
(
cx
nsLiteralCString
(
LOAD_ERROR_NOSERVICE
)
)
;
return
NS_OK
;
}
NS_LossyConvertUTF16toASCII
asciiUrl
(
url
)
;
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING_NONSENSITIVE
(
"
mozJSSubScriptLoader
:
:
DoLoadSubScriptWithOptions
"
OTHER
asciiUrl
)
;
AUTO_PROFILER_MARKER_TEXT
(
"
SubScript
"
JS
MarkerOptions
(
MarkerStack
:
:
Capture
(
)
MarkerInnerWindowIdFromJSContext
(
cx
)
)
asciiUrl
)
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
asciiUrl
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReportError
(
cx
nsLiteralCString
(
LOAD_ERROR_NOURI
)
)
;
return
NS_OK
;
}
rv
=
uri
-
>
GetSpec
(
uriStr
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReportError
(
cx
nsLiteralCString
(
LOAD_ERROR_NOSPEC
)
)
;
return
NS_OK
;
}
rv
=
uri
-
>
GetScheme
(
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReportError
(
cx
LOAD_ERROR_NOSCHEME
uri
)
;
return
NS_OK
;
}
bool
useCompilationScope
=
false
;
auto
*
principal
=
BasePrincipal
:
:
Cast
(
GetObjectPrincipal
(
targetObj
)
)
;
bool
isSystem
=
principal
-
>
Is
<
SystemPrincipal
>
(
)
;
if
(
!
isSystem
&
&
principal
-
>
Is
<
ContentPrincipal
>
(
)
)
{
nsAutoCString
scheme
;
principal
-
>
GetScheme
(
scheme
)
;
if
(
scheme
.
EqualsLiteral
(
"
about
"
)
)
{
nsAutoCString
filePath
;
principal
-
>
GetFilePath
(
filePath
)
;
useCompilationScope
=
filePath
.
EqualsLiteral
(
"
home
"
)
|
|
filePath
.
EqualsLiteral
(
"
newtab
"
)
|
|
filePath
.
EqualsLiteral
(
"
welcome
"
)
;
isSystem
=
true
;
}
}
bool
ignoreCache
=
options
.
ignoreCache
|
|
!
isSystem
|
|
scheme
.
EqualsLiteral
(
"
blob
"
)
;
StartupCache
*
cache
=
ignoreCache
?
nullptr
:
StartupCache
:
:
GetSingleton
(
)
;
nsAutoCString
cachePath
;
SubscriptCachePath
(
cx
uri
targetObj
cachePath
)
;
JS
:
:
CompileOptions
compileOptions
(
cx
)
;
ScriptPreloader
:
:
FillCompileOptionsForCachedScript
(
compileOptions
)
;
compileOptions
.
setFileAndLine
(
uriStr
.
get
(
)
1
)
;
compileOptions
.
setNonSyntacticScope
(
!
JS_IsGlobalObject
(
targetObj
)
)
;
if
(
options
.
wantReturnValue
)
{
compileOptions
.
setNoScriptRval
(
false
)
;
}
RefPtr
<
JS
:
:
Stencil
>
stencil
;
if
(
!
options
.
ignoreCache
)
{
if
(
cache
)
{
rv
=
ReadCachedStencil
(
cache
cachePath
cx
compileOptions
getter_AddRefs
(
stencil
)
)
;
}
if
(
NS_FAILED
(
rv
)
|
|
!
stencil
)
{
JS_ClearPendingException
(
cx
)
;
}
}
bool
storeIntoStartupCache
=
false
;
if
(
!
stencil
)
{
storeIntoStartupCache
=
cache
;
if
(
!
ReadStencil
(
getter_AddRefs
(
stencil
)
uri
cx
compileOptions
serv
useCompilationScope
)
)
{
return
NS_OK
;
}
}
bool
storeIntoPreloadCache
=
!
ignoreCache
&
&
!
options
.
wantReturnValue
;
Unused
<
<
EvalStencil
(
cx
targetObj
loadScope
retval
uri
storeIntoStartupCache
storeIntoPreloadCache
compileOptions
stencil
)
;
return
NS_OK
;
}
