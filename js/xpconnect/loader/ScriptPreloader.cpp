#
include
"
ScriptPreloader
-
inl
.
h
"
#
include
"
mozilla
/
ScriptPreloader
.
h
"
#
include
"
mozilla
/
loader
/
ScriptCacheActors
.
h
"
#
include
"
mozilla
/
URLPreloader
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
IOBuffers
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
xpcpublic
.
h
"
#
define
STARTUP_COMPLETE_TOPIC
"
browser
-
delayed
-
startup
-
finished
"
#
define
DOC_ELEM_INSERTED_TOPIC
"
document
-
element
-
inserted
"
#
define
CONTENT_DOCUMENT_LOADED_TOPIC
"
content
-
document
-
loaded
"
#
define
CACHE_WRITE_TOPIC
"
browser
-
idle
-
startup
-
tasks
-
finished
"
#
define
CLEANUP_TOPIC
"
xpcom
-
shutdown
"
#
define
CACHE_INVALIDATE_TOPIC
"
startupcache
-
invalidate
"
constexpr
uint32_t
CHILD_STARTUP_TIMEOUT_MS
=
8000
;
namespace
mozilla
{
namespace
{
static
LazyLogModule
gLog
(
"
ScriptPreloader
"
)
;
#
define
LOG
(
level
.
.
.
)
MOZ_LOG
(
gLog
LogLevel
:
:
level
(
__VA_ARGS__
)
)
}
using
mozilla
:
:
dom
:
:
AutoJSAPI
;
using
mozilla
:
:
dom
:
:
ContentChild
;
using
mozilla
:
:
dom
:
:
ContentParent
;
using
namespace
mozilla
:
:
loader
;
ProcessType
ScriptPreloader
:
:
sProcessType
;
nsresult
ScriptPreloader
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
script
-
preloader
/
heap
/
saved
-
scripts
"
KIND_HEAP
UNITS_BYTES
SizeOfHashEntries
<
ScriptStatus
:
:
Saved
>
(
mScripts
MallocSizeOf
)
"
Memory
used
to
hold
the
scripts
which
have
been
executed
in
this
"
"
session
and
will
be
written
to
the
startup
script
cache
file
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
script
-
preloader
/
heap
/
restored
-
scripts
"
KIND_HEAP
UNITS_BYTES
SizeOfHashEntries
<
ScriptStatus
:
:
Restored
>
(
mScripts
MallocSizeOf
)
"
Memory
used
to
hold
the
scripts
which
have
been
restored
from
the
"
"
startup
script
cache
file
but
have
not
been
executed
in
this
session
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
script
-
preloader
/
heap
/
other
"
KIND_HEAP
UNITS_BYTES
ShallowHeapSizeOfIncludingThis
(
MallocSizeOf
)
"
Memory
used
by
the
script
cache
service
itself
.
"
)
;
if
(
XRE_IsParentProcess
(
)
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
script
-
preloader
/
non
-
heap
/
memmapped
-
cache
"
KIND_NONHEAP
UNITS_BYTES
mCacheData
.
nonHeapSizeOfExcludingThis
(
)
"
The
memory
-
mapped
startup
script
cache
file
.
"
)
;
}
else
{
MOZ_COLLECT_REPORT
(
"
script
-
preloader
-
memmapped
-
cache
"
KIND_NONHEAP
UNITS_BYTES
mCacheData
.
nonHeapSizeOfExcludingThis
(
)
"
The
memory
-
mapped
startup
script
cache
file
.
"
)
;
}
return
NS_OK
;
}
ScriptPreloader
&
ScriptPreloader
:
:
GetSingleton
(
)
{
static
RefPtr
<
ScriptPreloader
>
singleton
;
if
(
!
singleton
)
{
if
(
XRE_IsParentProcess
(
)
)
{
singleton
=
new
ScriptPreloader
(
)
;
singleton
-
>
mChildCache
=
&
GetChildSingleton
(
)
;
Unused
<
<
singleton
-
>
InitCache
(
)
;
}
else
{
singleton
=
&
GetChildSingleton
(
)
;
}
ClearOnShutdown
(
&
singleton
)
;
}
return
*
singleton
;
}
ScriptPreloader
&
ScriptPreloader
:
:
GetChildSingleton
(
)
{
static
RefPtr
<
ScriptPreloader
>
singleton
;
if
(
!
singleton
)
{
singleton
=
new
ScriptPreloader
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
Unused
<
<
singleton
-
>
InitCache
(
u
"
scriptCache
-
child
"
_ns
)
;
}
ClearOnShutdown
(
&
singleton
)
;
}
return
*
singleton
;
}
void
ScriptPreloader
:
:
InitContentChild
(
ContentParent
&
parent
)
{
auto
&
cache
=
GetChildSingleton
(
)
;
auto
processType
=
GetChildProcessType
(
parent
.
GetRemoteType
(
)
)
;
bool
wantScriptData
=
!
cache
.
mInitializedProcesses
.
contains
(
processType
)
;
cache
.
mInitializedProcesses
+
=
processType
;
auto
fd
=
cache
.
mCacheData
.
cloneFileDescriptor
(
)
;
if
(
fd
.
IsValid
(
)
&
&
!
cache
.
mCacheInvalidated
)
{
Unused
<
<
parent
.
SendPScriptCacheConstructor
(
fd
wantScriptData
)
;
}
else
{
Unused
<
<
parent
.
SendPScriptCacheConstructor
(
NS_ERROR_FILE_NOT_FOUND
wantScriptData
)
;
}
}
ProcessType
ScriptPreloader
:
:
GetChildProcessType
(
const
nsACString
&
remoteType
)
{
if
(
remoteType
=
=
EXTENSION_REMOTE_TYPE
)
{
return
ProcessType
:
:
Extension
;
}
if
(
remoteType
=
=
PRIVILEGEDABOUT_REMOTE_TYPE
)
{
return
ProcessType
:
:
PrivilegedAbout
;
}
return
ProcessType
:
:
Web
;
}
namespace
{
static
void
TraceOp
(
JSTracer
*
trc
void
*
data
)
{
auto
preloader
=
static_cast
<
ScriptPreloader
*
>
(
data
)
;
preloader
-
>
Trace
(
trc
)
;
}
}
void
ScriptPreloader
:
:
Trace
(
JSTracer
*
trc
)
{
for
(
auto
&
script
:
IterHash
(
mScripts
)
)
{
script
-
>
mScript
.
Trace
(
trc
)
;
}
}
ScriptPreloader
:
:
ScriptPreloader
(
)
:
mMonitor
(
"
[
ScriptPreloader
.
mMonitor
]
"
)
mSaveMonitor
(
"
[
ScriptPreloader
.
mSaveMonitor
]
"
)
{
if
(
XRE_IsParentProcess
(
)
)
{
sProcessType
=
ProcessType
:
:
Parent
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
MOZ_RELEASE_ASSERT
(
obs
)
;
if
(
XRE_IsParentProcess
(
)
)
{
obs
-
>
AddObserver
(
this
STARTUP_COMPLETE_TOPIC
false
)
;
obs
-
>
AddObserver
(
this
CACHE_WRITE_TOPIC
false
)
;
}
obs
-
>
AddObserver
(
this
CLEANUP_TOPIC
false
)
;
obs
-
>
AddObserver
(
this
CACHE_INVALIDATE_TOPIC
false
)
;
AutoSafeJSAPI
jsapi
;
JS_AddExtraGCRootsTracer
(
jsapi
.
cx
(
)
TraceOp
this
)
;
}
void
ScriptPreloader
:
:
Cleanup
(
)
{
{
MonitorAutoLock
mal
(
mMonitor
)
;
FinishPendingParses
(
mal
)
;
mScripts
.
Clear
(
)
;
}
AutoSafeJSAPI
jsapi
;
JS_RemoveExtraGCRootsTracer
(
jsapi
.
cx
(
)
TraceOp
this
)
;
UnregisterWeakMemoryReporter
(
this
)
;
}
void
ScriptPreloader
:
:
StartCacheWrite
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mSaveThread
)
;
Unused
<
<
NS_NewNamedThread
(
"
SaveScripts
"
getter_AddRefs
(
mSaveThread
)
this
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
barrier
=
GetShutdownBarrier
(
)
;
barrier
-
>
AddBlocker
(
this
NS_LITERAL_STRING_FROM_CSTRING
(
__FILE__
)
__LINE__
u
"
"
_ns
)
;
}
void
ScriptPreloader
:
:
InvalidateCache
(
)
{
{
mMonitor
.
AssertNotCurrentThreadOwns
(
)
;
MonitorAutoLock
mal
(
mMonitor
)
;
FinishPendingParses
(
mal
)
;
MOZ_ASSERT
(
mParsingScripts
.
empty
(
)
)
;
MOZ_ASSERT
(
mParsingSources
.
empty
(
)
)
;
MOZ_ASSERT
(
mPendingScripts
.
isEmpty
(
)
)
;
for
(
auto
&
script
:
IterHash
(
mScripts
)
)
{
script
.
Remove
(
)
;
}
if
(
mSaveComplete
&
&
mChildCache
)
{
mSaveComplete
=
false
;
StartCacheWrite
(
)
;
}
}
{
MonitorAutoLock
saveMonitorAutoLock
(
mSaveMonitor
)
;
mCacheInvalidated
=
true
;
}
mSaveMonitor
.
NotifyAll
(
)
;
}
nsresult
ScriptPreloader
:
:
Observe
(
nsISupports
*
subject
const
char
*
topic
const
char16_t
*
data
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
!
strcmp
(
topic
STARTUP_COMPLETE_TOPIC
)
)
{
obs
-
>
RemoveObserver
(
this
STARTUP_COMPLETE_TOPIC
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
mStartupFinished
=
true
;
}
else
if
(
!
strcmp
(
topic
CACHE_WRITE_TOPIC
)
)
{
obs
-
>
RemoveObserver
(
this
CACHE_WRITE_TOPIC
)
;
MOZ_ASSERT
(
mStartupFinished
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
mChildCache
&
&
!
mSaveComplete
&
&
!
mSaveThread
)
{
StartCacheWrite
(
)
;
}
}
else
if
(
mContentStartupFinishedTopic
.
Equals
(
topic
)
)
{
if
(
nsCOMPtr
<
dom
:
:
Document
>
doc
=
do_QueryInterface
(
subject
)
)
{
nsCOMPtr
<
nsIURI
>
uri
=
doc
-
>
GetDocumentURI
(
)
;
if
(
(
NS_IsAboutBlank
(
uri
)
&
&
doc
-
>
GetReadyStateEnum
(
)
=
=
doc
-
>
READYSTATE_UNINITIALIZED
)
|
|
uri
-
>
SchemeIs
(
"
chrome
"
)
)
{
return
NS_OK
;
}
}
FinishContentStartup
(
)
;
}
else
if
(
!
strcmp
(
topic
"
timer
-
callback
"
)
)
{
FinishContentStartup
(
)
;
}
else
if
(
!
strcmp
(
topic
CLEANUP_TOPIC
)
)
{
Cleanup
(
)
;
}
else
if
(
!
strcmp
(
topic
CACHE_INVALIDATE_TOPIC
)
)
{
InvalidateCache
(
)
;
}
return
NS_OK
;
}
void
ScriptPreloader
:
:
FinishContentStartup
(
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
#
ifdef
DEBUG
if
(
mContentStartupFinishedTopic
.
Equals
(
CONTENT_DOCUMENT_LOADED_TOPIC
)
)
{
MOZ_ASSERT
(
sProcessType
=
=
ProcessType
:
:
PrivilegedAbout
)
;
}
else
{
MOZ_ASSERT
(
sProcessType
!
=
ProcessType
:
:
PrivilegedAbout
)
;
}
#
endif
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
obs
-
>
RemoveObserver
(
this
mContentStartupFinishedTopic
.
get
(
)
)
;
mSaveTimer
=
nullptr
;
mStartupFinished
=
true
;
if
(
mChildActor
)
{
mChildActor
-
>
SendScriptsAndFinalize
(
mScripts
)
;
}
#
ifdef
XP_WIN
if
(
sProcessType
!
=
ProcessType
:
:
PrivilegedAbout
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
MEMORY_UNIQUE_CONTENT_STARTUP
nsMemoryReporterManager
:
:
ResidentUnique
(
)
/
1024
)
;
}
#
endif
}
bool
ScriptPreloader
:
:
WillWriteScripts
(
)
{
return
!
mDataPrepared
&
&
(
XRE_IsParentProcess
(
)
|
|
mChildActor
)
;
}
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
ScriptPreloader
:
:
GetCacheFile
(
const
nsAString
&
suffix
)
{
NS_ENSURE_TRUE
(
mProfD
Err
(
NS_ERROR_NOT_INITIALIZED
)
)
;
nsCOMPtr
<
nsIFile
>
cacheFile
;
MOZ_TRY
(
mProfD
-
>
Clone
(
getter_AddRefs
(
cacheFile
)
)
)
;
MOZ_TRY
(
cacheFile
-
>
AppendNative
(
"
startupCache
"
_ns
)
)
;
Unused
<
<
cacheFile
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0777
)
;
MOZ_TRY
(
cacheFile
-
>
Append
(
mBaseName
+
suffix
)
)
;
return
std
:
:
move
(
cacheFile
)
;
}
static
const
uint8_t
MAGIC
[
]
=
"
mozXDRcachev002
"
;
Result
<
Ok
nsresult
>
ScriptPreloader
:
:
OpenCache
(
)
{
MOZ_TRY
(
NS_GetSpecialDirectory
(
"
ProfLDS
"
getter_AddRefs
(
mProfD
)
)
)
;
nsCOMPtr
<
nsIFile
>
cacheFile
;
MOZ_TRY_VAR
(
cacheFile
GetCacheFile
(
u
"
.
bin
"
_ns
)
)
;
bool
exists
;
MOZ_TRY
(
cacheFile
-
>
Exists
(
&
exists
)
)
;
if
(
exists
)
{
MOZ_TRY
(
cacheFile
-
>
MoveTo
(
nullptr
mBaseName
+
u
"
-
current
.
bin
"
_ns
)
)
;
}
else
{
MOZ_TRY
(
cacheFile
-
>
SetLeafName
(
mBaseName
+
u
"
-
current
.
bin
"
_ns
)
)
;
MOZ_TRY
(
cacheFile
-
>
Exists
(
&
exists
)
)
;
if
(
!
exists
)
{
return
Err
(
NS_ERROR_FILE_NOT_FOUND
)
;
}
}
MOZ_TRY
(
mCacheData
.
init
(
cacheFile
)
)
;
return
Ok
(
)
;
}
Result
<
Ok
nsresult
>
ScriptPreloader
:
:
InitCache
(
const
nsAString
&
basePath
)
{
mCacheInitialized
=
true
;
mBaseName
=
basePath
;
RegisterWeakMemoryReporter
(
this
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
Ok
(
)
;
}
AutoSafeJSAPI
jsapi
;
JS
:
:
RootedObject
scope
(
jsapi
.
cx
(
)
xpc
:
:
CompilationScope
(
)
)
;
URLPreloader
:
:
AutoBeginReading
abr
;
MOZ_TRY
(
OpenCache
(
)
)
;
return
InitCacheInternal
(
scope
)
;
}
Result
<
Ok
nsresult
>
ScriptPreloader
:
:
InitCache
(
const
Maybe
<
ipc
:
:
FileDescriptor
>
&
cacheFile
ScriptCacheChild
*
cacheChild
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
mCacheInitialized
=
true
;
mChildActor
=
cacheChild
;
sProcessType
=
GetChildProcessType
(
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
GetRemoteType
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
MOZ_RELEASE_ASSERT
(
obs
)
;
if
(
sProcessType
=
=
ProcessType
:
:
PrivilegedAbout
)
{
mContentStartupFinishedTopic
.
AssignLiteral
(
CONTENT_DOCUMENT_LOADED_TOPIC
)
;
}
else
{
mContentStartupFinishedTopic
.
AssignLiteral
(
DOC_ELEM_INSERTED_TOPIC
)
;
}
obs
-
>
AddObserver
(
this
mContentStartupFinishedTopic
.
get
(
)
false
)
;
RegisterWeakMemoryReporter
(
this
)
;
auto
cleanup
=
MakeScopeExit
(
[
&
]
{
if
(
cacheChild
)
{
NS_NewTimerWithObserver
(
getter_AddRefs
(
mSaveTimer
)
this
CHILD_STARTUP_TIMEOUT_MS
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
}
)
;
if
(
cacheFile
.
isNothing
(
)
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
mCacheData
.
init
(
cacheFile
.
ref
(
)
)
)
;
return
InitCacheInternal
(
)
;
}
Result
<
Ok
nsresult
>
ScriptPreloader
:
:
InitCacheInternal
(
JS
:
:
HandleObject
scope
)
{
auto
size
=
mCacheData
.
size
(
)
;
uint32_t
headerSize
;
if
(
size
<
sizeof
(
MAGIC
)
+
sizeof
(
headerSize
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
auto
data
=
mCacheData
.
get
<
uint8_t
>
(
)
;
auto
end
=
data
+
size
;
if
(
memcmp
(
MAGIC
data
.
get
(
)
sizeof
(
MAGIC
)
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
data
+
=
sizeof
(
MAGIC
)
;
headerSize
=
LittleEndian
:
:
readUint32
(
data
.
get
(
)
)
;
data
+
=
sizeof
(
headerSize
)
;
if
(
data
+
headerSize
>
end
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
{
auto
cleanup
=
MakeScopeExit
(
[
&
]
(
)
{
mScripts
.
Clear
(
)
;
}
)
;
LinkedList
<
CachedScript
>
scripts
;
Range
<
uint8_t
>
header
(
data
data
+
headerSize
)
;
data
+
=
headerSize
;
InputBuffer
buf
(
header
)
;
size_t
offset
=
0
;
while
(
!
buf
.
finished
(
)
)
{
auto
script
=
MakeUnique
<
CachedScript
>
(
*
this
buf
)
;
MOZ_RELEASE_ASSERT
(
script
)
;
auto
scriptData
=
data
+
script
-
>
mOffset
;
if
(
scriptData
+
script
-
>
mSize
>
end
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
script
-
>
mOffset
!
=
offset
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
offset
+
=
script
-
>
mSize
;
script
-
>
mXDRRange
.
emplace
(
scriptData
scriptData
+
script
-
>
mSize
)
;
if
(
script
-
>
mOriginalProcessTypes
.
contains
(
CurrentProcessType
(
)
)
)
{
scripts
.
insertBack
(
script
.
get
(
)
)
;
}
else
{
script
-
>
mReadyToExecute
=
true
;
}
mScripts
.
Put
(
script
-
>
mCachePath
script
.
get
(
)
)
;
Unused
<
<
script
.
release
(
)
;
}
if
(
buf
.
error
(
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
mPendingScripts
=
std
:
:
move
(
scripts
)
;
cleanup
.
release
(
)
;
}
DecodeNextBatch
(
OFF_THREAD_FIRST_CHUNK_SIZE
scope
)
;
return
Ok
(
)
;
}
void
ScriptPreloader
:
:
PrepareCacheWriteInternal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
auto
cleanup
=
MakeScopeExit
(
[
&
]
(
)
{
if
(
mChildCache
)
{
mChildCache
-
>
PrepareCacheWrite
(
)
;
}
}
)
;
if
(
mDataPrepared
)
{
return
;
}
AutoSafeJSAPI
jsapi
;
bool
found
=
false
;
for
(
auto
&
script
:
IterHash
(
mScripts
Match
<
ScriptStatus
:
:
Saved
>
(
)
)
)
{
CachedScript
*
childScript
=
mChildCache
?
mChildCache
-
>
mScripts
.
Get
(
script
-
>
mCachePath
)
:
nullptr
;
if
(
childScript
&
&
!
childScript
-
>
mProcessTypes
.
isEmpty
(
)
)
{
childScript
-
>
UpdateLoadTime
(
script
-
>
mLoadTime
)
;
childScript
-
>
mProcessTypes
+
=
script
-
>
mProcessTypes
;
script
.
Remove
(
)
;
continue
;
}
if
(
!
(
script
-
>
mProcessTypes
=
=
script
-
>
mOriginalProcessTypes
)
)
{
found
=
true
;
}
if
(
!
script
-
>
mSize
&
&
!
script
-
>
XDREncode
(
jsapi
.
cx
(
)
)
)
{
script
.
Remove
(
)
;
}
}
if
(
!
found
)
{
mSaveComplete
=
true
;
return
;
}
mDataPrepared
=
true
;
}
void
ScriptPreloader
:
:
PrepareCacheWrite
(
)
{
MonitorAutoLock
mal
(
mMonitor
)
;
PrepareCacheWriteInternal
(
)
;
}
Result
<
Ok
nsresult
>
ScriptPreloader
:
:
WriteCache
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
!
mDataPrepared
&
&
!
mSaveComplete
)
{
MonitorAutoUnlock
mau
(
mSaveMonitor
)
;
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
ScriptPreloader
:
:
PrepareCacheWrite
"
this
&
ScriptPreloader
:
:
PrepareCacheWrite
)
NS_DISPATCH_SYNC
)
;
}
if
(
mSaveComplete
)
{
return
Ok
(
)
;
}
nsCOMPtr
<
nsIFile
>
cacheFile
;
MOZ_TRY_VAR
(
cacheFile
GetCacheFile
(
u
"
-
new
.
bin
"
_ns
)
)
;
bool
exists
;
MOZ_TRY
(
cacheFile
-
>
Exists
(
&
exists
)
)
;
if
(
exists
)
{
MOZ_TRY
(
cacheFile
-
>
Remove
(
false
)
)
;
}
{
AutoFDClose
fd
;
MOZ_TRY
(
cacheFile
-
>
OpenNSPRFileDesc
(
PR_WRONLY
|
PR_CREATE_FILE
0644
&
fd
.
rwget
(
)
)
)
;
mMonitor
.
AssertNotCurrentThreadOwns
(
)
;
MonitorAutoLock
mal
(
mMonitor
)
;
nsTArray
<
CachedScript
*
>
scripts
;
for
(
auto
&
script
:
IterHash
(
mScripts
Match
<
ScriptStatus
:
:
Saved
>
(
)
)
)
{
scripts
.
AppendElement
(
script
)
;
}
scripts
.
Sort
(
CachedScript
:
:
Comparator
(
)
)
;
OutputBuffer
buf
;
size_t
offset
=
0
;
for
(
auto
script
:
scripts
)
{
script
-
>
mOffset
=
offset
;
script
-
>
Code
(
buf
)
;
offset
+
=
script
-
>
mSize
;
}
uint8_t
headerSize
[
4
]
;
LittleEndian
:
:
writeUint32
(
headerSize
buf
.
cursor
(
)
)
;
MOZ_TRY
(
Write
(
fd
MAGIC
sizeof
(
MAGIC
)
)
)
;
MOZ_TRY
(
Write
(
fd
headerSize
sizeof
(
headerSize
)
)
)
;
MOZ_TRY
(
Write
(
fd
buf
.
Get
(
)
buf
.
cursor
(
)
)
)
;
for
(
auto
script
:
scripts
)
{
MOZ_TRY
(
Write
(
fd
script
-
>
Range
(
)
.
begin
(
)
.
get
(
)
script
-
>
mSize
)
)
;
if
(
script
-
>
mScript
)
{
script
-
>
FreeData
(
)
;
}
}
}
MOZ_TRY
(
cacheFile
-
>
MoveTo
(
nullptr
mBaseName
+
u
"
.
bin
"
_ns
)
)
;
return
Ok
(
)
;
}
nsresult
ScriptPreloader
:
:
Run
(
)
{
MonitorAutoLock
mal
(
mSaveMonitor
)
;
if
(
!
mCacheInvalidated
)
{
mal
.
Wait
(
TimeDuration
:
:
FromSeconds
(
10
)
)
;
}
auto
result
=
URLPreloader
:
:
GetSingleton
(
)
.
WriteCache
(
)
;
Unused
<
<
NS_WARN_IF
(
result
.
isErr
(
)
)
;
result
=
WriteCache
(
)
;
Unused
<
<
NS_WARN_IF
(
result
.
isErr
(
)
)
;
result
=
mChildCache
-
>
WriteCache
(
)
;
Unused
<
<
NS_WARN_IF
(
result
.
isErr
(
)
)
;
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
ScriptPreloader
:
:
CacheWriteComplete
"
this
&
ScriptPreloader
:
:
CacheWriteComplete
)
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
void
ScriptPreloader
:
:
CacheWriteComplete
(
)
{
mSaveThread
-
>
AsyncShutdown
(
)
;
mSaveThread
=
nullptr
;
mSaveComplete
=
true
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
barrier
=
GetShutdownBarrier
(
)
;
barrier
-
>
RemoveBlocker
(
this
)
;
}
void
ScriptPreloader
:
:
NoteScript
(
const
nsCString
&
url
const
nsCString
&
cachePath
JS
:
:
HandleScript
jsscript
bool
isRunOnce
)
{
if
(
!
Active
(
)
)
{
if
(
isRunOnce
)
{
if
(
auto
script
=
mScripts
.
Get
(
cachePath
)
)
{
script
-
>
mIsRunOnce
=
true
;
script
-
>
MaybeDropScript
(
)
;
}
}
return
;
}
if
(
cachePath
.
FindChar
(
'
?
'
)
>
=
0
)
{
return
;
}
constexpr
auto
mochikitPrefix
=
"
chrome
:
/
/
mochikit
/
"
_ns
;
if
(
StringHead
(
url
mochikitPrefix
.
Length
(
)
)
=
=
mochikitPrefix
)
{
return
;
}
auto
script
=
mScripts
.
LookupOrAdd
(
cachePath
*
this
url
cachePath
jsscript
)
;
if
(
isRunOnce
)
{
script
-
>
mIsRunOnce
=
true
;
}
if
(
!
script
-
>
MaybeDropScript
(
)
&
&
!
script
-
>
mScript
)
{
MOZ_ASSERT
(
jsscript
)
;
script
-
>
mScript
.
Set
(
jsscript
)
;
script
-
>
mReadyToExecute
=
true
;
}
script
-
>
UpdateLoadTime
(
TimeStamp
:
:
Now
(
)
)
;
script
-
>
mProcessTypes
+
=
CurrentProcessType
(
)
;
}
void
ScriptPreloader
:
:
NoteScript
(
const
nsCString
&
url
const
nsCString
&
cachePath
ProcessType
processType
nsTArray
<
uint8_t
>
&
&
xdrData
TimeStamp
loadTime
)
{
if
(
mDataPrepared
)
{
return
;
}
auto
script
=
mScripts
.
LookupOrAdd
(
cachePath
*
this
url
cachePath
nullptr
)
;
if
(
!
script
-
>
HasRange
(
)
)
{
MOZ_ASSERT
(
!
script
-
>
HasArray
(
)
)
;
script
-
>
mSize
=
xdrData
.
Length
(
)
;
script
-
>
mXDRData
.
construct
<
nsTArray
<
uint8_t
>
>
(
std
:
:
forward
<
nsTArray
<
uint8_t
>
>
(
xdrData
)
)
;
auto
&
data
=
script
-
>
Array
(
)
;
script
-
>
mXDRRange
.
emplace
(
data
.
Elements
(
)
data
.
Length
(
)
)
;
}
if
(
!
script
-
>
mSize
&
&
!
script
-
>
mScript
)
{
mScripts
.
Remove
(
cachePath
)
;
return
;
}
script
-
>
UpdateLoadTime
(
loadTime
)
;
script
-
>
mProcessTypes
+
=
processType
;
}
void
ScriptPreloader
:
:
FillCompileOptionsForCachedScript
(
JS
:
:
CompileOptions
&
options
)
{
options
.
setNoScriptRval
(
true
)
;
MOZ_ASSERT
(
!
options
.
selfHostingMode
)
;
MOZ_ASSERT
(
!
options
.
isRunOnce
)
;
}
JSScript
*
ScriptPreloader
:
:
GetCachedScript
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
const
nsCString
&
path
)
{
if
(
mChildCache
)
{
RootedScript
script
(
cx
mChildCache
-
>
GetCachedScriptInternal
(
cx
options
path
)
)
;
if
(
script
)
{
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_SCRIPT_PRELOADER_REQUESTS
:
:
HitChild
)
;
return
script
;
}
}
RootedScript
script
(
cx
GetCachedScriptInternal
(
cx
options
path
)
)
;
Telemetry
:
:
AccumulateCategorical
(
script
?
Telemetry
:
:
LABELS_SCRIPT_PRELOADER_REQUESTS
:
:
Hit
:
Telemetry
:
:
LABELS_SCRIPT_PRELOADER_REQUESTS
:
:
Miss
)
;
return
script
;
}
JSScript
*
ScriptPreloader
:
:
GetCachedScriptInternal
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
const
nsCString
&
path
)
{
auto
script
=
mScripts
.
Get
(
path
)
;
if
(
script
)
{
return
WaitForCachedScript
(
cx
options
script
)
;
}
return
nullptr
;
}
JSScript
*
ScriptPreloader
:
:
WaitForCachedScript
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
CachedScript
*
script
)
{
MaybeFinishOffThreadDecode
(
)
;
if
(
!
script
-
>
mReadyToExecute
)
{
LOG
(
Info
"
Must
wait
for
async
script
load
:
%
s
\
n
"
script
-
>
mURL
.
get
(
)
)
;
auto
start
=
TimeStamp
:
:
Now
(
)
;
if
(
script
-
>
mSize
<
MAX_MAINTHREAD_DECODE_SIZE
)
{
LOG
(
Info
"
Script
is
small
enough
to
recompile
on
main
thread
\
n
"
)
;
script
-
>
mReadyToExecute
=
true
;
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
SCRIPT_PRELOADER_MAINTHREAD_RECOMPILE
1
)
;
}
else
{
MonitorAutoLock
mal
(
mMonitor
)
;
while
(
!
script
-
>
mReadyToExecute
)
{
if
(
mToken
)
{
MonitorAutoUnlock
mau
(
mMonitor
)
;
MaybeFinishOffThreadDecode
(
)
;
}
else
{
MOZ_ASSERT
(
!
mParsingScripts
.
empty
(
)
)
;
mal
.
Wait
(
)
;
}
}
}
double
waitedMS
=
(
TimeStamp
:
:
Now
(
)
-
start
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SCRIPT_PRELOADER_WAIT_TIME
int
(
waitedMS
)
)
;
LOG
(
Debug
"
Waited
%
fms
\
n
"
waitedMS
)
;
}
return
script
-
>
GetJSScript
(
cx
options
)
;
}
void
ScriptPreloader
:
:
OffThreadDecodeCallback
(
JS
:
:
OffThreadToken
*
token
void
*
context
)
{
auto
cache
=
static_cast
<
ScriptPreloader
*
>
(
context
)
;
cache
-
>
mMonitor
.
AssertNotCurrentThreadOwns
(
)
;
MonitorAutoLock
mal
(
cache
-
>
mMonitor
)
;
cache
-
>
mToken
=
token
;
mal
.
NotifyAll
(
)
;
if
(
cache
-
>
mToken
&
&
!
cache
-
>
mFinishDecodeRunnablePending
)
{
cache
-
>
mFinishDecodeRunnablePending
=
true
;
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
ScriptPreloader
:
:
DoFinishOffThreadDecode
"
cache
&
ScriptPreloader
:
:
DoFinishOffThreadDecode
)
)
;
}
}
void
ScriptPreloader
:
:
FinishPendingParses
(
MonitorAutoLock
&
aMal
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
mPendingScripts
.
clear
(
)
;
while
(
!
mParsingScripts
.
empty
(
)
)
{
if
(
mToken
)
{
MonitorAutoUnlock
mau
(
mMonitor
)
;
MaybeFinishOffThreadDecode
(
)
;
}
else
{
aMal
.
Wait
(
)
;
}
}
}
void
ScriptPreloader
:
:
DoFinishOffThreadDecode
(
)
{
mFinishDecodeRunnablePending
=
false
;
MaybeFinishOffThreadDecode
(
)
;
}
void
ScriptPreloader
:
:
MaybeFinishOffThreadDecode
(
)
{
mMonitor
.
AssertNotCurrentThreadOwns
(
)
;
if
(
!
mToken
)
{
return
;
}
auto
cleanup
=
MakeScopeExit
(
[
&
]
(
)
{
mToken
=
nullptr
;
mParsingSources
.
clear
(
)
;
mParsingScripts
.
clear
(
)
;
DecodeNextBatch
(
OFF_THREAD_CHUNK_SIZE
)
;
}
)
;
AutoSafeJSAPI
jsapi
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JSAutoRealm
ar
(
cx
xpc
:
:
CompilationScope
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
ScriptVector
>
jsScripts
(
cx
JS
:
:
ScriptVector
(
cx
)
)
;
Unused
<
<
JS
:
:
FinishMultiOffThreadScriptsDecoder
(
cx
mToken
&
jsScripts
)
;
unsigned
i
=
0
;
for
(
auto
script
:
mParsingScripts
)
{
LOG
(
Debug
"
Finished
off
-
thread
decode
of
%
s
\
n
"
script
-
>
mURL
.
get
(
)
)
;
if
(
i
<
jsScripts
.
length
(
)
)
{
script
-
>
mScript
.
Set
(
jsScripts
[
i
+
+
]
)
;
}
script
-
>
mReadyToExecute
=
true
;
}
}
void
ScriptPreloader
:
:
DecodeNextBatch
(
size_t
chunkSize
JS
:
:
HandleObject
scope
)
{
MOZ_ASSERT
(
mParsingSources
.
length
(
)
=
=
0
)
;
MOZ_ASSERT
(
mParsingScripts
.
length
(
)
=
=
0
)
;
auto
cleanup
=
MakeScopeExit
(
[
&
]
(
)
{
mParsingScripts
.
clearAndFree
(
)
;
mParsingSources
.
clearAndFree
(
)
;
}
)
;
auto
start
=
TimeStamp
:
:
Now
(
)
;
LOG
(
Debug
"
Off
-
thread
decoding
scripts
.
.
.
\
n
"
)
;
size_t
size
=
0
;
for
(
CachedScript
*
next
=
mPendingScripts
.
getFirst
(
)
;
next
;
)
{
auto
script
=
next
;
next
=
script
-
>
getNext
(
)
;
if
(
script
-
>
mReadyToExecute
)
{
script
-
>
remove
(
)
;
continue
;
}
if
(
size
>
SMALL_SCRIPT_CHUNK_THRESHOLD
&
&
size
+
script
-
>
mSize
>
chunkSize
)
{
break
;
}
if
(
!
mParsingScripts
.
append
(
script
)
|
|
!
mParsingSources
.
emplaceBack
(
script
-
>
Range
(
)
script
-
>
mURL
.
get
(
)
0
)
)
{
break
;
}
LOG
(
Debug
"
Beginning
off
-
thread
decode
of
script
%
s
(
%
u
bytes
)
\
n
"
script
-
>
mURL
.
get
(
)
script
-
>
mSize
)
;
script
-
>
remove
(
)
;
size
+
=
script
-
>
mSize
;
}
if
(
size
=
=
0
&
&
mPendingScripts
.
isEmpty
(
)
)
{
return
;
}
AutoSafeJSAPI
jsapi
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JSAutoRealm
ar
(
cx
scope
?
scope
:
xpc
:
:
CompilationScope
(
)
)
;
JS
:
:
CompileOptions
options
(
cx
)
;
FillCompileOptionsForCachedScript
(
options
)
;
options
.
setSourceIsLazy
(
true
)
;
if
(
!
JS
:
:
CanCompileOffThread
(
cx
options
size
)
|
|
!
JS
:
:
DecodeMultiOffThreadScripts
(
cx
options
mParsingSources
OffThreadDecodeCallback
static_cast
<
void
*
>
(
this
)
)
)
{
MOZ_ASSERT
(
mPendingScripts
.
isEmpty
(
)
)
;
for
(
auto
script
:
mPendingScripts
)
{
script
-
>
mReadyToExecute
=
true
;
}
LOG
(
Info
"
Can
'
t
decode
%
lu
bytes
of
scripts
off
-
thread
"
(
unsigned
long
)
size
)
;
for
(
auto
script
:
mParsingScripts
)
{
script
-
>
mReadyToExecute
=
true
;
}
return
;
}
cleanup
.
release
(
)
;
LOG
(
Debug
"
Initialized
decoding
of
%
u
scripts
(
%
u
bytes
)
in
%
fms
\
n
"
(
unsigned
)
mParsingSources
.
length
(
)
(
unsigned
)
size
(
TimeStamp
:
:
Now
(
)
-
start
)
.
ToMilliseconds
(
)
)
;
}
ScriptPreloader
:
:
CachedScript
:
:
CachedScript
(
ScriptPreloader
&
cache
InputBuffer
&
buf
)
:
mCache
(
cache
)
{
Code
(
buf
)
;
mOriginalProcessTypes
=
mProcessTypes
;
mProcessTypes
=
{
}
;
}
void
ScriptPreloader
:
:
CachedScript
:
:
ScriptHolder
:
:
Trace
(
JSTracer
*
trc
)
{
JS
:
:
TraceEdge
(
trc
&
mScript
"
ScriptPreloader
:
:
CachedScript
.
mScript
"
)
;
}
void
ScriptPreloader
:
:
CachedScript
:
:
ScriptHolder
:
:
Set
(
JS
:
:
HandleScript
jsscript
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mScript
=
jsscript
;
mHasScript
=
mScript
;
}
void
ScriptPreloader
:
:
CachedScript
:
:
ScriptHolder
:
:
Clear
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mScript
=
nullptr
;
mHasScript
=
false
;
}
bool
ScriptPreloader
:
:
CachedScript
:
:
XDREncode
(
JSContext
*
cx
)
{
auto
cleanup
=
MakeScopeExit
(
[
&
]
(
)
{
MaybeDropScript
(
)
;
}
)
;
JSAutoRealm
ar
(
cx
mScript
.
Get
(
)
)
;
JS
:
:
RootedScript
jsscript
(
cx
mScript
.
Get
(
)
)
;
mXDRData
.
construct
<
JS
:
:
TranscodeBuffer
>
(
)
;
JS
:
:
TranscodeResult
code
=
JS
:
:
EncodeScript
(
cx
Buffer
(
)
jsscript
)
;
if
(
code
=
=
JS
:
:
TranscodeResult_Ok
)
{
mXDRRange
.
emplace
(
Buffer
(
)
.
begin
(
)
Buffer
(
)
.
length
(
)
)
;
mSize
=
Range
(
)
.
length
(
)
;
return
true
;
}
mXDRData
.
destroy
(
)
;
JS_ClearPendingException
(
cx
)
;
return
false
;
}
JSScript
*
ScriptPreloader
:
:
CachedScript
:
:
GetJSScript
(
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
)
{
MOZ_ASSERT
(
mReadyToExecute
)
;
if
(
mScript
)
{
if
(
JS
:
:
CheckCompileOptionsMatch
(
options
mScript
.
Get
(
)
)
)
{
return
mScript
.
Get
(
)
;
}
LOG
(
Error
"
Cached
script
%
s
has
different
options
\
n
"
mURL
.
get
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Cached
script
has
different
options
"
)
;
}
if
(
!
HasRange
(
)
)
{
return
nullptr
;
}
auto
start
=
TimeStamp
:
:
Now
(
)
;
LOG
(
Info
"
Decoding
script
%
s
on
main
thread
.
.
.
\
n
"
mURL
.
get
(
)
)
;
JS
:
:
RootedScript
script
(
cx
)
;
if
(
JS
:
:
DecodeScript
(
cx
options
Range
(
)
&
script
)
)
{
mScript
.
Set
(
script
)
;
if
(
mCache
.
mSaveComplete
)
{
FreeData
(
)
;
}
}
LOG
(
Debug
"
Finished
decoding
in
%
fms
"
(
TimeStamp
:
:
Now
(
)
-
start
)
.
ToMilliseconds
(
)
)
;
return
mScript
.
Get
(
)
;
}
nsresult
ScriptPreloader
:
:
GetName
(
nsAString
&
aName
)
{
aName
.
AssignLiteral
(
u
"
ScriptPreloader
:
Saving
bytecode
cache
"
)
;
return
NS_OK
;
}
nsresult
ScriptPreloader
:
:
GetState
(
nsIPropertyBag
*
*
aState
)
{
*
aState
=
nullptr
;
return
NS_OK
;
}
nsresult
ScriptPreloader
:
:
BlockShutdown
(
nsIAsyncShutdownClient
*
aBarrierClient
)
{
mSaveMonitor
.
NotifyAll
(
)
;
return
NS_OK
;
}
already_AddRefed
<
nsIAsyncShutdownClient
>
ScriptPreloader
:
:
GetShutdownBarrier
(
)
{
nsCOMPtr
<
nsIAsyncShutdownService
>
svc
=
components
:
:
AsyncShutdown
:
:
Service
(
)
;
MOZ_RELEASE_ASSERT
(
svc
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
barrier
;
Unused
<
<
svc
-
>
GetXpcomWillShutdown
(
getter_AddRefs
(
barrier
)
)
;
MOZ_RELEASE_ASSERT
(
barrier
)
;
return
barrier
.
forget
(
)
;
}
NS_IMPL_ISUPPORTS
(
ScriptPreloader
nsIObserver
nsIRunnable
nsIMemoryReporter
nsIAsyncShutdownBlocker
)
#
undef
LOG
}
