#
ifndef
ScriptPreloader_h
#
define
ScriptPreloader_h
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
loader
/
AutoMemMap
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
jsapi
.
h
"
#
include
<
prio
.
h
>
namespace
mozilla
{
namespace
loader
{
class
InputBuffer
;
}
using
namespace
mozilla
:
:
loader
;
class
ScriptPreloader
:
public
nsIObserver
public
nsIMemoryReporter
public
nsIRunnable
{
MOZ_DEFINE_MALLOC_SIZE_OF
(
MallocSizeOf
)
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSIMEMORYREPORTER
NS_DECL_NSIRUNNABLE
static
ScriptPreloader
&
GetSingleton
(
)
;
JSScript
*
GetCachedScript
(
JSContext
*
cx
const
nsCString
&
name
)
;
void
NoteScript
(
const
nsCString
&
url
const
nsCString
&
cachePath
JS
:
:
HandleScript
script
)
;
Result
<
Ok
nsresult
>
InitCache
(
)
;
void
Trace
(
JSTracer
*
trc
)
;
protected
:
virtual
~
ScriptPreloader
(
)
=
default
;
private
:
class
CachedScript
:
public
LinkedListElement
<
CachedScript
>
{
public
:
CachedScript
(
CachedScript
&
&
)
=
default
;
CachedScript
(
const
nsCString
&
url
const
nsCString
&
cachePath
JSScript
*
script
)
:
mURL
(
url
)
mCachePath
(
cachePath
)
mScript
(
script
)
mReadyToExecute
(
true
)
{
}
explicit
inline
CachedScript
(
InputBuffer
&
buf
)
;
~
CachedScript
(
)
{
auto
&
cache
=
GetSingleton
(
)
;
#
ifdef
DEBUG
auto
hashValue
=
cache
.
mScripts
.
Get
(
mCachePath
)
;
MOZ_ASSERT_IF
(
hashValue
hashValue
=
=
this
)
;
#
endif
cache
.
mScripts
.
Remove
(
mCachePath
)
;
}
bool
XDREncode
(
JSContext
*
cx
)
;
template
<
typename
Buffer
>
void
Code
(
Buffer
&
buffer
)
{
buffer
.
codeString
(
mURL
)
;
buffer
.
codeString
(
mCachePath
)
;
buffer
.
codeUint32
(
mOffset
)
;
buffer
.
codeUint32
(
mSize
)
;
}
JS
:
:
TranscodeBuffer
&
Data
(
)
{
MOZ_ASSERT
(
mXDRData
.
isSome
(
)
)
;
return
mXDRData
.
ref
(
)
;
}
const
JS
:
:
TranscodeRange
&
Range
(
)
{
MOZ_ASSERT
(
mXDRRange
.
isSome
(
)
)
;
return
mXDRRange
.
ref
(
)
;
}
JSScript
*
GetJSScript
(
JSContext
*
cx
)
;
size_t
HeapSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
auto
size
=
mallocSizeOf
(
this
)
;
if
(
mXDRData
.
isSome
(
)
)
{
size
+
=
(
mXDRData
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
+
mURL
.
SizeOfExcludingThisEvenIfShared
(
mallocSizeOf
)
+
mCachePath
.
SizeOfExcludingThisEvenIfShared
(
mallocSizeOf
)
)
;
}
return
size
;
}
nsCString
mURL
;
nsCString
mCachePath
;
uint32_t
mOffset
=
0
;
uint32_t
mSize
=
0
;
JS
:
:
Heap
<
JSScript
*
>
mScript
;
bool
mReadyToExecute
=
false
;
void
*
mToken
=
nullptr
;
Maybe
<
JS
:
:
TranscodeRange
>
mXDRRange
;
Maybe
<
JS
:
:
TranscodeBuffer
>
mXDRData
;
}
;
static
constexpr
int
MIN_OFFTHREAD_SIZE
=
20
*
1024
;
static
constexpr
int
MAX_MAINTHREAD_DECODE_SIZE
=
50
*
1024
;
ScriptPreloader
(
)
;
void
ForceWriteCacheFile
(
)
;
void
Cleanup
(
)
;
Result
<
Ok
nsresult
>
OpenCache
(
)
;
Result
<
Ok
nsresult
>
WriteCache
(
)
;
void
PrepareCacheWrite
(
)
;
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
GetCacheFile
(
const
char
*
leafName
)
;
static
CachedScript
*
FindScript
(
LinkedList
<
CachedScript
>
&
scripts
const
nsCString
&
cachePath
)
;
JSScript
*
WaitForCachedScript
(
JSContext
*
cx
CachedScript
*
script
)
;
void
DecodeScriptOffThread
(
JSContext
*
cx
CachedScript
*
script
)
;
static
void
OffThreadDecodeCallback
(
void
*
token
void
*
context
)
;
void
CancelOffThreadParse
(
void
*
token
)
;
size_t
ShallowHeapSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
return
(
mallocSizeOf
(
this
)
+
mScripts
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
+
mallocSizeOf
(
mSaveThread
.
get
(
)
)
+
mallocSizeOf
(
mProfD
.
get
(
)
)
)
;
}
template
<
typename
T
>
static
size_t
SizeOfLinkedList
(
LinkedList
<
T
>
&
list
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
{
size_t
size
=
0
;
for
(
auto
elem
:
list
)
{
size
+
=
elem
-
>
HeapSizeOfIncludingThis
(
mallocSizeOf
)
;
}
return
size
;
}
AutoCleanLinkedList
<
CachedScript
>
mSavedScripts
;
AutoCleanLinkedList
<
CachedScript
>
mRestoredScripts
;
nsDataHashtable
<
nsCStringHashKey
CachedScript
*
>
mScripts
;
bool
mStartupFinished
=
false
;
bool
mCacheInitialized
=
false
;
bool
mSaveComplete
=
false
;
bool
mDataPrepared
=
false
;
nsCOMPtr
<
nsIFile
>
mProfD
;
nsCOMPtr
<
nsIThread
>
mSaveThread
;
AutoMemMap
mCacheData
;
Monitor
mMonitor
;
Monitor
mSaveMonitor
;
}
;
}
#
endif
