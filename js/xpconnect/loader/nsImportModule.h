#
ifndef
nsImportModule_h
#
define
nsImportModule_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
namespace
mozilla
{
namespace
loader
{
nsresult
ImportModule
(
const
char
*
aURI
const
char
*
aExportName
const
nsIID
&
aIID
void
*
*
aResult
)
;
}
}
class
MOZ_STACK_CLASS
nsImportModule
final
:
public
nsCOMPtr_helper
{
public
:
nsImportModule
(
const
char
*
aURI
const
char
*
aExportName
nsresult
*
aErrorPtr
)
:
mURI
(
aURI
)
mExportName
(
aExportName
)
mErrorPtr
(
aErrorPtr
)
{
}
virtual
nsresult
NS_FASTCALL
operator
(
)
(
const
nsIID
&
aIID
void
*
*
aResult
)
const
override
{
nsresult
rv
=
:
:
mozilla
:
:
loader
:
:
ImportModule
(
mURI
mExportName
aIID
aResult
)
;
if
(
mErrorPtr
)
{
*
mErrorPtr
=
rv
;
}
return
rv
;
}
private
:
const
char
*
mURI
;
const
char
*
mExportName
;
nsresult
*
mErrorPtr
;
}
;
template
<
size_t
N
>
inline
nsImportModule
do_ImportModule
(
const
char
(
&
aURI
)
[
N
]
)
{
return
{
aURI
nullptr
nullptr
}
;
}
template
<
size_t
N
>
inline
nsImportModule
do_ImportModule
(
const
char
(
&
aURI
)
[
N
]
nsresult
*
aRv
)
{
return
{
aURI
nullptr
aRv
}
;
}
template
<
size_t
N
size_t
N2
>
inline
nsImportModule
do_ImportModule
(
const
char
(
&
aURI
)
[
N
]
const
char
(
&
aExportName
)
[
N2
]
)
{
return
{
aURI
aExportName
nullptr
}
;
}
template
<
size_t
N
size_t
N2
>
inline
nsImportModule
do_ImportModule
(
const
char
(
&
aURI
)
[
N
]
const
char
(
&
aExportName
)
[
N2
]
nsresult
*
aRv
)
{
return
{
aURI
aExportName
aRv
}
;
}
#
endif
