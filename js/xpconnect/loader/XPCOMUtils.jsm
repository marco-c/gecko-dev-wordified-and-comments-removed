this
.
EXPORTED_SYMBOLS
=
[
"
XPCOMUtils
"
]
;
this
.
XPCOMUtils
=
{
generateQI
:
function
XPCU_generateQI
(
interfaces
)
{
let
a
=
[
]
;
if
(
interfaces
)
{
for
(
let
i
=
0
;
i
<
interfaces
.
length
;
i
+
+
)
{
let
iface
=
interfaces
[
i
]
;
let
name
=
(
iface
&
&
iface
.
name
)
|
|
String
(
iface
)
;
if
(
name
in
Ci
)
{
a
.
push
(
name
)
;
}
}
}
return
makeQI
(
a
)
;
}
generateCI
:
function
XPCU_generateCI
(
classInfo
)
{
if
(
QueryInterface
in
classInfo
)
throw
Error
(
"
In
generateCI
don
'
t
use
a
component
for
generating
classInfo
"
)
;
let
_interfaces
=
[
]
;
for
(
let
i
=
0
;
i
<
classInfo
.
interfaces
.
length
;
i
+
+
)
{
let
iface
=
classInfo
.
interfaces
[
i
]
;
if
(
Ci
[
iface
]
)
{
_interfaces
.
push
(
Ci
[
iface
]
)
;
}
}
return
{
getInterfaces
:
function
XPCU_getInterfaces
(
countRef
)
{
countRef
.
value
=
_interfaces
.
length
;
return
_interfaces
;
}
getScriptableHelper
:
function
XPCU_getScriptableHelper
(
)
{
return
null
;
}
contractID
:
classInfo
.
contractID
classDescription
:
classInfo
.
classDescription
classID
:
classInfo
.
classID
flags
:
classInfo
.
flags
QueryInterface
:
this
.
generateQI
(
[
Ci
.
nsIClassInfo
]
)
}
;
}
generateNSGetFactory
:
function
XPCU_generateNSGetFactory
(
componentsArray
)
{
let
classes
=
{
}
;
for
(
let
i
=
0
;
i
<
componentsArray
.
length
;
i
+
+
)
{
let
component
=
componentsArray
[
i
]
;
if
(
!
(
component
.
prototype
.
classID
instanceof
Components
.
ID
)
)
throw
Error
(
"
In
generateNSGetFactory
classID
missing
or
incorrect
for
component
"
+
component
)
;
classes
[
component
.
prototype
.
classID
]
=
this
.
_getFactory
(
component
)
;
}
return
function
NSGetFactory
(
cid
)
{
let
cidstring
=
cid
.
toString
(
)
;
if
(
cidstring
in
classes
)
return
classes
[
cidstring
]
;
throw
Cr
.
NS_ERROR_FACTORY_NOT_REGISTERED
;
}
}
defineLazyGetter
:
function
XPCU_defineLazyGetter
(
aObject
aName
aLambda
)
{
Object
.
defineProperty
(
aObject
aName
{
get
:
function
(
)
{
delete
aObject
[
aName
]
;
let
value
=
aLambda
.
apply
(
aObject
)
;
Object
.
defineProperty
(
aObject
aName
{
value
writable
:
true
configurable
:
true
enumerable
:
true
}
)
;
return
value
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
defineLazyScriptGetter
:
function
XPCU_defineLazyScriptGetter
(
aObject
aNames
aResource
)
{
if
(
!
Array
.
isArray
(
aNames
)
)
{
aNames
=
[
aNames
]
;
}
for
(
let
name
of
aNames
)
{
Object
.
defineProperty
(
aObject
name
{
get
:
function
(
)
{
for
(
let
n
of
aNames
)
{
delete
aObject
[
n
]
;
}
Services
.
scriptloader
.
loadSubScript
(
aResource
aObject
)
;
return
aObject
[
name
]
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
}
defineLazyServiceGetter
:
function
XPCU_defineLazyServiceGetter
(
aObject
aName
aContract
aInterfaceName
)
{
this
.
defineLazyGetter
(
aObject
aName
function
XPCU_serviceLambda
(
)
{
return
Cc
[
aContract
]
.
getService
(
Ci
[
aInterfaceName
]
)
;
}
)
;
}
defineLazyServiceGetters
:
function
XPCU_defineLazyServiceGetters
(
aObject
aServices
)
{
for
(
let
[
name
service
]
of
Object
.
entries
(
aServices
)
)
{
this
.
defineLazyServiceGetter
(
aObject
name
service
[
0
]
service
[
1
]
)
;
}
}
defineLazyModuleGetter
:
function
XPCU_defineLazyModuleGetter
(
aObject
aName
aResource
aSymbol
aPreLambda
aPostLambda
aProxy
)
{
if
(
arguments
.
length
=
=
3
)
{
return
ChromeUtils
.
defineModuleGetter
(
aObject
aName
aResource
)
;
}
let
proxy
=
aProxy
|
|
{
}
;
if
(
typeof
(
aPreLambda
)
=
=
=
"
function
"
)
{
aPreLambda
.
apply
(
proxy
)
;
}
this
.
defineLazyGetter
(
aObject
aName
function
XPCU_moduleLambda
(
)
{
var
temp
=
{
}
;
try
{
ChromeUtils
.
import
(
aResource
temp
)
;
if
(
typeof
(
aPostLambda
)
=
=
=
"
function
"
)
{
aPostLambda
.
apply
(
proxy
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
load
module
"
+
aResource
+
"
.
"
)
;
throw
ex
;
}
return
temp
[
aSymbol
|
|
aName
]
;
}
)
;
}
defineLazyModuleGetters
:
function
XPCU_defineLazyModuleGetters
(
aObject
aModules
)
{
for
(
let
[
name
module
]
of
Object
.
entries
(
aModules
)
)
{
ChromeUtils
.
defineModuleGetter
(
aObject
name
module
)
;
}
}
defineLazyPreferenceGetter
:
function
XPCU_defineLazyPreferenceGetter
(
aObject
aName
aPreference
aDefaultValue
=
null
aOnUpdate
=
null
aTransform
=
val
=
>
val
)
{
let
observer
=
{
QueryInterface
:
XPCU_lazyPreferenceObserverQI
value
:
undefined
observe
(
subject
topic
data
)
{
if
(
data
=
=
aPreference
)
{
if
(
aOnUpdate
)
{
let
previous
=
this
.
value
;
this
.
value
=
undefined
;
let
latest
=
lazyGetter
(
)
;
aOnUpdate
(
data
previous
latest
)
;
}
else
{
this
.
value
=
undefined
;
}
}
}
}
let
defineGetter
=
get
=
>
{
Object
.
defineProperty
(
aObject
aName
{
configurable
:
true
enumerable
:
true
get
}
)
;
}
;
function
lazyGetter
(
)
{
if
(
observer
.
value
=
=
=
undefined
)
{
let
prefValue
;
switch
(
Services
.
prefs
.
getPrefType
(
aPreference
)
)
{
case
Ci
.
nsIPrefBranch
.
PREF_STRING
:
prefValue
=
Services
.
prefs
.
getStringPref
(
aPreference
)
;
break
;
case
Ci
.
nsIPrefBranch
.
PREF_INT
:
prefValue
=
Services
.
prefs
.
getIntPref
(
aPreference
)
;
break
;
case
Ci
.
nsIPrefBranch
.
PREF_BOOL
:
prefValue
=
Services
.
prefs
.
getBoolPref
(
aPreference
)
;
break
;
case
Ci
.
nsIPrefBranch
.
PREF_INVALID
:
prefValue
=
aDefaultValue
;
break
;
default
:
throw
new
Error
(
Error
getting
pref
{
aPreference
}
;
its
value
'
s
type
is
+
{
Services
.
prefs
.
getPrefType
(
aPreference
)
}
which
I
don
'
t
+
know
how
to
handle
.
)
;
}
observer
.
value
=
aTransform
(
prefValue
)
;
}
return
observer
.
value
;
}
defineGetter
(
(
)
=
>
{
Services
.
prefs
.
addObserver
(
aPreference
observer
true
)
;
defineGetter
(
lazyGetter
)
;
return
lazyGetter
(
)
;
}
)
;
}
IterSimpleEnumerator
:
function
*
XPCU_IterSimpleEnumerator
(
e
i
)
{
while
(
e
.
hasMoreElements
(
)
)
yield
e
.
getNext
(
)
.
QueryInterface
(
i
)
;
}
IterStringEnumerator
:
function
*
XPCU_IterStringEnumerator
(
e
)
{
while
(
e
.
hasMore
(
)
)
yield
e
.
getNext
(
)
;
}
enumerateCategoryEntries
:
function
*
XPCOMUtils_enumerateCategoryEntries
(
aCategory
)
{
let
category
=
this
.
categoryManager
.
enumerateCategory
(
aCategory
)
;
for
(
let
entry
of
this
.
IterSimpleEnumerator
(
category
Ci
.
nsISupportsCString
)
)
{
yield
[
entry
.
data
this
.
categoryManager
.
getCategoryEntry
(
aCategory
entry
.
data
)
]
;
}
}
_getFactory
:
function
XPCOMUtils__getFactory
(
component
)
{
var
factory
=
component
.
prototype
.
_xpcom_factory
;
if
(
!
factory
)
{
factory
=
{
createInstance
:
function
(
outer
iid
)
{
if
(
outer
)
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
return
(
new
component
(
)
)
.
QueryInterface
(
iid
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIFactory
]
)
}
}
return
factory
;
}
importRelative
:
function
XPCOMUtils__importRelative
(
that
path
scope
)
{
if
(
!
(
"
__URI__
"
in
that
)
)
throw
Error
(
"
importRelative
may
only
be
used
from
a
JSM
and
its
first
argument
"
+
"
must
be
that
JSM
'
s
global
object
(
hint
:
use
this
)
"
)
;
Cu
.
importGlobalProperties
(
[
"
URL
"
]
)
;
ChromeUtils
.
import
(
new
URL
(
path
that
.
__URI__
)
.
href
scope
|
|
that
)
;
}
generateSingletonFactory
:
function
XPCOMUtils_generateSingletonFactory
(
aServiceConstructor
)
{
return
{
_instance
:
null
createInstance
:
function
XPCU_SF_createInstance
(
aOuter
aIID
)
{
if
(
aOuter
!
=
=
null
)
{
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
}
if
(
this
.
_instance
=
=
=
null
)
{
this
.
_instance
=
new
aServiceConstructor
(
)
;
}
return
this
.
_instance
.
QueryInterface
(
aIID
)
;
}
lockFactory
:
function
XPCU_SF_lockFactory
(
aDoLock
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIFactory
]
)
}
;
}
defineConstant
:
function
XPCOMUtils__defineConstant
(
aObj
aName
aValue
)
{
Object
.
defineProperty
(
aObj
aName
{
value
:
aValue
enumerable
:
true
writable
:
false
}
)
;
}
}
;
var
XPCU_lazyPreferenceObserverQI
=
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
XPCOMUtils
"
categoryManager
"
"
mozilla
.
org
/
categorymanager
;
1
"
"
nsICategoryManager
"
)
;
function
makeQI
(
interfaceNames
)
{
return
function
XPCOMUtils_QueryInterface
(
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsISupports
)
)
return
this
;
if
(
iid
.
equals
(
Ci
.
nsIClassInfo
)
&
&
"
classInfo
"
in
this
)
return
this
.
classInfo
;
for
(
let
i
=
0
;
i
<
interfaceNames
.
length
;
i
+
+
)
{
if
(
Ci
[
interfaceNames
[
i
]
]
.
equals
(
iid
)
)
return
this
;
}
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
;
}
