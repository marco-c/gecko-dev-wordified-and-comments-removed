#
include
"
js
/
Transcoding
.
h
"
#
include
"
mozilla
/
scache
/
StartupCache
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
using
namespace
JS
;
using
namespace
mozilla
:
:
scache
;
using
mozilla
:
:
UniquePtr
;
static
nsresult
HandleTranscodeResult
(
JSContext
*
cx
JS
:
:
TranscodeResult
result
)
{
if
(
result
=
=
JS
:
:
TranscodeResult
:
:
Ok
)
{
return
NS_OK
;
}
if
(
result
=
=
JS
:
:
TranscodeResult
:
:
Throw
)
{
JS_ClearPendingException
(
cx
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
MOZ_ASSERT
(
IsTranscodeFailureResult
(
result
)
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
ReadCachedScript
(
StartupCache
*
cache
nsACString
&
uri
JSContext
*
cx
const
JS
:
:
ReadOnlyCompileOptions
&
options
MutableHandleScript
scriptp
)
{
const
char
*
buf
;
uint32_t
len
;
nsresult
rv
=
cache
-
>
GetBuffer
(
PromiseFlatCString
(
uri
)
.
get
(
)
&
buf
&
len
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
void
*
copy
=
malloc
(
len
)
;
if
(
!
copy
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
memcpy
(
copy
buf
len
)
;
JS
:
:
TranscodeBuffer
buffer
;
buffer
.
replaceRawBuffer
(
reinterpret_cast
<
uint8_t
*
>
(
copy
)
len
)
;
JS
:
:
TranscodeResult
code
=
JS
:
:
DecodeScript
(
cx
options
buffer
scriptp
)
;
return
HandleTranscodeResult
(
cx
code
)
;
}
nsresult
WriteCachedScript
(
StartupCache
*
cache
nsACString
&
uri
JSContext
*
cx
HandleScript
script
)
{
MOZ_ASSERT
(
nsJSPrincipals
:
:
get
(
JS_GetScriptPrincipals
(
script
)
)
-
>
IsSystemPrincipal
(
)
)
;
JS
:
:
TranscodeBuffer
buffer
;
JS
:
:
TranscodeResult
code
=
JS
:
:
EncodeScript
(
cx
buffer
script
)
;
if
(
code
!
=
JS
:
:
TranscodeResult
:
:
Ok
)
{
return
HandleTranscodeResult
(
cx
code
)
;
}
size_t
size
=
buffer
.
length
(
)
;
if
(
size
>
UINT32_MAX
)
{
return
NS_ERROR_FAILURE
;
}
UniquePtr
<
char
[
]
>
buf
(
reinterpret_cast
<
char
*
>
(
buffer
.
extractOrCopyRawBuffer
(
)
)
)
;
nsresult
rv
=
cache
-
>
PutBuffer
(
PromiseFlatCString
(
uri
)
.
get
(
)
std
:
:
move
(
buf
)
size
)
;
return
rv
;
}
