const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
add_task
(
function
test_lazy_proxy
(
)
{
let
tmp
=
{
}
;
let
realObject
=
{
"
prop1
"
:
"
value1
"
"
prop2
"
:
"
value2
"
}
;
let
evaluated
=
false
;
let
untrapCalled
=
false
;
let
lazyProxy
=
XPCOMUtils
.
defineLazyProxy
(
tmp
"
myLazyProxy
"
function
init
(
)
{
evaluated
=
true
;
return
realObject
;
}
{
"
prop1
"
:
"
stub
"
}
function
untrapCallback
(
obj
)
{
Assert
.
equal
(
obj
realObject
"
The
underlying
object
can
be
obtained
in
the
untrap
callback
"
)
;
untrapCalled
=
true
;
}
)
;
Assert
.
ok
(
lazyProxy
=
=
=
tmp
.
myLazyProxy
"
Return
value
and
object
defined
are
the
same
"
)
;
Assert
.
ok
(
Cu
.
isProxy
(
lazyProxy
)
"
Returned
value
is
in
fact
a
proxy
"
)
;
Assert
.
ok
(
!
evaluated
"
The
lazy
proxy
hasn
'
t
been
evaluated
yet
"
)
;
Assert
.
ok
(
!
untrapCalled
"
The
untrap
callback
hasn
'
t
been
called
yet
"
)
;
Assert
.
equal
(
lazyProxy
.
prop1
"
stub
"
"
Accessing
a
stubbed
property
returns
the
stubbed
value
"
)
;
Assert
.
ok
(
!
evaluated
"
The
access
to
the
stubbed
property
above
didn
'
t
evaluate
the
lazy
proxy
"
)
;
Assert
.
ok
(
!
untrapCalled
"
The
untrap
callback
hasn
'
t
been
called
yet
"
)
;
Assert
.
equal
(
lazyProxy
.
prop2
"
value2
"
"
Property
access
is
correctly
forwarded
to
the
underlying
object
"
)
;
Assert
.
ok
(
evaluated
"
Accessing
a
non
-
stubbed
property
triggered
the
proxy
evaluation
"
)
;
Assert
.
ok
(
untrapCalled
"
The
untrap
callback
was
called
"
)
;
Assert
.
equal
(
lazyProxy
.
prop1
"
value1
"
"
The
value
of
prop1
is
now
the
real
value
and
not
the
stub
one
"
)
;
}
)
;
add_task
(
function
test_module_version
(
)
{
const
TEST_FILE_URI
=
"
resource
:
/
/
test
/
TestFile
.
jsm
"
;
let
underlyingObject
;
Cu
.
unload
(
TEST_FILE_URI
)
;
let
lazyProxy
=
XPCOMUtils
.
defineLazyProxy
(
null
"
TestFile
"
TEST_FILE_URI
null
function
untrapCallback
(
object
)
{
underlyingObject
=
object
;
}
)
;
Assert
.
ok
(
!
Cu
.
isModuleLoaded
(
TEST_FILE_URI
)
"
The
NetUtil
module
was
not
loaded
by
the
lazy
proxy
definition
"
)
;
lazyProxy
.
foo
=
"
bar
"
;
Assert
.
ok
(
Cu
.
isModuleLoaded
(
TEST_FILE_URI
)
"
The
NetUtil
module
was
loaded
"
)
;
let
{
TestFile
}
=
ChromeUtils
.
import
(
TEST_FILE_URI
{
}
)
;
Assert
.
ok
(
TestFile
=
=
=
underlyingObject
"
The
module
loaded
is
the
same
as
the
one
directly
obtained
by
ChromeUtils
.
import
"
)
;
Assert
.
equal
(
TestFile
.
foo
"
bar
"
"
Proxy
correctly
passed
the
setter
to
the
underlying
object
"
)
;
delete
lazyProxy
.
foo
;
Assert
.
ok
(
!
TestFile
.
hasOwnProperty
(
"
foo
"
)
"
Proxy
correctly
passed
the
delete
operation
to
the
underlying
object
"
)
;
}
)
;
