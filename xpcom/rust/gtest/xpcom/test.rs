#
!
[
allow
(
non_snake_case
)
]
#
[
macro_use
]
extern
crate
xpcom
;
extern
crate
nserror
;
use
nserror
:
:
{
nsresult
NS_OK
}
;
use
std
:
:
ffi
:
:
{
CStr
CString
}
;
use
std
:
:
os
:
:
raw
:
:
c_char
;
use
std
:
:
ptr
;
use
xpcom
:
:
interfaces
;
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
Rust_ObserveFromRust
(
)
-
>
*
const
interfaces
:
:
nsIObserverService
{
let
obssvc
=
xpcom
:
:
services
:
:
get_ObserverService
(
)
.
unwrap
(
)
;
#
[
derive
(
xpcom
)
]
#
[
xpimplements
(
nsIObserver
)
]
#
[
refcnt
=
"
nonatomic
"
]
struct
InitObserver
{
run
:
*
mut
bool
}
impl
Observer
{
unsafe
fn
Observe
(
&
self
_subject
:
*
const
interfaces
:
:
nsISupports
topic
:
*
const
c_char
_data
:
*
const
i16
)
-
>
nsresult
{
*
self
.
run
=
true
;
assert
!
(
CStr
:
:
from_ptr
(
topic
)
.
to_str
(
)
=
=
Ok
(
"
test
-
rust
-
observe
"
)
)
;
NS_OK
}
}
let
topic
=
CString
:
:
new
(
"
test
-
rust
-
observe
"
)
.
unwrap
(
)
;
let
mut
run
=
false
;
let
observer
=
Observer
:
:
allocate
(
InitObserver
{
run
:
&
mut
run
}
)
;
let
rv
=
obssvc
.
AddObserver
(
observer
.
coerce
:
:
<
interfaces
:
:
nsIObserver
>
(
)
topic
.
as_ptr
(
)
false
)
;
assert
!
(
rv
.
succeeded
(
)
)
;
let
rv
=
obssvc
.
NotifyObservers
(
ptr
:
:
null
(
)
topic
.
as_ptr
(
)
ptr
:
:
null
(
)
)
;
assert
!
(
rv
.
succeeded
(
)
)
;
assert
!
(
run
"
The
observer
should
have
been
run
!
"
)
;
let
rv
=
obssvc
.
RemoveObserver
(
observer
.
coerce
:
:
<
interfaces
:
:
nsIObserver
>
(
)
topic
.
as_ptr
(
)
)
;
assert
!
(
rv
.
succeeded
(
)
)
;
assert
!
(
observer
.
coerce
:
:
<
interfaces
:
:
nsISupports
>
(
)
as
*
const
_
=
=
&
*
observer
.
query_interface
:
:
<
interfaces
:
:
nsISupports
>
(
)
.
unwrap
(
)
as
*
const
_
)
;
&
*
obssvc
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
Rust_ImplementRunnableInRust
(
it_worked
:
*
mut
bool
runnable
:
*
mut
*
const
interfaces
:
:
nsIRunnable
)
{
#
[
derive
(
xpcom
)
]
#
[
xpimplements
(
nsIRunnable
)
]
#
[
refcnt
=
"
atomic
"
]
struct
InitRunnableFn
<
F
:
Fn
(
)
+
'
static
>
{
run
:
F
}
impl
<
F
:
Fn
(
)
+
'
static
>
RunnableFn
<
F
>
{
unsafe
fn
Run
(
&
self
)
-
>
nsresult
{
(
self
.
run
)
(
)
;
NS_OK
}
}
let
my_runnable
=
RunnableFn
:
:
allocate
(
InitRunnableFn
{
run
:
move
|
|
{
*
it_worked
=
true
;
}
}
)
;
my_runnable
.
query_interface
:
:
<
interfaces
:
:
nsIRunnable
>
(
)
.
unwrap
(
)
.
forget
(
&
mut
*
runnable
)
;
}
