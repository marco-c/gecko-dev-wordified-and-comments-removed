#
include
"
gtest
/
gtest
.
h
"
#
include
"
gtest
/
MozGTestBench
.
h
"
#
include
"
mozilla
/
AllocPolicy
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
<
unordered_set
>
using
namespace
mozilla
;
uintptr_t
MyRand
(
)
{
static
uintptr_t
s
=
0
;
s
=
s
*
1103515245
+
12345
;
return
s
;
}
struct
Params
{
const
char
*
mConfigName
;
size_t
mNumInserts
;
size_t
mNumSuccessfulLookups
;
size_t
mNumFailingLookups
;
size_t
mNumIterations
;
bool
mRemoveInserts
;
}
;
void
Bench_Cpp_unordered_set
(
const
Params
*
aParams
void
*
*
aVals
size_t
aLen
)
{
std
:
:
unordered_set
<
void
*
>
hs
;
for
(
size_t
j
=
0
;
j
<
aParams
-
>
mNumInserts
;
j
+
+
)
{
hs
.
insert
(
aVals
[
j
]
)
;
}
for
(
size_t
i
=
0
;
i
<
aParams
-
>
mNumSuccessfulLookups
;
i
+
+
)
{
for
(
size_t
j
=
0
;
j
<
aParams
-
>
mNumInserts
;
j
+
+
)
{
MOZ_RELEASE_ASSERT
(
hs
.
find
(
aVals
[
j
]
)
!
=
hs
.
end
(
)
)
;
}
}
for
(
size_t
i
=
0
;
i
<
aParams
-
>
mNumFailingLookups
;
i
+
+
)
{
for
(
size_t
j
=
aParams
-
>
mNumInserts
;
j
<
aParams
-
>
mNumInserts
*
2
;
j
+
+
)
{
MOZ_RELEASE_ASSERT
(
hs
.
find
(
aVals
[
j
]
)
=
=
hs
.
end
(
)
)
;
}
}
for
(
size_t
i
=
0
;
i
<
aParams
-
>
mNumIterations
;
i
+
+
)
{
size_t
n
=
0
;
for
(
const
auto
&
elem
:
hs
)
{
(
void
)
elem
;
n
+
+
;
}
MOZ_RELEASE_ASSERT
(
aParams
-
>
mNumInserts
=
=
n
)
;
MOZ_RELEASE_ASSERT
(
hs
.
size
(
)
=
=
n
)
;
}
if
(
aParams
-
>
mRemoveInserts
)
{
for
(
size_t
j
=
0
;
j
<
aParams
-
>
mNumInserts
;
j
+
+
)
{
MOZ_RELEASE_ASSERT
(
hs
.
erase
(
aVals
[
j
]
)
=
=
1
)
;
}
MOZ_RELEASE_ASSERT
(
hs
.
size
(
)
=
=
0
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
hs
.
size
(
)
=
=
aParams
-
>
mNumInserts
)
;
}
}
void
Bench_Cpp_PLDHashTable
(
const
Params
*
aParams
void
*
*
aVals
size_t
aLen
)
{
PLDHashTable
hs
(
PLDHashTable
:
:
StubOps
(
)
sizeof
(
PLDHashEntryStub
)
)
;
for
(
size_t
j
=
0
;
j
<
aParams
-
>
mNumInserts
;
j
+
+
)
{
auto
entry
=
static_cast
<
PLDHashEntryStub
*
>
(
hs
.
Add
(
aVals
[
j
]
)
)
;
MOZ_RELEASE_ASSERT
(
!
entry
-
>
key
)
;
entry
-
>
key
=
aVals
[
j
]
;
}
for
(
size_t
i
=
0
;
i
<
aParams
-
>
mNumSuccessfulLookups
;
i
+
+
)
{
for
(
size_t
j
=
0
;
j
<
aParams
-
>
mNumInserts
;
j
+
+
)
{
MOZ_RELEASE_ASSERT
(
hs
.
Search
(
aVals
[
j
]
)
)
;
}
}
for
(
size_t
i
=
0
;
i
<
aParams
-
>
mNumFailingLookups
;
i
+
+
)
{
for
(
size_t
j
=
aParams
-
>
mNumInserts
;
j
<
aParams
-
>
mNumInserts
*
2
;
j
+
+
)
{
MOZ_RELEASE_ASSERT
(
!
hs
.
Search
(
aVals
[
j
]
)
)
;
}
}
for
(
size_t
i
=
0
;
i
<
aParams
-
>
mNumIterations
;
i
+
+
)
{
size_t
n
=
0
;
for
(
auto
iter
=
hs
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
+
;
}
MOZ_RELEASE_ASSERT
(
aParams
-
>
mNumInserts
=
=
n
)
;
MOZ_RELEASE_ASSERT
(
hs
.
EntryCount
(
)
=
=
n
)
;
}
if
(
aParams
-
>
mRemoveInserts
)
{
for
(
size_t
j
=
0
;
j
<
aParams
-
>
mNumInserts
;
j
+
+
)
{
hs
.
Remove
(
aVals
[
j
]
)
;
}
MOZ_RELEASE_ASSERT
(
hs
.
EntryCount
(
)
=
=
0
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
hs
.
EntryCount
(
)
=
=
aParams
-
>
mNumInserts
)
;
}
}
void
Bench_Cpp_MozHashSet
(
const
Params
*
aParams
void
*
*
aVals
size_t
aLen
)
{
mozilla
:
:
HashSet
<
void
*
mozilla
:
:
DefaultHasher
<
void
*
>
MallocAllocPolicy
>
hs
;
MOZ_RELEASE_ASSERT
(
hs
.
init
(
)
)
;
for
(
size_t
j
=
0
;
j
<
aParams
-
>
mNumInserts
;
j
+
+
)
{
auto
p
=
hs
.
lookupForAdd
(
aVals
[
j
]
)
;
MOZ_RELEASE_ASSERT
(
!
p
)
;
MOZ_RELEASE_ASSERT
(
hs
.
add
(
p
aVals
[
j
]
)
)
;
}
for
(
size_t
i
=
0
;
i
<
aParams
-
>
mNumSuccessfulLookups
;
i
+
+
)
{
for
(
size_t
j
=
0
;
j
<
aParams
-
>
mNumInserts
;
j
+
+
)
{
MOZ_RELEASE_ASSERT
(
hs
.
lookup
(
aVals
[
j
]
)
)
;
}
}
for
(
size_t
i
=
0
;
i
<
aParams
-
>
mNumFailingLookups
;
i
+
+
)
{
for
(
size_t
j
=
aParams
-
>
mNumInserts
;
j
<
aParams
-
>
mNumInserts
*
2
;
j
+
+
)
{
MOZ_RELEASE_ASSERT
(
!
hs
.
lookup
(
aVals
[
j
]
)
)
;
}
}
for
(
size_t
i
=
0
;
i
<
aParams
-
>
mNumIterations
;
i
+
+
)
{
size_t
n
=
0
;
for
(
auto
iter
=
hs
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
n
+
+
;
}
MOZ_RELEASE_ASSERT
(
aParams
-
>
mNumInserts
=
=
n
)
;
MOZ_RELEASE_ASSERT
(
hs
.
count
(
)
=
=
n
)
;
}
if
(
aParams
-
>
mRemoveInserts
)
{
for
(
size_t
j
=
0
;
j
<
aParams
-
>
mNumInserts
;
j
+
+
)
{
hs
.
remove
(
aVals
[
j
]
)
;
}
MOZ_RELEASE_ASSERT
(
hs
.
count
(
)
=
=
0
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
hs
.
count
(
)
=
=
aParams
-
>
mNumInserts
)
;
}
}
extern
"
C
"
{
void
Bench_Rust_HashSet
(
const
Params
*
params
void
*
*
aVals
size_t
aLen
)
;
void
Bench_Rust_FnvHashSet
(
const
Params
*
params
void
*
*
aVals
size_t
aLen
)
;
void
Bench_Rust_FxHashSet
(
const
Params
*
params
void
*
*
aVals
size_t
aLen
)
;
}
static
const
size_t
VALS_LEN
=
131072
;
const
Params
gParamsList
[
]
=
{
{
"
succ_lookups
"
1024
5000
0
0
false
}
{
"
fail_lookups
"
1024
0
5000
0
false
}
{
"
insert_remove
"
VALS_LEN
0
0
0
true
}
{
"
iterate
"
1024
0
0
5000
false
}
}
;
class
BenchCollections
:
public
:
:
testing
:
:
Test
{
protected
:
void
SetUp
(
)
override
{
StaticMutexAutoLock
lock
(
sValsMutex
)
;
if
(
!
sVals
)
{
sVals
=
(
void
*
*
)
malloc
(
VALS_LEN
*
sizeof
(
void
*
)
)
;
for
(
size_t
i
=
0
;
i
<
VALS_LEN
;
i
+
+
)
{
sVals
[
i
]
=
reinterpret_cast
<
void
*
>
(
uintptr_t
(
MyRand
(
)
)
)
;
}
}
printf
(
"
\
n
"
)
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
gParamsList
)
;
i
+
+
)
{
const
Params
*
params
=
&
gParamsList
[
i
]
;
printf
(
"
%
14s
"
params
-
>
mConfigName
)
;
}
printf
(
"
%
14s
\
n
"
"
total
"
)
;
}
public
:
void
BenchImpl
(
void
(
*
aBench
)
(
const
Params
*
void
*
*
size_t
)
)
{
StaticMutexAutoLock
lock
(
sValsMutex
)
;
double
total
=
0
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
gParamsList
)
;
i
+
+
)
{
const
Params
*
params
=
&
gParamsList
[
i
]
;
TimeStamp
t1
=
TimeStamp
:
:
Now
(
)
;
aBench
(
params
sVals
VALS_LEN
)
;
TimeStamp
t2
=
TimeStamp
:
:
Now
(
)
;
double
t
=
(
t2
-
t1
)
.
ToMilliseconds
(
)
;
printf
(
"
%
11
.
1f
ms
"
t
)
;
total
+
=
t
;
}
printf
(
"
%
11
.
1f
ms
\
n
"
total
)
;
}
private
:
static
void
*
*
sVals
;
static
StaticMutex
sValsMutex
;
}
;
void
*
*
BenchCollections
:
:
sVals
;
StaticMutex
BenchCollections
:
:
sValsMutex
;
MOZ_GTEST_BENCH_F
(
BenchCollections
unordered_set
[
this
]
{
BenchImpl
(
Bench_Cpp_unordered_set
)
;
}
)
;
MOZ_GTEST_BENCH_F
(
BenchCollections
PLDHash
[
this
]
{
BenchImpl
(
Bench_Cpp_PLDHashTable
)
;
}
)
;
MOZ_GTEST_BENCH_F
(
BenchCollections
MozHash
[
this
]
{
BenchImpl
(
Bench_Cpp_MozHashSet
)
;
}
)
;
MOZ_GTEST_BENCH_F
(
BenchCollections
RustHash
[
this
]
{
BenchImpl
(
Bench_Rust_HashSet
)
;
}
)
;
MOZ_GTEST_BENCH_F
(
BenchCollections
RustFnvHash
[
this
]
{
BenchImpl
(
Bench_Rust_FnvHashSet
)
;
}
)
;
MOZ_GTEST_BENCH_F
(
BenchCollections
RustFxHash
[
this
]
{
BenchImpl
(
Bench_Rust_FxHashSet
)
;
}
)
;
