#
!
[
recursion_limit
=
"
256
"
]
use
lazy_static
:
:
lazy_static
;
use
proc_macro
:
:
TokenStream
;
use
proc_macro2
:
:
{
Span
TokenStream
as
TokenStream2
}
;
use
quote
:
:
{
quote
ToTokens
}
;
use
std
:
:
collections
:
:
{
HashMap
HashSet
}
;
use
syn
:
:
punctuated
:
:
Punctuated
;
use
syn
:
:
{
parse_macro_input
parse_quote
Attribute
Data
DataStruct
DeriveInput
Field
Fields
Ident
Lit
Meta
NestedMeta
Token
Type
}
;
macro_rules
!
bail
{
(
(
t
:
expr
)
s
:
expr
)
=
>
{
return
Err
(
syn
:
:
Error
:
:
new_spanned
(
&
t
&
s
[
.
.
]
)
)
;
}
;
(
(
t
:
expr
)
f
:
expr
(
e
:
expr
)
*
)
=
>
{
return
Err
(
syn
:
:
Error
:
:
new_spanned
(
&
t
&
format
!
(
f
(
e
)
*
)
[
.
.
]
)
)
;
}
;
(
s
:
expr
)
=
>
{
return
Err
(
syn
:
:
Error
:
:
new
(
Span
:
:
call_site
(
)
&
s
[
.
.
]
)
)
;
}
;
(
f
:
expr
(
e
:
expr
)
*
)
=
>
{
return
Err
(
syn
:
:
Error
:
:
new
(
Span
:
:
call_site
(
)
&
format
!
(
f
(
e
)
*
)
[
.
.
]
)
)
;
}
;
}
#
[
derive
(
Debug
)
]
struct
Param
{
name
:
&
'
static
str
ty
:
&
'
static
str
}
#
[
derive
(
Debug
)
]
struct
Method
{
name
:
&
'
static
str
params
:
&
'
static
[
Param
]
ret
:
&
'
static
str
}
#
[
derive
(
Debug
)
]
struct
Interface
{
name
:
&
'
static
str
base
:
Option
<
&
'
static
str
>
methods
:
Result
<
&
'
static
[
Method
]
&
'
static
str
>
}
impl
Interface
{
fn
base
(
&
self
)
-
>
Option
<
&
'
static
Interface
>
{
Some
(
IFACES
[
self
.
base
?
]
)
}
fn
methods
(
&
self
)
-
>
Result
<
&
'
static
[
Method
]
syn
:
:
Error
>
{
match
self
.
methods
{
Ok
(
methods
)
=
>
Ok
(
methods
)
Err
(
reason
)
=
>
Err
(
syn
:
:
Error
:
:
new
(
Span
:
:
call_site
(
)
&
format
!
(
"
Interface
{
}
cannot
be
implemented
in
rust
\
because
{
}
is
not
supported
yet
"
self
.
name
reason
)
)
)
}
}
}
lazy_static
!
{
/
/
/
This
item
contains
the
information
generated
by
the
procedural
macro
in
/
/
/
the
form
of
a
HashMap
from
interface
names
to
their
descriptions
.
static
ref
IFACES
:
HashMap
<
&
'
static
str
&
'
static
Interface
>
=
{
let
lists
:
&
[
&
[
Interface
]
]
=
include
!
(
concat
!
(
env
!
(
"
MOZ_TOPOBJDIR
"
)
"
/
dist
/
xpcrs
/
bt
/
all
.
rs
"
)
)
;
let
mut
hm
=
HashMap
:
:
new
(
)
;
for
&
list
in
lists
{
for
iface
in
list
{
hm
.
insert
(
iface
.
name
iface
)
;
}
}
hm
}
;
}
#
[
derive
(
Debug
Eq
PartialEq
Copy
Clone
)
]
enum
RefcntKind
{
Atomic
NonAtomic
}
impl
ToTokens
for
RefcntKind
{
fn
to_tokens
(
&
self
tokens
:
&
mut
TokenStream2
)
{
match
*
self
{
RefcntKind
:
:
NonAtomic
=
>
quote
!
(
xpcom
:
:
Refcnt
)
.
to_tokens
(
tokens
)
RefcntKind
:
:
Atomic
=
>
quote
!
(
xpcom
:
:
AtomicRefcnt
)
.
to_tokens
(
tokens
)
}
}
}
fn
get_refcnt_kind
(
attrs
:
&
[
Attribute
]
)
-
>
Result
<
RefcntKind
syn
:
:
Error
>
{
for
attr
in
attrs
{
if
let
Meta
:
:
NameValue
(
syn
:
:
MetaNameValue
{
ref
path
ref
lit
.
.
}
)
=
attr
.
parse_meta
(
)
?
{
if
!
path
.
is_ident
(
"
refcnt
"
)
{
continue
;
}
let
value
=
if
let
Lit
:
:
Str
(
ref
s
)
=
lit
{
s
.
value
(
)
}
else
{
bail
!
(
(
attr
)
"
Unexpected
non
-
string
value
in
#
[
refcnt
]
"
)
;
}
;
return
if
value
=
=
"
nonatomic
"
{
Ok
(
RefcntKind
:
:
NonAtomic
)
}
else
if
value
=
=
"
atomic
"
{
Ok
(
RefcntKind
:
:
Atomic
)
}
else
{
bail
!
(
(
attr
)
"
Unexpected
value
in
#
[
refcnt
]
.
\
Expected
nonatomic
or
atomic
"
)
;
}
;
}
}
bail
!
(
"
Expected
#
[
refcnt
]
attribute
"
)
}
fn
get_bases
(
attrs
:
&
[
Attribute
]
)
-
>
Result
<
Vec
<
&
'
static
Interface
>
syn
:
:
Error
>
{
let
mut
inherits
=
Vec
:
:
new
(
)
;
for
attr
in
attrs
{
if
let
Meta
:
:
List
(
syn
:
:
MetaList
{
ref
path
ref
nested
.
.
}
)
=
attr
.
parse_meta
(
)
?
{
if
!
path
.
is_ident
(
"
xpimplements
"
)
{
continue
;
}
for
item
in
nested
.
iter
(
)
{
let
iface
=
match
*
item
{
NestedMeta
:
:
Meta
(
syn
:
:
Meta
:
:
Path
(
ref
iface
)
)
=
>
iface
_
=
>
bail
!
(
(
attr
)
"
Unexpected
non
-
identifier
in
#
[
xpimplements
(
.
.
)
]
"
)
}
;
let
ident
=
match
iface
.
get_ident
(
)
{
Some
(
ref
iface
)
=
>
iface
.
to_string
(
)
_
=
>
bail
!
(
(
attr
)
"
Too
many
components
in
xpimplements
path
"
)
}
;
if
let
Some
(
&
iface
)
=
IFACES
.
get
(
ident
.
as_str
(
)
)
{
inherits
.
push
(
iface
)
;
}
else
{
bail
!
(
(
attr
)
"
Unexpected
invalid
base
interface
{
}
in
#
[
xpimplements
(
.
.
)
]
"
ident
)
;
}
}
}
}
Ok
(
inherits
)
}
fn
get_fields
(
di
:
&
DeriveInput
)
-
>
Result
<
&
Punctuated
<
Field
Token
!
[
]
>
syn
:
:
Error
>
{
match
di
.
data
{
Data
:
:
Struct
(
DataStruct
{
fields
:
Fields
:
:
Named
(
ref
named
)
.
.
}
)
=
>
Ok
(
&
named
.
named
)
_
=
>
{
bail
!
(
(
di
)
"
The
initializer
struct
must
be
a
standard
named
\
value
struct
definition
"
)
}
}
}
fn
gen_real_struct
(
init
:
&
DeriveInput
bases
:
&
[
&
Interface
]
refcnt_ty
:
RefcntKind
)
-
>
Result
<
DeriveInput
syn
:
:
Error
>
{
if
!
init
.
ident
.
to_string
(
)
.
starts_with
(
"
Init
"
)
{
bail
!
(
(
init
.
ident
)
"
The
target
struct
'
s
name
must
begin
with
Init
"
)
;
}
let
name
:
Ident
=
Ident
:
:
new
(
&
init
.
ident
.
to_string
(
)
[
4
.
.
]
Span
:
:
call_site
(
)
)
;
let
vis
=
&
init
.
vis
;
let
bases
=
bases
.
iter
(
)
.
map
(
|
base
|
{
let
ident
=
Ident
:
:
new
(
&
format
!
(
"
__base_
{
}
"
base
.
name
)
Span
:
:
call_site
(
)
)
;
let
vtable
=
Ident
:
:
new
(
&
format
!
(
"
{
}
VTable
"
base
.
name
)
Span
:
:
call_site
(
)
)
;
quote
!
(
#
ident
:
*
const
xpcom
:
:
interfaces
:
:
#
vtable
)
}
)
;
let
fields
=
get_fields
(
init
)
?
;
Ok
(
parse_quote
!
{
#
[
repr
(
C
)
]
#
vis
struct
#
name
{
#
(
#
bases
)
*
__refcnt
:
#
refcnt_ty
#
fields
}
}
)
}
fn
gen_vtable_methods
(
iface
:
&
Interface
)
-
>
Result
<
TokenStream2
syn
:
:
Error
>
{
let
base_ty
=
Ident
:
:
new
(
iface
.
name
Span
:
:
call_site
(
)
)
;
let
base_methods
=
if
let
Some
(
base
)
=
iface
.
base
(
)
{
gen_vtable_methods
(
base
)
?
}
else
{
quote
!
{
}
}
;
let
mut
method_defs
=
Vec
:
:
new
(
)
;
for
method
in
iface
.
methods
(
)
?
{
let
name
=
Ident
:
:
new
(
method
.
name
Span
:
:
call_site
(
)
)
;
let
ret
=
syn
:
:
parse_str
:
:
<
Type
>
(
method
.
ret
)
?
;
let
mut
params
=
Vec
:
:
new
(
)
;
let
mut
args
=
Vec
:
:
new
(
)
;
for
param
in
method
.
params
{
let
name
=
Ident
:
:
new
(
param
.
name
Span
:
:
call_site
(
)
)
;
let
ty
=
syn
:
:
parse_str
:
:
<
Type
>
(
param
.
ty
)
?
;
params
.
push
(
quote
!
{
#
name
:
#
ty
}
)
;
args
.
push
(
quote
!
{
#
name
}
)
;
}
method_defs
.
push
(
quote
!
{
unsafe
extern
"
system
"
fn
#
name
(
this
:
*
const
#
base_ty
#
(
#
params
)
*
)
-
>
#
ret
{
let
lt
=
(
)
;
recover_self
(
this
&
lt
)
.
#
name
(
#
(
#
args
)
*
)
}
}
)
;
}
Ok
(
quote
!
{
#
base_methods
#
(
#
method_defs
)
*
}
)
}
fn
gen_inner_vtable
(
iface
:
&
Interface
)
-
>
Result
<
TokenStream2
syn
:
:
Error
>
{
let
vtable_ty
=
Ident
:
:
new
(
&
format
!
(
"
{
}
VTable
"
iface
.
name
)
Span
:
:
call_site
(
)
)
;
let
base_vtable
=
if
let
Some
(
base
)
=
iface
.
base
(
)
{
let
vt
=
gen_inner_vtable
(
base
)
?
;
quote
!
{
__base
:
#
vt
}
}
else
{
quote
!
{
}
}
;
let
vtable_init
=
iface
.
methods
(
)
?
.
into_iter
(
)
.
map
(
|
method
|
{
let
name
=
Ident
:
:
new
(
method
.
name
Span
:
:
call_site
(
)
)
;
quote
!
{
#
name
:
#
name
}
}
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
;
Ok
(
quote
!
(
#
vtable_ty
{
#
base_vtable
#
(
#
vtable_init
)
*
}
)
)
}
fn
gen_root_vtable
(
name
:
&
Ident
base
:
&
Interface
)
-
>
Result
<
TokenStream2
syn
:
:
Error
>
{
let
field
=
Ident
:
:
new
(
&
format
!
(
"
__base_
{
}
"
base
.
name
)
Span
:
:
call_site
(
)
)
;
let
vtable_ty
=
Ident
:
:
new
(
&
format
!
(
"
{
}
VTable
"
base
.
name
)
Span
:
:
call_site
(
)
)
;
let
methods
=
gen_vtable_methods
(
base
)
?
;
let
value
=
gen_inner_vtable
(
base
)
?
;
Ok
(
quote
!
{
#
field
:
{
/
/
NOTE
:
The
&
'
a
(
)
dummy
lifetime
parameter
is
useful
as
it
easily
/
/
allows
the
caller
to
limit
the
lifetime
of
the
returned
parameter
/
/
to
a
local
lifetime
preventing
the
calling
of
methods
with
/
/
receivers
like
&
'
static
self
.
#
[
inline
]
unsafe
fn
recover_self
<
'
a
T
>
(
this
:
*
const
T
_
:
&
'
a
(
)
)
-
>
&
'
a
#
name
{
/
/
Calculate
the
offset
of
the
field
in
our
struct
.
/
/
XXX
:
Should
we
use
the
fact
that
our
type
is
#
[
repr
(
C
)
]
to
avoid
/
/
this
?
let
base
=
0x1000
;
let
member
=
&
(
*
(
0x1000
as
*
const
#
name
)
)
.
#
field
as
*
const
_
as
usize
;
let
off
=
member
-
base
;
/
/
Offset
the
pointer
by
that
offset
.
&
*
(
(
this
as
usize
-
off
)
as
*
const
#
name
)
}
/
/
The
method
implementations
which
will
be
used
to
build
the
vtable
.
#
methods
/
/
The
actual
VTable
definition
.
static
VTABLE
:
#
vtable_ty
=
#
value
;
&
VTABLE
}
}
)
}
fn
gen_casts
(
seen
:
&
mut
HashSet
<
&
'
static
str
>
iface
:
&
Interface
name
:
&
Ident
coerce_name
:
&
Ident
vtable_field
:
&
Ident
)
-
>
Result
<
(
TokenStream2
TokenStream2
)
syn
:
:
Error
>
{
if
!
seen
.
insert
(
iface
.
name
)
{
return
Ok
(
(
quote
!
{
}
quote
!
{
}
)
)
;
}
let
(
base_qi
base_coerce
)
=
if
let
Some
(
base
)
=
iface
.
base
(
)
{
gen_casts
(
seen
base
name
coerce_name
vtable_field
)
?
}
else
{
(
quote
!
{
}
quote
!
{
}
)
}
;
let
base_name
=
Ident
:
:
new
(
iface
.
name
Span
:
:
call_site
(
)
)
;
let
qi
=
quote
!
{
#
base_qi
if
*
uuid
=
=
#
base_name
:
:
IID
{
/
/
Implement
QueryInterface
in
terms
of
coersions
.
self
.
addref
(
)
;
*
result
=
self
.
coerce
:
:
<
#
base_name
>
(
)
as
*
const
#
base_name
as
*
const
:
:
xpcom
:
:
reexports
:
:
libc
:
:
c_void
as
*
mut
:
:
xpcom
:
:
reexports
:
:
libc
:
:
c_void
;
return
:
:
xpcom
:
:
reexports
:
:
NS_OK
;
}
}
;
let
coerce
=
quote
!
{
#
base_coerce
impl
#
coerce_name
for
:
:
xpcom
:
:
interfaces
:
:
#
base_name
{
fn
coerce_from
(
v
:
&
#
name
)
-
>
&
Self
{
unsafe
{
/
/
Get
the
address
of
the
VTable
field
.
This
should
be
a
/
/
pointer
to
a
pointer
to
a
vtable
which
we
can
then
cast
/
/
into
a
pointer
to
our
interface
.
&
*
(
&
(
v
.
#
vtable_field
)
as
*
const
*
const
_
as
*
const
:
:
xpcom
:
:
interfaces
:
:
#
base_name
)
}
}
}
}
;
Ok
(
(
qi
coerce
)
)
}
fn
xpcom
(
init
:
DeriveInput
)
-
>
Result
<
TokenStream2
syn
:
:
Error
>
{
if
!
init
.
generics
.
params
.
is_empty
(
)
|
|
!
init
.
generics
.
where_clause
.
is_none
(
)
{
bail
!
(
"
Cannot
#
[
derive
(
xpcom
)
]
on
a
generic
type
due
to
\
rust
limitations
.
It
is
not
possible
to
instantiate
\
a
static
with
a
generic
type
parameter
meaning
that
\
generic
types
cannot
have
their
VTables
instantiated
\
correctly
.
"
)
}
let
bases
=
get_bases
(
&
init
.
attrs
)
?
;
if
bases
.
is_empty
(
)
{
bail
!
(
"
Types
with
#
[
derive
(
xpcom
)
]
must
implement
at
least
one
\
interface
.
Interfaces
can
be
implemented
by
adding
the
\
#
[
xpimplements
(
nsIFoo
nsIBar
)
]
attribute
to
the
struct
\
declaration
.
"
)
;
}
let
mut
method_names
=
HashMap
:
:
new
(
)
;
for
base
in
&
bases
{
for
method
in
base
.
methods
(
)
?
{
if
let
Some
(
existing
)
=
method_names
.
insert
(
method
.
name
base
.
name
)
{
bail
!
(
"
The
method
{
0
}
is
declared
on
both
{
1
}
and
{
2
}
but
a
Rust
type
cannot
implement
two
methods
with
the
\
same
name
.
You
can
add
the
[
binaryname
(
Renamed
{
0
}
)
]
\
XPIDL
attribute
to
one
of
the
declarations
to
rename
it
.
"
method
.
name
existing
base
.
name
)
;
}
}
}
let
refcnt_ty
=
get_refcnt_kind
(
&
init
.
attrs
)
?
;
let
real
=
gen_real_struct
(
&
init
&
bases
refcnt_ty
)
?
;
let
name_init
=
&
init
.
ident
;
let
name
=
&
real
.
ident
;
let
coerce_name
=
Ident
:
:
new
(
&
format
!
(
"
{
}
Coerce
"
name
.
to_string
(
)
)
Span
:
:
call_site
(
)
)
;
let
mut
vtables
=
Vec
:
:
new
(
)
;
for
base
in
&
bases
{
vtables
.
push
(
gen_root_vtable
(
name
base
)
?
)
;
}
let
inits
=
get_fields
(
&
init
)
?
.
iter
(
)
.
map
(
|
field
|
{
let
id
=
&
field
.
ident
;
quote
!
{
#
id
:
__init
.
#
id
}
}
)
;
let
vis
=
&
real
.
vis
;
let
mut
seen
=
HashSet
:
:
new
(
)
;
let
mut
qi_impl
=
Vec
:
:
new
(
)
;
let
mut
coerce_impl
=
Vec
:
:
new
(
)
;
for
base
in
&
bases
{
let
(
qi
coerce
)
=
gen_casts
(
&
mut
seen
base
name
&
coerce_name
&
Ident
:
:
new
(
&
format
!
(
"
__base_
{
}
"
base
.
name
)
Span
:
:
call_site
(
)
)
)
?
;
qi_impl
.
push
(
qi
)
;
coerce_impl
.
push
(
coerce
)
;
}
Ok
(
quote
!
{
#
real
impl
#
name
{
/
/
/
This
method
is
used
for
fn
allocate
(
__init
:
#
name_init
)
-
>
:
:
xpcom
:
:
RefPtr
<
Self
>
{
#
[
allow
(
unused_imports
)
]
use
:
:
xpcom
:
:
*
;
#
[
allow
(
unused_imports
)
]
use
:
:
xpcom
:
:
interfaces
:
:
*
;
#
[
allow
(
unused_imports
)
]
use
:
:
xpcom
:
:
reexports
:
:
{
libc
nsACString
nsAString
nsCString
nsString
nsresult
}
;
unsafe
{
/
/
NOTE
:
This
is
split
into
multiple
lines
to
make
the
/
/
output
more
readable
.
let
value
=
#
name
{
#
(
#
vtables
)
*
__refcnt
:
#
refcnt_ty
:
:
new
(
)
#
(
#
inits
)
*
}
;
let
boxed
=
:
:
std
:
:
boxed
:
:
Box
:
:
new
(
value
)
;
let
raw
=
:
:
std
:
:
boxed
:
:
Box
:
:
into_raw
(
boxed
)
;
:
:
xpcom
:
:
RefPtr
:
:
from_raw
(
raw
)
.
unwrap
(
)
}
}
/
/
/
Automatically
generated
implementation
of
AddRef
for
nsISupports
.
#
vis
unsafe
fn
AddRef
(
&
self
)
-
>
:
:
xpcom
:
:
interfaces
:
:
nsrefcnt
{
self
.
__refcnt
.
inc
(
)
}
/
/
/
Automatically
generated
implementation
of
Release
for
nsISupports
.
#
vis
unsafe
fn
Release
(
&
self
)
-
>
:
:
xpcom
:
:
interfaces
:
:
nsrefcnt
{
let
new
=
self
.
__refcnt
.
dec
(
)
;
if
new
=
=
0
{
/
/
XXX
:
dealloc
:
:
std
:
:
boxed
:
:
Box
:
:
from_raw
(
self
as
*
const
Self
as
*
mut
Self
)
;
}
new
}
/
/
/
Automatically
generated
implementation
of
QueryInterface
for
/
/
/
nsISupports
.
#
vis
unsafe
fn
QueryInterface
(
&
self
uuid
:
*
const
:
:
xpcom
:
:
nsIID
result
:
*
mut
*
mut
:
:
xpcom
:
:
reexports
:
:
libc
:
:
c_void
)
-
>
:
:
xpcom
:
:
reexports
:
:
nsresult
{
#
[
allow
(
unused_imports
)
]
use
:
:
xpcom
:
:
*
;
#
[
allow
(
unused_imports
)
]
use
:
:
xpcom
:
:
interfaces
:
:
*
;
#
(
#
qi_impl
)
*
:
:
xpcom
:
:
reexports
:
:
NS_ERROR_NO_INTERFACE
}
/
/
/
Perform
a
QueryInterface
call
on
this
object
attempting
to
/
/
/
dynamically
cast
it
to
the
requested
interface
type
.
Returns
/
/
/
Some
(
RefPtr
<
T
>
)
if
the
cast
succeeded
and
None
otherwise
.
#
vis
fn
query_interface
<
T
:
:
:
xpcom
:
:
XpCom
>
(
&
self
)
-
>
:
:
std
:
:
option
:
:
Option
<
:
:
xpcom
:
:
RefPtr
<
T
>
>
{
let
mut
ga
=
:
:
xpcom
:
:
GetterAddrefs
:
:
<
T
>
:
:
new
(
)
;
unsafe
{
if
self
.
QueryInterface
(
&
T
:
:
IID
ga
.
void_ptr
(
)
)
.
succeeded
(
)
{
ga
.
refptr
(
)
}
else
{
None
}
}
}
/
/
/
Coerce
this
type
safely
to
any
of
the
interfaces
which
it
/
/
/
implements
without
AddRef
ing
it
.
#
vis
fn
coerce
<
T
:
#
coerce_name
>
(
&
self
)
-
>
&
T
{
T
:
:
coerce_from
(
self
)
}
}
/
/
/
This
trait
is
implemented
on
the
interface
types
which
this
/
/
/
#
[
derive
(
xpcom
)
]
type
can
be
safely
ane
cheaply
coerced
to
using
/
/
/
the
coerce
method
.
/
/
/
/
/
/
The
trait
and
its
method
should
usually
not
be
used
directly
but
/
/
/
rather
acts
as
a
trait
bound
and
implementation
for
the
coerce
/
/
/
methods
.
#
[
doc
(
hidden
)
]
#
vis
trait
#
coerce_name
{
/
/
/
Convert
a
value
of
the
#
[
derive
(
xpcom
)
]
type
into
the
/
/
/
implementing
interface
type
.
fn
coerce_from
(
v
:
&
#
name
)
-
>
&
Self
;
}
#
(
#
coerce_impl
)
*
unsafe
impl
:
:
xpcom
:
:
RefCounted
for
#
name
{
unsafe
fn
addref
(
&
self
)
{
self
.
AddRef
(
)
;
}
unsafe
fn
release
(
&
self
)
{
self
.
Release
(
)
;
}
}
}
)
}
#
[
proc_macro_derive
(
xpcom
attributes
(
xpimplements
refcnt
)
)
]
pub
fn
xpcom_internal
(
input
:
TokenStream
)
-
>
TokenStream
{
let
input
=
parse_macro_input
!
(
input
as
DeriveInput
)
;
match
xpcom
(
input
)
{
Ok
(
ts
)
=
>
ts
.
into
(
)
Err
(
err
)
=
>
err
.
to_compile_error
(
)
.
into
(
)
}
}
