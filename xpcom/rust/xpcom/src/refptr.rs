use
std
:
:
mem
;
use
std
:
:
ptr
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
sync
:
:
atomic
:
:
{
self
AtomicUsize
Ordering
}
;
use
nserror
:
:
{
NsresultExt
nsresult
NS_OK
}
;
use
libc
;
use
interfaces
:
:
nsrefcnt
;
use
threadbound
:
:
ThreadBound
;
pub
unsafe
trait
RefCounted
{
unsafe
fn
addref
(
&
self
)
;
unsafe
fn
release
(
&
self
)
;
}
pub
struct
RefPtr
<
T
:
RefCounted
+
'
static
>
{
_ptr
:
&
'
static
T
_marker
:
PhantomData
<
T
>
}
impl
<
T
:
RefCounted
+
'
static
>
RefPtr
<
T
>
{
#
[
inline
]
pub
fn
new
(
p
:
&
T
)
-
>
RefPtr
<
T
>
{
unsafe
{
p
.
addref
(
)
;
RefPtr
{
_ptr
:
mem
:
:
transmute
(
p
)
_marker
:
PhantomData
}
}
}
#
[
inline
]
pub
unsafe
fn
from_raw
(
p
:
*
const
T
)
-
>
Option
<
RefPtr
<
T
>
>
{
if
p
.
is_null
(
)
{
return
None
;
}
(
*
p
)
.
addref
(
)
;
Some
(
RefPtr
{
_ptr
:
&
*
p
_marker
:
PhantomData
}
)
}
#
[
inline
]
pub
unsafe
fn
from_raw_dont_addref
(
p
:
*
const
T
)
-
>
Option
<
RefPtr
<
T
>
>
{
if
p
.
is_null
(
)
{
return
None
;
}
Some
(
RefPtr
{
_ptr
:
&
*
p
_marker
:
PhantomData
}
)
}
#
[
inline
]
pub
fn
forget
(
self
into
:
&
mut
*
const
T
)
{
*
into
=
&
*
self
;
mem
:
:
forget
(
self
)
;
}
}
impl
<
T
:
RefCounted
+
'
static
>
Deref
for
RefPtr
<
T
>
{
type
Target
=
T
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
T
{
self
.
_ptr
}
}
impl
<
T
:
RefCounted
+
'
static
>
Drop
for
RefPtr
<
T
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
_ptr
.
release
(
)
;
}
}
}
impl
<
T
:
RefCounted
+
'
static
>
Clone
for
RefPtr
<
T
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
RefPtr
<
T
>
{
RefPtr
:
:
new
(
self
)
}
}
pub
struct
ThreadBoundRefPtr
<
T
:
RefCounted
+
'
static
>
(
ThreadBound
<
*
const
T
>
)
;
impl
<
T
:
RefCounted
+
'
static
>
ThreadBoundRefPtr
<
T
>
{
pub
fn
new
(
ptr
:
RefPtr
<
T
>
)
-
>
Self
{
let
raw
:
*
const
T
=
&
*
ptr
;
mem
:
:
forget
(
ptr
)
;
ThreadBoundRefPtr
(
ThreadBound
:
:
new
(
raw
)
)
}
pub
fn
get_ref
(
&
self
)
-
>
Option
<
&
T
>
{
self
.
0
.
get_ref
(
)
.
map
(
|
raw
|
unsafe
{
&
*
*
raw
}
)
}
}
impl
<
T
:
RefCounted
+
'
static
>
Drop
for
ThreadBoundRefPtr
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
RefPtr
:
:
from_raw_dont_addref
(
self
.
get_ref
(
)
.
expect
(
"
drop
(
)
called
on
wrong
thread
!
"
)
)
;
}
}
}
pub
struct
GetterAddrefs
<
T
:
RefCounted
+
'
static
>
{
_ptr
:
*
const
T
_marker
:
PhantomData
<
T
>
}
impl
<
T
:
RefCounted
+
'
static
>
GetterAddrefs
<
T
>
{
#
[
inline
]
pub
fn
new
(
)
-
>
GetterAddrefs
<
T
>
{
GetterAddrefs
{
_ptr
:
ptr
:
:
null
(
)
_marker
:
PhantomData
}
}
#
[
inline
]
pub
unsafe
fn
ptr
(
&
mut
self
)
-
>
&
mut
*
const
T
{
&
mut
self
.
_ptr
}
#
[
inline
]
pub
unsafe
fn
void_ptr
(
&
mut
self
)
-
>
*
mut
*
mut
libc
:
:
c_void
{
&
mut
self
.
_ptr
as
*
mut
*
const
T
as
*
mut
*
mut
libc
:
:
c_void
}
#
[
inline
]
pub
fn
refptr
(
self
)
-
>
Option
<
RefPtr
<
T
>
>
{
let
p
=
self
.
_ptr
;
mem
:
:
forget
(
self
)
;
unsafe
{
RefPtr
:
:
from_raw_dont_addref
(
p
)
}
}
}
impl
<
T
:
RefCounted
+
'
static
>
Drop
for
GetterAddrefs
<
T
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
if
!
self
.
_ptr
.
is_null
(
)
{
unsafe
{
(
*
self
.
_ptr
)
.
release
(
)
;
}
}
}
}
#
[
inline
]
pub
fn
getter_addrefs
<
T
:
RefCounted
F
>
(
f
:
F
)
-
>
Result
<
RefPtr
<
T
>
nsresult
>
where
F
:
FnOnce
(
*
mut
*
const
T
)
-
>
nsresult
{
let
mut
ga
=
GetterAddrefs
:
:
<
T
>
:
:
new
(
)
;
let
rv
=
f
(
unsafe
{
ga
.
ptr
(
)
}
)
;
if
rv
.
failed
(
)
{
return
Err
(
rv
)
;
}
ga
.
refptr
(
)
.
ok_or
(
NS_OK
)
}
#
[
derive
(
Debug
)
]
pub
struct
Refcnt
(
Cell
<
nsrefcnt
>
)
;
impl
Refcnt
{
pub
unsafe
fn
new
(
)
-
>
Self
{
Refcnt
(
Cell
:
:
new
(
0
)
)
}
pub
unsafe
fn
inc
(
&
self
)
-
>
nsrefcnt
{
let
new
=
self
.
0
.
get
(
)
+
1
;
self
.
0
.
set
(
new
)
;
new
}
pub
unsafe
fn
dec
(
&
self
)
-
>
nsrefcnt
{
let
new
=
self
.
0
.
get
(
)
-
1
;
self
.
0
.
set
(
new
)
;
new
}
pub
fn
get
(
&
self
)
-
>
nsrefcnt
{
self
.
0
.
get
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
AtomicRefcnt
(
AtomicUsize
)
;
impl
AtomicRefcnt
{
pub
unsafe
fn
new
(
)
-
>
Self
{
AtomicRefcnt
(
AtomicUsize
:
:
new
(
0
)
)
}
pub
unsafe
fn
inc
(
&
self
)
-
>
nsrefcnt
{
self
.
0
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
as
nsrefcnt
+
1
}
pub
unsafe
fn
dec
(
&
self
)
-
>
nsrefcnt
{
let
result
=
self
.
0
.
fetch_sub
(
1
Ordering
:
:
Release
)
as
nsrefcnt
-
1
;
if
result
=
=
0
{
atomic
:
:
fence
(
Ordering
:
:
Acquire
)
;
}
result
}
pub
fn
get
(
&
self
)
-
>
nsrefcnt
{
self
.
0
.
load
(
Ordering
:
:
Acquire
)
as
nsrefcnt
}
}
