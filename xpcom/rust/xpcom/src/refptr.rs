use
crate
:
:
interfaces
:
:
nsrefcnt
;
use
libc
;
use
nserror
:
:
{
nsresult
NS_OK
}
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
fmt
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
;
use
std
:
:
ops
:
:
Deref
;
use
std
:
:
ptr
:
:
{
self
NonNull
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
self
AtomicUsize
Ordering
}
;
use
threadbound
:
:
ThreadBound
;
pub
unsafe
trait
RefCounted
{
unsafe
fn
addref
(
&
self
)
;
unsafe
fn
release
(
&
self
)
;
}
pub
struct
RefPtr
<
T
:
RefCounted
+
'
static
>
{
_ptr
:
NonNull
<
T
>
_marker
:
PhantomData
<
T
>
}
impl
<
T
:
RefCounted
+
'
static
>
RefPtr
<
T
>
{
#
[
inline
]
pub
fn
new
(
p
:
&
T
)
-
>
RefPtr
<
T
>
{
unsafe
{
p
.
addref
(
)
;
}
RefPtr
{
_ptr
:
p
.
into
(
)
_marker
:
PhantomData
}
}
#
[
inline
]
pub
unsafe
fn
from_raw
(
p
:
*
const
T
)
-
>
Option
<
RefPtr
<
T
>
>
{
let
ptr
=
NonNull
:
:
new
(
p
as
*
mut
T
)
?
;
ptr
.
as_ref
(
)
.
addref
(
)
;
Some
(
RefPtr
{
_ptr
:
ptr
_marker
:
PhantomData
}
)
}
#
[
inline
]
pub
unsafe
fn
from_raw_dont_addref
(
p
:
*
const
T
)
-
>
Option
<
RefPtr
<
T
>
>
{
Some
(
RefPtr
{
_ptr
:
NonNull
:
:
new
(
p
as
*
mut
T
)
?
_marker
:
PhantomData
}
)
}
#
[
inline
]
pub
fn
forget
(
self
into
:
&
mut
*
const
T
)
{
*
into
=
Self
:
:
forget_into_raw
(
self
)
;
}
#
[
inline
]
pub
fn
forget_into_raw
(
this
:
RefPtr
<
T
>
)
-
>
*
const
T
{
let
into
=
&
*
this
as
*
const
T
;
mem
:
:
forget
(
this
)
;
into
}
}
impl
<
T
:
RefCounted
+
'
static
>
Deref
for
RefPtr
<
T
>
{
type
Target
=
T
;
#
[
inline
]
fn
deref
(
&
self
)
-
>
&
T
{
unsafe
{
self
.
_ptr
.
as_ref
(
)
}
}
}
impl
<
T
:
RefCounted
+
'
static
>
Drop
for
RefPtr
<
T
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
unsafe
{
self
.
_ptr
.
as_ref
(
)
.
release
(
)
;
}
}
}
impl
<
T
:
RefCounted
+
'
static
>
Clone
for
RefPtr
<
T
>
{
#
[
inline
]
fn
clone
(
&
self
)
-
>
RefPtr
<
T
>
{
RefPtr
:
:
new
(
self
)
}
}
impl
<
T
:
RefCounted
+
'
static
+
fmt
:
:
Debug
>
fmt
:
:
Debug
for
RefPtr
<
T
>
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
RefPtr
<
{
:
?
}
>
"
self
.
deref
(
)
)
}
}
unsafe
impl
<
T
:
RefCounted
+
'
static
+
Send
+
Sync
>
Send
for
RefPtr
<
T
>
{
}
unsafe
impl
<
T
:
RefCounted
+
'
static
+
Send
+
Sync
>
Sync
for
RefPtr
<
T
>
{
}
pub
struct
ThreadBoundRefPtr
<
T
:
RefCounted
+
'
static
>
(
ThreadBound
<
*
const
T
>
)
;
impl
<
T
:
RefCounted
+
'
static
>
ThreadBoundRefPtr
<
T
>
{
pub
fn
new
(
ptr
:
RefPtr
<
T
>
)
-
>
Self
{
let
raw
:
*
const
T
=
&
*
ptr
;
mem
:
:
forget
(
ptr
)
;
ThreadBoundRefPtr
(
ThreadBound
:
:
new
(
raw
)
)
}
pub
fn
get_ref
(
&
self
)
-
>
Option
<
&
T
>
{
self
.
0
.
get_ref
(
)
.
map
(
|
raw
|
unsafe
{
&
*
*
raw
}
)
}
}
impl
<
T
:
RefCounted
+
'
static
>
Drop
for
ThreadBoundRefPtr
<
T
>
{
fn
drop
(
&
mut
self
)
{
unsafe
{
RefPtr
:
:
from_raw_dont_addref
(
self
.
get_ref
(
)
.
expect
(
"
drop
(
)
called
on
wrong
thread
!
"
)
)
;
}
}
}
pub
struct
GetterAddrefs
<
T
:
RefCounted
+
'
static
>
{
_ptr
:
*
const
T
_marker
:
PhantomData
<
T
>
}
impl
<
T
:
RefCounted
+
'
static
>
GetterAddrefs
<
T
>
{
#
[
inline
]
pub
fn
new
(
)
-
>
GetterAddrefs
<
T
>
{
GetterAddrefs
{
_ptr
:
ptr
:
:
null
(
)
_marker
:
PhantomData
}
}
#
[
inline
]
pub
unsafe
fn
ptr
(
&
mut
self
)
-
>
&
mut
*
const
T
{
&
mut
self
.
_ptr
}
#
[
inline
]
pub
unsafe
fn
void_ptr
(
&
mut
self
)
-
>
*
mut
*
mut
libc
:
:
c_void
{
&
mut
self
.
_ptr
as
*
mut
*
const
T
as
*
mut
*
mut
libc
:
:
c_void
}
#
[
inline
]
pub
fn
refptr
(
self
)
-
>
Option
<
RefPtr
<
T
>
>
{
let
p
=
self
.
_ptr
;
mem
:
:
forget
(
self
)
;
unsafe
{
RefPtr
:
:
from_raw_dont_addref
(
p
)
}
}
}
impl
<
T
:
RefCounted
+
'
static
>
Drop
for
GetterAddrefs
<
T
>
{
#
[
inline
]
fn
drop
(
&
mut
self
)
{
if
!
self
.
_ptr
.
is_null
(
)
{
unsafe
{
(
*
self
.
_ptr
)
.
release
(
)
;
}
}
}
}
#
[
inline
]
pub
fn
getter_addrefs
<
T
:
RefCounted
F
>
(
f
:
F
)
-
>
Result
<
RefPtr
<
T
>
nsresult
>
where
F
:
FnOnce
(
*
mut
*
const
T
)
-
>
nsresult
{
let
mut
ga
=
GetterAddrefs
:
:
<
T
>
:
:
new
(
)
;
let
rv
=
f
(
unsafe
{
ga
.
ptr
(
)
}
)
;
if
rv
.
failed
(
)
{
return
Err
(
rv
)
;
}
ga
.
refptr
(
)
.
ok_or
(
NS_OK
)
}
#
[
derive
(
Debug
)
]
pub
struct
Refcnt
(
Cell
<
nsrefcnt
>
)
;
impl
Refcnt
{
pub
unsafe
fn
new
(
)
-
>
Self
{
Refcnt
(
Cell
:
:
new
(
0
)
)
}
pub
unsafe
fn
inc
(
&
self
)
-
>
nsrefcnt
{
let
new
=
self
.
0
.
get
(
)
+
1
;
self
.
0
.
set
(
new
)
;
new
}
pub
unsafe
fn
dec
(
&
self
)
-
>
nsrefcnt
{
let
new
=
self
.
0
.
get
(
)
-
1
;
self
.
0
.
set
(
new
)
;
new
}
pub
fn
get
(
&
self
)
-
>
nsrefcnt
{
self
.
0
.
get
(
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
AtomicRefcnt
(
AtomicUsize
)
;
impl
AtomicRefcnt
{
pub
unsafe
fn
new
(
)
-
>
Self
{
AtomicRefcnt
(
AtomicUsize
:
:
new
(
0
)
)
}
pub
unsafe
fn
inc
(
&
self
)
-
>
nsrefcnt
{
self
.
0
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
as
nsrefcnt
+
1
}
pub
unsafe
fn
dec
(
&
self
)
-
>
nsrefcnt
{
let
result
=
self
.
0
.
fetch_sub
(
1
Ordering
:
:
Release
)
as
nsrefcnt
-
1
;
if
result
=
=
0
{
if
cfg
!
(
feature
=
"
thread_sanitizer
"
)
{
self
.
0
.
load
(
Ordering
:
:
Acquire
)
;
}
else
{
atomic
:
:
fence
(
Ordering
:
:
Acquire
)
;
}
}
result
}
pub
fn
get
(
&
self
)
-
>
nsrefcnt
{
self
.
0
.
load
(
Ordering
:
:
Acquire
)
as
nsrefcnt
}
}
#
[
cfg
(
feature
=
"
gecko_refcount_logging
"
)
]
pub
mod
trace_refcnt
{
use
crate
:
:
interfaces
:
:
nsrefcnt
;
extern
"
C
"
{
pub
fn
NS_LogCtor
(
aPtr
:
*
mut
libc
:
:
c_void
aTypeName
:
*
const
libc
:
:
c_char
aSize
:
u32
)
;
pub
fn
NS_LogDtor
(
aPtr
:
*
mut
libc
:
:
c_void
aTypeName
:
*
const
libc
:
:
c_char
aSize
:
u32
)
;
pub
fn
NS_LogAddRef
(
aPtr
:
*
mut
libc
:
:
c_void
aRefcnt
:
nsrefcnt
aClass
:
*
const
libc
:
:
c_char
aClassSize
:
u32
)
;
pub
fn
NS_LogRelease
(
aPtr
:
*
mut
libc
:
:
c_void
aRefcnt
:
nsrefcnt
aClass
:
*
const
libc
:
:
c_char
aClassSize
:
u32
)
;
}
}
#
[
cfg
(
not
(
feature
=
"
gecko_refcount_logging
"
)
)
]
pub
mod
trace_refcnt
{
use
crate
:
:
interfaces
:
:
nsrefcnt
;
#
[
inline
]
#
[
allow
(
non_snake_case
)
]
pub
unsafe
extern
"
C
"
fn
NS_LogCtor
(
_
:
*
mut
libc
:
:
c_void
_
:
*
const
libc
:
:
c_char
_
:
u32
)
{
}
#
[
inline
]
#
[
allow
(
non_snake_case
)
]
pub
unsafe
extern
"
C
"
fn
NS_LogDtor
(
_
:
*
mut
libc
:
:
c_void
_
:
*
const
libc
:
:
c_char
_
:
u32
)
{
}
#
[
inline
]
#
[
allow
(
non_snake_case
)
]
pub
unsafe
extern
"
C
"
fn
NS_LogAddRef
(
_
:
*
mut
libc
:
:
c_void
_
:
nsrefcnt
_
:
*
const
libc
:
:
c_char
_
:
u32
)
{
}
#
[
inline
]
#
[
allow
(
non_snake_case
)
]
pub
unsafe
extern
"
C
"
fn
NS_LogRelease
(
_
:
*
mut
libc
:
:
c_void
_
:
nsrefcnt
_
:
*
const
libc
:
:
c_char
_
:
u32
)
{
}
}
