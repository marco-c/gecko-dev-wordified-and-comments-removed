extern
crate
encoding_rs
;
use
std
:
:
slice
;
use
super
:
:
nsACString
;
use
super
:
:
nsAString
;
use
super
:
:
nsCStringLike
;
use
super
:
:
BulkWriteOk
;
use
super
:
:
Gecko_FallibleAssignCString
;
use
super
:
:
Latin1StringLike
;
use
conversions
:
:
encoding_rs
:
:
mem
:
:
*
;
use
conversions
:
:
encoding_rs
:
:
Encoding
;
#
[
inline
(
always
)
]
fn
times_three
(
a
:
usize
)
-
>
Option
<
usize
>
{
a
.
checked_mul
(
3
)
}
#
[
inline
(
always
)
]
fn
identity
(
a
:
usize
)
-
>
Option
<
usize
>
{
Some
(
a
)
}
#
[
inline
(
always
)
]
fn
plus_one
(
a
:
usize
)
-
>
Option
<
usize
>
{
a
.
checked_add
(
1
)
}
const
CACHE_LINE
:
usize
=
64
;
const
CACHE_LINE_MASK
:
usize
=
CACHE_LINE
-
1
;
#
[
inline
(
always
)
]
fn
long_string_starts_with_ascii
(
buffer
:
&
[
u8
]
)
-
>
bool
{
if
buffer
.
len
(
)
<
=
CACHE_LINE
{
return
false
;
}
let
bound
=
CACHE_LINE
-
(
(
buffer
.
as_ptr
(
)
as
usize
)
&
CACHE_LINE_MASK
)
;
is_ascii
(
&
buffer
[
.
.
bound
]
)
}
#
[
inline
(
always
)
]
fn
long_string_stars_with_basic_latin
(
buffer
:
&
[
u16
]
)
-
>
bool
{
if
buffer
.
len
(
)
<
=
CACHE_LINE
{
return
false
;
}
let
bound
=
(
CACHE_LINE
*
2
-
(
(
buffer
.
as_ptr
(
)
as
usize
)
&
CACHE_LINE_MASK
)
)
/
2
;
is_basic_latin
(
&
buffer
[
.
.
bound
]
)
}
macro_rules
!
shrinking_conversion
{
(
name
=
name
:
ident
convert
=
convert
:
ident
other_ty
=
other_ty
:
ty
math
=
math
:
ident
)
=
>
(
fn
name
(
&
mut
self
other
:
other_ty
old_len
:
usize
)
-
>
Result
<
BulkWriteOk
(
)
>
{
let
needed
=
math
(
other
.
len
(
)
)
.
ok_or
(
(
)
)
?
;
let
mut
handle
=
unsafe
{
self
.
bulk_write
(
old_len
.
checked_add
(
needed
)
.
ok_or
(
(
)
)
?
old_len
false
)
?
}
;
let
written
=
convert
(
other
&
mut
handle
.
as_mut_slice
(
)
[
old_len
.
.
]
)
;
let
new_len
=
old_len
+
written
;
Ok
(
handle
.
finish
(
new_len
new_len
>
CACHE_LINE
)
)
}
)
}
macro_rules
!
constant_conversion
{
(
name
=
name
:
ident
convert
=
convert
:
ident
other_ty
=
other_ty
:
ty
)
=
>
(
fn
name
(
&
mut
self
other
:
other_ty
old_len
:
usize
allow_shrinking
:
bool
)
-
>
Result
<
BulkWriteOk
(
)
>
{
let
new_len
=
old_len
.
checked_add
(
other
.
len
(
)
)
.
ok_or
(
(
)
)
?
;
let
mut
handle
=
unsafe
{
self
.
bulk_write
(
new_len
old_len
allow_shrinking
)
?
}
;
convert
(
other
&
mut
handle
.
as_mut_slice
(
)
[
old_len
.
.
]
)
;
Ok
(
handle
.
finish
(
new_len
false
)
)
}
)
}
macro_rules
!
ascii_copy_avoidance
{
(
name
=
name
:
ident
implementation
=
implementation
:
ident
string_like
=
string_like
:
ident
)
=
>
(
fn
name
<
T
:
string_like
+
?
Sized
>
(
&
mut
self
other
:
&
T
old_len
:
usize
)
-
>
Result
<
BulkWriteOk
(
)
>
{
let
adapter
=
other
.
adapt
(
)
;
let
other_slice
=
adapter
.
as_ref
(
)
;
let
num_ascii
=
if
adapter
.
is_abstract
(
)
&
&
old_len
=
=
0
{
let
up_to
=
Encoding
:
:
ascii_valid_up_to
(
other_slice
)
;
if
up_to
=
=
other_slice
.
len
(
)
{
/
/
Calling
something
whose
argument
can
be
obtained
from
/
/
the
adapter
rather
than
an
nsStringLike
avoids
a
huge
/
/
lifetime
mess
by
keeping
nsStringLike
and
/
/
Latin1StringLike
free
of
lifetime
interdependencies
.
if
unsafe
{
Gecko_FallibleAssignCString
(
self
other
.
adapt
(
)
.
as_ptr
(
)
)
}
{
return
Ok
(
BulkWriteOk
{
}
)
;
}
else
{
return
Err
(
(
)
)
;
}
}
Some
(
up_to
)
}
else
{
None
}
;
self
.
implementation
(
other_slice
old_len
num_ascii
)
}
)
}
impl
nsAString
{
shrinking_conversion
!
(
name
=
fallible_append_str_impl
convert
=
convert_str_to_utf16
other_ty
=
&
str
math
=
identity
)
;
pub
fn
assign_str
(
&
mut
self
other
:
&
str
)
{
self
.
fallible_append_str_impl
(
other
0
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_assign_str
(
&
mut
self
other
:
&
str
)
-
>
Result
<
(
)
(
)
>
{
self
.
fallible_append_str_impl
(
other
0
)
.
map
(
|
_
|
(
)
)
}
pub
fn
append_str
(
&
mut
self
other
:
&
str
)
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_str_impl
(
other
len
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_append_str
(
&
mut
self
other
:
&
str
)
-
>
Result
<
(
)
(
)
>
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_str_impl
(
other
len
)
.
map
(
|
_
|
(
)
)
}
shrinking_conversion
!
(
name
=
fallible_append_utf8_impl
convert
=
convert_utf8_to_utf16
other_ty
=
&
[
u8
]
math
=
plus_one
)
;
pub
fn
assign_utf8
(
&
mut
self
other
:
&
[
u8
]
)
{
self
.
fallible_append_utf8_impl
(
other
0
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_assign_utf8
(
&
mut
self
other
:
&
[
u8
]
)
-
>
Result
<
(
)
(
)
>
{
self
.
fallible_append_utf8_impl
(
other
0
)
.
map
(
|
_
|
(
)
)
}
pub
fn
append_utf8
(
&
mut
self
other
:
&
[
u8
]
)
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_utf8_impl
(
other
len
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_append_utf8
(
&
mut
self
other
:
&
[
u8
]
)
-
>
Result
<
(
)
(
)
>
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_utf8_impl
(
other
len
)
.
map
(
|
_
|
(
)
)
}
constant_conversion
!
(
name
=
fallible_append_latin1_impl
convert
=
convert_latin1_to_utf16
other_ty
=
&
[
u8
]
)
;
pub
fn
assign_latin1
(
&
mut
self
other
:
&
[
u8
]
)
{
self
.
fallible_append_latin1_impl
(
other
0
true
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_assign_latin1
(
&
mut
self
other
:
&
[
u8
]
)
-
>
Result
<
(
)
(
)
>
{
self
.
fallible_append_latin1_impl
(
other
0
true
)
.
map
(
|
_
|
(
)
)
}
pub
fn
append_latin1
(
&
mut
self
other
:
&
[
u8
]
)
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_latin1_impl
(
other
len
false
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_append_latin1
(
&
mut
self
other
:
&
[
u8
]
)
-
>
Result
<
(
)
(
)
>
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_latin1_impl
(
other
len
false
)
.
map
(
|
_
|
(
)
)
}
}
impl
nsACString
{
fn
fallible_append_utf16_to_utf8_impl
(
&
mut
self
other
:
&
[
u16
]
old_len
:
usize
)
-
>
Result
<
BulkWriteOk
(
)
>
{
let
worst_case_needed
=
if
let
Some
(
inline_capacity
)
=
self
.
inline_capacity
(
)
{
let
worst_case
=
times_three
(
other
.
len
(
)
)
.
ok_or
(
(
)
)
?
;
if
worst_case
<
=
inline_capacity
{
Some
(
worst_case
)
}
else
{
None
}
}
else
{
None
}
;
let
(
filled
read
mut
handle
)
=
if
worst_case_needed
.
is_none
(
)
&
&
long_string_stars_with_basic_latin
(
other
)
{
let
new_len_with_ascii
=
old_len
.
checked_add
(
other
.
len
(
)
)
.
ok_or
(
(
)
)
?
;
let
mut
handle
=
unsafe
{
self
.
bulk_write
(
new_len_with_ascii
old_len
false
)
?
}
;
let
(
read
written
)
=
convert_utf16_to_utf8_partial
(
other
&
mut
handle
.
as_mut_slice
(
)
[
old_len
.
.
]
)
;
let
left
=
other
.
len
(
)
-
read
;
if
left
=
=
0
{
return
Ok
(
handle
.
finish
(
old_len
+
written
true
)
)
;
}
let
filled
=
old_len
+
written
;
let
needed
=
times_three
(
left
)
.
ok_or
(
(
)
)
?
;
let
new_len
=
filled
.
checked_add
(
needed
)
.
ok_or
(
(
)
)
?
;
unsafe
{
handle
.
restart_bulk_write
(
new_len
filled
false
)
?
;
}
(
filled
read
handle
)
}
else
{
let
needed
=
if
let
Some
(
n
)
=
worst_case_needed
{
n
}
else
{
times_three
(
other
.
len
(
)
)
.
ok_or
(
(
)
)
?
}
;
let
new_len
=
old_len
.
checked_add
(
needed
)
.
ok_or
(
(
)
)
?
;
let
mut
handle
=
unsafe
{
self
.
bulk_write
(
new_len
old_len
false
)
?
}
;
(
old_len
0
handle
)
}
;
let
written
=
convert_utf16_to_utf8
(
&
other
[
read
.
.
]
&
mut
handle
.
as_mut_slice
(
)
[
filled
.
.
]
)
;
Ok
(
handle
.
finish
(
filled
+
written
true
)
)
}
pub
fn
assign_utf16_to_utf8
(
&
mut
self
other
:
&
[
u16
]
)
{
self
.
fallible_append_utf16_to_utf8_impl
(
other
0
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_assign_utf16_to_utf8
(
&
mut
self
other
:
&
[
u16
]
)
-
>
Result
<
(
)
(
)
>
{
self
.
fallible_append_utf16_to_utf8_impl
(
other
0
)
.
map
(
|
_
|
(
)
)
}
pub
fn
append_utf16_to_utf8
(
&
mut
self
other
:
&
[
u16
]
)
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_utf16_to_utf8_impl
(
other
len
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_append_utf16_to_utf8
(
&
mut
self
other
:
&
[
u16
]
)
-
>
Result
<
(
)
(
)
>
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_utf16_to_utf8_impl
(
other
len
)
.
map
(
|
_
|
(
)
)
}
constant_conversion
!
(
name
=
fallible_append_utf16_to_latin1_lossy_impl
convert
=
convert_utf16_to_latin1_lossy
other_ty
=
&
[
u16
]
)
;
pub
fn
assign_utf16_to_latin1_lossy
(
&
mut
self
other
:
&
[
u16
]
)
{
self
.
fallible_append_utf16_to_latin1_lossy_impl
(
other
0
true
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_assign_utf16_to_latin1_lossy
(
&
mut
self
other
:
&
[
u16
]
)
-
>
Result
<
(
)
(
)
>
{
self
.
fallible_append_utf16_to_latin1_lossy_impl
(
other
0
true
)
.
map
(
|
_
|
(
)
)
}
pub
fn
append_utf16_to_latin1_lossy
(
&
mut
self
other
:
&
[
u16
]
)
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_utf16_to_latin1_lossy_impl
(
other
len
false
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_append_utf16_to_latin1_lossy
(
&
mut
self
other
:
&
[
u16
]
)
-
>
Result
<
(
)
(
)
>
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_utf16_to_latin1_lossy_impl
(
other
len
false
)
.
map
(
|
_
|
(
)
)
}
ascii_copy_avoidance
!
(
name
=
fallible_append_utf8_to_latin1_lossy_check
implementation
=
fallible_append_utf8_to_latin1_lossy_impl
string_like
=
nsCStringLike
)
;
fn
fallible_append_utf8_to_latin1_lossy_impl
(
&
mut
self
other
:
&
[
u8
]
old_len
:
usize
maybe_num_ascii
:
Option
<
usize
>
)
-
>
Result
<
BulkWriteOk
(
)
>
{
let
new_len
=
old_len
.
checked_add
(
other
.
len
(
)
)
.
ok_or
(
(
)
)
?
;
let
num_ascii
=
maybe_num_ascii
.
unwrap_or
(
0
)
;
let
old_len_plus_num_ascii
=
old_len
+
num_ascii
;
let
mut
handle
=
unsafe
{
self
.
bulk_write
(
new_len
old_len
false
)
?
}
;
let
written
=
{
let
buffer
=
handle
.
as_mut_slice
(
)
;
if
num_ascii
!
=
0
{
(
&
mut
buffer
[
old_len
.
.
old_len_plus_num_ascii
]
)
.
copy_from_slice
(
&
other
[
.
.
num_ascii
]
)
;
}
convert_utf8_to_latin1_lossy
(
&
other
[
num_ascii
.
.
]
&
mut
buffer
[
old_len_plus_num_ascii
.
.
]
)
}
;
Ok
(
handle
.
finish
(
old_len_plus_num_ascii
+
written
true
)
)
}
pub
fn
assign_utf8_to_latin1_lossy
<
T
:
nsCStringLike
+
?
Sized
>
(
&
mut
self
other
:
&
T
)
{
self
.
fallible_append_utf8_to_latin1_lossy_check
(
other
0
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_assign_utf8_to_latin1_lossy
<
T
:
nsCStringLike
+
?
Sized
>
(
&
mut
self
other
:
&
T
)
-
>
Result
<
(
)
(
)
>
{
self
.
fallible_append_utf8_to_latin1_lossy_check
(
other
0
)
.
map
(
|
_
|
(
)
)
}
pub
fn
append_utf8_to_latin1_lossy
<
T
:
nsCStringLike
+
?
Sized
>
(
&
mut
self
other
:
&
T
)
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_utf8_to_latin1_lossy_check
(
other
len
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_append_utf8_to_latin1_lossy
<
T
:
nsCStringLike
+
?
Sized
>
(
&
mut
self
other
:
&
T
)
-
>
Result
<
(
)
(
)
>
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_utf8_to_latin1_lossy_check
(
other
len
)
.
map
(
|
_
|
(
)
)
}
ascii_copy_avoidance
!
(
name
=
fallible_append_latin1_to_utf8_check
implementation
=
fallible_append_latin1_to_utf8_impl
string_like
=
Latin1StringLike
)
;
fn
fallible_append_latin1_to_utf8_impl
(
&
mut
self
other
:
&
[
u8
]
old_len
:
usize
maybe_num_ascii
:
Option
<
usize
>
)
-
>
Result
<
BulkWriteOk
(
)
>
{
let
(
filled
read
mut
handle
)
=
if
let
Some
(
num_ascii
)
=
maybe_num_ascii
{
let
left
=
other
.
len
(
)
-
num_ascii
;
let
filled
=
old_len
+
num_ascii
;
let
needed
=
left
.
checked_mul
(
2
)
.
ok_or
(
(
)
)
?
;
let
new_len
=
filled
.
checked_add
(
needed
)
.
ok_or
(
(
)
)
?
;
let
mut
handle
=
unsafe
{
self
.
bulk_write
(
new_len
old_len
false
)
?
}
;
if
num_ascii
!
=
0
{
(
&
mut
handle
.
as_mut_slice
(
)
[
old_len
.
.
filled
]
)
.
copy_from_slice
(
&
other
[
.
.
num_ascii
]
)
;
}
(
filled
num_ascii
handle
)
}
else
{
let
worst_case_needed
=
if
let
Some
(
inline_capacity
)
=
self
.
inline_capacity
(
)
{
let
worst_case
=
other
.
len
(
)
.
checked_mul
(
2
)
.
ok_or
(
(
)
)
?
;
if
worst_case
<
=
inline_capacity
{
Some
(
worst_case
)
}
else
{
None
}
}
else
{
None
}
;
if
worst_case_needed
.
is_none
(
)
&
&
long_string_starts_with_ascii
(
other
)
{
let
new_len_with_ascii
=
old_len
.
checked_add
(
other
.
len
(
)
)
.
ok_or
(
(
)
)
?
;
let
mut
handle
=
unsafe
{
self
.
bulk_write
(
new_len_with_ascii
old_len
false
)
?
}
;
let
(
read
written
)
=
convert_latin1_to_utf8_partial
(
other
&
mut
handle
.
as_mut_slice
(
)
[
old_len
.
.
]
)
;
let
left
=
other
.
len
(
)
-
read
;
let
filled
=
old_len
+
written
;
if
left
=
=
0
{
return
Ok
(
handle
.
finish
(
filled
true
)
)
;
}
let
needed
=
left
.
checked_mul
(
2
)
.
ok_or
(
(
)
)
?
;
let
new_len
=
filled
.
checked_add
(
needed
)
.
ok_or
(
(
)
)
?
;
unsafe
{
handle
.
restart_bulk_write
(
new_len
filled
false
)
?
;
}
(
filled
read
handle
)
}
else
{
let
needed
=
if
let
Some
(
n
)
=
worst_case_needed
{
n
}
else
{
other
.
len
(
)
.
checked_mul
(
2
)
.
ok_or
(
(
)
)
?
}
;
let
new_len
=
old_len
.
checked_add
(
needed
)
.
ok_or
(
(
)
)
?
;
let
mut
handle
=
unsafe
{
self
.
bulk_write
(
new_len
old_len
false
)
?
}
;
(
old_len
0
handle
)
}
}
;
let
written
=
convert_latin1_to_utf8
(
&
other
[
read
.
.
]
&
mut
handle
.
as_mut_slice
(
)
[
filled
.
.
]
)
;
Ok
(
handle
.
finish
(
filled
+
written
true
)
)
}
pub
fn
assign_latin1_to_utf8
<
T
:
Latin1StringLike
+
?
Sized
>
(
&
mut
self
other
:
&
T
)
{
self
.
fallible_append_latin1_to_utf8_check
(
other
0
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_assign_latin1_to_utf8
<
T
:
Latin1StringLike
+
?
Sized
>
(
&
mut
self
other
:
&
T
)
-
>
Result
<
(
)
(
)
>
{
self
.
fallible_append_latin1_to_utf8_check
(
other
0
)
.
map
(
|
_
|
(
)
)
}
pub
fn
append_latin1_to_utf8
<
T
:
Latin1StringLike
+
?
Sized
>
(
&
mut
self
other
:
&
T
)
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_latin1_to_utf8_check
(
other
len
)
.
expect
(
"
Out
of
memory
"
)
;
}
pub
fn
fallible_append_latin1_to_utf8
<
T
:
Latin1StringLike
+
?
Sized
>
(
&
mut
self
other
:
&
T
)
-
>
Result
<
(
)
(
)
>
{
let
len
=
self
.
len
(
)
;
self
.
fallible_append_latin1_to_utf8_check
(
other
len
)
.
map
(
|
_
|
(
)
)
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
nsstring_fallible_append_utf8_impl
(
this
:
*
mut
nsAString
other
:
*
const
u8
other_len
:
usize
old_len
:
usize
)
-
>
bool
{
let
other_slice
=
slice
:
:
from_raw_parts
(
other
other_len
)
;
(
*
this
)
.
fallible_append_utf8_impl
(
other_slice
old_len
)
.
is_ok
(
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
nsstring_fallible_append_latin1_impl
(
this
:
*
mut
nsAString
other
:
*
const
u8
other_len
:
usize
old_len
:
usize
allow_shrinking
:
bool
)
-
>
bool
{
let
other_slice
=
slice
:
:
from_raw_parts
(
other
other_len
)
;
(
*
this
)
.
fallible_append_latin1_impl
(
other_slice
old_len
allow_shrinking
)
.
is_ok
(
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
nscstring_fallible_append_utf16_to_utf8_impl
(
this
:
*
mut
nsACString
other
:
*
const
u16
other_len
:
usize
old_len
:
usize
)
-
>
bool
{
let
other_slice
=
slice
:
:
from_raw_parts
(
other
other_len
)
;
(
*
this
)
.
fallible_append_utf16_to_utf8_impl
(
other_slice
old_len
)
.
is_ok
(
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
nscstring_fallible_append_utf16_to_latin1_lossy_impl
(
this
:
*
mut
nsACString
other
:
*
const
u16
other_len
:
usize
old_len
:
usize
allow_shrinking
:
bool
)
-
>
bool
{
let
other_slice
=
slice
:
:
from_raw_parts
(
other
other_len
)
;
(
*
this
)
.
fallible_append_utf16_to_latin1_lossy_impl
(
other_slice
old_len
allow_shrinking
)
.
is_ok
(
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
nscstring_fallible_append_utf8_to_latin1_lossy_check
(
this
:
*
mut
nsACString
other
:
*
const
nsACString
old_len
:
usize
)
-
>
bool
{
(
*
this
)
.
fallible_append_utf8_to_latin1_lossy_check
(
&
*
other
old_len
)
.
is_ok
(
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
nscstring_fallible_append_latin1_to_utf8_check
(
this
:
*
mut
nsACString
other
:
*
const
nsACString
old_len
:
usize
)
-
>
bool
{
(
*
this
)
.
fallible_append_latin1_to_utf8_check
(
&
*
other
old_len
)
.
is_ok
(
)
}
