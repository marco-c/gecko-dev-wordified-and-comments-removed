extern
crate
log
;
use
log
:
:
{
Level
LevelFilter
}
;
use
std
:
:
boxed
:
:
Box
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
ffi
:
:
{
CStr
CString
}
;
use
std
:
:
os
:
:
raw
:
:
c_char
;
use
std
:
:
os
:
:
raw
:
:
c_int
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicPtr
Ordering
}
;
use
std
:
:
sync
:
:
{
Arc
RwLock
}
;
extern
"
C
"
{
fn
ExternMozLog
(
tag
:
*
const
c_char
prio
:
c_int
text
:
*
const
c_char
)
;
}
static
LOG_MODULE_MAP
:
AtomicPtr
<
Arc
<
RwLock
<
HashMap
<
&
str
LevelFilter
>
>
>
>
=
AtomicPtr
:
:
new
(
ptr
:
:
null_mut
(
)
)
;
pub
fn
log_to_gecko
(
record
:
&
log
:
:
Record
)
-
>
bool
{
let
module_map
=
LOG_MODULE_MAP
.
load
(
Ordering
:
:
Relaxed
)
;
if
module_map
.
is_null
(
)
{
return
false
;
}
let
key
=
match
record
.
module_path
(
)
{
Some
(
key
)
=
>
key
None
=
>
return
false
}
;
let
level
=
{
let
arc
=
Arc
:
:
clone
(
unsafe
{
&
*
module_map
}
)
;
let
map
=
arc
.
read
(
)
.
unwrap
(
)
;
match
map
.
get
(
key
)
{
None
=
>
return
false
Some
(
module_level
)
=
>
module_level
.
clone
(
)
}
}
;
if
level
<
record
.
metadata
(
)
.
level
(
)
{
return
false
;
}
let
moz_log_level
=
match
record
.
metadata
(
)
.
level
(
)
{
Level
:
:
Error
=
>
1
Level
:
:
Warn
=
>
2
Level
:
:
Info
=
>
3
Level
:
:
Debug
=
>
4
Level
:
:
Trace
=
>
5
}
;
let
msg
=
CString
:
:
new
(
format
!
(
"
{
}
"
record
.
args
(
)
)
)
.
unwrap
(
)
;
let
tag
=
CString
:
:
new
(
key
)
.
unwrap
(
)
;
unsafe
{
ExternMozLog
(
tag
.
as_ptr
(
)
moz_log_level
msg
.
as_ptr
(
)
)
;
}
return
true
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
set_rust_log_level
(
module
:
*
const
c_char
level
:
u8
)
{
let
rust_level
=
match
level
{
1
=
>
LevelFilter
:
:
Error
2
=
>
LevelFilter
:
:
Warn
3
=
>
LevelFilter
:
:
Info
4
=
>
LevelFilter
:
:
Debug
5
=
>
LevelFilter
:
:
Trace
_
=
>
LevelFilter
:
:
Off
}
;
let
mod_name
=
unsafe
{
CStr
:
:
from_ptr
(
module
)
}
.
to_str
(
)
.
unwrap
(
)
;
let
mut
map
=
HashMap
:
:
new
(
)
;
map
.
insert
(
mod_name
rust_level
)
;
let
mut
new_map
=
Box
:
:
new
(
Arc
:
:
new
(
RwLock
:
:
new
(
map
)
)
)
;
let
myptr
=
if
rust_level
=
=
LevelFilter
:
:
Off
{
ptr
:
:
null_mut
(
)
}
else
{
new_map
.
as_mut
(
)
}
;
let
old_ptr
=
LOG_MODULE_MAP
.
compare_and_swap
(
ptr
:
:
null_mut
(
)
myptr
Ordering
:
:
SeqCst
)
;
if
old_ptr
.
is_null
(
)
{
if
!
myptr
.
is_null
(
)
{
log
:
:
set_max_level
(
rust_level
)
;
let
_
=
Box
:
:
into_raw
(
new_map
)
;
}
return
;
}
let
arc
=
Arc
:
:
clone
(
unsafe
{
&
*
old_ptr
}
)
;
let
mut
map
=
arc
.
write
(
)
.
unwrap
(
)
;
map
.
insert
(
mod_name
rust_level
)
;
let
max
=
map
.
values
(
)
.
max
(
)
.
unwrap_or
(
&
LevelFilter
:
:
Off
)
;
log
:
:
set_max_level
(
*
max
)
;
}
