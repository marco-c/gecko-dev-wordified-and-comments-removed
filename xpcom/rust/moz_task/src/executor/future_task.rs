use
crate
:
:
dispatch
;
use
futures_task
:
:
{
waker
ArcWake
}
;
use
nserror
:
:
{
nsresult
NS_OK
}
;
use
std
:
:
{
future
:
:
Future
pin
:
:
Pin
sync
:
:
{
atomic
:
:
{
AtomicUsize
Ordering
:
:
SeqCst
}
Arc
Mutex
}
task
:
:
{
Context
Poll
}
}
;
use
xpcom
:
:
{
interfaces
:
:
nsIEventTarget
xpcom
xpcom_method
RefPtr
ThreadBoundRefPtr
}
;
#
[
derive
(
xpcom
)
]
#
[
xpimplements
(
nsIRunnable
)
]
#
[
refcnt
=
"
atomic
"
]
struct
InitLocalTask
<
F
:
Future
<
Output
=
(
)
>
+
'
static
>
{
future
:
Mutex
<
F
>
event_target
:
RefPtr
<
nsIEventTarget
>
state
:
TaskState
}
impl
<
T
>
InitLocalTask
<
T
>
where
T
:
Future
<
Output
=
(
)
>
+
'
static
{
fn
new
(
future
:
T
event_target
:
RefPtr
<
nsIEventTarget
>
)
-
>
Self
{
InitLocalTask
{
future
:
Mutex
:
:
new
(
future
)
event_target
state
:
TaskState
:
:
default
(
)
}
}
}
impl
<
T
>
LocalTask
<
T
>
where
T
:
Future
<
Output
=
(
)
>
+
'
static
{
fn
enter
<
F
R
>
(
&
self
f
:
F
)
-
>
R
where
F
:
FnOnce
(
&
mut
Context
<
'
_
>
)
-
>
R
{
let
task
=
ThreadBoundRefPtr
:
:
new
(
RefPtr
:
:
new
(
self
)
)
;
let
wake_handle
=
Arc
:
:
new
(
LocalWakeHandle
{
task
}
)
;
let
waker
=
waker
(
wake_handle
)
;
let
mut
cx
=
Context
:
:
from_waker
(
&
waker
)
;
f
(
&
mut
cx
)
}
xpcom_method
!
(
run
=
>
Run
(
)
)
;
fn
run
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
self
.
enter
(
|
cx
|
{
assert
!
(
self
.
state
.
is
(
POLL
)
)
;
loop
{
let
mut
lock
=
self
.
future
.
lock
(
)
.
expect
(
"
Failed
to
lock
future
"
)
;
let
fut
=
unsafe
{
Pin
:
:
new_unchecked
(
&
mut
*
lock
)
}
;
let
res
=
fut
.
poll
(
cx
)
;
match
res
{
Poll
:
:
Pending
=
>
{
}
Poll
:
:
Ready
(
(
)
)
=
>
return
unsafe
{
self
.
state
.
complete
(
)
}
}
if
unsafe
{
!
self
.
state
.
wait
(
)
}
{
break
;
}
}
}
)
;
Ok
(
(
)
)
}
fn
wake_up
(
&
self
)
{
if
self
.
state
.
wake_up
(
)
{
unsafe
{
dispatch
(
self
.
coerce
(
)
&
self
.
event_target
)
}
.
unwrap
(
)
}
}
}
struct
TaskState
{
state
:
AtomicUsize
}
const
IDLE
:
usize
=
0
;
const
POLL
:
usize
=
1
;
const
REPOLL
:
usize
=
2
;
const
COMPLETE
:
usize
=
3
;
impl
Default
for
TaskState
{
fn
default
(
)
-
>
Self
{
Self
{
state
:
AtomicUsize
:
:
new
(
IDLE
)
}
}
}
impl
TaskState
{
fn
is
(
&
self
state
:
usize
)
-
>
bool
{
self
.
state
.
load
(
SeqCst
)
=
=
state
}
fn
wake_up
(
&
self
)
-
>
bool
{
let
mut
state
=
self
.
state
.
load
(
SeqCst
)
;
loop
{
match
state
{
IDLE
=
>
match
self
.
state
.
compare_exchange
(
IDLE
POLL
SeqCst
SeqCst
)
{
Ok
(
_
)
=
>
{
return
true
;
}
Err
(
cur
)
=
>
state
=
cur
}
POLL
=
>
match
self
.
state
.
compare_exchange
(
POLL
REPOLL
SeqCst
SeqCst
)
{
Ok
(
_
)
=
>
return
false
Err
(
cur
)
=
>
state
=
cur
}
_
=
>
return
false
}
}
}
unsafe
fn
wait
(
&
self
)
-
>
bool
{
debug_assert
!
(
matches
!
(
self
.
state
.
load
(
SeqCst
)
POLL
|
REPOLL
)
)
;
match
self
.
state
.
compare_exchange
(
POLL
IDLE
SeqCst
SeqCst
)
{
Ok
(
_
)
=
>
false
Err
(
state
)
=
>
{
assert_eq
!
(
state
REPOLL
)
;
self
.
state
.
store
(
POLL
SeqCst
)
;
true
}
}
}
unsafe
fn
complete
(
&
self
)
{
debug_assert
!
(
matches
!
(
self
.
state
.
load
(
SeqCst
)
POLL
|
REPOLL
)
)
;
self
.
state
.
store
(
COMPLETE
SeqCst
)
;
}
}
struct
LocalWakeHandle
<
F
:
Future
<
Output
=
(
)
>
+
'
static
>
{
task
:
ThreadBoundRefPtr
<
LocalTask
<
F
>
>
}
impl
<
F
>
ArcWake
for
LocalWakeHandle
<
F
>
where
F
:
Future
<
Output
=
(
)
>
+
'
static
{
fn
wake_by_ref
(
arc_self
:
&
Arc
<
Self
>
)
{
if
let
Some
(
task
)
=
arc_self
.
task
.
get_ref
(
)
{
task
.
wake_up
(
)
;
}
else
{
panic
!
(
"
Attempting
to
wake
task
from
the
wrong
thread
!
"
)
;
}
}
}
pub
unsafe
fn
local_task
<
T
>
(
future
:
T
current_thread
:
&
nsIEventTarget
)
where
T
:
Future
<
Output
=
(
)
>
+
'
static
{
let
task
=
LocalTask
:
:
allocate
(
InitLocalTask
:
:
new
(
future
RefPtr
:
:
new
(
current_thread
)
)
)
;
task
.
wake_up
(
)
;
}
