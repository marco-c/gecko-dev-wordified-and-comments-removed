mod
dispatcher
;
pub
use
dispatcher
:
:
{
dispatch_background_task
dispatch_local
dispatch_onto
RunnableBuilder
}
;
mod
event_loop
;
mod
executor
;
pub
use
executor
:
:
{
spawn
spawn_blocking
spawn_local
spawn_onto
spawn_onto_blocking
AsyncTask
TaskBuilder
}
;
pub
mod
gtest_only
{
pub
use
crate
:
:
event_loop
:
:
spin_event_loop_until
;
}
use
nserror
:
:
nsresult
;
use
nsstring
:
:
{
nsACString
nsCString
}
;
use
std
:
:
{
ffi
:
:
CStr
marker
:
:
PhantomData
mem
ptr
}
;
use
xpcom
:
:
{
getter_addrefs
interfaces
:
:
{
nsIEventTarget
nsIRunnable
nsISerialEventTarget
nsISupports
nsIThread
}
AtomicRefcnt
RefCounted
RefPtr
XpCom
}
;
extern
"
C
"
{
fn
NS_GetCurrentThreadRust
(
result
:
*
mut
*
const
nsIThread
)
-
>
nsresult
;
fn
NS_GetMainThreadRust
(
result
:
*
mut
*
const
nsIThread
)
-
>
nsresult
;
fn
NS_IsMainThread
(
)
-
>
bool
;
fn
NS_NewNamedThreadWithDefaultStackSize
(
name
:
*
const
nsACString
result
:
*
mut
*
const
nsIThread
event
:
*
const
nsIRunnable
)
-
>
nsresult
;
fn
NS_IsOnCurrentThread
(
target
:
*
const
nsIEventTarget
)
-
>
bool
;
fn
NS_ProxyReleaseISupports
(
name
:
*
const
libc
:
:
c_char
target
:
*
const
nsIEventTarget
doomed
:
*
const
nsISupports
always_proxy
:
bool
)
;
fn
NS_CreateBackgroundTaskQueue
(
name
:
*
const
libc
:
:
c_char
target
:
*
mut
*
const
nsISerialEventTarget
)
-
>
nsresult
;
fn
NS_DispatchBackgroundTask
(
event
:
*
const
nsIRunnable
flags
:
u32
)
-
>
nsresult
;
}
pub
fn
get_current_thread
(
)
-
>
Result
<
RefPtr
<
nsIThread
>
nsresult
>
{
getter_addrefs
(
|
p
|
unsafe
{
NS_GetCurrentThreadRust
(
p
)
}
)
}
pub
fn
get_main_thread
(
)
-
>
Result
<
RefPtr
<
nsIThread
>
nsresult
>
{
getter_addrefs
(
|
p
|
unsafe
{
NS_GetMainThreadRust
(
p
)
}
)
}
pub
fn
is_main_thread
(
)
-
>
bool
{
unsafe
{
NS_IsMainThread
(
)
}
}
pub
fn
create_thread
(
name
:
&
str
)
-
>
Result
<
RefPtr
<
nsIThread
>
nsresult
>
{
getter_addrefs
(
|
p
|
unsafe
{
NS_NewNamedThreadWithDefaultStackSize
(
&
*
nsCString
:
:
from
(
name
)
p
ptr
:
:
null
(
)
)
}
)
}
pub
fn
is_on_current_thread
(
target
:
&
nsIEventTarget
)
-
>
bool
{
unsafe
{
NS_IsOnCurrentThread
(
target
)
}
}
pub
fn
create_background_task_queue
(
name
:
&
'
static
CStr
)
-
>
Result
<
RefPtr
<
nsISerialEventTarget
>
nsresult
>
{
getter_addrefs
(
|
p
|
unsafe
{
NS_CreateBackgroundTaskQueue
(
name
.
as_ptr
(
)
p
)
}
)
}
pub
unsafe
fn
dispatch_runnable
(
runnable
:
&
nsIRunnable
target
:
&
nsIEventTarget
options
:
DispatchOptions
)
-
>
Result
<
(
)
nsresult
>
{
target
.
DispatchFromScript
(
runnable
options
.
flags
(
)
)
.
to_result
(
)
}
pub
unsafe
fn
dispatch_background_task_runnable
(
runnable
:
&
nsIRunnable
options
:
DispatchOptions
)
-
>
Result
<
(
)
nsresult
>
{
NS_DispatchBackgroundTask
(
runnable
options
.
flags
(
)
)
.
to_result
(
)
}
#
[
derive
(
Copy
Clone
Debug
Eq
Hash
PartialEq
)
]
pub
struct
DispatchOptions
(
u32
)
;
impl
Default
for
DispatchOptions
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
DispatchOptions
(
nsIEventTarget
:
:
DISPATCH_NORMAL
)
}
}
impl
DispatchOptions
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
DispatchOptions
:
:
default
(
)
}
#
[
inline
]
pub
fn
may_block
(
self
may_block
:
bool
)
-
>
DispatchOptions
{
const
FLAG
:
u32
=
nsIEventTarget
:
:
DISPATCH_EVENT_MAY_BLOCK
;
if
may_block
{
DispatchOptions
(
self
.
flags
(
)
|
FLAG
)
}
else
{
DispatchOptions
(
self
.
flags
(
)
&
!
FLAG
)
}
}
#
[
inline
]
pub
unsafe
fn
at_end
(
self
may_block
:
bool
)
-
>
DispatchOptions
{
const
FLAG
:
u32
=
nsIEventTarget
:
:
DISPATCH_AT_END
;
if
may_block
{
DispatchOptions
(
self
.
flags
(
)
|
FLAG
)
}
else
{
DispatchOptions
(
self
.
flags
(
)
&
!
FLAG
)
}
}
#
[
inline
]
fn
flags
(
self
)
-
>
u32
{
self
.
0
}
}
pub
trait
Task
{
fn
run
(
&
self
)
;
fn
done
(
&
self
)
-
>
Result
<
(
)
nsresult
>
;
}
pub
struct
TaskRunnable
{
name
:
&
'
static
str
task
:
Box
<
dyn
Task
+
Send
+
Sync
>
}
impl
TaskRunnable
{
pub
fn
new
(
name
:
&
'
static
str
task
:
Box
<
dyn
Task
+
Send
+
Sync
>
)
-
>
Result
<
TaskRunnable
nsresult
>
{
Ok
(
TaskRunnable
{
name
task
}
)
}
pub
fn
dispatch
(
self
target
:
&
nsIEventTarget
)
-
>
Result
<
(
)
nsresult
>
{
self
.
dispatch_with_options
(
target
DispatchOptions
:
:
default
(
)
)
}
pub
fn
dispatch_with_options
(
self
target
:
&
nsIEventTarget
options
:
DispatchOptions
)
-
>
Result
<
(
)
nsresult
>
{
let
task
=
self
.
task
;
let
handle
=
TaskBuilder
:
:
new
(
self
.
name
async
move
{
task
.
run
(
)
;
task
}
)
.
options
(
options
)
.
spawn_onto
(
target
)
;
spawn_local
(
self
.
name
async
move
{
let
task
=
handle
.
await
;
let
_
=
task
.
done
(
)
;
}
)
.
detach
(
)
;
Ok
(
(
)
)
}
pub
fn
dispatch_background_task_with_options
(
self
options
:
DispatchOptions
)
-
>
Result
<
(
)
nsresult
>
{
let
task
=
self
.
task
;
let
handle
=
TaskBuilder
:
:
new
(
self
.
name
async
move
{
task
.
run
(
)
;
task
}
)
.
options
(
options
)
.
spawn
(
)
;
spawn_local
(
self
.
name
async
move
{
let
task
=
handle
.
await
;
let
_
=
task
.
done
(
)
;
}
)
.
detach
(
)
;
Ok
(
(
)
)
}
}
pub
type
ThreadPtrHandle
<
T
>
=
RefPtr
<
ThreadPtrHolder
<
T
>
>
;
pub
struct
ThreadPtrHolder
<
T
:
XpCom
+
'
static
>
{
ptr
:
*
const
T
marker
:
PhantomData
<
T
>
name
:
&
'
static
CStr
owning_thread
:
RefPtr
<
nsIThread
>
refcnt
:
AtomicRefcnt
}
unsafe
impl
<
T
:
XpCom
+
'
static
>
Send
for
ThreadPtrHolder
<
T
>
{
}
unsafe
impl
<
T
:
XpCom
+
'
static
>
Sync
for
ThreadPtrHolder
<
T
>
{
}
unsafe
impl
<
T
:
XpCom
+
'
static
>
RefCounted
for
ThreadPtrHolder
<
T
>
{
unsafe
fn
addref
(
&
self
)
{
self
.
refcnt
.
inc
(
)
;
}
unsafe
fn
release
(
&
self
)
{
let
rc
=
self
.
refcnt
.
dec
(
)
;
if
rc
=
=
0
{
if
!
self
.
ptr
.
is_null
(
)
{
if
is_on_current_thread
(
&
self
.
owning_thread
)
{
(
*
self
.
ptr
)
.
release
(
)
}
else
{
NS_ProxyReleaseISupports
(
self
.
name
.
as_ptr
(
)
self
.
owning_thread
.
coerce
(
)
self
.
ptr
as
*
const
T
as
*
const
nsISupports
false
)
;
}
}
Box
:
:
from_raw
(
self
as
*
const
Self
as
*
mut
Self
)
;
}
}
}
impl
<
T
:
XpCom
+
'
static
>
ThreadPtrHolder
<
T
>
{
pub
fn
new
(
name
:
&
'
static
CStr
ptr
:
RefPtr
<
T
>
)
-
>
Result
<
RefPtr
<
Self
>
nsresult
>
{
let
owning_thread
=
get_current_thread
(
)
?
;
let
raw
:
*
const
T
=
&
*
ptr
;
mem
:
:
forget
(
ptr
)
;
unsafe
{
let
boxed
=
Box
:
:
new
(
ThreadPtrHolder
{
name
ptr
:
raw
marker
:
PhantomData
owning_thread
refcnt
:
AtomicRefcnt
:
:
new
(
)
}
)
;
Ok
(
RefPtr
:
:
from_raw
(
Box
:
:
into_raw
(
boxed
)
)
.
unwrap
(
)
)
}
}
pub
fn
owning_thread
(
&
self
)
-
>
&
nsIThread
{
&
self
.
owning_thread
}
pub
fn
get
(
&
self
)
-
>
Option
<
&
T
>
{
if
is_on_current_thread
(
&
self
.
owning_thread
)
&
&
!
self
.
ptr
.
is_null
(
)
{
unsafe
{
Some
(
&
*
self
.
ptr
)
}
}
else
{
None
}
}
}
