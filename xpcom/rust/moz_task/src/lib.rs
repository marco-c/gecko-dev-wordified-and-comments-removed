extern
crate
cstr
;
extern
crate
futures_task
;
extern
crate
libc
;
extern
crate
nserror
;
extern
crate
nsstring
;
extern
crate
thiserror
;
extern
crate
xpcom
;
mod
event_loop
;
mod
executor
;
pub
use
executor
:
:
spawn_current_thread
;
pub
mod
gtest_only
{
pub
use
event_loop
:
:
spin_event_loop_until
;
}
use
nserror
:
:
{
nsresult
NS_OK
}
;
use
nsstring
:
:
{
nsACString
nsCString
}
;
use
std
:
:
{
ffi
:
:
CStr
marker
:
:
PhantomData
mem
ptr
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
}
;
use
xpcom
:
:
{
getter_addrefs
interfaces
:
:
{
nsIEventTarget
nsIRunnable
nsISerialEventTarget
nsISupports
nsIThread
}
xpcom
xpcom_method
AtomicRefcnt
RefCounted
RefPtr
XpCom
}
;
extern
"
C
"
{
fn
NS_GetCurrentThreadEventTarget
(
result
:
*
mut
*
const
nsIThread
)
-
>
nsresult
;
fn
NS_GetMainThreadEventTarget
(
result
:
*
mut
*
const
nsIThread
)
-
>
nsresult
;
fn
NS_IsMainThread
(
)
-
>
bool
;
fn
NS_NewNamedThreadWithDefaultStackSize
(
name
:
*
const
nsACString
result
:
*
mut
*
const
nsIThread
event
:
*
const
nsIRunnable
)
-
>
nsresult
;
fn
NS_IsCurrentThread
(
thread
:
*
const
nsIEventTarget
)
-
>
bool
;
fn
NS_ProxyReleaseISupports
(
name
:
*
const
libc
:
:
c_char
target
:
*
const
nsIEventTarget
doomed
:
*
const
nsISupports
always_proxy
:
bool
)
;
fn
NS_CreateBackgroundTaskQueue
(
name
:
*
const
libc
:
:
c_char
target
:
*
mut
*
const
nsISerialEventTarget
)
-
>
nsresult
;
fn
NS_DispatchBackgroundTask
(
event
:
*
const
nsIRunnable
flags
:
u32
)
-
>
nsresult
;
}
pub
fn
get_current_thread
(
)
-
>
Result
<
RefPtr
<
nsIThread
>
nsresult
>
{
getter_addrefs
(
|
p
|
unsafe
{
NS_GetCurrentThreadEventTarget
(
p
)
}
)
}
pub
fn
get_main_thread
(
)
-
>
Result
<
RefPtr
<
nsIThread
>
nsresult
>
{
getter_addrefs
(
|
p
|
unsafe
{
NS_GetMainThreadEventTarget
(
p
)
}
)
}
pub
fn
is_main_thread
(
)
-
>
bool
{
unsafe
{
NS_IsMainThread
(
)
}
}
pub
fn
create_thread
(
name
:
&
str
)
-
>
Result
<
RefPtr
<
nsIThread
>
nsresult
>
{
getter_addrefs
(
|
p
|
unsafe
{
NS_NewNamedThreadWithDefaultStackSize
(
&
*
nsCString
:
:
from
(
name
)
p
ptr
:
:
null
(
)
)
}
)
}
pub
fn
is_current_thread
(
thread
:
&
nsIThread
)
-
>
bool
{
unsafe
{
NS_IsCurrentThread
(
thread
.
coerce
(
)
)
}
}
pub
fn
create_background_task_queue
(
name
:
&
'
static
CStr
)
-
>
Result
<
RefPtr
<
nsISerialEventTarget
>
nsresult
>
{
getter_addrefs
(
|
p
|
unsafe
{
NS_CreateBackgroundTaskQueue
(
name
.
as_ptr
(
)
p
)
}
)
}
#
[
inline
]
pub
unsafe
fn
dispatch
(
runnable
:
&
nsIRunnable
target
:
&
nsIEventTarget
)
-
>
Result
<
(
)
nsresult
>
{
dispatch_with_options
(
runnable
target
DispatchOptions
:
:
default
(
)
)
}
pub
unsafe
fn
dispatch_with_options
(
runnable
:
&
nsIRunnable
target
:
&
nsIEventTarget
options
:
DispatchOptions
)
-
>
Result
<
(
)
nsresult
>
{
target
.
DispatchFromScript
(
runnable
options
.
flags
(
)
)
.
to_result
(
)
}
#
[
inline
]
pub
fn
dispatch_background_task
(
runnable
:
RefPtr
<
nsIRunnable
>
)
-
>
Result
<
(
)
nsresult
>
{
dispatch_background_task_with_options
(
runnable
DispatchOptions
:
:
default
(
)
)
}
pub
fn
dispatch_background_task_with_options
(
runnable
:
RefPtr
<
nsIRunnable
>
options
:
DispatchOptions
)
-
>
Result
<
(
)
nsresult
>
{
unsafe
{
NS_DispatchBackgroundTask
(
runnable
.
coerce
(
)
options
.
flags
(
)
)
}
.
to_result
(
)
}
#
[
derive
(
Copy
Clone
Debug
Eq
Hash
PartialEq
)
]
pub
struct
DispatchOptions
(
u32
)
;
impl
Default
for
DispatchOptions
{
#
[
inline
]
fn
default
(
)
-
>
Self
{
DispatchOptions
(
nsIEventTarget
:
:
DISPATCH_NORMAL
as
u32
)
}
}
impl
DispatchOptions
{
#
[
inline
]
pub
fn
new
(
)
-
>
Self
{
DispatchOptions
:
:
default
(
)
}
#
[
inline
]
pub
fn
may_block
(
self
may_block
:
bool
)
-
>
DispatchOptions
{
const
FLAG
:
u32
=
nsIEventTarget
:
:
DISPATCH_EVENT_MAY_BLOCK
as
u32
;
if
may_block
{
DispatchOptions
(
self
.
flags
(
)
|
FLAG
)
}
else
{
DispatchOptions
(
self
.
flags
(
)
&
!
FLAG
)
}
}
#
[
inline
]
fn
flags
(
self
)
-
>
u32
{
self
.
0
}
}
pub
trait
Task
{
fn
run
(
&
self
)
;
fn
done
(
&
self
)
-
>
Result
<
(
)
nsresult
>
;
}
#
[
derive
(
xpcom
)
]
#
[
xpimplements
(
nsIRunnable
nsINamed
)
]
#
[
refcnt
=
"
atomic
"
]
pub
struct
InitTaskRunnable
{
name
:
&
'
static
str
original_thread
:
RefPtr
<
nsIThread
>
task
:
Box
<
dyn
Task
+
Send
+
Sync
>
has_run
:
AtomicBool
}
impl
TaskRunnable
{
pub
fn
new
(
name
:
&
'
static
str
task
:
Box
<
dyn
Task
+
Send
+
Sync
>
)
-
>
Result
<
RefPtr
<
TaskRunnable
>
nsresult
>
{
Ok
(
TaskRunnable
:
:
allocate
(
InitTaskRunnable
{
name
original_thread
:
get_current_thread
(
)
?
task
has_run
:
AtomicBool
:
:
new
(
false
)
}
)
)
}
#
[
inline
]
pub
fn
dispatch
(
this
:
RefPtr
<
Self
>
target
:
&
nsIEventTarget
)
-
>
Result
<
(
)
nsresult
>
{
Self
:
:
dispatch_with_options
(
this
target
DispatchOptions
:
:
default
(
)
)
}
pub
fn
dispatch_with_options
(
this
:
RefPtr
<
Self
>
target
:
&
nsIEventTarget
options
:
DispatchOptions
)
-
>
Result
<
(
)
nsresult
>
{
unsafe
{
target
.
DispatchFromScript
(
this
.
coerce
(
)
options
.
flags
(
)
)
}
.
to_result
(
)
}
xpcom_method
!
(
run
=
>
Run
(
)
)
;
fn
run
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
match
self
.
has_run
.
compare_exchange
(
false
true
Ordering
:
:
AcqRel
Ordering
:
:
Acquire
)
{
Ok
(
_
)
=
>
{
self
.
task
.
run
(
)
;
Self
:
:
dispatch
(
RefPtr
:
:
new
(
self
)
&
self
.
original_thread
)
}
Err
(
_
)
=
>
{
assert
!
(
is_current_thread
(
&
self
.
original_thread
)
)
;
self
.
task
.
done
(
)
}
}
}
xpcom_method
!
(
get_name
=
>
GetName
(
)
-
>
nsACString
)
;
fn
get_name
(
&
self
)
-
>
Result
<
nsCString
nsresult
>
{
Ok
(
nsCString
:
:
from
(
self
.
name
)
)
}
}
pub
type
ThreadPtrHandle
<
T
>
=
RefPtr
<
ThreadPtrHolder
<
T
>
>
;
pub
struct
ThreadPtrHolder
<
T
:
XpCom
+
'
static
>
{
ptr
:
*
const
T
marker
:
PhantomData
<
T
>
name
:
&
'
static
CStr
owning_thread
:
RefPtr
<
nsIThread
>
refcnt
:
AtomicRefcnt
}
unsafe
impl
<
T
:
XpCom
+
'
static
>
Send
for
ThreadPtrHolder
<
T
>
{
}
unsafe
impl
<
T
:
XpCom
+
'
static
>
Sync
for
ThreadPtrHolder
<
T
>
{
}
unsafe
impl
<
T
:
XpCom
+
'
static
>
RefCounted
for
ThreadPtrHolder
<
T
>
{
unsafe
fn
addref
(
&
self
)
{
self
.
refcnt
.
inc
(
)
;
}
unsafe
fn
release
(
&
self
)
{
let
rc
=
self
.
refcnt
.
dec
(
)
;
if
rc
=
=
0
{
if
!
self
.
ptr
.
is_null
(
)
{
if
is_current_thread
(
&
self
.
owning_thread
)
{
(
*
self
.
ptr
)
.
release
(
)
}
else
{
NS_ProxyReleaseISupports
(
self
.
name
.
as_ptr
(
)
self
.
owning_thread
.
coerce
(
)
self
.
ptr
as
*
const
T
as
*
const
nsISupports
false
)
;
}
}
Box
:
:
from_raw
(
self
as
*
const
Self
as
*
mut
Self
)
;
}
}
}
impl
<
T
:
XpCom
+
'
static
>
ThreadPtrHolder
<
T
>
{
pub
fn
new
(
name
:
&
'
static
CStr
ptr
:
RefPtr
<
T
>
)
-
>
Result
<
RefPtr
<
Self
>
nsresult
>
{
let
owning_thread
=
get_current_thread
(
)
?
;
let
raw
:
*
const
T
=
&
*
ptr
;
mem
:
:
forget
(
ptr
)
;
unsafe
{
let
boxed
=
Box
:
:
new
(
ThreadPtrHolder
{
name
ptr
:
raw
marker
:
PhantomData
owning_thread
refcnt
:
AtomicRefcnt
:
:
new
(
)
}
)
;
Ok
(
RefPtr
:
:
from_raw
(
Box
:
:
into_raw
(
boxed
)
)
.
unwrap
(
)
)
}
}
pub
fn
owning_thread
(
&
self
)
-
>
&
nsIThread
{
&
self
.
owning_thread
}
pub
fn
get
(
&
self
)
-
>
Option
<
&
T
>
{
if
is_current_thread
(
&
self
.
owning_thread
)
&
&
!
self
.
ptr
.
is_null
(
)
{
unsafe
{
Some
(
&
*
self
.
ptr
)
}
}
else
{
None
}
}
}
