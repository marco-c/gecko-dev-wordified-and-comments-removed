extern
crate
nsstring
;
use
cstr
:
:
cstr
;
use
nserror
:
:
{
nsresult
NS_ERROR_SERVICE_NOT_AVAILABLE
NS_ERROR_UNEXPECTED
NS_OK
}
;
use
nsstring
:
:
*
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
future
:
:
Future
;
use
xpcom
:
:
{
interfaces
:
:
nsIThreadManager
xpcom
xpcom_method
}
;
#
[
xpcom
(
implement
(
nsINestedEventLoopCondition
)
nonatomic
)
]
struct
FutureCompleteCondition
<
T
:
'
static
>
{
value
:
RefCell
<
Option
<
T
>
>
}
impl
<
T
:
'
static
>
FutureCompleteCondition
<
T
>
{
xpcom_method
!
(
is_done
=
>
IsDone
(
)
-
>
bool
)
;
fn
is_done
(
&
self
)
-
>
Result
<
bool
nsresult
>
{
Ok
(
self
.
value
.
borrow
(
)
.
is_some
(
)
)
}
}
pub
unsafe
fn
spin_event_loop_until
<
F
>
(
reason
:
&
'
static
str
future
:
F
)
-
>
Result
<
F
:
:
Output
nsresult
>
where
F
:
Future
+
'
static
F
:
:
Output
:
'
static
{
let
thread_manager
=
xpcom
:
:
get_service
:
:
<
nsIThreadManager
>
(
cstr
!
(
"
mozilla
.
org
/
thread
-
manager
;
1
"
)
)
.
ok_or
(
NS_ERROR_SERVICE_NOT_AVAILABLE
)
?
;
let
cond
=
FutureCompleteCondition
:
:
<
F
:
:
Output
>
:
:
allocate
(
InitFutureCompleteCondition
{
value
:
RefCell
:
:
new
(
None
)
}
)
;
let
cond2
=
cond
.
clone
(
)
;
crate
:
:
spawn_local
(
reason
async
move
{
let
rv
=
future
.
await
;
*
cond2
.
value
.
borrow_mut
(
)
=
Some
(
rv
)
;
}
)
.
detach
(
)
;
thread_manager
.
SpinEventLoopUntil
(
&
*
nsCStr
:
:
from
(
reason
)
cond
.
coerce
(
)
)
.
to_result
(
)
?
;
let
rv
=
cond
.
value
.
borrow_mut
(
)
.
take
(
)
;
rv
.
ok_or
(
NS_ERROR_UNEXPECTED
)
}
