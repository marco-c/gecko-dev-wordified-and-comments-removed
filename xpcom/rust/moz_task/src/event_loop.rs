extern
crate
nsstring
;
use
cstr
:
:
cstr
;
use
nserror
:
:
{
nsresult
NS_ERROR_SERVICE_NOT_AVAILABLE
NS_OK
}
;
use
nsstring
:
:
*
;
use
std
:
:
cell
:
:
UnsafeCell
;
use
xpcom
:
:
{
interfaces
:
:
nsIThreadManager
xpcom
xpcom_method
}
;
type
IsDoneClosure
=
dyn
FnMut
(
)
-
>
bool
+
'
static
;
#
[
derive
(
xpcom
)
]
#
[
xpimplements
(
nsINestedEventLoopCondition
)
]
#
[
refcnt
=
"
atomic
"
]
struct
InitEventLoopCondition
{
closure
:
UnsafeCell
<
Box
<
IsDoneClosure
>
>
}
impl
EventLoopCondition
{
xpcom_method
!
(
is_done
=
>
IsDone
(
)
-
>
bool
)
;
fn
is_done
(
&
self
)
-
>
Result
<
bool
nsresult
>
{
unsafe
{
Ok
(
(
&
mut
*
self
.
closure
.
get
(
)
)
(
)
)
}
}
}
pub
unsafe
fn
spin_event_loop_until
<
P
>
(
pred
:
P
)
-
>
Result
<
(
)
nsresult
>
where
P
:
FnMut
(
)
-
>
bool
+
'
static
{
let
closure
=
Box
:
:
new
(
pred
)
as
Box
<
IsDoneClosure
>
;
let
cond
=
EventLoopCondition
:
:
allocate
(
InitEventLoopCondition
{
closure
:
UnsafeCell
:
:
new
(
closure
)
}
)
;
let
thread_manager
=
xpcom
:
:
get_service
:
:
<
nsIThreadManager
>
(
cstr
!
(
"
mozilla
.
org
/
thread
-
manager
;
1
"
)
)
.
ok_or
(
NS_ERROR_SERVICE_NOT_AVAILABLE
)
?
;
thread_manager
.
SpinEventLoopUntil
(
&
*
nsCStr
:
:
from
(
"
event_loop
.
rs
:
Rust
is
spinning
the
event
loop
.
"
)
cond
.
coerce
(
)
)
.
to_result
(
)
}
