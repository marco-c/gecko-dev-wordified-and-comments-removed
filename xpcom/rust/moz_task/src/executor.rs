use
crate
:
:
{
get_current_thread
DispatchOptions
RunnableBuilder
}
;
use
std
:
:
{
cell
:
:
Cell
fmt
:
:
Debug
future
:
:
Future
pin
:
:
Pin
ptr
sync
:
:
Arc
task
:
:
{
Context
Poll
}
}
;
use
xpcom
:
:
interfaces
:
:
{
nsIEventTarget
nsIRunnablePriority
}
;
use
xpcom
:
:
RefPtr
;
#
[
derive
(
Debug
)
]
#
[
must_use
=
"
tasks
get
canceled
when
dropped
use
.
detach
(
)
to
run
them
in
the
background
"
]
pub
struct
AsyncTask
<
T
>
{
task
:
async_task
:
:
FallibleTask
<
T
>
}
impl
<
T
>
AsyncTask
<
T
>
{
fn
new
(
task
:
async_task
:
:
Task
<
T
>
)
-
>
Self
{
AsyncTask
{
task
:
task
.
fallible
(
)
}
}
pub
fn
detach
(
self
)
{
self
.
task
.
detach
(
)
}
pub
async
fn
cancel
(
self
)
-
>
Option
<
T
>
{
self
.
task
.
cancel
(
)
.
await
}
}
impl
<
T
>
Future
for
AsyncTask
<
T
>
{
type
Output
=
T
;
fn
poll
(
mut
self
:
Pin
<
&
mut
Self
>
cx
:
&
mut
Context
<
'
_
>
)
-
>
Poll
<
Self
:
:
Output
>
{
match
Pin
:
:
new
(
&
mut
self
.
task
)
.
poll
(
cx
)
{
Poll
:
:
Ready
(
Some
(
t
)
)
=
>
Poll
:
:
Ready
(
t
)
Poll
:
:
Ready
(
None
)
|
Poll
:
:
Pending
=
>
Poll
:
:
Pending
}
}
}
enum
SpawnTarget
{
BackgroundTask
EventTarget
(
RefPtr
<
nsIEventTarget
>
)
}
unsafe
impl
Send
for
SpawnTarget
{
}
unsafe
impl
Sync
for
SpawnTarget
{
}
struct
TaskSpawnConfig
{
name
:
&
'
static
str
priority
:
u32
options
:
DispatchOptions
target
:
SpawnTarget
}
thread_local
!
{
/
/
/
Raw
pointer
to
the
TaskSpawnConfig
for
the
currently
polling
task
.
Used
/
/
/
to
detect
scheduling
callbacks
for
a
runnable
while
it
is
polled
to
set
/
/
/
DISPATCH_AT_END
on
the
notification
.
static
POLLING_TASK
:
Cell
<
*
const
TaskSpawnConfig
>
=
Cell
:
:
new
(
ptr
:
:
null
(
)
)
;
}
fn
schedule
(
config
:
Arc
<
TaskSpawnConfig
>
runnable
:
async_task
:
:
Runnable
)
{
let
currently_polling
=
POLLING_TASK
.
with
(
|
t
|
t
.
get
(
)
=
=
Arc
:
:
as_ptr
(
&
config
)
)
;
let
options
=
unsafe
{
config
.
options
.
at_end
(
currently_polling
)
}
;
let
config2
=
config
.
clone
(
)
;
let
builder
=
RunnableBuilder
:
:
new
(
config
.
name
move
|
|
{
POLLING_TASK
.
with
(
|
t
|
{
let
prev
=
t
.
get
(
)
;
t
.
set
(
Arc
:
:
as_ptr
(
&
config2
)
)
;
runnable
.
run
(
)
;
t
.
set
(
prev
)
;
}
)
;
}
)
.
priority
(
config
.
priority
)
.
options
(
options
)
;
let
rv
=
match
&
config
.
target
{
SpawnTarget
:
:
BackgroundTask
=
>
builder
.
dispatch_background_task
(
)
SpawnTarget
:
:
EventTarget
(
target
)
=
>
builder
.
dispatch
(
&
*
target
)
}
;
if
let
Err
(
err
)
=
rv
{
log
:
:
warn
!
(
"
dispatch
for
spawned
task
'
{
}
'
failed
:
{
:
?
}
"
config
.
name
err
)
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
TaskBuilder
<
F
>
{
name
:
&
'
static
str
future
:
F
priority
:
u32
options
:
DispatchOptions
}
impl
<
F
>
TaskBuilder
<
F
>
{
pub
fn
new
(
name
:
&
'
static
str
future
:
F
)
-
>
TaskBuilder
<
F
>
{
TaskBuilder
{
name
future
priority
:
nsIRunnablePriority
:
:
PRIORITY_NORMAL
options
:
DispatchOptions
:
:
default
(
)
}
}
pub
fn
priority
(
mut
self
priority
:
u32
)
-
>
Self
{
self
.
priority
=
priority
;
self
}
pub
fn
options
(
mut
self
options
:
DispatchOptions
)
-
>
Self
{
self
.
options
=
options
;
self
}
pub
fn
may_block
(
mut
self
may_block
:
bool
)
-
>
Self
{
self
.
options
=
self
.
options
.
may_block
(
may_block
)
;
self
}
}
impl
<
F
>
TaskBuilder
<
F
>
where
F
:
Future
+
Send
+
'
static
F
:
:
Output
:
Send
+
'
static
{
pub
fn
spawn
(
self
)
-
>
AsyncTask
<
F
:
:
Output
>
{
let
config
=
Arc
:
:
new
(
TaskSpawnConfig
{
name
:
self
.
name
priority
:
self
.
priority
options
:
self
.
options
target
:
SpawnTarget
:
:
BackgroundTask
}
)
;
let
(
runnable
task
)
=
async_task
:
:
spawn
(
self
.
future
move
|
runnable
|
{
schedule
(
config
.
clone
(
)
runnable
)
}
)
;
runnable
.
schedule
(
)
;
AsyncTask
:
:
new
(
task
)
}
pub
fn
spawn_onto
(
self
target
:
&
nsIEventTarget
)
-
>
AsyncTask
<
F
:
:
Output
>
{
let
config
=
Arc
:
:
new
(
TaskSpawnConfig
{
name
:
self
.
name
priority
:
self
.
priority
options
:
self
.
options
target
:
SpawnTarget
:
:
EventTarget
(
RefPtr
:
:
new
(
target
)
)
}
)
;
let
(
runnable
task
)
=
async_task
:
:
spawn
(
self
.
future
move
|
runnable
|
{
schedule
(
config
.
clone
(
)
runnable
)
}
)
;
runnable
.
schedule
(
)
;
AsyncTask
:
:
new
(
task
)
}
}
impl
<
F
>
TaskBuilder
<
F
>
where
F
:
Future
+
'
static
F
:
:
Output
:
'
static
{
pub
fn
spawn_local
(
self
)
-
>
AsyncTask
<
F
:
:
Output
>
{
let
current_thread
=
get_current_thread
(
)
.
expect
(
"
cannot
get
current
thread
"
)
;
let
config
=
Arc
:
:
new
(
TaskSpawnConfig
{
name
:
self
.
name
priority
:
self
.
priority
options
:
self
.
options
target
:
SpawnTarget
:
:
EventTarget
(
RefPtr
:
:
new
(
current_thread
.
coerce
(
)
)
)
}
)
;
let
(
runnable
task
)
=
async_task
:
:
spawn_local
(
self
.
future
move
|
runnable
|
{
schedule
(
config
.
clone
(
)
runnable
)
}
)
;
runnable
.
schedule
(
)
;
AsyncTask
:
:
new
(
task
)
}
}
pub
fn
spawn
<
F
>
(
name
:
&
'
static
str
future
:
F
)
-
>
AsyncTask
<
F
:
:
Output
>
where
F
:
Future
+
Send
+
'
static
F
:
:
Output
:
Send
+
'
static
{
TaskBuilder
:
:
new
(
name
future
)
.
spawn
(
)
}
pub
fn
spawn_blocking
<
F
>
(
name
:
&
'
static
str
future
:
F
)
-
>
AsyncTask
<
F
:
:
Output
>
where
F
:
Future
+
Send
+
'
static
F
:
:
Output
:
Send
+
'
static
{
TaskBuilder
:
:
new
(
name
future
)
.
may_block
(
true
)
.
spawn
(
)
}
pub
fn
spawn_local
<
F
>
(
name
:
&
'
static
str
future
:
F
)
-
>
AsyncTask
<
F
:
:
Output
>
where
F
:
Future
+
'
static
F
:
:
Output
:
'
static
{
TaskBuilder
:
:
new
(
name
future
)
.
spawn_local
(
)
}
pub
fn
spawn_onto
<
F
>
(
name
:
&
'
static
str
target
:
&
nsIEventTarget
future
:
F
)
-
>
AsyncTask
<
F
:
:
Output
>
where
F
:
Future
+
Send
+
'
static
F
:
:
Output
:
Send
+
'
static
{
TaskBuilder
:
:
new
(
name
future
)
.
spawn_onto
(
target
)
}
pub
fn
spawn_onto_blocking
<
F
>
(
name
:
&
'
static
str
target
:
&
nsIEventTarget
future
:
F
)
-
>
AsyncTask
<
F
:
:
Output
>
where
F
:
Future
+
Send
+
'
static
F
:
:
Output
:
Send
+
'
static
{
TaskBuilder
:
:
new
(
name
future
)
.
may_block
(
true
)
.
spawn_onto
(
target
)
}
