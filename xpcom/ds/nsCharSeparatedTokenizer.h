#
ifndef
__nsCharSeparatedTokenizer_h
#
define
__nsCharSeparatedTokenizer_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RangedPtr
.
h
"
#
include
"
nsDependentSubstring
.
h
"
#
include
"
nsCRTGlue
.
h
"
template
<
typename
TDependentSubstringType
bool
IsWhitespace
(
char16_t
)
>
class
nsTCharSeparatedTokenizer
{
using
CharType
=
typename
TDependentSubstringType
:
:
char_type
;
using
SubstringType
=
typename
TDependentSubstringType
:
:
substring_type
;
public
:
enum
{
SEPARATOR_OPTIONAL
=
1
}
;
using
DependentSubstringType
=
TDependentSubstringType
;
nsTCharSeparatedTokenizer
(
const
SubstringType
&
aSource
CharType
aSeparatorChar
uint32_t
aFlags
=
0
)
:
mIter
(
aSource
.
Data
(
)
aSource
.
Length
(
)
)
mEnd
(
aSource
.
Data
(
)
+
aSource
.
Length
(
)
aSource
.
Data
(
)
aSource
.
Length
(
)
)
mSeparatorChar
(
aSeparatorChar
)
mWhitespaceBeforeFirstToken
(
false
)
mWhitespaceAfterCurrentToken
(
false
)
mSeparatorAfterCurrentToken
(
false
)
mSeparatorOptional
(
aFlags
&
SEPARATOR_OPTIONAL
)
{
while
(
mIter
<
mEnd
&
&
IsWhitespace
(
*
mIter
)
)
{
mWhitespaceBeforeFirstToken
=
true
;
+
+
mIter
;
}
}
bool
hasMoreTokens
(
)
const
{
MOZ_ASSERT
(
mIter
=
=
mEnd
|
|
!
IsWhitespace
(
*
mIter
)
"
Should
be
at
beginning
of
token
if
there
is
one
"
)
;
return
mIter
<
mEnd
;
}
bool
whitespaceBeforeFirstToken
(
)
const
{
return
mWhitespaceBeforeFirstToken
;
}
bool
separatorAfterCurrentToken
(
)
const
{
return
mSeparatorAfterCurrentToken
;
}
bool
whitespaceAfterCurrentToken
(
)
const
{
return
mWhitespaceAfterCurrentToken
;
}
const
DependentSubstringType
nextToken
(
)
{
mozilla
:
:
RangedPtr
<
const
CharType
>
tokenStart
=
mIter
;
mozilla
:
:
RangedPtr
<
const
CharType
>
tokenEnd
=
mIter
;
MOZ_ASSERT
(
mIter
=
=
mEnd
|
|
!
IsWhitespace
(
*
mIter
)
"
Should
be
at
beginning
of
token
if
there
is
one
"
)
;
while
(
mIter
<
mEnd
&
&
*
mIter
!
=
mSeparatorChar
)
{
while
(
mIter
<
mEnd
&
&
!
IsWhitespace
(
*
mIter
)
&
&
*
mIter
!
=
mSeparatorChar
)
{
+
+
mIter
;
}
tokenEnd
=
mIter
;
mWhitespaceAfterCurrentToken
=
false
;
while
(
mIter
<
mEnd
&
&
IsWhitespace
(
*
mIter
)
)
{
mWhitespaceAfterCurrentToken
=
true
;
+
+
mIter
;
}
if
(
mSeparatorOptional
)
{
break
;
}
}
mSeparatorAfterCurrentToken
=
(
mIter
!
=
mEnd
&
&
*
mIter
=
=
mSeparatorChar
)
;
MOZ_ASSERT
(
mSeparatorOptional
|
|
(
mSeparatorAfterCurrentToken
=
=
(
mIter
<
mEnd
)
)
"
If
we
require
a
separator
and
haven
'
t
hit
the
end
of
"
"
our
string
then
we
shouldn
'
t
have
left
the
loop
"
"
unless
we
hit
a
separator
"
)
;
if
(
mSeparatorAfterCurrentToken
)
{
+
+
mIter
;
while
(
mIter
<
mEnd
&
&
IsWhitespace
(
*
mIter
)
)
{
mWhitespaceAfterCurrentToken
=
true
;
+
+
mIter
;
}
}
return
Substring
(
tokenStart
.
get
(
)
tokenEnd
.
get
(
)
)
;
}
auto
ToRange
(
)
const
;
private
:
mozilla
:
:
RangedPtr
<
const
CharType
>
mIter
;
const
mozilla
:
:
RangedPtr
<
const
CharType
>
mEnd
;
const
CharType
mSeparatorChar
;
bool
mWhitespaceBeforeFirstToken
;
bool
mWhitespaceAfterCurrentToken
;
bool
mSeparatorAfterCurrentToken
;
bool
mSeparatorOptional
;
}
;
constexpr
bool
NS_TokenizerIgnoreNothing
(
char16_t
)
{
return
false
;
}
template
<
bool
IsWhitespace
(
char16_t
)
typename
CharType
>
using
nsTCharSeparatedTokenizerTemplate
=
nsTCharSeparatedTokenizer
<
nsTDependentSubstring
<
CharType
>
IsWhitespace
>
;
template
<
bool
IsWhitespace
(
char16_t
)
>
using
nsCharSeparatedTokenizerTemplate
=
nsTCharSeparatedTokenizerTemplate
<
IsWhitespace
char16_t
>
;
using
nsCharSeparatedTokenizer
=
nsCharSeparatedTokenizerTemplate
<
NS_IsAsciiWhitespace
>
;
template
<
bool
IsWhitespace
(
char16_t
)
>
using
nsCCharSeparatedTokenizerTemplate
=
nsTCharSeparatedTokenizerTemplate
<
IsWhitespace
char
>
;
using
nsCCharSeparatedTokenizer
=
nsCCharSeparatedTokenizerTemplate
<
NS_IsAsciiWhitespace
>
;
template
<
typename
Tokenizer
>
class
nsTokenizedRange
{
public
:
using
DependentSubstringType
=
typename
Tokenizer
:
:
DependentSubstringType
;
explicit
nsTokenizedRange
(
Tokenizer
&
&
aTokenizer
)
:
mTokenizer
(
std
:
:
move
(
aTokenizer
)
)
{
}
struct
EndSentinel
{
}
;
struct
Iterator
{
explicit
Iterator
(
const
Tokenizer
&
aTokenizer
)
:
mTokenizer
(
aTokenizer
)
{
Next
(
)
;
}
const
DependentSubstringType
&
operator
*
(
)
const
{
return
*
mCurrentToken
;
}
Iterator
&
operator
+
+
(
)
{
Next
(
)
;
return
*
this
;
}
bool
operator
=
=
(
const
EndSentinel
&
)
const
{
return
mCurrentToken
.
isNothing
(
)
;
}
bool
operator
!
=
(
const
EndSentinel
&
)
const
{
return
mCurrentToken
.
isSome
(
)
;
}
private
:
void
Next
(
)
{
mCurrentToken
.
reset
(
)
;
if
(
mTokenizer
.
hasMoreTokens
(
)
)
{
mCurrentToken
.
emplace
(
mTokenizer
.
nextToken
(
)
)
;
}
}
Tokenizer
mTokenizer
;
mozilla
:
:
Maybe
<
DependentSubstringType
>
mCurrentToken
;
}
;
auto
begin
(
)
const
{
return
Iterator
{
mTokenizer
}
;
}
auto
end
(
)
const
{
return
EndSentinel
{
}
;
}
private
:
const
Tokenizer
mTokenizer
;
}
;
template
<
typename
TDependentSubstringType
bool
IsWhitespace
(
char16_t
)
>
auto
nsTCharSeparatedTokenizer
<
TDependentSubstringType
IsWhitespace
>
:
:
ToRange
(
)
const
{
return
nsTokenizedRange
{
nsTCharSeparatedTokenizer
{
*
this
}
}
;
}
#
endif
