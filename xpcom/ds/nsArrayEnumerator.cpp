#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsArrayEnumerator
.
h
"
#
include
"
nsIArray
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
class
nsSimpleArrayEnumerator
final
:
public
nsISimpleEnumerator
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISIMPLEENUMERATOR
explicit
nsSimpleArrayEnumerator
(
nsIArray
*
aValueArray
)
:
mValueArray
(
aValueArray
)
mIndex
(
0
)
{
}
private
:
~
nsSimpleArrayEnumerator
(
)
=
default
;
protected
:
nsCOMPtr
<
nsIArray
>
mValueArray
;
uint32_t
mIndex
;
}
;
NS_IMPL_ISUPPORTS
(
nsSimpleArrayEnumerator
nsISimpleEnumerator
)
NS_IMETHODIMP
nsSimpleArrayEnumerator
:
:
HasMoreElements
(
bool
*
aResult
)
{
MOZ_ASSERT
(
aResult
!
=
0
"
null
ptr
"
)
;
if
(
!
aResult
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
!
mValueArray
)
{
*
aResult
=
false
;
return
NS_OK
;
}
uint32_t
cnt
;
nsresult
rv
=
mValueArray
-
>
GetLength
(
&
cnt
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aResult
=
(
mIndex
<
cnt
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSimpleArrayEnumerator
:
:
GetNext
(
nsISupports
*
*
aResult
)
{
MOZ_ASSERT
(
aResult
!
=
0
"
null
ptr
"
)
;
if
(
!
aResult
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
!
mValueArray
)
{
*
aResult
=
nullptr
;
return
NS_OK
;
}
uint32_t
cnt
;
nsresult
rv
=
mValueArray
-
>
GetLength
(
&
cnt
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mIndex
>
=
cnt
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
mValueArray
-
>
QueryElementAt
(
mIndex
+
+
NS_GET_IID
(
nsISupports
)
(
void
*
*
)
aResult
)
;
}
nsresult
NS_NewArrayEnumerator
(
nsISimpleEnumerator
*
*
aResult
nsIArray
*
aArray
)
{
RefPtr
<
nsSimpleArrayEnumerator
>
enumer
=
new
nsSimpleArrayEnumerator
(
aArray
)
;
enumer
.
forget
(
aResult
)
;
return
NS_OK
;
}
class
nsCOMArrayEnumerator
final
:
public
nsISimpleEnumerator
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISIMPLEENUMERATOR
static
nsCOMArrayEnumerator
*
Allocate
(
const
nsCOMArray_base
&
aArray
)
;
void
operator
delete
(
void
*
aPtr
)
{
free
(
aPtr
)
;
}
private
:
nsCOMArrayEnumerator
(
)
:
mIndex
(
0
)
mArraySize
(
0
)
{
mValueArray
[
0
]
=
nullptr
;
}
~
nsCOMArrayEnumerator
(
void
)
;
protected
:
uint32_t
mIndex
;
uint32_t
mArraySize
;
nsISupports
*
mValueArray
[
1
]
;
}
;
NS_IMPL_ISUPPORTS
(
nsCOMArrayEnumerator
nsISimpleEnumerator
)
nsCOMArrayEnumerator
:
:
~
nsCOMArrayEnumerator
(
)
{
for
(
;
mIndex
<
mArraySize
;
+
+
mIndex
)
{
NS_IF_RELEASE
(
mValueArray
[
mIndex
]
)
;
}
}
NS_IMETHODIMP
nsCOMArrayEnumerator
:
:
HasMoreElements
(
bool
*
aResult
)
{
MOZ_ASSERT
(
aResult
!
=
0
"
null
ptr
"
)
;
if
(
!
aResult
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aResult
=
(
mIndex
<
mArraySize
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCOMArrayEnumerator
:
:
GetNext
(
nsISupports
*
*
aResult
)
{
MOZ_ASSERT
(
aResult
!
=
0
"
null
ptr
"
)
;
if
(
!
aResult
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
mIndex
>
=
mArraySize
)
{
return
NS_ERROR_UNEXPECTED
;
}
*
aResult
=
mValueArray
[
mIndex
+
+
]
;
return
NS_OK
;
}
nsCOMArrayEnumerator
*
nsCOMArrayEnumerator
:
:
Allocate
(
const
nsCOMArray_base
&
aArray
)
{
size_t
size
=
sizeof
(
nsCOMArrayEnumerator
)
;
uint32_t
count
;
if
(
aArray
.
Count
(
)
>
0
)
{
count
=
static_cast
<
uint32_t
>
(
aArray
.
Count
(
)
)
;
size
+
=
(
count
-
1
)
*
sizeof
(
aArray
[
0
]
)
;
}
else
{
count
=
0
;
}
void
*
mem
=
moz_xmalloc
(
size
)
;
auto
result
=
new
(
mozilla
:
:
KnownNotNull
mem
)
nsCOMArrayEnumerator
(
)
;
result
-
>
mArraySize
=
count
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
result
-
>
mValueArray
[
i
]
=
aArray
[
i
]
;
NS_IF_ADDREF
(
result
-
>
mValueArray
[
i
]
)
;
}
return
result
;
}
nsresult
NS_NewArrayEnumerator
(
nsISimpleEnumerator
*
*
aResult
const
nsCOMArray_base
&
aArray
)
{
RefPtr
<
nsCOMArrayEnumerator
>
enumerator
=
nsCOMArrayEnumerator
:
:
Allocate
(
aArray
)
;
enumerator
.
forget
(
aResult
)
;
return
NS_OK
;
}
