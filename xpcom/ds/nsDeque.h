#
ifndef
_NSDEQUE
#
define
_NSDEQUE
#
include
"
nscore
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
class
nsDequeFunctor
{
public
:
virtual
void
operator
(
)
(
void
*
aObject
)
=
0
;
virtual
~
nsDequeFunctor
(
)
=
default
;
}
;
class
nsDeque
{
typedef
mozilla
:
:
fallible_t
fallible_t
;
public
:
explicit
nsDeque
(
nsDequeFunctor
*
aDeallocator
=
nullptr
)
;
~
nsDeque
(
)
;
inline
size_t
GetSize
(
)
const
{
return
mSize
;
}
void
Push
(
void
*
aItem
)
{
if
(
!
Push
(
aItem
mozilla
:
:
fallible
)
)
{
NS_ABORT_OOM
(
mSize
*
sizeof
(
void
*
)
)
;
}
}
[
[
nodiscard
]
]
bool
Push
(
void
*
aItem
const
fallible_t
&
)
;
void
PushFront
(
void
*
aItem
)
{
if
(
!
PushFront
(
aItem
mozilla
:
:
fallible
)
)
{
NS_ABORT_OOM
(
mSize
*
sizeof
(
void
*
)
)
;
}
}
[
[
nodiscard
]
]
bool
PushFront
(
void
*
aItem
const
fallible_t
&
)
;
void
*
Pop
(
)
;
void
*
PopFront
(
)
;
void
*
Peek
(
)
const
;
void
*
PeekFront
(
)
const
;
void
*
ObjectAt
(
size_t
aIndex
)
const
;
void
Erase
(
)
;
void
ForEach
(
nsDequeFunctor
&
aFunctor
)
const
;
class
ConstDequeIterator
{
public
:
ConstDequeIterator
(
const
nsDeque
&
aDeque
size_t
aIndex
)
:
mDeque
(
aDeque
)
mIndex
(
aIndex
)
{
}
ConstDequeIterator
&
operator
+
+
(
)
{
+
+
mIndex
;
return
*
this
;
}
bool
operator
=
=
(
const
ConstDequeIterator
&
aOther
)
const
{
return
mIndex
=
=
aOther
.
mIndex
;
}
bool
operator
!
=
(
const
ConstDequeIterator
&
aOther
)
const
{
return
mIndex
!
=
aOther
.
mIndex
;
}
void
*
operator
*
(
)
const
{
MOZ_RELEASE_ASSERT
(
mIndex
<
mDeque
.
GetSize
(
)
)
;
return
mDeque
.
ObjectAt
(
mIndex
)
;
}
private
:
const
nsDeque
&
mDeque
;
size_t
mIndex
;
}
;
ConstDequeIterator
begin
(
)
const
{
return
ConstDequeIterator
(
*
this
0
)
;
}
ConstDequeIterator
end
(
)
const
{
return
ConstDequeIterator
(
*
this
mSize
)
;
}
class
ConstIterator
{
public
:
static
const
size_t
EndIteratorIndex
=
size_t
(
-
1
)
;
ConstIterator
(
const
nsDeque
&
aDeque
size_t
aIndex
)
:
mDeque
(
aDeque
)
mIndex
(
aIndex
)
{
}
ConstIterator
&
operator
+
+
(
)
{
MOZ_ASSERT
(
mIndex
!
=
EndIteratorIndex
)
;
+
+
mIndex
;
return
*
this
;
}
bool
operator
=
=
(
const
ConstIterator
&
aOther
)
const
{
return
EffectiveIndex
(
)
=
=
aOther
.
EffectiveIndex
(
)
;
}
bool
operator
!
=
(
const
ConstIterator
&
aOther
)
const
{
return
EffectiveIndex
(
)
!
=
aOther
.
EffectiveIndex
(
)
;
}
void
*
operator
*
(
)
const
{
MOZ_RELEASE_ASSERT
(
mIndex
<
mDeque
.
GetSize
(
)
)
;
return
mDeque
.
ObjectAt
(
mIndex
)
;
}
private
:
size_t
EffectiveIndex
(
)
const
{
return
(
mIndex
<
mDeque
.
GetSize
(
)
)
?
mIndex
:
mDeque
.
GetSize
(
)
;
}
const
nsDeque
&
mDeque
;
size_t
mIndex
;
}
;
ConstIterator
begin
(
)
{
return
ConstIterator
(
*
this
0
)
;
}
ConstIterator
end
(
)
{
return
ConstIterator
(
*
this
ConstIterator
:
:
EndIteratorIndex
)
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
protected
:
size_t
mSize
;
size_t
mCapacity
;
size_t
mOrigin
;
nsDequeFunctor
*
mDeallocator
;
void
*
mBuffer
[
8
]
;
void
*
*
mData
;
private
:
nsDeque
(
const
nsDeque
&
aOther
)
=
delete
;
nsDeque
&
operator
=
(
const
nsDeque
&
aOther
)
=
delete
;
bool
GrowCapacity
(
)
;
void
SetDeallocator
(
nsDequeFunctor
*
aDeallocator
)
;
void
Empty
(
)
;
}
;
#
endif
