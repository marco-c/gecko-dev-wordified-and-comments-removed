#
ifndef
NSEXPIRATIONTRACKER_H_
#
define
NSEXPIRATIONTRACKER_H_
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Services
.
h
"
struct
nsExpirationState
{
enum
{
NOT_TRACKED
=
(
1U
<
<
4
)
-
1
MAX_INDEX_IN_GENERATION
=
(
1U
<
<
28
)
-
1
}
;
nsExpirationState
(
)
:
mGeneration
(
NOT_TRACKED
)
mIndexInGeneration
(
0
)
{
}
bool
IsTracked
(
)
{
return
mGeneration
!
=
NOT_TRACKED
;
}
uint32_t
mGeneration
:
4
;
uint32_t
mIndexInGeneration
:
28
;
}
;
template
<
typename
T
uint32_t
K
typename
Mutex
typename
AutoLock
>
class
ExpirationTrackerImpl
{
public
:
ExpirationTrackerImpl
(
uint32_t
aTimerPeriod
const
char
*
aName
nsIEventTarget
*
aEventTarget
=
nullptr
)
:
mTimerPeriod
(
aTimerPeriod
)
mNewestGeneration
(
0
)
mInAgeOneGeneration
(
false
)
mName
(
aName
)
mEventTarget
(
aEventTarget
)
{
static_assert
(
K
>
=
2
&
&
K
<
=
nsExpirationState
:
:
NOT_TRACKED
"
Unsupported
number
of
generations
(
must
be
2
<
=
K
<
=
15
)
"
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mEventTarget
)
{
bool
current
=
false
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
mEventTarget
-
>
IsOnCurrentThread
(
&
current
)
)
|
|
!
current
)
)
{
MOZ_CRASH
(
"
Provided
event
target
must
be
on
the
main
thread
"
)
;
}
}
mObserver
=
new
ExpirationTrackerObserver
(
)
;
mObserver
-
>
Init
(
this
)
;
}
virtual
~
ExpirationTrackerImpl
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
mObserver
-
>
Destroy
(
)
;
}
nsresult
AddObjectLocked
(
T
*
aObj
const
AutoLock
&
aAutoLock
)
{
if
(
NS_WARN_IF
(
!
aObj
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Invalid
object
to
add
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsExpirationState
*
state
=
aObj
-
>
GetExpirationState
(
)
;
if
(
NS_WARN_IF
(
state
-
>
IsTracked
(
)
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Tried
to
add
an
object
that
'
s
already
tracked
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsTArray
<
T
*
>
&
generation
=
mGenerations
[
mNewestGeneration
]
;
uint32_t
index
=
generation
.
Length
(
)
;
if
(
index
>
nsExpirationState
:
:
MAX_INDEX_IN_GENERATION
)
{
NS_WARNING
(
"
More
than
256M
elements
tracked
this
is
probably
a
problem
"
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
index
=
=
0
)
{
nsresult
rv
=
CheckStartTimerLocked
(
aAutoLock
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
!
generation
.
AppendElement
(
aObj
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
state
-
>
mGeneration
=
mNewestGeneration
;
state
-
>
mIndexInGeneration
=
index
;
return
NS_OK
;
}
void
RemoveObjectLocked
(
T
*
aObj
const
AutoLock
&
aAutoLock
)
{
if
(
NS_WARN_IF
(
!
aObj
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Invalid
object
to
remove
"
)
;
return
;
}
nsExpirationState
*
state
=
aObj
-
>
GetExpirationState
(
)
;
if
(
NS_WARN_IF
(
!
state
-
>
IsTracked
(
)
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Tried
to
remove
an
object
that
'
s
not
tracked
"
)
;
return
;
}
nsTArray
<
T
*
>
&
generation
=
mGenerations
[
state
-
>
mGeneration
]
;
uint32_t
index
=
state
-
>
mIndexInGeneration
;
MOZ_ASSERT
(
generation
.
Length
(
)
>
index
&
&
generation
[
index
]
=
=
aObj
"
Object
is
lying
about
its
index
"
)
;
uint32_t
last
=
generation
.
Length
(
)
-
1
;
T
*
lastObj
=
generation
[
last
]
;
generation
[
index
]
=
lastObj
;
lastObj
-
>
GetExpirationState
(
)
-
>
mIndexInGeneration
=
index
;
generation
.
RemoveElementAt
(
last
)
;
MOZ_ASSERT
(
generation
.
Length
(
)
=
=
last
)
;
state
-
>
mGeneration
=
nsExpirationState
:
:
NOT_TRACKED
;
}
nsresult
MarkUsedLocked
(
T
*
aObj
const
AutoLock
&
aAutoLock
)
{
nsExpirationState
*
state
=
aObj
-
>
GetExpirationState
(
)
;
if
(
mNewestGeneration
=
=
state
-
>
mGeneration
)
{
return
NS_OK
;
}
RemoveObjectLocked
(
aObj
aAutoLock
)
;
return
AddObjectLocked
(
aObj
aAutoLock
)
;
}
void
AgeOneGenerationLocked
(
const
AutoLock
&
aAutoLock
)
{
if
(
mInAgeOneGeneration
)
{
NS_WARNING
(
"
Can
'
t
reenter
AgeOneGeneration
from
NotifyExpired
"
)
;
return
;
}
mInAgeOneGeneration
=
true
;
uint32_t
reapGeneration
=
mNewestGeneration
>
0
?
mNewestGeneration
-
1
:
K
-
1
;
nsTArray
<
T
*
>
&
generation
=
mGenerations
[
reapGeneration
]
;
size_t
index
=
generation
.
Length
(
)
;
for
(
;
;
)
{
index
=
XPCOM_MIN
(
index
generation
.
Length
(
)
)
;
if
(
index
=
=
0
)
{
break
;
}
-
-
index
;
NotifyExpiredLocked
(
generation
[
index
]
aAutoLock
)
;
}
if
(
!
generation
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
Expired
objects
were
not
removed
or
marked
used
"
)
;
}
generation
.
Compact
(
)
;
mNewestGeneration
=
reapGeneration
;
mInAgeOneGeneration
=
false
;
}
void
AgeAllGenerationsLocked
(
const
AutoLock
&
aAutoLock
)
{
uint32_t
i
;
for
(
i
=
0
;
i
<
K
;
+
+
i
)
{
AgeOneGenerationLocked
(
aAutoLock
)
;
}
}
class
Iterator
{
private
:
ExpirationTrackerImpl
<
T
K
Mutex
AutoLock
>
*
mTracker
;
uint32_t
mGeneration
;
uint32_t
mIndex
;
public
:
Iterator
(
ExpirationTrackerImpl
<
T
K
Mutex
AutoLock
>
*
aTracker
AutoLock
&
aAutoLock
)
:
mTracker
(
aTracker
)
mGeneration
(
0
)
mIndex
(
0
)
{
}
T
*
Next
(
)
{
while
(
mGeneration
<
K
)
{
nsTArray
<
T
*
>
*
generation
=
&
mTracker
-
>
mGenerations
[
mGeneration
]
;
if
(
mIndex
<
generation
-
>
Length
(
)
)
{
+
+
mIndex
;
return
(
*
generation
)
[
mIndex
-
1
]
;
}
+
+
mGeneration
;
mIndex
=
0
;
}
return
nullptr
;
}
}
;
friend
class
Iterator
;
bool
IsEmptyLocked
(
const
AutoLock
&
aAutoLock
)
{
for
(
uint32_t
i
=
0
;
i
<
K
;
+
+
i
)
{
if
(
!
mGenerations
[
i
]
.
IsEmpty
(
)
)
{
return
false
;
}
}
return
true
;
}
protected
:
virtual
void
NotifyExpiredLocked
(
T
*
const
AutoLock
&
)
=
0
;
virtual
void
NotifyHandlerEndLocked
(
const
AutoLock
&
)
{
}
;
virtual
void
NotifyHandlerEnd
(
)
{
}
;
virtual
Mutex
&
GetMutex
(
)
=
0
;
private
:
class
ExpirationTrackerObserver
;
RefPtr
<
ExpirationTrackerObserver
>
mObserver
;
nsTArray
<
T
*
>
mGenerations
[
K
]
;
nsCOMPtr
<
nsITimer
>
mTimer
;
uint32_t
mTimerPeriod
;
uint32_t
mNewestGeneration
;
bool
mInAgeOneGeneration
;
const
char
*
const
mName
;
const
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
class
ExpirationTrackerObserver
final
:
public
nsIObserver
{
public
:
void
Init
(
ExpirationTrackerImpl
<
T
K
Mutex
AutoLock
>
*
aObj
)
{
mOwner
=
aObj
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
this
"
memory
-
pressure
"
false
)
;
}
}
void
Destroy
(
)
{
mOwner
=
nullptr
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
"
memory
-
pressure
"
)
;
}
}
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
private
:
ExpirationTrackerImpl
<
T
K
Mutex
AutoLock
>
*
mOwner
;
}
;
void
HandleLowMemory
(
)
{
{
AutoLock
lock
(
GetMutex
(
)
)
;
AgeAllGenerationsLocked
(
lock
)
;
NotifyHandlerEndLocked
(
lock
)
;
}
NotifyHandlerEnd
(
)
;
}
void
HandleTimeout
(
)
{
{
AutoLock
lock
(
GetMutex
(
)
)
;
AgeOneGenerationLocked
(
lock
)
;
if
(
IsEmptyLocked
(
lock
)
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
NotifyHandlerEndLocked
(
lock
)
;
}
NotifyHandlerEnd
(
)
;
}
static
void
TimerCallback
(
nsITimer
*
aTimer
void
*
aThis
)
{
ExpirationTrackerImpl
*
tracker
=
static_cast
<
ExpirationTrackerImpl
*
>
(
aThis
)
;
tracker
-
>
HandleTimeout
(
)
;
}
nsresult
CheckStartTimerLocked
(
const
AutoLock
&
aAutoLock
)
{
if
(
mTimer
|
|
!
mTimerPeriod
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIEventTarget
>
target
=
mEventTarget
;
if
(
!
target
&
&
!
NS_IsMainThread
(
)
)
{
target
=
do_GetMainThread
(
)
;
NS_ENSURE_STATE
(
target
)
;
}
return
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mTimer
)
TimerCallback
this
mTimerPeriod
nsITimer
:
:
TYPE_REPEATING_SLACK_LOW_PRIORITY
mName
target
)
;
}
}
;
namespace
detail
{
class
PlaceholderLock
{
public
:
void
Lock
(
)
{
}
void
Unlock
(
)
{
}
}
;
class
PlaceholderAutoLock
{
public
:
explicit
PlaceholderAutoLock
(
PlaceholderLock
&
)
{
}
~
PlaceholderAutoLock
(
)
=
default
;
}
;
template
<
typename
T
uint32_t
K
>
using
SingleThreadedExpirationTracker
=
ExpirationTrackerImpl
<
T
K
PlaceholderLock
PlaceholderAutoLock
>
;
}
template
<
typename
T
uint32_t
K
>
class
nsExpirationTracker
:
protected
:
:
detail
:
:
SingleThreadedExpirationTracker
<
T
K
>
{
typedef
:
:
detail
:
:
PlaceholderLock
Lock
;
typedef
:
:
detail
:
:
PlaceholderAutoLock
AutoLock
;
Lock
mLock
;
AutoLock
FakeLock
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
return
AutoLock
(
mLock
)
;
}
Lock
&
GetMutex
(
)
override
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mLock
;
}
void
NotifyExpiredLocked
(
T
*
aObject
const
AutoLock
&
)
override
{
NotifyExpired
(
aObject
)
;
}
void
NotifyHandlerEndLocked
(
const
AutoLock
&
)
final
{
}
void
NotifyHandlerEnd
(
)
final
{
}
protected
:
virtual
void
NotifyExpired
(
T
*
aObj
)
=
0
;
public
:
nsExpirationTracker
(
uint32_t
aTimerPeriod
const
char
*
aName
nsIEventTarget
*
aEventTarget
=
nullptr
)
:
:
:
detail
:
:
SingleThreadedExpirationTracker
<
T
K
>
(
aTimerPeriod
aName
aEventTarget
)
{
}
virtual
~
nsExpirationTracker
(
)
{
}
nsresult
AddObject
(
T
*
aObj
)
{
return
this
-
>
AddObjectLocked
(
aObj
FakeLock
(
)
)
;
}
void
RemoveObject
(
T
*
aObj
)
{
this
-
>
RemoveObjectLocked
(
aObj
FakeLock
(
)
)
;
}
nsresult
MarkUsed
(
T
*
aObj
)
{
return
this
-
>
MarkUsedLocked
(
aObj
FakeLock
(
)
)
;
}
void
AgeOneGeneration
(
)
{
this
-
>
AgeOneGenerationLocked
(
FakeLock
(
)
)
;
}
void
AgeAllGenerations
(
)
{
this
-
>
AgeAllGenerationsLocked
(
FakeLock
(
)
)
;
}
class
Iterator
{
private
:
AutoLock
mAutoLock
;
typename
ExpirationTrackerImpl
<
T
K
Lock
AutoLock
>
:
:
Iterator
mIterator
;
public
:
explicit
Iterator
(
nsExpirationTracker
<
T
K
>
*
aTracker
)
:
mAutoLock
(
aTracker
-
>
GetMutex
(
)
)
mIterator
(
aTracker
mAutoLock
)
{
}
T
*
Next
(
)
{
return
mIterator
.
Next
(
)
;
}
}
;
friend
class
Iterator
;
bool
IsEmpty
(
)
{
return
this
-
>
IsEmptyLocked
(
FakeLock
(
)
)
;
}
}
;
template
<
typename
T
uint32_t
K
typename
Mutex
typename
AutoLock
>
NS_IMETHODIMP
ExpirationTrackerImpl
<
T
K
Mutex
AutoLock
>
:
:
ExpirationTrackerObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
"
memory
-
pressure
"
)
&
&
mOwner
)
{
mOwner
-
>
HandleLowMemory
(
)
;
}
return
NS_OK
;
}
template
<
class
T
uint32_t
K
typename
Mutex
typename
AutoLock
>
NS_IMETHODIMP_
(
MozExternalRefCountType
)
ExpirationTrackerImpl
<
T
K
Mutex
AutoLock
>
:
:
ExpirationTrackerObserver
:
:
AddRef
(
void
)
{
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
=
0
"
illegal
refcnt
"
)
;
NS_ASSERT_OWNINGTHREAD
(
ExpirationTrackerObserver
)
;
+
+
mRefCnt
;
NS_LOG_ADDREF
(
this
mRefCnt
"
ExpirationTrackerObserver
"
sizeof
(
*
this
)
)
;
return
mRefCnt
;
}
template
<
class
T
uint32_t
K
typename
Mutex
typename
AutoLock
>
NS_IMETHODIMP_
(
MozExternalRefCountType
)
ExpirationTrackerImpl
<
T
K
Mutex
AutoLock
>
:
:
ExpirationTrackerObserver
:
:
Release
(
void
)
{
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
0
"
dup
release
"
)
;
NS_ASSERT_OWNINGTHREAD
(
ExpirationTrackerObserver
)
;
-
-
mRefCnt
;
NS_LOG_RELEASE
(
this
mRefCnt
"
ExpirationTrackerObserver
"
)
;
if
(
mRefCnt
=
=
0
)
{
NS_ASSERT_OWNINGTHREAD
(
ExpirationTrackerObserver
)
;
mRefCnt
=
1
;
delete
(
this
)
;
return
0
;
}
return
mRefCnt
;
}
template
<
class
T
uint32_t
K
typename
Mutex
typename
AutoLock
>
NS_IMETHODIMP
ExpirationTrackerImpl
<
T
K
Mutex
AutoLock
>
:
:
ExpirationTrackerObserver
:
:
QueryInterface
(
REFNSIID
aIID
void
*
*
aInstancePtr
)
{
NS_ASSERTION
(
aInstancePtr
"
QueryInterface
requires
a
non
-
NULL
destination
!
"
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
NS_INTERFACE_TABLE
(
ExpirationTrackerObserver
nsIObserver
)
return
rv
;
}
#
endif
