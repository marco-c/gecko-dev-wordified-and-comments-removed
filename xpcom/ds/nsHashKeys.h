#
ifndef
nsTHashKeys_h__
#
define
nsTHashKeys_h__
#
include
"
nsID
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
<
new
>
#
include
"
nsString
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsPointerHashKeys
.
h
"
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
mozilla
/
HashFunctions
.
h
"
namespace
mozilla
{
inline
uint32_t
HashString
(
const
nsAString
&
aStr
)
{
return
HashString
(
aStr
.
BeginReading
(
)
aStr
.
Length
(
)
)
;
}
inline
uint32_t
HashString
(
const
nsACString
&
aStr
)
{
return
HashString
(
aStr
.
BeginReading
(
)
aStr
.
Length
(
)
)
;
}
}
class
nsStringHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
const
nsAString
&
KeyType
;
typedef
const
nsAString
*
KeyTypePointer
;
explicit
nsStringHashKey
(
KeyTypePointer
aStr
)
:
mStr
(
*
aStr
)
{
}
nsStringHashKey
(
const
nsStringHashKey
&
)
=
delete
;
nsStringHashKey
(
nsStringHashKey
&
&
aToMove
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aToMove
)
)
mStr
(
std
:
:
move
(
aToMove
.
mStr
)
)
{
}
~
nsStringHashKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mStr
;
}
bool
KeyEquals
(
const
KeyTypePointer
aKey
)
const
{
return
mStr
.
Equals
(
*
aKey
)
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
const
KeyTypePointer
aKey
)
{
return
mozilla
:
:
HashString
(
*
aKey
)
;
}
#
ifdef
MOZILLA_INTERNAL_API
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
GetKey
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
#
endif
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
nsString
mStr
;
}
;
#
ifdef
MOZILLA_INTERNAL_API
namespace
mozilla
:
:
detail
{
template
<
class
CharT
bool
Unicode
=
true
>
struct
comparatorTraits
{
}
;
template
<
>
struct
comparatorTraits
<
char
false
>
{
static
int
caseInsensitiveCompare
(
const
char
*
aLhs
const
char
*
aRhs
uint32_t
aLhsLength
uint32_t
aRhsLength
)
{
return
nsCaseInsensitiveCStringComparator
(
aLhs
aRhs
aLhsLength
aRhsLength
)
;
}
;
}
;
template
<
>
struct
comparatorTraits
<
char
true
>
{
static
int
caseInsensitiveCompare
(
const
char
*
aLhs
const
char
*
aRhs
uint32_t
aLhsLength
uint32_t
aRhsLength
)
{
return
nsCaseInsensitiveUTF8StringComparator
(
aLhs
aRhs
aLhsLength
aRhsLength
)
;
}
;
}
;
template
<
>
struct
comparatorTraits
<
char16_t
true
>
{
static
int
caseInsensitiveCompare
(
const
char16_t
*
aLhs
const
char16_t
*
aRhs
uint32_t
aLhsLength
uint32_t
aRhsLength
)
{
return
nsCaseInsensitiveStringComparator
(
aLhs
aRhs
aLhsLength
aRhsLength
)
;
}
;
}
;
}
template
<
typename
T
bool
Unicode
>
class
nsTStringCaseInsensitiveHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
const
nsTSubstring
<
T
>
&
KeyType
;
typedef
const
nsTSubstring
<
T
>
*
KeyTypePointer
;
explicit
nsTStringCaseInsensitiveHashKey
(
KeyTypePointer
aStr
)
:
mStr
(
*
aStr
)
{
}
nsTStringCaseInsensitiveHashKey
(
const
nsTStringCaseInsensitiveHashKey
&
)
=
delete
;
nsTStringCaseInsensitiveHashKey
(
nsTStringCaseInsensitiveHashKey
&
&
aToMove
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aToMove
)
)
mStr
(
std
:
:
move
(
aToMove
.
mStr
)
)
{
}
~
nsTStringCaseInsensitiveHashKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mStr
;
}
bool
KeyEquals
(
const
KeyTypePointer
aKey
)
const
{
using
comparator
=
typename
mozilla
:
:
detail
:
:
comparatorTraits
<
T
Unicode
>
;
return
mStr
.
Equals
(
*
aKey
comparator
:
:
caseInsensitiveCompare
)
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
const
KeyTypePointer
aKey
)
{
nsTAutoString
<
T
>
tmKey
(
*
aKey
)
;
ToLowerCase
(
tmKey
)
;
return
mozilla
:
:
HashString
(
tmKey
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
GetKey
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
private
:
const
nsTString
<
T
>
mStr
;
}
;
using
nsStringCaseInsensitiveHashKey
=
nsTStringCaseInsensitiveHashKey
<
char16_t
true
>
;
using
nsCStringASCIICaseInsensitiveHashKey
=
nsTStringCaseInsensitiveHashKey
<
char
false
>
;
using
nsCStringUTF8CaseInsensitiveHashKey
=
nsTStringCaseInsensitiveHashKey
<
char
true
>
;
#
endif
class
nsCStringHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
const
nsACString
&
KeyType
;
typedef
const
nsACString
*
KeyTypePointer
;
explicit
nsCStringHashKey
(
const
nsACString
*
aStr
)
:
mStr
(
*
aStr
)
{
}
nsCStringHashKey
(
nsCStringHashKey
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mStr
(
std
:
:
move
(
aOther
.
mStr
)
)
{
}
~
nsCStringHashKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mStr
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
mStr
.
Equals
(
*
aKey
)
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
mozilla
:
:
HashString
(
*
aKey
)
;
}
#
ifdef
MOZILLA_INTERNAL_API
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
GetKey
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
#
endif
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
const
nsCString
mStr
;
}
;
template
<
typename
T
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
T
>
|
|
std
:
:
is_enum_v
<
T
>
int
>
=
0
>
class
nsIntegralHashKey
:
public
PLDHashEntryHdr
{
public
:
using
KeyType
=
const
T
&
;
using
KeyTypePointer
=
const
T
*
;
explicit
nsIntegralHashKey
(
KeyTypePointer
aKey
)
:
mValue
(
*
aKey
)
{
}
nsIntegralHashKey
(
nsIntegralHashKey
&
&
aOther
)
noexcept
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mValue
(
aOther
.
mValue
)
{
}
~
nsIntegralHashKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mValue
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
*
aKey
=
=
mValue
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
mozilla
:
:
HashGeneric
(
*
aKey
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
const
T
mValue
;
}
;
using
nsUint32HashKey
=
nsIntegralHashKey
<
uint32_t
>
;
using
nsUint64HashKey
=
nsIntegralHashKey
<
uint64_t
>
;
class
nsFloatHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
const
float
&
KeyType
;
typedef
const
float
*
KeyTypePointer
;
explicit
nsFloatHashKey
(
KeyTypePointer
aKey
)
:
mValue
(
*
aKey
)
{
}
nsFloatHashKey
(
nsFloatHashKey
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mValue
(
std
:
:
move
(
aOther
.
mValue
)
)
{
}
~
nsFloatHashKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mValue
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
*
aKey
=
=
mValue
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
*
reinterpret_cast
<
const
uint32_t
*
>
(
aKey
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
const
float
mValue
;
}
;
using
IntPtrHashKey
=
nsIntegralHashKey
<
intptr_t
>
;
class
nsISupportsHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
nsISupports
*
KeyType
;
typedef
const
nsISupports
*
KeyTypePointer
;
explicit
nsISupportsHashKey
(
const
nsISupports
*
aKey
)
:
mSupports
(
const_cast
<
nsISupports
*
>
(
aKey
)
)
{
}
nsISupportsHashKey
(
nsISupportsHashKey
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mSupports
(
std
:
:
move
(
aOther
.
mSupports
)
)
{
}
~
nsISupportsHashKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mSupports
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
aKey
=
=
mSupports
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
NS_PTR_TO_UINT32
(
aKey
)
>
>
2
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
nsCOMPtr
<
nsISupports
>
mSupports
;
}
;
template
<
class
T
>
class
nsRefPtrHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
T
*
KeyType
;
typedef
const
T
*
KeyTypePointer
;
explicit
nsRefPtrHashKey
(
const
T
*
aKey
)
:
mKey
(
const_cast
<
T
*
>
(
aKey
)
)
{
}
nsRefPtrHashKey
(
nsRefPtrHashKey
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mKey
(
std
:
:
move
(
aOther
.
mKey
)
)
{
}
~
nsRefPtrHashKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mKey
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
aKey
=
=
mKey
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
NS_PTR_TO_UINT32
(
aKey
)
>
>
2
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
RefPtr
<
T
>
mKey
;
}
;
template
<
class
T
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
nsRefPtrHashKey
<
T
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
CycleCollectionNoteChild
(
aCallback
aField
.
GetKey
(
)
aName
aFlags
)
;
}
template
<
class
T
>
class
nsClearingPtrHashKey
:
public
nsPtrHashKey
<
T
>
{
public
:
explicit
nsClearingPtrHashKey
(
const
T
*
aKey
)
:
nsPtrHashKey
<
T
>
(
aKey
)
{
}
nsClearingPtrHashKey
(
nsClearingPtrHashKey
&
&
aToMove
)
:
nsPtrHashKey
<
T
>
(
std
:
:
move
(
aToMove
)
)
{
}
~
nsClearingPtrHashKey
(
)
{
nsPtrHashKey
<
T
>
:
:
mKey
=
nullptr
;
}
}
;
typedef
nsClearingPtrHashKey
<
const
void
>
nsClearingVoidPtrHashKey
;
template
<
class
T
>
class
nsFuncPtrHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
T
&
KeyType
;
typedef
const
T
*
KeyTypePointer
;
explicit
nsFuncPtrHashKey
(
const
T
*
aKey
)
:
mKey
(
*
const_cast
<
T
*
>
(
aKey
)
)
{
}
nsFuncPtrHashKey
(
const
nsFuncPtrHashKey
<
T
>
&
aToCopy
)
:
mKey
(
aToCopy
.
mKey
)
{
}
~
nsFuncPtrHashKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
const_cast
<
T
&
>
(
mKey
)
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
*
aKey
=
=
mKey
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
NS_PTR_TO_UINT32
(
*
aKey
)
>
>
2
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
protected
:
T
mKey
;
}
;
class
nsIDHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
const
nsID
&
KeyType
;
typedef
const
nsID
*
KeyTypePointer
;
explicit
nsIDHashKey
(
const
nsID
*
aInID
)
:
mID
(
*
aInID
)
{
}
nsIDHashKey
(
nsIDHashKey
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mID
(
std
:
:
move
(
aOther
.
mID
)
)
{
}
~
nsIDHashKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mID
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
aKey
-
>
Equals
(
mID
)
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
mozilla
:
:
HashBytes
(
aKey
sizeof
(
KeyType
)
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
nsID
mID
;
}
;
class
nsIDPointerHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
const
nsID
*
KeyType
;
typedef
const
nsID
*
KeyTypePointer
;
explicit
nsIDPointerHashKey
(
const
nsID
*
aInID
)
:
mID
(
aInID
)
{
}
nsIDPointerHashKey
(
nsIDPointerHashKey
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mID
(
aOther
.
mID
)
{
}
~
nsIDPointerHashKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mID
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
aKey
-
>
Equals
(
*
mID
)
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
mozilla
:
:
HashBytes
(
aKey
sizeof
(
*
aKey
)
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
const
nsID
*
mID
;
}
;
class
nsDepCharHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
const
char
*
KeyType
;
typedef
const
char
*
KeyTypePointer
;
explicit
nsDepCharHashKey
(
const
char
*
aKey
)
:
mKey
(
aKey
)
{
}
nsDepCharHashKey
(
nsDepCharHashKey
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mKey
(
std
:
:
move
(
aOther
.
mKey
)
)
{
}
~
nsDepCharHashKey
(
)
=
default
;
const
char
*
GetKey
(
)
const
{
return
mKey
;
}
bool
KeyEquals
(
const
char
*
aKey
)
const
{
return
!
strcmp
(
mKey
aKey
)
;
}
static
const
char
*
KeyToPointer
(
const
char
*
aKey
)
{
return
aKey
;
}
static
PLDHashNumber
HashKey
(
const
char
*
aKey
)
{
return
mozilla
:
:
HashString
(
aKey
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
const
char
*
mKey
;
}
;
class
nsCharPtrHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
const
char
*
KeyType
;
typedef
const
char
*
KeyTypePointer
;
explicit
nsCharPtrHashKey
(
const
char
*
aKey
)
:
mKey
(
strdup
(
aKey
)
)
{
}
nsCharPtrHashKey
(
const
nsCharPtrHashKey
&
)
=
delete
;
nsCharPtrHashKey
(
nsCharPtrHashKey
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mKey
(
aOther
.
mKey
)
{
aOther
.
mKey
=
nullptr
;
}
~
nsCharPtrHashKey
(
)
{
if
(
mKey
)
{
free
(
const_cast
<
char
*
>
(
mKey
)
)
;
}
}
const
char
*
GetKey
(
)
const
{
return
mKey
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
!
strcmp
(
mKey
aKey
)
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
mozilla
:
:
HashString
(
aKey
)
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
mKey
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
const
char
*
mKey
;
}
;
class
nsUnicharPtrHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
const
char16_t
*
KeyType
;
typedef
const
char16_t
*
KeyTypePointer
;
explicit
nsUnicharPtrHashKey
(
const
char16_t
*
aKey
)
:
mKey
(
NS_xstrdup
(
aKey
)
)
{
}
nsUnicharPtrHashKey
(
const
nsUnicharPtrHashKey
&
aToCopy
)
=
delete
;
nsUnicharPtrHashKey
(
nsUnicharPtrHashKey
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mKey
(
aOther
.
mKey
)
{
aOther
.
mKey
=
nullptr
;
}
~
nsUnicharPtrHashKey
(
)
{
if
(
mKey
)
{
free
(
const_cast
<
char16_t
*
>
(
mKey
)
)
;
}
}
const
char16_t
*
GetKey
(
)
const
{
return
mKey
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
!
NS_strcmp
(
mKey
aKey
)
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
mozilla
:
:
HashString
(
aKey
)
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
mKey
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
const
char16_t
*
mKey
;
}
;
namespace
mozilla
{
template
<
typename
T
>
PLDHashNumber
Hash
(
const
T
&
aValue
)
{
return
aValue
.
Hash
(
)
;
}
}
template
<
typename
T
>
class
nsGenericHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
const
T
&
KeyType
;
typedef
const
T
*
KeyTypePointer
;
explicit
nsGenericHashKey
(
KeyTypePointer
aKey
)
:
mKey
(
*
aKey
)
{
}
nsGenericHashKey
(
const
nsGenericHashKey
&
)
=
delete
;
nsGenericHashKey
(
nsGenericHashKey
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mKey
(
std
:
:
move
(
aOther
.
mKey
)
)
{
}
KeyType
GetKey
(
)
const
{
return
mKey
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
*
aKey
=
=
mKey
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
:
:
mozilla
:
:
Hash
(
*
aKey
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
T
mKey
;
}
;
#
endif
