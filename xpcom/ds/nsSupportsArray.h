#
ifndef
nsSupportsArray_h__
#
define
nsSupportsArray_h__
#
include
"
nsISupportsArray
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
static
const
uint32_t
kAutoArraySize
=
8
;
class
nsSupportsArray
final
:
public
nsISupportsArray
{
~
nsSupportsArray
(
void
)
;
public
:
nsSupportsArray
(
void
)
;
static
MOZ_MUST_USE
nsresult
Create
(
nsISupports
*
aOuter
REFNSIID
aIID
void
*
*
aResult
)
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSISERIALIZABLE
NS_IMETHOD
Count
(
uint32_t
*
aResult
)
override
{
*
aResult
=
mCount
;
return
NS_OK
;
}
NS_IMETHOD
GetElementAt
(
uint32_t
aIndex
nsISupports
*
*
aResult
)
override
;
MOZ_MUST_USE
NS_IMETHOD
QueryElementAt
(
uint32_t
aIndex
const
nsIID
&
aIID
void
*
*
aResult
)
override
{
if
(
aIndex
<
mCount
)
{
nsISupports
*
element
=
mArray
[
aIndex
]
;
if
(
element
)
{
return
element
-
>
QueryInterface
(
aIID
aResult
)
;
}
}
return
NS_ERROR_FAILURE
;
}
MOZ_MUST_USE
NS_IMETHOD
SetElementAt
(
uint32_t
aIndex
nsISupports
*
aValue
)
override
{
return
ReplaceElementAt
(
aValue
aIndex
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
MOZ_MUST_USE
NS_IMETHOD
AppendElement
(
nsISupports
*
aElement
)
override
{
return
(
nsresult
)
InsertElementAt
(
aElement
mCount
)
;
}
MOZ_MUST_USE
NS_IMETHOD
RemoveElement
(
nsISupports
*
aElement
)
override
;
NS_IMETHOD
Enumerate
(
nsIEnumerator
*
*
aResult
)
override
;
NS_IMETHOD
Clear
(
void
)
override
;
NS_IMETHOD_
(
bool
)
Equals
(
const
nsISupportsArray
*
aOther
)
override
;
NS_IMETHOD_
(
int32_t
)
IndexOf
(
const
nsISupports
*
aPossibleElement
)
override
;
NS_IMETHOD_
(
int32_t
)
IndexOfStartingAt
(
const
nsISupports
*
aPossibleElement
uint32_t
aStartIndex
=
0
)
override
;
NS_IMETHOD_
(
int32_t
)
LastIndexOf
(
const
nsISupports
*
aPossibleElement
)
override
;
NS_IMETHOD
GetIndexOf
(
nsISupports
*
aPossibleElement
int32_t
*
aResult
)
override
{
*
aResult
=
IndexOf
(
aPossibleElement
)
;
return
NS_OK
;
}
NS_IMETHOD
GetIndexOfStartingAt
(
nsISupports
*
aPossibleElement
uint32_t
aStartIndex
int32_t
*
aResult
)
override
{
*
aResult
=
IndexOfStartingAt
(
aPossibleElement
aStartIndex
)
;
return
NS_OK
;
}
NS_IMETHOD
GetLastIndexOf
(
nsISupports
*
aPossibleElement
int32_t
*
aResult
)
override
{
*
aResult
=
LastIndexOf
(
aPossibleElement
)
;
return
NS_OK
;
}
MOZ_MUST_USE
NS_IMETHOD_
(
bool
)
InsertElementAt
(
nsISupports
*
aElement
uint32_t
aIndex
)
override
;
MOZ_MUST_USE
NS_IMETHOD_
(
bool
)
ReplaceElementAt
(
nsISupports
*
aElement
uint32_t
aIndex
)
override
;
MOZ_MUST_USE
NS_IMETHOD_
(
bool
)
RemoveElementAt
(
uint32_t
aIndex
)
override
{
return
RemoveElementsAt
(
aIndex
1
)
;
}
MOZ_MUST_USE
NS_IMETHOD_
(
bool
)
RemoveLastElement
(
const
nsISupports
*
aElement
)
override
;
MOZ_MUST_USE
NS_IMETHOD
DeleteLastElement
(
nsISupports
*
aElement
)
override
{
return
(
RemoveLastElement
(
aElement
)
?
NS_OK
:
NS_ERROR_FAILURE
)
;
}
MOZ_MUST_USE
NS_IMETHOD
DeleteElementAt
(
uint32_t
aIndex
)
override
{
return
(
RemoveElementAt
(
aIndex
)
?
NS_OK
:
NS_ERROR_FAILURE
)
;
}
NS_IMETHOD
Compact
(
void
)
override
;
MOZ_MUST_USE
NS_IMETHOD
Clone
(
nsISupportsArray
*
*
aResult
)
override
;
MOZ_MUST_USE
NS_IMETHOD_
(
bool
)
RemoveElementsAt
(
uint32_t
aIndex
uint32_t
aCount
)
override
;
MOZ_MUST_USE
NS_IMETHOD_
(
bool
)
SizeTo
(
int32_t
aSize
)
override
;
protected
:
void
DeleteArray
(
void
)
;
bool
GrowArrayBy
(
uint32_t
aGrowBy
)
;
nsISupports
*
*
mArray
;
uint32_t
mArraySize
;
uint32_t
mCount
;
nsISupports
*
mAutoArray
[
kAutoArraySize
]
;
private
:
explicit
nsSupportsArray
(
const
nsISupportsArray
&
aOther
)
;
}
;
#
endif
