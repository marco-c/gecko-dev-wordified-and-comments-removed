#
ifndef
nsTArray_h__
#
error
"
Don
'
t
include
this
file
directly
"
#
endif
template
<
class
Alloc
class
RelocationStrategy
>
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
nsTArray_base
(
)
:
mHdr
(
EmptyHdr
(
)
)
{
}
template
<
class
Alloc
class
RelocationStrategy
>
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
~
nsTArray_base
(
)
{
if
(
!
HasEmptyHeader
(
)
&
&
!
UsesAutoArrayBuffer
(
)
)
{
Alloc
:
:
Free
(
mHdr
)
;
}
}
template
<
class
Alloc
class
RelocationStrategy
>
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
nsTArray_base
(
const
nsTArray_base
&
)
:
mHdr
(
EmptyHdr
(
)
)
{
}
template
<
class
Alloc
class
RelocationStrategy
>
nsTArray_base
<
Alloc
RelocationStrategy
>
&
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
operator
=
(
const
nsTArray_base
&
)
{
return
*
this
;
}
bool
IsTwiceTheRequiredBytesRepresentableAsUint32
(
size_t
aCapacity
size_t
aElemSize
)
;
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
>
typename
ActualAlloc
:
:
ResultTypeProxy
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
ExtendCapacity
(
size_type
aLength
size_type
aCount
size_type
aElemSize
)
{
mozilla
:
:
CheckedInt
<
size_type
>
newLength
=
aLength
;
newLength
+
=
aCount
;
if
(
!
newLength
.
isValid
(
)
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
return
this
-
>
EnsureCapacity
<
ActualAlloc
>
(
newLength
.
value
(
)
aElemSize
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
>
typename
ActualAlloc
:
:
ResultTypeProxy
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
EnsureCapacityImpl
(
size_type
aCapacity
size_type
aElemSize
)
{
MOZ_ASSERT
(
aCapacity
>
mHdr
-
>
mCapacity
"
Should
have
been
checked
by
caller
(
EnsureCapacity
)
"
)
;
if
(
!
IsTwiceTheRequiredBytesRepresentableAsUint32
(
aCapacity
aElemSize
)
)
{
ActualAlloc
:
:
SizeTooBig
(
(
size_t
)
aCapacity
*
aElemSize
)
;
return
ActualAlloc
:
:
FailureResult
(
)
;
}
size_t
reqSize
=
sizeof
(
Header
)
+
aCapacity
*
aElemSize
;
if
(
HasEmptyHeader
(
)
)
{
Header
*
header
=
static_cast
<
Header
*
>
(
ActualAlloc
:
:
Malloc
(
reqSize
)
)
;
if
(
!
header
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
header
-
>
mLength
=
0
;
header
-
>
mCapacity
=
aCapacity
;
header
-
>
mIsAutoBuffer
=
0
;
mHdr
=
header
;
return
ActualAlloc
:
:
SuccessResult
(
)
;
}
const
size_t
slowGrowthThreshold
=
8
*
1024
*
1024
;
size_t
bytesToAlloc
;
if
(
reqSize
>
=
slowGrowthThreshold
)
{
size_t
currSize
=
sizeof
(
Header
)
+
Capacity
(
)
*
aElemSize
;
size_t
minNewSize
=
currSize
+
(
currSize
>
>
3
)
;
bytesToAlloc
=
reqSize
>
minNewSize
?
reqSize
:
minNewSize
;
const
size_t
MiB
=
1
<
<
20
;
bytesToAlloc
=
MiB
*
(
(
bytesToAlloc
+
MiB
-
1
)
/
MiB
)
;
}
else
{
bytesToAlloc
=
mozilla
:
:
RoundUpPow2
(
reqSize
)
;
}
Header
*
header
;
if
(
UsesAutoArrayBuffer
(
)
|
|
!
RelocationStrategy
:
:
allowRealloc
)
{
header
=
static_cast
<
Header
*
>
(
ActualAlloc
:
:
Malloc
(
bytesToAlloc
)
)
;
if
(
!
header
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
RelocationStrategy
:
:
RelocateNonOverlappingRegionWithHeader
(
header
mHdr
Length
(
)
aElemSize
)
;
if
(
!
UsesAutoArrayBuffer
(
)
)
{
ActualAlloc
:
:
Free
(
mHdr
)
;
}
}
else
{
header
=
static_cast
<
Header
*
>
(
ActualAlloc
:
:
Realloc
(
mHdr
bytesToAlloc
)
)
;
if
(
!
header
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
}
size_t
newCapacity
=
(
bytesToAlloc
-
sizeof
(
Header
)
)
/
aElemSize
;
MOZ_ASSERT
(
newCapacity
>
=
aCapacity
"
Didn
'
t
enlarge
the
array
enough
!
"
)
;
header
-
>
mCapacity
=
newCapacity
;
header
-
>
mIsAutoBuffer
=
false
;
mHdr
=
header
;
return
ActualAlloc
:
:
SuccessResult
(
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
void
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
ShrinkCapacity
(
size_type
aElemSize
size_t
aElemAlign
)
{
if
(
HasEmptyHeader
(
)
|
|
UsesAutoArrayBuffer
(
)
)
{
return
;
}
if
(
mHdr
-
>
mLength
>
=
mHdr
-
>
mCapacity
)
{
return
;
}
size_type
length
=
Length
(
)
;
if
(
length
=
=
0
)
{
nsTArrayFallibleAllocator
:
:
Free
(
mHdr
)
;
mHdr
=
EmptyHdr
(
)
;
return
;
}
size_type
newSize
=
sizeof
(
Header
)
+
length
*
aElemSize
;
Header
*
newHeader
;
if
(
!
RelocationStrategy
:
:
allowRealloc
)
{
newHeader
=
static_cast
<
Header
*
>
(
nsTArrayFallibleAllocator
:
:
Malloc
(
newSize
)
)
;
if
(
!
newHeader
)
{
return
;
}
RelocationStrategy
:
:
RelocateNonOverlappingRegionWithHeader
(
newHeader
mHdr
Length
(
)
aElemSize
)
;
nsTArrayFallibleAllocator
:
:
Free
(
mHdr
)
;
}
else
{
newHeader
=
static_cast
<
Header
*
>
(
nsTArrayFallibleAllocator
:
:
Realloc
(
mHdr
newSize
)
)
;
if
(
!
newHeader
)
{
return
;
}
}
mHdr
=
newHeader
;
mHdr
-
>
mCapacity
=
length
;
mHdr
-
>
mIsAutoBuffer
=
false
;
}
template
<
class
Alloc
class
RelocationStrategy
>
void
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
ShrinkCapacityToZero
(
size_type
aElemSize
size_t
aElemAlign
)
{
MOZ_ASSERT
(
mHdr
-
>
mLength
=
=
0
)
;
if
(
HasEmptyHeader
(
)
|
|
UsesAutoArrayBuffer
(
)
)
{
return
;
}
nsTArrayFallibleAllocator
:
:
Free
(
mHdr
)
;
mHdr
=
EmptyHdr
(
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
>
void
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
ShiftData
(
index_type
aStart
size_type
aOldLen
size_type
aNewLen
size_type
aElemSize
size_t
aElemAlign
)
{
if
(
aOldLen
=
=
aNewLen
)
{
return
;
}
size_type
num
=
mHdr
-
>
mLength
-
(
aStart
+
aOldLen
)
;
mHdr
-
>
mLength
+
=
aNewLen
-
aOldLen
;
if
(
mHdr
-
>
mLength
=
=
0
)
{
ShrinkCapacityToZero
(
aElemSize
aElemAlign
)
;
}
else
{
if
(
num
=
=
0
)
{
return
;
}
aStart
*
=
aElemSize
;
aNewLen
*
=
aElemSize
;
aOldLen
*
=
aElemSize
;
char
*
baseAddr
=
reinterpret_cast
<
char
*
>
(
mHdr
+
1
)
+
aStart
;
RelocationStrategy
:
:
RelocateOverlappingRegion
(
baseAddr
+
aNewLen
baseAddr
+
aOldLen
num
aElemSize
)
;
}
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
>
void
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
SwapFromEnd
(
index_type
aStart
size_type
aCount
size_type
aElemSize
size_t
aElemAlign
)
{
if
(
aCount
=
=
0
)
{
return
;
}
size_type
oldLength
=
mHdr
-
>
mLength
;
mHdr
-
>
mLength
-
=
aCount
;
if
(
mHdr
-
>
mLength
=
=
0
)
{
ShrinkCapacityToZero
(
aElemSize
aElemAlign
)
;
return
;
}
size_type
relocCount
=
std
:
:
min
(
aCount
mHdr
-
>
mLength
-
aStart
)
;
if
(
relocCount
=
=
0
)
{
return
;
}
index_type
sourceBytes
=
(
oldLength
-
relocCount
)
*
aElemSize
;
index_type
destBytes
=
aStart
*
aElemSize
;
MOZ_ASSERT
(
sourceBytes
>
=
destBytes
"
The
source
should
be
after
the
destination
.
"
)
;
MOZ_ASSERT
(
sourceBytes
-
destBytes
>
=
relocCount
*
aElemSize
"
The
range
should
be
nonoverlapping
"
)
;
char
*
baseAddr
=
reinterpret_cast
<
char
*
>
(
mHdr
+
1
)
;
RelocationStrategy
:
:
RelocateNonOverlappingRegion
(
baseAddr
+
destBytes
baseAddr
+
sourceBytes
relocCount
aElemSize
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
>
typename
ActualAlloc
:
:
ResultTypeProxy
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
InsertSlotsAt
(
index_type
aIndex
size_type
aCount
size_type
aElemSize
size_t
aElemAlign
)
{
if
(
MOZ_UNLIKELY
(
aIndex
>
Length
(
)
)
)
{
mozilla
:
:
detail
:
:
InvalidArrayIndex_CRASH
(
aIndex
Length
(
)
)
;
}
if
(
!
ActualAlloc
:
:
Successful
(
this
-
>
ExtendCapacity
<
ActualAlloc
>
(
Length
(
)
aCount
aElemSize
)
)
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
ShiftData
<
ActualAlloc
>
(
aIndex
0
aCount
aElemSize
aElemAlign
)
;
return
ActualAlloc
:
:
SuccessResult
(
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
class
Allocator
>
typename
ActualAlloc
:
:
ResultTypeProxy
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
SwapArrayElements
(
nsTArray_base
<
Allocator
RelocationStrategy
>
&
aOther
size_type
aElemSize
size_t
aElemAlign
)
{
if
(
(
!
UsesAutoArrayBuffer
(
)
|
|
Capacity
(
)
<
aOther
.
Length
(
)
)
&
&
(
!
aOther
.
UsesAutoArrayBuffer
(
)
|
|
aOther
.
Capacity
(
)
<
Length
(
)
)
)
{
auto
*
thisHdr
=
TakeHeaderForMove
<
ActualAlloc
>
(
aElemSize
)
;
if
(
MOZ_UNLIKELY
(
!
thisHdr
)
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
auto
*
otherHdr
=
aOther
.
template
TakeHeaderForMove
<
ActualAlloc
>
(
aElemSize
)
;
if
(
MOZ_UNLIKELY
(
!
otherHdr
)
)
{
MOZ_ASSERT
(
UsesAutoArrayBuffer
(
)
|
|
HasEmptyHeader
(
)
)
;
mHdr
=
thisHdr
;
return
ActualAlloc
:
:
FailureResult
(
)
;
}
if
(
otherHdr
!
=
EmptyHdr
(
)
)
{
mHdr
=
otherHdr
;
}
if
(
thisHdr
!
=
EmptyHdr
(
)
)
{
aOther
.
mHdr
=
thisHdr
;
}
return
ActualAlloc
:
:
SuccessResult
(
)
;
}
if
(
!
ActualAlloc
:
:
Successful
(
EnsureCapacity
<
ActualAlloc
>
(
aOther
.
Length
(
)
aElemSize
)
)
|
|
!
Allocator
:
:
Successful
(
aOther
.
template
EnsureCapacity
<
Allocator
>
(
Length
(
)
aElemSize
)
)
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
MOZ_ASSERT
(
UsesAutoArrayBuffer
(
)
|
|
aOther
.
UsesAutoArrayBuffer
(
)
"
One
of
the
arrays
should
be
using
its
auto
buffer
.
"
)
;
size_type
smallerLength
=
XPCOM_MIN
(
Length
(
)
aOther
.
Length
(
)
)
;
size_type
largerLength
=
XPCOM_MAX
(
Length
(
)
aOther
.
Length
(
)
)
;
void
*
smallerElements
;
void
*
largerElements
;
if
(
Length
(
)
<
=
aOther
.
Length
(
)
)
{
smallerElements
=
Hdr
(
)
+
1
;
largerElements
=
aOther
.
Hdr
(
)
+
1
;
}
else
{
smallerElements
=
aOther
.
Hdr
(
)
+
1
;
largerElements
=
Hdr
(
)
+
1
;
}
AutoTArray
<
uint8_t
64
*
sizeof
(
void
*
)
>
temp
;
if
(
!
ActualAlloc
:
:
Successful
(
temp
.
template
EnsureCapacity
<
ActualAlloc
>
(
smallerLength
*
aElemSize
sizeof
(
uint8_t
)
)
)
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
RelocationStrategy
:
:
RelocateNonOverlappingRegion
(
temp
.
Elements
(
)
smallerElements
smallerLength
aElemSize
)
;
RelocationStrategy
:
:
RelocateNonOverlappingRegion
(
smallerElements
largerElements
largerLength
aElemSize
)
;
RelocationStrategy
:
:
RelocateNonOverlappingRegion
(
largerElements
temp
.
Elements
(
)
smallerLength
aElemSize
)
;
MOZ_ASSERT
(
(
aOther
.
Length
(
)
=
=
0
|
|
!
HasEmptyHeader
(
)
)
&
&
(
Length
(
)
=
=
0
|
|
!
aOther
.
HasEmptyHeader
(
)
)
"
Don
'
t
set
sEmptyTArrayHeader
'
s
length
.
"
)
;
size_type
tempLength
=
Length
(
)
;
if
(
!
HasEmptyHeader
(
)
)
{
mHdr
-
>
mLength
=
aOther
.
Length
(
)
;
}
if
(
!
aOther
.
HasEmptyHeader
(
)
)
{
aOther
.
mHdr
-
>
mLength
=
tempLength
;
}
return
ActualAlloc
:
:
SuccessResult
(
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
class
Allocator
>
void
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
MoveInit
(
nsTArray_base
<
Allocator
RelocationStrategy
>
&
aOther
size_type
aElemSize
size_t
aElemAlign
)
{
MOZ_ASSERT
(
Length
(
)
=
=
0
)
;
MOZ_ASSERT
(
Capacity
(
)
=
=
0
|
|
UsesAutoArrayBuffer
(
)
)
;
if
(
(
!
UsesAutoArrayBuffer
(
)
|
|
Capacity
(
)
<
aOther
.
Length
(
)
)
&
&
!
aOther
.
UsesAutoArrayBuffer
(
)
)
{
mHdr
=
aOther
.
mHdr
;
aOther
.
mHdr
=
EmptyHdr
(
)
;
return
;
}
EnsureCapacity
<
nsTArrayInfallibleAllocator
>
(
aOther
.
Length
(
)
aElemSize
)
;
MOZ_ASSERT
(
UsesAutoArrayBuffer
(
)
|
|
aOther
.
UsesAutoArrayBuffer
(
)
"
One
of
the
arrays
should
be
using
its
auto
buffer
.
"
)
;
RelocationStrategy
:
:
RelocateNonOverlappingRegion
(
Hdr
(
)
+
1
aOther
.
Hdr
(
)
+
1
aOther
.
Length
(
)
aElemSize
)
;
MOZ_ASSERT
(
(
aOther
.
Length
(
)
=
=
0
|
|
!
HasEmptyHeader
(
)
)
&
&
(
Length
(
)
=
=
0
|
|
!
aOther
.
HasEmptyHeader
(
)
)
"
Don
'
t
set
sEmptyTArrayHeader
'
s
length
.
"
)
;
if
(
!
HasEmptyHeader
(
)
)
{
mHdr
-
>
mLength
=
aOther
.
Length
(
)
;
}
if
(
!
aOther
.
HasEmptyHeader
(
)
)
{
aOther
.
mHdr
-
>
mLength
=
0
;
}
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
class
Allocator
>
void
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
MoveConstructNonAutoArray
(
nsTArray_base
<
Allocator
RelocationStrategy
>
&
aOther
size_type
aElemSize
size_t
aElemAlign
)
{
mHdr
=
aOther
.
template
TakeHeaderForMove
<
nsTArrayInfallibleAllocator
>
(
aElemSize
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
>
auto
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
TakeHeaderForMove
(
size_type
aElemSize
)
-
>
Header
*
{
if
(
IsEmpty
(
)
)
{
return
EmptyHdr
(
)
;
}
if
(
!
UsesAutoArrayBuffer
(
)
)
{
return
std
:
:
exchange
(
mHdr
EmptyHdr
(
)
)
;
}
size_type
size
=
sizeof
(
Header
)
+
Length
(
)
*
aElemSize
;
Header
*
header
=
static_cast
<
Header
*
>
(
ActualAlloc
:
:
Malloc
(
size
)
)
;
if
(
!
header
)
{
return
nullptr
;
}
RelocationStrategy
:
:
RelocateNonOverlappingRegionWithHeader
(
header
mHdr
Length
(
)
aElemSize
)
;
header
-
>
mCapacity
=
Length
(
)
;
header
-
>
mIsAutoBuffer
=
false
;
mHdr
-
>
mLength
=
0
;
MOZ_ASSERT
(
UsesAutoArrayBuffer
(
)
)
;
MOZ_ASSERT
(
IsEmpty
(
)
)
;
return
header
;
}
