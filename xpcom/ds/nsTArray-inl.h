#
ifndef
nsTArray_h__
#
error
"
Don
'
t
include
this
file
directly
"
#
endif
template
<
class
Alloc
class
RelocationStrategy
>
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
nsTArray_base
(
)
:
mHdr
(
EmptyHdr
(
)
)
{
MOZ_COUNT_CTOR
(
nsTArray_base
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
~
nsTArray_base
(
)
{
if
(
!
HasEmptyHeader
(
)
&
&
!
UsesAutoArrayBuffer
(
)
)
{
Alloc
:
:
Free
(
mHdr
)
;
}
MOZ_COUNT_DTOR
(
nsTArray_base
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
nsTArray_base
(
const
nsTArray_base
&
)
:
mHdr
(
EmptyHdr
(
)
)
{
MOZ_COUNT_CTOR
(
nsTArray_base
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
nsTArray_base
<
Alloc
RelocationStrategy
>
&
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
operator
=
(
const
nsTArray_base
&
)
{
return
*
this
;
}
template
<
class
Alloc
class
RelocationStrategy
>
const
nsTArrayHeader
*
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
GetAutoArrayBufferUnsafe
(
size_t
aElemAlign
)
const
{
const
void
*
autoBuf
=
&
reinterpret_cast
<
const
AutoTArray
<
nsTArray
<
uint32_t
>
1
>
*
>
(
this
)
-
>
mAutoBuf
;
static_assert
(
sizeof
(
void
*
)
!
=
4
|
|
(
MOZ_ALIGNOF
(
mozilla
:
:
AlignedElem
<
8
>
)
=
=
8
&
&
sizeof
(
AutoTArray
<
mozilla
:
:
AlignedElem
<
8
>
1
>
)
=
=
sizeof
(
void
*
)
+
sizeof
(
nsTArrayHeader
)
+
4
+
sizeof
(
mozilla
:
:
AlignedElem
<
8
>
)
)
"
auto
array
padding
wasn
'
t
what
we
expected
"
)
;
MOZ_ASSERT
(
aElemAlign
<
=
4
|
|
aElemAlign
=
=
8
"
unsupported
alignment
.
"
)
;
if
(
sizeof
(
void
*
)
=
=
4
&
&
aElemAlign
=
=
8
)
{
autoBuf
=
reinterpret_cast
<
const
char
*
>
(
autoBuf
)
+
4
;
}
return
reinterpret_cast
<
const
Header
*
>
(
autoBuf
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
bool
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
UsesAutoArrayBuffer
(
)
const
{
if
(
!
mHdr
-
>
mIsAutoArray
)
{
return
false
;
}
static_assert
(
sizeof
(
nsTArrayHeader
)
>
4
"
see
comment
above
"
)
;
#
ifdef
DEBUG
ptrdiff_t
diff
=
reinterpret_cast
<
const
char
*
>
(
GetAutoArrayBuffer
(
8
)
)
-
reinterpret_cast
<
const
char
*
>
(
GetAutoArrayBuffer
(
4
)
)
;
MOZ_ASSERT
(
diff
>
=
0
&
&
diff
<
=
4
"
GetAutoArrayBuffer
doesn
'
t
do
what
we
expect
.
"
)
;
#
endif
return
mHdr
=
=
GetAutoArrayBuffer
(
4
)
|
|
mHdr
=
=
GetAutoArrayBuffer
(
8
)
;
}
bool
IsTwiceTheRequiredBytesRepresentableAsUint32
(
size_t
aCapacity
size_t
aElemSize
)
;
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
>
typename
ActualAlloc
:
:
ResultTypeProxy
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
ExtendCapacity
(
size_type
aLength
size_type
aCount
size_type
aElemSize
)
{
mozilla
:
:
CheckedInt
<
size_type
>
newLength
=
aLength
;
newLength
+
=
aCount
;
if
(
!
newLength
.
isValid
(
)
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
return
this
-
>
EnsureCapacity
<
ActualAlloc
>
(
newLength
.
value
(
)
aElemSize
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
>
typename
ActualAlloc
:
:
ResultTypeProxy
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
EnsureCapacity
(
size_type
aCapacity
size_type
aElemSize
)
{
if
(
aCapacity
<
=
mHdr
-
>
mCapacity
)
{
return
ActualAlloc
:
:
SuccessResult
(
)
;
}
if
(
!
IsTwiceTheRequiredBytesRepresentableAsUint32
(
aCapacity
aElemSize
)
)
{
ActualAlloc
:
:
SizeTooBig
(
(
size_t
)
aCapacity
*
aElemSize
)
;
return
ActualAlloc
:
:
FailureResult
(
)
;
}
size_t
reqSize
=
sizeof
(
Header
)
+
aCapacity
*
aElemSize
;
if
(
HasEmptyHeader
(
)
)
{
Header
*
header
=
static_cast
<
Header
*
>
(
ActualAlloc
:
:
Malloc
(
reqSize
)
)
;
if
(
!
header
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
header
-
>
mLength
=
0
;
header
-
>
mCapacity
=
aCapacity
;
header
-
>
mIsAutoArray
=
0
;
mHdr
=
header
;
return
ActualAlloc
:
:
SuccessResult
(
)
;
}
const
size_t
slowGrowthThreshold
=
8
*
1024
*
1024
;
size_t
bytesToAlloc
;
if
(
reqSize
>
=
slowGrowthThreshold
)
{
size_t
currSize
=
sizeof
(
Header
)
+
Capacity
(
)
*
aElemSize
;
size_t
minNewSize
=
currSize
+
(
currSize
>
>
3
)
;
bytesToAlloc
=
reqSize
>
minNewSize
?
reqSize
:
minNewSize
;
const
size_t
MiB
=
1
<
<
20
;
bytesToAlloc
=
MiB
*
(
(
bytesToAlloc
+
MiB
-
1
)
/
MiB
)
;
}
else
{
bytesToAlloc
=
mozilla
:
:
RoundUpPow2
(
reqSize
)
;
}
Header
*
header
;
if
(
UsesAutoArrayBuffer
(
)
|
|
!
RelocationStrategy
:
:
allowRealloc
)
{
header
=
static_cast
<
Header
*
>
(
ActualAlloc
:
:
Malloc
(
bytesToAlloc
)
)
;
if
(
!
header
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
RelocationStrategy
:
:
RelocateNonOverlappingRegionWithHeader
(
header
mHdr
Length
(
)
aElemSize
)
;
if
(
!
UsesAutoArrayBuffer
(
)
)
{
ActualAlloc
:
:
Free
(
mHdr
)
;
}
}
else
{
header
=
static_cast
<
Header
*
>
(
ActualAlloc
:
:
Realloc
(
mHdr
bytesToAlloc
)
)
;
if
(
!
header
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
}
size_t
newCapacity
=
(
bytesToAlloc
-
sizeof
(
Header
)
)
/
aElemSize
;
MOZ_ASSERT
(
newCapacity
>
=
aCapacity
"
Didn
'
t
enlarge
the
array
enough
!
"
)
;
header
-
>
mCapacity
=
newCapacity
;
mHdr
=
header
;
return
ActualAlloc
:
:
SuccessResult
(
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
void
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
ShrinkCapacity
(
size_type
aElemSize
size_t
aElemAlign
)
{
if
(
HasEmptyHeader
(
)
|
|
UsesAutoArrayBuffer
(
)
)
{
return
;
}
if
(
mHdr
-
>
mLength
>
=
mHdr
-
>
mCapacity
)
{
return
;
}
size_type
length
=
Length
(
)
;
if
(
IsAutoArray
(
)
&
&
GetAutoArrayBuffer
(
aElemAlign
)
-
>
mCapacity
>
=
length
)
{
Header
*
header
=
GetAutoArrayBuffer
(
aElemAlign
)
;
header
-
>
mLength
=
length
;
RelocationStrategy
:
:
RelocateNonOverlappingRegion
(
header
+
1
mHdr
+
1
length
aElemSize
)
;
nsTArrayFallibleAllocator
:
:
Free
(
mHdr
)
;
mHdr
=
header
;
return
;
}
if
(
length
=
=
0
)
{
MOZ_ASSERT
(
!
IsAutoArray
(
)
"
autoarray
should
have
fit
0
elements
"
)
;
nsTArrayFallibleAllocator
:
:
Free
(
mHdr
)
;
mHdr
=
EmptyHdr
(
)
;
return
;
}
size_type
size
=
sizeof
(
Header
)
+
length
*
aElemSize
;
void
*
ptr
=
nsTArrayFallibleAllocator
:
:
Realloc
(
mHdr
size
)
;
if
(
!
ptr
)
{
return
;
}
mHdr
=
static_cast
<
Header
*
>
(
ptr
)
;
mHdr
-
>
mCapacity
=
length
;
}
template
<
class
Alloc
class
RelocationStrategy
>
void
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
ShrinkCapacityToZero
(
size_type
aElemSize
size_t
aElemAlign
)
{
MOZ_ASSERT
(
mHdr
-
>
mLength
=
=
0
)
;
if
(
HasEmptyHeader
(
)
|
|
UsesAutoArrayBuffer
(
)
)
{
return
;
}
const
bool
isAutoArray
=
IsAutoArray
(
)
;
nsTArrayFallibleAllocator
:
:
Free
(
mHdr
)
;
if
(
isAutoArray
)
{
mHdr
=
GetAutoArrayBufferUnsafe
(
aElemAlign
)
;
mHdr
-
>
mLength
=
0
;
}
else
{
mHdr
=
EmptyHdr
(
)
;
}
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
>
void
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
ShiftData
(
index_type
aStart
size_type
aOldLen
size_type
aNewLen
size_type
aElemSize
size_t
aElemAlign
)
{
if
(
aOldLen
=
=
aNewLen
)
{
return
;
}
size_type
num
=
mHdr
-
>
mLength
-
(
aStart
+
aOldLen
)
;
mHdr
-
>
mLength
+
=
aNewLen
-
aOldLen
;
if
(
mHdr
-
>
mLength
=
=
0
)
{
ShrinkCapacityToZero
(
aElemSize
aElemAlign
)
;
}
else
{
if
(
num
=
=
0
)
{
return
;
}
aStart
*
=
aElemSize
;
aNewLen
*
=
aElemSize
;
aOldLen
*
=
aElemSize
;
char
*
baseAddr
=
reinterpret_cast
<
char
*
>
(
mHdr
+
1
)
+
aStart
;
RelocationStrategy
:
:
RelocateOverlappingRegion
(
baseAddr
+
aNewLen
baseAddr
+
aOldLen
num
aElemSize
)
;
}
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
>
void
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
SwapFromEnd
(
index_type
aStart
size_type
aCount
size_type
aElemSize
size_t
aElemAlign
)
{
if
(
aCount
=
=
0
)
{
return
;
}
size_type
oldLength
=
mHdr
-
>
mLength
;
mHdr
-
>
mLength
-
=
aCount
;
if
(
mHdr
-
>
mLength
=
=
0
)
{
ShrinkCapacityToZero
(
aElemSize
aElemAlign
)
;
return
;
}
size_type
relocCount
=
std
:
:
min
(
aCount
mHdr
-
>
mLength
-
aStart
)
;
if
(
relocCount
=
=
0
)
{
return
;
}
index_type
sourceBytes
=
(
oldLength
-
relocCount
)
*
aElemSize
;
index_type
destBytes
=
aStart
*
aElemSize
;
MOZ_ASSERT
(
sourceBytes
>
=
destBytes
"
The
source
should
be
after
the
destination
.
"
)
;
MOZ_ASSERT
(
sourceBytes
-
destBytes
>
=
relocCount
*
aElemSize
"
The
range
should
be
nonoverlapping
"
)
;
char
*
baseAddr
=
reinterpret_cast
<
char
*
>
(
mHdr
+
1
)
;
RelocationStrategy
:
:
RelocateNonOverlappingRegion
(
baseAddr
+
destBytes
baseAddr
+
sourceBytes
relocCount
aElemSize
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
>
typename
ActualAlloc
:
:
ResultTypeProxy
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
InsertSlotsAt
(
index_type
aIndex
size_type
aCount
size_type
aElemSize
size_t
aElemAlign
)
{
if
(
MOZ_UNLIKELY
(
aIndex
>
Length
(
)
)
)
{
InvalidArrayIndex_CRASH
(
aIndex
Length
(
)
)
;
}
if
(
!
ActualAlloc
:
:
Successful
(
this
-
>
ExtendCapacity
<
ActualAlloc
>
(
Length
(
)
aCount
aElemSize
)
)
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
ShiftData
<
ActualAlloc
>
(
aIndex
0
aCount
aElemSize
aElemAlign
)
;
return
ActualAlloc
:
:
SuccessResult
(
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
IsAutoArrayRestorer
:
:
IsAutoArrayRestorer
(
nsTArray_base
<
Alloc
RelocationStrategy
>
&
aArray
size_t
aElemAlign
)
:
mArray
(
aArray
)
mElemAlign
(
aElemAlign
)
mIsAuto
(
aArray
.
IsAutoArray
(
)
)
{
}
template
<
class
Alloc
class
RelocationStrategy
>
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
IsAutoArrayRestorer
:
:
~
IsAutoArrayRestorer
(
)
{
if
(
mIsAuto
&
&
mArray
.
HasEmptyHeader
(
)
)
{
mArray
.
mHdr
=
mArray
.
GetAutoArrayBufferUnsafe
(
mElemAlign
)
;
mArray
.
mHdr
-
>
mLength
=
0
;
}
else
if
(
!
mArray
.
HasEmptyHeader
(
)
)
{
mArray
.
mHdr
-
>
mIsAutoArray
=
mIsAuto
;
}
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
class
Allocator
>
typename
ActualAlloc
:
:
ResultTypeProxy
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
SwapArrayElements
(
nsTArray_base
<
Allocator
RelocationStrategy
>
&
aOther
size_type
aElemSize
size_t
aElemAlign
)
{
IsAutoArrayRestorer
ourAutoRestorer
(
*
this
aElemAlign
)
;
typename
nsTArray_base
<
Allocator
RelocationStrategy
>
:
:
IsAutoArrayRestorer
otherAutoRestorer
(
aOther
aElemAlign
)
;
if
(
(
!
UsesAutoArrayBuffer
(
)
|
|
Capacity
(
)
<
aOther
.
Length
(
)
)
&
&
(
!
aOther
.
UsesAutoArrayBuffer
(
)
|
|
aOther
.
Capacity
(
)
<
Length
(
)
)
)
{
if
(
!
EnsureNotUsingAutoArrayBuffer
<
ActualAlloc
>
(
aElemSize
)
|
|
!
aOther
.
template
EnsureNotUsingAutoArrayBuffer
<
ActualAlloc
>
(
aElemSize
)
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
Header
*
temp
=
mHdr
;
mHdr
=
aOther
.
mHdr
;
aOther
.
mHdr
=
temp
;
return
ActualAlloc
:
:
SuccessResult
(
)
;
}
if
(
!
ActualAlloc
:
:
Successful
(
EnsureCapacity
<
ActualAlloc
>
(
aOther
.
Length
(
)
aElemSize
)
)
|
|
!
Allocator
:
:
Successful
(
aOther
.
template
EnsureCapacity
<
Allocator
>
(
Length
(
)
aElemSize
)
)
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
MOZ_ASSERT
(
UsesAutoArrayBuffer
(
)
|
|
aOther
.
UsesAutoArrayBuffer
(
)
"
One
of
the
arrays
should
be
using
its
auto
buffer
.
"
)
;
size_type
smallerLength
=
XPCOM_MIN
(
Length
(
)
aOther
.
Length
(
)
)
;
size_type
largerLength
=
XPCOM_MAX
(
Length
(
)
aOther
.
Length
(
)
)
;
void
*
smallerElements
;
void
*
largerElements
;
if
(
Length
(
)
<
=
aOther
.
Length
(
)
)
{
smallerElements
=
Hdr
(
)
+
1
;
largerElements
=
aOther
.
Hdr
(
)
+
1
;
}
else
{
smallerElements
=
aOther
.
Hdr
(
)
+
1
;
largerElements
=
Hdr
(
)
+
1
;
}
AutoTArray
<
uint8_t
64
*
sizeof
(
void
*
)
>
temp
;
if
(
!
ActualAlloc
:
:
Successful
(
temp
.
template
EnsureCapacity
<
ActualAlloc
>
(
smallerLength
*
aElemSize
sizeof
(
uint8_t
)
)
)
)
{
return
ActualAlloc
:
:
FailureResult
(
)
;
}
RelocationStrategy
:
:
RelocateNonOverlappingRegion
(
temp
.
Elements
(
)
smallerElements
smallerLength
aElemSize
)
;
RelocationStrategy
:
:
RelocateNonOverlappingRegion
(
smallerElements
largerElements
largerLength
aElemSize
)
;
RelocationStrategy
:
:
RelocateNonOverlappingRegion
(
largerElements
temp
.
Elements
(
)
smallerLength
aElemSize
)
;
MOZ_ASSERT
(
(
aOther
.
Length
(
)
=
=
0
|
|
!
HasEmptyHeader
(
)
)
&
&
(
Length
(
)
=
=
0
|
|
!
aOther
.
HasEmptyHeader
(
)
)
"
Don
'
t
set
sEmptyTArrayHeader
'
s
length
.
"
)
;
size_type
tempLength
=
Length
(
)
;
if
(
!
HasEmptyHeader
(
)
)
{
mHdr
-
>
mLength
=
aOther
.
Length
(
)
;
}
if
(
!
aOther
.
HasEmptyHeader
(
)
)
{
aOther
.
mHdr
-
>
mLength
=
tempLength
;
}
return
ActualAlloc
:
:
SuccessResult
(
)
;
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
class
Allocator
>
void
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
MoveInit
(
nsTArray_base
<
Allocator
RelocationStrategy
>
&
aOther
size_type
aElemSize
size_t
aElemAlign
)
{
MOZ_ASSERT
(
Length
(
)
=
=
0
)
;
MOZ_ASSERT
(
Capacity
(
)
=
=
0
|
|
(
IsAutoArray
(
)
&
&
UsesAutoArrayBuffer
(
)
)
)
;
IsAutoArrayRestorer
ourAutoRestorer
(
*
this
aElemAlign
)
;
typename
nsTArray_base
<
Allocator
RelocationStrategy
>
:
:
IsAutoArrayRestorer
otherAutoRestorer
(
aOther
aElemAlign
)
;
if
(
(
!
IsAutoArray
(
)
|
|
Capacity
(
)
<
aOther
.
Length
(
)
)
&
&
!
aOther
.
UsesAutoArrayBuffer
(
)
)
{
mHdr
=
aOther
.
mHdr
;
aOther
.
mHdr
=
EmptyHdr
(
)
;
return
;
}
EnsureCapacity
<
nsTArrayInfallibleAllocator
>
(
aOther
.
Length
(
)
aElemSize
)
;
MOZ_ASSERT
(
UsesAutoArrayBuffer
(
)
|
|
aOther
.
UsesAutoArrayBuffer
(
)
"
One
of
the
arrays
should
be
using
its
auto
buffer
.
"
)
;
RelocationStrategy
:
:
RelocateNonOverlappingRegion
(
Hdr
(
)
+
1
aOther
.
Hdr
(
)
+
1
aOther
.
Length
(
)
aElemSize
)
;
MOZ_ASSERT
(
(
aOther
.
Length
(
)
=
=
0
|
|
!
HasEmptyHeader
(
)
)
&
&
(
Length
(
)
=
=
0
|
|
!
aOther
.
HasEmptyHeader
(
)
)
"
Don
'
t
set
sEmptyTArrayHeader
'
s
length
.
"
)
;
if
(
!
HasEmptyHeader
(
)
)
{
mHdr
-
>
mLength
=
aOther
.
Length
(
)
;
}
if
(
!
aOther
.
HasEmptyHeader
(
)
)
{
aOther
.
mHdr
-
>
mLength
=
0
;
}
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
class
Allocator
>
void
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
MoveConstructNonAutoArray
(
nsTArray_base
<
Allocator
RelocationStrategy
>
&
aOther
size_type
aElemSize
size_t
aElemAlign
)
{
if
(
aOther
.
IsEmpty
(
)
)
{
return
;
}
const
bool
otherUsesAutoArrayBuffer
=
aOther
.
UsesAutoArrayBuffer
(
)
;
if
(
otherUsesAutoArrayBuffer
)
{
aOther
.
template
EnsureNotUsingAutoArrayBuffer
<
nsTArrayInfallibleAllocator
>
(
aElemSize
)
;
}
const
bool
otherIsAuto
=
otherUsesAutoArrayBuffer
|
|
aOther
.
IsAutoArray
(
)
;
mHdr
=
aOther
.
mHdr
;
MOZ_ASSERT
(
!
HasEmptyHeader
(
)
)
;
if
(
otherIsAuto
)
{
mHdr
-
>
mIsAutoArray
=
false
;
aOther
.
mHdr
=
aOther
.
GetAutoArrayBufferUnsafe
(
aElemAlign
)
;
aOther
.
mHdr
-
>
mLength
=
0
;
}
else
{
aOther
.
mHdr
=
aOther
.
EmptyHdr
(
)
;
}
}
template
<
class
Alloc
class
RelocationStrategy
>
template
<
typename
ActualAlloc
>
bool
nsTArray_base
<
Alloc
RelocationStrategy
>
:
:
EnsureNotUsingAutoArrayBuffer
(
size_type
aElemSize
)
{
if
(
UsesAutoArrayBuffer
(
)
)
{
if
(
Length
(
)
=
=
0
)
{
mHdr
=
EmptyHdr
(
)
;
return
true
;
}
size_type
size
=
sizeof
(
Header
)
+
Length
(
)
*
aElemSize
;
Header
*
header
=
static_cast
<
Header
*
>
(
ActualAlloc
:
:
Malloc
(
size
)
)
;
if
(
!
header
)
{
return
false
;
}
RelocationStrategy
:
:
RelocateNonOverlappingRegionWithHeader
(
header
mHdr
Length
(
)
aElemSize
)
;
header
-
>
mCapacity
=
Length
(
)
;
mHdr
=
header
;
}
return
true
;
}
