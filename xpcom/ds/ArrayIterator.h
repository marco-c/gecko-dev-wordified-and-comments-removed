#
ifndef
mozilla_ArrayIterator_h
#
define
mozilla_ArrayIterator_h
#
include
<
iterator
>
#
include
<
type_traits
>
#
include
"
mozilla
/
TypeTraits
.
h
"
namespace
mozilla
{
namespace
detail
{
template
<
typename
T
>
struct
AddInnerConst
;
template
<
typename
T
>
struct
AddInnerConst
<
T
&
>
{
using
Type
=
const
T
&
;
}
;
template
<
typename
T
>
struct
AddInnerConst
<
T
*
>
{
using
Type
=
const
T
*
;
}
;
template
<
typename
T
>
using
AddInnerConstT
=
typename
AddInnerConst
<
T
>
:
:
Type
;
}
template
<
class
Element
class
ArrayType
>
class
ArrayIterator
{
public
:
typedef
ArrayType
array_type
;
typedef
ArrayIterator
<
Element
ArrayType
>
iterator_type
;
typedef
typename
array_type
:
:
index_type
index_type
;
typedef
std
:
:
remove_reference_t
<
Element
>
value_type
;
typedef
ptrdiff_t
difference_type
;
typedef
value_type
*
pointer
;
typedef
value_type
&
reference
;
typedef
std
:
:
random_access_iterator_tag
iterator_category
;
typedef
ArrayIterator
<
detail
:
:
AddInnerConstT
<
Element
>
ArrayType
>
const_iterator_type
;
private
:
const
array_type
*
mArray
;
index_type
mIndex
;
public
:
ArrayIterator
(
)
:
mArray
(
nullptr
)
mIndex
(
0
)
{
}
ArrayIterator
(
const
iterator_type
&
aOther
)
:
mArray
(
aOther
.
mArray
)
mIndex
(
aOther
.
mIndex
)
{
}
ArrayIterator
(
const
array_type
&
aArray
index_type
aIndex
)
:
mArray
(
&
aArray
)
mIndex
(
aIndex
)
{
}
iterator_type
&
operator
=
(
const
iterator_type
&
aOther
)
{
mArray
=
aOther
.
mArray
;
mIndex
=
aOther
.
mIndex
;
return
*
this
;
}
constexpr
operator
const_iterator_type
(
)
const
{
return
mArray
?
const_iterator_type
{
*
mArray
mIndex
}
:
const_iterator_type
{
}
;
}
bool
operator
=
=
(
const
iterator_type
&
aRhs
)
const
{
return
mIndex
=
=
aRhs
.
mIndex
;
}
bool
operator
!
=
(
const
iterator_type
&
aRhs
)
const
{
return
!
(
*
this
=
=
aRhs
)
;
}
bool
operator
<
(
const
iterator_type
&
aRhs
)
const
{
return
mIndex
<
aRhs
.
mIndex
;
}
bool
operator
>
(
const
iterator_type
&
aRhs
)
const
{
return
mIndex
>
aRhs
.
mIndex
;
}
bool
operator
<
=
(
const
iterator_type
&
aRhs
)
const
{
return
mIndex
<
=
aRhs
.
mIndex
;
}
bool
operator
>
=
(
const
iterator_type
&
aRhs
)
const
{
return
mIndex
>
=
aRhs
.
mIndex
;
}
value_type
*
operator
-
>
(
)
const
{
return
const_cast
<
value_type
*
>
(
&
mArray
-
>
ElementAt
(
mIndex
)
)
;
}
Element
operator
*
(
)
const
{
return
const_cast
<
Element
>
(
mArray
-
>
ElementAt
(
mIndex
)
)
;
}
iterator_type
&
operator
+
+
(
)
{
+
+
mIndex
;
return
*
this
;
}
iterator_type
operator
+
+
(
int
)
{
iterator_type
it
=
*
this
;
+
+
*
this
;
return
it
;
}
iterator_type
&
operator
-
-
(
)
{
-
-
mIndex
;
return
*
this
;
}
iterator_type
operator
-
-
(
int
)
{
iterator_type
it
=
*
this
;
-
-
*
this
;
return
it
;
}
iterator_type
&
operator
+
=
(
difference_type
aDiff
)
{
mIndex
+
=
aDiff
;
return
*
this
;
}
iterator_type
&
operator
-
=
(
difference_type
aDiff
)
{
mIndex
-
=
aDiff
;
return
*
this
;
}
iterator_type
operator
+
(
difference_type
aDiff
)
const
{
iterator_type
it
=
*
this
;
it
+
=
aDiff
;
return
it
;
}
iterator_type
operator
-
(
difference_type
aDiff
)
const
{
iterator_type
it
=
*
this
;
it
-
=
aDiff
;
return
it
;
}
difference_type
operator
-
(
const
iterator_type
&
aOther
)
const
{
return
static_cast
<
difference_type
>
(
mIndex
)
-
static_cast
<
difference_type
>
(
aOther
.
mIndex
)
;
}
Element
operator
[
]
(
difference_type
aIndex
)
const
{
return
*
this
-
>
operator
+
(
aIndex
)
;
}
constexpr
const
array_type
*
GetArray
(
)
const
{
return
mArray
;
}
constexpr
index_type
GetIndex
(
)
const
{
return
mIndex
;
}
}
;
}
#
endif
