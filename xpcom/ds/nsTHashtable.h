#
ifndef
nsTHashtable_h__
#
define
nsTHashtable_h__
#
include
"
PLDHashTable
.
h
"
#
include
"
nsPointerHashKeys
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
<
new
>
template
<
class
EntryType
>
class
MOZ_NEEDS_NO_VTABLE_TYPE
nsTHashtable
{
typedef
mozilla
:
:
fallible_t
fallible_t
;
static_assert
(
mozilla
:
:
IsPointer
<
typename
EntryType
:
:
KeyTypePointer
>
:
:
value
"
KeyTypePointer
should
be
a
pointer
"
)
;
public
:
nsTHashtable
(
)
:
mTable
(
Ops
(
)
sizeof
(
EntryType
)
PLDHashTable
:
:
kDefaultInitialLength
)
{
}
explicit
nsTHashtable
(
uint32_t
aInitLength
)
:
mTable
(
Ops
(
)
sizeof
(
EntryType
)
aInitLength
)
{
}
~
nsTHashtable
(
)
;
nsTHashtable
(
nsTHashtable
<
EntryType
>
&
&
aOther
)
;
uint32_t
GetGeneration
(
)
const
{
return
mTable
.
Generation
(
)
;
}
typedef
typename
EntryType
:
:
KeyType
KeyType
;
typedef
typename
EntryType
:
:
KeyTypePointer
KeyTypePointer
;
uint32_t
Count
(
)
const
{
return
mTable
.
EntryCount
(
)
;
}
bool
IsEmpty
(
)
const
{
return
Count
(
)
=
=
0
;
}
EntryType
*
GetEntry
(
KeyType
aKey
)
const
{
return
static_cast
<
EntryType
*
>
(
mTable
.
Search
(
EntryType
:
:
KeyToPointer
(
aKey
)
)
)
;
}
bool
Contains
(
KeyType
aKey
)
const
{
return
!
!
GetEntry
(
aKey
)
;
}
EntryType
*
PutEntry
(
KeyType
aKey
)
{
return
static_cast
<
EntryType
*
>
(
mTable
.
Add
(
EntryType
:
:
KeyToPointer
(
aKey
)
)
)
;
}
MOZ_MUST_USE
EntryType
*
PutEntry
(
KeyType
aKey
const
fallible_t
&
)
{
return
static_cast
<
EntryType
*
>
(
mTable
.
Add
(
EntryType
:
:
KeyToPointer
(
aKey
)
mozilla
:
:
fallible
)
)
;
}
MOZ_MUST_USE
bool
EnsureInserted
(
KeyType
aKey
EntryType
*
*
aEntry
=
nullptr
)
{
auto
oldCount
=
Count
(
)
;
EntryType
*
entry
=
PutEntry
(
aKey
)
;
if
(
aEntry
)
{
*
aEntry
=
entry
;
}
return
oldCount
!
=
Count
(
)
;
}
void
RemoveEntry
(
KeyType
aKey
)
{
mTable
.
Remove
(
EntryType
:
:
KeyToPointer
(
aKey
)
)
;
}
bool
EnsureRemoved
(
KeyType
aKey
)
{
auto
*
entry
=
GetEntry
(
aKey
)
;
if
(
entry
)
{
RemoveEntry
(
entry
)
;
return
true
;
}
return
false
;
}
void
RemoveEntry
(
EntryType
*
aEntry
)
{
mTable
.
RemoveEntry
(
aEntry
)
;
}
void
RawRemoveEntry
(
EntryType
*
aEntry
)
{
mTable
.
RawRemove
(
aEntry
)
;
}
class
Iterator
:
public
PLDHashTable
:
:
Iterator
{
public
:
typedef
PLDHashTable
:
:
Iterator
Base
;
explicit
Iterator
(
nsTHashtable
*
aTable
)
:
Base
(
&
aTable
-
>
mTable
)
{
}
Iterator
(
Iterator
&
&
aOther
)
:
Base
(
aOther
.
mTable
)
{
}
~
Iterator
(
)
{
}
EntryType
*
Get
(
)
const
{
return
static_cast
<
EntryType
*
>
(
Base
:
:
Get
(
)
)
;
}
private
:
Iterator
(
)
=
delete
;
Iterator
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
&
)
=
delete
;
}
;
Iterator
Iter
(
)
{
return
Iterator
(
this
)
;
}
Iterator
ConstIter
(
)
const
{
return
Iterator
(
const_cast
<
nsTHashtable
*
>
(
this
)
)
;
}
void
Clear
(
)
{
mTable
.
Clear
(
)
;
}
size_t
ShallowSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
mTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
ShallowSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
=
(
*
iter
.
Get
(
)
)
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
void
SwapElements
(
nsTHashtable
<
EntryType
>
&
aOther
)
{
MOZ_ASSERT_IF
(
this
-
>
mTable
.
Ops
(
)
&
&
aOther
.
mTable
.
Ops
(
)
this
-
>
mTable
.
Ops
(
)
=
=
aOther
.
mTable
.
Ops
(
)
)
;
mozilla
:
:
Swap
(
this
-
>
mTable
aOther
.
mTable
)
;
}
#
ifdef
DEBUG
void
MarkImmutable
(
)
{
mTable
.
MarkImmutable
(
)
;
}
#
endif
protected
:
PLDHashTable
mTable
;
static
PLDHashNumber
s_HashKey
(
const
void
*
aKey
)
;
static
bool
s_MatchEntry
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
;
static
void
s_CopyEntry
(
PLDHashTable
*
aTable
const
PLDHashEntryHdr
*
aFrom
PLDHashEntryHdr
*
aTo
)
;
static
void
s_ClearEntry
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
;
static
void
s_InitEntry
(
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
;
private
:
nsTHashtable
(
nsTHashtable
<
EntryType
>
&
aToCopy
)
=
delete
;
static
const
PLDHashTableOps
*
Ops
(
)
;
nsTHashtable
<
EntryType
>
&
operator
=
(
nsTHashtable
<
EntryType
>
&
aToEqual
)
=
delete
;
}
;
namespace
mozilla
{
namespace
detail
{
template
<
size_t
N
>
static
void
FixedSizeEntryMover
(
PLDHashTable
*
const
PLDHashEntryHdr
*
aFrom
PLDHashEntryHdr
*
aTo
)
{
memcpy
(
aTo
aFrom
N
)
;
}
}
}
template
<
class
EntryType
>
nsTHashtable
<
EntryType
>
:
:
nsTHashtable
(
nsTHashtable
<
EntryType
>
&
&
aOther
)
:
mTable
(
std
:
:
move
(
aOther
.
mTable
)
)
{
}
template
<
class
EntryType
>
nsTHashtable
<
EntryType
>
:
:
~
nsTHashtable
(
)
{
}
template
<
class
EntryType
>
const
PLDHashTableOps
*
nsTHashtable
<
EntryType
>
:
:
Ops
(
)
{
static
const
PLDHashTableOps
sOps
=
{
s_HashKey
s_MatchEntry
EntryType
:
:
ALLOW_MEMMOVE
?
mozilla
:
:
detail
:
:
FixedSizeEntryMover
<
sizeof
(
EntryType
)
>
:
s_CopyEntry
s_ClearEntry
s_InitEntry
}
;
return
&
sOps
;
}
template
<
class
EntryType
>
PLDHashNumber
nsTHashtable
<
EntryType
>
:
:
s_HashKey
(
const
void
*
aKey
)
{
return
EntryType
:
:
HashKey
(
static_cast
<
KeyTypePointer
>
(
aKey
)
)
;
}
template
<
class
EntryType
>
bool
nsTHashtable
<
EntryType
>
:
:
s_MatchEntry
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
return
(
(
const
EntryType
*
)
aEntry
)
-
>
KeyEquals
(
static_cast
<
KeyTypePointer
>
(
aKey
)
)
;
}
template
<
class
EntryType
>
void
nsTHashtable
<
EntryType
>
:
:
s_CopyEntry
(
PLDHashTable
*
aTable
const
PLDHashEntryHdr
*
aFrom
PLDHashEntryHdr
*
aTo
)
{
EntryType
*
fromEntry
=
const_cast
<
EntryType
*
>
(
static_cast
<
const
EntryType
*
>
(
aFrom
)
)
;
new
(
mozilla
:
:
KnownNotNull
aTo
)
EntryType
(
std
:
:
move
(
*
fromEntry
)
)
;
fromEntry
-
>
~
EntryType
(
)
;
}
template
<
class
EntryType
>
void
nsTHashtable
<
EntryType
>
:
:
s_ClearEntry
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
{
static_cast
<
EntryType
*
>
(
aEntry
)
-
>
~
EntryType
(
)
;
}
template
<
class
EntryType
>
void
nsTHashtable
<
EntryType
>
:
:
s_InitEntry
(
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
new
(
mozilla
:
:
KnownNotNull
aEntry
)
EntryType
(
static_cast
<
KeyTypePointer
>
(
aKey
)
)
;
}
class
nsCycleCollectionTraversalCallback
;
template
<
class
EntryType
>
inline
void
ImplCycleCollectionUnlink
(
nsTHashtable
<
EntryType
>
&
aField
)
{
aField
.
Clear
(
)
;
}
template
<
class
EntryType
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
nsTHashtable
<
EntryType
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
for
(
auto
iter
=
aField
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
EntryType
*
entry
=
iter
.
Get
(
)
;
ImplCycleCollectionTraverse
(
aCallback
*
entry
aName
aFlags
)
;
}
}
namespace
detail
{
class
VoidPtrHashKey
:
public
nsPtrHashKey
<
const
void
>
{
typedef
nsPtrHashKey
<
const
void
>
Base
;
public
:
explicit
VoidPtrHashKey
(
const
void
*
aKey
)
:
Base
(
aKey
)
{
}
}
;
}
template
<
typename
T
>
class
nsTHashtable
<
nsPtrHashKey
<
T
>
>
:
protected
nsTHashtable
<
:
:
detail
:
:
VoidPtrHashKey
>
{
typedef
nsTHashtable
<
:
:
detail
:
:
VoidPtrHashKey
>
Base
;
typedef
nsPtrHashKey
<
T
>
EntryType
;
static_assert
(
sizeof
(
nsPtrHashKey
<
T
>
)
=
=
sizeof
(
:
:
detail
:
:
VoidPtrHashKey
)
"
hash
keys
must
be
the
same
size
"
)
;
nsTHashtable
(
const
nsTHashtable
&
aOther
)
=
delete
;
nsTHashtable
&
operator
=
(
const
nsTHashtable
&
aOther
)
=
delete
;
public
:
nsTHashtable
(
)
=
default
;
explicit
nsTHashtable
(
uint32_t
aInitLength
)
:
Base
(
aInitLength
)
{
}
~
nsTHashtable
(
)
=
default
;
nsTHashtable
(
nsTHashtable
&
&
)
=
default
;
using
Base
:
:
GetGeneration
;
using
Base
:
:
Count
;
using
Base
:
:
IsEmpty
;
using
Base
:
:
Clear
;
using
Base
:
:
ShallowSizeOfExcludingThis
;
using
Base
:
:
ShallowSizeOfIncludingThis
;
#
ifdef
DEBUG
using
Base
:
:
MarkImmutable
;
#
endif
EntryType
*
GetEntry
(
T
*
aKey
)
const
{
return
reinterpret_cast
<
EntryType
*
>
(
Base
:
:
GetEntry
(
aKey
)
)
;
}
bool
Contains
(
T
*
aKey
)
const
{
return
Base
:
:
Contains
(
aKey
)
;
}
EntryType
*
PutEntry
(
T
*
aKey
)
{
return
reinterpret_cast
<
EntryType
*
>
(
Base
:
:
PutEntry
(
aKey
)
)
;
}
MOZ_MUST_USE
EntryType
*
PutEntry
(
T
*
aKey
const
mozilla
:
:
fallible_t
&
)
{
return
reinterpret_cast
<
EntryType
*
>
(
Base
:
:
PutEntry
(
aKey
mozilla
:
:
fallible
)
)
;
}
MOZ_MUST_USE
bool
EnsureInserted
(
T
*
aKey
EntryType
*
*
aEntry
=
nullptr
)
{
return
Base
:
:
EnsureInserted
(
aKey
reinterpret_cast
<
:
:
detail
:
:
VoidPtrHashKey
*
*
>
(
aEntry
)
)
;
}
void
RemoveEntry
(
T
*
aKey
)
{
Base
:
:
RemoveEntry
(
aKey
)
;
}
bool
EnsureRemoved
(
T
*
aKey
)
{
return
Base
:
:
EnsureRemoved
(
aKey
)
;
}
void
RemoveEntry
(
EntryType
*
aEntry
)
{
Base
:
:
RemoveEntry
(
reinterpret_cast
<
:
:
detail
:
:
VoidPtrHashKey
*
>
(
aEntry
)
)
;
}
void
RawRemoveEntry
(
EntryType
*
aEntry
)
{
Base
:
:
RawRemoveEntry
(
reinterpret_cast
<
:
:
detail
:
:
VoidPtrHashKey
*
>
(
aEntry
)
)
;
}
class
Iterator
:
public
Base
:
:
Iterator
{
public
:
typedef
nsTHashtable
:
:
Base
:
:
Iterator
Base
;
explicit
Iterator
(
nsTHashtable
*
aTable
)
:
Base
(
aTable
)
{
}
Iterator
(
Iterator
&
&
aOther
)
:
Base
(
std
:
:
move
(
aOther
)
)
{
}
~
Iterator
(
)
=
default
;
EntryType
*
Get
(
)
const
{
return
reinterpret_cast
<
EntryType
*
>
(
Base
:
:
Get
(
)
)
;
}
private
:
Iterator
(
)
=
delete
;
Iterator
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
Iterator
&
&
)
=
delete
;
}
;
Iterator
Iter
(
)
{
return
Iterator
(
this
)
;
}
Iterator
ConstIter
(
)
const
{
return
Iterator
(
const_cast
<
nsTHashtable
*
>
(
this
)
)
;
}
void
SwapElements
(
nsTHashtable
&
aOther
)
{
Base
:
:
SwapElements
(
aOther
)
;
}
}
;
#
endif
