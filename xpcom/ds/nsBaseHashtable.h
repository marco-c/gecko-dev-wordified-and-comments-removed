#
ifndef
nsBaseHashtable_h__
#
define
nsBaseHashtable_h__
#
include
<
utility
>
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsTHashtable
.
h
"
template
<
class
KeyClass
class
DataType
class
UserDataType
class
Converter
>
class
nsBaseHashtable
;
template
<
class
DataType
class
UserDataType
>
class
nsDefaultConverter
{
public
:
static
UserDataType
Unwrap
(
DataType
&
src
)
{
return
UserDataType
(
src
)
;
}
static
DataType
Wrap
(
const
UserDataType
&
src
)
{
return
DataType
(
src
)
;
}
template
<
typename
U
>
static
DataType
Wrap
(
U
&
&
src
)
{
return
std
:
:
move
(
src
)
;
}
}
;
template
<
class
KeyClass
class
DataType
>
class
nsBaseHashtableET
:
public
KeyClass
{
public
:
const
DataType
&
GetData
(
)
const
{
return
mData
;
}
DataType
*
GetModifiableData
(
)
{
return
&
mData
;
}
template
<
typename
U
>
void
SetData
(
U
&
&
aData
)
{
mData
=
std
:
:
forward
<
U
>
(
aData
)
;
}
private
:
DataType
mData
;
friend
class
nsTHashtable
<
nsBaseHashtableET
<
KeyClass
DataType
>
>
;
template
<
typename
KeyClassX
typename
DataTypeX
typename
UserDataTypeX
typename
ConverterX
>
friend
class
nsBaseHashtable
;
typedef
typename
KeyClass
:
:
KeyType
KeyType
;
typedef
typename
KeyClass
:
:
KeyTypePointer
KeyTypePointer
;
explicit
nsBaseHashtableET
(
KeyTypePointer
aKey
)
;
nsBaseHashtableET
(
nsBaseHashtableET
<
KeyClass
DataType
>
&
&
aToMove
)
;
~
nsBaseHashtableET
(
)
;
}
;
template
<
class
KeyClass
class
DataType
class
UserDataType
class
Converter
=
nsDefaultConverter
<
DataType
UserDataType
>
>
class
nsBaseHashtable
:
protected
nsTHashtable
<
nsBaseHashtableET
<
KeyClass
DataType
>
>
{
typedef
mozilla
:
:
fallible_t
fallible_t
;
public
:
typedef
typename
KeyClass
:
:
KeyType
KeyType
;
typedef
nsBaseHashtableET
<
KeyClass
DataType
>
EntryType
;
using
nsTHashtable
<
EntryType
>
:
:
Contains
;
using
nsTHashtable
<
EntryType
>
:
:
GetGeneration
;
using
nsTHashtable
<
EntryType
>
:
:
SizeOfExcludingThis
;
using
nsTHashtable
<
EntryType
>
:
:
SizeOfIncludingThis
;
nsBaseHashtable
(
)
{
}
explicit
nsBaseHashtable
(
uint32_t
aInitLength
)
:
nsTHashtable
<
EntryType
>
(
aInitLength
)
{
}
uint32_t
Count
(
)
const
{
return
nsTHashtable
<
EntryType
>
:
:
Count
(
)
;
}
bool
IsEmpty
(
)
const
{
return
nsTHashtable
<
EntryType
>
:
:
IsEmpty
(
)
;
}
bool
Get
(
KeyType
aKey
UserDataType
*
aData
)
const
{
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
false
;
}
if
(
aData
)
{
*
aData
=
Converter
:
:
Unwrap
(
ent
-
>
mData
)
;
}
return
true
;
}
UserDataType
Get
(
KeyType
aKey
)
const
{
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
UserDataType
{
}
;
}
return
Converter
:
:
Unwrap
(
ent
-
>
mData
)
;
}
DataType
&
GetOrInsert
(
const
KeyType
&
aKey
)
{
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
)
;
return
ent
-
>
mData
;
}
void
Put
(
KeyType
aKey
const
UserDataType
&
aData
)
{
if
(
!
Put
(
aKey
aData
mozilla
:
:
fallible
)
)
{
NS_ABORT_OOM
(
this
-
>
mTable
.
EntrySize
(
)
*
this
-
>
mTable
.
EntryCount
(
)
)
;
}
}
MOZ_MUST_USE
bool
Put
(
KeyType
aKey
const
UserDataType
&
aData
const
fallible_t
&
)
{
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
mozilla
:
:
fallible
)
;
if
(
!
ent
)
{
return
false
;
}
ent
-
>
mData
=
Converter
:
:
Wrap
(
aData
)
;
return
true
;
}
void
Put
(
KeyType
aKey
UserDataType
&
&
aData
)
{
if
(
!
Put
(
aKey
std
:
:
move
(
aData
)
mozilla
:
:
fallible
)
)
{
NS_ABORT_OOM
(
this
-
>
mTable
.
EntrySize
(
)
*
this
-
>
mTable
.
EntryCount
(
)
)
;
}
}
MOZ_MUST_USE
bool
Put
(
KeyType
aKey
UserDataType
&
&
aData
const
fallible_t
&
)
{
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
mozilla
:
:
fallible
)
;
if
(
!
ent
)
{
return
false
;
}
ent
-
>
mData
=
Converter
:
:
Wrap
(
std
:
:
move
(
aData
)
)
;
return
true
;
}
bool
Remove
(
KeyType
aKey
DataType
*
aData
=
nullptr
)
{
if
(
auto
*
ent
=
this
-
>
GetEntry
(
aKey
)
)
{
if
(
aData
)
{
*
aData
=
std
:
:
move
(
ent
-
>
mData
)
;
}
this
-
>
RemoveEntry
(
ent
)
;
return
true
;
}
if
(
aData
)
{
*
aData
=
std
:
:
move
(
DataType
(
)
)
;
}
return
false
;
}
struct
LookupResult
{
private
:
EntryType
*
mEntry
;
nsBaseHashtable
&
mTable
;
#
ifdef
DEBUG
uint32_t
mTableGeneration
;
#
endif
public
:
LookupResult
(
EntryType
*
aEntry
nsBaseHashtable
&
aTable
)
:
mEntry
(
aEntry
)
mTable
(
aTable
)
#
ifdef
DEBUG
mTableGeneration
(
aTable
.
GetGeneration
(
)
)
#
endif
{
}
explicit
operator
bool
(
)
const
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
return
mEntry
;
}
void
Remove
(
)
{
if
(
!
*
this
)
{
return
;
}
mTable
.
RemoveEntry
(
mEntry
)
;
mEntry
=
nullptr
;
}
MOZ_MUST_USE
DataType
&
Data
(
)
{
MOZ_ASSERT
(
!
!
*
this
"
must
have
an
entry
to
access
its
value
"
)
;
return
mEntry
-
>
mData
;
}
}
;
MOZ_MUST_USE
LookupResult
Lookup
(
KeyType
aKey
)
{
return
LookupResult
(
this
-
>
GetEntry
(
aKey
)
*
this
)
;
}
struct
EntryPtr
{
private
:
EntryType
*
mEntry
;
bool
mExistingEntry
;
nsBaseHashtable
&
mTable
;
#
ifdef
DEBUG
uint32_t
mTableGeneration
;
bool
mDidInitNewEntry
;
#
endif
public
:
EntryPtr
(
nsBaseHashtable
&
aTable
EntryType
*
aEntry
bool
aExistingEntry
)
:
mEntry
(
aEntry
)
mExistingEntry
(
aExistingEntry
)
mTable
(
aTable
)
#
ifdef
DEBUG
mTableGeneration
(
aTable
.
GetGeneration
(
)
)
mDidInitNewEntry
(
false
)
#
endif
{
}
~
EntryPtr
(
)
{
MOZ_ASSERT
(
mExistingEntry
|
|
mDidInitNewEntry
|
|
!
mEntry
"
Forgot
to
call
OrInsert
(
)
or
OrRemove
(
)
on
a
new
entry
"
)
;
}
explicit
operator
bool
(
)
const
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
return
mExistingEntry
;
}
template
<
class
F
>
DataType
&
OrInsert
(
F
func
)
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
MOZ_ASSERT
(
mEntry
)
;
if
(
!
mExistingEntry
)
{
mEntry
-
>
mData
=
Converter
:
:
Wrap
(
func
(
)
)
;
#
ifdef
DEBUG
mDidInitNewEntry
=
true
;
#
endif
}
return
mEntry
-
>
mData
;
}
void
OrRemove
(
)
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
MOZ_ASSERT
(
mEntry
)
;
mTable
.
RemoveEntry
(
mEntry
)
;
mEntry
=
nullptr
;
}
MOZ_MUST_USE
DataType
&
Data
(
)
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
MOZ_ASSERT
(
mEntry
)
;
return
mEntry
-
>
mData
;
}
}
;
MOZ_MUST_USE
EntryPtr
LookupForAdd
(
KeyType
aKey
)
{
auto
count
=
Count
(
)
;
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
)
;
return
EntryPtr
(
*
this
ent
count
=
=
Count
(
)
)
;
}
class
Iterator
:
public
PLDHashTable
:
:
Iterator
{
public
:
typedef
PLDHashTable
:
:
Iterator
Base
;
explicit
Iterator
(
nsBaseHashtable
*
aTable
)
:
Base
(
&
aTable
-
>
mTable
)
{
}
Iterator
(
Iterator
&
&
aOther
)
:
Base
(
aOther
.
mTable
)
{
}
~
Iterator
(
)
{
}
KeyType
Key
(
)
const
{
return
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
GetKey
(
)
;
}
UserDataType
UserData
(
)
const
{
return
Converter
:
:
Unwrap
(
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
mData
)
;
}
DataType
&
Data
(
)
const
{
return
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
mData
;
}
private
:
Iterator
(
)
=
delete
;
Iterator
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
&
)
=
delete
;
}
;
Iterator
Iter
(
)
{
return
Iterator
(
this
)
;
}
Iterator
ConstIter
(
)
const
{
return
Iterator
(
const_cast
<
nsBaseHashtable
*
>
(
this
)
)
;
}
template
<
typename
T
>
class
base_iterator
:
public
std
:
:
iterator
<
std
:
:
forward_iterator_tag
T
int32_t
>
{
public
:
using
typename
std
:
:
iterator
<
std
:
:
forward_iterator_tag
T
int32_t
>
:
:
value_type
;
using
typename
std
:
:
iterator
<
std
:
:
forward_iterator_tag
T
int32_t
>
:
:
difference_type
;
using
iterator_type
=
base_iterator
;
using
const_iterator_type
=
base_iterator
<
const
T
>
;
using
EndIteratorTag
=
PLDHashTable
:
:
Iterator
:
:
EndIteratorTag
;
base_iterator
(
base_iterator
&
&
aOther
)
=
default
;
base_iterator
&
operator
=
(
base_iterator
&
&
aOther
)
{
return
operator
=
(
static_cast
<
const
base_iterator
&
>
(
aOther
)
)
;
}
base_iterator
(
const
base_iterator
&
aOther
)
:
mIterator
{
aOther
.
mIterator
.
Clone
(
)
}
{
}
base_iterator
&
operator
=
(
const
base_iterator
&
aOther
)
{
mIterator
.
~
Iterator
(
)
;
new
(
&
mIterator
)
PLDHashTable
:
:
Iterator
(
aOther
.
mIterator
.
Clone
(
)
)
;
return
*
this
;
}
explicit
base_iterator
(
PLDHashTable
:
:
Iterator
aFrom
)
:
mIterator
{
std
:
:
move
(
aFrom
)
}
{
}
explicit
base_iterator
(
const
nsBaseHashtable
*
aTable
)
:
mIterator
{
&
const_cast
<
nsBaseHashtable
*
>
(
aTable
)
-
>
mTable
}
{
}
base_iterator
(
const
nsBaseHashtable
*
aTable
EndIteratorTag
aTag
)
:
mIterator
{
&
const_cast
<
nsBaseHashtable
*
>
(
aTable
)
-
>
mTable
aTag
}
{
}
bool
operator
=
=
(
const
iterator_type
&
aRhs
)
const
{
return
mIterator
=
=
aRhs
.
mIterator
;
}
bool
operator
!
=
(
const
iterator_type
&
aRhs
)
const
{
return
!
(
*
this
=
=
aRhs
)
;
}
value_type
*
operator
-
>
(
)
const
{
return
static_cast
<
value_type
*
>
(
mIterator
.
Get
(
)
)
;
}
value_type
&
operator
*
(
)
const
{
return
*
static_cast
<
value_type
*
>
(
mIterator
.
Get
(
)
)
;
}
iterator_type
&
operator
+
+
(
)
{
mIterator
.
Next
(
)
;
return
*
this
;
}
iterator_type
operator
+
+
(
int
)
{
iterator_type
it
=
*
this
;
+
+
*
this
;
return
it
;
}
operator
const_iterator_type
(
)
const
{
return
const_iterator_type
{
mIterator
.
Clone
(
)
}
;
}
private
:
PLDHashTable
:
:
Iterator
mIterator
;
}
;
using
const_iterator
=
base_iterator
<
const
EntryType
>
;
using
iterator
=
base_iterator
<
EntryType
>
;
iterator
begin
(
)
{
return
iterator
{
this
}
;
}
const_iterator
begin
(
)
const
{
return
const_iterator
{
this
}
;
}
const_iterator
cbegin
(
)
const
{
return
begin
(
)
;
}
iterator
end
(
)
{
return
iterator
{
this
typename
iterator
:
:
EndIteratorTag
{
}
}
;
}
const_iterator
end
(
)
const
{
return
const_iterator
{
this
typename
const_iterator
:
:
EndIteratorTag
{
}
}
;
}
const_iterator
cend
(
)
const
{
return
end
(
)
;
}
void
Clear
(
)
{
nsTHashtable
<
EntryType
>
:
:
Clear
(
)
;
}
size_t
ShallowSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
this
-
>
mTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
ShallowSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
void
SwapElements
(
nsBaseHashtable
&
aOther
)
{
nsTHashtable
<
EntryType
>
:
:
SwapElements
(
aOther
)
;
}
using
nsTHashtable
<
EntryType
>
:
:
MarkImmutable
;
}
;
template
<
class
KeyClass
class
DataType
>
nsBaseHashtableET
<
KeyClass
DataType
>
:
:
nsBaseHashtableET
(
KeyTypePointer
aKey
)
:
KeyClass
(
aKey
)
mData
(
)
{
}
template
<
class
KeyClass
class
DataType
>
nsBaseHashtableET
<
KeyClass
DataType
>
:
:
nsBaseHashtableET
(
nsBaseHashtableET
<
KeyClass
DataType
>
&
&
aToMove
)
:
KeyClass
(
std
:
:
move
(
aToMove
)
)
mData
(
std
:
:
move
(
aToMove
.
mData
)
)
{
}
template
<
class
KeyClass
class
DataType
>
nsBaseHashtableET
<
KeyClass
DataType
>
:
:
~
nsBaseHashtableET
(
)
{
}
#
endif
