#
ifndef
nsBaseHashtable_h__
#
define
nsBaseHashtable_h__
#
include
<
utility
>
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsTHashtable
.
h
"
template
<
class
KeyClass
class
DataType
class
UserDataType
class
Converter
>
class
nsBaseHashtable
;
template
<
class
DataType
class
UserDataType
>
class
nsDefaultConverter
{
public
:
static
UserDataType
Unwrap
(
DataType
&
src
)
{
return
UserDataType
(
src
)
;
}
static
DataType
Wrap
(
const
UserDataType
&
src
)
{
return
DataType
(
src
)
;
}
template
<
typename
U
>
static
DataType
Wrap
(
U
&
&
src
)
{
return
std
:
:
forward
<
U
>
(
src
)
;
}
template
<
typename
U
>
static
UserDataType
Unwrap
(
U
&
&
src
)
{
return
std
:
:
forward
<
U
>
(
src
)
;
}
}
;
template
<
class
KeyClass
class
DataType
>
class
nsBaseHashtableET
:
public
KeyClass
{
public
:
const
DataType
&
GetData
(
)
const
{
return
mData
;
}
DataType
*
GetModifiableData
(
)
{
return
&
mData
;
}
template
<
typename
U
>
void
SetData
(
U
&
&
aData
)
{
mData
=
std
:
:
forward
<
U
>
(
aData
)
;
}
private
:
DataType
mData
;
friend
class
nsTHashtable
<
nsBaseHashtableET
<
KeyClass
DataType
>
>
;
template
<
typename
KeyClassX
typename
DataTypeX
typename
UserDataTypeX
typename
ConverterX
>
friend
class
nsBaseHashtable
;
typedef
typename
KeyClass
:
:
KeyType
KeyType
;
typedef
typename
KeyClass
:
:
KeyTypePointer
KeyTypePointer
;
template
<
typename
.
.
.
Args
>
explicit
nsBaseHashtableET
(
KeyTypePointer
aKey
Args
&
&
.
.
.
aArgs
)
;
nsBaseHashtableET
(
nsBaseHashtableET
<
KeyClass
DataType
>
&
&
aToMove
)
=
default
;
~
nsBaseHashtableET
(
)
=
default
;
}
;
template
<
class
KeyClass
class
DataType
class
UserDataType
class
Converter
=
nsDefaultConverter
<
DataType
UserDataType
>
>
class
nsBaseHashtable
:
protected
nsTHashtable
<
nsBaseHashtableET
<
KeyClass
DataType
>
>
{
using
Base
=
nsTHashtable
<
nsBaseHashtableET
<
KeyClass
DataType
>
>
;
typedef
mozilla
:
:
fallible_t
fallible_t
;
public
:
typedef
typename
KeyClass
:
:
KeyType
KeyType
;
typedef
nsBaseHashtableET
<
KeyClass
DataType
>
EntryType
;
using
nsTHashtable
<
EntryType
>
:
:
Contains
;
using
nsTHashtable
<
EntryType
>
:
:
GetGeneration
;
using
nsTHashtable
<
EntryType
>
:
:
SizeOfExcludingThis
;
using
nsTHashtable
<
EntryType
>
:
:
SizeOfIncludingThis
;
nsBaseHashtable
(
)
=
default
;
explicit
nsBaseHashtable
(
uint32_t
aInitLength
)
:
nsTHashtable
<
EntryType
>
(
aInitLength
)
{
}
uint32_t
Count
(
)
const
{
return
nsTHashtable
<
EntryType
>
:
:
Count
(
)
;
}
bool
IsEmpty
(
)
const
{
return
nsTHashtable
<
EntryType
>
:
:
IsEmpty
(
)
;
}
bool
Get
(
KeyType
aKey
UserDataType
*
aData
)
const
{
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
false
;
}
if
(
aData
)
{
*
aData
=
Converter
:
:
Unwrap
(
ent
-
>
mData
)
;
}
return
true
;
}
UserDataType
Get
(
KeyType
aKey
)
const
{
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
UserDataType
{
}
;
}
return
Converter
:
:
Unwrap
(
ent
-
>
mData
)
;
}
mozilla
:
:
Maybe
<
UserDataType
>
MaybeGet
(
KeyType
aKey
)
const
{
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
mozilla
:
:
Nothing
(
)
;
}
return
mozilla
:
:
Some
(
Converter
:
:
Unwrap
(
ent
-
>
mData
)
)
;
}
template
<
typename
.
.
.
Args
>
DataType
&
GetOrInsert
(
const
KeyType
&
aKey
Args
&
&
.
.
.
aArgs
)
{
return
WithEntryHandle
(
aKey
[
&
]
(
auto
entryHandle
)
-
>
DataType
&
{
return
entryHandle
.
OrInsert
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
)
;
}
template
<
typename
F
>
DataType
&
GetOrInsertWith
(
const
KeyType
&
aKey
F
&
&
aFunc
)
{
return
WithEntryHandle
(
aKey
[
&
aFunc
]
(
auto
entryHandle
)
-
>
DataType
&
{
return
entryHandle
.
OrInsertWith
(
std
:
:
forward
<
F
>
(
aFunc
)
)
;
}
)
;
}
template
<
typename
U
>
DataType
&
Put
(
KeyType
aKey
U
&
&
aData
)
{
return
WithEntryHandle
(
aKey
[
&
aData
]
(
auto
entryHandle
)
-
>
DataType
&
{
return
entryHandle
.
InsertOrUpdate
(
std
:
:
forward
<
U
>
(
aData
)
)
;
}
)
;
}
template
<
typename
U
>
[
[
nodiscard
]
]
bool
Put
(
KeyType
aKey
U
&
&
aData
const
fallible_t
&
aFallible
)
{
return
WithEntryHandle
(
aKey
aFallible
[
&
aData
]
(
auto
maybeEntryHandle
)
{
if
(
!
maybeEntryHandle
)
{
return
false
;
}
maybeEntryHandle
-
>
InsertOrUpdate
(
std
:
:
forward
<
U
>
(
aData
)
)
;
return
true
;
}
)
;
}
bool
Remove
(
KeyType
aKey
DataType
*
aData
)
{
if
(
auto
*
ent
=
this
-
>
GetEntry
(
aKey
)
)
{
if
(
aData
)
{
*
aData
=
std
:
:
move
(
ent
-
>
mData
)
;
}
this
-
>
RemoveEntry
(
ent
)
;
return
true
;
}
if
(
aData
)
{
*
aData
=
std
:
:
move
(
DataType
(
)
)
;
}
return
false
;
}
bool
Remove
(
KeyType
aKey
)
{
if
(
auto
*
ent
=
this
-
>
GetEntry
(
aKey
)
)
{
this
-
>
RemoveEntry
(
ent
)
;
return
true
;
}
return
false
;
}
[
[
nodiscard
]
]
mozilla
:
:
Maybe
<
DataType
>
Extract
(
KeyType
aKey
)
{
mozilla
:
:
Maybe
<
DataType
>
value
;
if
(
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
)
{
value
.
emplace
(
std
:
:
move
(
ent
-
>
mData
)
)
;
this
-
>
RemoveEntry
(
ent
)
;
}
return
value
;
}
struct
LookupResult
{
private
:
EntryType
*
mEntry
;
nsBaseHashtable
&
mTable
;
#
ifdef
DEBUG
uint32_t
mTableGeneration
;
#
endif
public
:
LookupResult
(
EntryType
*
aEntry
nsBaseHashtable
&
aTable
)
:
mEntry
(
aEntry
)
mTable
(
aTable
)
#
ifdef
DEBUG
mTableGeneration
(
aTable
.
GetGeneration
(
)
)
#
endif
{
}
explicit
operator
bool
(
)
const
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
return
mEntry
;
}
void
Remove
(
)
{
if
(
!
*
this
)
{
return
;
}
mTable
.
RemoveEntry
(
mEntry
)
;
mEntry
=
nullptr
;
}
[
[
nodiscard
]
]
DataType
&
Data
(
)
{
MOZ_ASSERT
(
!
!
*
this
"
must
have
an
entry
to
access
its
value
"
)
;
return
mEntry
-
>
mData
;
}
}
;
template
<
typename
Pred
>
void
RemoveIf
(
Pred
&
&
aPred
)
{
for
(
auto
iter
=
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
aPred
(
const_cast
<
std
:
:
add_const_t
<
decltype
(
iter
)
>
&
>
(
iter
)
)
)
{
iter
.
Remove
(
)
;
}
}
}
[
[
nodiscard
]
]
LookupResult
Lookup
(
KeyType
aKey
)
{
return
LookupResult
(
this
-
>
GetEntry
(
aKey
)
*
this
)
;
}
class
EntryHandle
:
protected
nsTHashtable
<
EntryType
>
:
:
EntryHandle
{
public
:
using
Base
=
typename
nsTHashtable
<
EntryType
>
:
:
EntryHandle
;
EntryHandle
(
EntryHandle
&
&
aOther
)
=
default
;
~
EntryHandle
(
)
=
default
;
EntryHandle
(
const
EntryHandle
&
)
=
delete
;
EntryHandle
&
operator
=
(
const
EntryHandle
&
)
=
delete
;
EntryHandle
&
operator
=
(
const
EntryHandle
&
&
)
=
delete
;
using
Base
:
:
Key
;
using
Base
:
:
HasEntry
;
using
Base
:
:
operator
bool
;
using
Base
:
:
Entry
;
template
<
typename
.
.
.
Args
>
DataType
&
Insert
(
Args
&
&
.
.
.
aArgs
)
{
Base
:
:
InsertInternal
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
return
Data
(
)
;
}
template
<
typename
.
.
.
Args
>
DataType
&
OrInsert
(
Args
&
&
.
.
.
aArgs
)
{
if
(
!
HasEntry
(
)
)
{
return
Insert
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
return
Data
(
)
;
}
template
<
typename
F
>
DataType
&
OrInsertWith
(
F
&
&
aFunc
)
{
if
(
!
HasEntry
(
)
)
{
return
Insert
(
std
:
:
forward
<
F
>
(
aFunc
)
(
)
)
;
}
return
Data
(
)
;
}
template
<
typename
U
>
DataType
&
Update
(
U
&
&
aData
)
{
MOZ_RELEASE_ASSERT
(
HasEntry
(
)
)
;
Data
(
)
=
std
:
:
forward
<
U
>
(
aData
)
;
return
Data
(
)
;
}
template
<
typename
U
>
void
OrUpdate
(
U
&
&
aData
)
{
if
(
HasEntry
(
)
)
{
Update
(
std
:
:
forward
<
U
>
(
aData
)
)
;
}
}
template
<
typename
F
>
void
OrUpdateWith
(
F
&
&
aFunc
)
{
if
(
HasEntry
(
)
)
{
Update
(
std
:
:
forward
<
F
>
(
aFunc
)
(
)
)
;
}
}
template
<
typename
U
>
DataType
&
InsertOrUpdate
(
U
&
&
aData
)
{
if
(
!
HasEntry
(
)
)
{
Insert
(
std
:
:
forward
<
U
>
(
aData
)
)
;
}
else
{
Update
(
std
:
:
forward
<
U
>
(
aData
)
)
;
}
return
Data
(
)
;
}
using
Base
:
:
Remove
;
using
Base
:
:
OrRemove
;
DataType
&
Data
(
)
{
return
Entry
(
)
-
>
mData
;
}
private
:
friend
class
nsBaseHashtable
;
explicit
EntryHandle
(
Base
&
&
aBase
)
:
Base
(
std
:
:
move
(
aBase
)
)
{
}
}
;
template
<
class
F
>
auto
WithEntryHandle
(
KeyType
aKey
F
&
&
aFunc
)
-
>
std
:
:
invoke_result_t
<
F
EntryHandle
&
&
>
{
return
Base
:
:
WithEntryHandle
(
aKey
[
&
aFunc
]
(
auto
entryHandle
)
-
>
decltype
(
auto
)
{
return
std
:
:
forward
<
F
>
(
aFunc
)
(
EntryHandle
{
std
:
:
move
(
entryHandle
)
}
)
;
}
)
;
}
template
<
class
F
>
auto
WithEntryHandle
(
KeyType
aKey
const
fallible_t
&
aFallible
F
&
&
aFunc
)
-
>
std
:
:
invoke_result_t
<
F
mozilla
:
:
Maybe
<
EntryHandle
>
&
&
>
{
return
Base
:
:
WithEntryHandle
(
aKey
aFallible
[
&
aFunc
]
(
auto
maybeEntryHandle
)
{
return
std
:
:
forward
<
F
>
(
aFunc
)
(
maybeEntryHandle
?
mozilla
:
:
Some
(
EntryHandle
{
maybeEntryHandle
.
extract
(
)
}
)
:
mozilla
:
:
Nothing
(
)
)
;
}
)
;
}
public
:
class
Iterator
:
public
PLDHashTable
:
:
Iterator
{
public
:
typedef
PLDHashTable
:
:
Iterator
Base
;
explicit
Iterator
(
nsBaseHashtable
*
aTable
)
:
Base
(
&
aTable
-
>
mTable
)
{
}
Iterator
(
Iterator
&
&
aOther
)
:
Base
(
aOther
.
mTable
)
{
}
~
Iterator
(
)
=
default
;
KeyType
Key
(
)
const
{
return
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
GetKey
(
)
;
}
UserDataType
UserData
(
)
const
{
return
Converter
:
:
Unwrap
(
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
mData
)
;
}
DataType
&
Data
(
)
const
{
return
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
mData
;
}
private
:
Iterator
(
)
=
delete
;
Iterator
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
&
)
=
delete
;
}
;
Iterator
Iter
(
)
{
return
Iterator
(
this
)
;
}
Iterator
ConstIter
(
)
const
{
return
Iterator
(
const_cast
<
nsBaseHashtable
*
>
(
this
)
)
;
}
using
typename
nsTHashtable
<
EntryType
>
:
:
iterator
;
using
typename
nsTHashtable
<
EntryType
>
:
:
const_iterator
;
using
nsTHashtable
<
EntryType
>
:
:
begin
;
using
nsTHashtable
<
EntryType
>
:
:
end
;
using
nsTHashtable
<
EntryType
>
:
:
cbegin
;
using
nsTHashtable
<
EntryType
>
:
:
cend
;
void
Clear
(
)
{
nsTHashtable
<
EntryType
>
:
:
Clear
(
)
;
}
size_t
ShallowSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
this
-
>
mTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
ShallowSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
void
SwapElements
(
nsBaseHashtable
&
aOther
)
{
nsTHashtable
<
EntryType
>
:
:
SwapElements
(
aOther
)
;
}
using
nsTHashtable
<
EntryType
>
:
:
MarkImmutable
;
}
;
template
<
class
KeyClass
class
DataType
>
template
<
typename
.
.
.
Args
>
nsBaseHashtableET
<
KeyClass
DataType
>
:
:
nsBaseHashtableET
(
KeyTypePointer
aKey
Args
&
&
.
.
.
aArgs
)
:
KeyClass
(
aKey
)
mData
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
{
}
#
endif
