#
ifndef
nsBaseHashtable_h__
#
define
nsBaseHashtable_h__
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsDebug
.
h
"
template
<
class
KeyClass
class
DataType
class
UserDataType
>
class
nsBaseHashtable
;
template
<
class
KeyClass
class
DataType
>
class
nsBaseHashtableET
:
public
KeyClass
{
public
:
DataType
mData
;
friend
class
nsTHashtable
<
nsBaseHashtableET
<
KeyClass
DataType
>
>
;
private
:
typedef
typename
KeyClass
:
:
KeyType
KeyType
;
typedef
typename
KeyClass
:
:
KeyTypePointer
KeyTypePointer
;
explicit
nsBaseHashtableET
(
KeyTypePointer
aKey
)
;
nsBaseHashtableET
(
nsBaseHashtableET
<
KeyClass
DataType
>
&
&
aToMove
)
;
~
nsBaseHashtableET
(
)
;
}
;
template
<
class
KeyClass
class
DataType
class
UserDataType
>
class
nsBaseHashtable
:
protected
nsTHashtable
<
nsBaseHashtableET
<
KeyClass
DataType
>
>
{
typedef
mozilla
:
:
fallible_t
fallible_t
;
public
:
typedef
typename
KeyClass
:
:
KeyType
KeyType
;
typedef
nsBaseHashtableET
<
KeyClass
DataType
>
EntryType
;
using
nsTHashtable
<
EntryType
>
:
:
Contains
;
using
nsTHashtable
<
EntryType
>
:
:
GetGeneration
;
using
nsTHashtable
<
EntryType
>
:
:
SizeOfExcludingThis
;
using
nsTHashtable
<
EntryType
>
:
:
SizeOfIncludingThis
;
nsBaseHashtable
(
)
{
}
explicit
nsBaseHashtable
(
uint32_t
aInitLength
)
:
nsTHashtable
<
EntryType
>
(
aInitLength
)
{
}
uint32_t
Count
(
)
const
{
return
nsTHashtable
<
EntryType
>
:
:
Count
(
)
;
}
bool
IsEmpty
(
)
const
{
return
nsTHashtable
<
EntryType
>
:
:
IsEmpty
(
)
;
}
bool
Get
(
KeyType
aKey
UserDataType
*
aData
)
const
{
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
false
;
}
if
(
aData
)
{
*
aData
=
ent
-
>
mData
;
}
return
true
;
}
UserDataType
Get
(
KeyType
aKey
)
const
{
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
UserDataType
{
}
;
}
return
ent
-
>
mData
;
}
DataType
&
GetOrInsert
(
const
KeyType
&
aKey
)
{
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
)
;
return
ent
-
>
mData
;
}
void
Put
(
KeyType
aKey
const
UserDataType
&
aData
)
{
if
(
!
Put
(
aKey
aData
mozilla
:
:
fallible
)
)
{
NS_ABORT_OOM
(
this
-
>
mTable
.
EntrySize
(
)
*
this
-
>
mTable
.
EntryCount
(
)
)
;
}
}
MOZ_MUST_USE
bool
Put
(
KeyType
aKey
const
UserDataType
&
aData
const
fallible_t
&
)
{
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
mozilla
:
:
fallible
)
;
if
(
!
ent
)
{
return
false
;
}
ent
-
>
mData
=
aData
;
return
true
;
}
void
Put
(
KeyType
aKey
UserDataType
&
&
aData
)
{
if
(
!
Put
(
aKey
std
:
:
move
(
aData
)
mozilla
:
:
fallible
)
)
{
NS_ABORT_OOM
(
this
-
>
mTable
.
EntrySize
(
)
*
this
-
>
mTable
.
EntryCount
(
)
)
;
}
}
MOZ_MUST_USE
bool
Put
(
KeyType
aKey
UserDataType
&
&
aData
const
fallible_t
&
)
{
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
mozilla
:
:
fallible
)
;
if
(
!
ent
)
{
return
false
;
}
ent
-
>
mData
=
std
:
:
move
(
aData
)
;
return
true
;
}
bool
Remove
(
KeyType
aKey
DataType
*
aData
=
nullptr
)
{
if
(
auto
*
ent
=
this
-
>
GetEntry
(
aKey
)
)
{
if
(
aData
)
{
*
aData
=
std
:
:
move
(
ent
-
>
mData
)
;
}
this
-
>
RemoveEntry
(
ent
)
;
return
true
;
}
if
(
aData
)
{
*
aData
=
std
:
:
move
(
DataType
(
)
)
;
}
return
false
;
}
struct
LookupResult
{
private
:
EntryType
*
mEntry
;
nsBaseHashtable
&
mTable
;
#
ifdef
DEBUG
uint32_t
mTableGeneration
;
#
endif
public
:
LookupResult
(
EntryType
*
aEntry
nsBaseHashtable
&
aTable
)
:
mEntry
(
aEntry
)
mTable
(
aTable
)
#
ifdef
DEBUG
mTableGeneration
(
aTable
.
GetGeneration
(
)
)
#
endif
{
}
explicit
operator
bool
(
)
const
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
return
mEntry
;
}
void
Remove
(
)
{
if
(
!
*
this
)
{
return
;
}
mTable
.
RemoveEntry
(
mEntry
)
;
mEntry
=
nullptr
;
}
MOZ_MUST_USE
DataType
&
Data
(
)
{
MOZ_ASSERT
(
!
!
*
this
"
must
have
an
entry
to
access
its
value
"
)
;
return
mEntry
-
>
mData
;
}
}
;
MOZ_MUST_USE
LookupResult
Lookup
(
KeyType
aKey
)
{
return
LookupResult
(
this
-
>
GetEntry
(
aKey
)
*
this
)
;
}
struct
EntryPtr
{
private
:
EntryType
*
mEntry
;
bool
mExistingEntry
;
nsBaseHashtable
&
mTable
;
#
ifdef
DEBUG
uint32_t
mTableGeneration
;
bool
mDidInitNewEntry
;
#
endif
public
:
EntryPtr
(
nsBaseHashtable
&
aTable
EntryType
*
aEntry
bool
aExistingEntry
)
:
mEntry
(
aEntry
)
mExistingEntry
(
aExistingEntry
)
mTable
(
aTable
)
#
ifdef
DEBUG
mTableGeneration
(
aTable
.
GetGeneration
(
)
)
mDidInitNewEntry
(
false
)
#
endif
{
}
~
EntryPtr
(
)
{
MOZ_ASSERT
(
mExistingEntry
|
|
mDidInitNewEntry
|
|
!
mEntry
"
Forgot
to
call
OrInsert
(
)
or
OrRemove
(
)
on
a
new
entry
"
)
;
}
explicit
operator
bool
(
)
const
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
return
mExistingEntry
;
}
template
<
class
F
>
DataType
&
OrInsert
(
F
func
)
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
MOZ_ASSERT
(
mEntry
)
;
if
(
!
mExistingEntry
)
{
mEntry
-
>
mData
=
func
(
)
;
#
ifdef
DEBUG
mDidInitNewEntry
=
true
;
#
endif
}
return
mEntry
-
>
mData
;
}
void
OrRemove
(
)
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
MOZ_ASSERT
(
mEntry
)
;
mTable
.
RemoveEntry
(
mEntry
)
;
mEntry
=
nullptr
;
}
MOZ_MUST_USE
DataType
&
Data
(
)
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
MOZ_ASSERT
(
mEntry
)
;
return
mEntry
-
>
mData
;
}
}
;
MOZ_MUST_USE
EntryPtr
LookupForAdd
(
KeyType
aKey
)
{
auto
count
=
Count
(
)
;
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
)
;
return
EntryPtr
(
*
this
ent
count
=
=
Count
(
)
)
;
}
class
Iterator
:
public
PLDHashTable
:
:
Iterator
{
public
:
typedef
PLDHashTable
:
:
Iterator
Base
;
explicit
Iterator
(
nsBaseHashtable
*
aTable
)
:
Base
(
&
aTable
-
>
mTable
)
{
}
Iterator
(
Iterator
&
&
aOther
)
:
Base
(
aOther
.
mTable
)
{
}
~
Iterator
(
)
{
}
KeyType
Key
(
)
const
{
return
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
GetKey
(
)
;
}
UserDataType
UserData
(
)
const
{
return
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
mData
;
}
DataType
&
Data
(
)
const
{
return
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
mData
;
}
private
:
Iterator
(
)
=
delete
;
Iterator
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
&
)
=
delete
;
}
;
Iterator
Iter
(
)
{
return
Iterator
(
this
)
;
}
Iterator
ConstIter
(
)
const
{
return
Iterator
(
const_cast
<
nsBaseHashtable
*
>
(
this
)
)
;
}
void
Clear
(
)
{
nsTHashtable
<
EntryType
>
:
:
Clear
(
)
;
}
size_t
ShallowSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
this
-
>
mTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
ShallowSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
void
SwapElements
(
nsBaseHashtable
&
aOther
)
{
nsTHashtable
<
EntryType
>
:
:
SwapElements
(
aOther
)
;
}
#
ifdef
DEBUG
using
nsTHashtable
<
EntryType
>
:
:
MarkImmutable
;
#
endif
}
;
template
<
class
KeyClass
class
DataType
>
nsBaseHashtableET
<
KeyClass
DataType
>
:
:
nsBaseHashtableET
(
KeyTypePointer
aKey
)
:
KeyClass
(
aKey
)
mData
(
)
{
}
template
<
class
KeyClass
class
DataType
>
nsBaseHashtableET
<
KeyClass
DataType
>
:
:
nsBaseHashtableET
(
nsBaseHashtableET
<
KeyClass
DataType
>
&
&
aToMove
)
:
KeyClass
(
std
:
:
move
(
aToMove
)
)
mData
(
std
:
:
move
(
aToMove
.
mData
)
)
{
}
template
<
class
KeyClass
class
DataType
>
nsBaseHashtableET
<
KeyClass
DataType
>
:
:
~
nsBaseHashtableET
(
)
{
}
#
endif
