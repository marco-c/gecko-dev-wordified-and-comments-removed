#
ifndef
nsBaseHashtable_h__
#
define
nsBaseHashtable_h__
#
include
<
utility
>
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsTHashtable
.
h
"
template
<
class
KeyClass
class
DataType
class
UserDataType
class
Converter
>
class
nsBaseHashtable
;
template
<
class
DataType
class
UserDataType
>
class
nsDefaultConverter
{
public
:
static
UserDataType
Unwrap
(
DataType
&
src
)
{
return
UserDataType
(
src
)
;
}
static
DataType
Wrap
(
const
UserDataType
&
src
)
{
return
DataType
(
src
)
;
}
template
<
typename
U
>
static
DataType
Wrap
(
U
&
&
src
)
{
return
std
:
:
move
(
src
)
;
}
}
;
template
<
class
KeyClass
class
DataType
>
class
nsBaseHashtableET
:
public
KeyClass
{
public
:
const
DataType
&
GetData
(
)
const
{
return
mData
;
}
DataType
*
GetModifiableData
(
)
{
return
&
mData
;
}
template
<
typename
U
>
void
SetData
(
U
&
&
aData
)
{
mData
=
std
:
:
forward
<
U
>
(
aData
)
;
}
private
:
DataType
mData
;
friend
class
nsTHashtable
<
nsBaseHashtableET
<
KeyClass
DataType
>
>
;
template
<
typename
KeyClassX
typename
DataTypeX
typename
UserDataTypeX
typename
ConverterX
>
friend
class
nsBaseHashtable
;
typedef
typename
KeyClass
:
:
KeyType
KeyType
;
typedef
typename
KeyClass
:
:
KeyTypePointer
KeyTypePointer
;
explicit
nsBaseHashtableET
(
KeyTypePointer
aKey
)
;
nsBaseHashtableET
(
nsBaseHashtableET
<
KeyClass
DataType
>
&
&
aToMove
)
;
~
nsBaseHashtableET
(
)
=
default
;
}
;
template
<
class
KeyClass
class
DataType
class
UserDataType
class
Converter
=
nsDefaultConverter
<
DataType
UserDataType
>
>
class
nsBaseHashtable
:
protected
nsTHashtable
<
nsBaseHashtableET
<
KeyClass
DataType
>
>
{
typedef
mozilla
:
:
fallible_t
fallible_t
;
public
:
typedef
typename
KeyClass
:
:
KeyType
KeyType
;
typedef
nsBaseHashtableET
<
KeyClass
DataType
>
EntryType
;
using
nsTHashtable
<
EntryType
>
:
:
Contains
;
using
nsTHashtable
<
EntryType
>
:
:
GetGeneration
;
using
nsTHashtable
<
EntryType
>
:
:
SizeOfExcludingThis
;
using
nsTHashtable
<
EntryType
>
:
:
SizeOfIncludingThis
;
nsBaseHashtable
(
)
=
default
;
explicit
nsBaseHashtable
(
uint32_t
aInitLength
)
:
nsTHashtable
<
EntryType
>
(
aInitLength
)
{
}
uint32_t
Count
(
)
const
{
return
nsTHashtable
<
EntryType
>
:
:
Count
(
)
;
}
bool
IsEmpty
(
)
const
{
return
nsTHashtable
<
EntryType
>
:
:
IsEmpty
(
)
;
}
bool
Get
(
KeyType
aKey
UserDataType
*
aData
)
const
{
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
false
;
}
if
(
aData
)
{
*
aData
=
Converter
:
:
Unwrap
(
ent
-
>
mData
)
;
}
return
true
;
}
UserDataType
Get
(
KeyType
aKey
)
const
{
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
UserDataType
{
}
;
}
return
Converter
:
:
Unwrap
(
ent
-
>
mData
)
;
}
DataType
&
GetOrInsert
(
const
KeyType
&
aKey
)
{
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
)
;
return
ent
-
>
mData
;
}
void
Put
(
KeyType
aKey
const
UserDataType
&
aData
)
{
if
(
!
Put
(
aKey
aData
mozilla
:
:
fallible
)
)
{
NS_ABORT_OOM
(
this
-
>
mTable
.
EntrySize
(
)
*
this
-
>
mTable
.
EntryCount
(
)
)
;
}
}
[
[
nodiscard
]
]
bool
Put
(
KeyType
aKey
const
UserDataType
&
aData
const
fallible_t
&
)
{
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
mozilla
:
:
fallible
)
;
if
(
!
ent
)
{
return
false
;
}
ent
-
>
mData
=
Converter
:
:
Wrap
(
aData
)
;
return
true
;
}
void
Put
(
KeyType
aKey
UserDataType
&
&
aData
)
{
if
(
!
Put
(
aKey
std
:
:
move
(
aData
)
mozilla
:
:
fallible
)
)
{
NS_ABORT_OOM
(
this
-
>
mTable
.
EntrySize
(
)
*
this
-
>
mTable
.
EntryCount
(
)
)
;
}
}
[
[
nodiscard
]
]
bool
Put
(
KeyType
aKey
UserDataType
&
&
aData
const
fallible_t
&
)
{
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
mozilla
:
:
fallible
)
;
if
(
!
ent
)
{
return
false
;
}
ent
-
>
mData
=
Converter
:
:
Wrap
(
std
:
:
move
(
aData
)
)
;
return
true
;
}
bool
Remove
(
KeyType
aKey
DataType
*
aData
=
nullptr
)
{
if
(
auto
*
ent
=
this
-
>
GetEntry
(
aKey
)
)
{
if
(
aData
)
{
*
aData
=
std
:
:
move
(
ent
-
>
mData
)
;
}
this
-
>
RemoveEntry
(
ent
)
;
return
true
;
}
if
(
aData
)
{
*
aData
=
std
:
:
move
(
DataType
(
)
)
;
}
return
false
;
}
struct
LookupResult
{
private
:
EntryType
*
mEntry
;
nsBaseHashtable
&
mTable
;
#
ifdef
DEBUG
uint32_t
mTableGeneration
;
#
endif
public
:
LookupResult
(
EntryType
*
aEntry
nsBaseHashtable
&
aTable
)
:
mEntry
(
aEntry
)
mTable
(
aTable
)
#
ifdef
DEBUG
mTableGeneration
(
aTable
.
GetGeneration
(
)
)
#
endif
{
}
explicit
operator
bool
(
)
const
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
return
mEntry
;
}
void
Remove
(
)
{
if
(
!
*
this
)
{
return
;
}
mTable
.
RemoveEntry
(
mEntry
)
;
mEntry
=
nullptr
;
}
[
[
nodiscard
]
]
DataType
&
Data
(
)
{
MOZ_ASSERT
(
!
!
*
this
"
must
have
an
entry
to
access
its
value
"
)
;
return
mEntry
-
>
mData
;
}
}
;
template
<
typename
Pred
>
void
RemoveIf
(
Pred
&
&
aPred
)
{
for
(
auto
iter
=
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
aPred
(
const_cast
<
std
:
:
add_const_t
<
decltype
(
iter
)
>
&
>
(
iter
)
)
)
{
iter
.
Remove
(
)
;
}
}
}
[
[
nodiscard
]
]
LookupResult
Lookup
(
KeyType
aKey
)
{
return
LookupResult
(
this
-
>
GetEntry
(
aKey
)
*
this
)
;
}
struct
EntryPtr
{
private
:
EntryType
*
mEntry
;
bool
mExistingEntry
;
nsBaseHashtable
&
mTable
;
#
ifdef
DEBUG
uint32_t
mTableGeneration
;
bool
mDidInitNewEntry
;
#
endif
public
:
EntryPtr
(
nsBaseHashtable
&
aTable
EntryType
*
aEntry
bool
aExistingEntry
)
:
mEntry
(
aEntry
)
mExistingEntry
(
aExistingEntry
)
mTable
(
aTable
)
#
ifdef
DEBUG
mTableGeneration
(
aTable
.
GetGeneration
(
)
)
mDidInitNewEntry
(
false
)
#
endif
{
}
~
EntryPtr
(
)
{
MOZ_ASSERT
(
mExistingEntry
|
|
mDidInitNewEntry
|
|
!
mEntry
"
Forgot
to
call
OrInsert
(
)
or
OrRemove
(
)
on
a
new
entry
"
)
;
}
explicit
operator
bool
(
)
const
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
return
mExistingEntry
;
}
template
<
class
F
>
DataType
&
OrInsert
(
F
func
)
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
MOZ_ASSERT
(
mEntry
)
;
if
(
!
mExistingEntry
)
{
mEntry
-
>
mData
=
Converter
:
:
Wrap
(
func
(
)
)
;
#
ifdef
DEBUG
mDidInitNewEntry
=
true
;
#
endif
}
return
mEntry
-
>
mData
;
}
void
OrRemove
(
)
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
MOZ_ASSERT
(
mEntry
)
;
mTable
.
RemoveEntry
(
mEntry
)
;
mEntry
=
nullptr
;
}
[
[
nodiscard
]
]
DataType
&
Data
(
)
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
MOZ_ASSERT
(
mEntry
)
;
return
mEntry
-
>
mData
;
}
}
;
[
[
nodiscard
]
]
EntryPtr
LookupForAdd
(
KeyType
aKey
)
{
auto
count
=
Count
(
)
;
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
)
;
return
EntryPtr
(
*
this
ent
count
=
=
Count
(
)
)
;
}
class
Iterator
:
public
PLDHashTable
:
:
Iterator
{
public
:
typedef
PLDHashTable
:
:
Iterator
Base
;
explicit
Iterator
(
nsBaseHashtable
*
aTable
)
:
Base
(
&
aTable
-
>
mTable
)
{
}
Iterator
(
Iterator
&
&
aOther
)
:
Base
(
aOther
.
mTable
)
{
}
~
Iterator
(
)
=
default
;
KeyType
Key
(
)
const
{
return
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
GetKey
(
)
;
}
UserDataType
UserData
(
)
const
{
return
Converter
:
:
Unwrap
(
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
mData
)
;
}
DataType
&
Data
(
)
const
{
return
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
mData
;
}
private
:
Iterator
(
)
=
delete
;
Iterator
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
&
)
=
delete
;
}
;
Iterator
Iter
(
)
{
return
Iterator
(
this
)
;
}
Iterator
ConstIter
(
)
const
{
return
Iterator
(
const_cast
<
nsBaseHashtable
*
>
(
this
)
)
;
}
using
typename
nsTHashtable
<
EntryType
>
:
:
iterator
;
using
typename
nsTHashtable
<
EntryType
>
:
:
const_iterator
;
using
nsTHashtable
<
EntryType
>
:
:
begin
;
using
nsTHashtable
<
EntryType
>
:
:
end
;
using
nsTHashtable
<
EntryType
>
:
:
cbegin
;
using
nsTHashtable
<
EntryType
>
:
:
cend
;
void
Clear
(
)
{
nsTHashtable
<
EntryType
>
:
:
Clear
(
)
;
}
size_t
ShallowSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
this
-
>
mTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
ShallowSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
void
SwapElements
(
nsBaseHashtable
&
aOther
)
{
nsTHashtable
<
EntryType
>
:
:
SwapElements
(
aOther
)
;
}
using
nsTHashtable
<
EntryType
>
:
:
MarkImmutable
;
}
;
template
<
class
KeyClass
class
DataType
>
nsBaseHashtableET
<
KeyClass
DataType
>
:
:
nsBaseHashtableET
(
KeyTypePointer
aKey
)
:
KeyClass
(
aKey
)
mData
(
)
{
}
template
<
class
KeyClass
class
DataType
>
nsBaseHashtableET
<
KeyClass
DataType
>
:
:
nsBaseHashtableET
(
nsBaseHashtableET
<
KeyClass
DataType
>
&
&
aToMove
)
:
KeyClass
(
std
:
:
move
(
aToMove
)
)
mData
(
std
:
:
move
(
aToMove
.
mData
)
)
{
}
#
endif
