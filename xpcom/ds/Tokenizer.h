#
ifndef
Tokenizer_h__
#
define
Tokenizer_h__
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
namespace
mozilla
{
class
Tokenizer
{
public
:
enum
TokenType
{
TOKEN_UNKNOWN
TOKEN_ERROR
TOKEN_INTEGER
TOKEN_WORD
TOKEN_CHAR
TOKEN_WS
TOKEN_EOL
TOKEN_EOF
}
;
class
Token
{
TokenType
mType
;
nsDependentCSubstring
mWord
;
char
mChar
;
uint64_t
mInteger
;
nsDependentCSubstring
mFragment
;
friend
class
Tokenizer
;
void
AssignFragment
(
nsACString
:
:
const_char_iterator
begin
nsACString
:
:
const_char_iterator
end
)
;
public
:
Token
(
)
:
mType
(
TOKEN_UNKNOWN
)
mChar
(
0
)
mInteger
(
0
)
{
}
Token
(
const
Token
&
aOther
)
;
Token
&
operator
=
(
const
Token
&
aOther
)
;
static
Token
Word
(
const
nsACString
&
aWord
)
;
static
Token
Char
(
const
char
aChar
)
;
static
Token
Number
(
const
uint64_t
aNumber
)
;
static
Token
Whitespace
(
)
;
static
Token
NewLine
(
)
;
static
Token
EndOfFile
(
)
;
static
Token
Error
(
)
;
bool
Equals
(
const
Token
&
aOther
)
const
;
TokenType
Type
(
)
const
{
return
mType
;
}
char
AsChar
(
)
const
;
nsDependentCSubstring
AsString
(
)
const
;
uint64_t
AsInteger
(
)
const
;
nsDependentCSubstring
Fragment
(
)
const
{
return
mFragment
;
}
}
;
public
:
explicit
Tokenizer
(
const
nsACString
&
aSource
const
char
*
aWhitespaces
=
nullptr
const
char
*
aAdditionalWordChars
=
nullptr
)
;
explicit
Tokenizer
(
const
char
*
aSource
const
char
*
aWhitespaces
=
nullptr
const
char
*
aAdditionalWordChars
=
nullptr
)
;
MOZ_WARN_UNUSED_RESULT
bool
Next
(
Token
&
aToken
)
;
MOZ_WARN_UNUSED_RESULT
bool
Check
(
const
TokenType
aTokenType
Token
&
aResult
)
;
MOZ_WARN_UNUSED_RESULT
bool
Check
(
const
Token
&
aToken
)
;
MOZ_WARN_UNUSED_RESULT
bool
HasFailed
(
)
const
;
enum
WhiteSkipping
{
DONT_INCLUDE_NEW_LINE
=
0
INCLUDE_NEW_LINE
=
1
}
;
void
SkipWhites
(
WhiteSkipping
aIncludeNewLines
=
DONT_INCLUDE_NEW_LINE
)
;
MOZ_WARN_UNUSED_RESULT
bool
CheckWhite
(
)
{
return
Check
(
Token
:
:
Whitespace
(
)
)
;
}
MOZ_WARN_UNUSED_RESULT
bool
CheckChar
(
const
char
aChar
)
{
return
Check
(
Token
:
:
Char
(
aChar
)
)
;
}
MOZ_WARN_UNUSED_RESULT
bool
CheckChar
(
bool
(
*
aClassifier
)
(
const
char
aChar
)
)
;
MOZ_WARN_UNUSED_RESULT
bool
CheckWord
(
const
nsACString
&
aWord
)
{
return
Check
(
Token
:
:
Word
(
aWord
)
)
;
}
template
<
uint32_t
N
>
MOZ_WARN_UNUSED_RESULT
bool
CheckWord
(
const
char
(
&
aWord
)
[
N
]
)
{
return
Check
(
Token
:
:
Word
(
nsDependentCString
(
aWord
N
-
1
)
)
)
;
}
MOZ_WARN_UNUSED_RESULT
bool
CheckEOL
(
)
{
return
Check
(
Token
:
:
NewLine
(
)
)
;
}
MOZ_WARN_UNUSED_RESULT
bool
CheckEOF
(
)
{
return
Check
(
Token
:
:
EndOfFile
(
)
)
;
}
bool
ReadChar
(
char
*
aValue
)
;
bool
ReadChar
(
bool
(
*
aClassifier
)
(
const
char
aChar
)
char
*
aValue
)
;
bool
ReadWord
(
nsACString
&
aValue
)
;
bool
ReadWord
(
nsDependentCSubstring
&
aValue
)
;
template
<
typename
T
>
bool
ReadInteger
(
T
*
aValue
)
{
MOZ_RELEASE_ASSERT
(
aValue
)
;
nsACString
:
:
const_char_iterator
rollback
=
mRollback
;
nsACString
:
:
const_char_iterator
cursor
=
mCursor
;
Token
t
;
if
(
!
Check
(
TOKEN_INTEGER
t
)
)
{
return
false
;
}
mozilla
:
:
CheckedInt
<
T
>
checked
(
t
.
AsInteger
(
)
)
;
if
(
!
checked
.
isValid
(
)
)
{
mRollback
=
rollback
;
mCursor
=
cursor
;
mHasFailed
=
true
;
return
false
;
}
*
aValue
=
checked
.
value
(
)
;
return
true
;
}
void
Rollback
(
)
;
enum
ClaimInclusion
{
INCLUDE_LAST
EXCLUDE_LAST
}
;
void
Record
(
ClaimInclusion
aInclude
=
EXCLUDE_LAST
)
;
void
Claim
(
nsACString
&
aResult
ClaimInclusion
aInclude
=
EXCLUDE_LAST
)
;
void
Claim
(
nsDependentCSubstring
&
aResult
ClaimInclusion
aInclude
=
EXCLUDE_LAST
)
;
protected
:
bool
HasInput
(
)
const
;
nsACString
:
:
const_char_iterator
Parse
(
Token
&
aToken
)
const
;
bool
IsEnd
(
const
nsACString
:
:
const_char_iterator
&
caret
)
const
;
bool
IsWordFirst
(
const
char
aInput
)
const
;
bool
IsWord
(
const
char
aInput
)
const
;
bool
IsNumber
(
const
char
aInput
)
const
;
bool
mPastEof
;
bool
mHasFailed
;
const
char
*
mWhitespaces
;
const
char
*
mAdditionalWordChars
;
nsACString
:
:
const_char_iterator
mRecord
;
nsACString
:
:
const_char_iterator
mRollback
;
nsACString
:
:
const_char_iterator
mCursor
;
nsACString
:
:
const_char_iterator
mEnd
;
private
:
Tokenizer
(
)
=
delete
;
Tokenizer
(
const
Tokenizer
&
)
=
delete
;
Tokenizer
(
Tokenizer
&
&
)
=
delete
;
Tokenizer
(
const
Tokenizer
&
&
)
=
delete
;
Tokenizer
&
operator
=
(
const
Tokenizer
&
)
=
delete
;
}
;
}
#
endif
