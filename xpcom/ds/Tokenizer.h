#
ifndef
Tokenizer_h__
#
define
Tokenizer_h__
#
include
"
nsString
.
h
"
namespace
mozilla
{
class
Tokenizer
{
public
:
enum
TokenType
{
TOKEN_UNKNOWN
TOKEN_ERROR
TOKEN_INTEGER
TOKEN_WORD
TOKEN_CHAR
TOKEN_WS
TOKEN_EOL
TOKEN_EOF
}
;
class
Token
{
TokenType
mType
;
nsCString
mWord
;
char
mChar
;
int64_t
mInteger
;
public
:
Token
(
)
:
mType
(
TOKEN_UNKNOWN
)
mChar
(
0
)
mInteger
(
0
)
{
}
static
Token
Word
(
const
nsACString
&
aWord
)
;
static
Token
Char
(
const
char
aChar
)
;
static
Token
Number
(
const
int64_t
aNumber
)
;
static
Token
Whitespace
(
)
;
static
Token
NewLine
(
)
;
static
Token
EndOfFile
(
)
;
static
Token
Error
(
)
;
bool
Equals
(
const
Token
&
aOther
)
const
;
TokenType
Type
(
)
const
{
return
mType
;
}
char
AsChar
(
)
const
;
nsCString
AsString
(
)
const
;
int64_t
AsInteger
(
)
const
;
}
;
public
:
explicit
Tokenizer
(
const
nsACString
&
aSource
)
;
enum
ClaimInclusion
{
INCLUDE_LAST
EXCLUDE_LAST
}
;
MOZ_WARN_UNUSED_RESULT
bool
Next
(
Token
&
aToken
)
;
MOZ_WARN_UNUSED_RESULT
bool
Check
(
const
TokenType
aTokenType
Token
&
aResult
)
;
MOZ_WARN_UNUSED_RESULT
bool
Check
(
const
Token
&
aToken
)
;
MOZ_WARN_UNUSED_RESULT
bool
HasFailed
(
)
const
;
void
SkipWhites
(
)
;
MOZ_WARN_UNUSED_RESULT
bool
CheckWhite
(
)
{
return
Check
(
Token
:
:
Whitespace
(
)
)
;
}
MOZ_WARN_UNUSED_RESULT
bool
CheckChar
(
const
char
aChar
)
{
return
Check
(
Token
:
:
Char
(
aChar
)
)
;
}
MOZ_WARN_UNUSED_RESULT
bool
CheckChar
(
bool
(
*
aClassifier
)
(
const
char
aChar
)
)
;
template
<
size_t
N
>
MOZ_WARN_UNUSED_RESULT
bool
CheckWord
(
const
char
(
&
aWord
)
[
N
]
)
{
return
Check
(
Token
:
:
Word
(
nsLiteralCString
(
aWord
)
)
)
;
}
MOZ_WARN_UNUSED_RESULT
bool
CheckEOL
(
)
{
return
Check
(
Token
:
:
NewLine
(
)
)
;
}
MOZ_WARN_UNUSED_RESULT
bool
CheckEOF
(
)
{
return
Check
(
Token
:
:
EndOfFile
(
)
)
;
}
void
Rollback
(
)
;
void
Record
(
ClaimInclusion
aInclude
=
EXCLUDE_LAST
)
;
void
Claim
(
nsACString
&
aResult
ClaimInclusion
aInclude
=
EXCLUDE_LAST
)
;
protected
:
bool
HasInput
(
)
const
;
nsACString
:
:
const_char_iterator
Parse
(
Token
&
aToken
)
const
;
bool
IsEnd
(
const
nsACString
:
:
const_char_iterator
&
caret
)
const
;
bool
IsWordFirst
(
const
char
aInput
)
const
;
bool
IsWord
(
const
char
aInput
)
const
;
bool
IsNumber
(
const
char
aInput
)
const
;
private
:
Tokenizer
(
)
=
delete
;
bool
mPastEof
;
bool
mHasFailed
;
char
const
*
mWhitespaces
;
nsACString
:
:
const_char_iterator
mRecord
;
nsACString
:
:
const_char_iterator
mRollback
;
nsACString
:
:
const_char_iterator
mCursor
;
nsACString
:
:
const_char_iterator
mEnd
;
}
;
}
#
endif
