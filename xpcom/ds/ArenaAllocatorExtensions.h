#
ifndef
mozilla_ArenaAllocatorExtensions_h
#
define
mozilla_ArenaAllocatorExtensions_h
#
include
"
mozilla
/
ArenaAllocator
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
nsAString
.
h
"
namespace
mozilla
{
namespace
detail
{
template
<
typename
T
size_t
ArenaSize
size_t
Alignment
>
T
*
DuplicateString
(
const
T
*
aSrc
const
CheckedInt
<
size_t
>
&
aLen
ArenaAllocator
<
ArenaSize
Alignment
>
&
aArena
)
;
}
template
<
size_t
ArenaSize
size_t
Alignment
>
char
*
ArenaStrdup
(
const
char
*
aStr
ArenaAllocator
<
ArenaSize
Alignment
>
&
aArena
)
{
return
detail
:
:
DuplicateString
(
aStr
strlen
(
aStr
)
aArena
)
;
}
template
<
size_t
ArenaSize
size_t
Alignment
>
nsAString
:
:
char_type
*
ArenaStrdup
(
const
nsAString
&
aStr
ArenaAllocator
<
ArenaSize
Alignment
>
&
aArena
)
{
return
detail
:
:
DuplicateString
(
aStr
.
BeginReading
(
)
aStr
.
Length
(
)
aArena
)
;
}
template
<
size_t
ArenaSize
size_t
Alignment
>
nsACString
:
:
char_type
*
ArenaStrdup
(
const
nsACString
&
aStr
ArenaAllocator
<
ArenaSize
Alignment
>
&
aArena
)
{
return
detail
:
:
DuplicateString
(
aStr
.
BeginReading
(
)
aStr
.
Length
(
)
aArena
)
;
}
template
<
typename
T
size_t
ArenaSize
size_t
Alignment
>
T
*
detail
:
:
DuplicateString
(
const
T
*
aSrc
const
CheckedInt
<
size_t
>
&
aLen
ArenaAllocator
<
ArenaSize
Alignment
>
&
aArena
)
{
const
auto
byteLen
=
(
aLen
+
1
)
*
sizeof
(
T
)
;
if
(
!
byteLen
.
isValid
(
)
)
{
return
nullptr
;
}
T
*
p
=
static_cast
<
T
*
>
(
aArena
.
Allocate
(
byteLen
.
value
(
)
mozilla
:
:
fallible
)
)
;
if
(
p
)
{
memcpy
(
p
aSrc
byteLen
.
value
(
)
-
sizeof
(
T
)
)
;
p
[
aLen
.
value
(
)
]
=
T
(
0
)
;
}
return
p
;
}
}
#
endif
