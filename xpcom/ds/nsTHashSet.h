#
ifndef
XPCOM_DS_NSTHASHSET_H_
#
define
XPCOM_DS_NSTHASHSET_H_
#
include
"
nsHashtablesFwd
.
h
"
#
include
"
nsTHashMap
.
h
"
template
<
class
KeyClass
>
class
nsTBaseHashSet
:
protected
nsTHashtable
<
KeyClass
>
{
using
Base
=
nsTHashtable
<
KeyClass
>
;
typedef
mozilla
:
:
fallible_t
fallible_t
;
public
:
using
ValueType
=
typename
KeyClass
:
:
KeyType
;
using
KeyType
=
typename
KeyClass
:
:
KeyType
;
using
Base
:
:
Base
;
using
Base
:
:
Contains
;
using
Base
:
:
GetGeneration
;
using
Base
:
:
ShallowSizeOfExcludingThis
;
using
Base
:
:
ShallowSizeOfIncludingThis
;
using
Base
:
:
SizeOfExcludingThis
;
using
Base
:
:
SizeOfIncludingThis
;
[
[
nodiscard
]
]
uint32_t
Count
(
)
const
{
return
Base
:
:
Count
(
)
;
}
[
[
nodiscard
]
]
bool
IsEmpty
(
)
const
{
return
Base
:
:
IsEmpty
(
)
;
}
using
iterator
=
:
:
detail
:
:
nsTHashtableKeyIterator
<
KeyClass
>
;
using
const_iterator
=
iterator
;
[
[
nodiscard
]
]
auto
begin
(
)
const
{
return
Base
:
:
Keys
(
)
.
begin
(
)
;
}
[
[
nodiscard
]
]
auto
end
(
)
const
{
return
Base
:
:
Keys
(
)
.
end
(
)
;
}
[
[
nodiscard
]
]
auto
cbegin
(
)
const
{
return
Base
:
:
Keys
(
)
.
cbegin
(
)
;
}
[
[
nodiscard
]
]
auto
cend
(
)
const
{
return
Base
:
:
Keys
(
)
.
cend
(
)
;
}
using
Base
:
:
Clear
;
using
Base
:
:
MarkImmutable
;
void
Insert
(
ValueType
aValue
)
{
Base
:
:
PutEntry
(
aValue
)
;
}
[
[
nodiscard
]
]
bool
Insert
(
ValueType
aValue
const
mozilla
:
:
fallible_t
&
)
{
return
Base
:
:
PutEntry
(
aValue
mozilla
:
:
fallible
)
;
}
bool
EnsureInserted
(
ValueType
aValue
)
{
return
Base
:
:
EnsureInserted
(
aValue
)
;
}
using
Base
:
:
Remove
;
void
Remove
(
ValueType
aValue
)
{
Base
:
:
RemoveEntry
(
aValue
)
;
}
using
Base
:
:
EnsureRemoved
;
template
<
typename
Pred
>
void
RemoveIf
(
Pred
&
&
aPred
)
{
for
(
auto
it
=
cbegin
(
)
end
=
cend
(
)
;
it
!
=
end
;
+
+
it
)
{
if
(
aPred
(
static_cast
<
ValueType
>
(
*
it
)
)
)
{
Remove
(
it
)
;
}
}
}
}
;
template
<
typename
KeyClass
>
auto
RangeSize
(
const
nsTBaseHashSet
<
KeyClass
>
&
aRange
)
{
return
aRange
.
Count
(
)
;
}
class
nsCycleCollectionTraversalCallback
;
template
<
class
KeyClass
>
inline
void
ImplCycleCollectionUnlink
(
nsTBaseHashSet
<
KeyClass
>
&
aField
)
{
aField
.
Clear
(
)
;
}
template
<
class
KeyClass
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
const
nsTBaseHashSet
<
KeyClass
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
for
(
const
auto
&
entry
:
aField
)
{
CycleCollectionNoteChild
(
aCallback
mozilla
:
:
detail
:
:
PtrGetWeak
(
entry
)
aName
aFlags
)
;
}
}
namespace
mozilla
{
template
<
typename
SetT
>
class
nsTSetInserter
{
SetT
*
mSet
;
class
Proxy
{
SetT
&
mSet
;
public
:
explicit
Proxy
(
SetT
&
aSet
)
:
mSet
{
aSet
}
{
}
template
<
typename
E2
>
void
operator
=
(
E2
&
&
aValue
)
{
mSet
.
Insert
(
std
:
:
forward
<
E2
>
(
aValue
)
)
;
}
}
;
public
:
using
iterator_category
=
std
:
:
output_iterator_tag
;
explicit
nsTSetInserter
(
SetT
&
aSet
)
:
mSet
{
&
aSet
}
{
}
Proxy
operator
*
(
)
{
return
Proxy
(
*
mSet
)
;
}
nsTSetInserter
&
operator
+
+
(
)
{
return
*
this
;
}
nsTSetInserter
&
operator
+
+
(
int
)
{
return
*
this
;
}
}
;
}
template
<
typename
E
>
auto
MakeInserter
(
nsTBaseHashSet
<
E
>
&
aSet
)
{
return
mozilla
:
:
nsTSetInserter
<
nsTBaseHashSet
<
E
>
>
{
aSet
}
;
}
#
endif
