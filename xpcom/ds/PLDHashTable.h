#
ifndef
PLDHashTable_h
#
define
PLDHashTable_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
nscore
.
h
"
typedef
uint32_t
PLDHashNumber
;
class
PLDHashTable
;
struct
PLDHashTableOps
;
struct
PLDHashEntryHdr
{
private
:
friend
class
PLDHashTable
;
PLDHashNumber
mKeyHash
;
}
;
#
ifdef
DEBUG
class
Checker
{
public
:
constexpr
Checker
(
)
:
mState
(
kIdle
)
mIsWritable
(
1
)
{
}
Checker
&
operator
=
(
Checker
&
&
aOther
)
{
mState
=
uint32_t
(
aOther
.
mState
)
;
mIsWritable
=
uint32_t
(
aOther
.
mIsWritable
)
;
aOther
.
mState
=
kIdle
;
return
*
this
;
}
static
bool
IsIdle
(
uint32_t
aState
)
{
return
aState
=
=
kIdle
;
}
static
bool
IsRead
(
uint32_t
aState
)
{
return
kRead1
<
=
aState
&
&
aState
<
=
kReadMax
;
}
static
bool
IsRead1
(
uint32_t
aState
)
{
return
aState
=
=
kRead1
;
}
static
bool
IsWrite
(
uint32_t
aState
)
{
return
aState
=
=
kWrite
;
}
bool
IsIdle
(
)
const
{
return
mState
=
=
kIdle
;
}
bool
IsWritable
(
)
const
{
return
!
!
mIsWritable
;
}
void
SetNonWritable
(
)
{
mIsWritable
=
0
;
}
void
StartReadOp
(
)
{
uint32_t
oldState
=
mState
+
+
;
MOZ_ASSERT
(
IsIdle
(
oldState
)
|
|
IsRead
(
oldState
)
)
;
MOZ_ASSERT
(
oldState
<
kReadMax
)
;
}
void
EndReadOp
(
)
{
uint32_t
oldState
=
mState
-
-
;
MOZ_ASSERT
(
IsRead
(
oldState
)
)
;
}
void
StartWriteOp
(
)
{
MOZ_ASSERT
(
IsWritable
(
)
)
;
uint32_t
oldState
=
mState
.
exchange
(
kWrite
)
;
MOZ_ASSERT
(
IsIdle
(
oldState
)
)
;
}
void
EndWriteOp
(
)
{
MOZ_ASSERT
(
IsWritable
(
)
)
;
uint32_t
oldState
=
mState
.
exchange
(
kIdle
)
;
MOZ_ASSERT
(
IsWrite
(
oldState
)
)
;
}
void
StartIteratorRemovalOp
(
)
{
MOZ_ASSERT
(
IsWritable
(
)
)
;
uint32_t
oldState
=
mState
.
exchange
(
kWrite
)
;
MOZ_ASSERT
(
IsRead1
(
oldState
)
)
;
}
void
EndIteratorRemovalOp
(
)
{
MOZ_ASSERT
(
IsWritable
(
)
)
;
uint32_t
oldState
=
mState
.
exchange
(
kRead1
)
;
MOZ_ASSERT
(
IsWrite
(
oldState
)
)
;
}
void
StartDestructorOp
(
)
{
uint32_t
oldState
=
mState
.
exchange
(
kWrite
)
;
MOZ_ASSERT
(
IsIdle
(
oldState
)
)
;
}
void
EndDestructorOp
(
)
{
uint32_t
oldState
=
mState
.
exchange
(
kIdle
)
;
MOZ_ASSERT
(
IsWrite
(
oldState
)
)
;
}
private
:
static
const
uint32_t
kIdle
=
0
;
static
const
uint32_t
kRead1
=
1
;
static
const
uint32_t
kReadMax
=
9999
;
static
const
uint32_t
kWrite
=
10000
;
mutable
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
SequentiallyConsistent
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
mState
;
mutable
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
SequentiallyConsistent
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
mIsWritable
;
}
;
#
endif
class
PLDHashTable
{
private
:
class
EntryStore
{
private
:
char
*
mEntryStore
;
public
:
EntryStore
(
)
:
mEntryStore
(
nullptr
)
{
}
~
EntryStore
(
)
{
free
(
mEntryStore
)
;
mEntryStore
=
nullptr
;
}
char
*
Get
(
)
{
return
mEntryStore
;
}
const
char
*
Get
(
)
const
{
return
mEntryStore
;
}
void
Set
(
char
*
aEntryStore
uint16_t
*
aGeneration
)
{
mEntryStore
=
aEntryStore
;
*
aGeneration
+
=
1
;
}
}
;
const
PLDHashTableOps
*
const
mOps
;
EntryStore
mEntryStore
;
uint16_t
mGeneration
;
uint8_t
mHashShift
;
const
uint8_t
mEntrySize
;
uint32_t
mEntryCount
;
uint32_t
mRemovedCount
;
#
ifdef
DEBUG
mutable
Checker
mChecker
;
#
endif
public
:
static
const
uint32_t
kMaxCapacity
=
(
(
uint32_t
)
1
<
<
26
)
;
static
const
uint32_t
kMinCapacity
=
8
;
static
const
uint32_t
kMaxInitialLength
=
kMaxCapacity
/
2
;
static
const
uint32_t
kDefaultInitialLength
=
4
;
PLDHashTable
(
const
PLDHashTableOps
*
aOps
uint32_t
aEntrySize
uint32_t
aLength
=
kDefaultInitialLength
)
;
PLDHashTable
(
PLDHashTable
&
&
aOther
)
:
mOps
(
aOther
.
mOps
)
mEntryStore
(
)
mGeneration
(
0
)
mEntrySize
(
aOther
.
mEntrySize
)
#
ifdef
DEBUG
mChecker
(
)
#
endif
{
*
this
=
std
:
:
move
(
aOther
)
;
}
PLDHashTable
&
operator
=
(
PLDHashTable
&
&
aOther
)
;
~
PLDHashTable
(
)
;
const
PLDHashTableOps
*
Ops
(
)
const
{
return
mOps
;
}
uint32_t
Capacity
(
)
const
{
return
mEntryStore
.
Get
(
)
?
CapacityFromHashShift
(
)
:
0
;
}
uint32_t
EntrySize
(
)
const
{
return
mEntrySize
;
}
uint32_t
EntryCount
(
)
const
{
return
mEntryCount
;
}
uint32_t
Generation
(
)
const
{
return
mGeneration
;
}
PLDHashEntryHdr
*
Search
(
const
void
*
aKey
)
const
;
PLDHashEntryHdr
*
Add
(
const
void
*
aKey
const
mozilla
:
:
fallible_t
&
)
;
PLDHashEntryHdr
*
Add
(
const
void
*
aKey
)
;
void
Remove
(
const
void
*
aKey
)
;
void
RemoveEntry
(
PLDHashEntryHdr
*
aEntry
)
;
void
RawRemove
(
PLDHashEntryHdr
*
aEntry
)
;
void
Clear
(
)
;
void
ClearAndPrepareForLength
(
uint32_t
aLength
)
;
size_t
ShallowSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
size_t
ShallowSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
#
ifdef
DEBUG
void
MarkImmutable
(
)
;
#
endif
static
const
PLDHashTableOps
*
StubOps
(
)
;
static
PLDHashNumber
HashVoidPtrKeyStub
(
const
void
*
aKey
)
;
static
bool
MatchEntryStub
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
;
static
void
MoveEntryStub
(
PLDHashTable
*
aTable
const
PLDHashEntryHdr
*
aFrom
PLDHashEntryHdr
*
aTo
)
;
static
void
ClearEntryStub
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
;
static
PLDHashNumber
HashStringKey
(
const
void
*
aKey
)
;
static
bool
MatchStringKey
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
;
class
Iterator
{
public
:
explicit
Iterator
(
PLDHashTable
*
aTable
)
;
Iterator
(
Iterator
&
&
aOther
)
;
~
Iterator
(
)
;
bool
Done
(
)
const
{
return
mNexts
=
=
mNextsLimit
;
}
PLDHashEntryHdr
*
Get
(
)
const
{
MOZ_ASSERT
(
!
Done
(
)
)
;
PLDHashEntryHdr
*
entry
=
reinterpret_cast
<
PLDHashEntryHdr
*
>
(
mCurrent
)
;
MOZ_ASSERT
(
EntryIsLive
(
entry
)
)
;
return
entry
;
}
void
Next
(
)
;
void
Remove
(
)
;
protected
:
PLDHashTable
*
mTable
;
private
:
char
*
mStart
;
char
*
mLimit
;
char
*
mCurrent
;
uint32_t
mNexts
;
uint32_t
mNextsLimit
;
bool
mHaveRemoved
;
bool
IsOnNonLiveEntry
(
)
const
;
void
MoveToNextEntry
(
)
;
Iterator
(
)
=
delete
;
Iterator
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
&
)
=
delete
;
}
;
Iterator
Iter
(
)
{
return
Iterator
(
this
)
;
}
Iterator
ConstIter
(
)
const
{
return
Iterator
(
const_cast
<
PLDHashTable
*
>
(
this
)
)
;
}
private
:
static
const
uint32_t
kHashBits
=
32
;
static
const
uint32_t
kGoldenRatio
=
0x9E3779B9U
;
static
uint32_t
HashShift
(
uint32_t
aEntrySize
uint32_t
aLength
)
;
static
const
PLDHashNumber
kCollisionFlag
=
1
;
static
bool
EntryIsFree
(
const
PLDHashEntryHdr
*
aEntry
)
{
return
aEntry
-
>
mKeyHash
=
=
0
;
}
static
bool
EntryIsRemoved
(
const
PLDHashEntryHdr
*
aEntry
)
{
return
aEntry
-
>
mKeyHash
=
=
1
;
}
static
bool
EntryIsLive
(
const
PLDHashEntryHdr
*
aEntry
)
{
return
aEntry
-
>
mKeyHash
>
=
2
;
}
static
void
MarkEntryFree
(
PLDHashEntryHdr
*
aEntry
)
{
aEntry
-
>
mKeyHash
=
0
;
}
static
void
MarkEntryRemoved
(
PLDHashEntryHdr
*
aEntry
)
{
aEntry
-
>
mKeyHash
=
1
;
}
PLDHashNumber
Hash1
(
PLDHashNumber
aHash0
)
const
;
void
Hash2
(
PLDHashNumber
aHash
uint32_t
&
aHash2Out
uint32_t
&
aSizeMaskOut
)
const
;
static
bool
MatchEntryKeyhash
(
const
PLDHashEntryHdr
*
aEntry
const
PLDHashNumber
aHash
)
;
PLDHashEntryHdr
*
AddressEntry
(
uint32_t
aIndex
)
const
;
uint32_t
CapacityFromHashShift
(
)
const
{
return
(
(
uint32_t
)
1
<
<
(
kHashBits
-
mHashShift
)
)
;
}
PLDHashNumber
ComputeKeyHash
(
const
void
*
aKey
)
const
;
enum
SearchReason
{
ForSearchOrRemove
ForAdd
}
;
template
<
SearchReason
Reason
>
PLDHashEntryHdr
*
NS_FASTCALL
SearchTable
(
const
void
*
aKey
PLDHashNumber
aKeyHash
)
const
;
PLDHashEntryHdr
*
FindFreeEntry
(
PLDHashNumber
aKeyHash
)
const
;
bool
ChangeTable
(
int
aDeltaLog2
)
;
void
ShrinkIfAppropriate
(
)
;
PLDHashTable
(
const
PLDHashTable
&
aOther
)
=
delete
;
PLDHashTable
&
operator
=
(
const
PLDHashTable
&
aOther
)
=
delete
;
}
;
typedef
PLDHashNumber
(
*
PLDHashHashKey
)
(
const
void
*
aKey
)
;
typedef
bool
(
*
PLDHashMatchEntry
)
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
;
typedef
void
(
*
PLDHashMoveEntry
)
(
PLDHashTable
*
aTable
const
PLDHashEntryHdr
*
aFrom
PLDHashEntryHdr
*
aTo
)
;
typedef
void
(
*
PLDHashClearEntry
)
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
;
typedef
void
(
*
PLDHashInitEntry
)
(
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
;
struct
PLDHashTableOps
{
PLDHashHashKey
hashKey
;
PLDHashMatchEntry
matchEntry
;
PLDHashMoveEntry
moveEntry
;
PLDHashClearEntry
clearEntry
;
PLDHashInitEntry
initEntry
;
}
;
struct
PLDHashEntryStub
:
public
PLDHashEntryHdr
{
const
void
*
key
;
}
;
#
endif
