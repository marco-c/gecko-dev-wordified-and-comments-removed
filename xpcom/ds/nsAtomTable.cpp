#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsAtomTable
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsStaticAtom
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
prenv
.
h
"
using
namespace
mozilla
;
enum
class
GCKind
{
RegularOperation
Shutdown
}
;
static
Atomic
<
int32_t
ReleaseAcquire
recordreplay
:
:
Behavior
:
:
DontPreserve
>
gUnusedAtomCount
(
0
)
;
nsDynamicAtom
:
:
nsDynamicAtom
(
const
nsAString
&
aString
uint32_t
aHash
)
:
nsAtom
(
AtomKind
:
:
DynamicNormal
aString
aHash
)
mRefCnt
(
1
)
{
}
nsDynamicAtom
*
nsDynamicAtom
:
:
CreateInner
(
const
nsAString
&
aString
uint32_t
aHash
)
{
size_t
numCharBytes
=
(
aString
.
Length
(
)
+
1
)
*
sizeof
(
char16_t
)
;
size_t
numTotalBytes
=
sizeof
(
nsDynamicAtom
)
+
numCharBytes
;
nsDynamicAtom
*
atom
=
(
nsDynamicAtom
*
)
moz_xmalloc
(
numTotalBytes
)
;
new
(
atom
)
nsDynamicAtom
(
aString
aHash
)
;
memcpy
(
const_cast
<
char16_t
*
>
(
atom
-
>
String
(
)
)
PromiseFlatString
(
aString
)
.
get
(
)
numCharBytes
)
;
MOZ_ASSERT
(
atom
-
>
String
(
)
[
atom
-
>
GetLength
(
)
]
=
=
char16_t
(
0
)
)
;
MOZ_ASSERT
(
atom
-
>
Equals
(
aString
)
)
;
return
atom
;
}
nsDynamicAtom
*
nsDynamicAtom
:
:
Create
(
const
nsAString
&
aString
uint32_t
aHash
)
{
nsDynamicAtom
*
atom
=
CreateInner
(
aString
aHash
)
;
MOZ_ASSERT
(
atom
-
>
mHash
=
=
HashString
(
atom
-
>
String
(
)
atom
-
>
GetLength
(
)
)
)
;
return
atom
;
}
nsDynamicAtom
*
nsDynamicAtom
:
:
Create
(
const
nsAString
&
aString
)
{
return
CreateInner
(
aString
0
)
;
}
void
nsDynamicAtom
:
:
Destroy
(
nsDynamicAtom
*
aAtom
)
{
aAtom
-
>
~
nsDynamicAtom
(
)
;
free
(
aAtom
)
;
}
const
nsStaticAtom
*
nsAtom
:
:
AsStatic
(
)
const
{
MOZ_ASSERT
(
IsStatic
(
)
)
;
return
static_cast
<
const
nsStaticAtom
*
>
(
this
)
;
}
const
nsDynamicAtom
*
nsAtom
:
:
AsDynamic
(
)
const
{
MOZ_ASSERT
(
IsDynamic
(
)
)
;
return
static_cast
<
const
nsDynamicAtom
*
>
(
this
)
;
}
nsDynamicAtom
*
nsAtom
:
:
AsDynamic
(
)
{
MOZ_ASSERT
(
IsDynamic
(
)
)
;
return
static_cast
<
nsDynamicAtom
*
>
(
this
)
;
}
void
nsAtom
:
:
ToString
(
nsAString
&
aString
)
const
{
if
(
IsStatic
(
)
)
{
aString
.
AssignLiteral
(
AsStatic
(
)
-
>
String
(
)
mLength
)
;
}
else
{
aString
.
Assign
(
AsDynamic
(
)
-
>
String
(
)
mLength
)
;
}
}
void
nsAtom
:
:
ToUTF8String
(
nsACString
&
aBuf
)
const
{
MOZ_ASSERT
(
!
IsDynamicHTML5
(
)
"
Called
ToUTF8String
(
)
on
a
dynamic
HTML5
atom
"
)
;
CopyUTF16toUTF8
(
nsDependentString
(
GetUTF16String
(
)
mLength
)
aBuf
)
;
}
void
nsAtom
:
:
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
const
{
MOZ_ASSERT
(
!
IsDynamicHTML5
(
)
"
Called
AddSizeOfIncludingThis
(
)
on
a
dynamic
HTML5
atom
"
)
;
if
(
IsDynamic
(
)
)
{
aSizes
.
mDynamicAtoms
+
=
aMallocSizeOf
(
this
)
;
}
}
char16ptr_t
nsAtom
:
:
GetUTF16String
(
)
const
{
return
IsStatic
(
)
?
AsStatic
(
)
-
>
String
(
)
:
AsDynamic
(
)
-
>
String
(
)
;
}
struct
AtomTableKey
{
explicit
AtomTableKey
(
const
nsStaticAtom
*
aAtom
)
:
mUTF16String
(
aAtom
-
>
String
(
)
)
mUTF8String
(
nullptr
)
mLength
(
aAtom
-
>
GetLength
(
)
)
mHash
(
aAtom
-
>
hash
(
)
)
{
MOZ_ASSERT
(
HashString
(
mUTF16String
mLength
)
=
=
mHash
)
;
}
AtomTableKey
(
const
char16_t
*
aUTF16String
uint32_t
aLength
uint32_t
*
aHashOut
)
:
mUTF16String
(
aUTF16String
)
mUTF8String
(
nullptr
)
mLength
(
aLength
)
{
mHash
=
HashString
(
mUTF16String
mLength
)
;
*
aHashOut
=
mHash
;
}
AtomTableKey
(
const
char
*
aUTF8String
uint32_t
aLength
uint32_t
*
aHashOut
)
:
mUTF16String
(
nullptr
)
mUTF8String
(
aUTF8String
)
mLength
(
aLength
)
{
bool
err
;
mHash
=
HashUTF8AsUTF16
(
mUTF8String
mLength
&
err
)
;
if
(
err
)
{
mUTF8String
=
nullptr
;
mLength
=
0
;
mHash
=
0
;
}
*
aHashOut
=
mHash
;
}
const
char16_t
*
mUTF16String
;
const
char
*
mUTF8String
;
uint32_t
mLength
;
uint32_t
mHash
;
}
;
struct
AtomTableEntry
:
public
PLDHashEntryHdr
{
nsAtom
*
MOZ_NON_OWNING_REF
mAtom
;
}
;
#
define
RECENTLY_USED_MAIN_THREAD_ATOM_CACHE_SIZE
31
static
nsAtom
*
sRecentlyUsedMainThreadAtoms
[
RECENTLY_USED_MAIN_THREAD_ATOM_CACHE_SIZE
]
=
{
}
;
class
nsAtomSubTable
{
friend
class
nsAtomTable
;
Mutex
mLock
;
PLDHashTable
mTable
;
nsAtomSubTable
(
)
;
void
GCLocked
(
GCKind
aKind
)
;
void
AddSizeOfExcludingThisLocked
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
;
AtomTableEntry
*
Search
(
AtomTableKey
&
aKey
)
const
{
mLock
.
AssertCurrentThreadOwns
(
)
;
return
static_cast
<
AtomTableEntry
*
>
(
mTable
.
Search
(
&
aKey
)
)
;
}
AtomTableEntry
*
Add
(
AtomTableKey
&
aKey
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
return
static_cast
<
AtomTableEntry
*
>
(
mTable
.
Add
(
&
aKey
)
)
;
}
}
;
class
nsAtomTable
{
public
:
nsAtomSubTable
&
SelectSubTable
(
AtomTableKey
&
aKey
)
;
void
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
;
void
GC
(
GCKind
aKind
)
;
already_AddRefed
<
nsAtom
>
Atomize
(
const
nsAString
&
aUTF16String
)
;
already_AddRefed
<
nsAtom
>
Atomize
(
const
nsACString
&
aUTF8String
)
;
already_AddRefed
<
nsAtom
>
AtomizeMainThread
(
const
nsAString
&
aUTF16String
)
;
nsStaticAtom
*
GetStaticAtom
(
const
nsAString
&
aUTF16String
)
;
void
RegisterStaticAtoms
(
const
nsStaticAtom
*
aAtoms
size_t
aAtomsLen
)
;
size_t
RacySlowCount
(
)
;
static
void
AtomTableClearEntry
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
;
const
static
size_t
kNumSubTables
=
128
;
private
:
nsAtomSubTable
mSubTables
[
kNumSubTables
]
;
}
;
static
nsAtomTable
*
gAtomTable
;
static
PLDHashNumber
AtomTableGetHash
(
const
void
*
aKey
)
{
const
AtomTableKey
*
k
=
static_cast
<
const
AtomTableKey
*
>
(
aKey
)
;
return
k
-
>
mHash
;
}
static
bool
AtomTableMatchKey
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
const
AtomTableEntry
*
he
=
static_cast
<
const
AtomTableEntry
*
>
(
aEntry
)
;
const
AtomTableKey
*
k
=
static_cast
<
const
AtomTableKey
*
>
(
aKey
)
;
if
(
k
-
>
mUTF8String
)
{
return
CompareUTF8toUTF16
(
nsDependentCSubstring
(
k
-
>
mUTF8String
k
-
>
mUTF8String
+
k
-
>
mLength
)
nsDependentAtomString
(
he
-
>
mAtom
)
)
=
=
0
;
}
return
he
-
>
mAtom
-
>
Equals
(
k
-
>
mUTF16String
k
-
>
mLength
)
;
}
void
nsAtomTable
:
:
AtomTableClearEntry
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
{
auto
entry
=
static_cast
<
AtomTableEntry
*
>
(
aEntry
)
;
entry
-
>
mAtom
=
nullptr
;
}
static
void
AtomTableInitEntry
(
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
static_cast
<
AtomTableEntry
*
>
(
aEntry
)
-
>
mAtom
=
nullptr
;
}
static
const
PLDHashTableOps
AtomTableOps
=
{
AtomTableGetHash
AtomTableMatchKey
PLDHashTable
:
:
MoveEntryStub
nsAtomTable
:
:
AtomTableClearEntry
AtomTableInitEntry
}
;
#
define
INITIAL_SUBTABLE_LENGTH
(
4096
/
nsAtomTable
:
:
kNumSubTables
)
nsAtomSubTable
&
nsAtomTable
:
:
SelectSubTable
(
AtomTableKey
&
aKey
)
{
static_assert
(
(
kNumSubTables
&
(
kNumSubTables
-
1
)
)
=
=
0
"
must
be
power
of
two
"
)
;
return
mSubTables
[
aKey
.
mHash
&
(
kNumSubTables
-
1
)
]
;
}
void
nsAtomTable
:
:
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aSizes
.
mTable
+
=
aMallocSizeOf
(
this
)
;
for
(
auto
&
table
:
mSubTables
)
{
MutexAutoLock
lock
(
table
.
mLock
)
;
table
.
AddSizeOfExcludingThisLocked
(
aMallocSizeOf
aSizes
)
;
}
}
void
nsAtomTable
:
:
GC
(
GCKind
aKind
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
RECENTLY_USED_MAIN_THREAD_ATOM_CACHE_SIZE
;
+
+
i
)
{
sRecentlyUsedMainThreadAtoms
[
i
]
=
nullptr
;
}
for
(
auto
&
table
:
mSubTables
)
{
MutexAutoLock
lock
(
table
.
mLock
)
;
table
.
GCLocked
(
aKind
)
;
}
MOZ_ASSERT_IF
(
aKind
=
=
GCKind
:
:
Shutdown
gUnusedAtomCount
=
=
0
)
;
}
size_t
nsAtomTable
:
:
RacySlowCount
(
)
{
GC
(
GCKind
:
:
RegularOperation
)
;
size_t
count
=
0
;
for
(
auto
&
table
:
mSubTables
)
{
MutexAutoLock
lock
(
table
.
mLock
)
;
count
+
=
table
.
mTable
.
EntryCount
(
)
;
}
return
count
;
}
nsAtomSubTable
:
:
nsAtomSubTable
(
)
:
mLock
(
"
Atom
Sub
-
Table
Lock
"
)
mTable
(
&
AtomTableOps
sizeof
(
AtomTableEntry
)
INITIAL_SUBTABLE_LENGTH
)
{
}
void
nsAtomSubTable
:
:
GCLocked
(
GCKind
aKind
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
int32_t
removedCount
=
0
;
nsAutoCString
nonZeroRefcountAtoms
;
uint32_t
nonZeroRefcountAtomsCount
=
0
;
for
(
auto
i
=
mTable
.
Iter
(
)
;
!
i
.
Done
(
)
;
i
.
Next
(
)
)
{
auto
entry
=
static_cast
<
AtomTableEntry
*
>
(
i
.
Get
(
)
)
;
if
(
entry
-
>
mAtom
-
>
IsStatic
(
)
)
{
continue
;
}
nsAtom
*
atom
=
entry
-
>
mAtom
;
MOZ_ASSERT
(
!
atom
-
>
IsDynamicHTML5
(
)
)
;
if
(
atom
-
>
IsDynamic
(
)
&
&
atom
-
>
AsDynamic
(
)
-
>
mRefCnt
=
=
0
)
{
i
.
Remove
(
)
;
nsDynamicAtom
:
:
Destroy
(
atom
-
>
AsDynamic
(
)
)
;
+
+
removedCount
;
}
#
ifdef
NS_FREE_PERMANENT_DATA
else
if
(
aKind
=
=
GCKind
:
:
Shutdown
&
&
PR_GetEnv
(
"
XPCOM_MEM_BLOAT_LOG
"
)
)
{
nsAutoCString
name
;
atom
-
>
ToUTF8String
(
name
)
;
if
(
nonZeroRefcountAtomsCount
=
=
0
)
{
nonZeroRefcountAtoms
=
name
;
}
else
if
(
nonZeroRefcountAtomsCount
<
20
)
{
nonZeroRefcountAtoms
+
=
NS_LITERAL_CSTRING
(
"
"
)
+
name
;
}
else
if
(
nonZeroRefcountAtomsCount
=
=
20
)
{
nonZeroRefcountAtoms
+
=
NS_LITERAL_CSTRING
(
"
.
.
.
"
)
;
}
nonZeroRefcountAtomsCount
+
+
;
}
#
endif
}
if
(
nonZeroRefcountAtomsCount
)
{
nsPrintfCString
msg
(
"
%
d
dynamic
atom
(
s
)
with
non
-
zero
refcount
:
%
s
"
nonZeroRefcountAtomsCount
nonZeroRefcountAtoms
.
get
(
)
)
;
NS_ASSERTION
(
nonZeroRefcountAtomsCount
=
=
0
msg
.
get
(
)
)
;
}
gUnusedAtomCount
-
=
removedCount
;
}
static
void
GCAtomTable
(
)
{
MOZ_ASSERT
(
gAtomTable
)
;
if
(
NS_IsMainThread
(
)
)
{
gAtomTable
-
>
GC
(
GCKind
:
:
RegularOperation
)
;
}
}
MOZ_ALWAYS_INLINE
MozExternalRefCountType
nsDynamicAtom
:
:
AddRef
(
)
{
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
=
0
"
illegal
refcnt
"
)
;
nsrefcnt
count
=
+
+
mRefCnt
;
if
(
count
=
=
1
)
{
gUnusedAtomCount
-
-
;
}
return
count
;
}
MOZ_ALWAYS_INLINE
MozExternalRefCountType
nsDynamicAtom
:
:
Release
(
)
{
#
ifdef
DEBUG
static
const
int32_t
kAtomGCThreshold
=
20
;
#
else
static
const
int32_t
kAtomGCThreshold
=
10000
;
#
endif
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
0
"
dup
release
"
)
;
nsrefcnt
count
=
-
-
mRefCnt
;
if
(
count
=
=
0
)
{
if
(
+
+
gUnusedAtomCount
>
=
kAtomGCThreshold
)
{
GCAtomTable
(
)
;
}
}
return
count
;
}
MozExternalRefCountType
nsAtom
:
:
AddRef
(
)
{
MOZ_ASSERT
(
!
IsDynamicHTML5
(
)
"
Attempt
to
AddRef
a
dynamic
HTML5
atom
"
)
;
return
IsStatic
(
)
?
2
:
AsDynamic
(
)
-
>
AddRef
(
)
;
}
MozExternalRefCountType
nsAtom
:
:
Release
(
)
{
MOZ_ASSERT
(
!
IsDynamicHTML5
(
)
"
Attempt
to
Release
a
dynamic
HTML5
atom
"
)
;
return
IsStatic
(
)
?
1
:
AsDynamic
(
)
-
>
Release
(
)
;
}
static
bool
gStaticAtomsDone
=
false
;
void
NS_InitAtomTable
(
)
{
MOZ_ASSERT
(
!
gAtomTable
)
;
gAtomTable
=
new
nsAtomTable
(
)
;
nsGkAtoms
:
:
RegisterStaticAtoms
(
)
;
}
void
NS_ShutdownAtomTable
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
gAtomTable
)
;
#
ifdef
NS_FREE_PERMANENT_DATA
gAtomTable
-
>
GC
(
GCKind
:
:
Shutdown
)
;
#
endif
delete
gAtomTable
;
gAtomTable
=
nullptr
;
}
void
NS_AddSizeOfAtoms
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
AddSizeOfIncludingThis
(
aMallocSizeOf
aSizes
)
;
}
void
nsAtomSubTable
:
:
AddSizeOfExcludingThisLocked
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
aSizes
.
mTable
+
=
mTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
AtomTableEntry
*
>
(
iter
.
Get
(
)
)
;
entry
-
>
mAtom
-
>
AddSizeOfIncludingThis
(
aMallocSizeOf
aSizes
)
;
}
}
void
nsAtomTable
:
:
RegisterStaticAtoms
(
const
nsStaticAtom
*
aAtoms
size_t
aAtomsLen
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gStaticAtomsDone
"
Static
atom
insertion
is
finished
!
"
)
;
for
(
uint32_t
i
=
0
;
i
<
aAtomsLen
;
+
+
i
)
{
const
nsStaticAtom
*
atom
=
&
aAtoms
[
i
]
;
MOZ_ASSERT
(
nsCRT
:
:
IsAscii
(
atom
-
>
String
(
)
)
)
;
MOZ_ASSERT
(
NS_strlen
(
atom
-
>
String
(
)
)
=
=
atom
-
>
GetLength
(
)
)
;
AtomTableKey
key
(
atom
)
;
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
MutexAutoLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Add
(
key
)
;
if
(
he
-
>
mAtom
)
{
nsAutoCString
name
;
he
-
>
mAtom
-
>
ToUTF8String
(
name
)
;
MOZ_CRASH_UNSAFE_PRINTF
(
"
Atom
for
'
%
s
'
already
exists
"
name
.
get
(
)
)
;
}
he
-
>
mAtom
=
const_cast
<
nsStaticAtom
*
>
(
atom
)
;
}
}
void
NS_RegisterStaticAtoms
(
const
nsStaticAtom
*
aAtoms
size_t
aAtomsLen
)
{
MOZ_ASSERT
(
gAtomTable
)
;
gAtomTable
-
>
RegisterStaticAtoms
(
aAtoms
aAtomsLen
)
;
}
already_AddRefed
<
nsAtom
>
NS_Atomize
(
const
char
*
aUTF8String
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
Atomize
(
nsDependentCString
(
aUTF8String
)
)
;
}
already_AddRefed
<
nsAtom
>
nsAtomTable
:
:
Atomize
(
const
nsACString
&
aUTF8String
)
{
uint32_t
hash
;
AtomTableKey
key
(
aUTF8String
.
Data
(
)
aUTF8String
.
Length
(
)
&
hash
)
;
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
MutexAutoLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Add
(
key
)
;
if
(
he
-
>
mAtom
)
{
RefPtr
<
nsAtom
>
atom
=
he
-
>
mAtom
;
return
atom
.
forget
(
)
;
}
nsString
str
;
CopyUTF8toUTF16
(
aUTF8String
str
)
;
RefPtr
<
nsAtom
>
atom
=
dont_AddRef
(
nsDynamicAtom
:
:
Create
(
str
hash
)
)
;
he
-
>
mAtom
=
atom
;
return
atom
.
forget
(
)
;
}
already_AddRefed
<
nsAtom
>
NS_Atomize
(
const
nsACString
&
aUTF8String
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
Atomize
(
aUTF8String
)
;
}
already_AddRefed
<
nsAtom
>
NS_Atomize
(
const
char16_t
*
aUTF16String
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
Atomize
(
nsDependentString
(
aUTF16String
)
)
;
}
already_AddRefed
<
nsAtom
>
nsAtomTable
:
:
Atomize
(
const
nsAString
&
aUTF16String
)
{
uint32_t
hash
;
AtomTableKey
key
(
aUTF16String
.
Data
(
)
aUTF16String
.
Length
(
)
&
hash
)
;
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
MutexAutoLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Add
(
key
)
;
if
(
he
-
>
mAtom
)
{
RefPtr
<
nsAtom
>
atom
=
he
-
>
mAtom
;
return
atom
.
forget
(
)
;
}
RefPtr
<
nsAtom
>
atom
=
dont_AddRef
(
nsDynamicAtom
:
:
Create
(
aUTF16String
hash
)
)
;
he
-
>
mAtom
=
atom
;
return
atom
.
forget
(
)
;
}
already_AddRefed
<
nsAtom
>
NS_Atomize
(
const
nsAString
&
aUTF16String
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
Atomize
(
aUTF16String
)
;
}
already_AddRefed
<
nsAtom
>
nsAtomTable
:
:
AtomizeMainThread
(
const
nsAString
&
aUTF16String
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
nsAtom
>
retVal
;
uint32_t
hash
;
AtomTableKey
key
(
aUTF16String
.
Data
(
)
aUTF16String
.
Length
(
)
&
hash
)
;
uint32_t
index
=
hash
%
RECENTLY_USED_MAIN_THREAD_ATOM_CACHE_SIZE
;
nsAtom
*
atom
=
sRecentlyUsedMainThreadAtoms
[
index
]
;
if
(
atom
)
{
uint32_t
length
=
atom
-
>
GetLength
(
)
;
if
(
length
=
=
key
.
mLength
&
&
(
memcmp
(
atom
-
>
GetUTF16String
(
)
key
.
mUTF16String
length
*
sizeof
(
char16_t
)
)
=
=
0
)
)
{
retVal
=
atom
;
return
retVal
.
forget
(
)
;
}
}
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
MutexAutoLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Add
(
key
)
;
if
(
he
-
>
mAtom
)
{
retVal
=
he
-
>
mAtom
;
}
else
{
RefPtr
<
nsAtom
>
newAtom
=
dont_AddRef
(
nsDynamicAtom
:
:
Create
(
aUTF16String
hash
)
)
;
he
-
>
mAtom
=
newAtom
;
retVal
=
newAtom
.
forget
(
)
;
}
sRecentlyUsedMainThreadAtoms
[
index
]
=
he
-
>
mAtom
;
return
retVal
.
forget
(
)
;
}
already_AddRefed
<
nsAtom
>
NS_AtomizeMainThread
(
const
nsAString
&
aUTF16String
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
AtomizeMainThread
(
aUTF16String
)
;
}
nsrefcnt
NS_GetNumberOfAtoms
(
void
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
RacySlowCount
(
)
;
}
int32_t
NS_GetUnusedAtomCount
(
void
)
{
return
gUnusedAtomCount
;
}
nsStaticAtom
*
NS_GetStaticAtom
(
const
nsAString
&
aUTF16String
)
{
MOZ_ASSERT
(
gStaticAtomsDone
"
Static
atom
setup
not
yet
done
.
"
)
;
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
GetStaticAtom
(
aUTF16String
)
;
}
nsStaticAtom
*
nsAtomTable
:
:
GetStaticAtom
(
const
nsAString
&
aUTF16String
)
{
uint32_t
hash
;
AtomTableKey
key
(
aUTF16String
.
Data
(
)
aUTF16String
.
Length
(
)
&
hash
)
;
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
MutexAutoLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Search
(
key
)
;
return
he
&
&
he
-
>
mAtom
-
>
IsStatic
(
)
?
static_cast
<
nsStaticAtom
*
>
(
he
-
>
mAtom
)
:
nullptr
;
}
void
NS_SetStaticAtomsDone
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
gStaticAtomsDone
=
true
;
}
void
ToLowerCaseASCII
(
RefPtr
<
nsAtom
>
&
aAtom
)
{
bool
reAtomize
=
false
;
const
nsDependentString
existing
(
aAtom
-
>
GetUTF16String
(
)
aAtom
-
>
GetLength
(
)
)
;
for
(
size_t
i
=
0
;
i
<
existing
.
Length
(
)
;
+
+
i
)
{
if
(
IS_ASCII_UPPER
(
existing
[
i
]
)
)
{
reAtomize
=
true
;
break
;
}
}
if
(
!
reAtomize
)
{
return
;
}
nsAutoString
lowercased
;
ToLowerCaseASCII
(
existing
lowercased
)
;
aAtom
=
NS_Atomize
(
lowercased
)
;
}
