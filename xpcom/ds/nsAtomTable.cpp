#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
MruCache
.
h
"
#
include
"
mozilla
/
RWLock
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsAtomTable
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
prenv
.
h
"
using
namespace
mozilla
;
enum
class
GCKind
{
RegularOperation
Shutdown
}
;
Atomic
<
int32_t
ReleaseAcquire
>
nsDynamicAtom
:
:
gUnusedAtomCount
;
nsDynamicAtom
:
:
nsDynamicAtom
(
already_AddRefed
<
mozilla
:
:
StringBuffer
>
aBuffer
uint32_t
aLength
uint32_t
aHash
bool
aIsAsciiLowercase
)
:
nsAtom
(
aLength
false
aHash
aIsAsciiLowercase
)
mRefCnt
(
1
)
mStringBuffer
(
aBuffer
)
{
}
static
bool
IsAsciiLowercase
(
const
char16_t
*
aString
const
uint32_t
aLength
)
{
for
(
uint32_t
i
=
0
;
i
<
aLength
;
+
+
i
)
{
if
(
IS_ASCII_UPPER
(
aString
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
nsDynamicAtom
*
nsDynamicAtom
:
:
Create
(
const
nsAString
&
aString
uint32_t
aHash
)
{
const
bool
isAsciiLower
=
:
:
IsAsciiLowercase
(
aString
.
Data
(
)
aString
.
Length
(
)
)
;
RefPtr
<
mozilla
:
:
StringBuffer
>
buffer
=
aString
.
GetStringBuffer
(
)
;
if
(
!
buffer
)
{
buffer
=
mozilla
:
:
StringBuffer
:
:
Create
(
aString
.
Data
(
)
aString
.
Length
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
buffer
)
)
{
MOZ_CRASH
(
"
Out
of
memory
atomizing
"
)
;
}
}
else
{
MOZ_ASSERT
(
aString
.
IsTerminated
(
)
"
String
buffers
are
always
null
-
terminated
"
)
;
}
auto
*
atom
=
new
nsDynamicAtom
(
buffer
.
forget
(
)
aString
.
Length
(
)
aHash
isAsciiLower
)
;
MOZ_ASSERT
(
atom
-
>
String
(
)
[
atom
-
>
GetLength
(
)
]
=
=
char16_t
(
0
)
)
;
MOZ_ASSERT
(
atom
-
>
Equals
(
aString
)
)
;
MOZ_ASSERT
(
atom
-
>
mHash
=
=
HashString
(
atom
-
>
String
(
)
atom
-
>
GetLength
(
)
)
)
;
MOZ_ASSERT
(
atom
-
>
mIsAsciiLowercase
=
=
isAsciiLower
)
;
return
atom
;
}
void
nsDynamicAtom
:
:
Destroy
(
nsDynamicAtom
*
aAtom
)
{
delete
aAtom
;
}
void
nsAtom
:
:
ToString
(
nsAString
&
aString
)
const
{
if
(
IsStatic
(
)
)
{
aString
.
AssignLiteral
(
AsStatic
(
)
-
>
String
(
)
mLength
)
;
}
else
{
aString
.
Assign
(
AsDynamic
(
)
-
>
StringBuffer
(
)
mLength
)
;
}
}
void
nsAtom
:
:
ToUTF8String
(
nsACString
&
aBuf
)
const
{
CopyUTF16toUTF8
(
nsDependentString
(
GetUTF16String
(
)
mLength
)
aBuf
)
;
}
void
nsAtom
:
:
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
const
{
if
(
IsDynamic
(
)
)
{
aSizes
.
mDynamicAtoms
+
=
aMallocSizeOf
(
this
)
;
}
}
char16ptr_t
nsAtom
:
:
GetUTF16String
(
)
const
{
return
IsStatic
(
)
?
AsStatic
(
)
-
>
String
(
)
:
AsDynamic
(
)
-
>
String
(
)
;
}
struct
AtomTableKey
{
explicit
AtomTableKey
(
const
nsStaticAtom
*
aAtom
)
:
mUTF16String
(
aAtom
-
>
String
(
)
)
mUTF8String
(
nullptr
)
mLength
(
aAtom
-
>
GetLength
(
)
)
mHash
(
aAtom
-
>
hash
(
)
)
{
MOZ_ASSERT
(
HashString
(
mUTF16String
mLength
)
=
=
mHash
)
;
}
AtomTableKey
(
const
char16_t
*
aUTF16String
uint32_t
aLength
uint32_t
aHash
)
:
mUTF16String
(
aUTF16String
)
mUTF8String
(
nullptr
)
mLength
(
aLength
)
mHash
(
aHash
)
{
MOZ_ASSERT
(
HashString
(
mUTF16String
mLength
)
=
=
mHash
)
;
}
AtomTableKey
(
const
char16_t
*
aUTF16String
uint32_t
aLength
)
:
AtomTableKey
(
aUTF16String
aLength
HashString
(
aUTF16String
aLength
)
)
{
}
AtomTableKey
(
const
char
*
aUTF8String
uint32_t
aLength
bool
*
aErr
)
:
mUTF16String
(
nullptr
)
mUTF8String
(
aUTF8String
)
mLength
(
aLength
)
{
mHash
=
HashUTF8AsUTF16
(
mUTF8String
mLength
aErr
)
;
}
const
char16_t
*
mUTF16String
;
const
char
*
mUTF8String
;
uint32_t
mLength
;
uint32_t
mHash
;
}
;
struct
AtomTableEntry
:
public
PLDHashEntryHdr
{
nsAtom
*
MOZ_NON_OWNING_REF
mAtom
;
}
;
struct
AtomCache
:
public
MruCache
<
AtomTableKey
nsAtom
*
AtomCache
>
{
static
HashNumber
Hash
(
const
AtomTableKey
&
aKey
)
{
return
aKey
.
mHash
;
}
static
bool
Match
(
const
AtomTableKey
&
aKey
const
nsAtom
*
aVal
)
{
MOZ_ASSERT
(
aKey
.
mUTF16String
)
;
return
(
aVal
-
>
hash
(
)
=
=
aKey
.
mHash
)
&
&
aVal
-
>
Equals
(
aKey
.
mUTF16String
aKey
.
mLength
)
;
}
}
;
static
AtomCache
sRecentlyUsedSmallMainThreadAtoms
;
static
AtomCache
sRecentlyUsedLargeMainThreadAtoms
;
class
nsAtomSubTable
{
friend
class
nsAtomTable
;
mozilla
:
:
RWLock
mLock
;
PLDHashTable
mTable
;
nsAtomSubTable
(
)
;
void
GCLocked
(
GCKind
aKind
)
MOZ_REQUIRES
(
mLock
)
;
void
AddSizeOfExcludingThisLocked
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
MOZ_REQUIRES_SHARED
(
mLock
)
;
AtomTableEntry
*
Search
(
AtomTableKey
&
aKey
)
const
MOZ_REQUIRES_SHARED
(
mLock
)
{
return
static_cast
<
AtomTableEntry
*
>
(
mTable
.
Search
(
&
aKey
)
)
;
}
AtomTableEntry
*
Add
(
AtomTableKey
&
aKey
)
MOZ_REQUIRES
(
mLock
)
{
MOZ_ASSERT
(
mLock
.
LockedForWritingByCurrentThread
(
)
)
;
return
static_cast
<
AtomTableEntry
*
>
(
mTable
.
Add
(
&
aKey
)
)
;
}
}
;
class
nsAtomTable
{
public
:
nsAtomSubTable
&
SelectSubTable
(
AtomTableKey
&
aKey
)
;
void
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
;
void
GC
(
GCKind
aKind
)
;
already_AddRefed
<
nsAtom
>
Atomize
(
const
nsAString
&
aUTF16String
uint32_t
aHash
)
;
already_AddRefed
<
nsAtom
>
Atomize
(
const
nsACString
&
aUTF8String
)
;
already_AddRefed
<
nsAtom
>
AtomizeMainThread
(
const
nsAString
&
aUTF16String
)
;
nsStaticAtom
*
GetStaticAtom
(
const
nsAString
&
aUTF16String
)
;
void
RegisterStaticAtoms
(
const
nsStaticAtom
*
aAtoms
size_t
aAtomsLen
)
;
size_t
RacySlowCount
(
)
;
static
void
AtomTableClearEntry
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
;
constexpr
static
size_t
kNumSubTables
=
512
;
constexpr
static
size_t
kInitialSubTableSize
=
4096
/
kNumSubTables
;
private
:
nsAtomSubTable
mSubTables
[
kNumSubTables
]
;
}
;
static
nsAtomTable
*
gAtomTable
;
static
PLDHashNumber
AtomTableGetHash
(
const
void
*
aKey
)
{
const
AtomTableKey
*
k
=
static_cast
<
const
AtomTableKey
*
>
(
aKey
)
;
return
k
-
>
mHash
;
}
static
bool
AtomTableMatchKey
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
const
AtomTableEntry
*
he
=
static_cast
<
const
AtomTableEntry
*
>
(
aEntry
)
;
const
AtomTableKey
*
k
=
static_cast
<
const
AtomTableKey
*
>
(
aKey
)
;
if
(
k
-
>
mUTF8String
)
{
bool
err
=
false
;
return
(
CompareUTF8toUTF16
(
nsDependentCSubstring
(
k
-
>
mUTF8String
k
-
>
mUTF8String
+
k
-
>
mLength
)
nsDependentAtomString
(
he
-
>
mAtom
)
&
err
)
=
=
0
)
&
&
!
err
;
}
return
he
-
>
mAtom
-
>
Equals
(
k
-
>
mUTF16String
k
-
>
mLength
)
;
}
void
nsAtomTable
:
:
AtomTableClearEntry
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
{
auto
*
entry
=
static_cast
<
AtomTableEntry
*
>
(
aEntry
)
;
entry
-
>
mAtom
=
nullptr
;
}
static
void
AtomTableInitEntry
(
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
static_cast
<
AtomTableEntry
*
>
(
aEntry
)
-
>
mAtom
=
nullptr
;
}
static
const
PLDHashTableOps
AtomTableOps
=
{
AtomTableGetHash
AtomTableMatchKey
PLDHashTable
:
:
MoveEntryStub
nsAtomTable
:
:
AtomTableClearEntry
AtomTableInitEntry
}
;
nsAtomSubTable
&
nsAtomTable
:
:
SelectSubTable
(
AtomTableKey
&
aKey
)
{
static_assert
(
(
kNumSubTables
&
(
kNumSubTables
-
1
)
)
=
=
0
"
must
be
power
of
two
"
)
;
return
mSubTables
[
aKey
.
mHash
&
(
kNumSubTables
-
1
)
]
;
}
void
nsAtomTable
:
:
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aSizes
.
mTable
+
=
aMallocSizeOf
(
this
)
;
for
(
auto
&
table
:
mSubTables
)
{
AutoReadLock
lock
(
table
.
mLock
)
;
table
.
AddSizeOfExcludingThisLocked
(
aMallocSizeOf
aSizes
)
;
}
}
void
nsAtomTable
:
:
GC
(
GCKind
aKind
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sRecentlyUsedSmallMainThreadAtoms
.
Clear
(
)
;
sRecentlyUsedLargeMainThreadAtoms
.
Clear
(
)
;
for
(
auto
&
table
:
mSubTables
)
{
AutoWriteLock
lock
(
table
.
mLock
)
;
table
.
GCLocked
(
aKind
)
;
}
MOZ_ASSERT_IF
(
aKind
=
=
GCKind
:
:
Shutdown
nsDynamicAtom
:
:
gUnusedAtomCount
=
=
0
)
;
}
size_t
nsAtomTable
:
:
RacySlowCount
(
)
{
GC
(
GCKind
:
:
RegularOperation
)
;
size_t
count
=
0
;
for
(
auto
&
table
:
mSubTables
)
{
AutoReadLock
lock
(
table
.
mLock
)
;
count
+
=
table
.
mTable
.
EntryCount
(
)
;
}
return
count
;
}
nsAtomSubTable
:
:
nsAtomSubTable
(
)
:
mLock
(
"
Atom
Sub
-
Table
Lock
"
)
mTable
(
&
AtomTableOps
sizeof
(
AtomTableEntry
)
nsAtomTable
:
:
kInitialSubTableSize
)
{
}
void
nsAtomSubTable
:
:
GCLocked
(
GCKind
aKind
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mLock
.
LockedForWritingByCurrentThread
(
)
)
;
int32_t
removedCount
=
0
;
nsAutoCString
nonZeroRefcountAtoms
;
uint32_t
nonZeroRefcountAtomsCount
=
0
;
for
(
auto
i
=
mTable
.
Iter
(
)
;
!
i
.
Done
(
)
;
i
.
Next
(
)
)
{
auto
*
entry
=
static_cast
<
AtomTableEntry
*
>
(
i
.
Get
(
)
)
;
if
(
entry
-
>
mAtom
-
>
IsStatic
(
)
)
{
continue
;
}
nsAtom
*
atom
=
entry
-
>
mAtom
;
if
(
atom
-
>
IsDynamic
(
)
&
&
atom
-
>
AsDynamic
(
)
-
>
mRefCnt
=
=
0
)
{
i
.
Remove
(
)
;
nsDynamicAtom
:
:
Destroy
(
atom
-
>
AsDynamic
(
)
)
;
+
+
removedCount
;
}
#
ifdef
NS_FREE_PERMANENT_DATA
else
if
(
aKind
=
=
GCKind
:
:
Shutdown
&
&
PR_GetEnv
(
"
XPCOM_MEM_BLOAT_LOG
"
)
)
{
nsAutoCString
name
;
atom
-
>
ToUTF8String
(
name
)
;
if
(
nonZeroRefcountAtomsCount
=
=
0
)
{
nonZeroRefcountAtoms
=
name
;
}
else
if
(
nonZeroRefcountAtomsCount
<
20
)
{
nonZeroRefcountAtoms
+
=
"
"
_ns
+
name
;
}
else
if
(
nonZeroRefcountAtomsCount
=
=
20
)
{
nonZeroRefcountAtoms
+
=
"
.
.
.
"
_ns
;
}
nonZeroRefcountAtomsCount
+
+
;
}
#
endif
}
if
(
nonZeroRefcountAtomsCount
)
{
nsPrintfCString
msg
(
"
%
d
dynamic
atom
(
s
)
with
non
-
zero
refcount
:
%
s
"
nonZeroRefcountAtomsCount
nonZeroRefcountAtoms
.
get
(
)
)
;
NS_ASSERTION
(
nonZeroRefcountAtomsCount
=
=
0
msg
.
get
(
)
)
;
}
nsDynamicAtom
:
:
gUnusedAtomCount
-
=
removedCount
;
}
void
nsDynamicAtom
:
:
ScheduleAtomTableGC
(
)
{
MOZ_ASSERT
(
gAtomTable
)
;
static
Atomic
<
bool
Relaxed
>
sScheduled
;
if
(
sScheduled
.
exchange
(
true
)
)
{
return
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
nsAtomTable
:
:
GC
"
[
]
(
)
{
sScheduled
=
false
;
if
(
MOZ_LIKELY
(
gAtomTable
)
)
{
gAtomTable
-
>
GC
(
GCKind
:
:
RegularOperation
)
;
}
}
)
)
;
}
static
bool
gStaticAtomsDone
=
false
;
void
NS_InitAtomTable
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
gAtomTable
)
;
gAtomTable
=
new
nsAtomTable
(
)
;
gAtomTable
-
>
RegisterStaticAtoms
(
nsGkAtoms
:
:
sAtoms
nsGkAtoms
:
:
sAtomsLen
)
;
gStaticAtomsDone
=
true
;
}
void
NS_ShutdownAtomTable
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
gAtomTable
)
;
#
ifdef
NS_FREE_PERMANENT_DATA
gAtomTable
-
>
GC
(
GCKind
:
:
Shutdown
)
;
#
endif
delete
gAtomTable
;
gAtomTable
=
nullptr
;
}
void
NS_AddSizeOfAtoms
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
AddSizeOfIncludingThis
(
aMallocSizeOf
aSizes
)
;
}
void
nsAtomSubTable
:
:
AddSizeOfExcludingThisLocked
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
{
aSizes
.
mTable
+
=
mTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
*
entry
=
static_cast
<
AtomTableEntry
*
>
(
iter
.
Get
(
)
)
;
entry
-
>
mAtom
-
>
AddSizeOfIncludingThis
(
aMallocSizeOf
aSizes
)
;
}
}
void
nsAtomTable
:
:
RegisterStaticAtoms
(
const
nsStaticAtom
*
aAtoms
size_t
aAtomsLen
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gStaticAtomsDone
"
Static
atom
insertion
is
finished
!
"
)
;
for
(
uint32_t
i
=
0
;
i
<
aAtomsLen
;
+
+
i
)
{
const
nsStaticAtom
*
atom
=
&
aAtoms
[
i
]
;
MOZ_ASSERT
(
IsAsciiNullTerminated
(
atom
-
>
String
(
)
)
)
;
MOZ_ASSERT
(
NS_strlen
(
atom
-
>
String
(
)
)
=
=
atom
-
>
GetLength
(
)
)
;
MOZ_ASSERT
(
atom
-
>
IsAsciiLowercase
(
)
=
=
:
:
IsAsciiLowercase
(
atom
-
>
String
(
)
atom
-
>
GetLength
(
)
)
)
;
MOZ_ASSERT
(
HashString
(
atom
-
>
String
(
)
)
=
=
atom
-
>
hash
(
)
)
;
AtomTableKey
key
(
atom
)
;
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
AutoWriteLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Add
(
key
)
;
if
(
he
-
>
mAtom
)
{
nsAutoCString
name
;
he
-
>
mAtom
-
>
ToUTF8String
(
name
)
;
MOZ_CRASH_UNSAFE_PRINTF
(
"
Atom
for
'
%
s
'
already
exists
"
name
.
get
(
)
)
;
}
he
-
>
mAtom
=
const_cast
<
nsStaticAtom
*
>
(
atom
)
;
}
}
already_AddRefed
<
nsAtom
>
NS_Atomize
(
const
char
*
aUTF8String
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
Atomize
(
nsDependentCString
(
aUTF8String
)
)
;
}
already_AddRefed
<
nsAtom
>
nsAtomTable
:
:
Atomize
(
const
nsACString
&
aUTF8String
)
{
bool
err
;
AtomTableKey
key
(
aUTF8String
.
Data
(
)
aUTF8String
.
Length
(
)
&
err
)
;
if
(
MOZ_UNLIKELY
(
err
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Tried
to
atomize
invalid
UTF
-
8
.
"
)
;
nsString
str
;
CopyUTF8toUTF16
(
aUTF8String
str
)
;
return
Atomize
(
str
HashString
(
str
)
)
;
}
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
{
AutoReadLock
lock
(
table
.
mLock
)
;
if
(
AtomTableEntry
*
he
=
table
.
Search
(
key
)
)
{
return
do_AddRef
(
he
-
>
mAtom
)
;
}
}
AutoWriteLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Add
(
key
)
;
if
(
he
-
>
mAtom
)
{
return
do_AddRef
(
he
-
>
mAtom
)
;
}
nsString
str
;
CopyUTF8toUTF16
(
aUTF8String
str
)
;
MOZ_ASSERT
(
str
.
GetStringBuffer
(
)
"
Should
create
a
string
buffer
"
)
;
RefPtr
<
nsAtom
>
atom
=
dont_AddRef
(
nsDynamicAtom
:
:
Create
(
str
key
.
mHash
)
)
;
he
-
>
mAtom
=
atom
;
return
atom
.
forget
(
)
;
}
already_AddRefed
<
nsAtom
>
NS_Atomize
(
const
nsACString
&
aUTF8String
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
Atomize
(
aUTF8String
)
;
}
already_AddRefed
<
nsAtom
>
NS_Atomize
(
const
char16_t
*
aUTF16String
)
{
return
NS_Atomize
(
nsDependentString
(
aUTF16String
)
)
;
}
already_AddRefed
<
nsAtom
>
nsAtomTable
:
:
Atomize
(
const
nsAString
&
aUTF16String
uint32_t
aHash
)
{
AtomTableKey
key
(
aUTF16String
.
Data
(
)
aUTF16String
.
Length
(
)
aHash
)
;
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
{
AutoReadLock
lock
(
table
.
mLock
)
;
if
(
AtomTableEntry
*
he
=
table
.
Search
(
key
)
)
{
return
do_AddRef
(
he
-
>
mAtom
)
;
}
}
AutoWriteLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Add
(
key
)
;
if
(
he
-
>
mAtom
)
{
RefPtr
<
nsAtom
>
atom
=
he
-
>
mAtom
;
return
atom
.
forget
(
)
;
}
RefPtr
<
nsAtom
>
atom
=
dont_AddRef
(
nsDynamicAtom
:
:
Create
(
aUTF16String
key
.
mHash
)
)
;
he
-
>
mAtom
=
atom
;
return
atom
.
forget
(
)
;
}
already_AddRefed
<
nsAtom
>
NS_Atomize
(
const
nsAString
&
aUTF16String
uint32_t
aKnownHash
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
Atomize
(
aUTF16String
aKnownHash
)
;
}
already_AddRefed
<
nsAtom
>
NS_Atomize
(
const
nsAString
&
aUTF16String
)
{
return
NS_Atomize
(
aUTF16String
HashString
(
aUTF16String
)
)
;
}
already_AddRefed
<
nsAtom
>
nsAtomTable
:
:
AtomizeMainThread
(
const
nsAString
&
aUTF16String
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
nsAtom
>
retVal
;
size_t
length
=
aUTF16String
.
Length
(
)
;
AtomTableKey
key
(
aUTF16String
.
Data
(
)
length
)
;
auto
p
=
(
length
<
5
)
?
sRecentlyUsedSmallMainThreadAtoms
.
Lookup
(
key
)
:
sRecentlyUsedLargeMainThreadAtoms
.
Lookup
(
key
)
;
if
(
p
)
{
retVal
=
p
.
Data
(
)
;
return
retVal
.
forget
(
)
;
}
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
{
AutoReadLock
lock
(
table
.
mLock
)
;
if
(
AtomTableEntry
*
he
=
table
.
Search
(
key
)
)
{
p
.
Set
(
he
-
>
mAtom
)
;
return
do_AddRef
(
he
-
>
mAtom
)
;
}
}
AutoWriteLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Add
(
key
)
;
if
(
he
-
>
mAtom
)
{
retVal
=
he
-
>
mAtom
;
}
else
{
RefPtr
<
nsAtom
>
newAtom
=
dont_AddRef
(
nsDynamicAtom
:
:
Create
(
aUTF16String
key
.
mHash
)
)
;
he
-
>
mAtom
=
newAtom
;
retVal
=
std
:
:
move
(
newAtom
)
;
}
p
.
Set
(
retVal
)
;
return
retVal
.
forget
(
)
;
}
already_AddRefed
<
nsAtom
>
NS_AtomizeMainThread
(
const
nsAString
&
aUTF16String
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
AtomizeMainThread
(
aUTF16String
)
;
}
nsrefcnt
NS_GetNumberOfAtoms
(
void
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
RacySlowCount
(
)
;
}
int32_t
NS_GetUnusedAtomCount
(
void
)
{
return
nsDynamicAtom
:
:
gUnusedAtomCount
;
}
nsStaticAtom
*
NS_GetStaticAtom
(
const
nsAString
&
aUTF16String
)
{
MOZ_ASSERT
(
gStaticAtomsDone
"
Static
atom
setup
not
yet
done
.
"
)
;
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
GetStaticAtom
(
aUTF16String
)
;
}
nsStaticAtom
*
nsAtomTable
:
:
GetStaticAtom
(
const
nsAString
&
aUTF16String
)
{
AtomTableKey
key
(
aUTF16String
.
Data
(
)
aUTF16String
.
Length
(
)
)
;
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
AutoReadLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Search
(
key
)
;
return
he
&
&
he
-
>
mAtom
-
>
IsStatic
(
)
?
static_cast
<
nsStaticAtom
*
>
(
he
-
>
mAtom
)
:
nullptr
;
}
void
ToLowerCaseASCII
(
RefPtr
<
nsAtom
>
&
aAtom
)
{
if
(
aAtom
-
>
IsAsciiLowercase
(
)
)
{
return
;
}
nsAutoString
lowercased
;
ToLowerCaseASCII
(
nsDependentAtomString
(
aAtom
)
lowercased
)
;
aAtom
=
NS_Atomize
(
lowercased
)
;
}
