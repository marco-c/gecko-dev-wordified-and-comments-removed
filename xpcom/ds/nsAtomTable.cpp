#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsAtomTable
.
h
"
#
include
"
nsStaticAtom
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
using
namespace
mozilla
;
class
CheckStaticAtomSizes
{
CheckStaticAtomSizes
(
)
{
static_assert
(
(
sizeof
(
nsFakeStringBuffer
<
1
>
(
)
.
mRefCnt
)
=
=
sizeof
(
nsStringBuffer
(
)
.
mRefCount
)
)
&
&
(
sizeof
(
nsFakeStringBuffer
<
1
>
(
)
.
mSize
)
=
=
sizeof
(
nsStringBuffer
(
)
.
mStorageSize
)
)
&
&
(
offsetof
(
nsFakeStringBuffer
<
1
>
mRefCnt
)
=
=
offsetof
(
nsStringBuffer
mRefCount
)
)
&
&
(
offsetof
(
nsFakeStringBuffer
<
1
>
mSize
)
=
=
offsetof
(
nsStringBuffer
mStorageSize
)
)
&
&
(
offsetof
(
nsFakeStringBuffer
<
1
>
mStringData
)
=
=
sizeof
(
nsStringBuffer
)
)
"
mocked
-
up
strings
'
representations
should
be
compatible
"
)
;
}
}
;
static
Atomic
<
uint32_t
ReleaseAcquire
>
gUnusedAtomCount
(
0
)
;
class
DynamicAtom
final
:
public
nsIAtom
{
public
:
static
already_AddRefed
<
DynamicAtom
>
Create
(
const
nsAString
&
aString
uint32_t
aHash
)
{
return
dont_AddRef
(
new
DynamicAtom
(
aString
aHash
)
)
;
}
static
void
GCAtomTable
(
)
;
enum
class
GCKind
{
RegularOperation
Shutdown
}
;
static
void
GCAtomTableLocked
(
const
MutexAutoLock
&
aProofOfLock
GCKind
aKind
)
;
private
:
DynamicAtom
(
const
nsAString
&
aString
uint32_t
aHash
)
:
mRefCnt
(
1
)
{
mLength
=
aString
.
Length
(
)
;
SetKind
(
AtomKind
:
:
DynamicAtom
)
;
RefPtr
<
nsStringBuffer
>
buf
=
nsStringBuffer
:
:
FromString
(
aString
)
;
if
(
buf
)
{
mString
=
static_cast
<
char16_t
*
>
(
buf
-
>
Data
(
)
)
;
}
else
{
const
size_t
size
=
(
mLength
+
1
)
*
sizeof
(
char16_t
)
;
buf
=
nsStringBuffer
:
:
Alloc
(
size
)
;
if
(
MOZ_UNLIKELY
(
!
buf
)
)
{
NS_ABORT_OOM
(
size
)
;
}
mString
=
static_cast
<
char16_t
*
>
(
buf
-
>
Data
(
)
)
;
CopyUnicodeTo
(
aString
0
mString
mLength
)
;
mString
[
mLength
]
=
char16_t
(
0
)
;
}
mHash
=
aHash
;
MOZ_ASSERT
(
mHash
=
=
HashString
(
mString
mLength
)
)
;
NS_ASSERTION
(
mString
[
mLength
]
=
=
char16_t
(
0
)
"
null
terminated
"
)
;
NS_ASSERTION
(
buf
&
&
buf
-
>
StorageSize
(
)
>
=
(
mLength
+
1
)
*
sizeof
(
char16_t
)
"
enough
storage
"
)
;
NS_ASSERTION
(
Equals
(
aString
)
"
correct
data
"
)
;
mozilla
:
:
Unused
<
<
buf
.
forget
(
)
;
}
private
:
~
DynamicAtom
(
)
;
public
:
NS_DECL_NSIATOM
NS_IMETHOD
QueryInterface
(
REFNSIID
aIID
void
*
*
aInstancePtr
)
final
;
typedef
mozilla
:
:
TrueType
HasThreadSafeRefCnt
;
MozExternalRefCountType
DoAddRef
(
)
;
MozExternalRefCountType
DoRelease
(
)
;
protected
:
ThreadSafeAutoRefCnt
mRefCnt
;
NS_DECL_OWNINGTHREAD
}
;
#
if
defined
(
NS_BUILD_REFCNT_LOGGING
)
class
FakeBufferRefcountHelper
{
public
:
explicit
FakeBufferRefcountHelper
(
nsStringBuffer
*
aBuffer
)
:
mBuffer
(
aBuffer
)
{
NS_LOG_ADDREF
(
aBuffer
1
"
nsStringBuffer
"
sizeof
(
nsStringBuffer
)
)
;
}
~
FakeBufferRefcountHelper
(
)
{
NS_LOG_RELEASE
(
mBuffer
0
"
nsStringBuffer
"
)
;
}
private
:
nsStringBuffer
*
mBuffer
;
}
;
UniquePtr
<
nsTArray
<
FakeBufferRefcountHelper
>
>
gFakeBuffers
;
#
endif
class
StaticAtom
final
:
public
nsIAtom
{
public
:
StaticAtom
(
nsStringBuffer
*
aStringBuffer
uint32_t
aLength
uint32_t
aHash
)
{
mLength
=
aLength
;
SetKind
(
AtomKind
:
:
StaticAtom
)
;
mString
=
static_cast
<
char16_t
*
>
(
aStringBuffer
-
>
Data
(
)
)
;
#
if
defined
(
NS_BUILD_REFCNT_LOGGING
)
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
gFakeBuffers
)
{
gFakeBuffers
=
MakeUnique
<
nsTArray
<
FakeBufferRefcountHelper
>
>
(
)
;
}
gFakeBuffers
-
>
AppendElement
(
aStringBuffer
)
;
#
endif
aStringBuffer
-
>
AddRef
(
)
;
mHash
=
aHash
;
MOZ_ASSERT
(
mHash
=
=
HashString
(
mString
mLength
)
)
;
MOZ_ASSERT
(
mString
[
mLength
]
=
=
char16_t
(
0
)
"
null
terminated
"
)
;
MOZ_ASSERT
(
aStringBuffer
&
&
aStringBuffer
-
>
StorageSize
(
)
=
=
(
mLength
+
1
)
*
sizeof
(
char16_t
)
"
correct
storage
"
)
;
}
~
StaticAtom
(
)
{
}
NS_IMETHOD
QueryInterface
(
REFNSIID
aIID
void
*
*
aInstancePtr
)
final
;
NS_DECL_NSIATOM
}
;
NS_IMPL_QUERY_INTERFACE
(
StaticAtom
nsIAtom
)
;
NS_IMETHODIMP
DynamicAtom
:
:
ScriptableToString
(
nsAString
&
aBuf
)
{
nsStringBuffer
:
:
FromData
(
mString
)
-
>
ToString
(
mLength
aBuf
)
;
return
NS_OK
;
}
NS_IMETHODIMP
StaticAtom
:
:
ScriptableToString
(
nsAString
&
aBuf
)
{
nsStringBuffer
:
:
FromData
(
mString
)
-
>
ToString
(
mLength
aBuf
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DynamicAtom
:
:
ToUTF8String
(
nsACString
&
aBuf
)
{
CopyUTF16toUTF8
(
nsDependentString
(
mString
mLength
)
aBuf
)
;
return
NS_OK
;
}
NS_IMETHODIMP
StaticAtom
:
:
ToUTF8String
(
nsACString
&
aBuf
)
{
CopyUTF16toUTF8
(
nsDependentString
(
mString
mLength
)
aBuf
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DynamicAtom
:
:
ScriptableEquals
(
const
nsAString
&
aString
bool
*
aResult
)
{
*
aResult
=
aString
.
Equals
(
nsDependentString
(
mString
mLength
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
StaticAtom
:
:
ScriptableEquals
(
const
nsAString
&
aString
bool
*
aResult
)
{
*
aResult
=
aString
.
Equals
(
nsDependentString
(
mString
mLength
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
size_t
)
DynamicAtom
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
nsStringBuffer
:
:
FromData
(
mString
)
-
>
SizeOfIncludingThisIfUnshared
(
aMallocSizeOf
)
;
return
n
;
}
NS_IMETHODIMP_
(
size_t
)
StaticAtom
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
this
)
;
return
n
;
}
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsIAtom
:
:
AddRef
(
)
{
MOZ_ASSERT
(
!
IsHTML5Atom
(
)
"
Attempt
to
AddRef
an
nsHtml5Atom
"
)
;
if
(
!
IsDynamicAtom
(
)
)
{
MOZ_ASSERT
(
IsStaticAtom
(
)
)
;
return
2
;
}
return
static_cast
<
DynamicAtom
*
>
(
this
)
-
>
DoAddRef
(
)
;
}
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsIAtom
:
:
Release
(
)
{
MOZ_ASSERT
(
!
IsHTML5Atom
(
)
"
Attempt
to
Release
an
nsHtml5Atom
"
)
;
if
(
!
IsDynamicAtom
(
)
)
{
MOZ_ASSERT
(
IsStaticAtom
(
)
)
;
return
1
;
}
return
static_cast
<
DynamicAtom
*
>
(
this
)
-
>
DoRelease
(
)
;
}
static
PLDHashTable
*
gAtomTable
;
static
Mutex
*
gAtomTableLock
;
struct
AtomTableKey
{
AtomTableKey
(
const
char16_t
*
aUTF16String
uint32_t
aLength
uint32_t
aHash
)
:
mUTF16String
(
aUTF16String
)
mUTF8String
(
nullptr
)
mLength
(
aLength
)
mHash
(
aHash
)
{
MOZ_ASSERT
(
mHash
=
=
HashString
(
mUTF16String
mLength
)
)
;
}
AtomTableKey
(
const
char
*
aUTF8String
uint32_t
aLength
uint32_t
aHash
)
:
mUTF16String
(
nullptr
)
mUTF8String
(
aUTF8String
)
mLength
(
aLength
)
mHash
(
aHash
)
{
mozilla
:
:
DebugOnly
<
bool
>
err
;
MOZ_ASSERT
(
aHash
=
=
HashUTF8AsUTF16
(
mUTF8String
mLength
&
err
)
)
;
}
AtomTableKey
(
const
char16_t
*
aUTF16String
uint32_t
aLength
uint32_t
*
aHashOut
)
:
mUTF16String
(
aUTF16String
)
mUTF8String
(
nullptr
)
mLength
(
aLength
)
{
mHash
=
HashString
(
mUTF16String
mLength
)
;
*
aHashOut
=
mHash
;
}
AtomTableKey
(
const
char
*
aUTF8String
uint32_t
aLength
uint32_t
*
aHashOut
)
:
mUTF16String
(
nullptr
)
mUTF8String
(
aUTF8String
)
mLength
(
aLength
)
{
bool
err
;
mHash
=
HashUTF8AsUTF16
(
mUTF8String
mLength
&
err
)
;
if
(
err
)
{
mUTF8String
=
nullptr
;
mLength
=
0
;
mHash
=
0
;
}
*
aHashOut
=
mHash
;
}
const
char16_t
*
mUTF16String
;
const
char
*
mUTF8String
;
uint32_t
mLength
;
uint32_t
mHash
;
}
;
struct
AtomTableEntry
:
public
PLDHashEntryHdr
{
nsIAtom
*
MOZ_NON_OWNING_REF
mAtom
;
}
;
static
PLDHashNumber
AtomTableGetHash
(
const
void
*
aKey
)
{
const
AtomTableKey
*
k
=
static_cast
<
const
AtomTableKey
*
>
(
aKey
)
;
return
k
-
>
mHash
;
}
static
bool
AtomTableMatchKey
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
const
AtomTableEntry
*
he
=
static_cast
<
const
AtomTableEntry
*
>
(
aEntry
)
;
const
AtomTableKey
*
k
=
static_cast
<
const
AtomTableKey
*
>
(
aKey
)
;
if
(
k
-
>
mUTF8String
)
{
return
CompareUTF8toUTF16
(
nsDependentCSubstring
(
k
-
>
mUTF8String
k
-
>
mUTF8String
+
k
-
>
mLength
)
nsDependentAtomString
(
he
-
>
mAtom
)
)
=
=
0
;
}
return
he
-
>
mAtom
-
>
Equals
(
k
-
>
mUTF16String
k
-
>
mLength
)
;
}
static
void
AtomTableClearEntry
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
{
auto
entry
=
static_cast
<
AtomTableEntry
*
>
(
aEntry
)
;
nsIAtom
*
atom
=
entry
-
>
mAtom
;
if
(
atom
-
>
IsStaticAtom
(
)
)
{
delete
static_cast
<
StaticAtom
*
>
(
atom
)
;
}
}
static
void
AtomTableInitEntry
(
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
static_cast
<
AtomTableEntry
*
>
(
aEntry
)
-
>
mAtom
=
nullptr
;
}
static
const
PLDHashTableOps
AtomTableOps
=
{
AtomTableGetHash
AtomTableMatchKey
PLDHashTable
:
:
MoveEntryStub
AtomTableClearEntry
AtomTableInitEntry
}
;
#
define
RECENTLY_USED_MAIN_THREAD_ATOM_CACHE_SIZE
31
static
nsIAtom
*
sRecentlyUsedMainThreadAtoms
[
RECENTLY_USED_MAIN_THREAD_ATOM_CACHE_SIZE
]
=
{
}
;
void
DynamicAtom
:
:
GCAtomTable
(
)
{
if
(
NS_IsMainThread
(
)
)
{
MutexAutoLock
lock
(
*
gAtomTableLock
)
;
GCAtomTableLocked
(
lock
GCKind
:
:
RegularOperation
)
;
}
}
void
DynamicAtom
:
:
GCAtomTableLocked
(
const
MutexAutoLock
&
aProofOfLock
GCKind
aKind
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
RECENTLY_USED_MAIN_THREAD_ATOM_CACHE_SIZE
;
+
+
i
)
{
sRecentlyUsedMainThreadAtoms
[
i
]
=
nullptr
;
}
uint32_t
removedCount
=
0
;
nsAutoCString
nonZeroRefcountAtoms
;
uint32_t
nonZeroRefcountAtomsCount
=
0
;
for
(
auto
i
=
gAtomTable
-
>
Iter
(
)
;
!
i
.
Done
(
)
;
i
.
Next
(
)
)
{
auto
entry
=
static_cast
<
AtomTableEntry
*
>
(
i
.
Get
(
)
)
;
if
(
entry
-
>
mAtom
-
>
IsStaticAtom
(
)
)
{
continue
;
}
auto
atom
=
static_cast
<
DynamicAtom
*
>
(
entry
-
>
mAtom
)
;
if
(
atom
-
>
mRefCnt
=
=
0
)
{
i
.
Remove
(
)
;
delete
atom
;
+
+
removedCount
;
}
#
ifdef
NS_FREE_PERMANENT_DATA
else
if
(
aKind
=
=
GCKind
:
:
Shutdown
&
&
PR_GetEnv
(
"
XPCOM_MEM_BLOAT_LOG
"
)
)
{
nsAutoCString
name
;
atom
-
>
ToUTF8String
(
name
)
;
if
(
nonZeroRefcountAtomsCount
=
=
0
)
{
nonZeroRefcountAtoms
=
name
;
}
else
if
(
nonZeroRefcountAtomsCount
<
20
)
{
nonZeroRefcountAtoms
+
=
NS_LITERAL_CSTRING
(
"
"
)
+
name
;
}
else
if
(
nonZeroRefcountAtomsCount
=
=
20
)
{
nonZeroRefcountAtoms
+
=
NS_LITERAL_CSTRING
(
"
.
.
.
"
)
;
}
nonZeroRefcountAtomsCount
+
+
;
}
#
endif
}
if
(
nonZeroRefcountAtomsCount
)
{
nsPrintfCString
msg
(
"
%
d
dynamic
atom
(
s
)
with
non
-
zero
refcount
:
%
s
"
nonZeroRefcountAtomsCount
nonZeroRefcountAtoms
.
get
(
)
)
;
NS_ASSERTION
(
nonZeroRefcountAtomsCount
=
=
0
msg
.
get
(
)
)
;
}
MOZ_ASSERT_IF
(
aKind
=
=
GCKind
:
:
Shutdown
removedCount
=
=
gUnusedAtomCount
)
;
gUnusedAtomCount
-
=
removedCount
;
}
NS_IMPL_QUERY_INTERFACE
(
DynamicAtom
nsIAtom
)
MozExternalRefCountType
DynamicAtom
:
:
DoAddRef
(
)
{
nsrefcnt
count
=
+
+
mRefCnt
;
if
(
count
=
=
1
)
{
gUnusedAtomCount
-
-
;
}
return
count
;
}
#
ifdef
DEBUG
static
const
uint32_t
kAtomGCThreshold
=
20
;
#
else
static
const
uint32_t
kAtomGCThreshold
=
10000
;
#
endif
MozExternalRefCountType
DynamicAtom
:
:
DoRelease
(
)
{
MOZ_ASSERT
(
mRefCnt
>
0
)
;
nsrefcnt
count
=
-
-
mRefCnt
;
if
(
count
=
=
0
)
{
if
(
+
+
gUnusedAtomCount
>
=
kAtomGCThreshold
)
{
GCAtomTable
(
)
;
}
}
return
count
;
}
DynamicAtom
:
:
~
DynamicAtom
(
)
{
nsStringBuffer
:
:
FromData
(
mString
)
-
>
Release
(
)
;
}
class
StaticAtomEntry
:
public
PLDHashEntryHdr
{
public
:
typedef
const
nsAString
&
KeyType
;
typedef
const
nsAString
*
KeyTypePointer
;
explicit
StaticAtomEntry
(
KeyTypePointer
aKey
)
{
}
StaticAtomEntry
(
const
StaticAtomEntry
&
aOther
)
:
mAtom
(
aOther
.
mAtom
)
{
}
~
StaticAtomEntry
(
)
{
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
mAtom
-
>
Equals
(
*
aKey
)
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
HashString
(
*
aKey
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
StaticAtom
*
MOZ_OWNING_REF
mAtom
;
}
;
typedef
nsTHashtable
<
StaticAtomEntry
>
StaticAtomTable
;
static
StaticAtomTable
*
gStaticAtomTable
=
nullptr
;
static
bool
gStaticAtomTableSealed
=
false
;
#
define
ATOM_HASHTABLE_INITIAL_LENGTH
4096
void
NS_InitAtomTable
(
)
{
MOZ_ASSERT
(
!
gAtomTable
)
;
gAtomTable
=
new
PLDHashTable
(
&
AtomTableOps
sizeof
(
AtomTableEntry
)
ATOM_HASHTABLE_INITIAL_LENGTH
)
;
gAtomTableLock
=
new
Mutex
(
"
Atom
Table
Lock
"
)
;
NS_STATIC_ATOM_BUFFER
(
empty
"
"
)
;
static
nsIAtom
*
empty_atom
=
nullptr
;
static
const
nsStaticAtom
default_atoms
[
]
=
{
NS_STATIC_ATOM
(
empty
&
empty_atom
)
}
;
NS_RegisterStaticAtoms
(
default_atoms
)
;
}
void
NS_ShutdownAtomTable
(
)
{
#
if
defined
(
NS_BUILD_REFCNT_LOGGING
)
gFakeBuffers
=
nullptr
;
#
endif
delete
gStaticAtomTable
;
gStaticAtomTable
=
nullptr
;
#
ifdef
NS_FREE_PERMANENT_DATA
{
MutexAutoLock
lock
(
*
gAtomTableLock
)
;
DynamicAtom
:
:
GCAtomTableLocked
(
lock
DynamicAtom
:
:
GCKind
:
:
Shutdown
)
;
}
#
endif
delete
gAtomTable
;
gAtomTable
=
nullptr
;
delete
gAtomTableLock
;
gAtomTableLock
=
nullptr
;
}
void
NS_SizeOfAtomTablesIncludingThis
(
MallocSizeOf
aMallocSizeOf
size_t
*
aMain
size_t
*
aStatic
)
{
MutexAutoLock
lock
(
*
gAtomTableLock
)
;
*
aMain
=
gAtomTable
-
>
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
gAtomTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
AtomTableEntry
*
>
(
iter
.
Get
(
)
)
;
*
aMain
+
=
entry
-
>
mAtom
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
*
aStatic
=
gStaticAtomTable
?
gStaticAtomTable
-
>
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
:
0
;
}
static
inline
AtomTableEntry
*
GetAtomHashEntry
(
const
char
*
aString
uint32_t
aLength
uint32_t
*
aHashOut
)
{
gAtomTableLock
-
>
AssertCurrentThreadOwns
(
)
;
AtomTableKey
key
(
aString
aLength
aHashOut
)
;
return
static_cast
<
AtomTableEntry
*
>
(
gAtomTable
-
>
Add
(
&
key
)
)
;
}
static
inline
AtomTableEntry
*
GetAtomHashEntry
(
const
char16_t
*
aString
uint32_t
aLength
uint32_t
*
aHashOut
)
{
gAtomTableLock
-
>
AssertCurrentThreadOwns
(
)
;
AtomTableKey
key
(
aString
aLength
aHashOut
)
;
return
static_cast
<
AtomTableEntry
*
>
(
gAtomTable
-
>
Add
(
&
key
)
)
;
}
void
RegisterStaticAtoms
(
const
nsStaticAtom
*
aAtoms
uint32_t
aAtomCount
)
{
MutexAutoLock
lock
(
*
gAtomTableLock
)
;
MOZ_RELEASE_ASSERT
(
!
gStaticAtomTableSealed
"
Atom
table
has
already
been
sealed
!
"
)
;
if
(
!
gStaticAtomTable
)
{
gStaticAtomTable
=
new
StaticAtomTable
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
aAtomCount
;
+
+
i
)
{
nsStringBuffer
*
stringBuffer
=
aAtoms
[
i
]
.
mStringBuffer
;
nsIAtom
*
*
atomp
=
aAtoms
[
i
]
.
mAtom
;
MOZ_ASSERT
(
nsCRT
:
:
IsAscii
(
static_cast
<
char16_t
*
>
(
stringBuffer
-
>
Data
(
)
)
)
)
;
uint32_t
stringLen
=
stringBuffer
-
>
StorageSize
(
)
/
sizeof
(
char16_t
)
-
1
;
uint32_t
hash
;
AtomTableEntry
*
he
=
GetAtomHashEntry
(
static_cast
<
char16_t
*
>
(
stringBuffer
-
>
Data
(
)
)
stringLen
&
hash
)
;
nsIAtom
*
atom
=
he
-
>
mAtom
;
if
(
atom
)
{
if
(
!
atom
-
>
IsStaticAtom
(
)
)
{
nsAutoCString
name
;
atom
-
>
ToUTF8String
(
name
)
;
MOZ_CRASH_UNSAFE_PRINTF
(
"
Static
atom
registration
for
%
s
should
be
pushed
back
"
name
.
get
(
)
)
;
}
}
else
{
atom
=
new
StaticAtom
(
stringBuffer
stringLen
hash
)
;
he
-
>
mAtom
=
atom
;
}
*
atomp
=
atom
;
if
(
!
gStaticAtomTableSealed
)
{
StaticAtomEntry
*
entry
=
gStaticAtomTable
-
>
PutEntry
(
nsDependentAtomString
(
atom
)
)
;
MOZ_ASSERT
(
atom
-
>
IsStaticAtom
(
)
)
;
entry
-
>
mAtom
=
static_cast
<
StaticAtom
*
>
(
atom
)
;
}
}
}
already_AddRefed
<
nsIAtom
>
NS_Atomize
(
const
char
*
aUTF8String
)
{
return
NS_Atomize
(
nsDependentCString
(
aUTF8String
)
)
;
}
already_AddRefed
<
nsIAtom
>
NS_Atomize
(
const
nsACString
&
aUTF8String
)
{
MutexAutoLock
lock
(
*
gAtomTableLock
)
;
uint32_t
hash
;
AtomTableEntry
*
he
=
GetAtomHashEntry
(
aUTF8String
.
Data
(
)
aUTF8String
.
Length
(
)
&
hash
)
;
if
(
he
-
>
mAtom
)
{
nsCOMPtr
<
nsIAtom
>
atom
=
he
-
>
mAtom
;
return
atom
.
forget
(
)
;
}
nsString
str
;
CopyUTF8toUTF16
(
aUTF8String
str
)
;
RefPtr
<
DynamicAtom
>
atom
=
DynamicAtom
:
:
Create
(
str
hash
)
;
he
-
>
mAtom
=
atom
;
return
atom
.
forget
(
)
;
}
already_AddRefed
<
nsIAtom
>
NS_Atomize
(
const
char16_t
*
aUTF16String
)
{
return
NS_Atomize
(
nsDependentString
(
aUTF16String
)
)
;
}
already_AddRefed
<
nsIAtom
>
NS_Atomize
(
const
nsAString
&
aUTF16String
)
{
MutexAutoLock
lock
(
*
gAtomTableLock
)
;
uint32_t
hash
;
AtomTableEntry
*
he
=
GetAtomHashEntry
(
aUTF16String
.
Data
(
)
aUTF16String
.
Length
(
)
&
hash
)
;
if
(
he
-
>
mAtom
)
{
nsCOMPtr
<
nsIAtom
>
atom
=
he
-
>
mAtom
;
return
atom
.
forget
(
)
;
}
RefPtr
<
DynamicAtom
>
atom
=
DynamicAtom
:
:
Create
(
aUTF16String
hash
)
;
he
-
>
mAtom
=
atom
;
return
atom
.
forget
(
)
;
}
already_AddRefed
<
nsIAtom
>
NS_AtomizeMainThread
(
const
nsAString
&
aUTF16String
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIAtom
>
retVal
;
uint32_t
hash
;
AtomTableKey
key
(
aUTF16String
.
Data
(
)
aUTF16String
.
Length
(
)
&
hash
)
;
uint32_t
index
=
hash
%
RECENTLY_USED_MAIN_THREAD_ATOM_CACHE_SIZE
;
nsIAtom
*
atom
=
sRecentlyUsedMainThreadAtoms
[
index
]
;
if
(
atom
)
{
uint32_t
length
=
atom
-
>
GetLength
(
)
;
if
(
length
=
=
key
.
mLength
&
&
(
memcmp
(
atom
-
>
GetUTF16String
(
)
key
.
mUTF16String
length
*
sizeof
(
char16_t
)
)
=
=
0
)
)
{
retVal
=
atom
;
return
retVal
.
forget
(
)
;
}
}
MutexAutoLock
lock
(
*
gAtomTableLock
)
;
AtomTableEntry
*
he
=
static_cast
<
AtomTableEntry
*
>
(
gAtomTable
-
>
Add
(
&
key
)
)
;
if
(
he
-
>
mAtom
)
{
retVal
=
he
-
>
mAtom
;
}
else
{
retVal
=
DynamicAtom
:
:
Create
(
aUTF16String
hash
)
;
he
-
>
mAtom
=
retVal
;
}
sRecentlyUsedMainThreadAtoms
[
index
]
=
retVal
;
return
retVal
.
forget
(
)
;
}
nsrefcnt
NS_GetNumberOfAtoms
(
void
)
{
DynamicAtom
:
:
GCAtomTable
(
)
;
MutexAutoLock
lock
(
*
gAtomTableLock
)
;
return
gAtomTable
-
>
EntryCount
(
)
;
}
nsIAtom
*
NS_GetStaticAtom
(
const
nsAString
&
aUTF16String
)
{
NS_PRECONDITION
(
gStaticAtomTable
"
Static
atom
table
not
created
yet
.
"
)
;
NS_PRECONDITION
(
gStaticAtomTableSealed
"
Static
atom
table
not
sealed
yet
.
"
)
;
StaticAtomEntry
*
entry
=
gStaticAtomTable
-
>
GetEntry
(
aUTF16String
)
;
return
entry
?
entry
-
>
mAtom
:
nullptr
;
}
void
NS_SealStaticAtomTable
(
)
{
gStaticAtomTableSealed
=
true
;
}
