#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsAtomTable
.
h
"
#
include
"
nsStaticAtom
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
using
namespace
mozilla
;
enum
class
GCKind
{
RegularOperation
Shutdown
}
;
static
Atomic
<
int32_t
ReleaseAcquire
>
gUnusedAtomCount
(
0
)
;
class
nsDynamicAtom
:
public
nsAtom
{
public
:
MozExternalRefCountType
AddRef
(
)
;
MozExternalRefCountType
Release
(
)
;
static
nsDynamicAtom
*
As
(
nsAtom
*
aAtom
)
{
MOZ_ASSERT
(
aAtom
-
>
IsDynamic
(
)
)
;
return
static_cast
<
nsDynamicAtom
*
>
(
aAtom
)
;
}
private
:
friend
class
nsAtomTable
;
friend
class
nsAtomSubTable
;
nsDynamicAtom
(
const
nsAString
&
aString
uint32_t
aHash
)
:
nsAtom
(
AtomKind
:
:
DynamicAtom
aString
aHash
)
mRefCnt
(
1
)
{
}
mozilla
:
:
ThreadSafeAutoRefCnt
mRefCnt
;
}
;
static
char16_t
*
FromStringBuffer
(
const
nsAString
&
aString
)
{
char16_t
*
str
;
size_t
length
=
aString
.
Length
(
)
;
RefPtr
<
nsStringBuffer
>
buf
=
nsStringBuffer
:
:
FromString
(
aString
)
;
if
(
buf
)
{
str
=
static_cast
<
char16_t
*
>
(
buf
-
>
Data
(
)
)
;
}
else
{
const
size_t
size
=
(
length
+
1
)
*
sizeof
(
char16_t
)
;
buf
=
nsStringBuffer
:
:
Alloc
(
size
)
;
if
(
MOZ_UNLIKELY
(
!
buf
)
)
{
NS_ABORT_OOM
(
size
)
;
}
str
=
static_cast
<
char16_t
*
>
(
buf
-
>
Data
(
)
)
;
CopyUnicodeTo
(
aString
0
str
length
)
;
str
[
length
]
=
char16_t
(
0
)
;
}
MOZ_ASSERT
(
buf
&
&
buf
-
>
StorageSize
(
)
>
=
(
length
+
1
)
*
sizeof
(
char16_t
)
"
enough
storage
"
)
;
mozilla
:
:
Unused
<
<
buf
.
forget
(
)
;
return
str
;
}
nsAtom
:
:
nsAtom
(
AtomKind
aKind
const
nsAString
&
aString
uint32_t
aHash
)
:
mLength
(
aString
.
Length
(
)
)
mKind
(
static_cast
<
uint32_t
>
(
aKind
)
)
mHash
(
aHash
)
mString
(
FromStringBuffer
(
aString
)
)
{
MOZ_ASSERT
(
aKind
=
=
AtomKind
:
:
DynamicAtom
|
|
aKind
=
=
AtomKind
:
:
HTML5Atom
)
;
MOZ_ASSERT_IF
(
!
IsHTML5
(
)
mHash
=
=
HashString
(
mString
mLength
)
)
;
MOZ_ASSERT
(
mString
[
mLength
]
=
=
char16_t
(
0
)
"
null
terminated
"
)
;
MOZ_ASSERT
(
Equals
(
aString
)
"
correct
data
"
)
;
}
nsAtom
:
:
nsAtom
(
const
char16_t
*
aString
uint32_t
aLength
uint32_t
aHash
)
:
mLength
(
aLength
)
mKind
(
static_cast
<
uint32_t
>
(
AtomKind
:
:
StaticAtom
)
)
mHash
(
aHash
)
mString
(
const_cast
<
char16_t
*
>
(
aString
)
)
{
MOZ_ASSERT
(
mHash
=
=
HashString
(
mString
mLength
)
)
;
MOZ_ASSERT
(
mString
[
mLength
]
=
=
char16_t
(
0
)
"
null
terminated
"
)
;
MOZ_ASSERT
(
NS_strlen
(
mString
)
=
=
mLength
"
correct
storage
"
)
;
}
nsAtom
:
:
~
nsAtom
(
)
{
if
(
!
IsStatic
(
)
)
{
MOZ_ASSERT
(
IsDynamic
(
)
|
|
IsHTML5
(
)
)
;
GetStringBuffer
(
)
-
>
Release
(
)
;
}
}
void
nsAtom
:
:
ToString
(
nsAString
&
aString
)
const
{
if
(
IsStatic
(
)
)
{
aString
.
AssignLiteral
(
mString
mLength
)
;
}
else
{
GetStringBuffer
(
)
-
>
ToString
(
mLength
aString
)
;
}
}
void
nsAtom
:
:
ToUTF8String
(
nsACString
&
aBuf
)
const
{
MOZ_ASSERT
(
!
IsHTML5
(
)
"
Called
ToUTF8String
(
)
on
an
HTML5
atom
"
)
;
CopyUTF16toUTF8
(
nsDependentString
(
mString
mLength
)
aBuf
)
;
}
void
nsAtom
:
:
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
const
{
MOZ_ASSERT
(
!
IsHTML5
(
)
"
Called
AddSizeOfIncludingThis
(
)
on
an
HTML5
atom
"
)
;
size_t
thisSize
=
aMallocSizeOf
(
this
)
;
if
(
IsStatic
(
)
)
{
aSizes
.
mStaticAtomObjects
+
=
thisSize
;
}
else
{
aSizes
.
mDynamicAtomObjects
+
=
thisSize
;
aSizes
.
mDynamicUnsharedBuffers
+
=
GetStringBuffer
(
)
-
>
SizeOfIncludingThisIfUnshared
(
aMallocSizeOf
)
;
}
}
struct
AtomTableKey
{
AtomTableKey
(
const
char16_t
*
aUTF16String
uint32_t
aLength
uint32_t
*
aHashOut
)
:
mUTF16String
(
aUTF16String
)
mUTF8String
(
nullptr
)
mLength
(
aLength
)
{
mHash
=
HashString
(
mUTF16String
mLength
)
;
*
aHashOut
=
mHash
;
}
AtomTableKey
(
const
char
*
aUTF8String
uint32_t
aLength
uint32_t
*
aHashOut
)
:
mUTF16String
(
nullptr
)
mUTF8String
(
aUTF8String
)
mLength
(
aLength
)
{
bool
err
;
mHash
=
HashUTF8AsUTF16
(
mUTF8String
mLength
&
err
)
;
if
(
err
)
{
mUTF8String
=
nullptr
;
mLength
=
0
;
mHash
=
0
;
}
*
aHashOut
=
mHash
;
}
const
char16_t
*
mUTF16String
;
const
char
*
mUTF8String
;
uint32_t
mLength
;
uint32_t
mHash
;
}
;
struct
AtomTableEntry
:
public
PLDHashEntryHdr
{
nsAtom
*
MOZ_NON_OWNING_REF
mAtom
;
}
;
#
define
RECENTLY_USED_MAIN_THREAD_ATOM_CACHE_SIZE
31
static
nsAtom
*
sRecentlyUsedMainThreadAtoms
[
RECENTLY_USED_MAIN_THREAD_ATOM_CACHE_SIZE
]
=
{
}
;
class
nsAtomSubTable
{
friend
class
nsAtomTable
;
Mutex
mLock
;
PLDHashTable
mTable
;
nsAtomSubTable
(
)
;
void
GCLocked
(
GCKind
aKind
)
;
void
AddSizeOfExcludingThisLocked
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
;
AtomTableEntry
*
Search
(
AtomTableKey
&
aKey
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
return
static_cast
<
AtomTableEntry
*
>
(
mTable
.
Search
(
&
aKey
)
)
;
}
AtomTableEntry
*
Add
(
AtomTableKey
&
aKey
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
return
static_cast
<
AtomTableEntry
*
>
(
mTable
.
Add
(
&
aKey
)
)
;
}
}
;
class
nsAtomTable
{
public
:
nsAtomSubTable
&
SelectSubTable
(
AtomTableKey
&
aKey
)
;
void
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
;
void
GC
(
GCKind
aKind
)
;
already_AddRefed
<
nsAtom
>
Atomize
(
const
nsAString
&
aUTF16String
)
;
already_AddRefed
<
nsAtom
>
Atomize
(
const
nsACString
&
aUTF8String
)
;
already_AddRefed
<
nsAtom
>
AtomizeMainThread
(
const
nsAString
&
aUTF16String
)
;
nsStaticAtom
*
GetStaticAtom
(
const
nsAString
&
aUTF16String
)
;
void
RegisterStaticAtoms
(
const
nsStaticAtomSetup
*
aSetup
uint32_t
aCount
)
;
size_t
RacySlowCount
(
)
;
static
void
AtomTableClearEntry
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
;
const
static
size_t
kNumSubTables
=
128
;
private
:
nsAtomSubTable
mSubTables
[
kNumSubTables
]
;
}
;
static
nsAtomTable
*
gAtomTable
;
static
PLDHashNumber
AtomTableGetHash
(
const
void
*
aKey
)
{
const
AtomTableKey
*
k
=
static_cast
<
const
AtomTableKey
*
>
(
aKey
)
;
return
k
-
>
mHash
;
}
static
bool
AtomTableMatchKey
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
const
AtomTableEntry
*
he
=
static_cast
<
const
AtomTableEntry
*
>
(
aEntry
)
;
const
AtomTableKey
*
k
=
static_cast
<
const
AtomTableKey
*
>
(
aKey
)
;
if
(
k
-
>
mUTF8String
)
{
return
CompareUTF8toUTF16
(
nsDependentCSubstring
(
k
-
>
mUTF8String
k
-
>
mUTF8String
+
k
-
>
mLength
)
nsDependentAtomString
(
he
-
>
mAtom
)
)
=
=
0
;
}
return
he
-
>
mAtom
-
>
Equals
(
k
-
>
mUTF16String
k
-
>
mLength
)
;
}
void
nsAtomTable
:
:
AtomTableClearEntry
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
{
auto
entry
=
static_cast
<
AtomTableEntry
*
>
(
aEntry
)
;
nsAtom
*
atom
=
entry
-
>
mAtom
;
if
(
atom
-
>
IsStatic
(
)
)
{
delete
atom
;
}
}
static
void
AtomTableInitEntry
(
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
static_cast
<
AtomTableEntry
*
>
(
aEntry
)
-
>
mAtom
=
nullptr
;
}
static
const
PLDHashTableOps
AtomTableOps
=
{
AtomTableGetHash
AtomTableMatchKey
PLDHashTable
:
:
MoveEntryStub
nsAtomTable
:
:
AtomTableClearEntry
AtomTableInitEntry
}
;
#
define
INITIAL_SUBTABLE_LENGTH
(
4096
/
nsAtomTable
:
:
kNumSubTables
)
nsAtomSubTable
&
nsAtomTable
:
:
SelectSubTable
(
AtomTableKey
&
aKey
)
{
static_assert
(
(
kNumSubTables
&
(
kNumSubTables
-
1
)
)
=
=
0
"
must
be
power
of
two
"
)
;
return
mSubTables
[
aKey
.
mHash
&
(
kNumSubTables
-
1
)
]
;
}
void
nsAtomTable
:
:
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aSizes
.
mTable
+
=
aMallocSizeOf
(
this
)
;
for
(
auto
&
table
:
mSubTables
)
{
MutexAutoLock
lock
(
table
.
mLock
)
;
table
.
AddSizeOfExcludingThisLocked
(
aMallocSizeOf
aSizes
)
;
}
}
void
nsAtomTable
:
:
GC
(
GCKind
aKind
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
RECENTLY_USED_MAIN_THREAD_ATOM_CACHE_SIZE
;
+
+
i
)
{
sRecentlyUsedMainThreadAtoms
[
i
]
=
nullptr
;
}
for
(
auto
&
table
:
mSubTables
)
{
MutexAutoLock
lock
(
table
.
mLock
)
;
table
.
GCLocked
(
aKind
)
;
}
MOZ_ASSERT_IF
(
aKind
=
=
GCKind
:
:
Shutdown
gUnusedAtomCount
=
=
0
)
;
}
size_t
nsAtomTable
:
:
RacySlowCount
(
)
{
GC
(
GCKind
:
:
RegularOperation
)
;
size_t
count
=
0
;
for
(
auto
&
table
:
mSubTables
)
{
MutexAutoLock
lock
(
table
.
mLock
)
;
count
+
=
table
.
mTable
.
EntryCount
(
)
;
}
return
count
;
}
nsAtomSubTable
:
:
nsAtomSubTable
(
)
:
mLock
(
"
Atom
Sub
-
Table
Lock
"
)
mTable
(
&
AtomTableOps
sizeof
(
AtomTableEntry
)
INITIAL_SUBTABLE_LENGTH
)
{
}
void
nsAtomSubTable
:
:
GCLocked
(
GCKind
aKind
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
int32_t
removedCount
=
0
;
nsAutoCString
nonZeroRefcountAtoms
;
uint32_t
nonZeroRefcountAtomsCount
=
0
;
for
(
auto
i
=
mTable
.
Iter
(
)
;
!
i
.
Done
(
)
;
i
.
Next
(
)
)
{
auto
entry
=
static_cast
<
AtomTableEntry
*
>
(
i
.
Get
(
)
)
;
if
(
entry
-
>
mAtom
-
>
IsStatic
(
)
)
{
continue
;
}
nsAtom
*
atom
=
entry
-
>
mAtom
;
MOZ_ASSERT
(
!
atom
-
>
IsHTML5
(
)
)
;
if
(
atom
-
>
IsDynamic
(
)
&
&
nsDynamicAtom
:
:
As
(
atom
)
-
>
mRefCnt
=
=
0
)
{
i
.
Remove
(
)
;
delete
atom
;
+
+
removedCount
;
}
#
ifdef
NS_FREE_PERMANENT_DATA
else
if
(
aKind
=
=
GCKind
:
:
Shutdown
&
&
PR_GetEnv
(
"
XPCOM_MEM_BLOAT_LOG
"
)
)
{
nsAutoCString
name
;
atom
-
>
ToUTF8String
(
name
)
;
if
(
nonZeroRefcountAtomsCount
=
=
0
)
{
nonZeroRefcountAtoms
=
name
;
}
else
if
(
nonZeroRefcountAtomsCount
<
20
)
{
nonZeroRefcountAtoms
+
=
NS_LITERAL_CSTRING
(
"
"
)
+
name
;
}
else
if
(
nonZeroRefcountAtomsCount
=
=
20
)
{
nonZeroRefcountAtoms
+
=
NS_LITERAL_CSTRING
(
"
.
.
.
"
)
;
}
nonZeroRefcountAtomsCount
+
+
;
}
#
endif
}
if
(
nonZeroRefcountAtomsCount
)
{
nsPrintfCString
msg
(
"
%
d
dynamic
atom
(
s
)
with
non
-
zero
refcount
:
%
s
"
nonZeroRefcountAtomsCount
nonZeroRefcountAtoms
.
get
(
)
)
;
NS_ASSERTION
(
nonZeroRefcountAtomsCount
=
=
0
msg
.
get
(
)
)
;
}
gUnusedAtomCount
-
=
removedCount
;
}
static
void
GCAtomTable
(
)
{
MOZ_ASSERT
(
gAtomTable
)
;
if
(
NS_IsMainThread
(
)
)
{
gAtomTable
-
>
GC
(
GCKind
:
:
RegularOperation
)
;
}
}
MOZ_ALWAYS_INLINE
MozExternalRefCountType
nsDynamicAtom
:
:
AddRef
(
)
{
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
=
0
"
illegal
refcnt
"
)
;
nsrefcnt
count
=
+
+
mRefCnt
;
if
(
count
=
=
1
)
{
gUnusedAtomCount
-
-
;
}
return
count
;
}
MOZ_ALWAYS_INLINE
MozExternalRefCountType
nsDynamicAtom
:
:
Release
(
)
{
#
ifdef
DEBUG
static
const
int32_t
kAtomGCThreshold
=
20
;
#
else
static
const
int32_t
kAtomGCThreshold
=
10000
;
#
endif
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
0
"
dup
release
"
)
;
nsrefcnt
count
=
-
-
mRefCnt
;
if
(
count
=
=
0
)
{
if
(
+
+
gUnusedAtomCount
>
=
kAtomGCThreshold
)
{
GCAtomTable
(
)
;
}
}
return
count
;
}
MozExternalRefCountType
nsAtom
:
:
AddRef
(
)
{
MOZ_ASSERT
(
!
IsHTML5
(
)
"
Attempt
to
AddRef
an
HTML5
atom
"
)
;
return
IsStatic
(
)
?
2
:
nsDynamicAtom
:
:
As
(
this
)
-
>
AddRef
(
)
;
}
MozExternalRefCountType
nsAtom
:
:
Release
(
)
{
MOZ_ASSERT
(
!
IsHTML5
(
)
"
Attempt
to
Release
an
HTML5
atom
"
)
;
return
IsStatic
(
)
?
1
:
nsDynamicAtom
:
:
As
(
this
)
-
>
Release
(
)
;
}
static
bool
gStaticAtomsDone
=
false
;
class
DefaultAtoms
{
public
:
NS_STATIC_ATOM_DECL
(
empty
)
}
;
NS_STATIC_ATOM_DEFN
(
DefaultAtoms
empty
)
NS_STATIC_ATOM_BUFFER
(
empty
"
"
)
static
const
nsStaticAtomSetup
sDefaultAtomSetup
[
]
=
{
NS_STATIC_ATOM_SETUP
(
DefaultAtoms
empty
)
}
;
void
NS_InitAtomTable
(
)
{
MOZ_ASSERT
(
!
gAtomTable
)
;
gAtomTable
=
new
nsAtomTable
(
)
;
NS_RegisterStaticAtoms
(
sDefaultAtomSetup
)
;
}
void
NS_ShutdownAtomTable
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
gAtomTable
)
;
#
ifdef
NS_FREE_PERMANENT_DATA
gAtomTable
-
>
GC
(
GCKind
:
:
Shutdown
)
;
#
endif
delete
gAtomTable
;
gAtomTable
=
nullptr
;
}
void
NS_AddSizeOfAtoms
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
AddSizeOfIncludingThis
(
aMallocSizeOf
aSizes
)
;
}
void
nsAtomSubTable
:
:
AddSizeOfExcludingThisLocked
(
MallocSizeOf
aMallocSizeOf
AtomsSizes
&
aSizes
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
aSizes
.
mTable
+
=
mTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
AtomTableEntry
*
>
(
iter
.
Get
(
)
)
;
entry
-
>
mAtom
-
>
AddSizeOfIncludingThis
(
aMallocSizeOf
aSizes
)
;
}
}
void
nsAtomTable
:
:
RegisterStaticAtoms
(
const
nsStaticAtomSetup
*
aSetup
uint32_t
aCount
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gStaticAtomsDone
"
Static
atom
insertion
is
finished
!
"
)
;
for
(
uint32_t
i
=
0
;
i
<
aCount
;
+
+
i
)
{
const
char16_t
*
string
=
aSetup
[
i
]
.
mString
;
nsStaticAtom
*
*
atomp
=
aSetup
[
i
]
.
mAtomp
;
MOZ_ASSERT
(
nsCRT
:
:
IsAscii
(
string
)
)
;
uint32_t
stringLen
=
NS_strlen
(
string
)
;
uint32_t
hash
;
AtomTableKey
key
(
string
stringLen
&
hash
)
;
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
MutexAutoLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Add
(
key
)
;
nsStaticAtom
*
atom
;
if
(
he
-
>
mAtom
)
{
if
(
!
he
-
>
mAtom
-
>
IsStatic
(
)
)
{
nsAutoCString
name
;
he
-
>
mAtom
-
>
ToUTF8String
(
name
)
;
MOZ_CRASH_UNSAFE_PRINTF
(
"
Static
atom
registration
for
%
s
should
be
pushed
back
"
name
.
get
(
)
)
;
}
atom
=
static_cast
<
nsStaticAtom
*
>
(
he
-
>
mAtom
)
;
}
else
{
atom
=
new
nsStaticAtom
(
string
stringLen
hash
)
;
he
-
>
mAtom
=
atom
;
}
*
atomp
=
atom
;
}
}
void
RegisterStaticAtoms
(
const
nsStaticAtomSetup
*
aSetup
uint32_t
aCount
)
{
MOZ_ASSERT
(
gAtomTable
)
;
gAtomTable
-
>
RegisterStaticAtoms
(
aSetup
aCount
)
;
}
already_AddRefed
<
nsAtom
>
NS_Atomize
(
const
char
*
aUTF8String
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
Atomize
(
nsDependentCString
(
aUTF8String
)
)
;
}
already_AddRefed
<
nsAtom
>
nsAtomTable
:
:
Atomize
(
const
nsACString
&
aUTF8String
)
{
uint32_t
hash
;
AtomTableKey
key
(
aUTF8String
.
Data
(
)
aUTF8String
.
Length
(
)
&
hash
)
;
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
MutexAutoLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Add
(
key
)
;
if
(
he
-
>
mAtom
)
{
RefPtr
<
nsAtom
>
atom
=
he
-
>
mAtom
;
return
atom
.
forget
(
)
;
}
nsString
str
;
CopyUTF8toUTF16
(
aUTF8String
str
)
;
RefPtr
<
nsAtom
>
atom
=
dont_AddRef
(
new
nsDynamicAtom
(
str
hash
)
)
;
he
-
>
mAtom
=
atom
;
return
atom
.
forget
(
)
;
}
already_AddRefed
<
nsAtom
>
NS_Atomize
(
const
nsACString
&
aUTF8String
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
Atomize
(
aUTF8String
)
;
}
already_AddRefed
<
nsAtom
>
NS_Atomize
(
const
char16_t
*
aUTF16String
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
Atomize
(
nsDependentString
(
aUTF16String
)
)
;
}
already_AddRefed
<
nsAtom
>
nsAtomTable
:
:
Atomize
(
const
nsAString
&
aUTF16String
)
{
uint32_t
hash
;
AtomTableKey
key
(
aUTF16String
.
Data
(
)
aUTF16String
.
Length
(
)
&
hash
)
;
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
MutexAutoLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Add
(
key
)
;
if
(
he
-
>
mAtom
)
{
RefPtr
<
nsAtom
>
atom
=
he
-
>
mAtom
;
return
atom
.
forget
(
)
;
}
RefPtr
<
nsAtom
>
atom
=
dont_AddRef
(
new
nsDynamicAtom
(
aUTF16String
hash
)
)
;
he
-
>
mAtom
=
atom
;
return
atom
.
forget
(
)
;
}
already_AddRefed
<
nsAtom
>
NS_Atomize
(
const
nsAString
&
aUTF16String
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
Atomize
(
aUTF16String
)
;
}
already_AddRefed
<
nsAtom
>
nsAtomTable
:
:
AtomizeMainThread
(
const
nsAString
&
aUTF16String
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
nsAtom
>
retVal
;
uint32_t
hash
;
AtomTableKey
key
(
aUTF16String
.
Data
(
)
aUTF16String
.
Length
(
)
&
hash
)
;
uint32_t
index
=
hash
%
RECENTLY_USED_MAIN_THREAD_ATOM_CACHE_SIZE
;
nsAtom
*
atom
=
sRecentlyUsedMainThreadAtoms
[
index
]
;
if
(
atom
)
{
uint32_t
length
=
atom
-
>
GetLength
(
)
;
if
(
length
=
=
key
.
mLength
&
&
(
memcmp
(
atom
-
>
GetUTF16String
(
)
key
.
mUTF16String
length
*
sizeof
(
char16_t
)
)
=
=
0
)
)
{
retVal
=
atom
;
return
retVal
.
forget
(
)
;
}
}
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
MutexAutoLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Add
(
key
)
;
if
(
he
-
>
mAtom
)
{
retVal
=
he
-
>
mAtom
;
}
else
{
RefPtr
<
nsAtom
>
newAtom
=
dont_AddRef
(
new
nsDynamicAtom
(
aUTF16String
hash
)
)
;
he
-
>
mAtom
=
newAtom
;
retVal
=
newAtom
.
forget
(
)
;
}
sRecentlyUsedMainThreadAtoms
[
index
]
=
he
-
>
mAtom
;
return
retVal
.
forget
(
)
;
}
already_AddRefed
<
nsAtom
>
NS_AtomizeMainThread
(
const
nsAString
&
aUTF16String
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
AtomizeMainThread
(
aUTF16String
)
;
}
nsrefcnt
NS_GetNumberOfAtoms
(
void
)
{
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
RacySlowCount
(
)
;
}
int32_t
NS_GetUnusedAtomCount
(
void
)
{
return
gUnusedAtomCount
;
}
nsStaticAtom
*
NS_GetStaticAtom
(
const
nsAString
&
aUTF16String
)
{
MOZ_ASSERT
(
gStaticAtomsDone
"
Static
atom
setup
not
yet
done
.
"
)
;
MOZ_ASSERT
(
gAtomTable
)
;
return
gAtomTable
-
>
GetStaticAtom
(
aUTF16String
)
;
}
nsStaticAtom
*
nsAtomTable
:
:
GetStaticAtom
(
const
nsAString
&
aUTF16String
)
{
uint32_t
hash
;
AtomTableKey
key
(
aUTF16String
.
Data
(
)
aUTF16String
.
Length
(
)
&
hash
)
;
nsAtomSubTable
&
table
=
SelectSubTable
(
key
)
;
MutexAutoLock
lock
(
table
.
mLock
)
;
AtomTableEntry
*
he
=
table
.
Search
(
key
)
;
return
he
&
&
he
-
>
mAtom
-
>
IsStatic
(
)
?
static_cast
<
nsStaticAtom
*
>
(
he
-
>
mAtom
)
:
nullptr
;
}
void
NS_SetStaticAtomsDone
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
gStaticAtomsDone
=
true
;
}
