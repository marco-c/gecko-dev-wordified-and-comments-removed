#
ifndef
nsClassHashtable_h__
#
define
nsClassHashtable_h__
#
include
"
mozilla
/
Move
.
h
"
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsAutoPtr
.
h
"
template
<
class
KeyClass
class
T
>
class
nsClassHashtable
:
public
nsBaseHashtable
<
KeyClass
nsAutoPtr
<
T
>
T
*
>
{
public
:
typedef
typename
KeyClass
:
:
KeyType
KeyType
;
typedef
T
*
UserDataType
;
typedef
nsBaseHashtable
<
KeyClass
nsAutoPtr
<
T
>
T
*
>
base_type
;
using
base_type
:
:
IsEmpty
;
nsClassHashtable
(
)
{
}
explicit
nsClassHashtable
(
uint32_t
aInitLength
)
:
nsBaseHashtable
<
KeyClass
nsAutoPtr
<
T
>
T
*
>
(
aInitLength
)
{
}
template
<
typename
.
.
.
Args
>
UserDataType
LookupOrAdd
(
KeyType
aKey
Args
&
&
.
.
.
aConstructionArgs
)
;
bool
Get
(
KeyType
aKey
UserDataType
*
aData
)
const
;
UserDataType
Get
(
KeyType
aKey
)
const
;
void
RemoveAndForget
(
KeyType
aKey
nsAutoPtr
<
T
>
&
aOut
)
;
struct
EntryPtr
{
private
:
typename
base_type
:
:
EntryType
&
mEntry
;
#
ifdef
DEBUG
base_type
&
mTable
;
uint32_t
mTableGeneration
;
#
endif
public
:
EntryPtr
(
base_type
&
aTable
typename
base_type
:
:
EntryType
*
aEntry
)
:
mEntry
(
*
aEntry
)
#
ifdef
DEBUG
mTable
(
aTable
)
mTableGeneration
(
aTable
.
GetGeneration
(
)
)
#
endif
{
}
~
EntryPtr
(
)
{
MOZ_ASSERT
(
mEntry
.
mData
"
Entry
should
have
been
added
by
now
"
)
;
}
explicit
operator
bool
(
)
const
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
return
!
!
mEntry
.
mData
;
}
template
<
class
F
>
T
*
OrInsert
(
F
func
)
{
MOZ_ASSERT
(
mTableGeneration
=
=
mTable
.
GetGeneration
(
)
)
;
if
(
!
mEntry
.
mData
)
{
mEntry
.
mData
=
func
(
)
;
}
return
mEntry
.
mData
;
}
}
;
MOZ_MUST_USE
EntryPtr
LookupForAdd
(
KeyType
aKey
)
;
}
;
template
<
class
KeyClass
class
T
>
template
<
typename
.
.
.
Args
>
T
*
nsClassHashtable
<
KeyClass
T
>
:
:
LookupOrAdd
(
KeyType
aKey
Args
&
&
.
.
.
aConstructionArgs
)
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
)
;
if
(
!
ent
-
>
mData
)
{
ent
-
>
mData
=
new
T
(
mozilla
:
:
Forward
<
Args
>
(
aConstructionArgs
)
.
.
.
)
;
}
return
ent
-
>
mData
;
}
template
<
class
KeyClass
class
T
>
typename
nsClassHashtable
<
KeyClass
T
>
:
:
EntryPtr
nsClassHashtable
<
KeyClass
T
>
:
:
LookupForAdd
(
KeyType
aKey
)
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
)
;
return
EntryPtr
(
*
this
ent
)
;
}
template
<
class
KeyClass
class
T
>
bool
nsClassHashtable
<
KeyClass
T
>
:
:
Get
(
KeyType
aKey
T
*
*
aRetVal
)
const
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
ent
)
{
if
(
aRetVal
)
{
*
aRetVal
=
ent
-
>
mData
;
}
return
true
;
}
if
(
aRetVal
)
{
*
aRetVal
=
nullptr
;
}
return
false
;
}
template
<
class
KeyClass
class
T
>
T
*
nsClassHashtable
<
KeyClass
T
>
:
:
Get
(
KeyType
aKey
)
const
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
nullptr
;
}
return
ent
-
>
mData
;
}
template
<
class
KeyClass
class
T
>
void
nsClassHashtable
<
KeyClass
T
>
:
:
RemoveAndForget
(
KeyType
aKey
nsAutoPtr
<
T
>
&
aOut
)
{
aOut
=
nullptr
;
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
;
}
aOut
=
mozilla
:
:
Move
(
ent
-
>
mData
)
;
this
-
>
Remove
(
aKey
)
;
}
#
endif
