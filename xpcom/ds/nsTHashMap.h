#
ifndef
XPCOM_DS_NSTHASHMAP_H_
#
define
XPCOM_DS_NSTHASHMAP_H_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsAtomHashKeys
.
h
"
#
include
"
nsHashtablesFwd
.
h
"
#
include
<
type_traits
>
namespace
mozilla
:
:
detail
{
template
<
class
KeyType
>
struct
nsKeyClass
<
KeyType
std
:
:
enable_if_t
<
sizeof
(
KeyType
)
&
&
std
:
:
is_base_of_v
<
PLDHashEntryHdr
KeyType
>
>
>
{
using
type
=
KeyType
;
}
;
template
<
typename
KeyType
>
struct
nsKeyClass
<
KeyType
*
>
{
using
type
=
nsPtrHashKey
<
KeyType
>
;
}
;
template
<
>
struct
nsKeyClass
<
nsAtom
*
>
{
using
type
=
nsWeakAtomHashKey
;
}
;
template
<
typename
Ret
typename
.
.
.
Args
>
struct
nsKeyClass
<
Ret
(
*
)
(
Args
.
.
.
)
>
{
using
type
=
nsFuncPtrHashKey
<
Ret
(
*
)
(
Args
.
.
.
)
>
;
}
;
template
<
>
struct
nsKeyClass
<
nsCString
>
{
using
type
=
nsCStringHashKey
;
}
;
template
<
>
struct
nsKeyClass
<
nsString
>
{
using
type
=
nsStringHashKey
;
}
;
template
<
typename
KeyType
>
struct
nsKeyClass
<
KeyType
std
:
:
enable_if_t
<
std
:
:
is_integral_v
<
KeyType
>
|
|
std
:
:
is_enum_v
<
KeyType
>
>
>
{
using
type
=
nsIntegralHashKey
<
KeyType
>
;
}
;
template
<
>
struct
nsKeyClass
<
nsCOMPtr
<
nsISupports
>
>
{
using
type
=
nsISupportsHashKey
;
}
;
template
<
typename
T
>
struct
nsKeyClass
<
RefPtr
<
T
>
>
{
using
type
=
nsRefPtrHashKey
<
T
>
;
}
;
template
<
>
struct
nsKeyClass
<
RefPtr
<
nsAtom
>
>
{
using
type
=
nsAtomHashKey
;
}
;
template
<
>
struct
nsKeyClass
<
nsID
>
{
using
type
=
nsIDHashKey
;
}
;
}
#
endif
