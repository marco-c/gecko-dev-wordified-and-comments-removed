#
ifndef
XPCOM_DS_NSTHASHMAP_H_
#
define
XPCOM_DS_NSTHASHMAP_H_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsHashtablesFwd
.
h
"
#
include
<
type_traits
>
namespace
mozilla
:
:
detail
{
template
<
class
KeyType
>
struct
nsKeyClass
{
static_assert
(
sizeof
(
KeyType
)
>
0
"
KeyType
must
be
a
complete
type
(
unless
there
'
s
an
explicit
"
"
specialization
for
nsKeyClass
<
KeyType
>
)
"
)
;
static_assert
(
std
:
:
is_base_of_v
<
PLDHashEntryHdr
KeyType
>
"
KeyType
must
inherit
from
PLDHashEntryHdr
(
unless
there
'
s
an
"
"
explicit
specialization
for
nsKeyClass
<
KeyType
>
)
"
)
;
using
type
=
std
:
:
conditional_t
<
std
:
:
is_base_of_v
<
PLDHashEntryHdr
KeyType
>
KeyType
void
>
;
}
;
template
<
typename
KeyType
>
struct
nsKeyClass
<
KeyType
*
>
{
using
type
=
nsPtrHashKey
<
KeyType
>
;
}
;
template
<
>
struct
nsKeyClass
<
nsCString
>
{
using
type
=
nsCStringHashKey
;
}
;
template
<
>
struct
nsKeyClass
<
nsString
>
{
using
type
=
nsStringHashKey
;
}
;
template
<
>
struct
nsKeyClass
<
uint32_t
>
{
using
type
=
nsUint32HashKey
;
}
;
template
<
>
struct
nsKeyClass
<
uint64_t
>
{
using
type
=
nsUint64HashKey
;
}
;
template
<
>
struct
nsKeyClass
<
intptr_t
>
{
using
type
=
IntPtrHashKey
;
}
;
template
<
>
struct
nsKeyClass
<
nsCOMPtr
<
nsISupports
>
>
{
using
type
=
nsISupportsHashKey
;
}
;
template
<
typename
T
>
struct
nsKeyClass
<
RefPtr
<
T
>
>
{
using
type
=
nsRefPtrHashKey
<
T
>
;
}
;
template
<
>
struct
nsKeyClass
<
nsID
>
{
using
type
=
nsIDHashKey
;
}
;
}
#
endif
