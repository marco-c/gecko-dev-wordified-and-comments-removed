#
ifndef
nsCRT_h___
#
define
nsCRT_h___
#
include
<
stdlib
.
h
>
#
include
<
ctype
.
h
>
#
include
"
plstr
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
if
defined
(
XP_WIN
)
#
define
NS_LINEBREAK
"
\
015
\
012
"
#
define
NS_ULINEBREAK
u
"
\
015
\
012
"
#
define
NS_LINEBREAK_LEN
2
#
else
#
ifdef
XP_UNIX
#
define
NS_LINEBREAK
"
\
012
"
#
define
NS_ULINEBREAK
u
"
\
012
"
#
define
NS_LINEBREAK_LEN
1
#
endif
#
endif
class
nsCRT
{
public
:
enum
{
LF
=
'
\
n
'
VTAB
=
'
\
v
'
CR
=
'
\
r
'
}
;
static
int32_t
strcmp
(
const
char
*
aStr1
const
char
*
aStr2
)
{
return
int32_t
(
PL_strcmp
(
aStr1
aStr2
)
)
;
}
static
int32_t
strcasecmp
(
const
char
*
aStr1
const
char
*
aStr2
)
{
#
if
defined
(
LIBFUZZER
)
&
&
defined
(
LINUX
)
return
int32_t
(
:
:
strcasecmp
(
aStr1
aStr2
)
)
;
#
else
return
int32_t
(
PL_strcasecmp
(
aStr1
aStr2
)
)
;
#
endif
}
static
int32_t
strncasecmp
(
const
char
*
aStr1
const
char
*
aStr2
uint32_t
aMaxLen
)
{
#
if
defined
(
LIBFUZZER
)
&
&
defined
(
LINUX
)
int32_t
result
=
int32_t
(
:
:
strncasecmp
(
aStr1
aStr2
aMaxLen
)
)
;
#
else
int32_t
result
=
int32_t
(
PL_strncasecmp
(
aStr1
aStr2
aMaxLen
)
)
;
#
endif
if
(
result
<
0
)
{
result
=
-
1
;
}
return
result
;
}
static
char
*
strcasestr
(
const
char
*
aStr1
const
char
*
aStr2
)
{
#
if
defined
(
LIBFUZZER
)
&
&
defined
(
LINUX
)
return
const_cast
<
char
*
>
(
:
:
strcasestr
(
aStr1
aStr2
)
)
;
#
else
return
PL_strcasestr
(
aStr1
aStr2
)
;
#
endif
}
static
char
*
strtok
(
char
*
aStr
const
char
*
aDelims
char
*
*
aNewStr
)
;
static
int32_t
strcmp
(
const
char16_t
*
aStr1
const
char16_t
*
aStr2
)
;
static
int64_t
atoll
(
const
char
*
aStr
)
;
static
char
ToUpper
(
char
aChar
)
{
return
NS_ToUpper
(
aChar
)
;
}
static
char
ToLower
(
char
aChar
)
{
return
NS_ToLower
(
aChar
)
;
}
static
bool
IsAsciiSpace
(
char16_t
aChar
)
{
return
NS_IsAsciiWhitespace
(
aChar
)
;
}
}
;
inline
bool
NS_IS_SPACE
(
char16_t
aChar
)
{
return
(
(
int
(
aChar
)
&
0x7f
)
=
=
int
(
aChar
)
)
&
&
isspace
(
int
(
aChar
)
)
;
}
#
endif
