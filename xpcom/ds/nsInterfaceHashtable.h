#
ifndef
nsInterfaceHashtable_h__
#
define
nsInterfaceHashtable_h__
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsCOMPtr
.
h
"
template
<
class
KeyClass
class
Interface
>
class
nsInterfaceHashtable
:
public
nsBaseHashtable
<
KeyClass
nsCOMPtr
<
Interface
>
Interface
*
>
{
public
:
typedef
typename
KeyClass
:
:
KeyType
KeyType
;
typedef
Interface
*
UserDataType
;
typedef
nsBaseHashtable
<
KeyClass
nsCOMPtr
<
Interface
>
Interface
*
>
base_type
;
nsInterfaceHashtable
(
)
{
}
explicit
nsInterfaceHashtable
(
uint32_t
aInitLength
)
:
nsBaseHashtable
<
KeyClass
nsCOMPtr
<
Interface
>
Interface
*
>
(
aInitLength
)
{
}
bool
Get
(
KeyType
aKey
UserDataType
*
aData
)
const
;
already_AddRefed
<
Interface
>
Get
(
KeyType
aKey
)
const
;
Interface
*
GetWeak
(
KeyType
aKey
bool
*
aFound
=
nullptr
)
const
;
void
Put
(
KeyType
aKey
already_AddRefed
<
Interface
>
&
&
aData
)
{
if
(
!
Put
(
aKey
std
:
:
move
(
aData
)
mozilla
:
:
fallible
)
)
{
NS_ABORT_OOM
(
this
-
>
mTable
.
EntrySize
(
)
*
this
-
>
mTable
.
EntryCount
(
)
)
;
}
}
MOZ_MUST_USE
bool
Put
(
KeyType
aKey
already_AddRefed
<
Interface
>
&
&
aData
const
mozilla
:
:
fallible_t
&
)
;
using
base_type
:
:
Put
;
inline
bool
Remove
(
KeyType
aKey
Interface
*
*
aData
=
nullptr
)
;
}
;
template
<
typename
K
typename
T
>
inline
void
ImplCycleCollectionUnlink
(
nsInterfaceHashtable
<
K
T
>
&
aField
)
{
aField
.
Clear
(
)
;
}
template
<
typename
K
typename
T
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
const
nsInterfaceHashtable
<
K
T
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
for
(
auto
iter
=
aField
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
CycleCollectionNoteChild
(
aCallback
iter
.
UserData
(
)
aName
aFlags
)
;
}
}
template
<
class
KeyClass
class
Interface
>
bool
nsInterfaceHashtable
<
KeyClass
Interface
>
:
:
Get
(
KeyType
aKey
UserDataType
*
aInterface
)
const
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
ent
)
{
if
(
aInterface
)
{
*
aInterface
=
ent
-
>
mData
;
NS_IF_ADDREF
(
*
aInterface
)
;
}
return
true
;
}
if
(
aInterface
)
{
*
aInterface
=
nullptr
;
}
return
false
;
}
template
<
class
KeyClass
class
Interface
>
already_AddRefed
<
Interface
>
nsInterfaceHashtable
<
KeyClass
Interface
>
:
:
Get
(
KeyType
aKey
)
const
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
nullptr
;
}
nsCOMPtr
<
Interface
>
copy
=
ent
-
>
mData
;
return
copy
.
forget
(
)
;
}
template
<
class
KeyClass
class
Interface
>
Interface
*
nsInterfaceHashtable
<
KeyClass
Interface
>
:
:
GetWeak
(
KeyType
aKey
bool
*
aFound
)
const
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
ent
)
{
if
(
aFound
)
{
*
aFound
=
true
;
}
return
ent
-
>
mData
;
}
if
(
aFound
)
{
*
aFound
=
false
;
}
return
nullptr
;
}
template
<
class
KeyClass
class
Interface
>
bool
nsInterfaceHashtable
<
KeyClass
Interface
>
:
:
Put
(
KeyType
aKey
already_AddRefed
<
Interface
>
&
&
aValue
const
mozilla
:
:
fallible_t
&
)
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
)
;
if
(
!
ent
)
{
return
false
;
}
ent
-
>
mData
=
aValue
;
return
true
;
}
template
<
class
KeyClass
class
Interface
>
bool
nsInterfaceHashtable
<
KeyClass
Interface
>
:
:
Remove
(
KeyType
aKey
Interface
*
*
aData
)
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
ent
)
{
if
(
aData
)
{
ent
-
>
mData
.
forget
(
aData
)
;
}
this
-
>
RemoveEntry
(
ent
)
;
return
true
;
}
if
(
aData
)
{
*
aData
=
nullptr
;
}
return
false
;
}
#
endif
