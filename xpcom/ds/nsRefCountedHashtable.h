#
ifndef
XPCOM_DS_NSREFCOUNTEDHASHTABLE_H_
#
define
XPCOM_DS_NSREFCOUNTEDHASHTABLE_H_
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
template
<
class
KeyClass
class
PtrType
>
class
nsRefCountedHashtable
:
public
nsBaseHashtable
<
KeyClass
PtrType
typename
mozilla
:
:
detail
:
:
SmartPtrTraits
<
PtrType
>
:
:
RawPointerType
>
{
public
:
using
KeyType
=
typename
KeyClass
:
:
KeyType
;
using
SmartPtrTraits
=
mozilla
:
:
detail
:
:
SmartPtrTraits
<
PtrType
>
;
using
PointeeType
=
typename
SmartPtrTraits
:
:
PointeeType
;
using
RawPointerType
=
typename
SmartPtrTraits
:
:
RawPointerType
;
using
base_type
=
nsBaseHashtable
<
KeyClass
PtrType
RawPointerType
>
;
using
base_type
:
:
base_type
;
static_assert
(
SmartPtrTraits
:
:
IsRefCounted
)
;
bool
Get
(
KeyType
aKey
RawPointerType
*
aData
)
const
;
[
[
nodiscard
]
]
already_AddRefed
<
PointeeType
>
Get
(
KeyType
aKey
)
const
;
[
[
nodiscard
]
]
RawPointerType
GetWeak
(
KeyType
aKey
bool
*
aFound
=
nullptr
)
const
;
using
base_type
:
:
InsertOrUpdate
;
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
PointeeType
U
>
>
>
void
InsertOrUpdate
(
KeyType
aKey
typename
SmartPtrTraits
:
:
template
OtherSmartPtrType
<
U
>
&
&
aData
)
;
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
PointeeType
U
>
>
>
[
[
nodiscard
]
]
bool
InsertOrUpdate
(
KeyType
aKey
typename
SmartPtrTraits
:
:
template
OtherSmartPtrType
<
U
>
&
&
aData
const
mozilla
:
:
fallible_t
&
)
;
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
PointeeType
U
>
>
>
void
InsertOrUpdate
(
KeyType
aKey
already_AddRefed
<
U
>
&
&
aData
)
;
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
PointeeType
U
>
>
>
[
[
nodiscard
]
]
bool
InsertOrUpdate
(
KeyType
aKey
already_AddRefed
<
U
>
&
&
aData
const
mozilla
:
:
fallible_t
&
)
;
inline
bool
Remove
(
KeyType
aKey
RawPointerType
*
aData
=
nullptr
)
;
nsRefCountedHashtable
Clone
(
)
const
{
return
this
-
>
template
CloneAs
<
nsRefCountedHashtable
>
(
)
;
}
}
;
template
<
typename
K
typename
T
>
inline
void
ImplCycleCollectionUnlink
(
nsRefCountedHashtable
<
K
T
>
&
aField
)
{
aField
.
Clear
(
)
;
}
template
<
typename
K
typename
T
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
nsRefCountedHashtable
<
K
T
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
for
(
auto
iter
=
aField
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
CycleCollectionNoteChild
(
aCallback
iter
.
UserData
(
)
aName
aFlags
)
;
}
}
template
<
class
KeyClass
class
PtrType
>
bool
nsRefCountedHashtable
<
KeyClass
PtrType
>
:
:
Get
(
KeyType
aKey
RawPointerType
*
aRefPtr
)
const
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
ent
)
{
if
(
aRefPtr
)
{
*
aRefPtr
=
ent
-
>
GetData
(
)
;
NS_IF_ADDREF
(
*
aRefPtr
)
;
}
return
true
;
}
if
(
aRefPtr
)
{
*
aRefPtr
=
nullptr
;
}
return
false
;
}
template
<
class
KeyClass
class
PtrType
>
already_AddRefed
<
typename
nsRefCountedHashtable
<
KeyClass
PtrType
>
:
:
PointeeType
>
nsRefCountedHashtable
<
KeyClass
PtrType
>
:
:
Get
(
KeyType
aKey
)
const
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
nullptr
;
}
PtrType
copy
=
ent
-
>
GetData
(
)
;
return
copy
.
forget
(
)
;
}
template
<
class
KeyClass
class
PtrType
>
typename
nsRefCountedHashtable
<
KeyClass
PtrType
>
:
:
RawPointerType
nsRefCountedHashtable
<
KeyClass
PtrType
>
:
:
GetWeak
(
KeyType
aKey
bool
*
aFound
)
const
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
ent
)
{
if
(
aFound
)
{
*
aFound
=
true
;
}
return
ent
-
>
GetData
(
)
;
}
if
(
aFound
)
{
*
aFound
=
false
;
}
return
nullptr
;
}
template
<
class
KeyClass
class
PtrType
>
template
<
typename
U
typename
>
void
nsRefCountedHashtable
<
KeyClass
PtrType
>
:
:
InsertOrUpdate
(
KeyType
aKey
typename
SmartPtrTraits
:
:
template
OtherSmartPtrType
<
U
>
&
&
aData
)
{
if
(
!
InsertOrUpdate
(
aKey
std
:
:
move
(
aData
)
mozilla
:
:
fallible
)
)
{
NS_ABORT_OOM
(
this
-
>
mTable
.
EntrySize
(
)
*
this
-
>
mTable
.
EntryCount
(
)
)
;
}
}
template
<
class
KeyClass
class
PtrType
>
template
<
typename
U
typename
>
bool
nsRefCountedHashtable
<
KeyClass
PtrType
>
:
:
InsertOrUpdate
(
KeyType
aKey
typename
SmartPtrTraits
:
:
template
OtherSmartPtrType
<
U
>
&
&
aData
const
mozilla
:
:
fallible_t
&
)
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
mozilla
:
:
fallible
)
;
if
(
!
ent
)
{
return
false
;
}
ent
-
>
SetData
(
std
:
:
move
(
aData
)
)
;
return
true
;
}
template
<
class
KeyClass
class
PtrType
>
template
<
typename
U
typename
>
void
nsRefCountedHashtable
<
KeyClass
PtrType
>
:
:
InsertOrUpdate
(
KeyType
aKey
already_AddRefed
<
U
>
&
&
aData
)
{
if
(
!
InsertOrUpdate
(
aKey
std
:
:
move
(
aData
)
mozilla
:
:
fallible
)
)
{
NS_ABORT_OOM
(
this
-
>
mTable
.
EntrySize
(
)
*
this
-
>
mTable
.
EntryCount
(
)
)
;
}
}
template
<
class
KeyClass
class
PtrType
>
template
<
typename
U
typename
>
bool
nsRefCountedHashtable
<
KeyClass
PtrType
>
:
:
InsertOrUpdate
(
KeyType
aKey
already_AddRefed
<
U
>
&
&
aData
const
mozilla
:
:
fallible_t
&
)
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
mozilla
:
:
fallible
)
;
if
(
!
ent
)
{
return
false
;
}
ent
-
>
SetData
(
std
:
:
move
(
aData
)
)
;
return
true
;
}
template
<
class
KeyClass
class
PtrType
>
bool
nsRefCountedHashtable
<
KeyClass
PtrType
>
:
:
Remove
(
KeyType
aKey
RawPointerType
*
aRefPtr
)
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
ent
)
{
if
(
aRefPtr
)
{
ent
-
>
GetModifiableData
(
)
-
>
forget
(
aRefPtr
)
;
}
this
-
>
RemoveEntry
(
ent
)
;
return
true
;
}
if
(
aRefPtr
)
{
*
aRefPtr
=
nullptr
;
}
return
false
;
}
#
endif
