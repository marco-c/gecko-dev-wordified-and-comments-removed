#
ifndef
nsRefPtrHashtable_h__
#
define
nsRefPtrHashtable_h__
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
template
<
class
KeyClass
class
PtrType
>
class
nsRefPtrHashtable
:
public
nsBaseHashtable
<
KeyClass
RefPtr
<
PtrType
>
PtrType
*
>
{
public
:
typedef
typename
KeyClass
:
:
KeyType
KeyType
;
typedef
PtrType
*
UserDataType
;
typedef
nsBaseHashtable
<
KeyClass
RefPtr
<
PtrType
>
PtrType
*
>
base_type
;
nsRefPtrHashtable
(
)
=
default
;
explicit
nsRefPtrHashtable
(
uint32_t
aInitLength
)
:
nsBaseHashtable
<
KeyClass
RefPtr
<
PtrType
>
PtrType
*
>
(
aInitLength
)
{
}
bool
Get
(
KeyType
aKey
UserDataType
*
aData
)
const
;
[
[
nodiscard
]
]
already_AddRefed
<
PtrType
>
Get
(
KeyType
aKey
)
const
;
[
[
nodiscard
]
]
PtrType
*
GetWeak
(
KeyType
aKey
bool
*
aFound
=
nullptr
)
const
;
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
PtrType
U
>
>
>
void
InsertOrUpdate
(
KeyType
aKey
RefPtr
<
U
>
&
&
aData
)
;
template
<
typename
U
typename
=
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
PtrType
U
>
>
>
[
[
nodiscard
]
]
bool
InsertOrUpdate
(
KeyType
aKey
RefPtr
<
U
>
&
&
aData
const
mozilla
:
:
fallible_t
&
)
;
inline
bool
Remove
(
KeyType
aKey
UserDataType
*
aData
=
nullptr
)
;
}
;
template
<
typename
K
typename
T
>
inline
void
ImplCycleCollectionUnlink
(
nsRefPtrHashtable
<
K
T
>
&
aField
)
{
aField
.
Clear
(
)
;
}
template
<
typename
K
typename
T
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
nsRefPtrHashtable
<
K
T
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
for
(
auto
iter
=
aField
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
CycleCollectionNoteChild
(
aCallback
iter
.
UserData
(
)
aName
aFlags
)
;
}
}
template
<
class
KeyClass
class
PtrType
>
bool
nsRefPtrHashtable
<
KeyClass
PtrType
>
:
:
Get
(
KeyType
aKey
UserDataType
*
aRefPtr
)
const
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
ent
)
{
if
(
aRefPtr
)
{
*
aRefPtr
=
ent
-
>
GetData
(
)
;
NS_IF_ADDREF
(
*
aRefPtr
)
;
}
return
true
;
}
if
(
aRefPtr
)
{
*
aRefPtr
=
nullptr
;
}
return
false
;
}
template
<
class
KeyClass
class
PtrType
>
already_AddRefed
<
PtrType
>
nsRefPtrHashtable
<
KeyClass
PtrType
>
:
:
Get
(
KeyType
aKey
)
const
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
nullptr
;
}
RefPtr
<
PtrType
>
copy
=
ent
-
>
GetData
(
)
;
return
copy
.
forget
(
)
;
}
template
<
class
KeyClass
class
PtrType
>
PtrType
*
nsRefPtrHashtable
<
KeyClass
PtrType
>
:
:
GetWeak
(
KeyType
aKey
bool
*
aFound
)
const
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
ent
)
{
if
(
aFound
)
{
*
aFound
=
true
;
}
return
ent
-
>
GetData
(
)
;
}
if
(
aFound
)
{
*
aFound
=
false
;
}
return
nullptr
;
}
template
<
class
KeyClass
class
PtrType
>
template
<
typename
U
typename
>
void
nsRefPtrHashtable
<
KeyClass
PtrType
>
:
:
InsertOrUpdate
(
KeyType
aKey
RefPtr
<
U
>
&
&
aData
)
{
if
(
!
InsertOrUpdate
(
aKey
std
:
:
move
(
aData
)
mozilla
:
:
fallible
)
)
{
NS_ABORT_OOM
(
this
-
>
mTable
.
EntrySize
(
)
*
this
-
>
mTable
.
EntryCount
(
)
)
;
}
}
template
<
class
KeyClass
class
PtrType
>
template
<
typename
U
typename
>
bool
nsRefPtrHashtable
<
KeyClass
PtrType
>
:
:
InsertOrUpdate
(
KeyType
aKey
RefPtr
<
U
>
&
&
aData
const
mozilla
:
:
fallible_t
&
)
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
mozilla
:
:
fallible
)
;
if
(
!
ent
)
{
return
false
;
}
ent
-
>
SetData
(
std
:
:
move
(
aData
)
)
;
return
true
;
}
template
<
class
KeyClass
class
PtrType
>
bool
nsRefPtrHashtable
<
KeyClass
PtrType
>
:
:
Remove
(
KeyType
aKey
UserDataType
*
aRefPtr
)
{
typename
base_type
:
:
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
ent
)
{
if
(
aRefPtr
)
{
ent
-
>
GetModifiableData
(
)
-
>
forget
(
aRefPtr
)
;
}
this
-
>
RemoveEntry
(
ent
)
;
return
true
;
}
if
(
aRefPtr
)
{
*
aRefPtr
=
nullptr
;
}
return
false
;
}
#
endif
