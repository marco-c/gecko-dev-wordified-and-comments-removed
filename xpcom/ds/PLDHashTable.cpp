#
include
<
new
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
"
PLDHashTable
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ChaosMode
.
h
"
using
namespace
mozilla
;
#
ifdef
DEBUG
class
AutoReadOp
{
Checker
&
mChk
;
public
:
explicit
AutoReadOp
(
Checker
&
aChk
)
:
mChk
(
aChk
)
{
mChk
.
StartReadOp
(
)
;
}
~
AutoReadOp
(
)
{
mChk
.
EndReadOp
(
)
;
}
}
;
class
AutoWriteOp
{
Checker
&
mChk
;
public
:
explicit
AutoWriteOp
(
Checker
&
aChk
)
:
mChk
(
aChk
)
{
mChk
.
StartWriteOp
(
)
;
}
~
AutoWriteOp
(
)
{
mChk
.
EndWriteOp
(
)
;
}
}
;
class
AutoIteratorRemovalOp
{
Checker
&
mChk
;
public
:
explicit
AutoIteratorRemovalOp
(
Checker
&
aChk
)
:
mChk
(
aChk
)
{
mChk
.
StartIteratorRemovalOp
(
)
;
}
~
AutoIteratorRemovalOp
(
)
{
mChk
.
EndIteratorRemovalOp
(
)
;
}
}
;
class
AutoDestructorOp
{
Checker
&
mChk
;
public
:
explicit
AutoDestructorOp
(
Checker
&
aChk
)
:
mChk
(
aChk
)
{
mChk
.
StartDestructorOp
(
)
;
}
~
AutoDestructorOp
(
)
{
mChk
.
EndDestructorOp
(
)
;
}
}
;
#
endif
PLDHashNumber
PLDHashTable
:
:
HashStringKey
(
const
void
*
aKey
)
{
return
HashString
(
static_cast
<
const
char
*
>
(
aKey
)
)
;
}
PLDHashNumber
PLDHashTable
:
:
HashVoidPtrKeyStub
(
const
void
*
aKey
)
{
return
(
PLDHashNumber
)
(
ptrdiff_t
)
aKey
>
>
2
;
}
bool
PLDHashTable
:
:
MatchEntryStub
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
const
PLDHashEntryStub
*
stub
=
(
const
PLDHashEntryStub
*
)
aEntry
;
return
stub
-
>
key
=
=
aKey
;
}
bool
PLDHashTable
:
:
MatchStringKey
(
const
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
const
PLDHashEntryStub
*
stub
=
(
const
PLDHashEntryStub
*
)
aEntry
;
return
stub
-
>
key
=
=
aKey
|
|
(
stub
-
>
key
&
&
aKey
&
&
strcmp
(
(
const
char
*
)
stub
-
>
key
(
const
char
*
)
aKey
)
=
=
0
)
;
}
void
PLDHashTable
:
:
MoveEntryStub
(
PLDHashTable
*
aTable
const
PLDHashEntryHdr
*
aFrom
PLDHashEntryHdr
*
aTo
)
{
memcpy
(
aTo
aFrom
aTable
-
>
mEntrySize
)
;
}
void
PLDHashTable
:
:
ClearEntryStub
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
{
memset
(
aEntry
0
aTable
-
>
mEntrySize
)
;
}
static
const
PLDHashTableOps
gStubOps
=
{
PLDHashTable
:
:
HashVoidPtrKeyStub
PLDHashTable
:
:
MatchEntryStub
PLDHashTable
:
:
MoveEntryStub
PLDHashTable
:
:
ClearEntryStub
nullptr
}
;
const
PLDHashTableOps
*
PLDHashTable
:
:
StubOps
(
)
{
return
&
gStubOps
;
}
static
bool
SizeOfEntryStore
(
uint32_t
aCapacity
uint32_t
aEntrySize
uint32_t
*
aNbytes
)
{
uint64_t
nbytes64
=
uint64_t
(
aCapacity
)
*
uint64_t
(
aEntrySize
)
;
*
aNbytes
=
aCapacity
*
aEntrySize
;
return
uint64_t
(
*
aNbytes
)
=
=
nbytes64
;
}
static
inline
uint32_t
MaxLoad
(
uint32_t
aCapacity
)
{
return
aCapacity
-
(
aCapacity
>
>
2
)
;
}
static
inline
uint32_t
MaxLoadOnGrowthFailure
(
uint32_t
aCapacity
)
{
return
aCapacity
-
(
aCapacity
>
>
5
)
;
}
static
inline
uint32_t
MinLoad
(
uint32_t
aCapacity
)
{
return
aCapacity
>
>
2
;
}
static
inline
void
BestCapacity
(
uint32_t
aLength
uint32_t
*
aCapacityOut
uint32_t
*
aLog2CapacityOut
)
{
uint32_t
capacity
=
(
aLength
*
4
+
(
3
-
1
)
)
/
3
;
if
(
capacity
<
PLDHashTable
:
:
kMinCapacity
)
{
capacity
=
PLDHashTable
:
:
kMinCapacity
;
}
uint32_t
log2
=
CeilingLog2
(
capacity
)
;
capacity
=
1u
<
<
log2
;
MOZ_ASSERT
(
capacity
<
=
PLDHashTable
:
:
kMaxCapacity
)
;
*
aCapacityOut
=
capacity
;
*
aLog2CapacityOut
=
log2
;
}
MOZ_ALWAYS_INLINE
uint32_t
PLDHashTable
:
:
HashShift
(
uint32_t
aEntrySize
uint32_t
aLength
)
{
if
(
aLength
>
kMaxInitialLength
)
{
MOZ_CRASH
(
"
Initial
length
is
too
large
"
)
;
}
uint32_t
capacity
log2
;
BestCapacity
(
aLength
&
capacity
&
log2
)
;
uint32_t
nbytes
;
if
(
!
SizeOfEntryStore
(
capacity
aEntrySize
&
nbytes
)
)
{
MOZ_CRASH
(
"
Initial
entry
store
size
is
too
large
"
)
;
}
return
kHashBits
-
log2
;
}
PLDHashTable
:
:
PLDHashTable
(
const
PLDHashTableOps
*
aOps
uint32_t
aEntrySize
uint32_t
aLength
)
:
mOps
(
aOps
)
mHashShift
(
HashShift
(
aEntrySize
aLength
)
)
mEntrySize
(
aEntrySize
)
mEntryCount
(
0
)
mRemovedCount
(
0
)
mEntryStore
(
)
#
ifdef
DEBUG
mChecker
(
)
#
endif
{
}
PLDHashTable
&
PLDHashTable
:
:
operator
=
(
PLDHashTable
&
&
aOther
)
{
if
(
this
=
=
&
aOther
)
{
return
*
this
;
}
this
-
>
~
PLDHashTable
(
)
;
MOZ_RELEASE_ASSERT
(
mOps
=
=
aOther
.
mOps
)
;
MOZ_RELEASE_ASSERT
(
mEntrySize
=
=
aOther
.
mEntrySize
)
;
mHashShift
=
Move
(
aOther
.
mHashShift
)
;
mEntryCount
=
Move
(
aOther
.
mEntryCount
)
;
mRemovedCount
=
Move
(
aOther
.
mRemovedCount
)
;
mEntryStore
=
Move
(
aOther
.
mEntryStore
)
;
#
ifdef
DEBUG
mChecker
=
Move
(
aOther
.
mChecker
)
;
#
endif
{
#
ifdef
DEBUG
AutoDestructorOp
op
(
mChecker
)
;
#
endif
aOther
.
mEntryStore
.
Set
(
nullptr
)
;
}
return
*
this
;
}
PLDHashNumber
PLDHashTable
:
:
Hash1
(
PLDHashNumber
aHash0
)
{
return
aHash0
>
>
mHashShift
;
}
void
PLDHashTable
:
:
Hash2
(
PLDHashNumber
aHash
uint32_t
&
aHash2Out
uint32_t
&
aSizeMaskOut
)
{
uint32_t
sizeLog2
=
kHashBits
-
mHashShift
;
aHash2Out
=
(
(
aHash
<
<
sizeLog2
)
>
>
mHashShift
)
|
1
;
aSizeMaskOut
=
(
PLDHashNumber
(
1
)
<
<
sizeLog2
)
-
1
;
}
bool
PLDHashTable
:
:
MatchEntryKeyhash
(
PLDHashEntryHdr
*
aEntry
PLDHashNumber
aKeyHash
)
{
return
(
aEntry
-
>
mKeyHash
&
~
kCollisionFlag
)
=
=
aKeyHash
;
}
PLDHashEntryHdr
*
PLDHashTable
:
:
AddressEntry
(
uint32_t
aIndex
)
{
return
reinterpret_cast
<
PLDHashEntryHdr
*
>
(
mEntryStore
.
Get
(
)
+
aIndex
*
mEntrySize
)
;
}
PLDHashTable
:
:
~
PLDHashTable
(
)
{
#
ifdef
DEBUG
AutoDestructorOp
op
(
mChecker
)
;
#
endif
if
(
!
mEntryStore
.
Get
(
)
)
{
return
;
}
char
*
entryAddr
=
mEntryStore
.
Get
(
)
;
char
*
entryLimit
=
entryAddr
+
Capacity
(
)
*
mEntrySize
;
while
(
entryAddr
<
entryLimit
)
{
PLDHashEntryHdr
*
entry
=
(
PLDHashEntryHdr
*
)
entryAddr
;
if
(
EntryIsLive
(
entry
)
)
{
mOps
-
>
clearEntry
(
this
entry
)
;
}
entryAddr
+
=
mEntrySize
;
}
}
void
PLDHashTable
:
:
ClearAndPrepareForLength
(
uint32_t
aLength
)
{
const
PLDHashTableOps
*
ops
=
mOps
;
uint32_t
entrySize
=
mEntrySize
;
this
-
>
~
PLDHashTable
(
)
;
new
(
KnownNotNull
this
)
PLDHashTable
(
ops
entrySize
aLength
)
;
}
void
PLDHashTable
:
:
Clear
(
)
{
ClearAndPrepareForLength
(
kDefaultInitialLength
)
;
}
template
<
PLDHashTable
:
:
SearchReason
Reason
>
PLDHashEntryHdr
*
NS_FASTCALL
PLDHashTable
:
:
SearchTable
(
const
void
*
aKey
PLDHashNumber
aKeyHash
)
{
MOZ_ASSERT
(
mEntryStore
.
Get
(
)
)
;
NS_ASSERTION
(
!
(
aKeyHash
&
kCollisionFlag
)
"
!
(
aKeyHash
&
kCollisionFlag
)
"
)
;
PLDHashNumber
hash1
=
Hash1
(
aKeyHash
)
;
PLDHashEntryHdr
*
entry
=
AddressEntry
(
hash1
)
;
if
(
EntryIsFree
(
entry
)
)
{
return
(
Reason
=
=
ForAdd
)
?
entry
:
nullptr
;
}
PLDHashMatchEntry
matchEntry
=
mOps
-
>
matchEntry
;
if
(
MatchEntryKeyhash
(
entry
aKeyHash
)
&
&
matchEntry
(
entry
aKey
)
)
{
return
entry
;
}
PLDHashNumber
hash2
;
uint32_t
sizeMask
;
Hash2
(
aKeyHash
hash2
sizeMask
)
;
PLDHashEntryHdr
*
firstRemoved
=
nullptr
;
for
(
;
;
)
{
if
(
Reason
=
=
ForAdd
&
&
!
firstRemoved
)
{
if
(
MOZ_UNLIKELY
(
EntryIsRemoved
(
entry
)
)
)
{
firstRemoved
=
entry
;
}
else
{
entry
-
>
mKeyHash
|
=
kCollisionFlag
;
}
}
hash1
-
=
hash2
;
hash1
&
=
sizeMask
;
entry
=
AddressEntry
(
hash1
)
;
if
(
EntryIsFree
(
entry
)
)
{
return
(
Reason
=
=
ForAdd
)
?
(
firstRemoved
?
firstRemoved
:
entry
)
:
nullptr
;
}
if
(
MatchEntryKeyhash
(
entry
aKeyHash
)
&
&
matchEntry
(
entry
aKey
)
)
{
return
entry
;
}
}
return
nullptr
;
}
MOZ_ALWAYS_INLINE
PLDHashEntryHdr
*
PLDHashTable
:
:
FindFreeEntry
(
PLDHashNumber
aKeyHash
)
{
MOZ_ASSERT
(
mEntryStore
.
Get
(
)
)
;
NS_ASSERTION
(
!
(
aKeyHash
&
kCollisionFlag
)
"
!
(
aKeyHash
&
kCollisionFlag
)
"
)
;
PLDHashNumber
hash1
=
Hash1
(
aKeyHash
)
;
PLDHashEntryHdr
*
entry
=
AddressEntry
(
hash1
)
;
if
(
EntryIsFree
(
entry
)
)
{
return
entry
;
}
PLDHashNumber
hash2
;
uint32_t
sizeMask
;
Hash2
(
aKeyHash
hash2
sizeMask
)
;
for
(
;
;
)
{
NS_ASSERTION
(
!
EntryIsRemoved
(
entry
)
"
!
EntryIsRemoved
(
entry
)
"
)
;
entry
-
>
mKeyHash
|
=
kCollisionFlag
;
hash1
-
=
hash2
;
hash1
&
=
sizeMask
;
entry
=
AddressEntry
(
hash1
)
;
if
(
EntryIsFree
(
entry
)
)
{
return
entry
;
}
}
}
bool
PLDHashTable
:
:
ChangeTable
(
int32_t
aDeltaLog2
)
{
MOZ_ASSERT
(
mEntryStore
.
Get
(
)
)
;
int32_t
oldLog2
=
kHashBits
-
mHashShift
;
int32_t
newLog2
=
oldLog2
+
aDeltaLog2
;
uint32_t
newCapacity
=
1u
<
<
newLog2
;
if
(
newCapacity
>
kMaxCapacity
)
{
return
false
;
}
uint32_t
nbytes
;
if
(
!
SizeOfEntryStore
(
newCapacity
mEntrySize
&
nbytes
)
)
{
return
false
;
}
char
*
newEntryStore
=
(
char
*
)
malloc
(
nbytes
)
;
if
(
!
newEntryStore
)
{
return
false
;
}
mHashShift
=
kHashBits
-
newLog2
;
mRemovedCount
=
0
;
memset
(
newEntryStore
0
nbytes
)
;
char
*
oldEntryStore
;
char
*
oldEntryAddr
;
oldEntryAddr
=
oldEntryStore
=
mEntryStore
.
Get
(
)
;
mEntryStore
.
Set
(
newEntryStore
)
;
PLDHashMoveEntry
moveEntry
=
mOps
-
>
moveEntry
;
uint32_t
oldCapacity
=
1u
<
<
oldLog2
;
for
(
uint32_t
i
=
0
;
i
<
oldCapacity
;
+
+
i
)
{
PLDHashEntryHdr
*
oldEntry
=
(
PLDHashEntryHdr
*
)
oldEntryAddr
;
if
(
EntryIsLive
(
oldEntry
)
)
{
oldEntry
-
>
mKeyHash
&
=
~
kCollisionFlag
;
PLDHashEntryHdr
*
newEntry
=
FindFreeEntry
(
oldEntry
-
>
mKeyHash
)
;
NS_ASSERTION
(
EntryIsFree
(
newEntry
)
"
EntryIsFree
(
newEntry
)
"
)
;
moveEntry
(
this
oldEntry
newEntry
)
;
newEntry
-
>
mKeyHash
=
oldEntry
-
>
mKeyHash
;
}
oldEntryAddr
+
=
mEntrySize
;
}
free
(
oldEntryStore
)
;
return
true
;
}
MOZ_ALWAYS_INLINE
PLDHashNumber
PLDHashTable
:
:
ComputeKeyHash
(
const
void
*
aKey
)
{
MOZ_ASSERT
(
mEntryStore
.
Get
(
)
)
;
PLDHashNumber
keyHash
=
mOps
-
>
hashKey
(
aKey
)
;
keyHash
*
=
kGoldenRatio
;
if
(
keyHash
<
2
)
{
keyHash
-
=
2
;
}
keyHash
&
=
~
kCollisionFlag
;
return
keyHash
;
}
PLDHashEntryHdr
*
PLDHashTable
:
:
Search
(
const
void
*
aKey
)
{
#
ifdef
DEBUG
AutoReadOp
op
(
mChecker
)
;
#
endif
PLDHashEntryHdr
*
entry
=
mEntryStore
.
Get
(
)
?
SearchTable
<
ForSearchOrRemove
>
(
aKey
ComputeKeyHash
(
aKey
)
)
:
nullptr
;
return
entry
;
}
PLDHashEntryHdr
*
PLDHashTable
:
:
Add
(
const
void
*
aKey
const
mozilla
:
:
fallible_t
&
)
{
#
ifdef
DEBUG
AutoWriteOp
op
(
mChecker
)
;
#
endif
if
(
!
mEntryStore
.
Get
(
)
)
{
uint32_t
nbytes
;
MOZ_RELEASE_ASSERT
(
SizeOfEntryStore
(
CapacityFromHashShift
(
)
mEntrySize
&
nbytes
)
)
;
mEntryStore
.
Set
(
(
char
*
)
malloc
(
nbytes
)
)
;
if
(
!
mEntryStore
.
Get
(
)
)
{
return
nullptr
;
}
memset
(
mEntryStore
.
Get
(
)
0
nbytes
)
;
}
uint32_t
capacity
=
Capacity
(
)
;
if
(
mEntryCount
+
mRemovedCount
>
=
MaxLoad
(
capacity
)
)
{
int
deltaLog2
;
if
(
mRemovedCount
>
=
capacity
>
>
2
)
{
deltaLog2
=
0
;
}
else
{
deltaLog2
=
1
;
}
if
(
!
ChangeTable
(
deltaLog2
)
&
&
mEntryCount
+
mRemovedCount
>
=
MaxLoadOnGrowthFailure
(
capacity
)
)
{
return
nullptr
;
}
}
PLDHashNumber
keyHash
=
ComputeKeyHash
(
aKey
)
;
PLDHashEntryHdr
*
entry
=
SearchTable
<
ForAdd
>
(
aKey
keyHash
)
;
if
(
!
EntryIsLive
(
entry
)
)
{
if
(
EntryIsRemoved
(
entry
)
)
{
mRemovedCount
-
-
;
keyHash
|
=
kCollisionFlag
;
}
if
(
mOps
-
>
initEntry
)
{
mOps
-
>
initEntry
(
entry
aKey
)
;
}
entry
-
>
mKeyHash
=
keyHash
;
mEntryCount
+
+
;
}
return
entry
;
}
PLDHashEntryHdr
*
PLDHashTable
:
:
Add
(
const
void
*
aKey
)
{
PLDHashEntryHdr
*
entry
=
Add
(
aKey
fallible
)
;
if
(
!
entry
)
{
if
(
!
mEntryStore
.
Get
(
)
)
{
uint32_t
nbytes
;
(
void
)
SizeOfEntryStore
(
CapacityFromHashShift
(
)
mEntrySize
&
nbytes
)
;
NS_ABORT_OOM
(
nbytes
)
;
}
else
{
NS_ABORT_OOM
(
2
*
EntrySize
(
)
*
EntryCount
(
)
)
;
}
}
return
entry
;
}
void
PLDHashTable
:
:
Remove
(
const
void
*
aKey
)
{
#
ifdef
DEBUG
AutoWriteOp
op
(
mChecker
)
;
#
endif
PLDHashEntryHdr
*
entry
=
mEntryStore
.
Get
(
)
?
SearchTable
<
ForSearchOrRemove
>
(
aKey
ComputeKeyHash
(
aKey
)
)
:
nullptr
;
if
(
entry
)
{
RawRemove
(
entry
)
;
ShrinkIfAppropriate
(
)
;
}
}
void
PLDHashTable
:
:
RemoveEntry
(
PLDHashEntryHdr
*
aEntry
)
{
#
ifdef
DEBUG
AutoWriteOp
op
(
mChecker
)
;
#
endif
RawRemove
(
aEntry
)
;
ShrinkIfAppropriate
(
)
;
}
void
PLDHashTable
:
:
RawRemove
(
PLDHashEntryHdr
*
aEntry
)
{
MOZ_ASSERT
(
mChecker
.
IsWritable
(
)
)
;
MOZ_ASSERT
(
mEntryStore
.
Get
(
)
)
;
MOZ_ASSERT
(
EntryIsLive
(
aEntry
)
"
EntryIsLive
(
aEntry
)
"
)
;
PLDHashNumber
keyHash
=
aEntry
-
>
mKeyHash
;
mOps
-
>
clearEntry
(
this
aEntry
)
;
if
(
keyHash
&
kCollisionFlag
)
{
MarkEntryRemoved
(
aEntry
)
;
mRemovedCount
+
+
;
}
else
{
MarkEntryFree
(
aEntry
)
;
}
mEntryCount
-
-
;
}
void
PLDHashTable
:
:
ShrinkIfAppropriate
(
)
{
uint32_t
capacity
=
Capacity
(
)
;
if
(
mRemovedCount
>
=
capacity
>
>
2
|
|
(
capacity
>
kMinCapacity
&
&
mEntryCount
<
=
MinLoad
(
capacity
)
)
)
{
uint32_t
log2
;
BestCapacity
(
mEntryCount
&
capacity
&
log2
)
;
int32_t
deltaLog2
=
log2
-
(
kHashBits
-
mHashShift
)
;
MOZ_ASSERT
(
deltaLog2
<
=
0
)
;
(
void
)
ChangeTable
(
deltaLog2
)
;
}
}
size_t
PLDHashTable
:
:
ShallowSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
#
ifdef
DEBUG
AutoReadOp
op
(
mChecker
)
;
#
endif
return
aMallocSizeOf
(
mEntryStore
.
Get
(
)
)
;
}
size_t
PLDHashTable
:
:
ShallowSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
PLDHashTable
:
:
Iterator
:
:
Iterator
(
Iterator
&
&
aOther
)
:
mTable
(
aOther
.
mTable
)
mStart
(
aOther
.
mStart
)
mLimit
(
aOther
.
mLimit
)
mCurrent
(
aOther
.
mCurrent
)
mNexts
(
aOther
.
mNexts
)
mNextsLimit
(
aOther
.
mNextsLimit
)
mHaveRemoved
(
aOther
.
mHaveRemoved
)
{
aOther
.
mTable
=
nullptr
;
aOther
.
mStart
=
nullptr
;
aOther
.
mLimit
=
nullptr
;
aOther
.
mCurrent
=
nullptr
;
aOther
.
mNexts
=
0
;
aOther
.
mNextsLimit
=
0
;
aOther
.
mHaveRemoved
=
false
;
}
PLDHashTable
:
:
Iterator
:
:
Iterator
(
PLDHashTable
*
aTable
)
:
mTable
(
aTable
)
mStart
(
mTable
-
>
mEntryStore
.
Get
(
)
)
mLimit
(
mTable
-
>
mEntryStore
.
Get
(
)
+
mTable
-
>
Capacity
(
)
*
mTable
-
>
mEntrySize
)
mCurrent
(
mTable
-
>
mEntryStore
.
Get
(
)
)
mNexts
(
0
)
mNextsLimit
(
mTable
-
>
EntryCount
(
)
)
mHaveRemoved
(
false
)
{
#
ifdef
DEBUG
mTable
-
>
mChecker
.
StartReadOp
(
)
;
#
endif
if
(
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
HashTableIteration
)
&
&
mTable
-
>
Capacity
(
)
>
0
)
{
mCurrent
+
=
ChaosMode
:
:
randomUint32LessThan
(
mTable
-
>
Capacity
(
)
)
*
mTable
-
>
mEntrySize
;
}
if
(
!
Done
(
)
)
{
while
(
IsOnNonLiveEntry
(
)
)
{
MoveToNextEntry
(
)
;
}
}
}
PLDHashTable
:
:
Iterator
:
:
~
Iterator
(
)
{
if
(
mTable
)
{
if
(
mHaveRemoved
)
{
mTable
-
>
ShrinkIfAppropriate
(
)
;
}
#
ifdef
DEBUG
mTable
-
>
mChecker
.
EndReadOp
(
)
;
#
endif
}
}
MOZ_ALWAYS_INLINE
bool
PLDHashTable
:
:
Iterator
:
:
IsOnNonLiveEntry
(
)
const
{
MOZ_ASSERT
(
!
Done
(
)
)
;
return
!
EntryIsLive
(
reinterpret_cast
<
PLDHashEntryHdr
*
>
(
mCurrent
)
)
;
}
MOZ_ALWAYS_INLINE
void
PLDHashTable
:
:
Iterator
:
:
MoveToNextEntry
(
)
{
mCurrent
+
=
mTable
-
>
mEntrySize
;
if
(
mCurrent
=
=
mLimit
)
{
mCurrent
=
mStart
;
}
}
void
PLDHashTable
:
:
Iterator
:
:
Next
(
)
{
MOZ_ASSERT
(
!
Done
(
)
)
;
mNexts
+
+
;
if
(
!
Done
(
)
)
{
do
{
MoveToNextEntry
(
)
;
}
while
(
IsOnNonLiveEntry
(
)
)
;
}
}
void
PLDHashTable
:
:
Iterator
:
:
Remove
(
)
{
mTable
-
>
RawRemove
(
Get
(
)
)
;
mHaveRemoved
=
true
;
}
#
ifdef
DEBUG
void
PLDHashTable
:
:
MarkImmutable
(
)
{
mChecker
.
SetNonWritable
(
)
;
}
#
endif
