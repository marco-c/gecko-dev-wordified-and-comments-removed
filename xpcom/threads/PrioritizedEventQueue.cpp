#
include
"
PrioritizedEventQueue
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_threads
.
h
"
#
include
"
mozilla
/
ipc
/
IdleSchedulerChild
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
InputEventStatistics
.
h
"
using
namespace
mozilla
;
PrioritizedEventQueue
:
:
PrioritizedEventQueue
(
already_AddRefed
<
nsIIdlePeriod
>
&
&
aIdlePeriod
)
:
mHighQueue
(
MakeUnique
<
EventQueue
>
(
EventQueuePriority
:
:
High
)
)
mInputQueue
(
MakeUnique
<
EventQueueSized
<
32
>
>
(
EventQueuePriority
:
:
Input
)
)
mMediumHighQueue
(
MakeUnique
<
EventQueue
>
(
EventQueuePriority
:
:
MediumHigh
)
)
mNormalQueue
(
MakeUnique
<
EventQueueSized
<
64
>
>
(
EventQueuePriority
:
:
Normal
)
)
mDeferredTimersQueue
(
MakeUnique
<
EventQueue
>
(
EventQueuePriority
:
:
DeferredTimers
)
)
mIdleQueue
(
MakeUnique
<
EventQueue
>
(
EventQueuePriority
:
:
Idle
)
)
mIdlePeriodState
(
std
:
:
move
(
aIdlePeriod
)
)
{
}
PrioritizedEventQueue
:
:
~
PrioritizedEventQueue
(
)
=
default
;
void
PrioritizedEventQueue
:
:
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventQueuePriority
aPriority
const
MutexAutoLock
&
aProofOfLock
mozilla
:
:
TimeDuration
*
aDelay
)
{
RefPtr
<
nsIRunnable
>
event
(
aEvent
)
;
EventQueuePriority
priority
=
aPriority
;
if
(
priority
=
=
EventQueuePriority
:
:
Input
&
&
mInputQueueState
=
=
STATE_DISABLED
)
{
priority
=
EventQueuePriority
:
:
Normal
;
}
else
if
(
priority
=
=
EventQueuePriority
:
:
MediumHigh
&
&
!
StaticPrefs
:
:
threads_medium_high_event_queue_enabled
(
)
)
{
priority
=
EventQueuePriority
:
:
Normal
;
}
switch
(
priority
)
{
case
EventQueuePriority
:
:
High
:
mHighQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
aDelay
)
;
break
;
case
EventQueuePriority
:
:
Input
:
mInputQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
aDelay
)
;
break
;
case
EventQueuePriority
:
:
MediumHigh
:
mMediumHighQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
aDelay
)
;
break
;
case
EventQueuePriority
:
:
Normal
:
mNormalQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
aDelay
)
;
break
;
case
EventQueuePriority
:
:
DeferredTimers
:
mDeferredTimersQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
aDelay
)
;
break
;
case
EventQueuePriority
:
:
Idle
:
mIdleQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
aDelay
)
;
break
;
case
EventQueuePriority
:
:
Count
:
MOZ_CRASH
(
"
EventQueuePriority
:
:
Count
isn
'
t
a
valid
priority
"
)
;
break
;
}
}
EventQueuePriority
PrioritizedEventQueue
:
:
SelectQueue
(
bool
aUpdateState
const
MutexAutoLock
&
aProofOfLock
)
{
size_t
inputCount
=
mInputQueue
-
>
Count
(
aProofOfLock
)
;
if
(
aUpdateState
&
&
mInputQueueState
=
=
STATE_ENABLED
&
&
mInputHandlingStartTime
.
IsNull
(
)
&
&
inputCount
>
0
)
{
mInputHandlingStartTime
=
InputEventStatistics
:
:
Get
(
)
.
GetInputHandlingStartTime
(
inputCount
)
;
}
EventQueuePriority
queue
;
bool
highPending
=
!
mHighQueue
-
>
IsEmpty
(
aProofOfLock
)
;
if
(
mProcessHighPriorityQueue
)
{
queue
=
EventQueuePriority
:
:
High
;
}
else
if
(
inputCount
>
0
&
&
(
mInputQueueState
=
=
STATE_FLUSHING
|
|
(
mInputQueueState
=
=
STATE_ENABLED
&
&
!
mInputHandlingStartTime
.
IsNull
(
)
&
&
TimeStamp
:
:
Now
(
)
>
mInputHandlingStartTime
)
)
)
{
queue
=
EventQueuePriority
:
:
Input
;
}
else
if
(
!
mMediumHighQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
MOZ_ASSERT
(
mInputQueueState
!
=
STATE_FLUSHING
"
Shouldn
'
t
consume
medium
high
event
when
flushing
input
events
"
)
;
queue
=
EventQueuePriority
:
:
MediumHigh
;
}
else
if
(
!
mNormalQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
MOZ_ASSERT
(
mInputQueueState
!
=
STATE_FLUSHING
"
Shouldn
'
t
consume
normal
event
when
flushing
input
events
"
)
;
queue
=
EventQueuePriority
:
:
Normal
;
}
else
if
(
highPending
)
{
queue
=
EventQueuePriority
:
:
High
;
}
else
if
(
inputCount
>
0
&
&
mInputQueueState
!
=
STATE_SUSPEND
)
{
MOZ_ASSERT
(
mInputQueueState
!
=
STATE_DISABLED
"
Shouldn
'
t
consume
input
events
when
the
input
queue
is
disabled
"
)
;
queue
=
EventQueuePriority
:
:
Input
;
}
else
if
(
!
mDeferredTimersQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
queue
=
EventQueuePriority
:
:
DeferredTimers
;
}
else
{
queue
=
EventQueuePriority
:
:
Idle
;
}
MOZ_ASSERT_IF
(
queue
=
=
EventQueuePriority
:
:
Input
mInputQueueState
!
=
STATE_DISABLED
&
&
mInputQueueState
!
=
STATE_SUSPEND
)
;
if
(
aUpdateState
)
{
mProcessHighPriorityQueue
=
highPending
;
}
return
queue
;
}
already_AddRefed
<
nsIRunnable
>
PrioritizedEventQueue
:
:
GetEvent
(
EventQueuePriority
*
aPriority
const
MutexAutoLock
&
aProofOfLock
TimeDuration
*
aHypotheticalInputEventDelay
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Who
is
managing
to
call
this
?
"
)
;
bool
ignored
;
return
GetEvent
(
aPriority
aProofOfLock
aHypotheticalInputEventDelay
&
ignored
)
;
}
already_AddRefed
<
nsIRunnable
>
PrioritizedEventQueue
:
:
GetEvent
(
EventQueuePriority
*
aPriority
const
MutexAutoLock
&
aProofOfLock
TimeDuration
*
aHypotheticalInputEventDelay
bool
*
aIsIdleEvent
)
{
EventQueuePriority
queue
=
SelectQueue
(
true
aProofOfLock
)
;
auto
guard
=
MakeScopeExit
(
[
&
]
{
mIdlePeriodState
.
ForgetPendingTaskGuarantee
(
)
;
if
(
queue
!
=
EventQueuePriority
:
:
Idle
&
&
queue
!
=
EventQueuePriority
:
:
DeferredTimers
)
{
mIdlePeriodState
.
FlagNotIdle
(
*
mMutex
)
;
}
}
)
;
if
(
aPriority
)
{
*
aPriority
=
queue
;
}
*
aIsIdleEvent
=
false
;
nsCOMPtr
<
nsIRunnable
>
event
;
switch
(
queue
)
{
default
:
MOZ_CRASH
(
)
;
break
;
case
EventQueuePriority
:
:
High
:
event
=
mHighQueue
-
>
GetEvent
(
aPriority
aProofOfLock
aHypotheticalInputEventDelay
)
;
MOZ_ASSERT
(
event
)
;
mInputHandlingStartTime
=
TimeStamp
(
)
;
mProcessHighPriorityQueue
=
false
;
break
;
case
EventQueuePriority
:
:
Input
:
event
=
mInputQueue
-
>
GetEvent
(
aPriority
aProofOfLock
aHypotheticalInputEventDelay
)
;
MOZ_ASSERT
(
event
)
;
break
;
case
EventQueuePriority
:
:
MediumHigh
:
event
=
mMediumHighQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
*
aHypotheticalInputEventDelay
=
TimeDuration
(
)
;
break
;
case
EventQueuePriority
:
:
Normal
:
event
=
mNormalQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
*
aHypotheticalInputEventDelay
=
TimeDuration
(
)
;
break
;
case
EventQueuePriority
:
:
Idle
:
case
EventQueuePriority
:
:
DeferredTimers
:
*
aHypotheticalInputEventDelay
=
TimeDuration
(
)
;
if
(
mIdleQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mDeferredTimersQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
mIdlePeriodState
.
RanOutOfTasks
(
*
mMutex
)
;
return
nullptr
;
}
TimeStamp
idleDeadline
=
mIdlePeriodState
.
GetDeadlineForIdleTask
(
*
mMutex
)
;
if
(
!
idleDeadline
)
{
return
nullptr
;
}
event
=
mDeferredTimersQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
if
(
!
event
)
{
event
=
mIdleQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
}
if
(
event
)
{
*
aIsIdleEvent
=
true
;
nsCOMPtr
<
nsIIdleRunnable
>
idleEvent
=
do_QueryInterface
(
event
)
;
if
(
idleEvent
)
{
idleEvent
-
>
SetDeadline
(
idleDeadline
)
;
}
}
break
;
}
if
(
!
event
)
{
*
aHypotheticalInputEventDelay
=
TimeDuration
(
)
;
}
return
event
.
forget
(
)
;
}
void
PrioritizedEventQueue
:
:
DidRunEvent
(
const
MutexAutoLock
&
aProofOfLock
)
{
if
(
IsEmpty
(
aProofOfLock
)
)
{
mIdlePeriodState
.
RanOutOfTasks
(
*
mMutex
)
;
}
}
bool
PrioritizedEventQueue
:
:
IsEmpty
(
const
MutexAutoLock
&
aProofOfLock
)
{
return
mHighQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mInputQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mMediumHighQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mNormalQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mDeferredTimersQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mIdleQueue
-
>
IsEmpty
(
aProofOfLock
)
;
}
bool
PrioritizedEventQueue
:
:
HasReadyEvent
(
const
MutexAutoLock
&
aProofOfLock
)
{
mIdlePeriodState
.
ForgetPendingTaskGuarantee
(
)
;
EventQueuePriority
queue
=
SelectQueue
(
false
aProofOfLock
)
;
if
(
queue
=
=
EventQueuePriority
:
:
High
)
{
return
mHighQueue
-
>
HasReadyEvent
(
aProofOfLock
)
;
}
else
if
(
queue
=
=
EventQueuePriority
:
:
Input
)
{
return
mInputQueue
-
>
HasReadyEvent
(
aProofOfLock
)
;
}
else
if
(
queue
=
=
EventQueuePriority
:
:
MediumHigh
)
{
return
mMediumHighQueue
-
>
HasReadyEvent
(
aProofOfLock
)
;
}
else
if
(
queue
=
=
EventQueuePriority
:
:
Normal
)
{
return
mNormalQueue
-
>
HasReadyEvent
(
aProofOfLock
)
;
}
MOZ_ASSERT
(
queue
=
=
EventQueuePriority
:
:
Idle
|
|
queue
=
=
EventQueuePriority
:
:
DeferredTimers
)
;
if
(
mDeferredTimersQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mIdleQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
return
false
;
}
TimeStamp
idleDeadline
=
mIdlePeriodState
.
PeekIdleDeadline
(
*
mMutex
)
;
if
(
idleDeadline
&
&
(
mDeferredTimersQueue
-
>
HasReadyEvent
(
aProofOfLock
)
|
|
mIdleQueue
-
>
HasReadyEvent
(
aProofOfLock
)
)
)
{
mIdlePeriodState
.
EnforcePendingTaskGuarantee
(
)
;
return
true
;
}
return
false
;
}
bool
PrioritizedEventQueue
:
:
HasPendingHighPriorityEvents
(
const
MutexAutoLock
&
aProofOfLock
)
{
return
!
mHighQueue
-
>
IsEmpty
(
aProofOfLock
)
;
}
size_t
PrioritizedEventQueue
:
:
Count
(
const
MutexAutoLock
&
aProofOfLock
)
const
{
MOZ_CRASH
(
"
unimplemented
"
)
;
}
void
PrioritizedEventQueue
:
:
EnableInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mInputQueueState
=
=
STATE_DISABLED
)
;
mInputQueueState
=
STATE_ENABLED
;
mInputHandlingStartTime
=
TimeStamp
(
)
;
}
void
PrioritizedEventQueue
:
:
FlushInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mInputQueueState
=
=
STATE_ENABLED
|
|
mInputQueueState
=
=
STATE_SUSPEND
)
;
mInputQueueState
=
mInputQueueState
=
=
STATE_ENABLED
?
STATE_FLUSHING
:
STATE_SUSPEND
;
}
void
PrioritizedEventQueue
:
:
SuspendInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mInputQueueState
=
=
STATE_ENABLED
|
|
mInputQueueState
=
=
STATE_FLUSHING
)
;
mInputQueueState
=
STATE_SUSPEND
;
}
void
PrioritizedEventQueue
:
:
ResumeInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mInputQueueState
=
=
STATE_SUSPEND
)
;
mInputQueueState
=
STATE_ENABLED
;
}
bool
PrioritizedEventQueue
:
:
HasIdleRunnables
(
const
MutexAutoLock
&
aProofOfLock
)
{
return
!
mIdleQueue
-
>
IsEmpty
(
aProofOfLock
)
|
|
!
mDeferredTimersQueue
-
>
IsEmpty
(
aProofOfLock
)
;
}
