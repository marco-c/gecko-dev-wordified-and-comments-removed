#
include
"
PrioritizedEventQueue
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
using
namespace
mozilla
;
template
<
class
InnerQueueT
>
PrioritizedEventQueue
<
InnerQueueT
>
:
:
PrioritizedEventQueue
(
UniquePtr
<
InnerQueueT
>
aHighQueue
UniquePtr
<
InnerQueueT
>
aInputQueue
UniquePtr
<
InnerQueueT
>
aNormalQueue
UniquePtr
<
InnerQueueT
>
aIdleQueue
already_AddRefed
<
nsIIdlePeriod
>
aIdlePeriod
)
:
mHighQueue
(
Move
(
aHighQueue
)
)
mInputQueue
(
Move
(
aInputQueue
)
)
mNormalQueue
(
Move
(
aNormalQueue
)
)
mIdleQueue
(
Move
(
aIdleQueue
)
)
mIdlePeriod
(
aIdlePeriod
)
{
static_assert
(
IsBaseOf
<
AbstractEventQueue
InnerQueueT
>
:
:
value
"
InnerQueueT
must
be
an
AbstractEventQueue
subclass
"
)
;
}
template
<
class
InnerQueueT
>
void
PrioritizedEventQueue
<
InnerQueueT
>
:
:
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventPriority
aPriority
const
MutexAutoLock
&
aProofOfLock
)
{
RefPtr
<
nsIRunnable
>
event
(
aEvent
)
;
EventPriority
priority
=
aPriority
;
if
(
nsCOMPtr
<
nsIRunnablePriority
>
runnablePrio
=
do_QueryInterface
(
event
)
)
{
uint32_t
prio
=
nsIRunnablePriority
:
:
PRIORITY_NORMAL
;
runnablePrio
-
>
GetPriority
(
&
prio
)
;
if
(
prio
=
=
nsIRunnablePriority
:
:
PRIORITY_HIGH
)
{
priority
=
EventPriority
:
:
High
;
}
else
if
(
prio
=
=
nsIRunnablePriority
:
:
PRIORITY_INPUT
)
{
priority
=
EventPriority
:
:
Input
;
}
}
if
(
priority
=
=
EventPriority
:
:
Input
&
&
!
mWriteToInputQueue
)
{
priority
=
EventPriority
:
:
Normal
;
}
switch
(
priority
)
{
case
EventPriority
:
:
High
:
mHighQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventPriority
:
:
Input
:
mInputQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventPriority
:
:
Normal
:
mNormalQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventPriority
:
:
Idle
:
mIdleQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
}
}
template
<
class
InnerQueueT
>
TimeStamp
PrioritizedEventQueue
<
InnerQueueT
>
:
:
GetIdleDeadline
(
)
{
if
(
gXPCOMThreadsShutDown
|
|
nsThreadManager
:
:
get
(
)
.
GetCurrentThread
(
)
-
>
ShuttingDown
(
)
)
{
return
TimeStamp
:
:
Now
(
)
;
}
TimeStamp
idleDeadline
;
{
MutexAutoUnlock
unlock
(
*
mMutex
)
;
mIdlePeriod
-
>
GetIdlePeriodHint
(
&
idleDeadline
)
;
}
if
(
!
mHasPendingEventsPromisedIdleEvent
&
&
(
!
idleDeadline
|
|
idleDeadline
<
TimeStamp
:
:
Now
(
)
)
)
{
return
TimeStamp
(
)
;
}
if
(
mHasPendingEventsPromisedIdleEvent
&
&
!
idleDeadline
)
{
return
TimeStamp
:
:
Now
(
)
;
}
return
idleDeadline
;
}
template
<
class
InnerQueueT
>
already_AddRefed
<
nsIRunnable
>
PrioritizedEventQueue
<
InnerQueueT
>
:
:
GetEvent
(
EventPriority
*
aPriority
const
MutexAutoLock
&
aProofOfLock
)
{
MakeScopeExit
(
[
&
]
{
mHasPendingEventsPromisedIdleEvent
=
false
;
}
)
;
#
ifndef
RELEASE_OR_BETA
*
mNextIdleDeadline
=
TimeStamp
(
)
;
#
endif
bool
highPending
=
mHighQueue
-
>
HasPendingEvent
(
aProofOfLock
)
;
bool
normalPending
=
mNormalQueue
-
>
HasPendingEvent
(
aProofOfLock
)
;
size_t
inputCount
=
mInputQueue
-
>
Count
(
aProofOfLock
)
;
if
(
mReadFromInputQueue
&
&
mInputHandlingStartTime
.
IsNull
(
)
&
&
inputCount
>
0
)
{
mInputHandlingStartTime
=
InputEventStatistics
:
:
Get
(
)
.
GetInputHandlingStartTime
(
inputCount
)
;
}
EventPriority
queue
;
if
(
mProcessHighPriorityQueue
)
{
queue
=
EventPriority
:
:
High
;
}
else
if
(
inputCount
>
0
&
&
TimeStamp
:
:
Now
(
)
>
mInputHandlingStartTime
&
&
mReadFromInputQueue
)
{
queue
=
EventPriority
:
:
Input
;
}
else
if
(
normalPending
)
{
queue
=
EventPriority
:
:
Normal
;
}
else
if
(
highPending
)
{
queue
=
EventPriority
:
:
High
;
}
else
if
(
inputCount
>
0
&
&
mReadFromInputQueue
)
{
queue
=
EventPriority
:
:
Input
;
}
else
{
queue
=
EventPriority
:
:
Idle
;
}
MOZ_ASSERT_IF
(
queue
=
=
EventPriority
:
:
Input
mReadFromInputQueue
)
;
mProcessHighPriorityQueue
=
highPending
;
if
(
aPriority
)
{
*
aPriority
=
queue
;
}
if
(
queue
=
=
EventPriority
:
:
High
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mHighQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
MOZ_ASSERT
(
event
)
;
mInputHandlingStartTime
=
TimeStamp
(
)
;
mProcessHighPriorityQueue
=
false
;
return
event
.
forget
(
)
;
}
if
(
queue
=
=
EventPriority
:
:
Input
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mInputQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
MOZ_ASSERT
(
event
)
;
return
event
.
forget
(
)
;
}
if
(
queue
=
=
EventPriority
:
:
Normal
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mNormalQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
return
event
.
forget
(
)
;
}
MOZ_ASSERT
(
queue
=
=
EventPriority
:
:
Idle
)
;
if
(
!
mIdleQueue
-
>
HasPendingEvent
(
aProofOfLock
)
)
{
MOZ_ASSERT
(
!
mHasPendingEventsPromisedIdleEvent
)
;
return
nullptr
;
}
TimeStamp
idleDeadline
=
GetIdleDeadline
(
)
;
if
(
!
idleDeadline
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
mIdleQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
if
(
event
)
{
nsCOMPtr
<
nsIIdleRunnable
>
idleEvent
=
do_QueryInterface
(
event
)
;
if
(
idleEvent
)
{
idleEvent
-
>
SetDeadline
(
idleDeadline
)
;
}
#
ifndef
RELEASE_OR_BETA
*
mNextIdleDeadline
=
idleDeadline
;
#
endif
}
return
event
.
forget
(
)
;
}
template
<
class
InnerQueueT
>
bool
PrioritizedEventQueue
<
InnerQueueT
>
:
:
HasPendingEvent
(
const
MutexAutoLock
&
aProofOfLock
)
{
mHasPendingEventsPromisedIdleEvent
=
false
;
if
(
mHighQueue
-
>
HasPendingEvent
(
aProofOfLock
)
|
|
mInputQueue
-
>
HasPendingEvent
(
aProofOfLock
)
|
|
mNormalQueue
-
>
HasPendingEvent
(
aProofOfLock
)
)
{
return
true
;
}
bool
hasPendingIdleEvent
=
false
;
TimeStamp
idleDeadline
=
GetIdleDeadline
(
)
;
if
(
idleDeadline
)
{
hasPendingIdleEvent
=
mIdleQueue
-
>
HasPendingEvent
(
aProofOfLock
)
;
mHasPendingEventsPromisedIdleEvent
=
hasPendingIdleEvent
;
}
return
hasPendingIdleEvent
;
}
template
<
class
InnerQueueT
>
size_t
PrioritizedEventQueue
<
InnerQueueT
>
:
:
Count
(
const
MutexAutoLock
&
aProofOfLock
)
const
{
MOZ_CRASH
(
"
unimplemented
"
)
;
}
template
<
class
InnerQueueT
>
class
PrioritizedEventQueue
<
InnerQueueT
>
:
:
EnablePrioritizationRunnable
final
:
public
mozilla
:
:
Runnable
{
public
:
explicit
EnablePrioritizationRunnable
(
PrioritizedEventQueue
<
InnerQueueT
>
*
aQueue
)
:
Runnable
(
"
EnablePrioritizationRunnable
"
)
mQueue
(
aQueue
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mQueue
-
>
mWriteToInputQueue
)
;
MOZ_ASSERT
(
!
mQueue
-
>
mReadFromInputQueue
)
;
mQueue
-
>
mReadFromInputQueue
=
true
;
return
NS_OK
;
}
private
:
PrioritizedEventQueue
<
InnerQueueT
>
*
mQueue
;
}
;
template
<
class
InnerQueueT
>
void
PrioritizedEventQueue
<
InnerQueueT
>
:
:
EnableInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
!
mWriteToInputQueue
)
;
MOZ_ASSERT
(
!
mReadFromInputQueue
)
;
mWriteToInputQueue
=
true
;
mInputHandlingStartTime
=
TimeStamp
(
)
;
RefPtr
<
EnablePrioritizationRunnable
>
runnable
=
new
EnablePrioritizationRunnable
(
this
)
;
PutEvent
(
runnable
.
forget
(
)
EventPriority
:
:
Normal
aProofOfLock
)
;
}
namespace
mozilla
{
template
class
PrioritizedEventQueue
<
EventQueue
>
;
}
