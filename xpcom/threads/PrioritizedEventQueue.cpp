#
include
"
PrioritizedEventQueue
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_idle_period
.
h
"
#
include
"
mozilla
/
StaticPrefs_threads
.
h
"
#
include
"
mozilla
/
ipc
/
IdleSchedulerChild
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
InputEventStatistics
.
h
"
using
namespace
mozilla
;
static
uint64_t
sIdleRequestCounter
=
0
;
PrioritizedEventQueue
:
:
PrioritizedEventQueue
(
already_AddRefed
<
nsIIdlePeriod
>
aIdlePeriod
)
:
mHighQueue
(
MakeUnique
<
EventQueue
>
(
EventQueuePriority
:
:
High
)
)
mInputQueue
(
MakeUnique
<
EventQueue
>
(
EventQueuePriority
:
:
Input
)
)
mMediumHighQueue
(
MakeUnique
<
EventQueue
>
(
EventQueuePriority
:
:
MediumHigh
)
)
mNormalQueue
(
MakeUnique
<
EventQueue
>
(
EventQueuePriority
:
:
Normal
)
)
mDeferredTimersQueue
(
MakeUnique
<
EventQueue
>
(
EventQueuePriority
:
:
DeferredTimers
)
)
mIdleQueue
(
MakeUnique
<
EventQueue
>
(
EventQueuePriority
:
:
Idle
)
)
mIdlePeriod
(
aIdlePeriod
)
{
}
PrioritizedEventQueue
:
:
~
PrioritizedEventQueue
(
)
{
if
(
mIdleScheduler
)
{
mIdleScheduler
-
>
Disconnect
(
)
;
}
}
void
PrioritizedEventQueue
:
:
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventQueuePriority
aPriority
const
MutexAutoLock
&
aProofOfLock
)
{
RefPtr
<
nsIRunnable
>
event
(
aEvent
)
;
EventQueuePriority
priority
=
aPriority
;
if
(
priority
=
=
EventQueuePriority
:
:
Input
&
&
mInputQueueState
=
=
STATE_DISABLED
)
{
priority
=
EventQueuePriority
:
:
Normal
;
}
else
if
(
priority
=
=
EventQueuePriority
:
:
MediumHigh
&
&
!
StaticPrefs
:
:
threads_medium_high_event_queue_enabled
(
)
)
{
priority
=
EventQueuePriority
:
:
Normal
;
}
switch
(
priority
)
{
case
EventQueuePriority
:
:
High
:
mHighQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventQueuePriority
:
:
Input
:
mInputQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventQueuePriority
:
:
MediumHigh
:
mMediumHighQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventQueuePriority
:
:
Normal
:
mNormalQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventQueuePriority
:
:
DeferredTimers
:
mDeferredTimersQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventQueuePriority
:
:
Idle
:
mIdleQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventQueuePriority
:
:
Count
:
MOZ_CRASH
(
"
EventQueuePriority
:
:
Count
isn
'
t
a
valid
priority
"
)
;
break
;
}
}
TimeStamp
PrioritizedEventQueue
:
:
GetLocalIdleDeadline
(
bool
&
aShuttingDown
)
{
if
(
gXPCOMThreadsShutDown
|
|
nsThreadManager
:
:
get
(
)
.
GetCurrentThread
(
)
-
>
ShuttingDown
(
)
)
{
aShuttingDown
=
true
;
return
TimeStamp
:
:
Now
(
)
;
}
aShuttingDown
=
false
;
TimeStamp
idleDeadline
;
{
MutexAutoUnlock
unlock
(
*
mMutex
)
;
mIdlePeriod
-
>
GetIdlePeriodHint
(
&
idleDeadline
)
;
}
if
(
!
mHasPendingEventsPromisedIdleEvent
&
&
(
!
idleDeadline
|
|
idleDeadline
<
TimeStamp
:
:
Now
(
)
)
)
{
return
TimeStamp
(
)
;
}
if
(
mHasPendingEventsPromisedIdleEvent
&
&
!
idleDeadline
)
{
return
TimeStamp
:
:
Now
(
)
;
}
return
idleDeadline
;
}
EventQueuePriority
PrioritizedEventQueue
:
:
SelectQueue
(
bool
aUpdateState
const
MutexAutoLock
&
aProofOfLock
)
{
size_t
inputCount
=
mInputQueue
-
>
Count
(
aProofOfLock
)
;
if
(
aUpdateState
&
&
mInputQueueState
=
=
STATE_ENABLED
&
&
mInputHandlingStartTime
.
IsNull
(
)
&
&
inputCount
>
0
)
{
mInputHandlingStartTime
=
InputEventStatistics
:
:
Get
(
)
.
GetInputHandlingStartTime
(
inputCount
)
;
}
EventQueuePriority
queue
;
bool
highPending
=
!
mHighQueue
-
>
IsEmpty
(
aProofOfLock
)
;
if
(
mProcessHighPriorityQueue
)
{
queue
=
EventQueuePriority
:
:
High
;
}
else
if
(
inputCount
>
0
&
&
(
mInputQueueState
=
=
STATE_FLUSHING
|
|
(
mInputQueueState
=
=
STATE_ENABLED
&
&
!
mInputHandlingStartTime
.
IsNull
(
)
&
&
TimeStamp
:
:
Now
(
)
>
mInputHandlingStartTime
)
)
)
{
queue
=
EventQueuePriority
:
:
Input
;
}
else
if
(
!
mMediumHighQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
MOZ_ASSERT
(
mInputQueueState
!
=
STATE_FLUSHING
"
Shouldn
'
t
consume
medium
high
event
when
flushing
input
events
"
)
;
queue
=
EventQueuePriority
:
:
MediumHigh
;
}
else
if
(
!
mNormalQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
MOZ_ASSERT
(
mInputQueueState
!
=
STATE_FLUSHING
"
Shouldn
'
t
consume
normal
event
when
flushing
input
events
"
)
;
queue
=
EventQueuePriority
:
:
Normal
;
}
else
if
(
highPending
)
{
queue
=
EventQueuePriority
:
:
High
;
}
else
if
(
inputCount
>
0
&
&
mInputQueueState
!
=
STATE_SUSPEND
)
{
MOZ_ASSERT
(
mInputQueueState
!
=
STATE_DISABLED
"
Shouldn
'
t
consume
input
events
when
the
input
queue
is
disabled
"
)
;
queue
=
EventQueuePriority
:
:
Input
;
}
else
if
(
!
mDeferredTimersQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
queue
=
EventQueuePriority
:
:
DeferredTimers
;
}
else
{
queue
=
EventQueuePriority
:
:
Idle
;
}
MOZ_ASSERT_IF
(
queue
=
=
EventQueuePriority
:
:
Input
mInputQueueState
!
=
STATE_DISABLED
&
&
mInputQueueState
!
=
STATE_SUSPEND
)
;
if
(
aUpdateState
)
{
mProcessHighPriorityQueue
=
highPending
;
}
return
queue
;
}
already_AddRefed
<
nsIRunnable
>
PrioritizedEventQueue
:
:
GetEvent
(
EventQueuePriority
*
aPriority
const
MutexAutoLock
&
aProofOfLock
)
{
#
ifndef
RELEASE_OR_BETA
*
mNextIdleDeadline
=
TimeStamp
(
)
;
#
endif
EventQueuePriority
queue
=
SelectQueue
(
true
aProofOfLock
)
;
auto
guard
=
MakeScopeExit
(
[
&
]
{
mHasPendingEventsPromisedIdleEvent
=
false
;
if
(
queue
!
=
EventQueuePriority
:
:
Idle
&
&
queue
!
=
EventQueuePriority
:
:
DeferredTimers
)
{
EnsureIsActive
(
)
;
if
(
mIdleToken
&
&
mIdleToken
<
TimeStamp
:
:
Now
(
)
)
{
ClearIdleToken
(
)
;
}
}
}
)
;
if
(
aPriority
)
{
*
aPriority
=
queue
;
}
if
(
queue
=
=
EventQueuePriority
:
:
High
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mHighQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
MOZ_ASSERT
(
event
)
;
mInputHandlingStartTime
=
TimeStamp
(
)
;
mProcessHighPriorityQueue
=
false
;
return
event
.
forget
(
)
;
}
if
(
queue
=
=
EventQueuePriority
:
:
Input
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mInputQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
MOZ_ASSERT
(
event
)
;
return
event
.
forget
(
)
;
}
if
(
queue
=
=
EventQueuePriority
:
:
MediumHigh
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mMediumHighQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
return
event
.
forget
(
)
;
}
if
(
queue
=
=
EventQueuePriority
:
:
Normal
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mNormalQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
return
event
.
forget
(
)
;
}
MOZ_ASSERT
(
queue
=
=
EventQueuePriority
:
:
Idle
|
|
queue
=
=
EventQueuePriority
:
:
DeferredTimers
)
;
if
(
mIdleQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mDeferredTimersQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
MOZ_ASSERT
(
!
mHasPendingEventsPromisedIdleEvent
)
;
EnsureIsPaused
(
)
;
ClearIdleToken
(
)
;
return
nullptr
;
}
bool
shuttingDown
;
TimeStamp
localIdleDeadline
=
GetLocalIdleDeadline
(
shuttingDown
)
;
if
(
!
localIdleDeadline
)
{
EnsureIsPaused
(
)
;
ClearIdleToken
(
)
;
return
nullptr
;
}
TimeStamp
idleDeadline
=
mHasPendingEventsPromisedIdleEvent
|
|
shuttingDown
?
localIdleDeadline
:
GetIdleToken
(
localIdleDeadline
)
;
if
(
!
idleDeadline
)
{
EnsureIsPaused
(
)
;
MutexAutoUnlock
unlock
(
*
mMutex
)
;
RequestIdleToken
(
localIdleDeadline
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
mDeferredTimersQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
if
(
!
event
)
{
event
=
mIdleQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
}
if
(
event
)
{
nsCOMPtr
<
nsIIdleRunnable
>
idleEvent
=
do_QueryInterface
(
event
)
;
if
(
idleEvent
)
{
idleEvent
-
>
SetDeadline
(
idleDeadline
)
;
}
#
ifndef
RELEASE_OR_BETA
*
mNextIdleDeadline
=
idleDeadline
;
#
endif
}
EnsureIsActive
(
)
;
return
event
.
forget
(
)
;
}
void
PrioritizedEventQueue
:
:
DidRunEvent
(
const
MutexAutoLock
&
aProofOfLock
)
{
if
(
IsEmpty
(
aProofOfLock
)
)
{
if
(
IsActive
(
)
)
{
SetPaused
(
)
;
}
ClearIdleToken
(
)
;
}
}
bool
PrioritizedEventQueue
:
:
IsEmpty
(
const
MutexAutoLock
&
aProofOfLock
)
{
return
mHighQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mInputQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mMediumHighQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mNormalQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mDeferredTimersQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mIdleQueue
-
>
IsEmpty
(
aProofOfLock
)
;
}
bool
PrioritizedEventQueue
:
:
HasReadyEvent
(
const
MutexAutoLock
&
aProofOfLock
)
{
mHasPendingEventsPromisedIdleEvent
=
false
;
EventQueuePriority
queue
=
SelectQueue
(
false
aProofOfLock
)
;
if
(
queue
=
=
EventQueuePriority
:
:
High
)
{
return
mHighQueue
-
>
HasReadyEvent
(
aProofOfLock
)
;
}
else
if
(
queue
=
=
EventQueuePriority
:
:
Input
)
{
return
mInputQueue
-
>
HasReadyEvent
(
aProofOfLock
)
;
}
else
if
(
queue
=
=
EventQueuePriority
:
:
MediumHigh
)
{
return
mMediumHighQueue
-
>
HasReadyEvent
(
aProofOfLock
)
;
}
else
if
(
queue
=
=
EventQueuePriority
:
:
Normal
)
{
return
mNormalQueue
-
>
HasReadyEvent
(
aProofOfLock
)
;
}
MOZ_ASSERT
(
queue
=
=
EventQueuePriority
:
:
Idle
|
|
queue
=
=
EventQueuePriority
:
:
DeferredTimers
)
;
if
(
mDeferredTimersQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mIdleQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
return
false
;
}
bool
shuttingDown
;
TimeStamp
localIdleDeadline
=
GetLocalIdleDeadline
(
shuttingDown
)
;
if
(
localIdleDeadline
)
{
TimeStamp
idleDeadline
=
mHasPendingEventsPromisedIdleEvent
|
|
shuttingDown
?
localIdleDeadline
:
GetIdleToken
(
localIdleDeadline
)
;
if
(
idleDeadline
&
&
(
mDeferredTimersQueue
-
>
HasReadyEvent
(
aProofOfLock
)
|
|
mIdleQueue
-
>
HasReadyEvent
(
aProofOfLock
)
)
)
{
mHasPendingEventsPromisedIdleEvent
=
true
;
return
true
;
}
}
return
false
;
}
bool
PrioritizedEventQueue
:
:
HasPendingHighPriorityEvents
(
const
MutexAutoLock
&
aProofOfLock
)
{
return
!
mHighQueue
-
>
IsEmpty
(
aProofOfLock
)
;
}
size_t
PrioritizedEventQueue
:
:
Count
(
const
MutexAutoLock
&
aProofOfLock
)
const
{
MOZ_CRASH
(
"
unimplemented
"
)
;
}
void
PrioritizedEventQueue
:
:
EnableInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mInputQueueState
=
=
STATE_DISABLED
)
;
mInputQueueState
=
STATE_ENABLED
;
mInputHandlingStartTime
=
TimeStamp
(
)
;
}
void
PrioritizedEventQueue
:
:
FlushInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mInputQueueState
=
=
STATE_ENABLED
|
|
mInputQueueState
=
=
STATE_SUSPEND
)
;
mInputQueueState
=
mInputQueueState
=
=
STATE_ENABLED
?
STATE_FLUSHING
:
STATE_SUSPEND
;
}
void
PrioritizedEventQueue
:
:
SuspendInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mInputQueueState
=
=
STATE_ENABLED
|
|
mInputQueueState
=
=
STATE_FLUSHING
)
;
mInputQueueState
=
STATE_SUSPEND
;
}
void
PrioritizedEventQueue
:
:
ResumeInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mInputQueueState
=
=
STATE_SUSPEND
)
;
mInputQueueState
=
STATE_ENABLED
;
}
mozilla
:
:
TimeStamp
PrioritizedEventQueue
:
:
GetIdleToken
(
TimeStamp
aLocalIdlePeriodHint
)
{
if
(
XRE_IsParentProcess
(
)
)
{
return
aLocalIdlePeriodHint
;
}
if
(
mIdleToken
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
mIdleToken
<
now
)
{
ClearIdleToken
(
)
;
return
mIdleToken
;
}
return
mIdleToken
<
aLocalIdlePeriodHint
?
mIdleToken
:
aLocalIdlePeriodHint
;
}
return
TimeStamp
(
)
;
}
void
PrioritizedEventQueue
:
:
RequestIdleToken
(
TimeStamp
aLocalIdlePeriodHint
)
{
MOZ_ASSERT
(
!
mActive
)
;
if
(
!
mIdleSchedulerInitialized
)
{
mIdleSchedulerInitialized
=
true
;
if
(
StaticPrefs
:
:
idle_period_cross_process_scheduling
(
)
&
&
XRE_IsContentProcess
(
)
&
&
NS_IsMainThread
(
)
&
&
!
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
mIdleScheduler
=
ipc
:
:
IdleSchedulerChild
:
:
GetMainThreadIdleScheduler
(
)
;
if
(
mIdleScheduler
)
{
mIdleScheduler
-
>
Init
(
this
)
;
}
}
}
if
(
mIdleScheduler
&
&
!
mIdleRequestId
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
aLocalIdlePeriodHint
<
=
now
)
{
return
;
}
mIdleRequestId
=
+
+
sIdleRequestCounter
;
mIdleScheduler
-
>
SendRequestIdleTime
(
mIdleRequestId
aLocalIdlePeriodHint
-
now
)
;
}
}
void
PrioritizedEventQueue
:
:
SetIdleToken
(
uint64_t
aId
TimeDuration
aDuration
)
{
if
(
mIdleRequestId
=
=
aId
)
{
mIdleToken
=
TimeStamp
:
:
Now
(
)
+
aDuration
;
}
}
void
PrioritizedEventQueue
:
:
SetActive
(
)
{
MOZ_ASSERT
(
!
mActive
)
;
if
(
mIdleScheduler
)
{
mIdleScheduler
-
>
SetActive
(
)
;
}
mActive
=
true
;
}
void
PrioritizedEventQueue
:
:
SetPaused
(
)
{
MOZ_ASSERT
(
mActive
)
;
if
(
mIdleScheduler
&
&
mIdleScheduler
-
>
SetPaused
(
)
)
{
MutexAutoUnlock
unlock
(
*
mMutex
)
;
mIdleScheduler
-
>
SendSchedule
(
)
;
}
mActive
=
false
;
}
void
PrioritizedEventQueue
:
:
ClearIdleToken
(
)
{
if
(
mIdleRequestId
)
{
if
(
mIdleScheduler
)
{
MutexAutoUnlock
unlock
(
*
mMutex
)
;
mIdleScheduler
-
>
SendIdleTimeUsed
(
mIdleRequestId
)
;
}
mIdleRequestId
=
0
;
mIdleToken
=
TimeStamp
(
)
;
}
}
