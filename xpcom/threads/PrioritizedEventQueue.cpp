#
include
"
PrioritizedEventQueue
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
InputEventStatistics
.
h
"
using
namespace
mozilla
;
template
<
class
InnerQueueT
>
PrioritizedEventQueue
<
InnerQueueT
>
:
:
PrioritizedEventQueue
(
UniquePtr
<
InnerQueueT
>
aHighQueue
UniquePtr
<
InnerQueueT
>
aInputQueue
UniquePtr
<
InnerQueueT
>
aMediumHighQueue
UniquePtr
<
InnerQueueT
>
aNormalQueue
UniquePtr
<
InnerQueueT
>
aDeferredTimersQueue
UniquePtr
<
InnerQueueT
>
aIdleQueue
already_AddRefed
<
nsIIdlePeriod
>
aIdlePeriod
)
:
mHighQueue
(
std
:
:
move
(
aHighQueue
)
)
mInputQueue
(
std
:
:
move
(
aInputQueue
)
)
mMediumHighQueue
(
std
:
:
move
(
aMediumHighQueue
)
)
mNormalQueue
(
std
:
:
move
(
aNormalQueue
)
)
mDeferredTimersQueue
(
std
:
:
move
(
aDeferredTimersQueue
)
)
mIdleQueue
(
std
:
:
move
(
aIdleQueue
)
)
mIdlePeriod
(
aIdlePeriod
)
{
static_assert
(
IsBaseOf
<
AbstractEventQueue
InnerQueueT
>
:
:
value
"
InnerQueueT
must
be
an
AbstractEventQueue
subclass
"
)
;
}
template
<
class
InnerQueueT
>
void
PrioritizedEventQueue
<
InnerQueueT
>
:
:
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventQueuePriority
aPriority
const
MutexAutoLock
&
aProofOfLock
)
{
RefPtr
<
nsIRunnable
>
event
(
aEvent
)
;
EventQueuePriority
priority
=
aPriority
;
if
(
priority
=
=
EventQueuePriority
:
:
Input
&
&
mInputQueueState
=
=
STATE_DISABLED
)
{
priority
=
EventQueuePriority
:
:
Normal
;
}
else
if
(
priority
=
=
EventQueuePriority
:
:
MediumHigh
&
&
!
StaticPrefs
:
:
medium_high_event_queue_enabled
(
)
)
{
priority
=
EventQueuePriority
:
:
Normal
;
}
switch
(
priority
)
{
case
EventQueuePriority
:
:
High
:
mHighQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventQueuePriority
:
:
Input
:
mInputQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventQueuePriority
:
:
MediumHigh
:
mMediumHighQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventQueuePriority
:
:
Normal
:
mNormalQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventQueuePriority
:
:
DeferredTimers
:
mDeferredTimersQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventQueuePriority
:
:
Idle
:
mIdleQueue
-
>
PutEvent
(
event
.
forget
(
)
priority
aProofOfLock
)
;
break
;
case
EventQueuePriority
:
:
Count
:
MOZ_CRASH
(
"
EventQueuePriority
:
:
Count
isn
'
t
a
valid
priority
"
)
;
break
;
}
}
template
<
class
InnerQueueT
>
TimeStamp
PrioritizedEventQueue
<
InnerQueueT
>
:
:
GetIdleDeadline
(
)
{
if
(
gXPCOMThreadsShutDown
|
|
nsThreadManager
:
:
get
(
)
.
GetCurrentThread
(
)
-
>
ShuttingDown
(
)
)
{
return
TimeStamp
:
:
Now
(
)
;
}
TimeStamp
idleDeadline
;
{
MutexAutoUnlock
unlock
(
*
mMutex
)
;
mIdlePeriod
-
>
GetIdlePeriodHint
(
&
idleDeadline
)
;
}
if
(
!
mHasPendingEventsPromisedIdleEvent
&
&
(
!
idleDeadline
|
|
idleDeadline
<
TimeStamp
:
:
Now
(
)
)
)
{
return
TimeStamp
(
)
;
}
if
(
mHasPendingEventsPromisedIdleEvent
&
&
!
idleDeadline
)
{
return
TimeStamp
:
:
Now
(
)
;
}
return
idleDeadline
;
}
template
<
class
InnerQueueT
>
EventQueuePriority
PrioritizedEventQueue
<
InnerQueueT
>
:
:
SelectQueue
(
bool
aUpdateState
const
MutexAutoLock
&
aProofOfLock
)
{
size_t
inputCount
=
mInputQueue
-
>
Count
(
aProofOfLock
)
;
if
(
aUpdateState
&
&
mInputQueueState
=
=
STATE_ENABLED
&
&
mInputHandlingStartTime
.
IsNull
(
)
&
&
inputCount
>
0
)
{
mInputHandlingStartTime
=
InputEventStatistics
:
:
Get
(
)
.
GetInputHandlingStartTime
(
inputCount
)
;
}
EventQueuePriority
queue
;
bool
highPending
=
!
mHighQueue
-
>
IsEmpty
(
aProofOfLock
)
;
if
(
mProcessHighPriorityQueue
)
{
queue
=
EventQueuePriority
:
:
High
;
}
else
if
(
inputCount
>
0
&
&
(
mInputQueueState
=
=
STATE_FLUSHING
|
|
(
mInputQueueState
=
=
STATE_ENABLED
&
&
!
mInputHandlingStartTime
.
IsNull
(
)
&
&
TimeStamp
:
:
Now
(
)
>
mInputHandlingStartTime
)
)
)
{
queue
=
EventQueuePriority
:
:
Input
;
}
else
if
(
!
mMediumHighQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
MOZ_ASSERT
(
mInputQueueState
!
=
STATE_FLUSHING
"
Shouldn
'
t
consume
medium
high
event
when
flushing
input
events
"
)
;
queue
=
EventQueuePriority
:
:
MediumHigh
;
}
else
if
(
!
mNormalQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
MOZ_ASSERT
(
mInputQueueState
!
=
STATE_FLUSHING
"
Shouldn
'
t
consume
normal
event
when
flushing
input
events
"
)
;
queue
=
EventQueuePriority
:
:
Normal
;
}
else
if
(
highPending
)
{
queue
=
EventQueuePriority
:
:
High
;
}
else
if
(
inputCount
>
0
&
&
mInputQueueState
!
=
STATE_SUSPEND
)
{
MOZ_ASSERT
(
mInputQueueState
!
=
STATE_DISABLED
"
Shouldn
'
t
consume
input
events
when
the
input
queue
is
disabled
"
)
;
queue
=
EventQueuePriority
:
:
Input
;
}
else
if
(
!
mDeferredTimersQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
queue
=
EventQueuePriority
:
:
DeferredTimers
;
}
else
{
queue
=
EventQueuePriority
:
:
Idle
;
}
MOZ_ASSERT_IF
(
queue
=
=
EventQueuePriority
:
:
Input
mInputQueueState
!
=
STATE_DISABLED
&
&
mInputQueueState
!
=
STATE_SUSPEND
)
;
if
(
aUpdateState
)
{
mProcessHighPriorityQueue
=
highPending
;
}
return
queue
;
}
template
<
class
InnerQueueT
>
already_AddRefed
<
nsIRunnable
>
PrioritizedEventQueue
<
InnerQueueT
>
:
:
GetEvent
(
EventQueuePriority
*
aPriority
const
MutexAutoLock
&
aProofOfLock
)
{
auto
guard
=
MakeScopeExit
(
[
&
]
{
mHasPendingEventsPromisedIdleEvent
=
false
;
}
)
;
#
ifndef
RELEASE_OR_BETA
*
mNextIdleDeadline
=
TimeStamp
(
)
;
#
endif
EventQueuePriority
queue
=
SelectQueue
(
true
aProofOfLock
)
;
if
(
aPriority
)
{
*
aPriority
=
queue
;
}
if
(
queue
=
=
EventQueuePriority
:
:
High
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mHighQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
MOZ_ASSERT
(
event
)
;
mInputHandlingStartTime
=
TimeStamp
(
)
;
mProcessHighPriorityQueue
=
false
;
return
event
.
forget
(
)
;
}
if
(
queue
=
=
EventQueuePriority
:
:
Input
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mInputQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
MOZ_ASSERT
(
event
)
;
return
event
.
forget
(
)
;
}
if
(
queue
=
=
EventQueuePriority
:
:
MediumHigh
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mMediumHighQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
return
event
.
forget
(
)
;
}
if
(
queue
=
=
EventQueuePriority
:
:
Normal
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mNormalQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
return
event
.
forget
(
)
;
}
MOZ_ASSERT
(
queue
=
=
EventQueuePriority
:
:
Idle
|
|
queue
=
=
EventQueuePriority
:
:
DeferredTimers
)
;
if
(
mIdleQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mDeferredTimersQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
MOZ_ASSERT
(
!
mHasPendingEventsPromisedIdleEvent
)
;
return
nullptr
;
}
TimeStamp
idleDeadline
=
GetIdleDeadline
(
)
;
if
(
!
idleDeadline
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
mDeferredTimersQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
if
(
!
event
)
{
event
=
mIdleQueue
-
>
GetEvent
(
aPriority
aProofOfLock
)
;
}
if
(
event
)
{
nsCOMPtr
<
nsIIdleRunnable
>
idleEvent
=
do_QueryInterface
(
event
)
;
if
(
idleEvent
)
{
idleEvent
-
>
SetDeadline
(
idleDeadline
)
;
}
#
ifndef
RELEASE_OR_BETA
*
mNextIdleDeadline
=
idleDeadline
;
#
endif
}
return
event
.
forget
(
)
;
}
template
<
class
InnerQueueT
>
bool
PrioritizedEventQueue
<
InnerQueueT
>
:
:
IsEmpty
(
const
MutexAutoLock
&
aProofOfLock
)
{
return
mHighQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mInputQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mMediumHighQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mNormalQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mDeferredTimersQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mIdleQueue
-
>
IsEmpty
(
aProofOfLock
)
;
}
template
<
class
InnerQueueT
>
bool
PrioritizedEventQueue
<
InnerQueueT
>
:
:
HasReadyEvent
(
const
MutexAutoLock
&
aProofOfLock
)
{
mHasPendingEventsPromisedIdleEvent
=
false
;
EventQueuePriority
queue
=
SelectQueue
(
false
aProofOfLock
)
;
if
(
queue
=
=
EventQueuePriority
:
:
High
)
{
return
mHighQueue
-
>
HasReadyEvent
(
aProofOfLock
)
;
}
else
if
(
queue
=
=
EventQueuePriority
:
:
Input
)
{
return
mInputQueue
-
>
HasReadyEvent
(
aProofOfLock
)
;
}
else
if
(
queue
=
=
EventQueuePriority
:
:
MediumHigh
)
{
return
mMediumHighQueue
-
>
HasReadyEvent
(
aProofOfLock
)
;
}
else
if
(
queue
=
=
EventQueuePriority
:
:
Normal
)
{
return
mNormalQueue
-
>
HasReadyEvent
(
aProofOfLock
)
;
}
MOZ_ASSERT
(
queue
=
=
EventQueuePriority
:
:
Idle
|
|
queue
=
=
EventQueuePriority
:
:
DeferredTimers
)
;
if
(
mDeferredTimersQueue
-
>
IsEmpty
(
aProofOfLock
)
&
&
mIdleQueue
-
>
IsEmpty
(
aProofOfLock
)
)
{
return
false
;
}
TimeStamp
idleDeadline
=
GetIdleDeadline
(
)
;
if
(
idleDeadline
&
&
(
mDeferredTimersQueue
-
>
HasReadyEvent
(
aProofOfLock
)
|
|
mIdleQueue
-
>
HasReadyEvent
(
aProofOfLock
)
)
)
{
mHasPendingEventsPromisedIdleEvent
=
true
;
return
true
;
}
return
false
;
}
template
<
class
InnerQueueT
>
bool
PrioritizedEventQueue
<
InnerQueueT
>
:
:
HasPendingHighPriorityEvents
(
const
MutexAutoLock
&
aProofOfLock
)
{
return
!
mHighQueue
-
>
IsEmpty
(
aProofOfLock
)
;
}
template
<
class
InnerQueueT
>
size_t
PrioritizedEventQueue
<
InnerQueueT
>
:
:
Count
(
const
MutexAutoLock
&
aProofOfLock
)
const
{
MOZ_CRASH
(
"
unimplemented
"
)
;
}
template
<
class
InnerQueueT
>
void
PrioritizedEventQueue
<
InnerQueueT
>
:
:
EnableInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mInputQueueState
=
=
STATE_DISABLED
)
;
mInputQueueState
=
STATE_ENABLED
;
mInputHandlingStartTime
=
TimeStamp
(
)
;
}
template
<
class
InnerQueueT
>
void
PrioritizedEventQueue
<
InnerQueueT
>
:
:
FlushInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mInputQueueState
=
=
STATE_ENABLED
|
|
mInputQueueState
=
=
STATE_SUSPEND
)
;
mInputQueueState
=
mInputQueueState
=
=
STATE_ENABLED
?
STATE_FLUSHING
:
STATE_SUSPEND
;
}
template
<
class
InnerQueueT
>
void
PrioritizedEventQueue
<
InnerQueueT
>
:
:
SuspendInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mInputQueueState
=
=
STATE_ENABLED
|
|
mInputQueueState
=
=
STATE_FLUSHING
)
;
mInputQueueState
=
STATE_SUSPEND
;
}
template
<
class
InnerQueueT
>
void
PrioritizedEventQueue
<
InnerQueueT
>
:
:
ResumeInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mInputQueueState
=
=
STATE_SUSPEND
)
;
mInputQueueState
=
STATE_ENABLED
;
}
namespace
mozilla
{
template
class
PrioritizedEventQueue
<
EventQueue
>
;
}
