#
if
!
defined
(
MozPromise_h_
)
#
define
MozPromise_h_
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
nsIDirectTaskDispatcher
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
mozilla
/
jni
/
GeckoResultUtils
.
h
"
#
endif
#
if
MOZ_DIAGNOSTIC_ASSERT_ENABLED
#
define
PROMISE_DEBUG
#
endif
#
ifdef
PROMISE_DEBUG
#
define
PROMISE_ASSERT
MOZ_RELEASE_ASSERT
#
else
#
define
PROMISE_ASSERT
(
.
.
.
)
\
do
{
\
}
while
(
0
)
#
endif
#
if
DEBUG
#
include
"
nsPrintfCString
.
h
"
#
endif
namespace
mozilla
{
namespace
dom
{
class
Promise
;
}
extern
LazyLogModule
gMozPromiseLog
;
#
define
PROMISE_LOG
(
x
.
.
.
)
\
MOZ_LOG
(
gMozPromiseLog
mozilla
:
:
LogLevel
:
:
Debug
(
x
#
#
__VA_ARGS__
)
)
namespace
detail
{
template
<
typename
F
>
struct
MethodTraitsHelper
:
MethodTraitsHelper
<
decltype
(
&
F
:
:
operator
(
)
)
>
{
}
;
template
<
typename
ThisType
typename
Ret
typename
.
.
.
ArgTypes
>
struct
MethodTraitsHelper
<
Ret
(
ThisType
:
:
*
)
(
ArgTypes
.
.
.
)
>
{
using
ReturnType
=
Ret
;
static
const
size_t
ArgSize
=
sizeof
.
.
.
(
ArgTypes
)
;
}
;
template
<
typename
ThisType
typename
Ret
typename
.
.
.
ArgTypes
>
struct
MethodTraitsHelper
<
Ret
(
ThisType
:
:
*
)
(
ArgTypes
.
.
.
)
const
>
{
using
ReturnType
=
Ret
;
static
const
size_t
ArgSize
=
sizeof
.
.
.
(
ArgTypes
)
;
}
;
template
<
typename
ThisType
typename
Ret
typename
.
.
.
ArgTypes
>
struct
MethodTraitsHelper
<
Ret
(
ThisType
:
:
*
)
(
ArgTypes
.
.
.
)
volatile
>
{
using
ReturnType
=
Ret
;
static
const
size_t
ArgSize
=
sizeof
.
.
.
(
ArgTypes
)
;
}
;
template
<
typename
ThisType
typename
Ret
typename
.
.
.
ArgTypes
>
struct
MethodTraitsHelper
<
Ret
(
ThisType
:
:
*
)
(
ArgTypes
.
.
.
)
const
volatile
>
{
using
ReturnType
=
Ret
;
static
const
size_t
ArgSize
=
sizeof
.
.
.
(
ArgTypes
)
;
}
;
template
<
typename
T
>
struct
MethodTrait
:
MethodTraitsHelper
<
std
:
:
remove_reference_t
<
T
>
>
{
}
;
}
template
<
typename
MethodType
>
using
TakesArgument
=
std
:
:
integral_constant
<
bool
detail
:
:
MethodTrait
<
MethodType
>
:
:
ArgSize
!
=
0
>
;
template
<
typename
MethodType
typename
TargetType
>
using
ReturnTypeIs
=
std
:
:
is_convertible
<
typename
detail
:
:
MethodTrait
<
MethodType
>
:
:
ReturnType
TargetType
>
;
template
<
typename
ResolveValueT
typename
RejectValueT
bool
IsExclusive
>
class
MozPromise
;
template
<
typename
Return
>
struct
IsMozPromise
:
std
:
:
false_type
{
}
;
template
<
typename
ResolveValueT
typename
RejectValueT
bool
IsExclusive
>
struct
IsMozPromise
<
MozPromise
<
ResolveValueT
RejectValueT
IsExclusive
>
>
:
std
:
:
true_type
{
}
;
class
MozPromiseRefcountable
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MozPromiseRefcountable
)
protected
:
virtual
~
MozPromiseRefcountable
(
)
=
default
;
}
;
class
MozPromiseBase
:
public
MozPromiseRefcountable
{
public
:
virtual
void
AssertIsDead
(
)
=
0
;
}
;
template
<
typename
T
>
class
MozPromiseHolder
;
template
<
typename
T
>
class
MozPromiseRequestHolder
;
template
<
typename
ResolveValueT
typename
RejectValueT
bool
IsExclusive
>
class
MozPromise
:
public
MozPromiseBase
{
static
const
uint32_t
sMagic
=
0xcecace11
;
template
<
typename
T
typename
R
=
std
:
:
conditional_t
<
IsExclusive
T
&
&
const
T
&
>
>
static
R
MaybeMove
(
T
&
aX
)
{
return
static_cast
<
R
>
(
aX
)
;
}
public
:
typedef
ResolveValueT
ResolveValueType
;
typedef
RejectValueT
RejectValueType
;
class
ResolveOrRejectValue
{
public
:
template
<
typename
ResolveValueType_
>
void
SetResolve
(
ResolveValueType_
&
&
aResolveValue
)
{
MOZ_ASSERT
(
IsNothing
(
)
)
;
mValue
=
Storage
(
VariantIndex
<
ResolveIndex
>
{
}
std
:
:
forward
<
ResolveValueType_
>
(
aResolveValue
)
)
;
}
template
<
typename
RejectValueType_
>
void
SetReject
(
RejectValueType_
&
&
aRejectValue
)
{
MOZ_ASSERT
(
IsNothing
(
)
)
;
mValue
=
Storage
(
VariantIndex
<
RejectIndex
>
{
}
std
:
:
forward
<
RejectValueType_
>
(
aRejectValue
)
)
;
}
template
<
typename
ResolveValueType_
>
static
ResolveOrRejectValue
MakeResolve
(
ResolveValueType_
&
&
aResolveValue
)
{
ResolveOrRejectValue
val
;
val
.
SetResolve
(
std
:
:
forward
<
ResolveValueType_
>
(
aResolveValue
)
)
;
return
val
;
}
template
<
typename
RejectValueType_
>
static
ResolveOrRejectValue
MakeReject
(
RejectValueType_
&
&
aRejectValue
)
{
ResolveOrRejectValue
val
;
val
.
SetReject
(
std
:
:
forward
<
RejectValueType_
>
(
aRejectValue
)
)
;
return
val
;
}
bool
IsResolve
(
)
const
{
return
mValue
.
template
is
<
ResolveIndex
>
(
)
;
}
bool
IsReject
(
)
const
{
return
mValue
.
template
is
<
RejectIndex
>
(
)
;
}
bool
IsNothing
(
)
const
{
return
mValue
.
template
is
<
NothingIndex
>
(
)
;
}
const
ResolveValueType
&
ResolveValue
(
)
const
{
return
mValue
.
template
as
<
ResolveIndex
>
(
)
;
}
ResolveValueType
&
ResolveValue
(
)
{
return
mValue
.
template
as
<
ResolveIndex
>
(
)
;
}
const
RejectValueType
&
RejectValue
(
)
const
{
return
mValue
.
template
as
<
RejectIndex
>
(
)
;
}
RejectValueType
&
RejectValue
(
)
{
return
mValue
.
template
as
<
RejectIndex
>
(
)
;
}
private
:
enum
{
NothingIndex
ResolveIndex
RejectIndex
}
;
using
Storage
=
Variant
<
Nothing
ResolveValueType
RejectValueType
>
;
Storage
mValue
=
Storage
(
VariantIndex
<
NothingIndex
>
{
}
)
;
}
;
protected
:
MozPromise
(
const
char
*
aCreationSite
bool
aIsCompletionPromise
)
:
mCreationSite
(
aCreationSite
)
mMutex
(
"
MozPromise
Mutex
"
)
mHaveRequest
(
false
)
mIsCompletionPromise
(
aIsCompletionPromise
)
#
ifdef
PROMISE_DEBUG
mMagic4
(
&
mMutex
)
#
endif
{
PROMISE_LOG
(
"
%
s
creating
MozPromise
(
%
p
)
"
mCreationSite
this
)
;
}
public
:
class
Private
;
template
<
typename
ResolveValueType_
>
[
[
nodiscard
]
]
static
RefPtr
<
MozPromise
>
CreateAndResolve
(
ResolveValueType_
&
&
aResolveValue
const
char
*
aResolveSite
)
{
static_assert
(
std
:
:
is_convertible_v
<
ResolveValueType_
ResolveValueT
>
"
Resolve
(
)
argument
must
be
implicitly
convertible
to
"
"
MozPromise
'
s
ResolveValueT
"
)
;
RefPtr
<
typename
MozPromise
:
:
Private
>
p
=
new
MozPromise
:
:
Private
(
aResolveSite
)
;
p
-
>
Resolve
(
std
:
:
forward
<
ResolveValueType_
>
(
aResolveValue
)
aResolveSite
)
;
return
p
;
}
template
<
typename
RejectValueType_
>
[
[
nodiscard
]
]
static
RefPtr
<
MozPromise
>
CreateAndReject
(
RejectValueType_
&
&
aRejectValue
const
char
*
aRejectSite
)
{
static_assert
(
std
:
:
is_convertible_v
<
RejectValueType_
RejectValueT
>
"
Reject
(
)
argument
must
be
implicitly
convertible
to
"
"
MozPromise
'
s
RejectValueT
"
)
;
RefPtr
<
typename
MozPromise
:
:
Private
>
p
=
new
MozPromise
:
:
Private
(
aRejectSite
)
;
p
-
>
Reject
(
std
:
:
forward
<
RejectValueType_
>
(
aRejectValue
)
aRejectSite
)
;
return
p
;
}
template
<
typename
ResolveOrRejectValueType_
>
[
[
nodiscard
]
]
static
RefPtr
<
MozPromise
>
CreateAndResolveOrReject
(
ResolveOrRejectValueType_
&
&
aValue
const
char
*
aSite
)
{
RefPtr
<
typename
MozPromise
:
:
Private
>
p
=
new
MozPromise
:
:
Private
(
aSite
)
;
p
-
>
ResolveOrReject
(
std
:
:
forward
<
ResolveOrRejectValueType_
>
(
aValue
)
aSite
)
;
return
p
;
}
typedef
MozPromise
<
CopyableTArray
<
ResolveValueType
>
RejectValueType
IsExclusive
>
AllPromiseType
;
typedef
MozPromise
<
CopyableTArray
<
ResolveOrRejectValue
>
bool
IsExclusive
>
AllSettledPromiseType
;
private
:
class
AllPromiseHolder
:
public
MozPromiseRefcountable
{
public
:
explicit
AllPromiseHolder
(
size_t
aDependentPromises
)
:
mPromise
(
new
typename
AllPromiseType
:
:
Private
(
__func__
)
)
mOutstandingPromises
(
aDependentPromises
)
{
MOZ_ASSERT
(
aDependentPromises
>
0
)
;
mResolveValues
.
SetLength
(
aDependentPromises
)
;
}
void
Resolve
(
size_t
aIndex
ResolveValueType
&
&
aResolveValue
)
{
if
(
!
mPromise
)
{
return
;
}
mResolveValues
[
aIndex
]
.
emplace
(
std
:
:
move
(
aResolveValue
)
)
;
if
(
-
-
mOutstandingPromises
=
=
0
)
{
nsTArray
<
ResolveValueType
>
resolveValues
;
resolveValues
.
SetCapacity
(
mResolveValues
.
Length
(
)
)
;
for
(
auto
&
&
resolveValue
:
mResolveValues
)
{
resolveValues
.
AppendElement
(
std
:
:
move
(
resolveValue
.
ref
(
)
)
)
;
}
mPromise
-
>
Resolve
(
std
:
:
move
(
resolveValues
)
__func__
)
;
mPromise
=
nullptr
;
mResolveValues
.
Clear
(
)
;
}
}
void
Reject
(
RejectValueType
&
&
aRejectValue
)
{
if
(
!
mPromise
)
{
return
;
}
mPromise
-
>
Reject
(
std
:
:
move
(
aRejectValue
)
__func__
)
;
mPromise
=
nullptr
;
mResolveValues
.
Clear
(
)
;
}
AllPromiseType
*
Promise
(
)
{
return
mPromise
;
}
private
:
nsTArray
<
Maybe
<
ResolveValueType
>
>
mResolveValues
;
RefPtr
<
typename
AllPromiseType
:
:
Private
>
mPromise
;
size_t
mOutstandingPromises
;
}
;
typedef
std
:
:
conditional_t
<
IsExclusive
ResolveOrRejectValue
&
&
const
ResolveOrRejectValue
&
>
ResolveOrRejectValueParam
;
class
AllSettledPromiseHolder
:
public
MozPromiseRefcountable
{
public
:
explicit
AllSettledPromiseHolder
(
size_t
aDependentPromises
)
:
mPromise
(
new
typename
AllSettledPromiseType
:
:
Private
(
__func__
)
)
mOutstandingPromises
(
aDependentPromises
)
{
MOZ_ASSERT
(
aDependentPromises
>
0
)
;
mValues
.
SetLength
(
aDependentPromises
)
;
}
void
Settle
(
size_t
aIndex
ResolveOrRejectValueParam
aValue
)
{
if
(
!
mPromise
)
{
return
;
}
mValues
[
aIndex
]
.
emplace
(
MaybeMove
(
aValue
)
)
;
if
(
-
-
mOutstandingPromises
=
=
0
)
{
nsTArray
<
ResolveOrRejectValue
>
values
;
values
.
SetCapacity
(
mValues
.
Length
(
)
)
;
for
(
auto
&
&
value
:
mValues
)
{
values
.
AppendElement
(
std
:
:
move
(
value
.
ref
(
)
)
)
;
}
mPromise
-
>
Resolve
(
std
:
:
move
(
values
)
__func__
)
;
mPromise
=
nullptr
;
mValues
.
Clear
(
)
;
}
}
AllSettledPromiseType
*
Promise
(
)
{
return
mPromise
;
}
private
:
nsTArray
<
Maybe
<
ResolveOrRejectValue
>
>
mValues
;
RefPtr
<
typename
AllSettledPromiseType
:
:
Private
>
mPromise
;
size_t
mOutstandingPromises
;
}
;
public
:
[
[
nodiscard
]
]
static
RefPtr
<
AllPromiseType
>
All
(
nsISerialEventTarget
*
aProcessingTarget
nsTArray
<
RefPtr
<
MozPromise
>
>
&
aPromises
)
{
if
(
aPromises
.
Length
(
)
=
=
0
)
{
return
AllPromiseType
:
:
CreateAndResolve
(
CopyableTArray
<
ResolveValueType
>
(
)
__func__
)
;
}
RefPtr
<
AllPromiseHolder
>
holder
=
new
AllPromiseHolder
(
aPromises
.
Length
(
)
)
;
RefPtr
<
AllPromiseType
>
promise
=
holder
-
>
Promise
(
)
;
for
(
size_t
i
=
0
;
i
<
aPromises
.
Length
(
)
;
+
+
i
)
{
aPromises
[
i
]
-
>
Then
(
aProcessingTarget
__func__
[
holder
i
]
(
ResolveValueType
aResolveValue
)
-
>
void
{
holder
-
>
Resolve
(
i
std
:
:
move
(
aResolveValue
)
)
;
}
[
holder
]
(
RejectValueType
aRejectValue
)
-
>
void
{
holder
-
>
Reject
(
std
:
:
move
(
aRejectValue
)
)
;
}
)
;
}
return
promise
;
}
[
[
nodiscard
]
]
static
RefPtr
<
AllSettledPromiseType
>
AllSettled
(
nsISerialEventTarget
*
aProcessingTarget
nsTArray
<
RefPtr
<
MozPromise
>
>
&
aPromises
)
{
if
(
aPromises
.
Length
(
)
=
=
0
)
{
return
AllSettledPromiseType
:
:
CreateAndResolve
(
CopyableTArray
<
ResolveOrRejectValue
>
(
)
__func__
)
;
}
RefPtr
<
AllSettledPromiseHolder
>
holder
=
new
AllSettledPromiseHolder
(
aPromises
.
Length
(
)
)
;
RefPtr
<
AllSettledPromiseType
>
promise
=
holder
-
>
Promise
(
)
;
for
(
size_t
i
=
0
;
i
<
aPromises
.
Length
(
)
;
+
+
i
)
{
aPromises
[
i
]
-
>
Then
(
aProcessingTarget
__func__
[
holder
i
]
(
ResolveOrRejectValueParam
aValue
)
-
>
void
{
holder
-
>
Settle
(
i
MaybeMove
(
aValue
)
)
;
}
)
;
}
return
promise
;
}
class
Request
:
public
MozPromiseRefcountable
{
public
:
virtual
void
Disconnect
(
)
=
0
;
protected
:
Request
(
)
:
mComplete
(
false
)
mDisconnected
(
false
)
{
}
virtual
~
Request
(
)
=
default
;
bool
mComplete
;
bool
mDisconnected
;
}
;
protected
:
class
ThenValueBase
:
public
Request
{
friend
class
MozPromise
;
static
const
uint32_t
sMagic
=
0xfadece11
;
public
:
class
ResolveOrRejectRunnable
:
public
CancelableRunnable
{
public
:
ResolveOrRejectRunnable
(
ThenValueBase
*
aThenValue
MozPromise
*
aPromise
)
:
CancelableRunnable
(
"
MozPromise
:
:
ThenValueBase
:
:
ResolveOrRejectRunnable
"
)
mThenValue
(
aThenValue
)
mPromise
(
aPromise
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mPromise
-
>
IsPending
(
)
)
;
}
~
ResolveOrRejectRunnable
(
)
{
if
(
mThenValue
)
{
mThenValue
-
>
AssertIsDead
(
)
;
}
}
NS_IMETHOD
Run
(
)
override
{
PROMISE_LOG
(
"
ResolveOrRejectRunnable
:
:
Run
(
)
[
this
=
%
p
]
"
this
)
;
mThenValue
-
>
DoResolveOrReject
(
mPromise
-
>
Value
(
)
)
;
mThenValue
=
nullptr
;
mPromise
=
nullptr
;
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
return
Run
(
)
;
}
private
:
RefPtr
<
ThenValueBase
>
mThenValue
;
RefPtr
<
MozPromise
>
mPromise
;
}
;
ThenValueBase
(
nsISerialEventTarget
*
aResponseTarget
const
char
*
aCallSite
)
:
mResponseTarget
(
aResponseTarget
)
mCallSite
(
aCallSite
)
{
MOZ_ASSERT
(
aResponseTarget
)
;
}
#
ifdef
PROMISE_DEBUG
~
ThenValueBase
(
)
{
mMagic1
=
0
;
mMagic2
=
0
;
}
#
endif
void
AssertIsDead
(
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
)
;
if
(
MozPromiseBase
*
p
=
CompletionPromise
(
)
)
{
p
-
>
AssertIsDead
(
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
Request
:
:
mDisconnected
)
;
}
}
void
Dispatch
(
MozPromise
*
aPromise
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
)
;
aPromise
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
!
aPromise
-
>
IsPending
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
new
ResolveOrRejectRunnable
(
this
aPromise
)
;
PROMISE_LOG
(
"
%
s
Then
(
)
call
made
from
%
s
[
Runnable
=
%
p
Promise
=
%
p
ThenValue
=
%
p
]
"
"
%
s
dispatch
"
aPromise
-
>
mValue
.
IsResolve
(
)
?
"
Resolving
"
:
"
Rejecting
"
mCallSite
r
.
get
(
)
aPromise
this
aPromise
-
>
mUseSynchronousTaskDispatch
?
"
synchronous
"
:
aPromise
-
>
mUseDirectTaskDispatch
?
"
directtask
"
:
"
normal
"
)
;
if
(
aPromise
-
>
mUseSynchronousTaskDispatch
&
&
mResponseTarget
-
>
IsOnCurrentThread
(
)
)
{
PROMISE_LOG
(
"
ThenValue
:
:
Dispatch
running
task
synchronously
[
this
=
%
p
]
"
this
)
;
r
-
>
Run
(
)
;
return
;
}
if
(
aPromise
-
>
mUseDirectTaskDispatch
&
&
mResponseTarget
-
>
IsOnCurrentThread
(
)
)
{
PROMISE_LOG
(
"
ThenValue
:
:
Dispatch
dispatch
task
via
direct
task
queue
[
this
=
%
p
]
"
this
)
;
nsCOMPtr
<
nsIDirectTaskDispatcher
>
dispatcher
=
do_QueryInterface
(
mResponseTarget
)
;
if
(
dispatcher
)
{
dispatcher
-
>
DispatchDirectTask
(
r
.
forget
(
)
)
;
return
;
}
NS_WARNING
(
nsPrintfCString
(
"
Direct
Task
dispatching
not
available
for
thread
\
"
%
s
\
"
"
PR_GetThreadName
(
PR_GetCurrentThread
(
)
)
)
.
get
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
false
"
mResponseTarget
must
implement
nsIDirectTaskDispatcher
for
direct
"
"
task
dispatching
"
)
;
}
mResponseTarget
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
Disconnect
(
)
override
{
MOZ_DIAGNOSTIC_ASSERT
(
mResponseTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
Request
:
:
mComplete
)
;
Request
:
:
mDisconnected
=
true
;
MOZ_DIAGNOSTIC_ASSERT
(
!
CompletionPromise
(
)
)
;
}
protected
:
virtual
MozPromiseBase
*
CompletionPromise
(
)
const
=
0
;
virtual
void
DoResolveOrRejectInternal
(
ResolveOrRejectValue
&
aValue
)
=
0
;
void
DoResolveOrReject
(
ResolveOrRejectValue
&
aValue
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mResponseTarget
-
>
IsOnCurrentThread
(
)
)
;
Request
:
:
mComplete
=
true
;
if
(
Request
:
:
mDisconnected
)
{
PROMISE_LOG
(
"
ThenValue
:
:
DoResolveOrReject
disconnected
-
bailing
out
[
this
=
%
p
]
"
this
)
;
return
;
}
DoResolveOrRejectInternal
(
aValue
)
;
}
nsCOMPtr
<
nsISerialEventTarget
>
mResponseTarget
;
#
ifdef
PROMISE_DEBUG
uint32_t
mMagic1
=
sMagic
;
#
endif
const
char
*
mCallSite
;
#
ifdef
PROMISE_DEBUG
uint32_t
mMagic2
=
sMagic
;
#
endif
}
;
template
<
typename
ThisType
typename
MethodType
typename
ValueType
>
static
std
:
:
enable_if_t
<
TakesArgument
<
MethodType
>
:
:
value
typename
detail
:
:
MethodTrait
<
MethodType
>
:
:
ReturnType
>
InvokeMethod
(
ThisType
*
aThisVal
MethodType
aMethod
ValueType
&
&
aValue
)
{
return
(
aThisVal
-
>
*
aMethod
)
(
std
:
:
forward
<
ValueType
>
(
aValue
)
)
;
}
template
<
typename
ThisType
typename
MethodType
typename
ValueType
>
static
std
:
:
enable_if_t
<
!
TakesArgument
<
MethodType
>
:
:
value
typename
detail
:
:
MethodTrait
<
MethodType
>
:
:
ReturnType
>
InvokeMethod
(
ThisType
*
aThisVal
MethodType
aMethod
ValueType
&
&
aValue
)
{
return
(
aThisVal
-
>
*
aMethod
)
(
)
;
}
template
<
bool
SupportChaining
typename
ThisType
typename
MethodType
typename
ValueType
typename
CompletionPromiseType
>
static
std
:
:
enable_if_t
<
SupportChaining
void
>
InvokeCallbackMethod
(
ThisType
*
aThisVal
MethodType
aMethod
ValueType
&
&
aValue
CompletionPromiseType
&
&
aCompletionPromise
)
{
auto
p
=
InvokeMethod
(
aThisVal
aMethod
std
:
:
forward
<
ValueType
>
(
aValue
)
)
;
if
(
aCompletionPromise
)
{
p
-
>
ChainTo
(
aCompletionPromise
.
forget
(
)
"
<
chained
completion
promise
>
"
)
;
}
}
template
<
bool
SupportChaining
typename
ThisType
typename
MethodType
typename
ValueType
typename
CompletionPromiseType
>
static
std
:
:
enable_if_t
<
!
SupportChaining
void
>
InvokeCallbackMethod
(
ThisType
*
aThisVal
MethodType
aMethod
ValueType
&
&
aValue
CompletionPromiseType
&
&
aCompletionPromise
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aCompletionPromise
"
Can
'
t
do
promise
chaining
for
a
non
-
promise
-
returning
method
.
"
)
;
InvokeMethod
(
aThisVal
aMethod
std
:
:
forward
<
ValueType
>
(
aValue
)
)
;
}
template
<
typename
>
class
ThenCommand
;
template
<
typename
.
.
.
>
class
ThenValue
;
template
<
typename
ThisType
typename
ResolveMethodType
typename
RejectMethodType
>
class
ThenValue
<
ThisType
*
ResolveMethodType
RejectMethodType
>
:
public
ThenValueBase
{
friend
class
ThenCommand
<
ThenValue
>
;
using
R1
=
typename
RemoveSmartPointer
<
typename
detail
:
:
MethodTrait
<
ResolveMethodType
>
:
:
ReturnType
>
:
:
Type
;
using
R2
=
typename
RemoveSmartPointer
<
typename
detail
:
:
MethodTrait
<
RejectMethodType
>
:
:
ReturnType
>
:
:
Type
;
using
SupportChaining
=
std
:
:
integral_constant
<
bool
IsMozPromise
<
R1
>
:
:
value
&
&
std
:
:
is_same_v
<
R1
R2
>
>
;
using
PromiseType
=
std
:
:
conditional_t
<
SupportChaining
:
:
value
R1
MozPromise
>
;
public
:
ThenValue
(
nsISerialEventTarget
*
aResponseTarget
ThisType
*
aThisVal
ResolveMethodType
aResolveMethod
RejectMethodType
aRejectMethod
const
char
*
aCallSite
)
:
ThenValueBase
(
aResponseTarget
aCallSite
)
mThisVal
(
aThisVal
)
mResolveMethod
(
aResolveMethod
)
mRejectMethod
(
aRejectMethod
)
{
}
void
Disconnect
(
)
override
{
ThenValueBase
:
:
Disconnect
(
)
;
mThisVal
=
nullptr
;
}
protected
:
MozPromiseBase
*
CompletionPromise
(
)
const
override
{
return
mCompletionPromise
;
}
void
DoResolveOrRejectInternal
(
ResolveOrRejectValue
&
aValue
)
override
{
if
(
aValue
.
IsResolve
(
)
)
{
InvokeCallbackMethod
<
SupportChaining
:
:
value
>
(
mThisVal
.
get
(
)
mResolveMethod
MaybeMove
(
aValue
.
ResolveValue
(
)
)
std
:
:
move
(
mCompletionPromise
)
)
;
}
else
{
InvokeCallbackMethod
<
SupportChaining
:
:
value
>
(
mThisVal
.
get
(
)
mRejectMethod
MaybeMove
(
aValue
.
RejectValue
(
)
)
std
:
:
move
(
mCompletionPromise
)
)
;
}
mThisVal
=
nullptr
;
}
private
:
RefPtr
<
ThisType
>
mThisVal
;
ResolveMethodType
mResolveMethod
;
RejectMethodType
mRejectMethod
;
RefPtr
<
typename
PromiseType
:
:
Private
>
mCompletionPromise
;
}
;
template
<
typename
ThisType
typename
ResolveRejectMethodType
>
class
ThenValue
<
ThisType
*
ResolveRejectMethodType
>
:
public
ThenValueBase
{
friend
class
ThenCommand
<
ThenValue
>
;
using
R1
=
typename
RemoveSmartPointer
<
typename
detail
:
:
MethodTrait
<
ResolveRejectMethodType
>
:
:
ReturnType
>
:
:
Type
;
using
SupportChaining
=
std
:
:
integral_constant
<
bool
IsMozPromise
<
R1
>
:
:
value
>
;
using
PromiseType
=
std
:
:
conditional_t
<
SupportChaining
:
:
value
R1
MozPromise
>
;
public
:
ThenValue
(
nsISerialEventTarget
*
aResponseTarget
ThisType
*
aThisVal
ResolveRejectMethodType
aResolveRejectMethod
const
char
*
aCallSite
)
:
ThenValueBase
(
aResponseTarget
aCallSite
)
mThisVal
(
aThisVal
)
mResolveRejectMethod
(
aResolveRejectMethod
)
{
}
void
Disconnect
(
)
override
{
ThenValueBase
:
:
Disconnect
(
)
;
mThisVal
=
nullptr
;
}
protected
:
MozPromiseBase
*
CompletionPromise
(
)
const
override
{
return
mCompletionPromise
;
}
void
DoResolveOrRejectInternal
(
ResolveOrRejectValue
&
aValue
)
override
{
InvokeCallbackMethod
<
SupportChaining
:
:
value
>
(
mThisVal
.
get
(
)
mResolveRejectMethod
MaybeMove
(
aValue
)
std
:
:
move
(
mCompletionPromise
)
)
;
mThisVal
=
nullptr
;
}
private
:
RefPtr
<
ThisType
>
mThisVal
;
ResolveRejectMethodType
mResolveRejectMethod
;
RefPtr
<
typename
PromiseType
:
:
Private
>
mCompletionPromise
;
}
;
template
<
typename
ResolveFunction
typename
RejectFunction
>
class
ThenValue
<
ResolveFunction
RejectFunction
>
:
public
ThenValueBase
{
friend
class
ThenCommand
<
ThenValue
>
;
using
R1
=
typename
RemoveSmartPointer
<
typename
detail
:
:
MethodTrait
<
ResolveFunction
>
:
:
ReturnType
>
:
:
Type
;
using
R2
=
typename
RemoveSmartPointer
<
typename
detail
:
:
MethodTrait
<
RejectFunction
>
:
:
ReturnType
>
:
:
Type
;
using
SupportChaining
=
std
:
:
integral_constant
<
bool
IsMozPromise
<
R1
>
:
:
value
&
&
std
:
:
is_same_v
<
R1
R2
>
>
;
using
PromiseType
=
std
:
:
conditional_t
<
SupportChaining
:
:
value
R1
MozPromise
>
;
public
:
ThenValue
(
nsISerialEventTarget
*
aResponseTarget
ResolveFunction
&
&
aResolveFunction
RejectFunction
&
&
aRejectFunction
const
char
*
aCallSite
)
:
ThenValueBase
(
aResponseTarget
aCallSite
)
{
mResolveFunction
.
emplace
(
std
:
:
move
(
aResolveFunction
)
)
;
mRejectFunction
.
emplace
(
std
:
:
move
(
aRejectFunction
)
)
;
}
void
Disconnect
(
)
override
{
ThenValueBase
:
:
Disconnect
(
)
;
mResolveFunction
.
reset
(
)
;
mRejectFunction
.
reset
(
)
;
}
protected
:
MozPromiseBase
*
CompletionPromise
(
)
const
override
{
return
mCompletionPromise
;
}
void
DoResolveOrRejectInternal
(
ResolveOrRejectValue
&
aValue
)
override
{
if
(
aValue
.
IsResolve
(
)
)
{
InvokeCallbackMethod
<
SupportChaining
:
:
value
>
(
mResolveFunction
.
ptr
(
)
&
ResolveFunction
:
:
operator
(
)
MaybeMove
(
aValue
.
ResolveValue
(
)
)
std
:
:
move
(
mCompletionPromise
)
)
;
}
else
{
InvokeCallbackMethod
<
SupportChaining
:
:
value
>
(
mRejectFunction
.
ptr
(
)
&
RejectFunction
:
:
operator
(
)
MaybeMove
(
aValue
.
RejectValue
(
)
)
std
:
:
move
(
mCompletionPromise
)
)
;
}
mResolveFunction
.
reset
(
)
;
mRejectFunction
.
reset
(
)
;
}
private
:
Maybe
<
ResolveFunction
>
mResolveFunction
;
Maybe
<
RejectFunction
>
mRejectFunction
;
RefPtr
<
typename
PromiseType
:
:
Private
>
mCompletionPromise
;
}
;
template
<
typename
ResolveRejectFunction
>
class
ThenValue
<
ResolveRejectFunction
>
:
public
ThenValueBase
{
friend
class
ThenCommand
<
ThenValue
>
;
using
R1
=
typename
RemoveSmartPointer
<
typename
detail
:
:
MethodTrait
<
ResolveRejectFunction
>
:
:
ReturnType
>
:
:
Type
;
using
SupportChaining
=
std
:
:
integral_constant
<
bool
IsMozPromise
<
R1
>
:
:
value
>
;
using
PromiseType
=
std
:
:
conditional_t
<
SupportChaining
:
:
value
R1
MozPromise
>
;
public
:
ThenValue
(
nsISerialEventTarget
*
aResponseTarget
ResolveRejectFunction
&
&
aResolveRejectFunction
const
char
*
aCallSite
)
:
ThenValueBase
(
aResponseTarget
aCallSite
)
{
mResolveRejectFunction
.
emplace
(
std
:
:
move
(
aResolveRejectFunction
)
)
;
}
void
Disconnect
(
)
override
{
ThenValueBase
:
:
Disconnect
(
)
;
mResolveRejectFunction
.
reset
(
)
;
}
protected
:
MozPromiseBase
*
CompletionPromise
(
)
const
override
{
return
mCompletionPromise
;
}
void
DoResolveOrRejectInternal
(
ResolveOrRejectValue
&
aValue
)
override
{
InvokeCallbackMethod
<
SupportChaining
:
:
value
>
(
mResolveRejectFunction
.
ptr
(
)
&
ResolveRejectFunction
:
:
operator
(
)
MaybeMove
(
aValue
)
std
:
:
move
(
mCompletionPromise
)
)
;
mResolveRejectFunction
.
reset
(
)
;
}
private
:
Maybe
<
ResolveRejectFunction
>
mResolveRejectFunction
;
RefPtr
<
typename
PromiseType
:
:
Private
>
mCompletionPromise
;
}
;
public
:
void
ThenInternal
(
already_AddRefed
<
ThenValueBase
>
aThenValue
const
char
*
aCallSite
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
&
&
mMagic3
=
=
sMagic
&
&
mMagic4
=
=
&
mMutex
)
;
RefPtr
<
ThenValueBase
>
thenValue
=
aThenValue
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsExclusive
|
|
!
mHaveRequest
"
Using
an
exclusive
promise
in
a
non
-
exclusive
fashion
"
)
;
mHaveRequest
=
true
;
PROMISE_LOG
(
"
%
s
invoking
Then
(
)
[
this
=
%
p
aThenValue
=
%
p
isPending
=
%
d
]
"
aCallSite
this
thenValue
.
get
(
)
(
int
)
IsPending
(
)
)
;
if
(
!
IsPending
(
)
)
{
thenValue
-
>
Dispatch
(
this
)
;
}
else
{
mThenValues
.
AppendElement
(
thenValue
.
forget
(
)
)
;
}
}
protected
:
template
<
typename
ThenValueType
>
class
ThenCommand
{
template
<
typename
typename
bool
>
friend
class
MozPromise
;
using
PromiseType
=
typename
ThenValueType
:
:
PromiseType
;
using
Private
=
typename
PromiseType
:
:
Private
;
ThenCommand
(
const
char
*
aCallSite
already_AddRefed
<
ThenValueType
>
aThenValue
MozPromise
*
aReceiver
)
:
mCallSite
(
aCallSite
)
mThenValue
(
aThenValue
)
mReceiver
(
aReceiver
)
{
}
ThenCommand
(
ThenCommand
&
&
aOther
)
=
default
;
public
:
~
ThenCommand
(
)
{
if
(
mThenValue
)
{
mReceiver
-
>
ThenInternal
(
mThenValue
.
forget
(
)
mCallSite
)
;
}
}
operator
RefPtr
<
PromiseType
>
(
)
{
static_assert
(
ThenValueType
:
:
SupportChaining
:
:
value
"
The
resolve
/
reject
callback
needs
to
return
a
RefPtr
<
MozPromise
>
"
"
in
order
to
do
promise
chaining
.
"
)
;
RefPtr
<
Private
>
p
=
new
Private
(
"
<
completion
promise
>
"
true
)
;
mThenValue
-
>
mCompletionPromise
=
p
;
mReceiver
-
>
ThenInternal
(
mThenValue
.
forget
(
)
mCallSite
)
;
return
p
;
}
template
<
typename
.
.
.
Ts
>
auto
Then
(
Ts
&
&
.
.
.
aArgs
)
-
>
decltype
(
std
:
:
declval
<
PromiseType
>
(
)
.
Then
(
std
:
:
forward
<
Ts
>
(
aArgs
)
.
.
.
)
)
{
return
static_cast
<
RefPtr
<
PromiseType
>
>
(
*
this
)
-
>
Then
(
std
:
:
forward
<
Ts
>
(
aArgs
)
.
.
.
)
;
}
void
Track
(
MozPromiseRequestHolder
<
MozPromise
>
&
aRequestHolder
)
{
aRequestHolder
.
Track
(
do_AddRef
(
mThenValue
)
)
;
mReceiver
-
>
ThenInternal
(
mThenValue
.
forget
(
)
mCallSite
)
;
}
ThenCommand
*
operator
-
>
(
)
{
return
this
;
}
private
:
const
char
*
mCallSite
;
RefPtr
<
ThenValueType
>
mThenValue
;
RefPtr
<
MozPromise
>
mReceiver
;
}
;
public
:
template
<
typename
ThisType
typename
.
.
.
Methods
typename
ThenValueType
=
ThenValue
<
ThisType
*
Methods
.
.
.
>
typename
ReturnType
=
ThenCommand
<
ThenValueType
>
>
ReturnType
Then
(
nsISerialEventTarget
*
aResponseTarget
const
char
*
aCallSite
ThisType
*
aThisVal
Methods
.
.
.
aMethods
)
{
RefPtr
<
ThenValueType
>
thenValue
=
new
ThenValueType
(
aResponseTarget
aThisVal
aMethods
.
.
.
aCallSite
)
;
return
ReturnType
(
aCallSite
thenValue
.
forget
(
)
this
)
;
}
template
<
typename
.
.
.
Functions
typename
ThenValueType
=
ThenValue
<
Functions
.
.
.
>
typename
ReturnType
=
ThenCommand
<
ThenValueType
>
>
ReturnType
Then
(
nsISerialEventTarget
*
aResponseTarget
const
char
*
aCallSite
Functions
&
&
.
.
.
aFunctions
)
{
RefPtr
<
ThenValueType
>
thenValue
=
new
ThenValueType
(
aResponseTarget
std
:
:
move
(
aFunctions
)
.
.
.
aCallSite
)
;
return
ReturnType
(
aCallSite
thenValue
.
forget
(
)
this
)
;
}
void
ChainTo
(
already_AddRefed
<
Private
>
aChainedPromise
const
char
*
aCallSite
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsExclusive
|
|
!
mHaveRequest
"
Using
an
exclusive
promise
in
a
non
-
exclusive
fashion
"
)
;
mHaveRequest
=
true
;
RefPtr
<
Private
>
chainedPromise
=
aChainedPromise
;
PROMISE_LOG
(
"
%
s
invoking
Chain
(
)
[
this
=
%
p
chainedPromise
=
%
p
isPending
=
%
d
]
"
aCallSite
this
chainedPromise
.
get
(
)
(
int
)
IsPending
(
)
)
;
if
(
mUseDirectTaskDispatch
)
{
chainedPromise
-
>
UseDirectTaskDispatch
(
aCallSite
)
;
}
else
if
constexpr
(
IsExclusive
)
{
if
(
mUseSynchronousTaskDispatch
)
{
chainedPromise
-
>
UseSynchronousTaskDispatch
(
aCallSite
)
;
}
}
if
(
!
IsPending
(
)
)
{
ForwardTo
(
chainedPromise
)
;
}
else
{
mChainedPromises
.
AppendElement
(
chainedPromise
)
;
}
}
#
ifdef
MOZ_WIDGET_ANDROID
[
[
nodiscard
]
]
static
RefPtr
<
MozPromise
>
FromGeckoResult
(
java
:
:
GeckoResult
:
:
Param
aGeckoResult
)
{
using
jni
:
:
GeckoResultCallback
;
RefPtr
<
Private
>
p
=
new
Private
(
"
GeckoResult
Glue
"
false
)
;
auto
resolve
=
GeckoResultCallback
:
:
CreateAndAttach
<
ResolveValueType
>
(
[
p
]
(
ResolveValueType
aArg
)
{
p
-
>
Resolve
(
aArg
__func__
)
;
}
)
;
auto
reject
=
GeckoResultCallback
:
:
CreateAndAttach
<
RejectValueType
>
(
[
p
]
(
RejectValueType
aArg
)
{
p
-
>
Reject
(
aArg
__func__
)
;
}
)
;
aGeckoResult
-
>
NativeThen
(
resolve
reject
)
;
return
p
;
}
#
endif
static
RefPtr
<
MozPromise
>
FromDomPromise
(
dom
:
:
Promise
*
aDOMPromise
)
;
void
AssertIsDead
(
)
override
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
&
&
mMagic3
=
=
sMagic
&
&
mMagic4
=
=
&
mMutex
)
;
MutexAutoLock
lock
(
mMutex
)
;
for
(
auto
&
&
then
:
mThenValues
)
{
then
-
>
AssertIsDead
(
)
;
}
for
(
auto
&
&
chained
:
mChainedPromises
)
{
chained
-
>
AssertIsDead
(
)
;
}
}
protected
:
bool
IsPending
(
)
const
{
return
mValue
.
IsNothing
(
)
;
}
ResolveOrRejectValue
&
Value
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsPending
(
)
)
;
return
mValue
;
}
void
DispatchAll
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
for
(
auto
&
&
thenValue
:
mThenValues
)
{
thenValue
-
>
Dispatch
(
this
)
;
}
mThenValues
.
Clear
(
)
;
for
(
auto
&
&
chainedPromise
:
mChainedPromises
)
{
ForwardTo
(
chainedPromise
)
;
}
mChainedPromises
.
Clear
(
)
;
}
void
ForwardTo
(
Private
*
aOther
)
{
MOZ_ASSERT
(
!
IsPending
(
)
)
;
if
(
mValue
.
IsResolve
(
)
)
{
aOther
-
>
Resolve
(
MaybeMove
(
mValue
.
ResolveValue
(
)
)
"
<
chained
promise
>
"
)
;
}
else
{
aOther
-
>
Reject
(
MaybeMove
(
mValue
.
RejectValue
(
)
)
"
<
chained
promise
>
"
)
;
}
}
virtual
~
MozPromise
(
)
{
PROMISE_LOG
(
"
MozPromise
:
:
~
MozPromise
[
this
=
%
p
]
"
this
)
;
AssertIsDead
(
)
;
if
(
!
mIsCompletionPromise
)
{
MOZ_ASSERT
(
!
IsPending
(
)
)
;
MOZ_ASSERT
(
mThenValues
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mChainedPromises
.
IsEmpty
(
)
)
;
}
#
ifdef
PROMISE_DEBUG
mMagic1
=
0
;
mMagic2
=
0
;
mMagic3
=
0
;
mMagic4
=
nullptr
;
#
endif
}
;
const
char
*
mCreationSite
;
Mutex
mMutex
;
ResolveOrRejectValue
mValue
;
bool
mUseSynchronousTaskDispatch
=
false
;
bool
mUseDirectTaskDispatch
=
false
;
#
ifdef
PROMISE_DEBUG
uint32_t
mMagic1
=
sMagic
;
#
endif
AutoTArray
<
RefPtr
<
ThenValueBase
>
IsExclusive
?
1
:
3
>
mThenValues
;
#
ifdef
PROMISE_DEBUG
uint32_t
mMagic2
=
sMagic
;
#
endif
nsTArray
<
RefPtr
<
Private
>
>
mChainedPromises
;
#
ifdef
PROMISE_DEBUG
uint32_t
mMagic3
=
sMagic
;
#
endif
bool
mHaveRequest
;
const
bool
mIsCompletionPromise
;
#
ifdef
PROMISE_DEBUG
void
*
mMagic4
;
#
endif
}
;
template
<
typename
ResolveValueT
typename
RejectValueT
bool
IsExclusive
>
class
MozPromise
<
ResolveValueT
RejectValueT
IsExclusive
>
:
:
Private
:
public
MozPromise
<
ResolveValueT
RejectValueT
IsExclusive
>
{
public
:
explicit
Private
(
const
char
*
aCreationSite
bool
aIsCompletionPromise
=
false
)
:
MozPromise
(
aCreationSite
aIsCompletionPromise
)
{
}
template
<
typename
ResolveValueT_
>
void
Resolve
(
ResolveValueT_
&
&
aResolveValue
const
char
*
aResolveSite
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
&
&
mMagic3
=
=
sMagic
&
&
mMagic4
=
=
&
mMutex
)
;
MutexAutoLock
lock
(
mMutex
)
;
PROMISE_LOG
(
"
%
s
resolving
MozPromise
(
%
p
created
at
%
s
)
"
aResolveSite
this
mCreationSite
)
;
if
(
!
IsPending
(
)
)
{
PROMISE_LOG
(
"
%
s
ignored
already
resolved
or
rejected
MozPromise
(
%
p
created
at
"
"
%
s
)
"
aResolveSite
this
mCreationSite
)
;
return
;
}
mValue
.
SetResolve
(
std
:
:
forward
<
ResolveValueT_
>
(
aResolveValue
)
)
;
DispatchAll
(
)
;
}
template
<
typename
RejectValueT_
>
void
Reject
(
RejectValueT_
&
&
aRejectValue
const
char
*
aRejectSite
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
&
&
mMagic3
=
=
sMagic
&
&
mMagic4
=
=
&
mMutex
)
;
MutexAutoLock
lock
(
mMutex
)
;
PROMISE_LOG
(
"
%
s
rejecting
MozPromise
(
%
p
created
at
%
s
)
"
aRejectSite
this
mCreationSite
)
;
if
(
!
IsPending
(
)
)
{
PROMISE_LOG
(
"
%
s
ignored
already
resolved
or
rejected
MozPromise
(
%
p
created
at
"
"
%
s
)
"
aRejectSite
this
mCreationSite
)
;
return
;
}
mValue
.
SetReject
(
std
:
:
forward
<
RejectValueT_
>
(
aRejectValue
)
)
;
DispatchAll
(
)
;
}
template
<
typename
ResolveOrRejectValue_
>
void
ResolveOrReject
(
ResolveOrRejectValue_
&
&
aValue
const
char
*
aSite
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
&
&
mMagic3
=
=
sMagic
&
&
mMagic4
=
=
&
mMutex
)
;
MutexAutoLock
lock
(
mMutex
)
;
PROMISE_LOG
(
"
%
s
resolveOrRejecting
MozPromise
(
%
p
created
at
%
s
)
"
aSite
this
mCreationSite
)
;
if
(
!
IsPending
(
)
)
{
PROMISE_LOG
(
"
%
s
ignored
already
resolved
or
rejected
MozPromise
(
%
p
created
at
"
"
%
s
)
"
aSite
this
mCreationSite
)
;
return
;
}
mValue
=
std
:
:
forward
<
ResolveOrRejectValue_
>
(
aValue
)
;
DispatchAll
(
)
;
}
void
UseSynchronousTaskDispatch
(
const
char
*
aSite
)
{
static_assert
(
IsExclusive
"
Synchronous
dispatch
can
only
be
used
with
exclusive
promises
"
)
;
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
&
&
mMagic3
=
=
sMagic
&
&
mMagic4
=
=
&
mMutex
)
;
MutexAutoLock
lock
(
mMutex
)
;
PROMISE_LOG
(
"
%
s
UseSynchronousTaskDispatch
MozPromise
(
%
p
created
at
%
s
)
"
aSite
this
mCreationSite
)
;
MOZ_ASSERT
(
IsPending
(
)
"
A
Promise
must
not
have
been
already
resolved
or
rejected
to
"
"
set
dispatch
state
"
)
;
mUseSynchronousTaskDispatch
=
true
;
}
void
UseDirectTaskDispatch
(
const
char
*
aSite
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
&
&
mMagic3
=
=
sMagic
&
&
mMagic4
=
=
&
mMutex
)
;
MutexAutoLock
lock
(
mMutex
)
;
PROMISE_LOG
(
"
%
s
UseDirectTaskDispatch
MozPromise
(
%
p
created
at
%
s
)
"
aSite
this
mCreationSite
)
;
MOZ_ASSERT
(
IsPending
(
)
"
A
Promise
must
not
have
been
already
resolved
or
rejected
to
"
"
set
dispatch
state
"
)
;
MOZ_ASSERT
(
!
mUseSynchronousTaskDispatch
"
Promise
already
set
for
synchronous
dispatch
"
)
;
mUseDirectTaskDispatch
=
true
;
}
}
;
typedef
MozPromise
<
bool
nsresult
true
>
GenericPromise
;
typedef
MozPromise
<
bool
nsresult
false
>
GenericNonExclusivePromise
;
template
<
typename
PromiseType
typename
ImplType
>
class
MozPromiseHolderBase
{
public
:
MozPromiseHolderBase
(
)
=
default
;
MozPromiseHolderBase
(
MozPromiseHolderBase
&
&
aOther
)
=
default
;
MozPromiseHolderBase
&
operator
=
(
MozPromiseHolderBase
&
&
aOther
)
=
default
;
~
MozPromiseHolderBase
(
)
{
MOZ_ASSERT
(
!
mPromise
)
;
}
already_AddRefed
<
PromiseType
>
Ensure
(
const
char
*
aMethodName
)
{
static_cast
<
ImplType
*
>
(
this
)
-
>
Check
(
)
;
if
(
!
mPromise
)
{
mPromise
=
new
(
typename
PromiseType
:
:
Private
)
(
aMethodName
)
;
}
RefPtr
<
PromiseType
>
p
=
mPromise
.
get
(
)
;
return
p
.
forget
(
)
;
}
bool
IsEmpty
(
)
const
{
static_cast
<
const
ImplType
*
>
(
this
)
-
>
Check
(
)
;
return
!
mPromise
;
}
already_AddRefed
<
typename
PromiseType
:
:
Private
>
Steal
(
)
{
static_cast
<
ImplType
*
>
(
this
)
-
>
Check
(
)
;
return
mPromise
.
forget
(
)
;
}
template
<
typename
ResolveValueType_
>
void
Resolve
(
ResolveValueType_
&
&
aResolveValue
const
char
*
aMethodName
)
{
static_assert
(
std
:
:
is_convertible_v
<
ResolveValueType_
typename
PromiseType
:
:
ResolveValueType
>
"
Resolve
(
)
argument
must
be
implicitly
convertible
to
"
"
MozPromise
'
s
ResolveValueT
"
)
;
static_cast
<
ImplType
*
>
(
this
)
-
>
Check
(
)
;
MOZ_ASSERT
(
mPromise
)
;
mPromise
-
>
Resolve
(
std
:
:
forward
<
ResolveValueType_
>
(
aResolveValue
)
aMethodName
)
;
mPromise
=
nullptr
;
}
template
<
typename
ResolveValueType_
>
void
ResolveIfExists
(
ResolveValueType_
&
&
aResolveValue
const
char
*
aMethodName
)
{
if
(
!
IsEmpty
(
)
)
{
Resolve
(
std
:
:
forward
<
ResolveValueType_
>
(
aResolveValue
)
aMethodName
)
;
}
}
template
<
typename
RejectValueType_
>
void
Reject
(
RejectValueType_
&
&
aRejectValue
const
char
*
aMethodName
)
{
static_assert
(
std
:
:
is_convertible_v
<
RejectValueType_
typename
PromiseType
:
:
RejectValueType
>
"
Reject
(
)
argument
must
be
implicitly
convertible
to
"
"
MozPromise
'
s
RejectValueT
"
)
;
static_cast
<
ImplType
*
>
(
this
)
-
>
Check
(
)
;
MOZ_ASSERT
(
mPromise
)
;
mPromise
-
>
Reject
(
std
:
:
forward
<
RejectValueType_
>
(
aRejectValue
)
aMethodName
)
;
mPromise
=
nullptr
;
}
template
<
typename
RejectValueType_
>
void
RejectIfExists
(
RejectValueType_
&
&
aRejectValue
const
char
*
aMethodName
)
{
if
(
!
IsEmpty
(
)
)
{
Reject
(
std
:
:
forward
<
RejectValueType_
>
(
aRejectValue
)
aMethodName
)
;
}
}
template
<
typename
ResolveOrRejectValueType_
>
void
ResolveOrReject
(
ResolveOrRejectValueType_
&
&
aValue
const
char
*
aMethodName
)
{
static_cast
<
ImplType
*
>
(
this
)
-
>
Check
(
)
;
MOZ_ASSERT
(
mPromise
)
;
mPromise
-
>
ResolveOrReject
(
std
:
:
forward
<
ResolveOrRejectValueType_
>
(
aValue
)
aMethodName
)
;
mPromise
=
nullptr
;
}
template
<
typename
ResolveOrRejectValueType_
>
void
ResolveOrRejectIfExists
(
ResolveOrRejectValueType_
&
&
aValue
const
char
*
aMethodName
)
{
if
(
!
IsEmpty
(
)
)
{
ResolveOrReject
(
std
:
:
forward
<
ResolveOrRejectValueType_
>
(
aValue
)
aMethodName
)
;
}
}
void
UseSynchronousTaskDispatch
(
const
char
*
aSite
)
{
MOZ_ASSERT
(
mPromise
)
;
mPromise
-
>
UseSynchronousTaskDispatch
(
aSite
)
;
}
void
UseDirectTaskDispatch
(
const
char
*
aSite
)
{
MOZ_ASSERT
(
mPromise
)
;
mPromise
-
>
UseDirectTaskDispatch
(
aSite
)
;
}
private
:
RefPtr
<
typename
PromiseType
:
:
Private
>
mPromise
;
}
;
template
<
typename
PromiseType
>
class
MozPromiseHolder
:
public
MozPromiseHolderBase
<
PromiseType
MozPromiseHolder
<
PromiseType
>
>
{
public
:
using
MozPromiseHolderBase
<
PromiseType
MozPromiseHolder
<
PromiseType
>
>
:
:
MozPromiseHolderBase
;
static
constexpr
void
Check
(
)
{
}
;
}
;
template
<
typename
PromiseType
>
class
MozMonitoredPromiseHolder
:
public
MozPromiseHolderBase
<
PromiseType
MozMonitoredPromiseHolder
<
PromiseType
>
>
{
public
:
explicit
MozMonitoredPromiseHolder
(
Monitor
*
const
aMonitor
)
:
mMonitor
(
aMonitor
)
{
MOZ_ASSERT
(
aMonitor
)
;
}
MozMonitoredPromiseHolder
(
MozMonitoredPromiseHolder
&
&
aOther
)
=
delete
;
MozMonitoredPromiseHolder
&
operator
=
(
MozMonitoredPromiseHolder
&
&
aOther
)
=
delete
;
void
Check
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
}
private
:
Monitor
*
const
mMonitor
;
}
;
template
<
typename
PromiseType
>
class
MozPromiseRequestHolder
{
public
:
MozPromiseRequestHolder
(
)
=
default
;
~
MozPromiseRequestHolder
(
)
{
MOZ_ASSERT
(
!
mRequest
)
;
}
void
Track
(
already_AddRefed
<
typename
PromiseType
:
:
Request
>
aRequest
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
Exists
(
)
)
;
mRequest
=
aRequest
;
}
void
Complete
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
Exists
(
)
)
;
mRequest
=
nullptr
;
}
void
Disconnect
(
)
{
MOZ_ASSERT
(
Exists
(
)
)
;
mRequest
-
>
Disconnect
(
)
;
mRequest
=
nullptr
;
}
void
DisconnectIfExists
(
)
{
if
(
Exists
(
)
)
{
Disconnect
(
)
;
}
}
bool
Exists
(
)
const
{
return
!
!
mRequest
;
}
private
:
RefPtr
<
typename
PromiseType
:
:
Request
>
mRequest
;
}
;
namespace
detail
{
class
MethodCallBase
{
public
:
MOZ_COUNTED_DEFAULT_CTOR
(
MethodCallBase
)
MOZ_COUNTED_DTOR_VIRTUAL
(
MethodCallBase
)
}
;
template
<
typename
PromiseType
typename
MethodType
typename
ThisType
typename
.
.
.
Storages
>
class
MethodCall
:
public
MethodCallBase
{
public
:
template
<
typename
.
.
.
Args
>
MethodCall
(
MethodType
aMethod
ThisType
*
aThisVal
Args
&
&
.
.
.
aArgs
)
:
mMethod
(
aMethod
)
mThisVal
(
aThisVal
)
mArgs
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
Storages
and
Args
should
have
equal
sizes
"
)
;
}
RefPtr
<
PromiseType
>
Invoke
(
)
{
return
mArgs
.
apply
(
mThisVal
.
get
(
)
mMethod
)
;
}
private
:
MethodType
mMethod
;
RefPtr
<
ThisType
>
mThisVal
;
RunnableMethodArguments
<
Storages
.
.
.
>
mArgs
;
}
;
template
<
typename
PromiseType
typename
MethodType
typename
ThisType
typename
.
.
.
Storages
>
class
ProxyRunnable
:
public
CancelableRunnable
{
public
:
ProxyRunnable
(
typename
PromiseType
:
:
Private
*
aProxyPromise
MethodCall
<
PromiseType
MethodType
ThisType
Storages
.
.
.
>
*
aMethodCall
)
:
CancelableRunnable
(
"
detail
:
:
ProxyRunnable
"
)
mProxyPromise
(
aProxyPromise
)
mMethodCall
(
aMethodCall
)
{
}
NS_IMETHOD
Run
(
)
override
{
RefPtr
<
PromiseType
>
p
=
mMethodCall
-
>
Invoke
(
)
;
mMethodCall
=
nullptr
;
p
-
>
ChainTo
(
mProxyPromise
.
forget
(
)
"
<
Proxy
Promise
>
"
)
;
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
return
Run
(
)
;
}
private
:
RefPtr
<
typename
PromiseType
:
:
Private
>
mProxyPromise
;
UniquePtr
<
MethodCall
<
PromiseType
MethodType
ThisType
Storages
.
.
.
>
>
mMethodCall
;
}
;
template
<
typename
.
.
.
Storages
typename
PromiseType
typename
ThisType
typename
.
.
.
ArgTypes
typename
.
.
.
ActualArgTypes
>
static
RefPtr
<
PromiseType
>
InvokeAsyncImpl
(
nsISerialEventTarget
*
aTarget
ThisType
*
aThisVal
const
char
*
aCallerName
RefPtr
<
PromiseType
>
(
ThisType
:
:
*
aMethod
)
(
ArgTypes
.
.
.
)
ActualArgTypes
&
&
.
.
.
aArgs
)
{
MOZ_ASSERT
(
aTarget
)
;
typedef
RefPtr
<
PromiseType
>
(
ThisType
:
:
*
MethodType
)
(
ArgTypes
.
.
.
)
;
typedef
detail
:
:
MethodCall
<
PromiseType
MethodType
ThisType
Storages
.
.
.
>
MethodCallType
;
typedef
detail
:
:
ProxyRunnable
<
PromiseType
MethodType
ThisType
Storages
.
.
.
>
ProxyRunnableType
;
MethodCallType
*
methodCall
=
new
MethodCallType
(
aMethod
aThisVal
std
:
:
forward
<
ActualArgTypes
>
(
aArgs
)
.
.
.
)
;
RefPtr
<
typename
PromiseType
:
:
Private
>
p
=
new
(
typename
PromiseType
:
:
Private
)
(
aCallerName
)
;
RefPtr
<
ProxyRunnableType
>
r
=
new
ProxyRunnableType
(
p
methodCall
)
;
aTarget
-
>
Dispatch
(
r
.
forget
(
)
)
;
return
p
;
}
constexpr
bool
Any
(
)
{
return
false
;
}
template
<
typename
T1
>
constexpr
bool
Any
(
T1
a
)
{
return
static_cast
<
bool
>
(
a
)
;
}
template
<
typename
T1
typename
.
.
.
Ts
>
constexpr
bool
Any
(
T1
a
Ts
.
.
.
aOthers
)
{
return
a
|
|
Any
(
aOthers
.
.
.
)
;
}
}
template
<
typename
.
.
.
Storages
typename
PromiseType
typename
ThisType
typename
.
.
.
ArgTypes
typename
.
.
.
ActualArgTypes
std
:
:
enable_if_t
<
sizeof
.
.
.
(
Storages
)
!
=
0
int
>
=
0
>
static
RefPtr
<
PromiseType
>
InvokeAsync
(
nsISerialEventTarget
*
aTarget
ThisType
*
aThisVal
const
char
*
aCallerName
RefPtr
<
PromiseType
>
(
ThisType
:
:
*
aMethod
)
(
ArgTypes
.
.
.
)
ActualArgTypes
&
&
.
.
.
aArgs
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
ArgTypes
)
"
Provided
Storages
and
method
'
s
ArgTypes
should
have
equal
sizes
"
)
;
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
ActualArgTypes
)
"
Provided
Storages
and
ActualArgTypes
should
have
equal
sizes
"
)
;
return
detail
:
:
InvokeAsyncImpl
<
Storages
.
.
.
>
(
aTarget
aThisVal
aCallerName
aMethod
std
:
:
forward
<
ActualArgTypes
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
.
.
.
Storages
typename
PromiseType
typename
ThisType
typename
.
.
.
ArgTypes
typename
.
.
.
ActualArgTypes
std
:
:
enable_if_t
<
sizeof
.
.
.
(
Storages
)
=
=
0
int
>
=
0
>
static
RefPtr
<
PromiseType
>
InvokeAsync
(
nsISerialEventTarget
*
aTarget
ThisType
*
aThisVal
const
char
*
aCallerName
RefPtr
<
PromiseType
>
(
ThisType
:
:
*
aMethod
)
(
ArgTypes
.
.
.
)
ActualArgTypes
&
&
.
.
.
aArgs
)
{
static_assert
(
!
detail
:
:
Any
(
std
:
:
is_pointer_v
<
std
:
:
remove_reference_t
<
ActualArgTypes
>
>
.
.
.
)
"
Cannot
pass
pointer
types
through
InvokeAsync
Storages
must
be
"
"
provided
"
)
;
static_assert
(
sizeof
.
.
.
(
ArgTypes
)
=
=
sizeof
.
.
.
(
ActualArgTypes
)
"
Method
'
s
ArgTypes
and
ActualArgTypes
should
have
equal
sizes
"
)
;
return
detail
:
:
InvokeAsyncImpl
<
StoreCopyPassByRRef
<
std
:
:
decay_t
<
ActualArgTypes
>
>
.
.
.
>
(
aTarget
aThisVal
aCallerName
aMethod
std
:
:
forward
<
ActualArgTypes
>
(
aArgs
)
.
.
.
)
;
}
namespace
detail
{
template
<
typename
Function
typename
PromiseType
>
class
ProxyFunctionRunnable
:
public
CancelableRunnable
{
using
FunctionStorage
=
std
:
:
decay_t
<
Function
>
;
public
:
template
<
typename
F
>
ProxyFunctionRunnable
(
typename
PromiseType
:
:
Private
*
aProxyPromise
F
&
&
aFunction
)
:
CancelableRunnable
(
"
detail
:
:
ProxyFunctionRunnable
"
)
mProxyPromise
(
aProxyPromise
)
mFunction
(
new
FunctionStorage
(
std
:
:
forward
<
F
>
(
aFunction
)
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
RefPtr
<
PromiseType
>
p
=
(
*
mFunction
)
(
)
;
mFunction
=
nullptr
;
p
-
>
ChainTo
(
mProxyPromise
.
forget
(
)
"
<
Proxy
Promise
>
"
)
;
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
return
Run
(
)
;
}
private
:
RefPtr
<
typename
PromiseType
:
:
Private
>
mProxyPromise
;
UniquePtr
<
FunctionStorage
>
mFunction
;
}
;
struct
AllowInvokeAsyncFunctionLVRef
{
}
;
template
<
typename
Function
>
static
auto
InvokeAsync
(
nsISerialEventTarget
*
aTarget
const
char
*
aCallerName
AllowInvokeAsyncFunctionLVRef
Function
&
&
aFunction
)
-
>
decltype
(
aFunction
(
)
)
{
static_assert
(
IsRefcountedSmartPointer
<
decltype
(
aFunction
(
)
)
>
:
:
value
&
&
IsMozPromise
<
typename
RemoveSmartPointer
<
decltype
(
aFunction
(
)
)
>
:
:
Type
>
:
:
value
"
Function
object
must
return
RefPtr
<
MozPromise
>
"
)
;
MOZ_ASSERT
(
aTarget
)
;
typedef
typename
RemoveSmartPointer
<
decltype
(
aFunction
(
)
)
>
:
:
Type
PromiseType
;
typedef
detail
:
:
ProxyFunctionRunnable
<
Function
PromiseType
>
ProxyRunnableType
;
auto
p
=
MakeRefPtr
<
typename
PromiseType
:
:
Private
>
(
aCallerName
)
;
auto
r
=
MakeRefPtr
<
ProxyRunnableType
>
(
p
std
:
:
forward
<
Function
>
(
aFunction
)
)
;
aTarget
-
>
Dispatch
(
r
.
forget
(
)
)
;
return
p
;
}
}
template
<
typename
Function
>
static
auto
InvokeAsync
(
nsISerialEventTarget
*
aTarget
const
char
*
aCallerName
Function
&
&
aFunction
)
-
>
decltype
(
aFunction
(
)
)
{
static_assert
(
!
std
:
:
is_lvalue_reference_v
<
Function
>
"
Function
object
must
not
be
passed
by
lvalue
-
ref
(
to
avoid
"
"
unplanned
copies
)
;
Consider
move
(
)
ing
the
object
.
"
)
;
return
detail
:
:
InvokeAsync
(
aTarget
aCallerName
detail
:
:
AllowInvokeAsyncFunctionLVRef
(
)
std
:
:
forward
<
Function
>
(
aFunction
)
)
;
}
#
undef
PROMISE_LOG
#
undef
PROMISE_ASSERT
#
undef
PROMISE_DEBUG
}
#
endif
