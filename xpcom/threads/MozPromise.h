#
if
!
defined
(
MozPromise_h_
)
#
define
MozPromise_h_
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
IndexSequence
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
if
defined
(
DEBUG
)
|
|
!
defined
(
RELEASE_OR_BETA
)
#
define
PROMISE_DEBUG
#
endif
#
ifdef
PROMISE_DEBUG
#
define
PROMISE_ASSERT
MOZ_RELEASE_ASSERT
#
else
#
define
PROMISE_ASSERT
(
.
.
.
)
do
{
}
while
(
0
)
#
endif
namespace
mozilla
{
extern
LazyLogModule
gMozPromiseLog
;
#
define
PROMISE_LOG
(
x
.
.
.
)
\
MOZ_LOG
(
gMozPromiseLog
mozilla
:
:
LogLevel
:
:
Debug
(
x
#
#
__VA_ARGS__
)
)
namespace
detail
{
template
<
typename
ThisType
typename
Ret
typename
ArgType
>
static
TrueType
TakesArgumentHelper
(
Ret
(
ThisType
:
:
*
)
(
ArgType
)
)
;
template
<
typename
ThisType
typename
Ret
typename
ArgType
>
static
TrueType
TakesArgumentHelper
(
Ret
(
ThisType
:
:
*
)
(
ArgType
)
const
)
;
template
<
typename
ThisType
typename
Ret
>
static
FalseType
TakesArgumentHelper
(
Ret
(
ThisType
:
:
*
)
(
)
)
;
template
<
typename
ThisType
typename
Ret
>
static
FalseType
TakesArgumentHelper
(
Ret
(
ThisType
:
:
*
)
(
)
const
)
;
template
<
typename
ThisType
typename
Ret
typename
ArgType
>
static
Ret
ReturnTypeHelper
(
Ret
(
ThisType
:
:
*
)
(
ArgType
)
)
;
template
<
typename
ThisType
typename
Ret
typename
ArgType
>
static
Ret
ReturnTypeHelper
(
Ret
(
ThisType
:
:
*
)
(
ArgType
)
const
)
;
template
<
typename
ThisType
typename
Ret
>
static
Ret
ReturnTypeHelper
(
Ret
(
ThisType
:
:
*
)
(
)
)
;
template
<
typename
ThisType
typename
Ret
>
static
Ret
ReturnTypeHelper
(
Ret
(
ThisType
:
:
*
)
(
)
const
)
;
template
<
typename
MethodType
>
struct
ReturnType
{
typedef
decltype
(
detail
:
:
ReturnTypeHelper
(
DeclVal
<
MethodType
>
(
)
)
)
Type
;
}
;
}
template
<
typename
MethodType
>
struct
TakesArgument
{
static
const
bool
value
=
decltype
(
detail
:
:
TakesArgumentHelper
(
DeclVal
<
MethodType
>
(
)
)
)
:
:
value
;
}
;
template
<
typename
MethodType
typename
TargetType
>
struct
ReturnTypeIs
{
static
const
bool
value
=
IsConvertible
<
typename
detail
:
:
ReturnType
<
MethodType
>
:
:
Type
TargetType
>
:
:
value
;
}
;
class
MozPromiseRefcountable
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MozPromiseRefcountable
)
protected
:
virtual
~
MozPromiseRefcountable
(
)
{
}
}
;
template
<
typename
T
>
class
MozPromiseHolder
;
template
<
typename
T
>
class
MozPromiseRequestHolder
;
template
<
typename
ResolveValueT
typename
RejectValueT
bool
IsExclusive
>
class
MozPromise
:
public
MozPromiseRefcountable
{
static
const
uint32_t
sMagic
=
0xcecace11
;
public
:
typedef
ResolveValueT
ResolveValueType
;
typedef
RejectValueT
RejectValueType
;
class
ResolveOrRejectValue
{
public
:
template
<
typename
ResolveValueType_
>
void
SetResolve
(
ResolveValueType_
&
&
aResolveValue
)
{
MOZ_ASSERT
(
IsNothing
(
)
)
;
mResolveValue
.
emplace
(
Forward
<
ResolveValueType_
>
(
aResolveValue
)
)
;
}
template
<
typename
RejectValueType_
>
void
SetReject
(
RejectValueType_
&
&
aRejectValue
)
{
MOZ_ASSERT
(
IsNothing
(
)
)
;
mRejectValue
.
emplace
(
Forward
<
RejectValueType_
>
(
aRejectValue
)
)
;
}
template
<
typename
ResolveValueType_
>
static
ResolveOrRejectValue
MakeResolve
(
ResolveValueType_
&
&
aResolveValue
)
{
ResolveOrRejectValue
val
;
val
.
SetResolve
(
Forward
<
ResolveValueType_
>
(
aResolveValue
)
)
;
return
val
;
}
template
<
typename
RejectValueType_
>
static
ResolveOrRejectValue
MakeReject
(
RejectValueType_
&
&
aRejectValue
)
{
ResolveOrRejectValue
val
;
val
.
SetReject
(
Forward
<
RejectValueType_
>
(
aRejectValue
)
)
;
return
val
;
}
bool
IsResolve
(
)
const
{
return
mResolveValue
.
isSome
(
)
;
}
bool
IsReject
(
)
const
{
return
mRejectValue
.
isSome
(
)
;
}
bool
IsNothing
(
)
const
{
return
mResolveValue
.
isNothing
(
)
&
&
mRejectValue
.
isNothing
(
)
;
}
const
ResolveValueType
&
ResolveValue
(
)
const
{
return
mResolveValue
.
ref
(
)
;
}
const
RejectValueType
&
RejectValue
(
)
const
{
return
mRejectValue
.
ref
(
)
;
}
private
:
Maybe
<
ResolveValueType
>
mResolveValue
;
Maybe
<
RejectValueType
>
mRejectValue
;
}
;
protected
:
MozPromise
(
const
char
*
aCreationSite
bool
aIsCompletionPromise
)
:
mCreationSite
(
aCreationSite
)
mMutex
(
"
MozPromise
Mutex
"
)
mHaveRequest
(
false
)
mIsCompletionPromise
(
aIsCompletionPromise
)
#
ifdef
PROMISE_DEBUG
mMagic4
(
mMutex
.
mLock
)
#
endif
{
PROMISE_LOG
(
"
%
s
creating
MozPromise
(
%
p
)
"
mCreationSite
this
)
;
}
public
:
class
Private
;
template
<
typename
ResolveValueType_
>
static
RefPtr
<
MozPromise
>
CreateAndResolve
(
ResolveValueType_
&
&
aResolveValue
const
char
*
aResolveSite
)
{
RefPtr
<
typename
MozPromise
:
:
Private
>
p
=
new
MozPromise
:
:
Private
(
aResolveSite
)
;
p
-
>
Resolve
(
Forward
<
ResolveValueType_
>
(
aResolveValue
)
aResolveSite
)
;
return
p
.
forget
(
)
;
}
template
<
typename
RejectValueType_
>
static
RefPtr
<
MozPromise
>
CreateAndReject
(
RejectValueType_
&
&
aRejectValue
const
char
*
aRejectSite
)
{
RefPtr
<
typename
MozPromise
:
:
Private
>
p
=
new
MozPromise
:
:
Private
(
aRejectSite
)
;
p
-
>
Reject
(
Forward
<
RejectValueType_
>
(
aRejectValue
)
aRejectSite
)
;
return
p
.
forget
(
)
;
}
typedef
MozPromise
<
nsTArray
<
ResolveValueType
>
RejectValueType
IsExclusive
>
AllPromiseType
;
private
:
class
AllPromiseHolder
:
public
MozPromiseRefcountable
{
public
:
explicit
AllPromiseHolder
(
size_t
aDependentPromises
)
:
mPromise
(
new
typename
AllPromiseType
:
:
Private
(
__func__
)
)
mOutstandingPromises
(
aDependentPromises
)
{
mResolveValues
.
SetLength
(
aDependentPromises
)
;
}
void
Resolve
(
size_t
aIndex
ResolveValueType
&
&
aResolveValue
)
{
if
(
!
mPromise
)
{
return
;
}
mResolveValues
[
aIndex
]
.
emplace
(
Move
(
aResolveValue
)
)
;
if
(
-
-
mOutstandingPromises
=
=
0
)
{
nsTArray
<
ResolveValueType
>
resolveValues
;
resolveValues
.
SetCapacity
(
mResolveValues
.
Length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
mResolveValues
.
Length
(
)
;
+
+
i
)
{
resolveValues
.
AppendElement
(
Move
(
mResolveValues
[
i
]
.
ref
(
)
)
)
;
}
mPromise
-
>
Resolve
(
Move
(
resolveValues
)
__func__
)
;
mPromise
=
nullptr
;
mResolveValues
.
Clear
(
)
;
}
}
void
Reject
(
RejectValueType
&
&
aRejectValue
)
{
if
(
!
mPromise
)
{
return
;
}
mPromise
-
>
Reject
(
Move
(
aRejectValue
)
__func__
)
;
mPromise
=
nullptr
;
mResolveValues
.
Clear
(
)
;
}
AllPromiseType
*
Promise
(
)
{
return
mPromise
;
}
private
:
nsTArray
<
Maybe
<
ResolveValueType
>
>
mResolveValues
;
RefPtr
<
typename
AllPromiseType
:
:
Private
>
mPromise
;
size_t
mOutstandingPromises
;
}
;
public
:
static
RefPtr
<
AllPromiseType
>
All
(
AbstractThread
*
aProcessingThread
nsTArray
<
RefPtr
<
MozPromise
>
>
&
aPromises
)
{
RefPtr
<
AllPromiseHolder
>
holder
=
new
AllPromiseHolder
(
aPromises
.
Length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
aPromises
.
Length
(
)
;
+
+
i
)
{
aPromises
[
i
]
-
>
Then
(
aProcessingThread
__func__
[
holder
i
]
(
ResolveValueType
aResolveValue
)
-
>
void
{
holder
-
>
Resolve
(
i
Move
(
aResolveValue
)
)
;
}
[
holder
]
(
RejectValueType
aRejectValue
)
-
>
void
{
holder
-
>
Reject
(
Move
(
aRejectValue
)
)
;
}
)
;
}
return
holder
-
>
Promise
(
)
;
}
class
Request
:
public
MozPromiseRefcountable
{
public
:
virtual
void
Disconnect
(
)
=
0
;
protected
:
Request
(
)
:
mComplete
(
false
)
mDisconnected
(
false
)
{
}
virtual
~
Request
(
)
{
}
bool
mComplete
;
bool
mDisconnected
;
}
;
protected
:
class
ThenValueBase
:
public
Request
{
friend
class
MozPromise
;
static
const
uint32_t
sMagic
=
0xfadece11
;
public
:
class
ResolveOrRejectRunnable
:
public
CancelableRunnable
{
public
:
ResolveOrRejectRunnable
(
ThenValueBase
*
aThenValue
MozPromise
*
aPromise
)
:
mThenValue
(
aThenValue
)
mPromise
(
aPromise
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mPromise
-
>
IsPending
(
)
)
;
}
~
ResolveOrRejectRunnable
(
)
{
if
(
mThenValue
)
{
mThenValue
-
>
AssertIsDead
(
)
;
}
}
NS_IMETHOD
Run
(
)
override
{
PROMISE_LOG
(
"
ResolveOrRejectRunnable
:
:
Run
(
)
[
this
=
%
p
]
"
this
)
;
mThenValue
-
>
DoResolveOrReject
(
mPromise
-
>
Value
(
)
)
;
mThenValue
=
nullptr
;
mPromise
=
nullptr
;
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
return
Run
(
)
;
}
private
:
RefPtr
<
ThenValueBase
>
mThenValue
;
RefPtr
<
MozPromise
>
mPromise
;
}
;
ThenValueBase
(
AbstractThread
*
aResponseTarget
const
char
*
aCallSite
)
:
mResponseTarget
(
aResponseTarget
)
mCallSite
(
aCallSite
)
{
MOZ_ASSERT
(
aResponseTarget
)
;
}
#
ifdef
PROMISE_DEBUG
~
ThenValueBase
(
)
{
mMagic1
=
0
;
mMagic2
=
0
;
}
#
endif
void
AssertIsDead
(
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
)
;
if
(
mCompletionPromise
)
{
mCompletionPromise
-
>
AssertIsDead
(
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
Request
:
:
mDisconnected
)
;
}
}
void
Dispatch
(
MozPromise
*
aPromise
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
)
;
aPromise
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
!
aPromise
-
>
IsPending
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
new
ResolveOrRejectRunnable
(
this
aPromise
)
;
PROMISE_LOG
(
"
%
s
Then
(
)
call
made
from
%
s
[
Runnable
=
%
p
Promise
=
%
p
ThenValue
=
%
p
]
"
aPromise
-
>
mValue
.
IsResolve
(
)
?
"
Resolving
"
:
"
Rejecting
"
mCallSite
r
.
get
(
)
aPromise
this
)
;
mResponseTarget
-
>
Dispatch
(
r
.
forget
(
)
AbstractThread
:
:
DontAssertDispatchSuccess
)
;
}
void
Disconnect
(
)
override
{
MOZ_DIAGNOSTIC_ASSERT
(
mResponseTarget
-
>
IsCurrentThreadIn
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
Request
:
:
mComplete
)
;
Request
:
:
mDisconnected
=
true
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mCompletionPromise
)
;
}
protected
:
virtual
already_AddRefed
<
MozPromise
>
DoResolveOrRejectInternal
(
const
ResolveOrRejectValue
&
aValue
)
=
0
;
void
DoResolveOrReject
(
const
ResolveOrRejectValue
&
aValue
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mResponseTarget
-
>
IsCurrentThreadIn
(
)
)
;
Request
:
:
mComplete
=
true
;
if
(
Request
:
:
mDisconnected
)
{
PROMISE_LOG
(
"
ThenValue
:
:
DoResolveOrReject
disconnected
-
bailing
out
[
this
=
%
p
]
"
this
)
;
return
;
}
RefPtr
<
MozPromise
>
result
=
DoResolveOrRejectInternal
(
aValue
)
;
if
(
RefPtr
<
Private
>
p
=
mCompletionPromise
.
forget
(
)
)
{
if
(
result
)
{
result
-
>
ChainTo
(
p
.
forget
(
)
"
<
chained
completion
promise
>
"
)
;
}
else
{
p
-
>
ResolveOrReject
(
aValue
"
<
completion
of
non
-
promise
-
returning
method
>
"
)
;
}
}
}
RefPtr
<
AbstractThread
>
mResponseTarget
;
#
ifdef
PROMISE_DEBUG
uint32_t
mMagic1
=
sMagic
;
#
endif
RefPtr
<
Private
>
mCompletionPromise
;
#
ifdef
PROMISE_DEBUG
uint32_t
mMagic2
=
sMagic
;
#
endif
const
char
*
mCallSite
;
}
;
template
<
typename
ThisType
typename
MethodType
typename
ValueType
>
static
typename
EnableIf
<
ReturnTypeIs
<
MethodType
RefPtr
<
MozPromise
>
>
:
:
value
&
&
TakesArgument
<
MethodType
>
:
:
value
already_AddRefed
<
MozPromise
>
>
:
:
Type
InvokeCallbackMethod
(
ThisType
*
aThisVal
MethodType
aMethod
ValueType
&
&
aValue
)
{
return
(
(
*
aThisVal
)
.
*
aMethod
)
(
Forward
<
ValueType
>
(
aValue
)
)
.
forget
(
)
;
}
template
<
typename
ThisType
typename
MethodType
typename
ValueType
>
static
typename
EnableIf
<
ReturnTypeIs
<
MethodType
void
>
:
:
value
&
&
TakesArgument
<
MethodType
>
:
:
value
already_AddRefed
<
MozPromise
>
>
:
:
Type
InvokeCallbackMethod
(
ThisType
*
aThisVal
MethodType
aMethod
ValueType
&
&
aValue
)
{
(
(
*
aThisVal
)
.
*
aMethod
)
(
Forward
<
ValueType
>
(
aValue
)
)
;
return
nullptr
;
}
template
<
typename
ThisType
typename
MethodType
typename
ValueType
>
static
typename
EnableIf
<
ReturnTypeIs
<
MethodType
RefPtr
<
MozPromise
>
>
:
:
value
&
&
!
TakesArgument
<
MethodType
>
:
:
value
already_AddRefed
<
MozPromise
>
>
:
:
Type
InvokeCallbackMethod
(
ThisType
*
aThisVal
MethodType
aMethod
ValueType
&
&
aValue
)
{
return
(
(
*
aThisVal
)
.
*
aMethod
)
(
)
.
forget
(
)
;
}
template
<
typename
ThisType
typename
MethodType
typename
ValueType
>
static
typename
EnableIf
<
ReturnTypeIs
<
MethodType
void
>
:
:
value
&
&
!
TakesArgument
<
MethodType
>
:
:
value
already_AddRefed
<
MozPromise
>
>
:
:
Type
InvokeCallbackMethod
(
ThisType
*
aThisVal
MethodType
aMethod
ValueType
&
&
aValue
)
{
(
(
*
aThisVal
)
.
*
aMethod
)
(
)
;
return
nullptr
;
}
template
<
typename
ThisType
typename
ResolveMethodType
typename
RejectMethodType
>
class
MethodThenValue
:
public
ThenValueBase
{
public
:
MethodThenValue
(
AbstractThread
*
aResponseTarget
ThisType
*
aThisVal
ResolveMethodType
aResolveMethod
RejectMethodType
aRejectMethod
const
char
*
aCallSite
)
:
ThenValueBase
(
aResponseTarget
aCallSite
)
mThisVal
(
aThisVal
)
mResolveMethod
(
aResolveMethod
)
mRejectMethod
(
aRejectMethod
)
{
}
void
Disconnect
(
)
override
{
ThenValueBase
:
:
Disconnect
(
)
;
mThisVal
=
nullptr
;
}
protected
:
already_AddRefed
<
MozPromise
>
DoResolveOrRejectInternal
(
const
ResolveOrRejectValue
&
aValue
)
override
{
RefPtr
<
MozPromise
>
completion
;
if
(
aValue
.
IsResolve
(
)
)
{
completion
=
InvokeCallbackMethod
(
mThisVal
.
get
(
)
mResolveMethod
aValue
.
ResolveValue
(
)
)
;
}
else
{
completion
=
InvokeCallbackMethod
(
mThisVal
.
get
(
)
mRejectMethod
aValue
.
RejectValue
(
)
)
;
}
mThisVal
=
nullptr
;
return
completion
.
forget
(
)
;
}
private
:
RefPtr
<
ThisType
>
mThisVal
;
ResolveMethodType
mResolveMethod
;
RejectMethodType
mRejectMethod
;
}
;
template
<
typename
ThisType
typename
ResolveRejectMethodType
>
class
MethodThenValue
<
ThisType
ResolveRejectMethodType
void
>
:
public
ThenValueBase
{
public
:
MethodThenValue
(
AbstractThread
*
aResponseTarget
ThisType
*
aThisVal
ResolveRejectMethodType
aResolveRejectMethod
const
char
*
aCallSite
)
:
ThenValueBase
(
aResponseTarget
aCallSite
)
mThisVal
(
aThisVal
)
mResolveRejectMethod
(
aResolveRejectMethod
)
{
}
void
Disconnect
(
)
override
{
ThenValueBase
:
:
Disconnect
(
)
;
mThisVal
=
nullptr
;
}
protected
:
already_AddRefed
<
MozPromise
>
DoResolveOrRejectInternal
(
const
ResolveOrRejectValue
&
aValue
)
override
{
RefPtr
<
MozPromise
>
completion
=
InvokeCallbackMethod
(
mThisVal
.
get
(
)
mResolveRejectMethod
aValue
)
;
mThisVal
=
nullptr
;
return
completion
.
forget
(
)
;
}
private
:
RefPtr
<
ThisType
>
mThisVal
;
ResolveRejectMethodType
mResolveRejectMethod
;
}
;
template
<
typename
ResolveFunction
typename
RejectFunction
>
class
FunctionThenValue
:
public
ThenValueBase
{
public
:
FunctionThenValue
(
AbstractThread
*
aResponseTarget
ResolveFunction
&
&
aResolveFunction
RejectFunction
&
&
aRejectFunction
const
char
*
aCallSite
)
:
ThenValueBase
(
aResponseTarget
aCallSite
)
{
mResolveFunction
.
emplace
(
Move
(
aResolveFunction
)
)
;
mRejectFunction
.
emplace
(
Move
(
aRejectFunction
)
)
;
}
void
Disconnect
(
)
override
{
ThenValueBase
:
:
Disconnect
(
)
;
mResolveFunction
.
reset
(
)
;
mRejectFunction
.
reset
(
)
;
}
protected
:
already_AddRefed
<
MozPromise
>
DoResolveOrRejectInternal
(
const
ResolveOrRejectValue
&
aValue
)
override
{
RefPtr
<
MozPromise
>
completion
;
if
(
aValue
.
IsResolve
(
)
)
{
completion
=
InvokeCallbackMethod
(
mResolveFunction
.
ptr
(
)
&
ResolveFunction
:
:
operator
(
)
aValue
.
ResolveValue
(
)
)
;
}
else
{
completion
=
InvokeCallbackMethod
(
mRejectFunction
.
ptr
(
)
&
RejectFunction
:
:
operator
(
)
aValue
.
RejectValue
(
)
)
;
}
mResolveFunction
.
reset
(
)
;
mRejectFunction
.
reset
(
)
;
return
completion
.
forget
(
)
;
}
private
:
Maybe
<
ResolveFunction
>
mResolveFunction
;
Maybe
<
RejectFunction
>
mRejectFunction
;
}
;
template
<
typename
ResolveRejectFunction
>
class
FunctionThenValue
<
ResolveRejectFunction
void
>
:
public
ThenValueBase
{
public
:
FunctionThenValue
(
AbstractThread
*
aResponseTarget
ResolveRejectFunction
&
&
aResolveRejectFunction
const
char
*
aCallSite
)
:
ThenValueBase
(
aResponseTarget
aCallSite
)
{
mResolveRejectFunction
.
emplace
(
Move
(
aResolveRejectFunction
)
)
;
}
void
Disconnect
(
)
override
{
ThenValueBase
:
:
Disconnect
(
)
;
mResolveRejectFunction
.
reset
(
)
;
}
protected
:
already_AddRefed
<
MozPromise
>
DoResolveOrRejectInternal
(
const
ResolveOrRejectValue
&
aValue
)
override
{
RefPtr
<
MozPromise
>
completion
=
InvokeCallbackMethod
(
mResolveRejectFunction
.
ptr
(
)
&
ResolveRejectFunction
:
:
operator
(
)
aValue
)
;
mResolveRejectFunction
.
reset
(
)
;
return
completion
.
forget
(
)
;
}
private
:
Maybe
<
ResolveRejectFunction
>
mResolveRejectFunction
;
}
;
public
:
void
ThenInternal
(
AbstractThread
*
aResponseThread
ThenValueBase
*
aThenValue
const
char
*
aCallSite
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
&
&
mMagic3
=
=
sMagic
&
&
mMagic4
=
=
mMutex
.
mLock
)
;
MOZ_ASSERT
(
aResponseThread
)
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsExclusive
|
|
!
mHaveRequest
)
;
mHaveRequest
=
true
;
PROMISE_LOG
(
"
%
s
invoking
Then
(
)
[
this
=
%
p
aThenValue
=
%
p
isPending
=
%
d
]
"
aCallSite
this
aThenValue
(
int
)
IsPending
(
)
)
;
if
(
!
IsPending
(
)
)
{
aThenValue
-
>
Dispatch
(
this
)
;
}
else
{
mThenValues
.
AppendElement
(
aThenValue
)
;
}
}
private
:
class
ThenCommand
{
friend
class
MozPromise
;
ThenCommand
(
AbstractThread
*
aResponseThread
const
char
*
aCallSite
already_AddRefed
<
ThenValueBase
>
aThenValue
MozPromise
*
aReceiver
)
:
mResponseThread
(
aResponseThread
)
mCallSite
(
aCallSite
)
mThenValue
(
aThenValue
)
mReceiver
(
aReceiver
)
{
MOZ_ASSERT
(
aResponseThread
)
;
}
ThenCommand
(
ThenCommand
&
&
aOther
)
=
default
;
public
:
~
ThenCommand
(
)
{
if
(
mThenValue
)
{
mReceiver
-
>
ThenInternal
(
mResponseThread
mThenValue
mCallSite
)
;
}
}
operator
RefPtr
<
MozPromise
>
(
)
{
RefPtr
<
ThenValueBase
>
thenValue
=
mThenValue
.
forget
(
)
;
RefPtr
<
MozPromise
:
:
Private
>
p
=
new
MozPromise
:
:
Private
(
"
<
completion
promise
>
"
true
)
;
thenValue
-
>
mCompletionPromise
=
p
;
mReceiver
-
>
ThenInternal
(
mResponseThread
thenValue
mCallSite
)
;
return
p
;
}
template
<
typename
.
.
.
Ts
>
auto
Then
(
Ts
&
&
.
.
.
aArgs
)
-
>
decltype
(
DeclVal
<
MozPromise
>
(
)
.
Then
(
Forward
<
Ts
>
(
aArgs
)
.
.
.
)
)
{
return
static_cast
<
RefPtr
<
MozPromise
>
>
(
*
this
)
-
>
Then
(
Forward
<
Ts
>
(
aArgs
)
.
.
.
)
;
}
void
Track
(
MozPromiseRequestHolder
<
MozPromise
>
&
aRequestHolder
)
{
RefPtr
<
ThenValueBase
>
thenValue
=
mThenValue
.
forget
(
)
;
mReceiver
-
>
ThenInternal
(
mResponseThread
thenValue
mCallSite
)
;
aRequestHolder
.
Track
(
thenValue
.
forget
(
)
)
;
}
ThenCommand
*
operator
-
>
(
)
{
return
this
;
}
private
:
AbstractThread
*
mResponseThread
;
const
char
*
mCallSite
;
RefPtr
<
ThenValueBase
>
mThenValue
;
MozPromise
*
mReceiver
;
}
;
public
:
template
<
typename
ThisType
typename
ResolveMethodType
typename
RejectMethodType
>
ThenCommand
Then
(
AbstractThread
*
aResponseThread
const
char
*
aCallSite
ThisType
*
aThisVal
ResolveMethodType
aResolveMethod
RejectMethodType
aRejectMethod
)
{
using
ThenType
=
MethodThenValue
<
ThisType
ResolveMethodType
RejectMethodType
>
;
RefPtr
<
ThenValueBase
>
thenValue
=
new
ThenType
(
aResponseThread
aThisVal
aResolveMethod
aRejectMethod
aCallSite
)
;
return
ThenCommand
(
aResponseThread
aCallSite
thenValue
.
forget
(
)
this
)
;
}
template
<
typename
ThisType
typename
ResolveRejectMethodType
>
ThenCommand
Then
(
AbstractThread
*
aResponseThread
const
char
*
aCallSite
ThisType
*
aThisVal
ResolveRejectMethodType
aResolveRejectMethod
)
{
using
ThenType
=
MethodThenValue
<
ThisType
ResolveRejectMethodType
void
>
;
RefPtr
<
ThenValueBase
>
thenValue
=
new
ThenType
(
aResponseThread
aThisVal
aResolveRejectMethod
aCallSite
)
;
return
ThenCommand
(
aResponseThread
aCallSite
thenValue
.
forget
(
)
this
)
;
}
template
<
typename
ResolveFunction
typename
RejectFunction
>
ThenCommand
Then
(
AbstractThread
*
aResponseThread
const
char
*
aCallSite
ResolveFunction
&
&
aResolveFunction
RejectFunction
&
&
aRejectFunction
)
{
using
ThenType
=
FunctionThenValue
<
ResolveFunction
RejectFunction
>
;
RefPtr
<
ThenValueBase
>
thenValue
=
new
ThenType
(
aResponseThread
Move
(
aResolveFunction
)
Move
(
aRejectFunction
)
aCallSite
)
;
return
ThenCommand
(
aResponseThread
aCallSite
thenValue
.
forget
(
)
this
)
;
}
template
<
typename
ResolveRejectFunction
>
ThenCommand
Then
(
AbstractThread
*
aResponseThread
const
char
*
aCallSite
ResolveRejectFunction
&
&
aResolveRejectFunction
)
{
using
ThenType
=
FunctionThenValue
<
ResolveRejectFunction
void
>
;
RefPtr
<
ThenValueBase
>
thenValue
=
new
ThenType
(
aResponseThread
Move
(
aResolveRejectFunction
)
aCallSite
)
;
return
ThenCommand
(
aResponseThread
aCallSite
thenValue
.
forget
(
)
this
)
;
}
void
ChainTo
(
already_AddRefed
<
Private
>
aChainedPromise
const
char
*
aCallSite
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsExclusive
|
|
!
mHaveRequest
)
;
mHaveRequest
=
true
;
RefPtr
<
Private
>
chainedPromise
=
aChainedPromise
;
PROMISE_LOG
(
"
%
s
invoking
Chain
(
)
[
this
=
%
p
chainedPromise
=
%
p
isPending
=
%
d
]
"
aCallSite
this
chainedPromise
.
get
(
)
(
int
)
IsPending
(
)
)
;
if
(
!
IsPending
(
)
)
{
ForwardTo
(
chainedPromise
)
;
}
else
{
mChainedPromises
.
AppendElement
(
chainedPromise
)
;
}
}
void
AssertIsDead
(
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
&
&
mMagic3
=
=
sMagic
&
&
mMagic4
=
=
mMutex
.
mLock
)
;
MutexAutoLock
lock
(
mMutex
)
;
for
(
auto
&
&
then
:
mThenValues
)
{
then
-
>
AssertIsDead
(
)
;
}
for
(
auto
&
&
chained
:
mChainedPromises
)
{
chained
-
>
AssertIsDead
(
)
;
}
}
protected
:
bool
IsPending
(
)
const
{
return
mValue
.
IsNothing
(
)
;
}
const
ResolveOrRejectValue
&
Value
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsPending
(
)
)
;
return
mValue
;
}
void
DispatchAll
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
for
(
size_t
i
=
0
;
i
<
mThenValues
.
Length
(
)
;
+
+
i
)
{
mThenValues
[
i
]
-
>
Dispatch
(
this
)
;
}
mThenValues
.
Clear
(
)
;
for
(
size_t
i
=
0
;
i
<
mChainedPromises
.
Length
(
)
;
+
+
i
)
{
ForwardTo
(
mChainedPromises
[
i
]
)
;
}
mChainedPromises
.
Clear
(
)
;
}
void
ForwardTo
(
Private
*
aOther
)
{
MOZ_ASSERT
(
!
IsPending
(
)
)
;
if
(
mValue
.
IsResolve
(
)
)
{
aOther
-
>
Resolve
(
mValue
.
ResolveValue
(
)
"
<
chained
promise
>
"
)
;
}
else
{
aOther
-
>
Reject
(
mValue
.
RejectValue
(
)
"
<
chained
promise
>
"
)
;
}
}
virtual
~
MozPromise
(
)
{
PROMISE_LOG
(
"
MozPromise
:
:
~
MozPromise
[
this
=
%
p
]
"
this
)
;
AssertIsDead
(
)
;
if
(
!
mIsCompletionPromise
)
{
MOZ_ASSERT
(
!
IsPending
(
)
)
;
MOZ_ASSERT
(
mThenValues
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mChainedPromises
.
IsEmpty
(
)
)
;
}
#
ifdef
PROMISE_DEBUG
mMagic1
=
0
;
mMagic2
=
0
;
mMagic3
=
0
;
mMagic4
=
nullptr
;
#
endif
}
;
const
char
*
mCreationSite
;
Mutex
mMutex
;
ResolveOrRejectValue
mValue
;
#
ifdef
PROMISE_DEBUG
uint32_t
mMagic1
=
sMagic
;
#
endif
nsTArray
<
RefPtr
<
ThenValueBase
>
>
mThenValues
;
#
ifdef
PROMISE_DEBUG
uint32_t
mMagic2
=
sMagic
;
#
endif
nsTArray
<
RefPtr
<
Private
>
>
mChainedPromises
;
#
ifdef
PROMISE_DEBUG
uint32_t
mMagic3
=
sMagic
;
#
endif
bool
mHaveRequest
;
const
bool
mIsCompletionPromise
;
#
ifdef
PROMISE_DEBUG
void
*
mMagic4
;
#
endif
}
;
template
<
typename
ResolveValueT
typename
RejectValueT
bool
IsExclusive
>
class
MozPromise
<
ResolveValueT
RejectValueT
IsExclusive
>
:
:
Private
:
public
MozPromise
<
ResolveValueT
RejectValueT
IsExclusive
>
{
public
:
explicit
Private
(
const
char
*
aCreationSite
bool
aIsCompletionPromise
=
false
)
:
MozPromise
(
aCreationSite
aIsCompletionPromise
)
{
}
template
<
typename
ResolveValueT_
>
void
Resolve
(
ResolveValueT_
&
&
aResolveValue
const
char
*
aResolveSite
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
&
&
mMagic3
=
=
sMagic
&
&
mMagic4
=
=
mMutex
.
mLock
)
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
IsPending
(
)
)
;
PROMISE_LOG
(
"
%
s
resolving
MozPromise
(
%
p
created
at
%
s
)
"
aResolveSite
this
mCreationSite
)
;
mValue
.
SetResolve
(
Forward
<
ResolveValueT_
>
(
aResolveValue
)
)
;
DispatchAll
(
)
;
}
template
<
typename
RejectValueT_
>
void
Reject
(
RejectValueT_
&
&
aRejectValue
const
char
*
aRejectSite
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
&
&
mMagic3
=
=
sMagic
&
&
mMagic4
=
=
mMutex
.
mLock
)
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
IsPending
(
)
)
;
PROMISE_LOG
(
"
%
s
rejecting
MozPromise
(
%
p
created
at
%
s
)
"
aRejectSite
this
mCreationSite
)
;
mValue
.
SetReject
(
Forward
<
RejectValueT_
>
(
aRejectValue
)
)
;
DispatchAll
(
)
;
}
template
<
typename
ResolveOrRejectValue_
>
void
ResolveOrReject
(
ResolveOrRejectValue_
&
&
aValue
const
char
*
aSite
)
{
PROMISE_ASSERT
(
mMagic1
=
=
sMagic
&
&
mMagic2
=
=
sMagic
&
&
mMagic3
=
=
sMagic
&
&
mMagic4
=
=
mMutex
.
mLock
)
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
IsPending
(
)
)
;
PROMISE_LOG
(
"
%
s
resolveOrRejecting
MozPromise
(
%
p
created
at
%
s
)
"
aSite
this
mCreationSite
)
;
mValue
=
Forward
<
ResolveOrRejectValue_
>
(
aValue
)
;
DispatchAll
(
)
;
}
}
;
typedef
MozPromise
<
bool
nsresult
false
>
GenericPromise
;
template
<
typename
PromiseType
>
class
MozPromiseHolder
{
public
:
MozPromiseHolder
(
)
:
mMonitor
(
nullptr
)
{
}
MozPromiseHolder
(
MozPromiseHolder
&
&
aOther
)
:
mMonitor
(
nullptr
)
mPromise
(
aOther
.
mPromise
.
forget
(
)
)
{
}
MozPromiseHolder
&
operator
=
(
MozPromiseHolder
&
&
aOther
)
{
MOZ_ASSERT
(
!
mMonitor
&
&
!
aOther
.
mMonitor
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mPromise
)
;
mPromise
=
aOther
.
mPromise
;
aOther
.
mPromise
=
nullptr
;
return
*
this
;
}
~
MozPromiseHolder
(
)
{
MOZ_ASSERT
(
!
mPromise
)
;
}
already_AddRefed
<
PromiseType
>
Ensure
(
const
char
*
aMethodName
)
{
if
(
mMonitor
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
}
if
(
!
mPromise
)
{
mPromise
=
new
(
typename
PromiseType
:
:
Private
)
(
aMethodName
)
;
}
RefPtr
<
PromiseType
>
p
=
mPromise
.
get
(
)
;
return
p
.
forget
(
)
;
}
void
SetMonitor
(
Monitor
*
aMonitor
)
{
mMonitor
=
aMonitor
;
}
bool
IsEmpty
(
)
const
{
if
(
mMonitor
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
}
return
!
mPromise
;
}
already_AddRefed
<
typename
PromiseType
:
:
Private
>
Steal
(
)
{
if
(
mMonitor
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
}
RefPtr
<
typename
PromiseType
:
:
Private
>
p
=
mPromise
;
mPromise
=
nullptr
;
return
p
.
forget
(
)
;
}
void
Resolve
(
const
typename
PromiseType
:
:
ResolveValueType
&
aResolveValue
const
char
*
aMethodName
)
{
if
(
mMonitor
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
}
MOZ_ASSERT
(
mPromise
)
;
mPromise
-
>
Resolve
(
aResolveValue
aMethodName
)
;
mPromise
=
nullptr
;
}
void
Resolve
(
typename
PromiseType
:
:
ResolveValueType
&
&
aResolveValue
const
char
*
aMethodName
)
{
if
(
mMonitor
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
}
MOZ_ASSERT
(
mPromise
)
;
mPromise
-
>
Resolve
(
Move
(
aResolveValue
)
aMethodName
)
;
mPromise
=
nullptr
;
}
void
ResolveIfExists
(
const
typename
PromiseType
:
:
ResolveValueType
&
aResolveValue
const
char
*
aMethodName
)
{
if
(
!
IsEmpty
(
)
)
{
Resolve
(
aResolveValue
aMethodName
)
;
}
}
void
ResolveIfExists
(
typename
PromiseType
:
:
ResolveValueType
&
&
aResolveValue
const
char
*
aMethodName
)
{
if
(
!
IsEmpty
(
)
)
{
Resolve
(
Move
(
aResolveValue
)
aMethodName
)
;
}
}
void
Reject
(
const
typename
PromiseType
:
:
RejectValueType
&
aRejectValue
const
char
*
aMethodName
)
{
if
(
mMonitor
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
}
MOZ_ASSERT
(
mPromise
)
;
mPromise
-
>
Reject
(
aRejectValue
aMethodName
)
;
mPromise
=
nullptr
;
}
void
Reject
(
typename
PromiseType
:
:
RejectValueType
&
&
aRejectValue
const
char
*
aMethodName
)
{
if
(
mMonitor
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
}
MOZ_ASSERT
(
mPromise
)
;
mPromise
-
>
Reject
(
Move
(
aRejectValue
)
aMethodName
)
;
mPromise
=
nullptr
;
}
void
RejectIfExists
(
const
typename
PromiseType
:
:
RejectValueType
&
aRejectValue
const
char
*
aMethodName
)
{
if
(
!
IsEmpty
(
)
)
{
Reject
(
aRejectValue
aMethodName
)
;
}
}
void
RejectIfExists
(
typename
PromiseType
:
:
RejectValueType
&
&
aRejectValue
const
char
*
aMethodName
)
{
if
(
!
IsEmpty
(
)
)
{
Reject
(
Move
(
aRejectValue
)
aMethodName
)
;
}
}
private
:
Monitor
*
mMonitor
;
RefPtr
<
typename
PromiseType
:
:
Private
>
mPromise
;
}
;
template
<
typename
PromiseType
>
class
MozPromiseRequestHolder
{
public
:
MozPromiseRequestHolder
(
)
{
}
~
MozPromiseRequestHolder
(
)
{
MOZ_ASSERT
(
!
mRequest
)
;
}
void
Track
(
RefPtr
<
typename
PromiseType
:
:
Request
>
&
&
aRequest
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
Exists
(
)
)
;
mRequest
=
Move
(
aRequest
)
;
}
void
Complete
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
Exists
(
)
)
;
mRequest
=
nullptr
;
}
void
Disconnect
(
)
{
MOZ_ASSERT
(
Exists
(
)
)
;
mRequest
-
>
Disconnect
(
)
;
mRequest
=
nullptr
;
}
void
DisconnectIfExists
(
)
{
if
(
Exists
(
)
)
{
Disconnect
(
)
;
}
}
bool
Exists
(
)
const
{
return
!
!
mRequest
;
}
private
:
RefPtr
<
typename
PromiseType
:
:
Request
>
mRequest
;
}
;
template
<
typename
Return
>
struct
IsMozPromise
:
FalseType
{
}
;
template
<
typename
ResolveValueT
typename
RejectValueT
bool
IsExclusive
>
struct
IsMozPromise
<
MozPromise
<
ResolveValueT
RejectValueT
IsExclusive
>
>
:
TrueType
{
}
;
namespace
detail
{
class
MethodCallBase
{
public
:
MethodCallBase
(
)
{
MOZ_COUNT_CTOR
(
MethodCallBase
)
;
}
virtual
~
MethodCallBase
(
)
{
MOZ_COUNT_DTOR
(
MethodCallBase
)
;
}
}
;
template
<
typename
PromiseType
typename
MethodType
typename
ThisType
typename
.
.
.
Storages
>
class
MethodCall
:
public
MethodCallBase
{
public
:
template
<
typename
.
.
.
Args
>
MethodCall
(
MethodType
aMethod
ThisType
*
aThisVal
Args
&
&
.
.
.
aArgs
)
:
mMethod
(
aMethod
)
mThisVal
(
aThisVal
)
mArgs
(
Forward
<
Args
>
(
aArgs
)
.
.
.
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
Storages
and
Args
should
have
equal
sizes
"
)
;
}
RefPtr
<
PromiseType
>
Invoke
(
)
{
return
mArgs
.
apply
(
mThisVal
.
get
(
)
mMethod
)
;
}
private
:
MethodType
mMethod
;
RefPtr
<
ThisType
>
mThisVal
;
RunnableMethodArguments
<
Storages
.
.
.
>
mArgs
;
}
;
template
<
typename
PromiseType
typename
MethodType
typename
ThisType
typename
.
.
.
Storages
>
class
ProxyRunnable
:
public
CancelableRunnable
{
public
:
ProxyRunnable
(
typename
PromiseType
:
:
Private
*
aProxyPromise
MethodCall
<
PromiseType
MethodType
ThisType
Storages
.
.
.
>
*
aMethodCall
)
:
mProxyPromise
(
aProxyPromise
)
mMethodCall
(
aMethodCall
)
{
}
NS_IMETHOD
Run
(
)
override
{
RefPtr
<
PromiseType
>
p
=
mMethodCall
-
>
Invoke
(
)
;
mMethodCall
=
nullptr
;
p
-
>
ChainTo
(
mProxyPromise
.
forget
(
)
"
<
Proxy
Promise
>
"
)
;
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
return
Run
(
)
;
}
private
:
RefPtr
<
typename
PromiseType
:
:
Private
>
mProxyPromise
;
nsAutoPtr
<
MethodCall
<
PromiseType
MethodType
ThisType
Storages
.
.
.
>
>
mMethodCall
;
}
;
template
<
typename
.
.
.
Storages
typename
PromiseType
typename
ThisType
typename
.
.
.
ArgTypes
typename
.
.
.
ActualArgTypes
>
static
RefPtr
<
PromiseType
>
InvokeAsyncImpl
(
AbstractThread
*
aTarget
ThisType
*
aThisVal
const
char
*
aCallerName
RefPtr
<
PromiseType
>
(
ThisType
:
:
*
aMethod
)
(
ArgTypes
.
.
.
)
ActualArgTypes
&
&
.
.
.
aArgs
)
{
MOZ_ASSERT
(
aTarget
)
;
typedef
RefPtr
<
PromiseType
>
(
ThisType
:
:
*
MethodType
)
(
ArgTypes
.
.
.
)
;
typedef
detail
:
:
MethodCall
<
PromiseType
MethodType
ThisType
Storages
.
.
.
>
MethodCallType
;
typedef
detail
:
:
ProxyRunnable
<
PromiseType
MethodType
ThisType
Storages
.
.
.
>
ProxyRunnableType
;
MethodCallType
*
methodCall
=
new
MethodCallType
(
aMethod
aThisVal
Forward
<
ActualArgTypes
>
(
aArgs
)
.
.
.
)
;
RefPtr
<
typename
PromiseType
:
:
Private
>
p
=
new
(
typename
PromiseType
:
:
Private
)
(
aCallerName
)
;
RefPtr
<
ProxyRunnableType
>
r
=
new
ProxyRunnableType
(
p
methodCall
)
;
aTarget
-
>
Dispatch
(
r
.
forget
(
)
)
;
return
p
.
forget
(
)
;
}
constexpr
bool
Any
(
)
{
return
false
;
}
template
<
typename
T1
>
constexpr
bool
Any
(
T1
a
)
{
return
static_cast
<
bool
>
(
a
)
;
}
template
<
typename
T1
typename
.
.
.
Ts
>
constexpr
bool
Any
(
T1
a
Ts
.
.
.
aOthers
)
{
return
a
|
|
Any
(
aOthers
.
.
.
)
;
}
}
template
<
typename
.
.
.
Storages
typename
PromiseType
typename
ThisType
typename
.
.
.
ArgTypes
typename
.
.
.
ActualArgTypes
typename
EnableIf
<
sizeof
.
.
.
(
Storages
)
!
=
0
int
>
:
:
Type
=
0
>
static
RefPtr
<
PromiseType
>
InvokeAsync
(
AbstractThread
*
aTarget
ThisType
*
aThisVal
const
char
*
aCallerName
RefPtr
<
PromiseType
>
(
ThisType
:
:
*
aMethod
)
(
ArgTypes
.
.
.
)
ActualArgTypes
&
&
.
.
.
aArgs
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
ArgTypes
)
"
Provided
Storages
and
method
'
s
ArgTypes
should
have
equal
sizes
"
)
;
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
ActualArgTypes
)
"
Provided
Storages
and
ActualArgTypes
should
have
equal
sizes
"
)
;
return
detail
:
:
InvokeAsyncImpl
<
Storages
.
.
.
>
(
aTarget
aThisVal
aCallerName
aMethod
Forward
<
ActualArgTypes
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
.
.
.
Storages
typename
PromiseType
typename
ThisType
typename
.
.
.
ArgTypes
typename
.
.
.
ActualArgTypes
typename
EnableIf
<
sizeof
.
.
.
(
Storages
)
=
=
0
int
>
:
:
Type
=
0
>
static
RefPtr
<
PromiseType
>
InvokeAsync
(
AbstractThread
*
aTarget
ThisType
*
aThisVal
const
char
*
aCallerName
RefPtr
<
PromiseType
>
(
ThisType
:
:
*
aMethod
)
(
ArgTypes
.
.
.
)
ActualArgTypes
&
&
.
.
.
aArgs
)
{
static_assert
(
(
!
detail
:
:
Any
(
IsReference
<
ArgTypes
>
:
:
value
.
.
.
)
)
&
&
(
!
detail
:
:
Any
(
IsPointer
<
ArgTypes
>
:
:
value
.
.
.
)
)
"
Cannot
pass
reference
/
pointer
types
through
InvokeAsync
Storages
must
be
provided
"
)
;
static_assert
(
sizeof
.
.
.
(
ArgTypes
)
=
=
sizeof
.
.
.
(
ActualArgTypes
)
"
Method
'
s
ArgTypes
and
ActualArgTypes
should
have
equal
sizes
"
)
;
return
detail
:
:
InvokeAsyncImpl
<
StoreCopyPassByRRef
<
ArgTypes
>
.
.
.
>
(
aTarget
aThisVal
aCallerName
aMethod
Forward
<
ActualArgTypes
>
(
aArgs
)
.
.
.
)
;
}
namespace
detail
{
template
<
typename
Function
typename
PromiseType
>
class
ProxyFunctionRunnable
:
public
CancelableRunnable
{
typedef
typename
Decay
<
Function
>
:
:
Type
FunctionStorage
;
public
:
template
<
typename
F
>
ProxyFunctionRunnable
(
typename
PromiseType
:
:
Private
*
aProxyPromise
F
&
&
aFunction
)
:
mProxyPromise
(
aProxyPromise
)
mFunction
(
new
FunctionStorage
(
Forward
<
F
>
(
aFunction
)
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
RefPtr
<
PromiseType
>
p
=
(
*
mFunction
)
(
)
;
mFunction
=
nullptr
;
p
-
>
ChainTo
(
mProxyPromise
.
forget
(
)
"
<
Proxy
Promise
>
"
)
;
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
return
Run
(
)
;
}
private
:
RefPtr
<
typename
PromiseType
:
:
Private
>
mProxyPromise
;
UniquePtr
<
FunctionStorage
>
mFunction
;
}
;
struct
AllowInvokeAsyncFunctionLVRef
{
}
;
template
<
typename
Function
>
static
auto
InvokeAsync
(
AbstractThread
*
aTarget
const
char
*
aCallerName
AllowInvokeAsyncFunctionLVRef
Function
&
&
aFunction
)
-
>
decltype
(
aFunction
(
)
)
{
static_assert
(
IsRefcountedSmartPointer
<
decltype
(
aFunction
(
)
)
>
:
:
value
&
&
IsMozPromise
<
typename
RemoveSmartPointer
<
decltype
(
aFunction
(
)
)
>
:
:
Type
>
:
:
value
"
Function
object
must
return
RefPtr
<
MozPromise
>
"
)
;
MOZ_ASSERT
(
aTarget
)
;
typedef
typename
RemoveSmartPointer
<
decltype
(
aFunction
(
)
)
>
:
:
Type
PromiseType
;
typedef
detail
:
:
ProxyFunctionRunnable
<
Function
PromiseType
>
ProxyRunnableType
;
RefPtr
<
typename
PromiseType
:
:
Private
>
p
=
new
(
typename
PromiseType
:
:
Private
)
(
aCallerName
)
;
RefPtr
<
ProxyRunnableType
>
r
=
new
ProxyRunnableType
(
p
Forward
<
Function
>
(
aFunction
)
)
;
aTarget
-
>
Dispatch
(
r
.
forget
(
)
)
;
return
p
.
forget
(
)
;
}
}
template
<
typename
Function
>
static
auto
InvokeAsync
(
AbstractThread
*
aTarget
const
char
*
aCallerName
Function
&
&
aFunction
)
-
>
decltype
(
aFunction
(
)
)
{
static_assert
(
!
IsLvalueReference
<
Function
>
:
:
value
"
Function
object
must
not
be
passed
by
lvalue
-
ref
(
to
avoid
"
"
unplanned
copies
)
;
Consider
move
(
)
ing
the
object
.
"
)
;
return
detail
:
:
InvokeAsync
(
aTarget
aCallerName
detail
:
:
AllowInvokeAsyncFunctionLVRef
(
)
Forward
<
Function
>
(
aFunction
)
)
;
}
#
undef
PROMISE_LOG
#
undef
PROMISE_ASSERT
#
undef
PROMISE_DEBUG
}
#
endif
