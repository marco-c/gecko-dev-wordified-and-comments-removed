#
include
"
mozilla
/
ThreadEventQueue
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
LabeledEventQueue
.
h
"
#
include
"
LeakRefPtr
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
PrioritizedEventQueue
.
h
"
#
include
"
ThreadEventTarget
.
h
"
using
namespace
mozilla
;
template
<
class
InnerQueueT
>
class
ThreadEventQueue
<
InnerQueueT
>
:
:
NestedSink
:
public
ThreadTargetSink
{
public
:
NestedSink
(
EventQueue
*
aQueue
ThreadEventQueue
*
aOwner
)
:
mQueue
(
aQueue
)
mOwner
(
aOwner
)
{
}
bool
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventPriority
aPriority
)
final
override
{
return
mOwner
-
>
PutEventInternal
(
Move
(
aEvent
)
aPriority
this
)
;
}
void
Disconnect
(
const
MutexAutoLock
&
aProofOfLock
)
final
override
{
mQueue
=
nullptr
;
}
private
:
friend
class
ThreadEventQueue
;
EventQueue
*
mQueue
;
RefPtr
<
ThreadEventQueue
>
mOwner
;
}
;
template
<
class
InnerQueueT
>
ThreadEventQueue
<
InnerQueueT
>
:
:
ThreadEventQueue
(
UniquePtr
<
InnerQueueT
>
aQueue
)
:
mBaseQueue
(
Move
(
aQueue
)
)
mLock
(
"
ThreadEventQueue
"
)
mEventsAvailable
(
mLock
"
EventsAvail
"
)
{
static_assert
(
IsBaseOf
<
AbstractEventQueue
InnerQueueT
>
:
:
value
"
InnerQueueT
must
be
an
AbstractEventQueue
subclass
"
)
;
}
template
<
class
InnerQueueT
>
ThreadEventQueue
<
InnerQueueT
>
:
:
~
ThreadEventQueue
(
)
{
MOZ_ASSERT
(
mNestedQueues
.
IsEmpty
(
)
)
;
}
template
<
class
InnerQueueT
>
bool
ThreadEventQueue
<
InnerQueueT
>
:
:
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventPriority
aPriority
)
{
return
PutEventInternal
(
Move
(
aEvent
)
aPriority
nullptr
)
;
}
template
<
class
InnerQueueT
>
bool
ThreadEventQueue
<
InnerQueueT
>
:
:
PutEventInternal
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventPriority
aPriority
NestedSink
*
aSink
)
{
LeakRefPtr
<
nsIRunnable
>
event
(
Move
(
aEvent
)
)
;
nsCOMPtr
<
nsIThreadObserver
>
obs
;
{
if
(
InnerQueueT
:
:
SupportsPrioritization
)
{
auto
*
e
=
event
.
get
(
)
;
if
(
nsCOMPtr
<
nsIRunnablePriority
>
runnablePrio
=
do_QueryInterface
(
e
)
)
{
uint32_t
prio
=
nsIRunnablePriority
:
:
PRIORITY_NORMAL
;
runnablePrio
-
>
GetPriority
(
&
prio
)
;
if
(
prio
=
=
nsIRunnablePriority
:
:
PRIORITY_HIGH
)
{
aPriority
=
EventPriority
:
:
High
;
}
else
if
(
prio
=
=
nsIRunnablePriority
:
:
PRIORITY_INPUT
)
{
aPriority
=
EventPriority
:
:
Input
;
}
}
}
MutexAutoLock
lock
(
mLock
)
;
if
(
mEventsAreDoomed
)
{
return
false
;
}
if
(
aSink
)
{
if
(
!
aSink
-
>
mQueue
)
{
return
false
;
}
aSink
-
>
mQueue
-
>
PutEvent
(
event
.
take
(
)
aPriority
lock
)
;
}
else
{
mBaseQueue
-
>
PutEvent
(
event
.
take
(
)
aPriority
lock
)
;
}
mEventsAvailable
.
Notify
(
)
;
obs
=
mObserver
;
}
if
(
obs
)
{
obs
-
>
OnDispatchedEvent
(
)
;
}
return
true
;
}
template
<
class
InnerQueueT
>
already_AddRefed
<
nsIRunnable
>
ThreadEventQueue
<
InnerQueueT
>
:
:
GetEvent
(
bool
aMayWait
EventPriority
*
aPriority
)
{
MutexAutoLock
lock
(
mLock
)
;
nsCOMPtr
<
nsIRunnable
>
event
;
for
(
;
;
)
{
if
(
mNestedQueues
.
IsEmpty
(
)
)
{
event
=
mBaseQueue
-
>
GetEvent
(
aPriority
lock
)
;
}
else
{
event
=
mNestedQueues
.
LastElement
(
)
.
mQueue
-
>
GetEvent
(
aPriority
lock
)
;
}
if
(
event
|
|
!
aMayWait
)
{
break
;
}
mEventsAvailable
.
Wait
(
)
;
}
return
event
.
forget
(
)
;
}
template
<
class
InnerQueueT
>
bool
ThreadEventQueue
<
InnerQueueT
>
:
:
HasPendingEvent
(
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
mNestedQueues
.
IsEmpty
(
)
)
{
return
mBaseQueue
-
>
HasReadyEvent
(
lock
)
;
}
else
{
return
mNestedQueues
.
LastElement
(
)
.
mQueue
-
>
HasReadyEvent
(
lock
)
;
}
}
template
<
class
InnerQueueT
>
bool
ThreadEventQueue
<
InnerQueueT
>
:
:
ShutdownIfNoPendingEvents
(
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
mNestedQueues
.
IsEmpty
(
)
&
&
mBaseQueue
-
>
IsEmpty
(
lock
)
)
{
mEventsAreDoomed
=
true
;
return
true
;
}
return
false
;
}
template
<
class
InnerQueueT
>
void
ThreadEventQueue
<
InnerQueueT
>
:
:
EnableInputEventPrioritization
(
)
{
MutexAutoLock
lock
(
mLock
)
;
mBaseQueue
-
>
EnableInputEventPrioritization
(
lock
)
;
}
template
<
class
InnerQueueT
>
void
ThreadEventQueue
<
InnerQueueT
>
:
:
FlushInputEventPrioritization
(
)
{
MutexAutoLock
lock
(
mLock
)
;
mBaseQueue
-
>
FlushInputEventPrioritization
(
lock
)
;
}
template
<
class
InnerQueueT
>
void
ThreadEventQueue
<
InnerQueueT
>
:
:
SuspendInputEventPrioritization
(
)
{
MutexAutoLock
lock
(
mLock
)
;
mBaseQueue
-
>
SuspendInputEventPrioritization
(
lock
)
;
}
template
<
class
InnerQueueT
>
void
ThreadEventQueue
<
InnerQueueT
>
:
:
ResumeInputEventPrioritization
(
)
{
MutexAutoLock
lock
(
mLock
)
;
mBaseQueue
-
>
ResumeInputEventPrioritization
(
lock
)
;
}
template
<
class
InnerQueueT
>
already_AddRefed
<
nsISerialEventTarget
>
ThreadEventQueue
<
InnerQueueT
>
:
:
PushEventQueue
(
)
{
auto
queue
=
MakeUnique
<
EventQueue
>
(
)
;
RefPtr
<
NestedSink
>
sink
=
new
NestedSink
(
queue
.
get
(
)
this
)
;
RefPtr
<
ThreadEventTarget
>
eventTarget
=
new
ThreadEventTarget
(
sink
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mLock
)
;
mNestedQueues
.
AppendElement
(
NestedQueueItem
(
Move
(
queue
)
eventTarget
)
)
;
return
eventTarget
.
forget
(
)
;
}
template
<
class
InnerQueueT
>
void
ThreadEventQueue
<
InnerQueueT
>
:
:
PopEventQueue
(
nsIEventTarget
*
aTarget
)
{
MutexAutoLock
lock
(
mLock
)
;
MOZ_ASSERT
(
!
mNestedQueues
.
IsEmpty
(
)
)
;
NestedQueueItem
&
item
=
mNestedQueues
.
LastElement
(
)
;
MOZ_ASSERT
(
aTarget
=
=
item
.
mEventTarget
)
;
item
.
mEventTarget
-
>
Disconnect
(
lock
)
;
AbstractEventQueue
*
prevQueue
=
mNestedQueues
.
Length
(
)
=
=
1
?
static_cast
<
AbstractEventQueue
*
>
(
mBaseQueue
.
get
(
)
)
:
static_cast
<
AbstractEventQueue
*
>
(
mNestedQueues
[
mNestedQueues
.
Length
(
)
-
2
]
.
mQueue
.
get
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
;
EventPriority
prio
;
while
(
(
event
=
item
.
mQueue
-
>
GetEvent
(
&
prio
lock
)
)
)
{
prevQueue
-
>
PutEvent
(
event
.
forget
(
)
prio
lock
)
;
}
mNestedQueues
.
RemoveElementAt
(
mNestedQueues
.
Length
(
)
-
1
)
;
}
template
<
class
InnerQueueT
>
already_AddRefed
<
nsIThreadObserver
>
ThreadEventQueue
<
InnerQueueT
>
:
:
GetObserver
(
)
{
MutexAutoLock
lock
(
mLock
)
;
return
do_AddRef
(
mObserver
)
;
}
template
<
class
InnerQueueT
>
already_AddRefed
<
nsIThreadObserver
>
ThreadEventQueue
<
InnerQueueT
>
:
:
GetObserverOnThread
(
)
{
return
do_AddRef
(
mObserver
)
;
}
template
<
class
InnerQueueT
>
void
ThreadEventQueue
<
InnerQueueT
>
:
:
SetObserver
(
nsIThreadObserver
*
aObserver
)
{
MutexAutoLock
lock
(
mLock
)
;
mObserver
=
aObserver
;
}
namespace
mozilla
{
template
class
ThreadEventQueue
<
EventQueue
>
;
template
class
ThreadEventQueue
<
PrioritizedEventQueue
<
EventQueue
>
>
;
template
class
ThreadEventQueue
<
PrioritizedEventQueue
<
LabeledEventQueue
>
>
;
}
