#
ifndef
nsThread_h__
#
define
nsThread_h__
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
PerformanceCounter
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TaskDispatcher
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsIDirectTaskDispatcher
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
class
CycleCollectedJSContext
;
class
DelayedRunnable
;
class
SynchronizedEventQueue
;
class
ThreadEventQueue
;
class
ThreadEventTarget
;
template
<
typename
T
size_t
Length
>
class
Array
;
}
using
mozilla
:
:
NotNull
;
class
nsIRunnable
;
class
nsLocalExecutionRecord
;
class
nsThreadEnumerator
;
class
nsThreadShutdownContext
;
#
define
LONGTASK_BUSY_WINDOW_MS
50
namespace
mozilla
{
class
PerformanceCounterState
{
public
:
explicit
PerformanceCounterState
(
const
uint32_t
&
aNestedEventLoopDepthRef
bool
aIsMainThread
)
:
mNestedEventLoopDepth
(
aNestedEventLoopDepthRef
)
mIsMainThread
(
aIsMainThread
)
mLastLongTaskEnd
(
TimeStamp
:
:
Now
(
)
)
mLastLongNonIdleTaskEnd
(
mLastLongTaskEnd
)
{
}
class
Snapshot
{
public
:
Snapshot
(
uint32_t
aOldEventLoopDepth
PerformanceCounter
*
aCounter
bool
aOldIsIdleRunnable
)
:
mOldEventLoopDepth
(
aOldEventLoopDepth
)
mOldPerformanceCounter
(
aCounter
)
mOldIsIdleRunnable
(
aOldIsIdleRunnable
)
{
}
Snapshot
(
const
Snapshot
&
)
=
default
;
Snapshot
(
Snapshot
&
&
)
=
default
;
private
:
friend
class
PerformanceCounterState
;
const
uint32_t
mOldEventLoopDepth
;
RefPtr
<
PerformanceCounter
>
mOldPerformanceCounter
;
const
bool
mOldIsIdleRunnable
;
}
;
Snapshot
RunnableWillRun
(
PerformanceCounter
*
Counter
TimeStamp
aNow
bool
aIsIdleRunnable
)
;
void
RunnableDidRun
(
Snapshot
&
&
aSnapshot
)
;
const
TimeStamp
&
LastLongTaskEnd
(
)
const
{
return
mLastLongTaskEnd
;
}
const
TimeStamp
&
LastLongNonIdleTaskEnd
(
)
const
{
return
mLastLongNonIdleTaskEnd
;
}
private
:
void
MaybeReportAccumulatedTime
(
TimeStamp
aNow
)
;
bool
IsNestedRunnable
(
)
const
{
return
mNestedEventLoopDepth
>
mCurrentEventLoopDepth
;
}
uint32_t
mCurrentEventLoopDepth
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
const
uint32_t
&
mNestedEventLoopDepth
;
bool
mCurrentRunnableIsIdleRunnable
=
false
;
const
bool
mIsMainThread
;
TimeStamp
mCurrentTimeSliceStart
;
TimeStamp
mLastLongTaskEnd
;
TimeStamp
mLastLongNonIdleTaskEnd
;
RefPtr
<
PerformanceCounter
>
mCurrentPerformanceCounter
;
}
;
}
class
nsThread
:
public
nsIThreadInternal
public
nsISupportsPriority
public
nsIDirectTaskDispatcher
private
mozilla
:
:
LinkedListElement
<
nsThread
>
{
friend
mozilla
:
:
LinkedList
<
nsThread
>
;
friend
mozilla
:
:
LinkedListElement
<
nsThread
>
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIEVENTTARGET_FULL
NS_DECL_NSITHREAD
NS_DECL_NSITHREADINTERNAL
NS_DECL_NSISUPPORTSPRIORITY
NS_DECL_NSIDIRECTTASKDISPATCHER
enum
MainThreadFlag
{
MAIN_THREAD
NOT_MAIN_THREAD
}
;
nsThread
(
NotNull
<
mozilla
:
:
SynchronizedEventQueue
*
>
aQueue
MainThreadFlag
aMainThread
uint32_t
aStackSize
)
;
private
:
nsThread
(
)
;
public
:
nsresult
Init
(
const
nsACString
&
aName
)
;
nsresult
InitCurrentThread
(
)
;
void
GetThreadName
(
nsACString
&
aNameBuffer
)
;
void
SetThreadNameInternal
(
const
nsACString
&
aName
)
;
private
:
void
InitCommon
(
)
;
public
:
PRThread
*
GetPRThread
(
)
const
{
return
mThread
;
}
const
void
*
StackBase
(
)
const
{
return
mStackBase
;
}
size_t
StackSize
(
)
const
{
return
mStackSize
;
}
uint32_t
ThreadId
(
)
const
{
return
mThreadId
;
}
bool
ShutdownRequired
(
)
{
return
mShutdownRequired
;
}
void
SetPoolThreadFreePtr
(
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
*
aPtr
)
{
mIsAPoolThreadFree
=
aPtr
;
}
void
SetScriptObserver
(
mozilla
:
:
CycleCollectedJSContext
*
aScriptObserver
)
;
uint32_t
RecursionDepth
(
)
const
;
void
ShutdownComplete
(
NotNull
<
nsThreadShutdownContext
*
>
aContext
)
;
void
WaitForAllAsynchronousShutdowns
(
)
;
static
const
uint32_t
kRunnableNameBufSize
=
1000
;
static
mozilla
:
:
Array
<
char
kRunnableNameBufSize
>
sMainThreadRunnableName
;
mozilla
:
:
SynchronizedEventQueue
*
EventQueue
(
)
{
return
mEvents
.
get
(
)
;
}
bool
ShuttingDown
(
)
const
{
return
mShutdownContext
!
=
nullptr
;
}
static
bool
GetLabeledRunnableName
(
nsIRunnable
*
aEvent
nsACString
&
aName
mozilla
:
:
EventQueuePriority
aPriority
)
;
virtual
mozilla
:
:
PerformanceCounter
*
GetPerformanceCounter
(
nsIRunnable
*
aEvent
)
const
;
static
mozilla
:
:
PerformanceCounter
*
GetPerformanceCounterBase
(
nsIRunnable
*
aEvent
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
size_t
ShallowSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
size_t
SizeOfEventQueues
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
static
nsThreadEnumerator
Enumerate
(
)
;
nsLocalExecutionRecord
EnterLocalExecution
(
)
;
void
SetUseHangMonitor
(
bool
aValue
)
{
MOZ_ASSERT
(
IsOnCurrentThread
(
)
)
;
mUseHangMonitor
=
aValue
;
}
private
:
void
DoMainThreadSpecificProcessing
(
)
const
;
protected
:
friend
class
nsThreadShutdownEvent
;
friend
class
nsThreadEnumerator
;
virtual
~
nsThread
(
)
;
static
void
ThreadFunc
(
void
*
aArg
)
;
already_AddRefed
<
nsIThreadObserver
>
GetObserver
(
)
{
nsIThreadObserver
*
obs
;
nsThread
:
:
GetObserver
(
&
obs
)
;
return
already_AddRefed
<
nsIThreadObserver
>
(
obs
)
;
}
already_AddRefed
<
nsThreadShutdownContext
>
ShutdownInternal
(
bool
aSync
)
;
friend
class
nsThreadManager
;
friend
class
nsThreadPool
;
static
mozilla
:
:
OffTheBooksMutex
&
ThreadListMutex
(
)
;
static
mozilla
:
:
LinkedList
<
nsThread
>
&
ThreadList
(
)
;
void
AddToThreadList
(
)
;
void
MaybeRemoveFromThreadList
(
)
;
RefPtr
<
mozilla
:
:
SynchronizedEventQueue
>
mEvents
;
RefPtr
<
mozilla
:
:
ThreadEventTarget
>
mEventTarget
;
uint32_t
mOutstandingShutdownContexts
;
RefPtr
<
nsThreadShutdownContext
>
mShutdownContext
;
mozilla
:
:
CycleCollectedJSContext
*
mScriptObserver
;
mozilla
:
:
DataMutex
<
nsCString
>
mThreadName
;
void
*
mStackBase
=
nullptr
;
uint32_t
mStackSize
;
uint32_t
mThreadId
;
uint32_t
mNestedEventLoopDepth
;
mozilla
:
:
Atomic
<
bool
>
mShutdownRequired
;
int8_t
mPriority
;
const
bool
mIsMainThread
;
bool
mUseHangMonitor
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
>
*
mIsAPoolThreadFree
;
bool
mCanInvokeJS
;
mozilla
:
:
TimeDuration
mLastEventDelay
;
mozilla
:
:
TimeStamp
mLastEventStart
;
#
ifdef
EARLY_BETA_OR_EARLIER
nsCString
mNameForWakeupTelemetry
;
mozilla
:
:
TimeStamp
mLastWakeupCheckTime
;
uint32_t
mWakeupCount
=
0
;
#
endif
mozilla
:
:
PerformanceCounterState
mPerformanceCounterState
;
bool
mIsInLocalExecutionMode
=
false
;
mozilla
:
:
SimpleTaskQueue
mDirectTasks
;
}
;
class
nsThreadShutdownContext
final
:
public
nsIThreadShutdown
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSITHREADSHUTDOWN
private
:
friend
class
nsThread
;
friend
class
nsThreadShutdownEvent
;
friend
class
nsThreadShutdownAckEvent
;
nsThreadShutdownContext
(
NotNull
<
nsThread
*
>
aTerminatingThread
nsThread
*
aJoiningThread
)
:
mTerminatingThread
(
aTerminatingThread
)
mTerminatingPRThread
(
aTerminatingThread
-
>
GetPRThread
(
)
)
mJoiningThreadMutex
(
"
nsThreadShutdownContext
:
:
mJoiningThreadMutex
"
)
mJoiningThread
(
aJoiningThread
)
{
}
~
nsThreadShutdownContext
(
)
=
default
;
void
MarkCompleted
(
)
;
NotNull
<
RefPtr
<
nsThread
>
>
const
mTerminatingThread
;
PRThread
*
const
mTerminatingPRThread
;
bool
mCompleted
=
false
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mCompletionCallbacks
;
mozilla
:
:
Mutex
mJoiningThreadMutex
;
RefPtr
<
nsThread
>
mJoiningThread
GUARDED_BY
(
mJoiningThreadMutex
)
;
bool
mThreadLeaked
GUARDED_BY
(
mJoiningThreadMutex
)
=
false
;
}
;
class
MOZ_RAII
nsLocalExecutionGuard
final
{
public
:
MOZ_IMPLICIT
nsLocalExecutionGuard
(
nsLocalExecutionRecord
&
&
aLocalExecutionRecord
)
;
nsLocalExecutionGuard
(
const
nsLocalExecutionGuard
&
)
=
delete
;
nsLocalExecutionGuard
(
nsLocalExecutionGuard
&
&
)
=
delete
;
~
nsLocalExecutionGuard
(
)
;
nsCOMPtr
<
nsISerialEventTarget
>
GetEventTarget
(
)
const
{
return
mLocalEventTarget
;
}
private
:
mozilla
:
:
SynchronizedEventQueue
&
mEventQueueStack
;
nsCOMPtr
<
nsISerialEventTarget
>
mLocalEventTarget
;
bool
&
mLocalExecutionFlag
;
}
;
class
MOZ_TEMPORARY_CLASS
nsLocalExecutionRecord
final
{
private
:
friend
class
nsThread
;
friend
class
nsLocalExecutionGuard
;
nsLocalExecutionRecord
(
mozilla
:
:
SynchronizedEventQueue
&
aEventQueueStack
bool
&
aLocalExecutionFlag
)
:
mEventQueueStack
(
aEventQueueStack
)
mLocalExecutionFlag
(
aLocalExecutionFlag
)
{
}
nsLocalExecutionRecord
(
nsLocalExecutionRecord
&
&
)
=
default
;
public
:
nsLocalExecutionRecord
(
const
nsLocalExecutionRecord
&
)
=
delete
;
private
:
mozilla
:
:
SynchronizedEventQueue
&
mEventQueueStack
;
bool
&
mLocalExecutionFlag
;
}
;
class
MOZ_STACK_CLASS
nsThreadEnumerator
final
{
public
:
nsThreadEnumerator
(
)
=
default
;
auto
begin
(
)
{
return
nsThread
:
:
ThreadList
(
)
.
begin
(
)
;
}
auto
end
(
)
{
return
nsThread
:
:
ThreadList
(
)
.
end
(
)
;
}
private
:
mozilla
:
:
OffTheBooksMutexAutoLock
mMal
{
nsThread
:
:
ThreadListMutex
(
)
}
;
}
;
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
ANDROID
)
&
&
!
defined
(
DEBUG
)
&
&
HAVE_UALARM
&
&
\
defined
(
_GNU_SOURCE
)
#
define
MOZ_CANARY
extern
int
sCanaryOutputFD
;
#
endif
#
endif
