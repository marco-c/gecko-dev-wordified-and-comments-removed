#
ifndef
nsThread_h__
#
define
nsThread_h__
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsIIdlePeriod
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsEventQueue
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Array
.
h
"
namespace
mozilla
{
class
CycleCollectedJSContext
;
}
using
mozilla
:
:
NotNull
;
class
nsThread
:
public
nsIThreadInternal
public
nsISupportsPriority
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIEVENTTARGET_FULL
NS_DECL_NSITHREAD
NS_DECL_NSITHREADINTERNAL
NS_DECL_NSISUPPORTSPRIORITY
enum
MainThreadFlag
{
MAIN_THREAD
NOT_MAIN_THREAD
}
;
nsThread
(
MainThreadFlag
aMainThread
uint32_t
aStackSize
)
;
nsresult
Init
(
const
nsACString
&
aName
=
NS_LITERAL_CSTRING
(
"
"
)
)
;
nsresult
InitCurrentThread
(
)
;
PRThread
*
GetPRThread
(
)
{
return
mThread
;
}
bool
ShutdownRequired
(
)
{
return
mShutdownRequired
;
}
void
ClearObservers
(
)
{
mEventObservers
.
Clear
(
)
;
}
void
SetScriptObserver
(
mozilla
:
:
CycleCollectedJSContext
*
aScriptObserver
)
;
uint32_t
RecursionDepth
(
)
const
;
void
ShutdownComplete
(
NotNull
<
struct
nsThreadShutdownContext
*
>
aContext
)
;
void
WaitForAllAsynchronousShutdowns
(
)
;
#
ifdef
MOZ_CRASHREPORTER
enum
class
ShouldSaveMemoryReport
{
kMaybeReport
kForceReport
}
;
static
bool
SaveMemoryReportNearOOM
(
ShouldSaveMemoryReport
aShouldSave
)
;
#
endif
static
const
uint32_t
kRunnableNameBufSize
=
1000
;
static
mozilla
:
:
Array
<
char
kRunnableNameBufSize
>
sMainThreadRunnableName
;
bool
HasPendingInputEvents
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mozilla
:
:
MutexAutoLock
lock
(
mLock
)
;
return
mEventsRoot
.
HasPendingEventsInInputQueue
(
lock
)
;
}
private
:
void
DoMainThreadSpecificProcessing
(
bool
aReallyWait
)
;
mozilla
:
:
TimeStamp
GetIdleDeadline
(
)
;
void
GetIdleEvent
(
nsIRunnable
*
*
aEvent
mozilla
:
:
MutexAutoLock
&
aProofOfLock
)
;
void
GetEvent
(
bool
aWait
nsIRunnable
*
*
aEvent
unsigned
short
*
aPriority
mozilla
:
:
MutexAutoLock
&
aProofOfLock
)
;
protected
:
class
nsChainedEventQueue
;
class
nsNestedEventTarget
;
friend
class
nsNestedEventTarget
;
friend
class
nsThreadShutdownEvent
;
virtual
~
nsThread
(
)
;
bool
ShuttingDown
(
)
{
return
mShutdownContext
!
=
nullptr
;
}
static
void
ThreadFunc
(
void
*
aArg
)
;
already_AddRefed
<
nsIThreadObserver
>
GetObserver
(
)
{
nsIThreadObserver
*
obs
;
nsThread
:
:
GetObserver
(
&
obs
)
;
return
already_AddRefed
<
nsIThreadObserver
>
(
obs
)
;
}
nsresult
PutEvent
(
nsIRunnable
*
aEvent
nsNestedEventTarget
*
aTarget
)
;
nsresult
PutEvent
(
already_AddRefed
<
nsIRunnable
>
aEvent
nsNestedEventTarget
*
aTarget
)
;
nsresult
DispatchInternal
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
nsNestedEventTarget
*
aTarget
)
;
struct
nsThreadShutdownContext
*
ShutdownInternal
(
bool
aSync
)
;
class
nsChainedEventQueue
{
public
:
explicit
nsChainedEventQueue
(
mozilla
:
:
Mutex
&
aLock
)
:
mNext
(
nullptr
)
mEventsAvailable
(
aLock
"
[
nsChainedEventQueue
.
mEventsAvailable
]
"
)
mIsInputPrioritizationEnabled
(
false
)
mIsReadyToPrioritizeEvents
(
false
)
mProcessHighPriorityQueueRunnable
(
false
)
{
mNormalQueue
=
mozilla
:
:
MakeUnique
<
nsEventQueue
>
(
mEventsAvailable
nsEventQueue
:
:
eSharedCondVarQueue
)
;
mInputQueue
=
mozilla
:
:
MakeUnique
<
nsEventQueue
>
(
mEventsAvailable
nsEventQueue
:
:
eSharedCondVarQueue
)
;
mHighQueue
=
mozilla
:
:
MakeUnique
<
nsEventQueue
>
(
mEventsAvailable
nsEventQueue
:
:
eSharedCondVarQueue
)
;
}
void
EnablePrioritization
(
mozilla
:
:
MutexAutoLock
&
aProofOfLock
)
;
bool
IsPrioritizationEnabled
(
)
{
return
mIsInputPrioritizationEnabled
;
}
bool
GetEvent
(
bool
aMayWait
nsIRunnable
*
*
aEvent
unsigned
short
*
aPriority
mozilla
:
:
MutexAutoLock
&
aProofOfLock
)
{
return
mIsReadyToPrioritizeEvents
?
GetNormalOrInputOrHighPriorityEvent
(
aMayWait
aEvent
aPriority
aProofOfLock
)
:
GetNormalOrHighPriorityEvent
(
aMayWait
aEvent
aPriority
aProofOfLock
)
;
}
void
PutEvent
(
nsIRunnable
*
aEvent
mozilla
:
:
MutexAutoLock
&
aProofOfLock
)
{
RefPtr
<
nsIRunnable
>
event
(
aEvent
)
;
PutEvent
(
event
.
forget
(
)
aProofOfLock
)
;
}
void
PutEvent
(
already_AddRefed
<
nsIRunnable
>
aEvent
mozilla
:
:
MutexAutoLock
&
aProofOfLock
)
;
bool
HasPendingEvent
(
mozilla
:
:
MutexAutoLock
&
aProofOfLock
)
{
return
mNormalQueue
-
>
HasPendingEvent
(
aProofOfLock
)
|
|
mInputQueue
-
>
HasPendingEvent
(
aProofOfLock
)
|
|
mHighQueue
-
>
HasPendingEvent
(
aProofOfLock
)
;
}
bool
HasPendingEventsInInputQueue
(
mozilla
:
:
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mIsInputPrioritizationEnabled
)
;
return
mInputQueue
-
>
HasPendingEvent
(
aProofOfLock
)
;
}
nsChainedEventQueue
*
mNext
;
RefPtr
<
nsNestedEventTarget
>
mEventTarget
;
private
:
bool
GetNormalOrInputOrHighPriorityEvent
(
bool
aMayWait
nsIRunnable
*
*
aEvent
unsigned
short
*
aPriority
mozilla
:
:
MutexAutoLock
&
aProofOfLock
)
;
bool
GetNormalOrHighPriorityEvent
(
bool
aMayWait
nsIRunnable
*
*
aEvent
unsigned
short
*
aPriority
mozilla
:
:
MutexAutoLock
&
aProofOfLock
)
;
class
EnablePrioritizationRunnable
final
:
public
nsIRunnable
{
nsChainedEventQueue
*
mEventQueue
;
public
:
NS_DECL_ISUPPORTS
explicit
EnablePrioritizationRunnable
(
nsChainedEventQueue
*
aQueue
)
:
mEventQueue
(
aQueue
)
{
}
NS_IMETHOD
Run
(
)
override
{
mEventQueue
-
>
mIsReadyToPrioritizeEvents
=
true
;
return
NS_OK
;
}
private
:
~
EnablePrioritizationRunnable
(
)
{
}
}
;
static
void
SetPriorityIfNotNull
(
unsigned
short
*
aPriority
short
aValue
)
{
if
(
aPriority
)
{
*
aPriority
=
aValue
;
}
}
mozilla
:
:
CondVar
mEventsAvailable
;
mozilla
:
:
TimeStamp
mInputHandlingStartTime
;
mozilla
:
:
UniquePtr
<
nsEventQueue
>
mNormalQueue
;
mozilla
:
:
UniquePtr
<
nsEventQueue
>
mInputQueue
;
mozilla
:
:
UniquePtr
<
nsEventQueue
>
mHighQueue
;
bool
mIsInputPrioritizationEnabled
;
bool
mIsReadyToPrioritizeEvents
;
bool
mProcessHighPriorityQueueRunnable
;
}
;
class
nsNestedEventTarget
final
:
public
nsIEventTarget
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIEVENTTARGET_FULL
nsNestedEventTarget
(
NotNull
<
nsThread
*
>
aThread
NotNull
<
nsChainedEventQueue
*
>
aQueue
)
:
mThread
(
aThread
)
mQueue
(
aQueue
)
{
}
NotNull
<
RefPtr
<
nsThread
>
>
mThread
;
nsChainedEventQueue
*
mQueue
;
private
:
~
nsNestedEventTarget
(
)
{
}
}
;
mozilla
:
:
Mutex
mLock
;
nsCOMPtr
<
nsIThreadObserver
>
mObserver
;
mozilla
:
:
CycleCollectedJSContext
*
mScriptObserver
;
nsAutoTObserverArray
<
NotNull
<
nsCOMPtr
<
nsIThreadObserver
>
>
2
>
mEventObservers
;
NotNull
<
nsChainedEventQueue
*
>
mEvents
;
nsChainedEventQueue
mEventsRoot
;
nsCOMPtr
<
nsIIdlePeriod
>
mIdlePeriod
;
mozilla
:
:
CondVar
mIdleEventsAvailable
;
nsEventQueue
mIdleEvents
;
int32_t
mPriority
;
PRThread
*
mThread
;
uint32_t
mNestedEventLoopDepth
;
uint32_t
mStackSize
;
struct
nsThreadShutdownContext
*
mShutdownContext
;
nsTArray
<
nsAutoPtr
<
struct
nsThreadShutdownContext
>
>
mRequestedShutdownContexts
;
bool
mShutdownRequired
;
bool
mEventsAreDoomed
;
MainThreadFlag
mIsMainThread
;
mozilla
:
:
TimeStamp
mLastUnlabeledRunnable
;
bool
mCanInvokeJS
;
bool
mHasPendingEventsPromisedIdleEvent
;
#
ifndef
RELEASE_OR_BETA
mozilla
:
:
TimeStamp
mNextIdleDeadline
;
#
endif
}
;
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
ANDROID
)
&
&
!
defined
(
DEBUG
)
&
&
HAVE_UALARM
\
&
&
defined
(
_GNU_SOURCE
)
#
define
MOZ_CANARY
extern
int
sCanaryOutputFD
;
#
endif
#
endif
