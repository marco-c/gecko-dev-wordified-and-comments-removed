#
ifndef
nsThreadUtils_h__
#
define
nsThreadUtils_h__
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsICancelableRunnable
.
h
"
#
include
"
nsIDiscardableRunnable
.
h
"
#
include
"
nsIIdlePeriod
.
h
"
#
include
"
nsIIdleRunnable
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIThreadManager
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsString
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
prthread
.
h
"
class
MessageLoop
;
class
nsIThread
;
extern
nsresult
NS_NewNamedThread
(
const
nsACString
&
aName
nsIThread
*
*
aResult
nsIRunnable
*
aInitialEvent
=
nullptr
uint32_t
aStackSize
=
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
)
;
extern
nsresult
NS_NewNamedThread
(
const
nsACString
&
aName
nsIThread
*
*
aResult
already_AddRefed
<
nsIRunnable
>
aInitialEvent
uint32_t
aStackSize
=
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
)
;
template
<
size_t
LEN
>
inline
nsresult
NS_NewNamedThread
(
const
char
(
&
aName
)
[
LEN
]
nsIThread
*
*
aResult
already_AddRefed
<
nsIRunnable
>
aInitialEvent
uint32_t
aStackSize
=
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
)
{
static_assert
(
LEN
<
=
16
"
Thread
name
must
be
no
more
than
16
characters
"
)
;
return
NS_NewNamedThread
(
nsDependentCString
(
aName
LEN
-
1
)
aResult
std
:
:
move
(
aInitialEvent
)
aStackSize
)
;
}
template
<
size_t
LEN
>
inline
nsresult
NS_NewNamedThread
(
const
char
(
&
aName
)
[
LEN
]
nsIThread
*
*
aResult
nsIRunnable
*
aInitialEvent
=
nullptr
uint32_t
aStackSize
=
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
aInitialEvent
;
static_assert
(
LEN
<
=
16
"
Thread
name
must
be
no
more
than
16
characters
"
)
;
return
NS_NewNamedThread
(
nsDependentCString
(
aName
LEN
-
1
)
aResult
event
.
forget
(
)
aStackSize
)
;
}
extern
nsresult
NS_GetCurrentThread
(
nsIThread
*
*
aResult
)
;
extern
nsresult
NS_DispatchToCurrentThread
(
nsIRunnable
*
aEvent
)
;
extern
nsresult
NS_DispatchToCurrentThread
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
)
;
extern
nsresult
NS_DispatchToMainThread
(
nsIRunnable
*
aEvent
uint32_t
aDispatchFlags
=
NS_DISPATCH_NORMAL
)
;
extern
nsresult
NS_DispatchToMainThread
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
uint32_t
aDispatchFlags
=
NS_DISPATCH_NORMAL
)
;
extern
nsresult
NS_DelayedDispatchToCurrentThread
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
uint32_t
aDelayMs
)
;
extern
nsresult
NS_DispatchToCurrentThreadQueue
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
mozilla
:
:
EventQueuePriority
aQueue
)
;
extern
nsresult
NS_DispatchToMainThreadQueue
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
mozilla
:
:
EventQueuePriority
aQueue
)
;
extern
nsresult
NS_DispatchToCurrentThreadQueue
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
uint32_t
aTimeout
mozilla
:
:
EventQueuePriority
aQueue
)
;
extern
nsresult
NS_DispatchToThreadQueue
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
nsIThread
*
aThread
mozilla
:
:
EventQueuePriority
aQueue
)
;
extern
nsresult
NS_DispatchToThreadQueue
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
uint32_t
aTimeout
nsIThread
*
aThread
mozilla
:
:
EventQueuePriority
aQueue
)
;
#
ifndef
XPCOM_GLUE_AVOID_NSPR
extern
nsresult
NS_ProcessPendingEvents
(
nsIThread
*
aThread
PRIntervalTime
aTimeout
=
PR_INTERVAL_NO_TIMEOUT
)
;
#
endif
extern
bool
NS_HasPendingEvents
(
nsIThread
*
aThread
=
nullptr
)
;
extern
bool
NS_ProcessNextEvent
(
nsIThread
*
aThread
=
nullptr
bool
aMayWait
=
true
)
;
extern
bool
NS_IsInCompositorThread
(
)
;
extern
bool
NS_IsInCanvasThreadOrWorker
(
)
;
extern
bool
NS_IsInVRThread
(
)
;
inline
already_AddRefed
<
nsIThread
>
do_GetCurrentThread
(
)
{
nsIThread
*
thread
=
nullptr
;
NS_GetCurrentThread
(
&
thread
)
;
return
already_AddRefed
<
nsIThread
>
(
thread
)
;
}
inline
already_AddRefed
<
nsIThread
>
do_GetMainThread
(
)
{
nsIThread
*
thread
=
nullptr
;
NS_GetMainThread
(
&
thread
)
;
return
already_AddRefed
<
nsIThread
>
(
thread
)
;
}
extern
nsIThread
*
NS_GetCurrentThread
(
)
;
extern
nsIThread
*
NS_GetCurrentThreadNoCreate
(
)
;
extern
void
NS_SetCurrentThreadName
(
const
char
*
aName
)
;
#
ifndef
XPCOM_GLUE_AVOID_NSPR
namespace
mozilla
{
class
IdlePeriod
:
public
nsIIdlePeriod
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIIDLEPERIOD
IdlePeriod
(
)
=
default
;
protected
:
virtual
~
IdlePeriod
(
)
=
default
;
private
:
IdlePeriod
(
const
IdlePeriod
&
)
=
delete
;
IdlePeriod
&
operator
=
(
const
IdlePeriod
&
)
=
delete
;
IdlePeriod
&
operator
=
(
const
IdlePeriod
&
&
)
=
delete
;
}
;
enum
class
RunnableKind
{
Standard
Cancelable
Idle
IdleWithTimer
}
;
#
ifndef
RELEASE_OR_BETA
#
define
MOZ_COLLECTING_RUNNABLE_TELEMETRY
#
endif
class
Runnable
:
public
nsIRunnable
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
public
nsINamed
#
endif
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIRUNNABLE
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
NS_DECL_NSINAMED
#
endif
Runnable
(
)
=
delete
;
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
explicit
Runnable
(
const
char
*
aName
)
:
mName
(
aName
)
{
}
#
else
explicit
Runnable
(
const
char
*
aName
)
{
}
#
endif
protected
:
virtual
~
Runnable
(
)
=
default
;
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
const
char
*
mName
=
nullptr
;
#
endif
private
:
Runnable
(
const
Runnable
&
)
=
delete
;
Runnable
&
operator
=
(
const
Runnable
&
)
=
delete
;
Runnable
&
operator
=
(
const
Runnable
&
&
)
=
delete
;
}
;
class
DiscardableRunnable
:
public
Runnable
public
nsIDiscardableRunnable
{
public
:
NS_DECL_ISUPPORTS_INHERITED
void
OnDiscard
(
)
override
{
}
DiscardableRunnable
(
)
=
delete
;
explicit
DiscardableRunnable
(
const
char
*
aName
)
:
Runnable
(
aName
)
{
}
protected
:
virtual
~
DiscardableRunnable
(
)
=
default
;
private
:
DiscardableRunnable
(
const
DiscardableRunnable
&
)
=
delete
;
DiscardableRunnable
&
operator
=
(
const
DiscardableRunnable
&
)
=
delete
;
DiscardableRunnable
&
operator
=
(
const
DiscardableRunnable
&
&
)
=
delete
;
}
;
class
CancelableRunnable
:
public
DiscardableRunnable
public
nsICancelableRunnable
{
public
:
NS_DECL_ISUPPORTS_INHERITED
void
OnDiscard
(
)
override
;
virtual
nsresult
Cancel
(
)
override
=
0
;
CancelableRunnable
(
)
=
delete
;
explicit
CancelableRunnable
(
const
char
*
aName
)
:
DiscardableRunnable
(
aName
)
{
}
protected
:
virtual
~
CancelableRunnable
(
)
=
default
;
private
:
CancelableRunnable
(
const
CancelableRunnable
&
)
=
delete
;
CancelableRunnable
&
operator
=
(
const
CancelableRunnable
&
)
=
delete
;
CancelableRunnable
&
operator
=
(
const
CancelableRunnable
&
&
)
=
delete
;
}
;
class
IdleRunnable
:
public
DiscardableRunnable
public
nsIIdleRunnable
{
public
:
NS_DECL_ISUPPORTS_INHERITED
explicit
IdleRunnable
(
const
char
*
aName
)
:
DiscardableRunnable
(
aName
)
{
}
protected
:
virtual
~
IdleRunnable
(
)
=
default
;
private
:
IdleRunnable
(
const
IdleRunnable
&
)
=
delete
;
IdleRunnable
&
operator
=
(
const
IdleRunnable
&
)
=
delete
;
IdleRunnable
&
operator
=
(
const
IdleRunnable
&
&
)
=
delete
;
}
;
class
CancelableIdleRunnable
:
public
CancelableRunnable
public
nsIIdleRunnable
{
public
:
NS_DECL_ISUPPORTS_INHERITED
CancelableIdleRunnable
(
)
:
CancelableRunnable
(
"
CancelableIdleRunnable
"
)
{
}
explicit
CancelableIdleRunnable
(
const
char
*
aName
)
:
CancelableRunnable
(
aName
)
{
}
protected
:
virtual
~
CancelableIdleRunnable
(
)
=
default
;
private
:
CancelableIdleRunnable
(
const
CancelableIdleRunnable
&
)
=
delete
;
CancelableIdleRunnable
&
operator
=
(
const
CancelableIdleRunnable
&
)
=
delete
;
CancelableIdleRunnable
&
operator
=
(
const
CancelableIdleRunnable
&
&
)
=
delete
;
}
;
class
PrioritizableRunnable
:
public
Runnable
public
nsIRunnablePriority
{
public
:
PrioritizableRunnable
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
uint32_t
aPriority
)
;
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
;
#
endif
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIRUNNABLE
NS_DECL_NSIRUNNABLEPRIORITY
protected
:
virtual
~
PrioritizableRunnable
(
)
=
default
;
;
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
uint32_t
mPriority
;
}
;
extern
already_AddRefed
<
nsIRunnable
>
CreateRenderBlockingRunnable
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
namespace
detail
{
template
<
typename
StoredFunction
>
class
RunnableFunction
:
public
Runnable
{
public
:
template
<
typename
F
>
explicit
RunnableFunction
(
const
char
*
aName
F
&
&
aFunction
)
:
Runnable
(
aName
)
mFunction
(
std
:
:
forward
<
F
>
(
aFunction
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
static_assert
(
std
:
:
is_void_v
<
decltype
(
mFunction
(
)
)
>
"
The
lambda
must
return
void
!
"
)
;
mFunction
(
)
;
return
NS_OK
;
}
private
:
StoredFunction
mFunction
;
}
;
template
<
typename
Function
>
using
RunnableFunctionImpl
=
typename
detail
:
:
RunnableFunction
<
std
:
:
remove_reference_t
<
Function
>
>
;
}
namespace
detail
{
template
<
typename
CVRemoved
>
struct
IsRefcountedSmartPointerHelper
:
std
:
:
false_type
{
}
;
template
<
typename
Pointee
>
struct
IsRefcountedSmartPointerHelper
<
RefPtr
<
Pointee
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
Pointee
>
struct
IsRefcountedSmartPointerHelper
<
nsCOMPtr
<
Pointee
>
>
:
std
:
:
true_type
{
}
;
}
template
<
typename
T
>
struct
IsRefcountedSmartPointer
:
detail
:
:
IsRefcountedSmartPointerHelper
<
std
:
:
remove_cv_t
<
T
>
>
{
}
;
namespace
detail
{
template
<
typename
T
typename
CVRemoved
>
struct
RemoveSmartPointerHelper
{
typedef
T
Type
;
}
;
template
<
typename
T
typename
Pointee
>
struct
RemoveSmartPointerHelper
<
T
RefPtr
<
Pointee
>
>
{
typedef
Pointee
Type
;
}
;
template
<
typename
T
typename
Pointee
>
struct
RemoveSmartPointerHelper
<
T
nsCOMPtr
<
Pointee
>
>
{
typedef
Pointee
Type
;
}
;
}
template
<
typename
T
>
struct
RemoveSmartPointer
:
detail
:
:
RemoveSmartPointerHelper
<
T
std
:
:
remove_cv_t
<
T
>
>
{
}
;
namespace
detail
{
template
<
typename
T
typename
CVRemoved
>
struct
RemoveRawOrSmartPointerHelper
{
typedef
T
Type
;
}
;
template
<
typename
T
typename
Pointee
>
struct
RemoveRawOrSmartPointerHelper
<
T
Pointee
*
>
{
typedef
Pointee
Type
;
}
;
template
<
typename
T
typename
Pointee
>
struct
RemoveRawOrSmartPointerHelper
<
T
RefPtr
<
Pointee
>
>
{
typedef
Pointee
Type
;
}
;
template
<
typename
T
typename
Pointee
>
struct
RemoveRawOrSmartPointerHelper
<
T
nsCOMPtr
<
Pointee
>
>
{
typedef
Pointee
Type
;
}
;
}
template
<
typename
T
>
struct
RemoveRawOrSmartPointer
:
detail
:
:
RemoveRawOrSmartPointerHelper
<
T
std
:
:
remove_cv_t
<
T
>
>
{
}
;
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
Runnable
*
p
)
{
return
static_cast
<
nsIRunnable
*
>
(
p
)
;
}
template
<
typename
Function
>
already_AddRefed
<
mozilla
:
:
Runnable
>
NS_NewRunnableFunction
(
const
char
*
aName
Function
&
&
aFunction
)
{
return
do_AddRef
(
new
mozilla
:
:
detail
:
:
RunnableFunctionImpl
<
Function
>
(
aName
std
:
:
forward
<
Function
>
(
aFunction
)
)
)
;
}
template
<
typename
Function
>
already_AddRefed
<
mozilla
:
:
CancelableRunnable
>
NS_NewCancelableRunnableFunction
(
const
char
*
aName
Function
&
&
aFunc
)
{
class
FuncCancelableRunnable
final
:
public
mozilla
:
:
CancelableRunnable
{
public
:
static_assert
(
std
:
:
is_void_v
<
decltype
(
std
:
:
declval
<
std
:
:
remove_reference_t
<
Function
>
>
(
)
(
)
)
>
)
;
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
FuncCancelableRunnable
CancelableRunnable
)
explicit
FuncCancelableRunnable
(
const
char
*
aName
Function
&
&
aFunc
)
:
CancelableRunnable
{
aName
}
mFunc
{
mozilla
:
:
Some
(
std
:
:
forward
<
Function
>
(
aFunc
)
)
}
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mFunc
)
{
(
*
mFunc
)
(
)
;
}
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
mFunc
.
reset
(
)
;
return
NS_OK
;
}
private
:
~
FuncCancelableRunnable
(
)
=
default
;
mozilla
:
:
Maybe
<
std
:
:
remove_reference_t
<
Function
>
>
mFunc
;
}
;
return
mozilla
:
:
MakeAndAddRef
<
FuncCancelableRunnable
>
(
aName
std
:
:
forward
<
Function
>
(
aFunc
)
)
;
}
namespace
mozilla
{
namespace
detail
{
template
<
RunnableKind
Kind
>
class
TimerBehaviour
{
public
:
nsITimer
*
GetTimer
(
)
{
return
nullptr
;
}
void
CancelTimer
(
)
{
}
protected
:
~
TimerBehaviour
(
)
=
default
;
}
;
template
<
>
class
TimerBehaviour
<
RunnableKind
:
:
IdleWithTimer
>
{
public
:
nsITimer
*
GetTimer
(
)
{
if
(
!
mTimer
)
{
mTimer
=
NS_NewTimer
(
)
;
}
return
mTimer
;
}
void
CancelTimer
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
}
protected
:
~
TimerBehaviour
(
)
{
CancelTimer
(
)
;
}
private
:
nsCOMPtr
<
nsITimer
>
mTimer
;
}
;
}
}
template
<
class
ClassType
typename
ReturnType
=
void
bool
Owning
=
true
mozilla
:
:
RunnableKind
Kind
=
mozilla
:
:
RunnableKind
:
:
Standard
>
class
nsRunnableMethod
:
public
std
:
:
conditional_t
<
Kind
=
=
mozilla
:
:
RunnableKind
:
:
Standard
mozilla
:
:
Runnable
std
:
:
conditional_t
<
Kind
=
=
mozilla
:
:
RunnableKind
:
:
Cancelable
mozilla
:
:
CancelableRunnable
mozilla
:
:
CancelableIdleRunnable
>
>
protected
mozilla
:
:
detail
:
:
TimerBehaviour
<
Kind
>
{
using
BaseType
=
std
:
:
conditional_t
<
Kind
=
=
mozilla
:
:
RunnableKind
:
:
Standard
mozilla
:
:
Runnable
std
:
:
conditional_t
<
Kind
=
=
mozilla
:
:
RunnableKind
:
:
Cancelable
mozilla
:
:
CancelableRunnable
mozilla
:
:
CancelableIdleRunnable
>
>
;
public
:
nsRunnableMethod
(
const
char
*
aName
)
:
BaseType
(
aName
)
{
}
virtual
void
Revoke
(
)
=
0
;
template
<
typename
OtherReturnType
>
class
ReturnTypeEnforcer
{
public
:
typedef
int
ReturnTypeIsSafe
;
}
;
template
<
class
T
>
class
ReturnTypeEnforcer
<
already_AddRefed
<
T
>
>
{
}
;
typedef
typename
ReturnTypeEnforcer
<
ReturnType
>
:
:
ReturnTypeIsSafe
check
;
}
;
template
<
class
ClassType
bool
Owning
>
struct
nsRunnableMethodReceiver
{
RefPtr
<
ClassType
>
mObj
;
explicit
nsRunnableMethodReceiver
(
ClassType
*
aObj
)
:
mObj
(
aObj
)
{
}
explicit
nsRunnableMethodReceiver
(
RefPtr
<
ClassType
>
&
&
aObj
)
:
mObj
(
std
:
:
move
(
aObj
)
)
{
}
~
nsRunnableMethodReceiver
(
)
{
Revoke
(
)
;
}
ClassType
*
Get
(
)
const
{
return
mObj
.
get
(
)
;
}
void
Revoke
(
)
{
mObj
=
nullptr
;
}
}
;
template
<
class
ClassType
>
struct
nsRunnableMethodReceiver
<
ClassType
false
>
{
ClassType
*
MOZ_NON_OWNING_REF
mObj
;
explicit
nsRunnableMethodReceiver
(
ClassType
*
aObj
)
:
mObj
(
aObj
)
{
}
ClassType
*
Get
(
)
const
{
return
mObj
;
}
void
Revoke
(
)
{
mObj
=
nullptr
;
}
}
;
static
inline
constexpr
bool
IsIdle
(
mozilla
:
:
RunnableKind
aKind
)
{
return
aKind
=
=
mozilla
:
:
RunnableKind
:
:
Idle
|
|
aKind
=
=
mozilla
:
:
RunnableKind
:
:
IdleWithTimer
;
}
template
<
typename
PtrType
typename
Method
bool
Owning
mozilla
:
:
RunnableKind
Kind
>
struct
nsRunnableMethodTraits
;
template
<
typename
PtrType
class
C
typename
R
bool
Owning
mozilla
:
:
RunnableKind
Kind
typename
.
.
.
As
>
struct
nsRunnableMethodTraits
<
PtrType
R
(
C
:
:
*
)
(
As
.
.
.
)
Owning
Kind
>
{
typedef
typename
mozilla
:
:
RemoveRawOrSmartPointer
<
PtrType
>
:
:
Type
class_type
;
static_assert
(
std
:
:
is_base_of
<
C
class_type
>
:
:
value
"
Stored
class
must
inherit
from
method
'
s
class
"
)
;
typedef
R
return_type
;
typedef
nsRunnableMethod
<
C
R
Owning
Kind
>
base_type
;
static
const
bool
can_cancel
=
Kind
=
=
mozilla
:
:
RunnableKind
:
:
Cancelable
;
}
;
template
<
typename
PtrType
class
C
typename
R
bool
Owning
mozilla
:
:
RunnableKind
Kind
typename
.
.
.
As
>
struct
nsRunnableMethodTraits
<
PtrType
R
(
C
:
:
*
)
(
As
.
.
.
)
const
Owning
Kind
>
{
typedef
const
typename
mozilla
:
:
RemoveRawOrSmartPointer
<
PtrType
>
:
:
Type
class_type
;
static_assert
(
std
:
:
is_base_of
<
C
class_type
>
:
:
value
"
Stored
class
must
inherit
from
method
'
s
class
"
)
;
typedef
R
return_type
;
typedef
nsRunnableMethod
<
C
R
Owning
Kind
>
base_type
;
static
const
bool
can_cancel
=
Kind
=
=
mozilla
:
:
RunnableKind
:
:
Cancelable
;
}
;
#
ifdef
NS_HAVE_STDCALL
template
<
typename
PtrType
class
C
typename
R
bool
Owning
mozilla
:
:
RunnableKind
Kind
typename
.
.
.
As
>
struct
nsRunnableMethodTraits
<
PtrType
R
(
__stdcall
C
:
:
*
)
(
As
.
.
.
)
Owning
Kind
>
{
typedef
typename
mozilla
:
:
RemoveRawOrSmartPointer
<
PtrType
>
:
:
Type
class_type
;
static_assert
(
std
:
:
is_base_of
<
C
class_type
>
:
:
value
"
Stored
class
must
inherit
from
method
'
s
class
"
)
;
typedef
R
return_type
;
typedef
nsRunnableMethod
<
C
R
Owning
Kind
>
base_type
;
static
const
bool
can_cancel
=
Kind
=
=
mozilla
:
:
RunnableKind
:
:
Cancelable
;
}
;
template
<
typename
PtrType
class
C
typename
R
bool
Owning
mozilla
:
:
RunnableKind
Kind
>
struct
nsRunnableMethodTraits
<
PtrType
R
(
NS_STDCALL
C
:
:
*
)
(
)
Owning
Kind
>
{
typedef
typename
mozilla
:
:
RemoveRawOrSmartPointer
<
PtrType
>
:
:
Type
class_type
;
static_assert
(
std
:
:
is_base_of
<
C
class_type
>
:
:
value
"
Stored
class
must
inherit
from
method
'
s
class
"
)
;
typedef
R
return_type
;
typedef
nsRunnableMethod
<
C
R
Owning
Kind
>
base_type
;
static
const
bool
can_cancel
=
Kind
=
=
mozilla
:
:
RunnableKind
:
:
Cancelable
;
}
;
template
<
typename
PtrType
class
C
typename
R
bool
Owning
mozilla
:
:
RunnableKind
Kind
typename
.
.
.
As
>
struct
nsRunnableMethodTraits
<
PtrType
R
(
__stdcall
C
:
:
*
)
(
As
.
.
.
)
const
Owning
Kind
>
{
typedef
const
typename
mozilla
:
:
RemoveRawOrSmartPointer
<
PtrType
>
:
:
Type
class_type
;
static_assert
(
std
:
:
is_base_of
<
C
class_type
>
:
:
value
"
Stored
class
must
inherit
from
method
'
s
class
"
)
;
typedef
R
return_type
;
typedef
nsRunnableMethod
<
C
R
Owning
Kind
>
base_type
;
static
const
bool
can_cancel
=
Kind
=
=
mozilla
:
:
RunnableKind
:
:
Cancelable
;
}
;
template
<
typename
PtrType
class
C
typename
R
bool
Owning
mozilla
:
:
RunnableKind
Kind
>
struct
nsRunnableMethodTraits
<
PtrType
R
(
NS_STDCALL
C
:
:
*
)
(
)
const
Owning
Kind
>
{
typedef
const
typename
mozilla
:
:
RemoveRawOrSmartPointer
<
PtrType
>
:
:
Type
class_type
;
static_assert
(
std
:
:
is_base_of
<
C
class_type
>
:
:
value
"
Stored
class
must
inherit
from
method
'
s
class
"
)
;
typedef
R
return_type
;
typedef
nsRunnableMethod
<
C
R
Owning
Kind
>
base_type
;
static
const
bool
can_cancel
=
Kind
=
=
mozilla
:
:
RunnableKind
:
:
Cancelable
;
}
;
#
endif
template
<
typename
T
>
struct
IsParameterStorageClass
:
public
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
StoreCopyPassByValue
{
using
stored_type
=
std
:
:
decay_t
<
T
>
;
typedef
stored_type
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreCopyPassByValue
(
A
&
&
a
)
:
m
(
std
:
:
forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreCopyPassByValue
<
S
>
>
:
public
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
StoreCopyPassByConstLRef
{
using
stored_type
=
std
:
:
decay_t
<
T
>
;
typedef
const
stored_type
&
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreCopyPassByConstLRef
(
A
&
&
a
)
:
m
(
std
:
:
forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreCopyPassByConstLRef
<
S
>
>
:
public
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
StoreCopyPassByLRef
{
using
stored_type
=
std
:
:
decay_t
<
T
>
;
typedef
stored_type
&
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreCopyPassByLRef
(
A
&
&
a
)
:
m
(
std
:
:
forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreCopyPassByLRef
<
S
>
>
:
public
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
StoreCopyPassByRRef
{
using
stored_type
=
std
:
:
decay_t
<
T
>
;
typedef
stored_type
&
&
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreCopyPassByRRef
(
A
&
&
a
)
:
m
(
std
:
:
forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
std
:
:
move
(
m
)
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreCopyPassByRRef
<
S
>
>
:
public
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
StoreRefPassByLRef
{
typedef
T
&
stored_type
;
typedef
T
&
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreRefPassByLRef
(
A
&
a
)
:
m
(
a
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreRefPassByLRef
<
S
>
>
:
public
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
StoreConstRefPassByConstLRef
{
typedef
const
T
&
stored_type
;
typedef
const
T
&
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreConstRefPassByConstLRef
(
const
A
&
a
)
:
m
(
a
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreConstRefPassByConstLRef
<
S
>
>
:
public
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
StoreRefPtrPassByPtr
{
typedef
RefPtr
<
T
>
stored_type
;
typedef
T
*
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreRefPtrPassByPtr
(
A
&
&
a
)
:
m
(
std
:
:
forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
.
get
(
)
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreRefPtrPassByPtr
<
S
>
>
:
public
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
StorePtrPassByPtr
{
typedef
T
*
stored_type
;
typedef
T
*
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StorePtrPassByPtr
(
A
a
)
:
m
(
a
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StorePtrPassByPtr
<
S
>
>
:
public
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
StoreConstPtrPassByConstPtr
{
typedef
const
T
*
stored_type
;
typedef
const
T
*
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreConstPtrPassByConstPtr
(
A
a
)
:
m
(
a
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreConstPtrPassByConstPtr
<
S
>
>
:
public
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
StoreCopyPassByConstPtr
{
typedef
T
stored_type
;
typedef
const
T
*
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreCopyPassByConstPtr
(
A
&
&
a
)
:
m
(
std
:
:
forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
&
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreCopyPassByConstPtr
<
S
>
>
:
public
std
:
:
true_type
{
}
;
template
<
typename
T
>
struct
StoreCopyPassByPtr
{
typedef
T
stored_type
;
typedef
T
*
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreCopyPassByPtr
(
A
&
&
a
)
:
m
(
std
:
:
forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
&
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreCopyPassByPtr
<
S
>
>
:
public
std
:
:
true_type
{
}
;
namespace
detail
{
template
<
typename
>
struct
SFINAE1True
:
std
:
:
true_type
{
}
;
template
<
class
T
>
static
auto
HasRefCountMethodsTest
(
int
)
-
>
SFINAE1True
<
decltype
(
std
:
:
declval
<
T
>
(
)
.
AddRef
(
)
std
:
:
declval
<
T
>
(
)
.
Release
(
)
)
>
;
template
<
class
>
static
auto
HasRefCountMethodsTest
(
long
)
-
>
std
:
:
false_type
;
template
<
class
T
>
struct
HasRefCountMethods
:
decltype
(
HasRefCountMethodsTest
<
T
>
(
0
)
)
{
}
;
template
<
typename
TWithoutPointer
>
struct
NonnsISupportsPointerStorageClass
:
std
:
:
conditional
<
std
:
:
is_const_v
<
TWithoutPointer
>
StoreConstPtrPassByConstPtr
<
std
:
:
remove_const_t
<
TWithoutPointer
>
>
StorePtrPassByPtr
<
TWithoutPointer
>
>
{
using
Type
=
typename
NonnsISupportsPointerStorageClass
:
:
conditional
:
:
type
;
}
;
template
<
typename
TWithoutPointer
>
struct
PointerStorageClass
:
std
:
:
conditional
<
HasRefCountMethods
<
TWithoutPointer
>
:
:
value
StoreRefPtrPassByPtr
<
TWithoutPointer
>
typename
NonnsISupportsPointerStorageClass
<
TWithoutPointer
>
:
:
Type
>
{
using
Type
=
typename
PointerStorageClass
:
:
conditional
:
:
type
;
}
;
template
<
typename
TWithoutRef
>
struct
LValueReferenceStorageClass
:
std
:
:
conditional
<
std
:
:
is_const_v
<
TWithoutRef
>
StoreConstRefPassByConstLRef
<
std
:
:
remove_const_t
<
TWithoutRef
>
>
StoreRefPassByLRef
<
TWithoutRef
>
>
{
using
Type
=
typename
LValueReferenceStorageClass
:
:
conditional
:
:
type
;
}
;
template
<
typename
T
>
struct
SmartPointerStorageClass
:
std
:
:
conditional
<
mozilla
:
:
IsRefcountedSmartPointer
<
T
>
:
:
value
StoreRefPtrPassByPtr
<
typename
mozilla
:
:
RemoveSmartPointer
<
T
>
:
:
Type
>
StoreCopyPassByConstLRef
<
T
>
>
{
using
Type
=
typename
SmartPointerStorageClass
:
:
conditional
:
:
type
;
}
;
template
<
typename
T
>
struct
NonLValueReferenceStorageClass
:
std
:
:
conditional
<
std
:
:
is_rvalue_reference_v
<
T
>
StoreCopyPassByRRef
<
std
:
:
remove_reference_t
<
T
>
>
typename
SmartPointerStorageClass
<
T
>
:
:
Type
>
{
using
Type
=
typename
NonLValueReferenceStorageClass
:
:
conditional
:
:
type
;
}
;
template
<
typename
T
>
struct
NonPointerStorageClass
:
std
:
:
conditional
<
std
:
:
is_lvalue_reference_v
<
T
>
typename
LValueReferenceStorageClass
<
std
:
:
remove_reference_t
<
T
>
>
:
:
Type
typename
NonLValueReferenceStorageClass
<
T
>
:
:
Type
>
{
using
Type
=
typename
NonPointerStorageClass
:
:
conditional
:
:
type
;
}
;
template
<
typename
T
>
struct
NonParameterStorageClass
:
std
:
:
conditional
<
std
:
:
is_pointer_v
<
T
>
typename
PointerStorageClass
<
std
:
:
remove_pointer_t
<
T
>
>
:
:
Type
typename
NonPointerStorageClass
<
T
>
:
:
Type
>
{
using
Type
=
typename
NonParameterStorageClass
:
:
conditional
:
:
type
;
}
;
template
<
typename
T
>
struct
ParameterStorage
:
std
:
:
conditional
<
IsParameterStorageClass
<
T
>
:
:
value
T
typename
NonParameterStorageClass
<
T
>
:
:
Type
>
{
using
Type
=
typename
ParameterStorage
:
:
conditional
:
:
type
;
}
;
template
<
class
T
>
static
auto
HasSetDeadlineTest
(
int
)
-
>
SFINAE1True
<
decltype
(
std
:
:
declval
<
T
>
(
)
.
SetDeadline
(
std
:
:
declval
<
mozilla
:
:
TimeStamp
>
(
)
)
)
>
;
template
<
class
T
>
static
auto
HasSetDeadlineTest
(
long
)
-
>
std
:
:
false_type
;
template
<
class
T
>
struct
HasSetDeadline
:
decltype
(
HasSetDeadlineTest
<
T
>
(
0
)
)
{
}
;
template
<
class
T
>
std
:
:
enable_if_t
<
:
:
detail
:
:
HasSetDeadline
<
T
>
:
:
value
>
SetDeadlineImpl
(
T
*
aObj
mozilla
:
:
TimeStamp
aTimeStamp
)
{
aObj
-
>
SetDeadline
(
aTimeStamp
)
;
}
template
<
class
T
>
std
:
:
enable_if_t
<
!
:
:
detail
:
:
HasSetDeadline
<
T
>
:
:
value
>
SetDeadlineImpl
(
T
*
aObj
mozilla
:
:
TimeStamp
aTimeStamp
)
{
}
}
namespace
mozilla
{
namespace
detail
{
template
<
typename
.
.
.
Ts
>
struct
RunnableMethodArguments
final
{
Tuple
<
typename
:
:
detail
:
:
ParameterStorage
<
Ts
>
:
:
Type
.
.
.
>
mArguments
;
template
<
typename
.
.
.
As
>
explicit
RunnableMethodArguments
(
As
&
&
.
.
.
aArguments
)
:
mArguments
(
std
:
:
forward
<
As
>
(
aArguments
)
.
.
.
)
{
}
template
<
typename
C
typename
M
typename
.
.
.
Args
size_t
.
.
.
Indices
>
static
auto
applyImpl
(
C
*
o
M
m
Tuple
<
Args
.
.
.
>
&
args
std
:
:
index_sequence
<
Indices
.
.
.
>
)
-
>
decltype
(
(
(
*
o
)
.
*
m
)
(
Get
<
Indices
>
(
args
)
.
PassAsParameter
(
)
.
.
.
)
)
{
return
(
(
*
o
)
.
*
m
)
(
Get
<
Indices
>
(
args
)
.
PassAsParameter
(
)
.
.
.
)
;
}
template
<
class
C
typename
M
>
auto
apply
(
C
*
o
M
m
)
-
>
decltype
(
applyImpl
(
o
m
mArguments
std
:
:
index_sequence_for
<
Ts
.
.
.
>
{
}
)
)
{
return
applyImpl
(
o
m
mArguments
std
:
:
index_sequence_for
<
Ts
.
.
.
>
{
}
)
;
}
}
;
template
<
typename
PtrType
typename
Method
bool
Owning
RunnableKind
Kind
typename
.
.
.
Storages
>
class
RunnableMethodImpl
final
:
public
:
:
nsRunnableMethodTraits
<
PtrType
Method
Owning
Kind
>
:
:
base_type
{
typedef
typename
:
:
nsRunnableMethodTraits
<
PtrType
Method
Owning
Kind
>
Traits
;
typedef
typename
Traits
:
:
class_type
ClassType
;
typedef
typename
Traits
:
:
base_type
BaseType
;
:
:
nsRunnableMethodReceiver
<
ClassType
Owning
>
mReceiver
;
Method
mMethod
;
RunnableMethodArguments
<
Storages
.
.
.
>
mArgs
;
using
BaseType
:
:
CancelTimer
;
using
BaseType
:
:
GetTimer
;
private
:
virtual
~
RunnableMethodImpl
(
)
{
Revoke
(
)
;
}
;
static
void
TimedOut
(
nsITimer
*
aTimer
void
*
aClosure
)
{
static_assert
(
IsIdle
(
Kind
)
"
Don
'
t
use
me
!
"
)
;
RefPtr
<
CancelableIdleRunnable
>
r
=
static_cast
<
CancelableIdleRunnable
*
>
(
aClosure
)
;
r
-
>
SetDeadline
(
TimeStamp
(
)
)
;
r
-
>
Run
(
)
;
r
-
>
Cancel
(
)
;
}
public
:
template
<
typename
ForwardedPtrType
typename
.
.
.
Args
>
explicit
RunnableMethodImpl
(
const
char
*
aName
ForwardedPtrType
&
&
aObj
Method
aMethod
Args
&
&
.
.
.
aArgs
)
:
BaseType
(
aName
)
mReceiver
(
std
:
:
forward
<
ForwardedPtrType
>
(
aObj
)
)
mMethod
(
aMethod
)
mArgs
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
Storages
and
Args
should
have
equal
sizes
"
)
;
}
NS_IMETHOD
Run
(
)
{
CancelTimer
(
)
;
if
(
MOZ_LIKELY
(
mReceiver
.
Get
(
)
)
)
{
mArgs
.
apply
(
mReceiver
.
Get
(
)
mMethod
)
;
}
return
NS_OK
;
}
nsresult
Cancel
(
)
{
static_assert
(
Kind
>
=
RunnableKind
:
:
Cancelable
"
Don
'
t
use
me
!
"
)
;
Revoke
(
)
;
return
NS_OK
;
}
void
Revoke
(
)
{
CancelTimer
(
)
;
mReceiver
.
Revoke
(
)
;
}
void
SetDeadline
(
TimeStamp
aDeadline
)
{
if
(
MOZ_LIKELY
(
mReceiver
.
Get
(
)
)
)
{
:
:
detail
:
:
SetDeadlineImpl
(
mReceiver
.
Get
(
)
aDeadline
)
;
}
}
void
SetTimer
(
uint32_t
aDelay
nsIEventTarget
*
aTarget
)
{
MOZ_ASSERT
(
aTarget
)
;
if
(
nsCOMPtr
<
nsITimer
>
timer
=
GetTimer
(
)
)
{
timer
-
>
Cancel
(
)
;
timer
-
>
SetTarget
(
aTarget
)
;
timer
-
>
InitWithNamedFuncCallback
(
TimedOut
this
aDelay
nsITimer
:
:
TYPE_ONE_SHOT
"
detail
:
:
RunnableMethodImpl
:
:
SetTimer
"
)
;
}
}
}
;
template
<
typename
PtrType
typename
Method
>
using
OwningRunnableMethod
=
typename
:
:
nsRunnableMethodTraits
<
std
:
:
remove_reference_t
<
PtrType
>
Method
true
RunnableKind
:
:
Standard
>
:
:
base_type
;
template
<
typename
PtrType
typename
Method
typename
.
.
.
Storages
>
using
OwningRunnableMethodImpl
=
RunnableMethodImpl
<
std
:
:
remove_reference_t
<
PtrType
>
Method
true
RunnableKind
:
:
Standard
Storages
.
.
.
>
;
template
<
typename
PtrType
typename
Method
>
using
CancelableRunnableMethod
=
typename
:
:
nsRunnableMethodTraits
<
std
:
:
remove_reference_t
<
PtrType
>
Method
true
RunnableKind
:
:
Cancelable
>
:
:
base_type
;
template
<
typename
PtrType
typename
Method
typename
.
.
.
Storages
>
using
CancelableRunnableMethodImpl
=
RunnableMethodImpl
<
std
:
:
remove_reference_t
<
PtrType
>
Method
true
RunnableKind
:
:
Cancelable
Storages
.
.
.
>
;
template
<
typename
PtrType
typename
Method
>
using
IdleRunnableMethod
=
typename
:
:
nsRunnableMethodTraits
<
std
:
:
remove_reference_t
<
PtrType
>
Method
true
RunnableKind
:
:
Idle
>
:
:
base_type
;
template
<
typename
PtrType
typename
Method
typename
.
.
.
Storages
>
using
IdleRunnableMethodImpl
=
RunnableMethodImpl
<
std
:
:
remove_reference_t
<
PtrType
>
Method
true
RunnableKind
:
:
Idle
Storages
.
.
.
>
;
template
<
typename
PtrType
typename
Method
>
using
IdleRunnableMethodWithTimer
=
typename
:
:
nsRunnableMethodTraits
<
std
:
:
remove_reference_t
<
PtrType
>
Method
true
RunnableKind
:
:
IdleWithTimer
>
:
:
base_type
;
template
<
typename
PtrType
typename
Method
typename
.
.
.
Storages
>
using
IdleRunnableMethodWithTimerImpl
=
RunnableMethodImpl
<
std
:
:
remove_reference_t
<
PtrType
>
Method
true
RunnableKind
:
:
IdleWithTimer
Storages
.
.
.
>
;
template
<
typename
PtrType
typename
Method
>
using
NonOwningRunnableMethod
=
typename
:
:
nsRunnableMethodTraits
<
std
:
:
remove_reference_t
<
PtrType
>
Method
false
RunnableKind
:
:
Standard
>
:
:
base_type
;
template
<
typename
PtrType
typename
Method
typename
.
.
.
Storages
>
using
NonOwningRunnableMethodImpl
=
RunnableMethodImpl
<
std
:
:
remove_reference_t
<
PtrType
>
Method
false
RunnableKind
:
:
Standard
Storages
.
.
.
>
;
template
<
typename
PtrType
typename
Method
>
using
NonOwningCancelableRunnableMethod
=
typename
:
:
nsRunnableMethodTraits
<
std
:
:
remove_reference_t
<
PtrType
>
Method
false
RunnableKind
:
:
Cancelable
>
:
:
base_type
;
template
<
typename
PtrType
typename
Method
typename
.
.
.
Storages
>
using
NonOwningCancelableRunnableMethodImpl
=
RunnableMethodImpl
<
std
:
:
remove_reference_t
<
PtrType
>
Method
false
RunnableKind
:
:
Cancelable
Storages
.
.
.
>
;
template
<
typename
PtrType
typename
Method
>
using
NonOwningIdleRunnableMethod
=
typename
:
:
nsRunnableMethodTraits
<
std
:
:
remove_reference_t
<
PtrType
>
Method
false
RunnableKind
:
:
Idle
>
:
:
base_type
;
template
<
typename
PtrType
typename
Method
typename
.
.
.
Storages
>
using
NonOwningIdleRunnableMethodImpl
=
RunnableMethodImpl
<
std
:
:
remove_reference_t
<
PtrType
>
Method
false
RunnableKind
:
:
Idle
Storages
.
.
.
>
;
template
<
typename
PtrType
typename
Method
>
using
NonOwningIdleRunnableMethodWithTimer
=
typename
:
:
nsRunnableMethodTraits
<
std
:
:
remove_reference_t
<
PtrType
>
Method
false
RunnableKind
:
:
IdleWithTimer
>
:
:
base_type
;
template
<
typename
PtrType
typename
Method
typename
.
.
.
Storages
>
using
NonOwningIdleRunnableMethodWithTimerImpl
=
RunnableMethodImpl
<
std
:
:
remove_reference_t
<
PtrType
>
Method
false
RunnableKind
:
:
IdleWithTimer
Storages
.
.
.
>
;
}
template
<
typename
PtrType
typename
Method
>
already_AddRefed
<
detail
:
:
OwningRunnableMethod
<
PtrType
Method
>
>
NewRunnableMethod
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
)
{
return
do_AddRef
(
new
detail
:
:
OwningRunnableMethodImpl
<
PtrType
Method
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
)
)
;
}
template
<
typename
PtrType
typename
Method
>
already_AddRefed
<
detail
:
:
CancelableRunnableMethod
<
PtrType
Method
>
>
NewCancelableRunnableMethod
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
)
{
return
do_AddRef
(
new
detail
:
:
CancelableRunnableMethodImpl
<
PtrType
Method
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
)
)
;
}
template
<
typename
PtrType
typename
Method
>
already_AddRefed
<
detail
:
:
IdleRunnableMethod
<
PtrType
Method
>
>
NewIdleRunnableMethod
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
)
{
return
do_AddRef
(
new
detail
:
:
IdleRunnableMethodImpl
<
PtrType
Method
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
)
)
;
}
template
<
typename
PtrType
typename
Method
>
already_AddRefed
<
detail
:
:
IdleRunnableMethodWithTimer
<
PtrType
Method
>
>
NewIdleRunnableMethodWithTimer
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
)
{
return
do_AddRef
(
new
detail
:
:
IdleRunnableMethodWithTimerImpl
<
PtrType
Method
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
)
)
;
}
template
<
typename
PtrType
typename
Method
>
already_AddRefed
<
detail
:
:
NonOwningRunnableMethod
<
PtrType
Method
>
>
NewNonOwningRunnableMethod
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
)
{
return
do_AddRef
(
new
detail
:
:
NonOwningRunnableMethodImpl
<
PtrType
Method
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
)
)
;
}
template
<
typename
PtrType
typename
Method
>
already_AddRefed
<
detail
:
:
NonOwningCancelableRunnableMethod
<
PtrType
Method
>
>
NewNonOwningCancelableRunnableMethod
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
)
{
return
do_AddRef
(
new
detail
:
:
NonOwningCancelableRunnableMethodImpl
<
PtrType
Method
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
)
)
;
}
template
<
typename
PtrType
typename
Method
>
already_AddRefed
<
detail
:
:
NonOwningIdleRunnableMethod
<
PtrType
Method
>
>
NewNonOwningIdleRunnableMethod
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
)
{
return
do_AddRef
(
new
detail
:
:
NonOwningIdleRunnableMethodImpl
<
PtrType
Method
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
)
)
;
}
template
<
typename
PtrType
typename
Method
>
already_AddRefed
<
detail
:
:
NonOwningIdleRunnableMethodWithTimer
<
PtrType
Method
>
>
NewNonOwningIdleRunnableMethodWithTimer
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
)
{
return
do_AddRef
(
new
detail
:
:
NonOwningIdleRunnableMethodWithTimerImpl
<
PtrType
Method
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
)
)
;
}
template
<
typename
.
.
.
Storages
typename
PtrType
typename
Method
typename
.
.
.
Args
>
already_AddRefed
<
detail
:
:
OwningRunnableMethod
<
PtrType
Method
>
>
NewRunnableMethod
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
<
Storages
.
.
.
>
size
should
be
equal
to
number
of
arguments
"
)
;
return
do_AddRef
(
new
detail
:
:
OwningRunnableMethodImpl
<
PtrType
Method
Storages
.
.
.
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
template
<
typename
.
.
.
Storages
typename
PtrType
typename
Method
typename
.
.
.
Args
>
already_AddRefed
<
detail
:
:
NonOwningRunnableMethod
<
PtrType
Method
>
>
NewNonOwningRunnableMethod
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
<
Storages
.
.
.
>
size
should
be
equal
to
number
of
arguments
"
)
;
return
do_AddRef
(
new
detail
:
:
NonOwningRunnableMethodImpl
<
PtrType
Method
Storages
.
.
.
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
template
<
typename
.
.
.
Storages
typename
PtrType
typename
Method
typename
.
.
.
Args
>
already_AddRefed
<
detail
:
:
CancelableRunnableMethod
<
PtrType
Method
>
>
NewCancelableRunnableMethod
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
<
Storages
.
.
.
>
size
should
be
equal
to
number
of
arguments
"
)
;
return
do_AddRef
(
new
detail
:
:
CancelableRunnableMethodImpl
<
PtrType
Method
Storages
.
.
.
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
template
<
typename
.
.
.
Storages
typename
PtrType
typename
Method
typename
.
.
.
Args
>
already_AddRefed
<
detail
:
:
NonOwningCancelableRunnableMethod
<
PtrType
Method
>
>
NewNonOwningCancelableRunnableMethod
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
<
Storages
.
.
.
>
size
should
be
equal
to
number
of
arguments
"
)
;
return
do_AddRef
(
new
detail
:
:
NonOwningCancelableRunnableMethodImpl
<
PtrType
Method
Storages
.
.
.
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
template
<
typename
.
.
.
Storages
typename
PtrType
typename
Method
typename
.
.
.
Args
>
already_AddRefed
<
detail
:
:
IdleRunnableMethod
<
PtrType
Method
>
>
NewIdleRunnableMethod
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
<
Storages
.
.
.
>
size
should
be
equal
to
number
of
arguments
"
)
;
return
do_AddRef
(
new
detail
:
:
IdleRunnableMethodImpl
<
PtrType
Method
Storages
.
.
.
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
template
<
typename
.
.
.
Storages
typename
PtrType
typename
Method
typename
.
.
.
Args
>
already_AddRefed
<
detail
:
:
NonOwningIdleRunnableMethod
<
PtrType
Method
>
>
NewNonOwningIdleRunnableMethod
(
const
char
*
aName
PtrType
&
&
aPtr
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
<
Storages
.
.
.
>
size
should
be
equal
to
number
of
arguments
"
)
;
return
do_AddRef
(
new
detail
:
:
NonOwningIdleRunnableMethodImpl
<
PtrType
Method
Storages
.
.
.
>
(
aName
std
:
:
forward
<
PtrType
>
(
aPtr
)
aMethod
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
}
#
endif
template
<
class
T
>
class
nsRevocableEventPtr
{
public
:
nsRevocableEventPtr
(
)
:
mEvent
(
nullptr
)
{
}
~
nsRevocableEventPtr
(
)
{
Revoke
(
)
;
}
const
nsRevocableEventPtr
&
operator
=
(
RefPtr
<
T
>
&
&
aEvent
)
{
if
(
mEvent
!
=
aEvent
)
{
Revoke
(
)
;
mEvent
=
std
:
:
move
(
aEvent
)
;
}
return
*
this
;
}
void
Revoke
(
)
{
if
(
mEvent
)
{
mEvent
-
>
Revoke
(
)
;
mEvent
=
nullptr
;
}
}
void
Forget
(
)
{
mEvent
=
nullptr
;
}
bool
IsPending
(
)
{
return
mEvent
!
=
nullptr
;
}
T
*
get
(
)
{
return
mEvent
;
}
private
:
nsRevocableEventPtr
(
const
nsRevocableEventPtr
&
)
;
nsRevocableEventPtr
&
operator
=
(
const
nsRevocableEventPtr
&
)
;
RefPtr
<
T
>
mEvent
;
}
;
template
<
class
T
>
inline
already_AddRefed
<
T
>
do_AddRef
(
nsRevocableEventPtr
<
T
>
&
aObj
)
{
return
do_AddRef
(
aObj
.
get
(
)
)
;
}
class
nsThreadPoolNaming
{
public
:
nsThreadPoolNaming
(
)
=
default
;
nsCString
GetNextThreadName
(
const
nsACString
&
aPoolName
)
;
template
<
size_t
LEN
>
nsCString
GetNextThreadName
(
const
char
(
&
aPoolName
)
[
LEN
]
)
{
return
GetNextThreadName
(
nsDependentCString
(
aPoolName
LEN
-
1
)
)
;
}
private
:
mozilla
:
:
Atomic
<
uint32_t
>
mCounter
{
0
}
;
nsThreadPoolNaming
(
const
nsThreadPoolNaming
&
)
=
delete
;
void
operator
=
(
const
nsThreadPoolNaming
&
)
=
delete
;
}
;
class
MOZ_STACK_CLASS
nsAutoLowPriorityIO
{
public
:
nsAutoLowPriorityIO
(
)
;
~
nsAutoLowPriorityIO
(
)
;
private
:
bool
lowIOPrioritySet
;
#
if
defined
(
XP_MACOSX
)
int
oldPriority
;
#
endif
}
;
void
NS_SetMainThread
(
)
;
void
NS_SetMainThread
(
PRThread
*
aVirtualThread
)
;
void
NS_UnsetMainThread
(
)
;
extern
mozilla
:
:
TimeStamp
NS_GetTimerDeadlineHintOnCurrentThread
(
mozilla
:
:
TimeStamp
aDefault
uint32_t
aSearchBound
)
;
extern
nsresult
NS_DispatchBackgroundTask
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aDispatchFlags
=
NS_DISPATCH_NORMAL
)
;
extern
"
C
"
nsresult
NS_DispatchBackgroundTask
(
nsIRunnable
*
aEvent
uint32_t
aDispatchFlags
=
NS_DISPATCH_NORMAL
)
;
extern
"
C
"
nsresult
NS_CreateBackgroundTaskQueue
(
const
char
*
aName
nsISerialEventTarget
*
*
aTarget
)
;
namespace
IPC
{
class
Message
;
}
class
nsTimerImpl
;
namespace
mozilla
{
class
SerialEventTargetGuard
{
public
:
explicit
SerialEventTargetGuard
(
nsISerialEventTarget
*
aThread
)
:
mLastCurrentThread
(
sCurrentThreadTLS
.
get
(
)
)
{
Set
(
aThread
)
;
}
~
SerialEventTargetGuard
(
)
{
sCurrentThreadTLS
.
set
(
mLastCurrentThread
)
;
}
static
void
InitTLS
(
)
;
static
nsISerialEventTarget
*
GetCurrentSerialEventTarget
(
)
{
return
sCurrentThreadTLS
.
get
(
)
;
}
protected
:
friend
class
:
:
MessageLoop
;
static
void
Set
(
nsISerialEventTarget
*
aThread
)
{
MOZ_ASSERT
(
aThread
-
>
IsOnCurrentThread
(
)
)
;
sCurrentThreadTLS
.
set
(
aThread
)
;
}
private
:
static
MOZ_THREAD_LOCAL
(
nsISerialEventTarget
*
)
sCurrentThreadTLS
;
nsISerialEventTarget
*
mLastCurrentThread
;
}
;
nsIEventTarget
*
GetCurrentEventTarget
(
)
;
nsIEventTarget
*
GetMainThreadEventTarget
(
)
;
nsISerialEventTarget
*
GetCurrentSerialEventTarget
(
)
;
nsISerialEventTarget
*
GetMainThreadSerialEventTarget
(
)
;
class
TailDispatchingTarget
:
public
nsISerialEventTarget
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
TailDispatchingTarget
(
)
#
if
DEBUG
:
mOwnerThread
(
AbstractThread
:
:
GetCurrent
(
)
)
#
endif
{
MOZ_ASSERT
(
mOwnerThread
"
Must
be
used
with
AbstractThreads
"
)
;
}
NS_IMETHOD
Dispatch
(
already_AddRefed
<
nsIRunnable
>
event
uint32_t
flags
)
override
{
MOZ_ASSERT
(
flags
=
=
DISPATCH_NORMAL
)
;
MOZ_ASSERT
(
AbstractThread
:
:
GetCurrent
(
)
=
=
mOwnerThread
"
TailDispatchingTarget
can
only
be
used
on
the
thread
upon
which
it
"
"
was
created
-
see
the
comment
on
the
class
declaration
.
"
)
;
AbstractThread
:
:
DispatchDirectTask
(
std
:
:
move
(
event
)
)
;
return
NS_OK
;
}
NS_IMETHOD_
(
bool
)
IsOnCurrentThreadInfallible
(
void
)
override
{
return
true
;
}
NS_IMETHOD
IsOnCurrentThread
(
bool
*
_retval
)
override
{
*
_retval
=
true
;
return
NS_OK
;
}
NS_IMETHOD
DispatchFromScript
(
nsIRunnable
*
event
uint32_t
flags
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
not
implemented
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
event
uint32_t
delay
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
not
implemented
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
private
:
virtual
~
TailDispatchingTarget
(
)
=
default
;
#
if
DEBUG
const
RefPtr
<
AbstractThread
>
mOwnerThread
;
#
endif
}
;
size_t
GetNumberOfProcessors
(
)
;
template
<
typename
T
>
class
LogTaskBase
{
public
:
LogTaskBase
(
)
=
delete
;
static
void
LogDispatch
(
T
*
aEvent
)
;
static
void
LogDispatch
(
T
*
aEvent
void
*
aContext
)
;
static
void
LogDispatchWithPid
(
T
*
aEvent
int32_t
aPid
)
;
class
MOZ_RAII
Run
{
public
:
Run
(
)
=
delete
;
explicit
Run
(
T
*
aEvent
bool
aWillRunAgain
=
false
)
;
explicit
Run
(
T
*
aEvent
void
*
aContext
bool
aWillRunAgain
=
false
)
;
~
Run
(
)
;
void
WillRunAgain
(
)
{
mWillRunAgain
=
true
;
}
private
:
bool
mWillRunAgain
=
false
;
}
;
}
;
class
MicroTaskRunnable
;
class
Task
;
class
PresShell
;
namespace
dom
{
class
FrameRequestCallback
;
}
template
<
>
LogTaskBase
<
nsIRunnable
>
:
:
Run
:
:
Run
(
nsIRunnable
*
aEvent
bool
aWillRunAgain
)
;
template
<
>
LogTaskBase
<
Task
>
:
:
Run
:
:
Run
(
Task
*
aTask
bool
aWillRunAgain
)
;
template
<
>
void
LogTaskBase
<
IPC
:
:
Message
>
:
:
LogDispatchWithPid
(
IPC
:
:
Message
*
aEvent
int32_t
aPid
)
;
template
<
>
LogTaskBase
<
IPC
:
:
Message
>
:
:
Run
:
:
Run
(
IPC
:
:
Message
*
aMessage
bool
aWillRunAgain
)
;
template
<
>
LogTaskBase
<
nsTimerImpl
>
:
:
Run
:
:
Run
(
nsTimerImpl
*
aEvent
bool
aWillRunAgain
)
;
typedef
LogTaskBase
<
nsIRunnable
>
LogRunnable
;
typedef
LogTaskBase
<
MicroTaskRunnable
>
LogMicroTaskRunnable
;
typedef
LogTaskBase
<
IPC
:
:
Message
>
LogIPCMessage
;
typedef
LogTaskBase
<
nsTimerImpl
>
LogTimerEvent
;
typedef
LogTaskBase
<
Task
>
LogTask
;
typedef
LogTaskBase
<
PresShell
>
LogPresShellObserver
;
typedef
LogTaskBase
<
dom
:
:
FrameRequestCallback
>
LogFrameRequestCallback
;
}
#
endif
