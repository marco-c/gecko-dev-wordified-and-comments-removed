#
ifndef
nsThreadUtils_h__
#
define
nsThreadUtils_h__
#
include
"
prthread
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsICancelableRunnable
.
h
"
#
include
"
nsIIdlePeriod
.
h
"
#
include
"
nsIIncrementalRunnable
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIThreadManager
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsStringGlue
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
IndexSequence
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
extern
nsresult
NS_NewThread
(
nsIThread
*
*
aResult
nsIRunnable
*
aInitialEvent
=
nullptr
uint32_t
aStackSize
=
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
)
;
extern
nsresult
NS_NewNamedThread
(
const
nsACString
&
aName
nsIThread
*
*
aResult
nsIRunnable
*
aInitialEvent
=
nullptr
uint32_t
aStackSize
=
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
)
;
template
<
size_t
LEN
>
inline
nsresult
NS_NewNamedThread
(
const
char
(
&
aName
)
[
LEN
]
nsIThread
*
*
aResult
nsIRunnable
*
aInitialEvent
=
nullptr
uint32_t
aStackSize
=
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
)
{
static_assert
(
LEN
<
=
16
"
Thread
name
must
be
no
more
than
16
characters
"
)
;
return
NS_NewNamedThread
(
nsDependentCString
(
aName
LEN
-
1
)
aResult
aInitialEvent
aStackSize
)
;
}
extern
nsresult
NS_GetCurrentThread
(
nsIThread
*
*
aResult
)
;
extern
nsresult
NS_DispatchToCurrentThread
(
nsIRunnable
*
aEvent
)
;
extern
nsresult
NS_DispatchToCurrentThread
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
)
;
extern
nsresult
NS_DispatchToMainThread
(
nsIRunnable
*
aEvent
uint32_t
aDispatchFlags
=
NS_DISPATCH_NORMAL
)
;
extern
nsresult
NS_DispatchToMainThread
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
uint32_t
aDispatchFlags
=
NS_DISPATCH_NORMAL
)
;
extern
nsresult
NS_DelayedDispatchToCurrentThread
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
uint32_t
aDelayMs
)
;
extern
nsresult
NS_IdleDispatchToCurrentThread
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
)
;
#
ifndef
XPCOM_GLUE_AVOID_NSPR
extern
nsresult
NS_ProcessPendingEvents
(
nsIThread
*
aThread
PRIntervalTime
aTimeout
=
PR_INTERVAL_NO_TIMEOUT
)
;
#
endif
extern
bool
NS_HasPendingEvents
(
nsIThread
*
aThread
=
nullptr
)
;
extern
bool
NS_ProcessNextEvent
(
nsIThread
*
aThread
=
nullptr
bool
aMayWait
=
true
)
;
inline
already_AddRefed
<
nsIThread
>
do_GetCurrentThread
(
)
{
nsIThread
*
thread
=
nullptr
;
NS_GetCurrentThread
(
&
thread
)
;
return
already_AddRefed
<
nsIThread
>
(
thread
)
;
}
inline
already_AddRefed
<
nsIThread
>
do_GetMainThread
(
)
{
nsIThread
*
thread
=
nullptr
;
NS_GetMainThread
(
&
thread
)
;
return
already_AddRefed
<
nsIThread
>
(
thread
)
;
}
#
ifdef
MOZILLA_INTERNAL_API
extern
nsIThread
*
NS_GetCurrentThread
(
)
;
#
endif
#
ifndef
XPCOM_GLUE_AVOID_NSPR
namespace
mozilla
{
class
IdlePeriod
:
public
nsIIdlePeriod
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIIDLEPERIOD
IdlePeriod
(
)
{
}
protected
:
virtual
~
IdlePeriod
(
)
{
}
private
:
IdlePeriod
(
const
IdlePeriod
&
)
=
delete
;
IdlePeriod
&
operator
=
(
const
IdlePeriod
&
)
=
delete
;
IdlePeriod
&
operator
=
(
const
IdlePeriod
&
&
)
=
delete
;
}
;
class
Runnable
:
public
nsIRunnable
public
nsINamed
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIRUNNABLE
NS_DECL_NSINAMED
Runnable
(
)
{
}
#
ifdef
RELEASE_OR_BETA
explicit
Runnable
(
const
char
*
aName
)
{
}
#
else
explicit
Runnable
(
const
char
*
aName
)
:
mName
(
aName
)
{
}
#
endif
protected
:
virtual
~
Runnable
(
)
{
}
private
:
Runnable
(
const
Runnable
&
)
=
delete
;
Runnable
&
operator
=
(
const
Runnable
&
)
=
delete
;
Runnable
&
operator
=
(
const
Runnable
&
&
)
=
delete
;
#
ifndef
RELEASE_OR_BETA
const
char
*
mName
=
nullptr
;
#
endif
}
;
class
CancelableRunnable
:
public
Runnable
public
nsICancelableRunnable
{
public
:
NS_DECL_ISUPPORTS_INHERITED
virtual
nsresult
Cancel
(
)
override
;
CancelableRunnable
(
)
{
}
explicit
CancelableRunnable
(
const
char
*
aName
)
:
Runnable
(
aName
)
{
}
protected
:
virtual
~
CancelableRunnable
(
)
{
}
private
:
CancelableRunnable
(
const
CancelableRunnable
&
)
=
delete
;
CancelableRunnable
&
operator
=
(
const
CancelableRunnable
&
)
=
delete
;
CancelableRunnable
&
operator
=
(
const
CancelableRunnable
&
&
)
=
delete
;
}
;
class
IncrementalRunnable
:
public
CancelableRunnable
public
nsIIncrementalRunnable
{
public
:
NS_DECL_ISUPPORTS_INHERITED
virtual
void
SetDeadline
(
TimeStamp
aDeadline
)
override
;
IncrementalRunnable
(
)
{
}
protected
:
virtual
~
IncrementalRunnable
(
)
{
}
private
:
IncrementalRunnable
(
const
IncrementalRunnable
&
)
=
delete
;
IncrementalRunnable
&
operator
=
(
const
IncrementalRunnable
&
)
=
delete
;
IncrementalRunnable
&
operator
=
(
const
IncrementalRunnable
&
&
)
=
delete
;
}
;
namespace
detail
{
template
<
typename
StoredFunction
>
class
RunnableFunction
:
public
Runnable
{
public
:
template
<
typename
F
>
explicit
RunnableFunction
(
F
&
&
aFunction
)
:
mFunction
(
Forward
<
F
>
(
aFunction
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
static_assert
(
IsVoid
<
decltype
(
mFunction
(
)
)
>
:
:
value
"
The
lambda
must
return
void
!
"
)
;
mFunction
(
)
;
return
NS_OK
;
}
private
:
StoredFunction
mFunction
;
}
;
template
<
typename
Function
>
using
RunnableFunctionImpl
=
typename
detail
:
:
RunnableFunction
<
typename
RemoveReference
<
Function
>
:
:
Type
>
;
}
namespace
detail
{
template
<
typename
CVRemoved
>
struct
IsRefcountedSmartPointerHelper
:
FalseType
{
}
;
template
<
typename
Pointee
>
struct
IsRefcountedSmartPointerHelper
<
RefPtr
<
Pointee
>
>
:
TrueType
{
}
;
template
<
typename
Pointee
>
struct
IsRefcountedSmartPointerHelper
<
nsCOMPtr
<
Pointee
>
>
:
TrueType
{
}
;
}
template
<
typename
T
>
struct
IsRefcountedSmartPointer
:
detail
:
:
IsRefcountedSmartPointerHelper
<
typename
RemoveCV
<
T
>
:
:
Type
>
{
}
;
namespace
detail
{
template
<
typename
T
typename
CVRemoved
>
struct
RemoveSmartPointerHelper
{
typedef
T
Type
;
}
;
template
<
typename
T
typename
Pointee
>
struct
RemoveSmartPointerHelper
<
T
RefPtr
<
Pointee
>
>
{
typedef
Pointee
Type
;
}
;
template
<
typename
T
typename
Pointee
>
struct
RemoveSmartPointerHelper
<
T
nsCOMPtr
<
Pointee
>
>
{
typedef
Pointee
Type
;
}
;
}
template
<
typename
T
>
struct
RemoveSmartPointer
:
detail
:
:
RemoveSmartPointerHelper
<
T
typename
RemoveCV
<
T
>
:
:
Type
>
{
}
;
namespace
detail
{
template
<
typename
T
typename
CVRemoved
>
struct
RemoveRawOrSmartPointerHelper
{
typedef
T
Type
;
}
;
template
<
typename
T
typename
Pointee
>
struct
RemoveRawOrSmartPointerHelper
<
T
Pointee
*
>
{
typedef
Pointee
Type
;
}
;
template
<
typename
T
typename
Pointee
>
struct
RemoveRawOrSmartPointerHelper
<
T
RefPtr
<
Pointee
>
>
{
typedef
Pointee
Type
;
}
;
template
<
typename
T
typename
Pointee
>
struct
RemoveRawOrSmartPointerHelper
<
T
nsCOMPtr
<
Pointee
>
>
{
typedef
Pointee
Type
;
}
;
}
template
<
typename
T
>
struct
RemoveRawOrSmartPointer
:
detail
:
:
RemoveRawOrSmartPointerHelper
<
T
typename
RemoveCV
<
T
>
:
:
Type
>
{
}
;
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
Runnable
*
p
)
{
return
static_cast
<
nsIRunnable
*
>
(
p
)
;
}
template
<
typename
Function
>
already_AddRefed
<
mozilla
:
:
Runnable
>
NS_NewRunnableFunction
(
Function
&
&
aFunction
)
{
return
do_AddRef
(
new
mozilla
:
:
detail
:
:
RunnableFunctionImpl
<
Function
>
(
mozilla
:
:
Forward
<
Function
>
(
aFunction
)
)
)
;
}
template
<
class
ClassType
typename
ReturnType
=
void
bool
Owning
=
true
bool
Cancelable
=
false
>
class
nsRunnableMethod
:
public
mozilla
:
:
Conditional
<
!
Cancelable
mozilla
:
:
Runnable
mozilla
:
:
CancelableRunnable
>
:
:
Type
{
public
:
virtual
void
Revoke
(
)
=
0
;
template
<
typename
OtherReturnType
>
class
ReturnTypeEnforcer
{
public
:
typedef
int
ReturnTypeIsSafe
;
}
;
template
<
class
T
>
class
ReturnTypeEnforcer
<
already_AddRefed
<
T
>
>
{
}
;
typedef
typename
ReturnTypeEnforcer
<
ReturnType
>
:
:
ReturnTypeIsSafe
check
;
}
;
template
<
class
ClassType
bool
Owning
>
struct
nsRunnableMethodReceiver
{
RefPtr
<
ClassType
>
mObj
;
explicit
nsRunnableMethodReceiver
(
ClassType
*
aObj
)
:
mObj
(
aObj
)
{
}
~
nsRunnableMethodReceiver
(
)
{
Revoke
(
)
;
}
ClassType
*
Get
(
)
const
{
return
mObj
.
get
(
)
;
}
void
Revoke
(
)
{
mObj
=
nullptr
;
}
}
;
template
<
class
ClassType
>
struct
nsRunnableMethodReceiver
<
ClassType
false
>
{
ClassType
*
MOZ_NON_OWNING_REF
mObj
;
explicit
nsRunnableMethodReceiver
(
ClassType
*
aObj
)
:
mObj
(
aObj
)
{
}
ClassType
*
Get
(
)
const
{
return
mObj
;
}
void
Revoke
(
)
{
mObj
=
nullptr
;
}
}
;
template
<
typename
PtrType
typename
Method
bool
Owning
bool
Cancelable
>
struct
nsRunnableMethodTraits
;
template
<
typename
PtrType
class
C
typename
R
bool
Owning
bool
Cancelable
typename
.
.
.
As
>
struct
nsRunnableMethodTraits
<
PtrType
R
(
C
:
:
*
)
(
As
.
.
.
)
Owning
Cancelable
>
{
typedef
typename
mozilla
:
:
RemoveRawOrSmartPointer
<
PtrType
>
:
:
Type
class_type
;
static_assert
(
mozilla
:
:
IsBaseOf
<
C
class_type
>
:
:
value
"
Stored
class
must
inherit
from
method
'
s
class
"
)
;
typedef
R
return_type
;
typedef
nsRunnableMethod
<
C
R
Owning
Cancelable
>
base_type
;
static
const
bool
can_cancel
=
Cancelable
;
}
;
template
<
typename
PtrType
class
C
typename
R
bool
Owning
bool
Cancelable
typename
.
.
.
As
>
struct
nsRunnableMethodTraits
<
PtrType
R
(
C
:
:
*
)
(
As
.
.
.
)
const
Owning
Cancelable
>
{
typedef
const
typename
mozilla
:
:
RemoveRawOrSmartPointer
<
PtrType
>
:
:
Type
class_type
;
static_assert
(
mozilla
:
:
IsBaseOf
<
C
class_type
>
:
:
value
"
Stored
class
must
inherit
from
method
'
s
class
"
)
;
typedef
R
return_type
;
typedef
nsRunnableMethod
<
C
R
Owning
Cancelable
>
base_type
;
static
const
bool
can_cancel
=
Cancelable
;
}
;
#
ifdef
NS_HAVE_STDCALL
template
<
typename
PtrType
class
C
typename
R
bool
Owning
bool
Cancelable
typename
.
.
.
As
>
struct
nsRunnableMethodTraits
<
PtrType
R
(
__stdcall
C
:
:
*
)
(
As
.
.
.
)
Owning
Cancelable
>
{
typedef
typename
mozilla
:
:
RemoveRawOrSmartPointer
<
PtrType
>
:
:
Type
class_type
;
static_assert
(
mozilla
:
:
IsBaseOf
<
C
class_type
>
:
:
value
"
Stored
class
must
inherit
from
method
'
s
class
"
)
;
typedef
R
return_type
;
typedef
nsRunnableMethod
<
C
R
Owning
Cancelable
>
base_type
;
static
const
bool
can_cancel
=
Cancelable
;
}
;
template
<
typename
PtrType
class
C
typename
R
bool
Owning
bool
Cancelable
>
struct
nsRunnableMethodTraits
<
PtrType
R
(
NS_STDCALL
C
:
:
*
)
(
)
Owning
Cancelable
>
{
typedef
typename
mozilla
:
:
RemoveRawOrSmartPointer
<
PtrType
>
:
:
Type
class_type
;
static_assert
(
mozilla
:
:
IsBaseOf
<
C
class_type
>
:
:
value
"
Stored
class
must
inherit
from
method
'
s
class
"
)
;
typedef
R
return_type
;
typedef
nsRunnableMethod
<
C
R
Owning
Cancelable
>
base_type
;
static
const
bool
can_cancel
=
Cancelable
;
}
;
template
<
typename
PtrType
class
C
typename
R
bool
Owning
bool
Cancelable
typename
.
.
.
As
>
struct
nsRunnableMethodTraits
<
PtrType
R
(
__stdcall
C
:
:
*
)
(
As
.
.
.
)
const
Owning
Cancelable
>
{
typedef
const
typename
mozilla
:
:
RemoveRawOrSmartPointer
<
PtrType
>
:
:
Type
class_type
;
static_assert
(
mozilla
:
:
IsBaseOf
<
C
class_type
>
:
:
value
"
Stored
class
must
inherit
from
method
'
s
class
"
)
;
typedef
R
return_type
;
typedef
nsRunnableMethod
<
C
R
Owning
Cancelable
>
base_type
;
static
const
bool
can_cancel
=
Cancelable
;
}
;
template
<
typename
PtrType
class
C
typename
R
bool
Owning
bool
Cancelable
>
struct
nsRunnableMethodTraits
<
PtrType
R
(
NS_STDCALL
C
:
:
*
)
(
)
const
Owning
Cancelable
>
{
typedef
const
typename
mozilla
:
:
RemoveRawOrSmartPointer
<
PtrType
>
:
:
Type
class_type
;
static_assert
(
mozilla
:
:
IsBaseOf
<
C
class_type
>
:
:
value
"
Stored
class
must
inherit
from
method
'
s
class
"
)
;
typedef
R
return_type
;
typedef
nsRunnableMethod
<
C
R
Owning
Cancelable
>
base_type
;
static
const
bool
can_cancel
=
Cancelable
;
}
;
#
endif
template
<
typename
T
>
struct
IsParameterStorageClass
:
public
mozilla
:
:
FalseType
{
}
;
template
<
typename
T
>
struct
StoreCopyPassByValue
{
typedef
T
stored_type
;
typedef
T
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreCopyPassByValue
(
A
&
&
a
)
:
m
(
mozilla
:
:
Forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreCopyPassByValue
<
S
>
>
:
public
mozilla
:
:
TrueType
{
}
;
template
<
typename
T
>
struct
StoreCopyPassByConstLRef
{
typedef
T
stored_type
;
typedef
const
T
&
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreCopyPassByConstLRef
(
A
&
&
a
)
:
m
(
mozilla
:
:
Forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreCopyPassByConstLRef
<
S
>
>
:
public
mozilla
:
:
TrueType
{
}
;
template
<
typename
T
>
struct
StoreCopyPassByLRef
{
typedef
T
stored_type
;
typedef
T
&
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreCopyPassByLRef
(
A
&
&
a
)
:
m
(
mozilla
:
:
Forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreCopyPassByLRef
<
S
>
>
:
public
mozilla
:
:
TrueType
{
}
;
template
<
typename
T
>
struct
StoreCopyPassByRRef
{
typedef
T
stored_type
;
typedef
T
&
&
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreCopyPassByRRef
(
A
&
&
a
)
:
m
(
mozilla
:
:
Forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
mozilla
:
:
Move
(
m
)
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreCopyPassByRRef
<
S
>
>
:
public
mozilla
:
:
TrueType
{
}
;
template
<
typename
T
>
struct
StoreRefPassByLRef
{
typedef
T
&
stored_type
;
typedef
T
&
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreRefPassByLRef
(
A
&
a
)
:
m
(
a
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreRefPassByLRef
<
S
>
>
:
public
mozilla
:
:
TrueType
{
}
;
template
<
typename
T
>
struct
StoreConstRefPassByConstLRef
{
typedef
const
T
&
stored_type
;
typedef
const
T
&
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreConstRefPassByConstLRef
(
const
A
&
a
)
:
m
(
a
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreConstRefPassByConstLRef
<
S
>
>
:
public
mozilla
:
:
TrueType
{
}
;
template
<
typename
T
>
struct
StoreRefPtrPassByPtr
{
typedef
RefPtr
<
T
>
stored_type
;
typedef
T
*
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreRefPtrPassByPtr
(
A
&
&
a
)
:
m
(
mozilla
:
:
Forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
.
get
(
)
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreRefPtrPassByPtr
<
S
>
>
:
public
mozilla
:
:
TrueType
{
}
;
template
<
typename
T
>
struct
StorePtrPassByPtr
{
typedef
T
*
stored_type
;
typedef
T
*
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StorePtrPassByPtr
(
A
a
)
:
m
(
a
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StorePtrPassByPtr
<
S
>
>
:
public
mozilla
:
:
TrueType
{
}
;
template
<
typename
T
>
struct
StoreConstPtrPassByConstPtr
{
typedef
const
T
*
stored_type
;
typedef
const
T
*
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreConstPtrPassByConstPtr
(
A
a
)
:
m
(
a
)
{
}
passed_type
PassAsParameter
(
)
{
return
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreConstPtrPassByConstPtr
<
S
>
>
:
public
mozilla
:
:
TrueType
{
}
;
template
<
typename
T
>
struct
StoreCopyPassByConstPtr
{
typedef
T
stored_type
;
typedef
const
T
*
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreCopyPassByConstPtr
(
A
&
&
a
)
:
m
(
mozilla
:
:
Forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
&
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreCopyPassByConstPtr
<
S
>
>
:
public
mozilla
:
:
TrueType
{
}
;
template
<
typename
T
>
struct
StoreCopyPassByPtr
{
typedef
T
stored_type
;
typedef
T
*
passed_type
;
stored_type
m
;
template
<
typename
A
>
MOZ_IMPLICIT
StoreCopyPassByPtr
(
A
&
&
a
)
:
m
(
mozilla
:
:
Forward
<
A
>
(
a
)
)
{
}
passed_type
PassAsParameter
(
)
{
return
&
m
;
}
}
;
template
<
typename
S
>
struct
IsParameterStorageClass
<
StoreCopyPassByPtr
<
S
>
>
:
public
mozilla
:
:
TrueType
{
}
;
namespace
detail
{
template
<
typename
>
struct
SFINAE1True
:
mozilla
:
:
TrueType
{
}
;
template
<
class
T
>
static
auto
HasRefCountMethodsTest
(
int
)
-
>
SFINAE1True
<
decltype
(
mozilla
:
:
DeclVal
<
T
>
(
)
.
AddRef
(
)
mozilla
:
:
DeclVal
<
T
>
(
)
.
Release
(
)
)
>
;
template
<
class
>
static
auto
HasRefCountMethodsTest
(
long
)
-
>
mozilla
:
:
FalseType
;
template
<
class
T
>
struct
HasRefCountMethods
:
decltype
(
HasRefCountMethodsTest
<
T
>
(
0
)
)
{
}
;
template
<
typename
TWithoutPointer
>
struct
NonnsISupportsPointerStorageClass
:
mozilla
:
:
Conditional
<
mozilla
:
:
IsConst
<
TWithoutPointer
>
:
:
value
StoreConstPtrPassByConstPtr
<
typename
mozilla
:
:
RemoveConst
<
TWithoutPointer
>
:
:
Type
>
StorePtrPassByPtr
<
TWithoutPointer
>
>
{
}
;
template
<
typename
TWithoutPointer
>
struct
PointerStorageClass
:
mozilla
:
:
Conditional
<
HasRefCountMethods
<
TWithoutPointer
>
:
:
value
StoreRefPtrPassByPtr
<
TWithoutPointer
>
typename
NonnsISupportsPointerStorageClass
<
TWithoutPointer
>
:
:
Type
>
{
}
;
template
<
typename
TWithoutRef
>
struct
LValueReferenceStorageClass
:
mozilla
:
:
Conditional
<
mozilla
:
:
IsConst
<
TWithoutRef
>
:
:
value
StoreConstRefPassByConstLRef
<
typename
mozilla
:
:
RemoveConst
<
TWithoutRef
>
:
:
Type
>
StoreRefPassByLRef
<
TWithoutRef
>
>
{
}
;
template
<
typename
T
>
struct
SmartPointerStorageClass
:
mozilla
:
:
Conditional
<
mozilla
:
:
IsRefcountedSmartPointer
<
T
>
:
:
value
StoreRefPtrPassByPtr
<
typename
mozilla
:
:
RemoveSmartPointer
<
T
>
:
:
Type
>
StoreCopyPassByConstLRef
<
T
>
>
{
}
;
template
<
typename
T
>
struct
NonLValueReferenceStorageClass
:
mozilla
:
:
Conditional
<
mozilla
:
:
IsRvalueReference
<
T
>
:
:
value
StoreCopyPassByRRef
<
typename
mozilla
:
:
RemoveReference
<
T
>
:
:
Type
>
typename
SmartPointerStorageClass
<
T
>
:
:
Type
>
{
}
;
template
<
typename
T
>
struct
NonPointerStorageClass
:
mozilla
:
:
Conditional
<
mozilla
:
:
IsLvalueReference
<
T
>
:
:
value
typename
LValueReferenceStorageClass
<
typename
mozilla
:
:
RemoveReference
<
T
>
:
:
Type
>
:
:
Type
typename
NonLValueReferenceStorageClass
<
T
>
:
:
Type
>
{
}
;
template
<
typename
T
>
struct
NonParameterStorageClass
:
mozilla
:
:
Conditional
<
mozilla
:
:
IsPointer
<
T
>
:
:
value
typename
PointerStorageClass
<
typename
mozilla
:
:
RemovePointer
<
T
>
:
:
Type
>
:
:
Type
typename
NonPointerStorageClass
<
T
>
:
:
Type
>
{
}
;
template
<
typename
T
>
struct
ParameterStorage
:
mozilla
:
:
Conditional
<
IsParameterStorageClass
<
T
>
:
:
value
T
typename
NonParameterStorageClass
<
T
>
:
:
Type
>
{
}
;
}
namespace
mozilla
{
namespace
detail
{
template
<
typename
.
.
.
Ts
>
struct
RunnableMethodArguments
final
{
Tuple
<
typename
:
:
detail
:
:
ParameterStorage
<
Ts
>
:
:
Type
.
.
.
>
mArguments
;
template
<
typename
.
.
.
As
>
explicit
RunnableMethodArguments
(
As
&
&
.
.
.
aArguments
)
:
mArguments
(
Forward
<
As
>
(
aArguments
)
.
.
.
)
{
}
template
<
typename
C
typename
M
typename
.
.
.
Args
size_t
.
.
.
Indices
>
static
auto
applyImpl
(
C
*
o
M
m
Tuple
<
Args
.
.
.
>
&
args
IndexSequence
<
Indices
.
.
.
>
)
-
>
decltype
(
(
(
*
o
)
.
*
m
)
(
Get
<
Indices
>
(
args
)
.
PassAsParameter
(
)
.
.
.
)
)
{
return
(
(
*
o
)
.
*
m
)
(
Get
<
Indices
>
(
args
)
.
PassAsParameter
(
)
.
.
.
)
;
}
template
<
class
C
typename
M
>
auto
apply
(
C
*
o
M
m
)
-
>
decltype
(
applyImpl
(
o
m
mArguments
typename
IndexSequenceFor
<
Ts
.
.
.
>
:
:
Type
(
)
)
)
{
return
applyImpl
(
o
m
mArguments
typename
IndexSequenceFor
<
Ts
.
.
.
>
:
:
Type
(
)
)
;
}
}
;
template
<
typename
PtrType
typename
Method
bool
Owning
bool
Cancelable
typename
.
.
.
Storages
>
class
RunnableMethodImpl
final
:
public
:
:
nsRunnableMethodTraits
<
PtrType
Method
Owning
Cancelable
>
:
:
base_type
{
typedef
typename
:
:
nsRunnableMethodTraits
<
PtrType
Method
Owning
Cancelable
>
:
:
class_type
ClassType
;
:
:
nsRunnableMethodReceiver
<
ClassType
Owning
>
mReceiver
;
Method
mMethod
;
RunnableMethodArguments
<
Storages
.
.
.
>
mArgs
;
private
:
virtual
~
RunnableMethodImpl
(
)
{
Revoke
(
)
;
}
;
public
:
template
<
typename
ForwardedPtrType
typename
.
.
.
Args
>
explicit
RunnableMethodImpl
(
ForwardedPtrType
&
&
aObj
Method
aMethod
Args
&
&
.
.
.
aArgs
)
:
mReceiver
(
Forward
<
ForwardedPtrType
>
(
aObj
)
)
mMethod
(
aMethod
)
mArgs
(
Forward
<
Args
>
(
aArgs
)
.
.
.
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
Storages
and
Args
should
have
equal
sizes
"
)
;
}
NS_IMETHOD
Run
(
)
{
if
(
MOZ_LIKELY
(
mReceiver
.
Get
(
)
)
)
{
mArgs
.
apply
(
mReceiver
.
Get
(
)
mMethod
)
;
}
return
NS_OK
;
}
nsresult
Cancel
(
)
{
static_assert
(
Cancelable
"
Don
'
t
use
me
!
"
)
;
Revoke
(
)
;
return
NS_OK
;
}
void
Revoke
(
)
{
mReceiver
.
Revoke
(
)
;
}
}
;
template
<
typename
PtrType
typename
Method
>
using
OwningRunnableMethod
=
typename
:
:
nsRunnableMethodTraits
<
typename
RemoveReference
<
PtrType
>
:
:
Type
Method
true
false
>
:
:
base_type
;
template
<
typename
PtrType
typename
Method
typename
.
.
.
Storages
>
using
OwningRunnableMethodImpl
=
RunnableMethodImpl
<
typename
RemoveReference
<
PtrType
>
:
:
Type
Method
true
false
Storages
.
.
.
>
;
template
<
typename
PtrType
typename
Method
>
using
CancelableRunnableMethod
=
typename
:
:
nsRunnableMethodTraits
<
typename
RemoveReference
<
PtrType
>
:
:
Type
Method
true
true
>
:
:
base_type
;
template
<
typename
PtrType
typename
Method
typename
.
.
.
Storages
>
using
CancelableRunnableMethodImpl
=
RunnableMethodImpl
<
typename
RemoveReference
<
PtrType
>
:
:
Type
Method
true
true
Storages
.
.
.
>
;
template
<
typename
PtrType
typename
Method
>
using
NonOwningRunnableMethod
=
typename
:
:
nsRunnableMethodTraits
<
typename
RemoveReference
<
PtrType
>
:
:
Type
Method
false
false
>
:
:
base_type
;
template
<
typename
PtrType
typename
Method
typename
.
.
.
Storages
>
using
NonOwningRunnableMethodImpl
=
RunnableMethodImpl
<
typename
RemoveReference
<
PtrType
>
:
:
Type
Method
false
false
Storages
.
.
.
>
;
template
<
typename
PtrType
typename
Method
>
using
NonOwningCancelableRunnableMethod
=
typename
:
:
nsRunnableMethodTraits
<
typename
RemoveReference
<
PtrType
>
:
:
Type
Method
false
true
>
:
:
base_type
;
template
<
typename
PtrType
typename
Method
typename
.
.
.
Storages
>
using
NonOwningCancelableRunnableMethodImpl
=
RunnableMethodImpl
<
typename
RemoveReference
<
PtrType
>
:
:
Type
Method
false
true
Storages
.
.
.
>
;
}
template
<
typename
PtrType
typename
Method
>
already_AddRefed
<
detail
:
:
OwningRunnableMethod
<
PtrType
Method
>
>
NewRunnableMethod
(
PtrType
&
&
aPtr
Method
aMethod
)
{
return
do_AddRef
(
new
detail
:
:
OwningRunnableMethodImpl
<
PtrType
Method
>
(
Forward
<
PtrType
>
(
aPtr
)
aMethod
)
)
;
}
template
<
typename
PtrType
typename
Method
>
already_AddRefed
<
detail
:
:
CancelableRunnableMethod
<
PtrType
Method
>
>
NewCancelableRunnableMethod
(
PtrType
&
&
aPtr
Method
aMethod
)
{
return
do_AddRef
(
new
detail
:
:
CancelableRunnableMethodImpl
<
PtrType
Method
>
(
Forward
<
PtrType
>
(
aPtr
)
aMethod
)
)
;
}
template
<
typename
PtrType
typename
Method
>
already_AddRefed
<
detail
:
:
NonOwningRunnableMethod
<
PtrType
Method
>
>
NewNonOwningRunnableMethod
(
PtrType
&
&
aPtr
Method
aMethod
)
{
return
do_AddRef
(
new
detail
:
:
NonOwningRunnableMethodImpl
<
PtrType
Method
>
(
Forward
<
PtrType
>
(
aPtr
)
aMethod
)
)
;
}
template
<
typename
PtrType
typename
Method
>
already_AddRefed
<
detail
:
:
NonOwningCancelableRunnableMethod
<
PtrType
Method
>
>
NewNonOwningCancelableRunnableMethod
(
PtrType
&
&
aPtr
Method
aMethod
)
{
return
do_AddRef
(
new
detail
:
:
NonOwningCancelableRunnableMethodImpl
<
PtrType
Method
>
(
Forward
<
PtrType
>
(
aPtr
)
aMethod
)
)
;
}
template
<
typename
.
.
.
Storages
typename
PtrType
typename
Method
typename
.
.
.
Args
>
already_AddRefed
<
detail
:
:
OwningRunnableMethod
<
PtrType
Method
>
>
NewRunnableMethod
(
PtrType
&
&
aPtr
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
<
Storages
.
.
.
>
size
should
be
equal
to
number
of
arguments
"
)
;
return
do_AddRef
(
new
detail
:
:
OwningRunnableMethodImpl
<
PtrType
Method
Storages
.
.
.
>
(
Forward
<
PtrType
>
(
aPtr
)
aMethod
mozilla
:
:
Forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
template
<
typename
.
.
.
Storages
typename
PtrType
typename
Method
typename
.
.
.
Args
>
already_AddRefed
<
detail
:
:
NonOwningRunnableMethod
<
PtrType
Method
>
>
NewNonOwningRunnableMethod
(
PtrType
&
&
aPtr
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
<
Storages
.
.
.
>
size
should
be
equal
to
number
of
arguments
"
)
;
return
do_AddRef
(
new
detail
:
:
NonOwningRunnableMethodImpl
<
PtrType
Method
Storages
.
.
.
>
(
Forward
<
PtrType
>
(
aPtr
)
aMethod
mozilla
:
:
Forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
template
<
typename
.
.
.
Storages
typename
PtrType
typename
Method
typename
.
.
.
Args
>
already_AddRefed
<
detail
:
:
CancelableRunnableMethod
<
PtrType
Method
>
>
NewCancelableRunnableMethod
(
PtrType
&
&
aPtr
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
<
Storages
.
.
.
>
size
should
be
equal
to
number
of
arguments
"
)
;
return
do_AddRef
(
new
detail
:
:
CancelableRunnableMethodImpl
<
PtrType
Method
Storages
.
.
.
>
(
Forward
<
PtrType
>
(
aPtr
)
aMethod
mozilla
:
:
Forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
template
<
typename
.
.
.
Storages
typename
PtrType
typename
Method
typename
.
.
.
Args
>
already_AddRefed
<
detail
:
:
NonOwningCancelableRunnableMethod
<
PtrType
Method
>
>
NewNonOwningCancelableRunnableMethod
(
PtrType
&
&
aPtr
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
static_assert
(
sizeof
.
.
.
(
Storages
)
=
=
sizeof
.
.
.
(
Args
)
"
<
Storages
.
.
.
>
size
should
be
equal
to
number
of
arguments
"
)
;
return
do_AddRef
(
new
detail
:
:
NonOwningCancelableRunnableMethodImpl
<
PtrType
Method
Storages
.
.
.
>
(
Forward
<
PtrType
>
(
aPtr
)
aMethod
mozilla
:
:
Forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
}
#
endif
template
<
class
T
>
class
nsRevocableEventPtr
{
public
:
nsRevocableEventPtr
(
)
:
mEvent
(
nullptr
)
{
}
~
nsRevocableEventPtr
(
)
{
Revoke
(
)
;
}
const
nsRevocableEventPtr
&
operator
=
(
T
*
aEvent
)
{
if
(
mEvent
!
=
aEvent
)
{
Revoke
(
)
;
mEvent
=
aEvent
;
}
return
*
this
;
}
const
nsRevocableEventPtr
&
operator
=
(
already_AddRefed
<
T
>
aEvent
)
{
RefPtr
<
T
>
event
=
aEvent
;
if
(
mEvent
!
=
event
)
{
Revoke
(
)
;
mEvent
=
event
.
forget
(
)
;
}
return
*
this
;
}
void
Revoke
(
)
{
if
(
mEvent
)
{
mEvent
-
>
Revoke
(
)
;
mEvent
=
nullptr
;
}
}
void
Forget
(
)
{
mEvent
=
nullptr
;
}
bool
IsPending
(
)
{
return
mEvent
!
=
nullptr
;
}
T
*
get
(
)
{
return
mEvent
;
}
private
:
nsRevocableEventPtr
(
const
nsRevocableEventPtr
&
)
;
nsRevocableEventPtr
&
operator
=
(
const
nsRevocableEventPtr
&
)
;
RefPtr
<
T
>
mEvent
;
}
;
class
nsThreadPoolNaming
{
public
:
nsThreadPoolNaming
(
)
:
mCounter
(
0
)
{
}
nsCString
GetNextThreadName
(
const
nsACString
&
aPoolName
)
;
template
<
size_t
LEN
>
nsCString
GetNextThreadName
(
const
char
(
&
aPoolName
)
[
LEN
]
)
{
return
GetNextThreadName
(
nsDependentCString
(
aPoolName
LEN
-
1
)
)
;
}
private
:
mozilla
:
:
Atomic
<
uint32_t
>
mCounter
;
nsThreadPoolNaming
(
const
nsThreadPoolNaming
&
)
=
delete
;
void
operator
=
(
const
nsThreadPoolNaming
&
)
=
delete
;
}
;
class
MOZ_STACK_CLASS
nsAutoLowPriorityIO
{
public
:
nsAutoLowPriorityIO
(
)
;
~
nsAutoLowPriorityIO
(
)
;
private
:
bool
lowIOPrioritySet
;
#
if
defined
(
XP_MACOSX
)
int
oldPriority
;
#
endif
}
;
void
NS_SetMainThread
(
)
;
#
endif
