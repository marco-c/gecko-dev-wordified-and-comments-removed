#
ifndef
mozilla_SyncRunnable_h
#
define
mozilla_SyncRunnable_h
#
include
<
utility
>
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
dom
/
JSExecutionManager
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
class
SyncRunnable
:
public
Runnable
{
public
:
explicit
SyncRunnable
(
nsIRunnable
*
aRunnable
)
:
Runnable
(
"
SyncRunnable
"
)
mRunnable
(
aRunnable
)
mMonitor
(
"
SyncRunnable
"
)
mDone
(
false
)
{
}
explicit
SyncRunnable
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
:
Runnable
(
"
SyncRunnable
"
)
mRunnable
(
std
:
:
move
(
aRunnable
)
)
mMonitor
(
"
SyncRunnable
"
)
mDone
(
false
)
{
}
nsresult
DispatchToThread
(
nsIEventTarget
*
aThread
bool
aForceDispatch
=
false
)
{
nsresult
rv
;
bool
on
;
if
(
!
aForceDispatch
)
{
rv
=
aThread
-
>
IsOnCurrentThread
(
&
on
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
on
)
{
mRunnable
-
>
Run
(
)
;
return
NS_OK
;
}
}
rv
=
aThread
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
dom
:
:
AutoYieldJSThreadExecution
yield
;
while
(
!
mDone
)
{
lock
.
Wait
(
)
;
}
}
return
rv
;
}
nsresult
DispatchToThread
(
AbstractThread
*
aThread
bool
aForceDispatch
=
false
)
{
if
(
!
aForceDispatch
&
&
aThread
-
>
IsCurrentThreadIn
(
)
)
{
mRunnable
-
>
Run
(
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
!
aThread
-
>
RequiresTailDispatchFromCurrentThread
(
)
)
;
nsresult
rv
=
aThread
-
>
Dispatch
(
RefPtr
<
nsIRunnable
>
(
this
)
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
!
mDone
)
{
lock
.
Wait
(
)
;
}
}
return
rv
;
}
static
nsresult
DispatchToThread
(
nsIEventTarget
*
aThread
nsIRunnable
*
aRunnable
bool
aForceDispatch
=
false
)
{
RefPtr
<
SyncRunnable
>
s
(
new
SyncRunnable
(
aRunnable
)
)
;
return
s
-
>
DispatchToThread
(
aThread
aForceDispatch
)
;
}
static
nsresult
DispatchToThread
(
AbstractThread
*
aThread
nsIRunnable
*
aRunnable
bool
aForceDispatch
=
false
)
{
RefPtr
<
SyncRunnable
>
s
(
new
SyncRunnable
(
aRunnable
)
)
;
return
s
-
>
DispatchToThread
(
aThread
aForceDispatch
)
;
}
static
nsresult
DispatchToThread
(
nsIEventTarget
*
aThread
already_AddRefed
<
nsIRunnable
>
aRunnable
bool
aForceDispatch
=
false
)
{
RefPtr
<
SyncRunnable
>
s
(
new
SyncRunnable
(
std
:
:
move
(
aRunnable
)
)
)
;
return
s
-
>
DispatchToThread
(
aThread
aForceDispatch
)
;
}
static
nsresult
DispatchToThread
(
AbstractThread
*
aThread
already_AddRefed
<
nsIRunnable
>
aRunnable
bool
aForceDispatch
=
false
)
{
RefPtr
<
SyncRunnable
>
s
(
new
SyncRunnable
(
std
:
:
move
(
aRunnable
)
)
)
;
return
s
-
>
DispatchToThread
(
aThread
aForceDispatch
)
;
}
static
nsresult
DispatchToThread
(
nsIEventTarget
*
aThread
SyncRunnable
*
aRunnable
bool
aForceDispatch
=
false
)
=
delete
;
static
nsresult
DispatchToThread
(
AbstractThread
*
aThread
SyncRunnable
*
aRunnable
bool
aForceDispatch
=
false
)
=
delete
;
protected
:
NS_IMETHOD
Run
(
)
override
{
mRunnable
-
>
Run
(
)
;
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
!
mDone
)
;
mDone
=
true
;
mMonitor
.
Notify
(
)
;
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
mozilla
:
:
Monitor
mMonitor
;
bool
mDone
MOZ_GUARDED_BY
(
mMonitor
)
;
}
;
}
#
endif
