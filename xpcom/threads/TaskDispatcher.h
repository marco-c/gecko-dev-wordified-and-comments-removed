#
if
!
defined
(
TaskDispatcher_h_
)
#
define
TaskDispatcher_h_
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
<
queue
>
namespace
mozilla
{
class
TaskDispatcher
{
public
:
TaskDispatcher
(
)
{
}
virtual
~
TaskDispatcher
(
)
{
}
virtual
void
AddDirectTask
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
=
0
;
virtual
void
AddStateChangeTask
(
AbstractThread
*
aThread
already_AddRefed
<
nsIRunnable
>
aRunnable
)
=
0
;
virtual
nsresult
AddTask
(
AbstractThread
*
aThread
already_AddRefed
<
nsIRunnable
>
aRunnable
)
=
0
;
virtual
nsresult
DispatchTasksFor
(
AbstractThread
*
aThread
)
=
0
;
virtual
bool
HasTasksFor
(
AbstractThread
*
aThread
)
=
0
;
virtual
void
DrainDirectTasks
(
)
=
0
;
}
;
class
AutoTaskDispatcher
:
public
TaskDispatcher
{
public
:
explicit
AutoTaskDispatcher
(
bool
aIsTailDispatcher
=
false
)
:
mIsTailDispatcher
(
aIsTailDispatcher
)
{
}
~
AutoTaskDispatcher
(
)
{
MOZ_ASSERT
(
!
HaveDirectTasks
(
)
)
;
for
(
size_t
i
=
0
;
i
<
mTaskGroups
.
Length
(
)
;
+
+
i
)
{
DispatchTaskGroup
(
std
:
:
move
(
mTaskGroups
[
i
]
)
)
;
}
}
bool
HaveDirectTasks
(
)
const
{
return
mDirectTasks
.
isSome
(
)
&
&
!
mDirectTasks
-
>
empty
(
)
;
}
void
DrainDirectTasks
(
)
override
{
while
(
HaveDirectTasks
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
mDirectTasks
-
>
front
(
)
;
mDirectTasks
-
>
pop
(
)
;
r
-
>
Run
(
)
;
}
}
void
AddDirectTask
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
override
{
if
(
mDirectTasks
.
isNothing
(
)
)
{
mDirectTasks
.
emplace
(
)
;
}
mDirectTasks
-
>
push
(
std
:
:
move
(
aRunnable
)
)
;
}
void
AddStateChangeTask
(
AbstractThread
*
aThread
already_AddRefed
<
nsIRunnable
>
aRunnable
)
override
{
nsCOMPtr
<
nsIRunnable
>
r
=
aRunnable
;
MOZ_RELEASE_ASSERT
(
r
)
;
EnsureTaskGroup
(
aThread
)
.
mStateChangeTasks
.
AppendElement
(
r
.
forget
(
)
)
;
}
nsresult
AddTask
(
AbstractThread
*
aThread
already_AddRefed
<
nsIRunnable
>
aRunnable
)
override
{
nsCOMPtr
<
nsIRunnable
>
r
=
aRunnable
;
MOZ_RELEASE_ASSERT
(
r
)
;
if
(
mTaskGroups
.
Length
(
)
=
=
0
|
|
mTaskGroups
.
LastElement
(
)
-
>
mThread
!
=
aThread
)
{
mTaskGroups
.
AppendElement
(
new
PerThreadTaskGroup
(
aThread
)
)
;
}
PerThreadTaskGroup
&
group
=
*
mTaskGroups
.
LastElement
(
)
;
group
.
mRegularTasks
.
AppendElement
(
r
.
forget
(
)
)
;
return
NS_OK
;
}
bool
HasTasksFor
(
AbstractThread
*
aThread
)
override
{
return
!
!
GetTaskGroup
(
aThread
)
|
|
(
aThread
=
=
AbstractThread
:
:
GetCurrent
(
)
&
&
HaveDirectTasks
(
)
)
;
}
nsresult
DispatchTasksFor
(
AbstractThread
*
aThread
)
override
{
nsresult
rv
=
NS_OK
;
for
(
size_t
i
=
0
;
i
<
mTaskGroups
.
Length
(
)
;
+
+
i
)
{
if
(
mTaskGroups
[
i
]
-
>
mThread
=
=
aThread
)
{
nsresult
rv2
=
DispatchTaskGroup
(
std
:
:
move
(
mTaskGroups
[
i
]
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv2
)
)
&
&
NS_SUCCEEDED
(
rv
)
)
{
rv
=
rv2
;
}
mTaskGroups
.
RemoveElementAt
(
i
-
-
)
;
}
}
return
rv
;
}
private
:
struct
PerThreadTaskGroup
{
public
:
explicit
PerThreadTaskGroup
(
AbstractThread
*
aThread
)
:
mThread
(
aThread
)
{
MOZ_COUNT_CTOR
(
PerThreadTaskGroup
)
;
}
~
PerThreadTaskGroup
(
)
{
MOZ_COUNT_DTOR
(
PerThreadTaskGroup
)
;
}
RefPtr
<
AbstractThread
>
mThread
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mStateChangeTasks
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mRegularTasks
;
}
;
class
TaskGroupRunnable
:
public
Runnable
{
public
:
explicit
TaskGroupRunnable
(
UniquePtr
<
PerThreadTaskGroup
>
&
&
aTasks
)
:
Runnable
(
"
AutoTaskDispatcher
:
:
TaskGroupRunnable
"
)
mTasks
(
std
:
:
move
(
aTasks
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
for
(
size_t
i
=
0
;
i
<
mTasks
-
>
mStateChangeTasks
.
Length
(
)
;
+
+
i
)
{
mTasks
-
>
mStateChangeTasks
[
i
]
-
>
Run
(
)
;
}
MaybeDrainDirectTasks
(
)
;
for
(
size_t
i
=
0
;
i
<
mTasks
-
>
mRegularTasks
.
Length
(
)
;
+
+
i
)
{
mTasks
-
>
mRegularTasks
[
i
]
-
>
Run
(
)
;
MaybeDrainDirectTasks
(
)
;
}
return
NS_OK
;
}
private
:
void
MaybeDrainDirectTasks
(
)
{
AbstractThread
*
currentThread
=
AbstractThread
:
:
GetCurrent
(
)
;
if
(
currentThread
)
{
currentThread
-
>
TailDispatcher
(
)
.
DrainDirectTasks
(
)
;
}
}
UniquePtr
<
PerThreadTaskGroup
>
mTasks
;
}
;
PerThreadTaskGroup
&
EnsureTaskGroup
(
AbstractThread
*
aThread
)
{
PerThreadTaskGroup
*
existing
=
GetTaskGroup
(
aThread
)
;
if
(
existing
)
{
return
*
existing
;
}
mTaskGroups
.
AppendElement
(
new
PerThreadTaskGroup
(
aThread
)
)
;
return
*
mTaskGroups
.
LastElement
(
)
;
}
PerThreadTaskGroup
*
GetTaskGroup
(
AbstractThread
*
aThread
)
{
for
(
size_t
i
=
0
;
i
<
mTaskGroups
.
Length
(
)
;
+
+
i
)
{
if
(
mTaskGroups
[
i
]
-
>
mThread
=
=
aThread
)
{
return
mTaskGroups
[
i
]
.
get
(
)
;
}
}
return
nullptr
;
}
nsresult
DispatchTaskGroup
(
UniquePtr
<
PerThreadTaskGroup
>
aGroup
)
{
RefPtr
<
AbstractThread
>
thread
=
aGroup
-
>
mThread
;
AbstractThread
:
:
DispatchReason
reason
=
mIsTailDispatcher
?
AbstractThread
:
:
TailDispatch
:
AbstractThread
:
:
NormalDispatch
;
nsCOMPtr
<
nsIRunnable
>
r
=
new
TaskGroupRunnable
(
std
:
:
move
(
aGroup
)
)
;
return
thread
-
>
Dispatch
(
r
.
forget
(
)
reason
)
;
}
mozilla
:
:
Maybe
<
std
:
:
queue
<
nsCOMPtr
<
nsIRunnable
>
>
>
mDirectTasks
;
nsTArray
<
UniquePtr
<
PerThreadTaskGroup
>
>
mTaskGroups
;
const
bool
mIsTailDispatcher
;
}
;
template
<
typename
T
>
class
PassByRef
{
public
:
PassByRef
(
)
{
}
operator
T
&
(
)
{
return
mVal
;
}
private
:
T
mVal
;
}
;
}
#
endif
