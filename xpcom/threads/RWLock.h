#
ifndef
mozilla_RWLock_h
#
define
mozilla_RWLock_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
BlockingResourceBase
.
h
"
#
ifndef
XP_WIN
#
include
<
pthread
.
h
>
#
endif
namespace
mozilla
{
class
RWLock
:
public
BlockingResourceBase
{
public
:
explicit
RWLock
(
const
char
*
aName
)
;
#
ifdef
XP_WIN
~
RWLock
(
)
=
default
;
#
else
~
RWLock
(
)
;
#
endif
#
ifdef
DEBUG
bool
LockedForWritingByCurrentThread
(
)
;
bool
TryReadLock
(
)
;
void
ReadLock
(
)
;
void
ReadUnlock
(
)
;
bool
TryWriteLock
(
)
;
void
WriteLock
(
)
;
void
WriteUnlock
(
)
;
#
else
bool
TryReadLock
(
)
{
return
TryReadLockInternal
(
)
;
}
void
ReadLock
(
)
{
ReadLockInternal
(
)
;
}
void
ReadUnlock
(
)
{
ReadUnlockInternal
(
)
;
}
bool
TryWriteLock
(
)
{
return
TryWriteLockInternal
(
)
;
}
void
WriteLock
(
)
{
WriteLockInternal
(
)
;
}
void
WriteUnlock
(
)
{
WriteUnlockInternal
(
)
;
}
#
endif
private
:
bool
TryReadLockInternal
(
)
;
void
ReadLockInternal
(
)
;
void
ReadUnlockInternal
(
)
;
bool
TryWriteLockInternal
(
)
;
void
WriteLockInternal
(
)
;
void
WriteUnlockInternal
(
)
;
RWLock
(
)
=
delete
;
RWLock
(
const
RWLock
&
)
=
delete
;
RWLock
&
operator
=
(
const
RWLock
&
)
=
delete
;
#
ifndef
XP_WIN
pthread_rwlock_t
mRWLock
;
#
else
void
*
mRWLock
;
#
endif
#
ifdef
DEBUG
PRThread
*
mOwningThread
;
#
endif
}
;
template
<
typename
T
>
class
MOZ_RAII
BaseAutoTryReadLock
{
public
:
explicit
BaseAutoTryReadLock
(
T
&
aLock
)
:
mLock
(
aLock
.
TryReadLock
(
)
?
&
aLock
:
nullptr
)
{
}
~
BaseAutoTryReadLock
(
)
{
if
(
mLock
)
{
mLock
-
>
ReadUnlock
(
)
;
}
}
explicit
operator
bool
(
)
const
{
return
mLock
;
}
private
:
BaseAutoTryReadLock
(
)
=
delete
;
BaseAutoTryReadLock
(
const
BaseAutoTryReadLock
&
)
=
delete
;
BaseAutoTryReadLock
&
operator
=
(
const
BaseAutoTryReadLock
&
)
=
delete
;
T
*
mLock
;
}
;
template
<
typename
T
>
class
MOZ_RAII
BaseAutoReadLock
{
public
:
explicit
BaseAutoReadLock
(
T
&
aLock
)
:
mLock
(
&
aLock
)
{
MOZ_ASSERT
(
mLock
"
null
lock
"
)
;
mLock
-
>
ReadLock
(
)
;
}
~
BaseAutoReadLock
(
)
{
mLock
-
>
ReadUnlock
(
)
;
}
private
:
BaseAutoReadLock
(
)
=
delete
;
BaseAutoReadLock
(
const
BaseAutoReadLock
&
)
=
delete
;
BaseAutoReadLock
&
operator
=
(
const
BaseAutoReadLock
&
)
=
delete
;
T
*
mLock
;
}
;
template
<
typename
T
>
class
MOZ_RAII
BaseAutoTryWriteLock
{
public
:
explicit
BaseAutoTryWriteLock
(
T
&
aLock
)
:
mLock
(
aLock
.
TryWriteLock
(
)
?
&
aLock
:
nullptr
)
{
}
~
BaseAutoTryWriteLock
(
)
{
if
(
mLock
)
{
mLock
-
>
WriteUnlock
(
)
;
}
}
explicit
operator
bool
(
)
const
{
return
mLock
;
}
private
:
BaseAutoTryWriteLock
(
)
=
delete
;
BaseAutoTryWriteLock
(
const
BaseAutoTryWriteLock
&
)
=
delete
;
BaseAutoTryWriteLock
&
operator
=
(
const
BaseAutoTryWriteLock
&
)
=
delete
;
T
*
mLock
;
}
;
template
<
typename
T
>
class
MOZ_RAII
BaseAutoWriteLock
final
{
public
:
explicit
BaseAutoWriteLock
(
T
&
aLock
)
:
mLock
(
&
aLock
)
{
MOZ_ASSERT
(
mLock
"
null
lock
"
)
;
mLock
-
>
WriteLock
(
)
;
}
~
BaseAutoWriteLock
(
)
{
mLock
-
>
WriteUnlock
(
)
;
}
private
:
BaseAutoWriteLock
(
)
=
delete
;
BaseAutoWriteLock
(
const
BaseAutoWriteLock
&
)
=
delete
;
BaseAutoWriteLock
&
operator
=
(
const
BaseAutoWriteLock
&
)
=
delete
;
T
*
mLock
;
}
;
typedef
BaseAutoTryReadLock
<
RWLock
>
AutoTryReadLock
;
typedef
BaseAutoReadLock
<
RWLock
>
AutoReadLock
;
typedef
BaseAutoTryWriteLock
<
RWLock
>
AutoTryWriteLock
;
typedef
BaseAutoWriteLock
<
RWLock
>
AutoWriteLock
;
namespace
detail
{
class
StaticRWLock
{
public
:
#
ifdef
DEBUG
StaticRWLock
(
)
{
MOZ_ASSERT
(
!
mLock
)
;
}
#
endif
bool
TryReadLock
(
)
{
return
Lock
(
)
-
>
TryReadLock
(
)
;
}
void
ReadLock
(
)
{
Lock
(
)
-
>
ReadLock
(
)
;
}
void
ReadUnlock
(
)
{
Lock
(
)
-
>
ReadUnlock
(
)
;
}
bool
TryWriteLock
(
)
{
return
Lock
(
)
-
>
TryWriteLock
(
)
;
}
void
WriteLock
(
)
{
Lock
(
)
-
>
WriteLock
(
)
;
}
void
WriteUnlock
(
)
{
Lock
(
)
-
>
WriteUnlock
(
)
;
}
private
:
RWLock
*
Lock
(
)
{
if
(
mLock
)
{
return
mLock
;
}
RWLock
*
lock
=
new
RWLock
(
"
StaticRWLock
"
)
;
if
(
!
mLock
.
compareExchange
(
nullptr
lock
)
)
{
delete
lock
;
}
return
mLock
;
}
Atomic
<
RWLock
*
>
mLock
;
#
ifdef
DEBUG
StaticRWLock
(
const
StaticRWLock
&
aOther
)
;
#
endif
StaticRWLock
&
operator
=
(
StaticRWLock
*
aRhs
)
;
static
void
*
operator
new
(
size_t
)
noexcept
(
true
)
;
static
void
operator
delete
(
void
*
)
;
}
;
typedef
BaseAutoTryReadLock
<
StaticRWLock
>
StaticAutoTryReadLock
;
typedef
BaseAutoReadLock
<
StaticRWLock
>
StaticAutoReadLock
;
typedef
BaseAutoTryWriteLock
<
StaticRWLock
>
StaticAutoTryWriteLock
;
typedef
BaseAutoWriteLock
<
StaticRWLock
>
StaticAutoWriteLock
;
}
}
#
endif
