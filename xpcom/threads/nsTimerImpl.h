#
ifndef
nsTimerImpl_h___
#
define
nsTimerImpl_h___
#
include
"
nsITimer
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
extern
mozilla
:
:
LogModule
*
GetTimerLog
(
)
;
#
define
NS_TIMER_CID
\
{
/
*
5ff24248
-
1dd2
-
11b2
-
8427
-
fbab44f29bc8
*
/
\
0x5ff24248
0x1dd2
0x11b2
{
\
0x84
0x27
0xfb
0xab
0x44
0xf2
0x9b
0xc8
\
}
\
}
class
nsIObserver
;
class
nsTimerImplHolder
;
namespace
mozilla
{
class
LogModule
;
}
class
nsTimerImpl
{
~
nsTimerImpl
(
)
{
MOZ_ASSERT
(
!
mHolder
)
;
MOZ_ASSERT
(
mCallback
.
is
<
UnknownCallback
>
(
)
|
|
mEventTarget
-
>
IsOnCurrentThread
(
)
"
Must
not
release
mCallback
off
-
target
without
canceling
"
)
;
}
public
:
typedef
mozilla
:
:
TimeStamp
TimeStamp
;
nsTimerImpl
(
nsITimer
*
aTimer
nsIEventTarget
*
aTarget
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsTimerImpl
)
NS_DECL_NON_VIRTUAL_NSITIMER
static
nsresult
Startup
(
)
;
static
void
Shutdown
(
)
;
void
SetDelayInternal
(
uint32_t
aDelay
TimeStamp
aBase
=
TimeStamp
:
:
Now
(
)
)
;
void
CancelImpl
(
bool
aClearITimer
)
;
void
Fire
(
int32_t
aGeneration
)
;
int32_t
GetGeneration
(
)
{
return
mGeneration
;
}
struct
UnknownCallback
{
}
;
using
InterfaceCallback
=
nsCOMPtr
<
nsITimerCallback
>
;
using
ObserverCallback
=
nsCOMPtr
<
nsIObserver
>
;
struct
FuncCallback
{
nsTimerCallbackFunc
mFunc
;
void
*
mClosure
;
const
char
*
mName
;
}
;
struct
ClosureCallback
{
std
:
:
function
<
void
(
nsITimer
*
)
>
mFunc
;
const
char
*
mName
;
}
;
using
Callback
=
mozilla
:
:
Variant
<
UnknownCallback
InterfaceCallback
ObserverCallback
FuncCallback
ClosureCallback
>
;
nsresult
InitCommon
(
const
mozilla
:
:
TimeDuration
&
aDelay
uint32_t
aType
Callback
&
&
newCallback
const
mozilla
:
:
MutexAutoLock
&
aProofOfLock
)
MOZ_REQUIRES
(
mMutex
)
;
Callback
&
GetCallback
(
)
MOZ_REQUIRES
(
mMutex
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
return
mCallback
;
}
bool
IsRepeating
(
)
const
{
static_assert
(
nsITimer
:
:
TYPE_ONE_SHOT
<
nsITimer
:
:
TYPE_REPEATING_SLACK
"
invalid
ordering
of
timer
types
!
"
)
;
static_assert
(
nsITimer
:
:
TYPE_REPEATING_SLACK
<
nsITimer
:
:
TYPE_REPEATING_PRECISE
"
invalid
ordering
of
timer
types
!
"
)
;
static_assert
(
nsITimer
:
:
TYPE_REPEATING_PRECISE
<
nsITimer
:
:
TYPE_REPEATING_PRECISE_CAN_SKIP
"
invalid
ordering
of
timer
types
!
"
)
;
return
mType
>
=
nsITimer
:
:
TYPE_REPEATING_SLACK
&
&
mType
<
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
;
}
bool
IsLowPriority
(
)
const
{
return
mType
=
=
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
|
|
mType
=
=
nsITimer
:
:
TYPE_REPEATING_SLACK_LOW_PRIORITY
;
}
bool
IsSlack
(
)
const
{
return
mType
=
=
nsITimer
:
:
TYPE_REPEATING_SLACK
|
|
mType
=
=
nsITimer
:
:
TYPE_REPEATING_SLACK_LOW_PRIORITY
;
}
void
GetName
(
nsACString
&
aName
const
mozilla
:
:
MutexAutoLock
&
aProofOfLock
)
MOZ_REQUIRES
(
mMutex
)
;
void
GetName
(
nsACString
&
aName
)
;
void
SetHolder
(
nsTimerImplHolder
*
aHolder
)
;
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
void
LogFiring
(
const
Callback
&
aCallback
uint8_t
aType
uint32_t
aDelay
)
;
nsresult
InitWithClosureCallback
(
std
:
:
function
<
void
(
nsITimer
*
)
>
&
&
aCallback
const
mozilla
:
:
TimeDuration
&
aDelay
uint32_t
aType
const
char
*
aNameString
)
;
nsTimerImplHolder
*
mHolder
;
uint8_t
mType
;
int32_t
mGeneration
;
mozilla
:
:
TimeDuration
mDelay
MOZ_GUARDED_BY
(
mMutex
)
;
mozilla
:
:
TimeStamp
mTimeout
;
RefPtr
<
nsITimer
>
mITimer
MOZ_GUARDED_BY
(
mMutex
)
;
mozilla
:
:
Mutex
mMutex
;
Callback
mCallback
MOZ_GUARDED_BY
(
mMutex
)
;
unsigned
int
mFiring
MOZ_GUARDED_BY
(
mMutex
)
;
static
mozilla
:
:
StaticMutex
sDeltaMutex
;
static
double
sDeltaSum
MOZ_GUARDED_BY
(
sDeltaMutex
)
;
static
double
sDeltaSumSquared
MOZ_GUARDED_BY
(
sDeltaMutex
)
;
static
double
sDeltaNum
MOZ_GUARDED_BY
(
sDeltaMutex
)
;
}
;
class
nsTimer
final
:
public
nsITimer
{
explicit
nsTimer
(
nsIEventTarget
*
aTarget
)
:
mImpl
(
new
nsTimerImpl
(
this
aTarget
)
)
{
}
virtual
~
nsTimer
(
)
;
public
:
friend
class
TimerThread
;
friend
class
nsTimerEvent
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_FORWARD_SAFE_NSITIMER
(
mImpl
)
;
nsresult
InitWithClosureCallback
(
std
:
:
function
<
void
(
nsITimer
*
)
>
&
&
aCallback
const
mozilla
:
:
TimeDuration
&
aDelay
uint32_t
aType
const
char
*
aNameString
)
{
return
mImpl
?
mImpl
-
>
InitWithClosureCallback
(
std
:
:
move
(
aCallback
)
aDelay
aType
aNameString
)
:
NS_ERROR_NULL_POINTER
;
}
static
RefPtr
<
nsTimer
>
WithEventTarget
(
nsIEventTarget
*
aTarget
)
;
static
nsresult
XPCOMConstructor
(
REFNSIID
aIID
void
*
*
aResult
)
;
private
:
RefPtr
<
nsTimerImpl
>
mImpl
;
}
;
class
nsTimerImplHolder
{
public
:
explicit
nsTimerImplHolder
(
nsTimerImpl
*
aTimerImpl
)
:
mTimerImpl
(
aTimerImpl
)
{
if
(
mTimerImpl
)
{
mTimerImpl
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
mTimerImpl
-
>
SetHolder
(
this
)
;
}
}
~
nsTimerImplHolder
(
)
{
if
(
mTimerImpl
)
{
mTimerImpl
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
mTimerImpl
-
>
SetHolder
(
nullptr
)
;
}
}
void
Forget
(
nsTimerImpl
*
aTimerImpl
)
{
if
(
MOZ_UNLIKELY
(
!
mTimerImpl
)
)
{
return
;
}
MOZ_ASSERT
(
aTimerImpl
=
=
mTimerImpl
)
;
mTimerImpl
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
mTimerImpl
-
>
SetHolder
(
nullptr
)
;
mTimerImpl
=
nullptr
;
}
protected
:
RefPtr
<
nsTimerImpl
>
mTimerImpl
;
}
;
#
endif
