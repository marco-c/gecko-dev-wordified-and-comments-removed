#
ifndef
nsTimerImpl_h___
#
define
nsTimerImpl_h___
#
include
"
nsITimer
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
ifdef
MOZ_TASK_TRACER
#
include
"
TracedTaskCommon
.
h
"
#
endif
extern
mozilla
:
:
LogModule
*
GetTimerLog
(
)
;
#
define
NS_TIMER_CID
\
{
/
*
5ff24248
-
1dd2
-
11b2
-
8427
-
fbab44f29bc8
*
/
\
0x5ff24248
0x1dd2
0x11b2
{
\
0x84
0x27
0xfb
0xab
0x44
0xf2
0x9b
0xc8
\
}
\
}
class
nsIObserver
;
class
nsTimerImplHolder
;
namespace
mozilla
{
class
LogModule
;
}
class
nsTimerImpl
{
~
nsTimerImpl
(
)
{
MOZ_ASSERT
(
!
mHolder
)
;
}
public
:
typedef
mozilla
:
:
TimeStamp
TimeStamp
;
nsTimerImpl
(
nsITimer
*
aTimer
nsIEventTarget
*
aTarget
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsTimerImpl
)
NS_DECL_NON_VIRTUAL_NSITIMER
static
nsresult
Startup
(
)
;
static
void
Shutdown
(
)
;
void
SetDelayInternal
(
uint32_t
aDelay
TimeStamp
aBase
=
TimeStamp
:
:
Now
(
)
)
;
void
CancelImpl
(
bool
aClearITimer
)
;
void
Fire
(
int32_t
aGeneration
)
;
#
ifdef
MOZ_TASK_TRACER
void
GetTLSTraceInfo
(
)
;
mozilla
:
:
tasktracer
:
:
TracedTaskCommon
GetTracedTask
(
)
;
#
endif
int32_t
GetGeneration
(
)
{
return
mGeneration
;
}
struct
Callback
{
Callback
(
)
:
mType
(
Type
:
:
Unknown
)
mName
(
Nothing
)
mClosure
(
nullptr
)
{
mCallback
.
c
=
nullptr
;
}
Callback
(
const
Callback
&
other
)
:
Callback
(
)
{
*
this
=
other
;
}
enum
class
Type
:
uint8_t
{
Unknown
=
0
Interface
=
1
Function
=
2
Observer
=
3
}
;
Callback
&
operator
=
(
const
Callback
&
other
)
{
if
(
this
!
=
&
other
)
{
clear
(
)
;
mType
=
other
.
mType
;
switch
(
mType
)
{
case
Type
:
:
Unknown
:
break
;
case
Type
:
:
Interface
:
mCallback
.
i
=
other
.
mCallback
.
i
;
NS_ADDREF
(
mCallback
.
i
)
;
break
;
case
Type
:
:
Function
:
mCallback
.
c
=
other
.
mCallback
.
c
;
break
;
case
Type
:
:
Observer
:
mCallback
.
o
=
other
.
mCallback
.
o
;
NS_ADDREF
(
mCallback
.
o
)
;
break
;
}
mName
=
other
.
mName
;
mClosure
=
other
.
mClosure
;
}
return
*
this
;
}
~
Callback
(
)
{
clear
(
)
;
}
void
clear
(
)
{
if
(
mType
=
=
Type
:
:
Interface
)
{
NS_RELEASE
(
mCallback
.
i
)
;
}
else
if
(
mType
=
=
Type
:
:
Observer
)
{
NS_RELEASE
(
mCallback
.
o
)
;
}
mType
=
Type
:
:
Unknown
;
}
void
swap
(
Callback
&
other
)
{
std
:
:
swap
(
mType
other
.
mType
)
;
std
:
:
swap
(
mCallback
other
.
mCallback
)
;
std
:
:
swap
(
mName
other
.
mName
)
;
std
:
:
swap
(
mClosure
other
.
mClosure
)
;
}
Type
mType
;
union
CallbackUnion
{
nsTimerCallbackFunc
c
;
nsITimerCallback
*
MOZ_OWNING_REF
i
;
nsIObserver
*
MOZ_OWNING_REF
o
;
}
mCallback
;
typedef
const
int
NameNothing
;
typedef
const
char
*
NameString
;
typedef
nsTimerNameCallbackFunc
NameFunc
;
typedef
mozilla
:
:
Variant
<
NameNothing
NameString
NameFunc
>
Name
;
static
const
NameNothing
Nothing
;
Name
mName
;
void
*
mClosure
;
}
;
nsresult
InitCommon
(
uint32_t
aDelayMS
uint32_t
aType
Callback
&
&
newCallback
)
;
nsresult
InitCommon
(
const
mozilla
:
:
TimeDuration
&
aDelay
uint32_t
aType
Callback
&
&
newCallback
)
;
Callback
&
GetCallback
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
return
mCallback
;
}
bool
IsRepeating
(
)
const
{
static_assert
(
nsITimer
:
:
TYPE_ONE_SHOT
<
nsITimer
:
:
TYPE_REPEATING_SLACK
"
invalid
ordering
of
timer
types
!
"
)
;
static_assert
(
nsITimer
:
:
TYPE_REPEATING_SLACK
<
nsITimer
:
:
TYPE_REPEATING_PRECISE
"
invalid
ordering
of
timer
types
!
"
)
;
static_assert
(
nsITimer
:
:
TYPE_REPEATING_PRECISE
<
nsITimer
:
:
TYPE_REPEATING_PRECISE_CAN_SKIP
"
invalid
ordering
of
timer
types
!
"
)
;
return
mType
>
=
nsITimer
:
:
TYPE_REPEATING_SLACK
&
&
mType
<
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
;
}
bool
IsLowPriority
(
)
const
{
return
mType
=
=
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
|
|
mType
=
=
nsITimer
:
:
TYPE_REPEATING_SLACK_LOW_PRIORITY
;
}
bool
IsSlack
(
)
const
{
return
mType
=
=
nsITimer
:
:
TYPE_REPEATING_SLACK
|
|
mType
=
=
nsITimer
:
:
TYPE_REPEATING_SLACK_LOW_PRIORITY
;
}
void
GetName
(
nsACString
&
aName
)
;
void
SetHolder
(
nsTimerImplHolder
*
aHolder
)
;
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
void
LogFiring
(
const
Callback
&
aCallback
uint8_t
aType
uint32_t
aDelay
)
;
nsresult
InitWithFuncCallbackCommon
(
nsTimerCallbackFunc
aFunc
void
*
aClosure
uint32_t
aDelay
uint32_t
aType
const
Callback
:
:
Name
&
aName
)
;
nsTimerImplHolder
*
mHolder
;
uint8_t
mType
;
int32_t
mGeneration
;
mozilla
:
:
TimeDuration
mDelay
;
mozilla
:
:
TimeStamp
mTimeout
;
#
ifdef
MOZ_TASK_TRACER
mozilla
:
:
tasktracer
:
:
TracedTaskCommon
mTracedTask
;
#
endif
static
double
sDeltaSum
;
static
double
sDeltaSumSquared
;
static
double
sDeltaNum
;
RefPtr
<
nsITimer
>
mITimer
;
mozilla
:
:
Mutex
mMutex
;
Callback
mCallback
;
unsigned
int
mFiring
;
}
;
class
nsTimer
final
:
public
nsITimer
{
explicit
nsTimer
(
nsIEventTarget
*
aTarget
)
:
mImpl
(
new
nsTimerImpl
(
this
aTarget
)
)
{
}
virtual
~
nsTimer
(
)
;
public
:
friend
class
TimerThread
;
friend
class
nsTimerEvent
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_FORWARD_SAFE_NSITIMER
(
mImpl
)
;
virtual
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
;
static
RefPtr
<
nsTimer
>
WithEventTarget
(
nsIEventTarget
*
aTarget
)
;
static
nsresult
XPCOMConstructor
(
nsISupports
*
aOuter
REFNSIID
aIID
void
*
*
aResult
)
;
private
:
RefPtr
<
nsTimerImpl
>
mImpl
;
}
;
class
nsTimerImplHolder
{
public
:
explicit
nsTimerImplHolder
(
nsTimerImpl
*
aTimerImpl
)
:
mTimerImpl
(
aTimerImpl
)
{
if
(
mTimerImpl
)
{
mTimerImpl
-
>
SetHolder
(
this
)
;
}
}
~
nsTimerImplHolder
(
)
{
if
(
mTimerImpl
)
{
mTimerImpl
-
>
SetHolder
(
nullptr
)
;
}
}
void
Forget
(
nsTimerImpl
*
aTimerImpl
)
{
if
(
MOZ_UNLIKELY
(
!
mTimerImpl
)
)
{
return
;
}
MOZ_ASSERT
(
aTimerImpl
=
=
mTimerImpl
)
;
mTimerImpl
-
>
SetHolder
(
nullptr
)
;
mTimerImpl
=
nullptr
;
}
protected
:
RefPtr
<
nsTimerImpl
>
mTimerImpl
;
}
;
#
endif
