#
ifndef
nsTimerImpl_h___
#
define
nsTimerImpl_h___
#
include
"
nsITimer
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
ifdef
MOZ_TASK_TRACER
#
include
"
TracedTaskCommon
.
h
"
#
endif
extern
mozilla
:
:
LogModule
*
GetTimerLog
(
)
;
#
define
NS_TIMER_CID
\
{
/
*
5ff24248
-
1dd2
-
11b2
-
8427
-
fbab44f29bc8
*
/
\
0x5ff24248
\
0x1dd2
\
0x11b2
\
{
0x84
0x27
0xfb
0xab
0x44
0xf2
0x9b
0xc8
}
\
}
class
nsTimerImpl
{
~
nsTimerImpl
(
)
;
public
:
typedef
mozilla
:
:
TimeStamp
TimeStamp
;
explicit
nsTimerImpl
(
nsITimer
*
aTimer
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsTimerImpl
)
NS_DECL_NON_VIRTUAL_NSITIMER
static
nsresult
Startup
(
)
;
static
void
Shutdown
(
)
;
friend
class
TimerThread
;
friend
class
nsTimerEvent
;
friend
struct
TimerAdditionComparator
;
void
SetDelayInternal
(
uint32_t
aDelay
)
;
void
Fire
(
)
;
#
ifdef
MOZ_TASK_TRACER
void
GetTLSTraceInfo
(
)
;
mozilla
:
:
tasktracer
:
:
TracedTaskCommon
GetTracedTask
(
)
;
#
endif
static
already_AddRefed
<
nsTimerImpl
>
PostTimerEvent
(
already_AddRefed
<
nsTimerImpl
>
aTimerRef
)
;
int32_t
GetGeneration
(
)
{
return
mGeneration
;
}
enum
class
CallbackType
:
uint8_t
{
Unknown
=
0
Interface
=
1
Function
=
2
Observer
=
3
}
;
nsresult
InitCommon
(
uint32_t
aDelay
uint32_t
aType
)
;
void
ReleaseCallback
(
)
{
CallbackType
cbType
=
mCallbackType
;
mCallbackType
=
CallbackType
:
:
Unknown
;
if
(
cbType
=
=
CallbackType
:
:
Interface
)
{
NS_RELEASE
(
mCallback
.
i
)
;
}
else
if
(
cbType
=
=
CallbackType
:
:
Observer
)
{
NS_RELEASE
(
mCallback
.
o
)
;
}
}
void
Neuter
(
)
;
bool
IsRepeating
(
)
const
{
static_assert
(
nsITimer
:
:
TYPE_ONE_SHOT
<
nsITimer
:
:
TYPE_REPEATING_SLACK
"
invalid
ordering
of
timer
types
!
"
)
;
static_assert
(
nsITimer
:
:
TYPE_REPEATING_SLACK
<
nsITimer
:
:
TYPE_REPEATING_PRECISE
"
invalid
ordering
of
timer
types
!
"
)
;
static_assert
(
nsITimer
:
:
TYPE_REPEATING_PRECISE
<
nsITimer
:
:
TYPE_REPEATING_PRECISE_CAN_SKIP
"
invalid
ordering
of
timer
types
!
"
)
;
return
mType
>
=
nsITimer
:
:
TYPE_REPEATING_SLACK
;
}
bool
IsRepeatingPrecisely
(
)
const
{
return
mType
>
=
nsITimer
:
:
TYPE_REPEATING_PRECISE
;
}
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
void
*
mClosure
;
union
CallbackUnion
{
nsTimerCallbackFunc
c
;
nsITimerCallback
*
MOZ_OWNING_REF
i
;
nsIObserver
*
MOZ_OWNING_REF
o
;
}
mCallback
;
void
LogFiring
(
CallbackType
aCallbackType
CallbackUnion
aCallbackUnion
)
;
typedef
const
int
NameNothing
;
typedef
const
char
*
NameString
;
typedef
nsTimerNameCallbackFunc
NameFunc
;
typedef
mozilla
:
:
Variant
<
NameNothing
NameString
NameFunc
>
Name
;
static
const
NameNothing
Nothing
;
nsresult
InitWithFuncCallbackCommon
(
nsTimerCallbackFunc
aFunc
void
*
aClosure
uint32_t
aDelay
uint32_t
aType
Name
aName
)
;
Name
mName
;
nsCOMPtr
<
nsITimerCallback
>
mTimerCallbackWhileFiring
;
CallbackType
mCallbackType
;
uint8_t
mType
;
bool
mFiring
;
bool
mArmed
;
bool
mCanceled
;
int32_t
mGeneration
;
uint32_t
mDelay
;
TimeStamp
mTimeout
;
#
ifdef
MOZ_TASK_TRACER
mozilla
:
:
tasktracer
:
:
TracedTaskCommon
mTracedTask
;
#
endif
TimeStamp
mStart
mStart2
;
static
double
sDeltaSum
;
static
double
sDeltaSumSquared
;
static
double
sDeltaNum
;
RefPtr
<
nsITimer
>
mITimer
;
}
;
class
nsTimer
final
:
public
nsITimer
{
virtual
~
nsTimer
(
)
;
public
:
nsTimer
(
)
:
mImpl
(
new
nsTimerImpl
(
this
)
)
{
}
friend
class
TimerThread
;
friend
class
nsTimerEvent
;
friend
struct
TimerAdditionComparator
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_FORWARD_SAFE_NSITIMER
(
mImpl
)
;
virtual
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
;
private
:
RefPtr
<
nsTimerImpl
>
mImpl
;
}
;
#
endif
