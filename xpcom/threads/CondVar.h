#
ifndef
mozilla_CondVar_h
#
define
mozilla_CondVar_h
#
include
"
mozilla
/
BlockingResourceBase
.
h
"
#
include
"
mozilla
/
PlatformConditionVariable
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
if
defined
(
MOZILLA_INTERNAL_API
)
&
&
!
defined
(
DEBUG
)
#
include
"
mozilla
/
ProfilerThreadSleep
.
h
"
#
endif
namespace
mozilla
{
class
OffTheBooksCondVar
:
BlockingResourceBase
{
public
:
OffTheBooksCondVar
(
OffTheBooksMutex
&
aLock
const
char
*
aName
)
:
BlockingResourceBase
(
aName
eCondVar
)
mLock
(
&
aLock
)
{
}
~
OffTheBooksCondVar
(
)
=
default
;
#
ifndef
DEBUG
void
Wait
(
)
{
#
ifdef
MOZILLA_INTERNAL_API
AUTO_PROFILER_THREAD_SLEEP
;
#
endif
mImpl
.
wait
(
*
mLock
)
;
}
CVStatus
Wait
(
TimeDuration
aDuration
)
{
#
ifdef
MOZILLA_INTERNAL_API
AUTO_PROFILER_THREAD_SLEEP
;
#
endif
return
mImpl
.
wait_for
(
*
mLock
aDuration
)
;
}
#
else
void
Wait
(
)
;
CVStatus
Wait
(
TimeDuration
aDuration
)
;
#
endif
void
Notify
(
)
{
mImpl
.
notify_one
(
)
;
}
void
NotifyAll
(
)
{
mImpl
.
notify_all
(
)
;
}
#
ifdef
DEBUG
void
AssertCurrentThreadOwnsMutex
(
)
const
ASSERT_CAPABILITY
(
mLock
)
{
mLock
-
>
AssertCurrentThreadOwns
(
)
;
}
void
AssertNotCurrentThreadOwnsMutex
(
)
const
ASSERT_CAPABILITY
(
!
mLock
)
{
mLock
-
>
AssertNotCurrentThreadOwns
(
)
;
}
#
else
void
AssertCurrentThreadOwnsMutex
(
)
const
ASSERT_CAPABILITY
(
mLock
)
{
}
void
AssertNotCurrentThreadOwnsMutex
(
)
const
ASSERT_CAPABILITY
(
!
mLock
)
{
}
#
endif
private
:
OffTheBooksCondVar
(
)
;
OffTheBooksCondVar
(
const
OffTheBooksCondVar
&
)
=
delete
;
OffTheBooksCondVar
&
operator
=
(
const
OffTheBooksCondVar
&
)
=
delete
;
OffTheBooksMutex
*
mLock
;
detail
:
:
ConditionVariableImpl
mImpl
;
}
;
class
CondVar
:
public
OffTheBooksCondVar
{
public
:
CondVar
(
OffTheBooksMutex
&
aLock
const
char
*
aName
)
:
OffTheBooksCondVar
(
aLock
aName
)
{
MOZ_COUNT_CTOR
(
CondVar
)
;
}
MOZ_COUNTED_DTOR
(
CondVar
)
private
:
CondVar
(
)
;
CondVar
(
const
CondVar
&
)
;
CondVar
&
operator
=
(
const
CondVar
&
)
;
}
;
}
#
endif
