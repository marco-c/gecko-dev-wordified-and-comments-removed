#
ifndef
mozilla_CondVar_h
#
define
mozilla_CondVar_h
#
include
"
mozilla
/
BlockingResourceBase
.
h
"
#
include
"
mozilla
/
PlatformConditionVariable
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
ifdef
MOZILLA_INTERNAL_API
#
include
"
GeckoProfiler
.
h
"
#
endif
namespace
mozilla
{
class
CondVar
:
BlockingResourceBase
{
public
:
CondVar
(
Mutex
&
aLock
const
char
*
aName
)
:
BlockingResourceBase
(
aName
eCondVar
)
mLock
(
&
aLock
)
{
MOZ_COUNT_CTOR
(
CondVar
)
;
}
~
CondVar
(
)
{
MOZ_COUNT_DTOR
(
CondVar
)
;
}
#
ifndef
DEBUG
nsresult
Wait
(
PRIntervalTime
aInterval
=
PR_INTERVAL_NO_TIMEOUT
)
{
#
ifdef
MOZILLA_INTERNAL_API
AUTO_PROFILER_THREAD_SLEEP
;
#
endif
if
(
aInterval
=
=
PR_INTERVAL_NO_TIMEOUT
)
{
mImpl
.
wait
(
*
mLock
)
;
}
else
{
mImpl
.
wait_for
(
*
mLock
TimeDuration
:
:
FromMilliseconds
(
double
(
aInterval
)
)
)
;
}
return
NS_OK
;
}
#
else
nsresult
Wait
(
PRIntervalTime
aInterval
=
PR_INTERVAL_NO_TIMEOUT
)
;
#
endif
nsresult
Notify
(
)
{
mImpl
.
notify_one
(
)
;
return
NS_OK
;
}
nsresult
NotifyAll
(
)
{
mImpl
.
notify_all
(
)
;
return
NS_OK
;
}
#
ifdef
DEBUG
void
AssertCurrentThreadOwnsMutex
(
)
{
mLock
-
>
AssertCurrentThreadOwns
(
)
;
}
void
AssertNotCurrentThreadOwnsMutex
(
)
{
mLock
-
>
AssertNotCurrentThreadOwns
(
)
;
}
#
else
void
AssertCurrentThreadOwnsMutex
(
)
{
}
void
AssertNotCurrentThreadOwnsMutex
(
)
{
}
#
endif
private
:
CondVar
(
)
;
CondVar
(
const
CondVar
&
)
=
delete
;
CondVar
&
operator
=
(
const
CondVar
&
)
=
delete
;
Mutex
*
mLock
;
detail
:
:
ConditionVariableImpl
mImpl
;
}
;
}
#
endif
