#
ifndef
xpcom_threads_SpinEventLoopUntil_h__
#
define
xpcom_threads_SpinEventLoopUntil_h__
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
xpcpublic
.
h
"
class
nsIThread
;
namespace
mozilla
{
enum
class
ProcessFailureBehavior
{
IgnoreAndContinue
ReportToCaller
}
;
struct
MOZ_STACK_CLASS
AutoNestedEventLoopAnnotation
{
explicit
AutoNestedEventLoopAnnotation
(
const
nsACString
&
aEntry
)
:
mPrev
(
nullptr
)
{
if
(
NS_IsMainThread
(
)
)
{
StaticMutexAutoLock
lock
(
sStackMutex
)
;
mPrev
=
sCurrent
;
sCurrent
=
this
;
if
(
mPrev
)
{
mStack
=
mPrev
-
>
mStack
+
"
|
"
_ns
+
aEntry
;
}
else
{
mStack
=
aEntry
;
}
AnnotateXPCOMSpinEventLoopStack
(
mStack
)
;
}
}
~
AutoNestedEventLoopAnnotation
(
)
{
if
(
NS_IsMainThread
(
)
)
{
StaticMutexAutoLock
lock
(
sStackMutex
)
;
MOZ_ASSERT
(
sCurrent
=
=
this
)
;
sCurrent
=
mPrev
;
if
(
mPrev
)
{
AnnotateXPCOMSpinEventLoopStack
(
mPrev
-
>
mStack
)
;
}
else
{
AnnotateXPCOMSpinEventLoopStack
(
"
"
_ns
)
;
}
}
}
static
void
CopyCurrentStack
(
nsCString
&
aNestedSpinStack
)
{
StaticMutexAutoLock
lock
(
sStackMutex
)
;
if
(
sCurrent
)
{
aNestedSpinStack
=
sCurrent
-
>
mStack
;
}
else
{
aNestedSpinStack
=
"
(
no
nested
event
loop
active
)
"
_ns
;
}
}
private
:
AutoNestedEventLoopAnnotation
(
const
AutoNestedEventLoopAnnotation
&
)
=
delete
;
AutoNestedEventLoopAnnotation
&
operator
=
(
const
AutoNestedEventLoopAnnotation
&
)
=
delete
;
static
AutoNestedEventLoopAnnotation
*
sCurrent
MOZ_GUARDED_BY
(
sStackMutex
)
;
static
StaticMutex
sStackMutex
;
static
void
AnnotateXPCOMSpinEventLoopStack
(
const
nsACString
&
aStack
)
;
AutoNestedEventLoopAnnotation
*
mPrev
MOZ_GUARDED_BY
(
sStackMutex
)
;
nsCString
mStack
MOZ_GUARDED_BY
(
sStackMutex
)
;
}
;
template
<
ProcessFailureBehavior
Behavior
=
ProcessFailureBehavior
:
:
ReportToCaller
typename
Pred
>
bool
SpinEventLoopUntil
(
const
nsACString
&
aVeryGoodReasonToDoThis
Pred
&
&
aPredicate
nsIThread
*
aThread
=
nullptr
)
{
AutoNestedEventLoopAnnotation
annotation
(
aVeryGoodReasonToDoThis
)
;
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING_NONSENSITIVE
(
"
SpinEventLoopUntil
"
OTHER
aVeryGoodReasonToDoThis
)
;
AUTO_PROFILER_MARKER_TEXT
(
"
SpinEventLoop
"
OTHER
MarkerStack
:
:
Capture
(
)
aVeryGoodReasonToDoThis
)
;
nsIThread
*
thread
=
aThread
?
aThread
:
NS_GetCurrentThread
(
)
;
mozilla
:
:
Maybe
<
xpc
:
:
AutoScriptActivity
>
asa
;
if
(
NS_IsMainThread
(
)
)
{
asa
.
emplace
(
false
)
;
}
while
(
!
aPredicate
(
)
)
{
bool
didSomething
=
NS_ProcessNextEvent
(
thread
true
)
;
if
(
Behavior
=
=
ProcessFailureBehavior
:
:
IgnoreAndContinue
)
{
continue
;
}
else
if
(
!
didSomething
)
{
return
false
;
}
}
return
true
;
}
}
#
endif
