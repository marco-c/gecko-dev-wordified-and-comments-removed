#
ifndef
mozilla_Monitor_h
#
define
mozilla_Monitor_h
#
include
"
mozilla
/
CondVar
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
namespace
mozilla
{
class
MOZ_CAPABILITY
Monitor
{
public
:
explicit
Monitor
(
const
char
*
aName
)
:
mMutex
(
aName
)
mCondVar
(
mMutex
"
[
Monitor
.
mCondVar
]
"
)
{
}
~
Monitor
(
)
=
default
;
void
Lock
(
)
MOZ_CAPABILITY_ACQUIRE
(
)
{
mMutex
.
Lock
(
)
;
}
[
[
nodiscard
]
]
bool
TryLock
(
)
MOZ_TRY_ACQUIRE
(
true
)
{
return
mMutex
.
TryLock
(
)
;
}
void
Unlock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
mMutex
.
Unlock
(
)
;
}
void
Wait
(
)
MOZ_REQUIRES
(
this
)
{
mCondVar
.
Wait
(
)
;
}
CVStatus
Wait
(
TimeDuration
aDuration
)
MOZ_REQUIRES
(
this
)
{
return
mCondVar
.
Wait
(
aDuration
)
;
}
void
Notify
(
)
{
mCondVar
.
Notify
(
)
;
}
void
NotifyAll
(
)
{
mCondVar
.
NotifyAll
(
)
;
}
void
AssertCurrentThreadOwns
(
)
const
MOZ_ASSERT_CAPABILITY
(
this
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
}
void
AssertNotCurrentThreadOwns
(
)
const
MOZ_ASSERT_CAPABILITY
(
!
this
)
{
mMutex
.
AssertNotCurrentThreadOwns
(
)
;
}
private
:
Monitor
(
)
=
delete
;
Monitor
(
const
Monitor
&
)
=
delete
;
Monitor
&
operator
=
(
const
Monitor
&
)
=
delete
;
Mutex
mMutex
;
CondVar
mCondVar
;
}
;
class
MonitorSingleWriter
:
public
Monitor
{
public
:
explicit
MonitorSingleWriter
(
const
char
*
aName
SingleWriterLockOwner
*
aOwner
)
:
Monitor
(
aName
)
#
ifdef
DEBUG
mOwner
(
aOwner
)
#
endif
{
MOZ_COUNT_CTOR
(
MonitorSingleWriter
)
;
MOZ_ASSERT
(
mOwner
)
;
}
MOZ_COUNTED_DTOR
(
MonitorSingleWriter
)
void
AssertOnWritingThread
(
)
const
MOZ_ASSERT_CAPABILITY
(
this
)
{
MOZ_ASSERT
(
mOwner
-
>
OnWritingThread
(
)
)
;
}
void
AssertOnWritingThreadOrHeld
(
)
const
MOZ_ASSERT_CAPABILITY
(
this
)
{
#
ifdef
DEBUG
if
(
!
mOwner
-
>
OnWritingThread
(
)
)
{
AssertCurrentThreadOwns
(
)
;
}
#
endif
}
private
:
#
ifdef
DEBUG
SingleWriterLockOwner
*
mOwner
MOZ_UNSAFE_REF
(
"
This
is
normally
the
object
that
contains
the
MonitorSingleWriter
so
"
"
we
don
'
t
want
to
hold
a
reference
to
ourselves
"
)
;
#
endif
MonitorSingleWriter
(
)
=
delete
;
MonitorSingleWriter
(
const
MonitorSingleWriter
&
)
=
delete
;
MonitorSingleWriter
&
operator
=
(
const
MonitorSingleWriter
&
)
=
delete
;
}
;
namespace
detail
{
template
<
typename
T
>
class
MOZ_SCOPED_CAPABILITY
MOZ_STACK_CLASS
BaseMonitorAutoLock
{
public
:
explicit
BaseMonitorAutoLock
(
T
&
aMonitor
)
MOZ_CAPABILITY_ACQUIRE
(
aMonitor
)
:
mMonitor
(
&
aMonitor
)
{
mMonitor
-
>
Lock
(
)
;
}
~
BaseMonitorAutoLock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
mMonitor
-
>
Unlock
(
)
;
}
void
Wait
(
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
mMonitor
-
>
Wait
(
)
;
}
CVStatus
Wait
(
TimeDuration
aDuration
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
mMonitor
-
>
Wait
(
aDuration
)
;
}
void
Notify
(
)
{
mMonitor
-
>
Notify
(
)
;
}
void
NotifyAll
(
)
{
mMonitor
-
>
NotifyAll
(
)
;
}
void
AssertOwns
(
const
T
&
aMonitor
)
const
MOZ_ASSERT_CAPABILITY
(
aMonitor
)
{
MOZ_ASSERT
(
&
aMonitor
=
=
mMonitor
)
;
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
}
private
:
BaseMonitorAutoLock
(
)
=
delete
;
BaseMonitorAutoLock
(
const
BaseMonitorAutoLock
&
)
=
delete
;
BaseMonitorAutoLock
&
operator
=
(
const
BaseMonitorAutoLock
&
)
=
delete
;
static
void
*
operator
new
(
size_t
)
noexcept
(
true
)
;
friend
class
MonitorAutoUnlock
;
protected
:
T
*
mMonitor
;
}
;
}
typedef
detail
:
:
BaseMonitorAutoLock
<
Monitor
>
MonitorAutoLock
;
typedef
detail
:
:
BaseMonitorAutoLock
<
MonitorSingleWriter
>
MonitorSingleWriterAutoLock
;
#
define
MonitorSingleWriterAutoLockOnThread
(
lock
monitor
)
\
MOZ_PUSH_IGNORE_THREAD_SAFETY
\
MonitorSingleWriterAutoLock
lock
(
monitor
)
;
\
MOZ_POP_THREAD_SAFETY
namespace
detail
{
template
<
typename
T
>
class
MOZ_STACK_CLASS
MOZ_SCOPED_CAPABILITY
BaseMonitorAutoUnlock
{
public
:
explicit
BaseMonitorAutoUnlock
(
T
&
aMonitor
)
MOZ_SCOPED_UNLOCK_RELEASE
(
aMonitor
)
:
mMonitor
(
&
aMonitor
)
{
mMonitor
-
>
Unlock
(
)
;
}
~
BaseMonitorAutoUnlock
(
)
MOZ_SCOPED_UNLOCK_REACQUIRE
(
)
{
mMonitor
-
>
Lock
(
)
;
}
private
:
BaseMonitorAutoUnlock
(
)
=
delete
;
BaseMonitorAutoUnlock
(
const
BaseMonitorAutoUnlock
&
)
=
delete
;
BaseMonitorAutoUnlock
&
operator
=
(
const
BaseMonitorAutoUnlock
&
)
=
delete
;
static
void
*
operator
new
(
size_t
)
noexcept
(
true
)
;
T
*
mMonitor
;
}
;
}
typedef
detail
:
:
BaseMonitorAutoUnlock
<
Monitor
>
MonitorAutoUnlock
;
typedef
detail
:
:
BaseMonitorAutoUnlock
<
MonitorSingleWriter
>
MonitorSingleWriterAutoUnlock
;
class
MOZ_SCOPED_CAPABILITY
MOZ_STACK_CLASS
ReleasableMonitorAutoLock
{
public
:
explicit
ReleasableMonitorAutoLock
(
Monitor
&
aMonitor
)
MOZ_CAPABILITY_ACQUIRE
(
aMonitor
)
:
mMonitor
(
&
aMonitor
)
{
mMonitor
-
>
Lock
(
)
;
mLocked
=
true
;
}
~
ReleasableMonitorAutoLock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
if
(
mLocked
)
{
mMonitor
-
>
Unlock
(
)
;
}
}
void
Wait
(
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
mMonitor
-
>
Wait
(
)
;
}
CVStatus
Wait
(
TimeDuration
aDuration
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
mMonitor
-
>
Wait
(
aDuration
)
;
}
void
Notify
(
)
{
MOZ_ASSERT
(
mLocked
)
;
mMonitor
-
>
Notify
(
)
;
}
void
NotifyAll
(
)
{
MOZ_ASSERT
(
mLocked
)
;
mMonitor
-
>
NotifyAll
(
)
;
}
void
Unlock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
MOZ_ASSERT
(
mLocked
)
;
mMonitor
-
>
Unlock
(
)
;
mLocked
=
false
;
}
void
Lock
(
)
MOZ_CAPABILITY_ACQUIRE
(
)
{
MOZ_ASSERT
(
!
mLocked
)
;
mMonitor
-
>
Lock
(
)
;
mLocked
=
true
;
}
void
AssertCurrentThreadOwns
(
)
const
MOZ_ASSERT_CAPABILITY
(
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
}
private
:
bool
mLocked
;
Monitor
*
mMonitor
;
ReleasableMonitorAutoLock
(
)
=
delete
;
ReleasableMonitorAutoLock
(
const
ReleasableMonitorAutoLock
&
)
=
delete
;
ReleasableMonitorAutoLock
&
operator
=
(
const
ReleasableMonitorAutoLock
&
)
=
delete
;
static
void
*
operator
new
(
size_t
)
noexcept
(
true
)
;
}
;
}
#
endif
