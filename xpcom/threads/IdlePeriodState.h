#
ifndef
mozilla_IdlePeriodState_h
#
define
mozilla_IdlePeriodState_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
<
stdint
.
h
>
class
nsIIdlePeriod
;
namespace
mozilla
{
namespace
ipc
{
class
IdleSchedulerChild
;
}
class
IdlePeriodState
{
public
:
explicit
IdlePeriodState
(
already_AddRefed
<
nsIIdlePeriod
>
&
&
aIdlePeriod
)
;
~
IdlePeriodState
(
)
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
void
FlagNotIdle
(
Mutex
&
aMutexToUnlock
)
;
void
RanOutOfTasks
(
Mutex
&
aMutexToUnlock
)
;
void
EnforcePendingTaskGuarantee
(
)
{
mHasPendingEventsPromisedIdleEvent
=
true
;
}
void
ForgetPendingTaskGuarantee
(
)
{
mHasPendingEventsPromisedIdleEvent
=
false
;
}
TimeStamp
GetDeadlineForIdleTask
(
Mutex
&
aMutexToUnlock
)
{
return
GetIdleDeadlineInternal
(
false
aMutexToUnlock
)
;
}
TimeStamp
PeekIdleDeadline
(
Mutex
&
aMutexToUnlock
)
{
return
GetIdleDeadlineInternal
(
true
aMutexToUnlock
)
;
}
void
SetIdleToken
(
uint64_t
aId
TimeDuration
aDuration
)
;
bool
IsActive
(
)
{
return
mActive
;
}
protected
:
void
EnsureIsActive
(
)
{
if
(
!
mActive
)
{
SetActive
(
)
;
}
}
void
EnsureIsPaused
(
Mutex
&
aMutexToUnlock
)
{
if
(
mActive
)
{
SetPaused
(
aMutexToUnlock
)
;
}
}
TimeStamp
GetLocalIdleDeadline
(
bool
&
aShuttingDown
Mutex
&
aMutexToUnlock
)
;
TimeStamp
GetIdleToken
(
TimeStamp
aLocalIdlePeriodHint
Mutex
&
aMutexToUnlock
)
;
void
RequestIdleToken
(
TimeStamp
aLocalIdlePeriodHint
)
;
void
ClearIdleToken
(
Mutex
&
aMutexToUnlock
)
;
void
SetActive
(
)
;
void
SetPaused
(
Mutex
&
aMutexToUnlock
)
;
TimeStamp
GetIdleDeadlineInternal
(
bool
aIsPeek
Mutex
&
aMutexToUnlock
)
;
bool
mHasPendingEventsPromisedIdleEvent
=
false
;
nsCOMPtr
<
nsIIdlePeriod
>
mIdlePeriod
;
TimeStamp
mIdleToken
;
uint64_t
mIdleRequestId
=
0
;
RefPtr
<
ipc
:
:
IdleSchedulerChild
>
mIdleScheduler
;
bool
mIdleSchedulerInitialized
=
false
;
bool
mActive
=
true
;
}
;
}
#
endif
