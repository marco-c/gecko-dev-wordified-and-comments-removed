#
include
"
ThreadStackHelper
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
jsfriendapi
.
h
"
#
ifdef
MOZ_THREADSTACKHELPER_NATIVE
#
include
"
shared
-
libraries
.
h
"
#
endif
#
ifdef
MOZ_THREADSTACKHELPER_PSEUDO
#
include
"
js
/
ProfilingStack
.
h
"
#
endif
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Scoped
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wshadow
"
#
endif
#
if
defined
(
MOZ_VALGRIND
)
#
include
<
valgrind
/
valgrind
.
h
>
#
endif
#
include
<
string
.
h
>
#
include
<
vector
>
#
include
<
cstdlib
>
#
ifdef
XP_LINUX
#
include
<
ucontext
.
h
>
#
include
<
unistd
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
endif
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
pop
/
/
-
Wshadow
#
endif
#
if
defined
(
XP_LINUX
)
|
|
defined
(
XP_MACOSX
)
#
include
<
pthread
.
h
>
#
endif
#
ifdef
ANDROID
#
ifndef
SYS_gettid
#
define
SYS_gettid
__NR_gettid
#
endif
#
if
defined
(
__arm__
)
&
&
!
defined
(
__NR_rt_tgsigqueueinfo
)
#
define
__NR_rt_tgsigqueueinfo
(
__NR_SYSCALL_BASE
+
363
)
#
endif
#
ifndef
SYS_rt_tgsigqueueinfo
#
define
SYS_rt_tgsigqueueinfo
__NR_rt_tgsigqueueinfo
#
endif
#
endif
#
ifdef
MOZ_THREADSTACKHELPER_NATIVE
#
if
defined
(
MOZ_THREADSTACKHELPER_X86
)
|
|
\
defined
(
MOZ_THREADSTACKHELPER_X64
)
#
define
MOZ_THREADSTACKHELPER_STACK_GROWS_DOWN
#
else
#
error
"
Unsupported
architecture
"
#
endif
#
endif
namespace
mozilla
{
void
ThreadStackHelper
:
:
Startup
(
)
{
#
if
defined
(
XP_LINUX
)
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sInitialized
)
{
sFillStackSignum
=
SIGRTMIN
+
4
;
if
(
sFillStackSignum
>
SIGRTMAX
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
struct
sigaction
sigact
=
{
}
;
sigact
.
sa_sigaction
=
FillStackHandler
;
sigemptyset
(
&
sigact
.
sa_mask
)
;
sigact
.
sa_flags
=
SA_SIGINFO
|
SA_RESTART
;
MOZ_ALWAYS_TRUE
(
!
:
:
sigaction
(
sFillStackSignum
&
sigact
nullptr
)
)
;
}
sInitialized
+
+
;
#
endif
}
void
ThreadStackHelper
:
:
Shutdown
(
)
{
#
if
defined
(
XP_LINUX
)
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
sInitialized
=
=
1
)
{
struct
sigaction
sigact
=
{
}
;
sigact
.
sa_handler
=
SIG_DFL
;
MOZ_ALWAYS_TRUE
(
!
:
:
sigaction
(
sFillStackSignum
&
sigact
nullptr
)
)
;
}
sInitialized
-
-
;
#
endif
}
ThreadStackHelper
:
:
ThreadStackHelper
(
)
:
mStackToFill
(
nullptr
)
#
ifdef
MOZ_THREADSTACKHELPER_PSEUDO
mPseudoStack
(
profiler_get_pseudo_stack
(
)
)
mMaxStackSize
(
Stack
:
:
sMaxInlineStorage
)
mMaxBufferSize
(
512
)
#
endif
{
#
if
defined
(
XP_LINUX
)
MOZ_ALWAYS_TRUE
(
!
:
:
sem_init
(
&
mSem
0
0
)
)
;
mThreadID
=
:
:
syscall
(
SYS_gettid
)
;
#
elif
defined
(
XP_WIN
)
mInitialized
=
!
!
:
:
DuplicateHandle
(
:
:
GetCurrentProcess
(
)
:
:
GetCurrentThread
(
)
:
:
GetCurrentProcess
(
)
&
mThreadID
THREAD_SUSPEND_RESUME
#
ifdef
MOZ_THREADSTACKHELPER_NATIVE
|
THREAD_GET_CONTEXT
|
THREAD_QUERY_INFORMATION
#
endif
FALSE
0
)
;
mStackTop
=
profiler_get_stack_top
(
)
;
MOZ_ASSERT
(
mInitialized
)
;
#
elif
defined
(
XP_MACOSX
)
mThreadID
=
mach_thread_self
(
)
;
#
endif
}
ThreadStackHelper
:
:
~
ThreadStackHelper
(
)
{
#
if
defined
(
XP_LINUX
)
MOZ_ALWAYS_TRUE
(
!
:
:
sem_destroy
(
&
mSem
)
)
;
#
elif
defined
(
XP_WIN
)
if
(
mInitialized
)
{
MOZ_ALWAYS_TRUE
(
!
!
:
:
CloseHandle
(
mThreadID
)
)
;
}
#
endif
}
namespace
{
template
<
typename
T
>
class
ScopedSetPtr
{
private
:
T
*
&
mPtr
;
public
:
ScopedSetPtr
(
T
*
&
p
T
*
val
)
:
mPtr
(
p
)
{
mPtr
=
val
;
}
~
ScopedSetPtr
(
)
{
mPtr
=
nullptr
;
}
}
;
}
void
ThreadStackHelper
:
:
GetPseudoStack
(
Stack
&
aStack
)
{
GetStacksInternal
(
&
aStack
nullptr
)
;
}
void
ThreadStackHelper
:
:
GetStacksInternal
(
Stack
*
aStack
NativeStack
*
aNativeStack
)
{
if
(
aStack
&
&
!
PrepareStackBuffer
(
*
aStack
)
)
{
return
;
}
ScopedSetPtr
<
Stack
>
stackPtr
(
mStackToFill
aStack
)
;
#
if
defined
(
XP_LINUX
)
if
(
!
sInitialized
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
if
(
aStack
)
{
siginfo_t
uinfo
=
{
}
;
uinfo
.
si_signo
=
sFillStackSignum
;
uinfo
.
si_code
=
SI_QUEUE
;
uinfo
.
si_pid
=
getpid
(
)
;
uinfo
.
si_uid
=
getuid
(
)
;
uinfo
.
si_value
.
sival_ptr
=
this
;
if
(
:
:
syscall
(
SYS_rt_tgsigqueueinfo
uinfo
.
si_pid
mThreadID
sFillStackSignum
&
uinfo
)
)
{
return
;
}
MOZ_ALWAYS_TRUE
(
!
:
:
sem_wait
(
&
mSem
)
)
;
}
#
elif
defined
(
XP_WIN
)
if
(
!
mInitialized
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
#
ifndef
MOZ_THREADSTACKHELPER_X64
if
(
aNativeStack
)
{
aNativeStack
-
>
reserve
(
Telemetry
:
:
HangStack
:
:
sMaxNativeFrames
)
;
}
#
endif
if
(
:
:
SuspendThread
(
mThreadID
)
=
=
DWORD
(
-
1
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
CONTEXT
context
;
memset
(
&
context
0
sizeof
(
context
)
)
;
context
.
ContextFlags
=
CONTEXT_CONTROL
;
if
(
:
:
GetThreadContext
(
mThreadID
&
context
)
)
{
if
(
aStack
)
{
FillStackBuffer
(
)
;
}
#
ifndef
MOZ_THREADSTACKHELPER_X64
if
(
aNativeStack
)
{
auto
callback
=
[
]
(
uint32_t
void
*
aPC
void
*
void
*
aClosure
)
{
NativeStack
*
stack
=
static_cast
<
NativeStack
*
>
(
aClosure
)
;
stack
-
>
push_back
(
reinterpret_cast
<
uintptr_t
>
(
aPC
)
)
;
}
;
void
*
*
framePointer
=
reinterpret_cast
<
void
*
*
>
(
context
.
Ebp
)
;
void
*
*
stackPointer
=
reinterpret_cast
<
void
*
*
>
(
context
.
Esp
)
;
MOZ_ASSERT
(
mStackTop
"
The
thread
should
be
registered
by
the
profiler
"
)
;
if
(
mStackTop
&
&
framePointer
>
=
stackPointer
&
&
framePointer
<
mStackTop
)
{
FramePointerStackWalk
(
callback
0
Telemetry
:
:
HangStack
:
:
sMaxNativeFrames
reinterpret_cast
<
void
*
>
(
aNativeStack
)
framePointer
mStackTop
)
;
}
}
#
endif
}
MOZ_ALWAYS_TRUE
(
:
:
ResumeThread
(
mThreadID
)
!
=
DWORD
(
-
1
)
)
;
#
elif
defined
(
XP_MACOSX
)
#
if
defined
(
MOZ_VALGRIND
)
&
&
defined
(
RUNNING_ON_VALGRIND
)
if
(
RUNNING_ON_VALGRIND
)
{
return
;
}
#
endif
if
(
aStack
)
{
if
(
:
:
thread_suspend
(
mThreadID
)
!
=
KERN_SUCCESS
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
FillStackBuffer
(
)
;
MOZ_ALWAYS_TRUE
(
:
:
thread_resume
(
mThreadID
)
=
=
KERN_SUCCESS
)
;
}
#
endif
}
void
ThreadStackHelper
:
:
GetNativeStack
(
NativeStack
&
aNativeStack
)
{
#
ifdef
MOZ_THREADSTACKHELPER_NATIVE
GetStacksInternal
(
nullptr
&
aNativeStack
)
;
#
endif
}
void
ThreadStackHelper
:
:
GetPseudoAndNativeStack
(
Stack
&
aStack
NativeStack
&
aNativeStack
)
{
GetStacksInternal
(
&
aStack
&
aNativeStack
)
;
}
#
ifdef
XP_LINUX
int
ThreadStackHelper
:
:
sInitialized
;
int
ThreadStackHelper
:
:
sFillStackSignum
;
void
ThreadStackHelper
:
:
FillStackHandler
(
int
aSignal
siginfo_t
*
aInfo
void
*
aContext
)
{
ThreadStackHelper
*
const
helper
=
reinterpret_cast
<
ThreadStackHelper
*
>
(
aInfo
-
>
si_value
.
sival_ptr
)
;
helper
-
>
FillStackBuffer
(
)
;
:
:
sem_post
(
&
helper
-
>
mSem
)
;
}
#
endif
bool
ThreadStackHelper
:
:
PrepareStackBuffer
(
Stack
&
aStack
)
{
aStack
.
clear
(
)
;
#
ifdef
MOZ_THREADSTACKHELPER_PSEUDO
#
ifdef
MOZ_WIDGET_GONK
if
(
!
mPseudoStack
)
{
return
false
;
}
#
endif
MOZ_ASSERT
(
mPseudoStack
)
;
if
(
!
aStack
.
reserve
(
mMaxStackSize
)
|
|
!
aStack
.
reserve
(
aStack
.
capacity
(
)
)
|
|
!
aStack
.
EnsureBufferCapacity
(
mMaxBufferSize
)
)
{
return
false
;
}
return
true
;
#
else
return
false
;
#
endif
}
#
ifdef
MOZ_THREADSTACKHELPER_PSEUDO
namespace
{
bool
IsChromeJSScript
(
JSScript
*
aScript
)
{
nsIScriptSecurityManager
*
const
secman
=
nsScriptSecurityManager
:
:
GetScriptSecurityManager
(
)
;
NS_ENSURE_TRUE
(
secman
false
)
;
JSPrincipals
*
const
principals
=
JS_GetScriptPrincipals
(
aScript
)
;
return
secman
-
>
IsSystemPrincipal
(
nsJSPrincipals
:
:
get
(
principals
)
)
;
}
template
<
size_t
LEN
>
const
char
*
GetFullPathForScheme
(
const
char
*
filename
const
char
(
&
scheme
)
[
LEN
]
)
{
if
(
!
strncmp
(
filename
scheme
LEN
-
1
)
)
{
return
filename
+
LEN
-
1
;
}
return
nullptr
;
}
template
<
size_t
LEN
>
const
char
*
GetPathAfterComponent
(
const
char
*
filename
const
char
(
&
component
)
[
LEN
]
)
{
const
char
*
found
=
nullptr
;
const
char
*
next
=
strstr
(
filename
component
)
;
while
(
next
)
{
found
=
next
+
LEN
-
1
;
next
=
strstr
(
found
-
1
component
)
;
}
return
found
;
}
}
const
char
*
ThreadStackHelper
:
:
AppendJSEntry
(
const
volatile
js
:
:
ProfileEntry
*
aEntry
intptr_t
&
aAvailableBufferSize
const
char
*
aPrevLabel
)
{
MOZ_ASSERT
(
aEntry
-
>
isJs
(
)
)
;
const
char
*
label
;
JSScript
*
script
=
aEntry
-
>
script
(
)
;
if
(
!
script
)
{
label
=
"
(
profiling
suppressed
)
"
;
}
else
if
(
IsChromeJSScript
(
aEntry
-
>
script
(
)
)
)
{
const
char
*
filename
=
JS_GetScriptFilename
(
aEntry
-
>
script
(
)
)
;
const
unsigned
lineno
=
JS_PCToLineNumber
(
aEntry
-
>
script
(
)
aEntry
-
>
pc
(
)
)
;
MOZ_ASSERT
(
filename
)
;
char
buffer
[
128
]
;
const
char
*
basename
=
GetPathAfterComponent
(
filename
"
-
>
"
)
;
if
(
basename
)
{
filename
=
basename
;
}
basename
=
GetFullPathForScheme
(
filename
"
chrome
:
/
/
"
)
;
if
(
!
basename
)
{
basename
=
GetFullPathForScheme
(
filename
"
resource
:
/
/
"
)
;
}
if
(
!
basename
)
{
basename
=
GetPathAfterComponent
(
filename
"
/
extensions
/
"
)
;
}
if
(
!
basename
)
{
basename
=
strrchr
(
filename
'
/
'
)
;
basename
=
basename
?
basename
+
1
:
filename
;
filename
=
strrchr
(
basename
'
\
\
'
)
;
if
(
filename
)
{
basename
=
filename
+
1
;
}
}
size_t
len
=
SprintfLiteral
(
buffer
"
%
s
:
%
u
"
basename
lineno
)
;
if
(
len
<
sizeof
(
buffer
)
)
{
if
(
mStackToFill
-
>
IsSameAsEntry
(
aPrevLabel
buffer
)
)
{
return
aPrevLabel
;
}
aAvailableBufferSize
-
=
(
len
+
1
)
;
if
(
aAvailableBufferSize
>
=
0
)
{
return
mStackToFill
-
>
InfallibleAppendViaBuffer
(
buffer
len
)
;
}
}
label
=
"
(
chrome
script
)
"
;
}
else
{
label
=
"
(
content
script
)
"
;
}
if
(
mStackToFill
-
>
IsSameAsEntry
(
aPrevLabel
label
)
)
{
return
aPrevLabel
;
}
mStackToFill
-
>
infallibleAppend
(
label
)
;
return
label
;
}
#
endif
void
ThreadStackHelper
:
:
FillStackBuffer
(
)
{
MOZ_ASSERT
(
mStackToFill
-
>
empty
(
)
)
;
#
ifdef
MOZ_THREADSTACKHELPER_PSEUDO
size_t
reservedSize
=
mStackToFill
-
>
capacity
(
)
;
size_t
reservedBufferSize
=
mStackToFill
-
>
AvailableBufferSize
(
)
;
intptr_t
availableBufferSize
=
intptr_t
(
reservedBufferSize
)
;
const
volatile
js
:
:
ProfileEntry
*
entry
=
mPseudoStack
-
>
entries
;
const
volatile
js
:
:
ProfileEntry
*
end
=
entry
+
mPseudoStack
-
>
stackSize
(
)
;
const
char
*
prevLabel
=
nullptr
;
for
(
;
reservedSize
-
-
&
&
entry
!
=
end
;
entry
+
+
)
{
if
(
entry
-
>
isJs
(
)
)
{
prevLabel
=
AppendJSEntry
(
entry
availableBufferSize
prevLabel
)
;
continue
;
}
const
char
*
const
label
=
entry
-
>
label
(
)
;
if
(
mStackToFill
-
>
IsSameAsEntry
(
prevLabel
label
)
)
{
continue
;
}
mStackToFill
-
>
infallibleAppend
(
label
)
;
prevLabel
=
label
;
}
mMaxStackSize
=
mStackToFill
-
>
capacity
(
)
+
(
end
-
entry
)
;
if
(
availableBufferSize
<
0
)
{
mMaxBufferSize
=
reservedBufferSize
-
availableBufferSize
;
}
#
endif
}
}
