#
include
"
nsThread
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
platform_thread
.
h
"
#
ifdef
LOG
#
undef
LOG
#
endif
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
nsMemoryPressure
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsIClassInfoImpl
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
pratom
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
IOInterposer
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
mozilla
/
ChaosMode
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsThreadSyncDispatch
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
ProfilerMarkerPayload
.
h
"
#
endif
#
include
"
InputEventStatistics
.
h
"
#
include
"
ThreadEventTarget
.
h
"
#
include
"
ThreadDelay
.
h
"
#
ifdef
XP_LINUX
#
ifdef
__GLIBC__
#
include
<
gnu
/
libc
-
version
.
h
>
#
endif
#
include
<
sys
/
mman
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
resource
.
h
>
#
include
<
sched
.
h
>
#
include
<
stdio
.
h
>
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
DynamicallyLinkedFunctionPtr
.
h
"
#
include
<
winbase
.
h
>
using
GetCurrentThreadStackLimitsFn
=
void
(
WINAPI
*
)
(
PULONG_PTR
LowLimit
PULONG_PTR
HighLimit
)
;
#
endif
#
define
HAVE_UALARM
\
_BSD_SOURCE
|
|
\
(
_XOPEN_SOURCE
>
=
500
|
|
_XOPEN_SOURCE
&
&
_XOPEN_SOURCE_EXTENDED
)
&
&
\
!
(
_POSIX_C_SOURCE
>
=
200809L
|
|
_XOPEN_SOURCE
>
=
700
)
#
if
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
&
&
defined
(
_GNU_SOURCE
)
#
define
HAVE_SCHED_SETAFFINITY
#
endif
#
ifdef
XP_MACOSX
#
include
<
mach
/
mach
.
h
>
#
include
<
mach
/
thread_policy
.
h
>
#
endif
#
ifdef
MOZ_CANARY
#
include
<
unistd
.
h
>
#
include
<
execinfo
.
h
>
#
include
<
signal
.
h
>
#
include
<
fcntl
.
h
>
#
include
"
nsXULAppAPI
.
h
"
#
endif
#
if
defined
(
NS_FUNCTION_TIMER
)
&
&
defined
(
_MSC_VER
)
#
include
"
nsTimerImpl
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
endif
#
ifdef
NS_FUNCTION_TIMER
#
include
"
nsCRT
.
h
"
#
endif
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
include
"
TracedTaskCommon
.
h
"
using
namespace
mozilla
:
:
tasktracer
;
#
endif
using
namespace
mozilla
;
static
LazyLogModule
sThreadLog
(
"
nsThread
"
)
;
#
ifdef
LOG
#
undef
LOG
#
endif
#
define
LOG
(
args
)
MOZ_LOG
(
sThreadLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
NS_DECL_CI_INTERFACE_GETTER
(
nsThread
)
Array
<
char
nsThread
:
:
kRunnableNameBufSize
>
nsThread
:
:
sMainThreadRunnableName
;
uint32_t
nsThread
:
:
sActiveThreads
;
uint32_t
nsThread
:
:
sMaxActiveThreads
;
class
nsThreadClassInfo
:
public
nsIClassInfo
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSICLASSINFO
nsThreadClassInfo
(
)
{
}
}
;
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsThreadClassInfo
:
:
AddRef
(
)
{
return
2
;
}
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsThreadClassInfo
:
:
Release
(
)
{
return
1
;
}
NS_IMPL_QUERY_INTERFACE
(
nsThreadClassInfo
nsIClassInfo
)
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetInterfaces
(
uint32_t
*
aCount
nsIID
*
*
*
aArray
)
{
return
NS_CI_INTERFACE_GETTER_NAME
(
nsThread
)
(
aCount
aArray
)
;
}
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetScriptableHelper
(
nsIXPCScriptable
*
*
aResult
)
{
*
aResult
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetContractID
(
nsACString
&
aResult
)
{
aResult
.
SetIsVoid
(
true
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetClassDescription
(
nsACString
&
aResult
)
{
aResult
.
SetIsVoid
(
true
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetClassID
(
nsCID
*
*
aResult
)
{
*
aResult
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetFlags
(
uint32_t
*
aResult
)
{
*
aResult
=
THREADSAFE
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetClassIDNoAlloc
(
nsCID
*
aResult
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMPL_ADDREF
(
nsThread
)
NS_IMPL_RELEASE
(
nsThread
)
NS_INTERFACE_MAP_BEGIN
(
nsThread
)
NS_INTERFACE_MAP_ENTRY
(
nsIThread
)
NS_INTERFACE_MAP_ENTRY
(
nsIThreadInternal
)
NS_INTERFACE_MAP_ENTRY
(
nsIEventTarget
)
NS_INTERFACE_MAP_ENTRY
(
nsISerialEventTarget
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsPriority
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIThread
)
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIClassInfo
)
)
)
{
static
nsThreadClassInfo
sThreadClassInfo
;
foundInterface
=
static_cast
<
nsIClassInfo
*
>
(
&
sThreadClassInfo
)
;
}
else
NS_INTERFACE_MAP_END
NS_IMPL_CI_INTERFACE_GETTER
(
nsThread
nsIThread
nsIThreadInternal
nsIEventTarget
nsISupportsPriority
)
class
nsThreadStartupEvent
final
:
public
Runnable
{
public
:
nsThreadStartupEvent
(
)
:
Runnable
(
"
nsThreadStartupEvent
"
)
mMon
(
"
nsThreadStartupEvent
.
mMon
"
)
mInitialized
(
false
)
{
}
void
Wait
(
)
{
ReentrantMonitorAutoEnter
mon
(
mMon
)
;
while
(
!
mInitialized
)
{
mon
.
Wait
(
)
;
}
}
private
:
~
nsThreadStartupEvent
(
)
=
default
;
NS_IMETHOD
Run
(
)
override
{
ReentrantMonitorAutoEnter
mon
(
mMon
)
;
mInitialized
=
true
;
mon
.
Notify
(
)
;
return
NS_OK
;
}
ReentrantMonitor
mMon
;
bool
mInitialized
;
}
;
struct
nsThreadShutdownContext
{
nsThreadShutdownContext
(
NotNull
<
nsThread
*
>
aTerminatingThread
NotNull
<
nsThread
*
>
aJoiningThread
bool
aAwaitingShutdownAck
)
:
mTerminatingThread
(
aTerminatingThread
)
mJoiningThread
(
aJoiningThread
)
mAwaitingShutdownAck
(
aAwaitingShutdownAck
)
mIsMainThreadJoining
(
NS_IsMainThread
(
)
)
{
MOZ_COUNT_CTOR
(
nsThreadShutdownContext
)
;
}
~
nsThreadShutdownContext
(
)
{
MOZ_COUNT_DTOR
(
nsThreadShutdownContext
)
;
}
NotNull
<
RefPtr
<
nsThread
>
>
mTerminatingThread
;
NotNull
<
nsThread
*
>
MOZ_UNSAFE_REF
(
"
Thread
manager
is
holding
reference
to
joining
thread
"
)
mJoiningThread
;
bool
mAwaitingShutdownAck
;
bool
mIsMainThreadJoining
;
}
;
class
nsThreadShutdownAckEvent
:
public
CancelableRunnable
{
public
:
explicit
nsThreadShutdownAckEvent
(
NotNull
<
nsThreadShutdownContext
*
>
aCtx
)
:
CancelableRunnable
(
"
nsThreadShutdownAckEvent
"
)
mShutdownContext
(
aCtx
)
{
}
NS_IMETHOD
Run
(
)
override
{
mShutdownContext
-
>
mTerminatingThread
-
>
ShutdownComplete
(
mShutdownContext
)
;
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
return
Run
(
)
;
}
private
:
virtual
~
nsThreadShutdownAckEvent
(
)
{
}
NotNull
<
nsThreadShutdownContext
*
>
mShutdownContext
;
}
;
class
nsThreadShutdownEvent
:
public
Runnable
{
public
:
nsThreadShutdownEvent
(
NotNull
<
nsThread
*
>
aThr
NotNull
<
nsThreadShutdownContext
*
>
aCtx
)
:
Runnable
(
"
nsThreadShutdownEvent
"
)
mThread
(
aThr
)
mShutdownContext
(
aCtx
)
{
}
NS_IMETHOD
Run
(
)
override
{
mThread
-
>
mShutdownContext
=
mShutdownContext
;
MessageLoop
:
:
current
(
)
-
>
Quit
(
)
;
return
NS_OK
;
}
private
:
NotNull
<
RefPtr
<
nsThread
>
>
mThread
;
NotNull
<
nsThreadShutdownContext
*
>
mShutdownContext
;
}
;
static
void
SetThreadAffinity
(
unsigned
int
cpu
)
{
#
ifdef
HAVE_SCHED_SETAFFINITY
cpu_set_t
cpus
;
CPU_ZERO
(
&
cpus
)
;
CPU_SET
(
cpu
&
cpus
)
;
sched_setaffinity
(
0
sizeof
(
cpus
)
&
cpus
)
;
#
elif
defined
(
XP_MACOSX
)
thread_affinity_policy_data_t
policy
;
policy
.
affinity_tag
=
cpu
+
1
;
MOZ_ALWAYS_TRUE
(
thread_policy_set
(
mach_thread_self
(
)
THREAD_AFFINITY_POLICY
&
policy
.
affinity_tag
1
)
=
=
KERN_SUCCESS
)
;
#
elif
defined
(
XP_WIN
)
MOZ_ALWAYS_TRUE
(
SetThreadIdealProcessor
(
GetCurrentThread
(
)
cpu
)
!
=
(
DWORD
)
-
1
)
;
#
endif
}
static
void
SetupCurrentThreadForChaosMode
(
)
{
if
(
!
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
ThreadScheduling
)
)
{
return
;
}
#
ifdef
XP_LINUX
setpriority
(
PRIO_PROCESS
0
ChaosMode
:
:
randomUint32LessThan
(
4
)
)
;
#
else
uint32_t
priority
=
ChaosMode
:
:
randomUint32LessThan
(
PR_PRIORITY_LAST
+
1
)
;
PR_SetThreadPriority
(
PR_GetCurrentThread
(
)
PRThreadPriority
(
priority
)
)
;
#
endif
if
(
ChaosMode
:
:
randomUint32LessThan
(
2
)
)
{
SetThreadAffinity
(
0
)
;
}
}
namespace
{
struct
ThreadInitData
{
nsThread
*
thread
;
const
nsACString
&
name
;
}
;
}
mozilla
:
:
OffTheBooksMutex
&
nsThread
:
:
ThreadListMutex
(
)
{
static
OffTheBooksMutex
sMutex
(
"
nsThread
:
:
ThreadListMutex
"
)
;
return
sMutex
;
}
LinkedList
<
nsThread
>
&
nsThread
:
:
ThreadList
(
)
{
static
LinkedList
<
nsThread
>
sList
;
return
sList
;
}
void
nsThread
:
:
ClearThreadList
(
)
{
OffTheBooksMutexAutoLock
mal
(
ThreadListMutex
(
)
)
;
while
(
ThreadList
(
)
.
popFirst
(
)
)
{
}
}
nsThreadEnumerator
nsThread
:
:
Enumerate
(
)
{
return
{
}
;
}
uint32_t
nsThread
:
:
MaxActiveThreads
(
)
{
OffTheBooksMutexAutoLock
mal
(
ThreadListMutex
(
)
)
;
return
sMaxActiveThreads
;
}
void
nsThread
:
:
AddToThreadList
(
)
{
OffTheBooksMutexAutoLock
mal
(
ThreadListMutex
(
)
)
;
MOZ_ASSERT
(
!
isInList
(
)
)
;
sActiveThreads
+
+
;
sMaxActiveThreads
=
std
:
:
max
(
sActiveThreads
sMaxActiveThreads
)
;
ThreadList
(
)
.
insertBack
(
this
)
;
}
void
nsThread
:
:
MaybeRemoveFromThreadList
(
)
{
OffTheBooksMutexAutoLock
mal
(
ThreadListMutex
(
)
)
;
if
(
isInList
(
)
)
{
sActiveThreads
-
-
;
removeFrom
(
ThreadList
(
)
)
;
}
}
void
nsThread
:
:
ThreadFunc
(
void
*
aArg
)
{
using
mozilla
:
:
ipc
:
:
BackgroundChild
;
ThreadInitData
*
initData
=
static_cast
<
ThreadInitData
*
>
(
aArg
)
;
nsThread
*
self
=
initData
-
>
thread
;
MOZ_ASSERT
(
self
-
>
mEventTarget
)
;
MOZ_ASSERT
(
self
-
>
mEvents
)
;
self
-
>
mThread
=
PR_GetCurrentThread
(
)
;
self
-
>
mVirtualThread
=
GetCurrentVirtualThread
(
)
;
self
-
>
mEventTarget
-
>
SetCurrentThread
(
)
;
SetupCurrentThreadForChaosMode
(
)
;
if
(
!
initData
-
>
name
.
IsEmpty
(
)
)
{
NS_SetCurrentThreadName
(
initData
-
>
name
.
BeginReading
(
)
)
;
}
self
-
>
InitCommon
(
)
;
nsThreadManager
:
:
get
(
)
.
RegisterCurrentThread
(
*
self
)
;
mozilla
:
:
IOInterposer
:
:
RegisterCurrentThread
(
)
;
if
(
!
initData
-
>
name
.
IsEmpty
(
)
)
{
PROFILER_REGISTER_THREAD
(
initData
-
>
name
.
BeginReading
(
)
)
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
self
-
>
mEvents
-
>
GetEvent
(
true
nullptr
)
;
MOZ_ASSERT
(
event
)
;
initData
=
nullptr
;
event
-
>
Run
(
)
;
event
=
nullptr
;
{
nsAutoPtr
<
MessageLoop
>
loop
(
new
MessageLoop
(
MessageLoop
:
:
TYPE_MOZILLA_NONMAINTHREAD
self
)
)
;
loop
-
>
Run
(
)
;
BackgroundChild
:
:
CloseForCurrentThread
(
)
;
while
(
true
)
{
self
-
>
WaitForAllAsynchronousShutdowns
(
)
;
if
(
self
-
>
mEvents
-
>
ShutdownIfNoPendingEvents
(
)
)
{
break
;
}
NS_ProcessPendingEvents
(
self
)
;
}
}
mozilla
:
:
IOInterposer
:
:
UnregisterCurrentThread
(
)
;
nsThreadManager
:
:
get
(
)
.
UnregisterCurrentThread
(
*
self
)
;
PROFILER_UNREGISTER_THREAD
(
)
;
NotNull
<
nsThreadShutdownContext
*
>
context
=
WrapNotNull
(
self
-
>
mShutdownContext
)
;
MOZ_ASSERT
(
context
-
>
mTerminatingThread
=
=
self
)
;
event
=
do_QueryObject
(
new
nsThreadShutdownAckEvent
(
context
)
)
;
if
(
context
-
>
mIsMainThreadJoining
)
{
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
}
else
{
context
-
>
mJoiningThread
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
self
-
>
SetObserver
(
nullptr
)
;
#
ifdef
MOZ_TASK_TRACER
FreeTraceInfo
(
)
;
#
endif
NS_RELEASE
(
self
)
;
}
void
nsThread
:
:
InitCommon
(
)
{
mThreadId
=
uint32_t
(
PlatformThread
:
:
CurrentId
(
)
)
;
{
#
if
defined
(
XP_LINUX
)
pthread_attr_t
attr
;
pthread_attr_init
(
&
attr
)
;
pthread_getattr_np
(
pthread_self
(
)
&
attr
)
;
size_t
stackSize
;
pthread_attr_getstack
(
&
attr
&
mStackBase
&
stackSize
)
;
static
bool
sAdjustForGuardSize
=
(
{
#
ifdef
__GLIBC__
unsigned
major
minor
;
sscanf
(
gnu_get_libc_version
(
)
"
%
u
.
%
u
"
&
major
&
minor
)
<
2
|
|
major
<
2
|
|
(
major
=
=
2
&
&
minor
<
27
)
;
#
else
false
;
#
endif
}
)
;
if
(
sAdjustForGuardSize
)
{
size_t
guardSize
;
pthread_attr_getguardsize
(
&
attr
&
guardSize
)
;
mStackBase
=
reinterpret_cast
<
char
*
>
(
mStackBase
)
+
guardSize
;
stackSize
-
=
guardSize
;
}
mStackSize
=
stackSize
;
madvise
(
mStackBase
stackSize
MADV_NOHUGEPAGE
)
;
pthread_attr_destroy
(
&
attr
)
;
#
elif
defined
(
XP_WIN
)
static
const
DynamicallyLinkedFunctionPtr
<
GetCurrentThreadStackLimitsFn
>
sGetStackLimits
(
L
"
kernel32
.
dll
"
"
GetCurrentThreadStackLimits
"
)
;
if
(
sGetStackLimits
)
{
ULONG_PTR
stackBottom
stackTop
;
sGetStackLimits
(
&
stackBottom
&
stackTop
)
;
mStackBase
=
reinterpret_cast
<
void
*
>
(
stackBottom
)
;
mStackSize
=
stackTop
-
stackBottom
;
}
#
endif
}
AddToThreadList
(
)
;
}
#
ifdef
MOZ_CANARY
int
sCanaryOutputFD
=
-
1
;
#
endif
nsThread
:
:
nsThread
(
NotNull
<
SynchronizedEventQueue
*
>
aQueue
MainThreadFlag
aMainThread
uint32_t
aStackSize
)
:
mEvents
(
aQueue
.
get
(
)
)
mEventTarget
(
new
ThreadEventTarget
(
mEvents
.
get
(
)
aMainThread
=
=
MAIN_THREAD
)
)
mShutdownContext
(
nullptr
)
mScriptObserver
(
nullptr
)
mThread
(
nullptr
)
mStackSize
(
aStackSize
)
mNestedEventLoopDepth
(
0
)
mCurrentEventLoopDepth
(
-
1
)
mShutdownRequired
(
false
)
mPriority
(
PRIORITY_NORMAL
)
mIsMainThread
(
uint8_t
(
aMainThread
)
)
mCanInvokeJS
(
false
)
mCurrentEvent
(
nullptr
)
mCurrentEventStart
(
TimeStamp
:
:
Now
(
)
)
mCurrentPerformanceCounter
(
nullptr
)
{
mLastLongTaskEnd
=
mCurrentEventStart
;
mLastLongNonIdleTaskEnd
=
mCurrentEventStart
;
}
nsThread
:
:
nsThread
(
)
:
mEvents
(
nullptr
)
mEventTarget
(
nullptr
)
mShutdownContext
(
nullptr
)
mScriptObserver
(
nullptr
)
mThread
(
nullptr
)
mStackSize
(
0
)
mNestedEventLoopDepth
(
0
)
mCurrentEventLoopDepth
(
-
1
)
mShutdownRequired
(
false
)
mPriority
(
PRIORITY_NORMAL
)
mIsMainThread
(
NOT_MAIN_THREAD
)
mCanInvokeJS
(
false
)
mCurrentEvent
(
nullptr
)
mCurrentEventStart
(
TimeStamp
:
:
Now
(
)
)
mCurrentPerformanceCounter
(
nullptr
)
{
mLastLongTaskEnd
=
mCurrentEventStart
;
mLastLongNonIdleTaskEnd
=
mCurrentEventStart
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
}
nsThread
:
:
~
nsThread
(
)
{
NS_ASSERTION
(
mRequestedShutdownContexts
.
IsEmpty
(
)
"
shouldn
'
t
be
waiting
on
other
threads
to
shutdown
"
)
;
MaybeRemoveFromThreadList
(
)
;
#
ifdef
DEBUG
for
(
size_t
i
=
0
;
i
<
mRequestedShutdownContexts
.
Length
(
)
;
+
+
i
)
{
Unused
<
<
mRequestedShutdownContexts
[
i
]
.
forget
(
)
;
}
#
endif
}
nsresult
nsThread
:
:
Init
(
const
nsACString
&
aName
)
{
MOZ_ASSERT
(
mEvents
)
;
MOZ_ASSERT
(
mEventTarget
)
;
RefPtr
<
nsThreadStartupEvent
>
startup
=
new
nsThreadStartupEvent
(
)
;
NS_ADDREF_THIS
(
)
;
mShutdownRequired
=
true
;
ThreadInitData
initData
=
{
this
aName
}
;
if
(
!
PR_CreateThread
(
PR_USER_THREAD
ThreadFunc
&
initData
PR_PRIORITY_NORMAL
PR_GLOBAL_THREAD
PR_JOINABLE_THREAD
mStackSize
)
)
{
NS_RELEASE_THIS
(
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
{
mEvents
-
>
PutEvent
(
do_AddRef
(
startup
)
EventQueuePriority
:
:
Normal
)
;
}
startup
-
>
Wait
(
)
;
return
NS_OK
;
}
nsresult
nsThread
:
:
InitCurrentThread
(
)
{
mThread
=
PR_GetCurrentThread
(
)
;
mVirtualThread
=
GetCurrentVirtualThread
(
)
;
SetupCurrentThreadForChaosMode
(
)
;
InitCommon
(
)
;
nsThreadManager
:
:
get
(
)
.
RegisterCurrentThread
(
*
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
DispatchFromScript
(
nsIRunnable
*
aEvent
uint32_t
aFlags
)
{
MOZ_ASSERT
(
mEventTarget
)
;
NS_ENSURE_TRUE
(
mEventTarget
NS_ERROR_NOT_IMPLEMENTED
)
;
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
return
mEventTarget
-
>
Dispatch
(
event
.
forget
(
)
aFlags
)
;
}
NS_IMETHODIMP
nsThread
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
MOZ_ASSERT
(
mEventTarget
)
;
NS_ENSURE_TRUE
(
mEventTarget
NS_ERROR_NOT_IMPLEMENTED
)
;
LOG
(
(
"
THRD
(
%
p
)
Dispatch
[
%
p
%
x
]
\
n
"
this
nullptr
aFlags
)
)
;
return
mEventTarget
-
>
Dispatch
(
std
:
:
move
(
aEvent
)
aFlags
)
;
}
NS_IMETHODIMP
nsThread
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aDelayMs
)
{
MOZ_ASSERT
(
mEventTarget
)
;
NS_ENSURE_TRUE
(
mEventTarget
NS_ERROR_NOT_IMPLEMENTED
)
;
return
mEventTarget
-
>
DelayedDispatch
(
std
:
:
move
(
aEvent
)
aDelayMs
)
;
}
NS_IMETHODIMP
nsThread
:
:
IsOnCurrentThread
(
bool
*
aResult
)
{
if
(
mEventTarget
)
{
return
mEventTarget
-
>
IsOnCurrentThread
(
aResult
)
;
}
*
aResult
=
GetCurrentVirtualThread
(
)
=
=
mVirtualThread
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
bool
)
nsThread
:
:
IsOnCurrentThreadInfallible
(
)
{
MOZ_CRASH
(
"
IsOnCurrentThreadInfallible
should
never
be
called
on
nsIThread
"
)
;
}
NS_IMETHODIMP
nsThread
:
:
GetPRThread
(
PRThread
*
*
aResult
)
{
*
aResult
=
mThread
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
GetCanInvokeJS
(
bool
*
aResult
)
{
*
aResult
=
mCanInvokeJS
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
SetCanInvokeJS
(
bool
aCanInvokeJS
)
{
mCanInvokeJS
=
aCanInvokeJS
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
GetLastLongTaskEnd
(
TimeStamp
*
_retval
)
{
*
_retval
=
mLastLongTaskEnd
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
GetLastLongNonIdleTaskEnd
(
TimeStamp
*
_retval
)
{
*
_retval
=
mLastLongNonIdleTaskEnd
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
AsyncShutdown
(
)
{
LOG
(
(
"
THRD
(
%
p
)
async
shutdown
\
n
"
this
)
)
;
if
(
!
mThread
)
{
return
NS_OK
;
}
return
!
!
ShutdownInternal
(
false
)
?
NS_OK
:
NS_ERROR_UNEXPECTED
;
}
nsThreadShutdownContext
*
nsThread
:
:
ShutdownInternal
(
bool
aSync
)
{
MOZ_ASSERT
(
mEvents
)
;
MOZ_ASSERT
(
mEventTarget
)
;
MOZ_ASSERT
(
mThread
)
;
MOZ_ASSERT
(
mThread
!
=
PR_GetCurrentThread
(
)
)
;
if
(
NS_WARN_IF
(
mThread
=
=
PR_GetCurrentThread
(
)
)
)
{
return
nullptr
;
}
if
(
!
mShutdownRequired
.
compareExchange
(
true
false
)
)
{
return
nullptr
;
}
MaybeRemoveFromThreadList
(
)
;
NotNull
<
nsThread
*
>
currentThread
=
WrapNotNull
(
nsThreadManager
:
:
get
(
)
.
GetCurrentThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
currentThread
-
>
EventQueue
(
)
"
Shutdown
(
)
may
only
be
called
from
an
XPCOM
thread
"
)
;
nsAutoPtr
<
nsThreadShutdownContext
>
&
context
=
*
currentThread
-
>
mRequestedShutdownContexts
.
AppendElement
(
)
;
context
=
new
nsThreadShutdownContext
(
WrapNotNull
(
this
)
currentThread
aSync
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsThreadShutdownEvent
(
WrapNotNull
(
this
)
WrapNotNull
(
context
.
get
(
)
)
)
;
mEvents
-
>
PutEvent
(
event
.
forget
(
)
EventQueuePriority
:
:
Normal
)
;
return
context
;
}
void
nsThread
:
:
ShutdownComplete
(
NotNull
<
nsThreadShutdownContext
*
>
aContext
)
{
MOZ_ASSERT
(
mEvents
)
;
MOZ_ASSERT
(
mEventTarget
)
;
MOZ_ASSERT
(
mThread
)
;
MOZ_ASSERT
(
aContext
-
>
mTerminatingThread
=
=
this
)
;
MaybeRemoveFromThreadList
(
)
;
if
(
aContext
-
>
mAwaitingShutdownAck
)
{
aContext
-
>
mAwaitingShutdownAck
=
false
;
return
;
}
PR_JoinThread
(
mThread
)
;
mThread
=
nullptr
;
#
ifdef
DEBUG
nsCOMPtr
<
nsIThreadObserver
>
obs
=
mEvents
-
>
GetObserver
(
)
;
MOZ_ASSERT
(
!
obs
"
Should
have
been
cleared
at
shutdown
!
"
)
;
#
endif
aContext
-
>
mJoiningThread
-
>
mRequestedShutdownContexts
.
RemoveElement
(
aContext
)
;
}
void
nsThread
:
:
WaitForAllAsynchronousShutdowns
(
)
{
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
[
&
]
(
)
{
return
mRequestedShutdownContexts
.
IsEmpty
(
)
;
}
this
)
;
}
NS_IMETHODIMP
nsThread
:
:
Shutdown
(
)
{
LOG
(
(
"
THRD
(
%
p
)
sync
shutdown
\
n
"
this
)
)
;
if
(
!
mThread
)
{
return
NS_OK
;
}
nsThreadShutdownContext
*
maybeContext
=
ShutdownInternal
(
true
)
;
if
(
!
maybeContext
)
return
NS_ERROR_UNEXPECTED
;
NotNull
<
nsThreadShutdownContext
*
>
context
=
WrapNotNull
(
maybeContext
)
;
SpinEventLoopUntil
(
[
&
context
]
(
)
{
return
!
context
-
>
mAwaitingShutdownAck
;
}
context
-
>
mJoiningThread
)
;
ShutdownComplete
(
context
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
HasPendingEvents
(
bool
*
aResult
)
{
if
(
NS_WARN_IF
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
*
aResult
=
mEvents
-
>
HasPendingEvent
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
HasPendingHighPriorityEvents
(
bool
*
aResult
)
{
if
(
NS_WARN_IF
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
*
aResult
=
mEvents
-
>
HasPendingHighPriorityEvents
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
DispatchToQueue
(
already_AddRefed
<
nsIRunnable
>
aEvent
EventQueuePriority
aQueue
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
aEvent
;
if
(
NS_WARN_IF
(
!
event
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mEvents
-
>
PutEvent
(
event
.
forget
(
)
aQueue
)
)
{
NS_WARNING
(
"
An
idle
event
was
posted
to
a
thread
that
will
never
run
it
"
"
(
rejected
)
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
#
ifdef
MOZ_CANARY
void
canary_alarm_handler
(
int
signum
)
;
class
Canary
{
public
:
Canary
(
)
{
if
(
sCanaryOutputFD
>
0
&
&
EventLatencyIsImportant
(
)
)
{
signal
(
SIGALRM
canary_alarm_handler
)
;
ualarm
(
15000
0
)
;
}
}
~
Canary
(
)
{
if
(
sCanaryOutputFD
!
=
0
&
&
EventLatencyIsImportant
(
)
)
{
ualarm
(
0
0
)
;
}
}
static
bool
EventLatencyIsImportant
(
)
{
return
NS_IsMainThread
(
)
&
&
XRE_IsParentProcess
(
)
;
}
}
;
void
canary_alarm_handler
(
int
signum
)
{
void
*
array
[
30
]
;
const
char
msg
[
29
]
=
"
event
took
too
long
to
run
:
\
n
"
;
write
(
sCanaryOutputFD
msg
sizeof
(
msg
)
)
;
backtrace_symbols_fd
(
array
backtrace
(
array
30
)
sCanaryOutputFD
)
;
}
#
endif
#
define
NOTIFY_EVENT_OBSERVERS
(
observers_
func_
params_
)
\
do
{
\
if
(
!
observers_
.
IsEmpty
(
)
)
{
\
nsTObserverArray
<
nsCOMPtr
<
nsIThreadObserver
>
>
:
:
ForwardIterator
iter_
(
\
observers_
)
;
\
nsCOMPtr
<
nsIThreadObserver
>
obs_
;
\
while
(
iter_
.
HasMore
(
)
)
{
\
obs_
=
iter_
.
GetNext
(
)
;
\
obs_
-
>
func_
params_
;
\
}
\
}
\
}
while
(
0
)
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
static
bool
GetLabeledRunnableName
(
nsIRunnable
*
aEvent
nsACString
&
aName
EventQueuePriority
aPriority
)
{
bool
labeled
=
false
;
if
(
RefPtr
<
SchedulerGroup
:
:
Runnable
>
groupRunnable
=
do_QueryObject
(
aEvent
)
)
{
labeled
=
true
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
groupRunnable
-
>
GetName
(
aName
)
)
)
;
}
else
if
(
nsCOMPtr
<
nsINamed
>
named
=
do_QueryInterface
(
aEvent
)
)
{
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
named
-
>
GetName
(
aName
)
)
)
;
}
else
{
aName
.
AssignLiteral
(
"
non
-
nsINamed
runnable
"
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
aName
.
AssignLiteral
(
"
anonymous
runnable
"
)
;
}
if
(
!
labeled
&
&
aPriority
>
EventQueuePriority
:
:
Input
)
{
aName
.
AppendLiteral
(
"
(
unlabeled
)
"
)
;
}
return
labeled
;
}
#
endif
mozilla
:
:
PerformanceCounter
*
nsThread
:
:
GetPerformanceCounter
(
nsIRunnable
*
aEvent
)
{
RefPtr
<
SchedulerGroup
:
:
Runnable
>
docRunnable
=
do_QueryObject
(
aEvent
)
;
if
(
docRunnable
)
{
mozilla
:
:
dom
:
:
DocGroup
*
docGroup
=
docRunnable
-
>
DocGroup
(
)
;
if
(
docGroup
)
{
return
docGroup
-
>
GetPerformanceCounter
(
)
;
}
}
return
nullptr
;
}
size_t
nsThread
:
:
ShallowSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
if
(
mShutdownContext
)
{
n
+
=
aMallocSizeOf
(
mShutdownContext
)
;
}
n
+
=
mRequestedShutdownContexts
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
aMallocSizeOf
(
this
)
+
aMallocSizeOf
(
mThread
)
+
n
;
}
size_t
nsThread
:
:
SizeOfEventQueues
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
if
(
mCurrentPerformanceCounter
)
{
n
+
=
aMallocSizeOf
(
mCurrentPerformanceCounter
)
;
}
if
(
mEventTarget
)
{
n
+
=
mEventTarget
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
size_t
nsThread
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
+
SizeOfEventQueues
(
aMallocSizeOf
)
;
}
NS_IMETHODIMP
nsThread
:
:
ProcessNextEvent
(
bool
aMayWait
bool
*
aResult
)
{
MOZ_ASSERT
(
mEvents
)
;
NS_ENSURE_TRUE
(
mEvents
NS_ERROR_NOT_IMPLEMENTED
)
;
LOG
(
(
"
THRD
(
%
p
)
ProcessNextEvent
[
%
u
%
u
]
\
n
"
this
aMayWait
mNestedEventLoopDepth
)
)
;
if
(
NS_WARN_IF
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
bool
reallyWait
=
aMayWait
&
&
(
mNestedEventLoopDepth
>
0
|
|
!
ShuttingDown
(
)
)
;
if
(
IsMainThread
(
)
)
{
DoMainThreadSpecificProcessing
(
reallyWait
)
;
}
+
+
mNestedEventLoopDepth
;
Maybe
<
dom
:
:
AutoNoJSAPI
>
noJSAPI
;
bool
callScriptObserver
=
!
!
mScriptObserver
;
if
(
callScriptObserver
)
{
noJSAPI
.
emplace
(
)
;
mScriptObserver
-
>
BeforeProcessTask
(
reallyWait
)
;
}
nsCOMPtr
<
nsIThreadObserver
>
obs
=
mEvents
-
>
GetObserverOnThread
(
)
;
if
(
obs
)
{
obs
-
>
OnProcessNextEvent
(
this
reallyWait
)
;
}
NOTIFY_EVENT_OBSERVERS
(
EventQueue
(
)
-
>
EventObservers
(
)
OnProcessNextEvent
(
this
reallyWait
)
)
;
#
ifdef
MOZ_CANARY
Canary
canary
;
#
endif
nsresult
rv
=
NS_OK
;
{
EventQueuePriority
priority
;
nsCOMPtr
<
nsIRunnable
>
event
=
mEvents
-
>
GetEvent
(
reallyWait
&
priority
)
;
*
aResult
=
(
event
.
get
(
)
!
=
nullptr
)
;
if
(
event
)
{
LOG
(
(
"
THRD
(
%
p
)
running
[
%
p
]
\
n
"
this
event
.
get
(
)
)
)
;
DelayForChaosMode
(
ChaosFeature
:
:
TaskRunning
1000
)
;
if
(
IsMainThread
(
)
)
{
BackgroundHangMonitor
(
)
.
NotifyActivity
(
)
;
}
bool
schedulerLoggingEnabled
=
mozilla
:
:
StaticPrefs
:
:
dom_performance_enable_scheduler_timing
(
)
;
if
(
schedulerLoggingEnabled
&
&
mNestedEventLoopDepth
>
mCurrentEventLoopDepth
&
&
mCurrentPerformanceCounter
)
{
mozilla
:
:
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
mCurrentEventStart
;
mCurrentPerformanceCounter
-
>
IncrementExecutionDuration
(
duration
.
ToMicroseconds
(
)
)
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
Array
<
char
kRunnableNameBufSize
>
restoreRunnableName
;
restoreRunnableName
[
0
]
=
'
\
0
'
;
auto
clear
=
MakeScopeExit
(
[
&
]
{
if
(
IsMainThread
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sMainThreadRunnableName
=
restoreRunnableName
;
}
}
)
;
if
(
IsMainThread
(
)
)
{
nsAutoCString
name
;
GetLabeledRunnableName
(
event
name
priority
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
restoreRunnableName
=
sMainThreadRunnableName
;
uint32_t
length
=
std
:
:
min
(
(
uint32_t
)
kRunnableNameBufSize
-
1
(
uint32_t
)
name
.
Length
(
)
)
;
memcpy
(
sMainThreadRunnableName
.
begin
(
)
name
.
BeginReading
(
)
length
)
;
sMainThreadRunnableName
[
length
]
=
'
\
0
'
;
}
#
endif
Maybe
<
AutoTimeDurationHelper
>
timeDurationHelper
;
if
(
priority
=
=
EventQueuePriority
:
:
Input
)
{
timeDurationHelper
.
emplace
(
)
;
}
bool
recursiveEvent
=
mNestedEventLoopDepth
>
mCurrentEventLoopDepth
;
mCurrentEventLoopDepth
=
mNestedEventLoopDepth
;
if
(
IsMainThread
(
)
&
&
!
recursiveEvent
)
{
mCurrentEventStart
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
}
RefPtr
<
mozilla
:
:
PerformanceCounter
>
currentPerformanceCounter
;
if
(
schedulerLoggingEnabled
)
{
mCurrentEventStart
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
mCurrentEvent
=
event
;
mCurrentPerformanceCounter
=
GetPerformanceCounter
(
event
)
;
currentPerformanceCounter
=
mCurrentPerformanceCounter
;
}
event
-
>
Run
(
)
;
mozilla
:
:
TimeDuration
duration
;
if
(
IsMainThread
(
)
&
&
!
recursiveEvent
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
duration
=
now
-
mCurrentEventStart
;
if
(
duration
.
ToMilliseconds
(
)
>
LONGTASK_BUSY_WINDOW_MS
)
{
if
(
priority
!
=
EventQueuePriority
:
:
Idle
)
{
mLastLongNonIdleTaskEnd
=
now
;
}
mLastLongTaskEnd
=
now
;
#
ifdef
MOZ_GECKO_PROFILER
if
(
profiler_thread_is_being_profiled
(
)
)
{
profiler_add_marker
(
(
priority
!
=
EventQueuePriority
:
:
Idle
)
?
"
LongTask
"
:
"
LongIdleTask
"
js
:
:
ProfilingStackFrame
:
:
Category
:
:
OTHER
MakeUnique
<
LongTaskMarkerPayload
>
(
mCurrentEventStart
now
)
)
;
}
#
endif
}
}
if
(
schedulerLoggingEnabled
)
{
if
(
recursiveEvent
)
{
mCurrentEventStart
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
mCurrentPerformanceCounter
=
currentPerformanceCounter
;
}
else
{
if
(
currentPerformanceCounter
)
{
mozilla
:
:
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
mCurrentEventStart
;
currentPerformanceCounter
-
>
IncrementExecutionDuration
(
duration
.
ToMicroseconds
(
)
)
;
}
mCurrentEvent
=
nullptr
;
mCurrentEventLoopDepth
=
-
1
;
mCurrentPerformanceCounter
=
nullptr
;
}
}
}
else
if
(
aMayWait
)
{
MOZ_ASSERT
(
ShuttingDown
(
)
"
This
should
only
happen
when
shutting
down
"
)
;
rv
=
NS_ERROR_UNEXPECTED
;
}
}
NOTIFY_EVENT_OBSERVERS
(
EventQueue
(
)
-
>
EventObservers
(
)
AfterProcessNextEvent
(
this
*
aResult
)
)
;
if
(
obs
)
{
obs
-
>
AfterProcessNextEvent
(
this
*
aResult
)
;
}
if
(
callScriptObserver
)
{
if
(
mScriptObserver
)
{
mScriptObserver
-
>
AfterProcessTask
(
mNestedEventLoopDepth
)
;
}
noJSAPI
.
reset
(
)
;
}
-
-
mNestedEventLoopDepth
;
return
rv
;
}
NS_IMETHODIMP
nsThread
:
:
GetPriority
(
int32_t
*
aPriority
)
{
*
aPriority
=
mPriority
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
SetPriority
(
int32_t
aPriority
)
{
if
(
NS_WARN_IF
(
!
mThread
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mPriority
=
aPriority
;
PRThreadPriority
pri
;
if
(
mPriority
<
=
PRIORITY_HIGHEST
)
{
pri
=
PR_PRIORITY_URGENT
;
}
else
if
(
mPriority
<
PRIORITY_NORMAL
)
{
pri
=
PR_PRIORITY_HIGH
;
}
else
if
(
mPriority
>
PRIORITY_NORMAL
)
{
pri
=
PR_PRIORITY_LOW
;
}
else
{
pri
=
PR_PRIORITY_NORMAL
;
}
if
(
!
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
ThreadScheduling
)
)
{
PR_SetThreadPriority
(
mThread
pri
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
AdjustPriority
(
int32_t
aDelta
)
{
return
SetPriority
(
mPriority
+
aDelta
)
;
}
NS_IMETHODIMP
nsThread
:
:
GetObserver
(
nsIThreadObserver
*
*
aObs
)
{
MOZ_ASSERT
(
mEvents
)
;
NS_ENSURE_TRUE
(
mEvents
NS_ERROR_NOT_IMPLEMENTED
)
;
nsCOMPtr
<
nsIThreadObserver
>
obs
=
mEvents
-
>
GetObserver
(
)
;
obs
.
forget
(
aObs
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
SetObserver
(
nsIThreadObserver
*
aObs
)
{
MOZ_ASSERT
(
mEvents
)
;
NS_ENSURE_TRUE
(
mEvents
NS_ERROR_NOT_IMPLEMENTED
)
;
if
(
NS_WARN_IF
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
mEvents
-
>
SetObserver
(
aObs
)
;
return
NS_OK
;
}
uint32_t
nsThread
:
:
RecursionDepth
(
)
const
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
mThread
)
;
return
mNestedEventLoopDepth
;
}
NS_IMETHODIMP
nsThread
:
:
AddObserver
(
nsIThreadObserver
*
aObserver
)
{
MOZ_ASSERT
(
mEvents
)
;
NS_ENSURE_TRUE
(
mEvents
NS_ERROR_NOT_IMPLEMENTED
)
;
if
(
NS_WARN_IF
(
!
aObserver
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
EventQueue
(
)
-
>
AddObserver
(
aObserver
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
RemoveObserver
(
nsIThreadObserver
*
aObserver
)
{
MOZ_ASSERT
(
mEvents
)
;
NS_ENSURE_TRUE
(
mEvents
NS_ERROR_NOT_IMPLEMENTED
)
;
if
(
NS_WARN_IF
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
EventQueue
(
)
-
>
RemoveObserver
(
aObserver
)
;
return
NS_OK
;
}
void
nsThread
:
:
SetScriptObserver
(
mozilla
:
:
CycleCollectedJSContext
*
aScriptObserver
)
{
if
(
!
aScriptObserver
)
{
mScriptObserver
=
nullptr
;
return
;
}
MOZ_ASSERT
(
!
mScriptObserver
)
;
mScriptObserver
=
aScriptObserver
;
}
void
nsThread
:
:
DoMainThreadSpecificProcessing
(
bool
aReallyWait
)
{
MOZ_ASSERT
(
IsMainThread
(
)
)
;
ipc
:
:
CancelCPOWs
(
)
;
if
(
aReallyWait
)
{
BackgroundHangMonitor
(
)
.
NotifyWait
(
)
;
}
if
(
!
ShuttingDown
(
)
)
{
MemoryPressureState
mpPending
=
NS_GetPendingMemoryPressure
(
)
;
if
(
mpPending
!
=
MemPressure_None
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
if
(
mpPending
=
=
MemPressure_Stopping
)
{
os
-
>
NotifyObservers
(
nullptr
"
memory
-
pressure
-
stop
"
nullptr
)
;
}
else
{
os
-
>
NotifyObservers
(
nullptr
"
memory
-
pressure
"
mpPending
=
=
MemPressure_New
?
u
"
low
-
memory
"
:
u
"
low
-
memory
-
ongoing
"
)
;
}
}
else
{
NS_WARNING
(
"
Can
'
t
get
observer
service
!
"
)
;
}
}
}
}
NS_IMETHODIMP
nsThread
:
:
GetEventTarget
(
nsIEventTarget
*
*
aEventTarget
)
{
nsCOMPtr
<
nsIEventTarget
>
target
=
this
;
target
.
forget
(
aEventTarget
)
;
return
NS_OK
;
}
nsIEventTarget
*
nsThread
:
:
EventTarget
(
)
{
return
this
;
}
nsISerialEventTarget
*
nsThread
:
:
SerialEventTarget
(
)
{
return
this
;
}
