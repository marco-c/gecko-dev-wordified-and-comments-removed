#
include
"
nsThread
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
ifdef
LOG
#
undef
LOG
#
endif
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
nsMemoryPressure
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsIClassInfoImpl
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
pratom
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
HangMonitor
.
h
"
#
include
"
mozilla
/
IOInterposer
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
Scheduler
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
mozilla
/
ChaosMode
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsThreadSyncDispatch
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
InputEventStatistics
.
h
"
#
include
"
ThreadEventTarget
.
h
"
#
ifdef
MOZ_CRASHREPORTER
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsICrashReporter
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
endif
#
ifdef
XP_LINUX
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
resource
.
h
>
#
include
<
sched
.
h
>
#
endif
#
define
HAVE_UALARM
_BSD_SOURCE
|
|
(
_XOPEN_SOURCE
>
=
500
|
|
\
_XOPEN_SOURCE
&
&
_XOPEN_SOURCE_EXTENDED
)
&
&
\
!
(
_POSIX_C_SOURCE
>
=
200809L
|
|
_XOPEN_SOURCE
>
=
700
)
#
if
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
&
&
defined
(
_GNU_SOURCE
)
#
define
HAVE_SCHED_SETAFFINITY
#
endif
#
ifdef
XP_MACOSX
#
include
<
mach
/
mach
.
h
>
#
include
<
mach
/
thread_policy
.
h
>
#
endif
#
ifdef
MOZ_CANARY
#
include
<
unistd
.
h
>
#
include
<
execinfo
.
h
>
#
include
<
signal
.
h
>
#
include
<
fcntl
.
h
>
#
include
"
nsXULAppAPI
.
h
"
#
endif
#
if
defined
(
NS_FUNCTION_TIMER
)
&
&
defined
(
_MSC_VER
)
#
include
"
nsTimerImpl
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
endif
#
ifdef
NS_FUNCTION_TIMER
#
include
"
nsCRT
.
h
"
#
endif
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
include
"
TracedTaskCommon
.
h
"
using
namespace
mozilla
:
:
tasktracer
;
#
endif
using
namespace
mozilla
;
static
LazyLogModule
sThreadLog
(
"
nsThread
"
)
;
#
ifdef
LOG
#
undef
LOG
#
endif
#
define
LOG
(
args
)
MOZ_LOG
(
sThreadLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
NS_DECL_CI_INTERFACE_GETTER
(
nsThread
)
Array
<
char
nsThread
:
:
kRunnableNameBufSize
>
nsThread
:
:
sMainThreadRunnableName
;
class
nsThreadClassInfo
:
public
nsIClassInfo
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSICLASSINFO
nsThreadClassInfo
(
)
{
}
}
;
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsThreadClassInfo
:
:
AddRef
(
)
{
return
2
;
}
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsThreadClassInfo
:
:
Release
(
)
{
return
1
;
}
NS_IMPL_QUERY_INTERFACE
(
nsThreadClassInfo
nsIClassInfo
)
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetInterfaces
(
uint32_t
*
aCount
nsIID
*
*
*
aArray
)
{
return
NS_CI_INTERFACE_GETTER_NAME
(
nsThread
)
(
aCount
aArray
)
;
}
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetScriptableHelper
(
nsIXPCScriptable
*
*
aResult
)
{
*
aResult
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetContractID
(
char
*
*
aResult
)
{
*
aResult
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetClassDescription
(
char
*
*
aResult
)
{
*
aResult
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetClassID
(
nsCID
*
*
aResult
)
{
*
aResult
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetFlags
(
uint32_t
*
aResult
)
{
*
aResult
=
THREADSAFE
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadClassInfo
:
:
GetClassIDNoAlloc
(
nsCID
*
aResult
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMPL_ADDREF
(
nsThread
)
NS_IMPL_RELEASE
(
nsThread
)
NS_INTERFACE_MAP_BEGIN
(
nsThread
)
NS_INTERFACE_MAP_ENTRY
(
nsIThread
)
NS_INTERFACE_MAP_ENTRY
(
nsIThreadInternal
)
NS_INTERFACE_MAP_ENTRY
(
nsIEventTarget
)
NS_INTERFACE_MAP_ENTRY
(
nsISerialEventTarget
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsPriority
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIThread
)
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIClassInfo
)
)
)
{
static
nsThreadClassInfo
sThreadClassInfo
;
foundInterface
=
static_cast
<
nsIClassInfo
*
>
(
&
sThreadClassInfo
)
;
}
else
NS_INTERFACE_MAP_END
NS_IMPL_CI_INTERFACE_GETTER
(
nsThread
nsIThread
nsIThreadInternal
nsIEventTarget
nsISupportsPriority
)
class
nsThreadStartupEvent
:
public
Runnable
{
public
:
nsThreadStartupEvent
(
)
:
Runnable
(
"
nsThreadStartupEvent
"
)
mMon
(
"
nsThreadStartupEvent
.
mMon
"
)
mInitialized
(
false
)
{
}
void
Wait
(
)
{
ReentrantMonitorAutoEnter
mon
(
mMon
)
;
while
(
!
mInitialized
)
{
mon
.
Wait
(
)
;
}
}
virtual
~
nsThreadStartupEvent
(
)
{
}
private
:
NS_IMETHOD
Run
(
)
override
{
ReentrantMonitorAutoEnter
mon
(
mMon
)
;
mInitialized
=
true
;
mon
.
Notify
(
)
;
return
NS_OK
;
}
ReentrantMonitor
mMon
;
bool
mInitialized
;
}
;
struct
nsThreadShutdownContext
{
nsThreadShutdownContext
(
NotNull
<
nsThread
*
>
aTerminatingThread
NotNull
<
nsThread
*
>
aJoiningThread
bool
aAwaitingShutdownAck
)
:
mTerminatingThread
(
aTerminatingThread
)
mJoiningThread
(
aJoiningThread
)
mAwaitingShutdownAck
(
aAwaitingShutdownAck
)
mIsMainThreadJoining
(
NS_IsMainThread
(
)
)
{
MOZ_COUNT_CTOR
(
nsThreadShutdownContext
)
;
}
~
nsThreadShutdownContext
(
)
{
MOZ_COUNT_DTOR
(
nsThreadShutdownContext
)
;
}
NotNull
<
RefPtr
<
nsThread
>
>
mTerminatingThread
;
NotNull
<
nsThread
*
>
MOZ_UNSAFE_REF
(
"
Thread
manager
is
holding
reference
to
joining
thread
"
)
mJoiningThread
;
bool
mAwaitingShutdownAck
;
bool
mIsMainThreadJoining
;
}
;
class
nsThreadShutdownAckEvent
:
public
CancelableRunnable
{
public
:
explicit
nsThreadShutdownAckEvent
(
NotNull
<
nsThreadShutdownContext
*
>
aCtx
)
:
CancelableRunnable
(
"
nsThreadShutdownAckEvent
"
)
mShutdownContext
(
aCtx
)
{
}
NS_IMETHOD
Run
(
)
override
{
mShutdownContext
-
>
mTerminatingThread
-
>
ShutdownComplete
(
mShutdownContext
)
;
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
return
Run
(
)
;
}
private
:
virtual
~
nsThreadShutdownAckEvent
(
)
{
}
NotNull
<
nsThreadShutdownContext
*
>
mShutdownContext
;
}
;
class
nsThreadShutdownEvent
:
public
Runnable
{
public
:
nsThreadShutdownEvent
(
NotNull
<
nsThread
*
>
aThr
NotNull
<
nsThreadShutdownContext
*
>
aCtx
)
:
Runnable
(
"
nsThreadShutdownEvent
"
)
mThread
(
aThr
)
mShutdownContext
(
aCtx
)
{
}
NS_IMETHOD
Run
(
)
override
{
mThread
-
>
mShutdownContext
=
mShutdownContext
;
MessageLoop
:
:
current
(
)
-
>
Quit
(
)
;
return
NS_OK
;
}
private
:
NotNull
<
RefPtr
<
nsThread
>
>
mThread
;
NotNull
<
nsThreadShutdownContext
*
>
mShutdownContext
;
}
;
static
void
SetThreadAffinity
(
unsigned
int
cpu
)
{
#
ifdef
HAVE_SCHED_SETAFFINITY
cpu_set_t
cpus
;
CPU_ZERO
(
&
cpus
)
;
CPU_SET
(
cpu
&
cpus
)
;
sched_setaffinity
(
0
sizeof
(
cpus
)
&
cpus
)
;
#
elif
defined
(
XP_MACOSX
)
thread_affinity_policy_data_t
policy
;
policy
.
affinity_tag
=
cpu
+
1
;
MOZ_ALWAYS_TRUE
(
thread_policy_set
(
mach_thread_self
(
)
THREAD_AFFINITY_POLICY
&
policy
.
affinity_tag
1
)
=
=
KERN_SUCCESS
)
;
#
elif
defined
(
XP_WIN
)
MOZ_ALWAYS_TRUE
(
SetThreadIdealProcessor
(
GetCurrentThread
(
)
cpu
)
!
=
(
DWORD
)
-
1
)
;
#
endif
}
static
void
SetupCurrentThreadForChaosMode
(
)
{
if
(
!
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
ThreadScheduling
)
)
{
return
;
}
#
ifdef
XP_LINUX
setpriority
(
PRIO_PROCESS
0
ChaosMode
:
:
randomUint32LessThan
(
4
)
)
;
#
else
uint32_t
priority
=
ChaosMode
:
:
randomUint32LessThan
(
PR_PRIORITY_LAST
+
1
)
;
PR_SetThreadPriority
(
PR_GetCurrentThread
(
)
PRThreadPriority
(
priority
)
)
;
#
endif
if
(
ChaosMode
:
:
randomUint32LessThan
(
2
)
)
{
SetThreadAffinity
(
0
)
;
}
}
namespace
{
struct
ThreadInitData
{
nsThread
*
thread
;
const
nsACString
&
name
;
}
;
}
void
nsThread
:
:
ThreadFunc
(
void
*
aArg
)
{
using
mozilla
:
:
ipc
:
:
BackgroundChild
;
ThreadInitData
*
initData
=
static_cast
<
ThreadInitData
*
>
(
aArg
)
;
nsThread
*
self
=
initData
-
>
thread
;
self
-
>
mThread
=
PR_GetCurrentThread
(
)
;
self
-
>
mVirtualThread
=
GetCurrentVirtualThread
(
)
;
self
-
>
mEventTarget
-
>
SetCurrentThread
(
)
;
SetupCurrentThreadForChaosMode
(
)
;
if
(
!
initData
-
>
name
.
IsEmpty
(
)
)
{
NS_SetCurrentThreadName
(
initData
-
>
name
.
BeginReading
(
)
)
;
}
nsThreadManager
:
:
get
(
)
.
RegisterCurrentThread
(
*
self
)
;
mozilla
:
:
IOInterposer
:
:
RegisterCurrentThread
(
)
;
if
(
!
initData
-
>
name
.
IsEmpty
(
)
)
{
PROFILER_REGISTER_THREAD
(
initData
-
>
name
.
BeginReading
(
)
)
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
self
-
>
mEvents
-
>
GetEvent
(
true
nullptr
)
;
MOZ_ASSERT
(
event
)
;
initData
=
nullptr
;
event
-
>
Run
(
)
;
event
=
nullptr
;
{
nsAutoPtr
<
MessageLoop
>
loop
(
new
MessageLoop
(
MessageLoop
:
:
TYPE_MOZILLA_NONMAINTHREAD
self
)
)
;
loop
-
>
Run
(
)
;
BackgroundChild
:
:
CloseForCurrentThread
(
)
;
while
(
true
)
{
self
-
>
WaitForAllAsynchronousShutdowns
(
)
;
if
(
self
-
>
mEvents
-
>
ShutdownIfNoPendingEvents
(
)
)
{
break
;
}
NS_ProcessPendingEvents
(
self
)
;
}
}
mozilla
:
:
IOInterposer
:
:
UnregisterCurrentThread
(
)
;
nsThreadManager
:
:
get
(
)
.
UnregisterCurrentThread
(
*
self
)
;
PROFILER_UNREGISTER_THREAD
(
)
;
NotNull
<
nsThreadShutdownContext
*
>
context
=
WrapNotNull
(
self
-
>
mShutdownContext
)
;
MOZ_ASSERT
(
context
-
>
mTerminatingThread
=
=
self
)
;
event
=
do_QueryObject
(
new
nsThreadShutdownAckEvent
(
context
)
)
;
if
(
context
-
>
mIsMainThreadJoining
)
{
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
}
else
{
context
-
>
mJoiningThread
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
self
-
>
SetObserver
(
nullptr
)
;
#
ifdef
MOZ_TASK_TRACER
FreeTraceInfo
(
)
;
#
endif
NS_RELEASE
(
self
)
;
}
#
ifdef
MOZ_CRASHREPORTER
bool
nsThread
:
:
SaveMemoryReportNearOOM
(
ShouldSaveMemoryReport
aShouldSave
)
{
const
size_t
kLowMemoryCheckSeconds
=
30
;
const
size_t
kLowMemorySaveSeconds
=
3
*
60
;
static
TimeStamp
nextCheck
=
TimeStamp
:
:
NowLoRes
(
)
+
TimeDuration
:
:
FromSeconds
(
kLowMemoryCheckSeconds
)
;
static
bool
recentlySavedReport
=
false
;
TimeStamp
now
=
TimeStamp
:
:
NowLoRes
(
)
;
if
(
(
aShouldSave
=
=
ShouldSaveMemoryReport
:
:
kMaybeReport
|
|
recentlySavedReport
)
&
&
now
<
nextCheck
)
{
return
false
;
}
bool
needMemoryReport
=
(
aShouldSave
=
=
ShouldSaveMemoryReport
:
:
kForceReport
)
;
#
ifdef
XP_WIN
if
(
aShouldSave
!
=
ShouldSaveMemoryReport
:
:
kForceReport
)
{
const
size_t
LOWMEM_THRESHOLD_VIRTUAL
=
200
*
1024
*
1024
;
MEMORYSTATUSEX
statex
;
statex
.
dwLength
=
sizeof
(
statex
)
;
if
(
GlobalMemoryStatusEx
(
&
statex
)
)
{
if
(
statex
.
ullAvailVirtual
<
LOWMEM_THRESHOLD_VIRTUAL
)
{
needMemoryReport
=
true
;
}
}
}
#
endif
if
(
needMemoryReport
)
{
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
if
(
cc
)
{
cc
-
>
SendNotifyLowMemory
(
)
;
}
}
else
{
nsCOMPtr
<
nsICrashReporter
>
cr
=
do_GetService
(
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
)
;
if
(
cr
)
{
cr
-
>
SaveMemoryReport
(
)
;
}
}
recentlySavedReport
=
true
;
nextCheck
=
now
+
TimeDuration
:
:
FromSeconds
(
kLowMemorySaveSeconds
)
;
}
else
{
recentlySavedReport
=
false
;
nextCheck
=
now
+
TimeDuration
:
:
FromSeconds
(
kLowMemoryCheckSeconds
)
;
}
return
recentlySavedReport
;
}
#
endif
#
ifdef
MOZ_CANARY
int
sCanaryOutputFD
=
-
1
;
#
endif
nsThread
:
:
nsThread
(
NotNull
<
SynchronizedEventQueue
*
>
aQueue
MainThreadFlag
aMainThread
uint32_t
aStackSize
)
:
mEvents
(
aQueue
.
get
(
)
)
mEventTarget
(
new
ThreadEventTarget
(
mEvents
.
get
(
)
aMainThread
=
=
MAIN_THREAD
)
)
mScriptObserver
(
nullptr
)
mPriority
(
PRIORITY_NORMAL
)
mThread
(
nullptr
)
mNestedEventLoopDepth
(
0
)
mStackSize
(
aStackSize
)
mShutdownContext
(
nullptr
)
mShutdownRequired
(
false
)
mIsMainThread
(
aMainThread
)
mLastUnlabeledRunnable
(
TimeStamp
:
:
Now
(
)
)
mCanInvokeJS
(
false
)
{
}
nsThread
:
:
~
nsThread
(
)
{
NS_ASSERTION
(
mRequestedShutdownContexts
.
IsEmpty
(
)
"
shouldn
'
t
be
waiting
on
other
threads
to
shutdown
"
)
;
#
ifdef
DEBUG
for
(
size_t
i
=
0
;
i
<
mRequestedShutdownContexts
.
Length
(
)
;
+
+
i
)
{
Unused
<
<
mRequestedShutdownContexts
[
i
]
.
forget
(
)
;
}
#
endif
}
nsresult
nsThread
:
:
Init
(
const
nsACString
&
aName
)
{
RefPtr
<
nsThreadStartupEvent
>
startup
=
new
nsThreadStartupEvent
(
)
;
NS_ADDREF_THIS
(
)
;
mShutdownRequired
=
true
;
ThreadInitData
initData
=
{
this
aName
}
;
if
(
!
PR_CreateThread
(
PR_USER_THREAD
ThreadFunc
&
initData
PR_PRIORITY_NORMAL
PR_GLOBAL_THREAD
PR_JOINABLE_THREAD
mStackSize
)
)
{
NS_RELEASE_THIS
(
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
{
mEvents
-
>
PutEvent
(
do_AddRef
(
startup
)
EventPriority
:
:
Normal
)
;
}
startup
-
>
Wait
(
)
;
return
NS_OK
;
}
nsresult
nsThread
:
:
InitCurrentThread
(
)
{
mThread
=
PR_GetCurrentThread
(
)
;
mVirtualThread
=
GetCurrentVirtualThread
(
)
;
SetupCurrentThreadForChaosMode
(
)
;
nsThreadManager
:
:
get
(
)
.
RegisterCurrentThread
(
*
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
DispatchFromScript
(
nsIRunnable
*
aEvent
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
return
mEventTarget
-
>
Dispatch
(
event
.
forget
(
)
aFlags
)
;
}
NS_IMETHODIMP
nsThread
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
LOG
(
(
"
THRD
(
%
p
)
Dispatch
[
%
p
%
x
]
\
n
"
this
nullptr
aFlags
)
)
;
return
mEventTarget
-
>
Dispatch
(
Move
(
aEvent
)
aFlags
)
;
}
NS_IMETHODIMP
nsThread
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aDelayMs
)
{
return
mEventTarget
-
>
DelayedDispatch
(
Move
(
aEvent
)
aDelayMs
)
;
}
NS_IMETHODIMP
nsThread
:
:
IsOnCurrentThread
(
bool
*
aResult
)
{
return
mEventTarget
-
>
IsOnCurrentThread
(
aResult
)
;
}
NS_IMETHODIMP_
(
bool
)
nsThread
:
:
IsOnCurrentThreadInfallible
(
)
{
MOZ_CRASH
(
"
IsOnCurrentThreadInfallible
should
never
be
called
on
nsIThread
"
)
;
}
NS_IMETHODIMP
nsThread
:
:
GetPRThread
(
PRThread
*
*
aResult
)
{
*
aResult
=
mThread
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
GetCanInvokeJS
(
bool
*
aResult
)
{
*
aResult
=
mCanInvokeJS
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
SetCanInvokeJS
(
bool
aCanInvokeJS
)
{
mCanInvokeJS
=
aCanInvokeJS
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
AsyncShutdown
(
)
{
LOG
(
(
"
THRD
(
%
p
)
async
shutdown
\
n
"
this
)
)
;
if
(
!
mThread
)
{
return
NS_OK
;
}
return
!
!
ShutdownInternal
(
false
)
?
NS_OK
:
NS_ERROR_UNEXPECTED
;
}
nsThreadShutdownContext
*
nsThread
:
:
ShutdownInternal
(
bool
aSync
)
{
MOZ_ASSERT
(
mThread
)
;
MOZ_ASSERT
(
mThread
!
=
PR_GetCurrentThread
(
)
)
;
if
(
NS_WARN_IF
(
mThread
=
=
PR_GetCurrentThread
(
)
)
)
{
return
nullptr
;
}
if
(
!
mShutdownRequired
.
compareExchange
(
true
false
)
)
{
return
nullptr
;
}
NotNull
<
nsThread
*
>
currentThread
=
WrapNotNull
(
nsThreadManager
:
:
get
(
)
.
GetCurrentThread
(
)
)
;
nsAutoPtr
<
nsThreadShutdownContext
>
&
context
=
*
currentThread
-
>
mRequestedShutdownContexts
.
AppendElement
(
)
;
context
=
new
nsThreadShutdownContext
(
WrapNotNull
(
this
)
currentThread
aSync
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsThreadShutdownEvent
(
WrapNotNull
(
this
)
WrapNotNull
(
context
.
get
(
)
)
)
;
mEvents
-
>
PutEvent
(
event
.
forget
(
)
EventPriority
:
:
Normal
)
;
return
context
;
}
void
nsThread
:
:
ShutdownComplete
(
NotNull
<
nsThreadShutdownContext
*
>
aContext
)
{
MOZ_ASSERT
(
mThread
)
;
MOZ_ASSERT
(
aContext
-
>
mTerminatingThread
=
=
this
)
;
if
(
aContext
-
>
mAwaitingShutdownAck
)
{
aContext
-
>
mAwaitingShutdownAck
=
false
;
return
;
}
PR_JoinThread
(
mThread
)
;
mThread
=
nullptr
;
ClearObservers
(
)
;
#
ifdef
DEBUG
nsCOMPtr
<
nsIThreadObserver
>
obs
=
mEvents
-
>
GetObserver
(
)
;
MOZ_ASSERT
(
!
obs
"
Should
have
been
cleared
at
shutdown
!
"
)
;
#
endif
MOZ_ALWAYS_TRUE
(
aContext
-
>
mJoiningThread
-
>
mRequestedShutdownContexts
.
RemoveElement
(
aContext
)
)
;
}
void
nsThread
:
:
WaitForAllAsynchronousShutdowns
(
)
{
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
[
&
]
(
)
{
return
mRequestedShutdownContexts
.
IsEmpty
(
)
;
}
this
)
;
}
NS_IMETHODIMP
nsThread
:
:
Shutdown
(
)
{
LOG
(
(
"
THRD
(
%
p
)
sync
shutdown
\
n
"
this
)
)
;
if
(
!
mThread
)
{
return
NS_OK
;
}
nsThreadShutdownContext
*
maybeContext
=
ShutdownInternal
(
true
)
;
NS_ENSURE_TRUE
(
maybeContext
NS_ERROR_UNEXPECTED
)
;
NotNull
<
nsThreadShutdownContext
*
>
context
=
WrapNotNull
(
maybeContext
)
;
SpinEventLoopUntil
(
[
&
context
]
(
)
{
return
!
context
-
>
mAwaitingShutdownAck
;
}
context
-
>
mJoiningThread
)
;
ShutdownComplete
(
context
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
HasPendingEvents
(
bool
*
aResult
)
{
if
(
NS_WARN_IF
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
*
aResult
=
mEvents
-
>
HasPendingEvent
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
IdleDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
aEvent
;
if
(
NS_WARN_IF
(
!
event
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mEvents
-
>
PutEvent
(
event
.
forget
(
)
EventPriority
:
:
Idle
)
)
{
NS_WARNING
(
"
An
idle
event
was
posted
to
a
thread
that
will
never
run
it
(
rejected
)
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
#
ifdef
MOZ_CANARY
void
canary_alarm_handler
(
int
signum
)
;
class
Canary
{
public
:
Canary
(
)
{
if
(
sCanaryOutputFD
>
0
&
&
EventLatencyIsImportant
(
)
)
{
signal
(
SIGALRM
canary_alarm_handler
)
;
ualarm
(
15000
0
)
;
}
}
~
Canary
(
)
{
if
(
sCanaryOutputFD
!
=
0
&
&
EventLatencyIsImportant
(
)
)
{
ualarm
(
0
0
)
;
}
}
static
bool
EventLatencyIsImportant
(
)
{
return
NS_IsMainThread
(
)
&
&
XRE_IsParentProcess
(
)
;
}
}
;
void
canary_alarm_handler
(
int
signum
)
{
void
*
array
[
30
]
;
const
char
msg
[
29
]
=
"
event
took
too
long
to
run
:
\
n
"
;
write
(
sCanaryOutputFD
msg
sizeof
(
msg
)
)
;
backtrace_symbols_fd
(
array
backtrace
(
array
30
)
sCanaryOutputFD
)
;
}
#
endif
#
define
NOTIFY_EVENT_OBSERVERS
(
observers_
func_
params_
)
\
do
{
\
if
(
!
observers_
.
IsEmpty
(
)
)
{
\
nsTObserverArray
<
nsCOMPtr
<
nsIThreadObserver
>
>
:
:
ForwardIterator
\
iter_
(
observers_
)
;
\
nsCOMPtr
<
nsIThreadObserver
>
obs_
;
\
while
(
iter_
.
HasMore
(
)
)
{
\
obs_
=
iter_
.
GetNext
(
)
;
\
obs_
-
>
func_
params_
;
\
}
\
}
\
}
while
(
0
)
#
ifndef
RELEASE_OR_BETA
static
bool
GetLabeledRunnableName
(
nsIRunnable
*
aEvent
nsACString
&
aName
)
{
bool
labeled
=
false
;
if
(
RefPtr
<
SchedulerGroup
:
:
Runnable
>
groupRunnable
=
do_QueryObject
(
aEvent
)
)
{
labeled
=
true
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
groupRunnable
-
>
GetName
(
aName
)
)
)
;
}
else
if
(
nsCOMPtr
<
nsINamed
>
named
=
do_QueryInterface
(
aEvent
)
)
{
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
named
-
>
GetName
(
aName
)
)
)
;
}
else
{
aName
.
AssignLiteral
(
"
non
-
nsINamed
runnable
"
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
aName
.
AssignLiteral
(
"
anonymous
runnable
"
)
;
}
return
labeled
;
}
#
endif
NS_IMETHODIMP
nsThread
:
:
ProcessNextEvent
(
bool
aMayWait
bool
*
aResult
)
{
LOG
(
(
"
THRD
(
%
p
)
ProcessNextEvent
[
%
u
%
u
]
\
n
"
this
aMayWait
mNestedEventLoopDepth
)
)
;
if
(
NS_WARN_IF
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
bool
reallyWait
=
aMayWait
&
&
(
mNestedEventLoopDepth
>
0
|
|
!
ShuttingDown
(
)
)
;
Maybe
<
Scheduler
:
:
EventLoopActivation
>
activation
;
if
(
mIsMainThread
=
=
MAIN_THREAD
)
{
DoMainThreadSpecificProcessing
(
reallyWait
)
;
activation
.
emplace
(
)
;
}
+
+
mNestedEventLoopDepth
;
Maybe
<
dom
:
:
AutoNoJSAPI
>
noJSAPI
;
bool
callScriptObserver
=
!
!
mScriptObserver
;
if
(
callScriptObserver
)
{
noJSAPI
.
emplace
(
)
;
mScriptObserver
-
>
BeforeProcessTask
(
reallyWait
)
;
}
nsCOMPtr
<
nsIThreadObserver
>
obs
=
mEvents
-
>
GetObserverOnThread
(
)
;
if
(
obs
)
{
obs
-
>
OnProcessNextEvent
(
this
reallyWait
)
;
}
NOTIFY_EVENT_OBSERVERS
(
EventQueue
(
)
-
>
EventObservers
(
)
OnProcessNextEvent
(
this
reallyWait
)
)
;
#
ifdef
MOZ_CANARY
Canary
canary
;
#
endif
nsresult
rv
=
NS_OK
;
{
EventPriority
priority
;
nsCOMPtr
<
nsIRunnable
>
event
=
mEvents
-
>
GetEvent
(
reallyWait
&
priority
)
;
if
(
activation
.
isSome
(
)
)
{
activation
.
ref
(
)
.
SetEvent
(
event
priority
)
;
}
*
aResult
=
(
event
.
get
(
)
!
=
nullptr
)
;
if
(
event
)
{
LOG
(
(
"
THRD
(
%
p
)
running
[
%
p
]
\
n
"
this
event
.
get
(
)
)
)
;
if
(
MAIN_THREAD
=
=
mIsMainThread
)
{
HangMonitor
:
:
NotifyActivity
(
)
;
}
#
ifndef
RELEASE_OR_BETA
Maybe
<
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
MAIN_THREAD_RUNNABLE_MS
>
>
timer
;
Maybe
<
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
IDLE_RUNNABLE_BUDGET_OVERUSE_MS
>
>
idleTimer
;
nsAutoCString
name
;
if
(
(
MAIN_THREAD
=
=
mIsMainThread
)
|
|
mNextIdleDeadline
)
{
bool
labeled
=
GetLabeledRunnableName
(
event
name
)
;
if
(
MAIN_THREAD
=
=
mIsMainThread
)
{
timer
.
emplace
(
name
)
;
if
(
!
labeled
&
&
priority
=
=
EventPriority
:
:
Normal
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
double
diff
=
(
now
-
mLastUnlabeledRunnable
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
TIME_BETWEEN_UNLABELED_RUNNABLES_MS
diff
)
;
mLastUnlabeledRunnable
=
now
;
}
}
if
(
mNextIdleDeadline
)
{
idleTimer
.
emplace
(
name
mNextIdleDeadline
)
;
}
}
Array
<
char
kRunnableNameBufSize
>
restoreRunnableName
;
restoreRunnableName
[
0
]
=
'
\
0
'
;
auto
clear
=
MakeScopeExit
(
[
&
]
{
if
(
MAIN_THREAD
=
=
mIsMainThread
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sMainThreadRunnableName
=
restoreRunnableName
;
}
}
)
;
if
(
MAIN_THREAD
=
=
mIsMainThread
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
restoreRunnableName
=
sMainThreadRunnableName
;
uint32_t
length
=
std
:
:
min
(
(
uint32_t
)
kRunnableNameBufSize
-
1
(
uint32_t
)
name
.
Length
(
)
)
;
memcpy
(
sMainThreadRunnableName
.
begin
(
)
name
.
BeginReading
(
)
length
)
;
sMainThreadRunnableName
[
length
]
=
'
\
0
'
;
}
#
endif
Maybe
<
AutoTimeDurationHelper
>
timeDurationHelper
;
if
(
priority
=
=
EventPriority
:
:
Input
)
{
timeDurationHelper
.
emplace
(
)
;
}
event
-
>
Run
(
)
;
}
else
if
(
aMayWait
)
{
MOZ_ASSERT
(
ShuttingDown
(
)
"
This
should
only
happen
when
shutting
down
"
)
;
rv
=
NS_ERROR_UNEXPECTED
;
}
}
NOTIFY_EVENT_OBSERVERS
(
EventQueue
(
)
-
>
EventObservers
(
)
AfterProcessNextEvent
(
this
*
aResult
)
)
;
if
(
obs
)
{
obs
-
>
AfterProcessNextEvent
(
this
*
aResult
)
;
}
if
(
callScriptObserver
)
{
if
(
mScriptObserver
)
{
mScriptObserver
-
>
AfterProcessTask
(
mNestedEventLoopDepth
)
;
}
noJSAPI
.
reset
(
)
;
}
-
-
mNestedEventLoopDepth
;
return
rv
;
}
NS_IMETHODIMP
nsThread
:
:
GetPriority
(
int32_t
*
aPriority
)
{
*
aPriority
=
mPriority
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
SetPriority
(
int32_t
aPriority
)
{
if
(
NS_WARN_IF
(
!
mThread
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mPriority
=
aPriority
;
PRThreadPriority
pri
;
if
(
mPriority
<
=
PRIORITY_HIGHEST
)
{
pri
=
PR_PRIORITY_URGENT
;
}
else
if
(
mPriority
<
PRIORITY_NORMAL
)
{
pri
=
PR_PRIORITY_HIGH
;
}
else
if
(
mPriority
>
PRIORITY_NORMAL
)
{
pri
=
PR_PRIORITY_LOW
;
}
else
{
pri
=
PR_PRIORITY_NORMAL
;
}
if
(
!
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
ThreadScheduling
)
)
{
PR_SetThreadPriority
(
mThread
pri
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
AdjustPriority
(
int32_t
aDelta
)
{
return
SetPriority
(
mPriority
+
aDelta
)
;
}
NS_IMETHODIMP
nsThread
:
:
GetObserver
(
nsIThreadObserver
*
*
aObs
)
{
nsCOMPtr
<
nsIThreadObserver
>
obs
=
mEvents
-
>
GetObserver
(
)
;
obs
.
forget
(
aObs
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
SetObserver
(
nsIThreadObserver
*
aObs
)
{
if
(
NS_WARN_IF
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
mEvents
-
>
SetObserver
(
aObs
)
;
return
NS_OK
;
}
uint32_t
nsThread
:
:
RecursionDepth
(
)
const
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
mThread
)
;
return
mNestedEventLoopDepth
;
}
NS_IMETHODIMP
nsThread
:
:
AddObserver
(
nsIThreadObserver
*
aObserver
)
{
if
(
NS_WARN_IF
(
!
aObserver
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
EventQueue
(
)
-
>
AddObserver
(
aObserver
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThread
:
:
RemoveObserver
(
nsIThreadObserver
*
aObserver
)
{
if
(
NS_WARN_IF
(
PR_GetCurrentThread
(
)
!
=
mThread
)
)
{
return
NS_ERROR_NOT_SAME_THREAD
;
}
EventQueue
(
)
-
>
RemoveObserver
(
aObserver
)
;
return
NS_OK
;
}
void
nsThread
:
:
SetScriptObserver
(
mozilla
:
:
CycleCollectedJSContext
*
aScriptObserver
)
{
if
(
!
aScriptObserver
)
{
mScriptObserver
=
nullptr
;
return
;
}
MOZ_ASSERT
(
!
mScriptObserver
)
;
mScriptObserver
=
aScriptObserver
;
}
void
nsThread
:
:
DoMainThreadSpecificProcessing
(
bool
aReallyWait
)
{
MOZ_ASSERT
(
mIsMainThread
=
=
MAIN_THREAD
)
;
ipc
:
:
CancelCPOWs
(
)
;
if
(
aReallyWait
)
{
HangMonitor
:
:
Suspend
(
)
;
}
if
(
!
ShuttingDown
(
)
)
{
MemoryPressureState
mpPending
=
NS_GetPendingMemoryPressure
(
)
;
if
(
mpPending
!
=
MemPressure_None
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
memory
-
pressure
"
mpPending
=
=
MemPressure_New
?
u
"
low
-
memory
-
no
-
forward
"
:
u
"
low
-
memory
-
ongoing
-
no
-
forward
"
)
;
}
else
{
NS_WARNING
(
"
Can
'
t
get
observer
service
!
"
)
;
}
}
}
#
ifdef
MOZ_CRASHREPORTER
if
(
!
ShuttingDown
(
)
)
{
SaveMemoryReportNearOOM
(
ShouldSaveMemoryReport
:
:
kMaybeReport
)
;
}
#
endif
}
NS_IMETHODIMP
nsThread
:
:
GetEventTarget
(
nsIEventTarget
*
*
aEventTarget
)
{
nsCOMPtr
<
nsIEventTarget
>
target
=
this
;
target
.
forget
(
aEventTarget
)
;
return
NS_OK
;
}
nsIEventTarget
*
nsThread
:
:
EventTarget
(
)
{
return
this
;
}
nsISerialEventTarget
*
nsThread
:
:
SerialEventTarget
(
)
{
return
this
;
}
