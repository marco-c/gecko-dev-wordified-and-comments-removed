#
include
"
nsISupports
.
idl
"
[
ptr
]
native
PRThread
(
PRThread
)
;
native
ThreadCreationOptions
(
nsIThreadManager
:
:
ThreadCreationOptions
)
;
interface
nsIEventTarget
;
interface
nsIRunnable
;
interface
nsIThread
;
%
{
C
+
+
#
include
"
mozilla
/
Maybe
.
h
"
%
}
[
scriptable
function
uuid
(
039a227d
-
0cb7
-
44a5
-
a8f9
-
dbb7071979f2
)
]
interface
nsINestedEventLoopCondition
:
nsISupports
{
boolean
isDone
(
)
;
}
;
[
scriptable
builtinclass
uuid
(
1be89eca
-
e2f7
-
453b
-
8d38
-
c11ba247f6f3
)
]
interface
nsIThreadManager
:
nsISupports
{
%
{
C
+
+
#
if
defined
(
MOZ_ASAN
)
|
|
defined
(
MOZ_TSAN
)
|
|
!
defined
(
__OPTIMIZE__
)
static
constexpr
uint32_t
DEFAULT_STACK_SIZE
=
0
;
#
else
static
constexpr
uint32_t
DEFAULT_STACK_SIZE
=
256
*
1024
;
#
endif
static
const
uint32_t
kThreadPoolStackSize
=
DEFAULT_STACK_SIZE
;
struct
ThreadCreationOptions
{
uint32_t
stackSize
=
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
;
bool
blockDispatch
=
false
;
bool
isUiThread
=
false
;
mozilla
:
:
Maybe
<
uint32_t
>
longTaskLength
;
}
;
%
}
[
noscript
]
nsIThread
newNamedThread
(
in
ACString
name
in
ThreadCreationOptions
options
)
;
readonly
attribute
nsIThread
mainThread
;
readonly
attribute
nsIThread
currentThread
;
[
optional_argc
]
void
dispatchToMainThread
(
in
nsIRunnable
event
[
optional
]
in
uint32_t
priority
)
;
[
optional_argc
]
void
dispatchToMainThreadWithMicroTask
(
in
nsIRunnable
event
[
optional
]
in
uint32_t
priority
)
;
void
idleDispatchToMainThread
(
in
nsIRunnable
event
[
optional
]
in
uint32_t
timeout
)
;
void
dispatchDirectTaskToCurrentThread
(
in
nsIRunnable
event
)
;
void
spinEventLoopUntil
(
in
ACString
aVeryGoodReasonToDoThis
in
nsINestedEventLoopCondition
condition
)
;
void
spinEventLoopUntilOrQuit
(
in
ACString
aVeryGoodReasonToDoThis
in
nsINestedEventLoopCondition
condition
)
;
void
spinEventLoopUntilEmpty
(
)
;
readonly
attribute
nsIEventTarget
mainThreadEventTarget
;
}
;
