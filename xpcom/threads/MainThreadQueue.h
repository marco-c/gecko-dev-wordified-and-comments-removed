#
ifndef
mozilla_MainThreadQueue_h
#
define
mozilla_MainThreadQueue_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
PrioritizedEventQueue
.
h
"
namespace
mozilla
{
template
<
typename
SynchronizedQueueT
typename
InnerQueueT
>
inline
already_AddRefed
<
nsThread
>
CreateMainThread
(
nsIIdlePeriod
*
aIdlePeriod
SynchronizedQueueT
*
*
aSynchronizedQueue
=
nullptr
)
{
using
MainThreadQueueT
=
PrioritizedEventQueue
<
InnerQueueT
>
;
auto
queue
=
MakeUnique
<
MainThreadQueueT
>
(
MakeUnique
<
InnerQueueT
>
(
EventQueuePriority
:
:
High
)
MakeUnique
<
InnerQueueT
>
(
EventQueuePriority
:
:
Input
)
MakeUnique
<
InnerQueueT
>
(
EventQueuePriority
:
:
Normal
)
MakeUnique
<
InnerQueueT
>
(
EventQueuePriority
:
:
DeferredTimers
)
MakeUnique
<
InnerQueueT
>
(
EventQueuePriority
:
:
Idle
)
do_AddRef
(
aIdlePeriod
)
)
;
MainThreadQueueT
*
prioritized
=
queue
.
get
(
)
;
RefPtr
<
SynchronizedQueueT
>
synchronizedQueue
=
new
SynchronizedQueueT
(
std
:
:
move
(
queue
)
)
;
prioritized
-
>
SetMutexRef
(
synchronizedQueue
-
>
MutexRef
(
)
)
;
RefPtr
<
nsThread
>
mainThread
=
new
nsThread
(
WrapNotNull
(
synchronizedQueue
)
nsThread
:
:
MAIN_THREAD
0
)
;
#
ifndef
RELEASE_OR_BETA
prioritized
-
>
SetNextIdleDeadlineRef
(
mainThread
-
>
NextIdleDeadlineRef
(
)
)
;
#
endif
if
(
aSynchronizedQueue
)
{
synchronizedQueue
.
forget
(
aSynchronizedQueue
)
;
}
return
mainThread
.
forget
(
)
;
}
}
#
endif
