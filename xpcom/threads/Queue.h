#
ifndef
mozilla_Queue_h
#
define
mozilla_Queue_h
#
include
<
utility
>
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
namespace
mozilla
{
template
<
class
T
size_t
RequestedItemsPerPage
=
256
>
class
Queue
{
public
:
Queue
(
)
=
default
;
Queue
(
Queue
&
&
aOther
)
noexcept
:
mHead
(
std
:
:
exchange
(
aOther
.
mHead
nullptr
)
)
mTail
(
std
:
:
exchange
(
aOther
.
mTail
nullptr
)
)
mOffsetHead
(
std
:
:
exchange
(
aOther
.
mOffsetHead
0
)
)
mHeadLength
(
std
:
:
exchange
(
aOther
.
mHeadLength
0
)
)
mTailLength
(
std
:
:
exchange
(
aOther
.
mTailLength
0
)
)
{
}
Queue
&
operator
=
(
Queue
&
&
aOther
)
noexcept
{
Clear
(
)
;
mHead
=
std
:
:
exchange
(
aOther
.
mHead
nullptr
)
;
mTail
=
std
:
:
exchange
(
aOther
.
mTail
nullptr
)
;
mOffsetHead
=
std
:
:
exchange
(
aOther
.
mOffsetHead
0
)
;
mHeadLength
=
std
:
:
exchange
(
aOther
.
mHeadLength
0
)
;
mTailLength
=
std
:
:
exchange
(
aOther
.
mTailLength
0
)
;
return
*
this
;
}
~
Queue
(
)
{
Clear
(
)
;
}
void
Clear
(
)
{
while
(
!
IsEmpty
(
)
)
{
Pop
(
)
;
}
if
(
mHead
)
{
free
(
mHead
)
;
mHead
=
nullptr
;
}
}
T
&
Push
(
T
&
&
aElement
)
{
#
if
defined
(
EXTRA_ASSERTS
)
&
&
DEBUG
size_t
original_length
=
Count
(
)
;
#
endif
if
(
!
mHead
)
{
mHead
=
NewPage
(
)
;
MOZ_ASSERT
(
mHead
)
;
mTail
=
mHead
;
T
*
eltPtr
=
&
mTail
-
>
mEvents
[
0
]
;
new
(
eltPtr
)
T
(
std
:
:
move
(
aElement
)
)
;
mOffsetHead
=
0
;
mHeadLength
=
1
;
#
ifdef
EXTRA_ASSERTS
MOZ_ASSERT
(
Count
(
)
=
=
original_length
+
1
)
;
#
endif
return
*
eltPtr
;
}
if
(
(
mHead
=
=
mTail
&
&
mHeadLength
=
=
ItemsPerPage
)
|
|
(
mHead
!
=
mTail
&
&
mTailLength
=
=
ItemsPerPage
)
)
{
Page
*
page
=
NewPage
(
)
;
MOZ_ASSERT
(
page
)
;
mTail
-
>
mNext
=
page
;
mTail
=
page
;
T
*
eltPtr
=
&
page
-
>
mEvents
[
0
]
;
new
(
eltPtr
)
T
(
std
:
:
move
(
aElement
)
)
;
mTailLength
=
1
;
#
ifdef
EXTRA_ASSERTS
MOZ_ASSERT
(
Count
(
)
=
=
original_length
+
1
)
;
#
endif
return
*
eltPtr
;
}
if
(
mHead
=
=
mTail
)
{
uint16_t
offset
=
(
mOffsetHead
+
mHeadLength
+
+
)
%
ItemsPerPage
;
T
*
eltPtr
=
&
mTail
-
>
mEvents
[
offset
]
;
new
(
eltPtr
)
T
(
std
:
:
move
(
aElement
)
)
;
#
ifdef
EXTRA_ASSERTS
MOZ_ASSERT
(
Count
(
)
=
=
original_length
+
1
)
;
#
endif
return
*
eltPtr
;
}
T
*
eltPtr
=
&
mTail
-
>
mEvents
[
mTailLength
+
+
]
;
new
(
eltPtr
)
T
(
std
:
:
move
(
aElement
)
)
;
#
ifdef
EXTRA_ASSERTS
MOZ_ASSERT
(
Count
(
)
=
=
original_length
+
1
)
;
#
endif
return
*
eltPtr
;
}
bool
IsEmpty
(
)
const
{
return
!
mHead
|
|
(
mHead
=
=
mTail
&
&
mHeadLength
=
=
0
)
;
}
T
Pop
(
)
{
#
if
defined
(
EXTRA_ASSERTS
)
&
&
DEBUG
size_t
original_length
=
Count
(
)
;
#
endif
MOZ_ASSERT
(
!
IsEmpty
(
)
)
;
T
result
=
std
:
:
move
(
mHead
-
>
mEvents
[
mOffsetHead
]
)
;
mHead
-
>
mEvents
[
mOffsetHead
]
.
~
T
(
)
;
mOffsetHead
=
(
mOffsetHead
+
1
)
%
ItemsPerPage
;
mHeadLength
-
=
1
;
if
(
mHead
!
=
mTail
&
&
mHeadLength
=
=
0
)
{
Page
*
dead
=
mHead
;
mHead
=
mHead
-
>
mNext
;
free
(
dead
)
;
mOffsetHead
=
0
;
if
(
mHead
!
=
mTail
)
{
mHeadLength
=
ItemsPerPage
;
}
else
{
mHeadLength
=
mTailLength
;
mTailLength
=
0
;
}
}
#
ifdef
EXTRA_ASSERTS
MOZ_ASSERT
(
Count
(
)
=
=
original_length
-
1
)
;
#
endif
return
result
;
}
T
&
FirstElement
(
)
{
MOZ_ASSERT
(
!
IsEmpty
(
)
)
;
return
mHead
-
>
mEvents
[
mOffsetHead
]
;
}
const
T
&
FirstElement
(
)
const
{
MOZ_ASSERT
(
!
IsEmpty
(
)
)
;
return
mHead
-
>
mEvents
[
mOffsetHead
]
;
}
T
&
LastElement
(
)
{
MOZ_ASSERT
(
!
IsEmpty
(
)
)
;
uint16_t
offset
=
mHead
=
=
mTail
?
mOffsetHead
+
mHeadLength
-
1
:
mTailLength
-
1
;
return
mTail
-
>
mEvents
[
offset
]
;
}
const
T
&
LastElement
(
)
const
{
MOZ_ASSERT
(
!
IsEmpty
(
)
)
;
uint16_t
offset
=
mHead
=
=
mTail
?
mOffsetHead
+
mHeadLength
-
1
:
mTailLength
-
1
;
return
mTail
-
>
mEvents
[
offset
]
;
}
size_t
Count
(
)
const
{
if
(
!
mHead
)
{
return
0
;
}
int
count
=
0
;
for
(
Page
*
page
=
mHead
;
page
!
=
mTail
&
&
page
-
>
mNext
!
=
mTail
;
page
=
page
-
>
mNext
)
{
count
+
=
ItemsPerPage
;
}
count
+
=
mHeadLength
+
mTailLength
;
MOZ_ASSERT
(
count
>
=
0
)
;
return
count
;
}
size_t
ShallowSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
if
(
mHead
)
{
for
(
Page
*
page
=
mHead
;
page
!
=
mTail
;
page
=
page
-
>
mNext
)
{
n
+
=
aMallocSizeOf
(
page
)
;
}
}
return
n
;
}
size_t
ShallowSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
private
:
static_assert
(
(
RequestedItemsPerPage
&
(
RequestedItemsPerPage
-
1
)
)
=
=
0
"
RequestedItemsPerPage
should
be
a
power
of
two
to
avoid
heap
slop
.
"
)
;
static
const
size_t
ItemsPerPage
=
RequestedItemsPerPage
-
1
;
struct
Page
{
struct
Page
*
mNext
;
T
mEvents
[
ItemsPerPage
]
;
}
;
static
Page
*
NewPage
(
)
{
return
static_cast
<
Page
*
>
(
moz_xcalloc
(
1
sizeof
(
Page
)
)
)
;
}
Page
*
mHead
=
nullptr
;
Page
*
mTail
=
nullptr
;
uint16_t
mOffsetHead
=
0
;
uint16_t
mHeadLength
=
0
;
uint16_t
mTailLength
=
0
;
}
;
}
#
endif
