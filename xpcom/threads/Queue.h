#
ifndef
mozilla_Queue_h
#
define
mozilla_Queue_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
namespace
mozilla
{
template
<
class
T
size_t
RequestedItemsPerPage
=
256
>
class
Queue
{
public
:
Queue
(
)
{
}
~
Queue
(
)
{
MOZ_ASSERT
(
IsEmpty
(
)
)
;
if
(
mHead
)
{
free
(
mHead
)
;
}
}
T
&
Push
(
T
&
&
aElement
)
{
if
(
!
mHead
)
{
mHead
=
NewPage
(
)
;
MOZ_ASSERT
(
mHead
)
;
mTail
=
mHead
;
mOffsetHead
=
0
;
mOffsetTail
=
0
;
}
else
if
(
mOffsetTail
=
=
ItemsPerPage
)
{
Page
*
page
=
NewPage
(
)
;
MOZ_ASSERT
(
page
)
;
mTail
-
>
mNext
=
page
;
mTail
=
page
;
mOffsetTail
=
0
;
}
T
&
eltLocation
=
mTail
-
>
mEvents
[
mOffsetTail
]
;
eltLocation
=
std
:
:
move
(
aElement
)
;
+
+
mOffsetTail
;
return
eltLocation
;
}
bool
IsEmpty
(
)
const
{
return
!
mHead
|
|
(
mHead
=
=
mTail
&
&
mOffsetHead
=
=
mOffsetTail
)
;
}
T
Pop
(
)
{
MOZ_ASSERT
(
!
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mOffsetHead
<
ItemsPerPage
)
;
MOZ_ASSERT_IF
(
mHead
=
=
mTail
mOffsetHead
<
=
mOffsetTail
)
;
T
result
=
std
:
:
move
(
mHead
-
>
mEvents
[
mOffsetHead
+
+
]
)
;
MOZ_ASSERT
(
mOffsetHead
<
=
ItemsPerPage
)
;
if
(
mOffsetHead
=
=
ItemsPerPage
)
{
Page
*
dead
=
mHead
;
mHead
=
mHead
-
>
mNext
;
free
(
dead
)
;
mOffsetHead
=
0
;
}
return
result
;
}
void
FirstElementAssertions
(
)
const
{
MOZ_ASSERT
(
!
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mOffsetHead
<
ItemsPerPage
)
;
MOZ_ASSERT_IF
(
mHead
=
=
mTail
mOffsetHead
<
=
mOffsetTail
)
;
}
T
&
FirstElement
(
)
{
FirstElementAssertions
(
)
;
return
mHead
-
>
mEvents
[
mOffsetHead
]
;
}
const
T
&
FirstElement
(
)
const
{
FirstElementAssertions
(
)
;
return
mHead
-
>
mEvents
[
mOffsetHead
]
;
}
void
LastElementAssertions
(
)
const
{
MOZ_ASSERT
(
!
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mOffsetTail
>
0
)
;
MOZ_ASSERT
(
mOffsetTail
<
=
ItemsPerPage
)
;
MOZ_ASSERT_IF
(
mHead
=
=
mTail
mOffsetHead
<
=
mOffsetTail
)
;
}
T
&
LastElement
(
)
{
LastElementAssertions
(
)
;
return
mTail
-
>
mEvents
[
mOffsetTail
-
1
]
;
}
const
T
&
LastElement
(
)
const
{
LastElementAssertions
(
)
;
return
mTail
-
>
mEvents
[
mOffsetTail
-
1
]
;
}
size_t
Count
(
)
const
{
if
(
!
mHead
)
{
return
0
;
}
int
count
=
-
mOffsetHead
;
for
(
Page
*
page
=
mHead
;
page
!
=
mTail
;
page
=
page
-
>
mNext
)
{
count
+
=
ItemsPerPage
;
}
count
+
=
mOffsetTail
;
MOZ_ASSERT
(
count
>
=
0
)
;
return
count
;
}
size_t
ShallowSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
if
(
mHead
)
{
for
(
Page
*
page
=
mHead
;
page
!
=
mTail
;
page
=
page
-
>
mNext
)
{
n
+
=
aMallocSizeOf
(
page
)
;
}
}
return
n
;
}
size_t
ShallowSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
private
:
static_assert
(
(
RequestedItemsPerPage
&
(
RequestedItemsPerPage
-
1
)
)
=
=
0
"
RequestedItemsPerPage
should
be
a
power
of
two
to
avoid
heap
slop
.
"
)
;
static
const
size_t
ItemsPerPage
=
RequestedItemsPerPage
-
1
;
struct
Page
{
struct
Page
*
mNext
;
T
mEvents
[
ItemsPerPage
]
;
}
;
static
Page
*
NewPage
(
)
{
return
static_cast
<
Page
*
>
(
moz_xcalloc
(
1
sizeof
(
Page
)
)
)
;
}
Page
*
mHead
=
nullptr
;
Page
*
mTail
=
nullptr
;
uint16_t
mOffsetHead
=
0
;
uint16_t
mOffsetTail
=
0
;
}
;
}
#
endif
