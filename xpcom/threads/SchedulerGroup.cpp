#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
<
utility
>
#
include
"
jsfriendapi
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
namespace
mozilla
;
namespace
{
static
Atomic
<
uint64_t
>
gEarliestUnprocessedVsync
(
0
)
;
}
nsresult
SchedulerGroup
:
:
UnlabeledDispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
if
(
NS_IsMainThread
(
)
)
{
return
NS_DispatchToCurrentThread
(
std
:
:
move
(
aRunnable
)
)
;
}
else
{
return
NS_DispatchToMainThread
(
std
:
:
move
(
aRunnable
)
)
;
}
}
void
SchedulerGroup
:
:
MarkVsyncReceived
(
)
{
TimeStamp
creation
=
TimeStamp
:
:
ProcessCreation
(
)
;
uint64_t
unprocessedVsync
=
uint64_t
(
(
TimeStamp
:
:
Now
(
)
-
creation
)
.
ToMicroseconds
(
)
)
;
gEarliestUnprocessedVsync
.
compareExchange
(
0
unprocessedVsync
)
;
}
void
SchedulerGroup
:
:
MarkVsyncRan
(
)
{
gEarliestUnprocessedVsync
=
0
;
}
SchedulerGroup
:
:
SchedulerGroup
(
)
:
mIsRunning
(
false
)
{
}
nsresult
SchedulerGroup
:
:
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
return
LabeledDispatch
(
aCategory
std
:
:
move
(
aRunnable
)
nullptr
)
;
}
nsresult
SchedulerGroup
:
:
LabeledDispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
mozilla
:
:
PerformanceCounter
*
aPerformanceCounter
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
if
(
XRE_IsContentProcess
(
)
)
{
RefPtr
<
Runnable
>
internalRunnable
=
new
Runnable
(
runnable
.
forget
(
)
aPerformanceCounter
)
;
return
InternalUnlabeledDispatch
(
aCategory
internalRunnable
.
forget
(
)
)
;
}
return
UnlabeledDispatch
(
aCategory
runnable
.
forget
(
)
)
;
}
nsresult
SchedulerGroup
:
:
InternalUnlabeledDispatch
(
TaskCategory
aCategory
already_AddRefed
<
Runnable
>
&
&
aRunnable
)
{
if
(
NS_IsMainThread
(
)
)
{
return
NS_DispatchToCurrentThread
(
std
:
:
move
(
aRunnable
)
)
;
}
RefPtr
<
Runnable
>
runnable
(
aRunnable
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
do_AddRef
(
runnable
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
Unused
<
<
runnable
-
>
mRunnable
.
forget
(
)
.
take
(
)
;
nsrefcnt
refcnt
=
runnable
.
get
(
)
-
>
Release
(
)
;
MOZ_RELEASE_ASSERT
(
refcnt
=
=
1
"
still
holding
an
unexpected
reference
!
"
)
;
}
return
rv
;
}
SchedulerGroup
:
:
Runnable
:
:
Runnable
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
mozilla
:
:
PerformanceCounter
*
aPerformanceCounter
)
:
mozilla
:
:
Runnable
(
"
SchedulerGroup
:
:
Runnable
"
)
mRunnable
(
std
:
:
move
(
aRunnable
)
)
mPerformanceCounter
(
aPerformanceCounter
)
{
}
mozilla
:
:
PerformanceCounter
*
SchedulerGroup
:
:
Runnable
:
:
GetPerformanceCounter
(
)
const
{
return
mPerformanceCounter
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
NS_IMETHODIMP
SchedulerGroup
:
:
Runnable
:
:
GetName
(
nsACString
&
aName
)
{
nsCOMPtr
<
nsINamed
>
named
=
do_QueryInterface
(
mRunnable
)
;
if
(
named
)
{
named
-
>
GetName
(
aName
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
aName
.
AssignLiteral
(
"
anonymous
"
)
;
}
return
NS_OK
;
}
#
endif
NS_IMETHODIMP
SchedulerGroup
:
:
Runnable
:
:
Run
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
(
std
:
:
move
(
mRunnable
)
)
;
return
runnable
-
>
Run
(
)
;
}
NS_IMETHODIMP
SchedulerGroup
:
:
Runnable
:
:
GetPriority
(
uint32_t
*
aPriority
)
{
*
aPriority
=
nsIRunnablePriority
:
:
PRIORITY_NORMAL
;
nsCOMPtr
<
nsIRunnablePriority
>
runnablePrio
=
do_QueryInterface
(
mRunnable
)
;
return
runnablePrio
?
runnablePrio
-
>
GetPriority
(
aPriority
)
:
NS_OK
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
SchedulerGroup
:
:
Runnable
mozilla
:
:
Runnable
nsIRunnablePriority
SchedulerGroup
:
:
Runnable
)
