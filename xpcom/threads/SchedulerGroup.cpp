#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
<
utility
>
#
include
"
jsfriendapi
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
namespace
mozilla
;
namespace
{
#
define
NS_DISPATCHEREVENTTARGET_IID
\
{
\
0xbf4e36c8
0x7d04
0x4ef4
{
\
0xbb
0xd8
0x11
0x09
0x0a
0xdb
0x4d
0xf7
\
}
\
}
class
SchedulerEventTarget
final
:
public
nsISerialEventTarget
{
RefPtr
<
SchedulerGroup
>
mDispatcher
;
TaskCategory
mCategory
;
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_DISPATCHEREVENTTARGET_IID
)
SchedulerEventTarget
(
SchedulerGroup
*
aDispatcher
TaskCategory
aCategory
)
:
mDispatcher
(
aDispatcher
)
mCategory
(
aCategory
)
{
}
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIEVENTTARGET_FULL
SchedulerGroup
*
Dispatcher
(
)
const
{
return
mDispatcher
;
}
private
:
~
SchedulerEventTarget
(
)
=
default
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
SchedulerEventTarget
NS_DISPATCHEREVENTTARGET_IID
)
static
Atomic
<
uint64_t
>
gEarliestUnprocessedVsync
(
0
)
;
}
NS_IMPL_ISUPPORTS
(
SchedulerEventTarget
SchedulerEventTarget
nsIEventTarget
nsISerialEventTarget
)
NS_IMETHODIMP
SchedulerEventTarget
:
:
DispatchFromScript
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
)
{
return
Dispatch
(
do_AddRef
(
aRunnable
)
aFlags
)
;
}
NS_IMETHODIMP
SchedulerEventTarget
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aFlags
)
{
if
(
NS_WARN_IF
(
aFlags
!
=
NS_DISPATCH_NORMAL
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
mDispatcher
-
>
Dispatch
(
mCategory
std
:
:
move
(
aRunnable
)
)
;
}
NS_IMETHODIMP
SchedulerEventTarget
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
uint32_t
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
SchedulerEventTarget
:
:
IsOnCurrentThread
(
bool
*
aIsOnCurrentThread
)
{
*
aIsOnCurrentThread
=
NS_IsMainThread
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
bool
)
SchedulerEventTarget
:
:
IsOnCurrentThreadInfallible
(
)
{
return
NS_IsMainThread
(
)
;
}
nsresult
SchedulerGroup
:
:
UnlabeledDispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
if
(
NS_IsMainThread
(
)
)
{
return
NS_DispatchToCurrentThread
(
std
:
:
move
(
aRunnable
)
)
;
}
else
{
return
NS_DispatchToMainThread
(
std
:
:
move
(
aRunnable
)
)
;
}
}
void
SchedulerGroup
:
:
MarkVsyncReceived
(
)
{
if
(
gEarliestUnprocessedVsync
)
{
return
;
}
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
bool
inconsistent
=
false
;
TimeStamp
creation
=
TimeStamp
:
:
ProcessCreation
(
&
inconsistent
)
;
if
(
inconsistent
)
{
return
;
}
gEarliestUnprocessedVsync
=
(
TimeStamp
:
:
Now
(
)
-
creation
)
.
ToMicroseconds
(
)
;
}
void
SchedulerGroup
:
:
MarkVsyncRan
(
)
{
gEarliestUnprocessedVsync
=
0
;
}
SchedulerGroup
:
:
SchedulerGroup
(
)
:
mIsRunning
(
false
)
{
}
nsresult
SchedulerGroup
:
:
DispatchWithDocGroup
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
dom
:
:
DocGroup
*
aDocGroup
)
{
return
LabeledDispatch
(
aCategory
std
:
:
move
(
aRunnable
)
aDocGroup
)
;
}
nsresult
SchedulerGroup
:
:
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
return
LabeledDispatch
(
aCategory
std
:
:
move
(
aRunnable
)
nullptr
)
;
}
nsISerialEventTarget
*
SchedulerGroup
:
:
EventTargetFor
(
TaskCategory
aCategory
)
const
{
MOZ_ASSERT
(
aCategory
!
=
TaskCategory
:
:
Count
)
;
MOZ_ASSERT
(
mEventTargets
[
size_t
(
aCategory
)
]
)
;
return
mEventTargets
[
size_t
(
aCategory
)
]
;
}
AbstractThread
*
SchedulerGroup
:
:
AbstractMainThreadFor
(
TaskCategory
aCategory
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
return
AbstractMainThreadForImpl
(
aCategory
)
;
}
AbstractThread
*
SchedulerGroup
:
:
AbstractMainThreadForImpl
(
TaskCategory
aCategory
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aCategory
!
=
TaskCategory
:
:
Count
)
;
MOZ_ASSERT
(
mEventTargets
[
size_t
(
aCategory
)
]
)
;
if
(
!
mAbstractThreads
[
size_t
(
aCategory
)
]
)
{
mAbstractThreads
[
size_t
(
aCategory
)
]
=
AbstractThread
:
:
CreateEventTargetWrapper
(
mEventTargets
[
size_t
(
aCategory
)
]
true
)
;
}
return
mAbstractThreads
[
size_t
(
aCategory
)
]
;
}
void
SchedulerGroup
:
:
CreateEventTargets
(
bool
aNeedValidation
)
{
for
(
size_t
i
=
0
;
i
<
size_t
(
TaskCategory
:
:
Count
)
;
i
+
+
)
{
TaskCategory
category
=
static_cast
<
TaskCategory
>
(
i
)
;
if
(
!
aNeedValidation
)
{
mEventTargets
[
i
]
=
GetMainThreadSerialEventTarget
(
)
;
}
else
{
mEventTargets
[
i
]
=
CreateEventTargetFor
(
category
)
;
}
}
}
void
SchedulerGroup
:
:
Shutdown
(
bool
aXPCOMShutdown
)
{
for
(
size_t
i
=
0
;
i
<
size_t
(
TaskCategory
:
:
Count
)
;
i
+
+
)
{
mEventTargets
[
i
]
=
aXPCOMShutdown
?
nullptr
:
GetMainThreadSerialEventTarget
(
)
;
mAbstractThreads
[
i
]
=
nullptr
;
}
}
already_AddRefed
<
nsISerialEventTarget
>
SchedulerGroup
:
:
CreateEventTargetFor
(
TaskCategory
aCategory
)
{
RefPtr
<
SchedulerEventTarget
>
target
=
new
SchedulerEventTarget
(
this
aCategory
)
;
return
target
.
forget
(
)
;
}
SchedulerGroup
*
SchedulerGroup
:
:
FromEventTarget
(
nsIEventTarget
*
aEventTarget
)
{
RefPtr
<
SchedulerEventTarget
>
target
=
do_QueryObject
(
aEventTarget
)
;
if
(
!
target
)
{
return
nullptr
;
}
return
target
-
>
Dispatcher
(
)
;
}
nsresult
SchedulerGroup
:
:
LabeledDispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
dom
:
:
DocGroup
*
aDocGroup
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
if
(
XRE_IsContentProcess
(
)
)
{
RefPtr
<
Runnable
>
internalRunnable
=
new
Runnable
(
runnable
.
forget
(
)
aDocGroup
)
;
return
InternalUnlabeledDispatch
(
aCategory
internalRunnable
.
forget
(
)
)
;
}
return
UnlabeledDispatch
(
aCategory
runnable
.
forget
(
)
)
;
}
nsresult
SchedulerGroup
:
:
InternalUnlabeledDispatch
(
TaskCategory
aCategory
already_AddRefed
<
Runnable
>
&
&
aRunnable
)
{
if
(
NS_IsMainThread
(
)
)
{
return
NS_DispatchToCurrentThread
(
std
:
:
move
(
aRunnable
)
)
;
}
RefPtr
<
Runnable
>
runnable
(
aRunnable
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
do_AddRef
(
runnable
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
Unused
<
<
runnable
-
>
mRunnable
.
forget
(
)
.
take
(
)
;
nsrefcnt
refcnt
=
runnable
.
get
(
)
-
>
Release
(
)
;
MOZ_RELEASE_ASSERT
(
refcnt
=
=
1
"
still
holding
an
unexpected
reference
!
"
)
;
}
return
rv
;
}
SchedulerGroup
:
:
Runnable
:
:
Runnable
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
dom
:
:
DocGroup
*
aDocGroup
)
:
mozilla
:
:
Runnable
(
"
SchedulerGroup
:
:
Runnable
"
)
mRunnable
(
std
:
:
move
(
aRunnable
)
)
mDocGroup
(
aDocGroup
)
{
}
dom
:
:
DocGroup
*
SchedulerGroup
:
:
Runnable
:
:
DocGroup
(
)
const
{
return
mDocGroup
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
NS_IMETHODIMP
SchedulerGroup
:
:
Runnable
:
:
GetName
(
nsACString
&
aName
)
{
nsCOMPtr
<
nsINamed
>
named
=
do_QueryInterface
(
mRunnable
)
;
if
(
named
)
{
named
-
>
GetName
(
aName
)
;
}
if
(
aName
.
IsEmpty
(
)
)
{
aName
.
AssignLiteral
(
"
anonymous
"
)
;
}
return
NS_OK
;
}
#
endif
NS_IMETHODIMP
SchedulerGroup
:
:
Runnable
:
:
Run
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
(
mRunnable
.
forget
(
)
)
;
return
runnable
-
>
Run
(
)
;
}
NS_IMETHODIMP
SchedulerGroup
:
:
Runnable
:
:
GetPriority
(
uint32_t
*
aPriority
)
{
*
aPriority
=
nsIRunnablePriority
:
:
PRIORITY_NORMAL
;
nsCOMPtr
<
nsIRunnablePriority
>
runnablePrio
=
do_QueryInterface
(
mRunnable
)
;
return
runnablePrio
?
runnablePrio
-
>
GetPriority
(
aPriority
)
:
NS_OK
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
SchedulerGroup
:
:
Runnable
mozilla
:
:
Runnable
nsIRunnablePriority
SchedulerGroup
:
:
Runnable
)
