#
include
"
TaskController
.
h
"
#
include
"
nsIIdleRunnable
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
<
algorithm
>
#
include
<
initializer_list
>
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
mozilla
/
InputTaskManager
.
h
"
#
include
"
mozilla
/
VsyncTaskManager
.
h
"
#
include
"
mozilla
/
IOInterposer
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
prenv
.
h
"
#
include
"
prsystem
.
h
"
#
ifdef
XP_WIN
#
include
"
objbase
.
h
"
#
endif
#
ifdef
XP_WIN
typedef
HRESULT
(
WINAPI
*
SetThreadDescriptionPtr
)
(
HANDLE
hThread
PCWSTR
lpThreadDescription
)
;
#
endif
namespace
mozilla
{
std
:
:
unique_ptr
<
TaskController
>
TaskController
:
:
sSingleton
;
thread_local
size_t
mThreadPoolIndex
=
-
1
;
std
:
:
atomic
<
uint64_t
>
Task
:
:
sCurrentTaskSeqNo
=
0
;
const
int32_t
kMinimumPoolThreadCount
=
2
;
const
int32_t
kMaximumPoolThreadCount
=
8
;
int32_t
TaskController
:
:
GetPoolThreadCount
(
)
{
if
(
PR_GetEnv
(
"
MOZ_TASKCONTROLLER_THREADCOUNT
"
)
)
{
return
strtol
(
PR_GetEnv
(
"
MOZ_TASKCONTROLLER_THREADCOUNT
"
)
nullptr
0
)
;
}
int32_t
numCores
=
std
:
:
max
<
int32_t
>
(
1
PR_GetNumberOfProcessors
(
)
)
;
return
std
:
:
clamp
<
int32_t
>
(
numCores
kMinimumPoolThreadCount
kMaximumPoolThreadCount
)
;
}
#
if
defined
(
MOZ_COLLECTING_RUNNABLE_TELEMETRY
)
#
define
AUTO_PROFILE_FOLLOWING_TASK
(
task
)
\
nsAutoCString
name
;
\
(
task
)
-
>
GetName
(
name
)
;
\
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING_NONSENSITIVE
(
"
Task
"
OTHER
name
)
;
\
AUTO_PROFILER_MARKER_TEXT
(
"
Runnable
"
OTHER
{
}
name
)
;
#
else
#
define
AUTO_PROFILE_FOLLOWING_TASK
(
task
)
#
endif
bool
TaskManager
:
:
UpdateCachesForCurrentIterationAndReportPriorityModifierChanged
(
const
MutexAutoLock
&
aProofOfLock
IterationType
aIterationType
)
{
mCurrentSuspended
=
IsSuspended
(
aProofOfLock
)
;
if
(
aIterationType
=
=
IterationType
:
:
EVENT_LOOP_TURN
&
&
!
mCurrentSuspended
)
{
int32_t
oldModifier
=
mCurrentPriorityModifier
;
mCurrentPriorityModifier
=
GetPriorityModifierForEventLoopTurn
(
aProofOfLock
)
;
if
(
mCurrentPriorityModifier
!
=
oldModifier
)
{
return
true
;
}
}
return
false
;
}
Task
*
Task
:
:
GetHighestPriorityDependency
(
)
{
Task
*
currentTask
=
this
;
while
(
!
currentTask
-
>
mDependencies
.
empty
(
)
)
{
auto
iter
=
currentTask
-
>
mDependencies
.
begin
(
)
;
while
(
iter
!
=
currentTask
-
>
mDependencies
.
end
(
)
)
{
if
(
(
*
iter
)
-
>
mCompleted
)
{
auto
oldIter
=
iter
;
iter
+
+
;
currentTask
-
>
mDependencies
.
erase
(
oldIter
)
;
continue
;
}
currentTask
=
iter
-
>
get
(
)
;
break
;
}
}
return
currentTask
=
=
this
?
nullptr
:
currentTask
;
}
TaskController
*
TaskController
:
:
Get
(
)
{
MOZ_ASSERT
(
sSingleton
.
get
(
)
)
;
return
sSingleton
.
get
(
)
;
}
bool
TaskController
:
:
Initialize
(
)
{
MOZ_ASSERT
(
!
sSingleton
)
;
sSingleton
=
std
:
:
make_unique
<
TaskController
>
(
)
;
return
sSingleton
-
>
InitializeInternal
(
)
;
}
void
ThreadFuncPoolThread
(
void
*
aIndex
)
{
mThreadPoolIndex
=
*
reinterpret_cast
<
int32_t
*
>
(
aIndex
)
;
delete
reinterpret_cast
<
int32_t
*
>
(
aIndex
)
;
TaskController
:
:
Get
(
)
-
>
RunPoolThread
(
)
;
}
#
ifdef
XP_WIN
static
SetThreadDescriptionPtr
sSetThreadDescriptionFunc
=
nullptr
;
#
endif
bool
TaskController
:
:
InitializeInternal
(
)
{
InputTaskManager
:
:
Init
(
)
;
VsyncTaskManager
:
:
Init
(
)
;
mMTProcessingRunnable
=
NS_NewRunnableFunction
(
"
TaskController
:
:
ExecutePendingMTTasks
(
)
"
[
]
(
)
{
TaskController
:
:
Get
(
)
-
>
ProcessPendingMTTask
(
)
;
}
)
;
mMTBlockingProcessingRunnable
=
NS_NewRunnableFunction
(
"
TaskController
:
:
ExecutePendingMTTasks
(
)
"
[
]
(
)
{
TaskController
:
:
Get
(
)
-
>
ProcessPendingMTTask
(
true
)
;
}
)
;
#
ifdef
XP_WIN
sSetThreadDescriptionFunc
=
reinterpret_cast
<
SetThreadDescriptionPtr
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandle
(
L
"
Kernel32
.
dll
"
)
"
SetThreadDescription
"
)
)
;
#
endif
return
true
;
}
constexpr
PRUint32
sBaseStackSize
=
2048
*
1024
-
2
*
4096
;
#
if
defined
(
MOZ_TSAN
)
constexpr
PRUint32
sStackSize
=
2
*
sBaseStackSize
;
#
else
constexpr
PRUint32
sStackSize
=
sBaseStackSize
;
#
endif
void
TaskController
:
:
InitializeThreadPool
(
)
{
mPoolInitializationMutex
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
!
mThreadPoolInitialized
)
;
mThreadPoolInitialized
=
true
;
int32_t
poolSize
=
GetPoolThreadCount
(
)
;
for
(
int32_t
i
=
0
;
i
<
poolSize
;
i
+
+
)
{
int32_t
*
index
=
new
int32_t
(
i
)
;
mPoolThreads
.
push_back
(
{
PR_CreateThread
(
PR_USER_THREAD
ThreadFuncPoolThread
index
PR_PRIORITY_NORMAL
PR_GLOBAL_THREAD
PR_JOINABLE_THREAD
sStackSize
)
nullptr
}
)
;
}
}
size_t
TaskController
:
:
GetThreadStackSize
(
)
{
return
sStackSize
;
}
void
TaskController
:
:
SetPerformanceCounterState
(
PerformanceCounterState
*
aPerformanceCounterState
)
{
mPerformanceCounterState
=
aPerformanceCounterState
;
}
void
TaskController
:
:
Shutdown
(
)
{
InputTaskManager
:
:
Cleanup
(
)
;
VsyncTaskManager
:
:
Cleanup
(
)
;
if
(
sSingleton
)
{
sSingleton
-
>
ShutdownThreadPoolInternal
(
)
;
sSingleton
-
>
ShutdownInternal
(
)
;
}
MOZ_ASSERT
(
!
sSingleton
)
;
}
void
TaskController
:
:
ShutdownThreadPoolInternal
(
)
{
{
MutexAutoLock
lock
(
mGraphMutex
)
;
mShuttingDown
=
true
;
mThreadPoolCV
.
NotifyAll
(
)
;
}
for
(
PoolThread
&
thread
:
mPoolThreads
)
{
PR_JoinThread
(
thread
.
mThread
)
;
}
}
void
TaskController
:
:
ShutdownInternal
(
)
{
sSingleton
=
nullptr
;
}
void
TaskController
:
:
RunPoolThread
(
)
{
IOInterposer
:
:
RegisterCurrentThread
(
)
;
RefPtr
<
Task
>
lastTask
;
#
ifdef
XP_WIN
nsAutoString
threadWName
;
threadWName
.
AppendLiteral
(
u
"
TaskController
Thread
#
"
)
;
threadWName
.
AppendInt
(
static_cast
<
int64_t
>
(
mThreadPoolIndex
)
)
;
if
(
sSetThreadDescriptionFunc
)
{
sSetThreadDescriptionFunc
(
:
:
GetCurrentThread
(
)
reinterpret_cast
<
const
WCHAR
*
>
(
threadWName
.
BeginReading
(
)
)
)
;
}
:
:
CoInitializeEx
(
nullptr
COINIT_MULTITHREADED
)
;
#
endif
nsAutoCString
threadName
;
threadName
.
AppendLiteral
(
"
TaskController
Thread
#
"
)
;
threadName
.
AppendInt
(
static_cast
<
int64_t
>
(
mThreadPoolIndex
)
)
;
AUTO_PROFILER_REGISTER_THREAD
(
threadName
.
BeginReading
(
)
)
;
MutexAutoLock
lock
(
mGraphMutex
)
;
while
(
true
)
{
bool
ranTask
=
false
;
if
(
!
mThreadableTasks
.
empty
(
)
)
{
for
(
auto
iter
=
mThreadableTasks
.
begin
(
)
;
iter
!
=
mThreadableTasks
.
end
(
)
;
+
+
iter
)
{
Task
*
task
=
iter
-
>
get
(
)
;
MOZ_ASSERT
(
!
task
-
>
mTaskManager
)
;
mPoolThreads
[
mThreadPoolIndex
]
.
mEffectiveTaskPriority
=
task
-
>
GetPriority
(
)
;
Task
*
nextTask
;
while
(
(
nextTask
=
task
-
>
GetHighestPriorityDependency
(
)
)
)
{
task
=
nextTask
;
}
if
(
task
-
>
IsMainThreadOnly
(
)
|
|
task
-
>
mInProgress
)
{
continue
;
}
mPoolThreads
[
mThreadPoolIndex
]
.
mCurrentTask
=
task
;
mThreadableTasks
.
erase
(
task
-
>
mIterator
)
;
task
-
>
mIterator
=
mThreadableTasks
.
end
(
)
;
task
-
>
mInProgress
=
true
;
bool
taskCompleted
=
false
;
{
MutexAutoUnlock
unlock
(
mGraphMutex
)
;
lastTask
=
nullptr
;
AUTO_PROFILE_FOLLOWING_TASK
(
task
)
;
taskCompleted
=
task
-
>
Run
(
)
;
ranTask
=
true
;
}
task
-
>
mInProgress
=
false
;
if
(
!
taskCompleted
)
{
auto
insertion
=
mThreadableTasks
.
insert
(
mPoolThreads
[
mThreadPoolIndex
]
.
mCurrentTask
)
;
MOZ_ASSERT
(
insertion
.
second
)
;
task
-
>
mIterator
=
insertion
.
first
;
}
else
{
task
-
>
mCompleted
=
true
;
#
ifdef
DEBUG
task
-
>
mIsInGraph
=
false
;
#
endif
task
-
>
mDependencies
.
clear
(
)
;
mMayHaveMainThreadTask
=
true
;
EnsureMainThreadTasksScheduled
(
)
;
MaybeInterruptTask
(
GetHighestPriorityMTTask
(
)
)
;
}
lastTask
=
mPoolThreads
[
mThreadPoolIndex
]
.
mCurrentTask
.
forget
(
)
;
break
;
}
}
if
(
lastTask
)
{
MutexAutoUnlock
unlock
(
mGraphMutex
)
;
lastTask
=
nullptr
;
continue
;
}
if
(
!
ranTask
)
{
if
(
mShuttingDown
)
{
IOInterposer
:
:
UnregisterCurrentThread
(
)
;
MOZ_ASSERT
(
mThreadableTasks
.
empty
(
)
)
;
return
;
}
AUTO_PROFILER_LABEL
(
"
TaskController
:
:
RunPoolThread
"
IDLE
)
;
mThreadPoolCV
.
Wait
(
)
;
}
}
#
ifdef
XP_WIN
:
:
CoUninitialize
(
)
;
#
endif
}
void
TaskController
:
:
AddTask
(
already_AddRefed
<
Task
>
&
&
aTask
)
{
RefPtr
<
Task
>
task
(
aTask
)
;
if
(
!
task
-
>
IsMainThreadOnly
(
)
)
{
MutexAutoLock
lock
(
mPoolInitializationMutex
)
;
if
(
!
mThreadPoolInitialized
)
{
InitializeThreadPool
(
)
;
mThreadPoolInitialized
=
true
;
}
}
MutexAutoLock
lock
(
mGraphMutex
)
;
if
(
TaskManager
*
manager
=
task
-
>
GetManager
(
)
)
{
if
(
manager
-
>
mTaskCount
=
=
0
)
{
mTaskManagers
.
insert
(
manager
)
;
}
manager
-
>
DidQueueTask
(
)
;
task
-
>
mPriorityModifier
=
manager
-
>
mCurrentPriorityModifier
;
}
task
-
>
mInsertionTime
=
TimeStamp
:
:
Now
(
)
;
#
ifdef
DEBUG
task
-
>
mIsInGraph
=
true
;
for
(
const
RefPtr
<
Task
>
&
otherTask
:
task
-
>
mDependencies
)
{
MOZ_ASSERT
(
!
otherTask
-
>
mTaskManager
|
|
otherTask
-
>
mTaskManager
=
=
task
-
>
mTaskManager
)
;
}
#
endif
LogTask
:
:
LogDispatch
(
task
)
;
std
:
:
pair
<
std
:
:
set
<
RefPtr
<
Task
>
Task
:
:
PriorityCompare
>
:
:
iterator
bool
>
insertion
;
if
(
task
-
>
IsMainThreadOnly
(
)
)
{
insertion
=
mMainThreadTasks
.
insert
(
std
:
:
move
(
task
)
)
;
}
else
{
insertion
=
mThreadableTasks
.
insert
(
std
:
:
move
(
task
)
)
;
}
(
*
insertion
.
first
)
-
>
mIterator
=
insertion
.
first
;
MOZ_ASSERT
(
insertion
.
second
)
;
MaybeInterruptTask
(
*
insertion
.
first
)
;
}
void
TaskController
:
:
WaitForTaskOrMessage
(
)
{
MutexAutoLock
lock
(
mGraphMutex
)
;
while
(
!
mMayHaveMainThreadTask
)
{
AUTO_PROFILER_LABEL
(
"
TaskController
:
:
WaitForTaskOrMessage
"
IDLE
)
;
mMainThreadCV
.
Wait
(
)
;
}
}
void
TaskController
:
:
ExecuteNextTaskOnlyMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mGraphMutex
)
;
ExecuteNextTaskOnlyMainThreadInternal
(
lock
)
;
}
void
TaskController
:
:
ProcessPendingMTTask
(
bool
aMayWait
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mGraphMutex
)
;
for
(
;
;
)
{
mMTTaskRunnableProcessedTask
=
ExecuteNextTaskOnlyMainThreadInternal
(
lock
)
;
if
(
mMTTaskRunnableProcessedTask
|
|
!
aMayWait
)
{
break
;
}
BackgroundHangMonitor
(
)
.
NotifyWait
(
)
;
{
AUTO_PROFILER_LABEL
(
"
TaskController
:
:
ProcessPendingMTTask
"
IDLE
)
;
mMainThreadCV
.
Wait
(
)
;
}
BackgroundHangMonitor
(
)
.
NotifyActivity
(
)
;
}
if
(
mMayHaveMainThreadTask
)
{
EnsureMainThreadTasksScheduled
(
)
;
}
}
void
TaskController
:
:
ReprioritizeTask
(
Task
*
aTask
uint32_t
aPriority
)
{
MutexAutoLock
lock
(
mGraphMutex
)
;
std
:
:
set
<
RefPtr
<
Task
>
Task
:
:
PriorityCompare
>
*
queue
=
&
mMainThreadTasks
;
if
(
!
aTask
-
>
IsMainThreadOnly
(
)
)
{
queue
=
&
mThreadableTasks
;
}
MOZ_ASSERT
(
aTask
-
>
mIterator
!
=
queue
-
>
end
(
)
)
;
queue
-
>
erase
(
aTask
-
>
mIterator
)
;
aTask
-
>
mPriority
=
aPriority
;
auto
insertion
=
queue
-
>
insert
(
aTask
)
;
MOZ_ASSERT
(
insertion
.
second
)
;
aTask
-
>
mIterator
=
insertion
.
first
;
MaybeInterruptTask
(
aTask
)
;
}
class
RunnableTask
:
public
Task
{
public
:
RunnableTask
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
int32_t
aPriority
bool
aMainThread
=
true
)
:
Task
(
aMainThread
aPriority
)
mRunnable
(
aRunnable
)
{
}
virtual
bool
Run
(
)
override
{
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Array
<
char
nsThread
:
:
kRunnableNameBufSize
>
restoreRunnableName
;
restoreRunnableName
[
0
]
=
'
\
0
'
;
auto
clear
=
MakeScopeExit
(
[
&
]
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsThread
:
:
sMainThreadRunnableName
=
restoreRunnableName
;
}
)
;
nsAutoCString
name
;
nsThread
:
:
GetLabeledRunnableName
(
mRunnable
name
EventQueuePriority
(
GetPriority
(
)
)
)
;
restoreRunnableName
=
nsThread
:
:
sMainThreadRunnableName
;
uint32_t
length
=
std
:
:
min
(
(
uint32_t
)
nsThread
:
:
kRunnableNameBufSize
-
1
(
uint32_t
)
name
.
Length
(
)
)
;
memcpy
(
nsThread
:
:
sMainThreadRunnableName
.
begin
(
)
name
.
BeginReading
(
)
length
)
;
nsThread
:
:
sMainThreadRunnableName
[
length
]
=
'
\
0
'
;
#
endif
mRunnable
-
>
Run
(
)
;
mRunnable
=
nullptr
;
return
true
;
}
void
SetIdleDeadline
(
TimeStamp
aDeadline
)
override
{
nsCOMPtr
<
nsIIdleRunnable
>
idleRunnable
=
do_QueryInterface
(
mRunnable
)
;
if
(
idleRunnable
)
{
idleRunnable
-
>
SetDeadline
(
aDeadline
)
;
}
}
PerformanceCounter
*
GetPerformanceCounter
(
)
const
override
{
return
nsThread
:
:
GetPerformanceCounterBase
(
mRunnable
)
;
}
virtual
bool
GetName
(
nsACString
&
aName
)
override
{
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
nsThread
:
:
GetLabeledRunnableName
(
mRunnable
aName
EventQueuePriority
(
GetPriority
(
)
)
)
;
return
true
;
#
else
return
false
;
#
endif
}
private
:
RefPtr
<
nsIRunnable
>
mRunnable
;
}
;
void
TaskController
:
:
DispatchRunnable
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
uint32_t
aPriority
TaskManager
*
aManager
)
{
RefPtr
<
RunnableTask
>
task
=
new
RunnableTask
(
std
:
:
move
(
aRunnable
)
aPriority
)
;
task
-
>
SetManager
(
aManager
)
;
TaskController
:
:
Get
(
)
-
>
AddTask
(
task
.
forget
(
)
)
;
}
nsIRunnable
*
TaskController
:
:
GetRunnableForMTTask
(
bool
aReallyWait
)
{
MutexAutoLock
lock
(
mGraphMutex
)
;
while
(
mMainThreadTasks
.
empty
(
)
)
{
if
(
!
aReallyWait
)
{
return
nullptr
;
}
AUTO_PROFILER_LABEL
(
"
TaskController
:
:
GetRunnableForMTTask
:
:
Wait
"
IDLE
)
;
mMainThreadCV
.
Wait
(
)
;
}
return
aReallyWait
?
mMTBlockingProcessingRunnable
:
mMTProcessingRunnable
;
}
bool
TaskController
:
:
HasMainThreadPendingTasks
(
)
{
auto
resetIdleState
=
MakeScopeExit
(
[
&
idleManager
=
mIdleTaskManager
]
{
if
(
idleManager
)
{
idleManager
-
>
State
(
)
.
ClearCachedIdleDeadline
(
)
;
}
}
)
;
for
(
bool
considerIdle
:
{
false
true
}
)
{
if
(
considerIdle
&
&
!
mIdleTaskManager
)
{
continue
;
}
MutexAutoLock
lock
(
mGraphMutex
)
;
if
(
considerIdle
)
{
mIdleTaskManager
-
>
State
(
)
.
ForgetPendingTaskGuarantee
(
)
;
{
MutexAutoUnlock
unlock
(
mGraphMutex
)
;
mIdleTaskManager
-
>
State
(
)
.
CachePeekedIdleDeadline
(
unlock
)
;
}
}
if
(
mMainThreadTasks
.
empty
(
)
)
{
return
false
;
}
uint64_t
totalSuspended
=
0
;
for
(
TaskManager
*
manager
:
mTaskManagers
)
{
DebugOnly
<
bool
>
modifierChanged
=
manager
-
>
UpdateCachesForCurrentIterationAndReportPriorityModifierChanged
(
lock
TaskManager
:
:
IterationType
:
:
NOT_EVENT_LOOP_TURN
)
;
MOZ_ASSERT
(
!
modifierChanged
)
;
MOZ_ASSERT
(
manager
!
=
mIdleTaskManager
|
|
manager
-
>
mCurrentSuspended
|
|
considerIdle
"
Why
are
idle
tasks
not
suspended
here
?
"
)
;
if
(
manager
-
>
mCurrentSuspended
)
{
totalSuspended
+
=
manager
-
>
mTaskCount
;
}
}
if
(
mMainThreadTasks
.
size
(
)
>
totalSuspended
)
{
if
(
mIdleTaskManager
&
&
mIdleTaskManager
-
>
mTaskCount
&
&
!
mIdleTaskManager
-
>
mCurrentSuspended
)
{
MOZ_ASSERT
(
considerIdle
"
Why
is
mIdleTaskManager
not
suspended
?
"
)
;
if
(
mMainThreadTasks
.
size
(
)
-
mIdleTaskManager
-
>
mTaskCount
<
=
totalSuspended
)
{
mIdleTaskManager
-
>
State
(
)
.
EnforcePendingTaskGuarantee
(
)
;
}
}
return
true
;
}
}
return
false
;
}
bool
TaskController
:
:
ExecuteNextTaskOnlyMainThreadInternal
(
const
MutexAutoLock
&
aProofOfLock
)
{
bool
taskRan
=
false
;
do
{
taskRan
=
DoExecuteNextTaskOnlyMainThreadInternal
(
aProofOfLock
)
;
if
(
taskRan
)
{
if
(
mIdleTaskManager
&
&
mIdleTaskManager
-
>
mTaskCount
&
&
mIdleTaskManager
-
>
IsSuspended
(
aProofOfLock
)
)
{
uint32_t
activeTasks
=
mMainThreadTasks
.
size
(
)
;
for
(
TaskManager
*
manager
:
mTaskManagers
)
{
if
(
manager
-
>
IsSuspended
(
aProofOfLock
)
)
{
activeTasks
-
=
manager
-
>
mTaskCount
;
}
else
{
break
;
}
}
if
(
!
activeTasks
)
{
MutexAutoUnlock
unlock
(
mGraphMutex
)
;
mIdleTaskManager
-
>
State
(
)
.
RequestIdleDeadlineIfNeeded
(
unlock
)
;
}
}
break
;
}
if
(
!
mIdleTaskManager
)
{
break
;
}
if
(
mIdleTaskManager
-
>
mTaskCount
)
{
MutexAutoUnlock
unlock
(
mGraphMutex
)
;
mIdleTaskManager
-
>
State
(
)
.
UpdateCachedIdleDeadline
(
unlock
)
;
}
else
{
MutexAutoUnlock
unlock
(
mGraphMutex
)
;
mIdleTaskManager
-
>
State
(
)
.
RanOutOfTasks
(
unlock
)
;
}
taskRan
=
DoExecuteNextTaskOnlyMainThreadInternal
(
aProofOfLock
)
;
}
while
(
false
)
;
if
(
mIdleTaskManager
)
{
mIdleTaskManager
-
>
State
(
)
.
ForgetPendingTaskGuarantee
(
)
;
if
(
mMainThreadTasks
.
empty
(
)
)
{
MutexAutoUnlock
unlock
(
mGraphMutex
)
;
mIdleTaskManager
-
>
State
(
)
.
RanOutOfTasks
(
unlock
)
;
}
}
return
taskRan
;
}
bool
TaskController
:
:
DoExecuteNextTaskOnlyMainThreadInternal
(
const
MutexAutoLock
&
aProofOfLock
)
{
nsCOMPtr
<
nsIThread
>
mainIThread
;
NS_GetMainThread
(
getter_AddRefs
(
mainIThread
)
)
;
nsThread
*
mainThread
=
static_cast
<
nsThread
*
>
(
mainIThread
.
get
(
)
)
;
if
(
mainThread
)
{
mainThread
-
>
SetRunningEventDelay
(
TimeDuration
(
)
TimeStamp
(
)
)
;
}
uint32_t
totalSuspended
=
0
;
for
(
TaskManager
*
manager
:
mTaskManagers
)
{
bool
modifierChanged
=
manager
-
>
UpdateCachesForCurrentIterationAndReportPriorityModifierChanged
(
aProofOfLock
TaskManager
:
:
IterationType
:
:
EVENT_LOOP_TURN
)
;
if
(
modifierChanged
)
{
ProcessUpdatedPriorityModifier
(
manager
)
;
}
if
(
manager
-
>
mCurrentSuspended
)
{
totalSuspended
+
=
manager
-
>
mTaskCount
;
}
}
MOZ_ASSERT
(
mMainThreadTasks
.
size
(
)
>
=
totalSuspended
)
;
if
(
mMainThreadTasks
.
size
(
)
>
totalSuspended
)
{
for
(
auto
iter
=
mMainThreadTasks
.
begin
(
)
;
iter
!
=
mMainThreadTasks
.
end
(
)
;
iter
+
+
)
{
Task
*
task
=
iter
-
>
get
(
)
;
if
(
task
-
>
mTaskManager
&
&
task
-
>
mTaskManager
-
>
mCurrentSuspended
)
{
continue
;
}
task
=
GetFinalDependency
(
task
)
;
if
(
!
task
-
>
IsMainThreadOnly
(
)
|
|
task
-
>
mInProgress
|
|
(
task
-
>
mTaskManager
&
&
task
-
>
mTaskManager
-
>
mCurrentSuspended
)
)
{
continue
;
}
mCurrentTasksMT
.
push
(
task
)
;
mMainThreadTasks
.
erase
(
task
-
>
mIterator
)
;
task
-
>
mIterator
=
mMainThreadTasks
.
end
(
)
;
task
-
>
mInProgress
=
true
;
TaskManager
*
manager
=
task
-
>
GetManager
(
)
;
bool
result
=
false
;
{
MutexAutoUnlock
unlock
(
mGraphMutex
)
;
if
(
manager
)
{
manager
-
>
WillRunTask
(
)
;
if
(
manager
!
=
mIdleTaskManager
)
{
mIdleTaskManager
-
>
State
(
)
.
FlagNotIdle
(
)
;
}
else
{
TimeStamp
idleDeadline
=
mIdleTaskManager
-
>
State
(
)
.
GetCachedIdleDeadline
(
)
;
MOZ_ASSERT
(
idleDeadline
"
How
can
we
not
have
a
deadline
if
our
manager
is
enabled
?
"
)
;
task
-
>
SetIdleDeadline
(
idleDeadline
)
;
}
}
if
(
mIdleTaskManager
)
{
mIdleTaskManager
-
>
State
(
)
.
ClearCachedIdleDeadline
(
)
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
mainThread
)
{
if
(
task
-
>
GetPriority
(
)
<
uint32_t
(
EventQueuePriority
:
:
InputHigh
)
)
{
mainThread
-
>
SetRunningEventDelay
(
TimeDuration
(
)
now
)
;
}
else
{
mainThread
-
>
SetRunningEventDelay
(
now
-
task
-
>
mInsertionTime
now
)
;
}
}
PerformanceCounterState
:
:
Snapshot
snapshot
=
mPerformanceCounterState
-
>
RunnableWillRun
(
task
-
>
GetPerformanceCounter
(
)
now
manager
=
=
mIdleTaskManager
)
;
{
LogTask
:
:
Run
log
(
task
)
;
AUTO_PROFILE_FOLLOWING_TASK
(
task
)
;
result
=
task
-
>
Run
(
)
;
}
if
(
manager
)
{
manager
-
>
DidRunTask
(
)
;
}
mPerformanceCounterState
-
>
RunnableDidRun
(
std
:
:
move
(
snapshot
)
)
;
}
if
(
manager
&
&
result
&
&
manager
-
>
mTaskCount
=
=
0
)
{
mTaskManagers
.
erase
(
manager
)
;
}
task
-
>
mInProgress
=
false
;
if
(
!
result
)
{
auto
insertion
=
mMainThreadTasks
.
insert
(
std
:
:
move
(
mCurrentTasksMT
.
top
(
)
)
)
;
MOZ_ASSERT
(
insertion
.
second
)
;
task
-
>
mIterator
=
insertion
.
first
;
manager
-
>
WillRunTask
(
)
;
}
else
{
task
-
>
mCompleted
=
true
;
#
ifdef
DEBUG
task
-
>
mIsInGraph
=
false
;
#
endif
task
-
>
mDependencies
.
clear
(
)
;
if
(
!
mThreadableTasks
.
empty
(
)
)
{
mThreadPoolCV
.
NotifyAll
(
)
;
}
}
mCurrentTasksMT
.
pop
(
)
;
return
true
;
}
}
mMayHaveMainThreadTask
=
false
;
if
(
mIdleTaskManager
)
{
mIdleTaskManager
-
>
State
(
)
.
ClearCachedIdleDeadline
(
)
;
}
return
false
;
}
Task
*
TaskController
:
:
GetFinalDependency
(
Task
*
aTask
)
{
Task
*
nextTask
;
while
(
(
nextTask
=
aTask
-
>
GetHighestPriorityDependency
(
)
)
)
{
aTask
=
nextTask
;
}
return
aTask
;
}
void
TaskController
:
:
MaybeInterruptTask
(
Task
*
aTask
)
{
mGraphMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
!
aTask
)
{
return
;
}
if
(
!
aTask
-
>
mDependencies
.
empty
(
)
)
{
Task
*
firstDependency
=
aTask
-
>
mDependencies
.
begin
(
)
-
>
get
(
)
;
if
(
aTask
-
>
GetPriority
(
)
<
=
firstDependency
-
>
GetPriority
(
)
&
&
!
firstDependency
-
>
mCompleted
&
&
aTask
-
>
IsMainThreadOnly
(
)
=
=
firstDependency
-
>
IsMainThreadOnly
(
)
)
{
return
;
}
}
Task
*
finalDependency
=
GetFinalDependency
(
aTask
)
;
if
(
finalDependency
-
>
mInProgress
)
{
return
;
}
if
(
aTask
-
>
IsMainThreadOnly
(
)
)
{
mMayHaveMainThreadTask
=
true
;
EnsureMainThreadTasksScheduled
(
)
;
if
(
mCurrentTasksMT
.
empty
(
)
)
{
return
;
}
if
(
!
finalDependency
-
>
IsMainThreadOnly
(
)
)
{
return
;
}
if
(
mCurrentTasksMT
.
top
(
)
-
>
GetPriority
(
)
<
aTask
-
>
GetPriority
(
)
)
{
mCurrentTasksMT
.
top
(
)
-
>
RequestInterrupt
(
aTask
-
>
GetPriority
(
)
)
;
}
}
else
{
Task
*
lowestPriorityTask
=
nullptr
;
for
(
PoolThread
&
thread
:
mPoolThreads
)
{
if
(
!
thread
.
mCurrentTask
)
{
mThreadPoolCV
.
Notify
(
)
;
return
;
}
if
(
!
lowestPriorityTask
)
{
lowestPriorityTask
=
thread
.
mCurrentTask
.
get
(
)
;
continue
;
}
if
(
lowestPriorityTask
-
>
GetPriority
(
)
>
thread
.
mEffectiveTaskPriority
)
{
lowestPriorityTask
=
thread
.
mCurrentTask
.
get
(
)
;
}
}
if
(
lowestPriorityTask
-
>
GetPriority
(
)
<
aTask
-
>
GetPriority
(
)
)
{
lowestPriorityTask
-
>
RequestInterrupt
(
aTask
-
>
GetPriority
(
)
)
;
}
}
}
Task
*
TaskController
:
:
GetHighestPriorityMTTask
(
)
{
mGraphMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
!
mMainThreadTasks
.
empty
(
)
)
{
return
mMainThreadTasks
.
begin
(
)
-
>
get
(
)
;
}
return
nullptr
;
}
void
TaskController
:
:
EnsureMainThreadTasksScheduled
(
)
{
if
(
mObserver
)
{
mObserver
-
>
OnDispatchedEvent
(
)
;
}
if
(
mExternalCondVar
)
{
mExternalCondVar
-
>
Notify
(
)
;
}
mMainThreadCV
.
Notify
(
)
;
}
void
TaskController
:
:
ProcessUpdatedPriorityModifier
(
TaskManager
*
aManager
)
{
mGraphMutex
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
int32_t
modifier
=
aManager
-
>
mCurrentPriorityModifier
;
std
:
:
vector
<
RefPtr
<
Task
>
>
storedTasks
;
for
(
auto
iter
=
mMainThreadTasks
.
begin
(
)
;
iter
!
=
mMainThreadTasks
.
end
(
)
;
)
{
if
(
(
*
iter
)
-
>
mTaskManager
=
=
aManager
)
{
storedTasks
.
push_back
(
*
iter
)
;
iter
=
mMainThreadTasks
.
erase
(
iter
)
;
}
else
{
iter
+
+
;
}
}
for
(
RefPtr
<
Task
>
&
ref
:
storedTasks
)
{
Task
*
task
=
ref
;
task
-
>
mPriorityModifier
=
modifier
;
auto
insertion
=
mMainThreadTasks
.
insert
(
std
:
:
move
(
ref
)
)
;
MOZ_ASSERT
(
insertion
.
second
)
;
task
-
>
mIterator
=
insertion
.
first
;
}
}
}
