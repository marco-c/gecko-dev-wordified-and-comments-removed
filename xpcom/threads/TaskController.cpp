#
include
"
TaskController
.
h
"
#
include
"
nsIIdleRunnable
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
<
algorithm
>
#
include
<
initializer_list
>
#
include
"
mozilla
/
AbstractEventQueue
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
mozilla
/
InputTaskManager
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsThread
.
h
"
namespace
mozilla
{
std
:
:
unique_ptr
<
TaskController
>
TaskController
:
:
sSingleton
;
uint64_t
Task
:
:
sCurrentTaskSeqNo
=
0
;
bool
TaskManager
:
:
UpdateCachesForCurrentIterationAndReportPriorityModifierChanged
(
const
MutexAutoLock
&
aProofOfLock
IterationType
aIterationType
)
{
mCurrentSuspended
=
IsSuspended
(
aProofOfLock
)
;
if
(
aIterationType
=
=
IterationType
:
:
EVENT_LOOP_TURN
)
{
int32_t
oldModifier
=
mCurrentPriorityModifier
;
mCurrentPriorityModifier
=
GetPriorityModifierForEventLoopTurn
(
aProofOfLock
)
;
if
(
mCurrentPriorityModifier
!
=
oldModifier
)
{
return
true
;
}
}
return
false
;
}
Task
*
Task
:
:
GetHighestPriorityDependency
(
)
{
Task
*
currentTask
=
this
;
while
(
!
currentTask
-
>
mDependencies
.
empty
(
)
)
{
auto
iter
=
currentTask
-
>
mDependencies
.
begin
(
)
;
while
(
iter
!
=
currentTask
-
>
mDependencies
.
end
(
)
)
{
if
(
(
*
iter
)
-
>
mCompleted
)
{
auto
oldIter
=
iter
;
iter
+
+
;
currentTask
-
>
mDependencies
.
erase
(
oldIter
)
;
continue
;
}
currentTask
=
iter
-
>
get
(
)
;
break
;
}
}
return
currentTask
=
=
this
?
nullptr
:
currentTask
;
}
TaskController
*
TaskController
:
:
Get
(
)
{
MOZ_ASSERT
(
sSingleton
.
get
(
)
)
;
return
sSingleton
.
get
(
)
;
}
bool
TaskController
:
:
Initialize
(
)
{
MOZ_ASSERT
(
!
sSingleton
)
;
sSingleton
=
std
:
:
make_unique
<
TaskController
>
(
)
;
return
sSingleton
-
>
InitializeInternal
(
)
;
}
bool
TaskController
:
:
InitializeInternal
(
)
{
mMTProcessingRunnable
=
NS_NewRunnableFunction
(
"
TaskController
:
:
ExecutePendingMTTasks
(
)
"
[
]
(
)
{
TaskController
:
:
Get
(
)
-
>
ProcessPendingMTTask
(
)
;
}
)
;
mMTBlockingProcessingRunnable
=
NS_NewRunnableFunction
(
"
TaskController
:
:
ExecutePendingMTTasks
(
)
"
[
]
(
)
{
TaskController
:
:
Get
(
)
-
>
ProcessPendingMTTask
(
true
)
;
}
)
;
return
true
;
}
void
TaskController
:
:
SetPerformanceCounterState
(
PerformanceCounterState
*
aPerformanceCounterState
)
{
mPerformanceCounterState
=
aPerformanceCounterState
;
}
void
TaskController
:
:
Shutdown
(
)
{
InputTaskManager
:
:
Cleanup
(
)
;
if
(
sSingleton
)
{
sSingleton
-
>
ShutdownInternal
(
)
;
}
MOZ_ASSERT
(
!
sSingleton
)
;
}
void
TaskController
:
:
ShutdownInternal
(
)
{
sSingleton
=
nullptr
;
}
void
TaskController
:
:
AddTask
(
already_AddRefed
<
Task
>
&
&
aTask
)
{
MutexAutoLock
lock
(
mGraphMutex
)
;
RefPtr
<
Task
>
task
(
aTask
)
;
if
(
TaskManager
*
manager
=
task
-
>
GetManager
(
)
)
{
if
(
manager
-
>
mTaskCount
=
=
0
)
{
mTaskManagers
.
insert
(
manager
)
;
}
manager
-
>
DidQueueTask
(
)
;
task
-
>
mPriorityModifier
=
manager
-
>
mCurrentPriorityModifier
;
}
#
ifdef
MOZ_GECKO_PROFILER
task
-
>
mInsertionTime
=
TimeStamp
:
:
Now
(
)
;
#
endif
#
ifdef
DEBUG
task
-
>
mIsInGraph
=
true
;
for
(
const
RefPtr
<
Task
>
&
otherTask
:
task
-
>
mDependencies
)
{
MOZ_ASSERT
(
!
otherTask
-
>
mTaskManager
|
|
otherTask
-
>
mTaskManager
=
=
task
-
>
mTaskManager
)
;
}
#
endif
LogTask
:
:
LogDispatch
(
task
)
;
auto
insertion
=
mMainThreadTasks
.
insert
(
std
:
:
move
(
task
)
)
;
MOZ_ASSERT
(
insertion
.
second
)
;
(
*
insertion
.
first
)
-
>
mIterator
=
insertion
.
first
;
MaybeInterruptTask
(
*
insertion
.
first
)
;
}
void
TaskController
:
:
WaitForTaskOrMessage
(
)
{
MutexAutoLock
lock
(
mGraphMutex
)
;
while
(
!
mMayHaveMainThreadTask
)
{
AUTO_PROFILER_LABEL
(
"
TaskController
:
:
WaitForTaskOrMessage
"
IDLE
)
;
mMainThreadCV
.
Wait
(
)
;
}
}
void
TaskController
:
:
ExecuteNextTaskOnlyMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mGraphMutex
)
;
ExecuteNextTaskOnlyMainThreadInternal
(
lock
)
;
}
void
TaskController
:
:
ProcessPendingMTTask
(
bool
aMayWait
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mGraphMutex
)
;
for
(
;
;
)
{
mMTTaskRunnableProcessedTask
=
ExecuteNextTaskOnlyMainThreadInternal
(
lock
)
;
if
(
mMTTaskRunnableProcessedTask
|
|
!
aMayWait
)
{
break
;
}
BackgroundHangMonitor
(
)
.
NotifyWait
(
)
;
{
AUTO_PROFILER_LABEL
(
"
TaskController
:
:
ProcessPendingMTTask
"
IDLE
)
;
mMainThreadCV
.
Wait
(
)
;
}
BackgroundHangMonitor
(
)
.
NotifyActivity
(
)
;
}
if
(
mMayHaveMainThreadTask
)
{
EnsureMainThreadTasksScheduled
(
)
;
}
}
void
TaskController
:
:
ReprioritizeTask
(
Task
*
aTask
uint32_t
aPriority
)
{
MutexAutoLock
lock
(
mGraphMutex
)
;
std
:
:
set
<
RefPtr
<
Task
>
Task
:
:
PriorityCompare
>
*
queue
=
&
mMainThreadTasks
;
MOZ_ASSERT
(
aTask
-
>
mIterator
!
=
queue
-
>
end
(
)
)
;
queue
-
>
erase
(
aTask
-
>
mIterator
)
;
aTask
-
>
mPriority
=
aPriority
;
auto
insertion
=
queue
-
>
insert
(
aTask
)
;
MOZ_ASSERT
(
insertion
.
second
)
;
aTask
-
>
mIterator
=
insertion
.
first
;
MaybeInterruptTask
(
aTask
)
;
}
class
RunnableTask
:
public
Task
{
public
:
RunnableTask
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
int32_t
aPriority
bool
aMainThread
=
true
)
:
Task
(
aMainThread
aPriority
)
mRunnable
(
aRunnable
)
{
}
virtual
bool
Run
(
)
override
{
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Array
<
char
nsThread
:
:
kRunnableNameBufSize
>
restoreRunnableName
;
restoreRunnableName
[
0
]
=
'
\
0
'
;
auto
clear
=
MakeScopeExit
(
[
&
]
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsThread
:
:
sMainThreadRunnableName
=
restoreRunnableName
;
}
)
;
nsAutoCString
name
;
nsThread
:
:
GetLabeledRunnableName
(
mRunnable
name
EventQueuePriority
(
GetPriority
(
)
)
)
;
restoreRunnableName
=
nsThread
:
:
sMainThreadRunnableName
;
uint32_t
length
=
std
:
:
min
(
(
uint32_t
)
nsThread
:
:
kRunnableNameBufSize
-
1
(
uint32_t
)
name
.
Length
(
)
)
;
memcpy
(
nsThread
:
:
sMainThreadRunnableName
.
begin
(
)
name
.
BeginReading
(
)
length
)
;
nsThread
:
:
sMainThreadRunnableName
[
length
]
=
'
\
0
'
;
#
endif
mRunnable
-
>
Run
(
)
;
mRunnable
=
nullptr
;
return
true
;
}
void
SetIdleDeadline
(
TimeStamp
aDeadline
)
override
{
nsCOMPtr
<
nsIIdleRunnable
>
idleRunnable
=
do_QueryInterface
(
mRunnable
)
;
if
(
idleRunnable
)
{
idleRunnable
-
>
SetDeadline
(
aDeadline
)
;
}
}
PerformanceCounter
*
GetPerformanceCounter
(
)
const
override
{
return
nsThread
:
:
GetPerformanceCounterBase
(
mRunnable
)
;
}
private
:
RefPtr
<
nsIRunnable
>
mRunnable
;
}
;
void
TaskController
:
:
DispatchRunnable
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
uint32_t
aPriority
TaskManager
*
aManager
)
{
RefPtr
<
RunnableTask
>
task
=
new
RunnableTask
(
std
:
:
move
(
aRunnable
)
aPriority
)
;
task
-
>
SetManager
(
aManager
)
;
TaskController
:
:
Get
(
)
-
>
AddTask
(
task
.
forget
(
)
)
;
}
nsIRunnable
*
TaskController
:
:
GetRunnableForMTTask
(
bool
aReallyWait
)
{
MutexAutoLock
lock
(
mGraphMutex
)
;
while
(
mMainThreadTasks
.
empty
(
)
)
{
if
(
!
aReallyWait
)
{
return
nullptr
;
}
AUTO_PROFILER_LABEL
(
"
TaskController
:
:
GetRunnableForMTTask
:
:
Wait
"
IDLE
)
;
mMainThreadCV
.
Wait
(
)
;
}
return
aReallyWait
?
mMTBlockingProcessingRunnable
:
mMTProcessingRunnable
;
}
bool
TaskController
:
:
HasMainThreadPendingTasks
(
)
{
auto
resetIdleState
=
MakeScopeExit
(
[
&
idleManager
=
mIdleTaskManager
]
{
if
(
idleManager
)
{
idleManager
-
>
State
(
)
.
ClearCachedIdleDeadline
(
)
;
}
}
)
;
for
(
bool
considerIdle
:
{
false
true
}
)
{
if
(
considerIdle
&
&
!
mIdleTaskManager
)
{
continue
;
}
MutexAutoLock
lock
(
mGraphMutex
)
;
if
(
considerIdle
)
{
mIdleTaskManager
-
>
State
(
)
.
ForgetPendingTaskGuarantee
(
)
;
{
MutexAutoUnlock
unlock
(
mGraphMutex
)
;
mIdleTaskManager
-
>
State
(
)
.
CachePeekedIdleDeadline
(
unlock
)
;
}
}
if
(
mMainThreadTasks
.
empty
(
)
)
{
return
false
;
}
uint64_t
totalSuspended
=
0
;
for
(
TaskManager
*
manager
:
mTaskManagers
)
{
DebugOnly
<
bool
>
modifierChanged
=
manager
-
>
UpdateCachesForCurrentIterationAndReportPriorityModifierChanged
(
lock
TaskManager
:
:
IterationType
:
:
NOT_EVENT_LOOP_TURN
)
;
MOZ_ASSERT
(
!
modifierChanged
)
;
MOZ_ASSERT
(
manager
!
=
mIdleTaskManager
|
|
manager
-
>
mCurrentSuspended
|
|
considerIdle
"
Why
are
idle
tasks
not
suspended
here
?
"
)
;
if
(
manager
-
>
mCurrentSuspended
)
{
totalSuspended
+
=
manager
-
>
mTaskCount
;
}
}
if
(
mMainThreadTasks
.
size
(
)
>
totalSuspended
)
{
if
(
mIdleTaskManager
&
&
mIdleTaskManager
-
>
mTaskCount
&
&
!
mIdleTaskManager
-
>
mCurrentSuspended
)
{
MOZ_ASSERT
(
considerIdle
"
Why
is
mIdleTaskManager
not
suspended
?
"
)
;
if
(
mMainThreadTasks
.
size
(
)
-
mIdleTaskManager
-
>
mTaskCount
<
=
totalSuspended
)
{
mIdleTaskManager
-
>
State
(
)
.
EnforcePendingTaskGuarantee
(
)
;
}
}
return
true
;
}
}
return
false
;
}
bool
TaskController
:
:
ExecuteNextTaskOnlyMainThreadInternal
(
const
MutexAutoLock
&
aProofOfLock
)
{
bool
taskRan
=
false
;
do
{
taskRan
=
DoExecuteNextTaskOnlyMainThreadInternal
(
aProofOfLock
)
;
if
(
taskRan
)
{
break
;
}
if
(
!
mIdleTaskManager
)
{
break
;
}
if
(
mIdleTaskManager
-
>
mTaskCount
)
{
MutexAutoUnlock
unlock
(
mGraphMutex
)
;
mIdleTaskManager
-
>
State
(
)
.
UpdateCachedIdleDeadline
(
unlock
)
;
}
else
{
MutexAutoUnlock
unlock
(
mGraphMutex
)
;
mIdleTaskManager
-
>
State
(
)
.
RanOutOfTasks
(
unlock
)
;
}
taskRan
=
DoExecuteNextTaskOnlyMainThreadInternal
(
aProofOfLock
)
;
}
while
(
false
)
;
if
(
mIdleTaskManager
)
{
mIdleTaskManager
-
>
State
(
)
.
ForgetPendingTaskGuarantee
(
)
;
if
(
mMainThreadTasks
.
empty
(
)
)
{
MutexAutoUnlock
unlock
(
mGraphMutex
)
;
mIdleTaskManager
-
>
State
(
)
.
RanOutOfTasks
(
unlock
)
;
}
}
return
taskRan
;
}
bool
TaskController
:
:
DoExecuteNextTaskOnlyMainThreadInternal
(
const
MutexAutoLock
&
aProofOfLock
)
{
nsCOMPtr
<
nsIThread
>
mainIThread
;
NS_GetMainThread
(
getter_AddRefs
(
mainIThread
)
)
;
nsThread
*
mainThread
=
static_cast
<
nsThread
*
>
(
mainIThread
.
get
(
)
)
;
mainThread
-
>
SetRunningEventDelay
(
TimeDuration
(
)
TimeStamp
(
)
)
;
uint32_t
totalSuspended
=
0
;
for
(
TaskManager
*
manager
:
mTaskManagers
)
{
bool
modifierChanged
=
manager
-
>
UpdateCachesForCurrentIterationAndReportPriorityModifierChanged
(
aProofOfLock
TaskManager
:
:
IterationType
:
:
EVENT_LOOP_TURN
)
;
if
(
modifierChanged
)
{
ProcessUpdatedPriorityModifier
(
manager
)
;
}
if
(
manager
-
>
mCurrentSuspended
)
{
totalSuspended
+
=
manager
-
>
mTaskCount
;
}
}
MOZ_ASSERT
(
mMainThreadTasks
.
size
(
)
>
=
totalSuspended
)
;
if
(
mMainThreadTasks
.
size
(
)
>
totalSuspended
)
{
for
(
auto
iter
=
mMainThreadTasks
.
begin
(
)
;
iter
!
=
mMainThreadTasks
.
end
(
)
;
iter
+
+
)
{
Task
*
task
=
iter
-
>
get
(
)
;
if
(
task
-
>
mTaskManager
&
&
task
-
>
mTaskManager
-
>
mCurrentSuspended
)
{
continue
;
}
task
=
GetFinalDependency
(
task
)
;
if
(
!
task
-
>
IsMainThreadOnly
(
)
|
|
task
-
>
mInProgress
|
|
(
task
-
>
mTaskManager
&
&
task
-
>
mTaskManager
-
>
mCurrentSuspended
)
)
{
continue
;
}
mCurrentTasksMT
.
push
(
task
)
;
mMainThreadTasks
.
erase
(
task
-
>
mIterator
)
;
task
-
>
mIterator
=
mMainThreadTasks
.
end
(
)
;
task
-
>
mInProgress
=
true
;
TaskManager
*
manager
=
task
-
>
GetManager
(
)
;
bool
result
=
false
;
{
MutexAutoUnlock
unlock
(
mGraphMutex
)
;
if
(
manager
)
{
manager
-
>
WillRunTask
(
)
;
if
(
manager
!
=
mIdleTaskManager
)
{
mIdleTaskManager
-
>
State
(
)
.
FlagNotIdle
(
)
;
}
else
{
TimeStamp
idleDeadline
=
mIdleTaskManager
-
>
State
(
)
.
GetCachedIdleDeadline
(
)
;
MOZ_ASSERT
(
idleDeadline
"
How
can
we
not
have
a
deadline
if
our
manager
is
enabled
?
"
)
;
task
-
>
SetIdleDeadline
(
idleDeadline
)
;
}
}
if
(
mIdleTaskManager
)
{
mIdleTaskManager
-
>
State
(
)
.
ClearCachedIdleDeadline
(
)
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
#
ifdef
MOZ_GECKO_PROFILER
if
(
task
-
>
GetPriority
(
)
<
uint32_t
(
EventQueuePriority
:
:
InputHigh
)
)
{
mainThread
-
>
SetRunningEventDelay
(
TimeDuration
(
)
now
)
;
}
else
{
mainThread
-
>
SetRunningEventDelay
(
now
-
task
-
>
mInsertionTime
now
)
;
}
#
endif
PerformanceCounterState
:
:
Snapshot
snapshot
=
mPerformanceCounterState
-
>
RunnableWillRun
(
task
-
>
GetPerformanceCounter
(
)
now
manager
=
=
mIdleTaskManager
)
;
{
LogTask
:
:
Run
log
(
task
)
;
result
=
task
-
>
Run
(
)
;
}
if
(
manager
)
{
manager
-
>
DidRunTask
(
)
;
}
mPerformanceCounterState
-
>
RunnableDidRun
(
std
:
:
move
(
snapshot
)
)
;
}
if
(
manager
&
&
result
&
&
manager
-
>
mTaskCount
=
=
0
)
{
mTaskManagers
.
erase
(
manager
)
;
}
task
-
>
mInProgress
=
false
;
if
(
!
result
)
{
auto
insertion
=
mMainThreadTasks
.
insert
(
std
:
:
move
(
mCurrentTasksMT
.
top
(
)
)
)
;
MOZ_ASSERT
(
insertion
.
second
)
;
task
-
>
mIterator
=
insertion
.
first
;
manager
-
>
WillRunTask
(
)
;
}
else
{
task
-
>
mCompleted
=
true
;
#
ifdef
DEBUG
task
-
>
mIsInGraph
=
false
;
#
endif
task
-
>
mDependencies
.
clear
(
)
;
}
mCurrentTasksMT
.
pop
(
)
;
return
true
;
}
}
mMayHaveMainThreadTask
=
false
;
if
(
mIdleTaskManager
)
{
mIdleTaskManager
-
>
State
(
)
.
ClearCachedIdleDeadline
(
)
;
}
return
false
;
}
Task
*
TaskController
:
:
GetFinalDependency
(
Task
*
aTask
)
{
Task
*
nextTask
;
while
(
(
nextTask
=
aTask
-
>
GetHighestPriorityDependency
(
)
)
)
{
aTask
=
nextTask
;
}
return
aTask
;
}
void
TaskController
:
:
MaybeInterruptTask
(
Task
*
aTask
)
{
mGraphMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
!
aTask
)
{
return
;
}
if
(
!
aTask
-
>
mDependencies
.
empty
(
)
)
{
Task
*
firstDependency
=
aTask
-
>
mDependencies
.
begin
(
)
-
>
get
(
)
;
if
(
aTask
-
>
GetPriority
(
)
<
=
firstDependency
-
>
GetPriority
(
)
&
&
!
firstDependency
-
>
mCompleted
&
&
aTask
-
>
IsMainThreadOnly
(
)
=
=
firstDependency
-
>
IsMainThreadOnly
(
)
)
{
return
;
}
}
Task
*
finalDependency
=
GetFinalDependency
(
aTask
)
;
if
(
finalDependency
-
>
mInProgress
)
{
return
;
}
EnsureMainThreadTasksScheduled
(
)
;
mMayHaveMainThreadTask
=
true
;
if
(
mCurrentTasksMT
.
empty
(
)
)
{
return
;
}
if
(
!
finalDependency
-
>
IsMainThreadOnly
(
)
)
{
return
;
}
if
(
mCurrentTasksMT
.
top
(
)
-
>
GetPriority
(
)
<
aTask
-
>
GetPriority
(
)
)
{
mCurrentTasksMT
.
top
(
)
-
>
RequestInterrupt
(
aTask
-
>
GetPriority
(
)
)
;
}
}
Task
*
TaskController
:
:
GetHighestPriorityMTTask
(
)
{
mGraphMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
!
mMainThreadTasks
.
empty
(
)
)
{
return
mMainThreadTasks
.
begin
(
)
-
>
get
(
)
;
}
return
nullptr
;
}
void
TaskController
:
:
EnsureMainThreadTasksScheduled
(
)
{
if
(
mObserver
)
{
mObserver
-
>
OnDispatchedEvent
(
)
;
}
if
(
mExternalCondVar
)
{
mExternalCondVar
-
>
Notify
(
)
;
}
mMainThreadCV
.
Notify
(
)
;
}
void
TaskController
:
:
ProcessUpdatedPriorityModifier
(
TaskManager
*
aManager
)
{
mGraphMutex
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
int32_t
modifier
=
aManager
-
>
mCurrentPriorityModifier
;
std
:
:
vector
<
RefPtr
<
Task
>
>
storedTasks
;
for
(
auto
iter
=
mMainThreadTasks
.
begin
(
)
;
iter
!
=
mMainThreadTasks
.
end
(
)
;
)
{
if
(
(
*
iter
)
-
>
mTaskManager
=
=
aManager
)
{
storedTasks
.
push_back
(
*
iter
)
;
iter
=
mMainThreadTasks
.
erase
(
iter
)
;
}
else
{
iter
+
+
;
}
}
for
(
RefPtr
<
Task
>
&
ref
:
storedTasks
)
{
Task
*
task
=
ref
;
task
-
>
mPriorityModifier
=
modifier
;
auto
insertion
=
mMainThreadTasks
.
insert
(
std
:
:
move
(
ref
)
)
;
MOZ_ASSERT
(
insertion
.
second
)
;
task
-
>
mIterator
=
insertion
.
first
;
}
}
}
