#
ifndef
mozilla_LabeledEventQueue_h
#
define
mozilla_LabeledEventQueue_h
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
AbstractEventQueue
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Queue
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
namespace
mozilla
{
class
SchedulerGroup
;
class
LabeledEventQueue
final
:
public
AbstractEventQueue
{
public
:
LabeledEventQueue
(
)
;
~
LabeledEventQueue
(
)
;
void
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventPriority
aPriority
const
MutexAutoLock
&
aProofOfLock
)
final
;
already_AddRefed
<
nsIRunnable
>
GetEvent
(
EventPriority
*
aPriority
const
MutexAutoLock
&
aProofOfLock
)
final
;
bool
IsEmpty
(
const
MutexAutoLock
&
aProofOfLock
)
final
;
size_t
Count
(
const
MutexAutoLock
&
aProofOfLock
)
const
final
;
bool
HasReadyEvent
(
const
MutexAutoLock
&
aProofOfLock
)
final
;
void
EnableInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
final
{
}
void
FlushInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
final
{
}
void
SuspendInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
final
{
}
void
ResumeInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
final
{
}
private
:
struct
QueueEntry
{
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
uintptr_t
mEpochNumber
;
QueueEntry
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uintptr_t
aEpoch
)
:
mRunnable
(
aRunnable
)
mEpochNumber
(
aEpoch
)
{
}
}
;
struct
Epoch
{
static
Epoch
First
(
bool
aIsLabeled
)
{
uintptr_t
number
=
aIsLabeled
?
1
:
0
;
return
Epoch
(
number
aIsLabeled
)
;
}
static
bool
EpochNumberIsLabeled
(
uintptr_t
aEpochNumber
)
{
return
(
aEpochNumber
&
1
)
?
true
:
false
;
}
uintptr_t
mEpochNumber
;
size_t
mNumEvents
;
Epoch
(
uintptr_t
aEpochNumber
bool
aIsLabeled
)
:
mEpochNumber
(
aEpochNumber
)
mNumEvents
(
0
)
{
MOZ_ASSERT
(
aIsLabeled
=
=
EpochNumberIsLabeled
(
aEpochNumber
)
)
;
}
bool
IsLabeled
(
)
const
{
return
EpochNumberIsLabeled
(
mEpochNumber
)
;
}
Epoch
NextEpoch
(
bool
aIsLabeled
)
const
{
MOZ_ASSERT
(
aIsLabeled
=
=
!
IsLabeled
(
)
)
;
return
Epoch
(
mEpochNumber
+
1
aIsLabeled
)
;
}
}
;
void
PopEpoch
(
)
;
static
SchedulerGroup
*
NextSchedulerGroup
(
SchedulerGroup
*
aGroup
)
;
using
RunnableEpochQueue
=
Queue
<
QueueEntry
32
>
;
using
LabeledMap
=
nsClassHashtable
<
nsRefPtrHashKey
<
SchedulerGroup
>
RunnableEpochQueue
>
;
using
EpochQueue
=
Queue
<
Epoch
8
>
;
static
LinkedList
<
SchedulerGroup
>
*
sSchedulerGroups
;
static
size_t
sLabeledEventQueueCount
;
static
SchedulerGroup
*
sCurrentSchedulerGroup
;
LabeledMap
mLabeled
;
RunnableEpochQueue
mUnlabeled
;
EpochQueue
mEpochs
;
size_t
mNumEvents
=
0
;
int64_t
mAvoidActiveTabCount
=
0
;
}
;
}
#
endif
