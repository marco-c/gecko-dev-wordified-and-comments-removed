#
include
"
nsEventQueue
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
prthread
.
h
"
#
include
"
mozilla
/
ChaosMode
.
h
"
using
namespace
mozilla
;
static
PRLogModuleInfo
*
GetLog
(
)
{
static
PRLogModuleInfo
*
sLog
;
if
(
!
sLog
)
{
sLog
=
PR_NewLogModule
(
"
nsEventQueue
"
)
;
}
return
sLog
;
}
#
ifdef
LOG
#
undef
LOG
#
endif
#
define
LOG
(
args
)
MOZ_LOG
(
GetLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
args
)
template
<
typename
MonitorType
>
nsEventQueueBase
<
MonitorType
>
:
:
nsEventQueueBase
(
)
:
mHead
(
nullptr
)
mTail
(
nullptr
)
mOffsetHead
(
0
)
mOffsetTail
(
0
)
{
}
template
nsEventQueueBase
<
Monitor
>
:
:
nsEventQueueBase
(
)
;
template
nsEventQueueBase
<
ReentrantMonitor
>
:
:
nsEventQueueBase
(
)
;
nsEventQueue
:
:
nsEventQueue
(
)
:
mMonitor
(
"
[
nsEventQueue
.
mMonitor
]
"
)
{
}
template
<
typename
MonitorType
>
nsEventQueueBase
<
MonitorType
>
:
:
~
nsEventQueueBase
(
)
{
NS_ASSERTION
(
IsEmpty
(
)
"
Non
-
empty
event
queue
being
destroyed
;
events
being
leaked
.
"
)
;
if
(
mHead
)
{
FreePage
(
mHead
)
;
}
}
template
nsEventQueueBase
<
Monitor
>
:
:
~
nsEventQueueBase
(
)
;
template
nsEventQueueBase
<
ReentrantMonitor
>
:
:
~
nsEventQueueBase
(
)
;
template
<
typename
MonitorType
>
bool
nsEventQueueBase
<
MonitorType
>
:
:
GetEvent
(
bool
aMayWait
nsIRunnable
*
*
aResult
MonitorAutoEnterType
&
aProofOfLock
)
{
while
(
IsEmpty
(
)
)
{
if
(
!
aMayWait
)
{
if
(
aResult
)
{
*
aResult
=
nullptr
;
}
return
false
;
}
LOG
(
(
"
EVENTQ
(
%
p
)
:
wait
begin
\
n
"
this
)
)
;
aProofOfLock
.
Wait
(
)
;
LOG
(
(
"
EVENTQ
(
%
p
)
:
wait
end
\
n
"
this
)
)
;
}
if
(
aResult
)
{
*
aResult
=
mHead
-
>
mEvents
[
mOffsetHead
+
+
]
;
if
(
mOffsetHead
=
=
EVENTS_PER_PAGE
)
{
Page
*
dead
=
mHead
;
mHead
=
mHead
-
>
mNext
;
FreePage
(
dead
)
;
mOffsetHead
=
0
;
}
}
return
true
;
}
template
bool
nsEventQueueBase
<
Monitor
>
:
:
GetEvent
(
bool
aMayWait
nsIRunnable
*
*
aResult
MonitorAutoLock
&
aProofOfLock
)
;
template
bool
nsEventQueueBase
<
ReentrantMonitor
>
:
:
GetEvent
(
bool
aMayWait
nsIRunnable
*
*
aResult
ReentrantMonitorAutoEnter
&
aProofOfLock
)
;
bool
nsEventQueue
:
:
GetEvent
(
bool
aMayWait
nsIRunnable
*
*
aEvent
)
{
MonitorAutoEnterType
mon
(
mMonitor
)
;
return
Base
:
:
GetEvent
(
aMayWait
aEvent
mon
)
;
}
template
<
typename
MonitorType
>
void
nsEventQueueBase
<
MonitorType
>
:
:
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
MonitorAutoEnterType
&
aProofOfLock
)
{
if
(
!
mHead
)
{
mHead
=
NewPage
(
)
;
MOZ_ASSERT
(
mHead
)
;
mTail
=
mHead
;
mOffsetHead
=
0
;
mOffsetTail
=
0
;
}
else
if
(
mOffsetTail
=
=
EVENTS_PER_PAGE
)
{
Page
*
page
=
NewPage
(
)
;
MOZ_ASSERT
(
page
)
;
mTail
-
>
mNext
=
page
;
mTail
=
page
;
mOffsetTail
=
0
;
}
nsIRunnable
*
&
queueLocation
=
mTail
-
>
mEvents
[
mOffsetTail
]
;
MOZ_ASSERT
(
!
queueLocation
)
;
queueLocation
=
aRunnable
.
take
(
)
;
+
+
mOffsetTail
;
LOG
(
(
"
EVENTQ
(
%
p
)
:
notify
\
n
"
this
)
)
;
aProofOfLock
.
NotifyAll
(
)
;
}
template
void
nsEventQueueBase
<
Monitor
>
:
:
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
MonitorAutoLock
&
aProofOfLock
)
;
template
void
nsEventQueueBase
<
ReentrantMonitor
>
:
:
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
ReentrantMonitorAutoEnter
&
aProofOfLock
)
;
void
nsEventQueue
:
:
PutEvent
(
nsIRunnable
*
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aRunnable
)
;
PutEvent
(
event
.
forget
(
)
)
;
}
void
nsEventQueue
:
:
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
if
(
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
ThreadScheduling
)
)
{
if
(
ChaosMode
:
:
randomUint32LessThan
(
2
)
)
{
PR_Sleep
(
PR_INTERVAL_NO_WAIT
)
;
}
}
MonitorAutoEnterType
mon
(
mMonitor
)
;
Base
:
:
PutEvent
(
Move
(
aRunnable
)
mon
)
;
}
template
<
typename
MonitorType
>
size_t
nsEventQueueBase
<
MonitorType
>
:
:
Count
(
MonitorAutoEnterType
&
aProofOfLock
)
{
if
(
!
mHead
)
{
return
0
;
}
int
count
=
-
mOffsetHead
;
for
(
Page
*
page
=
mHead
;
page
!
=
mTail
;
page
=
page
-
>
mNext
)
{
count
+
=
EVENTS_PER_PAGE
;
}
count
+
=
mOffsetTail
;
MOZ_ASSERT
(
count
>
=
0
)
;
return
count
;
}
template
size_t
nsEventQueueBase
<
Monitor
>
:
:
Count
(
MonitorAutoLock
&
aProofOfLock
)
;
template
size_t
nsEventQueueBase
<
ReentrantMonitor
>
:
:
Count
(
ReentrantMonitorAutoEnter
&
aProofOfLock
)
;
size_t
nsEventQueue
:
:
Count
(
)
{
MonitorAutoEnterType
mon
(
mMonitor
)
;
return
Base
:
:
Count
(
mon
)
;
}
