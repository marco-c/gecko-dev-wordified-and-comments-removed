#
include
"
nsEventQueue
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
prthread
.
h
"
#
include
"
mozilla
/
ChaosMode
.
h
"
using
namespace
mozilla
;
static
LazyLogModule
sEventQueueLog
(
"
nsEventQueue
"
)
;
#
ifdef
LOG
#
undef
LOG
#
endif
#
define
LOG
(
args
)
MOZ_LOG
(
sEventQueueLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
nsEventQueue
:
:
nsEventQueue
(
mozilla
:
:
CondVar
&
aCondVar
EventQueueType
aType
)
:
mHead
(
nullptr
)
mTail
(
nullptr
)
mOffsetHead
(
0
)
mOffsetTail
(
0
)
mEventsAvailable
(
aCondVar
)
mType
(
aType
)
{
}
nsEventQueue
:
:
~
nsEventQueue
(
)
{
NS_ASSERTION
(
IsEmpty
(
)
"
Non
-
empty
event
queue
being
destroyed
;
events
being
leaked
.
"
)
;
if
(
mHead
)
{
FreePage
(
mHead
)
;
}
}
bool
nsEventQueue
:
:
GetEvent
(
bool
aMayWait
nsIRunnable
*
*
aResult
MutexAutoLock
&
aProofOfLock
)
{
if
(
aResult
)
{
*
aResult
=
nullptr
;
}
while
(
IsEmpty
(
)
)
{
if
(
!
aMayWait
)
{
return
false
;
}
LOG
(
(
"
EVENTQ
(
%
p
)
:
wait
begin
\
n
"
this
)
)
;
mEventsAvailable
.
Wait
(
)
;
LOG
(
(
"
EVENTQ
(
%
p
)
:
wait
end
\
n
"
this
)
)
;
if
(
mType
=
=
eSharedCondVarQueue
)
{
if
(
IsEmpty
(
)
)
{
return
false
;
}
break
;
}
}
if
(
aResult
)
{
MOZ_ASSERT
(
mOffsetHead
<
EVENTS_PER_PAGE
)
;
MOZ_ASSERT_IF
(
mHead
=
=
mTail
mOffsetHead
<
=
mOffsetTail
)
;
*
aResult
=
mHead
-
>
mEvents
[
mOffsetHead
+
+
]
;
MOZ_ASSERT
(
*
aResult
)
;
MOZ_ASSERT
(
mOffsetHead
<
=
EVENTS_PER_PAGE
)
;
if
(
mOffsetHead
=
=
EVENTS_PER_PAGE
)
{
Page
*
dead
=
mHead
;
mHead
=
mHead
-
>
mNext
;
FreePage
(
dead
)
;
mOffsetHead
=
0
;
}
}
return
true
;
}
void
nsEventQueue
:
:
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
MutexAutoLock
&
aProofOfLock
)
{
if
(
!
mHead
)
{
mHead
=
NewPage
(
)
;
MOZ_ASSERT
(
mHead
)
;
mTail
=
mHead
;
mOffsetHead
=
0
;
mOffsetTail
=
0
;
}
else
if
(
mOffsetTail
=
=
EVENTS_PER_PAGE
)
{
Page
*
page
=
NewPage
(
)
;
MOZ_ASSERT
(
page
)
;
mTail
-
>
mNext
=
page
;
mTail
=
page
;
mOffsetTail
=
0
;
}
nsIRunnable
*
&
queueLocation
=
mTail
-
>
mEvents
[
mOffsetTail
]
;
MOZ_ASSERT
(
!
queueLocation
)
;
queueLocation
=
aRunnable
.
take
(
)
;
+
+
mOffsetTail
;
LOG
(
(
"
EVENTQ
(
%
p
)
:
notify
\
n
"
this
)
)
;
mEventsAvailable
.
Notify
(
)
;
}
void
nsEventQueue
:
:
PutEvent
(
nsIRunnable
*
aRunnable
MutexAutoLock
&
aProofOfLock
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aRunnable
)
;
PutEvent
(
event
.
forget
(
)
aProofOfLock
)
;
}
size_t
nsEventQueue
:
:
Count
(
MutexAutoLock
&
aProofOfLock
)
const
{
if
(
!
mHead
)
{
return
0
;
}
int
count
=
-
mOffsetHead
;
for
(
Page
*
page
=
mHead
;
page
!
=
mTail
;
page
=
page
-
>
mNext
)
{
count
+
=
EVENTS_PER_PAGE
;
}
count
+
=
mOffsetTail
;
MOZ_ASSERT
(
count
>
=
0
)
;
return
count
;
}
