#
ifndef
nsThreadManager_h__
#
define
nsThreadManager_h__
#
include
"
nsIThreadManager
.
h
"
#
include
"
nsThread
.
h
"
class
nsIRunnable
;
class
nsIEventTarget
;
class
nsISerialEventTarget
;
class
nsIThread
;
namespace
mozilla
{
class
IdleTaskManager
;
class
SynchronizedEventQueue
;
}
class
BackgroundEventTarget
;
class
nsThreadManager
:
public
nsIThreadManager
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSITHREADMANAGER
static
nsThreadManager
&
get
(
)
;
static
void
InitializeShutdownObserver
(
)
;
nsresult
Init
(
)
;
void
Shutdown
(
)
;
void
RegisterCurrentThread
(
nsThread
&
aThread
)
;
void
UnregisterCurrentThread
(
nsThread
&
aThread
)
;
nsThread
*
GetCurrentThread
(
)
;
bool
IsNSThread
(
)
const
;
nsThread
*
CreateCurrentThread
(
mozilla
:
:
SynchronizedEventQueue
*
aQueue
nsThread
:
:
MainThreadFlag
aMainThread
)
;
nsresult
DispatchToBackgroundThread
(
nsIRunnable
*
aEvent
uint32_t
aDispatchFlags
)
;
already_AddRefed
<
nsISerialEventTarget
>
CreateBackgroundTaskQueue
(
const
char
*
aName
)
;
uint32_t
GetHighestNumberOfThreads
(
)
;
~
nsThreadManager
(
)
;
void
EnableMainThreadEventPrioritization
(
)
;
void
FlushInputEventPrioritization
(
)
;
void
SuspendInputEventPrioritization
(
)
;
void
ResumeInputEventPrioritization
(
)
;
static
bool
MainThreadHasPendingHighPriorityEvents
(
)
;
nsIThread
*
GetMainThreadWeak
(
)
{
return
mMainThread
;
}
private
:
nsThreadManager
(
)
;
nsresult
SpinEventLoopUntilInternal
(
nsINestedEventLoopCondition
*
aCondition
bool
aCheckingShutdown
)
;
static
void
ReleaseThread
(
void
*
aData
)
;
unsigned
mCurThreadIndex
;
RefPtr
<
mozilla
:
:
IdleTaskManager
>
mIdleTaskManager
;
RefPtr
<
nsThread
>
mMainThread
;
PRThread
*
mMainPRThread
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
SequentiallyConsistent
>
mInitialized
;
RefPtr
<
BackgroundEventTarget
>
mBackgroundEventTarget
;
}
;
#
define
NS_THREADMANAGER_CID
\
{
/
*
7a4204c6
-
e45a
-
4c37
-
8ebb
-
6709a22c917c
*
/
\
0x7a4204c6
0xe45a
0x4c37
{
\
0x8e
0xbb
0x67
0x09
0xa2
0x2c
0x91
0x7c
\
}
\
}
#
endif
