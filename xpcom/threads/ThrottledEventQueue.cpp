#
include
"
ThrottledEventQueue
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsEventQueue
.
h
"
namespace
mozilla
{
using
mozilla
:
:
services
:
:
GetObserverService
;
namespace
{
static
const
char
kShutdownTopic
[
]
=
"
xpcom
-
shutdown
"
;
}
class
ThrottledEventQueue
:
:
Inner
final
:
public
nsIObserver
{
class
Executor
final
:
public
Runnable
{
RefPtr
<
Inner
>
mInner
;
public
:
explicit
Executor
(
Inner
*
aInner
)
:
mInner
(
aInner
)
{
}
NS_IMETHODIMP
Run
(
)
override
{
mInner
-
>
ExecuteRunnable
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
GetName
(
nsACString
&
aName
)
override
{
return
mInner
-
>
CurrentName
(
aName
)
;
}
}
;
mutable
Mutex
mMutex
;
mutable
CondVar
mIdleCondVar
;
mozilla
:
:
CondVar
mEventsAvailable
;
nsEventQueue
mEventQueue
;
nsCOMPtr
<
nsIEventTarget
>
mBaseTarget
;
nsCOMPtr
<
nsIRunnable
>
mExecutor
;
Atomic
<
uint32_t
>
mExecutionDepth
;
bool
mShutdownStarted
;
explicit
Inner
(
nsIEventTarget
*
aBaseTarget
)
:
mMutex
(
"
ThrottledEventQueue
"
)
mIdleCondVar
(
mMutex
"
ThrottledEventQueue
:
Idle
"
)
mEventsAvailable
(
mMutex
"
[
ThrottledEventQueue
:
:
Inner
.
mEventsAvailable
]
"
)
mEventQueue
(
mEventsAvailable
nsEventQueue
:
:
eNormalQueue
)
mBaseTarget
(
aBaseTarget
)
mExecutionDepth
(
0
)
mShutdownStarted
(
false
)
{
}
~
Inner
(
)
{
MOZ_ASSERT
(
!
mExecutor
)
;
MOZ_ASSERT
(
mShutdownStarted
)
;
}
nsresult
CurrentName
(
nsACString
&
aName
)
{
nsCOMPtr
<
nsIRunnable
>
event
;
#
ifdef
DEBUG
bool
currentThread
=
false
;
mBaseTarget
-
>
IsOnCurrentThread
(
&
currentThread
)
;
MOZ_ASSERT
(
currentThread
)
;
#
endif
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ALWAYS_TRUE
(
mEventQueue
.
PeekEvent
(
getter_AddRefs
(
event
)
lock
)
)
;
}
if
(
nsCOMPtr
<
nsINamed
>
named
=
do_QueryInterface
(
event
)
)
{
mExecutionDepth
+
+
;
nsresult
rv
=
named
-
>
GetName
(
aName
)
;
mExecutionDepth
-
-
;
return
rv
;
}
aName
.
AssignLiteral
(
"
non
-
nsINamed
ThrottledEventQueue
runnable
"
)
;
return
NS_OK
;
}
void
ExecuteRunnable
(
)
{
nsCOMPtr
<
nsIRunnable
>
event
;
bool
shouldShutdown
=
false
;
#
ifdef
DEBUG
bool
currentThread
=
false
;
mBaseTarget
-
>
IsOnCurrentThread
(
&
currentThread
)
;
MOZ_ASSERT
(
currentThread
)
;
#
endif
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ALWAYS_TRUE
(
mEventQueue
.
GetPendingEvent
(
getter_AddRefs
(
event
)
lock
)
)
;
if
(
mEventQueue
.
HasPendingEvent
(
lock
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
mBaseTarget
-
>
Dispatch
(
mExecutor
NS_DISPATCH_NORMAL
)
)
;
}
else
{
shouldShutdown
=
mShutdownStarted
;
mExecutor
=
nullptr
;
mIdleCondVar
.
NotifyAll
(
)
;
}
}
+
+
mExecutionDepth
;
Unused
<
<
event
-
>
Run
(
)
;
-
-
mExecutionDepth
;
if
(
shouldShutdown
)
{
MOZ_ASSERT
(
IsEmpty
(
)
)
;
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
ThrottledEventQueue
:
:
Inner
:
:
ShutdownComplete
"
this
&
Inner
:
:
ShutdownComplete
)
)
;
}
}
void
ShutdownComplete
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
IsEmpty
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
GetObserverService
(
)
;
obs
-
>
RemoveObserver
(
this
kShutdownTopic
)
;
}
public
:
static
already_AddRefed
<
Inner
>
Create
(
nsIEventTarget
*
aBaseTarget
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
ClearOnShutdown_Internal
:
:
sCurrentShutdownPhase
!
=
ShutdownPhase
:
:
NotInShutdown
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obs
)
)
{
return
nullptr
;
}
RefPtr
<
Inner
>
ref
=
new
Inner
(
aBaseTarget
)
;
nsresult
rv
=
obs
-
>
AddObserver
(
ref
kShutdownTopic
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ref
-
>
MaybeStartShutdown
(
)
;
MOZ_ASSERT
(
ref
-
>
IsEmpty
(
)
)
;
return
nullptr
;
}
return
ref
.
forget
(
)
;
}
NS_IMETHOD
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
strcmp
(
aTopic
kShutdownTopic
)
)
;
MaybeStartShutdown
(
)
;
while
(
!
IsEmpty
(
)
)
{
MOZ_ALWAYS_TRUE
(
NS_ProcessNextEvent
(
)
)
;
}
return
NS_OK
;
}
void
MaybeStartShutdown
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mShutdownStarted
)
{
return
;
}
mShutdownStarted
=
true
;
if
(
mExecutor
)
{
return
;
}
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
ThrottledEventQueue
:
:
Inner
:
:
ShutdownComplete
"
this
&
Inner
:
:
ShutdownComplete
)
)
;
}
bool
IsEmpty
(
)
const
{
return
Length
(
)
=
=
0
;
}
uint32_t
Length
(
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
return
mEventQueue
.
Count
(
lock
)
;
}
void
AwaitIdle
(
)
const
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
#
ifdef
DEBUG
bool
onBaseTarget
=
false
;
Unused
<
<
mBaseTarget
-
>
IsOnCurrentThread
(
&
onBaseTarget
)
;
MOZ_ASSERT
(
!
onBaseTarget
)
;
#
endif
MutexAutoLock
lock
(
mMutex
)
;
while
(
mExecutor
)
{
mIdleCondVar
.
Wait
(
)
;
}
}
nsresult
DispatchFromScript
(
nsIRunnable
*
aEvent
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
aEvent
;
return
Dispatch
(
r
.
forget
(
)
aFlags
)
;
}
nsresult
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
=
=
NS_DISPATCH_NORMAL
|
|
aFlags
=
=
NS_DISPATCH_AT_END
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
mShutdownStarted
)
{
return
mBaseTarget
-
>
Dispatch
(
Move
(
aEvent
)
aFlags
)
;
}
if
(
!
mExecutor
)
{
mExecutor
=
new
Executor
(
this
)
;
nsresult
rv
=
mBaseTarget
-
>
Dispatch
(
mExecutor
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mExecutor
=
nullptr
;
return
rv
;
}
}
mEventQueue
.
PutEvent
(
Move
(
aEvent
)
lock
)
;
return
NS_OK
;
}
nsresult
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aDelay
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
IsOnCurrentThread
(
bool
*
aResult
)
{
bool
shutdownAndIdle
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
shutdownAndIdle
=
mShutdownStarted
&
&
mEventQueue
.
Count
(
lock
)
=
=
0
;
}
bool
onBaseTarget
=
false
;
nsresult
rv
=
mBaseTarget
-
>
IsOnCurrentThread
(
&
onBaseTarget
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aResult
=
onBaseTarget
&
&
(
mExecutionDepth
|
|
shutdownAndIdle
)
;
return
NS_OK
;
}
NS_DECL_THREADSAFE_ISUPPORTS
}
;
NS_IMPL_ISUPPORTS
(
ThrottledEventQueue
:
:
Inner
nsIObserver
)
;
NS_IMPL_ISUPPORTS
(
ThrottledEventQueue
ThrottledEventQueue
nsIEventTarget
)
;
ThrottledEventQueue
:
:
ThrottledEventQueue
(
already_AddRefed
<
Inner
>
aInner
)
:
mInner
(
aInner
)
{
MOZ_ASSERT
(
mInner
)
;
}
ThrottledEventQueue
:
:
~
ThrottledEventQueue
(
)
{
mInner
-
>
MaybeStartShutdown
(
)
;
}
void
ThrottledEventQueue
:
:
MaybeStartShutdown
(
)
{
return
mInner
-
>
MaybeStartShutdown
(
)
;
}
already_AddRefed
<
ThrottledEventQueue
>
ThrottledEventQueue
:
:
Create
(
nsIEventTarget
*
aBaseTarget
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aBaseTarget
)
;
RefPtr
<
Inner
>
inner
=
Inner
:
:
Create
(
aBaseTarget
)
;
if
(
NS_WARN_IF
(
!
inner
)
)
{
return
nullptr
;
}
RefPtr
<
ThrottledEventQueue
>
ref
=
new
ThrottledEventQueue
(
inner
.
forget
(
)
)
;
return
ref
.
forget
(
)
;
}
bool
ThrottledEventQueue
:
:
IsEmpty
(
)
const
{
return
mInner
-
>
IsEmpty
(
)
;
}
uint32_t
ThrottledEventQueue
:
:
Length
(
)
const
{
return
mInner
-
>
Length
(
)
;
}
void
ThrottledEventQueue
:
:
AwaitIdle
(
)
const
{
return
mInner
-
>
AwaitIdle
(
)
;
}
NS_IMETHODIMP
ThrottledEventQueue
:
:
DispatchFromScript
(
nsIRunnable
*
aEvent
uint32_t
aFlags
)
{
return
mInner
-
>
DispatchFromScript
(
aEvent
aFlags
)
;
}
NS_IMETHODIMP
ThrottledEventQueue
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
return
mInner
-
>
Dispatch
(
Move
(
aEvent
)
aFlags
)
;
}
NS_IMETHODIMP
ThrottledEventQueue
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
return
mInner
-
>
DelayedDispatch
(
Move
(
aEvent
)
aFlags
)
;
}
NS_IMETHODIMP
ThrottledEventQueue
:
:
IsOnCurrentThread
(
bool
*
aResult
)
{
return
mInner
-
>
IsOnCurrentThread
(
aResult
)
;
}
}
