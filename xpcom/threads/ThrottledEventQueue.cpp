#
include
"
ThrottledEventQueue
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
{
}
class
ThrottledEventQueue
:
:
Inner
final
:
public
nsISupports
{
class
Executor
final
:
public
Runnable
{
RefPtr
<
Inner
>
mInner
;
public
:
explicit
Executor
(
Inner
*
aInner
)
:
Runnable
(
"
ThrottledEventQueue
:
:
Inner
:
:
Executor
"
)
mInner
(
aInner
)
{
}
NS_IMETHODIMP
Run
(
)
override
{
mInner
-
>
ExecuteRunnable
(
)
;
return
NS_OK
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
NS_IMETHODIMP
GetName
(
nsACString
&
aName
)
override
{
return
mInner
-
>
CurrentName
(
aName
)
;
}
#
endif
}
;
mutable
Mutex
mMutex
;
mutable
CondVar
mIdleCondVar
;
EventQueue
mEventQueue
;
nsCOMPtr
<
nsISerialEventTarget
>
mBaseTarget
;
nsCOMPtr
<
nsIRunnable
>
mExecutor
;
bool
mIsPaused
;
explicit
Inner
(
nsISerialEventTarget
*
aBaseTarget
)
:
mMutex
(
"
ThrottledEventQueue
"
)
mIdleCondVar
(
mMutex
"
ThrottledEventQueue
:
Idle
"
)
mBaseTarget
(
aBaseTarget
)
mIsPaused
(
false
)
{
}
~
Inner
(
)
{
#
ifdef
DEBUG
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
!
mExecutor
)
;
MOZ_ASSERT
(
mEventQueue
.
IsEmpty
(
lock
)
|
|
IsPaused
(
lock
)
)
;
MOZ_ASSERT_IF
(
!
mEventQueue
.
IsEmpty
(
lock
)
NS_IsMainThread
(
)
)
;
#
endif
}
nsresult
EnsureExecutor
(
MutexAutoLock
&
lock
)
{
if
(
mExecutor
)
return
NS_OK
;
mExecutor
=
new
Executor
(
this
)
;
nsresult
rv
=
mBaseTarget
-
>
Dispatch
(
mExecutor
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mExecutor
=
nullptr
;
return
rv
;
}
return
NS_OK
;
}
nsresult
CurrentName
(
nsACString
&
aName
)
{
nsCOMPtr
<
nsIRunnable
>
event
;
#
ifdef
DEBUG
bool
currentThread
=
false
;
mBaseTarget
-
>
IsOnCurrentThread
(
&
currentThread
)
;
MOZ_ASSERT
(
currentThread
)
;
#
endif
{
MutexAutoLock
lock
(
mMutex
)
;
event
=
mEventQueue
.
PeekEvent
(
lock
)
;
MOZ_ALWAYS_TRUE
(
event
)
;
}
if
(
nsCOMPtr
<
nsINamed
>
named
=
do_QueryInterface
(
event
)
)
{
nsresult
rv
=
named
-
>
GetName
(
aName
)
;
return
rv
;
}
aName
.
AssignLiteral
(
"
non
-
nsINamed
ThrottledEventQueue
runnable
"
)
;
return
NS_OK
;
}
void
ExecuteRunnable
(
)
{
nsCOMPtr
<
nsIRunnable
>
event
;
#
ifdef
DEBUG
bool
currentThread
=
false
;
mBaseTarget
-
>
IsOnCurrentThread
(
&
currentThread
)
;
MOZ_ASSERT
(
currentThread
)
;
#
endif
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
IsPaused
(
lock
)
)
{
mExecutor
=
nullptr
;
return
;
}
event
=
mEventQueue
.
GetEvent
(
nullptr
lock
)
;
MOZ_ASSERT
(
event
)
;
if
(
mEventQueue
.
HasReadyEvent
(
lock
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
mBaseTarget
-
>
Dispatch
(
mExecutor
NS_DISPATCH_NORMAL
)
)
;
}
else
{
mExecutor
=
nullptr
;
mIdleCondVar
.
NotifyAll
(
)
;
}
}
Unused
<
<
event
-
>
Run
(
)
;
}
public
:
static
already_AddRefed
<
Inner
>
Create
(
nsISerialEventTarget
*
aBaseTarget
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
ClearOnShutdown_Internal
:
:
sCurrentShutdownPhase
=
=
ShutdownPhase
:
:
NotInShutdown
)
;
RefPtr
<
Inner
>
ref
=
new
Inner
(
aBaseTarget
)
;
return
ref
.
forget
(
)
;
}
bool
IsEmpty
(
)
const
{
return
Length
(
)
=
=
0
;
}
uint32_t
Length
(
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
return
mEventQueue
.
Count
(
lock
)
;
}
void
AwaitIdle
(
)
const
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
#
ifdef
DEBUG
bool
onBaseTarget
=
false
;
Unused
<
<
mBaseTarget
-
>
IsOnCurrentThread
(
&
onBaseTarget
)
;
MOZ_ASSERT
(
!
onBaseTarget
)
;
#
endif
MutexAutoLock
lock
(
mMutex
)
;
while
(
mExecutor
|
|
IsPaused
(
lock
)
)
{
mIdleCondVar
.
Wait
(
)
;
}
}
bool
IsPaused
(
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
return
IsPaused
(
lock
)
;
}
bool
IsPaused
(
const
MutexAutoLock
&
aProofOfLock
)
const
{
return
mIsPaused
;
}
nsresult
SetIsPaused
(
bool
aIsPaused
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
aIsPaused
&
&
!
mEventQueue
.
IsEmpty
(
lock
)
)
{
nsresult
rv
=
EnsureExecutor
(
lock
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
mIsPaused
=
aIsPaused
;
return
NS_OK
;
}
nsresult
DispatchFromScript
(
nsIRunnable
*
aEvent
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
aEvent
;
return
Dispatch
(
r
.
forget
(
)
aFlags
)
;
}
nsresult
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
=
=
NS_DISPATCH_NORMAL
|
|
aFlags
=
=
NS_DISPATCH_AT_END
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
IsPaused
(
lock
)
)
{
nsresult
rv
=
EnsureExecutor
(
lock
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
mEventQueue
.
PutEvent
(
std
:
:
move
(
aEvent
)
EventPriority
:
:
Normal
lock
)
;
return
NS_OK
;
}
nsresult
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aDelay
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
bool
IsOnCurrentThread
(
)
{
return
mBaseTarget
-
>
IsOnCurrentThread
(
)
;
}
NS_DECL_THREADSAFE_ISUPPORTS
}
;
NS_IMPL_ISUPPORTS
(
ThrottledEventQueue
:
:
Inner
nsISupports
)
;
NS_IMPL_ISUPPORTS
(
ThrottledEventQueue
ThrottledEventQueue
nsIEventTarget
nsISerialEventTarget
)
;
ThrottledEventQueue
:
:
ThrottledEventQueue
(
already_AddRefed
<
Inner
>
aInner
)
:
mInner
(
aInner
)
{
MOZ_ASSERT
(
mInner
)
;
}
already_AddRefed
<
ThrottledEventQueue
>
ThrottledEventQueue
:
:
Create
(
nsISerialEventTarget
*
aBaseTarget
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aBaseTarget
)
;
RefPtr
<
Inner
>
inner
=
Inner
:
:
Create
(
aBaseTarget
)
;
RefPtr
<
ThrottledEventQueue
>
ref
=
new
ThrottledEventQueue
(
inner
.
forget
(
)
)
;
return
ref
.
forget
(
)
;
}
bool
ThrottledEventQueue
:
:
IsEmpty
(
)
const
{
return
mInner
-
>
IsEmpty
(
)
;
}
uint32_t
ThrottledEventQueue
:
:
Length
(
)
const
{
return
mInner
-
>
Length
(
)
;
}
void
ThrottledEventQueue
:
:
AwaitIdle
(
)
const
{
return
mInner
-
>
AwaitIdle
(
)
;
}
nsresult
ThrottledEventQueue
:
:
SetIsPaused
(
bool
aIsPaused
)
{
return
mInner
-
>
SetIsPaused
(
aIsPaused
)
;
}
bool
ThrottledEventQueue
:
:
IsPaused
(
)
const
{
return
mInner
-
>
IsPaused
(
)
;
}
NS_IMETHODIMP
ThrottledEventQueue
:
:
DispatchFromScript
(
nsIRunnable
*
aEvent
uint32_t
aFlags
)
{
return
mInner
-
>
DispatchFromScript
(
aEvent
aFlags
)
;
}
NS_IMETHODIMP
ThrottledEventQueue
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
return
mInner
-
>
Dispatch
(
std
:
:
move
(
aEvent
)
aFlags
)
;
}
NS_IMETHODIMP
ThrottledEventQueue
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
return
mInner
-
>
DelayedDispatch
(
std
:
:
move
(
aEvent
)
aFlags
)
;
}
NS_IMETHODIMP
ThrottledEventQueue
:
:
IsOnCurrentThread
(
bool
*
aResult
)
{
*
aResult
=
mInner
-
>
IsOnCurrentThread
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
bool
)
ThrottledEventQueue
:
:
IsOnCurrentThreadInfallible
(
)
{
return
mInner
-
>
IsOnCurrentThread
(
)
;
}
}
