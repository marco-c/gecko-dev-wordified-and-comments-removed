#
include
"
nsThreadManager
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIClassInfoImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
LabeledEventQueue
.
h
"
#
include
"
MainThreadQueue
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Scheduler
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadEventQueue
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
PrioritizedEventQueue
.
h
"
#
ifdef
MOZ_CANARY
#
include
<
fcntl
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
include
"
MainThreadIdlePeriod
.
h
"
#
include
"
InputEventStatistics
.
h
"
using
namespace
mozilla
;
static
MOZ_THREAD_LOCAL
(
bool
)
sTLSIsMainThread
;
static
MOZ_THREAD_LOCAL
(
PRThread
*
)
gTlsCurrentVirtualThread
;
bool
NS_IsMainThreadTLSInitialized
(
)
{
return
sTLSIsMainThread
.
initialized
(
)
;
}
bool
NS_IsMainThread
(
)
{
return
sTLSIsMainThread
.
get
(
)
;
}
void
NS_SetMainThread
(
)
{
if
(
!
sTLSIsMainThread
.
init
(
)
)
{
MOZ_CRASH
(
)
;
}
sTLSIsMainThread
.
set
(
true
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
NS_SetMainThread
(
PRThread
*
aVirtualThread
)
{
MOZ_ASSERT
(
Scheduler
:
:
IsCooperativeThread
(
)
)
;
MOZ_ASSERT
(
!
gTlsCurrentVirtualThread
.
get
(
)
)
;
gTlsCurrentVirtualThread
.
set
(
aVirtualThread
)
;
NS_SetMainThread
(
)
;
}
void
NS_UnsetMainThread
(
)
{
MOZ_ASSERT
(
Scheduler
:
:
IsCooperativeThread
(
)
)
;
sTLSIsMainThread
.
set
(
false
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
gTlsCurrentVirtualThread
.
set
(
nullptr
)
;
}
#
ifdef
DEBUG
namespace
mozilla
{
void
AssertIsOnMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
}
}
#
endif
typedef
nsTArray
<
NotNull
<
RefPtr
<
nsThread
>
>
>
nsThreadArray
;
static
void
ReleaseObject
(
void
*
aData
)
{
static_cast
<
nsISupports
*
>
(
aData
)
-
>
Release
(
)
;
}
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsThreadManager
:
:
AddRef
(
)
{
return
2
;
}
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsThreadManager
:
:
Release
(
)
{
return
1
;
}
NS_IMPL_CLASSINFO
(
nsThreadManager
nullptr
nsIClassInfo
:
:
THREADSAFE
|
nsIClassInfo
:
:
SINGLETON
NS_THREADMANAGER_CID
)
NS_IMPL_QUERY_INTERFACE_CI
(
nsThreadManager
nsIThreadManager
)
NS_IMPL_CI_INTERFACE_GETTER
(
nsThreadManager
nsIThreadManager
)
namespace
{
class
ShutdownObserveHelper
final
:
public
nsIObserver
public
nsSupportsWeakReference
{
public
:
NS_DECL_ISUPPORTS
static
nsresult
Create
(
ShutdownObserveHelper
*
*
aObserver
)
{
MOZ_ASSERT
(
aObserver
)
;
RefPtr
<
ShutdownObserveHelper
>
observer
=
new
ShutdownObserveHelper
(
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obs
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
obs
-
>
AddObserver
(
observer
NS_XPCOM_SHUTDOWN_OBSERVER_ID
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
obs
-
>
AddObserver
(
observer
"
content
-
child
-
will
-
shutdown
"
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
observer
.
forget
(
aObserver
)
;
return
NS_OK
;
}
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
if
(
!
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
|
|
!
strcmp
(
aTopic
"
content
-
child
-
will
-
shutdown
"
)
)
{
mShuttingDown
=
true
;
return
NS_OK
;
}
return
NS_OK
;
}
bool
ShuttingDown
(
)
const
{
return
mShuttingDown
;
}
private
:
explicit
ShutdownObserveHelper
(
)
:
mShuttingDown
(
false
)
{
}
~
ShutdownObserveHelper
(
)
=
default
;
bool
mShuttingDown
;
}
;
NS_INTERFACE_MAP_BEGIN
(
ShutdownObserveHelper
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIObserver
)
NS_INTERFACE_MAP_END
NS_IMPL_ADDREF
(
ShutdownObserveHelper
)
NS_IMPL_RELEASE
(
ShutdownObserveHelper
)
StaticRefPtr
<
ShutdownObserveHelper
>
gShutdownObserveHelper
;
}
nsThreadManager
&
nsThreadManager
:
:
get
(
)
{
static
nsThreadManager
sInstance
;
return
sInstance
;
}
void
nsThreadManager
:
:
InitializeShutdownObserver
(
)
{
MOZ_ASSERT
(
!
gShutdownObserveHelper
)
;
RefPtr
<
ShutdownObserveHelper
>
observer
;
nsresult
rv
=
ShutdownObserveHelper
:
:
Create
(
getter_AddRefs
(
observer
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
gShutdownObserveHelper
=
observer
;
ClearOnShutdown
(
&
gShutdownObserveHelper
)
;
}
nsresult
nsThreadManager
:
:
Init
(
)
{
if
(
mInitialized
)
{
return
NS_OK
;
}
if
(
!
gTlsCurrentVirtualThread
.
init
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
Scheduler
:
:
EventLoopActivation
:
:
Init
(
)
;
if
(
PR_NewThreadPrivateIndex
(
&
mCurThreadIndex
ReleaseObject
)
=
=
PR_FAILURE
)
{
return
NS_ERROR_FAILURE
;
}
#
ifdef
MOZ_CANARY
const
int
flags
=
O_WRONLY
|
O_APPEND
|
O_CREAT
|
O_NONBLOCK
;
const
mode_t
mode
=
S_IRUSR
|
S_IWUSR
|
S_IRGRP
|
S_IROTH
;
char
*
env_var_flag
=
getenv
(
"
MOZ_KILL_CANARIES
"
)
;
sCanaryOutputFD
=
env_var_flag
?
(
env_var_flag
[
0
]
?
open
(
env_var_flag
flags
mode
)
:
STDERR_FILENO
)
:
0
;
#
endif
nsCOMPtr
<
nsIIdlePeriod
>
idlePeriod
=
new
MainThreadIdlePeriod
(
)
;
bool
startScheduler
=
false
;
if
(
XRE_IsContentProcess
(
)
&
&
Scheduler
:
:
IsSchedulerEnabled
(
)
)
{
mMainThread
=
Scheduler
:
:
Init
(
idlePeriod
)
;
startScheduler
=
true
;
}
else
{
if
(
XRE_IsContentProcess
(
)
&
&
Scheduler
:
:
UseMultipleQueues
(
)
)
{
mMainThread
=
CreateMainThread
<
ThreadEventQueue
<
PrioritizedEventQueue
<
LabeledEventQueue
>
>
LabeledEventQueue
>
(
idlePeriod
)
;
}
else
{
mMainThread
=
CreateMainThread
<
ThreadEventQueue
<
PrioritizedEventQueue
<
EventQueue
>
>
EventQueue
>
(
idlePeriod
)
;
}
}
nsresult
rv
=
mMainThread
-
>
InitCurrentThread
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
mMainThread
=
nullptr
;
return
rv
;
}
mMainThread
-
>
GetPRThread
(
&
mMainPRThread
)
;
AbstractThread
:
:
InitTLS
(
)
;
AbstractThread
:
:
InitMainThread
(
)
;
mInitialized
=
true
;
if
(
startScheduler
)
{
Scheduler
:
:
Start
(
)
;
}
return
NS_OK
;
}
void
nsThreadManager
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
shutdown
not
called
from
main
thread
"
)
;
mInitialized
=
false
;
NS_ProcessPendingEvents
(
mMainThread
)
;
nsThreadArray
threads
;
{
OffTheBooksMutexAutoLock
lock
(
mLock
)
;
for
(
auto
iter
=
mThreadsByPRThread
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
nsThread
>
&
thread
=
iter
.
Data
(
)
;
threads
.
AppendElement
(
WrapNotNull
(
thread
)
)
;
iter
.
Remove
(
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
threads
.
Length
(
)
;
+
+
i
)
{
NotNull
<
nsThread
*
>
thread
=
threads
[
i
]
;
if
(
thread
-
>
ShutdownRequired
(
)
)
{
thread
-
>
Shutdown
(
)
;
}
}
mMainThread
-
>
WaitForAllAsynchronousShutdowns
(
)
;
NS_ProcessPendingEvents
(
mMainThread
)
;
{
OffTheBooksMutexAutoLock
lock
(
mLock
)
;
mThreadsByPRThread
.
Clear
(
)
;
}
mMainThread
-
>
SetObserver
(
nullptr
)
;
mMainThread
=
nullptr
;
PR_SetThreadPrivate
(
mCurThreadIndex
nullptr
)
;
}
void
nsThreadManager
:
:
RegisterCurrentThread
(
nsThread
&
aThread
)
{
MOZ_ASSERT
(
aThread
.
GetPRThread
(
)
=
=
PR_GetCurrentThread
(
)
"
bad
aThread
"
)
;
OffTheBooksMutexAutoLock
lock
(
mLock
)
;
+
+
mCurrentNumberOfThreads
;
if
(
mCurrentNumberOfThreads
>
mHighestNumberOfThreads
)
{
mHighestNumberOfThreads
=
mCurrentNumberOfThreads
;
}
mThreadsByPRThread
.
Put
(
aThread
.
GetPRThread
(
)
&
aThread
)
;
aThread
.
AddRef
(
)
;
PR_SetThreadPrivate
(
mCurThreadIndex
&
aThread
)
;
}
void
nsThreadManager
:
:
UnregisterCurrentThread
(
nsThread
&
aThread
)
{
MOZ_ASSERT
(
aThread
.
GetPRThread
(
)
=
=
PR_GetCurrentThread
(
)
"
bad
aThread
"
)
;
OffTheBooksMutexAutoLock
lock
(
mLock
)
;
-
-
mCurrentNumberOfThreads
;
mThreadsByPRThread
.
Remove
(
aThread
.
GetPRThread
(
)
)
;
PR_SetThreadPrivate
(
mCurThreadIndex
nullptr
)
;
}
nsThread
*
nsThreadManager
:
:
CreateCurrentThread
(
SynchronizedEventQueue
*
aQueue
nsThread
:
:
MainThreadFlag
aMainThread
)
{
MOZ_ASSERT
(
!
PR_GetThreadPrivate
(
mCurThreadIndex
)
)
;
if
(
!
mInitialized
)
{
return
nullptr
;
}
RefPtr
<
nsThread
>
thread
=
new
nsThread
(
WrapNotNull
(
aQueue
)
aMainThread
0
)
;
if
(
!
thread
|
|
NS_FAILED
(
thread
-
>
InitCurrentThread
(
)
)
)
{
return
nullptr
;
}
return
thread
.
get
(
)
;
}
nsThread
*
nsThreadManager
:
:
GetCurrentThread
(
)
{
void
*
data
=
PR_GetThreadPrivate
(
mCurThreadIndex
)
;
if
(
data
)
{
return
static_cast
<
nsThread
*
>
(
data
)
;
}
if
(
!
mInitialized
)
{
return
nullptr
;
}
RefPtr
<
ThreadEventQueue
<
EventQueue
>
>
queue
=
new
ThreadEventQueue
<
EventQueue
>
(
MakeUnique
<
EventQueue
>
(
)
)
;
RefPtr
<
nsThread
>
thread
=
new
nsThread
(
WrapNotNull
(
queue
)
nsThread
:
:
NOT_MAIN_THREAD
0
)
;
if
(
!
thread
|
|
NS_FAILED
(
thread
-
>
InitCurrentThread
(
)
)
)
{
return
nullptr
;
}
return
thread
.
get
(
)
;
}
bool
nsThreadManager
:
:
IsNSThread
(
)
const
{
if
(
!
mInitialized
)
{
return
false
;
}
if
(
auto
*
thread
=
(
nsThread
*
)
PR_GetThreadPrivate
(
mCurThreadIndex
)
)
{
return
thread
-
>
mShutdownRequired
;
}
return
false
;
}
NS_IMETHODIMP
nsThreadManager
:
:
NewThread
(
uint32_t
aCreationFlags
uint32_t
aStackSize
nsIThread
*
*
aResult
)
{
return
NewNamedThread
(
NS_LITERAL_CSTRING
(
"
"
)
aStackSize
aResult
)
;
}
NS_IMETHODIMP
nsThreadManager
:
:
NewNamedThread
(
const
nsACString
&
aName
uint32_t
aStackSize
nsIThread
*
*
aResult
)
{
if
(
NS_WARN_IF
(
!
mInitialized
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
ThreadEventQueue
<
EventQueue
>
>
queue
=
new
ThreadEventQueue
<
EventQueue
>
(
MakeUnique
<
EventQueue
>
(
)
)
;
RefPtr
<
nsThread
>
thr
=
new
nsThread
(
WrapNotNull
(
queue
)
nsThread
:
:
NOT_MAIN_THREAD
aStackSize
)
;
nsresult
rv
=
thr
-
>
Init
(
aName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
mInitialized
)
)
{
if
(
thr
-
>
ShutdownRequired
(
)
)
{
thr
-
>
Shutdown
(
)
;
}
return
NS_ERROR_NOT_INITIALIZED
;
}
thr
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetThreadFromPRThread
(
PRThread
*
aThread
nsIThread
*
*
aResult
)
{
if
(
NS_WARN_IF
(
!
mMainThread
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
NS_WARN_IF
(
!
aThread
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
nsThread
>
temp
;
{
OffTheBooksMutexAutoLock
lock
(
mLock
)
;
mThreadsByPRThread
.
Get
(
aThread
getter_AddRefs
(
temp
)
)
;
}
NS_IF_ADDREF
(
*
aResult
=
temp
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetMainThread
(
nsIThread
*
*
aResult
)
{
if
(
NS_WARN_IF
(
!
mMainThread
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
NS_ADDREF
(
*
aResult
=
mMainThread
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetCurrentThread
(
nsIThread
*
*
aResult
)
{
if
(
!
mMainThread
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
*
aResult
=
GetCurrentThread
(
)
;
if
(
!
*
aResult
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
NS_ADDREF
(
*
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
SpinEventLoopUntil
(
nsINestedEventLoopCondition
*
aCondition
)
{
return
SpinEventLoopUntilInternal
(
aCondition
false
)
;
}
NS_IMETHODIMP
nsThreadManager
:
:
SpinEventLoopUntilOrShutdown
(
nsINestedEventLoopCondition
*
aCondition
)
{
return
SpinEventLoopUntilInternal
(
aCondition
true
)
;
}
nsresult
nsThreadManager
:
:
SpinEventLoopUntilInternal
(
nsINestedEventLoopCondition
*
aCondition
bool
aCheckingShutdown
)
{
nsCOMPtr
<
nsINestedEventLoopCondition
>
condition
(
aCondition
)
;
nsresult
rv
=
NS_OK
;
if
(
aCheckingShutdown
&
&
(
!
gShutdownObserveHelper
|
|
gShutdownObserveHelper
-
>
ShuttingDown
(
)
)
)
{
return
NS_OK
;
}
if
(
!
mozilla
:
:
SpinEventLoopUntil
(
[
&
]
(
)
-
>
bool
{
if
(
aCheckingShutdown
&
&
(
!
gShutdownObserveHelper
|
|
gShutdownObserveHelper
-
>
ShuttingDown
(
)
)
)
{
return
true
;
}
bool
isDone
=
false
;
rv
=
condition
-
>
IsDone
(
&
isDone
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
true
;
}
return
isDone
;
}
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
rv
;
}
NS_IMETHODIMP
nsThreadManager
:
:
SpinEventLoopUntilEmpty
(
)
{
nsIThread
*
thread
=
NS_GetCurrentThread
(
)
;
while
(
NS_HasPendingEvents
(
thread
)
)
{
(
void
)
NS_ProcessNextEvent
(
thread
false
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetSystemGroupEventTarget
(
nsIEventTarget
*
*
aTarget
)
{
nsCOMPtr
<
nsIEventTarget
>
target
=
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
;
target
.
forget
(
aTarget
)
;
return
NS_OK
;
}
uint32_t
nsThreadManager
:
:
GetHighestNumberOfThreads
(
)
{
OffTheBooksMutexAutoLock
lock
(
mLock
)
;
return
mHighestNumberOfThreads
;
}
NS_IMETHODIMP
nsThreadManager
:
:
DispatchToMainThread
(
nsIRunnable
*
aEvent
uint32_t
aPriority
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
!
mMainThread
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
aPriority
!
=
nsIRunnablePriority
:
:
PRIORITY_NORMAL
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
return
mMainThread
-
>
DispatchFromScript
(
new
PrioritizableRunnable
(
event
.
forget
(
)
aPriority
)
0
)
;
}
return
mMainThread
-
>
DispatchFromScript
(
aEvent
0
)
;
}
void
nsThreadManager
:
:
EnableMainThreadEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
InputEventStatistics
:
:
Get
(
)
.
SetEnable
(
true
)
;
mMainThread
-
>
EnableInputEventPrioritization
(
)
;
}
void
nsThreadManager
:
:
FlushInputEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMainThread
-
>
FlushInputEventPrioritization
(
)
;
}
void
nsThreadManager
:
:
SuspendInputEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMainThread
-
>
SuspendInputEventPrioritization
(
)
;
}
void
nsThreadManager
:
:
ResumeInputEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMainThread
-
>
ResumeInputEventPrioritization
(
)
;
}
NS_IMETHODIMP
nsThreadManager
:
:
IdleDispatchToMainThread
(
nsIRunnable
*
aEvent
uint32_t
aTimeout
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
if
(
aTimeout
)
{
return
NS_IdleDispatchToThread
(
event
.
forget
(
)
aTimeout
mMainThread
)
;
}
return
NS_IdleDispatchToThread
(
event
.
forget
(
)
mMainThread
)
;
}
namespace
mozilla
{
PRThread
*
GetCurrentVirtualThread
(
)
{
if
(
gTlsCurrentVirtualThread
.
initialized
(
)
)
{
if
(
gTlsCurrentVirtualThread
.
get
(
)
)
{
return
gTlsCurrentVirtualThread
.
get
(
)
;
}
}
return
PR_GetCurrentThread
(
)
;
}
PRThread
*
GetCurrentPhysicalThread
(
)
{
return
PR_GetCurrentThread
(
)
;
}
}
