#
include
"
nsThreadManager
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsThreadPool
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIClassInfoImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
MainThreadQueue
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadEventQueue
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
PrioritizedEventQueue
.
h
"
#
ifdef
MOZ_CANARY
#
include
<
fcntl
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
include
"
MainThreadIdlePeriod
.
h
"
#
include
"
InputEventStatistics
.
h
"
using
namespace
mozilla
;
static
MOZ_THREAD_LOCAL
(
bool
)
sTLSIsMainThread
;
static
MOZ_THREAD_LOCAL
(
PRThread
*
)
gTlsCurrentVirtualThread
;
bool
NS_IsMainThreadTLSInitialized
(
)
{
return
sTLSIsMainThread
.
initialized
(
)
;
}
class
BackgroundEventTarget
final
:
public
nsIEventTarget
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIEVENTTARGET_FULL
BackgroundEventTarget
(
)
=
default
;
nsresult
Init
(
)
;
nsresult
Shutdown
(
)
;
private
:
~
BackgroundEventTarget
(
)
=
default
;
nsCOMPtr
<
nsIThreadPool
>
mPool
;
nsCOMPtr
<
nsIThreadPool
>
mIOPool
;
}
;
NS_IMPL_ISUPPORTS
(
BackgroundEventTarget
nsIEventTarget
)
nsresult
BackgroundEventTarget
:
:
Init
(
)
{
nsCOMPtr
<
nsIThreadPool
>
pool
(
new
nsThreadPool
(
)
)
;
NS_ENSURE_TRUE
(
pool
NS_ERROR_FAILURE
)
;
nsresult
rv
=
pool
-
>
SetName
(
NS_LITERAL_CSTRING
(
"
BackgroundThreadPool
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
pool
-
>
SetThreadStackSize
(
nsIThreadManager
:
:
kThreadPoolStackSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
pool
-
>
SetThreadLimit
(
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
pool
-
>
SetIdleThreadTimeout
(
300000
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIThreadPool
>
ioPool
(
new
nsThreadPool
(
)
)
;
NS_ENSURE_TRUE
(
pool
NS_ERROR_FAILURE
)
;
rv
=
ioPool
-
>
SetName
(
NS_LITERAL_CSTRING
(
"
BgIOThreadPool
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ioPool
-
>
SetThreadStackSize
(
nsIThreadManager
:
:
kThreadPoolStackSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ioPool
-
>
SetThreadLimit
(
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ioPool
-
>
SetIdleThreadTimeout
(
300000
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
pool
.
swap
(
mPool
)
;
ioPool
.
swap
(
mIOPool
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
bool
)
BackgroundEventTarget
:
:
IsOnCurrentThreadInfallible
(
)
{
return
mPool
-
>
IsOnCurrentThread
(
)
|
|
mIOPool
-
>
IsOnCurrentThread
(
)
;
}
NS_IMETHODIMP
BackgroundEventTarget
:
:
IsOnCurrentThread
(
bool
*
aValue
)
{
bool
value
=
false
;
if
(
NS_SUCCEEDED
(
mPool
-
>
IsOnCurrentThread
(
&
value
)
)
&
&
value
)
{
*
aValue
=
value
;
return
NS_OK
;
}
return
mIOPool
-
>
IsOnCurrentThread
(
aValue
)
;
}
NS_IMETHODIMP
BackgroundEventTarget
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aFlags
)
{
uint32_t
flags
=
aFlags
&
~
NS_DISPATCH_EVENT_MAY_BLOCK
;
if
(
aFlags
&
NS_DISPATCH_EVENT_MAY_BLOCK
)
{
return
mIOPool
-
>
Dispatch
(
std
:
:
move
(
aRunnable
)
flags
)
;
}
return
mPool
-
>
Dispatch
(
std
:
:
move
(
aRunnable
)
flags
)
;
}
NS_IMETHODIMP
BackgroundEventTarget
:
:
DispatchFromScript
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
return
Dispatch
(
runnable
.
forget
(
)
aFlags
)
;
}
NS_IMETHODIMP
BackgroundEventTarget
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
)
{
nsCOMPtr
<
nsIRunnable
>
dropRunnable
(
aRunnable
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
BackgroundEventTarget
:
:
Shutdown
(
)
{
mPool
-
>
Shutdown
(
)
;
mIOPool
-
>
Shutdown
(
)
;
return
NS_OK
;
}
extern
"
C
"
{
bool
NS_IsMainThread
(
)
{
return
sTLSIsMainThread
.
get
(
)
;
}
}
void
NS_SetMainThread
(
)
{
if
(
!
sTLSIsMainThread
.
init
(
)
)
{
MOZ_CRASH
(
)
;
}
sTLSIsMainThread
.
set
(
true
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
NS_SetMainThread
(
PRThread
*
aVirtualThread
)
{
MOZ_ASSERT
(
!
gTlsCurrentVirtualThread
.
get
(
)
)
;
gTlsCurrentVirtualThread
.
set
(
aVirtualThread
)
;
NS_SetMainThread
(
)
;
}
void
NS_UnsetMainThread
(
)
{
sTLSIsMainThread
.
set
(
false
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
gTlsCurrentVirtualThread
.
set
(
nullptr
)
;
}
#
ifdef
DEBUG
namespace
mozilla
{
void
AssertIsOnMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
}
}
#
endif
typedef
nsTArray
<
NotNull
<
RefPtr
<
nsThread
>
>
>
nsThreadArray
;
static
bool
sShutdownComplete
;
void
nsThreadManager
:
:
ReleaseThread
(
void
*
aData
)
{
if
(
sShutdownComplete
)
{
return
;
}
auto
*
thread
=
static_cast
<
nsThread
*
>
(
aData
)
;
if
(
thread
-
>
mHasTLSEntry
)
{
thread
-
>
mHasTLSEntry
=
false
;
thread
-
>
Release
(
)
;
}
}
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsThreadManager
:
:
AddRef
(
)
{
return
2
;
}
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsThreadManager
:
:
Release
(
)
{
return
1
;
}
NS_IMPL_CLASSINFO
(
nsThreadManager
nullptr
nsIClassInfo
:
:
THREADSAFE
|
nsIClassInfo
:
:
SINGLETON
NS_THREADMANAGER_CID
)
NS_IMPL_QUERY_INTERFACE_CI
(
nsThreadManager
nsIThreadManager
)
NS_IMPL_CI_INTERFACE_GETTER
(
nsThreadManager
nsIThreadManager
)
namespace
{
class
ShutdownObserveHelper
final
:
public
nsIObserver
public
nsSupportsWeakReference
{
public
:
NS_DECL_ISUPPORTS
static
nsresult
Create
(
ShutdownObserveHelper
*
*
aObserver
)
{
MOZ_ASSERT
(
aObserver
)
;
RefPtr
<
ShutdownObserveHelper
>
observer
=
new
ShutdownObserveHelper
(
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obs
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
obs
-
>
AddObserver
(
observer
NS_XPCOM_SHUTDOWN_OBSERVER_ID
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
obs
-
>
AddObserver
(
observer
"
content
-
child
-
will
-
shutdown
"
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
observer
.
forget
(
aObserver
)
;
return
NS_OK
;
}
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
if
(
!
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
|
|
!
strcmp
(
aTopic
"
content
-
child
-
will
-
shutdown
"
)
)
{
mShuttingDown
=
true
;
return
NS_OK
;
}
return
NS_OK
;
}
bool
ShuttingDown
(
)
const
{
return
mShuttingDown
;
}
private
:
explicit
ShutdownObserveHelper
(
)
:
mShuttingDown
(
false
)
{
}
~
ShutdownObserveHelper
(
)
=
default
;
bool
mShuttingDown
;
}
;
NS_INTERFACE_MAP_BEGIN
(
ShutdownObserveHelper
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIObserver
)
NS_INTERFACE_MAP_END
NS_IMPL_ADDREF
(
ShutdownObserveHelper
)
NS_IMPL_RELEASE
(
ShutdownObserveHelper
)
StaticRefPtr
<
ShutdownObserveHelper
>
gShutdownObserveHelper
;
}
nsThreadManager
&
nsThreadManager
:
:
get
(
)
{
static
nsThreadManager
sInstance
;
return
sInstance
;
}
void
nsThreadManager
:
:
InitializeShutdownObserver
(
)
{
MOZ_ASSERT
(
!
gShutdownObserveHelper
)
;
RefPtr
<
ShutdownObserveHelper
>
observer
;
nsresult
rv
=
ShutdownObserveHelper
:
:
Create
(
getter_AddRefs
(
observer
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
gShutdownObserveHelper
=
observer
;
ClearOnShutdown
(
&
gShutdownObserveHelper
)
;
}
nsThreadManager
:
:
nsThreadManager
(
)
:
mCurThreadIndex
(
0
)
mMainPRThread
(
nullptr
)
mInitialized
(
false
)
{
}
nsresult
nsThreadManager
:
:
Init
(
)
{
if
(
mInitialized
)
{
return
NS_OK
;
}
if
(
!
gTlsCurrentVirtualThread
.
init
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
PR_NewThreadPrivateIndex
(
&
mCurThreadIndex
ReleaseThread
)
=
=
PR_FAILURE
)
{
return
NS_ERROR_FAILURE
;
}
#
ifdef
MOZ_CANARY
const
int
flags
=
O_WRONLY
|
O_APPEND
|
O_CREAT
|
O_NONBLOCK
;
const
mode_t
mode
=
S_IRUSR
|
S_IWUSR
|
S_IRGRP
|
S_IROTH
;
char
*
env_var_flag
=
getenv
(
"
MOZ_KILL_CANARIES
"
)
;
sCanaryOutputFD
=
env_var_flag
?
(
env_var_flag
[
0
]
?
open
(
env_var_flag
flags
mode
)
:
STDERR_FILENO
)
:
0
;
#
endif
nsCOMPtr
<
nsIIdlePeriod
>
idlePeriod
=
new
MainThreadIdlePeriod
(
)
;
mMainThread
=
CreateMainThread
<
ThreadEventQueue
<
PrioritizedEventQueue
>
>
(
idlePeriod
)
;
nsresult
rv
=
mMainThread
-
>
InitCurrentThread
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
mMainThread
=
nullptr
;
return
rv
;
}
mMainThread
-
>
GetPRThread
(
&
mMainPRThread
)
;
AbstractThread
:
:
InitTLS
(
)
;
AbstractThread
:
:
InitMainThread
(
)
;
RefPtr
<
BackgroundEventTarget
>
target
(
new
BackgroundEventTarget
(
)
)
;
rv
=
target
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mBackgroundEventTarget
=
target
.
forget
(
)
;
mInitialized
=
true
;
return
NS_OK
;
}
void
nsThreadManager
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
shutdown
not
called
from
main
thread
"
)
;
mInitialized
=
false
;
NS_ProcessPendingEvents
(
mMainThread
)
;
static_cast
<
BackgroundEventTarget
*
>
(
mBackgroundEventTarget
.
get
(
)
)
-
>
Shutdown
(
)
;
{
nsTArray
<
RefPtr
<
nsThread
>
>
threadsToShutdown
;
for
(
auto
*
thread
:
nsThread
:
:
Enumerate
(
)
)
{
if
(
thread
-
>
ShutdownRequired
(
)
)
{
threadsToShutdown
.
AppendElement
(
thread
)
;
}
}
for
(
auto
&
thread
:
threadsToShutdown
)
{
thread
-
>
Shutdown
(
)
;
}
}
mMainThread
-
>
WaitForAllAsynchronousShutdowns
(
)
;
NS_ProcessPendingEvents
(
mMainThread
)
;
mMainThread
-
>
SetObserver
(
nullptr
)
;
mBackgroundEventTarget
=
nullptr
;
mMainThread
=
nullptr
;
PR_SetThreadPrivate
(
mCurThreadIndex
nullptr
)
;
{
nsTArray
<
RefPtr
<
nsThread
>
>
threads
;
for
(
auto
*
thread
:
nsThread
:
:
Enumerate
(
)
)
{
if
(
thread
-
>
mHasTLSEntry
)
{
threads
.
AppendElement
(
dont_AddRef
(
thread
)
)
;
thread
-
>
mHasTLSEntry
=
false
;
}
}
}
nsThread
:
:
ClearThreadList
(
)
;
sShutdownComplete
=
true
;
}
void
nsThreadManager
:
:
RegisterCurrentThread
(
nsThread
&
aThread
)
{
MOZ_ASSERT
(
aThread
.
GetPRThread
(
)
=
=
PR_GetCurrentThread
(
)
"
bad
aThread
"
)
;
aThread
.
AddRef
(
)
;
aThread
.
mHasTLSEntry
=
true
;
PR_SetThreadPrivate
(
mCurThreadIndex
&
aThread
)
;
}
void
nsThreadManager
:
:
UnregisterCurrentThread
(
nsThread
&
aThread
)
{
MOZ_ASSERT
(
aThread
.
GetPRThread
(
)
=
=
PR_GetCurrentThread
(
)
"
bad
aThread
"
)
;
PR_SetThreadPrivate
(
mCurThreadIndex
nullptr
)
;
}
nsThread
*
nsThreadManager
:
:
CreateCurrentThread
(
SynchronizedEventQueue
*
aQueue
nsThread
:
:
MainThreadFlag
aMainThread
)
{
MOZ_ASSERT
(
!
PR_GetThreadPrivate
(
mCurThreadIndex
)
)
;
if
(
!
mInitialized
)
{
return
nullptr
;
}
RefPtr
<
nsThread
>
thread
=
new
nsThread
(
WrapNotNull
(
aQueue
)
aMainThread
0
)
;
if
(
!
thread
|
|
NS_FAILED
(
thread
-
>
InitCurrentThread
(
)
)
)
{
return
nullptr
;
}
return
thread
.
get
(
)
;
}
nsresult
nsThreadManager
:
:
DispatchToBackgroundThread
(
nsIRunnable
*
aEvent
uint32_t
aDispatchFlags
)
{
if
(
!
mInitialized
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIEventTarget
>
backgroundTarget
(
mBackgroundEventTarget
)
;
return
backgroundTarget
-
>
Dispatch
(
aEvent
aDispatchFlags
)
;
}
nsThread
*
nsThreadManager
:
:
GetCurrentThread
(
)
{
void
*
data
=
PR_GetThreadPrivate
(
mCurThreadIndex
)
;
if
(
data
)
{
return
static_cast
<
nsThread
*
>
(
data
)
;
}
if
(
!
mInitialized
)
{
return
nullptr
;
}
RefPtr
<
nsThread
>
thread
=
new
nsThread
(
)
;
if
(
!
thread
|
|
NS_FAILED
(
thread
-
>
InitCurrentThread
(
)
)
)
{
return
nullptr
;
}
return
thread
.
get
(
)
;
}
bool
nsThreadManager
:
:
IsNSThread
(
)
const
{
if
(
!
mInitialized
)
{
return
false
;
}
if
(
auto
*
thread
=
(
nsThread
*
)
PR_GetThreadPrivate
(
mCurThreadIndex
)
)
{
return
thread
-
>
EventQueue
(
)
;
}
return
false
;
}
NS_IMETHODIMP
nsThreadManager
:
:
NewThread
(
uint32_t
aCreationFlags
uint32_t
aStackSize
nsIThread
*
*
aResult
)
{
return
NewNamedThread
(
NS_LITERAL_CSTRING
(
"
"
)
aStackSize
aResult
)
;
}
NS_IMETHODIMP
nsThreadManager
:
:
NewNamedThread
(
const
nsACString
&
aName
uint32_t
aStackSize
nsIThread
*
*
aResult
)
{
if
(
NS_WARN_IF
(
!
mInitialized
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
ThreadEventQueue
<
EventQueue
>
>
queue
=
new
ThreadEventQueue
<
EventQueue
>
(
MakeUnique
<
EventQueue
>
(
)
)
;
RefPtr
<
nsThread
>
thr
=
new
nsThread
(
WrapNotNull
(
queue
)
nsThread
:
:
NOT_MAIN_THREAD
aStackSize
)
;
nsresult
rv
=
thr
-
>
Init
(
aName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
mInitialized
)
)
{
if
(
thr
-
>
ShutdownRequired
(
)
)
{
thr
-
>
Shutdown
(
)
;
}
return
NS_ERROR_NOT_INITIALIZED
;
}
thr
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetMainThread
(
nsIThread
*
*
aResult
)
{
if
(
!
mMainThread
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_WARNING
(
"
Called
GetMainThread
but
there
isn
'
t
a
main
thread
and
"
"
we
'
re
not
the
main
thread
.
"
)
;
}
return
NS_ERROR_NOT_INITIALIZED
;
}
NS_ADDREF
(
*
aResult
=
mMainThread
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetCurrentThread
(
nsIThread
*
*
aResult
)
{
if
(
!
mMainThread
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
*
aResult
=
GetCurrentThread
(
)
;
if
(
!
*
aResult
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
NS_ADDREF
(
*
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
SpinEventLoopUntil
(
nsINestedEventLoopCondition
*
aCondition
)
{
return
SpinEventLoopUntilInternal
(
aCondition
false
)
;
}
NS_IMETHODIMP
nsThreadManager
:
:
SpinEventLoopUntilOrShutdown
(
nsINestedEventLoopCondition
*
aCondition
)
{
return
SpinEventLoopUntilInternal
(
aCondition
true
)
;
}
nsresult
nsThreadManager
:
:
SpinEventLoopUntilInternal
(
nsINestedEventLoopCondition
*
aCondition
bool
aCheckingShutdown
)
{
nsCOMPtr
<
nsINestedEventLoopCondition
>
condition
(
aCondition
)
;
nsresult
rv
=
NS_OK
;
if
(
aCheckingShutdown
&
&
(
!
gShutdownObserveHelper
|
|
gShutdownObserveHelper
-
>
ShuttingDown
(
)
)
)
{
return
NS_OK
;
}
if
(
!
mozilla
:
:
SpinEventLoopUntil
(
[
&
]
(
)
-
>
bool
{
if
(
aCheckingShutdown
&
&
(
!
gShutdownObserveHelper
|
|
gShutdownObserveHelper
-
>
ShuttingDown
(
)
)
)
{
return
true
;
}
bool
isDone
=
false
;
rv
=
condition
-
>
IsDone
(
&
isDone
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
true
;
}
return
isDone
;
}
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
rv
;
}
NS_IMETHODIMP
nsThreadManager
:
:
SpinEventLoopUntilEmpty
(
)
{
nsIThread
*
thread
=
NS_GetCurrentThread
(
)
;
while
(
NS_HasPendingEvents
(
thread
)
)
{
(
void
)
NS_ProcessNextEvent
(
thread
false
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetSystemGroupEventTarget
(
nsIEventTarget
*
*
aTarget
)
{
nsCOMPtr
<
nsIEventTarget
>
target
=
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
;
target
.
forget
(
aTarget
)
;
return
NS_OK
;
}
uint32_t
nsThreadManager
:
:
GetHighestNumberOfThreads
(
)
{
return
nsThread
:
:
MaxActiveThreads
(
)
;
}
NS_IMETHODIMP
nsThreadManager
:
:
DispatchToMainThread
(
nsIRunnable
*
aEvent
uint32_t
aPriority
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
!
mMainThread
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
aPriority
!
=
nsIRunnablePriority
:
:
PRIORITY_NORMAL
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
return
mMainThread
-
>
DispatchFromScript
(
new
PrioritizableRunnable
(
event
.
forget
(
)
aPriority
)
0
)
;
}
return
mMainThread
-
>
DispatchFromScript
(
aEvent
0
)
;
}
void
nsThreadManager
:
:
EnableMainThreadEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
InputEventStatistics
:
:
Get
(
)
.
SetEnable
(
true
)
;
mMainThread
-
>
EnableInputEventPrioritization
(
)
;
}
void
nsThreadManager
:
:
FlushInputEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMainThread
-
>
FlushInputEventPrioritization
(
)
;
}
void
nsThreadManager
:
:
SuspendInputEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMainThread
-
>
SuspendInputEventPrioritization
(
)
;
}
void
nsThreadManager
:
:
ResumeInputEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMainThread
-
>
ResumeInputEventPrioritization
(
)
;
}
bool
nsThreadManager
:
:
MainThreadHasPendingHighPriorityEvents
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
retVal
=
false
;
if
(
get
(
)
.
mMainThread
)
{
get
(
)
.
mMainThread
-
>
HasPendingHighPriorityEvents
(
&
retVal
)
;
}
return
retVal
;
}
NS_IMETHODIMP
nsThreadManager
:
:
IdleDispatchToMainThread
(
nsIRunnable
*
aEvent
uint32_t
aTimeout
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
if
(
aTimeout
)
{
return
NS_DispatchToThreadQueue
(
event
.
forget
(
)
aTimeout
mMainThread
EventQueuePriority
:
:
Idle
)
;
}
return
NS_DispatchToThreadQueue
(
event
.
forget
(
)
mMainThread
EventQueuePriority
:
:
Idle
)
;
}
namespace
mozilla
{
PRThread
*
GetCurrentVirtualThread
(
)
{
if
(
gTlsCurrentVirtualThread
.
initialized
(
)
)
{
if
(
gTlsCurrentVirtualThread
.
get
(
)
)
{
return
gTlsCurrentVirtualThread
.
get
(
)
;
}
}
return
PR_GetCurrentThread
(
)
;
}
PRThread
*
GetCurrentPhysicalThread
(
)
{
return
PR_GetCurrentThread
(
)
;
}
}
