#
include
"
nsThreadManager
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsThreadPool
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIClassInfoImpl
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
InputTaskManager
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
ThreadEventQueue
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
TaskController
.
h
"
#
include
"
ThreadEventTarget
.
h
"
#
ifdef
MOZ_CANARY
#
include
<
fcntl
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
include
"
MainThreadIdlePeriod
.
h
"
#
include
"
InputEventStatistics
.
h
"
using
namespace
mozilla
;
static
MOZ_THREAD_LOCAL
(
bool
)
sTLSIsMainThread
;
bool
NS_IsMainThreadTLSInitialized
(
)
{
return
sTLSIsMainThread
.
initialized
(
)
;
}
class
BackgroundEventTarget
final
:
public
nsIEventTarget
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIEVENTTARGET_FULL
BackgroundEventTarget
(
)
;
nsresult
Init
(
)
;
already_AddRefed
<
nsISerialEventTarget
>
CreateBackgroundTaskQueue
(
const
char
*
aName
)
;
using
CancelPromise
=
TaskQueue
:
:
CancelPromise
:
:
AllPromiseType
;
RefPtr
<
CancelPromise
>
CancelBackgroundDelayedRunnables
(
)
;
void
BeginShutdown
(
nsTArray
<
RefPtr
<
ShutdownPromise
>
>
&
)
;
void
FinishShutdown
(
)
;
private
:
~
BackgroundEventTarget
(
)
=
default
;
nsCOMPtr
<
nsIThreadPool
>
mPool
;
nsCOMPtr
<
nsIThreadPool
>
mIOPool
;
Mutex
mMutex
;
nsTArray
<
RefPtr
<
TaskQueue
>
>
mTaskQueues
;
bool
mIsBackgroundDelayedRunnablesCanceled
;
}
;
NS_IMPL_ISUPPORTS
(
BackgroundEventTarget
nsIEventTarget
)
BackgroundEventTarget
:
:
BackgroundEventTarget
(
)
:
mMutex
(
"
BackgroundEventTarget
:
:
mMutex
"
)
{
}
nsresult
BackgroundEventTarget
:
:
Init
(
)
{
nsCOMPtr
<
nsIThreadPool
>
pool
(
new
nsThreadPool
(
)
)
;
NS_ENSURE_TRUE
(
pool
NS_ERROR_FAILURE
)
;
nsresult
rv
=
pool
-
>
SetName
(
"
BackgroundThreadPool
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
pool
-
>
SetThreadStackSize
(
nsIThreadManager
:
:
kThreadPoolStackSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
pool
-
>
SetThreadLimit
(
2
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
pool
-
>
SetIdleThreadLimit
(
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
pool
-
>
SetIdleThreadTimeout
(
300000
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIThreadPool
>
ioPool
(
new
nsThreadPool
(
)
)
;
NS_ENSURE_TRUE
(
pool
NS_ERROR_FAILURE
)
;
rv
=
ioPool
-
>
SetName
(
"
BgIOThreadPool
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ioPool
-
>
SetThreadStackSize
(
nsIThreadManager
:
:
kThreadPoolStackSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ioPool
-
>
SetThreadLimit
(
4
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ioPool
-
>
SetIdleThreadLimit
(
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ioPool
-
>
SetIdleThreadTimeout
(
300000
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
pool
.
swap
(
mPool
)
;
ioPool
.
swap
(
mIOPool
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
bool
)
BackgroundEventTarget
:
:
IsOnCurrentThreadInfallible
(
)
{
return
mPool
-
>
IsOnCurrentThread
(
)
|
|
mIOPool
-
>
IsOnCurrentThread
(
)
;
}
NS_IMETHODIMP
BackgroundEventTarget
:
:
IsOnCurrentThread
(
bool
*
aValue
)
{
bool
value
=
false
;
if
(
NS_SUCCEEDED
(
mPool
-
>
IsOnCurrentThread
(
&
value
)
)
&
&
value
)
{
*
aValue
=
value
;
return
NS_OK
;
}
return
mIOPool
-
>
IsOnCurrentThread
(
aValue
)
;
}
NS_IMETHODIMP
BackgroundEventTarget
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aFlags
)
{
uint32_t
flags
=
aFlags
&
~
NS_DISPATCH_EVENT_MAY_BLOCK
;
bool
mayBlock
=
bool
(
aFlags
&
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
nsCOMPtr
<
nsIThreadPool
>
&
pool
=
mayBlock
?
mIOPool
:
mPool
;
if
(
pool
-
>
IsOnCurrentThread
(
)
)
{
flags
|
=
NS_DISPATCH_AT_END
;
}
else
{
flags
&
=
~
NS_DISPATCH_AT_END
;
}
return
pool
-
>
Dispatch
(
std
:
:
move
(
aRunnable
)
flags
)
;
}
NS_IMETHODIMP
BackgroundEventTarget
:
:
DispatchFromScript
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
return
Dispatch
(
runnable
.
forget
(
)
aFlags
)
;
}
NS_IMETHODIMP
BackgroundEventTarget
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
)
{
nsCOMPtr
<
nsIRunnable
>
dropRunnable
(
aRunnable
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
void
BackgroundEventTarget
:
:
BeginShutdown
(
nsTArray
<
RefPtr
<
ShutdownPromise
>
>
&
promises
)
{
for
(
auto
&
queue
:
mTaskQueues
)
{
promises
.
AppendElement
(
queue
-
>
BeginShutdown
(
)
)
;
}
}
void
BackgroundEventTarget
:
:
FinishShutdown
(
)
{
mPool
-
>
Shutdown
(
)
;
mIOPool
-
>
Shutdown
(
)
;
}
already_AddRefed
<
nsISerialEventTarget
>
BackgroundEventTarget
:
:
CreateBackgroundTaskQueue
(
const
char
*
aName
)
{
MutexAutoLock
lock
(
mMutex
)
;
RefPtr
<
TaskQueue
>
queue
=
new
TaskQueue
(
do_AddRef
(
this
)
aName
)
;
mTaskQueues
.
AppendElement
(
queue
)
;
return
queue
.
forget
(
)
;
}
auto
BackgroundEventTarget
:
:
CancelBackgroundDelayedRunnables
(
)
-
>
RefPtr
<
CancelPromise
>
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
mIsBackgroundDelayedRunnablesCanceled
=
true
;
nsTArray
<
RefPtr
<
TaskQueue
:
:
CancelPromise
>
>
promises
;
for
(
const
auto
&
tq
:
mTaskQueues
)
{
promises
.
AppendElement
(
tq
-
>
CancelDelayedRunnables
(
)
)
;
}
return
TaskQueue
:
:
CancelPromise
:
:
All
(
GetMainThreadSerialEventTarget
(
)
promises
)
;
}
extern
"
C
"
{
bool
NS_IsMainThread
(
)
{
return
sTLSIsMainThread
.
get
(
)
;
}
}
void
NS_SetMainThread
(
)
{
if
(
!
sTLSIsMainThread
.
init
(
)
)
{
MOZ_CRASH
(
)
;
}
sTLSIsMainThread
.
set
(
true
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
SerialEventTargetGuard
:
:
InitTLS
(
)
;
}
#
ifdef
DEBUG
namespace
mozilla
{
void
AssertIsOnMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
}
}
#
endif
typedef
nsTArray
<
NotNull
<
RefPtr
<
nsThread
>
>
>
nsThreadArray
;
static
Atomic
<
bool
>
sShutdownComplete
;
void
nsThreadManager
:
:
ReleaseThread
(
void
*
aData
)
{
if
(
sShutdownComplete
)
{
return
;
}
auto
*
thread
=
static_cast
<
nsThread
*
>
(
aData
)
;
if
(
thread
-
>
mHasTLSEntry
)
{
thread
-
>
mHasTLSEntry
=
false
;
thread
-
>
Release
(
)
;
}
}
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsThreadManager
:
:
AddRef
(
)
{
return
2
;
}
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsThreadManager
:
:
Release
(
)
{
return
1
;
}
NS_IMPL_CLASSINFO
(
nsThreadManager
nullptr
nsIClassInfo
:
:
THREADSAFE
|
nsIClassInfo
:
:
SINGLETON
NS_THREADMANAGER_CID
)
NS_IMPL_QUERY_INTERFACE_CI
(
nsThreadManager
nsIThreadManager
)
NS_IMPL_CI_INTERFACE_GETTER
(
nsThreadManager
nsIThreadManager
)
nsThreadManager
&
nsThreadManager
:
:
get
(
)
{
static
nsThreadManager
sInstance
;
return
sInstance
;
}
nsThreadManager
:
:
nsThreadManager
(
)
:
mCurThreadIndex
(
0
)
mMainPRThread
(
nullptr
)
mInitialized
(
false
)
{
}
nsThreadManager
:
:
~
nsThreadManager
(
)
=
default
;
nsresult
nsThreadManager
:
:
Init
(
)
{
if
(
mInitialized
)
{
return
NS_OK
;
}
if
(
PR_NewThreadPrivateIndex
(
&
mCurThreadIndex
ReleaseThread
)
=
=
PR_FAILURE
)
{
return
NS_ERROR_FAILURE
;
}
#
ifdef
MOZ_CANARY
const
int
flags
=
O_WRONLY
|
O_APPEND
|
O_CREAT
|
O_NONBLOCK
;
const
mode_t
mode
=
S_IRUSR
|
S_IWUSR
|
S_IRGRP
|
S_IROTH
;
char
*
env_var_flag
=
getenv
(
"
MOZ_KILL_CANARIES
"
)
;
sCanaryOutputFD
=
env_var_flag
?
(
env_var_flag
[
0
]
?
open
(
env_var_flag
flags
mode
)
:
STDERR_FILENO
)
:
0
;
#
endif
TaskController
:
:
Initialize
(
)
;
nsCOMPtr
<
nsIIdlePeriod
>
idlePeriod
=
new
MainThreadIdlePeriod
(
)
;
TaskController
:
:
Get
(
)
-
>
SetIdleTaskManager
(
new
IdleTaskManager
(
idlePeriod
.
forget
(
)
)
)
;
UniquePtr
<
EventQueue
>
queue
=
MakeUnique
<
EventQueue
>
(
true
)
;
RefPtr
<
ThreadEventQueue
>
synchronizedQueue
=
new
ThreadEventQueue
(
std
:
:
move
(
queue
)
true
)
;
mMainThread
=
new
nsThread
(
WrapNotNull
(
synchronizedQueue
)
nsThread
:
:
MAIN_THREAD
0
)
;
nsresult
rv
=
mMainThread
-
>
InitCurrentThread
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
mMainThread
=
nullptr
;
return
rv
;
}
mMainThread
-
>
GetPRThread
(
&
mMainPRThread
)
;
AbstractThread
:
:
InitTLS
(
)
;
AbstractThread
:
:
InitMainThread
(
)
;
RefPtr
<
BackgroundEventTarget
>
target
(
new
BackgroundEventTarget
(
)
)
;
rv
=
target
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mBackgroundEventTarget
=
std
:
:
move
(
target
)
;
mInitialized
=
true
;
return
NS_OK
;
}
void
nsThreadManager
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
shutdown
not
called
from
main
thread
"
)
;
mInitialized
=
false
;
NS_ProcessPendingEvents
(
mMainThread
)
;
nsTArray
<
RefPtr
<
ShutdownPromise
>
>
promises
;
mBackgroundEventTarget
-
>
BeginShutdown
(
promises
)
;
bool
taskQueuesShutdown
=
false
;
ShutdownPromise
:
:
All
(
mMainThread
promises
)
-
>
Then
(
mMainThread
__func__
[
&
]
{
mBackgroundEventTarget
-
>
FinishShutdown
(
)
;
taskQueuesShutdown
=
true
;
}
)
;
mozilla
:
:
SpinEventLoopUntil
(
"
nsThreadManager
:
:
Shutdown
"
_ns
[
&
]
(
)
{
return
taskQueuesShutdown
;
}
mMainThread
)
;
{
nsTArray
<
RefPtr
<
nsThread
>
>
threadsToShutdown
;
for
(
auto
*
thread
:
nsThread
:
:
Enumerate
(
)
)
{
if
(
thread
-
>
ShutdownRequired
(
)
)
{
threadsToShutdown
.
AppendElement
(
thread
)
;
}
}
for
(
auto
&
thread
:
threadsToShutdown
)
{
thread
-
>
Shutdown
(
)
;
}
}
mMainThread
-
>
WaitForAllAsynchronousShutdowns
(
)
;
mMainThread
-
>
mEventTarget
-
>
NotifyShutdown
(
)
;
NS_ProcessPendingEvents
(
mMainThread
)
;
mMainThread
-
>
SetObserver
(
nullptr
)
;
mBackgroundEventTarget
=
nullptr
;
mMainThread
=
nullptr
;
PR_SetThreadPrivate
(
mCurThreadIndex
nullptr
)
;
{
nsTArray
<
RefPtr
<
nsThread
>
>
threads
;
for
(
auto
*
thread
:
nsThread
:
:
Enumerate
(
)
)
{
if
(
thread
-
>
mHasTLSEntry
)
{
threads
.
AppendElement
(
dont_AddRef
(
thread
)
)
;
thread
-
>
mHasTLSEntry
=
false
;
}
}
}
nsThread
:
:
ClearThreadList
(
)
;
sShutdownComplete
=
true
;
}
void
nsThreadManager
:
:
RegisterCurrentThread
(
nsThread
&
aThread
)
{
MOZ_ASSERT
(
aThread
.
GetPRThread
(
)
=
=
PR_GetCurrentThread
(
)
"
bad
aThread
"
)
;
aThread
.
AddRef
(
)
;
aThread
.
mHasTLSEntry
=
true
;
PR_SetThreadPrivate
(
mCurThreadIndex
&
aThread
)
;
}
void
nsThreadManager
:
:
UnregisterCurrentThread
(
nsThread
&
aThread
)
{
MOZ_ASSERT
(
aThread
.
GetPRThread
(
)
=
=
PR_GetCurrentThread
(
)
"
bad
aThread
"
)
;
PR_SetThreadPrivate
(
mCurThreadIndex
nullptr
)
;
}
nsThread
*
nsThreadManager
:
:
CreateCurrentThread
(
SynchronizedEventQueue
*
aQueue
nsThread
:
:
MainThreadFlag
aMainThread
)
{
MOZ_ASSERT
(
!
PR_GetThreadPrivate
(
mCurThreadIndex
)
)
;
if
(
!
mInitialized
)
{
return
nullptr
;
}
RefPtr
<
nsThread
>
thread
=
new
nsThread
(
WrapNotNull
(
aQueue
)
aMainThread
0
)
;
if
(
!
thread
|
|
NS_FAILED
(
thread
-
>
InitCurrentThread
(
)
)
)
{
return
nullptr
;
}
return
thread
.
get
(
)
;
}
nsresult
nsThreadManager
:
:
DispatchToBackgroundThread
(
nsIRunnable
*
aEvent
uint32_t
aDispatchFlags
)
{
if
(
!
mInitialized
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIEventTarget
>
backgroundTarget
(
mBackgroundEventTarget
)
;
return
backgroundTarget
-
>
Dispatch
(
aEvent
aDispatchFlags
)
;
}
already_AddRefed
<
nsISerialEventTarget
>
nsThreadManager
:
:
CreateBackgroundTaskQueue
(
const
char
*
aName
)
{
if
(
!
mInitialized
)
{
return
nullptr
;
}
return
mBackgroundEventTarget
-
>
CreateBackgroundTaskQueue
(
aName
)
;
}
void
nsThreadManager
:
:
CancelBackgroundDelayedRunnables
(
)
{
if
(
!
mInitialized
)
{
return
;
}
bool
canceled
=
false
;
mBackgroundEventTarget
-
>
CancelBackgroundDelayedRunnables
(
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
&
]
{
canceled
=
true
;
}
)
;
mozilla
:
:
SpinEventLoopUntil
(
"
nsThreadManager
:
:
CancelBackgroundDelayedRunnables
"
_ns
[
&
]
(
)
{
return
canceled
;
}
)
;
}
nsThread
*
nsThreadManager
:
:
GetCurrentThread
(
)
{
void
*
data
=
PR_GetThreadPrivate
(
mCurThreadIndex
)
;
if
(
data
)
{
return
static_cast
<
nsThread
*
>
(
data
)
;
}
if
(
!
mInitialized
)
{
return
nullptr
;
}
RefPtr
<
nsThread
>
thread
=
new
nsThread
(
)
;
if
(
!
thread
|
|
NS_FAILED
(
thread
-
>
InitCurrentThread
(
)
)
)
{
return
nullptr
;
}
return
thread
.
get
(
)
;
}
bool
nsThreadManager
:
:
IsNSThread
(
)
const
{
if
(
!
mInitialized
)
{
return
false
;
}
if
(
auto
*
thread
=
(
nsThread
*
)
PR_GetThreadPrivate
(
mCurThreadIndex
)
)
{
return
thread
-
>
EventQueue
(
)
;
}
return
false
;
}
NS_IMETHODIMP
nsThreadManager
:
:
NewNamedThread
(
const
nsACString
&
aName
uint32_t
aStackSize
nsIThread
*
*
aResult
)
{
if
(
NS_WARN_IF
(
!
mInitialized
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
[
[
maybe_unused
]
]
TimeStamp
startTime
=
TimeStamp
:
:
Now
(
)
;
RefPtr
<
ThreadEventQueue
>
queue
=
new
ThreadEventQueue
(
MakeUnique
<
EventQueue
>
(
)
)
;
RefPtr
<
nsThread
>
thr
=
new
nsThread
(
WrapNotNull
(
queue
)
nsThread
:
:
NOT_MAIN_THREAD
aStackSize
)
;
nsresult
rv
=
thr
-
>
Init
(
aName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
mInitialized
)
)
{
if
(
thr
-
>
ShutdownRequired
(
)
)
{
thr
-
>
Shutdown
(
)
;
}
return
NS_ERROR_NOT_INITIALIZED
;
}
PROFILER_MARKER_TEXT
(
"
NewThread
"
OTHER
MarkerOptions
(
MarkerStack
:
:
Capture
(
)
MarkerTiming
:
:
IntervalUntilNowFrom
(
startTime
)
)
aName
)
;
if
(
!
NS_IsMainThread
(
)
)
{
PROFILER_MARKER_TEXT
(
"
NewThread
(
non
-
main
thread
)
"
OTHER
MarkerOptions
(
MarkerStack
:
:
Capture
(
)
MarkerThreadId
:
:
MainThread
(
)
MarkerTiming
:
:
IntervalUntilNowFrom
(
startTime
)
)
aName
)
;
}
thr
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetMainThread
(
nsIThread
*
*
aResult
)
{
if
(
!
mMainThread
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_WARNING
(
"
Called
GetMainThread
but
there
isn
'
t
a
main
thread
and
"
"
we
'
re
not
the
main
thread
.
"
)
;
}
return
NS_ERROR_NOT_INITIALIZED
;
}
NS_ADDREF
(
*
aResult
=
mMainThread
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetCurrentThread
(
nsIThread
*
*
aResult
)
{
if
(
!
mMainThread
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
*
aResult
=
GetCurrentThread
(
)
;
if
(
!
*
aResult
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
NS_ADDREF
(
*
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
SpinEventLoopUntil
(
const
nsACString
&
aVeryGoodReasonToDoThis
nsINestedEventLoopCondition
*
aCondition
)
{
return
SpinEventLoopUntilInternal
(
aVeryGoodReasonToDoThis
aCondition
ShutdownPhase
:
:
NotInShutdown
)
;
}
NS_IMETHODIMP
nsThreadManager
:
:
SpinEventLoopUntilOrQuit
(
const
nsACString
&
aVeryGoodReasonToDoThis
nsINestedEventLoopCondition
*
aCondition
)
{
return
SpinEventLoopUntilInternal
(
aVeryGoodReasonToDoThis
aCondition
ShutdownPhase
:
:
AppShutdownConfirmed
)
;
}
AutoNestedEventLoopAnnotation
*
AutoNestedEventLoopAnnotation
:
:
sCurrent
=
nullptr
;
StaticMutex
AutoNestedEventLoopAnnotation
:
:
sStackMutex
;
void
AutoNestedEventLoopAnnotation
:
:
AnnotateXPCOMSpinEventLoopStack
(
const
nsACString
&
aStack
)
{
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
XPCOMSpinEventLoopStack
aStack
)
;
}
nsresult
nsThreadManager
:
:
SpinEventLoopUntilInternal
(
const
nsACString
&
aVeryGoodReasonToDoThis
nsINestedEventLoopCondition
*
aCondition
ShutdownPhase
aShutdownPhaseToCheck
)
{
nsCOMPtr
<
nsINestedEventLoopCondition
>
condition
(
aCondition
)
;
nsresult
rv
=
NS_OK
;
if
(
!
mozilla
:
:
SpinEventLoopUntil
(
aVeryGoodReasonToDoThis
[
&
]
(
)
-
>
bool
{
if
(
aShutdownPhaseToCheck
>
ShutdownPhase
:
:
NotInShutdown
&
&
AppShutdown
:
:
GetCurrentShutdownPhase
(
)
>
=
aShutdownPhaseToCheck
)
{
return
true
;
}
bool
isDone
=
false
;
rv
=
condition
-
>
IsDone
(
&
isDone
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
true
;
}
return
isDone
;
}
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
rv
;
}
NS_IMETHODIMP
nsThreadManager
:
:
SpinEventLoopUntilEmpty
(
)
{
nsIThread
*
thread
=
NS_GetCurrentThread
(
)
;
while
(
NS_HasPendingEvents
(
thread
)
)
{
(
void
)
NS_ProcessNextEvent
(
thread
false
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetMainThreadEventTarget
(
nsIEventTarget
*
*
aTarget
)
{
nsCOMPtr
<
nsIEventTarget
>
target
=
GetMainThreadSerialEventTarget
(
)
;
target
.
forget
(
aTarget
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
DispatchToMainThread
(
nsIRunnable
*
aEvent
uint32_t
aPriority
uint8_t
aArgc
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
!
mMainThread
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
aArgc
>
0
&
&
aPriority
!
=
nsIRunnablePriority
:
:
PRIORITY_NORMAL
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
return
mMainThread
-
>
DispatchFromScript
(
new
PrioritizableRunnable
(
event
.
forget
(
)
aPriority
)
0
)
;
}
return
mMainThread
-
>
DispatchFromScript
(
aEvent
0
)
;
}
void
nsThreadManager
:
:
EnableMainThreadEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
InputEventStatistics
:
:
Get
(
)
.
SetEnable
(
true
)
;
InputTaskManager
:
:
Get
(
)
-
>
EnableInputEventPrioritization
(
)
;
}
void
nsThreadManager
:
:
FlushInputEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
InputTaskManager
:
:
Get
(
)
-
>
FlushInputEventPrioritization
(
)
;
}
void
nsThreadManager
:
:
SuspendInputEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
InputTaskManager
:
:
Get
(
)
-
>
SuspendInputEventPrioritization
(
)
;
}
void
nsThreadManager
:
:
ResumeInputEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
InputTaskManager
:
:
Get
(
)
-
>
ResumeInputEventPrioritization
(
)
;
}
bool
nsThreadManager
:
:
MainThreadHasPendingHighPriorityEvents
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
retVal
=
false
;
if
(
get
(
)
.
mMainThread
)
{
get
(
)
.
mMainThread
-
>
HasPendingHighPriorityEvents
(
&
retVal
)
;
}
return
retVal
;
}
NS_IMETHODIMP
nsThreadManager
:
:
IdleDispatchToMainThread
(
nsIRunnable
*
aEvent
uint32_t
aTimeout
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
if
(
aTimeout
)
{
return
NS_DispatchToThreadQueue
(
event
.
forget
(
)
aTimeout
mMainThread
EventQueuePriority
:
:
Idle
)
;
}
return
NS_DispatchToThreadQueue
(
event
.
forget
(
)
mMainThread
EventQueuePriority
:
:
Idle
)
;
}
