#
include
"
nsThreadManager
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIClassInfoImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
ThreadEventQueue
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
PrioritizedEventQueue
.
h
"
#
ifdef
MOZ_CANARY
#
include
<
fcntl
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
include
"
MainThreadIdlePeriod
.
h
"
#
include
"
InputEventStatistics
.
h
"
using
namespace
mozilla
;
static
MOZ_THREAD_LOCAL
(
bool
)
sTLSIsMainThread
;
bool
NS_IsMainThread
(
)
{
return
sTLSIsMainThread
.
get
(
)
;
}
void
NS_SetMainThread
(
)
{
if
(
!
sTLSIsMainThread
.
init
(
)
)
{
MOZ_CRASH
(
)
;
}
sTLSIsMainThread
.
set
(
true
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
typedef
nsTArray
<
NotNull
<
RefPtr
<
nsThread
>
>
>
nsThreadArray
;
static
void
ReleaseObject
(
void
*
aData
)
{
static_cast
<
nsISupports
*
>
(
aData
)
-
>
Release
(
)
;
}
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsThreadManager
:
:
AddRef
(
)
{
return
2
;
}
NS_IMETHODIMP_
(
MozExternalRefCountType
)
nsThreadManager
:
:
Release
(
)
{
return
1
;
}
NS_IMPL_CLASSINFO
(
nsThreadManager
nullptr
nsIClassInfo
:
:
THREADSAFE
|
nsIClassInfo
:
:
SINGLETON
NS_THREADMANAGER_CID
)
NS_IMPL_QUERY_INTERFACE_CI
(
nsThreadManager
nsIThreadManager
)
NS_IMPL_CI_INTERFACE_GETTER
(
nsThreadManager
nsIThreadManager
)
nsresult
nsThreadManager
:
:
Init
(
)
{
if
(
mInitialized
)
{
return
NS_OK
;
}
if
(
PR_NewThreadPrivateIndex
(
&
mCurThreadIndex
ReleaseObject
)
=
=
PR_FAILURE
)
{
return
NS_ERROR_FAILURE
;
}
#
ifdef
MOZ_CANARY
const
int
flags
=
O_WRONLY
|
O_APPEND
|
O_CREAT
|
O_NONBLOCK
;
const
mode_t
mode
=
S_IRUSR
|
S_IWUSR
|
S_IRGRP
|
S_IROTH
;
char
*
env_var_flag
=
getenv
(
"
MOZ_KILL_CANARIES
"
)
;
sCanaryOutputFD
=
env_var_flag
?
(
env_var_flag
[
0
]
?
open
(
env_var_flag
flags
mode
)
:
STDERR_FILENO
)
:
0
;
#
endif
using
MainThreadQueueT
=
PrioritizedEventQueue
<
EventQueue
>
;
nsCOMPtr
<
nsIIdlePeriod
>
idlePeriod
=
new
MainThreadIdlePeriod
(
)
;
auto
prioritized
=
MakeUnique
<
MainThreadQueueT
>
(
MakeUnique
<
EventQueue
>
(
)
MakeUnique
<
EventQueue
>
(
)
MakeUnique
<
EventQueue
>
(
)
MakeUnique
<
EventQueue
>
(
)
idlePeriod
.
forget
(
)
)
;
MainThreadQueueT
*
prioritizedRef
=
prioritized
.
get
(
)
;
RefPtr
<
ThreadEventQueue
<
MainThreadQueueT
>
>
queue
=
new
ThreadEventQueue
<
MainThreadQueueT
>
(
Move
(
prioritized
)
)
;
mMainThread
=
new
nsThread
(
WrapNotNull
(
queue
)
nsThread
:
:
MAIN_THREAD
0
)
;
prioritizedRef
-
>
SetMutexRef
(
queue
-
>
MutexRef
(
)
)
;
#
ifndef
RELEASE_OR_BETA
prioritizedRef
-
>
SetNextIdleDeadlineRef
(
mMainThread
-
>
NextIdleDeadlineRef
(
)
)
;
#
endif
nsresult
rv
=
mMainThread
-
>
InitCurrentThread
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
mMainThread
=
nullptr
;
return
rv
;
}
mMainThread
-
>
GetPRThread
(
&
mMainPRThread
)
;
AbstractThread
:
:
InitTLS
(
)
;
AbstractThread
:
:
InitMainThread
(
)
;
mInitialized
=
true
;
return
NS_OK
;
}
void
nsThreadManager
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
shutdown
not
called
from
main
thread
"
)
;
mInitialized
=
false
;
NS_ProcessPendingEvents
(
mMainThread
)
;
nsThreadArray
threads
;
{
OffTheBooksMutexAutoLock
lock
(
mLock
)
;
for
(
auto
iter
=
mThreadsByPRThread
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
nsThread
>
&
thread
=
iter
.
Data
(
)
;
threads
.
AppendElement
(
WrapNotNull
(
thread
)
)
;
iter
.
Remove
(
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
threads
.
Length
(
)
;
+
+
i
)
{
NotNull
<
nsThread
*
>
thread
=
threads
[
i
]
;
if
(
thread
-
>
ShutdownRequired
(
)
)
{
thread
-
>
Shutdown
(
)
;
}
}
mMainThread
-
>
WaitForAllAsynchronousShutdowns
(
)
;
NS_ProcessPendingEvents
(
mMainThread
)
;
{
OffTheBooksMutexAutoLock
lock
(
mLock
)
;
mThreadsByPRThread
.
Clear
(
)
;
}
mMainThread
-
>
SetObserver
(
nullptr
)
;
mMainThread
-
>
ClearObservers
(
)
;
mMainThread
=
nullptr
;
PR_SetThreadPrivate
(
mCurThreadIndex
nullptr
)
;
}
void
nsThreadManager
:
:
RegisterCurrentThread
(
nsThread
&
aThread
)
{
MOZ_ASSERT
(
aThread
.
GetPRThread
(
)
=
=
PR_GetCurrentThread
(
)
"
bad
aThread
"
)
;
OffTheBooksMutexAutoLock
lock
(
mLock
)
;
+
+
mCurrentNumberOfThreads
;
if
(
mCurrentNumberOfThreads
>
mHighestNumberOfThreads
)
{
mHighestNumberOfThreads
=
mCurrentNumberOfThreads
;
}
mThreadsByPRThread
.
Put
(
aThread
.
GetPRThread
(
)
&
aThread
)
;
aThread
.
AddRef
(
)
;
PR_SetThreadPrivate
(
mCurThreadIndex
&
aThread
)
;
}
void
nsThreadManager
:
:
UnregisterCurrentThread
(
nsThread
&
aThread
)
{
MOZ_ASSERT
(
aThread
.
GetPRThread
(
)
=
=
PR_GetCurrentThread
(
)
"
bad
aThread
"
)
;
OffTheBooksMutexAutoLock
lock
(
mLock
)
;
-
-
mCurrentNumberOfThreads
;
mThreadsByPRThread
.
Remove
(
aThread
.
GetPRThread
(
)
)
;
PR_SetThreadPrivate
(
mCurThreadIndex
nullptr
)
;
}
nsThread
*
nsThreadManager
:
:
GetCurrentThread
(
)
{
void
*
data
=
PR_GetThreadPrivate
(
mCurThreadIndex
)
;
if
(
data
)
{
return
static_cast
<
nsThread
*
>
(
data
)
;
}
if
(
!
mInitialized
)
{
return
nullptr
;
}
RefPtr
<
ThreadEventQueue
<
EventQueue
>
>
queue
=
new
ThreadEventQueue
<
EventQueue
>
(
MakeUnique
<
EventQueue
>
(
)
)
;
RefPtr
<
nsThread
>
thread
=
new
nsThread
(
WrapNotNull
(
queue
)
nsThread
:
:
NOT_MAIN_THREAD
0
)
;
if
(
!
thread
|
|
NS_FAILED
(
thread
-
>
InitCurrentThread
(
)
)
)
{
return
nullptr
;
}
return
thread
.
get
(
)
;
}
NS_IMETHODIMP
nsThreadManager
:
:
NewThread
(
uint32_t
aCreationFlags
uint32_t
aStackSize
nsIThread
*
*
aResult
)
{
return
NewNamedThread
(
NS_LITERAL_CSTRING
(
"
"
)
aStackSize
aResult
)
;
}
NS_IMETHODIMP
nsThreadManager
:
:
NewNamedThread
(
const
nsACString
&
aName
uint32_t
aStackSize
nsIThread
*
*
aResult
)
{
if
(
NS_WARN_IF
(
!
mInitialized
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
ThreadEventQueue
<
EventQueue
>
>
queue
=
new
ThreadEventQueue
<
EventQueue
>
(
MakeUnique
<
EventQueue
>
(
)
)
;
RefPtr
<
nsThread
>
thr
=
new
nsThread
(
WrapNotNull
(
queue
)
nsThread
:
:
NOT_MAIN_THREAD
aStackSize
)
;
nsresult
rv
=
thr
-
>
Init
(
aName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
mInitialized
)
)
{
if
(
thr
-
>
ShutdownRequired
(
)
)
{
thr
-
>
Shutdown
(
)
;
}
return
NS_ERROR_NOT_INITIALIZED
;
}
thr
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetThreadFromPRThread
(
PRThread
*
aThread
nsIThread
*
*
aResult
)
{
if
(
NS_WARN_IF
(
!
mMainThread
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
NS_WARN_IF
(
!
aThread
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
nsThread
>
temp
;
{
OffTheBooksMutexAutoLock
lock
(
mLock
)
;
mThreadsByPRThread
.
Get
(
aThread
getter_AddRefs
(
temp
)
)
;
}
NS_IF_ADDREF
(
*
aResult
=
temp
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetMainThread
(
nsIThread
*
*
aResult
)
{
if
(
NS_WARN_IF
(
!
mMainThread
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
NS_ADDREF
(
*
aResult
=
mMainThread
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetCurrentThread
(
nsIThread
*
*
aResult
)
{
if
(
!
mMainThread
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
*
aResult
=
GetCurrentThread
(
)
;
if
(
!
*
aResult
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
NS_ADDREF
(
*
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
SpinEventLoopUntil
(
nsINestedEventLoopCondition
*
aCondition
)
{
nsCOMPtr
<
nsINestedEventLoopCondition
>
condition
(
aCondition
)
;
nsresult
rv
=
NS_OK
;
if
(
!
mozilla
:
:
SpinEventLoopUntil
(
[
&
]
(
)
-
>
bool
{
bool
isDone
=
false
;
rv
=
condition
-
>
IsDone
(
&
isDone
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
true
;
}
return
isDone
;
}
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
rv
;
}
NS_IMETHODIMP
nsThreadManager
:
:
SpinEventLoopUntilEmpty
(
)
{
nsIThread
*
thread
=
NS_GetCurrentThread
(
)
;
while
(
NS_HasPendingEvents
(
thread
)
)
{
(
void
)
NS_ProcessNextEvent
(
thread
false
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadManager
:
:
GetSystemGroupEventTarget
(
nsIEventTarget
*
*
aTarget
)
{
nsCOMPtr
<
nsIEventTarget
>
target
=
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
;
target
.
forget
(
aTarget
)
;
return
NS_OK
;
}
uint32_t
nsThreadManager
:
:
GetHighestNumberOfThreads
(
)
{
OffTheBooksMutexAutoLock
lock
(
mLock
)
;
return
mHighestNumberOfThreads
;
}
NS_IMETHODIMP
nsThreadManager
:
:
DispatchToMainThread
(
nsIRunnable
*
aEvent
uint32_t
aPriority
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
!
mMainThread
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
aPriority
!
=
nsIRunnablePriority
:
:
PRIORITY_NORMAL
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
return
mMainThread
-
>
DispatchFromScript
(
new
PrioritizableRunnable
(
event
.
forget
(
)
aPriority
)
0
)
;
}
return
mMainThread
-
>
DispatchFromScript
(
aEvent
0
)
;
}
void
nsThreadManager
:
:
EnableMainThreadEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
InputEventStatistics
:
:
Get
(
)
.
SetEnable
(
true
)
;
mMainThread
-
>
EnableInputEventPrioritization
(
)
;
}
void
nsThreadManager
:
:
FlushInputEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMainThread
-
>
FlushInputEventPrioritization
(
)
;
}
void
nsThreadManager
:
:
SuspendInputEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMainThread
-
>
SuspendInputEventPrioritization
(
)
;
}
void
nsThreadManager
:
:
ResumeInputEventPrioritization
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMainThread
-
>
ResumeInputEventPrioritization
(
)
;
}
NS_IMETHODIMP
nsThreadManager
:
:
IdleDispatchToMainThread
(
nsIRunnable
*
aEvent
uint32_t
aTimeout
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
if
(
aTimeout
)
{
return
NS_IdleDispatchToThread
(
event
.
forget
(
)
aTimeout
mMainThread
)
;
}
return
NS_IdleDispatchToThread
(
event
.
forget
(
)
mMainThread
)
;
}
