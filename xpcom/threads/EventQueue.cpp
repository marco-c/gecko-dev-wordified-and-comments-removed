#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
nsIRunnable
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
detail
;
template
<
size_t
ItemsPerPage
>
EventQueueInternal
<
ItemsPerPage
>
:
:
EventQueueInternal
(
EventQueuePriority
aPriority
)
{
}
template
<
size_t
ItemsPerPage
>
void
EventQueueInternal
<
ItemsPerPage
>
:
:
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventQueuePriority
aPriority
const
MutexAutoLock
&
aProofOfLock
mozilla
:
:
TimeDuration
*
aDelay
)
{
#
ifdef
MOZ_GECKO_PROFILER
if
(
profiler_is_active
(
)
)
{
while
(
mDispatchTimes
.
Count
(
)
<
mQueue
.
Count
(
)
)
{
mDispatchTimes
.
Push
(
TimeStamp
(
)
)
;
}
mDispatchTimes
.
Push
(
aDelay
?
TimeStamp
:
:
Now
(
)
-
*
aDelay
:
TimeStamp
:
:
Now
(
)
)
;
}
#
endif
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
mQueue
.
Push
(
std
:
:
move
(
event
)
)
;
}
template
<
size_t
ItemsPerPage
>
already_AddRefed
<
nsIRunnable
>
EventQueueInternal
<
ItemsPerPage
>
:
:
GetEvent
(
EventQueuePriority
*
aPriority
const
MutexAutoLock
&
aProofOfLock
mozilla
:
:
TimeDuration
*
aLastEventDelay
)
{
if
(
mQueue
.
IsEmpty
(
)
)
{
if
(
aLastEventDelay
)
{
*
aLastEventDelay
=
TimeDuration
(
)
;
}
return
nullptr
;
}
if
(
aPriority
)
{
*
aPriority
=
EventQueuePriority
:
:
Normal
;
}
#
ifdef
MOZ_GECKO_PROFILER
if
(
!
mDispatchTimes
.
IsEmpty
(
)
)
{
TimeStamp
dispatch_time
=
mDispatchTimes
.
Pop
(
)
;
if
(
profiler_is_active
(
)
)
{
if
(
!
dispatch_time
.
IsNull
(
)
)
{
if
(
aLastEventDelay
)
{
*
aLastEventDelay
=
TimeStamp
:
:
Now
(
)
-
dispatch_time
;
}
}
}
}
else
if
(
profiler_is_active
(
)
)
{
if
(
aLastEventDelay
)
{
*
aLastEventDelay
=
TimeDuration
(
)
;
}
}
#
endif
nsCOMPtr
<
nsIRunnable
>
result
=
mQueue
.
Pop
(
)
;
return
result
.
forget
(
)
;
}
template
<
size_t
ItemsPerPage
>
bool
EventQueueInternal
<
ItemsPerPage
>
:
:
IsEmpty
(
const
MutexAutoLock
&
aProofOfLock
)
{
return
mQueue
.
IsEmpty
(
)
;
}
template
<
size_t
ItemsPerPage
>
bool
EventQueueInternal
<
ItemsPerPage
>
:
:
HasReadyEvent
(
const
MutexAutoLock
&
aProofOfLock
)
{
return
!
IsEmpty
(
aProofOfLock
)
;
}
template
<
size_t
ItemsPerPage
>
size_t
EventQueueInternal
<
ItemsPerPage
>
:
:
Count
(
const
MutexAutoLock
&
aProofOfLock
)
const
{
return
mQueue
.
Count
(
)
;
}
