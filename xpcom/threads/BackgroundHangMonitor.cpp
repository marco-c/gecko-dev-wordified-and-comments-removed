#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
ThreadHangStats
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
prthread
.
h
"
#
include
"
ThreadStackHelper
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
<
algorithm
>
#
define
BHR_BETA_MOD
1
;
static
const
size_t
kMaxThreadHangStackDepth
=
30
;
bool
StackScriptEntriesCollapser
(
const
char
*
aStackEntry
const
char
*
aAnotherStackEntry
)
{
return
!
strcmp
(
aStackEntry
aAnotherStackEntry
)
&
&
(
!
strcmp
(
aStackEntry
"
(
chrome
script
)
"
)
|
|
!
strcmp
(
aStackEntry
"
(
content
script
)
"
)
)
;
}
namespace
mozilla
{
class
ProcessHangRunnable
;
class
BackgroundHangManager
:
public
nsIObserver
{
private
:
static
void
MonitorThread
(
void
*
aData
)
{
AutoProfilerRegisterThread
registerThread
(
"
BgHangMonitor
"
)
;
NS_SetCurrentThreadName
(
"
BgHangManager
"
)
;
static_cast
<
BackgroundHangManager
*
>
(
aData
)
-
>
RunMonitorThread
(
)
;
}
PRThread
*
mHangMonitorThread
;
bool
mShutdown
;
BackgroundHangManager
(
const
BackgroundHangManager
&
)
;
BackgroundHangManager
&
operator
=
(
const
BackgroundHangManager
&
)
;
void
RunMonitorThread
(
)
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
static
StaticRefPtr
<
BackgroundHangManager
>
sInstance
;
static
bool
sDisabled
;
Monitor
mLock
;
PRIntervalTime
mIntervalNow
;
LinkedList
<
BackgroundHangThread
>
mHangThreads
;
nsCOMPtr
<
nsIEventTarget
>
mSTS
;
void
Shutdown
(
)
{
MonitorAutoLock
autoLock
(
mLock
)
;
mShutdown
=
true
;
autoLock
.
Notify
(
)
;
}
void
Wakeup
(
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
mLock
.
NotifyAll
(
)
;
}
BackgroundHangManager
(
)
;
private
:
virtual
~
BackgroundHangManager
(
)
;
}
;
NS_IMPL_ISUPPORTS
(
BackgroundHangManager
nsIObserver
)
NS_IMETHODIMP
BackgroundHangManager
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
NS_ENSURE_TRUE
(
!
strcmp
(
aTopic
"
profile
-
after
-
change
"
)
NS_ERROR_UNEXPECTED
)
;
BackgroundHangMonitor
:
:
DisableOnBeta
(
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
observerService
)
;
observerService
-
>
RemoveObserver
(
this
"
profile
-
after
-
change
"
)
;
return
NS_OK
;
}
class
BackgroundHangThread
:
public
LinkedListElement
<
BackgroundHangThread
>
{
private
:
static
MOZ_THREAD_LOCAL
(
BackgroundHangThread
*
)
sTlsKey
;
static
bool
sTlsKeyInitialized
;
BackgroundHangThread
(
const
BackgroundHangThread
&
)
;
BackgroundHangThread
&
operator
=
(
const
BackgroundHangThread
&
)
;
~
BackgroundHangThread
(
)
;
const
RefPtr
<
BackgroundHangManager
>
mManager
;
const
PRThread
*
mThreadID
;
void
Update
(
)
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
BackgroundHangThread
)
static
BackgroundHangThread
*
FindThread
(
)
;
static
void
Startup
(
)
{
sTlsKeyInitialized
=
sTlsKey
.
init
(
)
;
}
const
PRIntervalTime
mTimeout
;
const
PRIntervalTime
mMaxTimeout
;
PRIntervalTime
mInterval
;
PRIntervalTime
mHangStart
;
bool
mHanging
;
bool
mWaiting
;
BackgroundHangMonitor
:
:
ThreadType
mThreadType
;
ThreadStackHelper
mStackHelper
;
Telemetry
:
:
HangStack
mHangStack
;
Telemetry
:
:
NativeHangStack
mNativeHangStack
;
Telemetry
:
:
ThreadHangStats
mStats
;
UniquePtr
<
HangMonitor
:
:
HangAnnotations
>
mAnnotations
;
HangMonitor
:
:
Observer
:
:
Annotators
mAnnotators
;
LinkedList
<
RefPtr
<
ProcessHangRunnable
>
>
mProcessHangRunnables
;
nsCString
mRunnableName
;
BackgroundHangThread
(
const
char
*
aName
uint32_t
aTimeoutMs
uint32_t
aMaxTimeoutMs
BackgroundHangMonitor
:
:
ThreadType
aThreadType
=
BackgroundHangMonitor
:
:
THREAD_SHARED
)
;
void
ReportHang
(
PRIntervalTime
aHangTime
)
;
void
ReportPermaHang
(
)
;
void
NotifyActivity
(
)
{
MonitorAutoLock
autoLock
(
mManager
-
>
mLock
)
;
Update
(
)
;
}
void
NotifyWait
(
)
{
MonitorAutoLock
autoLock
(
mManager
-
>
mLock
)
;
if
(
mWaiting
)
{
return
;
}
Update
(
)
;
mWaiting
=
true
;
}
bool
IsShared
(
)
{
return
mThreadType
=
=
BackgroundHangMonitor
:
:
THREAD_SHARED
;
}
}
;
StaticRefPtr
<
BackgroundHangManager
>
BackgroundHangManager
:
:
sInstance
;
bool
BackgroundHangManager
:
:
sDisabled
=
false
;
MOZ_THREAD_LOCAL
(
BackgroundHangThread
*
)
BackgroundHangThread
:
:
sTlsKey
;
bool
BackgroundHangThread
:
:
sTlsKeyInitialized
;
BackgroundHangManager
:
:
BackgroundHangManager
(
)
:
mShutdown
(
false
)
mLock
(
"
BackgroundHangManager
"
)
mIntervalNow
(
0
)
mSTS
(
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
)
{
MonitorAutoLock
autoLock
(
mLock
)
;
mHangMonitorThread
=
PR_CreateThread
(
PR_USER_THREAD
MonitorThread
this
PR_PRIORITY_LOW
PR_GLOBAL_THREAD
PR_JOINABLE_THREAD
0
)
;
MOZ_ASSERT
(
mHangMonitorThread
"
Failed
to
create
monitor
thread
"
)
;
}
BackgroundHangManager
:
:
~
BackgroundHangManager
(
)
{
MOZ_ASSERT
(
mShutdown
"
Destruction
without
Shutdown
call
"
)
;
MOZ_ASSERT
(
mHangThreads
.
isEmpty
(
)
"
Destruction
with
outstanding
monitors
"
)
;
MOZ_ASSERT
(
mHangMonitorThread
"
No
monitor
thread
"
)
;
if
(
mHangMonitorThread
)
{
PR_JoinThread
(
mHangMonitorThread
)
;
}
}
void
BackgroundHangManager
:
:
RunMonitorThread
(
)
{
profiler_initialize_stackwalk
(
)
;
MonitorAutoLock
autoLock
(
mLock
)
;
PRIntervalTime
systemTime
=
PR_IntervalNow
(
)
;
PRIntervalTime
waitTime
=
PR_INTERVAL_NO_WAIT
;
PRIntervalTime
recheckTimeout
=
PR_INTERVAL_NO_WAIT
;
while
(
!
mShutdown
)
{
nsresult
rv
=
autoLock
.
Wait
(
waitTime
)
;
PRIntervalTime
newTime
=
PR_IntervalNow
(
)
;
PRIntervalTime
systemInterval
=
newTime
-
systemTime
;
systemTime
=
newTime
;
if
(
MOZ_LIKELY
(
waitTime
!
=
PR_INTERVAL_NO_TIMEOUT
&
&
systemInterval
<
2
*
waitTime
)
)
{
mIntervalNow
+
=
systemInterval
;
}
if
(
MOZ_LIKELY
(
systemInterval
<
recheckTimeout
&
&
systemInterval
>
=
waitTime
&
&
rv
=
=
NS_OK
)
)
{
recheckTimeout
-
=
systemInterval
;
continue
;
}
waitTime
=
PR_INTERVAL_NO_TIMEOUT
;
recheckTimeout
=
PR_INTERVAL_NO_TIMEOUT
;
PRIntervalTime
intervalNow
=
mIntervalNow
;
for
(
BackgroundHangThread
*
currentThread
=
mHangThreads
.
getFirst
(
)
;
currentThread
;
currentThread
=
currentThread
-
>
getNext
(
)
)
{
if
(
currentThread
-
>
mWaiting
)
{
continue
;
}
PRIntervalTime
interval
=
currentThread
-
>
mInterval
;
PRIntervalTime
hangTime
=
intervalNow
-
interval
;
if
(
MOZ_UNLIKELY
(
hangTime
>
=
currentThread
-
>
mMaxTimeout
)
)
{
currentThread
-
>
mWaiting
=
true
;
currentThread
-
>
mHanging
=
false
;
currentThread
-
>
ReportPermaHang
(
)
;
continue
;
}
if
(
MOZ_LIKELY
(
!
currentThread
-
>
mHanging
)
)
{
if
(
MOZ_UNLIKELY
(
hangTime
>
=
currentThread
-
>
mTimeout
)
)
{
#
ifdef
NIGHTLY_BUILD
if
(
currentThread
-
>
mStats
.
mNativeStackCnt
<
Telemetry
:
:
kMaximumNativeHangStacks
)
{
currentThread
-
>
mStats
.
mNativeStackCnt
+
=
1
;
currentThread
-
>
mStackHelper
.
GetPseudoAndNativeStack
(
currentThread
-
>
mHangStack
currentThread
-
>
mNativeHangStack
currentThread
-
>
mRunnableName
)
;
}
else
{
currentThread
-
>
mStackHelper
.
GetPseudoStack
(
currentThread
-
>
mHangStack
currentThread
-
>
mRunnableName
)
;
}
#
else
currentThread
-
>
mStackHelper
.
GetPseudoStack
(
currentThread
-
>
mHangStack
currentThread
-
>
mRunnableName
)
;
#
endif
currentThread
-
>
mHangStart
=
interval
;
currentThread
-
>
mHanging
=
true
;
currentThread
-
>
mAnnotations
=
currentThread
-
>
mAnnotators
.
GatherAnnotations
(
)
;
}
}
else
{
if
(
MOZ_LIKELY
(
interval
!
=
currentThread
-
>
mHangStart
)
)
{
currentThread
-
>
ReportHang
(
intervalNow
-
currentThread
-
>
mHangStart
)
;
currentThread
-
>
mHanging
=
false
;
}
}
PRIntervalTime
nextRecheck
;
if
(
currentThread
-
>
mHanging
)
{
nextRecheck
=
currentThread
-
>
mMaxTimeout
;
}
else
{
nextRecheck
=
currentThread
-
>
mTimeout
;
}
recheckTimeout
=
std
:
:
min
(
recheckTimeout
nextRecheck
-
hangTime
)
;
if
(
currentThread
-
>
mTimeout
!
=
PR_INTERVAL_NO_TIMEOUT
)
{
waitTime
=
std
:
:
min
(
waitTime
currentThread
-
>
mTimeout
/
4
)
;
}
}
}
while
(
!
mHangThreads
.
isEmpty
(
)
)
{
autoLock
.
Wait
(
PR_INTERVAL_NO_TIMEOUT
)
;
}
}
BackgroundHangThread
:
:
BackgroundHangThread
(
const
char
*
aName
uint32_t
aTimeoutMs
uint32_t
aMaxTimeoutMs
BackgroundHangMonitor
:
:
ThreadType
aThreadType
)
:
mManager
(
BackgroundHangManager
:
:
sInstance
)
mThreadID
(
PR_GetCurrentThread
(
)
)
mTimeout
(
aTimeoutMs
=
=
BackgroundHangMonitor
:
:
kNoTimeout
?
PR_INTERVAL_NO_TIMEOUT
:
PR_MillisecondsToInterval
(
aTimeoutMs
)
)
mMaxTimeout
(
aMaxTimeoutMs
=
=
BackgroundHangMonitor
:
:
kNoTimeout
?
PR_INTERVAL_NO_TIMEOUT
:
PR_MillisecondsToInterval
(
aMaxTimeoutMs
)
)
mInterval
(
mManager
-
>
mIntervalNow
)
mHangStart
(
mInterval
)
mHanging
(
false
)
mWaiting
(
true
)
mThreadType
(
aThreadType
)
mStats
(
aName
)
{
if
(
sTlsKeyInitialized
&
&
IsShared
(
)
)
{
sTlsKey
.
set
(
this
)
;
}
MonitorAutoLock
autoLock
(
mManager
-
>
mLock
)
;
mManager
-
>
mHangThreads
.
insertBack
(
this
)
;
autoLock
.
Notify
(
)
;
}
class
ProcessHangRunnable
final
:
public
CancelableRunnable
public
LinkedListElement
<
RefPtr
<
ProcessHangRunnable
>
>
{
public
:
ProcessHangRunnable
(
BackgroundHangManager
*
aManager
BackgroundHangThread
*
aThread
Telemetry
:
:
HangHistogram
&
&
aHistogram
Telemetry
:
:
NativeHangStack
&
&
aNativeStack
)
:
CancelableRunnable
(
"
ProcessHangRunnable
"
)
mManager
(
aManager
)
mNativeStack
(
mozilla
:
:
Move
(
aNativeStack
)
)
mThread
(
aThread
)
mHistogram
(
mozilla
:
:
Move
(
aHistogram
)
)
{
MOZ_ASSERT
(
mThread
)
;
}
NS_IMETHOD
Run
(
)
override
{
Telemetry
:
:
ProcessedStack
processed
;
if
(
!
mNativeStack
.
empty
(
)
)
{
processed
=
Telemetry
:
:
GetStackAndModules
(
mNativeStack
)
;
}
{
MonitorAutoLock
autoLock
(
mManager
-
>
mLock
)
;
if
(
NS_WARN_IF
(
!
mThread
)
)
{
return
NS_OK
;
}
if
(
!
mNativeStack
.
empty
(
)
&
&
mThread
-
>
mStats
.
mCombinedStacks
.
GetStackCount
(
)
<
Telemetry
:
:
kMaximumNativeHangStacks
)
{
mHistogram
.
SetNativeStackIndex
(
mThread
-
>
mStats
.
mCombinedStacks
.
AddStack
(
processed
)
)
;
}
MOZ_ALWAYS_TRUE
(
mThread
-
>
mStats
.
mHangs
.
append
(
Move
(
mHistogram
)
)
)
;
remove
(
)
;
mThread
=
nullptr
;
}
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
mManager
-
>
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
NS_WARN_IF
(
!
mThread
)
)
{
return
NS_OK
;
}
MOZ_ALWAYS_TRUE
(
mThread
-
>
mStats
.
mHangs
.
append
(
Move
(
mHistogram
)
)
)
;
if
(
isInList
(
)
)
{
remove
(
)
;
}
mThread
=
nullptr
;
return
NS_OK
;
}
private
:
RefPtr
<
BackgroundHangManager
>
mManager
;
const
Telemetry
:
:
NativeHangStack
mNativeStack
;
BackgroundHangThread
*
MOZ_NON_OWNING_REF
mThread
;
Telemetry
:
:
HangHistogram
mHistogram
;
}
;
BackgroundHangThread
:
:
~
BackgroundHangThread
(
)
{
MonitorAutoLock
autoLock
(
mManager
-
>
mLock
)
;
remove
(
)
;
autoLock
.
Notify
(
)
;
if
(
sTlsKeyInitialized
&
&
IsShared
(
)
)
{
sTlsKey
.
set
(
nullptr
)
;
}
while
(
RefPtr
<
ProcessHangRunnable
>
runnable
=
mProcessHangRunnables
.
popFirst
(
)
)
{
runnable
-
>
Cancel
(
)
;
}
Telemetry
:
:
RecordThreadHangStats
(
Move
(
mStats
)
)
;
}
void
BackgroundHangThread
:
:
ReportHang
(
PRIntervalTime
aHangTime
)
{
for
(
size_t
i
=
0
;
i
<
mHangStack
.
length
(
)
;
)
{
const
char
*
*
f
=
mHangStack
.
begin
(
)
+
i
;
if
(
!
mHangStack
.
IsInBuffer
(
*
f
)
&
&
!
strcmp
(
*
f
"
js
:
:
RunScript
"
)
)
{
mHangStack
.
erase
(
f
)
;
}
else
{
i
+
+
;
}
}
auto
it
=
std
:
:
unique
(
mHangStack
.
begin
(
)
mHangStack
.
end
(
)
StackScriptEntriesCollapser
)
;
mHangStack
.
erase
(
it
mHangStack
.
end
(
)
)
;
if
(
mHangStack
.
length
(
)
>
kMaxThreadHangStackDepth
)
{
const
int
elementsToRemove
=
mHangStack
.
length
(
)
-
kMaxThreadHangStackDepth
;
mHangStack
[
0
]
=
"
(
reduced
stack
)
"
;
mHangStack
.
erase
(
mHangStack
.
begin
(
)
+
1
mHangStack
.
begin
(
)
+
elementsToRemove
)
;
}
Telemetry
:
:
HangHistogram
newHistogram
(
Move
(
mHangStack
)
mRunnableName
)
;
for
(
Telemetry
:
:
HangHistogram
*
oldHistogram
=
mStats
.
mHangs
.
begin
(
)
;
oldHistogram
!
=
mStats
.
mHangs
.
end
(
)
;
oldHistogram
+
+
)
{
if
(
newHistogram
=
=
*
oldHistogram
)
{
oldHistogram
-
>
Add
(
aHangTime
Move
(
mAnnotations
)
)
;
return
;
}
}
newHistogram
.
Add
(
aHangTime
Move
(
mAnnotations
)
)
;
RefPtr
<
ProcessHangRunnable
>
processHang
=
new
ProcessHangRunnable
(
mManager
this
Move
(
newHistogram
)
Move
(
mNativeHangStack
)
)
;
mProcessHangRunnables
.
insertFront
(
processHang
)
;
if
(
!
mManager
-
>
mSTS
|
|
NS_FAILED
(
mManager
-
>
mSTS
-
>
Dispatch
(
processHang
.
forget
(
)
)
)
)
{
RefPtr
<
ProcessHangRunnable
>
runnable
=
mProcessHangRunnables
.
popFirst
(
)
;
runnable
-
>
Cancel
(
)
;
}
}
void
BackgroundHangThread
:
:
ReportPermaHang
(
)
{
ReportHang
(
mMaxTimeout
)
;
}
MOZ_ALWAYS_INLINE
void
BackgroundHangThread
:
:
Update
(
)
{
PRIntervalTime
intervalNow
=
mManager
-
>
mIntervalNow
;
if
(
mWaiting
)
{
mInterval
=
intervalNow
;
mWaiting
=
false
;
mManager
-
>
Wakeup
(
)
;
}
else
{
PRIntervalTime
duration
=
intervalNow
-
mInterval
;
mStats
.
mActivity
.
Add
(
duration
)
;
if
(
MOZ_UNLIKELY
(
duration
>
=
mTimeout
)
)
{
mManager
-
>
Wakeup
(
)
;
}
mInterval
=
intervalNow
;
}
}
BackgroundHangThread
*
BackgroundHangThread
:
:
FindThread
(
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
if
(
BackgroundHangManager
:
:
sInstance
=
=
nullptr
)
{
MOZ_ASSERT
(
BackgroundHangManager
:
:
sDisabled
"
BackgroundHandleManager
is
not
initialized
"
)
;
return
nullptr
;
}
if
(
sTlsKeyInitialized
)
{
return
sTlsKey
.
get
(
)
;
}
RefPtr
<
BackgroundHangManager
>
manager
(
BackgroundHangManager
:
:
sInstance
)
;
MOZ_ASSERT
(
manager
"
Creating
BackgroundHangMonitor
after
shutdown
"
)
;
PRThread
*
threadID
=
PR_GetCurrentThread
(
)
;
MonitorAutoLock
autoLock
(
manager
-
>
mLock
)
;
for
(
BackgroundHangThread
*
thread
=
manager
-
>
mHangThreads
.
getFirst
(
)
;
thread
;
thread
=
thread
-
>
getNext
(
)
)
{
if
(
thread
-
>
mThreadID
=
=
threadID
&
&
thread
-
>
IsShared
(
)
)
{
return
thread
;
}
}
#
endif
return
nullptr
;
}
bool
BackgroundHangMonitor
:
:
ShouldDisableOnBeta
(
const
nsCString
&
clientID
)
{
MOZ_ASSERT
(
clientID
.
Length
(
)
=
=
36
"
clientID
is
invalid
"
)
;
const
char
*
suffix
=
clientID
.
get
(
)
+
clientID
.
Length
(
)
-
4
;
return
strtol
(
suffix
NULL
16
)
%
BHR_BETA_MOD
;
}
bool
BackgroundHangMonitor
:
:
IsDisabled
(
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
return
BackgroundHangManager
:
:
sDisabled
;
#
else
return
true
;
#
endif
}
bool
BackgroundHangMonitor
:
:
DisableOnBeta
(
)
{
nsAdoptingCString
clientID
=
Preferences
:
:
GetCString
(
"
toolkit
.
telemetry
.
cachedClientID
"
)
;
bool
telemetryEnabled
=
Preferences
:
:
GetBool
(
"
toolkit
.
telemetry
.
enabled
"
)
;
if
(
!
telemetryEnabled
|
|
!
clientID
|
|
BackgroundHangMonitor
:
:
ShouldDisableOnBeta
(
clientID
)
)
{
if
(
XRE_IsParentProcess
(
)
)
{
BackgroundHangMonitor
:
:
Shutdown
(
)
;
}
else
{
BackgroundHangManager
:
:
sDisabled
=
true
;
}
return
true
;
}
return
false
;
}
void
BackgroundHangMonitor
:
:
Startup
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
MOZ_ASSERT
(
!
BackgroundHangManager
:
:
sInstance
"
Already
initialized
"
)
;
if
(
!
strcmp
(
NS_STRINGIFY
(
MOZ_UPDATE_CHANNEL
)
"
beta
"
)
)
{
if
(
XRE_IsParentProcess
(
)
)
{
BackgroundHangThread
:
:
Startup
(
)
;
BackgroundHangManager
:
:
sInstance
=
new
BackgroundHangManager
(
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
observerService
)
;
observerService
-
>
AddObserver
(
BackgroundHangManager
:
:
sInstance
"
profile
-
after
-
change
"
false
)
;
return
;
}
else
if
(
DisableOnBeta
(
)
)
{
return
;
}
}
BackgroundHangThread
:
:
Startup
(
)
;
BackgroundHangManager
:
:
sInstance
=
new
BackgroundHangManager
(
)
;
#
endif
}
void
BackgroundHangMonitor
:
:
Shutdown
(
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
if
(
BackgroundHangManager
:
:
sDisabled
)
{
MOZ_ASSERT
(
!
BackgroundHangManager
:
:
sInstance
"
Initialized
"
)
;
return
;
}
MOZ_ASSERT
(
BackgroundHangManager
:
:
sInstance
"
Not
initialized
"
)
;
BackgroundHangManager
:
:
sInstance
-
>
Shutdown
(
)
;
BackgroundHangManager
:
:
sInstance
=
nullptr
;
BackgroundHangManager
:
:
sDisabled
=
true
;
#
endif
}
BackgroundHangMonitor
:
:
BackgroundHangMonitor
(
const
char
*
aName
uint32_t
aTimeoutMs
uint32_t
aMaxTimeoutMs
ThreadType
aThreadType
)
:
mThread
(
aThreadType
=
=
THREAD_SHARED
?
BackgroundHangThread
:
:
FindThread
(
)
:
nullptr
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
if
(
!
BackgroundHangManager
:
:
sDisabled
&
&
!
mThread
)
{
mThread
=
new
BackgroundHangThread
(
aName
aTimeoutMs
aMaxTimeoutMs
aThreadType
)
;
}
#
endif
}
BackgroundHangMonitor
:
:
BackgroundHangMonitor
(
)
:
mThread
(
BackgroundHangThread
:
:
FindThread
(
)
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
if
(
BackgroundHangManager
:
:
sDisabled
)
{
return
;
}
#
endif
}
BackgroundHangMonitor
:
:
~
BackgroundHangMonitor
(
)
{
}
void
BackgroundHangMonitor
:
:
NotifyActivity
(
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
if
(
mThread
=
=
nullptr
)
{
MOZ_ASSERT
(
BackgroundHangManager
:
:
sDisabled
"
This
thread
is
not
initialized
for
hang
monitoring
"
)
;
return
;
}
if
(
Telemetry
:
:
CanRecordExtended
(
)
)
{
mThread
-
>
NotifyActivity
(
)
;
}
#
endif
}
void
BackgroundHangMonitor
:
:
NotifyWait
(
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
if
(
mThread
=
=
nullptr
)
{
MOZ_ASSERT
(
BackgroundHangManager
:
:
sDisabled
"
This
thread
is
not
initialized
for
hang
monitoring
"
)
;
return
;
}
if
(
Telemetry
:
:
CanRecordExtended
(
)
)
{
mThread
-
>
NotifyWait
(
)
;
}
#
endif
}
bool
BackgroundHangMonitor
:
:
RegisterAnnotator
(
HangMonitor
:
:
Annotator
&
aAnnotator
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
BackgroundHangThread
*
thisThread
=
BackgroundHangThread
:
:
FindThread
(
)
;
if
(
!
thisThread
)
{
return
false
;
}
return
thisThread
-
>
mAnnotators
.
Register
(
aAnnotator
)
;
#
else
return
false
;
#
endif
}
bool
BackgroundHangMonitor
:
:
UnregisterAnnotator
(
HangMonitor
:
:
Annotator
&
aAnnotator
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
BackgroundHangThread
*
thisThread
=
BackgroundHangThread
:
:
FindThread
(
)
;
if
(
!
thisThread
)
{
return
false
;
}
return
thisThread
-
>
mAnnotators
.
Unregister
(
aAnnotator
)
;
#
else
return
false
;
#
endif
}
BackgroundHangMonitor
:
:
ThreadHangStatsIterator
:
:
ThreadHangStatsIterator
(
)
:
MonitorAutoLock
(
BackgroundHangManager
:
:
sInstance
-
>
mLock
)
mThread
(
BackgroundHangManager
:
:
sInstance
?
BackgroundHangManager
:
:
sInstance
-
>
mHangThreads
.
getFirst
(
)
:
nullptr
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
MOZ_ASSERT
(
BackgroundHangManager
:
:
sInstance
|
|
BackgroundHangManager
:
:
sDisabled
"
Inconsistent
state
"
)
;
#
endif
}
Telemetry
:
:
ThreadHangStats
*
BackgroundHangMonitor
:
:
ThreadHangStatsIterator
:
:
GetNext
(
)
{
if
(
!
mThread
)
{
return
nullptr
;
}
Telemetry
:
:
ThreadHangStats
*
stats
=
&
mThread
-
>
mStats
;
mThread
=
mThread
-
>
getNext
(
)
;
return
stats
;
}
}
