#
ifndef
mozilla_EventQueue_h
#
define
mozilla_EventQueue_h
#
include
"
mozilla
/
AbstractEventQueue
.
h
"
#
include
"
mozilla
/
Queue
.
h
"
#
include
"
nsCOMPtr
.
h
"
class
nsIRunnable
;
namespace
mozilla
{
class
EventQueue
final
:
public
AbstractEventQueue
{
public
:
static
const
bool
SupportsPrioritization
=
false
;
EventQueue
(
)
{
}
explicit
EventQueue
(
EventPriority
aPriority
)
;
void
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventPriority
aPriority
const
MutexAutoLock
&
aProofOfLock
)
final
override
;
already_AddRefed
<
nsIRunnable
>
GetEvent
(
EventPriority
*
aPriority
const
MutexAutoLock
&
aProofOfLock
)
final
override
;
bool
IsEmpty
(
const
MutexAutoLock
&
aProofOfLock
)
final
override
;
bool
HasReadyEvent
(
const
MutexAutoLock
&
aProofOfLock
)
final
override
;
size_t
Count
(
const
MutexAutoLock
&
aProofOfLock
)
const
final
override
;
already_AddRefed
<
nsIRunnable
>
PeekEvent
(
const
MutexAutoLock
&
aProofOfLock
)
;
void
EnableInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
final
override
{
}
void
FlushInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
final
override
{
}
void
SuspendInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
final
override
{
}
void
ResumeInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
final
override
{
}
private
:
mozilla
:
:
Queue
<
nsCOMPtr
<
nsIRunnable
>
>
mQueue
;
}
;
}
#
endif
