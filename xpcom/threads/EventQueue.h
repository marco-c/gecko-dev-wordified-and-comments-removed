#
ifndef
mozilla_EventQueue_h
#
define
mozilla_EventQueue_h
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Queue
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsCOMPtr
.
h
"
class
nsIRunnable
;
namespace
mozilla
{
#
define
EVENT_QUEUE_PRIORITY_LIST
(
EVENT_PRIORITY
)
\
EVENT_PRIORITY
(
Idle
0
)
\
EVENT_PRIORITY
(
DeferredTimers
1
)
\
EVENT_PRIORITY
(
InputLow
2
)
\
EVENT_PRIORITY
(
Normal
3
)
\
EVENT_PRIORITY
(
MediumHigh
4
)
\
EVENT_PRIORITY
(
InputHigh
5
)
\
EVENT_PRIORITY
(
Vsync
6
)
\
EVENT_PRIORITY
(
InputHighest
7
)
\
EVENT_PRIORITY
(
RenderBlocking
8
)
\
EVENT_PRIORITY
(
Control
9
)
enum
class
EventQueuePriority
{
#
define
EVENT_PRIORITY
(
NAME
VALUE
)
NAME
=
VALUE
EVENT_QUEUE_PRIORITY_LIST
(
EVENT_PRIORITY
)
#
undef
EVENT_PRIORITY
Invalid
}
;
class
IdlePeriodState
;
namespace
detail
{
template
<
size_t
ItemsPerPage
>
class
EventQueueInternal
{
public
:
explicit
EventQueueInternal
(
bool
aForwardToTC
)
:
mForwardToTC
(
aForwardToTC
)
{
}
void
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventQueuePriority
aPriority
const
MutexAutoLock
&
aProofOfLock
mozilla
:
:
TimeDuration
*
aDelay
=
nullptr
)
;
already_AddRefed
<
nsIRunnable
>
GetEvent
(
const
MutexAutoLock
&
aProofOfLock
mozilla
:
:
TimeDuration
*
aLastEventDelay
=
nullptr
)
;
bool
IsEmpty
(
const
MutexAutoLock
&
aProofOfLock
)
;
bool
HasReadyEvent
(
const
MutexAutoLock
&
aProofOfLock
)
;
size_t
Count
(
const
MutexAutoLock
&
aProofOfLock
)
const
;
already_AddRefed
<
nsIRunnable
>
PeekEvent
(
const
MutexAutoLock
&
aProofOfLock
)
{
if
(
mQueue
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIRunnable
>
result
=
mQueue
.
FirstElement
(
)
;
return
result
.
forget
(
)
;
}
void
EnableInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
}
void
FlushInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
}
void
SuspendInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
}
void
ResumeInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
{
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
size
=
mQueue
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
size
+
=
mDispatchTimes
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
size
;
}
private
:
mozilla
:
:
Queue
<
nsCOMPtr
<
nsIRunnable
>
ItemsPerPage
>
mQueue
;
mozilla
:
:
Queue
<
mozilla
:
:
TimeStamp
ItemsPerPage
>
mDispatchTimes
;
TimeDuration
mLastEventDelay
;
bool
mForwardToTC
;
}
;
}
class
EventQueue
final
:
public
mozilla
:
:
detail
:
:
EventQueueInternal
<
16
>
{
public
:
explicit
EventQueue
(
bool
aForwardToTC
=
false
)
:
mozilla
:
:
detail
:
:
EventQueueInternal
<
16
>
(
aForwardToTC
)
{
}
}
;
template
<
size_t
ItemsPerPage
=
16
>
class
EventQueueSized
final
:
public
mozilla
:
:
detail
:
:
EventQueueInternal
<
ItemsPerPage
>
{
public
:
explicit
EventQueueSized
(
bool
aForwardToTC
=
false
)
:
mozilla
:
:
detail
:
:
EventQueueInternal
<
ItemsPerPage
>
(
aForwardToTC
)
{
}
}
;
}
#
endif
