#
include
"
nsCOMArray
.
h
"
#
include
"
ThreadDelay
.
h
"
#
include
"
nsThreadPool
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
nsThreadSyncDispatch
.
h
"
#
include
<
mutex
>
using
namespace
mozilla
;
static
LazyLogModule
sThreadPoolLog
(
"
nsThreadPool
"
)
;
#
ifdef
LOG
#
undef
LOG
#
endif
#
define
LOG
(
args
)
MOZ_LOG
(
sThreadPoolLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
static
MOZ_THREAD_LOCAL
(
nsThreadPool
*
)
gCurrentThreadPool
;
#
define
DEFAULT_THREAD_LIMIT
4
#
define
DEFAULT_IDLE_THREAD_LIMIT
1
#
define
DEFAULT_IDLE_THREAD_TIMEOUT
PR_SecondsToInterval
(
60
)
NS_IMPL_ADDREF
(
nsThreadPool
)
NS_IMPL_RELEASE
(
nsThreadPool
)
NS_IMPL_QUERY_INTERFACE
(
nsThreadPool
nsIThreadPool
nsIEventTarget
nsIRunnable
)
nsThreadPool
:
:
nsThreadPool
(
)
:
mMutex
(
"
[
nsThreadPool
.
mMutex
]
"
)
mEventsAvailable
(
mMutex
"
[
nsThreadPool
.
mEventsAvailable
]
"
)
mThreadLimit
(
DEFAULT_THREAD_LIMIT
)
mIdleThreadLimit
(
DEFAULT_IDLE_THREAD_LIMIT
)
mIdleThreadTimeout
(
DEFAULT_IDLE_THREAD_TIMEOUT
)
mIdleCount
(
0
)
mStackSize
(
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
)
mShutdown
(
false
)
mRegressiveMaxIdleTime
(
false
)
mIsAPoolThreadFree
(
true
)
{
static
std
:
:
once_flag
flag
;
std
:
:
call_once
(
flag
[
]
{
gCurrentThreadPool
.
infallibleInit
(
)
;
}
)
;
LOG
(
(
"
THRD
-
P
(
%
p
)
constructor
!
!
!
\
n
"
this
)
)
;
}
nsThreadPool
:
:
~
nsThreadPool
(
)
{
MOZ_ASSERT
(
mThreads
.
IsEmpty
(
)
)
;
}
nsresult
nsThreadPool
:
:
PutEvent
(
nsIRunnable
*
aEvent
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
return
PutEvent
(
event
.
forget
(
)
0
)
;
}
nsresult
nsThreadPool
:
:
PutEvent
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
bool
spawnThread
=
false
;
uint32_t
stackSize
=
0
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
NS_WARN_IF
(
mShutdown
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
LOG
(
(
"
THRD
-
P
(
%
p
)
put
[
%
d
%
d
%
d
]
\
n
"
this
mIdleCount
mThreads
.
Count
(
)
mThreadLimit
)
)
;
MOZ_ASSERT
(
mIdleCount
<
=
(
uint32_t
)
mThreads
.
Count
(
)
"
oops
"
)
;
if
(
mThreads
.
Count
(
)
<
(
int32_t
)
mThreadLimit
&
&
!
(
aFlags
&
NS_DISPATCH_AT_END
)
&
&
mEvents
.
Count
(
lock
)
>
=
mIdleCount
)
{
spawnThread
=
true
;
}
mEvents
.
PutEvent
(
std
:
:
move
(
aEvent
)
EventQueuePriority
:
:
Normal
lock
)
;
mEventsAvailable
.
Notify
(
)
;
stackSize
=
mStackSize
;
}
auto
delay
=
MakeScopeExit
(
[
&
]
(
)
{
DelayForChaosMode
(
ChaosFeature
:
:
TaskDispatching
1000
)
;
}
)
;
LOG
(
(
"
THRD
-
P
(
%
p
)
put
[
spawn
=
%
d
]
\
n
"
this
spawnThread
)
)
;
if
(
!
spawnThread
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
mThreadNaming
.
GetNextThreadName
(
mName
)
getter_AddRefs
(
thread
)
nullptr
stackSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
bool
killThread
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mShutdown
)
{
killThread
=
true
;
}
else
if
(
mThreads
.
Count
(
)
<
(
int32_t
)
mThreadLimit
)
{
mThreads
.
AppendObject
(
thread
)
;
if
(
mThreads
.
Count
(
)
>
=
(
int32_t
)
mThreadLimit
)
{
mIsAPoolThreadFree
=
false
;
}
}
else
{
killThread
=
true
;
}
}
LOG
(
(
"
THRD
-
P
(
%
p
)
put
[
%
p
kill
=
%
d
]
\
n
"
this
thread
.
get
(
)
killThread
)
)
;
if
(
killThread
)
{
ShutdownThread
(
thread
)
;
}
else
{
thread
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
}
return
NS_OK
;
}
void
nsThreadPool
:
:
ShutdownThread
(
nsIThread
*
aThread
)
{
LOG
(
(
"
THRD
-
P
(
%
p
)
shutdown
async
[
%
p
]
\
n
"
this
aThread
)
)
;
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
NewRunnableMethod
(
"
nsIThread
:
:
AsyncShutdown
"
aThread
&
nsIThread
:
:
AsyncShutdown
)
)
;
}
NS_IMETHODIMP
nsThreadPool
:
:
Run
(
)
{
LOG
(
(
"
THRD
-
P
(
%
p
)
enter
%
s
\
n
"
this
mName
.
BeginReading
(
)
)
)
;
nsCOMPtr
<
nsIThread
>
current
;
nsThreadManager
:
:
get
(
)
.
GetCurrentThread
(
getter_AddRefs
(
current
)
)
;
bool
shutdownThreadOnExit
=
false
;
bool
exitThread
=
false
;
bool
wasIdle
=
false
;
TimeStamp
idleSince
;
static_cast
<
nsThread
*
>
(
current
.
get
(
)
)
-
>
SetPoolThreadFreePtr
(
&
mIsAPoolThreadFree
)
;
nsCOMPtr
<
nsIThreadPoolListener
>
listener
;
{
MutexAutoLock
lock
(
mMutex
)
;
listener
=
mListener
;
}
if
(
listener
)
{
listener
-
>
OnThreadCreated
(
)
;
}
MOZ_ASSERT
(
!
gCurrentThreadPool
.
get
(
)
)
;
gCurrentThreadPool
.
set
(
this
)
;
do
{
nsCOMPtr
<
nsIRunnable
>
event
;
TimeDuration
delay
;
{
MutexAutoLock
lock
(
mMutex
)
;
event
=
mEvents
.
GetEvent
(
nullptr
lock
&
delay
)
;
if
(
!
event
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
uint32_t
idleTimeoutDivider
=
(
mIdleCount
&
&
mRegressiveMaxIdleTime
)
?
mIdleCount
:
1
;
TimeDuration
timeout
=
TimeDuration
:
:
FromMilliseconds
(
static_cast
<
double
>
(
mIdleThreadTimeout
)
/
idleTimeoutDivider
)
;
if
(
mShutdown
)
{
exitThread
=
true
;
}
else
{
if
(
wasIdle
)
{
if
(
mIdleCount
>
mIdleThreadLimit
|
|
(
mIdleThreadTimeout
!
=
UINT32_MAX
&
&
(
now
-
idleSince
)
>
=
timeout
)
)
{
exitThread
=
true
;
}
}
else
{
if
(
mIdleCount
=
=
mIdleThreadLimit
)
{
exitThread
=
true
;
}
else
{
+
+
mIdleCount
;
idleSince
=
now
;
wasIdle
=
true
;
}
}
}
if
(
exitThread
)
{
if
(
wasIdle
)
{
-
-
mIdleCount
;
}
shutdownThreadOnExit
=
mThreads
.
RemoveObject
(
current
)
;
mIsAPoolThreadFree
=
(
mThreads
.
Count
(
)
<
(
int32_t
)
mThreadLimit
)
;
}
else
{
current
-
>
SetRunningEventDelay
(
TimeDuration
(
)
TimeStamp
(
)
)
;
AUTO_PROFILER_LABEL
(
"
nsThreadPool
:
:
Run
:
:
Wait
"
IDLE
)
;
TimeDuration
delta
=
timeout
-
(
now
-
idleSince
)
;
LOG
(
(
"
THRD
-
P
(
%
p
)
%
s
waiting
[
%
f
]
\
n
"
this
mName
.
BeginReading
(
)
delta
.
ToMilliseconds
(
)
)
)
;
{
AUTO_PROFILER_THREAD_SLEEP
;
mEventsAvailable
.
Wait
(
delta
)
;
}
LOG
(
(
"
THRD
-
P
(
%
p
)
done
waiting
\
n
"
this
)
)
;
}
}
else
if
(
wasIdle
)
{
wasIdle
=
false
;
-
-
mIdleCount
;
}
}
if
(
event
)
{
LOG
(
(
"
THRD
-
P
(
%
p
)
%
s
running
[
%
p
]
\
n
"
this
mName
.
BeginReading
(
)
event
.
get
(
)
)
)
;
DelayForChaosMode
(
ChaosFeature
:
:
TaskRunning
1000
)
;
current
-
>
SetRunningEventDelay
(
delay
TimeStamp
:
:
Now
(
)
)
;
event
-
>
Run
(
)
;
}
}
while
(
!
exitThread
)
;
if
(
listener
)
{
listener
-
>
OnThreadShuttingDown
(
)
;
}
MOZ_ASSERT
(
gCurrentThreadPool
.
get
(
)
=
=
this
)
;
gCurrentThreadPool
.
set
(
nullptr
)
;
if
(
shutdownThreadOnExit
)
{
ShutdownThread
(
current
)
;
}
LOG
(
(
"
THRD
-
P
(
%
p
)
leave
\
n
"
this
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
DispatchFromScript
(
nsIRunnable
*
aEvent
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
return
Dispatch
(
event
.
forget
(
)
aFlags
)
;
}
NS_IMETHODIMP
nsThreadPool
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
LOG
(
(
"
THRD
-
P
(
%
p
)
dispatch
[
%
p
%
x
]
\
n
"
this
nullptr
aFlags
)
)
;
if
(
NS_WARN_IF
(
mShutdown
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
aFlags
&
DISPATCH_SYNC
)
{
nsCOMPtr
<
nsIThread
>
thread
;
nsThreadManager
:
:
get
(
)
.
GetCurrentThread
(
getter_AddRefs
(
thread
)
)
;
if
(
NS_WARN_IF
(
!
thread
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
nsThreadSyncDispatch
>
wrapper
=
new
nsThreadSyncDispatch
(
thread
.
forget
(
)
std
:
:
move
(
aEvent
)
)
;
PutEvent
(
wrapper
)
;
SpinEventLoopUntil
(
[
&
wrapper
]
(
)
-
>
bool
{
return
!
wrapper
-
>
IsPending
(
)
;
}
)
;
}
else
{
NS_ASSERTION
(
aFlags
=
=
NS_DISPATCH_NORMAL
|
|
aFlags
=
=
NS_DISPATCH_AT_END
"
unexpected
dispatch
flags
"
)
;
PutEvent
(
std
:
:
move
(
aEvent
)
aFlags
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
uint32_t
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP_
(
bool
)
nsThreadPool
:
:
IsOnCurrentThreadInfallible
(
)
{
return
gCurrentThreadPool
.
get
(
)
=
=
this
;
}
NS_IMETHODIMP
nsThreadPool
:
:
IsOnCurrentThread
(
bool
*
aResult
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
NS_WARN_IF
(
mShutdown
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aResult
=
IsOnCurrentThreadInfallible
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
Shutdown
(
)
{
nsCOMArray
<
nsIThread
>
threads
;
nsCOMPtr
<
nsIThreadPoolListener
>
listener
;
{
MutexAutoLock
lock
(
mMutex
)
;
mShutdown
=
true
;
mEventsAvailable
.
NotifyAll
(
)
;
threads
.
AppendObjects
(
mThreads
)
;
mThreads
.
Clear
(
)
;
mListener
.
swap
(
listener
)
;
}
for
(
int32_t
i
=
0
;
i
<
threads
.
Count
(
)
;
+
+
i
)
{
threads
[
i
]
-
>
Shutdown
(
)
;
}
return
NS_OK
;
}
template
<
typename
Pred
>
static
void
SpinMTEventLoopUntil
(
Pred
&
&
aPredicate
nsIThread
*
aThread
TimeDuration
aTimeout
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
run
on
the
main
thread
"
)
;
mozilla
:
:
Maybe
<
xpc
:
:
AutoScriptActivity
>
asa
;
asa
.
emplace
(
false
)
;
TimeStamp
deadline
=
TimeStamp
:
:
Now
(
)
+
aTimeout
;
while
(
!
aPredicate
(
)
&
&
TimeStamp
:
:
Now
(
)
<
deadline
)
{
if
(
!
NS_ProcessNextEvent
(
aThread
false
)
)
{
PR_Sleep
(
PR_MillisecondsToInterval
(
1
)
)
;
}
}
}
NS_IMETHODIMP
nsThreadPool
:
:
ShutdownWithTimeout
(
int32_t
aTimeoutMs
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMArray
<
nsIThread
>
threads
;
nsCOMPtr
<
nsIThreadPoolListener
>
listener
;
{
MutexAutoLock
lock
(
mMutex
)
;
mShutdown
=
true
;
mEventsAvailable
.
NotifyAll
(
)
;
threads
.
AppendObjects
(
mThreads
)
;
mThreads
.
Clear
(
)
;
mListener
.
swap
(
listener
)
;
}
nsTArray
<
nsThreadShutdownContext
*
>
contexts
;
for
(
int32_t
i
=
0
;
i
<
threads
.
Count
(
)
;
+
+
i
)
{
nsThreadShutdownContext
*
maybeContext
=
static_cast
<
nsThread
*
>
(
threads
[
i
]
)
-
>
ShutdownInternal
(
false
)
;
contexts
.
AppendElement
(
maybeContext
)
;
}
NotNull
<
nsThread
*
>
currentThread
=
WrapNotNull
(
nsThreadManager
:
:
get
(
)
.
GetCurrentThread
(
)
)
;
SpinMTEventLoopUntil
(
[
&
]
(
)
{
for
(
nsIThread
*
thread
:
threads
)
{
if
(
static_cast
<
nsThread
*
>
(
thread
)
-
>
mThread
)
{
return
false
;
}
}
return
true
;
}
currentThread
TimeDuration
:
:
FromMilliseconds
(
aTimeoutMs
)
)
;
static
const
nsThread
:
:
ShutdownContextsComp
comparator
{
}
;
for
(
int32_t
i
=
0
;
i
<
threads
.
Count
(
)
;
+
+
i
)
{
nsThread
*
thread
=
static_cast
<
nsThread
*
>
(
threads
[
i
]
)
;
if
(
thread
-
>
mThread
&
&
contexts
[
i
]
)
{
auto
index
=
currentThread
-
>
mRequestedShutdownContexts
.
IndexOf
(
contexts
[
i
]
0
comparator
)
;
if
(
index
!
=
nsThread
:
:
ShutdownContexts
:
:
NoIndex
)
{
Unused
<
<
currentThread
-
>
mRequestedShutdownContexts
[
index
]
.
release
(
)
;
currentThread
-
>
mRequestedShutdownContexts
.
RemoveElementsAt
(
index
1
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
GetThreadLimit
(
uint32_t
*
aValue
)
{
*
aValue
=
mThreadLimit
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetThreadLimit
(
uint32_t
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
LOG
(
(
"
THRD
-
P
(
%
p
)
thread
limit
[
%
u
]
\
n
"
this
aValue
)
)
;
mThreadLimit
=
aValue
;
if
(
mIdleThreadLimit
>
mThreadLimit
)
{
mIdleThreadLimit
=
mThreadLimit
;
}
if
(
static_cast
<
uint32_t
>
(
mThreads
.
Count
(
)
)
>
mThreadLimit
)
{
mEventsAvailable
.
NotifyAll
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
GetIdleThreadLimit
(
uint32_t
*
aValue
)
{
*
aValue
=
mIdleThreadLimit
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetIdleThreadLimit
(
uint32_t
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
LOG
(
(
"
THRD
-
P
(
%
p
)
idle
thread
limit
[
%
u
]
\
n
"
this
aValue
)
)
;
mIdleThreadLimit
=
aValue
;
if
(
mIdleThreadLimit
>
mThreadLimit
)
{
mIdleThreadLimit
=
mThreadLimit
;
}
if
(
mIdleCount
>
mIdleThreadLimit
)
{
mEventsAvailable
.
NotifyAll
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
GetIdleThreadTimeout
(
uint32_t
*
aValue
)
{
*
aValue
=
mIdleThreadTimeout
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetIdleThreadTimeout
(
uint32_t
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
uint32_t
oldTimeout
=
mIdleThreadTimeout
;
mIdleThreadTimeout
=
aValue
;
if
(
mIdleThreadTimeout
<
oldTimeout
&
&
mIdleCount
>
0
)
{
mEventsAvailable
.
NotifyAll
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
GetIdleThreadTimeoutRegressive
(
bool
*
aValue
)
{
*
aValue
=
mRegressiveMaxIdleTime
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetIdleThreadTimeoutRegressive
(
bool
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
bool
oldRegressive
=
mRegressiveMaxIdleTime
;
mRegressiveMaxIdleTime
=
aValue
;
if
(
mRegressiveMaxIdleTime
>
oldRegressive
&
&
mIdleCount
>
1
)
{
mEventsAvailable
.
NotifyAll
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
GetThreadStackSize
(
uint32_t
*
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
*
aValue
=
mStackSize
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetThreadStackSize
(
uint32_t
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
mStackSize
=
aValue
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
GetListener
(
nsIThreadPoolListener
*
*
aListener
)
{
MutexAutoLock
lock
(
mMutex
)
;
NS_IF_ADDREF
(
*
aListener
=
mListener
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetListener
(
nsIThreadPoolListener
*
aListener
)
{
nsCOMPtr
<
nsIThreadPoolListener
>
swappedListener
(
aListener
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
mListener
.
swap
(
swappedListener
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetName
(
const
nsACString
&
aName
)
{
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mThreads
.
Count
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
mName
=
aName
;
return
NS_OK
;
}
