#
include
"
nsThreadPool
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
ThreadDelay
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
ProfilerRunnable
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
nsThreadSyncDispatch
.
h
"
#
include
<
mutex
>
using
namespace
mozilla
;
static
LazyLogModule
sThreadPoolLog
(
"
nsThreadPool
"
)
;
#
ifdef
LOG
#
undef
LOG
#
endif
#
define
LOG
(
args
)
MOZ_LOG
(
sThreadPoolLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
static
MOZ_THREAD_LOCAL
(
nsThreadPool
*
)
gCurrentThreadPool
;
#
define
DEFAULT_THREAD_LIMIT
4
#
define
DEFAULT_IDLE_THREAD_LIMIT
1
#
define
DEFAULT_IDLE_THREAD_TIMEOUT
PR_SecondsToInterval
(
60
)
NS_IMPL_ISUPPORTS_INHERITED
(
nsThreadPool
Runnable
nsIThreadPool
nsIEventTarget
)
nsThreadPool
:
:
nsThreadPool
(
)
:
Runnable
(
"
nsThreadPool
"
)
mMutex
(
"
[
nsThreadPool
.
mMutex
]
"
)
mEventsAvailable
(
mMutex
"
[
nsThreadPool
.
mEventsAvailable
]
"
)
mThreadLimit
(
DEFAULT_THREAD_LIMIT
)
mIdleThreadLimit
(
DEFAULT_IDLE_THREAD_LIMIT
)
mIdleThreadTimeout
(
DEFAULT_IDLE_THREAD_TIMEOUT
)
mIdleCount
(
0
)
mStackSize
(
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
)
mShutdown
(
false
)
mRegressiveMaxIdleTime
(
false
)
mIsAPoolThreadFree
(
true
)
{
static
std
:
:
once_flag
flag
;
std
:
:
call_once
(
flag
[
]
{
gCurrentThreadPool
.
infallibleInit
(
)
;
}
)
;
LOG
(
(
"
THRD
-
P
(
%
p
)
constructor
!
!
!
\
n
"
this
)
)
;
}
nsThreadPool
:
:
~
nsThreadPool
(
)
{
MOZ_ASSERT
(
mThreads
.
IsEmpty
(
)
)
;
}
nsresult
nsThreadPool
:
:
PutEvent
(
nsIRunnable
*
aEvent
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
return
PutEvent
(
event
.
forget
(
)
0
)
;
}
nsresult
nsThreadPool
:
:
PutEvent
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
bool
spawnThread
=
false
;
uint32_t
stackSize
=
0
;
nsCString
name
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
NS_WARN_IF
(
mShutdown
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
LOG
(
(
"
THRD
-
P
(
%
p
)
put
[
%
d
%
d
%
d
]
\
n
"
this
mIdleCount
mThreads
.
Count
(
)
mThreadLimit
)
)
;
MOZ_ASSERT
(
mIdleCount
<
=
(
uint32_t
)
mThreads
.
Count
(
)
"
oops
"
)
;
if
(
mThreads
.
Count
(
)
<
(
int32_t
)
mThreadLimit
&
&
!
(
aFlags
&
NS_DISPATCH_AT_END
)
&
&
mEvents
.
Count
(
lock
)
>
=
mIdleCount
)
{
spawnThread
=
true
;
}
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
LogRunnable
:
:
LogDispatch
(
event
)
;
mEvents
.
PutEvent
(
event
.
forget
(
)
EventQueuePriority
:
:
Normal
lock
)
;
mEventsAvailable
.
Notify
(
)
;
stackSize
=
mStackSize
;
name
=
mName
;
}
auto
delay
=
MakeScopeExit
(
[
&
]
(
)
{
DelayForChaosMode
(
ChaosFeature
:
:
TaskDispatching
1000
)
;
}
)
;
LOG
(
(
"
THRD
-
P
(
%
p
)
put
[
spawn
=
%
d
]
\
n
"
this
spawnThread
)
)
;
if
(
!
spawnThread
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
mThreadNaming
.
GetNextThreadName
(
name
)
getter_AddRefs
(
thread
)
nullptr
stackSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
bool
killThread
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mShutdown
)
{
killThread
=
true
;
}
else
if
(
mThreads
.
Count
(
)
<
(
int32_t
)
mThreadLimit
)
{
mThreads
.
AppendObject
(
thread
)
;
if
(
mThreads
.
Count
(
)
>
=
(
int32_t
)
mThreadLimit
)
{
mIsAPoolThreadFree
=
false
;
}
}
else
{
killThread
=
true
;
}
}
LOG
(
(
"
THRD
-
P
(
%
p
)
put
[
%
p
kill
=
%
d
]
\
n
"
this
thread
.
get
(
)
killThread
)
)
;
if
(
killThread
)
{
ShutdownThread
(
thread
)
;
}
else
{
thread
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
}
return
NS_OK
;
}
void
nsThreadPool
:
:
ShutdownThread
(
nsIThread
*
aThread
)
{
LOG
(
(
"
THRD
-
P
(
%
p
)
shutdown
async
[
%
p
]
\
n
"
this
aThread
)
)
;
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
NewRunnableMethod
(
"
nsIThread
:
:
AsyncShutdown
"
aThread
&
nsIThread
:
:
AsyncShutdown
)
)
;
}
NS_IMETHODIMP
nsThreadPool
:
:
Run
(
)
{
nsCOMPtr
<
nsIThread
>
current
;
nsThreadManager
:
:
get
(
)
.
GetCurrentThread
(
getter_AddRefs
(
current
)
)
;
bool
shutdownThreadOnExit
=
false
;
bool
exitThread
=
false
;
bool
wasIdle
=
false
;
TimeStamp
idleSince
;
static_cast
<
nsThread
*
>
(
current
.
get
(
)
)
-
>
SetPoolThreadFreePtr
(
&
mIsAPoolThreadFree
)
;
nsCOMPtr
<
nsIThreadPoolListener
>
listener
;
{
MutexAutoLock
lock
(
mMutex
)
;
listener
=
mListener
;
LOG
(
(
"
THRD
-
P
(
%
p
)
enter
%
s
\
n
"
this
mName
.
BeginReading
(
)
)
)
;
}
if
(
listener
)
{
listener
-
>
OnThreadCreated
(
)
;
}
MOZ_ASSERT
(
!
gCurrentThreadPool
.
get
(
)
)
;
gCurrentThreadPool
.
set
(
this
)
;
do
{
nsCOMPtr
<
nsIRunnable
>
event
;
TimeDuration
delay
;
{
MutexAutoLock
lock
(
mMutex
)
;
event
=
mEvents
.
GetEvent
(
lock
&
delay
)
;
if
(
!
event
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
uint32_t
idleTimeoutDivider
=
(
mIdleCount
&
&
mRegressiveMaxIdleTime
)
?
mIdleCount
:
1
;
TimeDuration
timeout
=
TimeDuration
:
:
FromMilliseconds
(
static_cast
<
double
>
(
mIdleThreadTimeout
)
/
idleTimeoutDivider
)
;
if
(
mShutdown
)
{
exitThread
=
true
;
}
else
{
if
(
wasIdle
)
{
if
(
mIdleCount
>
mIdleThreadLimit
|
|
(
mIdleThreadTimeout
!
=
UINT32_MAX
&
&
(
now
-
idleSince
)
>
=
timeout
)
)
{
exitThread
=
true
;
}
}
else
{
if
(
mIdleCount
=
=
mIdleThreadLimit
)
{
exitThread
=
true
;
}
else
{
+
+
mIdleCount
;
idleSince
=
now
;
wasIdle
=
true
;
}
}
}
if
(
exitThread
)
{
if
(
wasIdle
)
{
-
-
mIdleCount
;
}
shutdownThreadOnExit
=
mThreads
.
RemoveObject
(
current
)
;
mIsAPoolThreadFree
=
(
mThreads
.
Count
(
)
<
(
int32_t
)
mThreadLimit
)
;
}
else
{
current
-
>
SetRunningEventDelay
(
TimeDuration
(
)
TimeStamp
(
)
)
;
AUTO_PROFILER_LABEL
(
"
nsThreadPool
:
:
Run
:
:
Wait
"
IDLE
)
;
TimeDuration
delta
=
timeout
-
(
now
-
idleSince
)
;
LOG
(
(
"
THRD
-
P
(
%
p
)
%
s
waiting
[
%
f
]
\
n
"
this
mName
.
BeginReading
(
)
delta
.
ToMilliseconds
(
)
)
)
;
mEventsAvailable
.
Wait
(
delta
)
;
LOG
(
(
"
THRD
-
P
(
%
p
)
done
waiting
\
n
"
this
)
)
;
}
}
else
if
(
wasIdle
)
{
wasIdle
=
false
;
-
-
mIdleCount
;
}
}
if
(
event
)
{
if
(
MOZ_LOG_TEST
(
sThreadPoolLog
mozilla
:
:
LogLevel
:
:
Debug
)
)
{
MutexAutoLock
lock
(
mMutex
)
;
LOG
(
(
"
THRD
-
P
(
%
p
)
%
s
running
[
%
p
]
\
n
"
this
mName
.
BeginReading
(
)
event
.
get
(
)
)
)
;
}
DelayForChaosMode
(
ChaosFeature
:
:
TaskRunning
1000
)
;
current
-
>
SetRunningEventDelay
(
delay
TimeStamp
:
:
Now
(
)
)
;
LogRunnable
:
:
Run
log
(
event
)
;
AUTO_PROFILE_FOLLOWING_RUNNABLE
(
event
)
;
event
-
>
Run
(
)
;
event
=
nullptr
;
}
}
while
(
!
exitThread
)
;
if
(
listener
)
{
listener
-
>
OnThreadShuttingDown
(
)
;
}
MOZ_ASSERT
(
gCurrentThreadPool
.
get
(
)
=
=
this
)
;
gCurrentThreadPool
.
set
(
nullptr
)
;
if
(
shutdownThreadOnExit
)
{
ShutdownThread
(
current
)
;
}
LOG
(
(
"
THRD
-
P
(
%
p
)
leave
\
n
"
this
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
DispatchFromScript
(
nsIRunnable
*
aEvent
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
return
Dispatch
(
event
.
forget
(
)
aFlags
)
;
}
NS_IMETHODIMP
nsThreadPool
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
LOG
(
(
"
THRD
-
P
(
%
p
)
dispatch
[
%
p
%
x
]
\
n
"
this
nullptr
aFlags
)
)
;
if
(
NS_WARN_IF
(
mShutdown
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
aFlags
&
DISPATCH_SYNC
)
{
nsCOMPtr
<
nsIThread
>
thread
;
nsThreadManager
:
:
get
(
)
.
GetCurrentThread
(
getter_AddRefs
(
thread
)
)
;
if
(
NS_WARN_IF
(
!
thread
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
nsThreadSyncDispatch
>
wrapper
=
new
nsThreadSyncDispatch
(
thread
.
forget
(
)
std
:
:
move
(
aEvent
)
)
;
PutEvent
(
wrapper
)
;
SpinEventLoopUntil
(
"
nsThreadPool
:
:
Dispatch
"
_ns
[
&
wrapper
]
(
)
-
>
bool
{
return
!
wrapper
-
>
IsPending
(
)
;
}
)
;
}
else
{
NS_ASSERTION
(
aFlags
=
=
NS_DISPATCH_NORMAL
|
|
aFlags
=
=
NS_DISPATCH_AT_END
"
unexpected
dispatch
flags
"
)
;
PutEvent
(
std
:
:
move
(
aEvent
)
aFlags
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
uint32_t
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsThreadPool
:
:
RegisterShutdownTask
(
nsITargetShutdownTask
*
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsThreadPool
:
:
UnregisterShutdownTask
(
nsITargetShutdownTask
*
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP_
(
bool
)
nsThreadPool
:
:
IsOnCurrentThreadInfallible
(
)
{
return
gCurrentThreadPool
.
get
(
)
=
=
this
;
}
NS_IMETHODIMP
nsThreadPool
:
:
IsOnCurrentThread
(
bool
*
aResult
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
NS_WARN_IF
(
mShutdown
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aResult
=
IsOnCurrentThreadInfallible
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
Shutdown
(
)
{
return
ShutdownWithTimeout
(
-
1
)
;
}
NS_IMETHODIMP
nsThreadPool
:
:
ShutdownWithTimeout
(
int32_t
aTimeoutMs
)
{
nsCOMArray
<
nsIThread
>
threads
;
nsCOMPtr
<
nsIThreadPoolListener
>
listener
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mShutdown
)
{
return
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
}
mShutdown
=
true
;
mEventsAvailable
.
NotifyAll
(
)
;
threads
.
AppendObjects
(
mThreads
)
;
mThreads
.
Clear
(
)
;
mListener
.
swap
(
listener
)
;
}
nsTArray
<
nsCOMPtr
<
nsIThreadShutdown
>
>
contexts
;
for
(
int32_t
i
=
0
;
i
<
threads
.
Count
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsIThreadShutdown
>
context
;
if
(
NS_SUCCEEDED
(
threads
[
i
]
-
>
BeginShutdown
(
getter_AddRefs
(
context
)
)
)
)
{
contexts
.
AppendElement
(
std
:
:
move
(
context
)
)
;
}
}
nsCOMPtr
<
nsITimer
>
timer
;
if
(
aTimeoutMs
>
=
0
)
{
NS_NewTimerWithCallback
(
getter_AddRefs
(
timer
)
[
&
]
(
nsITimer
*
)
{
for
(
auto
&
context
:
contexts
)
{
context
-
>
StopWaitingAndLeakThread
(
)
;
}
}
aTimeoutMs
nsITimer
:
:
TYPE_ONE_SHOT
"
nsThreadPool
:
:
ShutdownWithTimeout
"
)
;
}
uint32_t
outstandingThreads
=
contexts
.
Length
(
)
;
RefPtr
onCompletion
=
NS_NewCancelableRunnableFunction
(
"
nsThreadPool
thread
completion
"
[
&
]
{
-
-
outstandingThreads
;
}
)
;
for
(
auto
&
context
:
contexts
)
{
context
-
>
OnCompletion
(
onCompletion
)
;
}
mozilla
:
:
SpinEventLoopUntil
(
"
nsThreadPool
:
:
ShutdownWithTimeout
"
_ns
[
&
]
{
return
outstandingThreads
=
=
0
;
}
)
;
if
(
timer
)
{
timer
-
>
Cancel
(
)
;
}
onCompletion
-
>
Cancel
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
GetThreadLimit
(
uint32_t
*
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
*
aValue
=
mThreadLimit
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetThreadLimit
(
uint32_t
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
LOG
(
(
"
THRD
-
P
(
%
p
)
thread
limit
[
%
u
]
\
n
"
this
aValue
)
)
;
mThreadLimit
=
aValue
;
if
(
mIdleThreadLimit
>
mThreadLimit
)
{
mIdleThreadLimit
=
mThreadLimit
;
}
if
(
static_cast
<
uint32_t
>
(
mThreads
.
Count
(
)
)
>
mThreadLimit
)
{
mEventsAvailable
.
NotifyAll
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
GetIdleThreadLimit
(
uint32_t
*
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
*
aValue
=
mIdleThreadLimit
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetIdleThreadLimit
(
uint32_t
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
LOG
(
(
"
THRD
-
P
(
%
p
)
idle
thread
limit
[
%
u
]
\
n
"
this
aValue
)
)
;
mIdleThreadLimit
=
aValue
;
if
(
mIdleThreadLimit
>
mThreadLimit
)
{
mIdleThreadLimit
=
mThreadLimit
;
}
if
(
mIdleCount
>
mIdleThreadLimit
)
{
mEventsAvailable
.
NotifyAll
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
GetIdleThreadTimeout
(
uint32_t
*
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
*
aValue
=
mIdleThreadTimeout
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetIdleThreadTimeout
(
uint32_t
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
uint32_t
oldTimeout
=
mIdleThreadTimeout
;
mIdleThreadTimeout
=
aValue
;
if
(
mIdleThreadTimeout
<
oldTimeout
&
&
mIdleCount
>
0
)
{
mEventsAvailable
.
NotifyAll
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
GetIdleThreadTimeoutRegressive
(
bool
*
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
*
aValue
=
mRegressiveMaxIdleTime
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetIdleThreadTimeoutRegressive
(
bool
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
bool
oldRegressive
=
mRegressiveMaxIdleTime
;
mRegressiveMaxIdleTime
=
aValue
;
if
(
mRegressiveMaxIdleTime
>
oldRegressive
&
&
mIdleCount
>
1
)
{
mEventsAvailable
.
NotifyAll
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
GetThreadStackSize
(
uint32_t
*
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
*
aValue
=
mStackSize
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetThreadStackSize
(
uint32_t
aValue
)
{
MutexAutoLock
lock
(
mMutex
)
;
mStackSize
=
aValue
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
GetListener
(
nsIThreadPoolListener
*
*
aListener
)
{
MutexAutoLock
lock
(
mMutex
)
;
NS_IF_ADDREF
(
*
aListener
=
mListener
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetListener
(
nsIThreadPoolListener
*
aListener
)
{
nsCOMPtr
<
nsIThreadPoolListener
>
swappedListener
(
aListener
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
mListener
.
swap
(
swappedListener
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsThreadPool
:
:
SetName
(
const
nsACString
&
aName
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mThreads
.
Count
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mName
=
aName
;
return
NS_OK
;
}
