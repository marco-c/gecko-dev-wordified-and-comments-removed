#
ifndef
mozilla_InputTaskManager_h
#
define
mozilla_InputTaskManager_h
#
include
"
nsXULAppAPI
.
h
"
#
include
"
TaskController
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
namespace
mozilla
{
class
InputTaskManager
:
public
TaskManager
{
public
:
int32_t
GetPriorityModifierForEventLoopTurn
(
const
MutexAutoLock
&
aProofOfLock
)
final
;
void
WillRunTask
(
)
final
;
void
DidRunTask
(
)
final
;
enum
InputEventQueueState
{
STATE_DISABLED
STATE_FLUSHING
STATE_SUSPEND
STATE_ENABLED
}
;
void
EnableInputEventPrioritization
(
)
;
void
FlushInputEventPrioritization
(
)
;
void
SuspendInputEventPrioritization
(
)
;
void
ResumeInputEventPrioritization
(
)
;
InputEventQueueState
State
(
)
{
return
mInputQueueState
;
}
void
SetState
(
InputEventQueueState
aState
)
{
mInputQueueState
=
aState
;
}
TimeStamp
InputHandlingStartTime
(
)
{
return
mInputHandlingStartTime
;
}
void
SetInputHandlingStartTime
(
TimeStamp
aStartTime
)
{
mInputHandlingStartTime
=
aStartTime
;
}
static
InputTaskManager
*
Get
(
)
{
return
gInputTaskManager
.
get
(
)
;
}
static
void
Cleanup
(
)
{
gInputTaskManager
=
nullptr
;
}
static
void
Init
(
)
;
bool
IsSuspended
(
const
MutexAutoLock
&
aProofOfLock
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mInputQueueState
=
=
STATE_DISABLED
|
|
mInputQueueState
=
=
STATE_SUSPEND
|
|
mSuspensionLevel
>
0
;
}
bool
IsSuspended
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mSuspensionLevel
>
0
;
}
void
IncSuspensionLevel
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
+
+
mSuspensionLevel
;
}
void
DecSuspensionLevel
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
-
-
mSuspensionLevel
;
}
static
bool
CanSuspendInputEvent
(
)
{
return
XRE_IsContentProcess
(
)
&
&
StaticPrefs
:
:
dom_input_events_canSuspendInBCG_enabled
(
)
&
&
InputTaskManager
:
:
Get
(
)
-
>
State
(
)
!
=
InputEventQueueState
:
:
STATE_DISABLED
;
}
void
NotifyVsync
(
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
dom_input_events_strict_input_vsync_alignment
(
)
)
;
mInputPriorityController
.
DidVsync
(
)
;
}
private
:
InputTaskManager
(
)
:
mInputQueueState
(
STATE_DISABLED
)
{
}
class
InputPriorityController
{
public
:
InputPriorityController
(
)
;
bool
ShouldUseHighestPriority
(
InputTaskManager
*
)
;
void
DidVsync
(
)
;
void
DidRunTask
(
)
;
private
:
enum
class
InputVsyncState
{
HasPendingVsync
NoPendingVsync
RunVsync
}
;
void
EnterPendingVsyncState
(
uint32_t
aNumPendingTasks
)
;
void
LeavePendingVsyncState
(
bool
aRunVsync
)
;
uint32_t
mMaxInputTasksToRun
=
0
;
bool
mIsInitialized
;
InputVsyncState
mInputVsyncState
;
TimeStamp
mRunInputStartTime
;
TimeDuration
mMaxInputHandlingDuration
;
}
;
int32_t
GetPriorityModifierForEventLoopTurnForStrictVsyncAlignment
(
)
;
TimeStamp
mInputHandlingStartTime
;
Atomic
<
InputEventQueueState
>
mInputQueueState
;
AutoTArray
<
TimeStamp
4
>
mStartTimes
;
static
StaticRefPtr
<
InputTaskManager
>
gInputTaskManager
;
uint32_t
mSuspensionLevel
=
0
;
InputPriorityController
mInputPriorityController
;
}
;
}
#
endif
