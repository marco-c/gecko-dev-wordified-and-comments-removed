#
ifndef
TimerThread_h___
#
define
TimerThread_h___
#
include
"
nsIObserver
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsTimerImpl
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
class
TimeStamp
;
}
class
TimerThread
final
:
public
nsIRunnable
public
nsIObserver
{
public
:
typedef
mozilla
:
:
Monitor
Monitor
;
typedef
mozilla
:
:
TimeStamp
TimeStamp
;
typedef
mozilla
:
:
TimeDuration
TimeDuration
;
TimerThread
(
)
;
nsresult
InitLocks
(
)
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIRUNNABLE
NS_DECL_NSIOBSERVER
nsresult
Shutdown
(
)
;
nsresult
AddTimer
(
nsTimerImpl
*
aTimer
)
;
nsresult
RemoveTimer
(
nsTimerImpl
*
aTimer
)
;
TimeStamp
FindNextFireTimeForCurrentThread
(
TimeStamp
aDefault
uint32_t
aSearchBound
)
;
void
DoBeforeSleep
(
)
;
void
DoAfterSleep
(
)
;
bool
IsOnTimerThread
(
)
const
{
return
mThread
-
>
SerialEventTarget
(
)
-
>
IsOnCurrentThread
(
)
;
}
uint32_t
AllowedEarlyFiringMicroseconds
(
)
const
;
private
:
~
TimerThread
(
)
;
bool
mInitialized
;
bool
AddTimerInternal
(
nsTimerImpl
*
aTimer
)
;
bool
RemoveTimerInternal
(
nsTimerImpl
*
aTimer
)
;
void
RemoveLeadingCanceledTimersInternal
(
)
;
void
RemoveFirstTimerInternal
(
)
;
nsresult
Init
(
)
;
already_AddRefed
<
nsTimerImpl
>
PostTimerEvent
(
already_AddRefed
<
nsTimerImpl
>
aTimerRef
)
;
nsCOMPtr
<
nsIThread
>
mThread
;
Monitor
mMonitor
;
bool
mShutdown
;
bool
mWaiting
;
bool
mNotified
;
bool
mSleeping
;
class
Entry
final
:
public
nsTimerImplHolder
{
const
TimeStamp
mTimeout
;
public
:
Entry
(
const
TimeStamp
&
aMinTimeout
const
TimeStamp
&
aTimeout
nsTimerImpl
*
aTimerImpl
)
:
nsTimerImplHolder
(
aTimerImpl
)
mTimeout
(
std
:
:
max
(
aMinTimeout
aTimeout
)
)
{
}
nsTimerImpl
*
Value
(
)
const
{
return
mTimerImpl
;
}
already_AddRefed
<
nsTimerImpl
>
Take
(
)
{
if
(
mTimerImpl
)
{
mTimerImpl
-
>
SetHolder
(
nullptr
)
;
}
return
mTimerImpl
.
forget
(
)
;
}
static
bool
UniquePtrLessThan
(
UniquePtr
<
Entry
>
&
aLeft
UniquePtr
<
Entry
>
&
aRight
)
{
return
aRight
-
>
mTimeout
<
aLeft
-
>
mTimeout
;
}
TimeStamp
Timeout
(
)
const
{
return
mTimeout
;
}
}
;
nsTArray
<
UniquePtr
<
Entry
>
>
mTimers
;
uint32_t
mAllowedEarlyFiringMicroseconds
;
}
;
struct
TimerAdditionComparator
{
TimerAdditionComparator
(
const
mozilla
:
:
TimeStamp
&
aNow
nsTimerImpl
*
aTimerToInsert
)
:
now
(
aNow
)
#
ifdef
DEBUG
timerToInsert
(
aTimerToInsert
)
#
endif
{
}
bool
LessThan
(
nsTimerImpl
*
aFromArray
nsTimerImpl
*
aNewTimer
)
const
{
MOZ_ASSERT
(
aNewTimer
=
=
timerToInsert
"
Unexpected
timer
ordering
"
)
;
return
aFromArray
-
>
mTimeout
<
=
now
|
|
aFromArray
-
>
mTimeout
<
=
aNewTimer
-
>
mTimeout
;
}
bool
Equals
(
nsTimerImpl
*
aFromArray
nsTimerImpl
*
aNewTimer
)
const
{
return
false
;
}
private
:
const
mozilla
:
:
TimeStamp
&
now
;
#
ifdef
DEBUG
const
nsTimerImpl
*
const
timerToInsert
;
#
endif
}
;
#
endif
