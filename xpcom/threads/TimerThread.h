#
ifndef
TimerThread_h___
#
define
TimerThread_h___
#
include
"
nsIObserver
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsTimerImpl
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
ProfilerUtils
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
class
TimeStamp
;
}
#
define
TIMER_THREAD_STATISTICS
0
class
TimerThread
final
:
public
mozilla
:
:
Runnable
public
nsIObserver
{
public
:
typedef
mozilla
:
:
Monitor
Monitor
;
typedef
mozilla
:
:
MutexAutoLock
MutexAutoLock
;
typedef
mozilla
:
:
TimeStamp
TimeStamp
;
typedef
mozilla
:
:
TimeDuration
TimeDuration
;
TimerThread
(
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIRUNNABLE
NS_DECL_NSIOBSERVER
nsresult
Shutdown
(
)
;
nsresult
AddTimer
(
nsTimerImpl
*
aTimer
const
MutexAutoLock
&
aProofOfLock
)
MOZ_REQUIRES
(
aTimer
-
>
mMutex
)
;
nsresult
RemoveTimer
(
nsTimerImpl
*
aTimer
const
MutexAutoLock
&
aProofOfLock
)
MOZ_REQUIRES
(
aTimer
-
>
mMutex
)
;
TimeStamp
FindNextFireTimeForCurrentThread
(
TimeStamp
aDefault
uint32_t
aSearchBound
)
;
void
DoBeforeSleep
(
)
;
void
DoAfterSleep
(
)
;
bool
IsOnTimerThread
(
)
const
{
return
mThread
-
>
IsOnCurrentThread
(
)
;
}
uint32_t
AllowedEarlyFiringMicroseconds
(
)
;
nsresult
GetTimers
(
nsTArray
<
RefPtr
<
nsITimer
>
>
&
aRetVal
)
;
private
:
~
TimerThread
(
)
;
bool
mInitialized
;
bool
AddTimerInternal
(
nsTimerImpl
&
aTimer
)
MOZ_REQUIRES
(
mMonitor
)
;
bool
RemoveTimerInternal
(
nsTimerImpl
&
aTimer
)
MOZ_REQUIRES
(
mMonitor
aTimer
.
mMutex
)
;
void
RemoveLeadingCanceledTimersInternal
(
)
MOZ_REQUIRES
(
mMonitor
)
;
void
RemoveFirstTimerInternal
(
)
MOZ_REQUIRES
(
mMonitor
)
;
nsresult
Init
(
)
MOZ_REQUIRES
(
mMonitor
)
;
void
PostTimerEvent
(
already_AddRefed
<
nsTimerImpl
>
aTimerRef
)
MOZ_REQUIRES
(
mMonitor
)
;
nsCOMPtr
<
nsIThread
>
mThread
;
Monitor
mMonitor
;
bool
mShutdown
MOZ_GUARDED_BY
(
mMonitor
)
;
bool
mWaiting
MOZ_GUARDED_BY
(
mMonitor
)
;
bool
mNotified
MOZ_GUARDED_BY
(
mMonitor
)
;
bool
mSleeping
MOZ_GUARDED_BY
(
mMonitor
)
;
class
Entry
final
{
public
:
explicit
Entry
(
nsTimerImpl
&
aTimerImpl
)
:
mTimeout
(
aTimerImpl
.
mTimeout
)
mDelay
(
aTimerImpl
.
mDelay
)
mTimerImpl
(
&
aTimerImpl
)
{
aTimerImpl
.
SetIsInTimerThread
(
true
)
;
}
explicit
Entry
(
TimeStamp
aTimeout
)
:
mTimeout
(
std
:
:
move
(
aTimeout
)
)
mTimerImpl
(
nullptr
)
{
}
Entry
(
const
Entry
&
)
=
delete
;
Entry
&
operator
=
(
const
Entry
&
)
=
delete
;
Entry
(
Entry
&
&
)
=
default
;
Entry
&
operator
=
(
Entry
&
&
)
=
default
;
~
Entry
(
)
{
if
(
mTimerImpl
)
{
mTimerImpl
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
mTimerImpl
-
>
SetIsInTimerThread
(
false
)
;
}
}
nsTimerImpl
*
Value
(
)
const
{
return
mTimerImpl
;
}
void
Forget
(
)
{
if
(
MOZ_UNLIKELY
(
!
mTimerImpl
)
)
{
return
;
}
mTimerImpl
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
mTimerImpl
-
>
SetIsInTimerThread
(
false
)
;
mTimerImpl
=
nullptr
;
}
already_AddRefed
<
nsTimerImpl
>
Take
(
)
{
if
(
MOZ_LIKELY
(
mTimerImpl
)
)
{
MOZ_ASSERT
(
mTimerImpl
-
>
IsInTimerThread
(
)
)
;
mTimerImpl
-
>
SetIsInTimerThread
(
false
)
;
}
return
mTimerImpl
.
forget
(
)
;
}
const
TimeStamp
&
Timeout
(
)
const
{
return
mTimeout
;
}
const
TimeDuration
&
Delay
(
)
const
{
return
mDelay
;
}
private
:
TimeStamp
mTimeout
;
TimeDuration
mDelay
;
RefPtr
<
nsTimerImpl
>
mTimerImpl
;
}
;
size_t
ComputeTimerInsertionIndex
(
const
TimeStamp
&
timeout
)
const
MOZ_REQUIRES
(
mMonitor
)
;
TimeStamp
ComputeWakeupTimeFromTimers
(
)
const
MOZ_REQUIRES
(
mMonitor
)
;
TimeDuration
ComputeAcceptableFiringDelay
(
TimeDuration
timerDuration
TimeDuration
minDelay
TimeDuration
maxDelay
)
const
;
#
ifdef
DEBUG
void
VerifyTimerListConsistency
(
)
const
MOZ_REQUIRES
(
mMonitor
)
;
#
endif
nsTArray
<
Entry
>
mTimers
MOZ_GUARDED_BY
(
mMonitor
)
;
uint32_t
mAllowedEarlyFiringMicroseconds
MOZ_GUARDED_BY
(
mMonitor
)
;
ProfilerThreadId
mProfilerThreadId
MOZ_GUARDED_BY
(
mMonitor
)
;
TimeStamp
mIntendedWakeupTime
;
#
if
TIMER_THREAD_STATISTICS
static
constexpr
size_t
sTimersFiredPerWakeupBucketCount
=
16
;
static
inline
constexpr
std
:
:
array
<
size_t
sTimersFiredPerWakeupBucketCount
>
sTimersFiredPerWakeupThresholds
=
{
0
1
2
3
4
5
6
7
8
12
20
30
40
50
70
(
size_t
)
(
-
1
)
}
;
mutable
AutoTArray
<
size_t
sTimersFiredPerWakeupBucketCount
>
mTimersFiredPerWakeup
MOZ_GUARDED_BY
(
mMonitor
)
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
}
;
mutable
AutoTArray
<
size_t
sTimersFiredPerWakeupBucketCount
>
mTimersFiredPerUnnotifiedWakeup
MOZ_GUARDED_BY
(
mMonitor
)
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
}
;
mutable
AutoTArray
<
size_t
sTimersFiredPerWakeupBucketCount
>
mTimersFiredPerNotifiedWakeup
MOZ_GUARDED_BY
(
mMonitor
)
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
}
;
mutable
size_t
mTotalTimersAdded
MOZ_GUARDED_BY
(
mMonitor
)
=
0
;
mutable
size_t
mTotalTimersRemoved
MOZ_GUARDED_BY
(
mMonitor
)
=
0
;
mutable
size_t
mTotalTimersFiredNotified
MOZ_GUARDED_BY
(
mMonitor
)
=
0
;
mutable
size_t
mTotalTimersFiredUnnotified
MOZ_GUARDED_BY
(
mMonitor
)
=
0
;
mutable
size_t
mTotalWakeupCount
MOZ_GUARDED_BY
(
mMonitor
)
=
0
;
mutable
size_t
mTotalUnnotifiedWakeupCount
MOZ_GUARDED_BY
(
mMonitor
)
=
0
;
mutable
size_t
mTotalNotifiedWakeupCount
MOZ_GUARDED_BY
(
mMonitor
)
=
0
;
mutable
double
mTotalActualTimerFiringDelayNotified
MOZ_GUARDED_BY
(
mMonitor
)
=
0
.
0
;
mutable
double
mTotalActualTimerFiringDelayUnnotified
MOZ_GUARDED_BY
(
mMonitor
)
=
0
.
0
;
mutable
TimeStamp
mFirstTimerAdded
MOZ_GUARDED_BY
(
mMonitor
)
;
mutable
size_t
mEarlyWakeups
MOZ_GUARDED_BY
(
mMonitor
)
=
0
;
mutable
double
mTotalEarlyWakeupTime
MOZ_GUARDED_BY
(
mMonitor
)
=
0
.
0
;
void
PrintStatistics
(
)
const
;
#
endif
}
;
#
endif
