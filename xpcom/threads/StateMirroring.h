#
if
!
defined
(
StateMirroring_h_
)
#
define
StateMirroring_h_
#
include
<
cstddef
>
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StateWatching
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
#
define
MIRROR_LOG
(
x
.
.
.
)
\
MOZ_ASSERT
(
gStateWatchingLog
)
;
\
MOZ_LOG
(
gStateWatchingLog
LogLevel
:
:
Debug
(
x
#
#
__VA_ARGS__
)
)
template
<
typename
T
>
class
AbstractMirror
;
template
<
typename
T
>
class
AbstractCanonical
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AbstractCanonical
)
AbstractCanonical
(
AbstractThread
*
aThread
)
:
mOwnerThread
(
aThread
)
{
}
virtual
void
AddMirror
(
AbstractMirror
<
T
>
*
aMirror
)
=
0
;
virtual
void
RemoveMirror
(
AbstractMirror
<
T
>
*
aMirror
)
=
0
;
AbstractThread
*
OwnerThread
(
)
const
{
return
mOwnerThread
;
}
protected
:
virtual
~
AbstractCanonical
(
)
{
}
RefPtr
<
AbstractThread
>
mOwnerThread
;
}
;
template
<
typename
T
>
class
AbstractMirror
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AbstractMirror
)
AbstractMirror
(
AbstractThread
*
aThread
)
:
mOwnerThread
(
aThread
)
{
}
virtual
void
UpdateValue
(
const
T
&
aNewValue
)
=
0
;
virtual
void
NotifyDisconnected
(
)
=
0
;
AbstractThread
*
OwnerThread
(
)
const
{
return
mOwnerThread
;
}
protected
:
virtual
~
AbstractMirror
(
)
{
}
RefPtr
<
AbstractThread
>
mOwnerThread
;
}
;
template
<
typename
T
>
class
Canonical
{
public
:
Canonical
(
AbstractThread
*
aThread
const
T
&
aInitialValue
const
char
*
aName
)
{
mImpl
=
new
Impl
(
aThread
aInitialValue
aName
)
;
}
~
Canonical
(
)
{
}
private
:
class
Impl
:
public
AbstractCanonical
<
T
>
public
WatchTarget
{
public
:
using
AbstractCanonical
<
T
>
:
:
OwnerThread
;
Impl
(
AbstractThread
*
aThread
const
T
&
aInitialValue
const
char
*
aName
)
:
AbstractCanonical
<
T
>
(
aThread
)
WatchTarget
(
aName
)
mValue
(
aInitialValue
)
{
MIRROR_LOG
(
"
%
s
[
%
p
]
initialized
"
mName
this
)
;
MOZ_ASSERT
(
aThread
-
>
SupportsTailDispatch
(
)
"
Can
'
t
get
coherency
without
tail
dispatch
"
)
;
}
void
AddMirror
(
AbstractMirror
<
T
>
*
aMirror
)
override
{
MIRROR_LOG
(
"
%
s
[
%
p
]
adding
mirror
%
p
"
mName
this
aMirror
)
;
MOZ_ASSERT
(
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
)
;
MOZ_ASSERT
(
!
mMirrors
.
Contains
(
aMirror
)
)
;
mMirrors
.
AppendElement
(
aMirror
)
;
aMirror
-
>
OwnerThread
(
)
-
>
DispatchStateChange
(
MakeNotifier
(
aMirror
)
)
;
}
void
RemoveMirror
(
AbstractMirror
<
T
>
*
aMirror
)
override
{
MIRROR_LOG
(
"
%
s
[
%
p
]
removing
mirror
%
p
"
mName
this
aMirror
)
;
MOZ_ASSERT
(
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
)
;
MOZ_ASSERT
(
mMirrors
.
Contains
(
aMirror
)
)
;
mMirrors
.
RemoveElement
(
aMirror
)
;
}
void
DisconnectAll
(
)
{
MIRROR_LOG
(
"
%
s
[
%
p
]
Disconnecting
all
mirrors
"
mName
this
)
;
for
(
size_t
i
=
0
;
i
<
mMirrors
.
Length
(
)
;
+
+
i
)
{
mMirrors
[
i
]
-
>
OwnerThread
(
)
-
>
Dispatch
(
NewRunnableMethod
(
"
AbstractMirror
:
:
NotifyDisconnected
"
mMirrors
[
i
]
&
AbstractMirror
<
T
>
:
:
NotifyDisconnected
)
)
;
}
mMirrors
.
Clear
(
)
;
}
operator
const
T
&
(
)
{
MOZ_ASSERT
(
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
)
;
return
mValue
;
}
void
Set
(
const
T
&
aNewValue
)
{
MOZ_ASSERT
(
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
)
;
if
(
aNewValue
=
=
mValue
)
{
return
;
}
NotifyWatchers
(
)
;
bool
alreadyNotifying
=
mInitialValue
.
isSome
(
)
;
if
(
mInitialValue
.
isNothing
(
)
)
{
mInitialValue
.
emplace
(
mValue
)
;
}
mValue
=
aNewValue
;
if
(
!
alreadyNotifying
)
{
AbstractThread
:
:
DispatchDirectTask
(
NewRunnableMethod
(
"
Canonical
:
:
Impl
:
:
DoNotify
"
this
&
Impl
:
:
DoNotify
)
)
;
}
}
Impl
&
operator
=
(
const
T
&
aNewValue
)
{
Set
(
aNewValue
)
;
return
*
this
;
}
Impl
&
operator
=
(
const
Impl
&
aOther
)
{
Set
(
aOther
)
;
return
*
this
;
}
Impl
(
const
Impl
&
aOther
)
=
delete
;
protected
:
~
Impl
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mMirrors
.
IsEmpty
(
)
)
;
}
private
:
void
DoNotify
(
)
{
MOZ_ASSERT
(
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
)
;
MOZ_ASSERT
(
mInitialValue
.
isSome
(
)
)
;
bool
same
=
mInitialValue
.
ref
(
)
=
=
mValue
;
mInitialValue
.
reset
(
)
;
if
(
same
)
{
MIRROR_LOG
(
"
%
s
[
%
p
]
unchanged
-
not
sending
update
"
mName
this
)
;
return
;
}
for
(
size_t
i
=
0
;
i
<
mMirrors
.
Length
(
)
;
+
+
i
)
{
mMirrors
[
i
]
-
>
OwnerThread
(
)
-
>
DispatchStateChange
(
MakeNotifier
(
mMirrors
[
i
]
)
)
;
}
}
already_AddRefed
<
nsIRunnable
>
MakeNotifier
(
AbstractMirror
<
T
>
*
aMirror
)
{
return
NewRunnableMethod
<
T
>
(
"
AbstractMirror
:
:
UpdateValue
"
aMirror
&
AbstractMirror
<
T
>
:
:
UpdateValue
mValue
)
;
}
T
mValue
;
Maybe
<
T
>
mInitialValue
;
nsTArray
<
RefPtr
<
AbstractMirror
<
T
>
>
>
mMirrors
;
}
;
public
:
void
DisconnectAll
(
)
{
return
mImpl
-
>
DisconnectAll
(
)
;
}
operator
Impl
&
(
)
{
return
*
mImpl
;
}
Impl
*
operator
&
(
)
{
return
mImpl
;
}
const
T
&
Ref
(
)
const
{
return
*
mImpl
;
}
operator
const
T
&
(
)
const
{
return
Ref
(
)
;
}
void
Set
(
const
T
&
aNewValue
)
{
mImpl
-
>
Set
(
aNewValue
)
;
}
Canonical
&
operator
=
(
const
T
&
aNewValue
)
{
Set
(
aNewValue
)
;
return
*
this
;
}
Canonical
&
operator
=
(
const
Canonical
&
aOther
)
{
Set
(
aOther
)
;
return
*
this
;
}
Canonical
(
const
Canonical
&
aOther
)
=
delete
;
private
:
RefPtr
<
Impl
>
mImpl
;
}
;
template
<
typename
T
>
class
Mirror
{
public
:
Mirror
(
AbstractThread
*
aThread
const
T
&
aInitialValue
const
char
*
aName
)
{
mImpl
=
new
Impl
(
aThread
aInitialValue
aName
)
;
}
~
Mirror
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mImpl
-
>
IsConnected
(
)
)
;
}
private
:
class
Impl
:
public
AbstractMirror
<
T
>
public
WatchTarget
{
public
:
using
AbstractMirror
<
T
>
:
:
OwnerThread
;
Impl
(
AbstractThread
*
aThread
const
T
&
aInitialValue
const
char
*
aName
)
:
AbstractMirror
<
T
>
(
aThread
)
WatchTarget
(
aName
)
mValue
(
aInitialValue
)
{
MIRROR_LOG
(
"
%
s
[
%
p
]
initialized
"
mName
this
)
;
MOZ_ASSERT
(
aThread
-
>
SupportsTailDispatch
(
)
"
Can
'
t
get
coherency
without
tail
dispatch
"
)
;
}
operator
const
T
&
(
)
{
MOZ_ASSERT
(
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
)
;
return
mValue
;
}
void
UpdateValue
(
const
T
&
aNewValue
)
override
{
MOZ_ASSERT
(
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
)
;
if
(
mValue
!
=
aNewValue
)
{
mValue
=
aNewValue
;
WatchTarget
:
:
NotifyWatchers
(
)
;
}
}
void
NotifyDisconnected
(
)
override
{
MIRROR_LOG
(
"
%
s
[
%
p
]
Notifed
of
disconnection
from
%
p
"
mName
this
mCanonical
.
get
(
)
)
;
MOZ_ASSERT
(
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
)
;
mCanonical
=
nullptr
;
}
bool
IsConnected
(
)
const
{
return
!
!
mCanonical
;
}
void
Connect
(
AbstractCanonical
<
T
>
*
aCanonical
)
{
MIRROR_LOG
(
"
%
s
[
%
p
]
Connecting
to
%
p
"
mName
this
aCanonical
)
;
MOZ_ASSERT
(
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
)
;
MOZ_ASSERT
(
!
IsConnected
(
)
)
;
MOZ_ASSERT
(
OwnerThread
(
)
-
>
RequiresTailDispatch
(
aCanonical
-
>
OwnerThread
(
)
)
"
Can
'
t
get
coherency
without
tail
dispatch
"
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NewRunnableMethod
<
StoreRefPtrPassByPtr
<
AbstractMirror
<
T
>
>
>
(
"
AbstractCanonical
:
:
AddMirror
"
aCanonical
&
AbstractCanonical
<
T
>
:
:
AddMirror
this
)
;
aCanonical
-
>
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
mCanonical
=
aCanonical
;
}
void
DisconnectIfConnected
(
)
{
MOZ_ASSERT
(
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
)
;
if
(
!
IsConnected
(
)
)
{
return
;
}
MIRROR_LOG
(
"
%
s
[
%
p
]
Disconnecting
from
%
p
"
mName
this
mCanonical
.
get
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NewRunnableMethod
<
StoreRefPtrPassByPtr
<
AbstractMirror
<
T
>
>
>
(
"
AbstractCanonical
:
:
RemoveMirror
"
mCanonical
&
AbstractCanonical
<
T
>
:
:
RemoveMirror
this
)
;
mCanonical
-
>
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
mCanonical
=
nullptr
;
}
protected
:
~
Impl
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsConnected
(
)
)
;
}
private
:
T
mValue
;
RefPtr
<
AbstractCanonical
<
T
>
>
mCanonical
;
}
;
public
:
void
Connect
(
AbstractCanonical
<
T
>
*
aCanonical
)
{
mImpl
-
>
Connect
(
aCanonical
)
;
}
void
DisconnectIfConnected
(
)
{
mImpl
-
>
DisconnectIfConnected
(
)
;
}
operator
Impl
&
(
)
{
return
*
mImpl
;
}
Impl
*
operator
&
(
)
{
return
mImpl
;
}
const
T
&
Ref
(
)
const
{
return
*
mImpl
;
}
operator
const
T
&
(
)
const
{
return
Ref
(
)
;
}
private
:
RefPtr
<
Impl
>
mImpl
;
}
;
#
undef
MIRROR_LOG
}
#
endif
