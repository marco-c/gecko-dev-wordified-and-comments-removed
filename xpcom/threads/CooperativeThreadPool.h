#
ifndef
mozilla_CooperativeThreadPool_h
#
define
mozilla_CooperativeThreadPool_h
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
CondVar
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
prthread
.
h
"
#
undef
Yield
class
nsIEventTarget
;
namespace
mozilla
{
class
CooperativeThreadPool
{
public
:
class
Controller
{
public
:
virtual
void
OnStartThread
(
size_t
aIndex
const
nsACString
&
aName
void
*
aStackTop
)
=
0
;
virtual
void
OnStopThread
(
size_t
aIndex
)
=
0
;
virtual
void
OnResumeThread
(
size_t
aIndex
)
=
0
;
virtual
void
OnSuspendThread
(
size_t
aIndex
)
=
0
;
}
;
CooperativeThreadPool
(
size_t
aNumThreads
Mutex
&
aMutex
Controller
&
aController
)
;
~
CooperativeThreadPool
(
)
;
void
Shutdown
(
)
;
class
Resource
{
public
:
virtual
bool
IsAvailable
(
const
MutexAutoLock
&
aProofOfLock
)
=
0
;
}
;
void
RecheckBlockers
(
const
MutexAutoLock
&
aProofOfLock
)
;
static
void
Yield
(
Resource
*
aBlocker
const
MutexAutoLock
&
aProofOfLock
)
;
static
bool
IsCooperativeThread
(
)
;
enum
class
AllThreadsBlocked
{
Blocked
}
;
using
SelectedThread
=
Variant
<
size_t
AllThreadsBlocked
>
;
SelectedThread
CurrentThreadIndex
(
const
MutexAutoLock
&
aProofOfLock
)
const
;
static
const
size_t
kMaxThreads
=
16
;
private
:
class
CooperativeThread
{
friend
class
CooperativeThreadPool
;
public
:
CooperativeThread
(
CooperativeThreadPool
*
aPool
size_t
aIndex
)
;
void
BeginShutdown
(
)
;
void
EndShutdown
(
)
;
void
Started
(
)
;
bool
IsBlocked
(
const
MutexAutoLock
&
aProofOfLock
)
;
void
SetBlocker
(
Resource
*
aResource
)
{
mBlocker
=
aResource
;
}
void
Yield
(
const
MutexAutoLock
&
aProofOfLock
)
;
private
:
static
void
ThreadFunc
(
void
*
aArg
)
;
void
ThreadMethod
(
)
;
CooperativeThreadPool
*
mPool
;
CondVar
mCondVar
;
Resource
*
mBlocker
;
PRThread
*
mThread
;
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
const
size_t
mIndex
;
bool
mRunning
;
}
;
class
StartRunnable
;
Mutex
&
mMutex
;
CondVar
mShutdownCondition
;
nsThreadPoolNaming
mThreadNaming
;
bool
mRunning
;
const
size_t
mNumThreads
;
size_t
mRunningThreads
;
Controller
&
mController
;
Array
<
UniquePtr
<
CooperativeThread
>
kMaxThreads
>
mThreads
;
SelectedThread
mSelectedThread
;
static
MOZ_THREAD_LOCAL
(
CooperativeThread
*
)
sTlsCurrentThread
;
}
;
}
#
endif
