#
include
"
nsTimerImpl
.
h
"
#
include
"
TimerThread
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
pratom
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
ChaosMode
.
h
"
#
include
"
mozilla
/
ArenaAllocator
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
"
mozilla
/
StaticPrefs_timer
.
h
"
#
include
"
mozilla
/
glean
/
GleanMetrics
.
h
"
#
include
<
math
.
h
>
using
namespace
mozilla
;
#
ifdef
TIMERS_RUNTIME_STATS
class
StaticTimersStats
{
public
:
explicit
StaticTimersStats
(
const
char
*
aName
)
:
mName
(
aName
)
{
}
~
StaticTimersStats
(
)
{
using
ULL
=
unsigned
long
long
;
ULL
n
=
static_cast
<
ULL
>
(
mCount
)
;
if
(
n
=
=
0
)
{
printf
(
"
[
%
d
]
Timers
stats
%
s
:
(
nothing
)
\
n
"
int
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
mName
)
;
}
else
if
(
ULL
sumNs
=
static_cast
<
ULL
>
(
mSumDurationsNs
)
;
sumNs
=
=
0
)
{
printf
(
"
[
%
d
]
Timers
stats
%
s
:
%
llu
\
n
"
int
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
mName
n
)
;
}
else
{
printf
(
"
[
%
d
]
Timers
stats
%
s
:
%
llu
ns
/
%
llu
=
%
llu
ns
max
%
llu
ns
\
n
"
int
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
mName
sumNs
n
sumNs
/
n
static_cast
<
ULL
>
(
mLongestDurationNs
)
)
;
}
}
void
AddDurationFrom
(
TimeStamp
aStart
)
{
DurationNs
duration
=
static_cast
<
DurationNs
>
(
(
TimeStamp
:
:
Now
(
)
-
aStart
)
.
ToMicroseconds
(
)
*
1000
+
0
.
5
)
;
mSumDurationsNs
+
=
duration
;
+
+
mCount
;
for
(
;
;
)
{
DurationNs
longest
=
mLongestDurationNs
;
if
(
MOZ_LIKELY
(
longest
>
=
duration
)
)
{
break
;
}
if
(
MOZ_LIKELY
(
mLongestDurationNs
.
compareExchange
(
longest
duration
)
)
)
{
break
;
}
}
}
void
AddCount
(
)
{
MOZ_ASSERT
(
mSumDurationsNs
=
=
0
"
Don
'
t
mix
counts
and
durations
"
)
;
+
+
mCount
;
}
private
:
using
DurationNs
=
uint64_t
;
using
Count
=
uint32_t
;
Atomic
<
DurationNs
>
mSumDurationsNs
{
0
}
;
Atomic
<
DurationNs
>
mLongestDurationNs
{
0
}
;
Atomic
<
Count
>
mCount
{
0
}
;
const
char
*
mName
;
}
;
class
MOZ_RAII
AutoTimersStats
{
public
:
explicit
AutoTimersStats
(
StaticTimersStats
&
aStats
)
:
mStats
(
aStats
)
mStart
(
TimeStamp
:
:
Now
(
)
)
{
}
~
AutoTimersStats
(
)
{
mStats
.
AddDurationFrom
(
mStart
)
;
}
private
:
StaticTimersStats
&
mStats
;
TimeStamp
mStart
;
}
;
#
define
AUTO_TIMERS_STATS
(
name
)
\
static
:
:
StaticTimersStats
sStat
#
#
name
(
#
name
)
;
\
:
:
AutoTimersStats
autoStat
#
#
name
(
sStat
#
#
name
)
;
#
define
COUNT_TIMERS_STATS
(
name
)
\
static
:
:
StaticTimersStats
sStat
#
#
name
(
#
name
)
;
\
sStat
#
#
name
.
AddCount
(
)
;
#
else
#
define
AUTO_TIMERS_STATS
(
name
)
#
define
COUNT_TIMERS_STATS
(
name
)
#
endif
NS_IMPL_ISUPPORTS_INHERITED
(
TimerThread
Runnable
nsIObserver
)
TimerThread
:
:
TimerThread
(
)
:
Runnable
(
"
TimerThread
"
)
mInitialized
(
false
)
mMonitor
(
"
TimerThread
.
mMonitor
"
)
mShutdown
(
false
)
mWaiting
(
false
)
mNotified
(
false
)
mSleeping
(
false
)
mAllowedEarlyFiringMicroseconds
(
0
)
{
}
TimerThread
:
:
~
TimerThread
(
)
{
mThread
=
nullptr
;
NS_ASSERTION
(
mTimers
.
IsEmpty
(
)
"
Timers
remain
in
TimerThread
:
:
~
TimerThread
"
)
;
#
if
TIMER_THREAD_STATISTICS
{
MonitorAutoLock
lock
(
mMonitor
)
;
PrintStatistics
(
)
;
}
#
endif
}
namespace
{
class
TimerObserverRunnable
:
public
Runnable
{
public
:
explicit
TimerObserverRunnable
(
nsIObserver
*
aObserver
)
:
mozilla
:
:
Runnable
(
"
TimerObserverRunnable
"
)
mObserver
(
aObserver
)
{
}
NS_DECL_NSIRUNNABLE
private
:
nsCOMPtr
<
nsIObserver
>
mObserver
;
}
;
NS_IMETHODIMP
TimerObserverRunnable
:
:
Run
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
mObserver
"
sleep_notification
"
false
)
;
observerService
-
>
AddObserver
(
mObserver
"
wake_notification
"
false
)
;
observerService
-
>
AddObserver
(
mObserver
"
suspend_process_notification
"
false
)
;
observerService
-
>
AddObserver
(
mObserver
"
resume_process_notification
"
false
)
;
}
return
NS_OK
;
}
}
namespace
{
class
TimerEventAllocator
{
private
:
struct
FreeEntry
{
FreeEntry
*
mNext
;
}
;
ArenaAllocator
<
4096
>
mPool
MOZ_GUARDED_BY
(
mMonitor
)
;
FreeEntry
*
mFirstFree
MOZ_GUARDED_BY
(
mMonitor
)
;
mozilla
:
:
Monitor
mMonitor
;
public
:
TimerEventAllocator
(
)
:
mPool
(
)
mFirstFree
(
nullptr
)
mMonitor
(
"
TimerEventAllocator
"
)
{
}
~
TimerEventAllocator
(
)
=
default
;
void
*
Alloc
(
size_t
aSize
)
;
void
Free
(
void
*
aPtr
)
;
}
;
}
class
nsTimerEvent
final
:
public
CancelableRunnable
{
public
:
NS_IMETHOD
Run
(
)
override
;
nsresult
Cancel
(
)
override
{
mTimer
-
>
Cancel
(
)
;
return
NS_OK
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
;
#
endif
explicit
nsTimerEvent
(
already_AddRefed
<
nsTimerImpl
>
aTimer
ProfilerThreadId
aTimerThreadId
)
:
mozilla
:
:
CancelableRunnable
(
"
nsTimerEvent
"
)
mTimer
(
aTimer
)
mGeneration
(
mTimer
-
>
GetGeneration
(
)
)
mTimerThreadId
(
aTimerThreadId
)
{
sAllocatorUsers
+
+
;
if
(
MOZ_LOG_TEST
(
GetTimerLog
(
)
LogLevel
:
:
Debug
)
|
|
profiler_thread_is_being_profiled_for_markers
(
mTimerThreadId
)
)
{
mInitTime
=
TimeStamp
:
:
Now
(
)
;
}
}
static
void
Init
(
)
;
static
void
Shutdown
(
)
;
static
void
DeleteAllocatorIfNeeded
(
)
;
static
void
*
operator
new
(
size_t
aSize
)
noexcept
(
true
)
{
return
sAllocator
-
>
Alloc
(
aSize
)
;
}
void
operator
delete
(
void
*
aPtr
)
{
sAllocator
-
>
Free
(
aPtr
)
;
sAllocatorUsers
-
-
;
DeleteAllocatorIfNeeded
(
)
;
}
already_AddRefed
<
nsTimerImpl
>
ForgetTimer
(
)
{
return
mTimer
.
forget
(
)
;
}
private
:
nsTimerEvent
(
const
nsTimerEvent
&
)
=
delete
;
nsTimerEvent
&
operator
=
(
const
nsTimerEvent
&
)
=
delete
;
nsTimerEvent
&
operator
=
(
const
nsTimerEvent
&
&
)
=
delete
;
~
nsTimerEvent
(
)
{
MOZ_ASSERT
(
!
sCanDeleteAllocator
|
|
sAllocatorUsers
>
0
"
This
will
result
in
us
attempting
to
deallocate
the
"
"
nsTimerEvent
allocator
twice
"
)
;
}
TimeStamp
mInitTime
;
RefPtr
<
nsTimerImpl
>
mTimer
;
const
int32_t
mGeneration
;
ProfilerThreadId
mTimerThreadId
;
static
TimerEventAllocator
*
sAllocator
;
static
Atomic
<
int32_t
SequentiallyConsistent
>
sAllocatorUsers
;
static
Atomic
<
bool
SequentiallyConsistent
>
sCanDeleteAllocator
;
}
;
TimerEventAllocator
*
nsTimerEvent
:
:
sAllocator
=
nullptr
;
Atomic
<
int32_t
SequentiallyConsistent
>
nsTimerEvent
:
:
sAllocatorUsers
;
Atomic
<
bool
SequentiallyConsistent
>
nsTimerEvent
:
:
sCanDeleteAllocator
;
namespace
{
void
*
TimerEventAllocator
:
:
Alloc
(
size_t
aSize
)
{
MOZ_ASSERT
(
aSize
=
=
sizeof
(
nsTimerEvent
)
)
;
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
void
*
p
;
if
(
mFirstFree
)
{
p
=
mFirstFree
;
mFirstFree
=
mFirstFree
-
>
mNext
;
}
else
{
p
=
mPool
.
Allocate
(
aSize
fallible
)
;
}
return
p
;
}
void
TimerEventAllocator
:
:
Free
(
void
*
aPtr
)
{
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
FreeEntry
*
entry
=
reinterpret_cast
<
FreeEntry
*
>
(
aPtr
)
;
entry
-
>
mNext
=
mFirstFree
;
mFirstFree
=
entry
;
}
}
struct
TimerMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
Timer
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
uint32_t
aDelay
uint8_t
aType
MarkerThreadId
aThreadId
bool
aCanceled
)
{
aWriter
.
IntProperty
(
"
delay
"
aDelay
)
;
if
(
!
aThreadId
.
IsUnspecified
(
)
)
{
aWriter
.
IntProperty
(
"
threadId
"
static_cast
<
int64_t
>
(
aThreadId
.
ThreadId
(
)
.
ToNumber
(
)
)
)
;
}
if
(
aCanceled
)
{
aWriter
.
BoolProperty
(
"
canceled
"
true
)
;
aWriter
.
StringProperty
(
"
prefix
"
"
"
)
;
}
if
(
aType
!
=
nsITimer
:
:
TYPE_ONE_SHOT
)
{
if
(
aType
=
=
nsITimer
:
:
TYPE_REPEATING_SLACK
)
{
aWriter
.
StringProperty
(
"
ttype
"
"
repeating
slack
"
)
;
}
else
if
(
aType
=
=
nsITimer
:
:
TYPE_REPEATING_PRECISE
)
{
aWriter
.
StringProperty
(
"
ttype
"
"
repeating
precise
"
)
;
}
else
if
(
aType
=
=
nsITimer
:
:
TYPE_REPEATING_PRECISE_CAN_SKIP
)
{
aWriter
.
StringProperty
(
"
ttype
"
"
repeating
precise
can
skip
"
)
;
}
else
if
(
aType
=
=
nsITimer
:
:
TYPE_REPEATING_SLACK_LOW_PRIORITY
)
{
aWriter
.
StringProperty
(
"
ttype
"
"
repeating
slack
low
priority
"
)
;
}
else
if
(
aType
=
=
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
)
{
aWriter
.
StringProperty
(
"
ttype
"
"
low
priority
"
)
;
}
}
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyLabelFormat
(
"
delay
"
"
Delay
"
MS
:
:
Format
:
:
Milliseconds
)
;
schema
.
AddKeyLabelFormat
(
"
ttype
"
"
Timer
Type
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddKeyLabelFormat
(
"
canceled
"
"
Canceled
"
MS
:
:
Format
:
:
String
)
;
schema
.
SetChartLabel
(
"
{
marker
.
data
.
prefix
}
{
marker
.
data
.
delay
}
"
)
;
schema
.
SetTableLabel
(
"
{
marker
.
name
}
-
{
marker
.
data
.
prefix
}
{
marker
.
data
.
delay
}
"
)
;
return
schema
;
}
}
;
struct
AddRemoveTimerMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
AddRemoveTimer
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
ProfilerString8View
&
aTimerName
uint32_t
aDelay
MarkerThreadId
aThreadId
)
{
aWriter
.
StringProperty
(
"
name
"
aTimerName
)
;
aWriter
.
IntProperty
(
"
delay
"
aDelay
)
;
if
(
!
aThreadId
.
IsUnspecified
(
)
)
{
aWriter
.
IntProperty
(
"
threadId
"
static_cast
<
int64_t
>
(
aThreadId
.
ThreadId
(
)
.
ToNumber
(
)
)
)
;
}
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyLabelFormatSearchable
(
"
name
"
"
Name
"
MS
:
:
Format
:
:
String
MS
:
:
Searchable
:
:
Searchable
)
;
schema
.
AddKeyLabelFormat
(
"
delay
"
"
Delay
"
MS
:
:
Format
:
:
Milliseconds
)
;
schema
.
SetTableLabel
(
"
{
marker
.
name
}
-
{
marker
.
data
.
name
}
-
{
marker
.
data
.
delay
}
"
)
;
return
schema
;
}
}
;
void
nsTimerEvent
:
:
Init
(
)
{
sAllocator
=
new
TimerEventAllocator
(
)
;
}
void
nsTimerEvent
:
:
Shutdown
(
)
{
sCanDeleteAllocator
=
true
;
DeleteAllocatorIfNeeded
(
)
;
}
void
nsTimerEvent
:
:
DeleteAllocatorIfNeeded
(
)
{
if
(
sCanDeleteAllocator
&
&
sAllocatorUsers
=
=
0
)
{
delete
sAllocator
;
sAllocator
=
nullptr
;
}
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
NS_IMETHODIMP
nsTimerEvent
:
:
GetName
(
nsACString
&
aName
)
{
bool
current
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
mTimer
-
>
mEventTarget
-
>
IsOnCurrentThread
(
&
current
)
)
&
&
current
)
;
mTimer
-
>
GetName
(
aName
)
;
return
NS_OK
;
}
#
endif
NS_IMETHODIMP
nsTimerEvent
:
:
Run
(
)
{
if
(
MOZ_LOG_TEST
(
GetTimerLog
(
)
LogLevel
:
:
Debug
)
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
[
this
=
%
p
]
time
between
PostTimerEvent
(
)
and
Fire
(
)
:
%
fms
\
n
"
this
(
now
-
mInitTime
)
.
ToMilliseconds
(
)
)
)
;
}
if
(
profiler_thread_is_being_profiled_for_markers
(
mTimerThreadId
)
)
{
MutexAutoLock
lock
(
mTimer
-
>
mMutex
)
;
nsAutoCString
name
;
mTimer
-
>
GetName
(
name
lock
)
;
profiler_add_marker
(
name
geckoprofiler
:
:
category
:
:
TIMER
MarkerOptions
(
MOZ_LIKELY
(
mInitTime
)
?
MarkerTiming
:
:
Interval
(
mTimer
-
>
mTimeout
-
mTimer
-
>
mDelay
mInitTime
)
:
MarkerTiming
:
:
IntervalUntilNowFrom
(
mTimer
-
>
mTimeout
-
mTimer
-
>
mDelay
)
MarkerThreadId
(
mTimerThreadId
)
)
TimerMarker
{
}
mTimer
-
>
mDelay
.
ToMilliseconds
(
)
mTimer
-
>
mType
MarkerThreadId
:
:
CurrentThread
(
)
false
)
;
profiler_add_marker
(
"
PostTimerEvent
"
geckoprofiler
:
:
category
:
:
OTHER
MarkerOptions
(
MOZ_LIKELY
(
mInitTime
)
?
MarkerTiming
:
:
IntervalUntilNowFrom
(
mInitTime
)
:
MarkerTiming
:
:
InstantNow
(
)
MarkerThreadId
(
mTimerThreadId
)
)
AddRemoveTimerMarker
{
}
name
mTimer
-
>
mDelay
.
ToMilliseconds
(
)
MarkerThreadId
:
:
CurrentThread
(
)
)
;
}
mTimer
-
>
Fire
(
mGeneration
)
;
return
NS_OK
;
}
nsresult
TimerThread
:
:
Init
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
TimerThread
:
:
Init
[
%
d
]
\
n
"
mInitialized
)
)
;
if
(
!
mInitialized
)
{
nsTimerEvent
:
:
Init
(
)
;
nsresult
rv
=
NS_NewNamedThread
(
"
Timer
"
getter_AddRefs
(
mThread
)
this
{
.
stackSize
=
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
.
blockDispatch
=
true
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
mThread
=
nullptr
;
}
else
{
RefPtr
<
TimerObserverRunnable
>
r
=
new
TimerObserverRunnable
(
this
)
;
if
(
NS_IsMainThread
(
)
)
{
r
-
>
Run
(
)
;
}
else
{
NS_DispatchToMainThread
(
r
)
;
}
}
mInitialized
=
true
;
}
if
(
!
mThread
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
TimerThread
:
:
Shutdown
(
)
{
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
TimerThread
:
:
Shutdown
begin
\
n
"
)
)
;
if
(
!
mThread
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsTArray
<
RefPtr
<
nsTimerImpl
>
>
timers
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
mShutdown
=
true
;
if
(
mWaiting
)
{
mNotified
=
true
;
mMonitor
.
Notify
(
)
;
}
timers
.
SetCapacity
(
mTimers
.
Length
(
)
)
;
for
(
Entry
&
entry
:
mTimers
)
{
if
(
entry
.
Value
(
)
)
{
timers
.
AppendElement
(
entry
.
Take
(
)
)
;
}
}
mTimers
.
Clear
(
)
;
}
for
(
const
RefPtr
<
nsTimerImpl
>
&
timer
:
timers
)
{
MOZ_ASSERT
(
timer
)
;
timer
-
>
Cancel
(
)
;
}
mThread
-
>
Shutdown
(
)
;
nsTimerEvent
:
:
Shutdown
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
TimerThread
:
:
Shutdown
end
\
n
"
)
)
;
return
NS_OK
;
}
namespace
{
struct
MicrosecondsToInterval
{
PRIntervalTime
operator
[
]
(
size_t
aMs
)
const
{
return
PR_MicrosecondsToInterval
(
aMs
)
;
}
}
;
struct
IntervalComparator
{
int
operator
(
)
(
PRIntervalTime
aInterval
)
const
{
return
(
0
<
aInterval
)
?
-
1
:
1
;
}
}
;
}
#
ifdef
DEBUG
void
TimerThread
:
:
VerifyTimerListConsistency
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
const
size_t
timerCount
=
mTimers
.
Length
(
)
;
size_t
lastNonCanceledTimerIndex
=
0
;
while
(
lastNonCanceledTimerIndex
<
timerCount
&
&
!
mTimers
[
lastNonCanceledTimerIndex
]
.
Value
(
)
)
{
+
+
lastNonCanceledTimerIndex
;
}
MOZ_ASSERT
(
lastNonCanceledTimerIndex
=
=
timerCount
|
|
mTimers
[
lastNonCanceledTimerIndex
]
.
Value
(
)
)
;
MOZ_ASSERT
(
lastNonCanceledTimerIndex
=
=
timerCount
|
|
mTimers
[
lastNonCanceledTimerIndex
]
.
Value
(
)
-
>
mTimeout
=
=
mTimers
[
lastNonCanceledTimerIndex
]
.
Timeout
(
)
)
;
for
(
size_t
timerIndex
=
lastNonCanceledTimerIndex
+
1
;
timerIndex
<
timerCount
;
+
+
timerIndex
)
{
if
(
mTimers
[
timerIndex
]
.
Value
(
)
)
{
MOZ_ASSERT
(
mTimers
[
timerIndex
]
.
Timeout
(
)
=
=
mTimers
[
timerIndex
]
.
Value
(
)
-
>
mTimeout
)
;
MOZ_ASSERT
(
mTimers
[
timerIndex
]
.
Timeout
(
)
>
=
mTimers
[
lastNonCanceledTimerIndex
]
.
Timeout
(
)
)
;
lastNonCanceledTimerIndex
=
timerIndex
;
}
}
}
#
endif
size_t
TimerThread
:
:
ComputeTimerInsertionIndex
(
const
TimeStamp
&
timeout
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
const
size_t
timerCount
=
mTimers
.
Length
(
)
;
size_t
firstGtIndex
=
0
;
while
(
firstGtIndex
<
timerCount
&
&
(
!
mTimers
[
firstGtIndex
]
.
Value
(
)
|
|
mTimers
[
firstGtIndex
]
.
Timeout
(
)
<
=
timeout
)
)
{
+
+
firstGtIndex
;
}
return
firstGtIndex
;
}
TimeStamp
TimerThread
:
:
ComputeWakeupTimeFromTimers
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
!
mTimers
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mTimers
[
0
]
.
Value
(
)
)
;
TimeStamp
bundleWakeup
=
mTimers
[
0
]
.
Timeout
(
)
;
const
TimeDuration
minTimerDelay
=
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
timer_minimum_firing_delay_tolerance_ms
(
)
)
;
const
TimeDuration
maxTimerDelay
=
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
timer_maximum_firing_delay_tolerance_ms
(
)
)
;
TimeStamp
cutoffTime
=
bundleWakeup
+
ComputeAcceptableFiringDelay
(
mTimers
[
0
]
.
Delay
(
)
minTimerDelay
maxTimerDelay
)
;
const
size_t
timerCount
=
mTimers
.
Length
(
)
;
for
(
size_t
entryIndex
=
1
;
entryIndex
<
timerCount
;
+
+
entryIndex
)
{
const
Entry
&
curEntry
=
mTimers
[
entryIndex
]
;
const
nsTimerImpl
*
curTimer
=
curEntry
.
Value
(
)
;
if
(
!
curTimer
)
{
continue
;
}
const
TimeStamp
curTimerDue
=
curEntry
.
Timeout
(
)
;
if
(
curTimerDue
>
cutoffTime
)
{
break
;
}
bundleWakeup
=
curTimerDue
;
cutoffTime
=
std
:
:
min
(
curTimerDue
+
ComputeAcceptableFiringDelay
(
curEntry
.
Delay
(
)
minTimerDelay
maxTimerDelay
)
cutoffTime
)
;
MOZ_ASSERT
(
bundleWakeup
<
=
cutoffTime
)
;
}
MOZ_ASSERT
(
bundleWakeup
-
mTimers
[
0
]
.
Timeout
(
)
<
=
ComputeAcceptableFiringDelay
(
mTimers
[
0
]
.
Delay
(
)
minTimerDelay
maxTimerDelay
)
)
;
return
bundleWakeup
;
}
TimeDuration
TimerThread
:
:
ComputeAcceptableFiringDelay
(
TimeDuration
timerDuration
TimeDuration
minDelay
TimeDuration
maxDelay
)
const
{
constexpr
int64_t
timerDurationDivider
=
8
;
static_assert
(
IsPowerOfTwo
(
static_cast
<
uint64_t
>
(
timerDurationDivider
)
)
)
;
const
TimeDuration
tmp
=
timerDuration
/
timerDurationDivider
;
return
std
:
:
min
(
std
:
:
max
(
minDelay
tmp
)
maxDelay
)
;
}
NS_IMETHODIMP
TimerThread
:
:
Run
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mProfilerThreadId
=
profiler_current_thread_id
(
)
;
uint32_t
usForPosInterval
=
1
;
while
(
PR_MicrosecondsToInterval
(
usForPosInterval
)
=
=
0
)
{
usForPosInterval
<
<
=
1
;
}
size_t
usIntervalResolution
;
BinarySearchIf
(
MicrosecondsToInterval
(
)
0
usForPosInterval
IntervalComparator
(
)
&
usIntervalResolution
)
;
MOZ_ASSERT
(
PR_MicrosecondsToInterval
(
usIntervalResolution
-
1
)
=
=
0
)
;
MOZ_ASSERT
(
PR_MicrosecondsToInterval
(
usIntervalResolution
)
=
=
1
)
;
mAllowedEarlyFiringMicroseconds
=
usIntervalResolution
/
2
;
bool
forceRunNextTimer
=
false
;
static
constexpr
size_t
kMaxQueuedTimerFired
=
128
;
size_t
queuedTimerFiredCount
=
0
;
AutoTArray
<
uint64_t
kMaxQueuedTimerFired
>
queuedTimersFiredPerWakeup
;
queuedTimersFiredPerWakeup
.
SetLengthAndRetainStorage
(
kMaxQueuedTimerFired
)
;
uint64_t
timersFiredThisWakeup
=
0
;
while
(
!
mShutdown
)
{
TimeDuration
waitFor
;
bool
forceRunThisTimer
=
forceRunNextTimer
;
forceRunNextTimer
=
false
;
#
ifdef
DEBUG
VerifyTimerListConsistency
(
)
;
#
endif
if
(
mSleeping
)
{
uint32_t
milliseconds
=
100
;
if
(
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
TimerScheduling
)
)
{
milliseconds
=
ChaosMode
:
:
randomUint32LessThan
(
200
)
;
}
waitFor
=
TimeDuration
:
:
FromMilliseconds
(
milliseconds
)
;
}
else
{
waitFor
=
TimeDuration
:
:
Forever
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
#
if
TIMER_THREAD_STATISTICS
if
(
!
mNotified
&
&
!
mIntendedWakeupTime
.
IsNull
(
)
&
&
now
<
mIntendedWakeupTime
)
{
+
+
mEarlyWakeups
;
const
double
earlinessms
=
(
mIntendedWakeupTime
-
now
)
.
ToMilliseconds
(
)
;
mTotalEarlyWakeupTime
+
=
earlinessms
;
}
#
endif
RemoveLeadingCanceledTimersInternal
(
)
;
if
(
!
mTimers
.
IsEmpty
(
)
)
{
if
(
now
>
=
mTimers
[
0
]
.
Value
(
)
-
>
mTimeout
|
|
forceRunThisTimer
)
{
next
:
RefPtr
<
nsTimerImpl
>
timerRef
(
mTimers
[
0
]
.
Take
(
)
)
;
RemoveFirstTimerInternal
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
Timer
thread
woke
up
%
fms
from
when
it
was
supposed
to
\
n
"
fabs
(
(
now
-
timerRef
-
>
mTimeout
)
.
ToMilliseconds
(
)
)
)
)
;
{
+
+
timersFiredThisWakeup
;
LogTimerEvent
:
:
Run
run
(
timerRef
.
get
(
)
)
;
PostTimerEvent
(
timerRef
.
forget
(
)
)
;
}
if
(
mShutdown
)
{
break
;
}
now
=
TimeStamp
:
:
Now
(
)
;
}
}
RemoveLeadingCanceledTimersInternal
(
)
;
if
(
!
mTimers
.
IsEmpty
(
)
)
{
TimeStamp
timeout
=
mTimers
[
0
]
.
Value
(
)
-
>
mTimeout
;
double
microseconds
=
(
timeout
-
now
)
.
ToMicroseconds
(
)
;
static
constexpr
double
sChaosFractions
[
]
=
{
0
.
0
0
.
25
0
.
5
0
.
75
1
.
0
1
.
75
2
.
75
}
;
if
(
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
TimerScheduling
)
)
{
microseconds
*
=
sChaosFractions
[
ChaosMode
:
:
randomUint32LessThan
(
ArrayLength
(
sChaosFractions
)
)
]
;
forceRunNextTimer
=
true
;
}
if
(
microseconds
<
mAllowedEarlyFiringMicroseconds
)
{
forceRunNextTimer
=
false
;
goto
next
;
}
const
TimeStamp
wakeupTime
=
ComputeWakeupTimeFromTimers
(
)
;
waitFor
=
wakeupTime
-
now
;
MOZ_ASSERT
(
!
waitFor
.
IsZero
(
)
)
;
if
(
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
TimerScheduling
)
)
{
const
double
waitInMs
=
waitFor
.
ToMilliseconds
(
)
;
const
double
chaosWaitInMs
=
waitInMs
*
sChaosFractions
[
ChaosMode
:
:
randomUint32LessThan
(
ArrayLength
(
sChaosFractions
)
)
]
;
waitFor
=
TimeDuration
:
:
FromMilliseconds
(
chaosWaitInMs
)
;
MOZ_ASSERT
(
!
waitFor
.
IsZero
(
)
)
;
}
mIntendedWakeupTime
=
wakeupTime
;
}
else
{
mIntendedWakeupTime
=
TimeStamp
{
}
;
}
if
(
MOZ_LOG_TEST
(
GetTimerLog
(
)
LogLevel
:
:
Debug
)
)
{
if
(
waitFor
=
=
TimeDuration
:
:
Forever
(
)
)
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
waiting
forever
\
n
"
)
)
;
else
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
waiting
for
%
f
\
n
"
waitFor
.
ToMilliseconds
(
)
)
)
;
}
}
{
queuedTimersFiredPerWakeup
[
queuedTimerFiredCount
]
=
timersFiredThisWakeup
;
+
+
queuedTimerFiredCount
;
if
(
queuedTimerFiredCount
=
=
kMaxQueuedTimerFired
)
{
glean
:
:
timer_thread
:
:
timers_fired_per_wakeup
.
AccumulateSamples
(
queuedTimersFiredPerWakeup
)
;
queuedTimerFiredCount
=
0
;
}
}
#
if
TIMER_THREAD_STATISTICS
{
size_t
bucketIndex
=
0
;
while
(
bucketIndex
<
sTimersFiredPerWakeupBucketCount
-
1
&
&
timersFiredThisWakeup
>
sTimersFiredPerWakeupThresholds
[
bucketIndex
]
)
{
+
+
bucketIndex
;
}
MOZ_ASSERT
(
bucketIndex
<
sTimersFiredPerWakeupBucketCount
)
;
+
+
mTimersFiredPerWakeup
[
bucketIndex
]
;
+
+
mTotalWakeupCount
;
if
(
mNotified
)
{
+
+
mTimersFiredPerNotifiedWakeup
[
bucketIndex
]
;
+
+
mTotalNotifiedWakeupCount
;
}
else
{
+
+
mTimersFiredPerUnnotifiedWakeup
[
bucketIndex
]
;
+
+
mTotalUnnotifiedWakeupCount
;
}
}
#
endif
timersFiredThisWakeup
=
0
;
mWaiting
=
true
;
mNotified
=
false
;
{
AUTO_PROFILER_TRACING_MARKER
(
"
TimerThread
"
"
Wait
"
OTHER
)
;
mMonitor
.
Wait
(
waitFor
)
;
}
if
(
mNotified
)
{
forceRunNextTimer
=
false
;
}
mWaiting
=
false
;
}
if
(
queuedTimerFiredCount
!
=
0
)
{
queuedTimersFiredPerWakeup
.
SetLengthAndRetainStorage
(
queuedTimerFiredCount
)
;
glean
:
:
timer_thread
:
:
timers_fired_per_wakeup
.
AccumulateSamples
(
queuedTimersFiredPerWakeup
)
;
}
return
NS_OK
;
}
nsresult
TimerThread
:
:
AddTimer
(
nsTimerImpl
*
aTimer
const
MutexAutoLock
&
aProofOfLock
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
AUTO_TIMERS_STATS
(
TimerThread_AddTimer
)
;
if
(
!
aTimer
-
>
mEventTarget
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
const
TimeDuration
minTimerDelay
=
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
timer_minimum_firing_delay_tolerance_ms
(
)
)
;
const
TimeDuration
maxTimerDelay
=
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
timer_maximum_firing_delay_tolerance_ms
(
)
)
;
const
TimeDuration
firingDelay
=
ComputeAcceptableFiringDelay
(
aTimer
-
>
mDelay
minTimerDelay
maxTimerDelay
)
;
const
bool
firingBeforeNextWakeup
=
mIntendedWakeupTime
.
IsNull
(
)
|
|
(
aTimer
-
>
mTimeout
+
firingDelay
<
mIntendedWakeupTime
)
;
const
bool
wakeUpTimerThread
=
mWaiting
&
&
(
firingBeforeNextWakeup
|
|
aTimer
-
>
mDelay
.
IsZero
(
)
)
;
#
if
TIMER_THREAD_STATISTICS
if
(
mTotalTimersAdded
=
=
0
)
{
mFirstTimerAdded
=
TimeStamp
:
:
Now
(
)
;
}
+
+
mTotalTimersAdded
;
#
endif
if
(
!
AddTimerInternal
(
*
aTimer
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
wakeUpTimerThread
)
{
mNotified
=
true
;
mMonitor
.
Notify
(
)
;
}
if
(
profiler_thread_is_being_profiled_for_markers
(
mProfilerThreadId
)
)
{
nsAutoCString
name
;
aTimer
-
>
GetName
(
name
aProofOfLock
)
;
nsLiteralCString
prefix
(
"
Anonymous_
"
)
;
profiler_add_marker
(
"
AddTimer
"
geckoprofiler
:
:
category
:
:
OTHER
MarkerOptions
(
MarkerThreadId
(
mProfilerThreadId
)
MarkerStack
:
:
MaybeCapture
(
name
.
Equals
(
"
nonfunction
:
JS
"
)
|
|
StringHead
(
name
prefix
.
Length
(
)
)
=
=
prefix
)
)
AddRemoveTimerMarker
{
}
name
aTimer
-
>
mDelay
.
ToMilliseconds
(
)
MarkerThreadId
:
:
CurrentThread
(
)
)
;
}
return
NS_OK
;
}
nsresult
TimerThread
:
:
RemoveTimer
(
nsTimerImpl
*
aTimer
const
MutexAutoLock
&
aProofOfLock
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
AUTO_TIMERS_STATS
(
TimerThread_RemoveTimer
)
;
if
(
!
RemoveTimerInternal
(
*
aTimer
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
#
if
TIMER_THREAD_STATISTICS
+
+
mTotalTimersRemoved
;
#
endif
if
(
profiler_thread_is_being_profiled_for_markers
(
mProfilerThreadId
)
)
{
nsAutoCString
name
;
aTimer
-
>
GetName
(
name
aProofOfLock
)
;
nsLiteralCString
prefix
(
"
Anonymous_
"
)
;
profiler_add_marker
(
"
RemoveTimer
"
geckoprofiler
:
:
category
:
:
OTHER
MarkerOptions
(
MarkerThreadId
(
mProfilerThreadId
)
MarkerStack
:
:
MaybeCapture
(
name
.
Equals
(
"
nonfunction
:
JS
"
)
|
|
StringHead
(
name
prefix
.
Length
(
)
)
=
=
prefix
)
)
AddRemoveTimerMarker
{
}
name
aTimer
-
>
mDelay
.
ToMilliseconds
(
)
MarkerThreadId
:
:
CurrentThread
(
)
)
;
profiler_add_marker
(
name
geckoprofiler
:
:
category
:
:
TIMER
MarkerOptions
(
MarkerTiming
:
:
IntervalUntilNowFrom
(
aTimer
-
>
mTimeout
-
aTimer
-
>
mDelay
)
MarkerThreadId
(
mProfilerThreadId
)
)
TimerMarker
{
}
aTimer
-
>
mDelay
.
ToMilliseconds
(
)
aTimer
-
>
mType
MarkerThreadId
:
:
CurrentThread
(
)
true
)
;
}
return
NS_OK
;
}
TimeStamp
TimerThread
:
:
FindNextFireTimeForCurrentThread
(
TimeStamp
aDefault
uint32_t
aSearchBound
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
AUTO_TIMERS_STATS
(
TimerThread_FindNextFireTimeForCurrentThread
)
;
for
(
const
Entry
&
entry
:
mTimers
)
{
const
nsTimerImpl
*
timer
=
entry
.
Value
(
)
;
if
(
timer
)
{
if
(
entry
.
Timeout
(
)
>
aDefault
)
{
return
aDefault
;
}
if
(
!
timer
-
>
IsLowPriority
(
)
)
{
bool
isOnCurrentThread
=
false
;
nsresult
rv
=
timer
-
>
mEventTarget
-
>
IsOnCurrentThread
(
&
isOnCurrentThread
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isOnCurrentThread
)
{
return
entry
.
Timeout
(
)
;
}
}
if
(
aSearchBound
=
=
0
)
{
return
timer
-
>
mTimeout
;
}
-
-
aSearchBound
;
}
}
return
aDefault
;
}
bool
TimerThread
:
:
AddTimerInternal
(
nsTimerImpl
&
aTimer
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
aTimer
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal
)
;
if
(
mShutdown
)
{
return
false
;
}
LogTimerEvent
:
:
LogDispatch
(
&
aTimer
)
;
const
TimeStamp
&
timeout
=
aTimer
.
mTimeout
;
const
size_t
insertionIndex
=
ComputeTimerInsertionIndex
(
timeout
)
;
if
(
insertionIndex
!
=
0
&
&
!
mTimers
[
insertionIndex
-
1
]
.
Value
(
)
)
{
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal_overwrite_before
)
;
mTimers
[
insertionIndex
-
1
]
=
Entry
{
aTimer
}
;
return
true
;
}
const
size_t
length
=
mTimers
.
Length
(
)
;
if
(
insertionIndex
=
=
length
)
{
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal_append
)
;
return
mTimers
.
AppendElement
(
Entry
{
aTimer
}
mozilla
:
:
fallible
)
;
}
if
(
!
mTimers
[
insertionIndex
]
.
Value
(
)
)
{
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal_overwrite
)
;
mTimers
[
insertionIndex
]
=
Entry
{
aTimer
}
;
return
true
;
}
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal_insert
)
;
if
(
length
=
=
mTimers
.
Capacity
(
)
&
&
mTimers
[
length
-
1
]
.
Value
(
)
)
{
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal_insert_expand
)
;
if
(
!
mTimers
.
AppendElement
(
Entry
{
mTimers
[
length
-
1
]
.
Timeout
(
)
+
TimeDuration
:
:
FromSeconds
(
365
.
0
*
24
.
0
*
60
.
0
*
60
.
0
)
}
mozilla
:
:
fallible
)
)
{
return
false
;
}
}
Entry
extractedEntry
=
std
:
:
exchange
(
mTimers
[
insertionIndex
]
Entry
{
aTimer
}
)
;
for
(
size_t
i
=
insertionIndex
+
1
;
i
<
length
;
+
+
i
)
{
Entry
&
entryRef
=
mTimers
[
i
]
;
if
(
!
entryRef
.
Value
(
)
)
{
COUNT_TIMERS_STATS
(
TimerThread_AddTimerInternal_insert_overwrite
)
;
entryRef
=
std
:
:
move
(
extractedEntry
)
;
return
true
;
}
COUNT_TIMERS_STATS
(
TimerThread_AddTimerInternal_insert_shifts
)
;
std
:
:
swap
(
entryRef
extractedEntry
)
;
}
COUNT_TIMERS_STATS
(
TimerThread_AddTimerInternal_insert_append
)
;
mTimers
.
AppendElement
(
std
:
:
move
(
extractedEntry
)
)
;
return
true
;
}
bool
TimerThread
:
:
RemoveTimerInternal
(
nsTimerImpl
&
aTimer
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
aTimer
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_RemoveTimerInternal
)
;
if
(
!
aTimer
.
IsInTimerThread
(
)
)
{
COUNT_TIMERS_STATS
(
TimerThread_RemoveTimerInternal_not_in_list
)
;
return
false
;
}
AUTO_TIMERS_STATS
(
TimerThread_RemoveTimerInternal_in_list
)
;
for
(
auto
&
entry
:
mTimers
)
{
if
(
entry
.
Value
(
)
=
=
&
aTimer
)
{
entry
.
Forget
(
)
;
return
true
;
}
}
MOZ_ASSERT
(
!
aTimer
.
IsInTimerThread
(
)
"
Not
found
in
the
list
but
it
should
be
!
?
"
)
;
return
false
;
}
void
TimerThread
:
:
RemoveLeadingCanceledTimersInternal
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_RemoveLeadingCanceledTimersInternal
)
;
size_t
toRemove
=
0
;
while
(
toRemove
<
mTimers
.
Length
(
)
&
&
!
mTimers
[
toRemove
]
.
Value
(
)
)
{
+
+
toRemove
;
}
mTimers
.
RemoveElementsAt
(
0
toRemove
)
;
}
void
TimerThread
:
:
RemoveFirstTimerInternal
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_RemoveFirstTimerInternal
)
;
MOZ_ASSERT
(
!
mTimers
.
IsEmpty
(
)
)
;
mTimers
.
RemoveElementAt
(
0
)
;
}
void
TimerThread
:
:
PostTimerEvent
(
already_AddRefed
<
nsTimerImpl
>
aTimerRef
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_PostTimerEvent
)
;
RefPtr
<
nsTimerImpl
>
timer
(
aTimerRef
)
;
#
if
TIMER_THREAD_STATISTICS
const
double
actualFiringDelay
=
std
:
:
max
(
(
TimeStamp
:
:
Now
(
)
-
timer
-
>
mTimeout
)
.
ToMilliseconds
(
)
0
.
0
)
;
if
(
mNotified
)
{
+
+
mTotalTimersFiredNotified
;
mTotalActualTimerFiringDelayNotified
+
=
actualFiringDelay
;
}
else
{
+
+
mTotalTimersFiredUnnotified
;
mTotalActualTimerFiringDelayUnnotified
+
=
actualFiringDelay
;
}
#
endif
if
(
!
timer
-
>
mEventTarget
)
{
NS_ERROR
(
"
Attempt
to
post
timer
event
to
NULL
event
target
"
)
;
return
;
}
nsCOMPtr
<
nsIEventTarget
>
target
=
timer
-
>
mEventTarget
;
void
*
p
=
nsTimerEvent
:
:
operator
new
(
sizeof
(
nsTimerEvent
)
)
;
if
(
!
p
)
{
return
;
}
RefPtr
<
nsTimerEvent
>
event
=
:
:
new
(
KnownNotNull
p
)
nsTimerEvent
(
timer
.
forget
(
)
mProfilerThreadId
)
;
nsresult
rv
;
{
MonitorAutoUnlock
unlock
(
mMonitor
)
;
rv
=
target
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
timer
=
event
-
>
ForgetTimer
(
)
;
MutexAutoLock
lock1
(
timer
.
get
(
)
-
>
mMutex
)
;
MonitorAutoLock
lock2
(
mMonitor
)
;
RemoveTimerInternal
(
*
timer
)
;
}
}
}
void
TimerThread
:
:
DoBeforeSleep
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mSleeping
=
true
;
}
void
TimerThread
:
:
DoAfterSleep
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mSleeping
=
false
;
mNotified
=
true
;
PROFILER_MARKER_UNTYPED
(
"
AfterSleep
"
OTHER
MarkerThreadId
(
mProfilerThreadId
)
)
;
mMonitor
.
Notify
(
)
;
}
NS_IMETHODIMP
TimerThread
:
:
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
{
if
(
StaticPrefs
:
:
timer_ignore_sleep_wake_notifications
(
)
)
{
return
NS_OK
;
}
if
(
strcmp
(
aTopic
"
sleep_notification
"
)
=
=
0
|
|
strcmp
(
aTopic
"
suspend_process_notification
"
)
=
=
0
)
{
DoBeforeSleep
(
)
;
}
else
if
(
strcmp
(
aTopic
"
wake_notification
"
)
=
=
0
|
|
strcmp
(
aTopic
"
resume_process_notification
"
)
=
=
0
)
{
DoAfterSleep
(
)
;
}
return
NS_OK
;
}
uint32_t
TimerThread
:
:
AllowedEarlyFiringMicroseconds
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
mAllowedEarlyFiringMicroseconds
;
}
#
if
TIMER_THREAD_STATISTICS
void
TimerThread
:
:
PrintStatistics
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
const
TimeStamp
freshNow
=
TimeStamp
:
:
Now
(
)
;
const
double
timeElapsed
=
mFirstTimerAdded
.
IsNull
(
)
?
0
.
0
:
(
freshNow
-
mFirstTimerAdded
)
.
ToSeconds
(
)
;
printf_stderr
(
"
TimerThread
Stats
(
Total
time
%
8
.
2fs
)
\
n
"
timeElapsed
)
;
printf_stderr
(
"
Added
:
%
6llu
Removed
:
%
6llu
Fired
:
%
6llu
\
n
"
mTotalTimersAdded
mTotalTimersRemoved
mTotalTimersFiredNotified
+
mTotalTimersFiredUnnotified
)
;
auto
PrintTimersFiredBucket
=
[
]
(
const
AutoTArray
<
size_t
sTimersFiredPerWakeupBucketCount
>
&
buckets
const
size_t
wakeupCount
const
size_t
timersFiredCount
const
double
totalTimerDelay
const
char
*
label
)
{
printf_stderr
(
"
%
s
:
[
"
label
)
;
for
(
size_t
bucketVal
:
buckets
)
{
printf_stderr
(
"
%
5llu
"
bucketVal
)
;
}
printf_stderr
(
"
]
Wake
-
ups
/
timer
%
6llu
/
%
6llu
(
%
7
.
4f
)
Avg
Timer
Delay
%
7
.
4f
\
n
"
wakeupCount
timersFiredCount
static_cast
<
double
>
(
wakeupCount
)
/
timersFiredCount
totalTimerDelay
/
timersFiredCount
)
;
}
;
printf_stderr
(
"
Wake
-
ups
:
\
n
"
)
;
PrintTimersFiredBucket
(
mTimersFiredPerWakeup
mTotalWakeupCount
mTotalTimersFiredNotified
+
mTotalTimersFiredUnnotified
mTotalActualTimerFiringDelayNotified
+
mTotalActualTimerFiringDelayUnnotified
"
Total
"
)
;
PrintTimersFiredBucket
(
mTimersFiredPerNotifiedWakeup
mTotalNotifiedWakeupCount
mTotalTimersFiredNotified
mTotalActualTimerFiringDelayNotified
"
Notified
"
)
;
PrintTimersFiredBucket
(
mTimersFiredPerUnnotifiedWakeup
mTotalUnnotifiedWakeupCount
mTotalTimersFiredUnnotified
mTotalActualTimerFiringDelayUnnotified
"
Unnotified
"
)
;
printf_stderr
(
"
Early
Wake
-
ups
:
%
6llu
Avg
:
%
7
.
4fms
\
n
"
mEarlyWakeups
mTotalEarlyWakeupTime
/
mEarlyWakeups
)
;
}
#
endif
class
nsReadOnlyTimer
final
:
public
nsITimer
{
public
:
explicit
nsReadOnlyTimer
(
const
nsACString
&
aName
uint32_t
aDelay
uint32_t
aType
)
:
mName
(
aName
)
mDelay
(
aDelay
)
mType
(
aType
)
{
}
NS_DECL_ISUPPORTS
NS_IMETHOD
Init
(
nsIObserver
*
aObserver
uint32_t
aDelayInMs
uint32_t
aType
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
InitWithCallback
(
nsITimerCallback
*
aCallback
uint32_t
aDelayInMs
uint32_t
aType
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
InitHighResolutionWithCallback
(
nsITimerCallback
*
aCallback
const
mozilla
:
:
TimeDuration
&
aDelay
uint32_t
aType
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
Cancel
(
void
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
InitWithNamedFuncCallback
(
nsTimerCallbackFunc
aCallback
void
*
aClosure
uint32_t
aDelay
uint32_t
aType
const
char
*
aName
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
InitHighResolutionWithNamedFuncCallback
(
nsTimerCallbackFunc
aCallback
void
*
aClosure
const
mozilla
:
:
TimeDuration
&
aDelay
uint32_t
aType
const
char
*
aName
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
=
mName
;
return
NS_OK
;
}
NS_IMETHOD
GetDelay
(
uint32_t
*
aDelay
)
override
{
*
aDelay
=
mDelay
;
return
NS_OK
;
}
NS_IMETHOD
SetDelay
(
uint32_t
aDelay
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
GetType
(
uint32_t
*
aType
)
override
{
*
aType
=
mType
;
return
NS_OK
;
}
NS_IMETHOD
SetType
(
uint32_t
aType
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
GetClosure
(
void
*
*
aClosure
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
GetCallback
(
nsITimerCallback
*
*
aCallback
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
GetTarget
(
nsIEventTarget
*
*
aTarget
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
SetTarget
(
nsIEventTarget
*
aTarget
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
GetAllowedEarlyFiringMicroseconds
(
uint32_t
*
aAllowedEarlyFiringMicroseconds
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
override
{
return
sizeof
(
*
this
)
;
}
private
:
nsCString
mName
;
uint32_t
mDelay
;
uint32_t
mType
;
~
nsReadOnlyTimer
(
)
=
default
;
}
;
NS_IMPL_ISUPPORTS
(
nsReadOnlyTimer
nsITimer
)
nsresult
TimerThread
:
:
GetTimers
(
nsTArray
<
RefPtr
<
nsITimer
>
>
&
aRetVal
)
{
nsTArray
<
RefPtr
<
nsTimerImpl
>
>
timers
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
for
(
const
auto
&
entry
:
mTimers
)
{
nsTimerImpl
*
timer
=
entry
.
Value
(
)
;
if
(
!
timer
)
{
continue
;
}
timers
.
AppendElement
(
timer
)
;
}
}
for
(
nsTimerImpl
*
timer
:
timers
)
{
nsAutoCString
name
;
timer
-
>
GetName
(
name
)
;
uint32_t
delay
;
timer
-
>
GetDelay
(
&
delay
)
;
uint32_t
type
;
timer
-
>
GetType
(
&
type
)
;
aRetVal
.
AppendElement
(
new
nsReadOnlyTimer
(
name
delay
type
)
)
;
}
return
NS_OK
;
}
