#
include
"
nsTimerImpl
.
h
"
#
include
"
TimerThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
pratom
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
ChaosMode
.
h
"
#
include
"
mozilla
/
ArenaAllocator
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
<
math
.
h
>
using
namespace
mozilla
;
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracerImpl
.
h
"
using
namespace
mozilla
:
:
tasktracer
;
#
endif
NS_IMPL_ISUPPORTS
(
TimerThread
nsIRunnable
nsIObserver
)
TimerThread
:
:
TimerThread
(
)
:
mInitInProgress
(
false
)
mInitialized
(
false
)
mMonitor
(
"
TimerThread
.
mMonitor
"
)
mShutdown
(
false
)
mWaiting
(
false
)
mNotified
(
false
)
mSleeping
(
false
)
{
}
TimerThread
:
:
~
TimerThread
(
)
{
mThread
=
nullptr
;
NS_ASSERTION
(
mTimers
.
IsEmpty
(
)
"
Timers
remain
in
TimerThread
:
:
~
TimerThread
"
)
;
}
nsresult
TimerThread
:
:
InitLocks
(
)
{
return
NS_OK
;
}
namespace
{
class
TimerObserverRunnable
:
public
Runnable
{
public
:
explicit
TimerObserverRunnable
(
nsIObserver
*
aObserver
)
:
mObserver
(
aObserver
)
{
}
NS_DECL_NSIRUNNABLE
private
:
nsCOMPtr
<
nsIObserver
>
mObserver
;
}
;
NS_IMETHODIMP
TimerObserverRunnable
:
:
Run
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
mObserver
"
sleep_notification
"
false
)
;
observerService
-
>
AddObserver
(
mObserver
"
wake_notification
"
false
)
;
observerService
-
>
AddObserver
(
mObserver
"
suspend_process_notification
"
false
)
;
observerService
-
>
AddObserver
(
mObserver
"
resume_process_notification
"
false
)
;
}
return
NS_OK
;
}
}
namespace
{
class
TimerEventAllocator
{
private
:
struct
FreeEntry
{
FreeEntry
*
mNext
;
}
;
ArenaAllocator
<
4096
>
mPool
;
FreeEntry
*
mFirstFree
;
mozilla
:
:
Monitor
mMonitor
;
public
:
TimerEventAllocator
(
)
:
mPool
(
)
mFirstFree
(
nullptr
)
mMonitor
(
"
TimerEventAllocator
"
)
{
}
~
TimerEventAllocator
(
)
{
}
void
*
Alloc
(
size_t
aSize
)
;
void
Free
(
void
*
aPtr
)
;
}
;
}
class
nsTimerEvent
final
:
public
CancelableRunnable
{
public
:
NS_IMETHOD
Run
(
)
override
;
nsresult
Cancel
(
)
override
{
mTimer
-
>
Cancel
(
)
;
return
NS_OK
;
}
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
;
nsTimerEvent
(
)
:
mTimer
(
)
mGeneration
(
0
)
{
sAllocatorUsers
+
+
;
}
TimeStamp
mInitTime
;
static
void
Init
(
)
;
static
void
Shutdown
(
)
;
static
void
DeleteAllocatorIfNeeded
(
)
;
static
void
*
operator
new
(
size_t
aSize
)
CPP_THROW_NEW
{
return
sAllocator
-
>
Alloc
(
aSize
)
;
}
void
operator
delete
(
void
*
aPtr
)
{
sAllocator
-
>
Free
(
aPtr
)
;
DeleteAllocatorIfNeeded
(
)
;
}
already_AddRefed
<
nsTimerImpl
>
ForgetTimer
(
)
{
return
mTimer
.
forget
(
)
;
}
void
SetTimer
(
already_AddRefed
<
nsTimerImpl
>
aTimer
)
{
mTimer
=
aTimer
;
mGeneration
=
mTimer
-
>
GetGeneration
(
)
;
}
private
:
nsTimerEvent
(
const
nsTimerEvent
&
)
=
delete
;
nsTimerEvent
&
operator
=
(
const
nsTimerEvent
&
)
=
delete
;
nsTimerEvent
&
operator
=
(
const
nsTimerEvent
&
&
)
=
delete
;
~
nsTimerEvent
(
)
{
MOZ_ASSERT
(
!
sCanDeleteAllocator
|
|
sAllocatorUsers
>
0
"
This
will
result
in
us
attempting
to
deallocate
the
nsTimerEvent
allocator
twice
"
)
;
sAllocatorUsers
-
-
;
}
RefPtr
<
nsTimerImpl
>
mTimer
;
int32_t
mGeneration
;
static
TimerEventAllocator
*
sAllocator
;
static
Atomic
<
int32_t
>
sAllocatorUsers
;
static
bool
sCanDeleteAllocator
;
}
;
TimerEventAllocator
*
nsTimerEvent
:
:
sAllocator
=
nullptr
;
Atomic
<
int32_t
>
nsTimerEvent
:
:
sAllocatorUsers
;
bool
nsTimerEvent
:
:
sCanDeleteAllocator
=
false
;
namespace
{
void
*
TimerEventAllocator
:
:
Alloc
(
size_t
aSize
)
{
MOZ_ASSERT
(
aSize
=
=
sizeof
(
nsTimerEvent
)
)
;
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
void
*
p
;
if
(
mFirstFree
)
{
p
=
mFirstFree
;
mFirstFree
=
mFirstFree
-
>
mNext
;
}
else
{
p
=
mPool
.
Allocate
(
aSize
fallible
)
;
}
return
p
;
}
void
TimerEventAllocator
:
:
Free
(
void
*
aPtr
)
{
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
FreeEntry
*
entry
=
reinterpret_cast
<
FreeEntry
*
>
(
aPtr
)
;
entry
-
>
mNext
=
mFirstFree
;
mFirstFree
=
entry
;
}
}
void
nsTimerEvent
:
:
Init
(
)
{
sAllocator
=
new
TimerEventAllocator
(
)
;
}
void
nsTimerEvent
:
:
Shutdown
(
)
{
sCanDeleteAllocator
=
true
;
DeleteAllocatorIfNeeded
(
)
;
}
void
nsTimerEvent
:
:
DeleteAllocatorIfNeeded
(
)
{
if
(
sCanDeleteAllocator
&
&
sAllocatorUsers
=
=
0
)
{
delete
sAllocator
;
sAllocator
=
nullptr
;
}
}
NS_IMETHODIMP
nsTimerEvent
:
:
GetName
(
nsACString
&
aName
)
{
bool
current
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
mTimer
-
>
mEventTarget
-
>
IsOnCurrentThread
(
&
current
)
)
&
&
current
)
;
mTimer
-
>
GetName
(
aName
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTimerEvent
:
:
Run
(
)
{
if
(
MOZ_LOG_TEST
(
GetTimerLog
(
)
LogLevel
:
:
Debug
)
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
[
this
=
%
p
]
time
between
PostTimerEvent
(
)
and
Fire
(
)
:
%
fms
\
n
"
this
(
now
-
mInitTime
)
.
ToMilliseconds
(
)
)
)
;
}
mTimer
-
>
Fire
(
mGeneration
)
;
return
NS_OK
;
}
nsresult
TimerThread
:
:
Init
(
)
{
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
TimerThread
:
:
Init
[
%
d
]
\
n
"
mInitialized
)
)
;
if
(
mInitialized
)
{
if
(
!
mThread
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsTimerEvent
:
:
Init
(
)
;
if
(
mInitInProgress
.
exchange
(
true
)
=
=
false
)
{
nsresult
rv
=
NS_NewNamedThread
(
"
Timer
Thread
"
getter_AddRefs
(
mThread
)
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
mThread
=
nullptr
;
}
else
{
RefPtr
<
TimerObserverRunnable
>
r
=
new
TimerObserverRunnable
(
this
)
;
if
(
NS_IsMainThread
(
)
)
{
r
-
>
Run
(
)
;
}
else
{
NS_DispatchToMainThread
(
r
)
;
}
}
{
MonitorAutoLock
lock
(
mMonitor
)
;
mInitialized
=
true
;
mMonitor
.
NotifyAll
(
)
;
}
}
else
{
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
!
mInitialized
)
{
mMonitor
.
Wait
(
)
;
}
}
if
(
!
mThread
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
TimerThread
:
:
Shutdown
(
)
{
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
TimerThread
:
:
Shutdown
begin
\
n
"
)
)
;
if
(
!
mThread
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsTArray
<
UniquePtr
<
Entry
>
>
timers
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
mShutdown
=
true
;
if
(
mWaiting
)
{
mNotified
=
true
;
mMonitor
.
Notify
(
)
;
}
mTimers
.
SwapElements
(
timers
)
;
}
uint32_t
timersCount
=
timers
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
timersCount
;
i
+
+
)
{
RefPtr
<
nsTimerImpl
>
timer
=
timers
[
i
]
-
>
Take
(
)
;
if
(
timer
)
{
timer
-
>
Cancel
(
)
;
}
}
mThread
-
>
Shutdown
(
)
;
nsTimerEvent
:
:
Shutdown
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
TimerThread
:
:
Shutdown
end
\
n
"
)
)
;
return
NS_OK
;
}
namespace
{
struct
MicrosecondsToInterval
{
PRIntervalTime
operator
[
]
(
size_t
aMs
)
const
{
return
PR_MicrosecondsToInterval
(
aMs
)
;
}
}
;
struct
IntervalComparator
{
int
operator
(
)
(
PRIntervalTime
aInterval
)
const
{
return
(
0
<
aInterval
)
?
-
1
:
1
;
}
}
;
}
NS_IMETHODIMP
TimerThread
:
:
Run
(
)
{
NS_SetCurrentThreadName
(
"
Timer
"
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
uint32_t
usForPosInterval
=
1
;
while
(
PR_MicrosecondsToInterval
(
usForPosInterval
)
=
=
0
)
{
usForPosInterval
<
<
=
1
;
}
size_t
usIntervalResolution
;
BinarySearchIf
(
MicrosecondsToInterval
(
)
0
usForPosInterval
IntervalComparator
(
)
&
usIntervalResolution
)
;
MOZ_ASSERT
(
PR_MicrosecondsToInterval
(
usIntervalResolution
-
1
)
=
=
0
)
;
MOZ_ASSERT
(
PR_MicrosecondsToInterval
(
usIntervalResolution
)
=
=
1
)
;
int32_t
halfMicrosecondsIntervalResolution
=
usIntervalResolution
/
2
;
bool
forceRunNextTimer
=
false
;
while
(
!
mShutdown
)
{
PRIntervalTime
waitFor
;
bool
forceRunThisTimer
=
forceRunNextTimer
;
forceRunNextTimer
=
false
;
if
(
mSleeping
)
{
uint32_t
milliseconds
=
100
;
if
(
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
TimerScheduling
)
)
{
milliseconds
=
ChaosMode
:
:
randomUint32LessThan
(
200
)
;
}
waitFor
=
PR_MillisecondsToInterval
(
milliseconds
)
;
}
else
{
waitFor
=
PR_INTERVAL_NO_TIMEOUT
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
RemoveLeadingCanceledTimersInternal
(
)
;
if
(
!
mTimers
.
IsEmpty
(
)
)
{
if
(
now
>
=
mTimers
[
0
]
-
>
Value
(
)
-
>
mTimeout
|
|
forceRunThisTimer
)
{
next
:
RefPtr
<
nsTimerImpl
>
timerRef
(
mTimers
[
0
]
-
>
Take
(
)
)
;
RemoveFirstTimerInternal
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
Timer
thread
woke
up
%
fms
from
when
it
was
supposed
to
\
n
"
fabs
(
(
now
-
timerRef
-
>
mTimeout
)
.
ToMilliseconds
(
)
)
)
)
;
timerRef
=
PostTimerEvent
(
timerRef
.
forget
(
)
)
;
if
(
timerRef
)
{
nsrefcnt
rc
=
timerRef
.
forget
(
)
.
take
(
)
-
>
Release
(
)
;
(
void
)
rc
;
MOZ_ASSERT
(
rc
!
=
0
"
destroyed
timer
off
its
target
thread
!
"
)
;
}
if
(
mShutdown
)
{
break
;
}
now
=
TimeStamp
:
:
Now
(
)
;
}
}
RemoveLeadingCanceledTimersInternal
(
)
;
if
(
!
mTimers
.
IsEmpty
(
)
)
{
TimeStamp
timeout
=
mTimers
[
0
]
-
>
Value
(
)
-
>
mTimeout
;
double
microseconds
=
(
timeout
-
now
)
.
ToMilliseconds
(
)
*
1000
;
if
(
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
TimerScheduling
)
)
{
static
const
float
sFractions
[
]
=
{
0
.
0f
0
.
25f
0
.
5f
0
.
75f
1
.
0f
1
.
75f
2
.
75f
}
;
microseconds
*
=
sFractions
[
ChaosMode
:
:
randomUint32LessThan
(
ArrayLength
(
sFractions
)
)
]
;
forceRunNextTimer
=
true
;
}
if
(
microseconds
<
halfMicrosecondsIntervalResolution
)
{
forceRunNextTimer
=
false
;
goto
next
;
}
waitFor
=
PR_MicrosecondsToInterval
(
static_cast
<
uint32_t
>
(
microseconds
)
)
;
if
(
waitFor
=
=
0
)
{
waitFor
=
1
;
}
}
if
(
MOZ_LOG_TEST
(
GetTimerLog
(
)
LogLevel
:
:
Debug
)
)
{
if
(
waitFor
=
=
PR_INTERVAL_NO_TIMEOUT
)
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
waiting
for
PR_INTERVAL_NO_TIMEOUT
\
n
"
)
)
;
else
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
waiting
for
%
u
\
n
"
PR_IntervalToMilliseconds
(
waitFor
)
)
)
;
}
}
mWaiting
=
true
;
mNotified
=
false
;
mMonitor
.
Wait
(
waitFor
)
;
if
(
mNotified
)
{
forceRunNextTimer
=
false
;
}
mWaiting
=
false
;
}
return
NS_OK
;
}
nsresult
TimerThread
:
:
AddTimer
(
nsTimerImpl
*
aTimer
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
!
aTimer
-
>
mEventTarget
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
!
AddTimerInternal
(
aTimer
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
mWaiting
&
&
mTimers
[
0
]
-
>
Value
(
)
=
=
aTimer
)
{
mNotified
=
true
;
mMonitor
.
Notify
(
)
;
}
return
NS_OK
;
}
nsresult
TimerThread
:
:
RemoveTimer
(
nsTimerImpl
*
aTimer
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
!
RemoveTimerInternal
(
aTimer
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
mWaiting
)
{
mNotified
=
true
;
mMonitor
.
Notify
(
)
;
}
return
NS_OK
;
}
bool
TimerThread
:
:
AddTimerInternal
(
nsTimerImpl
*
aTimer
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
mShutdown
)
{
return
false
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
UniquePtr
<
Entry
>
*
entry
=
mTimers
.
AppendElement
(
MakeUnique
<
Entry
>
(
now
aTimer
-
>
mTimeout
aTimer
)
mozilla
:
:
fallible
)
;
if
(
!
entry
)
{
return
false
;
}
std
:
:
push_heap
(
mTimers
.
begin
(
)
mTimers
.
end
(
)
Entry
:
:
UniquePtrLessThan
)
;
#
ifdef
MOZ_TASK_TRACER
aTimer
-
>
GetTLSTraceInfo
(
)
;
#
endif
return
true
;
}
bool
TimerThread
:
:
RemoveTimerInternal
(
nsTimerImpl
*
aTimer
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
!
aTimer
|
|
!
aTimer
-
>
mHolder
)
{
return
false
;
}
aTimer
-
>
mHolder
-
>
Forget
(
aTimer
)
;
return
true
;
}
void
TimerThread
:
:
RemoveLeadingCanceledTimersInternal
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
auto
sortedEnd
=
mTimers
.
end
(
)
;
while
(
sortedEnd
!
=
mTimers
.
begin
(
)
&
&
!
mTimers
[
0
]
-
>
Value
(
)
)
{
std
:
:
pop_heap
(
mTimers
.
begin
(
)
sortedEnd
Entry
:
:
UniquePtrLessThan
)
;
-
-
sortedEnd
;
}
if
(
sortedEnd
=
=
mTimers
.
end
(
)
)
{
return
;
}
mTimers
.
RemoveElementsAt
(
sortedEnd
-
mTimers
.
begin
(
)
mTimers
.
end
(
)
-
sortedEnd
)
;
}
void
TimerThread
:
:
RemoveFirstTimerInternal
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
!
mTimers
.
IsEmpty
(
)
)
;
std
:
:
pop_heap
(
mTimers
.
begin
(
)
mTimers
.
end
(
)
Entry
:
:
UniquePtrLessThan
)
;
mTimers
.
RemoveElementAt
(
mTimers
.
Length
(
)
-
1
)
;
}
already_AddRefed
<
nsTimerImpl
>
TimerThread
:
:
PostTimerEvent
(
already_AddRefed
<
nsTimerImpl
>
aTimerRef
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
RefPtr
<
nsTimerImpl
>
timer
(
aTimerRef
)
;
if
(
!
timer
-
>
mEventTarget
)
{
NS_ERROR
(
"
Attempt
to
post
timer
event
to
NULL
event
target
"
)
;
return
timer
.
forget
(
)
;
}
RefPtr
<
nsTimerEvent
>
event
=
new
nsTimerEvent
;
if
(
!
event
)
{
return
timer
.
forget
(
)
;
}
if
(
MOZ_LOG_TEST
(
GetTimerLog
(
)
LogLevel
:
:
Debug
)
)
{
event
-
>
mInitTime
=
TimeStamp
:
:
Now
(
)
;
}
#
ifdef
MOZ_TASK_TRACER
AutoSaveCurTraceInfo
saveCurTraceInfo
;
(
timer
-
>
GetTracedTask
(
)
)
.
SetTLSTraceInfo
(
)
;
#
endif
nsCOMPtr
<
nsIEventTarget
>
target
=
timer
-
>
mEventTarget
;
event
-
>
SetTimer
(
timer
.
forget
(
)
)
;
nsresult
rv
;
{
MonitorAutoUnlock
unlock
(
mMonitor
)
;
rv
=
target
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
timer
=
event
-
>
ForgetTimer
(
)
;
RemoveTimerInternal
(
timer
)
;
return
timer
.
forget
(
)
;
}
return
nullptr
;
}
void
TimerThread
:
:
DoBeforeSleep
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mSleeping
=
true
;
}
void
TimerThread
:
:
DoAfterSleep
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mSleeping
=
false
;
mNotified
=
true
;
mMonitor
.
Notify
(
)
;
}
NS_IMETHODIMP
TimerThread
:
:
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
{
if
(
strcmp
(
aTopic
"
sleep_notification
"
)
=
=
0
|
|
strcmp
(
aTopic
"
suspend_process_notification
"
)
=
=
0
)
{
DoBeforeSleep
(
)
;
}
else
if
(
strcmp
(
aTopic
"
wake_notification
"
)
=
=
0
|
|
strcmp
(
aTopic
"
resume_process_notification
"
)
=
=
0
)
{
DoAfterSleep
(
)
;
}
return
NS_OK
;
}
