#
include
"
nsTimerImpl
.
h
"
#
include
"
TimerThread
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPropertyBag2
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
ChaosMode
.
h
"
#
include
"
mozilla
/
ArenaAllocator
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
"
mozilla
/
StaticPrefs_timer
.
h
"
#
include
"
mozilla
/
glean
/
XpcomMetrics
.
h
"
#
include
<
math
.
h
>
using
namespace
mozilla
;
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
class
WindowsTimerFrequencyManager
{
public
:
explicit
WindowsTimerFrequencyManager
(
const
hal
:
:
ProcessPriority
processPriority
)
:
mTimerPeriodEvalInterval
(
TimeDuration
:
:
FromSeconds
(
kTimerPeriodEvalIntervalSec
)
)
mNextTimerPeriodEval
(
TimeStamp
:
:
Now
(
)
+
mTimerPeriodEvalInterval
)
mLastTimePeriodSet
(
ComputeDesiredTimerPeriod
(
processPriority
)
)
mAdjustTimerPeriod
(
StaticPrefs
:
:
timer_auto_increase_timer_resolution
(
)
)
{
if
(
mAdjustTimerPeriod
)
{
timeBeginPeriod
(
mLastTimePeriodSet
)
;
}
}
~
WindowsTimerFrequencyManager
(
)
{
if
(
mAdjustTimerPeriod
)
{
timeEndPeriod
(
mLastTimePeriodSet
)
;
}
}
void
Update
(
const
TimeStamp
now
const
hal
:
:
ProcessPriority
processPriority
)
{
if
(
now
>
=
mNextTimerPeriodEval
)
{
const
UINT
newTimePeriod
=
ComputeDesiredTimerPeriod
(
processPriority
)
;
if
(
newTimePeriod
!
=
mLastTimePeriodSet
)
{
if
(
mAdjustTimerPeriod
)
{
timeEndPeriod
(
mLastTimePeriodSet
)
;
timeBeginPeriod
(
newTimePeriod
)
;
}
mLastTimePeriodSet
=
newTimePeriod
;
}
mNextTimerPeriodEval
=
now
+
mTimerPeriodEvalInterval
;
}
}
private
:
const
TimeDuration
mTimerPeriodEvalInterval
;
TimeStamp
mNextTimerPeriodEval
;
UINT
mLastTimePeriodSet
;
const
bool
mAdjustTimerPeriod
;
static
constexpr
float
kTimerPeriodEvalIntervalSec
=
2
.
0f
;
static
constexpr
UINT
kTimerPeriodHiRes
=
1
;
static
constexpr
UINT
kTimerPeriodLowRes
=
16
;
static
constexpr
UINT
GetDesiredTimerPeriod
(
const
bool
aOnBatteryPower
const
bool
aLowProcessPriority
)
{
const
bool
useLowResTimer
=
aOnBatteryPower
|
|
aLowProcessPriority
;
return
useLowResTimer
?
kTimerPeriodLowRes
:
kTimerPeriodHiRes
;
}
static
constexpr
void
StaticUnitTests
(
)
{
static_assert
(
GetDesiredTimerPeriod
(
true
false
)
=
=
kTimerPeriodLowRes
)
;
static_assert
(
GetDesiredTimerPeriod
(
false
true
)
=
=
kTimerPeriodLowRes
)
;
static_assert
(
GetDesiredTimerPeriod
(
true
true
)
=
=
kTimerPeriodLowRes
)
;
static_assert
(
GetDesiredTimerPeriod
(
false
false
)
=
=
kTimerPeriodHiRes
)
;
}
static
UINT
ComputeDesiredTimerPeriod
(
const
hal
:
:
ProcessPriority
processPriority
)
{
const
bool
lowPriorityProcess
=
processPriority
<
hal
:
:
PROCESS_PRIORITY_FOREGROUND
;
SYSTEM_POWER_STATUS
status
;
const
bool
onBatteryPower
=
!
lowPriorityProcess
&
&
GetSystemPowerStatus
(
&
status
)
&
&
(
status
.
ACLineStatus
=
=
0
)
;
return
GetDesiredTimerPeriod
(
onBatteryPower
lowPriorityProcess
)
;
}
}
;
#
endif
#
ifdef
TIMERS_RUNTIME_STATS
class
StaticTimersStats
{
public
:
explicit
StaticTimersStats
(
const
char
*
aName
)
:
mName
(
aName
)
{
}
~
StaticTimersStats
(
)
{
using
ULL
=
unsigned
long
long
;
ULL
n
=
static_cast
<
ULL
>
(
mCount
)
;
if
(
n
=
=
0
)
{
printf
(
"
[
%
d
]
Timers
stats
%
s
:
(
nothing
)
\
n
"
int
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
mName
)
;
}
else
if
(
ULL
sumNs
=
static_cast
<
ULL
>
(
mSumDurationsNs
)
;
sumNs
=
=
0
)
{
printf
(
"
[
%
d
]
Timers
stats
%
s
:
%
llu
\
n
"
int
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
mName
n
)
;
}
else
{
printf
(
"
[
%
d
]
Timers
stats
%
s
:
%
llu
ns
/
%
llu
=
%
llu
ns
max
%
llu
ns
\
n
"
int
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
mName
sumNs
n
sumNs
/
n
static_cast
<
ULL
>
(
mLongestDurationNs
)
)
;
}
}
void
AddDurationFrom
(
TimeStamp
aStart
)
{
DurationNs
duration
=
static_cast
<
DurationNs
>
(
(
TimeStamp
:
:
Now
(
)
-
aStart
)
.
ToMicroseconds
(
)
*
1000
+
0
.
5
)
;
mSumDurationsNs
+
=
duration
;
+
+
mCount
;
for
(
;
;
)
{
DurationNs
longest
=
mLongestDurationNs
;
if
(
MOZ_LIKELY
(
longest
>
=
duration
)
)
{
break
;
}
if
(
MOZ_LIKELY
(
mLongestDurationNs
.
compareExchange
(
longest
duration
)
)
)
{
break
;
}
}
}
void
AddCount
(
)
{
MOZ_ASSERT
(
mSumDurationsNs
=
=
0
"
Don
'
t
mix
counts
and
durations
"
)
;
+
+
mCount
;
}
private
:
using
DurationNs
=
uint64_t
;
using
Count
=
uint32_t
;
Atomic
<
DurationNs
>
mSumDurationsNs
{
0
}
;
Atomic
<
DurationNs
>
mLongestDurationNs
{
0
}
;
Atomic
<
Count
>
mCount
{
0
}
;
const
char
*
mName
;
}
;
class
MOZ_RAII
AutoTimersStats
{
public
:
explicit
AutoTimersStats
(
StaticTimersStats
&
aStats
)
:
mStats
(
aStats
)
mStart
(
TimeStamp
:
:
Now
(
)
)
{
}
~
AutoTimersStats
(
)
{
mStats
.
AddDurationFrom
(
mStart
)
;
}
private
:
StaticTimersStats
&
mStats
;
TimeStamp
mStart
;
}
;
#
define
AUTO_TIMERS_STATS
(
name
)
\
static
:
:
StaticTimersStats
sStat
#
#
name
(
#
name
)
;
\
:
:
AutoTimersStats
autoStat
#
#
name
(
sStat
#
#
name
)
;
#
define
COUNT_TIMERS_STATS
(
name
)
\
static
:
:
StaticTimersStats
sStat
#
#
name
(
#
name
)
;
\
sStat
#
#
name
.
AddCount
(
)
;
#
else
#
define
AUTO_TIMERS_STATS
(
name
)
#
define
COUNT_TIMERS_STATS
(
name
)
#
endif
NS_IMPL_ISUPPORTS_INHERITED
(
TimerThread
Runnable
nsIObserver
)
TimerThread
:
:
TimerThread
(
)
:
Runnable
(
"
TimerThread
"
)
mInitialized
(
false
)
mMonitor
(
"
TimerThread
.
mMonitor
"
)
mShutdown
(
false
)
mWaiting
(
false
)
mNotified
(
false
)
mSleeping
(
false
)
mAllowedEarlyFiringMicroseconds
(
0
)
{
}
TimerThread
:
:
~
TimerThread
(
)
{
mThread
=
nullptr
;
NS_ASSERTION
(
mTimers
.
IsEmpty
(
)
"
Timers
remain
in
TimerThread
:
:
~
TimerThread
"
)
;
#
if
TIMER_THREAD_STATISTICS
{
MonitorAutoLock
lock
(
mMonitor
)
;
PrintStatistics
(
)
;
}
#
endif
}
namespace
{
class
TimerObserverRunnable
:
public
Runnable
{
public
:
explicit
TimerObserverRunnable
(
nsIObserver
*
aObserver
)
:
mozilla
:
:
Runnable
(
"
TimerObserverRunnable
"
)
mObserver
(
aObserver
)
{
}
NS_DECL_NSIRUNNABLE
private
:
nsCOMPtr
<
nsIObserver
>
mObserver
;
}
;
NS_IMETHODIMP
TimerObserverRunnable
:
:
Run
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
mObserver
"
sleep_notification
"
false
)
;
observerService
-
>
AddObserver
(
mObserver
"
wake_notification
"
false
)
;
observerService
-
>
AddObserver
(
mObserver
"
suspend_process_notification
"
false
)
;
observerService
-
>
AddObserver
(
mObserver
"
resume_process_notification
"
false
)
;
observerService
-
>
AddObserver
(
mObserver
"
ipc
:
process
-
priority
-
changed
"
false
)
;
}
return
NS_OK
;
}
}
namespace
{
class
TimerEventAllocator
{
private
:
struct
FreeEntry
{
FreeEntry
*
mNext
;
}
;
ArenaAllocator
<
4096
>
mPool
MOZ_GUARDED_BY
(
mMonitor
)
;
FreeEntry
*
mFirstFree
MOZ_GUARDED_BY
(
mMonitor
)
;
mozilla
:
:
Monitor
mMonitor
;
public
:
TimerEventAllocator
(
)
:
mFirstFree
(
nullptr
)
mMonitor
(
"
TimerEventAllocator
"
)
{
}
~
TimerEventAllocator
(
)
=
default
;
void
*
Alloc
(
size_t
aSize
)
;
void
Free
(
void
*
aPtr
)
;
}
;
}
class
nsTimerEvent
final
:
public
CancelableRunnable
{
public
:
NS_IMETHOD
Run
(
)
override
;
nsresult
Cancel
(
)
override
{
mTimer
-
>
Cancel
(
)
;
return
NS_OK
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
;
#
endif
explicit
nsTimerEvent
(
already_AddRefed
<
nsTimerImpl
>
aTimer
uint64_t
aTimerSeq
ProfilerThreadId
aTimerThreadId
)
:
mozilla
:
:
CancelableRunnable
(
"
nsTimerEvent
"
)
mTimer
(
aTimer
)
mTimerSeq
(
aTimerSeq
)
mTimerThreadId
(
aTimerThreadId
)
{
AddAllocatorRef
(
)
;
if
(
MOZ_LOG_TEST
(
GetTimerLog
(
)
LogLevel
:
:
Debug
)
|
|
profiler_thread_is_being_profiled_for_markers
(
mTimerThreadId
)
)
{
mInitTime
=
TimeStamp
:
:
Now
(
)
;
}
}
static
void
Init
(
)
;
static
void
Shutdown
(
)
;
static
void
*
operator
new
(
size_t
aSize
)
noexcept
(
true
)
{
return
sAllocator
-
>
Alloc
(
aSize
)
;
}
void
operator
delete
(
void
*
aPtr
)
{
sAllocator
-
>
Free
(
aPtr
)
;
ReleaseAllocatorRef
(
)
;
}
already_AddRefed
<
nsTimerImpl
>
ForgetTimer
(
)
{
return
mTimer
.
forget
(
)
;
}
private
:
nsTimerEvent
(
const
nsTimerEvent
&
)
=
delete
;
nsTimerEvent
&
operator
=
(
const
nsTimerEvent
&
)
=
delete
;
nsTimerEvent
&
operator
=
(
const
nsTimerEvent
&
&
)
=
delete
;
~
nsTimerEvent
(
)
=
default
;
static
void
AddAllocatorRef
(
)
{
+
+
sAllocatorRefs
;
}
static
void
ReleaseAllocatorRef
(
)
{
nsrefcnt
count
=
-
-
sAllocatorRefs
;
if
(
count
=
=
0
)
{
delete
sAllocator
;
sAllocator
=
nullptr
;
}
}
TimeStamp
mInitTime
;
RefPtr
<
nsTimerImpl
>
mTimer
;
const
uint64_t
mTimerSeq
;
ProfilerThreadId
mTimerThreadId
;
static
TimerEventAllocator
*
sAllocator
;
static
ThreadSafeAutoRefCnt
sAllocatorRefs
;
}
;
TimerEventAllocator
*
nsTimerEvent
:
:
sAllocator
=
nullptr
;
ThreadSafeAutoRefCnt
nsTimerEvent
:
:
sAllocatorRefs
;
namespace
{
void
*
TimerEventAllocator
:
:
Alloc
(
size_t
aSize
)
{
MOZ_ASSERT
(
aSize
=
=
sizeof
(
nsTimerEvent
)
)
;
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
void
*
p
;
if
(
mFirstFree
)
{
p
=
mFirstFree
;
mFirstFree
=
mFirstFree
-
>
mNext
;
}
else
{
p
=
mPool
.
Allocate
(
aSize
fallible
)
;
}
return
p
;
}
void
TimerEventAllocator
:
:
Free
(
void
*
aPtr
)
{
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
FreeEntry
*
entry
=
reinterpret_cast
<
FreeEntry
*
>
(
aPtr
)
;
entry
-
>
mNext
=
mFirstFree
;
mFirstFree
=
entry
;
}
}
struct
TimerMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
Timer
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
uint32_t
aDelay
uint8_t
aType
MarkerThreadId
aThreadId
bool
aCanceled
)
{
aWriter
.
IntProperty
(
"
delay
"
aDelay
)
;
if
(
!
aThreadId
.
IsUnspecified
(
)
)
{
aWriter
.
IntProperty
(
"
threadId
"
static_cast
<
int64_t
>
(
aThreadId
.
ThreadId
(
)
.
ToNumber
(
)
)
)
;
}
if
(
aCanceled
)
{
aWriter
.
BoolProperty
(
"
canceled
"
true
)
;
aWriter
.
StringProperty
(
"
prefix
"
"
"
)
;
}
if
(
aType
!
=
nsITimer
:
:
TYPE_ONE_SHOT
)
{
if
(
aType
=
=
nsITimer
:
:
TYPE_REPEATING_SLACK
)
{
aWriter
.
StringProperty
(
"
ttype
"
"
repeating
slack
"
)
;
}
else
if
(
aType
=
=
nsITimer
:
:
TYPE_REPEATING_PRECISE
)
{
aWriter
.
StringProperty
(
"
ttype
"
"
repeating
precise
"
)
;
}
else
if
(
aType
=
=
nsITimer
:
:
TYPE_REPEATING_PRECISE_CAN_SKIP
)
{
aWriter
.
StringProperty
(
"
ttype
"
"
repeating
precise
can
skip
"
)
;
}
else
if
(
aType
=
=
nsITimer
:
:
TYPE_REPEATING_SLACK_LOW_PRIORITY
)
{
aWriter
.
StringProperty
(
"
ttype
"
"
repeating
slack
low
priority
"
)
;
}
else
if
(
aType
=
=
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
)
{
aWriter
.
StringProperty
(
"
ttype
"
"
low
priority
"
)
;
}
}
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyLabelFormat
(
"
delay
"
"
Delay
"
MS
:
:
Format
:
:
Milliseconds
)
;
schema
.
AddKeyLabelFormat
(
"
ttype
"
"
Timer
Type
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddKeyLabelFormat
(
"
canceled
"
"
Canceled
"
MS
:
:
Format
:
:
String
)
;
schema
.
SetChartLabel
(
"
{
marker
.
data
.
prefix
}
{
marker
.
data
.
delay
}
"
)
;
schema
.
SetTableLabel
(
"
{
marker
.
data
.
prefix
}
{
marker
.
data
.
delay
}
"
)
;
return
schema
;
}
}
;
struct
AddRemoveTimerMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
AddRemoveTimer
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
ProfilerString8View
&
aTimerName
uint32_t
aDelay
MarkerThreadId
aThreadId
)
{
aWriter
.
StringProperty
(
"
name
"
aTimerName
)
;
aWriter
.
IntProperty
(
"
delay
"
aDelay
)
;
if
(
!
aThreadId
.
IsUnspecified
(
)
)
{
aWriter
.
IntProperty
(
"
threadId
"
static_cast
<
int64_t
>
(
aThreadId
.
ThreadId
(
)
.
ToNumber
(
)
)
)
;
}
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyLabelFormat
(
"
name
"
"
Name
"
MS
:
:
Format
:
:
String
MS
:
:
PayloadFlags
:
:
Searchable
)
;
schema
.
AddKeyLabelFormat
(
"
delay
"
"
Delay
"
MS
:
:
Format
:
:
Milliseconds
)
;
schema
.
SetTableLabel
(
"
{
marker
.
data
.
name
}
-
{
marker
.
data
.
delay
}
"
)
;
return
schema
;
}
}
;
void
nsTimerEvent
:
:
Init
(
)
{
sAllocator
=
new
TimerEventAllocator
(
)
;
AddAllocatorRef
(
)
;
}
void
nsTimerEvent
:
:
Shutdown
(
)
{
ReleaseAllocatorRef
(
)
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
NS_IMETHODIMP
nsTimerEvent
:
:
GetName
(
nsACString
&
aName
)
{
bool
current
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
mTimer
-
>
mEventTarget
-
>
IsOnCurrentThread
(
&
current
)
)
&
&
current
)
;
mTimer
-
>
GetName
(
aName
)
;
return
NS_OK
;
}
#
endif
NS_IMETHODIMP
nsTimerEvent
:
:
Run
(
)
{
if
(
MOZ_LOG_TEST
(
GetTimerLog
(
)
LogLevel
:
:
Debug
)
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
[
this
=
%
p
]
time
between
PostTimerEvent
(
)
and
Fire
(
)
:
%
fms
\
n
"
this
(
now
-
mInitTime
)
.
ToMilliseconds
(
)
)
)
;
}
if
(
profiler_thread_is_being_profiled_for_markers
(
mTimerThreadId
)
)
{
MutexAutoLock
lock
(
mTimer
-
>
mMutex
)
;
profiler_add_marker
(
mTimer
-
>
mName
geckoprofiler
:
:
category
:
:
TIMER
MarkerOptions
(
MOZ_LIKELY
(
mInitTime
)
?
MarkerTiming
:
:
Interval
(
mTimer
-
>
mTimeout
-
mTimer
-
>
mDelay
mInitTime
)
:
MarkerTiming
:
:
IntervalUntilNowFrom
(
mTimer
-
>
mTimeout
-
mTimer
-
>
mDelay
)
MarkerThreadId
(
mTimerThreadId
)
)
TimerMarker
{
}
mTimer
-
>
mDelay
.
ToMilliseconds
(
)
mTimer
-
>
mType
MarkerThreadId
:
:
CurrentThread
(
)
false
)
;
profiler_add_marker
(
"
PostTimerEvent
"
geckoprofiler
:
:
category
:
:
OTHER
MarkerOptions
(
MOZ_LIKELY
(
mInitTime
)
?
MarkerTiming
:
:
IntervalUntilNowFrom
(
mInitTime
)
:
MarkerTiming
:
:
InstantNow
(
)
MarkerThreadId
(
mTimerThreadId
)
)
AddRemoveTimerMarker
{
}
mTimer
-
>
mName
mTimer
-
>
mDelay
.
ToMilliseconds
(
)
MarkerThreadId
:
:
CurrentThread
(
)
)
;
}
mTimer
-
>
Fire
(
mTimerSeq
)
;
return
NS_OK
;
}
nsresult
TimerThread
:
:
Init
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
TimerThread
:
:
Init
[
%
d
]
\
n
"
mInitialized
)
)
;
if
(
!
mInitialized
)
{
nsTimerEvent
:
:
Init
(
)
;
nsresult
rv
=
NS_NewNamedThread
(
"
Timer
"
getter_AddRefs
(
mThread
)
this
{
.
stackSize
=
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
.
blockDispatch
=
true
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
mThread
=
nullptr
;
}
else
{
RefPtr
<
TimerObserverRunnable
>
r
=
new
TimerObserverRunnable
(
this
)
;
if
(
NS_IsMainThread
(
)
)
{
r
-
>
Run
(
)
;
}
else
{
NS_DispatchToMainThread
(
r
)
;
}
}
mInitialized
=
true
;
}
if
(
!
mThread
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
TimerThread
:
:
Shutdown
(
)
{
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
TimerThread
:
:
Shutdown
begin
\
n
"
)
)
;
if
(
!
mThread
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsTArray
<
Entry
>
timers
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
mShutdown
=
true
;
if
(
mWaiting
)
{
mNotified
=
true
;
mMonitor
.
Notify
(
)
;
}
timers
=
std
:
:
move
(
mTimers
)
;
MOZ_ASSERT
(
mTimers
.
IsEmpty
(
)
)
;
for
(
auto
&
entry
:
timers
)
{
if
(
entry
.
mTimerImpl
)
{
entry
.
mTimerImpl
-
>
SetIsInTimerThread
(
false
)
;
}
}
}
for
(
const
auto
&
entry
:
timers
)
{
if
(
entry
.
mTimerImpl
)
{
entry
.
mTimerImpl
-
>
Cancel
(
)
;
}
}
mThread
-
>
Shutdown
(
)
;
nsTimerEvent
:
:
Shutdown
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
TimerThread
:
:
Shutdown
end
\
n
"
)
)
;
return
NS_OK
;
}
namespace
{
struct
MicrosecondsToInterval
{
PRIntervalTime
operator
[
]
(
size_t
aMs
)
const
{
return
PR_MicrosecondsToInterval
(
aMs
)
;
}
}
;
struct
IntervalComparator
{
int
operator
(
)
(
PRIntervalTime
aInterval
)
const
{
return
(
0
<
aInterval
)
?
-
1
:
1
;
}
}
;
}
TimeStamp
TimerThread
:
:
ComputeWakeupTimeFromTimers
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
mTimers
.
IsEmpty
(
)
)
{
return
TimeStamp
{
}
;
}
MOZ_ASSERT
(
mTimers
[
0
]
.
mTimerImpl
)
;
TimeStamp
bundleWakeup
=
mTimers
[
0
]
.
mTimeout
;
const
TimeDuration
minTimerDelay
=
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
timer_minimum_firing_delay_tolerance_ms
(
)
)
;
const
TimeDuration
maxTimerDelay
=
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
timer_maximum_firing_delay_tolerance_ms
(
)
)
;
TimeStamp
cutoffTime
=
bundleWakeup
+
ComputeAcceptableFiringDelay
(
mTimers
[
0
]
.
mDelay
minTimerDelay
maxTimerDelay
)
;
const
size_t
timerCount
=
mTimers
.
Length
(
)
;
for
(
size_t
entryIndex
=
1
;
entryIndex
<
timerCount
;
+
+
entryIndex
)
{
const
Entry
&
curEntry
=
mTimers
[
entryIndex
]
;
const
nsTimerImpl
*
curTimer
=
curEntry
.
mTimerImpl
;
if
(
!
curTimer
)
{
continue
;
}
const
TimeStamp
curTimerDue
=
curEntry
.
mTimeout
;
if
(
curTimerDue
>
cutoffTime
)
{
break
;
}
bundleWakeup
=
curTimerDue
;
cutoffTime
=
std
:
:
min
(
curTimerDue
+
ComputeAcceptableFiringDelay
(
curEntry
.
mDelay
minTimerDelay
maxTimerDelay
)
cutoffTime
)
;
MOZ_ASSERT
(
bundleWakeup
<
=
cutoffTime
)
;
}
#
if
!
defined
(
XP_WIN
)
MOZ_ASSERT
(
bundleWakeup
-
mTimers
[
0
]
.
mTimeout
<
=
ComputeAcceptableFiringDelay
(
mTimers
[
0
]
.
mDelay
minTimerDelay
maxTimerDelay
)
)
;
#
endif
return
bundleWakeup
;
}
TimeDuration
TimerThread
:
:
ComputeAcceptableFiringDelay
(
TimeDuration
timerDuration
TimeDuration
minDelay
TimeDuration
maxDelay
)
const
{
constexpr
int64_t
timerDurationDivider
=
8
;
static_assert
(
IsPowerOfTwo
(
static_cast
<
uint64_t
>
(
timerDurationDivider
)
)
)
;
const
TimeDuration
tmp
=
timerDuration
/
timerDurationDivider
;
return
std
:
:
clamp
(
tmp
minDelay
maxDelay
)
;
}
uint64_t
TimerThread
:
:
FireDueTimers
(
TimeDuration
aAllowedEarlyFiring
)
{
RemoveLeadingCanceledTimersInternal
(
)
;
uint64_t
timersFired
=
0
;
TimeStamp
lastNow
=
TimeStamp
:
:
Now
(
)
;
while
(
!
mTimers
.
IsEmpty
(
)
)
{
Entry
&
frontEntry
=
mTimers
[
0
]
;
MOZ_ASSERT
(
frontEntry
.
IsTimerInThreadAndUnchanged
(
)
)
;
if
(
lastNow
+
aAllowedEarlyFiring
<
frontEntry
.
mTimeout
)
{
lastNow
=
TimeStamp
:
:
Now
(
)
;
if
(
lastNow
+
aAllowedEarlyFiring
<
frontEntry
.
mTimeout
)
{
break
;
}
}
{
+
+
timersFired
;
LogTimerEvent
:
:
Run
run
(
frontEntry
.
mTimerImpl
.
get
(
)
)
;
PostTimerEvent
(
frontEntry
)
;
}
if
(
mShutdown
)
{
break
;
}
RemoveLeadingCanceledTimersInternal
(
)
;
}
return
timersFired
;
}
class
TelemetryQueue
{
public
:
TelemetryQueue
(
)
{
mQueuedTimersFiredPerWakeup
.
SetLengthAndRetainStorage
(
kMaxQueuedTimersFired
)
;
}
~
TelemetryQueue
(
)
{
if
(
mQueuedTimersFiredCount
!
=
0
)
{
mQueuedTimersFiredPerWakeup
.
SetLengthAndRetainStorage
(
mQueuedTimersFiredCount
)
;
glean
:
:
timer_thread
:
:
timers_fired_per_wakeup
.
AccumulateSamples
(
mQueuedTimersFiredPerWakeup
)
;
}
}
void
AccumulateAndMaybeSendTelemetry
(
uint64_t
timersFiredThisWakeup
)
{
mQueuedTimersFiredPerWakeup
[
mQueuedTimersFiredCount
]
=
timersFiredThisWakeup
;
+
+
mQueuedTimersFiredCount
;
if
(
mQueuedTimersFiredCount
=
=
kMaxQueuedTimersFired
)
{
glean
:
:
timer_thread
:
:
timers_fired_per_wakeup
.
AccumulateSamples
(
mQueuedTimersFiredPerWakeup
)
;
mQueuedTimersFiredCount
=
0
;
}
}
private
:
static
constexpr
size_t
kMaxQueuedTimersFired
=
128
;
AutoTArray
<
uint64_t
kMaxQueuedTimersFired
>
mQueuedTimersFiredPerWakeup
;
size_t
mQueuedTimersFiredCount
=
0
;
}
;
void
TimerThread
:
:
Wait
(
TimeDuration
aWaitFor
)
MOZ_REQUIRES
(
mMonitor
)
{
mWaiting
=
true
;
mNotified
=
false
;
{
AUTO_PROFILER_TRACING_MARKER
(
"
TimerThread
"
"
Wait
"
OTHER
)
;
mMonitor
.
Wait
(
aWaitFor
)
;
}
mWaiting
=
false
;
}
NS_IMETHODIMP
TimerThread
:
:
Run
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mProfilerThreadId
=
profiler_current_thread_id
(
)
;
mAllowedEarlyFiringMicroseconds
=
250
;
const
TimeDuration
normalAllowedEarlyFiring
=
TimeDuration
:
:
FromMicroseconds
(
mAllowedEarlyFiringMicroseconds
)
;
TelemetryQueue
telemetryQueue
;
#
ifdef
XP_WIN
WindowsTimerFrequencyManager
wTFM
{
mCachedPriority
.
load
(
std
:
:
memory_order_relaxed
)
}
;
#
endif
while
(
!
mShutdown
)
{
const
bool
chaosModeActive
=
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
TimerScheduling
)
;
TimeDuration
waitFor
;
if
(
!
mSleeping
)
{
const
TimeDuration
allowedEarlyFiring
=
!
chaosModeActive
?
normalAllowedEarlyFiring
:
TimeDuration
:
:
FromMicroseconds
(
ChaosMode
:
:
randomUint32LessThan
(
4
*
mAllowedEarlyFiringMicroseconds
)
)
;
const
TimeDuration
chaosWaitDelay
=
!
chaosModeActive
?
TimeDuration
:
:
Zero
(
)
:
TimeDuration
:
:
FromMicroseconds
(
ChaosMode
:
:
randomInt32InRange
(
-
10000
10000
)
)
;
const
uint64_t
timersFiredThisWakeup
=
FireDueTimers
(
allowedEarlyFiring
)
;
if
(
mShutdown
)
{
break
;
}
const
TimeStamp
wakeupTime
=
ComputeWakeupTimeFromTimers
(
)
;
mIntendedWakeupTime
=
wakeupTime
;
telemetryQueue
.
AccumulateAndMaybeSendTelemetry
(
timersFiredThisWakeup
)
;
#
if
TIMER_THREAD_STATISTICS
CollectTimersFiredStatistics
(
timersFiredThisWakeup
)
;
#
endif
const
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
waitFor
=
!
wakeupTime
.
IsNull
(
)
?
std
:
:
max
(
TimeDuration
:
:
Zero
(
)
wakeupTime
+
chaosWaitDelay
-
now
)
:
TimeDuration
:
:
Forever
(
)
;
if
(
MOZ_LOG_TEST
(
GetTimerLog
(
)
LogLevel
:
:
Debug
)
)
{
if
(
waitFor
=
=
TimeDuration
:
:
Forever
(
)
)
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
waiting
forever
\
n
"
)
)
;
else
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
waiting
for
%
f
\
n
"
waitFor
.
ToMilliseconds
(
)
)
)
;
}
#
ifdef
XP_WIN
wTFM
.
Update
(
now
mCachedPriority
.
load
(
std
:
:
memory_order_relaxed
)
)
;
#
endif
}
else
{
mIntendedWakeupTime
=
TimeStamp
{
}
;
uint32_t
milliseconds
=
100
;
if
(
chaosModeActive
)
{
milliseconds
=
ChaosMode
:
:
randomUint32LessThan
(
200
)
;
}
waitFor
=
TimeDuration
:
:
FromMilliseconds
(
milliseconds
)
;
}
Wait
(
waitFor
)
;
#
if
TIMER_THREAD_STATISTICS
CollectWakeupStatistics
(
)
;
#
endif
}
return
NS_OK
;
}
nsresult
TimerThread
:
:
AddTimer
(
nsTimerImpl
*
aTimer
const
MutexAutoLock
&
aProofOfLock
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
AUTO_TIMERS_STATS
(
TimerThread_AddTimer
)
;
if
(
mShutdown
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
aTimer
-
>
mEventTarget
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
const
TimeDuration
minTimerDelay
=
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
timer_minimum_firing_delay_tolerance_ms
(
)
)
;
const
TimeDuration
maxTimerDelay
=
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
timer_maximum_firing_delay_tolerance_ms
(
)
)
;
const
TimeDuration
firingDelay
=
ComputeAcceptableFiringDelay
(
aTimer
-
>
mDelay
minTimerDelay
maxTimerDelay
)
;
const
bool
firingBeforeNextWakeup
=
mIntendedWakeupTime
.
IsNull
(
)
|
|
(
aTimer
-
>
mTimeout
+
firingDelay
<
mIntendedWakeupTime
)
;
const
bool
wakeUpTimerThread
=
mWaiting
&
&
(
firingBeforeNextWakeup
|
|
aTimer
-
>
mDelay
.
IsZero
(
)
)
;
#
if
TIMER_THREAD_STATISTICS
if
(
mTotalTimersAdded
=
=
0
)
{
mFirstTimerAdded
=
TimeStamp
:
:
Now
(
)
;
}
+
+
mTotalTimersAdded
;
#
endif
MOZ_ASSERT
(
!
aTimer
-
>
IsInTimerThread
(
)
)
;
AddTimerInternal
(
*
aTimer
)
;
aTimer
-
>
SetIsInTimerThread
(
true
)
;
if
(
wakeUpTimerThread
)
{
mNotified
=
true
;
mMonitor
.
Notify
(
)
;
}
if
(
profiler_thread_is_being_profiled_for_markers
(
mProfilerThreadId
)
)
{
nsLiteralCString
prefix
(
"
Anonymous_
"
)
;
profiler_add_marker
(
"
AddTimer
"
geckoprofiler
:
:
category
:
:
OTHER
MarkerOptions
(
MarkerThreadId
(
mProfilerThreadId
)
MarkerStack
:
:
MaybeCapture
(
aTimer
-
>
mName
.
Equals
(
"
nonfunction
:
JS
"
)
|
|
StringHead
(
aTimer
-
>
mName
prefix
.
Length
(
)
)
=
=
prefix
)
)
AddRemoveTimerMarker
{
}
aTimer
-
>
mName
aTimer
-
>
mDelay
.
ToMilliseconds
(
)
MarkerThreadId
:
:
CurrentThread
(
)
)
;
}
return
NS_OK
;
}
nsresult
TimerThread
:
:
RemoveTimer
(
nsTimerImpl
*
aTimer
const
MutexAutoLock
&
aProofOfLock
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
AUTO_TIMERS_STATS
(
TimerThread_RemoveTimer
)
;
bool
wasInThread
=
RemoveTimerInternal
(
*
aTimer
)
;
if
(
!
wasInThread
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
aTimer
-
>
SetIsInTimerThread
(
false
)
;
#
if
TIMER_THREAD_STATISTICS
+
+
mTotalTimersRemoved
;
#
endif
if
(
profiler_thread_is_being_profiled_for_markers
(
mProfilerThreadId
)
)
{
nsLiteralCString
prefix
(
"
Anonymous_
"
)
;
profiler_add_marker
(
"
RemoveTimer
"
geckoprofiler
:
:
category
:
:
OTHER
MarkerOptions
(
MarkerThreadId
(
mProfilerThreadId
)
MarkerStack
:
:
MaybeCapture
(
aTimer
-
>
mName
.
Equals
(
"
nonfunction
:
JS
"
)
|
|
StringHead
(
aTimer
-
>
mName
prefix
.
Length
(
)
)
=
=
prefix
)
)
AddRemoveTimerMarker
{
}
aTimer
-
>
mName
aTimer
-
>
mDelay
.
ToMilliseconds
(
)
MarkerThreadId
:
:
CurrentThread
(
)
)
;
profiler_add_marker
(
aTimer
-
>
mName
geckoprofiler
:
:
category
:
:
TIMER
MarkerOptions
(
MarkerTiming
:
:
IntervalUntilNowFrom
(
aTimer
-
>
mTimeout
-
aTimer
-
>
mDelay
)
MarkerThreadId
(
mProfilerThreadId
)
)
TimerMarker
{
}
aTimer
-
>
mDelay
.
ToMilliseconds
(
)
aTimer
-
>
mType
MarkerThreadId
:
:
CurrentThread
(
)
true
)
;
}
return
NS_OK
;
}
TimeStamp
TimerThread
:
:
FindNextFireTimeForCurrentThread
(
TimeStamp
aDefault
uint32_t
aSearchBound
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
AUTO_TIMERS_STATS
(
TimerThread_FindNextFireTimeForCurrentThread
)
;
for
(
const
Entry
&
entry
:
mTimers
)
{
const
nsTimerImpl
*
timer
=
entry
.
mTimerImpl
;
if
(
timer
)
{
if
(
entry
.
mTimeout
>
aDefault
)
{
return
aDefault
;
}
if
(
!
timer
-
>
IsLowPriority
(
)
)
{
bool
isOnCurrentThread
=
false
;
nsresult
rv
=
timer
-
>
mEventTarget
-
>
IsOnCurrentThread
(
&
isOnCurrentThread
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isOnCurrentThread
)
{
return
entry
.
mTimeout
;
}
}
if
(
aSearchBound
=
=
0
)
{
TimeStamp
fallbackDeadline
=
TimeStamp
:
:
Now
(
)
+
TimeDuration
:
:
FromMilliseconds
(
16
)
;
return
fallbackDeadline
<
aDefault
?
fallbackDeadline
:
aDefault
;
}
-
-
aSearchBound
;
}
}
return
aDefault
;
}
void
TimerThread
:
:
AssertTimersSortedAndUnique
(
)
{
MOZ_ASSERT
(
std
:
:
is_sorted
(
mTimers
.
begin
(
)
mTimers
.
end
(
)
)
"
mTimers
must
be
sorted
.
"
)
;
MOZ_ASSERT
(
std
:
:
adjacent_find
(
mTimers
.
begin
(
)
mTimers
.
end
(
)
)
=
=
mTimers
.
end
(
)
"
mTimers
must
not
contain
duplicate
entries
.
"
)
;
}
void
TimerThread
:
:
AddTimerInternal
(
nsTimerImpl
&
aTimer
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
aTimer
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal
)
;
LogTimerEvent
:
:
LogDispatch
(
&
aTimer
)
;
Entry
toBeAdded
{
aTimer
}
;
size_t
insertAt
=
mTimers
.
IndexOfFirstElementGt
(
toBeAdded
)
;
if
(
insertAt
>
0
&
&
!
mTimers
[
insertAt
-
1
]
.
mTimerImpl
)
{
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal_ReuseBefore
)
;
mTimers
[
insertAt
-
1
]
=
std
:
:
move
(
toBeAdded
)
;
AssertTimersSortedAndUnique
(
)
;
return
;
}
bool
usedEmptySlot
=
false
;
if
(
insertAt
<
mTimers
.
Length
(
)
)
{
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal_ShiftAndFindEmptySlot
)
;
Span
<
Entry
>
tail
=
Span
{
mTimers
}
.
From
(
insertAt
)
;
for
(
Entry
&
e
:
tail
)
{
if
(
!
e
.
mTimerImpl
)
{
e
=
std
:
:
move
(
toBeAdded
)
;
usedEmptySlot
=
true
;
break
;
}
std
:
:
swap
(
e
toBeAdded
)
;
}
}
if
(
!
usedEmptySlot
)
{
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal_Expand
)
;
mTimers
.
AppendElement
(
std
:
:
move
(
toBeAdded
)
)
;
}
AssertTimersSortedAndUnique
(
)
;
}
bool
TimerThread
:
:
RemoveTimerInternal
(
nsTimerImpl
&
aTimer
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
aTimer
.
mMutex
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_RemoveTimerInternal
)
;
if
(
!
aTimer
.
IsInTimerThread
(
)
)
{
COUNT_TIMERS_STATS
(
TimerThread_RemoveTimerInternal_not_in_list
)
;
return
false
;
}
size_t
removeAt
=
mTimers
.
BinaryIndexOf
(
EntryKey
{
aTimer
}
)
;
if
(
removeAt
!
=
nsTArray
<
Entry
>
:
:
NoIndex
)
{
MOZ_ASSERT
(
mTimers
[
removeAt
]
.
mTimerImpl
=
=
&
aTimer
)
;
mTimers
[
removeAt
]
.
mTimerImpl
=
nullptr
;
AssertTimersSortedAndUnique
(
)
;
return
true
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Not
found
in
the
list
but
it
should
be
!
?
"
)
;
return
false
;
}
void
TimerThread
:
:
RemoveLeadingCanceledTimersInternal
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_RemoveLeadingCanceledTimersInternal
)
;
AssertTimersSortedAndUnique
(
)
;
size_t
toRemove
=
0
;
while
(
toRemove
<
mTimers
.
Length
(
)
&
&
!
mTimers
[
toRemove
]
.
mTimerImpl
)
{
+
+
toRemove
;
}
mTimers
.
RemoveElementsAt
(
0
toRemove
)
;
}
void
TimerThread
:
:
PostTimerEvent
(
Entry
&
aPostMe
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_PostTimerEvent
)
;
RefPtr
<
nsTimerImpl
>
timer
(
std
:
:
move
(
aPostMe
.
mTimerImpl
)
)
;
timer
-
>
SetIsInTimerThread
(
false
)
;
#
if
TIMER_THREAD_STATISTICS
const
double
actualFiringDelay
=
std
:
:
max
(
(
TimeStamp
:
:
Now
(
)
-
timer
-
>
mTimeout
)
.
ToMilliseconds
(
)
0
.
0
)
;
if
(
mNotified
)
{
+
+
mTotalTimersFiredNotified
;
mTotalActualTimerFiringDelayNotified
+
=
actualFiringDelay
;
}
else
{
+
+
mTotalTimersFiredUnnotified
;
mTotalActualTimerFiringDelayUnnotified
+
=
actualFiringDelay
;
}
#
endif
if
(
!
timer
-
>
mEventTarget
)
{
NS_ERROR
(
"
Attempt
to
post
timer
event
to
NULL
event
target
"
)
;
return
;
}
nsCOMPtr
<
nsIEventTarget
>
target
=
timer
-
>
mEventTarget
;
void
*
p
=
nsTimerEvent
:
:
operator
new
(
sizeof
(
nsTimerEvent
)
)
;
if
(
!
p
)
{
return
;
}
RefPtr
<
nsTimerEvent
>
event
=
:
:
new
(
KnownNotNull
p
)
nsTimerEvent
(
timer
.
forget
(
)
aPostMe
.
mTimerSeq
mProfilerThreadId
)
;
{
MonitorAutoUnlock
unlock
(
mMonitor
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
target
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
)
)
)
{
RefPtr
<
nsTimerImpl
>
dropMe
=
event
-
>
ForgetTimer
(
)
;
}
}
}
void
TimerThread
:
:
DoBeforeSleep
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mSleeping
=
true
;
}
void
TimerThread
:
:
DoAfterSleep
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mSleeping
=
false
;
mNotified
=
true
;
PROFILER_MARKER_UNTYPED
(
"
AfterSleep
"
OTHER
MarkerThreadId
(
mProfilerThreadId
)
)
;
mMonitor
.
Notify
(
)
;
}
NS_IMETHODIMP
TimerThread
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
strcmp
(
aTopic
"
ipc
:
process
-
priority
-
changed
"
)
=
=
0
)
{
nsCOMPtr
<
nsIPropertyBag2
>
props
=
do_QueryInterface
(
aSubject
)
;
MOZ_ASSERT
(
props
!
=
nullptr
)
;
int32_t
priority
=
static_cast
<
int32_t
>
(
hal
:
:
PROCESS_PRIORITY_UNKNOWN
)
;
props
-
>
GetPropertyAsInt32
(
u
"
priority
"
_ns
&
priority
)
;
mCachedPriority
.
store
(
static_cast
<
hal
:
:
ProcessPriority
>
(
priority
)
std
:
:
memory_order_relaxed
)
;
}
if
(
StaticPrefs
:
:
timer_ignore_sleep_wake_notifications
(
)
)
{
return
NS_OK
;
}
if
(
strcmp
(
aTopic
"
sleep_notification
"
)
=
=
0
|
|
strcmp
(
aTopic
"
suspend_process_notification
"
)
=
=
0
)
{
DoBeforeSleep
(
)
;
}
else
if
(
strcmp
(
aTopic
"
wake_notification
"
)
=
=
0
|
|
strcmp
(
aTopic
"
resume_process_notification
"
)
=
=
0
)
{
DoAfterSleep
(
)
;
}
return
NS_OK
;
}
uint32_t
TimerThread
:
:
AllowedEarlyFiringMicroseconds
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
mAllowedEarlyFiringMicroseconds
;
}
#
if
TIMER_THREAD_STATISTICS
void
TimerThread
:
:
CollectTimersFiredStatistics
(
uint64_t
timersFiredThisWakeup
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
size_t
bucketIndex
=
0
;
while
(
bucketIndex
<
sTimersFiredPerWakeupBucketCount
-
1
&
&
timersFiredThisWakeup
>
sTimersFiredPerWakeupThresholds
[
bucketIndex
]
)
{
+
+
bucketIndex
;
}
MOZ_ASSERT
(
bucketIndex
<
sTimersFiredPerWakeupBucketCount
)
;
+
+
mTimersFiredPerWakeup
[
bucketIndex
]
;
+
+
mTotalWakeupCount
;
if
(
mNotified
)
{
+
+
mTimersFiredPerNotifiedWakeup
[
bucketIndex
]
;
+
+
mTotalNotifiedWakeupCount
;
}
else
{
+
+
mTimersFiredPerUnnotifiedWakeup
[
bucketIndex
]
;
+
+
mTotalUnnotifiedWakeupCount
;
}
}
void
TimerThread
:
:
CollectWakeupStatistics
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
const
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
!
mNotified
&
&
!
mIntendedWakeupTime
.
IsNull
(
)
&
&
now
<
mIntendedWakeupTime
)
{
+
+
mEarlyWakeups
;
const
double
earlinessms
=
(
mIntendedWakeupTime
-
now
)
.
ToMilliseconds
(
)
;
mTotalEarlyWakeupTime
+
=
earlinessms
;
}
}
void
TimerThread
:
:
PrintStatistics
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
const
TimeStamp
freshNow
=
TimeStamp
:
:
Now
(
)
;
const
double
timeElapsed
=
mFirstTimerAdded
.
IsNull
(
)
?
0
.
0
:
(
freshNow
-
mFirstTimerAdded
)
.
ToSeconds
(
)
;
printf_stderr
(
"
TimerThread
Stats
(
Total
time
%
8
.
2fs
)
\
n
"
timeElapsed
)
;
printf_stderr
(
"
Added
:
%
6llu
Removed
:
%
6llu
Fired
:
%
6llu
\
n
"
mTotalTimersAdded
mTotalTimersRemoved
mTotalTimersFiredNotified
+
mTotalTimersFiredUnnotified
)
;
auto
PrintTimersFiredBucket
=
[
]
(
const
AutoTArray
<
size_t
sTimersFiredPerWakeupBucketCount
>
&
buckets
const
size_t
wakeupCount
const
size_t
timersFiredCount
const
double
totalTimerDelay
const
char
*
label
)
{
printf_stderr
(
"
%
s
:
[
"
label
)
;
for
(
size_t
bucketVal
:
buckets
)
{
printf_stderr
(
"
%
5llu
"
bucketVal
)
;
}
printf_stderr
(
"
]
Wake
-
ups
/
timer
%
6llu
/
%
6llu
(
%
7
.
4f
)
Avg
Timer
Delay
%
7
.
4f
\
n
"
wakeupCount
timersFiredCount
static_cast
<
double
>
(
wakeupCount
)
/
timersFiredCount
totalTimerDelay
/
timersFiredCount
)
;
}
;
printf_stderr
(
"
Wake
-
ups
:
\
n
"
)
;
PrintTimersFiredBucket
(
mTimersFiredPerWakeup
mTotalWakeupCount
mTotalTimersFiredNotified
+
mTotalTimersFiredUnnotified
mTotalActualTimerFiringDelayNotified
+
mTotalActualTimerFiringDelayUnnotified
"
Total
"
)
;
PrintTimersFiredBucket
(
mTimersFiredPerNotifiedWakeup
mTotalNotifiedWakeupCount
mTotalTimersFiredNotified
mTotalActualTimerFiringDelayNotified
"
Notified
"
)
;
PrintTimersFiredBucket
(
mTimersFiredPerUnnotifiedWakeup
mTotalUnnotifiedWakeupCount
mTotalTimersFiredUnnotified
mTotalActualTimerFiringDelayUnnotified
"
Unnotified
"
)
;
printf_stderr
(
"
Early
Wake
-
ups
:
%
6llu
Avg
:
%
7
.
4fms
\
n
"
mEarlyWakeups
mTotalEarlyWakeupTime
/
mEarlyWakeups
)
;
}
#
endif
class
nsReadOnlyTimer
final
:
public
nsITimer
{
public
:
explicit
nsReadOnlyTimer
(
const
nsACString
&
aName
uint32_t
aDelay
uint32_t
aType
)
:
mName
(
aName
)
mDelay
(
aDelay
)
mType
(
aType
)
{
}
NS_DECL_ISUPPORTS
NS_IMETHOD
Init
(
nsIObserver
*
aObserver
uint32_t
aDelayInMs
uint32_t
aType
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
InitWithCallback
(
nsITimerCallback
*
aCallback
uint32_t
aDelayInMs
uint32_t
aType
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
InitHighResolutionWithCallback
(
nsITimerCallback
*
aCallback
const
mozilla
:
:
TimeDuration
&
aDelay
uint32_t
aType
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
Cancel
(
void
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
InitWithNamedFuncCallback
(
nsTimerCallbackFunc
aCallback
void
*
aClosure
uint32_t
aDelay
uint32_t
aType
const
nsACString
&
aName
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
InitHighResolutionWithNamedFuncCallback
(
nsTimerCallbackFunc
aCallback
void
*
aClosure
const
mozilla
:
:
TimeDuration
&
aDelay
uint32_t
aType
const
nsACString
&
aName
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
=
mName
;
return
NS_OK
;
}
NS_IMETHOD
GetDelay
(
uint32_t
*
aDelay
)
override
{
*
aDelay
=
mDelay
;
return
NS_OK
;
}
NS_IMETHOD
SetDelay
(
uint32_t
aDelay
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
GetType
(
uint32_t
*
aType
)
override
{
*
aType
=
mType
;
return
NS_OK
;
}
NS_IMETHOD
SetType
(
uint32_t
aType
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
GetClosure
(
void
*
*
aClosure
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
GetCallback
(
nsITimerCallback
*
*
aCallback
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
GetTarget
(
nsIEventTarget
*
*
aTarget
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
SetTarget
(
nsIEventTarget
*
aTarget
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
GetAllowedEarlyFiringMicroseconds
(
uint32_t
*
aAllowedEarlyFiringMicroseconds
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
override
{
return
sizeof
(
*
this
)
;
}
private
:
nsCString
mName
;
uint32_t
mDelay
;
uint32_t
mType
;
~
nsReadOnlyTimer
(
)
=
default
;
}
;
NS_IMPL_ISUPPORTS
(
nsReadOnlyTimer
nsITimer
)
nsresult
TimerThread
:
:
GetTimers
(
nsTArray
<
RefPtr
<
nsITimer
>
>
&
aRetVal
)
{
nsTArray
<
RefPtr
<
nsTimerImpl
>
>
timers
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
for
(
const
auto
&
entry
:
mTimers
)
{
nsTimerImpl
*
timer
=
entry
.
mTimerImpl
;
if
(
!
timer
)
{
continue
;
}
timers
.
AppendElement
(
timer
)
;
}
}
for
(
nsTimerImpl
*
timer
:
timers
)
{
nsAutoCString
name
;
timer
-
>
GetName
(
name
)
;
uint32_t
delay
;
timer
-
>
GetDelay
(
&
delay
)
;
uint32_t
type
;
timer
-
>
GetType
(
&
type
)
;
aRetVal
.
AppendElement
(
new
nsReadOnlyTimer
(
name
delay
type
)
)
;
}
return
NS_OK
;
}
