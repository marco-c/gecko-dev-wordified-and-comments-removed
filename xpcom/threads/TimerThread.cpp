#
include
"
nsTimerImpl
.
h
"
#
include
"
TimerThread
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
pratom
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
ChaosMode
.
h
"
#
include
"
mozilla
/
ArenaAllocator
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
"
mozilla
/
StaticPrefs_timer
.
h
"
#
include
<
math
.
h
>
using
namespace
mozilla
;
#
ifdef
TIMERS_RUNTIME_STATS
class
StaticTimersStats
{
public
:
explicit
StaticTimersStats
(
const
char
*
aName
)
:
mName
(
aName
)
{
}
~
StaticTimersStats
(
)
{
using
ULL
=
unsigned
long
long
;
ULL
n
=
static_cast
<
ULL
>
(
mCount
)
;
if
(
n
=
=
0
)
{
printf
(
"
[
%
d
]
Timers
stats
%
s
:
(
nothing
)
\
n
"
int
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
mName
)
;
}
else
if
(
ULL
sumNs
=
static_cast
<
ULL
>
(
mSumDurationsNs
)
;
sumNs
=
=
0
)
{
printf
(
"
[
%
d
]
Timers
stats
%
s
:
%
llu
\
n
"
int
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
mName
n
)
;
}
else
{
printf
(
"
[
%
d
]
Timers
stats
%
s
:
%
llu
ns
/
%
llu
=
%
llu
ns
max
%
llu
ns
\
n
"
int
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
mName
sumNs
n
sumNs
/
n
static_cast
<
ULL
>
(
mLongestDurationNs
)
)
;
}
}
void
AddDurationFrom
(
TimeStamp
aStart
)
{
DurationNs
duration
=
static_cast
<
DurationNs
>
(
(
TimeStamp
:
:
Now
(
)
-
aStart
)
.
ToMicroseconds
(
)
*
1000
+
0
.
5
)
;
mSumDurationsNs
+
=
duration
;
+
+
mCount
;
for
(
;
;
)
{
DurationNs
longest
=
mLongestDurationNs
;
if
(
MOZ_LIKELY
(
longest
>
=
duration
)
)
{
break
;
}
if
(
MOZ_LIKELY
(
mLongestDurationNs
.
compareExchange
(
longest
duration
)
)
)
{
break
;
}
}
}
void
AddCount
(
)
{
MOZ_ASSERT
(
mSumDurationsNs
=
=
0
"
Don
'
t
mix
counts
and
durations
"
)
;
+
+
mCount
;
}
private
:
using
DurationNs
=
uint64_t
;
using
Count
=
uint32_t
;
Atomic
<
DurationNs
>
mSumDurationsNs
{
0
}
;
Atomic
<
DurationNs
>
mLongestDurationNs
{
0
}
;
Atomic
<
Count
>
mCount
{
0
}
;
const
char
*
mName
;
}
;
class
MOZ_RAII
AutoTimersStats
{
public
:
explicit
AutoTimersStats
(
StaticTimersStats
&
aStats
)
:
mStats
(
aStats
)
mStart
(
TimeStamp
:
:
Now
(
)
)
{
}
~
AutoTimersStats
(
)
{
mStats
.
AddDurationFrom
(
mStart
)
;
}
private
:
StaticTimersStats
&
mStats
;
TimeStamp
mStart
;
}
;
#
define
AUTO_TIMERS_STATS
(
name
)
\
static
:
:
StaticTimersStats
sStat
#
#
name
(
#
name
)
;
\
:
:
AutoTimersStats
autoStat
#
#
name
(
sStat
#
#
name
)
;
#
define
COUNT_TIMERS_STATS
(
name
)
\
static
:
:
StaticTimersStats
sStat
#
#
name
(
#
name
)
;
\
sStat
#
#
name
.
AddCount
(
)
;
#
else
#
define
AUTO_TIMERS_STATS
(
name
)
#
define
COUNT_TIMERS_STATS
(
name
)
#
endif
NS_IMPL_ISUPPORTS_INHERITED
(
TimerThread
Runnable
nsIObserver
)
TimerThread
:
:
TimerThread
(
)
:
Runnable
(
"
TimerThread
"
)
mInitialized
(
false
)
mMonitor
(
"
TimerThread
.
mMonitor
"
)
mShutdown
(
false
)
mWaiting
(
false
)
mNotified
(
false
)
mSleeping
(
false
)
mAllowedEarlyFiringMicroseconds
(
0
)
{
}
TimerThread
:
:
~
TimerThread
(
)
{
mThread
=
nullptr
;
NS_ASSERTION
(
mTimers
.
IsEmpty
(
)
"
Timers
remain
in
TimerThread
:
:
~
TimerThread
"
)
;
}
namespace
{
class
TimerObserverRunnable
:
public
Runnable
{
public
:
explicit
TimerObserverRunnable
(
nsIObserver
*
aObserver
)
:
mozilla
:
:
Runnable
(
"
TimerObserverRunnable
"
)
mObserver
(
aObserver
)
{
}
NS_DECL_NSIRUNNABLE
private
:
nsCOMPtr
<
nsIObserver
>
mObserver
;
}
;
NS_IMETHODIMP
TimerObserverRunnable
:
:
Run
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
mObserver
"
sleep_notification
"
false
)
;
observerService
-
>
AddObserver
(
mObserver
"
wake_notification
"
false
)
;
observerService
-
>
AddObserver
(
mObserver
"
suspend_process_notification
"
false
)
;
observerService
-
>
AddObserver
(
mObserver
"
resume_process_notification
"
false
)
;
}
return
NS_OK
;
}
}
namespace
{
class
TimerEventAllocator
{
private
:
struct
FreeEntry
{
FreeEntry
*
mNext
;
}
;
ArenaAllocator
<
4096
>
mPool
MOZ_GUARDED_BY
(
mMonitor
)
;
FreeEntry
*
mFirstFree
MOZ_GUARDED_BY
(
mMonitor
)
;
mozilla
:
:
Monitor
mMonitor
;
public
:
TimerEventAllocator
(
)
:
mPool
(
)
mFirstFree
(
nullptr
)
mMonitor
(
"
TimerEventAllocator
"
)
{
}
~
TimerEventAllocator
(
)
=
default
;
void
*
Alloc
(
size_t
aSize
)
;
void
Free
(
void
*
aPtr
)
;
}
;
}
class
nsTimerEvent
final
:
public
CancelableRunnable
{
public
:
NS_IMETHOD
Run
(
)
override
;
nsresult
Cancel
(
)
override
{
mTimer
-
>
Cancel
(
)
;
return
NS_OK
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
;
#
endif
explicit
nsTimerEvent
(
already_AddRefed
<
nsTimerImpl
>
aTimer
ProfilerThreadId
aTimerThreadId
)
:
mozilla
:
:
CancelableRunnable
(
"
nsTimerEvent
"
)
mTimer
(
aTimer
)
mGeneration
(
mTimer
-
>
GetGeneration
(
)
)
mTimerThreadId
(
aTimerThreadId
)
{
sAllocatorUsers
+
+
;
if
(
MOZ_LOG_TEST
(
GetTimerLog
(
)
LogLevel
:
:
Debug
)
|
|
profiler_thread_is_being_profiled_for_markers
(
mTimerThreadId
)
)
{
mInitTime
=
TimeStamp
:
:
Now
(
)
;
}
}
static
void
Init
(
)
;
static
void
Shutdown
(
)
;
static
void
DeleteAllocatorIfNeeded
(
)
;
static
void
*
operator
new
(
size_t
aSize
)
noexcept
(
true
)
{
return
sAllocator
-
>
Alloc
(
aSize
)
;
}
void
operator
delete
(
void
*
aPtr
)
{
sAllocator
-
>
Free
(
aPtr
)
;
sAllocatorUsers
-
-
;
DeleteAllocatorIfNeeded
(
)
;
}
already_AddRefed
<
nsTimerImpl
>
ForgetTimer
(
)
{
return
mTimer
.
forget
(
)
;
}
private
:
nsTimerEvent
(
const
nsTimerEvent
&
)
=
delete
;
nsTimerEvent
&
operator
=
(
const
nsTimerEvent
&
)
=
delete
;
nsTimerEvent
&
operator
=
(
const
nsTimerEvent
&
&
)
=
delete
;
~
nsTimerEvent
(
)
{
MOZ_ASSERT
(
!
sCanDeleteAllocator
|
|
sAllocatorUsers
>
0
"
This
will
result
in
us
attempting
to
deallocate
the
"
"
nsTimerEvent
allocator
twice
"
)
;
}
TimeStamp
mInitTime
;
RefPtr
<
nsTimerImpl
>
mTimer
;
const
int32_t
mGeneration
;
ProfilerThreadId
mTimerThreadId
;
static
TimerEventAllocator
*
sAllocator
;
static
Atomic
<
int32_t
SequentiallyConsistent
>
sAllocatorUsers
;
static
Atomic
<
bool
SequentiallyConsistent
>
sCanDeleteAllocator
;
}
;
TimerEventAllocator
*
nsTimerEvent
:
:
sAllocator
=
nullptr
;
Atomic
<
int32_t
SequentiallyConsistent
>
nsTimerEvent
:
:
sAllocatorUsers
;
Atomic
<
bool
SequentiallyConsistent
>
nsTimerEvent
:
:
sCanDeleteAllocator
;
namespace
{
void
*
TimerEventAllocator
:
:
Alloc
(
size_t
aSize
)
{
MOZ_ASSERT
(
aSize
=
=
sizeof
(
nsTimerEvent
)
)
;
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
void
*
p
;
if
(
mFirstFree
)
{
p
=
mFirstFree
;
mFirstFree
=
mFirstFree
-
>
mNext
;
}
else
{
p
=
mPool
.
Allocate
(
aSize
fallible
)
;
}
return
p
;
}
void
TimerEventAllocator
:
:
Free
(
void
*
aPtr
)
{
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
FreeEntry
*
entry
=
reinterpret_cast
<
FreeEntry
*
>
(
aPtr
)
;
entry
-
>
mNext
=
mFirstFree
;
mFirstFree
=
entry
;
}
}
void
nsTimerEvent
:
:
Init
(
)
{
sAllocator
=
new
TimerEventAllocator
(
)
;
}
void
nsTimerEvent
:
:
Shutdown
(
)
{
sCanDeleteAllocator
=
true
;
DeleteAllocatorIfNeeded
(
)
;
}
void
nsTimerEvent
:
:
DeleteAllocatorIfNeeded
(
)
{
if
(
sCanDeleteAllocator
&
&
sAllocatorUsers
=
=
0
)
{
delete
sAllocator
;
sAllocator
=
nullptr
;
}
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
NS_IMETHODIMP
nsTimerEvent
:
:
GetName
(
nsACString
&
aName
)
{
bool
current
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
mTimer
-
>
mEventTarget
-
>
IsOnCurrentThread
(
&
current
)
)
&
&
current
)
;
mTimer
-
>
GetName
(
aName
)
;
return
NS_OK
;
}
#
endif
NS_IMETHODIMP
nsTimerEvent
:
:
Run
(
)
{
if
(
MOZ_LOG_TEST
(
GetTimerLog
(
)
LogLevel
:
:
Debug
)
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
[
this
=
%
p
]
time
between
PostTimerEvent
(
)
and
Fire
(
)
:
%
fms
\
n
"
this
(
now
-
mInitTime
)
.
ToMilliseconds
(
)
)
)
;
}
if
(
profiler_thread_is_being_profiled_for_markers
(
mTimerThreadId
)
)
{
nsAutoCString
name
;
mTimer
-
>
GetName
(
name
)
;
PROFILER_MARKER_TEXT
(
"
PostTimerEvent
"
OTHER
MarkerOptions
(
MOZ_LIKELY
(
mInitTime
)
?
MarkerTiming
:
:
IntervalUntilNowFrom
(
mInitTime
)
:
MarkerTiming
:
:
InstantNow
(
)
MarkerThreadId
(
mTimerThreadId
)
)
name
)
;
}
mTimer
-
>
Fire
(
mGeneration
)
;
return
NS_OK
;
}
nsresult
TimerThread
:
:
Init
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
TimerThread
:
:
Init
[
%
d
]
\
n
"
mInitialized
)
)
;
if
(
!
mInitialized
)
{
nsTimerEvent
:
:
Init
(
)
;
nsresult
rv
=
NS_NewNamedThread
(
"
Timer
"
getter_AddRefs
(
mThread
)
this
{
.
stackSize
=
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
.
blockDispatch
=
true
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
mThread
=
nullptr
;
}
else
{
RefPtr
<
TimerObserverRunnable
>
r
=
new
TimerObserverRunnable
(
this
)
;
if
(
NS_IsMainThread
(
)
)
{
r
-
>
Run
(
)
;
}
else
{
NS_DispatchToMainThread
(
r
)
;
}
}
mInitialized
=
true
;
}
if
(
!
mThread
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
TimerThread
:
:
Shutdown
(
)
{
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
TimerThread
:
:
Shutdown
begin
\
n
"
)
)
;
if
(
!
mThread
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsTArray
<
RefPtr
<
nsTimerImpl
>
>
timers
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
mShutdown
=
true
;
if
(
mWaiting
)
{
mNotified
=
true
;
mMonitor
.
Notify
(
)
;
}
timers
.
SetCapacity
(
mTimers
.
Length
(
)
)
;
for
(
Entry
&
entry
:
mTimers
)
{
if
(
entry
.
Value
(
)
)
{
timers
.
AppendElement
(
entry
.
Take
(
)
)
;
}
}
mTimers
.
Clear
(
)
;
}
for
(
const
RefPtr
<
nsTimerImpl
>
&
timer
:
timers
)
{
MOZ_ASSERT
(
timer
)
;
timer
-
>
Cancel
(
)
;
}
mThread
-
>
Shutdown
(
)
;
nsTimerEvent
:
:
Shutdown
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
TimerThread
:
:
Shutdown
end
\
n
"
)
)
;
return
NS_OK
;
}
namespace
{
struct
MicrosecondsToInterval
{
PRIntervalTime
operator
[
]
(
size_t
aMs
)
const
{
return
PR_MicrosecondsToInterval
(
aMs
)
;
}
}
;
struct
IntervalComparator
{
int
operator
(
)
(
PRIntervalTime
aInterval
)
const
{
return
(
0
<
aInterval
)
?
-
1
:
1
;
}
}
;
}
#
ifdef
DEBUG
void
TimerThread
:
:
VerifyTimerListConsistency
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
const
size_t
timerCount
=
mTimers
.
Length
(
)
;
size_t
lastNonCanceledTimerIndex
=
0
;
while
(
lastNonCanceledTimerIndex
<
timerCount
&
&
!
mTimers
[
lastNonCanceledTimerIndex
]
.
Value
(
)
)
{
+
+
lastNonCanceledTimerIndex
;
}
MOZ_ASSERT
(
lastNonCanceledTimerIndex
=
=
timerCount
|
|
mTimers
[
lastNonCanceledTimerIndex
]
.
Value
(
)
)
;
MOZ_ASSERT
(
lastNonCanceledTimerIndex
=
=
timerCount
|
|
mTimers
[
lastNonCanceledTimerIndex
]
.
Value
(
)
-
>
mTimeout
=
=
mTimers
[
lastNonCanceledTimerIndex
]
.
Timeout
(
)
)
;
for
(
size_t
timerIndex
=
lastNonCanceledTimerIndex
+
1
;
timerIndex
<
timerCount
;
+
+
timerIndex
)
{
if
(
mTimers
[
timerIndex
]
.
Value
(
)
)
{
MOZ_ASSERT
(
mTimers
[
timerIndex
]
.
Timeout
(
)
=
=
mTimers
[
timerIndex
]
.
Value
(
)
-
>
mTimeout
)
;
MOZ_ASSERT
(
mTimers
[
timerIndex
]
.
Timeout
(
)
>
=
mTimers
[
lastNonCanceledTimerIndex
]
.
Timeout
(
)
)
;
lastNonCanceledTimerIndex
=
timerIndex
;
}
}
}
#
endif
size_t
TimerThread
:
:
ComputeTimerInsertionIndex
(
const
TimeStamp
&
timeout
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
const
size_t
timerCount
=
mTimers
.
Length
(
)
;
size_t
firstGtIndex
=
0
;
while
(
firstGtIndex
<
timerCount
&
&
(
!
mTimers
[
firstGtIndex
]
.
Value
(
)
|
|
mTimers
[
firstGtIndex
]
.
Timeout
(
)
<
=
timeout
)
)
{
+
+
firstGtIndex
;
}
return
firstGtIndex
;
}
NS_IMETHODIMP
TimerThread
:
:
Run
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mProfilerThreadId
=
profiler_current_thread_id
(
)
;
uint32_t
usForPosInterval
=
1
;
while
(
PR_MicrosecondsToInterval
(
usForPosInterval
)
=
=
0
)
{
usForPosInterval
<
<
=
1
;
}
size_t
usIntervalResolution
;
BinarySearchIf
(
MicrosecondsToInterval
(
)
0
usForPosInterval
IntervalComparator
(
)
&
usIntervalResolution
)
;
MOZ_ASSERT
(
PR_MicrosecondsToInterval
(
usIntervalResolution
-
1
)
=
=
0
)
;
MOZ_ASSERT
(
PR_MicrosecondsToInterval
(
usIntervalResolution
)
=
=
1
)
;
mAllowedEarlyFiringMicroseconds
=
usIntervalResolution
/
2
;
bool
forceRunNextTimer
=
false
;
while
(
!
mShutdown
)
{
TimeDuration
waitFor
;
bool
forceRunThisTimer
=
forceRunNextTimer
;
forceRunNextTimer
=
false
;
#
ifdef
DEBUG
VerifyTimerListConsistency
(
)
;
#
endif
if
(
mSleeping
)
{
uint32_t
milliseconds
=
100
;
if
(
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
TimerScheduling
)
)
{
milliseconds
=
ChaosMode
:
:
randomUint32LessThan
(
200
)
;
}
waitFor
=
TimeDuration
:
:
FromMilliseconds
(
milliseconds
)
;
}
else
{
waitFor
=
TimeDuration
:
:
Forever
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
RemoveLeadingCanceledTimersInternal
(
)
;
if
(
!
mTimers
.
IsEmpty
(
)
)
{
if
(
now
>
=
mTimers
[
0
]
.
Value
(
)
-
>
mTimeout
|
|
forceRunThisTimer
)
{
next
:
RefPtr
<
nsTimerImpl
>
timerRef
(
mTimers
[
0
]
.
Take
(
)
)
;
RemoveFirstTimerInternal
(
)
;
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
Timer
thread
woke
up
%
fms
from
when
it
was
supposed
to
\
n
"
fabs
(
(
now
-
timerRef
-
>
mTimeout
)
.
ToMilliseconds
(
)
)
)
)
;
{
LogTimerEvent
:
:
Run
run
(
timerRef
.
get
(
)
)
;
PostTimerEvent
(
timerRef
.
forget
(
)
)
;
}
if
(
mShutdown
)
{
break
;
}
now
=
TimeStamp
:
:
Now
(
)
;
}
}
RemoveLeadingCanceledTimersInternal
(
)
;
if
(
!
mTimers
.
IsEmpty
(
)
)
{
TimeStamp
timeout
=
mTimers
[
0
]
.
Value
(
)
-
>
mTimeout
;
double
microseconds
=
(
timeout
-
now
)
.
ToMicroseconds
(
)
;
if
(
ChaosMode
:
:
isActive
(
ChaosFeature
:
:
TimerScheduling
)
)
{
static
const
float
sFractions
[
]
=
{
0
.
0f
0
.
25f
0
.
5f
0
.
75f
1
.
0f
1
.
75f
2
.
75f
}
;
microseconds
*
=
sFractions
[
ChaosMode
:
:
randomUint32LessThan
(
ArrayLength
(
sFractions
)
)
]
;
forceRunNextTimer
=
true
;
}
if
(
microseconds
<
mAllowedEarlyFiringMicroseconds
)
{
forceRunNextTimer
=
false
;
goto
next
;
}
waitFor
=
TimeDuration
:
:
FromMicroseconds
(
microseconds
)
;
if
(
waitFor
.
IsZero
(
)
)
{
waitFor
=
TimeDuration
:
:
FromMicroseconds
(
1
)
;
}
}
if
(
MOZ_LOG_TEST
(
GetTimerLog
(
)
LogLevel
:
:
Debug
)
)
{
if
(
waitFor
=
=
TimeDuration
:
:
Forever
(
)
)
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
waiting
forever
\
n
"
)
)
;
else
MOZ_LOG
(
GetTimerLog
(
)
LogLevel
:
:
Debug
(
"
waiting
for
%
f
\
n
"
waitFor
.
ToMilliseconds
(
)
)
)
;
}
}
mWaiting
=
true
;
mNotified
=
false
;
{
AUTO_PROFILER_TRACING_MARKER
(
"
TimerThread
"
"
Wait
"
OTHER
)
;
mMonitor
.
Wait
(
waitFor
)
;
}
if
(
mNotified
)
{
forceRunNextTimer
=
false
;
}
mWaiting
=
false
;
}
return
NS_OK
;
}
nsresult
TimerThread
:
:
AddTimer
(
nsTimerImpl
*
aTimer
const
MutexAutoLock
&
aProofOfLock
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
AUTO_TIMERS_STATS
(
TimerThread_AddTimer
)
;
if
(
!
aTimer
-
>
mEventTarget
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
AddTimerInternal
(
aTimer
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
RemoveLeadingCanceledTimersInternal
(
)
;
if
(
mWaiting
&
&
(
mTimers
[
0
]
.
Value
(
)
=
=
aTimer
|
|
aTimer
-
>
mDelay
.
IsZero
(
)
)
)
{
mNotified
=
true
;
mMonitor
.
Notify
(
)
;
}
if
(
profiler_thread_is_being_profiled_for_markers
(
mProfilerThreadId
)
)
{
struct
TimerMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
Timer
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
ProfilerString8View
&
aTimerName
uint32_t
aDelay
MarkerThreadId
aThreadId
)
{
aWriter
.
StringProperty
(
"
name
"
aTimerName
)
;
aWriter
.
IntProperty
(
"
delay
"
aDelay
)
;
if
(
!
aThreadId
.
IsUnspecified
(
)
)
{
aWriter
.
IntProperty
(
"
threadId
"
static_cast
<
int64_t
>
(
aThreadId
.
ThreadId
(
)
.
ToNumber
(
)
)
)
;
}
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyLabelFormatSearchable
(
"
name
"
"
Name
"
MS
:
:
Format
:
:
String
MS
:
:
Searchable
:
:
Searchable
)
;
schema
.
AddKeyLabelFormat
(
"
delay
"
"
Delay
"
MS
:
:
Format
:
:
Milliseconds
)
;
schema
.
SetTableLabel
(
"
{
marker
.
name
}
-
{
marker
.
data
.
name
}
-
{
marker
.
data
.
delay
}
"
)
;
return
schema
;
}
}
;
nsAutoCString
name
;
aTimer
-
>
GetName
(
name
aProofOfLock
)
;
nsLiteralCString
prefix
(
"
Anonymous_
"
)
;
profiler_add_marker
(
"
AddTimer
"
geckoprofiler
:
:
category
:
:
OTHER
MarkerOptions
(
MarkerThreadId
(
mProfilerThreadId
)
MarkerStack
:
:
MaybeCapture
(
StringHead
(
name
prefix
.
Length
(
)
)
=
=
prefix
)
)
TimerMarker
{
}
name
aTimer
-
>
mDelay
.
ToMilliseconds
(
)
MarkerThreadId
:
:
CurrentThread
(
)
)
;
}
return
NS_OK
;
}
nsresult
TimerThread
:
:
RemoveTimer
(
nsTimerImpl
*
aTimer
const
MutexAutoLock
&
aProofOfLock
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
AUTO_TIMERS_STATS
(
TimerThread_RemoveTimer
)
;
if
(
!
RemoveTimerInternal
(
aTimer
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
profiler_thread_is_being_profiled_for_markers
(
mProfilerThreadId
)
)
{
nsAutoCString
name
;
aTimer
-
>
GetName
(
name
aProofOfLock
)
;
nsLiteralCString
prefix
(
"
Anonymous_
"
)
;
PROFILER_MARKER_TEXT
(
"
RemoveTimer
"
OTHER
MarkerOptions
(
MarkerThreadId
(
mProfilerThreadId
)
MarkerStack
:
:
MaybeCapture
(
StringHead
(
name
prefix
.
Length
(
)
)
=
=
prefix
)
)
name
)
;
}
return
NS_OK
;
}
TimeStamp
TimerThread
:
:
FindNextFireTimeForCurrentThread
(
TimeStamp
aDefault
uint32_t
aSearchBound
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
AUTO_TIMERS_STATS
(
TimerThread_FindNextFireTimeForCurrentThread
)
;
for
(
const
Entry
&
entry
:
mTimers
)
{
const
nsTimerImpl
*
timer
=
entry
.
Value
(
)
;
if
(
timer
)
{
if
(
entry
.
Timeout
(
)
>
aDefault
)
{
return
aDefault
;
}
if
(
!
timer
-
>
IsLowPriority
(
)
)
{
bool
isOnCurrentThread
=
false
;
nsresult
rv
=
timer
-
>
mEventTarget
-
>
IsOnCurrentThread
(
&
isOnCurrentThread
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isOnCurrentThread
)
{
return
entry
.
Timeout
(
)
;
}
}
if
(
aSearchBound
=
=
0
)
{
return
timer
-
>
mTimeout
;
}
-
-
aSearchBound
;
}
}
return
aDefault
;
}
bool
TimerThread
:
:
AddTimerInternal
(
nsTimerImpl
*
aTimer
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
aTimer
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal
)
;
if
(
mShutdown
)
{
return
false
;
}
LogTimerEvent
:
:
LogDispatch
(
aTimer
)
;
const
TimeStamp
&
timeout
=
aTimer
-
>
mTimeout
;
const
size_t
insertionIndex
=
ComputeTimerInsertionIndex
(
timeout
)
;
if
(
insertionIndex
!
=
0
&
&
!
mTimers
[
insertionIndex
-
1
]
.
Value
(
)
)
{
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal_overwrite_before
)
;
mTimers
[
insertionIndex
-
1
]
=
Entry
{
aTimer
}
;
return
true
;
}
const
size_t
length
=
mTimers
.
Length
(
)
;
if
(
insertionIndex
=
=
length
)
{
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal_append
)
;
return
mTimers
.
AppendElement
(
Entry
{
aTimer
}
mozilla
:
:
fallible
)
;
}
if
(
!
mTimers
[
insertionIndex
]
.
Value
(
)
)
{
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal_overwrite
)
;
mTimers
[
insertionIndex
]
=
Entry
{
aTimer
}
;
return
true
;
}
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal_insert
)
;
if
(
length
=
=
mTimers
.
Capacity
(
)
&
&
mTimers
[
length
-
1
]
.
Value
(
)
)
{
AUTO_TIMERS_STATS
(
TimerThread_AddTimerInternal_insert_expand
)
;
if
(
!
mTimers
.
AppendElement
(
Entry
{
mTimers
[
length
-
1
]
.
Timeout
(
)
+
TimeDuration
:
:
FromSeconds
(
365
.
0
*
24
.
0
*
60
.
0
*
60
.
0
)
}
mozilla
:
:
fallible
)
)
{
return
false
;
}
}
Entry
extractedEntry
=
std
:
:
exchange
(
mTimers
[
insertionIndex
]
Entry
{
aTimer
}
)
;
for
(
size_t
i
=
insertionIndex
+
1
;
i
<
length
;
+
+
i
)
{
Entry
&
entryRef
=
mTimers
[
i
]
;
if
(
!
entryRef
.
Value
(
)
)
{
COUNT_TIMERS_STATS
(
TimerThread_AddTimerInternal_insert_overwrite
)
;
entryRef
=
std
:
:
move
(
extractedEntry
)
;
return
true
;
}
COUNT_TIMERS_STATS
(
TimerThread_AddTimerInternal_insert_shifts
)
;
std
:
:
swap
(
entryRef
extractedEntry
)
;
}
COUNT_TIMERS_STATS
(
TimerThread_AddTimerInternal_insert_append
)
;
mTimers
.
AppendElement
(
std
:
:
move
(
extractedEntry
)
)
;
return
true
;
}
bool
TimerThread
:
:
RemoveTimerInternal
(
nsTimerImpl
*
aTimer
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
aTimer
-
>
mMutex
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_RemoveTimerInternal
)
;
if
(
!
aTimer
)
{
COUNT_TIMERS_STATS
(
TimerThread_RemoveTimerInternal_nullptr
)
;
return
false
;
}
if
(
!
aTimer
-
>
IsInTimerThread
(
)
)
{
COUNT_TIMERS_STATS
(
TimerThread_RemoveTimerInternal_not_in_list
)
;
return
false
;
}
AUTO_TIMERS_STATS
(
TimerThread_RemoveTimerInternal_in_list
)
;
for
(
auto
&
entry
:
mTimers
)
{
if
(
entry
.
Value
(
)
=
=
aTimer
)
{
entry
.
Forget
(
)
;
return
true
;
}
}
MOZ_ASSERT
(
!
aTimer
-
>
IsInTimerThread
(
)
"
Not
found
in
the
list
but
it
should
be
!
?
"
)
;
return
false
;
}
void
TimerThread
:
:
RemoveLeadingCanceledTimersInternal
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_RemoveLeadingCanceledTimersInternal
)
;
size_t
toRemove
=
0
;
while
(
toRemove
<
mTimers
.
Length
(
)
&
&
!
mTimers
[
toRemove
]
.
Value
(
)
)
{
+
+
toRemove
;
}
mTimers
.
RemoveElementsAt
(
0
toRemove
)
;
}
void
TimerThread
:
:
RemoveFirstTimerInternal
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_RemoveFirstTimerInternal
)
;
MOZ_ASSERT
(
!
mTimers
.
IsEmpty
(
)
)
;
mTimers
.
RemoveElementAt
(
0
)
;
}
void
TimerThread
:
:
PostTimerEvent
(
already_AddRefed
<
nsTimerImpl
>
aTimerRef
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
AUTO_TIMERS_STATS
(
TimerThread_PostTimerEvent
)
;
RefPtr
<
nsTimerImpl
>
timer
(
aTimerRef
)
;
if
(
!
timer
-
>
mEventTarget
)
{
NS_ERROR
(
"
Attempt
to
post
timer
event
to
NULL
event
target
"
)
;
return
;
}
nsCOMPtr
<
nsIEventTarget
>
target
=
timer
-
>
mEventTarget
;
void
*
p
=
nsTimerEvent
:
:
operator
new
(
sizeof
(
nsTimerEvent
)
)
;
if
(
!
p
)
{
return
;
}
RefPtr
<
nsTimerEvent
>
event
=
:
:
new
(
KnownNotNull
p
)
nsTimerEvent
(
timer
.
forget
(
)
mProfilerThreadId
)
;
nsresult
rv
;
{
MonitorAutoUnlock
unlock
(
mMonitor
)
;
rv
=
target
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
timer
=
event
-
>
ForgetTimer
(
)
;
MutexAutoLock
lock1
(
timer
.
get
(
)
-
>
mMutex
)
;
MonitorAutoLock
lock2
(
mMonitor
)
;
RemoveTimerInternal
(
timer
.
get
(
)
)
;
}
}
}
void
TimerThread
:
:
DoBeforeSleep
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mSleeping
=
true
;
}
void
TimerThread
:
:
DoAfterSleep
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mSleeping
=
false
;
mNotified
=
true
;
PROFILER_MARKER_UNTYPED
(
"
AfterSleep
"
OTHER
MarkerThreadId
(
mProfilerThreadId
)
)
;
mMonitor
.
Notify
(
)
;
}
NS_IMETHODIMP
TimerThread
:
:
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
{
if
(
StaticPrefs
:
:
timer_ignore_sleep_wake_notifications
(
)
)
{
return
NS_OK
;
}
if
(
strcmp
(
aTopic
"
sleep_notification
"
)
=
=
0
|
|
strcmp
(
aTopic
"
suspend_process_notification
"
)
=
=
0
)
{
DoBeforeSleep
(
)
;
}
else
if
(
strcmp
(
aTopic
"
wake_notification
"
)
=
=
0
|
|
strcmp
(
aTopic
"
resume_process_notification
"
)
=
=
0
)
{
DoAfterSleep
(
)
;
}
return
NS_OK
;
}
uint32_t
TimerThread
:
:
AllowedEarlyFiringMicroseconds
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
mAllowedEarlyFiringMicroseconds
;
}
