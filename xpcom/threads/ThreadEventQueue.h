#
ifndef
mozilla_ThreadEventQueue_h
#
define
mozilla_ThreadEventQueue_h
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
CondVar
.
h
"
#
include
"
mozilla
/
SynchronizedEventQueue
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIEventTarget
;
class
nsISerialEventTarget
;
class
nsIThreadObserver
;
namespace
mozilla
{
class
EventQueue
;
class
ThreadEventTarget
;
class
ThreadEventQueue
final
:
public
SynchronizedEventQueue
{
public
:
explicit
ThreadEventQueue
(
UniquePtr
<
EventQueue
>
aQueue
bool
aIsMainThread
=
false
)
;
bool
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventQueuePriority
aPriority
)
final
;
already_AddRefed
<
nsIRunnable
>
GetEvent
(
bool
aMayWait
mozilla
:
:
TimeDuration
*
aLastEventDelay
=
nullptr
)
final
;
bool
HasPendingEvent
(
)
final
;
bool
ShutdownIfNoPendingEvents
(
)
final
;
void
Disconnect
(
const
MutexAutoLock
&
aProofOfLock
)
final
{
}
nsresult
RegisterShutdownTask
(
nsITargetShutdownTask
*
aTask
)
final
;
nsresult
UnregisterShutdownTask
(
nsITargetShutdownTask
*
aTask
)
final
;
void
RunShutdownTasks
(
)
final
;
already_AddRefed
<
nsISerialEventTarget
>
PushEventQueue
(
)
final
;
void
PopEventQueue
(
nsIEventTarget
*
aTarget
)
final
;
already_AddRefed
<
nsIThreadObserver
>
GetObserver
(
)
final
;
already_AddRefed
<
nsIThreadObserver
>
GetObserverOnThread
(
)
final
;
void
SetObserver
(
nsIThreadObserver
*
aObserver
)
final
;
Mutex
&
MutexRef
(
)
{
return
mLock
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
override
;
private
:
class
NestedSink
;
virtual
~
ThreadEventQueue
(
)
;
bool
PutEventInternal
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventQueuePriority
aPriority
NestedSink
*
aQueue
)
;
const
UniquePtr
<
EventQueue
>
mBaseQueue
;
struct
NestedQueueItem
{
UniquePtr
<
EventQueue
>
mQueue
;
RefPtr
<
ThreadEventTarget
>
mEventTarget
;
NestedQueueItem
(
UniquePtr
<
EventQueue
>
aQueue
ThreadEventTarget
*
aEventTarget
)
;
}
;
nsTArray
<
NestedQueueItem
>
mNestedQueues
GUARDED_BY
(
mLock
)
;
Mutex
mLock
;
CondVar
mEventsAvailable
GUARDED_BY
(
mLock
)
;
bool
mEventsAreDoomed
GUARDED_BY
(
mLock
)
=
false
;
nsCOMPtr
<
nsIThreadObserver
>
mObserver
GUARDED_BY
(
mLock
)
;
nsTArray
<
nsCOMPtr
<
nsITargetShutdownTask
>
>
mShutdownTasks
GUARDED_BY
(
mLock
)
;
bool
mShutdownTasksRun
GUARDED_BY
(
mLock
)
=
false
;
const
bool
mIsMainThread
;
}
;
}
#
endif
