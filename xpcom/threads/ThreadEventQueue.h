#
ifndef
mozilla_ThreadEventQueue_h
#
define
mozilla_ThreadEventQueue_h
#
include
"
mozilla
/
AbstractEventQueue
.
h
"
#
include
"
mozilla
/
CondVar
.
h
"
#
include
"
mozilla
/
SynchronizedEventQueue
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIEventTarget
;
class
nsISerialEventTarget
;
class
nsIThreadObserver
;
namespace
mozilla
{
class
EventQueue
;
template
<
typename
InnerQueueT
>
class
PrioritizedEventQueue
;
class
LabeledEventQueue
;
class
ThreadEventTarget
;
template
<
class
InnerQueueT
>
class
ThreadEventQueue
final
:
public
SynchronizedEventQueue
{
public
:
explicit
ThreadEventQueue
(
UniquePtr
<
InnerQueueT
>
aQueue
)
;
bool
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventPriority
aPriority
)
final
;
already_AddRefed
<
nsIRunnable
>
GetEvent
(
bool
aMayWait
EventPriority
*
aPriority
)
final
;
bool
HasPendingEvent
(
)
final
;
bool
ShutdownIfNoPendingEvents
(
)
final
;
void
Disconnect
(
const
MutexAutoLock
&
aProofOfLock
)
final
{
}
void
EnableInputEventPrioritization
(
)
final
;
void
FlushInputEventPrioritization
(
)
final
;
void
SuspendInputEventPrioritization
(
)
final
;
void
ResumeInputEventPrioritization
(
)
final
;
already_AddRefed
<
nsISerialEventTarget
>
PushEventQueue
(
)
;
void
PopEventQueue
(
nsIEventTarget
*
aTarget
)
;
already_AddRefed
<
nsIThreadObserver
>
GetObserver
(
)
final
;
already_AddRefed
<
nsIThreadObserver
>
GetObserverOnThread
(
)
final
;
void
SetObserver
(
nsIThreadObserver
*
aObserver
)
final
;
Mutex
&
MutexRef
(
)
{
return
mLock
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
n
=
0
;
n
+
=
mBaseQueue
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
n
+
=
mNestedQueues
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
&
queue
:
mNestedQueues
)
{
n
+
=
queue
.
mEventTarget
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
SynchronizedEventQueue
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
+
n
;
}
private
:
class
NestedSink
;
virtual
~
ThreadEventQueue
(
)
;
bool
PutEventInternal
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventPriority
aPriority
NestedSink
*
aQueue
)
;
UniquePtr
<
InnerQueueT
>
mBaseQueue
;
struct
NestedQueueItem
{
UniquePtr
<
EventQueue
>
mQueue
;
RefPtr
<
ThreadEventTarget
>
mEventTarget
;
NestedQueueItem
(
UniquePtr
<
EventQueue
>
aQueue
ThreadEventTarget
*
aEventTarget
)
:
mQueue
(
std
:
:
move
(
aQueue
)
)
mEventTarget
(
aEventTarget
)
{
}
}
;
nsTArray
<
NestedQueueItem
>
mNestedQueues
;
Mutex
mLock
;
CondVar
mEventsAvailable
;
bool
mEventsAreDoomed
=
false
;
nsCOMPtr
<
nsIThreadObserver
>
mObserver
;
}
;
extern
template
class
ThreadEventQueue
<
EventQueue
>
;
extern
template
class
ThreadEventQueue
<
PrioritizedEventQueue
<
EventQueue
>
>
;
extern
template
class
ThreadEventQueue
<
PrioritizedEventQueue
<
LabeledEventQueue
>
>
;
}
;
#
endif
