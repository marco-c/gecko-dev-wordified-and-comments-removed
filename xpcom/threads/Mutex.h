#
ifndef
mozilla_Mutex_h
#
define
mozilla_Mutex_h
#
include
"
mozilla
/
BlockingResourceBase
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
PlatformMutex
.
h
"
namespace
mozilla
{
class
OffTheBooksMutex
:
public
detail
:
:
MutexImpl
BlockingResourceBase
{
public
:
explicit
OffTheBooksMutex
(
const
char
*
aName
recordreplay
:
:
Behavior
aRecorded
=
recordreplay
:
:
Behavior
:
:
Preserve
)
:
detail
:
:
MutexImpl
(
aRecorded
)
BlockingResourceBase
(
aName
eMutex
)
#
ifdef
DEBUG
mOwningThread
(
nullptr
)
#
endif
{
}
~
OffTheBooksMutex
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mOwningThread
"
destroying
a
still
-
owned
lock
!
"
)
;
#
endif
}
#
ifndef
DEBUG
void
Lock
(
)
{
this
-
>
lock
(
)
;
}
void
Unlock
(
)
{
this
-
>
unlock
(
)
;
}
void
AssertCurrentThreadOwns
(
)
const
{
}
void
AssertNotCurrentThreadOwns
(
)
const
{
}
#
else
void
Lock
(
)
;
void
Unlock
(
)
;
void
AssertCurrentThreadOwns
(
)
const
;
void
AssertNotCurrentThreadOwns
(
)
const
{
}
#
endif
private
:
OffTheBooksMutex
(
)
;
OffTheBooksMutex
(
const
OffTheBooksMutex
&
)
;
OffTheBooksMutex
&
operator
=
(
const
OffTheBooksMutex
&
)
;
friend
class
OffTheBooksCondVar
;
#
ifdef
DEBUG
PRThread
*
mOwningThread
;
#
endif
}
;
class
Mutex
:
public
OffTheBooksMutex
{
public
:
explicit
Mutex
(
const
char
*
aName
recordreplay
:
:
Behavior
aRecorded
=
recordreplay
:
:
Behavior
:
:
Preserve
)
:
OffTheBooksMutex
(
aName
aRecorded
)
{
MOZ_COUNT_CTOR
(
Mutex
)
;
}
~
Mutex
(
)
{
MOZ_COUNT_DTOR
(
Mutex
)
;
}
private
:
Mutex
(
)
;
Mutex
(
const
Mutex
&
)
;
Mutex
&
operator
=
(
const
Mutex
&
)
;
}
;
template
<
typename
T
>
class
MOZ_RAII
BaseAutoUnlock
;
template
<
typename
T
>
class
MOZ_RAII
BaseAutoLock
{
public
:
explicit
BaseAutoLock
(
T
aLock
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mLock
(
aLock
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
mLock
.
Lock
(
)
;
}
~
BaseAutoLock
(
void
)
{
mLock
.
Unlock
(
)
;
}
void
AssertOwns
(
const
T
&
aLock
)
const
{
MOZ_ASSERT
(
&
aLock
=
=
&
mLock
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
}
private
:
BaseAutoLock
(
)
;
BaseAutoLock
(
BaseAutoLock
&
)
;
BaseAutoLock
&
operator
=
(
BaseAutoLock
&
)
;
static
void
*
operator
new
(
size_t
)
CPP_THROW_NEW
;
friend
class
BaseAutoUnlock
<
T
>
;
T
mLock
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
typedef
BaseAutoLock
<
Mutex
&
>
MutexAutoLock
;
typedef
BaseAutoLock
<
OffTheBooksMutex
&
>
OffTheBooksMutexAutoLock
;
template
<
typename
T
>
class
MOZ_RAII
BaseAutoUnlock
{
public
:
explicit
BaseAutoUnlock
(
T
aLock
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mLock
(
aLock
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
mLock
.
Unlock
(
)
;
}
explicit
BaseAutoUnlock
(
BaseAutoLock
<
T
>
&
aAutoLock
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mLock
(
aAutoLock
.
mLock
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
NS_ASSERTION
(
mLock
"
null
lock
"
)
;
mLock
-
>
Unlock
(
)
;
}
~
BaseAutoUnlock
(
)
{
mLock
.
Lock
(
)
;
}
private
:
BaseAutoUnlock
(
)
;
BaseAutoUnlock
(
BaseAutoUnlock
&
)
;
BaseAutoUnlock
&
operator
=
(
BaseAutoUnlock
&
)
;
static
void
*
operator
new
(
size_t
)
CPP_THROW_NEW
;
T
mLock
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
typedef
BaseAutoUnlock
<
Mutex
&
>
MutexAutoUnlock
;
typedef
BaseAutoUnlock
<
OffTheBooksMutex
&
>
OffTheBooksMutexAutoUnlock
;
}
#
endif
