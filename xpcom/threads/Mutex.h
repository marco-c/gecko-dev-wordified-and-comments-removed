#
ifndef
mozilla_Mutex_h
#
define
mozilla_Mutex_h
#
include
"
mozilla
/
BlockingResourceBase
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PlatformMutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
namespace
mozilla
{
class
OffTheBooksMutex
:
public
detail
:
:
MutexImpl
BlockingResourceBase
{
public
:
explicit
OffTheBooksMutex
(
const
char
*
aName
)
:
BlockingResourceBase
(
aName
eMutex
)
#
ifdef
DEBUG
mOwningThread
(
nullptr
)
#
endif
{
}
~
OffTheBooksMutex
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mOwningThread
"
destroying
a
still
-
owned
lock
!
"
)
;
#
endif
}
#
ifndef
DEBUG
void
Lock
(
)
{
this
-
>
lock
(
)
;
}
bool
TryLock
(
)
{
return
this
-
>
tryLock
(
)
;
}
void
Unlock
(
)
{
this
-
>
unlock
(
)
;
}
void
AssertCurrentThreadOwns
(
)
const
{
}
void
AssertNotCurrentThreadOwns
(
)
const
{
}
#
else
void
Lock
(
)
;
bool
TryLock
(
)
;
void
Unlock
(
)
;
void
AssertCurrentThreadOwns
(
)
const
;
void
AssertNotCurrentThreadOwns
(
)
const
{
}
#
endif
private
:
OffTheBooksMutex
(
)
;
OffTheBooksMutex
(
const
OffTheBooksMutex
&
)
;
OffTheBooksMutex
&
operator
=
(
const
OffTheBooksMutex
&
)
;
friend
class
OffTheBooksCondVar
;
#
ifdef
DEBUG
PRThread
*
mOwningThread
;
#
endif
}
;
class
Mutex
:
public
OffTheBooksMutex
{
public
:
explicit
Mutex
(
const
char
*
aName
)
:
OffTheBooksMutex
(
aName
)
{
MOZ_COUNT_CTOR
(
Mutex
)
;
}
MOZ_COUNTED_DTOR
(
Mutex
)
private
:
Mutex
(
)
;
Mutex
(
const
Mutex
&
)
;
Mutex
&
operator
=
(
const
Mutex
&
)
;
}
;
namespace
detail
{
template
<
typename
T
>
class
MOZ_RAII
BaseAutoUnlock
;
template
<
typename
T
>
class
MOZ_RAII
BaseAutoLock
{
public
:
explicit
BaseAutoLock
(
T
aLock
)
:
mLock
(
aLock
)
{
mLock
.
Lock
(
)
;
}
~
BaseAutoLock
(
void
)
{
mLock
.
Unlock
(
)
;
}
static
MOZ_MUST_USE
bool
TryMake
(
T
aLock
Maybe
<
BaseAutoLock
<
T
>
>
&
aOutAutoLock
)
{
if
(
aLock
.
TryLock
(
)
)
{
aOutAutoLock
.
emplace
(
aLock
true
)
;
return
true
;
}
return
false
;
}
void
AssertOwns
(
const
T
&
aMutex
)
const
{
MOZ_ASSERT
(
&
aMutex
=
=
&
mLock
)
;
mLock
.
AssertCurrentThreadOwns
(
)
;
}
private
:
BaseAutoLock
(
)
;
BaseAutoLock
(
BaseAutoLock
&
)
;
BaseAutoLock
&
operator
=
(
BaseAutoLock
&
)
;
static
void
*
operator
new
(
size_t
)
noexcept
(
true
)
;
BaseAutoLock
(
T
aLock
bool
aPlaceholder
)
:
mLock
(
aLock
)
{
Unused
<
<
aPlaceholder
;
}
friend
class
BaseAutoUnlock
<
T
>
;
friend
class
Maybe
<
BaseAutoLock
<
T
>
>
;
T
mLock
;
}
;
template
<
typename
MutexType
>
BaseAutoLock
(
MutexType
&
)
-
>
BaseAutoLock
<
MutexType
&
>
;
}
typedef
detail
:
:
BaseAutoLock
<
Mutex
&
>
MutexAutoLock
;
typedef
detail
:
:
BaseAutoLock
<
OffTheBooksMutex
&
>
OffTheBooksMutexAutoLock
;
namespace
detail
{
template
<
typename
T
>
class
MOZ_RAII
BaseAutoUnlock
{
public
:
explicit
BaseAutoUnlock
(
T
aLock
)
:
mLock
(
aLock
)
{
mLock
.
Unlock
(
)
;
}
explicit
BaseAutoUnlock
(
BaseAutoLock
<
T
>
&
aAutoLock
)
:
mLock
(
aAutoLock
.
mLock
)
{
NS_ASSERTION
(
mLock
"
null
lock
"
)
;
mLock
-
>
Unlock
(
)
;
}
~
BaseAutoUnlock
(
)
{
mLock
.
Lock
(
)
;
}
private
:
BaseAutoUnlock
(
)
;
BaseAutoUnlock
(
BaseAutoUnlock
&
)
;
BaseAutoUnlock
&
operator
=
(
BaseAutoUnlock
&
)
;
static
void
*
operator
new
(
size_t
)
noexcept
(
true
)
;
T
mLock
;
}
;
template
<
typename
MutexType
>
BaseAutoUnlock
(
MutexType
&
)
-
>
BaseAutoUnlock
<
MutexType
&
>
;
}
typedef
detail
:
:
BaseAutoUnlock
<
Mutex
&
>
MutexAutoUnlock
;
typedef
detail
:
:
BaseAutoUnlock
<
OffTheBooksMutex
&
>
OffTheBooksMutexAutoUnlock
;
}
#
endif
