#
ifndef
TaskQueue_h_
#
define
TaskQueue_h_
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Queue
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TaskDispatcher
.
h
"
#
include
"
nsIDirectTaskDispatcher
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
typedef
MozPromise
<
bool
bool
false
>
ShutdownPromise
;
class
TaskQueue
:
public
AbstractThread
public
nsIDirectTaskDispatcher
{
class
EventTargetWrapper
;
public
:
TaskQueue
(
already_AddRefed
<
nsIEventTarget
>
aTarget
const
char
*
aName
bool
aSupportsTailDispatch
=
false
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIDIRECTTASKDISPATCHER
TaskDispatcher
&
TailDispatcher
(
)
override
;
NS_IMETHOD
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
override
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
aEvent
;
{
MonitorAutoLock
mon
(
mQueueMonitor
)
;
return
DispatchLocked
(
runnable
aFlags
NormalDispatch
)
;
}
}
[
[
nodiscard
]
]
nsresult
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
DispatchReason
aReason
=
NormalDispatch
)
override
{
nsCOMPtr
<
nsIRunnable
>
r
=
aRunnable
;
{
MonitorAutoLock
mon
(
mQueueMonitor
)
;
return
DispatchLocked
(
r
NS_DISPATCH_NORMAL
aReason
)
;
}
}
using
nsIEventTarget
:
:
Dispatch
;
NS_IMETHOD
RegisterShutdownTask
(
nsITargetShutdownTask
*
aTask
)
override
;
NS_IMETHOD
UnregisterShutdownTask
(
nsITargetShutdownTask
*
aTask
)
override
;
using
CancelPromise
=
MozPromise
<
bool
bool
false
>
;
RefPtr
<
CancelPromise
>
CancelDelayedRunnables
(
)
;
RefPtr
<
ShutdownPromise
>
BeginShutdown
(
)
;
void
AwaitIdle
(
)
;
void
AwaitShutdownAndIdle
(
)
;
bool
IsEmpty
(
)
;
bool
IsCurrentThreadIn
(
)
const
override
;
using
nsISerialEventTarget
:
:
IsOnCurrentThread
;
protected
:
virtual
~
TaskQueue
(
)
;
void
AwaitIdleLocked
(
)
;
nsresult
DispatchLocked
(
nsCOMPtr
<
nsIRunnable
>
&
aRunnable
uint32_t
aFlags
DispatchReason
aReason
=
NormalDispatch
)
;
void
MaybeResolveShutdown
(
)
{
mQueueMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
mIsShutdown
&
&
!
mIsRunning
)
{
mShutdownPromise
.
ResolveIfExists
(
true
__func__
)
;
mTarget
=
nullptr
;
}
}
nsCOMPtr
<
nsIEventTarget
>
mTarget
;
Monitor
mQueueMonitor
MOZ_UNANNOTATED
;
typedef
struct
TaskStruct
{
nsCOMPtr
<
nsIRunnable
>
event
;
uint32_t
flags
;
}
TaskStruct
;
Queue
<
TaskStruct
>
mTasks
;
nsTArray
<
nsCOMPtr
<
nsITargetShutdownTask
>
>
mShutdownTasks
;
Atomic
<
PRThread
*
>
mRunningThread
;
class
AutoTaskGuard
{
public
:
explicit
AutoTaskGuard
(
TaskQueue
*
aQueue
)
:
mQueue
(
aQueue
)
mLastCurrentThread
(
nullptr
)
{
MOZ_ASSERT
(
!
mQueue
-
>
mTailDispatcher
)
;
mTaskDispatcher
.
emplace
(
aQueue
true
)
;
mQueue
-
>
mTailDispatcher
=
mTaskDispatcher
.
ptr
(
)
;
mLastCurrentThread
=
sCurrentThreadTLS
.
get
(
)
;
sCurrentThreadTLS
.
set
(
aQueue
)
;
MOZ_ASSERT
(
mQueue
-
>
mRunningThread
=
=
nullptr
)
;
mQueue
-
>
mRunningThread
=
PR_GetCurrentThread
(
)
;
}
~
AutoTaskGuard
(
)
{
mTaskDispatcher
-
>
DrainDirectTasks
(
)
;
mTaskDispatcher
.
reset
(
)
;
MOZ_ASSERT
(
mQueue
-
>
mRunningThread
=
=
PR_GetCurrentThread
(
)
)
;
mQueue
-
>
mRunningThread
=
nullptr
;
sCurrentThreadTLS
.
set
(
mLastCurrentThread
)
;
mQueue
-
>
mTailDispatcher
=
nullptr
;
}
private
:
Maybe
<
AutoTaskDispatcher
>
mTaskDispatcher
;
TaskQueue
*
mQueue
;
AbstractThread
*
mLastCurrentThread
;
}
;
TaskDispatcher
*
mTailDispatcher
;
bool
mIsRunning
;
bool
mIsShutdown
;
MozPromiseHolder
<
ShutdownPromise
>
mShutdownPromise
;
const
char
*
const
mName
;
SimpleTaskQueue
mDirectTasks
;
class
Runner
:
public
Runnable
{
public
:
explicit
Runner
(
TaskQueue
*
aQueue
)
:
Runnable
(
"
TaskQueue
:
:
Runner
"
)
mQueue
(
aQueue
)
{
}
NS_IMETHOD
Run
(
)
override
;
private
:
RefPtr
<
TaskQueue
>
mQueue
;
}
;
}
;
}
#
endif
