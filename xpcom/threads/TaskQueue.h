#
ifndef
TaskQueue_h_
#
define
TaskQueue_h_
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TaskDispatcher
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
queue
>
#
include
"
nsThreadUtils
.
h
"
class
nsIEventTarget
;
class
nsIRunnable
;
namespace
mozilla
{
typedef
MozPromise
<
bool
bool
false
>
ShutdownPromise
;
class
TaskQueue
:
public
AbstractThread
{
class
EventTargetWrapper
;
public
:
explicit
TaskQueue
(
already_AddRefed
<
nsIEventTarget
>
aTarget
bool
aSupportsTailDispatch
=
false
)
;
TaskQueue
(
already_AddRefed
<
nsIEventTarget
>
aTarget
const
char
*
aName
bool
aSupportsTailDispatch
=
false
)
;
TaskDispatcher
&
TailDispatcher
(
)
override
;
TaskQueue
*
AsTaskQueue
(
)
override
{
return
this
;
}
void
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
DispatchFailureHandling
aFailureHandling
=
AssertDispatchSuccess
DispatchReason
aReason
=
NormalDispatch
)
override
{
nsCOMPtr
<
nsIRunnable
>
r
=
aRunnable
;
{
MonitorAutoLock
mon
(
mQueueMonitor
)
;
nsresult
rv
=
DispatchLocked
(
r
aFailureHandling
aReason
)
;
#
if
defined
(
DEBUG
)
|
|
!
defined
(
RELEASE_OR_BETA
)
|
|
defined
(
EARLY_BETA_OR_EARLIER
)
if
(
NS_FAILED
(
rv
)
&
&
aFailureHandling
=
=
AssertDispatchSuccess
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
%
s
:
Dispatch
failed
.
rv
=
%
x
"
mName
uint32_t
(
rv
)
)
;
}
#
endif
Unused
<
<
rv
;
}
}
using
AbstractThread
:
:
Dispatch
;
RefPtr
<
ShutdownPromise
>
BeginShutdown
(
)
;
void
AwaitIdle
(
)
;
void
AwaitShutdownAndIdle
(
)
;
bool
IsEmpty
(
)
;
uint32_t
ImpreciseLengthForHeuristics
(
)
;
bool
IsCurrentThreadIn
(
)
override
;
already_AddRefed
<
nsISerialEventTarget
>
WrapAsEventTarget
(
)
;
protected
:
virtual
~
TaskQueue
(
)
;
void
AwaitIdleLocked
(
)
;
nsresult
DispatchLocked
(
nsCOMPtr
<
nsIRunnable
>
&
aRunnable
DispatchFailureHandling
aFailureHandling
DispatchReason
aReason
=
NormalDispatch
)
;
void
MaybeResolveShutdown
(
)
{
mQueueMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
mIsShutdown
&
&
!
mIsRunning
)
{
mShutdownPromise
.
ResolveIfExists
(
true
__func__
)
;
mTarget
=
nullptr
;
}
}
nsCOMPtr
<
nsIEventTarget
>
mTarget
;
Monitor
mQueueMonitor
;
std
:
:
queue
<
nsCOMPtr
<
nsIRunnable
>
>
mTasks
;
Atomic
<
PRThread
*
>
mRunningThread
;
class
AutoTaskGuard
:
public
AutoTaskDispatcher
{
public
:
explicit
AutoTaskGuard
(
TaskQueue
*
aQueue
)
:
AutoTaskDispatcher
(
true
)
mQueue
(
aQueue
)
mLastCurrentThread
(
nullptr
)
{
MOZ_ASSERT
(
!
mQueue
-
>
mTailDispatcher
)
;
mQueue
-
>
mTailDispatcher
=
this
;
mLastCurrentThread
=
sCurrentThreadTLS
.
get
(
)
;
sCurrentThreadTLS
.
set
(
aQueue
)
;
MOZ_ASSERT
(
mQueue
-
>
mRunningThread
=
=
nullptr
)
;
mQueue
-
>
mRunningThread
=
GetCurrentPhysicalThread
(
)
;
}
~
AutoTaskGuard
(
)
{
DrainDirectTasks
(
)
;
MOZ_ASSERT
(
mQueue
-
>
mRunningThread
=
=
GetCurrentPhysicalThread
(
)
)
;
mQueue
-
>
mRunningThread
=
nullptr
;
sCurrentThreadTLS
.
set
(
mLastCurrentThread
)
;
mQueue
-
>
mTailDispatcher
=
nullptr
;
}
private
:
TaskQueue
*
mQueue
;
AbstractThread
*
mLastCurrentThread
;
}
;
TaskDispatcher
*
mTailDispatcher
;
bool
mIsRunning
;
bool
mIsShutdown
;
MozPromiseHolder
<
ShutdownPromise
>
mShutdownPromise
;
const
char
*
const
mName
;
class
Runner
:
public
Runnable
{
public
:
explicit
Runner
(
TaskQueue
*
aQueue
)
:
Runnable
(
"
TaskQueue
:
:
Runner
"
)
mQueue
(
aQueue
)
{
}
NS_IMETHOD
Run
(
)
override
;
private
:
RefPtr
<
TaskQueue
>
mQueue
;
}
;
}
;
}
#
endif
