#
ifndef
TaskQueue_h_
#
define
TaskQueue_h_
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Queue
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TargetShutdownTaskSet
.
h
"
#
include
"
mozilla
/
TaskDispatcher
.
h
"
#
include
"
mozilla
/
ThreadSafeWeakPtr
.
h
"
#
include
"
nsIDirectTaskDispatcher
.
h
"
#
include
"
nsITargetShutdownTask
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
define
MOZILLA_TASKQUEUE_IID
\
{
0xb5181e3a
0x39cf
0x4d32
{
0x81
0x4a
0xea
0x86
0x94
0x16
0x95
0xd1
}
}
namespace
mozilla
{
typedef
MozPromise
<
bool
bool
false
>
ShutdownPromise
;
class
TaskQueueTrackerEntry
;
class
TaskQueue
final
:
public
AbstractThread
public
nsIDirectTaskDispatcher
public
SupportsThreadSafeWeakPtr
<
TaskQueue
>
{
class
EventTargetWrapper
;
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIDIRECTTASKDISPATCHER
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
TaskQueue
)
NS_INLINE_DECL_STATIC_IID
(
MOZILLA_TASKQUEUE_IID
)
static
RefPtr
<
TaskQueue
>
Create
(
already_AddRefed
<
nsIEventTarget
>
aTarget
const
char
*
aName
bool
aSupportsTailDispatch
=
false
)
;
TaskDispatcher
&
TailDispatcher
(
)
override
;
NS_IMETHOD
DispatchFromScript
(
nsIRunnable
*
aEvent
DispatchFlags
aFlags
)
override
{
return
Dispatch
(
do_AddRef
(
aEvent
)
aFlags
)
;
}
NS_IMETHOD
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
DispatchFlags
aFlags
)
override
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
aEvent
;
{
MonitorAutoLock
mon
(
mQueueMonitor
)
;
return
DispatchLocked
(
runnable
aFlags
NormalDispatch
)
;
}
}
[
[
nodiscard
]
]
nsresult
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
DispatchReason
aReason
=
NormalDispatch
)
override
{
nsCOMPtr
<
nsIRunnable
>
r
=
aRunnable
;
{
MonitorAutoLock
mon
(
mQueueMonitor
)
;
return
DispatchLocked
(
r
NS_DISPATCH_NORMAL
aReason
)
;
}
}
using
nsIEventTarget
:
:
Dispatch
;
NS_IMETHOD
RegisterShutdownTask
(
nsITargetShutdownTask
*
aTask
)
override
;
NS_IMETHOD
UnregisterShutdownTask
(
nsITargetShutdownTask
*
aTask
)
override
;
using
CancelPromise
=
MozPromise
<
bool
bool
false
>
;
RefPtr
<
ShutdownPromise
>
BeginShutdown
(
)
;
void
AwaitIdle
(
)
;
void
AwaitShutdownAndIdle
(
)
;
bool
IsEmpty
(
)
;
bool
IsCurrentThreadIn
(
)
const
override
;
using
nsISerialEventTarget
:
:
IsOnCurrentThread
;
class
Observer
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
void
WillProcessEvent
(
TaskQueue
*
aQueue
)
=
0
;
virtual
void
DidProcessEvent
(
TaskQueue
*
aQueue
)
=
0
;
protected
:
virtual
~
Observer
(
)
=
default
;
}
;
void
SetObserver
(
Observer
*
aObserver
)
;
private
:
friend
class
SupportsThreadSafeWeakPtr
<
TaskQueue
>
;
TaskQueue
(
already_AddRefed
<
nsIEventTarget
>
aTarget
const
char
*
aName
bool
aSupportsTailDispatch
)
;
virtual
~
TaskQueue
(
)
=
default
;
void
AwaitIdleLocked
(
)
;
nsresult
DispatchLocked
(
nsCOMPtr
<
nsIRunnable
>
&
aRunnable
DispatchFlags
aFlags
DispatchReason
aReason
=
NormalDispatch
)
;
void
MaybeResolveShutdown
(
)
;
nsCOMPtr
<
nsIEventTarget
>
mTarget
MOZ_GUARDED_BY
(
mQueueMonitor
)
;
UniquePtr
<
TaskQueueTrackerEntry
>
mTrackerEntry
MOZ_GUARDED_BY
(
mQueueMonitor
)
;
Monitor
mQueueMonitor
;
typedef
struct
TaskStruct
{
nsCOMPtr
<
nsIRunnable
>
event
;
DispatchFlags
flags
;
}
TaskStruct
;
Queue
<
TaskStruct
>
mTasks
MOZ_GUARDED_BY
(
mQueueMonitor
)
;
TargetShutdownTaskSet
mShutdownTasks
MOZ_GUARDED_BY
(
mQueueMonitor
)
;
Atomic
<
PRThread
*
>
mRunningThread
;
class
AutoTaskGuard
{
public
:
AutoTaskGuard
(
TaskQueue
*
aQueue
TaskQueue
:
:
Observer
*
aObserver
)
:
mQueue
(
aQueue
)
mObserver
(
aObserver
)
mLastCurrentThread
(
nullptr
)
{
MOZ_ASSERT
(
!
mQueue
-
>
mTailDispatcher
)
;
mTaskDispatcher
.
emplace
(
aQueue
true
)
;
mQueue
-
>
mTailDispatcher
=
mTaskDispatcher
.
ptr
(
)
;
mLastCurrentThread
=
sCurrentThreadTLS
.
get
(
)
;
sCurrentThreadTLS
.
set
(
aQueue
)
;
MOZ_ASSERT
(
mQueue
-
>
mRunningThread
=
=
nullptr
)
;
mQueue
-
>
mRunningThread
=
PR_GetCurrentThread
(
)
;
mEventTargetGuard
.
emplace
(
mQueue
)
;
if
(
mObserver
)
{
mObserver
-
>
WillProcessEvent
(
mQueue
)
;
}
}
~
AutoTaskGuard
(
)
{
mTaskDispatcher
-
>
DrainDirectTasks
(
)
;
if
(
mObserver
)
{
mObserver
-
>
DidProcessEvent
(
mQueue
)
;
MOZ_ASSERT
(
!
mTaskDispatcher
-
>
HaveDirectTasks
(
)
"
TaskQueue
:
:
Observer
instance
in
"
"
DidProcessEvent
(
TaskQueue
*
)
added
direct
tasks
in
error
"
)
;
}
mTaskDispatcher
.
reset
(
)
;
mQueue
-
>
mTailDispatcher
=
nullptr
;
mEventTargetGuard
=
Nothing
(
)
;
MOZ_ASSERT
(
mQueue
-
>
mRunningThread
=
=
PR_GetCurrentThread
(
)
)
;
mQueue
-
>
mRunningThread
=
nullptr
;
sCurrentThreadTLS
.
set
(
mLastCurrentThread
)
;
}
private
:
Maybe
<
AutoTaskDispatcher
>
mTaskDispatcher
;
Maybe
<
SerialEventTargetGuard
>
mEventTargetGuard
;
TaskQueue
*
mQueue
;
TaskQueue
:
:
Observer
*
mObserver
;
AbstractThread
*
mLastCurrentThread
;
}
;
TaskDispatcher
*
mTailDispatcher
;
bool
mIsRunning
MOZ_GUARDED_BY
(
mQueueMonitor
)
;
bool
mIsShutdown
MOZ_GUARDED_BY
(
mQueueMonitor
)
;
MozPromiseHolder
<
ShutdownPromise
>
mShutdownPromise
MOZ_GUARDED_BY
(
mQueueMonitor
)
;
const
char
*
const
mName
;
SimpleTaskQueue
mDirectTasks
;
RefPtr
<
Observer
>
mObserver
MOZ_GUARDED_BY
(
mQueueMonitor
)
;
class
Runner
:
public
Runnable
{
public
:
explicit
Runner
(
TaskQueue
*
aQueue
)
:
Runnable
(
"
TaskQueue
:
:
Runner
"
)
mQueue
(
aQueue
)
{
}
NS_IMETHOD
Run
(
)
override
;
private
:
RefPtr
<
TaskQueue
>
mQueue
;
}
;
}
;
#
define
MOZILLA_TASKQUEUETRACKER_IID
\
{
0x765c4b56
0xd5f6
0x4a9f
{
0x91
0xcf
0x51
0x47
0xb3
0xc1
0x7e
0xa6
}
}
class
TaskQueueTracker
:
public
nsISupports
{
public
:
NS_INLINE_DECL_STATIC_IID
(
MOZILLA_TASKQUEUETRACKER_IID
)
nsTArray
<
RefPtr
<
TaskQueue
>
>
GetAllTrackedTaskQueues
(
)
;
protected
:
virtual
~
TaskQueueTracker
(
)
;
private
:
friend
class
TaskQueueTrackerEntry
;
Mutex
mMutex
{
"
TaskQueueTracker
"
}
;
LinkedList
<
TaskQueueTrackerEntry
>
mEntries
MOZ_GUARDED_BY
(
mMutex
)
;
}
;
}
#
endif
