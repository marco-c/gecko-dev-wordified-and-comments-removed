#
include
"
mozilla
/
HangAnnotations
.
h
"
#
include
<
vector
>
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
namespace
mozilla
{
namespace
HangMonitor
{
static
StaticAutoPtr
<
Observer
:
:
Annotators
>
gChromehangAnnotators
;
void
HangAnnotations
:
:
AddAnnotation
(
const
nsAString
&
aName
const
int32_t
aData
)
{
nsAutoString
dataString
;
dataString
.
AppendInt
(
aData
)
;
AppendElement
(
Annotation
(
aName
dataString
)
)
;
}
void
HangAnnotations
:
:
AddAnnotation
(
const
nsAString
&
aName
const
double
aData
)
{
nsAutoString
dataString
;
dataString
.
AppendFloat
(
aData
)
;
AppendElement
(
Annotation
(
aName
dataString
)
)
;
}
void
HangAnnotations
:
:
AddAnnotation
(
const
nsAString
&
aName
const
nsAString
&
aData
)
{
AppendElement
(
Annotation
(
aName
aData
)
)
;
}
void
HangAnnotations
:
:
AddAnnotation
(
const
nsAString
&
aName
const
nsACString
&
aData
)
{
NS_ConvertUTF8toUTF16
dataString
(
aData
)
;
AppendElement
(
Annotation
(
aName
dataString
)
)
;
}
void
HangAnnotations
:
:
AddAnnotation
(
const
nsAString
&
aName
const
bool
aData
)
{
if
(
aData
)
{
AppendElement
(
Annotation
(
aName
NS_LITERAL_STRING
(
"
true
"
)
)
)
;
}
else
{
AppendElement
(
Annotation
(
aName
NS_LITERAL_STRING
(
"
false
"
)
)
)
;
}
}
namespace
Observer
{
Annotators
:
:
Annotators
(
)
:
mMutex
(
"
HangMonitor
:
:
Annotators
:
:
mMutex
"
)
{
MOZ_COUNT_CTOR
(
Annotators
)
;
}
Annotators
:
:
~
Annotators
(
)
{
MOZ_ASSERT
(
mAnnotators
.
empty
(
)
)
;
MOZ_COUNT_DTOR
(
Annotators
)
;
}
bool
Annotators
:
:
Register
(
Annotator
&
aAnnotator
)
{
MutexAutoLock
lock
(
mMutex
)
;
auto
result
=
mAnnotators
.
insert
(
&
aAnnotator
)
;
return
result
.
second
;
}
bool
Annotators
:
:
Unregister
(
Annotator
&
aAnnotator
)
{
MutexAutoLock
lock
(
mMutex
)
;
DebugOnly
<
std
:
:
set
<
Annotator
*
>
:
:
size_type
>
numErased
;
numErased
=
mAnnotators
.
erase
(
&
aAnnotator
)
;
MOZ_ASSERT
(
numErased
=
=
1
)
;
return
mAnnotators
.
empty
(
)
;
}
HangAnnotations
Annotators
:
:
GatherAnnotations
(
)
{
HangAnnotations
annotations
;
{
MutexAutoLock
lock
(
mMutex
)
;
for
(
std
:
:
set
<
Annotator
*
>
:
:
iterator
i
=
mAnnotators
.
begin
(
)
e
=
mAnnotators
.
end
(
)
;
i
!
=
e
;
+
+
i
)
{
(
*
i
)
-
>
AnnotateHang
(
annotations
)
;
}
}
return
annotations
;
}
}
void
RegisterAnnotator
(
Annotator
&
aAnnotator
)
{
BackgroundHangMonitor
:
:
RegisterAnnotator
(
aAnnotator
)
;
if
(
NS_IsMainThread
(
)
&
&
GeckoProcessType_Default
=
=
XRE_GetProcessType
(
)
)
{
if
(
!
gChromehangAnnotators
)
{
gChromehangAnnotators
=
new
Observer
:
:
Annotators
(
)
;
}
gChromehangAnnotators
-
>
Register
(
aAnnotator
)
;
}
}
void
UnregisterAnnotator
(
Annotator
&
aAnnotator
)
{
BackgroundHangMonitor
:
:
UnregisterAnnotator
(
aAnnotator
)
;
if
(
NS_IsMainThread
(
)
&
&
GeckoProcessType_Default
=
=
XRE_GetProcessType
(
)
)
{
if
(
gChromehangAnnotators
-
>
Unregister
(
aAnnotator
)
)
{
gChromehangAnnotators
=
nullptr
;
}
}
}
HangAnnotations
ChromeHangAnnotatorCallout
(
)
{
if
(
!
gChromehangAnnotators
)
{
return
HangAnnotations
(
)
;
}
return
gChromehangAnnotators
-
>
GatherAnnotations
(
)
;
}
}
}
namespace
IPC
{
using
mozilla
:
:
HangMonitor
:
:
Annotation
;
void
ParamTraits
<
Annotation
>
:
:
Write
(
Message
*
aMsg
const
Annotation
&
aParam
)
{
WriteParam
(
aMsg
aParam
.
mName
)
;
WriteParam
(
aMsg
aParam
.
mValue
)
;
}
bool
ParamTraits
<
Annotation
>
:
:
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
Annotation
*
aResult
)
{
if
(
!
ReadParam
(
aMsg
aIter
&
aResult
-
>
mName
)
)
{
return
false
;
}
if
(
!
ReadParam
(
aMsg
aIter
&
aResult
-
>
mValue
)
)
{
return
false
;
}
return
true
;
}
}
