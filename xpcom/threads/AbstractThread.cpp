#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StateWatching
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
TaskDispatcher
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
namespace
mozilla
{
LazyLogModule
gMozPromiseLog
(
"
MozPromise
"
)
;
LazyLogModule
gStateWatchingLog
(
"
StateWatching
"
)
;
StaticRefPtr
<
AbstractThread
>
sMainThread
;
MOZ_THREAD_LOCAL
(
AbstractThread
*
)
AbstractThread
:
:
sCurrentThreadTLS
;
class
XPCOMThreadWrapper
:
public
AbstractThread
{
public
:
explicit
XPCOMThreadWrapper
(
nsIThread
*
aTarget
bool
aRequireTailDispatch
)
:
AbstractThread
(
aRequireTailDispatch
)
mTarget
(
aTarget
)
{
MOZ_ASSERT_IF
(
aRequireTailDispatch
NS_IsMainThread
(
)
&
&
NS_GetCurrentThread
(
)
=
=
aTarget
)
;
}
virtual
void
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
DispatchFailureHandling
aFailureHandling
=
AssertDispatchSuccess
DispatchReason
aReason
=
NormalDispatch
)
override
{
nsCOMPtr
<
nsIRunnable
>
r
=
aRunnable
;
AbstractThread
*
currentThread
;
if
(
aReason
!
=
TailDispatch
&
&
(
currentThread
=
GetCurrent
(
)
)
&
&
RequiresTailDispatch
(
currentThread
)
)
{
currentThread
-
>
TailDispatcher
(
)
.
AddTask
(
this
r
.
forget
(
)
aFailureHandling
)
;
return
;
}
nsresult
rv
=
mTarget
-
>
Dispatch
(
r
NS_DISPATCH_NORMAL
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aFailureHandling
=
=
DontAssertDispatchSuccess
|
|
NS_SUCCEEDED
(
rv
)
)
;
Unused
<
<
rv
;
}
virtual
bool
IsCurrentThreadIn
(
)
override
{
PRThread
*
thread
=
nullptr
;
mTarget
-
>
GetPRThread
(
&
thread
)
;
bool
in
=
PR_GetCurrentThread
(
)
=
=
thread
;
return
in
;
}
void
FireTailDispatcher
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mTailDispatcher
.
isSome
(
)
)
;
mTailDispatcher
.
ref
(
)
.
DrainDirectTasks
(
)
;
mTailDispatcher
.
reset
(
)
;
}
virtual
TaskDispatcher
&
TailDispatcher
(
)
override
{
MOZ_ASSERT
(
this
=
=
sMainThread
)
;
MOZ_ASSERT
(
IsCurrentThreadIn
(
)
)
;
if
(
!
mTailDispatcher
.
isSome
(
)
)
{
mTailDispatcher
.
emplace
(
true
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
this
&
XPCOMThreadWrapper
:
:
FireTailDispatcher
)
;
nsContentUtils
:
:
RunInStableState
(
event
.
forget
(
)
)
;
}
return
mTailDispatcher
.
ref
(
)
;
}
virtual
bool
MightHaveTailTasks
(
)
override
{
return
mTailDispatcher
.
isSome
(
)
;
}
virtual
nsIThread
*
AsXPCOMThread
(
)
override
{
return
mTarget
;
}
private
:
RefPtr
<
nsIThread
>
mTarget
;
Maybe
<
AutoTaskDispatcher
>
mTailDispatcher
;
}
;
void
AbstractThread
:
:
TailDispatchTasksFor
(
AbstractThread
*
aThread
)
{
if
(
MightHaveTailTasks
(
)
)
{
TailDispatcher
(
)
.
DispatchTasksFor
(
aThread
)
;
}
}
bool
AbstractThread
:
:
HasTailTasksFor
(
AbstractThread
*
aThread
)
{
if
(
!
MightHaveTailTasks
(
)
)
{
return
false
;
}
return
TailDispatcher
(
)
.
HasTasksFor
(
aThread
)
;
}
bool
AbstractThread
:
:
RequiresTailDispatch
(
AbstractThread
*
aThread
)
const
{
MOZ_ASSERT
(
aThread
)
;
return
SupportsTailDispatch
(
)
&
&
aThread
-
>
SupportsTailDispatch
(
)
;
}
bool
AbstractThread
:
:
RequiresTailDispatchFromCurrentThread
(
)
const
{
AbstractThread
*
current
=
GetCurrent
(
)
;
return
current
&
&
RequiresTailDispatch
(
current
)
;
}
AbstractThread
*
AbstractThread
:
:
MainThread
(
)
{
MOZ_ASSERT
(
sMainThread
)
;
return
sMainThread
;
}
void
AbstractThread
:
:
InitStatics
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sMainThread
)
;
nsCOMPtr
<
nsIThread
>
mainThread
;
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mainThread
)
;
sMainThread
=
new
XPCOMThreadWrapper
(
mainThread
.
get
(
)
true
)
;
ClearOnShutdown
(
&
sMainThread
)
;
if
(
!
sCurrentThreadTLS
.
init
(
)
)
{
MOZ_CRASH
(
)
;
}
sCurrentThreadTLS
.
set
(
sMainThread
)
;
}
void
AbstractThread
:
:
DispatchStateChange
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
GetCurrent
(
)
-
>
TailDispatcher
(
)
.
AddStateChangeTask
(
this
Move
(
aRunnable
)
)
;
}
void
AbstractThread
:
:
DispatchDirectTask
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
GetCurrent
(
)
-
>
TailDispatcher
(
)
.
AddDirectTask
(
Move
(
aRunnable
)
)
;
}
already_AddRefed
<
AbstractThread
>
AbstractThread
:
:
CreateXPCOMThreadWrapper
(
nsIThread
*
aThread
bool
aRequireTailDispatch
)
{
RefPtr
<
XPCOMThreadWrapper
>
wrapper
=
new
XPCOMThreadWrapper
(
aThread
aRequireTailDispatch
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
wrapper
]
(
)
{
sCurrentThreadTLS
.
set
(
wrapper
)
;
}
)
;
aThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
return
wrapper
.
forget
(
)
;
}
}
