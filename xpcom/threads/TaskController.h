#
ifndef
mozilla_TaskController_h
#
define
mozilla_TaskController_h
#
include
"
mozilla
/
CondVar
.
h
"
#
include
"
mozilla
/
IdlePeriodState
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
<
atomic
>
#
include
<
memory
>
#
include
<
vector
>
#
include
<
set
>
#
include
<
list
>
#
include
<
stack
>
class
nsIRunnable
;
class
nsIThreadObserver
;
namespace
mozilla
{
class
Task
;
class
TaskController
;
class
PerformanceCounter
;
class
PerformanceCounterState
;
const
EventQueuePriority
kDefaultPriorityValue
=
EventQueuePriority
:
:
Normal
;
class
TaskManager
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
TaskManager
)
TaskManager
(
)
:
mTaskCount
(
0
)
{
}
virtual
bool
IsSuspended
(
const
MutexAutoLock
&
aProofOfLock
)
{
return
false
;
}
virtual
int32_t
GetPriorityModifierForEventLoopTurn
(
const
MutexAutoLock
&
aProofOfLock
)
{
return
0
;
}
void
DidQueueTask
(
)
{
+
+
mTaskCount
;
}
virtual
void
WillRunTask
(
)
{
-
-
mTaskCount
;
}
virtual
void
DidRunTask
(
)
{
}
uint32_t
PendingTaskCount
(
)
{
return
mTaskCount
;
}
protected
:
virtual
~
TaskManager
(
)
{
}
private
:
friend
class
TaskController
;
enum
class
IterationType
{
NOT_EVENT_LOOP_TURN
EVENT_LOOP_TURN
}
;
bool
UpdateCachesForCurrentIterationAndReportPriorityModifierChanged
(
const
MutexAutoLock
&
aProofOfLock
IterationType
aIterationType
)
;
bool
mCurrentSuspended
=
false
;
int32_t
mCurrentPriorityModifier
=
0
;
std
:
:
atomic
<
uint32_t
>
mTaskCount
;
}
;
class
Task
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Task
)
bool
IsMainThreadOnly
(
)
{
return
mMainThreadOnly
;
}
uint32_t
GetPriority
(
)
{
return
mPriority
+
mPriorityModifier
;
}
uint64_t
GetSeqNo
(
)
{
return
mSeqNo
;
}
virtual
void
RequestInterrupt
(
uint32_t
aInterruptPriority
)
{
}
void
AddDependency
(
Task
*
aTask
)
{
MOZ_ASSERT
(
aTask
)
;
MOZ_ASSERT
(
!
mIsInGraph
)
;
mDependencies
.
insert
(
aTask
)
;
}
void
SetManager
(
TaskManager
*
aManager
)
{
MOZ_ASSERT
(
mMainThreadOnly
)
;
MOZ_ASSERT
(
!
mIsInGraph
)
;
mTaskManager
=
aManager
;
}
TaskManager
*
GetManager
(
)
{
return
mTaskManager
;
}
struct
PriorityCompare
{
bool
operator
(
)
(
const
RefPtr
<
Task
>
&
aTaskA
const
RefPtr
<
Task
>
&
aTaskB
)
const
{
uint32_t
prioA
=
aTaskA
-
>
GetPriority
(
)
;
uint32_t
prioB
=
aTaskB
-
>
GetPriority
(
)
;
return
(
prioA
>
prioB
)
|
|
(
prioA
=
=
prioB
&
&
(
aTaskA
-
>
GetSeqNo
(
)
<
aTaskB
-
>
GetSeqNo
(
)
)
)
;
}
}
;
virtual
void
SetIdleDeadline
(
TimeStamp
aDeadline
)
{
}
virtual
PerformanceCounter
*
GetPerformanceCounter
(
)
const
{
return
nullptr
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
virtual
bool
GetName
(
nsACString
&
aName
)
=
0
;
#
else
virtual
bool
GetName
(
nsACString
&
aName
)
{
return
false
;
}
#
endif
protected
:
Task
(
bool
aMainThreadOnly
uint32_t
aPriority
=
static_cast
<
uint32_t
>
(
kDefaultPriorityValue
)
)
:
mMainThreadOnly
(
aMainThreadOnly
)
mSeqNo
(
sCurrentTaskSeqNo
+
+
)
mPriority
(
aPriority
)
{
}
Task
(
bool
aMainThreadOnly
EventQueuePriority
aPriority
=
kDefaultPriorityValue
)
:
mMainThreadOnly
(
aMainThreadOnly
)
mSeqNo
(
sCurrentTaskSeqNo
+
+
)
mPriority
(
static_cast
<
uint32_t
>
(
aPriority
)
)
{
}
virtual
~
Task
(
)
{
}
friend
class
TaskController
;
virtual
bool
Run
(
)
=
0
;
private
:
Task
*
GetHighestPriorityDependency
(
)
;
std
:
:
set
<
RefPtr
<
Task
>
PriorityCompare
>
:
:
iterator
mIterator
;
std
:
:
set
<
RefPtr
<
Task
>
PriorityCompare
>
mDependencies
;
RefPtr
<
TaskManager
>
mTaskManager
;
bool
mMainThreadOnly
;
bool
mCompleted
=
false
;
bool
mInProgress
=
false
;
#
ifdef
DEBUG
bool
mIsInGraph
=
false
;
#
endif
static
std
:
:
atomic
<
uint64_t
>
sCurrentTaskSeqNo
;
int64_t
mSeqNo
;
uint32_t
mPriority
;
int32_t
mPriorityModifier
=
0
;
mozilla
:
:
TimeStamp
mInsertionTime
;
}
;
struct
PoolThread
{
PRThread
*
mThread
;
RefPtr
<
Task
>
mCurrentTask
;
uint32_t
mEffectiveTaskPriority
;
}
;
class
IdleTaskManager
:
public
TaskManager
{
public
:
explicit
IdleTaskManager
(
already_AddRefed
<
nsIIdlePeriod
>
&
&
aIdlePeriod
)
:
mIdlePeriodState
(
std
:
:
move
(
aIdlePeriod
)
)
mProcessedTaskCount
(
0
)
{
}
IdlePeriodState
&
State
(
)
{
return
mIdlePeriodState
;
}
bool
IsSuspended
(
const
MutexAutoLock
&
aProofOfLock
)
override
{
TimeStamp
idleDeadline
=
State
(
)
.
GetCachedIdleDeadline
(
)
;
return
!
idleDeadline
;
}
void
DidRunTask
(
)
override
{
TaskManager
:
:
DidRunTask
(
)
;
+
+
mProcessedTaskCount
;
}
uint64_t
ProcessedTaskCount
(
)
{
return
mProcessedTaskCount
;
}
private
:
IdlePeriodState
mIdlePeriodState
;
std
:
:
atomic
<
uint64_t
>
mProcessedTaskCount
;
}
;
class
TaskController
{
public
:
TaskController
(
)
:
mGraphMutex
(
"
TaskController
:
:
mGraphMutex
"
)
mThreadPoolCV
(
mGraphMutex
"
TaskController
:
:
mThreadPoolCV
"
)
mMainThreadCV
(
mGraphMutex
"
TaskController
:
:
mMainThreadCV
"
)
mRunOutOfMTTasksCounter
(
0
)
{
}
static
TaskController
*
Get
(
)
;
static
bool
Initialize
(
)
;
void
SetThreadObserver
(
nsIThreadObserver
*
aObserver
)
{
MutexAutoLock
lock
(
mGraphMutex
)
;
mObserver
=
aObserver
;
}
void
SetConditionVariable
(
CondVar
*
aExternalCondVar
)
{
mExternalCondVar
=
aExternalCondVar
;
}
void
SetIdleTaskManager
(
IdleTaskManager
*
aIdleTaskManager
)
{
mIdleTaskManager
=
aIdleTaskManager
;
}
IdleTaskManager
*
GetIdleTaskManager
(
)
{
return
mIdleTaskManager
.
get
(
)
;
}
uint64_t
RunOutOfMTTasksCount
(
)
{
return
mRunOutOfMTTasksCounter
;
}
void
SetPerformanceCounterState
(
PerformanceCounterState
*
aPerformanceCounterState
)
;
static
void
Shutdown
(
)
;
void
AddTask
(
already_AddRefed
<
Task
>
&
&
aTask
)
;
void
WaitForTaskOrMessage
(
)
;
void
ExecuteNextTaskOnlyMainThread
(
)
;
void
ProcessPendingMTTask
(
bool
aMayWait
=
false
)
;
void
ReprioritizeTask
(
Task
*
aTask
uint32_t
aPriority
)
;
void
DispatchRunnable
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
uint32_t
aPriority
TaskManager
*
aManager
=
nullptr
)
;
nsIRunnable
*
GetRunnableForMTTask
(
bool
aReallyWait
)
;
bool
HasMainThreadPendingTasks
(
)
;
uint64_t
PendingMainthreadTaskCountIncludingSuspended
(
)
;
bool
MTTaskRunnableProcessedTask
(
)
{
return
mMTTaskRunnableProcessedTask
;
}
static
int32_t
GetPoolThreadCount
(
)
;
static
size_t
GetThreadStackSize
(
)
;
private
:
friend
void
ThreadFuncPoolThread
(
void
*
aIndex
)
;
bool
InitializeInternal
(
)
;
void
InitializeThreadPool
(
)
;
bool
ExecuteNextTaskOnlyMainThreadInternal
(
const
MutexAutoLock
&
aProofOfLock
)
;
bool
DoExecuteNextTaskOnlyMainThreadInternal
(
const
MutexAutoLock
&
aProofOfLock
)
;
Task
*
GetFinalDependency
(
Task
*
aTask
)
;
void
MaybeInterruptTask
(
Task
*
aTask
)
;
Task
*
GetHighestPriorityMTTask
(
)
;
void
EnsureMainThreadTasksScheduled
(
)
;
void
ProcessUpdatedPriorityModifier
(
TaskManager
*
aManager
)
;
void
ShutdownThreadPoolInternal
(
)
;
void
ShutdownInternal
(
)
;
void
RunPoolThread
(
)
;
static
std
:
:
unique_ptr
<
TaskController
>
sSingleton
;
static
StaticMutex
sSingletonMutex
MOZ_UNANNOTATED
;
Mutex
mGraphMutex
MOZ_UNANNOTATED
;
Mutex
mPoolInitializationMutex
=
Mutex
(
"
TaskController
:
:
mPoolInitializationMutex
"
)
;
CondVar
mThreadPoolCV
;
CondVar
mMainThreadCV
;
std
:
:
vector
<
PoolThread
>
mPoolThreads
;
std
:
:
stack
<
RefPtr
<
Task
>
>
mCurrentTasksMT
;
std
:
:
set
<
RefPtr
<
Task
>
Task
:
:
PriorityCompare
>
mThreadableTasks
;
std
:
:
set
<
RefPtr
<
Task
>
Task
:
:
PriorityCompare
>
mMainThreadTasks
;
std
:
:
set
<
TaskManager
*
>
mTaskManagers
;
bool
mMayHaveMainThreadTask
=
true
;
bool
mShuttingDown
=
false
;
bool
mMTTaskRunnableProcessedTask
=
false
;
bool
mThreadPoolInitialized
=
false
;
RefPtr
<
nsIRunnable
>
mMTProcessingRunnable
;
RefPtr
<
nsIRunnable
>
mMTBlockingProcessingRunnable
;
nsIThreadObserver
*
mObserver
=
nullptr
;
CondVar
*
mExternalCondVar
=
nullptr
;
RefPtr
<
IdleTaskManager
>
mIdleTaskManager
;
std
:
:
atomic
<
uint64_t
>
mRunOutOfMTTasksCounter
;
PerformanceCounterState
*
mPerformanceCounterState
=
nullptr
;
}
;
}
#
endif
