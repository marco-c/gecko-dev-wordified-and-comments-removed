#
ifndef
SharedThreadPool_h_
#
define
SharedThreadPool_h_
#
include
<
utility
>
#
include
<
type_traits
>
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
RefCountType
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIThreadPool
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nscore
.
h
"
class
nsIRunnable
;
namespace
mozilla
{
class
SharedThreadPool
:
public
nsIThreadPool
{
public
:
static
already_AddRefed
<
SharedThreadPool
>
Get
(
const
nsCString
&
aName
uint32_t
aThreadLimit
=
4
)
;
NS_IMETHOD
QueryInterface
(
REFNSIID
aIID
void
*
*
aInstancePtr
)
override
;
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
void
)
override
;
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
void
)
override
;
using
HasThreadSafeRefCnt
=
std
:
:
true_type
;
NS_FORWARD_SAFE_NSITHREADPOOL
(
mPool
)
;
nsresult
DispatchFromEndOfTaskInThisPool
(
nsIRunnable
*
event
)
{
return
Dispatch
(
event
NS_DISPATCH_AT_END
)
;
}
NS_IMETHOD
DispatchFromScript
(
nsIRunnable
*
event
uint32_t
flags
)
override
{
return
Dispatch
(
event
flags
)
;
}
NS_IMETHOD
Dispatch
(
already_AddRefed
<
nsIRunnable
>
event
uint32_t
flags
=
NS_DISPATCH_NORMAL
)
override
{
return
!
mPool
?
NS_ERROR_NULL_POINTER
:
mPool
-
>
Dispatch
(
std
:
:
move
(
event
)
flags
)
;
}
NS_IMETHOD
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
uint32_t
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
using
nsIEventTarget
:
:
Dispatch
;
NS_IMETHOD
RegisterShutdownTask
(
nsITargetShutdownTask
*
task
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
UnregisterShutdownTask
(
nsITargetShutdownTask
*
task
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
IsOnCurrentThread
(
bool
*
_retval
)
override
{
return
!
mPool
?
NS_ERROR_NULL_POINTER
:
mPool
-
>
IsOnCurrentThread
(
_retval
)
;
}
NS_IMETHOD_
(
bool
)
IsOnCurrentThreadInfallible
(
)
override
{
return
mPool
&
&
mPool
-
>
IsOnCurrentThread
(
)
;
}
static
void
InitStatics
(
)
;
static
void
SpinUntilEmpty
(
)
;
private
:
static
bool
IsEmpty
(
)
;
SharedThreadPool
(
const
nsCString
&
aName
nsIThreadPool
*
aPool
)
;
virtual
~
SharedThreadPool
(
)
;
nsresult
EnsureThreadLimitIsAtLeast
(
uint32_t
aThreadLimit
)
;
const
nsCString
mName
;
nsCOMPtr
<
nsIThreadPool
>
mPool
;
nsrefcnt
mRefCnt
;
}
;
}
#
endif
