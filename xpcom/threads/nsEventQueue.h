#
ifndef
nsEventQueue_h__
#
define
nsEventQueue_h__
#
include
<
stdlib
.
h
>
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
template
<
typename
MonitorType
>
struct
MonitorAutoEnterChooser
;
template
<
>
struct
MonitorAutoEnterChooser
<
mozilla
:
:
Monitor
>
{
typedef
mozilla
:
:
MonitorAutoLock
Type
;
}
;
template
<
typename
MonitorType
>
class
nsEventQueueBase
{
typedef
mozilla
:
:
MutexAutoLock
MutexAutoLock
;
public
:
typedef
MonitorType
Monitor
;
typedef
typename
MonitorAutoEnterChooser
<
Monitor
>
:
:
Type
MonitorAutoEnterType
;
nsEventQueueBase
(
)
;
~
nsEventQueueBase
(
)
;
void
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
MonitorAutoEnterType
&
aProofOfLock
MutexAutoLock
&
)
;
bool
GetEvent
(
bool
aMayWait
nsIRunnable
*
*
aEvent
MonitorAutoEnterType
&
aProofOfLock
MutexAutoLock
&
)
;
bool
GetPendingEvent
(
nsIRunnable
*
*
aRunnable
MonitorAutoEnterType
&
aProofOfLock
MutexAutoLock
&
aExtraneousLock
)
{
return
GetEvent
(
false
aRunnable
aProofOfLock
aExtraneousLock
)
;
}
size_t
Count
(
MonitorAutoEnterType
&
aProofOfLock
MutexAutoLock
&
)
;
private
:
bool
IsEmpty
(
)
{
return
!
mHead
|
|
(
mHead
=
=
mTail
&
&
mOffsetHead
=
=
mOffsetTail
)
;
}
enum
{
EVENTS_PER_PAGE
=
255
}
;
struct
Page
{
struct
Page
*
mNext
;
nsIRunnable
*
mEvents
[
EVENTS_PER_PAGE
]
;
}
;
static_assert
(
(
sizeof
(
Page
)
&
(
sizeof
(
Page
)
-
1
)
)
=
=
0
"
sizeof
(
Page
)
should
be
a
power
of
two
to
avoid
heap
slop
.
"
)
;
static
Page
*
NewPage
(
)
{
return
static_cast
<
Page
*
>
(
moz_xcalloc
(
1
sizeof
(
Page
)
)
)
;
}
static
void
FreePage
(
Page
*
aPage
)
{
free
(
aPage
)
;
}
Page
*
mHead
;
Page
*
mTail
;
uint16_t
mOffsetHead
;
uint16_t
mOffsetTail
;
}
;
class
nsEventQueue
:
protected
nsEventQueueBase
<
mozilla
:
:
Monitor
>
{
private
:
typedef
nsEventQueueBase
<
mozilla
:
:
Monitor
>
Base
;
friend
class
nsEventQueueBase
<
mozilla
:
:
Monitor
>
;
typedef
mozilla
:
:
MutexAutoLock
MutexAutoLock
;
typedef
Base
:
:
Monitor
MonitorType
;
typedef
Base
:
:
MonitorAutoEnterType
MonitorAutoEnterType
;
MonitorType
mMonitor
;
public
:
nsEventQueue
(
)
;
void
PutEvent
(
nsIRunnable
*
aEvent
MutexAutoLock
&
)
;
void
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
MutexAutoLock
&
)
;
bool
GetEvent
(
bool
aMayWait
nsIRunnable
*
*
aEvent
MutexAutoLock
&
)
;
bool
HasPendingEvent
(
MutexAutoLock
&
aProofOfLock
)
{
return
GetEvent
(
false
nullptr
aProofOfLock
)
;
}
bool
GetPendingEvent
(
nsIRunnable
*
*
aRunnable
MutexAutoLock
&
aProofOfLock
)
{
return
GetEvent
(
false
aRunnable
aProofOfLock
)
;
}
size_t
Count
(
MutexAutoLock
&
)
;
}
;
#
endif
