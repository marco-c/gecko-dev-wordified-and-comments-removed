#
ifndef
nsEventQueue_h__
#
define
nsEventQueue_h__
#
include
<
stdlib
.
h
>
#
include
"
mozilla
/
CondVar
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
class
nsThreadPool
;
class
nsEventQueue
{
public
:
typedef
mozilla
:
:
MutexAutoLock
MutexAutoLock
;
nsEventQueue
(
mozilla
:
:
Mutex
&
aLock
)
;
~
nsEventQueue
(
)
;
void
PutEvent
(
nsIRunnable
*
aEvent
MutexAutoLock
&
aProofOfLock
)
;
void
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
MutexAutoLock
&
aProofOfLock
)
;
bool
GetEvent
(
bool
aMayWait
nsIRunnable
*
*
aEvent
MutexAutoLock
&
aProofOfLock
)
;
bool
HasPendingEvent
(
MutexAutoLock
&
aProofOfLock
)
{
return
GetEvent
(
false
nullptr
aProofOfLock
)
;
}
bool
GetPendingEvent
(
nsIRunnable
*
*
aRunnable
MutexAutoLock
&
aProofOfLock
)
{
return
GetEvent
(
false
aRunnable
aProofOfLock
)
;
}
size_t
Count
(
MutexAutoLock
&
)
;
private
:
bool
IsEmpty
(
)
{
return
!
mHead
|
|
(
mHead
=
=
mTail
&
&
mOffsetHead
=
=
mOffsetTail
)
;
}
enum
{
EVENTS_PER_PAGE
=
255
}
;
struct
Page
{
struct
Page
*
mNext
;
nsIRunnable
*
mEvents
[
EVENTS_PER_PAGE
]
;
}
;
static_assert
(
(
sizeof
(
Page
)
&
(
sizeof
(
Page
)
-
1
)
)
=
=
0
"
sizeof
(
Page
)
should
be
a
power
of
two
to
avoid
heap
slop
.
"
)
;
static
Page
*
NewPage
(
)
{
return
static_cast
<
Page
*
>
(
moz_xcalloc
(
1
sizeof
(
Page
)
)
)
;
}
static
void
FreePage
(
Page
*
aPage
)
{
free
(
aPage
)
;
}
Page
*
mHead
;
Page
*
mTail
;
uint16_t
mOffsetHead
;
uint16_t
mOffsetTail
;
mozilla
:
:
CondVar
mEventsAvailable
;
friend
class
nsThreadPool
;
void
Wait
(
PRIntervalTime
aInterval
)
{
mEventsAvailable
.
Wait
(
aInterval
)
;
}
void
NotifyAll
(
)
{
mEventsAvailable
.
NotifyAll
(
)
;
}
}
;
#
endif
