#
ifndef
mozilla_PrioritizedEventQueue_h
#
define
mozilla_PrioritizedEventQueue_h
#
include
"
mozilla
/
AbstractEventQueue
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
IdlePeriodState
.
h
"
#
include
"
mozilla
/
TaskController
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
class
nsIIdlePeriod
;
class
nsIRunnable
;
namespace
mozilla
{
namespace
ipc
{
class
IdleSchedulerChild
;
}
class
InputTaskManager
:
public
TaskManager
{
public
:
InputTaskManager
(
)
:
mInputQueueState
(
STATE_DISABLED
)
{
}
int32_t
GetPriorityModifierForEventLoopTurn
(
const
MutexAutoLock
&
aProofOfLock
)
final
;
void
WillRunTask
(
)
final
;
void
DidRunTask
(
)
final
;
enum
InputEventQueueState
{
STATE_DISABLED
STATE_FLUSHING
STATE_SUSPEND
STATE_ENABLED
}
;
void
EnableInputEventPrioritization
(
)
;
void
FlushInputEventPrioritization
(
)
;
void
SuspendInputEventPrioritization
(
)
;
void
ResumeInputEventPrioritization
(
)
;
InputEventQueueState
State
(
)
{
return
mInputQueueState
;
}
void
SetState
(
InputEventQueueState
aState
)
{
mInputQueueState
=
aState
;
}
TimeStamp
InputHandlingStartTime
(
)
{
return
mInputHandlingStartTime
;
}
void
SetInputHandlingStartTime
(
TimeStamp
aStartTime
)
{
mInputHandlingStartTime
=
aStartTime
;
}
private
:
TimeStamp
mInputHandlingStartTime
;
Atomic
<
InputEventQueueState
>
mInputQueueState
;
AutoTArray
<
TimeStamp
4
>
mStartTimes
;
}
;
class
PrioritizedEventQueue
final
:
public
AbstractEventQueue
{
public
:
static
const
bool
SupportsPrioritization
=
true
;
explicit
PrioritizedEventQueue
(
already_AddRefed
<
nsIIdlePeriod
>
&
&
aIdlePeriod
)
;
virtual
~
PrioritizedEventQueue
(
)
;
void
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventQueuePriority
aPriority
const
MutexAutoLock
&
aProofOfLock
mozilla
:
:
TimeDuration
*
aDelay
=
nullptr
)
final
;
already_AddRefed
<
nsIRunnable
>
GetEvent
(
EventQueuePriority
*
aPriority
const
MutexAutoLock
&
aProofOfLock
TimeDuration
*
aHypotheticalInputEventDelay
=
nullptr
)
final
;
already_AddRefed
<
nsIRunnable
>
GetEvent
(
EventQueuePriority
*
aPriority
const
MutexAutoLock
&
aProofOfLock
TimeDuration
*
aHypotheticalInputEventDelay
bool
*
aIsIdleEvent
)
;
void
DidRunEvent
(
const
MutexAutoLock
&
aProofOfLock
)
;
bool
IsEmpty
(
const
MutexAutoLock
&
aProofOfLock
)
final
;
size_t
Count
(
const
MutexAutoLock
&
aProofOfLock
)
const
final
;
bool
HasReadyEvent
(
const
MutexAutoLock
&
aProofOfLock
)
final
;
bool
HasPendingHighPriorityEvents
(
const
MutexAutoLock
&
aProofOfLock
)
final
;
void
SetMutexRef
(
Mutex
&
aMutex
)
{
mMutex
=
&
aMutex
;
}
void
EnableInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
final
{
mInputTaskManager
-
>
EnableInputEventPrioritization
(
)
;
}
void
FlushInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
final
{
mInputTaskManager
-
>
FlushInputEventPrioritization
(
)
;
}
void
SuspendInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
final
{
mInputTaskManager
-
>
SuspendInputEventPrioritization
(
)
;
}
void
ResumeInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
final
{
mInputTaskManager
-
>
ResumeInputEventPrioritization
(
)
;
}
IdlePeriodState
*
GetIdlePeriodState
(
)
{
return
&
mIdleTaskManager
-
>
State
(
)
;
}
bool
HasIdleRunnables
(
const
MutexAutoLock
&
aProofOfLock
)
const
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
n
=
0
;
n
+
=
mHighQueue
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
n
+
=
mInputQueue
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
n
+
=
mMediumHighQueue
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
n
+
=
mNormalQueue
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
n
+
=
mDeferredTimersQueue
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
n
+
=
mIdleQueue
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
n
+
=
mIdleTaskManager
-
>
State
(
)
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
return
n
;
}
private
:
EventQueuePriority
SelectQueue
(
bool
aUpdateState
const
MutexAutoLock
&
aProofOfLock
)
;
void
IndirectlyQueueRunnable
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventQueuePriority
aPriority
const
MutexAutoLock
&
aProofOfLock
mozilla
:
:
TimeDuration
*
aDelay
)
;
UniquePtr
<
EventQueue
>
mHighQueue
;
UniquePtr
<
EventQueueSized
<
32
>
>
mInputQueue
;
UniquePtr
<
EventQueue
>
mMediumHighQueue
;
UniquePtr
<
EventQueueSized
<
64
>
>
mNormalQueue
;
UniquePtr
<
EventQueue
>
mDeferredTimersQueue
;
UniquePtr
<
EventQueue
>
mIdleQueue
;
Mutex
*
mMutex
=
nullptr
;
TimeDuration
mLastEventDelay
;
TimeStamp
mLastEventStart
;
RefPtr
<
InputTaskManager
>
mInputTaskManager
;
RefPtr
<
IdleTaskManager
>
mIdleTaskManager
;
}
;
}
#
endif
