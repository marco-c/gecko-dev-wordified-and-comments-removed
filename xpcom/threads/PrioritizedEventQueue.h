#
ifndef
mozilla_PrioritizedEventQueue_h
#
define
mozilla_PrioritizedEventQueue_h
#
include
"
mozilla
/
AbstractEventQueue
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIIdlePeriod
.
h
"
class
nsIRunnable
;
namespace
mozilla
{
template
<
class
InnerQueueT
>
class
PrioritizedEventQueue
final
:
public
AbstractEventQueue
{
public
:
PrioritizedEventQueue
(
UniquePtr
<
InnerQueueT
>
aHighQueue
UniquePtr
<
InnerQueueT
>
aInputQueue
UniquePtr
<
InnerQueueT
>
aNormalQueue
UniquePtr
<
InnerQueueT
>
aIdleQueue
already_AddRefed
<
nsIIdlePeriod
>
aIdlePeriod
)
;
void
PutEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
EventPriority
aPriority
const
MutexAutoLock
&
aProofOfLock
)
final
;
already_AddRefed
<
nsIRunnable
>
GetEvent
(
EventPriority
*
aPriority
const
MutexAutoLock
&
aProofOfLock
)
final
;
bool
HasPendingEvent
(
const
MutexAutoLock
&
aProofOfLock
)
final
;
size_t
Count
(
const
MutexAutoLock
&
aProofOfLock
)
const
final
;
void
SetMutexRef
(
Mutex
&
aMutex
)
{
mMutex
=
&
aMutex
;
}
void
SetNextIdleDeadlineRef
(
TimeStamp
&
aDeadline
)
{
mNextIdleDeadline
=
&
aDeadline
;
}
void
EnableInputEventPrioritization
(
const
MutexAutoLock
&
aProofOfLock
)
final
;
private
:
class
EnablePrioritizationRunnable
;
mozilla
:
:
TimeStamp
GetIdleDeadline
(
)
;
UniquePtr
<
InnerQueueT
>
mHighQueue
;
UniquePtr
<
InnerQueueT
>
mInputQueue
;
UniquePtr
<
InnerQueueT
>
mNormalQueue
;
UniquePtr
<
InnerQueueT
>
mIdleQueue
;
Mutex
*
mMutex
=
nullptr
;
TimeStamp
*
mNextIdleDeadline
=
nullptr
;
bool
mProcessHighPriorityQueue
=
false
;
nsCOMPtr
<
nsIIdlePeriod
>
mIdlePeriod
;
bool
mHasPendingEventsPromisedIdleEvent
=
false
;
TimeStamp
mInputHandlingStartTime
;
bool
mWriteToInputQueue
=
false
;
bool
mReadFromInputQueue
=
false
;
}
;
class
EventQueue
;
extern
template
class
PrioritizedEventQueue
<
EventQueue
>
;
}
#
endif
