#
ifndef
DataMutex_h__
#
define
DataMutex_h__
#
include
<
utility
>
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
namespace
mozilla
{
template
<
typename
T
typename
MutexType
>
class
DataMutexBase
{
public
:
class
MOZ_STACK_CLASS
AutoLock
{
public
:
T
*
operator
-
>
(
)
const
&
{
return
&
ref
(
)
;
}
T
*
operator
-
>
(
)
const
&
&
=
delete
;
T
&
operator
*
(
)
const
&
{
return
ref
(
)
;
}
T
&
operator
*
(
)
const
&
&
=
delete
;
operator
T
*
(
)
const
&
{
return
&
ref
(
)
;
}
operator
T
*
(
)
const
&
&
=
delete
;
T
&
ref
(
)
const
&
{
MOZ_ASSERT
(
mOwner
)
;
return
mOwner
-
>
mValue
;
}
T
&
ref
(
)
const
&
&
=
delete
;
AutoLock
(
AutoLock
&
&
aOther
)
:
mOwner
(
aOther
.
mOwner
)
{
aOther
.
mOwner
=
nullptr
;
}
~
AutoLock
(
)
{
if
(
mOwner
)
{
mOwner
-
>
mMutex
.
Unlock
(
)
;
mOwner
=
nullptr
;
}
}
private
:
friend
class
DataMutexBase
;
AutoLock
(
const
AutoLock
&
aOther
)
=
delete
;
explicit
AutoLock
(
DataMutexBase
<
T
MutexType
>
*
aDataMutex
)
:
mOwner
(
aDataMutex
)
{
MOZ_ASSERT
(
!
!
mOwner
)
;
mOwner
-
>
mMutex
.
Lock
(
)
;
}
DataMutexBase
<
T
MutexType
>
*
mOwner
;
}
;
explicit
DataMutexBase
(
const
char
*
aName
)
:
mMutex
(
aName
)
{
}
DataMutexBase
(
T
&
&
aValue
const
char
*
aName
)
:
mMutex
(
aName
)
mValue
(
std
:
:
move
(
aValue
)
)
{
}
AutoLock
Lock
(
)
{
return
AutoLock
(
this
)
;
}
private
:
MutexType
mMutex
;
T
mValue
;
}
;
class
StaticMutexNameless
:
public
StaticMutex
{
public
:
explicit
StaticMutexNameless
(
const
char
*
aName
)
:
StaticMutex
(
)
{
}
private
:
#
ifdef
DEBUG
StaticMutexNameless
(
StaticMutexNameless
&
aOther
)
;
#
endif
StaticMutexNameless
&
operator
=
(
StaticMutexNameless
*
aRhs
)
;
static
void
*
operator
new
(
size_t
)
noexcept
(
true
)
;
static
void
operator
delete
(
void
*
)
;
}
;
template
<
typename
T
>
using
DataMutex
=
DataMutexBase
<
T
Mutex
>
;
template
<
typename
T
>
using
StaticDataMutex
=
DataMutexBase
<
T
StaticMutexNameless
>
;
}
#
endif
