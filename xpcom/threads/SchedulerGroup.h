#
ifndef
mozilla_SchedulerGroup_h
#
define
mozilla_SchedulerGroup_h
#
include
"
mozilla
/
AbstractEventQueue
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Queue
.
h
"
#
include
"
mozilla
/
TaskCategory
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsILabelableRunnable
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsThreadUtils
.
h
"
class
nsIEventTarget
;
class
nsIRunnable
;
class
nsISerialEventTarget
;
namespace
mozilla
{
class
AbstractThread
;
namespace
dom
{
class
DocGroup
;
class
TabGroup
;
}
#
define
NS_SCHEDULERGROUPRUNNABLE_IID
\
{
0xd31b7420
0x872b
0x4cfb
\
{
0xa9
0xc6
0xae
0x4c
0x0f
0x06
0x36
0x74
}
}
class
SchedulerGroup
:
public
LinkedListElement
<
SchedulerGroup
>
{
public
:
SchedulerGroup
(
)
;
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
bool
IsBackground
(
)
const
{
return
false
;
}
bool
IsSafeToRun
(
)
const
{
return
!
sTlsValidatingAccess
.
get
(
)
|
|
mIsRunning
;
}
static
bool
IsSafeToRunUnlabeled
(
)
{
return
!
sTlsValidatingAccess
.
get
(
)
;
}
void
ValidateAccess
(
)
const
{
MOZ_ASSERT
(
IsSafeToRun
(
)
)
;
}
enum
EnqueueStatus
{
NewlyQueued
AlreadyQueued
}
;
EnqueueStatus
EnqueueEvent
(
)
{
mEventCount
+
+
;
return
mEventCount
=
=
1
?
NewlyQueued
:
AlreadyQueued
;
}
enum
DequeueStatus
{
StillQueued
NoLongerQueued
}
;
DequeueStatus
DequeueEvent
(
)
{
mEventCount
-
-
;
return
mEventCount
=
=
0
?
NoLongerQueued
:
StillQueued
;
}
class
Runnable
final
:
public
mozilla
:
:
Runnable
public
nsIRunnablePriority
public
nsILabelableRunnable
{
public
:
Runnable
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
SchedulerGroup
*
aGroup
dom
:
:
DocGroup
*
aDocGroup
)
;
bool
GetAffectedSchedulerGroups
(
SchedulerGroupSet
&
aGroups
)
override
;
SchedulerGroup
*
Group
(
)
const
{
return
mGroup
;
}
dom
:
:
DocGroup
*
DocGroup
(
)
const
;
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
;
#
endif
bool
IsBackground
(
)
const
{
return
mGroup
-
>
IsBackground
(
)
;
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIRUNNABLE
NS_DECL_NSIRUNNABLEPRIORITY
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_SCHEDULERGROUPRUNNABLE_IID
)
;
private
:
friend
class
SchedulerGroup
;
~
Runnable
(
)
=
default
;
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
RefPtr
<
SchedulerGroup
>
mGroup
;
RefPtr
<
dom
:
:
DocGroup
>
mDocGroup
;
}
;
friend
class
Runnable
;
bool
*
GetValidAccessPtr
(
)
{
return
&
mIsRunning
;
}
virtual
nsresult
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
virtual
nsISerialEventTarget
*
EventTargetFor
(
TaskCategory
aCategory
)
const
;
AbstractThread
*
AbstractMainThreadFor
(
TaskCategory
aCategory
)
;
virtual
dom
:
:
TabGroup
*
AsTabGroup
(
)
{
return
nullptr
;
}
static
nsresult
UnlabeledDispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
static
void
MarkVsyncReceived
(
)
;
static
void
MarkVsyncRan
(
)
;
void
SetIsRunning
(
bool
aIsRunning
)
{
mIsRunning
=
aIsRunning
;
}
bool
IsRunning
(
)
const
{
return
mIsRunning
;
}
enum
ValidationType
{
StartValidation
EndValidation
}
;
static
void
SetValidatingAccess
(
ValidationType
aType
)
;
struct
EpochQueueEntry
{
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
uintptr_t
mEpochNumber
;
EpochQueueEntry
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uintptr_t
aEpoch
)
:
mRunnable
(
aRunnable
)
mEpochNumber
(
aEpoch
)
{
}
}
;
using
RunnableEpochQueue
=
Queue
<
EpochQueueEntry
32
>
;
RunnableEpochQueue
&
GetQueue
(
mozilla
:
:
EventPriority
aPriority
)
{
return
mEventQueues
[
size_t
(
aPriority
)
]
;
}
protected
:
nsresult
DispatchWithDocGroup
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
dom
:
:
DocGroup
*
aDocGroup
)
;
static
nsresult
InternalUnlabeledDispatch
(
TaskCategory
aCategory
already_AddRefed
<
Runnable
>
&
&
aRunnable
)
;
virtual
AbstractThread
*
AbstractMainThreadForImpl
(
TaskCategory
aCategory
)
;
virtual
already_AddRefed
<
nsISerialEventTarget
>
CreateEventTargetFor
(
TaskCategory
aCategory
)
;
static
SchedulerGroup
*
FromEventTarget
(
nsIEventTarget
*
aEventTarget
)
;
nsresult
LabeledDispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
dom
:
:
DocGroup
*
aDocGroup
)
;
void
CreateEventTargets
(
bool
aNeedValidation
)
;
void
Shutdown
(
bool
aXPCOMShutdown
)
;
static
MOZ_THREAD_LOCAL
(
bool
)
sTlsValidatingAccess
;
bool
mIsRunning
;
size_t
mEventCount
=
0
;
nsCOMPtr
<
nsISerialEventTarget
>
mEventTargets
[
size_t
(
TaskCategory
:
:
Count
)
]
;
RefPtr
<
AbstractThread
>
mAbstractThreads
[
size_t
(
TaskCategory
:
:
Count
)
]
;
RunnableEpochQueue
mEventQueues
[
size_t
(
mozilla
:
:
EventPriority
:
:
Count
)
]
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
SchedulerGroup
:
:
Runnable
NS_SCHEDULERGROUPRUNNABLE_IID
)
;
}
#
endif
