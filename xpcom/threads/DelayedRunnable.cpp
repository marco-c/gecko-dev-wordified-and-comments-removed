#
include
"
DelayedRunnable
.
h
"
#
include
"
mozilla
/
ProfilerRunnable
.
h
"
namespace
mozilla
{
DelayedRunnable
:
:
DelayedRunnable
(
already_AddRefed
<
nsISerialEventTarget
>
aTarget
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aDelay
)
:
mozilla
:
:
Runnable
(
"
DelayedRunnable
"
)
mTarget
(
aTarget
)
mDelayedFrom
(
TimeStamp
:
:
NowLoRes
(
)
)
mDelay
(
aDelay
)
mWrappedRunnable
(
aRunnable
)
{
}
nsresult
DelayedRunnable
:
:
Init
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mWrappedRunnable
)
{
MOZ_ASSERT_UNREACHABLE
(
)
;
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
mTarget
-
>
RegisterShutdownTask
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
rv
=
=
NS_ERROR_UNEXPECTED
"
DelayedRunnable
target
must
support
RegisterShutdownTask
"
)
;
NS_WARNING
(
"
DelayedRunnable
init
after
target
is
shutdown
"
)
;
return
rv
;
}
rv
=
NS_NewTimerWithCallback
(
getter_AddRefs
(
mTimer
)
this
mDelay
nsITimer
:
:
TYPE_ONE_SHOT
mTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mTarget
-
>
UnregisterShutdownTask
(
this
)
;
}
return
rv
;
}
NS_IMETHODIMP
DelayedRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
mTarget
-
>
IsOnCurrentThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mTimer
"
Init
(
)
must
have
been
called
"
)
;
if
(
!
mWrappedRunnable
)
{
return
NS_OK
;
}
if
(
(
mozilla
:
:
TimeStamp
:
:
NowLoRes
(
)
-
mDelayedFrom
)
.
ToMilliseconds
(
)
<
mDelay
)
{
return
NS_OK
;
}
mTimer
-
>
Cancel
(
)
;
mTarget
-
>
UnregisterShutdownTask
(
this
)
;
runnable
=
mWrappedRunnable
.
forget
(
)
;
}
AUTO_PROFILE_FOLLOWING_RUNNABLE
(
runnable
)
;
return
runnable
-
>
Run
(
)
;
}
NS_IMETHODIMP
DelayedRunnable
:
:
Notify
(
nsITimer
*
aTimer
)
{
MOZ_ASSERT
(
mTarget
-
>
IsOnCurrentThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mTimer
"
Init
(
)
must
have
been
called
"
)
;
if
(
!
mWrappedRunnable
)
{
return
NS_OK
;
}
mTarget
-
>
UnregisterShutdownTask
(
this
)
;
runnable
=
mWrappedRunnable
.
forget
(
)
;
}
AUTO_PROFILE_FOLLOWING_RUNNABLE
(
runnable
)
;
return
runnable
-
>
Run
(
)
;
}
void
DelayedRunnable
:
:
TargetShutdown
(
)
{
MOZ_ASSERT
(
mTarget
-
>
IsOnCurrentThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mWrappedRunnable
)
{
return
;
}
mWrappedRunnable
=
nullptr
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
}
NS_IMPL_ISUPPORTS_INHERITED
(
DelayedRunnable
Runnable
nsITimerCallback
nsITargetShutdownTask
)
}
