#
include
"
ThreadEventTarget
.
h
"
#
include
"
mozilla
/
ThreadEventQueue
.
h
"
#
include
"
LeakRefPtr
.
h
"
#
include
"
mozilla
/
DelayedRunnable
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsThreadSyncDispatch
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
ThreadDelay
.
h
"
using
namespace
mozilla
;
#
ifdef
DEBUG
static
mozilla
:
:
Atomic
<
bool
mozilla
:
:
SequentiallyConsistent
>
gXPCOMThreadsShutDownNotified
(
false
)
;
#
endif
ThreadEventTarget
:
:
ThreadEventTarget
(
ThreadTargetSink
*
aSink
bool
aIsMainThread
bool
aBlockDispatch
)
:
mSink
(
aSink
)
#
ifdef
DEBUG
mIsMainThread
(
aIsMainThread
)
#
endif
mBlockDispatch
(
aBlockDispatch
)
{
mThread
=
PR_GetCurrentThread
(
)
;
}
ThreadEventTarget
:
:
~
ThreadEventTarget
(
)
=
default
;
void
ThreadEventTarget
:
:
SetCurrentThread
(
PRThread
*
aThread
)
{
mThread
=
aThread
;
}
void
ThreadEventTarget
:
:
ClearCurrentThread
(
)
{
mThread
=
nullptr
;
}
NS_IMPL_ISUPPORTS
(
ThreadEventTarget
nsIEventTarget
nsISerialEventTarget
)
NS_IMETHODIMP
ThreadEventTarget
:
:
DispatchFromScript
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
)
{
return
Dispatch
(
do_AddRef
(
aRunnable
)
aFlags
)
;
}
#
ifdef
DEBUG
void
ThreadEventTarget
:
:
XPCOMShutdownThreadsNotificationFinished
(
)
{
gXPCOMThreadsShutDownNotified
=
true
;
}
#
endif
NS_IMETHODIMP
ThreadEventTarget
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
LeakRefPtr
<
nsIRunnable
>
event
(
std
:
:
move
(
aEvent
)
)
;
if
(
NS_WARN_IF
(
!
event
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
NS_ASSERTION
(
!
gXPCOMThreadsShutDownNotified
|
|
mIsMainThread
|
|
PR_GetCurrentThread
(
)
=
=
mThread
"
Dispatch
to
non
-
main
thread
after
xpcom
-
shutdown
-
threads
"
)
;
if
(
mBlockDispatch
&
&
!
(
aFlags
&
NS_DISPATCH_IGNORE_BLOCK_DISPATCH
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Attempt
to
dispatch
to
thread
which
does
not
usually
process
"
"
dispatched
runnables
until
shutdown
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
LogRunnable
:
:
LogDispatch
(
event
.
get
(
)
)
;
if
(
aFlags
&
DISPATCH_SYNC
)
{
nsCOMPtr
<
nsIEventTarget
>
current
=
GetCurrentEventTarget
(
)
;
if
(
NS_WARN_IF
(
!
current
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
nsThreadSyncDispatch
>
wrapper
=
new
nsThreadSyncDispatch
(
current
.
forget
(
)
event
.
take
(
)
)
;
bool
success
=
mSink
-
>
PutEvent
(
do_AddRef
(
wrapper
)
EventQueuePriority
:
:
Normal
)
;
if
(
!
success
)
{
wrapper
.
get
(
)
-
>
Release
(
)
;
return
NS_ERROR_UNEXPECTED
;
}
SpinEventLoopUntil
(
"
ThreadEventTarget
:
:
Dispatch
"
_ns
[
&
wrapper
]
(
)
-
>
bool
{
return
!
wrapper
-
>
IsPending
(
)
;
}
)
;
return
NS_OK
;
}
NS_ASSERTION
(
(
aFlags
&
(
NS_DISPATCH_AT_END
|
NS_DISPATCH_IGNORE_BLOCK_DISPATCH
)
)
=
=
aFlags
"
unexpected
dispatch
flags
"
)
;
if
(
!
mSink
-
>
PutEvent
(
event
.
take
(
)
EventQueuePriority
:
:
Normal
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
DelayForChaosMode
(
ChaosFeature
:
:
TaskDispatching
1000
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aDelayMs
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
aEvent
;
NS_ENSURE_TRUE
(
!
!
aDelayMs
NS_ERROR_UNEXPECTED
)
;
RefPtr
<
DelayedRunnable
>
r
=
new
DelayedRunnable
(
do_AddRef
(
this
)
event
.
forget
(
)
aDelayMs
)
;
nsresult
rv
=
r
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
RegisterShutdownTask
(
nsITargetShutdownTask
*
aTask
)
{
return
mSink
-
>
RegisterShutdownTask
(
aTask
)
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
UnregisterShutdownTask
(
nsITargetShutdownTask
*
aTask
)
{
return
mSink
-
>
UnregisterShutdownTask
(
aTask
)
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
IsOnCurrentThread
(
bool
*
aIsOnCurrentThread
)
{
*
aIsOnCurrentThread
=
IsOnCurrentThread
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
bool
)
ThreadEventTarget
:
:
IsOnCurrentThreadInfallible
(
)
{
return
false
;
}
