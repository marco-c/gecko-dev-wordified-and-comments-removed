#
include
"
ThreadEventTarget
.
h
"
#
include
"
mozilla
/
ThreadEventQueue
.
h
"
#
include
"
MaybeLeakRefPtr
.
h
"
#
include
"
mozilla
/
DelayedRunnable
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsThreadSyncDispatch
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
ThreadDelay
.
h
"
using
namespace
mozilla
;
#
ifdef
DEBUG
static
mozilla
:
:
Atomic
<
bool
mozilla
:
:
SequentiallyConsistent
>
gXPCOMThreadsShutDownNotified
(
false
)
;
#
endif
ThreadEventTarget
:
:
ThreadEventTarget
(
ThreadTargetSink
*
aSink
bool
aIsMainThread
bool
aBlockDispatch
)
:
mSink
(
aSink
)
#
ifdef
DEBUG
mIsMainThread
(
aIsMainThread
)
#
endif
mBlockDispatch
(
aBlockDispatch
)
{
mThread
=
PR_GetCurrentThread
(
)
;
}
ThreadEventTarget
:
:
~
ThreadEventTarget
(
)
=
default
;
void
ThreadEventTarget
:
:
SetCurrentThread
(
PRThread
*
aThread
)
{
mThread
=
aThread
;
}
void
ThreadEventTarget
:
:
ClearCurrentThread
(
)
{
mThread
=
nullptr
;
}
NS_IMPL_ISUPPORTS
(
ThreadEventTarget
nsIEventTarget
nsISerialEventTarget
)
NS_IMETHODIMP
ThreadEventTarget
:
:
DispatchFromScript
(
nsIRunnable
*
aRunnable
DispatchFlags
aFlags
)
{
return
Dispatch
(
do_AddRef
(
aRunnable
)
aFlags
)
;
}
#
ifdef
DEBUG
void
ThreadEventTarget
:
:
XPCOMShutdownThreadsNotificationFinished
(
)
{
gXPCOMThreadsShutDownNotified
=
true
;
}
#
endif
NS_IMETHODIMP
ThreadEventTarget
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
DispatchFlags
aFlags
)
{
MaybeLeakRefPtr
<
nsIRunnable
>
event
(
std
:
:
move
(
aEvent
)
aFlags
&
NS_DISPATCH_FALLIBLE
)
;
if
(
NS_WARN_IF
(
!
event
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
NS_ASSERTION
(
!
gXPCOMThreadsShutDownNotified
|
|
mIsMainThread
|
|
PR_GetCurrentThread
(
)
=
=
mThread
|
|
(
aFlags
&
NS_DISPATCH_IGNORE_BLOCK_DISPATCH
)
|
|
(
aFlags
&
NS_DISPATCH_FALLIBLE
)
"
Infallible
dispatch
to
non
-
main
thread
after
xpcom
-
shutdown
-
threads
"
)
;
if
(
mBlockDispatch
&
&
!
(
aFlags
&
NS_DISPATCH_IGNORE_BLOCK_DISPATCH
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aFlags
&
NS_DISPATCH_FALLIBLE
"
Attempt
to
dispatch
to
thread
which
does
not
usually
process
"
"
dispatched
runnables
until
shutdown
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
LogRunnable
:
:
LogDispatch
(
event
.
get
(
)
)
;
if
(
!
mSink
-
>
PutEvent
(
event
EventQueuePriority
:
:
Normal
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
DelayForChaosMode
(
ChaosFeature
:
:
TaskDispatching
1000
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aDelayMs
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
aEvent
;
NS_ENSURE_TRUE
(
!
!
aDelayMs
NS_ERROR_UNEXPECTED
)
;
RefPtr
<
DelayedRunnable
>
r
=
new
DelayedRunnable
(
do_AddRef
(
this
)
event
.
forget
(
)
aDelayMs
)
;
nsresult
rv
=
r
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
RegisterShutdownTask
(
nsITargetShutdownTask
*
aTask
)
{
return
mSink
-
>
RegisterShutdownTask
(
aTask
)
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
UnregisterShutdownTask
(
nsITargetShutdownTask
*
aTask
)
{
return
mSink
-
>
UnregisterShutdownTask
(
aTask
)
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
IsOnCurrentThread
(
bool
*
aIsOnCurrentThread
)
{
*
aIsOnCurrentThread
=
IsOnCurrentThread
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
bool
)
ThreadEventTarget
:
:
IsOnCurrentThreadInfallible
(
)
{
return
false
;
}
