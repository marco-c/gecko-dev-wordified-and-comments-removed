#
include
"
ThreadEventTarget
.
h
"
#
include
"
mozilla
/
ThreadEventQueue
.
h
"
#
include
"
LeakRefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsThreadSyncDispatch
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
ThreadDelay
.
h
"
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
include
"
TracedTaskCommon
.
h
"
using
namespace
mozilla
:
:
tasktracer
;
#
endif
using
namespace
mozilla
;
namespace
{
class
DelayedRunnable
:
public
Runnable
public
nsITimerCallback
{
public
:
DelayedRunnable
(
already_AddRefed
<
nsIEventTarget
>
aTarget
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aDelay
)
:
mozilla
:
:
Runnable
(
"
DelayedRunnable
"
)
mTarget
(
aTarget
)
mWrappedRunnable
(
aRunnable
)
mDelayedFrom
(
TimeStamp
:
:
NowLoRes
(
)
)
mDelay
(
aDelay
)
{
}
NS_DECL_ISUPPORTS_INHERITED
nsresult
Init
(
)
{
return
NS_NewTimerWithCallback
(
getter_AddRefs
(
mTimer
)
this
mDelay
nsITimer
:
:
TYPE_ONE_SHOT
mTarget
)
;
}
nsresult
DoRun
(
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
mWrappedRunnable
.
forget
(
)
;
return
r
-
>
Run
(
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
!
mWrappedRunnable
)
{
return
NS_OK
;
}
if
(
(
TimeStamp
:
:
NowLoRes
(
)
-
mDelayedFrom
)
.
ToMilliseconds
(
)
<
mDelay
)
{
return
NS_OK
;
}
mTimer
-
>
Cancel
(
)
;
return
DoRun
(
)
;
}
NS_IMETHOD
Notify
(
nsITimer
*
aTimer
)
override
{
MOZ_ASSERT
(
mWrappedRunnable
)
;
MOZ_ASSERT
(
aTimer
=
=
mTimer
)
;
return
DoRun
(
)
;
}
private
:
~
DelayedRunnable
(
)
{
}
nsCOMPtr
<
nsIEventTarget
>
mTarget
;
nsCOMPtr
<
nsIRunnable
>
mWrappedRunnable
;
nsCOMPtr
<
nsITimer
>
mTimer
;
TimeStamp
mDelayedFrom
;
uint32_t
mDelay
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
DelayedRunnable
Runnable
nsITimerCallback
)
}
ThreadEventTarget
:
:
ThreadEventTarget
(
ThreadTargetSink
*
aSink
bool
aIsMainThread
)
:
mSink
(
aSink
)
mIsMainThread
(
aIsMainThread
)
{
mThread
=
PR_GetCurrentThread
(
)
;
}
void
ThreadEventTarget
:
:
SetCurrentThread
(
)
{
mThread
=
PR_GetCurrentThread
(
)
;
}
NS_IMPL_ISUPPORTS
(
ThreadEventTarget
nsIEventTarget
nsISerialEventTarget
)
NS_IMETHODIMP
ThreadEventTarget
:
:
DispatchFromScript
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
)
{
return
Dispatch
(
do_AddRef
(
aRunnable
)
aFlags
)
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
LeakRefPtr
<
nsIRunnable
>
event
(
std
:
:
move
(
aEvent
)
)
;
if
(
NS_WARN_IF
(
!
event
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
gXPCOMThreadsShutDown
&
&
!
mIsMainThread
)
{
NS_ASSERTION
(
false
"
Failed
Dispatch
after
xpcom
-
shutdown
-
threads
"
)
;
return
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
}
#
ifdef
MOZ_TASK_TRACER
nsCOMPtr
<
nsIRunnable
>
tracedRunnable
=
CreateTracedRunnable
(
event
.
take
(
)
)
;
(
static_cast
<
TracedRunnable
*
>
(
tracedRunnable
.
get
(
)
)
)
-
>
DispatchTask
(
)
;
event
=
tracedRunnable
.
forget
(
)
;
#
endif
if
(
aFlags
&
DISPATCH_SYNC
)
{
nsCOMPtr
<
nsIEventTarget
>
current
=
GetCurrentThreadEventTarget
(
)
;
if
(
NS_WARN_IF
(
!
current
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
nsThreadSyncDispatch
>
wrapper
=
new
nsThreadSyncDispatch
(
current
.
forget
(
)
event
.
take
(
)
)
;
bool
success
=
mSink
-
>
PutEvent
(
do_AddRef
(
wrapper
)
EventQueuePriority
:
:
Normal
)
;
if
(
!
success
)
{
wrapper
.
get
(
)
-
>
Release
(
)
;
return
NS_ERROR_UNEXPECTED
;
}
SpinEventLoopUntil
(
[
&
wrapper
]
(
)
-
>
bool
{
return
!
wrapper
-
>
IsPending
(
)
;
}
)
;
return
NS_OK
;
}
NS_ASSERTION
(
aFlags
=
=
NS_DISPATCH_NORMAL
|
|
aFlags
=
=
NS_DISPATCH_AT_END
"
unexpected
dispatch
flags
"
)
;
if
(
!
mSink
-
>
PutEvent
(
event
.
take
(
)
EventQueuePriority
:
:
Normal
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
DelayForChaosMode
(
ChaosFeature
:
:
TaskDispatching
1000
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aDelayMs
)
{
NS_ENSURE_TRUE
(
!
!
aDelayMs
NS_ERROR_UNEXPECTED
)
;
RefPtr
<
DelayedRunnable
>
r
=
new
DelayedRunnable
(
do_AddRef
(
this
)
std
:
:
move
(
aEvent
)
aDelayMs
)
;
nsresult
rv
=
r
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
IsOnCurrentThread
(
bool
*
aIsOnCurrentThread
)
{
*
aIsOnCurrentThread
=
IsOnCurrentThread
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
bool
)
ThreadEventTarget
:
:
IsOnCurrentThreadInfallible
(
)
{
MOZ_CRASH
(
"
IsOnCurrentThreadInfallible
should
never
be
called
on
nsIThread
"
)
;
}
