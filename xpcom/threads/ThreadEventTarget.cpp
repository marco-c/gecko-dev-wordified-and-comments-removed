#
include
"
ThreadEventTarget
.
h
"
#
include
"
mozilla
/
ThreadEventQueue
.
h
"
#
include
"
LeakRefPtr
.
h
"
#
include
"
mozilla
/
DelayedRunnable
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsThreadSyncDispatch
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
ThreadDelay
.
h
"
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
include
"
TracedTaskCommon
.
h
"
using
namespace
mozilla
:
:
tasktracer
;
#
endif
using
namespace
mozilla
;
ThreadEventTarget
:
:
ThreadEventTarget
(
ThreadTargetSink
*
aSink
bool
aIsMainThread
)
:
mSink
(
aSink
)
mIsMainThread
(
aIsMainThread
)
{
mThread
=
PR_GetCurrentThread
(
)
;
}
ThreadEventTarget
:
:
~
ThreadEventTarget
(
)
{
MOZ_ASSERT
(
mScheduledDelayedRunnables
.
IsEmpty
(
)
)
;
}
void
ThreadEventTarget
:
:
SetCurrentThread
(
PRThread
*
aThread
)
{
mThread
=
aThread
;
}
void
ThreadEventTarget
:
:
ClearCurrentThread
(
)
{
mThread
=
nullptr
;
}
NS_IMPL_ISUPPORTS
(
ThreadEventTarget
nsIEventTarget
nsISerialEventTarget
nsIDelayedRunnableObserver
)
NS_IMETHODIMP
ThreadEventTarget
:
:
DispatchFromScript
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
)
{
return
Dispatch
(
do_AddRef
(
aRunnable
)
aFlags
)
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
LeakRefPtr
<
nsIRunnable
>
event
(
std
:
:
move
(
aEvent
)
)
;
if
(
NS_WARN_IF
(
!
event
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
gXPCOMThreadsShutDown
&
&
!
mIsMainThread
)
{
NS_ASSERTION
(
false
"
Failed
Dispatch
after
xpcom
-
shutdown
-
threads
"
)
;
return
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
}
#
ifdef
MOZ_TASK_TRACER
nsCOMPtr
<
nsIRunnable
>
tracedRunnable
=
CreateTracedRunnable
(
event
.
take
(
)
)
;
(
static_cast
<
TracedRunnable
*
>
(
tracedRunnable
.
get
(
)
)
)
-
>
DispatchTask
(
)
;
event
=
tracedRunnable
.
forget
(
)
;
#
endif
LogRunnable
:
:
LogDispatch
(
event
.
get
(
)
)
;
if
(
aFlags
&
DISPATCH_SYNC
)
{
nsCOMPtr
<
nsIEventTarget
>
current
=
GetCurrentEventTarget
(
)
;
if
(
NS_WARN_IF
(
!
current
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
nsThreadSyncDispatch
>
wrapper
=
new
nsThreadSyncDispatch
(
current
.
forget
(
)
event
.
take
(
)
)
;
bool
success
=
mSink
-
>
PutEvent
(
do_AddRef
(
wrapper
)
EventQueuePriority
:
:
Normal
)
;
if
(
!
success
)
{
wrapper
.
get
(
)
-
>
Release
(
)
;
return
NS_ERROR_UNEXPECTED
;
}
SpinEventLoopUntil
(
[
&
wrapper
]
(
)
-
>
bool
{
return
!
wrapper
-
>
IsPending
(
)
;
}
)
;
return
NS_OK
;
}
NS_ASSERTION
(
aFlags
=
=
NS_DISPATCH_NORMAL
|
|
aFlags
=
=
NS_DISPATCH_AT_END
"
unexpected
dispatch
flags
"
)
;
if
(
!
mSink
-
>
PutEvent
(
event
.
take
(
)
EventQueuePriority
:
:
Normal
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
DelayForChaosMode
(
ChaosFeature
:
:
TaskDispatching
1000
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aDelayMs
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
aEvent
;
NS_ENSURE_TRUE
(
!
!
aDelayMs
NS_ERROR_UNEXPECTED
)
;
RefPtr
<
DelayedRunnable
>
r
=
new
DelayedRunnable
(
do_AddRef
(
this
)
event
.
forget
(
)
aDelayMs
)
;
nsresult
rv
=
r
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
ThreadEventTarget
:
:
IsOnCurrentThread
(
bool
*
aIsOnCurrentThread
)
{
*
aIsOnCurrentThread
=
IsOnCurrentThread
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
bool
)
ThreadEventTarget
:
:
IsOnCurrentThreadInfallible
(
)
{
return
false
;
}
void
ThreadEventTarget
:
:
OnDelayedRunnableCreated
(
DelayedRunnable
*
aRunnable
)
{
}
void
ThreadEventTarget
:
:
OnDelayedRunnableScheduled
(
DelayedRunnable
*
aRunnable
)
{
MOZ_ASSERT
(
IsOnCurrentThread
(
)
)
;
mScheduledDelayedRunnables
.
AppendElement
(
aRunnable
)
;
}
void
ThreadEventTarget
:
:
OnDelayedRunnableRan
(
DelayedRunnable
*
aRunnable
)
{
MOZ_ASSERT
(
IsOnCurrentThread
(
)
)
;
mScheduledDelayedRunnables
.
RemoveElement
(
aRunnable
)
;
}
void
ThreadEventTarget
:
:
NotifyShutdown
(
)
{
MOZ_ASSERT
(
IsOnCurrentThread
(
)
)
;
for
(
const
auto
&
runnable
:
mScheduledDelayedRunnables
)
{
runnable
-
>
CancelTimer
(
)
;
}
mScheduledDelayedRunnables
.
Clear
(
)
;
}
