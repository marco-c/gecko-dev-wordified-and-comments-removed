#
if
!
defined
(
AbstractThread_h_
)
#
define
AbstractThread_h_
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIThread
.
h
"
namespace
mozilla
{
class
TaskQueue
;
class
TaskDispatcher
;
class
AbstractThread
:
public
nsISerialEventTarget
{
public
:
static
AbstractThread
*
GetCurrent
(
)
{
return
sCurrentThreadTLS
.
get
(
)
;
}
AbstractThread
(
bool
aSupportsTailDispatch
)
:
mSupportsTailDispatch
(
aSupportsTailDispatch
)
{
}
static
already_AddRefed
<
AbstractThread
>
CreateXPCOMThreadWrapper
(
nsIThread
*
aThread
bool
aRequireTailDispatch
)
;
static
already_AddRefed
<
AbstractThread
>
CreateEventTargetWrapper
(
nsIEventTarget
*
aEventTarget
bool
aRequireTailDispatch
)
;
NS_DECL_THREADSAFE_ISUPPORTS_WITH_RECORDING
(
recordreplay
:
:
Behavior
:
:
Preserve
)
NS_IMETHOD_
(
bool
)
IsOnCurrentThreadInfallible
(
void
)
override
;
NS_IMETHOD
IsOnCurrentThread
(
bool
*
_retval
)
override
;
NS_IMETHOD
Dispatch
(
already_AddRefed
<
nsIRunnable
>
event
uint32_t
flags
)
override
;
NS_IMETHOD
DispatchFromScript
(
nsIRunnable
*
event
uint32_t
flags
)
override
;
NS_IMETHOD
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
event
uint32_t
delay
)
override
;
enum
DispatchReason
{
NormalDispatch
TailDispatch
}
;
virtual
nsresult
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
DispatchReason
aReason
=
NormalDispatch
)
=
0
;
virtual
bool
IsCurrentThreadIn
(
)
=
0
;
virtual
TaskDispatcher
&
TailDispatcher
(
)
=
0
;
virtual
bool
MightHaveTailTasks
(
)
{
return
true
;
}
nsresult
TailDispatchTasksFor
(
AbstractThread
*
aThread
)
;
bool
HasTailTasksFor
(
AbstractThread
*
aThread
)
;
bool
SupportsTailDispatch
(
)
const
{
return
mSupportsTailDispatch
;
}
bool
RequiresTailDispatch
(
AbstractThread
*
aThread
)
const
;
bool
RequiresTailDispatchFromCurrentThread
(
)
const
;
virtual
TaskQueue
*
AsTaskQueue
(
)
{
MOZ_CRASH
(
"
Not
a
task
queue
!
"
)
;
}
virtual
nsIEventTarget
*
AsEventTarget
(
)
{
MOZ_CRASH
(
"
Not
an
event
target
!
"
)
;
}
static
AbstractThread
*
MainThread
(
)
;
static
void
InitTLS
(
)
;
static
void
InitMainThread
(
)
;
void
DispatchStateChange
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
static
void
DispatchDirectTask
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
virtual
already_AddRefed
<
nsIRunnable
>
CreateDirectTaskDrainer
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
MOZ_CRASH
(
"
Not
support
!
"
)
;
}
struct
AutoEnter
{
explicit
AutoEnter
(
AbstractThread
*
aThread
)
{
mLastCurrentThread
=
sCurrentThreadTLS
.
get
(
)
;
sCurrentThreadTLS
.
set
(
aThread
)
;
}
~
AutoEnter
(
)
{
sCurrentThreadTLS
.
set
(
mLastCurrentThread
)
;
}
private
:
AbstractThread
*
mLastCurrentThread
=
nullptr
;
}
;
protected
:
virtual
~
AbstractThread
(
)
{
}
static
MOZ_THREAD_LOCAL
(
AbstractThread
*
)
sCurrentThreadTLS
;
const
bool
mSupportsTailDispatch
;
}
;
}
#
endif
