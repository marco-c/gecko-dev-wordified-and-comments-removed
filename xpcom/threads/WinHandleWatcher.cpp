#
include
<
windows
.
h
>
#
include
<
threadpoolapiset
.
h
>
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ThreadSafety
.
h
"
#
include
"
mozilla
/
WinHandleWatcher
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsITargetShutdownTask
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
mozilla
:
:
HandleWatcher
;
mozilla
:
:
LazyLogModule
sHWLog
(
"
HandleWatcher
"
)
;
namespace
mozilla
{
namespace
details
{
struct
WaitHandleDeleter
{
void
operator
(
)
(
PTP_WAIT
waitHandle
)
{
MOZ_LOG
(
sHWLog
LogLevel
:
:
Debug
(
"
Closing
PTP_WAIT
%
p
"
waitHandle
)
)
;
:
:
CloseThreadpoolWait
(
waitHandle
)
;
}
}
;
}
using
WaitHandlePtr
=
UniquePtr
<
TP_WAIT
details
:
:
WaitHandleDeleter
>
;
class
HandleWatcher
:
:
Impl
final
:
public
nsITargetShutdownTask
{
NS_DECL_THREADSAFE_ISUPPORTS
public
:
Impl
(
)
=
default
;
private
:
~
Impl
(
)
{
MOZ_ASSERT
(
IsStopped
(
)
)
;
}
struct
Data
{
HANDLE
handle
;
RefPtr
<
nsIEventTarget
>
target
;
nsCOMPtr
<
nsIRunnable
>
runnable
;
WaitHandlePtr
waitHandle
;
RefPtr
<
Impl
>
self
;
}
;
mozilla
:
:
Mutex
mMutex
{
"
HandleWatcher
:
:
Impl
"
}
;
Data
mData
MOZ_GUARDED_BY
(
mMutex
)
=
{
}
;
static
void
CALLBACK
WaitCallback
(
PTP_CALLBACK_INSTANCE
void
*
ctx
PTP_WAIT
aWaitHandle
TP_WAIT_RESULT
aResult
)
{
static_cast
<
Impl
*
>
(
ctx
)
-
>
OnWaitCompleted
(
aWaitHandle
aResult
)
;
}
void
OnWaitCompleted
(
PTP_WAIT
aWaitHandle
TP_WAIT_RESULT
aResult
)
MOZ_EXCLUDES
(
mMutex
)
{
MOZ_ASSERT
(
aResult
=
=
WAIT_OBJECT_0
)
;
mMutex
.
Lock
(
)
;
if
(
aWaitHandle
!
=
mData
.
waitHandle
.
get
(
)
)
{
MOZ_LOG
(
sHWLog
LogLevel
:
:
Debug
(
"
Recv
'
d
already
-
stopped
callback
:
HW
%
p
|
PTP_WAIT
%
p
"
this
aWaitHandle
)
)
;
mMutex
.
Unlock
(
)
;
return
;
}
RefPtr
<
Impl
>
self
=
std
:
:
move
(
mData
.
self
)
;
MOZ_LOG
(
sHWLog
LogLevel
:
:
Info
(
"
Recv
'
d
callback
:
HW
%
p
|
handle
%
p
|
target
%
p
|
PTP_WAIT
%
p
"
this
mData
.
handle
mData
.
target
.
get
(
)
aWaitHandle
)
)
;
mData
.
target
-
>
Dispatch
(
mData
.
runnable
.
forget
(
)
)
;
Replace
(
Data
{
}
)
;
}
public
:
static
RefPtr
<
Impl
>
Create
(
HANDLE
aHandle
nsIEventTarget
*
aTarget
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
auto
impl
=
MakeRefPtr
<
Impl
>
(
)
;
bool
const
ok
[
[
maybe_unused
]
]
=
impl
-
>
Watch
(
aHandle
aTarget
std
:
:
move
(
aRunnable
)
)
;
MOZ_ASSERT
(
ok
)
;
return
impl
;
}
private
:
bool
Watch
(
HANDLE
aHandle
nsIEventTarget
*
aTarget
already_AddRefed
<
nsIRunnable
>
aRunnable
)
MOZ_EXCLUDES
(
mMutex
)
{
MOZ_ASSERT
(
aHandle
)
;
MOZ_ASSERT
(
aTarget
)
;
RefPtr
<
nsIEventTarget
>
target
(
aTarget
)
;
WaitHandlePtr
waitHandle
{
:
:
CreateThreadpoolWait
(
&
WaitCallback
this
nullptr
)
}
;
if
(
!
waitHandle
)
{
return
false
;
}
{
mMutex
.
Lock
(
)
;
nsresult
const
ret
=
aTarget
-
>
RegisterShutdownTask
(
this
)
;
if
(
NS_FAILED
(
ret
)
)
{
mMutex
.
Unlock
(
)
;
return
false
;
}
MOZ_LOG
(
sHWLog
LogLevel
:
:
Info
(
"
Setting
callback
:
HW
%
p
|
handle
%
p
|
target
%
p
|
PTP_WAIT
%
p
"
this
aHandle
aTarget
waitHandle
.
get
(
)
)
)
;
:
:
SetThreadpoolWait
(
waitHandle
.
get
(
)
aHandle
nullptr
)
;
Replace
(
Data
{
.
handle
=
aHandle
.
target
=
std
:
:
move
(
target
)
.
runnable
=
aRunnable
.
waitHandle
=
std
:
:
move
(
waitHandle
)
.
self
=
this
}
)
;
}
return
true
;
}
void
TargetShutdown
(
)
MOZ_EXCLUDES
(
mMutex
)
override
final
{
mMutex
.
Lock
(
)
;
MOZ_LOG
(
sHWLog
LogLevel
:
:
Debug
(
"
Target
shutdown
:
HW
%
p
|
handle
%
p
|
target
%
p
|
PTP_WAIT
%
p
"
this
mData
.
handle
mData
.
target
.
get
(
)
mData
.
waitHandle
.
get
(
)
)
)
;
mData
.
target
=
nullptr
;
Replace
(
Data
{
}
)
;
}
public
:
void
Stop
(
)
MOZ_EXCLUDES
(
mMutex
)
{
mMutex
.
Lock
(
)
;
Replace
(
Data
{
}
)
;
}
bool
IsStopped
(
)
MOZ_EXCLUDES
(
mMutex
)
{
mozilla
:
:
MutexAutoLock
lock
(
mMutex
)
;
return
!
mData
.
handle
;
}
private
:
void
Replace
(
Data
&
&
aData
)
MOZ_CAPABILITY_RELEASE
(
mMutex
)
{
MOZ_ASSERT
(
!
!
aData
.
handle
=
=
!
!
aData
.
waitHandle
)
;
if
(
mData
.
handle
)
{
MOZ_LOG
(
sHWLog
LogLevel
:
:
Info
(
"
Stop
callback
:
HW
%
p
|
handle
%
p
|
target
%
p
|
PTP_WAIT
%
p
"
this
mData
.
handle
mData
.
target
.
get
(
)
mData
.
waitHandle
.
get
(
)
)
)
;
}
if
(
mData
.
target
)
{
mData
.
target
-
>
UnregisterShutdownTask
(
this
)
;
}
RefPtr
<
Impl
>
self
=
std
:
:
move
(
mData
.
self
)
;
WaitHandlePtr
waitHandle
=
std
:
:
move
(
mData
.
waitHandle
)
;
mData
=
std
:
:
move
(
aData
)
;
mMutex
.
Unlock
(
)
;
if
(
self
)
{
MOZ_ASSERT
(
waitHandle
)
;
FlushWaitHandle
(
waitHandle
.
get
(
)
)
;
}
}
void
FlushWaitHandle
(
PTP_WAIT
aWaitHandle
)
MOZ_EXCLUDES
(
mMutex
)
{
:
:
SetThreadpoolWait
(
aWaitHandle
nullptr
nullptr
)
;
:
:
WaitForThreadpoolWaitCallbacks
(
aWaitHandle
TRUE
)
;
}
}
;
NS_IMPL_ISUPPORTS
(
HandleWatcher
:
:
Impl
nsITargetShutdownTask
)
HandleWatcher
:
:
HandleWatcher
(
)
:
mImpl
{
}
{
}
HandleWatcher
:
:
~
HandleWatcher
(
)
{
if
(
mImpl
)
{
MOZ_ASSERT
(
mImpl
-
>
IsStopped
(
)
)
;
mImpl
-
>
Stop
(
)
;
}
}
void
HandleWatcher
:
:
Watch
(
HANDLE
aHandle
nsIEventTarget
*
aTarget
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
auto
impl
=
Impl
:
:
Create
(
aHandle
aTarget
std
:
:
move
(
aRunnable
)
)
;
MOZ_ASSERT
(
impl
)
;
if
(
mImpl
)
{
mImpl
-
>
Stop
(
)
;
}
mImpl
=
std
:
:
move
(
impl
)
;
}
void
HandleWatcher
:
:
Stop
(
)
{
if
(
mImpl
)
{
mImpl
-
>
Stop
(
)
;
}
}
bool
HandleWatcher
:
:
IsStopped
(
)
{
return
!
mImpl
|
|
mImpl
-
>
IsStopped
(
)
;
}
}
