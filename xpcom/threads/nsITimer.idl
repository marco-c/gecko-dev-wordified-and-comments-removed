#
include
"
nsISupports
.
idl
"
#
include
"
nsINamed
.
idl
"
interface
nsIObserver
;
interface
nsIEventTarget
;
%
{
C
+
+
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
<
functional
>
class
nsITimer
;
typedef
void
(
*
nsTimerCallbackFunc
)
(
nsITimer
*
aTimer
void
*
aClosure
)
;
%
}
native
nsTimerCallbackFunc
(
nsTimerCallbackFunc
)
;
[
ref
]
native
TimeDuration
(
mozilla
:
:
TimeDuration
)
;
interface
nsITimer
;
[
function
scriptable
uuid
(
a796816d
-
7d47
-
4348
-
9ab8
-
c7aeb3216a7d
)
]
interface
nsITimerCallback
:
nsISupports
{
void
notify
(
in
nsITimer
timer
)
;
}
;
%
{
C
+
+
#
define
DELAY_INTERVAL_LIMIT
PR_BIT
(
8
*
sizeof
(
PRIntervalTime
)
-
1
)
%
}
[
scriptable
builtinclass
uuid
(
3de4b105
-
363c
-
482c
-
a409
-
baac83a01bfc
)
]
interface
nsITimer
:
nsISupports
{
const
short
TYPE_ONE_SHOT
=
0
;
const
short
TYPE_REPEATING_SLACK
=
1
;
const
short
TYPE_REPEATING_PRECISE
=
2
;
const
short
TYPE_REPEATING_PRECISE_CAN_SKIP
=
3
;
const
short
TYPE_REPEATING_SLACK_LOW_PRIORITY
=
4
;
const
short
TYPE_ONE_SHOT_LOW_PRIORITY
=
5
;
void
init
(
in
nsIObserver
aObserver
in
unsigned
long
aDelayInMs
in
unsigned
long
aType
)
;
void
initWithCallback
(
in
nsITimerCallback
aCallback
in
unsigned
long
aDelayInMs
in
unsigned
long
aType
)
;
[
noscript
]
void
InitHighResolutionWithCallback
(
in
nsITimerCallback
aCallback
[
const
]
in
TimeDuration
aDelay
in
unsigned
long
aType
)
;
void
cancel
(
)
;
[
noscript
]
void
initWithNamedFuncCallback
(
in
nsTimerCallbackFunc
aCallback
in
voidPtr
aClosure
in
unsigned
long
aDelay
in
unsigned
long
aType
in
string
aName
)
;
attribute
unsigned
long
delay
;
attribute
unsigned
long
type
;
[
noscript
]
readonly
attribute
voidPtr
closure
;
readonly
attribute
nsITimerCallback
callback
;
attribute
nsIEventTarget
target
;
[
noscript
]
readonly
attribute
unsigned
long
allowedEarlyFiringMicroseconds
;
%
{
C
+
+
virtual
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
=
0
;
%
}
}
;
%
{
C
+
+
#
include
"
nsCOMPtr
.
h
"
already_AddRefed
<
nsITimer
>
NS_NewTimer
(
)
;
already_AddRefed
<
nsITimer
>
NS_NewTimer
(
nsIEventTarget
*
aTarget
)
;
nsresult
NS_NewTimerWithObserver
(
nsITimer
*
*
aTimer
nsIObserver
*
aObserver
uint32_t
aDelay
uint32_t
aType
nsIEventTarget
*
aTarget
=
nullptr
)
;
mozilla
:
:
Result
<
nsCOMPtr
<
nsITimer
>
nsresult
>
NS_NewTimerWithObserver
(
nsIObserver
*
aObserver
uint32_t
aDelay
uint32_t
aType
nsIEventTarget
*
aTarget
=
nullptr
)
;
nsresult
NS_NewTimerWithCallback
(
nsITimer
*
*
aTimer
nsITimerCallback
*
aCallback
uint32_t
aDelay
uint32_t
aType
nsIEventTarget
*
aTarget
=
nullptr
)
;
mozilla
:
:
Result
<
nsCOMPtr
<
nsITimer
>
nsresult
>
NS_NewTimerWithCallback
(
nsITimerCallback
*
aCallback
uint32_t
aDelay
uint32_t
aType
nsIEventTarget
*
aTarget
=
nullptr
)
;
nsresult
NS_NewTimerWithCallback
(
nsITimer
*
*
aTimer
nsITimerCallback
*
aCallback
const
mozilla
:
:
TimeDuration
&
aDelay
uint32_t
aType
nsIEventTarget
*
aTarget
=
nullptr
)
;
mozilla
:
:
Result
<
nsCOMPtr
<
nsITimer
>
nsresult
>
NS_NewTimerWithCallback
(
nsITimerCallback
*
aCallback
const
mozilla
:
:
TimeDuration
&
aDelay
uint32_t
aType
nsIEventTarget
*
aTarget
=
nullptr
)
;
nsresult
NS_NewTimerWithCallback
(
nsITimer
*
*
aTimer
std
:
:
function
<
void
(
nsITimer
*
)
>
&
&
aCallback
uint32_t
aDelay
uint32_t
aType
const
char
*
aNameString
nsIEventTarget
*
aTarget
=
nullptr
)
;
mozilla
:
:
Result
<
nsCOMPtr
<
nsITimer
>
nsresult
>
NS_NewTimerWithCallback
(
std
:
:
function
<
void
(
nsITimer
*
)
>
&
&
aCallback
uint32_t
aDelay
uint32_t
aType
const
char
*
aNameString
nsIEventTarget
*
aTarget
=
nullptr
)
;
nsresult
NS_NewTimerWithCallback
(
nsITimer
*
*
aTimer
std
:
:
function
<
void
(
nsITimer
*
)
>
&
&
aCallback
const
mozilla
:
:
TimeDuration
&
aDelay
uint32_t
aType
const
char
*
aNameString
nsIEventTarget
*
aTarget
=
nullptr
)
;
mozilla
:
:
Result
<
nsCOMPtr
<
nsITimer
>
nsresult
>
NS_NewTimerWithCallback
(
std
:
:
function
<
void
(
nsITimer
*
)
>
&
&
aCallback
const
mozilla
:
:
TimeDuration
&
aDelay
uint32_t
aType
const
char
*
aNameString
nsIEventTarget
*
aTarget
=
nullptr
)
;
nsresult
NS_NewTimerWithFuncCallback
(
nsITimer
*
*
aTimer
nsTimerCallbackFunc
aCallback
void
*
aClosure
uint32_t
aDelay
uint32_t
aType
const
char
*
aNameString
nsIEventTarget
*
aTarget
=
nullptr
)
;
mozilla
:
:
Result
<
nsCOMPtr
<
nsITimer
>
nsresult
>
NS_NewTimerWithFuncCallback
(
nsTimerCallbackFunc
aCallback
void
*
aClosure
uint32_t
aDelay
uint32_t
aType
const
char
*
aNameString
nsIEventTarget
*
aTarget
=
nullptr
)
;
#
define
NS_TIMER_CONTRACTID
"
mozilla
.
org
/
timer
;
1
"
#
define
NS_TIMER_CALLBACK_TOPIC
"
timer
-
callback
"
#
ifndef
RELEASE_OR_BETA
#
undef
NS_DECL_NSITIMERCALLBACK
#
define
NS_DECL_NSITIMERCALLBACK
\
NS_IMETHOD
Notify
(
nsITimer
*
timer
)
override
;
\
inline
void
_ensure_GetName_exists
(
void
)
{
\
static_assert
(
std
:
:
is_convertible
<
decltype
(
this
)
nsINamed
*
>
:
:
value
\
"
nsITimerCallback
implementations
must
also
implement
nsINamed
"
)
;
\
}
#
endif
%
}
