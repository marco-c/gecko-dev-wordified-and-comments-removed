#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
class
TaskQueue
:
:
EventTargetWrapper
final
:
public
nsIEventTarget
{
RefPtr
<
TaskQueue
>
mTaskQueue
;
~
EventTargetWrapper
(
)
{
}
public
:
explicit
EventTargetWrapper
(
TaskQueue
*
aTaskQueue
)
:
mTaskQueue
(
aTaskQueue
)
{
MOZ_ASSERT
(
mTaskQueue
)
;
}
NS_IMETHOD
DispatchFromScript
(
nsIRunnable
*
aEvent
uint32_t
aFlags
)
override
{
nsCOMPtr
<
nsIRunnable
>
ref
=
aEvent
;
return
Dispatch
(
ref
.
forget
(
)
aFlags
)
;
}
NS_IMETHOD
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
override
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
aEvent
;
MonitorAutoLock
mon
(
mTaskQueue
-
>
mQueueMonitor
)
;
return
mTaskQueue
-
>
DispatchLocked
(
runnable
DontAssertDispatchSuccess
NormalDispatch
)
;
}
NS_IMETHOD
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
uint32_t
aFlags
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
IsOnCurrentThread
(
bool
*
aResult
)
override
{
*
aResult
=
mTaskQueue
-
>
IsCurrentThreadIn
(
)
;
return
NS_OK
;
}
NS_DECL_THREADSAFE_ISUPPORTS
}
;
NS_IMPL_ISUPPORTS
(
TaskQueue
:
:
EventTargetWrapper
nsIEventTarget
)
TaskQueue
:
:
TaskQueue
(
already_AddRefed
<
nsIEventTarget
>
aTarget
bool
aRequireTailDispatch
)
:
AbstractThread
(
aRequireTailDispatch
)
mTarget
(
aTarget
)
mQueueMonitor
(
"
TaskQueue
:
:
Queue
"
)
mTailDispatcher
(
nullptr
)
mIsRunning
(
false
)
mIsShutdown
(
false
)
{
MOZ_COUNT_CTOR
(
TaskQueue
)
;
}
TaskQueue
:
:
~
TaskQueue
(
)
{
MonitorAutoLock
mon
(
mQueueMonitor
)
;
MOZ_ASSERT
(
mIsShutdown
)
;
MOZ_COUNT_DTOR
(
TaskQueue
)
;
}
TaskDispatcher
&
TaskQueue
:
:
TailDispatcher
(
)
{
MOZ_ASSERT
(
IsCurrentThreadIn
(
)
)
;
MOZ_ASSERT
(
mTailDispatcher
)
;
return
*
mTailDispatcher
;
}
nsresult
TaskQueue
:
:
DispatchLocked
(
nsCOMPtr
<
nsIRunnable
>
&
aRunnable
DispatchFailureHandling
aFailureHandling
DispatchReason
aReason
)
{
mQueueMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
mIsShutdown
)
{
return
NS_ERROR_FAILURE
;
}
AbstractThread
*
currentThread
;
if
(
aReason
!
=
TailDispatch
&
&
(
currentThread
=
GetCurrent
(
)
)
&
&
RequiresTailDispatch
(
currentThread
)
)
{
currentThread
-
>
TailDispatcher
(
)
.
AddTask
(
this
aRunnable
.
forget
(
)
aFailureHandling
)
;
return
NS_OK
;
}
mTasks
.
push
(
aRunnable
.
forget
(
)
)
;
if
(
mIsRunning
)
{
return
NS_OK
;
}
RefPtr
<
nsIRunnable
>
runner
(
new
Runner
(
this
)
)
;
nsresult
rv
=
mTarget
-
>
Dispatch
(
runner
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
runnable
to
run
TaskQueue
"
)
;
return
rv
;
}
mIsRunning
=
true
;
return
NS_OK
;
}
void
TaskQueue
:
:
AwaitIdle
(
)
{
MonitorAutoLock
mon
(
mQueueMonitor
)
;
AwaitIdleLocked
(
)
;
}
void
TaskQueue
:
:
AwaitIdleLocked
(
)
{
MOZ_ASSERT_IF
(
AbstractThread
:
:
GetCurrent
(
)
!
AbstractThread
:
:
GetCurrent
(
)
-
>
HasTailTasksFor
(
this
)
)
;
mQueueMonitor
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
mIsRunning
|
|
mTasks
.
empty
(
)
)
;
while
(
mIsRunning
)
{
mQueueMonitor
.
Wait
(
)
;
}
}
void
TaskQueue
:
:
AwaitShutdownAndIdle
(
)
{
MOZ_ASSERT
(
!
IsCurrentThreadIn
(
)
)
;
MOZ_ASSERT_IF
(
AbstractThread
:
:
GetCurrent
(
)
!
AbstractThread
:
:
GetCurrent
(
)
-
>
HasTailTasksFor
(
this
)
)
;
MonitorAutoLock
mon
(
mQueueMonitor
)
;
while
(
!
mIsShutdown
)
{
mQueueMonitor
.
Wait
(
)
;
}
AwaitIdleLocked
(
)
;
}
RefPtr
<
ShutdownPromise
>
TaskQueue
:
:
BeginShutdown
(
)
{
if
(
AbstractThread
*
currentThread
=
AbstractThread
:
:
GetCurrent
(
)
)
{
currentThread
-
>
TailDispatchTasksFor
(
this
)
;
}
MonitorAutoLock
mon
(
mQueueMonitor
)
;
mIsShutdown
=
true
;
RefPtr
<
ShutdownPromise
>
p
=
mShutdownPromise
.
Ensure
(
__func__
)
;
MaybeResolveShutdown
(
)
;
mon
.
NotifyAll
(
)
;
return
p
;
}
bool
TaskQueue
:
:
IsEmpty
(
)
{
MonitorAutoLock
mon
(
mQueueMonitor
)
;
return
mTasks
.
empty
(
)
;
}
uint32_t
TaskQueue
:
:
ImpreciseLengthForHeuristics
(
)
{
MonitorAutoLock
mon
(
mQueueMonitor
)
;
return
mTasks
.
size
(
)
;
}
bool
TaskQueue
:
:
IsCurrentThreadIn
(
)
{
bool
in
=
NS_GetCurrentThread
(
)
=
=
mRunningThread
;
return
in
;
}
already_AddRefed
<
nsIEventTarget
>
TaskQueue
:
:
WrapAsEventTarget
(
)
{
nsCOMPtr
<
nsIEventTarget
>
ref
=
new
EventTargetWrapper
(
this
)
;
return
ref
.
forget
(
)
;
}
nsresult
TaskQueue
:
:
Runner
:
:
Run
(
)
{
RefPtr
<
nsIRunnable
>
event
;
{
MonitorAutoLock
mon
(
mQueue
-
>
mQueueMonitor
)
;
MOZ_ASSERT
(
mQueue
-
>
mIsRunning
)
;
if
(
mQueue
-
>
mTasks
.
size
(
)
=
=
0
)
{
mQueue
-
>
mIsRunning
=
false
;
mQueue
-
>
MaybeResolveShutdown
(
)
;
mon
.
NotifyAll
(
)
;
return
NS_OK
;
}
event
=
mQueue
-
>
mTasks
.
front
(
)
.
forget
(
)
;
mQueue
-
>
mTasks
.
pop
(
)
;
}
MOZ_ASSERT
(
event
)
;
{
AutoTaskGuard
g
(
mQueue
)
;
event
-
>
Run
(
)
;
}
event
=
nullptr
;
{
MonitorAutoLock
mon
(
mQueue
-
>
mQueueMonitor
)
;
if
(
mQueue
-
>
mTasks
.
size
(
)
=
=
0
)
{
mQueue
-
>
mIsRunning
=
false
;
mQueue
-
>
MaybeResolveShutdown
(
)
;
mon
.
NotifyAll
(
)
;
return
NS_OK
;
}
}
nsresult
rv
=
mQueue
-
>
mTarget
-
>
Dispatch
(
this
NS_DISPATCH_AT_END
)
;
if
(
NS_FAILED
(
rv
)
)
{
MonitorAutoLock
mon
(
mQueue
-
>
mQueueMonitor
)
;
mQueue
-
>
mIsRunning
=
false
;
mQueue
-
>
mIsShutdown
=
true
;
mQueue
-
>
MaybeResolveShutdown
(
)
;
mon
.
NotifyAll
(
)
;
}
return
NS_OK
;
}
}
