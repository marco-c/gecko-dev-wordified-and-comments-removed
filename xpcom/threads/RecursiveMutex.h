#
ifndef
mozilla_RecursiveMutex_h
#
define
mozilla_RecursiveMutex_h
#
include
"
mozilla
/
ThreadSafety
.
h
"
#
include
"
mozilla
/
BlockingResourceBase
.
h
"
#
ifndef
XP_WIN
#
include
<
pthread
.
h
>
#
endif
namespace
mozilla
{
class
CAPABILITY
RecursiveMutex
:
public
BlockingResourceBase
{
public
:
explicit
RecursiveMutex
(
const
char
*
aName
)
;
~
RecursiveMutex
(
)
;
#
ifdef
DEBUG
void
Lock
(
)
CAPABILITY_ACQUIRE
(
)
;
void
Unlock
(
)
CAPABILITY_RELEASE
(
)
;
#
else
void
Lock
(
)
CAPABILITY_ACQUIRE
(
)
{
LockInternal
(
)
;
}
void
Unlock
(
)
CAPABILITY_RELEASE
(
)
{
UnlockInternal
(
)
;
}
#
endif
#
ifdef
DEBUG
void
AssertCurrentThreadIn
(
)
const
ASSERT_CAPABILITY
(
this
)
;
void
AssertNotCurrentThreadIn
(
)
const
EXCLUDES
(
this
)
{
}
#
else
void
AssertCurrentThreadIn
(
)
const
ASSERT_CAPABILITY
(
this
)
{
}
void
AssertNotCurrentThreadIn
(
)
const
EXCLUDES
(
this
)
{
}
#
endif
private
:
RecursiveMutex
(
)
=
delete
;
RecursiveMutex
(
const
RecursiveMutex
&
)
=
delete
;
RecursiveMutex
&
operator
=
(
const
RecursiveMutex
&
)
=
delete
;
void
LockInternal
(
)
;
void
UnlockInternal
(
)
;
#
ifdef
DEBUG
PRThread
*
mOwningThread
;
size_t
mEntryCount
;
#
endif
#
if
!
defined
(
XP_WIN
)
pthread_mutex_t
mMutex
;
#
else
void
*
mMutex
[
6
]
;
#
endif
}
;
class
MOZ_RAII
SCOPED_CAPABILITY
RecursiveMutexAutoLock
{
public
:
explicit
RecursiveMutexAutoLock
(
RecursiveMutex
&
aRecursiveMutex
)
CAPABILITY_ACQUIRE
(
aRecursiveMutex
)
:
mRecursiveMutex
(
&
aRecursiveMutex
)
{
NS_ASSERTION
(
mRecursiveMutex
"
null
mutex
"
)
;
mRecursiveMutex
-
>
Lock
(
)
;
}
~
RecursiveMutexAutoLock
(
void
)
CAPABILITY_RELEASE
(
)
{
mRecursiveMutex
-
>
Unlock
(
)
;
}
private
:
RecursiveMutexAutoLock
(
)
=
delete
;
RecursiveMutexAutoLock
(
const
RecursiveMutexAutoLock
&
)
=
delete
;
RecursiveMutexAutoLock
&
operator
=
(
const
RecursiveMutexAutoLock
&
)
=
delete
;
static
void
*
operator
new
(
size_t
)
noexcept
(
true
)
;
mozilla
:
:
RecursiveMutex
*
mRecursiveMutex
;
}
;
class
MOZ_RAII
SCOPED_CAPABILITY
RecursiveMutexAutoUnlock
{
public
:
explicit
RecursiveMutexAutoUnlock
(
RecursiveMutex
&
aRecursiveMutex
)
SCOPED_UNLOCK_RELEASE
(
aRecursiveMutex
)
:
mRecursiveMutex
(
&
aRecursiveMutex
)
{
NS_ASSERTION
(
mRecursiveMutex
"
null
mutex
"
)
;
mRecursiveMutex
-
>
Unlock
(
)
;
}
~
RecursiveMutexAutoUnlock
(
void
)
SCOPED_UNLOCK_REACQUIRE
(
)
{
mRecursiveMutex
-
>
Lock
(
)
;
}
private
:
RecursiveMutexAutoUnlock
(
)
=
delete
;
RecursiveMutexAutoUnlock
(
const
RecursiveMutexAutoUnlock
&
)
=
delete
;
RecursiveMutexAutoUnlock
&
operator
=
(
const
RecursiveMutexAutoUnlock
&
)
=
delete
;
static
void
*
operator
new
(
size_t
)
noexcept
(
true
)
;
mozilla
:
:
RecursiveMutex
*
mRecursiveMutex
;
}
;
}
#
endif
