#
include
"
CooperativeThreadPool
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
mozilla
/
IOInterposer
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
namespace
mozilla
;
static
bool
gCooperativeSchedulingEnabled
;
MOZ_THREAD_LOCAL
(
CooperativeThreadPool
:
:
CooperativeThread
*
)
CooperativeThreadPool
:
:
sTlsCurrentThread
;
#
undef
Yield
CooperativeThreadPool
:
:
CooperativeThreadPool
(
size_t
aNumThreads
Mutex
&
aMutex
Controller
&
aController
)
:
mMutex
(
aMutex
)
mShutdownCondition
(
mMutex
"
CoopShutdown
"
)
mRunning
(
false
)
mNumThreads
(
std
:
:
min
(
aNumThreads
kMaxThreads
)
)
mRunningThreads
(
0
)
mController
(
aController
)
mSelectedThread
(
size_t
(
0
)
)
{
MOZ_ASSERT
(
aNumThreads
<
kMaxThreads
)
;
gCooperativeSchedulingEnabled
=
true
;
sTlsCurrentThread
.
infallibleInit
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
mRunning
=
true
;
mRunningThreads
=
mNumThreads
;
for
(
size_t
i
=
0
;
i
<
mNumThreads
;
i
+
+
)
{
mThreads
[
i
]
=
MakeUnique
<
CooperativeThread
>
(
this
i
)
;
}
}
CooperativeThreadPool
:
:
~
CooperativeThreadPool
(
)
{
MOZ_ASSERT
(
!
mRunning
)
;
}
const
size_t
CooperativeThreadPool
:
:
kMaxThreads
;
void
CooperativeThreadPool
:
:
Shutdown
(
)
{
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mRunning
)
;
mRunning
=
false
;
}
for
(
size_t
i
=
0
;
i
<
mNumThreads
;
i
+
+
)
{
mThreads
[
i
]
-
>
BeginShutdown
(
)
;
}
{
MutexAutoLock
lock
(
mMutex
)
;
while
(
mRunningThreads
)
{
mShutdownCondition
.
Wait
(
)
;
}
}
for
(
size_t
i
=
0
;
i
<
mNumThreads
;
i
+
+
)
{
mThreads
[
i
]
-
>
EndShutdown
(
)
;
}
}
void
CooperativeThreadPool
:
:
RecheckBlockers
(
const
MutexAutoLock
&
aProofOfLock
)
{
aProofOfLock
.
AssertOwns
(
mMutex
)
;
if
(
!
mSelectedThread
.
is
<
AllThreadsBlocked
>
(
)
)
{
return
;
}
for
(
size_t
i
=
0
;
i
<
mNumThreads
;
i
+
+
)
{
if
(
mThreads
[
i
]
-
>
mRunning
&
&
!
mThreads
[
i
]
-
>
IsBlocked
(
aProofOfLock
)
)
{
mSelectedThread
=
AsVariant
(
i
)
;
mThreads
[
i
]
-
>
mCondVar
.
Notify
(
)
;
return
;
}
}
}
void
CooperativeThreadPool
:
:
Yield
(
Resource
*
aBlocker
const
MutexAutoLock
&
aProofOfLock
)
{
if
(
!
gCooperativeSchedulingEnabled
)
{
return
;
}
CooperativeThread
*
thread
=
sTlsCurrentThread
.
get
(
)
;
MOZ_RELEASE_ASSERT
(
thread
)
;
thread
-
>
SetBlocker
(
aBlocker
)
;
thread
-
>
Yield
(
aProofOfLock
)
;
}
bool
CooperativeThreadPool
:
:
IsCooperativeThread
(
)
{
if
(
!
gCooperativeSchedulingEnabled
)
{
return
false
;
}
return
!
!
sTlsCurrentThread
.
get
(
)
;
}
CooperativeThreadPool
:
:
SelectedThread
CooperativeThreadPool
:
:
CurrentThreadIndex
(
const
MutexAutoLock
&
aProofOfLock
)
const
{
aProofOfLock
.
AssertOwns
(
mMutex
)
;
return
mSelectedThread
;
}
CooperativeThreadPool
:
:
CooperativeThread
:
:
CooperativeThread
(
CooperativeThreadPool
*
aPool
size_t
aIndex
)
:
mPool
(
aPool
)
mCondVar
(
aPool
-
>
mMutex
"
CooperativeThreadPool
"
)
mBlocker
(
nullptr
)
mIndex
(
aIndex
)
mRunning
(
true
)
{
mThread
=
PR_CreateThread
(
PR_USER_THREAD
ThreadFunc
this
PR_PRIORITY_NORMAL
PR_GLOBAL_THREAD
PR_JOINABLE_THREAD
0
)
;
MOZ_RELEASE_ASSERT
(
mThread
)
;
}
void
CooperativeThreadPool
:
:
CooperativeThread
:
:
ThreadMethod
(
)
{
char
stackTop
;
MOZ_ASSERT
(
gCooperativeSchedulingEnabled
)
;
sTlsCurrentThread
.
set
(
this
)
;
nsCString
name
=
mPool
-
>
mThreadNaming
.
GetNextThreadName
(
"
Main
"
)
;
PR_SetCurrentThreadName
(
name
.
get
(
)
)
;
mozilla
:
:
IOInterposer
:
:
RegisterCurrentThread
(
)
;
{
MutexAutoLock
lock
(
mPool
-
>
mMutex
)
;
while
(
mPool
-
>
mSelectedThread
!
=
AsVariant
(
mIndex
)
)
{
mCondVar
.
Wait
(
)
;
}
}
mPool
-
>
mController
.
OnStartThread
(
mIndex
name
&
stackTop
)
;
nsCOMPtr
<
nsIThread
>
thread
=
do_GetCurrentThread
(
)
;
mEventTarget
=
thread
;
for
(
;
;
)
{
{
MutexAutoLock
lock
(
mPool
-
>
mMutex
)
;
if
(
!
mPool
-
>
mRunning
)
{
break
;
}
}
bool
processedEvent
;
thread
-
>
ProcessNextEvent
(
true
&
processedEvent
)
;
}
mPool
-
>
mController
.
OnStopThread
(
mIndex
)
;
mozilla
:
:
IOInterposer
:
:
UnregisterCurrentThread
(
)
;
MutexAutoLock
lock
(
mPool
-
>
mMutex
)
;
mPool
-
>
mRunningThreads
-
-
;
mRunning
=
false
;
mPool
-
>
mSelectedThread
=
AsVariant
(
AllThreadsBlocked
:
:
Blocked
)
;
mPool
-
>
RecheckBlockers
(
lock
)
;
mPool
-
>
mShutdownCondition
.
Notify
(
)
;
}
void
CooperativeThreadPool
:
:
CooperativeThread
:
:
ThreadFunc
(
void
*
aArg
)
{
auto
thread
=
static_cast
<
CooperativeThreadPool
:
:
CooperativeThread
*
>
(
aArg
)
;
thread
-
>
ThreadMethod
(
)
;
}
void
CooperativeThreadPool
:
:
CooperativeThread
:
:
BeginShutdown
(
)
{
mEventTarget
-
>
Dispatch
(
new
mozilla
:
:
Runnable
(
"
CooperativeShutdownEvent
"
)
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
}
void
CooperativeThreadPool
:
:
CooperativeThread
:
:
EndShutdown
(
)
{
PR_JoinThread
(
mThread
)
;
}
bool
CooperativeThreadPool
:
:
CooperativeThread
:
:
IsBlocked
(
const
MutexAutoLock
&
aProofOfLock
)
{
if
(
!
mBlocker
)
{
return
false
;
}
return
!
mBlocker
-
>
IsAvailable
(
aProofOfLock
)
;
}
void
CooperativeThreadPool
:
:
CooperativeThread
:
:
Yield
(
const
MutexAutoLock
&
aProofOfLock
)
{
aProofOfLock
.
AssertOwns
(
mPool
-
>
mMutex
)
;
size_t
selected
=
mIndex
+
1
;
bool
found
=
false
;
do
{
if
(
selected
>
=
mPool
-
>
mNumThreads
)
{
selected
=
0
;
}
if
(
mPool
-
>
mThreads
[
selected
]
-
>
mRunning
&
&
!
mPool
-
>
mThreads
[
selected
]
-
>
IsBlocked
(
aProofOfLock
)
)
{
found
=
true
;
break
;
}
selected
+
+
;
}
while
(
selected
!
=
mIndex
+
1
)
;
if
(
found
)
{
mPool
-
>
mSelectedThread
=
AsVariant
(
selected
)
;
mPool
-
>
mThreads
[
selected
]
-
>
mCondVar
.
Notify
(
)
;
}
else
{
mPool
-
>
mSelectedThread
=
AsVariant
(
AllThreadsBlocked
:
:
Blocked
)
;
}
mPool
-
>
mController
.
OnSuspendThread
(
mIndex
)
;
while
(
mPool
-
>
mSelectedThread
!
=
AsVariant
(
mIndex
)
)
{
mCondVar
.
Wait
(
)
;
}
mPool
-
>
mController
.
OnResumeThread
(
mIndex
)
;
}
