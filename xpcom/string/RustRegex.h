#
ifndef
mozilla_RustRegex_h
#
define
mozilla_RustRegex_h
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
rure
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
class
RustRegex
;
class
RustRegexSet
;
class
RustRegexOptions
;
class
RustRegexCaptures
;
class
RustRegexIter
;
class
RustRegexIterCaptureNames
;
using
RustRegexMatch
=
rure_match
;
class
RustRegexCaptures
final
{
public
:
RustRegexCaptures
(
)
=
default
;
bool
IsValid
(
)
const
{
return
mPtr
!
=
nullptr
;
}
explicit
operator
bool
(
)
const
{
return
IsValid
(
)
;
}
Maybe
<
RustRegexMatch
>
CaptureAt
(
size_t
aIdx
)
const
{
RustRegexMatch
match
;
if
(
mPtr
&
&
rure_captures_at
(
mPtr
.
get
(
)
aIdx
&
match
)
)
{
return
Some
(
match
)
;
}
return
Nothing
(
)
;
}
Maybe
<
RustRegexMatch
>
operator
[
]
(
size_t
aIdx
)
const
{
return
CaptureAt
(
aIdx
)
;
}
size_t
Length
(
)
const
{
return
mPtr
?
rure_captures_len
(
mPtr
.
get
(
)
)
:
0
;
}
private
:
friend
class
RustRegex
;
friend
class
RustRegexIter
;
explicit
RustRegexCaptures
(
rure
*
aRe
)
:
mPtr
(
aRe
?
rure_captures_new
(
aRe
)
:
nullptr
)
{
}
struct
Deleter
{
void
operator
(
)
(
rure_captures
*
ptr
)
const
{
rure_captures_free
(
ptr
)
;
}
}
;
UniquePtr
<
rure_captures
Deleter
>
mPtr
;
}
;
class
RustRegexIterCaptureNames
{
public
:
RustRegexIterCaptureNames
(
)
=
delete
;
bool
IsValid
(
)
const
{
return
mPtr
!
=
nullptr
;
}
explicit
operator
bool
(
)
const
{
return
IsValid
(
)
;
}
mozilla
:
:
Maybe
<
const
char
*
>
Next
(
)
{
char
*
next
=
nullptr
;
if
(
mPtr
&
&
rure_iter_capture_names_next
(
mPtr
.
get
(
)
&
next
)
)
{
return
Some
(
next
)
;
}
return
Nothing
(
)
;
}
private
:
friend
class
RustRegex
;
explicit
RustRegexIterCaptureNames
(
rure
*
aRe
)
:
mPtr
(
aRe
?
rure_iter_capture_names_new
(
aRe
)
:
nullptr
)
{
}
struct
Deleter
{
void
operator
(
)
(
rure_iter_capture_names
*
ptr
)
const
{
rure_iter_capture_names_free
(
ptr
)
;
}
}
;
UniquePtr
<
rure_iter_capture_names
Deleter
>
mPtr
;
}
;
class
RustRegexIter
{
public
:
RustRegexIter
(
)
=
delete
;
bool
IsValid
(
)
const
{
return
mPtr
!
=
nullptr
;
}
explicit
operator
bool
(
)
const
{
return
IsValid
(
)
;
}
mozilla
:
:
Maybe
<
RustRegexMatch
>
Next
(
)
{
RustRegexMatch
match
{
}
;
if
(
mPtr
&
&
rure_iter_next
(
mPtr
.
get
(
)
mHaystackPtr
mHaystackSize
&
match
)
)
{
return
Some
(
match
)
;
}
return
Nothing
(
)
;
}
RustRegexCaptures
NextCaptures
(
)
{
RustRegexCaptures
captures
(
mRe
)
;
if
(
mPtr
&
&
rure_iter_next_captures
(
mPtr
.
get
(
)
mHaystackPtr
mHaystackSize
captures
.
mPtr
.
get
(
)
)
)
{
return
captures
;
}
return
{
}
;
}
private
:
friend
class
RustRegex
;
RustRegexIter
(
rure
*
aRe
const
std
:
:
string_view
&
aHaystack
)
:
mRe
(
aRe
)
mHaystackPtr
(
reinterpret_cast
<
const
uint8_t
*
>
(
aHaystack
.
data
(
)
)
)
mHaystackSize
(
aHaystack
.
size
(
)
)
mPtr
(
aRe
?
rure_iter_new
(
aRe
)
:
nullptr
)
{
}
rure
*
MOZ_NON_OWNING_REF
mRe
;
const
uint8_t
*
MOZ_NON_OWNING_REF
mHaystackPtr
;
size_t
mHaystackSize
;
struct
Deleter
{
void
operator
(
)
(
rure_iter
*
ptr
)
const
{
rure_iter_free
(
ptr
)
;
}
}
;
UniquePtr
<
rure_iter
Deleter
>
mPtr
;
}
;
class
RustRegexOptions
{
public
:
RustRegexOptions
(
)
=
default
;
RustRegexOptions
&
CaseInsensitive
(
bool
aYes
)
{
return
SetFlag
(
aYes
RURE_FLAG_CASEI
)
;
}
RustRegexOptions
&
MultiLine
(
bool
aYes
)
{
return
SetFlag
(
aYes
RURE_FLAG_MULTI
)
;
}
RustRegexOptions
&
DotMatchesNewLine
(
bool
aYes
)
{
return
SetFlag
(
aYes
RURE_FLAG_DOTNL
)
;
}
RustRegexOptions
&
SwapGreed
(
bool
aYes
)
{
return
SetFlag
(
aYes
RURE_FLAG_SWAP_GREED
)
;
}
RustRegexOptions
&
IgnoreWhitespace
(
bool
aYes
)
{
return
SetFlag
(
aYes
RURE_FLAG_SPACE
)
;
}
RustRegexOptions
&
Unicode
(
bool
aYes
)
{
return
SetFlag
(
aYes
RURE_FLAG_UNICODE
)
;
}
RustRegexOptions
&
SizeLimit
(
size_t
aLimit
)
{
mSizeLimit
=
Some
(
aLimit
)
;
return
*
this
;
}
RustRegexOptions
&
DFASizeLimit
(
size_t
aLimit
)
{
mDFASizeLimit
=
Some
(
aLimit
)
;
return
*
this
;
}
private
:
friend
class
RustRegex
;
friend
class
RustRegexSet
;
struct
OptionsDeleter
{
void
operator
(
)
(
rure_options
*
ptr
)
const
{
rure_options_free
(
ptr
)
;
}
}
;
UniquePtr
<
rure_options
OptionsDeleter
>
GetOptions
(
)
const
{
UniquePtr
<
rure_options
OptionsDeleter
>
options
;
if
(
mSizeLimit
|
|
mDFASizeLimit
)
{
options
.
reset
(
rure_options_new
(
)
)
;
if
(
mSizeLimit
)
{
rure_options_size_limit
(
options
.
get
(
)
*
mSizeLimit
)
;
}
if
(
mDFASizeLimit
)
{
rure_options_dfa_size_limit
(
options
.
get
(
)
*
mDFASizeLimit
)
;
}
}
return
options
;
}
uint32_t
GetFlags
(
)
const
{
return
mFlags
;
}
RustRegexOptions
&
SetFlag
(
bool
aYes
uint32_t
aFlag
)
{
if
(
aYes
)
{
mFlags
|
=
aFlag
;
}
else
{
mFlags
&
=
~
aFlag
;
}
return
*
this
;
}
uint32_t
mFlags
=
RURE_DEFAULT_FLAGS
;
Maybe
<
size_t
>
mSizeLimit
;
Maybe
<
size_t
>
mDFASizeLimit
;
}
;
class
RustRegex
final
{
public
:
RustRegex
(
)
=
default
;
explicit
RustRegex
(
const
std
:
:
string_view
&
aPattern
const
RustRegexOptions
&
aOptions
=
{
}
)
{
#
ifdef
DEBUG
rure_error
*
error
=
rure_error_new
(
)
;
#
else
rure_error
*
error
=
nullptr
;
#
endif
mPtr
.
reset
(
rure_compile
(
reinterpret_cast
<
const
uint8_t
*
>
(
aPattern
.
data
(
)
)
aPattern
.
size
(
)
aOptions
.
GetFlags
(
)
aOptions
.
GetOptions
(
)
.
get
(
)
error
)
)
;
#
ifdef
DEBUG
if
(
!
mPtr
)
{
NS_WARNING
(
nsPrintfCString
(
"
RustRegex
compile
failed
:
%
s
"
rure_error_message
(
error
)
)
.
get
(
)
)
;
}
rure_error_free
(
error
)
;
#
endif
}
bool
IsValid
(
)
const
{
return
mPtr
!
=
nullptr
;
}
explicit
operator
bool
(
)
const
{
return
IsValid
(
)
;
}
bool
IsMatch
(
const
std
:
:
string_view
&
aHaystack
size_t
aStart
=
0
)
const
{
return
mPtr
&
&
rure_is_match
(
mPtr
.
get
(
)
reinterpret_cast
<
const
uint8_t
*
>
(
aHaystack
.
data
(
)
)
aHaystack
.
size
(
)
aStart
)
;
}
Maybe
<
RustRegexMatch
>
Find
(
const
std
:
:
string_view
&
aHaystack
size_t
aStart
=
0
)
const
{
RustRegexMatch
match
{
}
;
if
(
mPtr
&
&
rure_find
(
mPtr
.
get
(
)
reinterpret_cast
<
const
uint8_t
*
>
(
aHaystack
.
data
(
)
)
aHaystack
.
size
(
)
aStart
&
match
)
)
{
return
Some
(
match
)
;
}
return
Nothing
(
)
;
}
RustRegexCaptures
FindCaptures
(
const
std
:
:
string_view
&
aHaystack
size_t
aStart
=
0
)
const
{
RustRegexCaptures
captures
(
mPtr
.
get
(
)
)
;
if
(
mPtr
&
&
rure_find_captures
(
mPtr
.
get
(
)
reinterpret_cast
<
const
uint8_t
*
>
(
aHaystack
.
data
(
)
)
aHaystack
.
size
(
)
aStart
captures
.
mPtr
.
get
(
)
)
)
{
return
captures
;
}
return
{
}
;
}
Maybe
<
size_t
>
ShortestMatch
(
const
std
:
:
string_view
&
aHaystack
size_t
aStart
=
0
)
const
{
size_t
end
=
0
;
if
(
mPtr
&
&
rure_shortest_match
(
mPtr
.
get
(
)
reinterpret_cast
<
const
uint8_t
*
>
(
aHaystack
.
data
(
)
)
aHaystack
.
size
(
)
aStart
&
end
)
)
{
return
Some
(
end
)
;
}
return
Nothing
(
)
;
}
RustRegexIter
IterMatches
(
const
std
:
:
string_view
&
aHaystack
)
const
{
return
RustRegexIter
(
mPtr
.
get
(
)
aHaystack
)
;
}
int32_t
CaptureNameIndex
(
const
char
*
aName
)
const
{
return
mPtr
?
rure_capture_name_index
(
mPtr
.
get
(
)
aName
)
:
-
1
;
}
RustRegexIterCaptureNames
IterCaptureNames
(
)
const
{
return
RustRegexIterCaptureNames
(
mPtr
.
get
(
)
)
;
}
size_t
CountMatches
(
const
std
:
:
string_view
&
aHaystack
)
const
{
size_t
count
=
0
;
auto
iter
=
IterMatches
(
aHaystack
)
;
while
(
iter
.
Next
(
)
)
{
count
+
+
;
}
return
count
;
}
private
:
struct
Deleter
{
void
operator
(
)
(
rure
*
ptr
)
const
{
rure_free
(
ptr
)
;
}
}
;
UniquePtr
<
rure
Deleter
>
mPtr
;
}
;
class
RustRegexSet
final
{
public
:
template
<
typename
Patterns
>
explicit
RustRegexSet
(
Patterns
&
&
aPatterns
const
RustRegexOptions
&
aOptions
=
{
}
)
{
#
ifdef
DEBUG
rure_error
*
error
=
rure_error_new
(
)
;
#
else
rure_error
*
error
=
nullptr
;
#
endif
AutoTArray
<
const
uint8_t
*
4
>
patternPtrs
;
AutoTArray
<
size_t
4
>
patternSizes
;
for
(
auto
&
&
pattern
:
std
:
:
forward
<
Patterns
>
(
aPatterns
)
)
{
std
:
:
string_view
view
=
pattern
;
patternPtrs
.
AppendElement
(
reinterpret_cast
<
const
uint8_t
*
>
(
view
.
data
(
)
)
)
;
patternSizes
.
AppendElement
(
view
.
size
(
)
)
;
}
mPtr
.
reset
(
rure_compile_set
(
patternPtrs
.
Elements
(
)
patternSizes
.
Elements
(
)
patternPtrs
.
Length
(
)
aOptions
.
GetFlags
(
)
aOptions
.
GetOptions
(
)
.
get
(
)
error
)
)
;
#
ifdef
DEBUG
if
(
!
mPtr
)
{
NS_WARNING
(
nsPrintfCString
(
"
RustRegexSet
compile
failed
:
%
s
"
rure_error_message
(
error
)
)
.
get
(
)
)
;
}
rure_error_free
(
error
)
;
#
endif
}
bool
IsValid
(
)
const
{
return
mPtr
!
=
nullptr
;
}
explicit
operator
bool
(
)
const
{
return
IsValid
(
)
;
}
bool
IsMatch
(
const
std
:
:
string_view
&
aHaystack
size_t
aStart
=
0
)
const
{
return
mPtr
&
&
rure_set_is_match
(
mPtr
.
get
(
)
reinterpret_cast
<
const
uint8_t
*
>
(
aHaystack
.
data
(
)
)
aHaystack
.
size
(
)
aStart
)
;
}
struct
SetMatches
{
bool
matchedAny
=
false
;
nsTArray
<
bool
>
matches
;
}
;
SetMatches
Matches
(
const
std
:
:
string_view
&
aHaystack
size_t
aStart
=
0
)
const
{
nsTArray
<
bool
>
matches
;
matches
.
SetLength
(
Length
(
)
)
;
bool
any
=
mPtr
&
&
rure_set_matches
(
mPtr
.
get
(
)
reinterpret_cast
<
const
uint8_t
*
>
(
aHaystack
.
data
(
)
)
aHaystack
.
size
(
)
aStart
matches
.
Elements
(
)
)
;
return
SetMatches
{
any
std
:
:
move
(
matches
)
}
;
}
size_t
Length
(
)
const
{
return
mPtr
?
rure_set_len
(
mPtr
.
get
(
)
)
:
0
;
}
private
:
struct
Deleter
{
void
operator
(
)
(
rure_set
*
ptr
)
const
{
rure_set_free
(
ptr
)
;
}
}
;
UniquePtr
<
rure_set
Deleter
>
mPtr
;
}
;
}
#
endif
