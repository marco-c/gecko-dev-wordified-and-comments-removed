#
ifndef
nsTSubstringTuple_h
#
define
nsTSubstringTuple_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsTStringRepr
.
h
"
template
<
typename
T
>
class
MOZ_TEMPORARY_CLASS
nsTSubstringTuple
{
public
:
typedef
T
char_type
;
typedef
nsCharTraits
<
char_type
>
char_traits
;
typedef
nsTSubstringTuple
<
T
>
self_type
;
typedef
mozilla
:
:
detail
:
:
nsTStringRepr
<
char_type
>
base_string_type
;
typedef
uint32_t
size_type
;
public
:
nsTSubstringTuple
(
const
base_string_type
*
aStrA
const
base_string_type
*
aStrB
)
:
mHead
(
nullptr
)
mFragA
(
aStrA
)
mFragB
(
aStrB
)
{
}
nsTSubstringTuple
(
const
self_type
&
aHead
const
base_string_type
*
aStrB
)
:
mHead
(
&
aHead
)
mFragA
(
nullptr
)
mFragB
(
aStrB
)
{
}
size_type
Length
(
)
const
;
void
WriteTo
(
char_type
*
aBuf
uint32_t
aBufLen
)
const
;
bool
IsDependentOn
(
const
char_type
*
aStart
const
char_type
*
aEnd
)
const
;
private
:
const
self_type
*
const
mHead
;
const
base_string_type
*
const
mFragA
;
const
base_string_type
*
const
mFragB
;
}
;
template
<
typename
T
>
inline
const
nsTSubstringTuple
<
T
>
operator
+
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aStrA
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aStrB
)
{
return
nsTSubstringTuple
<
T
>
(
&
aStrA
&
aStrB
)
;
}
template
<
typename
T
>
inline
const
nsTSubstringTuple
<
T
>
operator
+
(
const
nsTSubstringTuple
<
T
>
&
aHead
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aStrB
)
{
return
nsTSubstringTuple
<
T
>
(
aHead
&
aStrB
)
;
}
#
endif
