#
ifndef
nsTStringRepr_h
#
define
nsTStringRepr_h
#
include
<
type_traits
>
#
include
"
mozilla
/
Char16
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
nsStringFlags
.
h
"
#
include
"
nsCharTraits
.
h
"
template
<
typename
T
>
class
nsTSubstringTuple
;
template
<
typename
T
>
class
nsTStringComparator
{
public
:
typedef
T
char_type
;
nsTStringComparator
(
)
{
}
virtual
int
operator
(
)
(
const
char_type
*
const
char_type
*
uint32_t
uint32_t
)
const
=
0
;
}
;
template
<
typename
T
>
class
nsTDefaultStringComparator
:
public
nsTStringComparator
<
T
>
{
public
:
typedef
T
char_type
;
nsTDefaultStringComparator
(
)
{
}
virtual
int
operator
(
)
(
const
char_type
*
const
char_type
*
uint32_t
uint32_t
)
const
override
;
}
;
extern
template
class
nsTDefaultStringComparator
<
char
>
;
extern
template
class
nsTDefaultStringComparator
<
char16_t
>
;
namespace
mozilla
{
template
<
typename
CharType
>
using
CharOnlyT
=
typename
std
:
:
enable_if
<
std
:
:
is_same
<
char
CharType
>
:
:
value
>
:
:
type
;
template
<
typename
CharType
>
using
Char16OnlyT
=
typename
std
:
:
enable_if
<
std
:
:
is_same
<
char16_t
CharType
>
:
:
value
>
:
:
type
;
namespace
detail
{
template
<
typename
T
>
class
nsTStringRepr
{
public
:
typedef
mozilla
:
:
fallible_t
fallible_t
;
typedef
T
char_type
;
typedef
nsCharTraits
<
char_type
>
char_traits
;
typedef
typename
char_traits
:
:
incompatible_char_type
incompatible_char_type
;
typedef
nsTStringRepr
<
T
>
self_type
;
typedef
self_type
base_string_type
;
typedef
nsTSubstring
<
T
>
substring_type
;
typedef
nsTSubstringTuple
<
T
>
substring_tuple_type
;
typedef
nsReadingIterator
<
char_type
>
const_iterator
;
typedef
char_type
*
iterator
;
typedef
nsTStringComparator
<
char_type
>
comparator_type
;
typedef
const
char_type
*
const_char_iterator
;
typedef
uint32_t
index_type
;
typedef
uint32_t
size_type
;
typedef
StringDataFlags
DataFlags
;
typedef
StringClassFlags
ClassFlags
;
constexpr
const_char_iterator
BeginReading
(
)
const
{
return
mData
;
}
constexpr
const_char_iterator
EndReading
(
)
const
{
return
mData
+
mLength
;
}
const_iterator
&
BeginReading
(
const_iterator
&
aIter
)
const
{
aIter
.
mStart
=
mData
;
aIter
.
mEnd
=
mData
+
mLength
;
aIter
.
mPosition
=
aIter
.
mStart
;
return
aIter
;
}
const_iterator
&
EndReading
(
const_iterator
&
aIter
)
const
{
aIter
.
mStart
=
mData
;
aIter
.
mEnd
=
mData
+
mLength
;
aIter
.
mPosition
=
aIter
.
mEnd
;
return
aIter
;
}
const_char_iterator
&
BeginReading
(
const_char_iterator
&
aIter
)
const
{
return
aIter
=
mData
;
}
const_char_iterator
&
EndReading
(
const_char_iterator
&
aIter
)
const
{
return
aIter
=
mData
+
mLength
;
}
template
<
typename
U
typename
Dummy
>
struct
raw_type
{
typedef
const
U
*
type
;
}
;
#
if
defined
(
MOZ_USE_CHAR16_WRAPPER
)
template
<
typename
Dummy
>
struct
raw_type
<
char16_t
Dummy
>
{
typedef
char16ptr_t
type
;
}
;
#
endif
constexpr
const
typename
raw_type
<
T
int
>
:
:
type
Data
(
)
const
{
return
mData
;
}
constexpr
size_type
Length
(
)
const
{
return
mLength
;
}
constexpr
DataFlags
GetDataFlags
(
)
const
{
return
mDataFlags
;
}
constexpr
bool
IsEmpty
(
)
const
{
return
mLength
=
=
0
;
}
constexpr
bool
IsLiteral
(
)
const
{
return
!
!
(
mDataFlags
&
DataFlags
:
:
LITERAL
)
;
}
constexpr
bool
IsVoid
(
)
const
{
return
!
!
(
mDataFlags
&
DataFlags
:
:
VOIDED
)
;
}
constexpr
bool
IsTerminated
(
)
const
{
return
!
!
(
mDataFlags
&
DataFlags
:
:
TERMINATED
)
;
}
constexpr
char_type
CharAt
(
index_type
aIndex
)
const
{
NS_ASSERTION
(
aIndex
<
mLength
"
index
exceeds
allowable
range
"
)
;
return
mData
[
aIndex
]
;
}
constexpr
char_type
operator
[
]
(
index_type
aIndex
)
const
{
return
CharAt
(
aIndex
)
;
}
char_type
First
(
)
const
;
char_type
Last
(
)
const
;
size_type
NS_FASTCALL
CountChar
(
char_type
)
const
;
int32_t
NS_FASTCALL
FindChar
(
char_type
index_type
aOffset
=
0
)
const
;
inline
bool
Contains
(
char_type
aChar
)
const
{
return
FindChar
(
aChar
)
!
=
kNotFound
;
}
bool
NS_FASTCALL
Equals
(
const
self_type
&
)
const
;
bool
NS_FASTCALL
Equals
(
const
self_type
&
const
comparator_type
&
)
const
;
bool
NS_FASTCALL
Equals
(
const
substring_tuple_type
&
aTuple
)
const
;
bool
NS_FASTCALL
Equals
(
const
substring_tuple_type
&
aTuple
const
comparator_type
&
aComp
)
const
;
bool
NS_FASTCALL
Equals
(
const
char_type
*
aData
)
const
;
bool
NS_FASTCALL
Equals
(
const
char_type
*
aData
const
comparator_type
&
aComp
)
const
;
template
<
typename
Q
=
T
typename
EnableIfChar
=
mozilla
:
:
CharOnlyT
<
Q
>
>
int32_t
Compare
(
const
char_type
*
aString
bool
aIgnoreCase
=
false
int32_t
aCount
=
-
1
)
const
;
template
<
typename
Q
=
T
typename
EnableIfChar
=
mozilla
:
:
CharOnlyT
<
Q
>
>
bool
EqualsIgnoreCase
(
const
char_type
*
aString
int32_t
aCount
=
-
1
)
const
{
return
Compare
(
aString
true
aCount
)
=
=
0
;
}
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
bool
EqualsIgnoreCase
(
const
incompatible_char_type
*
aString
int32_t
aCount
=
-
1
)
const
;
#
if
defined
(
MOZ_USE_CHAR16_WRAPPER
)
template
<
typename
Q
=
T
typename
EnableIfChar16
=
Char16OnlyT
<
Q
>
>
bool
NS_FASTCALL
Equals
(
char16ptr_t
aData
)
const
{
return
Equals
(
static_cast
<
const
char16_t
*
>
(
aData
)
)
;
}
template
<
typename
Q
=
T
typename
EnableIfChar16
=
Char16OnlyT
<
Q
>
>
bool
NS_FASTCALL
Equals
(
char16ptr_t
aData
const
comparator_type
&
aComp
)
const
{
return
Equals
(
static_cast
<
const
char16_t
*
>
(
aData
)
aComp
)
;
}
#
endif
bool
NS_FASTCALL
EqualsASCII
(
const
char
*
aData
size_type
aLen
)
const
;
bool
NS_FASTCALL
EqualsASCII
(
const
char
*
aData
)
const
;
bool
EqualsLatin1
(
const
char
*
aData
size_type
aLength
)
const
;
template
<
int
N
>
inline
bool
EqualsLiteral
(
const
char
(
&
aStr
)
[
N
]
)
const
{
return
EqualsASCII
(
aStr
N
-
1
)
;
}
bool
NS_FASTCALL
LowerCaseEqualsASCII
(
const
char
*
aData
size_type
aLen
)
const
;
bool
NS_FASTCALL
LowerCaseEqualsASCII
(
const
char
*
aData
)
const
;
template
<
int
N
>
bool
LowerCaseEqualsLiteral
(
const
char
(
&
aStr
)
[
N
]
)
const
{
return
LowerCaseEqualsASCII
(
aStr
N
-
1
)
;
}
bool
IsDependentOn
(
const
char_type
*
aStart
const
char_type
*
aEnd
)
const
{
return
(
reinterpret_cast
<
uintptr_t
>
(
aStart
)
<
reinterpret_cast
<
uintptr_t
>
(
mData
+
mLength
)
&
&
reinterpret_cast
<
uintptr_t
>
(
aEnd
)
>
reinterpret_cast
<
uintptr_t
>
(
mData
)
)
;
}
protected
:
nsTStringRepr
(
)
=
delete
;
constexpr
nsTStringRepr
(
char_type
*
aData
size_type
aLength
DataFlags
aDataFlags
ClassFlags
aClassFlags
)
:
mData
(
aData
)
mLength
(
aLength
)
mDataFlags
(
aDataFlags
)
mClassFlags
(
aClassFlags
)
{
}
char_type
*
mData
;
size_type
mLength
;
DataFlags
mDataFlags
;
ClassFlags
const
mClassFlags
;
}
;
extern
template
class
nsTStringRepr
<
char
>
;
extern
template
class
nsTStringRepr
<
char16_t
>
;
}
}
template
<
typename
T
>
int
NS_FASTCALL
Compare
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
const
nsTStringComparator
<
T
>
&
=
nsTDefaultStringComparator
<
T
>
(
)
)
;
template
<
typename
T
>
inline
constexpr
bool
operator
!
=
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
)
{
return
!
aLhs
.
Equals
(
aRhs
)
;
}
template
<
typename
T
>
inline
constexpr
bool
operator
!
=
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
T
*
aRhs
)
{
return
!
aLhs
.
Equals
(
aRhs
)
;
}
template
<
typename
T
>
inline
bool
operator
<
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
)
{
return
Compare
(
aLhs
aRhs
)
<
0
;
}
template
<
typename
T
>
inline
bool
operator
<
=
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
)
{
return
Compare
(
aLhs
aRhs
)
<
=
0
;
}
template
<
typename
T
>
inline
bool
operator
=
=
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
)
{
return
aLhs
.
Equals
(
aRhs
)
;
}
template
<
typename
T
>
inline
bool
operator
=
=
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
T
*
aRhs
)
{
return
aLhs
.
Equals
(
aRhs
)
;
}
template
<
typename
T
>
inline
bool
operator
>
=
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
)
{
return
Compare
(
aLhs
aRhs
)
>
=
0
;
}
template
<
typename
T
>
inline
bool
operator
>
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
)
{
return
Compare
(
aLhs
aRhs
)
>
0
;
}
#
endif
