#
ifndef
nsTStringRepr_h
#
define
nsTStringRepr_h
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
mozilla
/
Char16
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
nsStringFlags
.
h
"
#
include
"
nsStringIterator
.
h
"
#
include
"
nsCharTraits
.
h
"
template
<
typename
T
>
class
nsTSubstringTuple
;
namespace
mozilla
{
template
<
typename
CharType
>
using
CharOnlyT
=
typename
std
:
:
enable_if
<
std
:
:
is_same
<
char
CharType
>
:
:
value
>
:
:
type
;
template
<
typename
CharType
>
using
Char16OnlyT
=
typename
std
:
:
enable_if
<
std
:
:
is_same
<
char16_t
CharType
>
:
:
value
>
:
:
type
;
namespace
detail
{
template
<
typename
T
>
class
nsTStringLengthStorage
{
public
:
static
constexpr
size_t
kMax
=
size_t
{
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
}
/
sizeof
(
T
)
-
1
;
static_assert
(
(
kMax
+
1
)
*
sizeof
(
T
)
<
=
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
"
nsTString
'
s
maximum
length
including
the
trailing
null
must
fit
"
"
within
int32_t
as
callers
will
cast
to
int32_t
occasionally
"
)
;
static_assert
(
(
(
CheckedInt
<
uint32_t
>
{
kMax
}
+
1
)
*
sizeof
(
T
)
+
sizeof
(
nsStringBuffer
)
)
.
isValid
(
)
"
Math
required
to
allocate
a
nsStringBuffer
for
a
"
"
maximum
-
capacity
string
must
not
overflow
uint32_t
"
)
;
MOZ_IMPLICIT
constexpr
nsTStringLengthStorage
(
size_t
aLength
)
:
mLength
(
static_cast
<
uint32_t
>
(
aLength
)
)
{
MOZ_RELEASE_ASSERT
(
aLength
<
=
kMax
"
string
is
too
large
"
)
;
}
constexpr
nsTStringLengthStorage
&
operator
=
(
size_t
aLength
)
{
MOZ_RELEASE_ASSERT
(
aLength
<
=
kMax
"
string
is
too
large
"
)
;
mLength
=
static_cast
<
uint32_t
>
(
aLength
)
;
return
*
this
;
}
MOZ_IMPLICIT
constexpr
operator
size_t
(
)
const
{
return
mLength
;
}
private
:
uint32_t
mLength
=
0
;
}
;
template
<
typename
T
>
class
nsTStringRepr
{
public
:
typedef
mozilla
:
:
fallible_t
fallible_t
;
typedef
T
char_type
;
typedef
nsCharTraits
<
char_type
>
char_traits
;
typedef
typename
char_traits
:
:
incompatible_char_type
incompatible_char_type
;
typedef
nsTStringRepr
<
T
>
self_type
;
typedef
self_type
base_string_type
;
typedef
nsTSubstring
<
T
>
substring_type
;
typedef
nsTSubstringTuple
<
T
>
substring_tuple_type
;
typedef
nsReadingIterator
<
char_type
>
const_iterator
;
typedef
char_type
*
iterator
;
typedef
nsTStringComparator
<
char_type
>
comparator_type
;
typedef
const
char_type
*
const_char_iterator
;
typedef
size_t
index_type
;
typedef
size_t
size_type
;
typedef
StringDataFlags
DataFlags
;
typedef
StringClassFlags
ClassFlags
;
typedef
nsTStringLengthStorage
<
T
>
LengthStorage
;
constexpr
const_char_iterator
BeginReading
(
)
const
{
return
mData
;
}
constexpr
const_char_iterator
EndReading
(
)
const
{
return
mData
+
mLength
;
}
const_iterator
&
BeginReading
(
const_iterator
&
aIter
)
const
{
aIter
.
mStart
=
mData
;
aIter
.
mEnd
=
mData
+
mLength
;
aIter
.
mPosition
=
aIter
.
mStart
;
return
aIter
;
}
const_iterator
&
EndReading
(
const_iterator
&
aIter
)
const
{
aIter
.
mStart
=
mData
;
aIter
.
mEnd
=
mData
+
mLength
;
aIter
.
mPosition
=
aIter
.
mEnd
;
return
aIter
;
}
const_char_iterator
&
BeginReading
(
const_char_iterator
&
aIter
)
const
{
return
aIter
=
mData
;
}
const_char_iterator
&
EndReading
(
const_char_iterator
&
aIter
)
const
{
return
aIter
=
mData
+
mLength
;
}
template
<
typename
U
typename
Dummy
>
struct
raw_type
{
typedef
const
U
*
type
;
}
;
#
if
defined
(
MOZ_USE_CHAR16_WRAPPER
)
template
<
typename
Dummy
>
struct
raw_type
<
char16_t
Dummy
>
{
typedef
char16ptr_t
type
;
}
;
#
endif
constexpr
const
typename
raw_type
<
T
int
>
:
:
type
Data
(
)
const
{
return
mData
;
}
constexpr
size_type
Length
(
)
const
{
return
static_cast
<
size_type
>
(
mLength
)
;
}
constexpr
DataFlags
GetDataFlags
(
)
const
{
return
mDataFlags
;
}
constexpr
bool
IsEmpty
(
)
const
{
return
mLength
=
=
0
;
}
constexpr
bool
IsLiteral
(
)
const
{
return
!
!
(
mDataFlags
&
DataFlags
:
:
LITERAL
)
;
}
constexpr
bool
IsVoid
(
)
const
{
return
!
!
(
mDataFlags
&
DataFlags
:
:
VOIDED
)
;
}
constexpr
bool
IsTerminated
(
)
const
{
return
!
!
(
mDataFlags
&
DataFlags
:
:
TERMINATED
)
;
}
constexpr
char_type
CharAt
(
index_type
aIndex
)
const
{
NS_ASSERTION
(
aIndex
<
Length
(
)
"
index
exceeds
allowable
range
"
)
;
return
mData
[
aIndex
]
;
}
constexpr
char_type
operator
[
]
(
index_type
aIndex
)
const
{
return
CharAt
(
aIndex
)
;
}
char_type
First
(
)
const
;
char_type
Last
(
)
const
;
size_type
NS_FASTCALL
CountChar
(
char_type
)
const
;
int32_t
NS_FASTCALL
FindChar
(
char_type
index_type
aOffset
=
0
)
const
;
bool
Contains
(
char_type
aChar
)
const
;
bool
NS_FASTCALL
Equals
(
const
self_type
&
)
const
;
bool
NS_FASTCALL
Equals
(
const
self_type
&
comparator_type
)
const
;
bool
NS_FASTCALL
Equals
(
const
substring_tuple_type
&
aTuple
)
const
;
bool
NS_FASTCALL
Equals
(
const
substring_tuple_type
&
aTuple
comparator_type
)
const
;
bool
NS_FASTCALL
Equals
(
const
char_type
*
aData
)
const
;
bool
NS_FASTCALL
Equals
(
const
char_type
*
aData
comparator_type
)
const
;
template
<
typename
Q
=
T
typename
EnableIfChar
=
mozilla
:
:
CharOnlyT
<
Q
>
>
int32_t
Compare
(
const
char_type
*
aString
bool
aIgnoreCase
=
false
size_type
aCount
=
std
:
:
numeric_limits
<
size_type
>
:
:
max
(
)
)
const
;
template
<
typename
Q
=
T
typename
EnableIfChar
=
mozilla
:
:
CharOnlyT
<
Q
>
>
bool
EqualsIgnoreCase
(
const
char_type
*
aString
size_type
aCount
=
std
:
:
numeric_limits
<
size_type
>
:
:
max
(
)
)
const
{
return
Compare
(
aString
true
aCount
)
=
=
0
;
}
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
bool
EqualsIgnoreCase
(
const
incompatible_char_type
*
aString
size_type
aCount
=
std
:
:
numeric_limits
<
size_type
>
:
:
max
(
)
)
const
;
#
if
defined
(
MOZ_USE_CHAR16_WRAPPER
)
template
<
typename
Q
=
T
typename
EnableIfChar16
=
Char16OnlyT
<
Q
>
>
bool
NS_FASTCALL
Equals
(
char16ptr_t
aData
)
const
{
return
Equals
(
static_cast
<
const
char16_t
*
>
(
aData
)
)
;
}
template
<
typename
Q
=
T
typename
EnableIfChar16
=
Char16OnlyT
<
Q
>
>
bool
NS_FASTCALL
Equals
(
char16ptr_t
aData
comparator_type
aComp
)
const
{
return
Equals
(
static_cast
<
const
char16_t
*
>
(
aData
)
aComp
)
;
}
#
endif
bool
NS_FASTCALL
EqualsASCII
(
const
char
*
aData
size_type
aLen
)
const
;
bool
NS_FASTCALL
EqualsASCII
(
const
char
*
aData
)
const
;
bool
EqualsLatin1
(
const
char
*
aData
size_type
aLength
)
const
;
template
<
int
N
>
inline
bool
EqualsLiteral
(
const
char
(
&
aStr
)
[
N
]
)
const
{
return
EqualsASCII
(
aStr
N
-
1
)
;
}
template
<
size_t
N
typename
=
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
const
char
(
&
)
[
N
]
const
char_type
(
&
)
[
N
]
>
>
>
inline
bool
EqualsLiteral
(
const
char_type
(
&
aStr
)
[
N
]
)
const
{
return
*
this
=
=
nsTLiteralString
<
char_type
>
(
aStr
)
;
}
bool
NS_FASTCALL
LowerCaseEqualsASCII
(
const
char
*
aData
size_type
aLen
)
const
;
bool
NS_FASTCALL
LowerCaseEqualsASCII
(
const
char
*
aData
)
const
;
template
<
int
N
>
bool
LowerCaseEqualsLiteral
(
const
char
(
&
aStr
)
[
N
]
)
const
{
return
LowerCaseEqualsASCII
(
aStr
N
-
1
)
;
}
bool
IsDependentOn
(
const
char_type
*
aStart
const
char_type
*
aEnd
)
const
{
return
(
reinterpret_cast
<
uintptr_t
>
(
aStart
)
<
reinterpret_cast
<
uintptr_t
>
(
mData
+
mLength
)
&
&
reinterpret_cast
<
uintptr_t
>
(
aEnd
)
>
reinterpret_cast
<
uintptr_t
>
(
mData
)
)
;
}
int32_t
Find
(
const
nsTStringRepr
<
char
>
&
aString
bool
aIgnoreCase
=
false
int32_t
aOffset
=
0
int32_t
aCount
=
-
1
)
const
;
int32_t
Find
(
const
char
*
aString
bool
aIgnoreCase
=
false
int32_t
aOffset
=
0
int32_t
aCount
=
-
1
)
const
;
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
int32_t
Find
(
const
self_type
&
aString
int32_t
aOffset
=
0
int32_t
aCount
=
-
1
)
const
;
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
int32_t
Find
(
const
char_type
*
aString
int32_t
aOffset
=
0
int32_t
aCount
=
-
1
)
const
;
#
ifdef
MOZ_USE_CHAR16_WRAPPER
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
int32_t
Find
(
char16ptr_t
aString
int32_t
aOffset
=
0
int32_t
aCount
=
-
1
)
const
{
return
Find
(
static_cast
<
const
char16_t
*
>
(
aString
)
aOffset
aCount
)
;
}
#
endif
int32_t
RFind
(
const
nsTStringRepr
<
char
>
&
aString
bool
aIgnoreCase
=
false
int32_t
aOffset
=
-
1
int32_t
aCount
=
-
1
)
const
;
int32_t
RFind
(
const
char
*
aCString
bool
aIgnoreCase
=
false
int32_t
aOffset
=
-
1
int32_t
aCount
=
-
1
)
const
;
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
int32_t
RFind
(
const
self_type
&
aString
int32_t
aOffset
=
-
1
int32_t
aCount
=
-
1
)
const
;
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
int32_t
RFind
(
const
char_type
*
aString
int32_t
aOffset
=
-
1
int32_t
aCount
=
-
1
)
const
;
int32_t
RFindChar
(
char16_t
aChar
int32_t
aOffset
=
-
1
int32_t
aCount
=
-
1
)
const
;
int32_t
FindCharInSet
(
const
char_type
*
aString
int32_t
aOffset
=
0
)
const
;
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
int32_t
FindCharInSet
(
const
char
*
aSet
int32_t
aOffset
=
0
)
const
;
int32_t
RFindCharInSet
(
const
char_type
*
aString
int32_t
aOffset
=
-
1
)
const
;
protected
:
nsTStringRepr
(
)
=
delete
;
constexpr
nsTStringRepr
(
char_type
*
aData
size_type
aLength
DataFlags
aDataFlags
ClassFlags
aClassFlags
)
:
mData
(
aData
)
mLength
(
aLength
)
mDataFlags
(
aDataFlags
)
mClassFlags
(
aClassFlags
)
{
}
static
constexpr
size_type
kMaxCapacity
=
LengthStorage
:
:
kMax
;
[
[
nodiscard
]
]
static
constexpr
bool
CheckCapacity
(
size_type
aCapacity
)
{
return
aCapacity
<
=
kMaxCapacity
;
}
char_type
*
mData
;
LengthStorage
mLength
;
DataFlags
mDataFlags
;
ClassFlags
const
mClassFlags
;
}
;
extern
template
class
nsTStringRepr
<
char
>
;
extern
template
class
nsTStringRepr
<
char16_t
>
;
}
}
template
<
typename
T
>
int
NS_FASTCALL
Compare
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
nsTStringComparator
<
T
>
=
nsTDefaultStringComparator
<
T
>
)
;
extern
template
int
NS_FASTCALL
Compare
<
char
>
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
char
>
&
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
char
>
&
nsTStringComparator
<
char
>
)
;
extern
template
int
NS_FASTCALL
Compare
<
char16_t
>
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
char16_t
>
&
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
char16_t
>
&
nsTStringComparator
<
char16_t
>
)
;
template
<
typename
T
>
inline
constexpr
bool
operator
!
=
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
)
{
return
!
aLhs
.
Equals
(
aRhs
)
;
}
template
<
typename
T
>
inline
constexpr
bool
operator
!
=
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
T
*
aRhs
)
{
return
!
aLhs
.
Equals
(
aRhs
)
;
}
template
<
typename
T
>
inline
bool
operator
<
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
)
{
return
Compare
(
aLhs
aRhs
)
<
0
;
}
template
<
typename
T
>
inline
bool
operator
<
=
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
)
{
return
Compare
(
aLhs
aRhs
)
<
=
0
;
}
template
<
typename
T
>
inline
bool
operator
=
=
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
)
{
return
aLhs
.
Equals
(
aRhs
)
;
}
template
<
typename
T
>
inline
bool
operator
=
=
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
T
*
aRhs
)
{
return
aLhs
.
Equals
(
aRhs
)
;
}
template
<
typename
T
>
inline
bool
operator
>
=
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
)
{
return
Compare
(
aLhs
aRhs
)
>
=
0
;
}
template
<
typename
T
>
inline
bool
operator
>
(
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aLhs
const
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
&
aRhs
)
{
return
Compare
(
aLhs
aRhs
)
>
0
;
}
#
endif
