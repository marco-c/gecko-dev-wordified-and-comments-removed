#
ifndef
nsTSubstring_h
#
define
nsTSubstring_h
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
IntegerTypeTraits
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsTStringRepr
.
h
"
#
ifndef
MOZILLA_INTERNAL_API
#
error
"
Using
XPCOM
strings
is
limited
to
code
linked
into
libxul
.
"
#
endif
const
size_t
kNsStringBufferMaxPoison
=
16
;
template
<
typename
T
>
class
nsTSubstringSplitter
;
template
<
typename
T
>
class
nsTString
;
template
<
typename
T
>
class
nsTSubstring
;
namespace
mozilla
{
template
<
typename
T
>
class
BulkWriteHandle
final
{
friend
class
nsTSubstring
<
T
>
;
public
:
typedef
typename
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
base_string_type
;
typedef
typename
base_string_type
:
:
size_type
size_type
;
T
*
Elements
(
)
const
{
MOZ_ASSERT
(
mString
)
;
return
mString
-
>
mData
;
}
size_type
Length
(
)
const
{
MOZ_ASSERT
(
mString
)
;
return
mCapacity
;
}
T
*
End
(
)
const
{
return
Elements
(
)
+
Length
(
)
;
}
mozilla
:
:
Span
<
T
>
AsSpan
(
)
const
{
return
mozilla
:
:
MakeSpan
(
Elements
(
)
Length
(
)
)
;
}
operator
mozilla
:
:
Span
<
T
>
(
)
const
{
return
AsSpan
(
)
;
}
mozilla
:
:
Result
<
mozilla
:
:
Ok
nsresult
>
RestartBulkWrite
(
size_type
aCapacity
size_type
aPrefixToPreserve
bool
aAllowShrinking
)
{
MOZ_ASSERT
(
mString
)
;
auto
r
=
mString
-
>
StartBulkWriteImpl
(
aCapacity
aPrefixToPreserve
aAllowShrinking
)
;
if
(
MOZ_UNLIKELY
(
r
.
isErr
(
)
)
)
{
nsresult
rv
=
r
.
unwrapErr
(
)
;
return
mozilla
:
:
Err
(
rv
)
;
}
mCapacity
=
r
.
unwrap
(
)
;
return
mozilla
:
:
Ok
(
)
;
}
void
Finish
(
size_type
aLength
bool
aAllowShrinking
)
{
MOZ_ASSERT
(
mString
)
;
MOZ_ASSERT
(
aLength
<
=
mCapacity
)
;
if
(
!
aLength
)
{
mString
-
>
Truncate
(
)
;
mString
=
nullptr
;
return
;
}
if
(
aAllowShrinking
)
{
mozilla
:
:
Unused
<
<
mString
-
>
StartBulkWriteImpl
(
aLength
aLength
true
)
;
}
mString
-
>
FinishBulkWriteImpl
(
aLength
)
;
mString
=
nullptr
;
}
BulkWriteHandle
(
BulkWriteHandle
&
&
aOther
)
:
mString
(
aOther
.
Forget
(
)
)
mCapacity
(
aOther
.
mCapacity
)
{
}
~
BulkWriteHandle
(
)
{
if
(
!
mString
|
|
!
mCapacity
)
{
return
;
}
auto
ptr
=
Elements
(
)
;
if
(
sizeof
(
T
)
=
=
1
)
{
unsigned
char
*
charPtr
=
reinterpret_cast
<
unsigned
char
*
>
(
ptr
)
;
if
(
mCapacity
>
=
3
)
{
*
charPtr
+
+
=
0xEF
;
*
charPtr
+
+
=
0xBF
;
*
charPtr
+
+
=
0xBD
;
mString
-
>
mLength
=
3
;
}
else
{
*
charPtr
+
+
=
0x1A
;
mString
-
>
mLength
=
1
;
}
*
charPtr
=
0
;
}
else
if
(
sizeof
(
T
)
=
=
2
)
{
char16_t
*
charPtr
=
reinterpret_cast
<
char16_t
*
>
(
ptr
)
;
*
charPtr
+
+
=
0xFFFD
;
*
charPtr
=
0
;
mString
-
>
mLength
=
1
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Only
8
-
bit
and
16
-
bit
code
units
supported
.
"
)
;
}
}
BulkWriteHandle
(
)
=
delete
;
BulkWriteHandle
(
const
BulkWriteHandle
&
)
=
delete
;
BulkWriteHandle
&
operator
=
(
const
BulkWriteHandle
&
)
=
delete
;
private
:
BulkWriteHandle
(
nsTSubstring
<
T
>
*
aString
size_type
aCapacity
)
:
mString
(
aString
)
mCapacity
(
aCapacity
)
{
}
nsTSubstring
<
T
>
*
Forget
(
)
{
auto
string
=
mString
;
mString
=
nullptr
;
return
string
;
}
nsTSubstring
<
T
>
*
mString
;
size_type
mCapacity
;
}
;
}
template
<
typename
T
>
class
nsTSubstring
:
public
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
{
friend
class
mozilla
:
:
BulkWriteHandle
<
T
>
;
public
:
typedef
nsTSubstring
<
T
>
self_type
;
typedef
nsTString
<
T
>
string_type
;
typedef
typename
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
base_string_type
;
typedef
typename
base_string_type
:
:
substring_type
substring_type
;
typedef
typename
base_string_type
:
:
fallible_t
fallible_t
;
typedef
typename
base_string_type
:
:
char_type
char_type
;
typedef
typename
base_string_type
:
:
char_traits
char_traits
;
typedef
typename
base_string_type
:
:
incompatible_char_type
incompatible_char_type
;
typedef
typename
base_string_type
:
:
substring_tuple_type
substring_tuple_type
;
typedef
typename
base_string_type
:
:
const_iterator
const_iterator
;
typedef
typename
base_string_type
:
:
iterator
iterator
;
typedef
typename
base_string_type
:
:
comparator_type
comparator_type
;
typedef
typename
base_string_type
:
:
const_char_iterator
const_char_iterator
;
typedef
typename
base_string_type
:
:
index_type
index_type
;
typedef
typename
base_string_type
:
:
size_type
size_type
;
typedef
typename
base_string_type
:
:
DataFlags
DataFlags
;
typedef
typename
base_string_type
:
:
ClassFlags
ClassFlags
;
~
nsTSubstring
(
)
{
Finalize
(
)
;
}
iterator
BeginWriting
(
)
{
if
(
!
EnsureMutable
(
)
)
{
AllocFailed
(
base_string_type
:
:
mLength
)
;
}
return
base_string_type
:
:
mData
;
}
iterator
BeginWriting
(
const
fallible_t
&
)
{
return
EnsureMutable
(
)
?
base_string_type
:
:
mData
:
iterator
(
0
)
;
}
iterator
EndWriting
(
)
{
if
(
!
EnsureMutable
(
)
)
{
AllocFailed
(
base_string_type
:
:
mLength
)
;
}
return
base_string_type
:
:
mData
+
base_string_type
:
:
mLength
;
}
iterator
EndWriting
(
const
fallible_t
&
)
{
return
EnsureMutable
(
)
?
(
base_string_type
:
:
mData
+
base_string_type
:
:
mLength
)
:
iterator
(
0
)
;
}
int32_t
ToInteger
(
nsresult
*
aErrorCode
uint32_t
aRadix
=
10
)
const
;
int64_t
ToInteger64
(
nsresult
*
aErrorCode
uint32_t
aRadix
=
10
)
const
;
void
NS_FASTCALL
Assign
(
char_type
aChar
)
;
MOZ_MUST_USE
bool
NS_FASTCALL
Assign
(
char_type
aChar
const
fallible_t
&
)
;
void
NS_FASTCALL
Assign
(
const
char_type
*
aData
size_type
aLength
=
size_type
(
-
1
)
)
;
MOZ_MUST_USE
bool
NS_FASTCALL
Assign
(
const
char_type
*
aData
const
fallible_t
&
)
;
MOZ_MUST_USE
bool
NS_FASTCALL
Assign
(
const
char_type
*
aData
size_type
aLength
const
fallible_t
&
)
;
void
NS_FASTCALL
Assign
(
const
self_type
&
)
;
MOZ_MUST_USE
bool
NS_FASTCALL
Assign
(
const
self_type
&
const
fallible_t
&
)
;
void
NS_FASTCALL
Assign
(
self_type
&
&
)
;
MOZ_MUST_USE
bool
NS_FASTCALL
Assign
(
self_type
&
&
const
fallible_t
&
)
;
void
NS_FASTCALL
Assign
(
const
substring_tuple_type
&
)
;
MOZ_MUST_USE
bool
NS_FASTCALL
Assign
(
const
substring_tuple_type
&
const
fallible_t
&
)
;
#
if
defined
(
MOZ_USE_CHAR16_WRAPPER
)
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
void
Assign
(
char16ptr_t
aData
)
{
Assign
(
static_cast
<
const
char16_t
*
>
(
aData
)
)
;
}
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
void
Assign
(
char16ptr_t
aData
size_type
aLength
)
{
Assign
(
static_cast
<
const
char16_t
*
>
(
aData
)
aLength
)
;
}
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
MOZ_MUST_USE
bool
Assign
(
char16ptr_t
aData
size_type
aLength
const
fallible_t
&
aFallible
)
{
return
Assign
(
static_cast
<
const
char16_t
*
>
(
aData
)
aLength
aFallible
)
;
}
#
endif
void
NS_FASTCALL
AssignASCII
(
const
char
*
aData
size_type
aLength
)
;
MOZ_MUST_USE
bool
NS_FASTCALL
AssignASCII
(
const
char
*
aData
size_type
aLength
const
fallible_t
&
)
;
void
NS_FASTCALL
AssignASCII
(
const
char
*
aData
)
{
AssignASCII
(
aData
mozilla
:
:
AssertedCast
<
size_type
size_t
>
(
strlen
(
aData
)
)
)
;
}
MOZ_MUST_USE
bool
NS_FASTCALL
AssignASCII
(
const
char
*
aData
const
fallible_t
&
aFallible
)
{
return
AssignASCII
(
aData
mozilla
:
:
AssertedCast
<
size_type
size_t
>
(
strlen
(
aData
)
)
aFallible
)
;
}
template
<
int
N
>
void
AssignLiteral
(
const
char_type
(
&
aStr
)
[
N
]
)
{
AssignLiteral
(
aStr
N
-
1
)
;
}
template
<
int
N
typename
Q
=
T
typename
EnableIfChar16
=
typename
mozilla
:
:
Char16OnlyT
<
Q
>
>
void
AssignLiteral
(
const
incompatible_char_type
(
&
aStr
)
[
N
]
)
{
AssignASCII
(
aStr
N
-
1
)
;
}
self_type
&
operator
=
(
char_type
aChar
)
{
Assign
(
aChar
)
;
return
*
this
;
}
self_type
&
operator
=
(
const
char_type
*
aData
)
{
Assign
(
aData
)
;
return
*
this
;
}
#
if
defined
(
MOZ_USE_CHAR16_WRAPPER
)
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
self_type
&
operator
=
(
char16ptr_t
aData
)
{
Assign
(
aData
)
;
return
*
this
;
}
#
endif
self_type
&
operator
=
(
const
self_type
&
aStr
)
{
Assign
(
aStr
)
;
return
*
this
;
}
self_type
&
operator
=
(
self_type
&
&
aStr
)
{
Assign
(
std
:
:
move
(
aStr
)
)
;
return
*
this
;
}
self_type
&
operator
=
(
const
substring_tuple_type
&
aTuple
)
{
Assign
(
aTuple
)
;
return
*
this
;
}
void
NS_FASTCALL
Adopt
(
char_type
*
aData
size_type
aLength
=
size_type
(
-
1
)
)
;
void
NS_FASTCALL
Replace
(
index_type
aCutStart
size_type
aCutLength
char_type
aChar
)
;
MOZ_MUST_USE
bool
NS_FASTCALL
Replace
(
index_type
aCutStart
size_type
aCutLength
char_type
aChar
const
fallible_t
&
)
;
void
NS_FASTCALL
Replace
(
index_type
aCutStart
size_type
aCutLength
const
char_type
*
aData
size_type
aLength
=
size_type
(
-
1
)
)
;
MOZ_MUST_USE
bool
NS_FASTCALL
Replace
(
index_type
aCutStart
size_type
aCutLength
const
char_type
*
aData
size_type
aLength
const
fallible_t
&
)
;
void
Replace
(
index_type
aCutStart
size_type
aCutLength
const
self_type
&
aStr
)
{
Replace
(
aCutStart
aCutLength
aStr
.
Data
(
)
aStr
.
Length
(
)
)
;
}
MOZ_MUST_USE
bool
Replace
(
index_type
aCutStart
size_type
aCutLength
const
self_type
&
aStr
const
fallible_t
&
aFallible
)
{
return
Replace
(
aCutStart
aCutLength
aStr
.
Data
(
)
aStr
.
Length
(
)
aFallible
)
;
}
void
NS_FASTCALL
Replace
(
index_type
aCutStart
size_type
aCutLength
const
substring_tuple_type
&
aTuple
)
;
void
NS_FASTCALL
ReplaceASCII
(
index_type
aCutStart
size_type
aCutLength
const
char
*
aData
size_type
aLength
=
size_type
(
-
1
)
)
;
MOZ_MUST_USE
bool
NS_FASTCALL
ReplaceASCII
(
index_type
aCutStart
size_type
aCutLength
const
char
*
aData
size_type
aLength
const
fallible_t
&
)
;
template
<
int
N
>
void
ReplaceLiteral
(
index_type
aCutStart
size_type
aCutLength
const
char_type
(
&
aStr
)
[
N
]
)
{
ReplaceLiteral
(
aCutStart
aCutLength
aStr
N
-
1
)
;
}
void
Append
(
char_type
aChar
)
;
MOZ_MUST_USE
bool
Append
(
char_type
aChar
const
fallible_t
&
aFallible
)
;
void
Append
(
const
char_type
*
aData
size_type
aLength
=
size_type
(
-
1
)
)
;
MOZ_MUST_USE
bool
Append
(
const
char_type
*
aData
size_type
aLength
const
fallible_t
&
aFallible
)
;
#
if
defined
(
MOZ_USE_CHAR16_WRAPPER
)
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
void
Append
(
char16ptr_t
aData
size_type
aLength
=
size_type
(
-
1
)
)
{
Append
(
static_cast
<
const
char16_t
*
>
(
aData
)
aLength
)
;
}
#
endif
void
Append
(
const
self_type
&
aStr
)
;
MOZ_MUST_USE
bool
Append
(
const
self_type
&
aStr
const
fallible_t
&
aFallible
)
;
void
Append
(
const
substring_tuple_type
&
aTuple
)
;
MOZ_MUST_USE
bool
Append
(
const
substring_tuple_type
&
aTuple
const
fallible_t
&
aFallible
)
;
void
AppendASCII
(
const
char
*
aData
size_type
aLength
=
size_type
(
-
1
)
)
;
MOZ_MUST_USE
bool
AppendASCII
(
const
char
*
aData
const
fallible_t
&
aFallible
)
;
MOZ_MUST_USE
bool
AppendASCII
(
const
char
*
aData
size_type
aLength
const
fallible_t
&
aFallible
)
;
template
<
int
N
>
void
AppendLiteral
(
const
char_type
(
&
aStr
)
[
N
]
)
{
Append
(
aStr
N
-
1
)
;
}
template
<
int
N
>
void
AppendLiteral
(
const
char_type
(
&
aStr
)
[
N
]
const
fallible_t
&
aFallible
)
{
return
Append
(
aStr
N
-
1
aFallible
)
;
}
template
<
int
N
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
void
AppendLiteral
(
const
incompatible_char_type
(
&
aStr
)
[
N
]
)
{
AppendASCII
(
aStr
N
-
1
)
;
}
template
<
int
N
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
MOZ_MUST_USE
bool
AppendLiteral
(
const
incompatible_char_type
(
&
aStr
)
[
N
]
const
fallible_t
&
aFallible
)
{
return
AppendASCII
(
aStr
N
-
1
aFallible
)
;
}
void
AppendPrintf
(
const
char
*
aFormat
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
void
AppendPrintf
(
const
char
*
aFormat
va_list
aAp
)
MOZ_FORMAT_PRINTF
(
2
0
)
;
void
AppendInt
(
int32_t
aInteger
)
{
AppendIntDec
(
aInteger
)
;
}
void
AppendInt
(
int32_t
aInteger
int
aRadix
)
{
if
(
aRadix
=
=
10
)
{
AppendIntDec
(
aInteger
)
;
}
else
if
(
aRadix
=
=
8
)
{
AppendIntOct
(
static_cast
<
uint32_t
>
(
aInteger
)
)
;
}
else
{
AppendIntHex
(
static_cast
<
uint32_t
>
(
aInteger
)
)
;
}
}
void
AppendInt
(
uint32_t
aInteger
)
{
AppendIntDec
(
aInteger
)
;
}
void
AppendInt
(
uint32_t
aInteger
int
aRadix
)
{
if
(
aRadix
=
=
10
)
{
AppendIntDec
(
aInteger
)
;
}
else
if
(
aRadix
=
=
8
)
{
AppendIntOct
(
aInteger
)
;
}
else
{
AppendIntHex
(
aInteger
)
;
}
}
void
AppendInt
(
int64_t
aInteger
)
{
AppendIntDec
(
aInteger
)
;
}
void
AppendInt
(
int64_t
aInteger
int
aRadix
)
{
if
(
aRadix
=
=
10
)
{
AppendIntDec
(
aInteger
)
;
}
else
if
(
aRadix
=
=
8
)
{
AppendIntOct
(
static_cast
<
uint64_t
>
(
aInteger
)
)
;
}
else
{
AppendIntHex
(
static_cast
<
uint64_t
>
(
aInteger
)
)
;
}
}
void
AppendInt
(
uint64_t
aInteger
)
{
AppendIntDec
(
aInteger
)
;
}
void
AppendInt
(
uint64_t
aInteger
int
aRadix
)
{
if
(
aRadix
=
=
10
)
{
AppendIntDec
(
aInteger
)
;
}
else
if
(
aRadix
=
=
8
)
{
AppendIntOct
(
aInteger
)
;
}
else
{
AppendIntHex
(
aInteger
)
;
}
}
private
:
void
AppendIntDec
(
int32_t
)
;
void
AppendIntDec
(
uint32_t
)
;
void
AppendIntOct
(
uint32_t
)
;
void
AppendIntHex
(
uint32_t
)
;
void
AppendIntDec
(
int64_t
)
;
void
AppendIntDec
(
uint64_t
)
;
void
AppendIntOct
(
uint64_t
)
;
void
AppendIntHex
(
uint64_t
)
;
public
:
void
NS_FASTCALL
AppendFloat
(
float
aFloat
)
;
void
NS_FASTCALL
AppendFloat
(
double
aFloat
)
;
self_type
&
operator
+
=
(
char_type
aChar
)
{
Append
(
aChar
)
;
return
*
this
;
}
self_type
&
operator
+
=
(
const
char_type
*
aData
)
{
Append
(
aData
)
;
return
*
this
;
}
#
if
defined
(
MOZ_USE_CHAR16_WRAPPER
)
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
self_type
&
operator
+
=
(
char16ptr_t
aData
)
{
Append
(
aData
)
;
return
*
this
;
}
#
endif
self_type
&
operator
+
=
(
const
self_type
&
aStr
)
{
Append
(
aStr
)
;
return
*
this
;
}
self_type
&
operator
+
=
(
const
substring_tuple_type
&
aTuple
)
{
Append
(
aTuple
)
;
return
*
this
;
}
void
Insert
(
char_type
aChar
index_type
aPos
)
{
Replace
(
aPos
0
aChar
)
;
}
void
Insert
(
const
char_type
*
aData
index_type
aPos
size_type
aLength
=
size_type
(
-
1
)
)
{
Replace
(
aPos
0
aData
aLength
)
;
}
#
if
defined
(
MOZ_USE_CHAR16_WRAPPER
)
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
void
Insert
(
char16ptr_t
aData
index_type
aPos
size_type
aLength
=
size_type
(
-
1
)
)
{
Insert
(
static_cast
<
const
char16_t
*
>
(
aData
)
aPos
aLength
)
;
}
#
endif
void
Insert
(
const
self_type
&
aStr
index_type
aPos
)
{
Replace
(
aPos
0
aStr
)
;
}
void
Insert
(
const
substring_tuple_type
&
aTuple
index_type
aPos
)
{
Replace
(
aPos
0
aTuple
)
;
}
template
<
int
N
>
void
InsertLiteral
(
const
char_type
(
&
aStr
)
[
N
]
index_type
aPos
)
{
ReplaceLiteral
(
aPos
0
aStr
N
-
1
)
;
}
void
Cut
(
index_type
aCutStart
size_type
aCutLength
)
{
Replace
(
aCutStart
aCutLength
char_traits
:
:
sEmptyBuffer
0
)
;
}
nsTSubstringSplitter
<
T
>
Split
(
const
char_type
aChar
)
const
;
void
NS_FASTCALL
SetCapacity
(
size_type
aNewCapacity
)
;
MOZ_MUST_USE
bool
NS_FASTCALL
SetCapacity
(
size_type
aNewCapacity
const
fallible_t
&
)
;
void
NS_FASTCALL
SetLength
(
size_type
aNewLength
)
;
MOZ_MUST_USE
bool
NS_FASTCALL
SetLength
(
size_type
aNewLength
const
fallible_t
&
)
;
void
Truncate
(
size_type
aNewLength
)
{
MOZ_RELEASE_ASSERT
(
aNewLength
<
=
base_string_type
:
:
mLength
"
Truncate
cannot
make
string
longer
"
)
;
mozilla
:
:
DebugOnly
<
bool
>
success
=
SetLength
(
aNewLength
mozilla
:
:
fallible
)
;
MOZ_ASSERT
(
success
)
;
}
void
Truncate
(
)
;
inline
size_type
GetData
(
const
char_type
*
*
aData
)
const
{
*
aData
=
base_string_type
:
:
mData
;
return
base_string_type
:
:
mLength
;
}
size_type
GetMutableData
(
char_type
*
*
aData
size_type
aNewLen
=
size_type
(
-
1
)
)
{
if
(
!
EnsureMutable
(
aNewLen
)
)
{
AllocFailed
(
aNewLen
=
=
size_type
(
-
1
)
?
base_string_type
:
:
mLength
:
aNewLen
)
;
}
*
aData
=
base_string_type
:
:
mData
;
return
base_string_type
:
:
mLength
;
}
size_type
GetMutableData
(
char_type
*
*
aData
size_type
aNewLen
const
fallible_t
&
)
{
if
(
!
EnsureMutable
(
aNewLen
)
)
{
*
aData
=
nullptr
;
return
0
;
}
*
aData
=
base_string_type
:
:
mData
;
return
base_string_type
:
:
mLength
;
}
#
if
defined
(
MOZ_USE_CHAR16_WRAPPER
)
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
size_type
GetMutableData
(
wchar_t
*
*
aData
size_type
aNewLen
=
size_type
(
-
1
)
)
{
return
GetMutableData
(
reinterpret_cast
<
char16_t
*
*
>
(
aData
)
aNewLen
)
;
}
template
<
typename
Q
=
T
typename
EnableIfChar16
=
mozilla
:
:
Char16OnlyT
<
Q
>
>
size_type
GetMutableData
(
wchar_t
*
*
aData
size_type
aNewLen
const
fallible_t
&
aFallible
)
{
return
GetMutableData
(
reinterpret_cast
<
char16_t
*
*
>
(
aData
)
aNewLen
aFallible
)
;
}
#
endif
operator
mozilla
:
:
Span
<
char_type
>
(
)
{
return
mozilla
:
:
MakeSpan
(
BeginWriting
(
)
base_string_type
:
:
Length
(
)
)
;
}
operator
mozilla
:
:
Span
<
const
char_type
>
(
)
const
{
return
mozilla
:
:
MakeSpan
(
base_string_type
:
:
BeginReading
(
)
base_string_type
:
:
Length
(
)
)
;
}
void
Append
(
mozilla
:
:
Span
<
const
char_type
>
aSpan
)
{
auto
len
=
aSpan
.
Length
(
)
;
MOZ_RELEASE_ASSERT
(
len
<
=
std
:
:
numeric_limits
<
size_type
>
:
:
max
(
)
)
;
Append
(
aSpan
.
Elements
(
)
len
)
;
}
MOZ_MUST_USE
bool
Append
(
mozilla
:
:
Span
<
const
char_type
>
aSpan
const
fallible_t
&
aFallible
)
{
auto
len
=
aSpan
.
Length
(
)
;
if
(
len
>
std
:
:
numeric_limits
<
size_type
>
:
:
max
(
)
)
{
return
false
;
}
return
Append
(
aSpan
.
Elements
(
)
len
aFallible
)
;
}
void
NS_FASTCALL
AssignASCII
(
mozilla
:
:
Span
<
const
char
>
aData
)
{
AssignASCII
(
aData
.
Elements
(
)
aData
.
Length
(
)
)
;
}
MOZ_MUST_USE
bool
NS_FASTCALL
AssignASCII
(
mozilla
:
:
Span
<
const
char
>
aData
const
fallible_t
&
aFallible
)
{
return
AssignASCII
(
aData
.
Elements
(
)
aData
.
Length
(
)
aFallible
)
;
}
void
AppendASCII
(
mozilla
:
:
Span
<
const
char
>
aData
)
{
AppendASCII
(
aData
.
Elements
(
)
aData
.
Length
(
)
)
;
}
template
<
typename
Q
=
T
typename
EnableIfChar
=
mozilla
:
:
CharOnlyT
<
Q
>
>
operator
mozilla
:
:
Span
<
uint8_t
>
(
)
{
return
mozilla
:
:
MakeSpan
(
reinterpret_cast
<
uint8_t
*
>
(
BeginWriting
(
)
)
base_string_type
:
:
Length
(
)
)
;
}
template
<
typename
Q
=
T
typename
EnableIfChar
=
mozilla
:
:
CharOnlyT
<
Q
>
>
operator
mozilla
:
:
Span
<
const
uint8_t
>
(
)
const
{
return
mozilla
:
:
MakeSpan
(
reinterpret_cast
<
const
uint8_t
*
>
(
base_string_type
:
:
BeginReading
(
)
)
base_string_type
:
:
Length
(
)
)
;
}
template
<
typename
Q
=
T
typename
EnableIfChar
=
mozilla
:
:
CharOnlyT
<
Q
>
>
void
Append
(
mozilla
:
:
Span
<
const
uint8_t
>
aSpan
)
{
auto
len
=
aSpan
.
Length
(
)
;
MOZ_RELEASE_ASSERT
(
len
<
=
std
:
:
numeric_limits
<
size_type
>
:
:
max
(
)
)
;
Append
(
reinterpret_cast
<
const
char
*
>
(
aSpan
.
Elements
(
)
)
len
)
;
}
template
<
typename
Q
=
T
typename
EnableIfChar
=
mozilla
:
:
CharOnlyT
<
Q
>
>
MOZ_MUST_USE
bool
Append
(
mozilla
:
:
Span
<
const
uint8_t
>
aSpan
const
fallible_t
&
aFallible
)
{
auto
len
=
aSpan
.
Length
(
)
;
if
(
len
>
std
:
:
numeric_limits
<
size_type
>
:
:
max
(
)
)
{
return
false
;
}
return
Append
(
reinterpret_cast
<
const
char
*
>
(
aSpan
.
Elements
(
)
)
len
aFallible
)
;
}
void
NS_FASTCALL
SetIsVoid
(
bool
)
;
void
StripChar
(
char_type
aChar
)
;
void
StripChars
(
const
char_type
*
aChars
)
;
void
StripTaggedASCII
(
const
std
:
:
array
<
bool
128
>
&
aToStrip
)
;
void
StripCRLF
(
)
;
void
ForgetSharedBuffer
(
)
{
if
(
base_string_type
:
:
mDataFlags
&
DataFlags
:
:
REFCOUNTED
)
{
SetToEmptyBuffer
(
)
;
}
}
protected
:
void
AssertValid
(
)
{
MOZ_ASSERT
(
!
(
this
-
>
mClassFlags
&
ClassFlags
:
:
NULL_TERMINATED
)
|
|
(
this
-
>
mDataFlags
&
DataFlags
:
:
TERMINATED
)
"
String
classes
whose
static
type
guarantees
a
null
-
terminated
"
"
buffer
must
not
be
assigned
a
non
-
null
-
terminated
buffer
.
"
)
;
}
public
:
MOZ_IMPLICIT
nsTSubstring
(
const
substring_tuple_type
&
aTuple
)
:
base_string_type
(
nullptr
0
DataFlags
(
0
)
ClassFlags
(
0
)
)
{
AssertValid
(
)
;
Assign
(
aTuple
)
;
}
size_t
SizeOfExcludingThisIfUnshared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
size_t
SizeOfIncludingThisIfUnshared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
size_t
SizeOfExcludingThisEvenIfShared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
size_t
SizeOfIncludingThisEvenIfShared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
template
<
class
N
>
void
NS_ABORT_OOM
(
T
)
{
struct
never
{
}
;
static_assert
(
mozilla
:
:
IsSame
<
N
never
>
:
:
value
"
In
string
classes
use
AllocFailed
to
account
for
sizeof
(
char_type
)
.
"
"
Use
the
global
:
:
NS_ABORT_OOM
if
you
really
have
a
count
of
bytes
.
"
)
;
}
MOZ_ALWAYS_INLINE
void
AllocFailed
(
size_t
aLength
)
{
:
:
NS_ABORT_OOM
(
aLength
*
sizeof
(
char_type
)
)
;
}
protected
:
nsTSubstring
(
)
:
base_string_type
(
char_traits
:
:
sEmptyBuffer
0
DataFlags
:
:
TERMINATED
ClassFlags
(
0
)
)
{
AssertValid
(
)
;
}
nsTSubstring
(
const
self_type
&
aStr
)
:
base_string_type
(
aStr
.
base_string_type
:
:
mData
aStr
.
base_string_type
:
:
mLength
aStr
.
base_string_type
:
:
mDataFlags
&
(
DataFlags
:
:
TERMINATED
|
DataFlags
:
:
VOIDED
)
ClassFlags
(
0
)
)
{
AssertValid
(
)
;
}
explicit
nsTSubstring
(
ClassFlags
aClassFlags
)
:
base_string_type
(
char_traits
:
:
sEmptyBuffer
0
DataFlags
:
:
TERMINATED
aClassFlags
)
{
AssertValid
(
)
;
}
nsTSubstring
(
char_type
*
aData
size_type
aLength
DataFlags
aDataFlags
ClassFlags
aClassFlags
)
#
if
defined
(
DEBUG
)
|
|
defined
(
FORCE_BUILD_REFCNT_LOGGING
)
#
define
XPCOM_STRING_CONSTRUCTOR_OUT_OF_LINE
;
#
else
#
undef
XPCOM_STRING_CONSTRUCTOR_OUT_OF_LINE
:
base_string_type
(
aData
aLength
aDataFlags
aClassFlags
)
{
AssertValid
(
)
;
MOZ_RELEASE_ASSERT
(
CheckCapacity
(
aLength
)
"
String
is
too
large
.
"
)
;
}
#
endif
void
SetToEmptyBuffer
(
)
{
base_string_type
:
:
mData
=
char_traits
:
:
sEmptyBuffer
;
base_string_type
:
:
mLength
=
0
;
base_string_type
:
:
mDataFlags
=
DataFlags
:
:
TERMINATED
;
AssertValid
(
)
;
}
void
SetData
(
char_type
*
aData
size_type
aLength
DataFlags
aDataFlags
)
{
base_string_type
:
:
mData
=
aData
;
base_string_type
:
:
mLength
=
aLength
;
base_string_type
:
:
mDataFlags
=
aDataFlags
;
AssertValid
(
)
;
}
void
NS_FASTCALL
Finalize
(
)
;
public
:
mozilla
:
:
BulkWriteHandle
<
T
>
NS_FASTCALL
BulkWrite
(
size_type
aCapacity
size_type
aPrefixToPreserve
bool
aAllowShrinking
nsresult
&
aRv
)
;
mozilla
:
:
Result
<
uint32_t
nsresult
>
NS_FASTCALL
StartBulkWriteImpl
(
size_type
aCapacity
size_type
aPrefixToPreserve
=
0
bool
aAllowShrinking
=
true
size_type
aSuffixLength
=
0
size_type
aOldSuffixStart
=
0
size_type
aNewSuffixStart
=
0
)
;
private
:
MOZ_ALWAYS_INLINE
void
NS_FASTCALL
FinishBulkWriteImplImpl
(
size_type
aLength
)
{
base_string_type
:
:
mData
[
aLength
]
=
char_type
(
0
)
;
base_string_type
:
:
mLength
=
aLength
;
#
ifdef
DEBUG
char_traits
:
:
uninitialize
(
base_string_type
:
:
mData
+
aLength
+
1
XPCOM_MIN
(
size_t
(
Capacity
(
)
-
aLength
)
kNsStringBufferMaxPoison
)
)
;
#
endif
}
protected
:
void
NS_FASTCALL
FinishBulkWriteImpl
(
size_type
aLength
)
;
MOZ_MUST_USE
bool
ReplacePrep
(
index_type
aCutStart
size_type
aCutLength
size_type
aNewLength
)
;
MOZ_MUST_USE
bool
NS_FASTCALL
ReplacePrepInternal
(
index_type
aCutStart
size_type
aCutLength
size_type
aNewFragLength
size_type
aNewTotalLength
)
;
size_type
NS_FASTCALL
Capacity
(
)
const
;
MOZ_MUST_USE
bool
NS_FASTCALL
EnsureMutable
(
size_type
aNewLen
=
size_type
(
-
1
)
)
;
static
MOZ_MUST_USE
bool
CheckCapacity
(
size_type
aCapacity
)
{
if
(
aCapacity
>
kMaxCapacity
)
{
NS_ASSERTION
(
aCapacity
!
=
size_type
(
-
1
)
"
Bogus
capacity
"
)
;
return
false
;
}
return
true
;
}
void
NS_FASTCALL
ReplaceLiteral
(
index_type
aCutStart
size_type
aCutLength
const
char_type
*
aData
size_type
aLength
)
;
static
const
size_type
kMaxCapacity
;
public
:
void
NS_FASTCALL
AssignLiteral
(
const
char_type
*
aData
size_type
aLength
)
;
}
;
extern
template
class
nsTSubstring
<
char
>
;
extern
template
class
nsTSubstring
<
char16_t
>
;
static_assert
(
sizeof
(
nsTSubstring
<
char
>
)
=
=
sizeof
(
mozilla
:
:
detail
:
:
nsTStringRepr
<
char
>
)
"
Don
'
t
add
new
data
fields
to
nsTSubstring_CharT
.
"
"
Add
to
nsTStringRepr
<
T
>
instead
.
"
)
;
template
<
typename
T
>
class
nsTSubstringSplitter
{
typedef
typename
nsTSubstring
<
T
>
:
:
size_type
size_type
;
typedef
typename
nsTSubstring
<
T
>
:
:
char_type
char_type
;
class
nsTSubstringSplit_Iter
{
public
:
nsTSubstringSplit_Iter
(
const
nsTSubstringSplitter
<
T
>
&
aObj
size_type
aPos
)
:
mObj
(
aObj
)
mPos
(
aPos
)
{
}
bool
operator
!
=
(
const
nsTSubstringSplit_Iter
&
other
)
const
{
return
mPos
!
=
other
.
mPos
;
}
const
nsTDependentSubstring
<
T
>
&
operator
*
(
)
const
;
const
nsTSubstringSplit_Iter
&
operator
+
+
(
)
{
+
+
mPos
;
return
*
this
;
}
private
:
const
nsTSubstringSplitter
<
T
>
&
mObj
;
size_type
mPos
;
}
;
private
:
const
nsTSubstring
<
T
>
*
const
mStr
;
mozilla
:
:
UniquePtr
<
nsTDependentSubstring
<
T
>
[
]
>
mArray
;
size_type
mArraySize
;
const
char_type
mDelim
;
public
:
nsTSubstringSplitter
(
const
nsTSubstring
<
T
>
*
aStr
char_type
aDelim
)
;
nsTSubstringSplit_Iter
begin
(
)
const
{
return
nsTSubstringSplit_Iter
(
*
this
0
)
;
}
nsTSubstringSplit_Iter
end
(
)
const
{
return
nsTSubstringSplit_Iter
(
*
this
mArraySize
)
;
}
const
nsTDependentSubstring
<
T
>
&
Get
(
const
size_type
index
)
const
{
MOZ_ASSERT
(
index
<
mArraySize
)
;
return
mArray
[
index
]
;
}
}
;
extern
template
class
nsTSubstringSplitter
<
char
>
;
extern
template
class
nsTSubstringSplitter
<
char16_t
>
;
namespace
mozilla
{
inline
Span
<
char
>
MakeSpan
(
nsTSubstring
<
char
>
&
aString
)
{
return
aString
;
}
inline
Span
<
const
char
>
MakeSpan
(
const
nsTSubstring
<
char
>
&
aString
)
{
return
aString
;
}
inline
Span
<
char16_t
>
MakeSpan
(
nsTSubstring
<
char16_t
>
&
aString
)
{
return
aString
;
}
inline
Span
<
const
char16_t
>
MakeSpan
(
const
nsTSubstring
<
char16_t
>
&
aString
)
{
return
aString
;
}
}
#
endif
