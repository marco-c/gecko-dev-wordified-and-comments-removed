#
ifndef
nsStringBuffer_h__
#
define
nsStringBuffer_h__
#
include
<
atomic
>
#
include
"
mozilla
/
MemoryReporting
.
h
"
template
<
class
T
>
struct
already_AddRefed
;
#
if
(
defined
(
DEBUG
)
|
|
defined
(
NIGHTLY_BUILD
)
)
&
&
!
defined
(
MOZ_ASAN
)
#
define
STRING_BUFFER_CANARY
1
#
endif
#
ifdef
STRING_BUFFER_CANARY
enum
nsStringBufferCanary
:
uint32_t
{
CANARY_OK
=
0xaf57c8fa
CANARY_POISON
=
0x534dc0f5
}
;
#
endif
class
nsStringBuffer
{
private
:
friend
class
CheckStaticAtomSizes
;
std
:
:
atomic
<
uint32_t
>
mRefCount
;
uint32_t
mStorageSize
;
#
ifdef
STRING_BUFFER_CANARY
uint32_t
mCanary
;
#
endif
public
:
static
already_AddRefed
<
nsStringBuffer
>
Alloc
(
size_t
aStorageSize
)
;
static
nsStringBuffer
*
Realloc
(
nsStringBuffer
*
aBuf
size_t
aStorageSize
)
;
void
NS_FASTCALL
AddRef
(
)
;
void
NS_FASTCALL
Release
(
)
;
static
nsStringBuffer
*
FromData
(
void
*
aData
)
;
void
*
Data
(
)
const
{
return
const_cast
<
char
*
>
(
reinterpret_cast
<
const
char
*
>
(
this
+
1
)
)
;
}
uint32_t
StorageSize
(
)
const
{
return
mStorageSize
;
}
bool
IsReadonly
(
)
const
{
return
mRefCount
.
load
(
std
:
:
memory_order_relaxed
)
>
1
;
}
static
nsStringBuffer
*
FromString
(
const
nsAString
&
aStr
)
;
static
nsStringBuffer
*
FromString
(
const
nsACString
&
aStr
)
;
void
ToString
(
uint32_t
aLen
nsAString
&
aStr
bool
aMoveOwnership
=
false
)
;
void
ToString
(
uint32_t
aLen
nsACString
&
aStr
bool
aMoveOwnership
=
false
)
;
size_t
SizeOfIncludingThisIfUnshared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
size_t
SizeOfIncludingThisEvenIfShared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
}
;
#
endif
