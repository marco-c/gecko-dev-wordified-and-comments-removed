#
ifndef
nsStringBuffer_h__
#
define
nsStringBuffer_h__
#
include
<
atomic
>
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
RefCounted
.
h
"
class
nsStringBuffer
{
private
:
std
:
:
atomic
<
uint32_t
>
mRefCount
;
uint32_t
mStorageSize
;
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
nsStringBuffer
)
static
already_AddRefed
<
nsStringBuffer
>
Alloc
(
size_t
aSize
)
{
MOZ_ASSERT
(
aSize
!
=
0
"
zero
capacity
allocation
not
allowed
"
)
;
MOZ_ASSERT
(
sizeof
(
nsStringBuffer
)
+
aSize
<
=
size_t
(
uint32_t
(
-
1
)
)
&
&
sizeof
(
nsStringBuffer
)
+
aSize
>
aSize
"
mStorageSize
will
truncate
"
)
;
auto
*
hdr
=
(
nsStringBuffer
*
)
malloc
(
sizeof
(
nsStringBuffer
)
+
aSize
)
;
if
(
hdr
)
{
hdr
-
>
mRefCount
=
1
;
hdr
-
>
mStorageSize
=
aSize
;
mozilla
:
:
detail
:
:
RefCountLogger
:
:
logAddRef
(
hdr
1
)
;
}
return
already_AddRefed
(
hdr
)
;
}
static
already_AddRefed
<
nsStringBuffer
>
Create
(
const
char16_t
*
aData
size_t
aLength
)
;
static
already_AddRefed
<
nsStringBuffer
>
Create
(
const
char
*
aData
size_t
aLength
)
;
static
nsStringBuffer
*
Realloc
(
nsStringBuffer
*
aBuf
size_t
aStorageSize
)
;
void
AddRef
(
)
{
uint32_t
count
=
mRefCount
.
fetch_add
(
1
std
:
:
memory_order_relaxed
)
+
1
;
mozilla
:
:
detail
:
:
RefCountLogger
:
:
logAddRef
(
this
count
)
;
}
void
Release
(
)
{
mozilla
:
:
detail
:
:
RefCountLogger
:
:
ReleaseLogger
logger
(
this
)
;
uint32_t
count
=
mRefCount
.
fetch_sub
(
1
std
:
:
memory_order_release
)
-
1
;
logger
.
logRelease
(
count
)
;
if
(
count
=
=
0
)
{
count
=
mRefCount
.
load
(
std
:
:
memory_order_acquire
)
;
free
(
this
)
;
}
}
static
nsStringBuffer
*
FromData
(
void
*
aData
)
{
return
reinterpret_cast
<
nsStringBuffer
*
>
(
aData
)
-
1
;
}
void
*
Data
(
)
const
{
return
const_cast
<
char
*
>
(
reinterpret_cast
<
const
char
*
>
(
this
+
1
)
)
;
}
uint32_t
StorageSize
(
)
const
{
return
mStorageSize
;
}
bool
IsReadonly
(
)
const
{
#
if
defined
(
MOZ_TSAN
)
return
mRefCount
.
load
(
std
:
:
memory_order_acquire
)
>
1
;
#
else
return
mRefCount
.
load
(
std
:
:
memory_order_relaxed
)
>
1
;
#
endif
}
size_t
SizeOfIncludingThisIfUnshared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
size_t
SizeOfIncludingThisEvenIfShared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
}
;
#
endif
