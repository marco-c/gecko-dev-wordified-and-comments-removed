#
include
"
double
-
conversion
/
double
-
conversion
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Printf
.
h
"
#
include
"
nsASCIIMask
.
h
"
const
uint32_t
kNsStringBufferShrinkingThreshold
=
384
;
using
double_conversion
:
:
DoubleToStringConverter
;
template
<
typename
T
>
const
typename
nsTSubstring
<
T
>
:
:
size_type
nsTSubstring
<
T
>
:
:
kMaxCapacity
=
(
nsTSubstring
<
T
>
:
:
size_type
(
-
1
)
/
2
-
sizeof
(
nsStringBuffer
)
)
/
sizeof
(
nsTSubstring
<
T
>
:
:
char_type
)
-
2
;
#
ifdef
XPCOM_STRING_CONSTRUCTOR_OUT_OF_LINE
template
<
typename
T
>
nsTSubstring
<
T
>
:
:
nsTSubstring
(
char_type
*
aData
size_type
aLength
DataFlags
aDataFlags
ClassFlags
aClassFlags
)
:
:
:
mozilla
:
:
detail
:
:
nsTStringRepr
<
T
>
(
aData
aLength
aDataFlags
aClassFlags
)
{
AssertValid
(
)
;
MOZ_RELEASE_ASSERT
(
CheckCapacity
(
aLength
)
"
String
is
too
large
.
"
)
;
if
(
aDataFlags
&
DataFlags
:
:
OWNED
)
{
STRING_STAT_INCREMENT
(
Adopt
)
;
MOZ_LOG_CTOR
(
this
-
>
mData
"
StringAdopt
"
1
)
;
}
}
#
endif
template
<
typename
T
>
inline
const
nsTAutoString
<
T
>
*
AsAutoString
(
const
nsTSubstring
<
T
>
*
aStr
)
{
return
static_cast
<
const
nsTAutoString
<
T
>
*
>
(
aStr
)
;
}
template
<
typename
T
>
mozilla
:
:
BulkWriteHandle
<
T
>
nsTSubstring
<
T
>
:
:
BulkWrite
(
size_type
aCapacity
size_type
aPrefixToPreserve
bool
aAllowShrinking
nsresult
&
aRv
)
{
auto
r
=
StartBulkWriteImpl
(
aCapacity
aPrefixToPreserve
aAllowShrinking
)
;
if
(
MOZ_UNLIKELY
(
r
.
isErr
(
)
)
)
{
aRv
=
r
.
unwrapErr
(
)
;
return
mozilla
:
:
BulkWriteHandle
<
T
>
(
nullptr
0
)
;
}
aRv
=
NS_OK
;
return
mozilla
:
:
BulkWriteHandle
<
T
>
(
this
r
.
unwrap
(
)
)
;
}
template
<
typename
T
>
mozilla
:
:
Result
<
uint32_t
nsresult
>
nsTSubstring
<
T
>
:
:
StartBulkWriteImpl
(
size_type
aCapacity
size_type
aPrefixToPreserve
bool
aAllowShrinking
size_type
aSuffixLength
size_type
aOldSuffixStart
size_type
aNewSuffixStart
)
{
MOZ_ASSERT
(
aPrefixToPreserve
<
=
aCapacity
"
Requested
preservation
of
an
overlong
prefix
.
"
)
;
MOZ_ASSERT
(
aNewSuffixStart
+
aSuffixLength
<
=
aCapacity
"
Requesed
move
of
suffix
to
out
-
of
-
bounds
location
.
"
)
;
if
(
MOZ_UNLIKELY
(
!
aCapacity
)
)
{
:
:
ReleaseData
(
this
-
>
mData
this
-
>
mDataFlags
)
;
SetToEmptyBuffer
(
)
;
return
0
;
}
const
size_type
curCapacity
=
Capacity
(
)
;
bool
shrinking
=
false
;
if
(
aCapacity
<
=
curCapacity
)
{
if
(
aAllowShrinking
)
{
shrinking
=
true
;
}
else
{
char_traits
:
:
move
(
this
-
>
mData
+
aNewSuffixStart
this
-
>
mData
+
aOldSuffixStart
aSuffixLength
)
;
if
(
aSuffixLength
)
{
char_traits
:
:
uninitialize
(
this
-
>
mData
+
aPrefixToPreserve
XPCOM_MIN
(
size_t
(
aNewSuffixStart
-
aPrefixToPreserve
)
kNsStringBufferMaxPoison
)
)
;
char_traits
:
:
uninitialize
(
this
-
>
mData
+
aNewSuffixStart
+
aSuffixLength
XPCOM_MIN
(
size_t
(
curCapacity
+
1
-
aNewSuffixStart
-
aSuffixLength
)
kNsStringBufferMaxPoison
)
)
;
}
else
{
char_traits
:
:
uninitialize
(
this
-
>
mData
+
aPrefixToPreserve
XPCOM_MIN
(
size_t
(
curCapacity
+
1
-
aPrefixToPreserve
)
kNsStringBufferMaxPoison
)
)
;
}
return
curCapacity
;
}
}
char_type
*
oldData
=
this
-
>
mData
;
DataFlags
oldFlags
=
this
-
>
mDataFlags
;
char_type
*
newData
;
DataFlags
newDataFlags
;
size_type
newCapacity
;
if
(
(
this
-
>
mClassFlags
&
ClassFlags
:
:
INLINE
)
&
&
(
aCapacity
<
=
AsAutoString
(
this
)
-
>
mInlineCapacity
)
)
{
newCapacity
=
AsAutoString
(
this
)
-
>
mInlineCapacity
;
newData
=
(
char_type
*
)
AsAutoString
(
this
)
-
>
mStorage
;
newDataFlags
=
DataFlags
:
:
TERMINATED
|
DataFlags
:
:
INLINE
;
}
else
{
static_assert
(
(
sizeof
(
nsStringBuffer
)
&
0x1
)
=
=
0
"
bad
size
for
nsStringBuffer
"
)
;
if
(
MOZ_UNLIKELY
(
!
CheckCapacity
(
aCapacity
)
)
)
{
return
mozilla
:
:
Err
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
const
size_type
slowGrowthThreshold
=
8
*
1024
*
1024
;
const
size_type
neededExtraSpace
=
sizeof
(
nsStringBuffer
)
/
sizeof
(
char_type
)
+
1
;
size_type
temp
;
if
(
aCapacity
>
=
slowGrowthThreshold
)
{
size_type
minNewCapacity
=
curCapacity
+
(
curCapacity
>
>
3
)
;
temp
=
XPCOM_MAX
(
aCapacity
minNewCapacity
)
+
neededExtraSpace
;
const
size_t
MiB
=
1
<
<
20
;
temp
=
(
MiB
*
(
(
temp
+
MiB
-
1
)
/
MiB
)
)
-
neededExtraSpace
;
}
else
{
temp
=
mozilla
:
:
RoundUpPow2
(
aCapacity
+
neededExtraSpace
)
-
neededExtraSpace
;
}
newCapacity
=
XPCOM_MIN
(
temp
kMaxCapacity
)
;
MOZ_ASSERT
(
newCapacity
>
=
aCapacity
"
should
have
hit
the
early
return
at
the
top
"
)
;
if
(
(
curCapacity
-
newCapacity
)
<
=
kNsStringBufferShrinkingThreshold
&
&
(
this
-
>
mDataFlags
&
DataFlags
:
:
REFCOUNTED
)
)
{
MOZ_ASSERT
(
aAllowShrinking
"
How
come
we
didn
'
t
return
earlier
?
"
)
;
newData
=
oldData
;
newCapacity
=
curCapacity
;
}
else
{
size_type
storageSize
=
(
newCapacity
+
1
)
*
sizeof
(
char_type
)
;
nsStringBuffer
*
newHdr
=
nsStringBuffer
:
:
Alloc
(
storageSize
)
.
take
(
)
;
if
(
newHdr
)
{
newData
=
(
char_type
*
)
newHdr
-
>
Data
(
)
;
}
else
if
(
shrinking
)
{
newData
=
oldData
;
newCapacity
=
curCapacity
;
}
else
{
return
mozilla
:
:
Err
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
}
newDataFlags
=
DataFlags
:
:
TERMINATED
|
DataFlags
:
:
REFCOUNTED
;
}
this
-
>
mData
=
newData
;
this
-
>
mDataFlags
=
newDataFlags
;
if
(
oldData
=
=
newData
)
{
char_traits
:
:
move
(
newData
+
aNewSuffixStart
oldData
+
aOldSuffixStart
aSuffixLength
)
;
if
(
aSuffixLength
)
{
char_traits
:
:
uninitialize
(
this
-
>
mData
+
aPrefixToPreserve
XPCOM_MIN
(
size_t
(
aNewSuffixStart
-
aPrefixToPreserve
)
kNsStringBufferMaxPoison
)
)
;
char_traits
:
:
uninitialize
(
this
-
>
mData
+
aNewSuffixStart
+
aSuffixLength
XPCOM_MIN
(
size_t
(
newCapacity
+
1
-
aNewSuffixStart
-
aSuffixLength
)
kNsStringBufferMaxPoison
)
)
;
}
else
{
char_traits
:
:
uninitialize
(
this
-
>
mData
+
aPrefixToPreserve
XPCOM_MIN
(
size_t
(
newCapacity
+
1
-
aPrefixToPreserve
)
kNsStringBufferMaxPoison
)
)
;
}
}
else
{
char_traits
:
:
copy
(
newData
oldData
aPrefixToPreserve
)
;
char_traits
:
:
copy
(
newData
+
aNewSuffixStart
oldData
+
aOldSuffixStart
aSuffixLength
)
;
:
:
ReleaseData
(
oldData
oldFlags
)
;
}
return
newCapacity
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
FinishBulkWriteImpl
(
size_type
aLength
)
{
MOZ_ASSERT
(
aLength
!
=
UINT32_MAX
"
OOM
magic
value
passed
as
length
.
"
)
;
if
(
aLength
)
{
FinishBulkWriteImplImpl
(
aLength
)
;
}
else
{
:
:
ReleaseData
(
this
-
>
mData
this
-
>
mDataFlags
)
;
SetToEmptyBuffer
(
)
;
}
AssertValid
(
)
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Finalize
(
)
{
:
:
ReleaseData
(
this
-
>
mData
this
-
>
mDataFlags
)
;
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
ReplacePrep
(
index_type
aCutStart
size_type
aCutLength
size_type
aNewLength
)
{
aCutLength
=
XPCOM_MIN
(
aCutLength
this
-
>
mLength
-
aCutStart
)
;
mozilla
:
:
CheckedInt
<
size_type
>
newTotalLen
=
this
-
>
mLength
;
newTotalLen
+
=
aNewLength
;
newTotalLen
-
=
aCutLength
;
if
(
!
newTotalLen
.
isValid
(
)
)
{
return
false
;
}
if
(
aCutStart
=
=
this
-
>
mLength
&
&
Capacity
(
)
>
newTotalLen
.
value
(
)
)
{
this
-
>
mDataFlags
&
=
~
DataFlags
:
:
VOIDED
;
this
-
>
mData
[
newTotalLen
.
value
(
)
]
=
char_type
(
0
)
;
this
-
>
mLength
=
newTotalLen
.
value
(
)
;
return
true
;
}
return
ReplacePrepInternal
(
aCutStart
aCutLength
aNewLength
newTotalLen
.
value
(
)
)
;
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
ReplacePrepInternal
(
index_type
aCutStart
size_type
aCutLen
size_type
aFragLen
size_type
aNewLen
)
{
size_type
newSuffixStart
=
aCutStart
+
aFragLen
;
size_type
oldSuffixStart
=
aCutStart
+
aCutLen
;
size_type
suffixLength
=
this
-
>
mLength
-
oldSuffixStart
;
mozilla
:
:
Result
<
uint32_t
nsresult
>
r
=
StartBulkWriteImpl
(
aNewLen
aCutStart
false
suffixLength
oldSuffixStart
newSuffixStart
)
;
if
(
r
.
isErr
(
)
)
{
return
false
;
}
FinishBulkWriteImpl
(
aNewLen
)
;
return
true
;
}
template
<
typename
T
>
typename
nsTSubstring
<
T
>
:
:
size_type
nsTSubstring
<
T
>
:
:
Capacity
(
)
const
{
size_type
capacity
;
if
(
this
-
>
mDataFlags
&
DataFlags
:
:
REFCOUNTED
)
{
nsStringBuffer
*
hdr
=
nsStringBuffer
:
:
FromData
(
this
-
>
mData
)
;
if
(
hdr
-
>
IsReadonly
(
)
)
{
capacity
=
0
;
}
else
{
capacity
=
(
hdr
-
>
StorageSize
(
)
/
sizeof
(
char_type
)
)
-
1
;
}
}
else
if
(
this
-
>
mDataFlags
&
DataFlags
:
:
INLINE
)
{
capacity
=
AsAutoString
(
this
)
-
>
mInlineCapacity
;
}
else
if
(
this
-
>
mDataFlags
&
DataFlags
:
:
OWNED
)
{
capacity
=
this
-
>
mLength
;
}
else
{
capacity
=
0
;
}
return
capacity
;
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
EnsureMutable
(
size_type
aNewLen
)
{
if
(
aNewLen
=
=
size_type
(
-
1
)
|
|
aNewLen
=
=
this
-
>
mLength
)
{
if
(
this
-
>
mDataFlags
&
(
DataFlags
:
:
INLINE
|
DataFlags
:
:
OWNED
)
)
{
return
true
;
}
if
(
(
this
-
>
mDataFlags
&
DataFlags
:
:
REFCOUNTED
)
&
&
!
nsStringBuffer
:
:
FromData
(
this
-
>
mData
)
-
>
IsReadonly
(
)
)
{
return
true
;
}
aNewLen
=
this
-
>
mLength
;
}
return
SetLength
(
aNewLen
mozilla
:
:
fallible
)
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Assign
(
char_type
aChar
)
{
if
(
MOZ_UNLIKELY
(
!
Assign
(
aChar
mozilla
:
:
fallible
)
)
)
{
AllocFailed
(
1
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
Assign
(
char_type
aChar
const
fallible_t
&
)
{
auto
r
=
StartBulkWriteImpl
(
1
0
true
)
;
if
(
MOZ_UNLIKELY
(
r
.
isErr
(
)
)
)
{
return
false
;
}
*
this
-
>
mData
=
aChar
;
FinishBulkWriteImpl
(
1
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Assign
(
const
char_type
*
aData
size_type
aLength
)
{
if
(
MOZ_UNLIKELY
(
!
Assign
(
aData
aLength
mozilla
:
:
fallible
)
)
)
{
AllocFailed
(
aLength
=
=
size_type
(
-
1
)
?
char_traits
:
:
length
(
aData
)
:
aLength
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
Assign
(
const
char_type
*
aData
const
fallible_t
&
aFallible
)
{
return
Assign
(
aData
size_type
(
-
1
)
aFallible
)
;
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
Assign
(
const
char_type
*
aData
size_type
aLength
const
fallible_t
&
aFallible
)
{
if
(
!
aData
|
|
aLength
=
=
0
)
{
Truncate
(
)
;
return
true
;
}
if
(
MOZ_UNLIKELY
(
aLength
=
=
size_type
(
-
1
)
)
)
{
aLength
=
char_traits
:
:
length
(
aData
)
;
}
if
(
MOZ_UNLIKELY
(
this
-
>
IsDependentOn
(
aData
aData
+
aLength
)
)
)
{
return
Assign
(
string_type
(
aData
aLength
)
aFallible
)
;
}
auto
r
=
StartBulkWriteImpl
(
aLength
0
true
)
;
if
(
MOZ_UNLIKELY
(
r
.
isErr
(
)
)
)
{
return
false
;
}
char_traits
:
:
copy
(
this
-
>
mData
aData
aLength
)
;
FinishBulkWriteImpl
(
aLength
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
AssignASCII
(
const
char
*
aData
size_type
aLength
)
{
if
(
MOZ_UNLIKELY
(
!
AssignASCII
(
aData
aLength
mozilla
:
:
fallible
)
)
)
{
AllocFailed
(
aLength
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
AssignASCII
(
const
char
*
aData
size_type
aLength
const
fallible_t
&
aFallible
)
{
MOZ_ASSERT
(
aLength
!
=
size_type
(
-
1
)
)
;
#
ifdef
CharT_is_char
if
(
this
-
>
IsDependentOn
(
aData
aData
+
aLength
)
)
{
return
Assign
(
string_type
(
aData
aLength
)
aFallible
)
;
}
#
endif
auto
r
=
StartBulkWriteImpl
(
aLength
0
true
)
;
if
(
MOZ_UNLIKELY
(
r
.
isErr
(
)
)
)
{
return
false
;
}
char_traits
:
:
copyASCII
(
this
-
>
mData
aData
aLength
)
;
FinishBulkWriteImpl
(
aLength
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
AssignLiteral
(
const
char_type
*
aData
size_type
aLength
)
{
:
:
ReleaseData
(
this
-
>
mData
this
-
>
mDataFlags
)
;
SetData
(
const_cast
<
char_type
*
>
(
aData
)
aLength
DataFlags
:
:
TERMINATED
|
DataFlags
:
:
LITERAL
)
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Assign
(
const
self_type
&
aStr
)
{
if
(
!
Assign
(
aStr
mozilla
:
:
fallible
)
)
{
AllocFailed
(
aStr
.
Length
(
)
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
Assign
(
const
self_type
&
aStr
const
fallible_t
&
aFallible
)
{
if
(
&
aStr
=
=
this
)
{
return
true
;
}
if
(
!
aStr
.
mLength
)
{
Truncate
(
)
;
this
-
>
mDataFlags
|
=
aStr
.
mDataFlags
&
DataFlags
:
:
VOIDED
;
return
true
;
}
if
(
aStr
.
mDataFlags
&
DataFlags
:
:
REFCOUNTED
)
{
NS_ASSERTION
(
aStr
.
mDataFlags
&
DataFlags
:
:
TERMINATED
"
shared
but
not
terminated
"
)
;
:
:
ReleaseData
(
this
-
>
mData
this
-
>
mDataFlags
)
;
SetData
(
aStr
.
mData
aStr
.
mLength
DataFlags
:
:
TERMINATED
|
DataFlags
:
:
REFCOUNTED
)
;
nsStringBuffer
:
:
FromData
(
this
-
>
mData
)
-
>
AddRef
(
)
;
return
true
;
}
else
if
(
aStr
.
mDataFlags
&
DataFlags
:
:
LITERAL
)
{
MOZ_ASSERT
(
aStr
.
mDataFlags
&
DataFlags
:
:
TERMINATED
"
Unterminated
literal
"
)
;
AssignLiteral
(
aStr
.
mData
aStr
.
mLength
)
;
return
true
;
}
return
Assign
(
aStr
.
Data
(
)
aStr
.
Length
(
)
aFallible
)
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Assign
(
self_type
&
&
aStr
)
{
if
(
!
Assign
(
std
:
:
move
(
aStr
)
mozilla
:
:
fallible
)
)
{
AllocFailed
(
aStr
.
Length
(
)
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
Assign
(
self_type
&
&
aStr
const
fallible_t
&
aFallible
)
{
if
(
&
aStr
=
=
this
)
{
NS_WARNING
(
"
Move
assigning
a
string
to
itself
?
"
)
;
return
true
;
}
if
(
aStr
.
mDataFlags
&
(
DataFlags
:
:
REFCOUNTED
|
DataFlags
:
:
OWNED
)
)
{
NS_ASSERTION
(
aStr
.
mDataFlags
&
DataFlags
:
:
TERMINATED
"
shared
or
owned
but
not
terminated
"
)
;
:
:
ReleaseData
(
this
-
>
mData
this
-
>
mDataFlags
)
;
SetData
(
aStr
.
mData
aStr
.
mLength
aStr
.
mDataFlags
)
;
aStr
.
SetToEmptyBuffer
(
)
;
return
true
;
}
if
(
!
Assign
(
aStr
aFallible
)
)
{
return
false
;
}
aStr
.
Truncate
(
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Assign
(
const
substring_tuple_type
&
aTuple
)
{
if
(
!
Assign
(
aTuple
mozilla
:
:
fallible
)
)
{
AllocFailed
(
aTuple
.
Length
(
)
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
Assign
(
const
substring_tuple_type
&
aTuple
const
fallible_t
&
aFallible
)
{
if
(
aTuple
.
IsDependentOn
(
this
-
>
mData
this
-
>
mData
+
this
-
>
mLength
)
)
{
return
Assign
(
string_type
(
aTuple
)
aFallible
)
;
}
size_type
length
=
aTuple
.
Length
(
)
;
mozilla
:
:
Result
<
uint32_t
nsresult
>
r
=
StartBulkWriteImpl
(
length
)
;
if
(
r
.
isErr
(
)
)
{
return
false
;
}
aTuple
.
WriteTo
(
this
-
>
mData
length
)
;
FinishBulkWriteImpl
(
length
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Adopt
(
char_type
*
aData
size_type
aLength
)
{
if
(
aData
)
{
:
:
ReleaseData
(
this
-
>
mData
this
-
>
mDataFlags
)
;
if
(
aLength
=
=
size_type
(
-
1
)
)
{
aLength
=
char_traits
:
:
length
(
aData
)
;
}
MOZ_RELEASE_ASSERT
(
CheckCapacity
(
aLength
)
"
adopting
a
too
-
long
string
"
)
;
SetData
(
aData
aLength
DataFlags
:
:
TERMINATED
|
DataFlags
:
:
OWNED
)
;
STRING_STAT_INCREMENT
(
Adopt
)
;
MOZ_LOG_CTOR
(
this
-
>
mData
"
StringAdopt
"
1
)
;
}
else
{
SetIsVoid
(
true
)
;
}
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Replace
(
index_type
aCutStart
size_type
aCutLength
char_type
aChar
)
{
aCutStart
=
XPCOM_MIN
(
aCutStart
this
-
>
Length
(
)
)
;
if
(
ReplacePrep
(
aCutStart
aCutLength
1
)
)
{
this
-
>
mData
[
aCutStart
]
=
aChar
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
Replace
(
index_type
aCutStart
size_type
aCutLength
char_type
aChar
const
fallible_t
&
)
{
aCutStart
=
XPCOM_MIN
(
aCutStart
this
-
>
Length
(
)
)
;
if
(
!
ReplacePrep
(
aCutStart
aCutLength
1
)
)
{
return
false
;
}
this
-
>
mData
[
aCutStart
]
=
aChar
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Replace
(
index_type
aCutStart
size_type
aCutLength
const
char_type
*
aData
size_type
aLength
)
{
if
(
!
Replace
(
aCutStart
aCutLength
aData
aLength
mozilla
:
:
fallible
)
)
{
AllocFailed
(
this
-
>
Length
(
)
-
aCutLength
+
1
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
Replace
(
index_type
aCutStart
size_type
aCutLength
const
char_type
*
aData
size_type
aLength
const
fallible_t
&
aFallible
)
{
if
(
!
aData
)
{
aLength
=
0
;
}
else
{
if
(
aLength
=
=
size_type
(
-
1
)
)
{
aLength
=
char_traits
:
:
length
(
aData
)
;
}
if
(
this
-
>
IsDependentOn
(
aData
aData
+
aLength
)
)
{
nsTAutoString
<
T
>
temp
(
aData
aLength
)
;
return
Replace
(
aCutStart
aCutLength
temp
aFallible
)
;
}
}
aCutStart
=
XPCOM_MIN
(
aCutStart
this
-
>
Length
(
)
)
;
bool
ok
=
ReplacePrep
(
aCutStart
aCutLength
aLength
)
;
if
(
!
ok
)
{
return
false
;
}
if
(
aLength
>
0
)
{
char_traits
:
:
copy
(
this
-
>
mData
+
aCutStart
aData
aLength
)
;
}
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
ReplaceASCII
(
index_type
aCutStart
size_type
aCutLength
const
char
*
aData
size_type
aLength
)
{
if
(
!
ReplaceASCII
(
aCutStart
aCutLength
aData
aLength
mozilla
:
:
fallible
)
)
{
AllocFailed
(
this
-
>
Length
(
)
-
aCutLength
+
1
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
ReplaceASCII
(
index_type
aCutStart
size_type
aCutLength
const
char
*
aData
size_type
aLength
const
fallible_t
&
aFallible
)
{
if
(
aLength
=
=
size_type
(
-
1
)
)
{
aLength
=
strlen
(
aData
)
;
}
#
ifdef
CharT_is_char
if
(
this
-
>
IsDependentOn
(
aData
aData
+
aLength
)
)
{
nsTAutoString_CharT
temp
(
aData
aLength
)
;
return
Replace
(
aCutStart
aCutLength
temp
aFallible
)
;
}
#
endif
aCutStart
=
XPCOM_MIN
(
aCutStart
this
-
>
Length
(
)
)
;
bool
ok
=
ReplacePrep
(
aCutStart
aCutLength
aLength
)
;
if
(
!
ok
)
{
return
false
;
}
if
(
aLength
>
0
)
{
char_traits
:
:
copyASCII
(
this
-
>
mData
+
aCutStart
aData
aLength
)
;
}
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Replace
(
index_type
aCutStart
size_type
aCutLength
const
substring_tuple_type
&
aTuple
)
{
if
(
aTuple
.
IsDependentOn
(
this
-
>
mData
this
-
>
mData
+
this
-
>
mLength
)
)
{
nsTAutoString
<
T
>
temp
(
aTuple
)
;
Replace
(
aCutStart
aCutLength
temp
)
;
return
;
}
size_type
length
=
aTuple
.
Length
(
)
;
aCutStart
=
XPCOM_MIN
(
aCutStart
this
-
>
Length
(
)
)
;
if
(
ReplacePrep
(
aCutStart
aCutLength
length
)
&
&
length
>
0
)
{
aTuple
.
WriteTo
(
this
-
>
mData
+
aCutStart
length
)
;
}
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
ReplaceLiteral
(
index_type
aCutStart
size_type
aCutLength
const
char_type
*
aData
size_type
aLength
)
{
aCutStart
=
XPCOM_MIN
(
aCutStart
this
-
>
Length
(
)
)
;
if
(
!
aCutStart
&
&
aCutLength
=
=
this
-
>
Length
(
)
&
&
!
(
this
-
>
mDataFlags
&
DataFlags
:
:
REFCOUNTED
)
)
{
AssignLiteral
(
aData
aLength
)
;
}
else
if
(
ReplacePrep
(
aCutStart
aCutLength
aLength
)
&
&
aLength
>
0
)
{
char_traits
:
:
copy
(
this
-
>
mData
+
aCutStart
aData
aLength
)
;
}
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Append
(
char_type
aChar
)
{
if
(
MOZ_UNLIKELY
(
!
Append
(
aChar
mozilla
:
:
fallible
)
)
)
{
AllocFailed
(
this
-
>
mLength
+
1
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
Append
(
char_type
aChar
const
fallible_t
&
aFallible
)
{
size_type
oldLen
=
this
-
>
mLength
;
size_type
newLen
=
oldLen
+
1
;
auto
r
=
StartBulkWriteImpl
(
newLen
oldLen
false
)
;
if
(
MOZ_UNLIKELY
(
r
.
isErr
(
)
)
)
{
return
false
;
}
this
-
>
mData
[
oldLen
]
=
aChar
;
FinishBulkWriteImpl
(
newLen
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Append
(
const
char_type
*
aData
size_type
aLength
)
{
if
(
MOZ_UNLIKELY
(
!
Append
(
aData
aLength
mozilla
:
:
fallible
)
)
)
{
AllocFailed
(
this
-
>
mLength
+
(
aLength
=
=
size_type
(
-
1
)
?
char_traits
:
:
length
(
aData
)
:
aLength
)
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
Append
(
const
char_type
*
aData
size_type
aLength
const
fallible_t
&
aFallible
)
{
if
(
MOZ_UNLIKELY
(
aLength
=
=
size_type
(
-
1
)
)
)
{
aLength
=
char_traits
:
:
length
(
aData
)
;
}
if
(
MOZ_UNLIKELY
(
!
aLength
)
)
{
return
true
;
}
if
(
MOZ_UNLIKELY
(
this
-
>
IsDependentOn
(
aData
aData
+
aLength
)
)
)
{
return
Append
(
string_type
(
aData
aLength
)
mozilla
:
:
fallible
)
;
}
size_type
oldLen
=
this
-
>
mLength
;
mozilla
:
:
CheckedInt
<
size_type
>
newLen
(
oldLen
)
;
newLen
+
=
aLength
;
if
(
MOZ_UNLIKELY
(
!
newLen
.
isValid
(
)
)
)
{
return
false
;
}
auto
r
=
StartBulkWriteImpl
(
newLen
.
value
(
)
oldLen
false
)
;
if
(
MOZ_UNLIKELY
(
r
.
isErr
(
)
)
)
{
return
false
;
}
char_traits
:
:
copy
(
this
-
>
mData
+
oldLen
aData
aLength
)
;
FinishBulkWriteImpl
(
newLen
.
value
(
)
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
AppendASCII
(
const
char
*
aData
size_type
aLength
)
{
if
(
MOZ_UNLIKELY
(
!
AppendASCII
(
aData
aLength
mozilla
:
:
fallible
)
)
)
{
AllocFailed
(
this
-
>
mLength
+
(
aLength
=
=
size_type
(
-
1
)
?
strlen
(
aData
)
:
aLength
)
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
AppendASCII
(
const
char
*
aData
const
fallible_t
&
aFallible
)
{
return
AppendASCII
(
aData
size_type
(
-
1
)
aFallible
)
;
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
AppendASCII
(
const
char
*
aData
size_type
aLength
const
fallible_t
&
aFallible
)
{
if
(
MOZ_UNLIKELY
(
aLength
=
=
size_type
(
-
1
)
)
)
{
aLength
=
strlen
(
aData
)
;
}
if
(
MOZ_UNLIKELY
(
!
aLength
)
)
{
return
true
;
}
#
ifdef
CharT_is_char
if
(
MOZ_UNLIKELY
(
this
-
>
IsDependentOn
(
aData
aData
+
aLength
)
)
)
{
return
Append
(
string_type
(
aData
aLength
)
mozilla
:
:
fallible
)
;
}
#
endif
size_type
oldLen
=
this
-
>
mLength
;
mozilla
:
:
CheckedInt
<
size_type
>
newLen
(
oldLen
)
;
newLen
+
=
aLength
;
if
(
MOZ_UNLIKELY
(
!
newLen
.
isValid
(
)
)
)
{
return
false
;
}
auto
r
=
StartBulkWriteImpl
(
newLen
.
value
(
)
oldLen
false
)
;
if
(
MOZ_UNLIKELY
(
r
.
isErr
(
)
)
)
{
return
false
;
}
char_traits
:
:
copyASCII
(
this
-
>
mData
+
oldLen
aData
aLength
)
;
FinishBulkWriteImpl
(
newLen
.
value
(
)
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Append
(
const
self_type
&
aStr
)
{
if
(
MOZ_UNLIKELY
(
!
Append
(
aStr
mozilla
:
:
fallible
)
)
)
{
AllocFailed
(
this
-
>
mLength
+
aStr
.
Length
(
)
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
Append
(
const
self_type
&
aStr
const
fallible_t
&
aFallible
)
{
if
(
MOZ_UNLIKELY
(
!
this
-
>
mLength
&
&
!
(
this
-
>
mDataFlags
&
DataFlags
:
:
REFCOUNTED
)
)
)
{
return
Assign
(
aStr
mozilla
:
:
fallible
)
;
}
return
Append
(
aStr
.
BeginReading
(
)
aStr
.
Length
(
)
mozilla
:
:
fallible
)
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Append
(
const
substring_tuple_type
&
aTuple
)
{
if
(
MOZ_UNLIKELY
(
!
Append
(
aTuple
mozilla
:
:
fallible
)
)
)
{
AllocFailed
(
this
-
>
mLength
+
aTuple
.
Length
(
)
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
Append
(
const
substring_tuple_type
&
aTuple
const
fallible_t
&
aFallible
)
{
size_type
tupleLength
=
aTuple
.
Length
(
)
;
if
(
MOZ_UNLIKELY
(
!
tupleLength
)
)
{
return
true
;
}
if
(
MOZ_UNLIKELY
(
aTuple
.
IsDependentOn
(
this
-
>
mData
this
-
>
mData
+
this
-
>
mLength
)
)
)
{
return
Append
(
string_type
(
aTuple
)
aFallible
)
;
}
size_type
oldLen
=
this
-
>
mLength
;
mozilla
:
:
CheckedInt
<
size_type
>
newLen
(
oldLen
)
;
newLen
+
=
tupleLength
;
if
(
MOZ_UNLIKELY
(
!
newLen
.
isValid
(
)
)
)
{
return
false
;
}
auto
r
=
StartBulkWriteImpl
(
newLen
.
value
(
)
oldLen
false
)
;
if
(
MOZ_UNLIKELY
(
r
.
isErr
(
)
)
)
{
return
false
;
}
aTuple
.
WriteTo
(
this
-
>
mData
+
oldLen
tupleLength
)
;
FinishBulkWriteImpl
(
newLen
.
value
(
)
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
SetCapacity
(
size_type
aCapacity
)
{
if
(
!
SetCapacity
(
aCapacity
mozilla
:
:
fallible
)
)
{
AllocFailed
(
aCapacity
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
SetCapacity
(
size_type
aCapacity
const
fallible_t
&
)
{
size_type
length
=
this
-
>
mLength
;
size_type
capacity
=
XPCOM_MAX
(
aCapacity
length
)
;
mozilla
:
:
Result
<
uint32_t
nsresult
>
r
=
StartBulkWriteImpl
(
capacity
length
true
)
;
if
(
r
.
isErr
(
)
)
{
return
false
;
}
if
(
MOZ_UNLIKELY
(
!
capacity
)
)
{
AssertValid
(
)
;
return
true
;
}
FinishBulkWriteImplImpl
(
length
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
SetLength
(
size_type
aLength
)
{
if
(
!
SetLength
(
aLength
mozilla
:
:
fallible
)
)
{
AllocFailed
(
aLength
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
SetLength
(
size_type
aLength
const
fallible_t
&
aFallible
)
{
size_type
preserve
=
XPCOM_MIN
(
aLength
this
-
>
mLength
)
;
mozilla
:
:
Result
<
uint32_t
nsresult
>
r
=
StartBulkWriteImpl
(
aLength
preserve
true
)
;
if
(
r
.
isErr
(
)
)
{
return
false
;
}
FinishBulkWriteImpl
(
aLength
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Truncate
(
)
{
:
:
ReleaseData
(
this
-
>
mData
this
-
>
mDataFlags
)
;
SetToEmptyBuffer
(
)
;
AssertValid
(
)
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
SetIsVoid
(
bool
aVal
)
{
if
(
aVal
)
{
Truncate
(
)
;
this
-
>
mDataFlags
|
=
DataFlags
:
:
VOIDED
;
}
else
{
this
-
>
mDataFlags
&
=
~
DataFlags
:
:
VOIDED
;
}
}
namespace
mozilla
{
namespace
detail
{
template
<
typename
T
>
typename
nsTStringRepr
<
T
>
:
:
char_type
nsTStringRepr
<
T
>
:
:
First
(
)
const
{
MOZ_RELEASE_ASSERT
(
this
-
>
mLength
>
0
"
|
First
(
)
|
called
on
an
empty
string
"
)
;
return
this
-
>
mData
[
0
]
;
}
template
<
typename
T
>
typename
nsTStringRepr
<
T
>
:
:
char_type
nsTStringRepr
<
T
>
:
:
Last
(
)
const
{
MOZ_RELEASE_ASSERT
(
this
-
>
mLength
>
0
"
|
Last
(
)
|
called
on
an
empty
string
"
)
;
return
this
-
>
mData
[
this
-
>
mLength
-
1
]
;
}
template
<
typename
T
>
bool
nsTStringRepr
<
T
>
:
:
Equals
(
const
self_type
&
aStr
)
const
{
return
this
-
>
mLength
=
=
aStr
.
mLength
&
&
char_traits
:
:
compare
(
this
-
>
mData
aStr
.
mData
this
-
>
mLength
)
=
=
0
;
}
template
<
typename
T
>
bool
nsTStringRepr
<
T
>
:
:
Equals
(
const
self_type
&
aStr
const
comparator_type
&
aComp
)
const
{
return
this
-
>
mLength
=
=
aStr
.
mLength
&
&
aComp
(
this
-
>
mData
aStr
.
mData
this
-
>
mLength
aStr
.
mLength
)
=
=
0
;
}
template
<
typename
T
>
bool
nsTStringRepr
<
T
>
:
:
Equals
(
const
substring_tuple_type
&
aTuple
)
const
{
return
Equals
(
substring_type
(
aTuple
)
)
;
}
template
<
typename
T
>
bool
nsTStringRepr
<
T
>
:
:
Equals
(
const
substring_tuple_type
&
aTuple
const
comparator_type
&
aComp
)
const
{
return
Equals
(
substring_type
(
aTuple
)
aComp
)
;
}
template
<
typename
T
>
bool
nsTStringRepr
<
T
>
:
:
Equals
(
const
char_type
*
aData
)
const
{
if
(
!
aData
)
{
MOZ_ASSERT_UNREACHABLE
(
"
null
data
pointer
"
)
;
return
this
-
>
mLength
=
=
0
;
}
size_type
length
=
char_traits
:
:
length
(
aData
)
;
return
this
-
>
mLength
=
=
length
&
&
char_traits
:
:
compare
(
this
-
>
mData
aData
this
-
>
mLength
)
=
=
0
;
}
template
<
typename
T
>
bool
nsTStringRepr
<
T
>
:
:
Equals
(
const
char_type
*
aData
const
comparator_type
&
aComp
)
const
{
if
(
!
aData
)
{
MOZ_ASSERT_UNREACHABLE
(
"
null
data
pointer
"
)
;
return
this
-
>
mLength
=
=
0
;
}
size_type
length
=
char_traits
:
:
length
(
aData
)
;
return
this
-
>
mLength
=
=
length
&
&
aComp
(
this
-
>
mData
aData
this
-
>
mLength
length
)
=
=
0
;
}
template
<
typename
T
>
bool
nsTStringRepr
<
T
>
:
:
EqualsASCII
(
const
char
*
aData
size_type
aLen
)
const
{
return
this
-
>
mLength
=
=
aLen
&
&
char_traits
:
:
compareASCII
(
this
-
>
mData
aData
aLen
)
=
=
0
;
}
template
<
typename
T
>
bool
nsTStringRepr
<
T
>
:
:
EqualsASCII
(
const
char
*
aData
)
const
{
return
char_traits
:
:
compareASCIINullTerminated
(
this
-
>
mData
this
-
>
mLength
aData
)
=
=
0
;
}
template
<
typename
T
>
bool
nsTStringRepr
<
T
>
:
:
LowerCaseEqualsASCII
(
const
char
*
aData
size_type
aLen
)
const
{
return
this
-
>
mLength
=
=
aLen
&
&
char_traits
:
:
compareLowerCaseToASCII
(
this
-
>
mData
aData
aLen
)
=
=
0
;
}
template
<
typename
T
>
bool
nsTStringRepr
<
T
>
:
:
LowerCaseEqualsASCII
(
const
char
*
aData
)
const
{
return
char_traits
:
:
compareLowerCaseToASCIINullTerminated
(
this
-
>
mData
this
-
>
mLength
aData
)
=
=
0
;
}
template
<
typename
T
>
typename
nsTStringRepr
<
T
>
:
:
size_type
nsTStringRepr
<
T
>
:
:
CountChar
(
char_type
aChar
)
const
{
const
char_type
*
start
=
this
-
>
mData
;
const
char_type
*
end
=
this
-
>
mData
+
this
-
>
mLength
;
return
NS_COUNT
(
start
end
aChar
)
;
}
template
<
typename
T
>
int32_t
nsTStringRepr
<
T
>
:
:
FindChar
(
char_type
aChar
index_type
aOffset
)
const
{
if
(
aOffset
<
this
-
>
mLength
)
{
const
char_type
*
result
=
char_traits
:
:
find
(
this
-
>
mData
+
aOffset
this
-
>
mLength
-
aOffset
aChar
)
;
if
(
result
)
{
return
result
-
this
-
>
mData
;
}
}
return
-
1
;
}
}
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
StripChar
(
char_type
aChar
)
{
if
(
this
-
>
mLength
=
=
0
)
{
return
;
}
if
(
!
EnsureMutable
(
)
)
{
AllocFailed
(
this
-
>
mLength
)
;
}
char_type
*
to
=
this
-
>
mData
;
char_type
*
from
=
this
-
>
mData
;
char_type
*
end
=
this
-
>
mData
+
this
-
>
mLength
;
while
(
from
<
end
)
{
char_type
theChar
=
*
from
+
+
;
if
(
aChar
!
=
theChar
)
{
*
to
+
+
=
theChar
;
}
}
*
to
=
char_type
(
0
)
;
this
-
>
mLength
=
to
-
this
-
>
mData
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
StripChars
(
const
char_type
*
aChars
)
{
if
(
this
-
>
mLength
=
=
0
)
{
return
;
}
if
(
!
EnsureMutable
(
)
)
{
AllocFailed
(
this
-
>
mLength
)
;
}
char_type
*
to
=
this
-
>
mData
;
char_type
*
from
=
this
-
>
mData
;
char_type
*
end
=
this
-
>
mData
+
this
-
>
mLength
;
while
(
from
<
end
)
{
char_type
theChar
=
*
from
+
+
;
const
char_type
*
test
=
aChars
;
for
(
;
*
test
&
&
*
test
!
=
theChar
;
+
+
test
)
;
if
(
!
*
test
)
{
*
to
+
+
=
theChar
;
}
}
*
to
=
char_type
(
0
)
;
this
-
>
mLength
=
to
-
this
-
>
mData
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
StripTaggedASCII
(
const
ASCIIMaskArray
&
aToStrip
)
{
if
(
this
-
>
mLength
=
=
0
)
{
return
;
}
if
(
!
EnsureMutable
(
)
)
{
AllocFailed
(
this
-
>
mLength
)
;
}
char_type
*
to
=
this
-
>
mData
;
char_type
*
from
=
this
-
>
mData
;
char_type
*
end
=
this
-
>
mData
+
this
-
>
mLength
;
while
(
from
<
end
)
{
uint32_t
theChar
=
(
uint32_t
)
*
from
+
+
;
if
(
!
mozilla
:
:
ASCIIMask
:
:
IsMasked
(
aToStrip
theChar
)
)
{
*
to
+
+
=
(
char_type
)
theChar
;
}
}
*
to
=
char_type
(
0
)
;
this
-
>
mLength
=
to
-
this
-
>
mData
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
StripCRLF
(
)
{
StripTaggedASCII
(
mozilla
:
:
ASCIIMask
:
:
MaskCRLF
(
)
)
;
}
template
<
typename
T
>
struct
MOZ_STACK_CLASS
PrintfAppend
:
public
mozilla
:
:
PrintfTarget
{
explicit
PrintfAppend
(
nsTSubstring
<
T
>
*
aString
)
:
mString
(
aString
)
{
}
bool
append
(
const
char
*
aStr
size_t
aLen
)
override
{
if
(
aLen
=
=
0
)
{
return
true
;
}
mString
-
>
AppendASCII
(
aStr
aLen
)
;
return
true
;
}
private
:
nsTSubstring
<
T
>
*
mString
;
}
;
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
AppendPrintf
(
const
char
*
aFormat
.
.
.
)
{
PrintfAppend
<
T
>
appender
(
this
)
;
va_list
ap
;
va_start
(
ap
aFormat
)
;
bool
r
=
appender
.
vprint
(
aFormat
ap
)
;
if
(
!
r
)
{
MOZ_CRASH
(
"
Allocation
or
other
failure
in
PrintfTarget
:
:
print
"
)
;
}
va_end
(
ap
)
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
AppendPrintf
(
const
char
*
aFormat
va_list
aAp
)
{
PrintfAppend
<
T
>
appender
(
this
)
;
bool
r
=
appender
.
vprint
(
aFormat
aAp
)
;
if
(
!
r
)
{
MOZ_CRASH
(
"
Allocation
or
other
failure
in
PrintfTarget
:
:
print
"
)
;
}
}
static
int
FormatWithoutTrailingZeros
(
char
(
&
aBuf
)
[
40
]
double
aDouble
int
aPrecision
)
{
static
const
DoubleToStringConverter
converter
(
DoubleToStringConverter
:
:
UNIQUE_ZERO
|
DoubleToStringConverter
:
:
EMIT_POSITIVE_EXPONENT_SIGN
"
Infinity
"
"
NaN
"
'
e
'
-
6
21
6
1
)
;
double_conversion
:
:
StringBuilder
builder
(
aBuf
sizeof
(
aBuf
)
)
;
bool
exponential_notation
=
false
;
converter
.
ToPrecision
(
aDouble
aPrecision
&
exponential_notation
&
builder
)
;
int
length
=
builder
.
position
(
)
;
char
*
formattedDouble
=
builder
.
Finalize
(
)
;
if
(
length
<
=
aPrecision
)
{
return
length
;
}
char
*
end
=
formattedDouble
+
length
;
char
*
decimalPoint
=
strchr
(
aBuf
'
.
'
)
;
if
(
!
decimalPoint
)
{
return
length
;
}
if
(
MOZ_UNLIKELY
(
exponential_notation
)
)
{
char
*
exponent
=
end
-
1
;
for
(
;
;
-
-
exponent
)
{
if
(
*
exponent
=
=
'
e
'
)
{
break
;
}
}
char
*
zerosBeforeExponent
=
exponent
-
1
;
for
(
;
zerosBeforeExponent
!
=
decimalPoint
;
-
-
zerosBeforeExponent
)
{
if
(
*
zerosBeforeExponent
!
=
'
0
'
)
{
break
;
}
}
if
(
zerosBeforeExponent
=
=
decimalPoint
)
{
-
-
zerosBeforeExponent
;
}
size_t
exponentSize
=
end
-
exponent
;
memmove
(
zerosBeforeExponent
+
1
exponent
exponentSize
)
;
length
-
=
exponent
-
(
zerosBeforeExponent
+
1
)
;
}
else
{
char
*
trailingZeros
=
end
-
1
;
for
(
;
trailingZeros
!
=
decimalPoint
;
-
-
trailingZeros
)
{
if
(
*
trailingZeros
!
=
'
0
'
)
{
break
;
}
}
if
(
trailingZeros
=
=
decimalPoint
)
{
-
-
trailingZeros
;
}
length
-
=
end
-
(
trailingZeros
+
1
)
;
}
return
length
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
AppendFloat
(
float
aFloat
)
{
char
buf
[
40
]
;
int
length
=
FormatWithoutTrailingZeros
(
buf
aFloat
6
)
;
AppendASCII
(
buf
length
)
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
AppendFloat
(
double
aFloat
)
{
char
buf
[
40
]
;
int
length
=
FormatWithoutTrailingZeros
(
buf
aFloat
15
)
;
AppendASCII
(
buf
length
)
;
}
template
<
typename
T
>
size_t
nsTSubstring
<
T
>
:
:
SizeOfExcludingThisIfUnshared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
if
(
this
-
>
mDataFlags
&
DataFlags
:
:
REFCOUNTED
)
{
return
nsStringBuffer
:
:
FromData
(
this
-
>
mData
)
-
>
SizeOfIncludingThisIfUnshared
(
aMallocSizeOf
)
;
}
if
(
this
-
>
mDataFlags
&
DataFlags
:
:
OWNED
)
{
return
aMallocSizeOf
(
this
-
>
mData
)
;
}
return
0
;
}
template
<
typename
T
>
size_t
nsTSubstring
<
T
>
:
:
SizeOfExcludingThisEvenIfShared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
if
(
this
-
>
mDataFlags
&
DataFlags
:
:
REFCOUNTED
)
{
return
nsStringBuffer
:
:
FromData
(
this
-
>
mData
)
-
>
SizeOfIncludingThisEvenIfShared
(
aMallocSizeOf
)
;
}
if
(
this
-
>
mDataFlags
&
DataFlags
:
:
OWNED
)
{
return
aMallocSizeOf
(
this
-
>
mData
)
;
}
return
0
;
}
template
<
typename
T
>
size_t
nsTSubstring
<
T
>
:
:
SizeOfIncludingThisIfUnshared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
template
<
typename
T
>
size_t
nsTSubstring
<
T
>
:
:
SizeOfIncludingThisEvenIfShared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThisEvenIfShared
(
aMallocSizeOf
)
;
}
template
<
typename
T
>
inline
nsTSubstringSplitter
<
T
>
:
:
nsTSubstringSplitter
(
const
nsTSubstring
<
T
>
*
aStr
char_type
aDelim
)
:
mStr
(
aStr
)
mArray
(
nullptr
)
mDelim
(
aDelim
)
{
if
(
mStr
-
>
IsEmpty
(
)
)
{
mArraySize
=
0
;
return
;
}
size_type
delimCount
=
mStr
-
>
CountChar
(
aDelim
)
;
mArraySize
=
delimCount
+
1
;
mArray
.
reset
(
new
nsTDependentSubstring
<
T
>
[
mArraySize
]
)
;
size_t
seenParts
=
0
;
size_type
start
=
0
;
do
{
MOZ_ASSERT
(
seenParts
<
mArraySize
)
;
int32_t
offset
=
mStr
-
>
FindChar
(
aDelim
start
)
;
if
(
offset
!
=
-
1
)
{
size_type
length
=
static_cast
<
size_type
>
(
offset
)
-
start
;
mArray
[
seenParts
+
+
]
.
Rebind
(
mStr
-
>
Data
(
)
+
start
length
)
;
start
=
static_cast
<
size_type
>
(
offset
)
+
1
;
}
else
{
mArray
[
seenParts
+
+
]
.
Rebind
(
mStr
-
>
Data
(
)
+
start
mStr
-
>
Length
(
)
-
start
)
;
break
;
}
}
while
(
start
<
mStr
-
>
Length
(
)
)
;
}
template
<
typename
T
>
nsTSubstringSplitter
<
T
>
nsTSubstring
<
T
>
:
:
Split
(
const
char_type
aChar
)
const
{
return
nsTSubstringSplitter
<
T
>
(
this
aChar
)
;
}
template
<
typename
T
>
const
nsTDependentSubstring
<
T
>
&
nsTSubstringSplitter
<
T
>
:
:
nsTSubstringSplit_Iter
:
:
operator
*
(
)
const
{
return
mObj
.
Get
(
mPos
)
;
}
template
<
typename
T
typename
int_type
>
int_type
ToIntegerCommon
(
const
nsTSubstring
<
T
>
&
aSrc
nsresult
*
aErrorCode
uint32_t
aRadix
)
{
MOZ_ASSERT
(
aRadix
=
=
10
|
|
aRadix
=
=
16
)
;
*
aErrorCode
=
NS_ERROR_ILLEGAL_VALUE
;
auto
cp
=
aSrc
.
BeginReading
(
)
;
auto
endcp
=
aSrc
.
EndReading
(
)
;
bool
negate
=
false
;
bool
done
=
false
;
while
(
(
cp
<
endcp
)
&
&
(
!
done
)
)
{
switch
(
*
cp
+
+
)
{
case
'
a
'
:
case
'
b
'
:
case
'
c
'
:
case
'
d
'
:
case
'
e
'
:
case
'
f
'
:
case
'
A
'
:
case
'
B
'
:
case
'
C
'
:
case
'
D
'
:
case
'
E
'
:
case
'
F
'
:
case
'
0
'
:
case
'
1
'
:
case
'
2
'
:
case
'
3
'
:
case
'
4
'
:
case
'
5
'
:
case
'
6
'
:
case
'
7
'
:
case
'
8
'
:
case
'
9
'
:
done
=
true
;
break
;
case
'
-
'
:
negate
=
true
;
break
;
default
:
break
;
}
}
if
(
!
done
)
{
return
0
;
}
cp
-
-
;
mozilla
:
:
CheckedInt
<
int_type
>
result
;
while
(
cp
<
endcp
)
{
auto
theChar
=
*
cp
+
+
;
if
(
(
'
0
'
<
=
theChar
)
&
&
(
theChar
<
=
'
9
'
)
)
{
result
=
(
aRadix
*
result
)
+
(
theChar
-
'
0
'
)
;
}
else
if
(
(
theChar
>
=
'
A
'
)
&
&
(
theChar
<
=
'
F
'
)
)
{
if
(
10
=
=
aRadix
)
{
return
0
;
}
else
{
result
=
(
aRadix
*
result
)
+
(
(
theChar
-
'
A
'
)
+
10
)
;
}
}
else
if
(
(
theChar
>
=
'
a
'
)
&
&
(
theChar
<
=
'
f
'
)
)
{
if
(
10
=
=
aRadix
)
{
return
0
;
}
else
{
result
=
(
aRadix
*
result
)
+
(
(
theChar
-
'
a
'
)
+
10
)
;
}
}
else
if
(
(
(
'
X
'
=
=
theChar
)
|
|
(
'
x
'
=
=
theChar
)
)
&
&
result
=
=
0
)
{
continue
;
}
else
{
break
;
}
if
(
!
result
.
isValid
(
)
)
{
return
0
;
}
}
*
aErrorCode
=
NS_OK
;
if
(
negate
)
{
result
=
-
result
;
}
return
result
.
value
(
)
;
}
template
<
typename
T
>
int32_t
nsTSubstring
<
T
>
:
:
ToInteger
(
nsresult
*
aErrorCode
uint32_t
aRadix
)
const
{
return
ToIntegerCommon
<
T
int32_t
>
(
*
this
aErrorCode
aRadix
)
;
}
template
<
typename
T
>
int64_t
nsTSubstring
<
T
>
:
:
ToInteger64
(
nsresult
*
aErrorCode
uint32_t
aRadix
)
const
{
return
ToIntegerCommon
<
T
int64_t
>
(
*
this
aErrorCode
aRadix
)
;
}
