#
include
"
nsStringBuffer
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
template
<
typename
CharT
>
static
already_AddRefed
<
nsStringBuffer
>
DoCreate
(
const
CharT
*
aData
size_t
aLength
)
{
RefPtr
<
nsStringBuffer
>
buffer
=
nsStringBuffer
:
:
Alloc
(
(
aLength
+
1
)
*
sizeof
(
CharT
)
)
;
if
(
MOZ_UNLIKELY
(
!
buffer
)
)
{
return
nullptr
;
}
auto
*
data
=
reinterpret_cast
<
CharT
*
>
(
buffer
-
>
Data
(
)
)
;
memcpy
(
data
aData
aLength
*
sizeof
(
CharT
)
)
;
data
[
aLength
]
=
0
;
return
buffer
.
forget
(
)
;
}
already_AddRefed
<
nsStringBuffer
>
nsStringBuffer
:
:
Create
(
const
char
*
aData
size_t
aLength
)
{
return
DoCreate
(
aData
aLength
)
;
}
already_AddRefed
<
nsStringBuffer
>
nsStringBuffer
:
:
Create
(
const
char16_t
*
aData
size_t
aLength
)
{
return
DoCreate
(
aData
aLength
)
;
}
nsStringBuffer
*
nsStringBuffer
:
:
Realloc
(
nsStringBuffer
*
aHdr
size_t
aSize
)
{
MOZ_ASSERT
(
aSize
!
=
0
"
zero
capacity
allocation
not
allowed
"
)
;
MOZ_ASSERT
(
sizeof
(
nsStringBuffer
)
+
aSize
<
=
size_t
(
uint32_t
(
-
1
)
)
&
&
sizeof
(
nsStringBuffer
)
+
aSize
>
aSize
"
mStorageSize
will
truncate
"
)
;
MOZ_ASSERT
(
!
aHdr
-
>
IsReadonly
(
)
"
|
Realloc
|
attempted
on
readonly
string
"
)
;
{
mozilla
:
:
detail
:
:
RefCountLogger
:
:
ReleaseLogger
logger
(
aHdr
)
;
logger
.
logRelease
(
0
)
;
}
aHdr
=
(
nsStringBuffer
*
)
realloc
(
aHdr
sizeof
(
nsStringBuffer
)
+
aSize
)
;
if
(
aHdr
)
{
mozilla
:
:
detail
:
:
RefCountLogger
:
:
logAddRef
(
aHdr
1
)
;
aHdr
-
>
mStorageSize
=
aSize
;
}
return
aHdr
;
}
size_t
nsStringBuffer
:
:
SizeOfIncludingThisIfUnshared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
IsReadonly
(
)
?
0
:
aMallocSizeOf
(
this
)
;
}
size_t
nsStringBuffer
:
:
SizeOfIncludingThisEvenIfShared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
;
}
