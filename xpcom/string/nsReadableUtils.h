#
ifndef
nsReadableUtils_h___
#
define
nsReadableUtils_h___
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
extern
"
C
"
{
size_t
encoding_utf8_valid_up_to
(
uint8_t
const
*
buffer
size_t
buffer_len
)
;
bool
encoding_mem_is_ascii
(
uint8_t
const
*
buffer
size_t
buffer_len
)
;
bool
encoding_mem_is_basic_latin
(
char16_t
const
*
buffer
size_t
buffer_len
)
;
bool
encoding_mem_is_utf8_latin1
(
uint8_t
const
*
buffer
size_t
buffer_len
)
;
bool
encoding_mem_is_str_latin1
(
uint8_t
const
*
buffer
size_t
buffer_len
)
;
bool
encoding_mem_is_utf16_latin1
(
char16_t
const
*
buffer
size_t
buffer_len
)
;
size_t
encoding_mem_utf16_valid_up_to
(
char16_t
const
*
buffer
size_t
buffer_len
)
;
void
encoding_mem_ensure_utf16_validity
(
char16_t
*
buffer
size_t
buffer_len
)
;
void
encoding_mem_convert_utf16_to_latin1_lossy
(
const
char16_t
*
src
size_t
src_len
char
*
dst
size_t
dst_len
)
;
size_t
encoding_mem_convert_utf8_to_latin1_lossy
(
const
char
*
src
size_t
src_len
char
*
dst
size_t
dst_len
)
;
void
encoding_mem_convert_latin1_to_utf16
(
const
char
*
src
size_t
src_len
char16_t
*
dst
size_t
dst_len
)
;
size_t
encoding_mem_convert_utf16_to_utf8
(
const
char16_t
*
src
size_t
src_len
char
*
dst
size_t
dst_len
)
;
size_t
encoding_mem_convert_utf8_to_utf16
(
const
char
*
src
size_t
src_len
char16_t
*
dst
size_t
dst_len
)
;
}
extern
"
C
"
{
bool
nsstring_fallible_append_utf8_impl
(
nsAString
*
aThis
const
char
*
aOther
size_t
aOtherLen
size_t
aOldLen
)
;
bool
nsstring_fallible_append_latin1_impl
(
nsAString
*
aThis
const
char
*
aOther
size_t
aOtherLen
size_t
aOldLen
bool
aAllowShrinking
)
;
bool
nscstring_fallible_append_utf16_to_utf8_impl
(
nsACString
*
aThis
const
char16_t
*
size_t
aOtherLen
size_t
aOldLen
)
;
bool
nscstring_fallible_append_utf16_to_latin1_lossy_impl
(
nsACString
*
aThis
const
char16_t
*
size_t
aOtherLen
size_t
aOldLen
bool
aAllowShrinking
)
;
bool
nscstring_fallible_append_utf8_to_latin1_lossy_check
(
nsACString
*
aThis
const
nsACString
*
aOther
size_t
aOldLen
)
;
bool
nscstring_fallible_append_latin1_to_utf8_check
(
nsACString
*
aThis
const
nsACString
*
aOther
size_t
aOldLen
)
;
}
inline
void
LossyConvertUTF16toLatin1
(
mozilla
:
:
Span
<
const
char16_t
>
aSource
mozilla
:
:
Span
<
char
>
aDest
)
{
encoding_mem_convert_utf16_to_latin1_lossy
(
aSource
.
Elements
(
)
aSource
.
Length
(
)
aDest
.
Elements
(
)
aDest
.
Length
(
)
)
;
}
inline
size_t
LossyConvertUTF8toLatin1
(
mozilla
:
:
Span
<
const
char
>
aSource
mozilla
:
:
Span
<
char
>
aDest
)
{
return
encoding_mem_convert_utf8_to_latin1_lossy
(
aSource
.
Elements
(
)
aSource
.
Length
(
)
aDest
.
Elements
(
)
aDest
.
Length
(
)
)
;
}
inline
void
ConvertLatin1toUTF16
(
mozilla
:
:
Span
<
const
char
>
aSource
mozilla
:
:
Span
<
char16_t
>
aDest
)
{
encoding_mem_convert_latin1_to_utf16
(
aSource
.
Elements
(
)
aSource
.
Length
(
)
aDest
.
Elements
(
)
aDest
.
Length
(
)
)
;
}
inline
size_t
ConvertUTF16toUTF8
(
mozilla
:
:
Span
<
const
char16_t
>
aSource
mozilla
:
:
Span
<
char
>
aDest
)
{
return
encoding_mem_convert_utf16_to_utf8
(
aSource
.
Elements
(
)
aSource
.
Length
(
)
aDest
.
Elements
(
)
aDest
.
Length
(
)
)
;
}
inline
size_t
ConvertUTF8toUTF16
(
mozilla
:
:
Span
<
const
char
>
aSource
mozilla
:
:
Span
<
char16_t
>
aDest
)
{
return
encoding_mem_convert_utf8_to_utf16
(
aSource
.
Elements
(
)
aSource
.
Length
(
)
aDest
.
Elements
(
)
aDest
.
Length
(
)
)
;
}
inline
size_t
Distance
(
const
nsReadingIterator
<
char16_t
>
&
aStart
const
nsReadingIterator
<
char16_t
>
&
aEnd
)
{
MOZ_ASSERT
(
aStart
.
get
(
)
<
=
aEnd
.
get
(
)
)
;
return
static_cast
<
size_t
>
(
aEnd
.
get
(
)
-
aStart
.
get
(
)
)
;
}
inline
size_t
Distance
(
const
nsReadingIterator
<
char
>
&
aStart
const
nsReadingIterator
<
char
>
&
aEnd
)
{
MOZ_ASSERT
(
aStart
.
get
(
)
<
=
aEnd
.
get
(
)
)
;
return
static_cast
<
size_t
>
(
aEnd
.
get
(
)
-
aStart
.
get
(
)
)
;
}
inline
MOZ_MUST_USE
bool
CopyUTF8toUTF16
(
mozilla
:
:
Span
<
const
char
>
aSource
nsAString
&
aDest
const
mozilla
:
:
fallible_t
&
)
{
return
nsstring_fallible_append_utf8_impl
(
&
aDest
aSource
.
Elements
(
)
aSource
.
Length
(
)
0
)
;
}
inline
void
CopyUTF8toUTF16
(
mozilla
:
:
Span
<
const
char
>
aSource
nsAString
&
aDest
)
{
if
(
MOZ_UNLIKELY
(
!
CopyUTF8toUTF16
(
aSource
aDest
mozilla
:
:
fallible
)
)
)
{
aDest
.
AllocFailed
(
aSource
.
Length
(
)
)
;
}
}
inline
MOZ_MUST_USE
bool
AppendUTF8toUTF16
(
mozilla
:
:
Span
<
const
char
>
aSource
nsAString
&
aDest
const
mozilla
:
:
fallible_t
&
)
{
return
nsstring_fallible_append_utf8_impl
(
&
aDest
aSource
.
Elements
(
)
aSource
.
Length
(
)
aDest
.
Length
(
)
)
;
}
inline
void
AppendUTF8toUTF16
(
mozilla
:
:
Span
<
const
char
>
aSource
nsAString
&
aDest
)
{
if
(
MOZ_UNLIKELY
(
!
AppendUTF8toUTF16
(
aSource
aDest
mozilla
:
:
fallible
)
)
)
{
aDest
.
AllocFailed
(
aDest
.
Length
(
)
+
aSource
.
Length
(
)
)
;
}
}
inline
MOZ_MUST_USE
bool
CopyASCIItoUTF16
(
mozilla
:
:
Span
<
const
char
>
aSource
nsAString
&
aDest
const
mozilla
:
:
fallible_t
&
)
{
return
nsstring_fallible_append_latin1_impl
(
&
aDest
aSource
.
Elements
(
)
aSource
.
Length
(
)
0
true
)
;
}
inline
void
CopyASCIItoUTF16
(
mozilla
:
:
Span
<
const
char
>
aSource
nsAString
&
aDest
)
{
if
(
MOZ_UNLIKELY
(
!
CopyASCIItoUTF16
(
aSource
aDest
mozilla
:
:
fallible
)
)
)
{
aDest
.
AllocFailed
(
aSource
.
Length
(
)
)
;
}
}
inline
MOZ_MUST_USE
bool
AppendASCIItoUTF16
(
mozilla
:
:
Span
<
const
char
>
aSource
nsAString
&
aDest
const
mozilla
:
:
fallible_t
&
)
{
return
nsstring_fallible_append_latin1_impl
(
&
aDest
aSource
.
Elements
(
)
aSource
.
Length
(
)
aDest
.
Length
(
)
false
)
;
}
inline
void
AppendASCIItoUTF16
(
mozilla
:
:
Span
<
const
char
>
aSource
nsAString
&
aDest
)
{
if
(
MOZ_UNLIKELY
(
!
AppendASCIItoUTF16
(
aSource
aDest
mozilla
:
:
fallible
)
)
)
{
aDest
.
AllocFailed
(
aDest
.
Length
(
)
+
aSource
.
Length
(
)
)
;
}
}
inline
MOZ_MUST_USE
bool
CopyUTF16toUTF8
(
mozilla
:
:
Span
<
const
char16_t
>
aSource
nsACString
&
aDest
const
mozilla
:
:
fallible_t
&
)
{
return
nscstring_fallible_append_utf16_to_utf8_impl
(
&
aDest
aSource
.
Elements
(
)
aSource
.
Length
(
)
0
)
;
}
inline
void
CopyUTF16toUTF8
(
mozilla
:
:
Span
<
const
char16_t
>
aSource
nsACString
&
aDest
)
{
if
(
MOZ_UNLIKELY
(
!
CopyUTF16toUTF8
(
aSource
aDest
mozilla
:
:
fallible
)
)
)
{
aDest
.
AllocFailed
(
aSource
.
Length
(
)
)
;
}
}
inline
MOZ_MUST_USE
bool
AppendUTF16toUTF8
(
mozilla
:
:
Span
<
const
char16_t
>
aSource
nsACString
&
aDest
const
mozilla
:
:
fallible_t
&
)
{
return
nscstring_fallible_append_utf16_to_utf8_impl
(
&
aDest
aSource
.
Elements
(
)
aSource
.
Length
(
)
aDest
.
Length
(
)
)
;
}
inline
void
AppendUTF16toUTF8
(
mozilla
:
:
Span
<
const
char16_t
>
aSource
nsACString
&
aDest
)
{
if
(
MOZ_UNLIKELY
(
!
AppendUTF16toUTF8
(
aSource
aDest
mozilla
:
:
fallible
)
)
)
{
aDest
.
AllocFailed
(
aDest
.
Length
(
)
+
aSource
.
Length
(
)
)
;
}
}
inline
MOZ_MUST_USE
bool
LossyCopyUTF16toASCII
(
mozilla
:
:
Span
<
const
char16_t
>
aSource
nsACString
&
aDest
const
mozilla
:
:
fallible_t
&
)
{
return
nscstring_fallible_append_utf16_to_latin1_lossy_impl
(
&
aDest
aSource
.
Elements
(
)
aSource
.
Length
(
)
0
true
)
;
}
inline
void
LossyCopyUTF16toASCII
(
mozilla
:
:
Span
<
const
char16_t
>
aSource
nsACString
&
aDest
)
{
if
(
MOZ_UNLIKELY
(
!
LossyCopyUTF16toASCII
(
aSource
aDest
mozilla
:
:
fallible
)
)
)
{
aDest
.
AllocFailed
(
aSource
.
Length
(
)
)
;
}
}
inline
MOZ_MUST_USE
bool
LossyAppendUTF16toASCII
(
mozilla
:
:
Span
<
const
char16_t
>
aSource
nsACString
&
aDest
const
mozilla
:
:
fallible_t
&
)
{
return
nscstring_fallible_append_utf16_to_latin1_lossy_impl
(
&
aDest
aSource
.
Elements
(
)
aSource
.
Length
(
)
aDest
.
Length
(
)
false
)
;
}
inline
void
LossyAppendUTF16toASCII
(
mozilla
:
:
Span
<
const
char16_t
>
aSource
nsACString
&
aDest
)
{
if
(
MOZ_UNLIKELY
(
!
LossyAppendUTF16toASCII
(
aSource
aDest
mozilla
:
:
fallible
)
)
)
{
aDest
.
AllocFailed
(
aDest
.
Length
(
)
+
aSource
.
Length
(
)
)
;
}
}
char
*
ToNewCString
(
const
nsAString
&
aSource
)
;
char
*
ToNewCString
(
const
nsACString
&
aSource
)
;
char
*
ToNewUTF8String
(
const
nsAString
&
aSource
uint32_t
*
aUTF8Count
=
nullptr
)
;
char16_t
*
ToNewUnicode
(
const
nsAString
&
aSource
)
;
char16_t
*
ToNewUnicode
(
const
nsACString
&
aSource
)
;
char16_t
*
UTF8ToNewUnicode
(
const
nsACString
&
aSource
uint32_t
*
aUTF16Count
=
nullptr
)
;
char16_t
*
CopyUnicodeTo
(
const
nsAString
&
aSource
uint32_t
aSrcOffset
char16_t
*
aDest
uint32_t
aLength
)
;
inline
bool
IsASCII
(
mozilla
:
:
Span
<
const
char16_t
>
aString
)
{
size_t
length
=
aString
.
Length
(
)
;
const
char16_t
*
ptr
=
aString
.
Elements
(
)
;
if
(
length
<
16
)
{
char16_t
accu
=
0
;
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
accu
|
=
ptr
[
i
]
;
}
return
accu
<
0x80U
;
}
return
encoding_mem_is_basic_latin
(
ptr
length
)
;
}
inline
bool
IsASCII
(
mozilla
:
:
Span
<
const
char
>
aString
)
{
size_t
length
=
aString
.
Length
(
)
;
const
uint8_t
*
ptr
=
reinterpret_cast
<
const
uint8_t
*
>
(
aString
.
Elements
(
)
)
;
if
(
length
<
16
)
{
uint8_t
accu
=
0
;
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
accu
|
=
ptr
[
i
]
;
}
return
accu
<
0x80U
;
}
return
encoding_mem_is_ascii
(
ptr
length
)
;
}
inline
bool
IsUTF16Latin1
(
mozilla
:
:
Span
<
const
char16_t
>
aString
)
{
size_t
length
=
aString
.
Length
(
)
;
const
char16_t
*
ptr
=
aString
.
Elements
(
)
;
if
(
length
<
16
)
{
char16_t
accu
=
0
;
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
accu
|
=
ptr
[
i
]
;
}
return
accu
<
0x100U
;
}
return
encoding_mem_is_utf16_latin1
(
ptr
length
)
;
}
inline
bool
IsUTF8Latin1
(
mozilla
:
:
Span
<
const
char
>
aString
)
{
size_t
length
=
aString
.
Length
(
)
;
const
uint8_t
*
ptr
=
reinterpret_cast
<
const
uint8_t
*
>
(
aString
.
Elements
(
)
)
;
if
(
length
<
16
)
{
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
ptr
[
i
]
>
=
0x80U
)
{
ptr
+
=
i
;
length
-
=
i
;
goto
end
;
}
}
return
true
;
}
end
:
return
encoding_mem_is_utf8_latin1
(
ptr
length
)
;
}
inline
bool
UnsafeIsValidUTF8Latin1
(
mozilla
:
:
Span
<
const
char
>
aString
)
{
size_t
length
=
aString
.
Length
(
)
;
const
uint8_t
*
ptr
=
reinterpret_cast
<
const
uint8_t
*
>
(
aString
.
Elements
(
)
)
;
if
(
length
<
16
)
{
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
ptr
[
i
]
>
=
0x80U
)
{
ptr
+
=
i
;
length
-
=
i
;
goto
end
;
}
}
return
true
;
}
end
:
return
encoding_mem_is_str_latin1
(
ptr
length
)
;
}
inline
bool
IsUTF8
(
mozilla
:
:
Span
<
const
char
>
aString
)
{
size_t
length
=
aString
.
Length
(
)
;
const
uint8_t
*
ptr
=
reinterpret_cast
<
const
uint8_t
*
>
(
aString
.
Elements
(
)
)
;
if
(
length
<
16
)
{
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
ptr
[
i
]
>
=
0x80U
)
{
ptr
+
=
i
;
length
-
=
i
;
goto
end
;
}
}
return
true
;
}
end
:
return
length
=
=
encoding_utf8_valid_up_to
(
ptr
length
)
;
}
inline
uint32_t
UTF16ValidUpTo
(
mozilla
:
:
Span
<
const
char16_t
>
aString
)
{
return
encoding_mem_utf16_valid_up_to
(
aString
.
Elements
(
)
aString
.
Length
(
)
)
;
}
inline
void
EnsureUTF16ValiditySpan
(
mozilla
:
:
Span
<
char16_t
>
aString
)
{
encoding_mem_ensure_utf16_validity
(
aString
.
Elements
(
)
aString
.
Length
(
)
)
;
}
inline
void
EnsureUTF16Validity
(
nsAString
&
aString
)
{
uint32_t
upTo
=
UTF16ValidUpTo
(
aString
)
;
uint32_t
len
=
aString
.
Length
(
)
;
if
(
upTo
=
=
len
)
{
return
;
}
char16_t
*
ptr
=
aString
.
BeginWriting
(
)
;
auto
span
=
mozilla
:
:
MakeSpan
(
ptr
len
)
;
span
[
upTo
]
=
0xFFFD
;
EnsureUTF16ValiditySpan
(
span
.
From
(
upTo
+
1
)
)
;
}
bool
ParseString
(
const
nsACString
&
aAstring
char
aDelimiter
nsTArray
<
nsCString
>
&
aArray
)
;
void
ToUpperCase
(
nsACString
&
)
;
void
ToLowerCase
(
nsACString
&
)
;
void
ToUpperCase
(
nsACString
&
)
;
void
ToLowerCase
(
nsACString
&
)
;
void
ToUpperCase
(
const
nsACString
&
aSource
nsACString
&
aDest
)
;
void
ToLowerCase
(
const
nsACString
&
aSource
nsACString
&
aDest
)
;
bool
FindInReadable
(
const
nsAString
&
aPattern
nsAString
:
:
const_iterator
&
nsAString
:
:
const_iterator
&
const
nsStringComparator
&
=
nsDefaultStringComparator
(
)
)
;
bool
FindInReadable
(
const
nsACString
&
aPattern
nsACString
:
:
const_iterator
&
nsACString
:
:
const_iterator
&
const
nsCStringComparator
&
=
nsDefaultCStringComparator
(
)
)
;
inline
bool
FindInReadable
(
const
nsAString
&
aPattern
const
nsAString
&
aSource
const
nsStringComparator
&
aCompare
=
nsDefaultStringComparator
(
)
)
{
nsAString
:
:
const_iterator
start
end
;
aSource
.
BeginReading
(
start
)
;
aSource
.
EndReading
(
end
)
;
return
FindInReadable
(
aPattern
start
end
aCompare
)
;
}
inline
bool
FindInReadable
(
const
nsACString
&
aPattern
const
nsACString
&
aSource
const
nsCStringComparator
&
aCompare
=
nsDefaultCStringComparator
(
)
)
{
nsACString
:
:
const_iterator
start
end
;
aSource
.
BeginReading
(
start
)
;
aSource
.
EndReading
(
end
)
;
return
FindInReadable
(
aPattern
start
end
aCompare
)
;
}
bool
CaseInsensitiveFindInReadable
(
const
nsACString
&
aPattern
nsACString
:
:
const_iterator
&
nsACString
:
:
const_iterator
&
)
;
bool
RFindInReadable
(
const
nsAString
&
aPattern
nsAString
:
:
const_iterator
&
nsAString
:
:
const_iterator
&
const
nsStringComparator
&
=
nsDefaultStringComparator
(
)
)
;
bool
RFindInReadable
(
const
nsACString
&
aPattern
nsACString
:
:
const_iterator
&
nsACString
:
:
const_iterator
&
const
nsCStringComparator
&
=
nsDefaultCStringComparator
(
)
)
;
bool
FindCharInReadable
(
char16_t
aChar
nsAString
:
:
const_iterator
&
aSearchStart
const
nsAString
:
:
const_iterator
&
aSearchEnd
)
;
bool
FindCharInReadable
(
char
aChar
nsACString
:
:
const_iterator
&
aSearchStart
const
nsACString
:
:
const_iterator
&
aSearchEnd
)
;
uint32_t
CountCharInReadable
(
const
nsAString
&
aStr
char16_t
aChar
)
;
uint32_t
CountCharInReadable
(
const
nsACString
&
aStr
char
aChar
)
;
bool
StringBeginsWith
(
const
nsAString
&
aSource
const
nsAString
&
aSubstring
)
;
bool
StringBeginsWith
(
const
nsAString
&
aSource
const
nsAString
&
aSubstring
const
nsStringComparator
&
aComparator
)
;
bool
StringBeginsWith
(
const
nsACString
&
aSource
const
nsACString
&
aSubstring
)
;
bool
StringBeginsWith
(
const
nsACString
&
aSource
const
nsACString
&
aSubstring
const
nsCStringComparator
&
aComparator
)
;
bool
StringEndsWith
(
const
nsAString
&
aSource
const
nsAString
&
aSubstring
)
;
bool
StringEndsWith
(
const
nsAString
&
aSource
const
nsAString
&
aSubstring
const
nsStringComparator
&
aComparator
)
;
bool
StringEndsWith
(
const
nsACString
&
aSource
const
nsACString
&
aSubstring
)
;
bool
StringEndsWith
(
const
nsACString
&
aSource
const
nsACString
&
aSubstring
const
nsCStringComparator
&
aComparator
)
;
const
nsString
&
EmptyString
(
)
;
const
nsCString
&
EmptyCString
(
)
;
const
nsString
&
VoidString
(
)
;
const
nsCString
&
VoidCString
(
)
;
int32_t
CompareUTF8toUTF16
(
const
nsACString
&
aUTF8String
const
nsAString
&
aUTF16String
bool
*
aErr
=
nullptr
)
;
void
AppendUCS4ToUTF16
(
const
uint32_t
aSource
nsAString
&
aDest
)
;
template
<
class
T
>
inline
bool
EnsureStringLength
(
T
&
aStr
uint32_t
aLen
)
{
aStr
.
SetLength
(
aLen
)
;
return
(
aStr
.
Length
(
)
=
=
aLen
)
;
}
#
endif
