#
include
"
mozilla
/
Casting
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsDependentString
.
h
"
#
include
"
nsDependentSubstring
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
"
prdtoa
.
h
"
inline
char
ascii_tolower
(
char
aChar
)
{
if
(
aChar
>
=
'
A
'
&
&
aChar
<
=
'
Z
'
)
return
aChar
+
(
'
a
'
-
'
A
'
)
;
return
aChar
;
}
static
int32_t
FindChar1
(
const
char
*
aDest
uint32_t
aDestLength
int32_t
anOffset
const
char16_t
aChar
int32_t
aCount
)
{
if
(
anOffset
<
0
)
anOffset
=
0
;
if
(
aCount
<
0
)
aCount
=
(
int32_t
)
aDestLength
;
if
(
(
aChar
<
256
)
&
&
(
0
<
aDestLength
)
&
&
(
(
uint32_t
)
anOffset
<
aDestLength
)
)
{
if
(
0
<
aCount
)
{
const
char
*
left
=
aDest
+
anOffset
;
const
char
*
last
=
left
+
aCount
;
const
char
*
max
=
aDest
+
aDestLength
;
const
char
*
end
=
(
last
<
max
)
?
last
:
max
;
int32_t
theMax
=
end
-
left
;
if
(
0
<
theMax
)
{
unsigned
char
theChar
=
(
unsigned
char
)
aChar
;
const
char
*
result
=
(
const
char
*
)
memchr
(
left
(
int
)
theChar
theMax
)
;
if
(
result
)
return
result
-
aDest
;
}
}
}
return
kNotFound
;
}
static
int32_t
FindChar2
(
const
char16_t
*
aDest
uint32_t
aDestLength
int32_t
anOffset
const
char16_t
aChar
int32_t
aCount
)
{
if
(
anOffset
<
0
)
anOffset
=
0
;
if
(
aCount
<
0
)
aCount
=
(
int32_t
)
aDestLength
;
if
(
(
0
<
aDestLength
)
&
&
(
(
uint32_t
)
anOffset
<
aDestLength
)
)
{
if
(
0
<
aCount
)
{
const
char16_t
*
root
=
aDest
;
const
char16_t
*
left
=
root
+
anOffset
;
const
char16_t
*
last
=
left
+
aCount
;
const
char16_t
*
max
=
root
+
aDestLength
;
const
char16_t
*
end
=
(
last
<
max
)
?
last
:
max
;
while
(
left
<
end
)
{
if
(
*
left
=
=
aChar
)
return
(
left
-
root
)
;
+
+
left
;
}
}
}
return
kNotFound
;
}
static
int32_t
RFindChar1
(
const
char
*
aDest
uint32_t
aDestLength
int32_t
anOffset
const
char16_t
aChar
int32_t
aCount
)
{
if
(
anOffset
<
0
)
anOffset
=
(
int32_t
)
aDestLength
-
1
;
if
(
aCount
<
0
)
aCount
=
int32_t
(
aDestLength
)
;
if
(
(
aChar
<
256
)
&
&
(
0
<
aDestLength
)
&
&
(
(
uint32_t
)
anOffset
<
aDestLength
)
)
{
if
(
0
<
aCount
)
{
const
char
*
rightmost
=
aDest
+
anOffset
;
const
char
*
min
=
rightmost
-
aCount
+
1
;
const
char
*
leftmost
=
(
min
<
aDest
)
?
aDest
:
min
;
char
theChar
=
(
char
)
aChar
;
while
(
leftmost
<
=
rightmost
)
{
if
(
(
*
rightmost
)
=
=
theChar
)
return
rightmost
-
aDest
;
-
-
rightmost
;
}
}
}
return
kNotFound
;
}
static
int32_t
RFindChar2
(
const
char16_t
*
aDest
uint32_t
aDestLength
int32_t
anOffset
const
char16_t
aChar
int32_t
aCount
)
{
if
(
anOffset
<
0
)
anOffset
=
(
int32_t
)
aDestLength
-
1
;
if
(
aCount
<
0
)
aCount
=
int32_t
(
aDestLength
)
;
if
(
(
0
<
aDestLength
)
&
&
(
(
uint32_t
)
anOffset
<
aDestLength
)
)
{
if
(
0
<
aCount
)
{
const
char16_t
*
root
=
aDest
;
const
char16_t
*
rightmost
=
root
+
anOffset
;
const
char16_t
*
min
=
rightmost
-
aCount
+
1
;
const
char16_t
*
leftmost
=
(
min
<
root
)
?
root
:
min
;
while
(
leftmost
<
=
rightmost
)
{
if
(
(
*
rightmost
)
=
=
aChar
)
return
rightmost
-
root
;
-
-
rightmost
;
}
}
}
return
kNotFound
;
}
static
#
ifdef
__SUNPRO_CC
inline
#
endif
int32_t
Compare1To1
(
const
char
*
aStr1
const
char
*
aStr2
uint32_t
aCount
bool
aIgnoreCase
)
{
int32_t
result
=
0
;
if
(
aIgnoreCase
)
#
if
defined
(
LIBFUZZER
)
&
&
defined
(
LINUX
)
result
=
int32_t
(
strncasecmp
(
aStr1
aStr2
aCount
)
)
;
#
else
result
=
int32_t
(
PL_strncasecmp
(
aStr1
aStr2
aCount
)
)
;
#
endif
else
result
=
nsCharTraits
<
char
>
:
:
compare
(
aStr1
aStr2
aCount
)
;
if
(
result
<
-
1
)
result
=
-
1
;
else
if
(
result
>
1
)
result
=
1
;
return
result
;
}
static
#
ifdef
__SUNPRO_CC
inline
#
endif
int32_t
Compare2To2
(
const
char16_t
*
aStr1
const
char16_t
*
aStr2
uint32_t
aCount
)
{
int32_t
result
;
if
(
aStr1
&
&
aStr2
)
result
=
nsCharTraits
<
char16_t
>
:
:
compare
(
aStr1
aStr2
aCount
)
;
else
if
(
!
aStr1
&
&
!
aStr2
)
result
=
0
;
else
if
(
aStr1
)
result
=
1
;
else
result
=
-
1
;
if
(
result
<
-
1
)
result
=
-
1
;
else
if
(
result
>
1
)
result
=
1
;
return
result
;
}
static
#
ifdef
__SUNPRO_CC
inline
#
endif
int32_t
Compare2To1
(
const
char16_t
*
aStr1
const
char
*
aStr2
uint32_t
aCount
bool
aIgnoreCase
)
{
const
char16_t
*
s1
=
aStr1
;
const
char
*
s2
=
aStr2
;
if
(
aStr1
&
&
aStr2
)
{
if
(
aCount
!
=
0
)
{
do
{
char16_t
c1
=
*
s1
+
+
;
char16_t
c2
=
char16_t
(
(
unsigned
char
)
*
s2
+
+
)
;
if
(
c1
!
=
c2
)
{
#
ifdef
DEBUG
if
(
aIgnoreCase
&
&
c2
>
=
128
)
NS_WARNING
(
"
got
a
non
-
ASCII
string
but
we
can
'
t
do
an
accurate
case
"
"
conversion
!
"
)
;
#
endif
if
(
aIgnoreCase
&
&
c1
<
128
&
&
c2
<
128
)
{
c1
=
ascii_tolower
(
char
(
c1
)
)
;
c2
=
ascii_tolower
(
char
(
c2
)
)
;
if
(
c1
=
=
c2
)
continue
;
}
if
(
c1
<
c2
)
return
-
1
;
return
1
;
}
}
while
(
-
-
aCount
)
;
}
}
return
0
;
}
inline
int32_t
Compare1To2
(
const
char
*
aStr1
const
char16_t
*
aStr2
uint32_t
aCount
bool
aIgnoreCase
)
{
return
Compare2To1
(
aStr2
aStr1
aCount
aIgnoreCase
)
*
-
1
;
}
static
int32_t
CompressChars1
(
char
*
aString
uint32_t
aLength
const
char
*
aSet
)
{
char
*
from
=
aString
;
char
*
end
=
aString
+
aLength
;
char
*
to
=
from
;
if
(
aSet
&
&
aString
&
&
(
0
<
aLength
)
)
{
uint32_t
aSetLen
=
strlen
(
aSet
)
;
while
(
from
<
end
)
{
char
theChar
=
*
from
+
+
;
*
to
+
+
=
theChar
;
if
(
(
kNotFound
!
=
FindChar1
(
aSet
aSetLen
0
theChar
aSetLen
)
)
)
{
while
(
from
<
end
)
{
theChar
=
*
from
+
+
;
if
(
kNotFound
=
=
FindChar1
(
aSet
aSetLen
0
theChar
aSetLen
)
)
{
*
to
+
+
=
theChar
;
break
;
}
}
}
}
*
to
=
0
;
}
return
to
-
aString
;
}
static
int32_t
CompressChars2
(
char16_t
*
aString
uint32_t
aLength
const
char
*
aSet
)
{
char16_t
*
from
=
aString
;
char16_t
*
end
=
from
+
aLength
;
char16_t
*
to
=
from
;
if
(
aSet
&
&
aString
&
&
(
0
<
aLength
)
)
{
uint32_t
aSetLen
=
strlen
(
aSet
)
;
while
(
from
<
end
)
{
char16_t
theChar
=
*
from
+
+
;
*
to
+
+
=
theChar
;
if
(
(
theChar
<
256
)
&
&
(
kNotFound
!
=
FindChar1
(
aSet
aSetLen
0
theChar
aSetLen
)
)
)
{
while
(
from
<
end
)
{
theChar
=
*
from
+
+
;
if
(
kNotFound
=
=
FindChar1
(
aSet
aSetLen
0
theChar
aSetLen
)
)
{
*
to
+
+
=
theChar
;
break
;
}
}
}
}
*
to
=
0
;
}
return
to
-
(
char16_t
*
)
aString
;
}
static
int32_t
StripChars1
(
char
*
aString
uint32_t
aLength
const
char
*
aSet
)
{
char
*
to
=
aString
;
char
*
from
=
aString
-
1
;
char
*
end
=
aString
+
aLength
;
if
(
aSet
&
&
aString
&
&
(
0
<
aLength
)
)
{
uint32_t
aSetLen
=
strlen
(
aSet
)
;
while
(
+
+
from
<
end
)
{
char
theChar
=
*
from
;
if
(
kNotFound
=
=
FindChar1
(
aSet
aSetLen
0
theChar
aSetLen
)
)
{
*
to
+
+
=
theChar
;
}
}
*
to
=
0
;
}
return
to
-
(
char
*
)
aString
;
}
static
int32_t
StripChars2
(
char16_t
*
aString
uint32_t
aLength
const
char
*
aSet
)
{
char16_t
*
to
=
aString
;
char16_t
*
from
=
aString
-
1
;
char16_t
*
end
=
to
+
aLength
;
if
(
aSet
&
&
aString
&
&
(
0
<
aLength
)
)
{
uint32_t
aSetLen
=
strlen
(
aSet
)
;
while
(
+
+
from
<
end
)
{
char16_t
theChar
=
*
from
;
if
(
(
255
<
theChar
)
|
|
(
kNotFound
=
=
FindChar1
(
aSet
aSetLen
0
theChar
aSetLen
)
)
)
{
*
to
+
+
=
theChar
;
}
}
*
to
=
0
;
}
return
to
-
(
char16_t
*
)
aString
;
}
template
<
class
CharT
>
#
ifndef
__SUNPRO_CC
static
#
endif
CharT
GetFindInSetFilter
(
const
CharT
*
set
)
{
CharT
filter
=
~
CharT
(
0
)
;
while
(
*
set
)
{
filter
&
=
~
(
*
set
)
;
+
+
set
;
}
return
filter
;
}
template
<
class
CharT
>
struct
nsBufferRoutines
{
}
;
template
<
>
struct
nsBufferRoutines
<
char
>
{
static
int32_t
compare
(
const
char
*
a
const
char
*
b
uint32_t
max
bool
ic
)
{
return
Compare1To1
(
a
b
max
ic
)
;
}
static
int32_t
compare
(
const
char
*
a
const
char16_t
*
b
uint32_t
max
bool
ic
)
{
return
Compare1To2
(
a
b
max
ic
)
;
}
static
int32_t
find_char
(
const
char
*
s
uint32_t
max
int32_t
offset
const
char16_t
c
int32_t
count
)
{
return
FindChar1
(
s
max
offset
c
count
)
;
}
static
int32_t
rfind_char
(
const
char
*
s
uint32_t
max
int32_t
offset
const
char16_t
c
int32_t
count
)
{
return
RFindChar1
(
s
max
offset
c
count
)
;
}
static
char
get_find_in_set_filter
(
const
char
*
set
)
{
return
GetFindInSetFilter
(
set
)
;
}
static
int32_t
strip_chars
(
char
*
s
uint32_t
len
const
char
*
set
)
{
return
StripChars1
(
s
len
set
)
;
}
static
int32_t
compress_chars
(
char
*
s
uint32_t
len
const
char
*
set
)
{
return
CompressChars1
(
s
len
set
)
;
}
}
;
template
<
>
struct
nsBufferRoutines
<
char16_t
>
{
static
int32_t
compare
(
const
char16_t
*
a
const
char16_t
*
b
uint32_t
max
bool
ic
)
{
NS_ASSERTION
(
!
ic
"
no
case
-
insensitive
compare
here
"
)
;
return
Compare2To2
(
a
b
max
)
;
}
static
int32_t
compare
(
const
char16_t
*
a
const
char
*
b
uint32_t
max
bool
ic
)
{
return
Compare2To1
(
a
b
max
ic
)
;
}
static
int32_t
find_char
(
const
char16_t
*
s
uint32_t
max
int32_t
offset
const
char16_t
c
int32_t
count
)
{
return
FindChar2
(
s
max
offset
c
count
)
;
}
static
int32_t
rfind_char
(
const
char16_t
*
s
uint32_t
max
int32_t
offset
const
char16_t
c
int32_t
count
)
{
return
RFindChar2
(
s
max
offset
c
count
)
;
}
static
char16_t
get_find_in_set_filter
(
const
char16_t
*
set
)
{
return
GetFindInSetFilter
(
set
)
;
}
static
char16_t
get_find_in_set_filter
(
const
char
*
set
)
{
return
(
~
char16_t
(
0
)
^
~
char
(
0
)
)
|
GetFindInSetFilter
(
set
)
;
}
static
int32_t
strip_chars
(
char16_t
*
s
uint32_t
max
const
char
*
set
)
{
return
StripChars2
(
s
max
set
)
;
}
static
int32_t
compress_chars
(
char16_t
*
s
uint32_t
len
const
char
*
set
)
{
return
CompressChars2
(
s
len
set
)
;
}
}
;
template
<
class
L
class
R
>
#
ifndef
__SUNPRO_CC
static
#
endif
int32_t
FindSubstring
(
const
L
*
big
uint32_t
bigLen
const
R
*
little
uint32_t
littleLen
bool
ignoreCase
)
{
if
(
littleLen
>
bigLen
)
return
kNotFound
;
int32_t
i
max
=
int32_t
(
bigLen
-
littleLen
)
;
for
(
i
=
0
;
i
<
=
max
;
+
+
i
+
+
big
)
{
if
(
nsBufferRoutines
<
L
>
:
:
compare
(
big
little
littleLen
ignoreCase
)
=
=
0
)
return
i
;
}
return
kNotFound
;
}
template
<
class
CharT
class
SetCharT
>
#
ifndef
__SUNPRO_CC
static
#
endif
int32_t
FindCharInSet
(
const
CharT
*
data
uint32_t
dataLen
const
SetCharT
*
set
)
{
CharT
filter
=
nsBufferRoutines
<
CharT
>
:
:
get_find_in_set_filter
(
set
)
;
const
CharT
*
end
=
data
+
dataLen
;
for
(
const
CharT
*
iter
=
data
;
iter
<
end
;
+
+
iter
)
{
CharT
currentChar
=
*
iter
;
if
(
currentChar
&
filter
)
continue
;
const
SetCharT
*
charInSet
=
set
;
CharT
setChar
=
CharT
(
*
charInSet
)
;
while
(
setChar
)
{
if
(
setChar
=
=
currentChar
)
return
iter
-
data
;
setChar
=
CharT
(
*
(
+
+
charInSet
)
)
;
}
}
return
kNotFound
;
}
#
include
"
nsTStringObsolete
.
cpp
"
template
<
typename
T
>
template
<
typename
Q
typename
EnableIfChar16
>
void
nsTSubstring
<
T
>
:
:
ReplaceChar
(
const
char
*
aSet
char16_t
aNewChar
)
{
if
(
!
this
-
>
EnsureMutable
(
)
)
this
-
>
AllocFailed
(
this
-
>
mLength
)
;
char16_t
*
data
=
this
-
>
mData
;
uint32_t
lenRemaining
=
this
-
>
mLength
;
while
(
lenRemaining
)
{
int32_t
i
=
:
:
FindCharInSet
(
data
lenRemaining
aSet
)
;
if
(
i
=
=
kNotFound
)
break
;
data
[
i
+
+
]
=
aNewChar
;
data
+
=
i
;
lenRemaining
-
=
i
;
}
}
