#
include
"
nsTArray
.
h
"
#
include
"
nsASCIIMask
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
namespace
mozilla
:
:
detail
{
template
<
typename
T
>
int32_t
nsTStringRepr
<
T
>
:
:
Find
(
const
nsTStringRepr
<
char
>
&
aString
bool
aIgnoreCase
int32_t
aOffset
int32_t
aCount
)
const
{
Find_ComputeSearchRange
(
this
-
>
mLength
aString
.
Length
(
)
aOffset
aCount
)
;
int32_t
result
=
FindSubstring
(
this
-
>
mData
+
aOffset
aCount
aString
.
BeginReading
(
)
aString
.
Length
(
)
aIgnoreCase
)
;
if
(
result
!
=
kNotFound
)
result
+
=
aOffset
;
return
result
;
}
template
<
typename
T
>
int32_t
nsTStringRepr
<
T
>
:
:
Find
(
const
char
*
aString
bool
aIgnoreCase
int32_t
aOffset
int32_t
aCount
)
const
{
return
Find
(
nsTDependentString
<
char
>
(
aString
)
aIgnoreCase
aOffset
aCount
)
;
}
template
<
typename
T
>
int32_t
nsTStringRepr
<
T
>
:
:
RFind
(
const
nsTStringRepr
<
char
>
&
aString
bool
aIgnoreCase
int32_t
aOffset
int32_t
aCount
)
const
{
RFind_ComputeSearchRange
(
this
-
>
mLength
aString
.
Length
(
)
aOffset
aCount
)
;
int32_t
result
=
RFindSubstring
(
this
-
>
mData
+
aOffset
aCount
aString
.
BeginReading
(
)
aString
.
Length
(
)
aIgnoreCase
)
;
if
(
result
!
=
kNotFound
)
result
+
=
aOffset
;
return
result
;
}
template
<
typename
T
>
int32_t
nsTStringRepr
<
T
>
:
:
RFind
(
const
char
*
aString
bool
aIgnoreCase
int32_t
aOffset
int32_t
aCount
)
const
{
return
RFind
(
nsTDependentString
<
char
>
(
aString
)
aIgnoreCase
aOffset
aCount
)
;
}
template
<
typename
T
>
int32_t
nsTStringRepr
<
T
>
:
:
RFindChar
(
char16_t
aChar
int32_t
aOffset
int32_t
aCount
)
const
{
return
nsBufferRoutines
<
T
>
:
:
rfind_char
(
this
-
>
mData
this
-
>
mLength
aOffset
aChar
aCount
)
;
}
template
<
typename
T
>
int32_t
nsTStringRepr
<
T
>
:
:
FindCharInSet
(
const
char_type
*
aSet
int32_t
aOffset
)
const
{
if
(
aOffset
<
0
)
aOffset
=
0
;
else
if
(
aOffset
>
=
int32_t
(
this
-
>
mLength
)
)
return
kNotFound
;
int32_t
result
=
:
:
FindCharInSet
(
this
-
>
mData
+
aOffset
this
-
>
mLength
-
aOffset
aSet
)
;
if
(
result
!
=
kNotFound
)
result
+
=
aOffset
;
return
result
;
}
template
<
typename
T
>
int32_t
nsTStringRepr
<
T
>
:
:
RFindCharInSet
(
const
char_type
*
aSet
int32_t
aOffset
)
const
{
if
(
aOffset
<
0
|
|
aOffset
>
int32_t
(
this
-
>
mLength
)
)
aOffset
=
this
-
>
mLength
;
else
+
+
aOffset
;
return
:
:
RFindCharInSet
(
this
-
>
mData
aOffset
aSet
)
;
}
}
template
<
typename
T
>
typename
nsTSubstring
<
T
>
:
:
size_type
nsTSubstring
<
T
>
:
:
Mid
(
self_type
&
aResult
index_type
aStartPos
size_type
aLengthToCopy
)
const
{
if
(
aStartPos
=
=
0
&
&
aLengthToCopy
>
=
this
-
>
mLength
)
aResult
=
*
this
;
else
aResult
=
Substring
(
*
this
aStartPos
aLengthToCopy
)
;
return
aResult
.
mLength
;
}
template
<
typename
T
>
bool
nsTString
<
T
>
:
:
SetCharAt
(
char16_t
aChar
index_type
aIndex
)
{
if
(
aIndex
>
=
this
-
>
mLength
)
return
false
;
if
(
!
this
-
>
EnsureMutable
(
)
)
this
-
>
AllocFailed
(
this
-
>
mLength
)
;
this
-
>
mData
[
aIndex
]
=
char_type
(
aChar
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
StripWhitespace
(
)
{
if
(
!
StripWhitespace
(
mozilla
:
:
fallible
)
)
{
this
-
>
AllocFailed
(
this
-
>
mLength
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
StripWhitespace
(
const
fallible_t
&
)
{
if
(
!
this
-
>
EnsureMutable
(
)
)
{
return
false
;
}
this
-
>
StripTaggedASCII
(
mozilla
:
:
ASCIIMask
:
:
MaskWhitespace
(
)
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
ReplaceChar
(
char_type
aOldChar
char_type
aNewChar
)
{
if
(
!
this
-
>
EnsureMutable
(
)
)
this
-
>
AllocFailed
(
this
-
>
mLength
)
;
for
(
uint32_t
i
=
0
;
i
<
this
-
>
mLength
;
+
+
i
)
{
if
(
this
-
>
mData
[
i
]
=
=
aOldChar
)
this
-
>
mData
[
i
]
=
aNewChar
;
}
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
ReplaceChar
(
const
char_type
*
aSet
char_type
aNewChar
)
{
if
(
!
this
-
>
EnsureMutable
(
)
)
this
-
>
AllocFailed
(
this
-
>
mLength
)
;
char_type
*
data
=
this
-
>
mData
;
uint32_t
lenRemaining
=
this
-
>
mLength
;
while
(
lenRemaining
)
{
int32_t
i
=
:
:
FindCharInSet
(
data
lenRemaining
aSet
)
;
if
(
i
=
=
kNotFound
)
break
;
data
[
i
+
+
]
=
aNewChar
;
data
+
=
i
;
lenRemaining
-
=
i
;
}
}
template
void
nsTSubstring
<
char16_t
>
:
:
ReplaceChar
(
const
char
*
char16_t
)
;
void
ReleaseData
(
void
*
aData
nsAString
:
:
DataFlags
aFlags
)
;
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
ReplaceSubstring
(
const
char_type
*
aTarget
const
char_type
*
aNewValue
)
{
ReplaceSubstring
(
nsTDependentString
<
T
>
(
aTarget
)
nsTDependentString
<
T
>
(
aNewValue
)
)
;
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
ReplaceSubstring
(
const
char_type
*
aTarget
const
char_type
*
aNewValue
const
fallible_t
&
aFallible
)
{
return
ReplaceSubstring
(
nsTDependentString
<
T
>
(
aTarget
)
nsTDependentString
<
T
>
(
aNewValue
)
aFallible
)
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
ReplaceSubstring
(
const
self_type
&
aTarget
const
self_type
&
aNewValue
)
{
if
(
!
ReplaceSubstring
(
aTarget
aNewValue
mozilla
:
:
fallible
)
)
{
this
-
>
AllocFailed
(
this
-
>
mLength
+
(
aNewValue
.
Length
(
)
-
aTarget
.
Length
(
)
)
)
;
}
}
template
<
typename
T
>
bool
nsTSubstring
<
T
>
:
:
ReplaceSubstring
(
const
self_type
&
aTarget
const
self_type
&
aNewValue
const
fallible_t
&
)
{
struct
Segment
{
uint32_t
mBegin
mLength
;
Segment
(
uint32_t
aBegin
uint32_t
aLength
)
:
mBegin
(
aBegin
)
mLength
(
aLength
)
{
}
}
;
if
(
aTarget
.
Length
(
)
=
=
0
)
return
true
;
AutoTArray
<
Segment
16
>
nonMatching
;
uint32_t
i
=
0
;
mozilla
:
:
CheckedUint32
newLength
;
while
(
true
)
{
int32_t
r
=
FindSubstring
(
this
-
>
mData
+
i
this
-
>
mLength
-
i
static_cast
<
const
char_type
*
>
(
aTarget
.
Data
(
)
)
aTarget
.
Length
(
)
false
)
;
int32_t
until
=
(
r
=
=
kNotFound
)
?
this
-
>
mLength
-
i
:
r
;
nonMatching
.
AppendElement
(
Segment
(
i
until
)
)
;
newLength
+
=
until
;
if
(
r
=
=
kNotFound
)
{
break
;
}
newLength
+
=
aNewValue
.
Length
(
)
;
i
+
=
r
+
aTarget
.
Length
(
)
;
if
(
i
>
=
this
-
>
mLength
)
{
nonMatching
.
AppendElement
(
Segment
(
this
-
>
mLength
0
)
)
;
break
;
}
}
if
(
!
newLength
.
isValid
(
)
)
{
return
false
;
}
if
(
nonMatching
.
Length
(
)
=
=
1
)
{
MOZ_ASSERT
(
nonMatching
[
0
]
.
mBegin
=
=
0
&
&
nonMatching
[
0
]
.
mLength
=
=
this
-
>
mLength
"
We
should
have
the
correct
non
-
matching
segment
.
"
)
;
return
true
;
}
uint32_t
oldLen
=
this
-
>
mLength
;
auto
r
=
this
-
>
StartBulkWriteImpl
(
XPCOM_MAX
(
oldLen
newLength
.
value
(
)
)
oldLen
)
;
if
(
r
.
isErr
(
)
)
{
return
false
;
}
if
(
aTarget
.
Length
(
)
>
=
aNewValue
.
Length
(
)
)
{
const
uint32_t
delta
=
(
aTarget
.
Length
(
)
-
aNewValue
.
Length
(
)
)
;
for
(
i
=
1
;
i
<
nonMatching
.
Length
(
)
;
+
+
i
)
{
const
char_type
*
sourceSegmentPtr
=
this
-
>
mData
+
nonMatching
[
i
]
.
mBegin
;
char_type
*
destinationSegmentPtr
=
this
-
>
mData
+
nonMatching
[
i
]
.
mBegin
-
i
*
delta
;
char_traits
:
:
copy
(
destinationSegmentPtr
-
aNewValue
.
Length
(
)
aNewValue
.
Data
(
)
aNewValue
.
Length
(
)
)
;
char_traits
:
:
move
(
destinationSegmentPtr
sourceSegmentPtr
nonMatching
[
i
]
.
mLength
)
;
}
}
else
{
const
uint32_t
delta
=
(
aNewValue
.
Length
(
)
-
aTarget
.
Length
(
)
)
;
for
(
i
=
nonMatching
.
Length
(
)
-
1
;
i
>
0
;
-
-
i
)
{
const
char_type
*
sourceSegmentPtr
=
this
-
>
mData
+
nonMatching
[
i
]
.
mBegin
;
char_type
*
destinationSegmentPtr
=
this
-
>
mData
+
nonMatching
[
i
]
.
mBegin
+
i
*
delta
;
char_traits
:
:
move
(
destinationSegmentPtr
sourceSegmentPtr
nonMatching
[
i
]
.
mLength
)
;
char_traits
:
:
copy
(
destinationSegmentPtr
-
aNewValue
.
Length
(
)
aNewValue
.
Data
(
)
aNewValue
.
Length
(
)
)
;
}
}
this
-
>
FinishBulkWriteImpl
(
newLength
.
value
(
)
)
;
return
true
;
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
Trim
(
const
char
*
aSet
bool
aTrimLeading
bool
aTrimTrailing
bool
aIgnoreQuotes
)
{
if
(
!
aSet
)
return
;
char_type
*
start
=
this
-
>
mData
;
char_type
*
end
=
this
-
>
mData
+
this
-
>
mLength
;
if
(
aIgnoreQuotes
&
&
this
-
>
mLength
>
2
&
&
this
-
>
mData
[
0
]
=
=
this
-
>
mData
[
this
-
>
mLength
-
1
]
&
&
(
this
-
>
mData
[
0
]
=
=
'
\
'
'
|
|
this
-
>
mData
[
0
]
=
=
'
"
'
)
)
{
+
+
start
;
-
-
end
;
}
uint32_t
setLen
=
nsCharTraits
<
char
>
:
:
length
(
aSet
)
;
if
(
aTrimLeading
)
{
uint32_t
cutStart
=
start
-
this
-
>
mData
;
uint32_t
cutLength
=
0
;
for
(
;
start
!
=
end
;
+
+
start
+
+
cutLength
)
{
int32_t
pos
=
FindChar1
(
aSet
setLen
0
*
start
setLen
)
;
if
(
pos
=
=
kNotFound
)
break
;
}
if
(
cutLength
)
{
this
-
>
Cut
(
cutStart
cutLength
)
;
start
=
this
-
>
mData
+
cutStart
;
end
=
this
-
>
mData
+
this
-
>
mLength
-
cutStart
;
}
}
if
(
aTrimTrailing
)
{
uint32_t
cutEnd
=
end
-
this
-
>
mData
;
uint32_t
cutLength
=
0
;
-
-
end
;
for
(
;
end
>
=
start
;
-
-
end
+
+
cutLength
)
{
int32_t
pos
=
FindChar1
(
aSet
setLen
0
*
end
setLen
)
;
if
(
pos
=
=
kNotFound
)
break
;
}
if
(
cutLength
)
this
-
>
Cut
(
cutEnd
-
cutLength
cutLength
)
;
}
}
template
<
typename
T
>
void
nsTSubstring
<
T
>
:
:
CompressWhitespace
(
bool
aTrimLeading
bool
aTrimTrailing
)
{
if
(
this
-
>
mLength
=
=
0
)
{
return
;
}
if
(
!
this
-
>
EnsureMutable
(
)
)
this
-
>
AllocFailed
(
this
-
>
mLength
)
;
const
ASCIIMaskArray
&
mask
=
mozilla
:
:
ASCIIMask
:
:
MaskWhitespace
(
)
;
char_type
*
to
=
this
-
>
mData
;
char_type
*
from
=
this
-
>
mData
;
char_type
*
end
=
this
-
>
mData
+
this
-
>
mLength
;
bool
skipWS
=
aTrimLeading
;
while
(
from
<
end
)
{
uint32_t
theChar
=
*
from
+
+
;
if
(
mozilla
:
:
ASCIIMask
:
:
IsMasked
(
mask
theChar
)
)
{
if
(
!
skipWS
)
{
*
to
+
+
=
'
'
;
skipWS
=
true
;
}
}
else
{
*
to
+
+
=
theChar
;
skipWS
=
false
;
}
}
if
(
aTrimTrailing
&
&
skipWS
&
&
to
>
this
-
>
mData
)
{
to
-
-
;
}
*
to
=
char_type
(
0
)
;
this
-
>
mLength
=
to
-
this
-
>
mData
;
}
