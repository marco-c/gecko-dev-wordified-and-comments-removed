#
include
"
nsTArray
.
h
"
#
include
"
nsASCIIMask
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
template
<
typename
T
>
int32_t
nsTString
<
T
>
:
:
Find
(
const
nsTString
<
char
>
&
aString
bool
aIgnoreCase
int32_t
aOffset
int32_t
aCount
)
const
{
Find_ComputeSearchRange
(
this
-
>
mLength
aString
.
Length
(
)
aOffset
aCount
)
;
int32_t
result
=
FindSubstring
(
this
-
>
mData
+
aOffset
aCount
aString
.
get
(
)
aString
.
Length
(
)
aIgnoreCase
)
;
if
(
result
!
=
kNotFound
)
result
+
=
aOffset
;
return
result
;
}
template
<
typename
T
>
int32_t
nsTString
<
T
>
:
:
Find
(
const
char
*
aString
bool
aIgnoreCase
int32_t
aOffset
int32_t
aCount
)
const
{
return
Find
(
nsTDependentString
<
char
>
(
aString
)
aIgnoreCase
aOffset
aCount
)
;
}
template
<
typename
T
>
int32_t
nsTString
<
T
>
:
:
RFind
(
const
nsTString
<
char
>
&
aString
bool
aIgnoreCase
int32_t
aOffset
int32_t
aCount
)
const
{
RFind_ComputeSearchRange
(
this
-
>
mLength
aString
.
Length
(
)
aOffset
aCount
)
;
int32_t
result
=
RFindSubstring
(
this
-
>
mData
+
aOffset
aCount
aString
.
get
(
)
aString
.
Length
(
)
aIgnoreCase
)
;
if
(
result
!
=
kNotFound
)
result
+
=
aOffset
;
return
result
;
}
template
<
typename
T
>
int32_t
nsTString
<
T
>
:
:
RFind
(
const
char
*
aString
bool
aIgnoreCase
int32_t
aOffset
int32_t
aCount
)
const
{
return
RFind
(
nsTDependentString
<
char
>
(
aString
)
aIgnoreCase
aOffset
aCount
)
;
}
template
<
typename
T
>
int32_t
nsTString
<
T
>
:
:
RFindChar
(
char16_t
aChar
int32_t
aOffset
int32_t
aCount
)
const
{
return
nsBufferRoutines
<
T
>
:
:
rfind_char
(
this
-
>
mData
this
-
>
mLength
aOffset
aChar
aCount
)
;
}
template
<
typename
T
>
int32_t
nsTString
<
T
>
:
:
FindCharInSet
(
const
char_type
*
aSet
int32_t
aOffset
)
const
{
if
(
aOffset
<
0
)
aOffset
=
0
;
else
if
(
aOffset
>
=
int32_t
(
this
-
>
mLength
)
)
return
kNotFound
;
int32_t
result
=
:
:
FindCharInSet
(
this
-
>
mData
+
aOffset
this
-
>
mLength
-
aOffset
aSet
)
;
if
(
result
!
=
kNotFound
)
result
+
=
aOffset
;
return
result
;
}
template
<
typename
T
>
int32_t
nsTString
<
T
>
:
:
RFindCharInSet
(
const
char_type
*
aSet
int32_t
aOffset
)
const
{
if
(
aOffset
<
0
|
|
aOffset
>
int32_t
(
this
-
>
mLength
)
)
aOffset
=
this
-
>
mLength
;
else
+
+
aOffset
;
return
:
:
RFindCharInSet
(
this
-
>
mData
aOffset
aSet
)
;
}
template
<
typename
T
>
int32_t
nsTString
<
T
>
:
:
ToInteger
(
nsresult
*
aErrorCode
uint32_t
aRadix
)
const
{
char_type
*
cp
=
this
-
>
mData
;
int32_t
theRadix
=
10
;
int32_t
result
=
0
;
bool
negate
=
false
;
char_type
theChar
=
0
;
*
aErrorCode
=
NS_ERROR_ILLEGAL_VALUE
;
if
(
cp
)
{
char_type
*
endcp
=
cp
+
this
-
>
mLength
;
bool
done
=
false
;
while
(
(
cp
<
endcp
)
&
&
(
!
done
)
)
{
switch
(
*
cp
+
+
)
{
case
'
a
'
:
case
'
b
'
:
case
'
c
'
:
case
'
d
'
:
case
'
e
'
:
case
'
f
'
:
case
'
A
'
:
case
'
B
'
:
case
'
C
'
:
case
'
D
'
:
case
'
E
'
:
case
'
F
'
:
theRadix
=
16
;
done
=
true
;
break
;
case
'
0
'
:
case
'
1
'
:
case
'
2
'
:
case
'
3
'
:
case
'
4
'
:
case
'
5
'
:
case
'
6
'
:
case
'
7
'
:
case
'
8
'
:
case
'
9
'
:
done
=
true
;
break
;
case
'
-
'
:
negate
=
true
;
break
;
case
'
X
'
:
case
'
x
'
:
theRadix
=
16
;
break
;
default
:
break
;
}
}
if
(
done
)
{
*
aErrorCode
=
NS_OK
;
if
(
aRadix
!
=
kAutoDetect
)
theRadix
=
aRadix
;
char_type
*
first
=
-
-
cp
;
bool
haveValue
=
false
;
while
(
cp
<
endcp
)
{
int32_t
oldresult
=
result
;
theChar
=
*
cp
+
+
;
if
(
(
'
0
'
<
=
theChar
)
&
&
(
theChar
<
=
'
9
'
)
)
{
result
=
(
theRadix
*
result
)
+
(
theChar
-
'
0
'
)
;
haveValue
=
true
;
}
else
if
(
(
theChar
>
=
'
A
'
)
&
&
(
theChar
<
=
'
F
'
)
)
{
if
(
10
=
=
theRadix
)
{
if
(
kAutoDetect
=
=
aRadix
)
{
theRadix
=
16
;
cp
=
first
;
result
=
0
;
haveValue
=
false
;
}
else
{
*
aErrorCode
=
NS_ERROR_ILLEGAL_VALUE
;
result
=
0
;
break
;
}
}
else
{
result
=
(
theRadix
*
result
)
+
(
(
theChar
-
'
A
'
)
+
10
)
;
haveValue
=
true
;
}
}
else
if
(
(
theChar
>
=
'
a
'
)
&
&
(
theChar
<
=
'
f
'
)
)
{
if
(
10
=
=
theRadix
)
{
if
(
kAutoDetect
=
=
aRadix
)
{
theRadix
=
16
;
cp
=
first
;
result
=
0
;
haveValue
=
false
;
}
else
{
*
aErrorCode
=
NS_ERROR_ILLEGAL_VALUE
;
result
=
0
;
break
;
}
}
else
{
result
=
(
theRadix
*
result
)
+
(
(
theChar
-
'
a
'
)
+
10
)
;
haveValue
=
true
;
}
}
else
if
(
(
(
'
X
'
=
=
theChar
)
|
|
(
'
x
'
=
=
theChar
)
)
&
&
(
!
haveValue
|
|
result
=
=
0
)
)
{
continue
;
}
else
if
(
(
(
'
#
'
=
=
theChar
)
|
|
(
'
+
'
=
=
theChar
)
)
&
&
!
haveValue
)
{
continue
;
}
else
{
break
;
}
if
(
result
<
oldresult
)
{
*
aErrorCode
=
NS_ERROR_ILLEGAL_VALUE
;
result
=
0
;
break
;
}
}
if
(
negate
)
result
=
-
result
;
}
}
return
result
;
}
template
<
typename
T
>
int64_t
nsTString
<
T
>
:
:
ToInteger64
(
nsresult
*
aErrorCode
uint32_t
aRadix
)
const
{
char_type
*
cp
=
this
-
>
mData
;
int32_t
theRadix
=
10
;
int64_t
result
=
0
;
bool
negate
=
false
;
char_type
theChar
=
0
;
*
aErrorCode
=
NS_ERROR_ILLEGAL_VALUE
;
if
(
cp
)
{
char_type
*
endcp
=
cp
+
this
-
>
mLength
;
bool
done
=
false
;
while
(
(
cp
<
endcp
)
&
&
(
!
done
)
)
{
switch
(
*
cp
+
+
)
{
case
'
a
'
:
case
'
b
'
:
case
'
c
'
:
case
'
d
'
:
case
'
e
'
:
case
'
f
'
:
case
'
A
'
:
case
'
B
'
:
case
'
C
'
:
case
'
D
'
:
case
'
E
'
:
case
'
F
'
:
theRadix
=
16
;
done
=
true
;
break
;
case
'
0
'
:
case
'
1
'
:
case
'
2
'
:
case
'
3
'
:
case
'
4
'
:
case
'
5
'
:
case
'
6
'
:
case
'
7
'
:
case
'
8
'
:
case
'
9
'
:
done
=
true
;
break
;
case
'
-
'
:
negate
=
true
;
break
;
case
'
X
'
:
case
'
x
'
:
theRadix
=
16
;
break
;
default
:
break
;
}
}
if
(
done
)
{
*
aErrorCode
=
NS_OK
;
if
(
aRadix
!
=
kAutoDetect
)
theRadix
=
aRadix
;
char_type
*
first
=
-
-
cp
;
bool
haveValue
=
false
;
while
(
cp
<
endcp
)
{
int64_t
oldresult
=
result
;
theChar
=
*
cp
+
+
;
if
(
(
'
0
'
<
=
theChar
)
&
&
(
theChar
<
=
'
9
'
)
)
{
result
=
(
theRadix
*
result
)
+
(
theChar
-
'
0
'
)
;
haveValue
=
true
;
}
else
if
(
(
theChar
>
=
'
A
'
)
&
&
(
theChar
<
=
'
F
'
)
)
{
if
(
10
=
=
theRadix
)
{
if
(
kAutoDetect
=
=
aRadix
)
{
theRadix
=
16
;
cp
=
first
;
result
=
0
;
haveValue
=
false
;
}
else
{
*
aErrorCode
=
NS_ERROR_ILLEGAL_VALUE
;
result
=
0
;
break
;
}
}
else
{
result
=
(
theRadix
*
result
)
+
(
(
theChar
-
'
A
'
)
+
10
)
;
haveValue
=
true
;
}
}
else
if
(
(
theChar
>
=
'
a
'
)
&
&
(
theChar
<
=
'
f
'
)
)
{
if
(
10
=
=
theRadix
)
{
if
(
kAutoDetect
=
=
aRadix
)
{
theRadix
=
16
;
cp
=
first
;
result
=
0
;
haveValue
=
false
;
}
else
{
*
aErrorCode
=
NS_ERROR_ILLEGAL_VALUE
;
result
=
0
;
break
;
}
}
else
{
result
=
(
theRadix
*
result
)
+
(
(
theChar
-
'
a
'
)
+
10
)
;
haveValue
=
true
;
}
}
else
if
(
(
(
'
X
'
=
=
theChar
)
|
|
(
'
x
'
=
=
theChar
)
)
&
&
(
!
haveValue
|
|
result
=
=
0
)
)
{
continue
;
}
else
if
(
(
(
'
#
'
=
=
theChar
)
|
|
(
'
+
'
=
=
theChar
)
)
&
&
!
haveValue
)
{
continue
;
}
else
{
break
;
}
if
(
result
<
oldresult
)
{
*
aErrorCode
=
NS_ERROR_ILLEGAL_VALUE
;
result
=
0
;
break
;
}
}
if
(
negate
)
result
=
-
result
;
}
}
return
result
;
}
template
<
typename
T
>
typename
nsTString
<
T
>
:
:
size_type
nsTString
<
T
>
:
:
Mid
(
self_type
&
aResult
index_type
aStartPos
size_type
aLengthToCopy
)
const
{
if
(
aStartPos
=
=
0
&
&
aLengthToCopy
>
=
this
-
>
mLength
)
aResult
=
*
this
;
else
aResult
=
Substring
(
*
this
aStartPos
aLengthToCopy
)
;
return
aResult
.
mLength
;
}
template
<
typename
T
>
bool
nsTString
<
T
>
:
:
SetCharAt
(
char16_t
aChar
uint32_t
aIndex
)
{
if
(
aIndex
>
=
this
-
>
mLength
)
return
false
;
if
(
!
this
-
>
EnsureMutable
(
)
)
this
-
>
AllocFailed
(
this
-
>
mLength
)
;
this
-
>
mData
[
aIndex
]
=
char_type
(
aChar
)
;
return
true
;
}
template
<
typename
T
>
template
<
typename
EnableIfChar16
>
void
nsTString
<
T
>
:
:
StripChars
(
const
incompatible_char_type
*
aSet
)
{
if
(
!
StripChars
(
aSet
mozilla
:
:
fallible
)
)
{
this
-
>
AllocFailed
(
this
-
>
mLength
)
;
}
}
template
<
typename
T
>
template
<
typename
EnableIfChar16
>
bool
nsTString
<
T
>
:
:
StripChars
(
const
incompatible_char_type
*
aSet
const
fallible_t
&
)
{
if
(
!
this
-
>
EnsureMutable
(
)
)
{
return
false
;
}
this
-
>
mLength
=
nsBufferRoutines
<
T
>
:
:
strip_chars
(
this
-
>
mData
this
-
>
mLength
aSet
)
;
return
true
;
}
template
<
typename
T
>
void
nsTString
<
T
>
:
:
StripChars
(
const
char_type
*
aSet
)
{
nsTSubstring
<
T
>
:
:
StripChars
(
aSet
)
;
}
template
<
typename
T
>
void
nsTString
<
T
>
:
:
StripWhitespace
(
)
{
if
(
!
StripWhitespace
(
mozilla
:
:
fallible
)
)
{
this
-
>
AllocFailed
(
this
-
>
mLength
)
;
}
}
template
<
typename
T
>
bool
nsTString
<
T
>
:
:
StripWhitespace
(
const
fallible_t
&
)
{
if
(
!
this
-
>
EnsureMutable
(
)
)
{
return
false
;
}
this
-
>
StripTaggedASCII
(
mozilla
:
:
ASCIIMask
:
:
MaskWhitespace
(
)
)
;
return
true
;
}
template
<
typename
T
>
void
nsTString
<
T
>
:
:
ReplaceChar
(
char_type
aOldChar
char_type
aNewChar
)
{
if
(
!
this
-
>
EnsureMutable
(
)
)
this
-
>
AllocFailed
(
this
-
>
mLength
)
;
for
(
uint32_t
i
=
0
;
i
<
this
-
>
mLength
;
+
+
i
)
{
if
(
this
-
>
mData
[
i
]
=
=
aOldChar
)
this
-
>
mData
[
i
]
=
aNewChar
;
}
}
template
<
typename
T
>
void
nsTString
<
T
>
:
:
ReplaceChar
(
const
char_type
*
aSet
char_type
aNewChar
)
{
if
(
!
this
-
>
EnsureMutable
(
)
)
this
-
>
AllocFailed
(
this
-
>
mLength
)
;
char_type
*
data
=
this
-
>
mData
;
uint32_t
lenRemaining
=
this
-
>
mLength
;
while
(
lenRemaining
)
{
int32_t
i
=
:
:
FindCharInSet
(
data
lenRemaining
aSet
)
;
if
(
i
=
=
kNotFound
)
break
;
data
[
i
+
+
]
=
aNewChar
;
data
+
=
i
;
lenRemaining
-
=
i
;
}
}
void
ReleaseData
(
void
*
aData
nsAString
:
:
DataFlags
aFlags
)
;
template
<
typename
T
>
void
nsTString
<
T
>
:
:
ReplaceSubstring
(
const
char_type
*
aTarget
const
char_type
*
aNewValue
)
{
ReplaceSubstring
(
nsTDependentString
<
T
>
(
aTarget
)
nsTDependentString
<
T
>
(
aNewValue
)
)
;
}
template
<
typename
T
>
bool
nsTString
<
T
>
:
:
ReplaceSubstring
(
const
char_type
*
aTarget
const
char_type
*
aNewValue
const
fallible_t
&
aFallible
)
{
return
ReplaceSubstring
(
nsTDependentString
<
T
>
(
aTarget
)
nsTDependentString
<
T
>
(
aNewValue
)
aFallible
)
;
}
template
<
typename
T
>
void
nsTString
<
T
>
:
:
ReplaceSubstring
(
const
self_type
&
aTarget
const
self_type
&
aNewValue
)
{
if
(
!
ReplaceSubstring
(
aTarget
aNewValue
mozilla
:
:
fallible
)
)
{
this
-
>
AllocFailed
(
this
-
>
mLength
+
(
aNewValue
.
Length
(
)
-
aTarget
.
Length
(
)
)
)
;
}
}
template
<
typename
T
>
bool
nsTString
<
T
>
:
:
ReplaceSubstring
(
const
self_type
&
aTarget
const
self_type
&
aNewValue
const
fallible_t
&
)
{
if
(
aTarget
.
Length
(
)
=
=
0
)
return
true
;
AutoTArray
<
Segment
16
>
nonMatching
;
uint32_t
i
=
0
;
mozilla
:
:
CheckedUint32
newLength
;
while
(
true
)
{
int32_t
r
=
FindSubstring
(
this
-
>
mData
+
i
this
-
>
mLength
-
i
static_cast
<
const
char_type
*
>
(
aTarget
.
Data
(
)
)
aTarget
.
Length
(
)
false
)
;
int32_t
until
=
(
r
=
=
kNotFound
)
?
this
-
>
mLength
-
i
:
r
;
nonMatching
.
AppendElement
(
Segment
(
i
until
)
)
;
newLength
+
=
until
;
if
(
r
=
=
kNotFound
)
{
break
;
}
newLength
+
=
aNewValue
.
Length
(
)
;
i
+
=
r
+
aTarget
.
Length
(
)
;
if
(
i
>
=
this
-
>
mLength
)
{
nonMatching
.
AppendElement
(
Segment
(
this
-
>
mLength
0
)
)
;
break
;
}
}
if
(
!
newLength
.
isValid
(
)
)
{
return
false
;
}
if
(
nonMatching
.
Length
(
)
=
=
1
)
{
MOZ_ASSERT
(
nonMatching
[
0
]
.
mBegin
=
=
0
&
&
nonMatching
[
0
]
.
mLength
=
=
this
-
>
mLength
"
We
should
have
the
correct
non
-
matching
segment
.
"
)
;
return
true
;
}
char_type
*
oldData
;
DataFlags
oldFlags
;
if
(
!
this
-
>
MutatePrep
(
XPCOM_MAX
(
this
-
>
mLength
newLength
.
value
(
)
)
&
oldData
&
oldFlags
)
)
return
false
;
if
(
oldData
)
{
char_traits
:
:
copy
(
this
-
>
mData
oldData
this
-
>
mLength
)
;
:
:
ReleaseData
(
oldData
oldFlags
)
;
}
if
(
aTarget
.
Length
(
)
>
=
aNewValue
.
Length
(
)
)
{
const
uint32_t
delta
=
(
aTarget
.
Length
(
)
-
aNewValue
.
Length
(
)
)
;
for
(
i
=
1
;
i
<
nonMatching
.
Length
(
)
;
+
+
i
)
{
const
char_type
*
sourceSegmentPtr
=
this
-
>
mData
+
nonMatching
[
i
]
.
mBegin
;
char_type
*
destinationSegmentPtr
=
this
-
>
mData
+
nonMatching
[
i
]
.
mBegin
-
i
*
delta
;
char_traits
:
:
copy
(
destinationSegmentPtr
-
aNewValue
.
Length
(
)
aNewValue
.
Data
(
)
aNewValue
.
Length
(
)
)
;
char_traits
:
:
move
(
destinationSegmentPtr
sourceSegmentPtr
nonMatching
[
i
]
.
mLength
)
;
}
}
else
{
const
uint32_t
delta
=
(
aNewValue
.
Length
(
)
-
aTarget
.
Length
(
)
)
;
for
(
i
=
nonMatching
.
Length
(
)
-
1
;
i
>
0
;
-
-
i
)
{
const
char_type
*
sourceSegmentPtr
=
this
-
>
mData
+
nonMatching
[
i
]
.
mBegin
;
char_type
*
destinationSegmentPtr
=
this
-
>
mData
+
nonMatching
[
i
]
.
mBegin
+
i
*
delta
;
char_traits
:
:
move
(
destinationSegmentPtr
sourceSegmentPtr
nonMatching
[
i
]
.
mLength
)
;
char_traits
:
:
copy
(
destinationSegmentPtr
-
aNewValue
.
Length
(
)
aNewValue
.
Data
(
)
aNewValue
.
Length
(
)
)
;
}
}
this
-
>
mLength
=
newLength
.
value
(
)
;
this
-
>
mData
[
this
-
>
mLength
]
=
char_type
(
0
)
;
return
true
;
}
template
<
typename
T
>
void
nsTString
<
T
>
:
:
Trim
(
const
char
*
aSet
bool
aTrimLeading
bool
aTrimTrailing
bool
aIgnoreQuotes
)
{
if
(
!
aSet
)
return
;
char_type
*
start
=
this
-
>
mData
;
char_type
*
end
=
this
-
>
mData
+
this
-
>
mLength
;
if
(
aIgnoreQuotes
&
&
this
-
>
mLength
>
2
&
&
this
-
>
mData
[
0
]
=
=
this
-
>
mData
[
this
-
>
mLength
-
1
]
&
&
(
this
-
>
mData
[
0
]
=
=
'
\
'
'
|
|
this
-
>
mData
[
0
]
=
=
'
"
'
)
)
{
+
+
start
;
-
-
end
;
}
uint32_t
setLen
=
nsCharTraits
<
char
>
:
:
length
(
aSet
)
;
if
(
aTrimLeading
)
{
uint32_t
cutStart
=
start
-
this
-
>
mData
;
uint32_t
cutLength
=
0
;
for
(
;
start
!
=
end
;
+
+
start
+
+
cutLength
)
{
int32_t
pos
=
FindChar1
(
aSet
setLen
0
*
start
setLen
)
;
if
(
pos
=
=
kNotFound
)
break
;
}
if
(
cutLength
)
{
this
-
>
Cut
(
cutStart
cutLength
)
;
start
=
this
-
>
mData
+
cutStart
;
end
=
this
-
>
mData
+
this
-
>
mLength
-
cutStart
;
}
}
if
(
aTrimTrailing
)
{
uint32_t
cutEnd
=
end
-
this
-
>
mData
;
uint32_t
cutLength
=
0
;
-
-
end
;
for
(
;
end
>
=
start
;
-
-
end
+
+
cutLength
)
{
int32_t
pos
=
FindChar1
(
aSet
setLen
0
*
end
setLen
)
;
if
(
pos
=
=
kNotFound
)
break
;
}
if
(
cutLength
)
this
-
>
Cut
(
cutEnd
-
cutLength
cutLength
)
;
}
}
template
<
typename
T
>
void
nsTString
<
T
>
:
:
CompressWhitespace
(
bool
aTrimLeading
bool
aTrimTrailing
)
{
if
(
this
-
>
mLength
=
=
0
)
{
return
;
}
if
(
!
this
-
>
EnsureMutable
(
)
)
this
-
>
AllocFailed
(
this
-
>
mLength
)
;
const
ASCIIMaskArray
&
mask
=
mozilla
:
:
ASCIIMask
:
:
MaskWhitespace
(
)
;
char_type
*
to
=
this
-
>
mData
;
char_type
*
from
=
this
-
>
mData
;
char_type
*
end
=
this
-
>
mData
+
this
-
>
mLength
;
bool
skipWS
=
aTrimLeading
;
while
(
from
<
end
)
{
uint32_t
theChar
=
*
from
+
+
;
if
(
mozilla
:
:
ASCIIMask
:
:
IsMasked
(
mask
theChar
)
)
{
if
(
!
skipWS
)
{
*
to
+
+
=
'
'
;
skipWS
=
true
;
}
}
else
{
*
to
+
+
=
theChar
;
skipWS
=
false
;
}
}
if
(
aTrimTrailing
&
&
skipWS
&
&
to
>
this
-
>
mData
)
{
to
-
-
;
}
*
to
=
char_type
(
0
)
;
this
-
>
mLength
=
to
-
this
-
>
mData
;
}
