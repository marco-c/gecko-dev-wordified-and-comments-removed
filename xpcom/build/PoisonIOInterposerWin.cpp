#
include
"
PoisonIOInterposer
.
h
"
#
include
<
io
.
h
>
#
include
<
windows
.
h
>
#
include
<
winternl
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
FileUtilsWin
.
h
"
#
include
"
mozilla
/
IOInterposer
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
NativeNt
.
h
"
#
include
"
mozilla
/
SmallArrayLRUCache
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWindowsDllInterceptor
.
h
"
#
ifdef
MOZ_REPLACE_MALLOC
#
include
"
replace_malloc_bridge
.
h
"
#
endif
namespace
{
static
bool
sIOPoisoned
=
false
;
typedef
NTSTATUS
(
NTAPI
*
NtCreateFileFn
)
(
PHANDLE
aFileHandle
ACCESS_MASK
aDesiredAccess
POBJECT_ATTRIBUTES
aObjectAttributes
PIO_STATUS_BLOCK
aIoStatusBlock
PLARGE_INTEGER
aAllocationSize
ULONG
aFileAttributes
ULONG
aShareAccess
ULONG
aCreateDisposition
ULONG
aCreateOptions
PVOID
aEaBuffer
ULONG
aEaLength
)
;
typedef
NTSTATUS
(
NTAPI
*
NtReadFileFn
)
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
PVOID
aBuffer
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
;
typedef
NTSTATUS
(
NTAPI
*
NtReadFileScatterFn
)
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
FILE_SEGMENT_ELEMENT
*
aSegments
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
;
typedef
NTSTATUS
(
NTAPI
*
NtWriteFileFn
)
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
PVOID
aBuffer
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
;
typedef
NTSTATUS
(
NTAPI
*
NtWriteFileGatherFn
)
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
FILE_SEGMENT_ELEMENT
*
aSegments
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
;
typedef
NTSTATUS
(
NTAPI
*
NtFlushBuffersFileFn
)
(
HANDLE
aFileHandle
PIO_STATUS_BLOCK
aIoStatusBlock
)
;
typedef
struct
_FILE_NETWORK_OPEN_INFORMATION
*
PFILE_NETWORK_OPEN_INFORMATION
;
typedef
NTSTATUS
(
NTAPI
*
NtQueryFullAttributesFileFn
)
(
POBJECT_ATTRIBUTES
aObjectAttributes
PFILE_NETWORK_OPEN_INFORMATION
aFileInformation
)
;
using
HandleToFilenameCache
=
mozilla
:
:
SmallArrayLRUCache
<
HANDLE
nsString
32
>
;
MOZ_RUNINIT
static
mozilla
:
:
UniquePtr
<
HandleToFilenameCache
>
sHandleToFilenameCache
;
class
WinIOAutoObservation
:
public
mozilla
:
:
IOInterposeObserver
:
:
Observation
{
public
:
WinIOAutoObservation
(
mozilla
:
:
IOInterposeObserver
:
:
Operation
aOp
HANDLE
aFileHandle
const
LARGE_INTEGER
*
aOffset
)
:
mozilla
:
:
IOInterposeObserver
:
:
Observation
(
aOp
sReference
!
mozilla
:
:
IsDebugFile
(
aFileHandle
)
)
mFileHandle
(
aFileHandle
)
mFileHandleType
(
GetFileType
(
aFileHandle
)
)
mHasQueriedFilename
(
false
)
{
if
(
mShouldReport
)
{
mOffset
.
QuadPart
=
aOffset
?
aOffset
-
>
QuadPart
:
0
;
}
}
WinIOAutoObservation
(
mozilla
:
:
IOInterposeObserver
:
:
Operation
aOp
nsAString
&
aFilename
)
:
mozilla
:
:
IOInterposeObserver
:
:
Observation
(
aOp
sReference
)
mFileHandle
(
nullptr
)
mFileHandleType
(
FILE_TYPE_UNKNOWN
)
mHasQueriedFilename
(
false
)
{
if
(
mShouldReport
)
{
nsAutoString
dosPath
;
if
(
mozilla
:
:
NtPathToDosPath
(
aFilename
dosPath
)
)
{
mFilename
=
dosPath
;
}
else
{
mFilename
=
aFilename
;
}
mHasQueriedFilename
=
true
;
mOffset
.
QuadPart
=
0
;
}
}
void
SetHandle
(
HANDLE
aFileHandle
)
{
mFileHandle
=
aFileHandle
;
if
(
aFileHandle
)
{
mFileHandleType
=
GetFileType
(
aFileHandle
)
;
if
(
mHasQueriedFilename
)
{
sHandleToFilenameCache
-
>
Add
(
aFileHandle
mFilename
)
;
}
}
}
const
char
*
FileType
(
)
const
override
;
void
Filename
(
nsAString
&
aFilename
)
override
;
~
WinIOAutoObservation
(
)
{
Report
(
)
;
}
private
:
HANDLE
mFileHandle
;
DWORD
mFileHandleType
;
LARGE_INTEGER
mOffset
;
bool
mHasQueriedFilename
;
nsString
mFilename
;
static
const
char
*
sReference
;
}
;
const
char
*
WinIOAutoObservation
:
:
sReference
=
"
PoisonIOInterposer
"
;
void
WinIOAutoObservation
:
:
Filename
(
nsAString
&
aFilename
)
{
if
(
mHasQueriedFilename
)
{
aFilename
=
mFilename
;
return
;
}
if
(
mFileHandle
)
{
mFilename
=
sHandleToFilenameCache
-
>
FetchOrAdd
(
mFileHandle
[
&
]
(
)
{
nsString
filename
;
if
(
!
mozilla
:
:
HandleToFilename
(
mFileHandle
mOffset
filename
)
)
{
filename
.
Truncate
(
)
;
}
return
filename
;
}
)
;
}
mHasQueriedFilename
=
true
;
aFilename
=
mFilename
;
}
const
char
*
WinIOAutoObservation
:
:
FileType
(
)
const
{
if
(
mFileHandle
)
{
switch
(
mFileHandleType
)
{
case
FILE_TYPE_CHAR
:
return
"
Char
"
;
case
FILE_TYPE_DISK
:
return
"
File
"
;
case
FILE_TYPE_PIPE
:
return
"
Pipe
"
;
case
FILE_TYPE_REMOTE
:
return
"
Remote
"
;
case
FILE_TYPE_UNKNOWN
:
default
:
break
;
}
}
return
mozilla
:
:
IOInterposeObserver
:
:
Observation
:
:
FileType
(
)
;
}
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtCreateFileFn
>
gOriginalNtCreateFile
;
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtReadFileFn
>
gOriginalNtReadFile
;
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtReadFileScatterFn
>
gOriginalNtReadFileScatter
;
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtWriteFileFn
>
gOriginalNtWriteFile
;
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtWriteFileGatherFn
>
gOriginalNtWriteFileGather
;
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtFlushBuffersFileFn
>
gOriginalNtFlushBuffersFile
;
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtQueryFullAttributesFileFn
>
gOriginalNtQueryFullAttributesFile
;
static
NTSTATUS
NTAPI
InterposedNtCreateFile
(
PHANDLE
aFileHandle
ACCESS_MASK
aDesiredAccess
POBJECT_ATTRIBUTES
aObjectAttributes
PIO_STATUS_BLOCK
aIoStatusBlock
PLARGE_INTEGER
aAllocationSize
ULONG
aFileAttributes
ULONG
aShareAccess
ULONG
aCreateDisposition
ULONG
aCreateOptions
PVOID
aEaBuffer
ULONG
aEaLength
)
{
MOZ_ASSERT
(
gOriginalNtCreateFile
)
;
if
(
!
mozilla
:
:
nt
:
:
RtlGetThreadLocalStoragePointer
(
)
)
{
return
gOriginalNtCreateFile
(
aFileHandle
aDesiredAccess
aObjectAttributes
aIoStatusBlock
aAllocationSize
aFileAttributes
aShareAccess
aCreateDisposition
aCreateOptions
aEaBuffer
aEaLength
)
;
}
const
wchar_t
*
buf
=
aObjectAttributes
?
aObjectAttributes
-
>
ObjectName
-
>
Buffer
:
L
"
"
;
uint32_t
len
=
aObjectAttributes
?
aObjectAttributes
-
>
ObjectName
-
>
Length
/
sizeof
(
WCHAR
)
:
0
;
nsDependentSubstring
filename
(
buf
len
)
;
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpCreateOrOpen
filename
)
;
NTSTATUS
status
=
gOriginalNtCreateFile
(
aFileHandle
aDesiredAccess
aObjectAttributes
aIoStatusBlock
aAllocationSize
aFileAttributes
aShareAccess
aCreateDisposition
aCreateOptions
aEaBuffer
aEaLength
)
;
if
(
NT_SUCCESS
(
status
)
&
&
aFileHandle
)
{
timer
.
SetHandle
(
*
aFileHandle
)
;
}
return
status
;
}
static
NTSTATUS
NTAPI
InterposedNtReadFile
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
PVOID
aBuffer
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
{
MOZ_ASSERT
(
gOriginalNtReadFile
)
;
if
(
!
mozilla
:
:
nt
:
:
RtlGetThreadLocalStoragePointer
(
)
)
{
return
gOriginalNtReadFile
(
aFileHandle
aEvent
aApc
aApcCtx
aIoStatus
aBuffer
aLength
aOffset
aKey
)
;
}
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpRead
aFileHandle
aOffset
)
;
return
gOriginalNtReadFile
(
aFileHandle
aEvent
aApc
aApcCtx
aIoStatus
aBuffer
aLength
aOffset
aKey
)
;
}
static
NTSTATUS
NTAPI
InterposedNtReadFileScatter
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
FILE_SEGMENT_ELEMENT
*
aSegments
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
{
MOZ_ASSERT
(
gOriginalNtReadFileScatter
)
;
if
(
!
mozilla
:
:
nt
:
:
RtlGetThreadLocalStoragePointer
(
)
)
{
return
gOriginalNtReadFileScatter
(
aFileHandle
aEvent
aApc
aApcCtx
aIoStatus
aSegments
aLength
aOffset
aKey
)
;
}
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpRead
aFileHandle
aOffset
)
;
return
gOriginalNtReadFileScatter
(
aFileHandle
aEvent
aApc
aApcCtx
aIoStatus
aSegments
aLength
aOffset
aKey
)
;
}
static
NTSTATUS
NTAPI
InterposedNtWriteFile
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
PVOID
aBuffer
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
{
MOZ_ASSERT
(
gOriginalNtWriteFile
)
;
if
(
!
mozilla
:
:
nt
:
:
RtlGetThreadLocalStoragePointer
(
)
)
{
return
gOriginalNtWriteFile
(
aFileHandle
aEvent
aApc
aApcCtx
aIoStatus
aBuffer
aLength
aOffset
aKey
)
;
}
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpWrite
aFileHandle
aOffset
)
;
return
gOriginalNtWriteFile
(
aFileHandle
aEvent
aApc
aApcCtx
aIoStatus
aBuffer
aLength
aOffset
aKey
)
;
}
static
NTSTATUS
NTAPI
InterposedNtWriteFileGather
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
FILE_SEGMENT_ELEMENT
*
aSegments
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
{
MOZ_ASSERT
(
gOriginalNtWriteFileGather
)
;
if
(
!
mozilla
:
:
nt
:
:
RtlGetThreadLocalStoragePointer
(
)
)
{
return
gOriginalNtWriteFileGather
(
aFileHandle
aEvent
aApc
aApcCtx
aIoStatus
aSegments
aLength
aOffset
aKey
)
;
}
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpWrite
aFileHandle
aOffset
)
;
return
gOriginalNtWriteFileGather
(
aFileHandle
aEvent
aApc
aApcCtx
aIoStatus
aSegments
aLength
aOffset
aKey
)
;
}
static
NTSTATUS
NTAPI
InterposedNtFlushBuffersFile
(
HANDLE
aFileHandle
PIO_STATUS_BLOCK
aIoStatusBlock
)
{
MOZ_ASSERT
(
gOriginalNtFlushBuffersFile
)
;
if
(
!
mozilla
:
:
nt
:
:
RtlGetThreadLocalStoragePointer
(
)
)
{
return
gOriginalNtFlushBuffersFile
(
aFileHandle
aIoStatusBlock
)
;
}
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpFSync
aFileHandle
nullptr
)
;
return
gOriginalNtFlushBuffersFile
(
aFileHandle
aIoStatusBlock
)
;
}
static
NTSTATUS
NTAPI
InterposedNtQueryFullAttributesFile
(
POBJECT_ATTRIBUTES
aObjectAttributes
PFILE_NETWORK_OPEN_INFORMATION
aFileInformation
)
{
MOZ_ASSERT
(
gOriginalNtQueryFullAttributesFile
)
;
if
(
!
mozilla
:
:
nt
:
:
RtlGetThreadLocalStoragePointer
(
)
)
{
return
gOriginalNtQueryFullAttributesFile
(
aObjectAttributes
aFileInformation
)
;
}
const
wchar_t
*
buf
=
aObjectAttributes
?
aObjectAttributes
-
>
ObjectName
-
>
Buffer
:
L
"
"
;
uint32_t
len
=
aObjectAttributes
?
aObjectAttributes
-
>
ObjectName
-
>
Length
/
sizeof
(
WCHAR
)
:
0
;
nsDependentSubstring
filename
(
buf
len
)
;
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpStat
filename
)
;
return
gOriginalNtQueryFullAttributesFile
(
aObjectAttributes
aFileInformation
)
;
}
}
MOZ_RUNINIT
static
mozilla
:
:
WindowsDllInterceptor
sNtDllInterceptor
;
namespace
mozilla
{
void
InitPoisonIOInterposer
(
)
{
if
(
:
:
GetModuleHandleW
(
L
"
kwsui64
.
dll
"
)
|
|
:
:
GetModuleHandleW
(
L
"
ffm64
.
dll
"
)
)
{
return
;
}
if
(
sIOPoisoned
)
{
return
;
}
sIOPoisoned
=
true
;
MOZ_RELEASE_ASSERT
(
!
sHandleToFilenameCache
)
;
sHandleToFilenameCache
=
mozilla
:
:
MakeUnique
<
HandleToFilenameCache
>
(
)
;
mozilla
:
:
RunOnShutdown
(
[
]
(
)
{
sHandleToFilenameCache
-
>
Shutdown
(
)
;
}
)
;
MozillaRegisterDebugFD
(
1
)
;
if
(
:
:
GetStdHandle
(
STD_OUTPUT_HANDLE
)
!
=
:
:
GetStdHandle
(
STD_ERROR_HANDLE
)
)
{
MozillaRegisterDebugFD
(
2
)
;
}
#
ifdef
MOZ_REPLACE_MALLOC
static
DebugFdRegistry
registry
;
ReplaceMalloc
:
:
InitDebugFd
(
registry
)
;
#
endif
sNtDllInterceptor
.
Init
(
"
ntdll
.
dll
"
)
;
gOriginalNtCreateFile
.
Set
(
sNtDllInterceptor
"
NtCreateFile
"
&
InterposedNtCreateFile
)
;
gOriginalNtReadFile
.
Set
(
sNtDllInterceptor
"
NtReadFile
"
&
InterposedNtReadFile
)
;
gOriginalNtReadFileScatter
.
Set
(
sNtDllInterceptor
"
NtReadFileScatter
"
&
InterposedNtReadFileScatter
)
;
gOriginalNtWriteFile
.
Set
(
sNtDllInterceptor
"
NtWriteFile
"
&
InterposedNtWriteFile
)
;
gOriginalNtWriteFileGather
.
Set
(
sNtDllInterceptor
"
NtWriteFileGather
"
&
InterposedNtWriteFileGather
)
;
gOriginalNtFlushBuffersFile
.
Set
(
sNtDllInterceptor
"
NtFlushBuffersFile
"
&
InterposedNtFlushBuffersFile
)
;
gOriginalNtQueryFullAttributesFile
.
Set
(
sNtDllInterceptor
"
NtQueryFullAttributesFile
"
&
InterposedNtQueryFullAttributesFile
)
;
}
void
ClearPoisonIOInterposer
(
)
{
MOZ_ASSERT
(
false
"
Never
called
!
See
bug
1647107
"
)
;
if
(
sIOPoisoned
)
{
sIOPoisoned
=
false
;
sNtDllInterceptor
.
Clear
(
)
;
sHandleToFilenameCache
-
>
Clear
(
)
;
}
}
}
