#
include
"
PoisonIOInterposer
.
h
"
#
include
<
algorithm
>
#
include
<
stdio
.
h
>
#
include
<
vector
>
#
include
<
io
.
h
>
#
include
<
windows
.
h
>
#
include
<
winternl
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
FileUtilsWin
.
h
"
#
include
"
mozilla
/
IOInterposer
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWindowsDllInterceptor
.
h
"
#
include
"
plstr
.
h
"
#
ifdef
MOZ_REPLACE_MALLOC
#
include
"
replace_malloc_bridge
.
h
"
#
endif
namespace
{
static
bool
sIOPoisoned
=
false
;
typedef
NTSTATUS
(
NTAPI
*
NtCreateFileFn
)
(
PHANDLE
aFileHandle
ACCESS_MASK
aDesiredAccess
POBJECT_ATTRIBUTES
aObjectAttributes
PIO_STATUS_BLOCK
aIoStatusBlock
PLARGE_INTEGER
aAllocationSize
ULONG
aFileAttributes
ULONG
aShareAccess
ULONG
aCreateDisposition
ULONG
aCreateOptions
PVOID
aEaBuffer
ULONG
aEaLength
)
;
typedef
NTSTATUS
(
NTAPI
*
NtReadFileFn
)
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
PVOID
aBuffer
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
;
typedef
NTSTATUS
(
NTAPI
*
NtReadFileScatterFn
)
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
FILE_SEGMENT_ELEMENT
*
aSegments
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
;
typedef
NTSTATUS
(
NTAPI
*
NtWriteFileFn
)
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
PVOID
aBuffer
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
;
typedef
NTSTATUS
(
NTAPI
*
NtWriteFileGatherFn
)
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
FILE_SEGMENT_ELEMENT
*
aSegments
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
;
typedef
NTSTATUS
(
NTAPI
*
NtFlushBuffersFileFn
)
(
HANDLE
aFileHandle
PIO_STATUS_BLOCK
aIoStatusBlock
)
;
typedef
struct
_FILE_NETWORK_OPEN_INFORMATION
*
PFILE_NETWORK_OPEN_INFORMATION
;
typedef
NTSTATUS
(
NTAPI
*
NtQueryFullAttributesFileFn
)
(
POBJECT_ATTRIBUTES
aObjectAttributes
PFILE_NETWORK_OPEN_INFORMATION
aFileInformation
)
;
template
<
typename
Key
typename
Value
unsigned
LRUCapacity
>
class
LRUCache
{
public
:
static_assert
(
std
:
:
is_default_constructible_v
<
Key
>
)
;
static_assert
(
std
:
:
is_trivially_constructible_v
<
Key
>
)
;
static_assert
(
std
:
:
is_trivially_copyable_v
<
Key
>
)
;
static_assert
(
std
:
:
is_default_constructible_v
<
Value
>
)
;
static_assert
(
LRUCapacity
<
=
1024
"
This
seems
a
bit
big
is
this
the
right
cache
for
your
use
?
"
)
;
void
Clear
(
)
{
mozilla
:
:
MutexAutoLock
lock
(
mMutex
)
;
for
(
KeyAndValue
*
item
=
&
mLRUArray
[
0
]
;
item
!
=
&
mLRUArray
[
mSize
]
;
+
+
item
)
{
item
-
>
mValue
=
Value
{
}
;
}
mSize
=
0
;
}
template
<
typename
ToValue
>
void
Add
(
Key
aKey
ToValue
&
&
aValue
)
{
mozilla
:
:
MutexAutoLock
lock
(
mMutex
)
;
KeyAndValue
*
const
item0
=
&
mLRUArray
[
0
]
;
mSize
=
std
:
:
min
(
mSize
+
1
LRUCapacity
)
;
if
(
MOZ_LIKELY
(
mSize
!
=
1
)
)
{
std
:
:
move_backward
(
item0
item0
+
mSize
-
1
item0
+
mSize
)
;
}
item0
-
>
mKey
=
aKey
;
item0
-
>
mValue
=
std
:
:
forward
<
ToValue
>
(
aValue
)
;
return
;
}
template
<
typename
ValueFunction
>
Value
FetchOrAdd
(
Key
aKey
ValueFunction
&
&
aValueFunction
)
{
Value
value
;
mozilla
:
:
MutexAutoLock
lock
(
mMutex
)
;
KeyAndValue
*
const
item0
=
&
mLRUArray
[
0
]
;
if
(
MOZ_UNLIKELY
(
mSize
=
=
0
)
)
{
value
=
std
:
:
forward
<
ValueFunction
>
(
aValueFunction
)
(
)
;
item0
-
>
mKey
=
aKey
;
item0
-
>
mValue
=
value
;
return
value
;
}
if
(
MOZ_LIKELY
(
item0
-
>
mKey
=
=
aKey
)
)
{
#
ifdef
LRUCACHE_STATS
+
+
mCacheFoundAt
[
0
]
;
#
endif
value
=
item0
-
>
mValue
;
return
value
;
}
for
(
KeyAndValue
*
item
=
item0
+
1
;
item
!
=
item0
+
mSize
;
+
+
item
)
{
if
(
item
-
>
mKey
=
=
aKey
)
{
#
ifdef
LRUCACHE_STATS
+
+
mCacheFoundAt
[
unsigned
(
item
-
item0
)
]
;
#
endif
value
=
item
-
>
mValue
;
std
:
:
rotate
(
item0
item
item
+
1
)
;
return
value
;
}
}
#
ifdef
LRUCACHE_STATS
+
+
mCacheFoundAt
[
LRUCapacity
]
;
#
endif
{
mozilla
:
:
MutexAutoUnlock
unlock
(
mMutex
)
;
value
=
std
:
:
forward
<
ValueFunction
>
(
aValueFunction
)
(
)
;
}
mSize
=
std
:
:
min
(
mSize
+
1
LRUCapacity
)
;
std
:
:
move_backward
(
item0
item0
+
mSize
-
1
item0
+
mSize
)
;
item0
-
>
mKey
=
aKey
;
item0
-
>
mValue
=
value
;
return
value
;
}
#
ifdef
LRUCACHE_STATS
~
LRUCache
(
)
{
if
(
mSize
!
=
0
)
{
fprintf
(
stderr
"
*
*
*
*
*
LRUCache
stats
:
(
position
-
>
hit
count
)
\
n
"
)
;
for
(
unsigned
i
=
0
;
i
<
mSize
;
+
+
i
)
{
fprintf
(
stderr
"
*
*
*
*
*
%
3u
-
>
%
6u
\
n
"
i
mCacheFoundAt
[
i
]
)
;
}
fprintf
(
stderr
"
*
*
*
*
*
not
found
-
>
%
6u
\
n
"
mCacheFoundAt
[
LRUCapacity
]
)
;
}
}
#
endif
private
:
struct
KeyAndValue
{
Key
mKey
;
Value
mValue
;
KeyAndValue
(
)
=
default
;
KeyAndValue
(
KeyAndValue
&
&
)
=
default
;
KeyAndValue
&
operator
=
(
KeyAndValue
&
&
)
=
default
;
}
;
mozilla
:
:
Mutex
mMutex
{
"
LRU
cache
"
}
;
unsigned
mSize
=
0
;
KeyAndValue
mLRUArray
[
LRUCapacity
]
;
#
ifdef
LRUCACHE_STATS
unsigned
mCacheFoundAt
[
LRUCapacity
+
1
]
=
{
0u
}
;
#
endif
}
;
using
HandleToFilenameCache
=
LRUCache
<
HANDLE
nsString
32
>
;
static
mozilla
:
:
UniquePtr
<
HandleToFilenameCache
>
sHandleToFilenameCache
;
class
WinIOAutoObservation
:
public
mozilla
:
:
IOInterposeObserver
:
:
Observation
{
public
:
WinIOAutoObservation
(
mozilla
:
:
IOInterposeObserver
:
:
Operation
aOp
HANDLE
aFileHandle
const
LARGE_INTEGER
*
aOffset
)
:
mozilla
:
:
IOInterposeObserver
:
:
Observation
(
aOp
sReference
!
mozilla
:
:
IsDebugFile
(
reinterpret_cast
<
intptr_t
>
(
aFileHandle
)
)
)
mFileHandle
(
aFileHandle
)
mHasQueriedFilename
(
false
)
{
if
(
mShouldReport
)
{
mOffset
.
QuadPart
=
aOffset
?
aOffset
-
>
QuadPart
:
0
;
}
}
WinIOAutoObservation
(
mozilla
:
:
IOInterposeObserver
:
:
Operation
aOp
nsAString
&
aFilename
)
:
mozilla
:
:
IOInterposeObserver
:
:
Observation
(
aOp
sReference
)
mFileHandle
(
nullptr
)
mHasQueriedFilename
(
false
)
{
if
(
mShouldReport
)
{
nsAutoString
dosPath
;
if
(
mozilla
:
:
NtPathToDosPath
(
aFilename
dosPath
)
)
{
mFilename
=
dosPath
;
}
else
{
mFilename
=
aFilename
;
}
mHasQueriedFilename
=
true
;
mOffset
.
QuadPart
=
0
;
}
}
void
SetHandle
(
HANDLE
aFileHandle
)
{
mFileHandle
=
aFileHandle
;
if
(
aFileHandle
&
&
mHasQueriedFilename
)
{
sHandleToFilenameCache
-
>
Add
(
aFileHandle
mFilename
)
;
}
}
void
Filename
(
nsAString
&
aFilename
)
override
;
~
WinIOAutoObservation
(
)
{
Report
(
)
;
}
private
:
HANDLE
mFileHandle
;
LARGE_INTEGER
mOffset
;
bool
mHasQueriedFilename
;
nsString
mFilename
;
static
const
char
*
sReference
;
}
;
const
char
*
WinIOAutoObservation
:
:
sReference
=
"
PoisonIOInterposer
"
;
void
WinIOAutoObservation
:
:
Filename
(
nsAString
&
aFilename
)
{
if
(
mHasQueriedFilename
)
{
aFilename
=
mFilename
;
return
;
}
if
(
mFileHandle
)
{
mFilename
=
sHandleToFilenameCache
-
>
FetchOrAdd
(
mFileHandle
[
&
]
(
)
{
nsString
filename
;
if
(
!
mozilla
:
:
HandleToFilename
(
mFileHandle
mOffset
filename
)
)
{
filename
.
Truncate
(
)
;
}
return
filename
;
}
)
;
}
mHasQueriedFilename
=
true
;
aFilename
=
mFilename
;
}
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtCreateFileFn
>
gOriginalNtCreateFile
;
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtReadFileFn
>
gOriginalNtReadFile
;
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtReadFileScatterFn
>
gOriginalNtReadFileScatter
;
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtWriteFileFn
>
gOriginalNtWriteFile
;
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtWriteFileGatherFn
>
gOriginalNtWriteFileGather
;
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtFlushBuffersFileFn
>
gOriginalNtFlushBuffersFile
;
static
mozilla
:
:
WindowsDllInterceptor
:
:
FuncHookType
<
NtQueryFullAttributesFileFn
>
gOriginalNtQueryFullAttributesFile
;
static
NTSTATUS
NTAPI
InterposedNtCreateFile
(
PHANDLE
aFileHandle
ACCESS_MASK
aDesiredAccess
POBJECT_ATTRIBUTES
aObjectAttributes
PIO_STATUS_BLOCK
aIoStatusBlock
PLARGE_INTEGER
aAllocationSize
ULONG
aFileAttributes
ULONG
aShareAccess
ULONG
aCreateDisposition
ULONG
aCreateOptions
PVOID
aEaBuffer
ULONG
aEaLength
)
{
const
wchar_t
*
buf
=
aObjectAttributes
?
aObjectAttributes
-
>
ObjectName
-
>
Buffer
:
L
"
"
;
uint32_t
len
=
aObjectAttributes
?
aObjectAttributes
-
>
ObjectName
-
>
Length
/
sizeof
(
WCHAR
)
:
0
;
nsDependentSubstring
filename
(
buf
len
)
;
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpCreateOrOpen
filename
)
;
MOZ_ASSERT
(
gOriginalNtCreateFile
)
;
NTSTATUS
status
=
gOriginalNtCreateFile
(
aFileHandle
aDesiredAccess
aObjectAttributes
aIoStatusBlock
aAllocationSize
aFileAttributes
aShareAccess
aCreateDisposition
aCreateOptions
aEaBuffer
aEaLength
)
;
timer
.
SetHandle
(
*
aFileHandle
)
;
return
status
;
}
static
NTSTATUS
NTAPI
InterposedNtReadFile
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
PVOID
aBuffer
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
{
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpRead
aFileHandle
aOffset
)
;
MOZ_ASSERT
(
gOriginalNtReadFile
)
;
return
gOriginalNtReadFile
(
aFileHandle
aEvent
aApc
aApcCtx
aIoStatus
aBuffer
aLength
aOffset
aKey
)
;
}
static
NTSTATUS
NTAPI
InterposedNtReadFileScatter
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
FILE_SEGMENT_ELEMENT
*
aSegments
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
{
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpRead
aFileHandle
aOffset
)
;
MOZ_ASSERT
(
gOriginalNtReadFileScatter
)
;
return
gOriginalNtReadFileScatter
(
aFileHandle
aEvent
aApc
aApcCtx
aIoStatus
aSegments
aLength
aOffset
aKey
)
;
}
static
NTSTATUS
NTAPI
InterposedNtWriteFile
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
PVOID
aBuffer
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
{
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpWrite
aFileHandle
aOffset
)
;
MOZ_ASSERT
(
gOriginalNtWriteFile
)
;
return
gOriginalNtWriteFile
(
aFileHandle
aEvent
aApc
aApcCtx
aIoStatus
aBuffer
aLength
aOffset
aKey
)
;
}
static
NTSTATUS
NTAPI
InterposedNtWriteFileGather
(
HANDLE
aFileHandle
HANDLE
aEvent
PIO_APC_ROUTINE
aApc
PVOID
aApcCtx
PIO_STATUS_BLOCK
aIoStatus
FILE_SEGMENT_ELEMENT
*
aSegments
ULONG
aLength
PLARGE_INTEGER
aOffset
PULONG
aKey
)
{
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpWrite
aFileHandle
aOffset
)
;
MOZ_ASSERT
(
gOriginalNtWriteFileGather
)
;
return
gOriginalNtWriteFileGather
(
aFileHandle
aEvent
aApc
aApcCtx
aIoStatus
aSegments
aLength
aOffset
aKey
)
;
}
static
NTSTATUS
NTAPI
InterposedNtFlushBuffersFile
(
HANDLE
aFileHandle
PIO_STATUS_BLOCK
aIoStatusBlock
)
{
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpFSync
aFileHandle
nullptr
)
;
MOZ_ASSERT
(
gOriginalNtFlushBuffersFile
)
;
return
gOriginalNtFlushBuffersFile
(
aFileHandle
aIoStatusBlock
)
;
}
static
NTSTATUS
NTAPI
InterposedNtQueryFullAttributesFile
(
POBJECT_ATTRIBUTES
aObjectAttributes
PFILE_NETWORK_OPEN_INFORMATION
aFileInformation
)
{
const
wchar_t
*
buf
=
aObjectAttributes
?
aObjectAttributes
-
>
ObjectName
-
>
Buffer
:
L
"
"
;
uint32_t
len
=
aObjectAttributes
?
aObjectAttributes
-
>
ObjectName
-
>
Length
/
sizeof
(
WCHAR
)
:
0
;
nsDependentSubstring
filename
(
buf
len
)
;
WinIOAutoObservation
timer
(
mozilla
:
:
IOInterposeObserver
:
:
OpStat
filename
)
;
MOZ_ASSERT
(
gOriginalNtQueryFullAttributesFile
)
;
return
gOriginalNtQueryFullAttributesFile
(
aObjectAttributes
aFileInformation
)
;
}
}
static
mozilla
:
:
WindowsDllInterceptor
sNtDllInterceptor
;
namespace
mozilla
{
void
InitPoisonIOInterposer
(
)
{
if
(
sIOPoisoned
)
{
return
;
}
sIOPoisoned
=
true
;
if
(
!
sHandleToFilenameCache
)
{
sHandleToFilenameCache
=
mozilla
:
:
MakeUnique
<
HandleToFilenameCache
>
(
)
;
mozilla
:
:
ClearOnShutdown
(
&
sHandleToFilenameCache
)
;
}
MozillaRegisterDebugFD
(
1
)
;
MozillaRegisterDebugFD
(
2
)
;
#
ifdef
MOZ_REPLACE_MALLOC
static
DebugFdRegistry
registry
;
ReplaceMalloc
:
:
InitDebugFd
(
registry
)
;
#
endif
sNtDllInterceptor
.
Init
(
"
ntdll
.
dll
"
)
;
gOriginalNtCreateFile
.
Set
(
sNtDllInterceptor
"
NtCreateFile
"
&
InterposedNtCreateFile
)
;
gOriginalNtReadFile
.
Set
(
sNtDllInterceptor
"
NtReadFile
"
&
InterposedNtReadFile
)
;
gOriginalNtReadFileScatter
.
Set
(
sNtDllInterceptor
"
NtReadFileScatter
"
&
InterposedNtReadFileScatter
)
;
gOriginalNtWriteFile
.
Set
(
sNtDllInterceptor
"
NtWriteFile
"
&
InterposedNtWriteFile
)
;
gOriginalNtWriteFileGather
.
Set
(
sNtDllInterceptor
"
NtWriteFileGather
"
&
InterposedNtWriteFileGather
)
;
gOriginalNtFlushBuffersFile
.
Set
(
sNtDllInterceptor
"
NtFlushBuffersFile
"
&
InterposedNtFlushBuffersFile
)
;
gOriginalNtQueryFullAttributesFile
.
Set
(
sNtDllInterceptor
"
NtQueryFullAttributesFile
"
&
InterposedNtQueryFullAttributesFile
)
;
}
void
ClearPoisonIOInterposer
(
)
{
MOZ_ASSERT
(
false
)
;
if
(
sIOPoisoned
)
{
sIOPoisoned
=
false
;
sNtDllInterceptor
.
Clear
(
)
;
sHandleToFilenameCache
-
>
Clear
(
)
;
}
}
}
