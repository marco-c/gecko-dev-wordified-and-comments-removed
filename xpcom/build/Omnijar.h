#
ifndef
mozilla_Omnijar_h
#
define
mozilla_Omnijar_h
#
include
"
nscore
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsZipArchive
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
class
CacheAwareZipReader
;
class
Omnijar
{
private
:
static
StaticRefPtr
<
nsIFile
>
sPath
[
2
]
;
static
StaticRefPtr
<
CacheAwareZipReader
>
sReader
[
2
]
;
static
StaticRefPtr
<
CacheAwareZipReader
>
sOuterReader
[
2
]
;
static
bool
sInitialized
;
static
bool
sIsUnified
;
public
:
enum
Type
{
GRE
=
0
APP
=
1
}
;
private
:
static
inline
bool
IsNested
(
Type
aType
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
Omnijar
not
initialized
"
)
;
return
!
!
sOuterReader
[
aType
]
;
}
static
inline
already_AddRefed
<
CacheAwareZipReader
>
GetOuterReader
(
Type
aType
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
Omnijar
not
initialized
"
)
;
RefPtr
<
CacheAwareZipReader
>
reader
=
sOuterReader
[
aType
]
.
get
(
)
;
return
reader
.
forget
(
)
;
}
public
:
static
inline
bool
IsInitialized
(
)
{
return
sInitialized
;
}
static
void
Init
(
nsIFile
*
aGrePath
=
nullptr
nsIFile
*
aAppPath
=
nullptr
)
;
static
void
CleanUp
(
)
;
static
inline
already_AddRefed
<
nsIFile
>
GetPath
(
Type
aType
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
Omnijar
not
initialized
"
)
;
nsCOMPtr
<
nsIFile
>
path
=
sPath
[
aType
]
.
get
(
)
;
return
path
.
forget
(
)
;
}
static
inline
bool
HasOmnijar
(
Type
aType
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
Omnijar
not
initialized
"
)
;
return
!
!
sPath
[
aType
]
;
}
static
inline
already_AddRefed
<
CacheAwareZipReader
>
GetReader
(
Type
aType
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
Omnijar
not
initialized
"
)
;
RefPtr
<
CacheAwareZipReader
>
reader
=
sReader
[
aType
]
.
get
(
)
;
return
reader
.
forget
(
)
;
}
static
already_AddRefed
<
CacheAwareZipReader
>
GetReader
(
nsIFile
*
aPath
)
;
static
already_AddRefed
<
CacheAwareZipReader
>
GetInnerReader
(
nsIFile
*
aPath
const
nsACString
&
aEntry
)
;
static
nsresult
GetURIString
(
Type
aType
nsACString
&
aResult
)
;
private
:
static
void
InitOne
(
nsIFile
*
aPath
Type
aType
)
;
static
void
CleanUpOne
(
Type
aType
)
;
}
;
class
CacheAwareZipCursor
{
public
:
CacheAwareZipCursor
(
nsZipItem
*
aItem
CacheAwareZipReader
*
aReader
uint8_t
*
aBuf
=
nullptr
uint32_t
aBufSize
=
0
bool
aDoCRC
=
false
)
;
uint8_t
*
Read
(
uint32_t
*
aBytesRead
)
{
return
ReadOrCopy
(
aBytesRead
false
)
;
}
uint8_t
*
Copy
(
uint32_t
*
aBytesRead
)
{
return
ReadOrCopy
(
aBytesRead
true
)
;
}
private
:
uint8_t
*
ReadOrCopy
(
uint32_t
*
aBytesRead
bool
aCopy
)
;
nsZipItem
*
mItem
;
CacheAwareZipReader
*
mReader
;
uint8_t
*
mBuf
;
uint32_t
mBufSize
;
bool
mDoCRC
;
}
;
class
CacheAwareZipHandle
{
friend
class
CacheAwareZipReader
;
public
:
CacheAwareZipHandle
(
)
:
mFd
(
nullptr
)
mDataIsCached
(
false
)
{
}
~
CacheAwareZipHandle
(
)
{
ReleaseHandle
(
)
;
}
nsZipHandle
*
UnderlyingFD
(
)
{
return
mFd
;
}
void
ReleaseHandle
(
)
;
explicit
operator
bool
(
)
const
{
return
mDataIsCached
|
|
mFd
;
}
private
:
RefPtr
<
nsZipHandle
>
mFd
;
nsCString
mDeferredCachingKey
;
Span
<
const
uint8_t
>
mDataToCache
;
bool
mDataIsCached
;
}
;
class
CacheAwareZipReader
{
friend
class
CacheAwareZipCursor
;
friend
class
CacheAwareZipHandle
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CacheAwareZipReader
)
enum
Caching
{
Default
DeferCaching
}
;
explicit
CacheAwareZipReader
(
nsZipArchive
*
aZip
const
char
*
aCacheKeyPrefix
)
;
CacheAwareZipReader
(
)
:
mZip
(
new
nsZipArchive
(
)
)
{
}
nsresult
OpenArchive
(
nsIFile
*
aFile
)
{
return
mZip
-
>
OpenArchive
(
aFile
)
;
}
nsresult
OpenArchive
(
nsZipHandle
*
aHandle
)
{
return
mZip
-
>
OpenArchive
(
aHandle
)
;
}
const
uint8_t
*
GetData
(
const
char
*
aEntryName
uint32_t
*
aResultSize
Caching
aCaching
=
Default
)
;
const
uint8_t
*
GetData
(
nsZipItem
*
aItem
Caching
aCaching
=
Default
)
;
nsresult
GetPersistentHandle
(
nsZipItem
*
aItem
CacheAwareZipHandle
*
aHandle
Caching
aCaching
)
;
already_AddRefed
<
nsIFile
>
GetBaseFile
(
)
{
return
mZip
-
>
GetBaseFile
(
)
;
}
void
GetURIString
(
nsACString
&
result
)
{
mZip
-
>
GetURIString
(
result
)
;
}
nsZipArchive
*
GetZipArchive
(
)
{
return
mZip
;
}
nsresult
FindInit
(
const
char
*
aPattern
nsZipFind
*
*
aFind
)
;
bool
IsForZip
(
nsZipArchive
*
aArchive
)
{
return
aArchive
=
=
mZip
;
}
nsZipItem
*
GetItem
(
const
char
*
aEntryName
)
;
nsresult
CloseArchive
(
)
;
nsresult
Test
(
const
char
*
aEntryName
)
{
return
mZip
-
>
Test
(
aEntryName
)
;
}
nsresult
ExtractFile
(
nsZipItem
*
zipEntry
nsIFile
*
outFile
PRFileDesc
*
outFD
)
{
return
mZip
-
>
ExtractFile
(
zipEntry
outFile
outFD
)
;
}
static
void
PushSuspendStartupCacheWrites
(
)
;
static
void
PopSuspendStartupCacheWrites
(
)
;
protected
:
~
CacheAwareZipReader
(
)
=
default
;
private
:
const
uint8_t
*
GetCachedBuffer
(
const
char
*
aEntryName
uint32_t
aEntryNameLength
uint32_t
*
aResultSize
nsCString
&
aCacheKey
)
;
static
void
PutBufferIntoCache
(
const
nsCString
&
aCacheKey
const
uint8_t
*
aBuffer
uint32_t
aSize
)
;
RefPtr
<
nsZipArchive
>
mZip
;
nsCString
mCacheKeyPrefix
;
}
;
class
MOZ_RAII
AutoSuspendStartupCacheWrites
{
public
:
AutoSuspendStartupCacheWrites
(
)
{
CacheAwareZipReader
:
:
PushSuspendStartupCacheWrites
(
)
;
}
~
AutoSuspendStartupCacheWrites
(
)
{
CacheAwareZipReader
:
:
PopSuspendStartupCacheWrites
(
)
;
}
}
;
}
#
endif
