#
ifndef
SmallArrayLRUCache_h
#
define
SmallArrayLRUCache_h
#
include
"
mozilla
/
Mutex
.
h
"
#
include
<
algorithm
>
#
include
<
type_traits
>
#
include
<
utility
>
#
ifdef
SMALLARRAYLRUCACHE_STATS
#
include
<
cstdio
>
#
endif
namespace
mozilla
{
template
<
typename
Key
typename
Value
unsigned
LRUCapacity
>
class
SmallArrayLRUCache
{
public
:
static_assert
(
std
:
:
is_default_constructible_v
<
Key
>
)
;
static_assert
(
std
:
:
is_trivially_constructible_v
<
Key
>
)
;
static_assert
(
std
:
:
is_trivially_copyable_v
<
Key
>
)
;
static_assert
(
std
:
:
is_default_constructible_v
<
Value
>
)
;
static_assert
(
LRUCapacity
>
=
2
)
;
static_assert
(
LRUCapacity
<
=
1024
"
This
seems
a
bit
big
is
this
the
right
cache
for
your
use
?
"
)
;
void
Clear
(
)
{
mozilla
:
:
OffTheBooksMutexAutoLock
lock
(
mMutex
)
;
if
(
mSize
=
=
ShutdownSize
)
{
return
;
}
Clear
(
lock
)
;
}
void
Shutdown
(
)
{
mozilla
:
:
OffTheBooksMutexAutoLock
lock
(
mMutex
)
;
if
(
mSize
=
=
ShutdownSize
)
{
return
;
}
Clear
(
lock
)
;
mSize
=
ShutdownSize
;
}
template
<
typename
ToValue
>
void
Add
(
Key
aKey
ToValue
&
&
aValue
)
{
mozilla
:
:
OffTheBooksMutexAutoLock
lock
(
mMutex
)
;
if
(
mSize
=
=
ShutdownSize
)
{
return
;
}
KeyAndValue
*
const
item0
=
&
mLRUArray
[
0
]
;
mSize
=
std
:
:
min
(
mSize
+
1
LRUCapacity
)
;
if
(
MOZ_LIKELY
(
mSize
!
=
1
)
)
{
std
:
:
move_backward
(
item0
item0
+
mSize
-
1
item0
+
mSize
)
;
}
item0
-
>
mKey
=
aKey
;
item0
-
>
mValue
=
std
:
:
forward
<
ToValue
>
(
aValue
)
;
return
;
}
template
<
typename
ValueFunction
>
Value
FetchOrAdd
(
Key
aKey
ValueFunction
&
&
aValueFunction
)
{
Value
value
;
mozilla
:
:
OffTheBooksMutexAutoLock
lock
(
mMutex
)
;
if
(
mSize
=
=
ShutdownSize
)
{
value
=
std
:
:
forward
<
ValueFunction
>
(
aValueFunction
)
(
)
;
return
value
;
}
KeyAndValue
*
const
item0
=
&
mLRUArray
[
0
]
;
if
(
MOZ_UNLIKELY
(
mSize
=
=
0
)
)
{
value
=
std
:
:
forward
<
ValueFunction
>
(
aValueFunction
)
(
)
;
item0
-
>
mKey
=
aKey
;
item0
-
>
mValue
=
value
;
mSize
=
1
;
return
value
;
}
if
(
MOZ_LIKELY
(
item0
-
>
mKey
=
=
aKey
)
)
{
#
ifdef
SMALLARRAYLRUCACHE_STATS
+
+
mCacheFoundAt
[
0
]
;
#
endif
value
=
item0
-
>
mValue
;
return
value
;
}
for
(
KeyAndValue
*
item
=
item0
+
1
;
item
!
=
item0
+
mSize
;
+
+
item
)
{
if
(
item
-
>
mKey
=
=
aKey
)
{
#
ifdef
SMALLARRAYLRUCACHE_STATS
+
+
mCacheFoundAt
[
unsigned
(
item
-
item0
)
]
;
#
endif
value
=
item
-
>
mValue
;
std
:
:
rotate
(
item0
item
item
+
1
)
;
return
value
;
}
}
#
ifdef
SMALLARRAYLRUCACHE_STATS
+
+
mCacheFoundAt
[
LRUCapacity
]
;
#
endif
{
mozilla
:
:
OffTheBooksMutexAutoUnlock
unlock
(
mMutex
)
;
value
=
std
:
:
forward
<
ValueFunction
>
(
aValueFunction
)
(
)
;
}
mSize
=
std
:
:
min
(
mSize
+
1
LRUCapacity
)
;
std
:
:
move_backward
(
item0
item0
+
mSize
-
1
item0
+
mSize
)
;
item0
-
>
mKey
=
aKey
;
item0
-
>
mValue
=
value
;
return
value
;
}
#
ifdef
SMALLARRAYLRUCACHE_STATS
~
SmallArrayLRUCache
(
)
{
if
(
mSize
!
=
0
&
&
mSize
!
=
ShutdownSize
)
{
fprintf
(
stderr
"
*
*
*
*
*
SmallArrayLRUCache
stats
:
(
position
-
>
hit
count
)
\
n
"
)
;
for
(
unsigned
i
=
0
;
i
<
mSize
;
+
+
i
)
{
fprintf
(
stderr
"
*
*
*
*
*
%
3u
-
>
%
6u
\
n
"
i
mCacheFoundAt
[
i
]
)
;
}
fprintf
(
stderr
"
*
*
*
*
*
not
found
-
>
%
6u
\
n
"
mCacheFoundAt
[
LRUCapacity
]
)
;
}
}
#
endif
private
:
void
Clear
(
const
mozilla
:
:
OffTheBooksMutexAutoLock
&
)
REQUIRES
(
mMutex
)
{
for
(
KeyAndValue
*
item
=
&
mLRUArray
[
0
]
;
item
!
=
&
mLRUArray
[
mSize
]
;
+
+
item
)
{
item
-
>
mValue
=
Value
{
}
;
}
mSize
=
0
;
}
struct
KeyAndValue
{
Key
mKey
;
Value
mValue
;
KeyAndValue
(
)
=
default
;
KeyAndValue
(
KeyAndValue
&
&
)
=
default
;
KeyAndValue
&
operator
=
(
KeyAndValue
&
&
)
=
default
;
}
;
constexpr
static
unsigned
ShutdownSize
=
unsigned
(
-
1
)
;
mozilla
:
:
OffTheBooksMutex
mMutex
{
"
LRU
cache
"
}
;
unsigned
mSize
GUARDED_BY
(
mMutex
)
=
0
;
KeyAndValue
mLRUArray
[
LRUCapacity
]
GUARDED_BY
(
mMutex
)
;
#
ifdef
SMALLARRAYLRUCACHE_STATS
unsigned
mCacheFoundAt
[
LRUCapacity
+
1
]
GUARDED_BY
(
mMutex
)
=
{
0u
}
;
#
endif
}
;
}
#
endif
