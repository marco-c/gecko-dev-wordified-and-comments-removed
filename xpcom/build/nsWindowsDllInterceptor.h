#
ifndef
NS_WINDOWS_DLL_INTERCEPTOR_H_
#
define
NS_WINDOWS_DLL_INTERCEPTOR_H_
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
<
wchar
.
h
>
#
include
<
windows
.
h
>
#
include
<
winternl
.
h
>
#
include
<
stdint
.
h
>
#
define
COPY_CODES
(
NBYTES
)
do
{
\
memcpy
(
&
tramp
[
nTrampBytes
]
&
origBytes
[
nOrigBytes
]
NBYTES
)
;
\
nOrigBytes
+
=
NBYTES
;
\
nTrampBytes
+
=
NBYTES
;
\
}
while
(
0
)
namespace
mozilla
{
namespace
internal
{
class
AutoVirtualProtect
{
public
:
AutoVirtualProtect
(
void
*
aFunc
size_t
aSize
DWORD
aProtect
)
:
mFunc
(
aFunc
)
mSize
(
aSize
)
mNewProtect
(
aProtect
)
mOldProtect
(
0
)
mSuccess
(
false
)
{
}
~
AutoVirtualProtect
(
)
{
if
(
mSuccess
)
{
VirtualProtectEx
(
GetCurrentProcess
(
)
mFunc
mSize
mOldProtect
&
mOldProtect
)
;
}
}
bool
Protect
(
)
{
mSuccess
=
!
!
VirtualProtectEx
(
GetCurrentProcess
(
)
mFunc
mSize
mNewProtect
&
mOldProtect
)
;
return
mSuccess
;
}
private
:
void
*
const
mFunc
;
size_t
const
mSize
;
DWORD
const
mNewProtect
;
DWORD
mOldProtect
;
bool
mSuccess
;
}
;
class
WindowsDllNopSpacePatcher
{
typedef
uint8_t
*
byteptr_t
;
HMODULE
mModule
;
static
const
size_t
maxPatchedFns
=
16
;
byteptr_t
mPatchedFns
[
maxPatchedFns
]
;
int
mPatchedFnsLen
;
public
:
WindowsDllNopSpacePatcher
(
)
:
mModule
(
0
)
mPatchedFnsLen
(
0
)
{
}
#
if
defined
(
_M_IX86
)
~
WindowsDllNopSpacePatcher
(
)
{
for
(
int
i
=
0
;
i
<
mPatchedFnsLen
;
i
+
+
)
{
byteptr_t
fn
=
mPatchedFns
[
i
]
;
AutoVirtualProtect
protect
(
fn
2
PAGE_EXECUTE_READWRITE
)
;
if
(
!
protect
.
Protect
(
)
)
{
continue
;
}
*
(
(
uint16_t
*
)
fn
)
=
0xff8b
;
FlushInstructionCache
(
GetCurrentProcess
(
)
nullptr
0
)
;
}
}
void
Init
(
const
char
*
aModuleName
)
{
if
(
!
IsCompatible
(
)
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
NS_WARNING
(
"
NOP
space
patching
is
unavailable
for
compatibility
reasons
"
)
;
#
endif
return
;
}
mModule
=
LoadLibraryExA
(
aModuleName
nullptr
0
)
;
if
(
!
mModule
)
{
return
;
}
}
static
bool
IsCompatible
(
)
{
const
wchar_t
*
kIncompatibleDLLs
[
]
=
{
L
"
detoured
.
dll
"
L
"
_etoured
.
dll
"
L
"
nvd3d9wrap
.
dll
"
L
"
nvdxgiwrap
.
dll
"
}
;
for
(
unsigned
int
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
kIncompatibleDLLs
)
;
+
+
i
)
{
if
(
GetModuleHandleW
(
kIncompatibleDLLs
[
i
]
)
)
{
return
false
;
}
}
if
(
GetModuleHandleW
(
L
"
user32
.
dll
"
)
)
{
return
true
;
}
HKEY
hkey
=
NULL
;
if
(
!
RegOpenKeyExW
(
HKEY_LOCAL_MACHINE
L
"
SOFTWARE
\
\
Microsoft
\
\
Windows
NT
\
\
CurrentVersion
\
\
Windows
"
0
KEY_QUERY_VALUE
&
hkey
)
)
{
nsAutoRegKey
key
(
hkey
)
;
DWORD
numBytes
=
0
;
const
wchar_t
kAppInitDLLs
[
]
=
L
"
AppInit_DLLs
"
;
LONG
status
=
RegQueryValueExW
(
hkey
kAppInitDLLs
nullptr
nullptr
nullptr
&
numBytes
)
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
data
;
if
(
!
status
)
{
data
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
numBytes
/
sizeof
(
wchar_t
)
)
;
status
=
RegQueryValueExW
(
hkey
kAppInitDLLs
nullptr
nullptr
(
LPBYTE
)
data
.
get
(
)
&
numBytes
)
;
}
if
(
!
status
)
{
const
wchar_t
kDelimiters
[
]
=
L
"
"
;
wchar_t
*
tokenContext
=
nullptr
;
wchar_t
*
token
=
wcstok_s
(
data
.
get
(
)
kDelimiters
&
tokenContext
)
;
while
(
token
)
{
wchar_t
fname
[
_MAX_FNAME
]
=
{
0
}
;
if
(
!
_wsplitpath_s
(
token
nullptr
0
nullptr
0
fname
mozilla
:
:
ArrayLength
(
fname
)
nullptr
0
)
)
{
const
wchar_t
kNvInitName
[
]
=
L
"
nvinit
"
;
if
(
!
_wcsnicmp
(
fname
kNvInitName
mozilla
:
:
ArrayLength
(
kNvInitName
)
)
)
{
return
false
;
}
}
token
=
wcstok_s
(
nullptr
kDelimiters
&
tokenContext
)
;
}
}
}
return
true
;
}
bool
AddHook
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModule
)
{
return
false
;
}
if
(
!
IsCompatible
(
)
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
NS_WARNING
(
"
NOP
space
patching
is
unavailable
for
compatibility
reasons
"
)
;
#
endif
return
false
;
}
MOZ_RELEASE_ASSERT
(
mPatchedFnsLen
<
maxPatchedFns
"
No
room
for
the
hook
"
)
;
byteptr_t
fn
=
reinterpret_cast
<
byteptr_t
>
(
GetProcAddress
(
mModule
aName
)
)
;
if
(
!
fn
)
{
return
false
;
}
fn
=
ResolveRedirectedAddress
(
fn
)
;
AutoVirtualProtect
protectBefore
(
fn
-
5
5
PAGE_EXECUTE_READWRITE
)
;
AutoVirtualProtect
protectAfter
(
fn
2
PAGE_EXECUTE_READWRITE
)
;
if
(
!
protectBefore
.
Protect
(
)
|
|
!
protectAfter
.
Protect
(
)
)
{
return
false
;
}
bool
rv
=
WriteHook
(
fn
aHookDest
aOrigFunc
)
;
if
(
rv
)
{
mPatchedFns
[
mPatchedFnsLen
]
=
fn
;
mPatchedFnsLen
+
+
;
}
return
rv
;
}
bool
WriteHook
(
byteptr_t
aFn
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
for
(
int
i
=
-
5
;
i
<
=
-
1
;
i
+
+
)
{
if
(
aFn
[
i
]
!
=
0x90
&
&
aFn
[
i
]
!
=
0xcc
)
{
return
false
;
}
}
if
(
(
aFn
[
0
]
!
=
0x8b
&
&
aFn
[
0
]
!
=
0x89
)
|
|
aFn
[
1
]
!
=
0xff
)
{
return
false
;
}
aFn
[
-
5
]
=
0xe9
;
*
(
(
intptr_t
*
)
(
aFn
-
4
)
)
=
aHookDest
-
(
uintptr_t
)
(
aFn
)
;
*
aOrigFunc
=
aFn
+
2
;
*
(
(
uint16_t
*
)
(
aFn
)
)
=
0xf9eb
;
FlushInstructionCache
(
GetCurrentProcess
(
)
nullptr
0
)
;
return
true
;
}
private
:
static
byteptr_t
ResolveRedirectedAddress
(
const
byteptr_t
aOriginalFunction
)
{
if
(
aOriginalFunction
[
0
]
=
=
0xeb
)
{
int8_t
offset
=
(
int8_t
)
(
aOriginalFunction
[
1
]
)
;
if
(
offset
<
=
0
)
{
return
aOriginalFunction
;
}
for
(
int8_t
i
=
0
;
i
<
offset
;
i
+
+
)
{
if
(
aOriginalFunction
[
2
+
i
]
!
=
0x90
)
{
return
aOriginalFunction
;
}
}
return
aOriginalFunction
+
2
+
offset
;
}
if
(
aOriginalFunction
[
0
]
=
=
0xff
&
&
aOriginalFunction
[
1
]
=
=
0x25
)
{
return
(
byteptr_t
)
(
*
*
(
(
uint32_t
*
*
)
(
aOriginalFunction
+
2
)
)
)
;
}
return
aOriginalFunction
;
}
#
else
void
Init
(
const
char
*
aModuleName
)
{
}
bool
AddHook
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
return
false
;
}
#
endif
}
;
class
WindowsDllDetourPatcher
{
typedef
unsigned
char
*
byteptr_t
;
public
:
WindowsDllDetourPatcher
(
)
:
mModule
(
0
)
mHookPage
(
0
)
mMaxHooks
(
0
)
mCurHooks
(
0
)
{
}
~
WindowsDllDetourPatcher
(
)
{
int
i
;
byteptr_t
p
;
for
(
i
=
0
p
=
mHookPage
;
i
<
mCurHooks
;
i
+
+
p
+
=
kHookSize
)
{
#
if
defined
(
_M_IX86
)
size_t
nBytes
=
1
+
sizeof
(
intptr_t
)
;
#
elif
defined
(
_M_X64
)
size_t
nBytes
=
2
+
sizeof
(
intptr_t
)
;
#
else
#
error
"
Unknown
processor
type
"
#
endif
byteptr_t
origBytes
=
*
(
(
byteptr_t
*
)
p
)
;
AutoVirtualProtect
protect
(
origBytes
nBytes
PAGE_EXECUTE_READWRITE
)
;
if
(
!
protect
.
Protect
(
)
)
{
continue
;
}
intptr_t
dest
=
(
intptr_t
)
(
p
+
sizeof
(
void
*
)
)
;
#
if
defined
(
_M_IX86
)
*
(
(
intptr_t
*
)
(
origBytes
+
1
)
)
=
dest
-
(
intptr_t
)
(
origBytes
+
5
)
;
#
elif
defined
(
_M_X64
)
*
(
(
intptr_t
*
)
(
origBytes
+
2
)
)
=
dest
;
#
else
#
error
"
Unknown
processor
type
"
#
endif
}
}
void
Init
(
const
char
*
aModuleName
int
aNumHooks
=
0
)
{
if
(
mModule
)
{
return
;
}
mModule
=
LoadLibraryExA
(
aModuleName
nullptr
0
)
;
if
(
!
mModule
)
{
return
;
}
int
hooksPerPage
=
4096
/
kHookSize
;
if
(
aNumHooks
=
=
0
)
{
aNumHooks
=
hooksPerPage
;
}
mMaxHooks
=
aNumHooks
+
(
hooksPerPage
%
aNumHooks
)
;
mHookPage
=
(
byteptr_t
)
VirtualAllocEx
(
GetCurrentProcess
(
)
nullptr
mMaxHooks
*
kHookSize
MEM_COMMIT
|
MEM_RESERVE
PAGE_EXECUTE_READWRITE
)
;
if
(
!
mHookPage
)
{
mModule
=
0
;
return
;
}
}
bool
Initialized
(
)
{
return
!
!
mModule
;
}
void
LockHooks
(
)
{
if
(
!
mModule
)
{
return
;
}
DWORD
op
;
VirtualProtectEx
(
GetCurrentProcess
(
)
mHookPage
mMaxHooks
*
kHookSize
PAGE_EXECUTE_READ
&
op
)
;
mModule
=
0
;
}
bool
AddHook
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModule
)
{
return
false
;
}
void
*
pAddr
=
(
void
*
)
GetProcAddress
(
mModule
aName
)
;
if
(
!
pAddr
)
{
return
false
;
}
pAddr
=
ResolveRedirectedAddress
(
(
byteptr_t
)
pAddr
)
;
CreateTrampoline
(
pAddr
aHookDest
aOrigFunc
)
;
if
(
!
*
aOrigFunc
)
{
return
false
;
}
return
true
;
}
protected
:
const
static
int
kPageSize
=
4096
;
const
static
int
kHookSize
=
128
;
HMODULE
mModule
;
byteptr_t
mHookPage
;
int
mMaxHooks
;
int
mCurHooks
;
static
const
BYTE
kMaskHighNibble
=
0xF0
;
static
const
BYTE
kRexOpcode
=
0x40
;
static
const
BYTE
kMaskRexW
=
0x08
;
static
const
BYTE
kMaskRexR
=
0x04
;
static
const
BYTE
kMaskRexX
=
0x02
;
static
const
BYTE
kMaskRexB
=
0x01
;
static
const
BYTE
kRegFieldShift
=
3
;
static
const
BYTE
kMaskMod
=
0xC0
;
static
const
BYTE
kMaskReg
=
0x38
;
static
const
BYTE
kMaskRm
=
0x07
;
static
const
BYTE
kRmNeedSib
=
0x04
;
static
const
BYTE
kModReg
=
0xC0
;
static
const
BYTE
kModDisp32
=
0x80
;
static
const
BYTE
kModDisp8
=
0x40
;
static
const
BYTE
kModNoRegDisp
=
0x00
;
static
const
BYTE
kRmNoRegDispDisp32
=
0x05
;
static
const
BYTE
kMaskSibScale
=
0xC0
;
static
const
BYTE
kMaskSibIndex
=
0x38
;
static
const
BYTE
kMaskSibBase
=
0x07
;
static
const
BYTE
kSibBaseEbp
=
0x05
;
static
const
BYTE
kRegAx
=
0x0
;
static
const
BYTE
kRegCx
=
0x1
;
static
const
BYTE
kRegDx
=
0x2
;
static
const
BYTE
kRegBx
=
0x3
;
static
const
BYTE
kRegSp
=
0x4
;
static
const
BYTE
kRegBp
=
0x5
;
static
const
BYTE
kRegSi
=
0x6
;
static
const
BYTE
kRegDi
=
0x7
;
static
const
int
kModOperand64
=
-
2
;
static
const
int
kModUnknown
=
-
1
;
int
CountModRmSib
(
const
BYTE
*
aModRm
BYTE
*
aSubOpcode
=
nullptr
)
{
if
(
!
aModRm
)
{
MOZ_ASSERT
(
aModRm
"
Missing
ModRM
byte
"
)
;
return
kModUnknown
;
}
int
numBytes
=
1
;
switch
(
*
aModRm
&
kMaskMod
)
{
case
kModReg
:
return
numBytes
;
case
kModDisp8
:
numBytes
+
=
1
;
break
;
case
kModDisp32
:
numBytes
+
=
4
;
break
;
case
kModNoRegDisp
:
if
(
(
*
aModRm
&
kMaskRm
)
=
=
kRmNoRegDispDisp32
)
{
#
if
defined
(
_M_X64
)
if
(
aSubOpcode
)
{
*
aSubOpcode
=
(
*
aModRm
&
kMaskReg
)
>
>
kRegFieldShift
;
}
return
kModOperand64
;
#
else
numBytes
+
=
4
;
#
endif
}
else
if
(
(
(
*
aModRm
&
kMaskRm
)
=
=
kRmNeedSib
&
&
(
*
(
aModRm
+
1
)
&
kMaskSibBase
)
=
=
kSibBaseEbp
)
)
{
numBytes
+
=
4
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Impossible
value
for
modr
/
m
byte
mod
bits
"
)
;
return
kModUnknown
;
}
if
(
(
*
aModRm
&
kMaskRm
)
=
=
kRmNeedSib
)
{
numBytes
+
=
1
;
}
if
(
aSubOpcode
)
{
*
aSubOpcode
=
(
*
aModRm
&
kMaskReg
)
>
>
kRegFieldShift
;
}
return
numBytes
;
}
#
if
defined
(
_M_X64
)
enum
JumpType
{
Je
Jne
Jmp
Call
}
;
struct
JumpPatch
{
JumpPatch
(
)
:
mHookOffset
(
0
)
mJumpAddress
(
0
)
mType
(
JumpType
:
:
Jmp
)
{
}
JumpPatch
(
size_t
aOffset
intptr_t
aAddress
JumpType
aType
=
JumpType
:
:
Jmp
)
:
mHookOffset
(
aOffset
)
mJumpAddress
(
aAddress
)
mType
(
aType
)
{
}
size_t
GenerateJump
(
uint8_t
*
aCode
)
{
size_t
offset
=
mHookOffset
;
if
(
mType
=
=
JumpType
:
:
Je
)
{
aCode
[
offset
]
=
0x75
;
aCode
[
offset
+
1
]
=
14
;
offset
+
=
2
;
}
else
if
(
mType
=
=
JumpType
:
:
Jne
)
{
aCode
[
offset
]
=
0x74
;
aCode
[
offset
+
1
]
=
14
;
offset
+
=
2
;
}
if
(
mType
=
=
JumpType
:
:
Call
)
{
aCode
[
offset
]
=
0xff
;
aCode
[
offset
+
1
]
=
0x15
;
*
reinterpret_cast
<
int32_t
*
>
(
aCode
+
offset
+
2
)
=
2
;
aCode
[
offset
+
2
+
4
]
=
0xeb
;
aCode
[
offset
+
2
+
4
+
1
]
=
8
;
*
reinterpret_cast
<
int64_t
*
>
(
aCode
+
offset
+
2
+
4
+
2
)
=
mJumpAddress
;
return
offset
+
2
+
4
+
2
+
8
;
}
else
{
aCode
[
offset
]
=
0xff
;
aCode
[
offset
+
1
]
=
0x25
;
*
reinterpret_cast
<
int32_t
*
>
(
aCode
+
offset
+
2
)
=
0
;
*
reinterpret_cast
<
int64_t
*
>
(
aCode
+
offset
+
2
+
4
)
=
mJumpAddress
;
return
offset
+
2
+
4
+
8
;
}
}
size_t
mHookOffset
;
intptr_t
mJumpAddress
;
JumpType
mType
;
}
;
#
endif
enum
ePrefixGroupBits
{
eNoPrefixes
=
0
ePrefixGroup1
=
(
1
<
<
0
)
ePrefixGroup2
=
(
1
<
<
1
)
ePrefixGroup3
=
(
1
<
<
2
)
ePrefixGroup4
=
(
1
<
<
3
)
}
;
int
CountPrefixBytes
(
byteptr_t
aBytes
const
int
aBytesIndex
unsigned
char
*
aOutGroupBits
)
{
unsigned
char
&
groupBits
=
*
aOutGroupBits
;
groupBits
=
eNoPrefixes
;
int
index
=
aBytesIndex
;
while
(
true
)
{
switch
(
aBytes
[
index
]
)
{
case
0xF0
:
case
0xF2
:
case
0xF3
:
if
(
groupBits
&
ePrefixGroup1
)
{
return
-
1
;
}
groupBits
|
=
ePrefixGroup1
;
+
+
index
;
break
;
case
0x2E
:
case
0x36
:
case
0x3E
:
case
0x64
:
case
0x65
:
if
(
groupBits
&
ePrefixGroup2
)
{
return
-
1
;
}
groupBits
|
=
ePrefixGroup2
;
+
+
index
;
break
;
case
0x66
:
if
(
groupBits
&
ePrefixGroup3
)
{
return
-
1
;
}
groupBits
|
=
ePrefixGroup3
;
+
+
index
;
break
;
case
0x67
:
if
(
groupBits
&
ePrefixGroup4
)
{
return
-
1
;
}
groupBits
|
=
ePrefixGroup4
;
+
+
index
;
break
;
default
:
return
index
-
aBytesIndex
;
}
}
}
BYTE
BuildModRmByte
(
BYTE
aModBits
BYTE
aReg
BYTE
aRm
)
{
MOZ_ASSERT
(
(
aRm
&
kMaskRm
)
=
=
aRm
)
;
MOZ_ASSERT
(
(
aModBits
&
kMaskMod
)
=
=
aModBits
)
;
MOZ_ASSERT
(
(
(
aReg
<
<
kRegFieldShift
)
&
kMaskReg
)
=
=
(
aReg
<
<
kRegFieldShift
)
)
;
return
aModBits
|
(
aReg
<
<
kRegFieldShift
)
|
aRm
;
}
void
CreateTrampoline
(
void
*
aOrigFunction
intptr_t
aDest
void
*
*
aOutTramp
)
{
*
aOutTramp
=
nullptr
;
byteptr_t
tramp
=
FindTrampolineSpace
(
)
;
if
(
!
tramp
)
{
return
;
}
*
(
(
void
*
*
)
tramp
)
=
aOrigFunction
;
tramp
+
=
sizeof
(
void
*
)
;
byteptr_t
origBytes
=
(
byteptr_t
)
aOrigFunction
;
int
nOrigBytes
=
0
;
#
if
defined
(
_M_IX86
)
int
pJmp32
=
-
1
;
while
(
nOrigBytes
<
5
)
{
unsigned
char
prefixGroups
;
int
numPrefixBytes
=
CountPrefixBytes
(
origBytes
nOrigBytes
&
prefixGroups
)
;
if
(
numPrefixBytes
<
0
|
|
(
prefixGroups
&
(
ePrefixGroup3
|
ePrefixGroup4
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
nOrigBytes
+
=
numPrefixBytes
;
if
(
origBytes
[
nOrigBytes
]
>
=
0x88
&
&
origBytes
[
nOrigBytes
]
<
=
0x8B
)
{
+
+
nOrigBytes
;
int
len
=
CountModRmSib
(
origBytes
+
nOrigBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
MOV
opcode
sequence
"
)
;
return
;
}
nOrigBytes
+
=
len
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0xA1
)
{
nOrigBytes
+
=
5
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0xB8
)
{
nOrigBytes
+
=
5
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x33
&
&
(
origBytes
[
nOrigBytes
+
1
]
&
kMaskMod
)
=
=
kModReg
)
{
nOrigBytes
+
=
2
;
}
else
if
(
(
origBytes
[
nOrigBytes
]
&
0xf8
)
=
=
0x40
)
{
nOrigBytes
+
=
1
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x83
)
{
unsigned
char
b
=
origBytes
[
nOrigBytes
+
1
]
;
if
(
(
b
&
0xc0
)
=
=
0xc0
)
{
nOrigBytes
+
=
3
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
bit
opcode
sequence
"
)
;
return
;
}
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x68
)
{
nOrigBytes
+
=
5
;
}
else
if
(
(
origBytes
[
nOrigBytes
]
&
0xf0
)
=
=
0x50
)
{
nOrigBytes
+
+
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x6A
)
{
nOrigBytes
+
=
2
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0xe9
)
{
pJmp32
=
nOrigBytes
;
nOrigBytes
+
=
5
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0xff
&
&
origBytes
[
nOrigBytes
+
1
]
=
=
0x25
)
{
nOrigBytes
+
=
6
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0xc2
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
NS_WARNING
(
"
Cannot
hook
method
-
-
RET
opcode
found
"
)
;
#
endif
return
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
memcpy
(
tramp
aOrigFunction
nOrigBytes
)
;
#
elif
defined
(
_M_X64
)
int
nTrampBytes
=
0
;
bool
foundJmp
=
false
;
while
(
nOrigBytes
<
13
)
{
if
(
foundJmp
)
{
if
(
origBytes
[
nOrigBytes
]
=
=
0x90
|
|
origBytes
[
nOrigBytes
]
=
=
0xcc
)
{
nOrigBytes
+
+
;
continue
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Opcode
sequence
includes
commands
after
JMP
"
)
;
return
;
}
if
(
origBytes
[
nOrigBytes
]
=
=
0x0f
)
{
COPY_CODES
(
1
)
;
if
(
origBytes
[
nOrigBytes
]
=
=
0x1f
)
{
COPY_CODES
(
1
)
;
if
(
(
origBytes
[
nOrigBytes
]
&
0xc0
)
=
=
0x40
&
&
(
origBytes
[
nOrigBytes
]
&
0x7
)
=
=
0x04
)
{
COPY_CODES
(
3
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x05
)
{
COPY_CODES
(
1
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x10
|
|
origBytes
[
nOrigBytes
]
=
=
0x11
)
{
COPY_CODES
(
1
)
;
int
nModRmSibBytes
=
CountModRmSib
(
&
origBytes
[
nOrigBytes
]
)
;
if
(
nModRmSibBytes
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
else
{
COPY_CODES
(
nModRmSibBytes
)
;
}
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x84
)
{
JumpPatch
jump
(
nTrampBytes
-
1
(
intptr_t
)
(
origBytes
+
nOrigBytes
+
5
+
*
(
reinterpret_cast
<
int32_t
*
>
(
origBytes
+
nOrigBytes
+
1
)
)
)
JumpType
:
:
Je
)
;
nTrampBytes
=
jump
.
GenerateJump
(
tramp
)
;
nOrigBytes
+
=
5
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x40
|
|
origBytes
[
nOrigBytes
]
=
=
0x41
)
{
COPY_CODES
(
1
)
;
if
(
(
origBytes
[
nOrigBytes
]
&
0xf0
)
=
=
0x50
)
{
COPY_CODES
(
1
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
>
=
0xb8
&
&
origBytes
[
nOrigBytes
]
<
=
0xbf
)
{
COPY_CODES
(
5
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x45
)
{
COPY_CODES
(
1
)
;
if
(
origBytes
[
nOrigBytes
]
=
=
0x33
)
{
COPY_CODES
(
2
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
(
origBytes
[
nOrigBytes
]
&
0xfa
)
=
=
0x48
)
{
COPY_CODES
(
1
)
;
if
(
origBytes
[
nOrigBytes
]
=
=
0x81
&
&
(
origBytes
[
nOrigBytes
+
1
]
&
0xf8
)
=
=
0xe8
)
{
COPY_CODES
(
6
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x83
&
&
(
origBytes
[
nOrigBytes
+
1
]
&
0xf8
)
=
=
0xe8
)
{
COPY_CODES
(
3
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x83
&
&
(
origBytes
[
nOrigBytes
+
1
]
&
(
kMaskMod
|
kMaskReg
)
)
=
=
kModReg
)
{
COPY_CODES
(
3
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x83
&
&
(
origBytes
[
nOrigBytes
+
1
]
&
0xf8
)
=
=
0x60
)
{
COPY_CODES
(
5
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x2b
&
&
(
origBytes
[
nOrigBytes
+
1
]
&
kMaskMod
)
=
=
kModReg
)
{
COPY_CODES
(
2
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x85
)
{
if
(
(
origBytes
[
nOrigBytes
+
1
]
&
0xc0
)
=
=
0xc0
)
{
COPY_CODES
(
2
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
(
origBytes
[
nOrigBytes
]
&
0xfd
)
=
=
0x89
)
{
BYTE
reg
;
int
len
=
CountModRmSib
(
origBytes
+
nOrigBytes
+
1
&
reg
)
;
if
(
len
<
0
)
{
MOZ_ASSERT
(
len
=
=
kModOperand64
)
;
if
(
len
!
=
kModOperand64
)
{
return
;
}
nOrigBytes
+
=
2
;
int64_t
*
absAddr
=
reinterpret_cast
<
int64_t
*
>
(
origBytes
+
nOrigBytes
+
4
+
*
reinterpret_cast
<
int32_t
*
>
(
origBytes
+
nOrigBytes
)
)
;
nOrigBytes
+
=
4
;
if
(
reg
=
=
kRegAx
)
{
tramp
[
nTrampBytes
]
=
0xa1
;
+
+
nTrampBytes
;
int64_t
*
*
trampOperandPtr
=
reinterpret_cast
<
int64_t
*
*
>
(
tramp
+
nTrampBytes
)
;
*
trampOperandPtr
=
absAddr
;
nTrampBytes
+
=
8
;
}
else
{
tramp
[
nTrampBytes
]
=
0xb8
+
reg
;
+
+
nTrampBytes
;
int64_t
*
*
trampOperandPtr
=
reinterpret_cast
<
int64_t
*
*
>
(
tramp
+
nTrampBytes
)
;
*
trampOperandPtr
=
absAddr
;
nTrampBytes
+
=
8
;
tramp
[
nTrampBytes
]
=
0x48
;
tramp
[
nTrampBytes
+
1
]
=
0x8b
;
tramp
[
nTrampBytes
+
2
]
=
BuildModRmByte
(
kModNoRegDisp
reg
reg
)
;
nTrampBytes
+
=
3
;
}
}
else
{
COPY_CODES
(
len
+
1
)
;
}
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0xc7
)
{
if
(
origBytes
[
nOrigBytes
+
1
]
=
=
0x44
)
{
COPY_CODES
(
8
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0xff
)
{
if
(
(
origBytes
[
nOrigBytes
+
1
]
&
0xc0
)
=
=
0x0
&
&
(
origBytes
[
nOrigBytes
+
1
]
&
0x07
)
=
=
0x5
)
{
JumpPatch
jump
(
nTrampBytes
-
1
*
reinterpret_cast
<
intptr_t
*
>
(
origBytes
+
nOrigBytes
+
6
+
*
reinterpret_cast
<
int32_t
*
>
(
origBytes
+
nOrigBytes
+
2
)
)
JumpType
:
:
Jmp
)
;
nTrampBytes
=
jump
.
GenerateJump
(
tramp
)
;
nOrigBytes
+
=
6
;
foundJmp
=
true
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x63
&
&
(
origBytes
[
nOrigBytes
+
1
]
&
kMaskMod
)
=
=
kModReg
)
{
COPY_CODES
(
2
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x66
)
{
COPY_CODES
(
1
)
;
if
(
origBytes
[
nOrigBytes
]
>
=
0x88
&
&
origBytes
[
nOrigBytes
]
<
=
0x8B
)
{
unsigned
char
b
=
origBytes
[
nOrigBytes
+
1
]
;
if
(
(
(
b
&
0xc0
)
=
=
0xc0
)
|
|
(
(
(
b
&
0xc0
)
=
=
0x00
)
&
&
(
(
b
&
0x07
)
!
=
0x04
)
&
&
(
(
b
&
0x07
)
!
=
0x05
)
)
)
{
COPY_CODES
(
2
)
;
}
else
if
(
(
b
&
0xc0
)
=
=
0x40
)
{
if
(
(
b
&
0x07
)
=
=
0x04
)
{
COPY_CODES
(
4
)
;
}
else
{
COPY_CODES
(
3
)
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
MOV
opcode
sequence
"
)
;
return
;
}
}
}
else
if
(
(
origBytes
[
nOrigBytes
]
&
0xf0
)
=
=
0x50
)
{
COPY_CODES
(
1
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x65
)
{
if
(
origBytes
[
nOrigBytes
+
1
]
=
=
0x48
&
&
(
origBytes
[
nOrigBytes
+
2
]
>
=
0x88
&
&
origBytes
[
nOrigBytes
+
2
]
<
=
0x8b
)
)
{
COPY_CODES
(
3
)
;
int
len
=
CountModRmSib
(
origBytes
+
nOrigBytes
)
;
if
(
len
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
len
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x80
&
&
origBytes
[
nOrigBytes
+
1
]
=
=
0x3d
)
{
tramp
[
nTrampBytes
]
=
0x49
;
+
+
nTrampBytes
;
tramp
[
nTrampBytes
]
=
0x53
;
+
+
nTrampBytes
;
byteptr_t
absAddr
=
reinterpret_cast
<
byteptr_t
>
(
origBytes
+
nOrigBytes
+
7
+
*
reinterpret_cast
<
int32_t
*
>
(
origBytes
+
nOrigBytes
+
2
)
)
;
nOrigBytes
+
=
6
;
tramp
[
nTrampBytes
]
=
0x49
;
+
+
nTrampBytes
;
tramp
[
nTrampBytes
]
=
0xbb
;
+
+
nTrampBytes
;
*
reinterpret_cast
<
byteptr_t
*
>
(
tramp
+
nTrampBytes
)
=
absAddr
;
nTrampBytes
+
=
8
;
tramp
[
nTrampBytes
]
=
0x41
;
+
+
nTrampBytes
;
tramp
[
nTrampBytes
]
=
0x80
;
+
+
nTrampBytes
;
tramp
[
nTrampBytes
]
=
0x3b
;
+
+
nTrampBytes
;
COPY_CODES
(
1
)
;
tramp
[
nTrampBytes
]
=
0x49
;
+
+
nTrampBytes
;
tramp
[
nTrampBytes
]
=
0x5b
;
+
+
nTrampBytes
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x90
)
{
COPY_CODES
(
1
)
;
}
else
if
(
(
origBytes
[
nOrigBytes
]
&
0xf8
)
=
=
0xb8
)
{
COPY_CODES
(
5
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x33
)
{
COPY_CODES
(
2
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0xf6
)
{
BYTE
subOpcode
=
0
;
int
nModRmSibBytes
=
CountModRmSib
(
&
origBytes
[
nOrigBytes
+
1
]
&
subOpcode
)
;
if
(
nModRmSibBytes
<
0
|
|
subOpcode
!
=
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
2
+
nModRmSibBytes
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x85
)
{
int
nModRmSibBytes
=
CountModRmSib
(
&
origBytes
[
nOrigBytes
+
1
]
)
;
if
(
nModRmSibBytes
<
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
COPY_CODES
(
1
+
nModRmSibBytes
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0xd1
&
&
(
origBytes
[
nOrigBytes
+
1
]
&
kMaskMod
)
=
=
kModReg
)
{
COPY_CODES
(
2
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0xc3
)
{
COPY_CODES
(
1
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0xcc
)
{
COPY_CODES
(
1
)
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0xe8
|
|
origBytes
[
nOrigBytes
]
=
=
0xe9
)
{
foundJmp
=
origBytes
[
nOrigBytes
]
=
=
0xe9
;
JumpPatch
jump
(
nTrampBytes
(
intptr_t
)
(
origBytes
+
nOrigBytes
+
5
+
*
(
reinterpret_cast
<
int32_t
*
>
(
origBytes
+
nOrigBytes
+
1
)
)
)
origBytes
[
nOrigBytes
]
=
=
0xe8
?
JumpType
:
:
Call
:
JumpType
:
:
Jmp
)
;
nTrampBytes
=
jump
.
GenerateJump
(
tramp
)
;
nOrigBytes
+
=
5
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0x74
|
|
origBytes
[
nOrigBytes
]
=
=
0x75
)
{
char
offset
=
origBytes
[
nOrigBytes
+
1
]
;
auto
jumpType
=
JumpType
:
:
Je
;
if
(
origBytes
[
nOrigBytes
]
=
=
0x75
)
jumpType
=
JumpType
:
:
Jne
;
JumpPatch
jump
(
nTrampBytes
(
intptr_t
)
(
origBytes
+
nOrigBytes
+
2
+
offset
)
jumpType
)
;
nTrampBytes
=
jump
.
GenerateJump
(
tramp
)
;
nOrigBytes
+
=
2
;
}
else
if
(
origBytes
[
nOrigBytes
]
=
=
0xff
)
{
if
(
(
origBytes
[
nOrigBytes
+
1
]
&
(
kMaskMod
|
kMaskReg
)
)
=
=
0xf0
)
{
COPY_CODES
(
2
)
;
}
else
if
(
origBytes
[
nOrigBytes
+
1
]
=
=
0x25
)
{
foundJmp
=
true
;
int32_t
offset
=
*
(
reinterpret_cast
<
int32_t
*
>
(
origBytes
+
nOrigBytes
+
2
)
)
;
int64_t
*
ptrToJmpDest
=
reinterpret_cast
<
int64_t
*
>
(
origBytes
+
nOrigBytes
+
6
+
offset
)
;
intptr_t
jmpDest
=
static_cast
<
intptr_t
>
(
*
ptrToJmpDest
)
;
JumpPatch
jump
(
nTrampBytes
jmpDest
JumpType
:
:
Jmp
)
;
nTrampBytes
=
jump
.
GenerateJump
(
tramp
)
;
nOrigBytes
+
=
6
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
opcode
sequence
"
)
;
return
;
}
}
#
else
#
error
"
Unknown
processor
type
"
#
endif
if
(
nOrigBytes
>
100
)
{
return
;
}
byteptr_t
trampDest
=
origBytes
+
nOrigBytes
;
#
if
defined
(
_M_IX86
)
if
(
pJmp32
>
=
0
)
{
*
(
(
intptr_t
*
)
(
tramp
+
pJmp32
+
1
)
)
+
=
origBytes
-
tramp
;
}
else
{
tramp
[
nOrigBytes
]
=
0xE9
;
*
(
(
intptr_t
*
)
(
tramp
+
nOrigBytes
+
1
)
)
=
(
intptr_t
)
trampDest
-
(
intptr_t
)
(
tramp
+
nOrigBytes
+
5
)
;
}
#
elif
defined
(
_M_X64
)
if
(
!
foundJmp
)
{
JumpPatch
patch
(
nTrampBytes
reinterpret_cast
<
intptr_t
>
(
trampDest
)
)
;
patch
.
GenerateJump
(
tramp
)
;
}
#
endif
*
aOutTramp
=
tramp
;
AutoVirtualProtect
protect
(
aOrigFunction
nOrigBytes
PAGE_EXECUTE_READWRITE
)
;
if
(
!
protect
.
Protect
(
)
)
{
return
;
}
#
if
defined
(
_M_IX86
)
origBytes
[
0
]
=
0xE9
;
*
(
(
intptr_t
*
)
(
origBytes
+
1
)
)
=
aDest
-
(
intptr_t
)
(
origBytes
+
5
)
;
#
elif
defined
(
_M_X64
)
origBytes
[
0
]
=
0x49
;
origBytes
[
1
]
=
0xbb
;
*
(
(
intptr_t
*
)
(
origBytes
+
2
)
)
=
aDest
;
origBytes
[
10
]
=
0x41
;
origBytes
[
11
]
=
0xff
;
origBytes
[
12
]
=
0xe3
;
#
endif
}
byteptr_t
FindTrampolineSpace
(
)
{
if
(
mCurHooks
>
=
mMaxHooks
)
{
return
0
;
}
byteptr_t
p
=
mHookPage
+
mCurHooks
*
kHookSize
;
mCurHooks
+
+
;
return
p
;
}
static
void
*
ResolveRedirectedAddress
(
const
byteptr_t
aOriginalFunction
)
{
if
(
aOriginalFunction
[
0
]
=
=
0xeb
)
{
int8_t
offset
=
(
int8_t
)
(
aOriginalFunction
[
1
]
)
;
if
(
offset
<
=
0
)
{
return
aOriginalFunction
;
}
for
(
int8_t
i
=
0
;
i
<
offset
;
i
+
+
)
{
if
(
aOriginalFunction
[
2
+
i
]
!
=
0x90
)
{
return
aOriginalFunction
;
}
}
return
aOriginalFunction
+
2
+
offset
;
}
#
if
defined
(
_M_IX86
)
if
(
aOriginalFunction
[
0
]
=
=
0xff
&
&
aOriginalFunction
[
1
]
=
=
0x25
)
{
return
(
void
*
)
(
*
*
(
(
uint32_t
*
*
)
(
aOriginalFunction
+
2
)
)
)
;
}
#
elif
defined
(
_M_X64
)
if
(
aOriginalFunction
[
0
]
=
=
0xe9
)
{
int32_t
offset
=
*
(
(
int32_t
*
)
(
aOriginalFunction
+
1
)
)
;
return
aOriginalFunction
+
5
+
offset
;
}
#
endif
return
aOriginalFunction
;
}
}
;
}
class
WindowsDllInterceptor
{
internal
:
:
WindowsDllNopSpacePatcher
mNopSpacePatcher
;
internal
:
:
WindowsDllDetourPatcher
mDetourPatcher
;
const
char
*
mModuleName
;
int
mNHooks
;
public
:
WindowsDllInterceptor
(
)
:
mModuleName
(
nullptr
)
mNHooks
(
0
)
{
}
void
Init
(
const
char
*
aModuleName
int
aNumHooks
=
0
)
{
if
(
mModuleName
)
{
return
;
}
mModuleName
=
aModuleName
;
mNHooks
=
aNumHooks
;
mNopSpacePatcher
.
Init
(
aModuleName
)
;
}
void
LockHooks
(
)
{
if
(
mDetourPatcher
.
Initialized
(
)
)
{
mDetourPatcher
.
LockHooks
(
)
;
}
}
bool
AddHook
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModuleName
)
{
return
false
;
}
if
(
mNopSpacePatcher
.
AddHook
(
aName
aHookDest
aOrigFunc
)
)
{
return
true
;
}
return
AddDetour
(
aName
aHookDest
aOrigFunc
)
;
}
bool
AddDetour
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModuleName
)
{
return
false
;
}
if
(
!
mDetourPatcher
.
Initialized
(
)
)
{
mDetourPatcher
.
Init
(
mModuleName
mNHooks
)
;
}
return
mDetourPatcher
.
AddHook
(
aName
aHookDest
aOrigFunc
)
;
}
}
;
}
#
endif
