#
ifndef
NS_WINDOWS_DLL_INTERCEPTOR_H_
#
define
NS_WINDOWS_DLL_INTERCEPTOR_H_
#
include
<
wchar
.
h
>
#
include
<
windows
.
h
>
#
include
<
winternl
.
h
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
<
stdint
.
h
>
namespace
mozilla
{
namespace
internal
{
class
AutoVirtualProtect
{
public
:
AutoVirtualProtect
(
void
*
aFunc
size_t
aSize
DWORD
aProtect
)
:
mFunc
(
aFunc
)
mSize
(
aSize
)
mNewProtect
(
aProtect
)
mOldProtect
(
0
)
mSuccess
(
false
)
{
}
~
AutoVirtualProtect
(
)
{
if
(
mSuccess
)
{
VirtualProtectEx
(
GetCurrentProcess
(
)
mFunc
mSize
mOldProtect
&
mOldProtect
)
;
}
}
bool
Protect
(
)
{
mSuccess
=
!
!
VirtualProtectEx
(
GetCurrentProcess
(
)
mFunc
mSize
mNewProtect
&
mOldProtect
)
;
return
mSuccess
;
}
private
:
void
*
const
mFunc
;
size_t
const
mSize
;
DWORD
const
mNewProtect
;
DWORD
mOldProtect
;
bool
mSuccess
;
}
;
class
WindowsDllNopSpacePatcher
{
typedef
uint8_t
*
byteptr_t
;
HMODULE
mModule
;
static
const
size_t
maxPatchedFns
=
128
;
byteptr_t
mPatchedFns
[
maxPatchedFns
]
;
int
mPatchedFnsLen
;
public
:
WindowsDllNopSpacePatcher
(
)
:
mModule
(
0
)
mPatchedFnsLen
(
0
)
{
}
#
if
defined
(
_M_IX86
)
~
WindowsDllNopSpacePatcher
(
)
{
for
(
int
i
=
0
;
i
<
mPatchedFnsLen
;
i
+
+
)
{
byteptr_t
fn
=
mPatchedFns
[
i
]
;
AutoVirtualProtect
protect
(
fn
2
PAGE_EXECUTE_READWRITE
)
;
if
(
!
protect
.
Protect
(
)
)
{
continue
;
}
*
(
(
uint16_t
*
)
fn
)
=
0xff8b
;
FlushInstructionCache
(
GetCurrentProcess
(
)
nullptr
0
)
;
}
}
void
Init
(
const
char
*
aModuleName
)
{
if
(
!
IsCompatible
(
)
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
NS_WARNING
(
"
NOP
space
patching
is
unavailable
for
compatibility
reasons
"
)
;
#
endif
return
;
}
mModule
=
LoadLibraryExA
(
aModuleName
nullptr
0
)
;
if
(
!
mModule
)
{
return
;
}
}
static
bool
IsCompatible
(
)
{
const
wchar_t
*
kIncompatibleDLLs
[
]
=
{
L
"
detoured
.
dll
"
L
"
_etoured
.
dll
"
L
"
nvd3d9wrap
.
dll
"
L
"
nvdxgiwrap
.
dll
"
}
;
for
(
unsigned
int
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
kIncompatibleDLLs
)
;
+
+
i
)
{
if
(
GetModuleHandleW
(
kIncompatibleDLLs
[
i
]
)
)
{
return
false
;
}
}
if
(
GetModuleHandleW
(
L
"
user32
.
dll
"
)
)
{
return
true
;
}
HKEY
hkey
=
NULL
;
if
(
!
RegOpenKeyExW
(
HKEY_LOCAL_MACHINE
L
"
SOFTWARE
\
\
Microsoft
\
\
Windows
NT
\
\
CurrentVersion
\
\
Windows
"
0
KEY_QUERY_VALUE
&
hkey
)
)
{
nsAutoRegKey
key
(
hkey
)
;
DWORD
numBytes
=
0
;
const
wchar_t
kAppInitDLLs
[
]
=
L
"
AppInit_DLLs
"
;
LONG
status
=
RegQueryValueExW
(
hkey
kAppInitDLLs
nullptr
nullptr
nullptr
&
numBytes
)
;
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
data
;
if
(
!
status
)
{
data
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
numBytes
/
sizeof
(
wchar_t
)
)
;
status
=
RegQueryValueExW
(
hkey
kAppInitDLLs
nullptr
nullptr
(
LPBYTE
)
data
.
get
(
)
&
numBytes
)
;
}
if
(
!
status
)
{
const
wchar_t
kDelimiters
[
]
=
L
"
"
;
wchar_t
*
tokenContext
=
nullptr
;
wchar_t
*
token
=
wcstok_s
(
data
.
get
(
)
kDelimiters
&
tokenContext
)
;
while
(
token
)
{
wchar_t
fname
[
_MAX_FNAME
]
=
{
0
}
;
if
(
!
_wsplitpath_s
(
token
nullptr
0
nullptr
0
fname
mozilla
:
:
ArrayLength
(
fname
)
nullptr
0
)
)
{
const
wchar_t
kNvInitName
[
]
=
L
"
nvinit
"
;
if
(
!
_wcsnicmp
(
fname
kNvInitName
mozilla
:
:
ArrayLength
(
kNvInitName
)
)
)
{
return
false
;
}
}
token
=
wcstok_s
(
nullptr
kDelimiters
&
tokenContext
)
;
}
}
}
return
true
;
}
bool
AddHook
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModule
)
{
return
false
;
}
if
(
!
IsCompatible
(
)
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
NS_WARNING
(
"
NOP
space
patching
is
unavailable
for
compatibility
reasons
"
)
;
#
endif
return
false
;
}
if
(
mPatchedFnsLen
=
=
maxPatchedFns
)
{
return
false
;
}
byteptr_t
fn
=
reinterpret_cast
<
byteptr_t
>
(
GetProcAddress
(
mModule
aName
)
)
;
if
(
!
fn
)
{
return
false
;
}
fn
=
ResolveRedirectedAddress
(
fn
)
;
AutoVirtualProtect
protectBefore
(
fn
-
5
5
PAGE_EXECUTE_READWRITE
)
;
AutoVirtualProtect
protectAfter
(
fn
2
PAGE_EXECUTE_READWRITE
)
;
if
(
!
protectBefore
.
Protect
(
)
|
|
!
protectAfter
.
Protect
(
)
)
{
return
false
;
}
bool
rv
=
WriteHook
(
fn
aHookDest
aOrigFunc
)
;
if
(
rv
)
{
mPatchedFns
[
mPatchedFnsLen
]
=
fn
;
mPatchedFnsLen
+
+
;
}
return
rv
;
}
bool
WriteHook
(
byteptr_t
aFn
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
for
(
int
i
=
-
5
;
i
<
=
-
1
;
i
+
+
)
{
if
(
aFn
[
i
]
!
=
0x90
&
&
aFn
[
i
]
!
=
0xcc
)
{
return
false
;
}
}
if
(
(
aFn
[
0
]
!
=
0x8b
&
&
aFn
[
0
]
!
=
0x89
)
|
|
aFn
[
1
]
!
=
0xff
)
{
return
false
;
}
aFn
[
-
5
]
=
0xe9
;
*
(
(
intptr_t
*
)
(
aFn
-
4
)
)
=
aHookDest
-
(
uintptr_t
)
(
aFn
)
;
*
aOrigFunc
=
aFn
+
2
;
*
(
(
uint16_t
*
)
(
aFn
)
)
=
0xf9eb
;
FlushInstructionCache
(
GetCurrentProcess
(
)
nullptr
0
)
;
return
true
;
}
private
:
static
byteptr_t
ResolveRedirectedAddress
(
const
byteptr_t
aOriginalFunction
)
{
if
(
aOriginalFunction
[
0
]
=
=
0xff
&
&
aOriginalFunction
[
1
]
=
=
0x25
)
{
return
(
byteptr_t
)
(
*
*
(
(
uint32_t
*
*
)
(
aOriginalFunction
+
2
)
)
)
;
}
return
aOriginalFunction
;
}
#
else
void
Init
(
const
char
*
aModuleName
)
{
}
bool
AddHook
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
return
false
;
}
#
endif
}
;
class
WindowsDllDetourPatcher
{
typedef
unsigned
char
*
byteptr_t
;
public
:
WindowsDllDetourPatcher
(
)
:
mModule
(
0
)
mHookPage
(
0
)
mMaxHooks
(
0
)
mCurHooks
(
0
)
{
}
~
WindowsDllDetourPatcher
(
)
{
int
i
;
byteptr_t
p
;
for
(
i
=
0
p
=
mHookPage
;
i
<
mCurHooks
;
i
+
+
p
+
=
kHookSize
)
{
#
if
defined
(
_M_IX86
)
size_t
nBytes
=
1
+
sizeof
(
intptr_t
)
;
#
elif
defined
(
_M_X64
)
size_t
nBytes
=
2
+
sizeof
(
intptr_t
)
;
#
else
#
error
"
Unknown
processor
type
"
#
endif
byteptr_t
origBytes
=
*
(
(
byteptr_t
*
)
p
)
;
AutoVirtualProtect
protect
(
origBytes
nBytes
PAGE_EXECUTE_READWRITE
)
;
if
(
!
protect
.
Protect
(
)
)
{
continue
;
}
intptr_t
dest
=
(
intptr_t
)
(
p
+
sizeof
(
void
*
)
)
;
#
if
defined
(
_M_IX86
)
*
(
(
intptr_t
*
)
(
origBytes
+
1
)
)
=
dest
-
(
intptr_t
)
(
origBytes
+
5
)
;
#
elif
defined
(
_M_X64
)
*
(
(
intptr_t
*
)
(
origBytes
+
2
)
)
=
dest
;
#
else
#
error
"
Unknown
processor
type
"
#
endif
}
}
void
Init
(
const
char
*
aModuleName
int
aNumHooks
=
0
)
{
if
(
mModule
)
{
return
;
}
mModule
=
LoadLibraryExA
(
aModuleName
nullptr
0
)
;
if
(
!
mModule
)
{
return
;
}
int
hooksPerPage
=
4096
/
kHookSize
;
if
(
aNumHooks
=
=
0
)
{
aNumHooks
=
hooksPerPage
;
}
mMaxHooks
=
aNumHooks
+
(
hooksPerPage
%
aNumHooks
)
;
mHookPage
=
(
byteptr_t
)
VirtualAllocEx
(
GetCurrentProcess
(
)
nullptr
mMaxHooks
*
kHookSize
MEM_COMMIT
|
MEM_RESERVE
PAGE_EXECUTE_READWRITE
)
;
if
(
!
mHookPage
)
{
mModule
=
0
;
return
;
}
}
bool
Initialized
(
)
{
return
!
!
mModule
;
}
void
LockHooks
(
)
{
if
(
!
mModule
)
{
return
;
}
DWORD
op
;
VirtualProtectEx
(
GetCurrentProcess
(
)
mHookPage
mMaxHooks
*
kHookSize
PAGE_EXECUTE_READ
&
op
)
;
mModule
=
0
;
}
bool
AddHook
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModule
)
{
return
false
;
}
void
*
pAddr
=
(
void
*
)
GetProcAddress
(
mModule
aName
)
;
if
(
!
pAddr
)
{
return
false
;
}
pAddr
=
ResolveRedirectedAddress
(
(
byteptr_t
)
pAddr
)
;
CreateTrampoline
(
pAddr
aHookDest
aOrigFunc
)
;
if
(
!
*
aOrigFunc
)
{
return
false
;
}
return
true
;
}
protected
:
const
static
int
kPageSize
=
4096
;
const
static
int
kHookSize
=
128
;
HMODULE
mModule
;
byteptr_t
mHookPage
;
int
mMaxHooks
;
int
mCurHooks
;
static
const
BYTE
kMaskHighNibble
=
0xF0
;
static
const
BYTE
kRexOpcode
=
0x40
;
static
const
BYTE
kMaskRexW
=
0x08
;
static
const
BYTE
kMaskRexR
=
0x04
;
static
const
BYTE
kMaskRexX
=
0x02
;
static
const
BYTE
kMaskRexB
=
0x01
;
static
const
BYTE
kRegFieldShift
=
3
;
static
const
BYTE
kMaskMod
=
0xC0
;
static
const
BYTE
kMaskReg
=
0x38
;
static
const
BYTE
kMaskRm
=
0x07
;
static
const
BYTE
kRmNeedSib
=
0x04
;
static
const
BYTE
kModReg
=
0xC0
;
static
const
BYTE
kModDisp32
=
0x80
;
static
const
BYTE
kModDisp8
=
0x40
;
static
const
BYTE
kModNoRegDisp
=
0x00
;
static
const
BYTE
kRmNoRegDispDisp32
=
0x05
;
static
const
BYTE
kMaskSibScale
=
0xC0
;
static
const
BYTE
kMaskSibIndex
=
0x38
;
static
const
BYTE
kMaskSibBase
=
0x07
;
static
const
BYTE
kSibBaseEbp
=
0x05
;
int
CountModRmSib
(
const
BYTE
*
aModRm
BYTE
*
aSubOpcode
)
{
if
(
!
aModRm
)
{
return
-
1
;
}
int
numBytes
=
1
;
switch
(
*
aModRm
&
kMaskMod
)
{
case
kModReg
:
return
numBytes
;
case
kModDisp8
:
numBytes
+
=
1
;
break
;
case
kModDisp32
:
numBytes
+
=
4
;
break
;
case
kModNoRegDisp
:
if
(
(
*
aModRm
&
kMaskRm
)
=
=
kRmNoRegDispDisp32
|
|
(
(
*
aModRm
&
kMaskRm
)
=
=
kRmNeedSib
&
&
(
*
(
aModRm
+
1
)
&
kMaskSibBase
)
=
=
kSibBaseEbp
)
)
{
numBytes
+
=
4
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Impossible
value
for
modr
/
m
byte
mod
bits
"
)
;
return
-
1
;
}
if
(
(
*
aModRm
&
kMaskRm
)
=
=
kRmNeedSib
)
{
numBytes
+
=
1
;
}
if
(
aSubOpcode
)
{
*
aSubOpcode
=
(
*
aModRm
&
kMaskReg
)
>
>
kRegFieldShift
;
}
return
numBytes
;
}
#
if
defined
(
_M_X64
)
enum
JumpType
{
Je
Jmp
}
;
struct
JumpPatch
{
JumpPatch
(
)
:
mHookOffset
(
0
)
mJumpAddress
(
0
)
mType
(
JumpType
:
:
Jmp
)
{
}
JumpPatch
(
size_t
aOffset
intptr_t
aAddress
JumpType
aType
=
JumpType
:
:
Jmp
)
:
mHookOffset
(
aOffset
)
mJumpAddress
(
aAddress
)
mType
(
aType
)
{
}
void
AddJumpPatch
(
size_t
aHookOffset
intptr_t
aAbsJumpAddress
JumpType
aType
=
JumpType
:
:
Jmp
)
{
mHookOffset
=
aHookOffset
;
mJumpAddress
=
aAbsJumpAddress
;
mType
=
aType
;
}
size_t
GenerateJump
(
uint8_t
*
aCode
)
{
size_t
offset
=
mHookOffset
;
if
(
mType
=
=
JumpType
:
:
Je
)
{
aCode
[
offset
]
=
0x75
;
aCode
[
offset
+
1
]
=
14
;
offset
+
=
2
;
}
aCode
[
offset
]
=
0xff
;
aCode
[
offset
+
1
]
=
0x25
;
*
reinterpret_cast
<
int32_t
*
>
(
aCode
+
offset
+
2
)
=
0
;
*
reinterpret_cast
<
int64_t
*
>
(
aCode
+
offset
+
2
+
4
)
=
mJumpAddress
;
return
offset
+
2
+
4
+
8
;
}
bool
HasJumpPatch
(
)
const
{
return
!
!
mJumpAddress
;
}
size_t
mHookOffset
;
intptr_t
mJumpAddress
;
JumpType
mType
;
}
;
#
endif
void
CreateTrampoline
(
void
*
aOrigFunction
intptr_t
aDest
void
*
*
aOutTramp
)
{
*
aOutTramp
=
nullptr
;
byteptr_t
tramp
=
FindTrampolineSpace
(
)
;
if
(
!
tramp
)
{
return
;
}
byteptr_t
origBytes
=
(
byteptr_t
)
aOrigFunction
;
int
nBytes
=
0
;
#
if
defined
(
_M_IX86
)
int
pJmp32
=
-
1
;
while
(
nBytes
<
5
)
{
if
(
origBytes
[
nBytes
]
>
=
0x88
&
&
origBytes
[
nBytes
]
<
=
0x8B
)
{
unsigned
char
b
=
origBytes
[
nBytes
+
1
]
;
if
(
(
(
b
&
0xc0
)
=
=
0xc0
)
|
|
(
(
(
b
&
0xc0
)
=
=
0x00
)
&
&
(
(
b
&
0x07
)
!
=
0x04
)
&
&
(
(
b
&
0x07
)
!
=
0x05
)
)
)
{
nBytes
+
=
2
;
}
else
if
(
(
b
&
0xc0
)
=
=
0x40
)
{
if
(
(
b
&
0x07
)
=
=
0x04
)
{
nBytes
+
=
4
;
}
else
{
nBytes
+
=
3
;
}
}
else
{
return
;
}
}
else
if
(
origBytes
[
nBytes
]
=
=
0xB8
)
{
nBytes
+
=
5
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0x83
)
{
unsigned
char
b
=
origBytes
[
nBytes
+
1
]
;
if
(
(
b
&
0xc0
)
=
=
0xc0
)
{
nBytes
+
=
3
;
}
else
{
return
;
}
}
else
if
(
origBytes
[
nBytes
]
=
=
0x68
)
{
nBytes
+
=
5
;
}
else
if
(
(
origBytes
[
nBytes
]
&
0xf0
)
=
=
0x50
)
{
nBytes
+
+
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0x6A
)
{
nBytes
+
=
2
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0xe9
)
{
pJmp32
=
nBytes
;
nBytes
+
=
5
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0xff
&
&
origBytes
[
nBytes
+
1
]
=
=
0x25
)
{
nBytes
+
=
6
;
}
else
{
return
;
}
}
#
elif
defined
(
_M_X64
)
JumpPatch
jump
;
while
(
nBytes
<
13
)
{
if
(
jump
.
HasJumpPatch
(
)
)
{
if
(
origBytes
[
nBytes
]
=
=
0x90
|
|
origBytes
[
nBytes
]
=
=
0xcc
)
{
nBytes
+
+
;
continue
;
}
return
;
}
if
(
origBytes
[
nBytes
]
=
=
0x0f
)
{
nBytes
+
+
;
if
(
origBytes
[
nBytes
]
=
=
0x1f
)
{
nBytes
+
+
;
if
(
(
origBytes
[
nBytes
]
&
0xc0
)
=
=
0x40
&
&
(
origBytes
[
nBytes
]
&
0x7
)
=
=
0x04
)
{
nBytes
+
=
3
;
}
else
{
return
;
}
}
else
if
(
origBytes
[
nBytes
]
=
=
0x05
)
{
nBytes
+
+
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0x84
)
{
jump
.
AddJumpPatch
(
nBytes
-
1
(
intptr_t
)
origBytes
+
nBytes
+
5
+
*
(
reinterpret_cast
<
int32_t
*
>
(
origBytes
+
nBytes
+
1
)
)
JumpType
:
:
Je
)
;
nBytes
+
=
5
;
}
else
{
return
;
}
}
else
if
(
origBytes
[
nBytes
]
=
=
0x40
|
|
origBytes
[
nBytes
]
=
=
0x41
)
{
nBytes
+
+
;
if
(
(
origBytes
[
nBytes
]
&
0xf0
)
=
=
0x50
)
{
nBytes
+
+
;
}
else
if
(
origBytes
[
nBytes
]
>
=
0xb8
&
&
origBytes
[
nBytes
]
<
=
0xbf
)
{
nBytes
+
=
5
;
}
else
{
return
;
}
}
else
if
(
origBytes
[
nBytes
]
=
=
0x45
)
{
nBytes
+
+
;
if
(
origBytes
[
nBytes
]
=
=
0x33
)
{
nBytes
+
=
2
;
}
else
{
return
;
}
}
else
if
(
(
origBytes
[
nBytes
]
&
0xfb
)
=
=
0x48
)
{
nBytes
+
+
;
if
(
origBytes
[
nBytes
]
=
=
0x81
&
&
(
origBytes
[
nBytes
+
1
]
&
0xf8
)
=
=
0xe8
)
{
nBytes
+
=
6
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0x83
&
&
(
origBytes
[
nBytes
+
1
]
&
0xf8
)
=
=
0xe8
)
{
nBytes
+
=
3
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0x83
&
&
(
origBytes
[
nBytes
+
1
]
&
0xf8
)
=
=
0x60
)
{
nBytes
+
=
5
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0x85
)
{
if
(
(
origBytes
[
nBytes
+
1
]
&
0xc0
)
=
=
0xc0
)
{
nBytes
+
=
2
;
}
else
{
return
;
}
}
else
if
(
(
origBytes
[
nBytes
]
&
0xfd
)
=
=
0x89
)
{
if
(
(
origBytes
[
nBytes
+
1
]
&
0xc0
)
=
=
0x40
)
{
if
(
(
origBytes
[
nBytes
+
1
]
&
0x7
)
=
=
0x04
)
{
nBytes
+
=
4
;
}
else
{
nBytes
+
=
3
;
}
}
else
if
(
(
(
origBytes
[
nBytes
+
1
]
&
0xc0
)
=
=
0xc0
)
|
|
(
(
(
origBytes
[
nBytes
+
1
]
&
0xc0
)
=
=
0x00
)
&
&
(
(
origBytes
[
nBytes
+
1
]
&
0x07
)
!
=
0x04
)
&
&
(
(
origBytes
[
nBytes
+
1
]
&
0x07
)
!
=
0x05
)
)
)
{
nBytes
+
=
2
;
}
else
{
return
;
}
}
else
if
(
origBytes
[
nBytes
]
=
=
0xc7
)
{
if
(
origBytes
[
nBytes
+
1
]
=
=
0x44
)
{
nBytes
+
=
8
;
}
else
{
return
;
}
}
else
if
(
origBytes
[
nBytes
]
=
=
0xff
)
{
if
(
(
origBytes
[
nBytes
+
1
]
&
0xc0
)
=
=
0x0
&
&
(
origBytes
[
nBytes
+
1
]
&
0x07
)
=
=
0x5
)
{
jump
.
AddJumpPatch
(
nBytes
-
1
*
reinterpret_cast
<
intptr_t
*
>
(
origBytes
+
nBytes
+
6
+
*
reinterpret_cast
<
int32_t
*
>
(
origBytes
+
nBytes
+
2
)
)
)
;
nBytes
+
=
6
;
}
else
{
return
;
}
}
else
{
return
;
}
}
else
if
(
origBytes
[
nBytes
]
=
=
0x66
)
{
nBytes
+
=
1
;
if
(
origBytes
[
nBytes
]
>
=
0x88
&
&
origBytes
[
nBytes
]
<
=
0x8B
)
{
unsigned
char
b
=
origBytes
[
nBytes
+
1
]
;
if
(
(
(
b
&
0xc0
)
=
=
0xc0
)
|
|
(
(
(
b
&
0xc0
)
=
=
0x00
)
&
&
(
(
b
&
0x07
)
!
=
0x04
)
&
&
(
(
b
&
0x07
)
!
=
0x05
)
)
)
{
nBytes
+
=
2
;
}
else
if
(
(
b
&
0xc0
)
=
=
0x40
)
{
if
(
(
b
&
0x07
)
=
=
0x04
)
{
nBytes
+
=
4
;
}
else
{
nBytes
+
=
3
;
}
}
else
{
return
;
}
}
}
else
if
(
(
origBytes
[
nBytes
]
&
0xf0
)
=
=
0x50
)
{
nBytes
+
+
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0x90
)
{
nBytes
+
+
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0xb8
)
{
nBytes
+
=
5
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0x33
)
{
nBytes
+
=
2
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0xf6
)
{
BYTE
subOpcode
=
0
;
int
nModRmSibBytes
=
CountModRmSib
(
&
origBytes
[
nBytes
+
1
]
&
subOpcode
)
;
if
(
nModRmSibBytes
<
0
|
|
subOpcode
!
=
0
)
{
return
;
}
nBytes
+
=
2
+
nModRmSibBytes
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0xc3
)
{
nBytes
+
+
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0xcc
)
{
nBytes
+
+
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0xe9
)
{
jump
.
AddJumpPatch
(
nBytes
(
intptr_t
)
origBytes
+
nBytes
+
5
+
*
(
reinterpret_cast
<
int32_t
*
>
(
origBytes
+
nBytes
+
1
)
)
)
;
nBytes
+
=
5
;
}
else
if
(
origBytes
[
nBytes
]
=
=
0xff
)
{
nBytes
+
+
;
if
(
(
origBytes
[
nBytes
]
&
0xf8
)
=
=
0xf0
)
{
nBytes
+
+
;
}
else
{
return
;
}
}
else
{
return
;
}
}
#
else
#
error
"
Unknown
processor
type
"
#
endif
if
(
nBytes
>
100
)
{
return
;
}
*
(
(
void
*
*
)
tramp
)
=
aOrigFunction
;
tramp
+
=
sizeof
(
void
*
)
;
memcpy
(
tramp
aOrigFunction
nBytes
)
;
byteptr_t
trampDest
=
origBytes
+
nBytes
;
#
if
defined
(
_M_IX86
)
if
(
pJmp32
>
=
0
)
{
*
(
(
intptr_t
*
)
(
tramp
+
pJmp32
+
1
)
)
+
=
origBytes
-
tramp
;
}
else
{
tramp
[
nBytes
]
=
0xE9
;
*
(
(
intptr_t
*
)
(
tramp
+
nBytes
+
1
)
)
=
(
intptr_t
)
trampDest
-
(
intptr_t
)
(
tramp
+
nBytes
+
5
)
;
}
#
elif
defined
(
_M_X64
)
if
(
jump
.
HasJumpPatch
(
)
)
{
size_t
offset
=
jump
.
GenerateJump
(
tramp
)
;
if
(
jump
.
mType
!
=
JumpType
:
:
Jmp
)
{
JumpPatch
patch
(
offset
reinterpret_cast
<
intptr_t
>
(
trampDest
)
)
;
patch
.
GenerateJump
(
tramp
)
;
}
}
else
{
JumpPatch
patch
(
nBytes
reinterpret_cast
<
intptr_t
>
(
trampDest
)
)
;
patch
.
GenerateJump
(
tramp
)
;
}
#
endif
*
aOutTramp
=
tramp
;
AutoVirtualProtect
protect
(
aOrigFunction
nBytes
PAGE_EXECUTE_READWRITE
)
;
if
(
!
protect
.
Protect
(
)
)
{
return
;
}
#
if
defined
(
_M_IX86
)
origBytes
[
0
]
=
0xE9
;
*
(
(
intptr_t
*
)
(
origBytes
+
1
)
)
=
aDest
-
(
intptr_t
)
(
origBytes
+
5
)
;
#
elif
defined
(
_M_X64
)
origBytes
[
0
]
=
0x49
;
origBytes
[
1
]
=
0xbb
;
*
(
(
intptr_t
*
)
(
origBytes
+
2
)
)
=
aDest
;
origBytes
[
10
]
=
0x41
;
origBytes
[
11
]
=
0xff
;
origBytes
[
12
]
=
0xe3
;
#
endif
}
byteptr_t
FindTrampolineSpace
(
)
{
if
(
mCurHooks
>
=
mMaxHooks
)
{
return
0
;
}
byteptr_t
p
=
mHookPage
+
mCurHooks
*
kHookSize
;
mCurHooks
+
+
;
return
p
;
}
static
void
*
ResolveRedirectedAddress
(
const
byteptr_t
aOriginalFunction
)
{
#
if
defined
(
_M_IX86
)
if
(
aOriginalFunction
[
0
]
=
=
0xff
&
&
aOriginalFunction
[
1
]
=
=
0x25
)
{
return
(
void
*
)
(
*
*
(
(
uint32_t
*
*
)
(
aOriginalFunction
+
2
)
)
)
;
}
#
elif
defined
(
_M_X64
)
if
(
aOriginalFunction
[
0
]
=
=
0xe9
)
{
int32_t
offset
=
*
(
(
int32_t
*
)
(
aOriginalFunction
+
1
)
)
;
return
aOriginalFunction
+
5
+
offset
;
}
#
endif
return
aOriginalFunction
;
}
}
;
}
class
WindowsDllInterceptor
{
internal
:
:
WindowsDllNopSpacePatcher
mNopSpacePatcher
;
internal
:
:
WindowsDllDetourPatcher
mDetourPatcher
;
const
char
*
mModuleName
;
int
mNHooks
;
public
:
WindowsDllInterceptor
(
)
:
mModuleName
(
nullptr
)
mNHooks
(
0
)
{
}
void
Init
(
const
char
*
aModuleName
int
aNumHooks
=
0
)
{
if
(
mModuleName
)
{
return
;
}
mModuleName
=
aModuleName
;
mNHooks
=
aNumHooks
;
mNopSpacePatcher
.
Init
(
aModuleName
)
;
}
void
LockHooks
(
)
{
if
(
mDetourPatcher
.
Initialized
(
)
)
{
mDetourPatcher
.
LockHooks
(
)
;
}
}
bool
AddHook
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModuleName
)
{
return
false
;
}
if
(
mNopSpacePatcher
.
AddHook
(
aName
aHookDest
aOrigFunc
)
)
{
return
true
;
}
return
AddDetour
(
aName
aHookDest
aOrigFunc
)
;
}
bool
AddDetour
(
const
char
*
aName
intptr_t
aHookDest
void
*
*
aOrigFunc
)
{
if
(
!
mModuleName
)
{
return
false
;
}
if
(
!
mDetourPatcher
.
Initialized
(
)
)
{
mDetourPatcher
.
Init
(
mModuleName
mNHooks
)
;
}
return
mDetourPatcher
.
AddHook
(
aName
aHookDest
aOrigFunc
)
;
}
}
;
}
#
endif
