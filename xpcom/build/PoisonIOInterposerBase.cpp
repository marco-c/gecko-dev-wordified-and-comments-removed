#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Scoped
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
algorithm
>
#
include
"
PoisonIOInterposer
.
h
"
#
include
"
prlock
.
h
"
#
ifdef
MOZ_REPLACE_MALLOC
#
include
"
replace_malloc_bridge
.
h
"
#
endif
#
if
defined
(
XP_WIN
)
#
include
<
io
.
h
>
inline
mozilla
:
:
Maybe
<
intptr_t
>
FileDescriptorToHandle
(
int
aFd
)
{
intptr_t
handle
=
_get_osfhandle
(
aFd
)
;
if
(
(
handle
=
=
-
1
)
|
|
(
handle
=
=
-
2
)
)
{
return
mozilla
:
:
Nothing
(
)
;
}
return
mozilla
:
:
Some
(
handle
)
;
}
#
else
inline
mozilla
:
:
Maybe
<
intptr_t
>
FileDescriptorToHandle
(
int
aFd
)
{
return
mozilla
:
:
Some
<
intptr_t
>
(
aFd
)
;
}
#
endif
namespace
{
struct
DebugFilesAutoLockTraits
{
typedef
PRLock
*
type
;
typedef
const
PRLock
*
const_type
;
static
const_type
empty
(
)
{
return
nullptr
;
}
static
void
release
(
type
aL
)
{
PR_Unlock
(
aL
)
;
}
}
;
class
DebugFilesAutoLock
:
public
mozilla
:
:
Scoped
<
DebugFilesAutoLockTraits
>
{
static
PRLock
*
Lock
;
public
:
static
PRLock
*
getDebugFileIDsLock
(
)
{
if
(
!
Lock
)
{
Lock
=
PR_NewLock
(
)
;
}
return
Lock
;
}
DebugFilesAutoLock
(
)
:
mozilla
:
:
Scoped
<
DebugFilesAutoLockTraits
>
(
getDebugFileIDsLock
(
)
)
{
PR_Lock
(
get
(
)
)
;
}
}
;
PRLock
*
DebugFilesAutoLock
:
:
Lock
;
template
<
typename
T
size_t
chunk_size
=
64
>
class
ChunkedList
{
struct
ListChunk
{
static
const
size_t
kLength
=
(
chunk_size
-
sizeof
(
ListChunk
*
)
)
/
sizeof
(
mozilla
:
:
Atomic
<
T
>
)
;
mozilla
:
:
Atomic
<
T
>
mElements
[
kLength
]
;
mozilla
:
:
UniquePtr
<
ListChunk
>
mNext
;
ListChunk
(
)
:
mNext
(
nullptr
)
{
}
}
;
ListChunk
mList
;
mozilla
:
:
Atomic
<
size_t
>
mLength
;
public
:
ChunkedList
(
)
:
mLength
(
0
)
{
}
~
ChunkedList
(
)
{
MOZ_RELEASE_ASSERT
(
mLength
<
=
ListChunk
:
:
kLength
)
;
}
void
Add
(
T
aValue
)
{
ListChunk
*
list
=
&
mList
;
size_t
position
=
mLength
;
for
(
;
position
>
=
ListChunk
:
:
kLength
;
position
-
=
ListChunk
:
:
kLength
)
{
if
(
!
list
-
>
mNext
)
{
list
-
>
mNext
.
reset
(
new
ListChunk
(
)
)
;
}
list
=
list
-
>
mNext
.
get
(
)
;
}
list
-
>
mElements
[
position
]
=
aValue
;
mLength
+
+
;
}
void
Remove
(
T
aValue
)
{
if
(
!
mLength
)
{
return
;
}
ListChunk
*
list
=
&
mList
;
size_t
last
=
mLength
-
1
;
do
{
size_t
position
=
0
;
for
(
;
position
<
ListChunk
:
:
kLength
;
position
+
+
)
{
if
(
aValue
=
=
list
-
>
mElements
[
position
]
)
{
ListChunk
*
last_list
=
list
;
for
(
;
last
>
=
ListChunk
:
:
kLength
;
last
-
=
ListChunk
:
:
kLength
)
{
last_list
=
last_list
-
>
mNext
.
get
(
)
;
}
T
value
=
last_list
-
>
mElements
[
last
]
;
list
-
>
mElements
[
position
]
=
value
;
mLength
-
-
;
return
;
}
}
last
-
=
ListChunk
:
:
kLength
;
list
=
list
-
>
mNext
.
get
(
)
;
}
while
(
list
)
;
}
bool
Contains
(
T
aValue
)
{
ListChunk
*
list
=
&
mList
;
size_t
length
=
mLength
;
do
{
size_t
list_length
=
ListChunk
:
:
kLength
;
list_length
=
std
:
:
min
(
list_length
length
)
;
for
(
size_t
position
=
0
;
position
<
list_length
;
position
+
+
)
{
if
(
aValue
=
=
list
-
>
mElements
[
position
]
)
{
return
true
;
}
}
length
-
=
ListChunk
:
:
kLength
;
list
=
list
-
>
mNext
.
get
(
)
;
}
while
(
list
)
;
return
false
;
}
}
;
typedef
ChunkedList
<
intptr_t
>
FdList
;
FdList
&
getDebugFileIDs
(
)
{
static
FdList
DebugFileIDs
;
return
DebugFileIDs
;
}
}
namespace
mozilla
{
bool
IsDebugFile
(
intptr_t
aFileID
)
{
return
getDebugFileIDs
(
)
.
Contains
(
aFileID
)
;
}
}
extern
"
C
"
{
void
MozillaRegisterDebugHandle
(
intptr_t
aHandle
)
{
DebugFilesAutoLock
lockedScope
;
FdList
&
DebugFileIDs
=
getDebugFileIDs
(
)
;
MOZ_ASSERT
(
!
DebugFileIDs
.
Contains
(
aHandle
)
)
;
DebugFileIDs
.
Add
(
aHandle
)
;
}
void
MozillaRegisterDebugFD
(
int
aFd
)
{
mozilla
:
:
Maybe
<
intptr_t
>
handle
=
FileDescriptorToHandle
(
aFd
)
;
if
(
!
handle
.
isSome
(
)
)
{
return
;
}
MozillaRegisterDebugHandle
(
handle
.
value
(
)
)
;
}
void
MozillaRegisterDebugFILE
(
FILE
*
aFile
)
{
int
fd
=
fileno
(
aFile
)
;
if
(
fd
=
=
1
|
|
fd
=
=
2
)
{
return
;
}
MozillaRegisterDebugFD
(
fd
)
;
}
void
MozillaUnRegisterDebugHandle
(
intptr_t
aHandle
)
{
DebugFilesAutoLock
lockedScope
;
FdList
&
DebugFileIDs
=
getDebugFileIDs
(
)
;
MOZ_ASSERT
(
DebugFileIDs
.
Contains
(
aHandle
)
)
;
DebugFileIDs
.
Remove
(
aHandle
)
;
}
void
MozillaUnRegisterDebugFD
(
int
aFd
)
{
mozilla
:
:
Maybe
<
intptr_t
>
handle
=
FileDescriptorToHandle
(
aFd
)
;
if
(
!
handle
.
isSome
(
)
)
{
return
;
}
MozillaUnRegisterDebugHandle
(
handle
.
value
(
)
)
;
}
void
MozillaUnRegisterDebugFILE
(
FILE
*
aFile
)
{
int
fd
=
fileno
(
aFile
)
;
if
(
fd
=
=
1
|
|
fd
=
=
2
)
{
return
;
}
fflush
(
aFile
)
;
MozillaUnRegisterDebugFD
(
fd
)
;
}
}
#
ifdef
MOZ_REPLACE_MALLOC
void
mozilla
:
:
DebugFdRegistry
:
:
RegisterHandle
(
intptr_t
aHandle
)
{
MozillaRegisterDebugHandle
(
aHandle
)
;
}
void
mozilla
:
:
DebugFdRegistry
:
:
UnRegisterHandle
(
intptr_t
aHandle
)
{
MozillaUnRegisterDebugHandle
(
aHandle
)
;
}
#
endif
