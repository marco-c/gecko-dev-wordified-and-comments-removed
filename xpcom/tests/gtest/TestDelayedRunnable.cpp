#
include
"
mozilla
/
DelayedRunnable
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
gtest
/
MozAssertions
.
h
"
#
include
"
MediaTimer
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
include
"
VideoUtils
.
h
"
using
mozilla
:
:
Atomic
;
using
mozilla
:
:
MakeRefPtr
;
using
mozilla
:
:
Monitor
;
using
mozilla
:
:
MonitorAutoLock
;
using
mozilla
:
:
TaskQueue
;
namespace
{
struct
ReleaseDetector
{
explicit
ReleaseDetector
(
Atomic
<
bool
>
*
aActive
)
:
mActive
(
aActive
)
{
*
mActive
=
true
;
}
ReleaseDetector
(
ReleaseDetector
&
&
aOther
)
noexcept
:
mActive
(
aOther
.
mActive
)
{
aOther
.
mActive
=
nullptr
;
}
ReleaseDetector
(
const
ReleaseDetector
&
)
=
delete
;
~
ReleaseDetector
(
)
{
if
(
mActive
)
{
*
mActive
=
false
;
}
}
Atomic
<
bool
>
*
mActive
;
}
;
}
TEST
(
DelayedRunnable
TaskQueueShutdownLeak
)
{
Atomic
<
bool
>
active
{
false
}
;
auto
taskQueue
=
TaskQueue
:
:
Create
(
GetMediaThreadPool
(
mozilla
:
:
MediaThreadType
:
:
SUPERVISOR
)
"
TestDelayedRunnable
TaskQueueShutdownLeak
"
)
;
taskQueue
-
>
DelayedDispatch
(
NS_NewRunnableFunction
(
__func__
[
release
=
ReleaseDetector
(
&
active
)
]
{
}
)
60e3
)
;
EXPECT_TRUE
(
active
)
;
taskQueue
-
>
BeginShutdown
(
)
;
taskQueue
-
>
AwaitIdle
(
)
;
EXPECT_FALSE
(
active
)
;
}
TEST
(
DelayedRunnable
nsThreadShutdownLeak
)
{
Atomic
<
bool
>
active
{
false
}
;
nsCOMPtr
<
nsIThread
>
thread
;
ASSERT_EQ
(
NS_NewNamedThread
(
"
Test
Thread
"
getter_AddRefs
(
thread
)
)
NS_OK
)
;
thread
-
>
DelayedDispatch
(
NS_NewRunnableFunction
(
__func__
[
release
=
ReleaseDetector
(
&
active
)
]
{
}
)
60e3
)
;
EXPECT_TRUE
(
active
)
;
ASSERT_EQ
(
thread
-
>
Shutdown
(
)
NS_OK
)
;
EXPECT_FALSE
(
active
)
;
}
TEST
(
DelayedRunnable
BackgroundTaskQueueShutdownTask
)
{
nsCOMPtr
<
nsISerialEventTarget
>
taskQueue
;
nsresult
rv
=
NS_CreateBackgroundTaskQueue
(
"
TestDelayedRunnable
"
getter_AddRefs
(
taskQueue
)
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
nsISerialEventTarget
*
tq
=
taskQueue
.
forget
(
)
.
take
(
)
;
mozilla
:
:
Unused
<
<
tq
;
}
TEST
(
DelayedRunnable
nsThreadShutdownTask
)
{
nsCOMPtr
<
nsIThread
>
thread
;
ASSERT_EQ
(
NS_NewNamedThread
(
"
Test
Thread
"
getter_AddRefs
(
thread
)
)
NS_OK
)
;
nsIThread
*
t
=
thread
.
forget
(
)
.
take
(
)
;
mozilla
:
:
Unused
<
<
t
;
}
TEST
(
DelayedRunnable
TimerFiresBeforeRunnableRuns
)
{
RefPtr
<
mozilla
:
:
SharedThreadPool
>
pool
=
mozilla
:
:
SharedThreadPool
:
:
Get
(
"
Test
Pool
"
_ns
)
;
auto
tailTaskQueue1
=
TaskQueue
:
:
Create
(
do_AddRef
(
pool
)
"
TestDelayedRunnable
tailTaskQueue1
"
true
)
;
auto
tailTaskQueue2
=
TaskQueue
:
:
Create
(
do_AddRef
(
pool
)
"
TestDelayedRunnable
tailTaskQueue2
"
true
)
;
auto
noTailTaskQueue
=
TaskQueue
:
:
Create
(
do_AddRef
(
pool
)
"
TestDelayedRunnable
noTailTaskQueue
"
false
)
;
enum
class
State
:
uint8_t
{
Start
TimerRan
TasksFinished
}
state
=
State
:
:
Start
;
Monitor
monitor
MOZ_UNANNOTATED
(
__func__
)
;
MonitorAutoLock
lock
(
monitor
)
;
MOZ_ALWAYS_SUCCEEDS
(
tailTaskQueue1
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
&
]
{
EXPECT_TRUE
(
tailTaskQueue1
-
>
RequiresTailDispatch
(
tailTaskQueue2
)
)
;
tailTaskQueue2
-
>
DelayedDispatch
(
NS_NewRunnableFunction
(
__func__
[
&
]
{
}
)
1
)
;
MonitorAutoLock
lock
(
monitor
)
;
auto
timer
=
MakeRefPtr
<
mozilla
:
:
MediaTimer
<
mozilla
:
:
TimeStamp
>
>
(
)
;
timer
-
>
WaitFor
(
mozilla
:
:
TimeDuration
:
:
FromMilliseconds
(
1
)
__func__
)
-
>
Then
(
noTailTaskQueue
__func__
[
&
]
{
MonitorAutoLock
lock
(
monitor
)
;
state
=
State
:
:
TimerRan
;
monitor
.
NotifyAll
(
)
;
}
)
;
while
(
state
!
=
State
:
:
TimerRan
)
{
monitor
.
Wait
(
)
;
}
state
=
State
:
:
TasksFinished
;
monitor
.
Notify
(
)
;
}
)
)
)
;
while
(
state
!
=
State
:
:
TasksFinished
)
{
monitor
.
Wait
(
)
;
}
}
