#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
MruCache
.
h
"
#
include
"
nsString
.
h
"
using
namespace
mozilla
;
struct
IntMap
:
public
MruCache
<
int
int
IntMap
>
{
static
HashNumber
Hash
(
const
KeyType
&
aKey
)
{
return
aKey
-
1
;
}
static
bool
Match
(
const
KeyType
&
aKey
const
ValueType
&
aVal
)
{
return
aKey
=
=
aVal
;
}
}
;
struct
UintPtrMap
:
public
MruCache
<
uintptr_t
int
*
UintPtrMap
>
{
static
HashNumber
Hash
(
const
KeyType
&
aKey
)
{
return
aKey
-
1
;
}
static
bool
Match
(
const
KeyType
&
aKey
const
ValueType
&
aVal
)
{
return
aKey
=
=
(
KeyType
)
aVal
;
}
}
;
struct
StringStruct
{
nsCString
mKey
;
nsCString
mOther
;
}
;
struct
StringStructMap
:
public
MruCache
<
nsCString
StringStruct
StringStructMap
>
{
static
HashNumber
Hash
(
const
KeyType
&
aKey
)
{
return
*
aKey
.
BeginReading
(
)
-
1
;
}
static
bool
Match
(
const
KeyType
&
aKey
const
ValueType
&
aVal
)
{
return
aKey
=
=
aVal
.
mKey
;
}
}
;
template
<
typename
T
>
struct
Convertable
{
T
mItem
;
operator
T
(
)
const
{
return
mItem
;
}
}
;
nsCString
MakeStringKey
(
char
aKey
)
{
nsCString
key
;
key
.
Append
(
aKey
)
;
return
key
;
}
TEST
(
MruCache
TestNullChecker
)
{
using
mozilla
:
:
detail
:
:
EmptyChecker
;
{
int
test
=
0
;
EXPECT_TRUE
(
EmptyChecker
<
decltype
(
test
)
>
:
:
IsNotEmpty
(
test
)
)
;
test
=
42
;
EXPECT_TRUE
(
EmptyChecker
<
decltype
(
test
)
>
:
:
IsNotEmpty
(
test
)
)
;
}
{
const
char
*
test
=
"
abc
"
;
EXPECT_TRUE
(
EmptyChecker
<
decltype
(
test
)
>
:
:
IsNotEmpty
(
test
)
)
;
test
=
nullptr
;
EXPECT_FALSE
(
EmptyChecker
<
decltype
(
test
)
>
:
:
IsNotEmpty
(
test
)
)
;
}
{
int
foo
=
42
;
int
*
test
=
&
foo
;
EXPECT_TRUE
(
EmptyChecker
<
decltype
(
test
)
>
:
:
IsNotEmpty
(
test
)
)
;
test
=
nullptr
;
EXPECT_FALSE
(
EmptyChecker
<
decltype
(
test
)
>
:
:
IsNotEmpty
(
test
)
)
;
}
}
TEST
(
MruCache
TestEmptyCache
)
{
{
IntMap
mru
;
for
(
int
i
=
1
;
i
<
32
;
i
+
+
)
{
auto
p
=
mru
.
Lookup
(
i
)
;
EXPECT_FALSE
(
p
)
;
}
}
{
UintPtrMap
mru
;
for
(
uintptr_t
i
=
1
;
i
<
32
;
i
+
+
)
{
auto
p
=
mru
.
Lookup
(
i
)
;
EXPECT_FALSE
(
p
)
;
}
}
{
StringStructMap
mru
;
for
(
char
i
=
1
;
i
<
32
;
i
+
+
)
{
const
nsCString
key
=
MakeStringKey
(
i
)
;
auto
p
=
mru
.
Lookup
(
key
)
;
EXPECT_FALSE
(
p
)
;
}
}
}
TEST
(
MruCache
TestPut
)
{
IntMap
mru
;
for
(
int
i
=
1
;
i
<
32
;
i
+
+
)
{
mru
.
Put
(
i
i
)
;
}
for
(
int
i
=
1
;
i
<
32
;
i
+
+
)
{
auto
p
=
mru
.
Lookup
(
i
)
;
EXPECT_TRUE
(
p
)
;
EXPECT_EQ
(
p
.
Data
(
)
i
)
;
}
}
TEST
(
MruCache
TestPutConvertable
)
{
UintPtrMap
mru
;
for
(
uintptr_t
i
=
1
;
i
<
32
;
i
+
+
)
{
Convertable
<
int
*
>
val
{
(
int
*
)
i
}
;
mru
.
Put
(
i
val
)
;
}
for
(
uintptr_t
i
=
1
;
i
<
32
;
i
+
+
)
{
auto
p
=
mru
.
Lookup
(
i
)
;
EXPECT_TRUE
(
p
)
;
EXPECT_EQ
(
p
.
Data
(
)
(
int
*
)
i
)
;
}
}
TEST
(
MruCache
TestOverwriting
)
{
IntMap
mru
;
for
(
int
i
=
1
;
i
<
63
;
i
+
+
)
{
mru
.
Put
(
i
i
)
;
}
for
(
int
i
=
32
;
i
<
63
;
i
+
+
)
{
auto
p
=
mru
.
Lookup
(
i
)
;
EXPECT_TRUE
(
p
)
;
EXPECT_EQ
(
p
.
Data
(
)
i
)
;
}
}
TEST
(
MruCache
TestRemove
)
{
{
IntMap
mru
;
for
(
int
i
=
1
;
i
<
32
;
i
+
+
)
{
mru
.
Put
(
i
i
)
;
}
for
(
int
i
=
1
;
i
<
32
;
i
+
+
)
{
auto
p
=
mru
.
Lookup
(
i
)
;
EXPECT_TRUE
(
p
)
;
mru
.
Remove
(
i
)
;
p
=
mru
.
Lookup
(
i
)
;
EXPECT_FALSE
(
p
)
;
}
}
{
UintPtrMap
mru
;
for
(
uintptr_t
i
=
1
;
i
<
32
;
i
+
+
)
{
mru
.
Put
(
i
(
int
*
)
i
)
;
}
for
(
uintptr_t
i
=
1
;
i
<
32
;
i
+
+
)
{
auto
p
=
mru
.
Lookup
(
i
)
;
EXPECT_TRUE
(
p
)
;
mru
.
Remove
(
i
)
;
p
=
mru
.
Lookup
(
i
)
;
EXPECT_FALSE
(
p
)
;
}
}
{
StringStructMap
mru
;
for
(
char
i
=
1
;
i
<
32
;
i
+
+
)
{
const
nsCString
key
=
MakeStringKey
(
i
)
;
mru
.
Put
(
key
StringStruct
{
key
NS_LITERAL_CSTRING
(
"
foo
"
)
}
)
;
}
for
(
char
i
=
1
;
i
<
32
;
i
+
+
)
{
const
nsCString
key
=
MakeStringKey
(
i
)
;
auto
p
=
mru
.
Lookup
(
key
)
;
EXPECT_TRUE
(
p
)
;
mru
.
Remove
(
key
)
;
p
=
mru
.
Lookup
(
key
)
;
EXPECT_FALSE
(
p
)
;
}
}
}
TEST
(
MruCache
TestClear
)
{
IntMap
mru
;
for
(
int
i
=
1
;
i
<
32
;
i
+
+
)
{
mru
.
Put
(
i
i
)
;
}
mru
.
Clear
(
)
;
for
(
int
i
=
1
;
i
<
32
;
i
+
+
)
{
auto
p
=
mru
.
Lookup
(
i
)
;
EXPECT_FALSE
(
p
)
;
}
}
TEST
(
MruCache
TestLookupMissingAndSet
)
{
IntMap
mru
;
auto
p
=
mru
.
Lookup
(
1
)
;
EXPECT_FALSE
(
p
)
;
p
.
Set
(
1
)
;
EXPECT_TRUE
(
p
)
;
EXPECT_EQ
(
p
.
Data
(
)
1
)
;
p
=
mru
.
Lookup
(
1
)
;
EXPECT_TRUE
(
p
)
;
EXPECT_EQ
(
p
.
Data
(
)
1
)
;
p
=
mru
.
Lookup
(
2
)
;
EXPECT_FALSE
(
p
)
;
Convertable
<
int
>
val
{
2
}
;
p
.
Set
(
val
)
;
EXPECT_TRUE
(
p
)
;
EXPECT_EQ
(
p
.
Data
(
)
2
)
;
p
=
mru
.
Lookup
(
2
)
;
EXPECT_TRUE
(
p
)
;
EXPECT_EQ
(
p
.
Data
(
)
2
)
;
}
TEST
(
MruCache
TestLookupAndOverwrite
)
{
IntMap
mru
;
mru
.
Put
(
1
1
)
;
auto
p
=
mru
.
Lookup
(
32
)
;
EXPECT_FALSE
(
p
)
;
p
.
Set
(
32
)
;
EXPECT_TRUE
(
p
)
;
EXPECT_EQ
(
p
.
Data
(
)
32
)
;
p
=
mru
.
Lookup
(
1
)
;
EXPECT_FALSE
(
p
)
;
p
=
mru
.
Lookup
(
32
)
;
EXPECT_TRUE
(
p
)
;
EXPECT_EQ
(
p
.
Data
(
)
32
)
;
}
TEST
(
MruCache
TestLookupAndRemove
)
{
IntMap
mru
;
mru
.
Put
(
1
1
)
;
auto
p
=
mru
.
Lookup
(
1
)
;
EXPECT_TRUE
(
p
)
;
EXPECT_EQ
(
p
.
Data
(
)
1
)
;
p
.
Remove
(
)
;
EXPECT_FALSE
(
p
)
;
p
=
mru
.
Lookup
(
1
)
;
EXPECT_FALSE
(
p
)
;
}
TEST
(
MruCache
TestLookupNotMatchedAndRemove
)
{
IntMap
mru
;
mru
.
Put
(
1
1
)
;
auto
p
=
mru
.
Lookup
(
32
)
;
EXPECT_FALSE
(
p
)
;
p
.
Remove
(
)
;
p
=
mru
.
Lookup
(
1
)
;
EXPECT_TRUE
(
p
)
;
EXPECT_EQ
(
p
.
Data
(
)
1
)
;
}
TEST
(
MruCache
TestLookupAndSetWithMove
)
{
StringStructMap
mru
;
const
nsCString
key
=
MakeStringKey
(
(
char
)
1
)
;
StringStruct
val
{
key
NS_LITERAL_CSTRING
(
"
foo
"
)
}
;
auto
p
=
mru
.
Lookup
(
key
)
;
EXPECT_FALSE
(
p
)
;
p
.
Set
(
std
:
:
move
(
val
)
)
;
EXPECT_TRUE
(
p
.
Data
(
)
.
mKey
=
=
key
)
;
EXPECT_TRUE
(
p
.
Data
(
)
.
mOther
=
=
NS_LITERAL_CSTRING
(
"
foo
"
)
)
;
}
