#
include
"
gtest
/
gtest
.
h
"
#
include
"
Helpers
.
h
"
#
include
"
nsICloneableInputStream
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
nsISeekableStream
.
h
"
namespace
{
static
void
TestStringStream
(
uint32_t
aNumBytes
)
{
nsTArray
<
char
>
inputData
;
testing
:
:
CreateData
(
aNumBytes
inputData
)
;
nsDependentCSubstring
inputString
(
inputData
.
Elements
(
)
inputData
.
Length
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
stream
;
nsresult
rv
=
NS_NewCStringInputStream
(
getter_AddRefs
(
stream
)
inputString
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
testing
:
:
ConsumeAndValidateStream
(
stream
inputString
)
;
}
static
void
TestStringStreamClone
(
uint32_t
aNumBytes
)
{
nsTArray
<
char
>
inputData
;
testing
:
:
CreateData
(
aNumBytes
inputData
)
;
nsDependentCSubstring
inputString
(
inputData
.
Elements
(
)
inputData
.
Length
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
stream
;
nsresult
rv
=
NS_NewCStringInputStream
(
getter_AddRefs
(
stream
)
inputString
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
nsCOMPtr
<
nsICloneableInputStream
>
cloneable
=
do_QueryInterface
(
stream
)
;
ASSERT_TRUE
(
cloneable
!
=
nullptr
)
;
ASSERT_TRUE
(
cloneable
-
>
GetCloneable
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
clone
;
rv
=
cloneable
-
>
Clone
(
getter_AddRefs
(
clone
)
)
;
testing
:
:
ConsumeAndValidateStream
(
stream
inputString
)
;
stream
=
nullptr
;
testing
:
:
ConsumeAndValidateStream
(
clone
inputString
)
;
}
}
TEST
(
StringStream
Simple_4k
)
{
TestStringStream
(
1024
*
4
)
;
}
TEST
(
StringStream
Clone_4k
)
{
TestStringStreamClone
(
1024
*
4
)
;
}
static
nsresult
CloseStreamThenRead
(
nsIInputStream
*
aInStr
void
*
aClosure
const
char
*
aBuffer
uint32_t
aOffset
uint32_t
aCount
uint32_t
*
aCountWritten
)
{
nsresult
rv
=
aInStr
-
>
Close
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
char
*
newAlloc
=
moz_xstrdup
(
"
abcd
"
)
;
char
*
toBuf
=
static_cast
<
char
*
>
(
aClosure
)
;
memcpy
(
&
toBuf
[
aOffset
]
aBuffer
aCount
)
;
*
aCountWritten
=
aCount
;
free
(
newAlloc
)
;
return
NS_OK
;
}
TEST
(
StringStream
CancelInReadSegments
)
{
char
*
buffer
=
moz_xstrdup
(
"
test
"
)
;
nsCOMPtr
<
nsIInputStream
>
stream
;
nsresult
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
stream
)
mozilla
:
:
Span
(
buffer
5
)
NS_ASSIGNMENT_ADOPT
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
char
buf
[
100
]
;
uint32_t
count
=
0
;
uint64_t
available
=
0
;
rv
=
stream
-
>
Available
(
&
available
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
stream
-
>
ReadSegments
(
CloseStreamThenRead
buf
available
&
count
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_TRUE
(
count
=
=
5
)
;
ASSERT_TRUE
(
!
strcmp
(
buf
"
test
"
)
)
;
}
#
ifndef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
static
nsresult
ChangeStreamThenRead
(
nsIInputStream
*
aInStr
void
*
aClosure
const
char
*
aBuffer
uint32_t
aOffset
uint32_t
aCount
uint32_t
*
aCountWritten
)
{
nsCOMPtr
<
nsIStringInputStream
>
stream
=
do_QueryInterface
(
aInStr
)
;
char
*
newAlloc
=
moz_xstrdup
(
"
abcd
"
)
;
nsresult
rv
=
stream
-
>
AdoptData
(
newAlloc
5
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
char
*
toBuf
=
static_cast
<
char
*
>
(
aClosure
)
;
memcpy
(
&
toBuf
[
aOffset
]
aBuffer
aCount
)
;
*
aCountWritten
=
aCount
;
return
NS_OK
;
}
TEST
(
StringStream
ReplacedInReadSegments
)
{
char
*
buffer
=
moz_xstrdup
(
"
test
"
)
;
nsCOMPtr
<
nsIInputStream
>
stream
;
nsresult
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
stream
)
mozilla
:
:
Span
(
buffer
5
)
NS_ASSIGNMENT_ADOPT
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
char
buf
[
100
]
;
uint32_t
count
=
0
;
uint64_t
available
=
0
;
rv
=
stream
-
>
Available
(
&
available
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
stream
-
>
ReadSegments
(
ChangeStreamThenRead
buf
available
&
count
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_TRUE
(
count
=
=
5
)
;
ASSERT_TRUE
(
!
strcmp
(
buf
"
test
"
)
)
;
buf
[
0
]
=
'
\
0
'
;
count
=
0
;
available
=
0
;
nsCOMPtr
<
nsISeekableStream
>
seekable
=
do_QueryInterface
(
stream
)
;
rv
=
seekable
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
0
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
stream
-
>
Available
(
&
available
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
stream
-
>
ReadSegments
(
NS_CopySegmentToBuffer
buf
available
&
count
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_TRUE
(
count
=
=
5
)
;
ASSERT_TRUE
(
!
strcmp
(
buf
"
test
"
)
)
;
}
#
endif
