#
include
"
nsTArray
.
h
"
#
include
"
gtest
/
gtest
.
h
"
using
namespace
mozilla
;
namespace
TestTArray
{
struct
Copyable
{
Copyable
(
)
:
mDestructionCounter
(
nullptr
)
{
}
~
Copyable
(
)
{
if
(
mDestructionCounter
)
{
(
*
mDestructionCounter
)
+
+
;
}
}
Copyable
(
const
Copyable
&
)
=
default
;
Copyable
&
operator
=
(
const
Copyable
&
)
=
default
;
uint32_t
*
mDestructionCounter
;
}
;
struct
Movable
{
Movable
(
)
:
mDestructionCounter
(
nullptr
)
{
}
~
Movable
(
)
{
if
(
mDestructionCounter
)
{
(
*
mDestructionCounter
)
+
+
;
}
}
Movable
(
Movable
&
&
aOther
)
:
mDestructionCounter
(
aOther
.
mDestructionCounter
)
{
aOther
.
mDestructionCounter
=
nullptr
;
}
uint32_t
*
mDestructionCounter
;
}
;
}
template
<
>
struct
nsTArray_CopyChooser
<
TestTArray
:
:
Copyable
>
{
typedef
nsTArray_CopyWithConstructors
<
TestTArray
:
:
Copyable
>
Type
;
}
;
template
<
>
struct
nsTArray_CopyChooser
<
TestTArray
:
:
Movable
>
{
typedef
nsTArray_CopyWithConstructors
<
TestTArray
:
:
Movable
>
Type
;
}
;
namespace
TestTArray
{
const
nsTArray
<
int
>
&
DummyArray
(
)
{
static
nsTArray
<
int
>
sArray
;
if
(
sArray
.
IsEmpty
(
)
)
{
const
int
data
[
]
=
{
4
1
2
8
}
;
sArray
.
AppendElements
(
data
ArrayLength
(
data
)
)
;
}
return
sArray
;
}
#
ifdef
DEBUG
const
nsTArray
<
int
>
&
FakeHugeArray
(
)
{
static
nsTArray
<
int
>
sArray
;
if
(
sArray
.
IsEmpty
(
)
)
{
sArray
.
AppendElement
(
)
;
(
(
nsTArrayHeader
*
)
sArray
.
DebugGetHeader
(
)
)
-
>
mLength
=
UINT32_MAX
;
}
return
sArray
;
}
#
endif
TEST
(
TArray
AppendElementsRvalue
)
{
nsTArray
<
int
>
array
;
nsTArray
<
int
>
temp
(
DummyArray
(
)
)
;
array
.
AppendElements
(
std
:
:
move
(
temp
)
)
;
ASSERT_EQ
(
DummyArray
(
)
array
)
;
ASSERT_TRUE
(
temp
.
IsEmpty
(
)
)
;
temp
=
DummyArray
(
)
;
array
.
AppendElements
(
std
:
:
move
(
temp
)
)
;
nsTArray
<
int
>
expected
;
expected
.
AppendElements
(
DummyArray
(
)
)
;
expected
.
AppendElements
(
DummyArray
(
)
)
;
ASSERT_EQ
(
expected
array
)
;
ASSERT_TRUE
(
temp
.
IsEmpty
(
)
)
;
}
TEST
(
TArray
Assign
)
{
nsTArray
<
int
>
array
;
array
.
Assign
(
DummyArray
(
)
)
;
ASSERT_EQ
(
DummyArray
(
)
array
)
;
ASSERT_TRUE
(
array
.
Assign
(
DummyArray
(
)
fallible
)
)
;
ASSERT_EQ
(
DummyArray
(
)
array
)
;
#
ifdef
DEBUG
ASSERT_FALSE
(
array
.
Assign
(
FakeHugeArray
(
)
fallible
)
)
;
#
endif
nsTArray
<
int
>
array2
;
array2
.
Assign
(
std
:
:
move
(
array
)
)
;
ASSERT_TRUE
(
array
.
IsEmpty
(
)
)
;
ASSERT_EQ
(
DummyArray
(
)
array2
)
;
}
TEST
(
TArray
AssignmentOperatorSelfAssignment
)
{
nsTArray
<
int
>
array
;
array
=
DummyArray
(
)
;
array
=
*
&
array
;
ASSERT_EQ
(
DummyArray
(
)
array
)
;
array
=
std
:
:
move
(
array
)
;
ASSERT_EQ
(
DummyArray
(
)
array
)
;
}
TEST
(
TArray
CopyOverlappingForwards
)
{
const
size_t
rangeLength
=
8
;
const
size_t
initialLength
=
2
*
rangeLength
;
uint32_t
destructionCounters
[
initialLength
]
;
nsTArray
<
Movable
>
array
;
array
.
AppendElements
(
initialLength
)
;
for
(
uint32_t
i
=
0
;
i
<
initialLength
;
+
+
i
)
{
destructionCounters
[
i
]
=
0
;
}
for
(
uint32_t
i
=
0
;
i
<
initialLength
;
+
+
i
)
{
array
[
i
]
.
mDestructionCounter
=
&
destructionCounters
[
i
]
;
}
const
size_t
removedLength
=
rangeLength
/
2
;
array
.
RemoveElementsAt
(
0
removedLength
)
;
for
(
uint32_t
i
=
0
;
i
<
removedLength
;
+
+
i
)
{
ASSERT_EQ
(
destructionCounters
[
i
]
1u
)
;
}
for
(
uint32_t
i
=
removedLength
;
i
<
initialLength
;
+
+
i
)
{
ASSERT_EQ
(
destructionCounters
[
i
]
0u
)
;
}
}
TEST
(
TArray
CopyOverlappingBackwards
)
{
const
size_t
rangeLength
=
8
;
const
size_t
initialLength
=
2
*
rangeLength
;
uint32_t
destructionCounters
[
initialLength
]
;
nsTArray
<
Copyable
>
array
;
array
.
SetCapacity
(
3
*
rangeLength
)
;
array
.
AppendElements
(
initialLength
)
;
for
(
uint32_t
i
=
0
;
i
<
initialLength
;
+
+
i
)
{
destructionCounters
[
i
]
=
0
;
}
for
(
uint32_t
i
=
0
;
i
<
initialLength
;
+
+
i
)
{
array
[
i
]
.
mDestructionCounter
=
&
destructionCounters
[
i
]
;
}
array
.
InsertElementsAt
(
0
rangeLength
)
;
for
(
uint32_t
i
=
0
;
i
<
initialLength
;
+
+
i
)
{
ASSERT_EQ
(
destructionCounters
[
i
]
1u
)
;
}
}
TEST
(
TArray
UnorderedRemoveElements
)
{
{
nsTArray
<
int
>
array
{
1
2
3
}
;
array
.
UnorderedRemoveElementAt
(
2
)
;
nsTArray
<
int
>
goal
{
1
2
}
;
ASSERT_EQ
(
array
goal
)
;
}
{
nsTArray
<
int
>
array
{
1
2
3
4
5
6
}
;
array
.
UnorderedRemoveElementAt
(
1
)
;
nsTArray
<
int
>
goal
{
1
6
3
4
5
}
;
ASSERT_EQ
(
array
goal
)
;
}
{
nsTArray
<
int
>
array
{
1
2
3
4
5
6
}
;
array
.
UnorderedRemoveElementsAt
(
2
4
)
;
nsTArray
<
int
>
goal
{
1
2
}
;
ASSERT_EQ
(
array
goal
)
;
}
{
nsTArray
<
int
>
array
{
1
2
3
4
5
6
7
8
}
;
array
.
UnorderedRemoveElementsAt
(
2
4
)
;
nsTArray
<
int
>
goal
{
1
2
7
8
}
;
ASSERT_EQ
(
array
goal
)
;
}
{
nsTArray
<
int
>
array
{
1
2
3
4
5
6
7
8
}
;
array
.
UnorderedRemoveElementsAt
(
1
2
)
;
nsTArray
<
int
>
goal
{
1
7
8
4
5
6
}
;
ASSERT_EQ
(
array
goal
)
;
}
{
nsTArray
<
int
>
array
{
1
2
3
4
5
}
;
array
.
UnorderedRemoveElementsAt
(
0
5
)
;
nsTArray
<
int
>
goal
{
}
;
ASSERT_EQ
(
array
goal
)
;
}
{
nsTArray
<
int
>
array
{
1
}
;
array
.
UnorderedRemoveElementAt
(
0
)
;
nsTArray
<
int
>
goal
{
}
;
ASSERT_EQ
(
array
goal
)
;
}
{
nsTArray
<
int
>
array
{
1
2
3
4
5
6
}
;
array
.
UnorderedRemoveElementsAt
(
2
2
)
;
nsTArray
<
int
>
goal
{
1
2
5
6
}
;
ASSERT_EQ
(
array
goal
)
;
}
{
nsTArray
<
int
>
array
{
1
2
3
}
;
array
.
UnorderedRemoveElementAt
(
1
)
;
nsTArray
<
int
>
goal
{
1
3
}
;
ASSERT_EQ
(
array
goal
)
;
}
{
nsTArray
<
int
>
array
{
1
2
3
4
5
6
}
;
array
.
UnorderedRemoveElementsAt
(
0
2
)
;
nsTArray
<
int
>
goal
{
5
6
3
4
}
;
ASSERT_EQ
(
array
goal
)
;
}
{
nsTArray
<
int
>
array
{
1
2
3
4
}
;
array
.
UnorderedRemoveElementAt
(
0
)
;
nsTArray
<
int
>
goal
{
4
2
3
}
;
ASSERT_EQ
(
array
goal
)
;
}
}
TEST
(
TArray
RemoveFromEnd
)
{
{
nsTArray
<
int
>
array
{
1
2
3
4
}
;
ASSERT_EQ
(
array
.
PopLastElement
(
)
4
)
;
array
.
RemoveLastElement
(
)
;
ASSERT_EQ
(
array
.
PopLastElement
(
)
2
)
;
array
.
RemoveLastElement
(
)
;
ASSERT_TRUE
(
array
.
IsEmpty
(
)
)
;
}
}
}
