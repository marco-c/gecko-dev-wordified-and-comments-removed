#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
gtest
/
WaitFor
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
mozilla
/
SynchronizedEventQueue
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
VideoUtils
.
h
"
namespace
TestStateMirroring
{
using
namespace
mozilla
;
class
StateMirroringTest
:
public
:
:
testing
:
:
Test
{
public
:
using
ValueType
=
int
;
using
Promise
=
MozPromise
<
ValueType
bool
true
>
;
StateMirroringTest
(
)
:
mTarget
(
TaskQueue
:
:
Create
(
GetMediaThreadPool
(
MediaThreadType
:
:
SUPERVISOR
)
"
TestStateMirroring
"
true
)
)
mCanonical
(
AbstractThread
:
:
GetCurrent
(
)
0
"
TestCanonical
"
)
mMirror
(
mTarget
0
"
TestMirror
"
)
{
}
void
TearDown
(
)
override
{
mTarget
-
>
BeginShutdown
(
)
;
mTarget
-
>
AwaitShutdownAndIdle
(
)
;
NS_ProcessPendingEvents
(
nullptr
)
;
}
RefPtr
<
Promise
>
ReadMirrorAsync
(
)
{
return
InvokeAsync
(
mTarget
__func__
[
&
]
{
return
Promise
:
:
CreateAndResolve
(
mMirror
"
ReadMirrorAsync
:
:
Resolve
"
)
;
}
)
;
}
protected
:
const
RefPtr
<
TaskQueue
>
mTarget
;
Canonical
<
int
>
mCanonical
;
Mirror
<
int
>
mMirror
;
}
;
TEST_F
(
StateMirroringTest
MirrorInitiatedEventOrdering
)
{
ASSERT_FALSE
(
AbstractThread
:
:
GetCurrent
(
)
-
>
IsTailDispatcherAvailable
(
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchAndSpinEventLoopUntilComplete
(
"
NeedTailDispatcher
"
_ns
GetCurrentSerialEventTarget
(
)
NS_NewRunnableFunction
(
__func__
[
&
]
{
ASSERT_TRUE
(
AbstractThread
:
:
GetCurrent
(
)
-
>
IsTailDispatcherAvailable
(
)
)
;
RefPtr
<
Promise
>
mirrorPromise
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchAndSpinEventLoopUntilComplete
(
"
NeedTailDispatcher
"
_ns
GetCurrentSerialEventTarget
(
)
NS_NewRunnableFunction
(
__func__
[
&
]
{
MOZ_ALWAYS_SUCCEEDS
(
mTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
&
]
{
mMirror
.
Connect
(
&
mCanonical
)
;
}
)
)
)
;
mCanonical
=
1
;
mirrorPromise
=
ReadMirrorAsync
(
)
;
}
)
)
)
;
mTarget
-
>
AwaitIdle
(
)
;
NS_ProcessPendingEvents
(
nullptr
)
;
EXPECT_EQ
(
WaitFor
(
mirrorPromise
)
.
unwrap
(
)
0
)
;
mCanonical
=
2
;
EXPECT_EQ
(
WaitFor
(
ReadMirrorAsync
(
)
)
.
unwrap
(
)
2
)
;
MOZ_ALWAYS_SUCCEEDS
(
mTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
&
]
{
mMirror
.
DisconnectIfConnected
(
)
;
}
)
)
)
;
}
)
)
)
;
}
TEST_F
(
StateMirroringTest
CanonicalInitiatedEventOrdering
)
{
ASSERT_FALSE
(
AbstractThread
:
:
GetCurrent
(
)
-
>
IsTailDispatcherAvailable
(
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchAndSpinEventLoopUntilComplete
(
"
NeedTailDispatcher
"
_ns
GetCurrentSerialEventTarget
(
)
NS_NewRunnableFunction
(
__func__
[
&
]
{
ASSERT_TRUE
(
AbstractThread
:
:
GetCurrent
(
)
-
>
IsTailDispatcherAvailable
(
)
)
;
mCanonical
.
ConnectMirror
(
&
mMirror
)
;
mCanonical
=
1
;
EXPECT_EQ
(
WaitFor
(
ReadMirrorAsync
(
)
)
.
unwrap
(
)
1
)
;
mCanonical
.
DisconnectAll
(
)
;
}
)
)
)
;
}
}
