#
include
"
gtest
/
gtest
.
h
"
#
include
<
minwindef
.
h
>
#
include
<
handleapi
.
h
>
#
include
<
synchapi
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ErrorNames
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
TargetShutdownTaskSet
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
WinHandleWatcher
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsITargetShutdownTask
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsIThreadShutdown
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
details
{
static
nsCString
MakeTargetName
(
const
char
*
name
)
{
const
char
*
testName
=
:
:
testing
:
:
UnitTest
:
:
GetInstance
(
)
-
>
current_test_info
(
)
-
>
name
(
)
;
nsCString
ret
;
ret
.
AppendPrintf
(
"
%
s
:
%
s
"
testName
name
)
;
return
ret
;
}
}
using
HandleWatcher
=
mozilla
:
:
HandleWatcher
;
[
[
noreturn
]
]
void
nsresult_fatal_err_
(
const
char
*
file
size_t
line
const
char
*
expr
nsresult
res
)
{
MOZ_Crash
(
file
static_cast
<
int
>
(
line
)
MOZ_CrashPrintf
(
"
%
s
gave
nsresult
%
s
(
%
"
PRIX32
"
)
"
expr
mozilla
:
:
GetStaticErrorName
(
res
)
uint32_t
(
res
)
)
)
;
}
template
<
typename
T
>
T
unwrap_impl_
(
const
char
*
file
size_t
line
const
char
*
expr
mozilla
:
:
Result
<
T
nsresult
>
res
)
{
if
(
MOZ_LIKELY
(
res
.
isOk
(
)
)
)
{
return
res
.
unwrap
(
)
;
}
nsresult_fatal_err_
(
file
line
expr
res
.
unwrapErr
(
)
)
;
}
#
define
UNWRAP
(
expr
)
unwrap_impl_
(
__FILE__
__LINE__
#
expr
expr
)
static
mozilla
:
:
TimeDuration
Milliseconds
(
double
d
)
{
return
mozilla
:
:
TimeDuration
:
:
FromMilliseconds
(
d
)
;
}
class
TestHandleWatcher
:
public
testing
:
:
Test
{
protected
:
static
void
SetUpTestSuite
(
)
{
sIsLive
=
true
;
}
static
void
TearDownTestSuite
(
)
{
sPool
=
nullptr
;
sIsLive
=
false
;
}
public
:
static
already_AddRefed
<
mozilla
:
:
SharedThreadPool
>
GetPool
(
)
{
AssertIsLive
(
)
;
if
(
!
sPool
)
{
sPool
=
mozilla
:
:
SharedThreadPool
:
:
Get
(
"
Test
Pool
"
_ns
)
;
}
return
do_AddRef
(
sPool
)
;
}
private
:
static
bool
sIsLive
;
static
void
AssertIsLive
(
)
{
MOZ_RELEASE_ASSERT
(
sIsLive
"
attempted
to
use
class
TestHandleWatcher
outside
test
group
"
)
;
}
static
RefPtr
<
mozilla
:
:
SharedThreadPool
>
sPool
;
}
;
bool
TestHandleWatcher
:
:
sIsLive
=
false
;
MOZ_RUNINIT
RefPtr
<
mozilla
:
:
SharedThreadPool
>
TestHandleWatcher
:
:
sPool
=
nullptr
;
struct
WindowsEventObject
{
HANDLE
const
handle
=
:
:
CreateEvent
(
nullptr
TRUE
FALSE
nullptr
)
;
WindowsEventObject
(
)
=
default
;
~
WindowsEventObject
(
)
{
:
:
CloseHandle
(
handle
)
;
}
WindowsEventObject
(
WindowsEventObject
const
&
)
=
delete
;
WindowsEventObject
(
WindowsEventObject
&
&
)
=
delete
;
WindowsEventObject
&
operator
=
(
WindowsEventObject
const
&
)
=
delete
;
WindowsEventObject
&
operator
=
(
WindowsEventObject
&
&
)
=
delete
;
void
Set
(
)
{
:
:
SetEvent
(
handle
)
;
}
}
;
nsCOMPtr
<
nsIThread
>
SpawnNewThread
(
const
char
*
name
)
{
nsCOMPtr
<
nsIThread
>
thread
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewNamedThread
(
details
:
:
MakeTargetName
(
name
)
getter_AddRefs
(
thread
)
)
)
;
return
thread
;
}
RefPtr
<
mozilla
:
:
TaskQueue
>
SpawnNewBackgroundQueue
(
)
{
return
mozilla
:
:
TaskQueue
:
:
Create
(
TestHandleWatcher
:
:
GetPool
(
)
"
task
queue
for
TestHandleWatcher
"
)
;
}
struct
SpinEventLoopUntilRet
{
enum
Value
{
Ok
TimedOut
InternalError
}
value
;
bool
ok
(
)
const
{
return
value
=
=
Value
:
:
Ok
;
}
bool
timedOut
(
)
const
{
return
value
=
=
Value
:
:
TimedOut
;
}
MOZ_IMPLICIT
SpinEventLoopUntilRet
(
Value
v
)
:
value
(
v
)
{
}
}
;
template
<
typename
Predicate
>
SpinEventLoopUntilRet
SpinEventLoopUntil
(
Predicate
const
&
aPredicate
mozilla
:
:
TimeDuration
aDuration
=
Milliseconds
(
500
)
)
{
using
Value
=
SpinEventLoopUntilRet
:
:
Value
;
nsIThread
*
currentThread
=
NS_GetCurrentThread
(
)
;
bool
timedOut
=
false
;
auto
timer
=
UNWRAP
(
NS_NewTimerWithCallback
(
[
&
]
(
nsITimer
*
)
{
timedOut
=
true
;
}
aDuration
nsITimer
:
:
TYPE_ONE_SHOT
"
SpinEventLoop
timer
"
_ns
currentThread
)
)
;
auto
onExitCancelTimer
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
timer
-
>
Cancel
(
)
;
}
)
;
bool
const
ret
=
mozilla
:
:
SpinEventLoopUntil
(
"
TestHandleWatcher
"
_ns
[
&
]
{
return
timedOut
|
|
aPredicate
(
)
;
}
)
;
if
(
!
ret
)
return
Value
:
:
InternalError
;
if
(
timedOut
)
return
Value
:
:
TimedOut
;
return
Value
:
:
Ok
;
}
TEST_F
(
TestHandleWatcher
SpinEventLoopUntil
)
{
auto
should_fail
=
SpinEventLoopUntil
(
[
]
{
return
false
;
}
Milliseconds
(
1
)
)
;
ASSERT_TRUE
(
should_fail
.
timedOut
(
)
)
;
auto
should_pass
=
SpinEventLoopUntil
(
[
]
{
return
true
;
}
Milliseconds
(
50
)
)
;
ASSERT_TRUE
(
should_pass
.
ok
(
)
)
;
}
void
PingMainThread
(
)
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
Ping
"
[
]
{
}
)
)
)
;
}
TEST_F
(
TestHandleWatcher
Trivial
)
{
HandleWatcher
hw
;
}
TEST_F
(
TestHandleWatcher
Empty
)
{
HandleWatcher
hw
;
ASSERT_TRUE
(
hw
.
IsStopped
(
)
)
;
hw
.
Stop
(
)
;
}
TEST_F
(
TestHandleWatcher
Simple
)
{
WindowsEventObject
event
;
HandleWatcher
hw
;
std
:
:
atomic
<
bool
>
run
=
false
;
hw
.
Watch
(
event
.
handle
NS_GetCurrentThread
(
)
NS_NewRunnableFunction
(
"
TestHandleWatcher
:
:
Simple
"
[
&
]
{
run
=
true
;
}
)
)
;
ASSERT_FALSE
(
run
.
load
(
)
)
;
event
.
Set
(
)
;
:
:
Sleep
(
0
)
;
ASSERT_FALSE
(
run
.
load
(
)
)
;
ASSERT_TRUE
(
SpinEventLoopUntil
(
[
&
]
{
return
run
.
load
(
)
;
}
)
.
ok
(
)
)
;
}
TEST_F
(
TestHandleWatcher
Stop
)
{
WindowsEventObject
event
;
HandleWatcher
hw
;
std
:
:
atomic
<
bool
>
run
=
false
;
hw
.
Watch
(
event
.
handle
NS_GetCurrentThread
(
)
NS_NewRunnableFunction
(
"
TestHandleWatcher
:
:
Stop
"
[
&
]
{
run
=
true
;
}
)
)
;
ASSERT_FALSE
(
hw
.
IsStopped
(
)
)
;
hw
.
Stop
(
)
;
ASSERT_TRUE
(
hw
.
IsStopped
(
)
)
;
ASSERT_TRUE
(
SpinEventLoopUntil
(
[
&
]
{
return
run
.
load
(
)
;
}
Milliseconds
(
25
)
)
.
timedOut
(
)
)
;
}
TEST_F
(
TestHandleWatcher
TargetDestroyed
)
{
WindowsEventObject
event
;
HandleWatcher
hw
;
bool
run
=
false
;
auto
queue
=
SpawnNewThread
(
"
target
thread
"
)
;
hw
.
Watch
(
event
.
handle
queue
.
get
(
)
NS_NewRunnableFunction
(
"
never
called
"
[
&
]
{
run
=
true
;
}
)
)
;
ASSERT_FALSE
(
hw
.
IsStopped
(
)
)
;
queue
-
>
Shutdown
(
)
;
ASSERT_TRUE
(
hw
.
IsStopped
(
)
)
;
ASSERT_FALSE
(
run
)
;
}
TEST_F
(
TestHandleWatcher
Rewatch
)
{
WindowsEventObject
event
;
HandleWatcher
hw
;
bool
b1
=
false
;
bool
b2
=
false
;
{
auto
queue
=
SpawnNewThread
(
"
target
thread
"
)
;
hw
.
Watch
(
event
.
handle
queue
.
get
(
)
NS_NewRunnableFunction
(
"
b1
"
[
&
]
{
b1
=
true
;
PingMainThread
(
)
;
}
)
)
;
hw
.
Watch
(
event
.
handle
queue
.
get
(
)
NS_NewRunnableFunction
(
"
b2
"
[
&
]
{
b2
=
true
;
PingMainThread
(
)
;
}
)
)
;
event
.
Set
(
)
;
ASSERT_TRUE
(
SpinEventLoopUntil
(
[
&
]
{
return
b1
|
|
b2
;
}
)
.
ok
(
)
)
;
queue
-
>
Shutdown
(
)
;
}
ASSERT_FALSE
(
b1
)
;
ASSERT_TRUE
(
b2
)
;
}
TEST_F
(
TestHandleWatcher
Presignalled
)
{
WindowsEventObject
event
;
HandleWatcher
hw
;
bool
run
=
false
;
event
.
Set
(
)
;
hw
.
Watch
(
event
.
handle
NS_GetCurrentThread
(
)
NS_NewRunnableFunction
(
"
TestHandleWatcher
:
:
Presignalled
"
[
&
]
{
run
=
true
;
}
)
)
;
ASSERT_TRUE
(
SpinEventLoopUntil
(
[
&
]
{
return
run
;
}
)
.
ok
(
)
)
;
}
struct
ActivationTestSetup
{
enum
TargetType
{
Main
Side
Background
}
;
WindowsEventObject
event
;
HandleWatcher
watcher
;
std
:
:
atomic
<
bool
>
run
=
false
;
nsCOMPtr
<
nsIThread
>
sideThread
;
nsCOMPtr
<
nsISerialEventTarget
>
backgroundQueue
;
private
:
nsIEventTarget
*
GetQueue
(
TargetType
targetTyoe
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
switch
(
targetTyoe
)
{
case
TargetType
:
:
Main
:
return
NS_GetCurrentThread
(
)
;
case
TargetType
:
:
Side
:
{
if
(
!
sideThread
)
{
sideThread
=
SpawnNewThread
(
"
side
thread
"
)
;
}
return
sideThread
;
}
case
TargetType
:
:
Background
:
{
if
(
!
backgroundQueue
)
{
backgroundQueue
=
SpawnNewBackgroundQueue
(
)
;
}
return
backgroundQueue
.
get
(
)
;
}
}
}
void
OnSignaled
(
)
{
run
=
true
;
PingMainThread
(
)
;
}
public
:
void
Setup
(
TargetType
from
TargetType
to
)
{
watcher
.
Watch
(
event
.
handle
GetQueue
(
to
)
NS_NewRunnableFunction
(
"
Reaction
"
[
this
]
{
this
-
>
OnSignaled
(
)
;
}
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
GetQueue
(
from
)
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
Action
"
[
this
]
{
event
.
Set
(
)
;
}
)
)
)
;
}
bool
Execute
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
const
spin
=
SpinEventLoopUntil
(
[
this
]
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
return
run
.
load
(
)
;
}
)
.
ok
(
)
;
return
spin
&
&
watcher
.
IsStopped
(
)
;
}
~
ActivationTestSetup
(
)
{
watcher
.
Stop
(
)
;
}
}
;
#
define
MOZ_HANDLEWATCHER_GTEST_FROM_TO
(
FROM
TO
)
\
TEST_F
(
TestHandleWatcher
FROM
#
#
To
#
#
TO
)
{
\
ActivationTestSetup
s
;
\
s
.
Setup
(
ActivationTestSetup
:
:
TargetType
:
:
FROM
\
ActivationTestSetup
:
:
TargetType
:
:
TO
)
;
\
ASSERT_TRUE
(
s
.
Execute
(
)
)
;
\
}
MOZ_HANDLEWATCHER_GTEST_FROM_TO
(
Main
Main
)
;
MOZ_HANDLEWATCHER_GTEST_FROM_TO
(
Main
Side
)
;
MOZ_HANDLEWATCHER_GTEST_FROM_TO
(
Main
Background
)
;
MOZ_HANDLEWATCHER_GTEST_FROM_TO
(
Side
Main
)
;
MOZ_HANDLEWATCHER_GTEST_FROM_TO
(
Side
Side
)
;
MOZ_HANDLEWATCHER_GTEST_FROM_TO
(
Side
Background
)
;
MOZ_HANDLEWATCHER_GTEST_FROM_TO
(
Background
Main
)
;
MOZ_HANDLEWATCHER_GTEST_FROM_TO
(
Background
Side
)
;
MOZ_HANDLEWATCHER_GTEST_FROM_TO
(
Background
Background
)
;
namespace
{
class
MockEventTarget
final
:
public
nsIEventTarget
{
NS_DECL_THREADSAFE_ISUPPORTS
private
:
TargetShutdownTaskSet
mShutdownTasks
;
std
:
:
function
<
void
(
void
)
>
mDeathAction
;
~
MockEventTarget
(
)
{
auto
shutdownTasks
=
mShutdownTasks
.
Extract
(
)
;
for
(
const
auto
&
task
:
shutdownTasks
)
{
task
-
>
TargetShutdown
(
)
;
}
if
(
mDeathAction
)
{
mDeathAction
(
)
;
}
}
public
:
NS_IMETHOD
RegisterShutdownTask
(
nsITargetShutdownTask
*
task
)
override
{
return
mShutdownTasks
.
AddTask
(
task
)
;
}
NS_IMETHOD
UnregisterShutdownTask
(
nsITargetShutdownTask
*
task
)
override
{
return
mShutdownTasks
.
RemoveTask
(
task
)
;
}
void
RegisterDeathAction
(
std
:
:
function
<
void
(
void
)
>
&
&
f
)
{
mDeathAction
=
std
:
:
move
(
f
)
;
}
NS_IMETHOD_
(
bool
)
IsOnCurrentThreadInfallible
(
void
)
{
return
false
;
}
NS_IMETHOD
IsOnCurrentThread
(
bool
*
_retval
)
{
*
_retval
=
false
;
return
NS_OK
;
}
NS_IMETHOD
Dispatch
(
already_AddRefed
<
nsIRunnable
>
DispatchFlags
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
DispatchFromScript
(
nsIRunnable
*
DispatchFlags
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
uint32_t
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
}
;
NS_IMPL_ISUPPORTS
(
MockEventTarget
nsIEventTarget
)
}
TEST_F
(
TestHandleWatcher
TargetDestructionRecurrency
)
{
WindowsEventObject
e1
e2
;
bool
b1
=
false
b2
=
false
;
HandleWatcher
hw
;
{
RefPtr
<
MockEventTarget
>
p
=
mozilla
:
:
MakeRefPtr
<
MockEventTarget
>
(
)
;
hw
.
Watch
(
e1
.
handle
p
.
get
(
)
NS_NewRunnableFunction
(
"
first
callback
"
[
&
]
{
b1
=
true
;
PingMainThread
(
)
;
}
)
)
;
p
-
>
RegisterDeathAction
(
[
&
]
{
hw
.
Watch
(
e2
.
handle
mozilla
:
:
GetMainThreadSerialEventTarget
(
)
NS_NewRunnableFunction
(
"
second
callback
"
[
&
]
{
b2
=
true
;
}
)
)
;
}
)
;
}
ASSERT_FALSE
(
hw
.
IsStopped
(
)
)
;
hw
.
Stop
(
)
;
ASSERT_FALSE
(
hw
.
IsStopped
(
)
)
;
e1
.
Set
(
)
;
e2
.
Set
(
)
;
ASSERT_TRUE
(
SpinEventLoopUntil
(
[
&
]
{
return
b1
|
|
b2
;
}
)
.
ok
(
)
)
;
ASSERT_FALSE
(
b1
)
;
ASSERT_TRUE
(
b2
)
;
}
namespace
{
class
MockRunnable
final
:
public
nsIRunnable
{
NS_DECL_THREADSAFE_ISUPPORTS
NS_IMETHOD
Run
(
)
override
{
MOZ_CRASH
(
"
MockRunnable
was
invoked
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
std
:
:
function
<
void
(
void
)
>
mDeathAction
;
public
:
void
RegisterDeathAction
(
std
:
:
function
<
void
(
void
)
>
&
&
f
)
{
mDeathAction
=
std
:
:
move
(
f
)
;
}
private
:
~
MockRunnable
(
)
{
if
(
mDeathAction
)
{
mDeathAction
(
)
;
}
}
}
;
NS_IMPL_ISUPPORTS
(
MockRunnable
nsIRunnable
)
}
TEST_F
(
TestHandleWatcher
TaskDestructionRecurrency
)
{
WindowsEventObject
e1
e2
;
bool
run
=
false
;
HandleWatcher
hw
;
auto
thread
=
SpawnNewBackgroundQueue
(
)
;
{
RefPtr
<
MockRunnable
>
runnable
=
mozilla
:
:
MakeRefPtr
<
MockRunnable
>
(
)
;
runnable
-
>
RegisterDeathAction
(
[
&
]
{
hw
.
Watch
(
e2
.
handle
thread
NS_NewRunnableFunction
(
"
callback
"
[
&
]
{
run
=
true
;
PingMainThread
(
)
;
}
)
)
;
}
)
;
hw
.
Watch
(
e1
.
handle
thread
.
get
(
)
runnable
.
forget
(
)
)
;
}
ASSERT_FALSE
(
hw
.
IsStopped
(
)
)
;
hw
.
Stop
(
)
;
ASSERT_FALSE
(
hw
.
IsStopped
(
)
)
;
e1
.
Set
(
)
;
ASSERT_TRUE
(
SpinEventLoopUntil
(
[
&
]
{
return
false
;
}
Milliseconds
(
10
)
)
.
timedOut
(
)
)
;
e2
.
Set
(
)
;
ASSERT_TRUE
(
SpinEventLoopUntil
(
[
&
]
{
return
run
;
}
)
.
ok
(
)
)
;
ASSERT_TRUE
(
run
)
;
}
