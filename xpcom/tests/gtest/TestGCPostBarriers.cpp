#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
HeapAPI
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
using
namespace
JS
;
using
namespace
mozilla
;
template
<
class
ArrayT
>
static
void
TraceArray
(
JSTracer
*
trc
void
*
data
)
{
ArrayT
*
array
=
static_cast
<
ArrayT
*
>
(
data
)
;
for
(
unsigned
i
=
0
;
i
<
array
-
>
Length
(
)
;
+
+
i
)
JS
:
:
TraceEdge
(
trc
&
array
-
>
ElementAt
(
i
)
"
array
-
element
"
)
;
}
const
size_t
ElementCount
=
100
;
const
size_t
InitialElements
=
ElementCount
/
10
;
template
<
class
ArrayT
>
static
void
TestGrow
(
JSContext
*
cx
)
{
JS_GC
(
cx
)
;
auto
array
=
MakeUnique
<
ArrayT
>
(
)
;
ASSERT_TRUE
(
array
!
=
nullptr
)
;
JS_AddExtraGCRootsTracer
(
cx
TraceArray
<
ArrayT
>
array
.
get
(
)
)
;
RootedValue
value
(
cx
)
;
const
char
*
property
=
"
foo
"
;
for
(
size_t
i
=
0
;
i
<
ElementCount
;
+
+
i
)
{
RootedObject
obj
(
cx
JS_NewPlainObject
(
cx
)
)
;
ASSERT_FALSE
(
JS
:
:
ObjectIsTenured
(
obj
)
)
;
value
=
Int32Value
(
i
)
;
ASSERT_TRUE
(
JS_SetProperty
(
cx
obj
property
value
)
)
;
ASSERT_TRUE
(
array
-
>
AppendElement
(
obj
fallible
)
)
;
}
JS_GC
(
cx
)
;
ASSERT_EQ
(
array
-
>
Length
(
)
ElementCount
)
;
for
(
size_t
i
=
0
;
i
<
array
-
>
Length
(
)
;
i
+
+
)
{
RootedObject
obj
(
cx
array
-
>
ElementAt
(
i
)
)
;
ASSERT_TRUE
(
JS
:
:
ObjectIsTenured
(
obj
)
)
;
ASSERT_TRUE
(
JS_GetProperty
(
cx
obj
property
&
value
)
)
;
ASSERT_TRUE
(
value
.
isInt32
(
)
)
;
ASSERT_EQ
(
static_cast
<
int32_t
>
(
i
)
value
.
toInt32
(
)
)
;
}
JS_RemoveExtraGCRootsTracer
(
cx
TraceArray
<
ArrayT
>
array
.
get
(
)
)
;
}
template
<
class
ArrayT
>
static
void
TestShrink
(
JSContext
*
cx
)
{
JS_GC
(
cx
)
;
auto
array
=
MakeUnique
<
ArrayT
>
(
)
;
ASSERT_TRUE
(
array
!
=
nullptr
)
;
JS_AddExtraGCRootsTracer
(
cx
TraceArray
<
ArrayT
>
array
.
get
(
)
)
;
RootedValue
value
(
cx
)
;
const
char
*
property
=
"
foo
"
;
for
(
size_t
i
=
0
;
i
<
ElementCount
;
+
+
i
)
{
RootedObject
obj
(
cx
JS_NewPlainObject
(
cx
)
)
;
ASSERT_FALSE
(
JS
:
:
ObjectIsTenured
(
obj
)
)
;
value
=
Int32Value
(
i
)
;
ASSERT_TRUE
(
JS_SetProperty
(
cx
obj
property
value
)
)
;
ASSERT_TRUE
(
array
-
>
AppendElement
(
obj
fallible
)
)
;
}
array
-
>
RemoveElementsAt
(
InitialElements
ElementCount
-
InitialElements
)
;
array
-
>
Compact
(
)
;
JS_GC
(
cx
)
;
ASSERT_EQ
(
array
-
>
Length
(
)
InitialElements
)
;
for
(
size_t
i
=
0
;
i
<
array
-
>
Length
(
)
;
i
+
+
)
{
RootedObject
obj
(
cx
array
-
>
ElementAt
(
i
)
)
;
ASSERT_TRUE
(
JS
:
:
ObjectIsTenured
(
obj
)
)
;
ASSERT_TRUE
(
JS_GetProperty
(
cx
obj
property
&
value
)
)
;
ASSERT_TRUE
(
value
.
isInt32
(
)
)
;
ASSERT_EQ
(
static_cast
<
int32_t
>
(
i
)
value
.
toInt32
(
)
)
;
}
JS_RemoveExtraGCRootsTracer
(
cx
TraceArray
<
ArrayT
>
array
.
get
(
)
)
;
}
template
<
class
ArrayT
>
static
void
TestArrayType
(
JSContext
*
cx
)
{
TestGrow
<
ArrayT
>
(
cx
)
;
TestShrink
<
ArrayT
>
(
cx
)
;
}
static
void
CreateGlobalAndRunTest
(
JSContext
*
cx
)
{
static
const
JSClass
GlobalClass
=
{
"
global
"
JSCLASS_GLOBAL_FLAGS
&
JS
:
:
DefaultGlobalClassOps
}
;
JS
:
:
RealmOptions
options
;
JS
:
:
PersistentRootedObject
global
(
cx
)
;
global
=
JS_NewGlobalObject
(
cx
&
GlobalClass
nullptr
JS
:
:
FireOnNewGlobalHook
options
)
;
ASSERT_TRUE
(
global
!
=
nullptr
)
;
JS
:
:
Realm
*
oldRealm
=
JS
:
:
EnterRealm
(
cx
global
)
;
using
ElementT
=
Heap
<
JSObject
*
>
;
TestArrayType
<
nsTArray
<
ElementT
>
>
(
cx
)
;
TestArrayType
<
FallibleTArray
<
ElementT
>
>
(
cx
)
;
TestArrayType
<
AutoTArray
<
ElementT
1
>
>
(
cx
)
;
JS
:
:
LeaveRealm
(
cx
oldRealm
)
;
}
TEST
(
GCPostBarriers
nsTArray
)
{
CycleCollectedJSContext
*
ccjscx
=
CycleCollectedJSContext
:
:
Get
(
)
;
ASSERT_TRUE
(
ccjscx
!
=
nullptr
)
;
JSContext
*
cx
=
ccjscx
-
>
Context
(
)
;
ASSERT_TRUE
(
cx
!
=
nullptr
)
;
CreateGlobalAndRunTest
(
cx
)
;
}
