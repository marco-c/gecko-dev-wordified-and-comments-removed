#
include
"
gtest
/
gtest
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
TaskCategory
.
h
"
#
include
"
mozilla
/
PerformanceCounter
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThread
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
Runnable
;
using
mozilla
:
:
dom
:
:
DocGroup
;
using
mozilla
:
:
dom
:
:
Document
;
struct
RunnableDescriptor
{
MOZ_IMPLICIT
RunnableDescriptor
(
nsIRunnable
*
aRunnable
DocGroup
*
aDocGroup
=
nullptr
)
:
mRunnable
(
aRunnable
)
mDocGroup
(
aDocGroup
)
{
}
RunnableDescriptor
(
RunnableDescriptor
&
&
aDescriptor
)
:
mRunnable
(
std
:
:
move
(
aDescriptor
.
mRunnable
)
)
mDocGroup
(
std
:
:
move
(
aDescriptor
.
mDocGroup
)
)
{
}
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
RefPtr
<
DocGroup
>
mDocGroup
;
}
;
class
TimedRunnable
final
:
public
Runnable
{
public
:
explicit
TimedRunnable
(
uint32_t
aExecutionTime1
uint32_t
aExecutionTime2
)
:
Runnable
(
"
TimedRunnable
"
)
mExecutionTime1
(
aExecutionTime1
)
mExecutionTime2
(
aExecutionTime2
)
{
}
NS_IMETHODIMP
Run
(
)
{
Sleep
(
mExecutionTime1
)
;
for
(
uint32_t
index
=
0
;
index
<
mNestedRunnables
.
Length
(
)
;
+
+
index
)
{
if
(
index
!
=
0
)
{
Sleep
(
mExecutionTime1
)
;
}
(
void
)
DispatchNestedRunnable
(
mNestedRunnables
[
index
]
.
mRunnable
mNestedRunnables
[
index
]
.
mDocGroup
)
;
}
Sleep
(
mExecutionTime2
)
;
return
NS_OK
;
}
void
AddNestedRunnable
(
RunnableDescriptor
aDescriptor
)
{
mNestedRunnables
.
AppendElement
(
std
:
:
move
(
aDescriptor
)
)
;
}
void
Sleep
(
uint32_t
aMilliseconds
)
{
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
aMilliseconds
+
5
)
)
;
TimeStamp
stop
=
TimeStamp
:
:
Now
(
)
;
mTotalSlept
+
=
(
stop
-
start
)
.
ToMicroseconds
(
)
;
}
uint64_t
TotalSlept
(
)
const
{
return
mTotalSlept
;
}
static
void
DispatchNestedRunnable
(
nsIRunnable
*
aRunnable
DocGroup
*
aDocGroup
)
{
nsCOMPtr
<
nsIThread
>
thread
=
do_GetMainThread
(
)
;
if
(
aDocGroup
)
{
(
void
)
DispatchWithDocgroup
(
aRunnable
aDocGroup
)
;
}
else
{
thread
-
>
Dispatch
(
aRunnable
NS_DISPATCH_NORMAL
)
;
}
(
void
)
NS_ProcessNextEvent
(
thread
false
)
;
}
static
nsresult
DispatchWithDocgroup
(
nsIRunnable
*
aRunnable
DocGroup
*
aDocGroup
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
aRunnable
;
runnable
=
new
SchedulerGroup
:
:
Runnable
(
runnable
.
forget
(
)
aDocGroup
-
>
GetPerformanceCounter
(
)
)
;
return
aDocGroup
-
>
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
private
:
uint32_t
mExecutionTime1
;
uint32_t
mExecutionTime2
;
uint64_t
mTotalSlept
=
0
;
nsTArray
<
RunnableDescriptor
>
mNestedRunnables
;
}
;
class
ThreadMetrics
:
public
:
:
testing
:
:
Test
{
public
:
explicit
ThreadMetrics
(
)
=
default
;
protected
:
virtual
void
SetUp
(
)
{
RefPtr
<
dom
:
:
BrowsingContextGroup
>
group
=
dom
:
:
BrowsingContextGroup
:
:
Create
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewHTMLDocument
(
getter_AddRefs
(
mDocument
)
true
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewHTMLDocument
(
getter_AddRefs
(
mDocument2
)
true
)
)
;
mDocGroup
=
group
-
>
AddDocument
(
"
key
"
_ns
mDocument
)
;
mDocGroup2
=
group
-
>
AddDocument
(
"
key2
"
_ns
mDocument2
)
;
mCounter
=
mDocGroup
-
>
GetPerformanceCounter
(
)
;
mCounter2
=
mDocGroup2
-
>
GetPerformanceCounter
(
)
;
mThreadMgr
=
do_GetService
(
"
mozilla
.
org
/
thread
-
manager
;
1
"
)
;
mOther
=
DispatchCategory
(
TaskCategory
:
:
Other
)
.
GetValue
(
)
;
mDispatchCount
=
(
uint32_t
)
TaskCategory
:
:
Other
+
1
;
}
virtual
void
TearDown
(
)
{
mDocGroup
-
>
RemoveDocument
(
mDocument
)
;
mDocGroup2
-
>
RemoveDocument
(
mDocument2
)
;
mDocGroup
=
nullptr
;
mDocGroup2
=
nullptr
;
mDocument
=
nullptr
;
mDocument2
=
nullptr
;
ProcessAllEvents
(
)
;
}
void
initScheduler
(
)
{
ProcessAllEvents
(
)
;
}
nsresult
Dispatch
(
nsIRunnable
*
aRunnable
)
{
ProcessAllEvents
(
)
;
return
TimedRunnable
:
:
DispatchWithDocgroup
(
aRunnable
mDocGroup
)
;
}
void
ProcessAllEvents
(
)
{
mThreadMgr
-
>
SpinEventLoopUntilEmpty
(
)
;
}
uint32_t
mOther
;
bool
mOldPref
;
RefPtr
<
Document
>
mDocument
;
RefPtr
<
Document
>
mDocument2
;
RefPtr
<
DocGroup
>
mDocGroup
;
RefPtr
<
DocGroup
>
mDocGroup2
;
RefPtr
<
PerformanceCounter
>
mCounter
;
RefPtr
<
PerformanceCounter
>
mCounter2
;
nsCOMPtr
<
nsIThreadManager
>
mThreadMgr
;
uint32_t
mDispatchCount
;
}
;
#
if
!
defined
(
_WIN64
)
TEST_F
(
ThreadMetrics
CollectMetrics
)
{
nsresult
rv
;
initScheduler
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
TimedRunnable
(
25
25
)
;
rv
=
Dispatch
(
runnable
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ProcessAllEvents
(
)
;
ASSERT_EQ
(
mCounter
-
>
GetDispatchCounter
(
)
[
mOther
]
1u
)
;
for
(
uint32_t
i
=
0
;
i
<
mDispatchCount
;
i
+
+
)
{
if
(
i
!
=
mOther
)
{
ASSERT_EQ
(
mCounter
-
>
GetDispatchCounter
(
)
[
i
]
0u
)
;
}
}
uint64_t
duration
=
mCounter
-
>
GetExecutionDuration
(
)
;
ASSERT_GE
(
duration
50000u
)
;
}
#
endif
TEST_F
(
ThreadMetrics
CollectRecursiveMetrics
)
{
nsresult
rv
;
initScheduler
(
)
;
RefPtr
<
TimedRunnable
>
runnable
=
new
TimedRunnable
(
25
25
)
;
nsCOMPtr
<
nsIRunnable
>
nested
=
new
TimedRunnable
(
400
0
)
;
runnable
-
>
AddNestedRunnable
(
{
nested
}
)
;
rv
=
Dispatch
(
runnable
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ProcessAllEvents
(
)
;
ASSERT_EQ
(
mCounter
-
>
GetDispatchCounter
(
)
[
mOther
]
1u
)
;
for
(
uint32_t
i
=
0
;
i
<
mDispatchCount
;
i
+
+
)
{
if
(
i
!
=
mOther
)
{
ASSERT_EQ
(
mCounter
-
>
GetDispatchCounter
(
)
[
i
]
0u
)
;
}
}
uint64_t
duration
=
mCounter
-
>
GetExecutionDuration
(
)
;
ASSERT_GE
(
duration
runnable
-
>
TotalSlept
(
)
)
;
ASSERT_LT
(
duration
runnable
-
>
TotalSlept
(
)
+
200000u
)
;
}
TEST_F
(
ThreadMetrics
CollectMultipleRecursiveMetrics
)
{
nsresult
rv
;
initScheduler
(
)
;
RefPtr
<
TimedRunnable
>
runnable
=
new
TimedRunnable
(
25
25
)
;
for
(
auto
i
:
{
1
2
}
)
{
Unused
<
<
i
;
nsCOMPtr
<
nsIRunnable
>
nested
=
new
TimedRunnable
(
400
0
)
;
runnable
-
>
AddNestedRunnable
(
{
nested
}
)
;
}
rv
=
Dispatch
(
runnable
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ProcessAllEvents
(
)
;
ASSERT_EQ
(
mCounter
-
>
GetDispatchCounter
(
)
[
mOther
]
1u
)
;
for
(
uint32_t
i
=
0
;
i
<
mDispatchCount
;
i
+
+
)
{
if
(
i
!
=
mOther
)
{
ASSERT_EQ
(
mCounter
-
>
GetDispatchCounter
(
)
[
i
]
0u
)
;
}
}
uint64_t
duration
=
mCounter
-
>
GetExecutionDuration
(
)
;
ASSERT_GE
(
duration
runnable
-
>
TotalSlept
(
)
)
;
ASSERT_LT
(
duration
runnable
-
>
TotalSlept
(
)
+
200000u
)
;
}
TEST_F
(
ThreadMetrics
CollectMultipleRecursiveMetricsWithTwoDocgroups
)
{
nsresult
rv
;
initScheduler
(
)
;
RefPtr
<
TimedRunnable
>
runnable
=
new
TimedRunnable
(
25
25
)
;
RefPtr
<
TimedRunnable
>
nested1
=
new
TimedRunnable
(
400
0
)
;
runnable
-
>
AddNestedRunnable
(
{
nested1
mDocGroup2
}
)
;
nsCOMPtr
<
nsIRunnable
>
nested2
=
new
TimedRunnable
(
400
0
)
;
runnable
-
>
AddNestedRunnable
(
{
nested2
}
)
;
rv
=
Dispatch
(
runnable
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ProcessAllEvents
(
)
;
ASSERT_EQ
(
mCounter
-
>
GetDispatchCounter
(
)
[
mOther
]
1u
)
;
for
(
uint32_t
i
=
0
;
i
<
mDispatchCount
;
i
+
+
)
{
if
(
i
!
=
mOther
)
{
ASSERT_EQ
(
mCounter
-
>
GetDispatchCounter
(
)
[
i
]
0u
)
;
}
}
uint64_t
duration
=
mCounter2
-
>
GetExecutionDuration
(
)
;
ASSERT_GE
(
duration
nested1
-
>
TotalSlept
(
)
)
;
ASSERT_LT
(
duration
nested1
-
>
TotalSlept
(
)
+
20000u
)
;
duration
=
mCounter
-
>
GetExecutionDuration
(
)
;
ASSERT_GE
(
duration
runnable
-
>
TotalSlept
(
)
)
;
ASSERT_LT
(
duration
runnable
-
>
TotalSlept
(
)
+
200000u
)
;
}
