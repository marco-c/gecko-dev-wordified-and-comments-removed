#
include
<
sys
/
mman
.
h
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
AvailableMemoryWatcher
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsMemoryPressure
.
h
"
using
namespace
mozilla
;
namespace
{
class
MockTabUnloader
final
:
public
nsITabUnloader
{
NS_DECL_THREADSAFE_ISUPPORTS
public
:
MockTabUnloader
(
)
=
default
;
NS_IMETHOD
UnloadTabAsync
(
)
override
{
NS_NotifyOfEventualMemoryPressure
(
MemoryPressureState
:
:
LowMemory
)
;
return
NS_OK
;
}
private
:
~
MockTabUnloader
(
)
=
default
;
}
;
NS_IMPL_ISUPPORTS
(
MockTabUnloader
nsITabUnloader
)
class
AvailableMemoryChecker
final
:
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
AvailableMemoryChecker
(
)
;
void
Init
(
)
;
void
Shutdown
(
)
;
private
:
~
AvailableMemoryChecker
(
)
=
default
;
bool
mResolved
;
nsCOMPtr
<
nsITimer
>
mTimer
;
RefPtr
<
nsAvailableMemoryWatcherBase
>
mWatcher
;
RefPtr
<
MockTabUnloader
>
mTabUnloader
;
const
uint32_t
kPollingInterval
=
50
;
const
uint32_t
kPrefIncrement
=
5
;
}
;
AvailableMemoryChecker
:
:
AvailableMemoryChecker
(
)
:
mResolved
(
false
)
{
}
NS_IMPL_ISUPPORTS
(
AvailableMemoryChecker
nsITimerCallback
nsINamed
)
;
void
AvailableMemoryChecker
:
:
Init
(
)
{
mTabUnloader
=
new
MockTabUnloader
;
mWatcher
=
nsAvailableMemoryWatcherBase
:
:
GetSingleton
(
)
;
mWatcher
-
>
RegisterTabUnloader
(
mTabUnloader
)
;
mTimer
=
NS_NewTimer
(
)
;
mTimer
-
>
InitWithCallback
(
this
kPollingInterval
nsITimer
:
:
TYPE_REPEATING_SLACK
)
;
}
void
AvailableMemoryChecker
:
:
Shutdown
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
Preferences
:
:
ClearUser
(
"
browser
.
low_commit_space_threshold_percent
"
)
;
}
NS_IMETHODIMP
AvailableMemoryChecker
:
:
Notify
(
nsITimer
*
aTimer
)
{
uint32_t
threshold
=
StaticPrefs
:
:
browser_low_commit_space_threshold_percent
(
)
;
if
(
threshold
>
=
100
)
{
mResolved
=
true
;
return
NS_OK
;
}
threshold
+
=
kPrefIncrement
;
Preferences
:
:
SetUint
(
"
browser
.
low_commit_space_threshold_percent
"
threshold
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AvailableMemoryChecker
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
AvailableMemoryChecker
"
)
;
return
NS_OK
;
}
class
Spinner
final
:
public
nsIObserver
{
nsCOMPtr
<
nsIObserverService
>
mObserverSvc
;
nsDependentCString
mTopic
;
bool
mTopicObserved
;
~
Spinner
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
Spinner
(
nsIObserverService
*
aObserverSvc
const
char
*
aTopic
)
:
mObserverSvc
(
aObserverSvc
)
mTopic
(
aTopic
)
mTopicObserved
(
false
)
{
}
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
if
(
mTopic
=
=
aTopic
)
{
mTopicObserved
=
true
;
mObserverSvc
-
>
RemoveObserver
(
this
aTopic
)
;
nsCOMPtr
<
nsIRunnable
>
dummyEvent
=
new
Runnable
(
__func__
)
;
NS_DispatchToMainThread
(
dummyEvent
)
;
}
return
NS_OK
;
}
void
StartListening
(
)
{
mObserverSvc
-
>
AddObserver
(
this
mTopic
.
get
(
)
false
)
;
}
bool
TopicObserved
(
)
{
return
mTopicObserved
;
}
bool
WaitForNotification
(
)
;
}
;
NS_IMPL_ISUPPORTS
(
Spinner
nsIObserver
)
;
bool
Spinner
:
:
WaitForNotification
(
)
{
bool
isTimeout
=
false
;
nsCOMPtr
<
nsITimer
>
timer
;
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
timer
)
[
]
(
nsITimer
*
void
*
isTimeout
)
{
*
reinterpret_cast
<
bool
*
>
(
isTimeout
)
=
true
;
}
&
isTimeout
5000
nsITimer
:
:
TYPE_ONE_SHOT
__func__
)
;
SpinEventLoopUntil
(
"
Spinner
:
WaitForNotification
"
_ns
[
&
]
(
)
-
>
bool
{
if
(
isTimeout
)
{
return
true
;
}
return
mTopicObserved
;
}
)
;
return
!
isTimeout
;
}
void
StartUserInteraction
(
const
nsCOMPtr
<
nsIObserverService
>
&
aObserverSvc
)
{
aObserverSvc
-
>
NotifyObservers
(
nullptr
"
user
-
interaction
-
active
"
nullptr
)
;
}
TEST
(
AvailableMemoryWatcher
BasicTest
)
{
nsCOMPtr
<
nsIObserverService
>
observerSvc
=
services
:
:
GetObserverService
(
)
;
RefPtr
<
Spinner
>
aSpinner
=
new
Spinner
(
observerSvc
"
memory
-
pressure
"
)
;
aSpinner
-
>
StartListening
(
)
;
StartUserInteraction
(
observerSvc
)
;
RefPtr
<
AvailableMemoryChecker
>
checker
=
new
AvailableMemoryChecker
(
)
;
checker
-
>
Init
(
)
;
aSpinner
-
>
WaitForNotification
(
)
;
EXPECT_TRUE
(
aSpinner
-
>
TopicObserved
(
)
)
;
checker
-
>
Shutdown
(
)
;
}
TEST
(
AvailableMemoryWatcher
MemoryLowToHigh
)
{
Preferences
:
:
SetUint
(
"
browser
.
low_commit_space_threshold_percent
"
100
)
;
nsCOMPtr
<
nsIObserverService
>
observerSvc
=
services
:
:
GetObserverService
(
)
;
RefPtr
<
Spinner
>
lowMemorySpinner
=
new
Spinner
(
observerSvc
"
memory
-
pressure
"
)
;
lowMemorySpinner
-
>
StartListening
(
)
;
StartUserInteraction
(
observerSvc
)
;
RefPtr
<
AvailableMemoryChecker
>
checker
=
new
AvailableMemoryChecker
(
)
;
checker
-
>
Init
(
)
;
lowMemorySpinner
-
>
WaitForNotification
(
)
;
EXPECT_TRUE
(
lowMemorySpinner
-
>
TopicObserved
(
)
)
;
RefPtr
<
Spinner
>
highMemorySpinner
=
new
Spinner
(
observerSvc
"
memory
-
pressure
-
stop
"
)
;
highMemorySpinner
-
>
StartListening
(
)
;
Preferences
:
:
SetUint
(
"
browser
.
low_commit_space_threshold_percent
"
0
)
;
highMemorySpinner
-
>
WaitForNotification
(
)
;
EXPECT_TRUE
(
highMemorySpinner
-
>
TopicObserved
(
)
)
;
checker
-
>
Shutdown
(
)
;
}
}
