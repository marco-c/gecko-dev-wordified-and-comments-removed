#
include
"
mozmemory
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
define
ASSERT_ALLOCATION_HAPPENED
(
lambda
)
\
ASSERT_TRUE
(
ValidateHookedAllocation
(
lambda
free
)
)
;
const
size_t
kAllocAmount
=
16
;
static
bool
ValidateHookedAllocation
(
void
*
(
*
aAllocator
)
(
void
)
void
(
*
aFreeFunction
)
(
void
*
)
)
{
void
*
p
=
aAllocator
(
)
;
if
(
!
p
)
{
return
false
;
}
jemalloc_ptr_info_t
info
;
jemalloc_ptr_info
(
p
&
info
)
;
aFreeFunction
(
p
)
;
return
(
info
.
tag
=
=
PtrInfoTag
:
:
TagLiveAlloc
)
;
}
TEST
(
AllocReplacement
malloc_check
)
{
ASSERT_ALLOCATION_HAPPENED
(
[
]
{
return
malloc
(
kAllocAmount
)
;
}
)
;
}
TEST
(
AllocReplacement
calloc_check
)
{
ASSERT_ALLOCATION_HAPPENED
(
[
]
{
return
calloc
(
1
kAllocAmount
)
;
}
)
;
}
TEST
(
AllocReplacement
realloc_check
)
{
ASSERT_ALLOCATION_HAPPENED
(
[
]
{
return
realloc
(
nullptr
kAllocAmount
)
;
}
)
;
}
#
if
defined
(
HAVE_POSIX_MEMALIGN
)
TEST
(
AllocReplacement
posix_memalign_check
)
{
ASSERT_ALLOCATION_HAPPENED
(
[
]
{
void
*
p
=
nullptr
;
int
result
=
posix_memalign
(
&
p
sizeof
(
void
*
)
kAllocAmount
)
;
if
(
result
!
=
0
)
{
return
static_cast
<
void
*
>
(
nullptr
)
;
}
return
p
;
}
)
;
}
#
endif
#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
undef
ASSERT_ALLOCATION_HAPPENED
#
define
ASSERT_ALLOCATION_HAPPENED
(
lambda
)
\
ASSERT_TRUE
(
ValidateHookedAllocation
(
\
lambda
[
]
(
void
*
p
)
{
HeapFree
(
GetProcessHeap
(
)
0
p
)
;
}
)
)
;
TEST
(
AllocReplacement
HeapAlloc_check
)
{
ASSERT_ALLOCATION_HAPPENED
(
[
]
{
HANDLE
h
=
GetProcessHeap
(
)
;
return
HeapAlloc
(
h
0
kAllocAmount
)
;
}
)
;
}
TEST
(
AllocReplacement
HeapReAlloc_check
)
{
ASSERT_ALLOCATION_HAPPENED
(
[
]
{
HANDLE
h
=
GetProcessHeap
(
)
;
void
*
p
=
HeapAlloc
(
h
0
kAllocAmount
/
2
)
;
if
(
!
p
)
{
return
static_cast
<
void
*
>
(
nullptr
)
;
}
return
HeapReAlloc
(
h
0
p
kAllocAmount
)
;
}
)
;
}
#
endif
