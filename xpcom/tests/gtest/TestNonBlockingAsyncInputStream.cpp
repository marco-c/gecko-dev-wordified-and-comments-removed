#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
NonBlockingAsyncInputStream
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
Helpers
.
h
"
using
mozilla
:
:
NonBlockingAsyncInputStream
;
using
mozilla
:
:
SpinEventLoopUntil
;
TEST
(
TestNonBlockingAsyncInputStream
Simple
)
{
nsCString
data
;
data
.
Assign
(
"
Hello
world
!
"
)
;
bool
nonBlocking
=
false
;
nsCOMPtr
<
nsIAsyncInputStream
>
async
;
{
nsCOMPtr
<
nsIInputStream
>
stream
;
ASSERT_EQ
(
NS_OK
NS_NewCStringInputStream
(
getter_AddRefs
(
stream
)
data
)
)
;
async
=
do_QueryInterface
(
stream
)
;
ASSERT_EQ
(
nullptr
async
)
;
ASSERT_EQ
(
NS_OK
stream
-
>
IsNonBlocking
(
&
nonBlocking
)
)
;
ASSERT_TRUE
(
nonBlocking
)
;
ASSERT_EQ
(
NS_OK
NonBlockingAsyncInputStream
:
:
Create
(
stream
.
forget
(
)
getter_AddRefs
(
async
)
)
)
;
}
ASSERT_TRUE
(
!
!
async
)
;
ASSERT_EQ
(
NS_OK
async
-
>
IsNonBlocking
(
&
nonBlocking
)
)
;
ASSERT_TRUE
(
nonBlocking
)
;
uint64_t
length
;
ASSERT_EQ
(
NS_OK
async
-
>
Available
(
&
length
)
)
;
ASSERT_EQ
(
data
.
Length
(
)
length
)
;
char
buffer
[
1024
]
;
uint32_t
read
=
0
;
ASSERT_EQ
(
NS_OK
async
-
>
Read
(
buffer
sizeof
(
buffer
)
&
read
)
)
;
ASSERT_EQ
(
data
.
Length
(
)
read
)
;
ASSERT_TRUE
(
data
.
Equals
(
nsCString
(
buffer
read
)
)
)
;
}
class
ReadSegmentsData
{
public
:
ReadSegmentsData
(
nsIInputStream
*
aStream
char
*
aBuffer
)
:
mStream
(
aStream
)
mBuffer
(
aBuffer
)
{
}
nsIInputStream
*
mStream
;
char
*
mBuffer
;
}
;
static
nsresult
ReadSegmentsFunction
(
nsIInputStream
*
aInStr
void
*
aClosure
const
char
*
aBuffer
uint32_t
aOffset
uint32_t
aCount
uint32_t
*
aCountWritten
)
{
ReadSegmentsData
*
data
=
static_cast
<
ReadSegmentsData
*
>
(
aClosure
)
;
if
(
aInStr
!
=
data
-
>
mStream
)
return
NS_ERROR_FAILURE
;
memcpy
(
&
data
-
>
mBuffer
[
aOffset
]
aBuffer
aCount
)
;
*
aCountWritten
=
aCount
;
return
NS_OK
;
}
TEST
(
TestNonBlockingAsyncInputStream
ReadSegments
)
{
nsCString
data
;
data
.
Assign
(
"
Hello
world
!
"
)
;
nsCOMPtr
<
nsIAsyncInputStream
>
async
;
{
nsCOMPtr
<
nsIInputStream
>
stream
;
ASSERT_EQ
(
NS_OK
NS_NewCStringInputStream
(
getter_AddRefs
(
stream
)
data
)
)
;
ASSERT_EQ
(
NS_OK
NonBlockingAsyncInputStream
:
:
Create
(
stream
.
forget
(
)
getter_AddRefs
(
async
)
)
)
;
}
char
buffer
[
1024
]
;
uint32_t
read
=
0
;
ReadSegmentsData
closure
(
async
buffer
)
;
ASSERT_EQ
(
NS_OK
async
-
>
ReadSegments
(
ReadSegmentsFunction
&
closure
sizeof
(
buffer
)
&
read
)
)
;
ASSERT_EQ
(
data
.
Length
(
)
read
)
;
ASSERT_TRUE
(
data
.
Equals
(
nsCString
(
buffer
read
)
)
)
;
}
TEST
(
TestNonBlockingAsyncInputStream
AsyncWait_Simple
)
{
nsCString
data
;
data
.
Assign
(
"
Hello
world
!
"
)
;
nsCOMPtr
<
nsIAsyncInputStream
>
async
;
{
nsCOMPtr
<
nsIInputStream
>
stream
;
ASSERT_EQ
(
NS_OK
NS_NewCStringInputStream
(
getter_AddRefs
(
stream
)
data
)
)
;
ASSERT_EQ
(
NS_OK
NonBlockingAsyncInputStream
:
:
Create
(
stream
.
forget
(
)
getter_AddRefs
(
async
)
)
)
;
}
ASSERT_TRUE
(
!
!
async
)
;
uint64_t
length
;
ASSERT_EQ
(
NS_OK
async
-
>
Available
(
&
length
)
)
;
ASSERT_EQ
(
data
.
Length
(
)
length
)
;
RefPtr
<
testing
:
:
InputStreamCallback
>
cb
=
new
testing
:
:
InputStreamCallback
(
)
;
ASSERT_EQ
(
NS_OK
async
-
>
AsyncWait
(
cb
0
0
nullptr
)
)
;
ASSERT_TRUE
(
cb
-
>
Called
(
)
)
;
cb
=
new
testing
:
:
InputStreamCallback
(
)
;
nsCOMPtr
<
nsIThread
>
thread
=
do_GetCurrentThread
(
)
;
ASSERT_EQ
(
NS_OK
async
-
>
AsyncWait
(
cb
0
0
thread
)
)
;
ASSERT_FALSE
(
cb
-
>
Called
(
)
)
;
MOZ_ALWAYS_TRUE
(
SpinEventLoopUntil
(
[
&
]
(
)
{
return
cb
-
>
Called
(
)
;
}
)
)
;
ASSERT_TRUE
(
cb
-
>
Called
(
)
)
;
char
buffer
[
1024
]
;
uint32_t
read
=
0
;
ASSERT_EQ
(
NS_OK
async
-
>
Read
(
buffer
sizeof
(
buffer
)
&
read
)
)
;
ASSERT_EQ
(
data
.
Length
(
)
read
)
;
ASSERT_TRUE
(
data
.
Equals
(
nsCString
(
buffer
read
)
)
)
;
}
TEST
(
TestNonBlockingAsyncInputStream
AsyncWait_ClosureOnly_withoutEventTarget
)
{
nsCString
data
;
data
.
Assign
(
"
Hello
world
!
"
)
;
nsCOMPtr
<
nsIAsyncInputStream
>
async
;
{
nsCOMPtr
<
nsIInputStream
>
stream
;
ASSERT_EQ
(
NS_OK
NS_NewCStringInputStream
(
getter_AddRefs
(
stream
)
data
)
)
;
ASSERT_EQ
(
NS_OK
NonBlockingAsyncInputStream
:
:
Create
(
stream
.
forget
(
)
getter_AddRefs
(
async
)
)
)
;
}
ASSERT_TRUE
(
!
!
async
)
;
RefPtr
<
testing
:
:
InputStreamCallback
>
cb
=
new
testing
:
:
InputStreamCallback
(
)
;
ASSERT_EQ
(
NS_OK
async
-
>
AsyncWait
(
cb
nsIAsyncInputStream
:
:
WAIT_CLOSURE_ONLY
0
nullptr
)
)
;
ASSERT_FALSE
(
cb
-
>
Called
(
)
)
;
ASSERT_EQ
(
NS_OK
async
-
>
Close
(
)
)
;
ASSERT_TRUE
(
cb
-
>
Called
(
)
)
;
}
TEST
(
TestNonBlockingAsyncInputStream
AsyncWait_ClosureOnly_withEventTarget
)
{
nsCString
data
;
data
.
Assign
(
"
Hello
world
!
"
)
;
nsCOMPtr
<
nsIAsyncInputStream
>
async
;
{
nsCOMPtr
<
nsIInputStream
>
stream
;
ASSERT_EQ
(
NS_OK
NS_NewCStringInputStream
(
getter_AddRefs
(
stream
)
data
)
)
;
ASSERT_EQ
(
NS_OK
NonBlockingAsyncInputStream
:
:
Create
(
stream
.
forget
(
)
getter_AddRefs
(
async
)
)
)
;
}
ASSERT_TRUE
(
!
!
async
)
;
RefPtr
<
testing
:
:
InputStreamCallback
>
cb
=
new
testing
:
:
InputStreamCallback
(
)
;
nsCOMPtr
<
nsIThread
>
thread
=
do_GetCurrentThread
(
)
;
ASSERT_EQ
(
NS_OK
async
-
>
AsyncWait
(
cb
nsIAsyncInputStream
:
:
WAIT_CLOSURE_ONLY
0
thread
)
)
;
ASSERT_FALSE
(
cb
-
>
Called
(
)
)
;
ASSERT_EQ
(
NS_OK
async
-
>
Close
(
)
)
;
ASSERT_FALSE
(
cb
-
>
Called
(
)
)
;
MOZ_ALWAYS_TRUE
(
SpinEventLoopUntil
(
[
&
]
(
)
{
return
cb
-
>
Called
(
)
;
}
)
)
;
ASSERT_TRUE
(
cb
-
>
Called
(
)
)
;
}
TEST
(
TestNonBlockingAsyncInputStream
Helper
)
{
nsCString
data
;
data
.
Assign
(
"
Hello
world
!
"
)
;
nsCOMPtr
<
nsIAsyncInputStream
>
async
;
{
nsCOMPtr
<
nsIInputStream
>
stream
;
ASSERT_EQ
(
NS_OK
NS_NewCStringInputStream
(
getter_AddRefs
(
stream
)
data
)
)
;
ASSERT_EQ
(
NS_OK
NonBlockingAsyncInputStream
:
:
Create
(
stream
.
forget
(
)
getter_AddRefs
(
async
)
)
)
;
}
ASSERT_TRUE
(
!
!
async
)
;
nsCOMPtr
<
nsIAsyncInputStream
>
result
;
nsCOMPtr
<
nsIAsyncInputStream
>
asyncTmp
=
async
;
ASSERT_EQ
(
NS_OK
NS_MakeAsyncNonBlockingInputStream
(
asyncTmp
.
forget
(
)
getter_AddRefs
(
result
)
)
)
;
ASSERT_EQ
(
async
result
)
;
{
nsCOMPtr
<
nsIInputStream
>
stream
;
ASSERT_EQ
(
NS_OK
NS_NewCStringInputStream
(
getter_AddRefs
(
stream
)
data
)
)
;
ASSERT_EQ
(
NS_OK
NS_MakeAsyncNonBlockingInputStream
(
stream
.
forget
(
)
getter_AddRefs
(
result
)
)
)
;
}
ASSERT_TRUE
(
async
!
=
result
)
;
ASSERT_TRUE
(
async
)
;
}
class
QIInputStream
final
:
public
nsIInputStream
public
nsICloneableInputStream
public
nsIIPCSerializableInputStream
public
nsISeekableStream
{
public
:
NS_DECL_ISUPPORTS
QIInputStream
(
bool
aNonBlockingError
bool
aCloneable
bool
aIPCSerializable
bool
aSeekable
)
:
mNonBlockingError
(
aNonBlockingError
)
mCloneable
(
aCloneable
)
mIPCSerializable
(
aIPCSerializable
)
mSeekable
(
aSeekable
)
{
}
NS_IMETHOD
Close
(
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
Available
(
uint64_t
*
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
Read
(
char
*
uint32_t
uint32_t
*
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
ReadSegments
(
nsWriteSegmentFun
void
*
uint32_t
uint32_t
*
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
IsNonBlocking
(
bool
*
aNonBlocking
)
override
{
*
aNonBlocking
=
true
;
return
mNonBlockingError
?
NS_ERROR_FAILURE
:
NS_OK
;
}
NS_IMETHOD
GetCloneable
(
bool
*
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
Clone
(
nsIInputStream
*
*
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
void
Serialize
(
mozilla
:
:
ipc
:
:
InputStreamParams
&
FileDescriptorArray
&
bool
uint32_t
uint32_t
*
mozilla
:
:
ipc
:
:
ParentToChildStreamActorManager
*
)
override
{
}
void
Serialize
(
mozilla
:
:
ipc
:
:
InputStreamParams
&
FileDescriptorArray
&
bool
uint32_t
uint32_t
*
mozilla
:
:
ipc
:
:
ChildToParentStreamActorManager
*
)
override
{
}
bool
Deserialize
(
const
mozilla
:
:
ipc
:
:
InputStreamParams
&
const
FileDescriptorArray
&
)
override
{
return
false
;
}
NS_IMETHOD
Seek
(
int32_t
int64_t
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
SetEOF
(
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHOD
Tell
(
int64_t
*
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
private
:
~
QIInputStream
(
)
=
default
;
bool
mNonBlockingError
;
bool
mCloneable
;
bool
mIPCSerializable
;
bool
mSeekable
;
}
;
NS_IMPL_ADDREF
(
QIInputStream
)
;
NS_IMPL_RELEASE
(
QIInputStream
)
;
NS_INTERFACE_MAP_BEGIN
(
QIInputStream
)
NS_INTERFACE_MAP_ENTRY
(
nsIInputStream
)
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
nsICloneableInputStream
mCloneable
)
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
nsIIPCSerializableInputStream
mIPCSerializable
)
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
nsISeekableStream
mSeekable
)
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
nsITellableStream
mSeekable
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIInputStream
)
NS_INTERFACE_MAP_END
TEST
(
TestNonBlockingAsyncInputStream
QI
)
{
nsCOMPtr
<
nsIAsyncInputStream
>
async
;
{
nsCOMPtr
<
nsIInputStream
>
stream
=
new
QIInputStream
(
true
true
true
true
)
;
ASSERT_EQ
(
NS_ERROR_FAILURE
NonBlockingAsyncInputStream
:
:
Create
(
stream
.
forget
(
)
getter_AddRefs
(
async
)
)
)
;
}
for
(
int
i
=
0
;
i
<
8
;
+
+
i
)
{
bool
shouldBeCloneable
=
!
!
(
i
&
0x01
)
;
bool
shouldBeSerializable
=
!
!
(
i
&
0x02
)
;
bool
shouldBeSeekable
=
!
!
(
i
&
0x04
)
;
nsCOMPtr
<
nsICloneableInputStream
>
cloneable
;
nsCOMPtr
<
nsIIPCSerializableInputStream
>
ipcSerializable
;
nsCOMPtr
<
nsISeekableStream
>
seekable
;
{
nsCOMPtr
<
nsIInputStream
>
stream
=
new
QIInputStream
(
false
shouldBeCloneable
shouldBeSerializable
shouldBeSeekable
)
;
cloneable
=
do_QueryInterface
(
stream
)
;
ASSERT_EQ
(
shouldBeCloneable
!
!
cloneable
)
;
ipcSerializable
=
do_QueryInterface
(
stream
)
;
ASSERT_EQ
(
shouldBeSerializable
!
!
ipcSerializable
)
;
seekable
=
do_QueryInterface
(
stream
)
;
ASSERT_EQ
(
shouldBeSeekable
!
!
seekable
)
;
ASSERT_EQ
(
NS_OK
NonBlockingAsyncInputStream
:
:
Create
(
stream
.
forget
(
)
getter_AddRefs
(
async
)
)
)
;
}
cloneable
=
do_QueryInterface
(
async
)
;
ASSERT_EQ
(
shouldBeCloneable
!
!
cloneable
)
;
ipcSerializable
=
do_QueryInterface
(
async
)
;
ASSERT_EQ
(
shouldBeSerializable
!
!
ipcSerializable
)
;
seekable
=
do_QueryInterface
(
async
)
;
ASSERT_EQ
(
shouldBeSeekable
!
!
seekable
)
;
}
}
