#
include
"
mozilla
/
CondVar
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
ThreadSafety
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsThreadPool
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
pratom
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
prmon
.
h
"
#
include
"
prthread
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
gtest
/
MozAssertions
.
h
"
#
include
"
gtest
/
gtest
.
h
"
using
namespace
mozilla
;
#
define
NUMBER_OF_MAX_THREADS
(
(
uint32_t
)
6
)
#
define
NUMBER_OF_IDLE_THREADS
(
(
uint32_t
)
3
)
#
define
IDLE_THREAD_GRACE_TIMEOUT
250
#
define
IDLE_THREAD_MAX_TIMEOUT
1000
namespace
TestThreadPoolIdleTimeout
{
template
<
uint32_t
ms
size_t
repeats
>
class
ScopedTimingChecker
{
Mutex
mMutex
{
"
ScopedTimingCheckMutex
"
}
;
CondVar
mWaitForTimer
MOZ_GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsISerialEventTarget
>
mTarget
MOZ_GUARDED_BY
(
mMutex
)
;
TimeStamp
mLastStart
MOZ_GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsITimer
>
mTimer
MOZ_GUARDED_BY
(
mMutex
)
;
AutoTArray
<
TimeDuration
repeats
>
mEffectiveMS
MOZ_GUARDED_BY
(
mMutex
)
;
double
&
mDeviationPerc
;
void
TimerFn
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
TimeDuration
delta
=
TimeStamp
:
:
Now
(
)
-
mLastStart
;
mEffectiveMS
.
AppendElement
(
delta
)
;
if
(
mEffectiveMS
.
Length
(
)
<
repeats
)
{
mLastStart
=
TimeStamp
:
:
Now
(
)
;
auto
ret
=
NS_NewTimerWithCallback
(
[
self
=
this
]
(
nsITimer
*
t
)
{
self
-
>
TimerFn
(
)
;
}
TimeDuration
:
:
FromMilliseconds
(
ms
)
nsITimer
:
:
TYPE_ONE_SHOT
"
TimingChecker
"
mTarget
)
;
MOZ_ASSERT
(
ret
.
isOk
(
)
)
;
mTimer
=
ret
.
unwrap
(
)
;
}
else
{
mWaitForTimer
.
Notify
(
)
;
}
}
;
public
:
ScopedTimingChecker
(
nsCOMPtr
<
nsISerialEventTarget
>
aTarget
double
&
aDeviationPerc
)
:
mWaitForTimer
(
mMutex
"
WaitForPeak
"
)
mTarget
(
std
:
:
move
(
aTarget
)
)
mDeviationPerc
(
aDeviationPerc
)
{
MutexAutoLock
lock
(
mMutex
)
;
mLastStart
=
TimeStamp
:
:
Now
(
)
;
auto
ret
=
NS_NewTimerWithCallback
(
[
self
=
this
]
(
nsITimer
*
t
)
{
self
-
>
TimerFn
(
)
;
}
TimeDuration
:
:
FromMilliseconds
(
ms
)
nsITimer
:
:
TYPE_ONE_SHOT
"
TimingChecker
"
mTarget
)
;
MOZ_ASSERT
(
ret
.
isOk
(
)
)
;
mTimer
=
ret
.
unwrap
(
)
;
}
~
ScopedTimingChecker
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mEffectiveMS
.
Length
(
)
<
repeats
)
{
mWaitForTimer
.
Wait
(
)
;
}
double
maxDeviation
=
0
.
0
;
for
(
size_t
i
=
0
;
i
<
repeats
;
i
+
+
)
{
maxDeviation
=
std
:
:
max
(
maxDeviation
std
:
:
abs
(
mEffectiveMS
[
i
]
.
ToMilliseconds
(
)
-
ms
)
)
;
}
mDeviationPerc
=
100
.
0
*
(
maxDeviation
/
ms
)
;
printf
(
"
ScopedTimingChecker
calculated
%
.
2f
%
%
deviation
.
\
n
"
mDeviationPerc
)
;
}
}
;
class
Listener
final
:
public
nsIThreadPoolListener
{
~
Listener
(
)
=
default
;
TimeStamp
mExecStart
;
Atomic
<
uint32_t
>
&
mNumberOfThreadsCurrent
;
Atomic
<
uint32_t
>
&
mNumberOfThreadsCreated
;
Mutex
&
mWaitMutex
;
CondVar
&
mWaitForIdleLimit
;
CondVar
&
mWaitForNoThreadsAlive
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSITHREADPOOLLISTENER
Listener
(
TimeStamp
aStart
Atomic
<
uint32_t
>
&
aNumberOfThreadsCurrent
Atomic
<
uint32_t
>
&
aNumberOfThreadsCreated
Mutex
&
aWaitMutex
CondVar
&
aWaitForGrace
CondVar
&
aWaitForMaximum
)
:
mExecStart
(
aStart
)
mNumberOfThreadsCurrent
(
aNumberOfThreadsCurrent
)
mNumberOfThreadsCreated
(
aNumberOfThreadsCreated
)
mWaitMutex
(
aWaitMutex
)
mWaitForIdleLimit
(
aWaitForGrace
)
mWaitForNoThreadsAlive
(
aWaitForMaximum
)
{
}
}
;
NS_IMPL_ISUPPORTS
(
Listener
nsIThreadPoolListener
)
NS_IMETHODIMP
Listener
:
:
OnThreadCreated
(
)
{
+
+
mNumberOfThreadsCurrent
;
+
+
mNumberOfThreadsCreated
;
printf
(
"
%
u
Start
new
thread
.
%
u
alive
%
u
ever
created
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
mExecStart
)
.
ToMilliseconds
(
)
(
uint32_t
)
mNumberOfThreadsCurrent
(
uint32_t
)
mNumberOfThreadsCreated
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Listener
:
:
OnThreadShuttingDown
(
)
{
MutexAutoLock
lock
(
mWaitMutex
)
;
-
-
mNumberOfThreadsCurrent
;
if
(
mNumberOfThreadsCurrent
=
=
NUMBER_OF_IDLE_THREADS
)
{
mWaitForIdleLimit
.
Notify
(
)
;
}
if
(
mNumberOfThreadsCurrent
=
=
0
)
{
mWaitForNoThreadsAlive
.
Notify
(
)
;
}
printf
(
"
%
u
Shutdown
thread
.
%
u
alive
%
u
ever
created
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
mExecStart
)
.
ToMilliseconds
(
)
(
uint32_t
)
mNumberOfThreadsCurrent
(
uint32_t
)
mNumberOfThreadsCreated
)
;
return
NS_OK
;
}
TEST
(
ThreadPoolIdleTimeout
Test
)
{
nsresult
rv
;
Mutex
waitMutex
(
"
WaitMutex
"
)
;
CondVar
waitForPeak
(
waitMutex
"
WaitForPeak
"
)
;
CondVar
waitForIdleAfterPeak
(
waitMutex
"
WaitForIdleAfterPeak
"
)
;
CondVar
waitForGrace
(
waitMutex
"
WaitForGrace
"
)
;
CondVar
waitForMaximum
(
waitMutex
"
WaitForMaximum
"
)
;
TimeStamp
execStart
=
TimeStamp
:
:
Now
(
)
;
Atomic
<
uint32_t
>
numberOfThreads
(
0
)
;
Atomic
<
uint32_t
>
numberOfThreadsCreated
(
0
)
;
Atomic
<
uint32_t
>
numberOfActiviationRunnables
(
0
)
;
nsCOMPtr
<
nsIThreadPool
>
pool
=
new
nsThreadPool
(
)
;
rv
=
pool
-
>
SetThreadLimit
(
NUMBER_OF_MAX_THREADS
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
rv
=
pool
-
>
SetIdleThreadLimit
(
NUMBER_OF_IDLE_THREADS
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
rv
=
pool
-
>
SetIdleThreadGraceTimeout
(
IDLE_THREAD_GRACE_TIMEOUT
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
rv
=
pool
-
>
SetIdleThreadMaximumTimeout
(
IDLE_THREAD_MAX_TIMEOUT
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
pool
-
>
SetName
(
"
IdleTest
"
_ns
)
;
nsCOMPtr
<
nsIThreadPoolListener
>
listener
=
new
Listener
(
execStart
numberOfThreads
numberOfThreadsCreated
waitMutex
waitForGrace
waitForMaximum
)
;
ASSERT_TRUE
(
listener
)
;
rv
=
pool
-
>
SetListener
(
listener
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
nsCOMPtr
<
nsITimer
>
timer
;
nsCOMPtr
<
nsISerialEventTarget
>
helperTarget
;
rv
=
NS_CreateBackgroundTaskQueue
(
"
Helper
"
getter_AddRefs
(
helperTarget
)
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
auto
activateThreads
=
[
&
]
(
uint32_t
aNumThreads
)
MOZ_REQUIRES
(
waitMutex
)
{
MOZ_ASSERT
(
!
numberOfActiviationRunnables
)
;
printf
(
"
%
u
Activate
%
u
threads
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
(
uint32_t
)
aNumThreads
)
;
for
(
uint32_t
i
=
0
;
i
<
aNumThreads
;
i
+
+
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
TestRunnable
"
[
&
]
(
)
{
MutexAutoLock
lock
(
waitMutex
)
;
numberOfActiviationRunnables
+
+
;
if
(
numberOfActiviationRunnables
>
=
aNumThreads
)
{
waitForPeak
.
NotifyAll
(
)
;
}
else
{
waitForPeak
.
Wait
(
)
;
}
numberOfActiviationRunnables
-
-
;
if
(
numberOfActiviationRunnables
=
=
0
)
{
waitForIdleAfterPeak
.
NotifyAll
(
)
;
}
}
)
;
ASSERT_TRUE
(
runnable
)
;
rv
=
pool
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
}
waitForPeak
.
Wait
(
)
;
if
(
numberOfActiviationRunnables
>
0
)
{
waitForIdleAfterPeak
.
Wait
(
)
;
}
}
;
{
double
deviationPerc
=
0
.
0
;
TimeStamp
start
;
TimeDuration
graceTime
;
{
ScopedTimingChecker
<
IDLE_THREAD_GRACE_TIMEOUT
/
5
5
>
checker
(
helperTarget
deviationPerc
)
;
{
MutexAutoLock
lock
(
waitMutex
)
;
activateThreads
(
NUMBER_OF_MAX_THREADS
)
;
}
printf
(
"
%
u
Found
%
u
threads
alive
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
(
uint32_t
)
numberOfThreads
)
;
EXPECT_EQ
(
numberOfThreads
(
uint32_t
)
NUMBER_OF_MAX_THREADS
)
;
start
=
TimeStamp
:
:
Now
(
)
;
printf
(
"
%
u
Wait
for
grace
timeout
.
.
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
)
;
{
MutexAutoLock
lock
(
waitMutex
)
;
waitForGrace
.
Wait
(
)
;
}
printf
(
"
%
u
Found
%
u
threads
alive
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
(
uint32_t
)
numberOfThreads
)
;
graceTime
=
TimeStamp
:
:
Now
(
)
-
start
;
}
EXPECT_EQ
(
numberOfThreads
(
uint32_t
)
NUMBER_OF_IDLE_THREADS
)
;
if
(
deviationPerc
<
10
)
{
EXPECT_GE
(
graceTime
TimeDuration
:
:
FromMilliseconds
(
IDLE_THREAD_GRACE_TIMEOUT
*
.
9
)
)
;
EXPECT_LE
(
graceTime
TimeDuration
:
:
FromMilliseconds
(
IDLE_THREAD_GRACE_TIMEOUT
*
1
.
5
)
)
;
}
else
{
printf
(
"
Encountered
flaky
timers
(
deviation
=
%
.
2f
)
skipping
grace
timeout
"
"
check
.
\
n
"
deviationPerc
)
;
}
TimeDuration
maxTime
;
{
ScopedTimingChecker
<
(
IDLE_THREAD_MAX_TIMEOUT
-
IDLE_THREAD_GRACE_TIMEOUT
)
/
5
5
>
checker
(
helperTarget
deviationPerc
)
;
printf
(
"
%
u
Wait
for
maximum
timeout
.
.
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
)
;
{
MutexAutoLock
lock
(
waitMutex
)
;
waitForMaximum
.
Wait
(
)
;
}
}
printf
(
"
%
u
Found
%
u
threads
alive
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
(
uint32_t
)
numberOfThreads
)
;
maxTime
=
TimeStamp
:
:
Now
(
)
-
start
;
EXPECT_EQ
(
numberOfThreads
(
uint32_t
)
0
)
;
if
(
deviationPerc
<
10
)
{
EXPECT_GE
(
maxTime
TimeDuration
:
:
FromMilliseconds
(
IDLE_THREAD_MAX_TIMEOUT
*
.
9
)
)
;
EXPECT_LE
(
maxTime
TimeDuration
:
:
FromMilliseconds
(
IDLE_THREAD_MAX_TIMEOUT
*
1
.
5
)
)
;
}
else
{
printf
(
"
Encountered
flaky
timers
(
deviation
=
%
.
2f
)
skipping
max
timeout
"
"
check
.
\
n
"
deviationPerc
)
;
}
}
TimeStamp
started
=
TimeStamp
:
:
Now
(
)
;
CondVar
waitForRepeats
(
waitMutex
"
WaitForRepeats
"
)
;
{
numberOfThreadsCreated
=
0
;
auto
res
=
NS_NewTimerWithCallback
(
[
&
]
(
nsITimer
*
t
)
{
MutexAutoLock
lock
(
waitMutex
)
;
activateThreads
(
NUMBER_OF_MAX_THREADS
)
;
if
(
TimeStamp
:
:
Now
(
)
-
started
>
TimeDuration
:
:
FromMilliseconds
(
2
.
0
*
IDLE_THREAD_GRACE_TIMEOUT
)
)
{
waitForRepeats
.
Notify
(
)
;
}
}
50
nsITimer
:
:
TYPE_REPEATING_PRECISE_CAN_SKIP
"
Background
Bursts
"
helperTarget
)
;
ASSERT_TRUE
(
res
.
isOk
(
)
)
;
timer
=
res
.
unwrap
(
)
;
printf
(
"
%
u
Wait
for
repeated
bursts
.
.
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
)
;
{
MutexAutoLock
lock
(
waitMutex
)
;
waitForRepeats
.
Wait
(
)
;
timer
-
>
Cancel
(
)
;
}
printf
(
"
%
u
Found
%
u
threads
created
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
(
uint32_t
)
numberOfThreadsCreated
)
;
EXPECT_EQ
(
NUMBER_OF_MAX_THREADS
(
uint32_t
)
numberOfThreadsCreated
)
;
}
{
{
MutexAutoLock
lock
(
waitMutex
)
;
activateThreads
(
NUMBER_OF_MAX_THREADS
)
;
}
printf
(
"
%
u
Found
%
u
threads
alive
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
(
uint32_t
)
numberOfThreads
)
;
EXPECT_EQ
(
numberOfThreads
(
uint32_t
)
NUMBER_OF_MAX_THREADS
)
;
double
deviationPerc
=
0
.
0
;
{
ScopedTimingChecker
<
IDLE_THREAD_GRACE_TIMEOUT
/
5
5
>
checker
(
helperTarget
deviationPerc
)
;
numberOfActiviationRunnables
=
0
;
started
=
TimeStamp
:
:
Now
(
)
;
CondVar
waitForRepeatExecutions
(
waitMutex
"
waitForRepeatExecutions
"
)
;
Atomic
<
uint32_t
>
numberOfNoiseRunnables
(
0
)
;
auto
res
=
NS_NewTimerWithCallback
(
[
&
]
(
nsITimer
*
t
)
{
MutexAutoLock
lock
(
waitMutex
)
;
if
(
TimeStamp
:
:
Now
(
)
-
started
>
TimeDuration
:
:
FromMilliseconds
(
2
.
5
*
IDLE_THREAD_GRACE_TIMEOUT
)
)
{
waitForRepeats
.
Notify
(
)
;
}
else
{
if
(
numberOfNoiseRunnables
=
=
0
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
EmptyRunnable
"
[
&
]
(
)
{
MutexAutoLock
lock
(
waitMutex
)
;
printf
(
"
%
u
Execute
empty
runnable
num
%
u
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
(
uint32_t
)
numberOfNoiseRunnables
)
;
numberOfNoiseRunnables
-
-
;
if
(
numberOfNoiseRunnables
=
=
0
)
{
waitForRepeatExecutions
.
Notify
(
)
;
}
}
)
;
ASSERT_TRUE
(
runnable
)
;
numberOfNoiseRunnables
+
+
;
printf
(
"
%
u
Dispatch
empty
runnable
num
%
u
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
(
uint32_t
)
numberOfNoiseRunnables
)
;
rv
=
pool
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
}
}
}
50
nsITimer
:
:
TYPE_REPEATING_PRECISE_CAN_SKIP
"
Background
Noise
"
helperTarget
)
;
ASSERT_TRUE
(
res
.
isOk
(
)
)
;
timer
=
res
.
unwrap
(
)
;
printf
(
"
%
u
Wait
for
repeated
low
noise
.
.
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
)
;
{
MutexAutoLock
lock
(
waitMutex
)
;
waitForRepeats
.
Wait
(
)
;
timer
-
>
Cancel
(
)
;
if
(
numberOfNoiseRunnables
)
{
printf
(
"
%
u
Runnables
in
flight
after
cancel
:
%
u
wait
.
.
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
(
uint32_t
)
numberOfNoiseRunnables
)
;
waitForRepeatExecutions
.
Wait
(
)
;
}
}
}
if
(
deviationPerc
<
10
)
{
printf
(
"
%
u
End
of
low
noise
found
%
u
threads
alive
.
\
n
"
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
execStart
)
.
ToMilliseconds
(
)
(
uint32_t
)
numberOfThreads
)
;
EXPECT_LE
(
NUMBER_OF_IDLE_THREADS
(
uint32_t
)
numberOfThreads
)
;
EXPECT_GE
(
NUMBER_OF_IDLE_THREADS
+
1
(
uint32_t
)
numberOfThreads
)
;
}
else
{
printf
(
"
Encountered
flaky
timers
(
deviation
=
%
.
2f
)
skipping
low
noise
"
"
timeout
check
.
\
n
"
deviationPerc
)
;
}
}
rv
=
pool
-
>
Shutdown
(
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
}
}
