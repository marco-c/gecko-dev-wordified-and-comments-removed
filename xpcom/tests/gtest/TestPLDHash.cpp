#
include
"
PLDHashTable
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsICrashReporter
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
ifdef
XP_UNIX
#
include
<
unistd
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
wait
.
h
>
extern
unsigned
int
_gdb_sleep_duration
;
#
endif
void
TestCrashyOperation
(
void
(
*
aCrashyOperation
)
(
)
)
{
#
if
defined
(
XP_UNIX
)
&
&
defined
(
DEBUG
)
&
&
!
defined
(
MOZ_ASAN
)
unsigned
int
old_gdb_sleep_duration
=
_gdb_sleep_duration
;
_gdb_sleep_duration
=
0
;
int
pid
=
fork
(
)
;
ASSERT_NE
(
pid
-
1
)
;
if
(
pid
=
=
0
)
{
nsCOMPtr
<
nsICrashReporter
>
crashreporter
=
do_GetService
(
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
)
;
if
(
crashreporter
)
{
crashreporter
-
>
SetEnabled
(
false
)
;
}
fprintf
(
stderr
"
TestCrashyOperation
:
The
following
crash
is
expected
.
Do
not
panic
.
\
n
"
)
;
aCrashyOperation
(
)
;
fprintf
(
stderr
"
TestCrashyOperation
:
didn
'
t
crash
?
!
\
n
"
)
;
ASSERT_TRUE
(
false
)
;
}
int
status
;
ASSERT_NE
(
waitpid
(
pid
&
status
0
)
-
1
)
;
ASSERT_TRUE
(
WIFEXITED
(
status
)
|
|
WTERMSIG
(
status
)
)
;
if
(
WIFEXITED
(
status
)
)
{
int
signum
=
WEXITSTATUS
(
status
)
;
if
(
signum
!
=
SIGSEGV
&
&
signum
!
=
SIGBUS
)
{
fprintf
(
stderr
"
TestCrashyOperation
'
exited
'
failure
:
%
d
\
n
"
signum
)
;
ASSERT_TRUE
(
false
)
;
}
}
else
if
(
WIFSIGNALED
(
status
)
)
{
int
signum
=
WTERMSIG
(
status
)
;
if
(
signum
!
=
SIGSEGV
&
&
signum
!
=
SIGBUS
)
{
fprintf
(
stderr
"
TestCrashyOperation
'
signaled
'
failure
:
%
d
\
n
"
signum
)
;
ASSERT_TRUE
(
false
)
;
}
}
_gdb_sleep_duration
=
old_gdb_sleep_duration
;
#
endif
}
void
InitCapacityOk_InitialLengthTooBig
(
)
{
PLDHashTable
t
(
PLDHashTable
:
:
StubOps
(
)
sizeof
(
PLDHashEntryStub
)
PLDHashTable
:
:
kMaxInitialLength
+
1
)
;
}
void
InitCapacityOk_InitialEntryStoreTooBig
(
)
{
PLDHashTable
t
(
PLDHashTable
:
:
StubOps
(
)
(
uint32_t
)
1
<
<
8
(
uint32_t
)
1
<
<
23
)
;
}
void
InitCapacityOk_EntrySizeTooBig
(
)
{
PLDHashTable
t
(
PLDHashTable
:
:
StubOps
(
)
256
)
;
}
TEST
(
PLDHashTableTest
InitCapacityOk
)
{
PLDHashTable
t1
(
PLDHashTable
:
:
StubOps
(
)
sizeof
(
PLDHashEntryStub
)
PLDHashTable
:
:
kMaxInitialLength
)
;
PLDHashTable
t2
(
PLDHashTable
:
:
StubOps
(
)
(
uint32_t
)
1
<
<
7
(
uint32_t
)
1
<
<
23
)
;
TestCrashyOperation
(
InitCapacityOk_InitialLengthTooBig
)
;
TestCrashyOperation
(
InitCapacityOk_InitialEntryStoreTooBig
)
;
PLDHashTable
t3
(
PLDHashTable
:
:
StubOps
(
)
255
)
;
TestCrashyOperation
(
InitCapacityOk_EntrySizeTooBig
)
;
}
TEST
(
PLDHashTableTest
LazyStorage
)
{
PLDHashTable
t
(
PLDHashTable
:
:
StubOps
(
)
sizeof
(
PLDHashEntryStub
)
)
;
ASSERT_EQ
(
t
.
Capacity
(
)
0u
)
;
ASSERT_EQ
(
t
.
EntrySize
(
)
sizeof
(
PLDHashEntryStub
)
)
;
ASSERT_EQ
(
t
.
EntryCount
(
)
0u
)
;
ASSERT_EQ
(
t
.
Generation
(
)
0u
)
;
ASSERT_TRUE
(
!
t
.
Search
(
(
const
void
*
)
1
)
)
;
t
.
Remove
(
(
const
void
*
)
2
)
;
for
(
auto
iter
=
t
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ASSERT_TRUE
(
false
)
;
}
ASSERT_EQ
(
t
.
ShallowSizeOfExcludingThis
(
moz_malloc_size_of
)
0u
)
;
}
static
PLDHashNumber
TrivialHash
(
const
void
*
key
)
{
return
(
PLDHashNumber
)
(
size_t
)
key
;
}
static
void
TrivialInitEntry
(
PLDHashEntryHdr
*
aEntry
const
void
*
aKey
)
{
auto
entry
=
static_cast
<
PLDHashEntryStub
*
>
(
aEntry
)
;
entry
-
>
key
=
aKey
;
}
static
const
PLDHashTableOps
trivialOps
=
{
TrivialHash
PLDHashTable
:
:
MatchEntryStub
PLDHashTable
:
:
MoveEntryStub
PLDHashTable
:
:
ClearEntryStub
TrivialInitEntry
}
;
TEST
(
PLDHashTableTest
MoveSemantics
)
{
PLDHashTable
t1
(
&
trivialOps
sizeof
(
PLDHashEntryStub
)
)
;
t1
.
Add
(
(
const
void
*
)
88
)
;
PLDHashTable
t2
(
&
trivialOps
sizeof
(
PLDHashEntryStub
)
)
;
t2
.
Add
(
(
const
void
*
)
99
)
;
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
push
#
pragma
clang
diagnostic
ignored
"
-
Wself
-
move
"
#
endif
t1
=
std
:
:
move
(
t1
)
;
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
pop
#
endif
t1
=
std
:
:
move
(
t2
)
;
PLDHashTable
t3
(
&
trivialOps
sizeof
(
PLDHashEntryStub
)
)
;
PLDHashTable
t4
(
&
trivialOps
sizeof
(
PLDHashEntryStub
)
)
;
t3
.
Add
(
(
const
void
*
)
88
)
;
t3
=
std
:
:
move
(
t4
)
;
PLDHashTable
t5
(
&
trivialOps
sizeof
(
PLDHashEntryStub
)
)
;
PLDHashTable
t6
(
&
trivialOps
sizeof
(
PLDHashEntryStub
)
)
;
t6
.
Add
(
(
const
void
*
)
88
)
;
t5
=
std
:
:
move
(
t6
)
;
PLDHashTable
t7
(
&
trivialOps
sizeof
(
PLDHashEntryStub
)
)
;
PLDHashTable
t8
(
std
:
:
move
(
t7
)
)
;
PLDHashTable
t9
(
&
trivialOps
sizeof
(
PLDHashEntryStub
)
)
;
t9
.
Add
(
(
const
void
*
)
88
)
;
PLDHashTable
t10
(
std
:
:
move
(
t9
)
)
;
}
TEST
(
PLDHashTableTest
Clear
)
{
PLDHashTable
t1
(
&
trivialOps
sizeof
(
PLDHashEntryStub
)
)
;
t1
.
Clear
(
)
;
ASSERT_EQ
(
t1
.
EntryCount
(
)
0u
)
;
t1
.
ClearAndPrepareForLength
(
100
)
;
ASSERT_EQ
(
t1
.
EntryCount
(
)
0u
)
;
t1
.
Add
(
(
const
void
*
)
77
)
;
t1
.
Add
(
(
const
void
*
)
88
)
;
t1
.
Add
(
(
const
void
*
)
99
)
;
ASSERT_EQ
(
t1
.
EntryCount
(
)
3u
)
;
t1
.
Clear
(
)
;
ASSERT_EQ
(
t1
.
EntryCount
(
)
0u
)
;
t1
.
Add
(
(
const
void
*
)
55
)
;
t1
.
Add
(
(
const
void
*
)
66
)
;
t1
.
Add
(
(
const
void
*
)
77
)
;
t1
.
Add
(
(
const
void
*
)
88
)
;
t1
.
Add
(
(
const
void
*
)
99
)
;
ASSERT_EQ
(
t1
.
EntryCount
(
)
5u
)
;
t1
.
ClearAndPrepareForLength
(
8192
)
;
ASSERT_EQ
(
t1
.
EntryCount
(
)
0u
)
;
}
TEST
(
PLDHashTableTest
Iterator
)
{
PLDHashTable
t
(
&
trivialOps
sizeof
(
PLDHashEntryStub
)
)
;
{
PLDHashTable
:
:
Iterator
iter1
(
&
t
)
;
PLDHashTable
:
:
Iterator
iter2
(
std
:
:
move
(
iter1
)
)
;
}
for
(
PLDHashTable
:
:
Iterator
iter
(
&
t
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
(
void
)
iter
.
Get
(
)
;
ASSERT_TRUE
(
false
)
;
}
t
.
Add
(
(
const
void
*
)
77
)
;
t
.
Add
(
(
const
void
*
)
88
)
;
t
.
Add
(
(
const
void
*
)
99
)
;
bool
saw77
=
false
saw88
=
false
saw99
=
false
;
int
n
=
0
;
for
(
auto
iter
(
t
.
Iter
(
)
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
PLDHashEntryStub
*
>
(
iter
.
Get
(
)
)
;
if
(
entry
-
>
key
=
=
(
const
void
*
)
77
)
{
saw77
=
true
;
}
if
(
entry
-
>
key
=
=
(
const
void
*
)
88
)
{
saw88
=
true
;
}
if
(
entry
-
>
key
=
=
(
const
void
*
)
99
)
{
saw99
=
true
;
}
n
+
+
;
}
ASSERT_TRUE
(
saw77
&
&
saw88
&
&
saw99
&
&
n
=
=
3
)
;
t
.
Clear
(
)
;
for
(
intptr_t
i
=
0
;
i
<
64
;
i
+
+
)
{
t
.
Add
(
(
const
void
*
)
i
)
;
}
ASSERT_EQ
(
t
.
EntryCount
(
)
64u
)
;
ASSERT_EQ
(
t
.
Capacity
(
)
128u
)
;
for
(
PLDHashTable
:
:
Iterator
iter
(
&
t
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
(
void
)
iter
.
Get
(
)
;
}
ASSERT_EQ
(
t
.
EntryCount
(
)
64u
)
;
ASSERT_EQ
(
t
.
Capacity
(
)
128u
)
;
for
(
auto
iter
=
t
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
PLDHashEntryStub
*
>
(
iter
.
Get
(
)
)
;
if
(
(
intptr_t
)
(
entry
-
>
key
)
%
4
=
=
0
)
{
iter
.
Remove
(
)
;
}
}
ASSERT_EQ
(
t
.
EntryCount
(
)
48u
)
;
ASSERT_EQ
(
t
.
Capacity
(
)
128u
)
;
for
(
auto
iter
=
t
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
PLDHashEntryStub
*
>
(
iter
.
Get
(
)
)
;
if
(
(
intptr_t
)
(
entry
-
>
key
)
%
2
=
=
0
)
{
iter
.
Remove
(
)
;
}
}
ASSERT_EQ
(
t
.
EntryCount
(
)
32u
)
;
ASSERT_EQ
(
t
.
Capacity
(
)
64u
)
;
for
(
auto
iter
=
t
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Remove
(
)
;
}
ASSERT_EQ
(
t
.
EntryCount
(
)
0u
)
;
ASSERT_EQ
(
t
.
Capacity
(
)
unsigned
(
PLDHashTable
:
:
kMinCapacity
)
)
;
}
#
ifdef
HAVE_64BIT_BUILD
TEST
(
PLDHashTableTest
GrowToMaxCapacity
)
{
PLDHashTable
*
t
=
new
PLDHashTable
(
&
trivialOps
sizeof
(
PLDHashEntryStub
)
128
)
;
size_t
numInserted
=
0
;
while
(
true
)
{
if
(
!
t
-
>
Add
(
(
const
void
*
)
numInserted
mozilla
:
:
fallible
)
)
{
break
;
}
numInserted
+
+
;
}
if
(
numInserted
!
=
PLDHashTable
:
:
kMaxCapacity
-
(
PLDHashTable
:
:
kMaxCapacity
>
>
5
)
)
{
delete
t
;
ASSERT_TRUE
(
false
)
;
}
delete
t
;
}
#
endif
