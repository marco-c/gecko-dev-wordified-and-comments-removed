#
include
<
functional
>
#
include
<
queue
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
MainThreadUtils
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CondVar
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ThrottledEventQueue
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
prinrval
.
h
"
using
mozilla
:
:
CondVar
;
using
mozilla
:
:
MakeRefPtr
;
using
mozilla
:
:
Mutex
;
using
std
:
:
function
;
using
std
:
:
move
;
using
std
:
:
string
;
namespace
TestThrottledEventQueue
{
struct
RunnableQueue
:
nsISerialEventTarget
{
std
:
:
queue
<
nsCOMPtr
<
nsIRunnable
>
>
runnables
;
bool
IsEmpty
(
)
{
return
runnables
.
empty
(
)
;
}
size_t
Length
(
)
{
return
runnables
.
size
(
)
;
}
[
[
nodiscard
]
]
nsresult
Run
(
)
{
while
(
!
runnables
.
empty
(
)
)
{
auto
runnable
=
move
(
runnables
.
front
(
)
)
;
runnables
.
pop
(
)
;
nsresult
rv
=
runnable
-
>
Run
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
return
NS_OK
;
}
[
[
nodiscard
]
]
NS_IMETHODIMP
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aFlags
)
override
{
MOZ_ALWAYS_TRUE
(
aFlags
=
=
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
runnables
.
push
(
aRunnable
)
;
return
NS_OK
;
}
[
[
nodiscard
]
]
NS_IMETHODIMP
DispatchFromScript
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
)
override
{
RefPtr
<
nsIRunnable
>
r
=
aRunnable
;
return
Dispatch
(
r
.
forget
(
)
aFlags
)
;
}
NS_IMETHOD_
(
bool
)
IsOnCurrentThreadInfallible
(
void
)
override
{
return
NS_IsMainThread
(
)
;
}
[
[
nodiscard
]
]
NS_IMETHOD
IsOnCurrentThread
(
bool
*
retval
)
override
{
*
retval
=
IsOnCurrentThreadInfallible
(
)
;
return
NS_OK
;
}
[
[
nodiscard
]
]
NS_IMETHODIMP
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aDelay
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_DECL_THREADSAFE_ISUPPORTS
private
:
virtual
~
RunnableQueue
(
)
=
default
;
}
;
NS_IMPL_ISUPPORTS
(
RunnableQueue
nsIEventTarget
nsISerialEventTarget
)
static
void
Enqueue
(
nsIEventTarget
*
target
function
<
void
(
)
>
&
&
aCallable
)
{
nsresult
rv
=
target
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
TEQ
GTest
"
move
(
aCallable
)
)
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
using
namespace
TestThrottledEventQueue
;
TEST
(
ThrottledEventQueue
RunnableQueue
)
{
string
log
;
RefPtr
<
RunnableQueue
>
queue
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
Enqueue
(
queue
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
Enqueue
(
queue
[
&
]
(
)
{
log
+
=
'
b
'
;
}
)
;
Enqueue
(
queue
[
&
]
(
)
{
log
+
=
'
c
'
;
}
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
queue
-
>
Run
(
)
)
)
;
ASSERT_EQ
(
log
"
abc
"
)
;
}
TEST
(
ThrottledEventQueue
SimpleDispatch
)
{
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
1
"
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_EQ
(
log
"
a
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
}
TEST
(
ThrottledEventQueue
MixedDispatch
)
{
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
2
"
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
1U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
1U
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
b
'
;
}
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
2U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
1U
)
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
c
'
;
}
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
2U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
2U
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_EQ
(
log
"
acb
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
}
TEST
(
ThrottledEventQueue
EnqueueFromRun
)
{
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
3
"
)
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
b
'
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
c
'
;
}
)
;
}
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
d
'
;
}
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_EQ
(
log
"
abdc
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
}
TEST
(
ThrottledEventQueue
RunFromRun
)
{
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
4
"
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
(
'
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
log
+
=
'
)
'
;
}
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_EQ
(
log
"
(
a
)
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
}
TEST
(
ThrottledEventQueue
DropWhileRunning
)
{
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
{
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
5
"
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
}
ASSERT_EQ
(
log
"
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_EQ
(
log
"
a
"
)
;
}
TEST
(
ThrottledEventQueue
AwaitIdle
)
{
Mutex
mutex
(
"
TEQ
AwaitIdle
"
)
;
CondVar
cond
(
mutex
"
TEQ
AwaitIdle
"
)
;
string
dequeue_await
;
bool
threadFinished
=
false
;
bool
runnableFinished
=
false
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
6
"
)
;
Enqueue
(
throttled
[
&
]
(
)
{
runnableFinished
=
true
;
}
)
;
nsCOMPtr
<
nsIRunnable
>
await
=
NS_NewRunnableFunction
(
"
TEQ
AwaitIdle
"
[
&
]
(
)
{
throttled
-
>
AwaitIdle
(
)
;
MutexAutoLock
lock
(
mutex
)
;
dequeue_await
+
=
"
await
"
;
threadFinished
=
true
;
cond
.
Notify
(
)
;
}
)
;
nsCOMPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
"
TEQ
AwaitIdle
"
getter_AddRefs
(
thread
)
await
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
100
)
)
;
{
MutexAutoLock
lock
(
mutex
)
;
ASSERT_EQ
(
dequeue_await
"
"
)
;
dequeue_await
+
=
"
dequeue
"
;
ASSERT_FALSE
(
threadFinished
)
;
}
ASSERT_FALSE
(
runnableFinished
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_TRUE
(
runnableFinished
)
;
{
MutexAutoLock
lock
(
mutex
)
;
while
(
!
threadFinished
)
cond
.
Wait
(
)
;
ASSERT_EQ
(
dequeue_await
"
dequeue
await
"
)
;
}
ASSERT_TRUE
(
NS_SUCCEEDED
(
thread
-
>
Shutdown
(
)
)
)
;
}
TEST
(
ThrottledEventQueue
AwaitIdleMixed
)
{
nsCOMPtr
<
nsIThread
>
thread
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
NS_NewNamedThread
(
"
AwaitIdleMixed
"
getter_AddRefs
(
thread
)
)
)
)
;
Mutex
mutex
(
"
AwaitIdleMixed
"
)
;
CondVar
cond
(
mutex
"
AwaitIdleMixed
"
)
;
string
log
;
bool
threadStarted
=
false
;
bool
threadFinished
=
false
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
7
"
)
;
Enqueue
(
throttled
[
&
]
(
)
{
MutexAutoLock
lock
(
mutex
)
;
log
+
=
'
a
'
;
}
)
;
Enqueue
(
throttled
[
&
]
(
)
{
MutexAutoLock
lock
(
mutex
)
;
log
+
=
'
b
'
;
}
)
;
nsCOMPtr
<
nsIRunnable
>
await
=
NS_NewRunnableFunction
(
"
AwaitIdleMixed
"
[
&
]
(
)
{
{
MutexAutoLock
lock
(
mutex
)
;
log
+
=
'
(
'
;
threadStarted
=
true
;
cond
.
Notify
(
)
;
}
throttled
-
>
AwaitIdle
(
)
;
{
MutexAutoLock
lock
(
mutex
)
;
log
+
=
'
)
'
;
threadFinished
=
true
;
cond
.
Notify
(
)
;
}
}
)
;
{
MutexAutoLock
lock
(
mutex
)
;
ASSERT_EQ
(
log
"
"
)
;
}
ASSERT_TRUE
(
NS_SUCCEEDED
(
thread
-
>
Dispatch
(
await
.
forget
(
)
)
)
)
;
{
MutexAutoLock
lock
(
mutex
)
;
while
(
!
threadStarted
)
cond
.
Wait
(
)
;
ASSERT_EQ
(
log
"
(
"
)
;
}
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
{
MutexAutoLock
lock
(
mutex
)
;
ASSERT_TRUE
(
log
=
=
"
(
ab
"
|
|
log
=
=
"
(
a
)
b
"
|
|
log
=
=
"
(
ab
)
"
)
;
while
(
!
threadFinished
)
cond
.
Wait
(
)
;
ASSERT_TRUE
(
log
=
=
"
(
a
)
b
"
|
|
log
=
=
"
(
ab
)
"
)
;
}
ASSERT_TRUE
(
NS_SUCCEEDED
(
thread
-
>
Shutdown
(
)
)
)
;
}
TEST
(
ThrottledEventQueue
SimplePauseResume
)
{
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
8
"
)
;
ASSERT_FALSE
(
throttled
-
>
IsPaused
(
)
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_EQ
(
log
"
a
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
true
)
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsPaused
(
)
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
b
'
;
}
)
;
ASSERT_EQ
(
log
"
a
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_EQ
(
log
"
a
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
false
)
)
)
;
ASSERT_FALSE
(
throttled
-
>
IsPaused
(
)
)
;
ASSERT_EQ
(
log
"
a
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_EQ
(
log
"
ab
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
}
TEST
(
ThrottledEventQueue
MixedPauseResume
)
{
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
9
"
)
;
ASSERT_FALSE
(
throttled
-
>
IsPaused
(
)
)
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
A
'
;
}
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
b
'
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
true
)
)
)
;
}
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
c
'
;
}
)
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
D
'
;
}
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_EQ
(
log
"
AbD
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_FALSE
(
throttled
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsPaused
(
)
)
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
E
'
;
}
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
false
)
)
)
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
F
'
;
}
)
;
ASSERT_FALSE
(
throttled
-
>
IsPaused
(
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_EQ
(
log
"
AbDEcF
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
}
TEST
(
ThrottledEventQueue
AwaitIdlePaused
)
{
Mutex
mutex
(
"
AwaitIdlePaused
"
)
;
CondVar
cond
(
mutex
"
AwaitIdlePaused
"
)
;
string
dequeue_await
;
bool
threadFinished
=
false
;
bool
runnableFinished
=
false
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
10
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
true
)
)
)
;
Enqueue
(
throttled
[
&
]
(
)
{
runnableFinished
=
true
;
}
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
await
=
NS_NewRunnableFunction
(
"
AwaitIdlePaused
"
[
&
]
(
)
{
throttled
-
>
AwaitIdle
(
)
;
MutexAutoLock
lock
(
mutex
)
;
dequeue_await
+
=
"
await
"
;
threadFinished
=
true
;
cond
.
Notify
(
)
;
}
)
;
nsCOMPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
"
AwaitIdlePaused
"
getter_AddRefs
(
thread
)
await
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
100
)
)
;
{
MutexAutoLock
lock
(
mutex
)
;
ASSERT_EQ
(
dequeue_await
"
"
)
;
dequeue_await
+
=
"
dequeue
"
;
ASSERT_FALSE
(
threadFinished
)
;
}
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_FALSE
(
throttled
-
>
IsEmpty
(
)
)
;
ASSERT_FALSE
(
runnableFinished
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
false
)
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
runnableFinished
)
;
{
MutexAutoLock
lock
(
mutex
)
;
while
(
!
threadFinished
)
cond
.
Wait
(
)
;
ASSERT_EQ
(
dequeue_await
"
dequeue
await
"
)
;
}
ASSERT_TRUE
(
NS_SUCCEEDED
(
thread
-
>
Shutdown
(
)
)
)
;
}
TEST
(
ThrottledEventQueue
ExecutorTransitions
)
{
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
11
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
true
)
)
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
1U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
0U
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
false
)
)
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
1U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
1U
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
true
)
)
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
1U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
0U
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
false
)
)
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
1U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
1U
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
base
-
>
Run
(
)
)
)
;
ASSERT_EQ
(
log
"
a
"
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
0U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
0U
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
true
)
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
false
)
)
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
0U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
0U
)
;
}
