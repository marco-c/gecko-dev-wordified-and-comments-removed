#
include
<
functional
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
MainThreadUtils
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CondVar
.
h
"
#
include
"
mozilla
/
gtest
/
MozAssertions
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ThrottledEventQueue
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
Helpers
.
h
"
using
mozilla
:
:
CondVar
;
using
mozilla
:
:
MakeRefPtr
;
using
mozilla
:
:
Mutex
;
using
mozilla
:
:
MutexAutoLock
;
using
mozilla
:
:
ThrottledEventQueue
;
namespace
TestThrottledEventQueue
{
static
void
Enqueue
(
nsIEventTarget
*
target
std
:
:
function
<
void
(
)
>
&
&
aCallable
)
{
nsresult
rv
=
target
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
TEQ
GTest
"
std
:
:
move
(
aCallable
)
)
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
using
namespace
TestThrottledEventQueue
;
using
testing
:
:
RunnableQueue
;
TEST
(
ThrottledEventQueue
RunnableQueue
)
{
std
:
:
string
log
;
RefPtr
<
RunnableQueue
>
queue
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
Enqueue
(
queue
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
Enqueue
(
queue
[
&
]
(
)
{
log
+
=
'
b
'
;
}
)
;
Enqueue
(
queue
[
&
]
(
)
{
log
+
=
'
c
'
;
}
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_NS_SUCCEEDED
(
queue
-
>
Run
(
)
)
;
ASSERT_EQ
(
log
"
abc
"
)
;
}
TEST
(
ThrottledEventQueue
SimpleDispatch
)
{
std
:
:
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
1
"
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_EQ
(
log
"
a
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
}
TEST
(
ThrottledEventQueue
MixedDispatch
)
{
std
:
:
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
2
"
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
1U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
1U
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
b
'
;
}
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
2U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
1U
)
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
c
'
;
}
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
2U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
2U
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_EQ
(
log
"
acb
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
}
TEST
(
ThrottledEventQueue
EnqueueFromRun
)
{
std
:
:
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
3
"
)
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
b
'
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
c
'
;
}
)
;
}
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
d
'
;
}
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_EQ
(
log
"
abdc
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
}
TEST
(
ThrottledEventQueue
RunFromRun
)
{
std
:
:
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
4
"
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
(
'
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
log
+
=
'
)
'
;
}
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_EQ
(
log
"
(
a
)
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
}
TEST
(
ThrottledEventQueue
DropWhileRunning
)
{
std
:
:
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
{
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
5
"
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
}
ASSERT_EQ
(
log
"
"
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_EQ
(
log
"
a
"
)
;
}
TEST
(
ThrottledEventQueue
AwaitIdle
)
{
Mutex
mutex
MOZ_UNANNOTATED
(
"
TEQ
AwaitIdle
"
)
;
CondVar
cond
(
mutex
"
TEQ
AwaitIdle
"
)
;
std
:
:
string
dequeue_await
;
bool
threadFinished
=
false
;
bool
runnableFinished
=
false
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
6
"
)
;
Enqueue
(
throttled
[
&
]
(
)
{
runnableFinished
=
true
;
}
)
;
nsCOMPtr
<
nsIRunnable
>
await
=
NS_NewRunnableFunction
(
"
TEQ
AwaitIdle
"
[
&
]
(
)
{
throttled
-
>
AwaitIdle
(
)
;
MutexAutoLock
lock
(
mutex
)
;
dequeue_await
+
=
"
await
"
;
threadFinished
=
true
;
cond
.
Notify
(
)
;
}
)
;
nsCOMPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
"
TEQ
AwaitIdle
"
getter_AddRefs
(
thread
)
await
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
100
)
)
;
{
MutexAutoLock
lock
(
mutex
)
;
ASSERT_EQ
(
dequeue_await
"
"
)
;
dequeue_await
+
=
"
dequeue
"
;
ASSERT_FALSE
(
threadFinished
)
;
}
ASSERT_FALSE
(
runnableFinished
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_TRUE
(
runnableFinished
)
;
{
MutexAutoLock
lock
(
mutex
)
;
while
(
!
threadFinished
)
cond
.
Wait
(
)
;
ASSERT_EQ
(
dequeue_await
"
dequeue
await
"
)
;
}
ASSERT_NS_SUCCEEDED
(
thread
-
>
Shutdown
(
)
)
;
}
TEST
(
ThrottledEventQueue
AwaitIdleMixed
)
{
nsCOMPtr
<
nsIThread
>
thread
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
NS_NewNamedThread
(
"
AwaitIdleMixed
"
getter_AddRefs
(
thread
)
)
)
)
;
Mutex
mutex
MOZ_UNANNOTATED
(
"
AwaitIdleMixed
"
)
;
CondVar
cond
(
mutex
"
AwaitIdleMixed
"
)
;
std
:
:
string
log
;
bool
threadStarted
=
false
;
bool
threadFinished
=
false
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
7
"
)
;
Enqueue
(
throttled
[
&
]
(
)
{
MutexAutoLock
lock
(
mutex
)
;
log
+
=
'
a
'
;
}
)
;
Enqueue
(
throttled
[
&
]
(
)
{
MutexAutoLock
lock
(
mutex
)
;
log
+
=
'
b
'
;
}
)
;
nsCOMPtr
<
nsIRunnable
>
await
=
NS_NewRunnableFunction
(
"
AwaitIdleMixed
"
[
&
]
(
)
{
{
MutexAutoLock
lock
(
mutex
)
;
log
+
=
'
(
'
;
threadStarted
=
true
;
cond
.
Notify
(
)
;
}
throttled
-
>
AwaitIdle
(
)
;
{
MutexAutoLock
lock
(
mutex
)
;
log
+
=
'
)
'
;
threadFinished
=
true
;
cond
.
Notify
(
)
;
}
}
)
;
{
MutexAutoLock
lock
(
mutex
)
;
ASSERT_EQ
(
log
"
"
)
;
}
ASSERT_NS_SUCCEEDED
(
thread
-
>
Dispatch
(
await
.
forget
(
)
)
)
;
{
MutexAutoLock
lock
(
mutex
)
;
while
(
!
threadStarted
)
cond
.
Wait
(
)
;
ASSERT_EQ
(
log
"
(
"
)
;
}
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
{
MutexAutoLock
lock
(
mutex
)
;
ASSERT_TRUE
(
log
=
=
"
(
ab
"
|
|
log
=
=
"
(
a
)
b
"
|
|
log
=
=
"
(
ab
)
"
)
;
while
(
!
threadFinished
)
cond
.
Wait
(
)
;
ASSERT_TRUE
(
log
=
=
"
(
a
)
b
"
|
|
log
=
=
"
(
ab
)
"
)
;
}
ASSERT_NS_SUCCEEDED
(
thread
-
>
Shutdown
(
)
)
;
}
TEST
(
ThrottledEventQueue
SimplePauseResume
)
{
std
:
:
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
8
"
)
;
ASSERT_FALSE
(
throttled
-
>
IsPaused
(
)
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_EQ
(
log
"
a
"
)
;
ASSERT_NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
true
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsPaused
(
)
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
b
'
;
}
)
;
ASSERT_EQ
(
log
"
a
"
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_EQ
(
log
"
a
"
)
;
ASSERT_NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
false
)
)
;
ASSERT_FALSE
(
throttled
-
>
IsPaused
(
)
)
;
ASSERT_EQ
(
log
"
a
"
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_EQ
(
log
"
ab
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
}
TEST
(
ThrottledEventQueue
MixedPauseResume
)
{
std
:
:
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
9
"
)
;
ASSERT_FALSE
(
throttled
-
>
IsPaused
(
)
)
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
A
'
;
}
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
b
'
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
true
)
)
)
;
}
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
c
'
;
}
)
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
D
'
;
}
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_EQ
(
log
"
AbD
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_FALSE
(
throttled
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsPaused
(
)
)
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
E
'
;
}
)
;
ASSERT_NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
false
)
)
;
Enqueue
(
base
[
&
]
(
)
{
log
+
=
'
F
'
;
}
)
;
ASSERT_FALSE
(
throttled
-
>
IsPaused
(
)
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_EQ
(
log
"
AbDEcF
"
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
}
TEST
(
ThrottledEventQueue
AwaitIdlePaused
)
{
Mutex
mutex
MOZ_UNANNOTATED
(
"
AwaitIdlePaused
"
)
;
CondVar
cond
(
mutex
"
AwaitIdlePaused
"
)
;
std
:
:
string
dequeue_await
;
bool
threadFinished
=
false
;
bool
runnableFinished
=
false
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
10
"
)
;
ASSERT_NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
true
)
)
;
Enqueue
(
throttled
[
&
]
(
)
{
runnableFinished
=
true
;
}
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
await
=
NS_NewRunnableFunction
(
"
AwaitIdlePaused
"
[
&
]
(
)
{
throttled
-
>
AwaitIdle
(
)
;
MutexAutoLock
lock
(
mutex
)
;
dequeue_await
+
=
"
await
"
;
threadFinished
=
true
;
cond
.
Notify
(
)
;
}
)
;
nsCOMPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
"
AwaitIdlePaused
"
getter_AddRefs
(
thread
)
await
)
;
ASSERT_NS_SUCCEEDED
(
rv
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
100
)
)
;
{
MutexAutoLock
lock
(
mutex
)
;
ASSERT_EQ
(
dequeue_await
"
"
)
;
dequeue_await
+
=
"
dequeue
"
;
ASSERT_FALSE
(
threadFinished
)
;
}
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_FALSE
(
throttled
-
>
IsEmpty
(
)
)
;
ASSERT_FALSE
(
runnableFinished
)
;
ASSERT_NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
false
)
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_TRUE
(
base
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
throttled
-
>
IsEmpty
(
)
)
;
ASSERT_TRUE
(
runnableFinished
)
;
{
MutexAutoLock
lock
(
mutex
)
;
while
(
!
threadFinished
)
cond
.
Wait
(
)
;
ASSERT_EQ
(
dequeue_await
"
dequeue
await
"
)
;
}
ASSERT_NS_SUCCEEDED
(
thread
-
>
Shutdown
(
)
)
;
}
TEST
(
ThrottledEventQueue
ExecutorTransitions
)
{
std
:
:
string
log
;
auto
base
=
MakeRefPtr
<
RunnableQueue
>
(
)
;
RefPtr
<
ThrottledEventQueue
>
throttled
=
ThrottledEventQueue
:
:
Create
(
base
"
test
queue
11
"
)
;
ASSERT_NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
true
)
)
;
Enqueue
(
throttled
[
&
]
(
)
{
log
+
=
'
a
'
;
}
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
1U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
0U
)
;
ASSERT_NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
false
)
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
1U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
1U
)
;
ASSERT_NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
true
)
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
1U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
0U
)
;
ASSERT_NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
false
)
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
1U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
1U
)
;
ASSERT_EQ
(
log
"
"
)
;
ASSERT_NS_SUCCEEDED
(
base
-
>
Run
(
)
)
;
ASSERT_EQ
(
log
"
a
"
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
0U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
0U
)
;
ASSERT_NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
true
)
)
;
ASSERT_NS_SUCCEEDED
(
throttled
-
>
SetIsPaused
(
false
)
)
;
ASSERT_EQ
(
throttled
-
>
Length
(
)
0U
)
;
ASSERT_EQ
(
base
-
>
Length
(
)
0U
)
;
}
