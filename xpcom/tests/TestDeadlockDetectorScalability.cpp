#
undef
MOZ_DMD
#
include
"
TestHarness
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
define
PASS
(
)
\
do
{
\
passed
(
__FUNCTION__
)
;
\
return
NS_OK
;
\
}
while
(
0
)
#
define
FAIL
(
why
)
\
do
{
\
fail
(
"
%
s
|
%
s
-
%
s
"
__FILE__
__FUNCTION__
why
)
;
\
return
NS_ERROR_FAILURE
;
\
}
while
(
0
)
#
undef
DD_TEST1
#
undef
DD_TEST2
#
undef
DD_TEST3
#
undef
DD_TEST4
#
ifdef
DD_TEST1
static
void
AllocLockRecurseUnlockFree
(
int
i
)
{
if
(
0
=
=
i
)
return
;
mozilla
:
:
Mutex
*
lock
=
new
mozilla
:
:
Mutex
(
"
deadlockDetector
.
scalability
.
t1
"
)
;
{
mozilla
:
:
MutexAutoLock
_
(
*
lock
)
;
AllocLockRecurseUnlockFree
(
i
-
1
)
;
}
delete
lock
;
}
static
nsresult
LengthNDepChain
(
int
N
)
{
AllocLockRecurseUnlockFree
(
N
)
;
PASS
(
)
;
}
#
endif
#
ifdef
DD_TEST2
static
nsresult
OneLockNDeps
(
const
int
N
const
int
K
)
{
mozilla
:
:
Mutex
*
lock
=
new
mozilla
:
:
Mutex
(
"
deadlockDetector
.
scalability
.
t2
.
master
"
)
;
mozilla
:
:
Mutex
*
*
locks
=
new
mozilla
:
:
Mutex
*
[
N
]
;
if
(
!
locks
)
NS_RUNTIMEABORT
(
"
couldn
'
t
allocate
lock
array
"
)
;
for
(
int
i
=
0
;
i
<
N
;
+
+
i
)
locks
[
i
]
=
new
mozilla
:
:
Mutex
(
"
deadlockDetector
.
scalability
.
t2
.
dep
"
)
;
{
mozilla
:
:
MutexAutoLock
m
(
*
lock
)
;
for
(
int
i
=
0
;
i
<
N
;
+
+
i
)
mozilla
:
:
MutexAutoLock
s
(
*
locks
[
i
]
)
;
}
{
mozilla
:
:
MutexAutoLock
m
(
*
lock
)
;
for
(
int
i
=
0
;
i
<
K
;
+
+
i
)
for
(
int
j
=
0
;
j
<
N
;
+
+
j
)
mozilla
:
:
MutexAutoLock
s
(
*
locks
[
i
]
)
;
}
for
(
int
i
=
0
;
i
<
N
;
+
+
i
)
delete
locks
[
i
]
;
delete
[
]
locks
;
PASS
(
)
;
}
#
endif
#
ifdef
DD_TEST3
static
nsresult
MaxDepsNsq
(
const
int
N
const
int
K
)
{
mozilla
:
:
Mutex
*
*
locks
=
new
mozilla
:
:
Mutex
*
[
N
]
;
if
(
!
locks
)
NS_RUNTIMEABORT
(
"
couldn
'
t
allocate
lock
array
"
)
;
for
(
int
i
=
0
;
i
<
N
;
+
+
i
)
locks
[
i
]
=
new
mozilla
:
:
Mutex
(
"
deadlockDetector
.
scalability
.
t3
"
)
;
for
(
int
i
=
0
;
i
<
N
;
+
+
i
)
{
mozilla
:
:
MutexAutoLock
al1
(
*
locks
[
i
]
)
;
for
(
int
j
=
i
+
1
;
j
<
N
;
+
+
j
)
mozilla
:
:
MutexAutoLock
al2
(
*
locks
[
j
]
)
;
}
for
(
int
i
=
0
;
i
<
K
;
+
+
i
)
{
for
(
int
j
=
0
;
j
<
N
;
+
+
j
)
{
mozilla
:
:
MutexAutoLock
al1
(
*
locks
[
j
]
)
;
for
(
int
k
=
j
+
1
;
k
<
N
;
+
+
k
)
mozilla
:
:
MutexAutoLock
al2
(
*
locks
[
k
]
)
;
}
}
for
(
int
i
=
0
;
i
<
N
;
+
+
i
)
delete
locks
[
i
]
;
delete
[
]
locks
;
PASS
(
)
;
}
#
endif
#
ifdef
DD_TEST4
static
nsresult
OneLockNDepsUsedSeveralTimes
(
const
size_t
N
const
size_t
K
)
{
mozilla
:
:
Mutex
*
lock_1
=
new
mozilla
:
:
Mutex
(
"
deadlockDetector
.
scalability
.
t4
.
master
"
)
;
for
(
size_t
n
=
0
;
n
<
N
;
n
+
+
)
{
mozilla
:
:
Mutex
*
lock_2
=
new
mozilla
:
:
Mutex
(
"
deadlockDetector
.
scalability
.
t4
.
child
"
)
;
mozilla
:
:
MutexAutoLock
m
(
*
lock_1
)
;
for
(
size_t
k
=
0
;
k
<
K
;
k
+
+
)
{
mozilla
:
:
MutexAutoLock
c
(
*
lock_2
)
;
}
delete
lock_2
;
}
delete
lock_1
;
PASS
(
)
;
}
#
endif
MOZ_DEFINE_MALLOC_SIZE_OF
(
DeadlockDetectorMallocSizeOf
)
int
main
(
int
argc
char
*
*
argv
)
{
ScopedXPCOM
xpcom
(
"
Deadlock
detector
scalability
(
"
__FILE__
"
)
"
)
;
if
(
xpcom
.
failed
(
)
)
return
1
;
int
rv
=
0
;
#
ifndef
DD_TEST1
puts
(
"
Skipping
not
-
requested
LengthNDepChain
(
)
test
"
)
;
#
else
if
(
NS_FAILED
(
LengthNDepChain
(
1
<
<
14
)
)
)
rv
=
1
;
#
endif
#
ifndef
DD_TEST2
puts
(
"
Skipping
not
-
requested
OneLockNDeps
(
)
test
"
)
;
#
else
if
(
NS_FAILED
(
OneLockNDeps
(
1
<
<
17
100
)
)
)
rv
=
1
;
#
endif
#
ifndef
DD_TEST3
puts
(
"
Skipping
not
-
requested
MaxDepsNsq
(
)
test
"
)
;
#
else
if
(
NS_FAILED
(
MaxDepsNsq
(
1
<
<
10
10
)
)
)
rv
=
1
;
#
endif
#
ifndef
DD_TEST4
puts
(
"
Skipping
not
-
requested
OneLockNDepsUsedSeveralTimes
(
)
test
"
)
;
#
else
if
(
NS_FAILED
(
OneLockNDepsUsedSeveralTimes
(
1
<
<
17
3
)
)
)
rv
=
1
;
#
endif
size_t
memory_used
=
mozilla
:
:
BlockingResourceBase
:
:
SizeOfDeadlockDetector
(
DeadlockDetectorMallocSizeOf
)
;
printf_stderr
(
"
Used
%
d
bytes
\
n
"
(
int
)
memory_used
)
;
return
rv
;
}
