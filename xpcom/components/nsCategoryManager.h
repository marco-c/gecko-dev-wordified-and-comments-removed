#
ifndef
NSCATEGORYMANAGER_H
#
define
NSCATEGORYMANAGER_H
#
include
"
prio
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
mozilla
/
ArenaAllocator
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
class
nsIMemoryReporter
;
typedef
mozilla
:
:
ArenaAllocator
<
1024
*
8
8
>
CategoryAllocator
;
#
define
NS_CATEGORYMANAGER_CID
\
{
0x16d222a6
0x1dd2
0x11b2
\
{
0xb6
0x93
0xf3
0x8b
0x02
0xc0
0x21
0xb2
}
}
class
CategoryLeaf
:
public
nsDepCharHashKey
{
public
:
explicit
CategoryLeaf
(
const
char
*
aKey
)
:
nsDepCharHashKey
(
aKey
)
value
(
nullptr
)
{
}
const
char
*
value
;
}
;
class
CategoryNode
{
public
:
nsresult
GetLeaf
(
const
nsACString
&
aEntryName
nsACString
&
aResult
)
;
nsresult
AddLeaf
(
const
nsACString
&
aEntryName
const
nsACString
&
aValue
bool
aReplace
nsACString
&
aResult
CategoryAllocator
*
aArena
)
;
void
DeleteLeaf
(
const
nsACString
&
aEntryName
)
;
void
Clear
(
)
{
mozilla
:
:
MutexAutoLock
lock
(
mLock
)
;
mTable
.
Clear
(
)
;
}
uint32_t
Count
(
)
{
mozilla
:
:
MutexAutoLock
lock
(
mLock
)
;
uint32_t
tCount
=
mTable
.
Count
(
)
;
return
tCount
;
}
nsresult
Enumerate
(
nsISimpleEnumerator
*
*
aResult
)
;
static
CategoryNode
*
Create
(
CategoryAllocator
*
aArena
)
;
~
CategoryNode
(
)
;
void
operator
delete
(
void
*
)
{
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
;
private
:
CategoryNode
(
)
:
mLock
(
"
CategoryLeaf
"
)
{
}
void
*
operator
new
(
size_t
aSize
CategoryAllocator
*
aArena
)
;
nsTHashtable
<
CategoryLeaf
>
mTable
;
mozilla
:
:
Mutex
mLock
;
}
;
class
nsCategoryManager
final
:
public
nsICategoryManager
public
nsIMemoryReporter
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSICATEGORYMANAGER
NS_DECL_NSIMEMORYREPORTER
nsresult
SuppressNotifications
(
bool
aSuppress
)
;
void
AddCategoryEntry
(
const
nsACString
&
aCategory
const
nsACString
&
aKey
const
nsACString
&
aValue
bool
aReplace
nsACString
&
aOldValue
)
;
void
AddCategoryEntry
(
const
nsACString
&
aCategory
const
nsACString
&
aKey
const
nsACString
&
aValue
bool
aReplace
=
true
)
{
nsCString
oldValue
;
return
AddCategoryEntry
(
aCategory
aKey
aValue
aReplace
oldValue
)
;
}
static
nsresult
Create
(
nsISupports
*
aOuter
REFNSIID
aIID
void
*
*
aResult
)
;
void
InitMemoryReporter
(
)
;
static
nsCategoryManager
*
GetSingleton
(
)
;
static
void
Destroy
(
)
;
private
:
static
nsCategoryManager
*
gCategoryManager
;
nsCategoryManager
(
)
;
~
nsCategoryManager
(
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
;
CategoryNode
*
get_category
(
const
nsACString
&
aName
)
;
void
NotifyObservers
(
const
char
*
aTopic
const
nsACString
&
aCategoryName
const
nsACString
&
aEntryName
)
;
CategoryAllocator
mArena
;
nsClassHashtable
<
nsDepCharHashKey
CategoryNode
>
mTable
;
mozilla
:
:
Mutex
mLock
;
bool
mSuppressNotifications
;
}
;
#
endif
