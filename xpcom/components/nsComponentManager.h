#
ifndef
nsComponentManager_h__
#
define
nsComponentManager_h__
#
include
"
nsXPCOM
.
h
"
#
include
"
xpcom
-
private
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsIComponentRegistrar
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
mozilla
/
ArenaAllocator
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Module
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsIFactory
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
prtime
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsInterfaceHashtable
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Omnijar
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
struct
nsFactoryEntry
;
struct
PRThread
;
#
define
NS_COMPONENTMANAGER_CID
\
{
/
*
91775d60
-
d5dc
-
11d2
-
92fb
-
00e09805570f
*
/
\
0x91775d60
0xd5dc
0x11d2
{
\
0x92
0xfb
0x00
0xe0
0x98
0x05
0x57
0x0f
\
}
\
}
extern
const
mozilla
:
:
Module
kXPCOMModule
;
namespace
{
class
MutexLock
;
}
namespace
mozilla
{
namespace
xpcom
{
bool
ProcessSelectorMatches
(
Module
:
:
ProcessSelector
aSelector
)
;
bool
FastProcessSelectorMatches
(
Module
:
:
ProcessSelector
aSelector
)
;
}
}
class
SafeMutex
{
public
:
explicit
SafeMutex
(
const
char
*
aName
)
:
mMutex
(
aName
)
mOwnerThread
(
nullptr
)
{
}
~
SafeMutex
(
)
{
}
void
Lock
(
)
{
AssertNotCurrentThreadOwns
(
)
;
mMutex
.
Lock
(
)
;
MOZ_ASSERT
(
mOwnerThread
=
=
nullptr
)
;
mOwnerThread
=
PR_GetCurrentThread
(
)
;
}
void
Unlock
(
)
{
MOZ_ASSERT
(
mOwnerThread
=
=
PR_GetCurrentThread
(
)
)
;
mOwnerThread
=
nullptr
;
mMutex
.
Unlock
(
)
;
}
void
AssertCurrentThreadOwns
(
)
const
{
MOZ_ASSERT
(
mOwnerThread
=
=
PR_GetCurrentThread
(
)
)
;
}
MOZ_NEVER_INLINE
void
AssertNotCurrentThreadOwns
(
)
const
{
if
(
PR_GetCurrentThread
(
)
=
=
mOwnerThread
)
{
MOZ_CRASH
(
)
;
}
}
private
:
mozilla
:
:
Mutex
mMutex
;
mozilla
:
:
Atomic
<
PRThread
*
mozilla
:
:
Relaxed
>
mOwnerThread
;
}
;
typedef
mozilla
:
:
BaseAutoLock
<
SafeMutex
&
>
SafeMutexAutoLock
;
typedef
mozilla
:
:
BaseAutoUnlock
<
SafeMutex
&
>
SafeMutexAutoUnlock
;
class
nsComponentManagerImpl
final
:
public
nsIComponentManager
public
nsIServiceManager
public
nsSupportsWeakReference
public
nsIComponentRegistrar
public
nsIInterfaceRequestor
public
nsIMemoryReporter
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSICOMPONENTMANAGER
NS_DECL_NSICOMPONENTREGISTRAR
NS_DECL_NSIMEMORYREPORTER
static
nsresult
Create
(
nsISupports
*
aOuter
REFNSIID
aIID
void
*
*
aResult
)
;
nsresult
RegistryLocationForFile
(
nsIFile
*
aFile
nsCString
&
aResult
)
;
nsresult
FileForRegistryLocation
(
const
nsCString
&
aLocation
nsIFile
*
*
aSpec
)
;
NS_DECL_NSISERVICEMANAGER
nsComponentManagerImpl
(
)
;
static
nsComponentManagerImpl
*
gComponentManager
;
nsresult
Init
(
)
;
nsresult
Shutdown
(
void
)
;
nsresult
FreeServices
(
)
;
already_AddRefed
<
nsIFactory
>
FindFactory
(
const
nsCID
&
aClass
)
;
already_AddRefed
<
nsIFactory
>
FindFactory
(
const
char
*
aContractID
uint32_t
aContractIDLen
)
;
already_AddRefed
<
nsIFactory
>
LoadFactory
(
nsFactoryEntry
*
aEntry
)
;
nsFactoryEntry
*
GetFactoryEntry
(
const
char
*
aContractID
uint32_t
aContractIDLen
)
;
nsFactoryEntry
*
GetFactoryEntry
(
const
nsCID
&
aClass
)
;
nsDataHashtable
<
nsIDPointerHashKey
nsFactoryEntry
*
>
mFactories
;
nsDataHashtable
<
nsCStringHashKey
nsFactoryEntry
*
>
mContractIDs
;
SafeMutex
mLock
;
static
void
InitializeStaticModules
(
)
;
static
void
InitializeModuleLocations
(
)
;
struct
ComponentLocation
{
NSLocationType
type
;
mozilla
:
:
FileLocation
location
;
}
;
class
ComponentLocationComparator
{
public
:
bool
Equals
(
const
ComponentLocation
&
aA
const
ComponentLocation
&
aB
)
const
{
return
(
aA
.
type
=
=
aB
.
type
&
&
aA
.
location
.
Equals
(
aB
.
location
)
)
;
}
}
;
static
nsTArray
<
ComponentLocation
>
*
sModuleLocations
;
class
KnownModule
{
public
:
explicit
KnownModule
(
const
mozilla
:
:
Module
*
aModule
)
:
mModule
(
aModule
)
mLoaded
(
false
)
mFailed
(
false
)
{
}
explicit
KnownModule
(
mozilla
:
:
FileLocation
&
aFile
)
:
mModule
(
nullptr
)
mFile
(
aFile
)
mLoaded
(
false
)
mFailed
(
false
)
{
}
~
KnownModule
(
)
{
if
(
mLoaded
&
&
mModule
-
>
unloadProc
)
{
mModule
-
>
unloadProc
(
)
;
}
}
bool
Load
(
)
;
const
mozilla
:
:
Module
*
Module
(
)
const
{
return
mModule
;
}
nsCString
Description
(
)
const
;
private
:
const
mozilla
:
:
Module
*
mModule
;
mozilla
:
:
FileLocation
mFile
;
bool
mLoaded
;
bool
mFailed
;
}
;
nsTArray
<
nsAutoPtr
<
KnownModule
>
>
mKnownStaticModules
;
nsClassHashtable
<
nsCStringHashKey
KnownModule
>
mKnownModules
;
void
RegisterModule
(
const
mozilla
:
:
Module
*
aModule
)
;
void
RegisterCIDEntryLocked
(
const
mozilla
:
:
Module
:
:
CIDEntry
*
aEntry
KnownModule
*
aModule
)
;
void
RegisterContractIDLocked
(
const
mozilla
:
:
Module
:
:
ContractIDEntry
*
aEntry
)
;
void
RegisterManifest
(
NSLocationType
aType
mozilla
:
:
FileLocation
&
aFile
bool
aChromeOnly
)
;
struct
ManifestProcessingContext
{
ManifestProcessingContext
(
NSLocationType
aType
mozilla
:
:
FileLocation
&
aFile
bool
aChromeOnly
)
:
mType
(
aType
)
mFile
(
aFile
)
mChromeOnly
(
aChromeOnly
)
{
}
~
ManifestProcessingContext
(
)
{
}
NSLocationType
mType
;
mozilla
:
:
FileLocation
mFile
;
bool
mChromeOnly
;
}
;
void
ManifestManifest
(
ManifestProcessingContext
&
aCx
int
aLineNo
char
*
const
*
aArgv
)
;
void
ManifestComponent
(
ManifestProcessingContext
&
aCx
int
aLineNo
char
*
const
*
aArgv
)
;
void
ManifestContract
(
ManifestProcessingContext
&
aCx
int
aLineNo
char
*
const
*
aArgv
)
;
void
ManifestCategory
(
ManifestProcessingContext
&
aCx
int
aLineNo
char
*
const
*
aArgv
)
;
void
RereadChromeManifests
(
bool
aChromeOnly
=
true
)
;
enum
{
NOT_INITIALIZED
NORMAL
SHUTDOWN_IN_PROGRESS
SHUTDOWN_COMPLETE
}
mStatus
;
mozilla
:
:
ArenaAllocator
<
1024
*
8
8
>
mArena
;
struct
PendingServiceInfo
{
const
nsCID
*
cid
;
PRThread
*
thread
;
}
;
inline
PendingServiceInfo
*
AddPendingService
(
const
nsCID
&
aServiceCID
PRThread
*
aThread
)
;
inline
void
RemovePendingService
(
const
nsCID
&
aServiceCID
)
;
inline
PRThread
*
GetPendingServiceThread
(
const
nsCID
&
aServiceCID
)
const
;
nsTArray
<
PendingServiceInfo
>
mPendingServices
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
~
nsComponentManagerImpl
(
)
;
nsresult
GetServiceLocked
(
MutexLock
&
aLock
nsFactoryEntry
&
aEntry
const
nsIID
&
aIID
void
*
*
aResult
)
;
}
;
#
define
NS_MAX_FILENAME_LEN
1024
#
define
NS_ERROR_IS_DIR
NS_ERROR_GENERATE_FAILURE
(
NS_ERROR_MODULE_XPCOM
24
)
struct
nsFactoryEntry
{
nsFactoryEntry
(
const
mozilla
:
:
Module
:
:
CIDEntry
*
aEntry
nsComponentManagerImpl
:
:
KnownModule
*
aModule
)
;
nsFactoryEntry
(
const
nsCID
&
aClass
nsIFactory
*
aFactory
)
;
~
nsFactoryEntry
(
)
;
already_AddRefed
<
nsIFactory
>
GetFactory
(
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
;
const
mozilla
:
:
Module
:
:
CIDEntry
*
mCIDEntry
;
nsComponentManagerImpl
:
:
KnownModule
*
mModule
;
nsCOMPtr
<
nsIFactory
>
mFactory
;
nsCOMPtr
<
nsISupports
>
mServiceObject
;
}
;
#
endif
