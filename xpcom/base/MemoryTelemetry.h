#
ifndef
mozilla_MemoryTelemetry_h
#
define
mozilla_MemoryTelemetry_h
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
<
functional
>
class
nsIEventTarget
;
namespace
mozilla
{
namespace
ipc
{
enum
class
ResponseRejectReason
;
}
class
MemoryTelemetry
final
:
public
nsIObserver
public
nsSupportsWeakReference
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
static
MemoryTelemetry
&
Get
(
)
;
nsresult
GatherReports
(
const
std
:
:
function
<
void
(
)
>
&
aCompletionCallback
=
nullptr
)
;
void
GetUniqueSetSize
(
std
:
:
function
<
void
(
const
int64_t
&
)
>
&
&
aCallback
)
;
nsresult
DelayedInit
(
)
;
nsresult
Shutdown
(
)
;
private
:
MemoryTelemetry
(
)
;
~
MemoryTelemetry
(
)
=
default
;
void
Init
(
)
;
static
Result
<
uint32_t
nsresult
>
GetOpenTabsCount
(
)
;
class
TotalMemoryGatherer
final
:
public
nsITimerCallback
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSITIMERCALLBACK
TotalMemoryGatherer
(
)
=
default
;
void
CollectParentSize
(
int64_t
aResident
)
;
void
CollectResult
(
int64_t
aChildUSS
)
;
void
OnFailure
(
ipc
:
:
ResponseRejectReason
aReason
)
;
void
Begin
(
nsIEventTarget
*
aThreadPool
)
;
private
:
~
TotalMemoryGatherer
(
)
=
default
;
nsresult
MaybeFinish
(
)
;
nsCOMPtr
<
nsITimer
>
mTimeout
;
nsTArray
<
int64_t
>
mChildSizes
;
int64_t
mTotalMemory
=
0
;
uint32_t
mRemainingChildCount
=
0
;
bool
mHaveParentSize
=
false
;
}
;
nsCOMPtr
<
nsIEventTarget
>
mThreadPool
;
RefPtr
<
TotalMemoryGatherer
>
mTotalMemoryGatherer
;
TimeStamp
mLastPoll
{
}
;
}
;
}
#
endif
