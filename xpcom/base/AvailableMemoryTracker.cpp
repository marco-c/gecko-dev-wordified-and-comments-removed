#
include
"
mozilla
/
AvailableMemoryTracker
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
endif
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
if
defined
(
MOZ_MEMORY
)
#
include
"
mozmemory
.
h
"
#
endif
using
namespace
mozilla
;
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
sNumLowPhysicalMemEvents
;
namespace
{
#
if
defined
(
XP_WIN
)
#
if
(
NTDDI_VERSION
<
NTDDI_WINBLUE
)
|
|
\
(
NTDDI_VERSION
=
=
NTDDI_WINBLUE
&
&
!
defined
(
WINBLUE_KBSPRING14
)
)
static
const
HEAP_INFORMATION_CLASS
HeapOptimizeResources
=
static_cast
<
HEAP_INFORMATION_CLASS
>
(
3
)
;
static
const
DWORD
HEAP_OPTIMIZE_RESOURCES_CURRENT_VERSION
=
1
;
typedef
struct
_HEAP_OPTIMIZE_RESOURCES_INFORMATION
{
DWORD
Version
;
DWORD
Flags
;
}
HEAP_OPTIMIZE_RESOURCES_INFORMATION
*
PHEAP_OPTIMIZE_RESOURCES_INFORMATION
;
#
endif
static
int64_t
LowMemoryEventsPhysicalDistinguishedAmount
(
)
{
return
sNumLowPhysicalMemEvents
;
}
class
LowEventsReporter
final
:
public
nsIMemoryReporter
{
~
LowEventsReporter
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
MOZ_COLLECT_REPORT
(
"
low
-
memory
-
events
/
physical
"
KIND_OTHER
UNITS_COUNT_CUMULATIVE
LowMemoryEventsPhysicalDistinguishedAmount
(
)
"
Number
of
low
-
physical
-
memory
events
fired
since
startup
.
We
fire
such
an
"
"
event
when
a
windows
low
memory
resource
notification
is
signaled
.
The
"
"
machine
will
start
to
page
if
it
runs
out
of
physical
memory
.
This
may
"
"
cause
it
to
run
slowly
but
it
shouldn
'
t
cause
it
to
crash
.
"
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
LowEventsReporter
nsIMemoryReporter
)
#
endif
class
nsJemallocFreeDirtyPagesRunnable
final
:
public
Runnable
{
~
nsJemallocFreeDirtyPagesRunnable
(
)
=
default
;
#
if
defined
(
XP_WIN
)
void
OptimizeSystemHeap
(
)
;
#
endif
public
:
NS_DECL_NSIRUNNABLE
nsJemallocFreeDirtyPagesRunnable
(
)
:
Runnable
(
"
nsJemallocFreeDirtyPagesRunnable
"
)
{
}
}
;
NS_IMETHODIMP
nsJemallocFreeDirtyPagesRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
if
defined
(
MOZ_MEMORY
)
jemalloc_free_dirty_pages
(
)
;
#
endif
#
if
defined
(
XP_WIN
)
OptimizeSystemHeap
(
)
;
#
endif
return
NS_OK
;
}
#
if
defined
(
XP_WIN
)
void
nsJemallocFreeDirtyPagesRunnable
:
:
OptimizeSystemHeap
(
)
{
if
(
IsWin8Point1OrLater
(
)
)
{
HEAP_OPTIMIZE_RESOURCES_INFORMATION
heapOptInfo
=
{
HEAP_OPTIMIZE_RESOURCES_CURRENT_VERSION
}
;
:
:
HeapSetInformation
(
nullptr
HeapOptimizeResources
&
heapOptInfo
sizeof
(
heapOptInfo
)
)
;
}
}
#
endif
class
nsMemoryPressureWatcher
final
:
public
nsIObserver
{
~
nsMemoryPressureWatcher
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
void
Init
(
)
;
}
;
NS_IMPL_ISUPPORTS
(
nsMemoryPressureWatcher
nsIObserver
)
void
nsMemoryPressureWatcher
:
:
Init
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
this
"
memory
-
pressure
"
false
)
;
}
}
NS_IMETHODIMP
nsMemoryPressureWatcher
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
!
strcmp
(
aTopic
"
memory
-
pressure
"
)
"
Unknown
topic
"
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
nsJemallocFreeDirtyPagesRunnable
(
)
;
NS_DispatchToMainThread
(
runnable
)
;
return
NS_OK
;
}
}
namespace
mozilla
{
namespace
AvailableMemoryTracker
{
void
Init
(
)
{
RefPtr
<
nsMemoryPressureWatcher
>
watcher
=
new
nsMemoryPressureWatcher
(
)
;
watcher
-
>
Init
(
)
;
#
if
defined
(
XP_WIN
)
RegisterLowMemoryEventsPhysicalDistinguishedAmount
(
LowMemoryEventsPhysicalDistinguishedAmount
)
;
#
endif
}
}
}
