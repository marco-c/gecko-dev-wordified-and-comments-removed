#
include
"
mozilla
/
AvailableMemoryTracker
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
prinrval
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsMemoryPressure
.
h
"
#
endif
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
nsWindowsDllInterceptor
.
h
"
#
include
<
windows
.
h
>
#
endif
#
if
defined
(
MOZ_MEMORY
)
#
include
"
mozmemory
.
h
"
#
endif
using
namespace
mozilla
;
namespace
{
#
if
defined
(
XP_WIN
)
#
if
defined
(
HAVE_64BIT_BUILD
)
static
const
size_t
kLowVirtualMemoryThreshold
=
0
;
#
else
static
const
size_t
kLowVirtualMemoryThreshold
=
256
*
1024
*
1024
;
#
endif
static
const
size_t
kLowCommitSpaceThreshold
=
256
*
1024
*
1024
;
static
const
size_t
kLowPhysicalMemoryThreshold
=
0
;
static
const
uint32_t
kLowMemoryNotificationIntervalMS
=
10000
;
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
sNumLowVirtualMemEvents
;
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
sNumLowCommitSpaceEvents
;
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
sNumLowPhysicalMemEvents
;
#
if
!
defined
(
HAVE_64BIT_BUILD
)
WindowsDllInterceptor
sKernel32Intercept
;
WindowsDllInterceptor
sGdi32Intercept
;
bool
sInitialized
=
false
;
bool
sHooksActive
=
false
;
volatile
bool
sUnderMemoryPressure
=
false
;
volatile
PRIntervalTime
sLastLowMemoryNotificationTime
;
void
*
(
WINAPI
*
sVirtualAllocOrig
)
(
LPVOID
aAddress
SIZE_T
aSize
DWORD
aAllocationType
DWORD
aProtect
)
;
void
*
(
WINAPI
*
sMapViewOfFileOrig
)
(
HANDLE
aFileMappingObject
DWORD
aDesiredAccess
DWORD
aFileOffsetHigh
DWORD
aFileOffsetLow
SIZE_T
aNumBytesToMap
)
;
HBITMAP
(
WINAPI
*
sCreateDIBSectionOrig
)
(
HDC
aDC
const
BITMAPINFO
*
aBitmapInfo
UINT
aUsage
VOID
*
*
aBits
HANDLE
aSection
DWORD
aOffset
)
;
bool
MaybeScheduleMemoryPressureEvent
(
)
{
MemoryPressureState
state
=
MemPressure_New
;
PRIntervalTime
now
=
PR_IntervalNow
(
)
;
PRIntervalTime
interval
=
now
-
sLastLowMemoryNotificationTime
;
if
(
sUnderMemoryPressure
)
{
if
(
PR_IntervalToMilliseconds
(
interval
)
<
kLowMemoryNotificationIntervalMS
)
{
return
false
;
}
state
=
MemPressure_Ongoing
;
}
sUnderMemoryPressure
=
true
;
sLastLowMemoryNotificationTime
=
now
;
NS_DispatchEventualMemoryPressure
(
state
)
;
return
true
;
}
static
bool
CheckLowMemory
(
DWORDLONG
available
size_t
threshold
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
&
counter
)
{
if
(
available
<
threshold
)
{
if
(
MaybeScheduleMemoryPressureEvent
(
)
)
{
counter
+
+
;
}
return
true
;
}
return
false
;
}
void
CheckMemAvailable
(
)
{
if
(
!
sHooksActive
)
{
return
;
}
MEMORYSTATUSEX
stat
;
stat
.
dwLength
=
sizeof
(
stat
)
;
bool
success
=
GlobalMemoryStatusEx
(
&
stat
)
;
if
(
success
)
{
bool
lowMemory
=
CheckLowMemory
(
stat
.
ullAvailVirtual
kLowVirtualMemoryThreshold
sNumLowVirtualMemEvents
)
;
lowMemory
|
=
CheckLowMemory
(
stat
.
ullAvailPageFile
kLowCommitSpaceThreshold
sNumLowCommitSpaceEvents
)
;
lowMemory
|
=
CheckLowMemory
(
stat
.
ullAvailPhys
kLowPhysicalMemoryThreshold
sNumLowPhysicalMemEvents
)
;
sUnderMemoryPressure
=
lowMemory
;
}
}
LPVOID
WINAPI
VirtualAllocHook
(
LPVOID
aAddress
SIZE_T
aSize
DWORD
aAllocationType
DWORD
aProtect
)
{
LPVOID
result
=
sVirtualAllocOrig
(
aAddress
aSize
aAllocationType
aProtect
)
;
if
(
(
kLowVirtualMemoryThreshold
!
=
0
&
&
aAllocationType
&
MEM_RESERVE
)
|
|
(
(
kLowCommitSpaceThreshold
!
=
0
|
|
kLowPhysicalMemoryThreshold
!
=
0
)
&
&
aAllocationType
&
MEM_COMMIT
)
)
{
CheckMemAvailable
(
)
;
}
return
result
;
}
LPVOID
WINAPI
MapViewOfFileHook
(
HANDLE
aFileMappingObject
DWORD
aDesiredAccess
DWORD
aFileOffsetHigh
DWORD
aFileOffsetLow
SIZE_T
aNumBytesToMap
)
{
LPVOID
result
=
sMapViewOfFileOrig
(
aFileMappingObject
aDesiredAccess
aFileOffsetHigh
aFileOffsetLow
aNumBytesToMap
)
;
CheckMemAvailable
(
)
;
return
result
;
}
HBITMAP
WINAPI
CreateDIBSectionHook
(
HDC
aDC
const
BITMAPINFO
*
aBitmapInfo
UINT
aUsage
VOID
*
*
aBits
HANDLE
aSection
DWORD
aOffset
)
{
bool
doCheck
=
false
;
if
(
sHooksActive
&
&
!
aSection
&
&
aBitmapInfo
)
{
uint16_t
bitCount
=
aBitmapInfo
-
>
bmiHeader
.
biBitCount
;
if
(
bitCount
=
=
0
)
{
bitCount
=
32
;
}
int64_t
size
=
bitCount
*
aBitmapInfo
-
>
bmiHeader
.
biWidth
*
aBitmapInfo
-
>
bmiHeader
.
biHeight
;
if
(
size
<
0
)
{
size
*
=
-
1
;
}
if
(
size
>
1024
*
1024
*
8
)
{
doCheck
=
true
;
}
}
HBITMAP
result
=
sCreateDIBSectionOrig
(
aDC
aBitmapInfo
aUsage
aBits
aSection
aOffset
)
;
if
(
doCheck
)
{
CheckMemAvailable
(
)
;
}
return
result
;
}
#
else
class
nsAvailableMemoryWatcher
final
:
public
nsIObserver
public
nsITimerCallback
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSITIMERCALLBACK
nsresult
Init
(
)
;
private
:
static
const
uint32_t
kPollingIntervalMS
=
1000
;
static
const
char
*
const
kObserverTopics
[
]
;
static
bool
IsVirtualMemoryLow
(
const
MEMORYSTATUSEX
&
aStat
)
;
static
bool
IsCommitSpaceLow
(
const
MEMORYSTATUSEX
&
aStat
)
;
static
bool
IsPhysicalMemoryLow
(
const
MEMORYSTATUSEX
&
aStat
)
;
~
nsAvailableMemoryWatcher
(
)
{
}
;
void
AdjustPollingInterval
(
const
bool
aLowMemory
)
;
void
SendMemoryPressureEvent
(
)
;
void
Shutdown
(
)
;
nsCOMPtr
<
nsITimer
>
mTimer
;
bool
mUnderMemoryPressure
;
}
;
const
char
*
const
nsAvailableMemoryWatcher
:
:
kObserverTopics
[
]
=
{
"
quit
-
application
"
"
user
-
interaction
-
active
"
"
user
-
interaction
-
inactive
"
}
;
NS_IMPL_ISUPPORTS
(
nsAvailableMemoryWatcher
nsIObserver
nsITimerCallback
)
nsresult
nsAvailableMemoryWatcher
:
:
Init
(
)
{
mTimer
=
NS_NewTimer
(
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
observerService
)
;
for
(
auto
topic
:
kObserverTopics
)
{
nsresult
rv
=
observerService
-
>
AddObserver
(
this
topic
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
MOZ_TRY
(
mTimer
-
>
InitWithCallback
(
this
kPollingIntervalMS
nsITimer
:
:
TYPE_REPEATING_SLACK
)
)
;
return
NS_OK
;
}
void
nsAvailableMemoryWatcher
:
:
Shutdown
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
observerService
)
;
for
(
auto
topic
:
kObserverTopics
)
{
Unused
<
<
observerService
-
>
RemoveObserver
(
this
topic
)
;
}
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
}
bool
nsAvailableMemoryWatcher
:
:
IsVirtualMemoryLow
(
const
MEMORYSTATUSEX
&
aStat
)
{
if
(
(
kLowVirtualMemoryThreshold
!
=
0
)
&
&
(
aStat
.
ullAvailVirtual
<
kLowVirtualMemoryThreshold
)
)
{
sNumLowVirtualMemEvents
+
+
;
return
true
;
}
return
false
;
}
bool
nsAvailableMemoryWatcher
:
:
IsCommitSpaceLow
(
const
MEMORYSTATUSEX
&
aStat
)
{
if
(
(
kLowCommitSpaceThreshold
!
=
0
)
&
&
(
aStat
.
ullAvailPageFile
<
kLowCommitSpaceThreshold
)
)
{
sNumLowCommitSpaceEvents
+
+
;
return
true
;
}
return
false
;
}
bool
nsAvailableMemoryWatcher
:
:
IsPhysicalMemoryLow
(
const
MEMORYSTATUSEX
&
aStat
)
{
if
(
(
kLowPhysicalMemoryThreshold
!
=
0
)
&
&
(
aStat
.
ullAvailPhys
<
kLowPhysicalMemoryThreshold
)
)
{
sNumLowPhysicalMemEvents
+
+
;
return
true
;
}
return
false
;
}
void
nsAvailableMemoryWatcher
:
:
SendMemoryPressureEvent
(
)
{
MemoryPressureState
state
=
mUnderMemoryPressure
?
MemPressure_Ongoing
:
MemPressure_New
;
NS_DispatchEventualMemoryPressure
(
state
)
;
}
void
nsAvailableMemoryWatcher
:
:
AdjustPollingInterval
(
const
bool
aLowMemory
)
{
if
(
aLowMemory
)
{
mTimer
-
>
SetDelay
(
kLowMemoryNotificationIntervalMS
)
;
}
else
if
(
mUnderMemoryPressure
)
{
mTimer
-
>
SetDelay
(
kPollingIntervalMS
)
;
}
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
Notify
(
nsITimer
*
aTimer
)
{
MEMORYSTATUSEX
stat
;
stat
.
dwLength
=
sizeof
(
stat
)
;
bool
success
=
GlobalMemoryStatusEx
(
&
stat
)
;
if
(
success
)
{
bool
lowMemory
=
IsVirtualMemoryLow
(
stat
)
|
|
IsCommitSpaceLow
(
stat
)
|
|
IsPhysicalMemoryLow
(
stat
)
;
if
(
lowMemory
)
{
SendMemoryPressureEvent
(
)
;
}
AdjustPollingInterval
(
lowMemory
)
;
mUnderMemoryPressure
=
lowMemory
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
strcmp
(
aTopic
"
quit
-
application
"
)
=
=
0
)
{
Shutdown
(
)
;
}
else
if
(
strcmp
(
aTopic
"
user
-
interaction
-
inactive
"
)
=
=
0
)
{
mTimer
-
>
Cancel
(
)
;
}
else
if
(
strcmp
(
aTopic
"
user
-
interaction
-
active
"
)
=
=
0
)
{
mTimer
-
>
InitWithCallback
(
this
kPollingIntervalMS
nsITimer
:
:
TYPE_REPEATING_SLACK
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
topic
"
)
;
}
return
NS_OK
;
}
#
endif
static
int64_t
LowMemoryEventsVirtualDistinguishedAmount
(
)
{
return
sNumLowVirtualMemEvents
;
}
static
int64_t
LowMemoryEventsCommitSpaceDistinguishedAmount
(
)
{
return
sNumLowCommitSpaceEvents
;
}
static
int64_t
LowMemoryEventsPhysicalDistinguishedAmount
(
)
{
return
sNumLowPhysicalMemEvents
;
}
class
LowEventsReporter
final
:
public
nsIMemoryReporter
{
~
LowEventsReporter
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
MOZ_COLLECT_REPORT
(
"
low
-
memory
-
events
/
virtual
"
KIND_OTHER
UNITS_COUNT_CUMULATIVE
LowMemoryEventsVirtualDistinguishedAmount
(
)
"
Number
of
low
-
virtual
-
memory
events
fired
since
startup
.
We
fire
such
an
"
"
event
if
we
notice
there
is
less
than
memory
.
low_virtual_mem_threshold_mb
of
"
"
virtual
address
space
available
(
if
zero
this
behavior
is
disabled
)
.
The
"
"
process
will
probably
crash
if
it
runs
out
of
virtual
address
space
so
"
"
this
event
is
dire
.
"
)
;
MOZ_COLLECT_REPORT
(
"
low
-
memory
-
events
/
commit
-
space
"
KIND_OTHER
UNITS_COUNT_CUMULATIVE
LowMemoryEventsCommitSpaceDistinguishedAmount
(
)
"
Number
of
low
-
commit
-
space
events
fired
since
startup
.
We
fire
such
an
"
"
event
if
we
notice
there
is
less
than
memory
.
low_commit_space_threshold_mb
of
"
"
commit
space
available
(
if
zero
this
behavior
is
disabled
)
.
Windows
will
"
"
likely
kill
the
process
if
it
runs
out
of
commit
space
so
this
event
is
"
"
dire
.
"
)
;
MOZ_COLLECT_REPORT
(
"
low
-
memory
-
events
/
physical
"
KIND_OTHER
UNITS_COUNT_CUMULATIVE
LowMemoryEventsPhysicalDistinguishedAmount
(
)
"
Number
of
low
-
physical
-
memory
events
fired
since
startup
.
We
fire
such
an
"
"
event
if
we
notice
there
is
less
than
memory
.
low_physical_memory_threshold_mb
"
"
of
physical
memory
available
(
if
zero
this
behavior
is
disabled
)
.
The
"
"
machine
will
start
to
page
if
it
runs
out
of
physical
memory
.
This
may
"
"
cause
it
to
run
slowly
but
it
shouldn
'
t
cause
it
to
crash
.
"
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
LowEventsReporter
nsIMemoryReporter
)
#
endif
class
nsJemallocFreeDirtyPagesRunnable
final
:
public
nsIRunnable
{
~
nsJemallocFreeDirtyPagesRunnable
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIRUNNABLE
}
;
NS_IMPL_ISUPPORTS
(
nsJemallocFreeDirtyPagesRunnable
nsIRunnable
)
NS_IMETHODIMP
nsJemallocFreeDirtyPagesRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
if
defined
(
MOZ_MEMORY
)
jemalloc_free_dirty_pages
(
)
;
#
endif
return
NS_OK
;
}
class
nsMemoryPressureWatcher
final
:
public
nsIObserver
{
~
nsMemoryPressureWatcher
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
void
Init
(
)
;
}
;
NS_IMPL_ISUPPORTS
(
nsMemoryPressureWatcher
nsIObserver
)
void
nsMemoryPressureWatcher
:
:
Init
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
this
"
memory
-
pressure
"
false
)
;
}
}
NS_IMETHODIMP
nsMemoryPressureWatcher
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
!
strcmp
(
aTopic
"
memory
-
pressure
"
)
"
Unknown
topic
"
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
nsJemallocFreeDirtyPagesRunnable
(
)
;
NS_DispatchToMainThread
(
runnable
)
;
return
NS_OK
;
}
}
namespace
mozilla
{
namespace
AvailableMemoryTracker
{
void
Activate
(
)
{
#
if
defined
(
XP_WIN
)
&
&
!
defined
(
HAVE_64BIT_BUILD
)
MOZ_ASSERT
(
sInitialized
)
;
MOZ_ASSERT
(
!
sHooksActive
)
;
RegisterStrongMemoryReporter
(
new
LowEventsReporter
(
)
)
;
RegisterLowMemoryEventsVirtualDistinguishedAmount
(
LowMemoryEventsVirtualDistinguishedAmount
)
;
RegisterLowMemoryEventsPhysicalDistinguishedAmount
(
LowMemoryEventsPhysicalDistinguishedAmount
)
;
sHooksActive
=
true
;
#
endif
RefPtr
<
nsMemoryPressureWatcher
>
watcher
=
new
nsMemoryPressureWatcher
(
)
;
watcher
-
>
Init
(
)
;
#
if
defined
(
XP_WIN
)
&
&
defined
(
HAVE_64BIT_BUILD
)
if
(
XRE_IsParentProcess
(
)
)
{
RefPtr
<
nsAvailableMemoryWatcher
>
poller
=
new
nsAvailableMemoryWatcher
(
)
;
if
(
NS_FAILED
(
poller
-
>
Init
(
)
)
)
{
NS_WARNING
(
"
Could
not
start
the
available
memory
watcher
"
)
;
}
}
#
endif
}
void
Init
(
)
{
#
if
defined
(
XP_WIN
)
&
&
!
defined
(
HAVE_64BIT_BUILD
)
if
(
!
PR_GetEnv
(
"
MOZ_PGO_INSTRUMENTED
"
)
)
{
sKernel32Intercept
.
Init
(
"
Kernel32
.
dll
"
)
;
sKernel32Intercept
.
AddHook
(
"
VirtualAlloc
"
reinterpret_cast
<
intptr_t
>
(
VirtualAllocHook
)
reinterpret_cast
<
void
*
*
>
(
&
sVirtualAllocOrig
)
)
;
sKernel32Intercept
.
AddHook
(
"
MapViewOfFile
"
reinterpret_cast
<
intptr_t
>
(
MapViewOfFileHook
)
reinterpret_cast
<
void
*
*
>
(
&
sMapViewOfFileOrig
)
)
;
sGdi32Intercept
.
Init
(
"
Gdi32
.
dll
"
)
;
sGdi32Intercept
.
AddHook
(
"
CreateDIBSection
"
reinterpret_cast
<
intptr_t
>
(
CreateDIBSectionHook
)
reinterpret_cast
<
void
*
*
>
(
&
sCreateDIBSectionOrig
)
)
;
}
sInitialized
=
true
;
#
endif
}
}
}
