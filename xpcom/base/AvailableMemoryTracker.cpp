#
include
"
mozilla
/
AvailableMemoryTracker
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsMemoryPressure
.
h
"
#
include
"
memoryapi
.
h
"
#
endif
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
if
defined
(
MOZ_MEMORY
)
#
include
"
mozmemory
.
h
"
#
endif
using
namespace
mozilla
;
namespace
{
#
if
defined
(
XP_WIN
)
#
if
(
NTDDI_VERSION
<
NTDDI_WINBLUE
)
|
|
\
(
NTDDI_VERSION
=
=
NTDDI_WINBLUE
&
&
!
defined
(
WINBLUE_KBSPRING14
)
)
static
const
HEAP_INFORMATION_CLASS
HeapOptimizeResources
=
static_cast
<
HEAP_INFORMATION_CLASS
>
(
3
)
;
static
const
DWORD
HEAP_OPTIMIZE_RESOURCES_CURRENT_VERSION
=
1
;
typedef
struct
_HEAP_OPTIMIZE_RESOURCES_INFORMATION
{
DWORD
Version
;
DWORD
Flags
;
}
HEAP_OPTIMIZE_RESOURCES_INFORMATION
*
PHEAP_OPTIMIZE_RESOURCES_INFORMATION
;
#
endif
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
sNumLowPhysicalMemEvents
;
class
nsAvailableMemoryWatcher
final
:
public
nsIObserver
public
nsITimerCallback
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSITIMERCALLBACK
nsAvailableMemoryWatcher
(
)
;
nsresult
Init
(
)
;
private
:
static
const
uint32_t
kLowMemoryNotificationIntervalMS
=
10000
;
static
const
char
*
const
kObserverTopics
[
]
;
static
VOID
CALLBACK
LowMemoryCallback
(
PVOID
aContext
BOOLEAN
aIsTimer
)
;
static
void
RecordLowMemoryEvent
(
)
;
~
nsAvailableMemoryWatcher
(
)
{
}
;
bool
RegisterMemoryResourceHandler
(
)
;
void
UnregisterMemoryResourceHandler
(
)
;
void
Shutdown
(
const
MutexAutoLock
&
)
;
bool
ListenForLowMemory
(
)
;
void
OnLowMemory
(
const
MutexAutoLock
&
)
;
void
OnHighMemory
(
const
MutexAutoLock
&
)
;
bool
IsMemoryLow
(
)
const
;
bool
IsCommitSpaceLow
(
)
const
;
void
StartPollingIfUserInteracting
(
)
;
void
StopPolling
(
)
;
void
StopPollingIfUserIdle
(
const
MutexAutoLock
&
)
;
void
OnUserInteracting
(
const
MutexAutoLock
&
)
;
void
OnUserIdle
(
const
MutexAutoLock
&
)
;
Mutex
mMutex
;
nsCOMPtr
<
nsITimer
>
mTimer
;
HANDLE
mLowMemoryHandle
;
HANDLE
mWaitHandle
;
bool
mPolling
;
bool
mInteracting
;
bool
mUnderMemoryPressure
;
}
;
const
char
*
const
nsAvailableMemoryWatcher
:
:
kObserverTopics
[
]
=
{
"
quit
-
application
"
"
user
-
interaction
-
active
"
"
user
-
interaction
-
inactive
"
}
;
NS_IMPL_ISUPPORTS
(
nsAvailableMemoryWatcher
nsIObserver
nsITimerCallback
)
nsAvailableMemoryWatcher
:
:
nsAvailableMemoryWatcher
(
)
:
mMutex
(
"
low
memory
callback
mutex
"
)
mTimer
(
nullptr
)
mLowMemoryHandle
(
nullptr
)
mWaitHandle
(
nullptr
)
mPolling
(
false
)
mInteracting
(
false
)
mUnderMemoryPressure
(
false
)
{
}
nsresult
nsAvailableMemoryWatcher
:
:
Init
(
)
{
mTimer
=
NS_NewTimer
(
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
observerService
)
;
if
(
!
RegisterMemoryResourceHandler
(
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
auto
topic
:
kObserverTopics
)
{
nsresult
rv
=
observerService
-
>
AddObserver
(
this
topic
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
VOID
CALLBACK
nsAvailableMemoryWatcher
:
:
LowMemoryCallback
(
PVOID
aContext
BOOLEAN
aIsTimer
)
{
nsAvailableMemoryWatcher
*
watcher
=
static_cast
<
nsAvailableMemoryWatcher
*
>
(
aContext
)
;
if
(
!
aIsTimer
)
{
MutexAutoLock
lock
(
watcher
-
>
mMutex
)
;
watcher
-
>
OnLowMemory
(
lock
)
;
}
}
void
nsAvailableMemoryWatcher
:
:
RecordLowMemoryEvent
(
)
{
sNumLowPhysicalMemEvents
+
+
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
LowPhysicalMemoryEvents
sNumLowPhysicalMemEvents
)
;
}
bool
nsAvailableMemoryWatcher
:
:
RegisterMemoryResourceHandler
(
)
{
mLowMemoryHandle
=
:
:
CreateMemoryResourceNotification
(
LowMemoryResourceNotification
)
;
if
(
!
mLowMemoryHandle
)
{
return
false
;
}
return
ListenForLowMemory
(
)
;
}
void
nsAvailableMemoryWatcher
:
:
UnregisterMemoryResourceHandler
(
)
{
if
(
mWaitHandle
)
{
Unused
<
<
:
:
UnregisterWait
(
mWaitHandle
)
;
mWaitHandle
=
nullptr
;
}
if
(
mLowMemoryHandle
)
{
Unused
<
<
:
:
CloseHandle
(
mLowMemoryHandle
)
;
mLowMemoryHandle
=
nullptr
;
}
}
void
nsAvailableMemoryWatcher
:
:
Shutdown
(
const
MutexAutoLock
&
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
observerService
)
;
for
(
auto
topic
:
kObserverTopics
)
{
Unused
<
<
observerService
-
>
RemoveObserver
(
this
topic
)
;
}
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
UnregisterMemoryResourceHandler
(
)
;
}
bool
nsAvailableMemoryWatcher
:
:
ListenForLowMemory
(
)
{
if
(
mLowMemoryHandle
&
&
!
mWaitHandle
)
{
return
:
:
RegisterWaitForSingleObject
(
&
mWaitHandle
mLowMemoryHandle
LowMemoryCallback
this
INFINITE
WT_EXECUTEDEFAULT
|
WT_EXECUTEONLYONCE
)
;
}
return
false
;
}
void
nsAvailableMemoryWatcher
:
:
OnLowMemory
(
const
MutexAutoLock
&
)
{
mUnderMemoryPressure
=
true
;
:
:
UnregisterWait
(
mWaitHandle
)
;
mWaitHandle
=
nullptr
;
if
(
IsCommitSpaceLow
(
)
)
{
RecordLowMemoryEvent
(
)
;
NS_DispatchEventualMemoryPressure
(
MemPressure_New
)
;
}
StartPollingIfUserInteracting
(
)
;
}
void
nsAvailableMemoryWatcher
:
:
OnHighMemory
(
const
MutexAutoLock
&
)
{
mUnderMemoryPressure
=
false
;
NS_DispatchEventualMemoryPressure
(
MemPressure_Stopping
)
;
StopPolling
(
)
;
ListenForLowMemory
(
)
;
}
bool
nsAvailableMemoryWatcher
:
:
IsMemoryLow
(
)
const
{
BOOL
lowMemory
=
FALSE
;
if
(
:
:
QueryMemoryResourceNotification
(
mLowMemoryHandle
&
lowMemory
)
)
{
return
lowMemory
;
}
return
false
;
}
bool
nsAvailableMemoryWatcher
:
:
IsCommitSpaceLow
(
)
const
{
MEMORYSTATUSEX
memStatus
=
{
sizeof
(
memStatus
)
}
;
if
(
!
:
:
GlobalMemoryStatusEx
(
&
memStatus
)
)
{
return
false
;
}
constexpr
size_t
kBytesPerMB
=
1024
*
1024
;
return
(
memStatus
.
ullAvailPageFile
/
kBytesPerMB
)
<
StaticPrefs
:
:
browser_low_commit_space_threshold_mb
(
)
;
}
void
nsAvailableMemoryWatcher
:
:
StartPollingIfUserInteracting
(
)
{
if
(
mInteracting
&
&
!
mPolling
)
{
if
(
NS_SUCCEEDED
(
mTimer
-
>
InitWithCallback
(
this
kLowMemoryNotificationIntervalMS
nsITimer
:
:
TYPE_REPEATING_SLACK
)
)
)
{
mPolling
=
true
;
}
}
}
void
nsAvailableMemoryWatcher
:
:
StopPolling
(
)
{
mTimer
-
>
Cancel
(
)
;
mPolling
=
false
;
}
void
nsAvailableMemoryWatcher
:
:
StopPollingIfUserIdle
(
const
MutexAutoLock
&
)
{
if
(
!
mInteracting
)
{
StopPolling
(
)
;
}
}
void
nsAvailableMemoryWatcher
:
:
OnUserInteracting
(
const
MutexAutoLock
&
)
{
mInteracting
=
true
;
if
(
mUnderMemoryPressure
)
{
StartPollingIfUserInteracting
(
)
;
}
}
void
nsAvailableMemoryWatcher
:
:
OnUserIdle
(
const
MutexAutoLock
&
)
{
mInteracting
=
false
;
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
Notify
(
nsITimer
*
aTimer
)
{
MutexAutoLock
lock
(
mMutex
)
;
StopPollingIfUserIdle
(
lock
)
;
if
(
!
IsMemoryLow
(
)
)
{
OnHighMemory
(
lock
)
;
return
NS_OK
;
}
if
(
IsCommitSpaceLow
(
)
)
{
NS_DispatchEventualMemoryPressure
(
MemPressure_Ongoing
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
strcmp
(
aTopic
"
quit
-
application
"
)
=
=
0
)
{
Shutdown
(
lock
)
;
}
else
if
(
strcmp
(
aTopic
"
user
-
interaction
-
inactive
"
)
=
=
0
)
{
OnUserIdle
(
lock
)
;
}
else
if
(
strcmp
(
aTopic
"
user
-
interaction
-
active
"
)
=
=
0
)
{
OnUserInteracting
(
lock
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
topic
"
)
;
}
return
NS_OK
;
}
static
int64_t
LowMemoryEventsPhysicalDistinguishedAmount
(
)
{
return
sNumLowPhysicalMemEvents
;
}
class
LowEventsReporter
final
:
public
nsIMemoryReporter
{
~
LowEventsReporter
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
MOZ_COLLECT_REPORT
(
"
low
-
memory
-
events
/
physical
"
KIND_OTHER
UNITS_COUNT_CUMULATIVE
LowMemoryEventsPhysicalDistinguishedAmount
(
)
"
Number
of
low
-
physical
-
memory
events
fired
since
startup
.
We
fire
such
an
"
"
event
when
a
windows
low
memory
resource
notification
is
signaled
.
The
"
"
machine
will
start
to
page
if
it
runs
out
of
physical
memory
.
This
may
"
"
cause
it
to
run
slowly
but
it
shouldn
'
t
cause
it
to
crash
.
"
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
LowEventsReporter
nsIMemoryReporter
)
#
endif
class
nsJemallocFreeDirtyPagesRunnable
final
:
public
Runnable
{
~
nsJemallocFreeDirtyPagesRunnable
(
)
=
default
;
#
if
defined
(
XP_WIN
)
void
OptimizeSystemHeap
(
)
;
#
endif
public
:
NS_DECL_NSIRUNNABLE
nsJemallocFreeDirtyPagesRunnable
(
)
:
Runnable
(
"
nsJemallocFreeDirtyPagesRunnable
"
)
{
}
}
;
NS_IMETHODIMP
nsJemallocFreeDirtyPagesRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
if
defined
(
MOZ_MEMORY
)
jemalloc_free_dirty_pages
(
)
;
#
endif
#
if
defined
(
XP_WIN
)
OptimizeSystemHeap
(
)
;
#
endif
return
NS_OK
;
}
#
if
defined
(
XP_WIN
)
void
nsJemallocFreeDirtyPagesRunnable
:
:
OptimizeSystemHeap
(
)
{
if
(
IsWin8Point1OrLater
(
)
)
{
HEAP_OPTIMIZE_RESOURCES_INFORMATION
heapOptInfo
=
{
HEAP_OPTIMIZE_RESOURCES_CURRENT_VERSION
}
;
:
:
HeapSetInformation
(
nullptr
HeapOptimizeResources
&
heapOptInfo
sizeof
(
heapOptInfo
)
)
;
}
}
#
endif
class
nsMemoryPressureWatcher
final
:
public
nsIObserver
{
~
nsMemoryPressureWatcher
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
void
Init
(
)
;
}
;
NS_IMPL_ISUPPORTS
(
nsMemoryPressureWatcher
nsIObserver
)
void
nsMemoryPressureWatcher
:
:
Init
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
this
"
memory
-
pressure
"
false
)
;
}
}
NS_IMETHODIMP
nsMemoryPressureWatcher
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
!
strcmp
(
aTopic
"
memory
-
pressure
"
)
"
Unknown
topic
"
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
nsJemallocFreeDirtyPagesRunnable
(
)
;
NS_DispatchToMainThread
(
runnable
)
;
return
NS_OK
;
}
}
namespace
mozilla
{
namespace
AvailableMemoryTracker
{
void
Init
(
)
{
RefPtr
<
nsMemoryPressureWatcher
>
watcher
=
new
nsMemoryPressureWatcher
(
)
;
watcher
-
>
Init
(
)
;
#
if
defined
(
XP_WIN
)
RegisterLowMemoryEventsPhysicalDistinguishedAmount
(
LowMemoryEventsPhysicalDistinguishedAmount
)
;
if
(
XRE_IsParentProcess
(
)
)
{
RefPtr
<
nsAvailableMemoryWatcher
>
poller
=
new
nsAvailableMemoryWatcher
(
)
;
if
(
NS_FAILED
(
poller
-
>
Init
(
)
)
)
{
NS_WARNING
(
"
Could
not
start
the
available
memory
watcher
"
)
;
}
}
#
endif
}
}
}
