#
include
"
mozilla
/
AvailableMemoryTracker
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsICrashReporter
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsMemoryPressure
.
h
"
#
endif
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
if
defined
(
MOZ_MEMORY
)
#
include
"
mozmemory
.
h
"
#
endif
using
namespace
mozilla
;
namespace
{
#
if
defined
(
XP_WIN
)
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
sNumLowVirtualMemEvents
;
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
sNumLowCommitSpaceEvents
;
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
sNumLowPhysicalMemEvents
;
class
nsAvailableMemoryWatcher
final
:
public
nsIObserver
public
nsITimerCallback
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSITIMERCALLBACK
nsAvailableMemoryWatcher
(
)
;
nsresult
Init
(
)
;
private
:
#
if
defined
(
HAVE_64BIT_BUILD
)
static
const
size_t
kLowVirtualMemoryThreshold
=
0
;
#
else
static
const
size_t
kLowVirtualMemoryThreshold
=
256
*
1024
*
1024
;
#
endif
static
const
size_t
kLowCommitSpaceThreshold
=
256
*
1024
*
1024
;
static
const
size_t
kLowPhysicalMemoryThreshold
=
0
;
static
const
uint32_t
kLowMemoryNotificationIntervalMS
=
10000
;
static
const
uint32_t
kPollingIntervalMS
=
1000
;
static
const
char
*
const
kObserverTopics
[
]
;
static
bool
IsVirtualMemoryLow
(
const
MEMORYSTATUSEX
&
aStat
)
;
static
bool
IsCommitSpaceLow
(
const
MEMORYSTATUSEX
&
aStat
)
;
static
bool
IsPhysicalMemoryLow
(
const
MEMORYSTATUSEX
&
aStat
)
;
~
nsAvailableMemoryWatcher
(
)
{
}
;
bool
OngoingMemoryPressure
(
)
{
return
mUnderMemoryPressure
;
}
void
AdjustPollingInterval
(
const
bool
aLowMemory
)
;
void
SendMemoryPressureEvent
(
)
;
void
MaybeSaveMemoryReport
(
)
;
void
Shutdown
(
)
;
nsCOMPtr
<
nsITimer
>
mTimer
;
bool
mUnderMemoryPressure
;
bool
mSavedReport
;
}
;
const
char
*
const
nsAvailableMemoryWatcher
:
:
kObserverTopics
[
]
=
{
"
quit
-
application
"
"
user
-
interaction
-
active
"
"
user
-
interaction
-
inactive
"
}
;
NS_IMPL_ISUPPORTS
(
nsAvailableMemoryWatcher
nsIObserver
nsITimerCallback
)
nsAvailableMemoryWatcher
:
:
nsAvailableMemoryWatcher
(
)
:
mTimer
(
nullptr
)
mUnderMemoryPressure
(
false
)
mSavedReport
(
false
)
{
}
nsresult
nsAvailableMemoryWatcher
:
:
Init
(
)
{
mTimer
=
NS_NewTimer
(
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
observerService
)
;
for
(
auto
topic
:
kObserverTopics
)
{
nsresult
rv
=
observerService
-
>
AddObserver
(
this
topic
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
MOZ_TRY
(
mTimer
-
>
InitWithCallback
(
this
kPollingIntervalMS
nsITimer
:
:
TYPE_REPEATING_SLACK
)
)
;
return
NS_OK
;
}
void
nsAvailableMemoryWatcher
:
:
Shutdown
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
observerService
)
;
for
(
auto
topic
:
kObserverTopics
)
{
Unused
<
<
observerService
-
>
RemoveObserver
(
this
topic
)
;
}
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
}
bool
nsAvailableMemoryWatcher
:
:
IsVirtualMemoryLow
(
const
MEMORYSTATUSEX
&
aStat
)
{
if
(
(
kLowVirtualMemoryThreshold
!
=
0
)
&
&
(
aStat
.
ullAvailVirtual
<
kLowVirtualMemoryThreshold
)
)
{
sNumLowVirtualMemEvents
+
+
;
return
true
;
}
return
false
;
}
bool
nsAvailableMemoryWatcher
:
:
IsCommitSpaceLow
(
const
MEMORYSTATUSEX
&
aStat
)
{
if
(
(
kLowCommitSpaceThreshold
!
=
0
)
&
&
(
aStat
.
ullAvailPageFile
<
kLowCommitSpaceThreshold
)
)
{
sNumLowCommitSpaceEvents
+
+
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
LowCommitSpaceEvents
uint32_t
(
sNumLowCommitSpaceEvents
)
)
;
return
true
;
}
return
false
;
}
bool
nsAvailableMemoryWatcher
:
:
IsPhysicalMemoryLow
(
const
MEMORYSTATUSEX
&
aStat
)
{
if
(
(
kLowPhysicalMemoryThreshold
!
=
0
)
&
&
(
aStat
.
ullAvailPhys
<
kLowPhysicalMemoryThreshold
)
)
{
sNumLowPhysicalMemEvents
+
+
;
return
true
;
}
return
false
;
}
void
nsAvailableMemoryWatcher
:
:
SendMemoryPressureEvent
(
)
{
MemoryPressureState
state
=
OngoingMemoryPressure
(
)
?
MemPressure_Ongoing
:
MemPressure_New
;
NS_DispatchEventualMemoryPressure
(
state
)
;
}
void
nsAvailableMemoryWatcher
:
:
MaybeSaveMemoryReport
(
)
{
if
(
!
mSavedReport
&
&
OngoingMemoryPressure
(
)
)
{
nsCOMPtr
<
nsICrashReporter
>
cr
=
do_GetService
(
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
)
;
if
(
cr
)
{
if
(
NS_SUCCEEDED
(
cr
-
>
SaveMemoryReport
(
)
)
)
{
mSavedReport
=
true
;
}
}
}
}
void
nsAvailableMemoryWatcher
:
:
AdjustPollingInterval
(
const
bool
aLowMemory
)
{
if
(
aLowMemory
)
{
mTimer
-
>
SetDelay
(
kLowMemoryNotificationIntervalMS
)
;
}
else
if
(
OngoingMemoryPressure
(
)
)
{
mTimer
-
>
SetDelay
(
kPollingIntervalMS
)
;
}
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
Notify
(
nsITimer
*
aTimer
)
{
MEMORYSTATUSEX
stat
;
stat
.
dwLength
=
sizeof
(
stat
)
;
bool
success
=
GlobalMemoryStatusEx
(
&
stat
)
;
if
(
success
)
{
bool
lowMemory
=
IsVirtualMemoryLow
(
stat
)
|
|
IsCommitSpaceLow
(
stat
)
|
|
IsPhysicalMemoryLow
(
stat
)
;
if
(
lowMemory
)
{
SendMemoryPressureEvent
(
)
;
MaybeSaveMemoryReport
(
)
;
}
else
{
mSavedReport
=
false
;
}
AdjustPollingInterval
(
lowMemory
)
;
mUnderMemoryPressure
=
lowMemory
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
strcmp
(
aTopic
"
quit
-
application
"
)
=
=
0
)
{
Shutdown
(
)
;
}
else
if
(
strcmp
(
aTopic
"
user
-
interaction
-
inactive
"
)
=
=
0
)
{
mTimer
-
>
Cancel
(
)
;
}
else
if
(
strcmp
(
aTopic
"
user
-
interaction
-
active
"
)
=
=
0
)
{
mTimer
-
>
InitWithCallback
(
this
kPollingIntervalMS
nsITimer
:
:
TYPE_REPEATING_SLACK
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
topic
"
)
;
}
return
NS_OK
;
}
static
int64_t
LowMemoryEventsVirtualDistinguishedAmount
(
)
{
return
sNumLowVirtualMemEvents
;
}
static
int64_t
LowMemoryEventsCommitSpaceDistinguishedAmount
(
)
{
return
sNumLowCommitSpaceEvents
;
}
static
int64_t
LowMemoryEventsPhysicalDistinguishedAmount
(
)
{
return
sNumLowPhysicalMemEvents
;
}
class
LowEventsReporter
final
:
public
nsIMemoryReporter
{
~
LowEventsReporter
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
MOZ_COLLECT_REPORT
(
"
low
-
memory
-
events
/
virtual
"
KIND_OTHER
UNITS_COUNT_CUMULATIVE
LowMemoryEventsVirtualDistinguishedAmount
(
)
"
Number
of
low
-
virtual
-
memory
events
fired
since
startup
.
We
fire
such
an
"
"
event
if
we
notice
there
is
less
than
memory
.
low_virtual_mem_threshold_mb
of
"
"
virtual
address
space
available
(
if
zero
this
behavior
is
disabled
)
.
The
"
"
process
will
probably
crash
if
it
runs
out
of
virtual
address
space
so
"
"
this
event
is
dire
.
"
)
;
MOZ_COLLECT_REPORT
(
"
low
-
memory
-
events
/
commit
-
space
"
KIND_OTHER
UNITS_COUNT_CUMULATIVE
LowMemoryEventsCommitSpaceDistinguishedAmount
(
)
"
Number
of
low
-
commit
-
space
events
fired
since
startup
.
We
fire
such
an
"
"
event
if
we
notice
there
is
less
than
memory
.
low_commit_space_threshold_mb
of
"
"
commit
space
available
(
if
zero
this
behavior
is
disabled
)
.
Windows
will
"
"
likely
kill
the
process
if
it
runs
out
of
commit
space
so
this
event
is
"
"
dire
.
"
)
;
MOZ_COLLECT_REPORT
(
"
low
-
memory
-
events
/
physical
"
KIND_OTHER
UNITS_COUNT_CUMULATIVE
LowMemoryEventsPhysicalDistinguishedAmount
(
)
"
Number
of
low
-
physical
-
memory
events
fired
since
startup
.
We
fire
such
an
"
"
event
if
we
notice
there
is
less
than
memory
.
low_physical_memory_threshold_mb
"
"
of
physical
memory
available
(
if
zero
this
behavior
is
disabled
)
.
The
"
"
machine
will
start
to
page
if
it
runs
out
of
physical
memory
.
This
may
"
"
cause
it
to
run
slowly
but
it
shouldn
'
t
cause
it
to
crash
.
"
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
LowEventsReporter
nsIMemoryReporter
)
#
endif
class
nsJemallocFreeDirtyPagesRunnable
final
:
public
nsIRunnable
{
~
nsJemallocFreeDirtyPagesRunnable
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIRUNNABLE
}
;
NS_IMPL_ISUPPORTS
(
nsJemallocFreeDirtyPagesRunnable
nsIRunnable
)
NS_IMETHODIMP
nsJemallocFreeDirtyPagesRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
if
defined
(
MOZ_MEMORY
)
jemalloc_free_dirty_pages
(
)
;
#
endif
return
NS_OK
;
}
class
nsMemoryPressureWatcher
final
:
public
nsIObserver
{
~
nsMemoryPressureWatcher
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
void
Init
(
)
;
}
;
NS_IMPL_ISUPPORTS
(
nsMemoryPressureWatcher
nsIObserver
)
void
nsMemoryPressureWatcher
:
:
Init
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
this
"
memory
-
pressure
"
false
)
;
}
}
NS_IMETHODIMP
nsMemoryPressureWatcher
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
!
strcmp
(
aTopic
"
memory
-
pressure
"
)
"
Unknown
topic
"
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
nsJemallocFreeDirtyPagesRunnable
(
)
;
NS_DispatchToMainThread
(
runnable
)
;
return
NS_OK
;
}
}
namespace
mozilla
{
namespace
AvailableMemoryTracker
{
void
Init
(
)
{
RefPtr
<
nsMemoryPressureWatcher
>
watcher
=
new
nsMemoryPressureWatcher
(
)
;
watcher
-
>
Init
(
)
;
#
if
defined
(
XP_WIN
)
RegisterStrongMemoryReporter
(
new
LowEventsReporter
(
)
)
;
RegisterLowMemoryEventsVirtualDistinguishedAmount
(
LowMemoryEventsVirtualDistinguishedAmount
)
;
RegisterLowMemoryEventsCommitSpaceDistinguishedAmount
(
LowMemoryEventsCommitSpaceDistinguishedAmount
)
;
RegisterLowMemoryEventsPhysicalDistinguishedAmount
(
LowMemoryEventsPhysicalDistinguishedAmount
)
;
if
(
XRE_IsParentProcess
(
)
)
{
RefPtr
<
nsAvailableMemoryWatcher
>
poller
=
new
nsAvailableMemoryWatcher
(
)
;
if
(
NS_FAILED
(
poller
-
>
Init
(
)
)
)
{
NS_WARNING
(
"
Could
not
start
the
available
memory
watcher
"
)
;
}
}
#
endif
}
}
}
