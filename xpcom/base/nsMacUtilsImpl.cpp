#
include
"
nsMacUtilsImpl
.
h
"
#
include
"
base
/
command_line
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
prenv
.
h
"
#
if
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
SandboxSettings
.
h
"
#
endif
#
include
<
CoreFoundation
/
CoreFoundation
.
h
>
#
include
<
CoreServices
/
CoreServices
.
h
>
#
if
defined
(
__aarch64__
)
#
include
<
dlfcn
.
h
>
#
endif
#
include
<
sys
/
sysctl
.
h
>
NS_IMPL_ISUPPORTS
(
nsMacUtilsImpl
nsIMacUtils
)
using
mozilla
:
:
StaticMutexAutoLock
;
using
mozilla
:
:
Unused
;
#
if
defined
(
MOZ_SANDBOX
)
|
|
defined
(
__aarch64__
)
StaticAutoPtr
<
nsCString
>
nsMacUtilsImpl
:
:
sCachedAppPath
;
StaticMutex
nsMacUtilsImpl
:
:
sCachedAppPathMutex
;
#
endif
std
:
:
atomic
<
uint32_t
>
nsMacUtilsImpl
:
:
sBundleArchMaskAtomic
=
0
;
#
if
defined
(
__aarch64__
)
std
:
:
atomic
<
bool
>
nsMacUtilsImpl
:
:
sIsXULTranslated
=
false
;
#
endif
#
define
MAC_DEV_REPO_KEY
"
MozillaDeveloperRepoPath
"
#
define
MAC_DEV_OBJ_KEY
"
MozillaDeveloperObjPath
"
#
define
kCFBundleExecutableArchitectureARM64
0x0100000c
Atomic
<
nsMacUtilsImpl
:
:
TCSMStatus
>
nsMacUtilsImpl
:
:
sTCSMStatus
(
TCSM_Unknown
)
;
nsresult
nsMacUtilsImpl
:
:
GetArchString
(
nsAString
&
aArchString
)
{
if
(
!
mBinaryArchs
.
IsEmpty
(
)
)
{
aArchString
.
Assign
(
mBinaryArchs
)
;
return
NS_OK
;
}
uint32_t
archMask
=
base
:
:
PROCESS_ARCH_INVALID
;
nsresult
rv
=
GetArchitecturesForBundle
(
&
archMask
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
archMask
&
base
:
:
PROCESS_ARCH_PPC
)
{
mBinaryArchs
.
AppendLiteral
(
"
ppc
"
)
;
}
if
(
archMask
&
base
:
:
PROCESS_ARCH_I386
)
{
if
(
!
mBinaryArchs
.
IsEmpty
(
)
)
{
mBinaryArchs
.
Append
(
'
-
'
)
;
}
mBinaryArchs
.
AppendLiteral
(
"
i386
"
)
;
}
if
(
archMask
&
base
:
:
PROCESS_ARCH_PPC_64
)
{
if
(
!
mBinaryArchs
.
IsEmpty
(
)
)
{
mBinaryArchs
.
Append
(
'
-
'
)
;
}
mBinaryArchs
.
AppendLiteral
(
"
ppc64
"
)
;
}
if
(
archMask
&
base
:
:
PROCESS_ARCH_X86_64
)
{
if
(
!
mBinaryArchs
.
IsEmpty
(
)
)
{
mBinaryArchs
.
Append
(
'
-
'
)
;
}
mBinaryArchs
.
AppendLiteral
(
"
x86_64
"
)
;
}
if
(
archMask
&
base
:
:
PROCESS_ARCH_ARM_64
)
{
if
(
!
mBinaryArchs
.
IsEmpty
(
)
)
{
mBinaryArchs
.
Append
(
'
-
'
)
;
}
mBinaryArchs
.
AppendLiteral
(
"
arm64
"
)
;
}
aArchString
.
Truncate
(
)
;
aArchString
.
Assign
(
mBinaryArchs
)
;
return
(
aArchString
.
IsEmpty
(
)
?
NS_ERROR_FAILURE
:
NS_OK
)
;
}
NS_IMETHODIMP
nsMacUtilsImpl
:
:
GetArchitecturesInBinary
(
nsAString
&
aArchString
)
{
return
GetArchString
(
aArchString
)
;
}
NS_IMETHODIMP
nsMacUtilsImpl
:
:
GetIsTranslated
(
bool
*
aIsTranslated
)
{
#
ifdef
__ppc__
static
bool
sInitialized
=
false
;
static
int32_t
sIsNative
=
1
;
if
(
!
sInitialized
)
{
size_t
sz
=
sizeof
(
sIsNative
)
;
sysctlbyname
(
"
sysctl
.
proc_native
"
&
sIsNative
&
sz
nullptr
0
)
;
sInitialized
=
true
;
}
*
aIsTranslated
=
!
sIsNative
;
#
else
*
aIsTranslated
=
false
;
#
endif
return
NS_OK
;
}
#
if
defined
(
MOZ_SANDBOX
)
|
|
defined
(
__aarch64__
)
bool
nsMacUtilsImpl
:
:
GetAppPath
(
nsCString
&
aAppPath
)
{
StaticMutexAutoLock
lock
(
sCachedAppPathMutex
)
;
if
(
sCachedAppPath
)
{
aAppPath
.
Assign
(
*
sCachedAppPath
)
;
return
true
;
}
nsAutoCString
appPath
;
nsAutoCString
appBinaryPath
(
(
CommandLine
:
:
ForCurrentProcess
(
)
-
>
argv
(
)
[
0
]
)
.
c_str
(
)
)
;
auto
pattern
=
"
/
Contents
/
MacOS
/
"
_ns
;
nsAutoCString
:
:
const_iterator
start
end
;
appBinaryPath
.
BeginReading
(
start
)
;
appBinaryPath
.
EndReading
(
end
)
;
if
(
RFindInReadable
(
pattern
start
end
)
)
{
end
=
start
;
appBinaryPath
.
BeginReading
(
start
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
if
(
RFindInReadable
(
pattern
start
end
)
)
{
end
=
start
;
appBinaryPath
.
BeginReading
(
start
)
;
}
else
{
return
false
;
}
}
appPath
.
Assign
(
Substring
(
start
end
)
)
;
}
else
{
return
false
;
}
nsCOMPtr
<
nsIFile
>
app
;
nsresult
rv
=
NS_NewLocalFile
(
NS_ConvertUTF8toUTF16
(
appPath
)
true
getter_AddRefs
(
app
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
rv
=
app
-
>
Normalize
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
app
-
>
GetNativePath
(
aAppPath
)
;
if
(
!
sCachedAppPath
)
{
sCachedAppPath
=
new
nsCString
(
aAppPath
)
;
if
(
NS_IsMainThread
(
)
)
{
nsMacUtilsImpl
:
:
ClearCachedAppPathOnShutdown
(
)
;
}
else
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
nsMacUtilsImpl
:
:
ClearCachedAppPathOnShutdown
"
[
]
{
nsMacUtilsImpl
:
:
ClearCachedAppPathOnShutdown
(
)
;
}
)
)
;
}
}
return
true
;
}
nsresult
nsMacUtilsImpl
:
:
ClearCachedAppPathOnShutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ClearOnShutdown
(
&
sCachedAppPath
)
;
return
NS_OK
;
}
#
endif
#
if
defined
(
MOZ_SANDBOX
)
&
&
defined
(
DEBUG
)
nsresult
nsMacUtilsImpl
:
:
GetBloatLogDir
(
nsCString
&
aDirectoryPath
)
{
nsAutoCString
bloatLog
(
PR_GetEnv
(
"
XPCOM_MEM_BLOAT_LOG
"
)
)
;
if
(
bloatLog
.
IsEmpty
(
)
)
{
bloatLog
=
PR_GetEnv
(
"
XPCOM_MEM_LEAK_LOG
"
)
;
}
if
(
!
bloatLog
.
IsEmpty
(
)
&
&
bloatLog
!
=
"
1
"
&
&
bloatLog
!
=
"
2
"
)
{
return
GetDirectoryPath
(
bloatLog
.
get
(
)
aDirectoryPath
)
;
}
return
NS_OK
;
}
nsresult
nsMacUtilsImpl
:
:
GetDirectoryPath
(
const
char
*
aPath
nsCString
&
aDirectoryPath
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIFile
>
file
=
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
file
-
>
InitWithNativePath
(
nsDependentCString
(
aPath
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
directoryFile
;
rv
=
file
-
>
GetParent
(
getter_AddRefs
(
directoryFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
directoryFile
-
>
Normalize
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
NS_FAILED
(
directoryFile
-
>
GetNativePath
(
aDirectoryPath
)
)
)
{
MOZ_CRASH
(
"
Failed
to
get
path
for
an
nsIFile
"
)
;
}
return
NS_OK
;
}
#
endif
bool
nsMacUtilsImpl
:
:
IsTCSMAvailable
(
)
{
if
(
sTCSMStatus
=
=
TCSM_Unknown
)
{
uint32_t
oldVal
=
0
;
size_t
oldValSize
=
sizeof
(
oldVal
)
;
int
rv
=
sysctlbyname
(
"
kern
.
tcsm_available
"
&
oldVal
&
oldValSize
NULL
0
)
;
TCSMStatus
newStatus
;
if
(
rv
<
0
|
|
oldVal
=
=
0
)
{
newStatus
=
TCSM_Unavailable
;
}
else
{
newStatus
=
TCSM_Available
;
}
Unused
<
<
sTCSMStatus
.
compareExchange
(
TCSM_Unknown
newStatus
)
;
}
return
(
sTCSMStatus
=
=
TCSM_Available
)
;
}
nsresult
nsMacUtilsImpl
:
:
EnableTCSM
(
)
{
uint32_t
newVal
=
1
;
int
rv
=
sysctlbyname
(
"
kern
.
tcsm_enable
"
NULL
0
&
newVal
sizeof
(
newVal
)
)
;
if
(
rv
<
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
void
nsMacUtilsImpl
:
:
EnableTCSMIfAvailable
(
)
{
if
(
IsTCSMAvailable
(
)
)
{
if
(
NS_FAILED
(
EnableTCSM
(
)
)
)
{
NS_WARNING
(
"
Failed
to
enable
TCSM
"
)
;
}
MOZ_ASSERT
(
IsTCSMEnabled
(
)
)
;
}
}
#
if
defined
(
DEBUG
)
bool
nsMacUtilsImpl
:
:
IsTCSMEnabled
(
)
{
uint32_t
oldVal
=
0
;
size_t
oldValSize
=
sizeof
(
oldVal
)
;
int
rv
=
sysctlbyname
(
"
kern
.
tcsm_enable
"
&
oldVal
&
oldValSize
NULL
0
)
;
return
(
rv
=
=
0
)
&
&
(
oldVal
!
=
0
)
;
}
#
endif
uint32_t
nsMacUtilsImpl
:
:
GetPhysicalCPUCount
(
)
{
uint32_t
oldVal
=
0
;
size_t
oldValSize
=
sizeof
(
oldVal
)
;
int
rv
=
sysctlbyname
(
"
hw
.
physicalcpu_max
"
&
oldVal
&
oldValSize
NULL
0
)
;
if
(
rv
=
=
-
1
)
{
return
0
;
}
return
oldVal
;
}
static
nsresult
GetStringValueFromBundlePlist
(
const
nsAString
&
aKey
nsAutoCString
&
aValue
)
{
CFBundleRef
mainBundle
=
CFBundleGetMainBundle
(
)
;
if
(
mainBundle
=
=
nullptr
)
{
return
NS_ERROR_FAILURE
;
}
CFDictionaryRef
bundleInfoDict
=
CFBundleGetInfoDictionary
(
mainBundle
)
;
if
(
bundleInfoDict
=
=
nullptr
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
keyAutoCString
=
NS_ConvertUTF16toUTF8
(
aKey
)
;
CFStringRef
key
=
CFStringCreateWithCString
(
kCFAllocatorDefault
keyAutoCString
.
get
(
)
kCFStringEncodingUTF8
)
;
if
(
key
=
=
nullptr
)
{
return
NS_ERROR_FAILURE
;
}
CFStringRef
value
=
(
CFStringRef
)
CFDictionaryGetValue
(
bundleInfoDict
key
)
;
CFRelease
(
key
)
;
if
(
value
=
=
nullptr
)
{
return
NS_ERROR_FAILURE
;
}
CFIndex
valueLength
=
CFStringGetLength
(
value
)
;
if
(
valueLength
=
=
0
)
{
return
NS_ERROR_FAILURE
;
}
const
char
*
valueCString
=
CFStringGetCStringPtr
(
value
kCFStringEncodingUTF8
)
;
if
(
valueCString
)
{
aValue
.
Assign
(
valueCString
)
;
return
NS_OK
;
}
CFIndex
maxLength
=
CFStringGetMaximumSizeForEncoding
(
valueLength
kCFStringEncodingUTF8
)
+
1
;
char
*
valueBuffer
=
static_cast
<
char
*
>
(
moz_xmalloc
(
maxLength
)
)
;
if
(
!
CFStringGetCString
(
value
valueBuffer
maxLength
kCFStringEncodingUTF8
)
)
{
free
(
valueBuffer
)
;
return
NS_ERROR_FAILURE
;
}
aValue
.
Assign
(
valueBuffer
)
;
free
(
valueBuffer
)
;
return
NS_OK
;
}
static
nsresult
GetDirFromBundlePlist
(
const
nsAString
&
aKey
nsIFile
*
*
aDir
)
{
nsresult
rv
;
nsAutoCString
dirPath
;
rv
=
GetStringValueFromBundlePlist
(
aKey
dirPath
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
dir
;
rv
=
NS_NewLocalFile
(
NS_ConvertUTF8toUTF16
(
dirPath
)
false
getter_AddRefs
(
dir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
dir
-
>
Normalize
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
isDirectory
=
false
;
rv
=
dir
-
>
IsDirectory
(
&
isDirectory
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isDirectory
)
{
return
NS_ERROR_FILE_NOT_DIRECTORY
;
}
dir
.
swap
(
*
aDir
)
;
return
NS_OK
;
}
nsresult
nsMacUtilsImpl
:
:
GetRepoDir
(
nsIFile
*
*
aRepoDir
)
{
#
if
defined
(
MOZ_SANDBOX
)
MOZ_ASSERT
(
mozilla
:
:
IsDevelopmentBuild
(
)
)
;
#
endif
return
GetDirFromBundlePlist
(
NS_LITERAL_STRING_FROM_CSTRING
(
MAC_DEV_REPO_KEY
)
aRepoDir
)
;
}
nsresult
nsMacUtilsImpl
:
:
GetObjDir
(
nsIFile
*
*
aObjDir
)
{
#
if
defined
(
MOZ_SANDBOX
)
MOZ_ASSERT
(
mozilla
:
:
IsDevelopmentBuild
(
)
)
;
#
endif
return
GetDirFromBundlePlist
(
NS_LITERAL_STRING_FROM_CSTRING
(
MAC_DEV_OBJ_KEY
)
aObjDir
)
;
}
nsresult
nsMacUtilsImpl
:
:
GetArchitecturesForBundle
(
uint32_t
*
aArchMask
)
{
MOZ_ASSERT
(
aArchMask
)
;
*
aArchMask
=
sBundleArchMaskAtomic
;
if
(
*
aArchMask
!
=
0
)
{
return
NS_OK
;
}
CFBundleRef
mainBundle
=
:
:
CFBundleGetMainBundle
(
)
;
if
(
!
mainBundle
)
{
return
NS_ERROR_FAILURE
;
}
CFArrayRef
archList
=
:
:
CFBundleCopyExecutableArchitectures
(
mainBundle
)
;
if
(
!
archList
)
{
return
NS_ERROR_FAILURE
;
}
CFIndex
archCount
=
:
:
CFArrayGetCount
(
archList
)
;
for
(
CFIndex
i
=
0
;
i
<
archCount
;
i
+
+
)
{
CFNumberRef
arch
=
static_cast
<
CFNumberRef
>
(
:
:
CFArrayGetValueAtIndex
(
archList
i
)
)
;
int
archInt
=
0
;
if
(
!
:
:
CFNumberGetValue
(
arch
kCFNumberIntType
&
archInt
)
)
{
:
:
CFRelease
(
archList
)
;
return
NS_ERROR_FAILURE
;
}
if
(
archInt
=
=
kCFBundleExecutableArchitecturePPC
)
{
*
aArchMask
|
=
base
:
:
PROCESS_ARCH_PPC
;
}
else
if
(
archInt
=
=
kCFBundleExecutableArchitectureI386
)
{
*
aArchMask
|
=
base
:
:
PROCESS_ARCH_I386
;
}
else
if
(
archInt
=
=
kCFBundleExecutableArchitecturePPC64
)
{
*
aArchMask
|
=
base
:
:
PROCESS_ARCH_PPC_64
;
}
else
if
(
archInt
=
=
kCFBundleExecutableArchitectureX86_64
)
{
*
aArchMask
|
=
base
:
:
PROCESS_ARCH_X86_64
;
}
else
if
(
archInt
=
=
kCFBundleExecutableArchitectureARM64
)
{
*
aArchMask
|
=
base
:
:
PROCESS_ARCH_ARM_64
;
}
}
:
:
CFRelease
(
archList
)
;
sBundleArchMaskAtomic
=
*
aArchMask
;
return
NS_OK
;
}
nsresult
nsMacUtilsImpl
:
:
GetArchitecturesForBinary
(
const
char
*
aPath
uint32_t
*
aArchMask
)
{
MOZ_ASSERT
(
aArchMask
)
;
*
aArchMask
=
0
;
CFURLRef
url
=
:
:
CFURLCreateFromFileSystemRepresentation
(
kCFAllocatorDefault
(
const
UInt8
*
)
aPath
strlen
(
aPath
)
false
)
;
if
(
!
url
)
{
return
NS_ERROR_FAILURE
;
}
CFArrayRef
archs
=
:
:
CFBundleCopyExecutableArchitecturesForURL
(
url
)
;
if
(
!
archs
)
{
CFRelease
(
url
)
;
return
NS_ERROR_FAILURE
;
}
CFIndex
archCount
=
:
:
CFArrayGetCount
(
archs
)
;
for
(
CFIndex
i
=
0
;
i
<
archCount
;
i
+
+
)
{
CFNumberRef
currentArch
=
static_cast
<
CFNumberRef
>
(
:
:
CFArrayGetValueAtIndex
(
archs
i
)
)
;
int
currentArchInt
=
0
;
if
(
!
:
:
CFNumberGetValue
(
currentArch
kCFNumberIntType
&
currentArchInt
)
)
{
continue
;
}
switch
(
currentArchInt
)
{
case
kCFBundleExecutableArchitectureX86_64
:
*
aArchMask
|
=
base
:
:
PROCESS_ARCH_X86_64
;
break
;
case
kCFBundleExecutableArchitectureARM64
:
*
aArchMask
|
=
base
:
:
PROCESS_ARCH_ARM_64
;
break
;
default
:
break
;
}
}
CFRelease
(
url
)
;
CFRelease
(
archs
)
;
if
(
*
aArchMask
=
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
#
if
defined
(
__aarch64__
)
int
nsMacUtilsImpl
:
:
PreTranslateXUL
(
)
{
bool
expected
=
false
;
if
(
!
sIsXULTranslated
.
compare_exchange_strong
(
expected
true
)
)
{
return
1
;
}
nsCString
xulPath
;
if
(
!
GetAppPath
(
xulPath
)
)
{
return
-
1
;
}
xulPath
.
Append
(
"
/
Contents
/
MacOS
/
XUL
"
)
;
return
PreTranslateBinary
(
xulPath
)
;
}
int
nsMacUtilsImpl
:
:
PreTranslateBinary
(
nsCString
aBinaryPath
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
-
1
;
}
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
return
-
1
;
}
#
pragma
clang
diagnostic
push
#
pragma
clang
diagnostic
ignored
"
-
Wunguarded
-
availability
-
new
"
if
(
!
CFBundleIsArchitectureLoadable
(
CPU_TYPE_X86_64
)
)
{
return
-
1
;
}
#
pragma
clang
diagnostic
pop
if
(
aBinaryPath
.
IsEmpty
(
)
)
{
return
-
1
;
}
using
rosetta_translate_binaries_t
=
int
(
*
)
(
const
char
*
[
]
int
)
;
static
auto
rosetta_translate_binaries
=
[
]
(
)
{
void
*
libRosetta
=
dlopen
(
"
/
usr
/
lib
/
libRosetta
.
dylib
"
RTLD_LAZY
|
RTLD_LOCAL
)
;
if
(
!
libRosetta
)
{
return
static_cast
<
rosetta_translate_binaries_t
>
(
nullptr
)
;
}
return
reinterpret_cast
<
rosetta_translate_binaries_t
>
(
dlsym
(
libRosetta
"
rosetta_translate_binaries
"
)
)
;
}
(
)
;
if
(
!
rosetta_translate_binaries
)
{
return
-
1
;
}
const
char
*
pathPtr
=
aBinaryPath
.
get
(
)
;
return
rosetta_translate_binaries
(
&
pathPtr
1
)
;
}
#
endif
