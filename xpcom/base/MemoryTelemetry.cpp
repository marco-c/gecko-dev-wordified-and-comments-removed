#
include
"
MemoryTelemetry
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
"
GCTelemetry
.
h
"
#
include
"
mozJSComponentLoader
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
SimpleEnumerator
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIBrowserDOMWindow
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsIWindowMediator
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsObserverService
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
<
cstdlib
>
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
AutoJSAPI
;
using
mozilla
:
:
dom
:
:
ContentParent
;
static
constexpr
uint32_t
kTelemetryInterval
=
60
*
1000
;
static
constexpr
const
char
*
kTopicCycleCollectorBegin
=
"
cycle
-
collector
-
begin
"
;
static
constexpr
uint32_t
kTotalMemoryCollectorTimeout
=
200
;
static
Result
<
nsCOMPtr
<
mozIGCTelemetry
>
nsresult
>
GetGCTelemetry
(
)
{
AutoJSAPI
jsapi
;
MOZ_ALWAYS_TRUE
(
jsapi
.
Init
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
RootedObject
global
(
cx
)
;
JS
:
:
RootedObject
exports
(
cx
)
;
MOZ_TRY
(
mozJSComponentLoader
:
:
Get
(
)
-
>
Import
(
cx
NS_LITERAL_CSTRING
(
"
resource
:
/
/
gre
/
modules
/
GCTelemetry
.
jsm
"
)
&
global
&
exports
)
)
;
nsCOMPtr
<
mozIGCTelemetryJSM
>
jsm
;
MOZ_TRY
(
nsContentUtils
:
:
XPConnect
(
)
-
>
WrapJS
(
cx
exports
NS_GET_IID
(
mozIGCTelemetryJSM
)
getter_AddRefs
(
jsm
)
)
)
;
nsCOMPtr
<
mozIGCTelemetry
>
gcTelemetry
;
MOZ_TRY
(
jsm
-
>
GetGCTelemetry
(
getter_AddRefs
(
gcTelemetry
)
)
)
;
return
std
:
:
move
(
gcTelemetry
)
;
}
namespace
{
enum
class
PrevValue
:
uint32_t
{
#
ifdef
XP_WIN
LOW_MEMORY_EVENTS_VIRTUAL
LOW_MEMORY_EVENTS_COMMIT_SPACE
LOW_MEMORY_EVENTS_PHYSICAL
#
endif
#
if
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
PAGE_FAULTS_HARD
#
endif
SIZE_
}
;
}
constexpr
uint32_t
kUninitialized
=
~
0
;
static
uint32_t
gPrevValues
[
uint32_t
(
PrevValue
:
:
SIZE_
)
]
;
static
uint32_t
PrevValueIndex
(
Telemetry
:
:
HistogramID
aId
)
{
switch
(
aId
)
{
#
ifdef
XP_WIN
case
Telemetry
:
:
LOW_MEMORY_EVENTS_VIRTUAL
:
return
uint32_t
(
PrevValue
:
:
LOW_MEMORY_EVENTS_VIRTUAL
)
;
case
Telemetry
:
:
LOW_MEMORY_EVENTS_COMMIT_SPACE
:
return
uint32_t
(
PrevValue
:
:
LOW_MEMORY_EVENTS_COMMIT_SPACE
)
;
case
Telemetry
:
:
LOW_MEMORY_EVENTS_PHYSICAL
:
return
uint32_t
(
PrevValue
:
:
LOW_MEMORY_EVENTS_PHYSICAL
)
;
#
endif
#
if
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
case
Telemetry
:
:
PAGE_FAULTS_HARD
:
return
uint32_t
(
PrevValue
:
:
PAGE_FAULTS_HARD
)
;
#
endif
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
histogram
ID
"
)
;
return
0
;
}
}
NS_IMPL_ISUPPORTS
(
MemoryTelemetry
nsIObserver
nsISupportsWeakReference
)
MemoryTelemetry
:
:
MemoryTelemetry
(
)
:
mThreadPool
(
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
)
{
}
void
MemoryTelemetry
:
:
Init
(
)
{
for
(
auto
&
val
:
gPrevValues
)
{
val
=
kUninitialized
;
}
if
(
XRE_IsContentProcess
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
MOZ_RELEASE_ASSERT
(
obs
)
;
obs
-
>
AddObserver
(
this
"
content
-
child
-
shutdown
"
true
)
;
}
}
MemoryTelemetry
&
MemoryTelemetry
:
:
Get
(
)
{
static
RefPtr
<
MemoryTelemetry
>
sInstance
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sInstance
)
{
sInstance
=
new
MemoryTelemetry
(
)
;
sInstance
-
>
Init
(
)
;
ClearOnShutdown
(
&
sInstance
)
;
}
return
*
sInstance
;
}
nsresult
MemoryTelemetry
:
:
DelayedInit
(
)
{
if
(
Telemetry
:
:
CanRecordExtended
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
MOZ_RELEASE_ASSERT
(
obs
)
;
obs
-
>
AddObserver
(
this
kTopicCycleCollectorBegin
true
)
;
}
GatherReports
(
)
;
if
(
Telemetry
:
:
CanRecordExtended
(
)
)
{
nsCOMPtr
<
mozIGCTelemetry
>
gcTelemetry
;
MOZ_TRY_VAR
(
gcTelemetry
GetGCTelemetry
(
)
)
;
MOZ_TRY
(
gcTelemetry
-
>
Init
(
)
)
;
}
return
NS_OK
;
}
nsresult
MemoryTelemetry
:
:
Shutdown
(
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
MOZ_RELEASE_ASSERT
(
obs
)
;
obs
-
>
RemoveObserver
(
this
kTopicCycleCollectorBegin
)
;
if
(
Telemetry
:
:
CanRecordExtended
(
)
)
{
nsCOMPtr
<
mozIGCTelemetry
>
gcTelemetry
;
MOZ_TRY_VAR
(
gcTelemetry
GetGCTelemetry
(
)
)
;
MOZ_TRY
(
gcTelemetry
-
>
Shutdown
(
)
)
;
}
return
NS_OK
;
}
static
inline
void
HandleMemoryReport
(
Telemetry
:
:
HistogramID
aId
int32_t
aUnits
uint64_t
aAmount
const
nsCString
&
aKey
=
VoidCString
(
)
)
{
uint32_t
val
;
switch
(
aUnits
)
{
case
nsIMemoryReporter
:
:
UNITS_BYTES
:
val
=
uint32_t
(
aAmount
/
1024
)
;
break
;
case
nsIMemoryReporter
:
:
UNITS_PERCENTAGE
:
val
=
uint32_t
(
aAmount
/
100
)
;
break
;
case
nsIMemoryReporter
:
:
UNITS_COUNT
:
val
=
uint32_t
(
aAmount
)
;
break
;
case
nsIMemoryReporter
:
:
UNITS_COUNT_CUMULATIVE
:
{
uint32_t
idx
=
PrevValueIndex
(
aId
)
;
uint32_t
prev
=
gPrevValues
[
idx
]
;
gPrevValues
[
idx
]
=
aAmount
;
if
(
prev
=
=
kUninitialized
)
{
return
;
}
val
=
aAmount
-
prev
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
aUnits
value
"
)
;
return
;
}
if
(
&
aKey
=
=
&
VoidCString
(
)
)
{
Telemetry
:
:
Accumulate
(
aId
val
)
;
}
else
{
Telemetry
:
:
Accumulate
(
aId
aKey
val
)
;
}
}
nsresult
MemoryTelemetry
:
:
GatherReports
(
const
std
:
:
function
<
void
(
)
>
&
aCompletionCallback
)
{
auto
cleanup
=
MakeScopeExit
(
[
&
]
(
)
{
if
(
aCompletionCallback
)
{
aCompletionCallback
(
)
;
}
}
)
;
RefPtr
<
nsMemoryReporterManager
>
mgr
=
nsMemoryReporterManager
:
:
GetOrCreate
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mgr
)
;
NS_ENSURE_TRUE
(
mgr
NS_ERROR_FAILURE
)
;
auto
startTime
=
TimeStamp
:
:
Now
(
)
;
#
define
RECORD
(
id
metric
units
)
\
do
{
\
int64_t
amt
;
\
nsresult
rv
=
mgr
-
>
Get
#
#
metric
(
&
amt
)
;
\
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
\
HandleMemoryReport
(
Telemetry
:
:
id
nsIMemoryReporter
:
:
units
amt
)
;
\
}
\
}
while
(
0
)
RECORD
(
GHOST_WINDOWS
GhostWindows
UNITS_COUNT
)
;
if
(
!
Telemetry
:
:
CanRecordReleaseData
(
)
)
{
return
NS_OK
;
}
RECORD
(
MEMORY_JS_GC_HEAP
JSMainRuntimeGCHeap
UNITS_BYTES
)
;
RECORD
(
MEMORY_JS_COMPARTMENTS_SYSTEM
JSMainRuntimeRealmsSystem
UNITS_COUNT
)
;
RECORD
(
MEMORY_JS_COMPARTMENTS_USER
JSMainRuntimeRealmsUser
UNITS_COUNT
)
;
RECORD
(
MEMORY_IMAGES_CONTENT_USED_UNCOMPRESSED
ImagesContentUsedUncompressed
UNITS_BYTES
)
;
RECORD
(
MEMORY_STORAGE_SQLITE
StorageSQLite
UNITS_BYTES
)
;
#
ifdef
XP_WIN
RECORD
(
LOW_MEMORY_EVENTS_VIRTUAL
LowMemoryEventsVirtual
UNITS_COUNT_CUMULATIVE
)
;
RECORD
(
LOW_MEMORY_EVENTS_COMMIT_SPACE
LowMemoryEventsCommitSpace
UNITS_COUNT_CUMULATIVE
)
;
RECORD
(
LOW_MEMORY_EVENTS_PHYSICAL
LowMemoryEventsPhysical
UNITS_COUNT_CUMULATIVE
)
;
#
endif
#
if
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
RECORD
(
PAGE_FAULTS_HARD
PageFaultsHard
UNITS_COUNT_CUMULATIVE
)
;
#
endif
RefPtr
<
Runnable
>
completionRunnable
;
if
(
aCompletionCallback
)
{
completionRunnable
=
NS_NewRunnableFunction
(
__func__
aCompletionCallback
)
;
}
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableFunction
(
"
MemoryTelemetry
:
:
GatherReports
"
[
mgr
completionRunnable
]
(
)
mutable
{
RECORD
(
MEMORY_VSIZE
Vsize
UNITS_BYTES
)
;
#
if
!
defined
(
HAVE_64BIT_BUILD
)
|
|
!
defined
(
XP_WIN
)
RECORD
(
MEMORY_VSIZE_MAX_CONTIGUOUS
VsizeMaxContiguous
UNITS_BYTES
)
;
#
endif
RECORD
(
MEMORY_RESIDENT_FAST
ResidentFast
UNITS_BYTES
)
;
RECORD
(
MEMORY_UNIQUE
ResidentUnique
UNITS_BYTES
)
;
RECORD
(
MEMORY_HEAP_ALLOCATED
HeapAllocated
UNITS_BYTES
)
;
RECORD
(
MEMORY_HEAP_OVERHEAD_FRACTION
HeapOverheadFraction
UNITS_PERCENTAGE
)
;
if
(
completionRunnable
)
{
NS_DispatchToMainThread
(
completionRunnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
}
)
;
#
undef
RECORD
nsresult
rv
=
mThreadPool
-
>
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
cleanup
.
release
(
)
;
}
if
(
XRE_IsParentProcess
(
)
&
&
!
mTotalMemoryGatherer
)
{
mTotalMemoryGatherer
=
new
TotalMemoryGatherer
(
)
;
mTotalMemoryGatherer
-
>
Begin
(
mThreadPool
)
;
}
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
HistogramID
:
:
TELEMETRY_MEMORY_REPORTER_MS
startTime
TimeStamp
:
:
Now
(
)
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
MemoryTelemetry
:
:
TotalMemoryGatherer
nsITimerCallback
)
void
MemoryTelemetry
:
:
TotalMemoryGatherer
:
:
Begin
(
nsIEventTarget
*
aThreadPool
)
{
nsCOMPtr
<
nsISerialEventTarget
>
target
=
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
;
nsTArray
<
ContentParent
*
>
parents
;
ContentParent
:
:
GetAll
(
parents
)
;
for
(
auto
&
parent
:
parents
)
{
mRemainingChildCount
+
+
;
parent
-
>
SendGetMemoryUniqueSetSize
(
)
-
>
Then
(
target
"
TotalMemoryGather
:
:
Begin
"
this
&
TotalMemoryGatherer
:
:
CollectResult
&
TotalMemoryGatherer
:
:
OnFailure
)
;
}
mChildSizes
.
SetCapacity
(
mRemainingChildCount
)
;
RefPtr
<
TotalMemoryGatherer
>
self
{
this
}
;
aThreadPool
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
TotalMemoryGather
:
:
Begin
"
[
self
]
(
)
{
RefPtr
<
nsMemoryReporterManager
>
mgr
=
nsMemoryReporterManager
:
:
GetOrCreate
(
)
;
MOZ_RELEASE_ASSERT
(
mgr
)
;
NS_DispatchToMainThread
(
NewRunnableMethod
<
int64_t
>
(
"
TotalMemoryGather
:
:
CollectParentSize
"
self
&
TotalMemoryGatherer
:
:
CollectParentSize
mgr
-
>
ResidentFast
(
)
)
)
;
}
)
NS_DISPATCH_NORMAL
)
;
NS_NewTimerWithCallback
(
getter_AddRefs
(
mTimeout
)
this
kTotalMemoryCollectorTimeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
nsresult
MemoryTelemetry
:
:
TotalMemoryGatherer
:
:
MaybeFinish
(
)
{
if
(
!
mTimeout
|
|
!
mHaveParentSize
|
|
mRemainingChildCount
)
{
return
NS_OK
;
}
mTimeout
=
nullptr
;
MemoryTelemetry
:
:
Get
(
)
.
mTotalMemoryGatherer
=
nullptr
;
HandleMemoryReport
(
Telemetry
:
:
MEMORY_TOTAL
nsIMemoryReporter
:
:
UNITS_BYTES
mTotalMemory
)
;
if
(
mChildSizes
.
Length
(
)
>
1
)
{
int32_t
tabsCount
;
MOZ_TRY_VAR
(
tabsCount
GetOpenTabsCount
(
)
)
;
nsCString
key
;
if
(
tabsCount
<
=
10
)
{
key
=
"
0
-
10
tabs
"
;
}
else
if
(
tabsCount
<
=
500
)
{
key
=
"
11
-
500
tabs
"
;
}
else
{
key
=
"
more
tabs
"
;
}
int64_t
mean
=
0
;
for
(
auto
size
:
mChildSizes
)
{
mean
+
=
size
;
}
mean
/
=
mChildSizes
.
Length
(
)
;
if
(
!
mean
)
{
return
NS_ERROR_UNEXPECTED
;
}
for
(
auto
size
:
mChildSizes
)
{
int64_t
diff
=
llabs
(
size
-
mean
)
*
100
/
mean
;
HandleMemoryReport
(
Telemetry
:
:
MEMORY_DISTRIBUTION_AMONG_CONTENT
nsIMemoryReporter
:
:
UNITS_COUNT
diff
key
)
;
}
}
if
(
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
)
{
obs
-
>
NotifyObservers
(
nullptr
"
gather
-
memory
-
telemetry
-
finished
"
nullptr
)
;
}
return
NS_OK
;
}
void
MemoryTelemetry
:
:
TotalMemoryGatherer
:
:
CollectParentSize
(
int64_t
aResident
)
{
mTotalMemory
+
=
aResident
;
mHaveParentSize
=
true
;
MaybeFinish
(
)
;
}
void
MemoryTelemetry
:
:
TotalMemoryGatherer
:
:
CollectResult
(
int64_t
aChildUSS
)
{
mChildSizes
.
AppendElement
(
aChildUSS
)
;
mTotalMemory
+
=
aChildUSS
;
mRemainingChildCount
-
-
;
MaybeFinish
(
)
;
}
void
MemoryTelemetry
:
:
TotalMemoryGatherer
:
:
OnFailure
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
aReason
)
{
Notify
(
nullptr
)
;
}
nsresult
MemoryTelemetry
:
:
TotalMemoryGatherer
:
:
Notify
(
nsITimer
*
aTimer
)
{
mTimeout
=
nullptr
;
MemoryTelemetry
:
:
Get
(
)
.
mTotalMemoryGatherer
=
nullptr
;
return
NS_OK
;
}
Result
<
uint32_t
nsresult
>
MemoryTelemetry
:
:
GetOpenTabsCount
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIWindowMediator
>
windowMediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
&
rv
)
)
;
MOZ_TRY
(
rv
)
;
nsCOMPtr
<
nsISimpleEnumerator
>
enumerator
;
MOZ_TRY
(
windowMediator
-
>
GetEnumerator
(
u
"
navigator
:
browser
"
getter_AddRefs
(
enumerator
)
)
)
;
uint32_t
total
=
0
;
for
(
auto
&
window
:
SimpleEnumerator
<
nsIDOMChromeWindow
>
(
enumerator
)
)
{
nsCOMPtr
<
nsIBrowserDOMWindow
>
browserWin
;
MOZ_TRY
(
window
-
>
GetBrowserDOMWindow
(
getter_AddRefs
(
browserWin
)
)
)
;
NS_ENSURE_TRUE
(
browserWin
Err
(
NS_ERROR_UNEXPECTED
)
)
;
uint32_t
tabCount
;
MOZ_TRY
(
browserWin
-
>
GetTabCount
(
&
tabCount
)
)
;
total
+
=
tabCount
;
}
return
total
;
}
void
MemoryTelemetry
:
:
GetUniqueSetSize
(
std
:
:
function
<
void
(
const
int64_t
&
)
>
&
&
aCallback
)
{
mThreadPool
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
MemoryTelemetry
:
:
GetUniqueSetSize
"
[
callback
=
std
:
:
move
(
aCallback
)
]
(
)
mutable
{
RefPtr
<
nsMemoryReporterManager
>
mgr
=
nsMemoryReporterManager
:
:
GetOrCreate
(
)
;
MOZ_RELEASE_ASSERT
(
mgr
)
;
int64_t
uss
=
mgr
-
>
ResidentUnique
(
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
MemoryTelemetry
:
:
GetUniqueSetSizeResult
"
[
uss
callback
=
std
:
:
move
(
callback
)
]
(
)
{
callback
(
uss
)
;
}
)
)
;
}
)
NS_DISPATCH_NORMAL
)
;
}
nsresult
MemoryTelemetry
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
strcmp
(
aTopic
kTopicCycleCollectorBegin
)
=
=
0
)
{
auto
now
=
TimeStamp
:
:
Now
(
)
;
if
(
!
mLastPoll
.
IsNull
(
)
&
&
(
now
-
mLastPoll
)
.
ToMilliseconds
(
)
<
kTelemetryInterval
)
{
return
NS_OK
;
}
mLastPoll
=
now
;
NS_IdleDispatchToCurrentThread
(
NewRunnableMethod
<
std
:
:
function
<
void
(
)
>
>
(
"
MemoryTelemetry
:
:
GatherReports
"
this
&
MemoryTelemetry
:
:
GatherReports
nullptr
)
)
;
}
else
if
(
strcmp
(
aTopic
"
content
-
child
-
shutdown
"
)
=
=
0
)
{
if
(
nsCOMPtr
<
nsITelemetry
>
telemetry
=
do_GetService
(
"
mozilla
.
org
/
base
/
telemetry
;
1
"
)
)
{
telemetry
-
>
FlushBatchedChildTelemetry
(
)
;
}
}
return
NS_OK
;
}
