#
ifndef
mozilla_DarwinObjectPtr_h
#
define
mozilla_DarwinObjectPtr_h
#
include
<
os
/
object
.
h
>
#
include
<
utility
>
#
include
"
mozilla
/
Attributes
.
h
"
#
if
__has_feature
(
objc_arc
)
#
define
AdoptDarwinObject
AdoptDarwinObjectArc
#
define
RetainDarwinObject
RetainDarwinObjectArc
#
define
ReleaseDarwinObject
ReleaseDarwinObjectArc
#
endif
namespace
mozilla
{
template
<
typename
>
class
DarwinObjectPtr
;
template
<
typename
T
>
[
[
nodiscard
]
]
DarwinObjectPtr
<
T
>
AdoptDarwinObject
(
T
)
;
template
<
typename
T
>
static
inline
void
RetainDarwinObject
(
T
aPtr
)
{
#
if
!
__has_feature
(
objc_arc
)
os_retain
(
aPtr
)
;
#
endif
}
template
<
typename
T
>
static
inline
void
ReleaseDarwinObject
(
T
aPtr
)
{
#
if
!
__has_feature
(
objc_arc
)
os_release
(
aPtr
)
;
#
endif
}
template
<
typename
T
>
class
DarwinObjectPtr
{
public
:
DarwinObjectPtr
(
)
:
mPtr
(
nullptr
)
{
}
~
DarwinObjectPtr
(
)
{
if
(
mPtr
)
{
ReleaseDarwinObject
(
mPtr
)
;
}
}
T
get
(
)
const
{
return
mPtr
;
}
explicit
operator
bool
(
)
const
{
return
mPtr
;
}
bool
operator
!
(
)
const
{
return
!
mPtr
;
}
DarwinObjectPtr
(
const
DarwinObjectPtr
&
aOther
)
:
mPtr
(
aOther
.
mPtr
)
{
if
(
mPtr
)
{
RetainDarwinObject
(
mPtr
)
;
}
}
DarwinObjectPtr
(
DarwinObjectPtr
&
&
aOther
)
:
mPtr
(
std
:
:
move
(
aOther
.
mPtr
)
)
{
aOther
.
mPtr
=
nullptr
;
}
MOZ_IMPLICIT
DarwinObjectPtr
(
T
aPtr
)
:
mPtr
(
std
:
:
move
(
aPtr
)
)
{
if
(
mPtr
)
{
RetainDarwinObject
(
mPtr
)
;
}
}
DarwinObjectPtr
&
operator
=
(
const
DarwinObjectPtr
&
aOther
)
{
DarwinObjectPtr
ptr
=
aOther
;
swap
(
ptr
)
;
return
*
this
;
}
DarwinObjectPtr
&
operator
=
(
DarwinObjectPtr
&
&
aOther
)
{
DarwinObjectPtr
ptr
=
std
:
:
move
(
aOther
)
;
swap
(
ptr
)
;
return
*
this
;
}
DarwinObjectPtr
&
operator
=
(
std
:
:
nullptr_t
)
{
if
(
mPtr
)
{
ReleaseDarwinObject
(
mPtr
)
;
}
mPtr
=
nullptr
;
return
*
this
;
}
DarwinObjectPtr
&
operator
=
(
T
aOther
)
{
DarwinObjectPtr
ptr
=
std
:
:
move
(
aOther
)
;
swap
(
ptr
)
;
return
*
this
;
}
void
swap
(
DarwinObjectPtr
&
aOther
)
{
std
:
:
swap
(
mPtr
aOther
.
mPtr
)
;
}
[
[
nodiscard
]
]
T
forget
(
)
{
return
std
:
:
exchange
(
mPtr
nullptr
)
;
}
friend
DarwinObjectPtr
AdoptDarwinObject
<
T
>
(
T
)
;
private
:
struct
AdoptDarwinObjectTag
{
}
;
DarwinObjectPtr
(
AdoptDarwinObjectTag
T
aPtr
)
:
mPtr
(
std
:
:
move
(
aPtr
)
)
{
}
T
mPtr
;
}
;
template
<
typename
T
>
inline
DarwinObjectPtr
<
T
>
AdoptDarwinObject
(
T
aPtr
)
{
return
DarwinObjectPtr
<
T
>
{
typename
DarwinObjectPtr
<
T
>
:
:
AdoptDarwinObjectTag
{
}
std
:
:
move
(
aPtr
)
}
;
}
}
#
endif
