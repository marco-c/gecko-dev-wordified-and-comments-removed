#
ifndef
mozilla_CycleCollectedJSRuntime_h
#
define
mozilla_CycleCollectedJSRuntime_h
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
DeferredFinalize
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
SegmentedVector
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTHashSet
.
h
"
class
nsCycleCollectionNoteRootCallback
;
class
nsIException
;
class
nsWrapperCache
;
namespace
mozilla
{
class
JSGCThingParticipant
:
public
nsCycleCollectionParticipant
{
public
:
constexpr
JSGCThingParticipant
(
)
:
nsCycleCollectionParticipant
(
false
)
{
}
NS_IMETHOD_
(
void
)
Root
(
void
*
)
override
{
MOZ_ASSERT
(
false
"
Don
'
t
call
Root
on
GC
things
"
)
;
}
NS_IMETHOD_
(
void
)
Unlink
(
void
*
)
override
{
MOZ_ASSERT
(
false
"
Don
'
t
call
Unlink
on
GC
things
as
they
may
be
dead
"
)
;
}
NS_IMETHOD_
(
void
)
Unroot
(
void
*
)
override
{
MOZ_ASSERT
(
false
"
Don
'
t
call
Unroot
on
GC
things
as
they
may
be
dead
"
)
;
}
NS_IMETHOD_
(
void
)
DeleteCycleCollectable
(
void
*
aPtr
)
override
{
MOZ_ASSERT
(
false
"
Can
'
t
directly
delete
a
cycle
collectable
GC
thing
"
)
;
}
NS_IMETHOD
TraverseNative
(
void
*
aPtr
nsCycleCollectionTraversalCallback
&
aCb
)
override
;
NS_DECL_CYCLE_COLLECTION_CLASS_NAME_METHOD
(
JSGCThingParticipant
)
}
;
class
JSZoneParticipant
:
public
nsCycleCollectionParticipant
{
public
:
constexpr
JSZoneParticipant
(
)
:
nsCycleCollectionParticipant
(
false
)
{
}
NS_IMETHOD_
(
void
)
Root
(
void
*
)
override
{
MOZ_ASSERT
(
false
"
Don
'
t
call
Root
on
GC
things
"
)
;
}
NS_IMETHOD_
(
void
)
Unlink
(
void
*
)
override
{
MOZ_ASSERT
(
false
"
Don
'
t
call
Unlink
on
GC
things
as
they
may
be
dead
"
)
;
}
NS_IMETHOD_
(
void
)
Unroot
(
void
*
)
override
{
MOZ_ASSERT
(
false
"
Don
'
t
call
Unroot
on
GC
things
as
they
may
be
dead
"
)
;
}
NS_IMETHOD_
(
void
)
DeleteCycleCollectable
(
void
*
)
override
{
MOZ_ASSERT
(
false
"
Can
'
t
directly
delete
a
cycle
collectable
GC
thing
"
)
;
}
NS_IMETHOD
TraverseNative
(
void
*
aPtr
nsCycleCollectionTraversalCallback
&
aCb
)
override
;
NS_DECL_CYCLE_COLLECTION_CLASS_NAME_METHOD
(
JSZoneParticipant
)
}
;
class
IncrementalFinalizeRunnable
;
class
JSHolderMap
{
public
:
enum
WhichHolders
{
AllHolders
HoldersInGrayMarkingZones
}
;
class
Iter
;
JSHolderMap
(
)
;
~
JSHolderMap
(
)
{
MOZ_RELEASE_ASSERT
(
!
mHasIterator
)
;
}
bool
Has
(
void
*
aHolder
)
const
;
nsScriptObjectTracer
*
Get
(
void
*
aHolder
)
const
;
nsScriptObjectTracer
*
Extract
(
void
*
aHolder
)
;
void
Put
(
void
*
aHolder
nsScriptObjectTracer
*
aTracer
JS
:
:
Zone
*
aZone
)
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
struct
Entry
{
void
*
mHolder
;
nsScriptObjectTracer
*
mTracer
;
#
ifdef
DEBUG
JS
:
:
Zone
*
mZone
;
#
endif
Entry
(
)
;
Entry
(
void
*
aHolder
nsScriptObjectTracer
*
aTracer
JS
:
:
Zone
*
aZone
)
;
}
;
using
EntryMap
=
mozilla
:
:
HashMap
<
void
*
Entry
*
DefaultHasher
<
void
*
>
InfallibleAllocPolicy
>
;
using
EntryVector
=
SegmentedVector
<
Entry
256
InfallibleAllocPolicy
>
;
using
EntryVectorMap
=
mozilla
:
:
HashMap
<
JS
:
:
Zone
*
UniquePtr
<
EntryVector
>
DefaultHasher
<
JS
:
:
Zone
*
>
InfallibleAllocPolicy
>
;
class
EntryVectorIter
;
bool
RemoveEntry
(
EntryVector
&
aJSHolders
Entry
*
aEntry
)
;
EntryMap
mJSHolderMap
;
EntryVector
mAnyZoneJSHolders
;
EntryVectorMap
mPerZoneJSHolders
;
bool
mHasIterator
=
false
;
}
;
class
JSHolderMap
:
:
EntryVectorIter
{
public
:
EntryVectorIter
(
JSHolderMap
&
aMap
EntryVector
&
aVector
)
:
mHolderMap
(
aMap
)
mVector
(
aVector
)
mIter
(
aVector
.
Iter
(
)
)
{
Settle
(
)
;
}
const
EntryVector
&
Vector
(
)
const
{
return
mVector
;
}
bool
Done
(
)
const
{
return
mIter
.
Done
(
)
;
}
const
Entry
&
Get
(
)
const
{
return
mIter
.
Get
(
)
;
}
void
Next
(
)
{
mIter
.
Next
(
)
;
Settle
(
)
;
}
operator
const
Entry
*
(
)
const
{
return
&
Get
(
)
;
}
const
Entry
*
operator
-
>
(
)
const
{
return
&
Get
(
)
;
}
private
:
void
Settle
(
)
;
friend
class
JSHolderMap
:
:
Iter
;
JSHolderMap
&
mHolderMap
;
EntryVector
&
mVector
;
EntryVector
:
:
IterImpl
mIter
;
}
;
class
JSHolderMap
:
:
Iter
{
public
:
explicit
Iter
(
JSHolderMap
&
aMap
WhichHolders
aWhich
=
AllHolders
)
;
~
Iter
(
)
{
MOZ_RELEASE_ASSERT
(
mHolderMap
.
mHasIterator
)
;
mHolderMap
.
mHasIterator
=
false
;
}
bool
Done
(
)
const
{
return
mIter
.
Done
(
)
;
}
const
Entry
&
Get
(
)
const
{
return
mIter
.
Get
(
)
;
}
void
Next
(
)
{
mIter
.
Next
(
)
;
Settle
(
)
;
}
void
UpdateForRemovals
(
)
;
operator
const
Entry
*
(
)
const
{
return
&
Get
(
)
;
}
const
Entry
*
operator
-
>
(
)
const
{
return
&
Get
(
)
;
}
JS
:
:
Zone
*
Zone
(
)
const
{
return
mZone
;
}
private
:
void
Settle
(
)
;
JSHolderMap
&
mHolderMap
;
Vector
<
JS
:
:
Zone
*
1
InfallibleAllocPolicy
>
mZones
;
JS
:
:
Zone
*
mZone
=
nullptr
;
EntryVectorIter
mIter
;
}
;
class
CycleCollectedJSRuntime
{
friend
class
JSGCThingParticipant
;
friend
class
JSZoneParticipant
;
friend
class
IncrementalFinalizeRunnable
;
friend
class
CycleCollectedJSContext
;
protected
:
CycleCollectedJSRuntime
(
JSContext
*
aMainContext
)
;
virtual
~
CycleCollectedJSRuntime
(
)
;
virtual
void
Shutdown
(
JSContext
*
cx
)
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
void
UnmarkSkippableJSHolders
(
)
;
virtual
void
TraverseAdditionalNativeRoots
(
nsCycleCollectionNoteRootCallback
&
aCb
)
{
}
virtual
void
TraceAdditionalNativeGrayRoots
(
JSTracer
*
aTracer
)
{
}
virtual
void
CustomGCCallback
(
JSGCStatus
aStatus
)
{
}
virtual
void
CustomOutOfMemoryCallback
(
)
{
}
CycleCollectedJSContext
*
GetContext
(
)
{
return
mContext
;
}
private
:
void
DescribeGCThing
(
bool
aIsMarked
JS
:
:
GCCellPtr
aThing
nsCycleCollectionTraversalCallback
&
aCb
)
const
;
virtual
bool
DescribeCustomObjects
(
JSObject
*
aObject
const
JSClass
*
aClasp
char
(
&
aName
)
[
72
]
)
const
{
return
false
;
}
void
NoteGCThingJSChildren
(
JS
:
:
GCCellPtr
aThing
nsCycleCollectionTraversalCallback
&
aCb
)
const
;
void
NoteGCThingXPCOMChildren
(
const
JSClass
*
aClasp
JSObject
*
aObj
nsCycleCollectionTraversalCallback
&
aCb
)
const
;
virtual
bool
NoteCustomGCThingXPCOMChildren
(
const
JSClass
*
aClasp
JSObject
*
aObj
nsCycleCollectionTraversalCallback
&
aCb
)
const
{
return
false
;
}
enum
TraverseSelect
{
TRAVERSE_CPP
TRAVERSE_FULL
}
;
void
TraverseGCThing
(
TraverseSelect
aTs
JS
:
:
GCCellPtr
aThing
nsCycleCollectionTraversalCallback
&
aCb
)
;
void
TraverseZone
(
JS
:
:
Zone
*
aZone
nsCycleCollectionTraversalCallback
&
aCb
)
;
static
void
TraverseObjectShim
(
void
*
aData
JS
:
:
GCCellPtr
aThing
const
JS
:
:
AutoRequireNoGC
&
nogc
)
;
void
TraverseNativeRoots
(
nsCycleCollectionNoteRootCallback
&
aCb
)
;
static
void
TraceBlackJS
(
JSTracer
*
aTracer
void
*
aData
)
;
static
bool
TraceGrayJS
(
JSTracer
*
aTracer
js
:
:
SliceBudget
&
budget
void
*
aData
)
;
static
void
GCCallback
(
JSContext
*
aContext
JSGCStatus
aStatus
JS
:
:
GCReason
aReason
void
*
aData
)
;
static
void
GCSliceCallback
(
JSContext
*
aContext
JS
:
:
GCProgress
aProgress
const
JS
:
:
GCDescription
&
aDesc
)
;
static
void
GCNurseryCollectionCallback
(
JSContext
*
aContext
JS
:
:
GCNurseryProgress
aProgress
JS
:
:
GCReason
aReason
)
;
static
void
OutOfMemoryCallback
(
JSContext
*
aContext
void
*
aData
)
;
static
bool
ContextCallback
(
JSContext
*
aCx
unsigned
aOperation
void
*
aData
)
;
static
void
*
BeforeWaitCallback
(
uint8_t
*
aMemory
)
;
static
void
AfterWaitCallback
(
void
*
aCookie
)
;
virtual
void
TraceNativeBlackRoots
(
JSTracer
*
aTracer
)
{
}
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
void
TraceAllNativeGrayRoots
(
JSTracer
*
aTracer
)
;
#
endif
bool
TraceNativeGrayRoots
(
JSTracer
*
aTracer
JSHolderMap
:
:
WhichHolders
aWhich
js
:
:
SliceBudget
&
aBudget
)
;
bool
TraceJSHolders
(
JSTracer
*
aTracer
JSHolderMap
:
:
Iter
&
aIter
js
:
:
SliceBudget
&
aBudget
)
;
public
:
void
FinalizeDeferredThings
(
CycleCollectedJSContext
:
:
DeferredFinalizeType
aType
)
;
virtual
void
PrepareForForgetSkippable
(
)
=
0
;
virtual
void
BeginCycleCollectionCallback
(
)
=
0
;
virtual
void
EndCycleCollectionCallback
(
CycleCollectorResults
&
aResults
)
=
0
;
virtual
void
DispatchDeferredDeletion
(
bool
aContinuation
bool
aPurge
=
false
)
=
0
;
enum
class
OOMState
:
uint32_t
{
OK
Reporting
Reported
Recovered
}
;
const
char
*
OOMStateToString
(
const
OOMState
aOomState
)
const
;
void
SetLargeAllocationFailure
(
OOMState
aNewState
)
;
void
AnnotateAndSetOutOfMemory
(
OOMState
*
aStatePtr
OOMState
aNewState
)
;
void
OnGC
(
JSContext
*
aContext
JSGCStatus
aStatus
JS
:
:
GCReason
aReason
)
;
void
OnOutOfMemory
(
)
;
void
OnLargeAllocationFailure
(
)
;
JSRuntime
*
Runtime
(
)
{
return
mJSRuntime
;
}
const
JSRuntime
*
Runtime
(
)
const
{
return
mJSRuntime
;
}
bool
HasPendingIdleGCTask
(
)
const
{
MOZ_ASSERT_IF
(
mHasPendingIdleGCTask
Runtime
(
)
)
;
return
mHasPendingIdleGCTask
;
}
void
SetPendingIdleGCTask
(
)
{
MOZ_ASSERT
(
Runtime
(
)
)
;
mHasPendingIdleGCTask
=
true
;
}
void
ClearPendingIdleGCTask
(
)
{
mHasPendingIdleGCTask
=
false
;
}
void
RunIdleTimeGCTask
(
)
{
if
(
HasPendingIdleGCTask
(
)
)
{
JS
:
:
RunIdleTimeGCTask
(
Runtime
(
)
)
;
ClearPendingIdleGCTask
(
)
;
}
}
bool
IsIdleGCTaskNeeded
(
)
{
return
!
HasPendingIdleGCTask
(
)
&
&
Runtime
(
)
&
&
JS
:
:
IsIdleGCTaskNeeded
(
Runtime
(
)
)
;
}
public
:
void
AddJSHolder
(
void
*
aHolder
nsScriptObjectTracer
*
aTracer
JS
:
:
Zone
*
aZone
)
;
void
RemoveJSHolder
(
void
*
aHolder
)
;
#
ifdef
DEBUG
void
AssertNoObjectsToTrace
(
void
*
aPossibleJSHolder
)
;
#
endif
nsCycleCollectionParticipant
*
GCThingParticipant
(
)
;
nsCycleCollectionParticipant
*
ZoneParticipant
(
)
;
nsresult
TraverseRoots
(
nsCycleCollectionNoteRootCallback
&
aCb
)
;
virtual
bool
UsefulToMergeZones
(
)
const
;
void
FixWeakMappingGrayBits
(
)
const
;
void
CheckGrayBits
(
)
const
;
bool
AreGCGrayBitsValid
(
)
const
;
void
GarbageCollect
(
JS
:
:
GCReason
aReason
)
const
;
void
NurseryWrapperAdded
(
nsWrapperCache
*
aCache
)
;
void
NurseryWrapperPreserved
(
JSObject
*
aWrapper
)
;
void
JSObjectsTenured
(
)
;
void
DeferredFinalize
(
DeferredFinalizeAppendFunction
aAppendFunc
DeferredFinalizeFunction
aFunc
void
*
aThing
)
;
void
DeferredFinalize
(
nsISupports
*
aSupports
)
;
void
DumpJSHeap
(
FILE
*
aFile
)
;
void
AddZoneWaitingForGC
(
JS
:
:
Zone
*
aZone
)
{
mZonesWaitingForGC
.
Insert
(
aZone
)
;
}
static
void
OnZoneDestroyed
(
JSFreeOp
*
aFop
JS
:
:
Zone
*
aZone
)
;
void
PrepareWaitingZonesForGC
(
)
;
static
CycleCollectedJSRuntime
*
Get
(
)
;
void
SetContext
(
CycleCollectedJSContext
*
aContext
)
;
#
ifdef
NIGHTLY_BUILD
bool
GetRecentDevError
(
JSContext
*
aContext
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aError
)
;
void
ClearRecentDevError
(
)
;
#
endif
private
:
CycleCollectedJSContext
*
mContext
;
JSGCThingParticipant
mGCThingCycleCollectorGlobal
;
JSZoneParticipant
mJSZoneCycleCollectorGlobal
;
JSRuntime
*
mJSRuntime
;
bool
mHasPendingIdleGCTask
;
JS
:
:
GCSliceCallback
mPrevGCSliceCallback
;
JS
:
:
GCNurseryCollectionCallback
mPrevGCNurseryCollectionCallback
;
mozilla
:
:
TimeStamp
mLatestNurseryCollectionStart
;
JSHolderMap
mJSHolders
;
Maybe
<
JSHolderMap
:
:
Iter
>
mHolderIter
;
typedef
nsTHashMap
<
nsFuncPtrHashKey
<
DeferredFinalizeFunction
>
void
*
>
DeferredFinalizerTable
;
DeferredFinalizerTable
mDeferredFinalizerTable
;
RefPtr
<
IncrementalFinalizeRunnable
>
mFinalizeRunnable
;
OOMState
mOutOfMemoryState
;
OOMState
mLargeAllocationFailureState
;
static
const
size_t
kSegmentSize
=
512
;
SegmentedVector
<
nsWrapperCache
*
kSegmentSize
InfallibleAllocPolicy
>
mNurseryObjects
;
SegmentedVector
<
JS
:
:
PersistentRooted
<
JSObject
*
>
kSegmentSize
InfallibleAllocPolicy
>
mPreservedNurseryObjects
;
nsTHashSet
<
JS
:
:
Zone
*
>
mZonesWaitingForGC
;
struct
EnvironmentPreparer
:
public
js
:
:
ScriptEnvironmentPreparer
{
void
invoke
(
JS
:
:
HandleObject
global
Closure
&
closure
)
override
;
}
;
EnvironmentPreparer
mEnvironmentPreparer
;
#
ifdef
DEBUG
bool
mShutdownCalled
;
#
endif
#
ifdef
NIGHTLY_BUILD
struct
ErrorInterceptor
final
:
public
JSErrorInterceptor
{
virtual
void
interceptError
(
JSContext
*
cx
JS
:
:
HandleValue
exn
)
override
;
void
Shutdown
(
JSRuntime
*
rt
)
;
struct
ErrorDetails
{
nsString
mFilename
;
nsString
mMessage
;
nsString
mStack
;
JSExnType
mType
;
uint32_t
mLine
;
uint32_t
mColumn
;
}
;
Maybe
<
ErrorDetails
>
mThrownError
;
}
;
ErrorInterceptor
mErrorInterceptor
;
#
endif
}
;
void
TraceScriptHolder
(
nsISupports
*
aHolder
JSTracer
*
aTracer
)
;
}
#
endif
