#
ifndef
mozilla_StaticPtr_h
#
define
mozilla_StaticPtr_h
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
namespace
mozilla
{
template
<
class
T
>
class
MOZ_ONLY_USED_TO_AVOID_STATIC_CONSTRUCTORS
StaticAutoPtr
{
public
:
#
ifdef
DEBUG
StaticAutoPtr
(
)
{
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wuninitialized
"
#
endif
MOZ_ASSERT
(
!
mRawPtr
)
;
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
pop
#
endif
}
#
endif
StaticAutoPtr
<
T
>
&
operator
=
(
T
*
aRhs
)
{
Assign
(
aRhs
)
;
return
*
this
;
}
T
*
get
(
)
const
{
return
mRawPtr
;
}
operator
T
*
(
)
const
{
return
get
(
)
;
}
T
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mRawPtr
)
;
return
get
(
)
;
}
T
&
operator
*
(
)
const
{
return
*
get
(
)
;
}
T
*
forget
(
)
{
T
*
temp
=
mRawPtr
;
mRawPtr
=
nullptr
;
return
temp
;
}
private
:
#
ifdef
DEBUG
StaticAutoPtr
(
StaticAutoPtr
<
T
>
&
aOther
)
;
#
endif
void
Assign
(
T
*
aNewPtr
)
{
MOZ_ASSERT
(
!
aNewPtr
|
|
mRawPtr
!
=
aNewPtr
)
;
T
*
oldPtr
=
mRawPtr
;
mRawPtr
=
aNewPtr
;
delete
oldPtr
;
}
T
*
mRawPtr
;
}
;
template
<
class
T
>
class
MOZ_ONLY_USED_TO_AVOID_STATIC_CONSTRUCTORS
StaticRefPtr
{
public
:
#
ifdef
DEBUG
StaticRefPtr
(
)
{
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wuninitialized
"
#
endif
MOZ_ASSERT
(
!
mRawPtr
)
;
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
pop
#
endif
}
#
endif
StaticRefPtr
<
T
>
&
operator
=
(
T
*
aRhs
)
{
AssignWithAddref
(
aRhs
)
;
return
*
this
;
}
StaticRefPtr
<
T
>
&
operator
=
(
const
StaticRefPtr
<
T
>
&
aRhs
)
{
return
(
this
=
aRhs
.
mRawPtr
)
;
}
StaticRefPtr
<
T
>
&
operator
=
(
already_AddRefed
<
T
>
&
aRhs
)
{
AssignAssumingAddRef
(
aRhs
.
take
(
)
)
;
return
*
this
;
}
StaticRefPtr
<
T
>
&
operator
=
(
already_AddRefed
<
T
>
&
&
aRhs
)
{
AssignAssumingAddRef
(
aRhs
.
take
(
)
)
;
return
*
this
;
}
already_AddRefed
<
T
>
forget
(
)
{
T
*
temp
=
mRawPtr
;
mRawPtr
=
nullptr
;
return
already_AddRefed
<
T
>
(
temp
)
;
}
T
*
get
(
)
const
{
return
mRawPtr
;
}
operator
T
*
(
)
const
{
return
get
(
)
;
}
T
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mRawPtr
)
;
return
get
(
)
;
}
T
&
operator
*
(
)
const
{
return
*
get
(
)
;
}
private
:
void
AssignWithAddref
(
T
*
aNewPtr
)
{
if
(
aNewPtr
)
{
aNewPtr
-
>
AddRef
(
)
;
}
AssignAssumingAddRef
(
aNewPtr
)
;
}
void
AssignAssumingAddRef
(
T
*
aNewPtr
)
{
T
*
oldPtr
=
mRawPtr
;
mRawPtr
=
aNewPtr
;
if
(
oldPtr
)
{
oldPtr
-
>
Release
(
)
;
}
}
T
*
MOZ_OWNING_REF
mRawPtr
;
}
;
namespace
StaticPtr_internal
{
class
Zero
;
}
#
define
REFLEXIVE_EQUALITY_OPERATORS
(
type1
type2
eq_fn
.
.
.
)
\
template
<
__VA_ARGS__
>
\
inline
bool
\
operator
=
=
(
type1
lhs
type2
rhs
)
\
{
\
return
eq_fn
;
\
}
\
\
template
<
__VA_ARGS__
>
\
inline
bool
\
operator
=
=
(
type2
lhs
type1
rhs
)
\
{
\
return
rhs
=
=
lhs
;
\
}
\
\
template
<
__VA_ARGS__
>
\
inline
bool
\
operator
!
=
(
type1
lhs
type2
rhs
)
\
{
\
return
!
(
lhs
=
=
rhs
)
;
\
}
\
\
template
<
__VA_ARGS__
>
\
inline
bool
\
operator
!
=
(
type2
lhs
type1
rhs
)
\
{
\
return
!
(
lhs
=
=
rhs
)
;
\
}
template
<
class
T
class
U
>
inline
bool
operator
=
=
(
const
StaticAutoPtr
<
T
>
&
aLhs
const
StaticAutoPtr
<
U
>
&
aRhs
)
{
return
aLhs
.
get
(
)
=
=
aRhs
.
get
(
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
!
=
(
const
StaticAutoPtr
<
T
>
&
aLhs
const
StaticAutoPtr
<
U
>
&
aRhs
)
{
return
!
(
aLhs
=
=
aRhs
)
;
}
REFLEXIVE_EQUALITY_OPERATORS
(
const
StaticAutoPtr
<
T
>
&
const
U
*
lhs
.
get
(
)
=
=
rhs
class
T
class
U
)
REFLEXIVE_EQUALITY_OPERATORS
(
const
StaticAutoPtr
<
T
>
&
U
*
lhs
.
get
(
)
=
=
rhs
class
T
class
U
)
REFLEXIVE_EQUALITY_OPERATORS
(
const
StaticAutoPtr
<
T
>
&
StaticPtr_internal
:
:
Zero
*
lhs
.
get
(
)
=
=
nullptr
class
T
)
template
<
class
T
class
U
>
inline
bool
operator
=
=
(
const
StaticRefPtr
<
T
>
&
aLhs
const
StaticRefPtr
<
U
>
&
aRhs
)
{
return
aLhs
.
get
(
)
=
=
aRhs
.
get
(
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
!
=
(
const
StaticRefPtr
<
T
>
&
aLhs
const
StaticRefPtr
<
U
>
&
aRhs
)
{
return
!
(
aLhs
=
=
aRhs
)
;
}
REFLEXIVE_EQUALITY_OPERATORS
(
const
StaticRefPtr
<
T
>
&
const
U
*
lhs
.
get
(
)
=
=
rhs
class
T
class
U
)
REFLEXIVE_EQUALITY_OPERATORS
(
const
StaticRefPtr
<
T
>
&
U
*
lhs
.
get
(
)
=
=
rhs
class
T
class
U
)
REFLEXIVE_EQUALITY_OPERATORS
(
const
StaticRefPtr
<
T
>
&
StaticPtr_internal
:
:
Zero
*
lhs
.
get
(
)
=
=
nullptr
class
T
)
#
undef
REFLEXIVE_EQUALITY_OPERATORS
}
template
<
class
T
>
template
<
class
U
>
RefPtr
<
T
>
:
:
RefPtr
(
const
mozilla
:
:
StaticRefPtr
<
U
>
&
aOther
)
:
RefPtr
(
aOther
.
get
(
)
)
{
}
template
<
class
T
>
template
<
class
U
>
RefPtr
<
T
>
&
RefPtr
<
T
>
:
:
operator
=
(
const
mozilla
:
:
StaticRefPtr
<
U
>
&
aOther
)
{
return
operator
=
(
aOther
.
get
(
)
)
;
}
template
<
class
T
>
inline
already_AddRefed
<
T
>
do_AddRef
(
const
mozilla
:
:
StaticRefPtr
<
T
>
&
aObj
)
{
RefPtr
<
T
>
ref
(
aObj
)
;
return
ref
.
forget
(
)
;
}
#
endif
