#
ifndef
mozilla_logging_h
#
define
mozilla_logging_h
#
include
<
string
.
h
>
#
include
<
stdarg
.
h
>
#
include
"
prlog
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MacroForEach
.
h
"
#
if
!
defined
(
ANDROID
)
|
|
!
defined
(
RELEASE_OR_BETA
)
#
define
MOZ_LOGGING_ENABLED
1
#
else
#
define
MOZ_LOGGING_ENABLED
0
#
endif
namespace
mozilla
{
enum
class
LogLevel
{
Disabled
=
0
Error
Warning
Info
Debug
Verbose
}
;
LogLevel
ToLogLevel
(
int32_t
aLevel
)
;
class
LogModule
{
public
:
~
LogModule
(
)
{
:
:
free
(
mName
)
;
}
static
LogModule
*
Get
(
const
char
*
aName
)
;
static
void
Init
(
)
;
static
void
SetLogFile
(
const
char
*
aFilename
)
;
static
uint32_t
GetLogFile
(
char
*
aBuffer
size_t
aLength
)
;
static
void
SetAddTimestamp
(
bool
aAddTimestamp
)
;
static
void
SetIsSync
(
bool
aIsSync
)
;
bool
ShouldLog
(
LogLevel
aLevel
)
const
{
return
mLevel
>
=
aLevel
;
}
LogLevel
Level
(
)
const
{
return
mLevel
;
}
void
SetLevel
(
LogLevel
level
)
{
mLevel
=
level
;
}
void
Printv
(
LogLevel
aLevel
const
char
*
aFmt
va_list
aArgs
)
const
;
const
char
*
Name
(
)
const
{
return
mName
;
}
private
:
friend
class
LogModuleManager
;
explicit
LogModule
(
const
char
*
aName
LogLevel
aLevel
)
:
mName
(
strdup
(
aName
)
)
mLevel
(
aLevel
)
{
}
LogModule
(
LogModule
&
)
=
delete
;
LogModule
&
operator
=
(
const
LogModule
&
)
=
delete
;
char
*
mName
;
Atomic
<
LogLevel
Relaxed
>
mLevel
;
}
;
class
LazyLogModule
final
{
public
:
explicit
constexpr
LazyLogModule
(
const
char
*
aLogName
)
:
mLogName
(
aLogName
)
mLog
(
nullptr
)
{
}
operator
LogModule
*
(
)
{
LogModule
*
tmp
=
mLog
;
if
(
MOZ_UNLIKELY
(
!
tmp
)
)
{
tmp
=
LogModule
:
:
Get
(
mLogName
)
;
mLog
=
tmp
;
}
return
tmp
;
}
private
:
const
char
*
const
mLogName
;
Atomic
<
LogModule
*
ReleaseAcquire
>
mLog
;
}
;
namespace
detail
{
inline
bool
log_test
(
const
PRLogModuleInfo
*
module
LogLevel
level
)
{
MOZ_ASSERT
(
level
!
=
LogLevel
:
:
Disabled
)
;
return
module
&
&
module
-
>
level
>
=
static_cast
<
int
>
(
level
)
;
}
void
log_print
(
const
PRLogModuleInfo
*
aModule
LogLevel
aLevel
const
char
*
aFmt
.
.
.
)
;
inline
bool
log_test
(
const
LogModule
*
module
LogLevel
level
)
{
MOZ_ASSERT
(
level
!
=
LogLevel
:
:
Disabled
)
;
return
module
&
&
module
-
>
ShouldLog
(
level
)
;
}
void
log_print
(
const
LogModule
*
aModule
LogLevel
aLevel
const
char
*
aFmt
.
.
.
)
;
}
}
#
define
MOZ_LOG_EXPAND_ARGS
(
.
.
.
)
__VA_ARGS__
#
if
MOZ_LOGGING_ENABLED
#
define
MOZ_LOG_TEST
(
_module
_level
)
mozilla
:
:
detail
:
:
log_test
(
_module
_level
)
#
else
#
define
MOZ_LOG_TEST
(
_module
_level
)
false
#
endif
#
define
MOZ_LOG
(
_module
_level
_args
)
\
PR_BEGIN_MACRO
\
if
(
MOZ_LOG_TEST
(
_module
_level
)
)
{
\
mozilla
:
:
detail
:
:
log_print
(
_module
_level
MOZ_LOG_EXPAND_ARGS
_args
)
;
\
}
\
PR_END_MACRO
#
undef
PR_LOG
#
undef
PR_LOG_TEST
#
undef
MOZ_LOGGING_ENABLED
#
endif
