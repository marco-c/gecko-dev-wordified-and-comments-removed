#
ifndef
mozilla_MemoryMapping_h
#
define
mozilla_MemoryMapping_h
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
enum
class
VMFlag
:
uint8_t
{
Readable
Writable
Executable
Shared
MayRead
MayWrite
MayExecute
MayShare
GrowsDown
PurePFN
DisabledWrite
Locked
IO
Sequential
Random
NoFork
NoExpand
Accountable
NotReserved
HugeTLB
NonLinear
ArchSpecific
NoCore
SoftDirty
MixedMap
HugePage
NoHugePage
Mergeable
}
;
using
VMFlagSet
=
EnumSet
<
VMFlag
>
;
class
MemoryMapping
final
{
public
:
enum
class
Perm
:
uint8_t
{
Read
Write
Execute
Shared
Private
}
;
using
PermSet
=
EnumSet
<
Perm
>
;
MemoryMapping
(
uintptr_t
aStart
uintptr_t
aEnd
PermSet
aPerms
size_t
aOffset
const
char
*
aName
)
:
mStart
(
aStart
)
mEnd
(
aEnd
)
mOffset
(
aOffset
)
mName
(
aName
)
mPerms
(
aPerms
)
{
}
const
nsCString
&
Name
(
)
const
{
return
mName
;
}
uintptr_t
Start
(
)
const
{
return
mStart
;
}
uintptr_t
End
(
)
const
{
return
mEnd
;
}
bool
Includes
(
const
void
*
aPtr
)
const
{
auto
ptr
=
uintptr_t
(
aPtr
)
;
return
ptr
>
=
mStart
&
&
ptr
<
mEnd
;
}
PermSet
Perms
(
)
const
{
return
mPerms
;
}
VMFlagSet
VMFlags
(
)
const
{
return
mFlags
;
}
size_t
Offset
(
)
const
{
return
mOffset
;
}
size_t
AnonHugePages
(
)
const
{
return
mAnonHugePages
;
}
size_t
Anonymous
(
)
const
{
return
mAnonymous
;
}
size_t
KernelPageSize
(
)
const
{
return
mKernelPageSize
;
}
size_t
LazyFree
(
)
const
{
return
mLazyFree
;
}
size_t
Locked
(
)
const
{
return
mLocked
;
}
size_t
MMUPageSize
(
)
const
{
return
mMMUPageSize
;
}
size_t
Private_Clean
(
)
const
{
return
mPrivate_Clean
;
}
size_t
Private_Dirty
(
)
const
{
return
mPrivate_Dirty
;
}
size_t
Private_Hugetlb
(
)
const
{
return
mPrivate_Hugetlb
;
}
size_t
Pss
(
)
const
{
return
mPss
;
}
size_t
Referenced
(
)
const
{
return
mReferenced
;
}
size_t
Rss
(
)
const
{
return
mRss
;
}
size_t
Shared_Clean
(
)
const
{
return
mShared_Clean
;
}
size_t
Shared_Dirty
(
)
const
{
return
mShared_Dirty
;
}
size_t
Shared_Hugetlb
(
)
const
{
return
mShared_Hugetlb
;
}
size_t
ShmemPmdMapped
(
)
const
{
return
mShmemPmdMapped
;
}
size_t
Size
(
)
const
{
return
mSize
;
}
size_t
Swap
(
)
const
{
return
mSwap
;
}
size_t
SwapPss
(
)
const
{
return
mSwapPss
;
}
void
Dump
(
nsACString
&
aOut
)
const
;
bool
operator
=
=
(
const
void
*
aPtr
)
const
{
return
Includes
(
aPtr
)
;
}
bool
operator
<
(
const
void
*
aPtr
)
const
{
return
mStart
<
uintptr_t
(
aPtr
)
;
}
private
:
friend
nsresult
GetMemoryMappings
(
nsTArray
<
MemoryMapping
>
&
aMappings
)
;
uintptr_t
mStart
=
0
;
uintptr_t
mEnd
=
0
;
size_t
mOffset
=
0
;
nsCString
mName
;
size_t
mAnonHugePages
=
0
;
size_t
mAnonymous
=
0
;
size_t
mKernelPageSize
=
0
;
size_t
mLazyFree
=
0
;
size_t
mLocked
=
0
;
size_t
mMMUPageSize
=
0
;
size_t
mPrivate_Clean
=
0
;
size_t
mPrivate_Dirty
=
0
;
size_t
mPrivate_Hugetlb
=
0
;
size_t
mPss
=
0
;
size_t
mReferenced
=
0
;
size_t
mRss
=
0
;
size_t
mShared_Clean
=
0
;
size_t
mShared_Dirty
=
0
;
size_t
mShared_Hugetlb
=
0
;
size_t
mShmemPmdMapped
=
0
;
size_t
mSize
=
0
;
size_t
mSwap
=
0
;
size_t
mSwapPss
=
0
;
PermSet
mPerms
{
}
;
VMFlagSet
mFlags
{
}
;
struct
Field
{
const
char
*
mName
;
size_t
mOffset
;
}
;
static
const
Field
sFields
[
20
]
;
size_t
&
ValueForField
(
const
Field
&
aField
)
{
char
*
fieldPtr
=
reinterpret_cast
<
char
*
>
(
this
)
+
aField
.
mOffset
;
return
reinterpret_cast
<
size_t
*
>
(
fieldPtr
)
[
0
]
;
}
size_t
ValueForField
(
const
Field
&
aField
)
const
{
return
const_cast
<
MemoryMapping
*
>
(
this
)
-
>
ValueForField
(
aField
)
;
}
}
;
nsresult
GetMemoryMappings
(
nsTArray
<
MemoryMapping
>
&
aMappings
)
;
}
#
endif
