#
ifndef
mozilla_OwningNonNull_h
#
define
mozilla_OwningNonNull_h
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCycleCollectionNoteChild
.
h
"
namespace
mozilla
{
template
<
class
T
>
class
MOZ_IS_SMARTPTR_TO_REFCOUNTED
OwningNonNull
{
public
:
OwningNonNull
(
)
{
}
MOZ_IMPLICIT
OwningNonNull
(
T
&
aValue
)
{
init
(
&
aValue
)
;
}
template
<
class
U
>
MOZ_IMPLICIT
OwningNonNull
(
already_AddRefed
<
U
>
&
&
aValue
)
{
init
(
aValue
)
;
}
template
<
class
U
>
MOZ_IMPLICIT
OwningNonNull
(
const
OwningNonNull
<
U
>
&
aValue
)
{
init
(
aValue
)
;
}
operator
T
&
(
)
const
{
MOZ_ASSERT
(
mInited
)
;
MOZ_ASSERT
(
mPtr
"
OwningNonNull
<
T
>
was
set
to
null
"
)
;
return
*
mPtr
;
}
operator
T
*
(
)
const
{
MOZ_ASSERT
(
mInited
)
;
MOZ_ASSERT
(
mPtr
"
OwningNonNull
<
T
>
was
set
to
null
"
)
;
return
mPtr
;
}
explicit
operator
bool
(
)
const
=
delete
;
T
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mInited
)
;
MOZ_ASSERT
(
mPtr
"
OwningNonNull
<
T
>
was
set
to
null
"
)
;
return
mPtr
;
}
OwningNonNull
<
T
>
&
operator
=
(
T
*
aValue
)
{
init
(
aValue
)
;
return
*
this
;
}
OwningNonNull
<
T
>
&
operator
=
(
T
&
aValue
)
{
init
(
&
aValue
)
;
return
*
this
;
}
template
<
class
U
>
OwningNonNull
<
T
>
&
operator
=
(
already_AddRefed
<
U
>
&
&
aValue
)
{
init
(
aValue
)
;
return
*
this
;
}
template
<
class
U
>
OwningNonNull
<
T
>
&
operator
=
(
const
OwningNonNull
<
U
>
&
aValue
)
{
init
(
aValue
)
;
return
*
this
;
}
void
operator
=
(
decltype
(
nullptr
)
)
=
delete
;
already_AddRefed
<
T
>
forget
(
)
{
#
ifdef
DEBUG
mInited
=
false
;
#
endif
return
mPtr
.
forget
(
)
;
}
template
<
class
U
>
void
forget
(
U
*
*
aOther
)
{
#
ifdef
DEBUG
mInited
=
false
;
#
endif
mPtr
.
forget
(
aOther
)
;
}
T
&
ref
(
)
const
{
MOZ_ASSERT
(
mInited
)
;
MOZ_ASSERT
(
mPtr
)
;
return
*
mPtr
;
}
T
*
get
(
)
const
{
MOZ_ASSERT
(
mInited
)
;
MOZ_ASSERT
(
mPtr
)
;
return
mPtr
;
}
template
<
typename
U
>
void
swap
(
U
&
aOther
)
{
mPtr
.
swap
(
aOther
)
;
#
ifdef
DEBUG
mInited
=
mPtr
;
#
endif
}
bool
isInitialized
(
)
const
{
MOZ_ASSERT
(
!
!
mPtr
=
=
mInited
"
mInited
out
of
sync
with
mPtr
?
"
)
;
return
mPtr
;
}
protected
:
template
<
typename
U
>
void
init
(
U
&
&
aValue
)
{
mPtr
=
aValue
;
MOZ_ASSERT
(
mPtr
)
;
#
ifdef
DEBUG
mInited
=
true
;
#
endif
}
RefPtr
<
T
>
mPtr
;
#
ifdef
DEBUG
bool
mInited
=
false
;
#
endif
}
;
template
<
typename
T
>
inline
void
ImplCycleCollectionUnlink
(
OwningNonNull
<
T
>
&
aField
)
{
RefPtr
<
T
>
releaser
(
aField
.
forget
(
)
)
;
}
template
<
typename
T
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
OwningNonNull
<
T
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
CycleCollectionNoteChild
(
aCallback
aField
.
get
(
)
aName
aFlags
)
;
}
}
template
<
class
T
>
template
<
class
U
>
nsCOMPtr
<
T
>
:
:
nsCOMPtr
(
const
mozilla
:
:
OwningNonNull
<
U
>
&
aOther
)
:
nsCOMPtr
(
aOther
.
get
(
)
)
{
}
template
<
class
T
>
template
<
class
U
>
nsCOMPtr
<
T
>
&
nsCOMPtr
<
T
>
:
:
operator
=
(
const
mozilla
:
:
OwningNonNull
<
U
>
&
aOther
)
{
return
operator
=
(
aOther
.
get
(
)
)
;
}
template
<
class
T
>
template
<
class
U
>
RefPtr
<
T
>
:
:
RefPtr
(
const
mozilla
:
:
OwningNonNull
<
U
>
&
aOther
)
:
RefPtr
(
aOther
.
get
(
)
)
{
}
template
<
class
T
>
template
<
class
U
>
RefPtr
<
T
>
&
RefPtr
<
T
>
:
:
operator
=
(
const
mozilla
:
:
OwningNonNull
<
U
>
&
aOther
)
{
return
operator
=
(
aOther
.
get
(
)
)
;
}
#
endif
