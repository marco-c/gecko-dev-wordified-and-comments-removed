#
include
"
AvailableMemoryWatcher
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsMemoryPressure
.
h
"
#
include
"
nsXULAppAPI
.
h
"
namespace
mozilla
{
class
NullTabUnloader
final
:
public
nsITabUnloader
{
~
NullTabUnloader
(
)
=
default
;
public
:
NullTabUnloader
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_NSITABUNLOADER
}
;
NS_IMPL_ISUPPORTS
(
NullTabUnloader
nsITabUnloader
)
NS_IMETHODIMP
NullTabUnloader
:
:
UnloadTabAsync
(
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
StaticRefPtr
<
nsAvailableMemoryWatcherBase
>
nsAvailableMemoryWatcherBase
:
:
sSingleton
;
already_AddRefed
<
nsAvailableMemoryWatcherBase
>
nsAvailableMemoryWatcherBase
:
:
GetSingleton
(
)
{
if
(
!
sSingleton
)
{
sSingleton
=
CreateAvailableMemoryWatcher
(
)
;
ClearOnShutdown
(
&
sSingleton
)
;
}
return
do_AddRef
(
sSingleton
)
;
}
NS_IMPL_ISUPPORTS
(
nsAvailableMemoryWatcherBase
nsIAvailableMemoryWatcherBase
)
;
nsAvailableMemoryWatcherBase
:
:
nsAvailableMemoryWatcherBase
(
)
:
mTabUnloader
(
new
NullTabUnloader
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Watching
memory
only
in
the
main
process
.
"
)
;
}
nsresult
nsAvailableMemoryWatcherBase
:
:
RegisterTabUnloader
(
nsITabUnloader
*
aTabUnloader
)
{
mTabUnloader
=
aTabUnloader
;
return
NS_OK
;
}
nsresult
nsAvailableMemoryWatcherBase
:
:
OnUnloadAttemptCompleted
(
nsresult
aResult
)
{
if
(
aResult
=
=
NS_ERROR_NOT_AVAILABLE
)
{
NS_NotifyOfEventualMemoryPressure
(
MemoryPressureState
:
:
LowMemory
)
;
}
return
NS_OK
;
}
#
if
!
defined
(
XP_WIN
)
already_AddRefed
<
nsAvailableMemoryWatcherBase
>
CreateAvailableMemoryWatcher
(
)
{
RefPtr
instance
(
new
nsAvailableMemoryWatcherBase
)
;
return
do_AddRef
(
instance
)
;
}
#
endif
}
