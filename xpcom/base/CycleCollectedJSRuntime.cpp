#
include
"
mozilla
/
CycleCollectedJSRuntime
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Snprintf
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimelineConsumers
.
h
"
#
include
"
mozilla
/
TimelineMarker
.
h
"
#
include
"
mozilla
/
DebuggerOnGCRunnable
.
h
"
#
include
"
mozilla
/
dom
/
DOMJSClass
.
h
"
#
include
"
mozilla
/
dom
/
ProfileTimelineMarkerBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseBinding
.
h
"
#
include
"
mozilla
/
dom
/
PromiseDebugging
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
jsprf
.
h
"
#
include
"
js
/
Debug
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCycleCollectionNoteRootCallback
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
ifdef
MOZ_CRASHREPORTER
#
include
"
nsExceptionHandler
.
h
"
#
endif
#
include
"
nsIException
.
h
"
#
include
"
nsIPlatformInfo
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
xpcpublic
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
struct
DeferredFinalizeFunctionHolder
{
DeferredFinalizeFunction
run
;
void
*
data
;
}
;
class
IncrementalFinalizeRunnable
:
public
Runnable
{
typedef
AutoTArray
<
DeferredFinalizeFunctionHolder
16
>
DeferredFinalizeArray
;
typedef
CycleCollectedJSRuntime
:
:
DeferredFinalizerTable
DeferredFinalizerTable
;
CycleCollectedJSRuntime
*
mRuntime
;
DeferredFinalizeArray
mDeferredFinalizeFunctions
;
uint32_t
mFinalizeFunctionToRun
;
bool
mReleasing
;
static
const
PRTime
SliceMillis
=
5
;
public
:
IncrementalFinalizeRunnable
(
CycleCollectedJSRuntime
*
aRt
DeferredFinalizerTable
&
aFinalizerTable
)
;
virtual
~
IncrementalFinalizeRunnable
(
)
;
void
ReleaseNow
(
bool
aLimited
)
;
NS_DECL_NSIRUNNABLE
}
;
}
struct
NoteWeakMapChildrenTracer
:
public
JS
:
:
CallbackTracer
{
NoteWeakMapChildrenTracer
(
JSRuntime
*
aRt
nsCycleCollectionNoteRootCallback
&
aCb
)
:
JS
:
:
CallbackTracer
(
aRt
)
mCb
(
aCb
)
mTracedAny
(
false
)
mMap
(
nullptr
)
mKey
(
nullptr
)
mKeyDelegate
(
nullptr
)
{
}
void
onChild
(
const
JS
:
:
GCCellPtr
&
aThing
)
override
;
nsCycleCollectionNoteRootCallback
&
mCb
;
bool
mTracedAny
;
JSObject
*
mMap
;
JS
:
:
GCCellPtr
mKey
;
JSObject
*
mKeyDelegate
;
}
;
void
NoteWeakMapChildrenTracer
:
:
onChild
(
const
JS
:
:
GCCellPtr
&
aThing
)
{
if
(
aThing
.
is
<
JSString
>
(
)
)
{
return
;
}
if
(
!
JS
:
:
GCThingIsMarkedGray
(
aThing
)
&
&
!
mCb
.
WantAllTraces
(
)
)
{
return
;
}
if
(
AddToCCKind
(
aThing
.
kind
(
)
)
)
{
mCb
.
NoteWeakMapping
(
mMap
mKey
mKeyDelegate
aThing
)
;
mTracedAny
=
true
;
}
else
{
JS
:
:
TraceChildren
(
this
aThing
)
;
}
}
struct
NoteWeakMapsTracer
:
public
js
:
:
WeakMapTracer
{
NoteWeakMapsTracer
(
JSRuntime
*
aRt
nsCycleCollectionNoteRootCallback
&
aCccb
)
:
js
:
:
WeakMapTracer
(
aRt
)
mCb
(
aCccb
)
mChildTracer
(
aRt
aCccb
)
{
}
void
trace
(
JSObject
*
aMap
JS
:
:
GCCellPtr
aKey
JS
:
:
GCCellPtr
aValue
)
override
;
nsCycleCollectionNoteRootCallback
&
mCb
;
NoteWeakMapChildrenTracer
mChildTracer
;
}
;
void
NoteWeakMapsTracer
:
:
trace
(
JSObject
*
aMap
JS
:
:
GCCellPtr
aKey
JS
:
:
GCCellPtr
aValue
)
{
if
(
(
!
aKey
|
|
!
JS
:
:
GCThingIsMarkedGray
(
aKey
)
)
&
&
MOZ_LIKELY
(
!
mCb
.
WantAllTraces
(
)
)
)
{
if
(
!
aValue
|
|
!
JS
:
:
GCThingIsMarkedGray
(
aValue
)
|
|
aValue
.
is
<
JSString
>
(
)
)
{
return
;
}
}
MOZ_ASSERT
(
AddToCCKind
(
aKey
.
kind
(
)
)
)
;
if
(
!
AddToCCKind
(
aKey
.
kind
(
)
)
)
{
aKey
=
nullptr
;
}
JSObject
*
kdelegate
=
nullptr
;
if
(
aKey
.
is
<
JSObject
>
(
)
)
{
kdelegate
=
js
:
:
GetWeakmapKeyDelegate
(
&
aKey
.
as
<
JSObject
>
(
)
)
;
}
if
(
AddToCCKind
(
aValue
.
kind
(
)
)
)
{
mCb
.
NoteWeakMapping
(
aMap
aKey
kdelegate
aValue
)
;
}
else
{
mChildTracer
.
mTracedAny
=
false
;
mChildTracer
.
mMap
=
aMap
;
mChildTracer
.
mKey
=
aKey
;
mChildTracer
.
mKeyDelegate
=
kdelegate
;
if
(
!
aValue
.
is
<
JSString
>
(
)
)
{
JS
:
:
TraceChildren
(
&
mChildTracer
aValue
)
;
}
if
(
!
mChildTracer
.
mTracedAny
&
&
aKey
&
&
JS
:
:
GCThingIsMarkedGray
(
aKey
)
&
&
kdelegate
)
{
mCb
.
NoteWeakMapping
(
aMap
aKey
kdelegate
nullptr
)
;
}
}
}
struct
FixWeakMappingGrayBitsTracer
:
public
js
:
:
WeakMapTracer
{
explicit
FixWeakMappingGrayBitsTracer
(
JSRuntime
*
aRt
)
:
js
:
:
WeakMapTracer
(
aRt
)
{
}
void
FixAll
(
)
{
do
{
mAnyMarked
=
false
;
js
:
:
TraceWeakMaps
(
this
)
;
}
while
(
mAnyMarked
)
;
}
void
trace
(
JSObject
*
aMap
JS
:
:
GCCellPtr
aKey
JS
:
:
GCCellPtr
aValue
)
override
{
bool
delegateMightNeedMarking
=
aKey
&
&
JS
:
:
GCThingIsMarkedGray
(
aKey
)
;
bool
valueMightNeedMarking
=
aValue
&
&
JS
:
:
GCThingIsMarkedGray
(
aValue
)
&
&
aValue
.
kind
(
)
!
=
JS
:
:
TraceKind
:
:
String
;
if
(
!
delegateMightNeedMarking
&
&
!
valueMightNeedMarking
)
{
return
;
}
if
(
!
AddToCCKind
(
aKey
.
kind
(
)
)
)
{
aKey
=
nullptr
;
}
if
(
delegateMightNeedMarking
&
&
aKey
.
is
<
JSObject
>
(
)
)
{
JSObject
*
kdelegate
=
js
:
:
GetWeakmapKeyDelegate
(
&
aKey
.
as
<
JSObject
>
(
)
)
;
if
(
kdelegate
&
&
!
JS
:
:
ObjectIsMarkedGray
(
kdelegate
)
)
{
if
(
JS
:
:
UnmarkGrayGCThingRecursively
(
aKey
)
)
{
mAnyMarked
=
true
;
}
}
}
if
(
aValue
&
&
JS
:
:
GCThingIsMarkedGray
(
aValue
)
&
&
(
!
aKey
|
|
!
JS
:
:
GCThingIsMarkedGray
(
aKey
)
)
&
&
(
!
aMap
|
|
!
JS
:
:
ObjectIsMarkedGray
(
aMap
)
)
&
&
aValue
.
kind
(
)
!
=
JS
:
:
TraceKind
:
:
Shape
)
{
if
(
JS
:
:
UnmarkGrayGCThingRecursively
(
aValue
)
)
{
mAnyMarked
=
true
;
}
}
}
bool
mAnyMarked
;
}
;
static
void
CheckParticipatesInCycleCollection
(
JS
:
:
GCCellPtr
aThing
const
char
*
aName
void
*
aClosure
)
{
bool
*
cycleCollectionEnabled
=
static_cast
<
bool
*
>
(
aClosure
)
;
if
(
*
cycleCollectionEnabled
)
{
return
;
}
if
(
AddToCCKind
(
aThing
.
kind
(
)
)
&
&
JS
:
:
GCThingIsMarkedGray
(
aThing
)
)
{
*
cycleCollectionEnabled
=
true
;
}
}
NS_IMETHODIMP
JSGCThingParticipant
:
:
Traverse
(
void
*
aPtr
nsCycleCollectionTraversalCallback
&
aCb
)
{
auto
runtime
=
reinterpret_cast
<
CycleCollectedJSRuntime
*
>
(
reinterpret_cast
<
char
*
>
(
this
)
-
offsetof
(
CycleCollectedJSRuntime
mGCThingCycleCollectorGlobal
)
)
;
JS
:
:
GCCellPtr
cellPtr
(
aPtr
JS
:
:
GCThingTraceKind
(
aPtr
)
)
;
runtime
-
>
TraverseGCThing
(
CycleCollectedJSRuntime
:
:
TRAVERSE_FULL
cellPtr
aCb
)
;
return
NS_OK
;
}
static
JSGCThingParticipant
sGCThingCycleCollectorGlobal
;
NS_IMETHODIMP
JSZoneParticipant
:
:
Traverse
(
void
*
aPtr
nsCycleCollectionTraversalCallback
&
aCb
)
{
auto
runtime
=
reinterpret_cast
<
CycleCollectedJSRuntime
*
>
(
reinterpret_cast
<
char
*
>
(
this
)
-
offsetof
(
CycleCollectedJSRuntime
mJSZoneCycleCollectorGlobal
)
)
;
MOZ_ASSERT
(
!
aCb
.
WantAllTraces
(
)
)
;
JS
:
:
Zone
*
zone
=
static_cast
<
JS
:
:
Zone
*
>
(
aPtr
)
;
runtime
-
>
TraverseZone
(
zone
aCb
)
;
return
NS_OK
;
}
struct
TraversalTracer
:
public
JS
:
:
CallbackTracer
{
TraversalTracer
(
JSRuntime
*
aRt
nsCycleCollectionTraversalCallback
&
aCb
)
:
JS
:
:
CallbackTracer
(
aRt
DoNotTraceWeakMaps
)
mCb
(
aCb
)
{
}
void
onChild
(
const
JS
:
:
GCCellPtr
&
aThing
)
override
;
nsCycleCollectionTraversalCallback
&
mCb
;
}
;
void
TraversalTracer
:
:
onChild
(
const
JS
:
:
GCCellPtr
&
aThing
)
{
if
(
!
JS
:
:
GCThingIsMarkedGray
(
aThing
)
&
&
!
mCb
.
WantAllTraces
(
)
)
{
return
;
}
if
(
AddToCCKind
(
aThing
.
kind
(
)
)
)
{
if
(
MOZ_UNLIKELY
(
mCb
.
WantDebugInfo
(
)
)
)
{
char
buffer
[
200
]
;
getTracingEdgeName
(
buffer
sizeof
(
buffer
)
)
;
mCb
.
NoteNextEdgeName
(
buffer
)
;
}
if
(
aThing
.
is
<
JSObject
>
(
)
)
{
mCb
.
NoteJSObject
(
&
aThing
.
as
<
JSObject
>
(
)
)
;
}
else
{
mCb
.
NoteJSScript
(
&
aThing
.
as
<
JSScript
>
(
)
)
;
}
}
else
if
(
aThing
.
is
<
js
:
:
Shape
>
(
)
)
{
JS_TraceShapeCycleCollectorChildren
(
this
aThing
)
;
}
else
if
(
aThing
.
is
<
js
:
:
ObjectGroup
>
(
)
)
{
JS_TraceObjectGroupCycleCollectorChildren
(
this
aThing
)
;
}
else
if
(
!
aThing
.
is
<
JSString
>
(
)
)
{
JS
:
:
TraceChildren
(
this
aThing
)
;
}
}
static
void
NoteJSChildGrayWrapperShim
(
void
*
aData
JS
:
:
GCCellPtr
aThing
)
{
TraversalTracer
*
trc
=
static_cast
<
TraversalTracer
*
>
(
aData
)
;
trc
-
>
onChild
(
aThing
)
;
}
static
const
JSZoneParticipant
sJSZoneCycleCollectorGlobal
;
static
void
JSObjectsTenuredCb
(
JSRuntime
*
aRuntime
void
*
aData
)
{
static_cast
<
CycleCollectedJSRuntime
*
>
(
aData
)
-
>
JSObjectsTenured
(
)
;
}
bool
mozilla
:
:
GetBuildId
(
JS
:
:
BuildIdCharVector
*
aBuildID
)
{
nsCOMPtr
<
nsIPlatformInfo
>
info
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
)
;
if
(
!
info
)
{
return
false
;
}
nsCString
buildID
;
nsresult
rv
=
info
-
>
GetPlatformBuildID
(
buildID
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
!
aBuildID
-
>
resize
(
buildID
.
Length
(
)
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
buildID
.
Length
(
)
;
i
+
+
)
{
(
*
aBuildID
)
[
i
]
=
buildID
[
i
]
;
}
return
true
;
}
CycleCollectedJSRuntime
:
:
CycleCollectedJSRuntime
(
)
:
mGCThingCycleCollectorGlobal
(
sGCThingCycleCollectorGlobal
)
mJSZoneCycleCollectorGlobal
(
sJSZoneCycleCollectorGlobal
)
mJSRuntime
(
nullptr
)
mJSContext
(
nullptr
)
mPrevGCSliceCallback
(
nullptr
)
mPrevGCNurseryCollectionCallback
(
nullptr
)
mJSHolders
(
256
)
mDoingStableStates
(
false
)
mOutOfMemoryState
(
OOMState
:
:
OK
)
mLargeAllocationFailureState
(
OOMState
:
:
OK
)
{
nsCOMPtr
<
nsIThread
>
thread
=
do_GetCurrentThread
(
)
;
mOwningThread
=
thread
.
forget
(
)
.
downcast
<
nsThread
>
(
)
.
take
(
)
;
MOZ_RELEASE_ASSERT
(
mOwningThread
)
;
}
CycleCollectedJSRuntime
:
:
~
CycleCollectedJSRuntime
(
)
{
if
(
!
mJSRuntime
)
{
return
;
}
MOZ_ASSERT
(
!
mDeferredFinalizerTable
.
Count
(
)
)
;
ProcessMetastableStateQueue
(
mBaseRecursionDepth
)
;
MOZ_ASSERT
(
mMetastableStateEvents
.
IsEmpty
(
)
)
;
ProcessStableStateQueue
(
)
;
MOZ_ASSERT
(
mStableStateEvents
.
IsEmpty
(
)
)
;
mPendingException
=
nullptr
;
MOZ_ASSERT
(
mDebuggerPromiseMicroTaskQueue
.
empty
(
)
)
;
MOZ_ASSERT
(
mPromiseMicroTaskQueue
.
empty
(
)
)
;
#
ifdef
SPIDERMONKEY_PROMISE
mUncaughtRejections
.
reset
(
)
;
mConsumedRejections
.
reset
(
)
;
#
endif
JS_DestroyRuntime
(
mJSRuntime
)
;
mJSRuntime
=
nullptr
;
mJSContext
=
nullptr
;
nsCycleCollector_forgetJSRuntime
(
)
;
mozilla
:
:
dom
:
:
DestroyScriptSettings
(
)
;
mOwningThread
-
>
SetScriptObserver
(
nullptr
)
;
NS_RELEASE
(
mOwningThread
)
;
}
static
void
MozCrashWarningReporter
(
JSContext
*
const
char
*
JSErrorReport
*
)
{
MOZ_CRASH
(
"
Why
is
someone
touching
JSAPI
without
an
AutoJSAPI
?
"
)
;
}
nsresult
CycleCollectedJSRuntime
:
:
Initialize
(
JSRuntime
*
aParentRuntime
uint32_t
aMaxBytes
uint32_t
aMaxNurseryBytes
)
{
MOZ_ASSERT
(
!
mJSRuntime
)
;
mOwningThread
-
>
SetScriptObserver
(
this
)
;
mBaseRecursionDepth
=
RecursionDepth
(
)
;
mozilla
:
:
dom
:
:
InitScriptSettings
(
)
;
mJSRuntime
=
JS_NewRuntime
(
aMaxBytes
aMaxNurseryBytes
aParentRuntime
)
;
if
(
!
mJSRuntime
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mJSContext
=
JS_GetContext
(
mJSRuntime
)
;
if
(
!
JS_AddExtraGCRootsTracer
(
mJSRuntime
TraceBlackJS
this
)
)
{
MOZ_CRASH
(
"
JS_AddExtraGCRootsTracer
failed
"
)
;
}
JS_SetGrayGCRootsTracer
(
mJSRuntime
TraceGrayJS
this
)
;
JS_SetGCCallback
(
mJSRuntime
GCCallback
this
)
;
mPrevGCSliceCallback
=
JS
:
:
SetGCSliceCallback
(
mJSRuntime
GCSliceCallback
)
;
if
(
NS_IsMainThread
(
)
)
{
mPrevGCNurseryCollectionCallback
=
JS
:
:
SetGCNurseryCollectionCallback
(
mJSRuntime
GCNurseryCollectionCallback
)
;
}
JS_SetObjectsTenuredCallback
(
mJSRuntime
JSObjectsTenuredCb
this
)
;
JS
:
:
SetOutOfMemoryCallback
(
mJSRuntime
OutOfMemoryCallback
this
)
;
JS
:
:
SetLargeAllocationFailureCallback
(
mJSRuntime
LargeAllocationFailureCallback
this
)
;
JS_SetDestroyZoneCallback
(
mJSContext
XPCStringConvert
:
:
FreeZoneCache
)
;
JS_SetSweepZoneCallback
(
mJSContext
XPCStringConvert
:
:
ClearZoneCache
)
;
JS
:
:
SetBuildIdOp
(
mJSContext
GetBuildId
)
;
JS
:
:
SetWarningReporter
(
mJSContext
MozCrashWarningReporter
)
;
static
js
:
:
DOMCallbacks
DOMcallbacks
=
{
InstanceClassHasProtoAtDepth
}
;
SetDOMCallbacks
(
mJSRuntime
&
DOMcallbacks
)
;
js
:
:
SetScriptEnvironmentPreparer
(
mJSRuntime
&
mEnvironmentPreparer
)
;
JS
:
:
SetGetIncumbentGlobalCallback
(
mJSRuntime
GetIncumbentGlobalCallback
)
;
#
ifdef
SPIDERMONKEY_PROMISE
JS
:
:
SetEnqueuePromiseJobCallback
(
mJSRuntime
EnqueuePromiseJobCallback
this
)
;
JS
:
:
SetPromiseRejectionTrackerCallback
(
mJSRuntime
PromiseRejectionTrackerCallback
this
)
;
mUncaughtRejections
.
init
(
mJSRuntime
JS
:
:
GCVector
<
JSObject
*
0
js
:
:
SystemAllocPolicy
>
(
js
:
:
SystemAllocPolicy
(
)
)
)
;
mConsumedRejections
.
init
(
mJSRuntime
JS
:
:
GCVector
<
JSObject
*
0
js
:
:
SystemAllocPolicy
>
(
js
:
:
SystemAllocPolicy
(
)
)
)
;
#
endif
JS
:
:
dbg
:
:
SetDebuggerMallocSizeOf
(
mJSRuntime
moz_malloc_size_of
)
;
nsCycleCollector_registerJSRuntime
(
this
)
;
return
NS_OK
;
}
size_t
CycleCollectedJSRuntime
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
n
+
=
mJSHolders
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
n
;
}
void
CycleCollectedJSRuntime
:
:
UnmarkSkippableJSHolders
(
)
{
for
(
auto
iter
=
mJSHolders
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
void
*
holder
=
iter
.
Key
(
)
;
nsScriptObjectTracer
*
&
tracer
=
iter
.
Data
(
)
;
tracer
-
>
CanSkip
(
holder
true
)
;
}
}
void
CycleCollectedJSRuntime
:
:
DescribeGCThing
(
bool
aIsMarked
JS
:
:
GCCellPtr
aThing
nsCycleCollectionTraversalCallback
&
aCb
)
const
{
if
(
!
aCb
.
WantDebugInfo
(
)
)
{
aCb
.
DescribeGCedNode
(
aIsMarked
"
JS
Object
"
)
;
return
;
}
char
name
[
72
]
;
uint64_t
compartmentAddress
=
0
;
if
(
aThing
.
is
<
JSObject
>
(
)
)
{
JSObject
*
obj
=
&
aThing
.
as
<
JSObject
>
(
)
;
compartmentAddress
=
(
uint64_t
)
js
:
:
GetObjectCompartment
(
obj
)
;
const
js
:
:
Class
*
clasp
=
js
:
:
GetObjectClass
(
obj
)
;
if
(
DescribeCustomObjects
(
obj
clasp
name
)
)
{
}
else
if
(
js
:
:
IsFunctionObject
(
obj
)
)
{
JSFunction
*
fun
=
JS_GetObjectFunction
(
obj
)
;
JSString
*
str
=
JS_GetFunctionDisplayId
(
fun
)
;
if
(
str
)
{
JSFlatString
*
flat
=
JS_ASSERT_STRING_IS_FLAT
(
str
)
;
nsAutoString
chars
;
AssignJSFlatString
(
chars
flat
)
;
NS_ConvertUTF16toUTF8
fname
(
chars
)
;
snprintf_literal
(
name
"
JS
Object
(
Function
-
%
s
)
"
fname
.
get
(
)
)
;
}
else
{
snprintf_literal
(
name
"
JS
Object
(
Function
)
"
)
;
}
}
else
{
snprintf_literal
(
name
"
JS
Object
(
%
s
)
"
clasp
-
>
name
)
;
}
}
else
{
snprintf_literal
(
name
"
JS
%
s
"
JS
:
:
GCTraceKindToAscii
(
aThing
.
kind
(
)
)
)
;
}
aCb
.
DescribeGCedNode
(
aIsMarked
name
compartmentAddress
)
;
}
void
CycleCollectedJSRuntime
:
:
NoteGCThingJSChildren
(
JS
:
:
GCCellPtr
aThing
nsCycleCollectionTraversalCallback
&
aCb
)
const
{
MOZ_ASSERT
(
mJSRuntime
)
;
TraversalTracer
trc
(
mJSRuntime
aCb
)
;
JS
:
:
TraceChildren
(
&
trc
aThing
)
;
}
void
CycleCollectedJSRuntime
:
:
NoteGCThingXPCOMChildren
(
const
js
:
:
Class
*
aClasp
JSObject
*
aObj
nsCycleCollectionTraversalCallback
&
aCb
)
const
{
MOZ_ASSERT
(
aClasp
)
;
MOZ_ASSERT
(
aClasp
=
=
js
:
:
GetObjectClass
(
aObj
)
)
;
if
(
NoteCustomGCThingXPCOMChildren
(
aClasp
aObj
aCb
)
)
{
return
;
}
else
if
(
aClasp
-
>
flags
&
JSCLASS_HAS_PRIVATE
&
&
aClasp
-
>
flags
&
JSCLASS_PRIVATE_IS_NSISUPPORTS
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
js
:
:
GetObjectPrivate
(
obj
)
"
)
;
aCb
.
NoteXPCOMChild
(
static_cast
<
nsISupports
*
>
(
js
:
:
GetObjectPrivate
(
aObj
)
)
)
;
}
else
{
const
DOMJSClass
*
domClass
=
GetDOMClass
(
aObj
)
;
if
(
domClass
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
UnwrapDOMObject
(
obj
)
"
)
;
if
(
domClass
-
>
mDOMObjectIsISupports
)
{
aCb
.
NoteXPCOMChild
(
UnwrapPossiblyNotInitializedDOMObject
<
nsISupports
>
(
aObj
)
)
;
}
else
if
(
domClass
-
>
mParticipant
)
{
aCb
.
NoteNativeChild
(
UnwrapPossiblyNotInitializedDOMObject
<
void
>
(
aObj
)
domClass
-
>
mParticipant
)
;
}
}
}
}
void
CycleCollectedJSRuntime
:
:
TraverseGCThing
(
TraverseSelect
aTs
JS
:
:
GCCellPtr
aThing
nsCycleCollectionTraversalCallback
&
aCb
)
{
bool
isMarkedGray
=
JS
:
:
GCThingIsMarkedGray
(
aThing
)
;
if
(
aTs
=
=
TRAVERSE_FULL
)
{
DescribeGCThing
(
!
isMarkedGray
aThing
aCb
)
;
}
if
(
!
isMarkedGray
&
&
!
aCb
.
WantAllTraces
(
)
)
{
return
;
}
if
(
aTs
=
=
TRAVERSE_FULL
)
{
NoteGCThingJSChildren
(
aThing
aCb
)
;
}
if
(
aThing
.
is
<
JSObject
>
(
)
)
{
JSObject
*
obj
=
&
aThing
.
as
<
JSObject
>
(
)
;
NoteGCThingXPCOMChildren
(
js
:
:
GetObjectClass
(
obj
)
obj
aCb
)
;
}
}
struct
TraverseObjectShimClosure
{
nsCycleCollectionTraversalCallback
&
cb
;
CycleCollectedJSRuntime
*
self
;
}
;
void
CycleCollectedJSRuntime
:
:
TraverseZone
(
JS
:
:
Zone
*
aZone
nsCycleCollectionTraversalCallback
&
aCb
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
aCb
.
DescribeGCedNode
(
false
"
JS
Zone
"
)
;
TraversalTracer
trc
(
mJSRuntime
aCb
)
;
js
:
:
VisitGrayWrapperTargets
(
aZone
NoteJSChildGrayWrapperShim
&
trc
)
;
TraverseObjectShimClosure
closure
=
{
aCb
this
}
;
js
:
:
IterateGrayObjects
(
aZone
TraverseObjectShim
&
closure
)
;
}
void
CycleCollectedJSRuntime
:
:
TraverseObjectShim
(
void
*
aData
JS
:
:
GCCellPtr
aThing
)
{
TraverseObjectShimClosure
*
closure
=
static_cast
<
TraverseObjectShimClosure
*
>
(
aData
)
;
MOZ_ASSERT
(
aThing
.
is
<
JSObject
>
(
)
)
;
closure
-
>
self
-
>
TraverseGCThing
(
CycleCollectedJSRuntime
:
:
TRAVERSE_CPP
aThing
closure
-
>
cb
)
;
}
void
CycleCollectedJSRuntime
:
:
TraverseNativeRoots
(
nsCycleCollectionNoteRootCallback
&
aCb
)
{
TraverseAdditionalNativeRoots
(
aCb
)
;
for
(
auto
iter
=
mJSHolders
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
void
*
holder
=
iter
.
Key
(
)
;
nsScriptObjectTracer
*
&
tracer
=
iter
.
Data
(
)
;
bool
noteRoot
=
false
;
if
(
MOZ_UNLIKELY
(
aCb
.
WantAllTraces
(
)
)
)
{
noteRoot
=
true
;
}
else
{
tracer
-
>
Trace
(
holder
TraceCallbackFunc
(
CheckParticipatesInCycleCollection
)
&
noteRoot
)
;
}
if
(
noteRoot
)
{
aCb
.
NoteNativeRoot
(
holder
tracer
)
;
}
}
}
void
CycleCollectedJSRuntime
:
:
TraceBlackJS
(
JSTracer
*
aTracer
void
*
aData
)
{
CycleCollectedJSRuntime
*
self
=
static_cast
<
CycleCollectedJSRuntime
*
>
(
aData
)
;
self
-
>
TraceNativeBlackRoots
(
aTracer
)
;
}
void
CycleCollectedJSRuntime
:
:
TraceGrayJS
(
JSTracer
*
aTracer
void
*
aData
)
{
CycleCollectedJSRuntime
*
self
=
static_cast
<
CycleCollectedJSRuntime
*
>
(
aData
)
;
self
-
>
TraceNativeGrayRoots
(
aTracer
)
;
}
void
CycleCollectedJSRuntime
:
:
GCCallback
(
JSRuntime
*
aRuntime
JSGCStatus
aStatus
void
*
aData
)
{
CycleCollectedJSRuntime
*
self
=
static_cast
<
CycleCollectedJSRuntime
*
>
(
aData
)
;
MOZ_ASSERT
(
aRuntime
=
=
self
-
>
Runtime
(
)
)
;
self
-
>
OnGC
(
aStatus
)
;
}
void
CycleCollectedJSRuntime
:
:
GCSliceCallback
(
JSRuntime
*
aRuntime
JS
:
:
GCProgress
aProgress
const
JS
:
:
GCDescription
&
aDesc
)
{
CycleCollectedJSRuntime
*
self
=
CycleCollectedJSRuntime
:
:
Get
(
)
;
MOZ_ASSERT
(
self
-
>
Runtime
(
)
=
=
aRuntime
)
;
if
(
aProgress
=
=
JS
:
:
GC_CYCLE_END
)
{
JS
:
:
gcreason
:
:
Reason
reason
=
aDesc
.
reason_
;
NS_WARN_IF
(
NS_FAILED
(
DebuggerOnGCRunnable
:
:
Enqueue
(
aRuntime
aDesc
)
)
&
&
reason
!
=
JS
:
:
gcreason
:
:
SHUTDOWN_CC
&
&
reason
!
=
JS
:
:
gcreason
:
:
DESTROY_RUNTIME
&
&
reason
!
=
JS
:
:
gcreason
:
:
XPCONNECT_SHUTDOWN
)
;
}
if
(
self
-
>
mPrevGCSliceCallback
)
{
self
-
>
mPrevGCSliceCallback
(
aRuntime
aProgress
aDesc
)
;
}
}
class
MinorGCMarker
:
public
TimelineMarker
{
private
:
JS
:
:
gcreason
:
:
Reason
mReason
;
public
:
MinorGCMarker
(
MarkerTracingType
aTracingType
JS
:
:
gcreason
:
:
Reason
aReason
)
:
TimelineMarker
(
"
MinorGC
"
aTracingType
MarkerStackRequest
:
:
NO_STACK
)
mReason
(
aReason
)
{
MOZ_ASSERT
(
aTracingType
=
=
MarkerTracingType
:
:
START
|
|
aTracingType
=
=
MarkerTracingType
:
:
END
)
;
}
MinorGCMarker
(
JS
:
:
GCNurseryProgress
aProgress
JS
:
:
gcreason
:
:
Reason
aReason
)
:
TimelineMarker
(
"
MinorGC
"
aProgress
=
=
JS
:
:
GCNurseryProgress
:
:
GC_NURSERY_COLLECTION_START
?
MarkerTracingType
:
:
START
:
MarkerTracingType
:
:
END
MarkerStackRequest
:
:
NO_STACK
)
mReason
(
aReason
)
{
}
virtual
void
AddDetails
(
JSContext
*
aCx
dom
:
:
ProfileTimelineMarker
&
aMarker
)
override
{
TimelineMarker
:
:
AddDetails
(
aCx
aMarker
)
;
if
(
GetTracingType
(
)
=
=
MarkerTracingType
:
:
START
)
{
auto
reason
=
JS
:
:
gcreason
:
:
ExplainReason
(
mReason
)
;
aMarker
.
mCauseName
.
Construct
(
NS_ConvertUTF8toUTF16
(
reason
)
)
;
}
}
virtual
UniquePtr
<
AbstractTimelineMarker
>
Clone
(
)
override
{
auto
clone
=
MakeUnique
<
MinorGCMarker
>
(
GetTracingType
(
)
mReason
)
;
clone
-
>
SetCustomTime
(
GetTime
(
)
)
;
return
UniquePtr
<
AbstractTimelineMarker
>
(
Move
(
clone
)
)
;
}
}
;
void
CycleCollectedJSRuntime
:
:
GCNurseryCollectionCallback
(
JSRuntime
*
aRuntime
JS
:
:
GCNurseryProgress
aProgress
JS
:
:
gcreason
:
:
Reason
aReason
)
{
CycleCollectedJSRuntime
*
self
=
CycleCollectedJSRuntime
:
:
Get
(
)
;
MOZ_ASSERT
(
self
-
>
Runtime
(
)
=
=
aRuntime
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
if
(
timelines
&
&
!
timelines
-
>
IsEmpty
(
)
)
{
UniquePtr
<
AbstractTimelineMarker
>
abstractMarker
(
MakeUnique
<
MinorGCMarker
>
(
aProgress
aReason
)
)
;
timelines
-
>
AddMarkerForAllObservedDocShells
(
abstractMarker
)
;
}
if
(
self
-
>
mPrevGCNurseryCollectionCallback
)
{
self
-
>
mPrevGCNurseryCollectionCallback
(
aRuntime
aProgress
aReason
)
;
}
}
void
CycleCollectedJSRuntime
:
:
OutOfMemoryCallback
(
JSContext
*
aContext
void
*
aData
)
{
CycleCollectedJSRuntime
*
self
=
static_cast
<
CycleCollectedJSRuntime
*
>
(
aData
)
;
MOZ_ASSERT
(
JS_GetRuntime
(
aContext
)
=
=
self
-
>
Runtime
(
)
)
;
self
-
>
OnOutOfMemory
(
)
;
}
void
CycleCollectedJSRuntime
:
:
LargeAllocationFailureCallback
(
void
*
aData
)
{
CycleCollectedJSRuntime
*
self
=
static_cast
<
CycleCollectedJSRuntime
*
>
(
aData
)
;
self
-
>
OnLargeAllocationFailure
(
)
;
}
class
PromiseJobRunnable
final
:
public
Runnable
{
public
:
PromiseJobRunnable
(
JS
:
:
HandleObject
aCallback
JS
:
:
HandleObject
aAllocationSite
nsIGlobalObject
*
aIncumbentGlobal
)
:
mCallback
(
new
PromiseJobCallback
(
aCallback
aAllocationSite
aIncumbentGlobal
)
)
{
}
virtual
~
PromiseJobRunnable
(
)
{
}
protected
:
NS_IMETHOD
Run
(
)
override
{
nsIGlobalObject
*
global
=
xpc
:
:
NativeGlobal
(
mCallback
-
>
CallbackPreserveColor
(
)
)
;
if
(
global
&
&
!
global
-
>
IsDying
(
)
)
{
mCallback
-
>
Call
(
"
promise
callback
"
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
PromiseJobCallback
>
mCallback
;
}
;
JSObject
*
CycleCollectedJSRuntime
:
:
GetIncumbentGlobalCallback
(
JSContext
*
aCx
)
{
nsIGlobalObject
*
global
=
mozilla
:
:
dom
:
:
GetIncumbentGlobal
(
)
;
if
(
global
)
{
return
global
-
>
GetGlobalJSObject
(
)
;
}
return
nullptr
;
}
bool
CycleCollectedJSRuntime
:
:
EnqueuePromiseJobCallback
(
JSContext
*
aCx
JS
:
:
HandleObject
aJob
JS
:
:
HandleObject
aAllocationSite
JS
:
:
HandleObject
aIncumbentGlobal
void
*
aData
)
{
CycleCollectedJSRuntime
*
self
=
static_cast
<
CycleCollectedJSRuntime
*
>
(
aData
)
;
MOZ_ASSERT
(
JS_GetRuntime
(
aCx
)
=
=
self
-
>
Runtime
(
)
)
;
MOZ_ASSERT
(
Get
(
)
=
=
self
)
;
nsIGlobalObject
*
global
=
nullptr
;
if
(
aIncumbentGlobal
)
{
global
=
xpc
:
:
NativeGlobal
(
aIncumbentGlobal
)
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
PromiseJobRunnable
(
aJob
aAllocationSite
global
)
;
self
-
>
DispatchToMicroTask
(
runnable
)
;
return
true
;
}
#
ifdef
SPIDERMONKEY_PROMISE
void
CycleCollectedJSRuntime
:
:
PromiseRejectionTrackerCallback
(
JSContext
*
aCx
JS
:
:
HandleObject
aPromise
PromiseRejectionHandlingState
state
void
*
aData
)
{
#
ifdef
DEBUG
CycleCollectedJSRuntime
*
self
=
static_cast
<
CycleCollectedJSRuntime
*
>
(
aData
)
;
#
endif
MOZ_ASSERT
(
JS_GetRuntime
(
aCx
)
=
=
self
-
>
Runtime
(
)
)
;
MOZ_ASSERT
(
Get
(
)
=
=
self
)
;
if
(
state
=
=
PromiseRejectionHandlingState
:
:
Unhandled
)
{
PromiseDebugging
:
:
AddUncaughtRejection
(
aPromise
)
;
}
else
{
PromiseDebugging
:
:
AddConsumedRejection
(
aPromise
)
;
}
}
#
endif
struct
JsGcTracer
:
public
TraceCallbacks
{
virtual
void
Trace
(
JS
:
:
Heap
<
JS
:
:
Value
>
*
aPtr
const
char
*
aName
void
*
aClosure
)
const
override
{
JS
:
:
TraceEdge
(
static_cast
<
JSTracer
*
>
(
aClosure
)
aPtr
aName
)
;
}
virtual
void
Trace
(
JS
:
:
Heap
<
jsid
>
*
aPtr
const
char
*
aName
void
*
aClosure
)
const
override
{
JS
:
:
TraceEdge
(
static_cast
<
JSTracer
*
>
(
aClosure
)
aPtr
aName
)
;
}
virtual
void
Trace
(
JS
:
:
Heap
<
JSObject
*
>
*
aPtr
const
char
*
aName
void
*
aClosure
)
const
override
{
JS
:
:
TraceEdge
(
static_cast
<
JSTracer
*
>
(
aClosure
)
aPtr
aName
)
;
}
virtual
void
Trace
(
JSObject
*
*
aPtr
const
char
*
aName
void
*
aClosure
)
const
override
{
js
:
:
UnsafeTraceManuallyBarrieredEdge
(
static_cast
<
JSTracer
*
>
(
aClosure
)
aPtr
aName
)
;
}
virtual
void
Trace
(
JS
:
:
TenuredHeap
<
JSObject
*
>
*
aPtr
const
char
*
aName
void
*
aClosure
)
const
override
{
JS
:
:
TraceEdge
(
static_cast
<
JSTracer
*
>
(
aClosure
)
aPtr
aName
)
;
}
virtual
void
Trace
(
JS
:
:
Heap
<
JSString
*
>
*
aPtr
const
char
*
aName
void
*
aClosure
)
const
override
{
JS
:
:
TraceEdge
(
static_cast
<
JSTracer
*
>
(
aClosure
)
aPtr
aName
)
;
}
virtual
void
Trace
(
JS
:
:
Heap
<
JSScript
*
>
*
aPtr
const
char
*
aName
void
*
aClosure
)
const
override
{
JS
:
:
TraceEdge
(
static_cast
<
JSTracer
*
>
(
aClosure
)
aPtr
aName
)
;
}
virtual
void
Trace
(
JS
:
:
Heap
<
JSFunction
*
>
*
aPtr
const
char
*
aName
void
*
aClosure
)
const
override
{
JS
:
:
TraceEdge
(
static_cast
<
JSTracer
*
>
(
aClosure
)
aPtr
aName
)
;
}
}
;
void
mozilla
:
:
TraceScriptHolder
(
nsISupports
*
aHolder
JSTracer
*
aTracer
)
{
nsXPCOMCycleCollectionParticipant
*
participant
=
nullptr
;
CallQueryInterface
(
aHolder
&
participant
)
;
participant
-
>
Trace
(
aHolder
JsGcTracer
(
)
aTracer
)
;
}
void
CycleCollectedJSRuntime
:
:
TraceNativeGrayRoots
(
JSTracer
*
aTracer
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
TraceAdditionalNativeGrayRoots
(
aTracer
)
;
for
(
auto
iter
=
mJSHolders
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
void
*
holder
=
iter
.
Key
(
)
;
nsScriptObjectTracer
*
&
tracer
=
iter
.
Data
(
)
;
tracer
-
>
Trace
(
holder
JsGcTracer
(
)
aTracer
)
;
}
}
void
CycleCollectedJSRuntime
:
:
AddJSHolder
(
void
*
aHolder
nsScriptObjectTracer
*
aTracer
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
mJSHolders
.
Put
(
aHolder
aTracer
)
;
}
struct
ClearJSHolder
:
public
TraceCallbacks
{
virtual
void
Trace
(
JS
:
:
Heap
<
JS
:
:
Value
>
*
aPtr
const
char
*
void
*
)
const
override
{
aPtr
-
>
setUndefined
(
)
;
}
virtual
void
Trace
(
JS
:
:
Heap
<
jsid
>
*
aPtr
const
char
*
void
*
)
const
override
{
*
aPtr
=
JSID_VOID
;
}
virtual
void
Trace
(
JS
:
:
Heap
<
JSObject
*
>
*
aPtr
const
char
*
void
*
)
const
override
{
*
aPtr
=
nullptr
;
}
virtual
void
Trace
(
JSObject
*
*
aPtr
const
char
*
aName
void
*
aClosure
)
const
override
{
*
aPtr
=
nullptr
;
}
virtual
void
Trace
(
JS
:
:
TenuredHeap
<
JSObject
*
>
*
aPtr
const
char
*
void
*
)
const
override
{
*
aPtr
=
nullptr
;
}
virtual
void
Trace
(
JS
:
:
Heap
<
JSString
*
>
*
aPtr
const
char
*
void
*
)
const
override
{
*
aPtr
=
nullptr
;
}
virtual
void
Trace
(
JS
:
:
Heap
<
JSScript
*
>
*
aPtr
const
char
*
void
*
)
const
override
{
*
aPtr
=
nullptr
;
}
virtual
void
Trace
(
JS
:
:
Heap
<
JSFunction
*
>
*
aPtr
const
char
*
void
*
)
const
override
{
*
aPtr
=
nullptr
;
}
}
;
void
CycleCollectedJSRuntime
:
:
RemoveJSHolder
(
void
*
aHolder
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
nsScriptObjectTracer
*
tracer
=
mJSHolders
.
Get
(
aHolder
)
;
if
(
!
tracer
)
{
return
;
}
tracer
-
>
Trace
(
aHolder
ClearJSHolder
(
)
nullptr
)
;
mJSHolders
.
Remove
(
aHolder
)
;
}
#
ifdef
DEBUG
bool
CycleCollectedJSRuntime
:
:
IsJSHolder
(
void
*
aHolder
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
return
mJSHolders
.
Get
(
aHolder
nullptr
)
;
}
static
void
AssertNoGcThing
(
JS
:
:
GCCellPtr
aGCThing
const
char
*
aName
void
*
aClosure
)
{
MOZ_ASSERT
(
!
aGCThing
)
;
}
void
CycleCollectedJSRuntime
:
:
AssertNoObjectsToTrace
(
void
*
aPossibleJSHolder
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
nsScriptObjectTracer
*
tracer
=
mJSHolders
.
Get
(
aPossibleJSHolder
)
;
if
(
tracer
)
{
tracer
-
>
Trace
(
aPossibleJSHolder
TraceCallbackFunc
(
AssertNoGcThing
)
nullptr
)
;
}
}
#
endif
already_AddRefed
<
nsIException
>
CycleCollectedJSRuntime
:
:
GetPendingException
(
)
const
{
MOZ_ASSERT
(
mJSRuntime
)
;
nsCOMPtr
<
nsIException
>
out
=
mPendingException
;
return
out
.
forget
(
)
;
}
void
CycleCollectedJSRuntime
:
:
SetPendingException
(
nsIException
*
aException
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
mPendingException
=
aException
;
}
std
:
:
queue
<
nsCOMPtr
<
nsIRunnable
>
>
&
CycleCollectedJSRuntime
:
:
GetPromiseMicroTaskQueue
(
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
return
mPromiseMicroTaskQueue
;
}
std
:
:
queue
<
nsCOMPtr
<
nsIRunnable
>
>
&
CycleCollectedJSRuntime
:
:
GetDebuggerPromiseMicroTaskQueue
(
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
return
mDebuggerPromiseMicroTaskQueue
;
}
nsCycleCollectionParticipant
*
CycleCollectedJSRuntime
:
:
GCThingParticipant
(
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
return
&
mGCThingCycleCollectorGlobal
;
}
nsCycleCollectionParticipant
*
CycleCollectedJSRuntime
:
:
ZoneParticipant
(
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
return
&
mJSZoneCycleCollectorGlobal
;
}
nsresult
CycleCollectedJSRuntime
:
:
TraverseRoots
(
nsCycleCollectionNoteRootCallback
&
aCb
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
TraverseNativeRoots
(
aCb
)
;
NoteWeakMapsTracer
trc
(
mJSRuntime
aCb
)
;
js
:
:
TraceWeakMaps
(
&
trc
)
;
return
NS_OK
;
}
bool
CycleCollectedJSRuntime
:
:
UsefulToMergeZones
(
)
const
{
return
false
;
}
void
CycleCollectedJSRuntime
:
:
FixWeakMappingGrayBits
(
)
const
{
MOZ_ASSERT
(
mJSRuntime
)
;
MOZ_ASSERT
(
!
JS
:
:
IsIncrementalGCInProgress
(
mJSRuntime
)
"
Don
'
t
call
FixWeakMappingGrayBits
during
a
GC
.
"
)
;
FixWeakMappingGrayBitsTracer
fixer
(
mJSRuntime
)
;
fixer
.
FixAll
(
)
;
}
bool
CycleCollectedJSRuntime
:
:
AreGCGrayBitsValid
(
)
const
{
MOZ_ASSERT
(
mJSRuntime
)
;
return
js
:
:
AreGCGrayBitsValid
(
mJSRuntime
)
;
}
void
CycleCollectedJSRuntime
:
:
GarbageCollect
(
uint32_t
aReason
)
const
{
MOZ_ASSERT
(
mJSRuntime
)
;
MOZ_ASSERT
(
aReason
<
JS
:
:
gcreason
:
:
NUM_REASONS
)
;
JS
:
:
gcreason
:
:
Reason
gcreason
=
static_cast
<
JS
:
:
gcreason
:
:
Reason
>
(
aReason
)
;
JS
:
:
PrepareForFullGC
(
mJSRuntime
)
;
JS
:
:
GCForReason
(
mJSRuntime
GC_NORMAL
gcreason
)
;
}
void
CycleCollectedJSRuntime
:
:
JSObjectsTenured
(
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
for
(
auto
iter
=
mNurseryObjects
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsWrapperCache
*
cache
=
iter
.
Get
(
)
;
JSObject
*
wrapper
=
cache
-
>
GetWrapperPreserveColor
(
)
;
MOZ_ASSERT
(
wrapper
)
;
if
(
!
JS
:
:
ObjectIsTenured
(
wrapper
)
)
{
MOZ_ASSERT
(
!
cache
-
>
PreservingWrapper
(
)
)
;
const
JSClass
*
jsClass
=
js
:
:
GetObjectJSClass
(
wrapper
)
;
jsClass
-
>
doFinalize
(
nullptr
wrapper
)
;
}
}
#
ifdef
DEBUG
for
(
auto
iter
=
mPreservedNurseryObjects
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
MOZ_ASSERT
(
JS
:
:
ObjectIsTenured
(
iter
.
Get
(
)
.
get
(
)
)
)
;
}
#
endif
mNurseryObjects
.
Clear
(
)
;
mPreservedNurseryObjects
.
Clear
(
)
;
}
void
CycleCollectedJSRuntime
:
:
NurseryWrapperAdded
(
nsWrapperCache
*
aCache
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
MOZ_ASSERT
(
aCache
)
;
MOZ_ASSERT
(
aCache
-
>
GetWrapperPreserveColor
(
)
)
;
MOZ_ASSERT
(
!
JS
:
:
ObjectIsTenured
(
aCache
-
>
GetWrapperPreserveColor
(
)
)
)
;
mNurseryObjects
.
InfallibleAppend
(
aCache
)
;
}
void
CycleCollectedJSRuntime
:
:
NurseryWrapperPreserved
(
JSObject
*
aWrapper
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
mPreservedNurseryObjects
.
InfallibleAppend
(
JS
:
:
PersistentRooted
<
JSObject
*
>
(
mJSRuntime
aWrapper
)
)
;
}
void
CycleCollectedJSRuntime
:
:
DeferredFinalize
(
DeferredFinalizeAppendFunction
aAppendFunc
DeferredFinalizeFunction
aFunc
void
*
aThing
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
void
*
thingArray
=
nullptr
;
bool
hadThingArray
=
mDeferredFinalizerTable
.
Get
(
aFunc
&
thingArray
)
;
thingArray
=
aAppendFunc
(
thingArray
aThing
)
;
if
(
!
hadThingArray
)
{
mDeferredFinalizerTable
.
Put
(
aFunc
thingArray
)
;
}
}
void
CycleCollectedJSRuntime
:
:
DeferredFinalize
(
nsISupports
*
aSupports
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
typedef
DeferredFinalizerImpl
<
nsISupports
>
Impl
;
DeferredFinalize
(
Impl
:
:
AppendDeferredFinalizePointer
Impl
:
:
DeferredFinalize
aSupports
)
;
}
void
CycleCollectedJSRuntime
:
:
DumpJSHeap
(
FILE
*
aFile
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
js
:
:
DumpHeap
(
Runtime
(
)
aFile
js
:
:
CollectNurseryBeforeDump
)
;
}
void
CycleCollectedJSRuntime
:
:
ProcessStableStateQueue
(
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
MOZ_RELEASE_ASSERT
(
!
mDoingStableStates
)
;
mDoingStableStates
=
true
;
for
(
uint32_t
i
=
0
;
i
<
mStableStateEvents
.
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mStableStateEvents
[
i
]
.
forget
(
)
;
event
-
>
Run
(
)
;
}
mStableStateEvents
.
Clear
(
)
;
mDoingStableStates
=
false
;
}
void
CycleCollectedJSRuntime
:
:
ProcessMetastableStateQueue
(
uint32_t
aRecursionDepth
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
MOZ_RELEASE_ASSERT
(
!
mDoingStableStates
)
;
mDoingStableStates
=
true
;
nsTArray
<
RunInMetastableStateData
>
localQueue
=
Move
(
mMetastableStateEvents
)
;
for
(
uint32_t
i
=
0
;
i
<
localQueue
.
Length
(
)
;
+
+
i
)
{
RunInMetastableStateData
&
data
=
localQueue
[
i
]
;
if
(
data
.
mRecursionDepth
!
=
aRecursionDepth
)
{
continue
;
}
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
data
.
mRunnable
.
forget
(
)
;
runnable
-
>
Run
(
)
;
}
localQueue
.
RemoveElementAt
(
i
-
-
)
;
}
localQueue
.
AppendElements
(
mMetastableStateEvents
)
;
localQueue
.
SwapElements
(
mMetastableStateEvents
)
;
mDoingStableStates
=
false
;
}
void
CycleCollectedJSRuntime
:
:
AfterProcessTask
(
uint32_t
aRecursionDepth
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
ProcessMetastableStateQueue
(
aRecursionDepth
)
;
if
(
NS_IsMainThread
(
)
)
{
nsContentUtils
:
:
PerformMainThreadMicroTaskCheckpoint
(
)
;
Promise
:
:
PerformMicroTaskCheckpoint
(
)
;
}
else
{
Promise
:
:
PerformWorkerMicroTaskCheckpoint
(
)
;
}
ProcessStableStateQueue
(
)
;
}
void
CycleCollectedJSRuntime
:
:
AfterProcessMicrotask
(
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
AfterProcessMicrotask
(
RecursionDepth
(
)
)
;
}
void
CycleCollectedJSRuntime
:
:
AfterProcessMicrotask
(
uint32_t
aRecursionDepth
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
ProcessMetastableStateQueue
(
aRecursionDepth
)
;
}
uint32_t
CycleCollectedJSRuntime
:
:
RecursionDepth
(
)
{
return
mOwningThread
-
>
RecursionDepth
(
)
;
}
void
CycleCollectedJSRuntime
:
:
RunInStableState
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
mStableStateEvents
.
AppendElement
(
Move
(
aRunnable
)
)
;
}
void
CycleCollectedJSRuntime
:
:
RunInMetastableState
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
RunInMetastableStateData
data
;
data
.
mRunnable
=
aRunnable
;
MOZ_ASSERT
(
mOwningThread
)
;
data
.
mRecursionDepth
=
RecursionDepth
(
)
;
#
ifndef
MOZ_WIDGET_COCOA
MOZ_ASSERT
(
data
.
mRecursionDepth
>
mBaseRecursionDepth
)
;
#
else
if
(
data
.
mRecursionDepth
<
=
mBaseRecursionDepth
)
{
data
.
mRecursionDepth
=
mBaseRecursionDepth
+
1
;
}
#
endif
mMetastableStateEvents
.
AppendElement
(
Move
(
data
)
)
;
}
IncrementalFinalizeRunnable
:
:
IncrementalFinalizeRunnable
(
CycleCollectedJSRuntime
*
aRt
DeferredFinalizerTable
&
aFinalizers
)
:
mRuntime
(
aRt
)
mFinalizeFunctionToRun
(
0
)
mReleasing
(
false
)
{
for
(
auto
iter
=
aFinalizers
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
DeferredFinalizeFunction
&
function
=
iter
.
Key
(
)
;
void
*
&
data
=
iter
.
Data
(
)
;
DeferredFinalizeFunctionHolder
*
holder
=
mDeferredFinalizeFunctions
.
AppendElement
(
)
;
holder
-
>
run
=
function
;
holder
-
>
data
=
data
;
iter
.
Remove
(
)
;
}
}
IncrementalFinalizeRunnable
:
:
~
IncrementalFinalizeRunnable
(
)
{
MOZ_ASSERT
(
this
!
=
mRuntime
-
>
mFinalizeRunnable
)
;
}
void
IncrementalFinalizeRunnable
:
:
ReleaseNow
(
bool
aLimited
)
{
if
(
mReleasing
)
{
NS_WARNING
(
"
Re
-
entering
ReleaseNow
"
)
;
return
;
}
{
mozilla
:
:
AutoRestore
<
bool
>
ar
(
mReleasing
)
;
mReleasing
=
true
;
MOZ_ASSERT
(
mDeferredFinalizeFunctions
.
Length
(
)
!
=
0
"
We
should
have
at
least
ReleaseSliceNow
to
run
"
)
;
MOZ_ASSERT
(
mFinalizeFunctionToRun
<
mDeferredFinalizeFunctions
.
Length
(
)
"
No
more
finalizers
to
run
?
"
)
;
TimeDuration
sliceTime
=
TimeDuration
:
:
FromMilliseconds
(
SliceMillis
)
;
TimeStamp
started
=
TimeStamp
:
:
Now
(
)
;
bool
timeout
=
false
;
do
{
const
DeferredFinalizeFunctionHolder
&
function
=
mDeferredFinalizeFunctions
[
mFinalizeFunctionToRun
]
;
if
(
aLimited
)
{
bool
done
=
false
;
while
(
!
timeout
&
&
!
done
)
{
done
=
function
.
run
(
100
function
.
data
)
;
timeout
=
TimeStamp
:
:
Now
(
)
-
started
>
=
sliceTime
;
}
if
(
done
)
{
+
+
mFinalizeFunctionToRun
;
}
if
(
timeout
)
{
break
;
}
}
else
{
while
(
!
function
.
run
(
UINT32_MAX
function
.
data
)
)
;
+
+
mFinalizeFunctionToRun
;
}
}
while
(
mFinalizeFunctionToRun
<
mDeferredFinalizeFunctions
.
Length
(
)
)
;
}
if
(
mFinalizeFunctionToRun
=
=
mDeferredFinalizeFunctions
.
Length
(
)
)
{
MOZ_ASSERT
(
mRuntime
-
>
mFinalizeRunnable
=
=
this
)
;
mDeferredFinalizeFunctions
.
Clear
(
)
;
mRuntime
-
>
mFinalizeRunnable
=
nullptr
;
}
}
NS_IMETHODIMP
IncrementalFinalizeRunnable
:
:
Run
(
)
{
if
(
mRuntime
-
>
mFinalizeRunnable
!
=
this
)
{
MOZ_ASSERT
(
!
mDeferredFinalizeFunctions
.
Length
(
)
)
;
return
NS_OK
;
}
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
ReleaseNow
(
true
)
;
if
(
mDeferredFinalizeFunctions
.
Length
(
)
)
{
nsresult
rv
=
NS_DispatchToCurrentThread
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReleaseNow
(
false
)
;
}
}
uint32_t
duration
=
(
uint32_t
)
(
(
TimeStamp
:
:
Now
(
)
-
start
)
.
ToMilliseconds
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
DEFERRED_FINALIZE_ASYNC
duration
)
;
return
NS_OK
;
}
void
CycleCollectedJSRuntime
:
:
FinalizeDeferredThings
(
DeferredFinalizeType
aType
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
if
(
mFinalizeRunnable
)
{
mFinalizeRunnable
-
>
ReleaseNow
(
false
)
;
if
(
mFinalizeRunnable
)
{
return
;
}
}
if
(
mDeferredFinalizerTable
.
Count
(
)
=
=
0
)
{
return
;
}
mFinalizeRunnable
=
new
IncrementalFinalizeRunnable
(
this
mDeferredFinalizerTable
)
;
MOZ_ASSERT
(
mDeferredFinalizerTable
.
Count
(
)
=
=
0
)
;
if
(
aType
=
=
FinalizeIncrementally
)
{
NS_DispatchToCurrentThread
(
mFinalizeRunnable
)
;
}
else
{
mFinalizeRunnable
-
>
ReleaseNow
(
false
)
;
MOZ_ASSERT
(
!
mFinalizeRunnable
)
;
}
}
void
CycleCollectedJSRuntime
:
:
AnnotateAndSetOutOfMemory
(
OOMState
*
aStatePtr
OOMState
aNewState
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
*
aStatePtr
=
aNewState
;
#
ifdef
MOZ_CRASHREPORTER
CrashReporter
:
:
AnnotateCrashReport
(
aStatePtr
=
=
&
mOutOfMemoryState
?
NS_LITERAL_CSTRING
(
"
JSOutOfMemory
"
)
:
NS_LITERAL_CSTRING
(
"
JSLargeAllocationFailure
"
)
aNewState
=
=
OOMState
:
:
Reporting
?
NS_LITERAL_CSTRING
(
"
Reporting
"
)
:
aNewState
=
=
OOMState
:
:
Reported
?
NS_LITERAL_CSTRING
(
"
Reported
"
)
:
NS_LITERAL_CSTRING
(
"
Recovered
"
)
)
;
#
endif
}
void
CycleCollectedJSRuntime
:
:
OnGC
(
JSGCStatus
aStatus
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
switch
(
aStatus
)
{
case
JSGC_BEGIN
:
nsCycleCollector_prepareForGarbageCollection
(
)
;
mZonesWaitingForGC
.
Clear
(
)
;
break
;
case
JSGC_END
:
{
#
ifdef
MOZ_CRASHREPORTER
if
(
mOutOfMemoryState
=
=
OOMState
:
:
Reported
)
{
AnnotateAndSetOutOfMemory
(
&
mOutOfMemoryState
OOMState
:
:
Recovered
)
;
}
if
(
mLargeAllocationFailureState
=
=
OOMState
:
:
Reported
)
{
AnnotateAndSetOutOfMemory
(
&
mLargeAllocationFailureState
OOMState
:
:
Recovered
)
;
}
#
endif
FinalizeDeferredThings
(
JS
:
:
WasIncrementalGC
(
mJSRuntime
)
?
FinalizeIncrementally
:
FinalizeNow
)
;
break
;
}
default
:
MOZ_CRASH
(
)
;
}
CustomGCCallback
(
aStatus
)
;
}
void
CycleCollectedJSRuntime
:
:
OnOutOfMemory
(
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
AnnotateAndSetOutOfMemory
(
&
mOutOfMemoryState
OOMState
:
:
Reporting
)
;
CustomOutOfMemoryCallback
(
)
;
AnnotateAndSetOutOfMemory
(
&
mOutOfMemoryState
OOMState
:
:
Reported
)
;
}
void
CycleCollectedJSRuntime
:
:
OnLargeAllocationFailure
(
)
{
MOZ_ASSERT
(
mJSRuntime
)
;
AnnotateAndSetOutOfMemory
(
&
mLargeAllocationFailureState
OOMState
:
:
Reporting
)
;
CustomLargeAllocationFailureCallback
(
)
;
AnnotateAndSetOutOfMemory
(
&
mLargeAllocationFailureState
OOMState
:
:
Reported
)
;
}
void
CycleCollectedJSRuntime
:
:
PrepareWaitingZonesForGC
(
)
{
if
(
mZonesWaitingForGC
.
Count
(
)
=
=
0
)
{
JS
:
:
PrepareForFullGC
(
Runtime
(
)
)
;
}
else
{
for
(
auto
iter
=
mZonesWaitingForGC
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
JS
:
:
PrepareZoneForGC
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
}
mZonesWaitingForGC
.
Clear
(
)
;
}
}
void
CycleCollectedJSRuntime
:
:
DispatchToMicroTask
(
nsIRunnable
*
aRunnable
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aRunnable
)
;
mPromiseMicroTaskQueue
.
push
(
aRunnable
)
;
}
void
CycleCollectedJSRuntime
:
:
EnvironmentPreparer
:
:
invoke
(
JS
:
:
HandleObject
scope
js
:
:
ScriptEnvironmentPreparer
:
:
Closure
&
closure
)
{
nsIGlobalObject
*
global
=
xpc
:
:
NativeGlobal
(
scope
)
;
NS_ENSURE_TRUE_VOID
(
global
&
&
global
-
>
GetGlobalJSObject
(
)
)
;
bool
mainThread
=
NS_IsMainThread
(
)
;
JSContext
*
cx
=
mainThread
?
nullptr
:
nsContentUtils
:
:
GetDefaultJSContextForThread
(
)
;
AutoEntryScript
aes
(
global
"
JS
-
engine
-
initiated
execution
"
mainThread
cx
)
;
MOZ_ASSERT
(
!
JS_IsExceptionPending
(
aes
.
cx
(
)
)
)
;
DebugOnly
<
bool
>
ok
=
closure
(
aes
.
cx
(
)
)
;
MOZ_ASSERT_IF
(
ok
!
JS_IsExceptionPending
(
aes
.
cx
(
)
)
)
;
}
