#
include
"
AvailableMemoryWatcher
.
h
"
#
include
"
AvailableMemoryWatcherUtils
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsMemoryPressure
.
h
"
namespace
mozilla
{
class
nsAvailableMemoryWatcher
final
:
public
nsITimerCallback
public
nsINamed
public
nsAvailableMemoryWatcherBase
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSIOBSERVER
NS_DECL_NSINAMED
nsresult
Init
(
)
override
;
nsAvailableMemoryWatcher
(
)
;
void
HandleLowMemory
(
)
;
void
MaybeHandleHighMemory
(
)
;
private
:
~
nsAvailableMemoryWatcher
(
)
=
default
;
void
StartPolling
(
const
MutexAutoLock
&
)
;
void
StopPolling
(
const
MutexAutoLock
&
)
;
void
ShutDown
(
const
MutexAutoLock
&
)
;
void
UpdateCrashAnnotation
(
const
MutexAutoLock
&
)
;
static
bool
IsMemoryLow
(
)
;
nsCOMPtr
<
nsITimer
>
mTimer
MOZ_GUARDED_BY
(
mMutex
)
;
nsCOMPtr
<
nsIThread
>
mThread
MOZ_GUARDED_BY
(
mMutex
)
;
bool
mPolling
MOZ_GUARDED_BY
(
mMutex
)
;
bool
mUnderMemoryPressure
MOZ_GUARDED_BY
(
mMutex
)
;
Mutex
mMutex
;
static
const
uint32_t
kHighMemoryPollingIntervalMS
=
5000
;
static
const
uint32_t
kLowMemoryPollingIntervalMS
=
1000
;
}
;
static
const
char
*
kMeminfoPath
=
"
/
proc
/
meminfo
"
;
nsAvailableMemoryWatcher
:
:
nsAvailableMemoryWatcher
(
)
:
mPolling
(
false
)
mUnderMemoryPressure
(
false
)
mMutex
(
"
Memory
Poller
mutex
"
)
{
}
nsresult
nsAvailableMemoryWatcher
:
:
Init
(
)
{
nsresult
rv
=
nsAvailableMemoryWatcherBase
:
:
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MutexAutoLock
lock
(
mMutex
)
;
mTimer
=
NS_NewTimer
(
)
;
nsCOMPtr
<
nsIThread
>
thread
;
rv
=
NS_NewNamedThread
(
"
MemoryPoller
"
getter_AddRefs
(
thread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Couldn
'
t
make
a
thread
for
nsAvailableMemoryWatcher
.
"
)
;
return
rv
;
}
mThread
=
thread
;
UpdateCrashAnnotation
(
lock
)
;
StartPolling
(
lock
)
;
return
NS_OK
;
}
already_AddRefed
<
nsAvailableMemoryWatcherBase
>
CreateAvailableMemoryWatcher
(
)
{
RefPtr
watcher
(
new
nsAvailableMemoryWatcher
)
;
if
(
NS_FAILED
(
watcher
-
>
Init
(
)
)
)
{
return
do_AddRef
(
new
nsAvailableMemoryWatcherBase
)
;
}
return
watcher
.
forget
(
)
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsAvailableMemoryWatcher
nsAvailableMemoryWatcherBase
nsITimerCallback
nsIObserver
)
;
void
nsAvailableMemoryWatcher
:
:
StopPolling
(
const
MutexAutoLock
&
)
MOZ_REQUIRES
(
mMutex
)
{
if
(
mPolling
&
&
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mPolling
=
false
;
}
}
bool
nsAvailableMemoryWatcher
:
:
IsMemoryLow
(
)
{
MemoryInfo
memInfo
{
0
0
}
;
bool
aResult
=
false
;
nsresult
rv
=
ReadMemoryFile
(
kMeminfoPath
memInfo
)
;
if
(
NS_FAILED
(
rv
)
|
|
memInfo
.
memAvailable
=
=
0
)
{
return
aResult
;
}
unsigned
long
memoryAsPercentage
=
(
memInfo
.
memAvailable
*
100
)
/
memInfo
.
memTotal
;
if
(
memoryAsPercentage
<
=
StaticPrefs
:
:
browser_low_commit_space_threshold_percent
(
)
|
|
memInfo
.
memAvailable
<
StaticPrefs
:
:
browser_low_commit_space_threshold_mb
(
)
*
1024
)
{
aResult
=
true
;
}
return
aResult
;
}
void
nsAvailableMemoryWatcher
:
:
ShutDown
(
const
MutexAutoLock
&
)
MOZ_REQUIRES
(
mMutex
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
if
(
mThread
)
{
mThread
-
>
Shutdown
(
)
;
}
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
Notify
(
nsITimer
*
aTimer
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mThread
)
{
MOZ_ASSERT
(
mThread
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
mThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
MemoryPoller
"
[
self
=
RefPtr
{
this
}
]
(
)
{
if
(
self
-
>
IsMemoryLow
(
)
)
{
self
-
>
HandleLowMemory
(
)
;
}
else
{
self
-
>
MaybeHandleHighMemory
(
)
;
}
}
)
)
;
if
NS_FAILED
(
rv
)
{
NS_WARNING
(
"
Cannot
dispatch
memory
polling
event
.
"
)
;
}
return
NS_OK
;
}
void
nsAvailableMemoryWatcher
:
:
HandleLowMemory
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mUnderMemoryPressure
)
{
mUnderMemoryPressure
=
true
;
UpdateCrashAnnotation
(
lock
)
;
StartPolling
(
lock
)
;
}
UpdateLowMemoryTimeStamp
(
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
nsAvailableMemoryWatcher
:
:
OnLowMemory
"
[
self
=
RefPtr
{
this
}
]
(
)
{
self
-
>
mTabUnloader
-
>
UnloadTabAsync
(
)
;
}
)
)
;
}
void
nsAvailableMemoryWatcher
:
:
UpdateCrashAnnotation
(
const
MutexAutoLock
&
)
MOZ_REQUIRES
(
mMutex
)
{
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
LinuxUnderMemoryPressure
mUnderMemoryPressure
)
;
}
void
nsAvailableMemoryWatcher
:
:
MaybeHandleHighMemory
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mUnderMemoryPressure
)
{
RecordTelemetryEventOnHighMemory
(
)
;
NS_NotifyOfEventualMemoryPressure
(
MemoryPressureState
:
:
NoPressure
)
;
mUnderMemoryPressure
=
false
;
UpdateCrashAnnotation
(
lock
)
;
}
StartPolling
(
lock
)
;
}
void
nsAvailableMemoryWatcher
:
:
StartPolling
(
const
MutexAutoLock
&
aLock
)
MOZ_REQUIRES
(
mMutex
)
{
uint32_t
pollingInterval
=
mUnderMemoryPressure
?
kLowMemoryPollingIntervalMS
:
kHighMemoryPollingIntervalMS
;
if
(
!
mPolling
)
{
if
(
NS_SUCCEEDED
(
mTimer
-
>
InitWithCallback
(
this
gIsGtest
?
10
:
pollingInterval
nsITimer
:
:
TYPE_REPEATING_SLACK
)
)
)
{
mPolling
=
true
;
}
}
else
{
mTimer
-
>
SetDelay
(
gIsGtest
?
10
:
pollingInterval
)
;
}
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
nsresult
rv
=
nsAvailableMemoryWatcherBase
:
:
Observe
(
aSubject
aTopic
aData
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MutexAutoLock
lock
(
mMutex
)
;
if
(
strcmp
(
aTopic
"
xpcom
-
shutdown
"
)
=
=
0
)
{
ShutDown
(
lock
)
;
}
else
if
(
strcmp
(
aTopic
"
user
-
interaction
-
active
"
)
=
=
0
)
{
StartPolling
(
lock
)
;
}
else
if
(
strcmp
(
aTopic
"
user
-
interaction
-
inactive
"
)
=
=
0
)
{
StopPolling
(
lock
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
nsAvailableMemoryWatcher
"
)
;
return
NS_OK
;
}
}
