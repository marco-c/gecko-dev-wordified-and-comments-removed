#
ifndef
nsWindowsHelpers_h
#
define
nsWindowsHelpers_h
#
include
<
windows
.
h
>
#
include
<
msi
.
h
>
#
include
"
nsAutoRef
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
class
AutoCriticalSection
{
public
:
explicit
AutoCriticalSection
(
LPCRITICAL_SECTION
aSection
)
:
mSection
(
aSection
)
{
:
:
EnterCriticalSection
(
mSection
)
;
}
~
AutoCriticalSection
(
)
{
:
:
LeaveCriticalSection
(
mSection
)
;
}
private
:
LPCRITICAL_SECTION
mSection
;
}
;
template
<
>
class
nsAutoRefTraits
<
HKEY
>
{
public
:
typedef
HKEY
RawRef
;
static
HKEY
Void
(
)
{
return
nullptr
;
}
static
void
Release
(
RawRef
aFD
)
{
if
(
aFD
!
=
Void
(
)
)
{
RegCloseKey
(
aFD
)
;
}
}
}
;
template
<
>
class
nsAutoRefTraits
<
HDC
>
{
public
:
typedef
HDC
RawRef
;
static
HDC
Void
(
)
{
return
nullptr
;
}
static
void
Release
(
RawRef
aFD
)
{
if
(
aFD
!
=
Void
(
)
)
{
:
:
DeleteDC
(
aFD
)
;
}
}
}
;
template
<
>
class
nsAutoRefTraits
<
HFONT
>
{
public
:
typedef
HFONT
RawRef
;
static
HFONT
Void
(
)
{
return
nullptr
;
}
static
void
Release
(
RawRef
aFD
)
{
if
(
aFD
!
=
Void
(
)
)
{
:
:
DeleteObject
(
aFD
)
;
}
}
}
;
template
<
>
class
nsAutoRefTraits
<
HBRUSH
>
{
public
:
typedef
HBRUSH
RawRef
;
static
HBRUSH
Void
(
)
{
return
nullptr
;
}
static
void
Release
(
RawRef
aFD
)
{
if
(
aFD
!
=
Void
(
)
)
{
:
:
DeleteObject
(
aFD
)
;
}
}
}
;
template
<
>
class
nsAutoRefTraits
<
HRGN
>
{
public
:
typedef
HRGN
RawRef
;
static
HRGN
Void
(
)
{
return
nullptr
;
}
static
void
Release
(
RawRef
aFD
)
{
if
(
aFD
!
=
Void
(
)
)
{
:
:
DeleteObject
(
aFD
)
;
}
}
}
;
template
<
>
class
nsAutoRefTraits
<
HBITMAP
>
{
public
:
typedef
HBITMAP
RawRef
;
static
HBITMAP
Void
(
)
{
return
nullptr
;
}
static
void
Release
(
RawRef
aFD
)
{
if
(
aFD
!
=
Void
(
)
)
{
:
:
DeleteObject
(
aFD
)
;
}
}
}
;
template
<
>
class
nsAutoRefTraits
<
SC_HANDLE
>
{
public
:
typedef
SC_HANDLE
RawRef
;
static
SC_HANDLE
Void
(
)
{
return
nullptr
;
}
static
void
Release
(
RawRef
aFD
)
{
if
(
aFD
!
=
Void
(
)
)
{
CloseServiceHandle
(
aFD
)
;
}
}
}
;
template
<
>
class
nsSimpleRef
<
HANDLE
>
{
protected
:
typedef
HANDLE
RawRef
;
nsSimpleRef
(
)
:
mRawRef
(
nullptr
)
{
}
explicit
nsSimpleRef
(
RawRef
aRawRef
)
:
mRawRef
(
aRawRef
)
{
}
bool
HaveResource
(
)
const
{
return
mRawRef
&
&
mRawRef
!
=
INVALID_HANDLE_VALUE
;
}
public
:
RawRef
get
(
)
const
{
return
mRawRef
;
}
static
void
Release
(
RawRef
aRawRef
)
{
if
(
aRawRef
&
&
aRawRef
!
=
INVALID_HANDLE_VALUE
)
{
CloseHandle
(
aRawRef
)
;
}
}
RawRef
mRawRef
;
}
;
template
<
>
class
nsAutoRefTraits
<
HMODULE
>
{
public
:
typedef
HMODULE
RawRef
;
static
RawRef
Void
(
)
{
return
nullptr
;
}
static
void
Release
(
RawRef
aFD
)
{
if
(
aFD
!
=
Void
(
)
)
{
FreeLibrary
(
aFD
)
;
}
}
}
;
template
<
>
class
nsAutoRefTraits
<
DEVMODEW
*
>
{
public
:
typedef
DEVMODEW
*
RawRef
;
static
RawRef
Void
(
)
{
return
nullptr
;
}
static
void
Release
(
RawRef
aDevMode
)
{
if
(
aDevMode
!
=
Void
(
)
)
{
:
:
HeapFree
(
:
:
GetProcessHeap
(
)
0
aDevMode
)
;
}
}
}
;
template
<
>
class
nsAutoRefTraits
<
MSIHANDLE
>
{
public
:
typedef
MSIHANDLE
RawRef
;
static
RawRef
Void
(
)
{
return
0
;
}
static
void
Release
(
RawRef
aHandle
)
{
if
(
aHandle
!
=
Void
(
)
)
{
:
:
MsiCloseHandle
(
aHandle
)
;
}
}
}
;
class
nsHGLOBAL
{
public
:
MOZ_IMPLICIT
nsHGLOBAL
(
HGLOBAL
hGlobal
)
:
m_hGlobal
(
hGlobal
)
{
}
operator
HGLOBAL
(
)
const
{
return
m_hGlobal
;
}
private
:
HGLOBAL
m_hGlobal
;
}
;
template
<
>
class
nsAutoRefTraits
<
nsHGLOBAL
>
{
public
:
typedef
nsHGLOBAL
RawRef
;
static
RawRef
Void
(
)
{
return
nullptr
;
}
static
void
Release
(
RawRef
hGlobal
)
{
:
:
GlobalFree
(
hGlobal
)
;
}
}
;
class
nsHPRINTER
{
public
:
MOZ_IMPLICIT
nsHPRINTER
(
HANDLE
hPrinter
)
:
m_hPrinter
(
hPrinter
)
{
}
operator
HANDLE
(
)
const
{
return
m_hPrinter
;
}
HANDLE
*
operator
&
(
)
{
return
&
m_hPrinter
;
}
private
:
HANDLE
m_hPrinter
;
}
;
extern
"
C
"
BOOL
WINAPI
ClosePrinter
(
HANDLE
hPrinter
)
;
template
<
>
class
nsAutoRefTraits
<
nsHPRINTER
>
{
public
:
typedef
nsHPRINTER
RawRef
;
static
RawRef
Void
(
)
{
return
nullptr
;
}
static
void
Release
(
RawRef
hPrinter
)
{
:
:
ClosePrinter
(
hPrinter
)
;
}
}
;
typedef
nsAutoRef
<
HKEY
>
nsAutoRegKey
;
typedef
nsAutoRef
<
HDC
>
nsAutoHDC
;
typedef
nsAutoRef
<
HFONT
>
nsAutoFont
;
typedef
nsAutoRef
<
HBRUSH
>
nsAutoBrush
;
typedef
nsAutoRef
<
HRGN
>
nsAutoRegion
;
typedef
nsAutoRef
<
HBITMAP
>
nsAutoBitmap
;
typedef
nsAutoRef
<
SC_HANDLE
>
nsAutoServiceHandle
;
typedef
nsAutoRef
<
HANDLE
>
nsAutoHandle
;
typedef
nsAutoRef
<
HMODULE
>
nsModuleHandle
;
typedef
nsAutoRef
<
DEVMODEW
*
>
nsAutoDevMode
;
typedef
nsAutoRef
<
nsHGLOBAL
>
nsAutoGlobalMem
;
typedef
nsAutoRef
<
nsHPRINTER
>
nsAutoPrinter
;
typedef
nsAutoRef
<
MSIHANDLE
>
nsAutoMsiHandle
;
bool
inline
ConstructSystem32Path
(
LPCWSTR
aModule
WCHAR
*
aSystemPath
UINT
aSize
)
{
MOZ_ASSERT
(
aSystemPath
)
;
size_t
fileLen
=
wcslen
(
aModule
)
;
if
(
fileLen
>
=
aSize
)
{
return
false
;
}
size_t
systemDirLen
=
GetSystemDirectoryW
(
aSystemPath
aSize
)
;
if
(
systemDirLen
)
{
if
(
systemDirLen
<
aSize
-
fileLen
)
{
if
(
aSystemPath
[
systemDirLen
-
1
]
!
=
L
'
\
\
'
)
{
if
(
systemDirLen
+
1
<
aSize
-
fileLen
)
{
aSystemPath
[
systemDirLen
]
=
L
'
\
\
'
;
+
+
systemDirLen
;
}
else
{
systemDirLen
=
0
;
}
}
}
else
{
systemDirLen
=
0
;
}
}
MOZ_ASSERT
(
systemDirLen
+
fileLen
<
aSize
)
;
wcsncpy
(
aSystemPath
+
systemDirLen
aModule
fileLen
)
;
aSystemPath
[
systemDirLen
+
fileLen
]
=
L
'
\
0
'
;
return
true
;
}
HMODULE
inline
LoadLibrarySystem32
(
LPCWSTR
aModule
)
{
return
LoadLibraryExW
(
aModule
nullptr
LOAD_LIBRARY_SEARCH_SYSTEM32
)
;
}
struct
LocalFreeDeleter
{
void
operator
(
)
(
void
*
aPtr
)
{
:
:
LocalFree
(
aPtr
)
;
}
}
;
struct
VirtualFreeDeleter
{
void
operator
(
)
(
void
*
aPtr
)
{
:
:
VirtualFree
(
aPtr
0
MEM_RELEASE
)
;
}
}
;
struct
FreeSidDeleter
{
void
operator
(
)
(
void
*
aPtr
)
{
:
:
FreeSid
(
aPtr
)
;
}
}
;
typedef
mozilla
:
:
UniquePtr
<
void
FreeSidDeleter
>
UniqueSidPtr
;
struct
CloseHandleDeleter
{
typedef
HANDLE
pointer
;
void
operator
(
)
(
pointer
aHandle
)
{
if
(
aHandle
!
=
INVALID_HANDLE_VALUE
)
{
:
:
CloseHandle
(
aHandle
)
;
}
}
}
;
using
AutoFreeSecurityDescriptor
=
mozilla
:
:
UniquePtr
<
SECURITY_DESCRIPTOR
LocalFreeDeleter
>
;
struct
DestroyPrivateObjectSecurityDeleter
{
void
operator
(
)
(
PSECURITY_DESCRIPTOR
aSecDescPtr
)
{
:
:
DestroyPrivateObjectSecurity
(
&
aSecDescPtr
)
;
}
}
;
using
AutoDestroySecurityDescriptor
=
mozilla
:
:
UniquePtr
<
SECURITY_DESCRIPTOR
DestroyPrivateObjectSecurityDeleter
>
;
inline
bool
IsDynamicBlocklistDisabled
(
bool
isSafeMode
bool
hasCommandLineDisableArgument
)
{
return
isSafeMode
|
|
hasCommandLineDisableArgument
;
}
#
endif
