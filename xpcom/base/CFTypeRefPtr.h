#
ifndef
CFTypeRefPtr_h
#
define
CFTypeRefPtr_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DbgMacro
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
template
<
class
PtrT
>
class
CFTypeRefPtr
{
private
:
void
assign_with_CFRetain
(
PtrT
aRawPtr
)
{
CFRetain
(
aRawPtr
)
;
assign_assuming_CFRetain
(
aRawPtr
)
;
}
void
assign_assuming_CFRetain
(
PtrT
aNewPtr
)
{
PtrT
oldPtr
=
mRawPtr
;
mRawPtr
=
aNewPtr
;
if
(
oldPtr
)
{
CFRelease
(
oldPtr
)
;
}
}
private
:
PtrT
mRawPtr
;
public
:
~
CFTypeRefPtr
(
)
{
if
(
mRawPtr
)
{
CFRelease
(
mRawPtr
)
;
}
}
CFTypeRefPtr
(
)
:
mRawPtr
(
nullptr
)
{
}
CFTypeRefPtr
(
const
CFTypeRefPtr
<
PtrT
>
&
aSmartPtr
)
:
mRawPtr
(
aSmartPtr
.
mRawPtr
)
{
if
(
mRawPtr
)
{
CFRetain
(
mRawPtr
)
;
}
}
CFTypeRefPtr
(
CFTypeRefPtr
<
PtrT
>
&
&
aRefPtr
)
:
mRawPtr
(
aRefPtr
.
mRawPtr
)
{
aRefPtr
.
mRawPtr
=
nullptr
;
}
MOZ_IMPLICIT
CFTypeRefPtr
(
decltype
(
nullptr
)
)
:
mRawPtr
(
nullptr
)
{
}
static
CFTypeRefPtr
<
PtrT
>
WrapUnderCreateRule
(
PtrT
aRawPtr
)
{
CFTypeRefPtr
<
PtrT
>
ptr
;
ptr
.
AssignUnderCreateRule
(
aRawPtr
)
;
return
ptr
;
}
static
CFTypeRefPtr
<
PtrT
>
WrapUnderGetRule
(
PtrT
aRawPtr
)
{
CFTypeRefPtr
<
PtrT
>
ptr
;
ptr
.
AssignUnderGetRule
(
aRawPtr
)
;
return
ptr
;
}
CFTypeRefPtr
<
PtrT
>
&
operator
=
(
decltype
(
nullptr
)
)
{
assign_assuming_CFRetain
(
nullptr
)
;
return
*
this
;
}
CFTypeRefPtr
<
PtrT
>
&
operator
=
(
const
CFTypeRefPtr
<
PtrT
>
&
aRhs
)
{
assign_with_CFRetain
(
aRhs
.
mRawPtr
)
;
return
*
this
;
}
CFTypeRefPtr
<
PtrT
>
&
operator
=
(
CFTypeRefPtr
<
PtrT
>
&
&
aRefPtr
)
{
assign_assuming_CFRetain
(
aRefPtr
.
mRawPtr
)
;
aRefPtr
.
mRawPtr
=
nullptr
;
return
*
this
;
}
CFTypeRefPtr
<
PtrT
>
&
AssignUnderCreateRule
(
PtrT
aRawPtr
)
{
assign_assuming_CFRetain
(
aRawPtr
)
;
return
*
this
;
}
CFTypeRefPtr
<
PtrT
>
&
AssignUnderGetRule
(
PtrT
aRawPtr
)
{
assign_with_CFRetain
(
aRawPtr
)
;
return
*
this
;
}
PtrT
get
(
)
const
{
return
mRawPtr
;
}
operator
PtrT
(
)
const
&
&
=
delete
;
operator
PtrT
(
)
const
&
=
delete
;
explicit
operator
bool
(
)
const
{
return
!
!
mRawPtr
;
}
}
;
template
<
class
PtrT
>
inline
bool
operator
=
=
(
const
CFTypeRefPtr
<
PtrT
>
&
aLhs
const
CFTypeRefPtr
<
PtrT
>
&
aRhs
)
{
return
aLhs
.
get
(
)
=
=
aRhs
.
get
(
)
;
}
template
<
class
PtrT
>
inline
bool
operator
!
=
(
const
CFTypeRefPtr
<
PtrT
>
&
aLhs
const
CFTypeRefPtr
<
PtrT
>
&
aRhs
)
{
return
!
(
aLhs
=
=
aRhs
)
;
}
template
<
class
PtrT
>
inline
bool
operator
=
=
(
const
CFTypeRefPtr
<
PtrT
>
&
aLhs
decltype
(
nullptr
)
)
{
return
aLhs
.
get
(
)
=
=
nullptr
;
}
template
<
class
PtrT
>
inline
bool
operator
=
=
(
decltype
(
nullptr
)
const
CFTypeRefPtr
<
PtrT
>
&
aRhs
)
{
return
nullptr
=
=
aRhs
.
get
(
)
;
}
template
<
class
PtrT
>
inline
bool
operator
!
=
(
const
CFTypeRefPtr
<
PtrT
>
&
aLhs
decltype
(
nullptr
)
)
{
return
aLhs
.
get
(
)
!
=
nullptr
;
}
template
<
class
PtrT
>
inline
bool
operator
!
=
(
decltype
(
nullptr
)
const
CFTypeRefPtr
<
PtrT
>
&
aRhs
)
{
return
nullptr
!
=
aRhs
.
get
(
)
;
}
template
<
class
PtrT
>
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aOut
const
CFTypeRefPtr
<
PtrT
>
&
aObj
)
{
return
mozilla
:
:
DebugValue
(
aOut
aObj
.
get
(
)
)
;
}
namespace
std
{
template
<
class
PtrT
>
struct
hash
<
CFTypeRefPtr
<
PtrT
>
>
{
typedef
CFTypeRefPtr
<
PtrT
>
argument_type
;
typedef
std
:
:
size_t
result_type
;
result_type
operator
(
)
(
argument_type
const
&
aPtr
)
const
{
return
mozilla
:
:
HashGeneric
(
reinterpret_cast
<
uintptr_t
>
(
aPtr
.
get
(
)
)
)
;
}
}
;
}
#
endif
