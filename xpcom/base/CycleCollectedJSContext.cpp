#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
CycleCollectedJSRuntime
.
h
"
#
include
<
utility
>
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimelineConsumers
.
h
"
#
include
"
mozilla
/
TimelineMarker
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
DebuggerOnGCRunnable
.
h
"
#
include
"
mozilla
/
dom
/
DOMJSClass
.
h
"
#
include
"
mozilla
/
dom
/
DOMException
.
h
"
#
include
"
mozilla
/
dom
/
ProfileTimelineMarkerBinding
.
h
"
#
include
"
mozilla
/
dom
/
PromiseBinding
.
h
"
#
include
"
mozilla
/
dom
/
PromiseDebugging
.
h
"
#
include
"
mozilla
/
dom
/
PromiseRejectionEvent
.
h
"
#
include
"
mozilla
/
dom
/
PromiseRejectionEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
Debug
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCycleCollectionNoteRootCallback
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
xpcpublic
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
CycleCollectedJSContext
:
:
CycleCollectedJSContext
(
)
:
mRuntime
(
nullptr
)
mJSContext
(
nullptr
)
mDoingStableStates
(
false
)
mTargetedMicroTaskRecursionDepth
(
0
)
mMicroTaskLevel
(
0
)
mDebuggerRecursionDepth
(
0
)
mMicroTaskRecursionDepth
(
0
)
{
MOZ_COUNT_CTOR
(
CycleCollectedJSContext
)
;
memset
(
static_cast
<
PerThreadAtomCache
*
>
(
this
)
0
sizeof
(
PerThreadAtomCache
)
)
;
nsCOMPtr
<
nsIThread
>
thread
=
do_GetCurrentThread
(
)
;
mOwningThread
=
thread
.
forget
(
)
.
downcast
<
nsThread
>
(
)
.
take
(
)
;
MOZ_RELEASE_ASSERT
(
mOwningThread
)
;
}
CycleCollectedJSContext
:
:
~
CycleCollectedJSContext
(
)
{
MOZ_COUNT_DTOR
(
CycleCollectedJSContext
)
;
if
(
!
mJSContext
)
{
return
;
}
JS
:
:
SetHostCleanupFinalizationGroupCallback
(
mJSContext
nullptr
nullptr
)
;
mFinalizationGroupsToCleanUp
.
reset
(
)
;
JS_SetContextPrivate
(
mJSContext
nullptr
)
;
mRuntime
-
>
SetContext
(
nullptr
)
;
mRuntime
-
>
Shutdown
(
mJSContext
)
;
CleanupIDBTransactions
(
mBaseRecursionDepth
)
;
MOZ_ASSERT
(
mPendingIDBTransactions
.
IsEmpty
(
)
)
;
ProcessStableStateQueue
(
)
;
MOZ_ASSERT
(
mStableStateEvents
.
IsEmpty
(
)
)
;
mPendingException
=
nullptr
;
MOZ_ASSERT
(
mDebuggerMicroTaskQueue
.
empty
(
)
)
;
MOZ_ASSERT
(
mPendingMicroTaskRunnables
.
empty
(
)
)
;
mUncaughtRejections
.
reset
(
)
;
mConsumedRejections
.
reset
(
)
;
mAboutToBeNotifiedRejectedPromises
.
Clear
(
)
;
mPendingUnhandledRejections
.
Clear
(
)
;
JS_DestroyContext
(
mJSContext
)
;
mJSContext
=
nullptr
;
nsCycleCollector_forgetJSContext
(
)
;
mozilla
:
:
dom
:
:
DestroyScriptSettings
(
)
;
mOwningThread
-
>
SetScriptObserver
(
nullptr
)
;
NS_RELEASE
(
mOwningThread
)
;
delete
mRuntime
;
mRuntime
=
nullptr
;
}
nsresult
CycleCollectedJSContext
:
:
Initialize
(
JSRuntime
*
aParentRuntime
uint32_t
aMaxBytes
)
{
MOZ_ASSERT
(
!
mJSContext
)
;
mozilla
:
:
dom
:
:
InitScriptSettings
(
)
;
mJSContext
=
JS_NewContext
(
aMaxBytes
aParentRuntime
)
;
if
(
!
mJSContext
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mRuntime
=
CreateRuntime
(
mJSContext
)
;
mRuntime
-
>
SetContext
(
this
)
;
mOwningThread
-
>
SetScriptObserver
(
this
)
;
mBaseRecursionDepth
=
RecursionDepth
(
)
;
NS_GetCurrentThread
(
)
-
>
SetCanInvokeJS
(
true
)
;
JS
:
:
SetJobQueue
(
mJSContext
this
)
;
JS
:
:
SetPromiseRejectionTrackerCallback
(
mJSContext
PromiseRejectionTrackerCallback
this
)
;
mUncaughtRejections
.
init
(
mJSContext
JS
:
:
GCVector
<
JSObject
*
0
js
:
:
SystemAllocPolicy
>
(
js
:
:
SystemAllocPolicy
(
)
)
)
;
mConsumedRejections
.
init
(
mJSContext
JS
:
:
GCVector
<
JSObject
*
0
js
:
:
SystemAllocPolicy
>
(
js
:
:
SystemAllocPolicy
(
)
)
)
;
mFinalizationGroupsToCleanUp
.
init
(
mJSContext
)
;
JS
:
:
SetHostCleanupFinalizationGroupCallback
(
mJSContext
CleanupFinalizationGroupCallback
this
)
;
JS_SetContextPrivate
(
mJSContext
static_cast
<
PerThreadAtomCache
*
>
(
this
)
)
;
nsCycleCollector_registerJSContext
(
this
)
;
return
NS_OK
;
}
CycleCollectedJSContext
*
CycleCollectedJSContext
:
:
GetFor
(
JSContext
*
aCx
)
{
auto
atomCache
=
static_cast
<
PerThreadAtomCache
*
>
(
JS_GetContextPrivate
(
aCx
)
)
;
return
static_cast
<
CycleCollectedJSContext
*
>
(
atomCache
)
;
}
size_t
CycleCollectedJSContext
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
class
PromiseJobRunnable
final
:
public
MicroTaskRunnable
{
public
:
PromiseJobRunnable
(
JS
:
:
HandleObject
aPromise
JS
:
:
HandleObject
aCallback
JS
:
:
HandleObject
aCallbackGlobal
JS
:
:
HandleObject
aAllocationSite
nsIGlobalObject
*
aIncumbentGlobal
)
:
mCallback
(
new
PromiseJobCallback
(
aCallback
aCallbackGlobal
aAllocationSite
aIncumbentGlobal
)
)
mPropagateUserInputEventHandling
(
false
)
{
MOZ_ASSERT
(
js
:
:
IsFunctionObject
(
aCallback
)
)
;
if
(
aPromise
)
{
JS
:
:
PromiseUserInputEventHandlingState
state
=
JS
:
:
GetPromiseUserInputEventHandlingState
(
aPromise
)
;
mPropagateUserInputEventHandling
=
state
=
=
JS
:
:
PromiseUserInputEventHandlingState
:
:
HadUserInteractionAtCreation
;
}
}
virtual
~
PromiseJobRunnable
(
)
{
}
protected
:
MOZ_CAN_RUN_SCRIPT
virtual
void
Run
(
AutoSlowOperation
&
aAso
)
override
{
JSObject
*
callback
=
mCallback
-
>
CallbackPreserveColor
(
)
;
nsIGlobalObject
*
global
=
callback
?
xpc
:
:
NativeGlobal
(
callback
)
:
nullptr
;
if
(
global
&
&
!
global
-
>
IsDying
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
global
)
;
RefPtr
<
Document
>
doc
;
if
(
win
)
{
doc
=
win
-
>
GetExtantDoc
(
)
;
}
AutoHandlingUserInputStatePusher
userInpStatePusher
(
mPropagateUserInputEventHandling
)
;
mCallback
-
>
Call
(
"
promise
callback
"
)
;
aAso
.
CheckForInterrupt
(
)
;
}
mCallback
-
>
Reset
(
)
;
}
virtual
bool
Suppressed
(
)
override
{
nsIGlobalObject
*
global
=
xpc
:
:
NativeGlobal
(
mCallback
-
>
CallbackPreserveColor
(
)
)
;
return
global
&
&
global
-
>
IsInSyncOperation
(
)
;
}
private
:
const
RefPtr
<
PromiseJobCallback
>
mCallback
;
bool
mPropagateUserInputEventHandling
;
}
;
JSObject
*
CycleCollectedJSContext
:
:
getIncumbentGlobal
(
JSContext
*
aCx
)
{
nsIGlobalObject
*
global
=
mozilla
:
:
dom
:
:
GetIncumbentGlobal
(
)
;
if
(
global
)
{
return
global
-
>
GetGlobalJSObject
(
)
;
}
return
nullptr
;
}
bool
CycleCollectedJSContext
:
:
enqueuePromiseJob
(
JSContext
*
aCx
JS
:
:
HandleObject
aPromise
JS
:
:
HandleObject
aJob
JS
:
:
HandleObject
aAllocationSite
JS
:
:
HandleObject
aIncumbentGlobal
)
{
MOZ_ASSERT
(
aCx
=
=
Context
(
)
)
;
MOZ_ASSERT
(
Get
(
)
=
=
this
)
;
nsIGlobalObject
*
global
=
nullptr
;
if
(
aIncumbentGlobal
)
{
global
=
xpc
:
:
NativeGlobal
(
aIncumbentGlobal
)
;
}
JS
:
:
RootedObject
jobGlobal
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
RefPtr
<
PromiseJobRunnable
>
runnable
=
new
PromiseJobRunnable
(
aPromise
aJob
jobGlobal
aAllocationSite
global
)
;
DispatchToMicroTask
(
runnable
.
forget
(
)
)
;
return
true
;
}
void
CycleCollectedJSContext
:
:
runJobs
(
JSContext
*
aCx
)
{
MOZ_ASSERT
(
aCx
=
=
Context
(
)
)
;
MOZ_ASSERT
(
Get
(
)
=
=
this
)
;
PerformMicroTaskCheckPoint
(
)
;
}
bool
CycleCollectedJSContext
:
:
empty
(
)
const
{
return
mPendingMicroTaskRunnables
.
empty
(
)
;
}
class
CycleCollectedJSContext
:
:
SavedMicroTaskQueue
:
public
JS
:
:
JobQueue
:
:
SavedJobQueue
{
public
:
explicit
SavedMicroTaskQueue
(
CycleCollectedJSContext
*
ccjs
)
:
ccjs
(
ccjs
)
{
ccjs
-
>
mDebuggerRecursionDepth
+
+
;
ccjs
-
>
mPendingMicroTaskRunnables
.
swap
(
mQueue
)
;
}
~
SavedMicroTaskQueue
(
)
{
MOZ_RELEASE_ASSERT
(
ccjs
-
>
mPendingMicroTaskRunnables
.
empty
(
)
)
;
MOZ_RELEASE_ASSERT
(
ccjs
-
>
mDebuggerRecursionDepth
)
;
ccjs
-
>
mDebuggerRecursionDepth
-
-
;
ccjs
-
>
mPendingMicroTaskRunnables
.
swap
(
mQueue
)
;
}
private
:
CycleCollectedJSContext
*
ccjs
;
std
:
:
queue
<
RefPtr
<
MicroTaskRunnable
>
>
mQueue
;
}
;
js
:
:
UniquePtr
<
JS
:
:
JobQueue
:
:
SavedJobQueue
>
CycleCollectedJSContext
:
:
saveJobQueue
(
JSContext
*
cx
)
{
auto
saved
=
js
:
:
MakeUnique
<
SavedMicroTaskQueue
>
(
this
)
;
if
(
!
saved
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
return
saved
;
}
void
CycleCollectedJSContext
:
:
PromiseRejectionTrackerCallback
(
JSContext
*
aCx
bool
aMutedErrors
JS
:
:
HandleObject
aPromise
JS
:
:
PromiseRejectionHandlingState
state
void
*
aData
)
{
CycleCollectedJSContext
*
self
=
static_cast
<
CycleCollectedJSContext
*
>
(
aData
)
;
MOZ_ASSERT
(
aCx
=
=
self
-
>
Context
(
)
)
;
MOZ_ASSERT
(
Get
(
)
=
=
self
)
;
PromiseArray
&
aboutToBeNotified
=
self
-
>
mAboutToBeNotifiedRejectedPromises
;
PromiseHashtable
&
unhandled
=
self
-
>
mPendingUnhandledRejections
;
uint64_t
promiseID
=
JS
:
:
GetPromiseID
(
aPromise
)
;
if
(
state
=
=
JS
:
:
PromiseRejectionHandlingState
:
:
Unhandled
)
{
PromiseDebugging
:
:
AddUncaughtRejection
(
aPromise
)
;
if
(
!
aMutedErrors
)
{
RefPtr
<
Promise
>
promise
=
Promise
:
:
CreateFromExisting
(
xpc
:
:
NativeGlobal
(
aPromise
)
aPromise
)
;
aboutToBeNotified
.
AppendElement
(
promise
)
;
unhandled
.
Put
(
promiseID
promise
)
;
}
}
else
{
PromiseDebugging
:
:
AddConsumedRejection
(
aPromise
)
;
for
(
size_t
i
=
0
;
i
<
aboutToBeNotified
.
Length
(
)
;
i
+
+
)
{
if
(
aboutToBeNotified
[
i
]
&
&
aboutToBeNotified
[
i
]
-
>
PromiseObj
(
)
=
=
aPromise
)
{
aboutToBeNotified
[
i
]
=
nullptr
;
DebugOnly
<
bool
>
isFound
=
unhandled
.
Remove
(
promiseID
)
;
MOZ_ASSERT
(
isFound
)
;
return
;
}
}
RefPtr
<
Promise
>
promise
;
unhandled
.
Remove
(
promiseID
getter_AddRefs
(
promise
)
)
;
if
(
!
promise
&
&
!
aMutedErrors
)
{
nsIGlobalObject
*
global
=
xpc
:
:
NativeGlobal
(
aPromise
)
;
if
(
nsCOMPtr
<
EventTarget
>
owner
=
do_QueryInterface
(
global
)
)
{
RootedDictionary
<
PromiseRejectionEventInit
>
init
(
aCx
)
;
init
.
mPromise
=
Promise
:
:
CreateFromExisting
(
global
aPromise
)
;
init
.
mReason
=
JS
:
:
GetPromiseResult
(
aPromise
)
;
RefPtr
<
PromiseRejectionEvent
>
event
=
PromiseRejectionEvent
:
:
Constructor
(
owner
NS_LITERAL_STRING
(
"
rejectionhandled
"
)
init
)
;
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
owner
event
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
}
}
}
already_AddRefed
<
Exception
>
CycleCollectedJSContext
:
:
GetPendingException
(
)
const
{
MOZ_ASSERT
(
mJSContext
)
;
nsCOMPtr
<
Exception
>
out
=
mPendingException
;
return
out
.
forget
(
)
;
}
void
CycleCollectedJSContext
:
:
SetPendingException
(
Exception
*
aException
)
{
MOZ_ASSERT
(
mJSContext
)
;
mPendingException
=
aException
;
}
std
:
:
queue
<
RefPtr
<
MicroTaskRunnable
>
>
&
CycleCollectedJSContext
:
:
GetMicroTaskQueue
(
)
{
MOZ_ASSERT
(
mJSContext
)
;
return
mPendingMicroTaskRunnables
;
}
std
:
:
queue
<
RefPtr
<
MicroTaskRunnable
>
>
&
CycleCollectedJSContext
:
:
GetDebuggerMicroTaskQueue
(
)
{
MOZ_ASSERT
(
mJSContext
)
;
return
mDebuggerMicroTaskQueue
;
}
void
CycleCollectedJSContext
:
:
ProcessStableStateQueue
(
)
{
MOZ_ASSERT
(
mJSContext
)
;
MOZ_RELEASE_ASSERT
(
!
mDoingStableStates
)
;
mDoingStableStates
=
true
;
for
(
uint32_t
i
=
0
;
i
<
mStableStateEvents
.
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mStableStateEvents
[
i
]
.
forget
(
)
;
event
-
>
Run
(
)
;
}
mStableStateEvents
.
Clear
(
)
;
mDoingStableStates
=
false
;
}
void
CycleCollectedJSContext
:
:
CleanupIDBTransactions
(
uint32_t
aRecursionDepth
)
{
MOZ_ASSERT
(
mJSContext
)
;
MOZ_RELEASE_ASSERT
(
!
mDoingStableStates
)
;
mDoingStableStates
=
true
;
nsTArray
<
PendingIDBTransactionData
>
localQueue
=
std
:
:
move
(
mPendingIDBTransactions
)
;
for
(
uint32_t
i
=
0
;
i
<
localQueue
.
Length
(
)
;
+
+
i
)
{
PendingIDBTransactionData
&
data
=
localQueue
[
i
]
;
if
(
data
.
mRecursionDepth
!
=
aRecursionDepth
)
{
continue
;
}
{
nsCOMPtr
<
nsIRunnable
>
transaction
=
data
.
mTransaction
.
forget
(
)
;
transaction
-
>
Run
(
)
;
}
localQueue
.
RemoveElementAt
(
i
-
-
)
;
}
localQueue
.
AppendElements
(
mPendingIDBTransactions
)
;
localQueue
.
SwapElements
(
mPendingIDBTransactions
)
;
mDoingStableStates
=
false
;
}
void
CycleCollectedJSContext
:
:
BeforeProcessTask
(
bool
aMightBlock
)
{
if
(
aMightBlock
&
&
PerformMicroTaskCheckPoint
(
)
)
{
NS_DispatchToMainThread
(
new
Runnable
(
"
BeforeProcessTask
"
)
)
;
}
}
void
CycleCollectedJSContext
:
:
AfterProcessTask
(
uint32_t
aRecursionDepth
)
{
MOZ_ASSERT
(
mJSContext
)
;
PerformMicroTaskCheckPoint
(
)
;
ProcessStableStateQueue
(
)
;
IsIdleGCTaskNeeded
(
)
;
}
void
CycleCollectedJSContext
:
:
AfterProcessMicrotasks
(
)
{
MOZ_ASSERT
(
mJSContext
)
;
if
(
mAboutToBeNotifiedRejectedPromises
.
Length
(
)
)
{
RefPtr
<
NotifyUnhandledRejections
>
runnable
=
new
NotifyUnhandledRejections
(
this
std
:
:
move
(
mAboutToBeNotifiedRejectedPromises
)
)
;
NS_DispatchToCurrentThread
(
runnable
)
;
}
CleanupIDBTransactions
(
RecursionDepth
(
)
)
;
JS
:
:
ClearKeptObjects
(
mJSContext
)
;
}
void
CycleCollectedJSContext
:
:
IsIdleGCTaskNeeded
(
)
const
{
class
IdleTimeGCTaskRunnable
:
public
mozilla
:
:
IdleRunnable
{
public
:
using
mozilla
:
:
IdleRunnable
:
:
IdleRunnable
;
public
:
NS_IMETHOD
Run
(
)
override
{
CycleCollectedJSRuntime
*
ccrt
=
CycleCollectedJSRuntime
:
:
Get
(
)
;
if
(
ccrt
)
{
ccrt
-
>
RunIdleTimeGCTask
(
)
;
}
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
return
NS_OK
;
}
}
;
if
(
Runtime
(
)
-
>
IsIdleGCTaskNeeded
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
gc_task
=
new
IdleTimeGCTaskRunnable
(
)
;
NS_DispatchToCurrentThreadQueue
(
gc_task
.
forget
(
)
EventQueuePriority
:
:
Idle
)
;
Runtime
(
)
-
>
SetPendingIdleGCTask
(
)
;
}
}
uint32_t
CycleCollectedJSContext
:
:
RecursionDepth
(
)
const
{
return
mOwningThread
-
>
RecursionDepth
(
)
+
mDebuggerRecursionDepth
;
}
void
CycleCollectedJSContext
:
:
RunInStableState
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
MOZ_ASSERT
(
mJSContext
)
;
mStableStateEvents
.
AppendElement
(
std
:
:
move
(
aRunnable
)
)
;
}
void
CycleCollectedJSContext
:
:
AddPendingIDBTransaction
(
already_AddRefed
<
nsIRunnable
>
&
&
aTransaction
)
{
MOZ_ASSERT
(
mJSContext
)
;
PendingIDBTransactionData
data
;
data
.
mTransaction
=
aTransaction
;
MOZ_ASSERT
(
mOwningThread
)
;
data
.
mRecursionDepth
=
RecursionDepth
(
)
;
#
ifndef
MOZ_WIDGET_COCOA
MOZ_ASSERT
(
data
.
mRecursionDepth
>
mBaseRecursionDepth
)
;
#
else
if
(
data
.
mRecursionDepth
<
=
mBaseRecursionDepth
)
{
data
.
mRecursionDepth
=
mBaseRecursionDepth
+
1
;
}
#
endif
mPendingIDBTransactions
.
AppendElement
(
std
:
:
move
(
data
)
)
;
}
void
CycleCollectedJSContext
:
:
DispatchToMicroTask
(
already_AddRefed
<
MicroTaskRunnable
>
aRunnable
)
{
RefPtr
<
MicroTaskRunnable
>
runnable
(
aRunnable
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
runnable
)
;
JS
:
:
JobQueueMayNotBeEmpty
(
Context
(
)
)
;
mPendingMicroTaskRunnables
.
push
(
runnable
.
forget
(
)
)
;
}
class
AsyncMutationHandler
final
:
public
mozilla
:
:
Runnable
{
public
:
AsyncMutationHandler
(
)
:
mozilla
:
:
Runnable
(
"
AsyncMutationHandler
"
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
CycleCollectedJSContext
*
ccjs
=
CycleCollectedJSContext
:
:
Get
(
)
;
if
(
ccjs
)
{
ccjs
-
>
PerformMicroTaskCheckPoint
(
)
;
}
return
NS_OK
;
}
}
;
bool
CycleCollectedJSContext
:
:
PerformMicroTaskCheckPoint
(
bool
aForce
)
{
if
(
mPendingMicroTaskRunnables
.
empty
(
)
&
&
mDebuggerMicroTaskQueue
.
empty
(
)
)
{
AfterProcessMicrotasks
(
)
;
return
false
;
}
uint32_t
currentDepth
=
RecursionDepth
(
)
;
if
(
mMicroTaskRecursionDepth
>
=
currentDepth
&
&
!
aForce
)
{
return
false
;
}
if
(
mTargetedMicroTaskRecursionDepth
!
=
0
&
&
mTargetedMicroTaskRecursionDepth
+
mDebuggerRecursionDepth
!
=
currentDepth
)
{
return
false
;
}
if
(
NS_IsMainThread
(
)
&
&
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
AsyncMutationHandler
(
)
)
;
return
false
;
}
mozilla
:
:
AutoRestore
<
uint32_t
>
restore
(
mMicroTaskRecursionDepth
)
;
MOZ_ASSERT
(
aForce
?
currentDepth
=
=
0
:
currentDepth
>
0
)
;
mMicroTaskRecursionDepth
=
currentDepth
;
bool
didProcess
=
false
;
AutoSlowOperation
aso
;
std
:
:
queue
<
RefPtr
<
MicroTaskRunnable
>
>
suppressed
;
for
(
;
;
)
{
RefPtr
<
MicroTaskRunnable
>
runnable
;
if
(
!
mDebuggerMicroTaskQueue
.
empty
(
)
)
{
runnable
=
mDebuggerMicroTaskQueue
.
front
(
)
.
forget
(
)
;
mDebuggerMicroTaskQueue
.
pop
(
)
;
}
else
if
(
!
mPendingMicroTaskRunnables
.
empty
(
)
)
{
runnable
=
mPendingMicroTaskRunnables
.
front
(
)
.
forget
(
)
;
mPendingMicroTaskRunnables
.
pop
(
)
;
}
else
{
break
;
}
if
(
runnable
-
>
Suppressed
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
JS
:
:
JobQueueMayNotBeEmpty
(
Context
(
)
)
;
suppressed
.
push
(
runnable
)
;
}
else
{
if
(
mPendingMicroTaskRunnables
.
empty
(
)
&
&
mDebuggerMicroTaskQueue
.
empty
(
)
&
&
suppressed
.
empty
(
)
)
{
JS
:
:
JobQueueIsEmpty
(
Context
(
)
)
;
}
didProcess
=
true
;
runnable
-
>
Run
(
aso
)
;
}
}
mPendingMicroTaskRunnables
.
swap
(
suppressed
)
;
AfterProcessMicrotasks
(
)
;
return
didProcess
;
}
void
CycleCollectedJSContext
:
:
PerformDebuggerMicroTaskCheckpoint
(
)
{
AutoSlowOperation
aso
;
for
(
;
;
)
{
std
:
:
queue
<
RefPtr
<
MicroTaskRunnable
>
>
*
microtaskQueue
=
&
GetDebuggerMicroTaskQueue
(
)
;
if
(
microtaskQueue
-
>
empty
(
)
)
{
break
;
}
RefPtr
<
MicroTaskRunnable
>
runnable
=
microtaskQueue
-
>
front
(
)
.
forget
(
)
;
MOZ_ASSERT
(
runnable
)
;
microtaskQueue
-
>
pop
(
)
;
if
(
mPendingMicroTaskRunnables
.
empty
(
)
&
&
mDebuggerMicroTaskQueue
.
empty
(
)
)
{
JS
:
:
JobQueueIsEmpty
(
Context
(
)
)
;
}
runnable
-
>
Run
(
aso
)
;
}
AfterProcessMicrotasks
(
)
;
}
NS_IMETHODIMP
CycleCollectedJSContext
:
:
NotifyUnhandledRejections
:
:
Run
(
)
{
for
(
size_t
i
=
0
;
i
<
mUnhandledRejections
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
Promise
>
&
promise
=
mUnhandledRejections
[
i
]
;
if
(
!
promise
)
{
continue
;
}
JS
:
:
RootingContext
*
cx
=
mCx
-
>
RootingCx
(
)
;
JS
:
:
RootedObject
promiseObj
(
cx
promise
-
>
PromiseObj
(
)
)
;
MOZ_ASSERT
(
JS
:
:
IsPromiseObject
(
promiseObj
)
)
;
uint64_t
promiseID
=
JS
:
:
GetPromiseID
(
promiseObj
)
;
if
(
!
JS
:
:
GetPromiseIsHandled
(
promiseObj
)
)
{
if
(
nsCOMPtr
<
EventTarget
>
target
=
do_QueryInterface
(
promise
-
>
GetParentObject
(
)
)
)
{
RootedDictionary
<
PromiseRejectionEventInit
>
init
(
cx
)
;
init
.
mPromise
=
promise
;
init
.
mReason
=
JS
:
:
GetPromiseResult
(
promiseObj
)
;
init
.
mCancelable
=
true
;
RefPtr
<
PromiseRejectionEvent
>
event
=
PromiseRejectionEvent
:
:
Constructor
(
target
NS_LITERAL_STRING
(
"
unhandledrejection
"
)
init
)
;
target
-
>
DispatchEvent
(
*
event
)
;
}
}
if
(
!
JS
:
:
GetPromiseIsHandled
(
promiseObj
)
)
{
DebugOnly
<
bool
>
isFound
=
mCx
-
>
mPendingUnhandledRejections
.
Remove
(
promiseID
)
;
MOZ_ASSERT
(
isFound
)
;
}
MOZ_ASSERT
(
!
mCx
-
>
mPendingUnhandledRejections
.
Lookup
(
promiseID
)
)
;
}
return
NS_OK
;
}
nsresult
CycleCollectedJSContext
:
:
NotifyUnhandledRejections
:
:
Cancel
(
)
{
for
(
size_t
i
=
0
;
i
<
mUnhandledRejections
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
Promise
>
&
promise
=
mUnhandledRejections
[
i
]
;
if
(
!
promise
)
{
continue
;
}
JS
:
:
RootedObject
promiseObj
(
mCx
-
>
RootingCx
(
)
promise
-
>
PromiseObj
(
)
)
;
mCx
-
>
mPendingUnhandledRejections
.
Remove
(
JS
:
:
GetPromiseID
(
promiseObj
)
)
;
}
return
NS_OK
;
}
class
CleanupFinalizationGroupsRunnable
:
public
CancelableRunnable
{
public
:
explicit
CleanupFinalizationGroupsRunnable
(
CycleCollectedJSContext
*
aContext
)
:
CancelableRunnable
(
"
CleanupFinalizationGroupsRunnable
"
)
mContext
(
aContext
)
{
}
NS_DECL_NSIRUNNABLE
private
:
CycleCollectedJSContext
*
mContext
;
}
;
NS_IMETHODIMP
CleanupFinalizationGroupsRunnable
:
:
Run
(
)
{
if
(
mContext
-
>
mFinalizationGroupsToCleanUp
.
empty
(
)
)
{
return
NS_OK
;
}
JS
:
:
RootingContext
*
cx
=
mContext
-
>
RootingCx
(
)
;
JS
:
:
Rooted
<
CycleCollectedJSContext
:
:
ObjectVector
>
groups
(
cx
)
;
std
:
:
swap
(
groups
.
get
(
)
mContext
-
>
mFinalizationGroupsToCleanUp
.
get
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
group
(
cx
)
;
for
(
const
auto
&
g
:
groups
)
{
group
=
g
;
AutoEntryScript
aes
(
group
"
cleanupFinalizationGroup
"
)
;
mozilla
:
:
Unused
<
<
JS
:
:
CleanupQueuedFinalizationGroup
(
aes
.
cx
(
)
group
)
;
}
return
NS_OK
;
}
void
CycleCollectedJSContext
:
:
CleanupFinalizationGroupCallback
(
JSObject
*
aGroup
void
*
aData
)
{
CycleCollectedJSContext
*
ccjs
=
static_cast
<
CycleCollectedJSContext
*
>
(
aData
)
;
ccjs
-
>
QueueFinalizationGroupForCleanup
(
aGroup
)
;
}
void
CycleCollectedJSContext
:
:
QueueFinalizationGroupForCleanup
(
JSObject
*
aGroup
)
{
bool
firstGroup
=
mFinalizationGroupsToCleanUp
.
empty
(
)
;
MOZ_ALWAYS_TRUE
(
mFinalizationGroupsToCleanUp
.
append
(
aGroup
)
)
;
if
(
firstGroup
)
{
RefPtr
<
CleanupFinalizationGroupsRunnable
>
cleanup
=
new
CleanupFinalizationGroupsRunnable
(
this
)
;
NS_DispatchToCurrentThread
(
cleanup
.
forget
(
)
)
;
}
}
}
