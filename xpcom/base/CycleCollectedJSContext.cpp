#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
CycleCollectedJSRuntime
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimelineConsumers
.
h
"
#
include
"
mozilla
/
TimelineMarker
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
DebuggerOnGCRunnable
.
h
"
#
include
"
mozilla
/
dom
/
DOMJSClass
.
h
"
#
include
"
mozilla
/
dom
/
DOMException
.
h
"
#
include
"
mozilla
/
dom
/
ProfileTimelineMarkerBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseBinding
.
h
"
#
include
"
mozilla
/
dom
/
PromiseDebugging
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
Debug
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCycleCollectionNoteRootCallback
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
xpcpublic
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
CycleCollectedJSContext
:
:
CycleCollectedJSContext
(
)
:
mIsPrimaryContext
(
true
)
mRuntime
(
nullptr
)
mJSContext
(
nullptr
)
mDoingStableStates
(
false
)
mTargetedMicroTaskRecursionDepth
(
0
)
mMicroTaskLevel
(
0
)
mMicroTaskRecursionDepth
(
0
)
{
MOZ_COUNT_CTOR
(
CycleCollectedJSContext
)
;
memset
(
static_cast
<
PerThreadAtomCache
*
>
(
this
)
0
sizeof
(
PerThreadAtomCache
)
)
;
nsCOMPtr
<
nsIThread
>
thread
=
do_GetCurrentThread
(
)
;
mOwningThread
=
thread
.
forget
(
)
.
downcast
<
nsThread
>
(
)
.
take
(
)
;
MOZ_RELEASE_ASSERT
(
mOwningThread
)
;
}
CycleCollectedJSContext
:
:
~
CycleCollectedJSContext
(
)
{
MOZ_COUNT_DTOR
(
CycleCollectedJSContext
)
;
if
(
!
mJSContext
)
{
return
;
}
JS_SetContextPrivate
(
mJSContext
nullptr
)
;
mRuntime
-
>
RemoveContext
(
this
)
;
if
(
mIsPrimaryContext
)
{
mRuntime
-
>
Shutdown
(
mJSContext
)
;
}
CleanupIDBTransactions
(
mBaseRecursionDepth
)
;
MOZ_ASSERT
(
mPendingIDBTransactions
.
IsEmpty
(
)
)
;
ProcessStableStateQueue
(
)
;
MOZ_ASSERT
(
mStableStateEvents
.
IsEmpty
(
)
)
;
mPendingException
=
nullptr
;
MOZ_ASSERT
(
mDebuggerMicroTaskQueue
.
empty
(
)
)
;
MOZ_ASSERT
(
mPendingMicroTaskRunnables
.
empty
(
)
)
;
mUncaughtRejections
.
reset
(
)
;
mConsumedRejections
.
reset
(
)
;
JS_DestroyContext
(
mJSContext
)
;
mJSContext
=
nullptr
;
if
(
mIsPrimaryContext
)
{
nsCycleCollector_forgetJSContext
(
)
;
}
else
{
nsCycleCollector_forgetNonPrimaryContext
(
)
;
}
mozilla
:
:
dom
:
:
DestroyScriptSettings
(
)
;
mOwningThread
-
>
SetScriptObserver
(
nullptr
)
;
NS_RELEASE
(
mOwningThread
)
;
if
(
mIsPrimaryContext
)
{
delete
mRuntime
;
}
mRuntime
=
nullptr
;
}
void
CycleCollectedJSContext
:
:
InitializeCommon
(
)
{
mRuntime
-
>
AddContext
(
this
)
;
mOwningThread
-
>
SetScriptObserver
(
this
)
;
mBaseRecursionDepth
=
RecursionDepth
(
)
;
NS_GetCurrentThread
(
)
-
>
SetCanInvokeJS
(
true
)
;
JS
:
:
SetGetIncumbentGlobalCallback
(
mJSContext
GetIncumbentGlobalCallback
)
;
JS
:
:
SetEnqueuePromiseJobCallback
(
mJSContext
EnqueuePromiseJobCallback
this
)
;
JS
:
:
SetPromiseRejectionTrackerCallback
(
mJSContext
PromiseRejectionTrackerCallback
this
)
;
mUncaughtRejections
.
init
(
mJSContext
JS
:
:
GCVector
<
JSObject
*
0
js
:
:
SystemAllocPolicy
>
(
js
:
:
SystemAllocPolicy
(
)
)
)
;
mConsumedRejections
.
init
(
mJSContext
JS
:
:
GCVector
<
JSObject
*
0
js
:
:
SystemAllocPolicy
>
(
js
:
:
SystemAllocPolicy
(
)
)
)
;
JS_SetContextPrivate
(
mJSContext
static_cast
<
PerThreadAtomCache
*
>
(
this
)
)
;
}
nsresult
CycleCollectedJSContext
:
:
Initialize
(
JSRuntime
*
aParentRuntime
uint32_t
aMaxBytes
uint32_t
aMaxNurseryBytes
)
{
MOZ_ASSERT
(
!
mJSContext
)
;
mozilla
:
:
dom
:
:
InitScriptSettings
(
)
;
mJSContext
=
JS_NewContext
(
aMaxBytes
aMaxNurseryBytes
aParentRuntime
)
;
if
(
!
mJSContext
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mRuntime
=
CreateRuntime
(
mJSContext
)
;
InitializeCommon
(
)
;
nsCycleCollector_registerJSContext
(
this
)
;
return
NS_OK
;
}
nsresult
CycleCollectedJSContext
:
:
InitializeNonPrimary
(
CycleCollectedJSContext
*
aPrimaryContext
)
{
MOZ_ASSERT
(
!
mJSContext
)
;
mIsPrimaryContext
=
false
;
mozilla
:
:
dom
:
:
InitScriptSettings
(
)
;
mJSContext
=
JS_NewCooperativeContext
(
aPrimaryContext
-
>
mJSContext
)
;
if
(
!
mJSContext
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mRuntime
=
aPrimaryContext
-
>
mRuntime
;
InitializeCommon
(
)
;
nsCycleCollector_registerNonPrimaryContext
(
this
)
;
return
NS_OK
;
}
CycleCollectedJSContext
*
CycleCollectedJSContext
:
:
GetFor
(
JSContext
*
aCx
)
{
auto
atomCache
=
static_cast
<
PerThreadAtomCache
*
>
(
JS_GetContextPrivate
(
aCx
)
)
;
return
static_cast
<
CycleCollectedJSContext
*
>
(
atomCache
)
;
}
size_t
CycleCollectedJSContext
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
class
PromiseJobRunnable
final
:
public
MicroTaskRunnable
{
public
:
PromiseJobRunnable
(
JS
:
:
HandleObject
aCallback
JS
:
:
HandleObject
aCallbackGlobal
JS
:
:
HandleObject
aAllocationSite
nsIGlobalObject
*
aIncumbentGlobal
)
:
mCallback
(
new
PromiseJobCallback
(
aCallback
aCallbackGlobal
aAllocationSite
aIncumbentGlobal
)
)
{
MOZ_ASSERT
(
js
:
:
IsFunctionObject
(
aCallback
)
)
;
}
virtual
~
PromiseJobRunnable
(
)
{
}
protected
:
virtual
void
Run
(
AutoSlowOperation
&
aAso
)
override
{
JSObject
*
callback
=
mCallback
-
>
CallbackPreserveColor
(
)
;
nsIGlobalObject
*
global
=
callback
?
xpc
:
:
NativeGlobal
(
callback
)
:
nullptr
;
if
(
global
&
&
!
global
-
>
IsDying
(
)
)
{
mCallback
-
>
Call
(
"
promise
callback
"
)
;
aAso
.
CheckForInterrupt
(
)
;
}
mCallback
-
>
Reset
(
)
;
}
virtual
bool
Suppressed
(
)
override
{
nsIGlobalObject
*
global
=
xpc
:
:
NativeGlobal
(
mCallback
-
>
CallbackPreserveColor
(
)
)
;
return
global
&
&
global
-
>
IsInSyncOperation
(
)
;
}
private
:
RefPtr
<
PromiseJobCallback
>
mCallback
;
}
;
JSObject
*
CycleCollectedJSContext
:
:
GetIncumbentGlobalCallback
(
JSContext
*
aCx
)
{
nsIGlobalObject
*
global
=
mozilla
:
:
dom
:
:
GetIncumbentGlobal
(
)
;
if
(
global
)
{
return
global
-
>
GetGlobalJSObject
(
)
;
}
return
nullptr
;
}
bool
CycleCollectedJSContext
:
:
EnqueuePromiseJobCallback
(
JSContext
*
aCx
JS
:
:
HandleObject
aPromise
JS
:
:
HandleObject
aJob
JS
:
:
HandleObject
aAllocationSite
JS
:
:
HandleObject
aIncumbentGlobal
void
*
aData
)
{
CycleCollectedJSContext
*
self
=
static_cast
<
CycleCollectedJSContext
*
>
(
aData
)
;
MOZ_ASSERT
(
aCx
=
=
self
-
>
Context
(
)
)
;
MOZ_ASSERT
(
Get
(
)
=
=
self
)
;
nsIGlobalObject
*
global
=
nullptr
;
if
(
aIncumbentGlobal
)
{
global
=
xpc
:
:
NativeGlobal
(
aIncumbentGlobal
)
;
}
JS
:
:
RootedObject
jobGlobal
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
RefPtr
<
MicroTaskRunnable
>
runnable
=
new
PromiseJobRunnable
(
aJob
jobGlobal
aAllocationSite
global
)
;
self
-
>
DispatchToMicroTask
(
runnable
.
forget
(
)
)
;
return
true
;
}
void
CycleCollectedJSContext
:
:
PromiseRejectionTrackerCallback
(
JSContext
*
aCx
JS
:
:
HandleObject
aPromise
JS
:
:
PromiseRejectionHandlingState
state
void
*
aData
)
{
#
ifdef
DEBUG
CycleCollectedJSContext
*
self
=
static_cast
<
CycleCollectedJSContext
*
>
(
aData
)
;
#
endif
MOZ_ASSERT
(
aCx
=
=
self
-
>
Context
(
)
)
;
MOZ_ASSERT
(
Get
(
)
=
=
self
)
;
if
(
state
=
=
JS
:
:
PromiseRejectionHandlingState
:
:
Unhandled
)
{
PromiseDebugging
:
:
AddUncaughtRejection
(
aPromise
)
;
}
else
{
PromiseDebugging
:
:
AddConsumedRejection
(
aPromise
)
;
}
}
already_AddRefed
<
Exception
>
CycleCollectedJSContext
:
:
GetPendingException
(
)
const
{
MOZ_ASSERT
(
mJSContext
)
;
nsCOMPtr
<
Exception
>
out
=
mPendingException
;
return
out
.
forget
(
)
;
}
void
CycleCollectedJSContext
:
:
SetPendingException
(
Exception
*
aException
)
{
MOZ_ASSERT
(
mJSContext
)
;
mPendingException
=
aException
;
}
std
:
:
queue
<
RefPtr
<
MicroTaskRunnable
>
>
&
CycleCollectedJSContext
:
:
GetMicroTaskQueue
(
)
{
MOZ_ASSERT
(
mJSContext
)
;
return
mPendingMicroTaskRunnables
;
}
std
:
:
queue
<
RefPtr
<
MicroTaskRunnable
>
>
&
CycleCollectedJSContext
:
:
GetDebuggerMicroTaskQueue
(
)
{
MOZ_ASSERT
(
mJSContext
)
;
return
mDebuggerMicroTaskQueue
;
}
void
CycleCollectedJSContext
:
:
ProcessStableStateQueue
(
)
{
MOZ_ASSERT
(
mJSContext
)
;
MOZ_RELEASE_ASSERT
(
!
mDoingStableStates
)
;
mDoingStableStates
=
true
;
for
(
uint32_t
i
=
0
;
i
<
mStableStateEvents
.
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
mStableStateEvents
[
i
]
.
forget
(
)
;
event
-
>
Run
(
)
;
}
mStableStateEvents
.
Clear
(
)
;
mDoingStableStates
=
false
;
}
void
CycleCollectedJSContext
:
:
CleanupIDBTransactions
(
uint32_t
aRecursionDepth
)
{
MOZ_ASSERT
(
mJSContext
)
;
MOZ_RELEASE_ASSERT
(
!
mDoingStableStates
)
;
mDoingStableStates
=
true
;
nsTArray
<
PendingIDBTransactionData
>
localQueue
=
std
:
:
move
(
mPendingIDBTransactions
)
;
for
(
uint32_t
i
=
0
;
i
<
localQueue
.
Length
(
)
;
+
+
i
)
{
PendingIDBTransactionData
&
data
=
localQueue
[
i
]
;
if
(
data
.
mRecursionDepth
!
=
aRecursionDepth
)
{
continue
;
}
{
nsCOMPtr
<
nsIRunnable
>
transaction
=
data
.
mTransaction
.
forget
(
)
;
transaction
-
>
Run
(
)
;
}
localQueue
.
RemoveElementAt
(
i
-
-
)
;
}
localQueue
.
AppendElements
(
mPendingIDBTransactions
)
;
localQueue
.
SwapElements
(
mPendingIDBTransactions
)
;
mDoingStableStates
=
false
;
}
void
CycleCollectedJSContext
:
:
BeforeProcessTask
(
bool
aMightBlock
)
{
if
(
aMightBlock
&
&
PerformMicroTaskCheckPoint
(
)
)
{
NS_DispatchToMainThread
(
new
Runnable
(
"
BeforeProcessTask
"
)
)
;
}
}
void
CycleCollectedJSContext
:
:
AfterProcessTask
(
uint32_t
aRecursionDepth
)
{
MOZ_ASSERT
(
mJSContext
)
;
PerformMicroTaskCheckPoint
(
)
;
ProcessStableStateQueue
(
)
;
IsIdleGCTaskNeeded
(
)
;
}
void
CycleCollectedJSContext
:
:
AfterProcessMicrotasks
(
)
{
MOZ_ASSERT
(
mJSContext
)
;
CleanupIDBTransactions
(
RecursionDepth
(
)
)
;
}
void
CycleCollectedJSContext
:
:
IsIdleGCTaskNeeded
(
)
{
class
IdleTimeGCTaskRunnable
:
public
mozilla
:
:
IdleRunnable
{
public
:
using
mozilla
:
:
IdleRunnable
:
:
IdleRunnable
;
public
:
NS_IMETHOD
Run
(
)
override
{
CycleCollectedJSRuntime
*
ccrt
=
CycleCollectedJSRuntime
:
:
Get
(
)
;
if
(
ccrt
)
{
ccrt
-
>
RunIdleTimeGCTask
(
)
;
}
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
return
NS_OK
;
}
}
;
if
(
Runtime
(
)
-
>
IsIdleGCTaskNeeded
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
gc_task
=
new
IdleTimeGCTaskRunnable
(
)
;
NS_IdleDispatchToCurrentThread
(
gc_task
.
forget
(
)
)
;
Runtime
(
)
-
>
SetPendingIdleGCTask
(
)
;
}
}
uint32_t
CycleCollectedJSContext
:
:
RecursionDepth
(
)
{
return
mOwningThread
-
>
RecursionDepth
(
)
;
}
void
CycleCollectedJSContext
:
:
RunInStableState
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
MOZ_ASSERT
(
mJSContext
)
;
mStableStateEvents
.
AppendElement
(
std
:
:
move
(
aRunnable
)
)
;
}
void
CycleCollectedJSContext
:
:
AddPendingIDBTransaction
(
already_AddRefed
<
nsIRunnable
>
&
&
aTransaction
)
{
MOZ_ASSERT
(
mJSContext
)
;
PendingIDBTransactionData
data
;
data
.
mTransaction
=
aTransaction
;
MOZ_ASSERT
(
mOwningThread
)
;
data
.
mRecursionDepth
=
RecursionDepth
(
)
;
#
ifndef
MOZ_WIDGET_COCOA
MOZ_ASSERT
(
data
.
mRecursionDepth
>
mBaseRecursionDepth
)
;
#
else
if
(
data
.
mRecursionDepth
<
=
mBaseRecursionDepth
)
{
data
.
mRecursionDepth
=
mBaseRecursionDepth
+
1
;
}
#
endif
mPendingIDBTransactions
.
AppendElement
(
std
:
:
move
(
data
)
)
;
}
void
CycleCollectedJSContext
:
:
DispatchToMicroTask
(
already_AddRefed
<
MicroTaskRunnable
>
aRunnable
)
{
RefPtr
<
MicroTaskRunnable
>
runnable
(
aRunnable
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
runnable
)
;
JS
:
:
JobQueueMayNotBeEmpty
(
Context
(
)
)
;
mPendingMicroTaskRunnables
.
push
(
runnable
.
forget
(
)
)
;
}
class
AsyncMutationHandler
final
:
public
mozilla
:
:
Runnable
{
public
:
AsyncMutationHandler
(
)
:
mozilla
:
:
Runnable
(
"
AsyncMutationHandler
"
)
{
}
NS_IMETHOD
Run
(
)
override
{
CycleCollectedJSContext
*
ccjs
=
CycleCollectedJSContext
:
:
Get
(
)
;
if
(
ccjs
)
{
ccjs
-
>
PerformMicroTaskCheckPoint
(
)
;
}
return
NS_OK
;
}
}
;
bool
CycleCollectedJSContext
:
:
PerformMicroTaskCheckPoint
(
bool
aForce
)
{
if
(
mPendingMicroTaskRunnables
.
empty
(
)
&
&
mDebuggerMicroTaskQueue
.
empty
(
)
)
{
AfterProcessMicrotasks
(
)
;
return
false
;
}
uint32_t
currentDepth
=
RecursionDepth
(
)
;
if
(
mMicroTaskRecursionDepth
>
=
currentDepth
&
&
!
aForce
)
{
return
false
;
}
if
(
mTargetedMicroTaskRecursionDepth
!
=
0
&
&
mTargetedMicroTaskRecursionDepth
!
=
currentDepth
)
{
return
false
;
}
if
(
NS_IsMainThread
(
)
&
&
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
AsyncMutationHandler
(
)
)
;
return
false
;
}
mozilla
:
:
AutoRestore
<
uint32_t
>
restore
(
mMicroTaskRecursionDepth
)
;
MOZ_ASSERT
(
aForce
?
currentDepth
=
=
0
:
currentDepth
>
0
)
;
mMicroTaskRecursionDepth
=
currentDepth
;
bool
didProcess
=
false
;
AutoSlowOperation
aso
;
std
:
:
queue
<
RefPtr
<
MicroTaskRunnable
>
>
suppressed
;
for
(
;
;
)
{
RefPtr
<
MicroTaskRunnable
>
runnable
;
if
(
!
mDebuggerMicroTaskQueue
.
empty
(
)
)
{
runnable
=
mDebuggerMicroTaskQueue
.
front
(
)
.
forget
(
)
;
mDebuggerMicroTaskQueue
.
pop
(
)
;
}
else
if
(
!
mPendingMicroTaskRunnables
.
empty
(
)
)
{
runnable
=
mPendingMicroTaskRunnables
.
front
(
)
.
forget
(
)
;
mPendingMicroTaskRunnables
.
pop
(
)
;
}
else
{
break
;
}
if
(
runnable
-
>
Suppressed
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
JS
:
:
JobQueueMayNotBeEmpty
(
Context
(
)
)
;
suppressed
.
push
(
runnable
)
;
}
else
{
if
(
mPendingMicroTaskRunnables
.
empty
(
)
&
&
mDebuggerMicroTaskQueue
.
empty
(
)
&
&
suppressed
.
empty
(
)
)
{
JS
:
:
JobQueueIsEmpty
(
Context
(
)
)
;
}
didProcess
=
true
;
runnable
-
>
Run
(
aso
)
;
}
}
mPendingMicroTaskRunnables
.
swap
(
suppressed
)
;
AfterProcessMicrotasks
(
)
;
return
didProcess
;
}
void
CycleCollectedJSContext
:
:
PerformDebuggerMicroTaskCheckpoint
(
)
{
AutoSlowOperation
aso
;
for
(
;
;
)
{
std
:
:
queue
<
RefPtr
<
MicroTaskRunnable
>
>
*
microtaskQueue
=
&
GetDebuggerMicroTaskQueue
(
)
;
if
(
microtaskQueue
-
>
empty
(
)
)
{
break
;
}
RefPtr
<
MicroTaskRunnable
>
runnable
=
microtaskQueue
-
>
front
(
)
.
forget
(
)
;
MOZ_ASSERT
(
runnable
)
;
microtaskQueue
-
>
pop
(
)
;
if
(
mPendingMicroTaskRunnables
.
empty
(
)
&
&
mDebuggerMicroTaskQueue
.
empty
(
)
)
{
JS
:
:
JobQueueIsEmpty
(
Context
(
)
)
;
}
runnable
-
>
Run
(
aso
)
;
}
AfterProcessMicrotasks
(
)
;
}
}
