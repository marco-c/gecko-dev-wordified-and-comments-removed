#
ifndef
mozilla_StaticMutex_h
#
define
mozilla_StaticMutex_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
namespace
mozilla
{
class
MOZ_ONLY_USED_TO_AVOID_STATIC_CONSTRUCTORS
StaticMutex
{
public
:
#
ifdef
DEBUG
StaticMutex
(
)
{
MOZ_ASSERT
(
!
mMutex
)
;
}
#
endif
void
Lock
(
)
{
Mutex
(
)
-
>
Lock
(
)
;
}
void
Unlock
(
)
{
Mutex
(
)
-
>
Unlock
(
)
;
}
void
AssertCurrentThreadOwns
(
)
{
#
ifdef
DEBUG
Mutex
(
)
-
>
AssertCurrentThreadOwns
(
)
;
#
endif
}
private
:
OffTheBooksMutex
*
Mutex
(
)
{
if
(
mMutex
)
{
return
mMutex
;
}
OffTheBooksMutex
*
mutex
=
new
OffTheBooksMutex
(
"
StaticMutex
"
)
;
if
(
!
mMutex
.
compareExchange
(
nullptr
mutex
)
)
{
delete
mutex
;
}
return
mMutex
;
}
Atomic
<
OffTheBooksMutex
*
SequentiallyConsistent
>
mMutex
;
#
ifdef
DEBUG
StaticMutex
(
StaticMutex
&
aOther
)
;
#
endif
StaticMutex
&
operator
=
(
StaticMutex
*
aRhs
)
;
static
void
*
operator
new
(
size_t
)
noexcept
(
true
)
;
static
void
operator
delete
(
void
*
)
;
}
;
class
MOZ_STACK_CLASS
AnyStaticMutex
{
public
:
MOZ_IMPLICIT
AnyStaticMutex
(
StaticMutex
&
aMutex
)
:
mStaticMutex
(
&
aMutex
)
{
}
void
Lock
(
)
{
mStaticMutex
-
>
Lock
(
)
;
}
void
Unlock
(
)
{
mStaticMutex
-
>
Unlock
(
)
;
}
private
:
StaticMutex
*
mStaticMutex
;
}
;
typedef
detail
:
:
BaseAutoLock
<
AnyStaticMutex
>
StaticMutexAutoLock
;
typedef
detail
:
:
BaseAutoUnlock
<
AnyStaticMutex
>
StaticMutexAutoUnlock
;
}
#
endif
