#
ifndef
mozilla_StaticMutex_h
#
define
mozilla_StaticMutex_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
namespace
mozilla
{
template
<
recordreplay
:
:
Behavior
Recording
>
class
MOZ_ONLY_USED_TO_AVOID_STATIC_CONSTRUCTORS
BaseStaticMutex
{
public
:
#
ifdef
DEBUG
BaseStaticMutex
(
)
{
MOZ_ASSERT
(
!
mMutex
)
;
}
#
endif
void
Lock
(
)
{
Mutex
(
)
-
>
Lock
(
)
;
}
void
Unlock
(
)
{
Mutex
(
)
-
>
Unlock
(
)
;
}
void
AssertCurrentThreadOwns
(
)
{
#
ifdef
DEBUG
Mutex
(
)
-
>
AssertCurrentThreadOwns
(
)
;
#
endif
}
private
:
OffTheBooksMutex
*
Mutex
(
)
{
if
(
mMutex
)
{
return
mMutex
;
}
OffTheBooksMutex
*
mutex
=
new
OffTheBooksMutex
(
"
StaticMutex
"
Recording
)
;
if
(
!
mMutex
.
compareExchange
(
nullptr
mutex
)
)
{
delete
mutex
;
}
return
mMutex
;
}
Atomic
<
OffTheBooksMutex
*
SequentiallyConsistent
Recording
>
mMutex
;
#
ifdef
DEBUG
BaseStaticMutex
(
BaseStaticMutex
&
aOther
)
;
#
endif
BaseStaticMutex
&
operator
=
(
BaseStaticMutex
*
aRhs
)
;
static
void
*
operator
new
(
size_t
)
CPP_THROW_NEW
;
static
void
operator
delete
(
void
*
)
;
}
;
typedef
BaseStaticMutex
<
recordreplay
:
:
Behavior
:
:
Preserve
>
StaticMutex
;
typedef
BaseStaticMutex
<
recordreplay
:
:
Behavior
:
:
DontPreserve
>
StaticMutexNotRecorded
;
class
MOZ_STACK_CLASS
AnyStaticMutex
{
public
:
MOZ_IMPLICIT
AnyStaticMutex
(
StaticMutex
&
aMutex
)
:
mStaticMutex
(
&
aMutex
)
mStaticMutexNotRecorded
(
nullptr
)
{
}
MOZ_IMPLICIT
AnyStaticMutex
(
StaticMutexNotRecorded
&
aMutex
)
:
mStaticMutex
(
nullptr
)
mStaticMutexNotRecorded
(
&
aMutex
)
{
}
void
Lock
(
)
{
if
(
mStaticMutex
)
{
mStaticMutex
-
>
Lock
(
)
;
}
else
{
mStaticMutexNotRecorded
-
>
Lock
(
)
;
}
}
void
Unlock
(
)
{
if
(
mStaticMutex
)
{
mStaticMutex
-
>
Unlock
(
)
;
}
else
{
mStaticMutexNotRecorded
-
>
Unlock
(
)
;
}
}
private
:
StaticMutex
*
mStaticMutex
;
StaticMutexNotRecorded
*
mStaticMutexNotRecorded
;
}
;
typedef
BaseAutoLock
<
AnyStaticMutex
>
StaticMutexAutoLock
;
typedef
BaseAutoUnlock
<
AnyStaticMutex
>
StaticMutexAutoUnlock
;
}
#
endif
