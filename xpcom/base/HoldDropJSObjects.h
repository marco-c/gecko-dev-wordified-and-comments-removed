#
ifndef
mozilla_HoldDropJSObjects_h
#
define
mozilla_HoldDropJSObjects_h
#
include
<
type_traits
>
#
include
"
nsCycleCollectionNoteChild
.
h
"
class
nsISupports
;
class
nsScriptObjectTracer
;
class
nsCycleCollectionParticipant
;
namespace
JS
{
class
Zone
;
}
namespace
mozilla
{
class
JSHolderList
;
struct
JSHolderListEntry
;
class
JSHolderKey
{
friend
class
JSHolderList
;
JSHolderListEntry
*
mEntry
=
nullptr
;
}
;
class
JSHolderBase
{
public
:
JSHolderKey
mJSHolderKey
;
}
;
namespace
cyclecollector
{
void
HoldJSObjectsImpl
(
void
*
aHolder
nsScriptObjectTracer
*
aTracer
JS
:
:
Zone
*
aZone
=
nullptr
)
;
void
HoldJSObjectsWithKeyImpl
(
void
*
aHolder
nsScriptObjectTracer
*
aTracer
JSHolderKey
*
aKey
)
;
void
HoldJSObjectsImpl
(
nsISupports
*
aHolder
)
;
void
HoldJSObjectsWithKeyImpl
(
nsISupports
*
aHolder
JSHolderKey
*
aKey
)
;
void
DropJSObjectsImpl
(
void
*
aHolder
)
;
void
DropJSObjectsWithKeyImpl
(
void
*
aHolder
JSHolderKey
*
aKey
)
;
void
DropJSObjectsImpl
(
nsISupports
*
aHolder
)
;
void
DropJSObjectsWithKeyImpl
(
nsISupports
*
aHolder
JSHolderKey
*
aKey
)
;
}
template
<
class
T
bool
isISupports
=
std
:
:
is_base_of_v
<
nsISupports
T
>
typename
P
=
typename
T
:
:
NS_CYCLE_COLLECTION_INNERCLASS
>
struct
HoldDropJSObjectsHelper
{
static
void
Hold
(
T
*
aHolder
)
{
cyclecollector
:
:
HoldJSObjectsImpl
(
aHolder
NS_CYCLE_COLLECTION_PARTICIPANT
(
T
)
)
;
}
static
void
Drop
(
T
*
aHolder
)
{
cyclecollector
:
:
DropJSObjectsImpl
(
aHolder
)
;
}
}
;
template
<
class
T
>
struct
HoldDropJSObjectsHelper
<
T
true
>
{
static
void
Hold
(
T
*
aHolder
)
{
cyclecollector
:
:
HoldJSObjectsImpl
(
ToSupports
(
aHolder
)
)
;
}
static
void
Drop
(
T
*
aHolder
)
{
cyclecollector
:
:
DropJSObjectsImpl
(
ToSupports
(
aHolder
)
)
;
}
}
;
template
<
class
T
bool
isISupports
=
std
:
:
is_base_of_v
<
nsISupports
T
>
typename
P
=
typename
T
:
:
NS_CYCLE_COLLECTION_INNERCLASS
>
struct
HoldDropJSObjectsWithKeyHelper
{
static
void
Hold
(
T
*
aHolder
)
{
cyclecollector
:
:
HoldJSObjectsWithKeyImpl
(
aHolder
NS_CYCLE_COLLECTION_PARTICIPANT
(
T
)
&
aHolder
-
>
mJSHolderKey
)
;
}
static
void
Drop
(
T
*
aHolder
)
{
cyclecollector
:
:
DropJSObjectsWithKeyImpl
(
aHolder
&
aHolder
-
>
mJSHolderKey
)
;
}
}
;
template
<
class
T
>
struct
HoldDropJSObjectsWithKeyHelper
<
T
true
>
{
static
void
Hold
(
T
*
aHolder
)
{
cyclecollector
:
:
HoldJSObjectsWithKeyImpl
(
ToSupports
(
aHolder
)
&
aHolder
-
>
mJSHolderKey
)
;
}
static
void
Drop
(
T
*
aHolder
)
{
cyclecollector
:
:
DropJSObjectsWithKeyImpl
(
ToSupports
(
aHolder
)
&
aHolder
-
>
mJSHolderKey
)
;
}
}
;
template
<
class
T
>
void
HoldJSObjects
(
T
*
aHolder
)
{
static_assert
(
!
std
:
:
is_base_of
<
nsCycleCollectionParticipant
T
>
:
:
value
"
Don
'
t
call
this
on
the
CC
participant
but
on
the
object
that
"
"
it
'
s
for
(
in
an
Unlink
implementation
it
'
s
usually
stored
in
"
"
a
variable
named
'
tmp
'
)
.
"
)
;
HoldDropJSObjectsHelper
<
T
>
:
:
Hold
(
aHolder
)
;
}
template
<
class
T
>
void
DropJSObjects
(
T
*
aHolder
)
{
static_assert
(
!
std
:
:
is_base_of
<
nsCycleCollectionParticipant
T
>
:
:
value
"
Don
'
t
call
this
on
the
CC
participant
but
on
the
object
that
"
"
it
'
s
for
(
in
an
Unlink
implementation
it
'
s
usually
stored
in
"
"
a
variable
named
'
tmp
'
)
.
"
)
;
HoldDropJSObjectsHelper
<
T
>
:
:
Drop
(
aHolder
)
;
}
template
<
class
T
>
void
HoldJSObjectsWithKey
(
T
*
aHolder
)
{
HoldDropJSObjectsWithKeyHelper
<
T
>
:
:
Hold
(
aHolder
)
;
}
template
<
class
T
>
void
DropJSObjectsWithKey
(
T
*
aHolder
)
{
HoldDropJSObjectsWithKeyHelper
<
T
>
:
:
Drop
(
aHolder
)
;
}
}
#
endif
