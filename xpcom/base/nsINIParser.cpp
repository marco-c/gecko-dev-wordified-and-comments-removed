#
include
"
nsCRTGlue
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsINIParser
.
h
"
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
URLPreloader
.
h
"
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
endif
using
namespace
mozilla
;
#
ifdef
XP_WIN
inline
FILE
*
TS_tfopen
(
const
char
*
aPath
const
wchar_t
*
aMode
)
{
wchar_t
wPath
[
MAX_PATH
]
;
MultiByteToWideChar
(
CP_UTF8
0
aPath
-
1
wPath
MAX_PATH
)
;
return
_wfopen
(
wPath
aMode
)
;
}
#
else
inline
FILE
*
TS_tfopen
(
const
char
*
aPath
const
char
*
aMode
)
{
return
fopen
(
aPath
aMode
)
;
}
#
endif
class
AutoFILE
{
public
:
explicit
AutoFILE
(
FILE
*
aFp
=
nullptr
)
:
fp_
(
aFp
)
{
}
~
AutoFILE
(
)
{
if
(
fp_
)
{
fclose
(
fp_
)
;
}
}
operator
FILE
*
(
)
{
return
fp_
;
}
FILE
*
*
operator
&
(
)
{
return
&
fp_
;
}
void
operator
=
(
FILE
*
aFp
)
{
fp_
=
aFp
;
}
private
:
FILE
*
fp_
;
}
;
nsresult
nsINIParser
:
:
Init
(
nsIFile
*
aFile
)
{
nsCString
result
;
MOZ_TRY_VAR
(
result
URLPreloader
:
:
ReadFile
(
aFile
)
)
;
return
InitFromString
(
result
)
;
}
nsresult
nsINIParser
:
:
Init
(
const
char
*
aPath
)
{
nsCString
result
;
MOZ_TRY_VAR
(
result
URLPreloader
:
:
ReadFile
(
nsDependentCString
(
aPath
)
)
)
;
return
InitFromString
(
result
)
;
}
static
const
char
kNL
[
]
=
"
\
r
\
n
"
;
static
const
char
kEquals
[
]
=
"
=
"
;
static
const
char
kWhitespace
[
]
=
"
\
t
"
;
static
const
char
kRBracket
[
]
=
"
]
"
;
nsresult
nsINIParser
:
:
InitFromString
(
const
nsCString
&
aStr
)
{
char
*
buffer
;
if
(
StringHead
(
aStr
3
)
=
=
"
\
xEF
\
xBB
\
xBF
"
)
{
mFileContents
.
Append
(
aStr
)
;
buffer
=
mFileContents
.
BeginWriting
(
)
+
3
;
}
else
{
if
(
StringHead
(
aStr
2
)
=
=
"
\
xFF
\
xFE
"
)
{
nsDependentSubstring
str
(
reinterpret_cast
<
const
char16_t
*
>
(
aStr
.
get
(
)
)
aStr
.
Length
(
)
/
2
)
;
AppendUTF16toUTF8
(
Substring
(
str
1
)
mFileContents
)
;
}
else
{
mFileContents
.
Append
(
aStr
)
;
}
buffer
=
mFileContents
.
BeginWriting
(
)
;
}
char
*
currSection
=
nullptr
;
while
(
char
*
token
=
NS_strtok
(
kNL
&
buffer
)
)
{
if
(
token
[
0
]
=
=
'
#
'
|
|
token
[
0
]
=
=
'
;
'
)
{
continue
;
}
token
=
(
char
*
)
NS_strspnp
(
kWhitespace
token
)
;
if
(
!
*
token
)
{
continue
;
}
if
(
token
[
0
]
=
=
'
[
'
)
{
+
+
token
;
currSection
=
token
;
char
*
rb
=
NS_strtok
(
kRBracket
&
token
)
;
if
(
!
rb
|
|
NS_strtok
(
kWhitespace
&
token
)
)
{
currSection
=
nullptr
;
}
continue
;
}
if
(
!
currSection
)
{
continue
;
}
char
*
key
=
token
;
char
*
e
=
NS_strtok
(
kEquals
&
token
)
;
if
(
!
e
|
|
!
token
)
{
continue
;
}
INIValue
*
v
;
if
(
!
mSections
.
Get
(
currSection
&
v
)
)
{
v
=
new
INIValue
(
key
token
)
;
if
(
!
v
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mSections
.
Put
(
currSection
v
)
;
continue
;
}
while
(
v
)
{
if
(
!
strcmp
(
key
v
-
>
key
)
)
{
v
-
>
value
=
token
;
break
;
}
if
(
!
v
-
>
next
)
{
v
-
>
next
=
MakeUnique
<
INIValue
>
(
key
token
)
;
if
(
!
v
-
>
next
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
break
;
}
v
=
v
-
>
next
.
get
(
)
;
}
NS_ASSERTION
(
v
"
v
should
never
be
null
coming
out
of
this
loop
"
)
;
}
return
NS_OK
;
}
nsresult
nsINIParser
:
:
GetString
(
const
char
*
aSection
const
char
*
aKey
nsACString
&
aResult
)
{
INIValue
*
val
;
mSections
.
Get
(
aSection
&
val
)
;
while
(
val
)
{
if
(
strcmp
(
val
-
>
key
aKey
)
=
=
0
)
{
aResult
.
Assign
(
val
-
>
value
)
;
return
NS_OK
;
}
val
=
val
-
>
next
.
get
(
)
;
}
return
NS_ERROR_FAILURE
;
}
nsresult
nsINIParser
:
:
GetString
(
const
char
*
aSection
const
char
*
aKey
char
*
aResult
uint32_t
aResultLen
)
{
INIValue
*
val
;
mSections
.
Get
(
aSection
&
val
)
;
while
(
val
)
{
if
(
strcmp
(
val
-
>
key
aKey
)
=
=
0
)
{
strncpy
(
aResult
val
-
>
value
aResultLen
)
;
aResult
[
aResultLen
-
1
]
=
'
\
0
'
;
if
(
strlen
(
val
-
>
value
)
>
=
aResultLen
)
{
return
NS_ERROR_LOSS_OF_SIGNIFICANT_DATA
;
}
return
NS_OK
;
}
val
=
val
-
>
next
.
get
(
)
;
}
return
NS_ERROR_FAILURE
;
}
nsresult
nsINIParser
:
:
GetSections
(
INISectionCallback
aCB
void
*
aClosure
)
{
for
(
auto
iter
=
mSections
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
!
aCB
(
iter
.
Key
(
)
aClosure
)
)
{
break
;
}
}
return
NS_OK
;
}
nsresult
nsINIParser
:
:
GetStrings
(
const
char
*
aSection
INIStringCallback
aCB
void
*
aClosure
)
{
INIValue
*
val
;
for
(
mSections
.
Get
(
aSection
&
val
)
;
val
;
val
=
val
-
>
next
.
get
(
)
)
{
if
(
!
aCB
(
val
-
>
key
val
-
>
value
aClosure
)
)
{
return
NS_OK
;
}
}
return
NS_OK
;
}
