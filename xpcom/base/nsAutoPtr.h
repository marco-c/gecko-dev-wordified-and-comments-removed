#
ifndef
nsAutoPtr_h
#
define
nsAutoPtr_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
nsCycleCollectionNoteChild
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
template
<
class
T
>
class
nsAutoPtr
{
private
:
static_assert
(
!
mozilla
:
:
IsScalar
<
T
>
:
:
value
"
If
you
are
using
"
"
nsAutoPtr
to
hold
an
array
use
UniquePtr
<
T
[
]
>
instead
"
)
;
void
*
*
begin_assignment
(
)
{
assign
(
0
)
;
return
reinterpret_cast
<
void
*
*
>
(
&
mRawPtr
)
;
}
void
assign
(
T
*
aNewPtr
)
{
T
*
oldPtr
=
mRawPtr
;
if
(
aNewPtr
&
&
aNewPtr
=
=
oldPtr
)
{
MOZ_CRASH
(
"
Logic
flaw
in
the
caller
"
)
;
}
mRawPtr
=
aNewPtr
;
delete
oldPtr
;
}
class
Ptr
{
public
:
MOZ_IMPLICIT
Ptr
(
T
*
aPtr
)
:
mPtr
(
aPtr
)
{
}
operator
T
*
(
)
const
{
return
mPtr
;
}
private
:
T
*
MOZ_NON_OWNING_REF
mPtr
;
}
;
private
:
T
*
MOZ_OWNING_REF
mRawPtr
;
public
:
typedef
T
element_type
;
~
nsAutoPtr
(
)
{
delete
mRawPtr
;
}
nsAutoPtr
(
)
:
mRawPtr
(
0
)
{
}
MOZ_IMPLICIT
nsAutoPtr
(
Ptr
aRawPtr
)
:
mRawPtr
(
aRawPtr
)
{
}
nsAutoPtr
(
nsAutoPtr
<
T
>
&
aSmartPtr
)
:
mRawPtr
(
aSmartPtr
.
forget
(
)
)
{
}
template
<
typename
I
>
MOZ_IMPLICIT
nsAutoPtr
(
nsAutoPtr
<
I
>
&
aSmartPtr
)
:
mRawPtr
(
aSmartPtr
.
forget
(
)
)
{
}
nsAutoPtr
(
nsAutoPtr
<
T
>
&
&
aSmartPtr
)
:
mRawPtr
(
aSmartPtr
.
forget
(
)
)
{
}
template
<
typename
I
>
MOZ_IMPLICIT
nsAutoPtr
(
nsAutoPtr
<
I
>
&
&
aSmartPtr
)
:
mRawPtr
(
aSmartPtr
.
forget
(
)
)
{
}
nsAutoPtr
<
T
>
&
operator
=
(
T
*
aRhs
)
{
assign
(
aRhs
)
;
return
*
this
;
}
nsAutoPtr
<
T
>
&
operator
=
(
nsAutoPtr
<
T
>
&
aRhs
)
{
assign
(
aRhs
.
forget
(
)
)
;
return
*
this
;
}
template
<
typename
I
>
nsAutoPtr
<
T
>
&
operator
=
(
nsAutoPtr
<
I
>
&
aRhs
)
{
assign
(
aRhs
.
forget
(
)
)
;
return
*
this
;
}
nsAutoPtr
<
T
>
&
operator
=
(
nsAutoPtr
<
T
>
&
&
aRhs
)
{
assign
(
aRhs
.
forget
(
)
)
;
return
*
this
;
}
template
<
typename
I
>
nsAutoPtr
<
T
>
&
operator
=
(
nsAutoPtr
<
I
>
&
&
aRhs
)
{
assign
(
aRhs
.
forget
(
)
)
;
return
*
this
;
}
T
*
get
(
)
const
{
return
mRawPtr
;
}
operator
T
*
(
)
const
{
return
get
(
)
;
}
T
*
forget
(
)
{
T
*
temp
=
mRawPtr
;
mRawPtr
=
0
;
return
temp
;
}
T
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mRawPtr
!
=
0
"
You
can
'
t
dereference
a
NULL
nsAutoPtr
with
operator
-
>
(
)
.
"
)
;
return
get
(
)
;
}
template
<
typename
R
typename
.
.
.
Args
>
class
Proxy
{
typedef
R
(
T
:
:
*
member_function
)
(
Args
.
.
.
)
;
T
*
mRawPtr
;
member_function
mFunction
;
public
:
Proxy
(
T
*
aRawPtr
member_function
aFunction
)
:
mRawPtr
(
aRawPtr
)
mFunction
(
aFunction
)
{
}
template
<
typename
.
.
.
ActualArgs
>
R
operator
(
)
(
ActualArgs
&
&
.
.
.
aArgs
)
{
return
(
(
*
mRawPtr
)
.
*
mFunction
)
(
std
:
:
forward
<
ActualArgs
>
(
aArgs
)
.
.
.
)
;
}
}
;
template
<
typename
R
typename
C
typename
.
.
.
Args
>
Proxy
<
R
Args
.
.
.
>
operator
-
>
*
(
R
(
C
:
:
*
aFptr
)
(
Args
.
.
.
)
)
const
{
MOZ_ASSERT
(
mRawPtr
!
=
0
"
You
can
'
t
dereference
a
NULL
nsAutoPtr
with
operator
-
>
*
(
)
.
"
)
;
return
Proxy
<
R
Args
.
.
.
>
(
get
(
)
aFptr
)
;
}
nsAutoPtr
<
T
>
*
get_address
(
)
{
return
this
;
}
const
nsAutoPtr
<
T
>
*
get_address
(
)
const
{
return
this
;
}
public
:
T
&
operator
*
(
)
const
{
MOZ_ASSERT
(
mRawPtr
!
=
0
"
You
can
'
t
dereference
a
NULL
nsAutoPtr
with
operator
*
(
)
.
"
)
;
return
*
get
(
)
;
}
T
*
*
StartAssignment
(
)
{
#
ifndef
NSCAP_FEATURE_INLINE_STARTASSIGNMENT
return
reinterpret_cast
<
T
*
*
>
(
begin_assignment
(
)
)
;
#
else
assign
(
0
)
;
return
reinterpret_cast
<
T
*
*
>
(
&
mRawPtr
)
;
#
endif
}
}
;
template
<
class
T
>
inline
nsAutoPtr
<
T
>
*
address_of
(
nsAutoPtr
<
T
>
&
aPtr
)
{
return
aPtr
.
get_address
(
)
;
}
template
<
class
T
>
inline
const
nsAutoPtr
<
T
>
*
address_of
(
const
nsAutoPtr
<
T
>
&
aPtr
)
{
return
aPtr
.
get_address
(
)
;
}
template
<
class
T
>
class
nsAutoPtrGetterTransfers
{
public
:
explicit
nsAutoPtrGetterTransfers
(
nsAutoPtr
<
T
>
&
aSmartPtr
)
:
mTargetSmartPtr
(
aSmartPtr
)
{
}
operator
void
*
*
(
)
{
return
reinterpret_cast
<
void
*
*
>
(
mTargetSmartPtr
.
StartAssignment
(
)
)
;
}
operator
T
*
*
(
)
{
return
mTargetSmartPtr
.
StartAssignment
(
)
;
}
T
*
&
operator
*
(
)
{
return
*
(
mTargetSmartPtr
.
StartAssignment
(
)
)
;
}
private
:
nsAutoPtr
<
T
>
&
mTargetSmartPtr
;
}
;
template
<
class
T
>
inline
nsAutoPtrGetterTransfers
<
T
>
getter_Transfers
(
nsAutoPtr
<
T
>
&
aSmartPtr
)
{
return
nsAutoPtrGetterTransfers
<
T
>
(
aSmartPtr
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
=
=
(
const
nsAutoPtr
<
T
>
&
aLhs
const
nsAutoPtr
<
U
>
&
aRhs
)
{
return
static_cast
<
const
T
*
>
(
aLhs
.
get
(
)
)
=
=
static_cast
<
const
U
*
>
(
aRhs
.
get
(
)
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
!
=
(
const
nsAutoPtr
<
T
>
&
aLhs
const
nsAutoPtr
<
U
>
&
aRhs
)
{
return
static_cast
<
const
T
*
>
(
aLhs
.
get
(
)
)
!
=
static_cast
<
const
U
*
>
(
aRhs
.
get
(
)
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
=
=
(
const
nsAutoPtr
<
T
>
&
aLhs
const
U
*
aRhs
)
{
return
static_cast
<
const
T
*
>
(
aLhs
.
get
(
)
)
=
=
static_cast
<
const
U
*
>
(
aRhs
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
=
=
(
const
U
*
aLhs
const
nsAutoPtr
<
T
>
&
aRhs
)
{
return
static_cast
<
const
U
*
>
(
aLhs
)
=
=
static_cast
<
const
T
*
>
(
aRhs
.
get
(
)
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
!
=
(
const
nsAutoPtr
<
T
>
&
aLhs
const
U
*
aRhs
)
{
return
static_cast
<
const
T
*
>
(
aLhs
.
get
(
)
)
!
=
static_cast
<
const
U
*
>
(
aRhs
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
!
=
(
const
U
*
aLhs
const
nsAutoPtr
<
T
>
&
aRhs
)
{
return
static_cast
<
const
U
*
>
(
aLhs
)
!
=
static_cast
<
const
T
*
>
(
aRhs
.
get
(
)
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
=
=
(
const
nsAutoPtr
<
T
>
&
aLhs
U
*
aRhs
)
{
return
static_cast
<
const
T
*
>
(
aLhs
.
get
(
)
)
=
=
const_cast
<
const
U
*
>
(
aRhs
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
=
=
(
U
*
aLhs
const
nsAutoPtr
<
T
>
&
aRhs
)
{
return
const_cast
<
const
U
*
>
(
aLhs
)
=
=
static_cast
<
const
T
*
>
(
aRhs
.
get
(
)
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
!
=
(
const
nsAutoPtr
<
T
>
&
aLhs
U
*
aRhs
)
{
return
static_cast
<
const
T
*
>
(
aLhs
.
get
(
)
)
!
=
const_cast
<
const
U
*
>
(
aRhs
)
;
}
template
<
class
T
class
U
>
inline
bool
operator
!
=
(
U
*
aLhs
const
nsAutoPtr
<
T
>
&
aRhs
)
{
return
const_cast
<
const
U
*
>
(
aLhs
)
!
=
static_cast
<
const
T
*
>
(
aRhs
.
get
(
)
)
;
}
template
<
class
T
>
inline
bool
operator
=
=
(
const
nsAutoPtr
<
T
>
&
aLhs
decltype
(
nullptr
)
)
{
return
aLhs
.
get
(
)
=
=
nullptr
;
}
template
<
class
T
>
inline
bool
operator
=
=
(
decltype
(
nullptr
)
const
nsAutoPtr
<
T
>
&
aRhs
)
{
return
nullptr
=
=
aRhs
.
get
(
)
;
}
template
<
class
T
>
inline
bool
operator
!
=
(
const
nsAutoPtr
<
T
>
&
aLhs
decltype
(
nullptr
)
)
{
return
aLhs
.
get
(
)
!
=
nullptr
;
}
template
<
class
T
>
inline
bool
operator
!
=
(
decltype
(
nullptr
)
const
nsAutoPtr
<
T
>
&
aRhs
)
{
return
nullptr
!
=
aRhs
.
get
(
)
;
}
#
endif
