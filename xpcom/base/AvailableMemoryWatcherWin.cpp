#
include
"
AvailableMemoryWatcher
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsICrashReporter
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsMemoryPressure
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
<
memoryapi
.
h
>
extern
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
MemoryOrdering
:
:
Relaxed
>
sNumLowPhysicalMemEvents
;
namespace
mozilla
{
class
nsAvailableMemoryWatcher
final
:
public
nsIObserver
public
nsITimerCallback
public
nsINamed
public
nsAvailableMemoryWatcherBase
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIOBSERVER
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
nsAvailableMemoryWatcher
(
)
;
nsresult
Init
(
uint32_t
aPollingInterval
)
;
private
:
static
const
char
*
const
kObserverTopics
[
]
;
static
VOID
CALLBACK
LowMemoryCallback
(
PVOID
aContext
BOOLEAN
aIsTimer
)
;
static
void
RecordLowMemoryEvent
(
)
;
static
bool
IsCommitSpaceLow
(
)
;
~
nsAvailableMemoryWatcher
(
)
;
bool
RegisterMemoryResourceHandler
(
)
;
void
UnregisterMemoryResourceHandler
(
)
;
void
MaybeSaveMemoryReport
(
const
MutexAutoLock
&
)
;
void
Shutdown
(
const
MutexAutoLock
&
)
;
bool
ListenForLowMemory
(
const
MutexAutoLock
&
)
;
void
OnLowMemory
(
const
MutexAutoLock
&
)
;
void
OnHighMemory
(
const
MutexAutoLock
&
)
;
void
StartPollingIfUserInteracting
(
const
MutexAutoLock
&
)
;
void
StopPolling
(
)
;
void
StopPollingIfUserIdle
(
const
MutexAutoLock
&
)
;
void
OnUserInteracting
(
const
MutexAutoLock
&
)
;
void
OnUserIdle
(
const
MutexAutoLock
&
)
;
Mutex
mMutex
;
nsCOMPtr
<
nsITimer
>
mTimer
;
nsAutoHandle
mLowMemoryHandle
;
HANDLE
mWaitHandle
;
bool
mPolling
;
bool
mInteracting
;
bool
mNeedToRestartTimerOnUserInteracting
;
bool
mUnderMemoryPressure
;
bool
mSavedReport
;
bool
mIsShutdown
;
bool
mInitialized
;
uint32_t
mPollingInterval
;
nsCOMPtr
<
nsIObserverService
>
mObserverSvc
;
}
;
const
char
*
const
nsAvailableMemoryWatcher
:
:
kObserverTopics
[
]
=
{
"
xpcom
-
shutdown
"
"
user
-
interaction
-
active
"
"
user
-
interaction
-
inactive
"
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
nsAvailableMemoryWatcher
nsAvailableMemoryWatcherBase
nsIObserver
nsITimerCallback
nsINamed
)
nsAvailableMemoryWatcher
:
:
nsAvailableMemoryWatcher
(
)
:
mMutex
(
"
low
memory
callback
mutex
"
)
mWaitHandle
(
nullptr
)
mPolling
(
false
)
mInteracting
(
false
)
mNeedToRestartTimerOnUserInteracting
(
false
)
mUnderMemoryPressure
(
false
)
mSavedReport
(
false
)
mIsShutdown
(
false
)
mInitialized
(
false
)
mPollingInterval
(
0
)
{
}
nsresult
nsAvailableMemoryWatcher
:
:
Init
(
uint32_t
aPollingInterval
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
nsAvailableMemoryWatcher
needs
to
be
initialized
in
the
main
thread
.
"
)
;
if
(
mInitialized
)
{
return
NS_ERROR_ALREADY_INITIALIZED
;
}
mTimer
=
NS_NewTimer
(
)
;
if
(
!
mTimer
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mObserverSvc
=
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
mObserverSvc
)
;
mPollingInterval
=
aPollingInterval
;
if
(
!
RegisterMemoryResourceHandler
(
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
auto
topic
:
kObserverTopics
)
{
nsresult
rv
=
mObserverSvc
-
>
AddObserver
(
this
topic
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mInitialized
=
true
;
return
NS_OK
;
}
nsAvailableMemoryWatcher
:
:
~
nsAvailableMemoryWatcher
(
)
{
MOZ_ASSERT
(
!
mLowMemoryHandle
)
;
MOZ_ASSERT
(
!
mWaitHandle
)
;
}
VOID
CALLBACK
nsAvailableMemoryWatcher
:
:
LowMemoryCallback
(
PVOID
aContext
BOOLEAN
aIsTimer
)
{
if
(
aIsTimer
)
{
return
;
}
RefPtr
<
nsAvailableMemoryWatcher
>
watcher
=
already_AddRefed
<
nsAvailableMemoryWatcher
>
(
static_cast
<
nsAvailableMemoryWatcher
*
>
(
aContext
)
)
;
MutexAutoLock
lock
(
watcher
-
>
mMutex
)
;
if
(
watcher
-
>
mIsShutdown
)
{
MOZ_ASSERT
(
!
watcher
-
>
mWaitHandle
)
;
return
;
}
:
:
UnregisterWait
(
watcher
-
>
mWaitHandle
)
;
watcher
-
>
mWaitHandle
=
nullptr
;
if
(
IsCommitSpaceLow
(
)
)
{
watcher
-
>
OnLowMemory
(
lock
)
;
}
else
{
watcher
-
>
StartPollingIfUserInteracting
(
lock
)
;
}
}
void
nsAvailableMemoryWatcher
:
:
RecordLowMemoryEvent
(
)
{
sNumLowPhysicalMemEvents
+
+
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
LowPhysicalMemoryEvents
sNumLowPhysicalMemEvents
)
;
}
bool
nsAvailableMemoryWatcher
:
:
RegisterMemoryResourceHandler
(
)
{
mLowMemoryHandle
.
own
(
:
:
CreateMemoryResourceNotification
(
LowMemoryResourceNotification
)
)
;
if
(
!
mLowMemoryHandle
)
{
return
false
;
}
MutexAutoLock
lock
(
mMutex
)
;
return
ListenForLowMemory
(
lock
)
;
}
void
nsAvailableMemoryWatcher
:
:
UnregisterMemoryResourceHandler
(
)
{
if
(
mWaitHandle
)
{
bool
res
=
:
:
UnregisterWait
(
mWaitHandle
)
;
if
(
res
|
|
:
:
GetLastError
(
)
!
=
ERROR_IO_PENDING
)
{
this
-
>
Release
(
)
;
}
mWaitHandle
=
nullptr
;
}
mLowMemoryHandle
.
reset
(
)
;
}
void
nsAvailableMemoryWatcher
:
:
Shutdown
(
const
MutexAutoLock
&
)
{
mIsShutdown
=
true
;
for
(
auto
topic
:
kObserverTopics
)
{
Unused
<
<
mObserverSvc
-
>
RemoveObserver
(
this
topic
)
;
}
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
UnregisterMemoryResourceHandler
(
)
;
}
bool
nsAvailableMemoryWatcher
:
:
ListenForLowMemory
(
const
MutexAutoLock
&
)
{
if
(
mLowMemoryHandle
&
&
!
mWaitHandle
)
{
this
-
>
AddRef
(
)
;
bool
res
=
:
:
RegisterWaitForSingleObject
(
&
mWaitHandle
mLowMemoryHandle
LowMemoryCallback
this
INFINITE
WT_EXECUTEDEFAULT
|
WT_EXECUTEONLYONCE
)
;
if
(
!
res
)
{
this
-
>
Release
(
)
;
}
mNeedToRestartTimerOnUserInteracting
=
false
;
return
res
;
}
return
false
;
}
void
nsAvailableMemoryWatcher
:
:
MaybeSaveMemoryReport
(
const
MutexAutoLock
&
)
{
if
(
mSavedReport
)
{
return
;
}
if
(
nsCOMPtr
<
nsICrashReporter
>
cr
=
do_GetService
(
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
)
)
{
mSavedReport
=
NS_SUCCEEDED
(
cr
-
>
SaveMemoryReport
(
)
)
;
}
}
void
nsAvailableMemoryWatcher
:
:
OnLowMemory
(
const
MutexAutoLock
&
aLock
)
{
mUnderMemoryPressure
=
true
;
RecordLowMemoryEvent
(
)
;
if
(
NS_IsMainThread
(
)
)
{
MaybeSaveMemoryReport
(
aLock
)
;
UpdateLowMemoryTimeStamp
(
)
;
{
MutexAutoUnlock
unlock
(
mMutex
)
;
mTabUnloader
-
>
UnloadTabAsync
(
)
;
}
}
else
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
nsAvailableMemoryWatcher
:
:
OnLowMemory
"
[
self
=
RefPtr
{
this
}
]
(
)
{
{
MutexAutoLock
lock
(
self
-
>
mMutex
)
;
self
-
>
MaybeSaveMemoryReport
(
lock
)
;
self
-
>
UpdateLowMemoryTimeStamp
(
)
;
}
self
-
>
mTabUnloader
-
>
UnloadTabAsync
(
)
;
}
)
)
;
}
StartPollingIfUserInteracting
(
aLock
)
;
}
void
nsAvailableMemoryWatcher
:
:
OnHighMemory
(
const
MutexAutoLock
&
aLock
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mUnderMemoryPressure
)
{
RecordTelemetryEventOnHighMemory
(
)
;
NS_NotifyOfEventualMemoryPressure
(
MemoryPressureState
:
:
NoPressure
)
;
}
mUnderMemoryPressure
=
false
;
mSavedReport
=
false
;
StopPolling
(
)
;
ListenForLowMemory
(
aLock
)
;
}
bool
nsAvailableMemoryWatcher
:
:
IsCommitSpaceLow
(
)
{
MEMORYSTATUSEX
memStatus
=
{
sizeof
(
memStatus
)
}
;
if
(
!
:
:
GlobalMemoryStatusEx
(
&
memStatus
)
)
{
return
false
;
}
constexpr
size_t
kBytesPerMB
=
1024
*
1024
;
return
(
memStatus
.
ullAvailPageFile
/
kBytesPerMB
)
<
StaticPrefs
:
:
browser_low_commit_space_threshold_mb
(
)
;
}
void
nsAvailableMemoryWatcher
:
:
StartPollingIfUserInteracting
(
const
MutexAutoLock
&
)
{
mNeedToRestartTimerOnUserInteracting
=
true
;
if
(
mInteracting
&
&
!
mPolling
)
{
if
(
NS_SUCCEEDED
(
mTimer
-
>
InitWithCallback
(
this
mPollingInterval
nsITimer
:
:
TYPE_REPEATING_SLACK
)
)
)
{
mPolling
=
true
;
}
}
}
void
nsAvailableMemoryWatcher
:
:
StopPolling
(
)
{
mTimer
-
>
Cancel
(
)
;
mPolling
=
false
;
}
void
nsAvailableMemoryWatcher
:
:
StopPollingIfUserIdle
(
const
MutexAutoLock
&
)
{
if
(
!
mInteracting
)
{
StopPolling
(
)
;
}
}
void
nsAvailableMemoryWatcher
:
:
OnUserInteracting
(
const
MutexAutoLock
&
aLock
)
{
mInteracting
=
true
;
if
(
mNeedToRestartTimerOnUserInteracting
)
{
StartPollingIfUserInteracting
(
aLock
)
;
}
}
void
nsAvailableMemoryWatcher
:
:
OnUserIdle
(
const
MutexAutoLock
&
)
{
mInteracting
=
false
;
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
Notify
(
nsITimer
*
aTimer
)
{
MutexAutoLock
lock
(
mMutex
)
;
StopPollingIfUserIdle
(
lock
)
;
if
(
IsCommitSpaceLow
(
)
)
{
OnLowMemory
(
lock
)
;
}
else
{
OnHighMemory
(
lock
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
nsAvailableMemoryWatcher
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
strcmp
(
aTopic
"
xpcom
-
shutdown
"
)
=
=
0
)
{
Shutdown
(
lock
)
;
}
else
if
(
strcmp
(
aTopic
"
user
-
interaction
-
inactive
"
)
=
=
0
)
{
OnUserIdle
(
lock
)
;
}
else
if
(
strcmp
(
aTopic
"
user
-
interaction
-
active
"
)
=
=
0
)
{
OnUserInteracting
(
lock
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
topic
"
)
;
}
return
NS_OK
;
}
already_AddRefed
<
nsAvailableMemoryWatcherBase
>
CreateAvailableMemoryWatcher
(
)
{
const
uint32_t
kLowMemoryNotificationIntervalMS
=
gIsGtest
?
10
:
10000
;
RefPtr
watcher
(
new
nsAvailableMemoryWatcher
)
;
if
(
NS_FAILED
(
watcher
-
>
Init
(
kLowMemoryNotificationIntervalMS
)
)
)
{
return
do_AddRef
(
new
nsAvailableMemoryWatcherBase
)
;
}
return
watcher
.
forget
(
)
;
}
}
