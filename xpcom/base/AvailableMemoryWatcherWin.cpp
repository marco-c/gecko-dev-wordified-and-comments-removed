#
include
"
AvailableMemoryWatcher
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsICrashReporter
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsMemoryPressure
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
<
memoryapi
.
h
>
extern
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
MemoryOrdering
:
:
Relaxed
>
sNumLowPhysicalMemEvents
;
namespace
mozilla
{
class
nsAvailableMemoryWatcher
final
:
public
nsITimerCallback
public
nsINamed
public
nsAvailableMemoryWatcherBase
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIOBSERVER
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
nsAvailableMemoryWatcher
(
)
;
nsresult
Init
(
)
override
;
private
:
static
VOID
CALLBACK
LowMemoryCallback
(
PVOID
aContext
BOOLEAN
aIsTimer
)
;
static
void
RecordLowMemoryEvent
(
)
;
static
bool
IsCommitSpaceLow
(
)
;
~
nsAvailableMemoryWatcher
(
)
;
bool
RegisterMemoryResourceHandler
(
const
MutexAutoLock
&
aLock
)
MOZ_REQUIRES
(
mMutex
)
;
void
UnregisterMemoryResourceHandler
(
const
MutexAutoLock
&
)
MOZ_REQUIRES
(
mMutex
)
;
void
MaybeSaveMemoryReport
(
const
MutexAutoLock
&
)
MOZ_REQUIRES
(
mMutex
)
;
void
Shutdown
(
const
MutexAutoLock
&
aLock
)
MOZ_REQUIRES
(
mMutex
)
;
bool
ListenForLowMemory
(
const
MutexAutoLock
&
)
MOZ_REQUIRES
(
mMutex
)
;
void
OnLowMemory
(
const
MutexAutoLock
&
)
MOZ_REQUIRES
(
mMutex
)
;
void
OnHighMemory
(
const
MutexAutoLock
&
)
MOZ_REQUIRES
(
mMutex
)
;
void
StartPollingIfUserInteracting
(
const
MutexAutoLock
&
aLock
)
MOZ_REQUIRES
(
mMutex
)
;
void
StopPolling
(
const
MutexAutoLock
&
)
MOZ_REQUIRES
(
mMutex
)
;
void
StopPollingIfUserIdle
(
const
MutexAutoLock
&
)
MOZ_REQUIRES
(
mMutex
)
;
void
OnUserInteracting
(
const
MutexAutoLock
&
)
MOZ_REQUIRES
(
mMutex
)
;
Mutex
mMutex
;
nsCOMPtr
<
nsITimer
>
mTimer
MOZ_GUARDED_BY
(
mMutex
)
;
nsAutoHandle
mLowMemoryHandle
MOZ_GUARDED_BY
(
mMutex
)
;
HANDLE
mWaitHandle
MOZ_GUARDED_BY
(
mMutex
)
;
bool
mPolling
MOZ_GUARDED_BY
(
mMutex
)
;
bool
mNeedToRestartTimerOnUserInteracting
MOZ_GUARDED_BY
(
mMutex
)
;
bool
mUnderMemoryPressure
MOZ_GUARDED_BY
(
mMutex
)
;
bool
mSavedReport
MOZ_GUARDED_BY
(
mMutex
)
;
bool
mIsShutdown
MOZ_GUARDED_BY
(
mMutex
)
;
uint32_t
mPollingInterval
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
nsAvailableMemoryWatcher
nsAvailableMemoryWatcherBase
nsIObserver
nsITimerCallback
nsINamed
)
nsAvailableMemoryWatcher
:
:
nsAvailableMemoryWatcher
(
)
:
mMutex
(
"
low
memory
callback
mutex
"
)
mWaitHandle
(
nullptr
)
mPolling
(
false
)
mNeedToRestartTimerOnUserInteracting
(
false
)
mUnderMemoryPressure
(
false
)
mSavedReport
(
false
)
mIsShutdown
(
false
)
mPollingInterval
(
0
)
{
}
nsresult
nsAvailableMemoryWatcher
:
:
Init
(
)
{
nsresult
rv
=
nsAvailableMemoryWatcherBase
:
:
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MutexAutoLock
lock
(
mMutex
)
;
mTimer
=
NS_NewTimer
(
)
;
if
(
!
mTimer
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mPollingInterval
=
gIsGtest
?
10
:
10000
;
if
(
!
RegisterMemoryResourceHandler
(
lock
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsAvailableMemoryWatcher
:
:
~
nsAvailableMemoryWatcher
(
)
{
MOZ_ASSERT
(
!
mLowMemoryHandle
)
;
MOZ_ASSERT
(
!
mWaitHandle
)
;
}
VOID
CALLBACK
nsAvailableMemoryWatcher
:
:
LowMemoryCallback
(
PVOID
aContext
BOOLEAN
aIsTimer
)
{
if
(
aIsTimer
)
{
return
;
}
RefPtr
<
nsAvailableMemoryWatcher
>
watcher
=
already_AddRefed
<
nsAvailableMemoryWatcher
>
(
static_cast
<
nsAvailableMemoryWatcher
*
>
(
aContext
)
)
;
MutexAutoLock
lock
(
watcher
-
>
mMutex
)
;
if
(
watcher
-
>
mIsShutdown
)
{
MOZ_ASSERT
(
!
watcher
-
>
mWaitHandle
)
;
return
;
}
:
:
UnregisterWait
(
watcher
-
>
mWaitHandle
)
;
watcher
-
>
mWaitHandle
=
nullptr
;
if
(
IsCommitSpaceLow
(
)
)
{
watcher
-
>
OnLowMemory
(
lock
)
;
}
else
{
watcher
-
>
StartPollingIfUserInteracting
(
lock
)
;
}
}
void
nsAvailableMemoryWatcher
:
:
RecordLowMemoryEvent
(
)
{
sNumLowPhysicalMemEvents
+
+
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
LowPhysicalMemoryEvents
sNumLowPhysicalMemEvents
)
;
}
bool
nsAvailableMemoryWatcher
:
:
RegisterMemoryResourceHandler
(
const
MutexAutoLock
&
aLock
)
{
mLowMemoryHandle
.
own
(
:
:
CreateMemoryResourceNotification
(
LowMemoryResourceNotification
)
)
;
if
(
!
mLowMemoryHandle
)
{
return
false
;
}
return
ListenForLowMemory
(
aLock
)
;
}
void
nsAvailableMemoryWatcher
:
:
UnregisterMemoryResourceHandler
(
const
MutexAutoLock
&
)
{
if
(
mWaitHandle
)
{
bool
res
=
:
:
UnregisterWait
(
mWaitHandle
)
;
if
(
res
|
|
:
:
GetLastError
(
)
!
=
ERROR_IO_PENDING
)
{
this
-
>
Release
(
)
;
}
mWaitHandle
=
nullptr
;
}
mLowMemoryHandle
.
reset
(
)
;
}
void
nsAvailableMemoryWatcher
:
:
Shutdown
(
const
MutexAutoLock
&
aLock
)
{
mIsShutdown
=
true
;
mNeedToRestartTimerOnUserInteracting
=
false
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
UnregisterMemoryResourceHandler
(
aLock
)
;
}
bool
nsAvailableMemoryWatcher
:
:
ListenForLowMemory
(
const
MutexAutoLock
&
)
{
if
(
mLowMemoryHandle
&
&
!
mWaitHandle
)
{
this
-
>
AddRef
(
)
;
bool
res
=
:
:
RegisterWaitForSingleObject
(
&
mWaitHandle
mLowMemoryHandle
LowMemoryCallback
this
INFINITE
WT_EXECUTEDEFAULT
|
WT_EXECUTEONLYONCE
)
;
if
(
!
res
)
{
this
-
>
Release
(
)
;
}
mNeedToRestartTimerOnUserInteracting
=
false
;
return
res
;
}
return
false
;
}
void
nsAvailableMemoryWatcher
:
:
MaybeSaveMemoryReport
(
const
MutexAutoLock
&
)
{
if
(
mSavedReport
)
{
return
;
}
if
(
nsCOMPtr
<
nsICrashReporter
>
cr
=
do_GetService
(
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
)
)
{
mSavedReport
=
NS_SUCCEEDED
(
cr
-
>
SaveMemoryReport
(
)
)
;
}
}
void
nsAvailableMemoryWatcher
:
:
OnLowMemory
(
const
MutexAutoLock
&
aLock
)
{
mUnderMemoryPressure
=
true
;
RecordLowMemoryEvent
(
)
;
if
(
NS_IsMainThread
(
)
)
{
MaybeSaveMemoryReport
(
aLock
)
;
UpdateLowMemoryTimeStamp
(
)
;
{
MutexAutoUnlock
unlock
(
mMutex
)
;
mTabUnloader
-
>
UnloadTabAsync
(
)
;
}
}
else
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
nsAvailableMemoryWatcher
:
:
OnLowMemory
"
[
self
=
RefPtr
{
this
}
]
(
)
{
{
MutexAutoLock
lock
(
self
-
>
mMutex
)
;
self
-
>
MaybeSaveMemoryReport
(
lock
)
;
self
-
>
UpdateLowMemoryTimeStamp
(
)
;
}
self
-
>
mTabUnloader
-
>
UnloadTabAsync
(
)
;
}
)
)
;
}
StartPollingIfUserInteracting
(
aLock
)
;
}
void
nsAvailableMemoryWatcher
:
:
OnHighMemory
(
const
MutexAutoLock
&
aLock
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mUnderMemoryPressure
)
{
RecordTelemetryEventOnHighMemory
(
)
;
NS_NotifyOfEventualMemoryPressure
(
MemoryPressureState
:
:
NoPressure
)
;
}
mUnderMemoryPressure
=
false
;
mSavedReport
=
false
;
StopPolling
(
aLock
)
;
ListenForLowMemory
(
aLock
)
;
}
bool
nsAvailableMemoryWatcher
:
:
IsCommitSpaceLow
(
)
{
MEMORYSTATUSEX
memStatus
=
{
sizeof
(
memStatus
)
}
;
if
(
!
:
:
GlobalMemoryStatusEx
(
&
memStatus
)
)
{
return
false
;
}
constexpr
size_t
kBytesPerMB
=
1024
*
1024
;
return
(
memStatus
.
ullAvailPageFile
/
kBytesPerMB
)
<
StaticPrefs
:
:
browser_low_commit_space_threshold_mb
(
)
;
}
void
nsAvailableMemoryWatcher
:
:
StartPollingIfUserInteracting
(
const
MutexAutoLock
&
)
{
mNeedToRestartTimerOnUserInteracting
=
true
;
if
(
mInteracting
&
&
!
mPolling
)
{
if
(
NS_SUCCEEDED
(
mTimer
-
>
InitWithCallback
(
this
mPollingInterval
nsITimer
:
:
TYPE_REPEATING_SLACK
)
)
)
{
mPolling
=
true
;
}
}
}
void
nsAvailableMemoryWatcher
:
:
StopPolling
(
const
MutexAutoLock
&
)
{
mTimer
-
>
Cancel
(
)
;
mPolling
=
false
;
}
void
nsAvailableMemoryWatcher
:
:
StopPollingIfUserIdle
(
const
MutexAutoLock
&
aLock
)
{
if
(
!
mInteracting
)
{
StopPolling
(
aLock
)
;
}
}
void
nsAvailableMemoryWatcher
:
:
OnUserInteracting
(
const
MutexAutoLock
&
aLock
)
{
if
(
mNeedToRestartTimerOnUserInteracting
)
{
StartPollingIfUserInteracting
(
aLock
)
;
}
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
Notify
(
nsITimer
*
aTimer
)
{
MutexAutoLock
lock
(
mMutex
)
;
StopPollingIfUserIdle
(
lock
)
;
if
(
IsCommitSpaceLow
(
)
)
{
OnLowMemory
(
lock
)
;
}
else
{
OnHighMemory
(
lock
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
nsAvailableMemoryWatcher
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsAvailableMemoryWatcher
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
nsresult
rv
=
nsAvailableMemoryWatcherBase
:
:
Observe
(
aSubject
aTopic
aData
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MutexAutoLock
lock
(
mMutex
)
;
if
(
strcmp
(
aTopic
"
xpcom
-
shutdown
"
)
=
=
0
)
{
Shutdown
(
lock
)
;
}
else
if
(
strcmp
(
aTopic
"
user
-
interaction
-
active
"
)
=
=
0
)
{
OnUserInteracting
(
lock
)
;
}
return
NS_OK
;
}
already_AddRefed
<
nsAvailableMemoryWatcherBase
>
CreateAvailableMemoryWatcher
(
)
{
RefPtr
watcher
(
new
nsAvailableMemoryWatcher
)
;
if
(
NS_FAILED
(
watcher
-
>
Init
(
)
)
)
{
return
do_AddRef
(
new
nsAvailableMemoryWatcherBase
)
;
}
return
watcher
.
forget
(
)
;
}
}
