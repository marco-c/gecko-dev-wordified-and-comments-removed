#
ifndef
SECURITY_RLBOX_SANDBOX_POOL_H_
#
define
SECURITY_RLBOX_SANDBOX_POOL_H_
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
rlbox
/
rlbox_types
.
hpp
"
namespace
mozilla
{
class
RLBoxSandboxDataBase
;
class
RLBoxSandboxPoolData
;
class
RLBoxSandboxPool
:
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
RLBoxSandboxPool
(
size_t
aDelaySeconds
=
10
)
:
mPool
(
)
mDelaySeconds
(
aDelaySeconds
)
mMutex
(
"
RLBoxSandboxPool
:
:
mMutex
"
)
{
}
;
void
Push
(
UniquePtr
<
RLBoxSandboxDataBase
>
sbx
)
;
UniquePtr
<
RLBoxSandboxPoolData
>
PopOrCreate
(
)
;
protected
:
virtual
UniquePtr
<
RLBoxSandboxDataBase
>
CreateSandboxData
(
)
=
0
;
virtual
~
RLBoxSandboxPool
(
)
=
default
;
private
:
void
StartTimer
(
)
;
void
CancelTimer
(
)
;
nsTArray
<
UniquePtr
<
RLBoxSandboxDataBase
>
>
mPool
;
const
size_t
mDelaySeconds
;
nsCOMPtr
<
nsITimer
>
mTimer
;
mozilla
:
:
Mutex
mMutex
;
}
;
class
RLBoxSandboxDataBase
{
public
:
virtual
~
RLBoxSandboxDataBase
(
)
=
default
;
}
;
class
RLBoxSandboxPoolData
{
public
:
RLBoxSandboxPoolData
(
UniquePtr
<
RLBoxSandboxDataBase
>
aSbxData
RefPtr
<
RLBoxSandboxPool
>
aPool
)
{
mSbxData
=
std
:
:
move
(
aSbxData
)
;
mPool
=
aPool
;
MOZ_COUNT_CTOR
(
RLBoxSandboxPoolData
)
;
}
RLBoxSandboxDataBase
*
SandboxData
(
)
const
{
return
mSbxData
.
get
(
)
;
}
;
~
RLBoxSandboxPoolData
(
)
{
mPool
-
>
Push
(
std
:
:
move
(
mSbxData
)
)
;
MOZ_COUNT_DTOR
(
RLBoxSandboxPoolData
)
;
}
;
private
:
UniquePtr
<
RLBoxSandboxDataBase
>
mSbxData
;
RefPtr
<
RLBoxSandboxPool
>
mPool
;
}
;
}
#
endif
