#
include
"
mozilla
/
Logging
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Printf
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDebugImpl
.
h
"
#
include
"
NSPRLogModulesParser
.
h
"
#
include
"
LogCommandLineHandler
.
h
"
#
include
"
prenv
.
h
"
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
else
#
include
<
sys
/
types
.
h
>
#
include
<
unistd
.
h
>
#
endif
const
uint32_t
kInitialModuleCount
=
256
;
const
uint32_t
kRotateFilesNumber
=
4
;
namespace
mozilla
{
LazyLogModule
:
:
operator
LogModule
*
(
)
{
LogModule
*
tmp
=
mLog
;
if
(
MOZ_UNLIKELY
(
!
tmp
)
)
{
tmp
=
LogModule
:
:
Get
(
mLogName
)
;
mLog
=
tmp
;
}
mCanary
.
Check
(
)
;
return
tmp
;
}
namespace
detail
{
void
log_print
(
const
LogModule
*
aModule
LogLevel
aLevel
const
char
*
aFmt
.
.
.
)
{
va_list
ap
;
va_start
(
ap
aFmt
)
;
aModule
-
>
Printv
(
aLevel
aFmt
ap
)
;
va_end
(
ap
)
;
}
}
LogLevel
ToLogLevel
(
int32_t
aLevel
)
{
aLevel
=
std
:
:
min
(
aLevel
static_cast
<
int32_t
>
(
LogLevel
:
:
Verbose
)
)
;
aLevel
=
std
:
:
max
(
aLevel
static_cast
<
int32_t
>
(
LogLevel
:
:
Disabled
)
)
;
return
static_cast
<
LogLevel
>
(
aLevel
)
;
}
const
char
*
ToLogStr
(
LogLevel
aLevel
)
{
switch
(
aLevel
)
{
case
LogLevel
:
:
Error
:
return
"
E
"
;
case
LogLevel
:
:
Warning
:
return
"
W
"
;
case
LogLevel
:
:
Info
:
return
"
I
"
;
case
LogLevel
:
:
Debug
:
return
"
D
"
;
case
LogLevel
:
:
Verbose
:
return
"
V
"
;
case
LogLevel
:
:
Disabled
:
default
:
MOZ_CRASH
(
"
Invalid
log
level
.
"
)
;
return
"
"
;
}
}
namespace
detail
{
class
LogFile
{
FILE
*
mFile
;
uint32_t
mFileNum
;
public
:
LogFile
(
FILE
*
aFile
uint32_t
aFileNum
)
:
mFile
(
aFile
)
mFileNum
(
aFileNum
)
mNextToRelease
(
nullptr
)
{
}
~
LogFile
(
)
{
fclose
(
mFile
)
;
delete
mNextToRelease
;
}
FILE
*
File
(
)
const
{
return
mFile
;
}
uint32_t
Num
(
)
const
{
return
mFileNum
;
}
LogFile
*
mNextToRelease
;
}
;
const
char
*
ExpandPIDMarker
(
const
char
*
aFilename
char
(
&
buffer
)
[
2048
]
)
{
MOZ_ASSERT
(
aFilename
)
;
static
const
char
kPIDToken
[
]
=
"
%
PID
"
;
const
char
*
pidTokenPtr
=
strstr
(
aFilename
kPIDToken
)
;
if
(
pidTokenPtr
&
&
SprintfLiteral
(
buffer
"
%
.
*
s
%
s
%
d
%
s
"
static_cast
<
int
>
(
pidTokenPtr
-
aFilename
)
aFilename
XRE_IsParentProcess
(
)
?
"
-
main
.
"
:
"
-
child
.
"
base
:
:
GetCurrentProcId
(
)
pidTokenPtr
+
strlen
(
kPIDToken
)
)
>
0
)
{
return
buffer
;
}
return
aFilename
;
}
}
namespace
{
void
empty_va
(
va_list
*
va
.
.
.
)
{
va_start
(
*
va
va
)
;
va_end
(
*
va
)
;
}
}
class
LogModuleManager
{
public
:
LogModuleManager
(
)
:
mModulesLock
(
"
logmodules
"
recordreplay
:
:
Behavior
:
:
DontPreserve
)
mModules
(
kInitialModuleCount
)
mPrintEntryCount
(
0
)
mOutFile
(
nullptr
)
mToReleaseFile
(
nullptr
)
mOutFileNum
(
0
)
mOutFilePath
(
strdup
(
"
"
)
)
mMainThread
(
PR_GetCurrentThread
(
)
)
mSetFromEnv
(
false
)
mAddTimestamp
(
false
)
mIsRaw
(
false
)
mIsSync
(
false
)
mRotate
(
0
)
mInitialized
(
false
)
{
}
~
LogModuleManager
(
)
{
detail
:
:
LogFile
*
logFile
=
mOutFile
.
exchange
(
nullptr
)
;
delete
logFile
;
}
void
Init
(
int
argc
char
*
argv
[
]
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mInitialized
)
;
mInitialized
=
true
;
LoggingHandleCommandLineArgs
(
argc
static_cast
<
char
const
*
const
*
>
(
argv
)
[
]
(
nsACString
const
&
env
)
{
PR_SetEnv
(
ToNewCString
(
env
)
)
;
}
)
;
bool
shouldAppend
=
false
;
bool
addTimestamp
=
false
;
bool
isSync
=
false
;
bool
isRaw
=
false
;
int32_t
rotate
=
0
;
const
char
*
modules
=
PR_GetEnv
(
"
MOZ_LOG
"
)
;
if
(
!
modules
|
|
!
modules
[
0
]
)
{
modules
=
PR_GetEnv
(
"
MOZ_LOG_MODULES
"
)
;
if
(
modules
)
{
NS_WARNING
(
"
MOZ_LOG_MODULES
is
deprecated
.
"
"
\
nPlease
use
MOZ_LOG
instead
.
"
)
;
}
}
if
(
!
modules
|
|
!
modules
[
0
]
)
{
modules
=
PR_GetEnv
(
"
NSPR_LOG_MODULES
"
)
;
if
(
modules
)
{
NS_WARNING
(
"
NSPR_LOG_MODULES
is
deprecated
.
"
"
\
nPlease
use
MOZ_LOG
instead
.
"
)
;
}
}
NSPRLogModulesParser
(
modules
[
this
&
shouldAppend
&
addTimestamp
&
isSync
&
isRaw
&
rotate
]
(
const
char
*
aName
LogLevel
aLevel
int32_t
aValue
)
mutable
{
if
(
strcmp
(
aName
"
append
"
)
=
=
0
)
{
shouldAppend
=
true
;
}
else
if
(
strcmp
(
aName
"
timestamp
"
)
=
=
0
)
{
addTimestamp
=
true
;
}
else
if
(
strcmp
(
aName
"
sync
"
)
=
=
0
)
{
isSync
=
true
;
}
else
if
(
strcmp
(
aName
"
raw
"
)
=
=
0
)
{
isRaw
=
true
;
}
else
if
(
strcmp
(
aName
"
rotate
"
)
=
=
0
)
{
rotate
=
(
aValue
<
<
20
)
/
kRotateFilesNumber
;
}
else
{
this
-
>
CreateOrGetModule
(
aName
)
-
>
SetLevel
(
aLevel
)
;
}
}
)
;
mAddTimestamp
=
addTimestamp
|
|
rotate
>
0
;
mIsSync
=
isSync
;
mIsRaw
=
isRaw
;
mRotate
=
rotate
;
if
(
rotate
>
0
&
&
shouldAppend
)
{
NS_WARNING
(
"
MOZ_LOG
:
when
you
rotate
the
log
you
cannot
use
append
!
"
)
;
}
const
char
*
logFile
=
PR_GetEnv
(
"
MOZ_LOG_FILE
"
)
;
if
(
!
logFile
|
|
!
logFile
[
0
]
)
{
logFile
=
PR_GetEnv
(
"
NSPR_LOG_FILE
"
)
;
}
if
(
logFile
&
&
logFile
[
0
]
)
{
char
buf
[
2048
]
;
logFile
=
detail
:
:
ExpandPIDMarker
(
logFile
buf
)
;
mOutFilePath
.
reset
(
strdup
(
logFile
)
)
;
if
(
mRotate
>
0
)
{
remove
(
mOutFilePath
.
get
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
kRotateFilesNumber
;
+
+
i
)
{
RemoveFile
(
i
)
;
}
}
mOutFile
=
OpenFile
(
shouldAppend
mOutFileNum
)
;
mSetFromEnv
=
true
;
}
}
void
SetLogFile
(
const
char
*
aFilename
)
{
if
(
mSetFromEnv
)
{
NS_WARNING
(
"
LogModuleManager
:
:
SetLogFile
-
Log
file
was
set
from
the
"
"
MOZ_LOG_FILE
environment
variable
.
"
)
;
return
;
}
const
char
*
filename
=
aFilename
?
aFilename
:
"
"
;
char
buf
[
2048
]
;
filename
=
detail
:
:
ExpandPIDMarker
(
filename
buf
)
;
MOZ_ASSERT
(
mRotate
=
=
0
"
We
don
'
t
allow
rotate
for
runtime
logfile
changes
"
)
;
mOutFilePath
.
reset
(
strdup
(
filename
)
)
;
detail
:
:
LogFile
*
newFile
=
OpenFile
(
false
0
)
;
detail
:
:
LogFile
*
oldFile
=
mOutFile
.
exchange
(
newFile
)
;
DebugOnly
<
detail
:
:
LogFile
*
>
prevFile
=
mToReleaseFile
.
exchange
(
oldFile
)
;
MOZ_ASSERT
(
!
prevFile
"
Should
be
null
because
rotation
is
not
allowed
"
)
;
if
(
oldFile
)
{
va_list
va
;
empty_va
(
&
va
)
;
Print
(
"
Logger
"
LogLevel
:
:
Info
"
Flushing
old
log
files
\
n
"
va
)
;
}
}
uint32_t
GetLogFile
(
char
*
aBuffer
size_t
aLength
)
{
uint32_t
len
=
strlen
(
mOutFilePath
.
get
(
)
)
;
if
(
len
+
1
>
aLength
)
{
return
0
;
}
snprintf
(
aBuffer
aLength
"
%
s
"
mOutFilePath
.
get
(
)
)
;
return
len
;
}
void
SetIsSync
(
bool
aIsSync
)
{
mIsSync
=
aIsSync
;
}
void
SetAddTimestamp
(
bool
aAddTimestamp
)
{
mAddTimestamp
=
aAddTimestamp
;
}
detail
:
:
LogFile
*
OpenFile
(
bool
aShouldAppend
uint32_t
aFileNum
)
{
FILE
*
file
;
if
(
mRotate
>
0
)
{
char
buf
[
2048
]
;
SprintfLiteral
(
buf
"
%
s
.
%
d
"
mOutFilePath
.
get
(
)
aFileNum
)
;
file
=
fopen
(
buf
"
w
"
)
;
}
else
{
file
=
fopen
(
mOutFilePath
.
get
(
)
aShouldAppend
?
"
a
"
:
"
w
"
)
;
}
if
(
!
file
)
{
return
nullptr
;
}
return
new
detail
:
:
LogFile
(
file
aFileNum
)
;
}
void
RemoveFile
(
uint32_t
aFileNum
)
{
char
buf
[
2048
]
;
SprintfLiteral
(
buf
"
%
s
.
%
d
"
mOutFilePath
.
get
(
)
aFileNum
)
;
remove
(
buf
)
;
}
LogModule
*
CreateOrGetModule
(
const
char
*
aName
)
{
OffTheBooksMutexAutoLock
guard
(
mModulesLock
)
;
LogModule
*
module
=
nullptr
;
if
(
!
mModules
.
Get
(
aName
&
module
)
)
{
module
=
new
LogModule
(
aName
LogLevel
:
:
Disabled
)
;
mModules
.
Put
(
aName
module
)
;
}
return
module
;
}
void
Print
(
const
char
*
aName
LogLevel
aLevel
const
char
*
aFmt
va_list
aArgs
)
MOZ_FORMAT_PRINTF
(
4
0
)
{
static
long
pid
=
static_cast
<
long
>
(
base
:
:
GetCurrentProcId
(
)
)
;
const
size_t
kBuffSize
=
1024
;
char
buff
[
kBuffSize
]
;
char
*
buffToWrite
=
buff
;
SmprintfPointer
allocatedBuff
;
va_list
argsCopy
;
va_copy
(
argsCopy
aArgs
)
;
int
charsWritten
=
VsprintfLiteral
(
buff
aFmt
argsCopy
)
;
va_end
(
argsCopy
)
;
if
(
charsWritten
<
0
)
{
MOZ_ASSERT
(
false
"
Probably
incorrect
format
string
in
LOG
?
"
)
;
strncpy
(
buff
aFmt
kBuffSize
-
1
)
;
buff
[
kBuffSize
-
1
]
=
'
\
0
'
;
charsWritten
=
strlen
(
buff
)
;
}
else
if
(
static_cast
<
size_t
>
(
charsWritten
)
>
=
kBuffSize
-
1
)
{
allocatedBuff
=
mozilla
:
:
Vsmprintf
(
aFmt
aArgs
)
;
buffToWrite
=
allocatedBuff
.
get
(
)
;
charsWritten
=
strlen
(
buffToWrite
)
;
}
const
char
*
newline
=
"
"
;
if
(
charsWritten
=
=
0
|
|
buffToWrite
[
charsWritten
-
1
]
!
=
'
\
n
'
)
{
newline
=
"
\
n
"
;
}
FILE
*
out
=
stderr
;
+
+
mPrintEntryCount
;
detail
:
:
LogFile
*
outFile
=
mOutFile
;
if
(
outFile
)
{
out
=
outFile
-
>
File
(
)
;
}
PRThread
*
currentThread
=
PR_GetCurrentThread
(
)
;
const
char
*
currentThreadName
=
(
mMainThread
=
=
currentThread
)
?
"
Main
Thread
"
:
PR_GetThreadName
(
currentThread
)
;
char
noNameThread
[
40
]
;
if
(
!
currentThreadName
)
{
SprintfLiteral
(
noNameThread
"
Unnamed
thread
%
p
"
currentThread
)
;
currentThreadName
=
noNameThread
;
}
if
(
!
mAddTimestamp
)
{
if
(
!
mIsRaw
)
{
fprintf_stderr
(
out
"
[
%
s
%
ld
:
%
s
]
:
%
s
/
%
s
%
s
%
s
"
nsDebugImpl
:
:
GetMultiprocessMode
(
)
pid
currentThreadName
ToLogStr
(
aLevel
)
aName
buffToWrite
newline
)
;
}
else
{
fprintf_stderr
(
out
"
%
s
%
s
"
buffToWrite
newline
)
;
}
}
else
{
PRExplodedTime
now
;
PR_ExplodeTime
(
PR_Now
(
)
PR_GMTParameters
&
now
)
;
fprintf_stderr
(
out
"
%
04d
-
%
02d
-
%
02d
%
02d
:
%
02d
:
%
02d
.
%
06d
UTC
-
[
%
s
%
ld
:
%
s
]
:
%
s
/
%
s
%
s
%
s
"
now
.
tm_year
now
.
tm_month
+
1
now
.
tm_mday
now
.
tm_hour
now
.
tm_min
now
.
tm_sec
now
.
tm_usec
nsDebugImpl
:
:
GetMultiprocessMode
(
)
pid
currentThreadName
ToLogStr
(
aLevel
)
aName
buffToWrite
newline
)
;
}
if
(
mIsSync
)
{
fflush
(
out
)
;
}
if
(
mRotate
>
0
&
&
outFile
)
{
int32_t
fileSize
=
ftell
(
out
)
;
if
(
fileSize
>
mRotate
)
{
uint32_t
fileNum
=
outFile
-
>
Num
(
)
;
uint32_t
nextFileNum
=
fileNum
+
1
;
if
(
nextFileNum
>
=
kRotateFilesNumber
)
{
nextFileNum
=
0
;
}
if
(
mOutFileNum
.
compareExchange
(
fileNum
nextFileNum
)
)
{
outFile
-
>
mNextToRelease
=
mToReleaseFile
;
mToReleaseFile
=
outFile
;
mOutFile
=
OpenFile
(
false
nextFileNum
)
;
}
}
}
if
(
-
-
mPrintEntryCount
=
=
0
&
&
mToReleaseFile
)
{
detail
:
:
LogFile
*
release
=
mToReleaseFile
.
exchange
(
nullptr
)
;
delete
release
;
}
}
private
:
OffTheBooksMutex
mModulesLock
;
nsClassHashtable
<
nsCharPtrHashKey
LogModule
>
mModules
;
Atomic
<
uint32_t
ReleaseAcquire
>
mPrintEntryCount
;
Atomic
<
detail
:
:
LogFile
*
ReleaseAcquire
>
mOutFile
;
Atomic
<
detail
:
:
LogFile
*
Relaxed
>
mToReleaseFile
;
Atomic
<
uint32_t
Relaxed
>
mOutFileNum
;
UniqueFreePtr
<
char
[
]
>
mOutFilePath
;
PRThread
*
mMainThread
;
bool
mSetFromEnv
;
Atomic
<
bool
Relaxed
>
mAddTimestamp
;
Atomic
<
bool
Relaxed
>
mIsRaw
;
Atomic
<
bool
Relaxed
>
mIsSync
;
int32_t
mRotate
;
bool
mInitialized
;
}
;
StaticAutoPtr
<
LogModuleManager
>
sLogModuleManager
;
LogModule
*
LogModule
:
:
Get
(
const
char
*
aName
)
{
MOZ_ASSERT
(
sLogModuleManager
!
=
nullptr
)
;
return
sLogModuleManager
-
>
CreateOrGetModule
(
aName
)
;
}
void
LogModule
:
:
SetLogFile
(
const
char
*
aFilename
)
{
MOZ_ASSERT
(
sLogModuleManager
)
;
sLogModuleManager
-
>
SetLogFile
(
aFilename
)
;
}
uint32_t
LogModule
:
:
GetLogFile
(
char
*
aBuffer
size_t
aLength
)
{
MOZ_ASSERT
(
sLogModuleManager
)
;
return
sLogModuleManager
-
>
GetLogFile
(
aBuffer
aLength
)
;
}
void
LogModule
:
:
SetAddTimestamp
(
bool
aAddTimestamp
)
{
sLogModuleManager
-
>
SetAddTimestamp
(
aAddTimestamp
)
;
}
void
LogModule
:
:
SetIsSync
(
bool
aIsSync
)
{
sLogModuleManager
-
>
SetIsSync
(
aIsSync
)
;
}
void
LogModule
:
:
Init
(
int
argc
char
*
argv
[
]
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
sLogModuleManager
)
{
return
;
}
auto
mgr
=
new
LogModuleManager
(
)
;
mgr
-
>
Init
(
argc
argv
)
;
sLogModuleManager
=
mgr
;
}
void
LogModule
:
:
Printv
(
LogLevel
aLevel
const
char
*
aFmt
va_list
aArgs
)
const
{
MOZ_ASSERT
(
sLogModuleManager
!
=
nullptr
)
;
sLogModuleManager
-
>
Print
(
Name
(
)
aLevel
aFmt
aArgs
)
;
}
}
