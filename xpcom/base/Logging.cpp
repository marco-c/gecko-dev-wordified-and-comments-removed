#
include
"
mozilla
/
Logging
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
NSPRLogModulesParser
.
h
"
#
include
"
prenv
.
h
"
const
uint32_t
kInitialModuleCount
=
256
;
namespace
mozilla
{
LogLevel
ToLogLevel
(
int32_t
aLevel
)
{
aLevel
=
std
:
:
min
(
aLevel
static_cast
<
int32_t
>
(
LogLevel
:
:
Verbose
)
)
;
aLevel
=
std
:
:
max
(
aLevel
static_cast
<
int32_t
>
(
LogLevel
:
:
Disabled
)
)
;
return
static_cast
<
LogLevel
>
(
aLevel
)
;
}
class
LogModuleManager
{
public
:
LogModuleManager
(
)
:
mModulesLock
(
"
logmodules
"
)
mModules
(
kInitialModuleCount
)
{
}
~
LogModuleManager
(
)
{
}
void
Init
(
)
{
const
char
*
modules
=
PR_GetEnv
(
"
NSPR_LOG_MODULES
"
)
;
NSPRLogModulesParser
(
modules
[
]
(
const
char
*
aName
LogLevel
aLevel
)
{
LogModule
:
:
Get
(
aName
)
-
>
SetLevel
(
aLevel
)
;
}
)
;
}
LogModule
*
CreateOrGetModule
(
const
char
*
aName
)
{
OffTheBooksMutexAutoLock
guard
(
mModulesLock
)
;
LogModule
*
module
=
nullptr
;
if
(
!
mModules
.
Get
(
aName
&
module
)
)
{
module
=
new
LogModule
(
LogLevel
:
:
Disabled
)
;
mModules
.
Put
(
aName
module
)
;
}
return
module
;
}
private
:
OffTheBooksMutex
mModulesLock
;
nsClassHashtable
<
nsCharPtrHashKey
LogModule
>
mModules
;
}
;
StaticAutoPtr
<
LogModuleManager
>
sLogModuleManager
;
LogModule
*
LogModule
:
:
Get
(
const
char
*
aName
)
{
MOZ_ASSERT
(
sLogModuleManager
!
=
nullptr
)
;
return
sLogModuleManager
-
>
CreateOrGetModule
(
aName
)
;
}
void
LogModule
:
:
Init
(
)
{
if
(
sLogModuleManager
)
{
return
;
}
sLogModuleManager
=
new
LogModuleManager
(
)
;
sLogModuleManager
-
>
Init
(
)
;
}
}
