#
ifndef
mozilla_ClearOnShutdown_h
#
define
mozilla_ClearOnShutdown_h
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Array
.
h
"
#
include
"
MainThreadUtils
.
h
"
namespace
mozilla
{
enum
class
ShutdownPhase
{
NotInShutdown
=
0
WillShutdown
Shutdown
ShutdownThreads
ShutdownLoaders
ShutdownFinal
ShutdownPhase_Length
First
=
WillShutdown
Last
=
ShutdownFinal
}
;
namespace
ClearOnShutdown_Internal
{
class
ShutdownObserver
:
public
LinkedListElement
<
ShutdownObserver
>
{
public
:
virtual
void
Shutdown
(
)
=
0
;
virtual
~
ShutdownObserver
(
)
{
}
}
;
template
<
class
SmartPtr
>
class
PointerClearer
:
public
ShutdownObserver
{
public
:
explicit
PointerClearer
(
SmartPtr
*
aPtr
)
:
mPtr
(
aPtr
)
{
}
virtual
void
Shutdown
(
)
override
{
if
(
mPtr
)
{
*
mPtr
=
nullptr
;
}
}
private
:
SmartPtr
*
mPtr
;
}
;
typedef
LinkedList
<
ShutdownObserver
>
ShutdownList
;
extern
Array
<
StaticAutoPtr
<
ShutdownList
>
static_cast
<
size_t
>
(
ShutdownPhase
:
:
ShutdownPhase_Length
)
>
sShutdownObservers
;
extern
ShutdownPhase
sCurrentShutdownPhase
;
}
template
<
class
SmartPtr
>
inline
void
ClearOnShutdown
(
SmartPtr
*
aPtr
ShutdownPhase
aPhase
=
ShutdownPhase
:
:
ShutdownFinal
)
{
using
namespace
ClearOnShutdown_Internal
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPhase
!
=
ShutdownPhase
:
:
ShutdownPhase_Length
)
;
if
(
!
(
static_cast
<
size_t
>
(
sCurrentShutdownPhase
)
<
static_cast
<
size_t
>
(
aPhase
)
)
)
{
MOZ_ASSERT
(
false
"
ClearOnShutdown
for
phase
that
already
was
cleared
"
)
;
*
aPtr
=
nullptr
;
return
;
}
if
(
!
(
sShutdownObservers
[
static_cast
<
size_t
>
(
aPhase
)
]
)
)
{
sShutdownObservers
[
static_cast
<
size_t
>
(
aPhase
)
]
=
new
ShutdownList
(
)
;
}
sShutdownObservers
[
static_cast
<
size_t
>
(
aPhase
)
]
-
>
insertBack
(
new
PointerClearer
<
SmartPtr
>
(
aPtr
)
)
;
}
void
KillClearOnShutdown
(
ShutdownPhase
aPhase
)
;
}
#
endif
