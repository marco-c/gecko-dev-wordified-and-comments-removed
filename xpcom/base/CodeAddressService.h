#
ifndef
CodeAddressService_h__
#
define
CodeAddressService_h__
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
"
mozilla
/
AllocPolicy
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
namespace
mozilla
{
namespace
detail
{
template
<
class
AllocPolicy
>
class
CodeAddressServiceAllocPolicy
:
public
AllocPolicy
{
public
:
char
*
strdup_
(
const
char
*
aStr
)
{
char
*
s
=
AllocPolicy
:
:
template
pod_malloc
<
char
>
(
strlen
(
aStr
)
+
1
)
;
if
(
!
s
)
{
MOZ_CRASH
(
"
CodeAddressService
OOM
"
)
;
}
strcpy
(
s
aStr
)
;
return
s
;
}
}
;
struct
DefaultDescribeCodeAddressLock
{
static
void
Unlock
(
)
{
}
static
void
Lock
(
)
{
}
static
bool
IsLocked
(
)
{
return
true
;
}
}
;
}
template
<
class
AllocPolicy_
=
MallocAllocPolicy
class
DescribeCodeAddressLock
=
detail
:
:
DefaultDescribeCodeAddressLock
>
class
CodeAddressService
:
private
detail
:
:
CodeAddressServiceAllocPolicy
<
AllocPolicy_
>
{
protected
:
using
AllocPolicy
=
detail
:
:
CodeAddressServiceAllocPolicy
<
AllocPolicy_
>
;
using
StringHashSet
=
HashSet
<
const
char
*
CStringHasher
AllocPolicy
>
;
StringHashSet
mLibraryStrings
;
struct
Entry
:
private
AllocPolicy
{
const
void
*
mPc
;
char
*
mFunction
;
const
char
*
mLibrary
;
ptrdiff_t
mLOffset
;
char
*
mFileName
;
uint32_t
mLineNo
:
31
;
uint32_t
mInUse
:
1
;
Entry
(
)
:
mPc
(
0
)
mFunction
(
nullptr
)
mLibrary
(
nullptr
)
mLOffset
(
0
)
mFileName
(
nullptr
)
mLineNo
(
0
)
mInUse
(
0
)
{
}
~
Entry
(
)
{
AllocPolicy
:
:
free_
(
mFunction
)
;
AllocPolicy
:
:
free_
(
mFileName
)
;
}
void
Replace
(
const
void
*
aPc
const
char
*
aFunction
const
char
*
aLibrary
ptrdiff_t
aLOffset
const
char
*
aFileName
unsigned
long
aLineNo
)
{
mPc
=
aPc
;
AllocPolicy
:
:
free_
(
mFunction
)
;
mFunction
=
!
aFunction
[
0
]
?
nullptr
:
AllocPolicy
:
:
strdup_
(
aFunction
)
;
AllocPolicy
:
:
free_
(
mFileName
)
;
mFileName
=
!
aFileName
[
0
]
?
nullptr
:
AllocPolicy
:
:
strdup_
(
aFileName
)
;
mLibrary
=
aLibrary
;
mLOffset
=
aLOffset
;
mLineNo
=
aLineNo
;
mInUse
=
1
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
n
+
=
aMallocSizeOf
(
mFunction
)
;
n
+
=
aMallocSizeOf
(
mFileName
)
;
return
n
;
}
}
;
const
char
*
InternLibraryString
(
const
char
*
aString
)
{
auto
p
=
mLibraryStrings
.
lookupForAdd
(
aString
)
;
if
(
p
)
{
return
*
p
;
}
const
char
*
newString
=
AllocPolicy
:
:
strdup_
(
aString
)
;
if
(
!
mLibraryStrings
.
add
(
p
newString
)
)
{
MOZ_CRASH
(
"
CodeAddressService
OOM
"
)
;
}
return
newString
;
}
Entry
&
GetEntry
(
const
void
*
aPc
)
{
MOZ_ASSERT
(
DescribeCodeAddressLock
:
:
IsLocked
(
)
)
;
uint32_t
index
=
HashGeneric
(
aPc
)
&
kMask
;
MOZ_ASSERT
(
index
<
kNumEntries
)
;
Entry
&
entry
=
mEntries
[
index
]
;
if
(
!
entry
.
mInUse
|
|
entry
.
mPc
!
=
aPc
)
{
mNumCacheMisses
+
+
;
MozCodeAddressDetails
details
;
{
DescribeCodeAddressLock
:
:
Unlock
(
)
;
(
void
)
MozDescribeCodeAddress
(
const_cast
<
void
*
>
(
aPc
)
&
details
)
;
DescribeCodeAddressLock
:
:
Lock
(
)
;
}
const
char
*
library
=
InternLibraryString
(
details
.
library
)
;
entry
.
Replace
(
aPc
details
.
function
library
details
.
loffset
details
.
filename
details
.
lineno
)
;
}
else
{
mNumCacheHits
+
+
;
}
MOZ_ASSERT
(
entry
.
mPc
=
=
aPc
)
;
return
entry
;
}
static
const
size_t
kNumEntries
=
1
<
<
12
;
static
const
size_t
kMask
=
kNumEntries
-
1
;
Entry
mEntries
[
kNumEntries
]
;
size_t
mNumCacheHits
;
size_t
mNumCacheMisses
;
public
:
CodeAddressService
(
)
:
mLibraryStrings
(
64
)
mEntries
(
)
mNumCacheHits
(
0
)
mNumCacheMisses
(
0
)
{
}
~
CodeAddressService
(
)
{
for
(
auto
iter
=
mLibraryStrings
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
AllocPolicy
:
:
free_
(
const_cast
<
char
*
>
(
iter
.
get
(
)
)
)
;
}
}
int
GetLocation
(
uint32_t
aFrameNumber
const
void
*
aPc
char
*
aBuf
size_t
aBufLen
)
{
Entry
&
entry
=
GetEntry
(
aPc
)
;
return
MozFormatCodeAddress
(
aBuf
aBufLen
aFrameNumber
entry
.
mPc
entry
.
mFunction
entry
.
mLibrary
entry
.
mLOffset
entry
.
mFileName
entry
.
mLineNo
)
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
for
(
uint32_t
i
=
0
;
i
<
kNumEntries
;
i
+
+
)
{
n
+
=
mEntries
[
i
]
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
n
+
=
mLibraryStrings
.
shallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mLibraryStrings
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
n
+
=
aMallocSizeOf
(
iter
.
get
(
)
)
;
}
return
n
;
}
size_t
CacheCapacity
(
)
const
{
return
kNumEntries
;
}
size_t
CacheCount
(
)
const
{
size_t
n
=
0
;
for
(
size_t
i
=
0
;
i
<
kNumEntries
;
i
+
+
)
{
if
(
mEntries
[
i
]
.
mInUse
)
{
n
+
+
;
}
}
return
n
;
}
size_t
NumCacheHits
(
)
const
{
return
mNumCacheHits
;
}
size_t
NumCacheMisses
(
)
const
{
return
mNumCacheMisses
;
}
}
;
}
#
endif
