#
include
"
xpt_xdr
.
h
"
#
include
"
nspr
.
h
"
#
include
"
nscore
.
h
"
#
include
<
string
.
h
>
#
define
CURS_POOL_OFFSET_RAW
(
cursor
)
\
(
(
cursor
)
-
>
pool
=
=
XPT_HEADER
\
?
(
cursor
)
-
>
offset
\
:
(
XPT_ASSERT
(
(
cursor
)
-
>
state
-
>
data_offset
)
\
(
cursor
)
-
>
offset
+
(
cursor
)
-
>
state
-
>
data_offset
)
)
#
define
CURS_POOL_OFFSET
(
cursor
)
\
(
CURS_POOL_OFFSET_RAW
(
cursor
)
-
1
)
#
define
CURS_POINT
(
cursor
)
\
(
(
cursor
)
-
>
state
-
>
pool_data
[
CURS_POOL_OFFSET
(
cursor
)
]
)
static
PRBool
CHECK_COUNT
(
NotNull
<
XPTCursor
*
>
cursor
uint32_t
space
)
{
if
(
cursor
-
>
pool
=
=
XPT_DATA
&
&
(
CURS_POOL_OFFSET
(
cursor
)
+
space
>
(
cursor
)
-
>
state
-
>
pool_allocated
)
)
{
XPT_ASSERT
(
0
)
;
fprintf
(
stderr
"
FATAL
:
no
room
for
%
d
in
cursor
\
n
"
space
)
;
return
PR_FALSE
;
}
return
PR_TRUE
;
}
XPT_PUBLIC_API
(
void
)
XPT_InitXDRState
(
XPTState
*
state
char
*
data
uint32_t
len
)
{
state
-
>
next_cursor
[
0
]
=
state
-
>
next_cursor
[
1
]
=
1
;
state
-
>
pool_data
=
data
;
state
-
>
pool_allocated
=
len
;
}
XPT_PUBLIC_API
(
void
)
XPT_SetDataOffset
(
XPTState
*
state
uint32_t
data_offset
)
{
state
-
>
data_offset
=
data_offset
;
}
XPT_PUBLIC_API
(
PRBool
)
XPT_MakeCursor
(
XPTState
*
state
XPTPool
pool
uint32_t
len
NotNull
<
XPTCursor
*
>
cursor
)
{
cursor
-
>
state
=
state
;
cursor
-
>
pool
=
pool
;
cursor
-
>
bits
=
0
;
cursor
-
>
offset
=
state
-
>
next_cursor
[
pool
]
;
if
(
!
(
CHECK_COUNT
(
cursor
len
)
)
)
return
PR_FALSE
;
if
(
pool
=
=
XPT_DATA
&
&
!
state
-
>
data_offset
)
{
fprintf
(
stderr
"
no
data
offset
for
XPT_DATA
cursor
!
\
n
"
)
;
return
PR_FALSE
;
}
state
-
>
next_cursor
[
pool
]
+
=
len
;
return
PR_TRUE
;
}
XPT_PUBLIC_API
(
PRBool
)
XPT_SeekTo
(
NotNull
<
XPTCursor
*
>
cursor
uint32_t
offset
)
{
cursor
-
>
offset
=
offset
;
return
PR_TRUE
;
}
XPT_PUBLIC_API
(
PRBool
)
XPT_SkipStringInline
(
NotNull
<
XPTCursor
*
>
cursor
)
{
uint16_t
length
;
if
(
!
XPT_Do16
(
cursor
&
length
)
)
return
PR_FALSE
;
uint8_t
byte
;
for
(
uint16_t
i
=
0
;
i
<
length
;
i
+
+
)
if
(
!
XPT_Do8
(
cursor
&
byte
)
)
return
PR_FALSE
;
return
PR_TRUE
;
}
XPT_PUBLIC_API
(
PRBool
)
XPT_DoCString
(
XPTArena
*
arena
NotNull
<
XPTCursor
*
>
cursor
char
*
*
identp
bool
ignore
)
{
uint32_t
offset
=
0
;
if
(
!
XPT_Do32
(
cursor
&
offset
)
)
return
PR_FALSE
;
if
(
!
offset
)
{
*
identp
=
NULL
;
return
PR_TRUE
;
}
XPTCursor
my_cursor
;
my_cursor
.
pool
=
XPT_DATA
;
my_cursor
.
offset
=
offset
;
my_cursor
.
state
=
cursor
-
>
state
;
char
*
start
=
&
CURS_POINT
(
&
my_cursor
)
;
char
*
end
=
strchr
(
start
0
)
;
if
(
!
end
)
{
fprintf
(
stderr
"
didn
'
t
find
end
of
string
on
decode
!
\
n
"
)
;
return
PR_FALSE
;
}
int
len
=
end
-
start
;
XPT_ASSERT
(
len
>
0
)
;
if
(
!
ignore
)
{
char
*
ident
=
(
char
*
)
XPT_CALLOC1
(
arena
len
+
1u
)
;
if
(
!
ident
)
return
PR_FALSE
;
memcpy
(
ident
start
(
size_t
)
len
)
;
ident
[
len
]
=
0
;
*
identp
=
ident
;
}
return
PR_TRUE
;
}
XPT_PUBLIC_API
(
PRBool
)
XPT_DoIID
(
NotNull
<
XPTCursor
*
>
cursor
nsID
*
iidp
)
{
int
i
;
if
(
!
XPT_Do32
(
cursor
&
iidp
-
>
m0
)
|
|
!
XPT_Do16
(
cursor
&
iidp
-
>
m1
)
|
|
!
XPT_Do16
(
cursor
&
iidp
-
>
m2
)
)
return
PR_FALSE
;
for
(
i
=
0
;
i
<
8
;
i
+
+
)
if
(
!
XPT_Do8
(
cursor
(
uint8_t
*
)
&
iidp
-
>
m3
[
i
]
)
)
return
PR_FALSE
;
return
PR_TRUE
;
}
XPT_PUBLIC_API
(
PRBool
)
XPT_Do64
(
NotNull
<
XPTCursor
*
>
cursor
int64_t
*
u64p
)
{
return
XPT_Do32
(
cursor
(
uint32_t
*
)
u64p
)
&
&
XPT_Do32
(
cursor
(
(
uint32_t
*
)
u64p
)
+
1
)
;
}
XPT_PUBLIC_API
(
PRBool
)
XPT_Do32
(
NotNull
<
XPTCursor
*
>
cursor
uint32_t
*
u32p
)
{
union
{
uint8_t
b8
[
4
]
;
uint32_t
b32
;
}
u
;
if
(
!
CHECK_COUNT
(
cursor
4
)
)
return
PR_FALSE
;
u
.
b8
[
0
]
=
CURS_POINT
(
cursor
)
;
cursor
-
>
offset
+
+
;
u
.
b8
[
1
]
=
CURS_POINT
(
cursor
)
;
cursor
-
>
offset
+
+
;
u
.
b8
[
2
]
=
CURS_POINT
(
cursor
)
;
cursor
-
>
offset
+
+
;
u
.
b8
[
3
]
=
CURS_POINT
(
cursor
)
;
*
u32p
=
XPT_SWAB32
(
u
.
b32
)
;
cursor
-
>
offset
+
+
;
return
PR_TRUE
;
}
XPT_PUBLIC_API
(
PRBool
)
XPT_Do16
(
NotNull
<
XPTCursor
*
>
cursor
uint16_t
*
u16p
)
{
union
{
uint8_t
b8
[
2
]
;
uint16_t
b16
;
}
u
;
if
(
!
CHECK_COUNT
(
cursor
2
)
)
return
PR_FALSE
;
u
.
b8
[
0
]
=
CURS_POINT
(
cursor
)
;
cursor
-
>
offset
+
+
;
u
.
b8
[
1
]
=
CURS_POINT
(
cursor
)
;
*
u16p
=
XPT_SWAB16
(
u
.
b16
)
;
cursor
-
>
offset
+
+
;
return
PR_TRUE
;
}
XPT_PUBLIC_API
(
PRBool
)
XPT_Do8
(
NotNull
<
XPTCursor
*
>
cursor
uint8_t
*
u8p
)
{
if
(
!
CHECK_COUNT
(
cursor
1
)
)
return
PR_FALSE
;
*
u8p
=
CURS_POINT
(
cursor
)
;
cursor
-
>
offset
+
+
;
return
PR_TRUE
;
}
