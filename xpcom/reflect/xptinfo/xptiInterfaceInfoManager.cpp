#
include
"
mozilla
/
XPTInterfaceInfoManager
.
h
"
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
xptiprivate
.
h
"
#
include
"
nsDependentString
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsArrayEnumerator
.
h
"
#
include
"
nsDirectoryService
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
using
namespace
mozilla
;
NS_IMPL_ISUPPORTS
(
XPTInterfaceInfoManager
nsIInterfaceInfoManager
nsIMemoryReporter
)
static
StaticRefPtr
<
XPTInterfaceInfoManager
>
gInterfaceInfoManager
;
size_t
XPTInterfaceInfoManager
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
this
)
;
ReentrantMonitorAutoEnter
monitor
(
mWorkingSet
.
mTableReentrantMonitor
)
;
n
+
=
mWorkingSet
.
mIIDTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
n
+
=
mWorkingSet
.
mNameTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
n
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
XPTIMallocSizeOf
)
NS_IMETHODIMP
XPTInterfaceInfoManager
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
size_t
amount
=
SizeOfIncludingThis
(
XPTIMallocSizeOf
)
;
amount
+
=
XPT_SizeOfArenaIncludingThis
(
gXPTIStructArena
XPTIMallocSizeOf
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
xpti
-
working
-
set
"
KIND_HEAP
UNITS_BYTES
amount
"
Memory
used
by
the
XPCOM
typelib
system
.
"
)
;
return
NS_OK
;
}
XPTInterfaceInfoManager
*
XPTInterfaceInfoManager
:
:
GetSingleton
(
)
{
if
(
!
gInterfaceInfoManager
)
{
gInterfaceInfoManager
=
new
XPTInterfaceInfoManager
(
)
;
gInterfaceInfoManager
-
>
InitMemoryReporter
(
)
;
}
return
gInterfaceInfoManager
;
}
void
XPTInterfaceInfoManager
:
:
FreeInterfaceInfoManager
(
)
{
gInterfaceInfoManager
=
nullptr
;
}
XPTInterfaceInfoManager
:
:
XPTInterfaceInfoManager
(
)
:
mWorkingSet
(
)
mResolveLock
(
"
XPTInterfaceInfoManager
.
mResolveLock
"
)
{
}
XPTInterfaceInfoManager
:
:
~
XPTInterfaceInfoManager
(
)
{
mWorkingSet
.
InvalidateInterfaceInfos
(
)
;
UnregisterWeakMemoryReporter
(
this
)
;
}
void
XPTInterfaceInfoManager
:
:
InitMemoryReporter
(
)
{
RegisterWeakMemoryReporter
(
this
)
;
}
void
XPTInterfaceInfoManager
:
:
RegisterBuffer
(
char
*
buf
uint32_t
length
)
{
XPTState
state
;
XPT_InitXDRState
(
&
state
buf
length
)
;
XPTCursor
curs
;
NotNull
<
XPTCursor
*
>
cursor
=
WrapNotNull
(
&
curs
)
;
if
(
!
XPT_MakeCursor
(
&
state
XPT_HEADER
0
cursor
)
)
{
return
;
}
XPTHeader
*
header
=
nullptr
;
if
(
XPT_DoHeader
(
gXPTIStructArena
cursor
&
header
)
)
{
RegisterXPTHeader
(
header
)
;
}
}
void
XPTInterfaceInfoManager
:
:
RegisterXPTHeader
(
const
XPTHeader
*
aHeader
)
{
if
(
aHeader
-
>
mMajorVersion
>
=
XPT_MAJOR_INCOMPATIBLE_VERSION
)
{
MOZ_ASSERT
(
!
aHeader
-
>
mNumInterfaces
"
bad
libxpt
"
)
;
}
xptiTypelibGuts
*
typelib
=
xptiTypelibGuts
:
:
Create
(
aHeader
)
;
ReentrantMonitorAutoEnter
monitor
(
mWorkingSet
.
mTableReentrantMonitor
)
;
for
(
uint16_t
k
=
0
;
k
<
aHeader
-
>
mNumInterfaces
;
k
+
+
)
VerifyAndAddEntryIfNew
(
aHeader
-
>
mInterfaceDirectory
+
k
k
typelib
)
;
}
void
XPTInterfaceInfoManager
:
:
VerifyAndAddEntryIfNew
(
const
XPTInterfaceDirectoryEntry
*
iface
uint16_t
idx
xptiTypelibGuts
*
typelib
)
{
if
(
!
iface
-
>
mInterfaceDescriptor
)
return
;
if
(
iface
-
>
mInterfaceDescriptor
-
>
mNumMethods
>
250
&
&
!
iface
-
>
mInterfaceDescriptor
-
>
IsBuiltinClass
(
)
)
{
NS_ASSERTION
(
0
"
Too
many
methods
to
handle
for
the
stub
cannot
load
"
)
;
fprintf
(
stderr
"
ignoring
too
large
interface
:
%
s
\
n
"
iface
-
>
mName
)
;
return
;
}
mWorkingSet
.
mTableReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
xptiInterfaceEntry
*
entry
=
mWorkingSet
.
mIIDTable
.
Get
(
iface
-
>
mIID
)
;
if
(
entry
)
{
return
;
}
entry
=
xptiInterfaceEntry
:
:
Create
(
iface
-
>
mName
iface
-
>
mIID
iface
-
>
mInterfaceDescriptor
typelib
)
;
if
(
!
entry
)
return
;
entry
-
>
SetScriptableFlag
(
iface
-
>
mInterfaceDescriptor
-
>
IsScriptable
(
)
)
;
entry
-
>
SetBuiltinClassFlag
(
iface
-
>
mInterfaceDescriptor
-
>
IsBuiltinClass
(
)
)
;
entry
-
>
SetMainProcessScriptableOnlyFlag
(
iface
-
>
mInterfaceDescriptor
-
>
IsMainProcessScriptableOnly
(
)
)
;
mWorkingSet
.
mIIDTable
.
Put
(
entry
-
>
IID
(
)
entry
)
;
mWorkingSet
.
mNameTable
.
Put
(
entry
-
>
GetTheName
(
)
entry
)
;
typelib
-
>
SetEntryAt
(
idx
entry
)
;
}
static
nsresult
EntryToInfo
(
xptiInterfaceEntry
*
entry
nsIInterfaceInfo
*
*
_retval
)
{
if
(
!
entry
)
{
*
_retval
=
nullptr
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
xptiInterfaceInfo
>
info
=
entry
-
>
InterfaceInfo
(
)
;
info
.
forget
(
_retval
)
;
return
NS_OK
;
}
xptiInterfaceEntry
*
XPTInterfaceInfoManager
:
:
GetInterfaceEntryForIID
(
const
nsIID
*
iid
)
{
ReentrantMonitorAutoEnter
monitor
(
mWorkingSet
.
mTableReentrantMonitor
)
;
return
mWorkingSet
.
mIIDTable
.
Get
(
*
iid
)
;
}
NS_IMETHODIMP
XPTInterfaceInfoManager
:
:
GetInfoForIID
(
const
nsIID
*
iid
nsIInterfaceInfo
*
*
_retval
)
{
NS_ASSERTION
(
iid
"
bad
param
"
)
;
NS_ASSERTION
(
_retval
"
bad
param
"
)
;
ReentrantMonitorAutoEnter
monitor
(
mWorkingSet
.
mTableReentrantMonitor
)
;
xptiInterfaceEntry
*
entry
=
mWorkingSet
.
mIIDTable
.
Get
(
*
iid
)
;
return
EntryToInfo
(
entry
_retval
)
;
}
NS_IMETHODIMP
XPTInterfaceInfoManager
:
:
GetInfoForName
(
const
char
*
name
nsIInterfaceInfo
*
*
_retval
)
{
NS_ASSERTION
(
name
"
bad
param
"
)
;
NS_ASSERTION
(
_retval
"
bad
param
"
)
;
ReentrantMonitorAutoEnter
monitor
(
mWorkingSet
.
mTableReentrantMonitor
)
;
xptiInterfaceEntry
*
entry
=
mWorkingSet
.
mNameTable
.
Get
(
name
)
;
return
EntryToInfo
(
entry
_retval
)
;
}
void
XPTInterfaceInfoManager
:
:
GetScriptableInterfaces
(
nsCOMArray
<
nsIInterfaceInfo
>
&
aInterfaces
)
{
ReentrantMonitorAutoEnter
monitor
(
mWorkingSet
.
mTableReentrantMonitor
)
;
aInterfaces
.
SetCapacity
(
mWorkingSet
.
mNameTable
.
Count
(
)
)
;
for
(
auto
iter
=
mWorkingSet
.
mNameTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
xptiInterfaceEntry
*
entry
=
iter
.
UserData
(
)
;
if
(
entry
-
>
GetScriptableFlag
(
)
)
{
nsCOMPtr
<
nsIInterfaceInfo
>
ii
=
entry
-
>
InterfaceInfo
(
)
;
aInterfaces
.
AppendElement
(
ii
)
;
}
}
}
