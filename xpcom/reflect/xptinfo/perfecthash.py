from
collections
import
namedtuple
FNV_OFFSET_BASIS
=
0x811C9DC5
FNV_PRIME
=
16777619
U32_HIGH_BIT
=
0x80000000
def
hash
(
bytes
h
=
FNV_OFFSET_BASIS
)
:
    
for
byte
in
bytes
:
        
h
^
=
byte
        
h
*
=
FNV_PRIME
        
h
&
=
0xffffffff
    
return
h
IntermediateBucket
=
namedtuple
(
'
IntermediateBucket
'
[
'
index
'
'
entries
'
]
)
HashEntry
=
namedtuple
(
'
HashEntry
'
[
'
key
'
'
value
'
]
)
class
PerfectHash
(
object
)
:
    
"
"
"
An
object
representing
a
perfect
hash
function
"
"
"
    
def
__init__
(
self
intermediate_table_size
data
)
:
        
self
.
intermediate
=
[
0
]
*
intermediate_table_size
        
self
.
values
=
[
None
]
*
len
(
data
)
        
assert
len
(
self
.
values
)
<
U32_HIGH_BIT
\
            
"
Not
enough
space
in
uint32_t
to
index
%
d
values
"
%
len
(
self
.
values
)
        
buckets
=
[
IntermediateBucket
(
index
=
idx
entries
=
[
]
)
                   
for
idx
in
range
(
len
(
self
.
intermediate
)
)
]
        
for
key
value
in
data
:
            
assert
isinstance
(
key
bytearray
)
\
                
"
data
should
be
a
list
of
(
bytearray
value
)
pairs
"
            
assert
value
is
not
None
"
cannot
handle
a
None
value
"
            
buckets
[
hash
(
key
)
%
len
(
self
.
intermediate
)
]
.
entries
\
                
.
append
(
HashEntry
(
key
=
key
value
=
value
)
)
        
buckets
.
sort
(
key
=
lambda
b
:
len
(
b
.
entries
)
reverse
=
True
)
        
freecursor
=
0
        
for
bucket
in
buckets
:
            
if
len
(
bucket
.
entries
)
=
=
0
:
                
break
            
elif
len
(
bucket
.
entries
)
=
=
1
:
                
while
freecursor
<
len
(
self
.
values
)
:
                    
if
self
.
values
[
freecursor
]
is
None
:
                        
self
.
intermediate
[
bucket
.
index
]
=
freecursor
|
U32_HIGH_BIT
                        
self
.
values
[
freecursor
]
=
bucket
.
entries
[
0
]
.
value
                        
break
                    
freecursor
+
=
1
                
continue
            
idx
=
0
            
basis
=
1
            
slots
=
[
]
            
while
idx
<
len
(
bucket
.
entries
)
:
                
slot
=
hash
(
bucket
.
entries
[
idx
]
.
key
basis
)
%
len
(
self
.
values
)
                
if
self
.
values
[
slot
]
is
not
None
or
slot
in
slots
:
                    
basis
+
=
1
                    
idx
=
0
                    
del
slots
[
:
]
                
else
:
                    
slots
.
append
(
slot
)
                    
idx
+
=
1
            
assert
basis
<
U32_HIGH_BIT
\
                
"
not
enough
space
in
uint32_t
to
store
basis
%
d
"
%
basis
            
self
.
intermediate
[
bucket
.
index
]
=
basis
            
for
slot
entry
in
zip
(
slots
bucket
.
entries
)
:
                
self
.
values
[
slot
]
=
entry
.
value
    
def
lookup
(
self
key
)
:
        
mid
=
self
.
intermediate
[
hash
(
key
)
%
len
(
self
.
intermediate
)
]
        
if
mid
&
U32_HIGH_BIT
:
            
return
self
.
values
[
mid
&
~
U32_HIGH_BIT
]
        
else
:
            
return
self
.
values
[
hash
(
key
mid
)
%
len
(
self
.
values
)
]
