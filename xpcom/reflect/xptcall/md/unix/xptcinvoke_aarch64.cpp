#
include
"
xptcprivate
.
h
"
#
if
!
defined
(
__aarch64__
)
#
error
"
This
code
is
for
Linux
AArch64
only
.
"
#
endif
#
ifndef
__AARCH64EL__
#
error
"
Only
little
endian
compatibility
was
tested
"
#
endif
template
<
typename
T
>
inline
uint64_t
normalize_arg
(
T
value
)
{
return
(
uint64_t
)
value
;
}
template
<
>
inline
uint64_t
normalize_arg
(
float
value
)
{
uint64_t
result
=
0
;
memcpy
(
&
result
&
value
sizeof
(
value
)
)
;
return
result
;
}
template
<
>
inline
uint64_t
normalize_arg
(
double
value
)
{
uint64_t
result
=
0
;
memcpy
(
&
result
&
value
sizeof
(
value
)
)
;
return
result
;
}
template
<
typename
T
>
static
inline
void
alloc_arg
(
uint64_t
*
&
reg_args
uint64_t
*
reg_args_end
void
*
&
stack_args
T
*
data
)
{
if
(
reg_args
<
reg_args_end
)
{
*
reg_args
=
normalize_arg
(
*
data
)
;
reg_args
+
+
;
}
else
{
#
ifdef
__APPLE__
const
size_t
aligned_size
=
sizeof
(
T
)
;
#
else
const
size_t
aligned_size
=
8
;
#
endif
uintptr_t
addr
=
(
reinterpret_cast
<
uintptr_t
>
(
stack_args
)
+
aligned_size
-
1
)
&
~
(
aligned_size
-
1
)
;
memcpy
(
reinterpret_cast
<
void
*
>
(
addr
)
data
sizeof
(
T
)
)
;
stack_args
=
reinterpret_cast
<
void
*
>
(
addr
+
aligned_size
)
;
}
}
extern
"
C
"
void
invoke_copy_to_stack
(
uint64_t
*
stk
uint64_t
*
end
uint32_t
paramCount
nsXPTCVariant
*
s
)
{
uint64_t
*
ireg_args
=
stk
;
uint64_t
*
ireg_end
=
ireg_args
+
8
;
uint64_t
*
freg_args
=
ireg_end
;
uint64_t
*
freg_end
=
freg_args
+
8
;
void
*
stack_args
=
freg_end
;
+
+
ireg_args
;
for
(
uint32_t
i
=
0
;
i
<
paramCount
;
i
+
+
s
+
+
)
{
if
(
s
-
>
IsIndirect
(
)
)
{
void
*
ptr
=
&
s
-
>
val
;
alloc_arg
(
ireg_args
ireg_end
stack_args
&
ptr
)
;
}
else
{
switch
(
s
-
>
type
)
{
case
nsXPTType
:
:
T_FLOAT
:
alloc_arg
(
freg_args
freg_end
stack_args
&
s
-
>
val
.
f
)
;
break
;
case
nsXPTType
:
:
T_DOUBLE
:
alloc_arg
(
freg_args
freg_end
stack_args
&
s
-
>
val
.
d
)
;
break
;
case
nsXPTType
:
:
T_I8
:
alloc_arg
(
ireg_args
ireg_end
stack_args
&
s
-
>
val
.
i8
)
;
break
;
case
nsXPTType
:
:
T_I16
:
alloc_arg
(
ireg_args
ireg_end
stack_args
&
s
-
>
val
.
i16
)
;
break
;
case
nsXPTType
:
:
T_I32
:
alloc_arg
(
ireg_args
ireg_end
stack_args
&
s
-
>
val
.
i32
)
;
break
;
case
nsXPTType
:
:
T_I64
:
alloc_arg
(
ireg_args
ireg_end
stack_args
&
s
-
>
val
.
i64
)
;
break
;
case
nsXPTType
:
:
T_U8
:
alloc_arg
(
ireg_args
ireg_end
stack_args
&
s
-
>
val
.
u8
)
;
break
;
case
nsXPTType
:
:
T_U16
:
alloc_arg
(
ireg_args
ireg_end
stack_args
&
s
-
>
val
.
u16
)
;
break
;
case
nsXPTType
:
:
T_U32
:
alloc_arg
(
ireg_args
ireg_end
stack_args
&
s
-
>
val
.
u32
)
;
break
;
case
nsXPTType
:
:
T_U64
:
alloc_arg
(
ireg_args
ireg_end
stack_args
&
s
-
>
val
.
u64
)
;
break
;
case
nsXPTType
:
:
T_BOOL
:
alloc_arg
(
ireg_args
ireg_end
stack_args
&
s
-
>
val
.
b
)
;
break
;
case
nsXPTType
:
:
T_CHAR
:
alloc_arg
(
ireg_args
ireg_end
stack_args
&
s
-
>
val
.
c
)
;
break
;
case
nsXPTType
:
:
T_WCHAR
:
alloc_arg
(
ireg_args
ireg_end
stack_args
&
s
-
>
val
.
wc
)
;
break
;
default
:
alloc_arg
(
ireg_args
ireg_end
stack_args
&
s
-
>
val
.
p
)
;
break
;
}
}
}
}
extern
"
C
"
nsresult
_NS_InvokeByIndex
(
nsISupports
*
that
uint32_t
methodIndex
uint32_t
paramCount
nsXPTCVariant
*
params
)
;
EXPORT_XPCOM_API
(
nsresult
)
NS_InvokeByIndex
(
nsISupports
*
that
uint32_t
methodIndex
uint32_t
paramCount
nsXPTCVariant
*
params
)
{
return
_NS_InvokeByIndex
(
that
methodIndex
paramCount
params
)
;
}
