#
include
"
xptcprivate
.
h
"
#
if
!
defined
(
__aarch64__
)
#
error
"
This
code
is
for
Linux
AArch64
only
.
"
#
endif
#
ifndef
__AARCH64EL__
#
error
"
Only
little
endian
compatibility
was
tested
"
#
endif
static
inline
void
alloc_word
(
uint64_t
*
&
ireg_args
uint64_t
*
&
stack_args
uint64_t
*
end
uint64_t
data
)
{
if
(
ireg_args
<
end
)
{
*
ireg_args
=
data
;
ireg_args
+
+
;
}
else
{
*
stack_args
=
data
;
stack_args
+
+
;
}
}
static
inline
void
alloc_double
(
double
*
&
freg_args
uint64_t
*
&
stack_args
double
*
end
double
data
)
{
if
(
freg_args
<
end
)
{
*
freg_args
=
data
;
freg_args
+
+
;
}
else
{
memcpy
(
stack_args
&
data
sizeof
(
data
)
)
;
stack_args
+
+
;
}
}
static
inline
void
alloc_float
(
double
*
&
freg_args
uint64_t
*
&
stack_args
double
*
end
float
data
)
{
if
(
freg_args
<
end
)
{
memcpy
(
freg_args
&
data
sizeof
(
data
)
)
;
freg_args
+
+
;
}
else
{
memcpy
(
stack_args
&
data
sizeof
(
data
)
)
;
stack_args
+
+
;
}
}
extern
"
C
"
void
invoke_copy_to_stack
(
uint64_t
*
stk
uint64_t
*
end
uint32_t
paramCount
nsXPTCVariant
*
s
)
{
uint64_t
*
ireg_args
=
stk
;
uint64_t
*
ireg_end
=
ireg_args
+
8
;
double
*
freg_args
=
(
double
*
)
ireg_end
;
double
*
freg_end
=
freg_args
+
8
;
uint64_t
*
stack_args
=
(
uint64_t
*
)
freg_end
;
+
+
ireg_args
;
for
(
uint32_t
i
=
0
;
i
<
paramCount
;
i
+
+
s
+
+
)
{
uint64_t
word
;
if
(
s
-
>
IsIndirect
(
)
)
{
word
=
(
uint64_t
)
&
s
-
>
val
;
}
else
{
switch
(
s
-
>
type
)
{
case
nsXPTType
:
:
T_FLOAT
:
alloc_float
(
freg_args
stack_args
freg_end
s
-
>
val
.
f
)
;
continue
;
case
nsXPTType
:
:
T_DOUBLE
:
alloc_double
(
freg_args
stack_args
freg_end
s
-
>
val
.
d
)
;
continue
;
case
nsXPTType
:
:
T_I8
:
word
=
s
-
>
val
.
i8
;
break
;
case
nsXPTType
:
:
T_I16
:
word
=
s
-
>
val
.
i16
;
break
;
case
nsXPTType
:
:
T_I32
:
word
=
s
-
>
val
.
i32
;
break
;
case
nsXPTType
:
:
T_I64
:
word
=
s
-
>
val
.
i64
;
break
;
case
nsXPTType
:
:
T_U8
:
word
=
s
-
>
val
.
u8
;
break
;
case
nsXPTType
:
:
T_U16
:
word
=
s
-
>
val
.
u16
;
break
;
case
nsXPTType
:
:
T_U32
:
word
=
s
-
>
val
.
u32
;
break
;
case
nsXPTType
:
:
T_U64
:
word
=
s
-
>
val
.
u64
;
break
;
case
nsXPTType
:
:
T_BOOL
:
word
=
s
-
>
val
.
b
;
break
;
case
nsXPTType
:
:
T_CHAR
:
word
=
s
-
>
val
.
c
;
break
;
case
nsXPTType
:
:
T_WCHAR
:
word
=
s
-
>
val
.
wc
;
break
;
default
:
word
=
reinterpret_cast
<
uint64_t
>
(
s
-
>
val
.
p
)
;
break
;
}
}
alloc_word
(
ireg_args
stack_args
ireg_end
word
)
;
}
}
extern
"
C
"
nsresult
_NS_InvokeByIndex
(
nsISupports
*
that
uint32_t
methodIndex
uint32_t
paramCount
nsXPTCVariant
*
params
)
;
EXPORT_XPCOM_API
(
nsresult
)
NS_InvokeByIndex
(
nsISupports
*
that
uint32_t
methodIndex
uint32_t
paramCount
nsXPTCVariant
*
params
)
{
return
_NS_InvokeByIndex
(
that
methodIndex
paramCount
params
)
;
}
