#
include
"
xptcprivate
.
h
"
const
uint32_t
GPR_COUNT
=
7
;
const
uint32_t
FPR_COUNT
=
13
;
extern
"
C
"
nsresult
ATTRIBUTE_USED
PrepareAndDispatch
(
nsXPTCStubBase
*
self
uint32_t
methodIndex
uint64_t
*
args
uint64_t
*
gpregs
double
*
fpregs
)
{
nsXPTCMiniVariant
paramBuffer
[
PARAM_BUFFER_COUNT
]
;
const
nsXPTMethodInfo
*
info
;
uint32_t
paramCount
;
uint32_t
i
;
NS_ASSERTION
(
self
"
no
self
"
)
;
self
-
>
mEntry
-
>
GetMethodInfo
(
uint16_t
(
methodIndex
)
&
info
)
;
NS_ASSERTION
(
info
"
no
method
info
"
)
;
if
(
!
info
)
return
NS_ERROR_UNEXPECTED
;
paramCount
=
info
-
>
GetParamCount
(
)
;
const
uint8_t
indexOfJSContext
=
info
-
>
IndexOfJSContext
(
)
;
uint64_t
*
ap
=
args
;
uint32_t
nr_gpr
=
0
;
uint32_t
nr_fpr
=
0
;
uint64_t
value
;
for
(
i
=
0
;
i
<
paramCount
;
i
+
+
)
{
const
nsXPTParamInfo
&
param
=
info
-
>
GetParam
(
i
)
;
const
nsXPTType
&
type
=
param
.
GetType
(
)
;
nsXPTCMiniVariant
*
dp
=
&
paramBuffer
[
i
]
;
if
(
i
=
=
indexOfJSContext
)
{
if
(
nr_gpr
<
GPR_COUNT
)
nr_gpr
+
+
;
else
ap
+
+
;
}
if
(
!
param
.
IsOut
(
)
&
&
type
=
=
nsXPTType
:
:
T_DOUBLE
)
{
if
(
nr_fpr
<
FPR_COUNT
)
{
dp
-
>
val
.
d
=
fpregs
[
nr_fpr
+
+
]
;
nr_gpr
+
+
;
}
else
{
dp
-
>
val
.
d
=
*
(
double
*
)
ap
+
+
;
}
continue
;
}
if
(
!
param
.
IsOut
(
)
&
&
type
=
=
nsXPTType
:
:
T_FLOAT
)
{
if
(
nr_fpr
<
FPR_COUNT
)
{
dp
-
>
val
.
f
=
(
float
)
fpregs
[
nr_fpr
+
+
]
;
nr_gpr
+
+
;
}
else
{
#
ifdef
__LITTLE_ENDIAN__
dp
-
>
val
.
f
=
*
(
float
*
)
ap
+
+
;
#
else
float
*
p
=
(
float
*
)
ap
;
p
+
+
;
dp
-
>
val
.
f
=
*
p
;
ap
+
+
;
#
endif
}
continue
;
}
if
(
nr_gpr
<
GPR_COUNT
)
value
=
gpregs
[
nr_gpr
+
+
]
;
else
value
=
*
ap
+
+
;
if
(
param
.
IsOut
(
)
|
|
!
type
.
IsArithmetic
(
)
)
{
dp
-
>
val
.
p
=
(
void
*
)
value
;
continue
;
}
switch
(
type
)
{
case
nsXPTType
:
:
T_I8
:
dp
-
>
val
.
i8
=
(
int8_t
)
value
;
break
;
case
nsXPTType
:
:
T_I16
:
dp
-
>
val
.
i16
=
(
int16_t
)
value
;
break
;
case
nsXPTType
:
:
T_I32
:
dp
-
>
val
.
i32
=
(
int32_t
)
value
;
break
;
case
nsXPTType
:
:
T_I64
:
dp
-
>
val
.
i64
=
(
int64_t
)
value
;
break
;
case
nsXPTType
:
:
T_U8
:
dp
-
>
val
.
u8
=
(
uint8_t
)
value
;
break
;
case
nsXPTType
:
:
T_U16
:
dp
-
>
val
.
u16
=
(
uint16_t
)
value
;
break
;
case
nsXPTType
:
:
T_U32
:
dp
-
>
val
.
u32
=
(
uint32_t
)
value
;
break
;
case
nsXPTType
:
:
T_U64
:
dp
-
>
val
.
u64
=
(
uint64_t
)
value
;
break
;
case
nsXPTType
:
:
T_BOOL
:
dp
-
>
val
.
b
=
(
bool
)
value
;
break
;
case
nsXPTType
:
:
T_CHAR
:
dp
-
>
val
.
c
=
(
char
)
value
;
break
;
case
nsXPTType
:
:
T_WCHAR
:
dp
-
>
val
.
wc
=
(
wchar_t
)
value
;
break
;
default
:
NS_ERROR
(
"
bad
type
"
)
;
break
;
}
}
nsresult
result
=
self
-
>
mOuter
-
>
CallMethod
(
(
uint16_t
)
methodIndex
info
paramBuffer
)
;
return
result
;
}
#
if
_CALL_ELF
=
=
2
#
define
STUB_ENTRY
(
n
)
\
__asm__
(
\
"
.
section
\
"
.
text
\
"
\
n
\
t
"
\
"
.
align
2
\
n
\
t
"
\
"
.
if
"
#
n
"
<
10
\
n
\
t
"
\
"
.
globl
_ZN14nsXPTCStubBase5Stub
"
#
n
"
Ev
\
n
\
t
"
\
"
.
type
_ZN14nsXPTCStubBase5Stub
"
#
n
"
Ev
function
\
n
\
n
"
\
"
_ZN14nsXPTCStubBase5Stub
"
#
n
"
Ev
:
\
n
\
t
"
\
"
0
:
addis
2
12
.
TOC
.
-
0b
ha
\
n
\
t
"
\
"
addi
2
2
.
TOC
.
-
0b
l
\
n
\
t
"
\
"
.
localentry
_ZN14nsXPTCStubBase5Stub
"
#
n
"
Ev
.
-
_ZN14nsXPTCStubBase5Stub
"
#
n
"
Ev
\
n
\
t
"
\
\
"
.
elseif
"
#
n
"
<
100
\
n
\
t
"
\
"
.
globl
_ZN14nsXPTCStubBase6Stub
"
#
n
"
Ev
\
n
\
t
"
\
"
.
type
_ZN14nsXPTCStubBase6Stub
"
#
n
"
Ev
function
\
n
\
n
"
\
"
_ZN14nsXPTCStubBase6Stub
"
#
n
"
Ev
:
\
n
\
t
"
\
"
0
:
addis
2
12
.
TOC
.
-
0b
ha
\
n
\
t
"
\
"
addi
2
2
.
TOC
.
-
0b
l
\
n
\
t
"
\
"
.
localentry
_ZN14nsXPTCStubBase6Stub
"
#
n
"
Ev
.
-
_ZN14nsXPTCStubBase6Stub
"
#
n
"
Ev
\
n
\
t
"
\
\
"
.
elseif
"
#
n
"
<
1000
\
n
\
t
"
\
"
.
globl
_ZN14nsXPTCStubBase7Stub
"
#
n
"
Ev
\
n
\
t
"
\
"
.
type
_ZN14nsXPTCStubBase7Stub
"
#
n
"
Ev
function
\
n
\
n
"
\
"
_ZN14nsXPTCStubBase7Stub
"
#
n
"
Ev
:
\
n
\
t
"
\
"
0
:
addis
2
12
.
TOC
.
-
0b
ha
\
n
\
t
"
\
"
addi
2
2
.
TOC
.
-
0b
l
\
n
\
t
"
\
"
.
localentry
_ZN14nsXPTCStubBase7Stub
"
#
n
"
Ev
.
-
_ZN14nsXPTCStubBase7Stub
"
#
n
"
Ev
\
n
\
t
"
\
\
"
.
else
\
n
\
t
"
\
"
.
err
\
"
stub
number
"
#
n
"
>
=
1000
not
yet
supported
\
"
\
n
"
\
"
.
endif
\
n
\
t
"
\
\
"
li
11
"
#
n
"
\
n
\
t
"
\
"
b
SharedStub
\
n
"
\
)
;
#
else
#
define
STUB_ENTRY
(
n
)
\
__asm__
(
\
"
.
section
\
"
.
toc
\
"
\
"
aw
\
"
\
n
\
t
"
\
"
.
section
\
"
.
text
\
"
\
n
\
t
"
\
"
.
align
2
\
n
\
t
"
\
"
.
if
"
#
n
"
<
10
\
n
\
t
"
\
"
.
globl
_ZN14nsXPTCStubBase5Stub
"
#
n
"
Ev
\
n
\
t
"
\
"
.
section
\
"
.
opd
\
"
\
"
aw
\
"
\
n
\
t
"
\
"
.
align
3
\
n
\
t
"
\
"
_ZN14nsXPTCStubBase5Stub
"
#
n
"
Ev
:
\
n
\
t
"
\
"
.
quad
.
_ZN14nsXPTCStubBase5Stub
"
#
n
"
Ev
.
TOC
.
tocbase
\
n
\
t
"
\
"
.
previous
\
n
\
t
"
\
"
.
type
_ZN14nsXPTCStubBase5Stub
"
#
n
"
Ev
function
\
n
\
n
"
\
"
.
_ZN14nsXPTCStubBase5Stub
"
#
n
"
Ev
:
\
n
\
t
"
\
\
"
.
elseif
"
#
n
"
<
100
\
n
\
t
"
\
"
.
globl
_ZN14nsXPTCStubBase6Stub
"
#
n
"
Ev
\
n
\
t
"
\
"
.
section
\
"
.
opd
\
"
\
"
aw
\
"
\
n
\
t
"
\
"
.
align
3
\
n
\
t
"
\
"
_ZN14nsXPTCStubBase6Stub
"
#
n
"
Ev
:
\
n
\
t
"
\
"
.
quad
.
_ZN14nsXPTCStubBase6Stub
"
#
n
"
Ev
.
TOC
.
tocbase
\
n
\
t
"
\
"
.
previous
\
n
\
t
"
\
"
.
type
_ZN14nsXPTCStubBase6Stub
"
#
n
"
Ev
function
\
n
\
n
"
\
"
.
_ZN14nsXPTCStubBase6Stub
"
#
n
"
Ev
:
\
n
\
t
"
\
\
"
.
elseif
"
#
n
"
<
1000
\
n
\
t
"
\
"
.
globl
_ZN14nsXPTCStubBase7Stub
"
#
n
"
Ev
\
n
\
t
"
\
"
.
section
\
"
.
opd
\
"
\
"
aw
\
"
\
n
\
t
"
\
"
.
align
3
\
n
\
t
"
\
"
_ZN14nsXPTCStubBase7Stub
"
#
n
"
Ev
:
\
n
\
t
"
\
"
.
quad
.
_ZN14nsXPTCStubBase7Stub
"
#
n
"
Ev
.
TOC
.
tocbase
\
n
\
t
"
\
"
.
previous
\
n
\
t
"
\
"
.
type
_ZN14nsXPTCStubBase7Stub
"
#
n
"
Ev
function
\
n
\
n
"
\
"
.
_ZN14nsXPTCStubBase7Stub
"
#
n
"
Ev
:
\
n
\
t
"
\
\
"
.
else
\
n
\
t
"
\
"
.
err
\
"
stub
number
"
#
n
"
>
=
1000
not
yet
supported
\
"
\
n
"
\
"
.
endif
\
n
\
t
"
\
\
"
li
11
"
#
n
"
\
n
\
t
"
\
"
b
SharedStub
\
n
"
\
)
;
#
endif
#
define
SENTINEL_ENTRY
(
n
)
\
nsresult
nsXPTCStubBase
:
:
Sentinel
#
#
n
(
)
\
{
\
NS_ERROR
(
"
nsXPTCStubBase
:
:
Sentinel
called
"
)
;
\
return
NS_ERROR_NOT_IMPLEMENTED
;
\
}
#
include
"
xptcstubsdef
.
inc
"
