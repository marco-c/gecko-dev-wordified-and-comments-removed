#
include
"
xptcprivate
.
h
"
const
uint32_t
GPR_COUNT
=
5
;
const
uint32_t
FPR_COUNT
=
8
;
extern
"
C
"
void
InvokeCopyToStack
(
uint64_t
*
gpregs
double
*
fpregs
uint32_t
paramCount
nsXPTCVariant
*
s
uint64_t
*
d
)
{
uint32_t
nr_gpr
=
0u
;
uint32_t
nr_fpr
=
0u
;
uint64_t
value
=
0u
;
for
(
uint32_t
i
=
0
;
i
<
paramCount
;
i
+
+
s
+
+
)
{
if
(
s
-
>
IsIndirect
(
)
)
value
=
(
uint64_t
)
&
s
-
>
val
;
else
{
switch
(
s
-
>
type
)
{
case
nsXPTType
:
:
T_FLOAT
:
break
;
case
nsXPTType
:
:
T_DOUBLE
:
break
;
case
nsXPTType
:
:
T_I8
:
value
=
s
-
>
val
.
i8
;
break
;
case
nsXPTType
:
:
T_I16
:
value
=
s
-
>
val
.
i16
;
break
;
case
nsXPTType
:
:
T_I32
:
value
=
s
-
>
val
.
i32
;
break
;
case
nsXPTType
:
:
T_I64
:
value
=
s
-
>
val
.
i64
;
break
;
case
nsXPTType
:
:
T_U8
:
value
=
s
-
>
val
.
u8
;
break
;
case
nsXPTType
:
:
T_U16
:
value
=
s
-
>
val
.
u16
;
break
;
case
nsXPTType
:
:
T_U32
:
value
=
s
-
>
val
.
u32
;
break
;
case
nsXPTType
:
:
T_U64
:
value
=
s
-
>
val
.
u64
;
break
;
case
nsXPTType
:
:
T_BOOL
:
value
=
s
-
>
val
.
b
;
break
;
case
nsXPTType
:
:
T_CHAR
:
value
=
s
-
>
val
.
c
;
break
;
case
nsXPTType
:
:
T_WCHAR
:
value
=
s
-
>
val
.
wc
;
break
;
default
:
value
=
(
uint64_t
)
s
-
>
val
.
p
;
break
;
}
}
if
(
!
s
-
>
IsIndirect
(
)
&
&
s
-
>
type
=
=
nsXPTType
:
:
T_DOUBLE
)
{
if
(
nr_fpr
<
FPR_COUNT
)
fpregs
[
nr_fpr
+
+
]
=
s
-
>
val
.
d
;
else
{
*
(
(
double
*
)
d
)
=
s
-
>
val
.
d
;
d
+
+
;
}
}
else
if
(
!
s
-
>
IsIndirect
(
)
&
&
s
-
>
type
=
=
nsXPTType
:
:
T_FLOAT
)
{
if
(
nr_fpr
<
FPR_COUNT
)
fpregs
[
nr_fpr
+
+
]
=
s
-
>
val
.
d
;
else
{
*
(
(
float
*
)
d
)
=
s
-
>
val
.
f
;
d
+
+
;
}
}
else
{
if
(
nr_gpr
<
GPR_COUNT
)
gpregs
[
nr_gpr
+
+
]
=
value
;
else
*
d
+
+
=
value
;
}
}
}
