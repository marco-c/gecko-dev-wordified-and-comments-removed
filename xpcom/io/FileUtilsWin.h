#
ifndef
mozilla_FileUtilsWin_h
#
define
mozilla_FileUtilsWin_h
#
include
<
windows
.
h
>
#
include
"
mozilla
/
Scoped
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
inline
bool
EnsureLongPath
(
nsAString
&
aDosPath
)
{
nsAutoString
inputPath
(
aDosPath
)
;
while
(
true
)
{
DWORD
requiredLength
=
GetLongPathNameW
(
inputPath
.
get
(
)
reinterpret_cast
<
wchar_t
*
>
(
aDosPath
.
BeginWriting
(
)
)
aDosPath
.
Length
(
)
)
;
if
(
!
requiredLength
)
{
return
false
;
}
if
(
requiredLength
<
aDosPath
.
Length
(
)
)
{
aDosPath
.
Truncate
(
requiredLength
)
;
return
true
;
}
aDosPath
.
SetLength
(
requiredLength
)
;
}
}
inline
bool
NtPathToDosPath
(
const
nsAString
&
aNtPath
nsAString
&
aDosPath
)
{
aDosPath
.
Truncate
(
)
;
if
(
aNtPath
.
IsEmpty
(
)
)
{
return
true
;
}
constexpr
auto
symLinkPrefix
=
u
"
\
\
?
?
\
\
"
_ns
;
uint32_t
ntPathLen
=
aNtPath
.
Length
(
)
;
uint32_t
symLinkPrefixLen
=
symLinkPrefix
.
Length
(
)
;
if
(
ntPathLen
>
=
6
&
&
aNtPath
.
CharAt
(
5
)
=
=
L
'
:
'
&
&
ntPathLen
>
=
symLinkPrefixLen
&
&
Substring
(
aNtPath
0
symLinkPrefixLen
)
.
Equals
(
symLinkPrefix
)
)
{
aDosPath
=
aNtPath
;
aDosPath
.
Cut
(
0
4
)
;
return
true
;
}
nsAutoString
logicalDrives
;
while
(
true
)
{
DWORD
requiredLength
=
GetLogicalDriveStringsW
(
logicalDrives
.
Length
(
)
reinterpret_cast
<
wchar_t
*
>
(
logicalDrives
.
BeginWriting
(
)
)
)
;
if
(
!
requiredLength
)
{
return
false
;
}
if
(
requiredLength
<
logicalDrives
.
Length
(
)
)
{
logicalDrives
.
Truncate
(
requiredLength
)
;
break
;
}
logicalDrives
.
SetLength
(
requiredLength
)
;
}
const
char16_t
*
cur
=
logicalDrives
.
BeginReading
(
)
;
const
char16_t
*
end
=
logicalDrives
.
EndReading
(
)
;
nsString
targetPath
;
targetPath
.
SetLength
(
MAX_PATH
)
;
wchar_t
driveTemplate
[
]
=
L
"
:
"
;
while
(
cur
<
end
)
{
driveTemplate
[
0
]
=
*
cur
;
DWORD
targetPathLen
=
0
;
SetLastError
(
ERROR_SUCCESS
)
;
while
(
true
)
{
targetPathLen
=
QueryDosDeviceW
(
driveTemplate
reinterpret_cast
<
wchar_t
*
>
(
targetPath
.
BeginWriting
(
)
)
targetPath
.
Length
(
)
)
;
if
(
targetPathLen
|
|
GetLastError
(
)
!
=
ERROR_INSUFFICIENT_BUFFER
)
{
break
;
}
targetPath
.
SetLength
(
targetPath
.
Length
(
)
*
2
)
;
}
if
(
targetPathLen
)
{
size_t
firstTargetPathLen
=
wcslen
(
targetPath
.
get
(
)
)
;
const
char16_t
*
pathComponent
=
aNtPath
.
BeginReading
(
)
+
firstTargetPathLen
;
bool
found
=
_wcsnicmp
(
char16ptr_t
(
aNtPath
.
BeginReading
(
)
)
targetPath
.
get
(
)
firstTargetPathLen
)
=
=
0
&
&
*
pathComponent
=
=
L
'
\
\
'
;
if
(
found
)
{
aDosPath
=
driveTemplate
;
aDosPath
+
=
pathComponent
;
return
EnsureLongPath
(
aDosPath
)
;
}
}
while
(
*
cur
)
{
cur
+
+
;
}
cur
+
+
;
}
constexpr
auto
uncPrefix
=
u
"
\
\
\
\
"
_ns
;
constexpr
auto
deviceMupPrefix
=
u
"
\
\
Device
\
\
Mup
\
\
"
_ns
;
if
(
StringBeginsWith
(
aNtPath
deviceMupPrefix
)
)
{
aDosPath
=
uncPrefix
;
aDosPath
+
=
Substring
(
aNtPath
deviceMupPrefix
.
Length
(
)
)
;
return
true
;
}
constexpr
auto
deviceLanmanRedirectorPrefix
=
u
"
\
\
Device
\
\
LanmanRedirector
\
\
"
_ns
;
if
(
StringBeginsWith
(
aNtPath
deviceLanmanRedirectorPrefix
)
)
{
aDosPath
=
uncPrefix
;
aDosPath
+
=
Substring
(
aNtPath
deviceLanmanRedirectorPrefix
.
Length
(
)
)
;
return
true
;
}
return
false
;
}
bool
HandleToFilename
(
HANDLE
aHandle
const
LARGE_INTEGER
&
aOffset
nsAString
&
aFilename
)
;
uint32_t
GetExecutableArchitecture
(
const
wchar_t
*
aPath
)
;
}
#
endif
