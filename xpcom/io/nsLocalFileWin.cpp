#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsLocalFile
.
h
"
#
include
"
nsLocalFileCommon
.
h
"
#
include
"
nsIDirectoryEnumerator
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nsSimpleEnumerator
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
prio
.
h
"
#
include
"
private
/
pprio
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
<
direct
.
h
>
#
include
<
windows
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
aclapi
.
h
>
#
include
"
shellapi
.
h
"
#
include
"
shlguid
.
h
"
#
include
<
io
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
mbstring
.
h
>
#
include
"
prproces
.
h
"
#
include
"
prlink
.
h
"
#
include
"
mozilla
/
FilePreferences
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
SpecialSystemDirectory
.
h
"
#
include
"
nsTraceRefcnt
.
h
"
#
include
"
nsXPCOMCIDInternal
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsIWindowMediator
.
h
"
#
include
"
mozIDOMWindow
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
mozilla
/
ShellHeaderOnlyUtils
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
using
namespace
mozilla
;
#
define
CHECK_mWorkingPath
(
)
\
do
{
\
if
(
mWorkingPath
.
IsEmpty
(
)
)
return
NS_ERROR_NOT_INITIALIZED
;
\
}
while
(
0
)
#
ifndef
COPY_FILE_NO_BUFFERING
#
define
COPY_FILE_NO_BUFFERING
0x00001000
#
endif
#
ifndef
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
#
define
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
0x00002000
#
endif
#
ifndef
DRIVE_REMOTE
#
define
DRIVE_REMOTE
4
#
endif
class
AsyncLocalFileWinDone
:
public
Runnable
{
public
:
AsyncLocalFileWinDone
(
)
:
Runnable
(
"
AsyncLocalFileWinDone
"
)
mWorkerThread
(
do_GetCurrentThread
(
)
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mWorkerThread
-
>
Shutdown
(
)
;
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIThread
>
mWorkerThread
;
}
;
class
AsyncRevealOperation
:
public
Runnable
{
public
:
explicit
AsyncRevealOperation
(
const
nsAString
&
aResolvedPath
)
:
Runnable
(
"
AsyncRevealOperation
"
)
mResolvedPath
(
aResolvedPath
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
AsyncRevealOperation
should
not
be
run
on
the
main
thread
!
"
)
;
bool
doCoUninitialize
=
SUCCEEDED
(
CoInitializeEx
(
nullptr
COINIT_APARTMENTTHREADED
|
COINIT_DISABLE_OLE1DDE
)
)
;
Reveal
(
)
;
if
(
doCoUninitialize
)
{
CoUninitialize
(
)
;
}
nsCOMPtr
<
nsIRunnable
>
resultrunnable
=
new
AsyncLocalFileWinDone
(
)
;
NS_DispatchToMainThread
(
resultrunnable
)
;
return
NS_OK
;
}
private
:
nsresult
Reveal
(
)
{
DWORD
attributes
=
GetFileAttributesW
(
mResolvedPath
.
get
(
)
)
;
if
(
INVALID_FILE_ATTRIBUTES
=
=
attributes
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
HRESULT
hr
;
if
(
attributes
&
FILE_ATTRIBUTE_DIRECTORY
)
{
LPITEMIDLIST
dir
=
ILCreateFromPathW
(
mResolvedPath
.
get
(
)
)
;
if
(
!
dir
)
{
return
NS_ERROR_FAILURE
;
}
LPCITEMIDLIST
selection
[
]
=
{
dir
}
;
UINT
count
=
ArrayLength
(
selection
)
;
hr
=
SHOpenFolderAndSelectItems
(
dir
count
selection
0
)
;
CoTaskMemFree
(
dir
)
;
}
else
{
int32_t
len
=
mResolvedPath
.
Length
(
)
;
if
(
len
>
MAX_PATH
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
WCHAR
parentDirectoryPath
[
MAX_PATH
+
1
]
=
{
0
}
;
wcsncpy
(
parentDirectoryPath
mResolvedPath
.
get
(
)
MAX_PATH
)
;
PathRemoveFileSpecW
(
parentDirectoryPath
)
;
LPITEMIDLIST
dir
=
ILCreateFromPathW
(
parentDirectoryPath
)
;
if
(
!
dir
)
{
return
NS_ERROR_FAILURE
;
}
LPITEMIDLIST
item
=
ILCreateFromPathW
(
mResolvedPath
.
get
(
)
)
;
if
(
!
item
)
{
CoTaskMemFree
(
dir
)
;
return
NS_ERROR_FAILURE
;
}
LPCITEMIDLIST
selection
[
]
=
{
item
}
;
UINT
count
=
ArrayLength
(
selection
)
;
hr
=
SHOpenFolderAndSelectItems
(
dir
count
selection
0
)
;
CoTaskMemFree
(
dir
)
;
CoTaskMemFree
(
item
)
;
}
return
SUCCEEDED
(
hr
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsString
mResolvedPath
;
}
;
class
nsDriveEnumerator
:
public
nsSimpleEnumerator
public
nsIDirectoryEnumerator
{
public
:
nsDriveEnumerator
(
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSISIMPLEENUMERATOR
NS_FORWARD_NSISIMPLEENUMERATORBASE
(
nsSimpleEnumerator
:
:
)
nsresult
Init
(
)
;
const
nsID
&
DefaultInterface
(
)
override
{
return
NS_GET_IID
(
nsIFile
)
;
}
NS_IMETHOD
GetNextFile
(
nsIFile
*
*
aResult
)
override
{
bool
hasMore
=
false
;
nsresult
rv
=
HasMoreElements
(
&
hasMore
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
hasMore
)
{
return
rv
;
}
nsCOMPtr
<
nsISupports
>
next
;
rv
=
GetNext
(
getter_AddRefs
(
next
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
result
=
do_QueryInterface
(
next
)
;
result
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHOD
Close
(
)
override
{
return
NS_OK
;
}
private
:
virtual
~
nsDriveEnumerator
(
)
;
nsString
mDrives
;
nsAString
:
:
const_iterator
mStartOfCurrentDrive
;
nsAString
:
:
const_iterator
mEndOfDrivesString
;
}
;
static
nsresult
ResolveShellLink
(
const
WCHAR
*
aIn
WCHAR
*
aOut
)
{
RefPtr
<
IPersistFile
>
persistFile
;
RefPtr
<
IShellLinkW
>
shellLink
;
if
(
FAILED
(
CoCreateInstance
(
CLSID_ShellLink
nullptr
CLSCTX_INPROC_SERVER
IID_IShellLinkW
getter_AddRefs
(
shellLink
)
)
)
|
|
FAILED
(
shellLink
-
>
QueryInterface
(
IID_IPersistFile
getter_AddRefs
(
persistFile
)
)
)
|
|
FAILED
(
persistFile
-
>
Load
(
aIn
STGM_READ
)
)
|
|
FAILED
(
shellLink
-
>
Resolve
(
nullptr
SLR_NO_UI
)
)
|
|
FAILED
(
shellLink
-
>
GetPath
(
aOut
MAX_PATH
nullptr
SLGP_UNCPRIORITY
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
static
nsresult
ConvertWinError
(
DWORD
aWinErr
)
{
nsresult
rv
;
switch
(
aWinErr
)
{
case
ERROR_FILE_NOT_FOUND
:
case
ERROR_PATH_NOT_FOUND
:
case
ERROR_INVALID_DRIVE
:
case
ERROR_NOT_READY
:
rv
=
NS_ERROR_FILE_NOT_FOUND
;
break
;
case
ERROR_ACCESS_DENIED
:
case
ERROR_NOT_SAME_DEVICE
:
rv
=
NS_ERROR_FILE_ACCESS_DENIED
;
break
;
case
ERROR_SHARING_VIOLATION
:
case
ERROR_LOCK_VIOLATION
:
rv
=
NS_ERROR_FILE_IS_LOCKED
;
break
;
case
ERROR_NOT_ENOUGH_MEMORY
:
case
ERROR_INVALID_BLOCK
:
case
ERROR_INVALID_HANDLE
:
case
ERROR_ARENA_TRASHED
:
rv
=
NS_ERROR_OUT_OF_MEMORY
;
break
;
case
ERROR_CURRENT_DIRECTORY
:
rv
=
NS_ERROR_FILE_DIR_NOT_EMPTY
;
break
;
case
ERROR_WRITE_PROTECT
:
rv
=
NS_ERROR_FILE_READ_ONLY
;
break
;
case
ERROR_HANDLE_DISK_FULL
:
rv
=
NS_ERROR_FILE_TOO_BIG
;
break
;
case
ERROR_FILE_EXISTS
:
case
ERROR_ALREADY_EXISTS
:
case
ERROR_CANNOT_MAKE
:
rv
=
NS_ERROR_FILE_ALREADY_EXISTS
;
break
;
case
ERROR_FILENAME_EXCED_RANGE
:
rv
=
NS_ERROR_FILE_NAME_TOO_LONG
;
break
;
case
ERROR_DIRECTORY
:
rv
=
NS_ERROR_FILE_NOT_DIRECTORY
;
break
;
case
0
:
rv
=
NS_OK
;
break
;
default
:
rv
=
NS_ERROR_FAILURE
;
break
;
}
return
rv
;
}
static
__int64
MyFileSeek64
(
HANDLE
aHandle
__int64
aDistance
DWORD
aMoveMethod
)
{
LARGE_INTEGER
li
;
li
.
QuadPart
=
aDistance
;
li
.
LowPart
=
SetFilePointer
(
aHandle
li
.
LowPart
&
li
.
HighPart
aMoveMethod
)
;
if
(
li
.
LowPart
=
=
INVALID_SET_FILE_POINTER
&
&
GetLastError
(
)
!
=
NO_ERROR
)
{
li
.
QuadPart
=
-
1
;
}
return
li
.
QuadPart
;
}
static
bool
IsShortcutPath
(
const
nsAString
&
aPath
)
{
MOZ_ASSERT
(
!
aPath
.
IsEmpty
(
)
"
don
'
t
pass
an
empty
string
"
)
;
int32_t
len
=
aPath
.
Length
(
)
;
return
len
>
=
4
&
&
(
StringTail
(
aPath
4
)
.
LowerCaseEqualsASCII
(
"
.
lnk
"
)
)
;
}
typedef
enum
{
_PR_TRI_TRUE
=
1
_PR_TRI_FALSE
=
0
_PR_TRI_UNKNOWN
=
-
1
}
_PRTriStateBool
;
struct
_MDFileDesc
{
PROsfd
osfd
;
}
;
struct
PRFilePrivate
{
int32_t
state
;
bool
nonblocking
;
_PRTriStateBool
inheritable
;
PRFileDesc
*
next
;
int
lockCount
;
bool
appendMode
;
_MDFileDesc
md
;
}
;
nsresult
OpenFile
(
const
nsString
&
aName
int
aOsflags
int
aMode
bool
aShareDelete
PRFileDesc
*
*
aFd
)
{
int32_t
access
=
0
;
int32_t
shareMode
=
FILE_SHARE_READ
|
FILE_SHARE_WRITE
;
int32_t
disposition
=
0
;
int32_t
attributes
=
0
;
if
(
aShareDelete
)
{
shareMode
|
=
FILE_SHARE_DELETE
;
}
if
(
aOsflags
&
PR_SYNC
)
{
attributes
=
FILE_FLAG_WRITE_THROUGH
;
}
if
(
aOsflags
&
PR_RDONLY
|
|
aOsflags
&
PR_RDWR
)
{
access
|
=
GENERIC_READ
;
}
if
(
aOsflags
&
PR_WRONLY
|
|
aOsflags
&
PR_RDWR
)
{
access
|
=
GENERIC_WRITE
;
}
if
(
aOsflags
&
PR_CREATE_FILE
&
&
aOsflags
&
PR_EXCL
)
{
disposition
=
CREATE_NEW
;
}
else
if
(
aOsflags
&
PR_CREATE_FILE
)
{
if
(
aOsflags
&
PR_TRUNCATE
)
{
disposition
=
CREATE_ALWAYS
;
}
else
{
disposition
=
OPEN_ALWAYS
;
}
}
else
{
if
(
aOsflags
&
PR_TRUNCATE
)
{
disposition
=
TRUNCATE_EXISTING
;
}
else
{
disposition
=
OPEN_EXISTING
;
}
}
if
(
aOsflags
&
nsIFile
:
:
DELETE_ON_CLOSE
)
{
attributes
|
=
FILE_FLAG_DELETE_ON_CLOSE
;
}
if
(
aOsflags
&
nsIFile
:
:
OS_READAHEAD
)
{
attributes
|
=
FILE_FLAG_SEQUENTIAL_SCAN
;
}
if
(
!
(
aMode
&
(
PR_IWUSR
|
PR_IWGRP
|
PR_IWOTH
)
)
&
&
disposition
!
=
OPEN_EXISTING
)
{
attributes
|
=
FILE_ATTRIBUTE_READONLY
;
}
HANDLE
file
=
:
:
CreateFileW
(
aName
.
get
(
)
access
shareMode
nullptr
disposition
attributes
nullptr
)
;
if
(
file
=
=
INVALID_HANDLE_VALUE
)
{
*
aFd
=
nullptr
;
return
ConvertWinError
(
GetLastError
(
)
)
;
}
*
aFd
=
PR_ImportFile
(
(
PROsfd
)
file
)
;
if
(
*
aFd
)
{
(
*
aFd
)
-
>
secret
-
>
appendMode
=
(
PR_APPEND
&
aOsflags
)
?
true
:
false
;
return
NS_OK
;
}
nsresult
rv
=
NS_ErrorAccordingToNSPR
(
)
;
CloseHandle
(
file
)
;
return
rv
;
}
static
void
FileTimeToPRTime
(
const
FILETIME
*
aFiletime
PRTime
*
aPrtm
)
{
#
ifdef
__GNUC__
const
PRTime
_pr_filetime_offset
=
116444736000000000LL
;
#
else
const
PRTime
_pr_filetime_offset
=
116444736000000000i64
;
#
endif
MOZ_ASSERT
(
sizeof
(
FILETIME
)
=
=
sizeof
(
PRTime
)
)
;
:
:
CopyMemory
(
aPrtm
aFiletime
sizeof
(
PRTime
)
)
;
#
ifdef
__GNUC__
*
aPrtm
=
(
*
aPrtm
-
_pr_filetime_offset
)
/
10LL
;
#
else
*
aPrtm
=
(
*
aPrtm
-
_pr_filetime_offset
)
/
10i64
;
#
endif
}
static
nsresult
GetFileInfo
(
const
nsString
&
aName
PRFileInfo64
*
aInfo
)
{
WIN32_FILE_ATTRIBUTE_DATA
fileData
;
if
(
aName
.
IsEmpty
(
)
|
|
aName
.
FindCharInSet
(
u
"
?
*
"
)
!
=
kNotFound
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
:
:
GetFileAttributesExW
(
aName
.
get
(
)
GetFileExInfoStandard
&
fileData
)
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
if
(
fileData
.
dwFileAttributes
&
FILE_ATTRIBUTE_DIRECTORY
)
{
aInfo
-
>
type
=
PR_FILE_DIRECTORY
;
}
else
{
aInfo
-
>
type
=
PR_FILE_FILE
;
}
aInfo
-
>
size
=
fileData
.
nFileSizeHigh
;
aInfo
-
>
size
=
(
aInfo
-
>
size
<
<
32
)
+
fileData
.
nFileSizeLow
;
FileTimeToPRTime
(
&
fileData
.
ftLastWriteTime
&
aInfo
-
>
modifyTime
)
;
if
(
0
=
=
fileData
.
ftCreationTime
.
dwLowDateTime
&
&
0
=
=
fileData
.
ftCreationTime
.
dwHighDateTime
)
{
aInfo
-
>
creationTime
=
aInfo
-
>
modifyTime
;
}
else
{
FileTimeToPRTime
(
&
fileData
.
ftCreationTime
&
aInfo
-
>
creationTime
)
;
}
return
NS_OK
;
}
struct
nsDir
{
HANDLE
handle
;
WIN32_FIND_DATAW
data
;
bool
firstEntry
;
}
;
static
nsresult
OpenDir
(
const
nsString
&
aName
nsDir
*
*
aDir
)
{
if
(
NS_WARN_IF
(
!
aDir
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aDir
=
nullptr
;
if
(
aName
.
Length
(
)
+
3
>
=
MAX_PATH
)
{
return
NS_ERROR_FILE_NAME_TOO_LONG
;
}
nsDir
*
d
=
new
nsDir
(
)
;
nsAutoString
filename
(
aName
)
;
if
(
filename
.
Last
(
)
=
=
L
'
/
'
|
|
filename
.
Last
(
)
=
=
L
'
\
\
'
)
{
filename
.
Append
(
'
*
'
)
;
}
else
{
filename
.
AppendLiteral
(
"
\
\
*
"
)
;
}
filename
.
ReplaceChar
(
L
'
/
'
L
'
\
\
'
)
;
d
-
>
handle
=
:
:
FindFirstFileW
(
filename
.
get
(
)
&
(
d
-
>
data
)
)
;
if
(
d
-
>
handle
=
=
INVALID_HANDLE_VALUE
)
{
delete
d
;
return
ConvertWinError
(
GetLastError
(
)
)
;
}
d
-
>
firstEntry
=
true
;
*
aDir
=
d
;
return
NS_OK
;
}
static
nsresult
ReadDir
(
nsDir
*
aDir
PRDirFlags
aFlags
nsString
&
aName
)
{
aName
.
Truncate
(
)
;
if
(
NS_WARN_IF
(
!
aDir
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
while
(
1
)
{
BOOL
rv
;
if
(
aDir
-
>
firstEntry
)
{
aDir
-
>
firstEntry
=
false
;
rv
=
1
;
}
else
{
rv
=
:
:
FindNextFileW
(
aDir
-
>
handle
&
(
aDir
-
>
data
)
)
;
}
if
(
rv
=
=
0
)
{
break
;
}
const
wchar_t
*
fileName
;
fileName
=
(
aDir
)
-
>
data
.
cFileName
;
if
(
(
aFlags
&
PR_SKIP_DOT
)
&
&
(
fileName
[
0
]
=
=
L
'
.
'
)
&
&
(
fileName
[
1
]
=
=
L
'
\
0
'
)
)
{
continue
;
}
if
(
(
aFlags
&
PR_SKIP_DOT_DOT
)
&
&
(
fileName
[
0
]
=
=
L
'
.
'
)
&
&
(
fileName
[
1
]
=
=
L
'
.
'
)
&
&
(
fileName
[
2
]
=
=
L
'
\
0
'
)
)
{
continue
;
}
DWORD
attrib
=
aDir
-
>
data
.
dwFileAttributes
;
if
(
(
aFlags
&
PR_SKIP_HIDDEN
)
&
&
(
attrib
&
FILE_ATTRIBUTE_HIDDEN
)
)
{
continue
;
}
aName
=
fileName
;
return
NS_OK
;
}
DWORD
err
=
GetLastError
(
)
;
return
err
=
=
ERROR_NO_MORE_FILES
?
NS_OK
:
ConvertWinError
(
err
)
;
}
static
nsresult
CloseDir
(
nsDir
*
&
aDir
)
{
if
(
NS_WARN_IF
(
!
aDir
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
BOOL
isOk
=
FindClose
(
aDir
-
>
handle
)
;
delete
aDir
;
aDir
=
nullptr
;
return
isOk
?
NS_OK
:
ConvertWinError
(
GetLastError
(
)
)
;
}
class
nsDirEnumerator
final
:
public
nsSimpleEnumerator
public
nsIDirectoryEnumerator
{
private
:
~
nsDirEnumerator
(
)
{
Close
(
)
;
}
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_FORWARD_NSISIMPLEENUMERATORBASE
(
nsSimpleEnumerator
:
:
)
nsDirEnumerator
(
)
:
mDir
(
nullptr
)
{
}
const
nsID
&
DefaultInterface
(
)
override
{
return
NS_GET_IID
(
nsIFile
)
;
}
nsresult
Init
(
nsIFile
*
aParent
)
{
nsAutoString
filepath
;
aParent
-
>
GetTarget
(
filepath
)
;
if
(
filepath
.
IsEmpty
(
)
)
{
aParent
-
>
GetPath
(
filepath
)
;
}
if
(
filepath
.
IsEmpty
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
OpenDir
(
filepath
&
mDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mParent
=
aParent
;
return
NS_OK
;
}
NS_IMETHOD
HasMoreElements
(
bool
*
aResult
)
override
{
nsresult
rv
;
if
(
!
mNext
&
&
mDir
)
{
nsString
name
;
rv
=
ReadDir
(
mDir
PR_SKIP_BOTH
name
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
name
.
IsEmpty
(
)
)
{
if
(
NS_FAILED
(
CloseDir
(
mDir
)
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aResult
=
false
;
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
file
;
rv
=
mParent
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
file
-
>
Append
(
name
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mNext
=
file
.
forget
(
)
;
}
*
aResult
=
mNext
!
=
nullptr
;
if
(
!
*
aResult
)
{
Close
(
)
;
}
return
NS_OK
;
}
NS_IMETHOD
GetNext
(
nsISupports
*
*
aResult
)
override
{
nsresult
rv
;
bool
hasMore
;
rv
=
HasMoreElements
(
&
hasMore
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
hasMore
)
{
return
NS_ERROR_FAILURE
;
}
mNext
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHOD
GetNextFile
(
nsIFile
*
*
aResult
)
override
{
*
aResult
=
nullptr
;
bool
hasMore
=
false
;
nsresult
rv
=
HasMoreElements
(
&
hasMore
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
hasMore
)
{
return
rv
;
}
mNext
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHOD
Close
(
)
override
{
if
(
mDir
)
{
nsresult
rv
=
CloseDir
(
mDir
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
close
failed
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
protected
:
nsDir
*
mDir
;
nsCOMPtr
<
nsIFile
>
mParent
;
nsCOMPtr
<
nsIFile
>
mNext
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
nsDirEnumerator
nsSimpleEnumerator
nsIDirectoryEnumerator
)
nsLocalFile
:
:
nsLocalFile
(
)
:
mDirty
(
true
)
mResolveDirty
(
true
)
mFollowSymlinks
(
false
)
{
}
nsLocalFile
:
:
nsLocalFile
(
const
nsAString
&
aFilePath
)
:
mFollowSymlinks
(
false
)
{
InitWithPath
(
aFilePath
)
;
}
nsresult
nsLocalFile
:
:
nsLocalFileConstructor
(
nsISupports
*
aOuter
const
nsIID
&
aIID
void
*
*
aInstancePtr
)
{
if
(
NS_WARN_IF
(
!
aInstancePtr
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
aOuter
)
)
{
return
NS_ERROR_NO_AGGREGATION
;
}
nsLocalFile
*
inst
=
new
nsLocalFile
(
)
;
nsresult
rv
=
inst
-
>
QueryInterface
(
aIID
aInstancePtr
)
;
if
(
NS_FAILED
(
rv
)
)
{
delete
inst
;
return
rv
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsLocalFile
nsIFile
nsILocalFileWin
)
nsLocalFile
:
:
nsLocalFile
(
const
nsLocalFile
&
aOther
)
:
mDirty
(
true
)
mResolveDirty
(
true
)
mFollowSymlinks
(
aOther
.
mFollowSymlinks
)
mWorkingPath
(
aOther
.
mWorkingPath
)
{
}
nsresult
nsLocalFile
:
:
ResolveShortcut
(
)
{
mResolvedPath
.
SetLength
(
MAX_PATH
)
;
if
(
mResolvedPath
.
Length
(
)
!
=
MAX_PATH
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
wchar_t
*
resolvedPath
=
mResolvedPath
.
get
(
)
;
nsresult
rv
=
ResolveShellLink
(
mWorkingPath
.
get
(
)
resolvedPath
)
;
size_t
len
=
NS_FAILED
(
rv
)
?
0
:
wcslen
(
resolvedPath
)
;
mResolvedPath
.
SetLength
(
len
)
;
return
rv
;
}
nsresult
nsLocalFile
:
:
ResolveAndStat
(
)
{
if
(
!
mDirty
)
{
return
NS_OK
;
}
AUTO_PROFILER_LABEL
(
"
nsLocalFile
:
:
ResolveAndStat
"
OTHER
)
;
if
(
mWorkingPath
.
IsEmpty
(
)
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
mResolvedPath
.
Assign
(
mWorkingPath
)
;
nsAutoString
nsprPath
(
mWorkingPath
)
;
if
(
mWorkingPath
.
Length
(
)
=
=
2
&
&
mWorkingPath
.
CharAt
(
1
)
=
=
u
'
:
'
)
{
nsprPath
.
Append
(
'
\
\
'
)
;
}
nsresult
rv
=
GetFileInfo
(
nsprPath
&
mFileInfo64
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
mFollowSymlinks
|
|
mFileInfo64
.
type
!
=
PR_FILE_FILE
|
|
!
IsShortcutPath
(
mWorkingPath
)
)
{
mDirty
=
false
;
mResolveDirty
=
false
;
return
NS_OK
;
}
rv
=
ResolveShortcut
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
mResolvedPath
.
Assign
(
mWorkingPath
)
;
return
rv
;
}
mResolveDirty
=
false
;
rv
=
GetFileInfo
(
mResolvedPath
&
mFileInfo64
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mDirty
=
false
;
return
NS_OK
;
}
nsresult
nsLocalFile
:
:
Resolve
(
)
{
if
(
!
mResolveDirty
)
{
return
NS_OK
;
}
if
(
mWorkingPath
.
IsEmpty
(
)
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
mResolvedPath
.
Assign
(
mWorkingPath
)
;
if
(
!
mFollowSymlinks
|
|
!
IsShortcutPath
(
mWorkingPath
)
)
{
mResolveDirty
=
false
;
return
NS_OK
;
}
nsresult
rv
=
ResolveShortcut
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
mResolvedPath
.
Assign
(
mWorkingPath
)
;
return
rv
;
}
mResolveDirty
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Clone
(
nsIFile
*
*
aFile
)
{
RefPtr
<
nsLocalFile
>
file
=
new
nsLocalFile
(
*
this
)
;
file
.
forget
(
aFile
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
InitWithFile
(
nsIFile
*
aFile
)
{
if
(
NS_WARN_IF
(
!
aFile
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoString
path
;
aFile
-
>
GetPath
(
path
)
;
if
(
path
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
InitWithPath
(
path
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
InitWithPath
(
const
nsAString
&
aFilePath
)
{
MakeDirty
(
)
;
nsAString
:
:
const_iterator
begin
end
;
aFilePath
.
BeginReading
(
begin
)
;
aFilePath
.
EndReading
(
end
)
;
if
(
begin
=
=
end
)
{
return
NS_ERROR_FAILURE
;
}
char16_t
firstChar
=
*
begin
;
char16_t
secondChar
=
*
(
+
+
begin
)
;
if
(
FindCharInReadable
(
L
'
/
'
begin
end
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
if
(
FilePreferences
:
:
IsBlockedUNCPath
(
aFilePath
)
)
{
return
NS_ERROR_FILE_ACCESS_DENIED
;
}
if
(
secondChar
!
=
L
'
:
'
&
&
(
secondChar
!
=
L
'
\
\
'
|
|
firstChar
!
=
L
'
\
\
'
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
if
(
secondChar
=
=
L
'
:
'
)
{
if
(
PathGetDriveNumberW
(
aFilePath
.
Data
(
)
)
=
=
-
1
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
}
mWorkingPath
=
aFilePath
;
if
(
mWorkingPath
.
Last
(
)
=
=
L
'
\
\
'
)
{
mWorkingPath
.
Truncate
(
mWorkingPath
.
Length
(
)
-
1
)
;
}
return
NS_OK
;
}
static
void
CleanupHandlerPath
(
nsString
&
aPath
)
{
int32_t
lastCommaPos
=
aPath
.
RFindChar
(
'
'
)
;
if
(
lastCommaPos
!
=
kNotFound
)
aPath
.
Truncate
(
lastCommaPos
)
;
aPath
.
Append
(
'
'
)
;
int32_t
index
=
aPath
.
Find
(
"
.
exe
"
true
)
;
if
(
index
=
=
kNotFound
)
index
=
aPath
.
Find
(
"
.
dll
"
true
)
;
if
(
index
=
=
kNotFound
)
index
=
aPath
.
Find
(
"
.
cpl
"
true
)
;
if
(
index
!
=
kNotFound
)
aPath
.
Truncate
(
index
+
4
)
;
aPath
.
Trim
(
"
"
true
true
)
;
}
static
void
StripRundll32
(
nsString
&
aCommandString
)
{
NS_NAMED_LITERAL_STRING
(
rundllSegment
"
rundll32
.
exe
"
)
;
NS_NAMED_LITERAL_STRING
(
rundllSegmentShort
"
rundll32
"
)
;
int32_t
strLen
=
rundllSegment
.
Length
(
)
;
int32_t
index
=
aCommandString
.
Find
(
rundllSegment
true
)
;
if
(
index
=
=
kNotFound
)
{
strLen
=
rundllSegmentShort
.
Length
(
)
;
index
=
aCommandString
.
Find
(
rundllSegmentShort
true
)
;
}
if
(
index
!
=
kNotFound
)
{
uint32_t
rundllSegmentLength
=
index
+
strLen
;
aCommandString
.
Cut
(
0
rundllSegmentLength
)
;
}
}
bool
nsLocalFile
:
:
CleanupCmdHandlerPath
(
nsAString
&
aCommandHandler
)
{
nsAutoString
handlerCommand
(
aCommandHandler
)
;
uint32_t
bufLength
=
:
:
ExpandEnvironmentStringsW
(
handlerCommand
.
get
(
)
nullptr
0
)
;
if
(
bufLength
=
=
0
)
return
false
;
auto
destination
=
mozilla
:
:
MakeUniqueFallible
<
wchar_t
[
]
>
(
bufLength
)
;
if
(
!
destination
)
return
false
;
if
(
!
:
:
ExpandEnvironmentStringsW
(
handlerCommand
.
get
(
)
destination
.
get
(
)
bufLength
)
)
return
false
;
handlerCommand
.
Assign
(
destination
.
get
(
)
)
;
handlerCommand
.
StripChars
(
"
\
"
"
)
;
StripRundll32
(
handlerCommand
)
;
CleanupHandlerPath
(
handlerCommand
)
;
aCommandHandler
.
Assign
(
handlerCommand
)
;
return
true
;
}
NS_IMETHODIMP
nsLocalFile
:
:
InitWithCommandLine
(
const
nsAString
&
aCommandLine
)
{
nsAutoString
commandLine
(
aCommandLine
)
;
if
(
!
CleanupCmdHandlerPath
(
commandLine
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
return
InitWithPath
(
commandLine
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
OpenNSPRFileDesc
(
int32_t
aFlags
int32_t
aMode
PRFileDesc
*
*
aResult
)
{
nsresult
rv
=
OpenNSPRFileDescMaybeShareDelete
(
aFlags
aMode
false
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
OpenANSIFileDesc
(
const
char
*
aMode
FILE
*
*
aResult
)
{
nsresult
rv
=
Resolve
(
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_FILE_NOT_FOUND
)
{
return
rv
;
}
*
aResult
=
_wfopen
(
mResolvedPath
.
get
(
)
NS_ConvertASCIItoUTF16
(
aMode
)
.
get
(
)
)
;
if
(
*
aResult
)
{
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
static
nsresult
do_create
(
nsIFile
*
aFile
const
nsString
&
aPath
uint32_t
aAttributes
)
{
PRFileDesc
*
file
;
nsresult
rv
=
OpenFile
(
aPath
PR_RDONLY
|
PR_CREATE_FILE
|
PR_APPEND
|
PR_EXCL
aAttributes
false
&
file
)
;
if
(
file
)
{
PR_Close
(
file
)
;
}
if
(
rv
=
=
NS_ERROR_FILE_ACCESS_DENIED
)
{
bool
isdir
;
if
(
NS_SUCCEEDED
(
aFile
-
>
IsDirectory
(
&
isdir
)
)
&
&
isdir
)
{
rv
=
NS_ERROR_FILE_ALREADY_EXISTS
;
}
}
return
rv
;
}
static
nsresult
do_mkdir
(
nsIFile
*
const
nsString
&
aPath
uint32_t
)
{
if
(
!
:
:
CreateDirectoryW
(
aPath
.
get
(
)
nullptr
)
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Create
(
uint32_t
aType
uint32_t
aAttributes
)
{
if
(
aType
!
=
NORMAL_FILE_TYPE
&
&
aType
!
=
DIRECTORY_TYPE
)
{
return
NS_ERROR_FILE_UNKNOWN_TYPE
;
}
nsresult
rv
=
Resolve
(
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_FILE_NOT_FOUND
)
{
return
rv
;
}
auto
*
createFunc
=
(
aType
=
=
NORMAL_FILE_TYPE
?
do_create
:
do_mkdir
)
;
rv
=
createFunc
(
this
mResolvedPath
aAttributes
)
;
if
(
NS_SUCCEEDED
(
rv
)
|
|
NS_ERROR_FILE_ALREADY_EXISTS
=
=
rv
)
{
return
rv
;
}
wchar_t
*
path
=
char16ptr_t
(
mResolvedPath
.
BeginWriting
(
)
)
;
if
(
path
[
0
]
=
=
L
'
\
\
'
&
&
path
[
1
]
=
=
L
'
\
\
'
)
{
path
=
wcschr
(
path
+
2
L
'
\
\
'
)
;
if
(
!
path
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
+
+
path
;
}
wchar_t
*
slash
=
wcschr
(
path
L
'
\
\
'
)
;
nsresult
directoryCreateError
=
NS_OK
;
if
(
slash
)
{
+
+
slash
;
slash
=
wcschr
(
slash
L
'
\
\
'
)
;
while
(
slash
)
{
*
slash
=
L
'
\
0
'
;
if
(
!
:
:
CreateDirectoryW
(
mResolvedPath
.
get
(
)
nullptr
)
)
{
rv
=
ConvertWinError
(
GetLastError
(
)
)
;
if
(
NS_ERROR_FILE_NOT_FOUND
=
=
rv
&
&
NS_ERROR_FILE_ACCESS_DENIED
=
=
directoryCreateError
)
{
return
NS_ERROR_FILE_ACCESS_DENIED
;
}
else
if
(
rv
!
=
NS_ERROR_FILE_ALREADY_EXISTS
&
&
rv
!
=
NS_ERROR_FILE_ACCESS_DENIED
)
{
return
rv
;
}
directoryCreateError
=
rv
;
}
*
slash
=
L
'
\
\
'
;
+
+
slash
;
slash
=
wcschr
(
slash
L
'
\
\
'
)
;
}
}
if
(
NS_ERROR_FILE_ACCESS_DENIED
=
=
directoryCreateError
)
{
return
directoryCreateError
;
}
return
createFunc
(
this
mResolvedPath
aAttributes
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Append
(
const
nsAString
&
aNode
)
{
return
AppendInternal
(
PromiseFlatString
(
aNode
)
false
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
AppendRelativePath
(
const
nsAString
&
aNode
)
{
return
AppendInternal
(
PromiseFlatString
(
aNode
)
true
)
;
}
nsresult
nsLocalFile
:
:
AppendInternal
(
const
nsString
&
aNode
bool
aMultipleComponents
)
{
if
(
aNode
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
aNode
.
First
(
)
=
=
L
'
\
\
'
|
|
aNode
.
Contains
(
L
'
/
'
)
|
|
aNode
.
EqualsASCII
(
"
.
.
"
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
if
(
aMultipleComponents
)
{
NS_NAMED_LITERAL_STRING
(
doubleDot
"
\
\
.
.
"
)
;
nsAString
:
:
const_iterator
start
end
offset
;
aNode
.
BeginReading
(
start
)
;
aNode
.
EndReading
(
end
)
;
offset
=
end
;
while
(
FindInReadable
(
doubleDot
start
offset
)
)
{
if
(
offset
=
=
end
|
|
*
offset
=
=
L
'
\
\
'
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
start
=
offset
;
offset
=
end
;
}
if
(
StringBeginsWith
(
aNode
NS_LITERAL_STRING
(
"
.
.
\
\
"
)
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
}
else
if
(
aNode
.
Contains
(
L
'
\
\
'
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
MakeDirty
(
)
;
mWorkingPath
.
Append
(
'
\
\
'
)
;
mWorkingPath
.
Append
(
aNode
)
;
return
NS_OK
;
}
nsresult
nsLocalFile
:
:
OpenNSPRFileDescMaybeShareDelete
(
int32_t
aFlags
int32_t
aMode
bool
aShareDelete
PRFileDesc
*
*
aResult
)
{
nsresult
rv
=
Resolve
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
OpenFile
(
mResolvedPath
aFlags
aMode
aShareDelete
aResult
)
;
}
#
define
TOUPPER
(
u
)
(
(
(
u
)
>
=
L
'
a
'
&
&
(
u
)
<
=
L
'
z
'
)
?
(
u
)
-
(
L
'
a
'
-
L
'
A
'
)
:
(
u
)
)
NS_IMETHODIMP
nsLocalFile
:
:
Normalize
(
)
{
if
(
mWorkingPath
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
nsAutoString
path
(
mWorkingPath
)
;
int32_t
rootIdx
=
2
;
if
(
path
.
First
(
)
=
=
L
'
\
\
'
)
{
rootIdx
=
path
.
FindChar
(
L
'
\
\
'
2
)
;
if
(
rootIdx
=
=
kNotFound
)
{
return
NS_OK
;
}
rootIdx
=
path
.
FindChar
(
L
'
\
\
'
rootIdx
+
1
)
;
if
(
rootIdx
=
=
kNotFound
)
{
return
NS_OK
;
}
}
else
if
(
path
.
CharAt
(
rootIdx
)
!
=
L
'
\
\
'
)
{
WCHAR
cwd
[
MAX_PATH
]
;
WCHAR
*
pcwd
=
cwd
;
int
drive
=
TOUPPER
(
path
.
First
(
)
)
-
'
A
'
+
1
;
if
(
!
(
(
1
<
<
(
drive
-
1
)
)
&
_getdrives
(
)
)
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
if
(
!
_wgetdcwd
(
drive
pcwd
MAX_PATH
)
)
{
pcwd
=
_wgetdcwd
(
drive
0
0
)
;
}
if
(
!
pcwd
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsAutoString
currentDir
(
pcwd
)
;
if
(
pcwd
!
=
cwd
)
{
free
(
pcwd
)
;
}
if
(
currentDir
.
Last
(
)
=
=
'
\
\
'
)
{
path
.
Replace
(
0
2
currentDir
)
;
}
else
{
path
.
Replace
(
0
2
currentDir
+
NS_LITERAL_STRING
(
"
\
\
"
)
)
;
}
}
MOZ_ASSERT
(
0
<
rootIdx
&
&
rootIdx
<
(
int32_t
)
path
.
Length
(
)
"
rootIdx
is
invalid
"
)
;
MOZ_ASSERT
(
path
.
CharAt
(
rootIdx
)
=
=
'
\
\
'
"
rootIdx
is
invalid
"
)
;
if
(
rootIdx
+
1
=
=
(
int32_t
)
path
.
Length
(
)
)
{
return
NS_OK
;
}
const
char16_t
*
pathBuffer
=
path
.
get
(
)
;
mWorkingPath
.
SetCapacity
(
path
.
Length
(
)
)
;
mWorkingPath
.
Assign
(
pathBuffer
rootIdx
)
;
int32_t
len
begin
end
=
rootIdx
;
while
(
end
<
(
int32_t
)
path
.
Length
(
)
)
{
begin
=
end
+
1
;
end
=
path
.
FindChar
(
'
\
\
'
begin
)
;
if
(
end
=
=
kNotFound
)
{
end
=
path
.
Length
(
)
;
}
len
=
end
-
begin
;
if
(
len
=
=
0
)
{
continue
;
}
if
(
pathBuffer
[
begin
]
=
=
'
.
'
)
{
if
(
len
=
=
1
)
{
continue
;
}
if
(
len
>
=
2
&
&
pathBuffer
[
begin
+
1
]
=
=
L
'
.
'
)
{
if
(
len
=
=
2
)
{
int32_t
prev
=
mWorkingPath
.
RFindChar
(
'
\
\
'
)
;
if
(
prev
>
=
rootIdx
)
{
mWorkingPath
.
Truncate
(
prev
)
;
}
continue
;
}
int
idx
=
len
-
1
;
for
(
;
idx
>
=
2
;
-
-
idx
)
{
if
(
pathBuffer
[
begin
+
idx
]
!
=
L
'
.
'
)
{
break
;
}
}
if
(
idx
<
2
)
{
continue
;
}
}
}
mWorkingPath
.
Append
(
pathBuffer
+
begin
-
1
len
+
1
)
;
}
int32_t
filePathLen
=
mWorkingPath
.
Length
(
)
-
1
;
while
(
filePathLen
>
0
&
&
(
mWorkingPath
[
filePathLen
]
=
=
L
'
'
|
|
mWorkingPath
[
filePathLen
]
=
=
L
'
.
'
)
)
{
mWorkingPath
.
Truncate
(
filePathLen
-
-
)
;
}
MakeDirty
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetLeafName
(
nsAString
&
aLeafName
)
{
aLeafName
.
Truncate
(
)
;
if
(
mWorkingPath
.
IsEmpty
(
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
int32_t
offset
=
mWorkingPath
.
RFindChar
(
L
'
\
\
'
)
;
if
(
offset
=
=
kNotFound
)
{
aLeafName
=
mWorkingPath
;
}
else
{
aLeafName
=
Substring
(
mWorkingPath
offset
+
1
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetLeafName
(
const
nsAString
&
aLeafName
)
{
MakeDirty
(
)
;
if
(
mWorkingPath
.
IsEmpty
(
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
int32_t
offset
=
mWorkingPath
.
RFindChar
(
L
'
\
\
'
)
;
if
(
offset
)
{
mWorkingPath
.
Truncate
(
offset
+
1
)
;
}
mWorkingPath
.
Append
(
aLeafName
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetPath
(
nsAString
&
aResult
)
{
aResult
=
mWorkingPath
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetCanonicalPath
(
nsAString
&
aResult
)
{
EnsureShortPath
(
)
;
aResult
.
Assign
(
mShortWorkingPath
)
;
return
NS_OK
;
}
typedef
struct
{
WORD
wLanguage
;
WORD
wCodePage
;
}
LANGANDCODEPAGE
;
NS_IMETHODIMP
nsLocalFile
:
:
GetVersionInfoField
(
const
char
*
aField
nsAString
&
aResult
)
{
nsresult
rv
=
Resolve
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
NS_ERROR_FAILURE
;
const
WCHAR
*
path
=
mFollowSymlinks
?
mResolvedPath
.
get
(
)
:
mWorkingPath
.
get
(
)
;
DWORD
dummy
;
DWORD
size
=
:
:
GetFileVersionInfoSizeW
(
path
&
dummy
)
;
if
(
!
size
)
{
return
rv
;
}
void
*
ver
=
moz_xcalloc
(
size
1
)
;
if
(
:
:
GetFileVersionInfoW
(
path
0
size
ver
)
)
{
LANGANDCODEPAGE
*
translate
=
nullptr
;
UINT
pageCount
;
BOOL
queryResult
=
:
:
VerQueryValueW
(
ver
L
"
\
\
VarFileInfo
\
\
Translation
"
(
void
*
*
)
&
translate
&
pageCount
)
;
if
(
queryResult
&
&
translate
)
{
for
(
int32_t
i
=
0
;
i
<
2
;
+
+
i
)
{
wchar_t
subBlock
[
MAX_PATH
]
;
_snwprintf
(
subBlock
MAX_PATH
L
"
\
\
StringFileInfo
\
\
%
04x
%
04x
\
\
%
s
"
(
i
=
=
0
?
translate
[
0
]
.
wLanguage
:
:
:
GetUserDefaultLangID
(
)
)
translate
[
0
]
.
wCodePage
NS_ConvertASCIItoUTF16
(
nsDependentCString
(
aField
)
)
.
get
(
)
)
;
subBlock
[
MAX_PATH
-
1
]
=
0
;
LPVOID
value
=
nullptr
;
UINT
size
;
queryResult
=
:
:
VerQueryValueW
(
ver
subBlock
&
value
&
size
)
;
if
(
queryResult
&
&
value
)
{
aResult
.
Assign
(
static_cast
<
char16_t
*
>
(
value
)
)
;
if
(
!
aResult
.
IsEmpty
(
)
)
{
rv
=
NS_OK
;
break
;
}
}
}
}
}
free
(
ver
)
;
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
OpenNSPRFileDescShareDelete
(
int32_t
aFlags
int32_t
aMode
PRFileDesc
*
*
aResult
)
{
nsresult
rv
=
OpenNSPRFileDescMaybeShareDelete
(
aFlags
aMode
true
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
static
bool
IsRemoteFilePath
(
LPCWSTR
aPath
bool
&
aRemote
)
{
WCHAR
dirPath
[
MAX_PATH
+
1
]
=
{
0
}
;
wcsncpy
(
dirPath
aPath
MAX_PATH
)
;
if
(
!
PathRemoveFileSpecW
(
dirPath
)
)
{
return
false
;
}
size_t
len
=
wcslen
(
dirPath
)
;
if
(
len
>
=
MAX_PATH
)
{
return
false
;
}
dirPath
[
len
]
=
L
'
\
\
'
;
dirPath
[
len
+
1
]
=
L
'
\
0
'
;
UINT
driveType
=
GetDriveTypeW
(
dirPath
)
;
aRemote
=
driveType
=
=
DRIVE_REMOTE
;
return
true
;
}
nsresult
nsLocalFile
:
:
CopySingleFile
(
nsIFile
*
aSourceFile
nsIFile
*
aDestParent
const
nsAString
&
aNewName
uint32_t
aOptions
)
{
nsresult
rv
=
NS_OK
;
nsAutoString
filePath
;
bool
move
=
aOptions
&
(
Move
|
Rename
)
;
nsAutoString
destPath
;
rv
=
aDestParent
-
>
GetTarget
(
destPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
destPath
.
Append
(
'
\
\
'
)
;
if
(
aNewName
.
IsEmpty
(
)
)
{
nsAutoString
aFileName
;
aSourceFile
-
>
GetLeafName
(
aFileName
)
;
destPath
.
Append
(
aFileName
)
;
}
else
{
destPath
.
Append
(
aNewName
)
;
}
if
(
aOptions
&
FollowSymlinks
)
{
rv
=
aSourceFile
-
>
GetTarget
(
filePath
)
;
if
(
filePath
.
IsEmpty
(
)
)
{
rv
=
aSourceFile
-
>
GetPath
(
filePath
)
;
}
}
else
{
rv
=
aSourceFile
-
>
GetPath
(
filePath
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
FilePreferences
:
:
IsBlockedUNCPath
(
destPath
)
)
{
return
NS_ERROR_FILE_ACCESS_DENIED
;
}
int
copyOK
=
0
;
if
(
move
)
{
copyOK
=
:
:
MoveFileExW
(
filePath
.
get
(
)
destPath
.
get
(
)
MOVEFILE_REPLACE_EXISTING
)
;
}
if
(
!
copyOK
&
&
(
!
move
|
|
GetLastError
(
)
=
=
ERROR_NOT_SAME_DEVICE
)
)
{
if
(
move
&
&
(
aOptions
&
Rename
)
)
{
return
NS_ERROR_FILE_ACCESS_DENIED
;
}
DWORD
dwCopyFlags
=
COPY_FILE_ALLOW_DECRYPTED_DESTINATION
;
bool
path1Remote
path2Remote
;
if
(
!
IsRemoteFilePath
(
filePath
.
get
(
)
path1Remote
)
|
|
!
IsRemoteFilePath
(
destPath
.
get
(
)
path2Remote
)
|
|
path1Remote
|
|
path2Remote
)
{
dwCopyFlags
|
=
COPY_FILE_NO_BUFFERING
;
}
copyOK
=
:
:
CopyFileExW
(
filePath
.
get
(
)
destPath
.
get
(
)
nullptr
nullptr
nullptr
dwCopyFlags
)
;
if
(
move
&
&
copyOK
)
{
DeleteFileW
(
filePath
.
get
(
)
)
;
}
}
if
(
!
copyOK
)
{
rv
=
ConvertWinError
(
GetLastError
(
)
)
;
}
else
if
(
move
&
&
!
(
aOptions
&
SkipNtfsAclReset
)
)
{
PACL
pOldDACL
=
nullptr
;
PSECURITY_DESCRIPTOR
pSD
=
nullptr
;
:
:
GetNamedSecurityInfoW
(
(
LPWSTR
)
destPath
.
get
(
)
SE_FILE_OBJECT
DACL_SECURITY_INFORMATION
nullptr
nullptr
&
pOldDACL
nullptr
&
pSD
)
;
if
(
pOldDACL
)
:
:
SetNamedSecurityInfoW
(
(
LPWSTR
)
destPath
.
get
(
)
SE_FILE_OBJECT
DACL_SECURITY_INFORMATION
|
UNPROTECTED_DACL_SECURITY_INFORMATION
nullptr
nullptr
pOldDACL
nullptr
)
;
if
(
pSD
)
{
LocalFree
(
(
HLOCAL
)
pSD
)
;
}
}
return
rv
;
}
nsresult
nsLocalFile
:
:
CopyMove
(
nsIFile
*
aParentDir
const
nsAString
&
aNewName
uint32_t
aOptions
)
{
bool
move
=
aOptions
&
(
Move
|
Rename
)
;
bool
followSymlinks
=
aOptions
&
FollowSymlinks
;
bool
targetInSameDirectory
=
!
aParentDir
;
nsCOMPtr
<
nsIFile
>
newParentDir
=
aParentDir
;
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
newParentDir
)
{
if
(
aNewName
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
rv
=
GetParent
(
getter_AddRefs
(
newParentDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
!
newParentDir
)
{
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
if
(
!
targetInSameDirectory
)
{
bool
exists
=
false
;
rv
=
newParentDir
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
exists
)
{
rv
=
newParentDir
-
>
Create
(
DIRECTORY_TYPE
0644
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
{
bool
isDir
=
false
;
rv
=
newParentDir
-
>
IsDirectory
(
&
isDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
isDir
)
{
if
(
followSymlinks
)
{
bool
isLink
=
false
;
rv
=
newParentDir
-
>
IsSymlink
(
&
isLink
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
isLink
)
{
nsAutoString
target
;
rv
=
newParentDir
-
>
GetTarget
(
target
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
realDest
=
new
nsLocalFile
(
)
;
rv
=
realDest
-
>
InitWithPath
(
target
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
CopyMove
(
realDest
aNewName
aOptions
)
;
}
}
else
{
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
}
}
}
bool
done
=
false
;
bool
isDir
=
false
;
rv
=
IsDirectory
(
&
isDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
isSymlink
=
false
;
rv
=
IsSymlink
(
&
isSymlink
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
move
|
|
!
isDir
|
|
(
isSymlink
&
&
!
followSymlinks
)
)
{
if
(
!
aParentDir
)
{
aOptions
|
=
SkipNtfsAclReset
;
}
rv
=
CopySingleFile
(
this
newParentDir
aNewName
aOptions
)
;
done
=
NS_SUCCEEDED
(
rv
)
;
if
(
!
done
&
&
!
(
move
&
&
isDir
)
)
{
return
rv
;
}
}
if
(
!
done
)
{
nsCOMPtr
<
nsIFile
>
target
;
rv
=
newParentDir
-
>
Clone
(
getter_AddRefs
(
target
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoString
allocatedNewName
;
if
(
aNewName
.
IsEmpty
(
)
)
{
bool
isLink
=
false
;
rv
=
IsSymlink
(
&
isLink
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
isLink
)
{
nsAutoString
temp
;
rv
=
GetTarget
(
temp
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
int32_t
offset
=
temp
.
RFindChar
(
L
'
\
\
'
)
;
if
(
offset
=
=
kNotFound
)
{
allocatedNewName
=
temp
;
}
else
{
allocatedNewName
=
Substring
(
temp
offset
+
1
)
;
}
}
else
{
GetLeafName
(
allocatedNewName
)
;
}
}
else
{
allocatedNewName
=
aNewName
;
}
rv
=
target
-
>
Append
(
allocatedNewName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
allocatedNewName
.
Truncate
(
)
;
bool
exists
=
false
;
rv
=
target
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
exists
)
{
rv
=
target
-
>
Create
(
DIRECTORY_TYPE
0644
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
{
bool
isWritable
=
false
;
rv
=
target
-
>
IsWritable
(
&
isWritable
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
isWritable
)
{
return
NS_ERROR_FILE_ACCESS_DENIED
;
}
nsCOMPtr
<
nsIDirectoryEnumerator
>
targetIterator
;
rv
=
target
-
>
GetDirectoryEntries
(
getter_AddRefs
(
targetIterator
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
more
;
targetIterator
-
>
HasMoreElements
(
&
more
)
;
if
(
more
)
{
return
NS_ERROR_FILE_DIR_NOT_EMPTY
;
}
}
RefPtr
<
nsDirEnumerator
>
dirEnum
=
new
nsDirEnumerator
(
)
;
rv
=
dirEnum
-
>
Init
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
dirEnum
initialization
failed
"
)
;
return
rv
;
}
nsCOMPtr
<
nsIFile
>
file
;
while
(
NS_SUCCEEDED
(
dirEnum
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
)
&
&
file
)
{
bool
isDir
=
false
;
rv
=
file
-
>
IsDirectory
(
&
isDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
isLink
=
false
;
rv
=
file
-
>
IsSymlink
(
&
isLink
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
move
)
{
if
(
followSymlinks
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
file
-
>
MoveTo
(
target
EmptyString
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
{
if
(
followSymlinks
)
{
rv
=
file
-
>
CopyToFollowingLinks
(
target
EmptyString
(
)
)
;
}
else
{
rv
=
file
-
>
CopyTo
(
target
EmptyString
(
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
}
if
(
move
)
{
rv
=
Remove
(
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
}
if
(
move
)
{
MakeDirty
(
)
;
nsAutoString
newParentPath
;
newParentDir
-
>
GetPath
(
newParentPath
)
;
if
(
newParentPath
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aNewName
.
IsEmpty
(
)
)
{
nsAutoString
aFileName
;
GetLeafName
(
aFileName
)
;
InitWithPath
(
newParentPath
)
;
Append
(
aFileName
)
;
}
else
{
InitWithPath
(
newParentPath
)
;
Append
(
aNewName
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
CopyTo
(
nsIFile
*
aNewParentDir
const
nsAString
&
aNewName
)
{
return
CopyMove
(
aNewParentDir
aNewName
0
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
CopyToFollowingLinks
(
nsIFile
*
aNewParentDir
const
nsAString
&
aNewName
)
{
return
CopyMove
(
aNewParentDir
aNewName
FollowSymlinks
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
MoveTo
(
nsIFile
*
aNewParentDir
const
nsAString
&
aNewName
)
{
return
CopyMove
(
aNewParentDir
aNewName
Move
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
RenameTo
(
nsIFile
*
aNewParentDir
const
nsAString
&
aNewName
)
{
bool
targetInSameDirectory
=
!
aNewParentDir
;
nsCOMPtr
<
nsIFile
>
targetParentDir
=
aNewParentDir
;
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
targetParentDir
)
{
if
(
aNewName
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
rv
=
GetParent
(
getter_AddRefs
(
targetParentDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
!
targetParentDir
)
{
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
if
(
!
targetInSameDirectory
)
{
bool
exists
=
false
;
rv
=
targetParentDir
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
exists
)
{
rv
=
targetParentDir
-
>
Create
(
DIRECTORY_TYPE
0644
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
{
bool
isDir
=
false
;
rv
=
targetParentDir
-
>
IsDirectory
(
&
isDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
isDir
)
{
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
}
}
uint32_t
options
=
Rename
;
if
(
!
aNewParentDir
)
{
options
|
=
SkipNtfsAclReset
;
}
return
CopySingleFile
(
this
targetParentDir
aNewName
options
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
RenameToNative
(
nsIFile
*
aNewParentDir
const
nsACString
&
aNewName
)
{
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aNewName
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
RenameTo
(
aNewParentDir
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Load
(
PRLibrary
*
*
aResult
)
{
CHECK_mWorkingPath
(
)
;
bool
isFile
;
nsresult
rv
=
IsFile
(
&
isFile
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
isFile
)
{
return
NS_ERROR_FILE_IS_DIRECTORY
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsTraceRefcnt
:
:
SetActivityIsLegal
(
false
)
;
#
endif
PRLibSpec
libSpec
;
libSpec
.
value
.
pathname_u
=
mResolvedPath
.
get
(
)
;
libSpec
.
type
=
PR_LibSpec_PathnameU
;
*
aResult
=
PR_LoadLibraryWithFlags
(
libSpec
0
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsTraceRefcnt
:
:
SetActivityIsLegal
(
true
)
;
#
endif
if
(
*
aResult
)
{
return
NS_OK
;
}
return
NS_ERROR_NULL_POINTER
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Remove
(
bool
aRecursive
)
{
CHECK_mWorkingPath
(
)
;
nsresult
rv
=
NS_OK
;
bool
isLink
=
false
;
rv
=
IsSymlink
(
&
isLink
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
isDir
=
false
;
if
(
!
isLink
)
{
rv
=
IsDirectory
(
&
isDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
isDir
)
{
if
(
aRecursive
)
{
RefPtr
<
nsDirEnumerator
>
dirEnum
=
new
nsDirEnumerator
(
)
;
rv
=
dirEnum
-
>
Init
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
more
=
false
;
while
(
NS_SUCCEEDED
(
dirEnum
-
>
HasMoreElements
(
&
more
)
)
&
&
more
)
{
nsCOMPtr
<
nsISupports
>
item
;
dirEnum
-
>
GetNext
(
getter_AddRefs
(
item
)
)
;
nsCOMPtr
<
nsIFile
>
file
=
do_QueryInterface
(
item
)
;
if
(
file
)
{
file
-
>
Remove
(
aRecursive
)
;
}
}
}
if
(
RemoveDirectoryW
(
mWorkingPath
.
get
(
)
)
=
=
0
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
}
else
{
if
(
DeleteFileW
(
mWorkingPath
.
get
(
)
)
=
=
0
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
}
MakeDirty
(
)
;
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetLastModifiedTime
(
PRTime
*
aLastModifiedTime
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aLastModifiedTime
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aLastModifiedTime
=
mFileInfo64
.
modifyTime
/
PR_USEC_PER_MSEC
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetLastModifiedTimeOfLink
(
PRTime
*
aLastModifiedTime
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aLastModifiedTime
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
PRFileInfo64
info
;
nsresult
rv
=
GetFileInfo
(
mWorkingPath
&
info
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aLastModifiedTime
=
info
.
modifyTime
/
PR_USEC_PER_MSEC
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetLastModifiedTime
(
PRTime
aLastModifiedTime
)
{
CHECK_mWorkingPath
(
)
;
nsresult
rv
=
Resolve
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
SetModDate
(
aLastModifiedTime
mResolvedPath
.
get
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MakeDirty
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetLastModifiedTimeOfLink
(
PRTime
aLastModifiedTime
)
{
nsresult
rv
=
SetModDate
(
aLastModifiedTime
mWorkingPath
.
get
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MakeDirty
(
)
;
}
return
rv
;
}
nsresult
nsLocalFile
:
:
SetModDate
(
PRTime
aLastModifiedTime
const
wchar_t
*
aFilePath
)
{
HANDLE
file
=
:
:
CreateFileW
(
aFilePath
GENERIC_WRITE
0
nullptr
OPEN_EXISTING
FILE_FLAG_BACKUP_SEMANTICS
nullptr
)
;
if
(
file
=
=
INVALID_HANDLE_VALUE
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
FILETIME
ft
;
SYSTEMTIME
st
;
PRExplodedTime
pret
;
PR_ExplodeTime
(
aLastModifiedTime
*
PR_USEC_PER_MSEC
PR_GMTParameters
&
pret
)
;
st
.
wYear
=
pret
.
tm_year
;
st
.
wMonth
=
pret
.
tm_month
+
1
;
st
.
wDayOfWeek
=
pret
.
tm_wday
;
st
.
wDay
=
pret
.
tm_mday
;
st
.
wHour
=
pret
.
tm_hour
;
st
.
wMinute
=
pret
.
tm_min
;
st
.
wSecond
=
pret
.
tm_sec
;
st
.
wMilliseconds
=
pret
.
tm_usec
/
1000
;
nsresult
rv
=
NS_OK
;
if
(
!
(
SystemTimeToFileTime
(
&
st
&
ft
)
!
=
0
&
&
SetFileTime
(
file
nullptr
&
ft
&
ft
)
!
=
0
)
)
{
rv
=
ConvertWinError
(
GetLastError
(
)
)
;
}
CloseHandle
(
file
)
;
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetPermissions
(
uint32_t
*
aPermissions
)
{
if
(
NS_WARN_IF
(
!
aPermissions
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
isWritable
=
false
;
rv
=
IsWritable
(
&
isWritable
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
isExecutable
=
false
;
rv
=
IsExecutable
(
&
isExecutable
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aPermissions
=
PR_IRUSR
|
PR_IRGRP
|
PR_IROTH
;
if
(
isWritable
)
{
*
aPermissions
|
=
PR_IWUSR
|
PR_IWGRP
|
PR_IWOTH
;
}
if
(
isExecutable
)
{
*
aPermissions
|
=
PR_IXUSR
|
PR_IXGRP
|
PR_IXOTH
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetPermissionsOfLink
(
uint32_t
*
aPermissions
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aPermissions
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
DWORD
word
=
:
:
GetFileAttributesW
(
mWorkingPath
.
get
(
)
)
;
if
(
word
=
=
INVALID_FILE_ATTRIBUTES
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
bool
isWritable
=
!
(
word
&
FILE_ATTRIBUTE_READONLY
)
;
*
aPermissions
=
PR_IRUSR
|
PR_IRGRP
|
PR_IROTH
;
if
(
isWritable
)
{
*
aPermissions
|
=
PR_IWUSR
|
PR_IWGRP
|
PR_IWOTH
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetPermissions
(
uint32_t
aPermissions
)
{
CHECK_mWorkingPath
(
)
;
nsresult
rv
=
Resolve
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
int
mode
=
0
;
if
(
aPermissions
&
(
PR_IRUSR
|
PR_IRGRP
|
PR_IROTH
)
)
{
mode
|
=
_S_IREAD
;
}
if
(
aPermissions
&
(
PR_IWUSR
|
PR_IWGRP
|
PR_IWOTH
)
)
{
mode
|
=
_S_IWRITE
;
}
if
(
_wchmod
(
mResolvedPath
.
get
(
)
mode
)
=
=
-
1
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetPermissionsOfLink
(
uint32_t
aPermissions
)
{
int
mode
=
0
;
if
(
aPermissions
&
(
PR_IRUSR
|
PR_IRGRP
|
PR_IROTH
)
)
{
mode
|
=
_S_IREAD
;
}
if
(
aPermissions
&
(
PR_IWUSR
|
PR_IWGRP
|
PR_IWOTH
)
)
{
mode
|
=
_S_IWRITE
;
}
if
(
_wchmod
(
mWorkingPath
.
get
(
)
mode
)
=
=
-
1
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetFileSize
(
int64_t
*
aFileSize
)
{
if
(
NS_WARN_IF
(
!
aFileSize
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aFileSize
=
mFileInfo64
.
size
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetFileSizeOfLink
(
int64_t
*
aFileSize
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aFileSize
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
PRFileInfo64
info
;
if
(
NS_FAILED
(
GetFileInfo
(
mWorkingPath
&
info
)
)
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
*
aFileSize
=
info
.
size
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetFileSize
(
int64_t
aFileSize
)
{
CHECK_mWorkingPath
(
)
;
nsresult
rv
=
Resolve
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
HANDLE
hFile
=
:
:
CreateFileW
(
mResolvedPath
.
get
(
)
GENERIC_WRITE
FILE_SHARE_READ
nullptr
OPEN_EXISTING
FILE_ATTRIBUTE_NORMAL
nullptr
)
;
if
(
hFile
=
=
INVALID_HANDLE_VALUE
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
rv
=
NS_ERROR_FAILURE
;
aFileSize
=
MyFileSeek64
(
hFile
aFileSize
FILE_BEGIN
)
;
if
(
aFileSize
!
=
-
1
&
&
SetEndOfFile
(
hFile
)
)
{
MakeDirty
(
)
;
rv
=
NS_OK
;
}
CloseHandle
(
hFile
)
;
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetDiskSpaceAvailable
(
int64_t
*
aDiskSpaceAvailable
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aDiskSpaceAvailable
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
ResolveAndStat
(
)
;
if
(
mFileInfo64
.
type
=
=
PR_FILE_FILE
)
{
nsCOMPtr
<
nsIFile
>
parent
;
if
(
NS_SUCCEEDED
(
GetParent
(
getter_AddRefs
(
parent
)
)
)
&
&
parent
)
{
return
parent
-
>
GetDiskSpaceAvailable
(
aDiskSpaceAvailable
)
;
}
}
ULARGE_INTEGER
liFreeBytesAvailableToCaller
liTotalNumberOfBytes
;
if
(
:
:
GetDiskFreeSpaceExW
(
mResolvedPath
.
get
(
)
&
liFreeBytesAvailableToCaller
&
liTotalNumberOfBytes
nullptr
)
)
{
*
aDiskSpaceAvailable
=
liFreeBytesAvailableToCaller
.
QuadPart
;
return
NS_OK
;
}
*
aDiskSpaceAvailable
=
0
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetParent
(
nsIFile
*
*
aParent
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aParent
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
mWorkingPath
.
Length
(
)
=
=
2
)
{
*
aParent
=
nullptr
;
return
NS_OK
;
}
int32_t
offset
=
mWorkingPath
.
RFindChar
(
char16_t
(
'
\
\
'
)
)
;
if
(
offset
=
=
kNotFound
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
if
(
offset
=
=
1
&
&
mWorkingPath
[
0
]
=
=
L
'
\
\
'
)
{
*
aParent
=
nullptr
;
return
NS_OK
;
}
nsAutoString
parentPath
(
mWorkingPath
)
;
if
(
offset
>
0
)
{
parentPath
.
Truncate
(
offset
)
;
}
else
{
parentPath
.
AssignLiteral
(
"
\
\
\
\
.
"
)
;
}
nsCOMPtr
<
nsIFile
>
localFile
;
nsresult
rv
=
NS_NewLocalFile
(
parentPath
mFollowSymlinks
getter_AddRefs
(
localFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
localFile
.
forget
(
aParent
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Exists
(
bool
*
aResult
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
false
;
MakeDirty
(
)
;
nsresult
rv
=
ResolveAndStat
(
)
;
*
aResult
=
NS_SUCCEEDED
(
rv
)
|
|
rv
=
=
NS_ERROR_FILE_IS_LOCKED
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsWritable
(
bool
*
aIsWritable
)
{
CHECK_mWorkingPath
(
)
;
nsresult
rv
=
IsDirectory
(
aIsWritable
)
;
if
(
rv
=
=
NS_ERROR_FILE_ACCESS_DENIED
)
{
*
aIsWritable
=
true
;
return
NS_OK
;
}
else
if
(
rv
=
=
NS_ERROR_FILE_IS_LOCKED
)
{
}
else
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
*
aIsWritable
)
{
return
NS_OK
;
}
rv
=
HasFileAttribute
(
FILE_ATTRIBUTE_READONLY
aIsWritable
)
;
if
(
rv
=
=
NS_ERROR_FILE_ACCESS_DENIED
)
{
*
aIsWritable
=
false
;
return
NS_OK
;
}
else
if
(
rv
=
=
NS_ERROR_FILE_IS_LOCKED
)
{
}
else
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aIsWritable
=
!
*
aIsWritable
;
if
(
*
aIsWritable
)
{
PRFileDesc
*
file
;
rv
=
OpenFile
(
mResolvedPath
PR_WRONLY
0
false
&
file
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
PR_Close
(
file
)
;
}
else
if
(
rv
=
=
NS_ERROR_FILE_ACCESS_DENIED
)
{
*
aIsWritable
=
false
;
}
else
if
(
rv
=
=
NS_ERROR_FILE_IS_LOCKED
)
{
*
aIsWritable
=
true
;
}
else
{
return
rv
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsReadable
(
bool
*
aResult
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
false
;
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aResult
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsExecutable
(
bool
*
aResult
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
false
;
nsresult
rv
;
bool
isFile
;
rv
=
IsFile
(
&
isFile
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
isFile
)
{
return
NS_OK
;
}
bool
symLink
=
false
;
rv
=
IsSymlink
(
&
symLink
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoString
path
;
if
(
symLink
)
{
GetTarget
(
path
)
;
}
else
{
GetPath
(
path
)
;
}
int32_t
filePathLen
=
path
.
Length
(
)
-
1
;
while
(
filePathLen
>
0
&
&
(
path
[
filePathLen
]
=
=
L
'
'
|
|
path
[
filePathLen
]
=
=
L
'
.
'
)
)
{
path
.
Truncate
(
filePathLen
-
-
)
;
}
int32_t
dotIdx
=
path
.
RFindChar
(
char16_t
(
'
.
'
)
)
;
if
(
dotIdx
!
=
kNotFound
)
{
char16_t
*
p
=
path
.
BeginWriting
(
)
;
for
(
p
+
=
dotIdx
+
1
;
*
p
;
+
+
p
)
{
*
p
+
=
(
*
p
>
=
L
'
A
'
&
&
*
p
<
=
L
'
Z
'
)
?
'
a
'
-
'
A
'
:
0
;
}
nsDependentSubstring
ext
=
Substring
(
path
dotIdx
)
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
sExecutableExts
)
;
+
+
i
)
{
if
(
ext
.
EqualsASCII
(
sExecutableExts
[
i
]
)
)
{
*
aResult
=
true
;
break
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsDirectory
(
bool
*
aResult
)
{
return
HasFileAttribute
(
FILE_ATTRIBUTE_DIRECTORY
aResult
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsFile
(
bool
*
aResult
)
{
nsresult
rv
=
HasFileAttribute
(
FILE_ATTRIBUTE_DIRECTORY
aResult
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aResult
=
!
*
aResult
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsHidden
(
bool
*
aResult
)
{
return
HasFileAttribute
(
FILE_ATTRIBUTE_HIDDEN
aResult
)
;
}
nsresult
nsLocalFile
:
:
HasFileAttribute
(
DWORD
aFileAttrib
bool
*
aResult
)
{
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
Resolve
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
DWORD
attributes
=
GetFileAttributesW
(
mResolvedPath
.
get
(
)
)
;
if
(
INVALID_FILE_ATTRIBUTES
=
=
attributes
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
*
aResult
=
(
(
attributes
&
aFileAttrib
)
!
=
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsSymlink
(
bool
*
aResult
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
IsShortcutPath
(
mWorkingPath
)
)
{
*
aResult
=
false
;
return
NS_OK
;
}
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aResult
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsSpecial
(
bool
*
aResult
)
{
return
HasFileAttribute
(
FILE_ATTRIBUTE_SYSTEM
aResult
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Equals
(
nsIFile
*
aInFile
bool
*
aResult
)
{
if
(
NS_WARN_IF
(
!
aInFile
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
EnsureShortPath
(
)
;
nsCOMPtr
<
nsILocalFileWin
>
lf
(
do_QueryInterface
(
aInFile
)
)
;
if
(
!
lf
)
{
*
aResult
=
false
;
return
NS_OK
;
}
nsAutoString
inFilePath
;
lf
-
>
GetCanonicalPath
(
inFilePath
)
;
*
aResult
=
_wcsicmp
(
mShortWorkingPath
.
get
(
)
inFilePath
.
get
(
)
)
=
=
0
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Contains
(
nsIFile
*
aInFile
bool
*
aResult
)
{
CHECK_mWorkingPath
(
)
;
*
aResult
=
false
;
nsAutoString
myFilePath
;
if
(
NS_FAILED
(
GetTarget
(
myFilePath
)
)
)
{
GetPath
(
myFilePath
)
;
}
uint32_t
myFilePathLen
=
myFilePath
.
Length
(
)
;
nsAutoString
inFilePath
;
if
(
NS_FAILED
(
aInFile
-
>
GetTarget
(
inFilePath
)
)
)
{
aInFile
-
>
GetPath
(
inFilePath
)
;
}
if
(
inFilePath
.
Length
(
)
>
=
myFilePathLen
&
&
inFilePath
[
myFilePathLen
]
=
=
L
'
\
\
'
)
{
if
(
_wcsnicmp
(
myFilePath
.
get
(
)
inFilePath
.
get
(
)
myFilePathLen
)
=
=
0
)
{
*
aResult
=
true
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetTarget
(
nsAString
&
aResult
)
{
aResult
.
Truncate
(
)
;
Resolve
(
)
;
aResult
=
mResolvedPath
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetFollowLinks
(
bool
*
aFollowLinks
)
{
*
aFollowLinks
=
mFollowSymlinks
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetFollowLinks
(
bool
aFollowLinks
)
{
MakeDirty
(
)
;
mFollowSymlinks
=
aFollowLinks
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetDirectoryEntriesImpl
(
nsIDirectoryEnumerator
*
*
aEntries
)
{
nsresult
rv
;
*
aEntries
=
nullptr
;
if
(
mWorkingPath
.
EqualsLiteral
(
"
\
\
\
\
.
"
)
)
{
RefPtr
<
nsDriveEnumerator
>
drives
=
new
nsDriveEnumerator
;
rv
=
drives
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
drives
.
forget
(
aEntries
)
;
return
NS_OK
;
}
RefPtr
<
nsDirEnumerator
>
dirEnum
=
new
nsDirEnumerator
(
)
;
rv
=
dirEnum
-
>
Init
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
dirEnum
.
forget
(
aEntries
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetPersistentDescriptor
(
nsACString
&
aPersistentDescriptor
)
{
CopyUTF16toUTF8
(
mWorkingPath
aPersistentDescriptor
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetPersistentDescriptor
(
const
nsACString
&
aPersistentDescriptor
)
{
if
(
IsUtf8
(
aPersistentDescriptor
)
)
{
return
InitWithPath
(
NS_ConvertUTF8toUTF16
(
aPersistentDescriptor
)
)
;
}
else
{
return
InitWithNativePath
(
aPersistentDescriptor
)
;
}
}
NS_IMETHODIMP
nsLocalFile
:
:
GetFileAttributesWin
(
uint32_t
*
aAttribs
)
{
*
aAttribs
=
0
;
DWORD
dwAttrs
=
GetFileAttributesW
(
mWorkingPath
.
get
(
)
)
;
if
(
dwAttrs
=
=
INVALID_FILE_ATTRIBUTES
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
if
(
!
(
dwAttrs
&
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
)
)
{
*
aAttribs
|
=
WFA_SEARCH_INDEXED
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetFileAttributesWin
(
uint32_t
aAttribs
)
{
DWORD
dwAttrs
=
GetFileAttributesW
(
mWorkingPath
.
get
(
)
)
;
if
(
dwAttrs
=
=
INVALID_FILE_ATTRIBUTES
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
if
(
aAttribs
&
WFA_SEARCH_INDEXED
)
{
dwAttrs
&
=
~
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
;
}
else
{
dwAttrs
|
=
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
;
}
if
(
aAttribs
&
WFA_READONLY
)
{
dwAttrs
|
=
FILE_ATTRIBUTE_READONLY
;
}
else
if
(
(
aAttribs
&
WFA_READWRITE
)
&
&
(
dwAttrs
&
FILE_ATTRIBUTE_READONLY
)
)
{
dwAttrs
&
=
~
FILE_ATTRIBUTE_READONLY
;
}
if
(
SetFileAttributesW
(
mWorkingPath
.
get
(
)
dwAttrs
)
=
=
0
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Reveal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
Resolve
(
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_FILE_NOT_FOUND
)
{
return
rv
;
}
nsCOMPtr
<
nsIThreadManager
>
tm
=
do_GetService
(
NS_THREADMANAGER_CONTRACTID
)
;
nsCOMPtr
<
nsIThread
>
mythread
;
rv
=
tm
-
>
NewThread
(
0
0
getter_AddRefs
(
mythread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
AsyncRevealOperation
(
mResolvedPath
)
;
mythread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Launch
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
Resolve
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
_bstr_t
execPath
(
mResolvedPath
.
get
(
)
)
;
_variant_t
args
;
_variant_t
verbDefault
(
DISP_E_PARAMNOTFOUND
VT_ERROR
)
;
_variant_t
workingDir
;
_variant_t
showCmd
(
SW_SHOWNORMAL
)
;
WCHAR
workingDirectory
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
wcsncpy
(
workingDirectory
mResolvedPath
.
get
(
)
MAX_PATH
)
;
if
(
PathRemoveFileSpecW
(
workingDirectory
)
)
{
workingDir
=
workingDirectory
;
}
else
{
NS_WARNING
(
"
Could
not
set
working
directory
for
launched
file
.
"
)
;
}
mozilla
:
:
LauncherVoidResult
shellExecuteOk
=
mozilla
:
:
ShellExecuteByExplorer
(
execPath
args
verbDefault
workingDir
showCmd
)
;
if
(
shellExecuteOk
.
isErr
(
)
)
{
return
NS_ERROR_FILE_EXECUTION_FAILED
;
}
return
NS_OK
;
}
nsresult
NS_NewLocalFile
(
const
nsAString
&
aPath
bool
aFollowLinks
nsIFile
*
*
aResult
)
{
RefPtr
<
nsLocalFile
>
file
=
new
nsLocalFile
(
)
;
file
-
>
SetFollowLinks
(
aFollowLinks
)
;
if
(
!
aPath
.
IsEmpty
(
)
)
{
nsresult
rv
=
file
-
>
InitWithPath
(
aPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
file
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
InitWithNativePath
(
const
nsACString
&
aFilePath
)
{
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aFilePath
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
InitWithPath
(
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
AppendNative
(
const
nsACString
&
aNode
)
{
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aNode
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
Append
(
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
AppendRelativeNativePath
(
const
nsACString
&
aNode
)
{
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aNode
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
AppendRelativePath
(
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetNativeLeafName
(
nsACString
&
aLeafName
)
{
nsAutoString
tmp
;
nsresult
rv
=
GetLeafName
(
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
NS_CopyUnicodeToNative
(
tmp
aLeafName
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetNativeLeafName
(
const
nsACString
&
aLeafName
)
{
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aLeafName
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
SetLeafName
(
tmp
)
;
}
return
rv
;
}
nsString
nsLocalFile
:
:
NativePath
(
)
{
return
mWorkingPath
;
}
nsCString
nsIFile
:
:
HumanReadablePath
(
)
{
nsString
path
;
DebugOnly
<
nsresult
>
rv
=
GetPath
(
path
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
NS_ConvertUTF16toUTF8
(
path
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetNativeCanonicalPath
(
nsACString
&
aResult
)
{
NS_WARNING
(
"
This
method
is
lossy
.
Use
GetCanonicalPath
!
"
)
;
EnsureShortPath
(
)
;
NS_CopyUnicodeToNative
(
mShortWorkingPath
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
CopyToNative
(
nsIFile
*
aNewParentDir
const
nsACString
&
aNewName
)
{
CHECK_mWorkingPath
(
)
;
if
(
aNewName
.
IsEmpty
(
)
)
{
return
CopyTo
(
aNewParentDir
EmptyString
(
)
)
;
}
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aNewName
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
CopyTo
(
aNewParentDir
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
CopyToFollowingLinksNative
(
nsIFile
*
aNewParentDir
const
nsACString
&
aNewName
)
{
if
(
aNewName
.
IsEmpty
(
)
)
{
return
CopyToFollowingLinks
(
aNewParentDir
EmptyString
(
)
)
;
}
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aNewName
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
CopyToFollowingLinks
(
aNewParentDir
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
MoveToNative
(
nsIFile
*
aNewParentDir
const
nsACString
&
aNewName
)
{
CHECK_mWorkingPath
(
)
;
if
(
aNewName
.
IsEmpty
(
)
)
{
return
MoveTo
(
aNewParentDir
EmptyString
(
)
)
;
}
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aNewName
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
MoveTo
(
aNewParentDir
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetNativeTarget
(
nsACString
&
aResult
)
{
CHECK_mWorkingPath
(
)
;
NS_WARNING
(
"
This
API
is
lossy
.
Use
GetTarget
!
"
)
;
nsAutoString
tmp
;
nsresult
rv
=
GetTarget
(
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
NS_CopyUnicodeToNative
(
tmp
aResult
)
;
}
return
rv
;
}
nsresult
NS_NewNativeLocalFile
(
const
nsACString
&
aPath
bool
aFollowLinks
nsIFile
*
*
aResult
)
{
nsAutoString
buf
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aPath
buf
)
;
if
(
NS_FAILED
(
rv
)
)
{
*
aResult
=
nullptr
;
return
rv
;
}
return
NS_NewLocalFile
(
buf
aFollowLinks
aResult
)
;
}
void
nsLocalFile
:
:
EnsureShortPath
(
)
{
if
(
!
mShortWorkingPath
.
IsEmpty
(
)
)
{
return
;
}
WCHAR
shortPath
[
MAX_PATH
+
1
]
;
DWORD
lengthNeeded
=
:
:
GetShortPathNameW
(
mWorkingPath
.
get
(
)
shortPath
ArrayLength
(
shortPath
)
)
;
if
(
lengthNeeded
!
=
0
&
&
lengthNeeded
<
ArrayLength
(
shortPath
)
)
{
mShortWorkingPath
.
Assign
(
shortPath
)
;
}
else
{
mShortWorkingPath
.
Assign
(
mWorkingPath
)
;
}
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsDriveEnumerator
nsSimpleEnumerator
nsIDirectoryEnumerator
)
nsDriveEnumerator
:
:
nsDriveEnumerator
(
)
{
}
nsDriveEnumerator
:
:
~
nsDriveEnumerator
(
)
{
}
nsresult
nsDriveEnumerator
:
:
Init
(
)
{
DWORD
length
=
GetLogicalDriveStringsW
(
0
0
)
;
if
(
!
mDrives
.
SetLength
(
length
+
1
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
!
GetLogicalDriveStringsW
(
length
mDrives
.
get
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
mDrives
.
BeginReading
(
mStartOfCurrentDrive
)
;
mDrives
.
EndReading
(
mEndOfDrivesString
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDriveEnumerator
:
:
HasMoreElements
(
bool
*
aHasMore
)
{
*
aHasMore
=
*
mStartOfCurrentDrive
!
=
L
'
\
0
'
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDriveEnumerator
:
:
GetNext
(
nsISupports
*
*
aNext
)
{
if
(
*
mStartOfCurrentDrive
=
=
L
'
\
0
'
)
{
*
aNext
=
nullptr
;
return
NS_ERROR_FAILURE
;
}
nsAString
:
:
const_iterator
driveEnd
=
mStartOfCurrentDrive
;
FindCharInReadable
(
L
'
\
0
'
driveEnd
mEndOfDrivesString
)
;
nsString
drive
(
Substring
(
mStartOfCurrentDrive
driveEnd
)
)
;
mStartOfCurrentDrive
=
+
+
driveEnd
;
nsIFile
*
file
;
nsresult
rv
=
NS_NewLocalFile
(
drive
false
&
file
)
;
*
aNext
=
file
;
return
rv
;
}
