#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsLocalFile
.
h
"
#
include
"
nsLocalFileCommon
.
h
"
#
include
"
nsIDirectoryEnumerator
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nsSimpleEnumerator
.
h
"
#
include
"
prio
.
h
"
#
include
"
private
/
pprio
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
<
direct
.
h
>
#
include
<
fileapi
.
h
>
#
include
<
windows
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
aclapi
.
h
>
#
include
"
shellapi
.
h
"
#
include
"
shlguid
.
h
"
#
include
<
io
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
mbstring
.
h
>
#
include
"
prproces
.
h
"
#
include
"
prlink
.
h
"
#
include
"
mozilla
/
FilePreferences
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
SpecialSystemDirectory
.
h
"
#
include
"
nsTraceRefcnt
.
h
"
#
include
"
nsXPCOMCIDInternal
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsIWindowMediator
.
h
"
#
include
"
mozIDOMWindow
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
mozilla
/
ShellHeaderOnlyUtils
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
#
include
"
WinUtils
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
FilePreferences
:
:
kDevicePathSpecifier
;
using
mozilla
:
:
FilePreferences
:
:
kPathSeparator
;
#
define
CHECK_mWorkingPath
(
)
\
do
{
\
if
(
mWorkingPath
.
IsEmpty
(
)
)
return
NS_ERROR_NOT_INITIALIZED
;
\
}
while
(
0
)
#
ifndef
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
#
define
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
0x00002000
#
endif
#
ifndef
DRIVE_REMOTE
#
define
DRIVE_REMOTE
4
#
endif
namespace
{
nsresult
NewLocalFile
(
const
nsAString
&
aPath
bool
aUseDOSDevicePathSyntax
nsIFile
*
*
aResult
)
{
RefPtr
<
nsLocalFile
>
file
=
new
nsLocalFile
(
)
;
file
-
>
SetUseDOSDevicePathSyntax
(
aUseDOSDevicePathSyntax
)
;
if
(
!
aPath
.
IsEmpty
(
)
)
{
nsresult
rv
=
file
-
>
InitWithPath
(
aPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
file
.
forget
(
aResult
)
;
return
NS_OK
;
}
}
static
HWND
GetMostRecentNavigatorHWND
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIWindowMediator
>
winMediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
nsCOMPtr
<
mozIDOMWindowProxy
>
navWin
;
rv
=
winMediator
-
>
GetMostRecentWindow
(
u
"
navigator
:
browser
"
getter_AddRefs
(
navWin
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
navWin
)
{
return
nullptr
;
}
nsPIDOMWindowOuter
*
win
=
nsPIDOMWindowOuter
:
:
From
(
navWin
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
widget
:
:
WidgetUtils
:
:
DOMWindowToWidget
(
win
)
;
if
(
!
widget
)
{
return
nullptr
;
}
return
reinterpret_cast
<
HWND
>
(
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
)
;
}
nsresult
nsLocalFile
:
:
RevealFile
(
const
nsString
&
aResolvedPath
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
Don
'
t
run
on
the
main
thread
"
)
;
DWORD
attributes
=
GetFileAttributesW
(
aResolvedPath
.
get
(
)
)
;
if
(
INVALID_FILE_ATTRIBUTES
=
=
attributes
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
HRESULT
hr
;
if
(
attributes
&
FILE_ATTRIBUTE_DIRECTORY
)
{
LPITEMIDLIST
dir
=
ILCreateFromPathW
(
aResolvedPath
.
get
(
)
)
;
if
(
!
dir
)
{
return
NS_ERROR_FAILURE
;
}
LPCITEMIDLIST
selection
[
]
=
{
dir
}
;
UINT
count
=
ArrayLength
(
selection
)
;
hr
=
SHOpenFolderAndSelectItems
(
dir
count
selection
0
)
;
CoTaskMemFree
(
dir
)
;
}
else
{
int32_t
len
=
aResolvedPath
.
Length
(
)
;
if
(
len
>
MAX_PATH
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
WCHAR
parentDirectoryPath
[
MAX_PATH
+
1
]
=
{
0
}
;
wcsncpy
(
parentDirectoryPath
aResolvedPath
.
get
(
)
MAX_PATH
)
;
PathRemoveFileSpecW
(
parentDirectoryPath
)
;
LPITEMIDLIST
dir
=
ILCreateFromPathW
(
parentDirectoryPath
)
;
if
(
!
dir
)
{
return
NS_ERROR_FAILURE
;
}
LPITEMIDLIST
item
=
ILCreateFromPathW
(
aResolvedPath
.
get
(
)
)
;
if
(
!
item
)
{
CoTaskMemFree
(
dir
)
;
return
NS_ERROR_FAILURE
;
}
LPCITEMIDLIST
selection
[
]
=
{
item
}
;
UINT
count
=
ArrayLength
(
selection
)
;
hr
=
SHOpenFolderAndSelectItems
(
dir
count
selection
0
)
;
CoTaskMemFree
(
dir
)
;
CoTaskMemFree
(
item
)
;
}
return
SUCCEEDED
(
hr
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
void
nsLocalFile
:
:
CheckForReservedFileName
(
nsString
&
aFileName
)
{
static
const
nsLiteralString
forbiddenNames
[
]
=
{
u
"
COM1
"
_ns
u
"
COM2
"
_ns
u
"
COM3
"
_ns
u
"
COM4
"
_ns
u
"
COM5
"
_ns
u
"
COM6
"
_ns
u
"
COM7
"
_ns
u
"
COM8
"
_ns
u
"
COM9
"
_ns
u
"
LPT1
"
_ns
u
"
LPT2
"
_ns
u
"
LPT3
"
_ns
u
"
LPT4
"
_ns
u
"
LPT5
"
_ns
u
"
LPT6
"
_ns
u
"
LPT7
"
_ns
u
"
LPT8
"
_ns
u
"
LPT9
"
_ns
u
"
CON
"
_ns
u
"
PRN
"
_ns
u
"
AUX
"
_ns
u
"
NUL
"
_ns
u
"
CLOCK
"
_ns
}
;
for
(
const
nsLiteralString
&
forbiddenName
:
forbiddenNames
)
{
if
(
StringBeginsWith
(
aFileName
forbiddenName
nsASCIICaseInsensitiveStringComparator
)
)
{
if
(
aFileName
.
Length
(
)
=
=
forbiddenName
.
Length
(
)
|
|
aFileName
.
CharAt
(
forbiddenName
.
Length
(
)
)
=
=
char16_t
(
'
.
'
)
)
{
aFileName
.
Truncate
(
)
;
}
}
}
}
class
nsDriveEnumerator
:
public
nsSimpleEnumerator
public
nsIDirectoryEnumerator
{
public
:
explicit
nsDriveEnumerator
(
bool
aUseDOSDevicePathSyntax
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSISIMPLEENUMERATOR
NS_FORWARD_NSISIMPLEENUMERATORBASE
(
nsSimpleEnumerator
:
:
)
nsresult
Init
(
)
;
const
nsID
&
DefaultInterface
(
)
override
{
return
NS_GET_IID
(
nsIFile
)
;
}
NS_IMETHOD
GetNextFile
(
nsIFile
*
*
aResult
)
override
{
bool
hasMore
=
false
;
nsresult
rv
=
HasMoreElements
(
&
hasMore
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
hasMore
)
{
return
rv
;
}
nsCOMPtr
<
nsISupports
>
next
;
rv
=
GetNext
(
getter_AddRefs
(
next
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
result
=
do_QueryInterface
(
next
)
;
result
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHOD
Close
(
)
override
{
return
NS_OK
;
}
private
:
virtual
~
nsDriveEnumerator
(
)
;
nsString
mDrives
;
nsAString
:
:
const_iterator
mStartOfCurrentDrive
;
nsAString
:
:
const_iterator
mEndOfDrivesString
;
const
bool
mUseDOSDevicePathSyntax
;
}
;
static
nsresult
ConvertWinError
(
DWORD
aWinErr
)
{
nsresult
rv
;
switch
(
aWinErr
)
{
case
ERROR_FILE_NOT_FOUND
:
[
[
fallthrough
]
]
;
case
ERROR_PATH_NOT_FOUND
:
[
[
fallthrough
]
]
;
case
ERROR_INVALID_DRIVE
:
rv
=
NS_ERROR_FILE_NOT_FOUND
;
break
;
case
ERROR_ACCESS_DENIED
:
[
[
fallthrough
]
]
;
case
ERROR_NOT_SAME_DEVICE
:
[
[
fallthrough
]
]
;
case
ERROR_CANNOT_MAKE
:
[
[
fallthrough
]
]
;
case
ERROR_CONTENT_BLOCKED
:
rv
=
NS_ERROR_FILE_ACCESS_DENIED
;
break
;
case
ERROR_SHARING_VIOLATION
:
[
[
fallthrough
]
]
;
case
ERROR_LOCK_VIOLATION
:
rv
=
NS_ERROR_FILE_IS_LOCKED
;
break
;
case
ERROR_NOT_ENOUGH_MEMORY
:
[
[
fallthrough
]
]
;
case
ERROR_NO_SYSTEM_RESOURCES
:
rv
=
NS_ERROR_OUT_OF_MEMORY
;
break
;
case
ERROR_DIR_NOT_EMPTY
:
[
[
fallthrough
]
]
;
case
ERROR_CURRENT_DIRECTORY
:
rv
=
NS_ERROR_FILE_DIR_NOT_EMPTY
;
break
;
case
ERROR_WRITE_PROTECT
:
rv
=
NS_ERROR_FILE_READ_ONLY
;
break
;
case
ERROR_HANDLE_DISK_FULL
:
[
[
fallthrough
]
]
;
case
ERROR_DISK_FULL
:
rv
=
NS_ERROR_FILE_NO_DEVICE_SPACE
;
break
;
case
ERROR_FILE_EXISTS
:
[
[
fallthrough
]
]
;
case
ERROR_ALREADY_EXISTS
:
rv
=
NS_ERROR_FILE_ALREADY_EXISTS
;
break
;
case
ERROR_FILENAME_EXCED_RANGE
:
rv
=
NS_ERROR_FILE_NAME_TOO_LONG
;
break
;
case
ERROR_DIRECTORY
:
rv
=
NS_ERROR_FILE_NOT_DIRECTORY
;
break
;
case
ERROR_FILE_CORRUPT
:
[
[
fallthrough
]
]
;
case
ERROR_DISK_CORRUPT
:
rv
=
NS_ERROR_FILE_FS_CORRUPTED
;
break
;
case
ERROR_DEVICE_HARDWARE_ERROR
:
[
[
fallthrough
]
]
;
case
ERROR_DEVICE_NOT_CONNECTED
:
[
[
fallthrough
]
]
;
case
ERROR_DEV_NOT_EXIST
:
[
[
fallthrough
]
]
;
case
ERROR_IO_DEVICE
:
rv
=
NS_ERROR_FILE_DEVICE_FAILURE
;
break
;
case
ERROR_NOT_READY
:
rv
=
NS_ERROR_FILE_DEVICE_TEMPORARY_FAILURE
;
break
;
case
ERROR_INVALID_NAME
:
rv
=
NS_ERROR_FILE_INVALID_PATH
;
break
;
case
ERROR_INVALID_BLOCK
:
[
[
fallthrough
]
]
;
case
ERROR_INVALID_HANDLE
:
[
[
fallthrough
]
]
;
case
ERROR_ARENA_TRASHED
:
rv
=
NS_ERROR_FILE_INVALID_HANDLE
;
break
;
case
0
:
rv
=
NS_OK
;
break
;
default
:
printf_stderr
(
"
ConvertWinError
received
an
unrecognized
WinError
:
0x
%
"
PRIx32
"
\
n
"
static_cast
<
uint32_t
>
(
aWinErr
)
)
;
MOZ_ASSERT
(
(
aWinErr
&
0xFFFF
)
=
=
aWinErr
)
;
rv
=
NS_ERROR_GENERATE_FAILURE
(
NS_ERROR_MODULE_WIN32
aWinErr
&
0xFFFF
)
;
break
;
}
return
rv
;
}
static
bool
IsRootPath
(
const
nsAString
&
aPath
)
{
if
(
aPath
.
Last
(
)
!
=
L
'
\
\
'
)
{
return
false
;
}
if
(
StringEndsWith
(
aPath
u
"
:
\
\
"
_ns
)
)
{
return
true
;
}
nsAString
:
:
const_iterator
begin
end
;
aPath
.
BeginReading
(
begin
)
;
aPath
.
EndReading
(
end
)
;
end
-
-
;
if
(
RFindInReadable
(
u
"
\
\
"
_ns
begin
end
)
)
{
aPath
.
EndReading
(
end
)
;
end
-
-
;
auto
lastSegment
=
Substring
(
+
+
begin
end
)
;
if
(
lastSegment
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
lastSegment
.
Last
(
)
=
=
L
'
'
&
&
lastSegment
.
Length
(
)
=
=
2
&
&
IsAsciiAlpha
(
lastSegment
.
First
(
)
)
)
{
return
true
;
}
if
(
StringBeginsWith
(
lastSegment
u
"
Volume
{
"
_ns
)
&
&
lastSegment
.
Last
(
)
=
=
L
'
}
'
)
{
return
true
;
}
}
return
false
;
}
static
auto
kSpecialNTFSFilesInRoot
=
{
u
"
MFT
"
_ns
u
"
MFTMirr
"
_ns
u
"
LogFile
"
_ns
u
"
Volume
"
_ns
u
"
AttrDef
"
_ns
u
"
Bitmap
"
_ns
u
"
Boot
"
_ns
u
"
BadClus
"
_ns
u
"
Secure
"
_ns
u
"
UpCase
"
_ns
u
"
Extend
"
_ns
}
;
static
bool
IsSpecialNTFSPath
(
const
nsAString
&
aFilePath
)
{
nsAString
:
:
const_iterator
begin
end
;
aFilePath
.
BeginReading
(
begin
)
;
aFilePath
.
EndReading
(
end
)
;
auto
iter
=
begin
;
if
(
!
FindCharInReadable
(
L
'
'
iter
end
)
)
{
return
false
;
}
iter
=
begin
;
if
(
FindInReadable
(
u
"
:
"
_ns
iter
end
)
)
{
return
true
;
}
auto
normalized
=
mozilla
:
:
MakeUniqueFallible
<
wchar_t
[
]
>
(
MAX_PATH
)
;
if
(
!
normalized
)
{
return
true
;
}
auto
flatPath
=
PromiseFlatString
(
aFilePath
)
;
auto
fullPathRV
=
GetFullPathNameW
(
flatPath
.
get
(
)
MAX_PATH
-
1
normalized
.
get
(
)
nullptr
)
;
if
(
fullPathRV
=
=
0
|
|
fullPathRV
>
MAX_PATH
-
1
)
{
return
false
;
}
nsString
normalizedPath
(
normalized
.
get
(
)
)
;
normalizedPath
.
BeginReading
(
begin
)
;
normalizedPath
.
EndReading
(
end
)
;
iter
=
begin
;
auto
kDelimiters
=
u
"
\
\
:
"
_ns
;
while
(
iter
!
=
end
&
&
FindCharInReadable
(
L
'
'
iter
end
)
)
{
for
(
auto
str
:
kSpecialNTFSFilesInRoot
)
{
if
(
StringBeginsWith
(
Substring
(
iter
end
)
str
nsCaseInsensitiveStringComparator
)
)
{
auto
iterCopy
=
iter
;
iterCopy
.
advance
(
str
.
Length
(
)
)
;
if
(
iterCopy
=
=
end
|
|
kDelimiters
.
Contains
(
*
iterCopy
)
)
{
iterCopy
=
iter
;
if
(
iterCopy
=
=
begin
|
|
*
(
-
-
iterCopy
)
=
=
L
'
\
\
'
)
{
return
IsRootPath
(
Substring
(
begin
iter
)
)
;
}
}
}
}
iter
+
+
;
}
return
false
;
}
typedef
enum
{
_PR_TRI_TRUE
=
1
_PR_TRI_FALSE
=
0
_PR_TRI_UNKNOWN
=
-
1
}
_PRTriStateBool
;
struct
_MDFileDesc
{
PROsfd
osfd
;
}
;
struct
PRFilePrivate
{
int32_t
state
;
bool
nonblocking
;
_PRTriStateBool
inheritable
;
PRFileDesc
*
next
;
int
lockCount
;
bool
appendMode
;
_MDFileDesc
md
;
}
;
nsresult
OpenFile
(
const
nsString
&
aName
int
aOsflags
int
aMode
bool
aShareDelete
PRFileDesc
*
*
aFd
)
{
int32_t
access
=
0
;
int32_t
shareMode
=
FILE_SHARE_READ
|
FILE_SHARE_WRITE
;
int32_t
disposition
=
0
;
int32_t
attributes
=
0
;
if
(
aShareDelete
)
{
shareMode
|
=
FILE_SHARE_DELETE
;
}
if
(
aOsflags
&
PR_SYNC
)
{
attributes
=
FILE_FLAG_WRITE_THROUGH
;
}
if
(
aOsflags
&
PR_RDONLY
|
|
aOsflags
&
PR_RDWR
)
{
access
|
=
GENERIC_READ
;
}
if
(
aOsflags
&
PR_WRONLY
|
|
aOsflags
&
PR_RDWR
)
{
access
|
=
GENERIC_WRITE
;
}
if
(
aOsflags
&
PR_CREATE_FILE
&
&
aOsflags
&
PR_EXCL
)
{
disposition
=
CREATE_NEW
;
}
else
if
(
aOsflags
&
PR_CREATE_FILE
)
{
if
(
aOsflags
&
PR_TRUNCATE
)
{
disposition
=
CREATE_ALWAYS
;
}
else
{
disposition
=
OPEN_ALWAYS
;
}
}
else
{
if
(
aOsflags
&
PR_TRUNCATE
)
{
disposition
=
TRUNCATE_EXISTING
;
}
else
{
disposition
=
OPEN_EXISTING
;
}
}
if
(
aOsflags
&
nsIFile
:
:
DELETE_ON_CLOSE
)
{
attributes
|
=
FILE_FLAG_DELETE_ON_CLOSE
;
}
if
(
aOsflags
&
nsIFile
:
:
OS_READAHEAD
)
{
attributes
|
=
FILE_FLAG_SEQUENTIAL_SCAN
;
}
if
(
!
(
aMode
&
(
PR_IWUSR
|
PR_IWGRP
|
PR_IWOTH
)
)
&
&
disposition
!
=
OPEN_EXISTING
)
{
attributes
|
=
FILE_ATTRIBUTE_READONLY
;
}
HANDLE
file
=
:
:
CreateFileW
(
aName
.
get
(
)
access
shareMode
nullptr
disposition
attributes
nullptr
)
;
if
(
file
=
=
INVALID_HANDLE_VALUE
)
{
*
aFd
=
nullptr
;
return
ConvertWinError
(
GetLastError
(
)
)
;
}
*
aFd
=
PR_ImportFile
(
(
PROsfd
)
file
)
;
if
(
*
aFd
)
{
(
*
aFd
)
-
>
secret
-
>
appendMode
=
(
PR_APPEND
&
aOsflags
)
?
true
:
false
;
return
NS_OK
;
}
nsresult
rv
=
NS_ErrorAccordingToNSPR
(
)
;
CloseHandle
(
file
)
;
return
rv
;
}
static
void
FileTimeToPRTime
(
const
FILETIME
*
aFiletime
PRTime
*
aPrtm
)
{
#
ifdef
__GNUC__
const
PRTime
_pr_filetime_offset
=
116444736000000000LL
;
#
else
const
PRTime
_pr_filetime_offset
=
116444736000000000i64
;
#
endif
MOZ_ASSERT
(
sizeof
(
FILETIME
)
=
=
sizeof
(
PRTime
)
)
;
:
:
CopyMemory
(
aPrtm
aFiletime
sizeof
(
PRTime
)
)
;
#
ifdef
__GNUC__
*
aPrtm
=
(
*
aPrtm
-
_pr_filetime_offset
)
/
10LL
;
#
else
*
aPrtm
=
(
*
aPrtm
-
_pr_filetime_offset
)
/
10i64
;
#
endif
}
static
nsresult
GetFileInfo
(
const
nsString
&
aName
nsLocalFile
:
:
FileInfo
*
aInfo
)
{
if
(
aName
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
const
int32_t
offset
=
StringBeginsWith
(
aName
kDevicePathSpecifier
)
?
kDevicePathSpecifier
.
Length
(
)
:
0
;
if
(
aName
.
FindCharInSet
(
u
"
?
*
"
offset
)
!
=
kNotFound
)
{
return
NS_ERROR_INVALID_ARG
;
}
WIN32_FILE_ATTRIBUTE_DATA
fileData
;
if
(
!
:
:
GetFileAttributesExW
(
aName
.
get
(
)
GetFileExInfoStandard
&
fileData
)
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
if
(
fileData
.
dwFileAttributes
&
FILE_ATTRIBUTE_REPARSE_POINT
)
{
aInfo
-
>
type
=
PR_FILE_OTHER
;
}
else
if
(
fileData
.
dwFileAttributes
&
FILE_ATTRIBUTE_DIRECTORY
)
{
aInfo
-
>
type
=
PR_FILE_DIRECTORY
;
}
else
{
aInfo
-
>
type
=
PR_FILE_FILE
;
}
aInfo
-
>
size
=
fileData
.
nFileSizeHigh
;
aInfo
-
>
size
=
(
aInfo
-
>
size
<
<
32
)
+
fileData
.
nFileSizeLow
;
if
(
0
=
=
fileData
.
ftCreationTime
.
dwLowDateTime
&
&
0
=
=
fileData
.
ftCreationTime
.
dwHighDateTime
)
{
aInfo
-
>
creationTime
=
aInfo
-
>
modifyTime
;
}
else
{
FileTimeToPRTime
(
&
fileData
.
ftCreationTime
&
aInfo
-
>
creationTime
)
;
}
FileTimeToPRTime
(
&
fileData
.
ftLastAccessTime
&
aInfo
-
>
accessTime
)
;
FileTimeToPRTime
(
&
fileData
.
ftLastWriteTime
&
aInfo
-
>
modifyTime
)
;
return
NS_OK
;
}
struct
nsDir
{
HANDLE
handle
;
WIN32_FIND_DATAW
data
;
bool
firstEntry
;
}
;
static
nsresult
OpenDir
(
const
nsString
&
aName
nsDir
*
*
aDir
)
{
if
(
NS_WARN_IF
(
!
aDir
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aDir
=
nullptr
;
nsDir
*
d
=
new
nsDir
(
)
;
nsAutoString
filename
(
aName
)
;
if
(
filename
.
Last
(
)
=
=
L
'
/
'
|
|
filename
.
Last
(
)
=
=
L
'
\
\
'
)
{
filename
.
Append
(
'
*
'
)
;
}
else
{
filename
.
AppendLiteral
(
"
\
\
*
"
)
;
}
filename
.
ReplaceChar
(
L
'
/
'
L
'
\
\
'
)
;
d
-
>
handle
=
:
:
FindFirstFileW
(
filename
.
get
(
)
&
(
d
-
>
data
)
)
;
if
(
d
-
>
handle
=
=
INVALID_HANDLE_VALUE
)
{
delete
d
;
return
ConvertWinError
(
GetLastError
(
)
)
;
}
d
-
>
firstEntry
=
true
;
*
aDir
=
d
;
return
NS_OK
;
}
static
nsresult
ReadDir
(
nsDir
*
aDir
PRDirFlags
aFlags
nsString
&
aName
)
{
aName
.
Truncate
(
)
;
if
(
NS_WARN_IF
(
!
aDir
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
while
(
1
)
{
BOOL
rv
;
if
(
aDir
-
>
firstEntry
)
{
aDir
-
>
firstEntry
=
false
;
rv
=
1
;
}
else
{
rv
=
:
:
FindNextFileW
(
aDir
-
>
handle
&
(
aDir
-
>
data
)
)
;
}
if
(
rv
=
=
0
)
{
break
;
}
const
wchar_t
*
fileName
;
fileName
=
(
aDir
)
-
>
data
.
cFileName
;
if
(
(
aFlags
&
PR_SKIP_DOT
)
&
&
(
fileName
[
0
]
=
=
L
'
.
'
)
&
&
(
fileName
[
1
]
=
=
L
'
\
0
'
)
)
{
continue
;
}
if
(
(
aFlags
&
PR_SKIP_DOT_DOT
)
&
&
(
fileName
[
0
]
=
=
L
'
.
'
)
&
&
(
fileName
[
1
]
=
=
L
'
.
'
)
&
&
(
fileName
[
2
]
=
=
L
'
\
0
'
)
)
{
continue
;
}
DWORD
attrib
=
aDir
-
>
data
.
dwFileAttributes
;
if
(
(
aFlags
&
PR_SKIP_HIDDEN
)
&
&
(
attrib
&
FILE_ATTRIBUTE_HIDDEN
)
)
{
continue
;
}
aName
=
fileName
;
return
NS_OK
;
}
DWORD
err
=
GetLastError
(
)
;
return
err
=
=
ERROR_NO_MORE_FILES
?
NS_OK
:
ConvertWinError
(
err
)
;
}
static
nsresult
CloseDir
(
nsDir
*
&
aDir
)
{
if
(
NS_WARN_IF
(
!
aDir
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
BOOL
isOk
=
FindClose
(
aDir
-
>
handle
)
;
delete
aDir
;
aDir
=
nullptr
;
return
isOk
?
NS_OK
:
ConvertWinError
(
GetLastError
(
)
)
;
}
class
nsDirEnumerator
final
:
public
nsSimpleEnumerator
public
nsIDirectoryEnumerator
{
private
:
~
nsDirEnumerator
(
)
{
Close
(
)
;
}
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_FORWARD_NSISIMPLEENUMERATORBASE
(
nsSimpleEnumerator
:
:
)
nsDirEnumerator
(
)
:
mDir
(
nullptr
)
{
}
const
nsID
&
DefaultInterface
(
)
override
{
return
NS_GET_IID
(
nsIFile
)
;
}
nsresult
Init
(
nsIFile
*
aParent
)
{
nsAutoString
filepath
;
aParent
-
>
GetTarget
(
filepath
)
;
if
(
filepath
.
IsEmpty
(
)
)
{
aParent
-
>
GetPath
(
filepath
)
;
}
if
(
filepath
.
IsEmpty
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
OpenDir
(
filepath
&
mDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mParent
=
aParent
;
return
NS_OK
;
}
NS_IMETHOD
HasMoreElements
(
bool
*
aResult
)
override
{
nsresult
rv
;
if
(
!
mNext
&
&
mDir
)
{
nsString
name
;
rv
=
ReadDir
(
mDir
PR_SKIP_BOTH
name
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
name
.
IsEmpty
(
)
)
{
rv
=
CloseDir
(
mDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aResult
=
false
;
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
file
;
rv
=
mParent
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
file
-
>
Append
(
name
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mNext
=
file
.
forget
(
)
;
}
*
aResult
=
mNext
!
=
nullptr
;
if
(
!
*
aResult
)
{
Close
(
)
;
}
return
NS_OK
;
}
NS_IMETHOD
GetNext
(
nsISupports
*
*
aResult
)
override
{
nsresult
rv
;
bool
hasMore
;
rv
=
HasMoreElements
(
&
hasMore
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
hasMore
)
{
return
NS_ERROR_FAILURE
;
}
mNext
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHOD
GetNextFile
(
nsIFile
*
*
aResult
)
override
{
*
aResult
=
nullptr
;
bool
hasMore
=
false
;
nsresult
rv
=
HasMoreElements
(
&
hasMore
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
hasMore
)
{
return
rv
;
}
mNext
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHOD
Close
(
)
override
{
if
(
mDir
)
{
nsresult
rv
=
CloseDir
(
mDir
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
close
failed
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
protected
:
nsDir
*
mDir
;
nsCOMPtr
<
nsIFile
>
mParent
;
nsCOMPtr
<
nsIFile
>
mNext
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
nsDirEnumerator
nsSimpleEnumerator
nsIDirectoryEnumerator
)
nsLocalFile
:
:
nsLocalFile
(
)
:
mDirty
(
true
)
mResolveDirty
(
true
)
mUseDOSDevicePathSyntax
(
false
)
{
}
nsLocalFile
:
:
nsLocalFile
(
const
nsAString
&
aFilePath
)
:
mUseDOSDevicePathSyntax
(
false
)
{
InitWithPath
(
aFilePath
)
;
}
nsresult
nsLocalFile
:
:
nsLocalFileConstructor
(
const
nsIID
&
aIID
void
*
*
aInstancePtr
)
{
if
(
NS_WARN_IF
(
!
aInstancePtr
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsLocalFile
*
inst
=
new
nsLocalFile
(
)
;
nsresult
rv
=
inst
-
>
QueryInterface
(
aIID
aInstancePtr
)
;
if
(
NS_FAILED
(
rv
)
)
{
delete
inst
;
return
rv
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsLocalFile
nsIFile
nsILocalFileWin
)
nsLocalFile
:
:
nsLocalFile
(
const
nsLocalFile
&
aOther
)
:
mDirty
(
true
)
mResolveDirty
(
true
)
mUseDOSDevicePathSyntax
(
aOther
.
mUseDOSDevicePathSyntax
)
mWorkingPath
(
aOther
.
mWorkingPath
)
{
}
nsresult
nsLocalFile
:
:
ResolveSymlink
(
)
{
std
:
:
wstring
workingPath
(
mWorkingPath
.
Data
(
)
)
;
if
(
!
widget
:
:
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
workingPath
)
)
{
return
NS_ERROR_FAILURE
;
}
mResolvedPath
.
Assign
(
workingPath
.
c_str
(
)
workingPath
.
length
(
)
)
;
return
NS_OK
;
}
nsresult
nsLocalFile
:
:
ResolveAndStat
(
)
{
if
(
!
mDirty
)
{
return
NS_OK
;
}
AUTO_PROFILER_LABEL
(
"
nsLocalFile
:
:
ResolveAndStat
"
OTHER
)
;
if
(
mWorkingPath
.
IsEmpty
(
)
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
mResolvedPath
.
Assign
(
mWorkingPath
)
;
nsAutoString
nsprPath
(
mWorkingPath
)
;
if
(
mWorkingPath
.
Length
(
)
=
=
2
&
&
mWorkingPath
.
CharAt
(
1
)
=
=
u
'
:
'
)
{
nsprPath
.
Append
(
'
\
\
'
)
;
}
nsresult
rv
=
GetFileInfo
(
nsprPath
&
mFileInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mFileInfo
.
type
!
=
PR_FILE_OTHER
)
{
mResolveDirty
=
false
;
mDirty
=
false
;
return
NS_OK
;
}
rv
=
ResolveSymlink
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
mResolvedPath
.
Assign
(
mWorkingPath
)
;
return
rv
;
}
mResolveDirty
=
false
;
rv
=
GetFileInfo
(
mResolvedPath
&
mFileInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mDirty
=
false
;
return
NS_OK
;
}
nsresult
nsLocalFile
:
:
Resolve
(
)
{
if
(
!
mResolveDirty
)
{
return
NS_OK
;
}
if
(
mWorkingPath
.
IsEmpty
(
)
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
mResolvedPath
.
Assign
(
mWorkingPath
)
;
mResolveDirty
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Clone
(
nsIFile
*
*
aFile
)
{
RefPtr
<
nsLocalFile
>
file
=
new
nsLocalFile
(
*
this
)
;
file
.
forget
(
aFile
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
InitWithFile
(
nsIFile
*
aFile
)
{
if
(
NS_WARN_IF
(
!
aFile
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoString
path
;
aFile
-
>
GetPath
(
path
)
;
if
(
path
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
InitWithPath
(
path
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
InitWithPath
(
const
nsAString
&
aFilePath
)
{
MakeDirty
(
)
;
nsAString
:
:
const_iterator
begin
end
;
aFilePath
.
BeginReading
(
begin
)
;
aFilePath
.
EndReading
(
end
)
;
if
(
begin
=
=
end
)
{
return
NS_ERROR_FAILURE
;
}
char16_t
firstChar
=
*
begin
;
char16_t
secondChar
=
*
(
+
+
begin
)
;
if
(
FindCharInReadable
(
L
'
/
'
begin
end
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
if
(
FilePreferences
:
:
IsBlockedUNCPath
(
aFilePath
)
)
{
return
NS_ERROR_FILE_ACCESS_DENIED
;
}
if
(
secondChar
!
=
L
'
:
'
&
&
(
secondChar
!
=
L
'
\
\
'
|
|
firstChar
!
=
L
'
\
\
'
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
if
(
secondChar
=
=
L
'
:
'
)
{
if
(
MozPathGetDriveNumber
<
wchar_t
>
(
aFilePath
.
Data
(
)
)
=
=
-
1
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
}
if
(
IsSpecialNTFSPath
(
aFilePath
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
mWorkingPath
=
aFilePath
;
if
(
mWorkingPath
.
Last
(
)
=
=
L
'
\
\
'
)
{
mWorkingPath
.
Truncate
(
mWorkingPath
.
Length
(
)
-
1
)
;
}
if
(
mUseDOSDevicePathSyntax
&
&
FilePreferences
:
:
StartsWithDiskDesignatorAndBackslash
(
mWorkingPath
)
)
{
mWorkingPath
=
kDevicePathSpecifier
+
mWorkingPath
;
}
return
NS_OK
;
}
static
void
CleanupHandlerPath
(
nsString
&
aPath
)
{
int32_t
lastCommaPos
=
aPath
.
RFindChar
(
'
'
)
;
if
(
lastCommaPos
!
=
kNotFound
)
aPath
.
Truncate
(
lastCommaPos
)
;
aPath
.
Append
(
'
'
)
;
int32_t
index
=
aPath
.
LowerCaseFindASCII
(
"
.
exe
"
)
;
if
(
index
=
=
kNotFound
)
index
=
aPath
.
LowerCaseFindASCII
(
"
.
dll
"
)
;
if
(
index
=
=
kNotFound
)
index
=
aPath
.
LowerCaseFindASCII
(
"
.
cpl
"
)
;
if
(
index
!
=
kNotFound
)
aPath
.
Truncate
(
index
+
4
)
;
aPath
.
Trim
(
"
"
true
true
)
;
}
static
void
StripRundll32
(
nsString
&
aCommandString
)
{
constexpr
auto
rundllSegment
=
"
rundll32
.
exe
"
_ns
;
constexpr
auto
rundllSegmentShort
=
"
rundll32
"
_ns
;
int32_t
strLen
=
rundllSegment
.
Length
(
)
;
int32_t
index
=
aCommandString
.
LowerCaseFindASCII
(
rundllSegment
)
;
if
(
index
=
=
kNotFound
)
{
strLen
=
rundllSegmentShort
.
Length
(
)
;
index
=
aCommandString
.
LowerCaseFindASCII
(
rundllSegmentShort
)
;
}
if
(
index
!
=
kNotFound
)
{
uint32_t
rundllSegmentLength
=
index
+
strLen
;
aCommandString
.
Cut
(
0
rundllSegmentLength
)
;
}
}
bool
nsLocalFile
:
:
CleanupCmdHandlerPath
(
nsAString
&
aCommandHandler
)
{
nsAutoString
handlerCommand
(
aCommandHandler
)
;
uint32_t
bufLength
=
:
:
ExpandEnvironmentStringsW
(
handlerCommand
.
get
(
)
nullptr
0
)
;
if
(
bufLength
=
=
0
)
return
false
;
auto
destination
=
mozilla
:
:
MakeUniqueFallible
<
wchar_t
[
]
>
(
bufLength
)
;
if
(
!
destination
)
return
false
;
if
(
!
:
:
ExpandEnvironmentStringsW
(
handlerCommand
.
get
(
)
destination
.
get
(
)
bufLength
)
)
return
false
;
handlerCommand
.
Assign
(
destination
.
get
(
)
)
;
handlerCommand
.
StripChars
(
u
"
\
"
"
)
;
StripRundll32
(
handlerCommand
)
;
CleanupHandlerPath
(
handlerCommand
)
;
aCommandHandler
.
Assign
(
handlerCommand
)
;
return
true
;
}
NS_IMETHODIMP
nsLocalFile
:
:
InitWithCommandLine
(
const
nsAString
&
aCommandLine
)
{
nsAutoString
commandLine
(
aCommandLine
)
;
if
(
!
CleanupCmdHandlerPath
(
commandLine
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
return
InitWithPath
(
commandLine
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
OpenNSPRFileDesc
(
int32_t
aFlags
int32_t
aMode
PRFileDesc
*
*
aResult
)
{
nsresult
rv
=
OpenNSPRFileDescMaybeShareDelete
(
aFlags
aMode
false
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
OpenANSIFileDesc
(
const
char
*
aMode
FILE
*
*
aResult
)
{
*
aResult
=
_wfopen
(
mWorkingPath
.
get
(
)
NS_ConvertASCIItoUTF16
(
aMode
)
.
get
(
)
)
;
if
(
*
aResult
)
{
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
static
nsresult
do_create
(
nsIFile
*
aFile
const
nsString
&
aPath
uint32_t
aAttributes
)
{
PRFileDesc
*
file
;
nsresult
rv
=
OpenFile
(
aPath
PR_RDONLY
|
PR_CREATE_FILE
|
PR_APPEND
|
PR_EXCL
aAttributes
false
&
file
)
;
if
(
file
)
{
PR_Close
(
file
)
;
}
if
(
rv
=
=
NS_ERROR_FILE_ACCESS_DENIED
)
{
bool
isdir
;
if
(
NS_SUCCEEDED
(
aFile
-
>
IsDirectory
(
&
isdir
)
)
&
&
isdir
)
{
rv
=
NS_ERROR_FILE_ALREADY_EXISTS
;
}
}
return
rv
;
}
static
nsresult
do_mkdir
(
nsIFile
*
const
nsString
&
aPath
uint32_t
)
{
if
(
!
:
:
CreateDirectoryW
(
aPath
.
get
(
)
nullptr
)
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Create
(
uint32_t
aType
uint32_t
aAttributes
bool
aSkipAncestors
)
{
if
(
aType
!
=
NORMAL_FILE_TYPE
&
&
aType
!
=
DIRECTORY_TYPE
)
{
return
NS_ERROR_FILE_UNKNOWN_TYPE
;
}
auto
*
createFunc
=
(
aType
=
=
NORMAL_FILE_TYPE
?
do_create
:
do_mkdir
)
;
nsresult
rv
=
createFunc
(
this
mWorkingPath
aAttributes
)
;
if
(
NS_SUCCEEDED
(
rv
)
|
|
NS_ERROR_FILE_ALREADY_EXISTS
=
=
rv
|
|
aSkipAncestors
)
{
return
rv
;
}
wchar_t
*
path
=
char16ptr_t
(
mWorkingPath
.
BeginWriting
(
)
)
;
if
(
path
[
0
]
=
=
L
'
\
\
'
&
&
path
[
1
]
=
=
L
'
\
\
'
)
{
path
=
wcschr
(
path
+
2
L
'
\
\
'
)
;
if
(
!
path
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
+
+
path
;
}
wchar_t
*
slash
=
wcschr
(
path
L
'
\
\
'
)
;
nsresult
directoryCreateError
=
NS_OK
;
if
(
slash
)
{
+
+
slash
;
slash
=
wcschr
(
slash
L
'
\
\
'
)
;
while
(
slash
)
{
*
slash
=
L
'
\
0
'
;
if
(
!
:
:
CreateDirectoryW
(
mWorkingPath
.
get
(
)
nullptr
)
)
{
rv
=
ConvertWinError
(
GetLastError
(
)
)
;
if
(
NS_ERROR_FILE_NOT_FOUND
=
=
rv
&
&
NS_ERROR_FILE_ACCESS_DENIED
=
=
directoryCreateError
)
{
return
NS_ERROR_FILE_ACCESS_DENIED
;
}
else
if
(
rv
!
=
NS_ERROR_FILE_ALREADY_EXISTS
&
&
rv
!
=
NS_ERROR_FILE_ACCESS_DENIED
)
{
return
rv
;
}
directoryCreateError
=
rv
;
}
*
slash
=
L
'
\
\
'
;
+
+
slash
;
slash
=
wcschr
(
slash
L
'
\
\
'
)
;
}
}
if
(
NS_ERROR_FILE_ACCESS_DENIED
=
=
directoryCreateError
)
{
return
directoryCreateError
;
}
return
createFunc
(
this
mWorkingPath
aAttributes
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Append
(
const
nsAString
&
aNode
)
{
return
AppendInternal
(
PromiseFlatString
(
aNode
)
false
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
AppendRelativePath
(
const
nsAString
&
aNode
)
{
return
AppendInternal
(
PromiseFlatString
(
aNode
)
true
)
;
}
nsresult
nsLocalFile
:
:
AppendInternal
(
const
nsString
&
aNode
bool
aMultipleComponents
)
{
if
(
aNode
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
aNode
.
First
(
)
=
=
L
'
\
\
'
|
|
aNode
.
Contains
(
L
'
/
'
)
|
|
aNode
.
EqualsASCII
(
"
.
.
"
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
if
(
aMultipleComponents
)
{
constexpr
auto
doubleDot
=
u
"
\
\
.
.
"
_ns
;
nsAString
:
:
const_iterator
start
end
offset
;
aNode
.
BeginReading
(
start
)
;
aNode
.
EndReading
(
end
)
;
offset
=
end
;
while
(
FindInReadable
(
doubleDot
start
offset
)
)
{
if
(
offset
=
=
end
|
|
*
offset
=
=
L
'
\
\
'
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
start
=
offset
;
offset
=
end
;
}
if
(
StringBeginsWith
(
aNode
u
"
.
.
\
\
"
_ns
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
}
else
if
(
aNode
.
Contains
(
L
'
\
\
'
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
MakeDirty
(
)
;
mWorkingPath
.
Append
(
'
\
\
'
)
;
mWorkingPath
.
Append
(
aNode
)
;
if
(
IsSpecialNTFSPath
(
mWorkingPath
)
)
{
mWorkingPath
.
SetLength
(
mWorkingPath
.
Length
(
)
-
aNode
.
Length
(
)
-
1
)
;
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
return
NS_OK
;
}
nsresult
nsLocalFile
:
:
OpenNSPRFileDescMaybeShareDelete
(
int32_t
aFlags
int32_t
aMode
bool
aShareDelete
PRFileDesc
*
*
aResult
)
{
return
OpenFile
(
mWorkingPath
aFlags
aMode
aShareDelete
aResult
)
;
}
#
define
TOUPPER
(
u
)
(
(
(
u
)
>
=
L
'
a
'
&
&
(
u
)
<
=
L
'
z
'
)
?
(
u
)
-
(
L
'
a
'
-
L
'
A
'
)
:
(
u
)
)
NS_IMETHODIMP
nsLocalFile
:
:
Normalize
(
)
{
if
(
mWorkingPath
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
nsAutoString
path
(
mWorkingPath
)
;
int32_t
rootIdx
=
2
;
if
(
path
.
First
(
)
=
=
L
'
\
\
'
)
{
rootIdx
=
path
.
FindChar
(
L
'
\
\
'
2
)
;
if
(
rootIdx
=
=
kNotFound
)
{
return
NS_OK
;
}
rootIdx
=
path
.
FindChar
(
L
'
\
\
'
rootIdx
+
1
)
;
if
(
rootIdx
=
=
kNotFound
)
{
return
NS_OK
;
}
}
else
if
(
path
.
CharAt
(
rootIdx
)
!
=
L
'
\
\
'
)
{
WCHAR
cwd
[
MAX_PATH
]
;
WCHAR
*
pcwd
=
cwd
;
int
drive
=
TOUPPER
(
path
.
First
(
)
)
-
'
A
'
+
1
;
if
(
!
(
(
1
<
<
(
drive
-
1
)
)
&
_getdrives
(
)
)
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
if
(
!
_wgetdcwd
(
drive
pcwd
MAX_PATH
)
)
{
pcwd
=
_wgetdcwd
(
drive
0
0
)
;
}
if
(
!
pcwd
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsAutoString
currentDir
(
pcwd
)
;
if
(
pcwd
!
=
cwd
)
{
free
(
pcwd
)
;
}
if
(
currentDir
.
Last
(
)
=
=
'
\
\
'
)
{
path
.
Replace
(
0
2
currentDir
)
;
}
else
{
path
.
Replace
(
0
2
currentDir
+
u
"
\
\
"
_ns
)
;
}
}
MOZ_ASSERT
(
0
<
rootIdx
&
&
rootIdx
<
(
int32_t
)
path
.
Length
(
)
"
rootIdx
is
invalid
"
)
;
MOZ_ASSERT
(
path
.
CharAt
(
rootIdx
)
=
=
'
\
\
'
"
rootIdx
is
invalid
"
)
;
if
(
rootIdx
+
1
=
=
(
int32_t
)
path
.
Length
(
)
)
{
return
NS_OK
;
}
const
char16_t
*
pathBuffer
=
path
.
get
(
)
;
mWorkingPath
.
SetCapacity
(
path
.
Length
(
)
)
;
mWorkingPath
.
Assign
(
pathBuffer
rootIdx
)
;
int32_t
len
begin
end
=
rootIdx
;
while
(
end
<
(
int32_t
)
path
.
Length
(
)
)
{
begin
=
end
+
1
;
end
=
path
.
FindChar
(
'
\
\
'
begin
)
;
if
(
end
=
=
kNotFound
)
{
end
=
path
.
Length
(
)
;
}
len
=
end
-
begin
;
if
(
len
=
=
0
)
{
continue
;
}
if
(
pathBuffer
[
begin
]
=
=
'
.
'
)
{
if
(
len
=
=
1
)
{
continue
;
}
if
(
len
>
=
2
&
&
pathBuffer
[
begin
+
1
]
=
=
L
'
.
'
)
{
if
(
len
=
=
2
)
{
int32_t
prev
=
mWorkingPath
.
RFindChar
(
'
\
\
'
)
;
if
(
prev
>
=
rootIdx
)
{
mWorkingPath
.
Truncate
(
prev
)
;
}
continue
;
}
int
idx
=
len
-
1
;
for
(
;
idx
>
=
2
;
-
-
idx
)
{
if
(
pathBuffer
[
begin
+
idx
]
!
=
L
'
.
'
)
{
break
;
}
}
if
(
idx
<
2
)
{
continue
;
}
}
}
mWorkingPath
.
Append
(
pathBuffer
+
begin
-
1
len
+
1
)
;
}
int32_t
filePathLen
=
mWorkingPath
.
Length
(
)
-
1
;
while
(
filePathLen
>
0
&
&
(
mWorkingPath
[
filePathLen
]
=
=
L
'
'
|
|
mWorkingPath
[
filePathLen
]
=
=
L
'
.
'
)
)
{
mWorkingPath
.
Truncate
(
filePathLen
-
-
)
;
}
MakeDirty
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetLeafName
(
nsAString
&
aLeafName
)
{
aLeafName
.
Truncate
(
)
;
if
(
mWorkingPath
.
IsEmpty
(
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
int32_t
offset
=
mWorkingPath
.
RFindChar
(
L
'
\
\
'
)
;
if
(
offset
=
=
kNotFound
)
{
aLeafName
=
mWorkingPath
;
}
else
{
aLeafName
=
Substring
(
mWorkingPath
offset
+
1
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetLeafName
(
const
nsAString
&
aLeafName
)
{
MakeDirty
(
)
;
if
(
mWorkingPath
.
IsEmpty
(
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
int32_t
offset
=
mWorkingPath
.
RFindChar
(
L
'
\
\
'
)
;
nsString
newDir
;
if
(
offset
)
{
newDir
=
Substring
(
mWorkingPath
0
offset
+
1
)
+
aLeafName
;
}
else
{
newDir
=
mWorkingPath
+
aLeafName
;
}
if
(
IsSpecialNTFSPath
(
newDir
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
mWorkingPath
.
Assign
(
newDir
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetDisplayName
(
nsAString
&
aLeafName
)
{
aLeafName
.
Truncate
(
)
;
if
(
mWorkingPath
.
IsEmpty
(
)
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
SHFILEINFOW
sfi
=
{
}
;
DWORD_PTR
result
=
:
:
SHGetFileInfoW
(
mWorkingPath
.
get
(
)
0
&
sfi
sizeof
(
sfi
)
SHGFI_DISPLAYNAME
)
;
if
(
result
)
{
aLeafName
.
Assign
(
sfi
.
szDisplayName
)
;
return
NS_OK
;
}
return
GetLeafName
(
aLeafName
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetPath
(
nsAString
&
aResult
)
{
MOZ_ASSERT_IF
(
mUseDOSDevicePathSyntax
!
FilePreferences
:
:
StartsWithDiskDesignatorAndBackslash
(
mWorkingPath
)
)
;
aResult
=
mWorkingPath
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetCanonicalPath
(
nsAString
&
aResult
)
{
EnsureShortPath
(
)
;
aResult
.
Assign
(
mShortWorkingPath
)
;
return
NS_OK
;
}
typedef
struct
{
WORD
wLanguage
;
WORD
wCodePage
;
}
LANGANDCODEPAGE
;
NS_IMETHODIMP
nsLocalFile
:
:
GetVersionInfoField
(
const
char
*
aField
nsAString
&
aResult
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
const
WCHAR
*
path
=
mWorkingPath
.
get
(
)
;
DWORD
dummy
;
DWORD
size
=
:
:
GetFileVersionInfoSizeW
(
path
&
dummy
)
;
if
(
!
size
)
{
return
rv
;
}
void
*
ver
=
moz_xcalloc
(
size
1
)
;
if
(
:
:
GetFileVersionInfoW
(
path
0
size
ver
)
)
{
LANGANDCODEPAGE
*
translate
=
nullptr
;
UINT
pageCount
;
BOOL
queryResult
=
:
:
VerQueryValueW
(
ver
L
"
\
\
VarFileInfo
\
\
Translation
"
(
void
*
*
)
&
translate
&
pageCount
)
;
if
(
queryResult
&
&
translate
)
{
for
(
int32_t
i
=
0
;
i
<
2
;
+
+
i
)
{
wchar_t
subBlock
[
MAX_PATH
]
;
_snwprintf
(
subBlock
MAX_PATH
L
"
\
\
StringFileInfo
\
\
%
04x
%
04x
\
\
%
S
"
(
i
=
=
0
?
translate
[
0
]
.
wLanguage
:
:
:
GetUserDefaultLangID
(
)
)
translate
[
0
]
.
wCodePage
aField
)
;
subBlock
[
MAX_PATH
-
1
]
=
0
;
LPVOID
value
=
nullptr
;
UINT
size
;
queryResult
=
:
:
VerQueryValueW
(
ver
subBlock
&
value
&
size
)
;
if
(
queryResult
&
&
value
)
{
aResult
.
Assign
(
static_cast
<
char16_t
*
>
(
value
)
)
;
if
(
!
aResult
.
IsEmpty
(
)
)
{
rv
=
NS_OK
;
break
;
}
}
}
}
}
free
(
ver
)
;
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
OpenNSPRFileDescShareDelete
(
int32_t
aFlags
int32_t
aMode
PRFileDesc
*
*
aResult
)
{
nsresult
rv
=
OpenNSPRFileDescMaybeShareDelete
(
aFlags
aMode
true
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
static
bool
IsRemoteFilePath
(
LPCWSTR
aPath
bool
&
aRemote
)
{
WCHAR
dirPath
[
MAX_PATH
+
1
]
=
{
0
}
;
wcsncpy
(
dirPath
aPath
MAX_PATH
)
;
if
(
!
PathRemoveFileSpecW
(
dirPath
)
)
{
return
false
;
}
size_t
len
=
wcslen
(
dirPath
)
;
if
(
len
>
=
MAX_PATH
)
{
return
false
;
}
dirPath
[
len
]
=
L
'
\
\
'
;
dirPath
[
len
+
1
]
=
L
'
\
0
'
;
UINT
driveType
=
GetDriveTypeW
(
dirPath
)
;
aRemote
=
driveType
=
=
DRIVE_REMOTE
;
return
true
;
}
nsresult
nsLocalFile
:
:
CopySingleFile
(
nsIFile
*
aSourceFile
nsIFile
*
aDestParent
const
nsAString
&
aNewName
uint32_t
aOptions
)
{
nsresult
rv
=
NS_OK
;
nsAutoString
filePath
;
bool
move
=
aOptions
&
(
Move
|
Rename
)
;
nsAutoString
destPath
;
rv
=
aDestParent
-
>
GetTarget
(
destPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
destPath
.
Append
(
'
\
\
'
)
;
if
(
aNewName
.
IsEmpty
(
)
)
{
nsAutoString
aFileName
;
aSourceFile
-
>
GetLeafName
(
aFileName
)
;
destPath
.
Append
(
aFileName
)
;
}
else
{
destPath
.
Append
(
aNewName
)
;
}
if
(
aOptions
&
FollowSymlinks
)
{
rv
=
aSourceFile
-
>
GetTarget
(
filePath
)
;
if
(
filePath
.
IsEmpty
(
)
)
{
rv
=
aSourceFile
-
>
GetPath
(
filePath
)
;
}
}
else
{
rv
=
aSourceFile
-
>
GetPath
(
filePath
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
#
ifdef
DEBUG
nsCOMPtr
<
nsILocalFileWin
>
srcWinFile
=
do_QueryInterface
(
aSourceFile
)
;
MOZ_ASSERT
(
srcWinFile
)
;
bool
srcUseDOSDevicePathSyntax
;
srcWinFile
-
>
GetUseDOSDevicePathSyntax
(
&
srcUseDOSDevicePathSyntax
)
;
nsCOMPtr
<
nsILocalFileWin
>
destWinFile
=
do_QueryInterface
(
aDestParent
)
;
MOZ_ASSERT
(
destWinFile
)
;
bool
destUseDOSDevicePathSyntax
;
destWinFile
-
>
GetUseDOSDevicePathSyntax
(
&
destUseDOSDevicePathSyntax
)
;
MOZ_ASSERT
(
srcUseDOSDevicePathSyntax
=
=
destUseDOSDevicePathSyntax
"
Copy
or
Move
files
with
different
values
for
"
"
useDOSDevicePathSyntax
would
fail
"
)
;
#
endif
if
(
FilePreferences
:
:
IsBlockedUNCPath
(
destPath
)
)
{
return
NS_ERROR_FILE_ACCESS_DENIED
;
}
int
copyOK
=
0
;
if
(
move
)
{
copyOK
=
:
:
MoveFileExW
(
filePath
.
get
(
)
destPath
.
get
(
)
MOVEFILE_REPLACE_EXISTING
)
;
}
if
(
!
copyOK
&
&
(
!
move
|
|
GetLastError
(
)
=
=
ERROR_NOT_SAME_DEVICE
)
)
{
if
(
move
&
&
(
aOptions
&
Rename
)
)
{
return
NS_ERROR_FILE_ACCESS_DENIED
;
}
DWORD
dwCopyFlags
=
COPY_FILE_ALLOW_DECRYPTED_DESTINATION
;
bool
path1Remote
path2Remote
;
if
(
!
IsRemoteFilePath
(
filePath
.
get
(
)
path1Remote
)
|
|
!
IsRemoteFilePath
(
destPath
.
get
(
)
path2Remote
)
|
|
path1Remote
|
|
path2Remote
)
{
dwCopyFlags
|
=
COPY_FILE_NO_BUFFERING
;
}
copyOK
=
:
:
CopyFileExW
(
filePath
.
get
(
)
destPath
.
get
(
)
nullptr
nullptr
nullptr
dwCopyFlags
)
;
if
(
!
copyOK
&
&
(
dwCopyFlags
&
COPY_FILE_NO_BUFFERING
)
&
&
GetLastError
(
)
=
=
ERROR_INVALID_PARAMETER
)
{
dwCopyFlags
&
=
~
COPY_FILE_NO_BUFFERING
;
copyOK
=
:
:
CopyFileExW
(
filePath
.
get
(
)
destPath
.
get
(
)
nullptr
nullptr
nullptr
dwCopyFlags
)
;
}
if
(
move
&
&
copyOK
)
{
DeleteFileW
(
filePath
.
get
(
)
)
;
}
}
if
(
!
copyOK
)
{
rv
=
ConvertWinError
(
GetLastError
(
)
)
;
}
else
if
(
move
&
&
!
(
aOptions
&
SkipNtfsAclReset
)
)
{
PACL
pOldDACL
=
nullptr
;
PSECURITY_DESCRIPTOR
pSD
=
nullptr
;
:
:
GetNamedSecurityInfoW
(
(
LPWSTR
)
destPath
.
get
(
)
SE_FILE_OBJECT
DACL_SECURITY_INFORMATION
nullptr
nullptr
&
pOldDACL
nullptr
&
pSD
)
;
if
(
pOldDACL
)
:
:
SetNamedSecurityInfoW
(
(
LPWSTR
)
destPath
.
get
(
)
SE_FILE_OBJECT
DACL_SECURITY_INFORMATION
|
UNPROTECTED_DACL_SECURITY_INFORMATION
nullptr
nullptr
pOldDACL
nullptr
)
;
if
(
pSD
)
{
LocalFree
(
(
HLOCAL
)
pSD
)
;
}
}
return
rv
;
}
nsresult
nsLocalFile
:
:
CopyMove
(
nsIFile
*
aParentDir
const
nsAString
&
aNewName
uint32_t
aOptions
)
{
bool
move
=
aOptions
&
(
Move
|
Rename
)
;
bool
followSymlinks
=
aOptions
&
FollowSymlinks
;
bool
targetInSameDirectory
=
!
aParentDir
;
nsCOMPtr
<
nsIFile
>
newParentDir
=
aParentDir
;
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
newParentDir
)
{
if
(
aNewName
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
rv
=
GetParent
(
getter_AddRefs
(
newParentDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
!
newParentDir
)
{
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
if
(
!
targetInSameDirectory
)
{
bool
exists
=
false
;
rv
=
newParentDir
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
exists
)
{
rv
=
newParentDir
-
>
Create
(
DIRECTORY_TYPE
0644
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
{
bool
isDir
=
false
;
rv
=
newParentDir
-
>
IsDirectory
(
&
isDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
isDir
)
{
if
(
followSymlinks
)
{
bool
isLink
=
false
;
rv
=
newParentDir
-
>
IsSymlink
(
&
isLink
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
isLink
)
{
nsAutoString
target
;
rv
=
newParentDir
-
>
GetTarget
(
target
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
realDest
=
new
nsLocalFile
(
)
;
rv
=
realDest
-
>
InitWithPath
(
target
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
CopyMove
(
realDest
aNewName
aOptions
)
;
}
}
else
{
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
}
}
}
bool
done
=
false
;
bool
isDir
=
false
;
rv
=
IsDirectory
(
&
isDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
isSymlink
=
false
;
rv
=
IsSymlink
(
&
isSymlink
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
move
|
|
!
isDir
|
|
(
isSymlink
&
&
!
followSymlinks
)
)
{
if
(
!
aParentDir
)
{
aOptions
|
=
SkipNtfsAclReset
;
}
rv
=
CopySingleFile
(
this
newParentDir
aNewName
aOptions
)
;
done
=
NS_SUCCEEDED
(
rv
)
;
if
(
!
done
&
&
!
(
move
&
&
isDir
)
)
{
return
rv
;
}
}
if
(
!
done
)
{
nsCOMPtr
<
nsIFile
>
target
;
rv
=
newParentDir
-
>
Clone
(
getter_AddRefs
(
target
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoString
allocatedNewName
;
if
(
aNewName
.
IsEmpty
(
)
)
{
bool
isLink
=
false
;
rv
=
IsSymlink
(
&
isLink
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
isLink
)
{
nsAutoString
temp
;
rv
=
GetTarget
(
temp
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
int32_t
offset
=
temp
.
RFindChar
(
L
'
\
\
'
)
;
if
(
offset
=
=
kNotFound
)
{
allocatedNewName
=
temp
;
}
else
{
allocatedNewName
=
Substring
(
temp
offset
+
1
)
;
}
}
else
{
GetLeafName
(
allocatedNewName
)
;
}
}
else
{
allocatedNewName
=
aNewName
;
}
rv
=
target
-
>
Append
(
allocatedNewName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
allocatedNewName
.
Truncate
(
)
;
bool
exists
=
false
;
rv
=
target
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
exists
)
{
rv
=
target
-
>
Create
(
DIRECTORY_TYPE
0644
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
{
bool
isWritable
=
false
;
rv
=
target
-
>
IsWritable
(
&
isWritable
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
isWritable
)
{
return
NS_ERROR_FILE_ACCESS_DENIED
;
}
nsCOMPtr
<
nsIDirectoryEnumerator
>
targetIterator
;
rv
=
target
-
>
GetDirectoryEntries
(
getter_AddRefs
(
targetIterator
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
more
;
targetIterator
-
>
HasMoreElements
(
&
more
)
;
if
(
more
)
{
return
NS_ERROR_FILE_DIR_NOT_EMPTY
;
}
}
RefPtr
<
nsDirEnumerator
>
dirEnum
=
new
nsDirEnumerator
(
)
;
rv
=
dirEnum
-
>
Init
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
dirEnum
initialization
failed
"
)
;
return
rv
;
}
nsCOMPtr
<
nsIFile
>
file
;
while
(
NS_SUCCEEDED
(
dirEnum
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
)
&
&
file
)
{
bool
isDir
=
false
;
rv
=
file
-
>
IsDirectory
(
&
isDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
isLink
=
false
;
rv
=
file
-
>
IsSymlink
(
&
isLink
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
move
)
{
if
(
followSymlinks
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
file
-
>
MoveTo
(
target
u
"
"
_ns
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
{
if
(
followSymlinks
)
{
rv
=
file
-
>
CopyToFollowingLinks
(
target
u
"
"
_ns
)
;
}
else
{
rv
=
file
-
>
CopyTo
(
target
u
"
"
_ns
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
}
if
(
move
)
{
rv
=
Remove
(
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
}
if
(
move
)
{
MakeDirty
(
)
;
nsAutoString
newParentPath
;
newParentDir
-
>
GetPath
(
newParentPath
)
;
if
(
newParentPath
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aNewName
.
IsEmpty
(
)
)
{
nsAutoString
aFileName
;
GetLeafName
(
aFileName
)
;
InitWithPath
(
newParentPath
)
;
Append
(
aFileName
)
;
}
else
{
InitWithPath
(
newParentPath
)
;
Append
(
aNewName
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
CopyTo
(
nsIFile
*
aNewParentDir
const
nsAString
&
aNewName
)
{
return
CopyMove
(
aNewParentDir
aNewName
0
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
CopyToFollowingLinks
(
nsIFile
*
aNewParentDir
const
nsAString
&
aNewName
)
{
return
CopyMove
(
aNewParentDir
aNewName
FollowSymlinks
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
MoveTo
(
nsIFile
*
aNewParentDir
const
nsAString
&
aNewName
)
{
return
CopyMove
(
aNewParentDir
aNewName
Move
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
MoveToFollowingLinks
(
nsIFile
*
aNewParentDir
const
nsAString
&
aNewName
)
{
return
CopyMove
(
aNewParentDir
aNewName
Move
|
FollowSymlinks
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
RenameTo
(
nsIFile
*
aNewParentDir
const
nsAString
&
aNewName
)
{
bool
targetInSameDirectory
=
!
aNewParentDir
;
nsCOMPtr
<
nsIFile
>
targetParentDir
=
aNewParentDir
;
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
targetParentDir
)
{
if
(
aNewName
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
rv
=
GetParent
(
getter_AddRefs
(
targetParentDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
!
targetParentDir
)
{
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
if
(
!
targetInSameDirectory
)
{
bool
exists
=
false
;
rv
=
targetParentDir
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
exists
)
{
rv
=
targetParentDir
-
>
Create
(
DIRECTORY_TYPE
0644
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
{
bool
isDir
=
false
;
rv
=
targetParentDir
-
>
IsDirectory
(
&
isDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
isDir
)
{
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
}
}
uint32_t
options
=
Rename
;
if
(
!
aNewParentDir
)
{
options
|
=
SkipNtfsAclReset
;
}
return
CopySingleFile
(
this
targetParentDir
aNewName
options
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
RenameToNative
(
nsIFile
*
aNewParentDir
const
nsACString
&
aNewName
)
{
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aNewName
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
RenameTo
(
aNewParentDir
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Load
(
PRLibrary
*
*
aResult
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsTraceRefcnt
:
:
SetActivityIsLegal
(
false
)
;
#
endif
PRLibSpec
libSpec
;
libSpec
.
value
.
pathname_u
=
mWorkingPath
.
get
(
)
;
libSpec
.
type
=
PR_LibSpec_PathnameU
;
*
aResult
=
PR_LoadLibraryWithFlags
(
libSpec
0
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsTraceRefcnt
:
:
SetActivityIsLegal
(
true
)
;
#
endif
if
(
*
aResult
)
{
return
NS_OK
;
}
return
NS_ERROR_NULL_POINTER
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Remove
(
bool
aRecursive
uint32_t
*
aRemoveCount
)
{
CHECK_mWorkingPath
(
)
;
nsresult
rv
=
NS_OK
;
bool
isLink
=
false
;
rv
=
IsSymlink
(
&
isLink
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
isDir
=
false
;
if
(
!
isLink
)
{
rv
=
IsDirectory
(
&
isDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
isDir
)
{
if
(
aRecursive
)
{
RefPtr
<
nsDirEnumerator
>
dirEnum
=
new
nsDirEnumerator
(
)
;
rv
=
dirEnum
-
>
Init
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
file
;
while
(
NS_SUCCEEDED
(
dirEnum
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
)
&
&
file
)
{
file
-
>
Remove
(
aRecursive
aRemoveCount
)
;
}
}
if
(
RemoveDirectoryW
(
mWorkingPath
.
get
(
)
)
=
=
0
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
}
else
{
if
(
DeleteFileW
(
mWorkingPath
.
get
(
)
)
=
=
0
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
}
if
(
aRemoveCount
)
{
*
aRemoveCount
+
=
1
;
}
MakeDirty
(
)
;
return
rv
;
}
nsresult
nsLocalFile
:
:
GetDateImpl
(
PRTime
*
aTime
nsLocalFile
:
:
TimeField
aTimeField
bool
aFollowLinks
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aTime
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
FileInfo
symlinkInfo
{
}
;
FileInfo
*
pInfo
;
if
(
aFollowLinks
)
{
if
(
nsresult
rv
=
GetFileInfo
(
mWorkingPath
&
symlinkInfo
)
;
NS_FAILED
(
rv
)
)
{
return
rv
;
}
pInfo
=
&
symlinkInfo
;
}
else
{
if
(
nsresult
rv
=
ResolveAndStat
(
)
;
NS_FAILED
(
rv
)
)
{
return
rv
;
}
pInfo
=
&
mFileInfo
;
}
switch
(
aTimeField
)
{
case
TimeField
:
:
AccessedTime
:
*
aTime
=
pInfo
-
>
accessTime
/
PR_USEC_PER_MSEC
;
break
;
case
TimeField
:
:
ModifiedTime
:
*
aTime
=
pInfo
-
>
modifyTime
/
PR_USEC_PER_MSEC
;
break
;
default
:
MOZ_CRASH
(
"
Unknown
time
field
"
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetLastAccessedTime
(
PRTime
*
aLastAccessedTime
)
{
return
GetDateImpl
(
aLastAccessedTime
TimeField
:
:
AccessedTime
true
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetLastAccessedTimeOfLink
(
PRTime
*
aLastAccessedTime
)
{
return
GetDateImpl
(
aLastAccessedTime
TimeField
:
:
AccessedTime
false
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetLastAccessedTime
(
PRTime
aLastAccessedTime
)
{
return
SetDateImpl
(
aLastAccessedTime
TimeField
:
:
AccessedTime
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetLastAccessedTimeOfLink
(
PRTime
aLastAccessedTime
)
{
return
SetLastAccessedTime
(
aLastAccessedTime
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetLastModifiedTime
(
PRTime
*
aLastModifiedTime
)
{
return
GetDateImpl
(
aLastModifiedTime
TimeField
:
:
ModifiedTime
true
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetLastModifiedTimeOfLink
(
PRTime
*
aLastModifiedTime
)
{
return
GetDateImpl
(
aLastModifiedTime
TimeField
:
:
ModifiedTime
false
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetLastModifiedTime
(
PRTime
aLastModifiedTime
)
{
return
SetDateImpl
(
aLastModifiedTime
TimeField
:
:
ModifiedTime
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetLastModifiedTimeOfLink
(
PRTime
aLastModifiedTime
)
{
return
SetLastModifiedTime
(
aLastModifiedTime
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetCreationTime
(
PRTime
*
aCreationTime
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aCreationTime
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
ResolveAndStat
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aCreationTime
=
mFileInfo
.
creationTime
/
PR_USEC_PER_MSEC
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetCreationTimeOfLink
(
PRTime
*
aCreationTime
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aCreationTime
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
FileInfo
info
;
nsresult
rv
=
GetFileInfo
(
mWorkingPath
&
info
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aCreationTime
=
info
.
creationTime
/
PR_USEC_PER_MSEC
;
return
NS_OK
;
}
nsresult
nsLocalFile
:
:
SetDateImpl
(
PRTime
aTime
nsLocalFile
:
:
TimeField
aTimeField
)
{
CHECK_mWorkingPath
(
)
;
HANDLE
file
=
:
:
CreateFileW
(
mWorkingPath
.
get
(
)
GENERIC_WRITE
0
nullptr
OPEN_EXISTING
FILE_FLAG_BACKUP_SEMANTICS
nullptr
)
;
if
(
file
=
=
INVALID_HANDLE_VALUE
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
FILETIME
ft
;
SYSTEMTIME
st
;
PRExplodedTime
pret
;
if
(
aTime
=
=
0
)
{
aTime
=
PR_Now
(
)
/
PR_USEC_PER_MSEC
;
}
PR_ExplodeTime
(
aTime
*
PR_USEC_PER_MSEC
PR_GMTParameters
&
pret
)
;
st
.
wYear
=
pret
.
tm_year
;
st
.
wMonth
=
pret
.
tm_month
+
1
;
st
.
wDayOfWeek
=
pret
.
tm_wday
;
st
.
wDay
=
pret
.
tm_mday
;
st
.
wHour
=
pret
.
tm_hour
;
st
.
wMinute
=
pret
.
tm_min
;
st
.
wSecond
=
pret
.
tm_sec
;
st
.
wMilliseconds
=
pret
.
tm_usec
/
1000
;
const
FILETIME
*
accessTime
=
nullptr
;
const
FILETIME
*
modifiedTime
=
nullptr
;
if
(
aTimeField
=
=
TimeField
:
:
AccessedTime
)
{
accessTime
=
&
ft
;
}
else
{
modifiedTime
=
&
ft
;
}
nsresult
rv
=
NS_OK
;
if
(
!
(
SystemTimeToFileTime
(
&
st
&
ft
)
!
=
0
&
&
SetFileTime
(
file
nullptr
accessTime
modifiedTime
)
!
=
0
)
)
{
rv
=
ConvertWinError
(
GetLastError
(
)
)
;
}
CloseHandle
(
file
)
;
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetPermissions
(
uint32_t
*
aPermissions
)
{
if
(
NS_WARN_IF
(
!
aPermissions
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
isWritable
=
false
;
rv
=
IsWritable
(
&
isWritable
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
bool
isExecutable
=
false
;
rv
=
IsExecutable
(
&
isExecutable
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aPermissions
=
PR_IRUSR
|
PR_IRGRP
|
PR_IROTH
;
if
(
isWritable
)
{
*
aPermissions
|
=
PR_IWUSR
|
PR_IWGRP
|
PR_IWOTH
;
}
if
(
isExecutable
)
{
*
aPermissions
|
=
PR_IXUSR
|
PR_IXGRP
|
PR_IXOTH
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetPermissionsOfLink
(
uint32_t
*
aPermissions
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aPermissions
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
DWORD
word
=
:
:
GetFileAttributesW
(
mWorkingPath
.
get
(
)
)
;
if
(
word
=
=
INVALID_FILE_ATTRIBUTES
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
bool
isWritable
=
!
(
word
&
FILE_ATTRIBUTE_READONLY
)
;
*
aPermissions
=
PR_IRUSR
|
PR_IRGRP
|
PR_IROTH
;
if
(
isWritable
)
{
*
aPermissions
|
=
PR_IWUSR
|
PR_IWGRP
|
PR_IWOTH
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetPermissions
(
uint32_t
aPermissions
)
{
CHECK_mWorkingPath
(
)
;
nsresult
rv
=
Resolve
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
int
mode
=
0
;
if
(
aPermissions
&
(
PR_IRUSR
|
PR_IRGRP
|
PR_IROTH
)
)
{
mode
|
=
_S_IREAD
;
}
if
(
aPermissions
&
(
PR_IWUSR
|
PR_IWGRP
|
PR_IWOTH
)
)
{
mode
|
=
_S_IWRITE
;
}
if
(
_wchmod
(
mResolvedPath
.
get
(
)
mode
)
=
=
-
1
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetPermissionsOfLink
(
uint32_t
aPermissions
)
{
int
mode
=
0
;
if
(
aPermissions
&
(
PR_IRUSR
|
PR_IRGRP
|
PR_IROTH
)
)
{
mode
|
=
_S_IREAD
;
}
if
(
aPermissions
&
(
PR_IWUSR
|
PR_IWGRP
|
PR_IWOTH
)
)
{
mode
|
=
_S_IWRITE
;
}
if
(
_wchmod
(
mWorkingPath
.
get
(
)
mode
)
=
=
-
1
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetFileSize
(
int64_t
*
aFileSize
)
{
if
(
NS_WARN_IF
(
!
aFileSize
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aFileSize
=
mFileInfo
.
size
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetFileSizeOfLink
(
int64_t
*
aFileSize
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aFileSize
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
FileInfo
info
{
}
;
if
(
NS_FAILED
(
GetFileInfo
(
mWorkingPath
&
info
)
)
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
*
aFileSize
=
info
.
size
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetFileSize
(
int64_t
aFileSize
)
{
CHECK_mWorkingPath
(
)
;
HANDLE
hFile
=
:
:
CreateFileW
(
mWorkingPath
.
get
(
)
GENERIC_WRITE
FILE_SHARE_READ
nullptr
OPEN_EXISTING
FILE_ATTRIBUTE_NORMAL
nullptr
)
;
if
(
hFile
=
=
INVALID_HANDLE_VALUE
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
nsresult
rv
=
NS_ERROR_FAILURE
;
LARGE_INTEGER
distance
;
distance
.
QuadPart
=
aFileSize
;
if
(
SetFilePointerEx
(
hFile
distance
nullptr
FILE_BEGIN
)
&
&
SetEndOfFile
(
hFile
)
)
{
MakeDirty
(
)
;
rv
=
NS_OK
;
}
CloseHandle
(
hFile
)
;
return
rv
;
}
static
nsresult
GetDiskSpaceAttributes
(
const
nsString
&
aResolvedPath
int64_t
*
aFreeBytesAvailable
int64_t
*
aTotalBytes
)
{
ULARGE_INTEGER
liFreeBytesAvailableToCaller
;
ULARGE_INTEGER
liTotalNumberOfBytes
;
if
(
:
:
GetDiskFreeSpaceExW
(
aResolvedPath
.
get
(
)
&
liFreeBytesAvailableToCaller
&
liTotalNumberOfBytes
nullptr
)
)
{
*
aFreeBytesAvailable
=
liFreeBytesAvailableToCaller
.
QuadPart
;
*
aTotalBytes
=
liTotalNumberOfBytes
.
QuadPart
;
return
NS_OK
;
}
return
ConvertWinError
(
:
:
GetLastError
(
)
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetDiskSpaceAvailable
(
int64_t
*
aDiskSpaceAvailable
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aDiskSpaceAvailable
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aDiskSpaceAvailable
=
0
;
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mFileInfo
.
type
=
=
PR_FILE_FILE
)
{
nsCOMPtr
<
nsIFile
>
parent
;
if
(
NS_SUCCEEDED
(
GetParent
(
getter_AddRefs
(
parent
)
)
)
&
&
parent
)
{
return
parent
-
>
GetDiskSpaceAvailable
(
aDiskSpaceAvailable
)
;
}
}
int64_t
dummy
=
0
;
return
GetDiskSpaceAttributes
(
mResolvedPath
aDiskSpaceAvailable
&
dummy
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetDiskCapacity
(
int64_t
*
aDiskCapacity
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aDiskCapacity
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mFileInfo
.
type
=
=
PR_FILE_FILE
)
{
nsCOMPtr
<
nsIFile
>
parent
;
if
(
NS_SUCCEEDED
(
GetParent
(
getter_AddRefs
(
parent
)
)
)
&
&
parent
)
{
return
parent
-
>
GetDiskCapacity
(
aDiskCapacity
)
;
}
}
int64_t
dummy
=
0
;
return
GetDiskSpaceAttributes
(
mResolvedPath
&
dummy
aDiskCapacity
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetParent
(
nsIFile
*
*
aParent
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aParent
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
mWorkingPath
.
Length
(
)
=
=
2
)
{
*
aParent
=
nullptr
;
return
NS_OK
;
}
int32_t
offset
=
mWorkingPath
.
RFindChar
(
char16_t
(
'
\
\
'
)
)
;
if
(
offset
=
=
kNotFound
)
{
return
NS_ERROR_FILE_UNRECOGNIZED_PATH
;
}
if
(
offset
=
=
1
&
&
mWorkingPath
[
0
]
=
=
L
'
\
\
'
)
{
*
aParent
=
nullptr
;
return
NS_OK
;
}
nsAutoString
parentPath
(
mWorkingPath
)
;
if
(
offset
>
0
)
{
parentPath
.
Truncate
(
offset
)
;
}
else
{
parentPath
.
AssignLiteral
(
"
\
\
\
\
.
"
)
;
}
nsCOMPtr
<
nsIFile
>
localFile
;
nsresult
rv
=
NewLocalFile
(
parentPath
mUseDOSDevicePathSyntax
getter_AddRefs
(
localFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
localFile
.
forget
(
aParent
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Exists
(
bool
*
aResult
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
false
;
MakeDirty
(
)
;
nsresult
rv
=
ResolveAndStat
(
)
;
*
aResult
=
NS_SUCCEEDED
(
rv
)
|
|
rv
=
=
NS_ERROR_FILE_IS_LOCKED
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsWritable
(
bool
*
aIsWritable
)
{
CHECK_mWorkingPath
(
)
;
nsresult
rv
=
IsDirectory
(
aIsWritable
)
;
if
(
rv
=
=
NS_ERROR_FILE_ACCESS_DENIED
)
{
*
aIsWritable
=
true
;
return
NS_OK
;
}
else
if
(
rv
=
=
NS_ERROR_FILE_IS_LOCKED
)
{
}
else
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
*
aIsWritable
)
{
return
NS_OK
;
}
rv
=
HasFileAttribute
(
FILE_ATTRIBUTE_READONLY
aIsWritable
)
;
if
(
rv
=
=
NS_ERROR_FILE_ACCESS_DENIED
)
{
*
aIsWritable
=
false
;
return
NS_OK
;
}
else
if
(
rv
=
=
NS_ERROR_FILE_IS_LOCKED
)
{
}
else
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aIsWritable
=
!
*
aIsWritable
;
if
(
*
aIsWritable
)
{
PRFileDesc
*
file
;
rv
=
OpenFile
(
mResolvedPath
PR_WRONLY
0
false
&
file
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
PR_Close
(
file
)
;
}
else
if
(
rv
=
=
NS_ERROR_FILE_ACCESS_DENIED
)
{
*
aIsWritable
=
false
;
}
else
if
(
rv
=
=
NS_ERROR_FILE_IS_LOCKED
)
{
*
aIsWritable
=
true
;
}
else
{
return
rv
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsReadable
(
bool
*
aResult
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
false
;
nsresult
rv
=
ResolveAndStat
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aResult
=
true
;
return
NS_OK
;
}
nsresult
nsLocalFile
:
:
LookupExtensionIn
(
const
char
*
const
*
aExtensionsArray
size_t
aArrayLength
bool
*
aResult
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
false
;
nsresult
rv
;
bool
isFile
;
rv
=
IsFile
(
&
isFile
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
isFile
)
{
return
NS_OK
;
}
bool
symLink
=
false
;
rv
=
IsSymlink
(
&
symLink
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoString
path
;
if
(
symLink
)
{
GetTarget
(
path
)
;
}
else
{
GetPath
(
path
)
;
}
int32_t
filePathLen
=
path
.
Length
(
)
-
1
;
while
(
filePathLen
>
0
&
&
(
path
[
filePathLen
]
=
=
L
'
'
|
|
path
[
filePathLen
]
=
=
L
'
.
'
)
)
{
path
.
Truncate
(
filePathLen
-
-
)
;
}
int32_t
dotIdx
=
path
.
RFindChar
(
char16_t
(
'
.
'
)
)
;
if
(
dotIdx
!
=
kNotFound
)
{
char16_t
*
p
=
path
.
BeginWriting
(
)
;
for
(
p
+
=
dotIdx
+
1
;
*
p
;
+
+
p
)
{
*
p
+
=
(
*
p
>
=
L
'
A
'
&
&
*
p
<
=
L
'
Z
'
)
?
'
a
'
-
'
A
'
:
0
;
}
nsDependentSubstring
ext
=
Substring
(
path
dotIdx
)
;
for
(
size_t
i
=
0
;
i
<
aArrayLength
;
+
+
i
)
{
if
(
ext
.
EqualsASCII
(
aExtensionsArray
[
i
]
)
)
{
*
aResult
=
true
;
break
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsExecutable
(
bool
*
aResult
)
{
return
LookupExtensionIn
(
sExecutableExts
ArrayLength
(
sExecutableExts
)
aResult
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsDirectory
(
bool
*
aResult
)
{
return
HasFileAttribute
(
FILE_ATTRIBUTE_DIRECTORY
aResult
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsFile
(
bool
*
aResult
)
{
nsresult
rv
=
HasFileAttribute
(
FILE_ATTRIBUTE_DIRECTORY
aResult
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aResult
=
!
*
aResult
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsHidden
(
bool
*
aResult
)
{
return
HasFileAttribute
(
FILE_ATTRIBUTE_HIDDEN
aResult
)
;
}
nsresult
nsLocalFile
:
:
HasFileAttribute
(
DWORD
aFileAttrib
bool
*
aResult
)
{
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
Resolve
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
DWORD
attributes
=
GetFileAttributesW
(
mResolvedPath
.
get
(
)
)
;
if
(
INVALID_FILE_ATTRIBUTES
=
=
attributes
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
*
aResult
=
(
(
attributes
&
aFileAttrib
)
!
=
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsSymlink
(
bool
*
aResult
)
{
CHECK_mWorkingPath
(
)
;
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aResult
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
IsSpecial
(
bool
*
aResult
)
{
return
HasFileAttribute
(
FILE_ATTRIBUTE_SYSTEM
aResult
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Equals
(
nsIFile
*
aInFile
bool
*
aResult
)
{
if
(
NS_WARN_IF
(
!
aInFile
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aResult
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsILocalFileWin
>
lf
(
do_QueryInterface
(
aInFile
)
)
;
if
(
!
lf
)
{
*
aResult
=
false
;
return
NS_OK
;
}
bool
inUseDOSDevicePathSyntax
;
lf
-
>
GetUseDOSDevicePathSyntax
(
&
inUseDOSDevicePathSyntax
)
;
bool
removePathPrefix
removeInPathPrefix
;
if
(
inUseDOSDevicePathSyntax
!
=
mUseDOSDevicePathSyntax
)
{
removeInPathPrefix
=
inUseDOSDevicePathSyntax
;
removePathPrefix
=
mUseDOSDevicePathSyntax
;
}
else
{
removePathPrefix
=
removeInPathPrefix
=
false
;
}
nsAutoString
inFilePath
workingPath
;
aInFile
-
>
GetPath
(
inFilePath
)
;
workingPath
=
mWorkingPath
;
constexpr
static
auto
equalPath
=
[
]
(
nsAutoString
&
workingPath
nsAutoString
&
inFilePath
bool
removePathPrefix
bool
removeInPathPrefix
)
{
if
(
removeInPathPrefix
&
&
StringBeginsWith
(
inFilePath
kDevicePathSpecifier
)
)
{
MOZ_ASSERT
(
!
StringBeginsWith
(
workingPath
kDevicePathSpecifier
)
)
;
inFilePath
=
Substring
(
inFilePath
kDevicePathSpecifier
.
Length
(
)
)
;
}
else
if
(
removePathPrefix
&
&
StringBeginsWith
(
workingPath
kDevicePathSpecifier
)
)
{
MOZ_ASSERT
(
!
StringBeginsWith
(
inFilePath
kDevicePathSpecifier
)
)
;
workingPath
=
Substring
(
workingPath
kDevicePathSpecifier
.
Length
(
)
)
;
}
return
_wcsicmp
(
workingPath
.
get
(
)
inFilePath
.
get
(
)
)
=
=
0
;
}
;
if
(
equalPath
(
workingPath
inFilePath
removePathPrefix
removeInPathPrefix
)
)
{
*
aResult
=
true
;
return
NS_OK
;
}
EnsureShortPath
(
)
;
lf
-
>
GetCanonicalPath
(
inFilePath
)
;
workingPath
=
mShortWorkingPath
;
*
aResult
=
equalPath
(
workingPath
inFilePath
removePathPrefix
removeInPathPrefix
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Contains
(
nsIFile
*
aInFile
bool
*
aResult
)
{
CHECK_mWorkingPath
(
)
;
*
aResult
=
false
;
nsAutoString
myFilePath
;
if
(
NS_FAILED
(
GetTarget
(
myFilePath
)
)
)
{
GetPath
(
myFilePath
)
;
}
uint32_t
myFilePathLen
=
myFilePath
.
Length
(
)
;
nsAutoString
inFilePath
;
if
(
NS_FAILED
(
aInFile
-
>
GetTarget
(
inFilePath
)
)
)
{
aInFile
-
>
GetPath
(
inFilePath
)
;
}
if
(
inFilePath
.
Length
(
)
>
myFilePathLen
&
&
inFilePath
[
myFilePathLen
]
=
=
L
'
\
\
'
)
{
if
(
_wcsnicmp
(
myFilePath
.
get
(
)
inFilePath
.
get
(
)
myFilePathLen
)
=
=
0
)
{
*
aResult
=
true
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetTarget
(
nsAString
&
aResult
)
{
aResult
.
Truncate
(
)
;
Resolve
(
)
;
MOZ_ASSERT_IF
(
mUseDOSDevicePathSyntax
!
FilePreferences
:
:
StartsWithDiskDesignatorAndBackslash
(
mResolvedPath
)
)
;
aResult
=
mResolvedPath
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetDirectoryEntriesImpl
(
nsIDirectoryEnumerator
*
*
aEntries
)
{
nsresult
rv
;
*
aEntries
=
nullptr
;
if
(
mWorkingPath
.
EqualsLiteral
(
"
\
\
\
\
.
"
)
)
{
RefPtr
<
nsDriveEnumerator
>
drives
=
new
nsDriveEnumerator
(
mUseDOSDevicePathSyntax
)
;
rv
=
drives
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
drives
.
forget
(
aEntries
)
;
return
NS_OK
;
}
RefPtr
<
nsDirEnumerator
>
dirEnum
=
new
nsDirEnumerator
(
)
;
rv
=
dirEnum
-
>
Init
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
dirEnum
.
forget
(
aEntries
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetPersistentDescriptor
(
nsACString
&
aPersistentDescriptor
)
{
CopyUTF16toUTF8
(
mWorkingPath
aPersistentDescriptor
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetPersistentDescriptor
(
const
nsACString
&
aPersistentDescriptor
)
{
if
(
IsUtf8
(
aPersistentDescriptor
)
)
{
return
InitWithPath
(
NS_ConvertUTF8toUTF16
(
aPersistentDescriptor
)
)
;
}
else
{
return
InitWithNativePath
(
aPersistentDescriptor
)
;
}
}
NS_IMETHODIMP
nsLocalFile
:
:
GetReadOnly
(
bool
*
aReadOnly
)
{
NS_ENSURE_ARG_POINTER
(
aReadOnly
)
;
DWORD
dwAttrs
=
GetFileAttributesW
(
mWorkingPath
.
get
(
)
)
;
if
(
dwAttrs
=
=
INVALID_FILE_ATTRIBUTES
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
*
aReadOnly
=
dwAttrs
&
FILE_ATTRIBUTE_READONLY
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetReadOnly
(
bool
aReadOnly
)
{
DWORD
dwAttrs
=
GetFileAttributesW
(
mWorkingPath
.
get
(
)
)
;
if
(
dwAttrs
=
=
INVALID_FILE_ATTRIBUTES
)
{
return
NS_ERROR_FILE_INVALID_PATH
;
}
if
(
aReadOnly
)
{
dwAttrs
|
=
FILE_ATTRIBUTE_READONLY
;
}
else
{
dwAttrs
&
=
~
FILE_ATTRIBUTE_READONLY
;
}
if
(
SetFileAttributesW
(
mWorkingPath
.
get
(
)
dwAttrs
)
=
=
0
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetUseDOSDevicePathSyntax
(
bool
*
aUseDOSDevicePathSyntax
)
{
MOZ_ASSERT
(
aUseDOSDevicePathSyntax
)
;
*
aUseDOSDevicePathSyntax
=
mUseDOSDevicePathSyntax
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetUseDOSDevicePathSyntax
(
bool
aUseDOSDevicePathSyntax
)
{
if
(
mUseDOSDevicePathSyntax
=
=
aUseDOSDevicePathSyntax
)
{
return
NS_OK
;
}
if
(
mUseDOSDevicePathSyntax
)
{
if
(
StringBeginsWith
(
mWorkingPath
kDevicePathSpecifier
)
)
{
MakeDirty
(
)
;
mWorkingPath
=
Substring
(
mWorkingPath
kDevicePathSpecifier
.
Length
(
)
)
;
}
}
else
{
if
(
FilePreferences
:
:
StartsWithDiskDesignatorAndBackslash
(
mWorkingPath
)
)
{
MakeDirty
(
)
;
mWorkingPath
=
kDevicePathSpecifier
+
mWorkingPath
;
}
}
mUseDOSDevicePathSyntax
=
aUseDOSDevicePathSyntax
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Reveal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
Resolve
(
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_FILE_NOT_FOUND
)
{
return
rv
;
}
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
"
nsLocalFile
:
:
Reveal
"
[
path
=
mResolvedPath
]
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
Don
'
t
run
on
the
main
thread
"
)
;
bool
doCoUninitialize
=
SUCCEEDED
(
CoInitializeEx
(
nullptr
COINIT_APARTMENTTHREADED
|
COINIT_DISABLE_OLE1DDE
)
)
;
RevealFile
(
path
)
;
if
(
doCoUninitialize
)
{
CoUninitialize
(
)
;
}
}
)
;
return
NS_DispatchBackgroundTask
(
task
nsIEventTarget
:
:
DISPATCH_EVENT_MAY_BLOCK
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetWindowsFileAttributes
(
uint32_t
*
aAttrs
)
{
NS_ENSURE_ARG_POINTER
(
aAttrs
)
;
DWORD
dwAttrs
=
:
:
GetFileAttributesW
(
mWorkingPath
.
get
(
)
)
;
if
(
dwAttrs
=
=
INVALID_FILE_ATTRIBUTES
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
*
aAttrs
=
dwAttrs
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetWindowsFileAttributes
(
uint32_t
aSetAttrs
uint32_t
aClearAttrs
)
{
DWORD
dwAttrs
=
:
:
GetFileAttributesW
(
mWorkingPath
.
get
(
)
)
;
if
(
dwAttrs
=
=
INVALID_FILE_ATTRIBUTES
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
dwAttrs
=
(
dwAttrs
&
~
aClearAttrs
)
|
aSetAttrs
;
if
(
:
:
SetFileAttributesW
(
mWorkingPath
.
get
(
)
dwAttrs
)
=
=
0
)
{
return
ConvertWinError
(
GetLastError
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
Launch
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
_bstr_t
execPath
(
mWorkingPath
.
get
(
)
)
;
_variant_t
args
;
_variant_t
verbDefault
(
DISP_E_PARAMNOTFOUND
VT_ERROR
)
;
_variant_t
showCmd
(
SW_SHOWNORMAL
)
;
wchar_t
*
workingDirectoryPtr
=
nullptr
;
WCHAR
workingDirectory
[
MAX_PATH
+
1
]
=
{
L
'
\
0
'
}
;
wcsncpy
(
workingDirectory
mWorkingPath
.
get
(
)
MAX_PATH
)
;
if
(
PathRemoveFileSpecW
(
workingDirectory
)
)
{
workingDirectoryPtr
=
workingDirectory
;
}
else
{
NS_WARNING
(
"
Could
not
set
working
directory
for
launched
file
.
"
)
;
}
static
const
char
*
const
onlyExeExt
[
]
=
{
"
.
exe
"
}
;
bool
isExecutable
;
nsresult
rv
=
LookupExtensionIn
(
onlyExeExt
ArrayLength
(
onlyExeExt
)
&
isExecutable
)
;
if
(
NS_FAILED
(
rv
)
)
{
isExecutable
=
false
;
}
if
(
!
isExecutable
)
{
mozilla
:
:
LauncherVoidResult
shellExecuteOk
=
mozilla
:
:
ShellExecuteByExplorer
(
execPath
args
verbDefault
workingDirectoryPtr
showCmd
)
;
if
(
shellExecuteOk
.
isOk
(
)
)
{
return
NS_OK
;
}
}
SHELLEXECUTEINFOW
seinfo
=
{
sizeof
(
SHELLEXECUTEINFOW
)
}
;
seinfo
.
fMask
=
SEE_MASK_ASYNCOK
;
seinfo
.
hwnd
=
GetMostRecentNavigatorHWND
(
)
;
seinfo
.
lpVerb
=
nullptr
;
seinfo
.
lpFile
=
mWorkingPath
.
get
(
)
;
seinfo
.
lpParameters
=
nullptr
;
seinfo
.
lpDirectory
=
workingDirectoryPtr
;
seinfo
.
nShow
=
SW_SHOWNORMAL
;
if
(
!
ShellExecuteExW
(
&
seinfo
)
)
{
return
NS_ERROR_FILE_EXECUTION_FAILED
;
}
return
NS_OK
;
}
nsresult
NS_NewLocalFile
(
const
nsAString
&
aPath
bool
aFollowLinks
nsIFile
*
*
aResult
)
{
RefPtr
<
nsLocalFile
>
file
=
new
nsLocalFile
(
)
;
if
(
!
aPath
.
IsEmpty
(
)
)
{
nsresult
rv
=
file
-
>
InitWithPath
(
aPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
file
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsLocalFile
:
:
InitWithNativePath
(
const
nsACString
&
aFilePath
)
{
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aFilePath
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
InitWithPath
(
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
AppendNative
(
const
nsACString
&
aNode
)
{
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aNode
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
Append
(
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
AppendRelativeNativePath
(
const
nsACString
&
aNode
)
{
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aNode
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
AppendRelativePath
(
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetNativeLeafName
(
nsACString
&
aLeafName
)
{
nsAutoString
tmp
;
nsresult
rv
=
GetLeafName
(
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
NS_CopyUnicodeToNative
(
tmp
aLeafName
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
SetNativeLeafName
(
const
nsACString
&
aLeafName
)
{
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aLeafName
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
SetLeafName
(
tmp
)
;
}
return
rv
;
}
nsString
nsLocalFile
:
:
NativePath
(
)
{
return
mWorkingPath
;
}
nsCString
nsIFile
:
:
HumanReadablePath
(
)
{
nsString
path
;
DebugOnly
<
nsresult
>
rv
=
GetPath
(
path
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
NS_ConvertUTF16toUTF8
(
path
)
;
}
NS_IMETHODIMP
nsLocalFile
:
:
CopyToNative
(
nsIFile
*
aNewParentDir
const
nsACString
&
aNewName
)
{
CHECK_mWorkingPath
(
)
;
if
(
aNewName
.
IsEmpty
(
)
)
{
return
CopyTo
(
aNewParentDir
u
"
"
_ns
)
;
}
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aNewName
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
CopyTo
(
aNewParentDir
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
CopyToFollowingLinksNative
(
nsIFile
*
aNewParentDir
const
nsACString
&
aNewName
)
{
if
(
aNewName
.
IsEmpty
(
)
)
{
return
CopyToFollowingLinks
(
aNewParentDir
u
"
"
_ns
)
;
}
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aNewName
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
CopyToFollowingLinks
(
aNewParentDir
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
MoveToNative
(
nsIFile
*
aNewParentDir
const
nsACString
&
aNewName
)
{
CHECK_mWorkingPath
(
)
;
if
(
aNewName
.
IsEmpty
(
)
)
{
return
MoveTo
(
aNewParentDir
u
"
"
_ns
)
;
}
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aNewName
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
MoveTo
(
aNewParentDir
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
MoveToFollowingLinksNative
(
nsIFile
*
aNewParentDir
const
nsACString
&
aNewName
)
{
CHECK_mWorkingPath
(
)
;
if
(
aNewName
.
IsEmpty
(
)
)
{
return
MoveToFollowingLinks
(
aNewParentDir
u
"
"
_ns
)
;
}
nsAutoString
tmp
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aNewName
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
MoveToFollowingLinks
(
aNewParentDir
tmp
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsLocalFile
:
:
GetNativeTarget
(
nsACString
&
aResult
)
{
CHECK_mWorkingPath
(
)
;
NS_WARNING
(
"
This
API
is
lossy
.
Use
GetTarget
!
"
)
;
nsAutoString
tmp
;
nsresult
rv
=
GetTarget
(
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
NS_CopyUnicodeToNative
(
tmp
aResult
)
;
}
return
rv
;
}
nsresult
NS_NewNativeLocalFile
(
const
nsACString
&
aPath
bool
aFollowLinks
nsIFile
*
*
aResult
)
{
nsAutoString
buf
;
nsresult
rv
=
NS_CopyNativeToUnicode
(
aPath
buf
)
;
if
(
NS_FAILED
(
rv
)
)
{
*
aResult
=
nullptr
;
return
rv
;
}
return
NS_NewLocalFile
(
buf
aFollowLinks
aResult
)
;
}
void
nsLocalFile
:
:
EnsureShortPath
(
)
{
if
(
!
mShortWorkingPath
.
IsEmpty
(
)
)
{
return
;
}
WCHAR
shortPath
[
MAX_PATH
+
1
]
;
DWORD
lengthNeeded
=
:
:
GetShortPathNameW
(
mWorkingPath
.
get
(
)
shortPath
ArrayLength
(
shortPath
)
)
;
if
(
lengthNeeded
!
=
0
&
&
lengthNeeded
<
ArrayLength
(
shortPath
)
)
{
mShortWorkingPath
.
Assign
(
shortPath
)
;
}
else
{
mShortWorkingPath
.
Assign
(
mWorkingPath
)
;
}
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsDriveEnumerator
nsSimpleEnumerator
nsIDirectoryEnumerator
)
nsDriveEnumerator
:
:
nsDriveEnumerator
(
bool
aUseDOSDevicePathSyntax
)
:
mUseDOSDevicePathSyntax
(
aUseDOSDevicePathSyntax
)
{
}
nsDriveEnumerator
:
:
~
nsDriveEnumerator
(
)
{
}
nsresult
nsDriveEnumerator
:
:
Init
(
)
{
DWORD
length
=
GetLogicalDriveStringsW
(
0
0
)
;
if
(
!
mDrives
.
SetLength
(
length
+
1
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
!
GetLogicalDriveStringsW
(
length
mDrives
.
get
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
mDrives
.
BeginReading
(
mStartOfCurrentDrive
)
;
mDrives
.
EndReading
(
mEndOfDrivesString
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDriveEnumerator
:
:
HasMoreElements
(
bool
*
aHasMore
)
{
*
aHasMore
=
*
mStartOfCurrentDrive
!
=
L
'
\
0
'
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDriveEnumerator
:
:
GetNext
(
nsISupports
*
*
aNext
)
{
if
(
*
mStartOfCurrentDrive
=
=
L
'
\
0
'
)
{
*
aNext
=
nullptr
;
return
NS_ERROR_FAILURE
;
}
nsAString
:
:
const_iterator
driveEnd
=
mStartOfCurrentDrive
;
FindCharInReadable
(
L
'
\
0
'
driveEnd
mEndOfDrivesString
)
;
nsString
drive
(
Substring
(
mStartOfCurrentDrive
driveEnd
)
)
;
mStartOfCurrentDrive
=
+
+
driveEnd
;
nsIFile
*
file
;
nsresult
rv
=
NewLocalFile
(
drive
mUseDOSDevicePathSyntax
&
file
)
;
*
aNext
=
file
;
return
rv
;
}
