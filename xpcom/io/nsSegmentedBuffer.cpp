#
include
"
nsSegmentedBuffer
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
nsresult
nsSegmentedBuffer
:
:
Init
(
uint32_t
aSegmentSize
uint32_t
aMaxSize
)
{
if
(
mSegmentArrayCount
!
=
0
)
{
return
NS_ERROR_FAILURE
;
}
mSegmentSize
=
aSegmentSize
;
mMaxSize
=
aMaxSize
;
#
if
0
mSegmentArrayCount
=
2
;
#
else
mSegmentArrayCount
=
NS_SEGMENTARRAY_INITIAL_COUNT
;
#
endif
return
NS_OK
;
}
char
*
nsSegmentedBuffer
:
:
AppendNewSegment
(
)
{
if
(
GetSize
(
)
>
=
mMaxSize
)
{
return
nullptr
;
}
if
(
!
mSegmentArray
)
{
uint32_t
bytes
=
mSegmentArrayCount
*
sizeof
(
char
*
)
;
mSegmentArray
=
(
char
*
*
)
moz_xmalloc
(
bytes
)
;
memset
(
mSegmentArray
0
bytes
)
;
}
if
(
IsFull
(
)
)
{
uint32_t
newArraySize
=
mSegmentArrayCount
*
2
;
uint32_t
bytes
=
newArraySize
*
sizeof
(
char
*
)
;
mSegmentArray
=
(
char
*
*
)
moz_xrealloc
(
mSegmentArray
bytes
)
;
if
(
mFirstSegmentIndex
>
mLastSegmentIndex
)
{
memcpy
(
&
mSegmentArray
[
mSegmentArrayCount
]
mSegmentArray
mLastSegmentIndex
*
sizeof
(
char
*
)
)
;
memset
(
mSegmentArray
0
mLastSegmentIndex
*
sizeof
(
char
*
)
)
;
mLastSegmentIndex
+
=
mSegmentArrayCount
;
memset
(
&
mSegmentArray
[
mLastSegmentIndex
]
0
(
newArraySize
-
mLastSegmentIndex
)
*
sizeof
(
char
*
)
)
;
}
else
{
memset
(
&
mSegmentArray
[
mLastSegmentIndex
]
0
(
newArraySize
-
mLastSegmentIndex
)
*
sizeof
(
char
*
)
)
;
}
mSegmentArrayCount
=
newArraySize
;
}
char
*
seg
=
(
char
*
)
malloc
(
mSegmentSize
)
;
if
(
!
seg
)
{
return
nullptr
;
}
mSegmentArray
[
mLastSegmentIndex
]
=
seg
;
mLastSegmentIndex
=
ModSegArraySize
(
mLastSegmentIndex
+
1
)
;
return
seg
;
}
bool
nsSegmentedBuffer
:
:
DeleteFirstSegment
(
)
{
NS_ASSERTION
(
mSegmentArray
[
mFirstSegmentIndex
]
!
=
nullptr
"
deleting
bad
segment
"
)
;
FreeOMT
(
mSegmentArray
[
mFirstSegmentIndex
]
)
;
mSegmentArray
[
mFirstSegmentIndex
]
=
nullptr
;
int32_t
last
=
ModSegArraySize
(
mLastSegmentIndex
-
1
)
;
if
(
mFirstSegmentIndex
=
=
last
)
{
mLastSegmentIndex
=
last
;
return
true
;
}
else
{
mFirstSegmentIndex
=
ModSegArraySize
(
mFirstSegmentIndex
+
1
)
;
return
false
;
}
}
bool
nsSegmentedBuffer
:
:
DeleteLastSegment
(
)
{
int32_t
last
=
ModSegArraySize
(
mLastSegmentIndex
-
1
)
;
NS_ASSERTION
(
mSegmentArray
[
last
]
!
=
nullptr
"
deleting
bad
segment
"
)
;
FreeOMT
(
mSegmentArray
[
last
]
)
;
mSegmentArray
[
last
]
=
nullptr
;
mLastSegmentIndex
=
last
;
return
(
bool
)
(
mLastSegmentIndex
=
=
mFirstSegmentIndex
)
;
}
bool
nsSegmentedBuffer
:
:
ReallocLastSegment
(
size_t
aNewSize
)
{
int32_t
last
=
ModSegArraySize
(
mLastSegmentIndex
-
1
)
;
NS_ASSERTION
(
mSegmentArray
[
last
]
!
=
nullptr
"
realloc
'
ing
bad
segment
"
)
;
char
*
newSegment
=
(
char
*
)
realloc
(
mSegmentArray
[
last
]
aNewSize
)
;
if
(
newSegment
)
{
mSegmentArray
[
last
]
=
newSegment
;
return
true
;
}
return
false
;
}
void
nsSegmentedBuffer
:
:
Empty
(
)
{
if
(
mSegmentArray
)
{
for
(
uint32_t
i
=
0
;
i
<
mSegmentArrayCount
;
i
+
+
)
{
if
(
mSegmentArray
[
i
]
)
{
FreeOMT
(
mSegmentArray
[
i
]
)
;
}
}
FreeOMT
(
mSegmentArray
)
;
mSegmentArray
=
nullptr
;
}
mSegmentArrayCount
=
NS_SEGMENTARRAY_INITIAL_COUNT
;
mFirstSegmentIndex
=
mLastSegmentIndex
=
0
;
}
void
nsSegmentedBuffer
:
:
FreeOMT
(
void
*
aPtr
)
{
if
(
!
NS_IsMainThread
(
)
)
{
free
(
aPtr
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
nsSegmentedBuffer
:
:
FreeOMT
"
[
aPtr
]
(
)
{
free
(
aPtr
)
;
}
)
;
nsresult
rv
=
NS_OK
;
if
(
!
mFreeMemoryQueue
)
{
rv
=
NS_CreateBackgroundTaskQueue
(
"
nsSegmentedBuffer
:
:
FreeOMT
"
getter_AddRefs
(
mFreeMemoryQueue
)
)
;
}
if
(
NS_FAILED
(
rv
)
|
|
!
mFreeMemoryQueue
|
|
NS_FAILED
(
mFreeMemoryQueue
-
>
Dispatch
(
r
.
forget
(
)
)
)
)
{
free
(
aPtr
)
;
}
}
