#
include
"
nsAnonymousTemporaryFile
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
prio
.
h
"
#
include
"
SpecialSystemDirectory
.
h
"
#
ifdef
XP_WIN
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsIIdleService
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsCRT
.
h
"
#
endif
using
namespace
mozilla
;
static
nsresult
GetTempDir
(
nsIFile
*
*
aTempDir
)
{
if
(
NS_WARN_IF
(
!
aTempDir
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIFile
>
tmpFile
;
nsresult
rv
=
GetSpecialSystemDirectory
(
OS_TemporaryDirectory
getter_AddRefs
(
tmpFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
#
ifdef
XP_WIN
rv
=
tmpFile
-
>
AppendNative
(
nsDependentCString
(
"
mozilla
-
temp
-
files
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
tmpFile
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0700
)
;
if
(
rv
!
=
NS_ERROR_FILE_ALREADY_EXISTS
&
&
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
#
endif
tmpFile
.
forget
(
aTempDir
)
;
return
NS_OK
;
}
nsresult
NS_OpenAnonymousTemporaryNsIFile
(
nsIFile
*
*
aFile
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
NS_WARN_IF
(
!
aFile
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
tmpFile
;
rv
=
GetTempDir
(
getter_AddRefs
(
tmpFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoCString
name
(
"
mozilla
-
temp
-
"
)
;
name
.
AppendInt
(
rand
(
)
)
;
rv
=
tmpFile
-
>
AppendNative
(
name
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
tmpFile
-
>
CreateUnique
(
nsIFile
:
:
NORMAL_FILE_TYPE
0600
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
tmpFile
.
forget
(
aFile
)
;
return
NS_OK
;
}
nsresult
NS_OpenAnonymousTemporaryFile
(
PRFileDesc
*
*
aOutFileDesc
)
{
nsCOMPtr
<
nsIFile
>
tmpFile
;
nsresult
rv
=
NS_OpenAnonymousTemporaryNsIFile
(
getter_AddRefs
(
tmpFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
tmpFile
-
>
OpenNSPRFileDesc
(
PR_RDWR
|
nsIFile
:
:
DELETE_ON_CLOSE
PR_IRWXU
aOutFileDesc
)
;
return
rv
;
}
#
ifdef
XP_WIN
#
define
TEMP_FILE_IDLE_TIME_S
30
#
define
SCHEDULE_TIMEOUT_MS
3
*
60
*
1000
#
define
XPCOM_SHUTDOWN_TOPIC
"
xpcom
-
shutdown
"
class
nsAnonTempFileRemover
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
nsAnonTempFileRemover
(
)
{
}
nsresult
Init
(
)
{
MOZ_TRY_VAR
(
mTimer
NS_NewTimerWithObserver
(
this
SCHEDULE_TIMEOUT_MS
nsITimer
:
:
TYPE_ONE_SHOT
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsSrv
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obsSrv
)
)
{
return
NS_ERROR_FAILURE
;
}
return
obsSrv
-
>
AddObserver
(
this
XPCOM_SHUTDOWN_TOPIC
false
)
;
}
void
Cleanup
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
nsCOMPtr
<
nsIIdleService
>
idleSvc
=
do_GetService
(
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
)
;
if
(
idleSvc
)
{
idleSvc
-
>
RemoveIdleObserver
(
this
TEMP_FILE_IDLE_TIME_S
)
;
}
nsCOMPtr
<
nsIObserverService
>
obsSrv
=
services
:
:
GetObserverService
(
)
;
if
(
obsSrv
)
{
obsSrv
-
>
RemoveObserver
(
this
XPCOM_SHUTDOWN_TOPIC
)
;
}
}
NS_IMETHODIMP
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
nsCRT
:
:
strcmp
(
aTopic
NS_TIMER_CALLBACK_TOPIC
)
=
=
0
&
&
NS_FAILED
(
RegisterIdleObserver
(
)
)
)
{
Cleanup
(
)
;
}
else
if
(
nsCRT
:
:
strcmp
(
aTopic
OBSERVER_TOPIC_IDLE
)
=
=
0
)
{
RemoveAnonTempFileFiles
(
)
;
Cleanup
(
)
;
}
else
if
(
nsCRT
:
:
strcmp
(
aTopic
XPCOM_SHUTDOWN_TOPIC
)
=
=
0
)
{
Cleanup
(
)
;
}
return
NS_OK
;
}
nsresult
RegisterIdleObserver
(
)
{
nsCOMPtr
<
nsIIdleService
>
idleSvc
=
do_GetService
(
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
)
;
if
(
!
idleSvc
)
{
return
NS_ERROR_FAILURE
;
}
return
idleSvc
-
>
AddIdleObserver
(
this
TEMP_FILE_IDLE_TIME_S
)
;
}
void
RemoveAnonTempFileFiles
(
)
{
nsCOMPtr
<
nsIFile
>
tmpDir
;
nsresult
rv
=
GetTempDir
(
getter_AddRefs
(
tmpDir
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
tmpDir
-
>
Remove
(
true
)
;
}
private
:
~
nsAnonTempFileRemover
(
)
{
}
nsCOMPtr
<
nsITimer
>
mTimer
;
}
;
NS_IMPL_ISUPPORTS
(
nsAnonTempFileRemover
nsIObserver
)
nsresult
CreateAnonTempFileRemover
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_OK
;
}
RefPtr
<
nsAnonTempFileRemover
>
tempRemover
=
new
nsAnonTempFileRemover
(
)
;
return
tempRemover
-
>
Init
(
)
;
}
#
endif
