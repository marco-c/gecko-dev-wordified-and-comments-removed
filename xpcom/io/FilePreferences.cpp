#
include
"
FilePreferences
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
namespace
FilePreferences
{
static
bool
sBlockUNCPaths
=
false
;
typedef
nsTArray
<
nsString
>
WinPaths
;
static
WinPaths
&
PathWhitelist
(
)
{
static
WinPaths
sPaths
;
return
sPaths
;
}
#
ifdef
XP_WIN
typedef
char16_t
char_path_t
;
#
else
typedef
char
char_path_t
;
#
endif
typedef
nsTArray
<
nsTString
<
char_path_t
>
>
Paths
;
static
StaticAutoPtr
<
Paths
>
sBlacklist
;
static
Paths
&
PathBlacklist
(
)
{
if
(
!
sBlacklist
)
{
sBlacklist
=
new
nsTArray
<
nsTString
<
char_path_t
>
>
(
)
;
ClearOnShutdown
(
&
sBlacklist
)
;
}
return
*
sBlacklist
;
}
static
void
AllowUNCDirectory
(
char
const
*
directory
)
{
nsCOMPtr
<
nsIFile
>
file
;
NS_GetSpecialDirectory
(
directory
getter_AddRefs
(
file
)
)
;
if
(
!
file
)
{
return
;
}
nsString
path
;
if
(
NS_FAILED
(
file
-
>
GetTarget
(
path
)
)
)
{
return
;
}
if
(
!
StringBeginsWith
(
path
NS_LITERAL_STRING
(
"
\
\
\
\
"
)
)
)
{
return
;
}
if
(
!
PathWhitelist
(
)
.
Contains
(
path
)
)
{
PathWhitelist
(
)
.
AppendElement
(
path
)
;
}
}
void
InitPrefs
(
)
{
sBlockUNCPaths
=
Preferences
:
:
GetBool
(
"
network
.
file
.
disable_unc_paths
"
false
)
;
PathBlacklist
(
)
.
Clear
(
)
;
nsTAutoString
<
char_path_t
>
blacklist
;
#
ifdef
XP_WIN
Preferences
:
:
GetString
(
"
network
.
file
.
path_blacklist
"
blacklist
)
;
#
else
Preferences
:
:
GetCString
(
"
network
.
file
.
path_blacklist
"
blacklist
)
;
#
endif
TTokenizer
<
char_path_t
>
p
(
blacklist
)
;
while
(
!
p
.
CheckEOF
(
)
)
{
nsTString
<
char_path_t
>
path
;
Unused
<
<
p
.
ReadUntil
(
TTokenizer
<
char_path_t
>
:
:
Token
:
:
Char
(
'
'
)
path
)
;
path
.
Trim
(
"
"
)
;
if
(
!
path
.
IsEmpty
(
)
)
{
PathBlacklist
(
)
.
AppendElement
(
path
)
;
}
Unused
<
<
p
.
CheckChar
(
'
'
)
;
}
}
void
InitDirectoriesWhitelist
(
)
{
AllowUNCDirectory
(
NS_GRE_DIR
)
;
AllowUNCDirectory
(
NS_APP_USER_PROFILE_50_DIR
)
;
AllowUNCDirectory
(
NS_APP_USER_PROFILE_LOCAL_50_DIR
)
;
}
namespace
{
template
<
typename
TChar
>
class
TNormalizer
:
public
TTokenizer
<
TChar
>
{
typedef
TTokenizer
<
TChar
>
base
;
public
:
typedef
typename
base
:
:
Token
Token
;
TNormalizer
(
const
nsTSubstring
<
TChar
>
&
aFilePath
const
Token
&
aSeparator
)
:
TTokenizer
<
TChar
>
(
aFilePath
)
mSeparator
(
aSeparator
)
{
}
bool
Get
(
nsTSubstring
<
TChar
>
&
aNormalizedFilePath
)
{
aNormalizedFilePath
.
Truncate
(
)
;
#
ifdef
XP_WIN
if
(
base
:
:
Check
(
mSeparator
)
)
{
aNormalizedFilePath
.
Append
(
mSeparator
.
AsChar
(
)
)
;
}
#
endif
if
(
base
:
:
Check
(
mSeparator
)
)
{
aNormalizedFilePath
.
Append
(
mSeparator
.
AsChar
(
)
)
;
}
while
(
base
:
:
HasInput
(
)
)
{
if
(
!
ConsumeName
(
)
)
{
return
false
;
}
}
for
(
auto
const
&
name
:
mStack
)
{
aNormalizedFilePath
.
Append
(
name
)
;
}
return
true
;
}
private
:
bool
ConsumeName
(
)
{
if
(
base
:
:
CheckEOF
(
)
)
{
return
true
;
}
if
(
CheckCurrentDir
(
)
)
{
return
true
;
}
if
(
CheckParentDir
(
)
)
{
if
(
!
mStack
.
Length
(
)
)
{
return
false
;
}
mStack
.
RemoveLastElement
(
)
;
return
true
;
}
nsTDependentSubstring
<
TChar
>
name
;
if
(
base
:
:
ReadUntil
(
mSeparator
name
base
:
:
INCLUDE_LAST
)
&
&
name
.
Length
(
)
=
=
1
)
{
return
false
;
}
mStack
.
AppendElement
(
name
)
;
return
true
;
}
bool
CheckParentDir
(
)
{
typename
nsTString
<
TChar
>
:
:
const_char_iterator
cursor
=
base
:
:
mCursor
;
if
(
base
:
:
CheckChar
(
'
.
'
)
&
&
base
:
:
CheckChar
(
'
.
'
)
&
&
CheckSeparator
(
)
)
{
return
true
;
}
base
:
:
mCursor
=
cursor
;
return
false
;
}
bool
CheckCurrentDir
(
)
{
typename
nsTString
<
TChar
>
:
:
const_char_iterator
cursor
=
base
:
:
mCursor
;
if
(
base
:
:
CheckChar
(
'
.
'
)
&
&
CheckSeparator
(
)
)
{
return
true
;
}
base
:
:
mCursor
=
cursor
;
return
false
;
}
bool
CheckSeparator
(
)
{
return
base
:
:
Check
(
mSeparator
)
|
|
base
:
:
CheckEOF
(
)
;
}
Token
const
mSeparator
;
nsTArray
<
nsTDependentSubstring
<
TChar
>
>
mStack
;
}
;
}
bool
IsBlockedUNCPath
(
const
nsAString
&
aFilePath
)
{
typedef
TNormalizer
<
char16_t
>
Normalizer
;
if
(
!
sBlockUNCPaths
)
{
return
false
;
}
if
(
!
StringBeginsWith
(
aFilePath
NS_LITERAL_STRING
(
"
\
\
\
\
"
)
)
)
{
return
false
;
}
nsAutoString
normalized
;
if
(
!
Normalizer
(
aFilePath
Normalizer
:
:
Token
:
:
Char
(
'
\
\
'
)
)
.
Get
(
normalized
)
)
{
return
true
;
}
for
(
const
auto
&
allowedPrefix
:
PathWhitelist
(
)
)
{
if
(
StringBeginsWith
(
normalized
allowedPrefix
)
)
{
if
(
normalized
.
Length
(
)
=
=
allowedPrefix
.
Length
(
)
)
{
return
false
;
}
if
(
normalized
[
allowedPrefix
.
Length
(
)
]
=
=
L
'
\
\
'
)
{
return
false
;
}
break
;
}
}
return
true
;
}
#
ifdef
XP_WIN
const
char
kPathSeparator
=
'
\
\
'
;
#
else
const
char
kPathSeparator
=
'
/
'
;
#
endif
bool
IsAllowedPath
(
const
nsTSubstring
<
char_path_t
>
&
aFilePath
)
{
typedef
TNormalizer
<
char_path_t
>
Normalizer
;
if
(
!
sBlacklist
)
{
return
true
;
}
if
(
PathBlacklist
(
)
.
Length
(
)
=
=
0
)
{
return
true
;
}
nsTAutoString
<
char_path_t
>
normalized
;
if
(
!
Normalizer
(
aFilePath
Normalizer
:
:
Token
:
:
Char
(
kPathSeparator
)
)
.
Get
(
normalized
)
)
{
return
false
;
}
for
(
const
auto
&
prefix
:
PathBlacklist
(
)
)
{
if
(
StringBeginsWith
(
normalized
prefix
)
)
{
if
(
normalized
.
Length
(
)
>
prefix
.
Length
(
)
&
&
normalized
[
prefix
.
Length
(
)
]
!
=
kPathSeparator
)
{
continue
;
}
return
false
;
}
}
return
true
;
}
void
testing
:
:
SetBlockUNCPaths
(
bool
aBlock
)
{
sBlockUNCPaths
=
aBlock
;
}
void
testing
:
:
AddDirectoryToWhitelist
(
nsAString
const
&
aPath
)
{
PathWhitelist
(
)
.
AppendElement
(
aPath
)
;
}
bool
testing
:
:
NormalizePath
(
nsAString
const
&
aPath
nsAString
&
aNormalized
)
{
typedef
TNormalizer
<
char16_t
>
Normalizer
;
Normalizer
normalizer
(
aPath
Normalizer
:
:
Token
:
:
Char
(
'
\
\
'
)
)
;
return
normalizer
.
Get
(
aNormalized
)
;
}
}
}
