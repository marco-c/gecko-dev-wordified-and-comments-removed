#
include
"
FilePreferences
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
namespace
mozilla
{
namespace
FilePreferences
{
static
bool
sBlockUNCPaths
=
false
;
typedef
nsTArray
<
nsString
>
Paths
;
static
Paths
&
PathArray
(
)
{
static
Paths
sPaths
;
return
sPaths
;
}
static
void
AllowDirectory
(
char
const
*
directory
)
{
nsCOMPtr
<
nsIFile
>
file
;
NS_GetSpecialDirectory
(
directory
getter_AddRefs
(
file
)
)
;
if
(
!
file
)
{
return
;
}
nsString
path
;
if
(
NS_FAILED
(
file
-
>
GetTarget
(
path
)
)
)
{
return
;
}
if
(
!
StringBeginsWith
(
path
NS_LITERAL_STRING
(
"
\
\
\
\
"
)
)
)
{
return
;
}
if
(
!
PathArray
(
)
.
Contains
(
path
)
)
{
PathArray
(
)
.
AppendElement
(
path
)
;
}
}
void
InitPrefs
(
)
{
sBlockUNCPaths
=
Preferences
:
:
GetBool
(
"
network
.
file
.
disable_unc_paths
"
false
)
;
}
void
InitDirectoriesWhitelist
(
)
{
AllowDirectory
(
NS_GRE_DIR
)
;
AllowDirectory
(
NS_APP_USER_PROFILE_50_DIR
)
;
AllowDirectory
(
NS_APP_USER_PROFILE_LOCAL_50_DIR
)
;
}
namespace
{
class
Normalizer
:
public
Tokenizer16
{
public
:
Normalizer
(
const
nsAString
&
aFilePath
const
Token
&
aSeparator
)
;
bool
Get
(
nsAString
&
aNormalizedFilePath
)
;
private
:
bool
ConsumeName
(
)
;
bool
CheckParentDir
(
)
;
bool
CheckCurrentDir
(
)
;
bool
CheckSeparator
(
)
;
Token
const
mSeparator
;
nsTArray
<
nsDependentSubstring
>
mStack
;
}
;
Normalizer
:
:
Normalizer
(
const
nsAString
&
aFilePath
const
Token
&
aSeparator
)
:
Tokenizer16
(
aFilePath
)
mSeparator
(
aSeparator
)
{
}
bool
Normalizer
:
:
Get
(
nsAString
&
aNormalizedFilePath
)
{
aNormalizedFilePath
.
Truncate
(
)
;
if
(
Check
(
mSeparator
)
)
{
aNormalizedFilePath
.
Append
(
mSeparator
.
AsChar
(
)
)
;
}
if
(
Check
(
mSeparator
)
)
{
aNormalizedFilePath
.
Append
(
mSeparator
.
AsChar
(
)
)
;
}
if
(
!
ConsumeName
(
)
)
{
return
false
;
}
for
(
auto
const
&
name
:
mStack
)
{
aNormalizedFilePath
.
Append
(
name
)
;
}
return
true
;
}
bool
Normalizer
:
:
ConsumeName
(
)
{
if
(
!
HasInput
(
)
|
|
CheckEOF
(
)
)
{
return
true
;
}
if
(
CheckCurrentDir
(
)
)
{
return
ConsumeName
(
)
;
}
if
(
CheckParentDir
(
)
)
{
if
(
!
mStack
.
Length
(
)
)
{
return
false
;
}
mStack
.
RemoveLastElement
(
)
;
return
ConsumeName
(
)
;
}
nsDependentSubstring
name
;
if
(
ReadUntil
(
mSeparator
name
INCLUDE_LAST
)
&
&
name
.
Length
(
)
=
=
1
)
{
return
false
;
}
mStack
.
AppendElement
(
name
)
;
return
ConsumeName
(
)
;
}
bool
Normalizer
:
:
CheckCurrentDir
(
)
{
nsString
:
:
const_char_iterator
cursor
=
mCursor
;
if
(
CheckChar
(
'
.
'
)
&
&
CheckSeparator
(
)
)
{
return
true
;
}
mCursor
=
cursor
;
return
false
;
}
bool
Normalizer
:
:
CheckParentDir
(
)
{
nsString
:
:
const_char_iterator
cursor
=
mCursor
;
if
(
CheckChar
(
'
.
'
)
&
&
CheckChar
(
'
.
'
)
&
&
CheckSeparator
(
)
)
{
return
true
;
}
mCursor
=
cursor
;
return
false
;
}
bool
Normalizer
:
:
CheckSeparator
(
)
{
return
Check
(
mSeparator
)
|
|
CheckEOF
(
)
;
}
}
bool
IsBlockedUNCPath
(
const
nsAString
&
aFilePath
)
{
if
(
!
sBlockUNCPaths
)
{
return
false
;
}
if
(
!
StringBeginsWith
(
aFilePath
NS_LITERAL_STRING
(
"
\
\
\
\
"
)
)
)
{
return
false
;
}
nsAutoString
normalized
;
if
(
!
Normalizer
(
aFilePath
Normalizer
:
:
Token
:
:
Char
(
'
\
\
'
)
)
.
Get
(
normalized
)
)
{
return
true
;
}
for
(
const
auto
&
allowedPrefix
:
PathArray
(
)
)
{
if
(
StringBeginsWith
(
normalized
allowedPrefix
)
)
{
if
(
normalized
.
Length
(
)
=
=
allowedPrefix
.
Length
(
)
)
{
return
false
;
}
if
(
normalized
[
allowedPrefix
.
Length
(
)
]
=
=
L
'
\
\
'
)
{
return
false
;
}
break
;
}
}
return
true
;
}
void
testing
:
:
SetBlockUNCPaths
(
bool
aBlock
)
{
sBlockUNCPaths
=
aBlock
;
}
void
testing
:
:
AddDirectoryToWhitelist
(
nsAString
const
&
aPath
)
{
PathArray
(
)
.
AppendElement
(
aPath
)
;
}
bool
testing
:
:
NormalizePath
(
nsAString
const
&
aPath
nsAString
&
aNormalized
)
{
Normalizer
normalizer
(
aPath
Normalizer
:
:
Token
:
:
Char
(
'
\
\
'
)
)
;
return
normalizer
.
Get
(
aNormalized
)
;
}
}
}
