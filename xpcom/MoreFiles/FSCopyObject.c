#
include
"
FSCopyObject
.
h
"
#
include
<
UnicodeConverter
.
h
>
#
include
<
stddef
.
h
>
#
include
<
string
.
h
>
#
pragma
mark
-
-
-
-
-
Tunable
Parameters
-
-
-
-
-
enum
{
kDefaultCopyBufferSize
=
256L
*
1024
kMaximumCopyBufferSize
=
2L
*
1024
*
1024
kMinimumCopyBufferSize
=
1024
}
;
enum
{
kExpectedForkCount
=
10
}
;
enum
{
errFSDestInsideSource
=
-
1234
}
;
enum
{
kPrivilegesMask
=
kioACAccessUserWriteMask
|
kioACAccessUserReadMask
|
kioACAccessUserSearchMask
kRWXUserAccessMask
=
0x01C0
kReadAccessUser
=
0x0100
kWriteAccessUser
=
0x0080
kExecuteAccessUser
=
0x0040
kRWXGroupAccessMask
=
0x0038
kReadAccessGroup
=
0x0020
kWriteAccessGroup
=
0x0010
kExecuteAccessGroup
=
0x0008
kRWXOtherAccessMask
=
0x0007
kReadAccessOther
=
0x0004
kWriteAccessOther
=
0x0002
kExecuteAccessOther
=
0x0001
kDropFolderValue
=
kWriteAccessOther
|
kExecuteAccessOther
}
;
#
pragma
mark
-
-
-
-
-
Struct
Definitions
-
-
-
-
-
#
define
VolHasCopyFile
(
volParms
)
\
(
(
(
volParms
)
-
>
vMAttrib
&
(
1L
<
<
bHasCopyFile
)
)
!
=
0
)
struct
CopyParams
{
UTCDateTime
magicBusyCreateDate
;
void
*
copyBuffer
;
ByteCount
copyBufferSize
;
Boolean
copyingToDropFolder
;
Boolean
copyingToLocalVolume
;
}
;
typedef
struct
CopyParams
CopyParams
;
struct
FilterParams
{
FSCatalogInfoBitmap
whichInfo
;
CopyObjectFilterProcPtr
filterProcPtr
;
FSSpec
fileSpec
;
FSSpec
*
fileSpecPtr
;
HFSUniStr255
fileName
;
HFSUniStr255
*
fileNamePtr
;
void
*
yourDataPtr
;
}
;
typedef
struct
FilterParams
FilterParams
;
struct
ForkTracker
{
HFSUniStr255
forkName
;
SInt64
forkSize
;
SInt16
forkDestRefNum
;
}
;
typedef
struct
ForkTracker
ForkTracker
;
typedef
ForkTracker
*
ForkTrackerPtr
;
struct
FSCopyObjectGlobals
{
FSCatalogInfo
catalogInfo
;
FSRef
ref
;
FSRef
destRef
;
CopyParams
*
copyParams
;
FilterParams
*
filterParams
;
ItemCount
maxLevels
;
ItemCount
currentLevel
;
Boolean
quitFlag
;
Boolean
containerChanged
;
OSErr
result
;
ItemCount
actualObjects
;
}
;
typedef
struct
FSCopyObjectGlobals
FSCopyObjectGlobals
;
struct
FSDeleteObjectGlobals
{
FSCatalogInfo
catalogInfo
;
ItemCount
actualObjects
;
OSErr
result
;
}
;
typedef
struct
FSDeleteObjectGlobals
FSDeleteObjectGlobals
;
#
pragma
mark
-
-
-
-
-
Local
Prototypes
-
-
-
-
-
static
OSErr
FSCopyFile
(
const
FSRef
*
source
const
FSRef
*
destDir
const
HFSUniStr255
*
destName
CopyParams
*
copyParams
FilterParams
*
filterParams
FSRef
*
newFile
)
;
static
OSErr
CopyFile
(
const
FSRef
*
source
FSCatalogInfo
*
sourceCatInfo
const
FSRef
*
destDir
const
HFSUniStr255
*
destName
CopyParams
*
copyParams
FSRef
*
newRef
)
;
static
OSErr
FSUsePBHCopyFile
(
const
FSRef
*
srcFileRef
const
FSRef
*
dstDirectoryRef
UniCharCount
nameLength
const
UniChar
*
copyName
TextEncoding
textEncodingHint
FSRef
*
newRef
)
;
static
OSErr
DoCopyFile
(
const
FSRef
*
source
FSCatalogInfo
*
sourceCatInfo
const
FSRef
*
destDir
const
HFSUniStr255
*
destName
CopyParams
*
params
FSRef
*
newRef
)
;
static
OSErr
FSCopyFolder
(
const
FSRef
*
source
const
FSRef
*
destDir
const
HFSUniStr255
*
destName
CopyParams
*
copyParams
FilterParams
*
filterParams
ItemCount
maxLevels
FSRef
*
newDir
)
;
static
OSErr
FSCopyFolderLevel
(
FSCopyObjectGlobals
*
theGlobals
const
HFSUniStr255
*
destName
)
;
static
OSErr
CheckForDestInsideSource
(
const
FSRef
*
source
const
FSRef
*
destDir
)
;
static
OSErr
CopyItemsForks
(
const
FSRef
*
source
const
FSRef
*
dest
CopyParams
*
params
)
;
static
OSErr
OpenAllForks
(
const
FSRef
*
dest
const
ForkTrackerPtr
dataFork
const
ForkTrackerPtr
rsrcFork
ForkTrackerPtr
otherForks
ItemCount
otherForksCount
)
;
static
OSErr
CopyFork
(
const
FSRef
*
source
const
FSRef
*
dest
const
ForkTrackerPtr
sourceFork
const
CopyParams
*
params
)
;
static
OSErr
CloseAllForks
(
SInt16
dataRefNum
SInt16
rsrcRefNum
ForkTrackerPtr
otherForks
ItemCount
otherForksCount
)
;
static
OSErr
CalculateForksToCopy
(
const
FSRef
*
source
const
ForkTrackerPtr
dataFork
const
ForkTrackerPtr
rsrcFork
ForkTrackerPtr
*
otherForksParam
ItemCount
*
otherForksCountParam
)
;
static
OSErr
CalculateBufferSize
(
const
FSRef
*
source
const
FSRef
*
destDir
ByteCount
*
bufferSize
)
;
static
ByteCount
BufferSizeForThisVolume
(
FSVolumeRefNum
vRefNum
)
;
static
ByteCount
BufferSizeForThisVolumeSpeed
(
UInt32
volumeBytesPerSecond
)
;
static
OSErr
IsDropBox
(
const
FSRef
*
source
Boolean
*
isDropBox
)
;
static
OSErr
GetMagicBusyCreationDate
(
UTCDateTime
*
date
)
;
static
Boolean
CompareHFSUniStr255
(
const
HFSUniStr255
*
lhs
const
HFSUniStr255
*
rhs
)
;
static
OSErr
FSGetVRefNum
(
const
FSRef
*
ref
FSVolumeRefNum
*
vRefNum
)
;
static
OSErr
FSGetVolParms
(
FSVolumeRefNum
volRefNum
UInt32
bufferSize
GetVolParmsInfoBuffer
*
volParmsInfo
UInt32
*
actualInfoSize
)
;
static
OSErr
UnicodeNameGetHFSName
(
UniCharCount
nameLength
const
UniChar
*
name
TextEncoding
textEncodingHint
Boolean
isVolumeName
Str31
hfsName
)
;
static
OSErr
FSMakeFSRef
(
FSVolumeRefNum
volRefNum
SInt32
dirID
ConstStr255Param
name
FSRef
*
ref
)
;
static
OSErr
FSDeleteFolder
(
const
FSRef
*
container
)
;
static
void
FSDeleteFolderLevel
(
const
FSRef
*
container
FSDeleteObjectGlobals
*
theGlobals
)
;
#
pragma
mark
-
-
-
-
-
Copy
Objects
-
-
-
-
-
OSErr
FSCopyObject
(
const
FSRef
*
source
const
FSRef
*
destDir
UniCharCount
nameLength
const
UniChar
*
copyName
ItemCount
maxLevels
FSCatalogInfoBitmap
whichInfo
Boolean
wantFSSpec
Boolean
wantName
CopyObjectFilterProcPtr
filterProcPtr
void
*
yourDataPtr
FSRef
*
newObject
)
{
CopyParams
copyParams
;
FilterParams
filterParams
;
HFSUniStr255
destName
;
HFSUniStr255
*
destNamePtr
;
Boolean
isDirectory
;
OSErr
osErr
=
(
source
!
=
NULL
&
&
destDir
!
=
NULL
)
?
noErr
:
paramErr
;
if
(
copyName
)
{
if
(
nameLength
<
=
255
)
{
BlockMoveData
(
copyName
destName
.
unicode
nameLength
*
sizeof
(
UniChar
)
)
;
destName
.
length
=
nameLength
;
destNamePtr
=
&
destName
;
}
else
osErr
=
paramErr
;
}
else
destNamePtr
=
NULL
;
filterParams
.
whichInfo
=
whichInfo
|
kFSCatInfoSettableInfo
;
filterParams
.
filterProcPtr
=
filterProcPtr
;
filterParams
.
fileSpecPtr
=
(
wantFSSpec
)
?
&
filterParams
.
fileSpec
:
NULL
;
filterParams
.
fileNamePtr
=
(
wantName
)
?
&
filterParams
.
fileName
:
NULL
;
filterParams
.
yourDataPtr
=
yourDataPtr
;
if
(
osErr
=
=
noErr
)
osErr
=
CalculateBufferSize
(
source
destDir
&
copyParams
.
copyBufferSize
)
;
if
(
osErr
=
=
noErr
)
{
copyParams
.
copyBuffer
=
NewPtr
(
copyParams
.
copyBufferSize
)
;
if
(
copyParams
.
copyBuffer
=
=
NULL
)
osErr
=
memFullErr
;
}
if
(
osErr
=
=
noErr
)
osErr
=
GetMagicBusyCreationDate
(
&
copyParams
.
magicBusyCreateDate
)
;
if
(
osErr
=
=
noErr
)
{
GetVolParmsInfoBuffer
volParms
;
FSCatalogInfo
tmpCatInfo
;
FSVolumeRefNum
destVRefNum
;
osErr
=
FSGetCatalogInfo
(
source
kFSCatInfoNodeFlags
&
tmpCatInfo
NULL
NULL
NULL
)
;
if
(
osErr
=
=
noErr
)
{
isDirectory
=
(
(
tmpCatInfo
.
nodeFlags
&
kFSNodeIsDirectoryMask
)
!
=
0
)
;
osErr
=
IsDropBox
(
destDir
&
copyParams
.
copyingToDropFolder
)
;
}
if
(
osErr
=
=
noErr
)
osErr
=
FSGetVRefNum
(
destDir
&
destVRefNum
)
;
if
(
osErr
=
=
noErr
)
osErr
=
FSGetVolParms
(
destVRefNum
sizeof
(
volParms
)
&
volParms
NULL
)
;
if
(
osErr
=
=
noErr
)
copyParams
.
copyingToLocalVolume
=
(
volParms
.
vMServerAdr
=
=
0
)
;
}
if
(
osErr
=
=
noErr
)
{
if
(
isDirectory
)
{
osErr
=
CheckForDestInsideSource
(
source
destDir
)
;
if
(
osErr
=
=
noErr
)
osErr
=
FSCopyFolder
(
source
destDir
destNamePtr
&
copyParams
&
filterParams
maxLevels
newObject
)
;
}
else
osErr
=
FSCopyFile
(
source
destDir
destNamePtr
&
copyParams
&
filterParams
newObject
)
;
}
if
(
copyParams
.
copyBuffer
!
=
NULL
)
DisposePtr
(
(
char
*
)
copyParams
.
copyBuffer
)
;
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
#
pragma
mark
-
-
-
-
-
Copy
Files
-
-
-
-
-
OSErr
FSCopyFile
(
const
FSRef
*
source
const
FSRef
*
destDir
const
HFSUniStr255
*
destName
CopyParams
*
copyParams
FilterParams
*
filterParams
FSRef
*
newFile
)
{
FSCatalogInfo
sourceCatInfo
;
FSRef
tmpRef
;
OSErr
osErr
=
(
source
!
=
NULL
&
&
destDir
!
=
NULL
&
&
copyParams
!
=
NULL
&
&
filterParams
!
=
NULL
)
?
noErr
:
paramErr
;
if
(
osErr
=
=
noErr
)
{
if
(
destName
)
{
osErr
=
FSGetCatalogInfo
(
source
filterParams
-
>
whichInfo
&
sourceCatInfo
NULL
NULL
NULL
)
;
filterParams
-
>
fileName
=
*
destName
;
}
else
osErr
=
FSGetCatalogInfo
(
source
filterParams
-
>
whichInfo
&
sourceCatInfo
&
filterParams
-
>
fileName
NULL
NULL
)
;
}
if
(
osErr
=
=
noErr
)
osErr
=
CopyFile
(
source
&
sourceCatInfo
destDir
&
filterParams
-
>
fileName
copyParams
&
tmpRef
)
;
if
(
filterParams
-
>
filterProcPtr
!
=
NULL
)
{
(
void
)
CallCopyObjectFilterProc
(
filterParams
-
>
filterProcPtr
false
0
osErr
&
sourceCatInfo
&
tmpRef
filterParams
-
>
fileSpecPtr
filterParams
-
>
fileNamePtr
filterParams
-
>
yourDataPtr
)
;
}
if
(
osErr
=
=
noErr
&
&
newFile
!
=
NULL
)
*
newFile
=
tmpRef
;
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
OSErr
CopyFile
(
const
FSRef
*
source
FSCatalogInfo
*
sourceCatInfo
const
FSRef
*
destDir
ConstHFSUniStr255Param
destName
CopyParams
*
params
FSRef
*
newFile
)
{
OSErr
osErr
=
paramErr
;
(
(
FInfo
*
)
(
sourceCatInfo
-
>
finderInfo
)
)
-
>
fdFlags
&
=
~
kHasBeenInited
;
if
(
params
-
>
copyingToLocalVolume
=
=
0
)
osErr
=
FSUsePBHCopyFile
(
source
destDir
0
NULL
kTextEncodingUnknown
newFile
)
;
if
(
osErr
!
=
noErr
)
osErr
=
DoCopyFile
(
source
sourceCatInfo
destDir
destName
params
newFile
)
;
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
OSErr
FSUsePBHCopyFile
(
const
FSRef
*
srcFileRef
const
FSRef
*
dstDirectoryRef
UniCharCount
nameLength
const
UniChar
*
copyName
TextEncoding
textEncodingHint
FSRef
*
newRef
)
{
FSSpec
srcFileSpec
;
FSCatalogInfo
catalogInfo
;
GetVolParmsInfoBuffer
volParmsInfo
;
HParamBlockRec
pb
;
Str31
hfsName
;
OSErr
osErr
;
osErr
=
FSGetCatalogInfo
(
srcFileRef
kFSCatInfoNone
NULL
NULL
&
srcFileSpec
NULL
)
;
if
(
osErr
=
=
noErr
)
osErr
=
FSGetVolParms
(
srcFileSpec
.
vRefNum
sizeof
(
GetVolParmsInfoBuffer
)
&
volParmsInfo
NULL
)
;
if
(
osErr
=
=
noErr
)
osErr
=
VolHasCopyFile
(
&
volParmsInfo
)
?
noErr
:
paramErr
;
if
(
osErr
=
=
noErr
)
osErr
=
FSGetCatalogInfo
(
dstDirectoryRef
kFSCatInfoVolume
|
kFSCatInfoNodeID
&
catalogInfo
NULL
NULL
NULL
)
;
if
(
osErr
=
=
noErr
)
{
pb
.
copyParam
.
ioVRefNum
=
srcFileSpec
.
vRefNum
;
pb
.
copyParam
.
ioDirID
=
srcFileSpec
.
parID
;
pb
.
copyParam
.
ioNamePtr
=
(
StringPtr
)
srcFileSpec
.
name
;
pb
.
copyParam
.
ioDstVRefNum
=
catalogInfo
.
volume
;
pb
.
copyParam
.
ioNewDirID
=
(
long
)
catalogInfo
.
nodeID
;
pb
.
copyParam
.
ioNewName
=
NULL
;
if
(
copyName
!
=
NULL
)
osErr
=
UnicodeNameGetHFSName
(
nameLength
copyName
textEncodingHint
false
hfsName
)
;
pb
.
copyParam
.
ioCopyName
=
(
copyName
!
=
NULL
&
&
osErr
=
=
noErr
)
?
hfsName
:
NULL
;
}
if
(
osErr
=
=
noErr
)
osErr
=
PBHCopyFileSync
(
&
pb
)
;
if
(
osErr
=
=
noErr
&
&
newRef
!
=
NULL
)
{
myverify_noerr
(
FSMakeFSRef
(
pb
.
copyParam
.
ioDstVRefNum
pb
.
copyParam
.
ioNewDirID
pb
.
copyParam
.
ioCopyName
newRef
)
)
;
}
if
(
osErr
!
=
paramErr
)
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
OSErr
DoCopyFile
(
const
FSRef
*
source
FSCatalogInfo
*
sourceCatInfo
const
FSRef
*
destDir
ConstHFSUniStr255Param
destName
CopyParams
*
params
FSRef
*
newRef
)
{
FSRef
dest
;
FSPermissionInfo
originalPermissions
;
UTCDateTime
originalCreateDate
;
OSType
originalFileType
;
UInt16
originalNodeFlags
;
OSErr
osErr
;
if
(
!
params
-
>
copyingToDropFolder
)
{
originalFileType
=
(
(
FInfo
*
)
&
sourceCatInfo
-
>
finderInfo
)
-
>
fdType
;
(
(
FInfo
*
)
&
sourceCatInfo
-
>
finderInfo
)
-
>
fdType
=
kFirstMagicBusyFiletype
;
originalNodeFlags
=
sourceCatInfo
-
>
nodeFlags
;
originalCreateDate
=
sourceCatInfo
-
>
createDate
;
sourceCatInfo
-
>
createDate
=
params
-
>
magicBusyCreateDate
;
}
sourceCatInfo
-
>
nodeFlags
&
=
~
kFSNodeLockedMask
;
originalPermissions
=
*
(
(
FSPermissionInfo
*
)
sourceCatInfo
-
>
permissions
)
;
(
(
FSPermissionInfo
*
)
sourceCatInfo
-
>
permissions
)
-
>
mode
|
=
kRWXUserAccessMask
;
osErr
=
FSCreateFileUnicode
(
destDir
destName
-
>
length
destName
-
>
unicode
kFSCatInfoSettableInfo
sourceCatInfo
&
dest
NULL
)
;
if
(
osErr
=
=
noErr
)
osErr
=
CopyItemsForks
(
source
&
dest
params
)
;
if
(
osErr
=
=
noErr
&
&
!
params
-
>
copyingToDropFolder
)
{
(
(
FInfo
*
)
&
sourceCatInfo
-
>
finderInfo
)
-
>
fdType
=
originalFileType
;
sourceCatInfo
-
>
createDate
=
originalCreateDate
;
sourceCatInfo
-
>
nodeFlags
=
originalNodeFlags
;
*
(
(
FSPermissionInfo
*
)
sourceCatInfo
-
>
permissions
)
=
originalPermissions
;
osErr
=
FSSetCatalogInfo
(
&
dest
kFSCatInfoSettableInfo
sourceCatInfo
)
;
}
if
(
osErr
!
=
noErr
&
&
osErr
!
=
dupFNErr
)
myverify_noerr
(
FSDeleteObjects
(
&
dest
)
)
;
else
if
(
newRef
!
=
NULL
)
*
newRef
=
dest
;
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
#
pragma
mark
-
-
-
-
-
Copy
Folders
-
-
-
-
-
OSErr
FSCopyFolder
(
const
FSRef
*
source
const
FSRef
*
destDir
const
HFSUniStr255
*
destName
CopyParams
*
copyParams
FilterParams
*
filterParams
ItemCount
maxLevels
FSRef
*
newDir
)
{
FSCopyObjectGlobals
theGlobals
;
theGlobals
.
ref
=
*
source
;
theGlobals
.
destRef
=
*
destDir
;
theGlobals
.
copyParams
=
copyParams
;
theGlobals
.
filterParams
=
filterParams
;
theGlobals
.
maxLevels
=
maxLevels
;
theGlobals
.
currentLevel
=
0
;
theGlobals
.
quitFlag
=
false
;
theGlobals
.
containerChanged
=
false
;
theGlobals
.
result
=
(
source
!
=
NULL
&
&
destDir
!
=
NULL
&
&
copyParams
!
=
NULL
&
&
filterParams
!
=
NULL
)
?
noErr
:
paramErr
;
theGlobals
.
actualObjects
=
0
;
if
(
theGlobals
.
result
=
=
noErr
)
theGlobals
.
result
=
FSCopyFolderLevel
(
&
theGlobals
destName
)
;
if
(
theGlobals
.
result
=
=
noErr
&
&
newDir
!
=
NULL
)
*
newDir
=
theGlobals
.
ref
;
if
(
filterParams
-
>
filterProcPtr
!
=
NULL
)
{
(
void
)
CallCopyObjectFilterProc
(
filterParams
-
>
filterProcPtr
theGlobals
.
containerChanged
theGlobals
.
currentLevel
theGlobals
.
result
&
theGlobals
.
catalogInfo
&
theGlobals
.
ref
filterParams
-
>
fileSpecPtr
filterParams
-
>
fileNamePtr
filterParams
-
>
yourDataPtr
)
;
}
mycheck_noerr
(
theGlobals
.
result
)
;
return
(
theGlobals
.
result
)
;
}
OSErr
FSCopyFolderLevel
(
FSCopyObjectGlobals
*
theGlobals
const
HFSUniStr255
*
destName
)
{
if
(
(
theGlobals
-
>
maxLevels
=
=
0
)
|
|
(
theGlobals
-
>
currentLevel
<
theGlobals
-
>
maxLevels
)
)
{
FSRef
newDirRef
;
UTCDateTime
originalCreateDate
;
FSPermissionInfo
originalPermissions
;
FSIterator
iterator
;
FilterParams
*
filterPtr
=
theGlobals
-
>
filterParams
;
theGlobals
-
>
result
=
FSGetCatalogInfo
(
&
theGlobals
-
>
ref
filterPtr
-
>
whichInfo
&
theGlobals
-
>
catalogInfo
&
filterPtr
-
>
fileName
NULL
NULL
)
;
if
(
theGlobals
-
>
currentLevel
=
=
0
&
&
destName
)
filterPtr
-
>
fileName
=
*
destName
;
(
(
FInfo
*
)
(
theGlobals
-
>
catalogInfo
.
finderInfo
)
)
-
>
fdFlags
&
=
~
kHasBeenInited
;
if
(
theGlobals
-
>
result
=
=
noErr
&
&
!
theGlobals
-
>
copyParams
-
>
copyingToDropFolder
)
{
originalCreateDate
=
theGlobals
-
>
catalogInfo
.
createDate
;
theGlobals
-
>
catalogInfo
.
createDate
=
theGlobals
-
>
copyParams
-
>
magicBusyCreateDate
;
}
originalPermissions
=
*
(
(
FSPermissionInfo
*
)
theGlobals
-
>
catalogInfo
.
permissions
)
;
(
(
FSPermissionInfo
*
)
theGlobals
-
>
catalogInfo
.
permissions
)
-
>
mode
|
=
kRWXUserAccessMask
;
if
(
theGlobals
-
>
result
=
=
noErr
)
{
theGlobals
-
>
result
=
FSCreateDirectoryUnicode
(
&
theGlobals
-
>
destRef
filterPtr
-
>
fileName
.
length
filterPtr
-
>
fileName
.
unicode
kFSCatInfoSettableInfo
&
theGlobals
-
>
catalogInfo
&
newDirRef
&
filterPtr
-
>
fileSpec
NULL
)
;
}
+
+
theGlobals
-
>
currentLevel
;
if
(
theGlobals
-
>
result
=
=
noErr
)
theGlobals
-
>
result
=
CopyItemsForks
(
&
theGlobals
-
>
ref
&
newDirRef
theGlobals
-
>
copyParams
)
;
if
(
theGlobals
-
>
result
=
=
noErr
)
theGlobals
-
>
result
=
FSOpenIterator
(
&
theGlobals
-
>
ref
kFSIterateFlat
&
iterator
)
;
if
(
theGlobals
-
>
result
=
=
noErr
)
{
OSErr
osErr
;
do
{
theGlobals
-
>
result
=
FSGetCatalogInfoBulk
(
iterator
1
&
theGlobals
-
>
actualObjects
&
theGlobals
-
>
containerChanged
filterPtr
-
>
whichInfo
&
theGlobals
-
>
catalogInfo
&
theGlobals
-
>
ref
filterPtr
-
>
fileSpecPtr
&
filterPtr
-
>
fileName
)
;
if
(
(
(
theGlobals
-
>
result
=
=
noErr
)
|
|
(
theGlobals
-
>
result
=
=
errFSNoMoreItems
)
)
&
&
(
theGlobals
-
>
actualObjects
!
=
0
)
)
{
if
(
(
theGlobals
-
>
catalogInfo
.
nodeFlags
&
kFSNodeIsDirectoryMask
)
!
=
0
)
{
theGlobals
-
>
destRef
=
newDirRef
;
osErr
=
FSCopyFolderLevel
(
theGlobals
NULL
)
;
theGlobals
-
>
result
=
noErr
;
}
else
{
osErr
=
CopyFile
(
&
theGlobals
-
>
ref
&
theGlobals
-
>
catalogInfo
&
newDirRef
&
filterPtr
-
>
fileName
theGlobals
-
>
copyParams
&
theGlobals
-
>
ref
)
;
}
if
(
filterPtr
-
>
filterProcPtr
!
=
NULL
&
&
!
theGlobals
-
>
quitFlag
)
{
theGlobals
-
>
quitFlag
=
CallCopyObjectFilterProc
(
filterPtr
-
>
filterProcPtr
theGlobals
-
>
containerChanged
theGlobals
-
>
currentLevel
osErr
&
theGlobals
-
>
catalogInfo
&
theGlobals
-
>
ref
filterPtr
-
>
fileSpecPtr
filterPtr
-
>
fileNamePtr
filterPtr
-
>
yourDataPtr
)
;
}
}
}
while
(
(
theGlobals
-
>
result
=
=
noErr
)
&
&
(
!
theGlobals
-
>
quitFlag
)
)
;
(
void
)
FSCloseIterator
(
iterator
)
;
}
if
(
(
theGlobals
-
>
result
=
=
errFSNoMoreItems
)
|
|
(
theGlobals
-
>
result
=
=
afpAccessDenied
)
)
theGlobals
-
>
result
=
noErr
;
if
(
theGlobals
-
>
result
=
=
noErr
)
{
theGlobals
-
>
ref
=
newDirRef
;
theGlobals
-
>
result
=
FSGetCatalogInfo
(
&
newDirRef
kFSCatInfoNone
NULL
&
filterPtr
-
>
fileName
&
filterPtr
-
>
fileSpec
NULL
)
;
}
-
-
theGlobals
-
>
currentLevel
;
if
(
theGlobals
-
>
result
=
=
noErr
&
&
!
theGlobals
-
>
copyParams
-
>
copyingToDropFolder
)
{
theGlobals
-
>
catalogInfo
.
createDate
=
originalCreateDate
;
*
(
(
FSPermissionInfo
*
)
theGlobals
-
>
catalogInfo
.
permissions
)
=
originalPermissions
;
theGlobals
-
>
result
=
FSSetCatalogInfo
(
&
newDirRef
kFSCatInfoCreateDate
|
kFSCatInfoAttrMod
|
kFSCatInfoContentMod
|
kFSCatInfoPermissions
&
theGlobals
-
>
catalogInfo
)
;
}
if
(
theGlobals
-
>
result
!
=
noErr
&
&
theGlobals
-
>
result
!
=
dupFNErr
)
myverify_noerr
(
FSDeleteObjects
(
&
newDirRef
)
)
;
}
mycheck_noerr
(
theGlobals
-
>
result
)
;
return
theGlobals
-
>
result
;
}
OSErr
CheckForDestInsideSource
(
const
FSRef
*
source
const
FSRef
*
destDir
)
{
FSRef
thisDir
=
*
destDir
;
FSCatalogInfo
thisDirInfo
;
Boolean
done
=
false
;
OSErr
osErr
;
do
{
osErr
=
FSCompareFSRefs
(
source
&
thisDir
)
;
if
(
osErr
=
=
noErr
)
osErr
=
errFSDestInsideSource
;
else
if
(
osErr
=
=
diffVolErr
)
{
osErr
=
noErr
;
done
=
true
;
}
else
if
(
osErr
=
=
errFSRefsDifferent
)
{
osErr
=
FSGetCatalogInfo
(
&
thisDir
kFSCatInfoParentDirID
&
thisDirInfo
NULL
NULL
&
thisDir
)
;
if
(
(
osErr
=
=
noErr
)
&
&
(
thisDirInfo
.
parentDirID
=
=
fsRtParID
)
)
done
=
true
;
}
}
while
(
osErr
=
=
noErr
&
&
!
done
)
;
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
#
pragma
mark
-
-
-
-
-
Copy
Forks
-
-
-
-
-
OSErr
CopyItemsForks
(
const
FSRef
*
source
const
FSRef
*
dest
CopyParams
*
params
)
{
ForkTracker
dataFork
rsrcFork
;
ForkTrackerPtr
otherForks
;
ItemCount
otherForksCount
thisForkIndex
;
OSErr
osErr
;
dataFork
.
forkDestRefNum
=
0
;
rsrcFork
.
forkDestRefNum
=
0
;
otherForks
=
NULL
;
otherForksCount
=
0
;
osErr
=
FSGetDataForkName
(
&
dataFork
.
forkName
)
;
if
(
osErr
=
=
noErr
)
osErr
=
FSGetResourceForkName
(
&
rsrcFork
.
forkName
)
;
if
(
osErr
=
=
noErr
)
osErr
=
CalculateForksToCopy
(
source
&
dataFork
&
rsrcFork
&
otherForks
&
otherForksCount
)
;
if
(
osErr
=
=
noErr
)
{
if
(
params
-
>
copyingToDropFolder
)
osErr
=
OpenAllForks
(
dest
&
dataFork
&
rsrcFork
otherForks
otherForksCount
)
;
if
(
osErr
=
=
noErr
&
&
(
dataFork
.
forkSize
!
=
0
)
)
osErr
=
CopyFork
(
source
dest
&
dataFork
params
)
;
if
(
osErr
=
=
noErr
&
&
(
rsrcFork
.
forkSize
!
=
0
)
)
osErr
=
CopyFork
(
source
dest
&
rsrcFork
params
)
;
if
(
osErr
=
=
noErr
)
{
for
(
thisForkIndex
=
0
;
thisForkIndex
<
otherForksCount
&
&
osErr
=
=
noErr
;
thisForkIndex
+
+
)
osErr
=
CopyFork
(
source
dest
&
otherForks
[
thisForkIndex
]
params
)
;
}
{
OSErr
osErr2
=
CloseAllForks
(
dataFork
.
forkDestRefNum
rsrcFork
.
forkDestRefNum
otherForks
otherForksCount
)
;
mycheck_noerr
(
osErr2
)
;
if
(
osErr
=
=
noErr
)
osErr
=
osErr2
;
}
}
if
(
otherForks
!
=
NULL
)
DisposePtr
(
(
char
*
)
otherForks
)
;
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
OSErr
OpenAllForks
(
const
FSRef
*
dest
const
ForkTrackerPtr
dataFork
const
ForkTrackerPtr
rsrcFork
ForkTrackerPtr
otherForks
ItemCount
otherForksCount
)
{
ItemCount
thisForkIndex
;
OSErr
osErr
=
noErr
;
if
(
dataFork
-
>
forkSize
!
=
0
)
osErr
=
FSOpenFork
(
dest
dataFork
-
>
forkName
.
length
dataFork
-
>
forkName
.
unicode
fsWrPerm
&
dataFork
-
>
forkDestRefNum
)
;
if
(
osErr
=
=
noErr
&
&
rsrcFork
-
>
forkSize
!
=
0
)
osErr
=
FSOpenFork
(
dest
rsrcFork
-
>
forkName
.
length
rsrcFork
-
>
forkName
.
unicode
fsWrPerm
&
rsrcFork
-
>
forkDestRefNum
)
;
if
(
osErr
=
=
noErr
&
&
otherForks
!
=
NULL
&
&
otherForksCount
>
0
)
{
for
(
thisForkIndex
=
0
;
thisForkIndex
<
otherForksCount
&
&
osErr
=
=
noErr
;
thisForkIndex
+
+
)
{
osErr
=
FSCreateFork
(
dest
otherForks
[
thisForkIndex
]
.
forkName
.
length
otherForks
[
thisForkIndex
]
.
forkName
.
unicode
)
;
if
(
osErr
=
=
noErr
|
|
osErr
=
=
afpAccessDenied
)
osErr
=
noErr
;
if
(
osErr
=
=
noErr
)
osErr
=
FSOpenFork
(
dest
otherForks
[
thisForkIndex
]
.
forkName
.
length
otherForks
[
thisForkIndex
]
.
forkName
.
unicode
fsWrPerm
&
otherForks
[
thisForkIndex
]
.
forkDestRefNum
)
;
}
}
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
OSErr
CopyFork
(
const
FSRef
*
source
const
FSRef
*
dest
const
ForkTrackerPtr
sourceFork
const
CopyParams
*
params
)
{
UInt64
bytesRemaining
;
UInt64
bytesToReadThisTime
;
UInt64
bytesToWriteThisTime
;
SInt16
sourceRef
;
SInt16
destRef
;
OSErr
osErr
=
noErr
;
OSErr
osErr2
=
noErr
;
if
(
sourceFork
-
>
forkDestRefNum
=
=
0
)
{
osErr
=
FSCreateFork
(
dest
sourceFork
-
>
forkName
.
length
sourceFork
-
>
forkName
.
unicode
)
;
if
(
osErr
=
=
errFSForkExists
&
&
!
params
-
>
copyingToLocalVolume
)
osErr
=
noErr
;
}
if
(
osErr
=
=
noErr
&
&
sourceFork
-
>
forkSize
!
=
0
)
{
sourceRef
=
0
;
destRef
=
0
;
if
(
sourceFork
-
>
forkDestRefNum
=
=
0
)
osErr
=
FSOpenFork
(
dest
sourceFork
-
>
forkName
.
length
sourceFork
-
>
forkName
.
unicode
fsWrPerm
&
destRef
)
;
else
destRef
=
sourceFork
-
>
forkDestRefNum
;
if
(
osErr
=
=
noErr
)
osErr
=
FSOpenFork
(
source
sourceFork
-
>
forkName
.
length
sourceFork
-
>
forkName
.
unicode
fsRdPerm
&
sourceRef
)
;
if
(
osErr
=
=
noErr
)
osErr
=
FSAllocateFork
(
destRef
kFSAllocNoRoundUpMask
fsFromStart
0
sourceFork
-
>
forkSize
NULL
)
;
bytesRemaining
=
sourceFork
-
>
forkSize
;
while
(
osErr
=
=
noErr
&
&
bytesRemaining
!
=
0
)
{
if
(
bytesRemaining
>
params
-
>
copyBufferSize
)
{
bytesToReadThisTime
=
params
-
>
copyBufferSize
;
bytesToWriteThisTime
=
bytesToReadThisTime
;
}
else
{
bytesToReadThisTime
=
bytesRemaining
;
bytesToWriteThisTime
=
(
params
-
>
copyingToLocalVolume
)
?
(
bytesRemaining
+
0x01FF
)
&
~
0x01FF
:
bytesRemaining
;
}
osErr
=
FSReadFork
(
sourceRef
fsAtMark
+
noCacheMask
0
bytesToReadThisTime
params
-
>
copyBuffer
NULL
)
;
if
(
osErr
=
=
noErr
)
osErr
=
FSWriteFork
(
destRef
fsAtMark
+
noCacheMask
0
bytesToWriteThisTime
params
-
>
copyBuffer
NULL
)
;
if
(
osErr
=
=
noErr
)
bytesRemaining
-
=
bytesToReadThisTime
;
}
if
(
osErr
=
=
noErr
&
&
(
params
-
>
copyingToLocalVolume
&
&
(
(
sourceFork
-
>
forkSize
&
0x01FF
)
!
=
0
)
)
)
osErr
=
FSSetForkSize
(
destRef
fsFromStart
sourceFork
-
>
forkSize
)
;
if
(
sourceRef
!
=
0
)
{
osErr2
=
FSCloseFork
(
sourceRef
)
;
mycheck_noerr
(
osErr2
)
;
if
(
osErr
=
=
noErr
)
osErr
=
osErr2
;
}
if
(
sourceFork
-
>
forkDestRefNum
=
=
0
&
&
destRef
!
=
0
)
{
osErr2
=
FSCloseFork
(
destRef
)
;
mycheck_noerr
(
osErr2
)
;
if
(
osErr
=
=
noErr
)
osErr
=
osErr2
;
}
}
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
OSErr
CloseAllForks
(
SInt16
dataRefNum
SInt16
rsrcRefNum
ForkTrackerPtr
otherForks
ItemCount
otherForksCount
)
{
ItemCount
thisForkIndex
;
OSErr
osErr
=
noErr
osErr2
;
if
(
dataRefNum
!
=
0
)
{
osErr2
=
FSCloseFork
(
dataRefNum
)
;
mycheck_noerr
(
osErr2
)
;
if
(
osErr
=
=
noErr
)
osErr
=
osErr2
;
}
if
(
rsrcRefNum
!
=
0
)
{
osErr2
=
FSCloseFork
(
rsrcRefNum
)
;
mycheck_noerr
(
osErr2
)
;
if
(
osErr
=
=
noErr
)
osErr
=
osErr2
;
}
if
(
otherForks
!
=
NULL
&
&
otherForksCount
>
0
)
{
for
(
thisForkIndex
=
0
;
thisForkIndex
<
otherForksCount
;
thisForkIndex
+
+
)
{
if
(
otherForks
[
thisForkIndex
]
.
forkDestRefNum
!
=
0
)
{
osErr2
=
FSCloseFork
(
otherForks
[
thisForkIndex
]
.
forkDestRefNum
)
;
mycheck_noerr
(
osErr2
)
;
if
(
osErr
=
=
noErr
)
osErr
=
osErr2
;
}
}
}
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
OSErr
CalculateForksToCopy
(
const
FSRef
*
source
const
ForkTrackerPtr
dataFork
const
ForkTrackerPtr
rsrcFork
ForkTrackerPtr
*
otherForksParam
ItemCount
*
otherForksCountParam
)
{
Boolean
done
;
CatPositionRec
iterator
;
HFSUniStr255
thisForkName
;
SInt64
thisForkSize
;
ForkTrackerPtr
otherForks
;
ItemCount
otherForksCount
;
ItemCount
otherForksMemoryBlockCount
;
OSErr
osErr
=
(
(
source
!
=
NULL
)
&
&
(
dataFork
!
=
NULL
)
&
&
(
rsrcFork
!
=
NULL
)
&
&
(
otherForksParam
!
=
NULL
)
&
&
(
otherForksCountParam
!
=
NULL
)
)
?
noErr
:
paramErr
;
dataFork
-
>
forkSize
=
0
;
rsrcFork
-
>
forkSize
=
0
;
otherForks
=
NULL
;
otherForksCount
=
0
;
iterator
.
initialize
=
0
;
done
=
false
;
while
(
osErr
=
=
noErr
&
&
!
done
)
{
osErr
=
FSIterateForks
(
source
&
iterator
&
thisForkName
&
thisForkSize
NULL
)
;
if
(
osErr
=
=
errFSNoMoreItems
)
{
osErr
=
noErr
;
done
=
true
;
}
else
if
(
osErr
=
=
noErr
)
{
if
(
CompareHFSUniStr255
(
&
thisForkName
&
dataFork
-
>
forkName
)
)
dataFork
-
>
forkSize
=
thisForkSize
;
else
if
(
CompareHFSUniStr255
(
&
thisForkName
&
rsrcFork
-
>
forkName
)
)
rsrcFork
-
>
forkSize
=
thisForkSize
;
else
{
if
(
otherForks
=
=
NULL
)
{
otherForksMemoryBlockCount
=
kExpectedForkCount
;
otherForks
=
(
ForkTracker
*
)
NewPtr
(
sizeof
(
ForkTracker
)
*
kExpectedForkCount
)
;
if
(
otherForks
=
=
NULL
)
osErr
=
memFullErr
;
}
else
if
(
otherForksCount
=
=
otherForksMemoryBlockCount
)
{
ForkTrackerPtr
newOtherForks
;
newOtherForks
=
(
ForkTracker
*
)
NewPtr
(
sizeof
(
ForkTracker
)
*
(
otherForksCount
+
kExpectedForkCount
)
)
;
if
(
newOtherForks
!
=
NULL
)
{
BlockMoveData
(
otherForks
newOtherForks
sizeof
(
ForkTracker
)
*
otherForksCount
)
;
otherForksMemoryBlockCount
+
=
kExpectedForkCount
;
DisposePtr
(
(
char
*
)
otherForks
)
;
otherForks
=
newOtherForks
;
}
else
osErr
=
memFullErr
;
}
if
(
osErr
=
=
noErr
)
{
BlockMoveData
(
&
thisForkName
&
otherForks
[
otherForksCount
]
.
forkName
sizeof
(
thisForkName
)
)
;
otherForks
[
otherForksCount
]
.
forkSize
=
thisForkSize
;
otherForks
[
otherForksCount
]
.
forkDestRefNum
=
0
;
+
+
otherForksCount
;
}
}
}
}
if
(
osErr
!
=
noErr
)
{
if
(
otherForks
!
=
NULL
)
{
DisposePtr
(
(
char
*
)
otherForks
)
;
otherForks
=
NULL
;
}
otherForksCount
=
0
;
}
*
otherForksParam
=
otherForks
;
*
otherForksCountParam
=
otherForksCount
;
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
#
pragma
mark
-
-
-
-
-
Calculate
Buffer
Size
-
-
-
-
-
OSErr
CalculateBufferSize
(
const
FSRef
*
source
const
FSRef
*
destDir
ByteCount
*
bufferSize
)
{
FSVolumeRefNum
sourceVRefNum
destVRefNum
;
ByteCount
tmpBufferSize
=
0
;
OSErr
osErr
=
(
source
!
=
NULL
&
&
destDir
!
=
NULL
&
&
bufferSize
!
=
NULL
)
?
noErr
:
paramErr
;
if
(
osErr
=
=
noErr
)
osErr
=
FSGetVRefNum
(
source
&
sourceVRefNum
)
;
if
(
osErr
=
=
noErr
)
osErr
=
FSGetVRefNum
(
destDir
&
destVRefNum
)
;
if
(
osErr
=
=
noErr
)
{
tmpBufferSize
=
BufferSizeForThisVolume
(
sourceVRefNum
)
;
if
(
destVRefNum
!
=
sourceVRefNum
)
{
ByteCount
tmp
=
BufferSizeForThisVolume
(
destVRefNum
)
;
if
(
tmp
<
tmpBufferSize
)
tmpBufferSize
=
tmp
;
}
}
*
bufferSize
=
tmpBufferSize
;
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
ByteCount
BufferSizeForThisVolume
(
FSVolumeRefNum
vRefNum
)
{
GetVolParmsInfoBuffer
volParms
;
ByteCount
volumeBytesPerSecond
=
0
;
UInt32
actualSize
;
OSErr
osErr
;
osErr
=
FSGetVolParms
(
vRefNum
sizeof
(
volParms
)
&
volParms
&
actualSize
)
;
if
(
osErr
=
=
noErr
)
{
mycheck
(
actualSize
>
=
offsetof
(
GetVolParmsInfoBuffer
vMVolumeGrade
)
)
;
if
(
(
actualSize
>
=
offsetof
(
GetVolParmsInfoBuffer
vMForeignPrivID
)
)
&
&
(
volParms
.
vMVolumeGrade
<
=
0
)
)
{
volumeBytesPerSecond
=
-
volParms
.
vMVolumeGrade
;
}
}
mycheck_noerr
(
osErr
)
;
return
BufferSizeForThisVolumeSpeed
(
volumeBytesPerSecond
)
;
}
ByteCount
BufferSizeForThisVolumeSpeed
(
UInt32
volumeBytesPerSecond
)
{
ByteCount
bufferSize
;
if
(
volumeBytesPerSecond
=
=
0
)
bufferSize
=
kDefaultCopyBufferSize
;
else
{
bufferSize
=
volumeBytesPerSecond
/
4
;
}
bufferSize
&
=
~
0x01FF
;
if
(
bufferSize
<
kMinimumCopyBufferSize
)
bufferSize
=
kMinimumCopyBufferSize
;
else
if
(
bufferSize
>
kMaximumCopyBufferSize
)
bufferSize
=
kMaximumCopyBufferSize
;
return
bufferSize
;
}
#
pragma
mark
-
-
-
-
-
Delete
Objects
-
-
-
-
-
OSErr
FSDeleteObjects
(
const
FSRef
*
source
)
{
FSCatalogInfo
catalogInfo
;
OSErr
osErr
=
(
source
!
=
NULL
)
?
noErr
:
paramErr
;
if
(
osErr
=
=
noErr
)
osErr
=
FSGetCatalogInfo
(
source
kFSCatInfoNodeFlags
&
catalogInfo
NULL
NULL
NULL
)
;
if
(
osErr
=
=
noErr
&
&
(
catalogInfo
.
nodeFlags
&
kFSNodeIsDirectoryMask
)
!
=
0
)
{
osErr
=
FSDeleteFolder
(
source
)
;
}
if
(
osErr
=
=
noErr
&
&
(
catalogInfo
.
nodeFlags
&
kFSNodeLockedMask
)
!
=
0
)
{
catalogInfo
.
nodeFlags
&
=
~
kFSNodeLockedMask
;
(
void
)
FSSetCatalogInfo
(
source
kFSCatInfoNodeFlags
&
catalogInfo
)
;
}
if
(
osErr
=
=
noErr
)
osErr
=
FSDeleteObject
(
source
)
;
mycheck_noerr
(
osErr
)
;
return
(
osErr
)
;
}
#
pragma
mark
-
-
-
-
-
Delete
Folders
-
-
-
-
-
OSErr
FSDeleteFolder
(
const
FSRef
*
container
)
{
FSDeleteObjectGlobals
theGlobals
;
theGlobals
.
result
=
(
container
!
=
NULL
)
?
noErr
:
paramErr
;
if
(
theGlobals
.
result
=
=
noErr
)
FSDeleteFolderLevel
(
container
&
theGlobals
)
;
mycheck_noerr
(
theGlobals
.
result
)
;
return
(
theGlobals
.
result
)
;
}
void
FSDeleteFolderLevel
(
const
FSRef
*
container
FSDeleteObjectGlobals
*
theGlobals
)
{
FSIterator
iterator
;
FSRef
itemToDelete
;
UInt16
nodeFlags
;
theGlobals
-
>
result
=
FSOpenIterator
(
container
kFSIterateFlat
+
kFSIterateDelete
&
iterator
)
;
if
(
theGlobals
-
>
result
=
=
noErr
)
{
do
{
theGlobals
-
>
result
=
FSGetCatalogInfoBulk
(
iterator
1
&
theGlobals
-
>
actualObjects
NULL
kFSCatInfoNodeFlags
&
theGlobals
-
>
catalogInfo
&
itemToDelete
NULL
NULL
)
;
if
(
(
theGlobals
-
>
result
=
=
noErr
)
&
&
(
theGlobals
-
>
actualObjects
=
=
1
)
)
{
nodeFlags
=
theGlobals
-
>
catalogInfo
.
nodeFlags
;
if
(
(
nodeFlags
&
kFSNodeIsDirectoryMask
)
!
=
0
)
{
FSDeleteFolderLevel
(
&
itemToDelete
theGlobals
)
;
}
if
(
theGlobals
-
>
result
=
=
noErr
)
{
if
(
(
nodeFlags
&
kFSNodeLockedMask
)
!
=
0
)
{
theGlobals
-
>
catalogInfo
.
nodeFlags
=
nodeFlags
&
~
kFSNodeLockedMask
;
(
void
)
FSSetCatalogInfo
(
&
itemToDelete
kFSCatInfoNodeFlags
&
theGlobals
-
>
catalogInfo
)
;
}
theGlobals
-
>
result
=
FSDeleteObject
(
&
itemToDelete
)
;
}
}
}
while
(
theGlobals
-
>
result
=
=
noErr
)
;
if
(
theGlobals
-
>
result
=
=
errFSNoMoreItems
)
theGlobals
-
>
result
=
noErr
;
myverify_noerr
(
FSCloseIterator
(
iterator
)
)
;
}
mycheck_noerr
(
theGlobals
-
>
result
)
;
return
;
}
#
pragma
mark
-
-
-
-
-
Utilities
-
-
-
-
-
OSErr
IsDropBox
(
const
FSRef
*
source
Boolean
*
isDropBox
)
{
FSCatalogInfo
tmpCatInfo
;
FSSpec
sourceSpec
;
Boolean
isDrop
=
false
;
OSErr
osErr
;
osErr
=
FSGetCatalogInfo
(
source
kFSCatInfoNodeFlags
|
kFSCatInfoPermissions
&
tmpCatInfo
NULL
&
sourceSpec
NULL
)
;
if
(
osErr
=
=
noErr
)
osErr
=
(
(
tmpCatInfo
.
nodeFlags
&
kFSNodeIsDirectoryMask
)
!
=
0
)
?
noErr
:
errFSNotAFolder
;
if
(
osErr
=
=
noErr
)
{
HParamBlockRec
hPB
;
BlockZero
(
&
hPB
sizeof
(
HParamBlockRec
)
)
;
hPB
.
accessParam
.
ioNamePtr
=
sourceSpec
.
name
;
hPB
.
accessParam
.
ioVRefNum
=
sourceSpec
.
vRefNum
;
hPB
.
accessParam
.
ioDirID
=
sourceSpec
.
parID
;
osErr
=
PBHGetDirAccessSync
(
&
hPB
)
;
if
(
osErr
=
=
noErr
)
isDrop
=
(
hPB
.
accessParam
.
ioACAccess
&
kPrivilegesMask
)
=
=
kioACAccessUserWriteMask
;
else
if
(
osErr
=
=
paramErr
)
{
FSPermissionInfo
*
tmpPerm
=
(
FSPermissionInfo
*
)
tmpCatInfo
.
permissions
;
isDrop
=
(
(
tmpPerm
-
>
mode
&
kRWXOtherAccessMask
)
=
=
kDropFolderValue
)
;
osErr
=
noErr
;
}
}
*
isDropBox
=
isDrop
;
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
OSErr
GetMagicBusyCreationDate
(
UTCDateTime
*
date
)
{
UTCDateTime
tmpDate
=
{
0
0
0
}
;
OSErr
osErr
=
(
date
!
=
NULL
)
?
noErr
:
paramErr
;
if
(
osErr
=
=
noErr
)
osErr
=
ConvertLocalTimeToUTC
(
kMagicBusyCreationDate
&
tmpDate
.
lowSeconds
)
;
if
(
osErr
=
=
noErr
)
*
date
=
tmpDate
;
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
Boolean
CompareHFSUniStr255
(
const
HFSUniStr255
*
lhs
const
HFSUniStr255
*
rhs
)
{
return
(
lhs
-
>
length
=
=
rhs
-
>
length
)
&
&
(
memcmp
(
lhs
-
>
unicode
rhs
-
>
unicode
lhs
-
>
length
*
sizeof
(
UniChar
)
)
=
=
0
)
;
}
OSErr
FSGetVRefNum
(
const
FSRef
*
ref
FSVolumeRefNum
*
vRefNum
)
{
FSCatalogInfo
catalogInfo
;
OSErr
osErr
=
(
ref
!
=
NULL
&
&
vRefNum
!
=
NULL
)
?
noErr
:
paramErr
;
if
(
osErr
=
=
noErr
)
osErr
=
FSGetCatalogInfo
(
ref
kFSCatInfoVolume
&
catalogInfo
NULL
NULL
NULL
)
;
if
(
osErr
=
=
noErr
)
*
vRefNum
=
catalogInfo
.
volume
;
mycheck_noerr
(
osErr
)
;
return
osErr
;
}
OSErr
FSGetVolParms
(
FSVolumeRefNum
volRefNum
UInt32
bufferSize
GetVolParmsInfoBuffer
*
volParmsInfo
UInt32
*
actualInfoSize
)
{
HParamBlockRec
pb
;
OSErr
osErr
=
(
volParmsInfo
!
=
NULL
)
?
noErr
:
paramErr
;
if
(
osErr
=
=
noErr
)
{
pb
.
ioParam
.
ioNamePtr
=
NULL
;
pb
.
ioParam
.
ioVRefNum
=
volRefNum
;
pb
.
ioParam
.
ioBuffer
=
(
Ptr
)
volParmsInfo
;
pb
.
ioParam
.
ioReqCount
=
(
SInt32
)
bufferSize
;
osErr
=
PBHGetVolParmsSync
(
&
pb
)
;
}
if
(
osErr
=
=
noErr
&
&
actualInfoSize
!
=
NULL
)
*
actualInfoSize
=
(
UInt32
)
pb
.
ioParam
.
ioActCount
;
mycheck_noerr
(
osErr
)
;
return
(
osErr
)
;
}
OSErr
UnicodeNameGetHFSName
(
UniCharCount
nameLength
const
UniChar
*
name
TextEncoding
textEncodingHint
Boolean
isVolumeName
Str31
hfsName
)
{
UnicodeMapping
uMapping
;
UnicodeToTextInfo
utInfo
;
ByteCount
unicodeByteLength
;
ByteCount
unicodeBytesConverted
;
ByteCount
actualPascalBytes
;
OSErr
osErr
=
(
hfsName
!
=
NULL
&
&
name
!
=
NULL
)
?
noErr
:
paramErr
;
hfsName
[
0
]
=
0
;
unicodeByteLength
=
nameLength
*
sizeof
(
UniChar
)
;
if
(
unicodeByteLength
=
=
0
)
osErr
=
noErr
;
else
{
if
(
kTextEncodingUnknown
=
=
textEncodingHint
)
{
ScriptCode
script
;
RegionCode
region
;
script
=
(
ScriptCode
)
GetScriptManagerVariable
(
smSysScript
)
;
region
=
(
RegionCode
)
GetScriptManagerVariable
(
smRegionCode
)
;
osErr
=
UpgradeScriptInfoToTextEncoding
(
script
kTextLanguageDontCare
region
NULL
&
textEncodingHint
)
;
if
(
osErr
=
=
paramErr
)
{
osErr
=
UpgradeScriptInfoToTextEncoding
(
script
kTextLanguageDontCare
kTextRegionDontCare
NULL
&
textEncodingHint
)
;
}
if
(
osErr
!
=
noErr
)
textEncodingHint
=
kTextEncodingMacRoman
;
}
uMapping
.
unicodeEncoding
=
CreateTextEncoding
(
kTextEncodingUnicodeV2_0
kUnicodeCanonicalDecompVariant
kUnicode16BitFormat
)
;
uMapping
.
otherEncoding
=
GetTextEncodingBase
(
textEncodingHint
)
;
uMapping
.
mappingVersion
=
kUnicodeUseHFSPlusMapping
;
osErr
=
CreateUnicodeToTextInfo
(
&
uMapping
&
utInfo
)
;
if
(
osErr
=
=
noErr
)
{
osErr
=
ConvertFromUnicodeToText
(
utInfo
unicodeByteLength
name
kUnicodeLooseMappingsMask
0
NULL
0
NULL
isVolumeName
?
kHFSMaxVolumeNameChars
:
kHFSMaxFileNameChars
&
unicodeBytesConverted
&
actualPascalBytes
&
hfsName
[
1
]
)
;
}
if
(
osErr
=
=
noErr
)
hfsName
[
0
]
=
actualPascalBytes
;
myverify_noerr
(
DisposeUnicodeToTextInfo
(
&
utInfo
)
)
;
}
mycheck_noerr
(
osErr
)
;
return
(
osErr
)
;
}
OSErr
FSMakeFSRef
(
FSVolumeRefNum
volRefNum
SInt32
dirID
ConstStr255Param
name
FSRef
*
ref
)
{
FSRefParam
pb
;
OSErr
osErr
=
(
ref
!
=
NULL
)
?
noErr
:
paramErr
;
if
(
osErr
=
=
noErr
)
{
pb
.
ioVRefNum
=
volRefNum
;
pb
.
ioDirID
=
dirID
;
pb
.
ioNamePtr
=
(
StringPtr
)
name
;
pb
.
newRef
=
ref
;
osErr
=
PBMakeFSRefSync
(
&
pb
)
;
}
mycheck_noerr
(
osErr
)
;
return
(
osErr
)
;
}
