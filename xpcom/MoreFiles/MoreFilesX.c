#
if
defined
(
__MACH__
)
#
include
<
Carbon
/
Carbon
.
h
>
#
include
<
string
.
h
>
#
else
#
include
<
Carbon
.
h
>
#
include
<
string
.
h
>
#
endif
#
include
"
MoreFilesX
.
h
"
#
ifndef
BuildingMoreFilesXForMacOS9
#
define
BuildingMoreFilesXForMacOS9
0
#
endif
#
pragma
mark
-
-
-
-
-
Local
type
definitions
-
-
-
-
-
struct
FSIterateContainerGlobals
{
IterateContainerFilterProcPtr
iterateFilter
;
FSCatalogInfoBitmap
whichInfo
;
FSCatalogInfo
catalogInfo
;
FSRef
ref
;
FSSpec
spec
;
FSSpec
*
specPtr
;
HFSUniStr255
name
;
HFSUniStr255
*
namePtr
;
void
*
yourDataPtr
;
ItemCount
maxLevels
;
ItemCount
currentLevel
;
Boolean
quitFlag
;
Boolean
containerChanged
;
OSErr
result
;
ItemCount
actualObjects
;
}
;
typedef
struct
FSIterateContainerGlobals
FSIterateContainerGlobals
;
struct
FSDeleteContainerGlobals
{
OSErr
result
;
ItemCount
actualObjects
;
FSCatalogInfo
catalogInfo
;
}
;
typedef
struct
FSDeleteContainerGlobals
FSDeleteContainerGlobals
;
#
pragma
mark
-
-
-
-
-
Local
prototypes
-
-
-
-
-
static
void
FSDeleteContainerLevel
(
const
FSRef
*
container
FSDeleteContainerGlobals
*
theGlobals
)
;
static
void
FSIterateContainerLevel
(
FSIterateContainerGlobals
*
theGlobals
)
;
static
OSErr
GenerateUniqueHFSUniStr
(
long
*
startSeed
const
FSRef
*
dir1
const
FSRef
*
dir2
HFSUniStr255
*
uniqueName
)
;
#
pragma
mark
-
-
-
-
-
File
Access
Routines
-
-
-
-
-
OSErr
FSCopyFork
(
SInt16
srcRefNum
SInt16
dstRefNum
void
*
copyBufferPtr
ByteCount
copyBufferSize
)
{
OSErr
srcResult
;
OSErr
dstResult
;
OSErr
result
;
SInt64
forkSize
;
ByteCount
readActualCount
;
require_action
(
(
NULL
!
=
copyBufferPtr
)
&
&
(
0
!
=
copyBufferSize
)
BadParameter
result
=
paramErr
)
;
result
=
FSGetForkSize
(
srcRefNum
&
forkSize
)
;
require_noerr
(
result
SourceFSGetForkSizeFailed
)
;
result
=
FSSetForkSize
(
dstRefNum
fsFromStart
forkSize
)
;
require_noerr
(
result
DestinationFSSetForkSizeFailed
)
;
result
=
FSSetForkPosition
(
srcRefNum
fsFromStart
0
)
;
require_noerr
(
result
SourceFSSetForkPositionFailed
)
;
result
=
FSSetForkPosition
(
dstRefNum
fsFromStart
0
)
;
require_noerr
(
result
DestinationFSSetForkPositionFailed
)
;
if
(
(
copyBufferSize
>
=
0x00001000
)
&
&
(
(
copyBufferSize
&
0x00000fff
)
!
=
0
)
)
{
copyBufferSize
&
=
~
(
0x00001000
-
1
)
;
}
srcResult
=
dstResult
=
noErr
;
while
(
(
noErr
=
=
srcResult
)
&
&
(
noErr
=
=
dstResult
)
)
{
srcResult
=
FSReadFork
(
srcRefNum
fsAtMark
+
noCacheMask
0
copyBufferSize
copyBufferPtr
&
readActualCount
)
;
dstResult
=
FSWriteFork
(
dstRefNum
fsAtMark
+
noCacheMask
0
readActualCount
copyBufferPtr
NULL
)
;
}
require_noerr_action
(
dstResult
DestinationFSWriteForkFailed
result
=
dstResult
)
;
require_action
(
eofErr
=
=
srcResult
SourceResultNotEofErr
result
=
srcResult
)
;
result
=
noErr
;
SourceResultNotEofErr
:
DestinationFSWriteForkFailed
:
DestinationFSSetForkPositionFailed
:
SourceFSSetForkPositionFailed
:
DestinationFSSetForkSizeFailed
:
SourceFSGetForkSizeFailed
:
BadParameter
:
return
(
result
)
;
}
#
pragma
mark
-
-
-
-
-
Volume
Access
Routines
-
-
-
-
-
OSErr
FSGetVolParms
(
FSVolumeRefNum
volRefNum
UInt32
bufferSize
GetVolParmsInfoBuffer
*
volParmsInfo
UInt32
*
actualInfoSize
)
{
OSErr
result
;
HParamBlockRec
pb
;
require_action
(
(
NULL
!
=
volParmsInfo
)
&
&
(
NULL
!
=
actualInfoSize
)
BadParameter
result
=
paramErr
)
;
pb
.
ioParam
.
ioNamePtr
=
NULL
;
pb
.
ioParam
.
ioVRefNum
=
volRefNum
;
pb
.
ioParam
.
ioBuffer
=
(
Ptr
)
volParmsInfo
;
pb
.
ioParam
.
ioReqCount
=
(
SInt32
)
bufferSize
;
result
=
PBHGetVolParmsSync
(
&
pb
)
;
require_noerr
(
result
PBHGetVolParmsSync
)
;
*
actualInfoSize
=
(
UInt32
)
pb
.
ioParam
.
ioActCount
;
PBHGetVolParmsSync
:
BadParameter
:
return
(
result
)
;
}
OSErr
FSGetVRefNum
(
const
FSRef
*
ref
FSVolumeRefNum
*
vRefNum
)
{
OSErr
result
;
FSCatalogInfo
catalogInfo
;
require_action
(
NULL
!
=
vRefNum
BadParameter
result
=
paramErr
)
;
result
=
FSGetCatalogInfo
(
ref
kFSCatInfoVolume
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
*
vRefNum
=
catalogInfo
.
volume
;
FSGetCatalogInfo
:
BadParameter
:
return
(
result
)
;
}
OSErr
FSGetVInfo
(
FSVolumeRefNum
volume
HFSUniStr255
*
volumeName
UInt64
*
freeBytes
UInt64
*
totalBytes
)
{
OSErr
result
;
FSVolumeInfo
info
;
result
=
FSGetVolumeInfo
(
volume
0
NULL
(
(
(
NULL
!
=
freeBytes
)
|
|
(
NULL
!
=
totalBytes
)
)
?
kFSVolInfoSizes
:
kFSVolInfoNone
)
&
info
volumeName
NULL
)
;
require_noerr
(
result
FSGetVolumeInfo
)
;
if
(
NULL
!
=
freeBytes
)
{
*
freeBytes
=
info
.
freeBytes
;
}
if
(
NULL
!
=
totalBytes
)
{
*
totalBytes
=
info
.
totalBytes
;
}
FSGetVolumeInfo
:
return
(
result
)
;
}
OSErr
FSGetVolFileSystemID
(
FSVolumeRefNum
volume
UInt16
*
fileSystemID
UInt16
*
signature
)
{
OSErr
result
;
FSVolumeInfo
info
;
result
=
FSGetVolumeInfo
(
volume
0
NULL
kFSVolInfoFSInfo
&
info
NULL
NULL
)
;
require_noerr
(
result
FSGetVolumeInfo
)
;
if
(
NULL
!
=
fileSystemID
)
{
*
fileSystemID
=
info
.
filesystemID
;
}
if
(
NULL
!
=
signature
)
{
*
signature
=
info
.
signature
;
}
FSGetVolumeInfo
:
return
(
result
)
;
}
OSErr
FSGetMountedVolumes
(
FSRef
*
*
*
volumeRefsHandle
ItemCount
*
numVolumes
)
{
OSErr
result
;
OSErr
memResult
;
ItemCount
volumeIndex
;
FSRef
ref
;
require_action
(
(
NULL
!
=
volumeRefsHandle
)
&
&
(
NULL
!
=
numVolumes
)
BadParameter
result
=
paramErr
)
;
*
numVolumes
=
0
;
*
volumeRefsHandle
=
(
FSRef
*
*
)
NewHandle
(
0
)
;
require_action
(
NULL
!
=
*
volumeRefsHandle
NewHandle
result
=
memFullErr
)
;
volumeIndex
=
1
;
do
{
result
=
FSGetVolumeInfo
(
0
volumeIndex
NULL
kFSVolInfoNone
NULL
NULL
&
ref
)
;
if
(
noErr
=
=
result
)
{
PtrAndHand
(
&
ref
(
Handle
)
*
volumeRefsHandle
sizeof
(
FSRef
)
)
;
memResult
=
MemError
(
)
;
require_noerr_action
(
memResult
MemoryAllocationFailed
result
=
memResult
)
;
+
+
(
*
numVolumes
)
;
+
+
volumeIndex
;
}
}
while
(
noErr
=
=
result
)
;
require
(
nsvErr
=
=
result
FSGetVolumeInfo
)
;
return
(
noErr
)
;
MemoryAllocationFailed
:
FSGetVolumeInfo
:
if
(
NULL
!
=
*
volumeRefsHandle
)
{
DisposeHandle
(
(
Handle
)
*
volumeRefsHandle
)
;
*
volumeRefsHandle
=
NULL
;
}
*
numVolumes
=
0
;
NewHandle
:
BadParameter
:
return
(
result
)
;
}
#
pragma
mark
-
-
-
-
-
FSRef
/
FSpec
/
Path
/
Name
Conversion
Routines
-
-
-
-
-
OSErr
FSRefMakeFSSpec
(
const
FSRef
*
ref
FSSpec
*
spec
)
{
OSErr
result
;
require_action
(
NULL
!
=
spec
BadParameter
result
=
paramErr
)
;
result
=
FSGetCatalogInfo
(
ref
kFSCatInfoNone
NULL
NULL
spec
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
FSGetCatalogInfo
:
BadParameter
:
return
(
result
)
;
}
OSErr
FSMakeFSRef
(
FSVolumeRefNum
volRefNum
SInt32
dirID
ConstStr255Param
name
FSRef
*
ref
)
{
OSErr
result
;
FSRefParam
pb
;
require_action
(
NULL
!
=
ref
BadParameter
result
=
paramErr
)
;
pb
.
ioVRefNum
=
volRefNum
;
pb
.
ioDirID
=
dirID
;
pb
.
ioNamePtr
=
(
StringPtr
)
name
;
pb
.
newRef
=
ref
;
result
=
PBMakeFSRefSync
(
&
pb
)
;
require_noerr
(
result
PBMakeFSRefSync
)
;
PBMakeFSRefSync
:
BadParameter
:
return
(
result
)
;
}
OSStatus
FSMakePath
(
SInt16
volRefNum
SInt32
dirID
ConstStr255Param
name
UInt8
*
path
UInt32
maxPathSize
)
{
OSStatus
result
;
FSRef
ref
;
require_action
(
NULL
!
=
path
BadParameter
result
=
paramErr
)
;
result
=
FSMakeFSRef
(
volRefNum
dirID
name
&
ref
)
;
require_noerr
(
result
FSMakeFSRef
)
;
result
=
FSRefMakePath
(
&
ref
path
maxPathSize
)
;
require_noerr
(
result
FSRefMakePath
)
;
FSRefMakePath
:
FSMakeFSRef
:
BadParameter
:
return
(
result
)
;
}
OSStatus
FSPathMakeFSSpec
(
const
UInt8
*
path
FSSpec
*
spec
Boolean
*
isDirectory
)
{
OSStatus
result
;
FSRef
ref
;
require_action
(
NULL
!
=
spec
BadParameter
result
=
paramErr
)
;
result
=
FSPathMakeRef
(
path
&
ref
isDirectory
)
;
require_noerr
(
result
FSPathMakeRef
)
;
result
=
FSGetCatalogInfo
(
&
ref
kFSCatInfoNone
NULL
NULL
spec
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
FSGetCatalogInfo
:
FSPathMakeRef
:
BadParameter
:
return
(
result
)
;
}
OSErr
UnicodeNameGetHFSName
(
UniCharCount
nameLength
const
UniChar
*
name
TextEncoding
textEncodingHint
Boolean
isVolumeName
Str31
hfsName
)
{
OSStatus
result
;
ByteCount
unicodeByteLength
;
ByteCount
unicodeBytesConverted
;
ByteCount
actualPascalBytes
;
UnicodeMapping
uMapping
;
UnicodeToTextInfo
utInfo
;
require_action
(
NULL
!
=
hfsName
BadParameter
result
=
paramErr
)
;
hfsName
[
0
]
=
0
;
unicodeByteLength
=
nameLength
*
sizeof
(
UniChar
)
;
if
(
0
=
=
unicodeByteLength
)
{
result
=
noErr
;
}
else
{
if
(
kTextEncodingUnknown
=
=
textEncodingHint
)
{
ScriptCode
script
;
RegionCode
region
;
script
=
(
ScriptCode
)
GetScriptManagerVariable
(
smSysScript
)
;
region
=
(
RegionCode
)
GetScriptManagerVariable
(
smRegionCode
)
;
result
=
UpgradeScriptInfoToTextEncoding
(
script
kTextLanguageDontCare
region
NULL
&
textEncodingHint
)
;
if
(
paramErr
=
=
result
)
{
result
=
UpgradeScriptInfoToTextEncoding
(
script
kTextLanguageDontCare
kTextRegionDontCare
NULL
&
textEncodingHint
)
;
}
if
(
noErr
!
=
result
)
{
textEncodingHint
=
kTextEncodingMacRoman
;
}
}
uMapping
.
unicodeEncoding
=
CreateTextEncoding
(
kTextEncodingUnicodeV2_0
kUnicodeCanonicalDecompVariant
kUnicode16BitFormat
)
;
uMapping
.
otherEncoding
=
GetTextEncodingBase
(
textEncodingHint
)
;
uMapping
.
mappingVersion
=
kUnicodeUseHFSPlusMapping
;
result
=
CreateUnicodeToTextInfo
(
&
uMapping
&
utInfo
)
;
require_noerr
(
result
CreateUnicodeToTextInfo
)
;
result
=
ConvertFromUnicodeToText
(
utInfo
unicodeByteLength
name
kUnicodeLooseMappingsMask
0
NULL
0
NULL
isVolumeName
?
kHFSMaxVolumeNameChars
:
kHFSMaxFileNameChars
&
unicodeBytesConverted
&
actualPascalBytes
&
hfsName
[
1
]
)
;
require_noerr
(
result
ConvertFromUnicodeToText
)
;
hfsName
[
0
]
=
(
unsigned
char
)
actualPascalBytes
;
ConvertFromUnicodeToText
:
verify_noerr
(
DisposeUnicodeToTextInfo
(
&
utInfo
)
)
;
}
CreateUnicodeToTextInfo
:
BadParameter
:
return
(
result
)
;
}
OSErr
HFSNameGetUnicodeName
(
ConstStr31Param
hfsName
TextEncoding
textEncodingHint
HFSUniStr255
*
unicodeName
)
{
ByteCount
unicodeByteLength
;
OSStatus
result
;
UnicodeMapping
uMapping
;
TextToUnicodeInfo
tuInfo
;
ByteCount
pascalCharsRead
;
require_action
(
NULL
!
=
unicodeName
BadParameter
result
=
paramErr
)
;
unicodeName
-
>
length
=
0
;
if
(
0
=
=
StrLength
(
hfsName
)
)
{
result
=
noErr
;
}
else
{
if
(
kTextEncodingUnknown
=
=
textEncodingHint
)
{
ScriptCode
script
;
RegionCode
region
;
script
=
GetScriptManagerVariable
(
smSysScript
)
;
region
=
GetScriptManagerVariable
(
smRegionCode
)
;
result
=
UpgradeScriptInfoToTextEncoding
(
script
kTextLanguageDontCare
region
NULL
&
textEncodingHint
)
;
if
(
paramErr
=
=
result
)
{
result
=
UpgradeScriptInfoToTextEncoding
(
script
kTextLanguageDontCare
kTextRegionDontCare
NULL
&
textEncodingHint
)
;
}
if
(
noErr
!
=
result
)
{
textEncodingHint
=
kTextEncodingMacRoman
;
}
}
uMapping
.
unicodeEncoding
=
CreateTextEncoding
(
kTextEncodingUnicodeV2_0
kUnicodeCanonicalDecompVariant
kUnicode16BitFormat
)
;
uMapping
.
otherEncoding
=
GetTextEncodingBase
(
textEncodingHint
)
;
uMapping
.
mappingVersion
=
kUnicodeUseHFSPlusMapping
;
result
=
CreateTextToUnicodeInfo
(
&
uMapping
&
tuInfo
)
;
require_noerr
(
result
CreateTextToUnicodeInfo
)
;
result
=
ConvertFromTextToUnicode
(
tuInfo
hfsName
[
0
]
&
hfsName
[
1
]
0
0
NULL
0
NULL
sizeof
(
unicodeName
-
>
unicode
)
&
pascalCharsRead
&
unicodeByteLength
unicodeName
-
>
unicode
)
;
require_noerr
(
result
ConvertFromTextToUnicode
)
;
unicodeName
-
>
length
=
unicodeByteLength
/
sizeof
(
UniChar
)
;
ConvertFromTextToUnicode
:
verify_noerr
(
DisposeTextToUnicodeInfo
(
&
tuInfo
)
)
;
}
CreateTextToUnicodeInfo
:
BadParameter
:
return
(
result
)
;
}
#
pragma
mark
-
-
-
-
-
File
/
Directory
Manipulation
Routines
-
-
-
-
-
Boolean
FSRefValid
(
const
FSRef
*
ref
)
{
return
(
noErr
=
=
FSGetCatalogInfo
(
ref
kFSCatInfoNone
NULL
NULL
NULL
NULL
)
)
;
}
OSErr
FSGetParentRef
(
const
FSRef
*
ref
FSRef
*
parentRef
)
{
OSErr
result
;
FSCatalogInfo
catalogInfo
;
require_action
(
NULL
!
=
parentRef
BadParameter
result
=
paramErr
)
;
result
=
FSGetCatalogInfo
(
ref
kFSCatInfoNodeID
&
catalogInfo
NULL
NULL
parentRef
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
if
(
fsRtDirID
=
=
catalogInfo
.
nodeID
)
{
memset
(
parentRef
0
sizeof
(
FSRef
)
)
;
}
FSGetCatalogInfo
:
BadParameter
:
return
(
result
)
;
}
OSErr
FSGetFileDirName
(
const
FSRef
*
ref
HFSUniStr255
*
outName
)
{
OSErr
result
;
require_action
(
NULL
!
=
outName
BadParameter
result
=
paramErr
)
;
result
=
FSGetCatalogInfo
(
ref
kFSCatInfoNone
NULL
outName
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
FSGetCatalogInfo
:
BadParameter
:
return
(
result
)
;
}
OSErr
FSGetNodeID
(
const
FSRef
*
ref
long
*
nodeID
Boolean
*
isDirectory
)
{
OSErr
result
;
FSCatalogInfo
catalogInfo
;
FSCatalogInfoBitmap
whichInfo
;
whichInfo
=
kFSCatInfoNone
;
if
(
NULL
!
=
nodeID
)
{
whichInfo
|
=
kFSCatInfoNodeID
;
}
if
(
NULL
!
=
isDirectory
)
{
whichInfo
|
=
kFSCatInfoNodeFlags
;
}
result
=
FSGetCatalogInfo
(
ref
whichInfo
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
if
(
NULL
!
=
nodeID
)
{
*
nodeID
=
catalogInfo
.
nodeID
;
}
if
(
NULL
!
=
isDirectory
)
{
*
isDirectory
=
(
0
!
=
(
kFSNodeIsDirectoryMask
&
catalogInfo
.
nodeFlags
)
)
;
}
FSGetCatalogInfo
:
return
(
result
)
;
}
OSErr
FSGetUserPrivilegesPermissions
(
const
FSRef
*
ref
UInt8
*
userPrivileges
UInt32
permissions
[
4
]
)
{
OSErr
result
;
FSCatalogInfo
catalogInfo
;
FSCatalogInfoBitmap
whichInfo
;
whichInfo
=
kFSCatInfoNone
;
if
(
NULL
!
=
userPrivileges
)
{
whichInfo
|
=
kFSCatInfoUserPrivs
;
}
if
(
NULL
!
=
permissions
)
{
whichInfo
|
=
kFSCatInfoPermissions
;
}
result
=
FSGetCatalogInfo
(
ref
whichInfo
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
if
(
NULL
!
=
userPrivileges
)
{
*
userPrivileges
=
catalogInfo
.
userPrivileges
;
}
if
(
NULL
!
=
permissions
)
{
BlockMoveData
(
&
catalogInfo
.
permissions
permissions
sizeof
(
UInt32
)
*
4
)
;
}
FSGetCatalogInfo
:
return
(
result
)
;
}
OSErr
FSCheckLock
(
const
FSRef
*
ref
)
{
OSErr
result
;
FSCatalogInfo
catalogInfo
;
FSVolumeInfo
volumeInfo
;
result
=
FSGetCatalogInfo
(
ref
kFSCatInfoNodeFlags
+
kFSCatInfoVolume
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
if
(
0
!
=
(
catalogInfo
.
nodeFlags
&
kFSNodeLockedMask
)
)
{
result
=
fLckdErr
;
}
else
{
result
=
FSGetVolumeInfo
(
catalogInfo
.
volume
0
NULL
kFSVolInfoFlags
&
volumeInfo
NULL
NULL
)
;
require_noerr
(
result
FSGetVolumeInfo
)
;
if
(
0
!
=
(
volumeInfo
.
flags
&
kFSVolFlagHardwareLockedMask
)
)
{
result
=
wPrErr
;
}
else
if
(
0
!
=
(
volumeInfo
.
flags
&
kFSVolFlagSoftwareLockedMask
)
)
{
result
=
vLckdErr
;
}
}
FSGetVolumeInfo
:
FSGetCatalogInfo
:
return
(
result
)
;
}
OSErr
FSGetForkSizes
(
const
FSRef
*
ref
UInt64
*
dataLogicalSize
UInt64
*
rsrcLogicalSize
)
{
OSErr
result
;
FSCatalogInfoBitmap
whichInfo
;
FSCatalogInfo
catalogInfo
;
whichInfo
=
kFSCatInfoNodeFlags
;
if
(
NULL
!
=
dataLogicalSize
)
{
whichInfo
|
=
kFSCatInfoDataSizes
;
}
if
(
NULL
!
=
rsrcLogicalSize
)
{
whichInfo
|
=
kFSCatInfoRsrcSizes
;
}
result
=
FSGetCatalogInfo
(
ref
whichInfo
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
require_action
(
0
=
=
(
catalogInfo
.
nodeFlags
&
kFSNodeIsDirectoryMask
)
FSRefNotFile
result
=
notAFileErr
)
;
if
(
NULL
!
=
dataLogicalSize
)
{
*
dataLogicalSize
=
catalogInfo
.
dataLogicalSize
;
}
if
(
NULL
!
=
rsrcLogicalSize
)
{
*
rsrcLogicalSize
=
catalogInfo
.
rsrcLogicalSize
;
}
FSRefNotFile
:
FSGetCatalogInfo
:
return
(
result
)
;
}
OSErr
FSGetTotalForkSizes
(
const
FSRef
*
ref
UInt64
*
totalLogicalSize
UInt64
*
totalPhysicalSize
ItemCount
*
forkCount
)
{
OSErr
result
;
CatPositionRec
forkIterator
;
SInt64
forkSize
;
SInt64
*
forkSizePtr
;
UInt64
forkPhysicalSize
;
UInt64
*
forkPhysicalSizePtr
;
if
(
NULL
!
=
totalLogicalSize
)
{
*
totalLogicalSize
=
0
;
forkSizePtr
=
&
forkSize
;
}
else
{
forkSizePtr
=
NULL
;
}
if
(
NULL
!
=
totalPhysicalSize
)
{
*
totalPhysicalSize
=
0
;
forkPhysicalSizePtr
=
&
forkPhysicalSize
;
}
else
{
forkPhysicalSizePtr
=
NULL
;
}
if
(
NULL
!
=
forkCount
)
{
*
forkCount
=
0
;
}
forkIterator
.
initialize
=
0
;
do
{
result
=
FSIterateForks
(
ref
&
forkIterator
NULL
forkSizePtr
forkPhysicalSizePtr
)
;
if
(
noErr
=
=
result
)
{
if
(
NULL
!
=
totalLogicalSize
)
{
*
totalLogicalSize
+
=
forkSize
;
}
if
(
NULL
!
=
totalPhysicalSize
)
{
*
totalPhysicalSize
+
=
forkPhysicalSize
;
}
if
(
NULL
!
=
forkCount
)
{
+
+
*
forkCount
;
}
}
}
while
(
noErr
=
=
result
)
;
require
(
errFSNoMoreItems
=
=
result
FSIterateForks
)
;
result
=
noErr
;
FSIterateForks
:
return
(
result
)
;
}
OSErr
FSBumpDate
(
const
FSRef
*
ref
)
{
OSStatus
result
;
FSCatalogInfo
catalogInfo
;
UTCDateTime
oldDateTime
;
#
if
!
BuildingMoreFilesXForMacOS9
FSRef
parentRef
;
Boolean
notifyParent
;
#
endif
#
if
!
BuildingMoreFilesXForMacOS9
result
=
FSGetCatalogInfo
(
ref
kFSCatInfoNodeFlags
+
kFSCatInfoContentMod
&
catalogInfo
NULL
NULL
&
parentRef
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
notifyParent
=
(
0
=
=
(
catalogInfo
.
nodeFlags
&
kFSNodeIsDirectoryMask
)
)
;
#
else
result
=
FSGetCatalogInfo
(
ref
kFSCatInfoContentMod
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
#
endif
oldDateTime
=
catalogInfo
.
contentModDate
;
result
=
GetUTCDateTime
(
&
catalogInfo
.
contentModDate
kUTCDefaultOptions
)
;
require_noerr
(
result
GetUTCDateTime
)
;
if
(
(
catalogInfo
.
contentModDate
.
fraction
=
=
oldDateTime
.
fraction
)
&
&
(
catalogInfo
.
contentModDate
.
lowSeconds
=
=
oldDateTime
.
lowSeconds
)
&
&
(
catalogInfo
.
contentModDate
.
highSeconds
=
=
oldDateTime
.
highSeconds
)
)
{
+
+
catalogInfo
.
contentModDate
.
lowSeconds
;
if
(
0
=
=
catalogInfo
.
contentModDate
.
lowSeconds
)
{
+
+
catalogInfo
.
contentModDate
.
highSeconds
;
}
}
result
=
FSSetCatalogInfo
(
ref
kFSCatInfoContentMod
&
catalogInfo
)
;
require_noerr
(
result
FSSetCatalogInfo
)
;
#
if
!
BuildingMoreFilesXForMacOS9
result
=
FNNotify
(
notifyParent
?
&
parentRef
:
ref
kFNDirectoryModifiedMessage
kNilOptions
)
;
require_noerr
(
result
FNNotify
)
;
#
endif
FNNotify
:
FSSetCatalogInfo
:
return
(
noErr
)
;
GetUTCDateTime
:
FSGetCatalogInfo
:
return
(
result
)
;
}
OSErr
FSGetFinderInfo
(
const
FSRef
*
ref
FinderInfo
*
info
ExtendedFinderInfo
*
extendedInfo
Boolean
*
isDirectory
)
{
OSErr
result
;
FSCatalogInfo
catalogInfo
;
FSCatalogInfoBitmap
whichInfo
;
whichInfo
=
kFSCatInfoNone
;
if
(
NULL
!
=
info
)
{
whichInfo
|
=
kFSCatInfoFinderInfo
;
}
if
(
NULL
!
=
extendedInfo
)
{
whichInfo
|
=
kFSCatInfoFinderXInfo
;
}
if
(
NULL
!
=
isDirectory
)
{
whichInfo
|
=
kFSCatInfoNodeFlags
;
}
result
=
FSGetCatalogInfo
(
ref
whichInfo
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
if
(
NULL
!
=
info
)
{
BlockMoveData
(
catalogInfo
.
finderInfo
info
sizeof
(
FinderInfo
)
)
;
}
if
(
NULL
!
=
extendedInfo
)
{
BlockMoveData
(
catalogInfo
.
extFinderInfo
extendedInfo
sizeof
(
ExtendedFinderInfo
)
)
;
}
if
(
NULL
!
=
isDirectory
)
{
*
isDirectory
=
(
0
!
=
(
kFSNodeIsDirectoryMask
&
catalogInfo
.
nodeFlags
)
)
;
}
FSGetCatalogInfo
:
return
(
result
)
;
}
OSErr
FSSetFinderInfo
(
const
FSRef
*
ref
const
FinderInfo
*
info
const
ExtendedFinderInfo
*
extendedInfo
)
{
OSErr
result
;
FSCatalogInfo
catalogInfo
;
FSCatalogInfoBitmap
whichInfo
;
whichInfo
=
kFSCatInfoNone
;
if
(
NULL
!
=
info
)
{
whichInfo
|
=
kFSCatInfoFinderInfo
;
BlockMoveData
(
info
catalogInfo
.
finderInfo
sizeof
(
FinderInfo
)
)
;
}
if
(
NULL
!
=
extendedInfo
)
{
whichInfo
|
=
kFSCatInfoFinderXInfo
;
BlockMoveData
(
extendedInfo
catalogInfo
.
extFinderInfo
sizeof
(
ExtendedFinderInfo
)
)
;
}
result
=
FSSetCatalogInfo
(
ref
whichInfo
&
catalogInfo
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
FSGetCatalogInfo
:
return
(
result
)
;
}
OSErr
FSChangeCreatorType
(
const
FSRef
*
ref
OSType
fileCreator
OSType
fileType
)
{
OSErr
result
;
FSCatalogInfo
catalogInfo
;
FSRef
parentRef
;
result
=
FSGetCatalogInfo
(
ref
kFSCatInfoNodeFlags
+
kFSCatInfoFinderInfo
&
catalogInfo
NULL
NULL
&
parentRef
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
require_action
(
0
=
=
(
catalogInfo
.
nodeFlags
&
kFSNodeIsDirectoryMask
)
FSRefNotFile
result
=
notAFileErr
)
;
if
(
fileType
!
=
(
OSType
)
0x00000000
)
{
(
(
FileInfo
*
)
&
catalogInfo
.
finderInfo
)
-
>
fileType
=
fileType
;
}
if
(
fileCreator
!
=
(
OSType
)
0x00000000
)
{
(
(
FileInfo
*
)
&
catalogInfo
.
finderInfo
)
-
>
fileCreator
=
fileCreator
;
}
result
=
FSSetCatalogInfo
(
ref
kFSCatInfoFinderInfo
&
catalogInfo
)
;
require_noerr
(
result
FSSetCatalogInfo
)
;
verify_noerr
(
FSBumpDate
(
&
parentRef
)
)
;
FSSetCatalogInfo
:
FSRefNotFile
:
FSGetCatalogInfo
:
return
(
result
)
;
}
OSErr
FSChangeFinderFlags
(
const
FSRef
*
ref
Boolean
setBits
UInt16
flagBits
)
{
OSErr
result
;
FSCatalogInfo
catalogInfo
;
FSRef
parentRef
;
result
=
FSGetCatalogInfo
(
ref
kFSCatInfoFinderInfo
&
catalogInfo
NULL
NULL
&
parentRef
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
if
(
setBits
)
{
(
(
FileInfo
*
)
&
catalogInfo
.
finderInfo
)
-
>
finderFlags
|
=
flagBits
;
}
else
{
(
(
FileInfo
*
)
&
catalogInfo
.
finderInfo
)
-
>
finderFlags
&
=
~
flagBits
;
}
result
=
FSSetCatalogInfo
(
ref
kFSCatInfoFinderInfo
&
catalogInfo
)
;
require_noerr
(
result
FSSetCatalogInfo
)
;
verify_noerr
(
FSBumpDate
(
&
parentRef
)
)
;
FSSetCatalogInfo
:
FSGetCatalogInfo
:
return
(
result
)
;
}
OSErr
FSSetInvisible
(
const
FSRef
*
ref
)
{
return
(
FSChangeFinderFlags
(
ref
true
kIsInvisible
)
)
;
}
OSErr
FSClearInvisible
(
const
FSRef
*
ref
)
{
return
(
FSChangeFinderFlags
(
ref
false
kIsInvisible
)
)
;
}
OSErr
FSSetNameLocked
(
const
FSRef
*
ref
)
{
return
(
FSChangeFinderFlags
(
ref
true
kNameLocked
)
)
;
}
OSErr
FSClearNameLocked
(
const
FSRef
*
ref
)
{
return
(
FSChangeFinderFlags
(
ref
false
kNameLocked
)
)
;
}
OSErr
FSSetIsStationery
(
const
FSRef
*
ref
)
{
return
(
FSChangeFinderFlags
(
ref
true
kIsStationery
)
)
;
}
OSErr
FSClearIsStationery
(
const
FSRef
*
ref
)
{
return
(
FSChangeFinderFlags
(
ref
false
kIsStationery
)
)
;
}
OSErr
FSSetHasCustomIcon
(
const
FSRef
*
ref
)
{
return
(
FSChangeFinderFlags
(
ref
true
kHasCustomIcon
)
)
;
}
OSErr
FSClearHasCustomIcon
(
const
FSRef
*
ref
)
{
return
(
FSChangeFinderFlags
(
ref
false
kHasCustomIcon
)
)
;
}
OSErr
FSClearHasBeenInited
(
const
FSRef
*
ref
)
{
return
(
FSChangeFinderFlags
(
ref
false
kHasBeenInited
)
)
;
}
OSErr
FSCopyFileMgrAttributes
(
const
FSRef
*
sourceRef
const
FSRef
*
destinationRef
Boolean
copyLockBit
)
{
OSErr
result
;
FSCatalogInfo
catalogInfo
;
result
=
FSGetCatalogInfo
(
sourceRef
kFSCatInfoSettableInfo
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
(
(
FileInfo
*
)
&
catalogInfo
.
finderInfo
)
-
>
finderFlags
&
=
~
kHasBeenInited
;
if
(
!
copyLockBit
)
{
catalogInfo
.
nodeFlags
&
=
~
kFSNodeLockedMask
;
}
result
=
FSSetCatalogInfo
(
destinationRef
kFSCatInfoSettableInfo
&
catalogInfo
)
;
require_noerr
(
result
FSSetCatalogInfo
)
;
FSSetCatalogInfo
:
FSGetCatalogInfo
:
return
(
result
)
;
}
OSErr
FSMoveRenameObjectUnicode
(
const
FSRef
*
ref
const
FSRef
*
destDirectory
UniCharCount
nameLength
const
UniChar
*
name
TextEncoding
textEncodingHint
FSRef
*
newRef
)
{
OSErr
result
;
FSVolumeRefNum
vRefNum
;
FSCatalogInfo
catalogInfo
;
FSRef
originalDirectory
;
TextEncoding
originalTextEncodingHint
;
HFSUniStr255
originalName
;
HFSUniStr255
uniqueName
;
long
theSeed
;
require_action
(
NULL
!
=
newRef
BadParameter
result
=
paramErr
)
;
BlockMoveData
(
ref
newRef
sizeof
(
FSRef
)
)
;
result
=
FSGetCatalogInfo
(
destDirectory
kFSCatInfoVolume
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
DestinationBad
)
;
vRefNum
=
catalogInfo
.
volume
;
result
=
FSGetCatalogInfo
(
ref
kFSCatInfoTextEncoding
+
kFSCatInfoVolume
&
catalogInfo
&
originalName
NULL
&
originalDirectory
)
;
require_noerr
(
result
SourceBad
)
;
originalTextEncodingHint
=
catalogInfo
.
textEncodingHint
;
require_action
(
vRefNum
=
=
catalogInfo
.
volume
NotSameVolume
result
=
diffVolErr
)
;
if
(
NULL
!
=
name
)
{
theSeed
=
0x4a696d4c
;
result
=
GenerateUniqueHFSUniStr
(
&
theSeed
&
originalDirectory
destDirectory
&
uniqueName
)
;
require_noerr
(
result
GenerateUniqueHFSUniStrFailed
)
;
result
=
FSRenameUnicode
(
ref
uniqueName
.
length
uniqueName
.
unicode
kTextEncodingUnknown
newRef
)
;
require_noerr
(
result
FSRenameUnicodeBeforeMoveFailed
)
;
if
(
FSCompareFSRefs
(
destDirectory
&
originalDirectory
)
!
=
noErr
)
{
result
=
FSMoveObject
(
newRef
destDirectory
newRef
)
;
require_noerr
(
result
FSMoveObjectAfterRenameFailed
)
;
}
result
=
FSRenameUnicode
(
ref
nameLength
name
textEncodingHint
newRef
)
;
require_noerr
(
result
FSRenameUnicodeAfterMoveFailed
)
;
}
else
{
result
=
FSMoveObject
(
newRef
destDirectory
newRef
)
;
require_noerr
(
result
FSMoveObjectNoRenameFailed
)
;
}
return
(
result
)
;
FSRenameUnicodeAfterMoveFailed
:
verify_noerr
(
FSMoveObject
(
newRef
&
originalDirectory
newRef
)
)
;
FSMoveObjectAfterRenameFailed
:
verify_noerr
(
FSRenameUnicode
(
newRef
originalName
.
length
originalName
.
unicode
originalTextEncodingHint
newRef
)
)
;
FSRenameUnicodeBeforeMoveFailed
:
GenerateUniqueHFSUniStrFailed
:
FSMoveObjectNoRenameFailed
:
NotSameVolume
:
SourceBad
:
DestinationBad
:
BadParameter
:
return
(
result
)
;
}
static
void
FSDeleteContainerLevel
(
const
FSRef
*
container
FSDeleteContainerGlobals
*
theGlobals
)
{
FSIterator
iterator
;
FSRef
itemToDelete
;
UInt16
nodeFlags
;
theGlobals
-
>
result
=
FSOpenIterator
(
container
kFSIterateFlat
+
kFSIterateDelete
&
iterator
)
;
require_noerr
(
theGlobals
-
>
result
FSOpenIterator
)
;
do
{
theGlobals
-
>
result
=
FSGetCatalogInfoBulk
(
iterator
1
&
theGlobals
-
>
actualObjects
NULL
kFSCatInfoNodeFlags
&
theGlobals
-
>
catalogInfo
&
itemToDelete
NULL
NULL
)
;
if
(
(
noErr
=
=
theGlobals
-
>
result
)
&
&
(
1
=
=
theGlobals
-
>
actualObjects
)
)
{
nodeFlags
=
theGlobals
-
>
catalogInfo
.
nodeFlags
;
if
(
0
!
=
(
nodeFlags
&
kFSNodeIsDirectoryMask
)
)
{
FSDeleteContainerLevel
(
&
itemToDelete
theGlobals
)
;
}
if
(
noErr
=
=
theGlobals
-
>
result
)
{
if
(
0
!
=
(
nodeFlags
&
kFSNodeLockedMask
)
)
{
theGlobals
-
>
catalogInfo
.
nodeFlags
=
nodeFlags
&
~
kFSNodeLockedMask
;
(
void
)
FSSetCatalogInfo
(
&
itemToDelete
kFSCatInfoNodeFlags
&
theGlobals
-
>
catalogInfo
)
;
}
theGlobals
-
>
result
=
FSDeleteObject
(
&
itemToDelete
)
;
}
}
}
while
(
noErr
=
=
theGlobals
-
>
result
)
;
if
(
errFSNoMoreItems
=
=
theGlobals
-
>
result
)
{
theGlobals
-
>
result
=
noErr
;
}
verify_noerr
(
FSCloseIterator
(
iterator
)
)
;
FSOpenIterator
:
return
;
}
OSErr
FSDeleteContainerContents
(
const
FSRef
*
container
)
{
FSDeleteContainerGlobals
theGlobals
;
FSDeleteContainerLevel
(
container
&
theGlobals
)
;
return
(
theGlobals
.
result
)
;
}
OSErr
FSDeleteContainer
(
const
FSRef
*
container
)
{
OSErr
result
;
FSCatalogInfo
catalogInfo
;
result
=
FSGetCatalogInfo
(
container
kFSCatInfoNodeFlags
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
require_action
(
0
!
=
(
catalogInfo
.
nodeFlags
&
kFSNodeIsDirectoryMask
)
ContainerNotDirectory
result
=
dirNFErr
)
;
result
=
FSDeleteContainerContents
(
container
)
;
require_noerr
(
result
FSDeleteContainerContents
)
;
if
(
0
!
=
(
catalogInfo
.
nodeFlags
&
kFSNodeLockedMask
)
)
{
catalogInfo
.
nodeFlags
&
=
~
kFSNodeLockedMask
;
(
void
)
FSSetCatalogInfo
(
container
kFSCatInfoNodeFlags
&
catalogInfo
)
;
}
result
=
FSDeleteObject
(
container
)
;
FSDeleteContainerContents
:
ContainerNotDirectory
:
FSGetCatalogInfo
:
return
(
result
)
;
}
static
void
FSIterateContainerLevel
(
FSIterateContainerGlobals
*
theGlobals
)
{
FSIterator
iterator
;
if
(
(
theGlobals
-
>
maxLevels
=
=
0
)
|
|
(
theGlobals
-
>
currentLevel
<
theGlobals
-
>
maxLevels
)
)
{
theGlobals
-
>
result
=
FSOpenIterator
(
&
theGlobals
-
>
ref
kFSIterateFlat
&
iterator
)
;
require_noerr
(
theGlobals
-
>
result
FSOpenIterator
)
;
+
+
theGlobals
-
>
currentLevel
;
do
{
theGlobals
-
>
result
=
FSGetCatalogInfoBulk
(
iterator
1
&
theGlobals
-
>
actualObjects
&
theGlobals
-
>
containerChanged
theGlobals
-
>
whichInfo
&
theGlobals
-
>
catalogInfo
&
theGlobals
-
>
ref
theGlobals
-
>
specPtr
theGlobals
-
>
namePtr
)
;
if
(
(
noErr
=
=
theGlobals
-
>
result
|
|
errFSNoMoreItems
=
=
theGlobals
-
>
result
)
&
&
(
0
!
=
theGlobals
-
>
actualObjects
)
)
{
theGlobals
-
>
quitFlag
=
CallIterateContainerFilterProc
(
theGlobals
-
>
iterateFilter
theGlobals
-
>
containerChanged
theGlobals
-
>
currentLevel
&
theGlobals
-
>
catalogInfo
&
theGlobals
-
>
ref
theGlobals
-
>
specPtr
theGlobals
-
>
namePtr
theGlobals
-
>
yourDataPtr
)
;
if
(
0
!
=
(
theGlobals
-
>
catalogInfo
.
nodeFlags
&
kFSNodeIsDirectoryMask
)
)
{
if
(
!
theGlobals
-
>
quitFlag
)
{
FSIterateContainerLevel
(
theGlobals
)
;
}
}
}
}
while
(
(
noErr
=
=
theGlobals
-
>
result
)
&
&
(
!
theGlobals
-
>
quitFlag
)
)
;
if
(
(
errFSNoMoreItems
=
=
theGlobals
-
>
result
)
|
|
(
afpAccessDenied
=
=
theGlobals
-
>
result
)
)
{
theGlobals
-
>
result
=
noErr
;
}
-
-
theGlobals
-
>
currentLevel
;
verify_noerr
(
FSCloseIterator
(
iterator
)
)
;
}
FSOpenIterator
:
return
;
}
OSErr
FSIterateContainer
(
const
FSRef
*
container
ItemCount
maxLevels
FSCatalogInfoBitmap
whichInfo
Boolean
wantFSSpec
Boolean
wantName
IterateContainerFilterProcPtr
iterateFilter
void
*
yourDataPtr
)
{
OSErr
result
;
FSIterateContainerGlobals
theGlobals
;
require_action
(
iterateFilter
!
=
NULL
NoIterateFilter
result
=
paramErr
)
;
theGlobals
.
iterateFilter
=
iterateFilter
;
theGlobals
.
whichInfo
=
whichInfo
|
kFSCatInfoNodeFlags
;
theGlobals
.
ref
=
*
container
;
if
(
wantFSSpec
)
{
theGlobals
.
specPtr
=
&
theGlobals
.
spec
;
}
else
{
theGlobals
.
specPtr
=
NULL
;
}
if
(
wantName
)
{
theGlobals
.
namePtr
=
&
theGlobals
.
name
;
}
else
{
theGlobals
.
namePtr
=
NULL
;
}
theGlobals
.
yourDataPtr
=
yourDataPtr
;
theGlobals
.
maxLevels
=
maxLevels
;
theGlobals
.
currentLevel
=
0
;
theGlobals
.
quitFlag
=
false
;
theGlobals
.
containerChanged
=
false
;
theGlobals
.
result
=
noErr
;
theGlobals
.
actualObjects
=
0
;
FSIterateContainerLevel
(
&
theGlobals
)
;
result
=
theGlobals
.
result
;
require_noerr
(
result
FSIterateContainerLevel
)
;
FSIterateContainerLevel
:
NoIterateFilter
:
return
(
result
)
;
}
OSErr
FSGetDirectoryItems
(
const
FSRef
*
container
FSRef
*
*
*
refsHandle
ItemCount
*
numRefs
Boolean
*
containerChanged
)
{
enum
{
kMaxItemsPerBulkCall
=
10
}
;
OSErr
result
;
OSErr
memResult
;
FSIterator
iterator
;
FSRef
refs
[
kMaxItemsPerBulkCall
]
;
ItemCount
actualObjects
;
Boolean
changed
;
require_action
(
(
NULL
!
=
refsHandle
)
&
&
(
NULL
!
=
numRefs
)
&
&
(
NULL
!
=
containerChanged
)
BadParameter
result
=
paramErr
)
;
*
numRefs
=
0
;
*
containerChanged
=
false
;
*
refsHandle
=
(
FSRef
*
*
)
NewHandle
(
0
)
;
require_action
(
NULL
!
=
*
refsHandle
NewHandle
result
=
memFullErr
)
;
result
=
FSOpenIterator
(
container
kFSIterateFlat
&
iterator
)
;
require_noerr
(
result
FSOpenIterator
)
;
do
{
result
=
FSGetCatalogInfoBulk
(
iterator
kMaxItemsPerBulkCall
&
actualObjects
&
changed
kFSCatInfoNone
NULL
refs
NULL
NULL
)
;
if
(
changed
)
{
*
containerChanged
=
changed
;
}
require
(
(
noErr
=
=
result
)
|
|
(
errFSNoMoreItems
=
=
result
)
FSGetCatalogInfoBulk
)
;
if
(
0
!
=
actualObjects
)
{
PtrAndHand
(
refs
(
Handle
)
*
refsHandle
actualObjects
*
sizeof
(
FSRef
)
)
;
memResult
=
MemError
(
)
;
require_noerr_action
(
memResult
MemoryAllocationFailed
result
=
memResult
)
;
*
numRefs
+
=
actualObjects
;
}
}
while
(
noErr
=
=
result
)
;
verify_noerr
(
FSCloseIterator
(
iterator
)
)
;
return
(
noErr
)
;
MemoryAllocationFailed
:
FSGetCatalogInfoBulk
:
verify_noerr
(
FSCloseIterator
(
iterator
)
)
;
FSOpenIterator
:
if
(
NULL
!
=
*
refsHandle
)
{
DisposeHandle
(
(
Handle
)
*
refsHandle
)
;
*
refsHandle
=
NULL
;
}
*
numRefs
=
0
;
NewHandle
:
BadParameter
:
return
(
result
)
;
}
static
OSErr
GenerateUniqueHFSUniStr
(
long
*
startSeed
const
FSRef
*
dir1
const
FSRef
*
dir2
HFSUniStr255
*
uniqueName
)
{
OSErr
result
;
long
i
;
FSRefParam
pb
;
FSRef
newRef
;
unsigned
char
hexStr
[
17
]
=
"
0123456789ABCDEF
"
;
pb
.
name
=
uniqueName
-
>
unicode
;
pb
.
nameLength
=
8
;
pb
.
textEncodingHint
=
kTextEncodingUnknown
;
pb
.
newRef
=
&
newRef
;
result
=
noErr
;
while
(
fnfErr
!
=
result
)
{
uniqueName
-
>
length
=
8
;
for
(
i
=
0
;
i
<
8
;
+
+
i
)
{
uniqueName
-
>
unicode
[
i
]
=
hexStr
[
(
(
*
startSeed
>
>
(
(
7
-
i
)
*
4
)
)
&
0xf
)
]
;
}
pb
.
ref
=
dir1
;
result
=
PBMakeFSRefUnicodeSync
(
&
pb
)
;
if
(
fnfErr
=
=
result
)
{
pb
.
ref
=
dir2
;
result
=
PBMakeFSRefUnicodeSync
(
&
pb
)
;
if
(
fnfErr
!
=
result
)
{
require_noerr
(
result
Dir2PBMakeFSRefUnicodeSyncFailed
)
;
}
}
else
{
require_noerr
(
result
Dir1PBMakeFSRefUnicodeSyncFailed
)
;
}
+
+
(
*
startSeed
)
;
}
result
=
noErr
;
Dir2PBMakeFSRefUnicodeSyncFailed
:
Dir1PBMakeFSRefUnicodeSyncFailed
:
return
(
result
)
;
}
OSErr
FSExchangeObjectsCompat
(
const
FSRef
*
sourceRef
const
FSRef
*
destRef
FSRef
*
newSourceRef
FSRef
*
newDestRef
)
{
enum
{
kGetCatInformationMask
=
(
kFSCatInfoSettableInfo
|
kFSCatInfoVolume
|
kFSCatInfoParentDirID
)
&
~
(
kFSCatInfoContentMod
|
kFSCatInfoAttrMod
)
kSetCatinformationMask
=
kFSCatInfoSettableInfo
&
~
(
kFSCatInfoContentMod
|
kFSCatInfoAttrMod
)
}
;
OSErr
result
;
GetVolParmsInfoBuffer
volParmsInfo
;
UInt32
infoSize
;
FSCatalogInfo
sourceCatalogInfo
;
FSCatalogInfo
destCatalogInfo
;
HFSUniStr255
sourceName
;
HFSUniStr255
destName
;
FSRef
sourceCurrentRef
;
FSRef
destCurrentRef
;
FSRef
sourceParentRef
;
FSRef
destParentRef
;
HFSUniStr255
sourceUniqueName
;
HFSUniStr255
destUniqueName
;
long
theSeed
;
Boolean
sameParentDirs
;
require_action
(
(
NULL
!
=
newSourceRef
)
&
&
(
NULL
!
=
newDestRef
)
BadParameter
result
=
paramErr
)
;
BlockMoveData
(
sourceRef
newSourceRef
sizeof
(
FSRef
)
)
;
BlockMoveData
(
sourceRef
&
sourceCurrentRef
sizeof
(
FSRef
)
)
;
BlockMoveData
(
destRef
newDestRef
sizeof
(
FSRef
)
)
;
BlockMoveData
(
destRef
&
destCurrentRef
sizeof
(
FSRef
)
)
;
result
=
FSGetCatalogInfo
(
&
sourceCurrentRef
kFSCatInfoVolume
&
sourceCatalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
DetermineSourceVRefNumFailed
)
;
result
=
FSGetVolParms
(
sourceCatalogInfo
.
volume
sizeof
(
GetVolParmsInfoBuffer
)
&
volParmsInfo
&
infoSize
)
;
if
(
(
noErr
=
=
result
)
&
&
VolSupportsFSExchangeObjects
(
&
volParmsInfo
)
)
{
result
=
FSExchangeObjects
(
sourceRef
destRef
)
;
}
else
{
result
=
FSGetCatalogInfo
(
&
sourceCurrentRef
kGetCatInformationMask
&
sourceCatalogInfo
&
sourceName
NULL
&
sourceParentRef
)
;
require_noerr
(
result
SourceFSGetCatalogInfoFailed
)
;
result
=
FSGetCatalogInfo
(
&
destCurrentRef
kGetCatInformationMask
&
destCatalogInfo
&
destName
NULL
&
destParentRef
)
;
require_noerr
(
result
DestFSGetCatalogInfoFailed
)
;
require_action
(
sourceCatalogInfo
.
volume
=
=
destCatalogInfo
.
volume
NotSameVolume
result
=
diffVolErr
)
;
require_action
(
(
0
=
=
(
sourceCatalogInfo
.
nodeFlags
&
kFSNodeIsDirectoryMask
)
)
&
&
(
0
=
=
(
destCatalogInfo
.
nodeFlags
&
kFSNodeIsDirectoryMask
)
)
NotAFile
result
=
notAFileErr
)
;
theSeed
=
0x4a696d4c
;
result
=
GenerateUniqueHFSUniStr
(
&
theSeed
&
sourceParentRef
&
destParentRef
&
sourceUniqueName
)
;
require_noerr
(
result
GenerateUniqueHFSUniStr1Failed
)
;
result
=
GenerateUniqueHFSUniStr
(
&
theSeed
&
sourceParentRef
&
destParentRef
&
destUniqueName
)
;
require_noerr
(
result
GenerateUniqueHFSUniStr2Failed
)
;
result
=
FSRenameUnicode
(
&
sourceCurrentRef
sourceUniqueName
.
length
sourceUniqueName
.
unicode
kTextEncodingUnknown
newSourceRef
)
;
require_noerr
(
result
FSRenameUnicode1Failed
)
;
BlockMoveData
(
newSourceRef
&
sourceCurrentRef
sizeof
(
FSRef
)
)
;
result
=
FSRenameUnicode
(
&
destCurrentRef
destUniqueName
.
length
destUniqueName
.
unicode
kTextEncodingUnknown
newDestRef
)
;
require_noerr
(
result
FSRenameUnicode2Failed
)
;
BlockMoveData
(
newDestRef
&
destCurrentRef
sizeof
(
FSRef
)
)
;
sameParentDirs
=
(
sourceCatalogInfo
.
parentDirID
=
=
destCatalogInfo
.
parentDirID
)
;
if
(
!
sameParentDirs
)
{
result
=
FSMoveObject
(
&
sourceCurrentRef
&
destParentRef
newSourceRef
)
;
require_noerr
(
result
FSMoveObject1Failed
)
;
BlockMoveData
(
newSourceRef
&
sourceCurrentRef
sizeof
(
FSRef
)
)
;
result
=
FSMoveObject
(
&
destCurrentRef
&
sourceParentRef
newDestRef
)
;
require_noerr
(
result
FSMoveObject2Failed
)
;
BlockMoveData
(
newDestRef
&
destCurrentRef
sizeof
(
FSRef
)
)
;
}
result
=
FSSetCatalogInfo
(
&
sourceCurrentRef
kSetCatinformationMask
&
destCatalogInfo
)
;
require_noerr
(
result
FSSetCatalogInfo1Failed
)
;
result
=
FSSetCatalogInfo
(
&
destCurrentRef
kSetCatinformationMask
&
sourceCatalogInfo
)
;
require_noerr
(
result
FSSetCatalogInfo2Failed
)
;
result
=
FSRenameUnicode
(
&
sourceCurrentRef
destName
.
length
destName
.
unicode
destCatalogInfo
.
textEncodingHint
newSourceRef
)
;
require_noerr
(
result
FSRenameUnicode3Failed
)
;
BlockMoveData
(
newSourceRef
&
sourceCurrentRef
sizeof
(
FSRef
)
)
;
result
=
FSRenameUnicode
(
&
destCurrentRef
sourceName
.
length
sourceName
.
unicode
sourceCatalogInfo
.
textEncodingHint
newDestRef
)
;
require_noerr
(
result
FSRenameUnicode4Failed
)
;
BlockMoveData
(
newDestRef
newSourceRef
sizeof
(
FSRef
)
)
;
BlockMoveData
(
&
sourceCurrentRef
newDestRef
sizeof
(
FSRef
)
)
;
}
return
(
result
)
;
FSRenameUnicode4Failed
:
if
(
noErr
=
=
FSRenameUnicode
(
&
sourceCurrentRef
sourceUniqueName
.
length
sourceUniqueName
.
unicode
kTextEncodingUnknown
newSourceRef
)
)
{
BlockMoveData
(
newSourceRef
&
sourceCurrentRef
sizeof
(
FSRef
)
)
;
}
FSRenameUnicode3Failed
:
verify_noerr
(
FSSetCatalogInfo
(
&
destCurrentRef
kFSCatInfoSettableInfo
&
destCatalogInfo
)
)
;
FSSetCatalogInfo2Failed
:
verify_noerr
(
FSSetCatalogInfo
(
&
sourceCurrentRef
kFSCatInfoSettableInfo
&
sourceCatalogInfo
)
)
;
FSSetCatalogInfo1Failed
:
if
(
!
sameParentDirs
)
{
if
(
noErr
=
=
FSMoveObject
(
&
destCurrentRef
&
destParentRef
newDestRef
)
)
{
BlockMoveData
(
newDestRef
&
destCurrentRef
sizeof
(
FSRef
)
)
;
}
}
FSMoveObject2Failed
:
if
(
!
sameParentDirs
)
{
if
(
noErr
=
=
FSMoveObject
(
&
sourceCurrentRef
&
sourceParentRef
newSourceRef
)
)
{
BlockMoveData
(
newSourceRef
&
sourceCurrentRef
sizeof
(
FSRef
)
)
;
}
}
FSMoveObject1Failed
:
verify_noerr
(
FSRenameUnicode
(
&
destCurrentRef
destName
.
length
destName
.
unicode
destCatalogInfo
.
textEncodingHint
newDestRef
)
)
;
FSRenameUnicode2Failed
:
verify_noerr
(
FSRenameUnicode
(
&
sourceCurrentRef
sourceName
.
length
sourceName
.
unicode
sourceCatalogInfo
.
textEncodingHint
newSourceRef
)
)
;
FSRenameUnicode1Failed
:
GenerateUniqueHFSUniStr2Failed
:
GenerateUniqueHFSUniStr1Failed
:
NotAFile
:
NotSameVolume
:
DestFSGetCatalogInfoFailed
:
SourceFSGetCatalogInfoFailed
:
DetermineSourceVRefNumFailed
:
BadParameter
:
return
(
result
)
;
}
#
pragma
mark
-
-
-
-
-
Shared
Environment
Routines
-
-
-
-
-
OSErr
MFX_FSLockRange
(
SInt16
refNum
SInt32
rangeLength
SInt32
rangeStart
)
{
OSErr
result
;
ParamBlockRec
pb
;
pb
.
ioParam
.
ioRefNum
=
refNum
;
pb
.
ioParam
.
ioReqCount
=
rangeLength
;
pb
.
ioParam
.
ioPosMode
=
fsFromStart
;
pb
.
ioParam
.
ioPosOffset
=
rangeStart
;
result
=
PBLockRangeSync
(
&
pb
)
;
require_noerr
(
result
PBLockRangeSync
)
;
PBLockRangeSync
:
return
(
result
)
;
}
OSErr
MFX_FSUnlockRange
(
SInt16
refNum
SInt32
rangeLength
SInt32
rangeStart
)
{
OSErr
result
;
ParamBlockRec
pb
;
pb
.
ioParam
.
ioRefNum
=
refNum
;
pb
.
ioParam
.
ioReqCount
=
rangeLength
;
pb
.
ioParam
.
ioPosMode
=
fsFromStart
;
pb
.
ioParam
.
ioPosOffset
=
rangeStart
;
result
=
PBUnlockRangeSync
(
&
pb
)
;
require_noerr
(
result
PBUnlockRangeSync
)
;
PBUnlockRangeSync
:
return
(
result
)
;
}
OSErr
FSGetDirAccess
(
const
FSRef
*
ref
SInt32
*
ownerID
SInt32
*
groupID
SInt32
*
accessRights
)
{
OSErr
result
;
FSSpec
spec
;
HParamBlockRec
pb
;
result
=
FSGetCatalogInfo
(
ref
kFSCatInfoNone
NULL
NULL
&
spec
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
pb
.
accessParam
.
ioNamePtr
=
(
StringPtr
)
spec
.
name
;
pb
.
accessParam
.
ioVRefNum
=
spec
.
vRefNum
;
pb
.
fileParam
.
ioDirID
=
spec
.
parID
;
result
=
PBHGetDirAccessSync
(
&
pb
)
;
require_noerr
(
result
PBHGetDirAccessSync
)
;
if
(
NULL
!
=
ownerID
)
{
*
ownerID
=
pb
.
accessParam
.
ioACOwnerID
;
}
if
(
NULL
!
=
groupID
)
{
*
groupID
=
pb
.
accessParam
.
ioACGroupID
;
}
if
(
NULL
!
=
accessRights
)
{
*
accessRights
=
pb
.
accessParam
.
ioACAccess
;
}
PBHGetDirAccessSync
:
FSGetCatalogInfo
:
return
(
result
)
;
}
OSErr
FSSetDirAccess
(
const
FSRef
*
ref
SInt32
ownerID
SInt32
groupID
SInt32
accessRights
)
{
OSErr
result
;
FSSpec
spec
;
HParamBlockRec
pb
;
enum
{
kSetDirAccessSettableMask
=
(
kioACAccessBlankAccessMask
+
kioACAccessEveryoneWriteMask
+
kioACAccessEveryoneReadMask
+
kioACAccessEveryoneSearchMask
+
kioACAccessGroupWriteMask
+
kioACAccessGroupReadMask
+
kioACAccessGroupSearchMask
+
kioACAccessOwnerWriteMask
+
kioACAccessOwnerReadMask
+
kioACAccessOwnerSearchMask
)
}
;
result
=
FSGetCatalogInfo
(
ref
kFSCatInfoNone
NULL
NULL
&
spec
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
pb
.
accessParam
.
ioNamePtr
=
(
StringPtr
)
spec
.
name
;
pb
.
accessParam
.
ioVRefNum
=
spec
.
vRefNum
;
pb
.
fileParam
.
ioDirID
=
spec
.
parID
;
pb
.
accessParam
.
ioACOwnerID
=
ownerID
;
pb
.
accessParam
.
ioACGroupID
=
groupID
;
pb
.
accessParam
.
ioACAccess
=
accessRights
&
kSetDirAccessSettableMask
;
result
=
PBHSetDirAccessSync
(
&
pb
)
;
require_noerr
(
result
PBHSetDirAccessSync
)
;
PBHSetDirAccessSync
:
FSGetCatalogInfo
:
return
(
result
)
;
}
OSErr
FSGetVolMountInfoSize
(
FSVolumeRefNum
volRefNum
SInt16
*
size
)
{
OSErr
result
;
ParamBlockRec
pb
;
require_action
(
NULL
!
=
size
BadParameter
result
=
paramErr
)
;
pb
.
ioParam
.
ioNamePtr
=
NULL
;
pb
.
ioParam
.
ioVRefNum
=
volRefNum
;
pb
.
ioParam
.
ioBuffer
=
(
Ptr
)
size
;
result
=
PBGetVolMountInfoSize
(
&
pb
)
;
require_noerr
(
result
PBGetVolMountInfoSize
)
;
PBGetVolMountInfoSize
:
BadParameter
:
return
(
result
)
;
}
OSErr
FSGetVolMountInfo
(
FSVolumeRefNum
volRefNum
void
*
volMountInfo
)
{
OSErr
result
;
ParamBlockRec
pb
;
require_action
(
NULL
!
=
volMountInfo
BadParameter
result
=
paramErr
)
;
pb
.
ioParam
.
ioNamePtr
=
NULL
;
pb
.
ioParam
.
ioVRefNum
=
volRefNum
;
pb
.
ioParam
.
ioBuffer
=
(
Ptr
)
volMountInfo
;
result
=
PBGetVolMountInfo
(
&
pb
)
;
require_noerr
(
result
PBGetVolMountInfo
)
;
PBGetVolMountInfo
:
BadParameter
:
return
(
result
)
;
}
#
if
0
OSErr
FSVolumeMount
(
const
void
*
volMountInfo
FSVolumeRefNum
*
volRefNum
)
{
OSErr
result
;
ParamBlockRec
pb
;
require_action
(
NULL
!
=
volRefNum
BadParameter
result
=
paramErr
)
;
pb
.
ioParam
.
ioBuffer
=
(
Ptr
)
volMountInfo
;
result
=
PBVolumeMount
(
&
pb
)
;
require_noerr
(
result
PBVolumeMount
)
;
*
volRefNum
=
pb
.
ioParam
.
ioVRefNum
;
PBVolumeMount
:
BadParameter
:
return
(
result
)
;
}
#
endif
OSErr
FSMapID
(
FSVolumeRefNum
volRefNum
SInt32
ugID
SInt16
objType
Str31
name
)
{
OSErr
result
;
HParamBlockRec
pb
;
require_action
(
NULL
!
=
name
BadParameter
result
=
paramErr
)
;
pb
.
objParam
.
ioNamePtr
=
NULL
;
pb
.
objParam
.
ioVRefNum
=
volRefNum
;
pb
.
objParam
.
ioObjType
=
objType
;
pb
.
objParam
.
ioObjNamePtr
=
name
;
pb
.
objParam
.
ioObjID
=
ugID
;
result
=
PBHMapIDSync
(
&
pb
)
;
require_noerr
(
result
PBHMapIDSync
)
;
PBHMapIDSync
:
BadParameter
:
return
(
result
)
;
}
OSErr
FSMapName
(
FSVolumeRefNum
volRefNum
ConstStr255Param
name
SInt16
objType
SInt32
*
ugID
)
{
OSErr
result
;
HParamBlockRec
pb
;
require_action
(
NULL
!
=
ugID
BadParameter
result
=
paramErr
)
;
pb
.
objParam
.
ioNamePtr
=
NULL
;
pb
.
objParam
.
ioVRefNum
=
volRefNum
;
pb
.
objParam
.
ioObjType
=
objType
;
pb
.
objParam
.
ioObjNamePtr
=
(
StringPtr
)
name
;
result
=
PBHMapNameSync
(
&
pb
)
;
require_noerr
(
result
PBHMapNameSync
)
;
*
ugID
=
pb
.
objParam
.
ioObjID
;
PBHMapNameSync
:
BadParameter
:
return
(
result
)
;
}
OSErr
FSCopyFile
(
const
FSRef
*
srcFileRef
const
FSRef
*
dstDirectoryRef
UniCharCount
nameLength
const
UniChar
*
copyName
TextEncoding
textEncodingHint
FSRef
*
newRef
)
{
OSErr
result
;
FSSpec
srcFileSpec
;
FSCatalogInfo
catalogInfo
;
HParamBlockRec
pb
;
Str31
hfsName
;
GetVolParmsInfoBuffer
volParmsInfo
;
UInt32
infoSize
;
result
=
FSGetCatalogInfo
(
srcFileRef
kFSCatInfoNone
NULL
NULL
&
srcFileSpec
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo_srcFileRef
)
;
result
=
FSGetVolParms
(
srcFileSpec
.
vRefNum
sizeof
(
GetVolParmsInfoBuffer
)
&
volParmsInfo
&
infoSize
)
;
require_action
(
(
noErr
=
=
result
)
&
&
VolHasCopyFile
(
&
volParmsInfo
)
NoCopyFileSupport
result
=
paramErr
)
;
result
=
FSGetCatalogInfo
(
dstDirectoryRef
kFSCatInfoVolume
+
kFSCatInfoNodeID
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo_dstDirectoryRef
)
;
pb
.
copyParam
.
ioVRefNum
=
srcFileSpec
.
vRefNum
;
pb
.
copyParam
.
ioDirID
=
srcFileSpec
.
parID
;
pb
.
copyParam
.
ioNamePtr
=
(
StringPtr
)
srcFileSpec
.
name
;
pb
.
copyParam
.
ioDstVRefNum
=
catalogInfo
.
volume
;
pb
.
copyParam
.
ioNewDirID
=
(
long
)
catalogInfo
.
nodeID
;
pb
.
copyParam
.
ioNewName
=
NULL
;
if
(
NULL
!
=
copyName
)
{
result
=
UnicodeNameGetHFSName
(
nameLength
copyName
textEncodingHint
false
hfsName
)
;
require_noerr
(
result
UnicodeNameGetHFSName
)
;
pb
.
copyParam
.
ioCopyName
=
hfsName
;
}
else
{
pb
.
copyParam
.
ioCopyName
=
NULL
;
}
result
=
PBHCopyFileSync
(
&
pb
)
;
require_noerr
(
result
PBHCopyFileSync
)
;
if
(
NULL
!
=
newRef
)
{
verify_noerr
(
FSMakeFSRef
(
pb
.
copyParam
.
ioDstVRefNum
pb
.
copyParam
.
ioNewDirID
pb
.
copyParam
.
ioCopyName
newRef
)
)
;
}
PBHCopyFileSync
:
UnicodeNameGetHFSName
:
FSGetCatalogInfo_dstDirectoryRef
:
NoCopyFileSupport
:
FSGetCatalogInfo_srcFileRef
:
return
(
result
)
;
}
OSErr
FSMoveRename
(
const
FSRef
*
srcFileRef
const
FSRef
*
dstDirectoryRef
UniCharCount
nameLength
const
UniChar
*
moveName
TextEncoding
textEncodingHint
FSRef
*
newRef
)
{
OSErr
result
;
FSSpec
srcFileSpec
;
FSCatalogInfo
catalogInfo
;
HParamBlockRec
pb
;
Str31
hfsName
;
GetVolParmsInfoBuffer
volParmsInfo
;
UInt32
infoSize
;
result
=
FSGetCatalogInfo
(
srcFileRef
kFSCatInfoNone
NULL
NULL
&
srcFileSpec
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo_srcFileRef
)
;
result
=
FSGetVolParms
(
srcFileSpec
.
vRefNum
sizeof
(
GetVolParmsInfoBuffer
)
&
volParmsInfo
&
infoSize
)
;
require_action
(
(
noErr
=
=
result
)
&
&
VolHasMoveRename
(
&
volParmsInfo
)
NoMoveRenameSupport
result
=
paramErr
)
;
result
=
FSGetCatalogInfo
(
dstDirectoryRef
kFSCatInfoVolume
+
kFSCatInfoNodeID
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo_dstDirectoryRef
)
;
require_action
(
srcFileSpec
.
vRefNum
=
=
catalogInfo
.
volume
NotSameVolume
result
=
diffVolErr
)
;
pb
.
copyParam
.
ioVRefNum
=
srcFileSpec
.
vRefNum
;
pb
.
copyParam
.
ioDirID
=
srcFileSpec
.
parID
;
pb
.
copyParam
.
ioNamePtr
=
(
StringPtr
)
srcFileSpec
.
name
;
pb
.
copyParam
.
ioNewDirID
=
(
long
)
catalogInfo
.
nodeID
;
pb
.
copyParam
.
ioNewName
=
NULL
;
if
(
NULL
!
=
moveName
)
{
result
=
UnicodeNameGetHFSName
(
nameLength
moveName
textEncodingHint
false
hfsName
)
;
require_noerr
(
result
UnicodeNameGetHFSName
)
;
pb
.
copyParam
.
ioCopyName
=
hfsName
;
}
else
{
pb
.
copyParam
.
ioCopyName
=
NULL
;
}
result
=
PBHMoveRenameSync
(
&
pb
)
;
require_noerr
(
result
PBHMoveRenameSync
)
;
if
(
NULL
!
=
newRef
)
{
verify_noerr
(
FSMakeFSRef
(
pb
.
copyParam
.
ioVRefNum
pb
.
copyParam
.
ioNewDirID
pb
.
copyParam
.
ioCopyName
newRef
)
)
;
}
PBHMoveRenameSync
:
UnicodeNameGetHFSName
:
NotSameVolume
:
FSGetCatalogInfo_dstDirectoryRef
:
NoMoveRenameSupport
:
FSGetCatalogInfo_srcFileRef
:
return
(
result
)
;
}
#
pragma
mark
-
-
-
-
-
File
ID
Routines
-
-
-
-
-
OSErr
FSResolveFileIDRef
(
FSVolumeRefNum
volRefNum
SInt32
fileID
FSRef
*
ref
)
{
OSErr
result
;
FIDParam
pb
;
Str255
tempStr
;
require_action
(
NULL
!
=
ref
BadParameter
result
=
paramErr
)
;
tempStr
[
0
]
=
0
;
pb
.
ioNamePtr
=
tempStr
;
pb
.
ioVRefNum
=
volRefNum
;
pb
.
ioFileID
=
fileID
;
result
=
PBResolveFileIDRefSync
(
(
HParmBlkPtr
)
&
pb
)
;
require_noerr
(
result
PBResolveFileIDRefSync
)
;
result
=
FSMakeFSRef
(
volRefNum
pb
.
ioSrcDirID
tempStr
ref
)
;
require_noerr
(
result
FSMakeFSRef
)
;
FSMakeFSRef
:
PBResolveFileIDRefSync
:
BadParameter
:
return
(
result
)
;
}
OSErr
FSCreateFileIDRef
(
const
FSRef
*
ref
SInt32
*
fileID
)
{
OSErr
result
;
FSSpec
spec
;
FIDParam
pb
;
require_action
(
NULL
!
=
fileID
BadParameter
result
=
paramErr
)
;
result
=
FSGetCatalogInfo
(
ref
kFSCatInfoNone
NULL
NULL
&
spec
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
pb
.
ioNamePtr
=
(
StringPtr
)
spec
.
name
;
pb
.
ioVRefNum
=
spec
.
vRefNum
;
pb
.
ioSrcDirID
=
spec
.
parID
;
result
=
PBCreateFileIDRefSync
(
(
HParmBlkPtr
)
&
pb
)
;
require
(
(
noErr
=
=
result
)
|
|
(
fidExists
=
=
result
)
|
|
(
afpIDExists
=
=
result
)
PBCreateFileIDRefSync
)
;
*
fileID
=
pb
.
ioFileID
;
PBCreateFileIDRefSync
:
FSGetCatalogInfo
:
BadParameter
:
return
(
result
)
;
}
#
pragma
mark
-
-
-
-
-
Utility
Routines
-
-
-
-
-
Ptr
GetTempBuffer
(
ByteCount
buffReqSize
ByteCount
*
buffActSize
)
{
enum
{
kSlopMemory
=
0x00008000
}
;
Ptr
tempPtr
;
require_action
(
NULL
!
=
buffActSize
BadParameter
tempPtr
=
NULL
)
;
buffReqSize
=
buffReqSize
&
0xfffff000
;
if
(
buffReqSize
<
0x00001000
)
{
buffReqSize
=
0x00001000
;
}
tempPtr
=
NewPtr
(
buffReqSize
)
;
if
(
(
tempPtr
=
=
NULL
)
&
&
(
buffReqSize
>
0x00001000
)
)
{
long
freeMemory
=
(
FreeMem
(
)
-
kSlopMemory
)
&
0xfffff000
;
buffReqSize
=
MaxBlock
(
)
&
0xfffff000
;
if
(
buffReqSize
>
freeMemory
)
{
buffReqSize
=
freeMemory
;
}
if
(
buffReqSize
=
=
0
)
{
buffReqSize
=
0x00001000
;
}
tempPtr
=
NewPtr
(
buffReqSize
)
;
}
if
(
tempPtr
!
=
NULL
)
{
*
buffActSize
=
buffReqSize
;
}
else
{
*
buffActSize
=
0
;
}
BadParameter
:
return
(
tempPtr
)
;
}
OSErr
FileRefNumGetFSRef
(
short
refNum
FSRef
*
ref
)
{
return
(
FSGetForkCBInfo
(
refNum
0
NULL
NULL
NULL
ref
NULL
)
)
;
}
OSErr
FSSetDefault
(
const
FSRef
*
newDefault
FSRef
*
oldDefault
)
{
OSErr
result
;
FSVolumeRefNum
vRefNum
;
long
dirID
;
FSCatalogInfo
catalogInfo
;
require_action
(
(
NULL
!
=
newDefault
)
&
&
(
NULL
!
=
oldDefault
)
BadParameter
result
=
paramErr
)
;
result
=
FSGetCatalogInfo
(
newDefault
kFSCatInfoNodeFlags
+
kFSCatInfoVolume
+
kFSCatInfoNodeID
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
require_action
(
0
!
=
(
kFSNodeIsDirectoryMask
&
catalogInfo
.
nodeFlags
)
NewDefaultNotDirectory
result
=
dirNFErr
)
;
result
=
HGetVol
(
NULL
&
vRefNum
&
dirID
)
;
require_noerr
(
result
HGetVol
)
;
result
=
FSMakeFSRef
(
vRefNum
dirID
NULL
oldDefault
)
;
require_noerr
(
result
FSMakeFSRef
)
;
result
=
HSetVol
(
NULL
catalogInfo
.
volume
catalogInfo
.
nodeID
)
;
require_noerr
(
result
HSetVol
)
;
HSetVol
:
FSMakeFSRef
:
HGetVol
:
NewDefaultNotDirectory
:
FSGetCatalogInfo
:
BadParameter
:
return
(
result
)
;
}
OSErr
FSRestoreDefault
(
const
FSRef
*
oldDefault
)
{
OSErr
result
;
FSCatalogInfo
catalogInfo
;
require_action
(
NULL
!
=
oldDefault
BadParameter
result
=
paramErr
)
;
result
=
FSGetCatalogInfo
(
oldDefault
kFSCatInfoNodeFlags
+
kFSCatInfoVolume
+
kFSCatInfoNodeID
&
catalogInfo
NULL
NULL
NULL
)
;
require_noerr
(
result
FSGetCatalogInfo
)
;
require_action
(
0
!
=
(
kFSNodeIsDirectoryMask
&
catalogInfo
.
nodeFlags
)
OldDefaultNotDirectory
result
=
dirNFErr
)
;
result
=
HSetVol
(
NULL
catalogInfo
.
volume
catalogInfo
.
nodeID
)
;
require_noerr
(
result
HSetVol
)
;
HSetVol
:
OldDefaultNotDirectory
:
FSGetCatalogInfo
:
BadParameter
:
return
(
result
)
;
}
