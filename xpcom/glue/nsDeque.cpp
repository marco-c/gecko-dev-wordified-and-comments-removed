#
include
"
nsDeque
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
<
string
.
h
>
#
ifdef
DEBUG_rickg
#
include
<
stdio
.
h
>
#
endif
#
include
"
mozilla
/
CheckedInt
.
h
"
#
define
modasgn
(
x
y
)
if
(
x
<
0
)
x
+
=
y
;
x
%
=
y
#
define
modulus
(
x
y
)
(
(
x
<
0
)
?
(
x
+
y
)
%
(
y
)
:
(
x
)
%
(
y
)
)
nsDeque
:
:
nsDeque
(
nsDequeFunctor
*
aDeallocator
)
{
MOZ_COUNT_CTOR
(
nsDeque
)
;
mDeallocator
=
aDeallocator
;
mOrigin
=
mSize
=
0
;
mData
=
mBuffer
;
mCapacity
=
sizeof
(
mBuffer
)
/
sizeof
(
mBuffer
[
0
]
)
;
memset
(
mData
0
mCapacity
*
sizeof
(
mBuffer
[
0
]
)
)
;
}
nsDeque
:
:
~
nsDeque
(
)
{
MOZ_COUNT_DTOR
(
nsDeque
)
;
#
ifdef
DEBUG_rickg
char
buffer
[
30
]
;
printf
(
"
Capacity
:
%
i
\
n
"
mCapacity
)
;
static
int
mCaps
[
15
]
=
{
0
}
;
switch
(
mCapacity
)
{
case
4
:
mCaps
[
0
]
+
+
;
break
;
case
8
:
mCaps
[
1
]
+
+
;
break
;
case
16
:
mCaps
[
2
]
+
+
;
break
;
case
32
:
mCaps
[
3
]
+
+
;
break
;
case
64
:
mCaps
[
4
]
+
+
;
break
;
case
128
:
mCaps
[
5
]
+
+
;
break
;
case
256
:
mCaps
[
6
]
+
+
;
break
;
case
512
:
mCaps
[
7
]
+
+
;
break
;
case
1024
:
mCaps
[
8
]
+
+
;
break
;
case
2048
:
mCaps
[
9
]
+
+
;
break
;
case
4096
:
mCaps
[
10
]
+
+
;
break
;
default
:
break
;
}
#
endif
Erase
(
)
;
if
(
mData
&
&
mData
!
=
mBuffer
)
{
free
(
mData
)
;
}
mData
=
0
;
SetDeallocator
(
0
)
;
}
size_t
nsDeque
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
size
=
0
;
if
(
mData
!
=
mBuffer
)
{
size
+
=
aMallocSizeOf
(
mData
)
;
}
if
(
mDeallocator
)
{
size
+
=
aMallocSizeOf
(
mDeallocator
)
;
}
return
size
;
}
size_t
nsDeque
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
void
nsDeque
:
:
SetDeallocator
(
nsDequeFunctor
*
aDeallocator
)
{
delete
mDeallocator
;
mDeallocator
=
aDeallocator
;
}
void
nsDeque
:
:
Empty
(
)
{
if
(
mSize
&
&
mData
)
{
memset
(
mData
0
mCapacity
*
sizeof
(
*
mData
)
)
;
}
mSize
=
0
;
mOrigin
=
0
;
}
void
nsDeque
:
:
Erase
(
)
{
if
(
mDeallocator
&
&
mSize
)
{
ForEach
(
*
mDeallocator
)
;
}
Empty
(
)
;
}
bool
nsDeque
:
:
GrowCapacity
(
)
{
mozilla
:
:
CheckedInt
<
int32_t
>
newCapacity
=
mCapacity
;
newCapacity
*
=
4
;
NS_ASSERTION
(
newCapacity
.
isValid
(
)
"
Overflow
"
)
;
if
(
!
newCapacity
.
isValid
(
)
)
{
return
false
;
}
mozilla
:
:
CheckedInt
<
int32_t
>
newByteSize
=
newCapacity
;
newByteSize
*
=
sizeof
(
void
*
)
;
NS_ASSERTION
(
newByteSize
.
isValid
(
)
"
Overflow
"
)
;
if
(
!
newByteSize
.
isValid
(
)
)
{
return
false
;
}
void
*
*
temp
=
(
void
*
*
)
malloc
(
newByteSize
.
value
(
)
)
;
if
(
!
temp
)
{
return
false
;
}
memcpy
(
temp
mData
+
mOrigin
sizeof
(
void
*
)
*
(
mCapacity
-
mOrigin
)
)
;
memcpy
(
temp
+
(
mCapacity
-
mOrigin
)
mData
sizeof
(
void
*
)
*
mOrigin
)
;
if
(
mData
!
=
mBuffer
)
{
free
(
mData
)
;
}
mCapacity
=
newCapacity
.
value
(
)
;
mOrigin
=
0
;
mData
=
temp
;
return
true
;
}
bool
nsDeque
:
:
Push
(
void
*
aItem
const
fallible_t
&
)
{
if
(
mSize
=
=
mCapacity
&
&
!
GrowCapacity
(
)
)
{
return
false
;
}
mData
[
modulus
(
mOrigin
+
mSize
mCapacity
)
]
=
aItem
;
mSize
+
+
;
return
true
;
}
bool
nsDeque
:
:
PushFront
(
void
*
aItem
const
fallible_t
&
)
{
mOrigin
-
-
;
modasgn
(
mOrigin
mCapacity
)
;
if
(
mSize
=
=
mCapacity
)
{
if
(
!
GrowCapacity
(
)
)
{
return
false
;
}
mData
[
mSize
]
=
mData
[
mOrigin
]
;
}
mData
[
mOrigin
]
=
aItem
;
mSize
+
+
;
return
true
;
}
void
*
nsDeque
:
:
Pop
(
)
{
void
*
result
=
0
;
if
(
mSize
>
0
)
{
-
-
mSize
;
int32_t
offset
=
modulus
(
mSize
+
mOrigin
mCapacity
)
;
result
=
mData
[
offset
]
;
mData
[
offset
]
=
0
;
if
(
!
mSize
)
{
mOrigin
=
0
;
}
}
return
result
;
}
void
*
nsDeque
:
:
PopFront
(
)
{
void
*
result
=
0
;
if
(
mSize
>
0
)
{
NS_ASSERTION
(
mOrigin
<
mCapacity
"
Error
:
Bad
origin
"
)
;
result
=
mData
[
mOrigin
]
;
mData
[
mOrigin
+
+
]
=
0
;
mSize
-
-
;
if
(
mCapacity
=
=
mOrigin
|
|
!
mSize
)
{
mOrigin
=
0
;
}
}
return
result
;
}
void
*
nsDeque
:
:
Peek
(
)
{
void
*
result
=
0
;
if
(
mSize
>
0
)
{
result
=
mData
[
modulus
(
mSize
-
1
+
mOrigin
mCapacity
)
]
;
}
return
result
;
}
void
*
nsDeque
:
:
PeekFront
(
)
{
void
*
result
=
0
;
if
(
mSize
>
0
)
{
result
=
mData
[
mOrigin
]
;
}
return
result
;
}
void
*
nsDeque
:
:
ObjectAt
(
int32_t
aIndex
)
const
{
void
*
result
=
0
;
if
(
aIndex
>
=
0
&
&
aIndex
<
mSize
)
{
result
=
mData
[
modulus
(
mOrigin
+
aIndex
mCapacity
)
]
;
}
return
result
;
}
void
*
nsDeque
:
:
RemoveObjectAt
(
int32_t
aIndex
)
{
if
(
aIndex
<
0
|
|
aIndex
>
=
mSize
)
{
return
0
;
}
void
*
result
=
mData
[
modulus
(
mOrigin
+
aIndex
mCapacity
)
]
;
for
(
int32_t
i
=
aIndex
;
i
<
mSize
;
+
+
i
)
{
mData
[
modulus
(
mOrigin
+
i
mCapacity
)
]
=
mData
[
modulus
(
mOrigin
+
i
+
1
mCapacity
)
]
;
}
mSize
-
-
;
return
result
;
}
void
*
nsDeque
:
:
Last
(
)
const
{
return
ObjectAt
(
mSize
-
1
)
;
}
void
nsDeque
:
:
ForEach
(
nsDequeFunctor
&
aFunctor
)
const
{
for
(
int32_t
i
=
0
;
i
<
mSize
;
+
+
i
)
{
aFunctor
(
ObjectAt
(
i
)
)
;
}
}
const
void
*
nsDeque
:
:
FirstThat
(
nsDequeFunctor
&
aFunctor
)
const
{
for
(
int32_t
i
=
0
;
i
<
mSize
;
+
+
i
)
{
void
*
obj
=
aFunctor
(
ObjectAt
(
i
)
)
;
if
(
obj
)
{
return
obj
;
}
}
return
0
;
}
