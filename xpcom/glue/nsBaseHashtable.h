#
ifndef
nsBaseHashtable_h__
#
define
nsBaseHashtable_h__
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
prlock
.
h
"
#
include
"
nsDebug
.
h
"
enum
PLDHashOperator
{
PL_DHASH_NEXT
=
0
PL_DHASH_STOP
=
1
PL_DHASH_REMOVE
=
2
}
;
template
<
class
KeyClass
class
DataType
class
UserDataType
>
class
nsBaseHashtable
;
template
<
class
KeyClass
class
DataType
>
class
nsBaseHashtableET
:
public
KeyClass
{
public
:
DataType
mData
;
friend
class
nsTHashtable
<
nsBaseHashtableET
<
KeyClass
DataType
>
>
;
private
:
typedef
typename
KeyClass
:
:
KeyType
KeyType
;
typedef
typename
KeyClass
:
:
KeyTypePointer
KeyTypePointer
;
explicit
nsBaseHashtableET
(
KeyTypePointer
aKey
)
;
nsBaseHashtableET
(
nsBaseHashtableET
<
KeyClass
DataType
>
&
&
aToMove
)
;
~
nsBaseHashtableET
(
)
;
}
;
template
<
class
KeyClass
class
DataType
class
UserDataType
>
class
nsBaseHashtable
:
protected
nsTHashtable
<
nsBaseHashtableET
<
KeyClass
DataType
>
>
{
typedef
mozilla
:
:
fallible_t
fallible_t
;
public
:
typedef
typename
KeyClass
:
:
KeyType
KeyType
;
typedef
nsBaseHashtableET
<
KeyClass
DataType
>
EntryType
;
using
nsTHashtable
<
EntryType
>
:
:
Contains
;
nsBaseHashtable
(
)
{
}
explicit
nsBaseHashtable
(
uint32_t
aInitLength
)
:
nsTHashtable
<
EntryType
>
(
aInitLength
)
{
}
uint32_t
Count
(
)
const
{
return
nsTHashtable
<
EntryType
>
:
:
Count
(
)
;
}
bool
Get
(
KeyType
aKey
UserDataType
*
aData
)
const
{
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
false
;
}
if
(
aData
)
{
*
aData
=
ent
-
>
mData
;
}
return
true
;
}
UserDataType
Get
(
KeyType
aKey
)
const
{
EntryType
*
ent
=
this
-
>
GetEntry
(
aKey
)
;
if
(
!
ent
)
{
return
0
;
}
return
ent
-
>
mData
;
}
void
Put
(
KeyType
aKey
const
UserDataType
&
aData
)
{
if
(
!
Put
(
aKey
aData
mozilla
:
:
fallible
)
)
{
NS_ABORT_OOM
(
this
-
>
mTable
.
EntrySize
(
)
*
this
-
>
mTable
.
EntryCount
(
)
)
;
}
}
MOZ_WARN_UNUSED_RESULT
bool
Put
(
KeyType
aKey
const
UserDataType
&
aData
const
fallible_t
&
)
{
EntryType
*
ent
=
this
-
>
PutEntry
(
aKey
)
;
if
(
!
ent
)
{
return
false
;
}
ent
-
>
mData
=
aData
;
return
true
;
}
void
Remove
(
KeyType
aKey
)
{
this
-
>
RemoveEntry
(
aKey
)
;
}
typedef
PLDHashOperator
(
*
EnumReadFunction
)
(
KeyType
aKey
UserDataType
aData
void
*
aUserArg
)
;
uint32_t
EnumerateRead
(
EnumReadFunction
aEnumFunc
void
*
aUserArg
)
const
{
uint32_t
n
=
0
;
for
(
auto
iter
=
this
-
>
mTable
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
EntryType
*
>
(
iter
.
Get
(
)
)
;
PLDHashOperator
op
=
aEnumFunc
(
entry
-
>
GetKey
(
)
entry
-
>
mData
aUserArg
)
;
n
+
+
;
MOZ_ASSERT
(
!
(
op
&
PL_DHASH_REMOVE
)
)
;
if
(
op
&
PL_DHASH_STOP
)
{
break
;
}
}
return
n
;
}
typedef
PLDHashOperator
(
*
EnumFunction
)
(
KeyType
aKey
DataType
&
aData
void
*
aUserArg
)
;
uint32_t
Enumerate
(
EnumFunction
aEnumFunc
void
*
aUserArg
)
{
uint32_t
n
=
0
;
for
(
auto
iter
=
this
-
>
mTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
EntryType
*
>
(
iter
.
Get
(
)
)
;
PLDHashOperator
op
=
aEnumFunc
(
entry
-
>
GetKey
(
)
entry
-
>
mData
aUserArg
)
;
n
+
+
;
if
(
op
&
PL_DHASH_REMOVE
)
{
iter
.
Remove
(
)
;
}
if
(
op
&
PL_DHASH_STOP
)
{
break
;
}
}
return
n
;
}
class
Iterator
:
public
PLDHashTable
:
:
Iterator
{
public
:
typedef
PLDHashTable
:
:
Iterator
Base
;
explicit
Iterator
(
nsBaseHashtable
*
aTable
)
:
Base
(
&
aTable
-
>
mTable
)
{
}
Iterator
(
Iterator
&
&
aOther
)
:
Base
(
aOther
.
mTable
)
{
}
~
Iterator
(
)
{
}
KeyType
Key
(
)
const
{
return
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
GetKey
(
)
;
}
UserDataType
UserData
(
)
const
{
return
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
mData
;
}
DataType
&
Data
(
)
const
{
return
static_cast
<
EntryType
*
>
(
Get
(
)
)
-
>
mData
;
}
private
:
Iterator
(
)
=
delete
;
Iterator
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
)
=
delete
;
Iterator
&
operator
=
(
const
Iterator
&
&
)
=
delete
;
}
;
Iterator
Iter
(
)
{
return
Iterator
(
this
)
;
}
Iterator
ConstIter
(
)
const
{
return
Iterator
(
const_cast
<
nsBaseHashtable
*
>
(
this
)
)
;
}
void
Clear
(
)
{
nsTHashtable
<
EntryType
>
:
:
Clear
(
)
;
}
size_t
ShallowSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
this
-
>
mTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
ShallowSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
#
ifdef
DEBUG
using
nsTHashtable
<
EntryType
>
:
:
MarkImmutable
;
#
endif
}
;
template
<
class
KeyClass
class
DataType
>
nsBaseHashtableET
<
KeyClass
DataType
>
:
:
nsBaseHashtableET
(
KeyTypePointer
aKey
)
:
KeyClass
(
aKey
)
mData
(
)
{
}
template
<
class
KeyClass
class
DataType
>
nsBaseHashtableET
<
KeyClass
DataType
>
:
:
nsBaseHashtableET
(
nsBaseHashtableET
<
KeyClass
DataType
>
&
&
aToMove
)
:
KeyClass
(
mozilla
:
:
Move
(
aToMove
)
)
mData
(
mozilla
:
:
Move
(
aToMove
.
mData
)
)
{
}
template
<
class
KeyClass
class
DataType
>
nsBaseHashtableET
<
KeyClass
DataType
>
:
:
~
nsBaseHashtableET
(
)
{
}
#
endif
