#
ifndef
mozilla_FileUtils_h
#
define
mozilla_FileUtils_h
#
include
"
nscore
.
h
"
#
if
defined
(
XP_UNIX
)
#
include
<
unistd
.
h
>
#
elif
defined
(
XP_WIN
)
#
include
<
io
.
h
>
#
endif
#
include
"
prio
.
h
"
#
include
"
prlink
.
h
"
#
include
<
memory
>
#
include
"
nsIFile
.
h
"
#
include
<
errno
.
h
>
#
include
<
limits
.
h
>
namespace
mozilla
{
#
if
defined
(
XP_WIN
)
typedef
void
*
filedesc_t
;
typedef
const
wchar_t
*
pathstr_t
;
#
else
typedef
int
filedesc_t
;
typedef
const
char
*
pathstr_t
;
#
endif
#
if
defined
(
MOZILLA_INTERNAL_API
)
struct
PRCloseDeleter
{
void
operator
(
)
(
PRFileDesc
*
aFd
)
{
if
(
aFd
)
{
PR_Close
(
aFd
)
;
}
}
}
;
using
AutoFDClose
=
UniquePtr
<
PRFileDesc
PRCloseDeleter
>
;
struct
FCloseDeleter
{
void
operator
(
)
(
FILE
*
p
)
{
if
(
p
)
{
fclose
(
p
)
;
}
}
}
;
using
ScopedCloseFile
=
UniquePtr
<
FILE
FCloseDeleter
>
;
bool
fallocate
(
PRFileDesc
*
aFD
int64_t
aLength
)
;
void
ReadAheadLib
(
nsIFile
*
aFile
)
;
void
ReadAheadFile
(
nsIFile
*
aFile
const
size_t
aOffset
=
0
const
size_t
aCount
=
SIZE_MAX
filedesc_t
*
aOutFd
=
nullptr
)
;
PathString
GetLibraryName
(
pathstr_t
aDirectory
const
char
*
aLib
)
;
PathString
GetLibraryFilePathname
(
pathstr_t
aName
PRFuncPtr
aAddr
)
;
#
endif
void
ReadAheadLib
(
pathstr_t
aFilePath
)
;
void
ReadAheadFile
(
pathstr_t
aFilePath
const
size_t
aOffset
=
0
const
size_t
aCount
=
SIZE_MAX
filedesc_t
*
aOutFd
=
nullptr
)
;
void
ReadAhead
(
filedesc_t
aFd
const
size_t
aOffset
=
0
const
size_t
aCount
=
SIZE_MAX
)
;
}
#
endif
