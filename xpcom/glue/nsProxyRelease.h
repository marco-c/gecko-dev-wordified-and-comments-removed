#
ifndef
nsProxyRelease_h__
#
define
nsProxyRelease_h__
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
ifdef
XPCOM_GLUE_AVOID_NSPR
#
error
NS_ProxyRelease
implementation
depends
on
NSPR
.
#
endif
namespace
detail
{
template
<
typename
T
>
class
ProxyReleaseEvent
:
public
mozilla
:
:
Runnable
{
public
:
explicit
ProxyReleaseEvent
(
already_AddRefed
<
T
>
aDoomed
)
:
mDoomed
(
aDoomed
.
take
(
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
NS_IF_RELEASE
(
mDoomed
)
;
return
NS_OK
;
}
private
:
T
*
MOZ_OWNING_REF
mDoomed
;
}
;
template
<
typename
T
>
void
ProxyRelease
(
nsIEventTarget
*
aTarget
already_AddRefed
<
T
>
aDoomed
bool
aAlwaysProxy
)
{
RefPtr
<
T
>
doomed
=
aDoomed
;
nsresult
rv
;
if
(
!
doomed
|
|
!
aTarget
)
{
return
;
}
if
(
!
aAlwaysProxy
)
{
bool
onCurrentThread
=
false
;
rv
=
aTarget
-
>
IsOnCurrentThread
(
&
onCurrentThread
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
onCurrentThread
)
{
return
;
}
}
nsCOMPtr
<
nsIRunnable
>
ev
=
new
ProxyReleaseEvent
<
T
>
(
doomed
.
forget
(
)
)
;
rv
=
aTarget
-
>
Dispatch
(
ev
NS_DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
post
proxy
release
event
leaking
!
"
)
;
}
}
template
<
bool
nsISupportsBased
>
struct
ProxyReleaseChooser
{
template
<
typename
T
>
static
void
ProxyRelease
(
nsIEventTarget
*
aTarget
already_AddRefed
<
T
>
aDoomed
bool
aAlwaysProxy
)
{
:
:
detail
:
:
ProxyRelease
(
aTarget
mozilla
:
:
Move
(
aDoomed
)
aAlwaysProxy
)
;
}
}
;
template
<
>
struct
ProxyReleaseChooser
<
true
>
{
template
<
typename
T
>
static
void
ProxyRelease
(
nsIEventTarget
*
aTarget
already_AddRefed
<
T
>
aDoomed
bool
aAlwaysProxy
)
{
ProxyReleaseISupports
(
aTarget
ToSupports
(
aDoomed
.
take
(
)
)
aAlwaysProxy
)
;
}
static
void
ProxyReleaseISupports
(
nsIEventTarget
*
aTarget
nsISupports
*
aDoomed
bool
aAlwaysProxy
)
;
}
;
}
template
<
class
T
>
inline
NS_HIDDEN_
(
void
)
NS_ProxyRelease
(
nsIEventTarget
*
aTarget
already_AddRefed
<
T
>
aDoomed
bool
aAlwaysProxy
=
false
)
{
:
:
detail
:
:
ProxyReleaseChooser
<
mozilla
:
:
IsBaseOf
<
nsISupports
T
>
:
:
value
>
:
:
ProxyRelease
(
aTarget
mozilla
:
:
Move
(
aDoomed
)
aAlwaysProxy
)
;
}
template
<
class
T
>
inline
NS_HIDDEN_
(
void
)
NS_ReleaseOnMainThread
(
already_AddRefed
<
T
>
aDoomed
bool
aAlwaysProxy
=
false
)
{
nsCOMPtr
<
nsIThread
>
mainThread
;
if
(
!
NS_IsMainThread
(
)
|
|
aAlwaysProxy
)
{
nsresult
rv
=
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Could
not
get
main
thread
;
leaking
an
object
!
"
)
;
mozilla
:
:
Unused
<
<
aDoomed
.
take
(
)
;
return
;
}
}
NS_ProxyRelease
(
mainThread
mozilla
:
:
Move
(
aDoomed
)
aAlwaysProxy
)
;
}
template
<
class
T
>
class
nsMainThreadPtrHolder
final
{
public
:
explicit
nsMainThreadPtrHolder
(
T
*
aPtr
bool
aStrict
=
true
)
:
mRawPtr
(
nullptr
)
mStrict
(
aStrict
)
{
MOZ_ASSERT
(
!
mStrict
|
|
NS_IsMainThread
(
)
)
;
NS_IF_ADDREF
(
mRawPtr
=
aPtr
)
;
}
explicit
nsMainThreadPtrHolder
(
already_AddRefed
<
T
>
aPtr
bool
aString
=
true
)
:
mRawPtr
(
aPtr
.
take
(
)
)
mStrict
(
aString
)
{
}
private
:
~
nsMainThreadPtrHolder
(
)
{
if
(
NS_IsMainThread
(
)
)
{
NS_IF_RELEASE
(
mRawPtr
)
;
}
else
if
(
mRawPtr
)
{
NS_ReleaseOnMainThread
(
dont_AddRef
(
mRawPtr
)
)
;
}
}
public
:
T
*
get
(
)
{
if
(
mStrict
&
&
MOZ_UNLIKELY
(
!
NS_IsMainThread
(
)
)
)
{
NS_ERROR
(
"
Can
'
t
dereference
nsMainThreadPtrHolder
off
main
thread
"
)
;
MOZ_CRASH
(
)
;
}
return
mRawPtr
;
}
bool
operator
=
=
(
const
nsMainThreadPtrHolder
<
T
>
&
aOther
)
const
{
return
mRawPtr
=
=
aOther
.
mRawPtr
;
}
bool
operator
!
(
)
const
{
return
!
mRawPtr
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsMainThreadPtrHolder
<
T
>
)
private
:
T
*
mRawPtr
;
bool
mStrict
;
T
&
operator
=
(
nsMainThreadPtrHolder
&
aOther
)
;
nsMainThreadPtrHolder
(
const
nsMainThreadPtrHolder
&
aOther
)
;
}
;
template
<
class
T
>
class
nsMainThreadPtrHandle
{
RefPtr
<
nsMainThreadPtrHolder
<
T
>
>
mPtr
;
public
:
nsMainThreadPtrHandle
(
)
:
mPtr
(
nullptr
)
{
}
MOZ_IMPLICIT
nsMainThreadPtrHandle
(
decltype
(
nullptr
)
)
:
mPtr
(
nullptr
)
{
}
explicit
nsMainThreadPtrHandle
(
nsMainThreadPtrHolder
<
T
>
*
aHolder
)
:
mPtr
(
aHolder
)
{
}
explicit
nsMainThreadPtrHandle
(
already_AddRefed
<
nsMainThreadPtrHolder
<
T
>
>
aHolder
)
:
mPtr
(
aHolder
)
{
}
nsMainThreadPtrHandle
(
const
nsMainThreadPtrHandle
&
aOther
)
:
mPtr
(
aOther
.
mPtr
)
{
}
nsMainThreadPtrHandle
&
operator
=
(
const
nsMainThreadPtrHandle
&
aOther
)
{
mPtr
=
aOther
.
mPtr
;
return
*
this
;
}
nsMainThreadPtrHandle
&
operator
=
(
nsMainThreadPtrHolder
<
T
>
*
aHolder
)
{
mPtr
=
aHolder
;
return
*
this
;
}
T
*
get
(
)
{
if
(
mPtr
)
{
return
mPtr
.
get
(
)
-
>
get
(
)
;
}
return
nullptr
;
}
const
T
*
get
(
)
const
{
if
(
mPtr
)
{
return
mPtr
.
get
(
)
-
>
get
(
)
;
}
return
nullptr
;
}
operator
T
*
(
)
{
return
get
(
)
;
}
T
*
operator
-
>
(
)
MOZ_NO_ADDREF_RELEASE_ON_RETURN
{
return
get
(
)
;
}
bool
operator
=
=
(
const
nsMainThreadPtrHandle
<
T
>
&
aOther
)
const
{
if
(
!
mPtr
|
|
!
aOther
.
mPtr
)
{
return
mPtr
=
=
aOther
.
mPtr
;
}
return
*
mPtr
=
=
*
aOther
.
mPtr
;
}
bool
operator
!
=
(
const
nsMainThreadPtrHandle
<
T
>
&
aOther
)
const
{
return
!
operator
=
=
(
aOther
)
;
}
bool
operator
=
=
(
decltype
(
nullptr
)
)
const
{
return
mPtr
=
=
nullptr
;
}
bool
operator
!
=
(
decltype
(
nullptr
)
)
const
{
return
mPtr
!
=
nullptr
;
}
bool
operator
!
(
)
const
{
return
!
mPtr
|
|
!
*
mPtr
;
}
}
;
namespace
mozilla
{
template
<
typename
T
>
using
PtrHolder
=
nsMainThreadPtrHolder
<
T
>
;
template
<
typename
T
>
using
PtrHandle
=
nsMainThreadPtrHandle
<
T
>
;
}
#
endif
