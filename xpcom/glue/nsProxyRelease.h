#
ifndef
nsProxyRelease_h__
#
define
nsProxyRelease_h__
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
ifdef
XPCOM_GLUE_AVOID_NSPR
#
error
NS_ProxyRelease
implementation
depends
on
NSPR
.
#
endif
template
<
class
T
>
class
nsProxyReleaseEvent
:
public
nsRunnable
{
public
:
explicit
nsProxyReleaseEvent
(
already_AddRefed
<
T
>
aDoomed
)
:
mDoomed
(
aDoomed
.
take
(
)
)
{
}
NS_IMETHOD
Run
(
)
{
NS_IF_RELEASE
(
mDoomed
)
;
return
NS_OK
;
}
private
:
T
*
MOZ_OWNING_REF
mDoomed
;
}
;
template
<
class
T
>
inline
NS_HIDDEN_
(
void
)
NS_ProxyRelease
(
nsIEventTarget
*
aTarget
already_AddRefed
<
T
>
aDoomed
bool
aAlwaysProxy
=
false
)
{
RefPtr
<
T
>
doomed
=
aDoomed
;
nsresult
rv
;
if
(
!
doomed
|
|
!
aTarget
)
{
return
;
}
if
(
!
aAlwaysProxy
)
{
bool
onCurrentThread
=
false
;
rv
=
aTarget
-
>
IsOnCurrentThread
(
&
onCurrentThread
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
onCurrentThread
)
{
return
;
}
}
nsCOMPtr
<
nsIRunnable
>
ev
=
new
nsProxyReleaseEvent
<
T
>
(
doomed
.
forget
(
)
)
;
rv
=
aTarget
-
>
Dispatch
(
ev
NS_DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
post
proxy
release
event
leaking
!
"
)
;
}
}
template
<
class
T
>
inline
NS_HIDDEN_
(
void
)
NS_ReleaseOnMainThread
(
already_AddRefed
<
T
>
aDoomed
bool
aAlwaysProxy
=
false
)
{
nsCOMPtr
<
nsIThread
>
mainThread
;
if
(
!
NS_IsMainThread
(
)
|
|
aAlwaysProxy
)
{
nsresult
rv
=
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Could
not
get
main
thread
!
Leaking
.
"
)
;
return
;
}
}
NS_ProxyRelease
(
mainThread
mozilla
:
:
Move
(
aDoomed
)
aAlwaysProxy
)
;
}
template
<
class
T
>
class
nsMainThreadPtrHolder
final
{
public
:
explicit
nsMainThreadPtrHolder
(
T
*
aPtr
bool
aStrict
=
true
)
:
mRawPtr
(
nullptr
)
mStrict
(
aStrict
)
{
MOZ_ASSERT
(
!
mStrict
|
|
NS_IsMainThread
(
)
)
;
NS_IF_ADDREF
(
mRawPtr
=
aPtr
)
;
}
private
:
~
nsMainThreadPtrHolder
(
)
{
if
(
NS_IsMainThread
(
)
)
{
NS_IF_RELEASE
(
mRawPtr
)
;
}
else
if
(
mRawPtr
)
{
NS_ReleaseOnMainThread
(
dont_AddRef
(
mRawPtr
)
)
;
}
}
public
:
T
*
get
(
)
{
if
(
mStrict
&
&
MOZ_UNLIKELY
(
!
NS_IsMainThread
(
)
)
)
{
NS_ERROR
(
"
Can
'
t
dereference
nsMainThreadPtrHolder
off
main
thread
"
)
;
MOZ_CRASH
(
)
;
}
return
mRawPtr
;
}
bool
operator
=
=
(
const
nsMainThreadPtrHolder
<
T
>
&
aOther
)
const
{
return
mRawPtr
=
=
aOther
.
mRawPtr
;
}
bool
operator
!
(
)
const
{
return
!
mRawPtr
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsMainThreadPtrHolder
<
T
>
)
private
:
T
*
mRawPtr
;
bool
mStrict
;
T
&
operator
=
(
nsMainThreadPtrHolder
&
aOther
)
;
nsMainThreadPtrHolder
(
const
nsMainThreadPtrHolder
&
aOther
)
;
}
;
template
<
class
T
>
class
nsMainThreadPtrHandle
{
RefPtr
<
nsMainThreadPtrHolder
<
T
>
>
mPtr
;
public
:
nsMainThreadPtrHandle
(
)
:
mPtr
(
nullptr
)
{
}
explicit
nsMainThreadPtrHandle
(
nsMainThreadPtrHolder
<
T
>
*
aHolder
)
:
mPtr
(
aHolder
)
{
}
nsMainThreadPtrHandle
(
const
nsMainThreadPtrHandle
&
aOther
)
:
mPtr
(
aOther
.
mPtr
)
{
}
nsMainThreadPtrHandle
&
operator
=
(
const
nsMainThreadPtrHandle
&
aOther
)
{
mPtr
=
aOther
.
mPtr
;
return
*
this
;
}
nsMainThreadPtrHandle
&
operator
=
(
nsMainThreadPtrHolder
<
T
>
*
aHolder
)
{
mPtr
=
aHolder
;
return
*
this
;
}
T
*
get
(
)
{
if
(
mPtr
)
{
return
mPtr
.
get
(
)
-
>
get
(
)
;
}
return
nullptr
;
}
const
T
*
get
(
)
const
{
if
(
mPtr
)
{
return
mPtr
.
get
(
)
-
>
get
(
)
;
}
return
nullptr
;
}
operator
T
*
(
)
{
return
get
(
)
;
}
T
*
operator
-
>
(
)
MOZ_NO_ADDREF_RELEASE_ON_RETURN
{
return
get
(
)
;
}
bool
operator
=
=
(
const
nsMainThreadPtrHandle
<
T
>
&
aOther
)
const
{
if
(
!
mPtr
|
|
!
aOther
.
mPtr
)
{
return
mPtr
=
=
aOther
.
mPtr
;
}
return
*
mPtr
=
=
*
aOther
.
mPtr
;
}
bool
operator
!
(
)
const
{
return
!
mPtr
|
|
!
*
mPtr
;
}
}
;
#
endif
