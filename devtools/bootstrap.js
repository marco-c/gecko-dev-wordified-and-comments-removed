"
use
strict
"
;
const
Cu
=
Components
.
utils
;
const
Ci
=
Components
.
interfaces
;
const
{
Services
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
;
const
{
NetUtil
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
{
}
)
;
const
{
AppConstants
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
{
}
)
;
let
listener
;
let
resourceURI
;
function
actionOccurred
(
id
)
{
let
{
require
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
let
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
let
telemetry
=
new
Telemetry
(
)
;
telemetry
.
actionOccurred
(
id
)
;
}
function
readURI
(
uri
)
{
let
stream
=
NetUtil
.
newChannel
(
{
uri
:
NetUtil
.
newURI
(
uri
"
UTF
-
8
"
)
loadUsingSystemPrincipal
:
true
}
)
.
open2
(
)
;
let
count
=
stream
.
available
(
)
;
let
data
=
NetUtil
.
readInputStreamToString
(
stream
count
{
charset
:
"
UTF
-
8
"
}
)
;
stream
.
close
(
)
;
return
data
;
}
function
interpretPreprocessingInstructions
(
content
)
{
const
ifMap
=
{
"
#
if
MOZ_UPDATE_CHANNEL
=
=
beta
"
:
AppConstants
.
MOZ_UPDATE_CHANNEL
=
=
=
"
beta
"
"
#
if
defined
(
NIGHTLY_BUILD
)
"
:
AppConstants
.
NIGHTLY_BUILD
"
#
ifdef
MOZ_DEV_EDITION
"
:
AppConstants
.
MOZ_DEV_EDITION
"
#
ifdef
RELEASE_OR_BETA
"
:
AppConstants
.
RELEASE_OR_BETA
}
;
let
lines
=
content
.
split
(
"
\
n
"
)
;
let
ignoring
=
false
;
let
newLines
=
[
]
;
let
continuation
=
false
;
for
(
let
line
of
lines
)
{
if
(
line
.
startsWith
(
"
#
if
"
)
)
{
if
(
!
(
line
in
ifMap
)
)
{
throw
new
Error
(
"
missing
line
in
ifMap
:
"
+
line
)
;
}
ignoring
=
!
ifMap
[
line
]
;
}
else
if
(
line
.
startsWith
(
"
#
else
"
)
)
{
ignoring
=
!
ignoring
;
}
else
if
(
line
.
startsWith
(
"
#
endif
"
)
)
{
ignoring
=
false
;
}
let
isPrefLine
=
/
^
*
(
sticky_
)
?
pref
\
(
"
(
[
^
"
]
+
)
"
/
.
test
(
line
)
;
if
(
continuation
|
|
(
!
ignoring
&
&
isPrefLine
)
)
{
newLines
.
push
(
line
)
;
continuation
=
!
/
\
)
;
/
.
test
(
line
)
;
}
}
return
newLines
.
join
(
"
\
n
"
)
;
}
function
processPrefFile
(
url
)
{
let
content
=
readURI
(
url
)
;
content
=
interpretPreprocessingInstructions
(
content
)
;
content
.
match
(
/
pref
\
(
"
[
^
"
]
+
"
\
s
*
.
+
\
s
*
\
)
/
g
)
.
forEach
(
item
=
>
{
let
m
=
item
.
match
(
/
pref
\
(
"
(
[
^
"
]
+
)
"
\
s
*
(
.
+
)
\
s
*
\
)
/
)
;
let
name
=
m
[
1
]
;
let
val
=
m
[
2
]
.
trim
(
)
;
if
(
Services
.
prefs
.
prefHasUserValue
(
name
)
)
{
return
;
}
let
defaultBranch
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
if
(
(
val
.
startsWith
(
"
\
"
"
)
&
&
val
.
endsWith
(
"
\
"
"
)
)
|
|
(
val
.
startsWith
(
"
'
"
)
&
&
val
.
endsWith
(
"
'
"
)
)
)
{
val
=
val
.
substr
(
1
val
.
length
-
2
)
;
val
=
val
.
replace
(
/
\
\
"
/
g
'
"
'
)
;
defaultBranch
.
setCharPref
(
name
val
)
;
}
else
if
(
val
.
match
(
/
[
0
-
9
]
+
/
)
)
{
defaultBranch
.
setIntPref
(
name
parseInt
(
val
10
)
)
;
}
else
if
(
val
=
=
"
true
"
|
|
val
=
=
"
false
"
)
{
defaultBranch
.
setBoolPref
(
name
val
=
=
"
true
"
)
;
}
else
{
console
.
log
(
"
Unable
to
match
preference
type
for
value
:
"
val
)
;
}
}
)
;
}
function
setPrefs
(
)
{
processPrefFile
(
resourceURI
.
spec
+
"
.
/
client
/
preferences
/
devtools
.
js
"
)
;
processPrefFile
(
resourceURI
.
spec
+
"
.
/
client
/
preferences
/
debugger
.
js
"
)
;
processPrefFile
(
resourceURI
.
spec
+
"
.
/
client
/
webide
/
webide
-
prefs
.
js
"
)
;
}
function
MultiWindowKeyListener
(
{
keyCode
ctrlKey
altKey
callback
}
)
{
let
keyListener
=
function
(
event
)
{
if
(
event
.
ctrlKey
=
=
!
!
ctrlKey
&
&
event
.
altKey
=
=
!
!
altKey
&
&
event
.
keyCode
=
=
=
keyCode
)
{
callback
(
event
)
;
event
.
preventDefault
(
)
;
}
}
;
let
observer
=
function
(
window
topic
data
)
{
if
(
topic
=
=
=
"
domwindowopened
"
)
{
window
.
addEventListener
(
"
keyup
"
keyListener
)
;
}
else
{
window
.
removeEventListener
(
"
keyup
"
keyListener
)
;
}
}
;
return
{
start
:
function
(
)
{
let
e
=
Services
.
ww
.
getWindowEnumerator
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
let
window
=
e
.
getNext
(
)
;
observer
(
window
"
domwindowopened
"
null
)
;
}
Services
.
ww
.
registerNotification
(
observer
)
;
}
stop
:
function
(
)
{
Services
.
ww
.
unregisterNotification
(
observer
)
;
let
e
=
Services
.
ww
.
getWindowEnumerator
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
let
window
=
e
.
getNext
(
)
;
observer
(
window
"
domwindowclosed
"
null
)
;
}
}
}
;
}
let
getTopLevelWindow
=
function
(
window
)
{
return
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
;
function
unload
(
reason
)
{
Services
.
ppmm
.
loadProcessScript
(
"
data
:
(
"
+
function
(
scriptReason
)
{
let
obs
=
Components
.
classes
[
"
mozilla
.
org
/
observer
-
service
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsIObserverService
)
;
obs
.
notifyObservers
(
null
"
message
-
manager
-
flush
-
caches
"
)
;
if
(
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
)
{
Services
.
obs
.
notifyObservers
(
null
"
devtools
-
unload
"
scriptReason
)
;
}
}
+
"
)
(
\
"
"
+
reason
.
replace
(
/
"
/
g
'
\
\
"
'
)
+
"
\
"
)
"
false
)
;
Services
.
obs
.
notifyObservers
(
null
"
devtools
-
unload
"
reason
)
;
Cu
.
unload
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
Cu
.
unload
(
"
resource
:
/
/
devtools
/
client
/
shared
/
browser
-
loader
.
js
"
)
;
Cu
.
unload
(
"
resource
:
/
/
devtools
/
client
/
framework
/
ToolboxProcess
.
jsm
"
)
;
Cu
.
unload
(
"
resource
:
/
/
devtools
/
shared
/
apps
/
Devices
.
jsm
"
)
;
Cu
.
unload
(
"
resource
:
/
/
devtools
/
client
/
scratchpad
/
scratchpad
-
manager
.
jsm
"
)
;
Cu
.
unload
(
"
resource
:
/
/
devtools
/
shared
/
Parser
.
jsm
"
)
;
Cu
.
unload
(
"
resource
:
/
/
devtools
/
client
/
shared
/
DOMHelpers
.
jsm
"
)
;
Cu
.
unload
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesView
.
jsm
"
)
;
Cu
.
unload
(
"
resource
:
/
/
devtools
/
client
/
responsivedesign
/
responsivedesign
.
jsm
"
)
;
Cu
.
unload
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
AbstractTreeItem
.
jsm
"
)
;
Cu
.
unload
(
"
resource
:
/
/
devtools
/
shared
/
deprecated
-
sync
-
thenables
.
js
"
)
;
}
function
reload
(
event
)
{
let
reloadToolbox
=
false
;
if
(
event
)
{
let
top
=
getTopLevelWindow
(
event
.
view
)
;
let
isBrowser
=
top
.
location
.
href
.
includes
(
"
/
browser
.
xul
"
)
;
if
(
isBrowser
&
&
top
.
gBrowser
)
{
let
nbox
=
top
.
gBrowser
.
getNotificationBox
(
)
;
reloadToolbox
=
top
.
document
.
getAnonymousElementByAttribute
(
nbox
"
class
"
"
devtools
-
toolbox
-
bottom
-
iframe
"
)
|
|
top
.
document
.
getAnonymousElementByAttribute
(
nbox
"
class
"
"
devtools
-
toolbox
-
side
-
iframe
"
)
|
|
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
toolbox
"
)
;
}
}
let
browserConsole
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webconsole
"
)
;
let
reopenBrowserConsole
=
false
;
if
(
browserConsole
)
{
browserConsole
.
close
(
)
;
reopenBrowserConsole
=
true
;
}
dump
(
"
Reload
DevTools
.
(
reload
-
toolbox
:
"
+
reloadToolbox
+
"
)
\
n
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
startupcache
-
invalidate
"
)
;
unload
(
"
reload
"
)
;
setPrefs
(
)
;
const
{
devtools
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
devtools
.
require
(
"
devtools
/
client
/
framework
/
devtools
-
browser
"
)
;
let
windowsEnum
=
Services
.
wm
.
getEnumerator
(
null
)
;
while
(
windowsEnum
.
hasMoreElements
(
)
)
{
let
window
=
windowsEnum
.
getNext
(
)
;
let
windowtype
=
window
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
if
(
windowtype
=
=
"
navigator
:
browser
"
&
&
window
.
gBrowser
)
{
for
(
let
tab
of
window
.
gBrowser
.
tabs
)
{
let
browser
=
tab
.
linkedBrowser
;
let
location
=
browser
.
documentURI
.
spec
;
let
mm
=
browser
.
messageManager
;
if
(
location
.
startsWith
(
"
about
:
debugging
"
)
|
|
location
.
startsWith
(
"
chrome
:
/
/
devtools
/
"
)
)
{
browser
.
reload
(
)
;
}
mm
.
loadFrameScript
(
"
data
:
text
/
javascript
new
"
+
function
(
)
{
let
isJSONView
=
content
.
document
.
baseURI
.
startsWith
(
"
resource
:
/
/
devtools
/
"
)
;
if
(
isJSONView
)
{
content
.
location
.
reload
(
)
;
}
}
false
)
;
}
}
else
if
(
windowtype
=
=
=
"
devtools
:
webide
"
)
{
window
.
location
.
reload
(
)
;
}
}
if
(
reloadToolbox
)
{
let
{
setTimeout
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
{
}
)
;
setTimeout
(
(
)
=
>
{
let
{
TargetFactory
}
=
devtools
.
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
let
{
gDevTools
}
=
devtools
.
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
let
top
=
getTopLevelWindow
(
event
.
view
)
;
let
target
=
TargetFactory
.
forTab
(
top
.
gBrowser
.
selectedTab
)
;
gDevTools
.
showToolbox
(
target
)
;
}
1000
)
;
}
if
(
reopenBrowserConsole
)
{
let
{
HUDService
}
=
devtools
.
require
(
"
devtools
/
client
/
webconsole
/
hudservice
"
)
;
HUDService
.
toggleBrowserConsole
(
)
;
}
actionOccurred
(
"
reloadAddonReload
"
)
;
}
function
startup
(
data
)
{
dump
(
"
DevTools
addon
started
.
\
n
"
)
;
resourceURI
=
data
.
resourceURI
;
listener
=
new
MultiWindowKeyListener
(
{
keyCode
:
Ci
.
nsIDOMKeyEvent
.
DOM_VK_R
ctrlKey
:
true
altKey
:
true
callback
:
reload
}
)
;
listener
.
start
(
)
;
reload
(
)
;
}
function
shutdown
(
data
reason
)
{
if
(
reason
=
=
APP_SHUTDOWN
)
{
return
;
}
listener
.
stop
(
)
;
listener
=
null
;
unload
(
"
disable
"
)
;
}
function
install
(
)
{
try
{
actionOccurred
(
"
reloadAddonInstalled
"
)
;
}
catch
(
e
)
{
}
}
function
uninstall
(
)
{
}
