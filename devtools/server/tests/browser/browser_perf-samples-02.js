const
WAIT_TIME
=
1000
;
const
{
PerformanceFront
}
=
require
(
"
devtools
/
server
/
actors
/
performance
"
)
;
add_task
(
function
*
(
)
{
let
browser
=
yield
addTab
(
MAIN_DOMAIN
+
"
doc_perf
.
html
"
)
;
let
doc
=
browser
.
contentDocument
;
initDebuggerServer
(
)
;
let
client
=
new
DebuggerClient
(
DebuggerServer
.
connectPipe
(
)
)
;
let
form
=
yield
connectDebuggerClient
(
client
)
;
let
front
=
PerformanceFront
(
client
form
)
;
yield
front
.
connect
(
)
;
let
rec
=
yield
front
.
startRecording
(
)
;
busyWait
(
WAIT_TIME
)
;
yield
front
.
stopRecording
(
rec
)
;
let
profile
=
rec
.
getProfile
(
)
;
let
sampleCount
=
0
;
for
(
let
thread
of
profile
.
threads
)
{
info
(
"
Checking
thread
:
"
+
thread
.
name
)
;
for
(
let
sample
of
thread
.
samples
.
data
)
{
sampleCount
+
+
;
let
stack
=
getInflatedStackLocations
(
thread
sample
)
;
if
(
stack
[
0
]
!
=
"
(
root
)
"
)
{
ok
(
false
"
The
sample
"
+
stack
.
toSource
(
)
+
"
doesn
'
t
have
a
root
node
.
"
)
;
}
}
}
ok
(
sampleCount
>
0
"
At
least
some
samples
have
been
iterated
over
checking
for
root
nodes
.
"
)
;
yield
front
.
destroy
(
)
;
yield
closeDebuggerClient
(
client
)
;
gBrowser
.
removeCurrentTab
(
)
;
}
)
;
function
getInflatedStackLocations
(
thread
sample
)
{
let
stackTable
=
thread
.
stackTable
;
let
frameTable
=
thread
.
frameTable
;
let
stringTable
=
thread
.
stringTable
;
let
SAMPLE_STACK_SLOT
=
thread
.
samples
.
schema
.
stack
;
let
STACK_PREFIX_SLOT
=
stackTable
.
schema
.
prefix
;
let
STACK_FRAME_SLOT
=
stackTable
.
schema
.
frame
;
let
FRAME_LOCATION_SLOT
=
frameTable
.
schema
.
location
;
let
stackIndex
=
sample
[
SAMPLE_STACK_SLOT
]
;
let
locations
=
[
]
;
while
(
stackIndex
!
=
=
null
)
{
let
stackEntry
=
stackTable
.
data
[
stackIndex
]
;
let
frame
=
frameTable
.
data
[
stackEntry
[
STACK_FRAME_SLOT
]
]
;
locations
.
push
(
stringTable
[
frame
[
FRAME_LOCATION_SLOT
]
]
)
;
stackIndex
=
stackEntry
[
STACK_PREFIX_SLOT
]
;
}
return
locations
.
reverse
(
)
;
}
