"
use
strict
"
;
add_task
(
async
function
(
)
{
let
{
client
walker
animations
}
=
await
initAnimationsFrontForUrl
(
MAIN_DOMAIN
+
"
animation
.
html
"
)
;
await
playStateIsUpdatedDynamically
(
walker
animations
)
;
await
client
.
close
(
)
;
gBrowser
.
removeCurrentTab
(
)
;
}
)
;
async
function
playStateIsUpdatedDynamically
(
walker
animations
)
{
info
(
"
Getting
the
test
node
(
which
runs
a
very
long
animation
)
"
)
;
let
node
=
await
walker
.
querySelector
(
walker
.
rootNode
"
.
long
-
animation
"
)
;
info
(
"
Getting
the
animation
player
front
for
this
node
"
)
;
let
[
player
]
=
await
animations
.
getAnimationPlayersForNode
(
node
)
;
await
player
.
ready
(
)
;
let
state
=
await
player
.
getCurrentState
(
)
;
is
(
state
.
playState
"
running
"
"
The
playState
is
running
while
the
animation
is
running
"
)
;
info
(
"
Change
the
animation
'
s
currentTime
to
be
near
the
end
and
wait
for
"
+
"
it
to
finish
"
)
;
let
onFinished
=
waitForAnimationPlayState
(
player
"
finished
"
)
;
await
player
.
setCurrentTime
(
98
*
1000
)
;
state
=
await
onFinished
;
is
(
state
.
playState
"
finished
"
"
The
animation
has
ended
and
the
state
has
been
updated
"
)
;
ok
(
state
.
currentTime
>
player
.
initialState
.
currentTime
"
The
currentTime
has
been
updated
"
)
;
}
async
function
waitForAnimationPlayState
(
player
playState
)
{
let
state
=
{
}
;
while
(
state
.
playState
!
=
=
playState
)
{
state
=
await
player
.
getCurrentState
(
)
;
await
wait
(
500
)
;
}
return
state
;
}
function
wait
(
ms
)
{
return
new
Promise
(
r
=
>
setTimeout
(
r
ms
)
)
;
}
