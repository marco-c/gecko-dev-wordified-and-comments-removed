var
Cc
=
Components
.
classes
;
var
Ci
=
Components
.
interfaces
;
var
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
console
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
const
{
require
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
const
{
DebuggerClient
}
=
require
(
"
devtools
/
shared
/
client
/
main
"
)
;
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
const
{
defer
}
=
require
(
"
promise
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
PATH
=
"
browser
/
devtools
/
server
/
tests
/
browser
/
"
;
const
MAIN_DOMAIN
=
"
http
:
/
/
test1
.
example
.
org
/
"
+
PATH
;
const
ALT_DOMAIN
=
"
http
:
/
/
sectest1
.
example
.
org
/
"
+
PATH
;
const
ALT_DOMAIN_SECURED
=
"
https
:
/
/
sectest1
.
example
.
org
:
443
/
"
+
PATH
;
waitForExplicitFinish
(
)
;
var
addTab
=
Task
.
async
(
function
*
(
url
)
{
info
(
"
Adding
a
new
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
let
tab
=
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
)
;
let
loaded
=
once
(
gBrowser
.
selectedBrowser
"
load
"
true
)
;
content
.
location
=
url
;
yield
loaded
;
info
(
"
URL
'
"
+
url
+
"
'
loading
complete
"
)
;
yield
new
Promise
(
resolve
=
>
{
let
isBlank
=
url
=
=
"
about
:
blank
"
;
waitForFocus
(
resolve
content
isBlank
)
;
}
)
;
return
tab
.
linkedBrowser
;
}
)
;
function
*
initAnimationsFrontForUrl
(
url
)
{
const
{
AnimationsFront
}
=
require
(
"
devtools
/
server
/
actors
/
animation
"
)
;
const
{
InspectorFront
}
=
require
(
"
devtools
/
server
/
actors
/
inspector
"
)
;
yield
addTab
(
url
)
;
initDebuggerServer
(
)
;
let
client
=
new
DebuggerClient
(
DebuggerServer
.
connectPipe
(
)
)
;
let
form
=
yield
connectDebuggerClient
(
client
)
;
let
inspector
=
InspectorFront
(
client
form
)
;
let
walker
=
yield
inspector
.
getWalker
(
)
;
let
animations
=
AnimationsFront
(
client
form
)
;
return
{
inspector
walker
animations
client
}
;
}
function
initDebuggerServer
(
)
{
try
{
DebuggerServer
.
destroy
(
)
;
}
catch
(
ex
)
{
}
DebuggerServer
.
init
(
)
;
DebuggerServer
.
addBrowserActors
(
)
;
}
function
connectDebuggerClient
(
client
)
{
return
new
Promise
(
resolve
=
>
{
client
.
connect
(
(
)
=
>
{
client
.
listTabs
(
tabs
=
>
{
resolve
(
tabs
.
tabs
[
tabs
.
selected
]
)
;
}
)
;
}
)
;
}
)
;
}
function
closeDebuggerClient
(
client
)
{
return
new
Promise
(
resolve
=
>
client
.
close
(
resolve
)
)
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
return
new
Promise
(
resolve
=
>
{
for
(
let
[
add
remove
]
of
[
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
on
"
"
off
"
]
]
)
{
if
(
(
add
in
target
)
&
&
(
remove
in
target
)
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
aArgs
)
{
info
(
"
Got
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
resolve
(
.
.
.
aArgs
)
;
}
useCapture
)
;
break
;
}
}
}
)
;
}
function
forceCollections
(
)
{
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
Cu
.
forceShrinkingGC
(
)
;
}
function
getMockTabActor
(
win
)
{
return
{
window
:
win
isRootActor
:
true
}
;
}
registerCleanupFunction
(
function
tearDown
(
)
{
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
)
;
function
idleWait
(
time
)
{
return
DevToolsUtils
.
waitForTime
(
time
)
;
}
function
busyWait
(
time
)
{
let
start
=
Date
.
now
(
)
;
let
stack
;
while
(
Date
.
now
(
)
-
start
<
time
)
{
stack
=
Components
.
stack
;
}
}
function
waitUntil
(
predicate
interval
=
10
)
{
if
(
predicate
(
)
)
{
return
Promise
.
resolve
(
true
)
;
}
return
new
Promise
(
resolve
=
>
{
setTimeout
(
function
(
)
{
waitUntil
(
predicate
)
.
then
(
(
)
=
>
resolve
(
true
)
)
;
}
interval
)
;
}
)
;
}
function
waitForMarkerType
(
front
types
predicate
unpackFun
=
(
name
data
)
=
>
data
.
markers
eventName
=
"
timeline
-
data
"
)
{
types
=
[
]
.
concat
(
types
)
;
predicate
=
predicate
|
|
function
(
)
{
return
true
;
}
;
let
filteredMarkers
=
[
]
;
let
{
promise
resolve
}
=
defer
(
)
;
info
(
"
Waiting
for
markers
of
type
:
"
+
types
)
;
function
handler
(
name
data
)
{
if
(
typeof
name
=
=
=
"
string
"
&
&
name
!
=
=
"
markers
"
)
{
return
;
}
let
markers
=
unpackFun
(
name
data
)
;
info
(
"
Got
markers
:
"
+
JSON
.
stringify
(
markers
null
2
)
)
;
filteredMarkers
=
filteredMarkers
.
concat
(
markers
.
filter
(
m
=
>
types
.
indexOf
(
m
.
name
)
!
=
=
-
1
)
)
;
if
(
types
.
every
(
t
=
>
filteredMarkers
.
some
(
m
=
>
m
.
name
=
=
=
t
)
)
&
&
predicate
(
filteredMarkers
)
)
{
front
.
off
(
eventName
handler
)
;
resolve
(
filteredMarkers
)
;
}
}
front
.
on
(
eventName
handler
)
;
return
promise
;
}
