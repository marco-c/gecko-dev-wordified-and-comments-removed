"
use
strict
"
;
add_task
(
async
function
(
)
{
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
MAIN_DOMAIN
+
"
doc_accessibility_infobar
.
html
"
}
async
function
(
browser
)
{
await
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
jsm
"
)
;
const
{
HighlighterEnvironment
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
highlighters
.
js
"
)
;
const
{
AccessibleHighlighter
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
highlighters
/
accessible
.
js
"
)
;
function
isContainerHidden
(
infobar
)
{
return
!
!
infobar
.
getElement
(
"
infobar
-
container
"
)
.
getAttribute
(
"
hidden
"
)
;
}
function
getName
(
infobar
)
{
return
infobar
.
getTextContent
(
"
infobar
-
name
"
)
;
}
function
getRole
(
infobar
)
{
return
infobar
.
getTextContent
(
"
infobar
-
role
"
)
;
}
function
checkInfobar
(
infobar
{
shouldBeHidden
role
name
}
)
{
is
(
isContainerHidden
(
infobar
)
shouldBeHidden
"
Infobar
'
s
hidden
state
is
correct
.
"
)
;
if
(
shouldBeHidden
)
{
return
;
}
is
(
getRole
(
infobar
)
role
"
infobarRole
text
content
is
correct
"
)
;
is
(
getName
(
infobar
)
"
{
name
}
"
"
infoBarName
text
content
is
correct
"
)
;
}
function
testInfobar
(
node
highlighter
)
{
const
infobar
=
highlighter
.
accessibleInfobar
;
const
bounds
=
{
x
:
0
y
:
0
w
:
250
h
:
100
}
;
info
(
"
Check
that
infobar
is
shown
with
valid
bounds
.
"
)
;
highlighter
.
show
(
node
{
.
.
.
bounds
role
:
"
button
"
name
:
"
Accessible
Button
"
}
)
;
checkInfobar
(
infobar
{
role
:
"
button
"
name
:
"
Accessible
Button
"
shouldBeHidden
:
false
}
)
;
highlighter
.
hide
(
)
;
info
(
"
Check
that
infobar
is
hidden
after
.
hide
(
)
is
called
.
"
)
;
checkInfobar
(
infobar
{
shouldBeHidden
:
true
}
)
;
info
(
"
Check
to
make
sure
content
is
updated
with
new
options
.
"
)
;
highlighter
.
show
(
node
{
.
.
.
bounds
name
:
"
Test
link
"
role
:
"
link
"
}
)
;
checkInfobar
(
infobar
{
name
:
"
Test
link
"
role
:
"
link
"
shouldBeHidden
:
false
}
)
;
highlighter
.
hide
(
)
;
}
const
env
=
new
HighlighterEnvironment
(
)
;
env
.
initFromWindow
(
content
.
window
)
;
await
new
Promise
(
resolve
=
>
{
const
doc
=
env
.
document
;
function
onContentLoaded
(
)
{
if
(
doc
.
readyState
=
=
=
"
interactive
"
|
|
doc
.
readyState
=
=
=
"
complete
"
)
{
resolve
(
)
;
}
else
{
doc
.
addEventListener
(
"
DOMContentLoaded
"
onContentLoaded
{
once
:
true
}
)
;
}
}
onContentLoaded
(
)
;
}
)
;
const
node
=
content
.
document
.
createElement
(
"
div
"
)
;
content
.
document
.
body
.
append
(
node
)
;
info
(
"
Checks
for
Infobar
'
s
show
method
"
)
;
const
highlighter
=
new
AccessibleHighlighter
(
env
)
;
await
highlighter
.
isReady
;
testInfobar
(
node
highlighter
)
;
}
)
;
}
)
;
}
)
;
