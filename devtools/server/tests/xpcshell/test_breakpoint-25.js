"
use
strict
"
;
add_task
(
threadFrontTest
(
(
{
threadFront
debuggee
targetFront
}
)
=
>
{
return
new
Promise
(
resolve
=
>
{
(
async
(
)
=
>
{
await
executeOnNextTickAndWaitForPause
(
evalCode
threadFront
)
;
ok
(
true
"
The
page
is
paused
"
)
;
ok
(
!
debuggee
.
foo
"
foo
is
still
false
after
we
hit
the
breakpoint
"
)
;
await
targetFront
.
detach
(
)
;
ok
(
debuggee
.
foo
"
foo
is
true
after
target
'
s
detach
request
"
)
;
resolve
(
)
;
}
)
(
)
;
function
evalCode
(
)
{
Cu
.
evalInSandbox
(
"
var
foo
=
false
;
\
n
"
debuggee
)
;
ok
(
!
debuggee
.
foo
"
foo
is
false
at
startup
"
)
;
Cu
.
evalInSandbox
(
"
debugger
;
\
n
"
+
"
foo
=
true
;
\
n
"
debuggee
)
;
}
}
)
;
}
)
)
;
add_task
(
threadFrontTest
(
(
{
threadFront
client
debuggee
}
)
=
>
{
return
new
Promise
(
resolve
=
>
{
(
async
(
)
=
>
{
await
executeOnNextTickAndWaitForPause
(
evalCode
threadFront
)
;
ok
(
true
"
The
page
is
paused
"
)
;
ok
(
!
debuggee
.
foo
"
foo
is
still
false
after
we
hit
the
breakpoint
"
)
;
await
client
.
close
(
)
;
await
new
Promise
(
executeSoon
)
;
ok
(
debuggee
.
foo
"
foo
is
true
after
client
close
"
)
;
executeSoon
(
resolve
)
;
dump
(
"
resolved
\
n
"
)
;
}
)
(
)
;
function
evalCode
(
)
{
Cu
.
evalInSandbox
(
"
var
foo
=
false
;
\
n
"
debuggee
)
;
ok
(
!
debuggee
.
foo
"
foo
is
false
at
startup
"
)
;
Cu
.
evalInSandbox
(
"
debugger
;
\
n
"
+
"
foo
=
true
;
\
n
"
debuggee
)
;
}
}
)
;
}
)
)
;
