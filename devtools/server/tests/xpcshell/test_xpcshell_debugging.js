"
use
strict
"
;
_profileInitialized
=
true
;
add_task
(
async
function
(
)
{
const
testFile
=
do_get_file
(
"
xpcshell_debugging_script
.
js
"
)
;
let
testInitialized
=
false
;
const
{
DevToolsServer
}
=
_setupDevToolsServer
(
[
testFile
.
path
]
(
)
=
>
{
testInitialized
=
true
;
}
)
;
const
transport
=
DevToolsServer
.
connectPipe
(
)
;
const
client
=
new
DevToolsClient
(
transport
)
;
await
client
.
connect
(
)
;
const
deviceFront
=
await
client
.
mainRoot
.
getFront
(
"
device
"
)
;
const
desc
=
await
deviceFront
.
getDescription
(
)
;
equal
(
desc
.
geckobuildid
Services
.
appinfo
.
platformBuildID
"
device
actor
works
"
)
;
const
commands
=
await
CommandsFactory
.
forMainProcess
(
{
client
}
)
;
await
commands
.
targetCommand
.
startListening
(
)
;
await
commands
.
threadConfigurationCommand
.
updateConfiguration
(
{
skipBreakpoints
:
false
}
)
;
const
threadFront
=
await
commands
.
targetCommand
.
targetFront
.
getFront
(
"
thread
"
)
;
ok
(
testInitialized
)
;
const
onPause
=
waitForPause
(
threadFront
)
;
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
load
(
testFile
.
path
)
;
}
)
;
info
(
"
Wait
for
first
paused
event
"
)
;
const
packet1
=
await
onPause
;
equal
(
packet1
.
why
.
type
"
breakpoint
"
"
yay
-
hit
the
breakpoint
at
the
first
line
in
our
script
"
)
;
info
(
"
Wait
for
second
pause
event
"
)
;
const
packet2
=
await
resumeAndWaitForPause
(
threadFront
)
;
equal
(
packet2
.
why
.
type
"
debuggerStatement
"
"
yay
-
hit
the
'
debugger
'
statement
in
our
script
"
)
;
info
(
"
Dynamically
add
a
breakpoint
after
the
debugger
statement
"
)
;
const
breakpointsFront
=
await
commands
.
watcherFront
.
getBreakpointListActor
(
)
;
await
breakpointsFront
.
setBreakpoint
(
{
sourceUrl
:
testFile
.
path
line
:
11
column
:
0
}
{
}
)
;
info
(
"
Wait
for
third
pause
event
"
)
;
const
packet3
=
await
resumeAndWaitForPause
(
threadFront
)
;
equal
(
packet3
.
why
.
type
"
breakpoint
"
"
yay
-
hit
the
breakpoint
added
after
starting
the
test
"
)
;
finishClient
(
client
)
;
}
)
;
