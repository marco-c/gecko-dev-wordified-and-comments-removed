"
use
strict
"
;
Services
.
prefs
.
setBoolPref
(
"
security
.
allow_eval_with_system_principal
"
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
security
.
allow_eval_with_system_principal
"
)
;
}
)
;
const
defaults
=
{
class
:
"
Restricted
"
string
:
"
"
isFunction
:
false
hasPreview
:
true
code
:
"
var
obj
=
{
}
"
protoType
:
"
null
"
hasOwnPropertyNames
:
false
hasOwnPropertySymbols
:
false
property
:
undefined
afterTest
:
"
true
=
=
true
"
}
;
const
systemPrincipalTests
=
[
{
class
:
"
DeadObject
"
string
:
"
<
dead
object
>
"
code
:
var
obj
=
Cu
.
Sandbox
(
null
)
;
Cu
.
nukeSandbox
(
obj
)
;
property
:
descriptor
(
{
value
:
"
TypeError
"
}
)
}
{
class
:
"
Proxy
"
string
:
"
<
proxy
>
"
code
:
var
trapDidRun
=
false
;
var
obj
=
new
Proxy
(
{
}
new
Proxy
(
{
}
{
get
:
(
_
trap
)
=
>
{
trapDidRun
=
true
;
throw
new
Error
(
"
proxy
trap
'
"
+
trap
+
"
'
was
called
.
"
)
;
}
}
)
)
;
afterTest
:
"
trapDidRun
=
=
=
false
"
}
{
class
:
"
Proxy
"
string
:
"
<
proxy
>
"
isFunction
:
true
code
:
var
trapDidRun
=
false
;
var
obj
=
new
Proxy
(
function
(
)
{
}
new
Proxy
(
{
}
{
get
:
(
_
trap
)
=
>
{
trapDidRun
=
true
;
throw
new
Error
(
"
proxy
trap
'
"
+
trap
+
"
'
was
called
.
(
function
)
"
)
;
}
}
)
)
;
afterTest
:
"
trapDidRun
=
=
=
false
"
}
{
class
:
"
InvisibleToDebugger
:
Array
"
string
:
"
<
invisibleToDebugger
>
"
hasPreview
:
false
code
:
var
s
=
Cu
.
Sandbox
(
systemPrincipal
{
invisibleToDebugger
:
true
}
)
;
var
obj
=
s
.
eval
(
"
[
1
2
3
]
"
)
;
}
{
class
:
"
InvisibleToDebugger
:
Function
"
string
:
"
<
invisibleToDebugger
>
"
isFunction
:
true
hasPreview
:
false
code
:
var
s
=
Cu
.
Sandbox
(
systemPrincipal
{
invisibleToDebugger
:
true
}
)
;
var
obj
=
s
.
eval
(
"
(
function
func
(
arg
)
{
}
)
"
)
;
}
{
class
:
"
nsXPCComponents_utils_Sandbox
"
string
:
"
[
object
nsXPCComponents_utils_Sandbox
]
"
code
:
var
obj
=
Cu
.
Sandbox
;
protoType
:
"
object
"
}
]
;
const
nullPrincipalTests
=
[
{
string
:
"
[
object
Object
]
"
code
:
var
obj
=
{
x
:
-
1
}
;
}
{
string
:
"
[
object
Object
]
"
code
:
var
obj
=
[
1
2
3
]
;
property
:
descriptor
(
{
value
:
"
Error
"
}
)
}
{
string
:
"
function
func
(
arg
)
{
}
"
isFunction
:
true
hasPreview
:
false
code
:
var
obj
=
function
func
(
arg
)
{
}
;
property
:
descriptor
(
{
value
:
"
Error
"
}
)
}
{
string
:
"
[
object
Object
]
"
code
:
var
trapDidRun
=
false
;
var
obj
=
new
Proxy
(
[
]
new
Proxy
(
{
}
{
get
:
(
_
trap
)
=
>
{
trapDidRun
=
true
;
throw
new
Error
(
"
proxy
trap
'
"
+
trap
+
"
'
was
called
.
"
)
;
}
}
)
)
;
property
:
descriptor
(
{
value
:
"
Error
"
}
)
afterTest
:
trapDidRun
=
=
=
false
}
{
string
:
"
function
(
)
{
\
n
[
native
code
]
\
n
}
"
isFunction
:
true
hasPreview
:
false
code
:
var
trapDidRun
=
false
;
var
obj
=
new
Proxy
(
function
(
)
{
}
new
Proxy
(
{
}
{
get
:
(
_
trap
)
=
>
{
trapDidRun
=
true
;
throw
new
Error
(
"
proxy
trap
'
"
+
trap
+
"
'
was
called
.
"
)
;
}
}
)
)
;
property
:
descriptor
(
{
value
:
"
Error
"
}
)
afterTest
:
trapDidRun
=
=
=
false
}
{
string
:
"
[
object
Object
]
"
code
:
var
obj
=
Services
.
appShell
.
createWindowlessBrowser
(
)
.
document
.
defaultView
;
hasOwnPropertyNames
:
true
hasOwnPropertySymbols
:
true
property
:
descriptor
(
{
value
:
"
SecurityError
"
}
)
previewUrl
:
"
about
:
blank
"
}
{
string
:
"
[
object
Object
]
"
code
:
var
obj
=
Services
.
appShell
.
createWindowlessBrowser
(
)
.
document
.
defaultView
.
location
;
hasOwnPropertyNames
:
true
hasOwnPropertySymbols
:
true
property
:
descriptor
(
{
value
:
"
SecurityError
"
}
)
}
]
;
function
descriptor
(
descr
)
{
return
Object
.
assign
(
{
configurable
:
false
writable
:
false
enumerable
:
false
value
:
undefined
}
descr
)
;
}
async
function
test_unsafe_grips
(
{
threadFront
debuggee
isWorkerServer
}
tests
)
{
debuggee
.
eval
(
function
stopMe
(
arg1
arg2
)
{
debugger
;
}
.
toString
(
)
)
;
for
(
let
data
of
tests
)
{
data
=
{
.
.
.
defaults
.
.
.
data
}
;
const
sandbox
=
Cu
.
Sandbox
(
systemPrincipal
)
;
Object
.
assign
(
sandbox
{
Services
systemPrincipal
Cu
}
)
;
sandbox
.
eval
(
data
.
code
)
;
debuggee
.
obj
=
sandbox
.
obj
;
const
inherits
=
Object
.
create
(
obj
{
x
:
{
value
:
1
}
[
Symbol
.
for
(
"
x
"
)
]
:
{
value
:
2
}
}
)
;
const
packet
=
await
executeOnNextTickAndWaitForPause
(
(
)
=
>
debuggee
.
eval
(
stopMe
(
obj
{
inherits
}
)
;
)
threadFront
)
;
const
[
objGrip
inheritsGrip
]
=
packet
.
frame
.
arguments
;
for
(
const
grip
of
[
objGrip
inheritsGrip
]
)
{
const
isUnsafe
=
grip
=
=
=
objGrip
;
check_grip
(
grip
data
isUnsafe
isWorkerServer
)
;
const
objClient
=
threadFront
.
pauseGrip
(
grip
)
;
let
response
slice
;
response
=
await
objClient
.
getPrototypeAndProperties
(
)
;
check_properties
(
response
.
ownProperties
data
isUnsafe
)
;
check_symbols
(
response
.
ownSymbols
data
isUnsafe
)
;
check_prototype
(
response
.
prototype
data
isUnsafe
isWorkerServer
)
;
response
=
await
objClient
.
enumProperties
(
{
ignoreIndexedProperties
:
true
}
)
;
slice
=
await
response
.
slice
(
0
response
.
count
)
;
check_properties
(
slice
.
ownProperties
data
isUnsafe
)
;
response
=
await
objClient
.
enumProperties
(
{
}
)
;
slice
=
await
response
.
slice
(
0
response
.
count
)
;
check_properties
(
slice
.
ownProperties
data
isUnsafe
)
;
response
=
await
objClient
.
getOwnPropertyNames
(
)
;
check_property_names
(
response
.
ownPropertyNames
data
isUnsafe
)
;
response
=
await
objClient
.
getProperty
(
"
x
"
)
;
check_property
(
response
.
descriptor
data
isUnsafe
)
;
response
=
await
objClient
.
enumSymbols
(
)
;
slice
=
await
response
.
slice
(
0
response
.
count
)
;
check_symbol_names
(
slice
.
ownSymbols
data
isUnsafe
)
;
response
=
await
objClient
.
getProperty
(
Symbol
.
for
(
"
x
"
)
)
;
check_symbol
(
response
.
descriptor
data
isUnsafe
)
;
response
=
await
objClient
.
getPrototype
(
)
;
check_prototype
(
response
.
prototype
data
isUnsafe
isWorkerServer
)
;
await
objClient
.
release
(
)
;
}
await
threadFront
.
resume
(
)
;
ok
(
sandbox
.
eval
(
data
.
afterTest
)
"
Check
after
test
passes
"
)
;
}
}
function
check_grip
(
grip
data
isUnsafe
isWorkerServer
)
{
if
(
isUnsafe
)
{
strictEqual
(
grip
.
class
data
.
class
"
The
grip
has
the
proper
class
.
"
)
;
strictEqual
(
"
preview
"
in
grip
data
.
hasPreview
"
Check
preview
presence
.
"
)
;
if
(
data
.
previewUrl
&
&
!
isWorkerServer
)
{
console
.
trace
(
)
;
strictEqual
(
grip
.
preview
.
url
data
.
previewUrl
Check
preview
.
url
for
"
{
data
.
code
}
"
.
)
;
}
}
else
{
strictEqual
(
grip
.
class
"
Object
"
"
The
grip
has
'
Object
'
class
.
"
)
;
ok
(
"
preview
"
in
grip
"
The
grip
has
a
preview
.
"
)
;
}
}
function
check_properties
(
props
data
isUnsafe
)
{
const
propNames
=
Reflect
.
ownKeys
(
props
)
;
check_property_names
(
propNames
data
isUnsafe
)
;
if
(
isUnsafe
)
{
deepEqual
(
props
.
x
undefined
"
The
property
does
not
exist
.
"
)
;
}
else
{
strictEqual
(
props
.
x
.
value
1
"
The
property
has
the
right
value
.
"
)
;
}
}
function
check_property_names
(
props
data
isUnsafe
)
{
if
(
isUnsafe
)
{
strictEqual
(
props
.
length
>
0
data
.
hasOwnPropertyNames
"
Check
presence
of
own
string
properties
.
"
)
;
}
else
{
strictEqual
(
props
.
length
1
"
1
own
property
was
retrieved
.
"
)
;
strictEqual
(
props
[
0
]
"
x
"
"
The
property
has
the
right
name
.
"
)
;
}
}
function
check_property
(
descr
data
isUnsafe
)
{
if
(
isUnsafe
)
{
deepEqual
(
descr
data
.
property
"
Got
the
right
property
descriptor
.
"
)
;
}
else
{
strictEqual
(
descr
.
value
1
"
The
property
has
the
right
value
.
"
)
;
}
}
function
check_symbols
(
symbols
data
isUnsafe
)
{
check_symbol_names
(
symbols
data
isUnsafe
)
;
if
(
!
isUnsafe
)
{
check_symbol
(
symbols
[
0
]
.
descriptor
data
isUnsafe
)
;
}
}
function
check_symbol_names
(
props
data
isUnsafe
)
{
if
(
isUnsafe
)
{
strictEqual
(
props
.
length
>
0
data
.
hasOwnPropertySymbols
"
Check
presence
of
own
symbol
properties
.
"
)
;
}
else
{
strictEqual
(
props
.
length
1
"
1
own
symbol
property
was
retrieved
.
"
)
;
strictEqual
(
props
[
0
]
.
name
"
Symbol
(
x
)
"
"
The
symbol
has
the
right
name
.
"
)
;
}
}
function
check_symbol
(
descr
data
isUnsafe
)
{
if
(
isUnsafe
)
{
deepEqual
(
descr
data
.
property
"
Got
the
right
symbol
property
descriptor
.
"
)
;
}
else
{
strictEqual
(
descr
.
value
2
"
The
symbol
property
has
the
right
value
.
"
)
;
}
}
function
check_prototype
(
proto
data
isUnsafe
isWorkerServer
)
{
const
protoGrip
=
proto
&
&
proto
.
getGrip
?
proto
.
getGrip
(
)
:
proto
;
if
(
isUnsafe
)
{
deepEqual
(
protoGrip
.
type
data
.
protoType
"
Got
the
right
prototype
type
.
"
)
;
}
else
{
check_grip
(
protoGrip
data
true
isWorkerServer
)
;
}
}
add_task
(
threadFrontTest
(
options
=
>
{
return
test_unsafe_grips
(
options
systemPrincipalTests
"
system
"
)
;
}
{
principal
:
systemPrincipal
}
)
)
;
const
nullPrincipal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
}
)
;
add_task
(
threadFrontTest
(
options
=
>
{
return
test_unsafe_grips
(
options
nullPrincipalTests
"
null
"
)
;
}
{
principal
:
nullPrincipal
}
)
)
;
