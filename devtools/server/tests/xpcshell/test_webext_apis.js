"
use
strict
"
;
const
{
AddonManager
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
sys
.
mjs
"
)
;
const
{
ExtensionTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
ExtensionXPCShellUtils
.
sys
.
mjs
"
)
;
ExtensionTestUtils
.
init
(
this
)
;
add_task
(
async
function
setup
(
)
{
Services
.
prefs
.
setBoolPref
(
"
extensions
.
blocklist
.
enabled
"
false
)
;
await
startupAddonsManager
(
)
;
}
)
;
async
function
sendRequest
(
transport
request
)
{
return
new
Promise
(
resolve
=
>
{
transport
.
hooks
=
{
onPacket
:
packet
=
>
{
dump
(
received
packet
:
{
JSON
.
stringify
(
packet
)
}
\
n
)
;
if
(
packet
.
from
=
=
=
request
.
to
)
{
resolve
(
packet
)
;
}
}
}
;
transport
.
send
(
request
)
;
}
)
;
}
add_task
(
async
function
test_webext_run_apis
(
)
{
DevToolsServer
.
init
(
)
;
DevToolsServer
.
registerAllActors
(
)
;
const
transport
=
DevToolsServer
.
connectPipe
(
)
;
await
new
Promise
(
resolve
=
>
{
transport
.
hooks
=
{
onPacket
:
resolve
}
;
}
)
;
const
getRootResponse
=
await
sendRequest
(
transport
{
to
:
"
root
"
type
:
"
getRoot
"
}
)
;
ok
(
getRootResponse
"
received
a
response
after
calling
RootActor
:
:
getRoot
"
)
;
ok
(
getRootResponse
.
addonsActor
"
getRoot
returned
an
addonsActor
id
"
)
;
const
addonId
=
"
test
-
addons
-
actor
mozilla
.
org
"
;
const
addonPath
=
getFilePath
(
"
addons
/
web
-
extension
"
false
true
)
;
const
promiseStarted
=
AddonTestUtils
.
promiseWebExtensionStartup
(
addonId
)
;
const
{
addon
}
=
await
sendRequest
(
transport
{
to
:
getRootResponse
.
addonsActor
type
:
"
installTemporaryAddon
"
addonPath
}
)
;
await
promiseStarted
;
ok
(
addon
"
addonsActor
allows
to
install
a
temporary
add
-
on
"
)
;
equal
(
addon
.
id
addonId
"
temporary
add
-
on
is
the
expected
one
"
)
;
equal
(
addon
.
actor
false
"
temporary
add
-
on
does
not
have
an
actor
"
)
;
let
{
addons
}
=
await
sendRequest
(
transport
{
to
:
"
root
"
type
:
"
listAddons
"
}
)
;
ok
(
Array
.
isArray
(
addons
)
"
listAddons
(
)
returns
a
list
of
add
-
ons
"
)
;
equal
(
addons
.
length
1
"
expected
an
add
-
on
installed
"
)
;
const
installedAddon
=
addons
[
0
]
;
equal
(
installedAddon
.
id
addonId
"
installed
add
-
on
is
the
expected
one
"
)
;
ok
(
installedAddon
.
actor
"
returned
add
-
on
has
an
actor
"
)
;
const
promiseReloaded
=
AddonTestUtils
.
promiseAddonEvent
(
"
onInstalled
"
)
;
const
promiseRestarted
=
AddonTestUtils
.
promiseWebExtensionStartup
(
addonId
)
;
await
sendRequest
(
transport
{
to
:
installedAddon
.
actor
type
:
"
reload
"
}
)
;
await
Promise
.
all
(
[
promiseReloaded
promiseRestarted
]
)
;
const
promiseUninstalled
=
new
Promise
(
resolve
=
>
{
const
listener
=
{
}
;
listener
.
onUninstalled
=
uninstalledAddon
=
>
{
if
(
uninstalledAddon
.
id
=
=
addonId
)
{
AddonManager
.
removeAddonListener
(
listener
)
;
resolve
(
)
;
}
}
;
AddonManager
.
addAddonListener
(
listener
)
;
}
)
;
await
sendRequest
(
transport
{
to
:
getRootResponse
.
addonsActor
type
:
"
uninstallAddon
"
addonId
}
)
;
await
promiseUninstalled
;
(
{
addons
}
=
await
sendRequest
(
transport
{
to
:
"
root
"
type
:
"
listAddons
"
}
)
)
;
equal
(
addons
.
length
0
"
expected
no
add
-
on
installed
"
)
;
let
error
=
await
sendRequest
(
transport
{
to
:
getRootResponse
.
addonsActor
type
:
"
uninstallAddon
"
addonId
}
)
;
equal
(
error
?
.
message
Could
not
uninstall
add
-
on
"
{
addonId
}
"
"
expected
error
"
)
;
const
id
=
"
not
-
a
-
temporary
extension
"
;
const
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
browser_specific_settings
:
{
gecko
:
{
id
}
}
}
useAddonManager
:
"
permanent
"
}
)
;
await
extension
.
startup
(
)
;
error
=
await
sendRequest
(
transport
{
to
:
getRootResponse
.
addonsActor
type
:
"
uninstallAddon
"
addonId
:
id
}
)
;
equal
(
error
?
.
message
Could
not
uninstall
add
-
on
"
{
id
}
"
"
expected
error
"
)
;
await
extension
.
unload
(
)
;
transport
.
close
(
)
;
}
)
;
