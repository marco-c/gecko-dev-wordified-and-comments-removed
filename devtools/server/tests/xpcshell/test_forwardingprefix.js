"
use
strict
"
;
const
{
RootActor
}
=
require
(
"
devtools
/
server
/
actors
/
root
"
)
;
var
gMainConnection
gMainTransport
;
var
gSubconnection1
gSubconnection2
;
var
gClient
;
function
run_test
(
)
{
DevToolsServer
.
init
(
)
;
add_test
(
createMainConnection
)
;
add_test
(
TestNoForwardingYet
)
;
add_test
(
createSubconnection1
)
;
add_test
(
TestForwardPrefix1OnlyRoot
)
;
add_test
(
createSubconnection2
)
;
add_test
(
TestForwardPrefix12OnlyRoot
)
;
add_test
(
TestForwardPrefix12WithActor1
)
;
add_test
(
TestForwardPrefix12WithActor12
)
;
run_next_test
(
)
;
}
function
newConnection
(
prefix
)
{
let
conn
;
DevToolsServer
.
createRootActor
=
function
(
connection
)
{
conn
=
connection
;
return
new
RootActor
(
connection
{
}
)
;
}
;
const
transport
=
DevToolsServer
.
connectPipe
(
prefix
)
;
return
{
conn
transport
}
;
}
function
createMainConnection
(
)
{
(
{
conn
:
gMainConnection
transport
:
gMainTransport
}
=
newConnection
(
)
)
;
gClient
=
new
DevToolsClient
(
gMainTransport
)
;
gClient
.
connect
(
)
.
then
(
(
[
type
traits
]
)
=
>
run_next_test
(
)
)
;
}
function
tryActors
(
reachables
completed
)
{
let
count
=
0
;
let
outerActor
;
for
(
outerActor
of
[
"
root
"
"
prefix1
/
root
"
"
prefix1
/
actor
"
"
prefix2
/
root
"
"
prefix2
/
actor
"
]
)
{
const
actor
=
outerActor
;
count
+
+
;
let
promise
;
if
(
actor
=
=
"
root
"
)
{
promise
=
gClient
.
mainRoot
.
echo
(
{
value
:
"
tango
"
}
)
;
}
else
{
promise
=
gClient
.
request
(
{
to
:
actor
type
:
"
echo
"
value
:
"
tango
"
}
)
;
}
const
callback
=
response
=
>
{
if
(
reachables
.
has
(
actor
)
)
{
Assert
.
deepEqual
(
{
from
:
actor
to
:
actor
type
:
"
echo
"
value
:
"
tango
"
}
response
)
;
}
else
{
Assert
.
deepEqual
(
{
from
:
actor
error
:
"
noSuchActor
"
message
:
"
No
such
actor
for
ID
:
"
+
actor
}
response
)
;
}
if
(
-
-
count
=
=
0
)
{
executeSoon
(
completed
"
tryActors
callback
"
+
completed
.
name
)
;
}
}
;
promise
.
then
(
callback
callback
)
;
}
}
function
TestNoForwardingYet
(
)
{
tryActors
(
new
Set
(
[
"
root
"
]
)
run_next_test
)
;
}
function
newSubconnection
(
prefix
)
{
const
{
conn
transport
}
=
newConnection
(
prefix
)
;
transport
.
hooks
=
{
onPacket
:
packet
=
>
gMainConnection
.
send
(
packet
)
}
;
gMainConnection
.
setForwarding
(
prefix
transport
)
;
return
{
conn
transport
}
;
}
function
createSubconnection1
(
)
{
const
{
conn
transport
}
=
newSubconnection
(
"
prefix1
"
)
;
gSubconnection1
=
conn
;
transport
.
ready
(
)
;
gClient
.
expectReply
(
"
prefix1
/
root
"
reply
=
>
run_next_test
(
)
)
;
}
function
TestForwardPrefix1OnlyRoot
(
)
{
tryActors
(
new
Set
(
[
"
root
"
"
prefix1
/
root
"
]
)
run_next_test
)
;
}
function
createSubconnection2
(
)
{
const
{
conn
transport
}
=
newSubconnection
(
"
prefix2
"
)
;
gSubconnection2
=
conn
;
transport
.
ready
(
)
;
gClient
.
expectReply
(
"
prefix2
/
root
"
reply
=
>
run_next_test
(
)
)
;
}
function
TestForwardPrefix12OnlyRoot
(
)
{
tryActors
(
new
Set
(
[
"
root
"
"
prefix1
/
root
"
"
prefix2
/
root
"
]
)
run_next_test
)
;
}
const
{
Actor
}
=
require
(
"
devtools
/
shared
/
protocol
/
Actor
"
)
;
class
EchoActor
extends
Actor
{
constructor
(
conn
)
{
super
(
conn
)
;
this
.
typeName
=
"
EchoActor
"
;
this
.
requestTypes
=
{
echo
:
EchoActor
.
prototype
.
onEcho
}
;
}
onEcho
(
request
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
request
)
)
;
}
}
function
TestForwardPrefix12WithActor1
(
)
{
const
actor
=
new
EchoActor
(
gSubconnection1
)
;
actor
.
actorID
=
"
prefix1
/
actor
"
;
gSubconnection1
.
addActor
(
actor
)
;
tryActors
(
new
Set
(
[
"
root
"
"
prefix1
/
root
"
"
prefix1
/
actor
"
"
prefix2
/
root
"
]
)
run_next_test
)
;
}
function
TestForwardPrefix12WithActor12
(
)
{
const
actor
=
new
EchoActor
(
gSubconnection2
)
;
actor
.
actorID
=
"
prefix2
/
actor
"
;
gSubconnection2
.
addActor
(
actor
)
;
tryActors
(
new
Set
(
[
"
root
"
"
prefix1
/
root
"
"
prefix1
/
actor
"
"
prefix2
/
root
"
"
prefix2
/
actor
"
]
)
run_next_test
)
;
}
