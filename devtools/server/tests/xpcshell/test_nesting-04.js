"
use
strict
"
;
add_task
(
threadFrontTest
(
async
(
{
commands
threadFront
debuggee
}
)
=
>
{
await
threadFront
.
setBreakpoint
(
{
sourceUrl
:
"
nesting
-
04
.
js
"
line
:
2
}
)
;
const
packet
=
await
executeOnNextTickAndWaitForPause
(
(
)
=
>
evalCode
(
debuggee
)
threadFront
)
;
Assert
.
equal
(
packet
.
frame
.
where
.
line
5
)
;
Assert
.
equal
(
packet
.
why
.
type
"
debuggerStatement
"
)
;
info
(
"
Test
calling
interrupt
"
)
;
const
onPaused
=
waitForPause
(
threadFront
)
;
await
threadFront
.
interrupt
(
)
;
const
paused
=
await
onPaused
;
equal
(
paused
.
why
.
type
"
alreadyPaused
"
)
;
info
(
"
Test
by
evaluating
code
via
the
console
"
)
;
const
{
result
}
=
await
commands
.
scriptCommand
.
execute
(
"
debugger
;
functionWithDebuggerStatement
(
)
"
{
frameActor
:
packet
.
frame
.
actorID
}
)
;
equal
(
result
42
)
;
info
(
"
Test
by
calling
code
from
chrome
context
"
)
;
const
rv
=
debuggee
.
functionWithDebuggerStatement
(
)
;
equal
(
rv
42
)
;
info
(
"
Test
by
stepping
over
a
function
that
breaks
"
)
;
const
step1
=
await
stepOver
(
threadFront
)
;
equal
(
step1
.
why
.
type
"
resumeLimit
"
)
;
equal
(
step1
.
frame
.
where
.
line
6
)
;
const
step2
=
await
stepOver
(
threadFront
)
;
equal
(
step2
.
why
.
type
"
breakpoint
"
)
;
equal
(
step2
.
frame
.
where
.
line
2
)
;
info
(
"
Resume
and
pause
on
the
breakpoint
"
)
;
threadFront
.
resume
(
)
;
const
pausedPacket
=
await
waitForEvent
(
threadFront
"
paused
"
)
;
Assert
.
equal
(
pausedPacket
.
frame
.
where
.
line
2
)
;
Assert
.
equal
(
pausedPacket
.
why
.
type
"
breakpoint
"
)
;
await
threadFront
.
resume
(
)
;
}
)
)
;
function
evalCode
(
debuggee
)
{
Cu
.
evalInSandbox
(
function
functionWithDebuggerStatement
(
)
{
debugger
;
return
42
;
}
debugger
;
functionWithDebuggerStatement
(
)
;
var
a
=
1
;
functionWithDebuggerStatement
(
)
;
debuggee
"
1
.
8
"
"
nesting
-
04
.
js
"
1
)
;
}
