"
use
strict
"
;
var
CC
=
Components
.
Constructor
;
const
appInfo
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
jsm
"
)
;
appInfo
.
updateAppInfo
(
{
ID
:
"
devtools
tests
.
mozilla
.
org
"
name
:
"
devtools
-
tests
"
version
:
"
1
"
platformVersion
:
"
42
"
crashReporter
:
true
}
)
;
const
{
require
loader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
jsm
"
)
;
const
{
worker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
worker
-
loader
.
js
"
)
;
const
{
NetUtil
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
Services
=
require
(
"
Services
"
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
debugger
.
log
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
debugger
.
remote
-
enabled
"
true
)
;
const
makeDebugger
=
require
(
"
devtools
/
server
/
actors
/
utils
/
make
-
debugger
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
ActorRegistry
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
actor
-
registry
"
)
;
const
{
DevToolsServer
}
=
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
const
{
DevToolsServer
:
WorkerDevToolsServer
}
=
worker
.
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
const
{
DevToolsClient
}
=
require
(
"
devtools
/
client
/
devtools
-
client
"
)
;
const
{
ObjectFront
}
=
require
(
"
devtools
/
client
/
fronts
/
object
"
)
;
const
{
LongStringFront
}
=
require
(
"
devtools
/
client
/
fronts
/
string
"
)
;
const
{
createCommandsDictionary
}
=
require
(
"
devtools
/
shared
/
commands
/
index
"
)
;
const
{
addDebuggerToGlobal
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
"
)
;
const
{
AddonTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
)
;
const
{
getAppInfo
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
jsm
"
)
;
const
systemPrincipal
=
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
;
var
{
loadSubScript
loadSubScriptWithOptions
}
=
Services
.
scriptloader
;
async
function
startupAddonsManager
(
)
{
const
profileDir
=
do_get_profile
(
)
.
clone
(
)
;
profileDir
.
append
(
"
extensions
"
)
;
AddonTestUtils
.
init
(
globalThis
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
AddonTestUtils
.
appInfo
=
getAppInfo
(
)
;
await
AddonTestUtils
.
promiseStartupManager
(
)
;
}
async
function
createTargetForFakeTab
(
title
)
{
const
client
=
await
startTestDevToolsServer
(
title
)
;
const
tabs
=
await
listTabs
(
client
)
;
const
tabDescriptor
=
findTab
(
tabs
title
)
;
tabDescriptor
.
disableTargetSwitching
(
)
;
return
tabDescriptor
.
getTarget
(
)
;
}
async
function
createTargetForMainProcess
(
)
{
DevToolsServer
.
init
(
)
;
DevToolsServer
.
registerAllActors
(
)
;
DevToolsServer
.
allowChromeProcess
=
true
;
const
client
=
new
DevToolsClient
(
DevToolsServer
.
connectPipe
(
)
)
;
await
client
.
connect
(
)
;
const
mainProcessDescriptor
=
await
client
.
mainRoot
.
getMainProcess
(
)
;
return
mainProcessDescriptor
.
getTarget
(
)
;
}
async
function
createTabMemoryFront
(
)
{
const
target
=
await
createTargetForFakeTab
(
"
test_memory
"
)
;
DevToolsServer
.
registerActors
(
{
browser
:
true
}
)
;
const
memoryFront
=
await
target
.
getFront
(
"
memory
"
)
;
await
memoryFront
.
attach
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
memoryFront
.
detach
(
)
;
await
target
.
client
.
close
(
)
;
}
)
;
return
{
target
memoryFront
}
;
}
async
function
createMainProcessMemoryFront
(
)
{
const
target
=
await
createTargetForMainProcess
(
)
;
const
memoryFront
=
await
target
.
getFront
(
"
memory
"
)
;
await
memoryFront
.
attach
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
memoryFront
.
detach
(
)
;
await
target
.
client
.
close
(
)
;
}
)
;
return
{
client
:
target
.
client
memoryFront
}
;
}
function
createLongStringFront
(
conn
form
)
{
const
front
=
new
LongStringFront
(
conn
form
)
;
front
.
actorID
=
form
.
actor
;
front
.
manage
(
front
)
;
return
front
;
}
function
createTestGlobal
(
name
options
)
{
const
principal
=
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
;
const
sandbox
=
options
?
Cu
.
Sandbox
(
principal
options
)
:
Cu
.
Sandbox
(
principal
)
;
sandbox
.
__name
=
name
;
sandbox
.
performance
=
{
timing
:
{
}
}
;
sandbox
.
document
=
{
readyState
:
"
complete
"
defaultView
:
sandbox
}
;
return
sandbox
;
}
function
connect
(
client
)
{
dump
(
"
Connecting
client
.
\
n
"
)
;
return
client
.
connect
(
)
;
}
function
close
(
client
)
{
dump
(
"
Closing
client
.
\
n
"
)
;
return
client
.
close
(
)
;
}
function
listTabs
(
client
)
{
dump
(
"
Listing
tabs
.
\
n
"
)
;
return
client
.
mainRoot
.
listTabs
(
)
;
}
function
findTab
(
tabs
title
)
{
dump
(
"
Finding
tab
with
title
'
"
+
title
+
"
'
.
\
n
"
)
;
for
(
const
tab
of
tabs
)
{
if
(
tab
.
title
=
=
=
title
)
{
return
tab
;
}
}
return
null
;
}
function
waitForNewSource
(
threadFront
url
)
{
dump
(
"
Waiting
for
new
source
with
url
'
"
+
url
+
"
'
.
\
n
"
)
;
return
waitForEvent
(
threadFront
"
newSource
"
function
(
packet
)
{
return
packet
.
source
.
url
=
=
=
url
;
}
)
;
}
function
attachThread
(
targetFront
options
=
{
}
)
{
dump
(
"
Attaching
to
thread
.
\
n
"
)
;
return
targetFront
.
attachThread
(
options
)
;
}
function
resume
(
threadFront
)
{
dump
(
"
Resuming
thread
.
\
n
"
)
;
return
threadFront
.
resume
(
)
;
}
async
function
addWatchpoint
(
threadFront
frame
variable
property
type
)
{
const
path
=
{
variable
}
.
{
property
}
;
info
(
Add
an
{
path
}
{
type
}
watchpoint
)
;
const
environment
=
await
frame
.
getEnvironment
(
)
;
const
obj
=
environment
.
bindings
.
variables
[
variable
]
;
const
objFront
=
threadFront
.
pauseGrip
(
obj
.
value
)
;
return
objFront
.
addWatchpoint
(
property
path
type
)
;
}
function
getSources
(
threadFront
)
{
dump
(
"
Getting
sources
.
\
n
"
)
;
return
threadFront
.
getSources
(
)
;
}
function
findSource
(
sources
url
)
{
dump
(
"
Finding
source
with
url
'
"
+
url
+
"
'
.
\
n
"
)
;
for
(
const
source
of
sources
)
{
if
(
source
.
url
=
=
=
url
)
{
return
source
;
}
}
return
null
;
}
function
waitForPause
(
threadFront
)
{
dump
(
"
Waiting
for
pause
.
\
n
"
)
;
return
waitForEvent
(
threadFront
"
paused
"
)
;
}
function
waitForProperty
(
dbg
property
)
{
return
new
Promise
(
resolve
=
>
{
Object
.
defineProperty
(
dbg
property
{
set
(
newValue
)
{
resolve
(
newValue
)
;
}
}
)
;
}
)
;
}
function
setBreakpoint
(
threadFront
location
)
{
dump
(
"
Setting
breakpoint
.
\
n
"
)
;
return
threadFront
.
setBreakpoint
(
location
{
}
)
;
}
function
getPrototypeAndProperties
(
objClient
)
{
dump
(
"
getting
prototype
and
properties
.
\
n
"
)
;
return
objClient
.
getPrototypeAndProperties
(
)
;
}
function
dumpn
(
msg
)
{
dump
(
"
DBG
-
TEST
:
"
+
msg
+
"
\
n
"
)
;
}
function
testExceptionHook
(
ex
)
{
try
{
do_report_unexpected_exception
(
ex
)
;
}
catch
(
e
)
{
return
{
throw
:
e
}
;
}
return
undefined
;
}
function
scriptErrorLogLevel
(
message
)
{
switch
(
message
.
logLevel
)
{
case
Ci
.
nsIConsoleMessage
.
info
:
return
"
info
"
;
case
Ci
.
nsIConsoleMessage
.
warn
:
return
"
warning
"
;
default
:
Assert
.
equal
(
message
.
logLevel
Ci
.
nsIConsoleMessage
.
error
)
;
return
"
error
"
;
}
}
var
errorCount
=
0
;
var
listener
=
{
observe
(
message
)
{
try
{
let
string
;
errorCount
+
+
;
try
{
message
.
QueryInterface
(
Ci
.
nsIScriptError
)
;
dumpn
(
message
.
sourceName
+
"
:
"
+
message
.
lineNumber
+
"
:
"
+
scriptErrorLogLevel
(
message
)
+
"
:
"
+
message
.
errorMessage
)
;
string
=
message
.
errorMessage
;
}
catch
(
e1
)
{
try
{
string
=
"
"
+
message
.
message
;
}
catch
(
e2
)
{
string
=
"
<
error
converting
error
message
to
string
>
"
;
}
}
while
(
DevToolsServer
&
&
DevToolsServer
.
xpcInspector
&
&
DevToolsServer
.
xpcInspector
.
eventLoopNestLevel
>
0
)
{
DevToolsServer
.
xpcInspector
.
exitNestedEventLoop
(
)
;
}
dumpn
(
"
head_dbg
.
js
observed
a
console
message
:
"
+
string
)
;
}
catch
(
_
)
{
}
}
}
;
Services
.
console
.
registerListener
(
listener
)
;
function
addTestGlobal
(
name
server
=
DevToolsServer
)
{
const
global
=
createTestGlobal
(
name
)
;
server
.
addTestGlobal
(
global
)
;
return
global
;
}
async
function
getTestTab
(
client
title
)
{
const
tabs
=
await
client
.
mainRoot
.
listTabs
(
)
;
for
(
const
tab
of
tabs
)
{
if
(
tab
.
title
=
=
=
title
)
{
return
tab
;
}
}
return
null
;
}
async
function
attachTestTab
(
client
title
)
{
const
descriptorFront
=
await
getTestTab
(
client
title
)
;
descriptorFront
.
disableTargetSwitching
(
)
;
const
commands
=
await
createCommandsDictionary
(
descriptorFront
)
;
await
commands
.
targetCommand
.
startListening
(
)
;
return
commands
;
}
async
function
attachTestThread
(
client
title
)
{
const
commands
=
await
attachTestTab
(
client
title
)
;
const
targetFront
=
commands
.
targetCommand
.
targetFront
;
const
threadFront
=
await
targetFront
.
getFront
(
"
thread
"
)
;
await
targetFront
.
attachThread
(
{
autoBlackBox
:
true
}
)
;
Assert
.
equal
(
threadFront
.
state
"
attached
"
"
Thread
front
is
attached
"
)
;
return
{
targetFront
threadFront
commands
}
;
}
function
initTestDevToolsServer
(
server
=
DevToolsServer
)
{
if
(
server
=
=
=
WorkerDevToolsServer
)
{
const
{
createRootActor
}
=
worker
.
require
(
"
xpcshell
-
test
/
testactors
"
)
;
server
.
setRootActor
(
createRootActor
)
;
}
else
{
const
{
createRootActor
}
=
require
(
"
xpcshell
-
test
/
testactors
"
)
;
server
.
setRootActor
(
createRootActor
)
;
}
server
.
init
(
function
(
)
{
return
true
;
}
)
;
}
async
function
startTestDevToolsServer
(
title
server
=
DevToolsServer
)
{
initTestDevToolsServer
(
server
)
;
addTestGlobal
(
title
)
;
DevToolsServer
.
registerActors
(
{
target
:
true
}
)
;
const
transport
=
DevToolsServer
.
connectPipe
(
)
;
const
client
=
new
DevToolsClient
(
transport
)
;
await
connect
(
client
)
;
return
client
;
}
async
function
finishClient
(
client
)
{
await
client
.
close
(
)
;
DevToolsServer
.
destroy
(
)
;
do_test_finished
(
)
;
}
function
getFileUrl
(
name
allowMissing
=
false
)
{
const
file
=
do_get_file
(
name
allowMissing
)
;
return
Services
.
io
.
newFileURI
(
file
)
.
spec
;
}
function
getFilePath
(
name
allowMissing
=
false
usePlatformPathSeparator
=
false
)
{
const
file
=
do_get_file
(
name
allowMissing
)
;
let
path
=
Services
.
io
.
newFileURI
(
file
)
.
spec
;
let
filePrePath
=
"
file
:
/
/
"
;
if
(
"
nsILocalFileWin
"
in
Ci
&
&
file
instanceof
Ci
.
nsILocalFileWin
)
{
filePrePath
+
=
"
/
"
;
}
path
=
path
.
slice
(
filePrePath
.
length
)
;
if
(
usePlatformPathSeparator
&
&
path
.
match
(
/
^
\
w
:
/
)
)
{
path
=
path
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
return
path
;
}
function
readFile
(
fileName
)
{
const
f
=
do_get_file
(
fileName
)
;
const
s
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
s
.
init
(
f
-
1
-
1
false
)
;
try
{
return
NetUtil
.
readInputStreamToString
(
s
s
.
available
(
)
)
;
}
finally
{
s
.
close
(
)
;
}
}
function
writeFile
(
fileName
content
)
{
const
file
=
do_get_file
(
fileName
true
)
;
const
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
stream
.
init
(
file
-
1
-
1
0
)
;
try
{
do
{
const
numWritten
=
stream
.
write
(
content
content
.
length
)
;
content
=
content
.
slice
(
numWritten
)
;
}
while
(
content
.
length
>
0
)
;
}
finally
{
stream
.
close
(
)
;
}
}
function
StubTransport
(
)
{
}
StubTransport
.
prototype
.
ready
=
function
(
)
{
}
;
StubTransport
.
prototype
.
send
=
function
(
)
{
}
;
StubTransport
.
prototype
.
close
=
function
(
)
{
}
;
const
Async
=
target
=
>
new
Proxy
(
target
Async
)
;
Async
.
get
=
(
target
name
)
=
>
typeof
target
[
name
]
=
=
=
"
function
"
?
asyncall
.
bind
(
null
target
[
name
]
target
)
:
target
[
name
]
;
const
asyncall
=
(
fn
self
.
.
.
args
)
=
>
new
Promise
(
(
.
.
.
etc
)
=
>
fn
.
call
(
self
.
.
.
args
.
.
.
etc
)
)
;
const
Test
=
task
=
>
(
)
=
>
{
add_task
(
task
)
;
run_next_test
(
)
;
}
;
const
assert
=
Assert
.
ok
.
bind
(
Assert
)
;
function
waitForEvent
(
front
type
predicate
)
{
if
(
!
predicate
)
{
return
front
.
once
(
type
)
;
}
return
new
Promise
(
function
(
resolve
)
{
function
listener
(
packet
)
{
if
(
!
predicate
(
packet
)
)
{
return
;
}
front
.
off
(
type
listener
)
;
resolve
(
packet
)
;
}
front
.
on
(
type
listener
)
;
}
)
;
}
function
executeOnNextTickAndWaitForPause
(
action
threadFront
)
{
const
paused
=
waitForPause
(
threadFront
)
;
executeSoon
(
action
)
;
return
paused
;
}
function
evalCallback
(
debuggeeGlobal
func
)
{
Cu
.
evalInSandbox
(
"
(
"
+
func
+
"
)
(
)
"
debuggeeGlobal
"
1
.
8
"
"
test
.
js
"
1
)
;
}
function
interrupt
(
threadFront
)
{
dumpn
(
"
Interrupting
.
"
)
;
return
threadFront
.
interrupt
(
)
;
}
async
function
resumeAndWaitForPause
(
threadFront
)
{
const
paused
=
waitForPause
(
threadFront
)
;
await
resume
(
threadFront
)
;
return
paused
;
}
function
stepIn
(
threadFront
)
{
dumpn
(
"
Stepping
in
.
"
)
;
const
paused
=
waitForPause
(
threadFront
)
;
return
threadFront
.
stepIn
(
)
.
then
(
(
)
=
>
paused
)
;
}
async
function
stepOver
(
threadFront
frameActor
)
{
dumpn
(
"
Stepping
over
.
"
)
;
await
threadFront
.
stepOver
(
frameActor
)
;
return
waitForPause
(
threadFront
)
;
}
async
function
stepOut
(
threadFront
frameActor
)
{
dumpn
(
"
Stepping
out
.
"
)
;
await
threadFront
.
stepOut
(
frameActor
)
;
return
waitForPause
(
threadFront
)
;
}
async
function
restartFrame
(
threadFront
frameActor
)
{
dumpn
(
"
Restarting
frame
.
"
)
;
await
threadFront
.
restart
(
frameActor
)
;
return
waitForPause
(
threadFront
)
;
}
function
getFrames
(
threadFront
first
count
)
{
dumpn
(
"
Getting
frames
.
"
)
;
return
threadFront
.
getFrames
(
first
count
)
;
}
async
function
blackBox
(
sourceFront
range
=
null
)
{
dumpn
(
"
Black
boxing
source
:
"
+
sourceFront
.
actor
)
;
const
pausedInSource
=
await
sourceFront
.
blackBox
(
range
)
;
ok
(
true
"
blackBox
didn
'
t
throw
"
)
;
return
pausedInSource
;
}
async
function
unBlackBox
(
sourceFront
range
=
null
)
{
dumpn
(
"
Un
-
black
boxing
source
:
"
+
sourceFront
.
actor
)
;
await
sourceFront
.
unblackBox
(
range
)
;
ok
(
true
"
unblackBox
didn
'
t
throw
"
)
;
}
function
getSourceContent
(
sourceFront
)
{
dumpn
(
"
Getting
source
content
for
"
+
sourceFront
.
actor
)
;
return
sourceFront
.
source
(
)
;
}
async
function
getSource
(
threadFront
url
)
{
const
source
=
await
getSourceForm
(
threadFront
url
)
;
if
(
source
)
{
return
threadFront
.
source
(
source
)
;
}
throw
new
Error
(
"
source
not
found
"
)
;
}
async
function
getSourceById
(
threadFront
id
)
{
const
form
=
await
getSourceFormById
(
threadFront
id
)
;
return
threadFront
.
source
(
form
)
;
}
async
function
getSourceForm
(
threadFront
url
)
{
const
{
sources
}
=
await
threadFront
.
getSources
(
)
;
return
sources
.
find
(
s
=
>
s
.
url
=
=
=
url
)
;
}
async
function
getSourceFormById
(
threadFront
id
)
{
const
{
sources
}
=
await
threadFront
.
getSources
(
)
;
return
sources
.
find
(
source
=
>
source
.
actor
=
=
id
)
;
}
async
function
checkFramesLength
(
threadFront
expectedFrames
)
{
const
frameResponse
=
await
threadFront
.
getFrames
(
0
null
)
;
Assert
.
equal
(
frameResponse
.
frames
.
length
expectedFrames
"
Thread
front
has
the
expected
number
of
frames
"
)
;
}
function
reload
(
tabFront
)
{
return
tabFront
.
reload
(
{
}
)
;
}
function
getInflatedStackLocations
(
thread
sample
)
{
const
stackTable
=
thread
.
stackTable
;
const
frameTable
=
thread
.
frameTable
;
const
stringTable
=
thread
.
stringTable
;
const
SAMPLE_STACK_SLOT
=
thread
.
samples
.
schema
.
stack
;
const
STACK_PREFIX_SLOT
=
stackTable
.
schema
.
prefix
;
const
STACK_FRAME_SLOT
=
stackTable
.
schema
.
frame
;
const
FRAME_LOCATION_SLOT
=
frameTable
.
schema
.
location
;
let
stackIndex
=
sample
[
SAMPLE_STACK_SLOT
]
;
const
locations
=
[
]
;
while
(
stackIndex
!
=
=
null
)
{
const
stackEntry
=
stackTable
.
data
[
stackIndex
]
;
const
frame
=
frameTable
.
data
[
stackEntry
[
STACK_FRAME_SLOT
]
]
;
locations
.
push
(
stringTable
[
frame
[
FRAME_LOCATION_SLOT
]
]
)
;
stackIndex
=
stackEntry
[
STACK_PREFIX_SLOT
]
;
}
return
locations
.
reverse
(
)
;
}
async
function
setupTestFromUrl
(
url
)
{
do_test_pending
(
)
;
const
{
createRootActor
}
=
require
(
"
xpcshell
-
test
/
testactors
"
)
;
DevToolsServer
.
setRootActor
(
createRootActor
)
;
DevToolsServer
.
init
(
(
)
=
>
true
)
;
const
global
=
createTestGlobal
(
"
test
"
)
;
DevToolsServer
.
addTestGlobal
(
global
)
;
const
devToolsClient
=
new
DevToolsClient
(
DevToolsServer
.
connectPipe
(
)
)
;
await
connect
(
devToolsClient
)
;
const
tabs
=
await
listTabs
(
devToolsClient
)
;
const
descriptorFront
=
findTab
(
tabs
"
test
"
)
;
descriptorFront
.
disableTargetSwitching
(
)
;
const
targetFront
=
await
descriptorFront
.
getTarget
(
)
;
const
threadFront
=
await
attachThread
(
targetFront
)
;
const
sourceUrl
=
getFileUrl
(
url
)
;
const
promise
=
waitForNewSource
(
threadFront
sourceUrl
)
;
loadSubScript
(
sourceUrl
global
)
;
const
{
source
}
=
await
promise
;
const
sourceFront
=
threadFront
.
source
(
source
)
;
return
{
global
devToolsClient
threadFront
sourceFront
}
;
}
function
threadFrontTest
(
test
options
=
{
}
)
{
const
{
principal
=
systemPrincipal
doNotRunWorker
=
false
wantXrays
=
true
waitForFinish
=
false
}
=
options
;
async
function
runThreadFrontTestWithServer
(
server
test
)
{
initTestDevToolsServer
(
server
)
;
const
debuggee
=
Cu
.
Sandbox
(
principal
{
freshZone
:
true
wantXrays
}
)
;
const
scriptName
=
"
debuggee
.
js
"
;
debuggee
.
__name
=
scriptName
;
server
.
addTestGlobal
(
debuggee
)
;
const
client
=
new
DevToolsClient
(
server
.
connectPipe
(
)
)
;
await
client
.
connect
(
)
;
const
{
targetFront
threadFront
commands
}
=
await
attachTestThread
(
client
scriptName
)
;
const
rootActor
=
client
.
transport
.
_serverConnection
.
rootActor
;
const
targetActor
=
rootActor
.
_parameters
.
tabList
.
getTargetActorForTab
(
"
debuggee
.
js
"
)
;
const
{
threadActor
}
=
targetActor
;
const
args
=
{
threadActor
threadFront
debuggee
client
server
targetFront
commands
isWorkerServer
:
server
=
=
=
WorkerDevToolsServer
}
;
if
(
waitForFinish
)
{
const
promise
=
new
Promise
(
resolve
=
>
(
threadFrontTestFinished
=
resolve
)
)
;
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
test
(
args
)
)
;
await
promise
;
}
else
{
await
test
(
args
)
;
}
await
client
.
close
(
)
;
server
.
removeTestGlobal
(
debuggee
)
;
server
.
destroy
(
)
;
}
return
async
(
)
=
>
{
dump
(
"
>
>
>
Run
thread
front
test
against
a
regular
DevToolsServer
\
n
"
)
;
await
runThreadFrontTestWithServer
(
DevToolsServer
test
)
;
if
(
!
doNotRunWorker
)
{
dump
(
"
>
>
>
Run
thread
front
test
against
a
worker
DevToolsServer
\
n
"
)
;
await
runThreadFrontTestWithServer
(
WorkerDevToolsServer
test
)
;
}
}
;
}
let
threadFrontTestFinished
;
