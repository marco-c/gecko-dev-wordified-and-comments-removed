"
use
strict
"
;
Services
.
prefs
.
setBoolPref
(
"
security
.
allow_eval_with_system_principal
"
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
security
.
allow_eval_with_system_principal
"
)
;
}
)
;
async
function
testPrincipal
(
options
globalPrincipal
debuggeeHasXrays
)
{
const
{
debuggee
}
=
options
;
if
(
globalPrincipal
=
=
=
undefined
)
{
await
test
(
options
{
global
:
debuggee
subsumes
:
true
isOpaque
:
false
globalIsInvisible
:
false
}
)
;
return
;
}
const
debuggeePrincipal
=
Cu
.
getObjectPrincipal
(
debuggee
)
;
const
sameOrigin
=
debuggeePrincipal
.
origin
=
=
=
globalPrincipal
.
origin
;
const
subsumes
=
debuggeePrincipal
.
subsumes
(
globalPrincipal
)
;
for
(
const
globalHasXrays
of
[
true
false
]
)
{
const
isOpaque
=
subsumes
&
&
globalPrincipal
!
=
=
systemPrincipal
&
&
(
(
sameOrigin
&
&
debuggeeHasXrays
)
|
|
globalHasXrays
)
;
for
(
const
globalIsInvisible
of
[
true
false
]
)
{
let
global
=
Cu
.
Sandbox
(
globalPrincipal
{
wantXrays
:
globalHasXrays
invisibleToDebugger
:
globalIsInvisible
}
)
;
if
(
!
globalHasXrays
)
{
global
=
Cu
.
waiveXrays
(
global
)
;
}
await
test
(
options
{
global
subsumes
isOpaque
globalIsInvisible
}
)
;
}
}
}
async
function
test
(
{
threadFront
debuggee
}
testOptions
)
{
const
{
global
}
=
testOptions
;
const
packet
=
await
executeOnNextTickAndWaitForPause
(
eval_code
threadFront
)
;
const
[
proxyGrip
inheritsProxyGrip
inheritsProxy2Grip
]
=
packet
.
frame
.
arguments
;
check_proxy_grip
(
debuggee
testOptions
proxyGrip
)
;
const
proxyClient
=
threadFront
.
pauseGrip
(
proxyGrip
)
;
const
proxySlots
=
await
proxyClient
.
getProxySlots
(
)
;
check_proxy_slots
(
debuggee
testOptions
proxyGrip
proxySlots
)
;
const
proxyResponse
=
await
proxyClient
.
getPrototypeAndProperties
(
)
;
check_properties
(
testOptions
proxyResponse
.
ownProperties
true
false
)
;
check_prototype
(
debuggee
testOptions
proxyResponse
.
prototype
true
false
)
;
const
inheritsProxyClient
=
threadFront
.
pauseGrip
(
inheritsProxyGrip
)
;
const
inheritsProxyResponse
=
await
inheritsProxyClient
.
getPrototypeAndProperties
(
)
;
check_properties
(
testOptions
inheritsProxyResponse
.
ownProperties
false
false
)
;
check_prototype
(
debuggee
testOptions
inheritsProxyResponse
.
prototype
false
false
)
;
const
inheritsProxy2Client
=
threadFront
.
pauseGrip
(
inheritsProxy2Grip
)
;
const
inheritsProxy2Response
=
await
inheritsProxy2Client
.
getPrototypeAndProperties
(
)
;
check_properties
(
testOptions
inheritsProxy2Response
.
ownProperties
false
true
)
;
check_prototype
(
debuggee
testOptions
inheritsProxy2Response
.
prototype
false
true
)
;
strictEqual
(
global
.
trapDidRun
false
"
No
proxy
trap
did
run
.
"
)
;
await
threadFront
.
resume
(
)
;
function
eval_code
(
)
{
global
.
eval
(
var
trapDidRun
=
false
;
var
proxy
=
new
Proxy
(
{
}
new
Proxy
(
{
}
{
get
:
(
_
trap
)
=
>
{
trapDidRun
=
true
;
throw
new
Error
(
"
proxy
trap
'
"
+
trap
+
"
'
was
called
.
"
)
;
}
}
)
)
;
var
inheritsProxy
=
Object
.
create
(
proxy
{
x
:
{
value
:
1
}
}
)
;
)
;
const
data
=
Cu
.
createObjectIn
(
debuggee
{
defineAs
:
"
data
"
}
)
;
data
.
proxy
=
global
.
proxy
;
data
.
inheritsProxy
=
global
.
inheritsProxy
;
debuggee
.
eval
(
var
inheritsProxy2
=
Object
.
create
(
data
.
proxy
{
x
:
{
value
:
1
}
}
)
;
stopMe
(
data
.
proxy
data
.
inheritsProxy
inheritsProxy2
)
;
)
;
}
}
function
check_proxy_grip
(
debuggee
testOptions
grip
)
{
const
{
global
isOpaque
subsumes
globalIsInvisible
}
=
testOptions
;
const
{
preview
}
=
grip
;
if
(
global
=
=
=
debuggee
)
{
strictEqual
(
grip
.
class
"
Proxy
"
"
The
grip
has
a
Proxy
class
.
"
)
;
strictEqual
(
preview
.
ownPropertiesLength
2
"
The
preview
has
2
properties
.
"
)
;
const
props
=
preview
.
ownProperties
;
ok
(
props
[
"
<
target
>
"
]
.
value
"
<
target
>
contains
the
[
[
ProxyTarget
]
]
.
"
)
;
ok
(
props
[
"
<
handler
>
"
]
.
value
"
<
handler
>
contains
the
[
[
ProxyHandler
]
]
.
"
)
;
}
else
if
(
isOpaque
)
{
strictEqual
(
grip
.
class
"
Opaque
"
"
The
grip
has
an
Opaque
class
.
"
)
;
strictEqual
(
grip
.
ownPropertyLength
0
"
The
grip
has
no
properties
.
"
)
;
}
else
if
(
!
subsumes
)
{
strictEqual
(
grip
.
class
"
Restricted
"
"
The
grip
has
a
Restricted
class
.
"
)
;
strictEqual
(
grip
.
ownPropertyLength
undefined
"
The
grip
doesn
'
t
know
the
number
of
properties
.
"
)
;
}
else
if
(
globalIsInvisible
)
{
strictEqual
(
grip
.
class
"
InvisibleToDebugger
:
Object
"
"
The
grip
has
an
InvisibleToDebugger
class
.
"
)
;
ok
(
!
(
"
ownPropertyLength
"
in
grip
)
"
The
grip
doesn
'
t
know
the
number
of
properties
.
"
)
;
}
else
{
strictEqual
(
grip
.
class
"
Proxy
"
"
The
grip
has
a
Proxy
class
.
"
)
;
strictEqual
(
preview
.
ownPropertiesLength
0
"
The
preview
has
no
properties
.
"
)
;
ok
(
!
(
"
<
target
>
"
in
preview
)
"
The
preview
has
no
<
target
>
property
.
"
)
;
ok
(
!
(
"
<
handler
>
"
in
preview
)
"
The
preview
has
no
<
handler
>
property
.
"
)
;
}
}
function
check_proxy_slots
(
debuggee
testOptions
grip
proxySlots
)
{
const
{
global
}
=
testOptions
;
if
(
grip
.
class
!
=
=
"
Proxy
"
)
{
strictEqual
(
proxySlots
null
"
Slots
can
only
be
retrived
for
Proxy
grips
.
"
)
;
}
else
if
(
global
=
=
=
debuggee
)
{
const
{
proxyTarget
proxyHandler
}
=
proxySlots
;
strictEqual
(
proxyTarget
.
getGrip
(
)
.
type
"
object
"
"
There
is
a
[
[
ProxyTarget
]
]
grip
.
"
)
;
strictEqual
(
proxyHandler
.
getGrip
(
)
.
type
"
object
"
"
There
is
a
[
[
ProxyHandler
]
]
grip
.
"
)
;
}
else
{
const
{
proxyTarget
proxyHandler
}
=
proxySlots
;
strictEqual
(
proxyTarget
.
type
"
undefined
"
"
There
is
no
[
[
ProxyTarget
]
]
grip
.
"
)
;
strictEqual
(
proxyHandler
.
type
"
undefined
"
"
There
is
no
[
[
ProxyHandler
]
]
grip
.
"
)
;
}
}
function
check_properties
(
testOptions
props
isProxy
createdInDebuggee
)
{
const
{
subsumes
globalIsInvisible
}
=
testOptions
;
const
ownPropertiesLength
=
Reflect
.
ownKeys
(
props
)
.
length
;
if
(
createdInDebuggee
|
|
(
!
isProxy
&
&
subsumes
&
&
!
globalIsInvisible
)
)
{
strictEqual
(
ownPropertiesLength
1
"
1
own
property
was
retrieved
.
"
)
;
strictEqual
(
props
.
x
.
value
1
"
The
property
has
the
right
value
.
"
)
;
}
else
{
strictEqual
(
ownPropertiesLength
0
"
No
own
property
could
be
retrieved
.
"
)
;
}
}
function
check_prototype
(
debuggee
testOptions
proto
isProxy
createdInDebuggee
)
{
const
{
global
isOpaque
subsumes
globalIsInvisible
}
=
testOptions
;
if
(
isOpaque
&
&
!
globalIsInvisible
&
&
!
createdInDebuggee
)
{
strictEqual
(
proto
.
getGrip
(
)
.
class
"
Object
"
"
The
prototype
has
a
Object
class
.
"
)
;
}
else
if
(
isProxy
&
&
isOpaque
&
&
globalIsInvisible
)
{
strictEqual
(
proto
.
getGrip
(
)
.
class
"
InvisibleToDebugger
:
Object
"
"
The
prototype
has
an
InvisibleToDebugger
class
.
"
)
;
}
else
if
(
createdInDebuggee
|
|
(
!
isProxy
&
&
subsumes
&
&
!
globalIsInvisible
)
)
{
check_proxy_grip
(
debuggee
{
global
isOpaque
subsumes
globalIsInvisible
}
proto
.
getGrip
(
)
)
;
}
else
{
strictEqual
(
proto
.
type
"
null
"
"
The
prototype
is
null
.
"
)
;
}
}
function
createNullPrincipal
(
)
{
return
Cc
[
"
mozilla
.
org
/
nullprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
;
}
async
function
run_tests_in_principal
(
options
debuggeePrincipal
debuggeeHasXrays
)
{
const
{
debuggee
}
=
options
;
debuggee
.
eval
(
function
stopMe
(
arg1
arg2
)
{
debugger
;
}
.
toString
(
)
)
;
await
testPrincipal
(
options
undefined
debuggeeHasXrays
)
;
await
testPrincipal
(
options
systemPrincipal
debuggeeHasXrays
)
;
await
testPrincipal
(
options
createNullPrincipal
(
)
debuggeeHasXrays
)
;
if
(
debuggeePrincipal
!
=
systemPrincipal
)
{
await
testPrincipal
(
options
debuggeePrincipal
debuggeeHasXrays
)
;
}
}
for
(
const
principal
of
[
systemPrincipal
createNullPrincipal
(
)
]
)
{
for
(
const
wantXrays
of
[
true
false
]
)
{
add_task
(
threadFrontTest
(
options
=
>
run_tests_in_principal
(
options
principal
wantXrays
)
{
principal
wantXrays
}
)
)
;
}
}
