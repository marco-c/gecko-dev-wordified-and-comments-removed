"
use
strict
"
;
var
gDebuggee
;
add_task
(
threadFrontTest
(
async
(
{
threadFront
debuggee
}
)
=
>
{
gDebuggee
=
debuggee
;
await
testBreakpoint
(
threadFront
)
;
}
)
)
;
const
testBreakpoint
=
async
function
(
threadFront
)
{
evalSetupCode
(
)
;
evalTestCode
(
)
;
equal
(
gDebuggee
.
functions
.
length
1
"
The
test
code
should
have
added
a
function
.
"
)
;
const
source
=
await
getSource
(
threadFront
"
test
.
js
"
)
;
setBreakpoint
(
threadFront
{
sourceUrl
:
source
.
url
line
:
3
}
)
;
evalTestCode
(
)
;
equal
(
gDebuggee
.
functions
.
length
2
"
The
test
code
should
have
added
another
function
.
"
)
;
const
bpPause1
=
await
executeOnNextTickAndWaitForPause
(
gDebuggee
.
functions
[
0
]
threadFront
)
;
equal
(
bpPause1
.
why
.
type
"
breakpoint
"
"
Should
pause
because
of
hitting
our
breakpoint
(
not
debugger
statement
)
.
"
)
;
const
dbgStmtPause1
=
await
executeOnNextTickAndWaitForPause
(
(
)
=
>
resume
(
threadFront
)
threadFront
)
;
equal
(
dbgStmtPause1
.
why
.
type
"
debuggerStatement
"
"
And
we
should
hit
the
debugger
statement
after
the
pause
.
"
)
;
await
resume
(
threadFront
)
;
const
bpPause2
=
await
executeOnNextTickAndWaitForPause
(
gDebuggee
.
functions
[
1
]
threadFront
)
;
equal
(
bpPause2
.
why
.
type
"
breakpoint
"
"
Should
pause
because
of
hitting
our
breakpoint
(
not
debugger
statement
)
.
"
)
;
const
dbgStmtPause2
=
await
executeOnNextTickAndWaitForPause
(
(
)
=
>
resume
(
threadFront
)
threadFront
)
;
equal
(
dbgStmtPause2
.
why
.
type
"
debuggerStatement
"
"
And
we
should
hit
the
debugger
statement
after
the
pause
.
"
)
;
}
;
function
evalSetupCode
(
)
{
Cu
.
evalInSandbox
(
"
this
.
functions
=
[
]
;
"
gDebuggee
"
1
.
8
"
"
setup
.
js
"
1
)
;
}
function
evalTestCode
(
)
{
Cu
.
evalInSandbox
(
/
/
1
this
.
functions
.
push
(
function
(
)
{
/
/
2
var
setBreakpointHere
=
1
;
/
/
3
debugger
;
/
/
4
}
)
;
/
/
5
gDebuggee
"
1
.
8
"
"
test
.
js
"
1
)
;
}
