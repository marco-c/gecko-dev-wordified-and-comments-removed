"
use
strict
"
;
var
CC
=
Components
.
Constructor
;
const
_appInfo
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
jsm
"
_appInfo
)
;
_appInfo
.
updateAppInfo
(
{
ID
:
"
devtools
tests
.
mozilla
.
org
"
name
:
"
devtools
-
tests
"
version
:
"
1
"
platformVersion
:
"
42
"
crashReporter
:
true
}
)
;
const
{
require
loader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
const
{
worker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
worker
/
loader
.
js
"
{
}
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
{
NetUtil
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
Services
=
require
(
"
Services
"
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
debugger
.
log
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
debugger
.
remote
-
enabled
"
true
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
const
{
DebuggerServer
:
WorkerDebuggerServer
}
=
worker
.
require
(
"
devtools
/
server
/
main
"
)
;
const
{
DebuggerClient
}
=
require
(
"
devtools
/
shared
/
client
/
debugger
-
client
"
)
;
const
ObjectClient
=
require
(
"
devtools
/
shared
/
client
/
object
-
client
"
)
;
const
{
MemoryFront
}
=
require
(
"
devtools
/
shared
/
fronts
/
memory
"
)
;
const
{
addDebuggerToGlobal
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
"
{
}
)
;
const
systemPrincipal
=
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
;
var
{
loadSubScript
loadSubScriptWithOptions
}
=
Services
.
scriptloader
;
function
startupAddonsManager
(
)
{
const
profileDir
=
do_get_profile
(
)
.
clone
(
)
;
profileDir
.
append
(
"
extensions
"
)
;
const
internalManager
=
Cc
[
"
mozilla
.
org
/
addons
/
integration
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
.
QueryInterface
(
Ci
.
nsITimerCallback
)
;
internalManager
.
observe
(
null
"
addons
-
startup
"
null
)
;
}
function
makeMemoryActorTest
(
testGeneratorFunction
)
{
const
TEST_GLOBAL_NAME
=
"
test_MemoryActor
"
;
return
function
run_test
(
)
{
do_test_pending
(
)
;
startTestDebuggerServer
(
TEST_GLOBAL_NAME
)
.
then
(
client
=
>
{
DebuggerServer
.
registerModule
(
"
devtools
/
server
/
actors
/
heap
-
snapshot
-
file
"
{
prefix
:
"
heapSnapshotFile
"
constructor
:
"
HeapSnapshotFileActor
"
type
:
{
global
:
true
}
}
)
;
getTestTab
(
client
TEST_GLOBAL_NAME
function
(
tabForm
rootForm
)
{
if
(
!
tabForm
|
|
!
rootForm
)
{
ok
(
false
"
Could
not
attach
to
test
tab
:
"
+
TEST_GLOBAL_NAME
)
;
return
;
}
(
async
function
(
)
{
try
{
const
memoryFront
=
new
MemoryFront
(
client
tabForm
rootForm
)
;
await
memoryFront
.
attach
(
)
;
await
testGeneratorFunction
(
client
memoryFront
)
;
await
memoryFront
.
detach
(
)
;
}
catch
(
err
)
{
DevToolsUtils
.
reportException
(
"
makeMemoryActorTest
"
err
)
;
ok
(
false
"
Got
an
error
:
"
+
err
)
;
}
finishClient
(
client
)
;
}
)
(
)
;
}
)
;
}
)
;
}
;
}
function
makeFullRuntimeMemoryActorTest
(
testGeneratorFunction
)
{
return
function
run_test
(
)
{
do_test_pending
(
)
;
startTestDebuggerServer
(
"
test_MemoryActor
"
)
.
then
(
client
=
>
{
DebuggerServer
.
registerModule
(
"
devtools
/
server
/
actors
/
heap
-
snapshot
-
file
"
{
prefix
:
"
heapSnapshotFile
"
constructor
:
"
HeapSnapshotFileActor
"
type
:
{
global
:
true
}
}
)
;
getParentProcessActors
(
client
)
.
then
(
function
(
form
)
{
if
(
!
form
)
{
ok
(
false
"
Could
not
attach
to
chrome
actors
"
)
;
return
;
}
(
async
function
(
)
{
try
{
const
rootForm
=
await
listTabs
(
client
)
;
const
memoryFront
=
new
MemoryFront
(
client
form
rootForm
)
;
await
memoryFront
.
attach
(
)
;
await
testGeneratorFunction
(
client
memoryFront
)
;
await
memoryFront
.
detach
(
)
;
}
catch
(
err
)
{
DevToolsUtils
.
reportException
(
"
makeMemoryActorTest
"
err
)
;
ok
(
false
"
Got
an
error
:
"
+
err
)
;
}
finishClient
(
client
)
;
}
)
(
)
;
}
)
;
}
)
;
}
;
}
function
createTestGlobal
(
name
)
{
const
sandbox
=
Cu
.
Sandbox
(
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
)
;
sandbox
.
__name
=
name
;
return
sandbox
;
}
function
connect
(
client
)
{
dump
(
"
Connecting
client
.
\
n
"
)
;
return
client
.
connect
(
)
;
}
function
close
(
client
)
{
dump
(
"
Closing
client
.
\
n
"
)
;
return
client
.
close
(
)
;
}
function
listTabs
(
client
)
{
dump
(
"
Listing
tabs
.
\
n
"
)
;
return
client
.
listTabs
(
)
;
}
function
findTab
(
tabs
title
)
{
dump
(
"
Finding
tab
with
title
'
"
+
title
+
"
'
.
\
n
"
)
;
for
(
const
tab
of
tabs
)
{
if
(
tab
.
title
=
=
=
title
)
{
return
tab
;
}
}
return
null
;
}
function
attachTab
(
client
tab
)
{
dump
(
"
Attaching
to
tab
with
title
'
"
+
tab
.
title
+
"
'
.
\
n
"
)
;
return
client
.
attachTab
(
tab
.
actor
)
;
}
function
waitForNewSource
(
threadClient
url
)
{
dump
(
"
Waiting
for
new
source
with
url
'
"
+
url
+
"
'
.
\
n
"
)
;
return
waitForEvent
(
threadClient
"
newSource
"
function
(
packet
)
{
return
packet
.
source
.
url
=
=
=
url
;
}
)
;
}
function
attachThread
(
tabClient
options
=
{
}
)
{
dump
(
"
Attaching
to
thread
.
\
n
"
)
;
return
tabClient
.
attachThread
(
options
)
;
}
function
resume
(
threadClient
)
{
dump
(
"
Resuming
thread
.
\
n
"
)
;
return
threadClient
.
resume
(
)
;
}
function
getSources
(
threadClient
)
{
dump
(
"
Getting
sources
.
\
n
"
)
;
return
threadClient
.
getSources
(
)
;
}
function
findSource
(
sources
url
)
{
dump
(
"
Finding
source
with
url
'
"
+
url
+
"
'
.
\
n
"
)
;
for
(
const
source
of
sources
)
{
if
(
source
.
url
=
=
=
url
)
{
return
source
;
}
}
return
null
;
}
function
waitForPause
(
threadClient
)
{
dump
(
"
Waiting
for
pause
.
\
n
"
)
;
return
waitForEvent
(
threadClient
"
paused
"
)
;
}
function
waitForProperty
(
dbg
property
)
{
return
new
Promise
(
resolve
=
>
{
Object
.
defineProperty
(
dbg
property
{
set
(
newValue
)
{
resolve
(
newValue
)
;
}
}
)
;
}
)
;
}
function
setBreakpoint
(
sourceClient
location
)
{
dump
(
"
Setting
breakpoint
.
\
n
"
)
;
return
sourceClient
.
setBreakpoint
(
location
)
;
}
function
getPrototypeAndProperties
(
objClient
)
{
dump
(
"
getting
prototype
and
properties
.
\
n
"
)
;
return
new
Promise
(
resolve
=
>
{
objClient
.
getPrototypeAndProperties
(
response
=
>
resolve
(
response
)
)
;
}
)
;
}
function
dumpn
(
msg
)
{
dump
(
"
DBG
-
TEST
:
"
+
msg
+
"
\
n
"
)
;
}
function
testExceptionHook
(
ex
)
{
try
{
do_report_unexpected_exception
(
ex
)
;
}
catch
(
e
)
{
return
{
throw
:
e
}
;
}
return
undefined
;
}
function
scriptErrorFlagsToKind
(
flags
)
{
let
kind
;
if
(
flags
&
Ci
.
nsIScriptError
.
warningFlag
)
{
kind
=
"
warning
"
;
}
if
(
flags
&
Ci
.
nsIScriptError
.
exceptionFlag
)
{
kind
=
"
exception
"
;
}
else
{
kind
=
"
error
"
;
}
if
(
flags
&
Ci
.
nsIScriptError
.
strictFlag
)
{
kind
=
"
strict
"
+
kind
;
}
return
kind
;
}
var
errorCount
=
0
;
var
listener
=
{
observe
:
function
(
message
)
{
try
{
let
string
;
errorCount
+
+
;
try
{
message
.
QueryInterface
(
Ci
.
nsIScriptError
)
;
dumpn
(
message
.
sourceName
+
"
:
"
+
message
.
lineNumber
+
"
:
"
+
scriptErrorFlagsToKind
(
message
.
flags
)
+
"
:
"
+
message
.
errorMessage
)
;
string
=
message
.
errorMessage
;
}
catch
(
e1
)
{
try
{
string
=
"
"
+
message
.
message
;
}
catch
(
e2
)
{
string
=
"
<
error
converting
error
message
to
string
>
"
;
}
}
while
(
DebuggerServer
&
&
DebuggerServer
.
xpcInspector
&
&
DebuggerServer
.
xpcInspector
.
eventLoopNestLevel
>
0
)
{
DebuggerServer
.
xpcInspector
.
exitNestedEventLoop
(
)
;
}
dumpn
(
"
head_dbg
.
js
observed
a
console
message
:
"
+
string
)
;
}
catch
(
_
)
{
}
}
}
;
Services
.
console
.
registerListener
(
listener
)
;
function
testGlobal
(
name
)
{
const
sandbox
=
Cu
.
Sandbox
(
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
)
;
sandbox
.
__name
=
name
;
return
sandbox
;
}
function
addTestGlobal
(
name
server
=
DebuggerServer
)
{
const
global
=
testGlobal
(
name
)
;
server
.
addTestGlobal
(
global
)
;
return
global
;
}
function
getTestTab
(
client
title
callback
)
{
client
.
listTabs
(
)
.
then
(
function
(
response
)
{
for
(
const
tab
of
response
.
tabs
)
{
if
(
tab
.
title
=
=
=
title
)
{
callback
(
tab
response
)
;
return
;
}
}
callback
(
null
)
;
}
)
;
}
function
attachTestTab
(
client
title
callback
)
{
getTestTab
(
client
title
function
(
tab
)
{
client
.
attachTab
(
tab
.
actor
)
.
then
(
(
[
response
tabClient
]
)
=
>
{
callback
(
response
tabClient
)
;
}
)
;
}
)
;
}
function
attachTestThread
(
client
title
callback
)
{
attachTestTab
(
client
title
function
(
tabResponse
tabClient
)
{
function
onAttach
(
[
response
threadClient
]
)
{
callback
(
response
tabClient
threadClient
tabResponse
)
;
}
tabClient
.
attachThread
(
{
useSourceMaps
:
true
autoBlackBox
:
true
}
)
.
then
(
onAttach
)
;
}
)
;
}
function
attachTestTabAndResume
(
client
title
callback
=
(
)
=
>
{
}
)
{
return
new
Promise
(
(
resolve
)
=
>
{
attachTestThread
(
client
title
function
(
response
tabClient
threadClient
)
{
threadClient
.
resume
(
function
(
response
)
{
callback
(
response
tabClient
threadClient
)
;
resolve
(
[
response
tabClient
threadClient
]
)
;
}
)
;
}
)
;
}
)
;
}
function
initTestDebuggerServer
(
server
=
DebuggerServer
)
{
if
(
server
=
=
=
WorkerDebuggerServer
)
{
const
{
createRootActor
}
=
worker
.
require
(
"
xpcshell
-
test
/
testactors
"
)
;
server
.
setRootActor
(
createRootActor
)
;
}
else
{
const
{
createRootActor
}
=
require
(
"
xpcshell
-
test
/
testactors
"
)
;
server
.
setRootActor
(
createRootActor
)
;
}
server
.
init
(
function
(
)
{
return
true
;
}
)
;
}
function
startTestDebuggerServer
(
title
server
=
DebuggerServer
)
{
initTestDebuggerServer
(
server
)
;
addTestGlobal
(
title
)
;
DebuggerServer
.
registerActors
(
{
target
:
true
}
)
;
const
transport
=
DebuggerServer
.
connectPipe
(
)
;
const
client
=
new
DebuggerClient
(
transport
)
;
return
connect
(
client
)
.
then
(
(
)
=
>
client
)
;
}
function
finishClient
(
client
)
{
client
.
close
(
function
(
)
{
DebuggerServer
.
destroy
(
)
;
do_test_finished
(
)
;
}
)
;
}
function
get_parent_process_actors
(
callback
)
{
DebuggerServer
.
init
(
)
;
DebuggerServer
.
registerAllActors
(
)
;
DebuggerServer
.
allowChromeProcess
=
true
;
const
client
=
new
DebuggerClient
(
DebuggerServer
.
connectPipe
(
)
)
;
client
.
connect
(
)
.
then
(
(
)
=
>
client
.
getProcess
(
)
)
.
then
(
response
=
>
{
callback
(
client
response
.
form
)
;
}
)
;
}
function
getParentProcessActors
(
client
server
=
DebuggerServer
)
{
server
.
allowChromeProcess
=
true
;
return
client
.
getProcess
(
)
.
then
(
response
=
>
response
.
form
)
;
}
function
getFileUrl
(
name
allowMissing
=
false
)
{
const
file
=
do_get_file
(
name
allowMissing
)
;
return
Services
.
io
.
newFileURI
(
file
)
.
spec
;
}
function
getFilePath
(
name
allowMissing
=
false
usePlatformPathSeparator
=
false
)
{
const
file
=
do_get_file
(
name
allowMissing
)
;
let
path
=
Services
.
io
.
newFileURI
(
file
)
.
spec
;
let
filePrePath
=
"
file
:
/
/
"
;
if
(
"
nsILocalFileWin
"
in
Ci
&
&
file
instanceof
Ci
.
nsILocalFileWin
)
{
filePrePath
+
=
"
/
"
;
}
path
=
path
.
slice
(
filePrePath
.
length
)
;
if
(
usePlatformPathSeparator
&
&
path
.
match
(
/
^
\
w
:
/
)
)
{
path
=
path
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
return
path
;
}
function
readFile
(
fileName
)
{
const
f
=
do_get_file
(
fileName
)
;
const
s
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
s
.
init
(
f
-
1
-
1
false
)
;
try
{
return
NetUtil
.
readInputStreamToString
(
s
s
.
available
(
)
)
;
}
finally
{
s
.
close
(
)
;
}
}
function
writeFile
(
fileName
content
)
{
const
file
=
do_get_file
(
fileName
true
)
;
const
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
stream
.
init
(
file
-
1
-
1
0
)
;
try
{
do
{
const
numWritten
=
stream
.
write
(
content
content
.
length
)
;
content
=
content
.
slice
(
numWritten
)
;
}
while
(
content
.
length
>
0
)
;
}
finally
{
stream
.
close
(
)
;
}
}
function
connectPipeTracing
(
)
{
return
new
TracingTransport
(
DebuggerServer
.
connectPipe
(
)
)
;
}
function
TracingTransport
(
childTransport
)
{
this
.
hooks
=
null
;
this
.
child
=
childTransport
;
this
.
child
.
hooks
=
this
;
this
.
expectations
=
[
]
;
this
.
packets
=
[
]
;
this
.
checkIndex
=
0
;
}
TracingTransport
.
prototype
=
{
normalize
:
function
(
packet
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
packet
(
key
value
)
=
>
{
if
(
key
=
=
=
"
to
"
|
|
key
=
=
=
"
from
"
|
|
key
=
=
=
"
actor
"
)
{
return
"
<
actorid
>
"
;
}
return
value
;
}
)
)
;
}
send
:
function
(
packet
)
{
this
.
packets
.
push
(
{
type
:
"
sent
"
packet
:
this
.
normalize
(
packet
)
}
)
;
return
this
.
child
.
send
(
packet
)
;
}
close
:
function
(
)
{
return
this
.
child
.
close
(
)
;
}
ready
:
function
(
)
{
return
this
.
child
.
ready
(
)
;
}
onPacket
:
function
(
packet
)
{
this
.
packets
.
push
(
{
type
:
"
received
"
packet
:
this
.
normalize
(
packet
)
}
)
;
this
.
hooks
.
onPacket
(
packet
)
;
}
onClosed
:
function
(
)
{
this
.
hooks
.
onClosed
(
)
;
}
expectSend
:
function
(
expected
)
{
const
packet
=
this
.
packets
[
this
.
checkIndex
+
+
]
;
Assert
.
equal
(
packet
.
type
"
sent
"
)
;
deepEqual
(
packet
.
packet
this
.
normalize
(
expected
)
)
;
}
expectReceive
:
function
(
expected
)
{
const
packet
=
this
.
packets
[
this
.
checkIndex
+
+
]
;
Assert
.
equal
(
packet
.
type
"
received
"
)
;
deepEqual
(
packet
.
packet
this
.
normalize
(
expected
)
)
;
}
dumpLog
:
function
(
)
{
for
(
const
entry
of
this
.
packets
)
{
if
(
entry
.
type
=
=
=
"
sent
"
)
{
dumpn
(
"
trace
.
expectSend
(
"
+
entry
.
packet
+
"
)
;
"
)
;
}
else
{
dumpn
(
"
trace
.
expectReceive
(
"
+
entry
.
packet
+
"
)
;
"
)
;
}
}
}
}
;
function
StubTransport
(
)
{
}
StubTransport
.
prototype
.
ready
=
function
(
)
{
}
;
StubTransport
.
prototype
.
send
=
function
(
)
{
}
;
StubTransport
.
prototype
.
close
=
function
(
)
{
}
;
const
Async
=
target
=
>
new
Proxy
(
target
Async
)
;
Async
.
get
=
(
target
name
)
=
>
typeof
(
target
[
name
]
)
=
=
=
"
function
"
?
asyncall
.
bind
(
null
target
[
name
]
target
)
:
target
[
name
]
;
const
asyncall
=
(
fn
self
.
.
.
args
)
=
>
new
Promise
(
(
.
.
.
etc
)
=
>
fn
.
call
(
self
.
.
.
args
.
.
.
etc
)
)
;
const
Test
=
task
=
>
(
)
=
>
{
add_task
(
task
)
;
run_next_test
(
)
;
}
;
const
assert
=
Assert
.
ok
.
bind
(
Assert
)
;
function
waitForEvent
(
client
type
predicate
)
{
if
(
!
predicate
)
{
return
client
.
addOneTimeListener
(
type
)
;
}
return
new
Promise
(
function
(
resolve
)
{
function
listener
(
type
packet
)
{
if
(
!
predicate
(
packet
)
)
{
return
;
}
client
.
removeListener
(
listener
)
;
resolve
(
packet
)
;
}
client
.
addListener
(
type
listener
)
;
}
)
;
}
function
executeOnNextTickAndWaitForPause
(
action
client
)
{
const
paused
=
waitForPause
(
client
)
;
executeSoon
(
action
)
;
return
paused
;
}
function
evalCallback
(
debuggeeGlobal
func
)
{
Cu
.
evalInSandbox
(
"
(
"
+
func
+
"
)
(
)
"
debuggeeGlobal
"
1
.
8
"
"
test
.
js
"
1
)
;
}
function
interrupt
(
threadClient
)
{
dumpn
(
"
Interrupting
.
"
)
;
return
threadClient
.
interrupt
(
)
;
}
function
resumeAndWaitForPause
(
client
threadClient
)
{
const
paused
=
waitForPause
(
client
)
;
return
resume
(
threadClient
)
.
then
(
(
)
=
>
paused
)
;
}
function
stepIn
(
client
threadClient
)
{
dumpn
(
"
Stepping
in
.
"
)
;
const
paused
=
waitForPause
(
client
)
;
return
threadClient
.
stepIn
(
)
.
then
(
(
)
=
>
paused
)
;
}
function
stepOver
(
client
threadClient
)
{
dumpn
(
"
Stepping
over
.
"
)
;
return
threadClient
.
stepOver
(
)
.
then
(
(
)
=
>
waitForPause
(
client
)
)
;
}
function
stepOut
(
client
threadClient
)
{
dumpn
(
"
Stepping
out
.
"
)
;
return
threadClient
.
stepOut
(
)
.
then
(
(
)
=
>
waitForPause
(
client
)
)
;
}
function
getFrames
(
threadClient
first
count
)
{
dumpn
(
"
Getting
frames
.
"
)
;
return
threadClient
.
getFrames
(
first
count
)
;
}
function
blackBox
(
sourceClient
)
{
dumpn
(
"
Black
boxing
source
:
"
+
sourceClient
.
actor
)
;
return
sourceClient
.
blackBox
(
)
;
}
function
unBlackBox
(
sourceClient
)
{
dumpn
(
"
Un
-
black
boxing
source
:
"
+
sourceClient
.
actor
)
;
return
sourceClient
.
unblackBox
(
)
;
}
function
getSourceContent
(
sourceClient
)
{
dumpn
(
"
Getting
source
content
for
"
+
sourceClient
.
actor
)
;
return
sourceClient
.
source
(
)
;
}
function
getSource
(
threadClient
url
)
{
const
deferred
=
defer
(
)
;
threadClient
.
getSources
(
(
res
)
=
>
{
const
source
=
res
.
sources
.
filter
(
function
(
s
)
{
return
s
.
url
=
=
=
url
;
}
)
;
if
(
source
.
length
)
{
deferred
.
resolve
(
threadClient
.
source
(
source
[
0
]
)
)
;
}
else
{
deferred
.
reject
(
new
Error
(
"
source
not
found
"
)
)
;
}
}
)
;
return
deferred
.
promise
;
}
function
reload
(
tabClient
)
{
const
deferred
=
defer
(
)
;
tabClient
.
_reload
(
{
}
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
function
getInflatedStackLocations
(
thread
sample
)
{
const
stackTable
=
thread
.
stackTable
;
const
frameTable
=
thread
.
frameTable
;
const
stringTable
=
thread
.
stringTable
;
const
SAMPLE_STACK_SLOT
=
thread
.
samples
.
schema
.
stack
;
const
STACK_PREFIX_SLOT
=
stackTable
.
schema
.
prefix
;
const
STACK_FRAME_SLOT
=
stackTable
.
schema
.
frame
;
const
FRAME_LOCATION_SLOT
=
frameTable
.
schema
.
location
;
let
stackIndex
=
sample
[
SAMPLE_STACK_SLOT
]
;
const
locations
=
[
]
;
while
(
stackIndex
!
=
=
null
)
{
const
stackEntry
=
stackTable
.
data
[
stackIndex
]
;
const
frame
=
frameTable
.
data
[
stackEntry
[
STACK_FRAME_SLOT
]
]
;
locations
.
push
(
stringTable
[
frame
[
FRAME_LOCATION_SLOT
]
]
)
;
stackIndex
=
stackEntry
[
STACK_PREFIX_SLOT
]
;
}
return
locations
.
reverse
(
)
;
}
