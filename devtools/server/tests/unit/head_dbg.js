"
use
strict
"
;
var
CC
=
Components
.
Constructor
;
const
_appInfo
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
jsm
"
_appInfo
)
;
_appInfo
.
updateAppInfo
(
{
ID
:
"
devtools
tests
.
mozilla
.
org
"
name
:
"
devtools
-
tests
"
version
:
"
1
"
platformVersion
:
"
42
"
crashReporter
:
true
}
)
;
const
{
require
loader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
const
{
worker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
worker
/
loader
.
js
"
{
}
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
{
NetUtil
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
Services
=
require
(
"
Services
"
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
debugger
.
log
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
debugger
.
remote
-
enabled
"
true
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
ActorRegistry
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
actor
-
registry
"
)
;
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
const
{
DebuggerServer
:
WorkerDebuggerServer
}
=
worker
.
require
(
"
devtools
/
server
/
main
"
)
;
const
{
DebuggerClient
}
=
require
(
"
devtools
/
shared
/
client
/
debugger
-
client
"
)
;
const
ObjectClient
=
require
(
"
devtools
/
shared
/
client
/
object
-
client
"
)
;
const
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
const
{
addDebuggerToGlobal
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
"
{
}
)
;
const
systemPrincipal
=
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
;
var
{
loadSubScript
loadSubScriptWithOptions
}
=
Services
.
scriptloader
;
function
startupAddonsManager
(
)
{
const
profileDir
=
do_get_profile
(
)
.
clone
(
)
;
profileDir
.
append
(
"
extensions
"
)
;
const
internalManager
=
Cc
[
"
mozilla
.
org
/
addons
/
integration
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
.
QueryInterface
(
Ci
.
nsITimerCallback
)
;
internalManager
.
observe
(
null
"
addons
-
startup
"
null
)
;
}
async
function
createTargetForFakeTab
(
title
)
{
const
client
=
await
startTestDebuggerServer
(
title
)
;
const
tabs
=
await
listTabs
(
client
)
;
const
front
=
findTab
(
tabs
title
)
;
const
options
=
{
activeTab
:
front
client
chrome
:
false
}
;
const
target
=
await
TargetFactory
.
forRemoteTab
(
options
)
;
return
target
;
}
async
function
createTargetForMainProcess
(
)
{
DebuggerServer
.
init
(
)
;
DebuggerServer
.
registerAllActors
(
)
;
DebuggerServer
.
allowChromeProcess
=
true
;
const
client
=
new
DebuggerClient
(
DebuggerServer
.
connectPipe
(
)
)
;
await
client
.
connect
(
)
;
const
front
=
await
client
.
mainRoot
.
getMainProcess
(
)
;
const
options
=
{
activeTab
:
front
client
chrome
:
true
}
;
const
target
=
await
TargetFactory
.
forRemoteTab
(
options
)
;
return
target
;
}
async
function
createTabMemoryFront
(
)
{
const
target
=
await
createTargetForFakeTab
(
"
test_memory
"
)
;
DebuggerServer
.
registerActors
(
{
browser
:
true
}
)
;
const
memoryFront
=
await
target
.
getFront
(
"
memory
"
)
;
await
memoryFront
.
attach
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
memoryFront
.
detach
(
)
;
await
target
.
client
.
close
(
)
;
}
)
;
return
{
target
memoryFront
}
;
}
async
function
createTabPromisesFront
(
)
{
const
title
=
"
test_promises
"
;
const
target
=
await
createTargetForFakeTab
(
title
)
;
const
debuggee
=
DebuggerServer
.
getTestGlobal
(
title
)
;
const
promisesFront
=
await
target
.
getFront
(
"
promises
"
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
target
.
client
.
close
(
)
;
}
)
;
return
{
debuggee
client
:
target
.
client
promisesFront
}
;
}
async
function
createMainProcessPromisesFront
(
)
{
const
target
=
await
createTargetForMainProcess
(
)
;
const
promisesFront
=
await
target
.
getFront
(
"
promises
"
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
target
.
client
.
close
(
)
;
}
)
;
return
{
client
:
target
.
client
promisesFront
}
;
}
async
function
createMainProcessMemoryFront
(
)
{
const
target
=
await
createTargetForMainProcess
(
)
;
const
memoryFront
=
await
target
.
getFront
(
"
memory
"
)
;
await
memoryFront
.
attach
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
await
memoryFront
.
detach
(
)
;
await
target
.
client
.
close
(
)
;
}
)
;
return
{
client
:
target
.
client
memoryFront
}
;
}
function
createTestGlobal
(
name
)
{
const
sandbox
=
Cu
.
Sandbox
(
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
)
;
sandbox
.
__name
=
name
;
return
sandbox
;
}
function
connect
(
client
)
{
dump
(
"
Connecting
client
.
\
n
"
)
;
return
client
.
connect
(
)
;
}
function
close
(
client
)
{
dump
(
"
Closing
client
.
\
n
"
)
;
return
client
.
close
(
)
;
}
function
listTabs
(
client
)
{
dump
(
"
Listing
tabs
.
\
n
"
)
;
return
client
.
mainRoot
.
listTabs
(
)
;
}
function
findTab
(
tabs
title
)
{
dump
(
"
Finding
tab
with
title
'
"
+
title
+
"
'
.
\
n
"
)
;
for
(
const
tab
of
tabs
)
{
if
(
tab
.
title
=
=
=
title
)
{
return
tab
;
}
}
return
null
;
}
function
attachTarget
(
client
tab
)
{
dump
(
"
Attaching
to
tab
with
title
'
"
+
tab
.
title
+
"
'
.
\
n
"
)
;
return
client
.
attachTarget
(
tab
)
;
}
function
waitForNewSource
(
threadClient
url
)
{
dump
(
"
Waiting
for
new
source
with
url
'
"
+
url
+
"
'
.
\
n
"
)
;
return
waitForEvent
(
threadClient
"
newSource
"
function
(
packet
)
{
return
packet
.
source
.
url
=
=
=
url
;
}
)
;
}
function
attachThread
(
targetFront
options
=
{
}
)
{
dump
(
"
Attaching
to
thread
.
\
n
"
)
;
return
targetFront
.
attachThread
(
options
)
;
}
function
resume
(
threadClient
)
{
dump
(
"
Resuming
thread
.
\
n
"
)
;
return
threadClient
.
resume
(
)
;
}
function
getSources
(
threadClient
)
{
dump
(
"
Getting
sources
.
\
n
"
)
;
return
threadClient
.
getSources
(
)
;
}
function
findSource
(
sources
url
)
{
dump
(
"
Finding
source
with
url
'
"
+
url
+
"
'
.
\
n
"
)
;
for
(
const
source
of
sources
)
{
if
(
source
.
url
=
=
=
url
)
{
return
source
;
}
}
return
null
;
}
function
waitForPause
(
threadClient
)
{
dump
(
"
Waiting
for
pause
.
\
n
"
)
;
return
waitForEvent
(
threadClient
"
paused
"
)
;
}
function
waitForProperty
(
dbg
property
)
{
return
new
Promise
(
resolve
=
>
{
Object
.
defineProperty
(
dbg
property
{
set
(
newValue
)
{
resolve
(
newValue
)
;
}
}
)
;
}
)
;
}
function
setBreakpoint
(
sourceClient
location
)
{
dump
(
"
Setting
breakpoint
.
\
n
"
)
;
return
sourceClient
.
setBreakpoint
(
location
)
;
}
function
getPrototypeAndProperties
(
objClient
)
{
dump
(
"
getting
prototype
and
properties
.
\
n
"
)
;
return
new
Promise
(
resolve
=
>
{
objClient
.
getPrototypeAndProperties
(
response
=
>
resolve
(
response
)
)
;
}
)
;
}
function
dumpn
(
msg
)
{
dump
(
"
DBG
-
TEST
:
"
+
msg
+
"
\
n
"
)
;
}
function
testExceptionHook
(
ex
)
{
try
{
do_report_unexpected_exception
(
ex
)
;
}
catch
(
e
)
{
return
{
throw
:
e
}
;
}
return
undefined
;
}
function
scriptErrorFlagsToKind
(
flags
)
{
let
kind
;
if
(
flags
&
Ci
.
nsIScriptError
.
warningFlag
)
{
kind
=
"
warning
"
;
}
if
(
flags
&
Ci
.
nsIScriptError
.
exceptionFlag
)
{
kind
=
"
exception
"
;
}
else
{
kind
=
"
error
"
;
}
if
(
flags
&
Ci
.
nsIScriptError
.
strictFlag
)
{
kind
=
"
strict
"
+
kind
;
}
return
kind
;
}
var
errorCount
=
0
;
var
listener
=
{
observe
:
function
(
message
)
{
try
{
let
string
;
errorCount
+
+
;
try
{
message
.
QueryInterface
(
Ci
.
nsIScriptError
)
;
dumpn
(
message
.
sourceName
+
"
:
"
+
message
.
lineNumber
+
"
:
"
+
scriptErrorFlagsToKind
(
message
.
flags
)
+
"
:
"
+
message
.
errorMessage
)
;
string
=
message
.
errorMessage
;
}
catch
(
e1
)
{
try
{
string
=
"
"
+
message
.
message
;
}
catch
(
e2
)
{
string
=
"
<
error
converting
error
message
to
string
>
"
;
}
}
while
(
DebuggerServer
&
&
DebuggerServer
.
xpcInspector
&
&
DebuggerServer
.
xpcInspector
.
eventLoopNestLevel
>
0
)
{
DebuggerServer
.
xpcInspector
.
exitNestedEventLoop
(
)
;
}
dumpn
(
"
head_dbg
.
js
observed
a
console
message
:
"
+
string
)
;
}
catch
(
_
)
{
}
}
}
;
Services
.
console
.
registerListener
(
listener
)
;
function
testGlobal
(
name
)
{
const
sandbox
=
Cu
.
Sandbox
(
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
)
;
sandbox
.
__name
=
name
;
return
sandbox
;
}
function
addTestGlobal
(
name
server
=
DebuggerServer
)
{
const
global
=
testGlobal
(
name
)
;
server
.
addTestGlobal
(
global
)
;
return
global
;
}
async
function
getTestTab
(
client
title
)
{
const
tabs
=
await
client
.
mainRoot
.
listTabs
(
)
;
for
(
const
tab
of
tabs
)
{
if
(
tab
.
title
=
=
=
title
)
{
return
tab
;
}
}
return
null
;
}
async
function
attachTestTab
(
client
title
)
{
const
targetFront
=
await
getTestTab
(
client
title
)
;
await
targetFront
.
attach
(
)
;
const
response
=
await
targetFront
.
attach
(
)
;
Assert
.
equal
(
response
.
type
"
tabAttached
"
)
;
Assert
.
ok
(
typeof
response
.
threadActor
=
=
=
"
string
"
)
;
return
targetFront
;
}
async
function
attachTestThread
(
client
title
callback
=
(
)
=
>
{
}
)
{
const
targetFront
=
await
attachTestTab
(
client
title
)
;
const
[
response
threadClient
]
=
await
targetFront
.
attachThread
(
{
autoBlackBox
:
true
}
)
;
Assert
.
equal
(
threadClient
.
state
"
paused
"
"
Thread
client
is
paused
"
)
;
Assert
.
equal
(
response
.
type
"
paused
"
)
;
Assert
.
ok
(
"
why
"
in
response
)
;
Assert
.
equal
(
response
.
why
.
type
"
attached
"
)
;
callback
(
response
targetFront
threadClient
)
;
return
{
targetFront
threadClient
}
;
}
async
function
attachTestTabAndResume
(
client
title
callback
=
(
)
=
>
{
}
)
{
const
{
targetFront
threadClient
}
=
await
attachTestThread
(
client
title
)
;
const
response
=
await
threadClient
.
resume
(
)
;
Assert
.
equal
(
response
.
type
"
resumed
"
)
;
callback
(
response
targetFront
threadClient
)
;
return
{
targetFront
threadClient
}
;
}
function
initTestDebuggerServer
(
server
=
DebuggerServer
)
{
if
(
server
=
=
=
WorkerDebuggerServer
)
{
const
{
createRootActor
}
=
worker
.
require
(
"
xpcshell
-
test
/
testactors
"
)
;
server
.
setRootActor
(
createRootActor
)
;
}
else
{
const
{
createRootActor
}
=
require
(
"
xpcshell
-
test
/
testactors
"
)
;
server
.
setRootActor
(
createRootActor
)
;
}
server
.
init
(
function
(
)
{
return
true
;
}
)
;
}
async
function
startTestDebuggerServer
(
title
server
=
DebuggerServer
)
{
initTestDebuggerServer
(
server
)
;
addTestGlobal
(
title
)
;
DebuggerServer
.
registerActors
(
{
target
:
true
}
)
;
const
transport
=
DebuggerServer
.
connectPipe
(
)
;
const
client
=
new
DebuggerClient
(
transport
)
;
await
connect
(
client
)
;
return
client
;
}
async
function
finishClient
(
client
)
{
await
client
.
close
(
)
;
DebuggerServer
.
destroy
(
)
;
do_test_finished
(
)
;
}
function
getFileUrl
(
name
allowMissing
=
false
)
{
const
file
=
do_get_file
(
name
allowMissing
)
;
return
Services
.
io
.
newFileURI
(
file
)
.
spec
;
}
function
getFilePath
(
name
allowMissing
=
false
usePlatformPathSeparator
=
false
)
{
const
file
=
do_get_file
(
name
allowMissing
)
;
let
path
=
Services
.
io
.
newFileURI
(
file
)
.
spec
;
let
filePrePath
=
"
file
:
/
/
"
;
if
(
"
nsILocalFileWin
"
in
Ci
&
&
file
instanceof
Ci
.
nsILocalFileWin
)
{
filePrePath
+
=
"
/
"
;
}
path
=
path
.
slice
(
filePrePath
.
length
)
;
if
(
usePlatformPathSeparator
&
&
path
.
match
(
/
^
\
w
:
/
)
)
{
path
=
path
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
return
path
;
}
function
readFile
(
fileName
)
{
const
f
=
do_get_file
(
fileName
)
;
const
s
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
s
.
init
(
f
-
1
-
1
false
)
;
try
{
return
NetUtil
.
readInputStreamToString
(
s
s
.
available
(
)
)
;
}
finally
{
s
.
close
(
)
;
}
}
function
writeFile
(
fileName
content
)
{
const
file
=
do_get_file
(
fileName
true
)
;
const
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
stream
.
init
(
file
-
1
-
1
0
)
;
try
{
do
{
const
numWritten
=
stream
.
write
(
content
content
.
length
)
;
content
=
content
.
slice
(
numWritten
)
;
}
while
(
content
.
length
>
0
)
;
}
finally
{
stream
.
close
(
)
;
}
}
function
connectPipeTracing
(
)
{
return
new
TracingTransport
(
DebuggerServer
.
connectPipe
(
)
)
;
}
function
TracingTransport
(
childTransport
)
{
this
.
hooks
=
null
;
this
.
child
=
childTransport
;
this
.
child
.
hooks
=
this
;
this
.
expectations
=
[
]
;
this
.
packets
=
[
]
;
this
.
checkIndex
=
0
;
}
TracingTransport
.
prototype
=
{
normalize
:
function
(
packet
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
packet
(
key
value
)
=
>
{
if
(
key
=
=
=
"
to
"
|
|
key
=
=
=
"
from
"
|
|
key
=
=
=
"
actor
"
)
{
return
"
<
actorid
>
"
;
}
return
value
;
}
)
)
;
}
send
:
function
(
packet
)
{
this
.
packets
.
push
(
{
type
:
"
sent
"
packet
:
this
.
normalize
(
packet
)
}
)
;
return
this
.
child
.
send
(
packet
)
;
}
close
:
function
(
)
{
return
this
.
child
.
close
(
)
;
}
ready
:
function
(
)
{
return
this
.
child
.
ready
(
)
;
}
onPacket
:
function
(
packet
)
{
this
.
packets
.
push
(
{
type
:
"
received
"
packet
:
this
.
normalize
(
packet
)
}
)
;
this
.
hooks
.
onPacket
(
packet
)
;
}
onClosed
:
function
(
)
{
this
.
hooks
.
onClosed
(
)
;
}
expectSend
:
function
(
expected
)
{
const
packet
=
this
.
packets
[
this
.
checkIndex
+
+
]
;
Assert
.
equal
(
packet
.
type
"
sent
"
)
;
deepEqual
(
packet
.
packet
this
.
normalize
(
expected
)
)
;
}
expectReceive
:
function
(
expected
)
{
const
packet
=
this
.
packets
[
this
.
checkIndex
+
+
]
;
Assert
.
equal
(
packet
.
type
"
received
"
)
;
deepEqual
(
packet
.
packet
this
.
normalize
(
expected
)
)
;
}
dumpLog
:
function
(
)
{
for
(
const
entry
of
this
.
packets
)
{
if
(
entry
.
type
=
=
=
"
sent
"
)
{
dumpn
(
"
trace
.
expectSend
(
"
+
entry
.
packet
+
"
)
;
"
)
;
}
else
{
dumpn
(
"
trace
.
expectReceive
(
"
+
entry
.
packet
+
"
)
;
"
)
;
}
}
}
}
;
function
StubTransport
(
)
{
}
StubTransport
.
prototype
.
ready
=
function
(
)
{
}
;
StubTransport
.
prototype
.
send
=
function
(
)
{
}
;
StubTransport
.
prototype
.
close
=
function
(
)
{
}
;
const
Async
=
target
=
>
new
Proxy
(
target
Async
)
;
Async
.
get
=
(
target
name
)
=
>
typeof
(
target
[
name
]
)
=
=
=
"
function
"
?
asyncall
.
bind
(
null
target
[
name
]
target
)
:
target
[
name
]
;
const
asyncall
=
(
fn
self
.
.
.
args
)
=
>
new
Promise
(
(
.
.
.
etc
)
=
>
fn
.
call
(
self
.
.
.
args
.
.
.
etc
)
)
;
const
Test
=
task
=
>
(
)
=
>
{
add_task
(
task
)
;
run_next_test
(
)
;
}
;
const
assert
=
Assert
.
ok
.
bind
(
Assert
)
;
function
waitForEvent
(
client
type
predicate
)
{
if
(
!
predicate
)
{
return
client
.
addOneTimeListener
(
type
)
;
}
return
new
Promise
(
function
(
resolve
)
{
function
listener
(
type
packet
)
{
if
(
!
predicate
(
packet
)
)
{
return
;
}
client
.
removeListener
(
listener
)
;
resolve
(
packet
)
;
}
client
.
addListener
(
type
listener
)
;
}
)
;
}
function
executeOnNextTickAndWaitForPause
(
action
client
)
{
const
paused
=
waitForPause
(
client
)
;
executeSoon
(
action
)
;
return
paused
;
}
function
evalCallback
(
debuggeeGlobal
func
)
{
Cu
.
evalInSandbox
(
"
(
"
+
func
+
"
)
(
)
"
debuggeeGlobal
"
1
.
8
"
"
test
.
js
"
1
)
;
}
function
interrupt
(
threadClient
)
{
dumpn
(
"
Interrupting
.
"
)
;
return
threadClient
.
interrupt
(
)
;
}
function
resumeAndWaitForPause
(
client
threadClient
)
{
const
paused
=
waitForPause
(
client
)
;
return
resume
(
threadClient
)
.
then
(
(
)
=
>
paused
)
;
}
function
stepIn
(
client
threadClient
)
{
dumpn
(
"
Stepping
in
.
"
)
;
const
paused
=
waitForPause
(
client
)
;
return
threadClient
.
stepIn
(
)
.
then
(
(
)
=
>
paused
)
;
}
function
stepOver
(
client
threadClient
)
{
dumpn
(
"
Stepping
over
.
"
)
;
return
threadClient
.
stepOver
(
)
.
then
(
(
)
=
>
waitForPause
(
client
)
)
;
}
function
stepOut
(
client
threadClient
)
{
dumpn
(
"
Stepping
out
.
"
)
;
return
threadClient
.
stepOut
(
)
.
then
(
(
)
=
>
waitForPause
(
client
)
)
;
}
function
getFrames
(
threadClient
first
count
)
{
dumpn
(
"
Getting
frames
.
"
)
;
return
threadClient
.
getFrames
(
first
count
)
;
}
async
function
blackBox
(
sourceClient
range
=
null
)
{
dumpn
(
"
Black
boxing
source
:
"
+
sourceClient
.
actor
)
;
const
{
error
pausedInSource
}
=
await
sourceClient
.
blackBox
(
range
)
;
Assert
.
ok
(
!
error
"
Should
not
get
an
error
:
"
+
error
)
;
return
{
error
pausedInSource
}
;
}
async
function
unBlackBox
(
sourceClient
range
=
null
)
{
dumpn
(
"
Un
-
black
boxing
source
:
"
+
sourceClient
.
actor
)
;
const
{
error
}
=
await
sourceClient
.
unblackBox
(
range
)
;
Assert
.
ok
(
!
error
"
Should
not
get
an
error
:
"
+
error
)
;
}
function
getSourceContent
(
sourceClient
)
{
dumpn
(
"
Getting
source
content
for
"
+
sourceClient
.
actor
)
;
return
sourceClient
.
source
(
)
;
}
async
function
getSource
(
threadClient
url
)
{
const
{
sources
}
=
await
threadClient
.
getSources
(
)
;
const
source
=
sources
.
find
(
(
s
)
=
>
s
.
url
=
=
=
url
)
;
if
(
source
)
{
return
threadClient
.
source
(
source
)
;
}
throw
new
Error
(
"
source
not
found
"
)
;
}
async
function
getSourceById
(
threadClient
id
)
{
const
{
sources
}
=
await
threadClient
.
getSources
(
)
;
const
form
=
sources
.
find
(
source
=
>
source
.
actor
=
=
id
)
;
return
threadClient
.
source
(
form
)
;
}
async
function
getSourceFormById
(
threadClient
id
)
{
const
{
sources
}
=
await
threadClient
.
getSources
(
)
;
return
sources
.
find
(
source
=
>
source
.
actor
=
=
id
)
;
}
function
reload
(
tabFront
)
{
return
tabFront
.
reload
(
{
}
)
;
}
function
getInflatedStackLocations
(
thread
sample
)
{
const
stackTable
=
thread
.
stackTable
;
const
frameTable
=
thread
.
frameTable
;
const
stringTable
=
thread
.
stringTable
;
const
SAMPLE_STACK_SLOT
=
thread
.
samples
.
schema
.
stack
;
const
STACK_PREFIX_SLOT
=
stackTable
.
schema
.
prefix
;
const
STACK_FRAME_SLOT
=
stackTable
.
schema
.
frame
;
const
FRAME_LOCATION_SLOT
=
frameTable
.
schema
.
location
;
let
stackIndex
=
sample
[
SAMPLE_STACK_SLOT
]
;
const
locations
=
[
]
;
while
(
stackIndex
!
=
=
null
)
{
const
stackEntry
=
stackTable
.
data
[
stackIndex
]
;
const
frame
=
frameTable
.
data
[
stackEntry
[
STACK_FRAME_SLOT
]
]
;
locations
.
push
(
stringTable
[
frame
[
FRAME_LOCATION_SLOT
]
]
)
;
stackIndex
=
stackEntry
[
STACK_PREFIX_SLOT
]
;
}
return
locations
.
reverse
(
)
;
}
async
function
setupTestFromUrl
(
url
)
{
do_test_pending
(
)
;
const
{
createRootActor
}
=
require
(
"
xpcshell
-
test
/
testactors
"
)
;
DebuggerServer
.
setRootActor
(
createRootActor
)
;
DebuggerServer
.
init
(
(
)
=
>
true
)
;
const
global
=
createTestGlobal
(
"
test
"
)
;
DebuggerServer
.
addTestGlobal
(
global
)
;
const
debuggerClient
=
new
DebuggerClient
(
DebuggerServer
.
connectPipe
(
)
)
;
await
connect
(
debuggerClient
)
;
const
tabs
=
await
listTabs
(
debuggerClient
)
;
const
targetFront
=
findTab
(
tabs
"
test
"
)
;
await
targetFront
.
attach
(
)
;
const
[
threadClient
]
=
await
attachThread
(
targetFront
)
;
await
resume
(
threadClient
)
;
const
sourceUrl
=
getFileUrl
(
url
)
;
const
promise
=
waitForNewSource
(
threadClient
sourceUrl
)
;
loadSubScript
(
sourceUrl
global
)
;
const
{
source
}
=
await
promise
;
const
sourceClient
=
threadClient
.
source
(
source
)
;
return
{
global
debuggerClient
threadClient
sourceClient
}
;
}
function
threadClientTest
(
test
options
=
{
}
)
{
let
{
principal
doNotRunWorker
}
=
options
;
if
(
!
principal
)
{
principal
=
systemPrincipal
;
}
async
function
runThreadClientTestWithServer
(
server
test
)
{
initTestDebuggerServer
(
server
)
;
const
debuggee
=
Cu
.
Sandbox
(
principal
{
freshZone
:
true
}
)
;
const
scriptName
=
"
debuggee
.
js
"
;
debuggee
.
__name
=
scriptName
;
server
.
addTestGlobal
(
debuggee
)
;
const
client
=
new
DebuggerClient
(
server
.
connectPipe
(
)
)
;
await
client
.
connect
(
)
;
const
{
targetFront
threadClient
}
=
await
attachTestTabAndResume
(
client
scriptName
)
;
await
test
(
{
threadClient
debuggee
client
targetFront
}
)
;
await
client
.
close
(
)
;
server
.
removeTestGlobal
(
debuggee
)
;
server
.
destroy
(
)
;
}
return
async
(
)
=
>
{
dump
(
"
>
>
>
Run
thread
client
test
against
a
regular
DebuggerServer
\
n
"
)
;
await
runThreadClientTestWithServer
(
DebuggerServer
test
)
;
if
(
!
doNotRunWorker
)
{
dump
(
"
>
>
>
Run
thread
client
test
against
a
worker
DebuggerServer
\
n
"
)
;
await
runThreadClientTestWithServer
(
WorkerDebuggerServer
test
)
;
}
}
;
}
