"
use
strict
"
;
try
{
var
chromeGlobal
=
this
;
(
function
(
)
{
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
dumpn
}
=
DevToolsUtils
;
const
{
DebuggerServer
ActorPool
}
=
require
(
"
devtools
/
server
/
main
"
)
;
DebuggerServer
.
init
(
)
;
DebuggerServer
.
registerActors
(
{
tab
:
true
}
)
;
let
connections
=
new
Map
(
)
;
let
onConnect
=
DevToolsUtils
.
makeInfallible
(
function
(
msg
)
{
removeMessageListener
(
"
debug
:
connect
"
onConnect
)
;
let
mm
=
msg
.
target
;
let
prefix
=
msg
.
data
.
prefix
;
let
addonId
=
msg
.
data
.
addonId
;
Cu
.
blockThreadedExecution
(
(
)
=
>
{
let
conn
=
DebuggerServer
.
connectToParent
(
prefix
mm
)
;
conn
.
parentMessageManager
=
mm
;
connections
.
set
(
prefix
conn
)
;
let
actor
;
if
(
addonId
)
{
const
{
WebExtensionChildActor
}
=
require
(
"
devtools
/
server
/
actors
/
webextension
"
)
;
actor
=
new
WebExtensionChildActor
(
conn
chromeGlobal
prefix
addonId
)
;
}
else
{
const
{
ContentActor
}
=
require
(
"
devtools
/
server
/
actors
/
content
"
)
;
actor
=
new
ContentActor
(
conn
chromeGlobal
prefix
)
;
}
let
actorPool
=
new
ActorPool
(
conn
)
;
actorPool
.
addActor
(
actor
)
;
conn
.
addActorPool
(
actorPool
)
;
sendAsyncMessage
(
"
debug
:
actor
"
{
actor
:
actor
.
form
(
)
prefix
:
prefix
}
)
;
}
)
;
}
)
;
addMessageListener
(
"
debug
:
connect
"
onConnect
)
;
let
onSetupInChild
=
DevToolsUtils
.
makeInfallible
(
msg
=
>
{
let
{
module
setupChild
args
}
=
msg
.
data
;
let
m
;
try
{
m
=
require
(
module
)
;
if
(
!
(
setupChild
in
m
)
)
{
dumpn
(
ERROR
:
module
'
{
module
}
'
does
not
export
'
{
setupChild
}
'
)
;
return
false
;
}
m
[
setupChild
]
.
apply
(
m
args
)
;
}
catch
(
e
)
{
let
errorMessage
=
"
Exception
during
actor
module
setup
running
in
the
child
process
:
"
;
DevToolsUtils
.
reportException
(
errorMessage
+
e
)
;
dumpn
(
ERROR
:
{
errorMessage
}
\
n
\
t
module
:
'
{
module
}
'
\
n
\
t
+
setupChild
:
'
{
setupChild
}
'
\
n
{
DevToolsUtils
.
safeErrorString
(
e
)
}
)
;
return
false
;
}
if
(
msg
.
data
.
id
)
{
sendAsyncMessage
(
"
debug
:
setup
-
in
-
child
-
response
"
{
id
:
msg
.
data
.
id
}
)
;
}
return
true
;
}
)
;
addMessageListener
(
"
debug
:
setup
-
in
-
child
"
onSetupInChild
)
;
let
onDisconnect
=
DevToolsUtils
.
makeInfallible
(
function
(
msg
)
{
let
prefix
=
msg
.
data
.
prefix
;
let
conn
=
connections
.
get
(
prefix
)
;
if
(
!
conn
)
{
return
;
}
Cu
.
unblockThreadedExecution
(
)
;
removeMessageListener
(
"
debug
:
disconnect
"
onDisconnect
)
;
conn
.
close
(
)
;
connections
.
delete
(
prefix
)
;
}
)
;
addMessageListener
(
"
debug
:
disconnect
"
onDisconnect
)
;
addEventListener
(
"
unload
"
(
)
=
>
{
for
(
let
conn
of
connections
.
values
(
)
)
{
conn
.
close
(
)
;
}
connections
.
clear
(
)
;
}
)
;
}
)
(
)
;
}
catch
(
e
)
{
dump
(
Exception
in
app
child
process
:
{
e
}
\
n
)
;
}
