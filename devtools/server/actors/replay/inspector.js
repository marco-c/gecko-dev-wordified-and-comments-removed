"
use
strict
"
;
const
ReplayDebugger
=
require
(
"
devtools
/
server
/
actors
/
replay
/
debugger
"
)
;
let
_dbg
=
null
;
function
dbg
(
)
{
if
(
!
_dbg
)
{
_dbg
=
new
ReplayDebugger
(
)
;
}
return
_dbg
;
}
function
dbgObject
(
id
)
{
return
dbg
(
)
.
_pool
.
getObject
(
id
)
;
}
let
gInspectorUtils
;
const
ReplayInspector
=
{
get
window
(
)
{
if
(
!
gFixedProxy
.
window
)
{
updateFixedProxies
(
)
;
}
return
gFixedProxy
.
window
;
}
createInspectorUtils
(
utils
)
{
gInspectorUtils
=
new
Proxy
(
{
}
{
get
(
_
name
)
{
switch
(
name
)
{
case
"
getAllStyleSheets
"
:
case
"
getContentState
"
:
case
"
getCSSStyleRules
"
:
case
"
getRuleLine
"
:
case
"
getRuleColumn
"
:
case
"
getRelativeRuleLine
"
:
case
"
getSelectorCount
"
:
case
"
getSelectorText
"
:
case
"
selectorMatchesElement
"
:
case
"
hasRulesModifiedByCSSOM
"
:
case
"
getSpecificity
"
:
return
gFixedProxy
.
InspectorUtils
[
name
]
;
case
"
hasPseudoClassLock
"
:
return
(
)
=
>
false
;
default
:
return
utils
[
name
]
;
}
}
}
)
;
return
gInspectorUtils
;
}
wrapRequireHook
(
requireHook
)
{
return
(
id
require
)
=
>
{
const
rv
=
requireHook
(
id
require
)
;
return
substituteRequire
(
id
rv
)
;
}
;
}
findEventTarget
(
event
)
{
const
rv
=
dbg
(
)
.
_sendRequestAllowDiverge
(
{
type
:
"
findEventTarget
"
clientX
:
event
.
clientX
clientY
:
event
.
clientY
}
)
;
const
obj
=
dbgObject
(
rv
.
id
)
;
return
wrapValue
(
obj
)
;
}
getDebuggerObject
(
node
)
{
return
unwrapValue
(
node
)
;
}
wrapObject
unwrapObject
(
obj
)
{
return
proxyMap
.
get
(
obj
)
;
}
}
;
const
gOverrideIsInstance
=
[
"
CSSRule
"
"
Event
"
]
;
for
(
const
name
of
gOverrideIsInstance
)
{
ReplayInspector
[
create
{
name
}
]
=
original
=
>
(
{
.
.
.
original
isInstance
(
obj
)
{
const
unwrapped
=
proxyMap
.
get
(
obj
)
;
if
(
!
unwrapped
)
{
return
original
.
isInstance
(
obj
)
;
}
assert
(
unwrapped
instanceof
ReplayDebugger
.
Object
)
;
return
unwrapped
.
replayIsInstance
(
name
)
;
}
}
)
;
}
function
newSubstituteProxy
(
target
mapping
)
{
return
new
Proxy
(
{
}
{
get
(
_
name
)
{
if
(
mapping
[
name
]
)
{
return
mapping
[
name
]
;
}
return
target
[
name
]
;
}
}
)
;
}
function
createSubstituteChrome
(
chrome
)
{
const
{
Cc
Cu
}
=
chrome
;
return
{
.
.
.
chrome
Cc
:
newSubstituteProxy
(
Cc
{
"
mozilla
.
org
/
inspector
/
deep
-
tree
-
walker
;
1
"
:
{
createInstance
(
)
{
const
data
=
dbg
(
)
.
_sendRequestAllowDiverge
(
{
type
:
"
newDeepTreeWalker
"
}
)
;
const
obj
=
dbgObject
(
data
.
id
)
;
return
wrapObject
(
obj
)
;
}
}
}
)
Cu
:
newSubstituteProxy
(
Cu
{
isDeadWrapper
(
node
)
{
let
unwrapped
=
proxyMap
.
get
(
node
)
;
if
(
!
unwrapped
)
{
return
Cu
.
isDeadWrapper
(
node
)
;
}
assert
(
unwrapped
instanceof
ReplayDebugger
.
Object
)
;
if
(
unwrapped
.
_pool
!
=
dbg
(
)
.
_pool
)
{
updateFixedProxies
(
)
;
unwrapped
=
proxyMap
.
get
(
node
)
;
return
unwrapped
.
_pool
!
=
dbg
(
)
.
_pool
;
}
return
false
;
}
}
)
}
;
}
function
createSubstituteServices
(
Services
)
{
return
newSubstituteProxy
(
Services
{
els
:
{
getListenerInfoFor
(
node
)
{
return
gFixedProxy
.
Services
.
els
.
getListenerInfoFor
(
node
)
;
}
}
}
)
;
}
function
createSubstitute
(
id
rv
)
{
switch
(
id
)
{
case
"
chrome
"
:
return
createSubstituteChrome
(
rv
)
;
case
"
Services
"
:
return
createSubstituteServices
(
rv
)
;
}
return
null
;
}
const
substitutes
=
new
Map
(
)
;
function
substituteRequire
(
id
rv
)
{
if
(
substitutes
.
has
(
id
)
)
{
return
substitutes
.
get
(
id
)
|
|
rv
;
}
const
newrv
=
createSubstitute
(
id
rv
)
;
substitutes
.
set
(
id
newrv
)
;
return
newrv
|
|
rv
;
}
const
proxyMap
=
new
Map
(
)
;
function
createArrayObject
(
obj
)
{
const
target
=
[
]
;
for
(
const
name
of
obj
.
getOwnPropertyNames
(
)
)
{
const
desc
=
obj
.
getOwnPropertyDescriptor
(
name
)
;
if
(
desc
&
&
"
value
"
in
desc
)
{
target
[
name
]
=
wrapValue
(
desc
.
value
)
;
}
}
return
target
;
}
function
createInspectorObject
(
obj
)
{
if
(
obj
.
class
=
=
"
Array
"
)
{
return
createArrayObject
(
obj
)
;
}
let
target
;
if
(
obj
.
callable
)
{
target
=
function
(
)
{
}
;
target
.
object
=
obj
;
}
else
{
target
=
{
object
:
obj
}
;
}
const
proxy
=
new
Proxy
(
target
ReplayInspectorProxyHandler
)
;
proxyMap
.
set
(
proxy
obj
)
;
return
proxy
;
}
function
wrapObject
(
obj
)
{
assert
(
obj
instanceof
ReplayDebugger
.
Object
)
;
if
(
!
obj
.
_inspectorObject
)
{
obj
.
_inspectorObject
=
createInspectorObject
(
obj
)
;
}
return
obj
.
_inspectorObject
;
}
function
wrapValue
(
value
)
{
if
(
value
&
&
typeof
value
=
=
"
object
"
)
{
return
wrapObject
(
value
)
;
}
return
value
;
}
function
unwrapValue
(
value
)
{
if
(
!
isNonNullObject
(
value
)
)
{
return
value
;
}
const
obj
=
proxyMap
.
get
(
value
)
;
if
(
obj
)
{
return
obj
;
}
if
(
value
=
=
gInspectorUtils
)
{
return
proxyMap
.
get
(
gFixedProxy
.
InspectorUtils
)
;
}
if
(
value
instanceof
Object
)
{
const
rv
=
dbg
(
)
.
_sendRequest
(
{
type
:
"
createObject
"
}
)
;
const
newobj
=
dbgObject
(
rv
.
id
)
;
Object
.
entries
(
value
)
.
forEach
(
(
[
name
propvalue
]
)
=
>
{
const
unwrapped
=
unwrapValue
(
propvalue
)
;
setObjectProperty
(
newobj
name
unwrapped
)
;
}
)
;
return
newobj
;
}
ThrowError
(
"
Can
'
t
unwrap
value
"
)
;
}
function
getObjectProperty
(
obj
name
)
{
assert
(
obj
.
_pool
=
=
dbg
(
)
.
_pool
)
;
const
rv
=
dbg
(
)
.
_sendRequestAllowDiverge
(
{
type
:
"
getObjectPropertyValue
"
id
:
obj
.
_data
.
id
name
}
)
;
return
dbg
(
)
.
_pool
.
convertCompletionValue
(
rv
)
;
}
function
ignoreSetProperty
(
obj
name
)
{
switch
(
obj
.
class
)
{
case
"
HTMLDocument
"
:
return
[
"
styleSheetChangeEventsEnabled
"
]
.
includes
(
name
)
;
}
return
false
;
}
function
setObjectProperty
(
obj
name
value
)
{
assert
(
obj
.
_pool
=
=
dbg
(
)
.
_pool
)
;
const
rv
=
dbg
(
)
.
_sendRequestAllowDiverge
(
{
type
:
"
setObjectPropertyValue
"
id
:
obj
.
_data
.
id
name
value
:
dbg
(
)
.
_convertValueForChild
(
value
)
}
)
;
return
dbg
(
)
.
_pool
.
convertCompletionValue
(
rv
)
;
}
function
getTargetObject
(
target
)
{
if
(
!
target
.
object
.
_data
)
{
updateFixedProxies
(
)
;
assert
(
target
.
object
.
_data
)
;
}
return
target
.
object
;
}
const
ReplayInspectorProxyHandler
=
{
getPrototypeOf
(
target
)
{
target
=
getTargetObject
(
target
)
;
if
(
target
.
_data
.
class
=
=
"
NamedNodeMap
"
)
{
return
NamedNodeMap
.
prototype
;
}
return
null
;
}
has
(
target
name
)
{
target
=
getTargetObject
(
target
)
;
if
(
typeof
name
=
=
"
symbol
"
)
{
return
name
=
=
Symbol
.
iterator
;
}
if
(
name
=
=
"
toString
"
)
{
return
true
;
}
const
desc
=
target
.
getOwnPropertyDescriptor
(
name
)
;
return
!
!
desc
;
}
get
(
target
name
receiver
)
{
target
=
getTargetObject
(
target
)
;
if
(
typeof
name
=
=
"
symbol
"
)
{
if
(
name
=
=
Symbol
.
iterator
)
{
const
array
=
createArrayObject
(
target
)
;
return
array
[
Symbol
.
iterator
]
;
}
return
undefined
;
}
if
(
name
=
=
"
toString
"
)
{
return
(
)
=
>
ReplayInspectorProxy
#
{
target
.
_data
.
id
}
;
}
if
(
!
target
.
_modifiedProperties
|
|
!
target
.
_modifiedProperties
.
has
(
name
)
)
{
const
desc
=
target
.
getOwnPropertyDescriptor
(
name
)
;
if
(
desc
&
&
"
value
"
in
desc
)
{
return
wrapValue
(
desc
.
value
)
;
}
}
const
rv
=
getObjectProperty
(
target
name
)
;
if
(
"
return
"
in
rv
)
{
return
wrapValue
(
rv
.
return
)
;
}
ThrowError
(
rv
.
throw
)
;
}
set
(
target
name
value
)
{
target
=
getTargetObject
(
target
)
;
if
(
ignoreSetProperty
(
target
name
)
)
{
return
true
;
}
if
(
!
target
.
_modifiedProperties
)
{
target
.
_modifiedProperties
=
new
Set
(
)
;
}
target
.
_modifiedProperties
.
add
(
name
)
;
const
rv
=
setObjectProperty
(
target
name
unwrapValue
(
value
)
)
;
if
(
"
return
"
in
rv
)
{
return
true
;
}
ThrowError
(
rv
.
throw
)
;
}
apply
(
target
thisArg
args
)
{
target
=
getTargetObject
(
target
)
;
const
rv
=
target
.
apply
(
unwrapValue
(
thisArg
)
args
.
map
(
v
=
>
unwrapValue
(
v
)
)
)
;
if
(
"
return
"
in
rv
)
{
return
wrapValue
(
rv
.
return
)
;
}
ThrowError
(
rv
.
throw
)
;
}
construct
(
target
args
)
{
target
=
getTargetObject
(
target
)
;
const
proxy
=
wrapObject
(
target
)
;
if
(
proxy
=
=
gFixedProxy
.
window
.
MutationObserver
)
{
return
{
observe
:
(
)
=
>
{
}
disconnect
:
(
)
=
>
{
}
}
;
}
NotAllowed
(
)
;
}
getOwnPropertyDescriptor
(
target
name
)
{
target
=
getTargetObject
(
target
)
;
const
desc
=
target
.
getOwnPropertyDescriptor
(
name
)
;
if
(
!
desc
)
{
return
null
;
}
if
(
"
value
"
in
desc
)
{
desc
.
value
=
wrapValue
(
desc
.
value
)
;
}
if
(
"
get
"
in
desc
)
{
desc
.
get
=
wrapValue
(
desc
.
get
)
;
}
if
(
"
set
"
in
desc
)
{
desc
.
set
=
wrapValue
(
desc
.
set
)
;
}
desc
.
configurable
=
true
;
return
desc
;
}
ownKeys
(
target
)
{
target
=
getTargetObject
(
target
)
;
return
target
.
getOwnPropertyNames
(
)
;
}
isExtensible
(
target
)
{
NYI
(
)
;
}
setPrototypeOf
(
)
{
NotAllowed
(
)
;
}
preventExtensions
(
)
{
NotAllowed
(
)
;
}
defineProperty
(
)
{
NotAllowed
(
)
;
}
deleteProperty
(
)
{
NotAllowed
(
)
;
}
}
;
const
gFixedProxyTargets
=
{
}
;
const
gFixedProxy
=
{
}
;
function
initFixedProxy
(
proxy
target
obj
)
{
target
.
object
=
obj
;
proxyMap
.
set
(
proxy
obj
)
;
obj
.
_inspectorObject
=
proxy
;
}
function
updateFixedProxies
(
)
{
dbg
(
)
.
_ensurePaused
(
)
;
const
{
objects
preview
}
=
dbg
(
)
.
_sendRequestAllowDiverge
(
{
type
:
"
getFixedObjects
"
}
)
;
dbg
(
)
.
_pool
.
addPauseData
(
preview
)
;
for
(
const
[
key
value
]
of
Object
.
entries
(
objects
)
)
{
if
(
!
gFixedProxyTargets
[
key
]
)
{
gFixedProxyTargets
[
key
]
=
{
object
:
{
}
}
;
gFixedProxy
[
key
]
=
new
Proxy
(
gFixedProxyTargets
[
key
]
ReplayInspectorProxyHandler
)
;
}
initFixedProxy
(
gFixedProxy
[
key
]
gFixedProxyTargets
[
key
]
dbgObject
(
value
)
)
;
}
}
function
NYI
(
)
{
ThrowError
(
"
Not
yet
implemented
"
)
;
}
function
NotAllowed
(
)
{
ThrowError
(
"
Not
allowed
"
)
;
}
function
ThrowError
(
msg
)
{
const
error
=
new
Error
(
msg
)
;
dump
(
"
ReplayInspector
Server
Error
:
"
+
msg
+
"
Stack
:
"
+
error
.
stack
+
"
\
n
"
)
;
throw
error
;
}
function
assert
(
v
)
{
if
(
!
v
)
{
ThrowError
(
"
Assertion
Failed
!
"
)
;
}
}
function
isNonNullObject
(
obj
)
{
return
obj
&
&
(
typeof
obj
=
=
"
object
"
|
|
typeof
obj
=
=
"
function
"
)
;
}
module
.
exports
=
ReplayInspector
;
