"
use
strict
"
;
self
.
addEventListener
(
"
message
"
function
(
{
data
}
)
{
const
{
type
id
}
=
data
;
switch
(
type
)
{
case
"
connect
"
:
try
{
doConnect
(
id
data
.
channelId
data
.
address
)
;
}
catch
(
e
)
{
dump
(
doConnect
error
:
{
e
}
\
n
)
;
}
break
;
case
"
send
"
:
try
{
doSend
(
id
data
.
buf
)
;
}
catch
(
e
)
{
dump
(
doSend
error
:
{
e
}
\
n
)
;
}
break
;
default
:
ThrowError
(
Unknown
event
type
{
type
}
)
;
}
}
)
;
const
gConnections
=
[
]
;
async
function
doConnect
(
id
channelId
address
)
{
if
(
gConnections
[
id
]
)
{
ThrowError
(
Duplicate
connection
ID
{
id
}
)
;
}
const
connection
=
{
outgoing
:
[
]
}
;
gConnections
[
id
]
=
connection
;
const
response
=
await
fetch
(
address
)
;
const
text
=
await
response
.
text
(
)
;
if
(
!
/
^
wss
?
:
\
/
\
/
/
.
test
(
text
)
)
{
ThrowError
(
Invalid
websocket
address
{
text
}
)
;
}
const
socket
=
new
WebSocket
(
text
)
;
socket
.
onopen
=
evt
=
>
onOpen
(
id
evt
)
;
socket
.
onclose
=
evt
=
>
onClose
(
id
evt
)
;
socket
.
onmessage
=
evt
=
>
onMessage
(
id
evt
)
;
socket
.
onerror
=
evt
=
>
onError
(
id
evt
)
;
await
new
Promise
(
resolve
=
>
(
connection
.
openWaiter
=
resolve
)
)
;
while
(
gConnections
[
id
]
)
{
if
(
connection
.
outgoing
.
length
)
{
const
buf
=
connection
.
outgoing
.
shift
(
)
;
try
{
socket
.
send
(
buf
)
;
}
catch
(
e
)
{
ThrowError
(
Send
error
{
e
}
)
;
}
}
else
{
await
new
Promise
(
resolve
=
>
(
connection
.
sendWaiter
=
resolve
)
)
;
}
}
}
function
doSend
(
id
buf
)
{
const
connection
=
gConnections
[
id
]
;
connection
.
outgoing
.
push
(
buf
)
;
if
(
connection
.
sendWaiter
)
{
connection
.
sendWaiter
(
)
;
connection
.
sendWaiter
=
null
;
}
}
function
onOpen
(
id
)
{
gConnections
[
id
]
.
openWaiter
(
)
;
}
function
onClose
(
id
evt
)
{
gConnections
[
id
]
=
null
;
}
const
gMessages
=
[
]
;
let
gMessageWaiter
=
null
;
(
async
function
processMessages
(
)
{
while
(
true
)
{
if
(
gMessages
.
length
)
{
const
{
id
promise
}
=
gMessages
.
shift
(
)
;
const
buf
=
await
promise
;
postMessage
(
{
id
buf
}
)
;
}
else
{
await
new
Promise
(
resolve
=
>
(
gMessageWaiter
=
resolve
)
)
;
}
}
}
)
(
)
;
function
onMessage
(
id
evt
)
{
gMessages
.
push
(
{
id
promise
:
evt
.
data
.
arrayBuffer
(
)
}
)
;
if
(
gMessageWaiter
)
{
gMessageWaiter
(
)
;
gMessageWaiter
=
null
;
}
}
function
onError
(
id
evt
)
{
ThrowError
(
Socket
error
{
evt
}
)
;
}
function
ThrowError
(
msg
)
{
dump
(
Connection
Worker
Error
:
{
msg
}
\
n
)
;
throw
new
Error
(
msg
)
;
}
