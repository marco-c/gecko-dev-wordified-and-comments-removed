"
use
strict
"
;
const
CC
=
Components
.
Constructor
;
const
sandbox
=
Cu
.
Sandbox
(
CC
(
"
mozilla
.
org
/
systemprincipal
;
1
"
"
nsIPrincipal
"
)
(
)
)
;
Cu
.
evalInSandbox
(
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
'
)
;
"
+
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
)
;
"
+
"
Components
.
utils
.
import
(
'
resource
:
/
/
devtools
/
shared
/
execution
-
point
-
utils
.
js
'
)
;
"
+
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
'
)
;
"
+
"
addDebuggerToGlobal
(
this
)
;
"
sandbox
)
;
const
{
RecordReplayControl
Services
pointEquals
pointToString
findClosestPoint
pointArrayIncludes
positionEquals
positionSubsumes
setInterval
}
=
sandbox
;
const
InvalidCheckpointId
=
0
;
const
FirstCheckpointId
=
1
;
function
ChildProcess
(
id
recording
)
{
this
.
id
=
id
;
this
.
recording
=
recording
;
this
.
paused
=
false
;
this
.
lastPausePoint
=
null
;
this
.
lastMemoryUsage
=
null
;
this
.
savedCheckpoints
=
new
Set
(
recording
?
[
]
:
[
FirstCheckpointId
]
)
;
this
.
scannedCheckpoints
=
new
Set
(
)
;
this
.
needSaveCheckpoints
=
[
]
;
this
.
divergedFromRecording
=
false
;
this
.
manifest
=
{
onFinished
:
(
{
point
}
)
=
>
{
if
(
this
=
=
gMainChild
)
{
getCheckpointInfo
(
FirstCheckpointId
)
.
point
=
point
;
Services
.
tm
.
dispatchToMainThread
(
recording
?
maybeResumeRecording
:
setMainChild
)
;
}
}
}
;
this
.
manifestSendTime
=
Date
.
now
(
)
;
this
.
asyncManifestInfo
=
new
AsyncManifestChildInfo
(
)
;
}
ChildProcess
.
prototype
=
{
pausePoint
(
)
{
assert
(
this
.
paused
)
;
return
this
.
lastPausePoint
;
}
pauseCheckpoint
(
)
{
const
point
=
this
.
pausePoint
(
)
;
assert
(
!
point
.
position
)
;
return
point
.
checkpoint
;
}
sendManifest
(
manifest
)
{
assert
(
this
.
paused
)
;
this
.
paused
=
false
;
this
.
manifest
=
manifest
;
this
.
manifestSendTime
=
Date
.
now
(
)
;
dumpv
(
SendManifest
#
{
this
.
id
}
{
stringify
(
manifest
.
contents
)
}
)
;
RecordReplayControl
.
sendManifest
(
this
.
id
manifest
.
contents
)
;
}
manifestFinished
(
response
)
{
assert
(
!
this
.
paused
)
;
if
(
response
)
{
if
(
response
.
point
)
{
this
.
lastPausePoint
=
response
.
point
;
}
if
(
response
.
memoryUsage
)
{
this
.
lastMemoryUsage
=
response
.
memoryUsage
;
}
}
this
.
paused
=
true
;
this
.
manifest
.
onFinished
(
response
)
;
this
.
manifest
=
null
;
maybeDumpStatistics
(
)
;
}
waitUntilPaused
(
maybeCreateCheckpoint
)
{
if
(
this
.
paused
)
{
return
;
}
RecordReplayControl
.
waitUntilPaused
(
this
.
id
maybeCreateCheckpoint
)
;
assert
(
this
.
paused
)
;
}
addSavedCheckpoint
(
checkpoint
)
{
dumpv
(
AddSavedCheckpoint
#
{
this
.
id
}
{
checkpoint
}
)
;
this
.
savedCheckpoints
.
add
(
checkpoint
)
;
if
(
checkpoint
!
=
FirstCheckpointId
)
{
this
.
needSaveCheckpoints
.
push
(
checkpoint
)
;
}
}
flushNeedSaveCheckpoints
(
)
{
const
rv
=
this
.
needSaveCheckpoints
;
this
.
needSaveCheckpoints
=
[
]
;
return
rv
;
}
lastSavedCheckpoint
(
checkpoint
)
{
while
(
!
this
.
savedCheckpoints
.
has
(
checkpoint
)
)
{
checkpoint
-
-
;
}
return
checkpoint
;
}
timeToReachPoint
(
point
)
{
let
startDelay
=
0
startPoint
=
this
.
lastPausePoint
;
if
(
!
this
.
paused
)
{
if
(
this
.
manifest
.
expectedDuration
)
{
const
elapsed
=
Date
.
now
(
)
-
this
.
manifestSendTime
;
if
(
elapsed
<
this
.
manifest
.
expectedDuration
)
{
startDelay
=
this
.
manifest
.
expectedDuration
-
elapsed
;
}
}
if
(
this
.
manifest
.
destination
)
{
startPoint
=
this
.
manifest
.
destination
;
}
}
let
startCheckpoint
=
startPoint
.
checkpoint
;
if
(
startPoint
.
position
)
{
startCheckpoint
=
this
.
lastSavedCheckpoint
(
startCheckpoint
)
;
}
if
(
point
.
checkpoint
<
startCheckpoint
)
{
startCheckpoint
=
this
.
lastSavedCheckpoint
(
point
.
checkpoint
)
;
}
return
(
startDelay
+
checkpointRangeDuration
(
startCheckpoint
point
.
checkpoint
)
)
;
}
}
;
let
gMainChild
;
const
gReplayingChildren
=
[
]
;
function
lookupChild
(
id
)
{
if
(
id
=
=
gMainChild
.
id
)
{
return
gMainChild
;
}
assert
(
gReplayingChildren
[
id
]
)
;
return
gReplayingChildren
[
id
]
;
}
function
closestChild
(
point
)
{
let
minChild
=
null
minTime
=
Infinity
;
for
(
const
child
of
gReplayingChildren
)
{
if
(
child
)
{
const
time
=
child
.
timeToReachPoint
(
point
)
;
if
(
time
<
minTime
)
{
minChild
=
child
;
minTime
=
time
;
}
}
}
return
minChild
;
}
let
gDebugger
;
const
gAsyncManifests
=
new
Set
(
)
;
const
gAsyncManifestsLowPriority
=
new
Set
(
)
;
function
asyncManifestWorklist
(
lowPriority
)
{
return
lowPriority
?
gAsyncManifestsLowPriority
:
gAsyncManifests
;
}
function
sendAsyncManifest
(
manifest
)
{
pokeChildrenSoon
(
)
;
return
new
Promise
(
resolve
=
>
{
manifest
.
resolve
=
resolve
;
asyncManifestWorklist
(
manifest
.
lowPriority
)
.
add
(
manifest
)
;
}
)
;
}
function
AsyncManifestChildInfo
(
)
{
this
.
inProgressManifest
=
null
;
}
function
pickAsyncManifest
(
child
lowPriority
)
{
const
worklist
=
asyncManifestWorklist
(
lowPriority
)
;
let
best
=
null
bestTime
=
Infinity
;
for
(
const
manifest
of
worklist
)
{
if
(
manifest
.
shouldSkip
(
)
)
{
manifest
.
resolve
(
)
;
worklist
.
delete
(
manifest
)
;
continue
;
}
if
(
manifest
.
scanCheckpoint
)
{
if
(
child
.
scannedCheckpoints
.
has
(
manifest
.
scanCheckpoint
)
)
{
assert
(
!
manifest
.
point
)
;
best
=
manifest
;
break
;
}
else
{
continue
;
}
}
if
(
child
=
=
gActiveChild
)
{
continue
;
}
assert
(
manifest
.
point
)
;
const
time
=
child
.
timeToReachPoint
(
manifest
.
point
)
;
if
(
time
<
bestTime
)
{
best
=
manifest
;
bestTime
=
time
;
}
}
if
(
best
)
{
worklist
.
delete
(
best
)
;
}
return
best
;
}
function
processAsyncManifest
(
child
)
{
let
manifest
=
child
.
asyncManifestInfo
.
inProgressManifest
;
child
.
asyncManifestInfo
.
inProgressManifest
=
null
;
if
(
manifest
&
&
child
=
=
gActiveChild
)
{
sendAsyncManifest
(
manifest
)
;
manifest
=
null
;
}
if
(
!
manifest
)
{
manifest
=
pickAsyncManifest
(
child
false
)
;
if
(
!
manifest
)
{
manifest
=
pickAsyncManifest
(
child
true
)
;
if
(
!
manifest
)
{
return
false
;
}
}
}
if
(
manifest
.
point
&
&
maybeReachPoint
(
child
manifest
.
point
)
)
{
child
.
asyncManifestInfo
.
inProgressManifest
=
manifest
;
return
true
;
}
child
.
sendManifest
(
{
contents
:
manifest
.
contents
(
child
)
onFinished
:
data
=
>
{
manifest
.
onFinished
(
child
data
)
;
manifest
.
resolve
(
)
;
pokeChildSoon
(
child
)
;
}
destination
:
manifest
.
destination
expectedDuration
:
manifest
.
expectedDuration
}
)
;
return
true
;
}
let
gActiveChild
=
null
;
const
gCheckpoints
=
[
null
]
;
function
CheckpointInfo
(
)
{
this
.
duration
=
0
;
this
.
point
=
null
;
this
.
saved
=
false
;
this
.
assignTime
=
null
;
this
.
scanTime
=
null
;
this
.
scanDuration
=
null
;
}
function
getCheckpointInfo
(
id
)
{
while
(
id
>
=
gCheckpoints
.
length
)
{
gCheckpoints
.
push
(
new
CheckpointInfo
(
)
)
;
}
return
gCheckpoints
[
id
]
;
}
function
checkpointRangeDuration
(
start
end
)
{
let
time
=
0
;
for
(
let
i
=
start
;
i
<
end
;
i
+
+
)
{
time
+
=
gCheckpoints
[
i
]
.
duration
;
}
return
time
;
}
function
timeSinceCheckpoint
(
id
)
{
return
checkpointRangeDuration
(
id
gCheckpoints
.
length
)
;
}
function
timeForSavedCheckpoint
(
id
)
{
return
checkpointRangeDuration
(
id
nextSavedCheckpoint
(
id
)
)
;
}
let
gLastFlushCheckpoint
=
InvalidCheckpointId
;
const
FlushMs
=
0
.
5
*
1000
;
let
gLastPickedChildId
=
0
;
function
addSavedCheckpoint
(
checkpoint
)
{
let
child
;
while
(
true
)
{
gLastPickedChildId
=
(
gLastPickedChildId
+
1
)
%
gReplayingChildren
.
length
;
child
=
gReplayingChildren
[
gLastPickedChildId
]
;
if
(
child
)
{
break
;
}
}
getCheckpointInfo
(
checkpoint
)
.
saved
=
true
;
getCheckpointInfo
(
checkpoint
)
.
assignTime
=
Date
.
now
(
)
;
child
.
addSavedCheckpoint
(
checkpoint
)
;
}
function
addCheckpoint
(
checkpoint
duration
)
{
assert
(
!
getCheckpointInfo
(
checkpoint
)
.
duration
)
;
getCheckpointInfo
(
checkpoint
)
.
duration
=
duration
;
}
function
restoreCheckpoint
(
child
target
)
{
assert
(
child
.
savedCheckpoints
.
has
(
target
)
)
;
child
.
sendManifest
(
{
contents
:
{
kind
:
"
restoreCheckpoint
"
target
}
onFinished
(
{
restoredCheckpoint
}
)
{
assert
(
restoredCheckpoint
)
;
child
.
divergedFromRecording
=
false
;
pokeChildSoon
(
child
)
;
}
destination
:
checkpointExecutionPoint
(
target
)
}
)
;
}
function
maybeReachPoint
(
child
endpoint
)
{
if
(
pointEquals
(
child
.
pausePoint
(
)
endpoint
)
&
&
!
child
.
divergedFromRecording
)
{
return
false
;
}
if
(
child
.
divergedFromRecording
|
|
child
.
pausePoint
(
)
.
position
)
{
restoreCheckpoint
(
child
child
.
lastSavedCheckpoint
(
child
.
pausePoint
(
)
.
checkpoint
)
)
;
return
true
;
}
if
(
endpoint
.
checkpoint
<
child
.
pauseCheckpoint
(
)
)
{
restoreCheckpoint
(
child
child
.
lastSavedCheckpoint
(
endpoint
.
checkpoint
)
)
;
return
true
;
}
child
.
sendManifest
(
{
contents
:
{
kind
:
"
runToPoint
"
endpoint
needSaveCheckpoints
:
child
.
flushNeedSaveCheckpoints
(
)
}
onFinished
(
)
{
pokeChildSoon
(
child
)
;
}
destination
:
endpoint
expectedDuration
:
checkpointRangeDuration
(
child
.
pausePoint
(
)
.
checkpoint
endpoint
.
checkpoint
)
}
)
;
return
true
;
}
function
nextSavedCheckpoint
(
checkpoint
)
{
assert
(
gCheckpoints
[
checkpoint
]
.
saved
)
;
while
(
!
gCheckpoints
[
+
+
checkpoint
]
.
saved
)
{
}
return
checkpoint
;
}
function
forSavedCheckpointsInRange
(
start
end
callback
)
{
if
(
start
=
=
FirstCheckpointId
&
&
!
gCheckpoints
[
start
]
.
saved
)
{
return
;
}
assert
(
gCheckpoints
[
start
]
.
saved
)
;
for
(
let
checkpoint
=
start
;
checkpoint
<
end
;
checkpoint
=
nextSavedCheckpoint
(
checkpoint
)
)
{
callback
(
checkpoint
)
;
}
}
function
getSavedCheckpoint
(
checkpoint
)
{
while
(
!
gCheckpoints
[
checkpoint
]
.
saved
)
{
checkpoint
-
-
;
}
return
checkpoint
;
}
function
checkpointExecutionPoint
(
checkpoint
)
{
return
gCheckpoints
[
checkpoint
]
.
point
;
}
function
pokeChild
(
child
)
{
assert
(
!
child
.
recording
)
;
if
(
!
child
.
paused
)
{
return
;
}
if
(
processAsyncManifest
(
child
)
)
{
return
;
}
if
(
child
=
=
gActiveChild
)
{
sendChildToPausePoint
(
child
)
;
return
;
}
maybeReachPoint
(
child
checkpointExecutionPoint
(
gLastFlushCheckpoint
)
)
;
}
function
pokeChildSoon
(
child
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
pokeChild
(
child
)
)
;
}
let
gPendingPokeChildren
=
false
;
function
pokeChildren
(
)
{
gPendingPokeChildren
=
false
;
for
(
const
child
of
gReplayingChildren
)
{
if
(
child
)
{
pokeChild
(
child
)
;
}
}
}
function
pokeChildrenSoon
(
)
{
if
(
!
gPendingPokeChildren
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
pokeChildren
(
)
)
;
gPendingPokeChildren
=
true
;
}
}
const
gBreakpoints
=
[
]
;
function
findScanChild
(
checkpoint
)
{
for
(
const
child
of
gReplayingChildren
)
{
if
(
child
&
&
child
.
scannedCheckpoints
.
has
(
checkpoint
)
)
{
return
child
;
}
}
return
null
;
}
async
function
scanRecording
(
checkpoint
)
{
assert
(
checkpoint
<
gLastFlushCheckpoint
)
;
const
child
=
findScanChild
(
checkpoint
)
;
if
(
child
)
{
return
;
}
const
endpoint
=
nextSavedCheckpoint
(
checkpoint
)
;
await
sendAsyncManifest
(
{
shouldSkip
:
(
)
=
>
!
!
findScanChild
(
checkpoint
)
contents
(
child
)
{
child
.
scannedCheckpoints
.
add
(
checkpoint
)
;
return
{
kind
:
"
scanRecording
"
endpoint
needSaveCheckpoints
:
child
.
flushNeedSaveCheckpoints
(
)
}
;
}
onFinished
(
child
{
duration
}
)
{
const
info
=
getCheckpointInfo
(
checkpoint
)
;
if
(
!
info
.
scanTime
)
{
info
.
scanTime
=
Date
.
now
(
)
;
info
.
scanDuration
=
duration
;
}
if
(
gDebugger
)
{
gDebugger
.
_callOnPositionChange
(
)
;
}
}
point
:
checkpointExecutionPoint
(
checkpoint
)
destination
:
checkpointExecutionPoint
(
endpoint
)
expectedDuration
:
checkpointRangeDuration
(
checkpoint
endpoint
)
*
5
}
)
;
assert
(
findScanChild
(
checkpoint
)
)
;
}
function
unscannedRegions
(
)
{
const
result
=
[
]
;
function
addRegion
(
startCheckpoint
endCheckpoint
)
{
const
start
=
checkpointExecutionPoint
(
startCheckpoint
)
.
progress
;
const
end
=
checkpointExecutionPoint
(
endCheckpoint
)
.
progress
;
if
(
result
.
length
&
&
result
[
result
.
length
-
1
]
.
end
=
=
start
)
{
result
[
result
.
length
-
1
]
.
end
=
end
;
}
else
{
result
.
push
(
{
start
end
}
)
;
}
}
forSavedCheckpointsInRange
(
FirstCheckpointId
gLastFlushCheckpoint
checkpoint
=
>
{
if
(
!
findScanChild
(
checkpoint
)
)
{
addRegion
(
checkpoint
nextSavedCheckpoint
(
checkpoint
)
)
;
}
}
)
;
const
lastFlush
=
gLastFlushCheckpoint
|
|
FirstCheckpointId
;
if
(
lastFlush
!
=
gRecordingEndpoint
)
{
addRegion
(
lastFlush
gMainChild
.
lastPausePoint
.
checkpoint
)
;
}
return
result
;
}
const
gHitSearches
=
new
Map
(
)
;
function
canFindHits
(
position
)
{
return
position
.
kind
=
=
"
Break
"
|
|
position
.
kind
=
=
"
OnStep
"
;
}
function
findExistingHits
(
checkpoint
position
)
{
const
checkpointHits
=
gHitSearches
.
get
(
checkpoint
)
;
if
(
!
checkpointHits
)
{
return
null
;
}
const
entry
=
checkpointHits
.
find
(
(
{
position
:
existingPosition
hits
}
)
=
>
{
return
positionEquals
(
position
existingPosition
)
;
}
)
;
return
entry
?
entry
.
hits
:
null
;
}
async
function
findHits
(
checkpoint
position
)
{
assert
(
canFindHits
(
position
)
)
;
assert
(
gCheckpoints
[
checkpoint
]
.
saved
)
;
if
(
!
gHitSearches
.
has
(
checkpoint
)
)
{
gHitSearches
.
set
(
checkpoint
[
]
)
;
}
let
hits
=
findExistingHits
(
checkpoint
position
)
;
if
(
hits
)
{
return
hits
;
}
await
scanRecording
(
checkpoint
)
;
const
endpoint
=
nextSavedCheckpoint
(
checkpoint
)
;
await
sendAsyncManifest
(
{
shouldSkip
:
(
)
=
>
!
!
findExistingHits
(
checkpoint
position
)
contents
(
)
{
return
{
kind
:
"
findHits
"
position
startpoint
:
checkpoint
endpoint
}
;
}
onFinished
(
_
hits
)
{
if
(
!
gHitSearches
.
has
(
checkpoint
)
)
{
gHitSearches
.
set
(
checkpoint
[
]
)
;
}
const
checkpointHits
=
gHitSearches
.
get
(
checkpoint
)
;
checkpointHits
.
push
(
{
position
hits
}
)
;
}
scanCheckpoint
:
checkpoint
}
)
;
hits
=
findExistingHits
(
checkpoint
position
)
;
assert
(
hits
)
;
return
hits
;
}
async
function
findBreakpointHits
(
checkpoint
position
)
{
if
(
position
.
kind
=
=
"
Break
"
)
{
const
hits
=
await
findHits
(
checkpoint
position
)
;
if
(
hits
.
length
)
{
updateNearbyPoints
(
)
;
}
}
}
const
gFrameSteps
=
[
]
;
function
hasSteppingBreakpoint
(
)
{
return
gBreakpoints
.
some
(
bp
=
>
bp
.
kind
=
=
"
EnterFrame
"
|
|
bp
.
kind
=
=
"
OnPop
"
)
;
}
function
findExistingFrameSteps
(
point
)
{
if
(
point
.
position
.
kind
=
=
"
EnterFrame
"
)
{
return
gFrameSteps
.
find
(
steps
=
>
pointEquals
(
point
steps
[
0
]
)
)
;
}
return
gFrameSteps
.
find
(
steps
=
>
pointArrayIncludes
(
steps
point
)
)
;
}
async
function
findFrameSteps
(
point
)
{
if
(
!
point
.
position
)
{
return
null
;
}
assert
(
point
.
position
.
kind
=
=
"
EnterFrame
"
|
|
point
.
position
.
kind
=
=
"
OnStep
"
|
|
point
.
position
.
kind
=
=
"
OnPop
"
)
;
let
steps
=
findExistingFrameSteps
(
point
)
;
if
(
steps
)
{
return
steps
;
}
const
info
=
gControl
.
sendRequestMainChild
(
{
type
:
"
frameStepsInfo
"
script
:
point
.
position
.
script
}
)
;
const
checkpoint
=
getSavedCheckpoint
(
point
.
checkpoint
)
;
await
scanRecording
(
checkpoint
)
;
await
sendAsyncManifest
(
{
shouldSkip
:
(
)
=
>
!
!
findExistingFrameSteps
(
point
)
contents
:
(
)
=
>
(
{
kind
:
"
findFrameSteps
"
targetPoint
:
point
.
.
.
info
}
)
onFinished
:
(
_
steps
)
=
>
gFrameSteps
.
push
(
steps
)
scanCheckpoint
:
checkpoint
}
)
;
steps
=
findExistingFrameSteps
(
point
)
;
assert
(
steps
)
;
updateNearbyPoints
(
)
;
return
steps
;
}
const
gPauseData
=
new
Map
(
)
;
const
gCachedPoints
=
new
Map
(
)
;
async
function
queuePauseData
(
point
trackCached
shouldSkipCallback
)
{
await
waitForFlushed
(
point
.
checkpoint
)
;
sendAsyncManifest
(
{
shouldSkip
(
)
{
if
(
maybeGetPauseData
(
point
)
)
{
return
true
;
}
if
(
gLogpoints
.
some
(
(
{
position
}
)
=
>
positionSubsumes
(
position
point
.
position
)
)
)
{
return
true
;
}
return
shouldSkipCallback
&
&
shouldSkipCallback
(
)
;
}
contents
(
)
{
return
{
kind
:
"
getPauseData
"
}
;
}
onFinished
(
child
data
)
{
if
(
!
data
.
restoredCheckpoint
)
{
addPauseData
(
point
data
trackCached
)
;
child
.
divergedFromRecording
=
true
;
}
}
point
expectedDuration
:
250
lowPriority
:
true
}
)
;
}
function
addPauseData
(
point
data
trackCached
)
{
if
(
data
.
paintData
)
{
data
.
paintData
=
RecordReplayControl
.
atomize
(
data
.
paintData
)
;
}
gPauseData
.
set
(
pointToString
(
point
)
data
)
;
if
(
trackCached
)
{
gCachedPoints
.
set
(
pointToString
(
point
)
point
)
;
if
(
gDebugger
)
{
gDebugger
.
_callOnPositionChange
(
)
;
}
}
}
function
maybeGetPauseData
(
point
)
{
return
gPauseData
.
get
(
pointToString
(
point
)
)
;
}
function
cachedPoints
(
)
{
return
[
.
.
.
gCachedPoints
.
values
(
)
]
.
map
(
point
=
>
point
.
progress
)
;
}
const
PauseModes
=
{
RUNNING
:
"
RUNNING
"
PAUSED
:
"
PAUSED
"
ARRIVING
:
"
ARRIVING
"
RESUMING_BACKWARD
:
"
RESUMING_BACKWARD
"
RESUMING_FORWARD
:
"
RESUMING_FORWARD
"
}
;
let
gPauseMode
=
PauseModes
.
RUNNING
;
let
gPausePoint
=
null
;
const
gDebuggerRequests
=
[
]
;
let
gSyncDebuggerRequests
=
false
;
function
setPauseState
(
mode
point
child
)
{
assert
(
mode
)
;
const
idString
=
child
?
#
{
child
.
id
}
:
"
"
;
dumpv
(
SetPauseState
{
mode
}
{
JSON
.
stringify
(
point
)
}
{
idString
}
)
;
gPauseMode
=
mode
;
gPausePoint
=
point
;
gActiveChild
=
child
;
if
(
mode
!
=
PauseModes
.
PAUSED
)
{
gDebuggerRequests
.
length
=
0
;
gSyncDebuggerRequests
=
false
;
}
if
(
mode
=
=
PauseModes
.
ARRIVING
)
{
updateNearbyPoints
(
)
;
}
pokeChildrenSoon
(
)
;
}
function
setReplayingPauseTarget
(
point
)
{
setPauseState
(
PauseModes
.
ARRIVING
point
closestChild
(
point
.
checkpoint
)
)
;
gDebugger
.
_onPause
(
)
;
findFrameSteps
(
point
)
;
}
function
pauseReplayingChild
(
child
point
)
{
do
{
child
.
waitUntilPaused
(
)
;
}
while
(
maybeReachPoint
(
child
point
)
)
;
setPauseState
(
PauseModes
.
PAUSED
point
child
)
;
}
function
sendChildToPausePoint
(
child
)
{
assert
(
child
.
paused
&
&
child
=
=
gActiveChild
)
;
switch
(
gPauseMode
)
{
case
PauseModes
.
PAUSED
:
assert
(
pointEquals
(
child
.
pausePoint
(
)
gPausePoint
)
)
;
return
;
case
PauseModes
.
ARRIVING
:
if
(
pointEquals
(
child
.
pausePoint
(
)
gPausePoint
)
)
{
setPauseState
(
PauseModes
.
PAUSED
gPausePoint
gActiveChild
)
;
}
else
{
maybeReachPoint
(
child
gPausePoint
)
;
}
return
;
default
:
throw
new
Error
(
Unexpected
pause
mode
:
{
gPauseMode
}
)
;
}
}
function
waitUntilPauseFinishes
(
)
{
assert
(
gActiveChild
)
;
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
return
;
}
while
(
true
)
{
gActiveChild
.
waitUntilPaused
(
)
;
if
(
pointEquals
(
gActiveChild
.
pausePoint
(
)
gPausePoint
)
)
{
return
;
}
pokeChild
(
gActiveChild
)
;
}
}
async
function
finishResume
(
)
{
assert
(
gPauseMode
=
=
PauseModes
.
RESUMING_FORWARD
|
|
gPauseMode
=
=
PauseModes
.
RESUMING_BACKWARD
)
;
const
forward
=
gPauseMode
=
=
PauseModes
.
RESUMING_FORWARD
;
let
startCheckpoint
=
gPausePoint
.
checkpoint
;
if
(
!
forward
&
&
!
gPausePoint
.
position
)
{
startCheckpoint
-
-
;
}
startCheckpoint
=
getSavedCheckpoint
(
startCheckpoint
)
;
let
checkpoint
=
startCheckpoint
;
for
(
;
;
forward
?
checkpoint
+
+
:
checkpoint
-
-
)
{
if
(
checkpoint
=
=
gLastFlushCheckpoint
)
{
assert
(
forward
)
;
RecordReplayControl
.
restoreMainGraphics
(
)
;
setPauseState
(
PauseModes
.
RUNNING
gMainChild
.
pausePoint
(
)
gMainChild
)
;
gDebugger
.
_callOnPositionChange
(
)
;
maybeResumeRecording
(
)
;
return
;
}
if
(
checkpoint
=
=
InvalidCheckpointId
)
{
assert
(
!
forward
)
;
setReplayingPauseTarget
(
checkpointExecutionPoint
(
FirstCheckpointId
)
)
;
return
;
}
if
(
!
gCheckpoints
[
checkpoint
]
.
saved
)
{
continue
;
}
let
hits
=
[
]
;
for
(
const
bp
of
gBreakpoints
)
{
if
(
canFindHits
(
bp
)
)
{
const
bphits
=
await
findHits
(
checkpoint
bp
)
;
hits
=
hits
.
concat
(
bphits
)
;
}
}
if
(
checkpoint
=
=
startCheckpoint
&
&
hasSteppingBreakpoint
(
)
)
{
const
steps
=
await
findFrameSteps
(
gPausePoint
)
;
hits
=
hits
.
concat
(
steps
.
filter
(
point
=
>
{
return
gBreakpoints
.
some
(
bp
=
>
positionSubsumes
(
bp
point
.
position
)
)
;
}
)
)
;
}
const
hit
=
findClosestPoint
(
hits
gPausePoint
!
forward
false
)
;
if
(
hit
)
{
setReplayingPauseTarget
(
hit
)
;
return
;
}
}
}
function
resume
(
forward
)
{
if
(
gActiveChild
.
recording
)
{
if
(
forward
)
{
maybeResumeRecording
(
)
;
return
;
}
}
if
(
gPausePoint
.
checkpoint
=
=
FirstCheckpointId
&
&
!
gPausePoint
.
position
&
&
!
forward
)
{
gDebugger
.
_onPause
(
)
;
return
;
}
setPauseState
(
forward
?
PauseModes
.
RESUMING_FORWARD
:
PauseModes
.
RESUMING_BACKWARD
gPausePoint
null
)
;
finishResume
(
)
;
pokeChildren
(
)
;
}
function
timeWarp
(
point
)
{
setReplayingPauseTarget
(
point
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
TimeWarpFinished
"
)
;
}
let
gNearbyPoints
=
[
]
;
const
NumNearbyBreakpointHits
=
2
;
const
NumNearbySteps
=
4
;
function
nextKnownBreakpointHit
(
point
forward
)
{
let
checkpoint
=
getSavedCheckpoint
(
point
.
checkpoint
)
;
for
(
;
;
forward
?
checkpoint
+
+
:
checkpoint
-
-
)
{
if
(
checkpoint
=
=
gLastFlushCheckpoint
|
|
checkpoint
=
=
InvalidCheckpointId
)
{
return
null
;
}
if
(
!
gCheckpoints
[
checkpoint
]
.
saved
)
{
continue
;
}
let
hits
=
[
]
;
for
(
const
bp
of
gBreakpoints
)
{
if
(
canFindHits
(
bp
)
)
{
const
bphits
=
findExistingHits
(
checkpoint
bp
)
;
if
(
bphits
)
{
hits
=
hits
.
concat
(
bphits
)
;
}
}
}
const
hit
=
findClosestPoint
(
hits
gPausePoint
!
forward
false
)
;
if
(
hit
)
{
return
hit
;
}
}
}
function
nextKnownBreakpointHits
(
point
forward
count
)
{
const
rv
=
[
]
;
for
(
let
i
=
0
;
i
<
count
;
i
+
+
)
{
const
next
=
nextKnownBreakpointHit
(
point
forward
)
;
if
(
next
)
{
rv
.
push
(
next
)
;
point
=
next
;
}
else
{
break
;
}
}
return
rv
;
}
function
updateNearbyPoints
(
)
{
const
nearby
=
[
.
.
.
nextKnownBreakpointHits
(
gPausePoint
true
NumNearbyBreakpointHits
)
.
.
.
nextKnownBreakpointHits
(
gPausePoint
false
NumNearbyBreakpointHits
)
]
;
const
steps
=
gPausePoint
.
position
&
&
findExistingFrameSteps
(
gPausePoint
)
;
if
(
steps
)
{
const
index
=
steps
.
findIndex
(
point
=
>
pointEquals
(
point
gPausePoint
)
)
;
const
start
=
Math
.
max
(
index
-
NumNearbySteps
1
)
;
nearby
.
push
(
.
.
.
steps
.
slice
(
start
index
+
NumNearbySteps
-
start
)
)
;
}
for
(
const
point
of
nearby
)
{
if
(
!
pointArrayIncludes
(
gNearbyPoints
point
)
)
{
queuePauseData
(
point
false
(
)
=
>
{
return
!
pointArrayIncludes
(
gNearbyPoints
point
)
;
}
)
;
}
}
gNearbyPoints
=
nearby
;
}
const
gLogpoints
=
[
]
;
async
function
findLogpointHits
(
checkpoint
{
position
text
condition
callback
}
)
{
const
hits
=
await
findHits
(
checkpoint
position
)
;
for
(
const
point
of
hits
)
{
if
(
!
condition
)
{
callback
(
point
{
return
:
"
Loading
.
.
.
"
}
)
;
}
sendAsyncManifest
(
{
shouldSkip
:
(
)
=
>
false
contents
(
)
{
return
{
kind
:
"
hitLogpoint
"
text
condition
}
;
}
onFinished
(
child
{
data
result
}
)
{
if
(
result
)
{
addPauseData
(
point
data
true
)
;
callback
(
point
gDebugger
.
_convertCompletionValue
(
result
)
)
;
}
child
.
divergedFromRecording
=
true
;
}
point
expectedDuration
:
250
lowPriority
:
true
}
)
;
}
}
function
handleResumeManifestResponse
(
{
point
duration
consoleMessages
scripts
}
)
{
if
(
!
point
.
position
)
{
addCheckpoint
(
point
.
checkpoint
-
1
duration
)
;
getCheckpointInfo
(
point
.
checkpoint
)
.
point
=
point
;
}
if
(
gDebugger
&
&
gDebugger
.
onConsoleMessage
)
{
consoleMessages
.
forEach
(
msg
=
>
gDebugger
.
onConsoleMessage
(
msg
)
)
;
}
if
(
gDebugger
)
{
scripts
.
forEach
(
script
=
>
gDebugger
.
_onNewScript
(
script
)
)
;
}
consoleMessages
.
forEach
(
msg
=
>
{
if
(
msg
.
executionPoint
)
{
queuePauseData
(
msg
.
executionPoint
true
)
;
}
}
)
;
}
function
maybeResumeRecording
(
)
{
if
(
gActiveChild
!
=
gMainChild
)
{
return
;
}
if
(
!
gLastFlushCheckpoint
|
|
timeSinceCheckpoint
(
gLastFlushCheckpoint
)
>
=
FlushMs
)
{
ensureFlushed
(
)
;
}
const
checkpoint
=
gMainChild
.
pausePoint
(
)
.
checkpoint
;
if
(
!
gMainChild
.
recording
&
&
checkpoint
=
=
gRecordingEndpoint
)
{
ensureFlushed
(
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
HitRecordingEndpoint
"
)
;
if
(
gDebugger
)
{
gDebugger
.
_onPause
(
)
;
}
return
;
}
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
resume
"
breakpoints
:
gBreakpoints
}
onFinished
(
response
)
{
handleResumeManifestResponse
(
response
)
;
gPausePoint
=
gMainChild
.
pausePoint
(
)
;
if
(
gDebugger
)
{
gDebugger
.
_onPause
(
)
;
}
else
{
Services
.
tm
.
dispatchToMainThread
(
maybeResumeRecording
)
;
}
}
}
)
;
}
const
gFlushWaiters
=
[
]
;
function
waitForFlushed
(
checkpoint
)
{
if
(
checkpoint
<
gLastFlushCheckpoint
)
{
return
undefined
;
}
return
new
Promise
(
resolve
=
>
{
gFlushWaiters
.
push
(
resolve
)
;
}
)
;
}
let
gLastFlushTime
=
Date
.
now
(
)
;
function
ensureFlushed
(
)
{
assert
(
gActiveChild
=
=
gMainChild
)
;
gMainChild
.
waitUntilPaused
(
true
)
;
gLastFlushTime
=
Date
.
now
(
)
;
if
(
gLastFlushCheckpoint
=
=
gActiveChild
.
pauseCheckpoint
(
)
)
{
return
;
}
if
(
gMainChild
.
recording
)
{
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
flushRecording
"
}
onFinished
(
)
{
}
}
)
;
gMainChild
.
waitUntilPaused
(
)
;
}
const
oldFlushCheckpoint
=
gLastFlushCheckpoint
|
|
FirstCheckpointId
;
gLastFlushCheckpoint
=
gMainChild
.
pauseCheckpoint
(
)
;
if
(
gReplayingChildren
.
length
=
=
0
)
{
spawnReplayingChildren
(
)
;
}
addSavedCheckpoint
(
gLastFlushCheckpoint
)
;
forSavedCheckpointsInRange
(
oldFlushCheckpoint
gLastFlushCheckpoint
checkpoint
=
>
{
scanRecording
(
checkpoint
)
;
gBreakpoints
.
forEach
(
position
=
>
findBreakpointHits
(
checkpoint
position
)
)
;
gLogpoints
.
forEach
(
logpoint
=
>
findLogpointHits
(
checkpoint
logpoint
)
)
;
}
)
;
for
(
const
waiter
of
gFlushWaiters
)
{
waiter
(
)
;
}
gFlushWaiters
.
length
=
0
;
pokeChildren
(
)
;
}
const
CheckFlushMs
=
1000
;
setInterval
(
(
)
=
>
{
const
elapsed
=
Date
.
now
(
)
-
gLastFlushTime
;
if
(
elapsed
>
CheckFlushMs
&
&
gMainChild
.
lastPausePoint
&
&
gMainChild
.
lastPausePoint
.
checkpoint
!
=
gLastFlushCheckpoint
)
{
ensureFlushed
(
)
;
}
}
CheckFlushMs
)
;
function
BeforeSaveRecording
(
)
{
if
(
gActiveChild
=
=
gMainChild
)
{
ensureFlushed
(
)
;
}
}
function
AfterSaveRecording
(
)
{
Services
.
cpmm
.
sendAsyncMessage
(
"
SaveRecordingFinished
"
)
;
}
let
gRecordingEndpoint
;
function
setMainChild
(
)
{
assert
(
!
gMainChild
.
recording
)
;
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
setMainChild
"
}
onFinished
(
{
endpoint
}
)
{
gRecordingEndpoint
=
endpoint
;
Services
.
tm
.
dispatchToMainThread
(
maybeResumeRecording
)
;
}
}
)
;
}
const
NumReplayingChildren
=
4
;
function
spawnReplayingChildren
(
)
{
for
(
let
i
=
0
;
i
<
NumReplayingChildren
;
i
+
+
)
{
const
id
=
RecordReplayControl
.
spawnReplayingChild
(
)
;
gReplayingChildren
[
id
]
=
new
ChildProcess
(
id
false
)
;
}
addSavedCheckpoint
(
FirstCheckpointId
)
;
}
function
Initialize
(
recordingChildId
)
{
try
{
if
(
recordingChildId
!
=
undefined
)
{
gMainChild
=
new
ChildProcess
(
recordingChildId
true
)
;
}
else
{
const
id
=
RecordReplayControl
.
spawnReplayingChild
(
)
;
gMainChild
=
new
ChildProcess
(
id
false
)
;
spawnReplayingChildren
(
)
;
}
gActiveChild
=
gMainChild
;
return
gControl
;
}
catch
(
e
)
{
dump
(
ERROR
:
Initialize
threw
exception
:
{
e
}
\
n
)
;
}
}
function
ManifestFinished
(
id
response
)
{
try
{
dumpv
(
ManifestFinished
#
{
id
}
{
stringify
(
response
)
}
)
;
lookupChild
(
id
)
.
manifestFinished
(
response
)
;
}
catch
(
e
)
{
dump
(
ERROR
:
ManifestFinished
threw
exception
:
{
e
}
{
e
.
stack
}
\
n
)
;
}
}
const
gControl
=
{
pausePoint
(
)
{
if
(
gActiveChild
&
&
gActiveChild
=
=
gMainChild
)
{
return
gActiveChild
.
paused
?
gActiveChild
.
pausePoint
(
)
:
null
;
}
if
(
gPauseMode
=
=
PauseModes
.
PAUSED
|
|
gPauseMode
=
=
PauseModes
.
ARRIVING
)
{
return
gPausePoint
;
}
return
null
;
}
lastPausePoint
(
)
{
return
gPausePoint
;
}
childIsRecording
(
)
{
return
gActiveChild
&
&
gActiveChild
.
recording
;
}
waitUntilPaused
(
)
{
assert
(
gActiveChild
)
;
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
}
}
addBreakpoint
(
position
)
{
gBreakpoints
.
push
(
position
)
;
if
(
canFindHits
(
position
)
)
{
forSavedCheckpointsInRange
(
FirstCheckpointId
gLastFlushCheckpoint
checkpoint
=
>
findBreakpointHits
(
checkpoint
position
)
)
;
}
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
}
updateNearbyPoints
(
)
;
}
clearBreakpoints
(
)
{
gBreakpoints
.
length
=
0
;
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
}
updateNearbyPoints
(
)
;
}
recordingEndpoint
(
)
{
return
gMainChild
.
lastPausePoint
;
}
maybeSwitchToReplayingChild
(
)
{
assert
(
gControl
.
pausePoint
(
)
)
;
if
(
gActiveChild
=
=
gMainChild
&
&
RecordReplayControl
.
canRewind
(
)
)
{
const
point
=
gActiveChild
.
pausePoint
(
)
;
if
(
point
.
position
)
{
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
resume
"
breakpoints
:
[
]
}
onFinished
(
response
)
{
handleResumeManifestResponse
(
response
)
;
}
}
)
;
gMainChild
.
waitUntilPaused
(
true
)
;
}
ensureFlushed
(
)
;
const
child
=
closestChild
(
point
)
;
pauseReplayingChild
(
child
point
)
;
}
}
sendRequest
(
request
)
{
waitUntilPauseFinishes
(
)
;
if
(
gSyncDebuggerRequests
)
{
gActiveChild
.
sendManifest
(
{
contents
:
{
kind
:
"
batchDebuggerRequest
"
requests
:
gDebuggerRequests
}
onFinished
(
finishData
)
{
assert
(
!
finishData
|
|
!
finishData
.
restoredCheckpoint
)
;
}
}
)
;
gActiveChild
.
waitUntilPaused
(
)
;
gSyncDebuggerRequests
=
false
;
}
let
data
;
gActiveChild
.
sendManifest
(
{
contents
:
{
kind
:
"
debuggerRequest
"
request
}
onFinished
(
finishData
)
{
data
=
finishData
;
}
}
)
;
gActiveChild
.
waitUntilPaused
(
)
;
if
(
data
.
restoredCheckpoint
)
{
pauseReplayingChild
(
gActiveChild
gPausePoint
)
;
gActiveChild
.
sendManifest
(
{
contents
:
{
kind
:
"
batchDebuggerRequest
"
requests
:
gDebuggerRequests
}
onFinished
(
finishData
)
{
assert
(
!
finishData
|
|
!
finishData
.
restoredCheckpoint
)
;
}
}
)
;
gActiveChild
.
waitUntilPaused
(
)
;
return
{
unhandledDivergence
:
true
}
;
}
if
(
data
.
divergedFromRecording
)
{
gActiveChild
.
divergedFromRecording
=
true
;
}
gDebuggerRequests
.
push
(
request
)
;
return
data
.
response
;
}
sendRequestMainChild
(
request
)
{
gMainChild
.
waitUntilPaused
(
true
)
;
let
data
;
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
debuggerRequest
"
request
}
onFinished
(
finishData
)
{
data
=
finishData
;
}
}
)
;
gMainChild
.
waitUntilPaused
(
)
;
assert
(
!
data
.
restoredCheckpoint
&
&
!
data
.
divergedFromRecording
)
;
return
data
.
response
;
}
resume
timeWarp
addLogpoint
(
logpoint
)
{
gLogpoints
.
push
(
logpoint
)
;
forSavedCheckpointsInRange
(
FirstCheckpointId
gLastFlushCheckpoint
checkpoint
=
>
findLogpointHits
(
checkpoint
logpoint
)
)
;
}
unscannedRegions
cachedPoints
getPauseData
(
)
{
if
(
!
gDebuggerRequests
.
length
)
{
assert
(
!
gSyncDebuggerRequests
)
;
const
data
=
maybeGetPauseData
(
gPausePoint
)
;
if
(
data
)
{
gSyncDebuggerRequests
=
true
;
gDebuggerRequests
.
push
(
{
type
:
"
pauseData
"
}
)
;
return
data
;
}
}
gControl
.
maybeSwitchToReplayingChild
(
)
;
return
gControl
.
sendRequest
(
{
type
:
"
pauseData
"
}
)
;
}
repaint
(
)
{
if
(
!
gPausePoint
)
{
return
;
}
if
(
gMainChild
.
paused
&
&
pointEquals
(
gPausePoint
gMainChild
.
pausePoint
(
)
)
)
{
if
(
gMainChild
.
recording
)
{
ensureFlushed
(
)
;
}
return
;
}
const
data
=
maybeGetPauseData
(
gPausePoint
)
;
if
(
data
&
&
data
.
paintData
)
{
RecordReplayControl
.
hadRepaint
(
data
.
paintData
)
;
}
else
{
gControl
.
maybeSwitchToReplayingChild
(
)
;
const
rv
=
gControl
.
sendRequest
(
{
type
:
"
repaint
"
}
)
;
if
(
rv
&
&
rv
.
length
)
{
RecordReplayControl
.
hadRepaint
(
rv
)
;
}
else
{
RecordReplayControl
.
clearGraphics
(
)
;
}
}
}
}
;
let
lastDumpTime
=
Date
.
now
(
)
;
function
maybeDumpStatistics
(
)
{
const
now
=
Date
.
now
(
)
;
if
(
now
-
lastDumpTime
<
5000
)
{
return
;
}
lastDumpTime
=
now
;
let
delayTotal
=
0
;
let
unscannedTotal
=
0
;
let
timeTotal
=
0
;
let
scanDurationTotal
=
0
;
forSavedCheckpointsInRange
(
FirstCheckpointId
gLastFlushCheckpoint
checkpoint
=
>
{
const
checkpointTime
=
timeForSavedCheckpoint
(
checkpoint
)
;
const
info
=
getCheckpointInfo
(
checkpoint
)
;
timeTotal
+
=
checkpointTime
;
if
(
info
.
scanTime
)
{
delayTotal
+
=
checkpointTime
*
(
info
.
scanTime
-
info
.
assignTime
)
;
scanDurationTotal
+
=
info
.
scanDuration
;
}
else
{
unscannedTotal
+
=
checkpointTime
;
}
}
)
;
const
memoryUsage
=
[
]
;
let
totalSaved
=
0
;
for
(
const
child
of
gReplayingChildren
)
{
if
(
!
child
)
{
continue
;
}
totalSaved
+
=
child
.
savedCheckpoints
.
size
;
if
(
!
child
.
lastMemoryUsage
)
{
continue
;
}
for
(
const
[
name
value
]
of
Object
.
entries
(
child
.
lastMemoryUsage
)
)
{
if
(
!
memoryUsage
[
name
]
)
{
memoryUsage
[
name
]
=
0
;
}
memoryUsage
[
name
]
+
=
value
;
}
}
const
delay
=
delayTotal
/
timeTotal
;
const
overhead
=
scanDurationTotal
/
(
timeTotal
-
unscannedTotal
)
;
dumpv
(
Statistics
:
)
;
dumpv
(
Total
recording
time
:
{
timeTotal
}
)
;
dumpv
(
Unscanned
fraction
:
{
unscannedTotal
/
timeTotal
}
)
;
dumpv
(
Average
scan
delay
:
{
delay
}
)
;
dumpv
(
Average
scanning
overhead
:
{
overhead
}
)
;
dumpv
(
Saved
checkpoints
:
{
totalSaved
}
)
;
for
(
const
[
name
value
]
of
Object
.
entries
(
memoryUsage
)
)
{
dumpv
(
Memory
{
name
}
:
{
value
}
)
;
}
}
function
ConnectDebugger
(
dbg
)
{
gDebugger
=
dbg
;
dbg
.
_control
=
gControl
;
}
const
startTime
=
Date
.
now
(
)
;
function
currentTime
(
)
{
return
(
(
(
Date
.
now
(
)
-
startTime
)
/
10
)
|
0
)
/
100
;
}
function
dumpv
(
str
)
{
}
function
assert
(
v
)
{
if
(
!
v
)
{
ThrowError
(
"
Assertion
Failed
!
"
)
;
}
}
function
ThrowError
(
msg
)
{
const
error
=
new
Error
(
msg
)
;
dump
(
ReplayControl
Server
Error
:
{
msg
}
Stack
:
{
error
.
stack
}
\
n
)
;
throw
error
;
}
function
stringify
(
object
)
{
const
str
=
JSON
.
stringify
(
object
)
;
if
(
str
&
&
str
.
length
>
=
4096
)
{
return
{
str
.
substr
(
0
4096
)
}
TRIMMED
{
str
.
length
}
;
}
return
str
;
}
var
EXPORTED_SYMBOLS
=
[
"
Initialize
"
"
ConnectDebugger
"
"
ManifestFinished
"
"
BeforeSaveRecording
"
"
AfterSaveRecording
"
]
;
