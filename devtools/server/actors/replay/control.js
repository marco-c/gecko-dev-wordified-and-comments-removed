"
use
strict
"
;
const
CC
=
Components
.
Constructor
;
const
sandbox
=
Cu
.
Sandbox
(
CC
(
"
mozilla
.
org
/
systemprincipal
;
1
"
"
nsIPrincipal
"
)
(
)
)
;
Cu
.
evalInSandbox
(
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
'
)
;
"
+
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
)
;
"
+
"
Components
.
utils
.
import
(
'
resource
:
/
/
devtools
/
shared
/
execution
-
point
-
utils
.
js
'
)
;
"
+
"
addDebuggerToGlobal
(
this
)
;
"
sandbox
)
;
const
{
RecordReplayControl
Services
pointPrecedes
pointEquals
positionEquals
positionSubsumes
}
=
sandbox
;
const
InvalidCheckpointId
=
0
;
const
FirstCheckpointId
=
1
;
function
ChildProcess
(
id
recording
)
{
this
.
id
=
id
;
this
.
recording
=
recording
;
this
.
paused
=
false
;
this
.
lastPausePoint
=
null
;
this
.
asyncManifests
=
[
]
;
this
.
savedCheckpoints
=
new
Set
(
recording
?
[
]
:
[
FirstCheckpointId
]
)
;
this
.
scannedCheckpoints
=
new
Set
(
)
;
this
.
needSaveCheckpoints
=
[
]
;
this
.
divergedFromRecording
=
false
;
this
.
manifest
=
{
onFinished
:
(
{
point
}
)
=
>
{
if
(
this
=
=
gMainChild
)
{
getCheckpointInfo
(
FirstCheckpointId
)
.
point
=
point
;
Services
.
tm
.
dispatchToMainThread
(
recording
?
maybeResumeRecording
:
setMainChild
)
;
}
}
}
;
}
ChildProcess
.
prototype
=
{
pausePoint
(
)
{
assert
(
this
.
paused
)
;
return
this
.
lastPausePoint
;
}
pauseCheckpoint
(
)
{
const
point
=
this
.
pausePoint
(
)
;
assert
(
!
point
.
position
)
;
return
point
.
checkpoint
;
}
sendManifest
(
manifest
)
{
assert
(
this
.
paused
)
;
this
.
paused
=
false
;
this
.
manifest
=
manifest
;
dumpv
(
SendManifest
#
{
this
.
id
}
{
JSON
.
stringify
(
manifest
.
contents
)
}
)
;
RecordReplayControl
.
sendManifest
(
this
.
id
manifest
.
contents
)
;
}
manifestFinished
(
response
)
{
assert
(
!
this
.
paused
)
;
if
(
response
&
&
response
.
point
)
{
this
.
lastPausePoint
=
response
.
point
;
}
this
.
paused
=
true
;
this
.
manifest
.
onFinished
(
response
)
;
this
.
manifest
=
null
;
}
waitUntilPaused
(
maybeCreateCheckpoint
)
{
if
(
this
.
paused
)
{
return
;
}
RecordReplayControl
.
waitUntilPaused
(
this
.
id
maybeCreateCheckpoint
)
;
assert
(
this
.
paused
)
;
}
addSavedCheckpoint
(
checkpoint
)
{
dumpv
(
AddSavedCheckpoint
#
{
this
.
id
}
{
checkpoint
}
)
;
this
.
savedCheckpoints
.
add
(
checkpoint
)
;
if
(
checkpoint
!
=
FirstCheckpointId
)
{
this
.
needSaveCheckpoints
.
push
(
checkpoint
)
;
}
}
flushNeedSaveCheckpoints
(
)
{
const
rv
=
this
.
needSaveCheckpoints
;
this
.
needSaveCheckpoints
=
[
]
;
return
rv
;
}
sendManifestAsync
(
manifest
point
)
{
pokeChildSoon
(
this
)
;
return
new
Promise
(
resolve
=
>
{
this
.
asyncManifests
.
push
(
{
resolve
manifest
point
}
)
;
}
)
;
}
processAsyncManifest
(
)
{
if
(
this
.
asyncManifests
.
length
=
=
0
)
{
return
false
;
}
const
{
resolve
manifest
point
}
=
this
.
asyncManifests
[
0
]
;
if
(
manifest
.
shouldSkip
&
&
manifest
.
shouldSkip
(
this
)
)
{
resolve
(
this
)
;
this
.
asyncManifests
.
shift
(
)
;
pokeChildSoon
(
this
)
;
return
true
;
}
if
(
this
=
=
gActiveChild
&
&
!
manifest
.
noReassign
)
{
const
child
=
pickReplayingChild
(
)
;
child
.
asyncManifests
.
push
(
this
.
asyncManifests
.
shift
(
)
)
;
pokeChildSoon
(
child
)
;
pokeChildSoon
(
this
)
;
return
true
;
}
if
(
point
&
&
maybeReachPoint
(
this
point
)
)
{
return
true
;
}
this
.
sendManifest
(
{
contents
:
manifest
.
contents
(
this
)
onFinished
:
data
=
>
{
if
(
manifest
.
onFinished
)
{
manifest
.
onFinished
(
this
data
)
;
}
resolve
(
this
)
;
pokeChildSoon
(
this
)
;
}
}
)
;
this
.
asyncManifests
.
shift
(
)
;
if
(
this
=
=
gActiveChild
)
{
this
.
waitUntilPaused
(
)
;
}
return
true
;
}
}
;
let
gMainChild
;
const
gReplayingChildren
=
[
]
;
function
lookupChild
(
id
)
{
if
(
id
=
=
gMainChild
.
id
)
{
return
gMainChild
;
}
assert
(
gReplayingChildren
[
id
]
)
;
return
gReplayingChildren
[
id
]
;
}
let
lastPickedChildId
=
0
;
function
pickReplayingChild
(
)
{
while
(
true
)
{
lastPickedChildId
=
(
lastPickedChildId
+
1
)
%
gReplayingChildren
.
length
;
const
child
=
gReplayingChildren
[
lastPickedChildId
]
;
if
(
child
)
{
return
child
;
}
}
}
let
gDebugger
;
let
gActiveChild
=
null
;
const
gCheckpoints
=
[
null
]
;
function
CheckpointInfo
(
)
{
this
.
duration
=
0
;
this
.
point
=
null
;
this
.
owner
=
null
;
}
function
getCheckpointInfo
(
id
)
{
while
(
id
>
=
gCheckpoints
.
length
)
{
gCheckpoints
.
push
(
new
CheckpointInfo
(
)
)
;
}
return
gCheckpoints
[
id
]
;
}
function
timeSinceCheckpoint
(
id
)
{
let
time
=
0
;
for
(
let
i
=
id
?
id
:
FirstCheckpointId
;
i
<
gCheckpoints
.
length
;
i
+
+
)
{
time
+
=
gCheckpoints
[
i
]
.
duration
;
}
return
time
;
}
let
gLastFlushCheckpoint
=
InvalidCheckpointId
;
const
FlushMs
=
0
.
5
*
1000
;
function
addSavedCheckpoint
(
checkpoint
)
{
if
(
getCheckpointInfo
(
checkpoint
)
.
owner
)
{
return
;
}
const
owner
=
pickReplayingChild
(
)
;
getCheckpointInfo
(
checkpoint
)
.
owner
=
owner
;
owner
.
addSavedCheckpoint
(
checkpoint
)
;
}
function
addCheckpoint
(
checkpoint
duration
)
{
assert
(
!
getCheckpointInfo
(
checkpoint
)
.
duration
)
;
getCheckpointInfo
(
checkpoint
)
.
duration
=
duration
;
}
function
ownerChild
(
checkpoint
)
{
while
(
!
getCheckpointInfo
(
checkpoint
)
.
owner
)
{
checkpoint
-
-
;
}
return
getCheckpointInfo
(
checkpoint
)
.
owner
;
}
function
restoreCheckpoint
(
child
target
)
{
while
(
!
child
.
savedCheckpoints
.
has
(
target
)
)
{
target
-
-
;
}
child
.
sendManifest
(
{
contents
:
{
kind
:
"
restoreCheckpoint
"
target
}
onFinished
(
{
restoredCheckpoint
}
)
{
assert
(
restoredCheckpoint
)
;
child
.
divergedFromRecording
=
false
;
pokeChildSoon
(
child
)
;
}
}
)
;
}
function
maybeReachPoint
(
child
endpoint
)
{
if
(
pointEquals
(
child
.
pausePoint
(
)
endpoint
)
&
&
!
child
.
divergedFromRecording
)
{
return
false
;
}
if
(
child
.
divergedFromRecording
|
|
child
.
pausePoint
(
)
.
position
)
{
restoreCheckpoint
(
child
child
.
pausePoint
(
)
.
checkpoint
)
;
return
true
;
}
if
(
endpoint
.
checkpoint
<
child
.
pauseCheckpoint
(
)
)
{
restoreCheckpoint
(
child
endpoint
.
checkpoint
)
;
return
true
;
}
child
.
sendManifest
(
{
contents
:
{
kind
:
"
runToPoint
"
endpoint
needSaveCheckpoints
:
child
.
flushNeedSaveCheckpoints
(
)
}
onFinished
(
)
{
pokeChildSoon
(
child
)
;
}
}
)
;
return
true
;
}
function
nextSavedCheckpoint
(
checkpoint
)
{
assert
(
gCheckpoints
[
checkpoint
]
.
owner
)
;
while
(
!
gCheckpoints
[
+
+
checkpoint
]
.
owner
)
{
}
return
checkpoint
;
}
function
forSavedCheckpointsInRange
(
start
end
callback
)
{
assert
(
gCheckpoints
[
start
]
.
owner
)
;
for
(
let
checkpoint
=
start
;
checkpoint
<
end
;
checkpoint
=
nextSavedCheckpoint
(
checkpoint
)
)
{
callback
(
checkpoint
)
;
}
}
function
getSavedCheckpoint
(
checkpoint
)
{
while
(
!
gCheckpoints
[
checkpoint
]
.
owner
)
{
checkpoint
-
-
;
}
return
checkpoint
;
}
function
checkpointExecutionPoint
(
checkpoint
)
{
return
gCheckpoints
[
checkpoint
]
.
point
;
}
function
pokeChild
(
child
)
{
assert
(
!
child
.
recording
)
;
if
(
!
child
.
paused
)
{
return
;
}
if
(
child
.
processAsyncManifest
(
)
)
{
return
;
}
if
(
child
=
=
gActiveChild
)
{
sendChildToPausePoint
(
child
)
;
return
;
}
maybeReachPoint
(
child
checkpointExecutionPoint
(
gLastFlushCheckpoint
)
)
;
}
function
pokeChildSoon
(
child
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
pokeChild
(
child
)
)
;
}
function
pokeChildren
(
)
{
for
(
const
child
of
gReplayingChildren
)
{
if
(
child
)
{
pokeChild
(
child
)
;
}
}
}
function
pokeChildrenSoon
(
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
pokeChildren
(
)
)
;
}
const
gBreakpoints
=
[
]
;
function
scanRecording
(
checkpoint
)
{
assert
(
checkpoint
<
gLastFlushCheckpoint
)
;
for
(
const
child
of
gReplayingChildren
)
{
if
(
child
&
&
child
.
scannedCheckpoints
.
has
(
checkpoint
)
)
{
return
child
;
}
}
const
initialChild
=
ownerChild
(
checkpoint
)
;
const
endpoint
=
nextSavedCheckpoint
(
checkpoint
)
;
return
initialChild
.
sendManifestAsync
(
{
shouldSkip
:
child
=
>
child
.
scannedCheckpoints
.
has
(
checkpoint
)
contents
(
child
)
{
return
{
kind
:
"
scanRecording
"
endpoint
needSaveCheckpoints
:
child
.
flushNeedSaveCheckpoints
(
)
}
;
}
onFinished
:
child
=
>
child
.
scannedCheckpoints
.
add
(
checkpoint
)
}
checkpointExecutionPoint
(
checkpoint
)
)
;
}
const
gHitSearches
=
new
Map
(
)
;
function
canFindHits
(
position
)
{
return
position
.
kind
=
=
"
Break
"
|
|
position
.
kind
=
=
"
OnStep
"
;
}
async
function
findHits
(
checkpoint
position
)
{
assert
(
canFindHits
(
position
)
)
;
assert
(
gCheckpoints
[
checkpoint
]
.
owner
)
;
if
(
!
gHitSearches
.
has
(
checkpoint
)
)
{
gHitSearches
.
set
(
checkpoint
[
]
)
;
}
if
(
!
gHitSearches
.
has
(
checkpoint
)
)
{
gHitSearches
.
set
(
checkpoint
[
]
)
;
}
const
checkpointHits
=
gHitSearches
.
get
(
checkpoint
)
;
let
hits
=
findExistingHits
(
)
;
if
(
hits
)
{
return
hits
;
}
const
child
=
await
scanRecording
(
checkpoint
)
;
const
endpoint
=
nextSavedCheckpoint
(
checkpoint
)
;
await
child
.
sendManifestAsync
(
{
shouldSkip
:
(
)
=
>
findExistingHits
(
)
!
=
null
contents
(
)
{
return
{
kind
:
"
findHits
"
position
startpoint
:
checkpoint
endpoint
}
;
}
onFinished
:
(
_
hits
)
=
>
checkpointHits
.
push
(
{
position
hits
}
)
noReassign
:
true
}
)
;
hits
=
findExistingHits
(
)
;
assert
(
hits
)
;
return
hits
;
function
findExistingHits
(
)
{
const
entry
=
checkpointHits
.
find
(
(
{
position
:
existingPosition
hits
}
)
=
>
{
return
positionEquals
(
position
existingPosition
)
;
}
)
;
return
entry
?
entry
.
hits
:
null
;
}
}
const
gFrameSteps
=
[
]
;
function
hasSteppingBreakpoint
(
)
{
return
gBreakpoints
.
some
(
bp
=
>
bp
.
kind
=
=
"
EnterFrame
"
|
|
bp
.
kind
=
=
"
OnPop
"
)
;
}
async
function
findFrameSteps
(
point
)
{
if
(
!
point
.
position
)
{
return
null
;
}
assert
(
point
.
position
.
kind
=
=
"
EnterFrame
"
|
|
point
.
position
.
kind
=
=
"
OnStep
"
|
|
point
.
position
.
kind
=
=
"
OnPop
"
)
;
let
steps
=
findExistingSteps
(
)
;
if
(
steps
)
{
return
steps
;
}
const
savedCheckpoint
=
getSavedCheckpoint
(
point
.
checkpoint
)
;
let
entryPoint
;
if
(
point
.
position
.
kind
=
=
"
EnterFrame
"
)
{
entryPoint
=
point
;
}
else
{
const
{
progress
:
targetProgress
position
:
{
script
frameIndex
:
targetFrameIndex
}
}
=
point
;
const
{
firstBreakpointOffset
}
=
gControl
.
sendRequestMainChild
(
{
type
:
"
getScript
"
id
:
script
}
)
;
const
entryPosition
=
{
kind
:
"
OnStep
"
script
offset
:
firstBreakpointOffset
frameIndex
:
targetFrameIndex
}
;
const
entryHits
=
await
findHits
(
savedCheckpoint
entryPosition
)
;
let
progressAtFrameStart
=
0
;
for
(
const
{
progress
position
:
{
frameIndex
}
}
of
entryHits
)
{
if
(
frameIndex
=
=
targetFrameIndex
&
&
progress
<
=
targetProgress
&
&
progress
>
progressAtFrameStart
)
{
progressAtFrameStart
=
progress
;
}
}
assert
(
progressAtFrameStart
)
;
entryPoint
=
{
checkpoint
:
point
.
checkpoint
progress
:
progressAtFrameStart
position
:
{
kind
:
"
EnterFrame
"
}
}
;
}
const
child
=
ownerChild
(
savedCheckpoint
)
;
await
child
.
sendManifestAsync
(
{
shouldSkip
:
(
)
=
>
findExistingSteps
(
)
!
=
null
contents
(
)
{
return
{
kind
:
"
findFrameSteps
"
entryPoint
}
;
}
onFinished
:
(
_
{
frameSteps
}
)
=
>
gFrameSteps
.
push
(
frameSteps
)
}
entryPoint
)
;
steps
=
findExistingSteps
(
)
;
assert
(
steps
)
;
return
steps
;
function
findExistingSteps
(
)
{
if
(
point
.
position
.
kind
=
=
"
EnterFrame
"
)
{
return
gFrameSteps
.
find
(
steps
=
>
pointEquals
(
point
steps
[
0
]
)
)
;
}
return
gFrameSteps
.
find
(
steps
=
>
steps
.
some
(
p
=
>
pointEquals
(
point
p
)
)
)
;
}
}
const
PauseModes
=
{
RUNNING
:
"
RUNNING
"
PAUSED
:
"
PAUSED
"
ARRIVING
:
"
ARRIVING
"
RESUMING_BACKWARD
:
"
RESUMING_BACKWARD
"
RESUMING_FORWARD
:
"
RESUMING_FORWARD
"
}
;
let
gPauseMode
=
PauseModes
.
RUNNING
;
let
gPausePoint
=
null
;
const
gDebuggerRequests
=
[
]
;
function
setPauseState
(
mode
point
child
)
{
assert
(
mode
)
;
const
idString
=
child
?
#
{
child
.
id
}
:
"
"
;
dumpv
(
SetPauseState
{
mode
}
{
JSON
.
stringify
(
point
)
}
{
idString
}
)
;
gPauseMode
=
mode
;
gPausePoint
=
point
;
gActiveChild
=
child
;
pokeChildrenSoon
(
)
;
}
function
setReplayingPauseTarget
(
point
)
{
setPauseState
(
PauseModes
.
ARRIVING
point
ownerChild
(
point
.
checkpoint
)
)
;
gDebuggerRequests
.
length
=
0
;
findFrameSteps
(
point
)
;
}
function
pauseReplayingChild
(
point
)
{
const
child
=
ownerChild
(
point
.
checkpoint
)
;
do
{
child
.
waitUntilPaused
(
)
;
}
while
(
maybeReachPoint
(
child
point
)
)
;
setPauseState
(
PauseModes
.
PAUSED
point
child
)
;
findFrameSteps
(
point
)
;
}
function
sendChildToPausePoint
(
child
)
{
assert
(
child
.
paused
&
&
child
=
=
gActiveChild
)
;
switch
(
gPauseMode
)
{
case
PauseModes
.
PAUSED
:
assert
(
pointEquals
(
child
.
pausePoint
(
)
gPausePoint
)
)
;
return
;
case
PauseModes
.
ARRIVING
:
if
(
pointEquals
(
child
.
pausePoint
(
)
gPausePoint
)
)
{
setPauseState
(
PauseModes
.
PAUSED
gPausePoint
gActiveChild
)
;
gDebugger
.
_onPause
(
)
;
return
;
}
maybeReachPoint
(
child
gPausePoint
)
;
return
;
default
:
throw
new
Error
(
Unexpected
pause
mode
:
{
gPauseMode
}
)
;
}
}
async
function
finishResume
(
)
{
assert
(
gPauseMode
=
=
PauseModes
.
RESUMING_FORWARD
|
|
gPauseMode
=
=
PauseModes
.
RESUMING_BACKWARD
)
;
const
forward
=
gPauseMode
=
=
PauseModes
.
RESUMING_FORWARD
;
let
startCheckpoint
=
gPausePoint
.
checkpoint
;
if
(
!
forward
&
&
!
gPausePoint
.
position
)
{
startCheckpoint
-
-
;
}
startCheckpoint
=
getSavedCheckpoint
(
startCheckpoint
)
;
let
checkpoint
=
startCheckpoint
;
for
(
;
;
forward
?
checkpoint
+
+
:
checkpoint
-
-
)
{
if
(
checkpoint
=
=
gMainChild
.
pauseCheckpoint
(
)
)
{
assert
(
forward
)
;
setPauseState
(
PauseModes
.
RUNNING
null
gMainChild
)
;
maybeResumeRecording
(
)
;
return
;
}
if
(
checkpoint
=
=
InvalidCheckpointId
)
{
assert
(
!
forward
)
;
setReplayingPauseTarget
(
checkpointExecutionPoint
(
FirstCheckpointId
)
)
;
return
;
}
if
(
!
gCheckpoints
[
checkpoint
]
.
owner
)
{
continue
;
}
let
hits
=
[
]
;
for
(
const
bp
of
gBreakpoints
)
{
if
(
canFindHits
(
bp
)
)
{
const
bphits
=
await
findHits
(
checkpoint
bp
)
;
hits
=
hits
.
concat
(
bphits
)
;
}
}
if
(
checkpoint
=
=
startCheckpoint
&
&
hasSteppingBreakpoint
(
)
)
{
const
steps
=
await
findFrameSteps
(
gPausePoint
)
;
hits
=
hits
.
concat
(
steps
.
filter
(
point
=
>
{
return
gBreakpoints
.
some
(
bp
=
>
positionSubsumes
(
bp
point
.
position
)
)
;
}
)
)
;
}
if
(
forward
)
{
hits
=
hits
.
filter
(
p
=
>
pointPrecedes
(
gPausePoint
p
)
)
;
}
else
{
hits
=
hits
.
filter
(
p
=
>
pointPrecedes
(
p
gPausePoint
)
)
;
}
if
(
hits
.
length
)
{
hits
.
sort
(
(
a
b
)
=
>
forward
?
pointPrecedes
(
b
a
)
:
pointPrecedes
(
a
b
)
)
;
setReplayingPauseTarget
(
hits
[
0
]
)
;
return
;
}
}
}
function
resume
(
forward
)
{
if
(
gActiveChild
.
recording
)
{
if
(
forward
)
{
maybeResumeRecording
(
)
;
return
;
}
}
if
(
gPausePoint
.
checkpoint
=
=
FirstCheckpointId
&
&
!
gPausePoint
.
position
&
&
!
forward
)
{
gDebugger
.
_onPause
(
)
;
return
;
}
setPauseState
(
forward
?
PauseModes
.
RESUMING_FORWARD
:
PauseModes
.
RESUMING_BACKWARD
gActiveChild
.
pausePoint
(
)
null
)
;
finishResume
(
)
;
pokeChildren
(
)
;
}
function
timeWarp
(
point
)
{
setReplayingPauseTarget
(
point
)
;
while
(
gPauseMode
!
=
PauseModes
.
PAUSED
)
{
gActiveChild
.
waitUntilPaused
(
)
;
pokeChildren
(
)
;
}
Services
.
cpmm
.
sendAsyncMessage
(
"
TimeWarpFinished
"
)
;
}
const
gLogpoints
=
[
]
;
async
function
findLogpointHits
(
checkpoint
{
position
text
condition
callback
}
)
{
const
hits
=
await
findHits
(
checkpoint
position
)
;
const
child
=
ownerChild
(
checkpoint
)
;
for
(
const
point
of
hits
)
{
await
child
.
sendManifestAsync
(
{
contents
(
)
{
return
{
kind
:
"
hitLogpoint
"
text
condition
}
;
}
onFinished
(
child
{
result
}
)
{
if
(
result
)
{
callback
(
point
gDebugger
.
_convertCompletionValue
(
result
)
)
;
}
child
.
divergedFromRecording
=
true
;
}
}
point
)
;
}
}
function
handleResumeManifestResponse
(
{
point
duration
consoleMessages
scripts
}
)
{
if
(
!
point
.
position
)
{
addCheckpoint
(
point
.
checkpoint
-
1
duration
)
;
getCheckpointInfo
(
point
.
checkpoint
)
.
point
=
point
;
}
if
(
gDebugger
&
&
gDebugger
.
onConsoleMessage
)
{
consoleMessages
.
forEach
(
msg
=
>
gDebugger
.
onConsoleMessage
(
msg
)
)
;
}
if
(
gDebugger
)
{
scripts
.
forEach
(
script
=
>
gDebugger
.
_onNewScript
(
script
)
)
;
}
}
function
maybeResumeRecording
(
)
{
if
(
gActiveChild
!
=
gMainChild
)
{
return
;
}
if
(
timeSinceCheckpoint
(
gLastFlushCheckpoint
)
>
=
FlushMs
)
{
ensureFlushed
(
)
;
}
const
checkpoint
=
gMainChild
.
pausePoint
(
)
.
checkpoint
;
if
(
!
gMainChild
.
recording
&
&
checkpoint
=
=
gRecordingEndpoint
)
{
ensureFlushed
(
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
HitRecordingEndpoint
"
)
;
if
(
gDebugger
)
{
gDebugger
.
_onPause
(
)
;
}
return
;
}
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
resume
"
breakpoints
:
gBreakpoints
}
onFinished
(
response
)
{
handleResumeManifestResponse
(
response
)
;
gPausePoint
=
gMainChild
.
pausePoint
(
)
;
if
(
gDebugger
)
{
gDebugger
.
_onPause
(
)
;
}
else
{
Services
.
tm
.
dispatchToMainThread
(
maybeResumeRecording
)
;
}
}
}
)
;
}
function
ensureFlushed
(
)
{
assert
(
gActiveChild
=
=
gMainChild
)
;
gMainChild
.
waitUntilPaused
(
true
)
;
if
(
gLastFlushCheckpoint
=
=
gActiveChild
.
pauseCheckpoint
(
)
)
{
return
;
}
if
(
gMainChild
.
recording
)
{
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
flushRecording
"
}
onFinished
(
)
{
}
}
)
;
gMainChild
.
waitUntilPaused
(
)
;
}
const
oldFlushCheckpoint
=
gLastFlushCheckpoint
|
|
FirstCheckpointId
;
gLastFlushCheckpoint
=
gMainChild
.
pauseCheckpoint
(
)
;
if
(
gReplayingChildren
.
length
=
=
0
)
{
spawnReplayingChildren
(
)
;
}
addSavedCheckpoint
(
gLastFlushCheckpoint
)
;
forSavedCheckpointsInRange
(
oldFlushCheckpoint
gLastFlushCheckpoint
checkpoint
=
>
{
scanRecording
(
checkpoint
)
;
gBreakpoints
.
forEach
(
position
=
>
findHits
(
checkpoint
position
)
)
;
gLogpoints
.
forEach
(
logpoint
=
>
findLogpointHits
(
checkpoint
logpoint
)
)
;
}
)
;
pokeChildren
(
)
;
}
function
BeforeSaveRecording
(
)
{
if
(
gActiveChild
=
=
gMainChild
)
{
ensureFlushed
(
)
;
}
}
function
AfterSaveRecording
(
)
{
Services
.
cpmm
.
sendAsyncMessage
(
"
SaveRecordingFinished
"
)
;
}
let
gRecordingEndpoint
;
function
setMainChild
(
)
{
assert
(
!
gMainChild
.
recording
)
;
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
setMainChild
"
}
onFinished
(
{
endpoint
}
)
{
gRecordingEndpoint
=
endpoint
;
Services
.
tm
.
dispatchToMainThread
(
maybeResumeRecording
)
;
}
}
)
;
}
const
NumReplayingChildren
=
4
;
function
spawnReplayingChildren
(
)
{
for
(
let
i
=
0
;
i
<
NumReplayingChildren
;
i
+
+
)
{
const
id
=
RecordReplayControl
.
spawnReplayingChild
(
)
;
gReplayingChildren
[
id
]
=
new
ChildProcess
(
id
false
)
;
}
addSavedCheckpoint
(
FirstCheckpointId
)
;
}
function
Initialize
(
recordingChildId
)
{
try
{
if
(
recordingChildId
!
=
undefined
)
{
gMainChild
=
new
ChildProcess
(
recordingChildId
true
)
;
}
else
{
const
id
=
RecordReplayControl
.
spawnReplayingChild
(
)
;
gMainChild
=
new
ChildProcess
(
id
false
)
;
spawnReplayingChildren
(
)
;
}
gActiveChild
=
gMainChild
;
return
gControl
;
}
catch
(
e
)
{
dump
(
ERROR
:
Initialize
threw
exception
:
{
e
}
\
n
)
;
}
}
function
ManifestFinished
(
id
response
)
{
try
{
dumpv
(
ManifestFinished
#
{
id
}
{
JSON
.
stringify
(
response
)
}
)
;
lookupChild
(
id
)
.
manifestFinished
(
response
)
;
}
catch
(
e
)
{
dump
(
ERROR
:
ManifestFinished
threw
exception
:
{
e
}
{
e
.
stack
}
\
n
)
;
}
}
const
gControl
=
{
pausePoint
(
)
{
return
gActiveChild
&
&
gActiveChild
.
paused
?
gActiveChild
.
pausePoint
(
)
:
null
;
}
childIsRecording
(
)
{
return
gActiveChild
&
&
gActiveChild
.
recording
;
}
waitUntilPaused
(
)
{
assert
(
gActiveChild
)
;
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
return
;
}
while
(
true
)
{
gActiveChild
.
waitUntilPaused
(
)
;
if
(
pointEquals
(
gActiveChild
.
pausePoint
(
)
gPausePoint
)
)
{
return
;
}
pokeChild
(
gActiveChild
)
;
}
}
addBreakpoint
(
position
)
{
gBreakpoints
.
push
(
position
)
;
if
(
canFindHits
(
position
)
)
{
forSavedCheckpointsInRange
(
FirstCheckpointId
gLastFlushCheckpoint
checkpoint
=
>
{
findHits
(
checkpoint
position
)
;
}
)
;
}
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
}
}
clearBreakpoints
(
)
{
gBreakpoints
.
length
=
0
;
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
}
}
recordingEndpoint
(
)
{
return
gMainChild
.
lastPausePoint
;
}
maybeSwitchToReplayingChild
(
)
{
assert
(
gActiveChild
.
paused
)
;
if
(
gActiveChild
=
=
gMainChild
&
&
RecordReplayControl
.
canRewind
(
)
)
{
const
point
=
gActiveChild
.
pausePoint
(
)
;
if
(
point
.
position
)
{
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
resume
"
breakpoints
:
[
]
}
onFinished
(
response
)
{
handleResumeManifestResponse
(
response
)
;
}
}
)
;
gMainChild
.
waitUntilPaused
(
true
)
;
}
ensureFlushed
(
)
;
pauseReplayingChild
(
point
)
;
}
}
sendRequest
(
request
)
{
let
data
;
gActiveChild
.
sendManifest
(
{
contents
:
{
kind
:
"
debuggerRequest
"
request
}
onFinished
(
finishData
)
{
data
=
finishData
;
}
}
)
;
gActiveChild
.
waitUntilPaused
(
)
;
if
(
data
.
restoredCheckpoint
)
{
pauseReplayingChild
(
gPausePoint
)
;
gActiveChild
.
sendManifest
(
{
contents
:
{
kind
:
"
batchDebuggerRequest
"
requests
:
gDebuggerRequests
}
onFinished
(
finishData
)
{
assert
(
!
finishData
|
|
!
finishData
.
restoredCheckpoint
)
;
}
}
)
;
gActiveChild
.
waitUntilPaused
(
)
;
return
{
unhandledDivergence
:
true
}
;
}
if
(
data
.
divergedFromRecording
)
{
gActiveChild
.
divergedFromRecording
=
true
;
}
gDebuggerRequests
.
push
(
request
)
;
return
data
.
response
;
}
sendRequestMainChild
(
request
)
{
gMainChild
.
waitUntilPaused
(
true
)
;
let
data
;
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
debuggerRequest
"
request
}
onFinished
(
finishData
)
{
data
=
finishData
;
}
}
)
;
gMainChild
.
waitUntilPaused
(
)
;
assert
(
!
data
.
restoredCheckpoint
&
&
!
data
.
divergedFromRecording
)
;
return
data
.
response
;
}
resume
timeWarp
addLogpoint
(
logpoint
)
{
gLogpoints
.
push
(
logpoint
)
;
forSavedCheckpointsInRange
(
FirstCheckpointId
gLastFlushCheckpoint
checkpoint
=
>
findLogpointHits
(
checkpoint
logpoint
)
)
;
}
}
;
function
ConnectDebugger
(
dbg
)
{
gDebugger
=
dbg
;
dbg
.
_control
=
gControl
;
}
function
dumpv
(
str
)
{
}
function
assert
(
v
)
{
if
(
!
v
)
{
ThrowError
(
"
Assertion
Failed
!
"
)
;
}
}
function
ThrowError
(
msg
)
{
const
error
=
new
Error
(
msg
)
;
dump
(
ReplayControl
Server
Error
:
{
msg
}
Stack
:
{
error
.
stack
}
\
n
)
;
throw
error
;
}
var
EXPORTED_SYMBOLS
=
[
"
Initialize
"
"
ConnectDebugger
"
"
ManifestFinished
"
"
BeforeSaveRecording
"
"
AfterSaveRecording
"
]
;
