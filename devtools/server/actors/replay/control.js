"
use
strict
"
;
const
CC
=
Components
.
Constructor
;
const
sandbox
=
Cu
.
Sandbox
(
CC
(
"
mozilla
.
org
/
systemprincipal
;
1
"
"
nsIPrincipal
"
)
(
)
)
;
Cu
.
evalInSandbox
(
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
'
)
;
"
+
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
)
;
"
+
"
Components
.
utils
.
import
(
'
resource
:
/
/
devtools
/
shared
/
execution
-
point
-
utils
.
js
'
)
;
"
+
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
'
)
;
"
+
"
addDebuggerToGlobal
(
this
)
;
"
sandbox
)
;
const
{
RecordReplayControl
Services
pointEquals
pointToString
findClosestPoint
pointArrayIncludes
pointPrecedes
positionEquals
positionSubsumes
setInterval
}
=
sandbox
;
const
InvalidCheckpointId
=
0
;
const
FirstCheckpointId
=
1
;
function
ChildProcess
(
id
recording
)
{
this
.
id
=
id
;
this
.
recording
=
recording
;
this
.
paused
=
false
;
this
.
lastPausePoint
=
null
;
this
.
lastMemoryUsage
=
null
;
this
.
savedCheckpoints
=
new
Set
(
recording
?
[
]
:
[
FirstCheckpointId
]
)
;
this
.
scannedCheckpoints
=
new
Set
(
)
;
this
.
snapshots
=
[
]
;
this
.
divergedFromRecording
=
false
;
this
.
crashed
=
false
;
this
.
manifest
=
{
onFinished
:
(
{
point
}
)
=
>
{
if
(
this
=
=
gMainChild
)
{
getCheckpointInfo
(
FirstCheckpointId
)
.
point
=
point
;
Services
.
tm
.
dispatchToMainThread
(
recording
?
maybeResumeRecording
:
setMainChild
)
;
}
else
{
this
.
snapshots
.
push
(
checkpointExecutionPoint
(
FirstCheckpointId
)
)
;
}
}
}
;
this
.
manifestSendTime
=
Date
.
now
(
)
;
this
.
asyncManifest
=
null
;
}
ChildProcess
.
prototype
=
{
pausePoint
(
)
{
assert
(
this
.
paused
)
;
return
this
.
lastPausePoint
;
}
pauseCheckpoint
(
)
{
const
point
=
this
.
pausePoint
(
)
;
assert
(
!
point
.
position
)
;
return
point
.
checkpoint
;
}
sendManifest
(
manifest
)
{
assert
(
!
this
.
crashed
)
;
assert
(
this
.
paused
)
;
this
.
paused
=
false
;
this
.
manifest
=
manifest
;
this
.
manifestSendTime
=
Date
.
now
(
)
;
const
{
contents
mightRewind
}
=
manifest
;
dumpv
(
SendManifest
#
{
this
.
id
}
{
stringify
(
contents
)
}
)
;
RecordReplayControl
.
sendManifest
(
this
.
id
contents
mightRewind
)
;
}
manifestFinished
(
response
)
{
assert
(
!
this
.
paused
)
;
if
(
response
)
{
if
(
response
.
point
)
{
this
.
lastPausePoint
=
response
.
point
;
}
if
(
response
.
memoryUsage
)
{
this
.
lastMemoryUsage
=
response
.
memoryUsage
;
}
if
(
response
.
exception
)
{
ThrowError
(
response
.
exception
)
;
}
if
(
response
.
restoredSnapshot
)
{
assert
(
this
.
manifest
.
mightRewind
)
;
}
}
this
.
paused
=
true
;
this
.
manifest
.
onFinished
(
response
)
;
this
.
manifest
=
null
;
maybeDumpStatistics
(
)
;
if
(
this
!
=
gMainChild
)
{
pokeChildSoon
(
this
)
;
}
}
waitUntilPaused
(
maybeCreateCheckpoint
)
{
if
(
this
.
paused
)
{
return
;
}
RecordReplayControl
.
waitUntilPaused
(
this
.
id
maybeCreateCheckpoint
)
;
assert
(
this
.
paused
|
|
this
.
crashed
)
;
}
addSavedCheckpoint
(
checkpoint
)
{
dumpv
(
AddSavedCheckpoint
#
{
this
.
id
}
{
checkpoint
}
)
;
this
.
savedCheckpoints
.
add
(
checkpoint
)
;
}
savedCheckpointsInRange
(
start
end
)
{
const
rv
=
[
]
;
for
(
let
i
=
start
;
i
<
=
end
;
i
+
+
)
{
if
(
this
.
savedCheckpoints
.
has
(
i
)
)
{
rv
.
push
(
i
)
;
}
}
return
rv
;
}
getSnapshotsForSavedCheckpoints
(
endpoint
)
{
assert
(
pointPrecedes
(
this
.
pausePoint
(
)
endpoint
)
)
;
return
this
.
savedCheckpointsInRange
(
this
.
pausePoint
(
)
.
checkpoint
+
1
endpoint
.
checkpoint
)
.
map
(
checkpointExecutionPoint
)
;
}
lastSnapshot
(
)
{
return
this
.
snapshots
[
this
.
snapshots
.
length
-
1
]
;
}
timeToReachPoint
(
point
)
{
let
startDelay
=
0
;
let
startPoint
=
this
.
lastPausePoint
;
if
(
!
startPoint
)
{
startPoint
=
checkpointExecutionPoint
(
FirstCheckpointId
)
;
}
if
(
!
this
.
paused
)
{
if
(
this
.
manifest
.
expectedDuration
)
{
const
elapsed
=
Date
.
now
(
)
-
this
.
manifestSendTime
;
if
(
elapsed
<
this
.
manifest
.
expectedDuration
)
{
startDelay
=
this
.
manifest
.
expectedDuration
-
elapsed
;
}
}
if
(
this
.
manifest
.
destination
)
{
startPoint
=
this
.
manifest
.
destination
;
}
}
let
startCheckpoint
;
if
(
this
.
snapshots
.
length
)
{
let
snapshotIndex
=
this
.
snapshots
.
length
-
1
;
while
(
pointPrecedes
(
point
this
.
snapshots
[
snapshotIndex
]
)
)
{
snapshotIndex
-
-
;
}
startCheckpoint
=
this
.
snapshots
[
snapshotIndex
]
.
checkpoint
;
}
else
{
startCheckpoint
=
FirstCheckpointId
;
}
return
(
startDelay
+
checkpointRangeDuration
(
startCheckpoint
point
.
checkpoint
)
)
;
}
}
;
let
gMainChild
;
const
gReplayingChildren
=
[
]
;
function
lookupChild
(
id
)
{
if
(
id
=
=
gMainChild
.
id
)
{
return
gMainChild
;
}
return
gReplayingChildren
[
id
]
;
}
function
closestChild
(
point
)
{
let
minChild
=
null
minTime
=
Infinity
;
for
(
const
child
of
gReplayingChildren
)
{
if
(
child
)
{
const
time
=
child
.
timeToReachPoint
(
point
)
;
if
(
time
<
minTime
)
{
minChild
=
child
;
minTime
=
time
;
}
}
}
return
minChild
;
}
let
gDebugger
;
const
Priority
=
{
HIGH
:
0
MEDIUM
:
1
LOW
:
2
}
;
const
gAsyncManifests
=
[
new
Set
(
)
new
Set
(
)
new
Set
(
)
]
;
function
sendAsyncManifest
(
manifest
)
{
pokeChildrenSoon
(
)
;
return
new
Promise
(
resolve
=
>
{
manifest
.
resolve
=
resolve
;
const
priority
=
manifest
.
priority
|
|
Priority
.
HIGH
;
gAsyncManifests
[
priority
]
.
add
(
manifest
)
;
}
)
;
}
function
pickAsyncManifest
(
child
priority
)
{
const
worklist
=
gAsyncManifests
[
priority
]
;
let
best
=
null
bestTime
=
Infinity
;
for
(
const
manifest
of
worklist
)
{
if
(
manifest
.
shouldSkip
(
)
)
{
manifest
.
resolve
(
)
;
worklist
.
delete
(
manifest
)
;
continue
;
}
if
(
manifest
.
scanCheckpoint
)
{
if
(
child
.
scannedCheckpoints
.
has
(
manifest
.
scanCheckpoint
)
)
{
assert
(
!
manifest
.
point
)
;
best
=
manifest
;
break
;
}
else
{
continue
;
}
}
if
(
child
=
=
gActiveChild
)
{
continue
;
}
assert
(
manifest
.
point
)
;
const
time
=
child
.
timeToReachPoint
(
manifest
.
point
)
;
if
(
time
<
bestTime
)
{
best
=
manifest
;
bestTime
=
time
;
}
}
if
(
best
)
{
worklist
.
delete
(
best
)
;
}
return
best
;
}
function
processAsyncManifest
(
child
)
{
let
manifest
=
child
.
asyncManifest
;
child
.
asyncManifest
=
null
;
if
(
manifest
&
&
child
=
=
gActiveChild
)
{
sendAsyncManifest
(
manifest
)
;
manifest
=
null
;
}
if
(
!
manifest
)
{
for
(
const
priority
of
Object
.
values
(
Priority
)
)
{
manifest
=
pickAsyncManifest
(
child
priority
)
;
if
(
manifest
)
{
break
;
}
}
if
(
!
manifest
)
{
return
false
;
}
}
child
.
asyncManifest
=
manifest
;
if
(
manifest
.
point
&
&
maybeReachPoint
(
child
manifest
.
point
manifest
.
snapshot
)
)
{
return
true
;
}
child
.
sendManifest
(
{
contents
:
manifest
.
contents
(
child
)
onFinished
:
data
=
>
{
child
.
asyncManifest
=
null
;
manifest
.
onFinished
(
child
data
)
;
manifest
.
resolve
(
)
;
}
destination
:
manifest
.
destination
expectedDuration
:
manifest
.
expectedDuration
mightRewind
:
manifest
.
mightRewind
}
)
;
return
true
;
}
let
gActiveChild
=
null
;
const
gCheckpoints
=
[
null
]
;
function
CheckpointInfo
(
)
{
this
.
duration
=
0
;
this
.
point
=
null
;
this
.
saved
=
false
;
this
.
assignTime
=
null
;
this
.
scanTime
=
null
;
this
.
scanDuration
=
null
;
this
.
debuggerStatements
=
[
]
;
this
.
events
=
[
]
;
}
function
getCheckpointInfo
(
id
)
{
while
(
id
>
=
gCheckpoints
.
length
)
{
gCheckpoints
.
push
(
new
CheckpointInfo
(
)
)
;
}
return
gCheckpoints
[
id
]
;
}
function
checkpointRangeDuration
(
start
end
)
{
let
time
=
0
;
for
(
let
i
=
start
;
i
<
end
;
i
+
+
)
{
time
+
=
gCheckpoints
[
i
]
.
duration
;
}
return
time
;
}
function
timeSinceCheckpoint
(
id
)
{
return
checkpointRangeDuration
(
id
gCheckpoints
.
length
)
;
}
function
timeForSavedCheckpoint
(
id
)
{
return
checkpointRangeDuration
(
id
nextSavedCheckpoint
(
id
)
)
;
}
let
gLastFlushCheckpoint
=
InvalidCheckpointId
;
const
FlushMs
=
0
.
5
*
1000
;
let
gLastPickedChildId
=
0
;
function
addSavedCheckpoint
(
checkpoint
)
{
getCheckpointInfo
(
checkpoint
)
.
saved
=
true
;
getCheckpointInfo
(
checkpoint
)
.
assignTime
=
Date
.
now
(
)
;
if
(
RecordReplayControl
.
canRewind
(
)
)
{
let
child
;
while
(
true
)
{
gLastPickedChildId
=
(
gLastPickedChildId
+
1
)
%
gReplayingChildren
.
length
;
child
=
gReplayingChildren
[
gLastPickedChildId
]
;
if
(
child
)
{
break
;
}
}
child
.
addSavedCheckpoint
(
checkpoint
)
;
}
}
function
addCheckpoint
(
checkpoint
duration
)
{
assert
(
!
getCheckpointInfo
(
checkpoint
)
.
duration
)
;
getCheckpointInfo
(
checkpoint
)
.
duration
=
duration
;
}
function
maybeReachPoint
(
child
endpoint
snapshot
)
{
if
(
pointEquals
(
child
.
pausePoint
(
)
endpoint
)
&
&
!
child
.
divergedFromRecording
)
{
return
false
;
}
if
(
pointPrecedes
(
endpoint
child
.
pausePoint
(
)
)
)
{
restoreSnapshotPriorTo
(
endpoint
)
;
return
true
;
}
if
(
child
.
divergedFromRecording
)
{
restoreSnapshotPriorTo
(
child
.
pausePoint
(
)
)
;
return
true
;
}
const
snapshotPoints
=
child
.
getSnapshotsForSavedCheckpoints
(
endpoint
)
;
if
(
snapshot
&
&
pointPrecedes
(
child
.
pausePoint
(
)
snapshot
)
&
&
!
pointArrayIncludes
(
snapshotPoints
snapshot
)
)
{
snapshotPoints
.
push
(
snapshot
)
;
}
child
.
sendManifest
(
{
contents
:
{
kind
:
"
runToPoint
"
endpoint
snapshotPoints
}
onFinished
(
)
{
child
.
snapshots
.
push
(
.
.
.
snapshotPoints
)
;
}
destination
:
endpoint
expectedDuration
:
checkpointRangeDuration
(
child
.
pausePoint
(
)
.
checkpoint
endpoint
.
checkpoint
)
}
)
;
return
true
;
function
restoreSnapshotPriorTo
(
target
)
{
let
numSnapshots
=
0
;
while
(
pointPrecedes
(
target
child
.
lastSnapshot
(
)
)
)
{
numSnapshots
+
+
;
child
.
snapshots
.
pop
(
)
;
}
child
.
sendManifest
(
{
contents
:
{
kind
:
"
restoreSnapshot
"
numSnapshots
}
onFinished
(
{
restoredSnapshot
}
)
{
assert
(
restoredSnapshot
)
;
child
.
divergedFromRecording
=
false
;
}
destination
:
child
.
lastSnapshot
(
)
mightRewind
:
true
}
)
;
}
}
function
nextSavedCheckpoint
(
checkpoint
)
{
assert
(
gCheckpoints
[
checkpoint
]
.
saved
)
;
while
(
!
gCheckpoints
[
+
+
checkpoint
]
.
saved
)
{
}
return
checkpoint
;
}
function
forSavedCheckpointsInRange
(
start
end
callback
)
{
if
(
start
=
=
FirstCheckpointId
&
&
!
gCheckpoints
[
start
]
.
saved
)
{
return
;
}
assert
(
gCheckpoints
[
start
]
.
saved
)
;
for
(
let
checkpoint
=
start
;
checkpoint
<
end
;
checkpoint
=
nextSavedCheckpoint
(
checkpoint
)
)
{
callback
(
checkpoint
)
;
}
}
function
forAllSavedCheckpoints
(
callback
)
{
forSavedCheckpointsInRange
(
FirstCheckpointId
gLastFlushCheckpoint
callback
)
;
}
function
getSavedCheckpoint
(
checkpoint
)
{
while
(
!
gCheckpoints
[
checkpoint
]
.
saved
)
{
checkpoint
-
-
;
}
return
checkpoint
;
}
function
checkpointExecutionPoint
(
checkpoint
)
{
return
gCheckpoints
[
checkpoint
]
.
point
;
}
function
pokeChild
(
child
)
{
assert
(
child
!
=
gMainChild
)
;
if
(
!
child
.
paused
)
{
return
;
}
if
(
processAsyncManifest
(
child
)
)
{
return
;
}
if
(
child
=
=
gActiveChild
)
{
sendActiveChildToPausePoint
(
)
;
return
;
}
if
(
gLastFlushCheckpoint
)
{
maybeReachPoint
(
child
checkpointExecutionPoint
(
gLastFlushCheckpoint
)
)
;
}
}
function
pokeChildSoon
(
child
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
pokeChild
(
child
)
)
;
}
let
gPendingPokeChildren
=
false
;
function
pokeChildren
(
)
{
gPendingPokeChildren
=
false
;
for
(
const
child
of
gReplayingChildren
)
{
if
(
child
)
{
pokeChild
(
child
)
;
}
}
}
function
pokeChildrenSoon
(
)
{
if
(
!
gPendingPokeChildren
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
pokeChildren
(
)
)
;
gPendingPokeChildren
=
true
;
}
}
const
gBreakpoints
=
[
]
;
function
findScanChild
(
checkpoint
requireComplete
)
{
for
(
const
child
of
gReplayingChildren
)
{
if
(
child
&
&
child
.
scannedCheckpoints
.
has
(
checkpoint
)
)
{
if
(
requireComplete
&
&
!
child
.
paused
&
&
child
.
manifest
.
contents
.
kind
=
=
"
scanRecording
"
&
&
child
.
lastPausePoint
.
checkpoint
=
=
checkpoint
)
{
continue
;
}
return
child
;
}
}
return
null
;
}
async
function
scanRecording
(
checkpoint
)
{
assert
(
checkpoint
<
gLastFlushCheckpoint
)
;
const
child
=
findScanChild
(
checkpoint
)
;
if
(
child
)
{
return
;
}
const
endpoint
=
checkpointExecutionPoint
(
nextSavedCheckpoint
(
checkpoint
)
)
;
let
snapshotPoints
=
null
;
await
sendAsyncManifest
(
{
shouldSkip
:
(
)
=
>
!
!
findScanChild
(
checkpoint
)
contents
(
child
)
{
child
.
scannedCheckpoints
.
add
(
checkpoint
)
;
snapshotPoints
=
child
.
getSnapshotsForSavedCheckpoints
(
endpoint
)
;
return
{
kind
:
"
scanRecording
"
endpoint
snapshotPoints
}
;
}
onFinished
(
child
{
duration
}
)
{
child
.
snapshots
.
push
(
.
.
.
snapshotPoints
)
;
const
info
=
getCheckpointInfo
(
checkpoint
)
;
if
(
!
info
.
scanTime
)
{
info
.
scanTime
=
Date
.
now
(
)
;
info
.
scanDuration
=
duration
;
}
if
(
gDebugger
)
{
gDebugger
.
_callOnPositionChange
(
)
;
}
}
point
:
checkpointExecutionPoint
(
checkpoint
)
destination
:
endpoint
expectedDuration
:
checkpointRangeDuration
(
checkpoint
endpoint
)
*
5
}
)
;
assert
(
findScanChild
(
checkpoint
)
)
;
}
function
unscannedRegions
(
)
{
const
result
=
[
]
;
function
addRegion
(
startCheckpoint
endCheckpoint
)
{
const
start
=
checkpointExecutionPoint
(
startCheckpoint
)
.
progress
;
const
end
=
checkpointExecutionPoint
(
endCheckpoint
)
.
progress
;
if
(
result
.
length
&
&
result
[
result
.
length
-
1
]
.
end
=
=
start
)
{
result
[
result
.
length
-
1
]
.
end
=
end
;
}
else
{
result
.
push
(
{
start
end
}
)
;
}
}
forAllSavedCheckpoints
(
checkpoint
=
>
{
if
(
!
findScanChild
(
checkpoint
true
)
)
{
addRegion
(
checkpoint
nextSavedCheckpoint
(
checkpoint
)
)
;
}
}
)
;
const
lastFlush
=
gLastFlushCheckpoint
|
|
FirstCheckpointId
;
if
(
lastFlush
!
=
gRecordingEndpoint
)
{
addRegion
(
lastFlush
gMainChild
.
lastPausePoint
.
checkpoint
)
;
}
return
result
;
}
const
gHitSearches
=
new
Map
(
)
;
function
canFindHits
(
position
)
{
return
position
.
kind
=
=
"
Break
"
|
|
position
.
kind
=
=
"
OnStep
"
;
}
async
function
findHits
(
checkpoint
position
)
{
assert
(
canFindHits
(
position
)
)
;
assert
(
gCheckpoints
[
checkpoint
]
.
saved
)
;
if
(
!
gHitSearches
.
has
(
checkpoint
)
)
{
gHitSearches
.
set
(
checkpoint
[
]
)
;
}
let
hits
=
findExisting
(
)
;
if
(
hits
)
{
return
hits
;
}
await
scanRecording
(
checkpoint
)
;
const
endpoint
=
nextSavedCheckpoint
(
checkpoint
)
;
await
sendAsyncManifest
(
{
shouldSkip
:
(
)
=
>
!
!
findExisting
(
)
contents
(
)
{
return
{
kind
:
"
findHits
"
position
startpoint
:
checkpoint
endpoint
}
;
}
onFinished
(
_
hits
)
{
if
(
!
gHitSearches
.
has
(
checkpoint
)
)
{
gHitSearches
.
set
(
checkpoint
[
]
)
;
}
const
checkpointHits
=
gHitSearches
.
get
(
checkpoint
)
;
checkpointHits
.
push
(
{
position
hits
}
)
;
}
scanCheckpoint
:
checkpoint
}
)
;
hits
=
findExisting
(
)
;
assert
(
hits
)
;
return
hits
;
function
findExisting
(
)
{
const
checkpointHits
=
gHitSearches
.
get
(
checkpoint
)
;
if
(
!
checkpointHits
)
{
return
null
;
}
const
entry
=
checkpointHits
.
find
(
(
{
position
:
existingPosition
hits
}
)
=
>
{
return
positionEquals
(
position
existingPosition
)
;
}
)
;
return
entry
?
entry
.
hits
:
null
;
}
}
async
function
findBreakpointHits
(
checkpoint
position
)
{
if
(
position
.
kind
=
=
"
Break
"
)
{
findHits
(
checkpoint
position
)
;
}
}
const
gFrameSteps
=
new
Map
(
)
;
const
gParentFrames
=
new
Map
(
)
;
async
function
findFrameSteps
(
point
)
{
if
(
!
point
.
position
)
{
return
null
;
}
assert
(
point
.
position
.
kind
=
=
"
EnterFrame
"
|
|
point
.
position
.
kind
=
=
"
OnStep
"
|
|
point
.
position
.
kind
=
=
"
OnPop
"
)
;
let
steps
=
findExisting
(
)
;
if
(
steps
)
{
return
steps
;
}
const
info
=
gControl
.
sendRequestMainChild
(
{
type
:
"
frameStepsInfo
"
script
:
point
.
position
.
script
}
)
;
const
checkpoint
=
getSavedCheckpoint
(
point
.
checkpoint
)
;
await
scanRecording
(
checkpoint
)
;
await
sendAsyncManifest
(
{
shouldSkip
:
(
)
=
>
!
!
findExisting
(
)
contents
:
(
)
=
>
(
{
kind
:
"
findFrameSteps
"
targetPoint
:
point
.
.
.
info
}
)
onFinished
:
(
_
steps
)
=
>
{
for
(
const
p
of
steps
)
{
if
(
p
.
position
.
frameIndex
=
=
point
.
position
.
frameIndex
)
{
gFrameSteps
.
set
(
pointToString
(
p
)
steps
)
;
}
else
{
assert
(
p
.
position
.
kind
=
=
"
EnterFrame
"
)
;
gParentFrames
.
set
(
pointToString
(
p
)
steps
[
0
]
)
;
}
}
}
scanCheckpoint
:
checkpoint
}
)
;
steps
=
findExisting
(
)
;
assert
(
steps
)
;
return
steps
;
function
findExisting
(
)
{
return
gFrameSteps
.
get
(
pointToString
(
point
)
)
;
}
}
async
function
findParentFrameEntryPoint
(
point
)
{
assert
(
point
.
position
.
kind
=
=
"
EnterFrame
"
)
;
assert
(
point
.
position
.
frameIndex
>
0
)
;
let
parentPoint
=
findExisting
(
)
;
if
(
parentPoint
)
{
return
parentPoint
;
}
const
checkpoint
=
getSavedCheckpoint
(
point
.
checkpoint
)
;
await
scanRecording
(
checkpoint
)
;
await
sendAsyncManifest
(
{
shouldSkip
:
(
)
=
>
!
!
findExisting
(
)
contents
:
(
)
=
>
(
{
kind
:
"
findParentFrameEntryPoint
"
point
}
)
onFinished
:
(
_
{
parentPoint
}
)
=
>
{
gParentFrames
.
set
(
pointToString
(
point
)
parentPoint
)
;
}
scanCheckpoint
:
checkpoint
}
)
;
parentPoint
=
findExisting
(
)
;
assert
(
parentPoint
)
;
return
parentPoint
;
function
findExisting
(
)
{
return
gParentFrames
.
get
(
pointToString
(
point
)
)
;
}
}
const
gPauseData
=
new
Map
(
)
;
const
gQueuedPauseData
=
new
Set
(
)
;
const
gCachedPoints
=
new
Map
(
)
;
async
function
queuePauseData
(
{
point
snapshot
trackCached
shouldSkip
:
shouldSkipCallback
}
)
{
if
(
gQueuedPauseData
.
has
(
pointToString
(
point
)
)
)
{
return
;
}
gQueuedPauseData
.
add
(
pointToString
(
point
)
)
;
await
waitForFlushed
(
point
.
checkpoint
)
;
await
sendAsyncManifest
(
{
shouldSkip
(
)
{
if
(
maybeGetPauseData
(
point
)
)
{
return
true
;
}
return
shouldSkipCallback
&
&
shouldSkipCallback
(
)
;
}
contents
(
)
{
return
{
kind
:
"
getPauseData
"
}
;
}
onFinished
(
child
data
)
{
if
(
!
data
.
restoredSnapshot
)
{
addPauseData
(
point
data
trackCached
)
;
child
.
divergedFromRecording
=
true
;
}
}
point
snapshot
expectedDuration
:
250
priority
:
Priority
.
LOW
mightRewind
:
true
}
)
;
}
function
addPauseData
(
point
data
trackCached
)
{
if
(
data
.
paintData
)
{
data
.
paintData
=
RecordReplayControl
.
atomize
(
data
.
paintData
)
;
}
gPauseData
.
set
(
pointToString
(
point
)
data
)
;
if
(
trackCached
)
{
gCachedPoints
.
set
(
pointToString
(
point
)
point
)
;
if
(
gDebugger
)
{
gDebugger
.
_callOnPositionChange
(
)
;
}
}
}
function
maybeGetPauseData
(
point
)
{
return
gPauseData
.
get
(
pointToString
(
point
)
)
;
}
function
cachedPoints
(
)
{
return
[
.
.
.
gCachedPoints
.
values
(
)
]
.
map
(
point
=
>
point
.
progress
)
;
}
const
PauseModes
=
{
RUNNING
:
"
RUNNING
"
PAUSED
:
"
PAUSED
"
ARRIVING
:
"
ARRIVING
"
RESUMING_BACKWARD
:
"
RESUMING_BACKWARD
"
RESUMING_FORWARD
:
"
RESUMING_FORWARD
"
}
;
let
gPauseMode
=
PauseModes
.
RUNNING
;
let
gPausePoint
=
null
;
const
gDebuggerRequests
=
[
]
;
function
addDebuggerRequest
(
request
)
{
gDebuggerRequests
.
push
(
{
request
stack
:
Error
(
)
.
stack
}
)
;
}
function
setPauseState
(
mode
point
child
)
{
assert
(
mode
)
;
const
idString
=
child
?
#
{
child
.
id
}
:
"
"
;
dumpv
(
SetPauseState
{
mode
}
{
JSON
.
stringify
(
point
)
}
{
idString
}
)
;
gPauseMode
=
mode
;
gPausePoint
=
point
;
gActiveChild
=
child
;
if
(
mode
=
=
PauseModes
.
ARRIVING
)
{
simulateNearbyNavigation
(
)
;
}
pokeChildrenSoon
(
)
;
}
function
setReplayingPauseTarget
(
point
)
{
assert
(
!
gDebuggerRequests
.
length
)
;
setPauseState
(
PauseModes
.
ARRIVING
point
closestChild
(
point
.
checkpoint
)
)
;
gDebugger
.
_onPause
(
)
;
findFrameSteps
(
point
)
;
}
function
sendActiveChildToPausePoint
(
)
{
assert
(
gActiveChild
.
paused
)
;
switch
(
gPauseMode
)
{
case
PauseModes
.
PAUSED
:
assert
(
pointEquals
(
gActiveChild
.
pausePoint
(
)
gPausePoint
)
)
;
return
;
case
PauseModes
.
ARRIVING
:
if
(
pointEquals
(
gActiveChild
.
pausePoint
(
)
gPausePoint
)
)
{
setPauseState
(
PauseModes
.
PAUSED
gPausePoint
gActiveChild
)
;
if
(
gDebuggerRequests
.
length
)
{
const
child
=
gActiveChild
;
child
.
sendManifest
(
{
contents
:
{
kind
:
"
batchDebuggerRequest
"
requests
:
gDebuggerRequests
.
map
(
r
=
>
r
.
request
)
}
onFinished
(
finishData
)
{
if
(
finishData
.
divergedFromRecording
)
{
child
.
divergedFromRecording
=
true
;
}
}
}
)
;
}
}
else
{
maybeReachPoint
(
gActiveChild
gPausePoint
)
;
}
return
;
default
:
ThrowError
(
Unexpected
pause
mode
:
{
gPauseMode
}
)
;
}
}
function
waitUntilPauseFinishes
(
)
{
assert
(
gActiveChild
)
;
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
return
;
}
while
(
gPauseMode
!
=
PauseModes
.
PAUSED
)
{
gActiveChild
.
waitUntilPaused
(
)
;
pokeChild
(
gActiveChild
)
;
}
gActiveChild
.
waitUntilPaused
(
)
;
}
function
pauseReplayingChild
(
child
point
)
{
setPauseState
(
PauseModes
.
ARRIVING
point
child
)
;
waitUntilPauseFinishes
(
)
;
}
async
function
resumeTarget
(
point
forward
breakpoints
)
{
let
startCheckpoint
=
point
.
checkpoint
;
if
(
!
forward
&
&
!
point
.
position
)
{
startCheckpoint
-
-
;
if
(
startCheckpoint
=
=
InvalidCheckpointId
)
{
return
null
;
}
}
startCheckpoint
=
getSavedCheckpoint
(
startCheckpoint
)
;
let
checkpoint
=
startCheckpoint
;
for
(
;
;
forward
?
checkpoint
+
+
:
checkpoint
-
-
)
{
if
(
[
InvalidCheckpointId
gLastFlushCheckpoint
]
.
includes
(
checkpoint
)
)
{
return
null
;
}
if
(
!
gCheckpoints
[
checkpoint
]
.
saved
)
{
continue
;
}
const
hits
=
[
]
;
for
(
const
bp
of
breakpoints
)
{
if
(
canFindHits
(
bp
)
)
{
const
bphits
=
await
findHits
(
checkpoint
bp
)
;
hits
.
push
(
.
.
.
bphits
)
;
}
}
if
(
checkpoint
=
=
startCheckpoint
&
&
gBreakpoints
.
some
(
bp
=
>
bp
.
kind
=
=
"
EnterFrame
"
|
|
bp
.
kind
=
=
"
OnPop
"
)
)
{
const
steps
=
await
findFrameSteps
(
point
)
;
hits
.
push
(
.
.
.
steps
.
filter
(
p
=
>
{
return
breakpoints
.
some
(
bp
=
>
positionSubsumes
(
bp
p
.
position
)
)
;
}
)
)
;
}
hits
.
push
(
.
.
.
getCheckpointInfo
(
checkpoint
)
.
debuggerStatements
)
;
const
hit
=
findClosestPoint
(
hits
gPausePoint
!
forward
false
)
;
if
(
hit
)
{
return
hit
;
}
}
}
async
function
finishResume
(
)
{
assert
(
gPauseMode
=
=
PauseModes
.
RESUMING_FORWARD
|
|
gPauseMode
=
=
PauseModes
.
RESUMING_BACKWARD
)
;
const
forward
=
gPauseMode
=
=
PauseModes
.
RESUMING_FORWARD
;
const
point
=
await
resumeTarget
(
gPausePoint
forward
gBreakpoints
)
;
if
(
point
)
{
setReplayingPauseTarget
(
point
)
;
}
else
if
(
forward
)
{
assert
(
forward
)
;
RecordReplayControl
.
restoreMainGraphics
(
)
;
setPauseState
(
PauseModes
.
RUNNING
gMainChild
.
pausePoint
(
)
gMainChild
)
;
gDebugger
.
_callOnPositionChange
(
)
;
maybeResumeRecording
(
)
;
}
else
{
assert
(
!
forward
)
;
setReplayingPauseTarget
(
checkpointExecutionPoint
(
FirstCheckpointId
)
)
;
}
}
function
resume
(
forward
)
{
gDebuggerRequests
.
length
=
0
;
if
(
gActiveChild
.
recording
)
{
if
(
forward
)
{
maybeResumeRecording
(
)
;
return
;
}
ensureFlushed
(
)
;
}
if
(
gPausePoint
.
checkpoint
=
=
FirstCheckpointId
&
&
!
gPausePoint
.
position
&
&
!
forward
)
{
gDebugger
.
_hitRecordingBoundary
(
)
;
return
;
}
setPauseState
(
forward
?
PauseModes
.
RESUMING_FORWARD
:
PauseModes
.
RESUMING_BACKWARD
gPausePoint
null
)
;
finishResume
(
)
;
pokeChildren
(
)
;
}
function
timeWarp
(
point
)
{
gDebuggerRequests
.
length
=
0
;
setReplayingPauseTarget
(
point
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
TimeWarpFinished
"
)
;
}
const
MaxCrashes
=
4
;
let
gNumCrashes
=
0
;
function
ChildCrashed
(
id
)
{
dumpv
(
Child
Crashed
:
{
id
}
)
;
const
child
=
gReplayingChildren
[
id
]
;
if
(
!
child
|
|
!
child
.
manifest
|
|
(
child
=
=
gActiveChild
&
&
gPauseMode
=
=
PauseModes
.
PAUSED
)
)
{
ThrowError
(
"
Cannot
recover
from
crashed
child
"
)
;
}
if
(
+
+
gNumCrashes
>
MaxCrashes
)
{
ThrowError
(
"
Too
many
crashes
"
)
;
}
delete
gReplayingChildren
[
id
]
;
child
.
crashed
=
true
;
const
newChild
=
spawnReplayingChild
(
)
;
pokeChildSoon
(
newChild
)
;
for
(
const
checkpoint
of
child
.
savedCheckpoints
)
{
newChild
.
addSavedCheckpoint
(
checkpoint
)
;
}
for
(
const
checkpoint
of
child
.
scannedCheckpoints
)
{
scanRecording
(
checkpoint
)
;
}
if
(
child
.
asyncManifest
)
{
sendAsyncManifest
(
child
.
asyncManifest
)
;
}
if
(
child
=
=
gActiveChild
)
{
assert
(
gPauseMode
=
=
PauseModes
.
ARRIVING
)
;
gActiveChild
=
closestChild
(
gPausePoint
.
checkpoint
)
;
pokeChildSoon
(
gActiveChild
)
;
}
}
async
function
simulateBreakpointNavigation
(
point
forward
count
)
{
if
(
!
count
)
{
return
;
}
const
breakpoints
=
gBreakpoints
.
filter
(
bp
=
>
bp
.
kind
=
=
"
Break
"
)
;
const
next
=
await
resumeTarget
(
point
forward
breakpoints
)
;
if
(
next
)
{
queuePauseData
(
{
point
:
next
}
)
;
simulateBreakpointNavigation
(
next
forward
count
-
1
)
;
}
}
async
function
findFrameEntryPoint
(
point
)
{
assert
(
point
.
position
.
kind
=
=
"
EnterFrame
"
)
;
const
steps
=
await
findFrameSteps
(
point
)
;
assert
(
pointEquals
(
steps
[
0
]
point
)
)
;
return
steps
[
1
]
;
}
async
function
simulateSteppingNavigation
(
point
count
frameCount
last
)
{
if
(
!
count
|
|
!
point
.
position
)
{
return
;
}
const
{
script
}
=
point
.
position
;
const
dbgScript
=
gDebugger
.
_getScript
(
script
)
;
const
steps
=
await
findFrameSteps
(
point
)
;
const
pointIndex
=
steps
.
findIndex
(
p
=
>
pointEquals
(
p
point
)
)
;
if
(
last
!
=
"
reverseStepOver
"
)
{
for
(
let
i
=
pointIndex
+
1
;
i
<
steps
.
length
;
i
+
+
)
{
const
p
=
steps
[
i
]
;
if
(
isStepOverTarget
(
p
)
)
{
queuePauseData
(
{
point
:
p
snapshot
:
steps
[
0
]
}
)
;
simulateSteppingNavigation
(
p
count
-
1
frameCount
"
stepOver
"
)
;
break
;
}
}
}
if
(
last
!
=
"
stepOver
"
)
{
for
(
let
i
=
pointIndex
-
1
;
i
>
=
1
;
i
-
-
)
{
const
p
=
steps
[
i
]
;
if
(
isStepOverTarget
(
p
)
)
{
queuePauseData
(
{
point
:
p
snapshot
:
steps
[
0
]
}
)
;
simulateSteppingNavigation
(
p
count
-
1
frameCount
"
reverseStepOver
"
)
;
break
;
}
}
}
if
(
frameCount
)
{
for
(
let
i
=
pointIndex
+
1
;
i
<
steps
.
length
;
i
+
+
)
{
const
p
=
steps
[
i
]
;
if
(
isStepOverTarget
(
p
)
)
{
break
;
}
if
(
p
.
position
.
script
!
=
script
)
{
queuePauseData
(
{
point
:
p
snapshot
:
steps
[
0
]
}
)
;
const
np
=
await
findFrameEntryPoint
(
p
)
;
queuePauseData
(
{
point
:
np
snapshot
:
steps
[
0
]
}
)
;
findHits
(
getSavedCheckpoint
(
point
.
checkpoint
)
np
.
position
)
;
simulateSteppingNavigation
(
np
count
-
1
frameCount
-
1
"
stepIn
"
)
;
break
;
}
}
}
if
(
frameCount
&
&
last
!
=
"
stepOver
"
&
&
last
!
=
"
reverseStepOver
"
&
&
point
.
position
.
frameIndex
)
{
queuePauseData
(
{
point
:
steps
[
steps
.
length
-
1
]
snapshot
:
steps
[
0
]
}
)
;
const
parentEntryPoint
=
await
findParentFrameEntryPoint
(
steps
[
0
]
)
;
const
parentSteps
=
await
findFrameSteps
(
parentEntryPoint
)
;
for
(
let
i
=
0
;
i
<
parentSteps
.
length
;
i
+
+
)
{
const
p
=
parentSteps
[
i
]
;
if
(
pointPrecedes
(
point
p
)
)
{
queuePauseData
(
{
point
:
p
snapshot
:
parentSteps
[
0
]
}
)
;
findHits
(
getSavedCheckpoint
(
point
.
checkpoint
)
p
.
position
)
;
simulateSteppingNavigation
(
p
count
-
1
frameCount
-
1
"
stepOut
"
)
;
break
;
}
}
}
function
isStepOverTarget
(
p
)
{
const
{
kind
offset
}
=
p
.
position
;
return
(
kind
=
=
"
OnPop
"
|
|
(
kind
=
=
"
OnStep
"
&
&
dbgScript
.
getOffsetMetadata
(
offset
)
.
isStepStart
)
)
;
}
}
function
simulateNearbyNavigation
(
)
{
const
numBreakpointHits
=
2
;
const
numSteps
=
4
;
const
numChangeFrames
=
2
;
simulateBreakpointNavigation
(
gPausePoint
true
numBreakpointHits
)
;
simulateBreakpointNavigation
(
gPausePoint
false
numBreakpointHits
)
;
simulateSteppingNavigation
(
gPausePoint
numSteps
numChangeFrames
)
;
}
const
gLogpoints
=
[
]
;
async
function
evaluateLogpoint
(
{
point
text
condition
callback
snapshot
fast
}
)
{
assert
(
point
)
;
await
sendAsyncManifest
(
{
shouldSkip
:
(
)
=
>
false
contents
(
)
{
return
{
kind
:
"
hitLogpoint
"
text
condition
fast
}
;
}
onFinished
(
child
{
result
resultData
restoredSnapshot
}
)
{
if
(
restoredSnapshot
)
{
callback
(
point
[
"
Recording
divergence
evaluating
logpoint
"
]
)
;
}
else
{
if
(
result
)
{
callback
(
point
result
resultData
)
;
}
if
(
!
fast
)
{
child
.
divergedFromRecording
=
true
;
}
}
}
point
snapshot
expectedDuration
:
250
priority
:
Priority
.
MEDIUM
mightRewind
:
true
}
)
;
}
async
function
findLogpointHits
(
checkpoint
{
position
text
condition
messageCallback
validCallback
}
)
{
if
(
!
validCallback
(
)
)
{
return
;
}
const
hits
=
await
findHits
(
checkpoint
position
)
;
hits
.
sort
(
(
a
b
)
=
>
pointPrecedes
(
b
a
)
)
;
if
(
!
condition
)
{
for
(
const
point
of
hits
)
{
messageCallback
(
point
[
"
Loading
.
.
.
"
]
)
;
}
}
for
(
const
point
of
hits
)
{
const
fast
=
getPreference
(
"
fastLogpoints
"
)
;
const
snapshot
=
!
fast
&
&
checkpointExecutionPoint
(
point
.
checkpoint
)
;
await
evaluateLogpoint
(
{
point
text
condition
callback
:
messageCallback
snapshot
fast
}
)
;
if
(
!
validCallback
(
)
)
{
return
;
}
}
for
(
const
point
of
hits
)
{
await
queuePauseData
(
{
point
trackCached
:
true
}
)
;
if
(
!
validCallback
(
)
)
{
return
;
}
}
}
const
gLoggedEvents
=
[
]
;
const
gEventFrameEntryPoints
=
new
Map
(
)
;
async
function
findEventFrameEntry
(
checkpoint
progress
)
{
if
(
gEventFrameEntryPoints
.
has
(
progress
)
)
{
return
gEventFrameEntryPoints
.
get
(
progress
)
;
}
const
savedCheckpoint
=
getSavedCheckpoint
(
checkpoint
)
;
await
scanRecording
(
savedCheckpoint
)
;
await
sendAsyncManifest
(
{
shouldSkip
:
(
)
=
>
gEventFrameEntryPoints
.
has
(
progress
)
contents
:
(
)
=
>
(
{
kind
:
"
findEventFrameEntry
"
checkpoint
progress
}
)
onFinished
:
(
_
{
rv
}
)
=
>
gEventFrameEntryPoints
.
set
(
progress
rv
)
scanCheckpoint
:
savedCheckpoint
}
)
;
const
point
=
gEventFrameEntryPoints
.
get
(
progress
)
;
if
(
!
point
)
{
return
null
;
}
return
findFrameEntryPoint
(
point
)
;
}
async
function
findEventLogpointHits
(
checkpoint
event
callback
)
{
for
(
const
info
of
getCheckpointInfo
(
checkpoint
)
.
events
)
{
if
(
info
.
event
=
=
event
)
{
const
point
=
await
findEventFrameEntry
(
info
.
checkpoint
info
.
progress
)
;
if
(
point
)
{
callback
(
point
[
"
Loading
.
.
.
"
]
)
;
evaluateLogpoint
(
{
point
text
:
"
arguments
[
0
]
"
callback
}
)
;
}
}
}
}
function
setActiveEventBreakpoints
(
events
callback
)
{
dumpv
(
SetActiveEventBreakpoints
{
JSON
.
stringify
(
events
)
}
)
;
for
(
const
event
of
events
)
{
if
(
gLoggedEvents
.
some
(
info
=
>
info
.
event
=
=
event
)
)
{
continue
;
}
gLoggedEvents
.
push
(
{
event
callback
}
)
;
forAllSavedCheckpoints
(
checkpoint
=
>
findEventLogpointHits
(
checkpoint
event
callback
)
)
;
}
}
function
handleResumeManifestResponse
(
{
point
duration
consoleMessages
scripts
debuggerStatements
events
}
)
{
if
(
!
point
.
position
)
{
addCheckpoint
(
point
.
checkpoint
-
1
duration
)
;
getCheckpointInfo
(
point
.
checkpoint
)
.
point
=
point
;
}
if
(
gDebugger
)
{
consoleMessages
.
forEach
(
msg
=
>
{
gDebugger
.
_newConsoleMessage
(
msg
)
;
}
)
;
}
if
(
gDebugger
)
{
scripts
.
forEach
(
script
=
>
gDebugger
.
_onNewScript
(
script
)
)
;
}
consoleMessages
.
forEach
(
msg
=
>
{
if
(
msg
.
executionPoint
)
{
queuePauseData
(
{
point
:
msg
.
executionPoint
trackCached
:
true
}
)
;
}
}
)
;
const
savedCheckpoint
=
getSavedCheckpoint
(
point
.
position
?
point
.
checkpoint
:
point
.
checkpoint
-
1
)
;
for
(
const
point
of
debuggerStatements
)
{
getCheckpointInfo
(
savedCheckpoint
)
.
debuggerStatements
.
push
(
point
)
;
}
for
(
const
event
of
events
)
{
getCheckpointInfo
(
savedCheckpoint
)
.
events
.
push
(
event
)
;
}
if
(
RecordReplayControl
.
inRepaintStressMode
(
)
)
{
queuePauseData
(
{
point
}
)
;
}
}
function
maybeResumeRecording
(
)
{
if
(
gActiveChild
!
=
gMainChild
)
{
return
;
}
if
(
!
gLastFlushCheckpoint
|
|
timeSinceCheckpoint
(
gLastFlushCheckpoint
)
>
=
FlushMs
)
{
ensureFlushed
(
)
;
}
const
checkpoint
=
gMainChild
.
pausePoint
(
)
.
checkpoint
;
if
(
!
gMainChild
.
recording
&
&
checkpoint
=
=
gRecordingEndpoint
)
{
ensureFlushed
(
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
HitRecordingEndpoint
"
)
;
if
(
gDebugger
)
{
gDebugger
.
_hitRecordingBoundary
(
)
;
}
return
;
}
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
resume
"
breakpoints
:
gBreakpoints
pauseOnDebuggerStatement
:
true
}
onFinished
(
response
)
{
handleResumeManifestResponse
(
response
)
;
gPausePoint
=
gMainChild
.
pausePoint
(
)
;
if
(
gDebugger
)
{
gDebugger
.
_onPause
(
)
;
}
else
{
Services
.
tm
.
dispatchToMainThread
(
maybeResumeRecording
)
;
}
}
}
)
;
}
const
gFlushWaiters
=
[
]
;
function
waitForFlushed
(
checkpoint
)
{
if
(
checkpoint
<
gLastFlushCheckpoint
)
{
return
undefined
;
}
return
new
Promise
(
resolve
=
>
{
gFlushWaiters
.
push
(
resolve
)
;
}
)
;
}
let
gLastFlushTime
=
Date
.
now
(
)
;
function
ensureFlushed
(
)
{
gMainChild
.
waitUntilPaused
(
true
)
;
gLastFlushTime
=
Date
.
now
(
)
;
if
(
gLastFlushCheckpoint
=
=
gMainChild
.
pauseCheckpoint
(
)
)
{
return
;
}
if
(
gMainChild
.
recording
)
{
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
flushRecording
"
}
onFinished
(
)
{
}
}
)
;
gMainChild
.
waitUntilPaused
(
)
;
}
const
oldFlushCheckpoint
=
gLastFlushCheckpoint
|
|
FirstCheckpointId
;
gLastFlushCheckpoint
=
gMainChild
.
pauseCheckpoint
(
)
;
if
(
gReplayingChildren
.
length
=
=
0
)
{
spawnReplayingChildren
(
)
;
}
addSavedCheckpoint
(
gLastFlushCheckpoint
)
;
forSavedCheckpointsInRange
(
oldFlushCheckpoint
gLastFlushCheckpoint
checkpoint
=
>
{
scanRecording
(
checkpoint
)
;
gBreakpoints
.
forEach
(
position
=
>
findBreakpointHits
(
checkpoint
position
)
)
;
gLogpoints
.
forEach
(
logpoint
=
>
findLogpointHits
(
checkpoint
logpoint
)
)
;
for
(
const
{
event
callback
}
of
gLoggedEvents
)
{
findEventLogpointHits
(
checkpoint
event
callback
)
;
}
}
)
;
for
(
const
waiter
of
gFlushWaiters
)
{
waiter
(
)
;
}
gFlushWaiters
.
length
=
0
;
pokeChildren
(
)
;
}
const
CheckFlushMs
=
1000
;
setInterval
(
(
)
=
>
{
const
elapsed
=
Date
.
now
(
)
-
gLastFlushTime
;
if
(
elapsed
>
CheckFlushMs
&
&
gMainChild
.
lastPausePoint
&
&
gMainChild
.
lastPausePoint
.
checkpoint
!
=
gLastFlushCheckpoint
)
{
ensureFlushed
(
)
;
}
for
(
const
child
of
gReplayingChildren
)
{
if
(
child
)
{
RecordReplayControl
.
maybePing
(
child
.
id
)
;
}
}
}
1000
)
;
function
BeforeSaveRecording
(
)
{
if
(
gActiveChild
=
=
gMainChild
)
{
ensureFlushed
(
)
;
}
}
function
AfterSaveRecording
(
)
{
Services
.
cpmm
.
sendAsyncMessage
(
"
SaveRecordingFinished
"
)
;
}
let
gRecordingEndpoint
;
function
setMainChild
(
)
{
assert
(
!
gMainChild
.
recording
)
;
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
setMainChild
"
}
onFinished
(
{
endpoint
}
)
{
gRecordingEndpoint
=
endpoint
;
Services
.
tm
.
dispatchToMainThread
(
maybeResumeRecording
)
;
}
}
)
;
}
function
spawnReplayingChild
(
)
{
const
id
=
RecordReplayControl
.
spawnReplayingChild
(
)
;
const
child
=
new
ChildProcess
(
id
false
)
;
gReplayingChildren
[
id
]
=
child
;
return
child
;
}
const
NumReplayingChildren
=
4
;
function
spawnReplayingChildren
(
)
{
if
(
RecordReplayControl
.
canRewind
(
)
)
{
for
(
let
i
=
0
;
i
<
NumReplayingChildren
;
i
+
+
)
{
spawnReplayingChild
(
)
;
}
}
addSavedCheckpoint
(
FirstCheckpointId
)
;
}
function
Initialize
(
recordingChildId
)
{
try
{
if
(
recordingChildId
!
=
undefined
)
{
gMainChild
=
new
ChildProcess
(
recordingChildId
true
)
;
}
else
{
const
id
=
RecordReplayControl
.
spawnReplayingChild
(
)
;
gMainChild
=
new
ChildProcess
(
id
false
)
;
spawnReplayingChildren
(
)
;
}
gActiveChild
=
gMainChild
;
return
gControl
;
}
catch
(
e
)
{
dump
(
ERROR
:
Initialize
threw
exception
:
{
e
}
\
n
)
;
}
}
function
ManifestFinished
(
id
response
)
{
try
{
dumpv
(
ManifestFinished
#
{
id
}
{
stringify
(
response
)
}
)
;
const
child
=
lookupChild
(
id
)
;
if
(
child
)
{
child
.
manifestFinished
(
response
)
;
}
else
{
}
}
catch
(
e
)
{
dump
(
ERROR
:
ManifestFinished
threw
exception
:
{
e
}
{
e
.
stack
}
\
n
)
;
}
}
const
gControl
=
{
pausePoint
(
)
{
if
(
gActiveChild
&
&
gActiveChild
=
=
gMainChild
)
{
return
gActiveChild
.
paused
?
gActiveChild
.
pausePoint
(
)
:
null
;
}
if
(
gPauseMode
=
=
PauseModes
.
PAUSED
|
|
gPauseMode
=
=
PauseModes
.
ARRIVING
)
{
return
gPausePoint
;
}
return
null
;
}
lastPausePoint
(
)
{
return
gPausePoint
;
}
findFrameSteps
(
point
)
{
return
findFrameSteps
(
point
)
;
}
async
findAncestorFrameEntryPoint
(
point
index
)
{
const
steps
=
await
findFrameSteps
(
point
)
;
point
=
steps
[
0
]
;
while
(
index
-
-
)
{
point
=
await
findParentFrameEntryPoint
(
point
)
;
}
return
point
;
}
childIsRecording
(
)
{
return
gActiveChild
&
&
gActiveChild
.
recording
;
}
waitUntilPaused
(
)
{
assert
(
gActiveChild
)
;
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
}
}
addBreakpoint
(
position
)
{
dumpv
(
AddBreakpoint
{
JSON
.
stringify
(
position
)
}
)
;
gBreakpoints
.
push
(
position
)
;
if
(
canFindHits
(
position
)
)
{
forAllSavedCheckpoints
(
checkpoint
=
>
findBreakpointHits
(
checkpoint
position
)
)
;
}
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
}
simulateNearbyNavigation
(
)
;
}
clearBreakpoints
(
)
{
dumpv
(
ClearBreakpoints
)
;
gBreakpoints
.
length
=
0
;
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
}
}
recordingEndpoint
(
)
{
return
gMainChild
.
lastPausePoint
;
}
maybeSwitchToReplayingChild
(
)
{
assert
(
gControl
.
pausePoint
(
)
)
;
if
(
gActiveChild
=
=
gMainChild
&
&
RecordReplayControl
.
canRewind
(
)
)
{
const
point
=
gActiveChild
.
pausePoint
(
)
;
if
(
point
.
position
)
{
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
resume
"
breakpoints
:
[
]
pauseOnDebuggerStatement
:
false
}
onFinished
(
response
)
{
handleResumeManifestResponse
(
response
)
;
}
}
)
;
gMainChild
.
waitUntilPaused
(
true
)
;
}
ensureFlushed
(
)
;
const
child
=
closestChild
(
point
)
;
pauseReplayingChild
(
child
point
)
;
}
}
sendRequest
(
request
)
{
waitUntilPauseFinishes
(
)
;
let
data
;
gActiveChild
.
sendManifest
(
{
contents
:
{
kind
:
"
debuggerRequest
"
request
}
onFinished
(
finishData
)
{
data
=
finishData
;
}
mightRewind
:
true
}
)
;
gActiveChild
.
waitUntilPaused
(
)
;
if
(
data
.
restoredSnapshot
)
{
pauseReplayingChild
(
gActiveChild
gPausePoint
)
;
return
{
unhandledDivergence
:
true
}
;
}
if
(
data
.
divergedFromRecording
)
{
gActiveChild
.
divergedFromRecording
=
true
;
}
addDebuggerRequest
(
request
)
;
return
data
.
response
;
}
sendRequestMainChild
(
request
)
{
gMainChild
.
waitUntilPaused
(
true
)
;
let
data
;
gMainChild
.
sendManifest
(
{
contents
:
{
kind
:
"
debuggerRequest
"
request
}
onFinished
(
finishData
)
{
data
=
finishData
;
}
}
)
;
gMainChild
.
waitUntilPaused
(
)
;
assert
(
!
data
.
divergedFromRecording
)
;
return
data
.
response
;
}
resume
timeWarp
addLogpoint
(
logpoint
)
{
gLogpoints
.
push
(
logpoint
)
;
forAllSavedCheckpoints
(
checkpoint
=
>
findLogpointHits
(
checkpoint
logpoint
)
)
;
}
setActiveEventBreakpoints
unscannedRegions
cachedPoints
debuggerRequests
(
)
{
return
gDebuggerRequests
;
}
getPauseDataAndRepaint
(
)
{
if
(
gPauseMode
=
=
PauseModes
.
ARRIVING
&
&
!
gDebuggerRequests
.
length
)
{
const
data
=
maybeGetPauseData
(
gPausePoint
)
;
if
(
data
)
{
addDebuggerRequest
(
{
type
:
"
pauseData
"
}
)
;
RecordReplayControl
.
hadRepaint
(
data
.
paintData
)
;
return
data
;
}
}
gControl
.
maybeSwitchToReplayingChild
(
)
;
const
data
=
gControl
.
sendRequest
(
{
type
:
"
pauseData
"
}
)
;
if
(
data
.
unhandledDivergence
)
{
RecordReplayControl
.
clearGraphics
(
)
;
}
else
{
addPauseData
(
gPausePoint
data
true
)
;
if
(
data
.
paintData
)
{
RecordReplayControl
.
hadRepaint
(
data
.
paintData
)
;
}
}
return
data
;
}
paint
(
point
)
{
const
data
=
maybeGetPauseData
(
point
)
;
if
(
data
&
&
data
.
paintData
)
{
RecordReplayControl
.
hadRepaint
(
data
.
paintData
)
;
}
}
isPausedAtDebuggerStatement
(
)
{
const
point
=
gControl
.
pausePoint
(
)
;
if
(
point
)
{
const
checkpoint
=
getSavedCheckpoint
(
point
.
checkpoint
)
;
const
{
debuggerStatements
}
=
getCheckpointInfo
(
checkpoint
)
;
return
pointArrayIncludes
(
debuggerStatements
point
)
;
}
return
false
;
}
}
;
let
lastDumpTime
=
Date
.
now
(
)
;
function
maybeDumpStatistics
(
)
{
const
now
=
Date
.
now
(
)
;
if
(
now
-
lastDumpTime
<
5000
)
{
return
;
}
lastDumpTime
=
now
;
let
delayTotal
=
0
;
let
unscannedTotal
=
0
;
let
timeTotal
=
0
;
let
scanDurationTotal
=
0
;
forAllSavedCheckpoints
(
checkpoint
=
>
{
const
checkpointTime
=
timeForSavedCheckpoint
(
checkpoint
)
;
const
info
=
getCheckpointInfo
(
checkpoint
)
;
timeTotal
+
=
checkpointTime
;
if
(
info
.
scanTime
)
{
delayTotal
+
=
checkpointTime
*
(
info
.
scanTime
-
info
.
assignTime
)
;
scanDurationTotal
+
=
info
.
scanDuration
;
}
else
{
unscannedTotal
+
=
checkpointTime
;
}
}
)
;
const
memoryUsage
=
[
]
;
let
totalSaved
=
0
;
for
(
const
child
of
gReplayingChildren
)
{
if
(
!
child
)
{
continue
;
}
totalSaved
+
=
child
.
savedCheckpoints
.
size
;
if
(
!
child
.
lastMemoryUsage
)
{
continue
;
}
for
(
const
[
name
value
]
of
Object
.
entries
(
child
.
lastMemoryUsage
)
)
{
if
(
!
memoryUsage
[
name
]
)
{
memoryUsage
[
name
]
=
0
;
}
memoryUsage
[
name
]
+
=
value
;
}
}
const
delay
=
delayTotal
/
timeTotal
;
const
overhead
=
scanDurationTotal
/
(
timeTotal
-
unscannedTotal
)
;
dumpv
(
Statistics
:
)
;
dumpv
(
Total
recording
time
:
{
timeTotal
}
)
;
dumpv
(
Unscanned
fraction
:
{
unscannedTotal
/
timeTotal
}
)
;
dumpv
(
Average
scan
delay
:
{
delay
}
)
;
dumpv
(
Average
scanning
overhead
:
{
overhead
}
)
;
dumpv
(
Saved
checkpoints
:
{
totalSaved
}
)
;
for
(
const
[
name
value
]
of
Object
.
entries
(
memoryUsage
)
)
{
dumpv
(
Memory
{
name
}
:
{
value
}
)
;
}
}
function
getPreference
(
name
)
{
return
Services
.
prefs
.
getBoolPref
(
devtools
.
recordreplay
.
{
name
}
)
;
}
const
loggingFullEnabled
=
getPreference
(
"
loggingFull
"
)
;
const
loggingEnabled
=
loggingFullEnabled
|
|
getPreference
(
"
logging
"
)
;
function
ConnectDebugger
(
dbg
)
{
gDebugger
=
dbg
;
dbg
.
_control
=
gControl
;
}
const
startTime
=
Date
.
now
(
)
;
function
currentTime
(
)
{
return
(
(
(
Date
.
now
(
)
-
startTime
)
/
10
)
|
0
)
/
100
;
}
function
dumpv
(
str
)
{
if
(
loggingEnabled
)
{
dump
(
[
ReplayControl
{
currentTime
(
)
}
]
{
str
}
\
n
)
;
}
}
function
assert
(
v
)
{
if
(
!
v
)
{
ThrowError
(
"
Assertion
Failed
!
"
)
;
}
}
function
ThrowError
(
msg
)
{
const
error
=
new
Error
(
msg
)
;
dump
(
ReplayControl
Server
Error
:
{
msg
}
Stack
:
{
error
.
stack
}
\
n
)
;
throw
error
;
}
function
stringify
(
object
)
{
const
str
=
JSON
.
stringify
(
object
)
;
if
(
str
&
&
str
.
length
>
=
4096
&
&
!
loggingFullEnabled
)
{
return
{
str
.
substr
(
0
4096
)
}
TRIMMED
{
str
.
length
}
;
}
return
str
;
}
var
EXPORTED_SYMBOLS
=
[
"
Initialize
"
"
ConnectDebugger
"
"
ManifestFinished
"
"
BeforeSaveRecording
"
"
AfterSaveRecording
"
"
ChildCrashed
"
]
;
