"
use
strict
"
;
const
CC
=
Components
.
Constructor
;
const
sandbox
=
Cu
.
Sandbox
(
CC
(
"
mozilla
.
org
/
systemprincipal
;
1
"
"
nsIPrincipal
"
)
(
)
)
;
Cu
.
evalInSandbox
(
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
'
)
;
"
+
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
)
;
"
+
"
addDebuggerToGlobal
(
this
)
;
"
sandbox
)
;
const
RecordReplayControl
=
sandbox
.
RecordReplayControl
;
const
Services
=
sandbox
.
Services
;
const
InvalidCheckpointId
=
0
;
const
FirstCheckpointId
=
1
;
const
gChildren
=
[
]
;
let
gDebugger
;
function
ChildProcess
(
id
recording
role
)
{
assert
(
!
gChildren
[
id
]
)
;
gChildren
[
id
]
=
this
;
this
.
id
=
id
;
this
.
recording
=
recording
;
this
.
role
=
role
;
this
.
paused
=
false
;
this
.
lastPausePoint
=
null
;
this
.
lastPauseAtRecordingEndpoint
=
false
;
this
.
pauseNeeded
=
false
;
this
.
breakpoints
=
[
]
;
this
.
debuggerRequests
=
[
]
;
this
.
_willSaveCheckpoints
=
[
]
;
this
.
_majorCheckpoints
=
[
]
;
this
.
_minorCheckpoints
=
new
Set
(
)
;
if
(
!
recording
)
{
this
.
_willSaveCheckpoints
.
push
(
FirstCheckpointId
)
;
}
dumpv
(
InitRole
#
{
this
.
id
}
{
role
.
name
}
)
;
this
.
role
.
initialize
(
this
{
startup
:
true
}
)
;
}
ChildProcess
.
prototype
=
{
hitExecutionPoint
(
msg
)
{
assert
(
!
this
.
paused
)
;
this
.
paused
=
true
;
this
.
lastPausePoint
=
msg
.
point
;
this
.
lastPauseAtRecordingEndpoint
=
msg
.
recordingEndpoint
;
this
.
role
.
hitExecutionPoint
(
msg
)
;
}
setRole
(
role
)
{
dumpv
(
SetRole
#
{
this
.
id
}
{
role
.
name
}
)
;
this
.
role
=
role
;
this
.
role
.
initialize
(
this
{
startup
:
false
}
)
;
}
addMajorCheckpoint
(
checkpointId
)
{
this
.
_majorCheckpoints
.
push
(
checkpointId
)
;
}
addMinorCheckpoint
(
checkpointId
)
{
this
.
_minorCheckpoints
.
add
(
checkpointId
)
;
}
_unpause
(
)
{
this
.
paused
=
false
;
this
.
debuggerRequests
.
length
=
0
;
}
sendResume
(
{
forward
}
)
{
assert
(
this
.
paused
)
;
this
.
_unpause
(
)
;
RecordReplayControl
.
sendResume
(
this
.
id
forward
)
;
}
sendRestoreCheckpoint
(
checkpoint
)
{
assert
(
this
.
paused
)
;
this
.
_unpause
(
)
;
RecordReplayControl
.
sendRestoreCheckpoint
(
this
.
id
checkpoint
)
;
}
sendRunToPoint
(
point
)
{
assert
(
this
.
paused
)
;
this
.
_unpause
(
)
;
RecordReplayControl
.
sendRunToPoint
(
this
.
id
point
)
;
}
sendFlushRecording
(
)
{
assert
(
this
.
paused
)
;
RecordReplayControl
.
sendFlushRecording
(
this
.
id
)
;
}
waitUntilPaused
(
maybeCreateCheckpoint
)
{
if
(
this
.
paused
)
{
return
;
}
const
msg
=
RecordReplayControl
.
waitUntilPaused
(
this
.
id
maybeCreateCheckpoint
)
;
this
.
hitExecutionPoint
(
msg
)
;
assert
(
this
.
paused
)
;
}
lastCheckpoint
(
)
{
return
this
.
lastPausePoint
.
checkpoint
;
}
rewindTargetCheckpoint
(
)
{
return
this
.
lastPausePoint
.
position
?
this
.
lastCheckpoint
(
)
:
this
.
lastCheckpoint
(
)
-
1
;
}
lastMajorCheckpointPreceding
(
id
)
{
let
last
=
InvalidCheckpointId
;
for
(
const
major
of
this
.
_majorCheckpoints
)
{
if
(
major
>
id
)
{
break
;
}
last
=
major
;
}
return
last
;
}
isMajorCheckpoint
(
id
)
{
return
this
.
_majorCheckpoints
.
some
(
major
=
>
major
=
=
id
)
;
}
isMinorCheckpoint
(
id
)
{
return
this
.
_minorCheckpoints
.
has
(
id
)
;
}
ensureCheckpointSaved
(
id
shouldSave
)
{
const
willSaveIndex
=
this
.
_willSaveCheckpoints
.
indexOf
(
id
)
;
if
(
shouldSave
!
=
(
willSaveIndex
!
=
-
1
)
)
{
if
(
shouldSave
)
{
this
.
_willSaveCheckpoints
.
push
(
id
)
;
}
else
{
const
last
=
this
.
_willSaveCheckpoints
.
pop
(
)
;
if
(
willSaveIndex
!
=
this
.
_willSaveCheckpoints
.
length
)
{
this
.
_willSaveCheckpoints
[
willSaveIndex
]
=
last
;
}
}
RecordReplayControl
.
sendSetSaveCheckpoint
(
this
.
id
id
shouldSave
)
;
}
}
ensureMajorCheckpointSaved
(
id
)
{
this
.
ensureCheckpointSaved
(
id
this
.
isMajorCheckpoint
(
id
)
|
|
id
=
=
FirstCheckpointId
)
;
}
hasSavedCheckpoint
(
id
)
{
return
(
id
<
=
this
.
lastCheckpoint
(
)
)
&
&
this
.
_willSaveCheckpoints
.
includes
(
id
)
;
}
canRewindFrom
(
id
)
{
const
lastMajorCheckpoint
=
this
.
lastMajorCheckpointPreceding
(
id
)
;
for
(
let
i
=
lastMajorCheckpoint
+
1
;
i
<
=
id
;
i
+
+
)
{
if
(
this
.
isMinorCheckpoint
(
i
)
&
&
!
this
.
hasSavedCheckpoint
(
i
)
)
{
return
false
;
}
}
return
true
;
}
lastSavedCheckpointPriorTo
(
id
)
{
while
(
!
this
.
hasSavedCheckpoint
(
id
)
)
{
id
-
-
;
}
return
id
;
}
sendAddBreakpoint
(
pos
)
{
assert
(
this
.
paused
)
;
this
.
breakpoints
.
push
(
pos
)
;
RecordReplayControl
.
sendAddBreakpoint
(
this
.
id
pos
)
;
}
sendClearBreakpoints
(
)
{
assert
(
this
.
paused
)
;
this
.
breakpoints
.
length
=
0
;
RecordReplayControl
.
sendClearBreakpoints
(
this
.
id
)
;
}
sendDebuggerRequest
(
request
)
{
assert
(
this
.
paused
)
;
this
.
debuggerRequests
.
push
(
request
)
;
return
RecordReplayControl
.
sendDebuggerRequest
(
this
.
id
request
)
;
}
}
;
const
FlushMs
=
.
5
*
1000
;
const
MajorCheckpointMs
=
2
*
1000
;
const
MinorCheckpointMs
=
.
25
*
1000
;
let
gRecordingChild
;
let
gFirstReplayingChild
;
let
gSecondReplayingChild
;
let
gActiveChild
;
function
otherReplayingChild
(
child
)
{
assert
(
child
=
=
gFirstReplayingChild
|
|
child
=
=
gSecondReplayingChild
)
;
return
child
=
=
gFirstReplayingChild
?
gSecondReplayingChild
:
gFirstReplayingChild
;
}
function
ChildRoleActive
(
)
{
}
ChildRoleActive
.
prototype
=
{
name
:
"
Active
"
initialize
(
child
{
startup
}
)
{
this
.
child
=
child
;
gActiveChild
=
child
;
if
(
!
startup
)
{
RecordReplayControl
.
setActiveChild
(
child
.
id
)
;
}
}
hitExecutionPoint
(
msg
)
{
if
(
gTimeWarpInProgress
)
{
return
;
}
if
(
msg
.
point
.
checkpoint
=
=
FirstCheckpointId
)
{
RecordReplayControl
.
setActiveChild
(
this
.
child
.
id
)
;
}
updateCheckpointTimes
(
msg
)
;
if
(
msg
.
recordingEndpoint
)
{
resume
(
true
)
;
return
;
}
if
(
!
gDebugger
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
this
.
child
.
sendResume
(
{
forward
:
true
}
)
)
;
return
;
}
gDebugger
.
_onPause
(
)
;
}
poke
(
)
{
}
}
;
let
gLastRecordingCheckpoint
;
function
ChildRoleStandby
(
)
{
}
ChildRoleStandby
.
prototype
=
{
name
:
"
Standby
"
initialize
(
child
{
startup
}
)
{
this
.
child
=
child
;
if
(
!
startup
)
{
this
.
poke
(
)
;
}
}
hitExecutionPoint
(
msg
)
{
assert
(
!
msg
.
point
.
position
)
;
this
.
poke
(
)
;
}
poke
(
)
{
assert
(
this
.
child
.
paused
&
&
!
this
.
child
.
lastPausePoint
.
position
)
;
const
currentCheckpoint
=
this
.
child
.
lastCheckpoint
(
)
;
if
(
this
.
child
.
pauseNeeded
)
{
return
;
}
let
targetCheckpoint
=
getActiveChildTargetCheckpoint
(
)
;
if
(
targetCheckpoint
=
=
undefined
)
{
if
(
(
currentCheckpoint
<
gActiveChild
.
lastCheckpoint
(
)
)
&
&
(
!
gRecordingChild
|
|
currentCheckpoint
<
gLastRecordingCheckpoint
)
)
{
this
.
child
.
ensureMajorCheckpointSaved
(
currentCheckpoint
+
1
)
;
this
.
child
.
sendResume
(
{
forward
:
true
}
)
;
}
return
;
}
const
lastMajorCheckpoint
=
this
.
child
.
lastMajorCheckpointPreceding
(
targetCheckpoint
)
;
if
(
lastMajorCheckpoint
=
=
InvalidCheckpointId
)
{
return
;
}
if
(
currentCheckpoint
<
lastMajorCheckpoint
)
{
this
.
child
.
ensureMajorCheckpointSaved
(
currentCheckpoint
+
1
)
;
this
.
child
.
sendResume
(
{
forward
:
true
}
)
;
return
;
}
const
otherChild
=
otherReplayingChild
(
this
.
child
)
;
const
otherMajorCheckpoint
=
otherChild
.
lastMajorCheckpointPreceding
(
targetCheckpoint
)
;
if
(
otherMajorCheckpoint
>
lastMajorCheckpoint
)
{
assert
(
otherMajorCheckpoint
<
=
targetCheckpoint
)
;
targetCheckpoint
=
otherMajorCheckpoint
-
1
;
}
let
missingCheckpoint
;
for
(
let
i
=
lastMajorCheckpoint
+
1
;
i
<
=
targetCheckpoint
;
i
+
+
)
{
if
(
this
.
child
.
isMinorCheckpoint
(
i
)
&
&
!
this
.
child
.
hasSavedCheckpoint
(
i
)
)
{
missingCheckpoint
=
i
;
break
;
}
}
if
(
missingCheckpoint
=
=
undefined
)
{
return
;
}
if
(
this
.
child
.
lastCheckpoint
(
)
<
missingCheckpoint
)
{
}
else
{
let
restoreTarget
=
missingCheckpoint
-
1
;
while
(
!
this
.
child
.
hasSavedCheckpoint
(
restoreTarget
)
)
{
restoreTarget
-
-
;
}
assert
(
restoreTarget
>
=
lastMajorCheckpoint
)
;
this
.
child
.
sendRestoreCheckpoint
(
restoreTarget
)
;
return
;
}
if
(
missingCheckpoint
=
=
this
.
child
.
lastCheckpoint
(
)
+
1
)
{
this
.
child
.
ensureCheckpointSaved
(
missingCheckpoint
true
)
;
}
this
.
child
.
sendResume
(
{
forward
:
true
}
)
;
}
}
;
function
ChildRoleInert
(
)
{
}
ChildRoleInert
.
prototype
=
{
name
:
"
Inert
"
initialize
(
)
{
}
hitExecutionPoint
(
)
{
}
poke
(
)
{
}
}
;
function
pokeChildren
(
)
{
for
(
const
child
of
gChildren
)
{
if
(
child
&
&
!
child
.
recording
&
&
child
.
paused
)
{
child
.
pauseNeeded
=
false
;
child
.
role
.
poke
(
)
;
}
}
}
function
switchActiveChild
(
child
recoverPosition
=
true
)
{
assert
(
child
!
=
gActiveChild
)
;
assert
(
gActiveChild
.
paused
)
;
const
oldActiveChild
=
gActiveChild
;
child
.
pauseNeeded
=
true
;
child
.
waitUntilPaused
(
)
;
child
.
pauseNeeded
=
false
;
assert
(
child
.
breakpoints
.
length
=
=
0
)
;
for
(
const
pos
of
oldActiveChild
.
breakpoints
)
{
child
.
sendAddBreakpoint
(
pos
)
;
}
oldActiveChild
.
sendClearBreakpoints
(
)
;
if
(
recoverPosition
&
&
!
child
.
recording
)
{
child
.
setRole
(
new
ChildRoleInert
(
)
)
;
const
targetCheckpoint
=
oldActiveChild
.
lastCheckpoint
(
)
;
if
(
child
.
lastCheckpoint
(
)
>
targetCheckpoint
)
{
const
restoreCheckpoint
=
child
.
lastSavedCheckpointPriorTo
(
targetCheckpoint
)
;
child
.
sendRestoreCheckpoint
(
restoreCheckpoint
)
;
child
.
waitUntilPaused
(
)
;
}
while
(
child
.
lastCheckpoint
(
)
<
targetCheckpoint
)
{
child
.
ensureMajorCheckpointSaved
(
child
.
lastCheckpoint
(
)
+
1
)
;
child
.
sendResume
(
{
forward
:
true
}
)
;
child
.
waitUntilPaused
(
)
;
}
assert
(
!
child
.
lastPausePoint
.
position
)
;
if
(
oldActiveChild
.
lastPausePoint
.
position
)
{
child
.
sendRunToPoint
(
oldActiveChild
.
lastPausePoint
)
;
child
.
waitUntilPaused
(
)
;
}
for
(
const
request
of
oldActiveChild
.
debuggerRequests
)
{
child
.
sendDebuggerRequest
(
request
)
;
}
}
child
.
setRole
(
new
ChildRoleActive
(
)
)
;
oldActiveChild
.
setRole
(
new
ChildRoleInert
(
)
)
;
if
(
!
oldActiveChild
.
recording
)
{
if
(
oldActiveChild
.
lastPausePoint
.
position
)
{
const
oldCheckpoint
=
oldActiveChild
.
lastCheckpoint
(
)
;
const
restoreCheckpoint
=
oldActiveChild
.
lastSavedCheckpointPriorTo
(
oldCheckpoint
)
;
oldActiveChild
.
sendRestoreCheckpoint
(
restoreCheckpoint
)
;
oldActiveChild
.
waitUntilPaused
(
)
;
}
oldActiveChild
.
setRole
(
new
ChildRoleStandby
(
)
)
;
}
if
(
child
.
recording
!
=
oldActiveChild
.
recording
)
{
gDebugger
.
_onSwitchChild
(
)
;
}
}
function
maybeSwitchToReplayingChild
(
)
{
if
(
gActiveChild
.
recording
&
&
RecordReplayControl
.
canRewind
(
)
)
{
flushRecording
(
)
;
const
checkpoint
=
gActiveChild
.
rewindTargetCheckpoint
(
)
;
const
child
=
otherReplayingChild
(
replayingChildResponsibleForSavingCheckpoint
(
checkpoint
)
)
;
switchActiveChild
(
child
)
;
}
}
const
gCheckpointTimes
=
[
]
;
let
gTimeSinceLastFlush
;
let
gTimeSinceLastMajorCheckpoint
=
0
;
let
gTimeSinceLastMinorCheckpoint
=
0
;
let
gLastAssignedMajorCheckpoint
;
function
assignMajorCheckpoint
(
child
checkpointId
)
{
dumpv
(
AssignMajorCheckpoint
:
#
{
child
.
id
}
Checkpoint
{
checkpointId
}
)
;
child
.
addMajorCheckpoint
(
checkpointId
)
;
gLastAssignedMajorCheckpoint
=
child
;
}
function
assignMinorCheckpoint
(
child
checkpointId
)
{
dumpv
(
AssignMinorCheckpoint
:
#
{
child
.
id
}
Checkpoint
{
checkpointId
}
)
;
child
.
addMinorCheckpoint
(
checkpointId
)
;
}
function
updateCheckpointTimes
(
msg
)
{
if
(
msg
.
point
.
checkpoint
!
=
gCheckpointTimes
.
length
+
1
|
|
msg
.
point
.
position
)
{
return
;
}
gCheckpointTimes
.
push
(
msg
.
duration
)
;
if
(
gActiveChild
.
recording
)
{
gTimeSinceLastFlush
+
=
msg
.
duration
;
if
(
msg
.
point
.
checkpoint
=
=
FirstCheckpointId
|
|
gTimeSinceLastFlush
>
=
FlushMs
)
{
if
(
maybeFlushRecording
(
)
)
{
gTimeSinceLastFlush
=
0
;
}
}
}
gTimeSinceLastMajorCheckpoint
+
=
msg
.
duration
;
gTimeSinceLastMinorCheckpoint
+
=
msg
.
duration
;
if
(
gTimeSinceLastMajorCheckpoint
>
=
MajorCheckpointMs
)
{
const
child
=
otherReplayingChild
(
gLastAssignedMajorCheckpoint
)
;
assignMajorCheckpoint
(
child
msg
.
point
.
checkpoint
+
1
)
;
gTimeSinceLastMajorCheckpoint
=
0
;
}
else
if
(
gTimeSinceLastMinorCheckpoint
>
=
MinorCheckpointMs
)
{
assignMinorCheckpoint
(
gLastAssignedMajorCheckpoint
msg
.
point
.
checkpoint
+
1
)
;
gTimeSinceLastMinorCheckpoint
=
0
;
}
}
function
replayingChildResponsibleForSavingCheckpoint
(
id
)
{
assert
(
gFirstReplayingChild
&
&
gSecondReplayingChild
)
;
const
firstMajor
=
gFirstReplayingChild
.
lastMajorCheckpointPreceding
(
id
)
;
const
secondMajor
=
gSecondReplayingChild
.
lastMajorCheckpointPreceding
(
id
)
;
return
(
firstMajor
<
secondMajor
)
?
gSecondReplayingChild
:
gFirstReplayingChild
;
}
function
flushRecording
(
)
{
assert
(
gActiveChild
.
recording
&
&
gActiveChild
.
paused
)
;
for
(
const
child
of
gChildren
)
{
if
(
child
&
&
!
child
.
recording
)
{
child
.
pauseNeeded
=
true
;
child
.
waitUntilPaused
(
)
;
}
}
gActiveChild
.
sendFlushRecording
(
)
;
for
(
const
child
of
gChildren
)
{
if
(
child
&
&
!
child
.
recording
)
{
child
.
pauseNeeded
=
false
;
child
.
role
.
poke
(
)
;
}
}
maybeResumeSearch
(
)
;
gLastRecordingCheckpoint
=
gActiveChild
.
lastCheckpoint
(
)
;
if
(
!
gFirstReplayingChild
)
{
spawnInitialReplayingChildren
(
)
;
}
}
function
maybeFlushRecording
(
)
{
assert
(
gActiveChild
.
recording
&
&
gActiveChild
.
paused
)
;
let
allPaused
=
true
;
for
(
const
child
of
gChildren
)
{
if
(
child
&
&
!
child
.
recording
)
{
child
.
pauseNeeded
=
true
;
allPaused
&
=
child
.
paused
;
}
}
if
(
allPaused
)
{
flushRecording
(
)
;
return
true
;
}
return
false
;
}
function
BeforeSaveRecording
(
)
{
if
(
gActiveChild
.
recording
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
flushRecording
(
)
;
}
}
function
AfterSaveRecording
(
)
{
Services
.
cpmm
.
sendAsyncMessage
(
"
SaveRecordingFinished
"
)
;
}
function
spawnReplayingChild
(
role
)
{
const
id
=
RecordReplayControl
.
spawnReplayingChild
(
)
;
return
new
ChildProcess
(
id
false
role
)
;
}
function
spawnInitialReplayingChildren
(
)
{
gFirstReplayingChild
=
spawnReplayingChild
(
gRecordingChild
?
new
ChildRoleStandby
(
)
:
new
ChildRoleActive
(
)
)
;
gSecondReplayingChild
=
spawnReplayingChild
(
new
ChildRoleStandby
(
)
)
;
assignMajorCheckpoint
(
gSecondReplayingChild
FirstCheckpointId
)
;
}
function
Initialize
(
recordingChildId
)
{
try
{
if
(
recordingChildId
!
=
undefined
)
{
gRecordingChild
=
new
ChildProcess
(
recordingChildId
true
new
ChildRoleActive
(
)
)
;
}
else
{
spawnInitialReplayingChildren
(
)
;
}
return
gControl
;
}
catch
(
e
)
{
dump
(
ERROR
:
Initialize
threw
exception
:
{
e
}
\
n
)
;
}
}
function
HitExecutionPoint
(
id
msg
)
{
try
{
dumpv
(
HitExecutionPoint
#
{
id
}
{
JSON
.
stringify
(
msg
)
}
)
;
gChildren
[
id
]
.
hitExecutionPoint
(
msg
)
;
}
catch
(
e
)
{
dump
(
ERROR
:
HitExecutionPoint
threw
exception
:
{
e
}
\
n
)
;
}
}
let
gLastExplicitPause
=
FirstCheckpointId
;
function
getActiveChildTargetCheckpoint
(
)
{
if
(
gActiveChild
.
rewindTargetCheckpoint
(
)
<
=
gLastExplicitPause
)
{
return
gActiveChild
.
rewindTargetCheckpoint
(
)
;
}
return
undefined
;
}
function
markExplicitPause
(
)
{
assert
(
gActiveChild
.
paused
)
;
const
targetCheckpoint
=
gActiveChild
.
rewindTargetCheckpoint
(
)
;
if
(
gActiveChild
.
recording
)
{
flushRecording
(
)
;
}
else
if
(
RecordReplayControl
.
canRewind
(
)
)
{
if
(
gActiveChild
=
=
replayingChildResponsibleForSavingCheckpoint
(
targetCheckpoint
)
)
{
if
(
!
gActiveChild
.
canRewindFrom
(
targetCheckpoint
)
)
{
switchActiveChild
(
otherReplayingChild
(
gActiveChild
)
)
;
}
}
}
gLastExplicitPause
=
targetCheckpoint
;
dumpv
(
MarkActiveChildExplicitPause
{
gLastExplicitPause
}
)
;
pokeChildren
(
)
;
}
function
maybeSendRepaintMessage
(
)
{
if
(
RecordReplayControl
.
inRepaintStressMode
(
)
)
{
maybeSwitchToReplayingChild
(
)
;
const
rv
=
gActiveChild
.
sendRequest
(
{
type
:
"
repaint
"
}
)
;
if
(
"
width
"
in
rv
&
&
"
height
"
in
rv
)
{
RecordReplayControl
.
hadRepaint
(
rv
.
width
rv
.
height
)
;
}
}
}
function
waitUntilChildHasSavedCheckpoint
(
child
checkpoint
)
{
while
(
true
)
{
child
.
pauseNeeded
=
true
;
child
.
waitUntilPaused
(
)
;
child
.
pauseNeeded
=
false
;
if
(
child
.
hasSavedCheckpoint
(
checkpoint
)
)
{
return
;
}
child
.
role
.
poke
(
)
;
}
}
function
resume
(
forward
)
{
assert
(
gActiveChild
.
paused
)
;
maybeSendRepaintMessage
(
)
;
if
(
!
forward
)
{
const
targetCheckpoint
=
gActiveChild
.
rewindTargetCheckpoint
(
)
;
if
(
targetCheckpoint
=
=
InvalidCheckpointId
)
{
Services
.
cpmm
.
sendAsyncMessage
(
"
HitRecordingBeginning
"
)
;
gDebugger
.
_onPause
(
gActiveChild
.
lastPausePoint
)
;
return
;
}
const
targetChild
=
replayingChildResponsibleForSavingCheckpoint
(
targetCheckpoint
)
;
if
(
targetChild
=
=
gActiveChild
)
{
assert
(
gActiveChild
.
canRewindFrom
(
targetCheckpoint
)
)
;
}
else
{
let
saveTarget
=
targetCheckpoint
;
while
(
!
targetChild
.
isMajorCheckpoint
(
saveTarget
)
&
&
!
targetChild
.
isMinorCheckpoint
(
saveTarget
)
)
{
saveTarget
-
-
;
}
waitUntilChildHasSavedCheckpoint
(
targetChild
saveTarget
)
;
switchActiveChild
(
targetChild
)
;
}
}
if
(
forward
)
{
if
(
gActiveChild
.
lastPauseAtRecordingEndpoint
)
{
assert
(
!
gActiveChild
.
recording
)
;
if
(
!
gRecordingChild
)
{
Services
.
cpmm
.
sendAsyncMessage
(
"
HitRecordingEndpoint
"
)
;
if
(
gDebugger
)
{
gDebugger
.
_onPause
(
gActiveChild
.
lastPausePoint
)
;
}
return
;
}
switchActiveChild
(
gRecordingChild
)
;
}
gActiveChild
.
ensureMajorCheckpointSaved
(
gActiveChild
.
lastCheckpoint
(
)
+
1
)
;
pokeChildren
(
)
;
}
gActiveChild
.
sendResume
(
{
forward
}
)
;
}
let
gTimeWarpInProgress
;
function
timeWarp
(
targetPoint
)
{
assert
(
gActiveChild
.
paused
)
;
const
targetCheckpoint
=
targetPoint
.
checkpoint
;
const
targetChild
=
replayingChildResponsibleForSavingCheckpoint
(
targetCheckpoint
)
;
if
(
targetChild
!
=
gActiveChild
)
{
switchActiveChild
(
otherReplayingChild
(
gActiveChild
)
)
;
}
let
restoreTarget
;
if
(
gActiveChild
.
lastCheckpoint
(
)
>
=
targetCheckpoint
)
{
restoreTarget
=
targetCheckpoint
;
}
else
if
(
gActiveChild
.
lastPausePoint
.
position
)
{
restoreTarget
=
gActiveChild
.
lastPausePoint
.
checkpoint
;
}
if
(
restoreTarget
)
{
while
(
!
gActiveChild
.
hasSavedCheckpoint
(
restoreTarget
)
)
{
restoreTarget
-
-
;
}
assert
(
!
gTimeWarpInProgress
)
;
gTimeWarpInProgress
=
true
;
gActiveChild
.
sendRestoreCheckpoint
(
restoreTarget
)
;
gActiveChild
.
waitUntilPaused
(
)
;
gTimeWarpInProgress
=
false
;
}
gActiveChild
.
sendRunToPoint
(
targetPoint
)
;
gActiveChild
.
waitUntilPaused
(
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
TimeWarpFinished
"
)
;
}
const
gControl
=
{
pausePoint
(
)
{
return
gActiveChild
.
paused
?
gActiveChild
.
lastPausePoint
:
null
;
}
childIsRecording
(
)
{
return
gActiveChild
.
recording
;
}
waitUntilPaused
(
)
{
while
(
!
gActiveChild
.
paused
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
}
}
addBreakpoint
(
pos
)
{
gActiveChild
.
sendAddBreakpoint
(
pos
)
;
}
clearBreakpoints
(
)
{
gActiveChild
.
sendClearBreakpoints
(
)
;
}
sendRequest
(
request
)
{
return
gActiveChild
.
sendDebuggerRequest
(
request
)
;
}
markExplicitPause
maybeSwitchToReplayingChild
resume
timeWarp
}
;
let
gSearchChild
;
let
gSearchRestartNeeded
;
function
maybeRestartSearch
(
)
{
if
(
gSearchRestartNeeded
&
&
gSearchChild
.
paused
)
{
if
(
gSearchChild
.
lastPausePoint
.
checkpoint
!
=
FirstCheckpointId
|
|
gSearchChild
.
lastPausePoint
.
position
)
{
gSearchChild
.
sendRestoreCheckpoint
(
FirstCheckpointId
)
;
gSearchChild
.
waitUntilPaused
(
)
;
}
gSearchChild
.
sendClearBreakpoints
(
)
;
gDebugger
.
_forEachSearch
(
pos
=
>
gSearchChild
.
sendAddBreakpoint
(
pos
)
)
;
gSearchRestartNeeded
=
false
;
gSearchChild
.
sendResume
(
{
forward
:
true
}
)
;
return
true
;
}
return
false
;
}
function
ChildRoleSearch
(
)
{
}
ChildRoleSearch
.
prototype
=
{
name
:
"
Search
"
initialize
(
child
{
startup
}
)
{
this
.
child
=
child
;
}
hitExecutionPoint
(
{
point
recordingEndpoint
}
)
{
if
(
maybeRestartSearch
(
)
)
{
return
;
}
if
(
point
.
position
)
{
gDebugger
.
_onSearchPause
(
point
)
;
}
if
(
!
recordingEndpoint
)
{
this
.
poke
(
)
;
}
}
poke
(
)
{
if
(
!
gSearchRestartNeeded
&
&
!
this
.
child
.
pauseNeeded
)
{
this
.
child
.
sendResume
(
{
forward
:
true
}
)
;
}
}
}
;
function
ensureHasSearchChild
(
)
{
if
(
!
gSearchChild
)
{
gSearchChild
=
spawnReplayingChild
(
new
ChildRoleSearch
(
)
)
;
}
}
function
maybeResumeSearch
(
)
{
if
(
gSearchChild
&
&
gSearchChild
.
paused
)
{
gSearchChild
.
sendResume
(
{
forward
:
true
}
)
;
}
}
const
gSearchControl
=
{
reset
(
)
{
ensureHasSearchChild
(
)
;
gSearchRestartNeeded
=
true
;
maybeRestartSearch
(
)
;
}
sendRequest
(
request
)
{
return
gSearchChild
.
sendDebuggerRequest
(
request
)
;
}
}
;
function
ConnectDebugger
(
dbg
)
{
gDebugger
=
dbg
;
dbg
.
_control
=
gControl
;
dbg
.
_searchControl
=
gSearchControl
;
}
function
dumpv
(
str
)
{
}
function
assert
(
v
)
{
if
(
!
v
)
{
ThrowError
(
"
Assertion
Failed
!
"
)
;
}
}
function
ThrowError
(
msg
)
{
const
error
=
new
Error
(
msg
)
;
dump
(
"
ReplayControl
Server
Error
:
"
+
msg
+
"
Stack
:
"
+
error
.
stack
+
"
\
n
"
)
;
throw
error
;
}
var
EXPORTED_SYMBOLS
=
[
"
Initialize
"
"
ConnectDebugger
"
"
HitExecutionPoint
"
"
BeforeSaveRecording
"
"
AfterSaveRecording
"
]
;
