"
use
strict
"
;
const
CC
=
Components
.
Constructor
;
const
sandbox
=
Cu
.
Sandbox
(
CC
(
"
mozilla
.
org
/
systemprincipal
;
1
"
"
nsIPrincipal
"
)
(
)
)
;
Cu
.
evalInSandbox
(
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
'
)
;
"
+
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
)
;
"
+
"
Components
.
utils
.
import
(
'
resource
:
/
/
devtools
/
shared
/
execution
-
point
-
utils
.
js
'
)
;
"
+
"
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
'
)
;
"
+
"
addDebuggerToGlobal
(
this
)
;
"
sandbox
)
;
const
{
RecordReplayControl
Services
pointEquals
pointToString
positionToString
findClosestPoint
pointArrayIncludes
pointPrecedes
positionSubsumes
setInterval
}
=
sandbox
;
const
InvalidCheckpointId
=
0
;
const
FirstCheckpointId
=
1
;
function
processId
(
rootId
forkId
)
{
return
forkId
?
#
{
rootId
}
:
{
forkId
}
:
#
{
rootId
}
;
}
let
gMainChild
;
const
gChildren
=
new
Map
(
)
;
const
gUnpausedChildren
=
new
Set
(
)
;
function
ChildProcess
(
rootId
forkId
recording
recordingLength
startPoint
)
{
this
.
rootId
=
rootId
;
this
.
forkId
=
forkId
;
this
.
id
=
processId
(
rootId
forkId
)
;
gChildren
.
set
(
this
.
id
this
)
;
this
.
recording
=
recording
;
this
.
recordingLength
=
recordingLength
;
this
.
startPoint
=
startPoint
;
this
.
paused
=
false
;
gUnpausedChildren
.
add
(
this
)
;
this
.
lastPausePoint
=
null
;
this
.
terminated
=
false
;
this
.
lastPingTime
=
Date
.
now
(
)
;
this
.
pings
=
[
]
;
this
.
manifests
=
[
{
manifest
:
{
kind
:
"
primordial
"
}
onFinished
:
(
{
point
maxRunningProcesses
}
)
=
>
{
if
(
this
=
=
gMainChild
)
{
getCheckpointInfo
(
FirstCheckpointId
)
.
point
=
point
;
Services
.
tm
.
dispatchToMainThread
(
recording
?
maybeResumeRecording
:
setMainChild
)
;
}
if
(
maxRunningProcesses
)
{
gMaxRunningLeafChildren
=
maxRunningProcesses
;
}
}
}
]
;
this
.
processedManifests
=
[
]
;
}
const
PingIntervalSeconds
=
2
;
const
MaxStalledPings
=
10
;
let
gNextPingId
=
1
;
ChildProcess
.
prototype
=
{
terminate
(
)
{
gChildren
.
delete
(
this
.
id
)
;
gUnpausedChildren
.
delete
(
this
)
;
RecordReplayControl
.
terminate
(
this
.
rootId
this
.
forkId
)
;
this
.
terminated
=
true
;
}
transplantFrom
(
newChild
)
{
assert
(
this
.
terminated
&
&
!
this
.
paused
)
;
assert
(
!
newChild
.
terminated
&
&
!
newChild
.
paused
)
;
this
.
terminated
=
false
;
newChild
.
terminated
=
true
;
gUnpausedChildren
.
delete
(
newChild
)
;
gUnpausedChildren
.
add
(
this
)
;
this
.
rootId
=
newChild
.
rootId
;
this
.
forkId
=
newChild
.
forkId
;
this
.
id
=
newChild
.
id
;
gChildren
.
set
(
this
.
id
this
)
;
this
.
recordingLength
=
newChild
.
recordingLength
;
this
.
startPoint
=
newChild
.
startPoint
;
this
.
lastPausePoint
=
newChild
.
lastPausePoint
;
this
.
lastPingTime
=
Date
.
now
(
)
;
this
.
pings
=
[
]
;
this
.
manifests
=
newChild
.
manifests
;
this
.
processedManifests
=
newChild
.
processedManifests
;
}
pausePoint
(
)
{
assert
(
this
.
paused
)
;
return
this
.
lastPausePoint
;
}
pauseCheckpoint
(
)
{
const
point
=
this
.
pausePoint
(
)
;
assert
(
!
point
.
position
)
;
return
point
.
checkpoint
;
}
sendManifest
(
manifest
onFinishedCallback
)
{
assert
(
!
this
.
terminated
)
;
return
new
Promise
(
resolve
=
>
{
this
.
manifests
.
push
(
{
manifest
onFinished
(
response
)
{
if
(
onFinishedCallback
)
{
onFinishedCallback
(
response
)
;
}
resolve
(
response
)
;
}
}
)
;
if
(
this
.
paused
)
{
this
.
_startNextManifest
(
)
;
}
}
)
;
}
manifestFinished
(
response
)
{
dumpv
(
ManifestFinished
{
this
.
id
}
{
stringify
(
response
)
}
)
;
assert
(
!
this
.
paused
)
;
this
.
paused
=
true
;
gUnpausedChildren
.
delete
(
this
)
;
const
{
manifest
onFinished
}
=
this
.
manifests
.
shift
(
)
;
if
(
response
)
{
if
(
response
.
point
)
{
this
.
lastPausePoint
=
response
.
point
;
}
if
(
response
.
exception
)
{
ThrowError
(
response
.
exception
)
;
}
}
onFinished
(
response
)
;
this
.
processedManifests
.
push
(
manifest
)
;
this
.
_startNextManifest
(
)
;
}
_startNextManifest
(
)
{
assert
(
this
.
paused
)
;
if
(
this
.
manifests
.
length
)
{
const
{
manifest
}
=
this
.
manifests
[
0
]
;
dumpv
(
SendManifest
{
this
.
id
}
{
stringify
(
manifest
)
}
)
;
RecordReplayControl
.
sendManifest
(
this
.
rootId
this
.
forkId
manifest
)
;
this
.
paused
=
false
;
gUnpausedChildren
.
add
(
this
)
;
this
.
pings
.
length
=
0
;
this
.
lastPingTime
=
Date
.
now
(
)
;
}
}
waitUntilPaused
(
maybeCreateCheckpoint
)
{
if
(
this
.
paused
)
{
return
;
}
dumpv
(
WaitUntilPaused
{
this
.
id
}
)
;
if
(
maybeCreateCheckpoint
)
{
assert
(
this
.
recording
&
&
!
this
.
forkId
)
;
RecordReplayControl
.
createCheckpointInRecording
(
this
.
rootId
)
;
}
while
(
!
this
.
paused
)
{
this
.
maybePing
(
)
;
RecordReplayControl
.
maybeProcessNextMessage
(
)
;
}
dumpv
(
WaitUntilPaused
Done
)
;
assert
(
this
.
paused
|
|
this
.
terminated
)
;
}
isHanged
(
)
{
if
(
this
.
pings
.
length
<
MaxStalledPings
)
{
return
false
;
}
const
firstIndex
=
this
.
pings
.
length
-
MaxStalledPings
;
const
firstValue
=
this
.
pings
[
firstIndex
]
.
progress
;
if
(
!
firstValue
)
{
return
true
;
}
for
(
let
i
=
firstIndex
;
i
<
this
.
pings
.
length
;
i
+
+
)
{
if
(
this
.
pings
[
i
]
.
progress
&
&
this
.
pings
[
i
]
.
progress
!
=
firstValue
)
{
return
false
;
}
}
return
true
;
}
maybePing
(
)
{
assert
(
!
this
.
paused
)
;
if
(
this
.
recording
)
{
return
;
}
const
now
=
Date
.
now
(
)
;
if
(
now
<
this
.
lastPingTime
+
PingIntervalSeconds
*
1000
)
{
return
;
}
if
(
this
.
isHanged
(
)
)
{
RecordReplayControl
.
crashHangedChild
(
this
.
rootId
this
.
forkId
)
;
ChildCrashed
(
this
.
rootId
this
.
forkId
)
;
}
else
{
const
id
=
gNextPingId
+
+
;
RecordReplayControl
.
ping
(
this
.
rootId
this
.
forkId
id
)
;
this
.
pings
.
push
(
{
id
}
)
;
this
.
lastPingTime
=
now
;
}
}
pingResponse
(
id
progress
)
{
for
(
const
entry
of
this
.
pings
)
{
if
(
entry
.
id
=
=
id
)
{
entry
.
progress
=
progress
;
break
;
}
}
}
updateRecording
(
length
)
{
RecordReplayControl
.
updateRecording
(
this
.
rootId
this
.
forkId
this
.
recordingLength
length
)
;
this
.
recordingLength
=
length
;
}
}
;
function
ManifestFinished
(
rootId
forkId
response
)
{
try
{
const
child
=
gChildren
.
get
(
processId
(
rootId
forkId
)
)
;
if
(
child
)
{
child
.
manifestFinished
(
response
)
;
}
}
catch
(
e
)
{
dump
(
ERROR
:
ManifestFinished
threw
exception
:
{
e
}
{
e
.
stack
}
\
n
)
;
}
}
function
PingResponse
(
rootId
forkId
pingId
progress
)
{
try
{
const
child
=
gChildren
.
get
(
processId
(
rootId
forkId
)
)
;
if
(
child
)
{
child
.
pingResponse
(
pingId
progress
)
;
}
}
catch
(
e
)
{
dump
(
ERROR
:
PingResponse
threw
exception
:
{
e
}
{
e
.
stack
}
\
n
)
;
}
}
let
gDebugger
;
const
Priority
=
{
HIGH
:
0
MEDIUM
:
1
LOW
:
2
}
;
let
gRootChild
;
let
gTrunkChild
;
const
gBranchChildren
=
[
]
;
let
gNextForkId
=
1
;
function
forkChild
(
child
point
)
{
const
forkId
=
gNextForkId
+
+
;
const
newChild
=
new
ChildProcess
(
child
.
rootId
forkId
false
child
.
recordingLength
point
)
;
dumpv
(
Forking
{
child
.
id
}
-
>
{
newChild
.
id
}
)
;
child
.
sendManifest
(
{
kind
:
"
fork
"
id
:
forkId
}
)
;
return
newChild
;
}
function
newLeafChild
(
endpoint
onFinished
=
(
)
=
>
{
}
)
{
assert
(
!
pointPrecedes
(
checkpointExecutionPoint
(
gLastSavedCheckpoint
)
endpoint
)
)
;
let
entry
;
for
(
let
i
=
gBranchChildren
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
entry
=
gBranchChildren
[
i
]
;
if
(
!
pointPrecedes
(
endpoint
entry
.
point
)
)
{
break
;
}
}
const
child
=
forkChild
(
entry
.
child
entry
.
point
)
;
if
(
pointEquals
(
endpoint
entry
.
point
)
)
{
onFinished
(
child
)
;
}
else
{
child
.
sendManifest
(
{
kind
:
"
runToPoint
"
endpoint
}
(
)
=
>
onFinished
(
child
)
)
;
}
return
child
;
}
let
gMaxRunningLeafChildren
=
4
;
let
gNumRunningLeafChildren
=
0
;
const
gChildWaiters
=
[
[
]
[
]
[
]
]
;
async
function
ensureLeafChild
(
endpoint
priority
=
Priority
.
HIGH
)
{
if
(
gNumRunningLeafChildren
<
gMaxRunningLeafChildren
)
{
gNumRunningLeafChildren
+
+
;
}
else
{
await
new
Promise
(
resolve
=
>
gChildWaiters
[
priority
]
.
push
(
resolve
)
)
;
}
return
new
Promise
(
resolve
=
>
{
newLeafChild
(
endpoint
child
=
>
resolve
(
child
)
)
;
}
)
;
}
function
stopRunningLeafChild
(
)
{
gNumRunningLeafChildren
-
-
;
if
(
gNumRunningLeafChildren
<
gMaxRunningLeafChildren
)
{
for
(
const
waiters
of
gChildWaiters
)
{
if
(
waiters
.
length
)
{
const
resolve
=
waiters
.
shift
(
)
;
gNumRunningLeafChildren
+
+
;
resolve
(
)
;
}
}
}
}
function
terminateRunningLeafChild
(
child
)
{
stopRunningLeafChild
(
)
;
dumpv
(
Terminate
{
child
.
id
}
)
;
child
.
terminate
(
)
;
}
let
gNextRootId
=
1
;
function
spawnTrunkChild
(
)
{
if
(
!
RecordReplayControl
.
canRewind
(
)
)
{
return
;
}
const
id
=
gNextRootId
+
+
;
RecordReplayControl
.
spawnReplayingChild
(
id
)
;
gRootChild
=
new
ChildProcess
(
id
0
false
RecordReplayControl
.
recordingLength
(
)
)
;
gTrunkChild
=
forkChild
(
gRootChild
checkpointExecutionPoint
(
FirstCheckpointId
)
)
;
assert
(
gLastSavedCheckpoint
=
=
InvalidCheckpointId
)
;
}
async
function
forkBranchChild
(
lastSavedCheckpoint
nextSavedCheckpoint
)
{
if
(
!
RecordReplayControl
.
canRewind
(
)
)
{
return
;
}
gTrunkChild
.
updateRecording
(
RecordReplayControl
.
recordingLength
(
)
)
;
const
point
=
checkpointExecutionPoint
(
lastSavedCheckpoint
)
;
const
child
=
forkChild
(
gTrunkChild
point
)
;
dumpv
(
AddBranchChild
Checkpoint
{
lastSavedCheckpoint
}
Child
{
child
.
id
}
)
;
gBranchChildren
.
push
(
{
child
point
}
)
;
const
endpoint
=
checkpointExecutionPoint
(
nextSavedCheckpoint
)
;
await
gTrunkChild
.
sendManifest
(
{
kind
:
"
runToPoint
"
endpoint
flushExternalCalls
:
true
}
)
;
updateStatus
(
)
;
}
function
respawnCrashedChild
(
child
)
{
const
{
startPoint
recordingLength
manifests
processedManifests
}
=
child
;
let
entry
;
for
(
let
i
=
gBranchChildren
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
branch
=
gBranchChildren
[
i
]
;
if
(
!
pointPrecedes
(
child
.
startPoint
branch
.
point
)
&
&
!
branch
.
child
.
terminated
)
{
entry
=
branch
;
break
;
}
}
if
(
!
entry
)
{
entry
=
{
child
:
gRootChild
point
:
checkpointExecutionPoint
(
FirstCheckpointId
)
}
;
}
const
newChild
=
forkChild
(
entry
.
child
entry
.
point
)
;
dumpv
(
Transplanting
Child
:
{
child
.
id
}
from
{
newChild
.
id
}
)
;
child
.
transplantFrom
(
newChild
)
;
if
(
recordingLength
>
child
.
recordingLength
)
{
child
.
updateRecording
(
recordingLength
)
;
}
if
(
!
pointEquals
(
startPoint
child
.
startPoint
)
)
{
assert
(
pointPrecedes
(
child
.
startPoint
startPoint
)
)
;
child
.
sendManifest
(
{
kind
:
"
runToPoint
"
endpoint
:
startPoint
}
)
;
}
for
(
const
manifest
of
processedManifests
)
{
if
(
manifest
.
kind
!
=
"
primordial
"
&
&
manifest
.
kind
!
=
"
fork
"
)
{
child
.
sendManifest
(
manifest
)
;
}
}
for
(
const
{
manifest
onFinished
}
of
manifests
)
{
if
(
manifest
.
kind
!
=
"
primordial
"
&
&
(
manifest
.
kind
!
=
"
fork
"
|
|
manifest
!
=
manifests
[
0
]
.
manifest
)
)
{
child
.
sendManifest
(
manifest
onFinished
)
;
}
}
}
function
Initialize
(
recordingChildId
)
{
try
{
if
(
recordingChildId
!
=
undefined
)
{
assert
(
recordingChildId
=
=
0
)
;
gMainChild
=
new
ChildProcess
(
recordingChildId
0
true
)
;
}
else
{
const
id
=
gNextRootId
+
+
;
RecordReplayControl
.
spawnReplayingChild
(
id
)
;
gMainChild
=
new
ChildProcess
(
id
0
false
RecordReplayControl
.
recordingLength
)
;
}
gActiveChild
=
gMainChild
;
return
gControl
;
}
catch
(
e
)
{
dump
(
ERROR
:
Initialize
threw
exception
:
{
e
}
\
n
)
;
}
}
function
PromiseMap
(
)
{
this
.
map
=
new
Map
(
)
;
}
PromiseMap
.
prototype
=
{
get
(
key
)
{
let
promise
=
this
.
map
.
get
(
key
)
;
if
(
promise
)
{
return
{
promise
}
;
}
let
resolve
;
promise
=
new
Promise
(
r
=
>
{
resolve
=
r
;
}
)
;
this
.
map
.
set
(
key
promise
)
;
return
{
promise
resolve
}
;
}
set
(
key
value
)
{
this
.
map
.
set
(
key
value
)
;
}
}
;
let
gActiveChild
=
null
;
const
gCheckpoints
=
[
null
]
;
function
CheckpointInfo
(
)
{
this
.
duration
=
0
;
this
.
point
=
null
;
this
.
saved
=
false
;
this
.
debuggerStatements
=
[
]
;
this
.
events
=
[
]
;
}
function
getCheckpointInfo
(
id
)
{
while
(
id
>
=
gCheckpoints
.
length
)
{
gCheckpoints
.
push
(
new
CheckpointInfo
(
)
)
;
}
return
gCheckpoints
[
id
]
;
}
function
checkpointRangeDuration
(
start
end
)
{
let
time
=
0
;
for
(
let
i
=
start
;
i
<
end
;
i
+
+
)
{
time
+
=
gCheckpoints
[
i
]
.
duration
;
}
return
time
;
}
function
timeSinceCheckpoint
(
id
)
{
return
checkpointRangeDuration
(
id
gCheckpoints
.
length
)
;
}
const
FlushMs
=
0
.
5
*
1000
;
let
gLastSavedCheckpoint
=
InvalidCheckpointId
;
const
gSavedCheckpointWaiters
=
[
]
;
function
addSavedCheckpoint
(
checkpoint
)
{
assert
(
checkpoint
>
=
gLastSavedCheckpoint
)
;
if
(
checkpoint
=
=
gLastSavedCheckpoint
)
{
return
;
}
if
(
gLastSavedCheckpoint
!
=
InvalidCheckpointId
)
{
forkBranchChild
(
gLastSavedCheckpoint
checkpoint
)
;
}
getCheckpointInfo
(
checkpoint
)
.
saved
=
true
;
gLastSavedCheckpoint
=
checkpoint
;
gSavedCheckpointWaiters
.
forEach
(
resolve
=
>
resolve
(
)
)
;
gSavedCheckpointWaiters
.
length
=
0
;
}
function
waitForSavedCheckpoint
(
)
{
return
new
Promise
(
resolve
=
>
gSavedCheckpointWaiters
.
push
(
resolve
)
)
;
}
function
addCheckpoint
(
checkpoint
duration
)
{
assert
(
!
getCheckpointInfo
(
checkpoint
)
.
duration
)
;
getCheckpointInfo
(
checkpoint
)
.
duration
=
duration
;
}
function
nextSavedCheckpoint
(
checkpoint
)
{
assert
(
checkpoint
=
=
InvalidCheckpointId
|
|
gCheckpoints
[
checkpoint
]
.
saved
)
;
while
(
+
+
checkpoint
<
gCheckpoints
.
length
)
{
if
(
gCheckpoints
[
checkpoint
]
.
saved
)
{
return
checkpoint
;
}
}
return
undefined
;
}
function
forSavedCheckpointsInRange
(
start
end
callback
)
{
if
(
start
=
=
FirstCheckpointId
&
&
!
gCheckpoints
[
start
]
.
saved
)
{
return
;
}
assert
(
gCheckpoints
[
start
]
.
saved
)
;
for
(
let
checkpoint
=
start
;
checkpoint
<
end
;
checkpoint
=
nextSavedCheckpoint
(
checkpoint
)
)
{
callback
(
checkpoint
)
;
}
}
function
forAllSavedCheckpoints
(
callback
)
{
forSavedCheckpointsInRange
(
FirstCheckpointId
gLastSavedCheckpoint
callback
)
;
}
function
getSavedCheckpoint
(
checkpoint
)
{
while
(
!
gCheckpoints
[
checkpoint
]
.
saved
)
{
checkpoint
-
-
;
}
return
checkpoint
;
}
function
checkpointExecutionPoint
(
checkpoint
)
{
return
gCheckpoints
[
checkpoint
]
.
point
;
}
const
gBreakpoints
=
[
]
;
const
gSavedCheckpointChildren
=
new
PromiseMap
(
)
;
const
gScannedSavedCheckpoints
=
new
Set
(
)
;
async
function
scanRecording
(
checkpoint
)
{
assert
(
gCheckpoints
[
checkpoint
]
.
saved
)
;
if
(
checkpoint
=
=
gLastSavedCheckpoint
)
{
await
waitForSavedCheckpoint
(
)
;
}
const
{
promise
resolve
}
=
gSavedCheckpointChildren
.
get
(
checkpoint
)
;
if
(
!
resolve
)
{
return
promise
;
}
const
endpoint
=
checkpointExecutionPoint
(
nextSavedCheckpoint
(
checkpoint
)
)
;
const
child
=
await
ensureLeafChild
(
checkpointExecutionPoint
(
checkpoint
)
)
;
await
child
.
sendManifest
(
{
kind
:
"
scanRecording
"
endpoint
}
)
;
stopRunningLeafChild
(
)
;
gScannedSavedCheckpoints
.
add
(
checkpoint
)
;
updateStatus
(
)
;
resolve
(
child
)
;
return
child
;
}
function
unscannedRegions
(
)
{
const
result
=
[
]
;
const
traversedCheckpoint
=
gTrunkChild
&
&
gTrunkChild
.
lastPausePoint
?
gTrunkChild
.
lastPausePoint
.
checkpoint
:
FirstCheckpointId
;
function
addRegion
(
startCheckpoint
endCheckpoint
)
{
const
start
=
checkpointExecutionPoint
(
startCheckpoint
)
.
progress
;
const
end
=
checkpointExecutionPoint
(
endCheckpoint
)
.
progress
;
const
traversed
=
endCheckpoint
<
=
traversedCheckpoint
;
if
(
result
.
length
&
&
result
[
result
.
length
-
1
]
.
end
=
=
start
&
&
result
[
result
.
length
-
1
]
.
traversed
=
=
traversed
)
{
result
[
result
.
length
-
1
]
.
end
=
end
;
}
else
{
result
.
push
(
{
start
end
traversed
}
)
;
}
}
forAllSavedCheckpoints
(
checkpoint
=
>
{
if
(
!
gScannedSavedCheckpoints
.
has
(
checkpoint
)
)
{
addRegion
(
checkpoint
nextSavedCheckpoint
(
checkpoint
)
)
;
}
}
)
;
const
lastFlush
=
gLastSavedCheckpoint
|
|
FirstCheckpointId
;
if
(
lastFlush
!
=
gRecordingEndpoint
)
{
addRegion
(
lastFlush
gMainChild
.
lastPausePoint
.
checkpoint
)
;
}
return
result
;
}
const
gHitSearches
=
new
PromiseMap
(
)
;
function
canFindHits
(
position
)
{
return
position
.
kind
=
=
"
Break
"
|
|
position
.
kind
=
=
"
OnStep
"
;
}
async
function
findHits
(
checkpoint
position
)
{
assert
(
canFindHits
(
position
)
)
;
assert
(
gCheckpoints
[
checkpoint
]
.
saved
)
;
const
key
=
{
checkpoint
}
:
{
positionToString
(
position
)
}
;
const
{
promise
resolve
}
=
gHitSearches
.
get
(
key
)
;
if
(
!
resolve
)
{
return
promise
;
}
const
endpoint
=
nextSavedCheckpoint
(
checkpoint
)
;
const
child
=
await
scanRecording
(
checkpoint
)
;
const
hits
=
await
child
.
sendManifest
(
{
kind
:
"
findHits
"
position
startpoint
:
checkpoint
endpoint
}
)
;
resolve
(
hits
)
;
return
hits
;
}
async
function
findBreakpointHits
(
checkpoint
position
)
{
if
(
position
.
kind
=
=
"
Break
"
)
{
findHits
(
checkpoint
position
)
;
}
}
const
gFrameSteps
=
new
PromiseMap
(
)
;
const
gParentFrames
=
new
PromiseMap
(
)
;
async
function
findFrameSteps
(
point
)
{
if
(
!
point
.
position
)
{
return
null
;
}
assert
(
point
.
position
.
kind
=
=
"
EnterFrame
"
|
|
point
.
position
.
kind
=
=
"
OnStep
"
|
|
point
.
position
.
kind
=
=
"
OnPop
"
)
;
const
{
promise
resolve
}
=
gFrameSteps
.
get
(
pointToString
(
point
)
)
;
if
(
!
resolve
)
{
return
promise
;
}
const
info
=
gControl
.
sendRequestMainChild
(
{
type
:
"
frameStepsInfo
"
script
:
point
.
position
.
script
}
)
;
const
checkpoint
=
getSavedCheckpoint
(
point
.
checkpoint
)
;
const
child
=
await
scanRecording
(
checkpoint
)
;
const
steps
=
await
child
.
sendManifest
(
{
kind
:
"
findFrameSteps
"
targetPoint
:
point
.
.
.
info
}
)
;
for
(
const
p
of
steps
)
{
if
(
p
.
position
.
frameIndex
=
=
point
.
position
.
frameIndex
)
{
gFrameSteps
.
set
(
pointToString
(
p
)
steps
)
;
}
else
{
assert
(
p
.
position
.
kind
=
=
"
EnterFrame
"
)
;
gParentFrames
.
set
(
pointToString
(
p
)
steps
[
0
]
)
;
}
}
resolve
(
steps
)
;
return
steps
;
}
async
function
findParentFrameEntryPoint
(
point
)
{
assert
(
point
.
position
.
kind
=
=
"
EnterFrame
"
)
;
assert
(
point
.
position
.
frameIndex
>
0
)
;
const
{
promise
resolve
}
=
gParentFrames
.
get
(
pointToString
(
point
)
)
;
if
(
!
resolve
)
{
return
promise
;
}
const
checkpoint
=
getSavedCheckpoint
(
point
.
checkpoint
)
;
const
child
=
await
scanRecording
(
checkpoint
)
;
const
{
parentPoint
}
=
await
child
.
sendManifest
(
{
kind
:
"
findParentFrameEntryPoint
"
point
}
)
;
resolve
(
parentPoint
)
;
return
parentPoint
;
}
const
gPauseData
=
new
Map
(
)
;
const
gQueuedPauseData
=
new
Set
(
)
;
const
gCachedPoints
=
new
Map
(
)
;
async
function
queuePauseData
(
{
point
trackCached
}
)
{
if
(
gQueuedPauseData
.
has
(
pointToString
(
point
)
)
)
{
return
;
}
gQueuedPauseData
.
add
(
pointToString
(
point
)
)
;
await
waitForFlushed
(
point
.
checkpoint
)
;
const
child
=
await
ensureLeafChild
(
point
Priority
.
LOW
)
;
const
data
=
await
child
.
sendManifest
(
{
kind
:
"
getPauseData
"
}
)
;
addPauseData
(
point
data
trackCached
)
;
terminateRunningLeafChild
(
child
)
;
}
function
addPauseData
(
point
data
trackCached
)
{
if
(
data
.
paintData
)
{
data
.
paintData
=
RecordReplayControl
.
atomize
(
data
.
paintData
)
;
}
gPauseData
.
set
(
pointToString
(
point
)
data
)
;
if
(
trackCached
)
{
gCachedPoints
.
set
(
pointToString
(
point
)
point
)
;
updateStatus
(
)
;
}
}
function
maybeGetPauseData
(
point
)
{
return
gPauseData
.
get
(
pointToString
(
point
)
)
;
}
function
cachedPoints
(
)
{
return
[
.
.
.
gCachedPoints
.
values
(
)
]
.
map
(
point
=
>
point
.
progress
)
;
}
const
PauseModes
=
{
RUNNING
:
"
RUNNING
"
PAUSED
:
"
PAUSED
"
RESUMING_BACKWARD
:
"
RESUMING_BACKWARD
"
RESUMING_FORWARD
:
"
RESUMING_FORWARD
"
}
;
let
gPauseMode
=
PauseModes
.
RUNNING
;
let
gPausePoint
=
null
;
const
gDebuggerRequests
=
[
]
;
function
addDebuggerRequest
(
request
)
{
gDebuggerRequests
.
push
(
{
request
stack
:
Error
(
)
.
stack
}
)
;
}
function
setPauseState
(
mode
point
child
)
{
assert
(
mode
)
;
const
idString
=
child
?
{
child
.
id
}
:
"
"
;
dumpv
(
SetPauseState
{
mode
}
{
JSON
.
stringify
(
point
)
}
{
idString
}
)
;
if
(
gActiveChild
&
&
gActiveChild
!
=
gMainChild
&
&
gActiveChild
!
=
child
)
{
terminateRunningLeafChild
(
gActiveChild
)
;
}
gPauseMode
=
mode
;
gPausePoint
=
point
;
gActiveChild
=
child
;
if
(
mode
=
=
PauseModes
.
PAUSED
)
{
simulateNearbyNavigation
(
)
;
}
}
function
setReplayingPauseTarget
(
point
)
{
assert
(
!
gDebuggerRequests
.
length
)
;
const
child
=
newLeafChild
(
point
)
;
setPauseState
(
PauseModes
.
PAUSED
point
child
)
;
updateStatus
(
)
;
gDebugger
.
_onPause
(
)
;
findFrameSteps
(
point
)
;
}
function
bringNewReplayingChildToPausePoint
(
)
{
const
child
=
newLeafChild
(
gPausePoint
)
;
setPauseState
(
PauseModes
.
PAUSED
gPausePoint
child
)
;
child
.
sendManifest
(
{
kind
:
"
batchDebuggerRequest
"
requests
:
gDebuggerRequests
.
map
(
r
=
>
r
.
request
)
}
)
;
}
async
function
resumeTarget
(
point
forward
breakpoints
)
{
let
startCheckpoint
=
point
.
checkpoint
;
if
(
!
forward
&
&
!
point
.
position
)
{
startCheckpoint
-
-
;
if
(
startCheckpoint
=
=
InvalidCheckpointId
)
{
return
null
;
}
}
startCheckpoint
=
getSavedCheckpoint
(
startCheckpoint
)
;
let
checkpoint
=
startCheckpoint
;
for
(
;
;
forward
?
checkpoint
+
+
:
checkpoint
-
-
)
{
if
(
[
InvalidCheckpointId
gLastSavedCheckpoint
]
.
includes
(
checkpoint
)
)
{
return
null
;
}
if
(
!
gCheckpoints
[
checkpoint
]
.
saved
)
{
continue
;
}
const
hits
=
[
]
;
for
(
const
bp
of
breakpoints
)
{
if
(
canFindHits
(
bp
)
)
{
const
bphits
=
await
findHits
(
checkpoint
bp
)
;
hits
.
push
(
.
.
.
bphits
)
;
}
}
if
(
checkpoint
=
=
startCheckpoint
&
&
gBreakpoints
.
some
(
bp
=
>
bp
.
kind
=
=
"
EnterFrame
"
|
|
bp
.
kind
=
=
"
OnPop
"
)
)
{
const
steps
=
await
findFrameSteps
(
point
)
;
hits
.
push
(
.
.
.
steps
.
filter
(
p
=
>
{
return
breakpoints
.
some
(
bp
=
>
positionSubsumes
(
bp
p
.
position
)
)
;
}
)
)
;
}
hits
.
push
(
.
.
.
getCheckpointInfo
(
checkpoint
)
.
debuggerStatements
)
;
const
hit
=
findClosestPoint
(
hits
gPausePoint
!
forward
false
)
;
if
(
hit
)
{
return
hit
;
}
}
}
async
function
finishResume
(
)
{
assert
(
gPauseMode
=
=
PauseModes
.
RESUMING_FORWARD
|
|
gPauseMode
=
=
PauseModes
.
RESUMING_BACKWARD
)
;
const
forward
=
gPauseMode
=
=
PauseModes
.
RESUMING_FORWARD
;
const
point
=
await
resumeTarget
(
gPausePoint
forward
gBreakpoints
)
;
if
(
point
)
{
setReplayingPauseTarget
(
point
)
;
}
else
if
(
forward
)
{
assert
(
forward
)
;
RecordReplayControl
.
restoreMainGraphics
(
)
;
setPauseState
(
PauseModes
.
RUNNING
gMainChild
.
pausePoint
(
)
gMainChild
)
;
updateStatus
(
)
;
maybeResumeRecording
(
)
;
}
else
{
assert
(
!
forward
)
;
setReplayingPauseTarget
(
checkpointExecutionPoint
(
FirstCheckpointId
)
)
;
}
}
function
resume
(
forward
)
{
gDebuggerRequests
.
length
=
0
;
if
(
gActiveChild
.
recording
)
{
if
(
forward
)
{
maybeResumeRecording
(
)
;
return
;
}
ensureFlushed
(
)
;
}
if
(
gPausePoint
.
checkpoint
=
=
FirstCheckpointId
&
&
!
gPausePoint
.
position
&
&
!
forward
)
{
gDebugger
.
_hitRecordingBoundary
(
)
;
return
;
}
setPauseState
(
forward
?
PauseModes
.
RESUMING_FORWARD
:
PauseModes
.
RESUMING_BACKWARD
gPausePoint
null
)
;
finishResume
(
)
;
}
function
timeWarp
(
point
)
{
gDebuggerRequests
.
length
=
0
;
setReplayingPauseTarget
(
point
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
TimeWarpFinished
"
)
;
}
const
MaxCrashes
=
4
;
let
gNumCrashes
=
0
;
function
ChildCrashed
(
rootId
forkId
)
{
const
id
=
processId
(
rootId
forkId
)
;
dumpv
(
Child
Crashed
:
{
id
}
)
;
const
child
=
gChildren
.
get
(
id
)
;
if
(
!
child
)
{
return
;
}
if
(
child
.
recording
)
{
ThrowError
(
"
Child
is
recording
"
)
;
}
if
(
!
forkId
)
{
ThrowError
(
"
Child
is
replaying
root
"
)
;
}
if
(
child
.
paused
)
{
ThrowError
(
"
Child
is
paused
"
)
;
}
if
(
+
+
gNumCrashes
>
MaxCrashes
)
{
ThrowError
(
"
Too
many
crashes
"
)
;
}
child
.
terminate
(
)
;
const
{
manifest
}
=
child
.
manifests
[
0
]
;
if
(
manifest
.
kind
=
=
"
fork
"
)
{
ChildCrashed
(
rootId
manifest
.
id
)
;
}
respawnCrashedChild
(
child
)
;
}
async
function
simulateBreakpointNavigation
(
point
forward
count
)
{
if
(
!
count
)
{
return
;
}
const
breakpoints
=
gBreakpoints
.
filter
(
bp
=
>
bp
.
kind
=
=
"
Break
"
)
;
const
next
=
await
resumeTarget
(
point
forward
breakpoints
)
;
if
(
next
)
{
queuePauseData
(
{
point
:
next
}
)
;
simulateBreakpointNavigation
(
next
forward
count
-
1
)
;
}
}
async
function
findFrameEntryPoint
(
point
)
{
assert
(
point
.
position
.
kind
=
=
"
EnterFrame
"
)
;
const
steps
=
await
findFrameSteps
(
point
)
;
assert
(
pointEquals
(
steps
[
0
]
point
)
)
;
return
steps
[
1
]
;
}
async
function
simulateSteppingNavigation
(
point
count
frameCount
last
)
{
if
(
!
count
|
|
!
point
.
position
)
{
return
;
}
const
{
script
}
=
point
.
position
;
const
dbgScript
=
gDebugger
.
_getScript
(
script
)
;
const
steps
=
await
findFrameSteps
(
point
)
;
const
pointIndex
=
steps
.
findIndex
(
p
=
>
pointEquals
(
p
point
)
)
;
if
(
last
!
=
"
reverseStepOver
"
)
{
for
(
let
i
=
pointIndex
+
1
;
i
<
steps
.
length
;
i
+
+
)
{
const
p
=
steps
[
i
]
;
if
(
isStepOverTarget
(
p
)
)
{
queuePauseData
(
{
point
:
p
snapshot
:
steps
[
0
]
}
)
;
simulateSteppingNavigation
(
p
count
-
1
frameCount
"
stepOver
"
)
;
break
;
}
}
}
if
(
last
!
=
"
stepOver
"
)
{
for
(
let
i
=
pointIndex
-
1
;
i
>
=
1
;
i
-
-
)
{
const
p
=
steps
[
i
]
;
if
(
isStepOverTarget
(
p
)
)
{
queuePauseData
(
{
point
:
p
snapshot
:
steps
[
0
]
}
)
;
simulateSteppingNavigation
(
p
count
-
1
frameCount
"
reverseStepOver
"
)
;
break
;
}
}
}
if
(
frameCount
)
{
for
(
let
i
=
pointIndex
+
1
;
i
<
steps
.
length
;
i
+
+
)
{
const
p
=
steps
[
i
]
;
if
(
isStepOverTarget
(
p
)
)
{
break
;
}
if
(
p
.
position
.
script
!
=
script
)
{
queuePauseData
(
{
point
:
p
snapshot
:
steps
[
0
]
}
)
;
const
np
=
await
findFrameEntryPoint
(
p
)
;
queuePauseData
(
{
point
:
np
snapshot
:
steps
[
0
]
}
)
;
if
(
canFindHits
(
np
.
position
)
)
{
findHits
(
getSavedCheckpoint
(
point
.
checkpoint
)
np
.
position
)
;
}
simulateSteppingNavigation
(
np
count
-
1
frameCount
-
1
"
stepIn
"
)
;
break
;
}
}
}
if
(
frameCount
&
&
last
!
=
"
stepOver
"
&
&
last
!
=
"
reverseStepOver
"
&
&
point
.
position
.
frameIndex
)
{
queuePauseData
(
{
point
:
steps
[
steps
.
length
-
1
]
snapshot
:
steps
[
0
]
}
)
;
const
parentEntryPoint
=
await
findParentFrameEntryPoint
(
steps
[
0
]
)
;
const
parentSteps
=
await
findFrameSteps
(
parentEntryPoint
)
;
for
(
let
i
=
0
;
i
<
parentSteps
.
length
;
i
+
+
)
{
const
p
=
parentSteps
[
i
]
;
if
(
pointPrecedes
(
point
p
)
)
{
queuePauseData
(
{
point
:
p
snapshot
:
parentSteps
[
0
]
}
)
;
if
(
canFindHits
(
p
.
position
)
)
{
findHits
(
getSavedCheckpoint
(
point
.
checkpoint
)
p
.
position
)
;
}
simulateSteppingNavigation
(
p
count
-
1
frameCount
-
1
"
stepOut
"
)
;
break
;
}
}
}
function
isStepOverTarget
(
p
)
{
const
{
kind
offset
}
=
p
.
position
;
return
(
kind
=
=
"
OnPop
"
|
|
(
kind
=
=
"
OnStep
"
&
&
dbgScript
.
getOffsetMetadata
(
offset
)
.
isStepStart
)
)
;
}
}
function
simulateNearbyNavigation
(
)
{
const
numBreakpointHits
=
2
;
const
numSteps
=
4
;
const
numChangeFrames
=
2
;
simulateBreakpointNavigation
(
gPausePoint
true
numBreakpointHits
)
;
simulateBreakpointNavigation
(
gPausePoint
false
numBreakpointHits
)
;
simulateSteppingNavigation
(
gPausePoint
numSteps
numChangeFrames
)
;
}
const
gLogpoints
=
[
]
;
async
function
evaluateLogpoint
(
{
point
text
condition
callback
snapshot
fast
}
)
{
assert
(
point
)
;
const
child
=
await
ensureLeafChild
(
point
Priority
.
MEDIUM
)
;
const
{
result
resultData
}
=
await
child
.
sendManifest
(
{
kind
:
"
hitLogpoint
"
text
condition
fast
}
)
;
terminateRunningLeafChild
(
child
)
;
if
(
result
)
{
callback
(
point
result
resultData
)
;
}
}
async
function
findLogpointHits
(
checkpoint
{
position
text
condition
messageCallback
validCallback
}
)
{
if
(
!
validCallback
(
)
)
{
return
;
}
const
hits
=
await
findHits
(
checkpoint
position
)
;
hits
.
sort
(
(
a
b
)
=
>
pointPrecedes
(
b
a
)
)
;
if
(
!
condition
)
{
for
(
const
point
of
hits
)
{
messageCallback
(
point
[
"
Loading
.
.
.
"
]
)
;
}
}
for
(
const
point
of
hits
)
{
const
fast
=
getPreference
(
"
fastLogpoints
"
)
;
const
snapshot
=
!
fast
&
&
checkpointExecutionPoint
(
point
.
checkpoint
)
;
await
evaluateLogpoint
(
{
point
text
condition
callback
:
messageCallback
snapshot
fast
}
)
;
if
(
!
validCallback
(
)
)
{
return
;
}
}
for
(
const
point
of
hits
)
{
await
queuePauseData
(
{
point
trackCached
:
true
}
)
;
if
(
!
validCallback
(
)
)
{
return
;
}
}
}
const
gLoggedEvents
=
[
]
;
const
gEventFrameEntryPoints
=
new
PromiseMap
(
)
;
async
function
findEventFrameEntry
(
checkpoint
progress
)
{
const
{
promise
resolve
}
=
gEventFrameEntryPoints
.
get
(
progress
)
;
if
(
!
resolve
)
{
return
promise
;
}
const
savedCheckpoint
=
getSavedCheckpoint
(
checkpoint
)
;
const
child
=
await
scanRecording
(
savedCheckpoint
)
;
const
{
rv
}
=
await
child
.
sendManifest
(
{
kind
:
"
findEventFrameEntry
"
checkpoint
progress
}
)
;
const
point
=
await
findFrameEntryPoint
(
rv
)
;
resolve
(
point
)
;
return
point
;
}
async
function
findEventLogpointHits
(
checkpoint
event
callback
)
{
for
(
const
info
of
getCheckpointInfo
(
checkpoint
)
.
events
)
{
if
(
info
.
event
=
=
event
)
{
const
point
=
await
findEventFrameEntry
(
info
.
checkpoint
info
.
progress
)
;
if
(
point
)
{
callback
(
point
[
"
Loading
.
.
.
"
]
)
;
evaluateLogpoint
(
{
point
text
:
"
arguments
[
0
]
"
callback
}
)
;
queuePauseData
(
{
point
trackCached
:
true
}
)
;
}
}
}
}
function
setActiveEventBreakpoints
(
events
callback
)
{
dumpv
(
SetActiveEventBreakpoints
{
JSON
.
stringify
(
events
)
}
)
;
for
(
const
event
of
events
)
{
if
(
gLoggedEvents
.
some
(
info
=
>
info
.
event
=
=
event
)
)
{
continue
;
}
gLoggedEvents
.
push
(
{
event
callback
}
)
;
forAllSavedCheckpoints
(
checkpoint
=
>
findEventLogpointHits
(
checkpoint
event
callback
)
)
;
}
}
function
handleResumeManifestResponse
(
{
point
duration
consoleMessages
scripts
debuggerStatements
events
}
)
{
if
(
!
point
.
position
)
{
addCheckpoint
(
point
.
checkpoint
-
1
duration
)
;
getCheckpointInfo
(
point
.
checkpoint
)
.
point
=
point
;
}
if
(
gDebugger
)
{
consoleMessages
.
forEach
(
msg
=
>
{
gDebugger
.
_newConsoleMessage
(
msg
)
;
}
)
;
}
if
(
gDebugger
)
{
scripts
.
forEach
(
script
=
>
gDebugger
.
_onNewScript
(
script
)
)
;
}
consoleMessages
.
forEach
(
msg
=
>
{
if
(
msg
.
executionPoint
)
{
queuePauseData
(
{
point
:
msg
.
executionPoint
trackCached
:
true
}
)
;
}
}
)
;
const
savedCheckpoint
=
getSavedCheckpoint
(
point
.
position
?
point
.
checkpoint
:
point
.
checkpoint
-
1
)
;
for
(
const
point
of
debuggerStatements
)
{
getCheckpointInfo
(
savedCheckpoint
)
.
debuggerStatements
.
push
(
point
)
;
}
for
(
const
event
of
events
)
{
getCheckpointInfo
(
savedCheckpoint
)
.
events
.
push
(
event
)
;
}
if
(
RecordReplayControl
.
inRepaintStressMode
(
)
)
{
queuePauseData
(
{
point
}
)
;
}
}
function
maybeResumeRecording
(
)
{
if
(
gActiveChild
!
=
gMainChild
)
{
return
;
}
if
(
!
gLastSavedCheckpoint
|
|
timeSinceCheckpoint
(
gLastSavedCheckpoint
)
>
=
FlushMs
)
{
ensureFlushed
(
)
;
}
const
checkpoint
=
gMainChild
.
pausePoint
(
)
.
checkpoint
;
if
(
!
gMainChild
.
recording
&
&
checkpoint
=
=
gRecordingEndpoint
)
{
ensureFlushed
(
)
;
Services
.
cpmm
.
sendAsyncMessage
(
"
HitRecordingEndpoint
"
)
;
if
(
gDebugger
)
{
gDebugger
.
_hitRecordingBoundary
(
)
;
}
return
;
}
gMainChild
.
sendManifest
(
{
kind
:
"
resume
"
breakpoints
:
gBreakpoints
pauseOnDebuggerStatement
:
!
!
gDebugger
}
response
=
>
{
handleResumeManifestResponse
(
response
)
;
gPausePoint
=
gMainChild
.
pausePoint
(
)
;
if
(
gDebugger
)
{
updateStatus
(
)
;
gDebugger
.
_onPause
(
)
;
}
else
{
Services
.
tm
.
dispatchToMainThread
(
maybeResumeRecording
)
;
}
}
)
;
}
const
gFlushWaiters
=
[
]
;
function
waitForFlushed
(
checkpoint
)
{
if
(
checkpoint
<
gLastSavedCheckpoint
)
{
return
undefined
;
}
return
new
Promise
(
resolve
=
>
{
gFlushWaiters
.
push
(
resolve
)
;
}
)
;
}
let
gLastFlushTime
=
Date
.
now
(
)
;
function
ensureFlushed
(
)
{
gMainChild
.
waitUntilPaused
(
true
)
;
gLastFlushTime
=
Date
.
now
(
)
;
if
(
gLastSavedCheckpoint
=
=
gMainChild
.
pauseCheckpoint
(
)
)
{
return
;
}
if
(
gMainChild
.
recording
)
{
gMainChild
.
sendManifest
(
{
kind
:
"
flushRecording
"
}
)
;
gMainChild
.
waitUntilPaused
(
)
;
}
if
(
!
gTrunkChild
)
{
spawnTrunkChild
(
)
;
}
const
oldSavedCheckpoint
=
gLastSavedCheckpoint
|
|
FirstCheckpointId
;
addSavedCheckpoint
(
gMainChild
.
pauseCheckpoint
(
)
)
;
forSavedCheckpointsInRange
(
oldSavedCheckpoint
gLastSavedCheckpoint
checkpoint
=
>
{
scanRecording
(
checkpoint
)
;
gBreakpoints
.
forEach
(
position
=
>
findBreakpointHits
(
checkpoint
position
)
)
;
gLogpoints
.
forEach
(
logpoint
=
>
findLogpointHits
(
checkpoint
logpoint
)
)
;
for
(
const
{
event
callback
}
of
gLoggedEvents
)
{
findEventLogpointHits
(
checkpoint
event
callback
)
;
}
}
)
;
for
(
const
waiter
of
gFlushWaiters
)
{
waiter
(
)
;
}
gFlushWaiters
.
length
=
0
;
}
const
CheckFlushMs
=
1000
;
setInterval
(
(
)
=
>
{
const
elapsed
=
Date
.
now
(
)
-
gLastFlushTime
;
if
(
elapsed
>
CheckFlushMs
&
&
gMainChild
.
lastPausePoint
&
&
gMainChild
.
lastPausePoint
.
checkpoint
!
=
gLastSavedCheckpoint
)
{
ensureFlushed
(
)
;
}
for
(
const
child
of
gUnpausedChildren
)
{
if
(
!
child
.
recording
)
{
child
.
maybePing
(
)
;
}
}
}
1000
)
;
function
BeforeSaveRecording
(
)
{
if
(
gActiveChild
=
=
gMainChild
)
{
ensureFlushed
(
)
;
}
}
function
AfterSaveRecording
(
)
{
Services
.
cpmm
.
sendAsyncMessage
(
"
SaveRecordingFinished
"
)
;
}
let
gRecordingEndpoint
;
async
function
setMainChild
(
)
{
assert
(
!
gMainChild
.
recording
)
;
const
{
endpoint
}
=
await
gMainChild
.
sendManifest
(
{
kind
:
"
setMainChild
"
}
)
;
gRecordingEndpoint
=
endpoint
;
Services
.
tm
.
dispatchToMainThread
(
maybeResumeRecording
)
;
}
const
gControl
=
{
pausePoint
(
)
{
if
(
gActiveChild
&
&
gActiveChild
=
=
gMainChild
)
{
return
gActiveChild
.
paused
?
gActiveChild
.
pausePoint
(
)
:
null
;
}
if
(
gPauseMode
=
=
PauseModes
.
PAUSED
)
{
return
gPausePoint
;
}
return
null
;
}
lastPausePoint
(
)
{
return
gPausePoint
;
}
findFrameSteps
(
point
)
{
return
findFrameSteps
(
point
)
;
}
async
findAncestorFrameEntryPoint
(
point
index
)
{
const
steps
=
await
findFrameSteps
(
point
)
;
point
=
steps
[
0
]
;
while
(
index
-
-
)
{
point
=
await
findParentFrameEntryPoint
(
point
)
;
}
return
point
;
}
waitUntilPaused
(
)
{
assert
(
gActiveChild
)
;
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
}
}
addBreakpoint
(
position
)
{
dumpv
(
AddBreakpoint
{
JSON
.
stringify
(
position
)
}
)
;
gBreakpoints
.
push
(
position
)
;
if
(
canFindHits
(
position
)
)
{
forAllSavedCheckpoints
(
checkpoint
=
>
findBreakpointHits
(
checkpoint
position
)
)
;
}
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
}
simulateNearbyNavigation
(
)
;
}
clearBreakpoints
(
)
{
dumpv
(
ClearBreakpoints
)
;
gBreakpoints
.
length
=
0
;
if
(
gActiveChild
=
=
gMainChild
)
{
gActiveChild
.
waitUntilPaused
(
true
)
;
}
}
recordingEndpoint
(
)
{
return
gMainChild
.
lastPausePoint
;
}
maybeSwitchToReplayingChild
(
)
{
assert
(
gControl
.
pausePoint
(
)
)
;
if
(
gActiveChild
=
=
gMainChild
&
&
RecordReplayControl
.
canRewind
(
)
)
{
const
point
=
gActiveChild
.
pausePoint
(
)
;
if
(
point
.
position
)
{
gMainChild
.
sendManifest
(
{
kind
:
"
resume
"
breakpoints
:
[
]
pauseOnDebuggerStatement
:
false
}
handleResumeManifestResponse
)
;
gMainChild
.
waitUntilPaused
(
true
)
;
}
ensureFlushed
(
)
;
bringNewReplayingChildToPausePoint
(
)
;
}
}
sendRequest
(
request
)
{
let
data
;
gActiveChild
.
sendManifest
(
{
kind
:
"
debuggerRequest
"
request
}
finishData
=
>
{
data
=
finishData
;
}
)
;
while
(
!
data
)
{
gActiveChild
.
waitUntilPaused
(
)
;
}
if
(
data
.
unhandledDivergence
)
{
bringNewReplayingChildToPausePoint
(
)
;
}
else
{
addDebuggerRequest
(
request
)
;
}
return
data
.
response
;
}
sendRequestMainChild
(
request
)
{
gMainChild
.
waitUntilPaused
(
true
)
;
let
data
;
gMainChild
.
sendManifest
(
{
kind
:
"
debuggerRequest
"
request
}
finishData
=
>
{
data
=
finishData
;
}
)
;
gMainChild
.
waitUntilPaused
(
)
;
assert
(
!
data
.
divergedFromRecording
)
;
return
data
.
response
;
}
resume
timeWarp
addLogpoint
(
logpoint
)
{
gLogpoints
.
push
(
logpoint
)
;
forAllSavedCheckpoints
(
checkpoint
=
>
findLogpointHits
(
checkpoint
logpoint
)
)
;
}
setActiveEventBreakpoints
debuggerRequests
(
)
{
return
gDebuggerRequests
;
}
getPauseDataAndRepaint
(
)
{
if
(
!
gDebuggerRequests
.
length
)
{
const
data
=
maybeGetPauseData
(
gPausePoint
)
;
if
(
data
)
{
gActiveChild
.
sendManifest
(
{
kind
:
"
debuggerRequest
"
request
:
{
type
:
"
pauseData
"
}
}
)
;
addDebuggerRequest
(
{
type
:
"
pauseData
"
}
)
;
RecordReplayControl
.
hadRepaint
(
data
.
paintData
)
;
return
data
;
}
}
gControl
.
maybeSwitchToReplayingChild
(
)
;
const
data
=
gControl
.
sendRequest
(
{
type
:
"
pauseData
"
}
)
;
if
(
!
data
)
{
RecordReplayControl
.
clearGraphics
(
)
;
}
else
{
addPauseData
(
gPausePoint
data
true
)
;
RecordReplayControl
.
hadRepaint
(
data
.
paintData
)
;
}
return
data
;
}
paint
(
point
)
{
const
data
=
maybeGetPauseData
(
point
)
;
if
(
data
)
{
RecordReplayControl
.
hadRepaint
(
data
.
paintData
)
;
}
}
isPausedAtDebuggerStatement
(
)
{
const
point
=
gControl
.
pausePoint
(
)
;
if
(
point
)
{
const
checkpoint
=
getSavedCheckpoint
(
point
.
checkpoint
)
;
const
{
debuggerStatements
}
=
getCheckpointInfo
(
checkpoint
)
;
return
pointArrayIncludes
(
debuggerStatements
point
)
;
}
return
false
;
}
}
;
function
updateStatus
(
)
{
if
(
gDebugger
&
&
gDebugger
.
replayingOnStatusUpdate
)
{
gDebugger
.
replayingOnStatusUpdate
(
{
recording
:
gActiveChild
&
&
gActiveChild
.
recording
executionPoint
:
gPausePoint
cachedPoints
:
cachedPoints
(
)
unscannedRegions
:
unscannedRegions
(
)
}
)
;
}
}
function
getPreference
(
name
)
{
return
Services
.
prefs
.
getBoolPref
(
devtools
.
recordreplay
.
{
name
}
)
;
}
const
loggingFullEnabled
=
getPreference
(
"
loggingFull
"
)
;
const
loggingEnabled
=
loggingFullEnabled
|
|
getPreference
(
"
logging
"
)
;
function
ConnectDebugger
(
dbg
)
{
gDebugger
=
dbg
;
dbg
.
_control
=
gControl
;
}
const
startTime
=
Date
.
now
(
)
;
function
currentTime
(
)
{
return
(
(
(
Date
.
now
(
)
-
startTime
)
/
10
)
|
0
)
/
100
;
}
function
dumpv
(
str
)
{
if
(
loggingEnabled
)
{
dump
(
[
ReplayControl
{
currentTime
(
)
}
]
{
str
}
\
n
)
;
}
}
function
assert
(
v
)
{
if
(
!
v
)
{
ThrowError
(
"
Assertion
Failed
!
"
)
;
}
}
function
ThrowError
(
msg
)
{
const
error
=
new
Error
(
msg
)
;
dump
(
ReplayControl
Server
Error
:
{
msg
}
Stack
:
{
error
.
stack
}
\
n
)
;
throw
error
;
}
function
stringify
(
object
)
{
const
str
=
JSON
.
stringify
(
object
)
;
if
(
str
&
&
str
.
length
>
=
4096
&
&
!
loggingFullEnabled
)
{
return
{
str
.
substr
(
0
4096
)
}
TRIMMED
{
str
.
length
}
;
}
return
str
;
}
var
EXPORTED_SYMBOLS
=
[
"
Initialize
"
"
ConnectDebugger
"
"
ManifestFinished
"
"
BeforeSaveRecording
"
"
AfterSaveRecording
"
"
ChildCrashed
"
"
PingResponse
"
]
;
