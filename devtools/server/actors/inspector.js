"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
LayoutActor
}
=
require
(
"
devtools
/
server
/
actors
/
layout
"
)
;
const
{
LongStringActor
}
=
require
(
"
devtools
/
server
/
actors
/
string
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
events
=
require
(
"
sdk
/
event
/
core
"
)
;
const
{
WalkerSearch
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
walker
-
search
"
)
;
const
{
PageStyleActor
getFontPreviewData
}
=
require
(
"
devtools
/
server
/
actors
/
styles
"
)
;
const
{
HighlighterActor
CustomHighlighterActor
isTypeRegistered
HighlighterEnvironment
}
=
require
(
"
devtools
/
server
/
actors
/
highlighters
"
)
;
const
{
EyeDropper
}
=
require
(
"
devtools
/
server
/
actors
/
highlighters
/
eye
-
dropper
"
)
;
const
{
isAnonymous
isNativeAnonymous
isXBLAnonymous
isShadowAnonymous
getFrameElement
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
{
getLayoutChangesObserver
releaseLayoutChangesObserver
}
=
require
(
"
devtools
/
server
/
actors
/
reflow
"
)
;
const
nodeFilterConstants
=
require
(
"
devtools
/
shared
/
dom
-
node
-
filter
-
constants
"
)
;
const
{
EventParsers
}
=
require
(
"
devtools
/
server
/
event
-
parsers
"
)
;
const
{
nodeSpec
nodeListSpec
walkerSpec
inspectorSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
inspector
"
)
;
const
FONT_FAMILY_PREVIEW_TEXT
=
"
The
quick
brown
fox
jumps
over
the
lazy
dog
"
;
const
FONT_FAMILY_PREVIEW_TEXT_SIZE
=
20
;
const
PSEUDO_CLASSES
=
[
"
:
hover
"
"
:
active
"
"
:
focus
"
]
;
const
HIDDEN_CLASS
=
"
__fx
-
devtools
-
hide
-
shortcut__
"
;
const
SVG_NS
=
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
IMAGE_FETCHING_TIMEOUT
=
500
;
const
PSEUDO_SELECTORS
=
[
[
"
:
active
"
1
]
[
"
:
hover
"
1
]
[
"
:
focus
"
1
]
[
"
:
visited
"
0
]
[
"
:
link
"
0
]
[
"
:
first
-
letter
"
0
]
[
"
:
first
-
child
"
2
]
[
"
:
before
"
2
]
[
"
:
after
"
2
]
[
"
:
lang
(
"
0
]
[
"
:
not
(
"
3
]
[
"
:
first
-
of
-
type
"
0
]
[
"
:
last
-
of
-
type
"
0
]
[
"
:
only
-
of
-
type
"
0
]
[
"
:
only
-
child
"
2
]
[
"
:
nth
-
child
(
"
3
]
[
"
:
nth
-
last
-
child
(
"
0
]
[
"
:
nth
-
of
-
type
(
"
0
]
[
"
:
nth
-
last
-
of
-
type
(
"
0
]
[
"
:
last
-
child
"
2
]
[
"
:
root
"
0
]
[
"
:
empty
"
0
]
[
"
:
target
"
0
]
[
"
:
enabled
"
0
]
[
"
:
disabled
"
0
]
[
"
:
checked
"
1
]
[
"
:
:
selection
"
0
]
]
;
var
HELPER_SHEET
=
.
__fx
-
devtools
-
hide
-
shortcut__
{
visibility
:
hidden
!
important
;
}
:
-
moz
-
devtools
-
highlighted
{
outline
:
2px
dashed
#
F06
!
important
;
outline
-
offset
:
-
2px
!
important
;
}
;
const
flags
=
require
(
"
devtools
/
shared
/
flags
"
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsUtils
"
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
AsyncUtils
"
"
devtools
/
shared
/
async
-
utils
"
)
;
loader
.
lazyGetter
(
this
"
DOMParser
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
xmlextras
/
domparser
;
1
"
]
.
createInstance
(
Ci
.
nsIDOMParser
)
;
}
)
;
loader
.
lazyGetter
(
this
"
eventListenerService
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
eventlistenerservice
;
1
"
]
.
getService
(
Ci
.
nsIEventListenerService
)
;
}
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
findCssSelector
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
exports
.
DEFAULT_VALUE_SUMMARY_LENGTH
=
50
;
var
gValueSummaryLength
=
exports
.
DEFAULT_VALUE_SUMMARY_LENGTH
;
exports
.
getValueSummaryLength
=
function
(
)
{
return
gValueSummaryLength
;
}
;
exports
.
setValueSummaryLength
=
function
(
val
)
{
gValueSummaryLength
=
val
;
}
;
const
getNodeDisplayName
=
function
(
rawNode
)
{
if
(
rawNode
.
nodeName
&
&
!
rawNode
.
localName
)
{
return
rawNode
.
nodeName
;
}
return
(
rawNode
.
prefix
?
rawNode
.
prefix
+
"
:
"
:
"
"
)
+
rawNode
.
localName
;
}
;
exports
.
getNodeDisplayName
=
getNodeDisplayName
;
var
NodeActor
=
exports
.
NodeActor
=
protocol
.
ActorClassWithSpec
(
nodeSpec
{
initialize
(
walker
node
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
walker
=
walker
;
this
.
rawNode
=
node
;
this
.
_eventParsers
=
new
EventParsers
(
)
.
parsers
;
this
.
wasDisplayed
=
this
.
isDisplayed
;
}
toString
(
)
{
return
"
[
NodeActor
"
+
this
.
actorID
+
"
for
"
+
this
.
rawNode
.
toString
(
)
+
"
]
"
;
}
get
conn
(
)
{
return
this
.
walker
.
conn
;
}
isDocumentElement
(
)
{
return
this
.
rawNode
.
ownerDocument
&
&
this
.
rawNode
.
ownerDocument
.
documentElement
=
=
=
this
.
rawNode
;
}
destroy
(
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
if
(
this
.
mutationObserver
)
{
if
(
!
Cu
.
isDeadWrapper
(
this
.
mutationObserver
)
)
{
this
.
mutationObserver
.
disconnect
(
)
;
}
this
.
mutationObserver
=
null
;
}
this
.
rawNode
=
null
;
this
.
walker
=
null
;
}
form
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
let
parentNode
=
this
.
walker
.
parentNode
(
this
)
;
let
inlineTextChild
=
this
.
walker
.
inlineTextChild
(
this
)
;
let
form
=
{
actor
:
this
.
actorID
baseURI
:
this
.
rawNode
.
baseURI
parent
:
parentNode
?
parentNode
.
actorID
:
undefined
nodeType
:
this
.
rawNode
.
nodeType
namespaceURI
:
this
.
rawNode
.
namespaceURI
nodeName
:
this
.
rawNode
.
nodeName
nodeValue
:
this
.
rawNode
.
nodeValue
displayName
:
getNodeDisplayName
(
this
.
rawNode
)
numChildren
:
this
.
numChildren
inlineTextChild
:
inlineTextChild
?
inlineTextChild
.
form
(
)
:
undefined
name
:
this
.
rawNode
.
name
publicId
:
this
.
rawNode
.
publicId
systemId
:
this
.
rawNode
.
systemId
attrs
:
this
.
writeAttrs
(
)
isBeforePseudoElement
:
this
.
isBeforePseudoElement
isAfterPseudoElement
:
this
.
isAfterPseudoElement
isAnonymous
:
isAnonymous
(
this
.
rawNode
)
isNativeAnonymous
:
isNativeAnonymous
(
this
.
rawNode
)
isXBLAnonymous
:
isXBLAnonymous
(
this
.
rawNode
)
isShadowAnonymous
:
isShadowAnonymous
(
this
.
rawNode
)
pseudoClassLocks
:
this
.
writePseudoClassLocks
(
)
isDisplayed
:
this
.
isDisplayed
isInHTMLDocument
:
this
.
rawNode
.
ownerDocument
&
&
this
.
rawNode
.
ownerDocument
.
contentType
=
=
=
"
text
/
html
"
hasEventListeners
:
this
.
_hasEventListeners
}
;
if
(
this
.
isDocumentElement
(
)
)
{
form
.
isDocumentElement
=
true
;
}
form
.
setFormProperty
=
(
name
value
)
=
>
{
if
(
!
form
.
props
)
{
form
.
props
=
{
}
;
}
form
.
props
[
name
]
=
value
;
}
;
events
.
emit
(
NodeActor
"
form
"
{
target
:
this
data
:
form
}
)
;
return
form
;
}
watchDocument
(
callback
)
{
let
node
=
this
.
rawNode
;
let
observer
=
new
node
.
defaultView
.
MutationObserver
(
callback
)
;
observer
.
mergeAttributeRecords
=
true
;
observer
.
observe
(
node
{
nativeAnonymousChildList
:
true
attributes
:
true
characterData
:
true
characterDataOldValue
:
true
childList
:
true
subtree
:
true
}
)
;
this
.
mutationObserver
=
observer
;
}
get
isBeforePseudoElement
(
)
{
return
this
.
rawNode
.
nodeName
=
=
=
"
_moz_generated_content_before
"
;
}
get
isAfterPseudoElement
(
)
{
return
this
.
rawNode
.
nodeName
=
=
=
"
_moz_generated_content_after
"
;
}
get
numChildren
(
)
{
if
(
this
.
isBeforePseudoElement
|
|
this
.
isAfterPseudoElement
)
{
return
0
;
}
let
rawNode
=
this
.
rawNode
;
let
numChildren
=
rawNode
.
childNodes
.
length
;
let
hasAnonChildren
=
rawNode
.
nodeType
=
=
=
Ci
.
nsIDOMNode
.
ELEMENT_NODE
&
&
rawNode
.
ownerDocument
.
getAnonymousNodes
(
rawNode
)
;
let
hasContentDocument
=
rawNode
.
contentDocument
;
let
hasSVGDocument
=
rawNode
.
getSVGDocument
&
&
rawNode
.
getSVGDocument
(
)
;
if
(
numChildren
=
=
=
0
&
&
(
hasContentDocument
|
|
hasSVGDocument
)
)
{
numChildren
=
1
;
}
if
(
numChildren
=
=
=
0
|
|
hasAnonChildren
)
{
numChildren
=
this
.
walker
.
children
(
this
)
.
nodes
.
length
;
}
return
numChildren
;
}
get
computedStyle
(
)
{
return
CssLogic
.
getComputedStyle
(
this
.
rawNode
)
;
}
get
isDisplayed
(
)
{
if
(
isNodeDead
(
this
)
|
|
this
.
rawNode
.
nodeType
!
=
=
Ci
.
nsIDOMNode
.
ELEMENT_NODE
|
|
this
.
isAfterPseudoElement
|
|
this
.
isBeforePseudoElement
)
{
return
true
;
}
let
style
=
this
.
computedStyle
;
if
(
!
style
)
{
return
true
;
}
return
style
.
display
!
=
=
"
none
"
;
}
get
_hasEventListeners
(
)
{
let
parsers
=
this
.
_eventParsers
;
for
(
let
[
{
hasListeners
}
]
of
parsers
)
{
try
{
if
(
hasListeners
&
&
hasListeners
(
this
.
rawNode
)
)
{
return
true
;
}
}
catch
(
e
)
{
}
}
return
false
;
}
writeAttrs
(
)
{
if
(
!
this
.
rawNode
.
attributes
)
{
return
undefined
;
}
return
[
.
.
.
this
.
rawNode
.
attributes
]
.
map
(
attr
=
>
{
return
{
namespace
:
attr
.
namespace
name
:
attr
.
name
value
:
attr
.
value
}
;
}
)
;
}
writePseudoClassLocks
(
)
{
if
(
this
.
rawNode
.
nodeType
!
=
=
Ci
.
nsIDOMNode
.
ELEMENT_NODE
)
{
return
undefined
;
}
let
ret
=
undefined
;
for
(
let
pseudo
of
PSEUDO_CLASSES
)
{
if
(
DOMUtils
.
hasPseudoClassLock
(
this
.
rawNode
pseudo
)
)
{
ret
=
ret
|
|
[
]
;
ret
.
push
(
pseudo
)
;
}
}
return
ret
;
}
getEventListeners
(
node
)
{
let
parsers
=
this
.
_eventParsers
;
let
dbg
=
this
.
parent
(
)
.
tabActor
.
makeDebugger
(
)
;
let
listenerArray
=
[
]
;
for
(
let
[
{
getListeners
normalizeListener
}
]
of
parsers
)
{
try
{
let
listeners
=
getListeners
(
node
)
;
if
(
!
listeners
)
{
continue
;
}
for
(
let
listener
of
listeners
)
{
if
(
normalizeListener
)
{
listener
.
normalizeListener
=
normalizeListener
;
}
this
.
processHandlerForEvent
(
node
listenerArray
dbg
listener
)
;
}
}
catch
(
e
)
{
}
}
listenerArray
.
sort
(
(
a
b
)
=
>
{
return
a
.
type
.
localeCompare
(
b
.
type
)
;
}
)
;
return
listenerArray
;
}
processHandlerForEvent
(
node
listenerArray
dbg
listener
)
{
let
{
handler
}
=
listener
;
let
global
=
Cu
.
getGlobalForObject
(
handler
)
;
let
globalDO
=
dbg
.
addDebuggee
(
global
)
;
let
listenerDO
=
globalDO
.
makeDebuggeeValue
(
handler
)
;
let
{
normalizeListener
}
=
listener
;
if
(
normalizeListener
)
{
listenerDO
=
normalizeListener
(
listenerDO
listener
)
;
}
let
{
capturing
}
=
listener
;
let
dom0
=
false
;
let
functionSource
=
handler
.
toString
(
)
;
let
hide
=
listener
.
hide
|
|
{
}
;
let
line
=
0
;
let
native
=
false
;
let
override
=
listener
.
override
|
|
{
}
;
let
tags
=
listener
.
tags
|
|
"
"
;
let
type
=
listener
.
type
|
|
"
"
;
let
url
=
"
"
;
if
(
listenerDO
.
class
=
=
=
"
Object
"
|
|
listenerDO
.
class
=
=
=
"
XULElement
"
)
{
let
desc
;
while
(
!
desc
&
&
listenerDO
)
{
desc
=
listenerDO
.
getOwnPropertyDescriptor
(
"
handleEvent
"
)
;
listenerDO
=
listenerDO
.
proto
;
}
if
(
desc
&
&
desc
.
value
)
{
listenerDO
=
desc
.
value
;
}
}
if
(
listenerDO
.
isBoundFunction
)
{
listenerDO
=
listenerDO
.
boundTargetFunction
;
}
let
{
isArrowFunction
name
script
parameterNames
}
=
listenerDO
;
if
(
script
)
{
let
scriptSource
=
script
.
source
.
text
;
if
(
script
.
source
.
element
)
{
dom0
=
script
.
source
.
element
.
class
!
=
=
"
HTMLScriptElement
"
;
}
else
{
dom0
=
false
;
}
line
=
script
.
startLine
;
url
=
script
.
url
;
if
(
functionSource
=
=
=
"
[
object
Object
]
"
|
|
functionSource
=
=
=
"
[
object
XULElement
]
"
|
|
functionSource
.
includes
(
"
[
native
code
]
"
)
)
{
functionSource
=
scriptSource
.
substr
(
script
.
sourceStart
script
.
sourceLength
)
;
if
(
!
isArrowFunction
)
{
functionSource
=
"
function
"
+
functionSource
;
}
}
}
else
{
native
=
true
;
}
if
(
parameterNames
&
&
parameterNames
.
length
>
0
)
{
let
prefix
=
"
function
"
+
name
+
"
(
)
"
;
let
paramString
=
parameterNames
.
join
(
"
"
)
;
if
(
functionSource
.
startsWith
(
prefix
)
)
{
functionSource
=
functionSource
.
substr
(
prefix
.
length
)
;
functionSource
=
function
{
name
}
(
{
paramString
}
)
{
functionSource
}
;
}
}
let
origin
;
if
(
native
)
{
origin
=
"
[
native
code
]
"
;
}
else
{
origin
=
url
+
(
(
dom0
|
|
line
=
=
=
0
)
?
"
"
:
"
:
"
+
line
)
;
}
let
eventObj
=
{
type
:
override
.
type
|
|
type
handler
:
override
.
handler
|
|
functionSource
.
trim
(
)
origin
:
override
.
origin
|
|
origin
tags
:
override
.
tags
|
|
tags
DOM0
:
typeof
override
.
dom0
!
=
=
"
undefined
"
?
override
.
dom0
:
dom0
capturing
:
typeof
override
.
capturing
!
=
=
"
undefined
"
?
override
.
capturing
:
capturing
hide
:
typeof
override
.
hide
!
=
=
"
undefined
"
?
override
.
hide
:
hide
native
}
;
if
(
native
|
|
dom0
)
{
eventObj
.
hide
.
debugger
=
true
;
}
listenerArray
.
push
(
eventObj
)
;
dbg
.
removeDebuggee
(
globalDO
)
;
}
getNodeValue
(
)
{
return
new
LongStringActor
(
this
.
conn
this
.
rawNode
.
nodeValue
|
|
"
"
)
;
}
setNodeValue
(
value
)
{
this
.
rawNode
.
nodeValue
=
value
;
}
getUniqueSelector
(
)
{
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
)
{
return
"
"
;
}
return
findCssSelector
(
this
.
rawNode
)
;
}
scrollIntoView
(
)
{
this
.
rawNode
.
scrollIntoView
(
true
)
;
}
getImageData
(
maxDim
)
{
return
imageToImageData
(
this
.
rawNode
maxDim
)
.
then
(
imageData
=
>
{
return
{
data
:
LongStringActor
(
this
.
conn
imageData
.
data
)
size
:
imageData
.
size
}
;
}
)
;
}
getEventListenerInfo
(
)
{
let
node
=
this
.
rawNode
;
if
(
this
.
rawNode
.
nodeName
.
toLowerCase
(
)
=
=
=
"
html
"
)
{
let
winListeners
=
this
.
getEventListeners
(
node
.
ownerGlobal
)
|
|
[
]
;
let
docElementListeners
=
this
.
getEventListeners
(
node
)
|
|
[
]
;
let
docListeners
=
this
.
getEventListeners
(
node
.
parentNode
)
|
|
[
]
;
return
[
.
.
.
winListeners
.
.
.
docElementListeners
.
.
.
docListeners
]
;
}
return
this
.
getEventListeners
(
node
)
;
}
modifyAttributes
(
modifications
)
{
let
rawNode
=
this
.
rawNode
;
for
(
let
change
of
modifications
)
{
if
(
change
.
newValue
=
=
null
)
{
if
(
change
.
attributeNamespace
)
{
rawNode
.
removeAttributeNS
(
change
.
attributeNamespace
change
.
attributeName
)
;
}
else
{
rawNode
.
removeAttribute
(
change
.
attributeName
)
;
}
}
else
if
(
change
.
attributeNamespace
)
{
rawNode
.
setAttributeNS
(
change
.
attributeNamespace
change
.
attributeName
change
.
newValue
)
;
}
else
{
rawNode
.
setAttribute
(
change
.
attributeName
change
.
newValue
)
;
}
}
}
getFontFamilyDataURL
(
font
fillStyle
=
"
black
"
)
{
let
doc
=
this
.
rawNode
.
ownerDocument
;
let
options
=
{
previewText
:
FONT_FAMILY_PREVIEW_TEXT
previewFontSize
:
FONT_FAMILY_PREVIEW_TEXT_SIZE
fillStyle
}
;
let
{
dataURL
size
}
=
getFontPreviewData
(
font
doc
options
)
;
return
{
data
:
LongStringActor
(
this
.
conn
dataURL
)
size
}
;
}
}
)
;
var
NodeListActor
=
exports
.
NodeListActor
=
protocol
.
ActorClassWithSpec
(
nodeListSpec
{
typeName
:
"
domnodelist
"
initialize
(
walker
nodeList
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
)
;
this
.
walker
=
walker
;
this
.
nodeList
=
nodeList
|
|
[
]
;
}
destroy
(
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
}
get
conn
(
)
{
return
this
.
walker
.
conn
;
}
marshallPool
(
)
{
return
this
.
walker
;
}
form
(
)
{
return
{
actor
:
this
.
actorID
length
:
this
.
nodeList
?
this
.
nodeList
.
length
:
0
}
;
}
item
(
index
)
{
return
this
.
walker
.
attachElement
(
this
.
nodeList
[
index
]
)
;
}
items
(
start
=
0
end
=
this
.
nodeList
.
length
)
{
let
items
=
Array
.
prototype
.
slice
.
call
(
this
.
nodeList
start
end
)
.
map
(
item
=
>
this
.
walker
.
_ref
(
item
)
)
;
return
this
.
walker
.
attachElements
(
items
)
;
}
release
(
)
{
}
}
)
;
var
WalkerActor
=
protocol
.
ActorClassWithSpec
(
walkerSpec
{
initialize
(
conn
tabActor
options
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
tabActor
=
tabActor
;
this
.
rootWin
=
tabActor
.
window
;
this
.
rootDoc
=
this
.
rootWin
.
document
;
this
.
_refMap
=
new
Map
(
)
;
this
.
_pendingMutations
=
[
]
;
this
.
_activePseudoClassLocks
=
new
Set
(
)
;
this
.
showAllAnonymousContent
=
options
.
showAllAnonymousContent
;
this
.
walkerSearch
=
new
WalkerSearch
(
this
)
;
this
.
_orphaned
=
new
Set
(
)
;
this
.
_retainedOrphans
=
new
Set
(
)
;
this
.
onMutations
=
this
.
onMutations
.
bind
(
this
)
;
this
.
onFrameLoad
=
this
.
onFrameLoad
.
bind
(
this
)
;
this
.
onFrameUnload
=
this
.
onFrameUnload
.
bind
(
this
)
;
events
.
on
(
tabActor
"
will
-
navigate
"
this
.
onFrameUnload
)
;
events
.
on
(
tabActor
"
window
-
ready
"
this
.
onFrameLoad
)
;
this
.
rootNode
=
this
.
document
(
)
;
this
.
layoutChangeObserver
=
getLayoutChangesObserver
(
this
.
tabActor
)
;
this
.
_onReflows
=
this
.
_onReflows
.
bind
(
this
)
;
this
.
layoutChangeObserver
.
on
(
"
reflows
"
this
.
_onReflows
)
;
this
.
_onResize
=
this
.
_onResize
.
bind
(
this
)
;
this
.
layoutChangeObserver
.
on
(
"
resize
"
this
.
_onResize
)
;
this
.
_onEventListenerChange
=
this
.
_onEventListenerChange
.
bind
(
this
)
;
eventListenerService
.
addListenerChangeListener
(
this
.
_onEventListenerChange
)
;
}
_onEventListenerChange
(
changesEnum
)
{
let
changes
=
changesEnum
.
enumerate
(
)
;
while
(
changes
.
hasMoreElements
(
)
)
{
let
current
=
changes
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIEventListenerChange
)
;
let
target
=
current
.
target
;
if
(
this
.
_refMap
.
has
(
target
)
)
{
let
actor
=
this
.
getNode
(
target
)
;
let
mutation
=
{
type
:
"
events
"
target
:
actor
.
actorID
hasEventListeners
:
actor
.
_hasEventListeners
}
;
this
.
queueMutation
(
mutation
)
;
}
}
}
form
(
)
{
return
{
actor
:
this
.
actorID
root
:
this
.
rootNode
.
form
(
)
traits
:
{
autoReleased
:
true
multiFrameQuerySelectorAll
:
true
textSearch
:
true
}
}
;
}
toString
(
)
{
return
"
[
WalkerActor
"
+
this
.
actorID
+
"
]
"
;
}
getDocumentWalker
(
node
whatToShow
)
{
let
nodeFilter
=
this
.
showAllAnonymousContent
?
allAnonymousContentTreeWalkerFilter
:
standardTreeWalkerFilter
;
return
new
DocumentWalker
(
node
this
.
rootWin
whatToShow
nodeFilter
)
;
}
destroy
(
)
{
if
(
this
.
_destroyed
)
{
return
;
}
this
.
_destroyed
=
true
;
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
try
{
this
.
clearPseudoClassLocks
(
)
;
this
.
_activePseudoClassLocks
=
null
;
this
.
_hoveredNode
=
null
;
this
.
rootWin
=
null
;
this
.
rootDoc
=
null
;
this
.
rootNode
=
null
;
this
.
layoutHelpers
=
null
;
this
.
_orphaned
=
null
;
this
.
_retainedOrphans
=
null
;
this
.
_refMap
=
null
;
events
.
off
(
this
.
tabActor
"
will
-
navigate
"
this
.
onFrameUnload
)
;
events
.
off
(
this
.
tabActor
"
window
-
ready
"
this
.
onFrameLoad
)
;
this
.
onFrameLoad
=
null
;
this
.
onFrameUnload
=
null
;
this
.
walkerSearch
.
destroy
(
)
;
this
.
layoutChangeObserver
.
off
(
"
reflows
"
this
.
_onReflows
)
;
this
.
layoutChangeObserver
.
off
(
"
resize
"
this
.
_onResize
)
;
this
.
layoutChangeObserver
=
null
;
releaseLayoutChangesObserver
(
this
.
tabActor
)
;
eventListenerService
.
removeListenerChangeListener
(
this
.
_onEventListenerChange
)
;
this
.
onMutations
=
null
;
this
.
layoutActor
=
null
;
this
.
tabActor
=
null
;
events
.
emit
(
this
"
destroyed
"
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
release
(
)
{
}
unmanage
(
actor
)
{
if
(
actor
instanceof
NodeActor
)
{
if
(
this
.
_activePseudoClassLocks
&
&
this
.
_activePseudoClassLocks
.
has
(
actor
)
)
{
this
.
clearPseudoClassLocks
(
actor
)
;
}
this
.
_refMap
.
delete
(
actor
.
rawNode
)
;
}
protocol
.
Actor
.
prototype
.
unmanage
.
call
(
this
actor
)
;
}
hasNode
(
rawNode
)
{
return
this
.
_refMap
.
has
(
rawNode
)
;
}
getNode
(
rawNode
)
{
return
this
.
_refMap
.
get
(
rawNode
)
;
}
_ref
(
node
)
{
let
actor
=
this
.
getNode
(
node
)
;
if
(
actor
)
{
return
actor
;
}
actor
=
new
NodeActor
(
this
node
)
;
this
.
manage
(
actor
)
;
this
.
_refMap
.
set
(
node
actor
)
;
if
(
node
.
nodeType
=
=
=
Ci
.
nsIDOMNode
.
DOCUMENT_NODE
)
{
actor
.
watchDocument
(
this
.
onMutations
)
;
}
return
actor
;
}
_onReflows
(
reflows
)
{
let
changes
=
[
]
;
for
(
let
[
node
actor
]
of
this
.
_refMap
)
{
if
(
Cu
.
isDeadWrapper
(
node
)
)
{
continue
;
}
let
isDisplayed
=
actor
.
isDisplayed
;
if
(
isDisplayed
!
=
=
actor
.
wasDisplayed
)
{
changes
.
push
(
actor
)
;
actor
.
wasDisplayed
=
isDisplayed
;
}
}
if
(
changes
.
length
)
{
events
.
emit
(
this
"
display
-
change
"
changes
)
;
}
}
_onResize
(
)
{
events
.
emit
(
this
"
resize
"
)
;
}
pick
(
)
{
}
cancelPick
(
)
{
}
highlight
(
node
)
{
}
attachElement
(
node
)
{
let
{
nodes
newParents
}
=
this
.
attachElements
(
[
node
]
)
;
return
{
node
:
nodes
[
0
]
newParents
}
;
}
attachElements
(
nodes
)
{
let
nodeActors
=
[
]
;
let
newParents
=
new
Set
(
)
;
for
(
let
node
of
nodes
)
{
if
(
!
(
node
instanceof
NodeActor
)
)
{
if
(
!
this
.
showAllAnonymousContent
&
&
isAnonymous
(
node
)
)
{
node
=
this
.
getDocumentWalker
(
node
)
.
currentNode
;
}
node
=
this
.
_ref
(
node
)
;
}
this
.
ensurePathToRoot
(
node
newParents
)
;
nodeActors
.
push
(
node
)
;
}
return
{
nodes
:
nodeActors
newParents
:
[
.
.
.
newParents
]
}
;
}
document
(
node
)
{
let
doc
=
isNodeDead
(
node
)
?
this
.
rootDoc
:
nodeDocument
(
node
.
rawNode
)
;
return
this
.
_ref
(
doc
)
;
}
documentElement
(
node
)
{
let
elt
=
isNodeDead
(
node
)
?
this
.
rootDoc
.
documentElement
:
nodeDocument
(
node
.
rawNode
)
.
documentElement
;
return
this
.
_ref
(
elt
)
;
}
parents
(
node
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
[
]
;
}
let
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
let
parents
=
[
]
;
let
cur
;
while
(
(
cur
=
walker
.
parentNode
(
)
)
)
{
if
(
options
.
sameDocument
&
&
nodeDocument
(
cur
)
!
=
nodeDocument
(
node
.
rawNode
)
)
{
break
;
}
if
(
options
.
sameTypeRootTreeItem
&
&
nodeDocshell
(
cur
)
.
sameTypeRootTreeItem
!
=
nodeDocshell
(
node
.
rawNode
)
.
sameTypeRootTreeItem
)
{
break
;
}
parents
.
push
(
this
.
_ref
(
cur
)
)
;
}
return
parents
;
}
parentNode
(
node
)
{
let
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
let
parent
=
walker
.
parentNode
(
)
;
if
(
parent
)
{
return
this
.
_ref
(
parent
)
;
}
return
null
;
}
inlineTextChild
(
node
)
{
if
(
node
.
isBeforePseudoElement
|
|
node
.
isAfterPseudoElement
|
|
node
.
rawNode
.
nodeType
!
=
Ci
.
nsIDOMNode
.
ELEMENT_NODE
|
|
node
.
rawNode
.
children
.
length
>
0
)
{
return
undefined
;
}
let
docWalker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
let
firstChild
=
docWalker
.
firstChild
(
)
;
if
(
!
firstChild
|
|
docWalker
.
nextSibling
(
)
|
|
firstChild
.
nodeType
!
=
=
Ci
.
nsIDOMNode
.
TEXT_NODE
|
|
firstChild
.
nodeValue
.
length
>
gValueSummaryLength
)
{
return
undefined
;
}
return
this
.
_ref
(
firstChild
)
;
}
retainNode
(
node
)
{
node
.
retained
=
true
;
}
unretainNode
(
node
)
{
node
.
retained
=
false
;
if
(
this
.
_retainedOrphans
.
has
(
node
)
)
{
this
.
_retainedOrphans
.
delete
(
node
)
;
this
.
releaseNode
(
node
)
;
}
}
releaseNode
(
node
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
if
(
node
.
retained
&
&
!
options
.
force
)
{
this
.
_retainedOrphans
.
add
(
node
)
;
return
;
}
if
(
node
.
retained
)
{
this
.
_retainedOrphans
.
delete
(
node
)
;
}
let
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
let
child
=
walker
.
firstChild
(
)
;
while
(
child
)
{
let
childActor
=
this
.
getNode
(
child
)
;
if
(
childActor
)
{
this
.
releaseNode
(
childActor
options
)
;
}
child
=
walker
.
nextSibling
(
)
;
}
node
.
destroy
(
)
;
}
ensurePathToRoot
(
node
newParents
=
new
Set
(
)
)
{
if
(
!
node
)
{
return
newParents
;
}
let
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
let
cur
;
while
(
(
cur
=
walker
.
parentNode
(
)
)
)
{
let
parent
=
this
.
getNode
(
cur
)
;
if
(
!
parent
)
{
newParents
.
add
(
this
.
_ref
(
cur
)
)
;
}
else
{
return
newParents
;
}
}
return
newParents
;
}
children
(
node
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
{
hasFirst
:
true
hasLast
:
true
nodes
:
[
]
}
;
}
if
(
options
.
center
&
&
options
.
start
)
{
throw
Error
(
"
Can
'
t
specify
both
'
center
'
and
'
start
'
options
.
"
)
;
}
let
maxNodes
=
options
.
maxNodes
|
|
-
1
;
if
(
maxNodes
=
=
-
1
)
{
maxNodes
=
Number
.
MAX_VALUE
;
}
let
getFilteredWalker
=
documentWalkerNode
=
>
{
return
this
.
getDocumentWalker
(
documentWalkerNode
options
.
whatToShow
)
;
}
;
let
rawNode
=
node
.
rawNode
;
let
firstChild
=
getFilteredWalker
(
rawNode
)
.
firstChild
(
)
;
let
lastChild
=
getFilteredWalker
(
rawNode
)
.
lastChild
(
)
;
if
(
!
firstChild
)
{
return
{
hasFirst
:
true
hasLast
:
true
nodes
:
[
]
}
;
}
let
start
;
if
(
options
.
center
)
{
start
=
options
.
center
.
rawNode
;
}
else
if
(
options
.
start
)
{
start
=
options
.
start
.
rawNode
;
}
else
{
start
=
firstChild
;
}
let
nodes
=
[
]
;
let
backwardWalker
=
getFilteredWalker
(
start
)
;
if
(
start
!
=
firstChild
&
&
options
.
center
)
{
backwardWalker
.
previousSibling
(
)
;
let
backwardCount
=
Math
.
floor
(
maxNodes
/
2
)
;
let
backwardNodes
=
this
.
_readBackward
(
backwardWalker
backwardCount
)
;
nodes
=
backwardNodes
;
}
let
forwardWalker
=
getFilteredWalker
(
start
)
;
let
forwardCount
=
maxNodes
-
nodes
.
length
;
nodes
=
nodes
.
concat
(
this
.
_readForward
(
forwardWalker
forwardCount
)
)
;
let
remaining
=
maxNodes
-
nodes
.
length
;
if
(
options
.
center
&
&
remaining
>
0
&
&
nodes
[
0
]
.
rawNode
!
=
firstChild
)
{
let
firstNodes
=
this
.
_readBackward
(
backwardWalker
remaining
)
;
nodes
=
firstNodes
.
concat
(
nodes
)
;
}
return
{
hasFirst
:
nodes
[
0
]
.
rawNode
=
=
firstChild
hasLast
:
nodes
[
nodes
.
length
-
1
]
.
rawNode
=
=
lastChild
nodes
}
;
}
siblings
(
node
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
{
hasFirst
:
true
hasLast
:
true
nodes
:
[
]
}
;
}
let
parentNode
=
this
.
getDocumentWalker
(
node
.
rawNode
options
.
whatToShow
)
.
parentNode
(
)
;
if
(
!
parentNode
)
{
return
{
hasFirst
:
true
hasLast
:
true
nodes
:
[
node
]
}
;
}
if
(
!
(
options
.
start
|
|
options
.
center
)
)
{
options
.
center
=
node
;
}
return
this
.
children
(
this
.
_ref
(
parentNode
)
options
)
;
}
nextSibling
(
node
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
let
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
options
.
whatToShow
)
;
let
sibling
=
walker
.
nextSibling
(
)
;
return
sibling
?
this
.
_ref
(
sibling
)
:
null
;
}
previousSibling
(
node
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
let
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
options
.
whatToShow
)
;
let
sibling
=
walker
.
previousSibling
(
)
;
return
sibling
?
this
.
_ref
(
sibling
)
:
null
;
}
_readForward
(
walker
count
)
{
let
ret
=
[
]
;
let
node
=
walker
.
currentNode
;
do
{
ret
.
push
(
this
.
_ref
(
node
)
)
;
node
=
walker
.
nextSibling
(
)
;
}
while
(
node
&
&
-
-
count
)
;
return
ret
;
}
_readBackward
(
walker
count
)
{
let
ret
=
[
]
;
let
node
=
walker
.
currentNode
;
do
{
ret
.
push
(
this
.
_ref
(
node
)
)
;
node
=
walker
.
previousSibling
(
)
;
}
while
(
node
&
&
-
-
count
)
;
ret
.
reverse
(
)
;
return
ret
;
}
querySelector
(
baseNode
selector
)
{
if
(
isNodeDead
(
baseNode
)
)
{
return
{
}
;
}
let
node
=
baseNode
.
rawNode
.
querySelector
(
selector
)
;
if
(
!
node
)
{
return
{
}
;
}
return
this
.
attachElement
(
node
)
;
}
querySelectorAll
(
baseNode
selector
)
{
let
nodeList
=
null
;
try
{
nodeList
=
baseNode
.
rawNode
.
querySelectorAll
(
selector
)
;
}
catch
(
e
)
{
}
return
new
NodeListActor
(
this
nodeList
)
;
}
_multiFrameQuerySelectorAll
(
selector
)
{
let
nodes
=
[
]
;
for
(
let
{
document
}
of
this
.
tabActor
.
windows
)
{
try
{
nodes
=
[
.
.
.
nodes
.
.
.
document
.
querySelectorAll
(
selector
)
]
;
}
catch
(
e
)
{
}
}
return
nodes
;
}
multiFrameQuerySelectorAll
(
selector
)
{
return
new
NodeListActor
(
this
this
.
_multiFrameQuerySelectorAll
(
selector
)
)
;
}
search
(
query
)
{
let
results
=
this
.
walkerSearch
.
search
(
query
)
;
let
nodeList
=
new
NodeListActor
(
this
results
.
map
(
r
=
>
r
.
node
)
)
;
return
{
list
:
nodeList
metadata
:
[
]
}
;
}
getSuggestionsForQuery
(
query
completing
selectorState
)
{
let
sugs
=
{
classes
:
new
Map
(
)
tags
:
new
Map
(
)
ids
:
new
Map
(
)
}
;
let
result
=
[
]
;
let
nodes
=
null
;
switch
(
selectorState
)
{
case
"
pseudo
"
:
result
=
PSEUDO_SELECTORS
.
filter
(
item
=
>
{
return
item
[
0
]
.
startsWith
(
"
:
"
+
completing
)
;
}
)
;
break
;
case
"
class
"
:
if
(
!
query
)
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
"
[
class
]
"
)
;
}
else
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
query
)
;
}
for
(
let
node
of
nodes
)
{
for
(
let
className
of
node
.
classList
)
{
sugs
.
classes
.
set
(
className
(
sugs
.
classes
.
get
(
className
)
|
0
)
+
1
)
;
}
}
sugs
.
classes
.
delete
(
"
"
)
;
sugs
.
classes
.
delete
(
HIDDEN_CLASS
)
;
for
(
let
[
className
count
]
of
sugs
.
classes
)
{
if
(
className
.
startsWith
(
completing
)
)
{
result
.
push
(
[
"
.
"
+
CSS
.
escape
(
className
)
count
selectorState
]
)
;
}
}
break
;
case
"
id
"
:
if
(
!
query
)
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
"
[
id
]
"
)
;
}
else
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
query
)
;
}
for
(
let
node
of
nodes
)
{
sugs
.
ids
.
set
(
node
.
id
(
sugs
.
ids
.
get
(
node
.
id
)
|
0
)
+
1
)
;
}
for
(
let
[
id
count
]
of
sugs
.
ids
)
{
if
(
id
.
startsWith
(
completing
)
&
&
id
!
=
=
"
"
)
{
result
.
push
(
[
"
#
"
+
CSS
.
escape
(
id
)
count
selectorState
]
)
;
}
}
break
;
case
"
tag
"
:
if
(
!
query
)
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
"
*
"
)
;
}
else
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
query
)
;
}
for
(
let
node
of
nodes
)
{
let
tag
=
node
.
localName
;
sugs
.
tags
.
set
(
tag
(
sugs
.
tags
.
get
(
tag
)
|
0
)
+
1
)
;
}
for
(
let
[
tag
count
]
of
sugs
.
tags
)
{
if
(
(
new
RegExp
(
"
^
"
+
completing
+
"
.
*
"
"
i
"
)
)
.
test
(
tag
)
)
{
result
.
push
(
[
tag
count
selectorState
]
)
;
}
}
if
(
!
query
)
{
result
=
[
.
.
.
result
.
.
.
this
.
getSuggestionsForQuery
(
null
completing
"
class
"
)
.
suggestions
.
.
.
this
.
getSuggestionsForQuery
(
null
completing
"
id
"
)
.
suggestions
]
;
}
break
;
case
"
null
"
:
nodes
=
this
.
_multiFrameQuerySelectorAll
(
query
)
;
for
(
let
node
of
nodes
)
{
sugs
.
ids
.
set
(
node
.
id
(
sugs
.
ids
.
get
(
node
.
id
)
|
0
)
+
1
)
;
let
tag
=
node
.
localName
;
sugs
.
tags
.
set
(
tag
(
sugs
.
tags
.
get
(
tag
)
|
0
)
+
1
)
;
for
(
let
className
of
node
.
classList
)
{
sugs
.
classes
.
set
(
className
(
sugs
.
classes
.
get
(
className
)
|
0
)
+
1
)
;
}
}
for
(
let
[
tag
count
]
of
sugs
.
tags
)
{
tag
&
&
result
.
push
(
[
tag
count
]
)
;
}
for
(
let
[
id
count
]
of
sugs
.
ids
)
{
id
&
&
result
.
push
(
[
"
#
"
+
id
count
]
)
;
}
sugs
.
classes
.
delete
(
"
"
)
;
sugs
.
classes
.
delete
(
HIDDEN_CLASS
)
;
for
(
let
[
className
count
]
of
sugs
.
classes
)
{
className
&
&
result
.
push
(
[
"
.
"
+
className
count
]
)
;
}
}
result
=
result
.
sort
(
(
a
b
)
=
>
{
let
sortA
=
(
10000
-
a
[
1
]
)
+
a
[
0
]
;
let
sortB
=
(
10000
-
b
[
1
]
)
+
b
[
0
]
;
let
firstA
=
a
[
0
]
.
substring
(
0
1
)
;
let
firstB
=
b
[
0
]
.
substring
(
0
1
)
;
if
(
firstA
=
=
=
"
#
"
)
{
sortA
=
"
2
"
+
sortA
;
}
else
if
(
firstA
=
=
=
"
.
"
)
{
sortA
=
"
1
"
+
sortA
;
}
else
{
sortA
=
"
0
"
+
sortA
;
}
if
(
firstB
=
=
=
"
#
"
)
{
sortB
=
"
2
"
+
sortB
;
}
else
if
(
firstB
=
=
=
"
.
"
)
{
sortB
=
"
1
"
+
sortB
;
}
else
{
sortB
=
"
0
"
+
sortB
;
}
return
sortA
.
localeCompare
(
sortB
)
;
}
)
;
result
.
slice
(
0
25
)
;
return
{
query
suggestions
:
result
}
;
}
addPseudoClassLock
(
node
pseudo
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
for
(
let
locked
of
this
.
_activePseudoClassLocks
)
{
if
(
DOMUtils
.
hasPseudoClassLock
(
locked
.
rawNode
pseudo
)
)
{
this
.
_removePseudoClassLock
(
locked
pseudo
)
;
}
}
this
.
_addPseudoClassLock
(
node
pseudo
)
;
if
(
!
options
.
parents
)
{
return
;
}
let
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
let
cur
;
while
(
(
cur
=
walker
.
parentNode
(
)
)
)
{
let
curNode
=
this
.
_ref
(
cur
)
;
this
.
_addPseudoClassLock
(
curNode
pseudo
)
;
}
}
_queuePseudoClassMutation
(
node
)
{
this
.
queueMutation
(
{
target
:
node
.
actorID
type
:
"
pseudoClassLock
"
pseudoClassLocks
:
node
.
writePseudoClassLocks
(
)
}
)
;
}
_addPseudoClassLock
(
node
pseudo
)
{
if
(
node
.
rawNode
.
nodeType
!
=
=
Ci
.
nsIDOMNode
.
ELEMENT_NODE
)
{
return
false
;
}
DOMUtils
.
addPseudoClassLock
(
node
.
rawNode
pseudo
)
;
this
.
_activePseudoClassLocks
.
add
(
node
)
;
this
.
_queuePseudoClassMutation
(
node
)
;
return
true
;
}
_installHelperSheet
(
node
)
{
if
(
!
this
.
installedHelpers
)
{
this
.
installedHelpers
=
new
WeakMap
(
)
;
}
let
win
=
node
.
rawNode
.
ownerDocument
.
defaultView
;
if
(
!
this
.
installedHelpers
.
has
(
win
)
)
{
let
{
Style
}
=
require
(
"
sdk
/
stylesheet
/
style
"
)
;
let
{
attach
}
=
require
(
"
sdk
/
content
/
mod
"
)
;
let
style
=
Style
(
{
source
:
HELPER_SHEET
type
:
"
agent
"
}
)
;
attach
(
style
win
)
;
this
.
installedHelpers
.
set
(
win
style
)
;
}
}
hideNode
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
this
.
_installHelperSheet
(
node
)
;
node
.
rawNode
.
classList
.
add
(
HIDDEN_CLASS
)
;
}
unhideNode
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
node
.
rawNode
.
classList
.
remove
(
HIDDEN_CLASS
)
;
}
removePseudoClassLock
(
node
pseudo
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
this
.
_removePseudoClassLock
(
node
pseudo
)
;
for
(
let
locked
of
this
.
_activePseudoClassLocks
)
{
if
(
node
.
rawNode
.
contains
(
locked
.
rawNode
)
&
&
DOMUtils
.
hasPseudoClassLock
(
locked
.
rawNode
pseudo
)
)
{
this
.
_removePseudoClassLock
(
locked
pseudo
)
;
}
}
if
(
!
options
.
parents
)
{
return
;
}
let
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
let
cur
;
while
(
(
cur
=
walker
.
parentNode
(
)
)
)
{
let
curNode
=
this
.
_ref
(
cur
)
;
this
.
_removePseudoClassLock
(
curNode
pseudo
)
;
}
}
_removePseudoClassLock
(
node
pseudo
)
{
if
(
node
.
rawNode
.
nodeType
!
=
Ci
.
nsIDOMNode
.
ELEMENT_NODE
)
{
return
false
;
}
DOMUtils
.
removePseudoClassLock
(
node
.
rawNode
pseudo
)
;
if
(
!
node
.
writePseudoClassLocks
(
)
)
{
this
.
_activePseudoClassLocks
.
delete
(
node
)
;
}
this
.
_queuePseudoClassMutation
(
node
)
;
return
true
;
}
clearPseudoClassLocks
(
node
)
{
if
(
node
&
&
isNodeDead
(
node
)
)
{
return
;
}
if
(
node
)
{
DOMUtils
.
clearPseudoClassLocks
(
node
.
rawNode
)
;
this
.
_activePseudoClassLocks
.
delete
(
node
)
;
this
.
_queuePseudoClassMutation
(
node
)
;
}
else
{
for
(
let
locked
of
this
.
_activePseudoClassLocks
)
{
DOMUtils
.
clearPseudoClassLocks
(
locked
.
rawNode
)
;
this
.
_activePseudoClassLocks
.
delete
(
locked
)
;
this
.
_queuePseudoClassMutation
(
locked
)
;
}
}
}
innerHTML
(
node
)
{
let
html
=
"
"
;
if
(
!
isNodeDead
(
node
)
)
{
html
=
node
.
rawNode
.
innerHTML
;
}
return
LongStringActor
(
this
.
conn
html
)
;
}
setInnerHTML
(
node
value
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
let
rawNode
=
node
.
rawNode
;
if
(
rawNode
.
nodeType
!
=
=
rawNode
.
ownerDocument
.
ELEMENT_NODE
)
{
throw
new
Error
(
"
Can
only
change
innerHTML
to
element
nodes
"
)
;
}
rawNode
.
innerHTML
=
value
;
}
outerHTML
(
node
)
{
let
outerHTML
=
"
"
;
if
(
!
isNodeDead
(
node
)
)
{
outerHTML
=
node
.
rawNode
.
outerHTML
;
}
return
LongStringActor
(
this
.
conn
outerHTML
)
;
}
setOuterHTML
(
node
value
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
let
parsedDOM
=
DOMParser
.
parseFromString
(
value
"
text
/
html
"
)
;
let
rawNode
=
node
.
rawNode
;
let
parentNode
=
rawNode
.
parentNode
;
if
(
rawNode
.
tagName
=
=
=
"
BODY
"
)
{
if
(
parsedDOM
.
head
.
innerHTML
=
=
=
"
"
)
{
parentNode
.
replaceChild
(
parsedDOM
.
body
rawNode
)
;
}
else
{
rawNode
.
outerHTML
=
value
;
}
}
else
if
(
rawNode
.
tagName
=
=
=
"
HEAD
"
)
{
if
(
parsedDOM
.
body
.
innerHTML
=
=
=
"
"
)
{
parentNode
.
replaceChild
(
parsedDOM
.
head
rawNode
)
;
}
else
{
rawNode
.
outerHTML
=
value
;
}
}
else
if
(
node
.
isDocumentElement
(
)
)
{
let
finalAttributeModifications
=
[
]
;
let
attributeModifications
=
{
}
;
for
(
let
attribute
of
rawNode
.
attributes
)
{
attributeModifications
[
attribute
.
name
]
=
null
;
}
for
(
let
attribute
of
parsedDOM
.
documentElement
.
attributes
)
{
attributeModifications
[
attribute
.
name
]
=
attribute
.
value
;
}
for
(
let
key
in
attributeModifications
)
{
finalAttributeModifications
.
push
(
{
attributeName
:
key
newValue
:
attributeModifications
[
key
]
}
)
;
}
node
.
modifyAttributes
(
finalAttributeModifications
)
;
rawNode
.
replaceChild
(
parsedDOM
.
head
rawNode
.
querySelector
(
"
head
"
)
)
;
rawNode
.
replaceChild
(
parsedDOM
.
body
rawNode
.
querySelector
(
"
body
"
)
)
;
}
else
{
rawNode
.
outerHTML
=
value
;
}
}
insertAdjacentHTML
(
node
position
value
)
{
if
(
isNodeDead
(
node
)
)
{
return
{
node
:
[
]
newParents
:
[
]
}
;
}
let
rawNode
=
node
.
rawNode
;
let
isInsertAsSibling
=
position
=
=
=
"
beforeBegin
"
|
|
position
=
=
=
"
afterEnd
"
;
if
(
isInsertAsSibling
&
&
node
.
isDocumentElement
(
)
)
{
throw
new
Error
(
"
Can
'
t
insert
adjacent
element
to
the
root
.
"
)
;
}
let
rawParentNode
=
rawNode
.
parentNode
;
if
(
!
rawParentNode
&
&
isInsertAsSibling
)
{
throw
new
Error
(
"
Can
'
t
insert
as
sibling
without
parent
node
.
"
)
;
}
let
range
=
rawNode
.
ownerDocument
.
createRange
(
)
;
if
(
position
=
=
=
"
beforeBegin
"
|
|
position
=
=
=
"
afterEnd
"
)
{
range
.
selectNode
(
rawNode
)
;
}
else
{
range
.
selectNodeContents
(
rawNode
)
;
}
let
docFrag
=
range
.
createContextualFragment
(
value
)
;
let
newRawNodes
=
Array
.
from
(
docFrag
.
childNodes
)
;
switch
(
position
)
{
case
"
beforeBegin
"
:
rawParentNode
.
insertBefore
(
docFrag
rawNode
)
;
break
;
case
"
afterEnd
"
:
rawParentNode
.
insertBefore
(
docFrag
rawNode
.
nextSibling
)
;
break
;
case
"
afterBegin
"
:
rawNode
.
insertBefore
(
docFrag
rawNode
.
firstChild
)
;
break
;
case
"
beforeEnd
"
:
rawNode
.
appendChild
(
docFrag
)
;
break
;
default
:
throw
new
Error
(
"
Invalid
position
value
.
Must
be
either
"
+
"
'
beforeBegin
'
'
beforeEnd
'
'
afterBegin
'
or
'
afterEnd
'
.
"
)
;
}
return
this
.
attachElements
(
newRawNodes
)
;
}
duplicateNode
(
{
rawNode
}
)
{
let
clonedNode
=
rawNode
.
cloneNode
(
true
)
;
rawNode
.
parentNode
.
insertBefore
(
clonedNode
rawNode
.
nextSibling
)
;
}
isDocumentOrDocumentElementNode
(
node
)
{
return
(
(
node
.
rawNode
.
ownerDocument
&
&
node
.
rawNode
.
ownerDocument
.
documentElement
=
=
=
this
.
rawNode
)
|
|
node
.
rawNode
.
nodeType
=
=
=
Ci
.
nsIDOMNode
.
DOCUMENT_NODE
)
;
}
removeNode
(
node
)
{
if
(
isNodeDead
(
node
)
|
|
this
.
isDocumentOrDocumentElementNode
(
node
)
)
{
throw
Error
(
"
Cannot
remove
document
document
elements
or
dead
nodes
.
"
)
;
}
let
nextSibling
=
this
.
nextSibling
(
node
)
;
node
.
rawNode
.
remove
(
)
;
return
nextSibling
;
}
removeNodes
(
nodes
)
{
for
(
let
node
of
nodes
)
{
if
(
isNodeDead
(
node
)
|
|
this
.
isDocumentOrDocumentElementNode
(
node
)
)
{
throw
Error
(
"
Cannot
remove
document
document
elements
or
dead
nodes
"
)
;
}
}
for
(
let
node
of
nodes
)
{
node
.
rawNode
.
remove
(
)
;
}
}
insertBefore
(
node
parent
sibling
)
{
if
(
isNodeDead
(
node
)
|
|
isNodeDead
(
parent
)
|
|
(
sibling
&
&
isNodeDead
(
sibling
)
)
)
{
return
;
}
let
rawNode
=
node
.
rawNode
;
let
rawParent
=
parent
.
rawNode
;
let
rawSibling
=
sibling
?
sibling
.
rawNode
:
null
;
if
(
rawNode
.
parentNode
=
=
=
rawParent
)
{
let
currentNextSibling
=
this
.
nextSibling
(
node
)
;
currentNextSibling
=
currentNextSibling
?
currentNextSibling
.
rawNode
:
null
;
if
(
rawNode
=
=
=
rawSibling
|
|
currentNextSibling
=
=
=
rawSibling
)
{
return
;
}
}
rawParent
.
insertBefore
(
rawNode
rawSibling
)
;
}
editTagName
(
node
tagName
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
let
oldNode
=
node
.
rawNode
;
let
newNode
;
try
{
newNode
=
nodeDocument
(
oldNode
)
.
createElement
(
tagName
)
;
}
catch
(
x
)
{
return
Promise
.
reject
(
new
Error
(
"
Could
not
change
node
'
s
tagName
to
"
+
tagName
)
)
;
}
let
attrs
=
oldNode
.
attributes
;
for
(
let
i
=
0
;
i
<
attrs
.
length
;
i
+
+
)
{
newNode
.
setAttribute
(
attrs
[
i
]
.
name
attrs
[
i
]
.
value
)
;
}
oldNode
.
parentNode
.
insertBefore
(
newNode
oldNode
)
;
while
(
oldNode
.
firstChild
)
{
newNode
.
appendChild
(
oldNode
.
firstChild
)
;
}
oldNode
.
remove
(
)
;
return
null
;
}
getMutations
(
options
=
{
}
)
{
let
pending
=
this
.
_pendingMutations
|
|
[
]
;
this
.
_pendingMutations
=
[
]
;
if
(
options
.
cleanup
)
{
for
(
let
node
of
this
.
_orphaned
)
{
this
.
releaseNode
(
node
)
;
}
this
.
_orphaned
=
new
Set
(
)
;
}
return
pending
;
}
queueMutation
(
mutation
)
{
if
(
!
this
.
actorID
|
|
this
.
_destroyed
)
{
return
;
}
let
needEvent
=
this
.
_pendingMutations
.
length
=
=
=
0
;
this
.
_pendingMutations
.
push
(
mutation
)
;
if
(
needEvent
)
{
events
.
emit
(
this
"
new
-
mutations
"
)
;
}
}
onMutations
(
mutations
)
{
events
.
emit
(
this
"
any
-
mutation
"
)
;
for
(
let
change
of
mutations
)
{
let
targetActor
=
this
.
getNode
(
change
.
target
)
;
if
(
!
targetActor
)
{
continue
;
}
let
targetNode
=
change
.
target
;
let
type
=
change
.
type
;
let
mutation
=
{
type
target
:
targetActor
.
actorID
}
;
if
(
type
=
=
=
"
attributes
"
)
{
mutation
.
attributeName
=
change
.
attributeName
;
mutation
.
attributeNamespace
=
change
.
attributeNamespace
|
|
undefined
;
mutation
.
newValue
=
targetNode
.
hasAttribute
(
mutation
.
attributeName
)
?
targetNode
.
getAttribute
(
mutation
.
attributeName
)
:
null
;
}
else
if
(
type
=
=
=
"
characterData
"
)
{
mutation
.
newValue
=
targetNode
.
nodeValue
;
this
.
_maybeQueueInlineTextChildMutation
(
change
targetNode
)
;
}
else
if
(
type
=
=
=
"
childList
"
|
|
type
=
=
=
"
nativeAnonymousChildList
"
)
{
let
removedActors
=
[
]
;
let
addedActors
=
[
]
;
for
(
let
removed
of
change
.
removedNodes
)
{
let
removedActor
=
this
.
getNode
(
removed
)
;
if
(
!
removedActor
)
{
continue
;
}
this
.
_orphaned
.
add
(
removedActor
)
;
removedActors
.
push
(
removedActor
.
actorID
)
;
}
for
(
let
added
of
change
.
addedNodes
)
{
let
addedActor
=
this
.
getNode
(
added
)
;
if
(
!
addedActor
)
{
continue
;
}
this
.
_orphaned
.
delete
(
addedActor
)
;
addedActors
.
push
(
addedActor
.
actorID
)
;
}
mutation
.
numChildren
=
targetActor
.
numChildren
;
mutation
.
removed
=
removedActors
;
mutation
.
added
=
addedActors
;
let
inlineTextChild
=
this
.
inlineTextChild
(
targetActor
)
;
if
(
inlineTextChild
)
{
mutation
.
inlineTextChild
=
inlineTextChild
.
form
(
)
;
}
}
this
.
queueMutation
(
mutation
)
;
}
}
_maybeQueueInlineTextChildMutation
(
mutation
)
{
let
{
oldValue
target
}
=
mutation
;
let
newValue
=
target
.
nodeValue
;
let
limit
=
gValueSummaryLength
;
if
(
(
oldValue
.
length
<
=
limit
&
&
newValue
.
length
<
=
limit
)
|
|
(
oldValue
.
length
>
limit
&
&
newValue
.
length
>
limit
)
)
{
return
;
}
let
parentActor
=
this
.
getNode
(
target
.
parentNode
)
;
if
(
!
parentActor
|
|
parentActor
.
rawNode
.
children
.
length
>
0
)
{
return
;
}
let
inlineTextChild
=
this
.
inlineTextChild
(
parentActor
)
;
this
.
queueMutation
(
{
type
:
"
inlineTextChild
"
target
:
parentActor
.
actorID
inlineTextChild
:
inlineTextChild
?
inlineTextChild
.
form
(
)
:
undefined
}
)
;
}
onFrameLoad
(
{
window
isTopLevel
}
)
{
let
{
readyState
}
=
window
.
document
;
if
(
readyState
!
=
"
interactive
"
&
&
readyState
!
=
"
complete
"
)
{
window
.
addEventListener
(
"
DOMContentLoaded
"
this
.
onFrameLoad
.
bind
(
this
{
window
isTopLevel
}
)
{
once
:
true
}
)
;
return
;
}
if
(
isTopLevel
)
{
if
(
this
.
rootDoc
&
&
!
Cu
.
isDeadWrapper
(
this
.
rootDoc
)
&
&
this
.
rootDoc
.
defaultView
)
{
this
.
onFrameUnload
(
{
window
:
this
.
rootDoc
.
defaultView
}
)
;
}
this
.
rootDoc
=
window
.
document
;
this
.
rootNode
=
this
.
document
(
)
;
this
.
queueMutation
(
{
type
:
"
newRoot
"
target
:
this
.
rootNode
.
form
(
)
}
)
;
return
;
}
let
frame
=
getFrameElement
(
window
)
;
let
frameActor
=
this
.
getNode
(
frame
)
;
if
(
!
frameActor
)
{
return
;
}
this
.
queueMutation
(
{
type
:
"
frameLoad
"
target
:
frameActor
.
actorID
}
)
;
this
.
queueMutation
(
{
type
:
"
childList
"
target
:
frameActor
.
actorID
added
:
[
]
removed
:
[
]
}
)
;
}
_childOfWindow
(
window
domNode
)
{
let
win
=
nodeDocument
(
domNode
)
.
defaultView
;
while
(
win
)
{
if
(
win
=
=
=
window
)
{
return
true
;
}
win
=
getFrameElement
(
win
)
;
}
return
false
;
}
onFrameUnload
(
{
window
}
)
{
let
releasedOrphans
=
[
]
;
for
(
let
retained
of
this
.
_retainedOrphans
)
{
if
(
Cu
.
isDeadWrapper
(
retained
.
rawNode
)
|
|
this
.
_childOfWindow
(
window
retained
.
rawNode
)
)
{
this
.
_retainedOrphans
.
delete
(
retained
)
;
releasedOrphans
.
push
(
retained
.
actorID
)
;
this
.
releaseNode
(
retained
{
force
:
true
}
)
;
}
}
if
(
releasedOrphans
.
length
>
0
)
{
this
.
queueMutation
(
{
target
:
this
.
rootNode
.
actorID
type
:
"
unretained
"
nodes
:
releasedOrphans
}
)
;
}
let
doc
=
window
.
document
;
let
documentActor
=
this
.
getNode
(
doc
)
;
if
(
!
documentActor
)
{
return
;
}
if
(
this
.
rootDoc
=
=
=
doc
)
{
this
.
rootDoc
=
null
;
this
.
rootNode
=
null
;
}
this
.
queueMutation
(
{
type
:
"
documentUnload
"
target
:
documentActor
.
actorID
}
)
;
let
walker
=
this
.
getDocumentWalker
(
doc
)
;
let
parentNode
=
walker
.
parentNode
(
)
;
if
(
parentNode
)
{
this
.
queueMutation
(
{
type
:
"
childList
"
target
:
this
.
getNode
(
parentNode
)
.
actorID
added
:
[
]
removed
:
[
]
}
)
;
}
this
.
releaseNode
(
documentActor
{
force
:
true
}
)
;
}
_isInDOMTree
(
rawNode
)
{
let
walker
=
this
.
getDocumentWalker
(
rawNode
)
;
let
current
=
walker
.
currentNode
;
while
(
walker
.
parentNode
(
)
)
{
current
=
walker
.
currentNode
;
}
if
(
current
.
nodeType
=
=
=
Ci
.
nsIDOMNode
.
DOCUMENT_FRAGMENT_NODE
|
|
current
!
=
=
this
.
rootDoc
)
{
return
false
;
}
return
true
;
}
isInDOMTree
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
false
;
}
return
this
.
_isInDOMTree
(
node
.
rawNode
)
;
}
getNodeActorFromObjectActor
(
objectActorID
)
{
let
actor
=
this
.
conn
.
getActor
(
objectActorID
)
;
if
(
!
actor
)
{
return
null
;
}
let
debuggerObject
=
this
.
conn
.
getActor
(
objectActorID
)
.
obj
;
let
rawNode
=
debuggerObject
.
unsafeDereference
(
)
;
if
(
!
this
.
_isInDOMTree
(
rawNode
)
)
{
return
null
;
}
if
(
rawNode
.
defaultView
&
&
rawNode
=
=
=
rawNode
.
defaultView
.
document
)
{
rawNode
=
rawNode
.
documentElement
;
}
return
this
.
attachElement
(
rawNode
)
;
}
getStyleSheetOwnerNode
(
styleSheetActorID
)
{
return
this
.
getNodeFromActor
(
styleSheetActorID
[
"
ownerNode
"
]
)
;
}
getNodeFromActor
(
actorID
path
)
{
let
actor
=
this
.
conn
.
getActor
(
actorID
)
;
if
(
!
actor
)
{
return
null
;
}
let
obj
=
actor
;
for
(
let
name
of
path
)
{
if
(
!
(
name
in
obj
)
)
{
return
null
;
}
obj
=
obj
[
name
]
;
}
return
this
.
attachElement
(
obj
)
;
}
getLayoutInspector
(
)
{
if
(
!
this
.
layoutActor
)
{
this
.
layoutActor
=
new
LayoutActor
(
this
.
conn
this
.
tabActor
this
)
;
}
return
this
.
layoutActor
;
}
}
)
;
exports
.
InspectorActor
=
protocol
.
ActorClassWithSpec
(
inspectorSpec
{
initialize
(
conn
tabActor
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
tabActor
=
tabActor
;
this
.
_onColorPicked
=
this
.
_onColorPicked
.
bind
(
this
)
;
this
.
_onColorPickCanceled
=
this
.
_onColorPickCanceled
.
bind
(
this
)
;
this
.
destroyEyeDropper
=
this
.
destroyEyeDropper
.
bind
(
this
)
;
}
destroy
(
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
destroyEyeDropper
(
)
;
this
.
_highlighterPromise
=
null
;
this
.
_pageStylePromise
=
null
;
this
.
_walkerPromise
=
null
;
this
.
walker
=
null
;
this
.
tabActor
=
null
;
}
get
window
(
)
{
return
this
.
tabActor
.
window
;
}
getWalker
(
options
=
{
}
)
{
if
(
this
.
_walkerPromise
)
{
return
this
.
_walkerPromise
;
}
let
deferred
=
promise
.
defer
(
)
;
this
.
_walkerPromise
=
deferred
.
promise
;
let
window
=
this
.
window
;
let
domReady
=
(
)
=
>
{
let
tabActor
=
this
.
tabActor
;
window
.
removeEventListener
(
"
DOMContentLoaded
"
domReady
true
)
;
this
.
walker
=
WalkerActor
(
this
.
conn
tabActor
options
)
;
this
.
manage
(
this
.
walker
)
;
events
.
once
(
this
.
walker
"
destroyed
"
(
)
=
>
{
this
.
_walkerPromise
=
null
;
this
.
_pageStylePromise
=
null
;
}
)
;
deferred
.
resolve
(
this
.
walker
)
;
}
;
if
(
window
.
document
.
readyState
=
=
=
"
loading
"
)
{
window
.
addEventListener
(
"
DOMContentLoaded
"
domReady
true
)
;
}
else
{
domReady
(
)
;
}
return
this
.
_walkerPromise
;
}
getPageStyle
(
)
{
if
(
this
.
_pageStylePromise
)
{
return
this
.
_pageStylePromise
;
}
this
.
_pageStylePromise
=
this
.
getWalker
(
)
.
then
(
walker
=
>
{
let
pageStyle
=
PageStyleActor
(
this
)
;
this
.
manage
(
pageStyle
)
;
return
pageStyle
;
}
)
;
return
this
.
_pageStylePromise
;
}
getHighlighter
(
autohide
)
{
if
(
this
.
_highlighterPromise
)
{
return
this
.
_highlighterPromise
;
}
this
.
_highlighterPromise
=
this
.
getWalker
(
)
.
then
(
walker
=
>
{
let
highlighter
=
HighlighterActor
(
this
autohide
)
;
this
.
manage
(
highlighter
)
;
return
highlighter
;
}
)
;
return
this
.
_highlighterPromise
;
}
getHighlighterByType
(
typeName
)
{
if
(
isTypeRegistered
(
typeName
)
)
{
return
CustomHighlighterActor
(
this
typeName
)
;
}
return
null
;
}
getImageDataFromURL
(
url
maxDim
)
{
let
img
=
new
this
.
window
.
Image
(
)
;
img
.
src
=
url
;
return
imageToImageData
(
img
maxDim
)
.
then
(
imageData
=
>
{
return
{
data
:
LongStringActor
(
this
.
conn
imageData
.
data
)
size
:
imageData
.
size
}
;
}
)
;
}
resolveRelativeURL
(
url
node
)
{
let
document
=
isNodeDead
(
node
)
?
this
.
window
.
document
:
nodeDocument
(
node
.
rawNode
)
;
if
(
!
document
)
{
return
url
;
}
let
baseURI
=
Services
.
io
.
newURI
(
document
.
location
.
href
)
;
return
Services
.
io
.
newURI
(
url
null
baseURI
)
.
spec
;
}
createEyeDropper
(
)
{
this
.
destroyEyeDropper
(
)
;
this
.
_highlighterEnv
=
new
HighlighterEnvironment
(
)
;
this
.
_highlighterEnv
.
initFromTabActor
(
this
.
tabActor
)
;
this
.
_eyeDropper
=
new
EyeDropper
(
this
.
_highlighterEnv
)
;
}
destroyEyeDropper
(
)
{
if
(
this
.
_eyeDropper
)
{
this
.
cancelPickColorFromPage
(
)
;
this
.
_eyeDropper
.
destroy
(
)
;
this
.
_eyeDropper
=
null
;
this
.
_highlighterEnv
.
destroy
(
)
;
this
.
_highlighterEnv
=
null
;
}
}
pickColorFromPage
(
options
)
{
this
.
createEyeDropper
(
)
;
this
.
_eyeDropper
.
show
(
this
.
window
.
document
.
documentElement
options
)
;
this
.
_eyeDropper
.
once
(
"
selected
"
this
.
_onColorPicked
)
;
this
.
_eyeDropper
.
once
(
"
canceled
"
this
.
_onColorPickCanceled
)
;
events
.
once
(
this
.
tabActor
"
will
-
navigate
"
this
.
destroyEyeDropper
)
;
}
cancelPickColorFromPage
(
)
{
if
(
this
.
_eyeDropper
)
{
this
.
_eyeDropper
.
hide
(
)
;
this
.
_eyeDropper
.
off
(
"
selected
"
this
.
_onColorPicked
)
;
this
.
_eyeDropper
.
off
(
"
canceled
"
this
.
_onColorPickCanceled
)
;
events
.
off
(
this
.
tabActor
"
will
-
navigate
"
this
.
destroyEyeDropper
)
;
}
}
supportsHighlighters
(
)
{
let
doc
=
this
.
tabActor
.
window
.
document
;
let
ns
=
doc
.
documentElement
.
namespaceURI
;
if
(
ns
=
=
=
XUL_NS
)
{
return
false
;
}
if
(
ns
=
=
=
SVG_NS
)
{
return
false
;
}
return
true
;
}
_onColorPicked
(
e
color
)
{
events
.
emit
(
this
"
color
-
picked
"
color
)
;
}
_onColorPickCanceled
(
)
{
events
.
emit
(
this
"
color
-
pick
-
canceled
"
)
;
}
}
)
;
exports
.
_documentWalker
=
DocumentWalker
;
function
nodeDocument
(
node
)
{
if
(
Cu
.
isDeadWrapper
(
node
)
)
{
return
null
;
}
return
node
.
ownerDocument
|
|
(
node
.
nodeType
=
=
Ci
.
nsIDOMNode
.
DOCUMENT_NODE
?
node
:
null
)
;
}
function
nodeDocshell
(
node
)
{
let
doc
=
node
?
nodeDocument
(
node
)
:
null
;
let
win
=
doc
?
doc
.
defaultView
:
null
;
if
(
win
)
{
return
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
;
}
return
null
;
}
function
isNodeDead
(
node
)
{
return
!
node
|
|
!
node
.
rawNode
|
|
Cu
.
isDeadWrapper
(
node
.
rawNode
)
;
}
function
DocumentWalker
(
node
rootWin
whatToShow
=
nodeFilterConstants
.
SHOW_ALL
filter
=
standardTreeWalkerFilter
)
{
if
(
!
rootWin
.
location
)
{
throw
new
Error
(
"
Got
an
invalid
root
window
in
DocumentWalker
"
)
;
}
this
.
walker
=
Cc
[
"
mozilla
.
org
/
inspector
/
deep
-
tree
-
walker
;
1
"
]
.
createInstance
(
Ci
.
inIDeepTreeWalker
)
;
this
.
walker
.
showAnonymousContent
=
true
;
this
.
walker
.
showSubDocuments
=
true
;
this
.
walker
.
showDocumentsAsNodes
=
true
;
this
.
walker
.
init
(
rootWin
.
document
whatToShow
)
;
this
.
filter
=
filter
;
this
.
walker
.
currentNode
=
node
;
while
(
node
&
&
this
.
filter
(
node
)
=
=
=
nodeFilterConstants
.
FILTER_SKIP
)
{
node
=
this
.
walker
.
parentNode
(
)
;
}
}
DocumentWalker
.
prototype
=
{
get
node
(
)
{
return
this
.
walker
.
node
;
}
get
whatToShow
(
)
{
return
this
.
walker
.
whatToShow
;
}
get
currentNode
(
)
{
return
this
.
walker
.
currentNode
;
}
set
currentNode
(
val
)
{
this
.
walker
.
currentNode
=
val
;
}
parentNode
(
)
{
return
this
.
walker
.
parentNode
(
)
;
}
nextNode
(
)
{
let
node
=
this
.
walker
.
currentNode
;
if
(
!
node
)
{
return
null
;
}
let
nextNode
=
this
.
walker
.
nextNode
(
)
;
while
(
nextNode
&
&
this
.
filter
(
nextNode
)
=
=
=
nodeFilterConstants
.
FILTER_SKIP
)
{
nextNode
=
this
.
walker
.
nextNode
(
)
;
}
return
nextNode
;
}
firstChild
(
)
{
let
node
=
this
.
walker
.
currentNode
;
if
(
!
node
)
{
return
null
;
}
let
firstChild
=
this
.
walker
.
firstChild
(
)
;
while
(
firstChild
&
&
this
.
filter
(
firstChild
)
=
=
=
nodeFilterConstants
.
FILTER_SKIP
)
{
firstChild
=
this
.
walker
.
nextSibling
(
)
;
}
return
firstChild
;
}
lastChild
(
)
{
let
node
=
this
.
walker
.
currentNode
;
if
(
!
node
)
{
return
null
;
}
let
lastChild
=
this
.
walker
.
lastChild
(
)
;
while
(
lastChild
&
&
this
.
filter
(
lastChild
)
=
=
=
nodeFilterConstants
.
FILTER_SKIP
)
{
lastChild
=
this
.
walker
.
previousSibling
(
)
;
}
return
lastChild
;
}
previousSibling
(
)
{
let
node
=
this
.
walker
.
previousSibling
(
)
;
while
(
node
&
&
this
.
filter
(
node
)
=
=
=
nodeFilterConstants
.
FILTER_SKIP
)
{
node
=
this
.
walker
.
previousSibling
(
)
;
}
return
node
;
}
nextSibling
(
)
{
let
node
=
this
.
walker
.
nextSibling
(
)
;
while
(
node
&
&
this
.
filter
(
node
)
=
=
=
nodeFilterConstants
.
FILTER_SKIP
)
{
node
=
this
.
walker
.
nextSibling
(
)
;
}
return
node
;
}
}
;
function
isInXULDocument
(
el
)
{
let
doc
=
nodeDocument
(
el
)
;
return
doc
&
&
doc
.
documentElement
&
&
doc
.
documentElement
.
namespaceURI
=
=
=
XUL_NS
;
}
function
standardTreeWalkerFilter
(
node
)
{
if
(
node
.
nodeName
=
=
=
"
_moz_generated_content_before
"
|
|
node
.
nodeName
=
=
=
"
_moz_generated_content_after
"
)
{
return
nodeFilterConstants
.
FILTER_ACCEPT
;
}
if
(
isWhitespaceTextNode
(
node
)
)
{
return
nodeHasSize
(
node
)
?
nodeFilterConstants
.
FILTER_ACCEPT
:
nodeFilterConstants
.
FILTER_SKIP
;
}
if
(
!
isInXULDocument
(
node
)
&
&
(
isXBLAnonymous
(
node
)
|
|
isNativeAnonymous
(
node
)
)
)
{
return
nodeFilterConstants
.
FILTER_SKIP
;
}
return
nodeFilterConstants
.
FILTER_ACCEPT
;
}
function
allAnonymousContentTreeWalkerFilter
(
node
)
{
if
(
isWhitespaceTextNode
(
node
)
)
{
return
nodeHasSize
(
node
)
?
nodeFilterConstants
.
FILTER_ACCEPT
:
nodeFilterConstants
.
FILTER_SKIP
;
}
return
nodeFilterConstants
.
FILTER_ACCEPT
;
}
function
isWhitespaceTextNode
(
node
)
{
return
node
.
nodeType
=
=
Ci
.
nsIDOMNode
.
TEXT_NODE
&
&
!
/
[
^
\
s
]
/
.
exec
(
node
.
nodeValue
)
;
}
function
nodeHasSize
(
node
)
{
if
(
!
node
.
getBoxQuads
)
{
return
false
;
}
let
quads
=
node
.
getBoxQuads
(
)
;
return
quads
.
length
&
&
quads
.
some
(
quad
=
>
quad
.
bounds
.
width
&
&
quad
.
bounds
.
height
)
;
}
function
ensureImageLoaded
(
image
timeout
)
{
let
{
HTMLImageElement
}
=
image
.
ownerDocument
.
defaultView
;
if
(
!
(
image
instanceof
HTMLImageElement
)
)
{
return
promise
.
reject
(
"
image
must
be
an
HTMLImageELement
"
)
;
}
if
(
image
.
complete
)
{
return
promise
.
resolve
(
)
;
}
let
onLoad
=
AsyncUtils
.
listenOnce
(
image
"
load
"
)
;
let
onError
=
AsyncUtils
.
listenOnce
(
image
"
error
"
)
.
then
(
(
)
=
>
{
return
promise
.
reject
(
"
Image
'
"
+
image
.
src
+
"
'
failed
to
load
.
"
)
;
}
)
;
let
onAbort
=
new
Promise
(
(
)
=
>
{
}
)
;
if
(
!
flags
.
testing
)
{
onAbort
=
DevToolsUtils
.
waitForTime
(
timeout
)
.
then
(
(
)
=
>
{
return
promise
.
reject
(
"
Image
'
"
+
image
.
src
+
"
'
took
too
long
to
load
.
"
)
;
}
)
;
}
return
promise
.
race
(
[
onLoad
onError
onAbort
]
)
;
}
var
imageToImageData
=
Task
.
async
(
function
*
(
node
maxDim
)
{
let
{
HTMLCanvasElement
HTMLImageElement
}
=
node
.
ownerDocument
.
defaultView
;
let
isImg
=
node
instanceof
HTMLImageElement
;
let
isCanvas
=
node
instanceof
HTMLCanvasElement
;
if
(
!
isImg
&
&
!
isCanvas
)
{
throw
new
Error
(
"
node
is
not
a
<
canvas
>
or
<
img
>
element
.
"
)
;
}
if
(
isImg
)
{
yield
ensureImageLoaded
(
node
IMAGE_FETCHING_TIMEOUT
)
;
}
let
resizeRatio
=
1
;
let
imgWidth
=
node
.
naturalWidth
|
|
node
.
width
;
let
imgHeight
=
node
.
naturalHeight
|
|
node
.
height
;
let
imgMax
=
Math
.
max
(
imgWidth
imgHeight
)
;
if
(
maxDim
&
&
imgMax
>
maxDim
)
{
resizeRatio
=
maxDim
/
imgMax
;
}
let
imageData
;
if
(
isImg
&
&
node
.
src
.
startsWith
(
"
data
:
"
)
&
&
resizeRatio
=
=
=
1
)
{
imageData
=
node
.
src
;
}
else
{
let
canvas
=
node
.
ownerDocument
.
createElementNS
(
XHTML_NS
"
canvas
"
)
;
canvas
.
width
=
imgWidth
*
resizeRatio
;
canvas
.
height
=
imgHeight
*
resizeRatio
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
drawImage
(
node
0
0
canvas
.
width
canvas
.
height
)
;
imageData
=
canvas
.
toDataURL
(
"
image
/
png
"
)
;
}
return
{
data
:
imageData
size
:
{
naturalWidth
:
imgWidth
naturalHeight
:
imgHeight
resized
:
resizeRatio
!
=
=
1
}
}
;
}
)
;
loader
.
lazyGetter
(
this
"
DOMUtils
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
inspector
/
dom
-
utils
;
1
"
]
.
getService
(
Ci
.
inIDOMUtils
)
;
}
)
;
