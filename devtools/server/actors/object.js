"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
assert
}
=
DevToolsUtils
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
objectSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
object
"
)
;
loader
.
lazyRequireGetter
(
this
"
PropertyIteratorActor
"
"
devtools
/
server
/
actors
/
object
/
property
-
iterator
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
SymbolIteratorActor
"
"
devtools
/
server
/
actors
/
object
/
symbol
-
iterator
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
PrivatePropertiesIteratorActor
"
"
devtools
/
server
/
actors
/
object
/
private
-
properties
-
iterator
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
previewers
"
"
devtools
/
server
/
actors
/
object
/
previewers
"
)
;
loader
.
lazyRequireGetter
(
this
"
makeSideeffectFreeDebugger
"
"
devtools
/
server
/
actors
/
webconsole
/
eval
-
with
-
debugger
"
true
)
;
if
(
!
isWorker
)
{
loader
.
lazyRequireGetter
(
this
"
ContentDOMReference
"
"
resource
:
/
/
gre
/
modules
/
ContentDOMReference
.
jsm
"
true
)
;
}
const
{
getArrayLength
getPromiseState
getStorageLength
isArray
isStorage
isTypedArray
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
proto
=
{
initialize
(
obj
{
thread
createValueGrip
:
createValueGripHook
createEnvironmentActor
getGripDepth
incrementGripDepth
decrementGripDepth
}
conn
)
{
assert
(
!
obj
.
optimizedOut
"
Should
not
create
object
actors
for
optimized
out
values
!
"
)
;
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
conn
=
conn
;
this
.
obj
=
obj
;
this
.
thread
=
thread
;
this
.
hooks
=
{
createValueGrip
:
createValueGripHook
createEnvironmentActor
getGripDepth
incrementGripDepth
decrementGripDepth
}
;
}
rawValue
(
)
{
return
this
.
obj
.
unsafeDereference
(
)
;
}
addWatchpoint
(
property
label
watchpointType
)
{
this
.
thread
.
addWatchpoint
(
this
{
property
label
watchpointType
}
)
;
}
removeWatchpoint
(
property
)
{
this
.
thread
.
removeWatchpoint
(
this
property
)
;
}
removeWatchpoints
(
)
{
this
.
thread
.
removeWatchpoint
(
this
)
;
}
form
(
)
{
const
g
=
{
type
:
"
object
"
actor
:
this
.
actorID
}
;
const
unwrapped
=
DevToolsUtils
.
unwrap
(
this
.
obj
)
;
if
(
unwrapped
=
=
=
undefined
)
{
g
.
class
=
"
InvisibleToDebugger
:
"
+
this
.
obj
.
class
;
return
g
;
}
if
(
unwrapped
?
.
isProxy
)
{
g
.
class
=
"
Proxy
"
;
this
.
hooks
.
incrementGripDepth
(
)
;
previewers
.
Proxy
[
0
]
(
this
g
null
)
;
this
.
hooks
.
decrementGripDepth
(
)
;
return
g
;
}
if
(
this
.
thread
?
.
_parent
?
.
customFormatters
)
{
const
header
=
this
.
customFormatterHeader
(
)
;
if
(
header
)
{
return
{
.
.
.
g
.
.
.
header
}
;
}
}
const
ownPropertyLength
=
this
.
_getOwnPropertyLength
(
)
;
Object
.
assign
(
g
{
class
:
unwrapped
=
=
=
null
?
"
Restricted
"
:
this
.
obj
.
class
ownPropertyLength
:
Number
.
isFinite
(
ownPropertyLength
)
?
ownPropertyLength
:
undefined
extensible
:
this
.
obj
.
isExtensible
(
)
frozen
:
this
.
obj
.
isFrozen
(
)
sealed
:
this
.
obj
.
isSealed
(
)
isError
:
this
.
obj
.
isError
}
)
;
this
.
hooks
.
incrementGripDepth
(
)
;
if
(
g
.
class
=
=
"
Function
"
)
{
g
.
isClassConstructor
=
this
.
obj
.
isClassConstructor
;
}
const
raw
=
this
.
getRawObject
(
)
;
this
.
_populateGripPreview
(
g
raw
)
;
this
.
hooks
.
decrementGripDepth
(
)
;
if
(
raw
&
&
Node
.
isInstance
(
raw
)
&
&
ContentDOMReference
)
{
try
{
g
.
contentDomReference
=
ContentDOMReference
.
get
(
raw
)
;
}
catch
(
e
)
{
}
}
return
g
;
}
_getOwnPropertyLength
(
)
{
if
(
isTypedArray
(
this
.
obj
)
)
{
return
getArrayLength
(
this
.
obj
)
;
}
if
(
isStorage
(
this
.
obj
)
)
{
return
getStorageLength
(
this
.
obj
)
;
}
try
{
return
this
.
obj
.
getOwnPropertyNamesLength
(
)
;
}
catch
(
err
)
{
}
return
null
;
}
getRawObject
(
)
{
let
raw
=
this
.
obj
.
unsafeDereference
(
)
;
if
(
raw
&
&
Cu
)
{
raw
=
Cu
.
unwaiveXrays
(
raw
)
;
}
if
(
raw
&
&
!
DevToolsUtils
.
isSafeJSObject
(
raw
)
)
{
raw
=
null
;
}
return
raw
;
}
_populateGripPreview
(
grip
raw
)
{
const
className
=
this
.
obj
.
class
;
for
(
const
previewer
of
previewers
[
className
]
|
|
previewers
.
Object
)
{
try
{
const
previewerResult
=
previewer
(
this
grip
raw
className
)
;
if
(
previewerResult
)
{
return
;
}
}
catch
(
e
)
{
const
msg
=
"
ObjectActor
.
prototype
.
_populateGripPreview
previewer
function
"
;
DevToolsUtils
.
reportException
(
msg
e
)
;
}
}
}
promiseState
(
)
{
const
{
state
value
reason
}
=
getPromiseState
(
this
.
obj
)
;
const
promiseState
=
{
state
}
;
if
(
state
=
=
"
fulfilled
"
)
{
promiseState
.
value
=
this
.
hooks
.
createValueGrip
(
value
)
;
}
else
if
(
state
=
=
"
rejected
"
)
{
promiseState
.
reason
=
this
.
hooks
.
createValueGrip
(
reason
)
;
}
promiseState
.
creationTimestamp
=
Date
.
now
(
)
-
this
.
obj
.
promiseLifetime
;
if
(
state
!
=
=
"
pending
"
)
{
promiseState
.
timeToSettle
=
this
.
obj
.
promiseTimeToResolution
;
}
return
{
promiseState
}
;
}
enumProperties
(
options
)
{
return
PropertyIteratorActor
(
this
options
this
.
conn
)
;
}
enumEntries
(
)
{
return
PropertyIteratorActor
(
this
{
enumEntries
:
true
}
this
.
conn
)
;
}
enumSymbols
(
)
{
return
SymbolIteratorActor
(
this
this
.
conn
)
;
}
enumPrivateProperties
(
)
{
return
PrivatePropertiesIteratorActor
(
this
this
.
conn
)
;
}
prototypeAndProperties
(
)
{
let
objProto
=
null
;
let
names
=
[
]
;
let
symbols
=
[
]
;
if
(
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
try
{
objProto
=
this
.
obj
.
proto
;
names
=
this
.
obj
.
getOwnPropertyNames
(
)
;
symbols
=
this
.
obj
.
getOwnPropertySymbols
(
)
;
}
catch
(
err
)
{
}
}
const
ownProperties
=
Object
.
create
(
null
)
;
const
ownSymbols
=
[
]
;
for
(
const
name
of
names
)
{
ownProperties
[
name
]
=
this
.
_propertyDescriptor
(
name
)
;
}
for
(
const
sym
of
symbols
)
{
ownSymbols
.
push
(
{
name
:
sym
.
toString
(
)
descriptor
:
this
.
_propertyDescriptor
(
sym
)
}
)
;
}
return
{
prototype
:
this
.
hooks
.
createValueGrip
(
objProto
)
ownProperties
ownSymbols
safeGetterValues
:
this
.
_findSafeGetterValues
(
names
)
}
;
}
_findSafeGetterValues
(
ownProperties
limit
=
Infinity
)
{
const
safeGetterValues
=
Object
.
create
(
null
)
;
let
obj
=
this
.
obj
;
let
level
=
0
currentGetterValuesCount
=
0
;
if
(
!
DevToolsUtils
.
isSafeDebuggerObject
(
obj
)
)
{
return
safeGetterValues
;
}
if
(
isArray
(
this
.
obj
)
|
|
[
"
Object
"
"
String
"
]
.
includes
(
this
.
obj
.
class
)
)
{
obj
=
obj
.
proto
;
level
+
+
;
}
while
(
obj
&
&
DevToolsUtils
.
isSafeDebuggerObject
(
obj
)
)
{
for
(
const
name
of
this
.
_findSafeGetters
(
obj
)
)
{
if
(
name
in
safeGetterValues
|
|
(
obj
!
=
this
.
obj
&
&
ownProperties
.
includes
(
name
)
)
)
{
continue
;
}
if
(
!
obj
.
proto
&
&
name
=
=
"
__proto__
"
)
{
continue
;
}
const
desc
=
safeGetOwnPropertyDescriptor
(
obj
name
)
;
if
(
!
desc
?
.
get
)
{
obj
.
_safeGetters
=
null
;
continue
;
}
const
getterValue
=
this
.
_evaluateGetter
(
desc
.
get
)
;
if
(
getterValue
=
=
=
undefined
)
{
continue
;
}
if
(
isRejectedPromise
(
getterValue
)
)
{
const
raw
=
getterValue
.
unsafeDereference
(
)
;
if
(
DevToolsUtils
.
isSafeJSObject
(
raw
)
)
{
raw
.
catch
(
e
=
>
e
)
;
}
continue
;
}
safeGetterValues
[
name
]
=
{
getterValue
:
this
.
hooks
.
createValueGrip
(
getterValue
)
getterPrototypeLevel
:
level
enumerable
:
desc
.
enumerable
writable
:
level
=
=
0
?
desc
.
writable
:
true
}
;
+
+
currentGetterValuesCount
;
if
(
currentGetterValuesCount
=
=
limit
)
{
return
safeGetterValues
;
}
}
obj
=
obj
.
proto
;
level
+
+
;
}
return
safeGetterValues
;
}
_evaluateGetter
(
getter
)
{
const
result
=
getter
.
call
(
this
.
obj
)
;
if
(
!
result
|
|
"
throw
"
in
result
)
{
return
undefined
;
}
let
getterValue
=
undefined
;
if
(
"
return
"
in
result
)
{
getterValue
=
result
.
return
;
}
else
if
(
"
yield
"
in
result
)
{
getterValue
=
result
.
yield
;
}
return
getterValue
;
}
_findSafeGetters
(
object
)
{
if
(
object
.
_safeGetters
)
{
return
object
.
_safeGetters
;
}
const
getters
=
new
Set
(
)
;
if
(
!
DevToolsUtils
.
isSafeDebuggerObject
(
object
)
)
{
object
.
_safeGetters
=
getters
;
return
getters
;
}
let
names
=
[
]
;
try
{
names
=
object
.
getOwnPropertyNames
(
)
;
}
catch
(
ex
)
{
}
for
(
const
name
of
names
)
{
let
desc
=
null
;
try
{
desc
=
object
.
getOwnPropertyDescriptor
(
name
)
;
}
catch
(
e
)
{
}
if
(
!
desc
|
|
desc
.
value
!
=
=
undefined
|
|
!
(
"
get
"
in
desc
)
)
{
continue
;
}
if
(
DevToolsUtils
.
hasSafeGetter
(
desc
)
)
{
getters
.
add
(
name
)
;
}
}
object
.
_safeGetters
=
getters
;
return
getters
;
}
prototype
(
)
{
let
objProto
=
null
;
if
(
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
objProto
=
this
.
obj
.
proto
;
}
return
{
prototype
:
this
.
hooks
.
createValueGrip
(
objProto
)
}
;
}
property
(
name
)
{
if
(
!
name
)
{
return
this
.
throwError
(
"
missingParameter
"
"
no
property
name
was
specified
"
)
;
}
return
{
descriptor
:
this
.
_propertyDescriptor
(
name
)
}
;
}
propertyValue
(
name
receiverId
)
{
if
(
!
name
)
{
return
this
.
throwError
(
"
missingParameter
"
"
no
property
name
was
specified
"
)
;
}
let
receiver
;
if
(
receiverId
)
{
const
receiverActor
=
this
.
conn
.
getActor
(
receiverId
)
;
if
(
receiverActor
)
{
receiver
=
receiverActor
.
obj
;
}
}
const
value
=
receiver
?
this
.
obj
.
getProperty
(
name
receiver
)
:
this
.
obj
.
getProperty
(
name
)
;
return
{
value
:
this
.
_buildCompletion
(
value
)
}
;
}
apply
(
context
args
)
{
if
(
!
this
.
obj
.
callable
)
{
return
this
.
throwError
(
"
notCallable
"
"
debugee
object
is
not
callable
"
)
;
}
const
debugeeContext
=
this
.
_getValueFromGrip
(
context
)
;
const
debugeeArgs
=
args
&
&
args
.
map
(
this
.
_getValueFromGrip
this
)
;
const
value
=
this
.
obj
.
apply
(
debugeeContext
debugeeArgs
)
;
return
{
value
:
this
.
_buildCompletion
(
value
)
}
;
}
_getValueFromGrip
(
grip
)
{
if
(
typeof
grip
!
=
=
"
object
"
|
|
!
grip
)
{
return
grip
;
}
if
(
typeof
grip
.
actor
!
=
=
"
string
"
)
{
return
this
.
throwError
(
"
invalidGrip
"
"
grip
argument
did
not
include
actor
ID
"
)
;
}
const
actor
=
this
.
conn
.
getActor
(
grip
.
actor
)
;
if
(
!
actor
)
{
return
this
.
throwError
(
"
unknownActor
"
"
grip
actor
did
not
match
a
known
object
"
)
;
}
return
actor
.
obj
;
}
_buildCompletion
(
value
)
{
let
completionGrip
=
null
;
if
(
value
)
{
completionGrip
=
{
}
;
if
(
"
return
"
in
value
)
{
completionGrip
.
return
=
this
.
hooks
.
createValueGrip
(
value
.
return
)
;
}
if
(
"
throw
"
in
value
)
{
completionGrip
.
throw
=
this
.
hooks
.
createValueGrip
(
value
.
throw
)
;
}
}
return
completionGrip
;
}
_propertyDescriptor
(
name
onlyEnumerable
)
{
if
(
!
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
return
undefined
;
}
let
desc
;
try
{
desc
=
this
.
obj
.
getOwnPropertyDescriptor
(
name
)
;
}
catch
(
e
)
{
return
{
configurable
:
false
writable
:
false
enumerable
:
false
value
:
e
.
name
}
;
}
if
(
isStorage
(
this
.
obj
)
)
{
if
(
name
=
=
=
"
length
"
)
{
return
undefined
;
}
return
desc
;
}
if
(
!
desc
|
|
(
onlyEnumerable
&
&
!
desc
.
enumerable
)
)
{
return
undefined
;
}
const
retval
=
{
configurable
:
desc
.
configurable
enumerable
:
desc
.
enumerable
}
;
const
obj
=
this
.
rawValue
(
)
;
if
(
"
value
"
in
desc
)
{
retval
.
writable
=
desc
.
writable
;
retval
.
value
=
this
.
hooks
.
createValueGrip
(
desc
.
value
)
;
}
else
if
(
this
.
thread
.
getWatchpoint
(
obj
name
.
toString
(
)
)
)
{
const
watchpoint
=
this
.
thread
.
getWatchpoint
(
obj
name
.
toString
(
)
)
;
retval
.
value
=
this
.
hooks
.
createValueGrip
(
watchpoint
.
desc
.
value
)
;
retval
.
watchpoint
=
watchpoint
.
watchpointType
;
}
else
{
if
(
"
get
"
in
desc
)
{
retval
.
get
=
this
.
hooks
.
createValueGrip
(
desc
.
get
)
;
}
if
(
"
set
"
in
desc
)
{
retval
.
set
=
this
.
hooks
.
createValueGrip
(
desc
.
set
)
;
}
}
return
retval
;
}
proxySlots
(
)
{
const
unwrapped
=
DevToolsUtils
.
unwrap
(
this
.
obj
)
;
if
(
!
unwrapped
|
|
!
unwrapped
.
isProxy
)
{
return
this
.
throwError
(
"
objectNotProxy
"
"
'
proxySlots
'
request
is
only
valid
for
grips
with
a
'
Proxy
'
class
.
"
)
;
}
return
{
proxyTarget
:
this
.
hooks
.
createValueGrip
(
this
.
obj
.
proxyTarget
)
proxyHandler
:
this
.
hooks
.
createValueGrip
(
this
.
obj
.
proxyHandler
)
}
;
}
customFormatterHeader
(
)
{
const
rawValue
=
this
.
rawValue
(
)
;
const
globalWrapper
=
Cu
.
getGlobalForObject
(
rawValue
)
;
const
global
=
globalWrapper
?
.
wrappedJSObject
;
if
(
global
&
&
Array
.
isArray
(
global
.
devtoolsFormatters
)
)
{
const
dbg
=
makeSideeffectFreeDebugger
(
)
;
const
dbgGlobal
=
dbg
.
makeGlobalObjectReference
(
global
)
;
for
(
const
[
index
formatter
]
of
global
.
devtoolsFormatters
.
entries
(
)
)
{
if
(
typeof
formatter
?
.
header
!
=
=
"
function
"
)
{
continue
;
}
try
{
const
formatterHeaderDbgValue
=
dbgGlobal
.
makeDebuggeeValue
(
formatter
.
header
)
;
const
debuggeeValue
=
dbgGlobal
.
makeDebuggeeValue
(
rawValue
)
;
const
header
=
formatterHeaderDbgValue
.
call
(
dbgGlobal
debuggeeValue
)
;
if
(
header
?
.
return
?
.
class
=
=
=
"
Array
"
)
{
let
hasBody
=
false
;
if
(
typeof
formatter
?
.
hasBody
=
=
=
"
function
"
)
{
const
formatterHasBodyDbgValue
=
dbgGlobal
.
makeDebuggeeValue
(
formatter
.
hasBody
)
;
hasBody
=
formatterHasBodyDbgValue
.
call
(
dbgGlobal
debuggeeValue
)
;
}
return
{
useCustomFormatter
:
true
customFormatterIndex
:
index
header
:
global
.
structuredClone
(
header
.
return
.
unsafeDereference
(
)
)
hasBody
:
!
!
hasBody
.
return
}
;
}
}
catch
(
e
)
{
dump
(
{
e
}
\
n
)
;
}
finally
{
dbg
.
removeAllDebuggees
(
)
;
}
}
}
return
null
;
}
customFormatterBody
(
customFormatterIndex
)
{
const
rawValue
=
this
.
rawValue
(
)
;
const
globalWrapper
=
Cu
.
getGlobalForObject
(
rawValue
)
;
const
global
=
globalWrapper
?
.
wrappedJSObject
;
const
dbg
=
makeSideeffectFreeDebugger
(
)
;
try
{
const
dbgGlobal
=
dbg
.
makeGlobalObjectReference
(
global
)
;
const
formatter
=
global
.
devtoolsFormatters
[
customFormatterIndex
]
;
const
formatterBodyDbgValue
=
formatter
&
&
dbgGlobal
.
makeDebuggeeValue
(
formatter
.
body
)
;
const
body
=
formatterBodyDbgValue
.
call
(
dbgGlobal
dbgGlobal
.
makeDebuggeeValue
(
rawValue
)
)
;
if
(
body
?
.
return
?
.
class
=
=
=
"
Array
"
)
{
return
{
customFormatterBody
:
global
.
structuredClone
(
body
.
return
.
unsafeDereference
(
)
)
}
;
}
}
catch
(
e
)
{
dump
(
{
e
}
\
n
)
;
}
finally
{
dbg
.
removeAllDebuggees
(
)
;
}
return
{
}
;
}
release
(
)
{
}
}
;
exports
.
ObjectActor
=
protocol
.
ActorClassWithSpec
(
objectSpec
proto
)
;
exports
.
ObjectActorProto
=
proto
;
function
safeGetOwnPropertyDescriptor
(
obj
name
)
{
let
desc
=
null
;
try
{
desc
=
obj
.
getOwnPropertyDescriptor
(
name
)
;
}
catch
(
ex
)
{
}
return
desc
;
}
function
isRejectedPromise
(
getterValue
)
{
return
(
getterValue
&
&
getterValue
.
class
=
=
"
Promise
"
&
&
getterValue
.
promiseState
=
=
"
rejected
"
)
;
}
