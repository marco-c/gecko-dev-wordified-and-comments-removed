"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
assert
}
=
DevToolsUtils
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
objectSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
object
"
)
;
loader
.
lazyRequireGetter
(
this
"
PropertyIteratorActor
"
"
devtools
/
server
/
actors
/
object
/
property
-
iterator
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
SymbolIteratorActor
"
"
devtools
/
server
/
actors
/
object
/
symbol
-
iterator
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
previewers
"
"
devtools
/
server
/
actors
/
object
/
previewers
"
)
;
loader
.
lazyRequireGetter
(
this
"
stringify
"
"
devtools
/
server
/
actors
/
object
/
stringifiers
"
)
;
const
{
getArrayLength
getPromiseState
getStorageLength
isArray
isStorage
isTypedArray
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
proto
=
{
initialize
(
obj
{
thread
createValueGrip
:
createValueGripHook
sources
createEnvironmentActor
getGripDepth
incrementGripDepth
decrementGripDepth
}
conn
)
{
assert
(
!
obj
.
optimizedOut
"
Should
not
create
object
actors
for
optimized
out
values
!
"
)
;
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
conn
=
conn
;
this
.
obj
=
obj
;
this
.
thread
=
thread
;
this
.
hooks
=
{
createValueGrip
:
createValueGripHook
sources
createEnvironmentActor
getGripDepth
incrementGripDepth
decrementGripDepth
}
;
this
.
_originalDescriptors
=
new
Map
(
)
;
}
rawValue
:
function
(
)
{
return
this
.
obj
.
unsafeDereference
(
)
;
}
addWatchpoint
(
property
label
watchpointType
)
{
this
.
thread
.
threadObjectGrip
(
this
)
;
if
(
this
.
_originalDescriptors
.
has
(
property
)
)
{
return
;
}
const
desc
=
this
.
obj
.
getOwnPropertyDescriptor
(
property
)
;
if
(
desc
.
set
|
|
desc
.
get
|
|
!
desc
.
configurable
)
{
return
;
}
this
.
_originalDescriptors
.
set
(
property
{
desc
watchpointType
}
)
;
const
pauseAndRespond
=
type
=
>
{
const
frame
=
this
.
thread
.
dbg
.
getNewestFrame
(
)
;
this
.
thread
.
_pauseAndRespond
(
frame
{
type
:
type
message
:
label
}
)
;
}
;
if
(
watchpointType
=
=
=
"
get
"
)
{
this
.
obj
.
defineProperty
(
property
{
configurable
:
desc
.
configurable
enumerable
:
desc
.
enumerable
set
:
this
.
obj
.
makeDebuggeeValue
(
v
=
>
{
desc
.
value
=
v
;
}
)
get
:
this
.
obj
.
makeDebuggeeValue
(
(
)
=
>
{
pauseAndRespond
(
"
getWatchpoint
"
)
;
return
desc
.
value
;
}
)
}
)
;
}
if
(
watchpointType
=
=
=
"
set
"
)
{
this
.
obj
.
defineProperty
(
property
{
configurable
:
desc
.
configurable
enumerable
:
desc
.
enumerable
set
:
this
.
obj
.
makeDebuggeeValue
(
v
=
>
{
pauseAndRespond
(
"
setWatchpoint
"
)
;
desc
.
value
=
v
;
}
)
get
:
this
.
obj
.
makeDebuggeeValue
(
v
=
>
{
return
desc
.
value
;
}
)
}
)
;
}
}
removeWatchpoint
(
property
)
{
if
(
!
this
.
_originalDescriptors
.
has
(
property
)
)
{
return
;
}
const
desc
=
this
.
_originalDescriptors
.
get
(
property
)
.
desc
;
this
.
_originalDescriptors
.
delete
(
property
)
;
this
.
obj
.
defineProperty
(
property
desc
)
;
}
removeWatchpoints
(
)
{
this
.
_originalDescriptors
.
forEach
(
property
=
>
this
.
removeWatchpoint
(
property
)
)
;
}
form
:
function
(
)
{
const
g
=
{
type
:
"
object
"
actor
:
this
.
actorID
}
;
if
(
DevToolsUtils
.
isCPOW
(
this
.
obj
)
)
{
g
.
class
=
"
CPOW
"
;
return
g
;
}
const
unwrapped
=
DevToolsUtils
.
unwrap
(
this
.
obj
)
;
if
(
unwrapped
=
=
=
undefined
)
{
g
.
class
=
"
InvisibleToDebugger
:
"
+
this
.
obj
.
class
;
return
g
;
}
if
(
unwrapped
&
&
unwrapped
.
isProxy
)
{
g
.
class
=
"
Proxy
"
;
this
.
hooks
.
incrementGripDepth
(
)
;
previewers
.
Proxy
[
0
]
(
this
g
null
)
;
this
.
hooks
.
decrementGripDepth
(
)
;
return
g
;
}
if
(
unwrapped
=
=
=
null
)
{
g
.
class
=
"
Restricted
"
;
}
else
{
g
.
class
=
this
.
obj
.
class
;
}
this
.
hooks
.
incrementGripDepth
(
)
;
g
.
extensible
=
this
.
obj
.
isExtensible
(
)
;
g
.
frozen
=
this
.
obj
.
isFrozen
(
)
;
g
.
sealed
=
this
.
obj
.
isSealed
(
)
;
if
(
g
.
class
=
=
"
Promise
"
)
{
g
.
promiseState
=
this
.
_createPromiseState
(
)
;
}
if
(
isTypedArray
(
g
)
)
{
g
.
ownPropertyLength
=
getArrayLength
(
this
.
obj
)
;
}
else
if
(
isStorage
(
g
)
)
{
g
.
ownPropertyLength
=
getStorageLength
(
this
.
obj
)
;
}
else
if
(
isReplaying
)
{
g
.
ownPropertyLength
=
this
.
obj
.
getOwnPropertyNamesCount
(
)
;
}
else
{
try
{
g
.
ownPropertyLength
=
this
.
obj
.
getOwnPropertyNames
(
)
.
length
;
}
catch
(
err
)
{
}
}
let
raw
=
this
.
obj
.
unsafeDereference
(
)
;
if
(
raw
&
&
Cu
)
{
raw
=
Cu
.
unwaiveXrays
(
raw
)
;
}
if
(
raw
&
&
!
DevToolsUtils
.
isSafeJSObject
(
raw
)
)
{
raw
=
null
;
}
for
(
const
fn
of
previewers
[
this
.
obj
.
class
]
|
|
previewers
.
Object
)
{
try
{
if
(
fn
(
this
g
raw
)
)
{
break
;
}
}
catch
(
e
)
{
const
msg
=
"
ObjectActor
.
prototype
.
grip
previewer
function
"
;
DevToolsUtils
.
reportException
(
msg
e
)
;
}
}
this
.
hooks
.
decrementGripDepth
(
)
;
return
g
;
}
_createPromiseState
:
function
(
)
{
const
{
state
value
reason
}
=
getPromiseState
(
this
.
obj
)
;
const
promiseState
=
{
state
}
;
if
(
state
=
=
"
fulfilled
"
)
{
promiseState
.
value
=
this
.
hooks
.
createValueGrip
(
value
)
;
}
else
if
(
state
=
=
"
rejected
"
)
{
promiseState
.
reason
=
this
.
hooks
.
createValueGrip
(
reason
)
;
}
promiseState
.
creationTimestamp
=
Date
.
now
(
)
-
this
.
obj
.
promiseLifetime
;
if
(
state
!
=
=
"
pending
"
)
{
promiseState
.
timeToSettle
=
this
.
obj
.
promiseTimeToResolution
;
}
return
promiseState
;
}
definitionSite
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
"
Function
"
)
{
return
this
.
throwError
(
"
objectNotFunction
"
this
.
actorID
+
"
is
not
a
function
.
"
)
;
}
if
(
!
this
.
obj
.
script
)
{
return
this
.
throwError
(
"
noScript
"
this
.
actorID
+
"
has
no
Debugger
.
Script
"
)
;
}
return
{
source
:
this
.
hooks
.
sources
(
)
.
createSourceActor
(
this
.
obj
.
script
.
source
)
line
:
this
.
obj
.
script
.
startLine
column
:
0
}
;
}
ownPropertyNames
:
function
(
)
{
let
props
=
[
]
;
if
(
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
try
{
props
=
this
.
obj
.
getOwnPropertyNames
(
)
;
}
catch
(
err
)
{
}
}
return
{
ownPropertyNames
:
props
}
;
}
enumProperties
:
function
(
options
)
{
return
PropertyIteratorActor
(
this
options
this
.
conn
)
;
}
enumEntries
:
function
(
)
{
return
PropertyIteratorActor
(
this
{
enumEntries
:
true
}
this
.
conn
)
;
}
enumSymbols
:
function
(
)
{
return
SymbolIteratorActor
(
this
this
.
conn
)
;
}
prototypeAndProperties
:
function
(
)
{
let
objProto
=
null
;
let
names
=
[
]
;
let
symbols
=
[
]
;
if
(
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
try
{
objProto
=
this
.
obj
.
proto
;
names
=
this
.
obj
.
getOwnPropertyNames
(
)
;
symbols
=
this
.
obj
.
getOwnPropertySymbols
(
)
;
}
catch
(
err
)
{
}
}
const
ownProperties
=
Object
.
create
(
null
)
;
const
ownSymbols
=
[
]
;
for
(
const
name
of
names
)
{
ownProperties
[
name
]
=
this
.
_propertyDescriptor
(
name
)
;
}
for
(
const
sym
of
symbols
)
{
ownSymbols
.
push
(
{
name
:
sym
.
toString
(
)
descriptor
:
this
.
_propertyDescriptor
(
sym
)
}
)
;
}
return
{
prototype
:
this
.
hooks
.
createValueGrip
(
objProto
)
ownProperties
ownSymbols
safeGetterValues
:
this
.
_findSafeGetterValues
(
names
)
}
;
}
_findSafeGetterValues
:
function
(
ownProperties
limit
=
0
)
{
const
safeGetterValues
=
Object
.
create
(
null
)
;
let
obj
=
this
.
obj
;
let
level
=
0
i
=
0
;
if
(
!
DevToolsUtils
.
isSafeDebuggerObject
(
obj
)
)
{
return
safeGetterValues
;
}
if
(
isArray
(
this
.
obj
)
|
|
[
"
Object
"
"
String
"
]
.
includes
(
this
.
obj
.
class
)
)
{
obj
=
obj
.
proto
;
level
+
+
;
}
while
(
obj
&
&
DevToolsUtils
.
isSafeDebuggerObject
(
obj
)
)
{
const
getters
=
this
.
_findSafeGetters
(
obj
)
;
for
(
const
name
of
getters
)
{
if
(
name
in
safeGetterValues
|
|
(
obj
!
=
this
.
obj
&
&
ownProperties
.
includes
(
name
)
)
)
{
continue
;
}
if
(
!
obj
.
proto
&
&
name
=
=
"
__proto__
"
)
{
continue
;
}
let
desc
=
null
getter
=
null
;
try
{
desc
=
obj
.
getOwnPropertyDescriptor
(
name
)
;
getter
=
desc
.
get
;
}
catch
(
ex
)
{
}
if
(
!
getter
)
{
obj
.
_safeGetters
=
null
;
continue
;
}
const
result
=
getter
.
call
(
this
.
obj
)
;
if
(
!
result
|
|
"
throw
"
in
result
)
{
continue
;
}
let
getterValue
=
undefined
;
if
(
"
return
"
in
result
)
{
getterValue
=
result
.
return
;
}
else
if
(
"
yield
"
in
result
)
{
getterValue
=
result
.
yield
;
}
if
(
getterValue
&
&
(
getterValue
.
class
=
=
"
Promise
"
&
&
getterValue
.
promiseState
=
=
"
rejected
"
)
)
{
const
raw
=
getterValue
.
unsafeDereference
(
)
;
if
(
DevToolsUtils
.
isSafeJSObject
(
raw
)
)
{
raw
.
catch
(
e
=
>
e
)
;
}
continue
;
}
if
(
getterValue
!
=
=
undefined
)
{
safeGetterValues
[
name
]
=
{
getterValue
:
this
.
hooks
.
createValueGrip
(
getterValue
)
getterPrototypeLevel
:
level
enumerable
:
desc
.
enumerable
writable
:
level
=
=
0
?
desc
.
writable
:
true
}
;
if
(
limit
&
&
+
+
i
=
=
limit
)
{
break
;
}
}
}
if
(
limit
&
&
i
=
=
limit
)
{
break
;
}
obj
=
obj
.
proto
;
level
+
+
;
}
return
safeGetterValues
;
}
_findSafeGetters
:
function
(
object
)
{
if
(
object
.
_safeGetters
)
{
return
object
.
_safeGetters
;
}
const
getters
=
new
Set
(
)
;
if
(
!
DevToolsUtils
.
isSafeDebuggerObject
(
object
)
)
{
object
.
_safeGetters
=
getters
;
return
getters
;
}
let
names
=
[
]
;
try
{
names
=
object
.
getOwnPropertyNames
(
)
;
}
catch
(
ex
)
{
}
for
(
const
name
of
names
)
{
let
desc
=
null
;
try
{
desc
=
object
.
getOwnPropertyDescriptor
(
name
)
;
}
catch
(
e
)
{
}
if
(
!
desc
|
|
desc
.
value
!
=
=
undefined
|
|
!
(
"
get
"
in
desc
)
)
{
continue
;
}
if
(
DevToolsUtils
.
hasSafeGetter
(
desc
)
)
{
getters
.
add
(
name
)
;
}
}
object
.
_safeGetters
=
getters
;
return
getters
;
}
prototype
:
function
(
)
{
let
objProto
=
null
;
if
(
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
objProto
=
this
.
obj
.
proto
;
}
return
{
prototype
:
this
.
hooks
.
createValueGrip
(
objProto
)
}
;
}
property
:
function
(
name
)
{
if
(
!
name
)
{
return
this
.
throwError
(
"
missingParameter
"
"
no
property
name
was
specified
"
)
;
}
return
{
descriptor
:
this
.
_propertyDescriptor
(
name
)
}
;
}
propertyValue
:
function
(
name
receiverId
)
{
if
(
!
name
)
{
return
this
.
throwError
(
"
missingParameter
"
"
no
property
name
was
specified
"
)
;
}
let
receiver
;
if
(
receiverId
)
{
const
receiverActor
=
this
.
conn
.
getActor
(
receiverId
)
;
if
(
receiverActor
)
{
receiver
=
receiverActor
.
obj
;
}
}
const
value
=
receiver
?
this
.
obj
.
getProperty
(
name
receiver
)
:
this
.
obj
.
getProperty
(
name
)
;
return
{
value
:
this
.
_buildCompletion
(
value
)
}
;
}
apply
:
function
(
context
args
)
{
if
(
!
this
.
obj
.
callable
)
{
return
this
.
throwError
(
"
notCallable
"
"
debugee
object
is
not
callable
"
)
;
}
const
debugeeContext
=
this
.
_getValueFromGrip
(
context
)
;
const
debugeeArgs
=
args
&
&
args
.
map
(
this
.
_getValueFromGrip
this
)
;
const
value
=
this
.
obj
.
apply
(
debugeeContext
debugeeArgs
)
;
return
{
value
:
this
.
_buildCompletion
(
value
)
}
;
}
_getValueFromGrip
(
grip
)
{
if
(
typeof
grip
!
=
=
"
object
"
|
|
!
grip
)
{
return
grip
;
}
if
(
typeof
grip
.
actor
!
=
=
"
string
"
)
{
return
this
.
throwError
(
"
invalidGrip
"
"
grip
argument
did
not
include
actor
ID
"
)
;
}
const
actor
=
this
.
conn
.
getActor
(
grip
.
actor
)
;
if
(
!
actor
)
{
return
this
.
throwError
(
"
unknownActor
"
"
grip
actor
did
not
match
a
known
object
"
)
;
}
return
actor
.
obj
;
}
_buildCompletion
(
value
)
{
let
completionGrip
=
null
;
if
(
value
)
{
completionGrip
=
{
}
;
if
(
"
return
"
in
value
)
{
completionGrip
.
return
=
this
.
hooks
.
createValueGrip
(
value
.
return
)
;
}
if
(
"
throw
"
in
value
)
{
completionGrip
.
throw
=
this
.
hooks
.
createValueGrip
(
value
.
throw
)
;
}
}
return
completionGrip
;
}
displayString
:
function
(
)
{
const
string
=
stringify
(
this
.
obj
)
;
return
{
displayString
:
this
.
hooks
.
createValueGrip
(
string
)
}
;
}
_propertyDescriptor
:
function
(
name
onlyEnumerable
)
{
if
(
!
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
return
undefined
;
}
let
desc
;
try
{
desc
=
this
.
obj
.
getOwnPropertyDescriptor
(
name
)
;
}
catch
(
e
)
{
return
{
configurable
:
false
writable
:
false
enumerable
:
false
value
:
e
.
name
}
;
}
if
(
isStorage
(
this
.
obj
)
)
{
if
(
name
=
=
=
"
length
"
)
{
return
undefined
;
}
return
desc
;
}
if
(
!
desc
|
|
(
onlyEnumerable
&
&
!
desc
.
enumerable
)
)
{
return
undefined
;
}
const
retval
=
{
configurable
:
desc
.
configurable
enumerable
:
desc
.
enumerable
}
;
if
(
"
value
"
in
desc
)
{
retval
.
writable
=
desc
.
writable
;
retval
.
value
=
this
.
hooks
.
createValueGrip
(
desc
.
value
)
;
}
else
if
(
this
.
_originalDescriptors
.
has
(
name
)
)
{
const
watchpointType
=
this
.
_originalDescriptors
.
get
(
name
)
.
watchpointType
;
desc
=
this
.
_originalDescriptors
.
get
(
name
)
.
desc
;
retval
.
value
=
this
.
hooks
.
createValueGrip
(
desc
.
value
)
;
retval
.
watchpoint
=
watchpointType
;
}
else
{
if
(
"
get
"
in
desc
)
{
retval
.
get
=
this
.
hooks
.
createValueGrip
(
desc
.
get
)
;
}
if
(
"
set
"
in
desc
)
{
retval
.
set
=
this
.
hooks
.
createValueGrip
(
desc
.
set
)
;
}
}
return
retval
;
}
decompile
:
function
(
pretty
)
{
if
(
this
.
obj
.
class
!
=
=
"
Function
"
)
{
return
this
.
throwError
(
"
objectNotFunction
"
"
decompile
request
is
only
valid
for
grips
with
a
'
Function
'
class
.
"
)
;
}
return
{
decompiledCode
:
this
.
obj
.
decompile
(
!
!
pretty
)
}
;
}
parameterNames
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
=
"
Function
"
)
{
return
this
.
throwError
(
"
objectNotFunction
"
"
'
parameterNames
'
request
is
only
valid
for
grips
with
a
'
Function
'
class
.
"
)
;
}
return
{
parameterNames
:
this
.
obj
.
parameterNames
}
;
}
scope
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
=
"
Function
"
)
{
return
this
.
throwError
(
"
objectNotFunction
"
"
scope
request
is
only
valid
for
grips
with
a
'
Function
'
class
.
"
)
;
}
const
{
createEnvironmentActor
}
=
this
.
hooks
;
const
envActor
=
createEnvironmentActor
(
this
.
obj
.
environment
this
.
registeredPool
)
;
if
(
!
envActor
)
{
return
this
.
throwError
(
"
notDebuggee
"
"
cannot
access
the
environment
of
this
function
.
"
)
;
}
return
{
scope
:
envActor
}
;
}
dependentPromises
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
"
Promise
"
)
{
return
this
.
throwError
(
"
objectNotPromise
"
"
'
dependentPromises
'
request
is
only
valid
for
grips
with
a
'
Promise
'
class
.
"
)
;
}
const
promises
=
this
.
obj
.
promiseDependentPromises
.
map
(
p
=
>
this
.
hooks
.
createValueGrip
(
p
)
)
;
return
{
promises
}
;
}
allocationStack
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
"
Promise
"
)
{
return
this
.
throwError
(
"
objectNotPromise
"
"
'
allocationStack
'
request
is
only
valid
for
grips
with
a
'
Promise
'
class
.
"
)
;
}
let
stack
=
this
.
obj
.
promiseAllocationSite
;
const
allocationStacks
=
[
]
;
while
(
stack
)
{
if
(
stack
.
source
)
{
const
source
=
this
.
_getSourceOriginalLocation
(
stack
)
;
if
(
source
)
{
allocationStacks
.
push
(
source
)
;
}
}
stack
=
stack
.
parent
;
}
return
Promise
.
all
(
allocationStacks
)
;
}
fulfillmentStack
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
"
Promise
"
)
{
return
this
.
throwError
(
"
objectNotPromise
"
"
'
fulfillmentStack
'
request
is
only
valid
for
grips
with
a
'
Promise
'
class
.
"
)
;
}
let
stack
=
this
.
obj
.
promiseResolutionSite
;
const
fulfillmentStacks
=
[
]
;
while
(
stack
)
{
if
(
stack
.
source
)
{
const
source
=
this
.
_getSourceOriginalLocation
(
stack
)
;
if
(
source
)
{
fulfillmentStacks
.
push
(
source
)
;
}
}
stack
=
stack
.
parent
;
}
return
Promise
.
all
(
fulfillmentStacks
)
;
}
rejectionStack
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
"
Promise
"
)
{
return
this
.
throwError
(
"
objectNotPromise
"
"
'
rejectionStack
'
request
is
only
valid
for
grips
with
a
'
Promise
'
class
.
"
)
;
}
let
stack
=
this
.
obj
.
promiseResolutionSite
;
const
rejectionStacks
=
[
]
;
while
(
stack
)
{
if
(
stack
.
source
)
{
const
source
=
this
.
_getSourceOriginalLocation
(
stack
)
;
if
(
source
)
{
rejectionStacks
.
push
(
source
)
;
}
}
stack
=
stack
.
parent
;
}
return
Promise
.
all
(
rejectionStacks
)
;
}
_getSourceOriginalLocation
:
function
(
stack
)
{
let
source
;
try
{
source
=
this
.
hooks
.
sources
(
)
.
getSourceActorsByURL
(
stack
.
source
)
[
0
]
;
}
catch
(
e
)
{
}
if
(
!
source
)
{
return
null
;
}
return
{
source
line
:
stack
.
line
column
:
stack
.
column
functionDisplayName
:
stack
.
functionDisplayName
}
;
}
proxySlots
:
function
(
)
{
const
unwrapped
=
DevToolsUtils
.
unwrap
(
this
.
obj
)
;
if
(
!
unwrapped
|
|
!
unwrapped
.
isProxy
)
{
return
this
.
throwError
(
"
objectNotProxy
"
"
'
proxySlots
'
request
is
only
valid
for
grips
with
a
'
Proxy
'
class
.
"
)
;
}
return
{
proxyTarget
:
this
.
hooks
.
createValueGrip
(
this
.
obj
.
proxyTarget
)
proxyHandler
:
this
.
hooks
.
createValueGrip
(
this
.
obj
.
proxyHandler
)
}
;
}
release
:
function
(
)
{
this
.
removeWatchpoints
(
)
;
}
}
;
exports
.
ObjectActor
=
protocol
.
ActorClassWithSpec
(
objectSpec
proto
)
;
exports
.
ObjectActorProto
=
proto
;
