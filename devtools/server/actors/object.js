"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
/
Actor
.
js
"
)
;
const
{
objectSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
object
.
js
"
)
;
const
DevToolsUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
{
assert
}
=
DevToolsUtils
;
loader
.
lazyRequireGetter
(
this
"
propertyDescriptor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
property
-
descriptor
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
PropertyIteratorActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
property
-
iterator
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
SymbolIteratorActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
symbol
-
iterator
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
PrivatePropertiesIteratorActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
private
-
properties
-
iterator
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
previewers
"
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
previewers
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
customFormatterHeader
"
"
customFormatterBody
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
custom
-
formatters
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
unsafeGettersNames
"
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
webidl
-
unsafe
-
getters
-
names
.
js
"
)
;
const
lazy
=
{
}
;
if
(
!
isWorker
)
{
loader
.
lazyGetter
(
lazy
"
ContentDOMReference
"
(
)
=
>
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ContentDOMReference
.
sys
.
mjs
"
{
global
:
"
shared
"
}
)
.
ContentDOMReference
)
;
}
const
{
getArrayLength
getPromiseState
getStorageLength
isArray
isStorage
isTypedArray
createValueGrip
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
utils
.
js
"
)
;
class
ObjectActor
extends
Actor
{
constructor
(
threadActor
obj
{
customFormatterObjectTagDepth
customFormatterConfigDbgObj
allowSideEffect
=
true
}
)
{
super
(
threadActor
.
conn
objectSpec
)
;
assert
(
!
obj
.
optimizedOut
"
Should
not
create
object
actors
for
optimized
out
values
!
"
)
;
this
.
obj
=
obj
;
this
.
targetActor
=
threadActor
.
targetActor
;
this
.
threadActor
=
threadActor
;
this
.
rawObj
=
obj
.
unsafeDereference
(
)
;
this
.
safeRawObj
=
this
.
#
getSafeRawObject
(
)
;
this
.
allowSideEffect
=
allowSideEffect
;
this
.
className
=
this
.
obj
.
class
;
this
.
hooks
=
{
customFormatterObjectTagDepth
customFormatterConfigDbgObj
}
;
}
addWatchpoint
(
property
label
watchpointType
)
{
this
.
threadActor
.
addWatchpoint
(
this
{
property
label
watchpointType
}
)
;
}
removeWatchpoint
(
property
)
{
this
.
threadActor
.
removeWatchpoint
(
this
property
)
;
}
removeWatchpoints
(
)
{
this
.
threadActor
.
removeWatchpoint
(
this
)
;
}
createValueGrip
(
value
depth
)
{
if
(
typeof
depth
!
=
"
number
"
)
{
throw
new
Error
(
"
Missing
'
depth
'
argument
to
createValeuGrip
(
)
"
)
;
}
return
createValueGrip
(
this
.
threadActor
value
this
.
getParent
(
)
depth
this
.
hooks
)
;
}
form
(
{
depth
=
0
}
=
{
}
)
{
const
g
=
{
type
:
"
object
"
actor
:
this
.
actorID
}
;
const
unwrapped
=
DevToolsUtils
.
unwrap
(
this
.
obj
)
;
if
(
unwrapped
=
=
=
undefined
)
{
g
.
class
=
"
InvisibleToDebugger
:
"
+
this
.
className
;
return
g
;
}
if
(
this
.
threadActor
?
.
targetActor
?
.
customFormatters
)
{
const
result
=
customFormatterHeader
(
this
)
;
if
(
result
)
{
const
{
formatter
.
.
.
header
}
=
result
;
this
.
_customFormatterItem
=
formatter
;
return
{
.
.
.
g
.
.
.
header
}
;
}
}
if
(
unwrapped
?
.
isProxy
)
{
g
.
class
=
"
Proxy
"
;
previewers
.
Proxy
[
0
]
(
this
g
depth
+
1
)
;
return
g
;
}
const
ownPropertyLength
=
this
.
_getOwnPropertyLength
(
)
;
Object
.
assign
(
g
{
class
:
unwrapped
=
=
=
null
?
"
Restricted
"
:
this
.
className
ownPropertyLength
:
Number
.
isFinite
(
ownPropertyLength
)
?
ownPropertyLength
:
undefined
extensible
:
this
.
obj
.
isExtensible
(
)
frozen
:
this
.
obj
.
isFrozen
(
)
sealed
:
this
.
obj
.
isSealed
(
)
isError
:
this
.
obj
.
isError
}
)
;
if
(
g
.
class
=
=
"
Function
"
)
{
g
.
isClassConstructor
=
this
.
obj
.
isClassConstructor
;
}
this
.
_populateGripPreview
(
g
depth
+
1
)
;
if
(
this
.
safeRawObj
&
&
Node
.
isInstance
(
this
.
safeRawObj
)
&
&
lazy
.
ContentDOMReference
)
{
try
{
g
.
contentDomReference
=
lazy
.
ContentDOMReference
.
get
(
this
.
safeRawObj
)
;
}
catch
(
e
)
{
}
}
return
g
;
}
customFormatterBody
(
)
{
return
customFormatterBody
(
this
this
.
_customFormatterItem
)
;
}
_getOwnPropertyLength
(
)
{
if
(
isTypedArray
(
this
.
obj
)
)
{
return
getArrayLength
(
this
.
obj
)
;
}
if
(
isStorage
(
this
.
obj
)
)
{
return
getStorageLength
(
this
.
obj
)
;
}
try
{
return
this
.
obj
.
getOwnPropertyNamesLength
(
)
;
}
catch
(
err
)
{
}
return
null
;
}
#
getSafeRawObject
(
)
{
let
raw
=
this
.
rawObj
;
if
(
raw
&
&
Cu
)
{
raw
=
Cu
.
unwaiveXrays
(
raw
)
;
}
if
(
raw
&
&
!
DevToolsUtils
.
isSafeJSObject
(
raw
)
)
{
raw
=
null
;
}
return
raw
;
}
_populateGripPreview
(
grip
depth
)
{
for
(
const
previewer
of
previewers
[
this
.
className
]
|
|
previewers
.
Object
)
{
try
{
const
previewerResult
=
previewer
(
this
grip
depth
)
;
if
(
previewerResult
)
{
return
;
}
}
catch
(
e
)
{
const
msg
=
"
ObjectActor
.
prototype
.
_populateGripPreview
previewer
function
"
;
DevToolsUtils
.
reportException
(
msg
e
)
;
}
}
}
promiseState
(
)
{
const
{
state
value
reason
}
=
getPromiseState
(
this
.
obj
)
;
const
promiseState
=
{
state
}
;
if
(
state
=
=
"
fulfilled
"
)
{
promiseState
.
value
=
this
.
createValueGrip
(
value
0
)
;
}
else
if
(
state
=
=
"
rejected
"
)
{
promiseState
.
reason
=
this
.
createValueGrip
(
reason
0
)
;
}
promiseState
.
creationTimestamp
=
Date
.
now
(
)
-
this
.
obj
.
promiseLifetime
;
if
(
state
!
=
=
"
pending
"
)
{
promiseState
.
timeToSettle
=
this
.
obj
.
promiseTimeToResolution
;
}
return
{
promiseState
}
;
}
enumProperties
(
options
)
{
return
new
PropertyIteratorActor
(
this
options
this
.
conn
)
;
}
enumEntries
(
)
{
return
new
PropertyIteratorActor
(
this
{
enumEntries
:
true
}
this
.
conn
)
;
}
enumSymbols
(
)
{
return
new
SymbolIteratorActor
(
this
this
.
conn
)
;
}
enumPrivateProperties
(
)
{
return
new
PrivatePropertiesIteratorActor
(
this
this
.
conn
)
;
}
prototypeAndProperties
(
)
{
let
objProto
=
null
;
let
names
=
[
]
;
let
symbols
=
[
]
;
if
(
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
try
{
objProto
=
this
.
obj
.
proto
;
names
=
this
.
obj
.
getOwnPropertyNames
(
)
;
symbols
=
this
.
obj
.
getOwnPropertySymbols
(
)
;
}
catch
(
err
)
{
}
}
const
ownProperties
=
Object
.
create
(
null
)
;
const
ownSymbols
=
[
]
;
for
(
const
name
of
names
)
{
ownProperties
[
name
]
=
propertyDescriptor
(
this
name
0
)
;
}
for
(
const
sym
of
symbols
)
{
ownSymbols
.
push
(
{
name
:
sym
.
toString
(
)
descriptor
:
propertyDescriptor
(
this
sym
0
)
}
)
;
}
return
{
prototype
:
this
.
createValueGrip
(
objProto
0
)
ownProperties
ownSymbols
safeGetterValues
:
this
.
_findSafeGetterValues
(
names
0
)
}
;
}
_findSafeGetterValues
(
ownProperties
depth
limit
=
Infinity
)
{
const
safeGetterValues
=
Object
.
create
(
null
)
;
let
obj
=
this
.
obj
;
let
level
=
0
currentGetterValuesCount
=
0
;
if
(
!
DevToolsUtils
.
isSafeDebuggerObject
(
obj
)
)
{
return
safeGetterValues
;
}
if
(
this
.
className
=
=
"
Object
"
|
|
this
.
className
=
=
"
String
"
|
|
isArray
(
this
.
obj
)
)
{
obj
=
obj
.
proto
;
level
+
+
;
}
while
(
obj
&
&
DevToolsUtils
.
isSafeDebuggerObject
(
obj
)
)
{
for
(
const
name
of
this
.
_findSafeGetters
(
obj
)
)
{
if
(
name
in
safeGetterValues
|
|
(
obj
!
=
this
.
obj
&
&
ownProperties
.
includes
(
name
)
)
)
{
continue
;
}
if
(
!
obj
.
proto
&
&
name
=
=
"
__proto__
"
)
{
continue
;
}
const
desc
=
safeGetOwnPropertyDescriptor
(
obj
name
)
;
if
(
!
desc
?
.
get
)
{
obj
.
_safeGetters
=
null
;
continue
;
}
const
getterValue
=
this
.
_evaluateGetter
(
desc
.
get
)
;
if
(
getterValue
=
=
=
undefined
)
{
continue
;
}
if
(
isRejectedPromise
(
getterValue
)
)
{
const
raw
=
getterValue
.
unsafeDereference
(
)
;
if
(
DevToolsUtils
.
isSafeJSObject
(
raw
)
)
{
raw
.
catch
(
e
=
>
e
)
;
}
continue
;
}
safeGetterValues
[
name
]
=
{
getterValue
:
this
.
createValueGrip
(
getterValue
depth
)
getterPrototypeLevel
:
level
enumerable
:
desc
.
enumerable
writable
:
level
=
=
0
?
desc
.
writable
:
true
}
;
+
+
currentGetterValuesCount
;
if
(
currentGetterValuesCount
=
=
limit
)
{
return
safeGetterValues
;
}
}
obj
=
obj
.
proto
;
level
+
+
;
}
return
safeGetterValues
;
}
_evaluateGetter
(
getter
)
{
const
result
=
getter
.
call
(
this
.
obj
)
;
if
(
!
result
|
|
"
throw
"
in
result
)
{
return
undefined
;
}
let
getterValue
=
undefined
;
if
(
"
return
"
in
result
)
{
getterValue
=
result
.
return
;
}
else
if
(
"
yield
"
in
result
)
{
getterValue
=
result
.
yield
;
}
return
getterValue
;
}
_findSafeGetters
(
object
)
{
if
(
object
.
_safeGetters
)
{
return
object
.
_safeGetters
;
}
const
getters
=
new
Set
(
)
;
if
(
!
DevToolsUtils
.
isSafeDebuggerObject
(
object
)
)
{
object
.
_safeGetters
=
getters
;
return
getters
;
}
let
names
=
[
]
;
try
{
names
=
object
.
getOwnPropertyNames
(
)
;
}
catch
(
ex
)
{
}
for
(
const
name
of
names
)
{
let
desc
=
null
;
try
{
desc
=
object
.
getOwnPropertyDescriptor
(
name
)
;
}
catch
(
e
)
{
}
if
(
!
desc
|
|
desc
.
value
!
=
=
undefined
|
|
!
(
"
get
"
in
desc
)
)
{
continue
;
}
if
(
DevToolsUtils
.
hasSafeGetter
(
desc
)
&
&
!
unsafeGettersNames
.
includes
(
name
)
)
{
getters
.
add
(
name
)
;
}
}
object
.
_safeGetters
=
getters
;
return
getters
;
}
prototype
(
)
{
let
objProto
=
null
;
if
(
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
objProto
=
this
.
obj
.
proto
;
}
return
{
prototype
:
this
.
createValueGrip
(
objProto
0
)
}
;
}
property
(
name
)
{
if
(
!
name
)
{
return
this
.
throwError
(
"
missingParameter
"
"
no
property
name
was
specified
"
)
;
}
return
{
descriptor
:
propertyDescriptor
(
this
name
0
)
}
;
}
propertyValue
(
name
receiverId
)
{
if
(
!
name
)
{
return
this
.
throwError
(
"
missingParameter
"
"
no
property
name
was
specified
"
)
;
}
let
receiver
;
if
(
receiverId
)
{
const
receiverActor
=
this
.
conn
.
getActor
(
receiverId
)
;
if
(
receiverActor
)
{
receiver
=
receiverActor
.
obj
;
}
}
const
value
=
receiver
?
this
.
obj
.
getProperty
(
name
receiver
)
:
this
.
obj
.
getProperty
(
name
)
;
return
{
value
:
this
.
_buildCompletion
(
value
)
}
;
}
apply
(
context
args
)
{
if
(
!
this
.
obj
.
callable
)
{
return
this
.
throwError
(
"
notCallable
"
"
debugee
object
is
not
callable
"
)
;
}
const
debugeeContext
=
this
.
_getValueFromGrip
(
context
)
;
const
debugeeArgs
=
args
&
&
args
.
map
(
this
.
_getValueFromGrip
this
)
;
const
value
=
this
.
obj
.
apply
(
debugeeContext
debugeeArgs
)
;
return
{
value
:
this
.
_buildCompletion
(
value
)
}
;
}
_getValueFromGrip
(
grip
)
{
if
(
typeof
grip
!
=
=
"
object
"
|
|
!
grip
)
{
return
grip
;
}
if
(
typeof
grip
.
actor
!
=
=
"
string
"
)
{
return
this
.
throwError
(
"
invalidGrip
"
"
grip
argument
did
not
include
actor
ID
"
)
;
}
const
actor
=
this
.
conn
.
getActor
(
grip
.
actor
)
;
if
(
!
actor
)
{
return
this
.
throwError
(
"
unknownActor
"
"
grip
actor
did
not
match
a
known
object
"
)
;
}
return
actor
.
obj
;
}
_buildCompletion
(
value
)
{
let
completionGrip
=
null
;
if
(
value
)
{
completionGrip
=
{
}
;
if
(
"
return
"
in
value
)
{
completionGrip
.
return
=
this
.
createValueGrip
(
value
.
return
0
)
;
}
if
(
"
throw
"
in
value
)
{
completionGrip
.
throw
=
this
.
createValueGrip
(
value
.
throw
0
)
;
}
}
return
completionGrip
;
}
proxySlots
(
)
{
const
unwrapped
=
DevToolsUtils
.
unwrap
(
this
.
obj
)
;
if
(
!
unwrapped
|
|
!
unwrapped
.
isProxy
)
{
return
this
.
throwError
(
"
objectNotProxy
"
"
'
proxySlots
'
request
is
only
valid
for
grips
with
a
'
Proxy
'
class
.
"
)
;
}
return
{
proxyTarget
:
this
.
createValueGrip
(
this
.
obj
.
proxyTarget
0
)
proxyHandler
:
this
.
createValueGrip
(
this
.
obj
.
proxyHandler
0
)
}
;
}
release
(
)
{
if
(
this
.
hooks
)
{
this
.
hooks
.
customFormatterConfigDbgObj
=
null
;
}
this
.
_customFormatterItem
=
null
;
this
.
obj
=
null
;
this
.
rawObj
=
null
;
this
.
safeRawObj
=
null
;
this
.
threadActor
=
null
;
}
}
exports
.
ObjectActor
=
ObjectActor
;
function
safeGetOwnPropertyDescriptor
(
obj
name
)
{
let
desc
=
null
;
try
{
desc
=
obj
.
getOwnPropertyDescriptor
(
name
)
;
}
catch
(
ex
)
{
}
return
desc
;
}
function
isRejectedPromise
(
getterValue
)
{
return
(
getterValue
&
&
getterValue
.
class
=
=
"
Promise
"
&
&
getterValue
.
promiseState
=
=
"
rejected
"
)
;
}
