"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
{
GeneratedLocation
}
=
require
(
"
devtools
/
server
/
actors
/
common
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
assert
}
=
DevToolsUtils
;
loader
.
lazyRequireGetter
(
this
"
PropertyIteratorActor
"
"
devtools
/
server
/
actors
/
object
/
property
-
iterator
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
SymbolIteratorActor
"
"
devtools
/
server
/
actors
/
object
/
symbol
-
iterator
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
previewers
"
"
devtools
/
server
/
actors
/
object
/
previewers
"
)
;
loader
.
lazyRequireGetter
(
this
"
stringify
"
"
devtools
/
server
/
actors
/
object
/
stringifiers
"
)
;
const
{
getArrayLength
getPromiseState
isArray
isTypedArray
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
function
ObjectActor
(
obj
{
createValueGrip
:
createValueGripHook
sources
createEnvironmentActor
getGripDepth
incrementGripDepth
decrementGripDepth
getGlobalDebugObject
}
)
{
assert
(
!
obj
.
optimizedOut
"
Should
not
create
object
actors
for
optimized
out
values
!
"
)
;
this
.
obj
=
obj
;
this
.
hooks
=
{
createValueGrip
:
createValueGripHook
sources
createEnvironmentActor
getGripDepth
incrementGripDepth
decrementGripDepth
getGlobalDebugObject
}
;
this
.
iterators
=
new
Set
(
)
;
}
ObjectActor
.
prototype
=
{
actorPrefix
:
"
obj
"
rawValue
:
function
(
)
{
return
this
.
obj
.
unsafeDereference
(
)
;
}
grip
:
function
(
)
{
let
g
=
{
"
type
"
:
"
object
"
"
actor
"
:
this
.
actorID
"
class
"
:
this
.
obj
.
class
}
;
let
unwrapped
=
DevToolsUtils
.
unwrap
(
this
.
obj
)
;
if
(
!
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
if
(
DevToolsUtils
.
isCPOW
(
this
.
obj
)
)
{
g
.
class
=
"
CPOW
:
"
+
g
.
class
;
}
else
if
(
unwrapped
=
=
=
undefined
)
{
g
.
class
=
"
InvisibleToDebugger
:
"
+
g
.
class
;
}
else
if
(
unwrapped
.
isProxy
)
{
g
.
class
=
"
Proxy
"
;
this
.
hooks
.
incrementGripDepth
(
)
;
previewers
.
Proxy
[
0
]
(
this
g
null
)
;
this
.
hooks
.
decrementGripDepth
(
)
;
}
return
g
;
}
if
(
unwrapped
=
=
=
null
)
{
g
.
class
=
"
Restricted
"
;
}
this
.
hooks
.
incrementGripDepth
(
)
;
g
.
extensible
=
this
.
obj
.
isExtensible
(
)
;
g
.
frozen
=
this
.
obj
.
isFrozen
(
)
;
g
.
sealed
=
this
.
obj
.
isSealed
(
)
;
if
(
g
.
class
=
=
"
Promise
"
)
{
g
.
promiseState
=
this
.
_createPromiseState
(
)
;
}
if
(
isTypedArray
(
g
)
)
{
g
.
ownPropertyLength
=
getArrayLength
(
this
.
obj
)
;
}
else
{
try
{
g
.
ownPropertyLength
=
this
.
obj
.
getOwnPropertyNames
(
)
.
length
;
}
catch
(
err
)
{
}
}
let
raw
=
this
.
obj
.
unsafeDereference
(
)
;
if
(
Cu
)
{
raw
=
Cu
.
unwaiveXrays
(
raw
)
;
}
if
(
!
DevToolsUtils
.
isSafeJSObject
(
raw
)
)
{
raw
=
null
;
}
for
(
let
fn
of
previewers
[
this
.
obj
.
class
]
|
|
previewers
.
Object
)
{
try
{
if
(
fn
(
this
g
raw
)
)
{
break
;
}
}
catch
(
e
)
{
let
msg
=
"
ObjectActor
.
prototype
.
grip
previewer
function
"
;
DevToolsUtils
.
reportException
(
msg
e
)
;
}
}
this
.
hooks
.
decrementGripDepth
(
)
;
return
g
;
}
_createPromiseState
:
function
(
)
{
const
{
state
value
reason
}
=
getPromiseState
(
this
.
obj
)
;
let
promiseState
=
{
state
}
;
if
(
state
=
=
"
fulfilled
"
)
{
promiseState
.
value
=
this
.
hooks
.
createValueGrip
(
value
)
;
}
else
if
(
state
=
=
"
rejected
"
)
{
promiseState
.
reason
=
this
.
hooks
.
createValueGrip
(
reason
)
;
}
promiseState
.
creationTimestamp
=
Date
.
now
(
)
-
this
.
obj
.
promiseLifetime
;
if
(
state
!
=
=
"
pending
"
)
{
promiseState
.
timeToSettle
=
this
.
obj
.
promiseTimeToResolution
;
}
return
promiseState
;
}
release
:
function
(
)
{
if
(
this
.
registeredPool
.
objectActors
)
{
this
.
registeredPool
.
objectActors
.
delete
(
this
.
obj
)
;
}
this
.
iterators
.
forEach
(
actor
=
>
this
.
registeredPool
.
removeActor
(
actor
)
)
;
this
.
iterators
.
clear
(
)
;
this
.
registeredPool
.
removeActor
(
this
)
;
}
onDefinitionSite
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
"
Function
"
)
{
return
{
from
:
this
.
actorID
error
:
"
objectNotFunction
"
message
:
this
.
actorID
+
"
is
not
a
function
.
"
}
;
}
if
(
!
this
.
obj
.
script
)
{
return
{
from
:
this
.
actorID
error
:
"
noScript
"
message
:
this
.
actorID
+
"
has
no
Debugger
.
Script
"
}
;
}
return
this
.
hooks
.
sources
(
)
.
getOriginalLocation
(
new
GeneratedLocation
(
this
.
hooks
.
sources
(
)
.
createNonSourceMappedActor
(
this
.
obj
.
script
.
source
)
this
.
obj
.
script
.
startLine
0
)
)
.
then
(
(
originalLocation
)
=
>
{
return
{
source
:
originalLocation
.
originalSourceActor
.
form
(
)
line
:
originalLocation
.
originalLine
column
:
originalLocation
.
originalColumn
}
;
}
)
;
}
onOwnPropertyNames
:
function
(
)
{
let
props
=
[
]
;
if
(
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
try
{
props
=
this
.
obj
.
getOwnPropertyNames
(
)
;
}
catch
(
err
)
{
}
}
return
{
from
:
this
.
actorID
ownPropertyNames
:
props
}
;
}
onEnumProperties
:
function
(
request
)
{
let
actor
=
new
PropertyIteratorActor
(
this
request
.
options
)
;
this
.
registeredPool
.
addActor
(
actor
)
;
this
.
iterators
.
add
(
actor
)
;
return
{
iterator
:
actor
.
grip
(
)
}
;
}
onEnumEntries
:
function
(
)
{
let
actor
=
new
PropertyIteratorActor
(
this
{
enumEntries
:
true
}
)
;
this
.
registeredPool
.
addActor
(
actor
)
;
this
.
iterators
.
add
(
actor
)
;
return
{
iterator
:
actor
.
grip
(
)
}
;
}
onEnumSymbols
:
function
(
)
{
let
actor
=
new
SymbolIteratorActor
(
this
)
;
this
.
registeredPool
.
addActor
(
actor
)
;
this
.
iterators
.
add
(
actor
)
;
return
{
iterator
:
actor
.
grip
(
)
}
;
}
onPrototypeAndProperties
:
function
(
)
{
let
proto
=
null
;
let
names
=
[
]
;
let
symbols
=
[
]
;
if
(
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
try
{
proto
=
this
.
obj
.
proto
;
names
=
this
.
obj
.
getOwnPropertyNames
(
)
;
symbols
=
this
.
obj
.
getOwnPropertySymbols
(
)
;
}
catch
(
err
)
{
}
}
let
ownProperties
=
Object
.
create
(
null
)
;
let
ownSymbols
=
[
]
;
for
(
let
name
of
names
)
{
ownProperties
[
name
]
=
this
.
_propertyDescriptor
(
name
)
;
}
for
(
let
sym
of
symbols
)
{
ownSymbols
.
push
(
{
name
:
sym
.
toString
(
)
descriptor
:
this
.
_propertyDescriptor
(
sym
)
}
)
;
}
return
{
from
:
this
.
actorID
prototype
:
this
.
hooks
.
createValueGrip
(
proto
)
ownProperties
ownSymbols
safeGetterValues
:
this
.
_findSafeGetterValues
(
names
)
}
;
}
_findSafeGetterValues
:
function
(
ownProperties
limit
=
0
)
{
let
safeGetterValues
=
Object
.
create
(
null
)
;
let
obj
=
this
.
obj
;
let
level
=
0
i
=
0
;
if
(
!
DevToolsUtils
.
isSafeDebuggerObject
(
obj
)
)
{
return
safeGetterValues
;
}
if
(
isArray
(
this
.
obj
)
|
|
[
"
Object
"
"
String
"
]
.
includes
(
this
.
obj
.
class
)
)
{
obj
=
obj
.
proto
;
level
+
+
;
}
while
(
obj
&
&
DevToolsUtils
.
isSafeDebuggerObject
(
obj
)
)
{
let
getters
=
this
.
_findSafeGetters
(
obj
)
;
for
(
let
name
of
getters
)
{
if
(
name
in
safeGetterValues
|
|
(
obj
!
=
this
.
obj
&
&
ownProperties
.
includes
(
name
)
)
)
{
continue
;
}
if
(
!
obj
.
proto
&
&
name
=
=
"
__proto__
"
)
{
continue
;
}
let
desc
=
null
getter
=
null
;
try
{
desc
=
obj
.
getOwnPropertyDescriptor
(
name
)
;
getter
=
desc
.
get
;
}
catch
(
ex
)
{
}
if
(
!
getter
)
{
obj
.
_safeGetters
=
null
;
continue
;
}
let
result
=
getter
.
call
(
this
.
obj
)
;
if
(
result
&
&
!
(
"
throw
"
in
result
)
)
{
let
getterValue
=
undefined
;
if
(
"
return
"
in
result
)
{
getterValue
=
result
.
return
;
}
else
if
(
"
yield
"
in
result
)
{
getterValue
=
result
.
yield
;
}
if
(
getterValue
!
=
=
undefined
)
{
safeGetterValues
[
name
]
=
{
getterValue
:
this
.
hooks
.
createValueGrip
(
getterValue
)
getterPrototypeLevel
:
level
enumerable
:
desc
.
enumerable
writable
:
level
=
=
0
?
desc
.
writable
:
true
}
;
if
(
limit
&
&
+
+
i
=
=
limit
)
{
break
;
}
}
}
}
if
(
limit
&
&
i
=
=
limit
)
{
break
;
}
obj
=
obj
.
proto
;
level
+
+
;
}
return
safeGetterValues
;
}
_findSafeGetters
:
function
(
object
)
{
if
(
object
.
_safeGetters
)
{
return
object
.
_safeGetters
;
}
let
getters
=
new
Set
(
)
;
if
(
!
DevToolsUtils
.
isSafeDebuggerObject
(
object
)
)
{
object
.
_safeGetters
=
getters
;
return
getters
;
}
let
names
=
[
]
;
try
{
names
=
object
.
getOwnPropertyNames
(
)
;
}
catch
(
ex
)
{
}
for
(
let
name
of
names
)
{
let
desc
=
null
;
try
{
desc
=
object
.
getOwnPropertyDescriptor
(
name
)
;
}
catch
(
e
)
{
}
if
(
!
desc
|
|
desc
.
value
!
=
=
undefined
|
|
!
(
"
get
"
in
desc
)
)
{
continue
;
}
if
(
DevToolsUtils
.
hasSafeGetter
(
desc
)
)
{
getters
.
add
(
name
)
;
}
}
object
.
_safeGetters
=
getters
;
return
getters
;
}
onPrototype
:
function
(
)
{
let
proto
=
null
;
if
(
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
proto
=
this
.
obj
.
proto
;
}
return
{
from
:
this
.
actorID
prototype
:
this
.
hooks
.
createValueGrip
(
proto
)
}
;
}
onProperty
:
function
(
request
)
{
if
(
!
request
.
name
)
{
return
{
error
:
"
missingParameter
"
message
:
"
no
property
name
was
specified
"
}
;
}
return
{
from
:
this
.
actorID
descriptor
:
this
.
_propertyDescriptor
(
request
.
name
)
}
;
}
onDisplayString
:
function
(
)
{
const
string
=
stringify
(
this
.
obj
)
;
return
{
from
:
this
.
actorID
displayString
:
this
.
hooks
.
createValueGrip
(
string
)
}
;
}
_propertyDescriptor
:
function
(
name
onlyEnumerable
)
{
if
(
!
DevToolsUtils
.
isSafeDebuggerObject
(
this
.
obj
)
)
{
return
undefined
;
}
let
desc
;
try
{
desc
=
this
.
obj
.
getOwnPropertyDescriptor
(
name
)
;
}
catch
(
e
)
{
return
{
configurable
:
false
writable
:
false
enumerable
:
false
value
:
e
.
name
}
;
}
if
(
!
desc
|
|
onlyEnumerable
&
&
!
desc
.
enumerable
)
{
return
undefined
;
}
let
retval
=
{
configurable
:
desc
.
configurable
enumerable
:
desc
.
enumerable
}
;
if
(
"
value
"
in
desc
)
{
retval
.
writable
=
desc
.
writable
;
retval
.
value
=
this
.
hooks
.
createValueGrip
(
desc
.
value
)
;
}
else
{
if
(
"
get
"
in
desc
)
{
retval
.
get
=
this
.
hooks
.
createValueGrip
(
desc
.
get
)
;
}
if
(
"
set
"
in
desc
)
{
retval
.
set
=
this
.
hooks
.
createValueGrip
(
desc
.
set
)
;
}
}
return
retval
;
}
onDecompile
:
function
(
request
)
{
if
(
this
.
obj
.
class
!
=
=
"
Function
"
)
{
return
{
error
:
"
objectNotFunction
"
message
:
"
decompile
request
is
only
valid
for
object
grips
"
+
"
with
a
'
Function
'
class
.
"
}
;
}
return
{
from
:
this
.
actorID
decompiledCode
:
this
.
obj
.
decompile
(
!
!
request
.
pretty
)
}
;
}
onParameterNames
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
=
"
Function
"
)
{
return
{
error
:
"
objectNotFunction
"
message
:
"
'
parameterNames
'
request
is
only
valid
for
object
"
+
"
grips
with
a
'
Function
'
class
.
"
}
;
}
return
{
parameterNames
:
this
.
obj
.
parameterNames
}
;
}
onRelease
:
function
(
)
{
this
.
release
(
)
;
return
{
}
;
}
onScope
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
=
"
Function
"
)
{
return
{
error
:
"
objectNotFunction
"
message
:
"
scope
request
is
only
valid
for
object
grips
with
a
"
+
"
'
Function
'
class
.
"
}
;
}
let
envActor
=
this
.
hooks
.
createEnvironmentActor
(
this
.
obj
.
environment
this
.
registeredPool
)
;
if
(
!
envActor
)
{
return
{
error
:
"
notDebuggee
"
message
:
"
cannot
access
the
environment
of
this
function
.
"
}
;
}
return
{
from
:
this
.
actorID
scope
:
envActor
.
form
(
)
}
;
}
onDependentPromises
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
"
Promise
"
)
{
return
{
error
:
"
objectNotPromise
"
message
:
"
'
dependentPromises
'
request
is
only
valid
for
"
+
"
object
grips
with
a
'
Promise
'
class
.
"
}
;
}
let
promises
=
this
.
obj
.
promiseDependentPromises
.
map
(
p
=
>
this
.
hooks
.
createValueGrip
(
p
)
)
;
return
{
promises
}
;
}
onAllocationStack
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
"
Promise
"
)
{
return
{
error
:
"
objectNotPromise
"
message
:
"
'
allocationStack
'
request
is
only
valid
for
"
+
"
object
grips
with
a
'
Promise
'
class
.
"
}
;
}
let
stack
=
this
.
obj
.
promiseAllocationSite
;
let
allocationStacks
=
[
]
;
while
(
stack
)
{
if
(
stack
.
source
)
{
let
source
=
this
.
_getSourceOriginalLocation
(
stack
)
;
if
(
source
)
{
allocationStacks
.
push
(
source
)
;
}
}
stack
=
stack
.
parent
;
}
return
Promise
.
all
(
allocationStacks
)
.
then
(
stacks
=
>
{
return
{
allocationStack
:
stacks
}
;
}
)
;
}
onFulfillmentStack
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
"
Promise
"
)
{
return
{
error
:
"
objectNotPromise
"
message
:
"
'
fulfillmentStack
'
request
is
only
valid
for
"
+
"
object
grips
with
a
'
Promise
'
class
.
"
}
;
}
let
stack
=
this
.
obj
.
promiseResolutionSite
;
let
fulfillmentStacks
=
[
]
;
while
(
stack
)
{
if
(
stack
.
source
)
{
let
source
=
this
.
_getSourceOriginalLocation
(
stack
)
;
if
(
source
)
{
fulfillmentStacks
.
push
(
source
)
;
}
}
stack
=
stack
.
parent
;
}
return
Promise
.
all
(
fulfillmentStacks
)
.
then
(
stacks
=
>
{
return
{
fulfillmentStack
:
stacks
}
;
}
)
;
}
onRejectionStack
:
function
(
)
{
if
(
this
.
obj
.
class
!
=
"
Promise
"
)
{
return
{
error
:
"
objectNotPromise
"
message
:
"
'
rejectionStack
'
request
is
only
valid
for
"
+
"
object
grips
with
a
'
Promise
'
class
.
"
}
;
}
let
stack
=
this
.
obj
.
promiseResolutionSite
;
let
rejectionStacks
=
[
]
;
while
(
stack
)
{
if
(
stack
.
source
)
{
let
source
=
this
.
_getSourceOriginalLocation
(
stack
)
;
if
(
source
)
{
rejectionStacks
.
push
(
source
)
;
}
}
stack
=
stack
.
parent
;
}
return
Promise
.
all
(
rejectionStacks
)
.
then
(
stacks
=
>
{
return
{
rejectionStack
:
stacks
}
;
}
)
;
}
_getSourceOriginalLocation
:
function
(
stack
)
{
let
source
;
try
{
source
=
this
.
hooks
.
sources
(
)
.
getSourceActorByURL
(
stack
.
source
)
;
}
catch
(
e
)
{
}
if
(
!
source
)
{
return
null
;
}
return
this
.
hooks
.
sources
(
)
.
getOriginalLocation
(
new
GeneratedLocation
(
source
stack
.
line
stack
.
column
)
)
.
then
(
(
originalLocation
)
=
>
{
return
{
source
:
originalLocation
.
originalSourceActor
.
form
(
)
line
:
originalLocation
.
originalLine
column
:
originalLocation
.
originalColumn
functionDisplayName
:
stack
.
functionDisplayName
}
;
}
)
;
}
}
;
ObjectActor
.
prototype
.
requestTypes
=
{
"
definitionSite
"
:
ObjectActor
.
prototype
.
onDefinitionSite
"
parameterNames
"
:
ObjectActor
.
prototype
.
onParameterNames
"
prototypeAndProperties
"
:
ObjectActor
.
prototype
.
onPrototypeAndProperties
"
enumProperties
"
:
ObjectActor
.
prototype
.
onEnumProperties
"
prototype
"
:
ObjectActor
.
prototype
.
onPrototype
"
property
"
:
ObjectActor
.
prototype
.
onProperty
"
displayString
"
:
ObjectActor
.
prototype
.
onDisplayString
"
ownPropertyNames
"
:
ObjectActor
.
prototype
.
onOwnPropertyNames
"
decompile
"
:
ObjectActor
.
prototype
.
onDecompile
"
release
"
:
ObjectActor
.
prototype
.
onRelease
"
scope
"
:
ObjectActor
.
prototype
.
onScope
"
dependentPromises
"
:
ObjectActor
.
prototype
.
onDependentPromises
"
allocationStack
"
:
ObjectActor
.
prototype
.
onAllocationStack
"
fulfillmentStack
"
:
ObjectActor
.
prototype
.
onFulfillmentStack
"
rejectionStack
"
:
ObjectActor
.
prototype
.
onRejectionStack
"
enumEntries
"
:
ObjectActor
.
prototype
.
onEnumEntries
"
enumSymbols
"
:
ObjectActor
.
prototype
.
onEnumSymbols
}
;
exports
.
ObjectActor
=
ObjectActor
;
