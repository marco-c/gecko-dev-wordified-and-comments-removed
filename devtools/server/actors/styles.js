"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
Arg
Option
method
RetVal
types
}
=
protocol
;
const
events
=
require
(
"
sdk
/
event
/
core
"
)
;
const
{
Class
}
=
require
(
"
sdk
/
core
/
heritage
"
)
;
const
{
PageStyleFront
}
=
require
(
"
devtools
/
client
/
fronts
/
styles
"
)
;
const
{
LongStringActor
}
=
require
(
"
devtools
/
server
/
actors
/
string
"
)
;
const
{
getDefinedGeometryProperties
}
=
require
(
"
devtools
/
server
/
actors
/
highlighters
/
geometry
-
editor
"
)
;
const
{
UPDATE_PRESERVING_RULES
UPDATE_GENERAL
}
=
require
(
"
devtools
/
server
/
actors
/
stylesheets
"
)
;
const
{
pageStyleSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
styles
"
)
;
loader
.
lazyRequireGetter
(
this
"
CSS
"
"
CSS
"
)
;
loader
.
lazyGetter
(
this
"
CssLogic
"
(
)
=
>
{
return
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
.
CssLogic
;
}
)
;
loader
.
lazyGetter
(
this
"
DOMUtils
"
(
)
=
>
{
return
Cc
[
"
mozilla
.
org
/
inspector
/
dom
-
utils
;
1
"
]
.
getService
(
Ci
.
inIDOMUtils
)
;
}
)
;
loader
.
lazyGetter
(
this
"
RuleRewriter
"
(
)
=
>
{
return
require
(
"
devtools
/
client
/
shared
/
css
-
parsing
-
utils
"
)
.
RuleRewriter
;
}
)
;
const
ELEMENT_STYLE
=
100
;
exports
.
ELEMENT_STYLE
=
ELEMENT_STYLE
;
loader
.
lazyGetter
(
this
"
PSEUDO_ELEMENTS_TO_READ
"
(
)
=
>
{
return
DOMUtils
.
getCSSPseudoElementNames
(
)
.
filter
(
pseudo
=
>
{
return
pseudo
!
=
=
"
:
before
"
&
&
pseudo
!
=
=
"
:
after
"
;
}
)
;
}
)
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
FONT_PREVIEW_TEXT
=
"
Abc
"
;
const
FONT_PREVIEW_FONT_SIZE
=
40
;
const
FONT_PREVIEW_FILLSTYLE
=
"
black
"
;
const
NORMAL_FONT_WEIGHT
=
400
;
const
BOLD_FONT_WEIGHT
=
700
;
const
FONT_PREVIEW_OFFSET
=
4
;
var
PageStyleActor
=
protocol
.
ActorClassWithSpec
(
pageStyleSpec
{
initialize
:
function
(
inspector
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
inspector
=
inspector
;
if
(
!
this
.
inspector
.
walker
)
{
throw
Error
(
"
The
inspector
'
s
WalkerActor
must
be
created
before
"
+
"
creating
a
PageStyleActor
.
"
)
;
}
this
.
walker
=
inspector
.
walker
;
this
.
cssLogic
=
new
CssLogic
(
)
;
this
.
refMap
=
new
Map
(
)
;
this
.
styleElements
=
new
WeakMap
(
)
;
this
.
onFrameUnload
=
this
.
onFrameUnload
.
bind
(
this
)
;
events
.
on
(
this
.
inspector
.
tabActor
"
will
-
navigate
"
this
.
onFrameUnload
)
;
this
.
_styleApplied
=
this
.
_styleApplied
.
bind
(
this
)
;
this
.
_watchedSheets
=
new
Set
(
)
;
}
destroy
:
function
(
)
{
if
(
!
this
.
walker
)
{
return
;
}
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
events
.
off
(
this
.
inspector
.
tabActor
"
will
-
navigate
"
this
.
onFrameUnload
)
;
this
.
inspector
=
null
;
this
.
walker
=
null
;
this
.
refMap
=
null
;
this
.
cssLogic
=
null
;
this
.
styleElements
=
null
;
for
(
let
sheet
of
this
.
_watchedSheets
)
{
sheet
.
off
(
"
style
-
applied
"
this
.
_styleApplied
)
;
}
this
.
_watchedSheets
.
clear
(
)
;
}
get
conn
(
)
{
return
this
.
inspector
.
conn
;
}
form
:
function
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
return
{
actor
:
this
.
actorID
traits
:
{
getAppliedCreatesStyleCache
:
true
authoredStyles
:
true
}
}
;
}
_styleApplied
:
function
(
kind
styleSheet
)
{
this
.
cssLogic
.
reset
(
)
;
if
(
kind
=
=
=
UPDATE_GENERAL
)
{
events
.
emit
(
this
"
stylesheet
-
updated
"
styleSheet
)
;
}
}
_styleRef
:
function
(
item
)
{
if
(
this
.
refMap
.
has
(
item
)
)
{
return
this
.
refMap
.
get
(
item
)
;
}
let
actor
=
StyleRuleActor
(
this
item
)
;
this
.
manage
(
actor
)
;
this
.
refMap
.
set
(
item
actor
)
;
return
actor
;
}
updateStyleRef
:
function
(
oldItem
item
actor
)
{
this
.
refMap
.
delete
(
oldItem
)
;
this
.
refMap
.
set
(
item
actor
)
;
}
_sheetRef
:
function
(
sheet
)
{
let
tabActor
=
this
.
inspector
.
tabActor
;
let
actor
=
tabActor
.
createStyleSheetActor
(
sheet
)
;
if
(
!
this
.
_watchedSheets
.
has
(
actor
)
)
{
this
.
_watchedSheets
.
add
(
actor
)
;
actor
.
on
(
"
style
-
applied
"
this
.
_styleApplied
)
;
}
return
actor
;
}
getComputed
:
function
(
node
options
)
{
let
ret
=
Object
.
create
(
null
)
;
this
.
cssLogic
.
sourceFilter
=
options
.
filter
|
|
CssLogic
.
FILTER
.
UA
;
this
.
cssLogic
.
highlight
(
node
.
rawNode
)
;
let
computed
=
this
.
cssLogic
.
computedStyle
|
|
[
]
;
Array
.
prototype
.
forEach
.
call
(
computed
name
=
>
{
ret
[
name
]
=
{
value
:
computed
.
getPropertyValue
(
name
)
priority
:
computed
.
getPropertyPriority
(
name
)
|
|
undefined
}
;
}
)
;
if
(
options
.
markMatched
|
|
options
.
onlyMatched
)
{
let
matched
=
this
.
cssLogic
.
hasMatchedSelectors
(
Object
.
keys
(
ret
)
)
;
for
(
let
key
in
ret
)
{
if
(
matched
[
key
]
)
{
ret
[
key
]
.
matched
=
options
.
markMatched
?
true
:
undefined
;
}
else
if
(
options
.
onlyMatched
)
{
delete
ret
[
key
]
;
}
}
}
return
ret
;
}
getAllUsedFontFaces
:
function
(
options
)
{
let
windows
=
this
.
inspector
.
tabActor
.
windows
;
let
fontsList
=
[
]
;
for
(
let
win
of
windows
)
{
fontsList
=
[
.
.
.
fontsList
.
.
.
this
.
getUsedFontFaces
(
win
.
document
.
body
options
)
]
;
}
return
fontsList
;
}
getUsedFontFaces
:
function
(
node
options
)
{
let
actualNode
=
node
.
rawNode
|
|
node
;
let
contentDocument
=
actualNode
.
ownerDocument
;
let
rng
=
contentDocument
.
createRange
(
)
;
rng
.
selectNodeContents
(
actualNode
)
;
let
fonts
=
DOMUtils
.
getUsedFontFaces
(
rng
)
;
let
fontsArray
=
[
]
;
for
(
let
i
=
0
;
i
<
fonts
.
length
;
i
+
+
)
{
let
font
=
fonts
.
item
(
i
)
;
let
fontFace
=
{
name
:
font
.
name
CSSFamilyName
:
font
.
CSSFamilyName
srcIndex
:
font
.
srcIndex
URI
:
font
.
URI
format
:
font
.
format
localName
:
font
.
localName
metadata
:
font
.
metadata
}
;
if
(
font
.
rule
)
{
let
styleActor
=
StyleRuleActor
(
this
font
.
rule
)
;
this
.
manage
(
styleActor
)
;
fontFace
.
rule
=
styleActor
;
fontFace
.
ruleText
=
font
.
rule
.
cssText
;
}
let
weight
=
NORMAL_FONT_WEIGHT
style
=
"
"
;
if
(
font
.
rule
)
{
weight
=
font
.
rule
.
style
.
getPropertyValue
(
"
font
-
weight
"
)
|
|
NORMAL_FONT_WEIGHT
;
if
(
weight
=
=
"
bold
"
)
{
weight
=
BOLD_FONT_WEIGHT
;
}
else
if
(
weight
=
=
"
normal
"
)
{
weight
=
NORMAL_FONT_WEIGHT
;
}
style
=
font
.
rule
.
style
.
getPropertyValue
(
"
font
-
style
"
)
|
|
"
"
;
}
fontFace
.
weight
=
weight
;
fontFace
.
style
=
style
;
if
(
options
.
includePreviews
)
{
let
opts
=
{
previewText
:
options
.
previewText
previewFontSize
:
options
.
previewFontSize
fontStyle
:
weight
+
"
"
+
style
fillStyle
:
options
.
previewFillStyle
}
;
let
{
dataURL
size
}
=
getFontPreviewData
(
font
.
CSSFamilyName
contentDocument
opts
)
;
fontFace
.
preview
=
{
data
:
LongStringActor
(
this
.
conn
dataURL
)
size
:
size
}
;
}
fontsArray
.
push
(
fontFace
)
;
}
fontsArray
.
sort
(
function
(
a
b
)
{
return
a
.
weight
>
b
.
weight
?
1
:
-
1
;
}
)
;
fontsArray
.
sort
(
function
(
a
b
)
{
if
(
a
.
CSSFamilyName
=
=
b
.
CSSFamilyName
)
{
return
0
;
}
return
a
.
CSSFamilyName
>
b
.
CSSFamilyName
?
1
:
-
1
;
}
)
;
fontsArray
.
sort
(
function
(
a
b
)
{
if
(
(
a
.
rule
&
&
b
.
rule
)
|
|
(
!
a
.
rule
&
&
!
b
.
rule
)
)
{
return
0
;
}
return
!
a
.
rule
&
&
b
.
rule
?
1
:
-
1
;
}
)
;
return
fontsArray
;
}
getMatchedSelectors
:
function
(
node
property
options
)
{
this
.
cssLogic
.
sourceFilter
=
options
.
filter
|
|
CssLogic
.
FILTER
.
UA
;
this
.
cssLogic
.
highlight
(
node
.
rawNode
)
;
let
rules
=
new
Set
(
)
;
let
sheets
=
new
Set
(
)
;
let
matched
=
[
]
;
let
propInfo
=
this
.
cssLogic
.
getPropertyInfo
(
property
)
;
for
(
let
selectorInfo
of
propInfo
.
matchedSelectors
)
{
let
cssRule
=
selectorInfo
.
selector
.
cssRule
;
let
domRule
=
cssRule
.
sourceElement
|
|
cssRule
.
domRule
;
let
rule
=
this
.
_styleRef
(
domRule
)
;
rules
.
add
(
rule
)
;
matched
.
push
(
{
rule
:
rule
sourceText
:
this
.
getSelectorSource
(
selectorInfo
node
.
rawNode
)
selector
:
selectorInfo
.
selector
.
text
name
:
selectorInfo
.
property
value
:
selectorInfo
.
value
status
:
selectorInfo
.
status
}
)
;
}
this
.
expandSets
(
rules
sheets
)
;
return
{
matched
:
matched
rules
:
[
.
.
.
rules
]
sheets
:
[
.
.
.
sheets
]
}
;
}
getSelectorSource
:
function
(
selectorInfo
relativeTo
)
{
let
result
=
selectorInfo
.
selector
.
text
;
if
(
selectorInfo
.
elementStyle
)
{
let
source
=
selectorInfo
.
sourceElement
;
if
(
source
=
=
=
relativeTo
)
{
result
=
"
this
"
;
}
else
{
result
=
CssLogic
.
getShortName
(
source
)
;
}
result
+
=
"
.
style
"
;
}
return
result
;
}
getApplied
:
Task
.
async
(
function
*
(
node
options
)
{
if
(
!
node
)
{
return
{
entries
:
[
]
rules
:
[
]
sheets
:
[
]
}
;
}
this
.
cssLogic
.
highlight
(
node
.
rawNode
)
;
let
entries
=
[
]
;
entries
=
entries
.
concat
(
this
.
_getAllElementRules
(
node
undefined
options
)
)
;
let
result
=
this
.
getAppliedProps
(
node
entries
options
)
;
for
(
let
rule
of
result
.
rules
)
{
yield
rule
.
getAuthoredCssText
(
)
;
}
return
result
;
}
)
_hasInheritedProps
:
function
(
style
)
{
return
Array
.
prototype
.
some
.
call
(
style
prop
=
>
{
return
DOMUtils
.
isInheritedProperty
(
prop
)
;
}
)
;
}
isPositionEditable
:
Task
.
async
(
function
*
(
node
)
{
if
(
!
node
|
|
node
.
rawNode
.
nodeType
!
=
=
node
.
rawNode
.
ELEMENT_NODE
)
{
return
false
;
}
let
props
=
getDefinedGeometryProperties
(
node
.
rawNode
)
;
return
props
.
has
(
"
top
"
)
|
|
props
.
has
(
"
right
"
)
|
|
props
.
has
(
"
left
"
)
|
|
props
.
has
(
"
bottom
"
)
;
}
)
_getAllElementRules
:
function
(
node
inherited
options
)
{
let
{
bindingElement
pseudo
}
=
CssLogic
.
getBindingElementAndPseudo
(
node
.
rawNode
)
;
let
rules
=
[
]
;
if
(
!
bindingElement
|
|
!
bindingElement
.
style
)
{
return
rules
;
}
let
elementStyle
=
this
.
_styleRef
(
bindingElement
)
;
let
showElementStyles
=
!
inherited
&
&
!
pseudo
;
let
showInheritedStyles
=
inherited
&
&
this
.
_hasInheritedProps
(
bindingElement
.
style
)
;
let
rule
=
{
rule
:
elementStyle
pseudoElement
:
null
isSystem
:
false
inherited
:
false
}
;
if
(
showElementStyles
)
{
rules
.
push
(
rule
)
;
}
if
(
showInheritedStyles
)
{
rule
.
inherited
=
inherited
;
rules
.
push
(
rule
)
;
}
this
.
_getElementRules
(
bindingElement
pseudo
inherited
options
)
.
forEach
(
oneRule
=
>
{
oneRule
.
pseudoElement
=
null
;
rules
.
push
(
oneRule
)
;
}
)
;
if
(
showElementStyles
)
{
for
(
let
readPseudo
of
PSEUDO_ELEMENTS_TO_READ
)
{
this
.
_getElementRules
(
bindingElement
readPseudo
inherited
options
)
.
forEach
(
oneRule
=
>
{
rules
.
push
(
oneRule
)
;
}
)
;
}
}
return
rules
;
}
_getElementRules
:
function
(
node
pseudo
inherited
options
)
{
let
domRules
=
DOMUtils
.
getCSSStyleRules
(
node
pseudo
)
;
if
(
!
domRules
)
{
return
[
]
;
}
let
rules
=
[
]
;
for
(
let
i
=
domRules
.
Count
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
let
domRule
=
domRules
.
GetElementAt
(
i
)
;
let
isSystem
=
!
CssLogic
.
isContentStylesheet
(
domRule
.
parentStyleSheet
)
;
if
(
isSystem
&
&
options
.
filter
!
=
CssLogic
.
FILTER
.
UA
)
{
continue
;
}
if
(
inherited
)
{
let
hasInherited
=
[
.
.
.
domRule
.
style
]
.
some
(
prop
=
>
DOMUtils
.
isInheritedProperty
(
prop
)
)
;
if
(
!
hasInherited
)
{
continue
;
}
}
let
ruleActor
=
this
.
_styleRef
(
domRule
)
;
rules
.
push
(
{
rule
:
ruleActor
inherited
:
inherited
isSystem
:
isSystem
pseudoElement
:
pseudo
}
)
;
}
return
rules
;
}
findEntryMatchingRule
:
function
(
node
filterRule
)
{
const
options
=
{
matchedSelectors
:
true
inherited
:
true
}
;
let
entries
=
[
]
;
let
parent
=
this
.
walker
.
parentNode
(
node
)
;
while
(
parent
&
&
parent
.
rawNode
.
nodeType
!
=
Ci
.
nsIDOMNode
.
DOCUMENT_NODE
)
{
entries
=
entries
.
concat
(
this
.
_getAllElementRules
(
parent
parent
options
)
)
;
parent
=
this
.
walker
.
parentNode
(
parent
)
;
}
return
entries
.
filter
(
entry
=
>
entry
.
rule
.
rawRule
=
=
=
filterRule
)
;
}
getAppliedProps
:
function
(
node
entries
options
)
{
if
(
options
.
inherited
)
{
let
parent
=
this
.
walker
.
parentNode
(
node
)
;
while
(
parent
&
&
parent
.
rawNode
.
nodeType
!
=
Ci
.
nsIDOMNode
.
DOCUMENT_NODE
)
{
entries
=
entries
.
concat
(
this
.
_getAllElementRules
(
parent
parent
options
)
)
;
parent
=
this
.
walker
.
parentNode
(
parent
)
;
}
}
if
(
options
.
matchedSelectors
)
{
for
(
let
entry
of
entries
)
{
if
(
entry
.
rule
.
type
=
=
=
ELEMENT_STYLE
)
{
continue
;
}
let
domRule
=
entry
.
rule
.
rawRule
;
let
selectors
=
CssLogic
.
getSelectors
(
domRule
)
;
let
element
=
entry
.
inherited
?
entry
.
inherited
.
rawNode
:
node
.
rawNode
;
let
{
bindingElement
pseudo
}
=
CssLogic
.
getBindingElementAndPseudo
(
element
)
;
entry
.
matchedSelectors
=
[
]
;
for
(
let
i
=
0
;
i
<
selectors
.
length
;
i
+
+
)
{
if
(
DOMUtils
.
selectorMatchesElement
(
bindingElement
domRule
i
pseudo
)
)
{
entry
.
matchedSelectors
.
push
(
selectors
[
i
]
)
;
}
}
}
}
let
computedStyle
=
this
.
cssLogic
.
computedStyle
;
if
(
computedStyle
)
{
let
animationNames
=
computedStyle
.
animationName
.
split
(
"
"
)
;
animationNames
=
animationNames
.
map
(
name
=
>
name
.
trim
(
)
)
;
if
(
animationNames
)
{
for
(
let
keyframesRule
of
this
.
cssLogic
.
keyframesRules
)
{
if
(
animationNames
.
indexOf
(
keyframesRule
.
name
)
>
-
1
)
{
for
(
let
rule
of
keyframesRule
.
cssRules
)
{
entries
.
push
(
{
rule
:
this
.
_styleRef
(
rule
)
keyframes
:
this
.
_styleRef
(
keyframesRule
)
}
)
;
}
}
}
}
}
let
rules
=
new
Set
(
)
;
let
sheets
=
new
Set
(
)
;
entries
.
forEach
(
entry
=
>
rules
.
add
(
entry
.
rule
)
)
;
this
.
expandSets
(
rules
sheets
)
;
return
{
entries
:
entries
rules
:
[
.
.
.
rules
]
sheets
:
[
.
.
.
sheets
]
}
;
}
expandSets
:
function
(
ruleSet
sheetSet
)
{
for
(
let
rule
of
ruleSet
)
{
if
(
rule
.
rawRule
.
parentRule
)
{
let
parent
=
this
.
_styleRef
(
rule
.
rawRule
.
parentRule
)
;
if
(
!
ruleSet
.
has
(
parent
)
)
{
ruleSet
.
add
(
parent
)
;
}
}
if
(
rule
.
rawRule
.
parentStyleSheet
)
{
let
parent
=
this
.
_sheetRef
(
rule
.
rawRule
.
parentStyleSheet
)
;
if
(
!
sheetSet
.
has
(
parent
)
)
{
sheetSet
.
add
(
parent
)
;
}
}
}
for
(
let
sheet
of
sheetSet
)
{
if
(
sheet
.
rawSheet
.
parentStyleSheet
)
{
let
parent
=
this
.
_sheetRef
(
sheet
.
rawSheet
.
parentStyleSheet
)
;
if
(
!
sheetSet
.
has
(
parent
)
)
{
sheetSet
.
add
(
parent
)
;
}
}
}
}
getLayout
:
function
(
node
options
)
{
this
.
cssLogic
.
highlight
(
node
.
rawNode
)
;
let
layout
=
{
}
;
let
clientRect
=
node
.
rawNode
.
getBoundingClientRect
(
)
;
layout
.
width
=
parseFloat
(
clientRect
.
width
.
toPrecision
(
6
)
)
;
layout
.
height
=
parseFloat
(
clientRect
.
height
.
toPrecision
(
6
)
)
;
let
style
=
CssLogic
.
getComputedStyle
(
node
.
rawNode
)
;
for
(
let
prop
of
[
"
position
"
"
margin
-
top
"
"
margin
-
right
"
"
margin
-
bottom
"
"
margin
-
left
"
"
padding
-
top
"
"
padding
-
right
"
"
padding
-
bottom
"
"
padding
-
left
"
"
border
-
top
-
width
"
"
border
-
right
-
width
"
"
border
-
bottom
-
width
"
"
border
-
left
-
width
"
"
z
-
index
"
"
box
-
sizing
"
"
display
"
]
)
{
layout
[
prop
]
=
style
.
getPropertyValue
(
prop
)
;
}
if
(
options
.
autoMargins
)
{
layout
.
autoMargins
=
this
.
processMargins
(
this
.
cssLogic
)
;
}
for
(
let
i
in
this
.
map
)
{
let
property
=
this
.
map
[
i
]
.
property
;
this
.
map
[
i
]
.
value
=
parseFloat
(
style
.
getPropertyValue
(
property
)
)
;
}
return
layout
;
}
processMargins
:
function
(
cssLogic
)
{
let
margins
=
{
}
;
for
(
let
prop
of
[
"
top
"
"
bottom
"
"
left
"
"
right
"
]
)
{
let
info
=
cssLogic
.
getPropertyInfo
(
"
margin
-
"
+
prop
)
;
let
selectors
=
info
.
matchedSelectors
;
if
(
selectors
&
&
selectors
.
length
>
0
&
&
selectors
[
0
]
.
value
=
=
"
auto
"
)
{
margins
[
prop
]
=
"
auto
"
;
}
}
return
margins
;
}
onFrameUnload
:
function
(
)
{
this
.
styleElements
=
new
WeakMap
(
)
;
}
getStyleElement
:
function
(
document
)
{
if
(
!
this
.
styleElements
.
has
(
document
)
)
{
let
style
=
document
.
createElementNS
(
XHTML_NS
"
style
"
)
;
style
.
setAttribute
(
"
type
"
"
text
/
css
"
)
;
document
.
documentElement
.
appendChild
(
style
)
;
this
.
styleElements
.
set
(
document
style
)
;
}
return
this
.
styleElements
.
get
(
document
)
;
}
getNewAppliedProps
:
function
(
node
rule
)
{
let
ruleActor
=
this
.
_styleRef
(
rule
)
;
return
this
.
getAppliedProps
(
node
[
{
rule
:
ruleActor
}
]
{
matchedSelectors
:
true
}
)
;
}
addNewRule
:
Task
.
async
(
function
*
(
node
pseudoClasses
editAuthored
=
false
)
{
let
style
=
this
.
getStyleElement
(
node
.
rawNode
.
ownerDocument
)
;
let
sheet
=
style
.
sheet
;
let
cssRules
=
sheet
.
cssRules
;
let
rawNode
=
node
.
rawNode
;
let
selector
;
if
(
rawNode
.
id
)
{
selector
=
"
#
"
+
CSS
.
escape
(
rawNode
.
id
)
;
}
else
if
(
rawNode
.
className
)
{
selector
=
"
.
"
+
[
.
.
.
rawNode
.
classList
]
.
map
(
c
=
>
CSS
.
escape
(
c
)
)
.
join
(
"
.
"
)
;
}
else
{
selector
=
rawNode
.
tagName
.
toLowerCase
(
)
;
}
if
(
pseudoClasses
&
&
pseudoClasses
.
length
>
0
)
{
selector
+
=
pseudoClasses
.
join
(
"
"
)
;
}
let
index
=
sheet
.
insertRule
(
selector
+
"
{
}
"
cssRules
.
length
)
;
if
(
editAuthored
)
{
let
sheetActor
=
this
.
_sheetRef
(
sheet
)
;
let
{
str
:
authoredText
}
=
yield
sheetActor
.
getText
(
)
;
authoredText
+
=
"
\
n
"
+
selector
+
"
{
\
n
"
+
"
}
"
;
yield
sheetActor
.
update
(
authoredText
false
)
;
}
return
this
.
getNewAppliedProps
(
node
sheet
.
cssRules
.
item
(
index
)
)
;
}
)
}
)
;
exports
.
PageStyleActor
=
PageStyleActor
;
var
StyleRuleActor
=
protocol
.
ActorClass
(
{
typeName
:
"
domstylerule
"
events
:
{
"
location
-
changed
"
:
{
type
:
"
locationChanged
"
line
:
Arg
(
0
"
number
"
)
column
:
Arg
(
1
"
number
"
)
}
}
initialize
:
function
(
pageStyle
item
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
pageStyle
=
pageStyle
;
this
.
rawStyle
=
item
.
style
;
this
.
_parentSheet
=
null
;
this
.
_onStyleApplied
=
this
.
_onStyleApplied
.
bind
(
this
)
;
if
(
item
instanceof
(
Ci
.
nsIDOMCSSRule
)
)
{
this
.
type
=
item
.
type
;
this
.
rawRule
=
item
;
if
(
(
this
.
type
=
=
=
Ci
.
nsIDOMCSSRule
.
STYLE_RULE
|
|
this
.
type
=
=
=
Ci
.
nsIDOMCSSRule
.
KEYFRAME_RULE
)
&
&
this
.
rawRule
.
parentStyleSheet
)
{
this
.
line
=
DOMUtils
.
getRelativeRuleLine
(
this
.
rawRule
)
;
this
.
column
=
DOMUtils
.
getRuleColumn
(
this
.
rawRule
)
;
this
.
_parentSheet
=
this
.
rawRule
.
parentStyleSheet
;
this
.
_computeRuleIndex
(
)
;
this
.
sheetActor
=
this
.
pageStyle
.
_sheetRef
(
this
.
_parentSheet
)
;
this
.
sheetActor
.
on
(
"
style
-
applied
"
this
.
_onStyleApplied
)
;
}
}
else
{
this
.
type
=
ELEMENT_STYLE
;
this
.
rawNode
=
item
;
this
.
rawRule
=
{
style
:
item
.
style
toString
:
function
(
)
{
return
"
[
element
rule
"
+
this
.
style
+
"
]
"
;
}
}
;
}
}
get
conn
(
)
{
return
this
.
pageStyle
.
conn
;
}
destroy
:
function
(
)
{
if
(
!
this
.
rawStyle
)
{
return
;
}
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
rawStyle
=
null
;
this
.
pageStyle
=
null
;
this
.
rawNode
=
null
;
this
.
rawRule
=
null
;
if
(
this
.
sheetActor
)
{
this
.
sheetActor
.
off
(
"
style
-
applied
"
this
.
_onStyleApplied
)
;
}
}
get
marshallPool
(
)
{
return
this
.
pageStyle
;
}
get
canSetRuleText
(
)
{
return
!
!
(
this
.
_parentSheet
&
&
this
.
sheetActor
.
allRulesHaveSource
(
)
&
&
this
.
_parentSheet
.
href
!
=
=
"
about
:
PreferenceStyleSheet
"
)
;
}
getDocument
:
function
(
sheet
)
{
let
document
;
if
(
sheet
.
ownerNode
instanceof
Ci
.
nsIDOMHTMLDocument
)
{
document
=
sheet
.
ownerNode
;
}
else
{
document
=
sheet
.
ownerNode
.
ownerDocument
;
}
return
document
;
}
toString
:
function
(
)
{
return
"
[
StyleRuleActor
for
"
+
this
.
rawRule
+
"
]
"
;
}
form
:
function
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
let
form
=
{
actor
:
this
.
actorID
type
:
this
.
type
line
:
this
.
line
|
|
undefined
column
:
this
.
column
traits
:
{
modifySelectorUnmatched
:
true
canSetRuleText
:
this
.
canSetRuleText
}
}
;
if
(
this
.
rawRule
.
parentRule
)
{
form
.
parentRule
=
this
.
pageStyle
.
_styleRef
(
this
.
rawRule
.
parentRule
)
.
actorID
;
if
(
this
.
rawRule
.
parentRule
.
type
=
=
=
Ci
.
nsIDOMCSSRule
.
MEDIA_RULE
)
{
form
.
media
=
[
]
;
for
(
let
i
=
0
n
=
this
.
rawRule
.
parentRule
.
media
.
length
;
i
<
n
;
i
+
+
)
{
form
.
media
.
push
(
this
.
rawRule
.
parentRule
.
media
.
item
(
i
)
)
;
}
}
}
if
(
this
.
_parentSheet
)
{
form
.
parentStyleSheet
=
this
.
pageStyle
.
_sheetRef
(
this
.
_parentSheet
)
.
actorID
;
}
form
.
authoredText
=
this
.
authoredText
;
switch
(
this
.
type
)
{
case
Ci
.
nsIDOMCSSRule
.
STYLE_RULE
:
form
.
selectors
=
CssLogic
.
getSelectors
(
this
.
rawRule
)
;
form
.
cssText
=
this
.
rawStyle
.
cssText
|
|
"
"
;
break
;
case
ELEMENT_STYLE
:
let
doc
=
this
.
rawNode
.
ownerDocument
;
form
.
href
=
doc
.
location
?
doc
.
location
.
href
:
"
"
;
form
.
cssText
=
this
.
rawStyle
.
cssText
|
|
"
"
;
break
;
case
Ci
.
nsIDOMCSSRule
.
CHARSET_RULE
:
form
.
encoding
=
this
.
rawRule
.
encoding
;
break
;
case
Ci
.
nsIDOMCSSRule
.
IMPORT_RULE
:
form
.
href
=
this
.
rawRule
.
href
;
break
;
case
Ci
.
nsIDOMCSSRule
.
KEYFRAMES_RULE
:
form
.
cssText
=
this
.
rawRule
.
cssText
;
form
.
name
=
this
.
rawRule
.
name
;
break
;
case
Ci
.
nsIDOMCSSRule
.
KEYFRAME_RULE
:
form
.
cssText
=
this
.
rawStyle
.
cssText
|
|
"
"
;
form
.
keyText
=
this
.
rawRule
.
keyText
|
|
"
"
;
break
;
}
return
form
;
}
_notifyLocationChanged
:
function
(
line
column
)
{
events
.
emit
(
this
"
location
-
changed
"
line
column
)
;
}
_computeRuleIndex
:
function
(
)
{
let
rule
=
this
.
rawRule
;
let
result
=
[
]
;
while
(
rule
)
{
let
cssRules
;
if
(
rule
.
parentRule
)
{
cssRules
=
rule
.
parentRule
.
cssRules
;
}
else
{
cssRules
=
rule
.
parentStyleSheet
.
cssRules
;
}
let
found
=
false
;
for
(
let
i
=
0
;
i
<
cssRules
.
length
;
i
+
+
)
{
if
(
rule
=
=
=
cssRules
.
item
(
i
)
)
{
found
=
true
;
result
.
unshift
(
i
)
;
break
;
}
}
if
(
!
found
)
{
this
.
_ruleIndex
=
null
;
return
;
}
rule
=
rule
.
parentRule
;
}
this
.
_ruleIndex
=
result
;
}
_getRuleFromIndex
:
function
(
parentSheet
)
{
let
currentRule
=
null
;
for
(
let
i
of
this
.
_ruleIndex
)
{
if
(
currentRule
=
=
=
null
)
{
currentRule
=
parentSheet
.
cssRules
[
i
]
;
}
else
{
currentRule
=
currentRule
.
cssRules
.
item
(
i
)
;
}
}
return
currentRule
;
}
_onStyleApplied
:
function
(
kind
)
{
if
(
kind
=
=
=
UPDATE_GENERAL
)
{
if
(
this
.
sheetActor
)
{
this
.
sheetActor
.
off
(
"
style
-
applied
"
this
.
_onStyleApplied
)
;
}
}
else
if
(
this
.
_ruleIndex
)
{
let
oldRule
=
this
.
rawRule
;
this
.
rawRule
=
this
.
_getRuleFromIndex
(
this
.
_parentSheet
)
;
this
.
pageStyle
.
updateStyleRef
(
oldRule
this
.
rawRule
this
)
;
let
line
=
DOMUtils
.
getRelativeRuleLine
(
this
.
rawRule
)
;
let
column
=
DOMUtils
.
getRuleColumn
(
this
.
rawRule
)
;
if
(
line
!
=
=
this
.
line
|
|
column
!
=
=
this
.
column
)
{
this
.
_notifyLocationChanged
(
line
column
)
;
}
this
.
line
=
line
;
this
.
column
=
column
;
}
}
getAuthoredCssText
:
function
(
)
{
if
(
!
this
.
canSetRuleText
|
|
(
this
.
type
!
=
=
Ci
.
nsIDOMCSSRule
.
STYLE_RULE
&
&
this
.
type
!
=
=
Ci
.
nsIDOMCSSRule
.
KEYFRAME_RULE
)
)
{
return
promise
.
resolve
(
"
"
)
;
}
if
(
typeof
this
.
authoredText
=
=
=
"
string
"
)
{
return
promise
.
resolve
(
this
.
authoredText
)
;
}
let
parentStyleSheet
=
this
.
pageStyle
.
_sheetRef
(
this
.
_parentSheet
)
;
return
parentStyleSheet
.
getText
(
)
.
then
(
(
longStr
)
=
>
{
let
cssText
=
longStr
.
str
;
let
{
text
}
=
getRuleText
(
cssText
this
.
line
this
.
column
)
;
this
.
authoredText
=
text
;
return
this
.
authoredText
;
}
)
;
}
setRuleText
:
method
(
Task
.
async
(
function
*
(
newText
)
{
if
(
!
this
.
canSetRuleText
|
|
(
this
.
type
!
=
=
Ci
.
nsIDOMCSSRule
.
STYLE_RULE
&
&
this
.
type
!
=
=
Ci
.
nsIDOMCSSRule
.
KEYFRAME_RULE
)
)
{
throw
new
Error
(
"
invalid
call
to
setRuleText
"
)
;
}
let
parentStyleSheet
=
this
.
pageStyle
.
_sheetRef
(
this
.
_parentSheet
)
;
let
{
str
:
cssText
}
=
yield
parentStyleSheet
.
getText
(
)
;
let
{
offset
text
}
=
getRuleText
(
cssText
this
.
line
this
.
column
)
;
cssText
=
cssText
.
substring
(
0
offset
)
+
newText
+
cssText
.
substring
(
offset
+
text
.
length
)
;
this
.
authoredText
=
newText
;
yield
parentStyleSheet
.
update
(
cssText
false
UPDATE_PRESERVING_RULES
)
;
return
this
;
}
)
{
request
:
{
modification
:
Arg
(
0
"
string
"
)
}
response
:
{
rule
:
RetVal
(
"
domstylerule
"
)
}
}
)
modifyProperties
:
method
(
function
(
modifications
)
{
let
document
;
if
(
this
.
rawNode
)
{
document
=
this
.
rawNode
.
ownerDocument
;
}
else
{
let
parentStyleSheet
=
this
.
_parentSheet
;
while
(
parentStyleSheet
.
ownerRule
&
&
parentStyleSheet
.
ownerRule
instanceof
Ci
.
nsIDOMCSSImportRule
)
{
parentStyleSheet
=
parentStyleSheet
.
ownerRule
.
parentStyleSheet
;
}
document
=
this
.
getDocument
(
parentStyleSheet
)
;
}
let
tempElement
=
document
.
createElementNS
(
XHTML_NS
"
div
"
)
;
for
(
let
mod
of
modifications
)
{
if
(
mod
.
type
=
=
=
"
set
"
)
{
tempElement
.
style
.
setProperty
(
mod
.
name
mod
.
value
mod
.
priority
|
|
"
"
)
;
this
.
rawStyle
.
setProperty
(
mod
.
name
tempElement
.
style
.
getPropertyValue
(
mod
.
name
)
mod
.
priority
|
|
"
"
)
;
}
else
if
(
mod
.
type
=
=
=
"
remove
"
)
{
this
.
rawStyle
.
removeProperty
(
mod
.
name
)
;
}
}
return
this
;
}
{
request
:
{
modifications
:
Arg
(
0
"
array
:
json
"
)
}
response
:
{
rule
:
RetVal
(
"
domstylerule
"
)
}
}
)
_addNewSelector
:
Task
.
async
(
function
*
(
value
editAuthored
)
{
let
rule
=
this
.
rawRule
;
let
parentStyleSheet
=
this
.
_parentSheet
;
if
(
editAuthored
)
{
let
document
=
this
.
getDocument
(
this
.
_parentSheet
)
;
try
{
document
.
querySelector
(
value
)
;
}
catch
(
e
)
{
return
null
;
}
let
sheetActor
=
this
.
pageStyle
.
_sheetRef
(
parentStyleSheet
)
;
let
{
str
:
authoredText
}
=
yield
sheetActor
.
getText
(
)
;
let
[
startOffset
endOffset
]
=
getSelectorOffsets
(
authoredText
this
.
line
this
.
column
)
;
authoredText
=
authoredText
.
substring
(
0
startOffset
)
+
value
+
authoredText
.
substring
(
endOffset
)
;
yield
sheetActor
.
update
(
authoredText
false
UPDATE_PRESERVING_RULES
)
;
}
else
{
let
cssRules
=
parentStyleSheet
.
cssRules
;
let
cssText
=
rule
.
cssText
;
let
selectorText
=
rule
.
selectorText
;
for
(
let
i
=
0
;
i
<
cssRules
.
length
;
i
+
+
)
{
if
(
rule
=
=
=
cssRules
.
item
(
i
)
)
{
try
{
let
ruleText
=
cssText
.
slice
(
selectorText
.
length
)
.
trim
(
)
;
parentStyleSheet
.
insertRule
(
value
+
"
"
+
ruleText
i
)
;
parentStyleSheet
.
deleteRule
(
i
+
1
)
;
break
;
}
catch
(
e
)
{
return
null
;
}
}
}
}
return
this
.
_getRuleFromIndex
(
parentStyleSheet
)
;
}
)
modifySelector
:
method
(
Task
.
async
(
function
*
(
value
)
{
if
(
this
.
type
=
=
=
ELEMENT_STYLE
)
{
return
false
;
}
let
document
=
this
.
getDocument
(
this
.
_parentSheet
)
;
let
[
selector
]
=
value
.
split
(
/
(
:
{
1
2
}
.
+
)
/
)
;
let
selectorElement
;
try
{
selectorElement
=
document
.
querySelector
(
selector
)
;
}
catch
(
e
)
{
return
false
;
}
if
(
selectorElement
&
&
this
.
rawRule
.
selectorText
!
=
=
value
)
{
yield
this
.
_addNewSelector
(
value
false
)
;
return
true
;
}
return
false
;
}
)
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
}
response
:
{
isModified
:
RetVal
(
"
boolean
"
)
}
}
)
modifySelector2
:
method
(
function
(
node
value
editAuthored
=
false
)
{
if
(
this
.
type
=
=
=
ELEMENT_STYLE
|
|
this
.
rawRule
.
selectorText
=
=
=
value
)
{
return
{
ruleProps
:
null
isMatching
:
true
}
;
}
let
selectorPromise
=
this
.
_addNewSelector
(
value
editAuthored
)
;
if
(
editAuthored
)
{
selectorPromise
=
selectorPromise
.
then
(
(
newCssRule
)
=
>
{
if
(
newCssRule
)
{
let
style
=
this
.
pageStyle
.
_styleRef
(
newCssRule
)
;
return
style
.
getAuthoredCssText
(
)
.
then
(
(
)
=
>
newCssRule
)
;
}
return
newCssRule
;
}
)
;
}
return
selectorPromise
.
then
(
(
newCssRule
)
=
>
{
let
ruleProps
=
null
;
let
isMatching
=
false
;
if
(
newCssRule
)
{
let
ruleEntry
=
this
.
pageStyle
.
findEntryMatchingRule
(
node
newCssRule
)
;
if
(
ruleEntry
.
length
=
=
=
1
)
{
isMatching
=
true
;
ruleProps
=
this
.
pageStyle
.
getAppliedProps
(
node
ruleEntry
{
matchedSelectors
:
true
}
)
;
}
else
{
ruleProps
=
this
.
pageStyle
.
getNewAppliedProps
(
node
newCssRule
)
;
}
}
return
{
ruleProps
isMatching
}
;
}
)
;
}
{
request
:
{
node
:
Arg
(
0
"
domnode
"
)
value
:
Arg
(
1
"
string
"
)
editAuthored
:
Arg
(
2
"
boolean
"
)
}
response
:
RetVal
(
"
modifiedStylesReturn
"
)
}
)
}
)
;
protocol
.
FrontClass
(
StyleRuleActor
{
initialize
:
function
(
client
form
ctx
detail
)
{
protocol
.
Front
.
prototype
.
initialize
.
call
(
this
client
form
ctx
detail
)
;
}
destroy
:
function
(
)
{
protocol
.
Front
.
prototype
.
destroy
.
call
(
this
)
;
}
form
:
function
(
form
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
this
.
actorID
=
form
;
return
;
}
this
.
actorID
=
form
.
actor
;
this
.
_form
=
form
;
if
(
this
.
_mediaText
)
{
this
.
_mediaText
=
null
;
}
}
_locationChangedPre
:
protocol
.
preEvent
(
"
location
-
changed
"
function
(
line
column
)
{
this
.
_clearOriginalLocation
(
)
;
this
.
_form
.
line
=
line
;
this
.
_form
.
column
=
column
;
}
)
startModifyingProperties
:
function
(
)
{
if
(
this
.
canSetRuleText
)
{
return
new
RuleRewriter
(
this
this
.
authoredText
)
;
}
return
new
RuleModificationList
(
this
)
;
}
get
type
(
)
{
return
this
.
_form
.
type
;
}
get
line
(
)
{
return
this
.
_form
.
line
|
|
-
1
;
}
get
column
(
)
{
return
this
.
_form
.
column
|
|
-
1
;
}
get
cssText
(
)
{
return
this
.
_form
.
cssText
;
}
get
authoredText
(
)
{
return
this
.
_form
.
authoredText
|
|
this
.
_form
.
cssText
;
}
get
keyText
(
)
{
return
this
.
_form
.
keyText
;
}
get
name
(
)
{
return
this
.
_form
.
name
;
}
get
selectors
(
)
{
return
this
.
_form
.
selectors
;
}
get
media
(
)
{
return
this
.
_form
.
media
;
}
get
mediaText
(
)
{
if
(
!
this
.
_form
.
media
)
{
return
null
;
}
if
(
this
.
_mediaText
)
{
return
this
.
_mediaText
;
}
this
.
_mediaText
=
this
.
media
.
join
(
"
"
)
;
return
this
.
_mediaText
;
}
get
parentRule
(
)
{
return
this
.
conn
.
getActor
(
this
.
_form
.
parentRule
)
;
}
get
parentStyleSheet
(
)
{
return
this
.
conn
.
getActor
(
this
.
_form
.
parentStyleSheet
)
;
}
get
element
(
)
{
return
this
.
conn
.
getActor
(
this
.
_form
.
element
)
;
}
get
href
(
)
{
if
(
this
.
_form
.
href
)
{
return
this
.
_form
.
href
;
}
let
sheet
=
this
.
parentStyleSheet
;
return
sheet
?
sheet
.
href
:
"
"
;
}
get
nodeHref
(
)
{
let
sheet
=
this
.
parentStyleSheet
;
return
sheet
?
sheet
.
nodeHref
:
"
"
;
}
get
supportsModifySelectorUnmatched
(
)
{
return
this
.
_form
.
traits
&
&
this
.
_form
.
traits
.
modifySelectorUnmatched
;
}
get
canSetRuleText
(
)
{
return
this
.
_form
.
traits
&
&
this
.
_form
.
traits
.
canSetRuleText
;
}
get
location
(
)
{
return
{
source
:
this
.
parentStyleSheet
href
:
this
.
href
line
:
this
.
line
column
:
this
.
column
}
;
}
_clearOriginalLocation
:
function
(
)
{
this
.
_originalLocation
=
null
;
}
getOriginalLocation
:
function
(
)
{
if
(
this
.
_originalLocation
)
{
return
promise
.
resolve
(
this
.
_originalLocation
)
;
}
let
parentSheet
=
this
.
parentStyleSheet
;
if
(
!
parentSheet
)
{
return
promise
.
resolve
(
this
.
location
)
;
}
return
parentSheet
.
getOriginalLocation
(
this
.
line
this
.
column
)
.
then
(
(
{
fromSourceMap
source
line
column
}
)
=
>
{
let
location
=
{
href
:
source
line
:
line
column
:
column
mediaText
:
this
.
mediaText
}
;
if
(
fromSourceMap
=
=
=
false
)
{
location
.
source
=
this
.
parentStyleSheet
;
}
if
(
!
source
)
{
location
.
href
=
this
.
href
;
}
this
.
_originalLocation
=
location
;
return
location
;
}
)
;
}
modifySelector
:
protocol
.
custom
(
Task
.
async
(
function
*
(
node
value
)
{
let
response
;
if
(
this
.
supportsModifySelectorUnmatched
)
{
if
(
this
.
canSetRuleText
)
{
response
=
yield
this
.
modifySelector2
(
node
value
true
)
;
}
else
{
response
=
yield
this
.
modifySelector2
(
node
value
)
;
}
}
else
{
response
=
yield
this
.
_modifySelector
(
value
)
;
}
if
(
response
.
ruleProps
)
{
response
.
ruleProps
=
response
.
ruleProps
.
entries
[
0
]
;
}
return
response
;
}
)
{
impl
:
"
_modifySelector
"
}
)
setRuleText
:
protocol
.
custom
(
function
(
newText
)
{
this
.
_form
.
authoredText
=
newText
;
return
this
.
_setRuleText
(
newText
)
;
}
{
impl
:
"
_setRuleText
"
}
)
}
)
;
var
RuleModificationList
=
Class
(
{
initialize
:
function
(
rule
)
{
this
.
rule
=
rule
;
this
.
modifications
=
[
]
;
}
apply
:
function
(
)
{
return
this
.
rule
.
modifyProperties
(
this
.
modifications
)
;
}
setProperty
:
function
(
index
name
value
priority
)
{
this
.
modifications
.
push
(
{
type
:
"
set
"
name
:
name
value
:
value
priority
:
priority
}
)
;
}
removeProperty
:
function
(
index
name
)
{
this
.
modifications
.
push
(
{
type
:
"
remove
"
name
:
name
}
)
;
}
renameProperty
:
function
(
index
name
)
{
this
.
removeProperty
(
index
name
)
;
}
setPropertyEnabled
:
function
(
index
name
isEnabled
)
{
if
(
!
isEnabled
)
{
this
.
removeProperty
(
index
name
)
;
}
}
createProperty
:
function
(
)
{
}
}
)
;
function
getFontPreviewData
(
font
doc
options
)
{
options
=
options
|
|
{
}
;
let
previewText
=
options
.
previewText
|
|
FONT_PREVIEW_TEXT
;
let
previewFontSize
=
options
.
previewFontSize
|
|
FONT_PREVIEW_FONT_SIZE
;
let
fillStyle
=
options
.
fillStyle
|
|
FONT_PREVIEW_FILLSTYLE
;
let
fontStyle
=
options
.
fontStyle
|
|
"
"
;
let
canvas
=
doc
.
createElementNS
(
XHTML_NS
"
canvas
"
)
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
let
fontValue
=
fontStyle
+
"
"
+
previewFontSize
+
"
px
"
+
font
+
"
serif
"
;
ctx
.
font
=
fontValue
;
ctx
.
fillStyle
=
fillStyle
;
let
textWidth
=
ctx
.
measureText
(
previewText
)
.
width
;
canvas
.
width
=
textWidth
*
2
+
FONT_PREVIEW_OFFSET
*
2
;
canvas
.
height
=
previewFontSize
*
3
;
ctx
.
font
=
fontValue
;
ctx
.
fillStyle
=
fillStyle
;
ctx
.
textBaseline
=
"
top
"
;
ctx
.
scale
(
2
2
)
;
ctx
.
fillText
(
previewText
FONT_PREVIEW_OFFSET
Math
.
round
(
previewFontSize
/
3
)
)
;
let
dataURL
=
canvas
.
toDataURL
(
"
image
/
png
"
)
;
return
{
dataURL
:
dataURL
size
:
textWidth
+
FONT_PREVIEW_OFFSET
*
2
}
;
}
exports
.
getFontPreviewData
=
getFontPreviewData
;
function
getRuleText
(
initialText
line
column
)
{
if
(
typeof
line
=
=
=
"
undefined
"
|
|
typeof
column
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
Location
information
is
missing
"
)
;
}
let
{
offset
:
textOffset
text
}
=
getTextAtLineColumn
(
initialText
line
column
)
;
let
lexer
=
DOMUtils
.
getCSSLexer
(
text
)
;
while
(
true
)
{
let
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
)
{
throw
new
Error
(
"
couldn
'
t
find
start
of
the
rule
"
)
;
}
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
{
"
)
{
break
;
}
}
let
braceDepth
=
1
;
let
startOffset
endOffset
;
while
(
true
)
{
let
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
)
{
break
;
}
if
(
startOffset
=
=
=
undefined
)
{
startOffset
=
token
.
startOffset
;
}
if
(
token
.
tokenType
=
=
=
"
symbol
"
)
{
if
(
token
.
text
=
=
=
"
{
"
)
{
+
+
braceDepth
;
}
else
if
(
token
.
text
=
=
=
"
}
"
)
{
-
-
braceDepth
;
if
(
braceDepth
=
=
0
)
{
break
;
}
}
}
endOffset
=
token
.
endOffset
;
}
if
(
startOffset
=
=
=
undefined
)
{
return
{
offset
:
0
text
:
"
"
}
;
}
if
(
endOffset
=
=
=
undefined
)
{
endOffset
=
startOffset
;
}
return
{
offset
:
textOffset
+
startOffset
text
:
text
.
substring
(
startOffset
endOffset
)
}
;
}
exports
.
getRuleText
=
getRuleText
;
function
getSelectorOffsets
(
initialText
line
column
)
{
if
(
typeof
line
=
=
=
"
undefined
"
|
|
typeof
column
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
Location
information
is
missing
"
)
;
}
let
{
offset
:
textOffset
text
}
=
getTextAtLineColumn
(
initialText
line
column
)
;
let
lexer
=
DOMUtils
.
getCSSLexer
(
text
)
;
let
endOffset
;
while
(
true
)
{
let
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
{
"
)
{
if
(
endOffset
=
=
=
undefined
)
{
break
;
}
return
[
textOffset
textOffset
+
endOffset
]
;
}
if
(
token
.
tokenType
!
=
=
"
comment
"
&
&
token
.
tokenType
!
=
=
"
whitespace
"
)
{
endOffset
=
token
.
endOffset
;
}
}
throw
new
Error
(
"
could
not
find
bounds
of
rule
"
)
;
}
function
getTextAtLineColumn
(
text
line
column
)
{
let
offset
;
if
(
line
>
1
)
{
let
rx
=
new
RegExp
(
"
(
?
:
.
*
(
?
:
\
\
r
\
\
n
|
\
\
n
|
\
\
r
|
\
\
f
)
)
{
"
+
(
line
-
1
)
+
"
}
"
)
;
offset
=
rx
.
exec
(
text
)
[
0
]
.
length
;
}
else
{
offset
=
0
;
}
offset
+
=
column
-
1
;
return
{
offset
:
offset
text
:
text
.
substr
(
offset
)
}
;
}
exports
.
getTextAtLineColumn
=
getTextAtLineColumn
;
