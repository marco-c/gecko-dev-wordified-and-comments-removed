"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
getCSSLexer
}
=
require
(
"
devtools
/
shared
/
css
/
lexer
"
)
;
const
{
LongStringActor
}
=
require
(
"
devtools
/
server
/
actors
/
string
"
)
;
const
InspectorUtils
=
require
(
"
InspectorUtils
"
)
;
const
TrackChangeEmitter
=
require
(
"
devtools
/
server
/
actors
/
utils
/
track
-
change
-
emitter
"
)
;
const
{
pageStyleSpec
styleRuleSpec
ELEMENT_STYLE
}
=
require
(
"
devtools
/
shared
/
specs
/
styles
"
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
actors
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
SharedCssLogic
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
loader
.
lazyRequireGetter
(
this
"
getDefinedGeometryProperties
"
"
devtools
/
server
/
actors
/
highlighters
/
geometry
-
editor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isCssPropertyKnown
"
"
devtools
/
server
/
actors
/
css
-
properties
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
parseNamedDeclarations
"
"
devtools
/
shared
/
css
/
parsing
-
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
UPDATE_PRESERVING_RULES
"
"
devtools
/
server
/
actors
/
stylesheets
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
UPDATE_GENERAL
"
"
devtools
/
server
/
actors
/
stylesheets
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
findCssSelector
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CSSRuleTypeName
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyGetter
(
this
"
PSEUDO_ELEMENTS
"
(
)
=
>
{
return
InspectorUtils
.
getCSSPseudoElementNames
(
)
;
}
)
;
loader
.
lazyGetter
(
this
"
FONT_VARIATIONS_ENABLED
"
(
)
=
>
{
return
Services
.
prefs
.
getBoolPref
(
"
layout
.
css
.
font
-
variations
.
enabled
"
)
;
}
)
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
FONT_PREVIEW_TEXT
=
"
Abc
"
;
const
FONT_PREVIEW_FONT_SIZE
=
40
;
const
FONT_PREVIEW_FILLSTYLE
=
"
black
"
;
const
NORMAL_FONT_WEIGHT
=
400
;
const
BOLD_FONT_WEIGHT
=
700
;
const
FONT_PREVIEW_OFFSET
=
4
;
var
PageStyleActor
=
protocol
.
ActorClassWithSpec
(
pageStyleSpec
{
initialize
:
function
(
inspector
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
inspector
=
inspector
;
if
(
!
this
.
inspector
.
walker
)
{
throw
Error
(
"
The
inspector
'
s
WalkerActor
must
be
created
before
"
+
"
creating
a
PageStyleActor
.
"
)
;
}
this
.
walker
=
inspector
.
walker
;
this
.
cssLogic
=
new
CssLogic
(
InspectorUtils
.
isInheritedProperty
)
;
this
.
refMap
=
new
Map
(
)
;
this
.
styleElements
=
new
WeakMap
(
)
;
this
.
onFrameUnload
=
this
.
onFrameUnload
.
bind
(
this
)
;
this
.
onStyleSheetAdded
=
this
.
onStyleSheetAdded
.
bind
(
this
)
;
this
.
inspector
.
targetActor
.
on
(
"
will
-
navigate
"
this
.
onFrameUnload
)
;
this
.
inspector
.
targetActor
.
on
(
"
stylesheet
-
added
"
this
.
onStyleSheetAdded
)
;
this
.
_styleApplied
=
this
.
_styleApplied
.
bind
(
this
)
;
this
.
_watchedSheets
=
new
Set
(
)
;
}
destroy
:
function
(
)
{
if
(
!
this
.
walker
)
{
return
;
}
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
inspector
.
targetActor
.
off
(
"
will
-
navigate
"
this
.
onFrameUnload
)
;
this
.
inspector
.
targetActor
.
off
(
"
stylesheet
-
added
"
this
.
onStyleSheetAdded
)
;
this
.
inspector
=
null
;
this
.
walker
=
null
;
this
.
refMap
=
null
;
this
.
cssLogic
=
null
;
this
.
styleElements
=
null
;
for
(
const
sheet
of
this
.
_watchedSheets
)
{
sheet
.
off
(
"
style
-
applied
"
this
.
_styleApplied
)
;
}
this
.
_watchedSheets
.
clear
(
)
;
}
get
conn
(
)
{
return
this
.
inspector
.
conn
;
}
get
ownerWindow
(
)
{
return
this
.
inspector
.
targetActor
.
window
;
}
form
:
function
(
)
{
const
CSS
=
this
.
inspector
.
targetActor
.
window
.
CSS
;
return
{
actor
:
this
.
actorID
traits
:
{
getAppliedCreatesStyleCache
:
true
fontStretchLevel4
:
CSS
.
supports
(
"
font
-
stretch
:
100
%
"
)
fontStyleLevel4
:
CSS
.
supports
(
"
font
-
style
:
oblique
20deg
"
)
fontVariations
:
FONT_VARIATIONS_ENABLED
fontWeightLevel4
:
CSS
.
supports
(
"
font
-
weight
:
1
"
)
&
&
CSS
.
supports
(
"
font
-
stretch
:
100
%
"
)
}
}
;
}
_styleApplied
:
function
(
kind
styleSheet
)
{
this
.
cssLogic
.
reset
(
)
;
if
(
kind
=
=
=
UPDATE_GENERAL
)
{
this
.
emit
(
"
stylesheet
-
updated
"
styleSheet
)
;
}
}
_styleRef
:
function
(
item
)
{
if
(
this
.
refMap
.
has
(
item
)
)
{
return
this
.
refMap
.
get
(
item
)
;
}
const
actor
=
StyleRuleActor
(
this
item
)
;
this
.
manage
(
actor
)
;
this
.
refMap
.
set
(
item
actor
)
;
return
actor
;
}
updateStyleRef
:
function
(
oldItem
item
actor
)
{
this
.
refMap
.
delete
(
oldItem
)
;
this
.
refMap
.
set
(
item
actor
)
;
}
_sheetRef
:
function
(
sheet
)
{
const
targetActor
=
this
.
inspector
.
targetActor
;
const
actor
=
targetActor
.
createStyleSheetActor
(
sheet
)
;
return
actor
;
}
getComputed
:
function
(
node
options
)
{
const
ret
=
Object
.
create
(
null
)
;
this
.
cssLogic
.
sourceFilter
=
options
.
filter
|
|
SharedCssLogic
.
FILTER
.
UA
;
this
.
cssLogic
.
highlight
(
node
.
rawNode
)
;
const
computed
=
this
.
cssLogic
.
computedStyle
|
|
[
]
;
Array
.
prototype
.
forEach
.
call
(
computed
name
=
>
{
if
(
Array
.
isArray
(
options
.
filterProperties
)
&
&
!
options
.
filterProperties
.
includes
(
name
)
)
{
return
;
}
ret
[
name
]
=
{
value
:
computed
.
getPropertyValue
(
name
)
priority
:
computed
.
getPropertyPriority
(
name
)
|
|
undefined
}
;
}
)
;
if
(
options
.
markMatched
|
|
options
.
onlyMatched
)
{
const
matched
=
this
.
cssLogic
.
hasMatchedSelectors
(
Object
.
keys
(
ret
)
)
;
for
(
const
key
in
ret
)
{
if
(
matched
[
key
]
)
{
ret
[
key
]
.
matched
=
options
.
markMatched
?
true
:
undefined
;
}
else
if
(
options
.
onlyMatched
)
{
delete
ret
[
key
]
;
}
}
}
return
ret
;
}
getAllUsedFontFaces
:
function
(
options
)
{
const
windows
=
this
.
inspector
.
targetActor
.
windows
;
let
fontsList
=
[
]
;
for
(
const
win
of
windows
)
{
fontsList
=
[
.
.
.
fontsList
.
.
.
this
.
getUsedFontFaces
(
win
.
document
.
body
options
)
]
;
}
return
fontsList
;
}
getUsedFontFaces
:
function
(
node
options
)
{
const
actualNode
=
node
.
rawNode
|
|
node
;
const
contentDocument
=
actualNode
.
ownerDocument
;
const
rng
=
contentDocument
.
createRange
(
)
;
const
isPseudoElement
=
Boolean
(
CssLogic
.
getBindingElementAndPseudo
(
actualNode
)
.
pseudo
)
;
if
(
isPseudoElement
)
{
rng
.
selectNodeContents
(
actualNode
)
;
}
else
{
rng
.
selectNode
(
actualNode
)
;
}
const
fonts
=
InspectorUtils
.
getUsedFontFaces
(
rng
)
;
const
fontsArray
=
[
]
;
for
(
let
i
=
0
;
i
<
fonts
.
length
;
i
+
+
)
{
const
font
=
fonts
[
i
]
;
const
fontFace
=
{
name
:
font
.
name
CSSFamilyName
:
font
.
CSSFamilyName
CSSGeneric
:
font
.
CSSGeneric
|
|
null
srcIndex
:
font
.
srcIndex
URI
:
font
.
URI
format
:
font
.
format
localName
:
font
.
localName
metadata
:
font
.
metadata
}
;
if
(
font
.
rule
)
{
const
styleActor
=
StyleRuleActor
(
this
font
.
rule
)
;
this
.
manage
(
styleActor
)
;
fontFace
.
rule
=
styleActor
;
fontFace
.
ruleText
=
font
.
rule
.
cssText
;
}
let
weight
=
NORMAL_FONT_WEIGHT
style
=
"
"
;
if
(
font
.
rule
)
{
weight
=
font
.
rule
.
style
.
getPropertyValue
(
"
font
-
weight
"
)
|
|
NORMAL_FONT_WEIGHT
;
if
(
weight
=
=
"
bold
"
)
{
weight
=
BOLD_FONT_WEIGHT
;
}
else
if
(
weight
=
=
"
normal
"
)
{
weight
=
NORMAL_FONT_WEIGHT
;
}
style
=
font
.
rule
.
style
.
getPropertyValue
(
"
font
-
style
"
)
|
|
"
"
;
}
fontFace
.
weight
=
weight
;
fontFace
.
style
=
style
;
if
(
options
.
includePreviews
)
{
const
opts
=
{
previewText
:
options
.
previewText
previewFontSize
:
options
.
previewFontSize
fontStyle
:
weight
+
"
"
+
style
fillStyle
:
options
.
previewFillStyle
}
;
const
{
dataURL
size
}
=
getFontPreviewData
(
font
.
CSSFamilyName
contentDocument
opts
)
;
fontFace
.
preview
=
{
data
:
LongStringActor
(
this
.
conn
dataURL
)
size
:
size
}
;
}
if
(
options
.
includeVariations
&
&
FONT_VARIATIONS_ENABLED
)
{
fontFace
.
variationAxes
=
font
.
getVariationAxes
(
)
;
fontFace
.
variationInstances
=
font
.
getVariationInstances
(
)
;
}
fontsArray
.
push
(
fontFace
)
;
}
fontsArray
.
sort
(
function
(
a
b
)
{
return
a
.
weight
>
b
.
weight
?
1
:
-
1
;
}
)
;
fontsArray
.
sort
(
function
(
a
b
)
{
if
(
a
.
CSSFamilyName
=
=
b
.
CSSFamilyName
)
{
return
0
;
}
return
a
.
CSSFamilyName
>
b
.
CSSFamilyName
?
1
:
-
1
;
}
)
;
fontsArray
.
sort
(
function
(
a
b
)
{
if
(
(
a
.
rule
&
&
b
.
rule
)
|
|
(
!
a
.
rule
&
&
!
b
.
rule
)
)
{
return
0
;
}
return
!
a
.
rule
&
&
b
.
rule
?
1
:
-
1
;
}
)
;
return
fontsArray
;
}
getMatchedSelectors
:
function
(
node
property
options
)
{
this
.
cssLogic
.
sourceFilter
=
options
.
filter
|
|
SharedCssLogic
.
FILTER
.
UA
;
this
.
cssLogic
.
highlight
(
node
.
rawNode
)
;
const
rules
=
new
Set
(
)
;
const
sheets
=
new
Set
(
)
;
const
matched
=
[
]
;
const
propInfo
=
this
.
cssLogic
.
getPropertyInfo
(
property
)
;
for
(
const
selectorInfo
of
propInfo
.
matchedSelectors
)
{
const
cssRule
=
selectorInfo
.
selector
.
cssRule
;
const
domRule
=
cssRule
.
sourceElement
|
|
cssRule
.
domRule
;
const
rule
=
this
.
_styleRef
(
domRule
)
;
rules
.
add
(
rule
)
;
matched
.
push
(
{
rule
:
rule
sourceText
:
this
.
getSelectorSource
(
selectorInfo
node
.
rawNode
)
selector
:
selectorInfo
.
selector
.
text
name
:
selectorInfo
.
property
value
:
selectorInfo
.
value
status
:
selectorInfo
.
status
}
)
;
}
this
.
expandSets
(
rules
sheets
)
;
return
{
matched
:
matched
rules
:
[
.
.
.
rules
]
sheets
:
[
.
.
.
sheets
]
}
;
}
getSelectorSource
:
function
(
selectorInfo
relativeTo
)
{
let
result
=
selectorInfo
.
selector
.
text
;
if
(
selectorInfo
.
elementStyle
)
{
const
source
=
selectorInfo
.
sourceElement
;
if
(
source
=
=
=
relativeTo
)
{
result
=
"
this
"
;
}
else
{
result
=
CssLogic
.
getShortName
(
source
)
;
}
result
+
=
"
.
style
"
;
}
return
result
;
}
async
getApplied
(
node
options
)
{
if
(
!
node
)
{
return
{
entries
:
[
]
rules
:
[
]
sheets
:
[
]
}
;
}
this
.
cssLogic
.
highlight
(
node
.
rawNode
)
;
let
entries
=
[
]
;
entries
=
entries
.
concat
(
this
.
_getAllElementRules
(
node
undefined
options
)
)
;
const
result
=
this
.
getAppliedProps
(
node
entries
options
)
;
for
(
const
rule
of
result
.
rules
)
{
await
rule
.
getAuthoredCssText
(
)
;
}
return
result
;
}
_hasInheritedProps
:
function
(
style
)
{
return
Array
.
prototype
.
some
.
call
(
style
prop
=
>
{
return
InspectorUtils
.
isInheritedProperty
(
prop
)
;
}
)
;
}
async
isPositionEditable
(
node
)
{
if
(
!
node
|
|
node
.
rawNode
.
nodeType
!
=
=
node
.
rawNode
.
ELEMENT_NODE
)
{
return
false
;
}
const
props
=
getDefinedGeometryProperties
(
node
.
rawNode
)
;
return
props
.
has
(
"
top
"
)
|
|
props
.
has
(
"
right
"
)
|
|
props
.
has
(
"
left
"
)
|
|
props
.
has
(
"
bottom
"
)
;
}
_getAllElementRules
:
function
(
node
inherited
options
)
{
const
{
bindingElement
pseudo
}
=
CssLogic
.
getBindingElementAndPseudo
(
node
.
rawNode
)
;
const
rules
=
[
]
;
if
(
!
bindingElement
|
|
!
bindingElement
.
style
)
{
return
rules
;
}
const
elementStyle
=
this
.
_styleRef
(
bindingElement
)
;
const
showElementStyles
=
!
inherited
&
&
!
pseudo
;
const
showInheritedStyles
=
inherited
&
&
this
.
_hasInheritedProps
(
bindingElement
.
style
)
;
const
rule
=
{
rule
:
elementStyle
pseudoElement
:
null
isSystem
:
false
inherited
:
false
}
;
if
(
showElementStyles
)
{
rules
.
push
(
rule
)
;
}
if
(
showInheritedStyles
)
{
rule
.
inherited
=
inherited
;
rules
.
push
(
rule
)
;
}
this
.
_getElementRules
(
bindingElement
pseudo
inherited
options
)
.
forEach
(
oneRule
=
>
{
oneRule
.
pseudoElement
=
null
;
rules
.
push
(
oneRule
)
;
}
)
;
if
(
showElementStyles
&
&
!
options
.
skipPseudo
)
{
for
(
const
readPseudo
of
PSEUDO_ELEMENTS
)
{
this
.
_getElementRules
(
bindingElement
readPseudo
inherited
options
)
.
forEach
(
oneRule
=
>
{
rules
.
push
(
oneRule
)
;
}
)
;
}
}
return
rules
;
}
_getElementRules
:
function
(
node
pseudo
inherited
options
)
{
const
domRules
=
InspectorUtils
.
getCSSStyleRules
(
node
pseudo
)
;
if
(
!
domRules
)
{
return
[
]
;
}
const
rules
=
[
]
;
for
(
let
i
=
domRules
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
domRule
=
domRules
[
i
]
;
const
isSystem
=
!
SharedCssLogic
.
isContentStylesheet
(
domRule
.
parentStyleSheet
)
;
if
(
isSystem
&
&
options
.
filter
!
=
SharedCssLogic
.
FILTER
.
UA
)
{
continue
;
}
if
(
inherited
)
{
const
hasInherited
=
[
.
.
.
domRule
.
style
]
.
some
(
prop
=
>
InspectorUtils
.
isInheritedProperty
(
prop
)
)
;
if
(
!
hasInherited
)
{
continue
;
}
}
const
ruleActor
=
this
.
_styleRef
(
domRule
)
;
rules
.
push
(
{
rule
:
ruleActor
inherited
:
inherited
isSystem
:
isSystem
pseudoElement
:
pseudo
}
)
;
}
return
rules
;
}
findEntryMatchingRule
:
function
(
node
filterRule
)
{
const
options
=
{
matchedSelectors
:
true
inherited
:
true
}
;
let
entries
=
[
]
;
let
parent
=
this
.
walker
.
parentNode
(
node
)
;
while
(
parent
&
&
parent
.
rawNode
.
nodeType
!
=
Node
.
DOCUMENT_NODE
)
{
entries
=
entries
.
concat
(
this
.
_getAllElementRules
(
parent
parent
options
)
)
;
parent
=
this
.
walker
.
parentNode
(
parent
)
;
}
return
entries
.
filter
(
entry
=
>
entry
.
rule
.
rawRule
=
=
=
filterRule
)
;
}
getAppliedProps
:
function
(
node
entries
options
)
{
if
(
options
.
inherited
)
{
let
parent
=
this
.
walker
.
parentNode
(
node
)
;
while
(
parent
&
&
parent
.
rawNode
.
nodeType
!
=
Node
.
DOCUMENT_NODE
)
{
entries
=
entries
.
concat
(
this
.
_getAllElementRules
(
parent
parent
options
)
)
;
parent
=
this
.
walker
.
parentNode
(
parent
)
;
}
}
if
(
options
.
matchedSelectors
)
{
for
(
const
entry
of
entries
)
{
if
(
entry
.
rule
.
type
=
=
=
ELEMENT_STYLE
)
{
continue
;
}
const
domRule
=
entry
.
rule
.
rawRule
;
const
selectors
=
CssLogic
.
getSelectors
(
domRule
)
;
const
element
=
entry
.
inherited
?
entry
.
inherited
.
rawNode
:
node
.
rawNode
;
const
{
bindingElement
pseudo
}
=
CssLogic
.
getBindingElementAndPseudo
(
element
)
;
entry
.
matchedSelectors
=
[
]
;
for
(
let
i
=
0
;
i
<
selectors
.
length
;
i
+
+
)
{
if
(
InspectorUtils
.
selectorMatchesElement
(
bindingElement
domRule
i
pseudo
)
)
{
entry
.
matchedSelectors
.
push
(
selectors
[
i
]
)
;
}
}
}
}
const
computedStyle
=
this
.
cssLogic
.
computedStyle
;
if
(
computedStyle
)
{
let
animationNames
=
computedStyle
.
animationName
.
split
(
"
"
)
;
animationNames
=
animationNames
.
map
(
name
=
>
name
.
trim
(
)
)
;
if
(
animationNames
)
{
for
(
const
keyframesRule
of
this
.
cssLogic
.
keyframesRules
)
{
if
(
animationNames
.
indexOf
(
keyframesRule
.
name
)
>
-
1
)
{
for
(
const
rule
of
keyframesRule
.
cssRules
)
{
entries
.
push
(
{
rule
:
this
.
_styleRef
(
rule
)
keyframes
:
this
.
_styleRef
(
keyframesRule
)
}
)
;
}
}
}
}
}
const
rules
=
new
Set
(
)
;
const
sheets
=
new
Set
(
)
;
entries
.
forEach
(
entry
=
>
rules
.
add
(
entry
.
rule
)
)
;
this
.
expandSets
(
rules
sheets
)
;
return
{
entries
:
entries
rules
:
[
.
.
.
rules
]
sheets
:
[
.
.
.
sheets
]
}
;
}
expandSets
:
function
(
ruleSet
sheetSet
)
{
for
(
const
rule
of
ruleSet
)
{
if
(
rule
.
rawRule
.
parentRule
)
{
const
parent
=
this
.
_styleRef
(
rule
.
rawRule
.
parentRule
)
;
if
(
!
ruleSet
.
has
(
parent
)
)
{
ruleSet
.
add
(
parent
)
;
}
}
if
(
rule
.
rawRule
.
parentStyleSheet
)
{
const
parent
=
this
.
_sheetRef
(
rule
.
rawRule
.
parentStyleSheet
)
;
if
(
!
sheetSet
.
has
(
parent
)
)
{
sheetSet
.
add
(
parent
)
;
}
}
}
for
(
const
sheet
of
sheetSet
)
{
if
(
sheet
.
rawSheet
.
parentStyleSheet
)
{
const
parent
=
this
.
_sheetRef
(
sheet
.
rawSheet
.
parentStyleSheet
)
;
if
(
!
sheetSet
.
has
(
parent
)
)
{
sheetSet
.
add
(
parent
)
;
}
}
}
}
getLayout
:
function
(
node
options
)
{
this
.
cssLogic
.
highlight
(
node
.
rawNode
)
;
const
layout
=
{
}
;
const
clientRect
=
node
.
rawNode
.
getBoundingClientRect
(
)
;
layout
.
width
=
parseFloat
(
clientRect
.
width
.
toPrecision
(
6
)
)
;
layout
.
height
=
parseFloat
(
clientRect
.
height
.
toPrecision
(
6
)
)
;
const
style
=
CssLogic
.
getComputedStyle
(
node
.
rawNode
)
;
for
(
const
prop
of
[
"
position
"
"
top
"
"
right
"
"
bottom
"
"
left
"
"
margin
-
top
"
"
margin
-
right
"
"
margin
-
bottom
"
"
margin
-
left
"
"
padding
-
top
"
"
padding
-
right
"
"
padding
-
bottom
"
"
padding
-
left
"
"
border
-
top
-
width
"
"
border
-
right
-
width
"
"
border
-
bottom
-
width
"
"
border
-
left
-
width
"
"
z
-
index
"
"
box
-
sizing
"
"
display
"
"
float
"
"
line
-
height
"
]
)
{
layout
[
prop
]
=
style
.
getPropertyValue
(
prop
)
;
}
if
(
options
.
autoMargins
)
{
layout
.
autoMargins
=
this
.
processMargins
(
this
.
cssLogic
)
;
}
for
(
const
i
in
this
.
map
)
{
const
property
=
this
.
map
[
i
]
.
property
;
this
.
map
[
i
]
.
value
=
parseFloat
(
style
.
getPropertyValue
(
property
)
)
;
}
return
layout
;
}
processMargins
:
function
(
cssLogic
)
{
const
margins
=
{
}
;
for
(
const
prop
of
[
"
top
"
"
bottom
"
"
left
"
"
right
"
]
)
{
const
info
=
cssLogic
.
getPropertyInfo
(
"
margin
-
"
+
prop
)
;
const
selectors
=
info
.
matchedSelectors
;
if
(
selectors
&
&
selectors
.
length
>
0
&
&
selectors
[
0
]
.
value
=
=
"
auto
"
)
{
margins
[
prop
]
=
"
auto
"
;
}
}
return
margins
;
}
onFrameUnload
:
function
(
)
{
this
.
styleElements
=
new
WeakMap
(
)
;
}
onStyleSheetAdded
:
function
(
actor
)
{
if
(
!
this
.
_watchedSheets
.
has
(
actor
)
)
{
this
.
_watchedSheets
.
add
(
actor
)
;
actor
.
on
(
"
style
-
applied
"
this
.
_styleApplied
)
;
}
}
getStyleElement
:
function
(
document
)
{
if
(
!
this
.
styleElements
.
has
(
document
)
)
{
const
style
=
document
.
createElementNS
(
XHTML_NS
"
style
"
)
;
style
.
setAttribute
(
"
type
"
"
text
/
css
"
)
;
document
.
documentElement
.
appendChild
(
style
)
;
this
.
styleElements
.
set
(
document
style
)
;
}
return
this
.
styleElements
.
get
(
document
)
;
}
getNewAppliedProps
:
function
(
node
rule
)
{
const
ruleActor
=
this
.
_styleRef
(
rule
)
;
return
this
.
getAppliedProps
(
node
[
{
rule
:
ruleActor
}
]
{
matchedSelectors
:
true
}
)
;
}
async
addNewRule
(
node
pseudoClasses
)
{
const
style
=
this
.
getStyleElement
(
node
.
rawNode
.
ownerDocument
)
;
const
sheet
=
style
.
sheet
;
const
cssRules
=
sheet
.
cssRules
;
const
rawNode
=
node
.
rawNode
;
const
classes
=
[
.
.
.
rawNode
.
classList
]
;
let
selector
;
if
(
rawNode
.
id
)
{
selector
=
"
#
"
+
CSS
.
escape
(
rawNode
.
id
)
;
}
else
if
(
classes
.
length
>
0
)
{
selector
=
"
.
"
+
classes
.
map
(
c
=
>
CSS
.
escape
(
c
)
)
.
join
(
"
.
"
)
;
}
else
{
selector
=
rawNode
.
localName
;
}
if
(
pseudoClasses
&
&
pseudoClasses
.
length
>
0
)
{
selector
+
=
pseudoClasses
.
join
(
"
"
)
;
}
const
index
=
sheet
.
insertRule
(
selector
+
"
{
}
"
cssRules
.
length
)
;
const
sheetActor
=
this
.
_sheetRef
(
sheet
)
;
let
{
str
:
authoredText
}
=
await
sheetActor
.
getText
(
)
;
authoredText
+
=
"
\
n
"
+
selector
+
"
{
\
n
"
+
"
}
"
;
await
sheetActor
.
update
(
authoredText
false
)
;
return
this
.
getNewAppliedProps
(
node
sheet
.
cssRules
.
item
(
index
)
)
;
}
}
)
;
exports
.
PageStyleActor
=
PageStyleActor
;
var
StyleRuleActor
=
protocol
.
ActorClassWithSpec
(
styleRuleSpec
{
initialize
:
function
(
pageStyle
item
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
pageStyle
=
pageStyle
;
this
.
rawStyle
=
item
.
style
;
this
.
_parentSheet
=
null
;
this
.
_onStyleApplied
=
this
.
_onStyleApplied
.
bind
(
this
)
;
this
.
_declarations
=
[
]
;
if
(
CSSRule
.
isInstance
(
item
)
)
{
this
.
type
=
item
.
type
;
this
.
rawRule
=
item
;
this
.
_computeRuleIndex
(
)
;
if
(
(
this
.
type
=
=
=
CSSRule
.
STYLE_RULE
|
|
this
.
type
=
=
=
CSSRule
.
KEYFRAME_RULE
)
&
&
this
.
rawRule
.
parentStyleSheet
)
{
this
.
line
=
InspectorUtils
.
getRelativeRuleLine
(
this
.
rawRule
)
;
this
.
column
=
InspectorUtils
.
getRuleColumn
(
this
.
rawRule
)
;
this
.
_parentSheet
=
this
.
rawRule
.
parentStyleSheet
;
this
.
sheetActor
=
this
.
pageStyle
.
_sheetRef
(
this
.
_parentSheet
)
;
this
.
sheetActor
.
on
(
"
style
-
applied
"
this
.
_onStyleApplied
)
;
}
}
else
{
this
.
type
=
ELEMENT_STYLE
;
this
.
rawNode
=
item
;
this
.
rawRule
=
{
style
:
item
.
style
toString
:
function
(
)
{
return
"
[
element
rule
"
+
this
.
style
+
"
]
"
;
}
}
;
}
}
get
conn
(
)
{
return
this
.
pageStyle
.
conn
;
}
destroy
:
function
(
)
{
if
(
!
this
.
rawStyle
)
{
return
;
}
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
rawStyle
=
null
;
this
.
pageStyle
=
null
;
this
.
rawNode
=
null
;
this
.
rawRule
=
null
;
this
.
_declarations
=
null
;
if
(
this
.
sheetActor
)
{
this
.
sheetActor
.
off
(
"
style
-
applied
"
this
.
_onStyleApplied
)
;
}
}
get
marshallPool
(
)
{
return
this
.
pageStyle
;
}
get
canSetRuleText
(
)
{
return
this
.
type
=
=
=
ELEMENT_STYLE
|
|
(
this
.
_parentSheet
&
&
!
this
.
sheetActor
.
hasRulesModifiedByCSSOM
(
)
&
&
this
.
_parentSheet
.
href
!
=
=
"
about
:
PreferenceStyleSheet
"
)
;
}
get
ancestorRules
(
)
{
const
ancestors
=
[
]
;
let
rule
=
this
.
rawRule
;
while
(
rule
.
parentRule
)
{
ancestors
.
unshift
(
this
.
pageStyle
.
_styleRef
(
rule
.
parentRule
)
)
;
rule
=
rule
.
parentRule
;
}
return
ancestors
;
}
get
metadata
(
)
{
const
data
=
{
}
;
data
.
id
=
this
.
actorID
;
data
.
ancestors
=
this
.
ancestorRules
.
map
(
rule
=
>
{
return
{
id
:
rule
.
actorID
type
:
rule
.
rawRule
.
type
typeName
:
CSSRuleTypeName
[
rule
.
rawRule
.
type
]
conditionText
:
rule
.
rawRule
.
conditionText
name
:
rule
.
rawRule
.
name
keyText
:
rule
.
rawRule
.
keyText
ruleIndex
:
rule
.
_ruleIndex
}
;
}
)
;
if
(
this
.
type
=
=
=
ELEMENT_STYLE
&
&
this
.
rawNode
)
{
try
{
data
.
selector
=
findCssSelector
(
this
.
rawNode
)
;
}
catch
(
err
)
{
}
data
.
source
=
{
type
:
"
element
"
href
:
this
.
rawNode
.
baseURI
index
:
data
.
selector
isFramed
:
this
.
rawNode
.
ownerGlobal
!
=
=
this
.
pageStyle
.
ownerWindow
}
;
const
nodeActor
=
this
.
pageStyle
.
walker
.
getNode
(
this
.
rawNode
)
;
if
(
nodeActor
)
{
data
.
source
.
id
=
nodeActor
.
actorID
;
}
data
.
ruleIndex
=
0
;
}
else
{
data
.
selector
=
(
this
.
type
=
=
=
CSSRule
.
KEYFRAME_RULE
)
?
this
.
rawRule
.
keyText
:
this
.
rawRule
.
selectorText
;
data
.
source
=
{
type
:
this
.
sheetActor
.
href
?
"
stylesheet
"
:
"
inline
"
href
:
this
.
sheetActor
.
href
|
|
this
.
sheetActor
.
window
.
location
.
toString
(
)
id
:
this
.
sheetActor
.
actorID
index
:
this
.
sheetActor
.
styleSheetIndex
isFramed
:
this
.
sheetActor
.
ownerWindow
!
=
=
this
.
sheetActor
.
window
}
;
data
.
ruleIndex
=
this
.
_ruleIndex
;
}
return
data
;
}
getDocument
:
function
(
sheet
)
{
if
(
sheet
.
ownerNode
)
{
return
sheet
.
ownerNode
.
nodeType
=
=
sheet
.
ownerNode
.
DOCUMENT_NODE
?
sheet
.
ownerNode
:
sheet
.
ownerNode
.
ownerDocument
;
}
else
if
(
sheet
.
parentStyleSheet
)
{
return
this
.
getDocument
(
sheet
.
parentStyleSheet
)
;
}
throw
(
new
Error
(
"
Failed
trying
to
get
the
document
of
an
invalid
stylesheet
"
)
)
;
}
toString
:
function
(
)
{
return
"
[
StyleRuleActor
for
"
+
this
.
rawRule
+
"
]
"
;
}
form
:
function
(
)
{
const
form
=
{
actor
:
this
.
actorID
type
:
this
.
type
line
:
this
.
line
|
|
undefined
column
:
this
.
column
traits
:
{
canSetRuleText
:
this
.
canSetRuleText
}
}
;
if
(
this
.
rawRule
.
parentRule
)
{
form
.
parentRule
=
this
.
pageStyle
.
_styleRef
(
this
.
rawRule
.
parentRule
)
.
actorID
;
if
(
this
.
rawRule
.
parentRule
.
type
=
=
=
CSSRule
.
MEDIA_RULE
)
{
form
.
media
=
[
]
;
for
(
let
i
=
0
n
=
this
.
rawRule
.
parentRule
.
media
.
length
;
i
<
n
;
i
+
+
)
{
form
.
media
.
push
(
this
.
rawRule
.
parentRule
.
media
.
item
(
i
)
)
;
}
}
}
if
(
this
.
_parentSheet
)
{
form
.
parentStyleSheet
=
this
.
pageStyle
.
_sheetRef
(
this
.
_parentSheet
)
.
actorID
;
}
form
.
authoredText
=
this
.
authoredText
;
switch
(
this
.
type
)
{
case
CSSRule
.
STYLE_RULE
:
form
.
selectors
=
CssLogic
.
getSelectors
(
this
.
rawRule
)
;
form
.
cssText
=
this
.
rawStyle
.
cssText
|
|
"
"
;
break
;
case
ELEMENT_STYLE
:
const
doc
=
this
.
rawNode
.
ownerDocument
;
form
.
href
=
doc
.
location
?
doc
.
location
.
href
:
"
"
;
form
.
cssText
=
this
.
rawStyle
.
cssText
|
|
"
"
;
form
.
authoredText
=
this
.
rawNode
.
getAttribute
(
"
style
"
)
;
break
;
case
CSSRule
.
CHARSET_RULE
:
form
.
encoding
=
this
.
rawRule
.
encoding
;
break
;
case
CSSRule
.
IMPORT_RULE
:
form
.
href
=
this
.
rawRule
.
href
;
break
;
case
CSSRule
.
KEYFRAMES_RULE
:
form
.
cssText
=
this
.
rawRule
.
cssText
;
form
.
name
=
this
.
rawRule
.
name
;
break
;
case
CSSRule
.
KEYFRAME_RULE
:
form
.
cssText
=
this
.
rawStyle
.
cssText
|
|
"
"
;
form
.
keyText
=
this
.
rawRule
.
keyText
|
|
"
"
;
break
;
}
if
(
form
.
authoredText
|
|
form
.
cssText
)
{
const
declarations
=
parseNamedDeclarations
(
isCssPropertyKnown
form
.
authoredText
|
|
form
.
cssText
true
)
;
const
CSS
=
this
.
pageStyle
.
inspector
.
targetActor
.
window
.
CSS
;
form
.
declarations
=
declarations
.
map
(
decl
=
>
{
decl
.
isValid
=
CSS
.
supports
(
{
decl
.
name
}
:
{
decl
.
value
}
)
;
decl
.
isNameValid
=
CSS
.
supports
(
decl
.
name
"
initial
"
)
;
return
decl
;
}
)
;
this
.
_declarations
=
declarations
;
}
return
form
;
}
_notifyLocationChanged
:
function
(
line
column
)
{
this
.
emit
(
"
location
-
changed
"
line
column
)
;
}
_computeRuleIndex
:
function
(
)
{
let
rule
=
this
.
rawRule
;
const
result
=
[
]
;
while
(
rule
)
{
let
cssRules
=
[
]
;
if
(
rule
.
parentRule
)
{
cssRules
=
rule
.
parentRule
.
cssRules
;
}
else
if
(
rule
.
parentStyleSheet
)
{
cssRules
=
rule
.
parentStyleSheet
.
cssRules
;
}
let
found
=
false
;
for
(
let
i
=
0
;
i
<
cssRules
.
length
;
i
+
+
)
{
if
(
rule
=
=
=
cssRules
.
item
(
i
)
)
{
found
=
true
;
result
.
unshift
(
i
)
;
break
;
}
}
if
(
!
found
)
{
this
.
_ruleIndex
=
null
;
return
;
}
rule
=
rule
.
parentRule
;
}
this
.
_ruleIndex
=
result
;
}
_getRuleFromIndex
:
function
(
parentSheet
)
{
let
currentRule
=
null
;
for
(
const
i
of
this
.
_ruleIndex
)
{
if
(
currentRule
=
=
=
null
)
{
currentRule
=
parentSheet
.
cssRules
[
i
]
;
}
else
{
currentRule
=
currentRule
.
cssRules
.
item
(
i
)
;
}
}
return
currentRule
;
}
_onStyleApplied
:
function
(
kind
)
{
if
(
kind
=
=
=
UPDATE_GENERAL
)
{
if
(
this
.
sheetActor
)
{
this
.
sheetActor
.
off
(
"
style
-
applied
"
this
.
_onStyleApplied
)
;
}
}
else
if
(
this
.
_ruleIndex
)
{
const
oldRule
=
this
.
rawRule
;
this
.
rawRule
=
this
.
_getRuleFromIndex
(
this
.
_parentSheet
)
;
this
.
pageStyle
.
updateStyleRef
(
oldRule
this
.
rawRule
this
)
;
const
line
=
InspectorUtils
.
getRelativeRuleLine
(
this
.
rawRule
)
;
const
column
=
InspectorUtils
.
getRuleColumn
(
this
.
rawRule
)
;
if
(
line
!
=
=
this
.
line
|
|
column
!
=
=
this
.
column
)
{
this
.
_notifyLocationChanged
(
line
column
)
;
}
this
.
line
=
line
;
this
.
column
=
column
;
}
}
getAuthoredCssText
:
function
(
)
{
if
(
!
this
.
canSetRuleText
|
|
(
this
.
type
!
=
=
CSSRule
.
STYLE_RULE
&
&
this
.
type
!
=
=
CSSRule
.
KEYFRAME_RULE
)
)
{
return
Promise
.
resolve
(
"
"
)
;
}
if
(
typeof
this
.
authoredText
=
=
=
"
string
"
)
{
return
Promise
.
resolve
(
this
.
authoredText
)
;
}
const
parentStyleSheet
=
this
.
pageStyle
.
_sheetRef
(
this
.
_parentSheet
)
;
return
parentStyleSheet
.
getText
(
)
.
then
(
(
longStr
)
=
>
{
const
cssText
=
longStr
.
str
;
const
{
text
}
=
getRuleText
(
cssText
this
.
line
this
.
column
)
;
this
.
authoredText
=
text
;
return
this
.
authoredText
;
}
)
;
}
async
setRuleText
(
newText
modifications
=
[
]
)
{
if
(
!
this
.
canSetRuleText
)
{
throw
new
Error
(
"
invalid
call
to
setRuleText
"
)
;
}
modifications
.
map
(
mod
=
>
this
.
logDeclarationChange
(
mod
)
)
;
if
(
this
.
type
=
=
=
ELEMENT_STYLE
)
{
this
.
rawNode
.
setAttribute
(
"
style
"
newText
)
;
}
else
{
const
parentStyleSheet
=
this
.
pageStyle
.
_sheetRef
(
this
.
_parentSheet
)
;
let
{
str
:
cssText
}
=
await
parentStyleSheet
.
getText
(
)
;
const
{
offset
text
}
=
getRuleText
(
cssText
this
.
line
this
.
column
)
;
cssText
=
cssText
.
substring
(
0
offset
)
+
newText
+
cssText
.
substring
(
offset
+
text
.
length
)
;
await
parentStyleSheet
.
update
(
cssText
false
UPDATE_PRESERVING_RULES
)
;
}
this
.
authoredText
=
newText
;
return
this
;
}
modifyProperties
:
function
(
modifications
)
{
let
document
;
if
(
this
.
rawNode
)
{
document
=
this
.
rawNode
.
ownerDocument
;
}
else
{
let
parentStyleSheet
=
this
.
_parentSheet
;
while
(
parentStyleSheet
.
ownerRule
)
{
parentStyleSheet
=
parentStyleSheet
.
ownerRule
.
parentStyleSheet
;
}
document
=
this
.
getDocument
(
parentStyleSheet
)
;
}
const
tempElement
=
document
.
createElementNS
(
XHTML_NS
"
div
"
)
;
for
(
const
mod
of
modifications
)
{
this
.
logDeclarationChange
(
mod
)
;
if
(
mod
.
type
=
=
=
"
set
"
)
{
tempElement
.
style
.
setProperty
(
mod
.
name
mod
.
value
mod
.
priority
|
|
"
"
)
;
this
.
rawStyle
.
setProperty
(
mod
.
name
tempElement
.
style
.
getPropertyValue
(
mod
.
name
)
mod
.
priority
|
|
"
"
)
;
}
else
if
(
mod
.
type
=
=
=
"
remove
"
|
|
mod
.
type
=
=
=
"
disable
"
)
{
this
.
rawStyle
.
removeProperty
(
mod
.
name
)
;
}
}
return
this
;
}
async
_addNewSelector
(
value
editAuthored
)
{
const
rule
=
this
.
rawRule
;
const
parentStyleSheet
=
this
.
_parentSheet
;
if
(
editAuthored
)
{
const
document
=
this
.
getDocument
(
this
.
_parentSheet
)
;
try
{
document
.
querySelector
(
value
)
;
}
catch
(
e
)
{
return
null
;
}
const
sheetActor
=
this
.
pageStyle
.
_sheetRef
(
parentStyleSheet
)
;
let
{
str
:
authoredText
}
=
await
sheetActor
.
getText
(
)
;
const
[
startOffset
endOffset
]
=
getSelectorOffsets
(
authoredText
this
.
line
this
.
column
)
;
authoredText
=
authoredText
.
substring
(
0
startOffset
)
+
value
+
authoredText
.
substring
(
endOffset
)
;
await
sheetActor
.
update
(
authoredText
false
UPDATE_PRESERVING_RULES
)
;
}
else
{
const
cssRules
=
parentStyleSheet
.
cssRules
;
const
cssText
=
rule
.
cssText
;
const
selectorText
=
rule
.
selectorText
;
for
(
let
i
=
0
;
i
<
cssRules
.
length
;
i
+
+
)
{
if
(
rule
=
=
=
cssRules
.
item
(
i
)
)
{
try
{
const
ruleText
=
cssText
.
slice
(
selectorText
.
length
)
.
trim
(
)
;
parentStyleSheet
.
insertRule
(
value
+
"
"
+
ruleText
i
)
;
parentStyleSheet
.
deleteRule
(
i
+
1
)
;
break
;
}
catch
(
e
)
{
return
null
;
}
}
}
}
return
this
.
_getRuleFromIndex
(
parentStyleSheet
)
;
}
logDeclarationChange
(
change
)
{
const
index
=
change
.
index
;
let
{
value
:
prevValue
name
:
prevName
priority
:
prevPriority
commentOffsets
}
=
this
.
_declarations
[
index
]
|
|
{
}
;
const
prevDisabled
=
!
!
commentOffsets
;
prevValue
=
(
prevValue
&
&
prevPriority
)
?
{
prevValue
}
!
important
:
prevValue
;
const
data
=
this
.
metadata
;
switch
(
change
.
type
)
{
case
"
set
"
:
data
.
type
=
prevValue
?
"
declaration
-
add
"
:
"
declaration
-
update
"
;
const
name
=
change
.
newName
?
change
.
newName
:
change
.
name
;
const
newValue
=
change
.
priority
?
{
change
.
value
}
!
important
:
change
.
value
;
const
value
=
change
.
newName
?
prevValue
:
newValue
;
data
.
add
=
[
{
property
:
name
value
index
}
]
;
if
(
prevValue
)
{
data
.
remove
=
[
{
property
:
prevName
value
:
prevValue
index
}
]
;
}
else
{
data
.
remove
=
null
;
}
if
(
prevDisabled
&
&
!
change
.
newName
&
&
prevValue
=
=
=
newValue
)
{
data
.
remove
=
null
;
}
break
;
case
"
remove
"
:
data
.
type
=
"
declaration
-
remove
"
;
data
.
add
=
null
;
data
.
remove
=
[
{
property
:
change
.
name
value
:
prevValue
index
}
]
;
break
;
case
"
disable
"
:
data
.
type
=
"
declaration
-
disable
"
;
data
.
add
=
null
;
data
.
remove
=
[
{
property
:
change
.
name
value
:
prevValue
index
}
]
;
break
;
}
TrackChangeEmitter
.
trackChange
(
data
)
;
}
logSelectorChange
(
oldSelector
newSelector
)
{
TrackChangeEmitter
.
trackChange
(
{
.
.
.
this
.
metadata
type
:
"
selector
-
remove
"
add
:
null
remove
:
null
selector
:
oldSelector
}
)
;
TrackChangeEmitter
.
trackChange
(
{
.
.
.
this
.
metadata
type
:
"
selector
-
add
"
add
:
null
remove
:
null
selector
:
newSelector
}
)
;
}
modifySelector
:
function
(
node
value
editAuthored
=
false
)
{
return
this
.
modifySelector2
(
node
value
editAuthored
)
;
}
modifySelector2
:
function
(
node
value
editAuthored
=
false
)
{
if
(
this
.
type
=
=
=
ELEMENT_STYLE
|
|
this
.
rawRule
.
selectorText
=
=
=
value
)
{
return
{
ruleProps
:
null
isMatching
:
true
}
;
}
const
oldValue
=
this
.
rawRule
.
selectorText
;
let
selectorPromise
=
this
.
_addNewSelector
(
value
editAuthored
)
;
if
(
editAuthored
)
{
selectorPromise
=
selectorPromise
.
then
(
(
newCssRule
)
=
>
{
if
(
newCssRule
)
{
this
.
logSelectorChange
(
oldValue
value
)
;
const
style
=
this
.
pageStyle
.
_styleRef
(
newCssRule
)
;
return
style
.
getAuthoredCssText
(
)
.
then
(
(
)
=
>
newCssRule
)
;
}
return
newCssRule
;
}
)
;
}
return
selectorPromise
.
then
(
(
newCssRule
)
=
>
{
let
ruleProps
=
null
;
let
isMatching
=
false
;
if
(
newCssRule
)
{
const
ruleEntry
=
this
.
pageStyle
.
findEntryMatchingRule
(
node
newCssRule
)
;
if
(
ruleEntry
.
length
=
=
=
1
)
{
ruleProps
=
this
.
pageStyle
.
getAppliedProps
(
node
ruleEntry
{
matchedSelectors
:
true
}
)
;
}
else
{
ruleProps
=
this
.
pageStyle
.
getNewAppliedProps
(
node
newCssRule
)
;
}
isMatching
=
ruleProps
.
entries
.
some
(
(
ruleProp
)
=
>
ruleProp
.
matchedSelectors
.
length
>
0
)
;
}
return
{
ruleProps
isMatching
}
;
}
)
;
}
}
)
;
function
getFontPreviewData
(
font
doc
options
)
{
options
=
options
|
|
{
}
;
const
previewText
=
options
.
previewText
|
|
FONT_PREVIEW_TEXT
;
const
previewFontSize
=
options
.
previewFontSize
|
|
FONT_PREVIEW_FONT_SIZE
;
const
fillStyle
=
options
.
fillStyle
|
|
FONT_PREVIEW_FILLSTYLE
;
const
fontStyle
=
options
.
fontStyle
|
|
"
"
;
const
canvas
=
doc
.
createElementNS
(
XHTML_NS
"
canvas
"
)
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
const
fontValue
=
fontStyle
+
"
"
+
previewFontSize
+
"
px
"
+
font
+
"
serif
"
;
ctx
.
font
=
fontValue
;
ctx
.
fillStyle
=
fillStyle
;
const
textWidth
=
Math
.
round
(
ctx
.
measureText
(
previewText
)
.
width
)
;
canvas
.
width
=
textWidth
*
2
+
FONT_PREVIEW_OFFSET
*
4
;
canvas
.
height
=
previewFontSize
*
3
;
ctx
.
font
=
fontValue
;
ctx
.
fillStyle
=
fillStyle
;
ctx
.
textBaseline
=
"
top
"
;
ctx
.
scale
(
2
2
)
;
ctx
.
fillText
(
previewText
FONT_PREVIEW_OFFSET
Math
.
round
(
previewFontSize
/
3
)
)
;
const
dataURL
=
canvas
.
toDataURL
(
"
image
/
png
"
)
;
return
{
dataURL
:
dataURL
size
:
textWidth
+
FONT_PREVIEW_OFFSET
*
2
}
;
}
exports
.
getFontPreviewData
=
getFontPreviewData
;
function
getRuleText
(
initialText
line
column
)
{
if
(
typeof
line
=
=
=
"
undefined
"
|
|
typeof
column
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
Location
information
is
missing
"
)
;
}
const
{
offset
:
textOffset
text
}
=
getTextAtLineColumn
(
initialText
line
column
)
;
const
lexer
=
getCSSLexer
(
text
)
;
while
(
true
)
{
const
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
)
{
throw
new
Error
(
"
couldn
'
t
find
start
of
the
rule
"
)
;
}
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
{
"
)
{
break
;
}
}
let
braceDepth
=
1
;
let
startOffset
endOffset
;
while
(
true
)
{
const
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
)
{
break
;
}
if
(
startOffset
=
=
=
undefined
)
{
startOffset
=
token
.
startOffset
;
}
if
(
token
.
tokenType
=
=
=
"
symbol
"
)
{
if
(
token
.
text
=
=
=
"
{
"
)
{
+
+
braceDepth
;
}
else
if
(
token
.
text
=
=
=
"
}
"
)
{
-
-
braceDepth
;
if
(
braceDepth
=
=
0
)
{
break
;
}
}
}
endOffset
=
token
.
endOffset
;
}
if
(
startOffset
=
=
=
undefined
)
{
return
{
offset
:
0
text
:
"
"
}
;
}
if
(
endOffset
=
=
=
undefined
)
{
endOffset
=
startOffset
;
}
return
{
offset
:
textOffset
+
startOffset
text
:
text
.
substring
(
startOffset
endOffset
)
}
;
}
exports
.
getRuleText
=
getRuleText
;
function
getSelectorOffsets
(
initialText
line
column
)
{
if
(
typeof
line
=
=
=
"
undefined
"
|
|
typeof
column
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
Location
information
is
missing
"
)
;
}
const
{
offset
:
textOffset
text
}
=
getTextAtLineColumn
(
initialText
line
column
)
;
const
lexer
=
getCSSLexer
(
text
)
;
let
endOffset
;
while
(
true
)
{
const
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
{
"
)
{
if
(
endOffset
=
=
=
undefined
)
{
break
;
}
return
[
textOffset
textOffset
+
endOffset
]
;
}
if
(
token
.
tokenType
!
=
=
"
comment
"
&
&
token
.
tokenType
!
=
=
"
whitespace
"
)
{
endOffset
=
token
.
endOffset
;
}
}
throw
new
Error
(
"
could
not
find
bounds
of
rule
"
)
;
}
function
getTextAtLineColumn
(
text
line
column
)
{
let
offset
;
if
(
line
>
1
)
{
const
rx
=
new
RegExp
(
"
(
?
:
[
^
\
\
r
\
\
n
\
\
f
]
*
(
?
:
\
\
r
\
\
n
|
\
\
n
|
\
\
r
|
\
\
f
)
)
{
"
+
(
line
-
1
)
+
"
}
"
)
;
offset
=
rx
.
exec
(
text
)
[
0
]
.
length
;
}
else
{
offset
=
0
;
}
offset
+
=
column
-
1
;
return
{
offset
:
offset
text
:
text
.
substr
(
offset
)
}
;
}
exports
.
getTextAtLineColumn
=
getTextAtLineColumn
;
