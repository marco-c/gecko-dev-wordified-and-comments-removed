"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
{
Actor
ActorClassWithSpec
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
flexboxSpec
flexItemSpec
gridSpec
layoutSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
layout
"
)
;
const
{
SHOW_ELEMENT
}
=
require
(
"
devtools
/
shared
/
dom
-
node
-
filter
-
constants
"
)
;
const
{
getStringifiableFragments
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
css
-
grid
-
utils
"
)
;
loader
.
lazyRequireGetter
(
this
"
getCSSStyleRules
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
actors
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
nodeConstants
"
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
const
FlexboxActor
=
ActorClassWithSpec
(
flexboxSpec
{
initialize
(
layoutActor
containerEl
)
{
Actor
.
prototype
.
initialize
.
call
(
this
layoutActor
.
conn
)
;
this
.
containerEl
=
containerEl
;
this
.
walker
=
layoutActor
.
walker
;
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
containerEl
=
null
;
this
.
walker
=
null
;
}
form
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
const
styles
=
CssLogic
.
getComputedStyle
(
this
.
containerEl
)
;
const
form
=
{
actor
:
this
.
actorID
properties
:
{
"
align
-
content
"
:
styles
.
alignContent
"
align
-
items
"
:
styles
.
alignItems
"
flex
-
direction
"
:
styles
.
flexDirection
"
flex
-
wrap
"
:
styles
.
flexWrap
"
justify
-
content
"
:
styles
.
justifyContent
}
}
;
if
(
this
.
walker
.
hasNode
(
this
.
containerEl
)
)
{
form
.
containerNodeActorID
=
this
.
walker
.
getNode
(
this
.
containerEl
)
.
actorID
;
}
return
form
;
}
getFlexItems
(
)
{
if
(
isNodeDead
(
this
.
containerEl
)
)
{
return
[
]
;
}
const
flex
=
this
.
containerEl
.
getAsFlexContainer
(
)
;
if
(
!
flex
)
{
return
[
]
;
}
const
flexItemActors
=
[
]
;
for
(
const
line
of
flex
.
getLines
(
)
)
{
for
(
const
item
of
line
.
getItems
(
)
)
{
flexItemActors
.
push
(
new
FlexItemActor
(
this
item
.
node
{
crossMaxSize
:
item
.
crossMaxSize
crossMinSize
:
item
.
crossMinSize
mainBaseSize
:
item
.
mainBaseSize
mainDeltaSize
:
item
.
mainDeltaSize
mainMaxSize
:
item
.
mainMaxSize
mainMinSize
:
item
.
mainMinSize
lineGrowthState
:
line
.
growthState
clampState
:
item
.
clampState
}
)
)
;
}
}
return
flexItemActors
;
}
}
)
;
const
FlexItemActor
=
ActorClassWithSpec
(
flexItemSpec
{
initialize
(
flexboxActor
element
flexItemSizing
)
{
Actor
.
prototype
.
initialize
.
call
(
this
flexboxActor
.
conn
)
;
this
.
containerEl
=
flexboxActor
.
containerEl
;
this
.
element
=
element
;
this
.
flexItemSizing
=
flexItemSizing
;
this
.
walker
=
flexboxActor
.
walker
;
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
containerEl
=
null
;
this
.
element
=
null
;
this
.
flexItemSizing
=
null
;
this
.
walker
=
null
;
}
form
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
const
{
flexDirection
}
=
CssLogic
.
getComputedStyle
(
this
.
containerEl
)
;
const
dimension
=
flexDirection
.
startsWith
(
"
row
"
)
?
"
width
"
:
"
height
"
;
const
properties
=
{
"
flex
-
basis
"
:
"
"
"
flex
-
grow
"
:
"
"
"
flex
-
shrink
"
:
"
"
[
min
-
{
dimension
}
]
:
"
"
[
max
-
{
dimension
}
]
:
"
"
[
dimension
]
:
"
"
}
;
const
isElementNode
=
this
.
element
.
nodeType
=
=
=
this
.
element
.
ELEMENT_NODE
;
if
(
isElementNode
)
{
for
(
const
name
in
properties
)
{
let
value
=
"
"
;
if
(
this
.
element
.
style
&
&
this
.
element
.
style
[
name
]
&
&
this
.
element
.
style
[
name
]
!
=
=
"
auto
"
)
{
value
=
this
.
element
.
style
[
name
]
;
}
else
{
const
cssRules
=
getCSSStyleRules
(
this
.
element
)
;
for
(
const
rule
of
cssRules
)
{
const
rulePropertyValue
=
rule
.
style
.
getPropertyValue
(
name
)
;
if
(
rulePropertyValue
&
&
rulePropertyValue
!
=
=
"
auto
"
)
{
value
=
rulePropertyValue
;
}
}
}
properties
[
name
]
=
value
;
}
}
const
{
flexGrow
flexShrink
}
=
isElementNode
?
CssLogic
.
getComputedStyle
(
this
.
element
)
:
{
flexGrow
:
null
flexShrink
:
null
}
;
const
computedStyle
=
{
flexGrow
flexShrink
}
;
const
form
=
{
actor
:
this
.
actorID
flexItemSizing
:
this
.
flexItemSizing
properties
computedStyle
}
;
if
(
this
.
walker
.
hasNode
(
this
.
element
)
)
{
form
.
nodeActorID
=
this
.
walker
.
getNode
(
this
.
element
)
.
actorID
;
}
return
form
;
}
}
)
;
const
GridActor
=
ActorClassWithSpec
(
gridSpec
{
initialize
(
layoutActor
containerEl
)
{
Actor
.
prototype
.
initialize
.
call
(
this
layoutActor
.
conn
)
;
this
.
containerEl
=
containerEl
;
this
.
walker
=
layoutActor
.
walker
;
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
containerEl
=
null
;
this
.
gridFragments
=
null
;
this
.
walker
=
null
;
}
form
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
const
gridFragments
=
this
.
containerEl
.
getGridFragments
(
)
;
this
.
gridFragments
=
getStringifiableFragments
(
gridFragments
)
;
const
{
direction
writingMode
}
=
CssLogic
.
getComputedStyle
(
this
.
containerEl
)
;
const
form
=
{
actor
:
this
.
actorID
direction
gridFragments
:
this
.
gridFragments
writingMode
}
;
if
(
this
.
walker
.
hasNode
(
this
.
containerEl
)
)
{
form
.
containerNodeActorID
=
this
.
walker
.
getNode
(
this
.
containerEl
)
.
actorID
;
}
return
form
;
}
}
)
;
const
LayoutActor
=
ActorClassWithSpec
(
layoutSpec
{
initialize
(
conn
targetActor
walker
)
{
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
targetActor
=
targetActor
;
this
.
walker
=
walker
;
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
targetActor
=
null
;
this
.
walker
=
null
;
}
getCurrentDisplay
(
node
type
onlyLookAtCurrentNode
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
if
(
node
.
rawNode
)
{
node
=
node
.
rawNode
;
}
const
treeWalker
=
this
.
walker
.
getDocumentWalker
(
node
SHOW_ELEMENT
)
;
let
currentNode
=
treeWalker
.
currentNode
;
let
displayType
=
this
.
walker
.
getNode
(
currentNode
)
.
displayType
;
if
(
currentNode
.
nodeType
=
=
=
currentNode
.
ELEMENT_NODE
)
{
if
(
!
displayType
)
{
return
null
;
}
if
(
type
=
=
"
flex
"
)
{
if
(
displayType
=
=
"
inline
-
flex
"
|
|
displayType
=
=
"
flex
"
)
{
return
new
FlexboxActor
(
this
currentNode
)
;
}
else
if
(
onlyLookAtCurrentNode
)
{
return
null
;
}
}
else
if
(
type
=
=
"
grid
"
&
&
(
displayType
=
=
"
inline
-
grid
"
|
|
displayType
=
=
"
grid
"
)
)
{
return
new
GridActor
(
this
currentNode
)
;
}
}
while
(
(
currentNode
=
treeWalker
.
parentNode
(
)
)
)
{
if
(
!
currentNode
)
{
break
;
}
displayType
=
this
.
walker
.
getNode
(
currentNode
)
.
displayType
;
if
(
type
=
=
"
flex
"
&
&
(
displayType
=
=
"
inline
-
flex
"
|
|
displayType
=
=
"
flex
"
)
)
{
return
new
FlexboxActor
(
this
currentNode
)
;
}
else
if
(
type
=
=
"
grid
"
&
&
(
displayType
=
=
"
inline
-
grid
"
|
|
displayType
=
=
"
grid
"
)
)
{
return
new
GridActor
(
this
currentNode
)
;
}
else
if
(
displayType
=
=
"
contents
"
)
{
continue
;
}
break
;
}
return
null
;
}
getCurrentGrid
(
node
)
{
return
this
.
getCurrentDisplay
(
node
"
grid
"
)
;
}
getCurrentFlexbox
(
node
onlyLookAtParents
)
{
if
(
onlyLookAtParents
)
{
node
=
node
.
rawNode
.
parentNode
;
}
return
this
.
getCurrentDisplay
(
node
"
flex
"
onlyLookAtParents
)
;
}
getGrids
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
[
]
;
}
if
(
node
.
rawNode
)
{
node
=
node
.
rawNode
;
}
if
(
node
.
nodeType
=
=
=
nodeConstants
.
DOCUMENT_NODE
)
{
node
=
node
.
documentElement
;
}
const
gridElements
=
node
.
getElementsWithGrid
(
)
;
let
gridActors
=
gridElements
.
map
(
n
=
>
new
GridActor
(
this
n
)
)
;
const
frames
=
node
.
querySelectorAll
(
"
iframe
frame
"
)
;
for
(
const
frame
of
frames
)
{
gridActors
=
gridActors
.
concat
(
this
.
getGrids
(
frame
.
contentDocument
)
)
;
}
return
gridActors
;
}
}
)
;
function
isNodeDead
(
node
)
{
return
!
node
|
|
(
node
.
rawNode
&
&
Cu
.
isDeadWrapper
(
node
.
rawNode
)
)
;
}
exports
.
FlexboxActor
=
FlexboxActor
;
exports
.
FlexItemActor
=
FlexItemActor
;
exports
.
GridActor
=
GridActor
;
exports
.
LayoutActor
=
LayoutActor
;
