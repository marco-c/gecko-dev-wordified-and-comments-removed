"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
{
Actor
ActorClassWithSpec
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
flexboxSpec
gridSpec
layoutSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
layout
"
)
;
const
nodeFilterConstants
=
require
(
"
devtools
/
shared
/
dom
-
node
-
filter
-
constants
"
)
;
const
{
getStringifiableFragments
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
css
-
grid
-
utils
"
)
;
loader
.
lazyRequireGetter
(
this
"
nodeConstants
"
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
actors
/
inspector
/
css
-
logic
"
true
)
;
const
FlexboxActor
=
ActorClassWithSpec
(
flexboxSpec
{
initialize
(
layoutActor
containerEl
)
{
Actor
.
prototype
.
initialize
.
call
(
this
layoutActor
.
conn
)
;
this
.
containerEl
=
containerEl
;
this
.
walker
=
layoutActor
.
walker
;
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
containerEl
=
null
;
this
.
walker
=
null
;
}
form
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
const
styles
=
CssLogic
.
getComputedStyle
(
this
.
containerEl
)
;
const
form
=
{
actor
:
this
.
actorID
properties
:
{
"
align
-
content
"
:
styles
.
alignContent
"
align
-
items
"
:
styles
.
alignItems
"
flex
-
direction
"
:
styles
.
flexDirection
"
flex
-
wrap
"
:
styles
.
flexWrap
"
justify
-
content
"
:
styles
.
justifyContent
}
}
;
if
(
this
.
walker
.
hasNode
(
this
.
containerEl
)
)
{
form
.
containerNodeActorID
=
this
.
walker
.
getNode
(
this
.
containerEl
)
.
actorID
;
}
return
form
;
}
}
)
;
const
GridActor
=
ActorClassWithSpec
(
gridSpec
{
initialize
(
layoutActor
containerEl
)
{
Actor
.
prototype
.
initialize
.
call
(
this
layoutActor
.
conn
)
;
this
.
containerEl
=
containerEl
;
this
.
walker
=
layoutActor
.
walker
;
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
containerEl
=
null
;
this
.
gridFragments
=
null
;
this
.
walker
=
null
;
}
form
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
const
gridFragments
=
this
.
containerEl
.
getGridFragments
(
)
;
this
.
gridFragments
=
getStringifiableFragments
(
gridFragments
)
;
const
{
direction
writingMode
}
=
CssLogic
.
getComputedStyle
(
this
.
containerEl
)
;
const
form
=
{
actor
:
this
.
actorID
direction
gridFragments
:
this
.
gridFragments
writingMode
}
;
if
(
this
.
walker
.
hasNode
(
this
.
containerEl
)
)
{
form
.
containerNodeActorID
=
this
.
walker
.
getNode
(
this
.
containerEl
)
.
actorID
;
}
return
form
;
}
}
)
;
const
LayoutActor
=
ActorClassWithSpec
(
layoutSpec
{
initialize
(
conn
targetActor
walker
)
{
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
targetActor
=
targetActor
;
this
.
walker
=
walker
;
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
targetActor
=
null
;
this
.
walker
=
null
;
}
getCurrentDisplay
(
node
type
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
if
(
node
.
rawNode
)
{
node
=
node
.
rawNode
;
}
const
treeWalker
=
this
.
walker
.
getDocumentWalker
(
node
nodeFilterConstants
.
SHOW_ELEMENT
)
;
let
currentNode
=
treeWalker
.
currentNode
;
let
displayType
=
this
.
walker
.
getNode
(
currentNode
)
.
displayType
;
if
(
!
displayType
)
{
return
null
;
}
if
(
type
=
=
"
flex
"
&
&
(
displayType
=
=
"
inline
-
flex
"
|
|
displayType
=
=
"
flex
"
)
)
{
return
new
FlexboxActor
(
this
currentNode
)
;
}
else
if
(
type
=
=
"
grid
"
&
&
(
displayType
=
=
"
inline
-
grid
"
|
|
displayType
=
=
"
grid
"
)
)
{
return
new
GridActor
(
this
currentNode
)
;
}
while
(
(
currentNode
=
treeWalker
.
parentNode
(
)
)
)
{
if
(
!
currentNode
)
{
break
;
}
displayType
=
this
.
walker
.
getNode
(
currentNode
)
.
displayType
;
if
(
type
=
=
"
flex
"
&
&
(
displayType
=
=
"
inline
-
flex
"
|
|
displayType
=
=
"
flex
"
)
)
{
return
new
FlexboxActor
(
this
currentNode
)
;
}
else
if
(
type
=
=
"
grid
"
&
&
(
displayType
=
=
"
inline
-
grid
"
|
|
displayType
=
=
"
grid
"
)
)
{
return
new
GridActor
(
this
currentNode
)
;
}
else
if
(
displayType
=
=
"
contents
"
)
{
continue
;
}
break
;
}
return
null
;
}
getCurrentGrid
(
node
)
{
return
this
.
getCurrentDisplay
(
node
"
grid
"
)
;
}
getCurrentFlexbox
(
node
)
{
return
this
.
getCurrentDisplay
(
node
"
flex
"
)
;
}
getGrids
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
[
]
;
}
if
(
node
.
rawNode
)
{
node
=
node
.
rawNode
;
}
if
(
node
.
nodeType
=
=
=
nodeConstants
.
DOCUMENT_NODE
)
{
node
=
node
.
documentElement
;
}
const
gridElements
=
node
.
getElementsWithGrid
(
)
;
let
gridActors
=
gridElements
.
map
(
n
=
>
new
GridActor
(
this
n
)
)
;
const
frames
=
node
.
querySelectorAll
(
"
iframe
frame
"
)
;
for
(
const
frame
of
frames
)
{
gridActors
=
gridActors
.
concat
(
this
.
getGrids
(
frame
.
contentDocument
)
)
;
}
return
gridActors
;
}
}
)
;
function
isNodeDead
(
node
)
{
return
!
node
|
|
(
node
.
rawNode
&
&
Cu
.
isDeadWrapper
(
node
.
rawNode
)
)
;
}
exports
.
FlexboxActor
=
FlexboxActor
;
exports
.
GridActor
=
GridActor
;
exports
.
LayoutActor
=
LayoutActor
;
