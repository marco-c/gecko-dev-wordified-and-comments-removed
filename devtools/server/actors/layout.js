"
use
strict
"
;
const
{
Actor
ActorClassWithSpec
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
flexboxSpec
gridSpec
layoutSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
layout
"
)
;
const
nodeFilterConstants
=
require
(
"
devtools
/
shared
/
dom
-
node
-
filter
-
constants
"
)
;
const
{
getStringifiableFragments
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
css
-
grid
-
utils
"
)
;
loader
.
lazyRequireGetter
(
this
"
nodeConstants
"
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
css
-
logic
"
true
)
;
const
FlexboxActor
=
ActorClassWithSpec
(
flexboxSpec
{
initialize
(
layoutActor
containerEl
)
{
Actor
.
prototype
.
initialize
.
call
(
this
layoutActor
.
conn
)
;
this
.
containerEl
=
containerEl
;
this
.
walker
=
layoutActor
.
walker
;
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
containerEl
=
null
;
this
.
walker
=
null
;
}
form
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
let
form
=
{
actor
:
this
.
actorID
}
;
if
(
this
.
walker
.
hasNode
(
this
.
containerEl
)
)
{
form
.
containerNodeActorID
=
this
.
walker
.
getNode
(
this
.
containerEl
)
.
actorID
;
}
return
form
;
}
}
)
;
const
GridActor
=
ActorClassWithSpec
(
gridSpec
{
initialize
(
layoutActor
containerEl
)
{
Actor
.
prototype
.
initialize
.
call
(
this
layoutActor
.
conn
)
;
this
.
containerEl
=
containerEl
;
this
.
walker
=
layoutActor
.
walker
;
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
containerEl
=
null
;
this
.
gridFragments
=
null
;
this
.
walker
=
null
;
}
form
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
let
gridFragments
=
this
.
containerEl
.
getGridFragments
(
)
;
this
.
gridFragments
=
getStringifiableFragments
(
gridFragments
)
;
let
form
=
{
actor
:
this
.
actorID
gridFragments
:
this
.
gridFragments
}
;
if
(
this
.
walker
.
hasNode
(
this
.
containerEl
)
)
{
form
.
containerNodeActorID
=
this
.
walker
.
getNode
(
this
.
containerEl
)
.
actorID
;
}
return
form
;
}
}
)
;
const
LayoutActor
=
ActorClassWithSpec
(
layoutSpec
{
initialize
(
conn
tabActor
walker
)
{
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
tabActor
=
tabActor
;
this
.
walker
=
walker
;
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
tabActor
=
null
;
this
.
walker
=
null
;
}
getFlexbox
(
rootNode
)
{
let
flexboxes
=
[
]
;
if
(
!
rootNode
)
{
return
flexboxes
;
}
let
treeWalker
=
this
.
walker
.
getDocumentWalker
(
rootNode
nodeFilterConstants
.
SHOW_ELEMENT
)
;
while
(
treeWalker
.
nextNode
(
)
)
{
let
currentNode
=
treeWalker
.
currentNode
;
let
computedStyle
=
CssLogic
.
getComputedStyle
(
currentNode
)
;
if
(
!
computedStyle
)
{
continue
;
}
if
(
computedStyle
.
display
=
=
"
inline
-
flex
"
|
|
computedStyle
.
display
=
=
"
flex
"
)
{
let
flexboxActor
=
new
FlexboxActor
(
this
currentNode
)
;
flexboxes
.
push
(
flexboxActor
)
;
}
}
return
flexboxes
;
}
getAllFlexbox
(
rootNode
traverseFrames
)
{
let
flexboxes
=
[
]
;
if
(
!
rootNode
)
{
return
flexboxes
;
}
if
(
!
traverseFrames
)
{
return
this
.
getFlexbox
(
rootNode
.
rawNode
)
;
}
for
(
let
{
document
}
of
this
.
tabActor
.
windows
)
{
flexboxes
=
[
.
.
.
flexboxes
.
.
.
this
.
getFlexbox
(
document
.
documentElement
)
]
;
}
return
flexboxes
;
}
getGrids
(
node
)
{
if
(
!
node
)
{
return
[
]
;
}
if
(
node
.
rawNode
)
{
node
=
node
.
rawNode
;
}
if
(
node
.
nodeType
=
=
=
nodeConstants
.
DOCUMENT_NODE
)
{
node
=
node
.
documentElement
;
}
let
gridElements
=
node
.
getElementsWithGrid
(
)
;
let
gridActors
=
gridElements
.
map
(
n
=
>
new
GridActor
(
this
n
)
)
;
let
frames
=
node
.
querySelectorAll
(
"
iframe
frame
"
)
;
for
(
let
frame
of
frames
)
{
gridActors
=
gridActors
.
concat
(
this
.
getGrids
(
frame
.
contentDocument
)
)
;
}
return
gridActors
;
}
}
)
;
exports
.
FlexboxActor
=
FlexboxActor
;
exports
.
GridActor
=
GridActor
;
exports
.
LayoutActor
=
LayoutActor
;
