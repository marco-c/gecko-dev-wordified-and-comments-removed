"
use
strict
"
;
const
{
Cu
Ci
}
=
require
(
"
chrome
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
Actor
}
=
protocol
;
const
{
animationPlayerSpec
animationsSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
animation
"
)
;
const
ANIMATION_TYPES
=
{
CSS_ANIMATION
:
"
cssanimation
"
CSS_TRANSITION
:
"
csstransition
"
SCRIPT_ANIMATION
:
"
scriptanimation
"
UNKNOWN
:
"
unknown
"
}
;
exports
.
ANIMATION_TYPES
=
ANIMATION_TYPES
;
var
AnimationPlayerActor
=
protocol
.
ActorClassWithSpec
(
animationPlayerSpec
{
initialize
:
function
(
animationsActor
player
)
{
Actor
.
prototype
.
initialize
.
call
(
this
animationsActor
.
conn
)
;
this
.
onAnimationMutation
=
this
.
onAnimationMutation
.
bind
(
this
)
;
this
.
walker
=
animationsActor
.
walker
;
this
.
player
=
player
;
this
.
observer
=
new
this
.
window
.
MutationObserver
(
this
.
onAnimationMutation
)
;
if
(
this
.
isPseudoElement
)
{
this
.
observer
.
observe
(
this
.
node
.
parentElement
{
animations
:
true
subtree
:
true
}
)
;
}
else
{
this
.
observer
.
observe
(
this
.
node
{
animations
:
true
}
)
;
}
}
destroy
:
function
(
)
{
if
(
this
.
observer
&
&
!
Cu
.
isDeadWrapper
(
this
.
observer
)
)
{
this
.
observer
.
disconnect
(
)
;
}
this
.
player
=
this
.
observer
=
this
.
walker
=
null
;
Actor
.
prototype
.
destroy
.
call
(
this
)
;
}
get
isPseudoElement
(
)
{
return
!
this
.
player
.
effect
.
target
.
ownerDocument
;
}
get
node
(
)
{
if
(
this
.
_node
)
{
return
this
.
_node
;
}
let
node
=
this
.
player
.
effect
.
target
;
if
(
this
.
isPseudoElement
)
{
let
treeWalker
=
this
.
walker
.
getDocumentWalker
(
node
.
parentElement
)
;
while
(
treeWalker
.
nextNode
(
)
)
{
let
currentNode
=
treeWalker
.
currentNode
;
if
(
(
currentNode
.
nodeName
=
=
=
"
_moz_generated_content_before
"
&
&
node
.
type
=
=
=
"
:
:
before
"
)
|
|
(
currentNode
.
nodeName
=
=
=
"
_moz_generated_content_after
"
&
&
node
.
type
=
=
=
"
:
:
after
"
)
)
{
this
.
_node
=
currentNode
;
}
}
}
else
{
this
.
_node
=
node
;
}
return
this
.
_node
;
}
get
window
(
)
{
return
this
.
node
.
ownerDocument
.
defaultView
;
}
release
:
function
(
)
{
}
form
:
function
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
let
data
=
this
.
getCurrentState
(
)
;
data
.
actor
=
this
.
actorID
;
if
(
this
.
walker
&
&
this
.
walker
.
hasNode
(
this
.
node
)
)
{
data
.
animationTargetNodeActorID
=
this
.
walker
.
getNode
(
this
.
node
)
.
actorID
;
}
return
data
;
}
isCssAnimation
:
function
(
player
=
this
.
player
)
{
return
player
instanceof
this
.
window
.
CSSAnimation
;
}
isCssTransition
:
function
(
player
=
this
.
player
)
{
return
player
instanceof
this
.
window
.
CSSTransition
;
}
isScriptAnimation
:
function
(
player
=
this
.
player
)
{
return
player
instanceof
this
.
window
.
Animation
&
&
!
(
player
instanceof
this
.
window
.
CSSAnimation
|
|
player
instanceof
this
.
window
.
CSSTransition
)
;
}
getType
:
function
(
)
{
if
(
this
.
isCssAnimation
(
)
)
{
return
ANIMATION_TYPES
.
CSS_ANIMATION
;
}
else
if
(
this
.
isCssTransition
(
)
)
{
return
ANIMATION_TYPES
.
CSS_TRANSITION
;
}
else
if
(
this
.
isScriptAnimation
(
)
)
{
return
ANIMATION_TYPES
.
SCRIPT_ANIMATION
;
}
return
ANIMATION_TYPES
.
UNKNOWN
;
}
getName
:
function
(
)
{
if
(
this
.
player
.
id
)
{
return
this
.
player
.
id
;
}
else
if
(
this
.
isCssAnimation
(
)
)
{
return
this
.
player
.
animationName
;
}
else
if
(
this
.
isCssTransition
(
)
)
{
return
this
.
player
.
transitionProperty
;
}
return
"
"
;
}
getDuration
:
function
(
)
{
return
this
.
player
.
effect
.
getComputedTiming
(
)
.
duration
;
}
getDelay
:
function
(
)
{
return
this
.
player
.
effect
.
getComputedTiming
(
)
.
delay
;
}
getEndDelay
:
function
(
)
{
return
this
.
player
.
effect
.
getComputedTiming
(
)
.
endDelay
;
}
getIterationCount
:
function
(
)
{
let
iterations
=
this
.
player
.
effect
.
getComputedTiming
(
)
.
iterations
;
return
iterations
=
=
=
"
Infinity
"
?
null
:
iterations
;
}
getIterationStart
:
function
(
)
{
return
this
.
player
.
effect
.
getComputedTiming
(
)
.
iterationStart
;
}
getEasing
:
function
(
)
{
return
this
.
player
.
effect
.
timing
.
easing
;
}
getFill
:
function
(
)
{
return
this
.
player
.
effect
.
getComputedTiming
(
)
.
fill
;
}
getDirection
:
function
(
)
{
return
this
.
player
.
effect
.
getComputedTiming
(
)
.
direction
;
}
getAnimationTimingFunction
:
function
(
)
{
if
(
!
this
.
isCssAnimation
(
)
)
{
return
null
;
}
let
pseudo
=
null
;
let
target
=
this
.
player
.
effect
.
target
;
if
(
target
.
type
)
{
pseudo
=
target
.
type
;
target
=
target
.
parentElement
;
}
return
this
.
window
.
getComputedStyle
(
target
pseudo
)
.
animationTimingFunction
;
}
getPropertiesCompositorStatus
:
function
(
)
{
let
properties
=
this
.
player
.
effect
.
getProperties
(
)
;
return
properties
.
map
(
prop
=
>
{
return
{
property
:
prop
.
property
runningOnCompositor
:
prop
.
runningOnCompositor
warning
:
prop
.
warning
}
;
}
)
;
}
getState
:
function
(
)
{
if
(
this
.
player
.
startTime
)
{
this
.
previousStartTime
=
this
.
player
.
startTime
;
}
return
{
type
:
this
.
getType
(
)
startTime
:
this
.
player
.
startTime
previousStartTime
:
this
.
previousStartTime
currentTime
:
this
.
player
.
currentTime
playState
:
this
.
player
.
playState
playbackRate
:
this
.
player
.
playbackRate
name
:
this
.
getName
(
)
duration
:
this
.
getDuration
(
)
delay
:
this
.
getDelay
(
)
endDelay
:
this
.
getEndDelay
(
)
iterationCount
:
this
.
getIterationCount
(
)
iterationStart
:
this
.
getIterationStart
(
)
fill
:
this
.
getFill
(
)
easing
:
this
.
getEasing
(
)
direction
:
this
.
getDirection
(
)
animationTimingFunction
:
this
.
getAnimationTimingFunction
(
)
isRunningOnCompositor
:
this
.
getPropertiesCompositorStatus
(
)
.
some
(
propState
=
>
propState
.
runningOnCompositor
)
propertyState
:
this
.
getPropertiesCompositorStatus
(
)
documentCurrentTime
:
this
.
node
.
ownerDocument
.
timeline
.
currentTime
}
;
}
getCurrentState
:
function
(
)
{
let
newState
=
this
.
getState
(
)
;
let
sentState
=
{
}
;
if
(
this
.
currentState
)
{
for
(
let
key
in
newState
)
{
if
(
typeof
this
.
currentState
[
key
]
=
=
=
"
undefined
"
|
|
this
.
currentState
[
key
]
!
=
=
newState
[
key
]
)
{
sentState
[
key
]
=
newState
[
key
]
;
}
}
}
else
{
sentState
=
newState
;
}
this
.
currentState
=
newState
;
return
sentState
;
}
onAnimationMutation
:
function
(
mutations
)
{
let
isCurrentAnimation
=
animation
=
>
animation
=
=
=
this
.
player
;
let
hasCurrentAnimation
=
animations
=
>
animations
.
some
(
isCurrentAnimation
)
;
let
hasChanged
=
false
;
for
(
let
{
removedAnimations
changedAnimations
}
of
mutations
)
{
if
(
hasCurrentAnimation
(
removedAnimations
)
)
{
this
.
currentState
=
null
;
}
if
(
hasCurrentAnimation
(
changedAnimations
)
)
{
let
newState
=
this
.
getState
(
)
;
let
oldState
=
this
.
currentState
;
hasChanged
=
newState
.
delay
!
=
=
oldState
.
delay
|
|
newState
.
iterationCount
!
=
=
oldState
.
iterationCount
|
|
newState
.
iterationStart
!
=
=
oldState
.
iterationStart
|
|
newState
.
duration
!
=
=
oldState
.
duration
|
|
newState
.
endDelay
!
=
=
oldState
.
endDelay
;
break
;
}
}
if
(
hasChanged
)
{
this
.
emit
(
"
changed
"
this
.
getCurrentState
(
)
)
;
}
}
pause
:
function
(
)
{
this
.
player
.
pause
(
)
;
return
this
.
player
.
ready
;
}
play
:
function
(
)
{
this
.
player
.
play
(
)
;
return
this
.
player
.
ready
;
}
ready
:
function
(
)
{
return
this
.
player
.
ready
;
}
setCurrentTime
:
function
(
currentTime
)
{
const
timing
=
this
.
player
.
effect
.
getComputedTiming
(
)
;
if
(
timing
.
delay
<
0
)
{
currentTime
+
=
timing
.
delay
;
}
if
(
currentTime
<
0
)
{
currentTime
=
0
;
}
else
if
(
currentTime
*
this
.
player
.
playbackRate
>
timing
.
endTime
)
{
currentTime
=
timing
.
endTime
;
}
this
.
player
.
currentTime
=
currentTime
*
this
.
player
.
playbackRate
;
}
setPlaybackRate
:
function
(
playbackRate
)
{
this
.
player
.
playbackRate
=
playbackRate
;
}
getFrames
:
function
(
)
{
return
this
.
player
.
effect
.
getKeyframes
(
)
;
}
getProperties
:
function
(
)
{
const
properties
=
this
.
player
.
effect
.
getProperties
(
)
.
map
(
property
=
>
{
return
{
name
:
property
.
property
values
:
property
.
values
}
;
}
)
;
const
DOMWindowUtils
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
for
(
let
property
of
properties
)
{
let
underlyingValue
=
null
;
[
0
property
.
values
.
length
-
1
]
.
forEach
(
index
=
>
{
const
values
=
property
.
values
[
index
]
;
if
(
values
.
value
!
=
=
undefined
)
{
return
;
}
if
(
!
underlyingValue
)
{
let
pseudo
=
null
;
let
target
=
this
.
player
.
effect
.
target
;
if
(
target
.
type
)
{
pseudo
=
target
.
type
;
target
=
target
.
parentElement
;
}
const
value
=
DOMWindowUtils
.
getUnanimatedComputedStyle
(
target
pseudo
property
.
name
DOMWindowUtils
.
FLUSH_NONE
)
;
const
animationType
=
DOMWindowUtils
.
getAnimationTypeForLonghand
(
property
.
name
)
;
underlyingValue
=
animationType
=
=
=
"
float
"
?
parseFloat
(
value
10
)
:
value
;
}
values
.
value
=
underlyingValue
;
}
)
;
}
for
(
let
property
of
properties
)
{
const
propertyName
=
property
.
name
;
const
maxObject
=
{
distance
:
-
1
}
;
for
(
let
i
=
0
;
i
<
property
.
values
.
length
-
1
;
i
+
+
)
{
const
value1
=
property
.
values
[
i
]
.
value
;
for
(
let
j
=
i
+
1
;
j
<
property
.
values
.
length
;
j
+
+
)
{
const
value2
=
property
.
values
[
j
]
.
value
;
const
distance
=
this
.
getDistance
(
this
.
player
.
effect
.
target
propertyName
value1
value2
DOMWindowUtils
)
;
if
(
maxObject
.
distance
>
=
distance
)
{
continue
;
}
maxObject
.
distance
=
distance
;
maxObject
.
value1
=
value1
;
maxObject
.
value2
=
value2
;
}
}
if
(
maxObject
.
distance
=
=
=
0
)
{
property
.
values
.
reduce
(
(
previous
current
)
=
>
{
current
.
distance
=
current
.
value
=
=
=
previous
.
value
?
previous
.
distance
:
current
.
offset
;
return
current
;
}
property
.
values
[
0
]
)
;
continue
;
}
const
baseValue
=
maxObject
.
value1
<
maxObject
.
value2
?
maxObject
.
value1
:
maxObject
.
value2
;
for
(
let
values
of
property
.
values
)
{
const
value
=
values
.
value
;
const
distance
=
this
.
getDistance
(
this
.
player
.
effect
.
target
propertyName
baseValue
value
DOMWindowUtils
)
;
values
.
distance
=
distance
/
maxObject
.
distance
;
}
}
return
properties
;
}
getAnimationTypes
:
function
(
propertyNames
)
{
const
DOMWindowUtils
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
const
animationTypes
=
{
}
;
for
(
let
propertyName
of
propertyNames
)
{
animationTypes
[
propertyName
]
=
DOMWindowUtils
.
getAnimationTypeForLonghand
(
propertyName
)
;
}
return
animationTypes
;
}
getDistance
:
function
(
target
propertyName
value1
value2
DOMWindowUtils
)
{
if
(
value1
=
=
=
value2
)
{
return
0
;
}
try
{
const
distance
=
DOMWindowUtils
.
computeAnimationDistance
(
target
propertyName
value1
value2
)
;
return
distance
;
}
catch
(
e
)
{
return
0
;
}
}
}
)
;
exports
.
AnimationPlayerActor
=
AnimationPlayerActor
;
exports
.
AnimationsActor
=
protocol
.
ActorClassWithSpec
(
animationsSpec
{
initialize
:
function
(
conn
tabActor
)
{
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
tabActor
=
tabActor
;
this
.
onWillNavigate
=
this
.
onWillNavigate
.
bind
(
this
)
;
this
.
onNavigate
=
this
.
onNavigate
.
bind
(
this
)
;
this
.
onAnimationMutation
=
this
.
onAnimationMutation
.
bind
(
this
)
;
this
.
allAnimationsPaused
=
false
;
this
.
tabActor
.
on
(
"
will
-
navigate
"
this
.
onWillNavigate
)
;
this
.
tabActor
.
on
(
"
navigate
"
this
.
onNavigate
)
;
}
destroy
:
function
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
tabActor
.
off
(
"
will
-
navigate
"
this
.
onWillNavigate
)
;
this
.
tabActor
.
off
(
"
navigate
"
this
.
onNavigate
)
;
this
.
stopAnimationPlayerUpdates
(
)
;
this
.
tabActor
=
this
.
observer
=
this
.
actors
=
this
.
walker
=
null
;
}
setWalkerActor
:
function
(
walker
)
{
this
.
walker
=
walker
;
}
getAnimationPlayersForNode
:
function
(
nodeActor
)
{
let
animations
=
nodeActor
.
rawNode
.
getAnimations
(
{
subtree
:
true
}
)
;
if
(
this
.
actors
)
{
this
.
actors
.
forEach
(
actor
=
>
actor
.
destroy
(
)
)
;
}
this
.
actors
=
[
]
;
for
(
let
i
=
0
;
i
<
animations
.
length
;
i
+
+
)
{
let
actor
=
AnimationPlayerActor
(
this
animations
[
i
]
)
;
this
.
actors
.
push
(
actor
)
;
}
this
.
stopAnimationPlayerUpdates
(
)
;
let
win
=
nodeActor
.
rawNode
.
ownerDocument
.
defaultView
;
this
.
observer
=
new
win
.
MutationObserver
(
this
.
onAnimationMutation
)
;
this
.
observer
.
observe
(
nodeActor
.
rawNode
{
animations
:
true
subtree
:
true
}
)
;
return
this
.
actors
;
}
onAnimationMutation
:
function
(
mutations
)
{
let
eventData
=
[
]
;
let
readyPromises
=
[
]
;
for
(
let
{
addedAnimations
removedAnimations
}
of
mutations
)
{
for
(
let
player
of
removedAnimations
)
{
if
(
player
.
playState
!
=
=
"
idle
"
)
{
continue
;
}
let
index
=
this
.
actors
.
findIndex
(
a
=
>
a
.
player
=
=
=
player
)
;
if
(
index
!
=
=
-
1
)
{
eventData
.
push
(
{
type
:
"
removed
"
player
:
this
.
actors
[
index
]
}
)
;
this
.
actors
.
splice
(
index
1
)
;
}
}
for
(
let
player
of
addedAnimations
)
{
if
(
this
.
actors
.
find
(
a
=
>
a
.
player
=
=
=
player
)
)
{
continue
;
}
let
index
=
this
.
actors
.
findIndex
(
a
=
>
{
let
isSameType
=
a
.
player
.
constructor
=
=
=
player
.
constructor
;
let
isSameName
=
(
a
.
isCssAnimation
(
)
&
&
a
.
player
.
animationName
=
=
=
player
.
animationName
)
|
|
(
a
.
isCssTransition
(
)
&
&
a
.
player
.
transitionProperty
=
=
=
player
.
transitionProperty
)
;
let
isSameNode
=
a
.
player
.
effect
.
target
=
=
=
player
.
effect
.
target
;
return
isSameType
&
&
isSameNode
&
&
isSameName
;
}
)
;
if
(
index
!
=
=
-
1
)
{
eventData
.
push
(
{
type
:
"
removed
"
player
:
this
.
actors
[
index
]
}
)
;
this
.
actors
.
splice
(
index
1
)
;
}
let
actor
=
AnimationPlayerActor
(
this
player
)
;
this
.
actors
.
push
(
actor
)
;
eventData
.
push
(
{
type
:
"
added
"
player
:
actor
}
)
;
readyPromises
.
push
(
player
.
ready
)
;
}
}
if
(
eventData
.
length
)
{
Promise
.
all
(
readyPromises
)
.
then
(
(
)
=
>
{
this
.
emit
(
"
mutations
"
eventData
)
;
}
)
;
}
}
stopAnimationPlayerUpdates
:
function
(
)
{
if
(
this
.
observer
&
&
!
Cu
.
isDeadWrapper
(
this
.
observer
)
)
{
this
.
observer
.
disconnect
(
)
;
}
}
getAllAnimations
:
function
(
rootNode
traverseFrames
)
{
if
(
!
traverseFrames
)
{
return
rootNode
.
getAnimations
(
{
subtree
:
true
}
)
;
}
let
animations
=
[
]
;
for
(
let
{
document
}
of
this
.
tabActor
.
windows
)
{
animations
=
[
.
.
.
animations
.
.
.
document
.
getAnimations
(
{
subtree
:
true
}
)
]
;
}
return
animations
;
}
onWillNavigate
:
function
(
{
isTopLevel
}
)
{
if
(
isTopLevel
)
{
this
.
stopAnimationPlayerUpdates
(
)
;
}
}
onNavigate
:
function
(
{
isTopLevel
}
)
{
if
(
isTopLevel
)
{
this
.
allAnimationsPaused
=
false
;
}
}
pauseAll
:
function
(
)
{
let
readyPromises
=
[
]
;
for
(
let
player
of
this
.
getAllAnimations
(
this
.
tabActor
.
window
.
document
true
)
)
{
player
.
pause
(
)
;
readyPromises
.
push
(
player
.
ready
)
;
}
this
.
allAnimationsPaused
=
true
;
return
promise
.
all
(
readyPromises
)
;
}
playAll
:
function
(
)
{
let
readyPromises
=
[
]
;
for
(
let
player
of
this
.
getAllAnimations
(
this
.
tabActor
.
window
.
document
true
)
)
{
player
.
play
(
)
;
readyPromises
.
push
(
player
.
ready
)
;
}
this
.
allAnimationsPaused
=
false
;
return
promise
.
all
(
readyPromises
)
;
}
toggleAll
:
function
(
)
{
if
(
this
.
allAnimationsPaused
)
{
return
this
.
playAll
(
)
;
}
return
this
.
pauseAll
(
)
;
}
toggleSeveral
:
function
(
players
shouldPause
)
{
return
promise
.
all
(
players
.
map
(
player
=
>
{
return
shouldPause
?
player
.
pause
(
)
:
player
.
play
(
)
;
}
)
)
;
}
setCurrentTimes
:
function
(
players
time
shouldPause
)
{
return
promise
.
all
(
players
.
map
(
player
=
>
{
let
pause
=
shouldPause
?
player
.
pause
(
)
:
promise
.
resolve
(
)
;
return
pause
.
then
(
(
)
=
>
player
.
setCurrentTime
(
time
)
)
;
}
)
)
;
}
setPlaybackRates
:
function
(
players
rate
)
{
for
(
let
player
of
players
)
{
player
.
setPlaybackRate
(
rate
)
;
}
}
}
)
;
