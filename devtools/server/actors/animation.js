"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
{
Task
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
{
}
)
;
const
protocol
=
require
(
"
devtools
/
server
/
protocol
"
)
;
const
{
ActorClass
Actor
FrontClass
Front
Arg
method
RetVal
types
}
=
protocol
;
const
{
NodeActor
}
=
require
(
"
devtools
/
server
/
actors
/
inspector
"
)
;
const
events
=
require
(
"
sdk
/
event
/
core
"
)
;
const
ANIMATION_TYPES
=
{
CSS_ANIMATION
:
"
cssanimation
"
CSS_TRANSITION
:
"
csstransition
"
SCRIPT_ANIMATION
:
"
scriptanimation
"
UNKNOWN
:
"
unknown
"
}
;
exports
.
ANIMATION_TYPES
=
ANIMATION_TYPES
;
var
AnimationPlayerActor
=
ActorClass
(
{
typeName
:
"
animationplayer
"
events
:
{
"
changed
"
:
{
type
:
"
changed
"
state
:
Arg
(
0
"
json
"
)
}
}
initialize
:
function
(
animationsActor
player
)
{
Actor
.
prototype
.
initialize
.
call
(
this
animationsActor
.
conn
)
;
this
.
onAnimationMutation
=
this
.
onAnimationMutation
.
bind
(
this
)
;
this
.
walker
=
animationsActor
.
walker
;
this
.
player
=
player
;
this
.
observer
=
new
this
.
window
.
MutationObserver
(
this
.
onAnimationMutation
)
;
if
(
this
.
isPseudoElement
)
{
this
.
observer
.
observe
(
this
.
node
.
parentElement
{
animations
:
true
subtree
:
true
}
)
;
}
else
{
this
.
observer
.
observe
(
this
.
node
{
animations
:
true
}
)
;
}
}
destroy
:
function
(
)
{
if
(
this
.
observer
&
&
!
Cu
.
isDeadWrapper
(
this
.
observer
)
)
{
this
.
observer
.
disconnect
(
)
;
}
this
.
player
=
this
.
observer
=
this
.
walker
=
null
;
Actor
.
prototype
.
destroy
.
call
(
this
)
;
}
get
isPseudoElement
(
)
{
return
!
this
.
player
.
effect
.
target
.
ownerDocument
;
}
get
node
(
)
{
if
(
this
.
_node
)
{
return
this
.
_node
;
}
let
node
=
this
.
player
.
effect
.
target
;
if
(
this
.
isPseudoElement
)
{
let
treeWalker
=
this
.
walker
.
getDocumentWalker
(
node
.
parentElement
)
;
while
(
treeWalker
.
nextNode
(
)
)
{
let
currentNode
=
treeWalker
.
currentNode
;
if
(
(
currentNode
.
nodeName
=
=
=
"
_moz_generated_content_before
"
&
&
node
.
type
=
=
=
"
:
:
before
"
)
|
|
(
currentNode
.
nodeName
=
=
=
"
_moz_generated_content_after
"
&
&
node
.
type
=
=
=
"
:
:
after
"
)
)
{
this
.
_node
=
currentNode
;
}
}
}
else
{
this
.
_node
=
node
;
}
return
this
.
_node
;
}
get
window
(
)
{
return
this
.
node
.
ownerDocument
.
defaultView
;
}
release
:
method
(
function
(
)
{
}
{
release
:
true
}
)
form
:
function
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
let
data
=
this
.
getCurrentState
(
)
;
data
.
actor
=
this
.
actorID
;
if
(
this
.
walker
&
&
this
.
walker
.
hasNode
(
this
.
node
)
)
{
data
.
animationTargetNodeActorID
=
this
.
walker
.
getNode
(
this
.
node
)
.
actorID
;
}
return
data
;
}
isCssAnimation
:
function
(
player
=
this
.
player
)
{
return
player
instanceof
this
.
window
.
CSSAnimation
;
}
isCssTransition
:
function
(
player
=
this
.
player
)
{
return
player
instanceof
this
.
window
.
CSSTransition
;
}
isScriptAnimation
:
function
(
player
=
this
.
player
)
{
return
player
instanceof
this
.
window
.
Animation
&
&
!
(
player
instanceof
this
.
window
.
CSSAnimation
|
|
player
instanceof
this
.
window
.
CSSTransition
)
;
}
getType
:
function
(
)
{
if
(
this
.
isCssAnimation
(
)
)
{
return
ANIMATION_TYPES
.
CSS_ANIMATION
;
}
else
if
(
this
.
isCssTransition
(
)
)
{
return
ANIMATION_TYPES
.
CSS_TRANSITION
;
}
else
if
(
this
.
isScriptAnimation
(
)
)
{
return
ANIMATION_TYPES
.
SCRIPT_ANIMATION
;
}
return
ANIMATION_TYPES
.
UNKNOWN
;
}
getName
:
function
(
)
{
if
(
this
.
player
.
id
)
{
return
this
.
player
.
id
;
}
else
if
(
this
.
isCssAnimation
(
)
)
{
return
this
.
player
.
animationName
;
}
else
if
(
this
.
isCssTransition
(
)
)
{
return
this
.
player
.
transitionProperty
;
}
return
"
"
;
}
getDuration
:
function
(
)
{
return
this
.
player
.
effect
.
getComputedTiming
(
)
.
duration
;
}
getDelay
:
function
(
)
{
return
this
.
player
.
effect
.
getComputedTiming
(
)
.
delay
;
}
getEndDelay
:
function
(
)
{
return
this
.
player
.
effect
.
getComputedTiming
(
)
.
endDelay
;
}
getIterationCount
:
function
(
)
{
let
iterations
=
this
.
player
.
effect
.
getComputedTiming
(
)
.
iterations
;
return
iterations
=
=
=
"
Infinity
"
?
null
:
iterations
;
}
getIterationStart
:
function
(
)
{
return
this
.
player
.
effect
.
getComputedTiming
(
)
.
iterationStart
;
}
getState
:
function
(
)
{
if
(
this
.
player
.
startTime
)
{
this
.
previousStartTime
=
this
.
player
.
startTime
;
}
return
{
type
:
this
.
getType
(
)
startTime
:
this
.
player
.
startTime
previousStartTime
:
this
.
previousStartTime
currentTime
:
this
.
player
.
currentTime
playState
:
this
.
player
.
playState
playbackRate
:
this
.
player
.
playbackRate
name
:
this
.
getName
(
)
duration
:
this
.
getDuration
(
)
delay
:
this
.
getDelay
(
)
endDelay
:
this
.
getEndDelay
(
)
iterationCount
:
this
.
getIterationCount
(
)
iterationStart
:
this
.
getIterationStart
(
)
isRunningOnCompositor
:
this
.
player
.
isRunningOnCompositor
documentCurrentTime
:
this
.
node
.
ownerDocument
.
timeline
.
currentTime
}
;
}
getCurrentState
:
method
(
function
(
)
{
let
newState
=
this
.
getState
(
)
;
let
sentState
=
{
}
;
if
(
this
.
currentState
)
{
for
(
let
key
in
newState
)
{
if
(
typeof
this
.
currentState
[
key
]
=
=
=
"
undefined
"
|
|
this
.
currentState
[
key
]
!
=
=
newState
[
key
]
)
{
sentState
[
key
]
=
newState
[
key
]
;
}
}
}
else
{
sentState
=
newState
;
}
this
.
currentState
=
newState
;
return
sentState
;
}
{
request
:
{
}
response
:
{
data
:
RetVal
(
"
json
"
)
}
}
)
onAnimationMutation
:
function
(
mutations
)
{
let
isCurrentAnimation
=
animation
=
>
animation
=
=
=
this
.
player
;
let
hasCurrentAnimation
=
animations
=
>
animations
.
some
(
isCurrentAnimation
)
;
let
hasChanged
=
false
;
for
(
let
{
removedAnimations
changedAnimations
}
of
mutations
)
{
if
(
hasCurrentAnimation
(
removedAnimations
)
)
{
this
.
currentState
=
null
;
}
if
(
hasCurrentAnimation
(
changedAnimations
)
)
{
let
newState
=
this
.
getState
(
)
;
let
oldState
=
this
.
currentState
;
hasChanged
=
newState
.
delay
!
=
=
oldState
.
delay
|
|
newState
.
iterationCount
!
=
=
oldState
.
iterationCount
|
|
newState
.
iterationStart
!
=
=
oldState
.
iterationStart
|
|
newState
.
duration
!
=
=
oldState
.
duration
|
|
newState
.
endDelay
!
=
=
oldState
.
endDelay
;
break
;
}
}
if
(
hasChanged
)
{
events
.
emit
(
this
"
changed
"
this
.
getCurrentState
(
)
)
;
}
}
pause
:
method
(
function
(
)
{
this
.
player
.
pause
(
)
;
return
this
.
player
.
ready
;
}
{
request
:
{
}
response
:
{
}
}
)
play
:
method
(
function
(
)
{
this
.
player
.
play
(
)
;
return
this
.
player
.
ready
;
}
{
request
:
{
}
response
:
{
}
}
)
ready
:
method
(
function
(
)
{
return
this
.
player
.
ready
;
}
{
request
:
{
}
response
:
{
}
}
)
setCurrentTime
:
method
(
function
(
currentTime
)
{
this
.
player
.
currentTime
=
currentTime
*
this
.
player
.
playbackRate
;
}
{
request
:
{
currentTime
:
Arg
(
0
"
number
"
)
}
response
:
{
}
}
)
setPlaybackRate
:
method
(
function
(
playbackRate
)
{
this
.
player
.
playbackRate
=
playbackRate
;
}
{
request
:
{
currentTime
:
Arg
(
0
"
number
"
)
}
response
:
{
}
}
)
getFrames
:
method
(
function
(
)
{
return
this
.
player
.
effect
.
getFrames
(
)
;
}
{
request
:
{
}
response
:
{
frames
:
RetVal
(
"
json
"
)
}
}
)
getProperties
:
method
(
function
(
)
{
return
this
.
player
.
effect
.
getProperties
(
)
;
}
{
request
:
{
}
response
:
{
frames
:
RetVal
(
"
json
"
)
}
}
)
}
)
;
exports
.
AnimationPlayerActor
=
AnimationPlayerActor
;
var
AnimationPlayerFront
=
FrontClass
(
AnimationPlayerActor
{
initialize
:
function
(
conn
form
detail
ctx
)
{
Front
.
prototype
.
initialize
.
call
(
this
conn
form
detail
ctx
)
;
this
.
state
=
{
}
;
}
form
:
function
(
form
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
this
.
actorID
=
form
;
return
;
}
this
.
_form
=
form
;
this
.
state
=
this
.
initialState
;
}
destroy
:
function
(
)
{
Front
.
prototype
.
destroy
.
call
(
this
)
;
}
get
animationTargetNodeFront
(
)
{
if
(
!
this
.
_form
.
animationTargetNodeActorID
)
{
return
null
;
}
return
this
.
conn
.
getActor
(
this
.
_form
.
animationTargetNodeActorID
)
;
}
get
initialState
(
)
{
return
{
type
:
this
.
_form
.
type
startTime
:
this
.
_form
.
startTime
previousStartTime
:
this
.
_form
.
previousStartTime
currentTime
:
this
.
_form
.
currentTime
playState
:
this
.
_form
.
playState
playbackRate
:
this
.
_form
.
playbackRate
name
:
this
.
_form
.
name
duration
:
this
.
_form
.
duration
delay
:
this
.
_form
.
delay
endDelay
:
this
.
_form
.
endDelay
iterationCount
:
this
.
_form
.
iterationCount
iterationStart
:
this
.
_form
.
iterationStart
isRunningOnCompositor
:
this
.
_form
.
isRunningOnCompositor
documentCurrentTime
:
this
.
_form
.
documentCurrentTime
}
;
}
onChanged
:
protocol
.
preEvent
(
"
changed
"
function
(
partialState
)
{
let
{
state
}
=
this
.
reconstructState
(
partialState
)
;
this
.
state
=
state
;
}
)
refreshState
:
Task
.
async
(
function
*
(
)
{
let
data
=
yield
this
.
getCurrentState
(
)
;
if
(
this
.
currentStateHasChanged
)
{
this
.
state
=
data
;
}
}
)
getCurrentState
:
protocol
.
custom
(
function
(
)
{
this
.
currentStateHasChanged
=
false
;
return
this
.
_getCurrentState
(
)
.
then
(
partialData
=
>
{
let
{
state
hasChanged
}
=
this
.
reconstructState
(
partialData
)
;
this
.
currentStateHasChanged
=
hasChanged
;
return
state
;
}
)
;
}
{
impl
:
"
_getCurrentState
"
}
)
reconstructState
:
function
(
data
)
{
let
hasChanged
=
false
;
for
(
let
key
in
this
.
state
)
{
if
(
typeof
data
[
key
]
=
=
=
"
undefined
"
)
{
data
[
key
]
=
this
.
state
[
key
]
;
}
else
if
(
data
[
key
]
!
=
=
this
.
state
[
key
]
)
{
hasChanged
=
true
;
}
}
return
{
state
:
data
hasChanged
}
;
}
}
)
;
types
.
addDictType
(
"
animationMutationChange
"
{
type
:
"
string
"
player
:
"
animationplayer
"
}
)
;
var
AnimationsActor
=
exports
.
AnimationsActor
=
ActorClass
(
{
typeName
:
"
animations
"
events
:
{
"
mutations
"
:
{
type
:
"
mutations
"
changes
:
Arg
(
0
"
array
:
animationMutationChange
"
)
}
}
initialize
:
function
(
conn
tabActor
)
{
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
tabActor
=
tabActor
;
this
.
onWillNavigate
=
this
.
onWillNavigate
.
bind
(
this
)
;
this
.
onNavigate
=
this
.
onNavigate
.
bind
(
this
)
;
this
.
onAnimationMutation
=
this
.
onAnimationMutation
.
bind
(
this
)
;
this
.
allAnimationsPaused
=
false
;
events
.
on
(
this
.
tabActor
"
will
-
navigate
"
this
.
onWillNavigate
)
;
events
.
on
(
this
.
tabActor
"
navigate
"
this
.
onNavigate
)
;
}
destroy
:
function
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
events
.
off
(
this
.
tabActor
"
will
-
navigate
"
this
.
onWillNavigate
)
;
events
.
off
(
this
.
tabActor
"
navigate
"
this
.
onNavigate
)
;
this
.
stopAnimationPlayerUpdates
(
)
;
this
.
tabActor
=
this
.
observer
=
this
.
actors
=
this
.
walker
=
null
;
}
disconnect
:
function
(
)
{
this
.
destroy
(
)
;
}
setWalkerActor
:
method
(
function
(
walker
)
{
this
.
walker
=
walker
;
}
{
request
:
{
walker
:
Arg
(
0
"
domwalker
"
)
}
response
:
{
}
}
)
getAnimationPlayersForNode
:
method
(
function
(
nodeActor
)
{
let
animations
=
nodeActor
.
rawNode
.
getAnimations
(
{
subtree
:
true
}
)
;
if
(
this
.
actors
)
{
this
.
actors
.
forEach
(
actor
=
>
actor
.
destroy
(
)
)
;
}
this
.
actors
=
[
]
;
for
(
let
i
=
0
;
i
<
animations
.
length
;
i
+
+
)
{
let
actor
=
AnimationPlayerActor
(
this
animations
[
i
]
)
;
this
.
actors
.
push
(
actor
)
;
}
this
.
stopAnimationPlayerUpdates
(
)
;
let
win
=
nodeActor
.
rawNode
.
ownerDocument
.
defaultView
;
this
.
observer
=
new
win
.
MutationObserver
(
this
.
onAnimationMutation
)
;
this
.
observer
.
observe
(
nodeActor
.
rawNode
{
animations
:
true
subtree
:
true
}
)
;
return
this
.
actors
;
}
{
request
:
{
actorID
:
Arg
(
0
"
domnode
"
)
}
response
:
{
players
:
RetVal
(
"
array
:
animationplayer
"
)
}
}
)
onAnimationMutation
:
function
(
mutations
)
{
let
eventData
=
[
]
;
let
readyPromises
=
[
]
;
for
(
let
{
addedAnimations
removedAnimations
}
of
mutations
)
{
for
(
let
player
of
removedAnimations
)
{
if
(
player
.
playState
!
=
=
"
idle
"
)
{
continue
;
}
let
index
=
this
.
actors
.
findIndex
(
a
=
>
a
.
player
=
=
=
player
)
;
if
(
index
!
=
=
-
1
)
{
eventData
.
push
(
{
type
:
"
removed
"
player
:
this
.
actors
[
index
]
}
)
;
this
.
actors
.
splice
(
index
1
)
;
}
}
for
(
let
player
of
addedAnimations
)
{
if
(
this
.
actors
.
find
(
a
=
>
a
.
player
=
=
=
player
)
)
{
continue
;
}
let
index
=
this
.
actors
.
findIndex
(
a
=
>
{
let
isSameType
=
a
.
player
.
constructor
=
=
=
player
.
constructor
;
let
isSameName
=
(
a
.
isCssAnimation
(
)
&
&
a
.
player
.
animationName
=
=
=
player
.
animationName
)
|
|
(
a
.
isCssTransition
(
)
&
&
a
.
player
.
transitionProperty
=
=
=
player
.
transitionProperty
)
;
let
isSameNode
=
a
.
player
.
effect
.
target
=
=
=
player
.
effect
.
target
;
return
isSameType
&
&
isSameNode
&
&
isSameName
;
}
)
;
if
(
index
!
=
=
-
1
)
{
eventData
.
push
(
{
type
:
"
removed
"
player
:
this
.
actors
[
index
]
}
)
;
this
.
actors
.
splice
(
index
1
)
;
}
let
actor
=
AnimationPlayerActor
(
this
player
)
;
this
.
actors
.
push
(
actor
)
;
eventData
.
push
(
{
type
:
"
added
"
player
:
actor
}
)
;
readyPromises
.
push
(
player
.
ready
)
;
}
}
if
(
eventData
.
length
)
{
Promise
.
all
(
readyPromises
)
.
then
(
(
)
=
>
{
events
.
emit
(
this
"
mutations
"
eventData
)
;
}
)
;
}
}
stopAnimationPlayerUpdates
:
method
(
function
(
)
{
if
(
this
.
observer
&
&
!
Cu
.
isDeadWrapper
(
this
.
observer
)
)
{
this
.
observer
.
disconnect
(
)
;
}
}
{
request
:
{
}
response
:
{
}
}
)
getAllAnimations
:
function
(
rootNode
traverseFrames
)
{
if
(
!
traverseFrames
)
{
return
rootNode
.
getAnimations
(
{
subtree
:
true
}
)
;
}
let
animations
=
[
]
;
for
(
let
{
document
}
of
this
.
tabActor
.
windows
)
{
animations
=
[
.
.
.
animations
.
.
.
document
.
getAnimations
(
{
subtree
:
true
}
)
]
;
}
return
animations
;
}
onWillNavigate
:
function
(
{
isTopLevel
}
)
{
if
(
isTopLevel
)
{
this
.
stopAnimationPlayerUpdates
(
)
;
}
}
onNavigate
:
function
(
{
isTopLevel
}
)
{
if
(
isTopLevel
)
{
this
.
allAnimationsPaused
=
false
;
}
}
pauseAll
:
method
(
function
(
)
{
let
readyPromises
=
[
]
;
for
(
let
player
of
this
.
getAllAnimations
(
this
.
tabActor
.
window
.
document
true
)
)
{
player
.
pause
(
)
;
readyPromises
.
push
(
player
.
ready
)
;
}
this
.
allAnimationsPaused
=
true
;
return
promise
.
all
(
readyPromises
)
;
}
{
request
:
{
}
response
:
{
}
}
)
playAll
:
method
(
function
(
)
{
let
readyPromises
=
[
]
;
for
(
let
player
of
this
.
getAllAnimations
(
this
.
tabActor
.
window
.
document
true
)
)
{
player
.
play
(
)
;
readyPromises
.
push
(
player
.
ready
)
;
}
this
.
allAnimationsPaused
=
false
;
return
promise
.
all
(
readyPromises
)
;
}
{
request
:
{
}
response
:
{
}
}
)
toggleAll
:
method
(
function
(
)
{
if
(
this
.
allAnimationsPaused
)
{
return
this
.
playAll
(
)
;
}
return
this
.
pauseAll
(
)
;
}
{
request
:
{
}
response
:
{
}
}
)
toggleSeveral
:
method
(
function
(
players
shouldPause
)
{
return
promise
.
all
(
players
.
map
(
player
=
>
{
return
shouldPause
?
player
.
pause
(
)
:
player
.
play
(
)
;
}
)
)
;
}
{
request
:
{
players
:
Arg
(
0
"
array
:
animationplayer
"
)
shouldPause
:
Arg
(
1
"
boolean
"
)
}
response
:
{
}
}
)
setCurrentTimes
:
method
(
function
(
players
time
shouldPause
)
{
return
promise
.
all
(
players
.
map
(
player
=
>
{
let
pause
=
shouldPause
?
player
.
pause
(
)
:
promise
.
resolve
(
)
;
return
pause
.
then
(
(
)
=
>
player
.
setCurrentTime
(
time
)
)
;
}
)
)
;
}
{
request
:
{
players
:
Arg
(
0
"
array
:
animationplayer
"
)
time
:
Arg
(
1
"
number
"
)
shouldPause
:
Arg
(
2
"
boolean
"
)
}
response
:
{
}
}
)
setPlaybackRates
:
method
(
function
(
players
rate
)
{
for
(
let
player
of
players
)
{
player
.
setPlaybackRate
(
rate
)
;
}
}
{
request
:
{
players
:
Arg
(
0
"
array
:
animationplayer
"
)
rate
:
Arg
(
1
"
number
"
)
}
response
:
{
}
}
)
}
)
;
var
AnimationsFront
=
exports
.
AnimationsFront
=
FrontClass
(
AnimationsActor
{
initialize
:
function
(
client
{
animationsActor
}
)
{
Front
.
prototype
.
initialize
.
call
(
this
client
{
actor
:
animationsActor
}
)
;
this
.
manage
(
this
)
;
}
destroy
:
function
(
)
{
Front
.
prototype
.
destroy
.
call
(
this
)
;
}
}
)
;
