"
use
strict
"
;
const
{
method
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
function
ActorPool
(
connection
label
)
{
this
.
conn
=
connection
;
this
.
_label
=
label
;
this
.
_actors
=
{
}
;
}
ActorPool
.
prototype
=
{
destroy
:
function
APDestroy
(
)
{
for
(
const
id
in
this
.
_actors
)
{
this
.
removeActor
(
this
.
_actors
[
id
]
)
;
}
}
addActor
:
function
APAddActor
(
actor
)
{
actor
.
conn
=
this
.
conn
;
if
(
!
actor
.
actorID
)
{
const
prefix
=
actor
.
actorPrefix
|
|
actor
.
typeName
;
if
(
!
prefix
)
{
throw
new
Error
(
"
Actor
should
precify
either
actorPrefix
or
typeName
"
+
"
attribute
"
)
;
}
actor
.
actorID
=
this
.
conn
.
allocID
(
prefix
|
|
undefined
)
;
}
if
(
actor
.
registeredPool
)
{
delete
actor
.
registeredPool
.
_actors
[
actor
.
actorID
]
;
}
actor
.
registeredPool
=
this
;
this
.
_actors
[
actor
.
actorID
]
=
actor
;
}
removeActor
(
actor
)
{
delete
this
.
_actors
[
actor
.
actorID
]
;
if
(
actor
.
destroy
)
{
actor
.
destroy
(
)
;
return
;
}
if
(
actor
.
disconnect
)
{
actor
.
disconnect
(
)
;
}
}
get
:
function
APGet
(
actorID
)
{
return
this
.
_actors
[
actorID
]
|
|
undefined
;
}
has
:
function
APHas
(
actorID
)
{
return
actorID
in
this
.
_actors
;
}
isEmpty
:
function
APIsEmpty
(
)
{
return
Object
.
keys
(
this
.
_actors
)
.
length
=
=
0
;
}
unmanage
:
function
(
actor
)
{
return
this
.
removeActor
(
actor
)
;
}
forEach
:
function
(
callback
)
{
for
(
const
name
in
this
.
_actors
)
{
callback
(
this
.
_actors
[
name
]
)
;
}
}
*
poolChildren
(
)
{
if
(
!
this
.
_actors
)
{
return
;
}
for
(
const
actor
of
Object
.
values
(
this
.
_actors
)
)
{
if
(
actor
=
=
=
this
)
{
continue
;
}
yield
actor
;
}
}
dumpPool
(
)
{
for
(
const
actor
in
this
.
_actors
)
{
console
.
log
(
>
>
{
actor
}
)
;
}
}
}
;
exports
.
ActorPool
=
ActorPool
;
function
SourceLocation
(
actor
line
column
lastColumn
)
{
this
.
_connection
=
actor
?
actor
.
conn
:
null
;
this
.
_actorID
=
actor
?
actor
.
actorID
:
undefined
;
this
.
_line
=
line
;
this
.
_column
=
column
;
this
.
_lastColumn
=
lastColumn
!
=
=
undefined
?
lastColumn
:
column
+
1
;
}
SourceLocation
.
prototype
=
{
get
sourceActor
(
)
{
return
this
.
_connection
?
this
.
_connection
.
getActor
(
this
.
_actorID
)
:
null
;
}
get
url
(
)
{
return
this
.
sourceActor
.
url
;
}
get
line
(
)
{
return
this
.
_line
;
}
get
column
(
)
{
return
this
.
_column
;
}
get
lastColumn
(
)
{
return
this
.
_lastColumn
;
}
get
sourceUrl
(
)
{
return
this
.
sourceActor
.
url
;
}
equals
:
function
(
other
)
{
return
(
this
.
sourceActor
.
url
=
=
other
.
sourceActor
.
url
&
&
this
.
line
=
=
=
other
.
line
&
&
(
this
.
column
=
=
=
undefined
|
|
other
.
column
=
=
=
undefined
|
|
this
.
column
=
=
=
other
.
column
)
)
;
}
toJSON
:
function
(
)
{
return
{
source
:
this
.
sourceActor
.
form
(
)
line
:
this
.
line
column
:
this
.
column
lastColumn
:
this
.
lastColumn
}
;
}
}
;
exports
.
SourceLocation
=
SourceLocation
;
function
expectState
(
expectedState
methodFunc
activity
)
{
return
function
(
.
.
.
args
)
{
if
(
this
.
state
!
=
=
expectedState
)
{
const
msg
=
Wrong
state
while
{
activity
}
:
+
Expected
'
{
expectedState
}
'
+
but
current
state
is
'
{
this
.
state
}
'
.
;
return
Promise
.
reject
(
new
Error
(
msg
)
)
;
}
return
methodFunc
.
apply
(
this
args
)
;
}
;
}
exports
.
expectState
=
expectState
;
function
actorBridge
(
methodName
definition
=
{
}
)
{
return
method
(
function
(
)
{
return
this
.
bridge
[
methodName
]
.
apply
(
this
.
bridge
arguments
)
;
}
definition
)
;
}
exports
.
actorBridge
=
actorBridge
;
function
actorBridgeWithSpec
(
methodName
)
{
return
method
(
function
(
)
{
return
this
.
bridge
[
methodName
]
.
apply
(
this
.
bridge
arguments
)
;
}
)
;
}
exports
.
actorBridgeWithSpec
=
actorBridgeWithSpec
;
