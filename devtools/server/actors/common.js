"
use
strict
"
;
const
promise
=
require
(
"
promise
"
)
;
const
{
method
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
function
RegisteredActorFactory
(
options
prefix
)
{
this
.
_prefix
=
prefix
;
if
(
typeof
(
options
)
!
=
"
function
"
)
{
if
(
options
.
constructorFun
)
{
this
.
_getConstructor
=
(
)
=
>
options
.
constructorFun
;
}
else
{
this
.
_getConstructor
=
function
(
)
{
let
mod
;
try
{
mod
=
require
(
options
.
id
)
;
}
catch
(
e
)
{
throw
new
Error
(
"
Unable
to
load
actor
module
'
"
+
options
.
id
+
"
'
.
\
n
"
+
e
.
message
+
"
\
n
"
+
e
.
stack
+
"
\
n
"
)
;
}
let
c
=
mod
[
options
.
constructorName
]
;
if
(
!
c
)
{
throw
new
Error
(
"
Unable
to
find
actor
constructor
named
'
"
+
options
.
constructorName
+
"
'
.
(
Is
it
exported
?
)
"
)
;
}
return
c
;
}
;
}
this
.
name
=
options
.
constructorName
;
}
else
{
this
.
_getConstructor
=
(
)
=
>
options
;
this
.
name
=
options
.
name
;
if
(
options
.
prototype
&
&
options
.
prototype
.
actorPrefix
)
{
this
.
_prefix
=
options
.
prototype
.
actorPrefix
;
}
}
}
RegisteredActorFactory
.
prototype
.
createObservedActorFactory
=
function
(
conn
parentActor
)
{
return
new
ObservedActorFactory
(
this
.
_getConstructor
this
.
_prefix
conn
parentActor
)
;
}
;
exports
.
RegisteredActorFactory
=
RegisteredActorFactory
;
function
ObservedActorFactory
(
getConstructor
prefix
conn
parentActor
)
{
this
.
_getConstructor
=
getConstructor
;
this
.
_conn
=
conn
;
this
.
_parentActor
=
parentActor
;
this
.
actorPrefix
=
prefix
;
this
.
actorID
=
null
;
this
.
registeredPool
=
null
;
}
ObservedActorFactory
.
prototype
.
createActor
=
function
(
)
{
let
C
=
this
.
_getConstructor
(
)
;
let
instance
=
new
C
(
this
.
_conn
this
.
_parentActor
)
;
instance
.
conn
=
this
.
_conn
;
instance
.
parentID
=
this
.
_parentActor
.
actorID
;
instance
.
actorID
=
this
.
actorID
;
this
.
registeredPool
.
addActor
(
instance
)
;
return
instance
;
}
;
exports
.
ObservedActorFactory
=
ObservedActorFactory
;
exports
.
createExtraActors
=
function
createExtraActors
(
factories
pool
)
{
for
(
let
name
in
factories
)
{
let
actor
=
this
.
_extraActors
[
name
]
;
if
(
!
actor
)
{
actor
=
factories
[
name
]
.
createObservedActorFactory
(
this
.
conn
this
)
;
this
.
_extraActors
[
name
]
=
actor
;
}
if
(
!
pool
.
has
(
actor
.
actorID
)
)
{
pool
.
addActor
(
actor
)
;
}
}
}
;
exports
.
appendExtraActors
=
function
appendExtraActors
(
object
)
{
for
(
let
name
in
this
.
_extraActors
)
{
let
actor
=
this
.
_extraActors
[
name
]
;
object
[
name
]
=
actor
.
actorID
;
}
}
;
function
ActorPool
(
connection
)
{
this
.
conn
=
connection
;
this
.
_actors
=
{
}
;
}
ActorPool
.
prototype
=
{
destroy
:
function
APDestroy
(
)
{
for
(
let
id
in
this
.
_actors
)
{
this
.
removeActor
(
this
.
_actors
[
id
]
)
;
}
}
addActor
:
function
APAddActor
(
actor
)
{
actor
.
conn
=
this
.
conn
;
if
(
!
actor
.
actorID
)
{
let
prefix
=
actor
.
actorPrefix
|
|
actor
.
typeName
;
if
(
!
prefix
&
&
typeof
actor
=
=
"
function
"
)
{
prefix
=
actor
.
prototype
.
actorPrefix
|
|
actor
.
prototype
.
typeName
;
}
actor
.
actorID
=
this
.
conn
.
allocID
(
prefix
|
|
undefined
)
;
}
if
(
actor
.
registeredPool
)
{
delete
actor
.
registeredPool
.
_actors
[
actor
.
actorID
]
;
}
actor
.
registeredPool
=
this
;
this
.
_actors
[
actor
.
actorID
]
=
actor
;
}
removeActor
(
actor
)
{
delete
this
.
_actors
[
actor
.
actorID
]
;
if
(
actor
.
destroy
)
{
actor
.
destroy
(
)
;
return
;
}
if
(
actor
.
disconnect
)
{
actor
.
disconnect
(
)
;
}
}
get
:
function
APGet
(
actorID
)
{
return
this
.
_actors
[
actorID
]
|
|
undefined
;
}
has
:
function
APHas
(
actorID
)
{
return
actorID
in
this
.
_actors
;
}
isEmpty
:
function
APIsEmpty
(
)
{
return
Object
.
keys
(
this
.
_actors
)
.
length
=
=
0
;
}
unmanage
:
function
(
actor
)
{
return
this
.
removeActor
(
actor
)
;
}
forEach
:
function
(
callback
)
{
for
(
let
name
in
this
.
_actors
)
{
callback
(
this
.
_actors
[
name
]
)
;
}
}
}
;
exports
.
ActorPool
=
ActorPool
;
function
OriginalLocation
(
actor
line
column
name
)
{
this
.
_connection
=
actor
?
actor
.
conn
:
null
;
this
.
_actorID
=
actor
?
actor
.
actorID
:
undefined
;
this
.
_line
=
line
;
this
.
_column
=
column
;
this
.
_name
=
name
;
}
OriginalLocation
.
fromGeneratedLocation
=
function
(
generatedLocation
)
{
return
new
OriginalLocation
(
generatedLocation
.
generatedSourceActor
generatedLocation
.
generatedLine
generatedLocation
.
generatedColumn
)
;
}
;
OriginalLocation
.
prototype
=
{
get
originalSourceActor
(
)
{
return
this
.
_connection
?
this
.
_connection
.
getActor
(
this
.
_actorID
)
:
null
;
}
get
originalUrl
(
)
{
let
actor
=
this
.
originalSourceActor
;
let
source
=
actor
.
source
;
return
source
?
source
.
url
:
actor
.
_originalUrl
;
}
get
originalLine
(
)
{
return
this
.
_line
;
}
get
originalColumn
(
)
{
return
this
.
_column
;
}
get
originalName
(
)
{
return
this
.
_name
;
}
get
generatedSourceActor
(
)
{
throw
new
Error
(
"
Shouldn
'
t
access
generatedSourceActor
from
an
OriginalLocation
"
)
;
}
get
generatedLine
(
)
{
throw
new
Error
(
"
Shouldn
'
t
access
generatedLine
from
an
OriginalLocation
"
)
;
}
get
generatedColumn
(
)
{
throw
new
Error
(
"
Shouldn
'
t
access
generatedColumn
from
an
Originallocation
"
)
;
}
equals
:
function
(
other
)
{
return
this
.
originalSourceActor
.
url
=
=
other
.
originalSourceActor
.
url
&
&
this
.
originalLine
=
=
=
other
.
originalLine
&
&
(
this
.
originalColumn
=
=
=
undefined
|
|
other
.
originalColumn
=
=
=
undefined
|
|
this
.
originalColumn
=
=
=
other
.
originalColumn
)
;
}
toJSON
:
function
(
)
{
return
{
source
:
this
.
originalSourceActor
.
form
(
)
line
:
this
.
originalLine
column
:
this
.
originalColumn
}
;
}
}
;
exports
.
OriginalLocation
=
OriginalLocation
;
function
GeneratedLocation
(
actor
line
column
lastColumn
)
{
this
.
_connection
=
actor
?
actor
.
conn
:
null
;
this
.
_actorID
=
actor
?
actor
.
actorID
:
undefined
;
this
.
_line
=
line
;
this
.
_column
=
column
;
this
.
_lastColumn
=
(
lastColumn
!
=
=
undefined
)
?
lastColumn
:
column
+
1
;
}
GeneratedLocation
.
fromOriginalLocation
=
function
(
originalLocation
)
{
return
new
GeneratedLocation
(
originalLocation
.
originalSourceActor
originalLocation
.
originalLine
originalLocation
.
originalColumn
)
;
}
;
GeneratedLocation
.
prototype
=
{
get
originalSourceActor
(
)
{
throw
new
Error
(
)
;
}
get
originalUrl
(
)
{
throw
new
Error
(
"
Shouldn
'
t
access
originalUrl
from
a
GeneratedLocation
"
)
;
}
get
originalLine
(
)
{
throw
new
Error
(
"
Shouldn
'
t
access
originalLine
from
a
GeneratedLocation
"
)
;
}
get
originalColumn
(
)
{
throw
new
Error
(
"
Shouldn
'
t
access
originalColumn
from
a
GeneratedLocation
"
)
;
}
get
originalName
(
)
{
throw
new
Error
(
"
Shouldn
'
t
access
originalName
from
a
GeneratedLocation
"
)
;
}
get
generatedSourceActor
(
)
{
return
this
.
_connection
?
this
.
_connection
.
getActor
(
this
.
_actorID
)
:
null
;
}
get
generatedLine
(
)
{
return
this
.
_line
;
}
get
generatedColumn
(
)
{
return
this
.
_column
;
}
get
generatedLastColumn
(
)
{
return
this
.
_lastColumn
;
}
equals
:
function
(
other
)
{
return
this
.
generatedSourceActor
.
url
=
=
other
.
generatedSourceActor
.
url
&
&
this
.
generatedLine
=
=
=
other
.
generatedLine
&
&
(
this
.
generatedColumn
=
=
=
undefined
|
|
other
.
generatedColumn
=
=
=
undefined
|
|
this
.
generatedColumn
=
=
=
other
.
generatedColumn
)
;
}
toJSON
:
function
(
)
{
return
{
source
:
this
.
generatedSourceActor
.
form
(
)
line
:
this
.
generatedLine
column
:
this
.
generatedColumn
lastColumn
:
this
.
generatedLastColumn
}
;
}
}
;
exports
.
GeneratedLocation
=
GeneratedLocation
;
function
expectState
(
expectedState
methodFunc
activity
)
{
return
function
(
.
.
.
args
)
{
if
(
this
.
state
!
=
=
expectedState
)
{
const
msg
=
Wrong
state
while
{
activity
}
:
+
Expected
'
{
expectedState
}
'
+
but
current
state
is
'
{
this
.
state
}
'
.
;
return
promise
.
reject
(
new
Error
(
msg
)
)
;
}
return
methodFunc
.
apply
(
this
args
)
;
}
;
}
exports
.
expectState
=
expectState
;
function
actorBridge
(
methodName
definition
=
{
}
)
{
return
method
(
function
(
)
{
return
this
.
bridge
[
methodName
]
.
apply
(
this
.
bridge
arguments
)
;
}
definition
)
;
}
exports
.
actorBridge
=
actorBridge
;
function
actorBridgeWithSpec
(
methodName
)
{
return
method
(
function
(
)
{
return
this
.
bridge
[
methodName
]
.
apply
(
this
.
bridge
arguments
)
;
}
)
;
}
exports
.
actorBridgeWithSpec
=
actorBridgeWithSpec
;
