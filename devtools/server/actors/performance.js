"
use
strict
"
;
const
{
Actor
ActorClassWithSpec
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
actorBridgeWithSpec
}
=
require
(
"
devtools
/
server
/
actors
/
common
"
)
;
const
{
performanceSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
performance
"
)
;
loader
.
lazyRequireGetter
(
this
"
PerformanceRecorder
"
"
devtools
/
server
/
performance
/
recorder
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
normalizePerformanceFeatures
"
"
devtools
/
shared
/
performance
/
recording
-
utils
"
true
)
;
const
PIPE_TO_FRONT_EVENTS
=
new
Set
(
[
"
recording
-
started
"
"
recording
-
stopping
"
"
recording
-
stopped
"
"
profiler
-
status
"
"
timeline
-
data
"
"
console
-
profile
-
start
"
]
)
;
const
RECORDING_STATE_CHANGE_EVENTS
=
new
Set
(
[
"
recording
-
started
"
"
recording
-
stopping
"
"
recording
-
stopped
"
]
)
;
var
PerformanceActor
=
ActorClassWithSpec
(
performanceSpec
{
traits
:
{
features
:
{
withMarkers
:
true
withTicks
:
true
withMemory
:
true
withFrames
:
true
withGCEvents
:
true
withDocLoadingEvents
:
true
withAllocations
:
true
}
}
initialize
:
function
(
conn
tabActor
)
{
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
_onRecorderEvent
=
this
.
_onRecorderEvent
.
bind
(
this
)
;
this
.
bridge
=
new
PerformanceRecorder
(
conn
tabActor
)
;
this
.
bridge
.
on
(
"
*
"
this
.
_onRecorderEvent
)
;
}
destroy
:
function
(
)
{
this
.
bridge
.
off
(
"
*
"
this
.
_onRecorderEvent
)
;
this
.
bridge
.
destroy
(
)
;
Actor
.
prototype
.
destroy
.
call
(
this
)
;
}
connect
:
function
(
config
)
{
this
.
bridge
.
connect
(
{
systemClient
:
config
.
systemClient
}
)
;
return
{
traits
:
this
.
traits
}
;
}
canCurrentlyRecord
:
function
(
)
{
return
this
.
bridge
.
canCurrentlyRecord
(
)
;
}
async
startRecording
(
options
=
{
}
)
{
if
(
!
this
.
bridge
.
canCurrentlyRecord
(
)
.
success
)
{
return
null
;
}
let
normalizedOptions
=
normalizePerformanceFeatures
(
options
this
.
traits
.
features
)
;
let
recording
=
await
this
.
bridge
.
startRecording
(
normalizedOptions
)
;
this
.
manage
(
recording
)
;
return
recording
;
}
stopRecording
:
actorBridgeWithSpec
(
"
stopRecording
"
)
isRecording
:
actorBridgeWithSpec
(
"
isRecording
"
)
getRecordings
:
actorBridgeWithSpec
(
"
getRecordings
"
)
getConfiguration
:
actorBridgeWithSpec
(
"
getConfiguration
"
)
setProfilerStatusInterval
:
actorBridgeWithSpec
(
"
setProfilerStatusInterval
"
)
_onRecorderEvent
:
function
(
eventName
.
.
.
data
)
{
if
(
RECORDING_STATE_CHANGE_EVENTS
.
has
(
eventName
)
)
{
let
recording
=
data
[
0
]
;
let
extraData
=
data
[
1
]
;
recording
.
_setState
(
eventName
extraData
)
;
}
if
(
PIPE_TO_FRONT_EVENTS
.
has
(
eventName
)
)
{
this
.
emit
(
eventName
.
.
.
data
)
;
}
}
}
)
;
exports
.
PerformanceActor
=
PerformanceActor
;
