"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
cssPropertiesSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
css
-
properties
.
js
"
)
;
const
{
cssColors
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
css
/
color
-
db
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
CSS_TYPES
"
"
resource
:
/
/
devtools
/
shared
/
css
/
constants
.
js
"
true
)
;
class
CssPropertiesActor
extends
Actor
{
constructor
(
conn
targetActor
)
{
super
(
conn
cssPropertiesSpec
)
;
this
.
targetActor
=
targetActor
;
}
getCSSDatabase
(
)
{
const
properties
=
generateCssProperties
(
this
.
targetActor
.
window
.
document
)
;
return
{
properties
}
;
}
}
exports
.
CssPropertiesActor
=
CssPropertiesActor
;
function
generateCssProperties
(
doc
)
{
const
properties
=
{
}
;
const
propertyNames
=
InspectorUtils
.
getCSSPropertyNames
(
{
includeAliases
:
true
}
)
;
const
colors
=
Object
.
keys
(
cssColors
)
;
propertyNames
.
forEach
(
name
=
>
{
const
supports
=
[
]
;
for
(
const
type
in
CSS_TYPES
)
{
if
(
safeCssPropertySupportsType
(
name
type
)
)
{
supports
.
push
(
type
)
;
}
}
let
values
=
InspectorUtils
.
getCSSValuesForProperty
(
name
)
;
if
(
values
.
includes
(
"
aliceblue
"
)
)
{
values
=
values
.
filter
(
x
=
>
!
colors
.
includes
(
x
)
)
;
values
.
unshift
(
"
COLOR
"
)
;
}
const
subproperties
=
InspectorUtils
.
getSubpropertiesForCSSProperty
(
name
)
;
properties
[
name
]
=
{
isInherited
:
InspectorUtils
.
isInheritedProperty
(
doc
name
)
values
supports
subproperties
}
;
}
)
;
return
properties
;
}
exports
.
generateCssProperties
=
generateCssProperties
;
function
isCssPropertyKnown
(
name
)
{
try
{
InspectorUtils
.
cssPropertyIsShorthand
(
name
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
exports
.
isCssPropertyKnown
=
isCssPropertyKnown
;
function
safeCssPropertySupportsType
(
name
type
)
{
try
{
return
InspectorUtils
.
cssPropertySupportsType
(
name
type
)
;
}
catch
(
e
)
{
return
false
;
}
}
