"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
perfSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
perf
.
js
"
)
;
const
{
copyArrayBufferToAsyncStream
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
transport
/
stream
-
utils
.
js
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
RecordingUtils
:
"
resource
:
/
/
devtools
/
shared
/
performance
-
new
/
recording
-
utils
.
sys
.
mjs
"
}
{
global
:
"
contextual
"
}
)
;
const
IS_SUPPORTED_PLATFORM
=
"
nsIProfiler
"
in
Ci
;
exports
.
PerfActor
=
class
PerfActor
extends
Actor
{
#
captureHandleCounter
=
0
;
#
previouslyRetrievedProfileDataPromise
=
null
;
#
previouslyRetrievedAdditionalInformationPromise
=
null
;
constructor
(
conn
)
{
super
(
conn
perfSpec
)
;
if
(
IS_SUPPORTED_PLATFORM
)
{
this
.
_observer
=
{
observe
:
this
.
_observe
.
bind
(
this
)
}
;
Services
.
obs
.
addObserver
(
this
.
_observer
"
profiler
-
started
"
)
;
Services
.
obs
.
addObserver
(
this
.
_observer
"
profiler
-
stopped
"
)
;
}
}
destroy
(
)
{
super
.
destroy
(
)
;
if
(
!
IS_SUPPORTED_PLATFORM
)
{
return
;
}
Services
.
obs
.
removeObserver
(
this
.
_observer
"
profiler
-
started
"
)
;
Services
.
obs
.
removeObserver
(
this
.
_observer
"
profiler
-
stopped
"
)
;
}
startProfiler
(
options
)
{
if
(
!
IS_SUPPORTED_PLATFORM
)
{
return
false
;
}
const
settings
=
{
entries
:
options
.
entries
|
|
1000000
duration
:
options
.
duration
|
|
0
interval
:
options
.
interval
|
|
1
features
:
options
.
features
|
|
[
"
js
"
"
stackwalk
"
"
cpu
"
"
memory
"
]
threads
:
options
.
threads
|
|
[
"
GeckoMain
"
"
Compositor
"
]
activeTabID
:
RecordingUtils
.
getActiveBrowserID
(
)
}
;
try
{
Services
.
profiler
.
StartProfiler
(
settings
.
entries
settings
.
interval
settings
.
features
settings
.
threads
settings
.
activeTabID
settings
.
duration
)
;
}
catch
(
e
)
{
return
false
;
}
return
true
;
}
stopProfilerAndDiscardProfile
(
)
{
if
(
!
IS_SUPPORTED_PLATFORM
)
{
return
null
;
}
return
Services
.
profiler
.
StopProfiler
(
)
;
}
async
getSymbolTable
(
debugPath
breakpadId
)
{
const
[
addr
index
buffer
]
=
await
Services
.
profiler
.
getSymbolTable
(
debugPath
breakpadId
)
;
return
[
Array
.
from
(
addr
)
Array
.
from
(
index
)
Array
.
from
(
buffer
)
]
;
}
async
getProfileAndStopProfiler
(
)
{
throw
new
Error
(
"
Unexpected
getProfileAndStopProfiler
function
called
in
Firefox
v140
+
.
Most
likely
you
'
re
using
an
older
version
of
Firefox
to
debug
this
application
.
Please
use
at
least
Firefox
v140
.
"
)
;
}
async
startCaptureAndStopProfiler
(
)
{
if
(
!
IS_SUPPORTED_PLATFORM
)
{
throw
new
Error
(
"
Profiling
is
not
supported
on
this
platform
.
"
)
;
}
const
capturePromise
=
RecordingUtils
.
getProfileDataAsGzippedArrayBufferThenStop
(
)
;
this
.
#
previouslyRetrievedProfileDataPromise
=
capturePromise
.
then
(
(
{
profileCaptureResult
}
)
=
>
{
if
(
profileCaptureResult
.
type
=
=
=
"
ERROR
"
)
{
throw
profileCaptureResult
.
error
;
}
return
profileCaptureResult
.
profile
;
}
)
;
this
.
#
previouslyRetrievedAdditionalInformationPromise
=
capturePromise
.
then
(
(
{
additionalInformation
}
)
=
>
additionalInformation
)
;
return
+
+
this
.
#
captureHandleCounter
;
}
async
getPreviouslyCapturedProfileDataBulk
(
handle
startBulkSend
)
{
if
(
handle
<
this
.
#
captureHandleCounter
)
{
console
.
error
(
[
devtools
perf
actor
]
In
getPreviouslyCapturedProfileDataBulk
the
requested
handle
{
handle
}
is
smaller
than
the
current
counter
{
this
.
#
captureHandleCounter
}
.
)
;
throw
new
Error
(
The
requested
data
was
not
found
.
)
;
}
if
(
this
.
#
previouslyRetrievedProfileDataPromise
=
=
=
null
)
{
/
/
No
capture
operation
has
been
started
write
a
message
and
throw
an
error
.
console
.
error
(
[
devtools
perf
actor
]
In
getPreviouslyCapturedProfileDataBulk
there
'
s
no
data
to
be
returned
.
)
;
throw
new
Error
(
The
requested
data
was
not
found
.
)
;
}
/
/
Note
that
this
promise
might
be
rejected
if
there
was
an
error
.
That
'
s
OK
const
profile
=
await
this
.
#
previouslyRetrievedProfileDataPromise
;
this
.
#
previouslyRetrievedProfileDataPromise
=
null
;
const
bulk
=
await
startBulkSend
(
profile
.
byteLength
)
;
try
{
await
copyArrayBufferToAsyncStream
(
profile
bulk
.
stream
)
;
}
finally
{
bulk
.
done
(
)
;
}
}
async
getPreviouslyRetrievedAdditionalInformation
(
handle
)
{
if
(
handle
<
this
.
#
captureHandleCounter
)
{
console
.
error
(
[
devtools
perf
actor
]
In
getPreviouslyRetrievedAdditionalInformation
the
requested
handle
{
handle
}
is
smaller
than
the
current
counter
{
this
.
#
captureHandleCounter
}
.
)
;
throw
new
Error
(
The
requested
data
was
not
found
.
)
;
}
if
(
this
.
#
previouslyRetrievedAdditionalInformationPromise
=
=
=
null
)
{
/
/
No
capture
operation
has
been
started
write
a
message
and
throw
an
error
.
console
.
error
(
[
devtools
perf
actor
]
In
getPreviouslyRetrievedAdditionalInformation
there
'
s
no
data
to
be
returned
.
)
;
throw
new
Error
(
The
requested
data
was
not
found
.
)
;
}
try
{
return
this
.
#
previouslyRetrievedAdditionalInformationPromise
;
}
finally
{
this
.
#
previouslyRetrievedAdditionalInformationPromise
=
null
;
}
}
isActive
(
)
{
if
(
!
IS_SUPPORTED_PLATFORM
)
{
return
false
;
}
return
Services
.
profiler
.
IsActive
(
)
;
}
isSupportedPlatform
(
)
{
return
IS_SUPPORTED_PLATFORM
;
}
/
*
*
*
Watch
for
events
that
happen
within
the
browser
.
These
can
affect
the
*
current
availability
and
state
of
the
Gecko
Profiler
.
*
/
_observe
(
subject
topic
_data
)
{
/
/
Note
!
If
emitting
new
events
make
sure
and
update
the
list
of
bridged
/
/
events
in
the
perf
actor
.
switch
(
topic
)
{
case
"
profiler
-
started
"
:
{
const
param
=
subject
.
QueryInterface
(
Ci
.
nsIProfilerStartParams
)
;
this
.
emit
(
topic
param
.
entries
param
.
interval
param
.
features
param
.
duration
param
.
activeTabID
)
;
break
;
}
case
"
profiler
-
stopped
"
:
this
.
emit
(
topic
)
;
break
;
}
}
/
*
*
*
Lists
the
supported
features
of
the
profiler
for
the
current
browser
.
*
returns
{
string
[
]
}
*
/
getSupportedFeatures
(
)
{
if
(
!
IS_SUPPORTED_PLATFORM
)
{
return
[
]
;
}
return
Services
.
profiler
.
GetFeatures
(
)
;
}
}
;
