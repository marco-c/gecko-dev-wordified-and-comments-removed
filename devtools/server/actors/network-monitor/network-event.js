"
use
strict
"
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
networkEventSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
network
-
event
"
)
;
const
{
LongStringActor
}
=
require
(
"
devtools
/
server
/
actors
/
string
"
)
;
const
NetworkEventActor
=
protocol
.
ActorClassWithSpec
(
networkEventSpec
{
initialize
(
netMonitorActor
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
netMonitorActor
.
conn
)
;
this
.
netMonitorActor
=
netMonitorActor
;
this
.
conn
=
this
.
netMonitorActor
.
conn
;
this
.
_request
=
{
method
:
null
url
:
null
httpVersion
:
null
headers
:
[
]
cookies
:
[
]
headersSize
:
null
postData
:
{
}
}
;
this
.
_response
=
{
headers
:
[
]
cookies
:
[
]
content
:
{
}
}
;
this
.
_timings
=
{
}
;
this
.
_serverTimings
=
[
]
;
this
.
_stackTrace
=
{
}
;
this
.
_discardRequestBody
=
false
;
this
.
_discardResponseBody
=
false
;
}
_request
:
null
_response
:
null
_timings
:
null
_serverTimings
:
null
form
(
)
{
return
{
actor
:
this
.
actorID
startedDateTime
:
this
.
_startedDateTime
timeStamp
:
Date
.
parse
(
this
.
_startedDateTime
)
url
:
this
.
_request
.
url
method
:
this
.
_request
.
method
isXHR
:
this
.
_isXHR
cause
:
this
.
_cause
fromCache
:
this
.
_fromCache
fromServiceWorker
:
this
.
_fromServiceWorker
private
:
this
.
_private
isThirdPartyTrackingResource
:
this
.
_isThirdPartyTrackingResource
referrerPolicy
:
this
.
_referrerPolicy
priority
:
this
.
_priority
blockedReason
:
this
.
_blockedReason
blockingExtension
:
this
.
_blockingExtension
channelId
:
this
.
_channelId
chromeContext
:
this
.
_isFromSystemPrincipal
}
;
}
destroy
(
conn
)
{
if
(
!
this
.
netMonitorActor
)
{
return
;
}
if
(
this
.
_request
.
url
)
{
this
.
netMonitorActor
.
_networkEventActorsByURL
.
delete
(
this
.
_request
.
url
)
;
}
if
(
this
.
channel
)
{
this
.
netMonitorActor
.
_netEvents
.
delete
(
this
.
channel
)
;
}
this
.
netMonitorActor
=
null
;
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
conn
)
;
}
release
(
)
{
}
init
(
networkEvent
)
{
this
.
_startedDateTime
=
networkEvent
.
startedDateTime
;
this
.
_isXHR
=
networkEvent
.
isXHR
;
this
.
_cause
=
networkEvent
.
cause
;
this
.
_fromCache
=
networkEvent
.
fromCache
;
this
.
_fromServiceWorker
=
networkEvent
.
fromServiceWorker
;
this
.
_isThirdPartyTrackingResource
=
networkEvent
.
isThirdPartyTrackingResource
;
this
.
_referrerPolicy
=
networkEvent
.
referrerPolicy
;
this
.
_priority
=
networkEvent
.
priority
;
this
.
_channelId
=
networkEvent
.
channelId
;
this
.
_isFromSystemPrincipal
=
networkEvent
.
isFromSystemPrincipal
;
this
.
_stackTrace
=
networkEvent
.
cause
.
stacktrace
;
delete
networkEvent
.
cause
.
stacktrace
;
networkEvent
.
cause
.
stacktraceAvailable
=
!
!
(
this
.
_stackTrace
&
&
(
typeof
this
.
_stackTrace
=
=
"
boolean
"
|
|
this
.
_stackTrace
.
length
)
)
;
for
(
const
prop
of
[
"
method
"
"
url
"
"
httpVersion
"
"
headersSize
"
]
)
{
this
.
_request
[
prop
]
=
networkEvent
[
prop
]
;
}
this
.
_discardRequestBody
=
!
!
networkEvent
.
discardRequestBody
;
this
.
_discardResponseBody
=
!
!
networkEvent
.
discardResponseBody
;
this
.
_blockedReason
=
networkEvent
.
blockedReason
;
this
.
_blockingExtension
=
networkEvent
.
blockingExtension
;
this
.
_truncated
=
false
;
this
.
_private
=
networkEvent
.
private
;
}
getRequestHeaders
(
)
{
return
{
headers
:
this
.
_request
.
headers
headersSize
:
this
.
_request
.
headersSize
rawHeaders
:
this
.
_request
.
rawHeaders
}
;
}
getRequestCookies
(
)
{
return
{
cookies
:
this
.
_request
.
cookies
}
;
}
getRequestPostData
(
)
{
return
{
postData
:
this
.
_request
.
postData
postDataDiscarded
:
this
.
_discardRequestBody
}
;
}
getSecurityInfo
(
)
{
return
{
securityInfo
:
this
.
_securityInfo
}
;
}
getResponseHeaders
(
)
{
return
{
headers
:
this
.
_response
.
headers
headersSize
:
this
.
_response
.
headersSize
rawHeaders
:
this
.
_response
.
rawHeaders
}
;
}
getResponseCache
(
)
{
return
{
cache
:
this
.
_response
.
responseCache
}
;
}
getResponseCookies
(
)
{
return
{
cookies
:
this
.
_response
.
cookies
}
;
}
getResponseContent
(
)
{
return
{
content
:
this
.
_response
.
content
contentDiscarded
:
this
.
_discardResponseBody
}
;
}
getEventTimings
(
)
{
return
{
timings
:
this
.
_timings
totalTime
:
this
.
_totalTime
offsets
:
this
.
_offsets
serverTimings
:
this
.
_serverTimings
}
;
}
async
getStackTrace
(
)
{
let
stacktrace
=
this
.
_stackTrace
;
if
(
stacktrace
&
&
typeof
stacktrace
=
=
"
boolean
"
)
{
let
id
;
if
(
this
.
_cause
.
type
=
=
"
websocket
"
)
{
id
=
this
.
_request
.
url
.
replace
(
/
^
http
/
"
ws
"
)
;
}
else
{
id
=
this
.
_channelId
;
}
const
messageManager
=
this
.
netMonitorActor
.
messageManager
;
stacktrace
=
await
new
Promise
(
resolve
=
>
{
const
onMessage
=
(
{
data
}
)
=
>
{
const
{
channelId
stack
}
=
data
;
if
(
channelId
=
=
id
)
{
messageManager
.
removeMessageListener
(
"
debug
:
request
-
stack
:
response
"
onMessage
)
;
resolve
(
stack
)
;
}
}
;
messageManager
.
addMessageListener
(
"
debug
:
request
-
stack
:
response
"
onMessage
)
;
messageManager
.
sendAsyncMessage
(
"
debug
:
request
-
stack
:
request
"
id
)
;
}
)
;
this
.
_stackTrace
=
stacktrace
;
}
return
{
stacktrace
}
;
}
addRequestHeaders
(
headers
rawHeaders
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_request
.
headers
=
headers
;
this
.
_prepareHeaders
(
headers
)
;
if
(
rawHeaders
)
{
rawHeaders
=
new
LongStringActor
(
this
.
conn
rawHeaders
)
;
this
.
manage
(
rawHeaders
)
;
rawHeaders
=
rawHeaders
.
form
(
)
;
}
this
.
_request
.
rawHeaders
=
rawHeaders
;
this
.
emit
(
"
network
-
event
-
update
:
headers
"
"
requestHeaders
"
{
headers
:
headers
.
length
headersSize
:
this
.
_request
.
headersSize
}
)
;
}
addRequestCookies
(
cookies
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_request
.
cookies
=
cookies
;
this
.
_prepareHeaders
(
cookies
)
;
this
.
emit
(
"
network
-
event
-
update
:
cookies
"
"
requestCookies
"
{
cookies
:
cookies
.
length
}
)
;
}
addRequestPostData
(
postData
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_request
.
postData
=
postData
;
postData
.
text
=
new
LongStringActor
(
this
.
conn
postData
.
text
)
;
this
.
manage
(
postData
.
text
)
;
const
dataSize
=
postData
.
size
;
postData
.
text
=
postData
.
text
.
form
(
)
;
this
.
emit
(
"
network
-
event
-
update
:
post
-
data
"
"
requestPostData
"
{
dataSize
discardRequestBody
:
this
.
_discardRequestBody
}
)
;
}
addResponseStart
(
info
rawHeaders
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
rawHeaders
=
new
LongStringActor
(
this
.
conn
rawHeaders
)
;
this
.
manage
(
rawHeaders
)
;
this
.
_response
.
rawHeaders
=
rawHeaders
.
form
(
)
;
this
.
_response
.
httpVersion
=
info
.
httpVersion
;
this
.
_response
.
status
=
info
.
status
;
this
.
_response
.
statusText
=
info
.
statusText
;
this
.
_response
.
headersSize
=
info
.
headersSize
;
this
.
_response
.
waitingTime
=
info
.
waitingTime
;
this
.
_discardResponseBody
=
!
!
info
.
discardResponseBody
;
this
.
emit
(
"
network
-
event
-
update
:
response
-
start
"
"
responseStart
"
{
response
:
info
}
)
;
}
addSecurityInfo
(
info
isRacing
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_securityInfo
=
info
;
this
.
emit
(
"
network
-
event
-
update
:
security
-
info
"
"
securityInfo
"
{
state
:
info
.
state
isRacing
}
)
;
}
addResponseHeaders
(
headers
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_response
.
headers
=
headers
;
this
.
_prepareHeaders
(
headers
)
;
this
.
emit
(
"
network
-
event
-
update
:
headers
"
"
responseHeaders
"
{
headers
:
headers
.
length
headersSize
:
this
.
_response
.
headersSize
}
)
;
}
addResponseCookies
(
cookies
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_response
.
cookies
=
cookies
;
this
.
_prepareHeaders
(
cookies
)
;
this
.
emit
(
"
network
-
event
-
update
:
cookies
"
"
responseCookies
"
{
cookies
:
cookies
.
length
}
)
;
}
addResponseContent
(
content
{
discardResponseBody
truncated
blockedReason
blockingExtension
}
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_truncated
=
truncated
;
this
.
_response
.
content
=
content
;
content
.
text
=
new
LongStringActor
(
this
.
conn
content
.
text
)
;
this
.
manage
(
content
.
text
)
;
content
.
text
=
content
.
text
.
form
(
)
;
this
.
emit
(
"
network
-
event
-
update
:
response
-
content
"
"
responseContent
"
{
mimeType
:
content
.
mimeType
contentSize
:
content
.
size
encoding
:
content
.
encoding
transferredSize
:
content
.
transferredSize
discardResponseBody
blockedReason
blockingExtension
}
)
;
}
addResponseCache
(
content
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_response
.
responseCache
=
content
.
responseCache
;
this
.
emit
(
"
network
-
event
-
update
:
response
-
cache
"
"
responseCache
"
)
;
}
addEventTimings
(
total
timings
offsets
serverTimings
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_totalTime
=
total
;
this
.
_timings
=
timings
;
this
.
_offsets
=
offsets
;
if
(
serverTimings
)
{
this
.
_serverTimings
=
serverTimings
;
}
this
.
emit
(
"
network
-
event
-
update
:
event
-
timings
"
"
eventTimings
"
{
totalTime
:
total
}
)
;
}
addServerTimings
(
serverTimings
)
{
if
(
serverTimings
)
{
this
.
_serverTimings
=
serverTimings
;
}
}
_prepareHeaders
(
headers
)
{
for
(
const
header
of
headers
)
{
header
.
value
=
new
LongStringActor
(
this
.
conn
header
.
value
)
;
this
.
manage
(
header
.
value
)
;
header
.
value
=
header
.
value
.
form
(
)
;
}
}
}
)
;
exports
.
NetworkEventActor
=
NetworkEventActor
;
