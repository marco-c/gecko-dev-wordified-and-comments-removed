"
use
strict
"
;
const
{
wildcardToRegExp
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
network
-
monitor
/
utils
/
wildcard
-
to
-
regexp
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkHelper
"
"
devtools
/
shared
/
webconsole
/
network
-
helper
"
)
;
loader
.
lazyGetter
(
this
"
tpFlagsMask
"
(
)
=
>
{
const
trackingProtectionLevel2Enabled
=
Services
.
prefs
.
getStringPref
(
"
urlclassifier
.
trackingTable
"
)
.
includes
(
"
content
-
track
-
digest256
"
)
;
return
trackingProtectionLevel2Enabled
?
~
Ci
.
nsIClassifiedChannel
.
CLASSIFIED_ANY_BASIC_TRACKING
&
~
Ci
.
nsIClassifiedChannel
.
CLASSIFIED_ANY_STRICT_TRACKING
:
~
Ci
.
nsIClassifiedChannel
.
CLASSIFIED_ANY_BASIC_TRACKING
&
Ci
.
nsIClassifiedChannel
.
CLASSIFIED_ANY_STRICT_TRACKING
;
}
)
;
const
LOAD_CAUSE_STRINGS
=
{
[
Ci
.
nsIContentPolicy
.
TYPE_INVALID
]
:
"
invalid
"
[
Ci
.
nsIContentPolicy
.
TYPE_OTHER
]
:
"
other
"
[
Ci
.
nsIContentPolicy
.
TYPE_SCRIPT
]
:
"
script
"
[
Ci
.
nsIContentPolicy
.
TYPE_IMAGE
]
:
"
img
"
[
Ci
.
nsIContentPolicy
.
TYPE_STYLESHEET
]
:
"
stylesheet
"
[
Ci
.
nsIContentPolicy
.
TYPE_OBJECT
]
:
"
object
"
[
Ci
.
nsIContentPolicy
.
TYPE_DOCUMENT
]
:
"
document
"
[
Ci
.
nsIContentPolicy
.
TYPE_SUBDOCUMENT
]
:
"
subdocument
"
[
Ci
.
nsIContentPolicy
.
TYPE_PING
]
:
"
ping
"
[
Ci
.
nsIContentPolicy
.
TYPE_XMLHTTPREQUEST
]
:
"
xhr
"
[
Ci
.
nsIContentPolicy
.
TYPE_OBJECT_SUBREQUEST
]
:
"
objectSubdoc
"
[
Ci
.
nsIContentPolicy
.
TYPE_DTD
]
:
"
dtd
"
[
Ci
.
nsIContentPolicy
.
TYPE_FONT
]
:
"
font
"
[
Ci
.
nsIContentPolicy
.
TYPE_MEDIA
]
:
"
media
"
[
Ci
.
nsIContentPolicy
.
TYPE_WEBSOCKET
]
:
"
websocket
"
[
Ci
.
nsIContentPolicy
.
TYPE_CSP_REPORT
]
:
"
csp
"
[
Ci
.
nsIContentPolicy
.
TYPE_XSLT
]
:
"
xslt
"
[
Ci
.
nsIContentPolicy
.
TYPE_BEACON
]
:
"
beacon
"
[
Ci
.
nsIContentPolicy
.
TYPE_FETCH
]
:
"
fetch
"
[
Ci
.
nsIContentPolicy
.
TYPE_IMAGESET
]
:
"
imageset
"
[
Ci
.
nsIContentPolicy
.
TYPE_WEB_MANIFEST
]
:
"
webManifest
"
}
;
exports
.
causeTypeToString
=
function
(
causeType
loadFlags
internalContentPolicyType
)
{
let
prefix
=
"
"
;
if
(
(
causeType
=
=
Ci
.
nsIContentPolicy
.
TYPE_IMAGESET
|
|
internalContentPolicyType
=
=
Ci
.
nsIContentPolicy
.
TYPE_INTERNAL_IMAGE
)
&
&
loadFlags
&
Ci
.
nsIRequest
.
LOAD_BACKGROUND
)
{
prefix
=
"
lazy
-
"
;
}
return
prefix
+
LOAD_CAUSE_STRINGS
[
causeType
]
|
|
"
unknown
"
;
}
;
exports
.
stringToCauseType
=
function
(
value
)
{
return
Object
.
keys
(
LOAD_CAUSE_STRINGS
)
.
find
(
key
=
>
LOAD_CAUSE_STRINGS
[
key
]
=
=
=
value
)
;
}
;
function
isChannelFromSystemPrincipal
(
channel
)
{
let
principal
=
null
;
let
browsingContext
=
channel
.
loadInfo
.
browsingContext
;
if
(
!
browsingContext
)
{
const
topFrame
=
NetworkHelper
.
getTopFrameForRequest
(
channel
)
;
if
(
topFrame
)
{
browsingContext
=
topFrame
.
browsingContext
;
}
else
{
principal
=
channel
.
loadInfo
.
triggeringPrincipal
;
}
}
if
(
!
principal
)
{
principal
=
CanonicalBrowsingContext
.
isInstance
(
browsingContext
)
?
browsingContext
.
currentWindowGlobal
.
documentPrincipal
:
browsingContext
.
window
.
document
.
nodePrincipal
;
}
return
principal
.
isSystemPrincipal
;
}
exports
.
getChannelBrowsingContextID
=
function
(
channel
)
{
if
(
channel
.
loadInfo
.
browsingContextID
)
{
return
channel
.
loadInfo
.
browsingContextID
;
}
const
topFrame
=
NetworkHelper
.
getTopFrameForRequest
(
channel
)
;
if
(
topFrame
&
&
topFrame
.
browsingContext
)
{
return
topFrame
.
browsingContext
.
id
;
}
return
null
;
}
;
exports
.
getChannelInnerWindowId
=
function
(
channel
)
{
if
(
channel
.
loadInfo
.
innerWindowID
)
{
return
channel
.
loadInfo
.
innerWindowID
;
}
const
topFrame
=
NetworkHelper
.
getTopFrameForRequest
(
channel
)
;
if
(
topFrame
?
.
browsingContext
?
.
currentWindowGlobal
)
{
return
topFrame
.
browsingContext
.
currentWindowGlobal
.
innerWindowId
;
}
return
null
;
}
;
exports
.
isPreloadRequest
=
function
(
channel
)
{
const
type
=
channel
.
loadInfo
.
internalContentPolicyType
;
return
(
type
=
=
Ci
.
nsIContentPolicy
.
TYPE_INTERNAL_SCRIPT_PRELOAD
|
|
type
=
=
Ci
.
nsIContentPolicy
.
TYPE_INTERNAL_MODULE_PRELOAD
|
|
type
=
=
Ci
.
nsIContentPolicy
.
TYPE_INTERNAL_IMAGE_PRELOAD
|
|
type
=
=
Ci
.
nsIContentPolicy
.
TYPE_INTERNAL_STYLESHEET_PRELOAD
|
|
type
=
=
Ci
.
nsIContentPolicy
.
TYPE_INTERNAL_FONT_PRELOAD
)
;
}
;
exports
.
createNetworkEvent
=
function
(
channel
{
timestamp
fromCache
fromServiceWorker
extraStringData
blockedReason
blockingExtension
=
null
blockedURLs
=
[
]
saveRequestAndResponseBodies
=
false
}
)
{
channel
.
QueryInterface
(
Ci
.
nsIPrivateBrowsingChannel
)
;
const
event
=
{
}
;
event
.
method
=
channel
.
requestMethod
;
event
.
channelId
=
channel
.
channelId
;
event
.
isFromSystemPrincipal
=
isChannelFromSystemPrincipal
(
channel
)
;
event
.
browsingContextID
=
this
.
getChannelBrowsingContextID
(
channel
)
;
event
.
innerWindowId
=
this
.
getChannelInnerWindowId
(
channel
)
;
event
.
url
=
channel
.
URI
.
spec
;
event
.
private
=
channel
.
isChannelPrivate
;
event
.
headersSize
=
extraStringData
?
extraStringData
.
length
:
0
;
event
.
startedDateTime
=
(
timestamp
?
new
Date
(
Math
.
round
(
timestamp
/
1000
)
)
:
new
Date
(
)
)
.
toISOString
(
)
;
event
.
fromCache
=
fromCache
;
event
.
fromServiceWorker
=
fromServiceWorker
;
if
(
channel
instanceof
Ci
.
nsIClassifiedChannel
)
{
event
.
isThirdPartyTrackingResource
=
!
!
(
channel
.
isThirdPartyTrackingResource
(
)
&
&
(
channel
.
thirdPartyClassificationFlags
&
tpFlagsMask
)
=
=
0
)
;
}
const
referrerInfo
=
channel
.
referrerInfo
;
event
.
referrerPolicy
=
referrerInfo
?
referrerInfo
.
getReferrerPolicyString
(
)
:
"
"
;
if
(
channel
instanceof
Ci
.
nsISupportsPriority
)
{
event
.
priority
=
channel
.
priority
;
}
let
causeType
=
Ci
.
nsIContentPolicy
.
TYPE_OTHER
;
let
causeUri
=
null
;
if
(
channel
.
loadInfo
)
{
causeType
=
channel
.
loadInfo
.
externalContentPolicyType
;
const
{
loadingPrincipal
}
=
channel
.
loadInfo
;
if
(
loadingPrincipal
)
{
causeUri
=
loadingPrincipal
.
spec
;
}
}
if
(
channel
.
notificationCallbacks
)
{
let
wsChannel
=
null
;
try
{
wsChannel
=
channel
.
notificationCallbacks
.
QueryInterface
(
Ci
.
nsIWebSocketChannel
)
;
}
catch
(
e
)
{
}
if
(
wsChannel
)
{
event
.
url
=
wsChannel
.
URI
.
spec
;
event
.
serial
=
wsChannel
.
serial
;
}
}
event
.
cause
=
{
type
:
this
.
causeTypeToString
(
causeType
channel
.
loadFlags
channel
.
loadInfo
.
internalContentPolicyType
)
loadingDocumentUri
:
causeUri
stacktrace
:
undefined
}
;
event
.
isXHR
=
causeType
=
=
=
Ci
.
nsIContentPolicy
.
TYPE_XMLHTTPREQUEST
|
|
causeType
=
=
=
Ci
.
nsIContentPolicy
.
TYPE_FETCH
;
const
httpVersionMaj
=
{
}
;
const
httpVersionMin
=
{
}
;
channel
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
;
channel
.
getRequestVersion
(
httpVersionMaj
httpVersionMin
)
;
event
.
httpVersion
=
"
HTTP
/
"
+
httpVersionMaj
.
value
+
"
.
"
+
httpVersionMin
.
value
;
event
.
discardRequestBody
=
!
saveRequestAndResponseBodies
;
event
.
discardResponseBody
=
!
saveRequestAndResponseBodies
;
if
(
!
blockedReason
)
{
if
(
blockedReason
!
=
=
undefined
)
{
event
.
blockedReason
=
"
unknown
"
;
}
else
if
(
blockedURLs
.
some
(
url
=
>
wildcardToRegExp
(
url
)
.
test
(
event
.
url
)
)
)
{
channel
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
event
.
blockedReason
=
"
devtools
"
;
}
}
else
{
event
.
blockedReason
=
blockedReason
;
if
(
blockingExtension
)
{
event
.
blockingExtension
=
blockingExtension
;
}
}
event
.
isNavigationRequest
=
channel
.
isMainDocumentChannel
&
&
channel
.
loadInfo
.
isTopLevelLoad
;
return
event
;
}
;
exports
.
fetchRequestHeadersAndCookies
=
function
(
channel
owner
{
extraStringData
=
"
"
}
)
{
const
headers
=
[
]
;
let
cookies
=
[
]
;
let
cookieHeader
=
null
;
channel
.
visitRequestHeaders
(
{
visitHeader
(
name
value
)
{
if
(
name
=
=
"
Cookie
"
)
{
cookieHeader
=
value
;
}
headers
.
push
(
{
name
value
}
)
;
}
}
)
;
if
(
cookieHeader
)
{
cookies
=
NetworkHelper
.
parseCookieHeader
(
cookieHeader
)
;
}
owner
.
addRequestHeaders
(
headers
extraStringData
)
;
owner
.
addRequestCookies
(
cookies
)
;
}
;
function
matchRequest
(
channel
filters
)
{
if
(
filters
.
sessionContext
)
{
const
{
type
}
=
filters
.
sessionContext
;
if
(
type
=
=
"
all
"
)
{
return
true
;
}
if
(
channel
.
loadInfo
?
.
loadingDocument
=
=
=
null
&
&
(
channel
.
loadInfo
.
loadingPrincipal
=
=
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
|
|
channel
.
loadInfo
.
isInDevToolsContext
)
)
{
return
false
;
}
if
(
type
=
=
"
browser
-
element
"
)
{
if
(
!
channel
.
loadInfo
.
browsingContext
)
{
const
topFrame
=
NetworkHelper
.
getTopFrameForRequest
(
channel
)
;
return
(
topFrame
?
.
browsingContext
?
.
browserId
=
=
filters
.
sessionContext
.
browserId
)
;
}
return
(
channel
.
loadInfo
.
browsingContext
.
browserId
=
=
filters
.
sessionContext
.
browserId
)
;
}
if
(
type
=
=
"
webextension
"
)
{
return
(
channel
?
.
loadInfo
.
loadingPrincipal
.
addonId
=
=
=
filters
.
sessionContext
.
addonId
)
;
}
throw
new
Error
(
"
Unsupported
session
context
type
:
"
+
type
)
;
}
if
(
filters
.
targetActor
)
{
let
windows
;
try
{
windows
=
filters
.
targetActor
.
windows
;
}
catch
(
e
)
{
return
false
;
}
const
win
=
NetworkHelper
.
getWindowForRequest
(
channel
)
;
return
windows
.
includes
(
win
)
;
}
return
legacyMatchRequest
(
channel
filters
)
;
}
function
legacyMatchRequest
(
channel
filters
)
{
if
(
!
filters
.
browserId
&
&
!
filters
.
window
&
&
!
filters
.
addonId
)
{
return
true
;
}
if
(
channel
.
loadInfo
&
&
channel
.
loadInfo
.
loadingDocument
=
=
=
null
&
&
(
channel
.
loadInfo
.
loadingPrincipal
=
=
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
|
|
channel
.
loadInfo
.
isInDevToolsContext
)
)
{
return
false
;
}
if
(
filters
.
window
)
{
let
win
=
NetworkHelper
.
getWindowForRequest
(
channel
)
;
if
(
filters
.
matchExactWindow
)
{
return
win
=
=
filters
.
window
;
}
while
(
win
)
{
if
(
win
=
=
filters
.
window
)
{
return
true
;
}
if
(
win
.
parent
=
=
win
)
{
break
;
}
win
=
win
.
parent
;
}
return
false
;
}
if
(
filters
.
browserId
)
{
const
topFrame
=
NetworkHelper
.
getTopFrameForRequest
(
channel
)
;
if
(
topFrame
?
.
browsingContext
?
.
browserId
=
=
filters
.
browserId
)
{
return
true
;
}
if
(
channel
.
loadInfo
&
&
channel
.
loadInfo
.
browsingContext
&
&
channel
.
loadInfo
.
browsingContext
.
browserId
=
=
filters
.
browserId
)
{
return
true
;
}
}
if
(
filters
.
addonId
&
&
channel
?
.
loadInfo
.
loadingPrincipal
.
addonId
=
=
=
filters
.
addonId
)
{
return
true
;
}
return
false
;
}
exports
.
matchRequest
=
matchRequest
;
