"
use
strict
"
;
const
{
ActorClassWithSpec
Actor
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
networkParentSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
network
-
parent
"
)
;
const
{
TYPES
:
{
NETWORK_EVENT
}
getResourceWatcher
}
=
require
(
"
devtools
/
server
/
actors
/
resources
/
index
"
)
;
const
NetworkParentActor
=
ActorClassWithSpec
(
networkParentSpec
{
initialize
(
watcherActor
)
{
this
.
watcherActor
=
watcherActor
;
Actor
.
prototype
.
initialize
.
call
(
this
this
.
watcherActor
.
conn
)
;
}
defaultThrottleData
:
undefined
isEqual
(
next
current
)
{
if
(
current
&
&
next
&
&
next
=
=
current
)
{
return
Object
.
entries
(
current
)
.
every
(
(
[
k
v
]
)
=
>
{
return
next
[
k
]
=
=
=
v
;
}
)
;
}
return
false
;
}
destroy
(
conn
)
{
Actor
.
prototype
.
destroy
.
call
(
this
conn
)
;
}
get
networkEventWatcher
(
)
{
return
getResourceWatcher
(
this
.
watcherActor
NETWORK_EVENT
)
;
}
setNetworkThrottling
(
throttleData
)
{
if
(
!
this
.
networkEventWatcher
)
{
throw
new
Error
(
"
Not
listening
for
network
events
"
)
;
}
if
(
throttleData
!
=
=
null
)
{
throttleData
=
{
latencyMean
:
throttleData
.
latency
latencyMax
:
throttleData
.
latency
downloadBPSMean
:
throttleData
.
downloadThroughput
downloadBPSMax
:
throttleData
.
downloadThroughput
uploadBPSMean
:
throttleData
.
uploadThroughput
uploadBPSMax
:
throttleData
.
uploadThroughput
}
;
}
const
currentThrottleData
=
this
.
networkEventWatcher
.
getThrottleData
(
)
;
if
(
this
.
isEqual
(
throttleData
currentThrottleData
)
)
{
return
;
}
if
(
this
.
defaultThrottleData
=
=
=
undefined
)
{
this
.
defaultThrottleData
=
currentThrottleData
;
}
this
.
networkEventWatcher
.
setThrottleData
(
throttleData
)
;
}
getNetworkThrottling
(
)
{
if
(
!
this
.
networkEventWatcher
)
{
throw
new
Error
(
"
Not
listening
for
network
events
"
)
;
}
const
throttleData
=
this
.
networkEventWatcher
.
getThrottleData
(
)
;
if
(
!
throttleData
)
{
return
null
;
}
return
{
downloadThroughput
:
throttleData
.
downloadBPSMax
uploadThroughput
:
throttleData
.
uploadBPSMax
latency
:
throttleData
.
latencyMax
}
;
}
clearNetworkThrottling
(
)
{
if
(
this
.
defaultThrottleData
!
=
=
undefined
)
{
this
.
setNetworkThrottling
(
this
.
defaultThrottleData
)
;
}
}
setSaveRequestAndResponseBodies
(
save
)
{
if
(
!
this
.
networkEventWatcher
)
{
throw
new
Error
(
"
Not
listening
for
network
events
"
)
;
}
this
.
networkEventWatcher
.
setSaveRequestAndResponseBodies
(
save
)
;
}
setBlockedUrls
(
urls
)
{
if
(
!
this
.
networkEventWatcher
)
{
throw
new
Error
(
"
Not
listening
for
network
events
"
)
;
}
this
.
networkEventWatcher
.
setBlockedUrls
(
urls
)
;
return
{
}
;
}
getBlockedUrls
(
)
{
if
(
!
this
.
networkEventWatcher
)
{
throw
new
Error
(
"
Not
listening
for
network
events
"
)
;
}
return
this
.
networkEventWatcher
.
getBlockedUrls
(
)
;
}
blockRequest
(
filters
)
{
if
(
!
this
.
networkEventWatcher
)
{
throw
new
Error
(
"
Not
listening
for
network
events
"
)
;
}
this
.
networkEventWatcher
.
blockRequest
(
filters
)
;
}
unblockRequest
(
filters
)
{
if
(
!
this
.
networkEventWatcher
)
{
throw
new
Error
(
"
Not
listening
for
network
events
"
)
;
}
this
.
networkEventWatcher
.
unblockRequest
(
filters
)
;
}
setPersist
(
enabled
)
{
if
(
!
this
.
networkEventWatcher
)
{
return
;
}
this
.
networkEventWatcher
.
setPersist
(
enabled
)
;
}
}
)
;
exports
.
NetworkParentActor
=
NetworkParentActor
;
