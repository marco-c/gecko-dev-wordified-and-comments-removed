"
use
strict
"
;
const
DEBUG_PLATFORM_EVENTS
=
false
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
ChannelMap
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
utils
/
channel
-
map
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkUtils
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
utils
/
network
-
utils
"
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkHelper
"
"
devtools
/
shared
/
webconsole
/
network
-
helper
"
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsUtils
"
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkThrottleManager
"
"
devtools
/
shared
/
webconsole
/
throttle
"
true
)
;
loader
.
lazyServiceGetter
(
this
"
gActivityDistributor
"
"
mozilla
.
org
/
network
/
http
-
activity
-
distributor
;
1
"
"
nsIHttpActivityDistributor
"
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkResponseListener
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
network
-
response
-
listener
"
true
)
;
function
logPlatformEvent
(
eventName
channel
message
=
"
"
)
{
if
(
!
DEBUG_PLATFORM_EVENTS
)
{
return
;
}
dump
(
[
netmonitor
]
{
channel
.
channelId
}
-
{
eventName
}
{
message
}
\
n
)
;
}
const
PR_UINT32_MAX
=
4294967295
;
const
HTTP_MOVED_PERMANENTLY
=
301
;
const
HTTP_FOUND
=
302
;
const
HTTP_SEE_OTHER
=
303
;
const
HTTP_TEMPORARY_REDIRECT
=
307
;
function
NetworkObserver
(
filters
owner
)
{
this
.
filters
=
filters
;
this
.
owner
=
owner
;
this
.
openRequests
=
new
ChannelMap
(
)
;
this
.
openResponses
=
new
ChannelMap
(
)
;
this
.
blockedURLs
=
[
]
;
this
.
_httpResponseExaminer
=
DevToolsUtils
.
makeInfallible
(
this
.
_httpResponseExaminer
)
.
bind
(
this
)
;
this
.
_httpModifyExaminer
=
DevToolsUtils
.
makeInfallible
(
this
.
_httpModifyExaminer
)
.
bind
(
this
)
;
this
.
_httpFailedOpening
=
DevToolsUtils
.
makeInfallible
(
this
.
_httpFailedOpening
)
.
bind
(
this
)
;
this
.
_httpStopRequest
=
DevToolsUtils
.
makeInfallible
(
this
.
_httpStopRequest
)
.
bind
(
this
)
;
this
.
_serviceWorkerRequest
=
this
.
_serviceWorkerRequest
.
bind
(
this
)
;
this
.
_throttleData
=
null
;
this
.
_throttler
=
null
;
this
.
_decodedCertificateCache
=
new
Map
(
)
;
}
exports
.
NetworkObserver
=
NetworkObserver
;
NetworkObserver
.
prototype
=
{
filters
:
null
httpTransactionCodes
:
{
0x5001
:
"
REQUEST_HEADER
"
0x5002
:
"
REQUEST_BODY_SENT
"
0x5003
:
"
RESPONSE_START
"
0x5004
:
"
RESPONSE_HEADER
"
0x5005
:
"
RESPONSE_COMPLETE
"
0x5006
:
"
TRANSACTION_CLOSE
"
0x804b0003
:
"
STATUS_RESOLVING
"
0x804b000b
:
"
STATUS_RESOLVED
"
0x804b0007
:
"
STATUS_CONNECTING_TO
"
0x804b0004
:
"
STATUS_CONNECTED_TO
"
0x804b0005
:
"
STATUS_SENDING_TO
"
0x804b000a
:
"
STATUS_WAITING_FOR
"
0x804b0006
:
"
STATUS_RECEIVING_FROM
"
0x804b000c
:
"
STATUS_TLS_STARTING
"
0x804b000d
:
"
STATUS_TLS_ENDING
"
}
httpDownloadActivities
:
[
gActivityDistributor
.
ACTIVITY_SUBTYPE_RESPONSE_START
gActivityDistributor
.
ACTIVITY_SUBTYPE_RESPONSE_HEADER
gActivityDistributor
.
ACTIVITY_SUBTYPE_RESPONSE_COMPLETE
gActivityDistributor
.
ACTIVITY_SUBTYPE_TRANSACTION_CLOSE
]
responsePipeSegmentSize
:
null
owner
:
null
saveRequestAndResponseBodies
:
true
openRequests
:
null
openResponses
:
null
init
(
)
{
this
.
responsePipeSegmentSize
=
Services
.
prefs
.
getIntPref
(
"
network
.
buffer
.
cache
.
size
"
)
;
this
.
interceptedChannels
=
new
WeakSet
(
)
;
if
(
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
)
{
gActivityDistributor
.
addObserver
(
this
)
;
Services
.
obs
.
addObserver
(
this
.
_httpResponseExaminer
"
http
-
on
-
examine
-
response
"
)
;
Services
.
obs
.
addObserver
(
this
.
_httpResponseExaminer
"
http
-
on
-
examine
-
cached
-
response
"
)
;
Services
.
obs
.
addObserver
(
this
.
_httpModifyExaminer
"
http
-
on
-
modify
-
request
"
)
;
Services
.
obs
.
addObserver
(
this
.
_httpStopRequest
"
http
-
on
-
stop
-
request
"
)
;
}
else
{
Services
.
obs
.
addObserver
(
this
.
_httpFailedOpening
"
http
-
on
-
failed
-
opening
-
request
"
)
;
}
Services
.
obs
.
addObserver
(
this
.
_serviceWorkerRequest
"
service
-
worker
-
synthesized
-
response
"
)
;
}
get
throttleData
(
)
{
return
this
.
_throttleData
;
}
set
throttleData
(
value
)
{
this
.
_throttleData
=
value
;
this
.
_throttler
=
null
;
}
_getThrottler
(
)
{
if
(
this
.
throttleData
!
=
=
null
&
&
this
.
_throttler
=
=
=
null
)
{
this
.
_throttler
=
new
NetworkThrottleManager
(
this
.
throttleData
)
;
}
return
this
.
_throttler
;
}
_shouldIgnoreChannel
(
channel
)
{
if
(
typeof
this
.
owner
.
shouldIgnoreChannel
=
=
"
function
"
&
&
this
.
owner
.
shouldIgnoreChannel
(
channel
)
)
{
return
true
;
}
return
!
NetworkUtils
.
matchRequest
(
channel
this
.
filters
)
;
}
_decodedCertificateCache
:
null
_serviceWorkerRequest
(
subject
topic
data
)
{
const
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
this
.
_shouldIgnoreChannel
(
channel
)
)
{
return
;
}
logPlatformEvent
(
topic
channel
)
;
this
.
interceptedChannels
.
add
(
subject
)
;
this
.
_httpResponseExaminer
(
channel
"
http
-
on
-
examine
-
cached
-
response
"
)
;
}
_httpFailedOpening
(
subject
topic
)
{
if
(
!
this
.
owner
|
|
topic
!
=
"
http
-
on
-
failed
-
opening
-
request
"
|
|
!
(
subject
instanceof
Ci
.
nsIHttpChannel
)
)
{
return
;
}
const
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
this
.
_shouldIgnoreChannel
(
channel
)
)
{
return
;
}
logPlatformEvent
(
topic
channel
)
;
if
(
NetworkUtils
.
isPreloadRequest
(
channel
)
)
{
return
;
}
const
blockedCode
=
channel
.
loadInfo
.
requestBlockingReason
;
this
.
_httpResponseExaminer
(
subject
topic
blockedCode
)
;
}
_httpStopRequest
(
subject
topic
)
{
if
(
!
this
.
owner
|
|
topic
!
=
"
http
-
on
-
stop
-
request
"
|
|
!
(
subject
instanceof
Ci
.
nsIHttpChannel
)
)
{
return
;
}
const
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
this
.
_shouldIgnoreChannel
(
channel
)
)
{
return
;
}
logPlatformEvent
(
topic
channel
)
;
let
id
;
let
reason
;
try
{
const
request
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
const
properties
=
request
.
QueryInterface
(
Ci
.
nsIPropertyBag
)
;
reason
=
request
.
loadInfo
.
requestBlockingReason
;
id
=
properties
.
getProperty
(
"
cancelledByExtension
"
)
;
if
(
typeof
WebExtensionPolicy
!
=
=
"
undefined
"
)
{
id
=
WebExtensionPolicy
.
getByID
(
id
)
.
name
;
}
}
catch
(
err
)
{
}
const
httpActivity
=
this
.
createOrGetActivityObject
(
channel
)
;
const
serverTimings
=
this
.
_extractServerTimings
(
channel
)
;
if
(
httpActivity
.
owner
)
{
httpActivity
.
owner
.
addServerTimings
(
serverTimings
)
;
}
else
{
const
{
status
}
=
channel
;
if
(
status
=
=
0
)
{
this
.
_createNetworkEvent
(
subject
{
inProgressRequest
:
true
}
)
;
}
else
{
if
(
reason
=
=
0
)
{
reason
=
ChromeUtils
.
getXPCOMErrorName
(
status
)
;
}
this
.
_createNetworkEvent
(
subject
{
blockedReason
:
reason
blockingExtension
:
id
}
)
;
}
}
}
_httpResponseExaminer
(
subject
topic
blockedReason
)
{
if
(
!
this
.
owner
|
|
(
topic
!
=
"
http
-
on
-
examine
-
response
"
&
&
topic
!
=
"
http
-
on
-
examine
-
cached
-
response
"
&
&
topic
!
=
"
http
-
on
-
failed
-
opening
-
request
"
)
|
|
!
(
subject
instanceof
Ci
.
nsIHttpChannel
)
|
|
!
(
subject
instanceof
Ci
.
nsIClassifiedChannel
)
)
{
return
;
}
const
blockedOrFailed
=
topic
=
=
=
"
http
-
on
-
failed
-
opening
-
request
"
;
subject
.
QueryInterface
(
Ci
.
nsIClassifiedChannel
)
;
const
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
this
.
_shouldIgnoreChannel
(
channel
)
)
{
return
;
}
logPlatformEvent
(
topic
subject
blockedOrFailed
?
"
blockedOrFailed
:
"
+
blockedReason
:
channel
.
responseStatus
)
;
const
response
=
{
id
:
gSequenceId
(
)
channel
headers
:
[
]
cookies
:
[
]
}
;
const
setCookieHeaders
=
[
]
;
if
(
!
blockedOrFailed
)
{
channel
.
visitOriginalResponseHeaders
(
{
visitHeader
(
name
value
)
{
const
lowerName
=
name
.
toLowerCase
(
)
;
if
(
lowerName
=
=
"
set
-
cookie
"
)
{
setCookieHeaders
.
push
(
value
)
;
}
response
.
headers
.
push
(
{
name
value
}
)
;
}
}
)
;
if
(
!
response
.
headers
.
length
)
{
return
;
}
if
(
setCookieHeaders
.
length
)
{
response
.
cookies
=
setCookieHeaders
.
reduce
(
(
result
header
)
=
>
{
const
cookies
=
NetworkHelper
.
parseSetCookieHeader
(
header
)
;
return
result
.
concat
(
cookies
)
;
}
[
]
)
;
}
}
const
httpVersionMaj
=
{
}
;
const
httpVersionMin
=
{
}
;
channel
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
;
if
(
!
blockedOrFailed
)
{
channel
.
getResponseVersion
(
httpVersionMaj
httpVersionMin
)
;
response
.
status
=
channel
.
responseStatus
;
response
.
statusText
=
channel
.
responseStatusText
;
if
(
httpVersionMaj
.
value
>
1
)
{
response
.
httpVersion
=
"
HTTP
/
"
+
httpVersionMaj
.
value
;
}
else
{
response
.
httpVersion
=
"
HTTP
/
"
+
httpVersionMaj
.
value
+
"
.
"
+
httpVersionMin
.
value
;
}
this
.
openResponses
.
set
(
channel
response
)
;
}
if
(
topic
=
=
=
"
http
-
on
-
examine
-
cached
-
response
"
)
{
const
fromServiceWorker
=
this
.
interceptedChannels
.
has
(
channel
)
;
this
.
interceptedChannels
.
delete
(
channel
)
;
let
httpActivity
=
this
.
createOrGetActivityObject
(
channel
)
;
if
(
!
httpActivity
.
owner
)
{
httpActivity
=
this
.
_createNetworkEvent
(
channel
{
fromCache
:
!
fromServiceWorker
fromServiceWorker
}
)
;
}
this
.
_onRequestBodySent
(
httpActivity
)
;
this
.
_sendRequestBody
(
httpActivity
)
;
httpActivity
.
owner
.
addResponseStart
(
{
httpVersion
:
response
.
httpVersion
remoteAddress
:
"
"
remotePort
:
"
"
status
:
response
.
status
statusText
:
response
.
statusText
headersSize
:
0
waitingTime
:
0
}
"
"
true
)
;
const
timings
=
this
.
_setupHarTimings
(
httpActivity
true
)
;
const
serverTimings
=
this
.
_extractServerTimings
(
httpActivity
.
channel
)
;
httpActivity
.
owner
.
addEventTimings
(
timings
.
total
timings
.
timings
timings
.
offsets
serverTimings
)
;
}
else
if
(
topic
=
=
=
"
http
-
on
-
failed
-
opening
-
request
"
)
{
this
.
_createNetworkEvent
(
channel
{
blockedReason
}
)
;
}
}
_httpModifyExaminer
(
subject
)
{
const
throttler
=
this
.
_getThrottler
(
)
;
if
(
throttler
)
{
const
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
this
.
_shouldIgnoreChannel
(
channel
)
)
{
return
;
}
logPlatformEvent
(
"
http
-
on
-
modify
-
request
"
channel
)
;
const
httpActivity
=
this
.
createOrGetActivityObject
(
channel
)
;
this
.
_onRequestBodySent
(
httpActivity
)
;
throttler
.
manageUpload
(
channel
)
;
}
}
_dispatchActivity
(
httpActivity
channel
activityType
activitySubtype
timestamp
extraSizeData
extraStringData
)
{
const
transCodes
=
this
.
httpTransactionCodes
;
if
(
activitySubtype
in
transCodes
)
{
const
stage
=
transCodes
[
activitySubtype
]
;
if
(
stage
in
httpActivity
.
timings
)
{
httpActivity
.
timings
[
stage
]
.
last
=
timestamp
;
}
else
{
httpActivity
.
timings
[
stage
]
=
{
first
:
timestamp
last
:
timestamp
}
;
}
}
switch
(
activitySubtype
)
{
case
gActivityDistributor
.
ACTIVITY_SUBTYPE_REQUEST_BODY_SENT
:
this
.
_onRequestBodySent
(
httpActivity
)
;
this
.
_sendRequestBody
(
httpActivity
)
;
break
;
case
gActivityDistributor
.
ACTIVITY_SUBTYPE_RESPONSE_HEADER
:
this
.
_onResponseHeader
(
httpActivity
extraStringData
)
;
break
;
case
gActivityDistributor
.
ACTIVITY_SUBTYPE_TRANSACTION_CLOSE
:
this
.
_onTransactionClose
(
httpActivity
)
;
break
;
default
:
break
;
}
}
getActivityTypeString
(
activityType
activitySubtype
)
{
if
(
activityType
=
=
=
Ci
.
nsIHttpActivityObserver
.
ACTIVITY_TYPE_SOCKET_TRANSPORT
)
{
for
(
const
name
in
Ci
.
nsISocketTransport
)
{
if
(
Ci
.
nsISocketTransport
[
name
]
=
=
=
activitySubtype
)
{
return
"
SOCKET_TRANSPORT
:
"
+
name
;
}
}
}
else
if
(
activityType
=
=
=
Ci
.
nsIHttpActivityObserver
.
ACTIVITY_TYPE_HTTP_TRANSACTION
)
{
for
(
const
name
in
Ci
.
nsIHttpActivityObserver
)
{
if
(
Ci
.
nsIHttpActivityObserver
[
name
]
=
=
=
activitySubtype
)
{
return
"
HTTP_TRANSACTION
:
"
+
name
.
replace
(
"
ACTIVITY_SUBTYPE_
"
"
"
)
;
}
}
}
return
"
unexpected
-
activity
-
types
:
"
+
activityType
+
"
:
"
+
activitySubtype
;
}
observeActivity
:
DevToolsUtils
.
makeInfallible
(
function
(
channel
activityType
activitySubtype
timestamp
extraSizeData
extraStringData
)
{
if
(
!
this
.
owner
|
|
(
activityType
!
=
gActivityDistributor
.
ACTIVITY_TYPE_HTTP_TRANSACTION
&
&
activityType
!
=
gActivityDistributor
.
ACTIVITY_TYPE_SOCKET_TRANSPORT
)
)
{
return
;
}
if
(
!
(
channel
instanceof
Ci
.
nsIHttpChannel
)
|
|
!
(
channel
instanceof
Ci
.
nsIClassifiedChannel
)
)
{
return
;
}
channel
=
channel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
channel
=
channel
.
QueryInterface
(
Ci
.
nsIClassifiedChannel
)
;
if
(
DEBUG_PLATFORM_EVENTS
)
{
logPlatformEvent
(
this
.
getActivityTypeString
(
activityType
activitySubtype
)
channel
)
;
}
if
(
activitySubtype
=
=
gActivityDistributor
.
ACTIVITY_SUBTYPE_REQUEST_HEADER
)
{
this
.
_onRequestHeader
(
channel
timestamp
extraStringData
)
;
return
;
}
const
httpActivity
=
this
.
_findActivityObject
(
channel
)
;
if
(
!
httpActivity
)
{
return
;
}
if
(
httpActivity
.
downloadThrottle
&
&
this
.
httpDownloadActivities
.
includes
(
activitySubtype
)
)
{
const
callback
=
this
.
_dispatchActivity
.
bind
(
this
)
;
httpActivity
.
downloadThrottle
.
addActivityCallback
(
callback
httpActivity
channel
activityType
activitySubtype
timestamp
extraSizeData
extraStringData
)
;
}
else
{
this
.
_dispatchActivity
(
httpActivity
channel
activityType
activitySubtype
timestamp
extraSizeData
extraStringData
)
;
}
}
)
_createNetworkEvent
(
channel
{
timestamp
extraStringData
fromCache
fromServiceWorker
blockedReason
blockingExtension
inProgressRequest
}
)
{
const
httpActivity
=
this
.
createOrGetActivityObject
(
channel
)
;
if
(
timestamp
)
{
httpActivity
.
timings
.
REQUEST_HEADER
=
{
first
:
timestamp
last
:
timestamp
}
;
}
const
event
=
NetworkUtils
.
createNetworkEvent
(
channel
{
timestamp
fromCache
fromServiceWorker
extraStringData
blockedReason
blockingExtension
blockedURLs
:
this
.
blockedURLs
saveRequestAndResponseBodies
:
this
.
saveRequestAndResponseBodies
}
)
;
httpActivity
.
isXHR
=
event
.
isXHR
;
httpActivity
.
private
=
event
.
private
;
httpActivity
.
fromServiceWorker
=
fromServiceWorker
;
httpActivity
.
owner
=
this
.
owner
.
onNetworkEvent
(
event
)
;
const
recordRequestContent
=
!
event
.
blockedReason
&
&
!
inProgressRequest
;
if
(
recordRequestContent
)
{
this
.
_setupResponseListener
(
httpActivity
fromCache
)
;
}
NetworkUtils
.
fetchRequestHeadersAndCookies
(
channel
httpActivity
.
owner
{
extraStringData
}
)
;
return
httpActivity
;
}
_onRequestHeader
(
channel
timestamp
extraStringData
)
{
if
(
this
.
_shouldIgnoreChannel
(
channel
)
)
{
return
;
}
this
.
_createNetworkEvent
(
channel
{
timestamp
extraStringData
}
)
;
}
_findActivityObject
(
channel
)
{
return
this
.
openRequests
.
getChannelById
(
channel
.
channelId
)
;
}
createOrGetActivityObject
(
channel
)
{
let
httpActivity
=
this
.
_findActivityObject
(
channel
)
;
if
(
!
httpActivity
)
{
const
win
=
NetworkHelper
.
getWindowForRequest
(
channel
)
;
const
charset
=
win
?
win
.
document
.
characterSet
:
null
;
httpActivity
=
{
id
:
gSequenceId
(
)
channel
charset
sentBody
:
null
url
:
channel
.
URI
.
spec
headersSize
:
null
hostname
:
channel
.
URI
.
host
discardRequestBody
:
!
this
.
saveRequestAndResponseBodies
discardResponseBody
:
!
this
.
saveRequestAndResponseBodies
timings
:
{
}
responseStatus
:
null
owner
:
null
}
;
this
.
openRequests
.
set
(
channel
httpActivity
)
;
}
return
httpActivity
;
}
blockRequest
(
filter
)
{
if
(
!
filter
|
|
!
filter
.
url
)
{
return
;
}
this
.
blockedURLs
.
push
(
filter
.
url
)
;
}
unblockRequest
(
filter
)
{
if
(
!
filter
|
|
!
filter
.
url
)
{
return
;
}
this
.
blockedURLs
=
this
.
blockedURLs
.
filter
(
url
=
>
url
!
=
filter
.
url
)
;
}
setBlockedUrls
(
urls
)
{
this
.
blockedURLs
=
urls
|
|
[
]
;
}
getBlockedUrls
(
)
{
return
this
.
blockedURLs
;
}
_setupResponseListener
(
httpActivity
fromCache
)
{
const
channel
=
httpActivity
.
channel
;
channel
.
QueryInterface
(
Ci
.
nsITraceableChannel
)
;
if
(
!
fromCache
)
{
const
throttler
=
this
.
_getThrottler
(
)
;
if
(
throttler
)
{
httpActivity
.
downloadThrottle
=
throttler
.
manage
(
channel
)
;
}
}
const
sink
=
Cc
[
"
mozilla
.
org
/
pipe
;
1
"
]
.
createInstance
(
Ci
.
nsIPipe
)
;
sink
.
init
(
false
false
this
.
responsePipeSegmentSize
PR_UINT32_MAX
null
)
;
const
newListener
=
new
NetworkResponseListener
(
this
httpActivity
this
.
_decodedCertificateCache
)
;
newListener
.
inputStream
=
sink
.
inputStream
;
newListener
.
sink
=
sink
;
const
tee
=
Cc
[
"
mozilla
.
org
/
network
/
stream
-
listener
-
tee
;
1
"
]
.
createInstance
(
Ci
.
nsIStreamListenerTee
)
;
const
originalListener
=
channel
.
setNewListener
(
tee
)
;
tee
.
init
(
originalListener
sink
.
outputStream
newListener
)
;
}
_onRequestBodySent
(
httpActivity
)
{
if
(
httpActivity
.
discardRequestBody
|
|
httpActivity
.
sentBody
!
=
=
null
)
{
return
;
}
let
sentBody
=
NetworkHelper
.
readPostTextFromRequest
(
httpActivity
.
channel
httpActivity
.
charset
)
;
if
(
sentBody
!
=
=
null
&
&
this
.
window
&
&
httpActivity
.
url
=
=
this
.
window
.
location
.
href
)
{
const
webNav
=
this
.
window
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
sentBody
=
NetworkHelper
.
readPostTextFromPageViaWebNav
(
webNav
httpActivity
.
charset
)
;
}
if
(
sentBody
!
=
=
null
)
{
httpActivity
.
sentBody
=
sentBody
;
}
}
_onResponseHeader
(
httpActivity
extraStringData
)
{
const
headers
=
extraStringData
.
split
(
/
\
r
\
n
|
\
n
|
\
r
/
)
;
const
statusLine
=
headers
.
shift
(
)
;
const
statusLineArray
=
statusLine
.
split
(
"
"
)
;
const
response
=
{
}
;
response
.
httpVersion
=
statusLineArray
.
shift
(
)
;
response
.
remoteAddress
=
httpActivity
.
channel
.
remoteAddress
;
response
.
remotePort
=
httpActivity
.
channel
.
remotePort
;
response
.
status
=
statusLineArray
.
shift
(
)
;
response
.
statusText
=
statusLineArray
.
join
(
"
"
)
;
response
.
headersSize
=
extraStringData
.
length
;
response
.
waitingTime
=
this
.
_convertTimeToMs
(
this
.
_getWaitTiming
(
httpActivity
.
timings
)
)
;
const
contentType
=
headers
.
find
(
header
=
>
{
const
lowerName
=
header
.
toLowerCase
(
)
;
return
lowerName
.
startsWith
(
"
content
-
type
"
)
;
}
)
;
if
(
contentType
)
{
response
.
mimeType
=
contentType
.
slice
(
"
Content
-
Type
:
"
.
length
)
;
}
httpActivity
.
responseStatus
=
response
.
status
;
httpActivity
.
headersSize
=
response
.
headersSize
;
switch
(
parseInt
(
response
.
status
10
)
)
{
case
HTTP_MOVED_PERMANENTLY
:
case
HTTP_FOUND
:
case
HTTP_SEE_OTHER
:
case
HTTP_TEMPORARY_REDIRECT
:
httpActivity
.
discardResponseBody
=
true
;
break
;
}
response
.
discardResponseBody
=
httpActivity
.
discardResponseBody
;
httpActivity
.
owner
.
addResponseStart
(
response
extraStringData
)
;
}
_onTransactionClose
(
httpActivity
)
{
if
(
httpActivity
.
owner
)
{
const
result
=
this
.
_setupHarTimings
(
httpActivity
)
;
const
serverTimings
=
this
.
_extractServerTimings
(
httpActivity
.
channel
)
;
httpActivity
.
owner
.
addEventTimings
(
result
.
total
result
.
timings
result
.
offsets
serverTimings
)
;
}
}
_getBlockedTiming
(
timings
)
{
if
(
timings
.
STATUS_RESOLVING
&
&
timings
.
STATUS_CONNECTING_TO
)
{
return
timings
.
STATUS_RESOLVING
.
first
-
timings
.
REQUEST_HEADER
.
first
;
}
else
if
(
timings
.
STATUS_SENDING_TO
)
{
return
timings
.
STATUS_SENDING_TO
.
first
-
timings
.
REQUEST_HEADER
.
first
;
}
return
-
1
;
}
_getDnsTiming
(
timings
)
{
if
(
timings
.
STATUS_RESOLVING
&
&
timings
.
STATUS_RESOLVED
)
{
return
timings
.
STATUS_RESOLVED
.
last
-
timings
.
STATUS_RESOLVING
.
first
;
}
return
-
1
;
}
_getConnectTiming
(
timings
)
{
if
(
timings
.
STATUS_CONNECTING_TO
&
&
timings
.
STATUS_CONNECTED_TO
)
{
return
(
timings
.
STATUS_CONNECTED_TO
.
last
-
timings
.
STATUS_CONNECTING_TO
.
first
)
;
}
return
-
1
;
}
_getReceiveTiming
(
timings
)
{
if
(
timings
.
RESPONSE_START
&
&
timings
.
RESPONSE_COMPLETE
)
{
return
timings
.
RESPONSE_COMPLETE
.
last
-
timings
.
RESPONSE_START
.
first
;
}
return
-
1
;
}
_getWaitTiming
(
timings
)
{
if
(
timings
.
RESPONSE_START
)
{
return
(
timings
.
RESPONSE_START
.
first
-
(
timings
.
REQUEST_BODY_SENT
|
|
timings
.
STATUS_SENDING_TO
)
.
last
)
;
}
return
-
1
;
}
_getSslTiming
(
timings
)
{
if
(
timings
.
STATUS_TLS_STARTING
&
&
timings
.
STATUS_TLS_ENDING
)
{
return
timings
.
STATUS_TLS_ENDING
.
last
-
timings
.
STATUS_TLS_STARTING
.
first
;
}
return
-
1
;
}
_getSendTiming
(
timings
)
{
if
(
timings
.
STATUS_SENDING_TO
)
{
return
timings
.
STATUS_SENDING_TO
.
last
-
timings
.
STATUS_SENDING_TO
.
first
;
}
else
if
(
timings
.
REQUEST_HEADER
&
&
timings
.
REQUEST_BODY_SENT
)
{
return
timings
.
REQUEST_BODY_SENT
.
last
-
timings
.
REQUEST_HEADER
.
first
;
}
return
-
1
;
}
_getDataFromTimedChannel
(
timedChannel
)
{
const
lookUpArr
=
[
"
tcpConnectEndTime
"
"
connectStartTime
"
"
connectEndTime
"
"
secureConnectionStartTime
"
"
domainLookupEndTime
"
"
domainLookupStartTime
"
]
;
return
lookUpArr
.
reduce
(
(
prev
prop
)
=
>
{
const
propName
=
prop
+
"
Tc
"
;
return
{
.
.
.
prev
[
propName
]
:
(
(
)
=
>
{
if
(
!
timedChannel
)
{
return
0
;
}
const
value
=
timedChannel
[
prop
]
;
if
(
value
!
=
0
&
&
timedChannel
.
asyncOpenTime
&
&
value
<
timedChannel
.
asyncOpenTime
)
{
return
0
;
}
return
value
;
}
)
(
)
}
;
}
{
}
)
;
}
_getSecureConnectionStartTimeInfo
(
timings
)
{
let
secureConnectionStartTime
=
0
;
let
secureConnectionStartTimeRelative
=
false
;
if
(
timings
.
STATUS_TLS_STARTING
&
&
timings
.
STATUS_TLS_ENDING
)
{
if
(
timings
.
STATUS_CONNECTING_TO
)
{
secureConnectionStartTime
=
timings
.
STATUS_TLS_STARTING
.
first
-
timings
.
STATUS_CONNECTING_TO
.
first
;
}
if
(
secureConnectionStartTime
<
0
)
{
secureConnectionStartTime
=
0
;
}
secureConnectionStartTimeRelative
=
true
;
}
return
{
secureConnectionStartTime
secureConnectionStartTimeRelative
}
;
}
_getStartSendingTimeInfo
(
timings
connectStartTimeTc
)
{
let
startSendingTime
=
0
;
let
startSendingTimeRelative
=
false
;
if
(
timings
.
STATUS_SENDING_TO
)
{
if
(
timings
.
STATUS_CONNECTING_TO
)
{
startSendingTime
=
timings
.
STATUS_SENDING_TO
.
first
-
timings
.
STATUS_CONNECTING_TO
.
first
;
startSendingTimeRelative
=
true
;
}
else
if
(
connectStartTimeTc
!
=
0
)
{
startSendingTime
=
timings
.
STATUS_SENDING_TO
.
first
-
connectStartTimeTc
;
startSendingTimeRelative
=
true
;
}
if
(
startSendingTime
<
0
)
{
startSendingTime
=
0
;
}
}
return
{
startSendingTime
startSendingTimeRelative
}
;
}
_setupHarTimings
(
httpActivity
fromCache
)
{
if
(
fromCache
)
{
return
{
total
:
0
timings
:
{
blocked
:
0
dns
:
0
ssl
:
0
connect
:
0
send
:
0
wait
:
0
receive
:
0
}
offsets
:
{
blocked
:
0
dns
:
0
ssl
:
0
connect
:
0
send
:
0
wait
:
0
receive
:
0
}
}
;
}
const
timings
=
httpActivity
.
timings
;
const
harTimings
=
{
}
;
harTimings
.
blocked
=
this
.
_getBlockedTiming
(
timings
)
;
harTimings
.
dns
=
this
.
_getDnsTiming
(
timings
)
;
harTimings
.
connect
=
this
.
_getConnectTiming
(
timings
)
;
harTimings
.
ssl
=
this
.
_getSslTiming
(
timings
)
;
let
{
secureConnectionStartTime
secureConnectionStartTimeRelative
}
=
this
.
_getSecureConnectionStartTimeInfo
(
timings
)
;
const
timedChannel
=
httpActivity
.
channel
.
QueryInterface
(
Ci
.
nsITimedChannel
)
;
const
{
tcpConnectEndTimeTc
connectStartTimeTc
connectEndTimeTc
secureConnectionStartTimeTc
domainLookupEndTimeTc
domainLookupStartTimeTc
}
=
this
.
_getDataFromTimedChannel
(
timedChannel
)
;
if
(
harTimings
.
connect
<
=
0
&
&
timedChannel
&
&
tcpConnectEndTimeTc
!
=
0
&
&
connectStartTimeTc
!
=
0
)
{
harTimings
.
connect
=
tcpConnectEndTimeTc
-
connectStartTimeTc
;
if
(
secureConnectionStartTimeTc
!
=
0
)
{
harTimings
.
ssl
=
connectEndTimeTc
-
secureConnectionStartTimeTc
;
secureConnectionStartTime
=
secureConnectionStartTimeTc
-
connectStartTimeTc
;
secureConnectionStartTimeRelative
=
true
;
}
else
{
harTimings
.
ssl
=
-
1
;
}
}
else
if
(
timedChannel
&
&
timings
.
STATUS_TLS_STARTING
&
&
secureConnectionStartTimeTc
!
=
0
)
{
if
(
secureConnectionStartTimeTc
>
timings
.
STATUS_TLS_STARTING
.
first
)
{
harTimings
.
ssl
=
connectEndTimeTc
-
secureConnectionStartTimeTc
;
secureConnectionStartTimeRelative
=
false
;
}
}
if
(
harTimings
.
dns
<
=
0
&
&
timedChannel
&
&
domainLookupEndTimeTc
!
=
0
&
&
domainLookupStartTimeTc
!
=
0
)
{
harTimings
.
dns
=
domainLookupEndTimeTc
-
domainLookupStartTimeTc
;
}
harTimings
.
send
=
this
.
_getSendTiming
(
timings
)
;
harTimings
.
wait
=
this
.
_getWaitTiming
(
timings
)
;
harTimings
.
receive
=
this
.
_getReceiveTiming
(
timings
)
;
let
{
startSendingTime
startSendingTimeRelative
}
=
this
.
_getStartSendingTimeInfo
(
timings
connectStartTimeTc
)
;
if
(
secureConnectionStartTimeRelative
)
{
const
time
=
Math
.
max
(
Math
.
round
(
secureConnectionStartTime
/
1000
)
-
1
)
;
secureConnectionStartTime
=
time
;
}
if
(
startSendingTimeRelative
)
{
const
time
=
Math
.
max
(
Math
.
round
(
startSendingTime
/
1000
)
-
1
)
;
startSendingTime
=
time
;
}
const
ot
=
this
.
_calculateOffsetAndTotalTime
(
harTimings
secureConnectionStartTime
startSendingTimeRelative
secureConnectionStartTimeRelative
startSendingTime
)
;
return
{
total
:
ot
.
total
timings
:
harTimings
offsets
:
ot
.
offsets
}
;
}
_extractServerTimings
(
channel
)
{
if
(
!
channel
|
|
!
channel
.
serverTiming
)
{
return
null
;
}
const
serverTimings
=
new
Array
(
channel
.
serverTiming
.
length
)
;
for
(
let
i
=
0
;
i
<
channel
.
serverTiming
.
length
;
+
+
i
)
{
const
{
name
duration
description
}
=
channel
.
serverTiming
.
queryElementAt
(
i
Ci
.
nsIServerTiming
)
;
serverTimings
[
i
]
=
{
name
duration
description
}
;
}
return
serverTimings
;
}
_convertTimeToMs
(
timing
)
{
return
Math
.
max
(
Math
.
round
(
timing
/
1000
)
-
1
)
;
}
_calculateOffsetAndTotalTime
(
harTimings
secureConnectionStartTime
startSendingTimeRelative
secureConnectionStartTimeRelative
startSendingTime
)
{
let
totalTime
=
0
;
for
(
const
timing
in
harTimings
)
{
const
time
=
this
.
_convertTimeToMs
(
harTimings
[
timing
]
)
;
harTimings
[
timing
]
=
time
;
if
(
time
>
-
1
&
&
timing
!
=
"
connect
"
&
&
timing
!
=
"
ssl
"
)
{
totalTime
+
=
time
;
}
}
if
(
startSendingTimeRelative
)
{
totalTime
+
=
startSendingTime
;
}
else
if
(
secureConnectionStartTimeRelative
)
{
totalTime
+
=
secureConnectionStartTime
;
totalTime
+
=
harTimings
.
ssl
;
}
const
offsets
=
{
}
;
offsets
.
blocked
=
0
;
offsets
.
dns
=
harTimings
.
blocked
;
offsets
.
connect
=
offsets
.
dns
+
harTimings
.
dns
;
if
(
secureConnectionStartTimeRelative
)
{
offsets
.
ssl
=
offsets
.
connect
+
secureConnectionStartTime
;
}
else
{
offsets
.
ssl
=
offsets
.
connect
+
harTimings
.
connect
;
}
if
(
startSendingTimeRelative
)
{
offsets
.
send
=
offsets
.
connect
+
startSendingTime
;
if
(
!
secureConnectionStartTimeRelative
)
{
offsets
.
ssl
=
offsets
.
send
-
harTimings
.
ssl
;
}
}
else
{
offsets
.
send
=
offsets
.
ssl
+
harTimings
.
ssl
;
}
offsets
.
wait
=
offsets
.
send
+
harTimings
.
send
;
offsets
.
receive
=
offsets
.
wait
+
harTimings
.
wait
;
return
{
total
:
totalTime
offsets
}
;
}
_sendRequestBody
(
httpActivity
)
{
if
(
httpActivity
.
sentBody
!
=
=
null
)
{
const
limit
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
netmonitor
.
requestBodyLimit
"
)
;
const
size
=
httpActivity
.
sentBody
.
length
;
if
(
size
>
limit
&
&
limit
>
0
)
{
httpActivity
.
sentBody
=
httpActivity
.
sentBody
.
substr
(
0
limit
)
;
}
httpActivity
.
owner
.
addRequestPostData
(
{
text
:
httpActivity
.
sentBody
size
}
)
;
httpActivity
.
sentBody
=
null
;
}
}
clear
(
)
{
this
.
openRequests
.
clear
(
)
;
this
.
openResponses
.
clear
(
)
;
}
destroy
(
)
{
if
(
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
)
{
gActivityDistributor
.
removeObserver
(
this
)
;
Services
.
obs
.
removeObserver
(
this
.
_httpResponseExaminer
"
http
-
on
-
examine
-
response
"
)
;
Services
.
obs
.
removeObserver
(
this
.
_httpResponseExaminer
"
http
-
on
-
examine
-
cached
-
response
"
)
;
Services
.
obs
.
removeObserver
(
this
.
_httpModifyExaminer
"
http
-
on
-
modify
-
request
"
)
;
Services
.
obs
.
removeObserver
(
this
.
_httpStopRequest
"
http
-
on
-
stop
-
request
"
)
;
}
else
{
Services
.
obs
.
removeObserver
(
this
.
_httpFailedOpening
"
http
-
on
-
failed
-
opening
-
request
"
)
;
}
Services
.
obs
.
removeObserver
(
this
.
_serviceWorkerRequest
"
service
-
worker
-
synthesized
-
response
"
)
;
this
.
owner
=
null
;
this
.
filters
=
null
;
this
.
_throttler
=
null
;
this
.
_decodedCertificateCache
.
clear
(
)
;
this
.
clear
(
)
;
}
}
;
function
gSequenceId
(
)
{
return
gSequenceId
.
n
+
+
;
}
gSequenceId
.
n
=
1
;
