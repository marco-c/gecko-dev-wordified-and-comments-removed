"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
networkEventSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
network
-
event
.
js
"
)
;
const
{
TYPES
:
{
NETWORK_EVENT
}
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
index
.
js
"
)
;
const
{
LongStringActor
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
string
.
js
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
NetworkUtils
:
"
resource
:
/
/
devtools
/
shared
/
network
-
observer
/
NetworkUtils
.
sys
.
mjs
"
}
{
global
:
"
contextual
"
}
)
;
const
CONTENT_TYPE_REGEXP
=
/
^
content
-
type
/
i
;
const
REDIRECT_STATES
=
[
301
302
303
307
]
;
function
isDataChannel
(
channel
)
{
return
channel
instanceof
Ci
.
nsIDataChannel
;
}
function
isFileChannel
(
channel
)
{
return
channel
instanceof
Ci
.
nsIFileChannel
;
}
class
NetworkEventActor
extends
Actor
{
constructor
(
conn
sessionContext
{
onNetworkEventUpdate
onNetworkEventDestroy
}
networkEventOptions
channel
)
{
super
(
conn
networkEventSpec
)
;
this
.
_sessionContext
=
sessionContext
;
this
.
_onNetworkEventUpdate
=
onNetworkEventUpdate
;
this
.
_onNetworkEventDestroy
=
onNetworkEventDestroy
;
this
.
_channelId
=
channel
.
channelId
;
this
.
_timings
=
{
}
;
this
.
_serverTimings
=
[
]
;
this
.
_discardRequestBody
=
!
!
networkEventOptions
.
discardRequestBody
;
this
.
_discardResponseBody
=
!
!
networkEventOptions
.
discardResponseBody
;
this
.
_response
=
{
headers
:
[
]
cookies
:
[
]
content
:
{
}
}
;
this
.
_earlyHintsResponse
=
{
headers
:
[
]
rawHeaders
:
"
"
}
;
if
(
isDataChannel
(
channel
)
|
|
isFileChannel
(
channel
)
)
{
this
.
_innerWindowId
=
lazy
.
NetworkUtils
.
getChannelInnerWindowId
(
channel
)
;
this
.
_isNavigationRequest
=
false
;
this
.
_request
=
{
cookies
:
[
]
headers
:
[
]
postData
:
{
}
rawHeaders
:
"
"
}
;
this
.
_resource
=
this
.
_createResource
(
networkEventOptions
channel
)
;
return
;
}
this
.
_innerWindowId
=
lazy
.
NetworkUtils
.
getChannelInnerWindowId
(
channel
)
;
this
.
_isNavigationRequest
=
lazy
.
NetworkUtils
.
isNavigationRequest
(
channel
)
;
const
{
cookies
headers
}
=
lazy
.
NetworkUtils
.
fetchRequestHeadersAndCookies
(
channel
)
;
this
.
_request
=
{
cookies
headers
postData
:
{
}
}
;
this
.
_resource
=
this
.
_createResource
(
networkEventOptions
channel
)
;
}
asResource
(
)
{
return
{
actor
:
this
.
actorID
.
.
.
this
.
_resource
}
;
}
_createResource
(
networkEventOptions
channel
)
{
let
wsChannel
;
let
method
;
if
(
isDataChannel
(
channel
)
|
|
isFileChannel
(
channel
)
)
{
channel
.
QueryInterface
(
Ci
.
nsIChannel
)
;
wsChannel
=
null
;
method
=
"
GET
"
;
}
else
{
channel
=
channel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
wsChannel
=
lazy
.
NetworkUtils
.
getWebSocketChannel
(
channel
)
;
method
=
channel
.
requestMethod
;
}
const
url
=
wsChannel
?
wsChannel
.
URI
.
spec
:
channel
.
URI
.
spec
;
let
browsingContextID
=
lazy
.
NetworkUtils
.
getChannelBrowsingContextID
(
channel
)
;
if
(
!
browsingContextID
&
&
this
.
_sessionContext
.
type
!
=
"
all
"
)
{
throw
new
Error
(
Got
a
request
{
url
}
without
a
browsingContextID
set
)
;
}
if
(
this
.
_sessionContext
.
type
=
=
"
all
"
|
|
this
.
_sessionContext
.
type
=
=
"
webextension
"
)
{
browsingContextID
=
-
1
;
}
const
cause
=
lazy
.
NetworkUtils
.
getCauseDetails
(
channel
)
;
const
isXHR
=
cause
.
type
=
=
"
xhr
"
|
|
cause
.
type
=
=
"
fetch
"
;
const
stacktraceResourceId
=
cause
.
type
=
=
"
websocket
"
?
wsChannel
.
serial
:
channel
.
channelId
;
const
timeStamp
=
networkEventOptions
.
timestamp
?
networkEventOptions
.
timestamp
/
1000
:
Date
.
now
(
)
;
let
blockedReason
=
networkEventOptions
.
blockedReason
;
if
(
blockedReason
=
=
=
0
|
|
blockedReason
=
=
=
false
|
|
blockedReason
=
=
=
null
|
|
blockedReason
=
=
=
"
"
)
{
blockedReason
=
"
unknown
"
;
}
const
resource
=
{
resourceId
:
this
.
_channelId
resourceType
:
NETWORK_EVENT
blockedReason
blockingExtension
:
networkEventOptions
.
blockingExtension
browsingContextID
cause
chromeContext
:
lazy
.
NetworkUtils
.
isChannelFromSystemPrincipal
(
channel
)
innerWindowId
:
this
.
_innerWindowId
isNavigationRequest
:
this
.
_isNavigationRequest
isThirdPartyTrackingResource
:
lazy
.
NetworkUtils
.
isThirdPartyTrackingResource
(
channel
)
isXHR
method
priority
:
lazy
.
NetworkUtils
.
getChannelPriority
(
channel
)
private
:
lazy
.
NetworkUtils
.
isChannelPrivate
(
channel
)
referrerPolicy
:
lazy
.
NetworkUtils
.
getReferrerPolicy
(
channel
)
stacktraceResourceId
startedDateTime
:
new
Date
(
timeStamp
)
.
toISOString
(
)
securityFlags
:
channel
.
loadInfo
.
securityFlags
timeStamp
timings
:
{
}
url
}
;
return
resource
;
}
destroy
(
conn
)
{
if
(
!
this
.
_channelId
)
{
return
;
}
if
(
this
.
_onNetworkEventDestroy
)
{
this
.
_onNetworkEventDestroy
(
this
.
_channelId
)
;
}
this
.
_channelId
=
null
;
super
.
destroy
(
conn
)
;
}
release
(
)
{
}
getInnerWindowId
(
)
{
return
this
.
_innerWindowId
;
}
isNavigationRequest
(
)
{
return
this
.
_isNavigationRequest
;
}
getRequestHeaders
(
)
{
let
rawHeaders
;
let
headersSize
=
0
;
if
(
this
.
_request
.
rawHeaders
)
{
headersSize
=
this
.
_request
.
rawHeaders
.
length
;
rawHeaders
=
this
.
_createLongStringActor
(
this
.
_request
.
rawHeaders
)
;
}
return
{
headers
:
this
.
_request
.
headers
.
map
(
header
=
>
(
{
name
:
header
.
name
value
:
this
.
_createLongStringActor
(
header
.
value
)
}
)
)
headersSize
rawHeaders
}
;
}
getRequestCookies
(
)
{
return
{
cookies
:
this
.
_request
.
cookies
.
map
(
cookie
=
>
(
{
name
:
cookie
.
name
value
:
this
.
_createLongStringActor
(
cookie
.
value
)
}
)
)
}
;
}
getRequestPostData
(
)
{
let
postDataText
;
if
(
this
.
_request
.
postData
.
text
)
{
postDataText
=
this
.
_createLongStringActor
(
this
.
_request
.
postData
.
text
)
;
}
return
{
postData
:
{
size
:
this
.
_request
.
postData
.
size
text
:
postDataText
}
postDataDiscarded
:
this
.
_discardRequestBody
}
;
}
getSecurityInfo
(
)
{
return
{
securityInfo
:
this
.
_securityInfo
}
;
}
getEarlyHintsResponseHeaders
(
)
{
const
{
rawHeaders
headers
}
=
this
.
_earlyHintsResponse
;
return
{
headers
:
headers
.
map
(
header
=
>
(
{
name
:
header
.
name
value
:
this
.
_createLongStringActor
(
header
.
value
)
}
)
)
headersSize
:
rawHeaders
.
length
rawHeaders
:
this
.
_createLongStringActor
(
rawHeaders
)
}
;
}
getResponseHeaders
(
)
{
let
rawHeaders
;
let
headersSize
=
0
;
if
(
this
.
_response
.
rawHeaders
)
{
headersSize
=
this
.
_response
.
rawHeaders
.
length
;
rawHeaders
=
this
.
_createLongStringActor
(
this
.
_response
.
rawHeaders
)
;
}
return
{
headers
:
this
.
_response
.
headers
.
map
(
header
=
>
(
{
name
:
header
.
name
value
:
this
.
_createLongStringActor
(
header
.
value
)
}
)
)
headersSize
rawHeaders
}
;
}
getResponseCache
(
)
{
return
{
cache
:
this
.
_response
.
responseCache
}
;
}
getResponseCookies
(
)
{
const
cookieOptionalProperties
=
[
"
domain
"
"
expires
"
"
httpOnly
"
"
path
"
"
samesite
"
"
secure
"
]
;
return
{
cookies
:
this
.
_response
.
cookies
.
map
(
cookie
=
>
{
const
cookieResponse
=
{
name
:
cookie
.
name
value
:
this
.
_createLongStringActor
(
cookie
.
value
)
}
;
for
(
const
prop
of
cookieOptionalProperties
)
{
if
(
prop
in
cookie
)
{
cookieResponse
[
prop
]
=
cookie
[
prop
]
;
}
}
return
cookieResponse
;
}
)
}
;
}
getResponseContent
(
)
{
const
content
=
{
.
.
.
this
.
_response
.
content
}
;
if
(
this
.
_response
.
contentLongStringActor
)
{
this
.
unmanage
(
this
.
_response
.
contentLongStringActor
)
;
}
this
.
_response
.
contentLongStringActor
=
new
LongStringActor
(
this
.
conn
content
.
text
)
;
this
.
manage
(
this
.
_response
.
contentLongStringActor
)
;
content
.
text
=
this
.
_response
.
contentLongStringActor
.
form
(
)
;
return
{
content
contentDiscarded
:
this
.
_discardResponseBody
}
;
}
getEventTimings
(
)
{
return
{
timings
:
this
.
_timings
totalTime
:
this
.
_totalTime
offsets
:
this
.
_offsets
serverTimings
:
this
.
_serverTimings
serviceWorkerTimings
:
this
.
_serviceWorkerTimings
}
;
}
addCacheDetails
(
{
fromCache
fromServiceWorker
}
)
{
this
.
_resource
.
fromCache
=
fromCache
;
this
.
_resource
.
fromServiceWorker
=
fromServiceWorker
;
this
.
_onEventUpdate
(
lazy
.
NetworkUtils
.
NETWORK_EVENT_TYPES
.
CACHE_DETAILS
{
fromCache
fromServiceWorker
}
)
;
}
addRawHeaders
(
{
channel
rawHeaders
}
)
{
this
.
_request
.
rawHeaders
=
rawHeaders
;
const
{
headers
}
=
lazy
.
NetworkUtils
.
fetchRequestHeadersAndCookies
(
channel
)
;
this
.
_request
.
headers
=
headers
;
}
addRequestPostData
(
postData
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_request
.
postData
=
postData
;
this
.
_onEventUpdate
(
lazy
.
NetworkUtils
.
NETWORK_EVENT_TYPES
.
REQUEST_POSTDATA
{
}
)
;
}
addResponseStart
(
{
channel
fromCache
rawHeaders
=
"
"
proxyResponseRawHeaders
earlyHintsResponseRawHeaders
}
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
const
{
responseStatus
responseStatusText
}
=
channel
;
fromCache
=
fromCache
|
|
lazy
.
NetworkUtils
.
isFromCache
(
channel
)
;
const
isDataOrFile
=
isDataChannel
(
channel
)
|
|
isFileChannel
(
channel
)
;
let
responseHeaders
=
[
]
;
let
responseCookies
=
[
]
;
if
(
!
this
.
_blockedReason
&
&
!
isDataOrFile
)
{
const
{
cookies
headers
}
=
lazy
.
NetworkUtils
.
fetchResponseHeadersAndCookies
(
channel
)
;
responseCookies
=
cookies
;
responseHeaders
=
headers
;
}
this
.
_response
.
rawHeaders
=
rawHeaders
;
this
.
_response
.
headers
=
responseHeaders
;
this
.
_response
.
cookies
=
responseCookies
;
this
.
_response
.
headersSize
=
rawHeaders
?
rawHeaders
.
length
:
0
;
if
(
earlyHintsResponseRawHeaders
)
{
this
.
_earlyHintsResponse
.
headers
=
lazy
.
NetworkUtils
.
parseEarlyHintsResponseHeaders
(
earlyHintsResponseRawHeaders
)
;
this
.
_earlyHintsResponse
.
rawHeaders
=
earlyHintsResponseRawHeaders
;
}
if
(
REDIRECT_STATES
.
includes
(
responseStatus
)
)
{
this
.
_discardResponseBody
=
true
;
}
const
contentTypeHeader
=
responseHeaders
.
find
(
header
=
>
CONTENT_TYPE_REGEXP
.
test
(
header
.
name
)
)
;
let
mimeType
=
"
"
;
if
(
contentTypeHeader
)
{
mimeType
=
contentTypeHeader
.
value
;
}
let
waitingTime
=
null
;
if
(
!
isDataOrFile
)
{
const
timedChannel
=
channel
.
QueryInterface
(
Ci
.
nsITimedChannel
)
;
waitingTime
=
Math
.
round
(
(
timedChannel
.
responseStartTime
-
timedChannel
.
requestStartTime
)
/
1000
)
;
}
let
proxyInfo
=
[
]
;
if
(
proxyResponseRawHeaders
)
{
proxyInfo
=
proxyResponseRawHeaders
.
split
(
"
\
r
\
n
"
)
[
0
]
.
split
(
"
"
)
;
}
this
.
_onEventUpdate
(
lazy
.
NetworkUtils
.
NETWORK_EVENT_TYPES
.
RESPONSE_START
{
httpVersion
:
isDataOrFile
?
null
:
lazy
.
NetworkUtils
.
getHttpVersion
(
channel
)
mimeType
remoteAddress
:
fromCache
?
"
"
:
channel
.
remoteAddress
remotePort
:
fromCache
?
"
"
:
channel
.
remotePort
status
:
isDataOrFile
?
"
200
"
:
responseStatus
+
"
"
statusText
:
isDataOrFile
?
"
0K
"
:
responseStatusText
earlyHintsStatus
:
earlyHintsResponseRawHeaders
?
"
103
"
:
"
"
waitingTime
isResolvedByTRR
:
channel
.
isResolvedByTRR
proxyHttpVersion
:
proxyInfo
[
0
]
proxyStatus
:
proxyInfo
[
1
]
proxyStatusText
:
proxyInfo
[
2
]
}
)
;
}
addSecurityInfo
(
info
isRacing
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_securityInfo
=
info
;
this
.
_onEventUpdate
(
lazy
.
NetworkUtils
.
NETWORK_EVENT_TYPES
.
SECURITY_INFO
{
state
:
info
.
state
isRacing
}
)
;
}
addResponseContentComplete
(
{
blockedReason
blockingExtension
}
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_onEventUpdate
(
lazy
.
NetworkUtils
.
NETWORK_EVENT_TYPES
.
RESPONSE_CONTENT_COMPLETE
{
blockedReason
blockingExtension
}
)
;
}
addResponseContent
(
content
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_response
.
content
=
content
;
this
.
_onEventUpdate
(
lazy
.
NetworkUtils
.
NETWORK_EVENT_TYPES
.
RESPONSE_CONTENT
{
mimeType
:
content
.
mimeType
contentSize
:
content
.
size
transferredSize
:
content
.
transferredSize
}
)
;
}
addResponseCache
(
content
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_response
.
responseCache
=
content
.
responseCache
;
this
.
_onEventUpdate
(
lazy
.
NetworkUtils
.
NETWORK_EVENT_TYPES
.
RESPONSE_CACHE
{
}
)
;
}
addEventTimings
(
total
timings
offsets
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_totalTime
=
total
;
this
.
_timings
=
timings
;
this
.
_offsets
=
offsets
;
this
.
_onEventUpdate
(
lazy
.
NetworkUtils
.
NETWORK_EVENT_TYPES
.
EVENT_TIMINGS
{
totalTime
:
total
}
)
;
}
addServerTimings
(
serverTimings
)
{
if
(
!
serverTimings
|
|
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_serverTimings
=
serverTimings
;
}
addServiceWorkerTimings
(
serviceWorkerTimings
)
{
if
(
!
serviceWorkerTimings
|
|
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_serviceWorkerTimings
=
serviceWorkerTimings
;
}
_createLongStringActor
(
string
)
{
if
(
string
?
.
actorID
)
{
return
string
;
}
const
longStringActor
=
new
LongStringActor
(
this
.
conn
string
)
;
this
.
manage
(
longStringActor
)
;
return
longStringActor
.
form
(
)
;
}
_onEventUpdate
(
updateType
data
)
{
if
(
this
.
_onNetworkEventUpdate
)
{
this
.
_onNetworkEventUpdate
(
{
resourceId
:
this
.
_channelId
updateType
.
.
.
data
}
)
;
}
}
}
exports
.
NetworkEventActor
=
NetworkEventActor
;
