"
use
strict
"
;
const
{
Ci
components
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
loader
.
lazyRequireGetter
(
this
"
ChannelEventSinkFactory
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
channel
-
event
-
sink
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkUtils
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
utils
/
network
-
utils
"
)
;
loader
.
lazyRequireGetter
(
this
"
WebConsoleUtils
"
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
true
)
;
function
StackTraceCollector
(
filters
netmonitors
)
{
this
.
filters
=
filters
;
this
.
stacktracesById
=
new
Map
(
)
;
this
.
netmonitors
=
netmonitors
;
}
StackTraceCollector
.
prototype
=
{
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
http
-
on
-
opening
-
request
"
)
;
Services
.
obs
.
addObserver
(
this
"
document
-
on
-
opening
-
request
"
)
;
Services
.
obs
.
addObserver
(
this
"
network
-
monitor
-
alternate
-
stack
"
)
;
ChannelEventSinkFactory
.
getService
(
)
.
registerCollector
(
this
)
;
this
.
onGetStack
=
this
.
onGetStack
.
bind
(
this
)
;
for
(
const
{
messageManager
}
of
this
.
netmonitors
)
{
messageManager
.
addMessageListener
(
"
debug
:
request
-
stack
:
request
"
this
.
onGetStack
)
;
}
}
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
"
http
-
on
-
opening
-
request
"
)
;
Services
.
obs
.
removeObserver
(
this
"
document
-
on
-
opening
-
request
"
)
;
Services
.
obs
.
removeObserver
(
this
"
network
-
monitor
-
alternate
-
stack
"
)
;
ChannelEventSinkFactory
.
getService
(
)
.
unregisterCollector
(
this
)
;
for
(
const
{
messageManager
}
of
this
.
netmonitors
)
{
messageManager
.
removeMessageListener
(
"
debug
:
request
-
stack
:
request
"
this
.
onGetStack
)
;
}
}
_saveStackTrace
(
id
stacktrace
)
{
if
(
this
.
stacktracesById
.
has
(
id
)
)
{
return
;
}
for
(
const
{
messageManager
}
of
this
.
netmonitors
)
{
messageManager
.
sendAsyncMessage
(
"
debug
:
request
-
stack
-
available
"
{
channelId
:
id
stacktrace
:
stacktrace
&
&
!
!
stacktrace
.
length
lastFrame
:
stacktrace
&
&
stacktrace
.
length
?
stacktrace
[
0
]
:
undefined
}
)
;
}
this
.
stacktracesById
.
set
(
id
stacktrace
)
;
}
observe
(
subject
topic
data
)
{
let
channel
id
;
try
{
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
id
=
channel
.
channelId
;
}
catch
(
e1
)
{
try
{
channel
=
subject
.
QueryInterface
(
Ci
.
nsIIdentChannel
)
;
id
=
channel
.
channelId
;
}
catch
(
e2
)
{
try
{
channel
=
subject
.
QueryInterface
(
Ci
.
nsIWebSocketChannel
)
;
}
catch
(
e3
)
{
return
;
}
id
=
channel
.
URI
.
spec
;
}
}
if
(
!
NetworkUtils
.
matchRequest
(
channel
this
.
filters
)
)
{
return
;
}
const
stacktrace
=
[
]
;
switch
(
topic
)
{
case
"
http
-
on
-
opening
-
request
"
:
case
"
document
-
on
-
opening
-
request
"
:
{
let
frame
=
components
.
stack
;
if
(
frame
?
.
caller
)
{
frame
=
frame
.
caller
;
while
(
frame
)
{
stacktrace
.
push
(
{
filename
:
frame
.
filename
lineNumber
:
frame
.
lineNumber
columnNumber
:
frame
.
columnNumber
functionName
:
frame
.
name
asyncCause
:
frame
.
asyncCause
}
)
;
frame
=
frame
.
caller
|
|
frame
.
asyncCaller
;
}
}
break
;
}
case
"
network
-
monitor
-
alternate
-
stack
"
:
{
let
frame
=
JSON
.
parse
(
data
)
;
while
(
frame
)
{
stacktrace
.
push
(
{
filename
:
frame
.
source
lineNumber
:
frame
.
line
columnNumber
:
frame
.
column
functionName
:
frame
.
functionDisplayName
asyncCause
:
frame
.
asyncCause
}
)
;
frame
=
frame
.
parent
|
|
frame
.
asyncParent
;
}
break
;
}
default
:
throw
new
Error
(
"
Unexpected
observe
(
)
topic
"
)
;
}
this
.
_saveStackTrace
(
id
stacktrace
)
;
}
onChannelRedirect
(
oldChannel
newChannel
flags
)
{
try
{
oldChannel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
newChannel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
}
catch
(
ex
)
{
return
;
}
const
oldId
=
oldChannel
.
channelId
;
const
stacktrace
=
this
.
stacktracesById
.
get
(
oldId
)
;
if
(
stacktrace
)
{
this
.
_saveStackTrace
(
newChannel
.
channelId
stacktrace
)
;
}
}
getStackTrace
(
channelId
)
{
const
trace
=
this
.
stacktracesById
.
get
(
channelId
)
;
this
.
stacktracesById
.
delete
(
channelId
)
;
return
WebConsoleUtils
.
removeFramesAboveDebuggerEval
(
trace
)
;
}
onGetStack
(
msg
)
{
const
messageManager
=
msg
.
target
;
const
channelId
=
msg
.
data
;
const
stack
=
this
.
getStackTrace
(
channelId
)
;
messageManager
.
sendAsyncMessage
(
"
debug
:
request
-
stack
:
response
"
{
channelId
stack
}
)
;
}
}
;
exports
.
StackTraceCollector
=
StackTraceCollector
;
