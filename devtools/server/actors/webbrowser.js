"
use
strict
"
;
var
{
Ci
}
=
require
(
"
chrome
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
{
DevToolsServer
}
=
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
var
{
ActorRegistry
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
actor
-
registry
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
RootActor
"
"
devtools
/
server
/
actors
/
root
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TabDescriptorActor
"
"
devtools
/
server
/
actors
/
descriptors
/
tab
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebExtensionDescriptorActor
"
"
devtools
/
server
/
actors
/
descriptors
/
webextension
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WorkerDescriptorActorList
"
"
devtools
/
server
/
actors
/
worker
/
worker
-
descriptor
-
actor
-
list
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ServiceWorkerRegistrationActorList
"
"
devtools
/
server
/
actors
/
worker
/
service
-
worker
-
registration
-
list
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ProcessActorList
"
"
devtools
/
server
/
actors
/
process
"
true
)
;
loader
.
lazyImporter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
function
appShellDOMWindowType
(
window
)
{
return
window
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
}
function
sendShutdownEvent
(
)
{
for
(
const
win
of
Services
.
wm
.
getEnumerator
(
DevToolsServer
.
chromeWindowType
)
)
{
const
evt
=
win
.
document
.
createEvent
(
"
Event
"
)
;
evt
.
initEvent
(
"
Debugger
:
Shutdown
"
true
false
)
;
win
.
document
.
documentElement
.
dispatchEvent
(
evt
)
;
}
}
exports
.
sendShutdownEvent
=
sendShutdownEvent
;
exports
.
createRootActor
=
function
createRootActor
(
connection
)
{
return
new
RootActor
(
connection
{
tabList
:
new
BrowserTabList
(
connection
)
addonList
:
new
BrowserAddonList
(
connection
)
workerList
:
new
WorkerDescriptorActorList
(
connection
{
}
)
serviceWorkerRegistrationList
:
new
ServiceWorkerRegistrationActorList
(
connection
)
processList
:
new
ProcessActorList
(
)
globalActorFactories
:
ActorRegistry
.
globalActorFactories
onShutdown
:
sendShutdownEvent
}
)
;
}
;
function
BrowserTabList
(
connection
)
{
this
.
_connection
=
connection
;
this
.
_actorByBrowser
=
new
Map
(
)
;
this
.
_onListChanged
=
null
;
this
.
_mustNotify
=
false
;
this
.
_testing
=
false
;
this
.
_onPageTitleChangedEvent
=
this
.
_onPageTitleChangedEvent
.
bind
(
this
)
;
}
BrowserTabList
.
prototype
.
constructor
=
BrowserTabList
;
BrowserTabList
.
prototype
.
destroy
=
function
(
)
{
this
.
_actorByBrowser
.
clear
(
)
;
this
.
onListChanged
=
null
;
}
;
BrowserTabList
.
prototype
.
_getSelectedBrowser
=
function
(
window
)
{
return
window
.
gBrowser
?
window
.
gBrowser
.
selectedBrowser
:
null
;
}
;
BrowserTabList
.
prototype
.
_getBrowsers
=
function
*
(
)
{
for
(
const
win
of
Services
.
wm
.
getEnumerator
(
DevToolsServer
.
chromeWindowType
)
)
{
for
(
const
browser
of
this
.
_getChildren
(
win
)
)
{
yield
browser
;
}
}
}
;
BrowserTabList
.
prototype
.
_getChildren
=
function
(
window
)
{
if
(
!
window
.
gBrowser
)
{
return
[
]
;
}
const
{
gBrowser
}
=
window
;
if
(
!
gBrowser
.
browsers
)
{
return
[
]
;
}
return
gBrowser
.
browsers
.
filter
(
browser
=
>
{
const
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
return
!
tab
.
closing
;
}
)
;
}
;
BrowserTabList
.
prototype
.
getList
=
async
function
(
)
{
const
initialMapSize
=
this
.
_actorByBrowser
.
size
;
this
.
_foundCount
=
0
;
const
actors
=
[
]
;
for
(
const
browser
of
this
.
_getBrowsers
(
)
)
{
try
{
const
actor
=
await
this
.
_getActorForBrowser
(
browser
)
;
actors
.
push
(
actor
)
;
}
catch
(
e
)
{
if
(
e
.
error
=
=
=
"
tabDestroyed
"
)
{
continue
;
}
throw
e
;
}
}
if
(
this
.
_testing
&
&
initialMapSize
!
=
=
this
.
_foundCount
)
{
throw
new
Error
(
"
_actorByBrowser
map
contained
actors
for
dead
tabs
"
)
;
}
this
.
_mustNotify
=
true
;
this
.
_checkListening
(
)
;
return
actors
;
}
;
BrowserTabList
.
prototype
.
_getActorForBrowser
=
async
function
(
browser
)
{
let
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
this
.
_foundCount
+
+
;
return
actor
;
}
actor
=
new
TabDescriptorActor
(
this
.
_connection
browser
)
;
this
.
_actorByBrowser
.
set
(
browser
actor
)
;
this
.
_checkListening
(
)
;
return
actor
;
}
;
BrowserTabList
.
prototype
.
getTab
=
function
(
{
browserId
tabId
}
)
{
if
(
typeof
browserId
=
=
"
number
"
)
{
const
browsingContext
=
BrowsingContext
.
getCurrentTopByBrowserId
(
browserId
)
;
if
(
!
browsingContext
)
{
return
Promise
.
reject
(
{
error
:
"
noTab
"
message
:
Unable
to
find
tab
with
browserId
'
{
browserId
}
'
(
no
browsing
-
context
)
}
)
;
}
const
browser
=
browsingContext
.
embedderElement
;
if
(
!
browser
)
{
return
Promise
.
reject
(
{
error
:
"
noTab
"
message
:
Unable
to
find
tab
with
browserId
'
{
browserId
}
'
(
no
embedder
element
)
}
)
;
}
return
this
.
_getActorForBrowser
(
browser
)
;
}
if
(
typeof
tabId
=
=
"
number
"
)
{
for
(
const
browser
of
this
.
_getBrowsers
(
)
)
{
if
(
browser
.
frameLoader
?
.
remoteTab
&
&
browser
.
frameLoader
.
remoteTab
.
tabId
=
=
=
tabId
)
{
return
this
.
_getActorForBrowser
(
browser
)
;
}
}
return
Promise
.
reject
(
{
error
:
"
noTab
"
message
:
"
Unable
to
find
tab
with
tabId
'
"
+
tabId
+
"
'
"
}
)
;
}
const
topAppWindow
=
Services
.
wm
.
getMostRecentWindow
(
DevToolsServer
.
chromeWindowType
)
;
if
(
topAppWindow
)
{
const
selectedBrowser
=
this
.
_getSelectedBrowser
(
topAppWindow
)
;
return
this
.
_getActorForBrowser
(
selectedBrowser
)
;
}
return
Promise
.
reject
(
{
error
:
"
noTab
"
message
:
"
Unable
to
find
any
selected
browser
"
}
)
;
}
;
Object
.
defineProperty
(
BrowserTabList
.
prototype
"
onListChanged
"
{
enumerable
:
true
configurable
:
true
get
(
)
{
return
this
.
_onListChanged
;
}
set
(
v
)
{
if
(
v
!
=
=
null
&
&
typeof
v
!
=
=
"
function
"
)
{
throw
new
Error
(
"
onListChanged
property
may
only
be
set
to
'
null
'
or
a
function
"
)
;
}
this
.
_onListChanged
=
v
;
this
.
_checkListening
(
)
;
}
}
)
;
BrowserTabList
.
prototype
.
_notifyListChanged
=
function
(
)
{
if
(
!
this
.
_onListChanged
)
{
return
;
}
if
(
this
.
_mustNotify
)
{
this
.
_onListChanged
(
)
;
this
.
_mustNotify
=
false
;
}
}
;
BrowserTabList
.
prototype
.
_handleActorClose
=
function
(
actor
browser
)
{
if
(
this
.
_testing
)
{
if
(
this
.
_actorByBrowser
.
get
(
browser
)
!
=
=
actor
)
{
throw
new
Error
(
"
TabDescriptorActor
not
stored
in
map
under
given
browser
"
)
;
}
if
(
actor
.
browser
!
=
=
browser
)
{
throw
new
Error
(
"
actor
'
s
browser
and
map
key
don
'
t
match
"
)
;
}
}
this
.
_actorByBrowser
.
delete
(
browser
)
;
actor
.
destroy
(
)
;
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
}
;
BrowserTabList
.
prototype
.
_checkListening
=
function
(
)
{
this
.
_listenForEventsIf
(
this
.
_onListChanged
&
&
this
.
_mustNotify
"
_listeningForTabOpen
"
[
"
TabOpen
"
"
TabSelect
"
"
TabAttrModified
"
]
)
;
this
.
_listenForEventsIf
(
this
.
_actorByBrowser
.
size
>
0
"
_listeningForTabClose
"
[
"
TabClose
"
]
)
;
this
.
_listenToMediatorIf
(
(
this
.
_onListChanged
&
&
this
.
_mustNotify
)
|
|
this
.
_actorByBrowser
.
size
>
0
)
;
this
.
_listenForEventsIf
(
this
.
_onListChanged
&
&
this
.
_mustNotify
"
_listeningForTitleChange
"
[
"
pagetitlechanged
"
]
this
.
_onPageTitleChangedEvent
)
;
}
;
BrowserTabList
.
prototype
.
_listenForEventsIf
=
function
(
shouldListen
guard
eventNames
listener
=
this
)
{
if
(
!
shouldListen
!
=
=
!
this
[
guard
]
)
{
const
op
=
shouldListen
?
"
addEventListener
"
:
"
removeEventListener
"
;
for
(
const
win
of
Services
.
wm
.
getEnumerator
(
DevToolsServer
.
chromeWindowType
)
)
{
for
(
const
name
of
eventNames
)
{
win
[
op
]
(
name
listener
false
)
;
}
}
this
[
guard
]
=
shouldListen
;
}
}
;
BrowserTabList
.
prototype
.
_onPageTitleChangedEvent
=
function
(
event
)
{
switch
(
event
.
type
)
{
case
"
pagetitlechanged
"
:
{
const
browser
=
event
.
target
;
this
.
_onDOMTitleChanged
(
browser
)
;
break
;
}
}
}
;
BrowserTabList
.
prototype
.
_onDOMTitleChanged
=
DevToolsUtils
.
makeInfallible
(
function
(
browser
)
{
const
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
}
}
)
;
BrowserTabList
.
prototype
.
handleEvent
=
DevToolsUtils
.
makeInfallible
(
function
(
event
)
{
const
browser
=
event
.
target
.
linkedBrowser
|
|
event
.
target
;
switch
(
event
.
type
)
{
case
"
TabOpen
"
:
case
"
TabSelect
"
:
{
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
break
;
}
case
"
TabClose
"
:
{
const
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
this
.
_handleActorClose
(
actor
browser
)
;
}
break
;
}
case
"
TabAttrModified
"
:
{
if
(
browser
.
isRemoteBrowser
)
{
break
;
}
const
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
if
(
event
.
detail
.
changed
.
includes
(
"
label
"
)
)
{
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
}
}
break
;
}
}
}
"
BrowserTabList
.
prototype
.
handleEvent
"
)
;
BrowserTabList
.
prototype
.
_listenToMediatorIf
=
function
(
shouldListen
)
{
if
(
!
shouldListen
!
=
=
!
this
.
_listeningToMediator
)
{
const
op
=
shouldListen
?
"
addListener
"
:
"
removeListener
"
;
Services
.
wm
[
op
]
(
this
)
;
this
.
_listeningToMediator
=
shouldListen
;
}
}
;
BrowserTabList
.
prototype
.
onOpenWindow
=
DevToolsUtils
.
makeInfallible
(
function
(
window
)
{
const
handleLoad
=
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
window
.
removeEventListener
(
"
load
"
handleLoad
)
;
if
(
appShellDOMWindowType
(
window
)
!
=
=
DevToolsServer
.
chromeWindowType
)
{
return
;
}
if
(
this
.
_listeningForTabOpen
)
{
window
.
addEventListener
(
"
TabOpen
"
this
)
;
window
.
addEventListener
(
"
TabSelect
"
this
)
;
window
.
addEventListener
(
"
TabAttrModified
"
this
)
;
}
if
(
this
.
_listeningForTabClose
)
{
window
.
addEventListener
(
"
TabClose
"
this
)
;
}
if
(
this
.
_listeningForTitleChange
)
{
window
.
messageManager
.
addMessageListener
(
"
DOMTitleChanged
"
this
)
;
}
this
.
_notifyListChanged
(
)
;
}
)
;
window
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
window
.
addEventListener
(
"
load
"
handleLoad
)
;
}
"
BrowserTabList
.
prototype
.
onOpenWindow
"
)
;
BrowserTabList
.
prototype
.
onCloseWindow
=
DevToolsUtils
.
makeInfallible
(
function
(
window
)
{
if
(
window
instanceof
Ci
.
nsIAppWindow
)
{
window
=
window
.
docShell
.
domWindow
;
}
if
(
appShellDOMWindowType
(
window
)
!
=
=
DevToolsServer
.
chromeWindowType
)
{
return
;
}
Services
.
tm
.
dispatchToMainThread
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
for
(
const
[
browser
actor
]
of
this
.
_actorByBrowser
)
{
if
(
!
browser
.
ownerGlobal
)
{
this
.
_handleActorClose
(
actor
browser
)
;
}
}
}
"
BrowserTabList
.
prototype
.
onCloseWindow
'
s
delayed
body
"
)
)
;
}
"
BrowserTabList
.
prototype
.
onCloseWindow
"
)
;
exports
.
BrowserTabList
=
BrowserTabList
;
function
BrowserAddonList
(
connection
)
{
this
.
_connection
=
connection
;
this
.
_actorByAddonId
=
new
Map
(
)
;
this
.
_onListChanged
=
null
;
}
BrowserAddonList
.
prototype
.
getList
=
async
function
(
)
{
const
addons
=
await
AddonManager
.
getAllAddons
(
)
;
for
(
const
addon
of
addons
)
{
let
actor
=
this
.
_actorByAddonId
.
get
(
addon
.
id
)
;
if
(
!
actor
)
{
actor
=
new
WebExtensionDescriptorActor
(
this
.
_connection
addon
)
;
this
.
_actorByAddonId
.
set
(
addon
.
id
actor
)
;
}
}
return
Array
.
from
(
this
.
_actorByAddonId
(
[
_
actor
]
)
=
>
actor
)
;
}
;
Object
.
defineProperty
(
BrowserAddonList
.
prototype
"
onListChanged
"
{
enumerable
:
true
configurable
:
true
get
(
)
{
return
this
.
_onListChanged
;
}
set
(
v
)
{
if
(
v
!
=
=
null
&
&
typeof
v
!
=
"
function
"
)
{
throw
new
Error
(
"
onListChanged
property
may
only
be
set
to
'
null
'
or
a
function
"
)
;
}
this
.
_onListChanged
=
v
;
this
.
_adjustListener
(
)
;
}
}
)
;
BrowserAddonList
.
prototype
.
onDisabled
=
function
(
addon
)
{
this
.
_onAddonManagerUpdated
(
)
;
}
;
BrowserAddonList
.
prototype
.
onEnabled
=
function
(
addon
)
{
this
.
_onAddonManagerUpdated
(
)
;
}
;
BrowserAddonList
.
prototype
.
onInstalled
=
function
(
addon
)
{
this
.
_onAddonManagerUpdated
(
)
;
}
;
BrowserAddonList
.
prototype
.
onOperationCancelled
=
function
(
addon
)
{
this
.
_onAddonManagerUpdated
(
)
;
}
;
BrowserAddonList
.
prototype
.
onUninstalling
=
function
(
addon
)
{
this
.
_onAddonManagerUpdated
(
)
;
}
;
BrowserAddonList
.
prototype
.
onUninstalled
=
function
(
addon
)
{
this
.
_actorByAddonId
.
delete
(
addon
.
id
)
;
this
.
_onAddonManagerUpdated
(
)
;
}
;
BrowserAddonList
.
prototype
.
_onAddonManagerUpdated
=
function
(
addon
)
{
this
.
_notifyListChanged
(
)
;
this
.
_adjustListener
(
)
;
}
;
BrowserAddonList
.
prototype
.
_notifyListChanged
=
function
(
)
{
if
(
this
.
_onListChanged
)
{
this
.
_onListChanged
(
)
;
}
}
;
BrowserAddonList
.
prototype
.
_adjustListener
=
function
(
)
{
if
(
this
.
_onListChanged
)
{
AddonManager
.
addAddonListener
(
this
)
;
}
else
if
(
this
.
_actorByAddonId
.
size
=
=
=
0
)
{
AddonManager
.
removeAddonListener
(
this
)
;
}
}
;
exports
.
BrowserAddonList
=
BrowserAddonList
;
