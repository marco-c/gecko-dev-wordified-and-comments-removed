"
use
strict
"
;
var
{
Ci
}
=
require
(
"
chrome
"
)
;
var
Services
=
require
(
"
Services
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
var
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
RootActor
"
"
devtools
/
server
/
actors
/
root
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BrowserAddonActor
"
"
devtools
/
server
/
actors
/
addon
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebExtensionParentActor
"
"
devtools
/
server
/
actors
/
webextension
-
parent
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WorkerActorList
"
"
devtools
/
server
/
actors
/
worker
-
list
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ServiceWorkerRegistrationActorList
"
"
devtools
/
server
/
actors
/
worker
-
list
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ProcessActorList
"
"
devtools
/
server
/
actors
/
process
"
true
)
;
loader
.
lazyImporter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
function
*
allAppShellDOMWindows
(
windowType
)
{
let
e
=
Services
.
wm
.
getEnumerator
(
windowType
)
;
while
(
e
.
hasMoreElements
(
)
)
{
yield
e
.
getNext
(
)
;
}
}
exports
.
allAppShellDOMWindows
=
allAppShellDOMWindows
;
function
appShellDOMWindowType
(
window
)
{
return
window
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
}
function
sendShutdownEvent
(
)
{
for
(
let
win
of
allAppShellDOMWindows
(
DebuggerServer
.
chromeWindowType
)
)
{
let
evt
=
win
.
document
.
createEvent
(
"
Event
"
)
;
evt
.
initEvent
(
"
Debugger
:
Shutdown
"
true
false
)
;
win
.
document
.
documentElement
.
dispatchEvent
(
evt
)
;
}
}
exports
.
sendShutdownEvent
=
sendShutdownEvent
;
function
createRootActor
(
connection
)
{
return
new
RootActor
(
connection
{
tabList
:
new
BrowserTabList
(
connection
)
addonList
:
new
BrowserAddonList
(
connection
)
workerList
:
new
WorkerActorList
(
connection
{
}
)
serviceWorkerRegistrationList
:
new
ServiceWorkerRegistrationActorList
(
connection
)
processList
:
new
ProcessActorList
(
)
globalActorFactories
:
DebuggerServer
.
globalActorFactories
onShutdown
:
sendShutdownEvent
}
)
;
}
function
BrowserTabList
(
connection
)
{
this
.
_connection
=
connection
;
this
.
_actorByBrowser
=
new
Map
(
)
;
this
.
_onListChanged
=
null
;
this
.
_mustNotify
=
false
;
this
.
_testing
=
false
;
}
BrowserTabList
.
prototype
.
constructor
=
BrowserTabList
;
BrowserTabList
.
prototype
.
_getSelectedBrowser
=
function
(
window
)
{
return
window
.
gBrowser
?
window
.
gBrowser
.
selectedBrowser
:
null
;
}
;
BrowserTabList
.
prototype
.
_getBrowsers
=
function
*
(
)
{
for
(
let
win
of
allAppShellDOMWindows
(
DebuggerServer
.
chromeWindowType
)
)
{
for
(
let
browser
of
this
.
_getChildren
(
win
)
)
{
yield
browser
;
}
}
}
;
BrowserTabList
.
prototype
.
_getChildren
=
function
(
window
)
{
if
(
!
window
.
gBrowser
)
{
return
[
]
;
}
let
{
gBrowser
}
=
window
;
if
(
!
gBrowser
.
browsers
)
{
return
[
]
;
}
return
gBrowser
.
browsers
.
filter
(
browser
=
>
{
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
return
!
tab
.
closing
;
}
)
;
}
;
BrowserTabList
.
prototype
.
getList
=
function
(
browserActorOptions
)
{
let
topXULWindow
=
Services
.
wm
.
getMostRecentWindow
(
DebuggerServer
.
chromeWindowType
)
;
let
selectedBrowser
=
null
;
if
(
topXULWindow
)
{
selectedBrowser
=
this
.
_getSelectedBrowser
(
topXULWindow
)
;
}
let
initialMapSize
=
this
.
_actorByBrowser
.
size
;
this
.
_foundCount
=
0
;
let
actorPromises
=
[
]
;
for
(
let
browser
of
this
.
_getBrowsers
(
)
)
{
let
selected
=
browser
=
=
=
selectedBrowser
;
actorPromises
.
push
(
this
.
_getActorForBrowser
(
browser
browserActorOptions
)
.
then
(
actor
=
>
{
actor
.
selected
=
selected
;
return
actor
;
}
e
=
>
{
if
(
e
.
error
=
=
=
"
tabDestroyed
"
)
{
return
null
;
}
throw
e
;
}
)
)
;
}
if
(
this
.
_testing
&
&
initialMapSize
!
=
=
this
.
_foundCount
)
{
throw
new
Error
(
"
_actorByBrowser
map
contained
actors
for
dead
tabs
"
)
;
}
this
.
_mustNotify
=
true
;
this
.
_checkListening
(
)
;
return
Promise
.
all
(
actorPromises
)
.
then
(
values
=
>
{
return
values
.
filter
(
value
=
>
value
!
=
null
)
;
}
)
;
}
;
BrowserTabList
.
prototype
.
_getActorForBrowser
=
function
(
browser
browserActorOptions
)
{
let
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
this
.
_foundCount
+
+
;
return
actor
.
update
(
browserActorOptions
)
;
}
actor
=
new
BrowserTabActor
(
this
.
_connection
browser
browserActorOptions
)
;
this
.
_actorByBrowser
.
set
(
browser
actor
)
;
this
.
_checkListening
(
)
;
return
actor
.
connect
(
)
;
}
;
BrowserTabList
.
prototype
.
getTab
=
function
(
{
outerWindowID
tabId
}
)
{
if
(
typeof
outerWindowID
=
=
"
number
"
)
{
let
window
=
Services
.
wm
.
getOuterWindowWithId
(
outerWindowID
)
;
if
(
window
&
&
window
.
isChromeWindow
)
{
return
Promise
.
reject
(
{
error
:
"
forbidden
"
message
:
"
Window
with
outerWindowID
'
"
+
outerWindowID
+
"
'
is
chrome
"
}
)
;
}
if
(
window
)
{
let
iframe
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
containerElement
;
if
(
iframe
)
{
return
this
.
_getActorForBrowser
(
iframe
)
;
}
}
for
(
let
browser
of
this
.
_getBrowsers
(
)
)
{
if
(
browser
.
outerWindowID
=
=
outerWindowID
)
{
return
this
.
_getActorForBrowser
(
browser
)
;
}
}
return
Promise
.
reject
(
{
error
:
"
noTab
"
message
:
"
Unable
to
find
tab
with
outerWindowID
'
"
+
outerWindowID
+
"
'
"
}
)
;
}
else
if
(
typeof
tabId
=
=
"
number
"
)
{
for
(
let
browser
of
this
.
_getBrowsers
(
)
)
{
if
(
browser
.
frameLoader
&
&
browser
.
frameLoader
.
tabParent
&
&
browser
.
frameLoader
.
tabParent
.
tabId
=
=
=
tabId
)
{
return
this
.
_getActorForBrowser
(
browser
)
;
}
}
return
Promise
.
reject
(
{
error
:
"
noTab
"
message
:
"
Unable
to
find
tab
with
tabId
'
"
+
tabId
+
"
'
"
}
)
;
}
let
topXULWindow
=
Services
.
wm
.
getMostRecentWindow
(
DebuggerServer
.
chromeWindowType
)
;
if
(
topXULWindow
)
{
let
selectedBrowser
=
this
.
_getSelectedBrowser
(
topXULWindow
)
;
return
this
.
_getActorForBrowser
(
selectedBrowser
)
;
}
return
Promise
.
reject
(
{
error
:
"
noTab
"
message
:
"
Unable
to
find
any
selected
browser
"
}
)
;
}
;
Object
.
defineProperty
(
BrowserTabList
.
prototype
"
onListChanged
"
{
enumerable
:
true
configurable
:
true
get
(
)
{
return
this
.
_onListChanged
;
}
set
(
v
)
{
if
(
v
!
=
=
null
&
&
typeof
v
!
=
=
"
function
"
)
{
throw
new
Error
(
"
onListChanged
property
may
only
be
set
to
'
null
'
or
a
function
"
)
;
}
this
.
_onListChanged
=
v
;
this
.
_checkListening
(
)
;
}
}
)
;
BrowserTabList
.
prototype
.
_notifyListChanged
=
function
(
)
{
if
(
!
this
.
_onListChanged
)
{
return
;
}
if
(
this
.
_mustNotify
)
{
this
.
_onListChanged
(
)
;
this
.
_mustNotify
=
false
;
}
}
;
BrowserTabList
.
prototype
.
_handleActorClose
=
function
(
actor
browser
)
{
if
(
this
.
_testing
)
{
if
(
this
.
_actorByBrowser
.
get
(
browser
)
!
=
=
actor
)
{
throw
new
Error
(
"
BrowserTabActor
not
stored
in
map
under
given
browser
"
)
;
}
if
(
actor
.
browser
!
=
=
browser
)
{
throw
new
Error
(
"
actor
'
s
browser
and
map
key
don
'
t
match
"
)
;
}
}
this
.
_actorByBrowser
.
delete
(
browser
)
;
actor
.
exit
(
)
;
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
}
;
BrowserTabList
.
prototype
.
_checkListening
=
function
(
)
{
this
.
_listenForEventsIf
(
this
.
_onListChanged
&
&
this
.
_mustNotify
"
_listeningForTabOpen
"
[
"
TabOpen
"
"
TabSelect
"
"
TabAttrModified
"
]
)
;
this
.
_listenForEventsIf
(
this
.
_actorByBrowser
.
size
>
0
"
_listeningForTabClose
"
[
"
TabClose
"
"
TabRemotenessChange
"
]
)
;
this
.
_listenToMediatorIf
(
(
this
.
_onListChanged
&
&
this
.
_mustNotify
)
|
|
(
this
.
_actorByBrowser
.
size
>
0
)
)
;
this
.
_listenForMessagesIf
(
this
.
_onListChanged
&
&
this
.
_mustNotify
"
_listeningForTitleChange
"
[
"
DOMTitleChanged
"
]
)
;
}
;
BrowserTabList
.
prototype
.
_listenForEventsIf
=
function
(
shouldListen
guard
eventNames
)
{
if
(
!
shouldListen
!
=
=
!
this
[
guard
]
)
{
let
op
=
shouldListen
?
"
addEventListener
"
:
"
removeEventListener
"
;
for
(
let
win
of
allAppShellDOMWindows
(
DebuggerServer
.
chromeWindowType
)
)
{
for
(
let
name
of
eventNames
)
{
win
[
op
]
(
name
this
false
)
;
}
}
this
[
guard
]
=
shouldListen
;
}
}
;
BrowserTabList
.
prototype
.
_listenForMessagesIf
=
function
(
shouldListen
guard
messageNames
)
{
if
(
!
shouldListen
!
=
=
!
this
[
guard
]
)
{
let
op
=
shouldListen
?
"
addMessageListener
"
:
"
removeMessageListener
"
;
for
(
let
win
of
allAppShellDOMWindows
(
DebuggerServer
.
chromeWindowType
)
)
{
for
(
let
name
of
messageNames
)
{
win
.
messageManager
[
op
]
(
name
this
)
;
}
}
this
[
guard
]
=
shouldListen
;
}
}
;
BrowserTabList
.
prototype
.
receiveMessage
=
DevToolsUtils
.
makeInfallible
(
function
(
message
)
{
let
browser
=
message
.
target
;
switch
(
message
.
name
)
{
case
"
DOMTitleChanged
"
:
{
let
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
}
break
;
}
}
}
)
;
BrowserTabList
.
prototype
.
handleEvent
=
DevToolsUtils
.
makeInfallible
(
function
(
event
)
{
let
browser
=
event
.
target
.
linkedBrowser
;
switch
(
event
.
type
)
{
case
"
TabOpen
"
:
case
"
TabSelect
"
:
{
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
break
;
}
case
"
TabClose
"
:
{
let
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
this
.
_handleActorClose
(
actor
browser
)
;
}
break
;
}
case
"
TabRemotenessChange
"
:
{
let
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
this
.
_actorByBrowser
.
delete
(
browser
)
;
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
}
break
;
}
case
"
TabAttrModified
"
:
{
if
(
browser
.
isRemoteBrowser
)
{
break
;
}
let
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
if
(
event
.
detail
.
changed
.
includes
(
"
label
"
)
)
{
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
}
}
break
;
}
}
}
"
BrowserTabList
.
prototype
.
handleEvent
"
)
;
BrowserTabList
.
prototype
.
_listenToMediatorIf
=
function
(
shouldListen
)
{
if
(
!
shouldListen
!
=
=
!
this
.
_listeningToMediator
)
{
let
op
=
shouldListen
?
"
addListener
"
:
"
removeListener
"
;
Services
.
wm
[
op
]
(
this
)
;
this
.
_listeningToMediator
=
shouldListen
;
}
}
;
BrowserTabList
.
prototype
.
onOpenWindow
=
DevToolsUtils
.
makeInfallible
(
function
(
window
)
{
let
handleLoad
=
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
window
.
removeEventListener
(
"
load
"
handleLoad
)
;
if
(
appShellDOMWindowType
(
window
)
!
=
=
DebuggerServer
.
chromeWindowType
)
{
return
;
}
if
(
this
.
_listeningForTabOpen
)
{
window
.
addEventListener
(
"
TabOpen
"
this
)
;
window
.
addEventListener
(
"
TabSelect
"
this
)
;
window
.
addEventListener
(
"
TabAttrModified
"
this
)
;
}
if
(
this
.
_listeningForTabClose
)
{
window
.
addEventListener
(
"
TabClose
"
this
)
;
window
.
addEventListener
(
"
TabRemotenessChange
"
this
)
;
}
if
(
this
.
_listeningForTitleChange
)
{
window
.
messageManager
.
addMessageListener
(
"
DOMTitleChanged
"
this
)
;
}
this
.
_notifyListChanged
(
)
;
}
)
;
window
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
window
.
addEventListener
(
"
load
"
handleLoad
)
;
}
"
BrowserTabList
.
prototype
.
onOpenWindow
"
)
;
BrowserTabList
.
prototype
.
onCloseWindow
=
DevToolsUtils
.
makeInfallible
(
function
(
window
)
{
window
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
if
(
appShellDOMWindowType
(
window
)
!
=
=
DebuggerServer
.
chromeWindowType
)
{
return
;
}
Services
.
tm
.
dispatchToMainThread
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
for
(
let
[
browser
actor
]
of
this
.
_actorByBrowser
)
{
if
(
!
browser
.
ownerGlobal
)
{
this
.
_handleActorClose
(
actor
browser
)
;
}
}
}
"
BrowserTabList
.
prototype
.
onCloseWindow
'
s
delayed
body
"
)
)
;
}
"
BrowserTabList
.
prototype
.
onCloseWindow
"
)
;
exports
.
BrowserTabList
=
BrowserTabList
;
function
BrowserTabActor
(
connection
browser
options
=
{
}
)
{
this
.
_conn
=
connection
;
this
.
_browser
=
browser
;
this
.
_form
=
null
;
this
.
exited
=
false
;
this
.
options
=
options
;
}
BrowserTabActor
.
prototype
=
{
async
connect
(
)
{
let
onDestroy
=
(
)
=
>
{
if
(
this
.
_deferredUpdate
)
{
this
.
_deferredUpdate
.
reject
(
{
error
:
"
tabDestroyed
"
message
:
"
Tab
destroyed
while
performing
a
BrowserTabActor
update
"
}
)
;
}
this
.
exit
(
)
;
}
;
let
connect
=
DebuggerServer
.
connectToChild
(
this
.
_conn
this
.
_browser
onDestroy
)
;
let
form
=
await
connect
;
this
.
_form
=
form
;
if
(
this
.
options
.
favicons
)
{
this
.
_form
.
favicon
=
await
this
.
getFaviconData
(
)
;
}
return
this
;
}
get
_tabbrowser
(
)
{
if
(
this
.
_browser
&
&
typeof
this
.
_browser
.
getTabBrowser
=
=
"
function
"
)
{
return
this
.
_browser
.
getTabBrowser
(
)
;
}
return
null
;
}
get
_mm
(
)
{
return
this
.
_browser
.
messageManager
|
|
this
.
_browser
.
frameLoader
.
messageManager
;
}
async
getFaviconData
(
)
{
try
{
let
{
data
}
=
await
PlacesUtils
.
promiseFaviconData
(
this
.
_form
.
url
)
;
return
data
;
}
catch
(
e
)
{
return
null
;
}
}
async
update
(
options
=
{
}
)
{
this
.
options
=
options
;
if
(
this
.
exited
)
{
return
this
.
connect
(
)
;
}
let
form
=
await
new
Promise
(
resolve
=
>
{
let
onFormUpdate
=
msg
=
>
{
if
(
this
.
_form
.
actor
!
=
msg
.
json
.
actor
)
{
return
;
}
this
.
_mm
.
removeMessageListener
(
"
debug
:
form
"
onFormUpdate
)
;
resolve
(
msg
.
json
)
;
}
;
this
.
_mm
.
addMessageListener
(
"
debug
:
form
"
onFormUpdate
)
;
this
.
_mm
.
sendAsyncMessage
(
"
debug
:
form
"
)
;
}
)
;
this
.
_form
=
form
;
if
(
this
.
options
.
favicons
)
{
this
.
_form
.
favicon
=
await
this
.
getFaviconData
(
)
;
}
return
this
;
}
get
title
(
)
{
if
(
this
.
_browser
&
&
this
.
_browser
.
__SS_restore
)
{
let
sessionStore
=
this
.
_browser
.
__SS_data
;
let
entry
=
sessionStore
.
entries
[
sessionStore
.
index
-
1
]
;
return
entry
.
title
;
}
if
(
this
.
_tabbrowser
)
{
let
tab
=
this
.
_tabbrowser
.
getTabForBrowser
(
this
.
_browser
)
;
if
(
tab
)
{
return
tab
.
label
;
}
}
return
"
"
;
}
get
url
(
)
{
if
(
this
.
_browser
&
&
this
.
_browser
.
__SS_restore
)
{
let
sessionStore
=
this
.
_browser
.
__SS_data
;
let
entry
=
sessionStore
.
entries
[
sessionStore
.
index
-
1
]
;
return
entry
.
url
;
}
return
null
;
}
form
(
)
{
let
form
=
Object
.
assign
(
{
}
this
.
_form
)
;
if
(
!
form
.
title
)
{
form
.
title
=
this
.
title
;
}
if
(
!
form
.
url
)
{
form
.
url
=
this
.
url
;
}
return
form
;
}
exit
(
)
{
this
.
_browser
=
null
;
this
.
_form
=
null
;
this
.
exited
=
true
;
}
}
;
exports
.
BrowserTabActor
=
BrowserTabActor
;
function
BrowserAddonList
(
connection
)
{
this
.
_connection
=
connection
;
this
.
_actorByAddonId
=
new
Map
(
)
;
this
.
_onListChanged
=
null
;
}
BrowserAddonList
.
prototype
.
getList
=
function
(
)
{
let
deferred
=
defer
(
)
;
AddonManager
.
getAllAddons
(
(
addons
)
=
>
{
for
(
let
addon
of
addons
)
{
let
actor
=
this
.
_actorByAddonId
.
get
(
addon
.
id
)
;
if
(
!
actor
)
{
if
(
addon
.
isWebExtension
)
{
actor
=
new
WebExtensionParentActor
(
this
.
_connection
addon
)
;
}
else
{
actor
=
new
BrowserAddonActor
(
this
.
_connection
addon
)
;
}
this
.
_actorByAddonId
.
set
(
addon
.
id
actor
)
;
}
}
deferred
.
resolve
(
[
.
.
.
this
.
_actorByAddonId
]
.
map
(
(
[
_
actor
]
)
=
>
actor
)
)
;
}
)
;
return
deferred
.
promise
;
}
;
Object
.
defineProperty
(
BrowserAddonList
.
prototype
"
onListChanged
"
{
enumerable
:
true
configurable
:
true
get
(
)
{
return
this
.
_onListChanged
;
}
set
(
v
)
{
if
(
v
!
=
=
null
&
&
typeof
v
!
=
"
function
"
)
{
throw
new
Error
(
"
onListChanged
property
may
only
be
set
to
'
null
'
or
a
function
"
)
;
}
this
.
_onListChanged
=
v
;
this
.
_adjustListener
(
)
;
}
}
)
;
BrowserAddonList
.
prototype
.
onInstalled
=
function
(
addon
)
{
this
.
_notifyListChanged
(
)
;
this
.
_adjustListener
(
)
;
}
;
BrowserAddonList
.
prototype
.
onUninstalled
=
function
(
addon
)
{
this
.
_actorByAddonId
.
delete
(
addon
.
id
)
;
this
.
_notifyListChanged
(
)
;
this
.
_adjustListener
(
)
;
}
;
BrowserAddonList
.
prototype
.
_notifyListChanged
=
function
(
)
{
if
(
this
.
_onListChanged
)
{
this
.
_onListChanged
(
)
;
}
}
;
BrowserAddonList
.
prototype
.
_adjustListener
=
function
(
)
{
if
(
this
.
_onListChanged
)
{
AddonManager
.
addAddonListener
(
this
)
;
}
else
if
(
this
.
_actorByAddonId
.
size
=
=
=
0
)
{
AddonManager
.
removeAddonListener
(
this
)
;
}
}
;
exports
.
BrowserAddonList
=
BrowserAddonList
;
exports
.
register
=
function
(
handle
)
{
handle
.
setRootActor
(
createRootActor
)
;
}
;
exports
.
unregister
=
function
(
handle
)
{
handle
.
setRootActor
(
null
)
;
}
;
