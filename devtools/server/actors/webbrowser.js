"
use
strict
"
;
var
{
Ci
Cu
Cr
}
=
require
(
"
chrome
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
var
promise
=
require
(
"
promise
"
)
;
var
{
ActorPool
createExtraActors
appendExtraActors
GeneratedLocation
}
=
require
(
"
devtools
/
server
/
actors
/
common
"
)
;
var
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
{
assert
}
=
DevToolsUtils
;
var
{
TabSources
}
=
require
(
"
.
/
utils
/
TabSources
"
)
;
var
makeDebugger
=
require
(
"
.
/
utils
/
make
-
debugger
"
)
;
loader
.
lazyRequireGetter
(
this
"
RootActor
"
"
devtools
/
server
/
actors
/
root
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ThreadActor
"
"
devtools
/
server
/
actors
/
script
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
unwrapDebuggerObjectGlobal
"
"
devtools
/
server
/
actors
/
script
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BrowserAddonActor
"
"
devtools
/
server
/
actors
/
addon
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebExtensionActor
"
"
devtools
/
server
/
actors
/
webextension
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WorkerActorList
"
"
devtools
/
server
/
actors
/
worker
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ServiceWorkerRegistrationActorList
"
"
devtools
/
server
/
actors
/
worker
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ProcessActorList
"
"
devtools
/
server
/
actors
/
process
"
true
)
;
loader
.
lazyImporter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
ExtensionContent
"
"
resource
:
/
/
gre
/
modules
/
ExtensionContent
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
events
"
"
sdk
/
event
/
core
"
)
;
loader
.
lazyRequireGetter
(
this
"
StyleSheetActor
"
"
devtools
/
server
/
actors
/
stylesheets
"
true
)
;
function
getWindowID
(
window
)
{
return
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
}
function
getDocShellChromeEventHandler
(
docShell
)
{
let
handler
=
docShell
.
chromeEventHandler
;
if
(
!
handler
)
{
try
{
handler
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
catch
(
e
)
{
}
}
return
handler
;
}
function
getChildDocShells
(
parentDocShell
)
{
let
docShellsEnum
=
parentDocShell
.
getDocShellEnumerator
(
Ci
.
nsIDocShellTreeItem
.
typeAll
Ci
.
nsIDocShell
.
ENUMERATE_FORWARDS
)
;
let
docShells
=
[
]
;
while
(
docShellsEnum
.
hasMoreElements
(
)
)
{
let
docShell
=
docShellsEnum
.
getNext
(
)
;
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
docShells
.
push
(
docShell
)
;
}
return
docShells
;
}
exports
.
getChildDocShells
=
getChildDocShells
;
function
getInnerId
(
window
)
{
return
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
}
function
*
allAppShellDOMWindows
(
windowType
)
{
let
e
=
Services
.
wm
.
getEnumerator
(
windowType
)
;
while
(
e
.
hasMoreElements
(
)
)
{
yield
e
.
getNext
(
)
;
}
}
exports
.
allAppShellDOMWindows
=
allAppShellDOMWindows
;
function
appShellDOMWindowType
(
window
)
{
return
window
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
}
function
sendShutdownEvent
(
)
{
for
(
let
win
of
allAppShellDOMWindows
(
DebuggerServer
.
chromeWindowType
)
)
{
let
evt
=
win
.
document
.
createEvent
(
"
Event
"
)
;
evt
.
initEvent
(
"
Debugger
:
Shutdown
"
true
false
)
;
win
.
document
.
documentElement
.
dispatchEvent
(
evt
)
;
}
}
exports
.
sendShutdownEvent
=
sendShutdownEvent
;
function
createRootActor
(
connection
)
{
return
new
RootActor
(
connection
{
tabList
:
new
BrowserTabList
(
connection
)
addonList
:
new
BrowserAddonList
(
connection
)
workerList
:
new
WorkerActorList
(
connection
{
}
)
serviceWorkerRegistrationList
:
new
ServiceWorkerRegistrationActorList
(
connection
)
processList
:
new
ProcessActorList
(
)
globalActorFactories
:
DebuggerServer
.
globalActorFactories
onShutdown
:
sendShutdownEvent
}
)
;
}
function
BrowserTabList
(
connection
)
{
this
.
_connection
=
connection
;
this
.
_actorByBrowser
=
new
Map
(
)
;
this
.
_onListChanged
=
null
;
this
.
_mustNotify
=
false
;
this
.
_testing
=
false
;
}
BrowserTabList
.
prototype
.
constructor
=
BrowserTabList
;
BrowserTabList
.
prototype
.
_getSelectedBrowser
=
function
(
window
)
{
return
window
.
gBrowser
?
window
.
gBrowser
.
selectedBrowser
:
null
;
}
;
BrowserTabList
.
prototype
.
_getBrowsers
=
function
*
(
)
{
for
(
let
win
of
allAppShellDOMWindows
(
DebuggerServer
.
chromeWindowType
)
)
{
for
(
let
browser
of
this
.
_getChildren
(
win
)
)
{
yield
browser
;
}
}
}
;
BrowserTabList
.
prototype
.
_getChildren
=
function
(
window
)
{
if
(
!
window
.
gBrowser
)
{
return
[
]
;
}
let
{
gBrowser
}
=
window
;
if
(
!
gBrowser
.
browsers
)
{
return
[
]
;
}
return
gBrowser
.
browsers
.
filter
(
browser
=
>
{
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
return
!
tab
.
closing
;
}
)
;
}
;
BrowserTabList
.
prototype
.
getList
=
function
(
)
{
let
topXULWindow
=
Services
.
wm
.
getMostRecentWindow
(
DebuggerServer
.
chromeWindowType
)
;
let
selectedBrowser
=
null
;
if
(
topXULWindow
)
{
selectedBrowser
=
this
.
_getSelectedBrowser
(
topXULWindow
)
;
}
let
initialMapSize
=
this
.
_actorByBrowser
.
size
;
this
.
_foundCount
=
0
;
let
actorPromises
=
[
]
;
for
(
let
browser
of
this
.
_getBrowsers
(
)
)
{
let
selected
=
browser
=
=
=
selectedBrowser
;
actorPromises
.
push
(
this
.
_getActorForBrowser
(
browser
)
.
then
(
actor
=
>
{
actor
.
selected
=
selected
;
return
actor
;
}
)
)
;
}
if
(
this
.
_testing
&
&
initialMapSize
!
=
=
this
.
_foundCount
)
{
throw
new
Error
(
"
_actorByBrowser
map
contained
actors
for
dead
tabs
"
)
;
}
this
.
_mustNotify
=
true
;
this
.
_checkListening
(
)
;
return
promise
.
all
(
actorPromises
)
;
}
;
BrowserTabList
.
prototype
.
_getActorForBrowser
=
function
(
browser
)
{
let
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
this
.
_foundCount
+
+
;
return
actor
.
update
(
)
;
}
actor
=
new
BrowserTabActor
(
this
.
_connection
browser
)
;
this
.
_actorByBrowser
.
set
(
browser
actor
)
;
this
.
_checkListening
(
)
;
return
actor
.
connect
(
)
;
}
;
BrowserTabList
.
prototype
.
getTab
=
function
(
{
outerWindowID
tabId
}
)
{
if
(
typeof
outerWindowID
=
=
"
number
"
)
{
let
window
=
Services
.
wm
.
getOuterWindowWithId
(
outerWindowID
)
;
if
(
window
instanceof
Ci
.
nsIDOMChromeWindow
)
{
return
promise
.
reject
(
{
error
:
"
forbidden
"
message
:
"
Window
with
outerWindowID
'
"
+
outerWindowID
+
"
'
is
chrome
"
}
)
;
}
if
(
window
)
{
let
iframe
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
containerElement
;
if
(
iframe
)
{
return
this
.
_getActorForBrowser
(
iframe
)
;
}
}
for
(
let
browser
of
this
.
_getBrowsers
(
)
)
{
if
(
browser
.
outerWindowID
=
=
outerWindowID
)
{
return
this
.
_getActorForBrowser
(
browser
)
;
}
}
return
promise
.
reject
(
{
error
:
"
noTab
"
message
:
"
Unable
to
find
tab
with
outerWindowID
'
"
+
outerWindowID
+
"
'
"
}
)
;
}
else
if
(
typeof
tabId
=
=
"
number
"
)
{
for
(
let
browser
of
this
.
_getBrowsers
(
)
)
{
if
(
browser
.
frameLoader
.
tabParent
&
&
browser
.
frameLoader
.
tabParent
.
tabId
=
=
=
tabId
)
{
return
this
.
_getActorForBrowser
(
browser
)
;
}
}
return
promise
.
reject
(
{
error
:
"
noTab
"
message
:
"
Unable
to
find
tab
with
tabId
'
"
+
tabId
+
"
'
"
}
)
;
}
let
topXULWindow
=
Services
.
wm
.
getMostRecentWindow
(
DebuggerServer
.
chromeWindowType
)
;
if
(
topXULWindow
)
{
let
selectedBrowser
=
this
.
_getSelectedBrowser
(
topXULWindow
)
;
return
this
.
_getActorForBrowser
(
selectedBrowser
)
;
}
return
promise
.
reject
(
{
error
:
"
noTab
"
message
:
"
Unable
to
find
any
selected
browser
"
}
)
;
}
;
Object
.
defineProperty
(
BrowserTabList
.
prototype
"
onListChanged
"
{
enumerable
:
true
configurable
:
true
get
(
)
{
return
this
.
_onListChanged
;
}
set
(
v
)
{
if
(
v
!
=
=
null
&
&
typeof
v
!
=
=
"
function
"
)
{
throw
new
Error
(
"
onListChanged
property
may
only
be
set
to
'
null
'
or
a
function
"
)
;
}
this
.
_onListChanged
=
v
;
this
.
_checkListening
(
)
;
}
}
)
;
BrowserTabList
.
prototype
.
_notifyListChanged
=
function
(
)
{
if
(
!
this
.
_onListChanged
)
{
return
;
}
if
(
this
.
_mustNotify
)
{
this
.
_onListChanged
(
)
;
this
.
_mustNotify
=
false
;
}
}
;
BrowserTabList
.
prototype
.
_handleActorClose
=
function
(
actor
browser
)
{
if
(
this
.
_testing
)
{
if
(
this
.
_actorByBrowser
.
get
(
browser
)
!
=
=
actor
)
{
throw
new
Error
(
"
BrowserTabActor
not
stored
in
map
under
given
browser
"
)
;
}
if
(
actor
.
browser
!
=
=
browser
)
{
throw
new
Error
(
"
actor
'
s
browser
and
map
key
don
'
t
match
"
)
;
}
}
this
.
_actorByBrowser
.
delete
(
browser
)
;
actor
.
exit
(
)
;
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
}
;
BrowserTabList
.
prototype
.
_checkListening
=
function
(
)
{
this
.
_listenForEventsIf
(
this
.
_onListChanged
&
&
this
.
_mustNotify
"
_listeningForTabOpen
"
[
"
TabOpen
"
"
TabSelect
"
"
TabAttrModified
"
]
)
;
this
.
_listenForEventsIf
(
this
.
_actorByBrowser
.
size
>
0
"
_listeningForTabClose
"
[
"
TabClose
"
"
TabRemotenessChange
"
]
)
;
this
.
_listenToMediatorIf
(
(
this
.
_onListChanged
&
&
this
.
_mustNotify
)
|
|
(
this
.
_actorByBrowser
.
size
>
0
)
)
;
this
.
_listenForMessagesIf
(
this
.
_onListChanged
&
&
this
.
_mustNotify
"
_listeningForTitleChange
"
[
"
DOMTitleChanged
"
]
)
;
}
;
BrowserTabList
.
prototype
.
_listenForEventsIf
=
function
(
shouldListen
guard
eventNames
)
{
if
(
!
shouldListen
!
=
=
!
this
[
guard
]
)
{
let
op
=
shouldListen
?
"
addEventListener
"
:
"
removeEventListener
"
;
for
(
let
win
of
allAppShellDOMWindows
(
DebuggerServer
.
chromeWindowType
)
)
{
for
(
let
name
of
eventNames
)
{
win
[
op
]
(
name
this
false
)
;
}
}
this
[
guard
]
=
shouldListen
;
}
}
;
BrowserTabList
.
prototype
.
_listenForMessagesIf
=
function
(
shouldListen
guard
messageNames
)
{
if
(
!
shouldListen
!
=
=
!
this
[
guard
]
)
{
let
op
=
shouldListen
?
"
addMessageListener
"
:
"
removeMessageListener
"
;
for
(
let
win
of
allAppShellDOMWindows
(
DebuggerServer
.
chromeWindowType
)
)
{
for
(
let
name
of
messageNames
)
{
win
.
messageManager
[
op
]
(
name
this
)
;
}
}
this
[
guard
]
=
shouldListen
;
}
}
;
BrowserTabList
.
prototype
.
receiveMessage
=
DevToolsUtils
.
makeInfallible
(
function
(
message
)
{
let
browser
=
message
.
target
;
switch
(
message
.
name
)
{
case
"
DOMTitleChanged
"
:
{
let
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
}
break
;
}
}
}
)
;
BrowserTabList
.
prototype
.
handleEvent
=
DevToolsUtils
.
makeInfallible
(
function
(
event
)
{
let
browser
=
event
.
target
.
linkedBrowser
;
switch
(
event
.
type
)
{
case
"
TabOpen
"
:
case
"
TabSelect
"
:
{
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
break
;
}
case
"
TabClose
"
:
{
let
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
this
.
_handleActorClose
(
actor
browser
)
;
}
break
;
}
case
"
TabRemotenessChange
"
:
{
let
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
this
.
_actorByBrowser
.
delete
(
browser
)
;
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
}
break
;
}
case
"
TabAttrModified
"
:
{
if
(
browser
.
isRemoteBrowser
)
{
break
;
}
let
actor
=
this
.
_actorByBrowser
.
get
(
browser
)
;
if
(
actor
)
{
if
(
event
.
detail
.
changed
.
includes
(
"
label
"
)
)
{
this
.
_notifyListChanged
(
)
;
this
.
_checkListening
(
)
;
}
}
break
;
}
}
}
"
BrowserTabList
.
prototype
.
handleEvent
"
)
;
BrowserTabList
.
prototype
.
_listenToMediatorIf
=
function
(
shouldListen
)
{
if
(
!
shouldListen
!
=
=
!
this
.
_listeningToMediator
)
{
let
op
=
shouldListen
?
"
addListener
"
:
"
removeListener
"
;
Services
.
wm
[
op
]
(
this
)
;
this
.
_listeningToMediator
=
shouldListen
;
}
}
;
BrowserTabList
.
prototype
.
onWindowTitleChange
=
(
)
=
>
{
}
;
BrowserTabList
.
prototype
.
onOpenWindow
=
DevToolsUtils
.
makeInfallible
(
function
(
window
)
{
let
handleLoad
=
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
window
.
removeEventListener
(
"
load
"
handleLoad
false
)
;
if
(
appShellDOMWindowType
(
window
)
!
=
=
DebuggerServer
.
chromeWindowType
)
{
return
;
}
if
(
this
.
_listeningForTabOpen
)
{
window
.
addEventListener
(
"
TabOpen
"
this
false
)
;
window
.
addEventListener
(
"
TabSelect
"
this
false
)
;
window
.
addEventListener
(
"
TabAttrModified
"
this
false
)
;
}
if
(
this
.
_listeningForTabClose
)
{
window
.
addEventListener
(
"
TabClose
"
this
false
)
;
window
.
addEventListener
(
"
TabRemotenessChange
"
this
false
)
;
}
if
(
this
.
_listeningForTitleChange
)
{
window
.
messageManager
.
addMessageListener
(
"
DOMTitleChanged
"
this
)
;
}
this
.
_notifyListChanged
(
)
;
}
)
;
window
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
window
.
addEventListener
(
"
load
"
handleLoad
false
)
;
}
"
BrowserTabList
.
prototype
.
onOpenWindow
"
)
;
BrowserTabList
.
prototype
.
onCloseWindow
=
DevToolsUtils
.
makeInfallible
(
function
(
window
)
{
window
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
if
(
appShellDOMWindowType
(
window
)
!
=
=
DebuggerServer
.
chromeWindowType
)
{
return
;
}
Services
.
tm
.
currentThread
.
dispatch
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
for
(
let
[
browser
actor
]
of
this
.
_actorByBrowser
)
{
if
(
!
browser
.
ownerDocument
.
defaultView
)
{
this
.
_handleActorClose
(
actor
browser
)
;
}
}
}
"
BrowserTabList
.
prototype
.
onCloseWindow
'
s
delayed
body
"
)
0
)
;
}
"
BrowserTabList
.
prototype
.
onCloseWindow
"
)
;
exports
.
BrowserTabList
=
BrowserTabList
;
function
TabActor
(
connection
)
{
this
.
conn
=
connection
;
this
.
_tabActorPool
=
null
;
this
.
_extraActors
=
{
}
;
this
.
_exited
=
false
;
this
.
_sources
=
null
;
this
.
_styleSheetActors
=
new
Map
(
)
;
this
.
_shouldAddNewGlobalAsDebuggee
=
this
.
_shouldAddNewGlobalAsDebuggee
.
bind
(
this
)
;
this
.
makeDebugger
=
makeDebugger
.
bind
(
null
{
findDebuggees
:
(
)
=
>
{
return
this
.
windows
.
concat
(
this
.
webextensionsContentScriptGlobals
)
;
}
shouldAddNewGlobalAsDebuggee
:
this
.
_shouldAddNewGlobalAsDebuggee
}
)
;
this
.
listenForNewDocShells
=
false
;
this
.
traits
=
{
reconfigure
:
true
frames
:
true
noTabReconfigureOnClose
:
true
}
;
this
.
_workerActorList
=
null
;
this
.
_workerActorPool
=
null
;
this
.
_onWorkerActorListChanged
=
this
.
_onWorkerActorListChanged
.
bind
(
this
)
;
}
TabActor
.
prototype
=
{
traits
:
null
consoleAPIListenerOptions
:
{
}
_allowSource
(
)
{
return
true
;
}
get
exited
(
)
{
return
this
.
_exited
;
}
get
attached
(
)
{
return
!
!
this
.
_attached
;
}
_tabPool
:
null
get
tabActorPool
(
)
{
return
this
.
_tabPool
;
}
_contextPool
:
null
get
contextActorPool
(
)
{
return
this
.
_contextPool
;
}
actorPrefix
:
"
tab
"
get
chromeEventHandler
(
)
{
return
getDocShellChromeEventHandler
(
this
.
docShell
)
;
}
get
messageManager
(
)
{
try
{
return
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
}
catch
(
e
)
{
return
null
;
}
}
get
docShell
(
)
{
throw
new
Error
(
"
The
docShell
getter
should
be
implemented
by
a
subclass
of
TabActor
"
)
;
}
get
docShells
(
)
{
return
getChildDocShells
(
this
.
docShell
)
;
}
get
window
(
)
{
if
(
this
.
docShell
)
{
return
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
return
null
;
}
get
outerWindowID
(
)
{
if
(
this
.
window
)
{
return
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
}
return
null
;
}
get
webextensionsContentScriptGlobals
(
)
{
if
(
this
.
window
)
{
return
ExtensionContent
.
getContentScriptGlobalsForWindow
(
this
.
window
)
;
}
return
[
]
;
}
get
windows
(
)
{
return
this
.
docShells
.
map
(
docShell
=
>
{
return
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
)
;
}
get
originalDocShell
(
)
{
if
(
!
this
.
_originalWindow
)
{
return
this
.
docShell
;
}
return
this
.
_originalWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
}
get
originalWindow
(
)
{
return
this
.
_originalWindow
|
|
this
.
window
;
}
get
webProgress
(
)
{
return
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
}
get
webNavigation
(
)
{
return
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
;
}
get
contentDocument
(
)
{
return
this
.
webNavigation
.
document
;
}
get
title
(
)
{
return
this
.
contentDocument
.
contentTitle
;
}
get
url
(
)
{
if
(
this
.
webNavigation
.
currentURI
)
{
return
this
.
webNavigation
.
currentURI
.
spec
;
}
return
null
;
}
get
sources
(
)
{
if
(
!
this
.
_sources
)
{
this
.
_sources
=
new
TabSources
(
this
.
threadActor
this
.
_allowSource
)
;
}
return
this
.
_sources
;
}
update
(
)
{
return
promise
.
resolve
(
this
)
;
}
form
(
)
{
assert
(
!
this
.
exited
"
form
(
)
shouldn
'
t
be
called
on
exited
browser
actor
.
"
)
;
assert
(
this
.
actorID
"
tab
should
have
an
actorID
.
"
)
;
let
response
=
{
actor
:
this
.
actorID
}
;
if
(
this
.
docShell
&
&
!
this
.
docShell
.
isBeingDestroyed
(
)
)
{
response
.
title
=
this
.
title
;
response
.
url
=
this
.
url
;
response
.
outerWindowID
=
this
.
outerWindowID
;
}
if
(
!
this
.
_tabActorPool
)
{
this
.
_tabActorPool
=
new
ActorPool
(
this
.
conn
)
;
this
.
conn
.
addActorPool
(
this
.
_tabActorPool
)
;
}
this
.
_createExtraActors
(
DebuggerServer
.
tabActorFactories
this
.
_tabActorPool
)
;
this
.
_appendExtraActors
(
response
)
;
return
response
;
}
disconnect
(
)
{
this
.
exit
(
)
;
}
exit
(
)
{
if
(
this
.
exited
)
{
return
;
}
if
(
this
.
_attached
)
{
this
.
threadActor
.
_tabClosed
=
true
;
}
this
.
_detach
(
)
;
Object
.
defineProperty
(
this
"
docShell
"
{
value
:
null
configurable
:
true
}
)
;
this
.
_extraActors
=
null
;
this
.
_exited
=
true
;
}
_shouldAddNewGlobalAsDebuggee
(
wrappedGlobal
)
{
if
(
wrappedGlobal
.
hostAnnotations
&
&
wrappedGlobal
.
hostAnnotations
.
type
=
=
"
document
"
&
&
wrappedGlobal
.
hostAnnotations
.
element
=
=
=
this
.
window
)
{
return
true
;
}
let
global
=
unwrapDebuggerObjectGlobal
(
wrappedGlobal
)
;
if
(
!
global
)
{
return
false
;
}
let
metadata
=
{
}
;
let
id
=
"
"
;
try
{
id
=
getInnerId
(
this
.
window
)
;
metadata
=
Cu
.
getSandboxMetadata
(
global
)
;
}
catch
(
e
)
{
}
if
(
metadata
&
&
metadata
[
"
inner
-
window
-
id
"
]
&
&
metadata
[
"
inner
-
window
-
id
"
]
=
=
id
)
{
return
true
;
}
return
false
;
}
_createExtraActors
:
createExtraActors
_appendExtraActors
:
appendExtraActors
_attach
(
)
{
if
(
this
.
_attached
)
{
return
;
}
assert
(
!
this
.
_tabPool
"
Shouldn
'
t
have
a
tab
pool
if
we
weren
'
t
attached
.
"
)
;
this
.
_tabPool
=
new
ActorPool
(
this
.
conn
)
;
this
.
conn
.
addActorPool
(
this
.
_tabPool
)
;
this
.
_pushContext
(
)
;
if
(
this
.
window
)
{
this
.
_progressListener
=
new
DebuggerProgressListener
(
this
)
;
this
.
_originalWindow
=
this
.
window
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
this
.
_watchDocshells
(
)
)
;
}
this
.
_attached
=
true
;
}
_watchDocshells
(
)
{
if
(
this
.
listenForNewDocShells
)
{
Services
.
obs
.
addObserver
(
this
"
webnavigation
-
create
"
false
)
;
}
Services
.
obs
.
addObserver
(
this
"
webnavigation
-
destroy
"
false
)
;
this
.
_progressListener
.
watch
(
this
.
docShell
)
;
this
.
_updateChildDocShells
(
)
;
}
onSwitchToFrame
(
request
)
{
let
windowId
=
request
.
windowId
;
let
win
;
try
{
win
=
Services
.
wm
.
getOuterWindowWithId
(
windowId
)
;
}
catch
(
e
)
{
}
if
(
!
win
)
{
return
{
error
:
"
noWindow
"
message
:
"
The
related
docshell
is
destroyed
or
not
found
"
}
;
}
else
if
(
win
=
=
this
.
window
)
{
return
{
}
;
}
DevToolsUtils
.
executeSoon
(
(
)
=
>
this
.
_changeTopLevelDocument
(
win
)
)
;
return
{
}
;
}
onListFrames
(
request
)
{
let
windows
=
this
.
_docShellsToWindows
(
this
.
docShells
)
;
return
{
frames
:
windows
}
;
}
onListWorkers
(
request
)
{
if
(
!
this
.
attached
)
{
return
{
error
:
"
wrongState
"
}
;
}
if
(
this
.
_workerActorList
=
=
=
null
)
{
this
.
_workerActorList
=
new
WorkerActorList
(
this
.
conn
{
type
:
Ci
.
nsIWorkerDebugger
.
TYPE_DEDICATED
window
:
this
.
window
}
)
;
}
return
this
.
_workerActorList
.
getList
(
)
.
then
(
(
actors
)
=
>
{
let
pool
=
new
ActorPool
(
this
.
conn
)
;
for
(
let
actor
of
actors
)
{
pool
.
addActor
(
actor
)
;
}
this
.
conn
.
removeActorPool
(
this
.
_workerActorPool
)
;
this
.
_workerActorPool
=
pool
;
this
.
conn
.
addActorPool
(
this
.
_workerActorPool
)
;
this
.
_workerActorList
.
onListChanged
=
this
.
_onWorkerActorListChanged
;
return
{
"
from
"
:
this
.
actorID
"
workers
"
:
actors
.
map
(
(
actor
)
=
>
actor
.
form
(
)
)
}
;
}
)
;
}
_onWorkerActorListChanged
(
)
{
this
.
_workerActorList
.
onListChanged
=
null
;
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
workerListChanged
"
)
;
}
observe
(
subject
topic
data
)
{
if
(
!
this
.
attached
)
{
return
;
}
if
(
topic
=
=
"
webnavigation
-
create
"
)
{
subject
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
this
.
_onDocShellCreated
(
subject
)
;
}
else
if
(
topic
=
=
"
webnavigation
-
destroy
"
)
{
this
.
_onDocShellDestroy
(
subject
)
;
}
}
_onDocShellCreated
(
docShell
)
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
if
(
docShell
.
isBeingDestroyed
(
)
)
{
return
;
}
if
(
this
.
_isRootDocShell
(
docShell
)
)
{
this
.
_progressListener
.
watch
(
docShell
)
;
}
this
.
_notifyDocShellsUpdate
(
[
docShell
]
)
;
}
)
;
}
_onDocShellDestroy
(
docShell
)
{
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
this
.
_notifyDocShellDestroy
(
webProgress
)
;
}
_isRootDocShell
(
docShell
)
{
return
!
docShell
.
parent
;
}
_docShellsToWindows
(
docshells
)
{
return
docshells
.
map
(
docShell
=
>
{
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
let
window
=
webProgress
.
DOMWindow
;
let
id
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
let
parentID
=
undefined
;
if
(
window
.
parent
&
&
window
!
=
this
.
_originalWindow
)
{
parentID
=
window
.
parent
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
}
let
addonID
=
window
.
document
.
nodePrincipal
.
originAttributes
.
addonId
;
return
{
id
parentID
addonID
url
:
window
.
location
.
href
title
:
window
.
document
.
title
}
;
}
)
;
}
_notifyDocShellsUpdate
(
docshells
)
{
let
windows
=
this
.
_docShellsToWindows
(
docshells
)
;
if
(
windows
.
length
=
=
0
)
{
return
;
}
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
frameUpdate
"
frames
:
windows
}
)
;
}
_updateChildDocShells
(
)
{
this
.
_notifyDocShellsUpdate
(
this
.
docShells
)
;
}
_notifyDocShellDestroy
(
webProgress
)
{
webProgress
=
webProgress
.
QueryInterface
(
Ci
.
nsIWebProgress
)
;
let
id
=
webProgress
.
DOMWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
frameUpdate
"
frames
:
[
{
id
destroy
:
true
}
]
}
)
;
webProgress
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
this
.
_progressListener
.
unwatch
(
webProgress
)
;
if
(
webProgress
.
DOMWindow
=
=
this
.
_originalWindow
)
{
let
rootDocShells
=
this
.
docShells
.
filter
(
d
=
>
{
return
d
!
=
this
.
docShell
&
&
this
.
_isRootDocShell
(
d
)
;
}
)
;
if
(
rootDocShells
.
length
>
0
)
{
let
newRoot
=
rootDocShells
[
0
]
;
this
.
_originalWindow
=
newRoot
.
DOMWindow
;
this
.
_changeTopLevelDocument
(
this
.
_originalWindow
)
;
}
else
{
this
.
exit
(
)
;
}
return
;
}
if
(
webProgress
.
DOMWindow
=
=
this
.
window
&
&
this
.
window
!
=
this
.
_originalWindow
)
{
this
.
_changeTopLevelDocument
(
this
.
_originalWindow
)
;
}
}
_notifyDocShellDestroyAll
(
)
{
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
frameUpdate
"
destroyAll
:
true
}
)
;
}
_pushContext
(
)
{
assert
(
!
this
.
_contextPool
"
Can
'
t
push
multiple
contexts
"
)
;
this
.
_contextPool
=
new
ActorPool
(
this
.
conn
)
;
this
.
conn
.
addActorPool
(
this
.
_contextPool
)
;
this
.
threadActor
=
new
ThreadActor
(
this
this
.
window
)
;
this
.
_contextPool
.
addActor
(
this
.
threadActor
)
;
}
_popContext
(
)
{
assert
(
!
!
this
.
_contextPool
"
No
context
to
pop
.
"
)
;
this
.
conn
.
removeActorPool
(
this
.
_contextPool
)
;
this
.
_contextPool
=
null
;
this
.
threadActor
.
exit
(
)
;
this
.
threadActor
=
null
;
this
.
_sources
=
null
;
}
_detach
(
)
{
if
(
!
this
.
attached
)
{
return
false
;
}
if
(
this
.
docShell
)
{
this
.
_progressListener
.
unwatch
(
this
.
docShell
)
;
this
.
_restoreDocumentSettings
(
)
;
}
if
(
this
.
_progressListener
)
{
this
.
_progressListener
.
destroy
(
)
;
this
.
_progressListener
=
null
;
this
.
_originalWindow
=
null
;
if
(
this
.
listenForNewDocShells
)
{
Services
.
obs
.
removeObserver
(
this
"
webnavigation
-
create
"
)
;
}
Services
.
obs
.
removeObserver
(
this
"
webnavigation
-
destroy
"
)
;
}
this
.
_popContext
(
)
;
for
(
let
sheetActor
of
this
.
_styleSheetActors
.
values
(
)
)
{
this
.
_tabPool
.
removeActor
(
sheetActor
)
;
}
this
.
_styleSheetActors
.
clear
(
)
;
this
.
conn
.
removeActorPool
(
this
.
_tabPool
)
;
this
.
_tabPool
=
null
;
if
(
this
.
_tabActorPool
)
{
this
.
conn
.
removeActorPool
(
this
.
_tabActorPool
)
;
this
.
_tabActorPool
=
null
;
}
if
(
this
.
_workerActorList
!
=
=
null
)
{
this
.
_workerActorList
.
onListChanged
=
null
;
this
.
_workerActorList
=
null
;
}
if
(
this
.
_workerActorPool
!
=
=
null
)
{
this
.
conn
.
removeActorPool
(
this
.
_workerActorPool
)
;
this
.
_workerActorPool
=
null
;
}
this
.
_attached
=
false
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
tabDetached
"
}
)
;
return
true
;
}
onAttach
(
request
)
{
if
(
this
.
exited
)
{
return
{
type
:
"
exited
"
}
;
}
this
.
_attach
(
)
;
return
{
type
:
"
tabAttached
"
threadActor
:
this
.
threadActor
.
actorID
cacheDisabled
:
this
.
_getCacheDisabled
(
)
javascriptEnabled
:
this
.
_getJavascriptEnabled
(
)
traits
:
this
.
traits
}
;
}
onDetach
(
request
)
{
if
(
!
this
.
_detach
(
)
)
{
return
{
error
:
"
wrongState
"
}
;
}
return
{
type
:
"
detached
"
}
;
}
onFocus
(
)
{
if
(
this
.
window
)
{
this
.
window
.
focus
(
)
;
}
return
{
}
;
}
onReload
(
request
)
{
let
force
=
request
&
&
request
.
options
&
&
request
.
options
.
force
;
Services
.
tm
.
currentThread
.
dispatch
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
Services
.
startup
.
shuttingDown
)
{
return
;
}
this
.
webNavigation
.
reload
(
force
?
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
)
;
}
"
TabActor
.
prototype
.
onReload
'
s
delayed
body
"
)
0
)
;
return
{
}
;
}
onNavigateTo
(
request
)
{
Services
.
tm
.
currentThread
.
dispatch
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
this
.
window
.
location
=
request
.
url
;
}
"
TabActor
.
prototype
.
onNavigateTo
'
s
delayed
body
"
)
0
)
;
return
{
}
;
}
onReconfigure
(
request
)
{
let
options
=
request
.
options
|
|
{
}
;
if
(
!
this
.
docShell
)
{
return
{
}
;
}
this
.
_toggleDevToolsSettings
(
options
)
;
return
{
}
;
}
_toggleDevToolsSettings
(
options
)
{
let
reload
=
false
;
if
(
typeof
options
.
javascriptEnabled
!
=
=
"
undefined
"
&
&
options
.
javascriptEnabled
!
=
=
this
.
_getJavascriptEnabled
(
)
)
{
this
.
_setJavascriptEnabled
(
options
.
javascriptEnabled
)
;
reload
=
true
;
}
if
(
typeof
options
.
cacheDisabled
!
=
=
"
undefined
"
&
&
options
.
cacheDisabled
!
=
=
this
.
_getCacheDisabled
(
)
)
{
this
.
_setCacheDisabled
(
options
.
cacheDisabled
)
;
}
if
(
(
typeof
options
.
serviceWorkersTestingEnabled
!
=
=
"
undefined
"
)
&
&
(
options
.
serviceWorkersTestingEnabled
!
=
=
this
.
_getServiceWorkersTestingEnabled
(
)
)
)
{
this
.
_setServiceWorkersTestingEnabled
(
options
.
serviceWorkersTestingEnabled
)
;
}
let
hasExplicitReloadFlag
=
"
performReload
"
in
options
;
if
(
(
hasExplicitReloadFlag
&
&
options
.
performReload
)
|
|
(
!
hasExplicitReloadFlag
&
&
reload
)
)
{
this
.
onReload
(
)
;
}
}
_restoreDocumentSettings
(
)
{
this
.
_restoreJavascript
(
)
;
this
.
_setCacheDisabled
(
false
)
;
this
.
_setServiceWorkersTestingEnabled
(
false
)
;
}
_setCacheDisabled
(
disabled
)
{
let
enable
=
Ci
.
nsIRequest
.
LOAD_NORMAL
;
let
disable
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
|
Ci
.
nsIRequest
.
INHIBIT_CACHING
;
this
.
docShell
.
defaultLoadFlags
=
disabled
?
disable
:
enable
;
}
_wasJavascriptEnabled
:
null
_setJavascriptEnabled
(
allow
)
{
if
(
this
.
_wasJavascriptEnabled
=
=
=
null
)
{
this
.
_wasJavascriptEnabled
=
this
.
docShell
.
allowJavascript
;
}
this
.
docShell
.
allowJavascript
=
allow
;
}
_restoreJavascript
(
)
{
if
(
this
.
_wasJavascriptEnabled
!
=
=
null
)
{
this
.
_setJavascriptEnabled
(
this
.
_wasJavascriptEnabled
)
;
this
.
_wasJavascriptEnabled
=
null
;
}
}
_getJavascriptEnabled
(
)
{
if
(
!
this
.
docShell
)
{
return
null
;
}
return
this
.
docShell
.
allowJavascript
;
}
_setServiceWorkersTestingEnabled
(
enabled
)
{
let
windowUtils
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
windowUtils
.
serviceWorkersTestingEnabled
=
enabled
;
}
_getCacheDisabled
(
)
{
if
(
!
this
.
docShell
)
{
return
null
;
}
let
disable
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
|
Ci
.
nsIRequest
.
INHIBIT_CACHING
;
return
this
.
docShell
.
defaultLoadFlags
=
=
=
disable
;
}
_getServiceWorkersTestingEnabled
(
)
{
if
(
!
this
.
docShell
)
{
return
null
;
}
let
windowUtils
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
return
windowUtils
.
serviceWorkersTestingEnabled
;
}
preNest
(
)
{
if
(
!
this
.
window
)
{
return
;
}
let
windowUtils
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
windowUtils
.
suppressEventHandling
(
true
)
;
windowUtils
.
suspendTimeouts
(
)
;
}
postNest
(
nestData
)
{
if
(
!
this
.
window
)
{
return
;
}
let
windowUtils
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
windowUtils
.
resumeTimeouts
(
)
;
windowUtils
.
suppressEventHandling
(
false
)
;
}
_changeTopLevelDocument
(
window
)
{
this
.
_willNavigate
(
this
.
window
window
.
location
.
href
null
true
)
;
this
.
_windowDestroyed
(
this
.
window
null
true
)
;
this
.
_setWindow
(
window
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
this
.
_windowReady
(
window
true
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
this
.
_navigate
(
window
true
)
;
}
)
;
}
)
;
}
_setWindow
(
window
)
{
let
docShell
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
Object
.
defineProperty
(
this
"
docShell
"
{
value
:
docShell
enumerable
:
true
configurable
:
true
}
)
;
events
.
emit
(
this
"
changed
-
toplevel
-
document
"
)
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
frameUpdate
"
selected
:
this
.
outerWindowID
}
)
;
}
_windowReady
(
window
isFrameSwitching
=
false
)
{
let
isTopLevel
=
window
=
=
this
.
window
;
if
(
window
=
=
this
.
_originalWindow
&
&
!
isFrameSwitching
)
{
this
.
_updateChildDocShells
(
)
;
}
events
.
emit
(
this
"
window
-
ready
"
{
window
:
window
isTopLevel
:
isTopLevel
id
:
getWindowID
(
window
)
}
)
;
let
threadActor
=
this
.
threadActor
;
if
(
isTopLevel
&
&
threadActor
.
state
!
=
"
detached
"
)
{
this
.
sources
.
reset
(
{
sourceMaps
:
true
}
)
;
threadActor
.
clearDebuggees
(
)
;
threadActor
.
dbg
.
enabled
=
true
;
threadActor
.
maybePauseOnExceptions
(
)
;
threadActor
.
global
=
window
;
}
if
(
threadActor
.
attached
)
{
threadActor
.
dbg
.
addDebuggees
(
)
;
}
}
_windowDestroyed
(
window
id
=
null
isFrozen
=
false
)
{
events
.
emit
(
this
"
window
-
destroyed
"
{
window
:
window
isTopLevel
:
window
=
=
this
.
window
id
:
id
|
|
getWindowID
(
window
)
isFrozen
:
isFrozen
}
)
;
}
_willNavigate
(
window
newURI
request
isFrameSwitching
=
false
)
{
let
isTopLevel
=
window
=
=
this
.
window
;
let
reset
=
false
;
if
(
window
=
=
this
.
_originalWindow
&
&
!
isFrameSwitching
)
{
this
.
_notifyDocShellDestroyAll
(
)
;
if
(
this
.
window
!
=
this
.
_originalWindow
)
{
reset
=
true
;
window
=
this
.
window
;
isTopLevel
=
true
;
}
}
events
.
emit
(
this
"
will
-
navigate
"
{
window
:
window
isTopLevel
:
isTopLevel
newURI
:
newURI
request
:
request
}
)
;
if
(
!
isTopLevel
)
{
return
;
}
let
threadActor
=
this
.
threadActor
;
if
(
threadActor
.
state
=
=
"
paused
"
)
{
this
.
conn
.
send
(
threadActor
.
unsafeSynchronize
(
Promise
.
resolve
(
threadActor
.
onResume
(
)
)
)
)
;
threadActor
.
dbg
.
enabled
=
false
;
}
threadActor
.
disableAllBreakpoints
(
)
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
tabNavigated
"
url
:
newURI
nativeConsoleAPI
:
true
state
:
"
start
"
isFrameSwitching
:
isFrameSwitching
}
)
;
if
(
reset
)
{
this
.
_setWindow
(
this
.
_originalWindow
)
;
}
}
_navigate
(
window
isFrameSwitching
=
false
)
{
let
isTopLevel
=
window
=
=
this
.
window
;
events
.
emit
(
this
"
navigate
"
{
window
:
window
isTopLevel
:
isTopLevel
}
)
;
if
(
!
isTopLevel
)
{
return
;
}
let
threadActor
=
this
.
threadActor
;
if
(
threadActor
.
state
=
=
"
running
"
)
{
threadActor
.
dbg
.
enabled
=
true
;
}
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
tabNavigated
"
url
:
this
.
url
title
:
this
.
title
nativeConsoleAPI
:
this
.
hasNativeConsoleAPI
(
this
.
window
)
state
:
"
stop
"
isFrameSwitching
:
isFrameSwitching
}
)
;
}
hasNativeConsoleAPI
(
window
)
{
let
isNative
=
false
;
try
{
let
console
=
window
.
wrappedJSObject
.
console
;
isNative
=
new
XPCNativeWrapper
(
console
)
.
IS_NATIVE_CONSOLE
;
}
catch
(
ex
)
{
}
return
isNative
;
}
createStyleSheetActor
(
styleSheet
)
{
if
(
this
.
_styleSheetActors
.
has
(
styleSheet
)
)
{
return
this
.
_styleSheetActors
.
get
(
styleSheet
)
;
}
let
actor
=
new
StyleSheetActor
(
styleSheet
this
)
;
this
.
_styleSheetActors
.
set
(
styleSheet
actor
)
;
this
.
_tabPool
.
addActor
(
actor
)
;
events
.
emit
(
this
"
stylesheet
-
added
"
actor
)
;
return
actor
;
}
removeActorByName
(
name
)
{
if
(
name
in
this
.
_extraActors
)
{
const
actor
=
this
.
_extraActors
[
name
]
;
if
(
this
.
_tabActorPool
.
has
(
actor
)
)
{
this
.
_tabActorPool
.
removeActor
(
actor
)
;
}
delete
this
.
_extraActors
[
name
]
;
}
}
onResolveLocation
(
request
)
{
let
{
url
line
}
=
request
;
let
column
=
request
.
column
|
|
0
;
const
scripts
=
this
.
threadActor
.
dbg
.
findScripts
(
{
url
}
)
;
if
(
!
scripts
[
0
]
|
|
!
scripts
[
0
]
.
source
)
{
return
promise
.
resolve
(
{
from
:
this
.
actorID
type
:
"
resolveLocation
"
error
:
"
SOURCE_NOT_FOUND
"
}
)
;
}
const
source
=
scripts
[
0
]
.
source
;
const
generatedActor
=
this
.
sources
.
createNonSourceMappedActor
(
source
)
;
let
generatedLocation
=
new
GeneratedLocation
(
generatedActor
line
column
)
;
return
this
.
sources
.
getOriginalLocation
(
generatedLocation
)
.
then
(
loc
=
>
{
if
(
loc
.
originalLine
=
=
null
)
{
return
{
type
:
"
resolveLocation
"
error
:
"
MAP_NOT_FOUND
"
}
;
}
loc
=
loc
.
toJSON
(
)
;
return
{
from
:
this
.
actorID
url
:
loc
.
source
.
url
column
:
loc
.
column
line
:
loc
.
line
}
;
}
)
;
}
}
;
TabActor
.
prototype
.
requestTypes
=
{
"
attach
"
:
TabActor
.
prototype
.
onAttach
"
detach
"
:
TabActor
.
prototype
.
onDetach
"
focus
"
:
TabActor
.
prototype
.
onFocus
"
reload
"
:
TabActor
.
prototype
.
onReload
"
navigateTo
"
:
TabActor
.
prototype
.
onNavigateTo
"
reconfigure
"
:
TabActor
.
prototype
.
onReconfigure
"
switchToFrame
"
:
TabActor
.
prototype
.
onSwitchToFrame
"
listFrames
"
:
TabActor
.
prototype
.
onListFrames
"
listWorkers
"
:
TabActor
.
prototype
.
onListWorkers
"
resolveLocation
"
:
TabActor
.
prototype
.
onResolveLocation
}
;
exports
.
TabActor
=
TabActor
;
function
BrowserTabActor
(
connection
browser
)
{
this
.
_conn
=
connection
;
this
.
_browser
=
browser
;
this
.
_form
=
null
;
}
BrowserTabActor
.
prototype
=
{
connect
(
)
{
let
onDestroy
=
(
)
=
>
{
this
.
_form
=
null
;
}
;
let
connect
=
DebuggerServer
.
connectToChild
(
this
.
_conn
this
.
_browser
onDestroy
)
;
return
connect
.
then
(
form
=
>
{
this
.
_form
=
form
;
return
this
;
}
)
;
}
get
_tabbrowser
(
)
{
if
(
typeof
this
.
_browser
.
getTabBrowser
=
=
"
function
"
)
{
return
this
.
_browser
.
getTabBrowser
(
)
;
}
return
null
;
}
get
_mm
(
)
{
return
this
.
_browser
.
messageManager
|
|
this
.
_browser
.
frameLoader
.
messageManager
;
}
update
(
)
{
if
(
this
.
_form
)
{
let
deferred
=
promise
.
defer
(
)
;
let
onFormUpdate
=
msg
=
>
{
if
(
this
.
_form
.
actor
!
=
msg
.
json
.
actor
)
{
return
;
}
this
.
_mm
.
removeMessageListener
(
"
debug
:
form
"
onFormUpdate
)
;
this
.
_form
=
msg
.
json
;
deferred
.
resolve
(
this
)
;
}
;
this
.
_mm
.
addMessageListener
(
"
debug
:
form
"
onFormUpdate
)
;
this
.
_mm
.
sendAsyncMessage
(
"
debug
:
form
"
)
;
return
deferred
.
promise
;
}
return
this
.
connect
(
)
;
}
get
title
(
)
{
if
(
this
.
_browser
.
__SS_restore
)
{
let
sessionStore
=
this
.
_browser
.
__SS_data
;
let
entry
=
sessionStore
.
entries
[
sessionStore
.
index
-
1
]
;
return
entry
.
title
;
}
if
(
this
.
_tabbrowser
)
{
let
tab
=
this
.
_tabbrowser
.
getTabForBrowser
(
this
.
_browser
)
;
if
(
tab
)
{
return
tab
.
label
;
}
}
return
"
"
;
}
get
url
(
)
{
if
(
this
.
_browser
.
__SS_restore
)
{
let
sessionStore
=
this
.
_browser
.
__SS_data
;
let
entry
=
sessionStore
.
entries
[
sessionStore
.
index
-
1
]
;
return
entry
.
url
;
}
return
null
;
}
form
(
)
{
let
form
=
Object
.
assign
(
{
}
this
.
_form
)
;
if
(
!
form
.
title
)
{
form
.
title
=
this
.
title
;
}
if
(
!
form
.
url
)
{
form
.
url
=
this
.
url
;
}
return
form
;
}
exit
(
)
{
this
.
_browser
=
null
;
}
}
;
exports
.
BrowserTabActor
=
BrowserTabActor
;
function
BrowserAddonList
(
connection
)
{
this
.
_connection
=
connection
;
this
.
_actorByAddonId
=
new
Map
(
)
;
this
.
_onListChanged
=
null
;
}
BrowserAddonList
.
prototype
.
getList
=
function
(
)
{
let
deferred
=
promise
.
defer
(
)
;
AddonManager
.
getAllAddons
(
(
addons
)
=
>
{
for
(
let
addon
of
addons
)
{
let
actor
=
this
.
_actorByAddonId
.
get
(
addon
.
id
)
;
if
(
!
actor
)
{
if
(
addon
.
isWebExtension
)
{
actor
=
new
WebExtensionActor
(
this
.
_connection
addon
)
;
}
else
{
actor
=
new
BrowserAddonActor
(
this
.
_connection
addon
)
;
}
this
.
_actorByAddonId
.
set
(
addon
.
id
actor
)
;
}
}
deferred
.
resolve
(
[
.
.
.
this
.
_actorByAddonId
]
.
map
(
(
[
_
actor
]
)
=
>
actor
)
)
;
}
)
;
return
deferred
.
promise
;
}
;
Object
.
defineProperty
(
BrowserAddonList
.
prototype
"
onListChanged
"
{
enumerable
:
true
configurable
:
true
get
(
)
{
return
this
.
_onListChanged
;
}
set
(
v
)
{
if
(
v
!
=
=
null
&
&
typeof
v
!
=
"
function
"
)
{
throw
new
Error
(
"
onListChanged
property
may
only
be
set
to
'
null
'
or
a
function
"
)
;
}
this
.
_onListChanged
=
v
;
this
.
_adjustListener
(
)
;
}
}
)
;
BrowserAddonList
.
prototype
.
onInstalled
=
function
(
addon
)
{
this
.
_notifyListChanged
(
)
;
this
.
_adjustListener
(
)
;
}
;
BrowserAddonList
.
prototype
.
onUninstalled
=
function
(
addon
)
{
this
.
_actorByAddonId
.
delete
(
addon
.
id
)
;
this
.
_notifyListChanged
(
)
;
this
.
_adjustListener
(
)
;
}
;
BrowserAddonList
.
prototype
.
_notifyListChanged
=
function
(
)
{
if
(
this
.
_onListChanged
)
{
this
.
_onListChanged
(
)
;
}
}
;
BrowserAddonList
.
prototype
.
_adjustListener
=
function
(
)
{
if
(
this
.
_onListChanged
)
{
AddonManager
.
addAddonListener
(
this
)
;
}
else
if
(
this
.
_actorByAddonId
.
size
=
=
=
0
)
{
AddonManager
.
removeAddonListener
(
this
)
;
}
}
;
exports
.
BrowserAddonList
=
BrowserAddonList
;
function
DebuggerProgressListener
(
tabActor
)
{
this
.
_tabActor
=
tabActor
;
this
.
_onWindowCreated
=
this
.
onWindowCreated
.
bind
(
this
)
;
this
.
_onWindowHidden
=
this
.
onWindowHidden
.
bind
(
this
)
;
Services
.
obs
.
addObserver
(
this
"
inner
-
window
-
destroyed
"
false
)
;
this
.
_knownWindowIDs
=
new
Map
(
)
;
this
.
_watchedDocShells
=
new
WeakSet
(
)
;
}
DebuggerProgressListener
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
Ci
.
nsISupports
]
)
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
"
inner
-
window
-
destroyed
"
false
)
;
this
.
_knownWindowIDs
.
clear
(
)
;
this
.
_knownWindowIDs
=
null
;
}
watch
(
docShell
)
{
let
docShellWindow
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
this
.
_watchedDocShells
.
add
(
docShellWindow
)
;
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATUS
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
let
handler
=
getDocShellChromeEventHandler
(
docShell
)
;
handler
.
addEventListener
(
"
DOMWindowCreated
"
this
.
_onWindowCreated
true
)
;
handler
.
addEventListener
(
"
pageshow
"
this
.
_onWindowCreated
true
)
;
handler
.
addEventListener
(
"
pagehide
"
this
.
_onWindowHidden
true
)
;
for
(
let
win
of
this
.
_getWindowsInDocShell
(
docShell
)
)
{
this
.
_tabActor
.
_windowReady
(
win
)
;
this
.
_knownWindowIDs
.
set
(
getWindowID
(
win
)
win
)
;
}
}
unwatch
(
docShell
)
{
let
docShellWindow
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
if
(
!
this
.
_watchedDocShells
.
has
(
docShellWindow
)
)
{
return
;
}
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
try
{
webProgress
.
removeProgressListener
(
this
)
;
}
catch
(
e
)
{
}
let
handler
=
getDocShellChromeEventHandler
(
docShell
)
;
handler
.
removeEventListener
(
"
DOMWindowCreated
"
this
.
_onWindowCreated
true
)
;
handler
.
removeEventListener
(
"
pageshow
"
this
.
_onWindowCreated
true
)
;
handler
.
removeEventListener
(
"
pagehide
"
this
.
_onWindowHidden
true
)
;
for
(
let
win
of
this
.
_getWindowsInDocShell
(
docShell
)
)
{
this
.
_knownWindowIDs
.
delete
(
getWindowID
(
win
)
)
;
}
}
_getWindowsInDocShell
(
docShell
)
{
return
getChildDocShells
(
docShell
)
.
map
(
d
=
>
{
return
d
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
)
;
}
onWindowCreated
:
DevToolsUtils
.
makeInfallible
(
function
(
evt
)
{
if
(
!
this
.
_tabActor
.
attached
)
{
return
;
}
if
(
evt
.
type
=
=
"
pageshow
"
&
&
!
evt
.
persisted
)
{
return
;
}
let
window
=
evt
.
target
.
defaultView
;
this
.
_tabActor
.
_windowReady
(
window
)
;
if
(
evt
.
type
!
=
=
"
pageshow
"
)
{
this
.
_knownWindowIDs
.
set
(
getWindowID
(
window
)
window
)
;
}
}
"
DebuggerProgressListener
.
prototype
.
onWindowCreated
"
)
onWindowHidden
:
DevToolsUtils
.
makeInfallible
(
function
(
evt
)
{
if
(
!
this
.
_tabActor
.
attached
)
{
return
;
}
if
(
!
evt
.
persisted
)
{
return
;
}
let
window
=
evt
.
target
.
defaultView
;
this
.
_tabActor
.
_windowDestroyed
(
window
null
true
)
;
}
"
DebuggerProgressListener
.
prototype
.
onWindowHidden
"
)
observe
:
DevToolsUtils
.
makeInfallible
(
function
(
subject
topic
)
{
if
(
!
this
.
_tabActor
.
attached
)
{
return
;
}
let
innerID
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
;
let
window
=
this
.
_knownWindowIDs
.
get
(
innerID
)
;
if
(
window
)
{
this
.
_knownWindowIDs
.
delete
(
innerID
)
;
this
.
_tabActor
.
_windowDestroyed
(
window
innerID
)
;
}
}
"
DebuggerProgressListener
.
prototype
.
observe
"
)
onStateChange
:
DevToolsUtils
.
makeInfallible
(
function
(
progress
request
flag
status
)
{
if
(
!
this
.
_tabActor
.
attached
)
{
return
;
}
let
isStart
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_START
;
let
isStop
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
;
let
isDocument
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_IS_DOCUMENT
;
let
isWindow
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
;
if
(
isDocument
&
&
isStop
)
{
progress
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
this
.
_tabActor
.
_notifyDocShellsUpdate
(
[
progress
]
)
;
}
let
window
=
progress
.
DOMWindow
;
if
(
isDocument
&
&
isStart
)
{
let
newURI
=
request
instanceof
Ci
.
nsIChannel
?
request
.
URI
.
spec
:
null
;
this
.
_tabActor
.
_willNavigate
(
window
newURI
request
)
;
}
if
(
isWindow
&
&
isStop
)
{
if
(
request
.
status
!
=
Cr
.
NS_OK
)
{
let
handler
=
getDocShellChromeEventHandler
(
progress
)
;
let
onLoad
=
evt
=
>
{
if
(
evt
.
target
=
=
window
.
document
)
{
handler
.
removeEventListener
(
"
DOMContentLoaded
"
onLoad
true
)
;
this
.
_tabActor
.
_navigate
(
window
)
;
}
}
;
handler
.
addEventListener
(
"
DOMContentLoaded
"
onLoad
true
)
;
}
else
{
this
.
_tabActor
.
_navigate
(
window
)
;
}
}
}
"
DebuggerProgressListener
.
prototype
.
onStateChange
"
)
}
;
exports
.
register
=
function
(
handle
)
{
handle
.
setRootActor
(
createRootActor
)
;
}
;
exports
.
unregister
=
function
(
handle
)
{
handle
.
setRootActor
(
null
)
;
}
;
