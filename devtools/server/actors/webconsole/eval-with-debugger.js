"
use
strict
"
;
const
Debugger
=
require
(
"
Debugger
"
)
;
const
DevToolsUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
Reflect
:
"
resource
:
/
/
gre
/
modules
/
reflect
.
sys
.
mjs
"
}
)
;
loader
.
lazyRequireGetter
(
this
[
"
isCommand
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
commands
/
parser
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebConsoleCommandsManager
"
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
commands
/
manager
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
LongStringActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
string
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
eagerEcmaAllowlist
"
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
eager
-
ecma
-
allowlist
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
eagerFunctionAllowlist
"
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
eager
-
function
-
allowlist
.
js
"
)
;
function
isObject
(
value
)
{
return
Object
(
value
)
=
=
=
value
;
}
function
evalWithDebugger
(
string
options
=
{
}
webConsole
)
{
const
trimmedString
=
string
.
trim
(
)
;
if
(
trimmedString
=
=
=
"
?
"
)
{
return
evalWithDebugger
(
"
:
help
"
options
webConsole
)
;
}
const
isCmd
=
isCommand
(
trimmedString
)
;
if
(
isCmd
&
&
options
.
eager
)
{
return
{
result
:
null
}
;
}
const
{
frame
dbg
}
=
getFrameDbg
(
options
webConsole
)
;
const
{
dbgGlobal
bindSelf
}
=
getDbgGlobal
(
options
dbg
webConsole
)
;
if
(
isCmd
)
{
try
{
return
WebConsoleCommandsManager
.
executeCommand
(
webConsole
dbgGlobal
options
.
selectedNodeActor
string
)
;
}
catch
(
e
)
{
return
{
helperResult
:
{
type
:
"
exception
"
message
:
e
.
message
}
}
;
}
}
const
helpers
=
WebConsoleCommandsManager
.
getWebConsoleCommands
(
webConsole
dbgGlobal
frame
string
options
.
selectedNodeActor
!
!
options
.
disableBreaks
)
;
let
{
bindings
}
=
helpers
;
if
(
trimmedString
=
=
=
"
help
"
&
&
bindings
.
help
)
{
return
evalWithDebugger
(
"
:
help
"
options
webConsole
)
;
}
if
(
bindSelf
)
{
bindings
.
_self
=
bindSelf
;
}
if
(
options
.
bindings
)
{
bindings
=
{
.
.
.
bindings
.
.
.
options
.
bindings
}
;
}
const
evalOptions
=
{
}
;
const
urlOption
=
options
.
url
|
|
(
options
.
eager
?
"
debugger
eager
eval
code
"
:
null
)
;
if
(
typeof
urlOption
=
=
=
"
string
"
)
{
evalOptions
.
url
=
urlOption
;
}
if
(
typeof
options
.
lineNumber
=
=
=
"
number
"
)
{
evalOptions
.
lineNumber
=
options
.
lineNumber
;
}
if
(
options
.
disableBreaks
)
{
evalOptions
.
hideFromDebugger
=
true
;
evalOptions
.
useInnerBindings
=
true
;
}
updateConsoleInputEvaluation
(
dbg
webConsole
)
;
const
evalString
=
getEvalInput
(
string
bindings
)
;
const
result
=
getEvalResult
(
dbg
evalString
evalOptions
bindings
frame
dbgGlobal
options
.
eager
)
;
if
(
!
frame
&
&
result
&
&
"
throw
"
in
result
)
{
forceLexicalInitForVariableDeclarationsInThrowingExpression
(
dbgGlobal
string
)
;
}
return
{
result
helperResult
:
helpers
.
getHelperResult
(
)
dbg
frame
dbgGlobal
}
;
}
exports
.
evalWithDebugger
=
evalWithDebugger
;
function
getEvalResult
(
dbg
string
evalOptions
bindings
frame
dbgGlobal
eager
)
{
let
noSideEffectDebugger
=
null
;
if
(
eager
)
{
noSideEffectDebugger
=
makeSideeffectFreeDebugger
(
dbg
)
;
if
(
frame
)
{
frame
=
noSideEffectDebugger
.
adoptFrame
(
frame
)
;
}
else
{
dbgGlobal
=
noSideEffectDebugger
.
adoptDebuggeeValue
(
dbgGlobal
)
;
}
if
(
bindings
)
{
bindings
=
Object
.
keys
(
bindings
)
.
reduce
(
(
acc
key
)
=
>
{
acc
[
key
]
=
noSideEffectDebugger
.
adoptDebuggeeValue
(
bindings
[
key
]
)
;
return
acc
;
}
{
}
)
;
}
}
try
{
let
result
;
if
(
frame
)
{
result
=
frame
.
evalWithBindings
(
string
bindings
evalOptions
)
;
}
else
{
result
=
dbgGlobal
.
executeInGlobalWithBindings
(
string
bindings
evalOptions
)
;
}
if
(
noSideEffectDebugger
&
&
result
)
{
if
(
"
return
"
in
result
)
{
result
.
return
=
dbg
.
adoptDebuggeeValue
(
result
.
return
)
;
}
if
(
"
throw
"
in
result
)
{
result
.
throw
=
dbg
.
adoptDebuggeeValue
(
result
.
throw
)
;
}
}
return
result
;
}
finally
{
if
(
noSideEffectDebugger
)
{
noSideEffectDebugger
.
removeAllDebuggees
(
)
;
noSideEffectDebugger
.
onNativeCall
=
undefined
;
}
}
}
function
forceLexicalInitForVariableDeclarationsInThrowingExpression
(
dbgGlobal
string
)
{
if
(
isWorker
)
{
return
;
}
let
ast
;
try
{
ast
=
lazy
.
Reflect
.
parse
(
string
)
;
}
catch
(
e
)
{
return
;
}
try
{
for
(
const
line
of
ast
.
body
)
{
if
(
!
(
line
.
kind
=
=
"
let
"
|
|
line
.
kind
=
=
"
const
"
)
)
{
continue
;
}
const
identifiers
=
[
]
;
for
(
const
decl
of
line
.
declarations
)
{
switch
(
decl
.
id
.
type
)
{
case
"
Identifier
"
:
identifiers
.
push
(
decl
.
id
.
name
)
;
break
;
case
"
ArrayPattern
"
:
for
(
const
e
of
decl
.
id
.
elements
)
{
if
(
e
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
e
.
name
)
;
}
else
if
(
e
.
type
=
=
"
AssignmentExpression
"
)
{
identifiers
.
push
(
e
.
left
.
name
)
;
}
}
break
;
case
"
ObjectPattern
"
:
for
(
const
prop
of
decl
.
id
.
properties
)
{
if
(
prop
.
key
?
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
prop
.
key
.
name
)
;
}
if
(
prop
.
value
?
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
prop
.
value
.
name
)
;
}
else
if
(
prop
.
value
?
.
type
=
=
"
AssignmentExpression
"
)
{
identifiers
.
push
(
prop
.
value
.
left
.
name
)
;
}
else
if
(
prop
.
type
=
=
=
"
SpreadExpression
"
)
{
identifiers
.
push
(
prop
.
expression
.
name
)
;
}
}
break
;
}
}
for
(
const
name
of
identifiers
)
{
dbgGlobal
.
forceLexicalInitializationByName
(
name
)
;
}
}
}
catch
(
ex
)
{
console
.
error
(
"
Error
in
forceLexicalInitForVariableDeclarationsInThrowingExpression
:
"
ex
)
;
}
}
function
makeSideeffectFreeDebugger
(
targetActorDbg
)
{
ensureSideEffectFreeNatives
(
)
;
const
dbg
=
new
Debugger
(
)
;
for
(
const
global
of
targetActorDbg
.
findDebuggees
(
)
)
{
try
{
dbg
.
addDebuggee
(
global
)
;
}
catch
(
e
)
{
if
(
!
e
.
message
.
includes
(
"
debugger
and
debuggee
must
be
in
different
compartments
"
)
)
{
throw
e
;
}
}
}
const
timeoutDuration
=
100
;
const
endTime
=
Date
.
now
(
)
+
timeoutDuration
;
let
count
=
0
;
function
shouldCancel
(
)
{
return
+
+
count
%
100
=
=
=
0
&
&
Date
.
now
(
)
>
endTime
;
}
const
executedScripts
=
new
Set
(
)
;
const
handler
=
{
hit
:
(
)
=
>
null
}
;
dbg
.
onEnterFrame
=
frame
=
>
{
if
(
shouldCancel
(
)
)
{
return
null
;
}
frame
.
onStep
=
(
)
=
>
{
if
(
shouldCancel
(
)
)
{
return
null
;
}
return
undefined
;
}
;
const
script
=
frame
.
script
;
if
(
executedScripts
.
has
(
script
)
)
{
return
undefined
;
}
executedScripts
.
add
(
script
)
;
const
offsets
=
script
.
getEffectfulOffsets
(
)
;
for
(
const
offset
of
offsets
)
{
script
.
setBreakpoint
(
offset
handler
)
;
}
return
undefined
;
}
;
const
{
SIDE_EFFECT_FREE
}
=
WebConsoleCommandsManager
;
dbg
.
onNativeCall
=
(
callee
reason
)
=
>
{
try
{
if
(
(
reason
=
=
"
get
"
|
|
reason
=
=
"
call
"
)
&
&
nativeIsEagerlyEvaluateable
(
callee
)
)
{
return
undefined
;
}
}
catch
(
err
)
{
DevToolsUtils
.
reportException
(
"
evalWithDebugger
onNativeCall
"
new
Error
(
"
Unable
to
validate
native
function
against
allowlist
"
)
)
;
}
if
(
reason
=
=
"
call
"
&
&
callee
.
unsafeDereference
(
)
.
isSideEffectFree
=
=
=
SIDE_EFFECT_FREE
)
{
return
undefined
;
}
return
null
;
}
;
return
dbg
;
}
let
gSideEffectFreeNatives
;
function
ensureSideEffectFreeNatives
(
)
{
if
(
gSideEffectFreeNatives
)
{
return
;
}
const
{
natives
:
domNatives
}
=
eagerFunctionAllowlist
;
const
natives
=
[
.
.
.
eagerEcmaAllowlist
.
functions
.
.
.
eagerEcmaAllowlist
.
getters
.
.
.
domNatives
]
;
const
map
=
new
Map
(
)
;
for
(
const
n
of
natives
)
{
if
(
!
map
.
has
(
n
.
name
)
)
{
map
.
set
(
n
.
name
[
]
)
;
}
map
.
get
(
n
.
name
)
.
push
(
n
)
;
}
gSideEffectFreeNatives
=
map
;
}
function
nativeIsEagerlyEvaluateable
(
fn
)
{
if
(
fn
.
isBoundFunction
)
{
fn
=
fn
.
boundTargetFunction
;
}
if
(
fn
.
isNativeGetterWithJitInfo
(
)
)
{
return
true
;
}
switch
(
fn
.
name
)
{
case
"
toString
"
:
case
"
toLocaleString
"
:
case
"
valueOf
"
:
return
true
;
}
const
natives
=
gSideEffectFreeNatives
.
get
(
fn
.
name
)
;
return
natives
&
&
natives
.
some
(
n
=
>
fn
.
isSameNative
(
n
)
)
;
}
function
updateConsoleInputEvaluation
(
dbg
webConsole
)
{
if
(
webConsole
.
_lastConsoleInputEvaluation
)
{
webConsole
.
_lastConsoleInputEvaluation
=
dbg
.
adoptDebuggeeValue
(
webConsole
.
_lastConsoleInputEvaluation
)
;
}
}
function
getEvalInput
(
string
bindings
)
{
const
trimmedString
=
string
.
trim
(
)
;
if
(
trimmedString
=
=
"
console
.
mihai
(
)
"
|
|
trimmedString
=
=
"
console
.
mihai
(
)
;
"
)
{
return
'
"
http
:
/
/
incompleteness
.
me
/
blog
/
2015
/
02
/
09
/
console
-
dot
-
mihai
/
"
'
;
}
return
string
;
}
function
getFrameDbg
(
options
webConsole
)
{
if
(
!
options
.
frameActor
)
{
return
{
frame
:
null
dbg
:
webConsole
.
dbg
}
;
}
const
frameActor
=
webConsole
.
conn
.
getActor
(
options
.
frameActor
)
;
if
(
frameActor
)
{
return
{
frame
:
frameActor
.
frame
dbg
:
frameActor
.
threadActor
.
dbg
}
;
}
return
DevToolsUtils
.
reportException
(
"
evalWithDebugger
"
Error
(
"
The
frame
actor
was
not
found
:
"
+
options
.
frameActor
)
)
;
}
function
getDbgGlobal
(
options
dbg
webConsole
)
{
let
evalGlobal
=
webConsole
.
evalGlobal
;
if
(
options
.
innerWindowID
)
{
const
window
=
Services
.
wm
.
getCurrentInnerWindowWithId
(
options
.
innerWindowID
)
;
if
(
window
)
{
evalGlobal
=
window
;
}
}
const
dbgGlobal
=
dbg
.
makeGlobalObjectReference
(
evalGlobal
)
;
if
(
!
options
.
selectedObjectActor
)
{
return
{
bindSelf
:
null
dbgGlobal
}
;
}
const
actor
=
webConsole
.
getActorByID
(
options
.
selectedObjectActor
)
|
|
webConsole
.
parentActor
.
getActorByID
(
options
.
selectedObjectActor
)
;
if
(
!
actor
)
{
return
{
bindSelf
:
null
dbgGlobal
}
;
}
const
jsVal
=
actor
instanceof
LongStringActor
?
actor
.
str
:
actor
.
rawValue
(
)
;
if
(
!
isObject
(
jsVal
)
)
{
return
{
bindSelf
:
jsVal
dbgGlobal
}
;
}
const
bindSelf
=
dbgGlobal
.
makeDebuggeeValue
(
jsVal
)
;
return
{
bindSelf
dbgGlobal
}
;
}
