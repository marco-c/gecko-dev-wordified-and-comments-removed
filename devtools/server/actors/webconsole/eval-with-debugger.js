"
use
strict
"
;
const
Debugger
=
require
(
"
Debugger
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
loader
.
lazyRequireGetter
(
this
"
Reflect
"
"
resource
:
/
/
gre
/
modules
/
reflect
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
formatCommand
"
"
devtools
/
server
/
actors
/
webconsole
/
commands
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isCommand
"
"
devtools
/
server
/
actors
/
webconsole
/
commands
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebConsoleCommands
"
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
LongStringActor
"
"
devtools
/
server
/
actors
/
string
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
eagerEcmaWhitelist
"
"
devtools
/
server
/
actors
/
webconsole
/
eager
-
ecma
-
whitelist
"
)
;
loader
.
lazyRequireGetter
(
this
"
eagerFunctionWhitelist
"
"
devtools
/
server
/
actors
/
webconsole
/
eager
-
function
-
whitelist
"
)
;
function
isObject
(
value
)
{
return
Object
(
value
)
=
=
=
value
;
}
exports
.
evalWithDebugger
=
function
(
string
options
=
{
}
webConsole
)
{
const
evalString
=
getEvalInput
(
string
)
;
const
{
frame
dbg
}
=
getFrameDbg
(
options
webConsole
)
;
const
{
dbgWindow
bindSelf
}
=
getDbgWindow
(
options
dbg
webConsole
)
;
const
helpers
=
getHelpers
(
dbgWindow
options
webConsole
)
;
let
{
bindings
helperCache
}
=
bindCommands
(
isCommand
(
string
)
dbgWindow
bindSelf
frame
helpers
)
;
if
(
options
.
bindings
)
{
bindings
=
{
.
.
.
(
bindings
|
|
{
}
)
.
.
.
options
.
bindings
}
;
}
helpers
.
evalInput
=
string
;
const
evalOptions
=
{
}
;
const
urlOption
=
options
.
url
|
|
(
options
.
eager
?
"
debugger
eager
eval
code
"
:
null
)
;
if
(
typeof
urlOption
=
=
=
"
string
"
)
{
evalOptions
.
url
=
urlOption
;
}
if
(
typeof
options
.
lineNumber
=
=
=
"
number
"
)
{
evalOptions
.
lineNumber
=
options
.
lineNumber
;
}
updateConsoleInputEvaluation
(
dbg
dbgWindow
webConsole
)
;
let
noSideEffectDebugger
=
null
;
if
(
options
.
eager
)
{
noSideEffectDebugger
=
makeSideeffectFreeDebugger
(
)
;
}
let
result
;
try
{
result
=
getEvalResult
(
dbg
evalString
evalOptions
bindings
frame
dbgWindow
noSideEffectDebugger
)
;
}
finally
{
if
(
noSideEffectDebugger
)
{
noSideEffectDebugger
.
removeAllDebuggees
(
)
;
}
}
if
(
!
frame
&
&
result
&
&
"
throw
"
in
result
)
{
parseErrorOutput
(
dbgWindow
string
)
;
}
const
{
helperResult
}
=
helpers
;
delete
helpers
.
evalInput
;
delete
helpers
.
helperResult
;
delete
helpers
.
selectedNode
;
cleanupBindings
(
bindings
helperCache
)
;
return
{
result
helperResult
dbg
frame
window
:
dbgWindow
}
;
}
;
function
getEvalResult
(
dbg
string
evalOptions
bindings
frame
dbgWindow
noSideEffectDebugger
)
{
if
(
noSideEffectDebugger
)
{
frame
=
frame
?
noSideEffectDebugger
.
adoptFrame
(
frame
)
:
null
;
dbgWindow
=
noSideEffectDebugger
.
adoptDebuggeeValue
(
dbgWindow
)
;
if
(
bindings
)
{
bindings
=
Object
.
keys
(
bindings
)
.
reduce
(
(
acc
key
)
=
>
{
acc
[
key
]
=
noSideEffectDebugger
.
adoptDebuggeeValue
(
bindings
[
key
]
)
;
return
acc
;
}
{
}
)
;
}
}
let
result
;
if
(
frame
)
{
result
=
frame
.
evalWithBindings
(
string
bindings
evalOptions
)
;
}
else
{
result
=
dbgWindow
.
executeInGlobalWithBindings
(
string
bindings
evalOptions
)
;
}
if
(
noSideEffectDebugger
&
&
result
)
{
if
(
"
return
"
in
result
)
{
result
.
return
=
dbg
.
adoptDebuggeeValue
(
result
.
return
)
;
}
if
(
"
throw
"
in
result
)
{
result
.
throw
=
dbg
.
adoptDebuggeeValue
(
result
.
throw
)
;
}
}
return
result
;
}
function
parseErrorOutput
(
dbgWindow
string
)
{
if
(
isWorker
)
{
return
;
}
let
ast
;
try
{
ast
=
Reflect
.
parse
(
string
)
;
}
catch
(
ex
)
{
return
;
}
for
(
const
line
of
ast
.
body
)
{
if
(
!
(
line
.
kind
=
=
"
let
"
|
|
line
.
kind
=
=
"
const
"
)
)
{
continue
;
}
const
identifiers
=
[
]
;
for
(
const
decl
of
line
.
declarations
)
{
switch
(
decl
.
id
.
type
)
{
case
"
Identifier
"
:
identifiers
.
push
(
decl
.
id
.
name
)
;
break
;
case
"
ArrayPattern
"
:
for
(
const
e
of
decl
.
id
.
elements
)
{
if
(
e
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
e
.
name
)
;
}
else
if
(
e
.
type
=
=
"
AssignmentExpression
"
)
{
identifiers
.
push
(
e
.
left
.
name
)
;
}
}
break
;
case
"
ObjectPattern
"
:
for
(
const
prop
of
decl
.
id
.
properties
)
{
if
(
prop
.
key
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
prop
.
key
.
name
)
;
}
if
(
prop
.
value
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
prop
.
value
.
name
)
;
}
else
if
(
prop
.
value
.
type
=
=
"
AssignmentExpression
"
)
{
identifiers
.
push
(
prop
.
value
.
left
.
name
)
;
}
}
break
;
}
}
for
(
const
name
of
identifiers
)
{
dbgWindow
.
forceLexicalInitializationByName
(
name
)
;
}
}
}
function
makeSideeffectFreeDebugger
(
)
{
ensureSideEffectFreeNatives
(
)
;
const
dbg
=
new
Debugger
(
)
;
dbg
.
addAllGlobalsAsDebuggees
(
)
;
const
timeoutDuration
=
100
;
const
endTime
=
Date
.
now
(
)
+
timeoutDuration
;
let
count
=
0
;
function
shouldCancel
(
)
{
return
+
+
count
%
100
=
=
=
0
&
&
Date
.
now
(
)
>
endTime
;
}
const
executedScripts
=
new
Set
(
)
;
const
handler
=
{
hit
:
(
)
=
>
null
}
;
dbg
.
onEnterFrame
=
frame
=
>
{
if
(
shouldCancel
(
)
)
{
return
null
;
}
frame
.
onStep
=
(
)
=
>
{
if
(
shouldCancel
(
)
)
{
return
null
;
}
return
undefined
;
}
;
const
script
=
frame
.
script
;
if
(
executedScripts
.
has
(
script
)
)
{
return
undefined
;
}
executedScripts
.
add
(
script
)
;
const
offsets
=
script
.
getEffectfulOffsets
(
)
;
for
(
const
offset
of
offsets
)
{
script
.
setBreakpoint
(
offset
handler
)
;
}
return
undefined
;
}
;
dbg
.
onNativeCall
=
(
callee
reason
)
=
>
{
try
{
if
(
reason
=
=
"
get
"
|
|
(
reason
=
=
"
call
"
&
&
nativeHasNoSideEffects
(
callee
)
)
)
{
return
undefined
;
}
}
catch
(
err
)
{
DevToolsUtils
.
reportException
(
"
evalWithDebugger
onNativeCall
"
new
Error
(
"
Unable
to
validate
native
function
against
whitelist
"
)
)
;
}
return
null
;
}
;
return
dbg
;
}
let
gSideEffectFreeNatives
;
function
ensureSideEffectFreeNatives
(
)
{
if
(
gSideEffectFreeNatives
)
{
return
;
}
const
natives
=
[
.
.
.
eagerEcmaWhitelist
.
.
.
eagerFunctionWhitelist
]
;
const
map
=
new
Map
(
)
;
for
(
const
n
of
natives
)
{
if
(
!
map
.
has
(
n
.
name
)
)
{
map
.
set
(
n
.
name
[
]
)
;
}
map
.
get
(
n
.
name
)
.
push
(
n
)
;
}
gSideEffectFreeNatives
=
map
;
}
function
nativeHasNoSideEffects
(
fn
)
{
if
(
fn
.
isBoundFunction
)
{
fn
=
fn
.
boundTargetFunction
;
}
switch
(
fn
.
name
)
{
case
"
toString
"
:
case
"
toLocaleString
"
:
case
"
valueOf
"
:
return
true
;
}
const
natives
=
gSideEffectFreeNatives
.
get
(
fn
.
name
)
;
return
natives
&
&
natives
.
some
(
n
=
>
fn
.
isSameNative
(
n
)
)
;
}
function
updateConsoleInputEvaluation
(
dbg
dbgWindow
webConsole
)
{
if
(
webConsole
.
_lastConsoleInputEvaluation
)
{
webConsole
.
_lastConsoleInputEvaluation
=
dbg
.
adoptDebuggeeValue
(
webConsole
.
_lastConsoleInputEvaluation
)
;
}
}
function
getEvalInput
(
string
)
{
const
trimmedString
=
string
.
trim
(
)
;
if
(
trimmedString
=
=
=
"
help
"
|
|
trimmedString
=
=
=
"
?
"
)
{
return
"
help
(
)
"
;
}
if
(
isCommand
(
string
)
)
{
try
{
return
formatCommand
(
string
)
;
}
catch
(
e
)
{
console
.
log
(
e
)
;
return
throw
"
{
e
}
"
;
}
}
if
(
trimmedString
=
=
"
console
.
mihai
(
)
"
|
|
trimmedString
=
=
"
console
.
mihai
(
)
;
"
)
{
return
'
"
http
:
/
/
incompleteness
.
me
/
blog
/
2015
/
02
/
09
/
console
-
dot
-
mihai
/
"
'
;
}
return
string
;
}
function
getFrameDbg
(
options
webConsole
)
{
if
(
!
options
.
frameActor
)
{
return
{
frame
:
null
dbg
:
webConsole
.
dbg
}
;
}
const
frameActor
=
webConsole
.
conn
.
getActor
(
options
.
frameActor
)
;
if
(
frameActor
)
{
return
{
frame
:
frameActor
.
frame
dbg
:
frameActor
.
threadActor
.
dbg
}
;
}
return
DevToolsUtils
.
reportException
(
"
evalWithDebugger
"
Error
(
"
The
frame
actor
was
not
found
:
"
+
options
.
frameActor
)
)
;
}
function
getDbgWindow
(
options
dbg
webConsole
)
{
let
evalWindow
=
webConsole
.
evalWindow
;
if
(
options
.
innerWindowID
)
{
const
window
=
Services
.
wm
.
getCurrentInnerWindowWithId
(
options
.
innerWindowID
)
;
if
(
window
)
{
evalWindow
=
window
;
}
}
const
dbgWindow
=
dbg
.
makeGlobalObjectReference
(
evalWindow
)
;
if
(
!
options
.
selectedObjectActor
)
{
return
{
bindSelf
:
null
dbgWindow
}
;
}
const
actor
=
webConsole
.
actor
(
options
.
selectedObjectActor
)
;
if
(
!
actor
)
{
return
{
bindSelf
:
null
dbgWindow
}
;
}
const
jsVal
=
actor
instanceof
LongStringActor
?
actor
.
str
:
actor
.
rawValue
(
)
;
if
(
!
isObject
(
jsVal
)
)
{
return
{
bindSelf
:
jsVal
dbgWindow
}
;
}
const
bindSelf
=
dbgWindow
.
makeDebuggeeValue
(
jsVal
)
;
return
{
bindSelf
dbgWindow
}
;
}
function
getHelpers
(
dbgWindow
options
webConsole
)
{
const
helpers
=
webConsole
.
_getWebConsoleCommands
(
dbgWindow
)
;
if
(
options
.
selectedNodeActor
)
{
const
actor
=
webConsole
.
conn
.
getActor
(
options
.
selectedNodeActor
)
;
if
(
actor
)
{
helpers
.
selectedNode
=
actor
.
rawNode
;
}
}
return
helpers
;
}
function
cleanupBindings
(
bindings
helperCache
)
{
for
(
const
[
helperName
helper
]
of
Object
.
entries
(
helperCache
)
)
{
bindings
[
helperName
]
=
helper
;
}
if
(
bindings
.
_self
)
{
delete
bindings
.
_self
;
}
}
function
bindCommands
(
isCmd
dbgWindow
bindSelf
frame
helpers
)
{
const
bindings
=
helpers
.
sandbox
;
if
(
bindSelf
)
{
bindings
.
_self
=
bindSelf
;
}
const
availableHelpers
=
[
.
.
.
WebConsoleCommands
.
_originalCommands
.
keys
(
)
]
;
let
helpersToDisable
=
[
]
;
const
helperCache
=
{
}
;
if
(
!
isCmd
)
{
if
(
frame
)
{
const
env
=
frame
.
environment
;
if
(
env
)
{
helpersToDisable
=
availableHelpers
.
filter
(
name
=
>
!
!
env
.
find
(
name
)
)
;
}
}
else
{
helpersToDisable
=
availableHelpers
.
filter
(
name
=
>
!
!
dbgWindow
.
getOwnPropertyDescriptor
(
name
)
)
;
}
helpersToDisable
.
push
(
"
screenshot
"
)
;
}
for
(
const
helper
of
helpersToDisable
)
{
helperCache
[
helper
]
=
bindings
[
helper
]
;
delete
bindings
[
helper
]
;
}
return
{
bindings
helperCache
}
;
}
