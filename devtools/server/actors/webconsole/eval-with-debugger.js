"
use
strict
"
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
Reflect
"
"
resource
:
/
/
gre
/
modules
/
reflect
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
formatCommand
"
"
devtools
/
server
/
actors
/
webconsole
/
commands
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isCommand
"
"
devtools
/
server
/
actors
/
webconsole
/
commands
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebConsoleCommands
"
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
LongStringActor
"
"
devtools
/
server
/
actors
/
string
"
true
)
;
function
isObject
(
value
)
{
return
Object
(
value
)
=
=
=
value
;
}
exports
.
evalWithDebugger
=
function
(
string
options
=
{
}
webConsole
)
{
const
evalString
=
getEvalInput
(
string
)
;
const
{
frame
dbg
}
=
getFrameDbg
(
options
webConsole
)
;
if
(
dbg
.
replaying
)
{
if
(
options
.
eager
)
{
throw
new
Error
(
"
Eager
evaluations
are
not
supported
while
replaying
"
)
;
}
return
evalReplay
(
frame
dbg
evalString
)
;
}
const
{
dbgWindow
bindSelf
}
=
getDbgWindow
(
options
dbg
webConsole
)
;
const
helpers
=
getHelpers
(
dbgWindow
options
webConsole
)
;
let
{
bindings
helperCache
}
=
bindCommands
(
isCommand
(
string
)
dbgWindow
bindSelf
frame
helpers
)
;
if
(
options
.
bindings
)
{
bindings
=
{
.
.
.
(
bindings
|
|
{
}
)
.
.
.
options
.
bindings
}
;
}
helpers
.
evalInput
=
string
;
const
evalOptions
=
{
}
;
if
(
typeof
options
.
url
=
=
=
"
string
"
)
{
evalOptions
.
url
=
options
.
url
;
}
if
(
typeof
options
.
lineNumber
=
=
=
"
number
"
)
{
evalOptions
.
lineNumber
=
options
.
lineNumber
;
}
updateConsoleInputEvaluation
(
dbg
dbgWindow
webConsole
)
;
let
sideEffectData
=
null
;
if
(
options
.
eager
)
{
sideEffectData
=
preventSideEffects
(
dbg
)
;
}
const
result
=
getEvalResult
(
evalString
evalOptions
bindings
frame
dbgWindow
)
;
if
(
options
.
eager
)
{
allowSideEffects
(
dbg
sideEffectData
)
;
}
if
(
!
frame
&
&
result
&
&
"
throw
"
in
result
)
{
parseErrorOutput
(
dbgWindow
string
)
;
}
const
{
helperResult
}
=
helpers
;
delete
helpers
.
evalInput
;
delete
helpers
.
helperResult
;
delete
helpers
.
selectedNode
;
cleanupBindings
(
bindings
helperCache
)
;
return
{
result
helperResult
dbg
frame
window
:
dbgWindow
}
;
}
;
function
getEvalResult
(
string
evalOptions
bindings
frame
dbgWindow
)
{
if
(
frame
)
{
return
frame
.
evalWithBindings
(
string
bindings
evalOptions
)
;
}
return
dbgWindow
.
executeInGlobalWithBindings
(
string
bindings
evalOptions
)
;
}
function
parseErrorOutput
(
dbgWindow
string
)
{
if
(
isWorker
)
{
return
;
}
let
ast
;
try
{
ast
=
Reflect
.
parse
(
string
)
;
}
catch
(
ex
)
{
return
;
}
for
(
const
line
of
ast
.
body
)
{
if
(
!
(
line
.
kind
=
=
"
let
"
|
|
line
.
kind
=
=
"
const
"
)
)
{
continue
;
}
const
identifiers
=
[
]
;
for
(
const
decl
of
line
.
declarations
)
{
switch
(
decl
.
id
.
type
)
{
case
"
Identifier
"
:
identifiers
.
push
(
decl
.
id
.
name
)
;
break
;
case
"
ArrayPattern
"
:
for
(
const
e
of
decl
.
id
.
elements
)
{
if
(
e
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
e
.
name
)
;
}
else
if
(
e
.
type
=
=
"
AssignmentExpression
"
)
{
identifiers
.
push
(
e
.
left
.
name
)
;
}
}
break
;
case
"
ObjectPattern
"
:
for
(
const
prop
of
decl
.
id
.
properties
)
{
if
(
prop
.
key
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
prop
.
key
.
name
)
;
}
if
(
prop
.
value
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
prop
.
value
.
name
)
;
}
else
if
(
prop
.
value
.
type
=
=
"
AssignmentExpression
"
)
{
identifiers
.
push
(
prop
.
value
.
left
.
name
)
;
}
}
break
;
}
}
for
(
const
name
of
identifiers
)
{
dbgWindow
.
forceLexicalInitializationByName
(
name
)
;
}
}
}
function
preventSideEffects
(
dbg
)
{
if
(
dbg
.
onEnterFrame
|
|
dbg
.
onNativeCall
)
{
throw
new
Error
(
"
Debugger
has
hook
installed
"
)
;
}
const
data
=
{
executedScripts
:
new
Set
(
)
debuggees
:
dbg
.
getDebuggees
(
)
handler
:
{
hit
:
(
)
=
>
null
}
}
;
const
timeoutDuration
=
100
;
const
endTime
=
Date
.
now
(
)
+
timeoutDuration
;
let
count
=
0
;
function
shouldCancel
(
)
{
return
+
+
count
%
100
=
=
=
0
&
&
Date
.
now
(
)
>
endTime
;
}
dbg
.
onEnterFrame
=
frame
=
>
{
if
(
shouldCancel
(
)
)
{
return
null
;
}
frame
.
onStep
=
(
)
=
>
{
if
(
shouldCancel
(
)
)
{
return
null
;
}
return
undefined
;
}
;
const
script
=
frame
.
script
;
if
(
data
.
executedScripts
.
has
(
script
)
)
{
return
undefined
;
}
data
.
executedScripts
.
add
(
script
)
;
const
offsets
=
script
.
getEffectfulOffsets
(
)
;
for
(
const
offset
of
offsets
)
{
script
.
setBreakpoint
(
offset
data
.
handler
)
;
}
return
undefined
;
}
;
dbg
.
onNativeCall
=
(
callee
reason
)
=
>
{
if
(
reason
=
=
"
get
"
|
|
(
reason
=
=
"
call
"
&
&
nativeHasNoSideEffects
(
callee
)
)
)
{
return
undefined
;
}
return
null
;
}
;
return
data
;
}
function
allowSideEffects
(
dbg
data
)
{
for
(
const
script
of
data
.
executedScripts
)
{
script
.
clearBreakpoint
(
data
.
handler
)
;
}
for
(
const
global
of
dbg
.
getDebuggees
(
)
)
{
if
(
!
data
.
debuggees
.
includes
(
global
)
)
{
dbg
.
removeDebuggee
(
global
)
;
}
}
dbg
.
onEnterFrame
=
undefined
;
dbg
.
onNativeCall
=
undefined
;
}
let
gSideEffectFreeNatives
;
function
ensureSideEffectFreeNatives
(
)
{
if
(
gSideEffectFreeNatives
)
{
return
;
}
const
natives
=
[
Array
Array
.
from
Array
.
isArray
Array
.
of
Array
.
prototype
.
concat
Array
.
prototype
.
entries
Array
.
prototype
.
every
Array
.
prototype
.
fill
Array
.
prototype
.
filter
Array
.
prototype
.
find
Array
.
prototype
.
findIndex
Array
.
prototype
.
flat
Array
.
prototype
.
flatMap
Array
.
prototype
.
forEach
Array
.
prototype
.
includes
Array
.
prototype
.
indexOf
Array
.
prototype
.
join
Array
.
prototype
.
keys
Array
.
prototype
.
lastIndexOf
Array
.
prototype
.
map
Array
.
prototype
.
reduce
Array
.
prototype
.
reduceRight
Array
.
prototype
.
slice
Array
.
prototype
.
some
Array
.
prototype
.
values
ArrayBuffer
ArrayBuffer
.
isView
ArrayBuffer
.
prototype
.
slice
BigInt
.
.
.
allProperties
(
BigInt
)
Boolean
DataView
Date
Date
.
now
Date
.
parse
Date
.
UTC
.
.
.
matchingProperties
(
Date
.
prototype
/
^
get
/
)
.
.
.
matchingProperties
(
Date
.
prototype
/
^
to
.
*
?
String
/
)
Error
Function
Function
.
prototype
.
apply
Function
.
prototype
.
bind
Function
.
prototype
.
call
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
Float32Array
Float64Array
Int8Array
.
prototype
.
entries
Int8Array
.
prototype
.
every
Int8Array
.
prototype
.
filter
Int8Array
.
prototype
.
find
Int8Array
.
prototype
.
findIndex
Int8Array
.
prototype
.
forEach
Int8Array
.
prototype
.
indexOf
Int8Array
.
prototype
.
includes
Int8Array
.
prototype
.
join
Int8Array
.
prototype
.
keys
Int8Array
.
prototype
.
lastIndexOf
Int8Array
.
prototype
.
map
Int8Array
.
prototype
.
reduce
Int8Array
.
prototype
.
reduceRight
Int8Array
.
prototype
.
slice
Int8Array
.
prototype
.
some
Int8Array
.
prototype
.
subarray
Int8Array
.
prototype
.
values
.
.
.
allProperties
(
JSON
)
Map
Map
.
prototype
.
forEach
Map
.
prototype
.
get
Map
.
prototype
.
has
Map
.
prototype
.
entries
Map
.
prototype
.
keys
Map
.
prototype
.
values
.
.
.
allProperties
(
Math
)
Number
.
.
.
allProperties
(
Number
)
.
.
.
allProperties
(
Number
.
prototype
)
Object
Object
.
create
Object
.
keys
Object
.
entries
Object
.
getOwnPropertyDescriptor
Object
.
getOwnPropertyDescriptors
Object
.
getOwnPropertyNames
Object
.
getOwnPropertySymbols
Object
.
getPrototypeOf
Object
.
is
Object
.
isExtensible
Object
.
isFrozen
Object
.
isSealed
Object
.
values
Object
.
prototype
.
hasOwnProperty
Object
.
prototype
.
isPrototypeOf
RegExp
RegExp
.
prototype
.
exec
RegExp
.
prototype
.
test
Set
Set
.
prototype
.
entries
Set
.
prototype
.
forEach
Set
.
prototype
.
has
Set
.
prototype
.
values
String
.
.
.
allProperties
(
String
)
.
.
.
allProperties
(
String
.
prototype
)
Symbol
Symbol
.
keyFor
WeakMap
WeakMap
.
prototype
.
get
WeakMap
.
prototype
.
has
WeakSet
WeakSet
.
prototype
.
has
decodeURI
decodeURIComponent
encodeURI
encodeURIComponent
escape
isFinite
isNaN
unescape
]
;
const
map
=
new
Map
(
)
;
for
(
const
n
of
natives
)
{
if
(
!
map
.
has
(
n
.
name
)
)
{
map
.
set
(
n
.
name
[
]
)
;
}
map
.
get
(
n
.
name
)
.
push
(
n
)
;
}
gSideEffectFreeNatives
=
map
;
function
matchingProperties
(
obj
regexp
)
{
return
Object
.
getOwnPropertyNames
(
obj
)
.
filter
(
n
=
>
regexp
.
test
(
n
)
)
.
map
(
n
=
>
obj
[
n
]
)
.
filter
(
v
=
>
typeof
v
=
=
"
function
"
)
;
}
function
allProperties
(
obj
)
{
return
matchingProperties
(
obj
/
.
/
)
;
}
}
function
nativeHasNoSideEffects
(
fn
)
{
switch
(
fn
.
name
)
{
case
"
toString
"
:
case
"
toLocaleString
"
:
case
"
valueOf
"
:
return
true
;
}
ensureSideEffectFreeNatives
(
)
;
const
natives
=
gSideEffectFreeNatives
.
get
(
fn
.
name
)
;
return
natives
&
&
natives
.
some
(
n
=
>
fn
.
isSameNative
(
n
)
)
;
}
function
updateConsoleInputEvaluation
(
dbg
dbgWindow
webConsole
)
{
if
(
webConsole
.
_lastConsoleInputEvaluation
)
{
webConsole
.
_lastConsoleInputEvaluation
=
dbg
.
adoptDebuggeeValue
(
webConsole
.
_lastConsoleInputEvaluation
)
;
}
}
function
getEvalInput
(
string
)
{
const
trimmedString
=
string
.
trim
(
)
;
if
(
trimmedString
=
=
=
"
help
"
|
|
trimmedString
=
=
=
"
?
"
)
{
return
"
help
(
)
"
;
}
if
(
isCommand
(
string
)
)
{
try
{
return
formatCommand
(
string
)
;
}
catch
(
e
)
{
console
.
log
(
e
)
;
return
throw
"
{
e
}
"
;
}
}
if
(
trimmedString
=
=
"
console
.
mihai
(
)
"
|
|
trimmedString
=
=
"
console
.
mihai
(
)
;
"
)
{
return
'
"
http
:
/
/
incompleteness
.
me
/
blog
/
2015
/
02
/
09
/
console
-
dot
-
mihai
/
"
'
;
}
return
string
;
}
function
getFrameDbg
(
options
webConsole
)
{
if
(
!
options
.
frameActor
)
{
return
{
frame
:
null
dbg
:
webConsole
.
dbg
}
;
}
const
frameActor
=
webConsole
.
conn
.
getActor
(
options
.
frameActor
)
;
if
(
frameActor
)
{
return
{
frame
:
frameActor
.
frame
dbg
:
frameActor
.
threadActor
.
dbg
}
;
}
return
DevToolsUtils
.
reportException
(
"
evalWithDebugger
"
Error
(
"
The
frame
actor
was
not
found
:
"
+
options
.
frameActor
)
)
;
}
function
evalReplay
(
frame
dbg
string
)
{
let
result
;
if
(
frame
)
{
try
{
result
=
frame
.
eval
(
string
)
;
}
catch
(
e
)
{
result
=
{
throw
:
e
}
;
}
}
else
{
result
=
{
throw
:
"
Cannot
evaluate
while
replaying
without
a
frame
"
}
;
}
return
{
result
:
result
helperResult
:
null
dbg
:
dbg
frame
:
frame
window
:
null
}
;
}
function
getDbgWindow
(
options
dbg
webConsole
)
{
const
dbgWindow
=
dbg
.
makeGlobalObjectReference
(
webConsole
.
evalWindow
)
;
if
(
!
options
.
selectedObjectActor
)
{
return
{
bindSelf
:
null
dbgWindow
}
;
}
const
actor
=
webConsole
.
getActorByID
(
options
.
selectedObjectActor
)
;
if
(
!
actor
)
{
return
{
bindSelf
:
null
dbgWindow
}
;
}
const
jsVal
=
actor
instanceof
LongStringActor
?
actor
.
str
:
actor
.
rawValue
(
)
;
if
(
!
isObject
(
jsVal
)
)
{
return
{
bindSelf
:
jsVal
dbgWindow
}
;
}
const
bindSelf
=
dbgWindow
.
makeDebuggeeValue
(
jsVal
)
;
return
{
bindSelf
dbgWindow
}
;
}
function
getHelpers
(
dbgWindow
options
webConsole
)
{
const
helpers
=
webConsole
.
_getWebConsoleCommands
(
dbgWindow
)
;
if
(
options
.
selectedNodeActor
)
{
const
actor
=
webConsole
.
conn
.
getActor
(
options
.
selectedNodeActor
)
;
if
(
actor
)
{
helpers
.
selectedNode
=
actor
.
rawNode
;
}
}
return
helpers
;
}
function
cleanupBindings
(
bindings
helperCache
)
{
for
(
const
[
helperName
helper
]
of
Object
.
entries
(
helperCache
)
)
{
bindings
[
helperName
]
=
helper
;
}
if
(
bindings
.
_self
)
{
delete
bindings
.
_self
;
}
}
function
bindCommands
(
isCmd
dbgWindow
bindSelf
frame
helpers
)
{
const
bindings
=
helpers
.
sandbox
;
if
(
bindSelf
)
{
bindings
.
_self
=
bindSelf
;
}
const
availableHelpers
=
[
.
.
.
WebConsoleCommands
.
_originalCommands
.
keys
(
)
]
.
filter
(
h
=
>
h
!
=
=
"
print
"
)
;
let
helpersToDisable
=
[
]
;
const
helperCache
=
{
}
;
if
(
!
isCmd
)
{
if
(
frame
)
{
const
env
=
frame
.
environment
;
if
(
env
)
{
helpersToDisable
=
availableHelpers
.
filter
(
name
=
>
!
!
env
.
find
(
name
)
)
;
}
}
else
{
helpersToDisable
=
availableHelpers
.
filter
(
name
=
>
!
!
dbgWindow
.
getOwnPropertyDescriptor
(
name
)
)
;
}
helpersToDisable
.
push
(
"
screenshot
"
)
;
}
for
(
const
helper
of
helpersToDisable
)
{
helperCache
[
helper
]
=
bindings
[
helper
]
;
delete
bindings
[
helper
]
;
}
return
{
bindings
helperCache
}
;
}
