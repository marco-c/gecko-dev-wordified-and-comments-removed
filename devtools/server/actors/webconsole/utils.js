"
use
strict
"
;
const
{
Ci
Cu
}
=
require
(
"
chrome
"
)
;
if
(
!
isWorker
)
{
loader
.
lazyImporter
(
this
"
VariablesView
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesView
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
captureScreenshot
"
"
devtools
/
shared
/
screenshot
/
capture
"
true
)
;
}
const
CONSOLE_WORKER_IDS
=
(
exports
.
CONSOLE_WORKER_IDS
=
[
"
SharedWorker
"
"
ServiceWorker
"
"
Worker
"
]
)
;
var
WebConsoleUtils
=
{
getWorkerType
:
function
(
message
)
{
const
id
=
message
?
message
.
innerID
:
null
;
return
CONSOLE_WORKER_IDS
[
CONSOLE_WORKER_IDS
.
indexOf
(
id
)
]
|
|
null
;
}
cloneObject
:
function
(
object
recursive
filter
)
{
if
(
typeof
object
!
=
"
object
"
)
{
return
object
;
}
let
temp
;
if
(
Array
.
isArray
(
object
)
)
{
temp
=
[
]
;
object
.
forEach
(
function
(
value
index
)
{
if
(
!
filter
|
|
filter
(
index
value
object
)
)
{
temp
.
push
(
recursive
?
WebConsoleUtils
.
cloneObject
(
value
)
:
value
)
;
}
}
)
;
}
else
{
temp
=
{
}
;
for
(
const
key
in
object
)
{
const
value
=
object
[
key
]
;
if
(
object
.
hasOwnProperty
(
key
)
&
&
(
!
filter
|
|
filter
(
key
value
object
)
)
)
{
temp
[
key
]
=
recursive
?
WebConsoleUtils
.
cloneObject
(
value
)
:
value
;
}
}
}
return
temp
;
}
getInnerWindowId
:
function
(
window
)
{
return
window
.
windowUtils
.
currentInnerWindowID
;
}
getInnerWindowIDsForFrames
:
function
(
window
)
{
const
innerWindowID
=
this
.
getInnerWindowId
(
window
)
;
let
ids
=
[
innerWindowID
]
;
if
(
window
.
frames
)
{
for
(
let
i
=
0
;
i
<
window
.
frames
.
length
;
i
+
+
)
{
const
frame
=
window
.
frames
[
i
]
;
ids
=
ids
.
concat
(
this
.
getInnerWindowIDsForFrames
(
frame
)
)
;
}
}
return
ids
;
}
getPropertyDescriptor
:
function
(
object
prop
)
{
let
desc
=
null
;
while
(
object
)
{
try
{
if
(
(
desc
=
Object
.
getOwnPropertyDescriptor
(
object
prop
)
)
)
{
break
;
}
}
catch
(
ex
)
{
if
(
ex
.
name
!
=
"
NS_ERROR_XPC_BAD_CONVERT_JS
"
&
&
ex
.
name
!
=
"
NS_ERROR_XPC_BAD_OP_ON_WN_PROTO
"
&
&
ex
.
name
!
=
"
TypeError
"
)
{
throw
ex
;
}
}
try
{
object
=
Object
.
getPrototypeOf
(
object
)
;
}
catch
(
ex
)
{
if
(
ex
.
name
=
=
"
TypeError
"
)
{
return
desc
;
}
throw
ex
;
}
}
return
desc
;
}
createValueGrip
:
function
(
value
objectWrapper
)
{
switch
(
typeof
value
)
{
case
"
boolean
"
:
return
value
;
case
"
string
"
:
return
objectWrapper
(
value
)
;
case
"
number
"
:
if
(
value
=
=
=
Infinity
)
{
return
{
type
:
"
Infinity
"
}
;
}
else
if
(
value
=
=
=
-
Infinity
)
{
return
{
type
:
"
-
Infinity
"
}
;
}
else
if
(
Number
.
isNaN
(
value
)
)
{
return
{
type
:
"
NaN
"
}
;
}
else
if
(
!
value
&
&
1
/
value
=
=
=
-
Infinity
)
{
return
{
type
:
"
-
0
"
}
;
}
return
value
;
case
"
undefined
"
:
return
{
type
:
"
undefined
"
}
;
case
"
object
"
:
if
(
value
=
=
=
null
)
{
return
{
type
:
"
null
"
}
;
}
case
"
function
"
:
return
objectWrapper
(
value
)
;
default
:
console
.
error
(
"
Failed
to
provide
a
grip
for
value
of
"
+
typeof
value
+
"
:
"
+
value
)
;
return
null
;
}
}
removeFramesAboveDebuggerEval
(
stack
)
{
const
debuggerEvalFilename
=
"
debugger
eval
code
"
;
const
evalIndex
=
stack
.
findIndex
(
(
{
filename
}
idx
arr
)
=
>
{
const
nextFrame
=
arr
[
idx
+
1
]
;
return
(
filename
=
=
debuggerEvalFilename
&
&
(
!
nextFrame
|
|
nextFrame
.
filename
!
=
=
debuggerEvalFilename
)
)
;
}
)
;
if
(
evalIndex
!
=
-
1
)
{
return
stack
.
slice
(
0
evalIndex
+
1
)
;
}
if
(
stack
.
some
(
(
{
filename
}
)
=
>
filename
&
&
filename
.
startsWith
(
"
resource
:
/
/
devtools
/
"
)
)
)
{
return
null
;
}
return
stack
;
}
}
;
exports
.
WebConsoleUtils
=
WebConsoleUtils
;
var
WebConsoleCommands
=
{
_registeredCommands
:
new
Map
(
)
_originalCommands
:
new
Map
(
)
_registerOriginal
:
function
(
name
command
)
{
this
.
register
(
name
command
)
;
this
.
_originalCommands
.
set
(
name
this
.
getCommand
(
name
)
)
;
}
register
:
function
(
name
command
)
{
this
.
_registeredCommands
.
set
(
name
command
)
;
}
unregister
:
function
(
name
)
{
this
.
_registeredCommands
.
delete
(
name
)
;
if
(
this
.
_originalCommands
.
has
(
name
)
)
{
this
.
register
(
name
this
.
_originalCommands
.
get
(
name
)
)
;
}
}
getCommand
:
function
(
name
)
{
return
this
.
_registeredCommands
.
get
(
name
)
;
}
hasCommand
:
function
(
name
)
{
return
this
.
_registeredCommands
.
has
(
name
)
;
}
}
;
exports
.
WebConsoleCommands
=
WebConsoleCommands
;
WebConsoleCommands
.
_registerOriginal
(
"
"
function
(
owner
selector
)
{
try
{
return
owner
.
window
.
document
.
querySelector
(
selector
)
;
}
catch
(
err
)
{
throw
new
owner
.
window
.
DOMException
(
err
.
message
err
.
name
)
;
}
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
"
function
(
owner
selector
)
{
let
nodes
;
try
{
nodes
=
owner
.
window
.
document
.
querySelectorAll
(
selector
)
;
}
catch
(
err
)
{
throw
new
owner
.
window
.
DOMException
(
err
.
message
err
.
name
)
;
}
const
result
=
new
owner
.
window
.
Array
(
)
;
for
(
let
i
=
0
;
i
<
nodes
.
length
;
i
+
+
)
{
result
.
push
(
nodes
[
i
]
)
;
}
return
result
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
_
"
{
get
:
function
(
owner
)
{
return
owner
.
consoleActor
.
getLastConsoleInputEvaluation
(
)
;
}
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
x
"
function
(
owner
xPath
context
resultType
=
owner
.
window
.
XPathResult
.
ANY_TYPE
)
{
const
nodes
=
new
owner
.
window
.
Array
(
)
;
const
doc
=
owner
.
window
.
document
;
context
=
context
|
|
doc
;
const
results
=
doc
.
evaluate
(
xPath
context
null
resultType
null
)
;
if
(
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
NUMBER_TYPE
)
{
return
results
.
numberValue
;
}
if
(
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
STRING_TYPE
)
{
return
results
.
stringValue
;
}
if
(
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
BOOLEAN_TYPE
)
{
return
results
.
booleanValue
;
}
if
(
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
ANY_UNORDERED_NODE_TYPE
|
|
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
FIRST_ORDERED_NODE_TYPE
)
{
return
results
.
singleNodeValue
;
}
if
(
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
UNORDERED_NODE_SNAPSHOT_TYPE
|
|
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
ORDERED_NODE_SNAPSHOT_TYPE
)
{
for
(
let
i
=
0
;
i
<
results
.
snapshotLength
;
i
+
+
)
{
nodes
.
push
(
results
.
snapshotItem
(
i
)
)
;
}
return
nodes
;
}
let
node
;
while
(
(
node
=
results
.
iterateNext
(
)
)
)
{
nodes
.
push
(
node
)
;
}
return
nodes
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
0
"
{
get
:
function
(
owner
)
{
return
owner
.
makeDebuggeeValue
(
owner
.
selectedNode
)
;
}
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
clear
"
function
(
owner
)
{
owner
.
helperResult
=
{
type
:
"
clearOutput
"
}
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
clearHistory
"
function
(
owner
)
{
owner
.
helperResult
=
{
type
:
"
clearHistory
"
}
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
keys
"
function
(
owner
object
)
{
return
Cu
.
cloneInto
(
Object
.
keys
(
Cu
.
waiveXrays
(
object
)
)
owner
.
window
)
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
values
"
function
(
owner
object
)
{
const
values
=
[
]
;
const
waived
=
Cu
.
waiveXrays
(
object
)
;
const
names
=
Object
.
getOwnPropertyNames
(
waived
)
;
for
(
const
name
of
names
)
{
values
.
push
(
waived
[
name
]
)
;
}
return
Cu
.
cloneInto
(
values
owner
.
window
)
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
help
"
function
(
owner
)
{
owner
.
helperResult
=
{
type
:
"
help
"
}
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
cd
"
function
(
owner
window
)
{
if
(
!
window
)
{
owner
.
consoleActor
.
evalWindow
=
null
;
owner
.
helperResult
=
{
type
:
"
cd
"
}
;
return
;
}
if
(
typeof
window
=
=
"
string
"
)
{
window
=
owner
.
window
.
document
.
querySelector
(
window
)
;
}
if
(
Element
.
isInstance
(
window
)
&
&
window
.
contentWindow
)
{
window
=
window
.
contentWindow
;
}
if
(
!
(
window
instanceof
Ci
.
nsIDOMWindow
)
)
{
owner
.
helperResult
=
{
type
:
"
error
"
message
:
"
cdFunctionInvalidArgument
"
}
;
return
;
}
owner
.
consoleActor
.
evalWindow
=
window
;
owner
.
helperResult
=
{
type
:
"
cd
"
}
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
inspect
"
function
(
owner
object
)
{
const
dbgObj
=
owner
.
makeDebuggeeValue
(
object
)
;
const
grip
=
owner
.
createValueGrip
(
dbgObj
)
;
owner
.
helperResult
=
{
type
:
"
inspectObject
"
input
:
owner
.
evalInput
object
:
grip
}
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
pprint
"
function
(
owner
object
)
{
if
(
object
=
=
=
null
|
|
object
=
=
=
undefined
|
|
object
=
=
=
true
|
|
object
=
=
=
false
)
{
owner
.
helperResult
=
{
type
:
"
error
"
message
:
"
helperFuncUnsupportedTypeError
"
}
;
return
null
;
}
owner
.
helperResult
=
{
rawOutput
:
true
}
;
if
(
typeof
object
=
=
"
function
"
)
{
return
object
+
"
\
n
"
;
}
const
output
=
[
]
;
const
obj
=
object
;
for
(
const
name
in
obj
)
{
const
desc
=
WebConsoleUtils
.
getPropertyDescriptor
(
obj
name
)
|
|
{
}
;
if
(
desc
.
get
|
|
desc
.
set
)
{
const
getGrip
=
VariablesView
.
getGrip
(
desc
.
get
)
;
const
setGrip
=
VariablesView
.
getGrip
(
desc
.
set
)
;
const
getString
=
VariablesView
.
getString
(
getGrip
)
;
const
setString
=
VariablesView
.
getString
(
setGrip
)
;
output
.
push
(
name
+
"
:
"
"
get
:
"
+
getString
"
set
:
"
+
setString
)
;
}
else
{
const
valueGrip
=
VariablesView
.
getGrip
(
obj
[
name
]
)
;
const
valueString
=
VariablesView
.
getString
(
valueGrip
)
;
output
.
push
(
name
+
"
:
"
+
valueString
)
;
}
}
return
"
"
+
output
.
join
(
"
\
n
"
)
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
print
"
function
(
owner
value
)
{
owner
.
helperResult
=
{
rawOutput
:
true
}
;
if
(
typeof
value
=
=
=
"
symbol
"
)
{
return
Symbol
.
prototype
.
toString
.
call
(
value
)
;
}
return
String
(
Cu
.
waiveXrays
(
value
)
)
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
copy
"
function
(
owner
value
)
{
let
payload
;
try
{
if
(
Element
.
isInstance
(
value
)
)
{
payload
=
value
.
outerHTML
;
}
else
if
(
typeof
value
=
=
"
string
"
)
{
payload
=
value
;
}
else
{
payload
=
JSON
.
stringify
(
value
null
"
"
)
;
}
}
catch
(
ex
)
{
payload
=
"
/
*
"
+
ex
+
"
*
/
"
;
}
owner
.
helperResult
=
{
type
:
"
copyValueToClipboard
"
value
:
payload
}
;
}
)
;
WebConsoleCommands
.
_registerOriginal
(
"
screenshot
"
function
(
owner
args
=
{
}
)
{
owner
.
helperResult
=
(
async
(
)
=
>
{
const
value
=
await
captureScreenshot
(
args
owner
.
window
.
document
)
;
return
{
type
:
"
screenshotOutput
"
value
args
}
;
}
)
(
)
;
}
)
;
function
addWebConsoleCommands
(
owner
)
{
const
commands
=
isWorker
?
[
]
:
WebConsoleCommands
.
_registeredCommands
;
if
(
!
owner
)
{
throw
new
Error
(
"
The
owner
is
required
"
)
;
}
for
(
const
[
name
command
]
of
commands
)
{
if
(
typeof
command
=
=
=
"
function
"
)
{
owner
.
sandbox
[
name
]
=
command
.
bind
(
undefined
owner
)
;
}
else
if
(
typeof
command
=
=
=
"
object
"
)
{
const
clone
=
Object
.
assign
(
{
}
command
{
enumerable
:
true
configurable
:
true
}
)
;
if
(
typeof
command
.
get
=
=
=
"
function
"
)
{
clone
.
get
=
command
.
get
.
bind
(
undefined
owner
)
;
}
if
(
typeof
command
.
set
=
=
=
"
function
"
)
{
clone
.
set
=
command
.
set
.
bind
(
undefined
owner
)
;
}
Object
.
defineProperty
(
owner
.
sandbox
name
clone
)
;
}
}
}
exports
.
addWebConsoleCommands
=
addWebConsoleCommands
;
