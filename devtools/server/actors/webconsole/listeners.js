"
use
strict
"
;
const
{
Cc
Ci
components
}
=
require
(
"
chrome
"
)
;
const
{
isWindowIncluded
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
CONSOLE_WORKER_IDS
WebConsoleUtils
}
=
require
(
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
swm
"
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
"
nsIServiceWorkerManager
"
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
CONTENT_PROCESS_SCRIPT
=
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
content
-
process
-
forward
.
js
"
;
function
ConsoleServiceListener
(
window
listener
)
{
this
.
window
=
window
;
this
.
listener
=
listener
;
}
exports
.
ConsoleServiceListener
=
ConsoleServiceListener
;
ConsoleServiceListener
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIConsoleListener
]
)
window
:
null
listener
:
null
init
:
function
(
)
{
Services
.
console
.
registerListener
(
this
)
;
}
observe
:
function
(
message
)
{
if
(
!
this
.
listener
)
{
return
;
}
if
(
this
.
window
)
{
if
(
!
(
message
instanceof
Ci
.
nsIScriptError
)
|
|
!
message
.
outerWindowID
|
|
!
this
.
isCategoryAllowed
(
message
.
category
)
)
{
return
;
}
let
errorWindow
=
Services
.
wm
.
getOuterWindowWithId
(
message
.
outerWindowID
)
;
if
(
!
errorWindow
|
|
!
isWindowIncluded
(
this
.
window
errorWindow
)
)
{
return
;
}
}
this
.
listener
.
onConsoleServiceMessage
(
message
)
;
}
isCategoryAllowed
:
function
(
category
)
{
if
(
!
category
)
{
return
false
;
}
switch
(
category
)
{
case
"
XPConnect
JavaScript
"
:
case
"
component
javascript
"
:
case
"
chrome
javascript
"
:
case
"
chrome
registration
"
:
case
"
XBL
"
:
case
"
XBL
Prototype
Handler
"
:
case
"
XBL
Content
Sink
"
:
case
"
xbl
javascript
"
:
return
false
;
}
return
true
;
}
getCachedMessages
:
function
(
includePrivate
=
false
)
{
let
errors
=
Services
.
console
.
getMessageArray
(
)
|
|
[
]
;
if
(
!
this
.
window
)
{
return
errors
.
filter
(
(
error
)
=
>
{
if
(
error
instanceof
Ci
.
nsIScriptError
)
{
if
(
!
includePrivate
&
&
error
.
isFromPrivateWindow
)
{
return
false
;
}
}
return
true
;
}
)
;
}
let
ids
=
WebConsoleUtils
.
getInnerWindowIDsForFrames
(
this
.
window
)
;
return
errors
.
filter
(
(
error
)
=
>
{
if
(
error
instanceof
Ci
.
nsIScriptError
)
{
if
(
!
includePrivate
&
&
error
.
isFromPrivateWindow
)
{
return
false
;
}
if
(
ids
&
&
(
ids
.
indexOf
(
error
.
innerWindowID
)
=
=
-
1
|
|
!
this
.
isCategoryAllowed
(
error
.
category
)
)
)
{
return
false
;
}
}
else
if
(
ids
&
&
ids
[
0
]
)
{
return
false
;
}
return
true
;
}
)
;
}
destroy
:
function
(
)
{
Services
.
console
.
unregisterListener
(
this
)
;
this
.
listener
=
this
.
window
=
null
;
}
}
;
function
ConsoleAPIListener
(
window
owner
{
addonId
}
=
{
}
)
{
this
.
window
=
window
;
this
.
owner
=
owner
;
this
.
addonId
=
addonId
;
}
exports
.
ConsoleAPIListener
=
ConsoleAPIListener
;
ConsoleAPIListener
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
window
:
null
owner
:
null
addonId
:
null
init
:
function
(
)
{
Services
.
obs
.
addObserver
(
this
"
console
-
api
-
log
-
event
"
)
;
}
observe
:
function
(
message
topic
)
{
if
(
!
this
.
owner
)
{
return
;
}
let
apiMessage
=
message
.
wrappedJSObject
;
if
(
!
this
.
isMessageRelevant
(
apiMessage
)
)
{
return
;
}
this
.
owner
.
onConsoleAPICall
(
apiMessage
)
;
}
isMessageRelevant
:
function
(
message
)
{
let
workerType
=
WebConsoleUtils
.
getWorkerType
(
message
)
;
if
(
this
.
window
&
&
workerType
=
=
=
"
ServiceWorker
"
)
{
let
scope
=
message
.
ID
;
if
(
!
this
.
window
.
shouldReportForServiceWorkerScope
(
scope
)
)
{
return
false
;
}
}
if
(
this
.
window
&
&
!
workerType
)
{
let
msgWindow
=
Services
.
wm
.
getCurrentInnerWindowWithId
(
message
.
innerID
)
;
if
(
!
msgWindow
|
|
!
isWindowIncluded
(
this
.
window
msgWindow
)
)
{
return
false
;
}
}
if
(
this
.
addonId
)
{
if
(
message
.
addonId
=
=
this
.
addonId
)
{
return
true
;
}
if
(
message
.
consoleID
&
&
message
.
consoleID
=
=
addon
/
{
this
.
addonId
}
)
{
return
true
;
}
return
false
;
}
return
true
;
}
getCachedMessages
:
function
(
includePrivate
=
false
)
{
let
messages
=
[
]
;
let
ConsoleAPIStorage
=
Cc
[
"
mozilla
.
org
/
consoleAPI
-
storage
;
1
"
]
.
getService
(
Ci
.
nsIConsoleAPIStorage
)
;
if
(
!
this
.
window
)
{
messages
=
ConsoleAPIStorage
.
getEvents
(
)
;
}
else
{
let
ids
=
WebConsoleUtils
.
getInnerWindowIDsForFrames
(
this
.
window
)
;
ids
.
forEach
(
(
id
)
=
>
{
messages
=
messages
.
concat
(
ConsoleAPIStorage
.
getEvents
(
id
)
)
;
}
)
;
}
CONSOLE_WORKER_IDS
.
forEach
(
(
id
)
=
>
{
messages
=
messages
.
concat
(
ConsoleAPIStorage
.
getEvents
(
id
)
)
;
}
)
;
messages
=
messages
.
filter
(
msg
=
>
{
return
this
.
isMessageRelevant
(
msg
)
;
}
)
;
if
(
includePrivate
)
{
return
messages
;
}
return
messages
.
filter
(
(
m
)
=
>
!
m
.
private
)
;
}
destroy
:
function
(
)
{
Services
.
obs
.
removeObserver
(
this
"
console
-
api
-
log
-
event
"
)
;
this
.
window
=
this
.
owner
=
null
;
}
}
;
function
ConsoleReflowListener
(
window
listener
)
{
this
.
docshell
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
this
.
listener
=
listener
;
this
.
docshell
.
addWeakReflowObserver
(
this
)
;
}
exports
.
ConsoleReflowListener
=
ConsoleReflowListener
;
ConsoleReflowListener
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIReflowObserver
Ci
.
nsISupportsWeakReference
]
)
docshell
:
null
listener
:
null
sendReflow
:
function
(
start
end
interruptible
)
{
let
frame
=
components
.
stack
.
caller
.
caller
;
let
filename
=
frame
?
frame
.
filename
:
null
;
if
(
filename
)
{
filename
=
filename
.
split
(
"
"
)
.
pop
(
)
;
}
this
.
listener
.
onReflowActivity
(
{
interruptible
:
interruptible
start
:
start
end
:
end
sourceURL
:
filename
sourceLine
:
frame
?
frame
.
lineNumber
:
null
functionName
:
frame
?
frame
.
name
:
null
}
)
;
}
reflow
:
function
(
start
end
)
{
this
.
sendReflow
(
start
end
false
)
;
}
reflowInterruptible
:
function
(
start
end
)
{
this
.
sendReflow
(
start
end
true
)
;
}
destroy
:
function
(
)
{
this
.
docshell
.
removeWeakReflowObserver
(
this
)
;
this
.
listener
=
this
.
docshell
=
null
;
}
}
;
function
ContentProcessListener
(
listener
)
{
this
.
listener
=
listener
;
Services
.
ppmm
.
addMessageListener
(
"
Console
:
Log
"
this
)
;
Services
.
ppmm
.
loadProcessScript
(
CONTENT_PROCESS_SCRIPT
true
)
;
}
exports
.
ContentProcessListener
=
ContentProcessListener
;
ContentProcessListener
.
prototype
=
{
receiveMessage
(
message
)
{
let
logMsg
=
message
.
data
;
logMsg
.
wrappedJSObject
=
logMsg
;
this
.
listener
.
onConsoleAPICall
(
logMsg
)
;
}
destroy
(
)
{
Services
.
ppmm
.
broadcastAsyncMessage
(
"
DevTools
:
StopForwardingContentProcessMessage
"
)
;
Services
.
ppmm
.
removeMessageListener
(
"
Console
:
Log
"
this
)
;
Services
.
ppmm
.
removeDelayedProcessScript
(
CONTENT_PROCESS_SCRIPT
)
;
this
.
listener
=
null
;
}
}
;
function
DocumentEventsListener
(
console
)
{
this
.
console
=
console
;
this
.
onWindowReady
=
this
.
onWindowReady
.
bind
(
this
)
;
this
.
onContentLoaded
=
this
.
onContentLoaded
.
bind
(
this
)
;
this
.
onLoad
=
this
.
onLoad
.
bind
(
this
)
;
this
.
listen
(
)
;
}
exports
.
DocumentEventsListener
=
DocumentEventsListener
;
DocumentEventsListener
.
prototype
=
{
listen
(
)
{
EventEmitter
.
on
(
this
.
console
.
parentActor
"
window
-
ready
"
this
.
onWindowReady
)
;
this
.
onWindowReady
(
{
window
:
this
.
console
.
window
isTopLevel
:
true
}
)
;
}
onWindowReady
(
{
window
isTopLevel
}
)
{
if
(
!
isTopLevel
)
{
return
;
}
let
{
readyState
}
=
window
.
document
;
if
(
readyState
!
=
"
interactive
"
&
&
readyState
!
=
"
complete
"
)
{
window
.
addEventListener
(
"
DOMContentLoaded
"
this
.
onContentLoaded
{
once
:
true
}
)
;
}
else
{
this
.
onContentLoaded
(
{
target
:
window
.
document
}
)
;
}
if
(
readyState
!
=
"
complete
"
)
{
window
.
addEventListener
(
"
load
"
this
.
onLoad
{
once
:
true
}
)
;
}
else
{
this
.
onLoad
(
{
target
:
window
.
document
}
)
;
}
}
onContentLoaded
(
event
)
{
let
window
=
event
.
target
.
defaultView
;
let
packet
=
{
from
:
this
.
console
.
actorID
type
:
"
documentEvent
"
name
:
"
dom
-
interactive
"
time
:
window
.
performance
.
timing
.
domInteractive
}
;
this
.
console
.
conn
.
send
(
packet
)
;
}
onLoad
(
event
)
{
let
window
=
event
.
target
.
defaultView
;
let
packet
=
{
from
:
this
.
console
.
actorID
type
:
"
documentEvent
"
name
:
"
dom
-
complete
"
time
:
window
.
performance
.
timing
.
domComplete
}
;
this
.
console
.
conn
.
send
(
packet
)
;
}
destroy
(
)
{
EventEmitter
.
off
(
this
.
console
.
parentActor
"
window
-
ready
"
this
.
onWindowReady
)
;
this
.
listener
=
null
;
}
}
;
