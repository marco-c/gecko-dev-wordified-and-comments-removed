"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
[
"
getCommandAndArgs
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
commands
/
parser
.
js
"
true
)
;
loader
.
lazyGetter
(
this
"
l10n
"
(
)
=
>
{
return
new
Localization
(
[
"
devtools
/
shared
/
webconsole
-
commands
.
ftl
"
"
devtools
/
server
/
actors
/
webconsole
/
commands
/
experimental
-
commands
.
ftl
"
]
true
)
;
}
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
JSTracer
:
"
resource
:
/
/
devtools
/
server
/
tracer
/
tracer
.
sys
.
mjs
"
}
{
global
:
"
contextual
"
}
)
;
const
USAGE_STRING_MAPPING
=
{
block
:
"
webconsole
-
commands
-
usage
-
block
"
trace
:
"
webconsole
-
commands
-
usage
-
trace3
"
unblock
:
"
webconsole
-
commands
-
usage
-
unblock
"
}
;
const
WebConsoleCommandsManager
=
{
SIDE_EFFECT_FREE
:
Symbol
(
"
SIDE_EFFECT_FREE
"
)
_registeredCommands
:
new
Map
(
)
_validArguments
:
new
Map
(
)
_sideEffectFreeCommands
:
new
Set
(
)
register
(
{
name
isSideEffectFree
command
validArguments
}
)
{
if
(
typeof
command
!
=
"
function
"
&
&
!
(
typeof
command
=
=
"
object
"
&
&
typeof
command
.
get
=
=
"
function
"
)
)
{
throw
new
Error
(
"
Invalid
web
console
command
.
It
can
only
be
a
function
or
an
object
with
a
function
as
'
get
'
attribute
"
)
;
}
if
(
typeof
isSideEffectFree
!
=
=
"
boolean
"
)
{
throw
new
Error
(
"
Invalid
web
console
command
.
'
isSideEffectFree
'
attribute
should
be
set
and
be
a
boolean
"
)
;
}
this
.
_registeredCommands
.
set
(
name
command
)
;
if
(
validArguments
)
{
this
.
_validArguments
.
set
(
name
validArguments
)
;
}
if
(
isSideEffectFree
)
{
this
.
_sideEffectFreeCommands
.
add
(
name
)
;
}
}
getAllCommandNames
(
)
{
return
[
.
.
.
this
.
_registeredCommands
.
keys
(
)
]
;
}
getAllColonCommandNames
(
)
{
return
[
"
block
"
"
help
"
"
history
"
"
screenshot
"
"
unblock
"
"
trace
"
]
;
}
getColonOnlyCommandNames
(
)
{
return
[
"
screenshot
"
"
trace
"
]
;
}
getAllCommands
(
)
{
return
this
.
_registeredCommands
;
}
_isCommandNameAlreadyInScope
(
name
frame
dbgGlobal
)
{
if
(
frame
&
&
frame
.
environment
)
{
return
!
!
frame
.
environment
.
find
(
name
)
;
}
try
{
const
globalEnv
=
dbgGlobal
.
asEnvironment
(
)
;
if
(
globalEnv
)
{
return
!
!
dbgGlobal
.
asEnvironment
(
)
.
find
(
name
)
;
}
}
catch
{
}
return
!
!
dbgGlobal
.
getOwnPropertyDescriptor
(
name
)
;
}
_createOwnerObject
(
consoleActor
debuggerGlobal
evalInput
selectedNodeActorID
)
{
const
owner
=
{
window
:
consoleActor
.
evalGlobal
makeDebuggeeValue
:
debuggerGlobal
.
makeDebuggeeValue
.
bind
(
debuggerGlobal
)
createValueGrip
:
consoleActor
.
createValueGrip
.
bind
(
consoleActor
)
preprocessDebuggerObject
:
consoleActor
.
preprocessDebuggerObject
.
bind
(
consoleActor
)
helperResult
:
null
consoleActor
evalInput
}
;
if
(
selectedNodeActorID
)
{
const
actor
=
consoleActor
.
conn
.
getActor
(
selectedNodeActorID
)
;
if
(
actor
)
{
owner
.
selectedNode
=
actor
.
rawNode
;
}
}
return
owner
;
}
_getCommandsForCurrentEnvironment
(
)
{
return
isWorker
?
new
Map
(
)
:
this
.
getAllCommands
(
)
;
}
getWebConsoleCommands
(
consoleActor
debuggerGlobal
frame
evalInput
selectedNodeActorID
preferConsoleCommandsOverLocalSymbols
)
{
const
bindings
=
Object
.
create
(
null
)
;
const
owner
=
this
.
_createOwnerObject
(
consoleActor
debuggerGlobal
evalInput
selectedNodeActorID
)
;
const
evalGlobal
=
consoleActor
.
evalGlobal
;
function
maybeExport
(
obj
name
)
{
if
(
typeof
obj
[
name
]
!
=
"
function
"
)
{
return
;
}
obj
[
name
]
=
Cu
.
exportFunction
(
obj
[
name
]
evalGlobal
{
allowCrossOriginArguments
:
true
}
)
;
}
const
commands
=
this
.
_getCommandsForCurrentEnvironment
(
)
;
const
colonOnlyCommandNames
=
this
.
getColonOnlyCommandNames
(
)
;
for
(
const
[
name
command
]
of
commands
)
{
if
(
!
preferConsoleCommandsOverLocalSymbols
&
&
(
frame
|
|
name
=
=
=
"
help
"
)
&
&
this
.
_isCommandNameAlreadyInScope
(
name
frame
debuggerGlobal
)
)
{
continue
;
}
if
(
colonOnlyCommandNames
.
includes
(
name
)
)
{
continue
;
}
const
descriptor
=
{
enumerable
:
true
configurable
:
true
}
;
if
(
typeof
command
=
=
=
"
function
"
)
{
descriptor
.
value
=
command
.
bind
(
undefined
owner
)
;
maybeExport
(
descriptor
"
value
"
)
;
if
(
this
.
_sideEffectFreeCommands
.
has
(
name
)
)
{
descriptor
.
value
.
isSideEffectFree
=
this
.
SIDE_EFFECT_FREE
;
}
descriptor
.
value
=
debuggerGlobal
.
makeDebuggeeValue
(
descriptor
.
value
)
;
}
else
if
(
typeof
command
?
.
get
=
=
=
"
function
"
)
{
descriptor
.
get
=
command
.
get
.
bind
(
undefined
owner
)
;
maybeExport
(
descriptor
"
get
"
)
;
if
(
this
.
_sideEffectFreeCommands
.
has
(
name
)
)
{
descriptor
.
get
.
isSideEffectFree
=
this
.
SIDE_EFFECT_FREE
;
}
}
Object
.
defineProperty
(
bindings
name
descriptor
)
;
}
return
{
getHelperResult
(
)
{
return
owner
.
helperResult
;
}
bindings
}
;
}
executeCommand
(
consoleActor
debuggerGlobal
selectedNodeActorID
evalInput
)
{
const
{
command
args
}
=
getCommandAndArgs
(
evalInput
)
;
const
commands
=
this
.
_getCommandsForCurrentEnvironment
(
)
;
if
(
!
commands
.
has
(
command
)
)
{
throw
new
Error
(
Unsupported
command
'
{
command
}
'
)
;
}
if
(
args
.
help
|
|
args
.
usage
)
{
const
l10nKey
=
USAGE_STRING_MAPPING
[
command
]
;
if
(
l10nKey
)
{
const
message
=
l10n
.
formatValueSync
(
l10nKey
)
;
if
(
message
&
&
message
!
=
=
l10nKey
)
{
return
{
result
:
null
helperResult
:
{
type
:
"
usage
"
message
}
}
;
}
}
}
const
validArguments
=
this
.
_validArguments
.
get
(
command
)
;
if
(
validArguments
)
{
for
(
const
key
of
Object
.
keys
(
args
)
)
{
if
(
!
validArguments
.
includes
(
key
)
)
{
throw
new
Error
(
:
{
command
}
command
doesn
'
t
support
'
{
key
}
'
argument
.
)
;
}
}
}
const
owner
=
this
.
_createOwnerObject
(
consoleActor
debuggerGlobal
evalInput
selectedNodeActorID
)
;
const
commandFunction
=
commands
.
get
(
command
)
;
const
result
=
commandFunction
(
owner
args
)
;
return
{
result
helperResult
:
owner
.
helperResult
}
;
}
}
;
exports
.
WebConsoleCommandsManager
=
WebConsoleCommandsManager
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
"
isSideEffectFree
:
true
command
(
owner
selector
element
)
{
try
{
if
(
element
&
&
element
.
querySelector
&
&
(
element
.
nodeType
=
=
Node
.
ELEMENT_NODE
|
|
element
.
nodeType
=
=
Node
.
DOCUMENT_NODE
|
|
element
.
nodeType
=
=
Node
.
DOCUMENT_FRAGMENT_NODE
)
)
{
return
element
.
querySelector
(
selector
)
;
}
return
owner
.
window
.
document
.
querySelector
(
selector
)
;
}
catch
(
err
)
{
throw
new
owner
.
window
.
DOMException
(
err
.
message
err
.
name
)
;
}
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
"
isSideEffectFree
:
true
command
(
owner
selector
element
)
{
let
scope
=
owner
.
window
.
document
;
try
{
if
(
element
&
&
element
.
querySelectorAll
&
&
(
element
.
nodeType
=
=
Node
.
ELEMENT_NODE
|
|
element
.
nodeType
=
=
Node
.
DOCUMENT_NODE
|
|
element
.
nodeType
=
=
Node
.
DOCUMENT_FRAGMENT_NODE
)
)
{
scope
=
element
;
}
const
nodes
=
scope
.
querySelectorAll
(
selector
)
;
const
result
=
new
owner
.
window
.
Array
(
)
;
for
(
let
i
=
0
;
i
<
nodes
.
length
;
i
+
+
)
{
result
.
push
(
nodes
[
i
]
)
;
}
return
result
;
}
catch
(
err
)
{
throw
new
owner
.
window
.
DOMException
(
err
.
message
err
.
name
)
;
}
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
_
"
isSideEffectFree
:
true
command
:
{
get
(
owner
)
{
return
owner
.
consoleActor
.
getLastConsoleInputEvaluation
(
)
;
}
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
x
"
isSideEffectFree
:
true
command
(
owner
xPath
context
resultType
=
owner
.
window
.
XPathResult
.
ANY_TYPE
)
{
const
nodes
=
new
owner
.
window
.
Array
(
)
;
const
doc
=
owner
.
window
.
document
;
context
=
context
|
|
doc
;
switch
(
resultType
)
{
case
"
number
"
:
resultType
=
owner
.
window
.
XPathResult
.
NUMBER_TYPE
;
break
;
case
"
string
"
:
resultType
=
owner
.
window
.
XPathResult
.
STRING_TYPE
;
break
;
case
"
bool
"
:
resultType
=
owner
.
window
.
XPathResult
.
BOOLEAN_TYPE
;
break
;
case
"
node
"
:
resultType
=
owner
.
window
.
XPathResult
.
FIRST_ORDERED_NODE_TYPE
;
break
;
case
"
nodes
"
:
resultType
=
owner
.
window
.
XPathResult
.
UNORDERED_NODE_ITERATOR_TYPE
;
break
;
}
const
results
=
doc
.
evaluate
(
xPath
context
null
resultType
null
)
;
if
(
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
NUMBER_TYPE
)
{
return
results
.
numberValue
;
}
if
(
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
STRING_TYPE
)
{
return
results
.
stringValue
;
}
if
(
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
BOOLEAN_TYPE
)
{
return
results
.
booleanValue
;
}
if
(
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
ANY_UNORDERED_NODE_TYPE
|
|
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
FIRST_ORDERED_NODE_TYPE
)
{
return
results
.
singleNodeValue
;
}
if
(
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
UNORDERED_NODE_SNAPSHOT_TYPE
|
|
results
.
resultType
=
=
=
owner
.
window
.
XPathResult
.
ORDERED_NODE_SNAPSHOT_TYPE
)
{
for
(
let
i
=
0
;
i
<
results
.
snapshotLength
;
i
+
+
)
{
nodes
.
push
(
results
.
snapshotItem
(
i
)
)
;
}
return
nodes
;
}
let
node
;
while
(
(
node
=
results
.
iterateNext
(
)
)
)
{
nodes
.
push
(
node
)
;
}
return
nodes
;
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
0
"
isSideEffectFree
:
true
command
:
{
get
(
owner
)
{
return
owner
.
makeDebuggeeValue
(
owner
.
selectedNode
)
;
}
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
clear
"
isSideEffectFree
:
false
command
(
owner
)
{
owner
.
helperResult
=
{
type
:
"
clearOutput
"
}
;
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
clearHistory
"
isSideEffectFree
:
false
command
(
owner
)
{
owner
.
helperResult
=
{
type
:
"
clearHistory
"
}
;
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
keys
"
isSideEffectFree
:
true
command
(
owner
object
)
{
return
Cu
.
cloneInto
(
Object
.
keys
(
Cu
.
waiveXrays
(
object
)
)
owner
.
window
)
;
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
values
"
isSideEffectFree
:
true
command
(
owner
object
)
{
const
values
=
[
]
;
const
waived
=
Cu
.
waiveXrays
(
object
)
;
const
names
=
Object
.
getOwnPropertyNames
(
waived
)
;
for
(
const
name
of
names
)
{
values
.
push
(
waived
[
name
]
)
;
}
return
Cu
.
cloneInto
(
values
owner
.
window
)
;
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
help
"
isSideEffectFree
:
false
command
(
owner
)
{
owner
.
helperResult
=
{
type
:
"
help
"
}
;
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
inspect
"
isSideEffectFree
:
false
command
(
owner
object
forceExpandInConsole
=
false
)
{
const
dbgObj
=
owner
.
preprocessDebuggerObject
(
owner
.
makeDebuggeeValue
(
object
)
)
;
const
grip
=
owner
.
createValueGrip
(
dbgObj
)
;
owner
.
helperResult
=
{
type
:
"
inspectObject
"
input
:
owner
.
evalInput
object
:
grip
forceExpandInConsole
}
;
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
copy
"
isSideEffectFree
:
false
command
(
owner
value
)
{
let
payload
;
try
{
if
(
Element
.
isInstance
(
value
)
)
{
payload
=
value
.
outerHTML
;
}
else
if
(
typeof
value
=
=
"
string
"
)
{
payload
=
value
;
}
else
{
payload
=
JSON
.
stringify
(
value
null
"
"
)
;
}
}
catch
(
ex
)
{
owner
.
helperResult
=
{
type
:
"
error
"
message
:
"
webconsole
.
error
.
commands
.
copyError
"
messageArgs
:
[
ex
.
toString
(
)
]
}
;
return
;
}
owner
.
helperResult
=
{
type
:
"
copyValueToClipboard
"
value
:
payload
}
;
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
screenshot
"
isSideEffectFree
:
false
command
(
owner
args
=
{
}
)
{
owner
.
helperResult
=
{
type
:
"
screenshotOutput
"
args
}
;
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
history
"
isSideEffectFree
:
false
command
(
owner
args
=
{
}
)
{
owner
.
helperResult
=
{
type
:
"
historyOutput
"
args
}
;
}
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
block
"
isSideEffectFree
:
false
command
(
owner
args
=
{
}
)
{
if
(
!
args
.
url
)
{
owner
.
helperResult
=
{
type
:
"
error
"
message
:
"
webconsole
.
messages
.
commands
.
blockArgMissing
"
}
;
return
;
}
owner
.
helperResult
=
{
type
:
"
blockURL
"
args
}
;
}
validArguments
:
[
"
url
"
]
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
unblock
"
isSideEffectFree
:
false
command
(
owner
args
=
{
}
)
{
if
(
!
args
.
url
)
{
owner
.
helperResult
=
{
type
:
"
error
"
message
:
"
webconsole
.
messages
.
commands
.
blockArgMissing
"
}
;
return
;
}
owner
.
helperResult
=
{
type
:
"
unblockURL
"
args
}
;
}
validArguments
:
[
"
url
"
]
}
)
;
WebConsoleCommandsManager
.
register
(
{
name
:
"
trace
"
isSideEffectFree
:
false
command
(
owner
args
)
{
if
(
isWorker
)
{
throw
new
Error
(
"
:
trace
command
isn
'
t
supported
in
workers
"
)
;
}
if
(
!
owner
.
consoleActor
.
targetActor
.
isTracerFeatureEnabled
)
{
throw
new
Error
(
"
:
trace
requires
'
devtools
.
debugger
.
features
.
javascript
-
tracing
'
preference
to
be
true
"
)
;
}
const
tracerActor
=
owner
.
consoleActor
.
targetActor
.
getTargetScopedActor
(
"
tracer
"
)
;
const
logMethod
=
args
.
logMethod
|
|
"
console
"
;
let
traceDOMMutations
=
null
;
if
(
"
dom
-
mutations
"
in
args
)
{
if
(
args
[
"
dom
-
mutations
"
]
=
=
=
true
)
{
traceDOMMutations
=
[
"
add
"
"
attributes
"
"
remove
"
]
;
}
else
if
(
typeof
args
[
"
dom
-
mutations
"
]
=
=
"
string
"
)
{
traceDOMMutations
=
args
[
"
dom
-
mutations
"
]
.
split
(
"
"
)
.
map
(
e
=
>
e
.
trim
(
)
)
;
const
acceptedValues
=
Object
.
values
(
lazy
.
JSTracer
.
DOM_MUTATIONS
)
;
if
(
!
traceDOMMutations
.
every
(
e
=
>
acceptedValues
.
includes
(
e
)
)
)
{
throw
new
Error
(
:
trace
-
-
dom
-
mutations
only
accept
a
list
of
strings
whose
values
can
be
:
{
acceptedValues
}
)
;
}
}
else
{
throw
new
Error
(
"
:
trace
-
-
dom
-
mutations
accept
only
no
arguments
or
a
list
mutation
type
strings
(
add
attributes
remove
)
"
)
;
}
}
const
enabled
=
tracerActor
.
toggleTracing
(
{
logMethod
prefix
:
args
.
prefix
|
|
null
traceFunctionReturn
:
!
!
args
.
returns
traceValues
:
!
!
args
.
values
traceOnNextInteraction
:
args
[
"
on
-
next
-
interaction
"
]
|
|
null
traceDOMMutations
maxDepth
:
args
[
"
max
-
depth
"
]
|
|
null
maxRecords
:
args
[
"
max
-
records
"
]
|
|
null
}
)
;
owner
.
helperResult
=
{
type
:
"
traceOutput
"
enabled
logMethod
}
;
}
validArguments
:
[
"
logMethod
"
"
max
-
depth
"
"
max
-
records
"
"
on
-
next
-
interaction
"
"
dom
-
mutations
"
"
prefix
"
"
returns
"
"
values
"
]
}
)
;
