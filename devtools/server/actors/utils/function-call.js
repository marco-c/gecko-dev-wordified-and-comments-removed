"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
functionCallSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
function
-
call
"
)
;
const
{
KNOWN_METHODS
}
=
require
(
"
devtools
/
shared
/
fronts
/
function
-
call
"
)
;
exports
.
FunctionCallActor
=
protocol
.
ActorClassWithSpec
(
functionCallSpec
{
initialize
:
function
(
conn
[
window
global
caller
type
name
stack
timestamp
args
result
]
holdWeak
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
details
=
{
global
:
global
type
:
type
name
:
name
stack
:
stack
timestamp
:
timestamp
}
;
if
(
holdWeak
)
{
const
weakRefs
=
{
window
:
Cu
.
getWeakReference
(
window
)
caller
:
Cu
.
getWeakReference
(
caller
)
args
:
Cu
.
getWeakReference
(
args
)
result
:
Cu
.
getWeakReference
(
result
)
}
;
Object
.
defineProperties
(
this
.
details
{
window
:
{
get
:
(
)
=
>
weakRefs
.
window
.
get
(
)
}
caller
:
{
get
:
(
)
=
>
weakRefs
.
caller
.
get
(
)
}
args
:
{
get
:
(
)
=
>
weakRefs
.
args
.
get
(
)
}
result
:
{
get
:
(
)
=
>
weakRefs
.
result
.
get
(
)
}
}
)
;
}
else
{
this
.
details
.
window
=
window
;
this
.
details
.
caller
=
caller
;
this
.
details
.
args
=
args
;
this
.
details
.
result
=
result
;
}
this
.
details
.
previews
=
{
caller
:
this
.
_generateStringPreview
(
caller
)
args
:
this
.
_generateArgsPreview
(
args
)
result
:
this
.
_generateStringPreview
(
result
)
}
;
}
form
:
function
(
)
{
return
{
actor
:
this
.
actorID
type
:
this
.
details
.
type
name
:
this
.
details
.
name
file
:
this
.
details
.
stack
[
0
]
.
file
line
:
this
.
details
.
stack
[
0
]
.
line
timestamp
:
this
.
details
.
timestamp
callerPreview
:
this
.
details
.
previews
.
caller
argsPreview
:
this
.
details
.
previews
.
args
resultPreview
:
this
.
details
.
previews
.
result
}
;
}
getDetails
:
function
(
)
{
const
{
type
name
stack
timestamp
}
=
this
.
details
;
for
(
let
i
=
stack
.
length
-
1
;
;
)
{
if
(
stack
[
i
]
.
file
)
{
break
;
}
stack
.
pop
(
)
;
i
-
-
;
}
return
{
type
:
type
name
:
name
stack
:
stack
timestamp
:
timestamp
}
;
}
_generateArgsPreview
:
function
(
args
)
{
const
{
global
name
caller
}
=
this
.
details
;
let
methodSignatureEnums
;
const
knownGlobal
=
KNOWN_METHODS
[
global
]
;
if
(
knownGlobal
)
{
const
knownMethod
=
knownGlobal
[
name
]
;
if
(
knownMethod
)
{
const
isOverloaded
=
typeof
knownMethod
.
enums
=
=
=
"
function
"
;
if
(
isOverloaded
)
{
methodSignatureEnums
=
knownMethod
.
enums
(
args
)
;
}
else
{
methodSignatureEnums
=
knownMethod
.
enums
;
}
}
}
const
serializeArgs
=
(
)
=
>
args
.
map
(
(
arg
i
)
=
>
{
if
(
arg
=
=
=
undefined
)
{
return
"
undefined
"
;
}
if
(
arg
=
=
=
null
)
{
return
"
null
"
;
}
if
(
typeof
arg
=
=
"
function
"
)
{
return
"
Function
"
;
}
if
(
typeof
arg
=
=
"
object
"
)
{
return
"
Object
"
;
}
if
(
methodSignatureEnums
&
&
methodSignatureEnums
.
has
(
i
)
)
{
return
getBitToEnumValue
(
global
caller
arg
)
;
}
return
arg
+
"
"
;
}
)
;
return
serializeArgs
(
)
.
join
(
"
"
)
;
}
_generateStringPreview
:
function
(
data
)
{
if
(
data
=
=
=
undefined
)
{
return
"
undefined
"
;
}
if
(
data
=
=
=
null
)
{
return
"
null
"
;
}
if
(
typeof
data
=
=
"
function
"
)
{
return
"
Function
"
;
}
if
(
typeof
data
=
=
"
object
"
)
{
return
"
Object
"
;
}
return
data
+
"
"
;
}
}
)
;
var
gEnumRegex
=
/
^
[
A
-
Z
]
[
A
-
Z0
-
9_
]
+
/
;
var
gEnumsLookupTable
=
{
}
;
var
INVALID_ENUMS
=
[
"
INVALID_ENUM
"
"
NO_ERROR
"
"
INVALID_VALUE
"
"
OUT_OF_MEMORY
"
"
NONE
"
]
;
function
getBitToEnumValue
(
type
object
arg
)
{
let
table
=
gEnumsLookupTable
[
type
]
;
if
(
!
table
)
{
table
=
gEnumsLookupTable
[
type
]
=
{
}
;
for
(
const
key
in
object
)
{
if
(
key
.
match
(
gEnumRegex
)
)
{
table
[
object
[
key
]
]
=
key
;
}
}
}
if
(
table
[
arg
]
)
{
return
table
[
arg
]
;
}
const
flags
=
[
]
;
for
(
let
flag
in
table
)
{
if
(
INVALID_ENUMS
.
includes
(
table
[
flag
]
)
)
{
continue
;
}
flag
=
flag
|
0
;
if
(
flag
&
&
(
arg
&
flag
)
=
=
=
flag
)
{
flags
.
push
(
table
[
flag
]
)
;
}
}
table
[
arg
]
=
flags
.
join
(
"
|
"
)
|
|
arg
;
return
table
[
arg
]
;
}
