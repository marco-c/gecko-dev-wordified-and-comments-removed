"
use
strict
"
;
const
xpcInspector
=
require
(
"
xpcInspector
"
)
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
class
EventLoop
{
constructor
(
{
thread
}
)
{
this
.
_thread
=
thread
;
this
.
_entered
=
false
;
this
.
_resolved
=
false
;
}
get
thread
(
)
{
return
this
.
_thread
;
}
get
resolved
(
)
{
return
this
.
_resolved
;
}
isTheLastPausedThreadActor
(
)
{
if
(
xpcInspector
.
eventLoopNestLevel
>
0
)
{
return
xpcInspector
.
lastNestRequestor
.
thread
=
=
=
this
.
_thread
;
}
return
true
;
}
enter
(
)
{
if
(
this
.
_entered
)
{
throw
new
Error
(
"
Can
'
t
enter
an
event
loop
that
has
already
been
entered
!
"
)
;
}
const
preEnterData
=
this
.
preEnter
(
)
;
this
.
_entered
=
true
;
xpcInspector
.
enterNestedEventLoop
(
this
)
;
if
(
xpcInspector
.
eventLoopNestLevel
>
0
)
{
const
{
resolved
}
=
xpcInspector
.
lastNestRequestor
;
if
(
resolved
)
{
xpcInspector
.
exitNestedEventLoop
(
)
;
}
}
this
.
postExit
(
preEnterData
)
;
}
exit
(
)
{
if
(
!
this
.
_entered
)
{
throw
new
Error
(
"
Can
'
t
exit
an
event
loop
before
it
has
been
entered
!
"
)
;
}
this
.
_entered
=
false
;
this
.
_resolved
=
true
;
if
(
this
=
=
=
xpcInspector
.
lastNestRequestor
)
{
xpcInspector
.
exitNestedEventLoop
(
)
;
return
true
;
}
return
false
;
}
getAllWindowDebuggees
(
)
{
return
this
.
_thread
.
dbg
.
getDebuggees
(
)
.
filter
(
debuggee
=
>
{
return
debuggee
.
class
=
=
"
Window
"
;
}
)
.
map
(
debuggee
=
>
{
return
debuggee
.
unsafeDereference
(
)
;
}
)
.
filter
(
window
=
>
{
if
(
Cu
.
isDeadWrapper
(
window
)
)
{
return
false
;
}
if
(
window
.
closed
)
{
return
false
;
}
if
(
Cu
.
isRemoteProxy
(
window
)
)
{
return
false
;
}
if
(
Cu
.
isRemoteProxy
(
window
.
parent
)
&
&
!
Cu
.
isRemoteProxy
(
window
)
)
{
return
true
;
}
try
{
return
window
.
top
=
=
=
window
;
}
catch
(
e
)
{
if
(
!
/
not
initialized
/
.
test
(
e
)
)
{
console
.
warn
(
Exception
in
getAllWindowDebuggees
:
{
e
}
)
;
}
return
false
;
}
}
)
;
}
preEnter
(
)
{
const
docShells
=
[
]
;
for
(
const
window
of
this
.
getAllWindowDebuggees
(
)
)
{
const
{
windowUtils
}
=
window
;
windowUtils
.
suppressEventHandling
(
true
)
;
windowUtils
.
suspendTimeouts
(
)
;
docShells
.
push
(
window
.
docShell
)
;
}
return
docShells
;
}
postExit
(
pausedDocShells
)
{
for
(
const
docShell
of
pausedDocShells
)
{
if
(
docShell
.
isBeingDestroyed
(
)
)
{
continue
;
}
const
{
windowUtils
}
=
docShell
.
domWindow
;
windowUtils
.
resumeTimeouts
(
)
;
windowUtils
.
suppressEventHandling
(
false
)
;
}
}
}
exports
.
EventLoop
=
EventLoop
;
