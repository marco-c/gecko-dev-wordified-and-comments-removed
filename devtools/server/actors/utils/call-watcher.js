"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
{
METHOD_FUNCTION
GETTER_FUNCTION
SETTER_FUNCTION
}
=
require
(
"
devtools
/
shared
/
fronts
/
function
-
call
"
)
;
const
{
FunctionCallActor
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
function
-
call
"
)
;
function
CallWatcher
(
conn
targetActor
)
{
this
.
targetActor
=
targetActor
;
this
.
conn
=
conn
;
this
.
_onGlobalCreated
=
this
.
_onGlobalCreated
.
bind
(
this
)
;
this
.
_onGlobalDestroyed
=
this
.
_onGlobalDestroyed
.
bind
(
this
)
;
this
.
_onContentFunctionCall
=
this
.
_onContentFunctionCall
.
bind
(
this
)
;
this
.
targetActor
.
on
(
"
window
-
ready
"
this
.
_onGlobalCreated
)
;
this
.
targetActor
.
on
(
"
window
-
destroyed
"
this
.
_onGlobalDestroyed
)
;
}
exports
.
CallWatcher
=
CallWatcher
;
CallWatcher
.
prototype
=
{
onCall
:
null
setup
:
function
(
{
tracedGlobals
tracedFunctions
startRecording
performReload
holdWeak
storeCalls
}
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
this
.
_timestampEpoch
=
0
;
this
.
_functionCalls
=
[
]
;
this
.
_tracedGlobals
=
tracedGlobals
|
|
[
]
;
this
.
_tracedFunctions
=
tracedFunctions
|
|
[
]
;
this
.
_holdWeak
=
!
!
holdWeak
;
this
.
_storeCalls
=
!
!
storeCalls
;
if
(
startRecording
)
{
this
.
resumeRecording
(
)
;
}
if
(
performReload
)
{
this
.
targetActor
.
window
.
location
.
reload
(
)
;
}
}
finalize
:
function
(
)
{
this
.
targetActor
.
off
(
"
window
-
ready
"
this
.
_onGlobalCreated
)
;
this
.
targetActor
.
off
(
"
window
-
destroyed
"
this
.
_onGlobalDestroyed
)
;
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
false
;
this
.
_finalized
=
true
;
this
.
_tracedGlobals
=
null
;
this
.
_tracedFunctions
=
null
;
}
isRecording
:
function
(
)
{
return
this
.
_recording
;
}
initTimestampEpoch
:
function
(
)
{
this
.
_timestampEpoch
=
this
.
targetActor
.
window
.
performance
.
now
(
)
;
}
resumeRecording
:
function
(
)
{
this
.
_recording
=
true
;
}
pauseRecording
:
function
(
)
{
this
.
_recording
=
false
;
return
this
.
_functionCalls
;
}
eraseRecording
:
function
(
)
{
this
.
_functionCalls
=
[
]
;
}
_onGlobalCreated
:
function
(
{
window
id
isTopLevel
}
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
if
(
!
isTopLevel
)
{
return
;
}
const
self
=
this
;
this
.
_tracedWindowId
=
id
;
const
unwrappedWindow
=
XPCNativeWrapper
.
unwrap
(
window
)
;
const
callback
=
this
.
_onContentFunctionCall
;
for
(
const
global
of
this
.
_tracedGlobals
)
{
const
prototype
=
unwrappedWindow
[
global
]
.
prototype
;
const
properties
=
Object
.
keys
(
prototype
)
;
properties
.
forEach
(
name
=
>
overrideSymbol
(
global
prototype
name
callback
)
)
;
}
for
(
const
name
of
this
.
_tracedFunctions
)
{
overrideSymbol
(
"
window
"
unwrappedWindow
name
callback
)
;
}
function
overrideSymbol
(
global
target
name
subcallback
)
{
const
propertyDescriptor
=
Object
.
getOwnPropertyDescriptor
(
target
name
)
;
if
(
propertyDescriptor
.
get
|
|
propertyDescriptor
.
set
)
{
overrideAccessor
(
global
target
name
propertyDescriptor
subcallback
)
;
return
;
}
if
(
propertyDescriptor
.
writable
&
&
typeof
propertyDescriptor
.
value
=
=
"
function
"
)
{
overrideFunction
(
global
target
name
propertyDescriptor
subcallback
)
;
}
}
function
overrideFunction
(
global
target
name
descriptor
subcallback
)
{
const
originalFunc
=
Cu
.
unwaiveXrays
(
target
[
name
]
)
;
Cu
.
exportFunction
(
function
(
.
.
.
args
)
{
let
result
;
try
{
result
=
Cu
.
waiveXrays
(
originalFunc
.
apply
(
this
args
)
)
;
}
catch
(
e
)
{
throw
createContentError
(
e
unwrappedWindow
)
;
}
if
(
self
.
_recording
)
{
const
type
=
METHOD_FUNCTION
;
const
stack
=
getStack
(
name
)
;
const
now
=
self
.
targetActor
.
window
.
performance
.
now
(
)
;
const
timestamp
=
now
-
self
.
_timestampEpoch
;
subcallback
(
unwrappedWindow
global
this
type
name
stack
timestamp
args
result
)
;
}
return
result
;
}
target
{
defineAs
:
name
}
)
;
Object
.
defineProperty
(
target
name
{
configurable
:
descriptor
.
configurable
enumerable
:
descriptor
.
enumerable
writable
:
true
}
)
;
}
function
overrideAccessor
(
global
target
name
descriptor
subcallback
)
{
const
originalGetter
=
Cu
.
unwaiveXrays
(
target
.
__lookupGetter__
(
name
)
)
;
const
originalSetter
=
Cu
.
unwaiveXrays
(
target
.
__lookupSetter__
(
name
)
)
;
Object
.
defineProperty
(
target
name
{
get
:
function
(
.
.
.
args
)
{
if
(
!
originalGetter
)
{
return
undefined
;
}
const
result
=
Cu
.
waiveXrays
(
originalGetter
.
apply
(
this
args
)
)
;
if
(
self
.
_recording
)
{
const
type
=
GETTER_FUNCTION
;
const
stack
=
getStack
(
name
)
;
const
now
=
self
.
targetActor
.
window
.
performance
.
now
(
)
;
const
timestamp
=
now
-
self
.
_timestampEpoch
;
subcallback
(
unwrappedWindow
global
this
type
name
stack
timestamp
args
result
)
;
}
return
result
;
}
set
:
function
(
.
.
.
args
)
{
if
(
!
originalSetter
)
{
return
;
}
originalSetter
.
apply
(
this
args
)
;
if
(
self
.
_recording
)
{
const
type
=
SETTER_FUNCTION
;
const
stack
=
getStack
(
name
)
;
const
now
=
self
.
targetActor
.
window
.
performance
.
now
(
)
;
const
timestamp
=
now
-
self
.
_timestampEpoch
;
subcallback
(
unwrappedWindow
global
this
type
name
stack
timestamp
args
undefined
)
;
}
}
configurable
:
descriptor
.
configurable
enumerable
:
descriptor
.
enumerable
}
)
;
}
function
getStack
(
caller
)
{
let
stack
;
try
{
throw
new
Error
(
)
;
}
catch
(
e
)
{
stack
=
e
.
stack
;
}
const
calls
=
[
]
;
let
callIndex
=
0
;
let
currNewLinePivot
=
stack
.
indexOf
(
"
\
n
"
)
+
1
;
let
nextNewLinePivot
=
stack
.
indexOf
(
"
\
n
"
currNewLinePivot
)
;
while
(
nextNewLinePivot
>
0
)
{
const
nameDelimiterIndex
=
stack
.
indexOf
(
"
"
currNewLinePivot
)
;
const
columnDelimiterIndex
=
stack
.
lastIndexOf
(
"
:
"
nextNewLinePivot
-
1
)
;
const
lineDelimiterIndex
=
stack
.
lastIndexOf
(
"
:
"
columnDelimiterIndex
-
1
)
;
if
(
!
calls
[
callIndex
]
)
{
calls
[
callIndex
]
=
{
name
:
"
"
file
:
"
"
line
:
0
}
;
}
if
(
!
calls
[
callIndex
+
1
]
)
{
calls
[
callIndex
+
1
]
=
{
name
:
"
"
file
:
"
"
line
:
0
}
;
}
if
(
callIndex
>
0
)
{
const
file
=
stack
.
substring
(
nameDelimiterIndex
+
1
lineDelimiterIndex
)
;
const
line
=
stack
.
substring
(
lineDelimiterIndex
+
1
columnDelimiterIndex
)
;
const
name
=
stack
.
substring
(
currNewLinePivot
nameDelimiterIndex
)
;
calls
[
callIndex
]
.
name
=
name
;
calls
[
callIndex
-
1
]
.
file
=
file
;
calls
[
callIndex
-
1
]
.
line
=
line
;
}
else
{
calls
[
0
]
.
name
=
caller
;
}
currNewLinePivot
=
nextNewLinePivot
+
1
;
nextNewLinePivot
=
stack
.
indexOf
(
"
\
n
"
currNewLinePivot
)
;
callIndex
+
+
;
}
return
calls
;
}
}
_onGlobalDestroyed
:
function
(
{
window
id
isTopLevel
}
)
{
if
(
this
.
_tracedWindowId
=
=
id
)
{
this
.
pauseRecording
(
)
;
this
.
eraseRecording
(
)
;
this
.
_timestampEpoch
=
0
;
}
}
_onContentFunctionCall
:
function
(
.
.
.
details
)
{
if
(
this
.
_finalized
)
{
return
;
}
const
functionCall
=
new
FunctionCallActor
(
this
.
conn
details
this
.
_holdWeak
)
;
if
(
this
.
_storeCalls
)
{
this
.
_functionCalls
.
push
(
functionCall
)
;
}
if
(
this
.
onCall
)
{
this
.
onCall
(
functionCall
)
;
}
else
{
this
.
emit
(
"
call
"
functionCall
)
;
}
}
}
;
function
parseURI
(
uri
)
{
return
String
(
uri
)
.
split
(
"
-
>
"
)
.
pop
(
)
;
}
function
parseStack
(
stack
)
{
const
lines
=
String
(
stack
)
.
split
(
"
\
n
"
)
;
return
lines
.
reduce
(
function
(
frames
line
)
{
if
(
line
)
{
const
atIndex
=
line
.
indexOf
(
"
"
)
;
const
columnIndex
=
line
.
lastIndexOf
(
"
:
"
)
;
const
lineIndex
=
line
.
lastIndexOf
(
"
:
"
columnIndex
-
1
)
;
const
fileName
=
parseURI
(
line
.
slice
(
atIndex
+
1
lineIndex
)
)
;
const
lineNumber
=
parseInt
(
line
.
slice
(
lineIndex
+
1
columnIndex
)
10
)
;
const
columnNumber
=
parseInt
(
line
.
slice
(
columnIndex
+
1
)
10
)
;
const
name
=
line
.
slice
(
0
atIndex
)
.
split
(
"
(
"
)
.
shift
(
)
;
frames
.
unshift
(
{
fileName
:
fileName
name
:
name
lineNumber
:
lineNumber
columnNumber
:
columnNumber
}
)
;
}
return
frames
;
}
[
]
)
;
}
function
serializeStack
(
frames
)
{
return
frames
.
reduce
(
function
(
stack
frame
)
{
return
frame
.
name
+
"
"
+
frame
.
fileName
+
"
:
"
+
frame
.
lineNumber
+
"
:
"
+
frame
.
columnNumber
+
"
\
n
"
+
stack
;
}
"
"
)
;
}
function
createContentError
(
e
win
)
{
const
{
message
name
stack
}
=
e
;
const
parsedStack
=
parseStack
(
stack
)
;
const
{
fileName
lineNumber
columnNumber
}
=
parsedStack
[
parsedStack
.
length
-
1
]
;
let
error
;
const
isDOMException
=
ChromeUtils
.
getClassName
(
e
)
=
=
=
"
DOMException
"
;
const
constructor
=
isDOMException
?
win
.
DOMException
:
(
win
[
e
.
name
]
|
|
win
.
Error
)
;
if
(
isDOMException
)
{
error
=
new
constructor
(
message
name
)
;
Object
.
defineProperties
(
error
{
code
:
{
value
:
e
.
code
}
columnNumber
:
{
value
:
0
}
filename
:
{
value
:
fileName
}
lineNumber
:
{
value
:
lineNumber
}
result
:
{
value
:
e
.
result
}
stack
:
{
value
:
serializeStack
(
parsedStack
)
}
}
)
;
}
else
{
error
=
new
constructor
(
message
fileName
lineNumber
)
;
Object
.
defineProperty
(
error
"
columnNumber
"
{
value
:
columnNumber
}
)
;
}
return
error
;
}
