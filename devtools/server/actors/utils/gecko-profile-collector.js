"
use
strict
"
;
const
DEFAULT_COLOR
=
"
grey
"
;
const
DEFAULT_CATEGORIES
=
[
{
name
:
"
Mixed
"
color
:
DEFAULT_COLOR
subcategories
:
[
"
Other
"
]
}
]
;
const
PREDEFINED_COLORS
=
{
interpreter
:
"
yellow
"
baseline
:
"
orange
"
ion
:
"
blue
"
wasm
:
"
purple
"
}
;
class
GeckoProfileCollector
{
#
thread
=
null
;
#
stackMap
=
new
Map
(
)
;
#
frameMap
=
new
Map
(
)
;
#
categories
=
DEFAULT_CATEGORIES
;
#
currentStack
=
[
]
;
#
time
=
0
;
start
(
)
{
this
.
#
reset
(
)
;
this
.
#
thread
=
this
.
#
getEmptyThread
(
)
;
}
stop
(
)
{
const
profile
=
this
.
#
getEmptyProfile
(
)
;
profile
.
meta
.
categories
=
this
.
#
categories
;
profile
.
threads
.
push
(
this
.
#
thread
)
;
this
.
#
reset
(
)
;
return
profile
;
}
#
reset
(
)
{
this
.
#
thread
=
null
;
this
.
#
stackMap
=
new
Map
(
)
;
this
.
#
frameMap
=
new
Map
(
)
;
this
.
#
categories
=
DEFAULT_CATEGORIES
;
this
.
#
currentStack
=
[
]
;
this
.
#
time
=
0
;
}
#
getEmptyProfile
(
)
{
const
httpHandler
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
http
"
]
.
getService
(
Ci
.
nsIHttpProtocolHandler
)
;
return
{
meta
:
{
interval
:
1
startTime
:
0
product
:
Services
.
appinfo
.
name
importedFrom
:
"
JS
Tracer
"
version
:
28
presymbolicated
:
true
abi
:
Services
.
appinfo
.
XPCOMABI
misc
:
httpHandler
.
misc
oscpu
:
httpHandler
.
oscpu
platform
:
httpHandler
.
platform
processType
:
Services
.
appinfo
.
processType
categories
:
[
]
stackwalk
:
0
toolkit
:
Services
.
appinfo
.
widgetToolkit
appBuildID
:
Services
.
appinfo
.
appBuildID
sourceURL
:
Services
.
appinfo
.
sourceURL
physicalCPUs
:
0
logicalCPUs
:
0
CPUName
:
"
"
markerSchema
:
[
]
}
libs
:
[
]
pages
:
[
]
threads
:
[
]
processes
:
[
]
}
;
}
#
getEmptyThread
(
)
{
return
{
processType
:
"
default
"
processStartupTime
:
0
processShutdownTime
:
null
registerTime
:
0
unregisterTime
:
null
pausedRanges
:
[
]
name
:
"
GeckoMain
"
"
eTLD
+
1
"
:
"
JS
Tracer
"
isMainThread
:
true
pid
:
Services
.
appinfo
.
processID
tid
:
0
samples
:
{
schema
:
{
stack
:
0
time
:
1
eventDelay
:
2
}
data
:
[
]
}
markers
:
{
schema
:
{
name
:
0
startTime
:
1
endTime
:
2
phase
:
3
category
:
4
data
:
5
}
data
:
[
]
}
stackTable
:
{
schema
:
{
prefix
:
0
frame
:
1
}
data
:
[
]
}
frameTable
:
{
schema
:
{
location
:
0
relevantForJS
:
1
innerWindowID
:
2
implementation
:
3
line
:
4
column
:
5
category
:
6
subcategory
:
7
}
data
:
[
]
}
stringTable
:
[
]
}
;
}
addSample
(
frame
depth
)
{
const
currentDepth
=
this
.
#
currentStack
.
length
;
if
(
currentDepth
=
=
depth
)
{
this
.
#
currentStack
[
currentDepth
]
=
frame
;
}
else
if
(
currentDepth
<
depth
)
{
this
.
#
currentStack
.
push
(
frame
)
;
}
else
{
this
.
#
currentStack
.
length
=
depth
;
this
.
#
currentStack
[
depth
]
=
frame
;
}
const
stack
=
this
.
#
currentStack
.
reduce
(
(
prefix
stackFrame
)
=
>
{
const
frameIndex
=
this
.
#
getOrCreateFrame
(
stackFrame
)
;
return
this
.
#
getOrCreateStack
(
frameIndex
prefix
)
;
}
null
)
;
this
.
#
thread
.
samples
.
data
.
push
(
[
stack
this
.
#
time
+
+
0
]
)
;
}
#
getOrCreateFrame
(
frame
)
{
const
{
frameTable
stringTable
}
=
this
.
#
thread
;
const
frameString
=
{
frame
.
name
}
:
{
frame
.
url
}
:
{
frame
.
lineNumber
}
:
{
frame
.
columnNumber
}
:
{
frame
.
category
}
;
let
frameIndex
=
this
.
#
frameMap
.
get
(
frameString
)
;
if
(
frameIndex
=
=
=
undefined
)
{
frameIndex
=
frameTable
.
data
.
length
;
const
location
=
stringTable
.
length
;
stringTable
.
push
(
{
frame
.
name
}
(
{
frame
.
url
}
:
{
frame
.
lineNumber
}
:
{
frame
.
columnNumber
}
)
)
;
const
category
=
this
.
#
getOrCreateCategory
(
frame
.
category
)
;
frameTable
.
data
.
push
(
[
location
true
0
null
frame
.
lineNumber
frame
.
columnNumber
category
0
]
)
;
this
.
#
frameMap
.
set
(
frameString
frameIndex
)
;
}
return
frameIndex
;
}
#
getOrCreateStack
(
frameIndex
prefix
)
{
const
{
stackTable
}
=
this
.
#
thread
;
const
key
=
prefix
=
=
=
null
?
{
frameIndex
}
:
{
frameIndex
}
{
prefix
}
;
let
stack
=
this
.
#
stackMap
.
get
(
key
)
;
if
(
stack
=
=
=
undefined
)
{
stack
=
stackTable
.
data
.
length
;
stackTable
.
data
.
push
(
[
prefix
frameIndex
]
)
;
this
.
#
stackMap
.
set
(
key
stack
)
;
}
return
stack
;
}
#
getOrCreateCategory
(
category
)
{
const
categories
=
this
.
#
categories
;
let
categoryIndex
=
categories
.
findIndex
(
c
=
>
c
.
name
=
=
=
category
)
;
if
(
categoryIndex
=
=
=
-
1
)
{
categoryIndex
=
categories
.
length
;
categories
.
push
(
{
name
:
category
color
:
PREDEFINED_COLORS
[
category
]
?
?
DEFAULT_COLOR
subcategories
:
[
"
Other
"
]
}
)
;
}
return
categoryIndex
;
}
}
exports
.
GeckoProfileCollector
=
GeckoProfileCollector
;
