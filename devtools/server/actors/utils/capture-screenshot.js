"
use
strict
"
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
CONTAINER_FLASHING_DURATION
=
500
;
const
STRINGS_URI
=
"
devtools
/
shared
/
locales
/
screenshot
.
properties
"
;
const
L10N
=
new
LocalizationHelper
(
STRINGS_URI
)
;
const
MAX_IMAGE_WIDTH
=
10000
;
const
MAX_IMAGE_HEIGHT
=
10000
;
function
simulateCameraFlash
(
browsingContext
)
{
const
node
=
browsingContext
.
topFrameElement
;
if
(
node
.
ownerGlobal
.
matchMedia
(
"
(
prefers
-
reduced
-
motion
)
"
)
.
matches
)
{
return
;
}
node
.
animate
(
[
{
opacity
:
0
}
{
opacity
:
1
}
]
{
duration
:
CONTAINER_FLASHING_DURATION
}
)
;
}
async
function
captureScreenshot
(
args
browsingContext
)
{
const
messages
=
[
]
;
let
filename
=
getFilename
(
args
.
filename
)
;
if
(
args
.
fullpage
)
{
filename
=
filename
.
replace
(
"
.
png
"
"
-
fullpage
.
png
"
)
;
}
let
{
left
top
width
height
}
=
args
.
rect
|
|
{
}
;
if
(
width
&
&
(
width
>
MAX_IMAGE_WIDTH
|
|
height
>
MAX_IMAGE_HEIGHT
)
)
{
width
=
Math
.
min
(
width
MAX_IMAGE_WIDTH
)
;
height
=
Math
.
min
(
height
MAX_IMAGE_HEIGHT
)
;
messages
.
push
(
{
level
:
"
warn
"
text
:
L10N
.
getFormatStr
(
"
screenshotTruncationWarning
"
width
height
)
}
)
;
}
let
rect
=
null
;
if
(
args
.
rect
)
{
rect
=
new
globalThis
.
DOMRect
(
Math
.
round
(
left
)
Math
.
round
(
top
)
Math
.
round
(
width
)
Math
.
round
(
height
)
)
;
}
const
ratio
=
args
.
dpr
?
args
.
dpr
:
1
;
const
document
=
browsingContext
.
topChromeWindow
.
document
;
const
canvas
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
const
drawToCanvas
=
async
actualRatio
=
>
{
try
{
const
snapshot
=
await
browsingContext
.
currentWindowGlobal
.
drawSnapshot
(
rect
actualRatio
"
rgb
(
255
255
255
)
"
)
;
canvas
.
width
=
snapshot
.
width
;
canvas
.
height
=
snapshot
.
height
;
width
=
snapshot
.
width
;
height
=
snapshot
.
height
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
drawImage
(
snapshot
0
0
)
;
snapshot
.
close
(
)
;
return
canvas
.
toDataURL
(
"
image
/
png
"
"
"
)
;
}
catch
(
e
)
{
return
null
;
}
}
;
let
data
=
await
drawToCanvas
(
ratio
)
;
if
(
!
data
&
&
ratio
>
1
.
0
)
{
messages
.
push
(
{
level
:
"
warn
"
text
:
L10N
.
getStr
(
"
screenshotDPRDecreasedWarning
"
)
}
)
;
data
=
await
drawToCanvas
(
1
.
0
)
;
}
if
(
!
data
)
{
messages
.
push
(
{
level
:
"
error
"
text
:
L10N
.
getStr
(
"
screenshotRenderingError
"
)
}
)
;
}
if
(
data
)
{
simulateCameraFlash
(
browsingContext
)
;
}
return
{
data
height
width
filename
messages
}
;
}
exports
.
captureScreenshot
=
captureScreenshot
;
function
getFilename
(
defaultName
)
{
if
(
defaultName
)
{
return
defaultName
;
}
const
date
=
new
Date
(
)
;
const
monthString
=
(
date
.
getMonth
(
)
+
1
)
.
toString
(
)
.
padStart
(
2
"
0
"
)
;
const
dayString
=
(
date
.
getDate
(
)
+
1
)
.
toString
(
)
.
padStart
(
2
"
0
"
)
;
const
dateString
=
{
date
.
getFullYear
(
)
}
-
{
monthString
}
-
{
dayString
}
;
const
timeString
=
date
.
toTimeString
(
)
.
replace
(
/
:
/
g
"
.
"
)
.
split
(
"
"
)
[
0
]
;
return
(
L10N
.
getFormatStr
(
"
screenshotGeneratedFilename
"
dateString
timeString
)
+
"
.
png
"
)
;
}
