"
use
strict
"
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
FONT_PREVIEW_TEXT
=
"
Abc
"
;
const
FONT_PREVIEW_FONT_SIZE
=
40
;
const
FONT_PREVIEW_FILLSTYLE
=
"
black
"
;
const
FONT_PREVIEW_OFFSET
=
4
;
const
FONT_PREVIEW_OVERSAMPLING_FACTOR
=
2
;
const
FONT_NEED_WRAPPING_QUOTES_REGEX
=
/
^
[
^
'
"
]
.
*
/
;
function
getFontPreviewData
(
font
doc
options
)
{
options
=
options
|
|
{
}
;
const
previewText
=
options
.
previewText
|
|
FONT_PREVIEW_TEXT
;
const
previewTextLines
=
previewText
.
split
(
"
\
n
"
)
;
const
previewFontSize
=
options
.
previewFontSize
|
|
FONT_PREVIEW_FONT_SIZE
;
const
fillStyle
=
options
.
fillStyle
|
|
FONT_PREVIEW_FILLSTYLE
;
const
fontStyle
=
options
.
fontStyle
|
|
"
"
;
const
canvas
=
doc
.
createElementNS
(
XHTML_NS
"
canvas
"
)
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
const
fontParts
=
[
]
;
for
(
let
f
of
font
.
split
(
"
"
)
)
{
if
(
FONT_NEED_WRAPPING_QUOTES_REGEX
.
test
(
f
.
trim
(
)
)
)
{
f
=
"
{
f
}
"
;
}
fontParts
.
push
(
f
)
;
}
const
fontValue
=
{
fontStyle
}
{
previewFontSize
}
px
{
fontParts
.
join
(
"
"
)
}
serif
;
ctx
.
font
=
fontValue
;
ctx
.
fillStyle
=
fillStyle
;
const
previewTextLinesWidths
=
previewTextLines
.
map
(
previewTextLine
=
>
ctx
.
measureText
(
previewTextLine
)
.
width
)
;
const
textWidth
=
Math
.
round
(
Math
.
max
(
.
.
.
previewTextLinesWidths
)
)
;
const
simpleCanvasWidth
=
textWidth
+
FONT_PREVIEW_OFFSET
*
2
;
canvas
.
width
=
simpleCanvasWidth
*
FONT_PREVIEW_OVERSAMPLING_FACTOR
;
canvas
.
height
=
(
previewFontSize
*
previewTextLines
.
length
+
FONT_PREVIEW_OFFSET
*
2
)
*
FONT_PREVIEW_OVERSAMPLING_FACTOR
;
ctx
.
font
=
fontValue
;
ctx
.
fillStyle
=
fillStyle
;
ctx
.
scale
(
FONT_PREVIEW_OVERSAMPLING_FACTOR
FONT_PREVIEW_OVERSAMPLING_FACTOR
)
;
ctx
.
textBaseline
=
"
top
"
;
ctx
.
textAlign
=
"
center
"
;
const
horizontalTextPosition
=
simpleCanvasWidth
/
2
;
let
verticalTextPosition
=
FONT_PREVIEW_OFFSET
;
for
(
let
i
=
0
;
i
<
previewTextLines
.
length
;
i
+
+
)
{
ctx
.
fillText
(
previewTextLines
[
i
]
horizontalTextPosition
verticalTextPosition
)
;
verticalTextPosition
+
=
previewFontSize
;
}
const
dataURL
=
canvas
.
toDataURL
(
"
image
/
png
"
)
;
return
{
dataURL
size
:
textWidth
+
FONT_PREVIEW_OFFSET
*
2
ctx
}
;
}
exports
.
getFontPreviewData
=
getFontPreviewData
;
function
getRuleText
(
initialText
line
column
)
{
if
(
typeof
line
=
=
=
"
undefined
"
|
|
typeof
column
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
Location
information
is
missing
"
)
;
}
const
{
text
}
=
getTextAtLineColumn
(
initialText
line
column
)
;
const
res
=
InspectorUtils
.
getRuleBodyText
(
text
)
;
if
(
res
=
=
=
null
|
|
typeof
res
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
Couldn
'
t
find
rule
"
)
;
}
return
res
;
}
exports
.
getRuleText
=
getRuleText
;
function
getTextAtLineColumn
(
text
line
column
)
{
let
offset
;
if
(
line
>
1
)
{
const
rx
=
new
RegExp
(
"
(
?
:
[
^
\
\
r
\
\
n
\
\
f
]
*
(
?
:
\
\
r
\
\
n
|
\
\
n
|
\
\
r
|
\
\
f
)
)
{
"
+
(
line
-
1
)
+
"
}
"
)
;
offset
=
rx
.
exec
(
text
)
[
0
]
.
length
;
}
else
{
offset
=
0
;
}
offset
+
=
column
-
1
;
return
{
offset
text
:
text
.
substr
(
offset
)
}
;
}
exports
.
getTextAtLineColumn
=
getTextAtLineColumn
;
