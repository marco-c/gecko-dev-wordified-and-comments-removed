"
use
strict
"
;
const
{
formatDisplayName
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
frame
.
js
"
)
;
const
{
TYPES
getResourceWatcher
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
index
.
js
"
)
;
function
getThrownMessage
(
completion
)
{
try
{
if
(
completion
.
throw
.
getOwnPropertyDescriptor
)
{
return
completion
.
throw
.
getOwnPropertyDescriptor
(
"
message
"
)
.
value
;
}
else
if
(
completion
.
toString
)
{
return
completion
.
toString
(
)
;
}
}
catch
(
ex
)
{
}
return
"
Unknown
exception
"
;
}
module
.
exports
.
getThrownMessage
=
getThrownMessage
;
function
evalAndLogEvent
(
{
threadActor
frame
level
expression
bindings
}
)
{
const
frameLocation
=
threadActor
.
sourcesManager
.
getFrameLocation
(
frame
)
;
const
{
sourceActor
line
}
=
frameLocation
;
const
displayName
=
formatDisplayName
(
frame
)
;
if
(
isWorker
)
{
threadActor
.
targetActor
.
_consoleActor
.
evaluateJS
(
{
text
:
console
.
log
(
.
.
.
{
expression
}
)
bindings
:
{
displayName
.
.
.
bindings
}
url
:
sourceActor
.
url
lineNumber
:
line
disableBreaks
:
true
}
)
;
return
undefined
;
}
let
completion
;
threadActor
.
insideClientEvaluation
=
{
disableBreaks
:
true
}
;
try
{
completion
=
frame
.
evalWithBindings
(
expression
{
displayName
.
.
.
bindings
}
{
hideFromDebugger
:
true
}
)
;
}
finally
{
threadActor
.
insideClientEvaluation
=
null
;
}
let
value
;
if
(
!
completion
)
{
value
=
[
"
Evaluation
failed
"
]
;
}
else
if
(
"
return
"
in
completion
)
{
value
=
completion
.
return
;
}
else
{
value
=
[
getThrownMessage
(
completion
)
]
;
level
=
{
level
}
Error
;
}
if
(
value
&
&
typeof
value
.
unsafeDereference
=
=
=
"
function
"
)
{
value
=
value
.
unsafeDereference
(
)
;
}
ChromeUtils
.
addProfilerMarker
(
"
Debugger
log
point
"
undefined
value
)
;
emitConsoleMessage
(
threadActor
frameLocation
value
level
)
;
return
undefined
;
}
function
logEvent
(
{
threadActor
frame
}
)
{
const
frameLocation
=
threadActor
.
sourcesManager
.
getFrameLocation
(
frame
)
;
const
{
sourceActor
line
}
=
frameLocation
;
if
(
isWorker
)
{
const
bindings
=
{
}
;
for
(
let
i
=
0
;
i
<
frame
.
arguments
.
length
;
i
+
+
)
{
bindings
[
x
{
i
}
]
=
frame
.
arguments
[
i
]
;
}
threadActor
.
targetActor
.
_consoleActor
.
evaluateJS
(
{
text
:
console
.
log
(
{
Object
.
keys
(
bindings
)
.
join
(
"
"
)
}
)
bindings
url
:
sourceActor
.
url
lineNumber
:
line
disableBreaks
:
true
}
)
;
return
undefined
;
}
const
args
=
[
]
;
for
(
const
arg
of
frame
.
arguments
)
{
args
.
push
(
arg
&
&
typeof
arg
.
unsafeDereference
=
=
=
"
function
"
?
arg
.
unsafeDereference
(
)
:
arg
)
;
}
emitConsoleMessage
(
threadActor
frameLocation
args
"
logPoint
"
)
;
return
undefined
;
}
function
emitConsoleMessage
(
threadActor
frameLocation
args
level
)
{
const
targetActor
=
threadActor
.
targetActor
;
const
{
sourceActor
line
column
}
=
frameLocation
;
const
message
=
{
filename
:
sourceActor
.
url
lineNumber
:
line
columnNumber
:
column
arguments
:
args
level
timeStamp
:
ChromeUtils
.
dateNow
(
)
chromeContext
:
targetActor
.
actorID
&
&
/
conn
\
d
+
\
.
parentProcessTarget
\
d
+
/
.
test
(
targetActor
.
actorID
)
sourceId
:
sourceActor
.
internalSourceId
}
;
const
consoleMessageWatcher
=
getResourceWatcher
(
targetActor
TYPES
.
CONSOLE_MESSAGE
)
;
if
(
consoleMessageWatcher
)
{
consoleMessageWatcher
.
emitMessages
(
[
message
]
)
;
}
else
{
targetActor
.
_consoleActor
.
onConsoleAPICall
(
message
)
;
}
}
module
.
exports
.
evalAndLogEvent
=
evalAndLogEvent
;
module
.
exports
.
logEvent
=
logEvent
;
