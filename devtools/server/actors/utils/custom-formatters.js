"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
"
makeSideeffectFreeDebugger
"
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
eval
-
with
-
debugger
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
createValueGripForTarget
"
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
utils
.
js
"
true
)
;
const
_invalidCustomFormatterHooks
=
new
WeakSet
(
)
;
function
addInvalidCustomFormatterHooks
(
hook
)
{
if
(
!
hook
)
{
return
;
}
try
{
_invalidCustomFormatterHooks
.
add
(
hook
)
;
}
catch
(
e
)
{
console
.
error
(
"
Couldn
'
t
add
hook
to
the
WeakSet
"
hook
)
;
}
}
class
FormatterError
extends
Error
{
constructor
(
message
script
)
{
super
(
message
)
;
this
.
script
=
script
;
}
}
function
customFormatterHeader
(
objectActor
)
{
const
rawValue
=
objectActor
.
rawValue
(
)
;
const
globalWrapper
=
Cu
.
getGlobalForObject
(
rawValue
)
;
const
global
=
globalWrapper
?
.
wrappedJSObject
;
if
(
!
global
|
|
!
Array
.
isArray
(
global
.
devtoolsFormatters
)
)
{
return
null
;
}
const
customFormatterTooDeep
=
(
objectActor
.
hooks
.
customFormatterObjectTagDepth
|
|
0
)
>
20
;
if
(
customFormatterTooDeep
)
{
logCustomFormatterError
(
globalWrapper
Too
deep
hierarchy
of
inlined
custom
previews
)
;
return
null
;
}
const
dbg
=
makeSideeffectFreeDebugger
(
)
;
try
{
const
targetActor
=
objectActor
.
thread
.
_parent
;
const
{
customFormatterConfig
customFormatterObjectTagDepth
}
=
objectActor
.
hooks
;
const
dbgGlobal
=
dbg
.
makeGlobalObjectReference
(
global
)
;
const
valueDbgObj
=
dbgGlobal
.
makeDebuggeeValue
(
rawValue
)
;
const
configDbgObj
=
dbgGlobal
.
makeDebuggeeValue
(
customFormatterConfig
)
;
for
(
const
[
customFormatterIndex
formatter
]
of
global
.
devtoolsFormatters
.
entries
(
)
)
{
if
(
_invalidCustomFormatterHooks
.
has
(
formatter
)
)
{
continue
;
}
try
{
const
rv
=
processFormatterForHeader
(
{
customFormatterIndex
customFormatterObjectTagDepth
valueDbgObj
configDbgObj
formatter
dbgGlobal
globalWrapper
global
targetActor
}
)
;
if
(
rv
)
{
dbg
.
removeAllDebuggees
(
)
;
return
rv
;
}
}
catch
(
e
)
{
logCustomFormatterError
(
globalWrapper
e
instanceof
FormatterError
?
devtoolsFormatters
[
{
customFormatterIndex
}
]
.
{
e
.
message
}
:
devtoolsFormatters
[
{
customFormatterIndex
}
]
couldn
'
t
be
run
:
{
e
.
message
}
e
.
script
)
;
addInvalidCustomFormatterHooks
(
formatter
)
;
}
}
}
finally
{
dbg
.
removeAllDebuggees
(
)
;
}
return
null
;
}
exports
.
customFormatterHeader
=
customFormatterHeader
;
function
processFormatterForHeader
(
{
customFormatterIndex
customFormatterObjectTagDepth
formatter
valueDbgObj
configDbgObj
dbgGlobal
targetActor
}
)
{
const
headerType
=
typeof
formatter
?
.
header
;
if
(
headerType
!
=
=
"
function
"
)
{
throw
new
FormatterError
(
header
should
be
a
function
got
{
headerType
}
)
;
}
const
formatterHeaderDbgValue
=
dbgGlobal
.
makeDebuggeeValue
(
formatter
.
header
)
;
const
header
=
formatterHeaderDbgValue
.
call
(
dbgGlobal
valueDbgObj
configDbgObj
)
;
if
(
header
?
.
return
=
=
=
null
)
{
return
null
;
}
if
(
header
?
.
return
?
.
class
!
=
=
"
Array
"
)
{
let
errorMsg
=
"
"
;
if
(
header
=
=
null
)
{
errorMsg
=
header
was
not
run
because
it
has
side
effects
;
}
else
if
(
"
return
"
in
header
)
{
let
type
=
typeof
header
.
return
;
if
(
type
=
=
=
"
object
"
)
{
type
=
header
.
return
?
.
class
;
}
errorMsg
=
header
should
return
an
array
got
{
type
}
;
}
else
if
(
"
throw
"
in
header
)
{
errorMsg
=
header
threw
:
{
header
.
throw
.
getProperty
(
"
message
"
)
?
.
return
}
;
}
throw
new
FormatterError
(
errorMsg
formatterHeaderDbgValue
?
.
script
)
;
}
const
rawHeader
=
header
.
return
.
unsafeDereference
(
)
;
if
(
rawHeader
.
length
=
=
=
0
)
{
throw
new
FormatterError
(
header
returned
an
empty
array
formatterHeaderDbgValue
?
.
script
)
;
}
const
sanitizedHeader
=
buildJsonMlFromCustomFormatterHookResult
(
header
.
return
customFormatterObjectTagDepth
targetActor
)
;
let
hasBody
=
false
;
const
hasBodyType
=
typeof
formatter
?
.
hasBody
;
if
(
hasBodyType
=
=
=
"
function
"
)
{
const
formatterHasBodyDbgValue
=
dbgGlobal
.
makeDebuggeeValue
(
formatter
.
hasBody
)
;
hasBody
=
formatterHasBodyDbgValue
.
call
(
dbgGlobal
valueDbgObj
configDbgObj
)
;
if
(
hasBody
=
=
null
)
{
throw
new
FormatterError
(
hasBody
was
not
run
because
it
has
side
effects
formatterHasBodyDbgValue
?
.
script
)
;
}
else
if
(
"
throw
"
in
hasBody
)
{
throw
new
FormatterError
(
hasBody
threw
:
{
hasBody
.
throw
.
getProperty
(
"
message
"
)
?
.
return
}
formatterHasBodyDbgValue
?
.
script
)
;
}
}
else
if
(
hasBodyType
!
=
=
"
undefined
"
)
{
throw
new
FormatterError
(
hasBody
should
be
a
function
got
{
hasBodyType
}
)
;
}
return
{
useCustomFormatter
:
true
customFormatterIndex
header
:
sanitizedHeader
hasBody
:
!
!
hasBody
?
.
return
}
;
}
async
function
customFormatterBody
(
objectActor
customFormatterIndex
)
{
const
rawValue
=
objectActor
.
rawValue
(
)
;
const
globalWrapper
=
Cu
.
getGlobalForObject
(
rawValue
)
;
const
global
=
globalWrapper
?
.
wrappedJSObject
;
const
dbg
=
makeSideeffectFreeDebugger
(
)
;
try
{
const
targetActor
=
objectActor
.
thread
.
_parent
;
const
{
customFormatterConfig
customFormatterObjectTagDepth
}
=
objectActor
.
hooks
;
const
dbgGlobal
=
dbg
.
makeGlobalObjectReference
(
global
)
;
const
formatter
=
global
.
devtoolsFormatters
[
customFormatterIndex
]
;
if
(
_invalidCustomFormatterHooks
.
has
(
formatter
)
)
{
return
{
customFormatterBody
:
null
}
;
}
const
bodyType
=
typeof
formatter
?
.
body
;
if
(
bodyType
!
=
=
"
function
"
)
{
logCustomFormatterError
(
globalWrapper
devtoolsFormatters
[
{
customFormatterIndex
}
]
.
body
should
be
a
function
got
{
bodyType
}
)
;
addInvalidCustomFormatterHooks
(
formatter
)
;
return
{
customFormatterBody
:
null
}
;
}
const
formatterBodyDbgValue
=
formatter
&
&
dbgGlobal
.
makeDebuggeeValue
(
formatter
.
body
)
;
const
body
=
formatterBodyDbgValue
.
call
(
dbgGlobal
dbgGlobal
.
makeDebuggeeValue
(
rawValue
)
dbgGlobal
.
makeDebuggeeValue
(
customFormatterConfig
)
)
;
if
(
body
?
.
return
?
.
class
=
=
=
"
Array
"
)
{
const
rawBody
=
body
.
return
.
unsafeDereference
(
)
;
if
(
rawBody
.
length
=
=
=
0
)
{
logCustomFormatterError
(
globalWrapper
devtoolsFormatters
[
{
customFormatterIndex
}
]
.
body
returned
an
empty
array
formatterBodyDbgValue
?
.
script
)
;
addInvalidCustomFormatterHooks
(
formatter
)
;
return
{
customFormatterBody
:
null
}
;
}
const
customFormatterBodyJsonMl
=
buildJsonMlFromCustomFormatterHookResult
(
body
.
return
customFormatterObjectTagDepth
targetActor
)
;
return
{
customFormatterBody
:
customFormatterBodyJsonMl
}
;
}
let
errorMsg
=
"
"
;
if
(
body
=
=
null
)
{
errorMsg
=
devtoolsFormatters
[
{
customFormatterIndex
}
]
.
body
was
not
run
because
it
has
side
effects
;
}
else
if
(
"
return
"
in
body
)
{
let
type
=
body
.
return
=
=
=
null
?
"
null
"
:
typeof
body
.
return
;
if
(
type
=
=
=
"
object
"
)
{
type
=
body
.
return
?
.
class
;
}
errorMsg
=
devtoolsFormatters
[
{
customFormatterIndex
}
]
.
body
should
return
an
array
got
{
type
}
;
}
else
if
(
"
throw
"
in
body
)
{
errorMsg
=
devtoolsFormatters
[
{
customFormatterIndex
}
]
.
body
threw
:
{
body
.
throw
.
getProperty
(
"
message
"
)
?
.
return
}
;
}
logCustomFormatterError
(
globalWrapper
errorMsg
formatterBodyDbgValue
?
.
script
)
;
addInvalidCustomFormatterHooks
(
formatter
)
;
}
catch
(
e
)
{
logCustomFormatterError
(
globalWrapper
Custom
formatter
with
index
{
customFormatterIndex
}
couldn
'
t
be
run
:
{
e
.
message
}
)
;
}
finally
{
dbg
.
removeAllDebuggees
(
)
;
}
return
{
}
;
}
exports
.
customFormatterBody
=
customFormatterBody
;
function
logCustomFormatterError
(
window
errorMsg
script
)
{
const
scriptErrorClass
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
;
const
scriptError
=
scriptErrorClass
.
createInstance
(
Ci
.
nsIScriptError
)
;
const
{
url
source
startLine
startColumn
}
=
script
?
?
{
}
;
scriptError
.
initWithWindowID
(
Custom
formatter
failed
:
{
errorMsg
}
url
source
startLine
startColumn
Ci
.
nsIScriptError
.
errorFlag
"
devtoolsFormatter
"
window
.
windowGlobalChild
.
innerWindowId
)
;
Services
.
console
.
logMessage
(
scriptError
)
;
}
function
buildJsonMlFromCustomFormatterHookResult
(
jsonMlDbgObj
customFormatterObjectTagDepth
targetActor
)
{
const
tagName
=
jsonMlDbgObj
.
getProperty
(
0
)
?
.
return
;
if
(
typeof
tagName
!
=
=
"
string
"
)
{
const
tagNameType
=
tagName
?
.
class
|
|
(
tagName
=
=
=
null
?
"
null
"
:
typeof
tagName
)
;
throw
new
Error
(
tagName
should
be
a
string
got
{
tagNameType
}
)
;
}
const
rest
=
[
]
;
const
dbgObjLength
=
jsonMlDbgObj
.
getProperty
(
"
length
"
)
?
.
return
|
|
0
;
for
(
let
i
=
1
;
i
<
dbgObjLength
;
i
+
+
)
{
rest
.
push
(
jsonMlDbgObj
.
getProperty
(
i
)
?
.
return
)
;
}
const
attributesDbgObj
=
rest
[
0
]
&
&
rest
[
0
]
.
class
=
=
=
"
Object
"
?
rest
[
0
]
:
null
;
const
childrenDbgObj
=
attributesDbgObj
?
rest
.
slice
(
1
)
:
rest
;
if
(
tagName
=
=
"
object
"
)
{
if
(
!
attributesDbgObj
)
{
throw
new
Error
(
"
object
"
tag
should
have
attributes
)
;
}
return
processObjectTag
(
attributesDbgObj
customFormatterObjectTagDepth
targetActor
)
;
}
const
jsonMl
=
[
tagName
{
}
]
;
if
(
attributesDbgObj
)
{
jsonMl
[
1
]
.
style
=
attributesDbgObj
.
getProperty
(
"
style
"
)
?
.
return
;
}
for
(
const
childDbgObj
of
childrenDbgObj
)
{
const
childDbgObjType
=
typeof
childDbgObj
;
if
(
childDbgObj
?
.
class
=
=
=
"
Array
"
)
{
jsonMl
.
push
(
buildJsonMlFromCustomFormatterHookResult
(
childDbgObj
customFormatterObjectTagDepth
targetActor
)
)
;
}
else
if
(
childDbgObjType
=
=
"
object
"
&
&
childDbgObj
!
=
=
null
)
{
jsonMl
.
push
(
"
[
object
Object
]
"
)
;
}
else
{
const
grip
=
createValueGripForTarget
(
targetActor
childDbgObj
)
;
if
(
grip
!
=
=
null
)
{
jsonMl
.
push
(
grip
)
;
}
}
}
return
jsonMl
;
}
function
processObjectTag
(
attributesDbgObj
customFormatterObjectTagDepth
targetActor
)
{
const
objectDbgObj
=
attributesDbgObj
.
getProperty
(
"
object
"
)
?
.
return
;
if
(
typeof
objectDbgObj
=
=
"
undefined
"
)
{
throw
new
Error
(
attribute
of
"
object
"
tag
should
have
an
"
object
"
property
)
;
}
const
configRv
=
attributesDbgObj
.
getProperty
(
"
config
"
)
;
const
grip
=
createValueGripForTarget
(
targetActor
objectDbgObj
0
{
customFormatterConfig
:
configRv
?
.
return
?
.
unsafeDereference
(
)
customFormatterObjectTagDepth
:
(
customFormatterObjectTagDepth
|
|
0
)
+
1
}
)
;
return
grip
;
}
