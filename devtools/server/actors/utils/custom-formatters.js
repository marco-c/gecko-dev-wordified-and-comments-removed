"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
"
makeSideeffectFreeDebugger
"
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
eval
-
with
-
debugger
.
js
"
true
)
;
const
_invalidCustomFormatterHooks
=
new
WeakSet
(
)
;
class
FormatterError
extends
Error
{
constructor
(
message
script
)
{
super
(
message
)
;
this
.
script
=
script
;
}
}
function
customFormatterHeader
(
rawValue
)
{
const
globalWrapper
=
Cu
.
getGlobalForObject
(
rawValue
)
;
const
global
=
globalWrapper
?
.
wrappedJSObject
;
if
(
!
global
|
|
!
Array
.
isArray
(
global
.
devtoolsFormatters
)
)
{
return
null
;
}
const
dbg
=
makeSideeffectFreeDebugger
(
)
;
try
{
const
dbgGlobal
=
dbg
.
makeGlobalObjectReference
(
global
)
;
const
debuggeeValue
=
dbgGlobal
.
makeDebuggeeValue
(
rawValue
)
;
for
(
const
[
customFormatterIndex
formatter
]
of
global
.
devtoolsFormatters
.
entries
(
)
)
{
if
(
_invalidCustomFormatterHooks
.
has
(
formatter
)
)
{
continue
;
}
try
{
const
rv
=
processFormatterForHeader
(
{
customFormatterIndex
debuggeeValue
formatter
dbgGlobal
globalWrapper
global
}
)
;
if
(
rv
)
{
return
rv
;
}
}
catch
(
e
)
{
_invalidCustomFormatterHooks
.
add
(
formatter
)
;
logCustomFormatterError
(
globalWrapper
e
instanceof
FormatterError
?
devtoolsFormatters
[
{
customFormatterIndex
}
]
.
{
e
.
message
}
:
devtoolsFormatters
[
{
customFormatterIndex
}
]
couldn
'
t
be
run
:
{
e
.
message
}
e
.
script
)
;
}
}
}
finally
{
dbg
.
removeAllDebuggees
(
)
;
}
return
null
;
}
exports
.
customFormatterHeader
=
customFormatterHeader
;
function
processFormatterForHeader
(
{
customFormatterIndex
formatter
debuggeeValue
dbgGlobal
global
}
)
{
const
headerType
=
typeof
formatter
?
.
header
;
if
(
headerType
!
=
=
"
function
"
)
{
throw
new
FormatterError
(
header
should
be
a
function
got
{
headerType
}
)
;
}
const
formatterHeaderDbgValue
=
dbgGlobal
.
makeDebuggeeValue
(
formatter
.
header
)
;
const
header
=
formatterHeaderDbgValue
.
call
(
dbgGlobal
debuggeeValue
)
;
if
(
header
?
.
return
=
=
=
null
)
{
return
null
;
}
if
(
header
?
.
return
?
.
class
!
=
=
"
Array
"
)
{
let
errorMsg
=
"
"
;
if
(
header
=
=
null
)
{
errorMsg
=
header
was
not
run
because
it
has
side
effects
;
}
else
if
(
"
return
"
in
header
)
{
let
type
=
typeof
header
.
return
;
if
(
type
=
=
=
"
object
"
)
{
type
=
header
.
return
?
.
class
;
}
errorMsg
=
header
should
return
an
array
got
{
type
}
;
}
else
if
(
"
throw
"
in
header
)
{
errorMsg
=
header
threw
:
{
header
.
throw
.
getProperty
(
"
message
"
)
?
.
return
}
;
}
throw
new
FormatterError
(
errorMsg
formatterHeaderDbgValue
?
.
script
)
;
}
const
rawHeader
=
header
.
return
.
unsafeDereference
(
)
;
if
(
rawHeader
.
length
=
=
=
0
)
{
throw
new
FormatterError
(
header
returned
an
empty
array
formatterHeaderDbgValue
?
.
script
)
;
}
let
hasBody
=
false
;
const
hasBodyType
=
typeof
formatter
?
.
hasBody
;
if
(
hasBodyType
=
=
=
"
function
"
)
{
const
formatterHasBodyDbgValue
=
dbgGlobal
.
makeDebuggeeValue
(
formatter
.
hasBody
)
;
hasBody
=
formatterHasBodyDbgValue
.
call
(
dbgGlobal
debuggeeValue
)
;
if
(
hasBody
=
=
null
)
{
throw
new
FormatterError
(
hasBody
was
not
run
because
it
has
side
effects
formatterHasBodyDbgValue
?
.
script
)
;
}
else
if
(
"
throw
"
in
hasBody
)
{
throw
new
FormatterError
(
hasBody
threw
:
{
hasBody
.
throw
.
getProperty
(
"
message
"
)
?
.
return
}
formatterHasBodyDbgValue
?
.
script
)
;
}
}
else
if
(
hasBodyType
!
=
=
"
undefined
"
)
{
throw
new
FormatterError
(
hasBody
should
be
a
function
got
{
hasBodyType
}
)
;
}
return
{
useCustomFormatter
:
true
customFormatterIndex
header
:
global
.
structuredClone
(
rawHeader
)
hasBody
:
!
!
hasBody
?
.
return
}
;
}
async
function
customFormatterBody
(
rawValue
customFormatterIndex
)
{
const
globalWrapper
=
Cu
.
getGlobalForObject
(
rawValue
)
;
const
global
=
globalWrapper
?
.
wrappedJSObject
;
const
dbg
=
makeSideeffectFreeDebugger
(
)
;
try
{
const
dbgGlobal
=
dbg
.
makeGlobalObjectReference
(
global
)
;
const
formatter
=
global
.
devtoolsFormatters
[
customFormatterIndex
]
;
if
(
_invalidCustomFormatterHooks
.
has
(
formatter
)
)
{
return
{
customFormatterBody
:
null
}
;
}
const
bodyType
=
typeof
formatter
?
.
body
;
if
(
bodyType
!
=
=
"
function
"
)
{
_invalidCustomFormatterHooks
.
add
(
formatter
)
;
logCustomFormatterError
(
globalWrapper
devtoolsFormatters
[
{
customFormatterIndex
}
]
.
body
should
be
a
function
got
{
bodyType
}
)
;
return
{
customFormatterBody
:
null
}
;
}
const
formatterBodyDbgValue
=
formatter
&
&
dbgGlobal
.
makeDebuggeeValue
(
formatter
.
body
)
;
const
body
=
formatterBodyDbgValue
.
call
(
dbgGlobal
dbgGlobal
.
makeDebuggeeValue
(
rawValue
)
)
;
if
(
body
?
.
return
?
.
class
=
=
=
"
Array
"
)
{
const
rawBody
=
body
.
return
.
unsafeDereference
(
)
;
if
(
rawBody
.
length
=
=
=
0
)
{
_invalidCustomFormatterHooks
.
add
(
formatter
)
;
logCustomFormatterError
(
globalWrapper
devtoolsFormatters
[
{
customFormatterIndex
}
]
.
body
returned
an
empty
array
formatterBodyDbgValue
?
.
script
)
;
return
{
customFormatterBody
:
null
}
;
}
return
{
customFormatterBody
:
global
.
structuredClone
(
rawBody
)
}
;
}
_invalidCustomFormatterHooks
.
add
(
formatter
)
;
let
errorMsg
=
"
"
;
if
(
body
=
=
null
)
{
errorMsg
=
devtoolsFormatters
[
{
customFormatterIndex
}
]
.
body
was
not
run
because
it
has
side
effects
;
}
else
if
(
"
return
"
in
body
)
{
let
type
=
body
.
return
=
=
=
null
?
"
null
"
:
typeof
body
.
return
;
if
(
type
=
=
=
"
object
"
)
{
type
=
body
.
return
?
.
class
;
}
errorMsg
=
devtoolsFormatters
[
{
customFormatterIndex
}
]
.
body
should
return
an
array
got
{
type
}
;
}
else
if
(
"
throw
"
in
body
)
{
errorMsg
=
devtoolsFormatters
[
{
customFormatterIndex
}
]
.
body
threw
:
{
body
.
throw
.
getProperty
(
"
message
"
)
?
.
return
}
;
}
logCustomFormatterError
(
globalWrapper
errorMsg
formatterBodyDbgValue
?
.
script
)
;
}
catch
(
e
)
{
logCustomFormatterError
(
globalWrapper
Custom
formatter
with
index
{
customFormatterIndex
}
couldn
'
t
be
run
:
{
e
.
message
}
)
;
}
finally
{
dbg
.
removeAllDebuggees
(
)
;
}
return
{
}
;
}
exports
.
customFormatterBody
=
customFormatterBody
;
function
logCustomFormatterError
(
window
errorMsg
script
)
{
const
scriptErrorClass
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
;
const
scriptError
=
scriptErrorClass
.
createInstance
(
Ci
.
nsIScriptError
)
;
const
{
url
source
startLine
startColumn
}
=
script
?
?
{
}
;
scriptError
.
initWithWindowID
(
Custom
formatter
failed
:
{
errorMsg
}
url
source
startLine
startColumn
Ci
.
nsIScriptError
.
errorFlag
"
devtoolsFormatter
"
window
.
windowGlobalChild
.
innerWindowId
)
;
Services
.
console
.
logMessage
(
scriptError
)
;
}
