"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
assert
fetch
}
=
DevToolsUtils
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
SourceLocation
}
=
require
(
"
devtools
/
server
/
actors
/
common
"
)
;
const
Services
=
require
(
"
Services
"
)
;
loader
.
lazyRequireGetter
(
this
"
SourceActor
"
"
devtools
/
server
/
actors
/
source
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isEvalSource
"
"
devtools
/
server
/
actors
/
source
"
true
)
;
function
TabSources
(
threadActor
allowSourceFn
=
(
)
=
>
true
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_thread
=
threadActor
;
this
.
_autoBlackBox
=
true
;
this
.
allowSource
=
source
=
>
{
return
!
isHiddenSource
(
source
)
&
&
allowSourceFn
(
source
)
;
}
;
this
.
blackBoxedSources
=
new
Map
(
)
;
this
.
neverAutoBlackBoxSources
=
new
Set
(
)
;
this
.
_sourceActors
=
new
Map
(
)
;
this
.
_urlContents
=
new
Map
(
)
;
this
.
_urlWaiters
=
new
Map
(
)
;
this
.
_sourcesByInternalSourceId
=
null
;
if
(
!
isWorker
)
{
Services
.
obs
.
addObserver
(
this
"
devtools
-
html
-
content
"
)
;
}
}
const
MINIFIED_SOURCE_REGEXP
=
/
\
bmin
\
.
js
/
;
TabSources
.
prototype
=
{
destroy
(
)
{
if
(
!
isWorker
)
{
Services
.
obs
.
removeObserver
(
this
"
devtools
-
html
-
content
"
)
;
}
}
setOptions
:
function
(
options
)
{
let
shouldReset
=
false
;
if
(
"
autoBlackBox
"
in
options
)
{
shouldReset
=
true
;
this
.
_autoBlackBox
=
options
.
autoBlackBox
;
}
if
(
shouldReset
)
{
this
.
reset
(
)
;
}
}
reset
:
function
(
)
{
this
.
_sourceActors
=
new
Map
(
)
;
this
.
_urlContents
=
new
Map
(
)
;
this
.
_urlWaiters
=
new
Map
(
)
;
this
.
_sourcesByInternalSourceId
=
null
;
}
source
:
function
(
{
source
isInlineSource
contentType
}
)
{
assert
(
source
"
TabSources
.
prototype
.
source
needs
a
source
"
)
;
if
(
!
this
.
allowSource
(
source
)
)
{
return
null
;
}
if
(
this
.
_sourceActors
.
has
(
source
)
)
{
return
this
.
_sourceActors
.
get
(
source
)
;
}
const
actor
=
new
SourceActor
(
{
thread
:
this
.
_thread
source
isInlineSource
contentType
}
)
;
this
.
_thread
.
threadLifetimePool
.
manage
(
actor
)
;
if
(
this
.
_autoBlackBox
&
&
!
this
.
neverAutoBlackBoxSources
.
has
(
actor
.
url
)
&
&
this
.
_isMinifiedURL
(
actor
.
url
)
)
{
this
.
blackBox
(
actor
.
url
)
;
this
.
neverAutoBlackBoxSources
.
add
(
actor
.
url
)
;
}
this
.
_sourceActors
.
set
(
source
actor
)
;
if
(
this
.
_sourcesByInternalSourceId
&
&
source
.
id
)
{
this
.
_sourcesByInternalSourceId
.
set
(
source
.
id
source
)
;
}
this
.
emit
(
"
newSource
"
actor
)
;
return
actor
;
}
_getSourceActor
:
function
(
source
)
{
if
(
this
.
_sourceActors
.
has
(
source
)
)
{
return
this
.
_sourceActors
.
get
(
source
)
;
}
return
null
;
}
hasSourceActor
:
function
(
source
)
{
return
!
!
this
.
_getSourceActor
(
source
)
;
}
getSourceActor
:
function
(
source
)
{
const
sourceActor
=
this
.
_getSourceActor
(
source
)
;
if
(
!
sourceActor
)
{
throw
new
Error
(
"
getSource
:
could
not
find
source
actor
for
"
+
(
source
.
url
|
|
"
source
"
)
)
;
}
return
sourceActor
;
}
getOrCreateSourceActor
(
source
)
{
try
{
source
=
this
.
_thread
.
dbg
.
adoptSource
(
source
)
;
}
catch
(
e
)
{
if
(
/
is
in
the
same
compartment
as
this
debugger
/
.
test
(
e
)
)
{
return
null
;
}
throw
e
;
}
if
(
this
.
hasSourceActor
(
source
)
)
{
return
this
.
getSourceActor
(
source
)
;
}
return
this
.
createSourceActor
(
source
)
;
}
getSourceActorByInternalSourceId
:
function
(
id
)
{
if
(
!
this
.
_sourcesByInternalSourceId
)
{
this
.
_sourcesByInternalSourceId
=
new
Map
(
)
;
for
(
const
source
of
this
.
_thread
.
dbg
.
findSources
(
)
)
{
if
(
source
.
id
)
{
this
.
_sourcesByInternalSourceId
.
set
(
source
.
id
source
)
;
}
}
}
const
source
=
this
.
_sourcesByInternalSourceId
.
get
(
id
)
;
if
(
source
)
{
return
this
.
getOrCreateSourceActor
(
source
)
;
}
return
null
;
}
getSourceActorsByURL
:
function
(
url
)
{
const
rv
=
[
]
;
if
(
url
)
{
for
(
const
[
actor
]
of
this
.
_sourceActors
)
{
if
(
actor
.
url
=
=
=
url
)
{
rv
.
push
(
actor
)
;
}
}
}
return
rv
;
}
getSourceActorById
(
actorId
)
{
for
(
const
[
actor
]
of
this
.
_sourceActors
)
{
if
(
actor
.
actorID
=
=
actorId
)
{
return
actor
;
}
}
return
null
;
}
_isMinifiedURL
:
function
(
uri
)
{
if
(
!
uri
)
{
return
false
;
}
try
{
const
url
=
new
URL
(
uri
)
;
const
pathname
=
url
.
pathname
;
return
MINIFIED_SOURCE_REGEXP
.
test
(
pathname
.
slice
(
pathname
.
lastIndexOf
(
"
/
"
)
+
1
)
)
;
}
catch
(
e
)
{
return
MINIFIED_SOURCE_REGEXP
.
test
(
uri
)
;
}
}
isInlineScript
(
source
)
{
try
{
const
e
=
source
.
element
?
source
.
element
.
unsafeDereference
(
)
:
null
;
return
e
&
&
e
.
tagName
=
=
=
"
SCRIPT
"
&
&
!
e
.
hasAttribute
(
"
src
"
)
;
}
catch
(
e
)
{
DevToolsUtils
.
reportException
(
"
TabSources
.
isInlineScript
"
e
)
;
return
false
;
}
}
createSourceActor
:
function
(
source
)
{
const
url
=
isEvalSource
(
source
)
?
null
:
source
.
url
;
const
spec
=
{
source
}
;
if
(
this
.
isInlineScript
(
source
)
)
{
if
(
source
.
introductionScript
)
{
spec
.
contentType
=
"
text
/
javascript
"
;
}
else
{
spec
.
isInlineSource
=
true
;
}
}
else
if
(
source
.
introductionType
=
=
=
"
wasm
"
)
{
spec
.
contentType
=
"
text
/
wasm
"
;
}
else
if
(
source
.
introductionType
=
=
=
"
debugger
eval
"
)
{
spec
.
contentType
=
"
text
/
javascript
"
;
}
else
if
(
url
)
{
if
(
url
.
indexOf
(
"
javascript
:
"
)
=
=
=
0
|
|
url
=
=
=
"
debugger
eval
code
"
|
|
url
=
=
=
"
sandbox
eval
code
"
)
{
spec
.
contentType
=
"
text
/
javascript
"
;
}
else
{
try
{
const
pathname
=
new
URL
(
url
)
.
pathname
;
const
filename
=
pathname
.
slice
(
pathname
.
lastIndexOf
(
"
/
"
)
+
1
)
;
const
index
=
filename
.
lastIndexOf
(
"
.
"
)
;
const
extension
=
index
>
=
0
?
filename
.
slice
(
index
+
1
)
:
"
"
;
if
(
extension
=
=
=
"
xml
"
)
{
spec
.
isInlineSource
=
true
;
}
else
if
(
extension
=
=
=
"
js
"
|
|
extension
=
=
"
sjs
"
)
{
spec
.
contentType
=
"
text
/
javascript
"
;
}
}
catch
(
e
)
{
const
filename
=
url
;
const
index
=
filename
.
lastIndexOf
(
"
.
"
)
;
const
extension
=
index
>
=
0
?
filename
.
slice
(
index
+
1
)
:
"
"
;
if
(
extension
=
=
=
"
js
"
)
{
spec
.
contentType
=
"
text
/
javascript
"
;
}
}
}
}
else
{
spec
.
contentType
=
"
text
/
javascript
"
;
}
return
this
.
source
(
spec
)
;
}
getScriptOffsetLocation
:
function
(
script
offset
)
{
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
offset
)
;
return
new
SourceLocation
(
this
.
createSourceActor
(
script
.
source
)
lineNumber
columnNumber
)
;
}
getFrameLocation
:
function
(
frame
)
{
if
(
!
frame
|
|
!
frame
.
script
)
{
return
new
SourceLocation
(
)
;
}
return
this
.
getScriptOffsetLocation
(
frame
.
script
frame
.
offset
)
;
}
isBlackBoxed
:
function
(
url
line
column
)
{
const
ranges
=
this
.
blackBoxedSources
.
get
(
url
)
;
if
(
!
ranges
)
{
return
this
.
blackBoxedSources
.
has
(
url
)
;
}
const
range
=
ranges
.
find
(
r
=
>
isLocationInRange
(
{
line
column
}
r
)
)
;
return
!
!
range
;
}
isFrameBlackBoxed
:
function
(
frame
)
{
const
{
url
line
column
}
=
this
.
getFrameLocation
(
frame
)
;
return
this
.
isBlackBoxed
(
url
line
column
)
;
}
blackBox
:
function
(
url
range
)
{
if
(
!
range
)
{
return
this
.
blackBoxedSources
.
set
(
url
null
)
;
}
const
ranges
=
this
.
blackBoxedSources
.
get
(
url
)
|
|
[
]
;
const
index
=
ranges
.
findIndex
(
r
=
>
r
.
end
.
line
<
=
range
.
start
.
line
&
&
r
.
end
.
column
<
=
range
.
start
.
column
)
;
ranges
.
splice
(
index
+
1
0
range
)
;
this
.
blackBoxedSources
.
set
(
url
ranges
)
;
return
true
;
}
unblackBox
:
function
(
url
range
)
{
if
(
!
range
)
{
return
this
.
blackBoxedSources
.
delete
(
url
)
;
}
const
ranges
=
this
.
blackBoxedSources
.
get
(
url
)
;
const
index
=
ranges
.
findIndex
(
r
=
>
r
.
start
.
line
=
=
=
range
.
start
.
line
&
&
r
.
start
.
column
=
=
=
range
.
start
.
column
&
&
r
.
end
.
line
=
=
=
range
.
end
.
line
&
&
r
.
end
.
column
=
=
=
range
.
end
.
column
)
;
if
(
index
!
=
=
-
1
)
{
ranges
.
splice
(
index
1
)
;
}
if
(
ranges
.
length
=
=
=
0
)
{
return
this
.
blackBoxedSources
.
delete
(
url
)
;
}
return
this
.
blackBoxedSources
.
set
(
url
ranges
)
;
}
iter
:
function
(
)
{
return
[
.
.
.
this
.
_sourceActors
.
values
(
)
]
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
devtools
-
html
-
content
"
)
{
const
{
parserID
uri
contents
complete
}
=
JSON
.
parse
(
data
)
;
if
(
this
.
_urlContents
.
has
(
uri
)
)
{
const
existing
=
this
.
_urlContents
.
get
(
uri
)
;
if
(
existing
.
parserID
=
=
parserID
)
{
assert
(
!
existing
.
complete
)
;
existing
.
content
=
existing
.
content
+
contents
;
existing
.
complete
=
complete
;
if
(
complete
)
{
const
waiters
=
this
.
_urlWaiters
.
get
(
uri
)
;
if
(
waiters
)
{
for
(
const
waiter
of
waiters
)
{
waiter
(
)
;
}
this
.
_urlWaiters
.
delete
(
uri
)
;
}
}
}
}
else
{
this
.
_urlContents
.
set
(
uri
{
content
:
contents
complete
contentType
:
"
text
/
html
"
parserID
}
)
;
}
}
}
urlContents
(
url
partial
canUseCache
)
{
if
(
this
.
_urlContents
.
has
(
url
)
)
{
const
data
=
this
.
_urlContents
.
get
(
url
)
;
if
(
!
partial
&
&
!
data
.
complete
)
{
return
new
Promise
(
resolve
=
>
{
if
(
!
this
.
_urlWaiters
.
has
(
url
)
)
{
this
.
_urlWaiters
.
set
(
url
[
]
)
;
}
this
.
_urlWaiters
.
get
(
url
)
.
push
(
resolve
)
;
}
)
.
then
(
(
)
=
>
{
assert
(
data
.
complete
)
;
return
{
content
:
data
.
content
contentType
:
data
.
contentType
}
;
}
)
;
}
return
{
content
:
data
.
content
contentType
:
data
.
contentType
}
;
}
return
this
.
_fetchURLContents
(
url
partial
canUseCache
)
;
}
_fetchURLContents
:
async
function
(
url
partial
canUseCache
)
{
let
loadFromCache
=
canUseCache
;
if
(
canUseCache
&
&
this
.
_thread
.
_parent
.
_getCacheDisabled
)
{
loadFromCache
=
!
this
.
_thread
.
_parent
.
_getCacheDisabled
(
)
;
}
const
win
=
this
.
_thread
.
_parent
.
window
;
let
principal
cacheKey
;
if
(
!
isWorker
&
&
win
instanceof
Ci
.
nsIDOMWindow
)
{
const
docShell
=
win
.
docShell
;
const
channel
=
docShell
.
currentDocumentChannel
;
principal
=
channel
.
loadInfo
.
loadingPrincipal
;
if
(
loadFromCache
&
&
docShell
.
currentDocumentChannel
instanceof
Ci
.
nsICacheInfoChannel
)
{
cacheKey
=
docShell
.
currentDocumentChannel
.
cacheKey
;
}
}
let
result
;
try
{
result
=
await
fetch
(
url
{
principal
cacheKey
loadFromCache
}
)
;
}
catch
(
error
)
{
this
.
_reportLoadSourceError
(
error
)
;
throw
error
;
}
const
actors
=
[
.
.
.
this
.
_sourceActors
.
values
(
)
]
.
filter
(
actor
=
>
actor
.
url
=
=
url
)
;
if
(
!
actors
.
every
(
actor
=
>
actor
.
contentMatches
(
result
)
)
)
{
if
(
actors
.
length
>
1
)
{
result
.
content
=
"
Error
:
Incorrect
contents
fetched
please
reload
.
"
;
}
else
{
result
.
content
=
actors
[
0
]
.
actualText
(
)
;
}
}
this
.
_urlContents
.
set
(
url
{
.
.
.
result
complete
:
true
}
)
;
return
result
;
}
_reportLoadSourceError
:
function
(
error
)
{
try
{
DevToolsUtils
.
reportException
(
"
SourceActor
"
error
)
;
const
lines
=
JSON
.
stringify
(
this
.
form
(
)
null
4
)
.
split
(
/
\
n
/
g
)
;
lines
.
forEach
(
line
=
>
console
.
error
(
"
\
t
"
line
)
)
;
}
catch
(
e
)
{
}
}
}
;
function
isHiddenSource
(
source
)
{
return
source
.
introductionType
=
=
=
"
Function
.
prototype
"
;
}
function
isLocationInRange
(
{
line
column
}
range
)
{
return
(
(
range
.
start
.
line
<
=
line
|
|
(
range
.
start
.
line
=
=
line
&
&
range
.
start
.
column
<
=
column
)
)
&
&
(
range
.
end
.
line
>
=
line
|
|
(
range
.
end
.
line
=
=
line
&
&
range
.
end
.
column
>
=
column
)
)
)
;
}
exports
.
TabSources
=
TabSources
;
exports
.
isHiddenSource
=
isHiddenSource
;
