"
use
strict
"
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
assert
}
=
DevToolsUtils
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
SourceLocation
}
=
require
(
"
devtools
/
server
/
actors
/
common
"
)
;
loader
.
lazyRequireGetter
(
this
"
SourceActor
"
"
devtools
/
server
/
actors
/
source
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isEvalSource
"
"
devtools
/
server
/
actors
/
source
"
true
)
;
function
TabSources
(
threadActor
allowSourceFn
=
(
)
=
>
true
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_thread
=
threadActor
;
this
.
_autoBlackBox
=
true
;
this
.
allowSource
=
source
=
>
{
return
!
isHiddenSource
(
source
)
&
&
allowSourceFn
(
source
)
;
}
;
this
.
blackBoxedSources
=
new
Map
(
)
;
this
.
neverAutoBlackBoxSources
=
new
Set
(
)
;
this
.
_sourceActors
=
new
Map
(
)
;
this
.
_sourcesByInternalSourceId
=
null
;
}
const
MINIFIED_SOURCE_REGEXP
=
/
\
bmin
\
.
js
/
;
TabSources
.
prototype
=
{
setOptions
:
function
(
options
)
{
let
shouldReset
=
false
;
if
(
"
autoBlackBox
"
in
options
)
{
shouldReset
=
true
;
this
.
_autoBlackBox
=
options
.
autoBlackBox
;
}
if
(
shouldReset
)
{
this
.
reset
(
)
;
}
}
reset
:
function
(
)
{
this
.
_sourceActors
=
new
Map
(
)
;
this
.
_sourcesByInternalSourceId
=
null
;
}
source
:
function
(
{
source
isInlineSource
contentType
}
)
{
assert
(
source
"
TabSources
.
prototype
.
source
needs
a
source
"
)
;
if
(
!
this
.
allowSource
(
source
)
)
{
return
null
;
}
if
(
this
.
_sourceActors
.
has
(
source
)
)
{
return
this
.
_sourceActors
.
get
(
source
)
;
}
const
actor
=
new
SourceActor
(
{
thread
:
this
.
_thread
source
isInlineSource
contentType
}
)
;
this
.
_thread
.
threadLifetimePool
.
addActor
(
actor
)
;
if
(
this
.
_autoBlackBox
&
&
!
this
.
neverAutoBlackBoxSources
.
has
(
actor
.
url
)
&
&
this
.
_isMinifiedURL
(
actor
.
url
)
)
{
this
.
blackBox
(
actor
.
url
)
;
this
.
neverAutoBlackBoxSources
.
add
(
actor
.
url
)
;
}
this
.
_sourceActors
.
set
(
source
actor
)
;
if
(
this
.
_sourcesByInternalSourceId
&
&
source
.
id
)
{
this
.
_sourcesByInternalSourceId
.
set
(
source
.
id
source
)
;
}
this
.
emit
(
"
newSource
"
actor
)
;
return
actor
;
}
_getSourceActor
:
function
(
source
)
{
if
(
this
.
_sourceActors
.
has
(
source
)
)
{
return
this
.
_sourceActors
.
get
(
source
)
;
}
return
null
;
}
hasSourceActor
:
function
(
source
)
{
return
!
!
this
.
_getSourceActor
(
source
)
;
}
getSourceActor
:
function
(
source
)
{
const
sourceActor
=
this
.
_getSourceActor
(
source
)
;
if
(
!
sourceActor
)
{
throw
new
Error
(
"
getSource
:
could
not
find
source
actor
for
"
+
(
source
.
url
|
|
"
source
"
)
)
;
}
return
sourceActor
;
}
getOrCreateSourceActor
(
source
)
{
try
{
source
=
this
.
_thread
.
dbg
.
adoptSource
(
source
)
;
}
catch
(
e
)
{
if
(
/
is
in
the
same
compartment
as
this
debugger
/
.
test
(
e
)
)
{
return
null
;
}
throw
e
;
}
if
(
this
.
hasSourceActor
(
source
)
)
{
return
this
.
getSourceActor
(
source
)
;
}
return
this
.
createSourceActor
(
source
)
;
}
getSourceActorByInternalSourceId
:
function
(
id
)
{
if
(
!
this
.
_sourcesByInternalSourceId
)
{
this
.
_sourcesByInternalSourceId
=
new
Map
(
)
;
for
(
const
source
of
this
.
_thread
.
dbg
.
findSources
(
)
)
{
if
(
source
.
id
)
{
this
.
_sourcesByInternalSourceId
.
set
(
source
.
id
source
)
;
}
}
}
const
source
=
this
.
_sourcesByInternalSourceId
.
get
(
id
)
;
if
(
source
)
{
return
this
.
getOrCreateSourceActor
(
source
)
;
}
return
null
;
}
getSourceActorsByURL
:
function
(
url
)
{
const
rv
=
[
]
;
if
(
url
)
{
for
(
const
[
actor
]
of
this
.
_sourceActors
)
{
if
(
actor
.
url
=
=
=
url
)
{
rv
.
push
(
actor
)
;
}
}
}
return
rv
;
}
getSourceActorById
(
actorId
)
{
for
(
const
[
actor
]
of
this
.
_sourceActors
)
{
if
(
actor
.
actorID
=
=
actorId
)
{
return
actor
;
}
}
return
null
;
}
_isMinifiedURL
:
function
(
uri
)
{
if
(
!
uri
)
{
return
false
;
}
try
{
const
url
=
new
URL
(
uri
)
;
const
pathname
=
url
.
pathname
;
return
MINIFIED_SOURCE_REGEXP
.
test
(
pathname
.
slice
(
pathname
.
lastIndexOf
(
"
/
"
)
+
1
)
)
;
}
catch
(
e
)
{
return
MINIFIED_SOURCE_REGEXP
.
test
(
uri
)
;
}
}
isInlineScript
(
source
)
{
try
{
const
e
=
source
.
element
?
source
.
element
.
unsafeDereference
(
)
:
null
;
return
e
&
&
e
.
tagName
=
=
=
"
SCRIPT
"
&
&
!
e
.
hasAttribute
(
"
src
"
)
;
}
catch
(
e
)
{
DevToolsUtils
.
reportException
(
"
TabSources
.
isInlineScript
"
e
)
;
return
false
;
}
}
createSourceActor
:
function
(
source
)
{
const
url
=
isEvalSource
(
source
)
?
null
:
source
.
url
;
const
spec
=
{
source
}
;
if
(
this
.
isInlineScript
(
source
)
)
{
if
(
source
.
introductionScript
)
{
spec
.
contentType
=
"
text
/
javascript
"
;
}
else
{
spec
.
isInlineSource
=
true
;
}
}
else
if
(
source
.
introductionType
=
=
=
"
wasm
"
)
{
spec
.
contentType
=
"
text
/
wasm
"
;
}
else
if
(
source
.
introductionType
=
=
=
"
debugger
eval
"
)
{
spec
.
contentType
=
"
text
/
javascript
"
;
}
else
if
(
url
)
{
if
(
url
.
indexOf
(
"
Scratchpad
/
"
)
=
=
=
0
|
|
url
.
indexOf
(
"
javascript
:
"
)
=
=
=
0
|
|
url
=
=
=
"
debugger
eval
code
"
)
{
spec
.
contentType
=
"
text
/
javascript
"
;
}
else
{
try
{
const
pathname
=
new
URL
(
url
)
.
pathname
;
const
filename
=
pathname
.
slice
(
pathname
.
lastIndexOf
(
"
/
"
)
+
1
)
;
const
index
=
filename
.
lastIndexOf
(
"
.
"
)
;
const
extension
=
index
>
=
0
?
filename
.
slice
(
index
+
1
)
:
"
"
;
if
(
extension
=
=
=
"
xml
"
)
{
spec
.
isInlineSource
=
true
;
}
else
if
(
extension
=
=
=
"
js
"
)
{
spec
.
contentType
=
"
text
/
javascript
"
;
}
}
catch
(
e
)
{
const
filename
=
url
;
const
index
=
filename
.
lastIndexOf
(
"
.
"
)
;
const
extension
=
index
>
=
0
?
filename
.
slice
(
index
+
1
)
:
"
"
;
if
(
extension
=
=
=
"
js
"
)
{
spec
.
contentType
=
"
text
/
javascript
"
;
}
}
}
}
else
{
spec
.
contentType
=
"
text
/
javascript
"
;
}
return
this
.
source
(
spec
)
;
}
getScriptOffsetLocation
:
function
(
script
offset
)
{
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
offset
)
;
return
new
SourceLocation
(
this
.
createSourceActor
(
script
.
source
)
lineNumber
columnNumber
)
;
}
getFrameLocation
:
function
(
frame
)
{
if
(
!
frame
|
|
!
frame
.
script
)
{
return
new
SourceLocation
(
)
;
}
return
this
.
getScriptOffsetLocation
(
frame
.
script
frame
.
offset
)
;
}
isBlackBoxed
:
function
(
url
line
column
)
{
const
ranges
=
this
.
blackBoxedSources
.
get
(
url
)
;
if
(
!
ranges
)
{
return
this
.
blackBoxedSources
.
has
(
url
)
;
}
const
range
=
ranges
.
find
(
r
=
>
isLocationInRange
(
{
line
column
}
r
)
)
;
return
!
!
range
;
}
blackBox
:
function
(
url
range
)
{
if
(
!
range
)
{
return
this
.
blackBoxedSources
.
set
(
url
null
)
;
}
const
ranges
=
this
.
blackBoxedSources
.
get
(
url
)
|
|
[
]
;
const
index
=
ranges
.
findIndex
(
r
=
>
r
.
end
.
line
<
=
range
.
start
.
line
&
&
r
.
end
.
column
<
=
range
.
start
.
column
)
;
ranges
.
splice
(
index
+
1
0
range
)
;
this
.
blackBoxedSources
.
set
(
url
ranges
)
;
return
true
;
}
unblackBox
:
function
(
url
range
)
{
if
(
!
range
)
{
return
this
.
blackBoxedSources
.
delete
(
url
)
;
}
const
ranges
=
this
.
blackBoxedSources
.
get
(
url
)
;
const
index
=
ranges
.
findIndex
(
r
=
>
r
.
start
.
line
=
=
=
range
.
start
.
line
&
&
r
.
start
.
column
=
=
=
range
.
start
.
column
&
&
r
.
end
.
line
=
=
=
range
.
end
.
line
&
&
r
.
end
.
column
=
=
=
range
.
end
.
column
)
;
if
(
index
!
=
=
-
1
)
{
ranges
.
splice
(
index
1
)
;
}
if
(
ranges
.
length
=
=
=
0
)
{
return
this
.
blackBoxedSources
.
delete
(
url
)
;
}
return
this
.
blackBoxedSources
.
set
(
url
ranges
)
;
}
iter
:
function
(
)
{
return
[
.
.
.
this
.
_sourceActors
.
values
(
)
]
;
}
}
;
function
isHiddenSource
(
source
)
{
return
source
.
introductionType
=
=
=
"
Function
.
prototype
"
;
}
function
isLocationInRange
(
{
line
column
}
range
)
{
return
(
(
range
.
start
.
line
<
=
line
|
|
(
range
.
start
.
line
=
=
line
&
&
range
.
start
.
column
<
=
column
)
)
&
&
(
range
.
end
.
line
>
=
line
|
|
(
range
.
end
.
line
=
=
line
&
&
range
.
end
.
column
>
=
column
)
)
)
;
}
exports
.
TabSources
=
TabSources
;
exports
.
isHiddenSource
=
isHiddenSource
;
