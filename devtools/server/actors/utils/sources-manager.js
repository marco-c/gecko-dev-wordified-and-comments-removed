"
use
strict
"
;
const
DevToolsUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
{
assert
fetch
}
=
DevToolsUtils
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
const
{
SourceLocation
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
common
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
SourceActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
source
.
js
"
true
)
;
const
MINIFIED_SOURCE_REGEXP
=
/
\
bmin
\
.
js
/
;
class
SourcesManager
extends
EventEmitter
{
constructor
(
threadActor
)
{
super
(
)
;
this
.
_thread
=
threadActor
;
this
.
blackBoxedSources
=
new
Map
(
)
;
this
.
_sourceActors
=
new
Map
(
)
;
this
.
_urlContents
=
new
Map
(
)
;
this
.
_urlWaiters
=
new
Map
(
)
;
this
.
_sourcesByInternalSourceId
=
null
;
if
(
!
isWorker
)
{
Services
.
obs
.
addObserver
(
this
"
devtools
-
html
-
content
"
)
;
}
}
destroy
(
)
{
if
(
!
isWorker
)
{
Services
.
obs
.
removeObserver
(
this
"
devtools
-
html
-
content
"
)
;
}
}
reset
(
)
{
this
.
_sourceActors
=
new
Map
(
)
;
this
.
_urlContents
=
new
Map
(
)
;
this
.
_urlWaiters
=
new
Map
(
)
;
this
.
_sourcesByInternalSourceId
=
null
;
}
createSourceActor
(
source
)
{
assert
(
source
"
SourcesManager
.
prototype
.
source
needs
a
source
"
)
;
if
(
this
.
_sourceActors
.
has
(
source
)
)
{
return
this
.
_sourceActors
.
get
(
source
)
;
}
const
actor
=
new
SourceActor
(
{
thread
:
this
.
_thread
source
}
)
;
this
.
_thread
.
threadLifetimePool
.
manage
(
actor
)
;
this
.
_sourceActors
.
set
(
source
actor
)
;
if
(
this
.
_sourcesByInternalSourceId
&
&
Number
.
isInteger
(
source
.
id
)
)
{
this
.
_sourcesByInternalSourceId
.
set
(
source
.
id
source
)
;
}
this
.
emit
(
"
newSource
"
actor
)
;
return
actor
;
}
_getSourceActor
(
source
)
{
if
(
this
.
_sourceActors
.
has
(
source
)
)
{
return
this
.
_sourceActors
.
get
(
source
)
;
}
return
null
;
}
hasSourceActor
(
source
)
{
return
!
!
this
.
_getSourceActor
(
source
)
;
}
getSourceActor
(
source
)
{
const
sourceActor
=
this
.
_getSourceActor
(
source
)
;
if
(
!
sourceActor
)
{
throw
new
Error
(
"
getSource
:
could
not
find
source
actor
for
"
+
(
source
.
url
|
|
"
source
"
)
)
;
}
return
sourceActor
;
}
getOrCreateSourceActor
(
source
)
{
try
{
source
=
this
.
_thread
.
dbg
.
adoptSource
(
source
)
;
}
catch
(
e
)
{
if
(
/
is
in
the
same
compartment
as
this
debugger
/
.
test
(
e
)
)
{
return
null
;
}
throw
e
;
}
if
(
this
.
hasSourceActor
(
source
)
)
{
return
this
.
getSourceActor
(
source
)
;
}
return
this
.
createSourceActor
(
source
)
;
}
getSourceActorByInternalSourceId
(
id
)
{
if
(
!
this
.
_sourcesByInternalSourceId
)
{
this
.
_sourcesByInternalSourceId
=
new
Map
(
)
;
for
(
const
source
of
this
.
_thread
.
dbg
.
findSources
(
)
)
{
if
(
Number
.
isInteger
(
source
.
id
)
)
{
this
.
_sourcesByInternalSourceId
.
set
(
source
.
id
source
)
;
}
}
}
const
source
=
this
.
_sourcesByInternalSourceId
.
get
(
id
)
;
if
(
source
)
{
return
this
.
getOrCreateSourceActor
(
source
)
;
}
return
null
;
}
getSourceActorsByURL
(
url
)
{
const
rv
=
[
]
;
if
(
url
)
{
for
(
const
[
actor
]
of
this
.
_sourceActors
)
{
if
(
actor
.
url
=
=
=
url
)
{
rv
.
push
(
actor
)
;
}
}
}
return
rv
;
}
getSourceActorById
(
actorId
)
{
for
(
const
[
actor
]
of
this
.
_sourceActors
)
{
if
(
actor
.
actorID
=
=
actorId
)
{
return
actor
;
}
}
return
null
;
}
_isMinifiedURL
(
uri
)
{
if
(
!
uri
)
{
return
false
;
}
try
{
const
url
=
new
URL
(
uri
)
;
const
pathname
=
url
.
pathname
;
return
MINIFIED_SOURCE_REGEXP
.
test
(
pathname
.
slice
(
pathname
.
lastIndexOf
(
"
/
"
)
+
1
)
)
;
}
catch
(
e
)
{
return
MINIFIED_SOURCE_REGEXP
.
test
(
uri
)
;
}
}
getScriptOffsetLocation
(
script
offset
)
{
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
offset
)
;
const
columnBase
=
script
.
format
=
=
=
"
wasm
"
?
0
:
1
;
return
new
SourceLocation
(
this
.
createSourceActor
(
script
.
source
)
lineNumber
columnNumber
-
columnBase
)
;
}
getFrameLocation
(
frame
)
{
if
(
!
frame
|
|
!
frame
.
script
)
{
return
new
SourceLocation
(
)
;
}
return
this
.
getScriptOffsetLocation
(
frame
.
script
frame
.
offset
)
;
}
isBlackBoxed
(
url
line
column
)
{
if
(
this
.
blackBoxedSources
.
size
=
=
0
)
{
return
false
;
}
if
(
!
this
.
blackBoxedSources
.
has
(
url
)
)
{
return
false
;
}
const
ranges
=
this
.
blackBoxedSources
.
get
(
url
)
;
if
(
!
ranges
)
{
return
true
;
}
const
range
=
ranges
.
find
(
r
=
>
isLocationInRange
(
{
line
column
}
r
)
)
;
return
!
!
range
;
}
isFrameBlackBoxed
(
frame
)
{
if
(
this
.
blackBoxedSources
.
size
=
=
0
)
{
return
false
;
}
const
{
url
line
column
}
=
this
.
getFrameLocation
(
frame
)
;
return
this
.
isBlackBoxed
(
url
line
column
)
;
}
clearAllBlackBoxing
(
)
{
this
.
blackBoxedSources
.
clear
(
)
;
}
blackBox
(
url
range
)
{
if
(
!
range
)
{
return
this
.
blackBoxedSources
.
set
(
url
null
)
;
}
const
ranges
=
this
.
blackBoxedSources
.
get
(
url
)
|
|
[
]
;
const
index
=
ranges
.
findIndex
(
r
=
>
r
.
end
.
line
<
=
range
.
start
.
line
&
&
r
.
end
.
column
<
=
range
.
start
.
column
)
;
ranges
.
splice
(
index
+
1
0
range
)
;
this
.
blackBoxedSources
.
set
(
url
ranges
)
;
return
true
;
}
unblackBox
(
url
range
)
{
if
(
!
range
)
{
return
this
.
blackBoxedSources
.
delete
(
url
)
;
}
const
ranges
=
this
.
blackBoxedSources
.
get
(
url
)
;
const
index
=
ranges
.
findIndex
(
r
=
>
r
.
start
.
line
=
=
=
range
.
start
.
line
&
&
r
.
start
.
column
=
=
=
range
.
start
.
column
&
&
r
.
end
.
line
=
=
=
range
.
end
.
line
&
&
r
.
end
.
column
=
=
=
range
.
end
.
column
)
;
if
(
index
!
=
=
-
1
)
{
ranges
.
splice
(
index
1
)
;
}
if
(
ranges
.
length
=
=
=
0
)
{
return
this
.
blackBoxedSources
.
delete
(
url
)
;
}
return
this
.
blackBoxedSources
.
set
(
url
ranges
)
;
}
iter
(
)
{
return
this
.
_sourceActors
.
values
(
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
devtools
-
html
-
content
"
)
{
const
{
parserID
uri
contents
complete
}
=
JSON
.
parse
(
data
)
;
if
(
this
.
_urlContents
.
has
(
uri
)
)
{
const
existing
=
this
.
_urlContents
.
get
(
uri
)
;
if
(
existing
.
parserID
=
=
parserID
)
{
assert
(
!
existing
.
complete
)
;
existing
.
content
=
existing
.
content
+
contents
;
existing
.
complete
=
complete
;
if
(
complete
)
{
const
waiters
=
this
.
_urlWaiters
.
get
(
uri
)
;
if
(
waiters
)
{
for
(
const
waiter
of
waiters
)
{
waiter
(
)
;
}
this
.
_urlWaiters
.
delete
(
uri
)
;
}
}
}
}
else
if
(
contents
)
{
this
.
_urlContents
.
set
(
uri
{
content
:
contents
complete
contentType
:
"
text
/
html
"
parserID
}
)
;
}
}
}
urlContents
(
url
partial
canUseCache
)
{
if
(
this
.
_urlContents
.
has
(
url
)
)
{
const
data
=
this
.
_urlContents
.
get
(
url
)
;
if
(
!
partial
&
&
!
data
.
complete
)
{
return
new
Promise
(
resolve
=
>
{
if
(
!
this
.
_urlWaiters
.
has
(
url
)
)
{
this
.
_urlWaiters
.
set
(
url
[
]
)
;
}
this
.
_urlWaiters
.
get
(
url
)
.
push
(
resolve
)
;
}
)
.
then
(
(
)
=
>
{
assert
(
data
.
complete
)
;
return
{
content
:
data
.
content
contentType
:
data
.
contentType
}
;
}
)
;
}
return
{
content
:
data
.
content
contentType
:
data
.
contentType
}
;
}
if
(
partial
)
{
return
{
content
:
"
"
contentType
:
"
"
}
;
}
return
this
.
_fetchURLContents
(
url
partial
canUseCache
)
;
}
async
_fetchURLContents
(
url
partial
canUseCache
)
{
let
loadFromCache
=
canUseCache
;
if
(
canUseCache
&
&
this
.
_thread
.
targetActor
.
browsingContext
)
{
loadFromCache
=
!
(
this
.
_thread
.
targetActor
.
browsingContext
.
defaultLoadFlags
=
=
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
)
;
}
const
win
=
this
.
_thread
.
targetActor
.
window
;
let
principal
cacheKey
;
if
(
!
isWorker
&
&
win
instanceof
Ci
.
nsIDOMWindow
)
{
const
docShell
=
win
.
docShell
;
const
channel
=
docShell
.
currentDocumentChannel
;
principal
=
channel
.
loadInfo
.
loadingPrincipal
;
if
(
loadFromCache
&
&
docShell
.
currentDocumentChannel
instanceof
Ci
.
nsICacheInfoChannel
)
{
cacheKey
=
docShell
.
currentDocumentChannel
.
cacheKey
;
}
}
let
result
;
try
{
result
=
await
fetch
(
url
{
principal
cacheKey
loadFromCache
}
)
;
}
catch
(
error
)
{
this
.
_reportLoadSourceError
(
error
)
;
throw
error
;
}
const
actors
=
[
.
.
.
this
.
_sourceActors
.
values
(
)
]
.
filter
(
actor
=
>
actor
.
url
=
=
url
&
&
actor
.
actualText
(
)
!
=
"
[
no
source
]
"
)
;
if
(
!
actors
.
every
(
actor
=
>
actor
.
contentMatches
(
result
)
)
)
{
if
(
actors
.
length
>
1
)
{
result
.
content
=
"
Error
:
Incorrect
contents
fetched
please
reload
.
"
;
}
else
{
result
.
content
=
actors
[
0
]
.
actualText
(
)
;
}
}
this
.
_urlContents
.
set
(
url
{
.
.
.
result
complete
:
true
}
)
;
return
result
;
}
_reportLoadSourceError
(
error
)
{
try
{
DevToolsUtils
.
reportException
(
"
SourceActor
"
error
)
;
const
lines
=
JSON
.
stringify
(
this
.
form
(
)
null
4
)
.
split
(
/
\
n
/
g
)
;
lines
.
forEach
(
line
=
>
console
.
error
(
"
\
t
"
line
)
)
;
}
catch
(
e
)
{
}
}
}
function
isLocationInRange
(
{
line
column
}
range
)
{
return
(
(
range
.
start
.
line
<
=
line
|
|
(
range
.
start
.
line
=
=
line
&
&
range
.
start
.
column
<
=
column
)
)
&
&
(
range
.
end
.
line
>
=
line
|
|
(
range
.
end
.
line
=
=
line
&
&
range
.
end
.
column
>
=
column
)
)
)
;
}
exports
.
SourcesManager
=
SourcesManager
;
