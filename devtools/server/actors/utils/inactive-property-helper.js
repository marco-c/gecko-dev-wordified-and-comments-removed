"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
PREF_UNUSED_CSS_ENABLED
=
"
devtools
.
inspector
.
inactive
.
css
.
enabled
"
;
const
INSPECTOR_L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
inspector
.
properties
"
)
;
class
InactivePropertyHelper
{
get
VALIDATORS
(
)
{
return
[
{
invalidProperties
:
[
"
flex
-
direction
"
"
flex
-
flow
"
"
flex
-
wrap
"
]
when
:
(
)
=
>
!
this
.
flexContainer
error
:
property
=
>
msg
(
"
rule
.
inactive
.
css
.
not
.
flex
.
container
"
property
)
}
{
invalidProperties
:
[
"
flex
"
"
flex
-
basis
"
"
flex
-
grow
"
"
flex
-
shrink
"
"
order
"
]
when
:
(
)
=
>
!
this
.
flexItem
error
:
property
=
>
msg
(
"
rule
.
inactive
.
css
.
not
.
flex
.
item
"
property
)
}
{
invalidProperties
:
[
"
grid
-
auto
-
columns
"
"
grid
-
auto
-
flow
"
"
grid
-
auto
-
rows
"
"
grid
-
template
"
"
grid
-
gap
"
"
row
-
gap
"
"
column
-
gap
"
"
justify
-
items
"
]
when
:
(
)
=
>
!
this
.
gridContainer
error
:
property
=
>
msg
(
"
rule
.
inactive
.
css
.
not
.
grid
.
container
"
property
)
}
{
invalidProperties
:
[
"
grid
-
area
"
"
grid
-
column
"
"
grid
-
column
-
end
"
"
grid
-
column
-
start
"
"
grid
-
row
"
"
grid
-
row
-
end
"
"
grid
-
row
-
start
"
"
justify
-
self
"
]
when
:
(
)
=
>
!
this
.
gridItem
error
:
property
=
>
msg
(
"
rule
.
inactive
.
css
.
not
.
grid
.
item
"
property
)
}
{
invalidProperties
:
[
"
align
-
self
"
]
when
:
(
)
=
>
!
this
.
gridItem
&
&
!
this
.
flexItem
error
:
property
=
>
msg
(
"
rule
.
inactive
.
css
.
not
.
grid
.
or
.
flex
.
item
"
property
)
}
{
invalidProperties
:
[
"
align
-
content
"
"
align
-
items
"
"
justify
-
content
"
]
when
:
(
)
=
>
!
this
.
gridContainer
&
&
!
this
.
flexContainer
error
:
property
=
>
msg
(
"
rule
.
inactive
.
css
.
not
.
grid
.
or
.
flex
.
container
"
property
)
}
]
;
}
get
unusedCssEnabled
(
)
{
if
(
!
this
.
_unusedCssEnabled
)
{
this
.
_unusedCssEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_UNUSED_CSS_ENABLED
)
;
}
return
this
.
_unusedCssEnabled
;
}
isPropertyUsed
(
el
elStyle
cssRule
property
)
{
if
(
!
this
.
unusedCssEnabled
)
{
return
{
used
:
true
}
;
}
const
errors
=
[
]
;
this
.
VALIDATORS
.
forEach
(
validator
=
>
{
let
isRuleConcerned
=
false
;
if
(
validator
.
invalidProperties
)
{
isRuleConcerned
=
validator
.
invalidProperties
=
=
=
"
*
"
|
|
validator
.
invalidProperties
.
includes
(
property
)
;
}
else
if
(
validator
.
validProperties
)
{
isRuleConcerned
=
!
validator
.
validProperties
.
includes
(
property
)
;
}
if
(
!
isRuleConcerned
)
{
return
;
}
this
.
select
(
el
elStyle
cssRule
property
)
;
if
(
validator
.
when
(
)
)
{
const
error
=
validator
.
error
(
property
)
;
if
(
typeof
error
=
=
=
"
string
"
)
{
errors
.
push
(
validator
.
error
(
property
)
)
;
}
}
}
)
;
return
{
used
:
!
errors
.
length
reasons
:
errors
}
;
}
select
(
node
style
cssRule
property
)
{
this
.
_node
=
node
;
this
.
_cssRule
=
cssRule
;
this
.
_property
=
property
;
this
.
_style
=
style
;
}
get
node
(
)
{
return
this
.
_node
;
}
get
style
(
)
{
return
this
.
_style
;
}
checkStyle
(
propName
values
)
{
return
this
.
checkStyleForNode
(
this
.
node
propName
values
)
;
}
checkStyleForNode
(
node
propName
values
)
{
return
values
.
some
(
value
=
>
this
.
style
[
propName
]
=
=
=
value
)
;
}
get
flexContainer
(
)
{
return
this
.
checkStyle
(
"
display
"
[
"
flex
"
"
inline
-
flex
"
]
)
;
}
get
flexItem
(
)
{
return
this
.
isFlexItem
(
this
.
node
)
;
}
get
gridContainer
(
)
{
return
this
.
checkStyle
(
"
display
"
[
"
grid
"
"
inline
-
grid
"
]
)
;
}
get
gridItem
(
)
{
return
this
.
isGridItem
(
this
.
node
)
;
}
isFlexItem
(
node
)
{
return
!
!
node
.
parentFlexElement
;
}
isFlexContainer
(
node
)
{
return
!
!
node
.
getAsFlexContainer
(
)
;
}
isGridContainer
(
node
)
{
return
!
!
node
.
getGridFragments
(
)
.
length
>
0
;
}
isGridItem
(
node
)
{
return
!
!
this
.
getParentGridElement
(
this
.
node
)
;
}
getParentGridElement
(
node
)
{
if
(
node
.
nodeType
=
=
=
node
.
ELEMENT_NODE
)
{
const
display
=
this
.
style
.
display
;
if
(
!
display
|
|
display
=
=
=
"
none
"
|
|
display
=
=
=
"
contents
"
)
{
return
null
;
}
const
position
=
this
.
style
.
position
;
if
(
position
=
=
=
"
absolute
"
|
|
position
=
=
=
"
fixed
"
|
|
this
.
style
.
cssFloat
!
=
=
"
none
"
)
{
return
null
;
}
}
else
if
(
node
.
nodeType
!
=
=
node
.
TEXT_NODE
)
{
return
null
;
}
for
(
let
p
=
node
.
flattenedTreeParentNode
;
p
;
p
=
p
.
flattenedTreeParentNode
)
{
const
style
=
node
.
ownerGlobal
.
getComputedStyle
(
p
)
;
const
display
=
style
.
display
;
if
(
display
.
includes
(
"
grid
"
)
&
&
!
!
p
.
getGridFragments
(
)
.
length
>
0
)
{
return
p
;
}
if
(
display
!
=
=
"
contents
"
)
{
return
null
;
}
}
return
null
;
}
}
function
msg
(
.
.
.
args
)
{
return
INSPECTOR_L10N
.
getFormatStr
(
.
.
.
args
)
;
}
exports
.
inactivePropertyHelper
=
new
InactivePropertyHelper
(
)
;
