"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
resource
:
/
/
devtools
/
server
/
actors
/
inspector
/
css
-
logic
.
js
"
true
)
;
const
INACTIVE_CSS_ENABLED
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
inspector
.
inactive
.
css
.
enabled
"
false
)
;
const
TEXT_WRAP_BALANCE_LIMIT
=
Services
.
prefs
.
getIntPref
(
"
layout
.
css
.
text
-
wrap
-
balance
.
limit
"
10
)
;
const
VISITED_MDN_LINK
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Web
/
CSS
/
:
visited
"
;
const
VISITED_INVALID_PROPERTIES
=
allCssPropertiesExcept
(
[
"
all
"
"
color
"
"
background
"
"
background
-
color
"
"
border
"
"
border
-
color
"
"
border
-
bottom
-
color
"
"
border
-
left
-
color
"
"
border
-
right
-
color
"
"
border
-
top
-
color
"
"
border
-
block
"
"
border
-
block
-
color
"
"
border
-
block
-
start
-
color
"
"
border
-
block
-
end
-
color
"
"
border
-
inline
"
"
border
-
inline
-
color
"
"
border
-
inline
-
start
-
color
"
"
border
-
inline
-
end
-
color
"
"
column
-
rule
"
"
column
-
rule
-
color
"
"
outline
"
"
outline
-
color
"
"
text
-
decoration
-
color
"
"
text
-
emphasis
-
color
"
]
)
;
const
REPLACED_ELEMENTS_NAMES
=
new
Set
(
[
"
audio
"
"
br
"
"
button
"
"
canvas
"
"
embed
"
"
hr
"
"
iframe
"
"
input
"
"
math
"
"
object
"
"
picture
"
"
select
"
"
svg
"
"
textarea
"
"
video
"
]
)
;
const
CUE_PSEUDO_ELEMENT_STYLING_SPEC_URL
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Web
/
CSS
/
:
:
cue
"
;
const
HIGHLIGHT_PSEUDO_ELEMENTS_STYLING_SPEC_URL
=
"
https
:
/
/
www
.
w3
.
org
/
TR
/
css
-
pseudo
-
4
/
#
highlight
-
styling
"
;
const
HIGHLIGHT_PSEUDO_ELEMENTS
=
[
"
:
:
highlight
"
"
:
:
selection
"
"
:
:
target
-
text
"
"
:
:
grammar
-
error
"
"
:
:
spelling
-
error
"
]
;
const
REGEXP_HIGHLIGHT_PSEUDO_ELEMENTS
=
new
RegExp
(
{
HIGHLIGHT_PSEUDO_ELEMENTS
.
join
(
"
|
"
)
}
)
;
const
FIRST_LINE_PSEUDO_ELEMENT_STYLING_SPEC_URL
=
"
https
:
/
/
www
.
w3
.
org
/
TR
/
css
-
pseudo
-
4
/
#
first
-
line
-
styling
"
;
const
FIRST_LETTER_PSEUDO_ELEMENT_STYLING_SPEC_URL
=
"
https
:
/
/
www
.
w3
.
org
/
TR
/
css
-
pseudo
-
4
/
#
first
-
letter
-
styling
"
;
const
PLACEHOLDER_PSEUDO_ELEMENT_STYLING_SPEC_URL
=
"
https
:
/
/
www
.
w3
.
org
/
TR
/
css
-
pseudo
-
4
/
#
placeholder
-
pseudo
"
;
class
InactivePropertyHelper
{
get
INVALID_PROPERTIES_VALIDATORS
(
)
{
return
[
{
invalidProperties
:
[
"
flex
-
direction
"
"
flex
-
flow
"
"
flex
-
wrap
"
]
when
:
(
)
=
>
!
this
.
flexContainer
fixId
:
"
inactive
-
css
-
not
-
flex
-
container
-
fix
"
msgId
:
"
inactive
-
css
-
not
-
flex
-
container
"
}
{
invalidProperties
:
[
"
flex
"
"
flex
-
basis
"
"
flex
-
grow
"
"
flex
-
shrink
"
]
when
:
(
)
=
>
!
this
.
flexItem
fixId
:
"
inactive
-
css
-
not
-
flex
-
item
-
fix
-
2
"
msgId
:
"
inactive
-
css
-
not
-
flex
-
item
"
}
{
invalidProperties
:
[
"
grid
-
auto
-
columns
"
"
grid
-
auto
-
flow
"
"
grid
-
auto
-
rows
"
"
grid
-
template
"
"
grid
-
template
-
areas
"
"
grid
-
template
-
columns
"
"
grid
-
template
-
rows
"
"
justify
-
items
"
]
when
:
(
)
=
>
!
this
.
gridContainer
fixId
:
"
inactive
-
css
-
not
-
grid
-
container
-
fix
"
msgId
:
"
inactive
-
css
-
not
-
grid
-
container
"
}
{
invalidProperties
:
[
"
grid
-
area
"
"
grid
-
column
"
"
grid
-
column
-
end
"
"
grid
-
column
-
start
"
"
grid
-
row
"
"
grid
-
row
-
end
"
"
grid
-
row
-
start
"
"
justify
-
self
"
]
when
:
(
)
=
>
!
this
.
gridItem
&
&
!
this
.
isAbsPosGridElement
(
)
fixId
:
"
inactive
-
css
-
not
-
grid
-
item
-
fix
-
2
"
msgId
:
"
inactive
-
css
-
not
-
grid
-
item
"
}
{
invalidProperties
:
[
"
align
-
self
"
"
place
-
self
"
"
order
"
]
when
:
(
)
=
>
!
this
.
gridItem
&
&
!
this
.
flexItem
&
&
!
this
.
isAbsPosGridElement
(
)
fixId
:
"
inactive
-
css
-
not
-
grid
-
or
-
flex
-
item
-
fix
-
3
"
msgId
:
"
inactive
-
css
-
not
-
grid
-
or
-
flex
-
item
"
}
{
invalidProperties
:
[
"
align
-
items
"
"
justify
-
content
"
"
place
-
content
"
"
place
-
items
"
"
row
-
gap
"
"
grid
-
row
-
gap
"
]
when
:
(
)
=
>
!
this
.
gridContainer
&
&
!
this
.
flexContainer
fixId
:
"
inactive
-
css
-
not
-
grid
-
or
-
flex
-
container
-
fix
"
msgId
:
"
inactive
-
css
-
not
-
grid
-
or
-
flex
-
container
"
}
{
invalidProperties
:
[
"
align
-
content
"
]
when
:
(
)
=
>
{
if
(
this
.
style
[
"
align
-
content
"
]
.
includes
(
"
baseline
"
)
)
{
return
false
;
}
const
supportedDisplay
=
[
"
flex
"
"
inline
-
flex
"
"
grid
"
"
inline
-
grid
"
"
block
"
"
inline
-
block
"
]
;
return
!
this
.
checkComputedStyle
(
"
display
"
supportedDisplay
)
;
}
fixId
:
"
inactive
-
css
-
not
-
grid
-
or
-
flex
-
or
-
block
-
container
-
fix
"
msgId
:
"
inactive
-
css
-
property
-
because
-
of
-
display
"
}
{
invalidProperties
:
[
"
column
-
gap
"
"
gap
"
"
grid
-
gap
"
"
grid
-
column
-
gap
"
]
when
:
(
)
=
>
!
this
.
gridContainer
&
&
!
this
.
flexContainer
&
&
!
this
.
multiColContainer
fixId
:
"
inactive
-
css
-
not
-
grid
-
or
-
flex
-
container
-
or
-
multicol
-
container
-
fix
"
msgId
:
"
inactive
-
css
-
not
-
grid
-
or
-
flex
-
container
-
or
-
multicol
-
container
"
}
{
invalidProperties
:
[
"
column
-
fill
"
"
column
-
rule
"
"
column
-
rule
-
color
"
"
column
-
rule
-
style
"
"
column
-
rule
-
width
"
]
when
:
(
)
=
>
!
this
.
multiColContainer
fixId
:
"
inactive
-
css
-
not
-
multicol
-
container
-
fix
"
msgId
:
"
inactive
-
css
-
not
-
multicol
-
container
"
}
{
invalidProperties
:
[
"
column
-
span
"
]
when
:
(
)
=
>
!
this
.
inMultiColContainer
fixId
:
"
inactive
-
css
-
column
-
span
-
fix
"
msgId
:
"
inactive
-
css
-
column
-
span
"
}
{
invalidProperties
:
[
"
vertical
-
align
"
]
when
:
(
)
=
>
!
this
.
isInlineLevel
(
)
&
&
!
this
.
isFirstLetter
&
&
!
this
.
isFirstLine
fixId
:
"
inactive
-
css
-
not
-
inline
-
or
-
tablecell
-
fix
"
msgId
:
"
inactive
-
css
-
not
-
inline
-
or
-
tablecell
"
}
{
invalidProperties
:
[
"
direction
"
"
text
-
orientation
"
"
writing
-
mode
"
]
when
:
(
)
=
>
this
.
isFirstLine
fixId
:
"
learn
-
more
"
msgId
:
"
inactive
-
css
-
first
-
line
-
pseudo
-
element
-
not
-
supported
"
learnMoreURL
:
FIRST_LINE_PSEUDO_ELEMENT_STYLING_SPEC_URL
}
{
invalidProperties
:
[
"
content
"
]
when
:
(
)
=
>
this
.
isFirstLetter
fixId
:
"
learn
-
more
"
msgId
:
"
inactive
-
css
-
first
-
letter
-
pseudo
-
element
-
not
-
supported
"
learnMoreURL
:
FIRST_LETTER_PSEUDO_ELEMENT_STYLING_SPEC_URL
}
{
invalidProperties
:
[
"
baseline
-
source
"
"
direction
"
"
dominant
-
baseline
"
"
line
-
height
"
"
text
-
orientation
"
"
vertical
-
align
"
"
writing
-
mode
"
"
alignment
-
baseline
"
"
baseline
-
shift
"
"
initial
-
letter
"
"
text
-
box
-
trim
"
]
when
:
(
)
=
>
{
const
{
selectorText
}
=
this
.
cssRule
;
return
selectorText
&
&
selectorText
.
includes
(
"
:
:
placeholder
"
)
;
}
fixId
:
"
learn
-
more
"
msgId
:
"
inactive
-
css
-
placeholder
-
pseudo
-
element
-
not
-
supported
"
learnMoreURL
:
PLACEHOLDER_PSEUDO_ELEMENT_STYLING_SPEC_URL
}
{
invalidProperties
:
[
"
max
-
width
"
"
min
-
width
"
"
width
"
]
when
:
(
)
=
>
this
.
nonReplacedInlineBox
|
|
this
.
horizontalTableTrack
|
|
this
.
horizontalTableTrackGroup
fixId
:
"
inactive
-
css
-
non
-
replaced
-
inline
-
or
-
table
-
row
-
or
-
row
-
group
-
fix
"
msgId
:
"
inactive
-
css
-
property
-
because
-
of
-
display
"
}
{
invalidProperties
:
[
"
max
-
height
"
"
min
-
height
"
"
height
"
]
when
:
(
)
=
>
this
.
nonReplacedInlineBox
|
|
this
.
verticalTableTrack
|
|
this
.
verticalTableTrackGroup
fixId
:
"
inactive
-
css
-
non
-
replaced
-
inline
-
or
-
table
-
column
-
or
-
column
-
group
-
fix
"
msgId
:
"
inactive
-
css
-
property
-
because
-
of
-
display
"
}
{
invalidProperties
:
[
"
display
"
]
when
:
(
)
=
>
this
.
isFloated
&
&
this
.
checkResolvedStyle
(
"
display
"
[
"
inline
"
"
inline
-
block
"
"
inline
-
table
"
"
inline
-
flex
"
"
inline
-
grid
"
"
table
-
cell
"
"
table
-
row
"
"
table
-
row
-
group
"
"
table
-
header
-
group
"
"
table
-
footer
-
group
"
"
table
-
column
"
"
table
-
column
-
group
"
"
table
-
caption
"
]
)
fixId
:
"
inactive
-
css
-
not
-
display
-
block
-
on
-
floated
-
fix
"
msgId
:
"
inactive
-
css
-
not
-
display
-
block
-
on
-
floated
-
2
"
}
{
invalidProperties
:
[
"
float
"
]
when
:
(
)
=
>
this
.
gridItem
|
|
this
.
flexItem
fixId
:
"
inactive
-
css
-
only
-
non
-
grid
-
or
-
flex
-
item
-
fix
"
msgId
:
"
inactive
-
css
-
only
-
non
-
grid
-
or
-
flex
-
item
"
}
{
invalidProperties
:
[
"
clear
"
]
when
:
(
)
=
>
!
this
.
isBlockLevel
(
)
fixId
:
"
inactive
-
css
-
not
-
block
-
fix
"
msgId
:
"
inactive
-
css
-
not
-
block
"
}
{
invalidProperties
:
[
"
shape
-
image
-
threshold
"
"
shape
-
margin
"
"
shape
-
outside
"
]
when
:
(
)
=
>
!
this
.
isFloated
fixId
:
"
inactive
-
css
-
not
-
floated
-
fix
"
msgId
:
"
inactive
-
css
-
not
-
floated
"
}
{
invalidProperties
:
VISITED_INVALID_PROPERTIES
when
:
(
)
=
>
this
.
isVisitedRule
(
)
fixId
:
"
learn
-
more
"
msgId
:
"
inactive
-
css
-
property
-
is
-
impossible
-
to
-
override
-
in
-
visited
"
learnMoreURL
:
VISITED_MDN_LINK
}
{
invalidProperties
:
[
"
top
"
"
right
"
"
bottom
"
"
left
"
]
when
:
(
)
=
>
!
this
.
isPositioned
fixId
:
"
inactive
-
css
-
position
-
property
-
on
-
unpositioned
-
box
-
fix
"
msgId
:
"
inactive
-
css
-
position
-
property
-
on
-
unpositioned
-
box
"
}
{
invalidProperties
:
[
"
z
-
index
"
]
when
:
(
)
=
>
!
this
.
isPositioned
&
&
!
this
.
gridItem
&
&
!
this
.
flexItem
fixId
:
"
inactive
-
css
-
position
-
property
-
on
-
unpositioned
-
box
-
fix
"
msgId
:
"
inactive
-
css
-
position
-
property
-
on
-
unpositioned
-
box
"
}
{
invalidProperties
:
[
"
object
-
fit
"
"
object
-
position
"
]
when
:
(
)
=
>
!
this
.
replaced
fixId
:
"
inactive
-
css
-
only
-
replaced
-
elements
-
fix
"
msgId
:
"
inactive
-
css
-
only
-
replaced
-
elements
"
}
{
invalidProperties
:
[
"
text
-
overflow
"
]
when
:
(
)
=
>
this
.
checkComputedStyle
(
"
overflow
-
inline
"
[
"
visible
"
]
)
fixId
:
"
inactive
-
text
-
overflow
-
when
-
no
-
overflow
-
fix
"
msgId
:
"
inactive
-
text
-
overflow
-
when
-
no
-
overflow
"
}
{
invalidProperties
:
[
"
content
-
visibility
"
]
when
:
(
)
=
>
!
this
.
hasPrincipalBox
|
|
this
.
table
|
|
this
.
internalTableElement
|
|
this
.
rubyContainer
|
|
this
.
internalRubyElement
|
|
this
.
nonAtomicInlineBox
fixId
:
"
inactive
-
css
-
no
-
size
-
containment
-
fix
"
msgId
:
"
inactive
-
css
-
no
-
size
-
containment
"
}
{
invalidProperties
:
[
"
margin
"
"
margin
-
block
"
"
margin
-
block
-
end
"
"
margin
-
block
-
start
"
"
margin
-
bottom
"
"
margin
-
inline
"
"
margin
-
inline
-
end
"
"
margin
-
inline
-
start
"
"
margin
-
left
"
"
margin
-
right
"
"
margin
-
top
"
]
when
:
(
)
=
>
this
.
internalTableElement
fixId
:
"
inactive
-
css
-
not
-
for
-
internal
-
table
-
elements
-
fix
"
msgId
:
"
inactive
-
css
-
not
-
for
-
internal
-
table
-
elements
"
}
{
invalidProperties
:
[
"
padding
"
"
padding
-
block
"
"
padding
-
block
-
end
"
"
padding
-
block
-
start
"
"
padding
-
bottom
"
"
padding
-
inline
"
"
padding
-
inline
-
end
"
"
padding
-
inline
-
start
"
"
padding
-
left
"
"
padding
-
right
"
"
padding
-
top
"
]
when
:
(
)
=
>
this
.
internalTableElement
&
&
!
this
.
checkComputedStyle
(
"
display
"
[
"
table
-
cell
"
]
)
fixId
:
"
inactive
-
css
-
not
-
for
-
internal
-
table
-
elements
-
except
-
table
-
cells
-
fix
"
msgId
:
"
inactive
-
css
-
not
-
for
-
internal
-
table
-
elements
-
except
-
table
-
cells
"
}
{
invalidProperties
:
[
"
border
-
collapse
"
"
border
-
spacing
"
"
table
-
layout
"
]
when
:
(
)
=
>
!
this
.
checkComputedStyle
(
"
display
"
[
"
table
"
"
inline
-
table
"
]
)
fixId
:
"
inactive
-
css
-
not
-
table
-
fix
"
msgId
:
"
inactive
-
css
-
not
-
table
"
}
{
invalidProperties
:
[
"
border
-
spacing
"
]
when
:
(
)
=
>
this
.
checkComputedStyle
(
"
border
-
collapse
"
[
"
collapse
"
]
)
fixId
:
"
inactive
-
css
-
collapsed
-
table
-
borders
-
fix
"
msgId
:
"
inactive
-
css
-
collapsed
-
table
-
borders
"
}
{
invalidProperties
:
[
"
empty
-
cells
"
]
when
:
(
)
=
>
!
this
.
checkComputedStyle
(
"
display
"
[
"
table
-
cell
"
]
)
fixId
:
"
inactive
-
css
-
not
-
table
-
cell
-
fix
"
msgId
:
"
inactive
-
css
-
not
-
table
-
cell
"
}
{
invalidProperties
:
[
"
scroll
-
padding
"
"
scroll
-
padding
-
top
"
"
scroll
-
padding
-
right
"
"
scroll
-
padding
-
bottom
"
"
scroll
-
padding
-
left
"
"
scroll
-
padding
-
block
"
"
scroll
-
padding
-
block
-
end
"
"
scroll
-
padding
-
block
-
start
"
"
scroll
-
padding
-
inline
"
"
scroll
-
padding
-
inline
-
end
"
"
scroll
-
padding
-
inline
-
start
"
]
when
:
(
)
=
>
!
this
.
isScrollContainer
fixId
:
"
inactive
-
scroll
-
padding
-
when
-
not
-
scroll
-
container
-
fix
"
msgId
:
"
inactive
-
scroll
-
padding
-
when
-
not
-
scroll
-
container
"
}
{
invalidProperties
:
[
"
border
-
image
"
"
border
-
image
-
outset
"
"
border
-
image
-
repeat
"
"
border
-
image
-
slice
"
"
border
-
image
-
source
"
"
border
-
image
-
width
"
]
when
:
(
)
=
>
this
.
internalTableElement
&
&
this
.
checkTableParentHasBorderCollapsed
(
)
fixId
:
"
inactive
-
css
-
border
-
image
-
fix
"
msgId
:
"
inactive
-
css
-
border
-
image
"
}
{
invalidProperties
:
[
"
height
"
"
min
-
height
"
"
max
-
height
"
"
width
"
"
min
-
width
"
"
max
-
width
"
]
when
:
(
)
=
>
this
.
checkComputedStyle
(
"
display
"
[
"
ruby
"
"
ruby
-
text
"
]
)
fixId
:
"
inactive
-
css
-
ruby
-
element
-
fix
"
msgId
:
"
inactive
-
css
-
ruby
-
element
"
}
{
invalidProperties
:
[
"
resize
"
]
when
:
(
)
=
>
!
this
.
isScrollContainer
&
&
!
this
.
isResizableReplacedElement
fixId
:
"
inactive
-
css
-
resize
-
fix
"
msgId
:
"
inactive
-
css
-
resize
"
}
{
invalidProperties
:
[
"
text
-
wrap
"
]
when
:
(
)
=
>
{
if
(
!
this
.
checkComputedStyle
(
"
text
-
wrap
"
[
"
balance
"
]
)
)
{
return
false
;
}
const
blockLineCounts
=
InspectorUtils
.
getBlockLineCounts
(
this
.
node
)
;
return
(
blockLineCounts
&
&
blockLineCounts
[
0
]
>
TEXT_WRAP_BALANCE_LIMIT
)
;
}
fixId
:
"
inactive
-
css
-
text
-
wrap
-
balance
-
lines
-
exceeded
-
fix
"
msgId
:
"
inactive
-
css
-
text
-
wrap
-
balance
-
lines
-
exceeded
"
lineCount
:
TEXT_WRAP_BALANCE_LIMIT
}
{
invalidProperties
:
[
"
text
-
wrap
"
]
when
:
(
)
=
>
{
if
(
!
this
.
checkComputedStyle
(
"
text
-
wrap
"
[
"
balance
"
]
)
)
{
return
false
;
}
const
blockLineCounts
=
InspectorUtils
.
getBlockLineCounts
(
this
.
node
)
;
const
isFragmented
=
blockLineCounts
&
&
blockLineCounts
.
length
>
1
;
return
isFragmented
;
}
fixId
:
"
inactive
-
css
-
text
-
wrap
-
balance
-
fragmented
-
fix
"
msgId
:
"
inactive
-
css
-
text
-
wrap
-
balance
-
fragmented
"
}
{
invalidProperties
:
[
"
box
-
sizing
"
]
when
:
(
)
=
>
this
.
nonReplacedInlineBox
fixId
:
"
learn
-
more
"
msgId
:
"
inactive
-
css
-
no
-
width
-
height
"
}
{
invalidProperties
:
[
"
anchor
-
name
"
]
when
:
(
)
=
>
!
this
.
hasPrincipalBox
fixId
:
"
inactive
-
css
-
no
-
principal
-
box
-
fix
"
msgId
:
"
inactive
-
css
-
no
-
principal
-
box
"
}
]
;
}
ACCEPTED_PROPERTIES_VALIDATORS
=
[
{
acceptedProperties
:
new
Set
(
[
"
background
"
"
background
-
color
"
"
color
"
"
text
-
decoration
"
"
text
-
decoration
-
color
"
"
text
-
decoration
-
line
"
"
text
-
decoration
-
style
"
"
text
-
decoration
-
thickness
"
"
text
-
shadow
"
"
text
-
underline
-
offset
"
"
text
-
underline
-
position
"
"
-
webkit
-
text
-
fill
-
color
"
"
-
webkit
-
text
-
stroke
-
color
"
"
-
webkit
-
text
-
stroke
-
width
"
"
-
webkit
-
text
-
stroke
"
]
)
when
:
(
)
=
>
{
const
{
selectorText
}
=
this
.
cssRule
;
return
(
selectorText
&
&
REGEXP_HIGHLIGHT_PSEUDO_ELEMENTS
.
test
(
selectorText
)
)
;
}
msgId
:
"
inactive
-
css
-
highlight
-
pseudo
-
elements
-
not
-
supported
"
fixId
:
"
learn
-
more
"
learnMoreURL
:
HIGHLIGHT_PSEUDO_ELEMENTS_STYLING_SPEC_URL
}
{
acceptedProperties
:
new
Set
(
[
"
background
"
"
background
-
attachment
"
"
background
-
blend
-
mode
"
"
background
-
clip
"
"
background
-
color
"
"
background
-
image
"
"
background
-
origin
"
"
background
-
position
"
"
background
-
position
-
x
"
"
background
-
position
-
y
"
"
background
-
repeat
"
"
background
-
size
"
"
color
"
"
font
"
"
font
-
family
"
"
font
-
size
"
"
font
-
stretch
"
"
font
-
style
"
"
font
-
variant
"
"
font
-
variant
-
alternates
"
"
font
-
variant
-
caps
"
"
font
-
variant
-
east
-
asian
"
"
font
-
variant
-
ligatures
"
"
font
-
variant
-
numeric
"
"
font
-
variant
-
position
"
"
font
-
weight
"
"
line
-
height
"
"
opacity
"
"
outline
"
"
outline
-
color
"
"
outline
-
offset
"
"
outline
-
style
"
"
outline
-
width
"
"
ruby
-
position
"
"
text
-
combine
-
upright
"
"
text
-
decoration
"
"
text
-
decoration
-
color
"
"
text
-
decoration
-
line
"
"
text
-
decoration
-
style
"
"
text
-
decoration
-
thickness
"
"
text
-
shadow
"
"
visibility
"
"
white
-
space
"
]
)
when
:
(
)
=
>
{
const
{
selectorText
}
=
this
.
cssRule
;
return
selectorText
&
&
selectorText
.
includes
(
"
:
:
cue
"
)
;
}
msgId
:
"
inactive
-
css
-
cue
-
pseudo
-
element
-
not
-
supported
"
fixId
:
"
learn
-
more
"
learnMoreURL
:
CUE_PSEUDO_ELEMENT_STYLING_SPEC_URL
}
]
;
get
invalidProperties
(
)
{
if
(
!
this
.
_invalidProperties
)
{
const
allProps
=
this
.
INVALID_PROPERTIES_VALIDATORS
.
map
(
v
=
>
v
.
invalidProperties
)
.
flat
(
)
;
this
.
_invalidProperties
=
new
Set
(
allProps
)
;
}
return
this
.
_invalidProperties
;
}
isPropertyUsed
(
el
elStyle
cssRule
property
)
{
if
(
!
INACTIVE_CSS_ENABLED
)
{
return
{
used
:
true
}
;
}
let
fixId
=
"
"
;
let
msgId
=
"
"
;
let
learnMoreURL
=
null
;
let
lineCount
=
null
;
let
used
=
true
;
const
someFn
=
validator
=
>
{
let
isRuleConcerned
=
false
;
if
(
validator
.
invalidProperties
)
{
isRuleConcerned
=
validator
.
invalidProperties
.
includes
(
property
)
;
}
else
if
(
validator
.
acceptedProperties
)
{
isRuleConcerned
=
!
validator
.
acceptedProperties
.
has
(
property
)
&
&
!
property
.
startsWith
(
"
-
-
"
)
;
}
if
(
!
isRuleConcerned
)
{
return
false
;
}
this
.
select
(
el
elStyle
cssRule
property
)
;
if
(
validator
.
when
(
)
)
{
fixId
=
validator
.
fixId
;
msgId
=
validator
.
msgId
;
learnMoreURL
=
validator
.
learnMoreURL
;
lineCount
=
validator
.
lineCount
;
used
=
false
;
return
true
;
}
return
false
;
}
;
const
isNotAccepted
=
this
.
ACCEPTED_PROPERTIES_VALIDATORS
.
some
(
someFn
)
;
if
(
!
isNotAccepted
&
&
!
this
.
invalidProperties
.
has
(
property
)
)
{
this
.
unselect
(
)
;
return
{
used
:
true
}
;
}
if
(
!
isNotAccepted
)
{
this
.
INVALID_PROPERTIES_VALIDATORS
.
some
(
someFn
)
;
}
this
.
unselect
(
)
;
let
display
;
try
{
display
=
elStyle
?
elStyle
.
display
:
null
;
}
catch
(
e
)
{
}
return
{
display
fixId
msgId
property
learnMoreURL
lineCount
used
}
;
}
select
(
node
style
cssRule
property
)
{
this
.
_node
=
node
;
this
.
_cssRule
=
cssRule
;
this
.
_property
=
property
;
this
.
_style
=
style
;
}
unselect
(
)
{
this
.
_node
=
null
;
this
.
_cssRule
=
null
;
this
.
_property
=
null
;
this
.
_style
=
null
;
}
get
node
(
)
{
return
this
.
_node
;
}
get
style
(
)
{
return
this
.
_style
;
}
get
cssRule
(
)
{
return
this
.
_cssRule
;
}
checkComputedStyle
(
propName
values
)
{
if
(
!
this
.
style
)
{
return
false
;
}
return
values
.
some
(
value
=
>
this
.
style
[
propName
]
=
=
=
value
)
;
}
checkResolvedStyle
(
propName
values
)
{
if
(
!
(
this
.
cssRule
&
&
this
.
cssRule
.
style
)
)
{
return
false
;
}
const
{
style
}
=
this
.
cssRule
;
return
values
.
some
(
value
=
>
style
[
propName
]
=
=
=
value
)
;
}
isBlockLevel
(
)
{
return
this
.
checkComputedStyle
(
"
display
"
[
"
block
"
"
flow
-
root
"
"
flex
"
"
grid
"
"
table
"
]
)
;
}
isInlineLevel
(
)
{
return
this
.
checkComputedStyle
(
"
display
"
[
"
inline
"
"
inline
-
block
"
"
inline
-
table
"
"
inline
-
flex
"
"
inline
-
grid
"
"
table
-
cell
"
"
table
-
row
"
"
table
-
row
-
group
"
"
table
-
header
-
group
"
"
table
-
footer
-
group
"
]
)
;
}
get
flexContainer
(
)
{
return
this
.
checkComputedStyle
(
"
display
"
[
"
flex
"
"
inline
-
flex
"
]
)
;
}
get
flexItem
(
)
{
return
this
.
isFlexItem
(
this
.
node
)
;
}
get
gridContainer
(
)
{
return
this
.
checkComputedStyle
(
"
display
"
[
"
grid
"
"
inline
-
grid
"
]
)
;
}
get
gridItem
(
)
{
return
this
.
isGridItem
(
this
.
node
)
;
}
get
multiColContainer
(
)
{
const
autoColumnWidth
=
this
.
checkComputedStyle
(
"
column
-
width
"
[
"
auto
"
]
)
;
const
autoColumnCount
=
this
.
checkComputedStyle
(
"
column
-
count
"
[
"
auto
"
]
)
;
return
!
autoColumnWidth
|
|
!
autoColumnCount
;
}
get
inMultiColContainer
(
)
{
return
!
!
this
.
getParentMultiColElement
(
this
.
node
)
;
}
get
table
(
)
{
return
this
.
checkComputedStyle
(
"
display
"
[
"
table
"
"
inline
-
table
"
]
)
;
}
get
tableRow
(
)
{
return
this
.
style
&
&
this
.
style
.
display
=
=
=
"
table
-
row
"
;
}
get
tableColumn
(
)
{
return
this
.
style
&
&
this
.
style
.
display
=
=
=
"
table
-
column
"
;
}
get
internalTableElement
(
)
{
return
this
.
checkComputedStyle
(
"
display
"
[
"
table
-
cell
"
"
table
-
row
"
"
table
-
row
-
group
"
"
table
-
header
-
group
"
"
table
-
footer
-
group
"
"
table
-
column
"
"
table
-
column
-
group
"
]
)
;
}
get
horizontalTableTrack
(
)
{
if
(
!
this
.
tableRow
&
&
!
this
.
tableColumn
)
{
return
false
;
}
const
tableTrackParent
=
this
.
getTableTrackParent
(
)
;
return
this
.
hasVerticalWritingMode
(
tableTrackParent
)
?
this
.
tableColumn
:
this
.
tableRow
;
}
get
verticalTableTrack
(
)
{
if
(
!
this
.
tableRow
&
&
!
this
.
tableColumn
)
{
return
false
;
}
const
tableTrackParent
=
this
.
getTableTrackParent
(
)
;
return
this
.
hasVerticalWritingMode
(
tableTrackParent
)
?
this
.
tableRow
:
this
.
tableColumn
;
}
get
rowGroup
(
)
{
return
this
.
isRowGroup
(
this
.
node
)
;
}
get
columnGroup
(
)
{
return
this
.
isColumnGroup
(
this
.
node
)
;
}
get
horizontalTableTrackGroup
(
)
{
if
(
!
this
.
rowGroup
&
&
!
this
.
columnGroup
)
{
return
false
;
}
const
tableTrackParent
=
this
.
getTableTrackParent
(
true
)
;
const
isVertical
=
this
.
hasVerticalWritingMode
(
tableTrackParent
)
;
const
isHorizontalRowGroup
=
this
.
rowGroup
&
&
!
isVertical
;
const
isHorizontalColumnGroup
=
this
.
columnGroup
&
&
isVertical
;
return
isHorizontalRowGroup
|
|
isHorizontalColumnGroup
;
}
get
verticalTableTrackGroup
(
)
{
if
(
!
this
.
rowGroup
&
&
!
this
.
columnGroup
)
{
return
false
;
}
const
tableTrackParent
=
this
.
getTableTrackParent
(
true
)
;
const
isVertical
=
this
.
hasVerticalWritingMode
(
tableTrackParent
)
;
const
isVerticalRowGroup
=
this
.
rowGroup
&
&
isVertical
;
const
isVerticalColumnGroup
=
this
.
columnGroup
&
&
!
isVertical
;
return
isVerticalRowGroup
|
|
isVerticalColumnGroup
;
}
get
rubyContainer
(
)
{
return
this
.
checkComputedStyle
(
"
display
"
[
"
ruby
"
]
)
;
}
get
internalRubyElement
(
)
{
return
this
.
checkComputedStyle
(
"
display
"
[
"
ruby
-
base
"
"
ruby
-
text
"
"
ruby
-
base
-
container
"
"
ruby
-
text
-
container
"
]
)
;
}
get
hasCssLayout
(
)
{
return
!
this
.
isSvg
&
&
!
this
.
isMathMl
;
}
get
nonReplacedInlineBox
(
)
{
return
(
this
.
hasCssLayout
&
&
this
.
nonReplaced
&
&
this
.
style
&
&
this
.
style
.
display
=
=
=
"
inline
"
)
;
}
get
nonAtomicInlineBox
(
)
{
return
(
this
.
hasCssLayout
&
&
this
.
nonReplaced
&
&
this
.
style
&
&
this
.
checkComputedStyle
(
"
display
"
[
"
inline
"
"
inline
list
-
item
"
]
)
)
;
}
get
hasPrincipalBox
(
)
{
return
(
this
.
hasCssLayout
&
&
this
.
style
&
&
this
.
style
.
display
!
=
=
"
none
"
&
&
this
.
style
.
display
!
=
=
"
contents
"
)
;
}
get
isFirstLetter
(
)
{
const
{
selectorText
}
=
this
.
cssRule
;
return
selectorText
&
&
selectorText
.
includes
(
"
:
:
first
-
letter
"
)
;
}
get
isFirstLine
(
)
{
const
{
selectorText
}
=
this
.
cssRule
;
return
selectorText
&
&
selectorText
.
includes
(
"
:
:
first
-
line
"
)
;
}
get
nonReplaced
(
)
{
return
!
this
.
replaced
;
}
get
isAbsolutelyPositioned
(
)
{
return
this
.
checkComputedStyle
(
"
position
"
[
"
absolute
"
"
fixed
"
]
)
;
}
get
isPositioned
(
)
{
return
this
.
checkComputedStyle
(
"
position
"
[
"
relative
"
"
absolute
"
"
fixed
"
"
sticky
"
]
)
;
}
get
isFloated
(
)
{
return
this
.
style
&
&
this
.
style
.
cssFloat
!
=
=
"
none
"
;
}
get
isScrollContainer
(
)
{
const
overflow
=
computedStyle
(
this
.
node
)
.
overflow
;
const
overflowValues
=
overflow
.
split
(
"
"
)
;
return
!
(
overflowValues
.
includes
(
"
visible
"
)
|
|
overflowValues
.
includes
(
"
clip
"
)
)
;
}
get
isResizableReplacedElement
(
)
{
return
this
.
localName
=
=
=
"
textarea
"
;
}
get
replaced
(
)
{
if
(
REPLACED_ELEMENTS_NAMES
.
has
(
this
.
localName
)
)
{
return
true
;
}
if
(
this
.
localName
=
=
=
"
img
"
&
&
this
.
node
.
complete
)
{
return
true
;
}
return
false
;
}
get
localName
(
)
{
return
this
.
node
.
localName
;
}
get
isMathMl
(
)
{
return
this
.
node
.
namespaceURI
=
=
=
"
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
"
;
}
get
isSvg
(
)
{
return
this
.
node
.
namespaceURI
=
=
=
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
;
}
isAbsPosGridElement
(
)
{
if
(
!
this
.
isAbsolutelyPositioned
)
{
return
false
;
}
const
containingBlock
=
this
.
getContainingBlock
(
)
;
return
containingBlock
!
=
=
null
&
&
this
.
isGridContainer
(
containingBlock
)
;
}
isFlexItem
(
node
)
{
return
!
!
node
.
parentFlexElement
;
}
isFlexContainer
(
node
)
{
return
!
!
node
.
getAsFlexContainer
(
)
;
}
isGridContainer
(
node
)
{
return
node
.
hasGridFragments
(
)
;
}
isGridItem
(
)
{
return
!
!
this
.
getParentGridElement
(
this
.
node
)
;
}
isVisitedRule
(
)
{
if
(
!
CssLogic
.
hasVisitedState
(
this
.
node
)
)
{
return
false
;
}
const
selectors
=
CssLogic
.
getSelectors
(
this
.
cssRule
)
;
if
(
!
selectors
.
some
(
s
=
>
s
.
endsWith
(
"
:
visited
"
)
)
)
{
return
false
;
}
const
{
bindingElement
pseudo
}
=
CssLogic
.
getBindingElementAndPseudo
(
this
.
node
)
;
for
(
let
i
=
0
;
i
<
selectors
.
length
;
i
+
+
)
{
if
(
!
selectors
[
i
]
.
endsWith
(
"
:
visited
"
)
&
&
this
.
cssRule
.
selectorMatchesElement
(
i
bindingElement
pseudo
true
)
)
{
return
false
;
}
}
return
true
;
}
getContainingBlock
(
)
{
return
this
.
node
?
InspectorUtils
.
containingBlockOf
(
this
.
node
)
:
null
;
}
getParentGridElement
(
node
)
{
if
(
node
.
flattenedTreeParentNode
=
=
=
node
.
ownerDocument
)
{
return
null
;
}
if
(
node
.
nodeType
=
=
=
node
.
ELEMENT_NODE
)
{
const
display
=
this
.
style
?
this
.
style
.
display
:
null
;
if
(
!
display
|
|
display
=
=
=
"
none
"
|
|
display
=
=
=
"
contents
"
)
{
return
null
;
}
if
(
this
.
isAbsolutelyPositioned
)
{
return
null
;
}
}
else
if
(
node
.
nodeType
!
=
=
node
.
TEXT_NODE
)
{
return
null
;
}
for
(
let
p
=
node
.
flattenedTreeParentNode
;
p
;
p
=
p
.
flattenedTreeParentNode
)
{
if
(
this
.
isGridContainer
(
p
)
)
{
return
p
;
}
const
style
=
computedStyle
(
p
node
.
ownerGlobal
)
;
const
display
=
style
.
display
;
if
(
display
!
=
=
"
contents
"
)
{
return
null
;
}
}
return
null
;
}
getParentMultiColElement
(
node
)
{
if
(
node
.
flattenedTreeParentNode
=
=
=
node
.
ownerDocument
)
{
return
null
;
}
if
(
node
.
nodeType
!
=
=
node
.
ELEMENT_NODE
&
&
node
.
nodeType
!
=
=
node
.
TEXT_NODE
)
{
return
null
;
}
if
(
node
.
nodeType
=
=
=
node
.
ELEMENT_NODE
)
{
const
display
=
this
.
style
?
this
.
style
.
display
:
null
;
if
(
!
display
|
|
display
=
=
=
"
none
"
|
|
display
=
=
=
"
contents
"
)
{
return
null
;
}
if
(
this
.
isAbsolutelyPositioned
)
{
return
null
;
}
}
for
(
let
p
=
node
.
flattenedTreeParentNode
;
p
&
&
p
!
=
=
node
.
ownerDocument
;
p
=
p
.
flattenedTreeParentNode
)
{
const
style
=
computedStyle
(
p
node
.
ownerGlobal
)
;
if
(
style
.
columnWidth
!
=
=
"
auto
"
|
|
style
.
columnCount
!
=
=
"
auto
"
)
{
return
p
;
}
}
return
null
;
}
isRowGroup
(
node
)
{
const
style
=
node
=
=
=
this
.
node
?
this
.
style
:
computedStyle
(
node
)
;
return
(
style
&
&
(
style
.
display
=
=
=
"
table
-
row
-
group
"
|
|
style
.
display
=
=
=
"
table
-
header
-
group
"
|
|
style
.
display
=
=
=
"
table
-
footer
-
group
"
)
)
;
}
isColumnGroup
(
node
)
{
const
style
=
node
=
=
=
this
.
node
?
this
.
style
:
computedStyle
(
node
)
;
return
style
&
&
style
.
display
=
=
=
"
table
-
column
-
group
"
;
}
hasVerticalWritingMode
(
node
)
{
return
computedStyle
(
node
)
.
writingMode
!
=
=
"
horizontal
-
tb
"
;
}
getTableTrackParent
(
isGroup
)
{
let
current
=
this
.
node
.
parentNode
;
while
(
computedStyle
(
current
)
.
display
=
=
=
"
contents
"
)
{
current
=
current
.
parentNode
;
}
if
(
!
isGroup
&
&
(
this
.
isRowGroup
(
current
)
|
|
this
.
isColumnGroup
(
current
)
)
)
{
current
=
current
.
parentNode
;
}
while
(
computedStyle
(
current
)
.
display
=
=
=
"
contents
"
)
{
current
=
current
.
parentNode
;
}
return
current
;
}
getTableParent
(
)
{
let
current
=
this
.
node
.
parentNode
;
while
(
current
&
&
computedStyle
(
current
)
.
display
!
=
=
"
table
"
)
{
current
=
current
.
parentNode
;
if
(
current
=
=
this
.
node
.
ownerDocument
.
documentElement
)
{
return
null
;
}
}
return
current
;
}
checkTableParentHasBorderCollapsed
(
)
{
const
parent
=
this
.
getTableParent
(
)
;
if
(
!
parent
)
{
return
false
;
}
return
computedStyle
(
parent
)
.
borderCollapse
=
=
=
"
collapse
"
;
}
}
function
allCssPropertiesExcept
(
propertiesToIgnore
)
{
const
properties
=
new
Set
(
InspectorUtils
.
getCSSPropertyNames
(
{
includeAliases
:
true
}
)
)
;
for
(
const
name
of
propertiesToIgnore
)
{
properties
.
delete
(
name
)
;
}
return
[
.
.
.
properties
]
;
}
function
computedStyle
(
node
window
=
node
.
ownerGlobal
)
{
return
window
.
getComputedStyle
(
node
)
;
}
const
inactivePropertyHelper
=
new
InactivePropertyHelper
(
)
;
exports
.
isPropertyUsed
=
inactivePropertyHelper
.
isPropertyUsed
.
bind
(
inactivePropertyHelper
)
;
