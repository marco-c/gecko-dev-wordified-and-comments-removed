"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
"
Ci
"
"
chrome
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
colorUtils
"
"
devtools
/
shared
/
css
/
color
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
actors
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getBounds
"
"
devtools
/
server
/
actors
/
highlighters
/
utils
/
accessibility
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getCurrentZoom
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Services
"
)
;
loader
.
lazyRequireGetter
(
this
"
addPseudoClassLock
"
"
devtools
/
server
/
actors
/
highlighters
/
utils
/
markup
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
removePseudoClassLock
"
"
devtools
/
server
/
actors
/
highlighters
/
utils
/
markup
"
true
)
;
const
HIGHLIGHTED_PSEUDO_CLASS
=
"
:
-
moz
-
devtools
-
highlighted
"
;
function
getTextProperties
(
node
)
{
const
computedStyles
=
CssLogic
.
getComputedStyle
(
node
)
;
if
(
!
computedStyles
)
{
return
null
;
}
const
{
color
"
font
-
size
"
:
fontSize
"
font
-
weight
"
:
fontWeight
}
=
computedStyles
;
const
opacity
=
parseFloat
(
computedStyles
.
opacity
)
;
let
{
r
g
b
a
}
=
colorUtils
.
colorToRGBA
(
color
true
)
;
a
=
opacity
*
a
;
const
textRgbaColor
=
new
colorUtils
.
CssColor
(
rgba
(
{
r
}
{
g
}
{
b
}
{
a
}
)
true
)
;
if
(
textRgbaColor
.
isTransparent
(
)
)
{
return
null
;
}
const
isBoldText
=
parseInt
(
fontWeight
10
)
>
=
600
;
const
isLargeText
=
Math
.
ceil
(
parseFloat
(
fontSize
)
*
72
)
/
96
>
=
(
isBoldText
?
14
:
18
)
;
return
{
color
:
colorUtils
.
blendColors
(
[
r
g
b
a
]
)
isLargeText
}
;
}
function
getImageCtx
(
win
bounds
node
)
{
const
doc
=
win
.
document
;
const
canvas
=
doc
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
const
scale
=
getCurrentZoom
(
win
)
;
const
{
left
top
width
height
}
=
bounds
;
canvas
.
width
=
width
/
scale
;
canvas
.
height
=
height
/
scale
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
{
alpha
:
false
}
)
;
if
(
node
)
{
addPseudoClassLock
(
node
HIGHLIGHTED_PSEUDO_CLASS
)
;
}
ctx
.
drawWindow
(
win
left
/
scale
top
/
scale
width
/
scale
height
/
scale
"
#
fff
"
ctx
.
DRAWWINDOW_USE_WIDGET_LAYERS
)
;
if
(
node
)
{
removePseudoClassLock
(
node
HIGHLIGHTED_PSEUDO_CLASS
)
;
}
return
ctx
;
}
function
getBgRGBA
(
dataText
dataBackground
)
{
let
min
=
[
0
0
0
1
]
;
let
max
=
[
255
255
255
1
]
;
let
minLuminance
=
1
;
let
maxLuminance
=
0
;
const
luminances
=
{
}
;
let
foundDistinctColor
=
false
;
for
(
let
i
=
0
;
i
<
dataText
.
length
;
i
=
i
+
4
)
{
const
tR
=
dataText
[
i
]
;
const
bgR
=
dataBackground
[
i
]
;
const
tG
=
dataText
[
i
+
1
]
;
const
bgG
=
dataBackground
[
i
+
1
]
;
const
tB
=
dataText
[
i
+
2
]
;
const
bgB
=
dataBackground
[
i
+
2
]
;
if
(
tR
=
=
=
bgR
&
&
tG
=
=
=
bgG
&
&
tB
=
=
=
bgB
)
{
continue
;
}
foundDistinctColor
=
true
;
const
bgColor
=
rgb
(
{
bgR
}
{
bgG
}
{
bgB
}
)
;
let
luminance
=
luminances
[
bgColor
]
;
if
(
!
luminance
)
{
luminance
=
colorUtils
.
calculateLuminance
(
[
bgR
bgG
bgB
]
)
;
luminances
[
bgColor
]
=
luminance
;
}
if
(
minLuminance
>
=
luminance
)
{
minLuminance
=
luminance
;
min
=
[
bgR
bgG
bgB
1
]
;
}
if
(
maxLuminance
<
=
luminance
)
{
maxLuminance
=
luminance
;
max
=
[
bgR
bgG
bgB
1
]
;
}
}
if
(
!
foundDistinctColor
)
{
return
null
;
}
return
minLuminance
=
=
=
maxLuminance
?
{
value
:
max
}
:
{
min
max
}
;
}
function
getContrastRatioFor
(
node
options
=
{
}
)
{
const
props
=
getTextProperties
(
node
)
;
if
(
!
props
)
{
return
{
error
:
true
}
;
}
const
bounds
=
getBounds
(
options
.
win
options
.
bounds
)
;
const
textContext
=
getImageCtx
(
options
.
win
bounds
)
;
const
backgroundContext
=
getImageCtx
(
options
.
win
bounds
node
)
;
const
{
data
:
dataText
}
=
textContext
.
getImageData
(
0
0
bounds
.
width
bounds
.
height
)
;
const
{
data
:
dataBackground
}
=
backgroundContext
.
getImageData
(
0
0
bounds
.
width
bounds
.
height
)
;
const
rgba
=
getBgRGBA
(
dataText
dataBackground
)
;
if
(
!
rgba
)
{
return
{
error
:
true
}
;
}
const
{
color
isLargeText
}
=
props
;
if
(
rgba
.
value
)
{
return
{
value
:
colorUtils
.
calculateContrastRatio
(
rgba
.
value
color
)
isLargeText
}
;
}
const
min
=
colorUtils
.
calculateContrastRatio
(
rgba
.
min
Array
.
from
(
color
)
)
;
const
max
=
colorUtils
.
calculateContrastRatio
(
rgba
.
max
Array
.
from
(
color
)
)
;
return
{
min
:
min
<
max
?
min
:
max
max
:
min
<
max
?
max
:
min
isLargeText
}
;
}
function
isDefunct
(
accessible
)
{
if
(
!
Services
.
appinfo
.
accessibilityEnabled
)
{
return
true
;
}
let
defunct
=
false
;
try
{
const
extraState
=
{
}
;
accessible
.
getState
(
{
}
extraState
)
;
defunct
=
!
!
(
extraState
.
value
&
Ci
.
nsIAccessibleStates
.
EXT_STATE_DEFUNCT
)
;
}
catch
(
e
)
{
defunct
=
true
;
}
return
defunct
;
}
exports
.
getContrastRatioFor
=
getContrastRatioFor
;
exports
.
isDefunct
=
isDefunct
;
