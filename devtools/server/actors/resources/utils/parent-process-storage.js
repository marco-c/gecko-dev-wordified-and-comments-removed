"
use
strict
"
;
const
{
storageTypePool
}
=
require
(
"
devtools
/
server
/
actors
/
storage
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
getAllBrowsingContextsForContext
isWindowGlobalPartOfContext
}
=
require
(
"
devtools
/
server
/
actors
/
watcher
/
browsing
-
context
-
helpers
.
jsm
"
)
;
const
BATCH_DELAY
=
200
;
function
getFilteredStorageEvents
(
updates
storageType
)
{
const
filteredUpdate
=
Object
.
create
(
null
)
;
for
(
const
updateType
in
updates
)
{
if
(
updates
[
updateType
]
[
storageType
]
)
{
if
(
!
filteredUpdate
[
updateType
]
)
{
filteredUpdate
[
updateType
]
=
{
}
;
}
filteredUpdate
[
updateType
]
[
storageType
]
=
updates
[
updateType
]
[
storageType
]
;
}
}
return
Object
.
keys
(
filteredUpdate
)
.
length
?
filteredUpdate
:
null
;
}
class
ParentProcessStorage
{
constructor
(
storageKey
storageType
)
{
this
.
storageKey
=
storageKey
;
this
.
storageType
=
storageType
;
this
.
onStoresUpdate
=
this
.
onStoresUpdate
.
bind
(
this
)
;
this
.
onStoresCleared
=
this
.
onStoresCleared
.
bind
(
this
)
;
this
.
observe
=
this
.
observe
.
bind
(
this
)
;
Services
.
obs
.
addObserver
(
this
"
window
-
global
-
created
"
)
;
Services
.
obs
.
addObserver
(
this
"
window
-
global
-
destroyed
"
)
;
loader
.
lazyGetter
(
this
"
isBfcacheInParentEnabled
"
(
)
=
>
Services
.
appinfo
.
sessionHistoryInParent
&
&
Services
.
prefs
.
getBoolPref
(
"
fission
.
bfcacheInParent
"
false
)
)
;
}
async
watch
(
watcherActor
{
onAvailable
}
)
{
this
.
watcherActor
=
watcherActor
;
this
.
onAvailable
=
onAvailable
;
this
.
_offPageShow
=
watcherActor
.
on
(
"
bf
-
cache
-
navigation
-
pageshow
"
(
{
windowGlobal
}
)
=
>
this
.
_onNewWindowGlobal
(
windowGlobal
true
)
)
;
if
(
watcherActor
.
sessionContext
.
type
=
=
"
browser
-
element
"
)
{
const
{
browsingContext
innerWindowID
:
innerWindowId
}
=
watcherActor
.
browserElement
;
await
this
.
_spawnActor
(
browsingContext
.
id
innerWindowId
)
;
}
else
if
(
watcherActor
.
sessionContext
.
type
=
=
"
webextension
"
)
{
const
{
addonBrowsingContextID
addonInnerWindowId
}
=
watcherActor
.
sessionContext
;
await
this
.
_spawnActor
(
addonBrowsingContextID
addonInnerWindowId
)
;
}
else
{
throw
new
Error
(
"
Unsupported
session
context
type
=
"
+
watcherActor
.
sessionContext
.
type
)
;
}
}
onStoresUpdate
(
response
)
{
response
=
getFilteredStorageEvents
(
response
this
.
storageKey
)
;
if
(
!
response
)
{
return
;
}
this
.
actor
.
emit
(
"
single
-
store
-
update
"
{
changed
:
response
.
changed
added
:
response
.
added
deleted
:
response
.
deleted
}
)
;
}
onStoresCleared
(
response
)
{
const
cleared
=
response
[
this
.
storageKey
]
;
if
(
!
cleared
)
{
return
;
}
this
.
actor
.
emit
(
"
single
-
store
-
cleared
"
{
clearedHostsOrPaths
:
cleared
}
)
;
}
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
"
window
-
global
-
created
"
)
;
Services
.
obs
.
removeObserver
(
this
"
window
-
global
-
destroyed
"
)
;
this
.
_offPageShow
(
)
;
this
.
_cleanActor
(
)
;
}
async
_spawnActor
(
browsingContextID
innerWindowId
)
{
const
ActorConstructor
=
storageTypePool
.
get
(
this
.
storageKey
)
;
const
storageActor
=
new
StorageActorMock
(
this
.
watcherActor
)
;
this
.
storageActor
=
storageActor
;
this
.
actor
=
new
ActorConstructor
(
storageActor
)
;
if
(
typeof
this
.
actor
.
preListStores
=
=
=
"
function
"
)
{
try
{
await
this
.
actor
.
preListStores
(
)
;
}
catch
(
e
)
{
if
(
this
.
actor
)
{
throw
e
;
}
}
}
if
(
!
this
.
actor
)
{
return
;
}
this
.
watcherActor
.
manage
(
this
.
actor
)
;
const
storage
=
this
.
actor
.
form
(
)
;
storage
.
resourceType
=
this
.
storageType
;
storage
.
resourceId
=
{
this
.
storageType
}
-
{
innerWindowId
}
;
storage
.
resourceKey
=
this
.
storageKey
;
storage
.
browsingContextID
=
browsingContextID
;
this
.
onAvailable
(
[
storage
]
)
;
storageActor
.
on
(
"
stores
-
update
"
this
.
onStoresUpdate
)
;
storageActor
.
on
(
"
stores
-
cleared
"
this
.
onStoresCleared
)
;
}
_cleanActor
(
)
{
this
.
actor
?
.
destroy
(
)
;
this
.
actor
=
null
;
if
(
this
.
storageActor
)
{
this
.
storageActor
.
off
(
"
stores
-
update
"
this
.
onStoresUpdate
)
;
this
.
storageActor
.
off
(
"
stores
-
cleared
"
this
.
onStoresCleared
)
;
this
.
storageActor
.
destroy
(
)
;
this
.
storageActor
=
null
;
}
}
observe
(
subject
topic
)
{
if
(
topic
=
=
=
"
window
-
global
-
created
"
)
{
this
.
_onNewWindowGlobal
(
subject
)
;
}
}
async
_onNewWindowGlobal
(
windowGlobal
isBfCacheNavigation
)
{
if
(
!
isWindowGlobalPartOfContext
(
windowGlobal
this
.
watcherActor
.
sessionContext
{
acceptNoWindowGlobal
:
true
acceptSameProcessIframes
:
true
}
)
)
{
return
;
}
if
(
windowGlobal
.
documentURI
.
displaySpec
=
=
=
"
about
:
blank
"
)
{
return
;
}
const
isTopContext
=
windowGlobal
.
browsingContext
.
top
=
=
windowGlobal
.
browsingContext
;
if
(
!
isTopContext
)
{
return
;
}
const
isNewTargetBeingCreated
=
this
.
watcherActor
.
sessionContext
.
isServerTargetSwitchingEnabled
|
|
(
isBfCacheNavigation
&
&
this
.
isBfcacheInParentEnabled
)
;
if
(
!
isNewTargetBeingCreated
)
{
return
;
}
await
new
Promise
(
resolve
=
>
{
const
listener
=
targetActorForm
=
>
{
if
(
targetActorForm
.
innerWindowId
!
=
windowGlobal
.
innerWindowId
)
{
return
;
}
this
.
watcherActor
.
off
(
"
target
-
available
-
form
"
listener
)
;
resolve
(
)
;
}
;
this
.
watcherActor
.
on
(
"
target
-
available
-
form
"
listener
)
;
}
)
;
this
.
_cleanActor
(
)
;
this
.
_spawnActor
(
windowGlobal
.
browsingContext
.
id
windowGlobal
.
innerWindowId
)
;
}
}
module
.
exports
=
ParentProcessStorage
;
class
StorageActorMock
extends
EventEmitter
{
constructor
(
watcherActor
)
{
super
(
)
;
this
.
conn
=
watcherActor
.
conn
;
this
.
watcherActor
=
watcherActor
;
this
.
boundUpdate
=
{
}
;
this
.
observe
=
this
.
observe
.
bind
(
this
)
;
Services
.
obs
.
addObserver
(
this
"
window
-
global
-
created
"
)
;
Services
.
obs
.
addObserver
(
this
"
window
-
global
-
destroyed
"
)
;
if
(
!
this
.
watcherActor
.
sessionContext
.
isServerTargetSwitchingEnabled
)
{
this
.
_offPageShow
=
watcherActor
.
on
(
"
bf
-
cache
-
navigation
-
pageshow
"
(
{
windowGlobal
}
)
=
>
{
if
(
this
.
isBfcacheInParentEnabled
)
{
return
;
}
const
windowMock
=
{
location
:
windowGlobal
.
documentURI
}
;
this
.
emit
(
"
window
-
ready
"
windowMock
)
;
}
)
;
this
.
_offPageHide
=
watcherActor
.
on
(
"
bf
-
cache
-
navigation
-
pagehide
"
(
{
windowGlobal
}
)
=
>
{
const
windowMock
=
{
location
:
windowGlobal
.
documentURI
}
;
this
.
emit
(
"
window
-
destroyed
"
windowMock
{
dontCheckHost
:
true
}
)
;
}
)
;
}
}
destroy
(
)
{
clearTimeout
(
this
.
batchTimer
)
;
this
.
batchTimer
=
null
;
Services
.
obs
.
removeObserver
(
this
"
window
-
global
-
created
"
)
;
Services
.
obs
.
removeObserver
(
this
"
window
-
global
-
destroyed
"
)
;
if
(
this
.
_offPageShow
)
{
this
.
_offPageShow
(
)
;
}
if
(
this
.
_offPageHide
)
{
this
.
_offPageHide
(
)
;
}
}
get
windows
(
)
{
return
(
getAllBrowsingContextsForContext
(
this
.
watcherActor
.
sessionContext
{
acceptSameProcessIframes
:
true
}
)
.
map
(
x
=
>
{
const
uri
=
x
.
currentWindowGlobal
.
documentURI
;
return
{
location
:
uri
}
;
}
)
.
filter
(
x
=
>
x
.
location
.
displaySpec
!
=
=
"
about
:
blank
"
)
)
;
}
getHostName
(
uri
)
{
switch
(
uri
.
scheme
)
{
case
"
about
"
:
case
"
file
"
:
case
"
javascript
"
:
case
"
resource
"
:
return
uri
.
displaySpec
;
case
"
moz
-
extension
"
:
case
"
http
"
:
case
"
https
"
:
return
uri
.
prePath
;
default
:
return
null
;
}
}
getWindowFromHost
(
host
)
{
const
hostBrowsingContext
=
getAllBrowsingContextsForContext
(
this
.
watcherActor
.
sessionContext
{
acceptSameProcessIframes
:
true
}
)
.
find
(
x
=
>
{
const
hostName
=
this
.
getHostName
(
x
.
currentWindowGlobal
.
documentURI
)
;
return
hostName
=
=
=
host
;
}
)
;
if
(
!
hostBrowsingContext
)
{
return
null
;
}
const
principal
=
hostBrowsingContext
.
currentWindowGlobal
.
documentStoragePrincipal
;
return
{
document
:
{
effectiveStoragePrincipal
:
principal
}
}
;
}
get
parentActor
(
)
{
return
{
isRootActor
:
this
.
watcherActor
.
sessionContext
.
type
=
=
"
all
"
}
;
}
async
observe
(
windowGlobal
topic
)
{
if
(
!
isWindowGlobalPartOfContext
(
windowGlobal
this
.
watcherActor
.
sessionContext
{
acceptNoWindowGlobal
:
true
acceptSameProcessIframes
:
true
}
)
)
{
return
;
}
if
(
windowGlobal
.
documentURI
.
displaySpec
=
=
=
"
about
:
blank
"
)
{
return
;
}
const
isTopContext
=
windowGlobal
.
browsingContext
.
top
=
=
windowGlobal
.
browsingContext
;
if
(
isTopContext
&
&
this
.
watcherActor
.
sessionContext
.
isServerTargetSwitchingEnabled
)
{
return
;
}
const
windowMock
=
{
location
:
windowGlobal
.
documentURI
}
;
if
(
topic
=
=
=
"
window
-
global
-
created
"
)
{
this
.
emit
(
"
window
-
ready
"
windowMock
)
;
}
else
if
(
topic
=
=
=
"
window
-
global
-
destroyed
"
)
{
this
.
emit
(
"
window
-
destroyed
"
windowMock
)
;
}
}
update
(
action
storeType
data
)
{
if
(
action
=
=
"
cleared
"
)
{
this
.
emit
(
"
stores
-
cleared
"
{
[
storeType
]
:
data
}
)
;
return
null
;
}
if
(
this
.
batchTimer
)
{
clearTimeout
(
this
.
batchTimer
)
;
}
if
(
!
this
.
boundUpdate
[
action
]
)
{
this
.
boundUpdate
[
action
]
=
{
}
;
}
if
(
!
this
.
boundUpdate
[
action
]
[
storeType
]
)
{
this
.
boundUpdate
[
action
]
[
storeType
]
=
{
}
;
}
for
(
const
host
in
data
)
{
if
(
!
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
)
{
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
=
[
]
;
}
for
(
const
name
of
data
[
host
]
)
{
if
(
!
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
.
includes
(
name
)
)
{
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
.
push
(
name
)
;
}
}
}
if
(
action
=
=
"
added
"
)
{
this
.
removeNamesFromUpdateList
(
"
deleted
"
storeType
data
)
;
this
.
removeNamesFromUpdateList
(
"
changed
"
storeType
data
)
;
}
else
if
(
action
=
=
"
changed
"
&
&
this
.
boundUpdate
.
added
&
&
this
.
boundUpdate
.
added
[
storeType
]
)
{
this
.
removeNamesFromUpdateList
(
"
changed
"
storeType
this
.
boundUpdate
.
added
[
storeType
]
)
;
}
else
if
(
action
=
=
"
deleted
"
)
{
this
.
removeNamesFromUpdateList
(
"
added
"
storeType
data
)
;
this
.
removeNamesFromUpdateList
(
"
changed
"
storeType
data
)
;
for
(
const
host
in
data
)
{
if
(
!
data
[
host
]
.
length
&
&
this
.
boundUpdate
.
added
&
&
this
.
boundUpdate
.
added
[
storeType
]
&
&
this
.
boundUpdate
.
added
[
storeType
]
[
host
]
)
{
delete
this
.
boundUpdate
.
added
[
storeType
]
[
host
]
;
}
if
(
!
data
[
host
]
.
length
&
&
this
.
boundUpdate
.
changed
&
&
this
.
boundUpdate
.
changed
[
storeType
]
&
&
this
.
boundUpdate
.
changed
[
storeType
]
[
host
]
)
{
delete
this
.
boundUpdate
.
changed
[
storeType
]
[
host
]
;
}
}
}
this
.
batchTimer
=
setTimeout
(
(
)
=
>
{
clearTimeout
(
this
.
batchTimer
)
;
this
.
emit
(
"
stores
-
update
"
this
.
boundUpdate
)
;
this
.
boundUpdate
=
{
}
;
}
BATCH_DELAY
)
;
return
null
;
}
removeNamesFromUpdateList
(
action
storeType
data
)
{
for
(
const
host
in
data
)
{
if
(
this
.
boundUpdate
[
action
]
&
&
this
.
boundUpdate
[
action
]
[
storeType
]
&
&
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
)
{
for
(
const
name
of
data
[
host
]
)
{
const
index
=
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
.
indexOf
(
name
)
;
if
(
index
>
-
1
)
{
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
.
splice
(
index
1
)
;
}
}
if
(
!
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
.
length
)
{
delete
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
;
}
}
}
return
null
;
}
}
