"
use
strict
"
;
const
{
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
{
createStringGrip
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
{
getActorIdForInternalSourceId
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
dbg
-
source
"
)
;
class
nsIConsoleListenerWatcher
{
constructor
(
targetActor
{
onAvailable
}
)
{
if
(
!
this
.
shouldHandleTarget
(
targetActor
)
)
{
return
;
}
targetActor
.
attach
(
)
;
const
listener
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIConsoleListener
"
]
)
observe
:
message
=
>
{
if
(
!
this
.
shouldHandleMessage
(
targetActor
message
)
)
{
return
;
}
onAvailable
(
[
this
.
buildResource
(
targetActor
message
)
]
)
;
}
}
;
const
cachedMessages
=
Services
.
console
.
getMessageArray
(
)
|
|
[
]
;
Services
.
console
.
registerListener
(
listener
)
;
this
.
listener
=
listener
;
const
messages
=
[
]
;
for
(
const
message
of
cachedMessages
)
{
if
(
!
this
.
shouldHandleMessage
(
targetActor
message
)
)
{
continue
;
}
messages
.
push
(
this
.
buildResource
(
targetActor
message
)
)
;
}
onAvailable
(
messages
)
;
}
shouldHandleTarget
(
targetActor
)
{
return
true
;
}
shouldHandleMessage
(
targetActor
message
)
{
throw
new
Error
(
"
'
shouldHandleMessage
'
should
be
implemented
in
the
class
that
extends
nsIConsoleListenerWatcher
"
)
;
}
buildResource
(
targetActor
message
)
{
throw
new
Error
(
"
'
buildResource
'
should
be
implemented
in
the
class
that
extends
nsIConsoleListenerWatcher
"
)
;
}
prepareStackForRemote
(
targetActor
errorStack
)
{
if
(
!
errorStack
|
|
(
Cu
&
&
Cu
.
isDeadWrapper
(
errorStack
)
)
)
{
return
null
;
}
const
stack
=
[
]
;
let
s
=
errorStack
;
while
(
s
)
{
stack
.
push
(
{
filename
:
s
.
source
sourceId
:
getActorIdForInternalSourceId
(
targetActor
s
.
sourceId
)
lineNumber
:
s
.
line
columnNumber
:
s
.
column
functionName
:
s
.
functionDisplayName
asyncCause
:
s
.
asyncCause
?
s
.
asyncCause
:
undefined
}
)
;
s
=
s
.
parent
|
|
s
.
asyncParent
;
}
return
stack
;
}
prepareNotesForRemote
(
targetActor
errorNotes
)
{
if
(
!
errorNotes
?
.
length
)
{
return
null
;
}
const
notes
=
[
]
;
for
(
let
i
=
0
len
=
errorNotes
.
length
;
i
<
len
;
i
+
+
)
{
const
note
=
errorNotes
.
queryElementAt
(
i
Ci
.
nsIScriptErrorNote
)
;
notes
.
push
(
{
messageBody
:
createStringGrip
(
targetActor
note
.
errorMessage
)
frame
:
{
source
:
note
.
sourceName
sourceId
:
getActorIdForInternalSourceId
(
targetActor
note
.
sourceId
)
line
:
note
.
lineNumber
column
:
note
.
columnNumber
}
}
)
;
}
return
notes
;
}
isProcessTarget
(
targetActor
)
{
const
{
typeName
}
=
targetActor
;
return
(
typeName
=
=
=
"
parentProcessTarget
"
|
|
typeName
=
=
=
"
contentProcessTarget
"
)
;
}
destroy
(
)
{
if
(
this
.
listener
)
{
Services
.
console
.
unregisterListener
(
this
.
listener
)
;
}
}
}
module
.
exports
=
nsIConsoleListenerWatcher
;
