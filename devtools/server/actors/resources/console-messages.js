"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
{
TYPES
:
{
CONSOLE_MESSAGE
}
}
=
require
(
"
devtools
/
server
/
actors
/
resources
/
index
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
WebConsoleUtils
}
=
require
(
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
)
;
const
{
ConsoleAPIListener
}
=
require
(
"
devtools
/
server
/
actors
/
webconsole
/
listeners
/
console
-
api
"
)
;
const
{
createValueGrip
isArray
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
{
ObjectActor
}
=
require
(
"
devtools
/
server
/
actors
/
object
"
)
;
loader
.
lazyRequireGetter
(
this
"
EnvironmentActor
"
"
devtools
/
server
/
actors
/
environment
"
true
)
;
class
ConsoleMessageWatcher
{
constructor
(
targetActor
{
onAvailable
}
)
{
targetActor
.
attach
(
)
;
const
onConsoleAPICall
=
message
=
>
{
onAvailable
(
[
{
resourceType
:
CONSOLE_MESSAGE
message
:
prepareConsoleMessageForRemote
(
targetActor
message
)
}
]
)
;
}
;
const
listener
=
new
ConsoleAPIListener
(
targetActor
.
window
onConsoleAPICall
targetActor
.
consoleAPIListenerOptions
)
;
this
.
listener
=
listener
;
listener
.
init
(
)
;
const
winStartTime
=
targetActor
.
window
&
&
targetActor
.
window
.
performance
?
targetActor
.
window
.
performance
.
timing
.
navigationStart
:
0
;
const
cachedMessages
=
listener
.
getCachedMessages
(
!
targetActor
.
isRootActor
)
;
const
messages
=
[
]
;
for
(
const
message
of
cachedMessages
)
{
if
(
message
.
innerID
=
=
=
"
ServiceWorker
"
&
&
winStartTime
>
message
.
timeStamp
)
{
continue
;
}
messages
.
push
(
{
resourceType
:
CONSOLE_MESSAGE
message
:
prepareConsoleMessageForRemote
(
targetActor
message
)
}
)
;
}
onAvailable
(
messages
)
;
}
destroy
(
)
{
if
(
this
.
listener
)
{
this
.
listener
.
destroy
(
)
;
}
}
onLogPoint
(
message
)
{
if
(
!
this
.
listener
)
{
throw
new
Error
(
"
This
target
actor
isn
'
t
listening
to
console
messages
"
)
;
}
this
.
listener
.
handler
(
message
)
;
}
}
module
.
exports
=
ConsoleMessageWatcher
;
function
getActorIdForInternalSourceId
(
targetActor
id
)
{
const
actor
=
targetActor
.
sources
.
getSourceActorByInternalSourceId
(
id
)
;
return
actor
?
actor
.
actorID
:
null
;
}
function
createValueGripForTarget
(
targetActor
value
depth
=
0
)
{
return
createValueGrip
(
value
targetActor
createObjectGrip
.
bind
(
null
targetActor
depth
)
)
;
}
function
createEnvironmentActor
(
environment
targetActor
)
{
if
(
!
environment
)
{
return
undefined
;
}
if
(
environment
.
actor
)
{
return
environment
.
actor
;
}
const
actor
=
new
EnvironmentActor
(
environment
targetActor
)
;
targetActor
.
manage
(
actor
)
;
environment
.
actor
=
actor
;
return
actor
;
}
function
createObjectGrip
(
targetActor
depth
object
pool
)
{
let
gripDepth
=
depth
;
const
actor
=
new
ObjectActor
(
object
{
thread
:
targetActor
.
threadActor
getGripDepth
:
(
)
=
>
gripDepth
incrementGripDepth
:
(
)
=
>
gripDepth
+
+
decrementGripDepth
:
(
)
=
>
gripDepth
-
-
createValueGrip
:
v
=
>
createValueGripForTarget
(
targetActor
v
gripDepth
)
createEnvironmentActor
:
env
=
>
createEnvironmentActor
(
env
targetActor
)
sources
:
(
)
=
>
DevToolsUtils
.
reportException
(
"
WebConsoleActor
"
Error
(
"
sources
not
yet
implemented
"
)
)
}
targetActor
.
conn
)
;
pool
.
manage
(
actor
)
;
return
actor
.
form
(
)
;
}
function
isObject
(
value
)
{
return
Object
(
value
)
=
=
=
value
;
}
function
makeDebuggeeValue
(
targetActor
value
)
{
if
(
isObject
(
value
)
)
{
try
{
const
global
=
Cu
.
getGlobalForObject
(
value
)
;
const
dbgGlobal
=
targetActor
.
dbg
.
makeGlobalObjectReference
(
global
)
;
return
dbgGlobal
.
makeDebuggeeValue
(
value
)
;
}
catch
(
ex
)
{
}
}
const
dbgGlobal
=
targetActor
.
dbg
.
makeGlobalObjectReference
(
targetActor
.
window
)
;
return
dbgGlobal
.
makeDebuggeeValue
(
value
)
;
}
function
getConsoleTableMessageItems
(
targetActor
result
)
{
if
(
!
result
|
|
!
Array
.
isArray
(
result
.
arguments
)
|
|
result
.
arguments
.
length
=
=
0
)
{
return
null
;
}
const
[
tableItemGrip
]
=
result
.
arguments
;
const
dataType
=
tableItemGrip
.
class
;
const
needEntries
=
[
"
Map
"
"
WeakMap
"
"
Set
"
"
WeakSet
"
]
.
includes
(
dataType
)
;
const
ignoreNonIndexedProperties
=
isArray
(
tableItemGrip
)
;
const
tableItemActor
=
targetActor
.
getActorByID
(
tableItemGrip
.
actor
)
;
if
(
!
tableItemActor
)
{
return
null
;
}
const
iterator
=
needEntries
?
tableItemActor
.
enumEntries
(
)
:
tableItemActor
.
enumProperties
(
{
ignoreNonIndexedProperties
}
)
;
const
{
ownProperties
}
=
iterator
.
all
(
)
;
const
descriptorKeys
=
[
"
safeGetterValues
"
"
getterValue
"
"
value
"
]
;
Object
.
values
(
ownProperties
)
.
forEach
(
desc
=
>
{
if
(
typeof
desc
!
=
=
"
undefined
"
)
{
descriptorKeys
.
forEach
(
key
=
>
{
if
(
desc
&
&
desc
.
hasOwnProperty
(
key
)
)
{
const
grip
=
desc
[
key
]
;
const
actor
=
grip
&
&
targetActor
.
getActorByID
(
grip
.
actor
)
;
if
(
actor
)
{
const
res
=
actor
.
enumProperties
(
{
ignoreNonIndexedProperties
:
isArray
(
grip
)
}
)
.
all
(
)
;
if
(
res
?
.
ownProperties
)
{
desc
[
key
]
.
ownProperties
=
res
.
ownProperties
;
}
}
}
}
)
;
}
}
)
;
return
ownProperties
;
}
function
prepareConsoleMessageForRemote
(
targetActor
message
)
{
const
result
=
WebConsoleUtils
.
cloneObject
(
message
)
;
result
.
workerType
=
WebConsoleUtils
.
getWorkerType
(
result
)
|
|
"
none
"
;
result
.
sourceId
=
getActorIdForInternalSourceId
(
targetActor
result
.
sourceId
)
;
delete
result
.
wrappedJSObject
;
delete
result
.
ID
;
delete
result
.
innerID
;
delete
result
.
consoleID
;
if
(
result
.
stacktrace
)
{
result
.
stacktrace
=
result
.
stacktrace
.
map
(
frame
=
>
{
return
{
.
.
.
frame
sourceId
:
getActorIdForInternalSourceId
(
targetActor
frame
.
sourceId
)
}
;
}
)
;
}
result
.
arguments
=
(
message
.
arguments
|
|
[
]
)
.
map
(
obj
=
>
{
const
dbgObj
=
makeDebuggeeValue
(
targetActor
obj
)
;
return
createValueGripForTarget
(
targetActor
dbgObj
)
;
}
)
;
result
.
styles
=
(
message
.
styles
|
|
[
]
)
.
map
(
string
=
>
{
return
createValueGripForTarget
(
targetActor
string
)
;
}
)
;
if
(
result
.
level
=
=
=
"
table
"
)
{
const
tableItems
=
getConsoleTableMessageItems
(
targetActor
result
)
;
if
(
tableItems
)
{
result
.
arguments
[
0
]
.
ownProperties
=
tableItems
;
result
.
arguments
[
0
]
.
preview
=
null
;
}
result
.
arguments
=
result
.
arguments
.
slice
(
0
2
)
;
}
result
.
category
=
message
.
category
|
|
"
webdev
"
;
result
.
innerWindowID
=
message
.
innerID
;
return
result
;
}
