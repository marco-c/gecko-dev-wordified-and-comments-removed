"
use
strict
"
;
const
Targets
=
require
(
"
devtools
/
server
/
actors
/
targets
/
index
"
)
;
const
consoleAPIListenerModule
=
isWorker
?
"
devtools
/
server
/
actors
/
webconsole
/
worker
-
listeners
"
:
"
devtools
/
server
/
actors
/
webconsole
/
listeners
/
console
-
api
"
;
const
{
ConsoleAPIListener
}
=
require
(
consoleAPIListenerModule
)
;
const
{
isArray
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
{
makeDebuggeeValue
createValueGripForTarget
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
{
getActorIdForInternalSourceId
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
dbg
-
source
"
)
;
const
{
isSupportedByConsoleTable
}
=
require
(
"
devtools
/
shared
/
webconsole
/
messages
"
)
;
class
ConsoleMessageWatcher
{
async
watch
(
targetActor
{
onAvailable
}
)
{
this
.
targetActor
=
targetActor
;
this
.
onAvailable
=
onAvailable
;
const
onConsoleAPICall
=
message
=
>
{
onAvailable
(
[
prepareConsoleMessageForRemote
(
targetActor
message
)
]
)
;
}
;
const
isTargetActorContentProcess
=
targetActor
.
targetType
=
=
=
Targets
.
TYPES
.
PROCESS
;
const
messagesShouldMatchWindow
=
targetActor
.
targetType
=
=
=
Targets
.
TYPES
.
FRAME
&
&
targetActor
.
typeName
!
=
"
parentProcessTarget
"
&
&
targetActor
.
typeName
!
=
"
webExtensionTarget
"
;
const
window
=
messagesShouldMatchWindow
?
targetActor
.
window
:
null
;
if
(
messagesShouldMatchWindow
&
&
!
window
)
{
return
;
}
const
listener
=
new
ConsoleAPIListener
(
window
onConsoleAPICall
{
excludeMessagesBoundToWindow
:
isTargetActorContentProcess
matchExactWindow
:
targetActor
.
ignoreSubFrames
.
.
.
(
targetActor
.
consoleAPIListenerOptions
|
|
{
}
)
}
)
;
this
.
listener
=
listener
;
listener
.
init
(
)
;
const
winStartTime
=
targetActor
.
window
?
.
performance
?
.
timing
?
.
navigationStart
|
|
0
;
const
cachedMessages
=
listener
.
getCachedMessages
(
!
targetActor
.
isRootActor
)
;
const
messages
=
[
]
;
for
(
const
message
of
cachedMessages
)
{
if
(
message
.
innerID
=
=
=
"
ServiceWorker
"
&
&
winStartTime
>
message
.
timeStamp
)
{
continue
;
}
messages
.
push
(
prepareConsoleMessageForRemote
(
targetActor
message
)
)
;
}
onAvailable
(
messages
)
;
}
destroy
(
)
{
if
(
this
.
listener
)
{
this
.
listener
.
destroy
(
)
;
this
.
listener
=
null
;
}
this
.
targetActor
=
null
;
this
.
onAvailable
=
null
;
}
emitMessages
(
messages
)
{
if
(
!
this
.
listener
)
{
throw
new
Error
(
"
This
target
actor
isn
'
t
listening
to
console
messages
"
)
;
}
this
.
onAvailable
(
messages
.
map
(
message
=
>
{
if
(
!
message
.
timeStamp
)
{
throw
new
Error
(
"
timeStamp
property
is
mandatory
"
)
;
}
return
prepareConsoleMessageForRemote
(
this
.
targetActor
message
)
;
}
)
)
;
}
}
module
.
exports
=
ConsoleMessageWatcher
;
function
getConsoleTableMessageItems
(
targetActor
result
)
{
const
[
tableItemGrip
]
=
result
.
arguments
;
const
dataType
=
tableItemGrip
.
class
;
const
needEntries
=
[
"
Map
"
"
WeakMap
"
"
Set
"
"
WeakSet
"
]
.
includes
(
dataType
)
;
const
ignoreNonIndexedProperties
=
isArray
(
tableItemGrip
)
;
const
tableItemActor
=
targetActor
.
getActorByID
(
tableItemGrip
.
actor
)
;
if
(
!
tableItemActor
)
{
return
null
;
}
const
iterator
=
needEntries
?
tableItemActor
.
enumEntries
(
)
:
tableItemActor
.
enumProperties
(
{
ignoreNonIndexedProperties
}
)
;
const
{
ownProperties
}
=
iterator
.
all
(
)
;
const
descriptorKeys
=
[
"
safeGetterValues
"
"
getterValue
"
"
value
"
]
;
Object
.
values
(
ownProperties
)
.
forEach
(
desc
=
>
{
if
(
typeof
desc
!
=
=
"
undefined
"
)
{
descriptorKeys
.
forEach
(
key
=
>
{
if
(
desc
&
&
desc
.
hasOwnProperty
(
key
)
)
{
const
grip
=
desc
[
key
]
;
const
actor
=
grip
&
&
targetActor
.
getActorByID
(
grip
.
actor
)
;
if
(
actor
)
{
const
res
=
actor
.
enumProperties
(
{
ignoreNonIndexedProperties
:
isArray
(
grip
)
}
)
.
all
(
)
;
if
(
res
?
.
ownProperties
)
{
desc
[
key
]
.
ownProperties
=
res
.
ownProperties
;
}
}
}
}
)
;
}
}
)
;
return
ownProperties
;
}
function
prepareConsoleMessageForRemote
(
targetActor
message
)
{
const
result
=
{
arguments
:
message
.
arguments
?
message
.
arguments
.
map
(
obj
=
>
{
const
dbgObj
=
makeDebuggeeValue
(
targetActor
obj
)
;
return
createValueGripForTarget
(
targetActor
dbgObj
)
;
}
)
:
[
]
columnNumber
:
message
.
columnNumber
filename
:
message
.
filename
level
:
message
.
level
lineNumber
:
message
.
lineNumber
timeStamp
:
message
.
microSecondTimeStamp
?
message
.
microSecondTimeStamp
/
1000
:
message
.
timeStamp
|
|
ChromeUtils
.
dateNow
(
)
sourceId
:
getActorIdForInternalSourceId
(
targetActor
message
.
sourceId
)
innerWindowID
:
message
.
innerID
}
;
if
(
message
.
chromeContext
)
{
result
.
chromeContext
=
message
.
chromeContext
;
}
if
(
message
.
counter
)
{
result
.
counter
=
message
.
counter
;
}
if
(
message
.
private
)
{
result
.
private
=
message
.
private
;
}
if
(
message
.
prefix
)
{
result
.
prefix
=
message
.
prefix
;
}
if
(
message
.
stacktrace
)
{
result
.
stacktrace
=
message
.
stacktrace
.
map
(
frame
=
>
{
return
{
.
.
.
frame
sourceId
:
getActorIdForInternalSourceId
(
targetActor
frame
.
sourceId
)
}
;
}
)
;
}
if
(
message
.
styles
&
&
message
.
styles
.
length
)
{
result
.
styles
=
message
.
styles
.
map
(
string
=
>
{
return
createValueGripForTarget
(
targetActor
string
)
;
}
)
;
}
if
(
message
.
timer
)
{
result
.
timer
=
message
.
timer
;
}
if
(
message
.
level
=
=
=
"
table
"
)
{
if
(
result
&
&
isSupportedByConsoleTable
(
result
.
arguments
)
)
{
const
tableItems
=
getConsoleTableMessageItems
(
targetActor
result
)
;
if
(
tableItems
)
{
result
.
arguments
[
0
]
.
ownProperties
=
tableItems
;
result
.
arguments
[
0
]
.
preview
=
null
;
result
.
arguments
=
result
.
arguments
.
slice
(
0
2
)
;
}
}
}
return
result
;
}
