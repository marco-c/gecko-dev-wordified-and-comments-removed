"
use
strict
"
;
const
Targets
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
index
.
js
"
)
;
const
{
PAUSE_REASONS
STATES
:
THREAD_STATES
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
thread
.
js
"
)
;
const
STATES
=
{
PAUSED
:
"
paused
"
RESUMED
:
"
resumed
"
}
;
class
BreakpointWatcher
{
constructor
(
)
{
this
.
onPaused
=
this
.
onPaused
.
bind
(
this
)
;
this
.
onResumed
=
this
.
onResumed
.
bind
(
this
)
;
}
async
watch
(
targetActor
{
onAvailable
}
)
{
if
(
targetActor
.
sessionContext
.
type
=
=
"
all
"
&
&
targetActor
.
targetType
=
=
=
Targets
.
TYPES
.
FRAME
&
&
targetActor
.
typeName
!
=
"
parentProcessTarget
"
)
{
return
;
}
const
{
threadActor
}
=
targetActor
;
this
.
threadActor
=
threadActor
;
this
.
onAvailable
=
onAvailable
;
const
isTargetCreation
=
this
.
threadActor
.
state
=
=
THREAD_STATES
.
DETACHED
;
if
(
isTargetCreation
&
&
!
targetActor
.
targetType
.
endsWith
(
"
worker
"
)
)
{
await
this
.
threadActor
.
attach
(
{
}
)
;
}
this
.
isInterrupted
=
false
;
threadActor
.
on
(
"
paused
"
this
.
onPaused
)
;
threadActor
.
on
(
"
resumed
"
this
.
onResumed
)
;
if
(
threadActor
.
isPaused
(
)
&
&
threadActor
.
lastPausedPacket
(
)
)
{
this
.
onPaused
(
threadActor
.
lastPausedPacket
(
)
)
;
}
}
destroy
(
)
{
if
(
!
this
.
threadActor
)
{
return
;
}
this
.
threadActor
.
off
(
"
paused
"
this
.
onPaused
)
;
this
.
threadActor
.
off
(
"
resumed
"
this
.
onResumed
)
;
}
onPaused
(
packet
)
{
const
{
why
}
=
packet
;
if
(
why
.
type
=
=
=
PAUSE_REASONS
.
INTERRUPTED
&
&
!
why
.
onNext
)
{
this
.
isInterrupted
=
true
;
return
;
}
if
(
why
.
type
=
=
PAUSE_REASONS
.
ALREADY_PAUSED
)
{
return
;
}
this
.
onAvailable
(
[
{
state
:
STATES
.
PAUSED
why
frame
:
packet
.
frame
.
form
(
)
}
]
)
;
}
onResumed
(
)
{
if
(
this
.
isInterrupted
)
{
this
.
isInterrupted
=
false
;
return
;
}
this
.
onAvailable
(
[
{
state
:
STATES
.
RESUMED
}
]
)
;
}
}
module
.
exports
=
BreakpointWatcher
;
