"
use
strict
"
;
class
CSSRegisteredPropertiesWatcher
{
#
abortController
;
#
onAvailable
;
#
onUpdated
;
#
onDestroyed
;
#
registeredPropertiesCache
=
new
Map
(
)
;
#
styleSheetsManager
;
#
targetActor
;
async
watch
(
targetActor
{
onAvailable
onUpdated
onDestroyed
}
)
{
this
.
#
targetActor
=
targetActor
;
this
.
#
onAvailable
=
onAvailable
;
this
.
#
onUpdated
=
onUpdated
;
this
.
#
onDestroyed
=
onDestroyed
;
const
registeredProperties
=
this
.
#
getRegisteredProperties
(
)
;
for
(
const
registeredProperty
of
registeredProperties
)
{
this
.
#
registeredPropertiesCache
.
set
(
registeredProperty
.
name
registeredProperty
)
;
}
this
.
#
notifyResourcesAvailable
(
registeredProperties
)
;
this
.
#
abortController
=
new
AbortController
(
)
;
const
{
signal
}
=
this
.
#
abortController
;
this
.
#
targetActor
.
chromeEventHandler
.
addEventListener
(
"
csscustompropertyregistered
"
this
.
#
onCssCustomPropertyRegistered
{
capture
:
true
signal
}
)
;
this
.
#
styleSheetsManager
=
targetActor
.
getStyleSheetsManager
(
)
;
await
this
.
#
styleSheetsManager
.
watch
(
{
onAvailable
:
this
.
#
refreshCacheAndNotify
onUpdated
:
this
.
#
refreshCacheAndNotify
onDestroyed
:
this
.
#
refreshCacheAndNotify
ignoreExisting
:
true
}
)
;
}
#
getRegisteredProperties
(
)
{
return
InspectorUtils
.
getCSSRegisteredProperties
(
this
.
#
targetActor
.
window
.
document
)
;
}
#
getRegisteredPropertyResourceId
(
propertyDefinition
)
{
return
{
this
.
#
targetActor
.
actorID
}
:
css
-
registered
-
property
:
{
propertyDefinition
.
name
}
;
}
#
refreshCacheAndNotify
=
async
(
)
=
>
{
const
registeredProperties
=
this
.
#
getRegisteredProperties
(
)
;
const
existingPropertiesNames
=
new
Set
(
this
.
#
registeredPropertiesCache
.
keys
(
)
)
;
const
added
=
[
]
;
const
updated
=
[
]
;
const
removed
=
[
]
;
for
(
const
registeredProperty
of
registeredProperties
)
{
if
(
!
this
.
#
registeredPropertiesCache
.
has
(
registeredProperty
.
name
)
)
{
added
.
push
(
registeredProperty
)
;
this
.
#
registeredPropertiesCache
.
set
(
registeredProperty
.
name
registeredProperty
)
;
continue
;
}
existingPropertiesNames
.
delete
(
registeredProperty
.
name
)
;
const
cachedRegisteredProperty
=
this
.
#
registeredPropertiesCache
.
get
(
registeredProperty
.
name
)
;
const
resourceUpdates
=
{
}
;
let
wasUpdated
=
false
;
if
(
registeredProperty
.
syntax
!
=
=
cachedRegisteredProperty
.
syntax
)
{
resourceUpdates
.
syntax
=
registeredProperty
.
syntax
;
wasUpdated
=
true
;
}
if
(
registeredProperty
.
inherits
!
=
=
cachedRegisteredProperty
.
inherits
)
{
resourceUpdates
.
inherits
=
registeredProperty
.
inherits
;
wasUpdated
=
true
;
}
if
(
registeredProperty
.
initialValue
!
=
=
cachedRegisteredProperty
.
initialValue
)
{
resourceUpdates
.
initialValue
=
registeredProperty
.
initialValue
;
wasUpdated
=
true
;
}
if
(
wasUpdated
=
=
=
true
)
{
updated
.
push
(
{
registeredProperty
resourceUpdates
}
)
;
this
.
#
registeredPropertiesCache
.
set
(
registeredProperty
.
name
registeredProperty
)
;
}
}
for
(
const
registeredPropertyName
of
existingPropertiesNames
)
{
removed
.
push
(
this
.
#
registeredPropertiesCache
.
get
(
registeredPropertyName
)
)
;
this
.
#
registeredPropertiesCache
.
delete
(
registeredPropertyName
)
;
}
this
.
#
notifyResourcesAvailable
(
added
)
;
this
.
#
notifyResourcesUpdated
(
updated
)
;
this
.
#
notifyResourcesDestroyed
(
removed
)
;
}
;
#
onCssCustomPropertyRegistered
=
event
=
>
{
if
(
this
.
#
targetActor
.
ignoreSubFrames
&
&
event
.
target
.
ownerGlobal
!
=
=
this
.
#
targetActor
.
window
)
{
return
;
}
const
registeredProperty
=
event
.
propertyDefinition
;
this
.
#
registeredPropertiesCache
.
set
(
registeredProperty
.
name
registeredProperty
)
;
this
.
#
notifyResourcesAvailable
(
[
registeredProperty
]
)
;
}
;
#
notifyResourcesAvailable
=
registeredProperties
=
>
{
if
(
!
registeredProperties
.
length
)
{
return
;
}
for
(
const
registeredProperty
of
registeredProperties
)
{
registeredProperty
.
resourceId
=
this
.
#
getRegisteredPropertyResourceId
(
registeredProperty
)
;
}
this
.
#
onAvailable
(
registeredProperties
)
;
}
;
#
notifyResourcesUpdated
=
updates
=
>
{
if
(
!
updates
.
length
)
{
return
;
}
for
(
const
update
of
updates
)
{
update
.
resourceId
=
this
.
#
getRegisteredPropertyResourceId
(
update
.
registeredProperty
)
;
delete
update
.
registeredProperty
;
}
this
.
#
onUpdated
(
updates
)
;
}
;
#
notifyResourcesDestroyed
=
registeredProperties
=
>
{
if
(
!
registeredProperties
.
length
)
{
return
;
}
this
.
#
onDestroyed
(
registeredProperties
.
map
(
registeredProperty
=
>
this
.
#
getRegisteredPropertyResourceId
(
registeredProperty
)
)
)
;
}
;
destroy
(
)
{
this
.
#
styleSheetsManager
.
unwatch
(
{
onAvailable
:
this
.
#
refreshCacheAndNotify
onUpdated
:
this
.
#
refreshCacheAndNotify
onDestroyed
:
this
.
#
refreshCacheAndNotify
}
)
;
this
.
#
abortController
.
abort
(
)
;
}
}
module
.
exports
=
CSSRegisteredPropertiesWatcher
;
