"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
"
NetworkEventActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
network
-
monitor
/
network
-
event
-
actor
.
js
"
true
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
NetworkUtils
:
"
resource
:
/
/
devtools
/
shared
/
network
-
observer
/
NetworkUtils
.
sys
.
mjs
"
}
)
;
class
NetworkEventContentWatcher
{
async
watch
(
targetActor
{
onAvailable
onUpdated
}
)
{
this
.
_imageCacheURIs
=
new
Map
(
)
;
this
.
targetActor
=
targetActor
;
this
.
onAvailable
=
onAvailable
;
this
.
onUpdated
=
onUpdated
;
this
.
httpFailedOpeningRequest
=
this
.
httpFailedOpeningRequest
.
bind
(
this
)
;
this
.
httpOnImageCacheResponse
=
this
.
httpOnImageCacheResponse
.
bind
(
this
)
;
Services
.
obs
.
addObserver
(
this
.
httpFailedOpeningRequest
"
http
-
on
-
failed
-
opening
-
request
"
)
;
Services
.
obs
.
addObserver
(
this
.
httpOnImageCacheResponse
"
http
-
on
-
image
-
cache
-
response
"
)
;
}
clear
(
)
{
this
.
_imageCacheURIs
.
clear
(
)
;
}
httpFailedOpeningRequest
(
subject
topic
)
{
const
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
lazy
.
NetworkUtils
.
isPreloadRequest
(
channel
)
)
{
return
;
}
if
(
!
lazy
.
NetworkUtils
.
matchRequest
(
channel
{
targetActor
:
this
.
targetActor
}
)
)
{
return
;
}
this
.
onNetworkEventAvailable
(
channel
{
networkEventOptions
:
{
blockedReason
:
channel
.
loadInfo
.
requestBlockingReason
}
resourceOverrides
:
null
}
)
;
}
httpOnImageCacheResponse
(
subject
topic
)
{
if
(
topic
!
=
"
http
-
on
-
image
-
cache
-
response
"
|
|
!
(
subject
instanceof
Ci
.
nsIHttpChannel
)
)
{
return
;
}
const
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
!
lazy
.
NetworkUtils
.
matchRequest
(
channel
{
targetActor
:
this
.
targetActor
}
)
)
{
return
;
}
const
hasURI
=
Array
.
from
(
this
.
_imageCacheURIs
.
values
(
)
)
.
some
(
uri
=
>
uri
=
=
=
channel
.
URI
.
spec
)
;
if
(
hasURI
)
{
return
;
}
this
.
_imageCacheURIs
.
set
(
channel
.
channelId
channel
.
URI
.
spec
)
;
this
.
onNetworkEventAvailable
(
channel
{
networkEventOptions
:
{
fromCache
:
true
}
resourceOverrides
:
{
status
:
200
statusText
:
"
OK
"
totalTime
:
0
mimeType
:
channel
.
contentType
contentSize
:
channel
.
contentLength
}
}
)
;
}
onNetworkEventAvailable
(
channel
{
networkEventOptions
resourceOverrides
}
)
{
const
event
=
lazy
.
NetworkUtils
.
createNetworkEvent
(
channel
networkEventOptions
)
;
const
actor
=
new
NetworkEventActor
(
this
.
targetActor
.
conn
this
.
targetActor
.
sessionContext
{
onNetworkEventDestroy
:
this
.
onNetworkEventDestroyed
.
bind
(
this
)
}
event
)
;
this
.
targetActor
.
manage
(
actor
)
;
const
resource
=
actor
.
asResource
(
)
;
if
(
resourceOverrides
)
{
for
(
const
prop
in
resourceOverrides
)
{
resource
[
prop
]
=
resourceOverrides
[
prop
]
;
}
}
this
.
onAvailable
(
[
resource
]
)
;
this
.
onUpdated
(
[
{
browsingContextID
:
resource
.
browsingContextID
innerWindowId
:
resource
.
innerWindowId
resourceType
:
resource
.
resourceType
resourceId
:
resource
.
resourceId
resourceUpdates
:
{
requestCookiesAvailable
:
true
requestHeadersAvailable
:
true
}
}
]
)
;
}
onNetworkEventDestroyed
(
channelId
)
{
if
(
this
.
_imageCacheURIs
.
has
(
channelId
)
)
{
this
.
_imageCacheURIs
.
delete
(
channelId
)
;
}
}
destroy
(
)
{
this
.
clear
(
)
;
Services
.
obs
.
removeObserver
(
this
.
httpFailedOpeningRequest
"
http
-
on
-
failed
-
opening
-
request
"
)
;
Services
.
obs
.
removeObserver
(
this
.
httpOnImageCacheResponse
"
http
-
on
-
image
-
cache
-
response
"
)
;
}
}
module
.
exports
=
NetworkEventContentWatcher
;
