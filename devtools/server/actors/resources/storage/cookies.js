"
use
strict
"
;
const
{
BaseStorageActor
DEFAULT_VALUE
SEPARATOR_GUID
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
storage
/
index
.
js
"
)
;
const
{
LongStringActor
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
string
.
js
"
)
;
const
COOKIE_SAMESITE
=
{
LAX
:
"
Lax
"
STRICT
:
"
Strict
"
NONE
:
"
None
"
}
;
const
MAX_COOKIE_EXPIRY
=
Math
.
pow
(
2
62
)
;
function
trimHttpHttpsPort
(
url
)
{
const
match
=
url
.
match
(
/
(
.
+
)
:
\
d
+
/
)
;
if
(
match
)
{
url
=
match
[
1
]
;
}
if
(
url
.
startsWith
(
"
http
:
/
/
"
)
)
{
return
url
.
substr
(
7
)
;
}
if
(
url
.
startsWith
(
"
https
:
/
/
"
)
)
{
return
url
.
substr
(
8
)
;
}
return
url
;
}
class
CookiesStorageActor
extends
BaseStorageActor
{
constructor
(
storageActor
)
{
super
(
storageActor
"
cookies
"
)
;
Services
.
obs
.
addObserver
(
this
"
cookie
-
changed
"
)
;
Services
.
obs
.
addObserver
(
this
"
private
-
cookie
-
changed
"
)
;
}
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
"
cookie
-
changed
"
)
;
Services
.
obs
.
removeObserver
(
this
"
private
-
cookie
-
changed
"
)
;
super
.
destroy
(
)
;
}
populateStoresForHost
(
host
)
{
this
.
hostVsStores
.
set
(
host
new
Map
(
)
)
;
const
originAttributes
=
this
.
getOriginAttributesFromHost
(
host
)
;
const
cookies
=
this
.
getCookiesFromHost
(
host
originAttributes
)
;
for
(
const
cookie
of
cookies
)
{
if
(
this
.
isCookieAtHost
(
cookie
host
)
)
{
const
uniqueKey
=
{
cookie
.
name
}
{
SEPARATOR_GUID
}
{
cookie
.
host
}
+
{
SEPARATOR_GUID
}
{
cookie
.
path
}
;
this
.
hostVsStores
.
get
(
host
)
.
set
(
uniqueKey
cookie
)
;
}
}
}
getOriginAttributesFromHost
(
host
)
{
const
win
=
this
.
storageActor
.
getWindowFromHost
(
host
)
;
let
originAttributes
;
if
(
win
)
{
originAttributes
=
win
.
document
.
effectiveStoragePrincipal
.
originAttributes
;
}
else
{
originAttributes
=
this
.
storageActor
.
document
?
.
effectiveStoragePrincipal
.
originAttributes
;
}
return
originAttributes
;
}
getCookiesFromHost
(
host
originAttributes
)
{
if
(
host
.
startsWith
(
"
file
:
/
/
/
"
)
)
{
host
=
"
"
;
}
host
=
trimHttpHttpsPort
(
host
)
;
return
Services
.
cookies
.
getCookiesFromHost
(
host
originAttributes
)
;
}
getMatchingHosts
(
cookies
)
{
if
(
!
cookies
.
length
)
{
cookies
=
[
cookies
]
;
}
const
hosts
=
new
Set
(
)
;
for
(
const
host
of
this
.
hosts
)
{
for
(
const
cookie
of
cookies
)
{
if
(
this
.
isCookieAtHost
(
cookie
host
)
)
{
hosts
.
add
(
host
)
;
}
}
}
return
[
.
.
.
hosts
]
;
}
isCookieAtHost
(
cookie
host
)
{
if
(
cookie
.
host
=
=
null
)
{
return
host
=
=
null
;
}
host
=
trimHttpHttpsPort
(
host
)
;
if
(
cookie
.
host
.
startsWith
(
"
.
"
)
)
{
return
(
"
.
"
+
host
)
.
endsWith
(
cookie
.
host
)
;
}
if
(
cookie
.
host
=
=
=
"
"
)
{
return
host
.
startsWith
(
"
file
:
/
/
"
+
cookie
.
path
)
;
}
return
cookie
.
host
=
=
host
;
}
toStoreObject
(
cookie
)
{
if
(
!
cookie
)
{
return
null
;
}
return
{
uniqueKey
:
{
cookie
.
name
}
{
SEPARATOR_GUID
}
{
cookie
.
host
}
+
{
SEPARATOR_GUID
}
{
cookie
.
path
}
name
:
cookie
.
name
host
:
cookie
.
host
|
|
"
"
path
:
cookie
.
path
|
|
"
"
expires
:
(
cookie
.
expires
|
|
0
)
*
1000
creationTime
:
cookie
.
creationTime
/
1000
size
:
cookie
.
name
.
length
+
(
cookie
.
value
|
|
"
"
)
.
length
lastAccessed
:
cookie
.
lastAccessed
/
1000
value
:
new
LongStringActor
(
this
.
conn
cookie
.
value
|
|
"
"
)
hostOnly
:
!
cookie
.
isDomain
isSecure
:
cookie
.
isSecure
isHttpOnly
:
cookie
.
isHttpOnly
sameSite
:
this
.
getSameSiteStringFromCookie
(
cookie
)
}
;
}
getSameSiteStringFromCookie
(
cookie
)
{
switch
(
cookie
.
sameSite
)
{
case
cookie
.
SAMESITE_LAX
:
return
COOKIE_SAMESITE
.
LAX
;
case
cookie
.
SAMESITE_STRICT
:
return
COOKIE_SAMESITE
.
STRICT
;
}
return
COOKIE_SAMESITE
.
NONE
;
}
onCookieChanged
(
subject
topic
action
)
{
if
(
(
topic
!
=
=
"
cookie
-
changed
"
&
&
topic
!
=
=
"
private
-
cookie
-
changed
"
)
|
|
!
this
.
storageActor
|
|
!
this
.
storageActor
.
windows
)
{
return
null
;
}
const
hosts
=
this
.
getMatchingHosts
(
subject
)
;
const
data
=
{
}
;
switch
(
action
)
{
case
"
added
"
:
case
"
changed
"
:
if
(
hosts
.
length
)
{
for
(
const
host
of
hosts
)
{
const
uniqueKey
=
{
subject
.
name
}
{
SEPARATOR_GUID
}
{
subject
.
host
}
+
{
SEPARATOR_GUID
}
{
subject
.
path
}
;
this
.
hostVsStores
.
get
(
host
)
.
set
(
uniqueKey
subject
)
;
data
[
host
]
=
[
uniqueKey
]
;
}
this
.
storageActor
.
update
(
action
"
cookies
"
data
)
;
}
break
;
case
"
deleted
"
:
if
(
hosts
.
length
)
{
for
(
const
host
of
hosts
)
{
const
uniqueKey
=
{
subject
.
name
}
{
SEPARATOR_GUID
}
{
subject
.
host
}
+
{
SEPARATOR_GUID
}
{
subject
.
path
}
;
this
.
hostVsStores
.
get
(
host
)
.
delete
(
uniqueKey
)
;
data
[
host
]
=
[
uniqueKey
]
;
}
this
.
storageActor
.
update
(
"
deleted
"
"
cookies
"
data
)
;
}
break
;
case
"
batch
-
deleted
"
:
if
(
hosts
.
length
)
{
for
(
const
host
of
hosts
)
{
const
stores
=
[
]
;
for
(
const
cookie
of
subject
)
{
const
uniqueKey
=
{
cookie
.
name
}
{
SEPARATOR_GUID
}
{
cookie
.
host
}
+
{
SEPARATOR_GUID
}
{
cookie
.
path
}
;
this
.
hostVsStores
.
get
(
host
)
.
delete
(
uniqueKey
)
;
stores
.
push
(
uniqueKey
)
;
}
data
[
host
]
=
stores
;
}
this
.
storageActor
.
update
(
"
deleted
"
"
cookies
"
data
)
;
}
break
;
case
"
cleared
"
:
if
(
hosts
.
length
)
{
for
(
const
host
of
hosts
)
{
data
[
host
]
=
[
]
;
}
this
.
storageActor
.
update
(
"
cleared
"
"
cookies
"
data
)
;
}
break
;
}
return
null
;
}
async
getFields
(
)
{
return
[
{
name
:
"
uniqueKey
"
editable
:
false
private
:
true
}
{
name
:
"
name
"
editable
:
true
hidden
:
false
}
{
name
:
"
value
"
editable
:
true
hidden
:
false
}
{
name
:
"
host
"
editable
:
true
hidden
:
false
}
{
name
:
"
path
"
editable
:
true
hidden
:
false
}
{
name
:
"
expires
"
editable
:
true
hidden
:
false
}
{
name
:
"
size
"
editable
:
false
hidden
:
false
}
{
name
:
"
isHttpOnly
"
editable
:
true
hidden
:
false
}
{
name
:
"
isSecure
"
editable
:
true
hidden
:
false
}
{
name
:
"
sameSite
"
editable
:
false
hidden
:
false
}
{
name
:
"
lastAccessed
"
editable
:
false
hidden
:
false
}
{
name
:
"
creationTime
"
editable
:
false
hidden
:
true
}
{
name
:
"
hostOnly
"
editable
:
false
hidden
:
true
}
]
;
}
async
editItem
(
data
)
{
data
.
originAttributes
=
this
.
getOriginAttributesFromHost
(
data
.
host
)
;
this
.
editCookie
(
data
)
;
}
async
addItem
(
guid
host
)
{
const
window
=
this
.
storageActor
.
getWindowFromHost
(
host
)
;
const
principal
=
window
.
document
.
effectiveStoragePrincipal
;
this
.
addCookie
(
guid
principal
)
;
}
async
removeItem
(
host
name
)
{
const
originAttributes
=
this
.
getOriginAttributesFromHost
(
host
)
;
this
.
removeCookie
(
host
name
originAttributes
)
;
}
async
removeAll
(
host
domain
)
{
const
originAttributes
=
this
.
getOriginAttributesFromHost
(
host
)
;
this
.
removeAllCookies
(
host
domain
originAttributes
)
;
}
async
removeAllSessionCookies
(
host
domain
)
{
const
originAttributes
=
this
.
getOriginAttributesFromHost
(
host
)
;
this
.
_removeCookies
(
host
{
domain
originAttributes
session
:
true
}
)
;
}
addCookie
(
guid
principal
)
{
const
ONE_DAY_IN_SECONDS
=
60
*
60
*
24
;
const
time
=
Math
.
floor
(
Date
.
now
(
)
/
1000
)
;
const
expiry
=
time
+
ONE_DAY_IN_SECONDS
;
const
domain
=
principal
.
asciiHost
?
principal
.
host
:
principal
.
baseDomain
;
Services
.
cookies
.
add
(
domain
"
/
"
guid
DEFAULT_VALUE
false
false
false
expiry
principal
.
originAttributes
Ci
.
nsICookie
.
SAMESITE_LAX
principal
.
scheme
=
=
=
"
https
"
?
Ci
.
nsICookie
.
SCHEME_HTTPS
:
Ci
.
nsICookie
.
SCHEME_HTTP
)
;
}
editCookie
(
data
)
{
let
{
field
oldValue
newValue
}
=
data
;
const
origName
=
field
=
=
=
"
name
"
?
oldValue
:
data
.
items
.
name
;
const
origHost
=
field
=
=
=
"
host
"
?
oldValue
:
data
.
items
.
host
;
const
origPath
=
field
=
=
=
"
path
"
?
oldValue
:
data
.
items
.
path
;
let
cookie
=
null
;
const
cookies
=
Services
.
cookies
.
getCookiesFromHost
(
origHost
data
.
originAttributes
|
|
{
}
)
;
for
(
const
nsiCookie
of
cookies
)
{
if
(
nsiCookie
.
name
=
=
=
origName
&
&
nsiCookie
.
host
=
=
=
origHost
&
&
nsiCookie
.
path
=
=
=
origPath
)
{
cookie
=
{
host
:
nsiCookie
.
host
path
:
nsiCookie
.
path
name
:
nsiCookie
.
name
value
:
nsiCookie
.
value
isSecure
:
nsiCookie
.
isSecure
isHttpOnly
:
nsiCookie
.
isHttpOnly
isSession
:
nsiCookie
.
isSession
expires
:
nsiCookie
.
expires
originAttributes
:
nsiCookie
.
originAttributes
schemeMap
:
nsiCookie
.
schemeMap
}
;
break
;
}
}
if
(
!
cookie
)
{
return
;
}
const
now
=
new
Date
(
)
;
if
(
!
cookie
.
isSession
&
&
cookie
.
expires
*
1000
<
=
now
)
{
const
tenSecondsFromNow
=
(
now
.
getTime
(
)
+
10
*
1000
)
/
1000
;
cookie
.
expires
=
tenSecondsFromNow
;
}
switch
(
field
)
{
case
"
isSecure
"
:
case
"
isHttpOnly
"
:
case
"
isSession
"
:
newValue
=
newValue
=
=
=
"
true
"
;
break
;
case
"
expires
"
:
newValue
=
Date
.
parse
(
newValue
)
/
1000
;
if
(
isNaN
(
newValue
)
)
{
newValue
=
MAX_COOKIE_EXPIRY
;
}
break
;
case
"
host
"
:
case
"
name
"
:
case
"
path
"
:
Services
.
cookies
.
remove
(
origHost
origName
origPath
cookie
.
originAttributes
)
;
break
;
}
cookie
[
field
]
=
newValue
;
cookie
.
isSession
=
!
cookie
.
expires
;
Services
.
cookies
.
add
(
cookie
.
host
cookie
.
path
cookie
.
name
cookie
.
value
cookie
.
isSecure
cookie
.
isHttpOnly
cookie
.
isSession
cookie
.
isSession
?
MAX_COOKIE_EXPIRY
:
cookie
.
expires
cookie
.
originAttributes
cookie
.
sameSite
cookie
.
schemeMap
)
;
}
_removeCookies
(
host
opts
=
{
}
)
{
if
(
opts
.
name
)
{
const
split
=
opts
.
name
.
split
(
SEPARATOR_GUID
)
;
opts
.
name
=
split
[
0
]
;
opts
.
path
=
split
[
2
]
;
}
host
=
trimHttpHttpsPort
(
host
)
;
function
hostMatches
(
cookieHost
matchHost
)
{
if
(
cookieHost
=
=
null
)
{
return
matchHost
=
=
null
;
}
if
(
cookieHost
.
startsWith
(
"
.
"
)
)
{
return
(
"
.
"
+
matchHost
)
.
endsWith
(
cookieHost
)
;
}
return
cookieHost
=
=
host
;
}
const
cookies
=
Services
.
cookies
.
getCookiesFromHost
(
host
opts
.
originAttributes
|
|
{
}
)
;
for
(
const
cookie
of
cookies
)
{
if
(
hostMatches
(
cookie
.
host
host
)
&
&
(
!
opts
.
name
|
|
cookie
.
name
=
=
=
opts
.
name
)
&
&
(
!
opts
.
domain
|
|
cookie
.
host
=
=
=
opts
.
domain
)
&
&
(
!
opts
.
path
|
|
cookie
.
path
=
=
=
opts
.
path
)
&
&
(
!
opts
.
session
|
|
(
!
cookie
.
expires
&
&
!
cookie
.
maxAge
)
)
)
{
Services
.
cookies
.
remove
(
cookie
.
host
cookie
.
name
cookie
.
path
cookie
.
originAttributes
)
;
}
}
}
removeCookie
(
host
name
originAttributes
)
{
if
(
name
!
=
=
undefined
)
{
this
.
_removeCookies
(
host
{
name
originAttributes
}
)
;
}
}
removeAllCookies
(
host
domain
originAttributes
)
{
this
.
_removeCookies
(
host
{
domain
originAttributes
}
)
;
}
observe
(
subject
topic
data
)
{
if
(
!
subject
|
|
(
topic
!
=
"
cookie
-
changed
"
&
&
topic
!
=
"
private
-
cookie
-
changed
"
)
)
{
return
;
}
if
(
data
=
=
=
"
batch
-
deleted
"
)
{
const
cookiesNoInterface
=
subject
.
QueryInterface
(
Ci
.
nsIArray
)
;
const
cookies
=
[
]
;
for
(
let
i
=
0
;
i
<
cookiesNoInterface
.
length
;
i
+
+
)
{
const
cookie
=
cookiesNoInterface
.
queryElementAt
(
i
Ci
.
nsICookie
)
;
cookies
.
push
(
cookie
)
;
}
this
.
onCookieChanged
(
cookies
topic
data
)
;
return
;
}
const
cookie
=
subject
.
QueryInterface
(
Ci
.
nsICookie
)
;
this
.
onCookieChanged
(
cookie
topic
data
)
;
}
}
exports
.
CookiesStorageActor
=
CookiesStorageActor
;
