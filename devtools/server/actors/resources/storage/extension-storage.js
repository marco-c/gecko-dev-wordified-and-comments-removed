"
use
strict
"
;
const
protocol
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
StorageActors
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
storage
/
index
.
js
"
)
;
const
{
parseItemValue
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
storage
/
utils
.
js
"
)
;
const
{
LongStringActor
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
string
.
js
"
)
;
loader
.
lazyGetter
(
this
"
ExtensionProcessScript
"
(
)
=
>
{
return
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionProcessScript
.
jsm
"
)
.
ExtensionProcessScript
;
}
)
;
loader
.
lazyGetter
(
this
"
ExtensionStorageIDB
"
(
)
=
>
{
return
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionStorageIDB
.
jsm
"
)
.
ExtensionStorageIDB
;
}
)
;
exports
.
ExtensionStorageActor
=
StorageActors
.
createActor
(
{
typeName
:
"
extensionStorage
"
}
{
initialize
(
storageActor
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
storageActor
=
storageActor
;
this
.
addonId
=
this
.
storageActor
.
parentActor
.
addonId
;
this
.
extensionHostURL
=
this
.
getExtensionPolicy
(
)
.
getURL
(
)
.
slice
(
0
-
1
)
;
this
.
dbConnectionForHost
=
new
Map
(
)
;
this
.
hostVsStores
=
new
Map
(
)
;
this
.
onStorageChange
=
this
.
onStorageChange
.
bind
(
this
)
;
this
.
onWindowReady
=
this
.
onWindowReady
.
bind
(
this
)
;
this
.
onWindowDestroyed
=
this
.
onWindowDestroyed
.
bind
(
this
)
;
this
.
storageActor
.
on
(
"
window
-
ready
"
this
.
onWindowReady
)
;
this
.
storageActor
.
on
(
"
window
-
destroyed
"
this
.
onWindowDestroyed
)
;
}
getExtensionPolicy
(
)
{
return
WebExtensionPolicy
.
getByID
(
this
.
addonId
)
;
}
destroy
(
)
{
ExtensionStorageIDB
.
removeOnChangedListener
(
this
.
addonId
this
.
onStorageChange
)
;
this
.
storageActor
.
off
(
"
window
-
ready
"
this
.
onWindowReady
)
;
this
.
storageActor
.
off
(
"
window
-
destroyed
"
this
.
onWindowDestroyed
)
;
this
.
hostVsStores
.
clear
(
)
;
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
storageActor
=
null
;
}
onStorageChange
(
changes
)
{
const
host
=
this
.
extensionHostURL
;
const
storeMap
=
this
.
hostVsStores
.
get
(
host
)
;
function
isStructuredCloneHolder
(
value
)
{
return
(
value
&
&
typeof
value
=
=
=
"
object
"
&
&
Cu
.
getClassName
(
value
true
)
=
=
=
"
StructuredCloneHolder
"
)
;
}
for
(
const
key
in
changes
)
{
const
storageChange
=
changes
[
key
]
;
let
{
newValue
oldValue
}
=
storageChange
;
if
(
isStructuredCloneHolder
(
newValue
)
)
{
newValue
=
newValue
.
deserialize
(
this
)
;
}
if
(
isStructuredCloneHolder
(
oldValue
)
)
{
oldValue
=
oldValue
.
deserialize
(
this
)
;
}
let
action
;
if
(
typeof
newValue
=
=
=
"
undefined
"
)
{
action
=
"
deleted
"
;
storeMap
.
delete
(
key
)
;
}
else
if
(
typeof
oldValue
=
=
=
"
undefined
"
)
{
action
=
"
added
"
;
storeMap
.
set
(
key
newValue
)
;
}
else
{
action
=
"
changed
"
;
storeMap
.
set
(
key
newValue
)
;
}
this
.
storageActor
.
update
(
action
this
.
typeName
{
[
host
]
:
[
key
]
}
)
;
}
}
async
preListStores
(
)
{
if
(
!
this
.
addonId
|
|
!
this
.
getExtensionPolicy
(
)
)
{
return
;
}
ExtensionStorageIDB
.
addOnChangedListener
(
this
.
addonId
this
.
onStorageChange
)
;
try
{
const
{
extension
}
=
WebExtensionPolicy
.
getByID
(
this
.
addonId
)
;
await
extension
.
apiManager
.
asyncGetAPI
(
"
storage
"
extension
)
;
}
catch
(
e
)
{
console
.
error
(
"
Exception
while
trying
to
initialize
webext
storage
API
"
e
)
;
}
await
this
.
populateStoresForHost
(
this
.
extensionHostURL
)
;
}
populateStoresForHosts
(
)
{
}
async
populateStoresForHost
(
host
)
{
if
(
host
!
=
=
this
.
extensionHostURL
)
{
return
;
}
const
extension
=
ExtensionProcessScript
.
getExtensionChild
(
this
.
addonId
)
;
if
(
!
extension
|
|
!
extension
.
hasPermission
(
"
storage
"
)
)
{
return
;
}
const
storeMap
=
new
Map
(
)
;
this
.
hostVsStores
.
set
(
host
storeMap
)
;
const
storagePrincipal
=
await
this
.
getStoragePrincipal
(
)
;
if
(
!
storagePrincipal
)
{
return
;
}
const
db
=
await
ExtensionStorageIDB
.
open
(
storagePrincipal
)
;
this
.
dbConnectionForHost
.
set
(
host
db
)
;
const
data
=
await
db
.
get
(
)
;
for
(
const
[
key
value
]
of
Object
.
entries
(
data
)
)
{
storeMap
.
set
(
key
value
)
;
}
if
(
this
.
storageActor
.
parentActor
.
fallbackWindow
)
{
const
storageData
=
{
}
;
storageData
[
host
]
=
this
.
getNamesForHost
(
host
)
;
this
.
storageActor
.
update
(
"
added
"
this
.
typeName
storageData
)
;
}
}
async
getStoragePrincipal
(
)
{
const
{
extension
}
=
this
.
getExtensionPolicy
(
)
;
const
{
backendEnabled
storagePrincipal
}
=
await
ExtensionStorageIDB
.
selectBackend
(
{
extension
}
)
;
if
(
!
backendEnabled
)
{
return
null
;
}
return
storagePrincipal
.
deserialize
(
this
true
)
;
}
getValuesForHost
(
host
name
)
{
const
result
=
[
]
;
if
(
!
this
.
hostVsStores
.
has
(
host
)
)
{
return
result
;
}
if
(
name
)
{
return
[
{
name
value
:
this
.
hostVsStores
.
get
(
host
)
.
get
(
name
)
}
]
;
}
for
(
const
[
key
value
]
of
Array
.
from
(
this
.
hostVsStores
.
get
(
host
)
.
entries
(
)
)
)
{
result
.
push
(
{
name
:
key
value
}
)
;
}
return
result
;
}
toStoreObject
(
item
)
{
if
(
!
item
)
{
return
null
;
}
let
{
name
value
}
=
item
;
const
isValueEditable
=
extensionStorageHelpers
.
isEditable
(
value
)
;
switch
(
typeof
value
)
{
case
"
bigint
"
:
value
=
{
value
.
toString
(
)
}
n
;
break
;
case
"
string
"
:
break
;
case
"
undefined
"
:
value
=
"
undefined
"
;
break
;
default
:
value
=
JSON
.
stringify
(
value
)
;
if
(
Object
.
prototype
.
toString
.
call
(
item
.
value
)
=
=
=
"
[
object
Date
]
"
)
{
value
=
JSON
.
parse
(
value
)
;
}
}
return
{
name
value
:
new
LongStringActor
(
this
.
conn
value
)
area
:
"
local
"
isValueEditable
}
;
}
getFields
(
)
{
return
[
{
name
:
"
name
"
editable
:
false
}
{
name
:
"
value
"
editable
:
true
}
{
name
:
"
area
"
editable
:
false
}
{
name
:
"
isValueEditable
"
editable
:
false
private
:
true
}
]
;
}
onItemUpdated
(
action
host
names
)
{
this
.
storageActor
.
update
(
action
this
.
typeName
{
[
host
]
:
names
}
)
;
}
async
editItem
(
{
host
field
items
oldValue
}
)
{
const
db
=
this
.
dbConnectionForHost
.
get
(
host
)
;
if
(
!
db
)
{
return
;
}
const
{
name
value
}
=
items
;
let
parsedValue
=
parseItemValue
(
value
)
;
if
(
parsedValue
=
=
=
value
)
{
const
{
typesFromString
}
=
extensionStorageHelpers
;
for
(
const
{
test
parse
}
of
Object
.
values
(
typesFromString
)
)
{
if
(
test
(
value
)
)
{
parsedValue
=
parse
(
value
)
;
break
;
}
}
}
const
changes
=
await
db
.
set
(
{
[
name
]
:
parsedValue
}
)
;
this
.
fireOnChangedExtensionEvent
(
host
changes
)
;
this
.
onItemUpdated
(
"
changed
"
host
[
name
]
)
;
}
async
removeItem
(
host
name
)
{
const
db
=
this
.
dbConnectionForHost
.
get
(
host
)
;
if
(
!
db
)
{
return
;
}
const
changes
=
await
db
.
remove
(
name
)
;
this
.
fireOnChangedExtensionEvent
(
host
changes
)
;
this
.
onItemUpdated
(
"
deleted
"
host
[
name
]
)
;
}
async
removeAll
(
host
)
{
const
db
=
this
.
dbConnectionForHost
.
get
(
host
)
;
if
(
!
db
)
{
return
;
}
const
changes
=
await
db
.
clear
(
)
;
this
.
fireOnChangedExtensionEvent
(
host
changes
)
;
this
.
onItemUpdated
(
"
cleared
"
host
[
]
)
;
}
fireOnChangedExtensionEvent
(
host
changes
)
{
const
uuid
=
new
URL
(
host
)
.
host
;
Services
.
cpmm
.
sendAsyncMessage
(
Extension
:
StorageLocalOnChanged
:
{
uuid
}
changes
)
;
}
}
)
;
const
extensionStorageHelpers
=
{
isEditable
(
value
)
{
for
(
const
{
test
}
of
Object
.
values
(
this
.
supportedTypes
)
)
{
if
(
test
(
value
)
)
{
return
true
;
}
}
return
false
;
}
isPrimitive
(
value
)
{
const
primitiveValueTypes
=
[
"
string
"
"
number
"
"
boolean
"
]
;
return
primitiveValueTypes
.
includes
(
typeof
value
)
|
|
value
=
=
=
null
;
}
isObjectLiteral
(
value
)
{
return
(
value
&
&
typeof
value
=
=
=
"
object
"
&
&
Cu
.
getClassName
(
value
true
)
=
=
=
"
Object
"
)
;
}
isArrayOrObjectLiteralEditable
(
obj
)
{
const
topLevelValuesArr
=
Array
.
isArray
(
obj
)
?
obj
:
Object
.
values
(
obj
)
;
if
(
topLevelValuesArr
.
some
(
value
=
>
!
this
.
isPrimitive
(
value
)
&
&
!
Array
.
isArray
(
value
)
&
&
!
this
.
isObjectLiteral
(
value
)
)
)
{
return
false
;
}
const
arrayOrObjects
=
topLevelValuesArr
.
filter
(
value
=
>
Array
.
isArray
(
value
)
|
|
this
.
isObjectLiteral
(
value
)
)
;
if
(
arrayOrObjects
.
length
=
=
=
0
)
{
return
true
;
}
for
(
const
nestedObj
of
arrayOrObjects
)
{
const
secondLevelValuesArr
=
Array
.
isArray
(
nestedObj
)
?
nestedObj
:
Object
.
values
(
nestedObj
)
;
if
(
secondLevelValuesArr
.
some
(
value
=
>
!
this
.
isPrimitive
(
value
)
)
)
{
return
false
;
}
}
return
true
;
}
typesFromString
:
{
jsonifiable
:
{
test
(
str
)
{
try
{
JSON
.
parse
(
str
)
;
}
catch
(
e
)
{
return
false
;
}
return
true
;
}
parse
(
str
)
{
return
JSON
.
parse
(
str
)
;
}
}
}
supportedTypes
:
{
array
:
{
test
(
value
)
{
if
(
Array
.
isArray
(
value
)
)
{
return
extensionStorageHelpers
.
isArrayOrObjectLiteralEditable
(
value
)
;
}
return
false
;
}
}
boolean
:
{
test
(
value
)
{
return
typeof
value
=
=
=
"
boolean
"
;
}
}
null
:
{
test
(
value
)
{
return
value
=
=
=
null
;
}
}
number
:
{
test
(
value
)
{
return
typeof
value
=
=
=
"
number
"
;
}
}
object
:
{
test
(
value
)
{
if
(
extensionStorageHelpers
.
isObjectLiteral
(
value
)
)
{
return
extensionStorageHelpers
.
isArrayOrObjectLiteralEditable
(
value
)
;
}
return
false
;
}
}
string
:
{
test
(
value
)
{
return
typeof
value
=
=
=
"
string
"
;
}
}
}
}
;
