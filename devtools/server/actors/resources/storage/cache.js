"
use
strict
"
;
const
{
BaseStorageActor
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
storage
/
index
.
js
"
)
;
class
CacheStorageActor
extends
BaseStorageActor
{
constructor
(
storageActor
)
{
super
(
storageActor
"
Cache
"
)
;
}
async
getCachesForHost
(
host
)
{
const
win
=
this
.
storageActor
.
getWindowFromHost
(
host
)
;
if
(
!
win
)
{
return
null
;
}
const
principal
=
win
.
document
.
effectiveStoragePrincipal
;
const
{
CacheStorage
}
=
win
;
if
(
!
CacheStorage
)
{
return
null
;
}
const
cache
=
new
CacheStorage
(
"
content
"
principal
)
;
return
cache
;
}
async
preListStores
(
)
{
for
(
const
host
of
this
.
hosts
)
{
await
this
.
populateStoresForHost
(
host
)
;
}
}
form
(
)
{
const
hosts
=
{
}
;
for
(
const
host
of
this
.
hosts
)
{
hosts
[
host
]
=
this
.
getNamesForHost
(
host
)
;
}
return
{
actor
:
this
.
actorID
hosts
traits
:
this
.
_getTraits
(
)
}
;
}
getNamesForHost
(
host
)
{
return
[
.
.
.
this
.
hostVsStores
.
get
(
host
)
.
keys
(
)
]
.
map
(
a
=
>
{
return
JSON
.
stringify
(
[
a
]
)
;
}
)
;
}
async
getValuesForHost
(
host
name
)
{
if
(
!
name
)
{
const
previousCaches
=
[
.
.
.
this
.
hostVsStores
.
get
(
host
)
.
keys
(
)
]
;
await
this
.
preListStores
(
)
;
const
updatedCaches
=
[
.
.
.
this
.
hostVsStores
.
get
(
host
)
.
keys
(
)
]
;
const
newCaches
=
updatedCaches
.
filter
(
cacheName
=
>
!
previousCaches
.
includes
(
cacheName
)
)
;
newCaches
.
forEach
(
cacheName
=
>
this
.
onItemUpdated
(
"
added
"
host
[
cacheName
]
)
)
;
const
removedCaches
=
previousCaches
.
filter
(
cacheName
=
>
!
updatedCaches
.
includes
(
cacheName
)
)
;
removedCaches
.
forEach
(
cacheName
=
>
this
.
onItemUpdated
(
"
deleted
"
host
[
cacheName
]
)
)
;
return
[
]
;
}
name
=
JSON
.
parse
(
name
)
[
0
]
;
const
cache
=
this
.
hostVsStores
.
get
(
host
)
.
get
(
name
)
;
const
requests
=
await
cache
.
keys
(
)
;
const
results
=
[
]
;
for
(
const
request
of
requests
)
{
let
response
=
await
cache
.
match
(
request
)
;
response
=
response
.
cloneUnfiltered
(
)
;
results
.
push
(
await
this
.
processEntry
(
request
response
)
)
;
}
return
results
;
}
async
processEntry
(
request
response
)
{
return
{
url
:
String
(
request
.
url
)
status
:
String
(
response
.
statusText
)
}
;
}
async
getFields
(
)
{
return
[
{
name
:
"
url
"
editable
:
false
}
{
name
:
"
status
"
editable
:
false
}
]
;
}
async
populateStoresForHost
(
host
)
{
const
storeMap
=
new
Map
(
)
;
const
caches
=
await
this
.
getCachesForHost
(
host
)
;
try
{
for
(
const
name
of
await
caches
.
keys
(
)
)
{
storeMap
.
set
(
name
await
caches
.
open
(
name
)
)
;
}
}
catch
(
ex
)
{
console
.
warn
(
Failed
to
enumerate
CacheStorage
for
host
{
host
}
:
{
ex
}
)
;
}
this
.
hostVsStores
.
set
(
host
storeMap
)
;
}
populateStoresForHosts
(
)
{
this
.
hostVsStores
=
new
Map
(
)
;
}
getSchemaAndHost
(
url
)
{
const
uri
=
Services
.
io
.
newURI
(
url
)
;
return
uri
.
scheme
+
"
:
/
/
"
+
uri
.
hostPort
;
}
toStoreObject
(
item
)
{
return
item
;
}
async
removeItem
(
host
name
)
{
const
cacheMap
=
this
.
hostVsStores
.
get
(
host
)
;
if
(
!
cacheMap
)
{
return
;
}
const
parsedName
=
JSON
.
parse
(
name
)
;
if
(
parsedName
.
length
=
=
1
)
{
const
[
cacheName
]
=
parsedName
;
cacheMap
.
delete
(
cacheName
)
;
const
cacheStorage
=
await
this
.
getCachesForHost
(
host
)
;
await
cacheStorage
.
delete
(
cacheName
)
;
this
.
onItemUpdated
(
"
deleted
"
host
[
cacheName
]
)
;
}
else
if
(
parsedName
.
length
=
=
2
)
{
const
[
cacheName
url
]
=
parsedName
;
const
cache
=
cacheMap
.
get
(
cacheName
)
;
if
(
cache
)
{
await
cache
.
delete
(
url
)
;
this
.
onItemUpdated
(
"
deleted
"
host
[
cacheName
url
]
)
;
}
}
}
async
removeAll
(
host
name
)
{
const
cacheMap
=
this
.
hostVsStores
.
get
(
host
)
;
if
(
!
cacheMap
)
{
return
;
}
const
parsedName
=
JSON
.
parse
(
name
)
;
if
(
parsedName
.
length
=
=
1
)
{
const
[
cacheName
]
=
parsedName
;
const
cache
=
cacheMap
.
get
(
cacheName
)
;
if
(
cache
)
{
const
keys
=
await
cache
.
keys
(
)
;
await
Promise
.
all
(
keys
.
map
(
key
=
>
cache
.
delete
(
key
)
)
)
;
this
.
onItemUpdated
(
"
cleared
"
host
[
cacheName
]
)
;
}
}
}
onItemUpdated
(
action
host
path
)
{
this
.
storageActor
.
update
(
action
"
Cache
"
{
[
host
]
:
[
JSON
.
stringify
(
path
)
]
}
)
;
}
}
exports
.
CacheStorageActor
=
CacheStorageActor
;
