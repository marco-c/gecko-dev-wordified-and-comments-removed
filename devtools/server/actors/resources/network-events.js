"
use
strict
"
;
const
{
Pool
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
/
Pool
.
js
"
)
;
const
{
isWindowGlobalPartOfContext
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
browsing
-
context
-
helpers
.
sys
.
mjs
"
{
global
:
"
contextual
"
}
)
;
const
{
ParentProcessWatcherRegistry
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
ParentProcessWatcherRegistry
.
sys
.
mjs
"
{
global
:
"
shared
"
}
)
;
const
Targets
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
index
.
js
"
)
;
const
lazy
=
{
}
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
{
global
:
"
contextual
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
responseBodyLimit
"
"
devtools
.
netmonitor
.
responseBodyLimit
"
0
)
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
NetworkObserver
:
"
resource
:
/
/
devtools
/
shared
/
network
-
observer
/
NetworkObserver
.
sys
.
mjs
"
NetworkUtils
:
"
resource
:
/
/
devtools
/
shared
/
network
-
observer
/
NetworkUtils
.
sys
.
mjs
"
}
{
global
:
"
contextual
"
}
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkEventActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
network
-
monitor
/
network
-
event
-
actor
.
js
"
true
)
;
class
NetworkEventWatcher
{
async
watch
(
watcherActor
{
onAvailable
onUpdated
}
)
{
this
.
networkEvents
=
new
Map
(
)
;
this
.
watcherActor
=
watcherActor
;
this
.
onNetworkEventAvailable
=
onAvailable
;
this
.
onNetworkEventUpdated
=
onUpdated
;
this
.
persist
=
false
;
this
.
listener
=
new
lazy
.
NetworkObserver
(
{
decodeResponseBodies
:
true
responseBodyLimit
:
lazy
.
responseBodyLimit
ignoreChannelFunction
:
this
.
shouldIgnoreChannel
.
bind
(
this
)
onNetworkEvent
:
this
.
onNetworkEvent
.
bind
(
this
)
}
)
;
Services
.
obs
.
addObserver
(
this
"
window
-
global
-
destroyed
"
)
;
}
clear
(
)
{
this
.
networkEvents
.
clear
(
)
;
this
.
listener
.
clear
(
)
;
if
(
this
.
_pool
)
{
this
.
_pool
.
destroy
(
)
;
this
.
_pool
=
null
;
}
}
get
pool
(
)
{
if
(
this
.
_pool
)
{
return
this
.
_pool
;
}
this
.
_pool
=
new
Pool
(
this
.
watcherActor
.
conn
"
network
-
events
"
)
;
this
.
watcherActor
.
manage
(
this
.
_pool
)
;
return
this
.
_pool
;
}
setPersist
(
enabled
)
{
this
.
persist
=
enabled
;
}
getThrottleData
(
)
{
return
this
.
listener
.
getThrottleData
(
)
;
}
setThrottleData
(
data
)
{
this
.
listener
.
setThrottleData
(
data
)
;
}
setSaveRequestAndResponseBodies
(
save
)
{
this
.
listener
.
setSaveRequestAndResponseBodies
(
save
)
;
}
blockRequest
(
filters
)
{
this
.
listener
.
blockRequest
(
filters
)
;
}
unblockRequest
(
filters
)
{
this
.
listener
.
unblockRequest
(
filters
)
;
}
setBlockedUrls
(
urls
)
{
this
.
listener
.
setBlockedUrls
(
urls
)
;
}
getBlockedUrls
(
)
{
return
this
.
listener
.
getBlockedUrls
(
)
;
}
override
(
url
path
)
{
this
.
listener
.
override
(
url
path
)
;
}
removeOverride
(
url
)
{
this
.
listener
.
removeOverride
(
url
)
;
}
observe
(
windowGlobal
topic
)
{
if
(
topic
!
=
=
"
window
-
global
-
destroyed
"
)
{
return
;
}
if
(
this
.
persist
|
|
this
.
watcherActor
.
sessionContext
.
type
=
=
"
all
"
)
{
return
;
}
if
(
!
isWindowGlobalPartOfContext
(
windowGlobal
this
.
watcherActor
.
sessionContext
)
)
{
return
;
}
const
{
innerWindowId
}
=
windowGlobal
;
for
(
const
child
of
this
.
pool
.
poolChildren
(
)
)
{
if
(
!
child
.
isNavigationRequest
(
)
)
{
if
(
child
.
getInnerWindowId
(
)
=
=
innerWindowId
)
{
child
.
destroy
(
)
;
}
}
else
if
(
child
.
getInnerWindowId
(
)
&
&
child
.
getInnerWindowId
(
)
!
=
innerWindowId
&
&
windowGlobal
.
browsingContext
=
=
this
.
watcherActor
.
browserElement
?
.
browsingContext
)
{
child
.
destroy
(
)
;
}
}
}
shouldIgnoreChannel
(
channel
)
{
const
filters
=
{
sessionContext
:
this
.
watcherActor
.
sessionContext
}
;
if
(
!
lazy
.
NetworkUtils
.
matchRequest
(
channel
filters
)
)
{
return
true
;
}
const
isParentProcessOnlyBrowserToolbox
=
this
.
watcherActor
.
sessionContext
.
type
=
=
"
all
"
&
&
!
ParentProcessWatcherRegistry
.
isWatchingTargets
(
this
.
watcherActor
Targets
.
TYPES
.
FRAME
)
;
if
(
isParentProcessOnlyBrowserToolbox
)
{
const
browsingContextID
=
lazy
.
NetworkUtils
.
getChannelBrowsingContextID
(
channel
)
;
const
browsingContext
=
BrowsingContext
.
get
(
browsingContextID
)
;
if
(
browsingContext
?
.
currentWindowGlobal
.
isInProcess
=
=
=
false
)
{
return
true
;
}
}
return
false
;
}
onNetworkEvent
(
networkEventOptions
channel
)
{
if
(
channel
.
channelId
&
&
this
.
networkEvents
.
has
(
channel
.
channelId
)
)
{
throw
new
Error
(
Got
notified
about
channel
{
channel
.
channelId
}
more
than
once
.
)
;
}
const
actor
=
new
NetworkEventActor
(
this
.
watcherActor
.
conn
this
.
watcherActor
.
sessionContext
{
onNetworkEventUpdate
:
this
.
onNetworkEventUpdate
.
bind
(
this
)
onNetworkEventDestroy
:
this
.
onNetworkEventDestroy
.
bind
(
this
)
}
networkEventOptions
channel
)
;
this
.
pool
.
manage
(
actor
)
;
const
resource
=
actor
.
asResource
(
)
;
const
isBlocked
=
!
!
resource
.
blockedReason
;
const
networkEvent
=
{
browsingContextID
:
resource
.
browsingContextID
innerWindowId
:
resource
.
innerWindowId
resourceId
:
resource
.
resourceId
isBlocked
receivedUpdates
:
[
]
resourceUpdates
:
{
}
}
;
lazy
.
NetworkUtils
.
setEventAsAvailable
(
resource
[
lazy
.
NetworkUtils
.
NETWORK_EVENT_TYPES
.
REQUEST_COOKIES
lazy
.
NetworkUtils
.
NETWORK_EVENT_TYPES
.
REQUEST_HEADERS
]
)
;
this
.
networkEvents
.
set
(
resource
.
resourceId
networkEvent
)
;
this
.
onNetworkEventAvailable
(
[
resource
]
)
;
if
(
isBlocked
)
{
lazy
.
NetworkUtils
.
setEventAsAvailable
(
networkEvent
.
resourceUpdates
[
lazy
.
NetworkUtils
.
NETWORK_EVENT_TYPES
.
RESPONSE_END
]
)
;
this
.
_emitUpdate
(
networkEvent
)
;
}
return
actor
;
}
onNetworkEventUpdate
(
updateResource
)
{
const
networkEvent
=
this
.
networkEvents
.
get
(
updateResource
.
resourceId
)
;
if
(
!
networkEvent
)
{
return
;
}
const
{
NETWORK_EVENT_TYPES
}
=
lazy
.
NetworkUtils
;
const
{
resourceUpdates
receivedUpdates
}
=
networkEvent
;
const
networkEventTypes
=
[
NETWORK_EVENT_TYPES
.
RESPONSE_COOKIES
NETWORK_EVENT_TYPES
.
RESPONSE_HEADERS
]
;
switch
(
updateResource
.
updateType
)
{
case
NETWORK_EVENT_TYPES
.
CACHE_DETAILS
:
resourceUpdates
.
fromCache
=
updateResource
.
fromCache
;
resourceUpdates
.
fromServiceWorker
=
updateResource
.
fromServiceWorker
;
break
;
case
NETWORK_EVENT_TYPES
.
RESPONSE_START
:
resourceUpdates
.
httpVersion
=
updateResource
.
httpVersion
;
resourceUpdates
.
status
=
updateResource
.
status
;
resourceUpdates
.
statusText
=
updateResource
.
statusText
;
resourceUpdates
.
earlyHintsStatus
=
updateResource
.
earlyHintsStatus
;
resourceUpdates
.
remoteAddress
=
updateResource
.
remoteAddress
;
resourceUpdates
.
remotePort
=
updateResource
.
remotePort
;
resourceUpdates
.
mimeType
=
updateResource
.
mimeType
;
resourceUpdates
.
waitingTime
=
updateResource
.
waitingTime
;
resourceUpdates
.
isResolvedByTRR
=
updateResource
.
isResolvedByTRR
;
resourceUpdates
.
proxyHttpVersion
=
updateResource
.
proxyHttpVersion
;
resourceUpdates
.
proxyStatus
=
updateResource
.
proxyStatus
;
resourceUpdates
.
proxyStatusText
=
updateResource
.
proxyStatusText
;
if
(
resourceUpdates
.
earlyHintsStatus
.
length
)
{
networkEventTypes
.
push
(
NETWORK_EVENT_TYPES
.
EARLY_HINT_RESPONSE_HEADERS
)
;
}
lazy
.
NetworkUtils
.
setEventAsAvailable
(
resourceUpdates
networkEventTypes
)
;
break
;
case
NETWORK_EVENT_TYPES
.
RESPONSE_CONTENT
:
resourceUpdates
.
contentSize
=
updateResource
.
contentSize
;
resourceUpdates
.
transferredSize
=
updateResource
.
transferredSize
;
resourceUpdates
.
mimeType
=
updateResource
.
mimeType
;
resourceUpdates
.
blockingExtension
=
updateResource
.
blockingExtension
;
resourceUpdates
.
blockedReason
=
updateResource
.
blockedReason
;
break
;
case
NETWORK_EVENT_TYPES
.
EVENT_TIMINGS
:
resourceUpdates
.
totalTime
=
updateResource
.
totalTime
;
break
;
case
NETWORK_EVENT_TYPES
.
SECURITY_INFO
:
resourceUpdates
.
securityState
=
updateResource
.
state
;
resourceUpdates
.
isRacing
=
updateResource
.
isRacing
;
break
;
}
lazy
.
NetworkUtils
.
setEventAsAvailable
(
resourceUpdates
[
updateResource
.
updateType
]
)
;
receivedUpdates
.
push
(
updateResource
.
updateType
)
;
const
isResponseComplete
=
receivedUpdates
.
includes
(
NETWORK_EVENT_TYPES
.
EVENT_TIMINGS
)
&
&
receivedUpdates
.
includes
(
NETWORK_EVENT_TYPES
.
RESPONSE_CONTENT
)
&
&
receivedUpdates
.
includes
(
NETWORK_EVENT_TYPES
.
SECURITY_INFO
)
;
if
(
isResponseComplete
)
{
lazy
.
NetworkUtils
.
setEventAsAvailable
(
resourceUpdates
[
lazy
.
NetworkUtils
.
NETWORK_EVENT_TYPES
.
RESPONSE_END
]
)
;
}
if
(
updateResource
.
updateType
=
=
NETWORK_EVENT_TYPES
.
RESPONSE_START
|
|
isResponseComplete
)
{
this
.
_emitUpdate
(
networkEvent
)
;
networkEvent
.
resourceUpdates
=
{
}
;
}
}
_emitUpdate
(
networkEvent
)
{
this
.
onNetworkEventUpdated
(
[
{
resourceId
:
networkEvent
.
resourceId
resourceUpdates
:
networkEvent
.
resourceUpdates
browsingContextID
:
networkEvent
.
browsingContextID
innerWindowId
:
networkEvent
.
innerWindowId
}
]
)
;
}
onNetworkEventDestroy
(
channelId
)
{
if
(
this
.
networkEvents
.
has
(
channelId
)
)
{
this
.
networkEvents
.
delete
(
channelId
)
;
}
}
destroy
(
)
{
if
(
this
.
listener
)
{
this
.
clear
(
)
;
this
.
listener
.
destroy
(
)
;
Services
.
obs
.
removeObserver
(
this
"
window
-
global
-
destroyed
"
)
;
}
}
}
module
.
exports
=
NetworkEventWatcher
;
