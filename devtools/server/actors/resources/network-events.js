"
use
strict
"
;
const
{
Pool
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
/
Pool
.
js
"
)
;
const
{
isWindowGlobalPartOfContext
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
browsing
-
context
-
helpers
.
sys
.
mjs
"
{
global
:
"
contextual
"
}
)
;
const
{
WatcherRegistry
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
WatcherRegistry
.
sys
.
mjs
"
{
global
:
"
shared
"
}
)
;
const
Targets
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
index
.
js
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
NetworkObserver
:
"
resource
:
/
/
devtools
/
shared
/
network
-
observer
/
NetworkObserver
.
sys
.
mjs
"
NetworkUtils
:
"
resource
:
/
/
devtools
/
shared
/
network
-
observer
/
NetworkUtils
.
sys
.
mjs
"
}
{
global
:
"
contextual
"
}
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkEventActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
network
-
monitor
/
network
-
event
-
actor
.
js
"
true
)
;
class
NetworkEventWatcher
{
async
watch
(
watcherActor
{
onAvailable
onUpdated
}
)
{
this
.
networkEvents
=
new
Map
(
)
;
this
.
watcherActor
=
watcherActor
;
this
.
onNetworkEventAvailable
=
onAvailable
;
this
.
onNetworkEventUpdated
=
onUpdated
;
this
.
persist
=
false
;
this
.
listener
=
new
lazy
.
NetworkObserver
(
{
ignoreChannelFunction
:
this
.
shouldIgnoreChannel
.
bind
(
this
)
onNetworkEvent
:
this
.
onNetworkEvent
.
bind
(
this
)
}
)
;
Services
.
obs
.
addObserver
(
this
"
window
-
global
-
destroyed
"
)
;
}
clear
(
)
{
this
.
networkEvents
.
clear
(
)
;
this
.
listener
.
clear
(
)
;
if
(
this
.
_pool
)
{
this
.
_pool
.
destroy
(
)
;
this
.
_pool
=
null
;
}
}
get
pool
(
)
{
if
(
this
.
_pool
)
{
return
this
.
_pool
;
}
this
.
_pool
=
new
Pool
(
this
.
watcherActor
.
conn
"
network
-
events
"
)
;
this
.
watcherActor
.
manage
(
this
.
_pool
)
;
return
this
.
_pool
;
}
setPersist
(
enabled
)
{
this
.
persist
=
enabled
;
}
getThrottleData
(
)
{
return
this
.
listener
.
getThrottleData
(
)
;
}
setThrottleData
(
data
)
{
this
.
listener
.
setThrottleData
(
data
)
;
}
setSaveRequestAndResponseBodies
(
save
)
{
this
.
listener
.
setSaveRequestAndResponseBodies
(
save
)
;
}
blockRequest
(
filters
)
{
this
.
listener
.
blockRequest
(
filters
)
;
}
unblockRequest
(
filters
)
{
this
.
listener
.
unblockRequest
(
filters
)
;
}
setBlockedUrls
(
urls
)
{
this
.
listener
.
setBlockedUrls
(
urls
)
;
}
getBlockedUrls
(
)
{
return
this
.
listener
.
getBlockedUrls
(
)
;
}
override
(
url
path
)
{
this
.
listener
.
override
(
url
path
)
;
}
removeOverride
(
url
)
{
this
.
listener
.
removeOverride
(
url
)
;
}
observe
(
windowGlobal
topic
)
{
if
(
topic
!
=
=
"
window
-
global
-
destroyed
"
)
{
return
;
}
if
(
this
.
persist
|
|
this
.
watcherActor
.
sessionContext
.
type
=
=
"
all
"
)
{
return
;
}
if
(
!
isWindowGlobalPartOfContext
(
windowGlobal
this
.
watcherActor
.
sessionContext
)
)
{
return
;
}
const
{
innerWindowId
}
=
windowGlobal
;
for
(
const
child
of
this
.
pool
.
poolChildren
(
)
)
{
if
(
!
child
.
isNavigationRequest
(
)
)
{
if
(
child
.
getInnerWindowId
(
)
=
=
innerWindowId
)
{
child
.
destroy
(
)
;
}
}
else
if
(
child
.
getInnerWindowId
(
)
&
&
child
.
getInnerWindowId
(
)
!
=
innerWindowId
&
&
windowGlobal
.
browsingContext
=
=
this
.
watcherActor
.
browserElement
?
.
browsingContext
)
{
child
.
destroy
(
)
;
}
}
}
shouldIgnoreChannel
(
channel
)
{
const
filters
=
{
sessionContext
:
this
.
watcherActor
.
sessionContext
}
;
if
(
!
lazy
.
NetworkUtils
.
matchRequest
(
channel
filters
)
)
{
return
true
;
}
const
isParentProcessOnlyBrowserToolbox
=
this
.
watcherActor
.
sessionContext
.
type
=
=
"
all
"
&
&
!
WatcherRegistry
.
isWatchingTargets
(
this
.
watcherActor
Targets
.
TYPES
.
FRAME
)
;
if
(
isParentProcessOnlyBrowserToolbox
)
{
const
browsingContextID
=
lazy
.
NetworkUtils
.
getChannelBrowsingContextID
(
channel
)
;
const
browsingContext
=
BrowsingContext
.
get
(
browsingContextID
)
;
if
(
browsingContext
?
.
currentWindowGlobal
.
isInProcess
=
=
=
false
)
{
return
true
;
}
}
return
false
;
}
onNetworkEvent
(
networkEventOptions
channel
)
{
if
(
channel
.
channelId
&
&
this
.
networkEvents
.
has
(
channel
.
channelId
)
)
{
throw
new
Error
(
Got
notified
about
channel
{
channel
.
channelId
}
more
than
once
.
)
;
}
const
actor
=
new
NetworkEventActor
(
this
.
watcherActor
.
conn
this
.
watcherActor
.
sessionContext
{
onNetworkEventUpdate
:
this
.
onNetworkEventUpdate
.
bind
(
this
)
onNetworkEventDestroy
:
this
.
onNetworkEventDestroy
.
bind
(
this
)
}
networkEventOptions
channel
)
;
this
.
pool
.
manage
(
actor
)
;
const
resource
=
actor
.
asResource
(
)
;
const
isBlocked
=
!
!
resource
.
blockedReason
;
const
networkEvent
=
{
browsingContextID
:
resource
.
browsingContextID
innerWindowId
:
resource
.
innerWindowId
resourceId
:
resource
.
resourceId
resourceType
:
resource
.
resourceType
isBlocked
isFileRequest
:
resource
.
isFileRequest
receivedUpdates
:
[
]
resourceUpdates
:
{
requestCookiesAvailable
:
true
requestHeadersAvailable
:
true
}
}
;
this
.
networkEvents
.
set
(
resource
.
resourceId
networkEvent
)
;
this
.
onNetworkEventAvailable
(
[
resource
]
)
;
if
(
isBlocked
)
{
this
.
_emitUpdate
(
networkEvent
)
;
}
return
actor
;
}
onNetworkEventUpdate
(
updateResource
)
{
const
networkEvent
=
this
.
networkEvents
.
get
(
updateResource
.
resourceId
)
;
if
(
!
networkEvent
)
{
return
;
}
const
{
resourceUpdates
receivedUpdates
}
=
networkEvent
;
switch
(
updateResource
.
updateType
)
{
case
"
responseStart
"
:
resourceUpdates
.
httpVersion
=
updateResource
.
httpVersion
;
resourceUpdates
.
status
=
updateResource
.
status
;
resourceUpdates
.
statusText
=
updateResource
.
statusText
;
resourceUpdates
.
remoteAddress
=
updateResource
.
remoteAddress
;
resourceUpdates
.
remotePort
=
updateResource
.
remotePort
;
resourceUpdates
.
mimeType
=
updateResource
.
mimeType
;
resourceUpdates
.
waitingTime
=
updateResource
.
waitingTime
;
resourceUpdates
.
isResolvedByTRR
=
updateResource
.
isResolvedByTRR
;
resourceUpdates
.
proxyHttpVersion
=
updateResource
.
proxyHttpVersion
;
resourceUpdates
.
proxyStatus
=
updateResource
.
proxyStatus
;
resourceUpdates
.
proxyStatusText
=
updateResource
.
proxyStatusText
;
resourceUpdates
.
responseHeadersAvailable
=
true
;
resourceUpdates
.
responseCookiesAvailable
=
true
;
break
;
case
"
responseContent
"
:
resourceUpdates
.
contentSize
=
updateResource
.
contentSize
;
resourceUpdates
.
transferredSize
=
updateResource
.
transferredSize
;
resourceUpdates
.
mimeType
=
updateResource
.
mimeType
;
resourceUpdates
.
blockingExtension
=
updateResource
.
blockingExtension
;
resourceUpdates
.
blockedReason
=
updateResource
.
blockedReason
;
break
;
case
"
eventTimings
"
:
resourceUpdates
.
totalTime
=
updateResource
.
totalTime
;
break
;
case
"
securityInfo
"
:
resourceUpdates
.
securityState
=
updateResource
.
state
;
resourceUpdates
.
isRacing
=
updateResource
.
isRacing
;
break
;
}
resourceUpdates
[
{
updateResource
.
updateType
}
Available
]
=
true
;
receivedUpdates
.
push
(
updateResource
.
updateType
)
;
const
isComplete
=
networkEvent
.
isFileRequest
?
receivedUpdates
.
includes
(
"
responseStart
"
)
:
receivedUpdates
.
includes
(
"
eventTimings
"
)
&
&
receivedUpdates
.
includes
(
"
responseContent
"
)
&
&
receivedUpdates
.
includes
(
"
securityInfo
"
)
;
if
(
isComplete
)
{
this
.
_emitUpdate
(
networkEvent
)
;
}
}
_emitUpdate
(
networkEvent
)
{
this
.
onNetworkEventUpdated
(
[
{
resourceType
:
networkEvent
.
resourceType
resourceId
:
networkEvent
.
resourceId
resourceUpdates
:
networkEvent
.
resourceUpdates
browsingContextID
:
networkEvent
.
browsingContextID
innerWindowId
:
networkEvent
.
innerWindowId
}
]
)
;
}
onNetworkEventDestroy
(
channelId
)
{
if
(
this
.
networkEvents
.
has
(
channelId
)
)
{
this
.
networkEvents
.
delete
(
channelId
)
;
}
}
destroy
(
)
{
if
(
this
.
listener
)
{
this
.
clear
(
)
;
this
.
listener
.
destroy
(
)
;
Services
.
obs
.
removeObserver
(
this
"
window
-
global
-
destroyed
"
)
;
}
}
}
module
.
exports
=
NetworkEventWatcher
;
