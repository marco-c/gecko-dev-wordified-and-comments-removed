"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Pool
}
=
require
(
"
devtools
/
shared
/
protocol
/
Pool
"
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkObserver
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
network
-
observer
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkEventActor
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
network
-
event
-
actor
"
true
)
;
class
NetworkEventWatcher
{
async
watch
(
watcherActor
{
onAvailable
onUpdated
}
)
{
this
.
networkEvents
=
new
Map
(
)
;
this
.
watcherActor
=
watcherActor
;
this
.
pool
=
new
Pool
(
watcherActor
.
conn
"
network
-
events
"
)
;
this
.
watcherActor
.
manage
(
this
.
pool
)
;
this
.
onNetworkEventAvailable
=
onAvailable
;
this
.
onNetworkEventUpdated
=
onUpdated
;
this
.
persist
=
false
;
this
.
listener
=
new
NetworkObserver
(
{
browserId
:
watcherActor
.
browserId
}
{
onNetworkEvent
:
this
.
onNetworkEvent
.
bind
(
this
)
}
)
;
this
.
listener
.
init
(
)
;
Services
.
obs
.
addObserver
(
this
"
window
-
global
-
destroyed
"
)
;
}
get
conn
(
)
{
return
this
.
watcherActor
.
conn
;
}
get
browserId
(
)
{
return
this
.
watcherActor
.
browserId
;
}
setPersist
(
enabled
)
{
this
.
persist
=
enabled
;
}
getThrottleData
(
)
{
return
this
.
listener
.
throttleData
;
}
setThrottleData
(
data
)
{
this
.
listener
.
throttleData
=
data
;
}
setSaveRequestAndResponseBodies
(
save
)
{
this
.
listener
.
saveRequestAndResponseBodies
=
save
;
}
blockRequest
(
filters
)
{
this
.
listener
.
blockRequest
(
filters
)
;
}
unblockRequest
(
filters
)
{
this
.
listener
.
unblockRequest
(
filters
)
;
}
setBlockedUrls
(
urls
)
{
this
.
listener
.
setBlockedUrls
(
urls
)
;
}
getBlockedUrls
(
)
{
return
this
.
listener
.
getBlockedUrls
(
)
;
}
observe
(
windowGlobal
topic
)
{
if
(
topic
!
=
=
"
window
-
global
-
destroyed
"
)
{
return
;
}
if
(
this
.
persist
)
{
return
;
}
if
(
this
.
watcherActor
.
browserId
&
&
windowGlobal
.
browsingContext
.
browserId
!
=
this
.
watcherActor
.
browserId
)
{
return
;
}
if
(
windowGlobal
.
isInitialDocument
)
{
return
;
}
const
{
innerWindowId
}
=
windowGlobal
;
for
(
const
child
of
this
.
pool
.
poolChildren
(
)
)
{
if
(
!
child
.
isNavigationRequest
)
{
if
(
child
.
innerWindowId
=
=
innerWindowId
)
{
child
.
destroy
(
)
;
}
}
else
if
(
child
.
innerWindowId
!
=
innerWindowId
&
&
windowGlobal
.
browsingContext
=
=
this
.
watcherActor
.
browserElement
.
browsingContext
)
{
child
.
destroy
(
)
;
}
}
}
onNetworkEvent
(
event
)
{
const
{
channelId
}
=
event
;
if
(
this
.
networkEvents
.
has
(
channelId
)
)
{
throw
new
Error
(
Got
notified
about
channel
{
channelId
}
more
than
once
.
)
;
}
const
actor
=
new
NetworkEventActor
(
this
{
onNetworkEventUpdate
:
this
.
onNetworkEventUpdate
.
bind
(
this
)
onNetworkEventDestroy
:
this
.
onNetworkEventDestroy
.
bind
(
this
)
}
event
)
;
this
.
pool
.
manage
(
actor
)
;
const
resource
=
actor
.
asResource
(
)
;
this
.
networkEvents
.
set
(
resource
.
resourceId
{
resourceId
:
resource
.
resourceId
resourceType
:
resource
.
resourceType
isBlocked
:
!
!
resource
.
blockedReason
types
:
[
]
resourceUpdates
:
{
}
}
)
;
this
.
onNetworkEventAvailable
(
[
resource
]
)
;
return
actor
;
}
onNetworkEventUpdate
(
updateResource
)
{
const
networkEvent
=
this
.
networkEvents
.
get
(
updateResource
.
resourceId
)
;
if
(
!
networkEvent
)
{
return
;
}
const
{
resourceId
resourceType
resourceUpdates
types
isBlocked
}
=
networkEvent
;
switch
(
updateResource
.
updateType
)
{
case
"
responseStart
"
:
resourceUpdates
.
httpVersion
=
updateResource
.
httpVersion
;
resourceUpdates
.
status
=
updateResource
.
status
;
resourceUpdates
.
statusText
=
updateResource
.
statusText
;
resourceUpdates
.
remoteAddress
=
updateResource
.
remoteAddress
;
resourceUpdates
.
remotePort
=
updateResource
.
remotePort
;
resourceUpdates
.
mimeType
=
updateResource
.
mimeType
;
resourceUpdates
.
waitingTime
=
updateResource
.
waitingTime
;
break
;
case
"
responseContent
"
:
resourceUpdates
.
contentSize
=
updateResource
.
contentSize
;
resourceUpdates
.
transferredSize
=
updateResource
.
transferredSize
;
resourceUpdates
.
mimeType
=
updateResource
.
mimeType
;
resourceUpdates
.
blockingExtension
=
updateResource
.
blockingExtension
;
resourceUpdates
.
blockedReason
=
updateResource
.
blockedReason
;
break
;
case
"
eventTimings
"
:
resourceUpdates
.
totalTime
=
updateResource
.
totalTime
;
break
;
case
"
securityInfo
"
:
resourceUpdates
.
securityState
=
updateResource
.
state
;
resourceUpdates
.
isRacing
=
updateResource
.
isRacing
;
break
;
}
resourceUpdates
[
{
updateResource
.
updateType
}
Available
]
=
true
;
types
.
push
(
updateResource
.
updateType
)
;
if
(
isBlocked
)
{
if
(
!
types
.
includes
(
"
requestHeaders
"
)
|
|
!
types
.
includes
(
"
requestCookies
"
)
)
{
return
;
}
}
else
if
(
!
types
.
includes
(
"
requestHeaders
"
)
|
|
!
types
.
includes
(
"
requestCookies
"
)
|
|
!
types
.
includes
(
"
eventTimings
"
)
|
|
!
types
.
includes
(
"
responseContent
"
)
|
|
!
types
.
includes
(
"
securityInfo
"
)
)
{
return
;
}
this
.
onNetworkEventUpdated
(
[
{
resourceType
resourceId
resourceUpdates
}
]
)
;
}
onNetworkEventDestroy
(
channelId
)
{
if
(
this
.
networkEvents
.
has
(
channelId
)
)
{
this
.
networkEvents
.
delete
(
channelId
)
;
}
}
destroy
(
watcherActor
)
{
if
(
this
.
listener
)
{
this
.
listener
.
destroy
(
)
;
Services
.
obs
.
removeObserver
(
this
"
window
-
global
-
destroyed
"
)
;
this
.
pool
.
destroy
(
)
;
}
}
}
module
.
exports
=
NetworkEventWatcher
;
