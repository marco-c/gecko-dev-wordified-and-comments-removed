"
use
strict
"
;
const
{
TYPES
:
{
NETWORK_EVENT_STACKTRACE
}
}
=
require
(
"
devtools
/
server
/
actors
/
resources
/
index
"
)
;
const
{
Ci
components
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
loader
.
lazyRequireGetter
(
this
"
ChannelEventSinkFactory
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
channel
-
event
-
sink
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkUtils
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
utils
/
network
-
utils
.
js
"
)
;
class
NetworkEventStackTracesWatcher
{
async
watch
(
targetActor
{
onAvailable
}
)
{
this
.
stacktraces
=
new
Map
(
)
;
this
.
onStackTraceAvailable
=
onAvailable
;
this
.
targetActor
=
targetActor
;
Services
.
obs
.
addObserver
(
this
"
http
-
on
-
opening
-
request
"
)
;
Services
.
obs
.
addObserver
(
this
"
document
-
on
-
opening
-
request
"
)
;
Services
.
obs
.
addObserver
(
this
"
network
-
monitor
-
alternate
-
stack
"
)
;
ChannelEventSinkFactory
.
getService
(
)
.
registerCollector
(
this
)
;
}
clear
(
)
{
this
.
stacktraces
.
clear
(
)
;
}
destroy
(
targetActor
)
{
this
.
clear
(
)
;
Services
.
obs
.
removeObserver
(
this
"
http
-
on
-
opening
-
request
"
)
;
Services
.
obs
.
removeObserver
(
this
"
document
-
on
-
opening
-
request
"
)
;
Services
.
obs
.
removeObserver
(
this
"
network
-
monitor
-
alternate
-
stack
"
)
;
ChannelEventSinkFactory
.
getService
(
)
.
unregisterCollector
(
this
)
;
}
onChannelRedirect
(
oldChannel
newChannel
flags
)
{
try
{
oldChannel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
newChannel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
}
catch
(
ex
)
{
return
;
}
const
oldId
=
oldChannel
.
channelId
;
const
stacktrace
=
this
.
stacktraces
.
get
(
oldId
)
;
if
(
stacktrace
)
{
this
.
_setStackTrace
(
newChannel
.
channelId
stacktrace
)
;
}
}
observe
(
subject
topic
data
)
{
let
channel
id
;
try
{
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
id
=
channel
.
channelId
;
}
catch
(
e1
)
{
try
{
channel
=
subject
.
QueryInterface
(
Ci
.
nsIIdentChannel
)
;
id
=
channel
.
channelId
;
}
catch
(
e2
)
{
try
{
channel
=
subject
.
QueryInterface
(
Ci
.
nsIWebSocketChannel
)
;
id
=
channel
.
serial
;
}
catch
(
e3
)
{
return
;
}
}
}
if
(
!
NetworkUtils
.
matchRequest
(
channel
{
targetActor
:
this
.
targetActor
}
)
)
{
return
;
}
if
(
this
.
stacktraces
.
has
(
id
)
)
{
return
;
}
const
stacktrace
=
[
]
;
switch
(
topic
)
{
case
"
http
-
on
-
opening
-
request
"
:
case
"
document
-
on
-
opening
-
request
"
:
{
let
frame
=
components
.
stack
;
if
(
frame
?
.
caller
)
{
frame
=
frame
.
caller
;
while
(
frame
)
{
stacktrace
.
push
(
{
filename
:
frame
.
filename
lineNumber
:
frame
.
lineNumber
columnNumber
:
frame
.
columnNumber
functionName
:
frame
.
name
asyncCause
:
frame
.
asyncCause
}
)
;
frame
=
frame
.
caller
|
|
frame
.
asyncCaller
;
}
}
break
;
}
case
"
network
-
monitor
-
alternate
-
stack
"
:
{
let
frame
=
JSON
.
parse
(
data
)
;
while
(
frame
)
{
stacktrace
.
push
(
{
filename
:
frame
.
source
lineNumber
:
frame
.
line
columnNumber
:
frame
.
column
functionName
:
frame
.
functionDisplayName
asyncCause
:
frame
.
asyncCause
}
)
;
frame
=
frame
.
parent
|
|
frame
.
asyncParent
;
}
break
;
}
default
:
throw
new
Error
(
"
Unexpected
observe
(
)
topic
"
)
;
}
this
.
_setStackTrace
(
id
stacktrace
)
;
}
_setStackTrace
(
resourceId
stacktrace
)
{
this
.
stacktraces
.
set
(
resourceId
stacktrace
)
;
this
.
onStackTraceAvailable
(
[
{
resourceType
:
NETWORK_EVENT_STACKTRACE
resourceId
stacktraceAvailable
:
stacktrace
&
&
!
!
stacktrace
.
length
lastFrame
:
stacktrace
&
&
stacktrace
.
length
?
stacktrace
[
0
]
:
undefined
}
]
)
;
}
getStackTrace
(
id
)
{
let
stacktrace
=
[
]
;
if
(
this
.
stacktraces
.
has
(
id
)
)
{
stacktrace
=
this
.
stacktraces
.
get
(
id
)
;
}
return
stacktrace
;
}
}
module
.
exports
=
NetworkEventStackTracesWatcher
;
