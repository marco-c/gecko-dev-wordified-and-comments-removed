"
use
strict
"
;
const
nsIConsoleListenerWatcher
=
require
(
"
devtools
/
server
/
actors
/
resources
/
utils
/
nsi
-
console
-
listener
-
watcher
"
)
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
{
DevToolsServer
}
=
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
const
{
createStringGrip
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
{
getActorIdForInternalSourceId
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
dbg
-
source
"
)
;
const
{
WebConsoleUtils
}
=
require
(
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
)
;
const
{
TYPES
:
{
CSS_MESSAGE
}
}
=
require
(
"
devtools
/
server
/
actors
/
resources
/
index
"
)
;
const
{
MESSAGE_CATEGORY
}
=
require
(
"
devtools
/
shared
/
constants
"
)
;
class
CSSMessageWatcher
extends
nsIConsoleListenerWatcher
{
async
watch
(
targetActor
{
onAvailable
}
)
{
super
.
watch
(
targetActor
{
onAvailable
}
)
;
if
(
targetActor
.
ensureCSSErrorReportingEnabled
)
{
targetActor
.
ensureCSSErrorReportingEnabled
(
)
;
}
}
shouldHandleMessage
(
targetActor
message
)
{
if
(
!
(
message
instanceof
Ci
.
nsIScriptError
)
|
|
message
.
category
!
=
=
MESSAGE_CATEGORY
.
CSS_PARSER
)
{
return
false
;
}
if
(
this
.
isProcessTarget
(
targetActor
)
)
{
return
!
message
.
isFromPrivateWindow
;
}
if
(
!
message
.
innerWindowID
)
{
return
false
;
}
if
(
targetActor
.
ignoreSubFrames
)
{
return
(
WebConsoleUtils
.
getInnerWindowId
(
targetActor
.
window
)
=
=
=
message
.
innerWindowID
)
;
}
const
ids
=
WebConsoleUtils
.
getInnerWindowIDsForFrames
(
targetActor
.
window
)
;
return
ids
.
includes
(
message
.
innerWindowID
)
;
}
buildResource
(
targetActor
error
)
{
const
stack
=
this
.
prepareStackForRemote
(
targetActor
error
.
stack
)
;
let
lineText
=
error
.
sourceLine
;
if
(
lineText
&
&
lineText
.
length
>
DevToolsServer
.
LONG_STRING_INITIAL_LENGTH
)
{
lineText
=
lineText
.
substr
(
0
DevToolsServer
.
LONG_STRING_INITIAL_LENGTH
)
;
}
const
notesArray
=
this
.
prepareNotesForRemote
(
targetActor
error
.
notes
)
;
let
{
sourceName
sourceId
lineNumber
columnNumber
}
=
error
;
if
(
!
sourceName
&
&
!
sourceId
&
&
!
lineNumber
&
&
!
columnNumber
&
&
stack
)
{
sourceName
=
stack
[
0
]
.
filename
;
sourceId
=
stack
[
0
]
.
sourceId
;
lineNumber
=
stack
[
0
]
.
lineNumber
;
columnNumber
=
stack
[
0
]
.
columnNumber
;
}
const
pageError
=
{
errorMessage
:
createStringGrip
(
targetActor
error
.
errorMessage
)
sourceName
sourceId
:
getActorIdForInternalSourceId
(
targetActor
sourceId
)
lineText
lineNumber
columnNumber
category
:
error
.
category
innerWindowID
:
error
.
innerWindowID
timeStamp
:
error
.
timeStamp
warning
:
!
!
(
error
.
flags
&
error
.
warningFlag
)
error
:
!
(
error
.
flags
&
(
error
.
warningFlag
|
error
.
infoFlag
)
)
info
:
!
!
(
error
.
flags
&
error
.
infoFlag
)
private
:
error
.
isFromPrivateWindow
stacktrace
:
stack
notes
:
notesArray
chromeContext
:
error
.
isFromChromeContext
isForwardedFromContentProcess
:
error
.
isForwardedFromContentProcess
}
;
return
{
pageError
resourceType
:
CSS_MESSAGE
cssSelectors
:
error
.
cssSelectors
}
;
}
}
module
.
exports
=
CSSMessageWatcher
;
