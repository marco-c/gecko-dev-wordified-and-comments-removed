"
use
strict
"
;
const
nsIConsoleListenerWatcher
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
utils
/
nsi
-
console
-
listener
-
watcher
.
js
"
)
;
const
{
DevToolsServer
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
devtools
-
server
.
js
"
)
;
const
{
createStringGrip
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
utils
.
js
"
)
;
const
{
getActorIdForInternalSourceId
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
dbg
-
source
.
js
"
)
;
const
{
WebConsoleUtils
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
utils
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
getStyleSheetText
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
stylesheet
-
utils
.
js
"
true
)
;
const
{
TYPES
:
{
CSS_MESSAGE
}
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
index
.
js
"
)
;
const
{
MESSAGE_CATEGORY
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
constants
.
js
"
)
;
class
CSSMessageWatcher
extends
nsIConsoleListenerWatcher
{
async
watch
(
targetActor
{
onAvailable
}
)
{
super
.
watch
(
targetActor
{
onAvailable
}
)
;
await
this
.
#
ensureCSSErrorReportingEnabled
(
targetActor
)
;
}
shouldHandleMessage
(
targetActor
message
)
{
if
(
!
(
message
instanceof
Ci
.
nsIScriptError
)
|
|
message
.
category
!
=
=
MESSAGE_CATEGORY
.
CSS_PARSER
)
{
return
false
;
}
if
(
this
.
isProcessTarget
(
targetActor
)
)
{
return
!
message
.
isFromPrivateWindow
;
}
if
(
!
message
.
innerWindowID
)
{
return
false
;
}
const
ids
=
targetActor
.
windows
.
map
(
window
=
>
WebConsoleUtils
.
getInnerWindowId
(
window
)
)
;
return
ids
.
includes
(
message
.
innerWindowID
)
;
}
buildResource
(
targetActor
error
)
{
const
stack
=
this
.
prepareStackForRemote
(
targetActor
error
.
stack
)
;
let
lineText
=
error
.
sourceLine
;
if
(
lineText
&
&
lineText
.
length
>
DevToolsServer
.
LONG_STRING_INITIAL_LENGTH
)
{
lineText
=
lineText
.
substr
(
0
DevToolsServer
.
LONG_STRING_INITIAL_LENGTH
)
;
}
const
notesArray
=
this
.
prepareNotesForRemote
(
targetActor
error
.
notes
)
;
let
{
sourceName
sourceId
lineNumber
columnNumber
}
=
error
;
if
(
!
sourceName
&
&
!
sourceId
&
&
!
lineNumber
&
&
!
columnNumber
&
&
stack
)
{
sourceName
=
stack
[
0
]
.
filename
;
sourceId
=
stack
[
0
]
.
sourceId
;
lineNumber
=
stack
[
0
]
.
lineNumber
;
columnNumber
=
stack
[
0
]
.
columnNumber
;
}
const
pageError
=
{
errorMessage
:
createStringGrip
(
targetActor
error
.
errorMessage
)
sourceName
sourceId
:
getActorIdForInternalSourceId
(
targetActor
sourceId
)
lineText
lineNumber
columnNumber
category
:
error
.
category
innerWindowID
:
error
.
innerWindowID
timeStamp
:
error
.
microSecondTimeStamp
/
1000
warning
:
!
!
(
error
.
flags
&
error
.
warningFlag
)
error
:
!
(
error
.
flags
&
(
error
.
warningFlag
|
error
.
infoFlag
)
)
info
:
!
!
(
error
.
flags
&
error
.
infoFlag
)
private
:
error
.
isFromPrivateWindow
stacktrace
:
stack
notes
:
notesArray
chromeContext
:
error
.
isFromChromeContext
isForwardedFromContentProcess
:
error
.
isForwardedFromContentProcess
}
;
return
{
pageError
resourceType
:
CSS_MESSAGE
cssSelectors
:
error
.
cssSelectors
}
;
}
async
#
ensureCSSErrorReportingEnabled
(
targetActor
)
{
const
docShells
=
targetActor
.
docShells
;
if
(
!
docShells
)
{
return
;
}
const
promises
=
docShells
.
map
(
async
docShell
=
>
{
if
(
docShell
.
cssErrorReportingEnabled
)
{
return
;
}
try
{
docShell
.
cssErrorReportingEnabled
=
true
;
}
catch
(
e
)
{
return
;
}
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
const
sheets
=
InspectorUtils
.
getAllStyleSheets
(
docShell
.
document
true
)
;
for
(
const
sheet
of
sheets
)
{
if
(
InspectorUtils
.
hasRulesModifiedByCSSOM
(
sheet
)
)
{
continue
;
}
try
{
const
text
=
await
getStyleSheetText
(
sheet
)
;
InspectorUtils
.
parseStyleSheet
(
sheet
text
false
)
;
}
catch
(
e
)
{
console
.
error
(
"
Error
while
parsing
stylesheet
"
)
;
}
}
}
)
;
await
Promise
.
all
(
promises
)
;
}
}
module
.
exports
=
CSSMessageWatcher
;
