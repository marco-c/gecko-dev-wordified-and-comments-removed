"
use
strict
"
;
const
{
TYPES
:
{
DOCUMENT_EVENT
}
}
=
require
(
"
devtools
/
server
/
actors
/
resources
/
index
"
)
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
isEveryFrameTargetEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
every
-
frame
-
target
.
enabled
"
false
)
;
const
{
getAllRemoteBrowsingContexts
}
=
require
(
"
devtools
/
server
/
actors
/
watcher
/
target
-
helpers
/
utils
.
js
"
)
;
const
{
WILL_NAVIGATE_TIME_SHIFT
}
=
require
(
"
devtools
/
server
/
actors
/
webconsole
/
listeners
/
document
-
events
"
)
;
class
ParentProcessDocumentEventWatcher
{
async
watch
(
watcherActor
{
onAvailable
}
)
{
this
.
watcherActor
=
watcherActor
;
this
.
onAvailable
=
onAvailable
;
this
.
_onceWillNavigate
=
new
Map
(
)
;
const
topLevelBrowsingContexts
=
this
.
getAllBrowsingContexts
(
)
.
filter
(
browsingContext
=
>
browsingContext
.
top
=
=
browsingContext
)
;
this
.
webProgresses
=
topLevelBrowsingContexts
.
map
(
browsingContext
=
>
browsingContext
.
webProgress
)
;
this
.
webProgresses
.
forEach
(
webProgress
=
>
{
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
}
)
;
}
getAllBrowsingContexts
(
)
{
if
(
this
.
watcherActor
.
context
.
type
=
=
"
browser
-
element
"
)
{
const
browsingContext
=
this
.
watcherActor
.
browserElement
.
browsingContext
;
return
browsingContext
.
getAllBrowsingContextsInSubtree
(
)
;
}
if
(
this
.
watcherActor
.
context
.
type
=
=
"
all
"
)
{
return
getAllRemoteBrowsingContexts
(
)
;
}
if
(
this
.
watcherActor
.
context
.
type
=
=
"
webextension
"
)
{
return
getAllRemoteBrowsingContexts
(
)
.
filter
(
bc
=
>
bc
.
currentWindowGlobal
.
documentPrincipal
.
addonId
=
=
this
.
watcherActor
.
context
.
addonId
)
;
}
throw
new
Error
(
"
Unsupported
context
type
=
"
+
this
.
watcherActor
.
context
.
type
)
;
}
onceWillNavigateIsEmitted
(
innerWindowId
)
{
const
isTracked
=
this
.
webProgresses
.
find
(
webProgress
=
>
webProgress
.
browsingContext
.
currentWindowGlobal
.
innerWindowId
=
=
innerWindowId
)
;
if
(
isTracked
)
{
return
new
Promise
(
resolve
=
>
{
this
.
_onceWillNavigate
.
set
(
innerWindowId
resolve
)
;
}
)
;
}
return
Promise
.
resolve
(
)
;
}
onStateChange
(
progress
request
flag
status
)
{
const
isStart
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_START
;
const
isDocument
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_IS_DOCUMENT
;
if
(
isDocument
&
&
isStart
)
{
const
{
browsingContext
}
=
progress
;
if
(
!
browsingContext
.
currentWindowGlobal
.
isProcessRoot
&
&
!
isEveryFrameTargetEnabled
)
{
return
;
}
if
(
browsingContext
.
currentWindowGlobal
.
isInitialDocument
)
{
return
;
}
const
isTopLevel
=
browsingContext
.
top
=
=
browsingContext
;
const
isRestoring
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_RESTORING
;
if
(
!
isTopLevel
&
&
isRestoring
)
{
return
;
}
const
newURI
=
request
instanceof
Ci
.
nsIChannel
?
request
.
URI
.
spec
:
null
;
const
{
innerWindowId
}
=
browsingContext
.
currentWindowGlobal
;
this
.
onAvailable
(
[
{
browsingContextID
:
browsingContext
.
id
innerWindowId
resourceType
:
DOCUMENT_EVENT
name
:
"
will
-
navigate
"
time
:
Date
.
now
(
)
-
WILL_NAVIGATE_TIME_SHIFT
isFrameSwitching
:
false
newURI
}
]
)
;
const
callback
=
this
.
_onceWillNavigate
.
get
(
innerWindowId
)
;
if
(
callback
)
{
this
.
_onceWillNavigate
.
delete
(
innerWindowId
)
;
callback
(
)
;
}
}
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
;
}
destroy
(
)
{
this
.
webProgresses
.
forEach
(
webProgress
=
>
{
webProgress
.
removeProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
}
)
;
this
.
webProgresses
=
null
;
}
}
module
.
exports
=
ParentProcessDocumentEventWatcher
;
