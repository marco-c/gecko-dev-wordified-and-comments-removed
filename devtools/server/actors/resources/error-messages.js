"
use
strict
"
;
const
{
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
{
DevToolsServer
}
=
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
const
ErrorDocs
=
require
(
"
devtools
/
server
/
actors
/
errordocs
"
)
;
const
{
createStringGrip
makeDebuggeeValue
createValueGripForTarget
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
{
getActorIdForInternalSourceId
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
dbg
-
source
"
)
;
const
{
TYPES
:
{
ERROR_MESSAGE
}
}
=
require
(
"
devtools
/
server
/
actors
/
resources
/
index
"
)
;
class
ErrorMessageWatcher
{
constructor
(
targetActor
{
onAvailable
}
)
{
targetActor
.
attach
(
)
;
const
listener
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIConsoleListener
"
]
)
observe
(
message
)
{
if
(
!
shouldHandleMessage
(
targetActor
message
)
)
{
return
;
}
onAvailable
(
[
buildPageErrorResource
(
targetActor
message
)
]
)
;
}
}
;
const
cachedMessages
=
Services
.
console
.
getMessageArray
(
)
|
|
[
]
;
Services
.
console
.
registerListener
(
listener
)
;
this
.
listener
=
listener
;
const
messages
=
[
]
;
for
(
const
message
of
cachedMessages
)
{
if
(
!
shouldHandleMessage
(
targetActor
message
)
)
{
continue
;
}
messages
.
push
(
buildPageErrorResource
(
targetActor
message
)
)
;
}
onAvailable
(
messages
)
;
}
destroy
(
)
{
if
(
this
.
listener
)
{
Services
.
console
.
unregisterListener
(
this
.
listener
)
;
}
}
}
module
.
exports
=
ErrorMessageWatcher
;
function
shouldHandleMessage
(
targetActor
message
)
{
if
(
!
(
message
instanceof
Ci
.
nsIScriptError
)
|
|
!
isCategoryAllowed
(
targetActor
message
.
category
)
|
|
message
.
sourceName
=
=
=
"
debugger
eager
eval
code
"
|
|
(
isProcessTarget
(
targetActor
)
&
&
message
.
isFromPrivateWindow
)
)
{
return
false
;
}
if
(
isProcessTarget
(
targetActor
)
)
{
return
true
;
}
if
(
!
message
.
innerWindowID
)
{
return
false
;
}
const
{
window
}
=
targetActor
.
window
;
const
win
=
window
?
.
WindowGlobalChild
?
.
getByInnerWindowId
(
message
.
innerWindowID
)
;
return
targetActor
.
browserId
=
=
=
win
?
.
browsingContext
?
.
browserId
;
}
const
PLATFORM_SPECIFIC_CATEGORIES
=
[
"
XPConnect
JavaScript
"
"
component
javascript
"
"
chrome
javascript
"
"
chrome
registration
"
]
;
function
isCategoryAllowed
(
targetActor
category
)
{
if
(
!
category
|
|
category
=
=
=
"
CSS
Parser
"
)
{
return
false
;
}
if
(
isProcessTarget
(
targetActor
)
)
{
return
true
;
}
return
!
PLATFORM_SPECIFIC_CATEGORIES
.
includes
(
category
)
;
}
function
isProcessTarget
(
targetActor
)
{
const
{
typeName
}
=
targetActor
;
return
(
typeName
=
=
=
"
parentProcessTarget
"
|
|
typeName
=
=
=
"
contentProcessTarget
"
)
;
}
function
buildPageErrorResource
(
targetActor
error
)
{
const
stack
=
prepareStackForRemote
(
targetActor
error
.
stack
)
;
let
lineText
=
error
.
sourceLine
;
if
(
lineText
&
&
lineText
.
length
>
DevToolsServer
.
LONG_STRING_INITIAL_LENGTH
)
{
lineText
=
lineText
.
substr
(
0
DevToolsServer
.
LONG_STRING_INITIAL_LENGTH
)
;
}
let
notesArray
=
null
;
const
notes
=
error
.
notes
;
if
(
notes
?
.
length
)
{
notesArray
=
[
]
;
for
(
let
i
=
0
len
=
notes
.
length
;
i
<
len
;
i
+
+
)
{
const
note
=
notes
.
queryElementAt
(
i
Ci
.
nsIScriptErrorNote
)
;
notesArray
.
push
(
{
messageBody
:
createStringGrip
(
targetActor
note
.
errorMessage
)
frame
:
{
source
:
note
.
sourceName
sourceId
:
getActorIdForInternalSourceId
(
targetActor
note
.
sourceId
)
line
:
note
.
lineNumber
column
:
note
.
columnNumber
}
}
)
;
}
}
let
{
sourceName
sourceId
lineNumber
columnNumber
}
=
error
;
if
(
!
sourceName
&
&
!
sourceId
&
&
!
lineNumber
&
&
!
columnNumber
&
&
stack
)
{
sourceName
=
stack
[
0
]
.
filename
;
sourceId
=
stack
[
0
]
.
sourceId
;
lineNumber
=
stack
[
0
]
.
lineNumber
;
columnNumber
=
stack
[
0
]
.
columnNumber
;
}
const
pageError
=
{
errorMessage
:
createStringGrip
(
targetActor
error
.
errorMessage
)
errorMessageName
:
error
.
errorMessageName
exceptionDocURL
:
ErrorDocs
.
GetURL
(
error
)
sourceName
sourceId
:
getActorIdForInternalSourceId
(
targetActor
sourceId
)
lineText
lineNumber
columnNumber
category
:
error
.
category
innerWindowID
:
error
.
innerWindowID
timeStamp
:
error
.
timeStamp
warning
:
!
!
(
error
.
flags
&
error
.
warningFlag
)
error
:
!
(
error
.
flags
&
(
error
.
warningFlag
|
error
.
infoFlag
)
)
info
:
!
!
(
error
.
flags
&
error
.
infoFlag
)
private
:
error
.
isFromPrivateWindow
stacktrace
:
stack
notes
:
notesArray
chromeContext
:
error
.
isFromChromeContext
isPromiseRejection
:
error
.
isPromiseRejection
isForwardedFromContentProcess
:
error
.
isForwardedFromContentProcess
}
;
if
(
error
.
hasException
)
{
try
{
const
obj
=
makeDebuggeeValue
(
targetActor
error
.
exception
)
;
if
(
obj
?
.
class
!
=
=
"
DeadObject
"
)
{
pageError
.
exception
=
createValueGripForTarget
(
targetActor
obj
)
;
pageError
.
hasException
=
true
;
}
}
catch
(
e
)
{
}
}
return
{
pageError
resourceType
:
ERROR_MESSAGE
}
;
}
function
prepareStackForRemote
(
targetActor
errorStack
)
{
if
(
!
errorStack
|
|
(
Cu
&
&
Cu
.
isDeadWrapper
(
errorStack
)
)
)
{
return
null
;
}
const
stack
=
[
]
;
let
s
=
errorStack
;
while
(
s
)
{
stack
.
push
(
{
filename
:
s
.
source
sourceId
:
getActorIdForInternalSourceId
(
targetActor
s
.
sourceId
)
lineNumber
:
s
.
line
columnNumber
:
s
.
column
functionName
:
s
.
functionDisplayName
asyncCause
:
s
.
asyncCause
?
s
.
asyncCause
:
undefined
}
)
;
s
=
s
.
parent
|
|
s
.
asyncParent
;
}
return
stack
;
}
