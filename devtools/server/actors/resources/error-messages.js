"
use
strict
"
;
const
nsIConsoleListenerWatcher
=
require
(
"
devtools
/
server
/
actors
/
resources
/
utils
/
nsi
-
console
-
listener
-
watcher
"
)
;
const
{
DevToolsServer
}
=
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
const
ErrorDocs
=
require
(
"
devtools
/
server
/
actors
/
errordocs
"
)
;
const
{
createStringGrip
makeDebuggeeValue
createValueGripForTarget
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
{
getActorIdForInternalSourceId
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
dbg
-
source
"
)
;
const
{
WebConsoleUtils
}
=
require
(
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
)
;
const
{
TYPES
:
{
ERROR_MESSAGE
}
}
=
require
(
"
devtools
/
server
/
actors
/
resources
/
index
"
)
;
const
Targets
=
require
(
"
devtools
/
server
/
actors
/
targets
/
index
"
)
;
const
{
MESSAGE_CATEGORY
}
=
require
(
"
devtools
/
shared
/
constants
"
)
;
const
PLATFORM_SPECIFIC_CATEGORIES
=
[
"
XPConnect
JavaScript
"
"
component
javascript
"
"
chrome
javascript
"
"
chrome
registration
"
]
;
class
ErrorMessageWatcher
extends
nsIConsoleListenerWatcher
{
shouldHandleMessage
(
targetActor
message
isCachedMessage
=
false
)
{
if
(
!
(
message
instanceof
Ci
.
nsIScriptError
)
|
|
!
this
.
isCategoryAllowed
(
targetActor
message
.
category
)
|
|
message
.
sourceName
=
=
=
"
debugger
eager
eval
code
"
)
{
return
false
;
}
if
(
this
.
isProcessTarget
(
targetActor
)
)
{
const
isCachedFromPrivateWindow
=
isCachedMessage
&
&
message
.
isFromPrivateWindow
;
if
(
isCachedFromPrivateWindow
)
{
return
false
;
}
if
(
message
.
isForwardedFromContentProcess
)
{
return
false
;
}
if
(
targetActor
.
targetType
=
=
Targets
.
TYPES
.
PROCESS
&
&
message
.
innerWindowID
)
{
return
false
;
}
return
true
;
}
if
(
!
message
.
innerWindowID
)
{
return
false
;
}
const
ids
=
targetActor
.
windows
.
map
(
window
=
>
WebConsoleUtils
.
getInnerWindowId
(
window
)
)
;
return
ids
.
includes
(
message
.
innerWindowID
)
;
}
isCategoryAllowed
(
targetActor
category
)
{
if
(
!
category
|
|
category
=
=
=
MESSAGE_CATEGORY
.
CSS_PARSER
)
{
return
false
;
}
if
(
this
.
isProcessTarget
(
targetActor
)
)
{
return
true
;
}
if
(
targetActor
.
sessionContext
.
type
=
=
"
all
"
)
{
return
true
;
}
return
!
PLATFORM_SPECIFIC_CATEGORIES
.
includes
(
category
)
;
}
buildResource
(
targetActor
error
)
{
const
stack
=
this
.
prepareStackForRemote
(
targetActor
error
.
stack
)
;
let
lineText
=
error
.
sourceLine
;
if
(
lineText
&
&
lineText
.
length
>
DevToolsServer
.
LONG_STRING_INITIAL_LENGTH
)
{
lineText
=
lineText
.
substr
(
0
DevToolsServer
.
LONG_STRING_INITIAL_LENGTH
)
;
}
const
notesArray
=
this
.
prepareNotesForRemote
(
targetActor
error
.
notes
)
;
let
{
sourceName
sourceId
lineNumber
columnNumber
}
=
error
;
if
(
!
sourceName
&
&
!
sourceId
&
&
!
lineNumber
&
&
!
columnNumber
&
&
stack
)
{
sourceName
=
stack
[
0
]
.
filename
;
sourceId
=
stack
[
0
]
.
sourceId
;
lineNumber
=
stack
[
0
]
.
lineNumber
;
columnNumber
=
stack
[
0
]
.
columnNumber
;
}
const
pageError
=
{
errorMessage
:
createStringGrip
(
targetActor
error
.
errorMessage
)
errorMessageName
:
error
.
errorMessageName
exceptionDocURL
:
ErrorDocs
.
GetURL
(
error
)
sourceName
sourceId
:
getActorIdForInternalSourceId
(
targetActor
sourceId
)
lineText
lineNumber
columnNumber
category
:
error
.
category
innerWindowID
:
error
.
innerWindowID
timeStamp
:
error
.
microSecondTimeStamp
/
1000
warning
:
!
!
(
error
.
flags
&
error
.
warningFlag
)
error
:
!
(
error
.
flags
&
(
error
.
warningFlag
|
error
.
infoFlag
)
)
info
:
!
!
(
error
.
flags
&
error
.
infoFlag
)
private
:
error
.
isFromPrivateWindow
stacktrace
:
stack
notes
:
notesArray
chromeContext
:
error
.
isFromChromeContext
isPromiseRejection
:
error
.
isPromiseRejection
isForwardedFromContentProcess
:
error
.
isForwardedFromContentProcess
}
;
if
(
error
.
hasException
)
{
try
{
const
obj
=
makeDebuggeeValue
(
targetActor
error
.
exception
)
;
if
(
obj
?
.
class
!
=
=
"
DeadObject
"
)
{
pageError
.
exception
=
createValueGripForTarget
(
targetActor
obj
)
;
pageError
.
hasException
=
true
;
}
}
catch
(
e
)
{
}
}
return
{
pageError
resourceType
:
ERROR_MESSAGE
}
;
}
}
module
.
exports
=
ErrorMessageWatcher
;
