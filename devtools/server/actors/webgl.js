"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
ContentObserver
}
=
require
(
"
devtools
/
shared
/
content
-
observer
"
)
;
const
{
shaderSpec
programSpec
webGLSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
webgl
"
)
;
const
WEBGL_CONTEXT_NAMES
=
[
"
webgl
"
"
experimental
-
webgl
"
"
moz
-
webgl
"
]
;
const
PROGRAM_DEFAULT_TRAITS
=
0
;
const
PROGRAM_BLACKBOX_TRAIT
=
1
;
const
PROGRAM_HIGHLIGHT_TRAIT
=
2
;
var
ShaderActor
=
protocol
.
ActorClassWithSpec
(
shaderSpec
{
initialize
:
function
(
conn
program
shader
proxy
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
program
=
program
;
this
.
shader
=
shader
;
this
.
text
=
proxy
.
getShaderSource
(
shader
)
;
this
.
linkedProxy
=
proxy
;
}
getText
:
function
(
)
{
return
this
.
text
;
}
compile
:
function
(
text
)
{
const
{
linkedProxy
:
proxy
shader
program
}
=
this
;
const
oldText
=
this
.
text
;
const
newText
=
text
;
const
error
=
proxy
.
compileShader
(
program
shader
this
.
text
=
newText
)
;
if
(
error
.
compile
|
|
error
.
link
)
{
proxy
.
compileShader
(
program
shader
this
.
text
=
oldText
)
;
return
error
;
}
return
undefined
;
}
}
)
;
var
ProgramActor
=
protocol
.
ActorClassWithSpec
(
programSpec
{
initialize
:
function
(
conn
[
program
shaders
cache
proxy
]
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
_shaderActorsCache
=
{
vertex
:
null
fragment
:
null
}
;
this
.
program
=
program
;
this
.
shaders
=
shaders
;
this
.
linkedCache
=
cache
;
this
.
linkedProxy
=
proxy
;
}
get
ownerWindow
(
)
{
return
this
.
linkedCache
.
ownerWindow
;
}
get
ownerContext
(
)
{
return
this
.
linkedCache
.
ownerContext
;
}
getVertexShader
:
function
(
)
{
return
this
.
_getShaderActor
(
"
vertex
"
)
;
}
getFragmentShader
:
function
(
)
{
return
this
.
_getShaderActor
(
"
fragment
"
)
;
}
highlight
:
function
(
tint
)
{
this
.
linkedProxy
.
highlightTint
=
tint
;
this
.
linkedCache
.
setProgramTrait
(
this
.
program
PROGRAM_HIGHLIGHT_TRAIT
)
;
}
unhighlight
:
function
(
)
{
this
.
linkedCache
.
unsetProgramTrait
(
this
.
program
PROGRAM_HIGHLIGHT_TRAIT
)
;
}
blackbox
:
function
(
)
{
this
.
linkedCache
.
setProgramTrait
(
this
.
program
PROGRAM_BLACKBOX_TRAIT
)
;
}
unblackbox
:
function
(
)
{
this
.
linkedCache
.
unsetProgramTrait
(
this
.
program
PROGRAM_BLACKBOX_TRAIT
)
;
}
_getShaderActor
:
function
(
type
)
{
if
(
this
.
_shaderActorsCache
[
type
]
)
{
return
this
.
_shaderActorsCache
[
type
]
;
}
const
proxy
=
this
.
linkedProxy
;
const
shader
=
proxy
.
getShaderOfType
(
this
.
shaders
type
)
;
const
shaderActor
=
new
ShaderActor
(
this
.
conn
this
.
program
shader
proxy
)
;
this
.
_shaderActorsCache
[
type
]
=
shaderActor
;
return
this
.
_shaderActorsCache
[
type
]
;
}
}
)
;
exports
.
WebGLActor
=
protocol
.
ActorClassWithSpec
(
webGLSpec
{
initialize
:
function
(
conn
tabActor
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
tabActor
=
tabActor
;
this
.
_onGlobalCreated
=
this
.
_onGlobalCreated
.
bind
(
this
)
;
this
.
_onGlobalDestroyed
=
this
.
_onGlobalDestroyed
.
bind
(
this
)
;
this
.
_onProgramLinked
=
this
.
_onProgramLinked
.
bind
(
this
)
;
}
destroy
:
function
(
conn
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
conn
)
;
this
.
finalize
(
)
;
}
setup
:
function
(
{
reload
}
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
this
.
_programActorsCache
=
[
]
;
this
.
_webglObserver
=
new
WebGLObserver
(
)
;
this
.
tabActor
.
on
(
"
window
-
ready
"
this
.
_onGlobalCreated
)
;
this
.
tabActor
.
on
(
"
window
-
destroyed
"
this
.
_onGlobalDestroyed
)
;
EventEmitter
.
on
(
this
.
_webglObserver
"
program
-
linked
"
this
.
_onProgramLinked
)
;
if
(
reload
)
{
this
.
tabActor
.
window
.
location
.
reload
(
)
;
}
}
finalize
:
function
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
false
;
this
.
tabActor
.
off
(
"
window
-
ready
"
this
.
_onGlobalCreated
)
;
this
.
tabActor
.
off
(
"
window
-
destroyed
"
this
.
_onGlobalDestroyed
)
;
EventEmitter
.
off
(
this
.
_webglObserver
"
program
-
linked
"
this
.
_onProgramLinked
)
;
this
.
_programActorsCache
=
null
;
this
.
_contentObserver
=
null
;
this
.
_webglObserver
=
null
;
}
getPrograms
:
function
(
)
{
const
id
=
ContentObserver
.
GetInnerWindowID
(
this
.
tabActor
.
window
)
;
return
this
.
_programActorsCache
.
filter
(
e
=
>
e
.
ownerWindow
=
=
id
)
;
}
waitForFrame
:
function
(
)
{
const
deferred
=
defer
(
)
;
this
.
tabActor
.
window
.
requestAnimationFrame
(
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
getPixel
:
function
(
{
selector
position
}
)
{
const
{
x
y
}
=
position
;
const
canvas
=
this
.
tabActor
.
window
.
document
.
querySelector
(
selector
)
;
const
context
=
XPCNativeWrapper
.
unwrap
(
canvas
.
getContext
(
"
webgl
"
)
)
;
const
{
proxy
}
=
this
.
_webglObserver
.
for
(
context
)
;
const
height
=
canvas
.
height
;
let
buffer
=
new
this
.
tabActor
.
window
.
Uint8Array
(
4
)
;
buffer
=
XPCNativeWrapper
.
unwrap
(
buffer
)
;
proxy
.
readPixels
(
x
height
-
y
-
1
1
1
context
.
RGBA
context
.
UNSIGNED_BYTE
buffer
)
;
return
{
r
:
buffer
[
0
]
g
:
buffer
[
1
]
b
:
buffer
[
2
]
a
:
buffer
[
3
]
}
;
}
_getAllPrograms
:
function
(
)
{
return
this
.
_programActorsCache
;
}
_onGlobalCreated
:
function
(
{
id
window
isTopLevel
}
)
{
if
(
isTopLevel
)
{
WebGLInstrumenter
.
handle
(
window
this
.
_webglObserver
)
;
this
.
emit
(
"
global
-
created
"
id
)
;
}
}
_onGlobalDestroyed
:
function
(
{
id
isTopLevel
isFrozen
}
)
{
if
(
isTopLevel
&
&
!
isFrozen
)
{
removeFromArray
(
this
.
_programActorsCache
e
=
>
e
.
ownerWindow
=
=
id
)
;
this
.
_webglObserver
.
unregisterContextsForWindow
(
id
)
;
this
.
emit
(
"
global
-
destroyed
"
id
)
;
}
}
_onProgramLinked
:
function
(
.
.
.
args
)
{
const
programActor
=
new
ProgramActor
(
this
.
conn
args
)
;
this
.
_programActorsCache
.
push
(
programActor
)
;
this
.
emit
(
"
program
-
linked
"
programActor
)
;
}
}
)
;
var
WebGLInstrumenter
=
{
handle
:
function
(
window
observer
)
{
const
self
=
this
;
const
id
=
ContentObserver
.
GetInnerWindowID
(
window
)
;
const
canvasElem
=
XPCNativeWrapper
.
unwrap
(
window
.
HTMLCanvasElement
)
;
const
canvasPrototype
=
canvasElem
.
prototype
;
const
originalGetContext
=
canvasPrototype
.
getContext
;
canvasPrototype
.
getContext
=
function
(
name
options
)
{
const
context
=
originalGetContext
.
call
(
this
name
options
)
;
if
(
!
context
)
{
return
context
;
}
if
(
!
WEBGL_CONTEXT_NAMES
.
includes
(
name
)
)
{
return
context
;
}
if
(
observer
.
for
(
context
)
)
{
return
context
;
}
observer
.
registerContextForWindow
(
id
context
)
;
for
(
const
{
timing
callback
functions
}
of
self
.
_methods
)
{
for
(
const
func
of
functions
)
{
self
.
_instrument
(
observer
context
func
callback
timing
)
;
}
}
return
context
;
}
;
}
_instrument
:
function
(
observer
context
funcName
callbackName
=
[
]
timing
=
-
1
)
{
const
{
cache
proxy
}
=
observer
.
for
(
context
)
;
const
originalFunc
=
context
[
funcName
]
;
const
beforeFuncName
=
callbackName
[
0
]
|
|
funcName
;
const
afterFuncName
=
callbackName
[
1
]
|
|
callbackName
[
0
]
|
|
funcName
;
context
[
funcName
]
=
function
(
.
.
.
glArgs
)
{
if
(
timing
<
=
0
&
&
!
observer
.
suppressHandlers
)
{
const
glBreak
=
observer
[
beforeFuncName
]
(
glArgs
cache
proxy
)
;
if
(
glBreak
)
{
return
undefined
;
}
}
const
glResult
=
Cu
.
waiveXrays
(
Cu
.
unwaiveXrays
(
originalFunc
)
.
apply
(
this
glArgs
)
)
;
if
(
timing
>
=
0
&
&
!
observer
.
suppressHandlers
)
{
const
glBreak
=
observer
[
afterFuncName
]
(
glArgs
glResult
cache
proxy
)
;
if
(
glBreak
)
{
return
undefined
;
}
}
return
glResult
;
}
;
}
_methods
:
[
{
timing
:
1
functions
:
[
"
linkProgram
"
"
getAttribLocation
"
"
getUniformLocation
"
]
}
{
timing
:
-
1
callback
:
[
"
toggleVertexAttribArray
"
]
functions
:
[
"
enableVertexAttribArray
"
"
disableVertexAttribArray
"
]
}
{
timing
:
-
1
callback
:
[
"
attribute_
"
]
functions
:
[
"
vertexAttrib1f
"
"
vertexAttrib2f
"
"
vertexAttrib3f
"
"
vertexAttrib4f
"
"
vertexAttrib1fv
"
"
vertexAttrib2fv
"
"
vertexAttrib3fv
"
"
vertexAttrib4fv
"
"
vertexAttribPointer
"
]
}
{
timing
:
-
1
callback
:
[
"
uniform_
"
]
functions
:
[
"
uniform1i
"
"
uniform2i
"
"
uniform3i
"
"
uniform4i
"
"
uniform1f
"
"
uniform2f
"
"
uniform3f
"
"
uniform4f
"
"
uniform1iv
"
"
uniform2iv
"
"
uniform3iv
"
"
uniform4iv
"
"
uniform1fv
"
"
uniform2fv
"
"
uniform3fv
"
"
uniform4fv
"
"
uniformMatrix2fv
"
"
uniformMatrix3fv
"
"
uniformMatrix4fv
"
]
}
{
timing
:
-
1
functions
:
[
"
useProgram
"
"
enable
"
"
disable
"
"
blendColor
"
"
blendEquation
"
"
blendEquationSeparate
"
"
blendFunc
"
"
blendFuncSeparate
"
]
}
{
timing
:
0
callback
:
[
"
beforeDraw_
"
"
afterDraw_
"
]
functions
:
[
"
drawArrays
"
"
drawElements
"
]
}
]
}
;
function
WebGLObserver
(
)
{
this
.
_contexts
=
new
Map
(
)
;
}
WebGLObserver
.
prototype
=
{
_contexts
:
null
registerContextForWindow
:
function
(
id
context
)
{
const
cache
=
new
WebGLCache
(
id
context
)
;
const
proxy
=
new
WebGLProxy
(
id
context
cache
this
)
;
cache
.
refreshState
(
proxy
)
;
this
.
_contexts
.
set
(
context
{
ownerWindow
:
id
cache
:
cache
proxy
:
proxy
}
)
;
}
unregisterContextsForWindow
:
function
(
id
)
{
removeFromMap
(
this
.
_contexts
e
=
>
e
.
ownerWindow
=
=
id
)
;
}
for
:
function
(
context
)
{
return
this
.
_contexts
.
get
(
context
)
;
}
suppressHandlers
:
false
linkProgram
:
function
(
glArgs
glResult
cache
proxy
)
{
const
program
=
glArgs
[
0
]
;
const
shaders
=
proxy
.
getAttachedShaders
(
program
)
;
cache
.
addProgram
(
program
PROGRAM_DEFAULT_TRAITS
)
;
EventEmitter
.
emit
(
this
"
program
-
linked
"
program
shaders
cache
proxy
)
;
}
getAttribLocation
:
function
(
glArgs
glResult
cache
)
{
if
(
glResult
<
0
)
{
return
;
}
const
[
program
name
]
=
glArgs
;
cache
.
addAttribute
(
program
name
glResult
)
;
}
getUniformLocation
:
function
(
glArgs
glResult
cache
)
{
if
(
!
glResult
)
{
return
;
}
const
[
program
name
]
=
glArgs
;
cache
.
addUniform
(
program
name
glResult
)
;
}
toggleVertexAttribArray
:
function
(
glArgs
cache
)
{
glArgs
[
0
]
=
cache
.
getCurrentAttributeLocation
(
glArgs
[
0
]
)
;
return
glArgs
[
0
]
<
0
;
}
attribute_
:
function
(
glArgs
cache
)
{
glArgs
[
0
]
=
cache
.
getCurrentAttributeLocation
(
glArgs
[
0
]
)
;
return
glArgs
[
0
]
<
0
;
}
uniform_
:
function
(
glArgs
cache
)
{
glArgs
[
0
]
=
cache
.
getCurrentUniformLocation
(
glArgs
[
0
]
)
;
return
!
glArgs
[
0
]
;
}
useProgram
:
function
(
glArgs
cache
)
{
cache
.
currentProgram
=
glArgs
[
0
]
;
}
enable
:
function
(
glArgs
cache
)
{
cache
.
currentState
[
glArgs
[
0
]
]
=
true
;
}
disable
:
function
(
glArgs
cache
)
{
cache
.
currentState
[
glArgs
[
0
]
]
=
false
;
}
blendColor
:
function
(
glArgs
cache
)
{
const
blendColor
=
cache
.
currentState
.
blendColor
;
blendColor
[
0
]
=
glArgs
[
0
]
;
blendColor
[
1
]
=
glArgs
[
1
]
;
blendColor
[
2
]
=
glArgs
[
2
]
;
blendColor
[
3
]
=
glArgs
[
3
]
;
}
blendEquation
:
function
(
glArgs
cache
)
{
const
state
=
cache
.
currentState
;
state
.
blendEquationRgb
=
state
.
blendEquationAlpha
=
glArgs
[
0
]
;
}
blendEquationSeparate
:
function
(
glArgs
cache
)
{
const
state
=
cache
.
currentState
;
state
.
blendEquationRgb
=
glArgs
[
0
]
;
state
.
blendEquationAlpha
=
glArgs
[
1
]
;
}
blendFunc
:
function
(
glArgs
cache
)
{
const
state
=
cache
.
currentState
;
state
.
blendSrcRgb
=
state
.
blendSrcAlpha
=
glArgs
[
0
]
;
state
.
blendDstRgb
=
state
.
blendDstAlpha
=
glArgs
[
1
]
;
}
blendFuncSeparate
:
function
(
glArgs
cache
)
{
const
state
=
cache
.
currentState
;
state
.
blendSrcRgb
=
glArgs
[
0
]
;
state
.
blendDstRgb
=
glArgs
[
1
]
;
state
.
blendSrcAlpha
=
glArgs
[
2
]
;
state
.
blendDstAlpha
=
glArgs
[
3
]
;
}
beforeDraw_
:
function
(
glArgs
cache
proxy
)
{
const
traits
=
cache
.
currentProgramTraits
;
if
(
traits
&
PROGRAM_BLACKBOX_TRAIT
)
{
return
true
;
}
if
(
traits
&
PROGRAM_HIGHLIGHT_TRAIT
)
{
proxy
.
enableHighlighting
(
)
;
}
return
false
;
}
afterDraw_
:
function
(
glArgs
glResult
cache
proxy
)
{
const
traits
=
cache
.
currentProgramTraits
;
if
(
traits
&
PROGRAM_HIGHLIGHT_TRAIT
)
{
proxy
.
disableHighlighting
(
)
;
}
}
}
;
function
WebGLCache
(
id
context
)
{
this
.
_id
=
id
;
this
.
_gl
=
context
;
this
.
_programs
=
new
Map
(
)
;
this
.
currentState
=
{
}
;
}
WebGLCache
.
prototype
=
{
_id
:
0
_gl
:
null
_programs
:
null
_currentProgramInfo
:
null
_currentAttributesMap
:
null
_currentUniformsMap
:
null
get
ownerWindow
(
)
{
return
this
.
_id
;
}
get
ownerContext
(
)
{
return
this
.
_gl
;
}
currentState
:
null
refreshState
:
function
(
proxy
)
{
const
gl
=
this
.
_gl
;
const
s
=
this
.
currentState
;
s
[
gl
.
BLEND
]
=
proxy
.
isEnabled
(
"
BLEND
"
)
;
s
.
blendColor
=
proxy
.
getParameter
(
"
BLEND_COLOR
"
)
;
s
.
blendEquationRgb
=
proxy
.
getParameter
(
"
BLEND_EQUATION_RGB
"
)
;
s
.
blendEquationAlpha
=
proxy
.
getParameter
(
"
BLEND_EQUATION_ALPHA
"
)
;
s
.
blendSrcRgb
=
proxy
.
getParameter
(
"
BLEND_SRC_RGB
"
)
;
s
.
blendSrcAlpha
=
proxy
.
getParameter
(
"
BLEND_SRC_ALPHA
"
)
;
s
.
blendDstRgb
=
proxy
.
getParameter
(
"
BLEND_DST_RGB
"
)
;
s
.
blendDstAlpha
=
proxy
.
getParameter
(
"
BLEND_DST_ALPHA
"
)
;
}
addProgram
:
function
(
program
traits
)
{
this
.
_programs
.
set
(
program
{
traits
:
traits
attributes
:
[
]
uniforms
:
new
Map
(
)
}
)
;
}
setProgramTrait
:
function
(
program
trait
)
{
this
.
_programs
.
get
(
program
)
.
traits
|
=
trait
;
}
unsetProgramTrait
:
function
(
program
trait
)
{
this
.
_programs
.
get
(
program
)
.
traits
&
=
~
trait
;
}
set
currentProgram
(
program
)
{
const
programInfo
=
this
.
_programs
.
get
(
program
)
;
if
(
programInfo
=
=
null
)
{
return
;
}
this
.
_currentProgramInfo
=
programInfo
;
this
.
_currentAttributesMap
=
programInfo
.
attributes
;
this
.
_currentUniformsMap
=
programInfo
.
uniforms
;
}
get
currentProgramTraits
(
)
{
return
this
.
_currentProgramInfo
.
traits
;
}
addAttribute
:
function
(
program
name
value
)
{
this
.
_programs
.
get
(
program
)
.
attributes
[
value
]
=
{
name
:
name
value
:
value
}
;
}
addUniform
:
function
(
program
name
value
)
{
this
.
_programs
.
get
(
program
)
.
uniforms
.
set
(
new
XPCNativeWrapper
(
value
)
{
name
:
name
value
:
value
}
)
;
}
updateAttributesForProgram
:
function
(
program
)
{
const
attributes
=
this
.
_programs
.
get
(
program
)
.
attributes
;
for
(
const
attribute
of
attributes
)
{
attribute
.
value
=
this
.
_gl
.
getAttribLocation
(
program
attribute
.
name
)
;
}
}
updateUniformsForProgram
:
function
(
program
)
{
const
uniforms
=
this
.
_programs
.
get
(
program
)
.
uniforms
;
for
(
const
[
uniform
]
of
uniforms
)
{
uniform
.
value
=
this
.
_gl
.
getUniformLocation
(
program
uniform
.
name
)
;
}
}
getCurrentAttributeLocation
:
function
(
initialValue
)
{
const
attributes
=
this
.
_currentAttributesMap
;
const
currentInfo
=
attributes
?
attributes
[
initialValue
]
:
null
;
return
currentInfo
?
currentInfo
.
value
:
initialValue
;
}
getCurrentUniformLocation
:
function
(
initialValue
)
{
const
uniforms
=
this
.
_currentUniformsMap
;
const
currentInfo
=
uniforms
?
uniforms
.
get
(
initialValue
)
:
null
;
return
currentInfo
?
currentInfo
.
value
:
initialValue
;
}
}
;
function
WebGLProxy
(
id
context
cache
observer
)
{
this
.
_id
=
id
;
this
.
_gl
=
context
;
this
.
_cache
=
cache
;
this
.
_observer
=
observer
;
const
exports
=
[
"
isEnabled
"
"
getParameter
"
"
getAttachedShaders
"
"
getShaderSource
"
"
getShaderOfType
"
"
compileShader
"
"
enableHighlighting
"
"
disableHighlighting
"
"
readPixels
"
]
;
exports
.
forEach
(
e
=
>
{
this
[
e
]
=
(
.
.
.
args
)
=
>
this
.
_call
(
e
args
)
;
}
)
;
}
WebGLProxy
.
prototype
=
{
_id
:
0
_gl
:
null
_cache
:
null
_observer
:
null
get
ownerWindow
(
)
{
return
this
.
_id
;
}
get
ownerContext
(
)
{
return
this
.
_gl
;
}
_isEnabled
:
function
(
name
)
{
return
this
.
_gl
.
isEnabled
(
this
.
_gl
[
name
]
)
;
}
_getParameter
:
function
(
name
)
{
return
this
.
_gl
.
getParameter
(
this
.
_gl
[
name
]
)
;
}
_getRenderbufferParameter
:
function
(
name
)
{
if
(
!
this
.
_getParameter
(
"
RENDERBUFFER_BINDING
"
)
)
{
return
null
;
}
const
gl
=
this
.
_gl
;
return
gl
.
getRenderbufferParameter
(
gl
.
RENDERBUFFER
gl
[
name
]
)
;
}
_getFramebufferAttachmentParameter
(
type
name
=
"
FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
"
)
{
if
(
!
this
.
_getParameter
(
"
FRAMEBUFFER_BINDING
"
)
)
{
return
null
;
}
const
gl
=
this
.
_gl
;
return
gl
.
getFramebufferAttachmentParameter
(
gl
.
FRAMEBUFFER
gl
[
type
]
gl
[
name
]
)
;
}
_getAttachedShaders
:
function
(
program
)
{
return
this
.
_gl
.
getAttachedShaders
(
program
)
;
}
_getShaderSource
:
function
(
shader
)
{
return
this
.
_gl
.
getShaderSource
(
shader
)
;
}
_getShaderOfType
:
function
(
shaders
type
)
{
const
gl
=
this
.
_gl
;
const
shaderTypeEnum
=
{
vertex
:
gl
.
VERTEX_SHADER
fragment
:
gl
.
FRAGMENT_SHADER
}
[
type
]
;
for
(
const
shader
of
shaders
)
{
if
(
gl
.
getShaderParameter
(
shader
gl
.
SHADER_TYPE
)
=
=
shaderTypeEnum
)
{
return
shader
;
}
}
return
null
;
}
_compileShader
:
function
(
program
shader
text
)
{
const
gl
=
this
.
_gl
;
gl
.
shaderSource
(
shader
text
)
;
gl
.
compileShader
(
shader
)
;
gl
.
linkProgram
(
program
)
;
const
error
=
{
compile
:
"
"
link
:
"
"
}
;
if
(
!
gl
.
getShaderParameter
(
shader
gl
.
COMPILE_STATUS
)
)
{
error
.
compile
=
gl
.
getShaderInfoLog
(
shader
)
;
}
if
(
!
gl
.
getProgramParameter
(
program
gl
.
LINK_STATUS
)
)
{
error
.
link
=
gl
.
getShaderInfoLog
(
shader
)
;
}
this
.
_cache
.
updateAttributesForProgram
(
program
)
;
this
.
_cache
.
updateUniformsForProgram
(
program
)
;
return
error
;
}
_enableHighlighting
:
function
(
)
{
const
gl
=
this
.
_gl
;
const
hasFramebuffer
=
this
.
_getParameter
(
"
FRAMEBUFFER_BINDING
"
)
;
const
hasRenderbuffer
=
this
.
_getParameter
(
"
RENDERBUFFER_BINDING
"
)
;
if
(
hasFramebuffer
&
&
!
hasRenderbuffer
)
{
return
;
}
const
writesDepth
=
this
.
_getFramebufferAttachmentParameter
(
"
DEPTH_ATTACHMENT
"
)
;
const
writesStencil
=
this
.
_getFramebufferAttachmentParameter
(
"
STENCIL_ATTACHMENT
"
)
;
if
(
writesDepth
|
|
writesStencil
)
{
return
;
}
gl
.
enable
(
gl
.
BLEND
)
;
gl
.
blendColor
.
apply
(
gl
this
.
highlightTint
)
;
gl
.
blendEquation
(
gl
.
FUNC_ADD
)
;
gl
.
blendFunc
(
gl
.
CONSTANT_COLOR
gl
.
ONE_MINUS_SRC_ALPHA
gl
.
CONSTANT_COLOR
gl
.
ZERO
)
;
this
.
wasHighlighting
=
true
;
}
_disableHighlighting
:
function
(
)
{
const
gl
=
this
.
_gl
;
const
s
=
this
.
_cache
.
currentState
;
gl
[
s
[
gl
.
BLEND
]
?
"
enable
"
:
"
disable
"
]
(
gl
.
BLEND
)
;
gl
.
blendColor
.
apply
(
gl
s
.
blendColor
)
;
gl
.
blendEquationSeparate
(
s
.
blendEquationRgb
s
.
blendEquationAlpha
)
;
gl
.
blendFuncSeparate
(
s
.
blendSrcRgb
s
.
blendDstRgb
s
.
blendSrcAlpha
s
.
blendDstAlpha
)
;
}
_readPixels
:
function
(
x
y
w
h
format
type
buffer
)
{
this
.
_gl
.
readPixels
(
x
y
w
h
format
type
buffer
)
;
}
highlightTint
:
[
0
0
0
0
]
_call
:
function
(
funcName
args
)
{
const
prevState
=
this
.
_observer
.
suppressHandlers
;
this
.
_observer
.
suppressHandlers
=
true
;
const
result
=
this
[
"
_
"
+
funcName
]
.
apply
(
this
args
)
;
this
.
_observer
.
suppressHandlers
=
prevState
;
return
result
;
}
}
;
function
removeFromMap
(
map
predicate
)
{
for
(
const
[
key
value
]
of
map
)
{
if
(
predicate
(
value
)
)
{
map
.
delete
(
key
)
;
}
}
}
function
removeFromArray
(
array
predicate
)
{
for
(
let
i
=
0
;
i
<
array
.
length
;
)
{
if
(
predicate
(
array
[
i
]
)
)
{
array
.
splice
(
i
1
)
;
}
else
{
i
+
+
;
}
}
}
