"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
pageStyleSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
page
-
style
.
js
"
)
;
const
{
getCSSLexer
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
css
/
lexer
.
js
"
)
;
const
{
LongStringActor
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
string
.
js
"
)
;
const
TrackChangeEmitter
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
track
-
change
-
emitter
.
js
"
)
;
const
{
style
:
{
ELEMENT_STYLE
}
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
constants
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
StyleRuleActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
style
-
rule
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getFontPreviewData
"
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
style
-
utils
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
resource
:
/
/
devtools
/
server
/
actors
/
inspector
/
css
-
logic
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
SharedCssLogic
"
"
resource
:
/
/
devtools
/
shared
/
inspector
/
css
-
logic
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
getDefinedGeometryProperties
"
"
resource
:
/
/
devtools
/
server
/
actors
/
highlighters
/
geometry
-
editor
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
UPDATE_GENERAL
"
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
stylesheets
-
manager
.
js
"
true
)
;
loader
.
lazyGetter
(
this
"
PSEUDO_ELEMENTS
"
(
)
=
>
{
return
InspectorUtils
.
getCSSPseudoElementNames
(
)
;
}
)
;
loader
.
lazyGetter
(
this
"
FONT_VARIATIONS_ENABLED
"
(
)
=
>
{
return
Services
.
prefs
.
getBoolPref
(
"
layout
.
css
.
font
-
variations
.
enabled
"
)
;
}
)
;
const
NORMAL_FONT_WEIGHT
=
400
;
const
BOLD_FONT_WEIGHT
=
700
;
class
PageStyleActor
extends
Actor
{
constructor
(
inspector
)
{
super
(
inspector
.
conn
pageStyleSpec
)
;
this
.
inspector
=
inspector
;
if
(
!
this
.
inspector
.
walker
)
{
throw
Error
(
"
The
inspector
'
s
WalkerActor
must
be
created
before
"
+
"
creating
a
PageStyleActor
.
"
)
;
}
this
.
walker
=
inspector
.
walker
;
this
.
cssLogic
=
new
CssLogic
(
)
;
this
.
refMap
=
new
Map
(
)
;
this
.
selectedElement
=
null
;
this
.
styleElements
=
new
WeakMap
(
)
;
this
.
onFrameUnload
=
this
.
onFrameUnload
.
bind
(
this
)
;
this
.
inspector
.
targetActor
.
on
(
"
will
-
navigate
"
this
.
onFrameUnload
)
;
this
.
_observedRules
=
[
]
;
this
.
_styleApplied
=
this
.
_styleApplied
.
bind
(
this
)
;
this
.
styleSheetsManager
=
this
.
inspector
.
targetActor
.
getStyleSheetsManager
(
)
;
this
.
_onStylesheetUpdated
=
this
.
_onStylesheetUpdated
.
bind
(
this
)
;
this
.
styleSheetsManager
.
on
(
"
stylesheet
-
updated
"
this
.
_onStylesheetUpdated
)
;
}
destroy
(
)
{
if
(
!
this
.
walker
)
{
return
;
}
super
.
destroy
(
)
;
this
.
inspector
.
targetActor
.
off
(
"
will
-
navigate
"
this
.
onFrameUnload
)
;
this
.
inspector
=
null
;
this
.
walker
=
null
;
this
.
refMap
=
null
;
this
.
selectedElement
=
null
;
this
.
cssLogic
=
null
;
this
.
styleElements
=
null
;
this
.
_observedRules
=
[
]
;
}
get
ownerWindow
(
)
{
return
this
.
inspector
.
targetActor
.
window
;
}
form
(
)
{
const
CSS
=
this
.
inspector
.
targetActor
.
window
.
CSS
;
return
{
actor
:
this
.
actorID
traits
:
{
fontStretchLevel4
:
CSS
.
supports
(
"
font
-
stretch
:
100
%
"
)
fontStyleLevel4
:
CSS
.
supports
(
"
font
-
style
:
oblique
20deg
"
)
fontVariations
:
FONT_VARIATIONS_ENABLED
fontWeightLevel4
:
CSS
.
supports
(
"
font
-
weight
:
1
"
)
&
&
CSS
.
supports
(
"
font
-
stretch
:
100
%
"
)
}
}
;
}
_styleApplied
(
kind
styleSheet
)
{
this
.
cssLogic
.
reset
(
)
;
if
(
kind
=
=
=
UPDATE_GENERAL
)
{
this
.
emit
(
"
stylesheet
-
updated
"
)
;
}
}
_styleRef
(
item
)
{
if
(
this
.
refMap
.
has
(
item
)
)
{
return
this
.
refMap
.
get
(
item
)
;
}
const
actor
=
new
StyleRuleActor
(
this
item
)
;
this
.
manage
(
actor
)
;
this
.
refMap
.
set
(
item
actor
)
;
return
actor
;
}
updateStyleRef
(
oldItem
item
actor
)
{
this
.
refMap
.
delete
(
oldItem
)
;
this
.
refMap
.
set
(
item
actor
)
;
}
getRule
(
ruleId
)
{
let
match
=
null
;
for
(
const
actor
of
this
.
refMap
.
values
(
)
)
{
if
(
actor
.
actorID
=
=
=
ruleId
)
{
match
=
actor
;
continue
;
}
}
return
match
;
}
getComputed
(
node
options
)
{
const
ret
=
Object
.
create
(
null
)
;
this
.
cssLogic
.
sourceFilter
=
options
.
filter
|
|
SharedCssLogic
.
FILTER
.
UA
;
this
.
cssLogic
.
highlight
(
node
.
rawNode
)
;
const
computed
=
this
.
cssLogic
.
computedStyle
|
|
[
]
;
Array
.
prototype
.
forEach
.
call
(
computed
name
=
>
{
if
(
Array
.
isArray
(
options
.
filterProperties
)
&
&
!
options
.
filterProperties
.
includes
(
name
)
)
{
return
;
}
ret
[
name
]
=
{
value
:
computed
.
getPropertyValue
(
name
)
priority
:
computed
.
getPropertyPriority
(
name
)
|
|
undefined
}
;
}
)
;
if
(
options
.
markMatched
|
|
options
.
onlyMatched
)
{
const
matched
=
this
.
cssLogic
.
hasMatchedSelectors
(
Object
.
keys
(
ret
)
)
;
for
(
const
key
in
ret
)
{
if
(
matched
[
key
]
)
{
ret
[
key
]
.
matched
=
options
.
markMatched
?
true
:
undefined
;
}
else
if
(
options
.
onlyMatched
)
{
delete
ret
[
key
]
;
}
}
}
return
ret
;
}
getAllUsedFontFaces
(
options
)
{
const
windows
=
this
.
inspector
.
targetActor
.
windows
;
let
fontsList
=
[
]
;
for
(
const
win
of
windows
)
{
const
node
=
win
.
document
.
body
?
win
.
document
.
body
:
win
.
document
.
documentElement
;
fontsList
=
[
.
.
.
fontsList
.
.
.
this
.
getUsedFontFaces
(
node
options
)
]
;
}
return
fontsList
;
}
getUsedFontFaces
(
node
options
)
{
const
actualNode
=
node
.
rawNode
|
|
node
;
const
contentDocument
=
actualNode
.
ownerDocument
;
const
rng
=
contentDocument
.
createRange
(
)
;
const
isPseudoElement
=
Boolean
(
CssLogic
.
getBindingElementAndPseudo
(
actualNode
)
.
pseudo
)
;
if
(
isPseudoElement
)
{
rng
.
selectNodeContents
(
actualNode
)
;
}
else
{
rng
.
selectNode
(
actualNode
)
;
}
const
fonts
=
InspectorUtils
.
getUsedFontFaces
(
rng
)
;
const
fontsArray
=
[
]
;
for
(
let
i
=
0
;
i
<
fonts
.
length
;
i
+
+
)
{
const
font
=
fonts
[
i
]
;
const
fontFace
=
{
name
:
font
.
name
CSSFamilyName
:
font
.
CSSFamilyName
CSSGeneric
:
font
.
CSSGeneric
|
|
null
srcIndex
:
font
.
srcIndex
URI
:
font
.
URI
format
:
font
.
format
localName
:
font
.
localName
metadata
:
font
.
metadata
}
;
if
(
font
.
rule
)
{
const
styleActor
=
new
StyleRuleActor
(
this
font
.
rule
)
;
this
.
manage
(
styleActor
)
;
fontFace
.
rule
=
styleActor
;
fontFace
.
ruleText
=
font
.
rule
.
cssText
;
}
let
weight
=
NORMAL_FONT_WEIGHT
style
=
"
"
;
if
(
font
.
rule
)
{
weight
=
font
.
rule
.
style
.
getPropertyValue
(
"
font
-
weight
"
)
|
|
NORMAL_FONT_WEIGHT
;
if
(
weight
=
=
"
bold
"
)
{
weight
=
BOLD_FONT_WEIGHT
;
}
else
if
(
weight
=
=
"
normal
"
)
{
weight
=
NORMAL_FONT_WEIGHT
;
}
style
=
font
.
rule
.
style
.
getPropertyValue
(
"
font
-
style
"
)
|
|
"
"
;
}
fontFace
.
weight
=
weight
;
fontFace
.
style
=
style
;
if
(
options
.
includePreviews
)
{
const
opts
=
{
previewText
:
options
.
previewText
previewFontSize
:
options
.
previewFontSize
fontStyle
:
weight
+
"
"
+
style
fillStyle
:
options
.
previewFillStyle
}
;
const
{
dataURL
size
}
=
getFontPreviewData
(
font
.
CSSFamilyName
contentDocument
opts
)
;
fontFace
.
preview
=
{
data
:
new
LongStringActor
(
this
.
conn
dataURL
)
size
}
;
}
if
(
options
.
includeVariations
&
&
FONT_VARIATIONS_ENABLED
)
{
fontFace
.
variationAxes
=
font
.
getVariationAxes
(
)
;
fontFace
.
variationInstances
=
font
.
getVariationInstances
(
)
;
}
fontsArray
.
push
(
fontFace
)
;
}
fontsArray
.
sort
(
function
(
a
b
)
{
return
a
.
weight
>
b
.
weight
?
1
:
-
1
;
}
)
;
fontsArray
.
sort
(
function
(
a
b
)
{
if
(
a
.
CSSFamilyName
=
=
b
.
CSSFamilyName
)
{
return
0
;
}
return
a
.
CSSFamilyName
>
b
.
CSSFamilyName
?
1
:
-
1
;
}
)
;
fontsArray
.
sort
(
function
(
a
b
)
{
if
(
(
a
.
rule
&
&
b
.
rule
)
|
|
(
!
a
.
rule
&
&
!
b
.
rule
)
)
{
return
0
;
}
return
!
a
.
rule
&
&
b
.
rule
?
1
:
-
1
;
}
)
;
return
fontsArray
;
}
getMatchedSelectors
(
node
property
options
)
{
this
.
cssLogic
.
sourceFilter
=
options
.
filter
|
|
SharedCssLogic
.
FILTER
.
UA
;
this
.
cssLogic
.
highlight
(
node
.
rawNode
)
;
const
rules
=
new
Set
(
)
;
const
matched
=
[
]
;
const
propInfo
=
this
.
cssLogic
.
getPropertyInfo
(
property
)
;
for
(
const
selectorInfo
of
propInfo
.
matchedSelectors
)
{
const
cssRule
=
selectorInfo
.
selector
.
cssRule
;
const
domRule
=
cssRule
.
sourceElement
|
|
cssRule
.
domRule
;
const
rule
=
this
.
_styleRef
(
domRule
)
;
rules
.
add
(
rule
)
;
matched
.
push
(
{
rule
sourceText
:
this
.
getSelectorSource
(
selectorInfo
node
.
rawNode
)
selector
:
selectorInfo
.
selector
.
text
name
:
selectorInfo
.
property
value
:
selectorInfo
.
value
status
:
selectorInfo
.
status
}
)
;
}
this
.
_expandRules
(
rules
)
;
return
{
matched
rules
:
[
.
.
.
rules
]
}
;
}
getSelectorSource
(
selectorInfo
relativeTo
)
{
let
result
=
selectorInfo
.
selector
.
text
;
if
(
selectorInfo
.
inlineStyle
)
{
const
source
=
selectorInfo
.
sourceElement
;
if
(
source
=
=
=
relativeTo
)
{
result
=
"
this
"
;
}
else
{
result
=
CssLogic
.
getShortName
(
source
)
;
}
result
+
=
"
.
style
"
;
}
return
result
;
}
async
getApplied
(
node
options
)
{
this
.
_observedRules
=
[
]
;
this
.
selectedElement
=
node
.
rawNode
;
if
(
!
node
)
{
return
{
entries
:
[
]
}
;
}
this
.
cssLogic
.
highlight
(
node
.
rawNode
)
;
const
entries
=
this
.
getAppliedProps
(
node
this
.
_getAllElementRules
(
node
undefined
options
)
options
)
;
const
entryRules
=
new
Set
(
)
;
entries
.
forEach
(
entry
=
>
{
entryRules
.
add
(
entry
.
rule
)
;
}
)
;
for
(
const
rule
of
entryRules
)
{
try
{
await
rule
.
getAuthoredCssText
(
)
;
}
catch
(
ex
)
{
}
}
this
.
_observedRules
=
entryRules
;
return
{
entries
}
;
}
_hasInheritedProps
(
style
)
{
return
Array
.
prototype
.
some
.
call
(
style
prop
=
>
{
return
InspectorUtils
.
isInheritedProperty
(
prop
)
;
}
)
;
}
async
isPositionEditable
(
node
)
{
if
(
!
node
|
|
node
.
rawNode
.
nodeType
!
=
=
node
.
rawNode
.
ELEMENT_NODE
)
{
return
false
;
}
const
props
=
getDefinedGeometryProperties
(
node
.
rawNode
)
;
return
(
props
.
has
(
"
top
"
)
|
|
props
.
has
(
"
right
"
)
|
|
props
.
has
(
"
left
"
)
|
|
props
.
has
(
"
bottom
"
)
)
;
}
_getAllElementRules
(
node
inherited
options
)
{
const
{
bindingElement
pseudo
}
=
CssLogic
.
getBindingElementAndPseudo
(
node
.
rawNode
)
;
const
rules
=
[
]
;
if
(
!
bindingElement
|
|
!
bindingElement
.
style
)
{
return
rules
;
}
const
elementStyle
=
this
.
_styleRef
(
bindingElement
)
;
const
showElementStyles
=
!
inherited
&
&
!
pseudo
;
const
showInheritedStyles
=
inherited
&
&
this
.
_hasInheritedProps
(
bindingElement
.
style
)
;
const
rule
=
{
rule
:
elementStyle
pseudoElement
:
null
isSystem
:
false
inherited
:
false
}
;
if
(
showElementStyles
)
{
rules
.
push
(
rule
)
;
}
if
(
showInheritedStyles
)
{
rule
.
inherited
=
inherited
;
rules
.
push
(
rule
)
;
}
this
.
_getElementRules
(
bindingElement
pseudo
inherited
options
)
.
forEach
(
oneRule
=
>
{
oneRule
.
pseudoElement
=
null
;
rules
.
push
(
oneRule
)
;
}
)
;
if
(
showElementStyles
&
&
!
options
.
skipPseudo
)
{
for
(
const
readPseudo
of
PSEUDO_ELEMENTS
)
{
if
(
this
.
_pseudoIsRelevant
(
bindingElement
readPseudo
)
)
{
this
.
_getElementRules
(
bindingElement
readPseudo
inherited
options
)
.
forEach
(
oneRule
=
>
{
rules
.
push
(
oneRule
)
;
}
)
;
}
}
}
return
rules
;
}
_nodeIsTextfieldLike
(
node
)
{
if
(
node
.
nodeName
=
=
"
TEXTAREA
"
)
{
return
true
;
}
return
(
node
.
mozIsTextField
&
&
(
node
.
mozIsTextField
(
false
)
|
|
node
.
type
=
=
"
number
"
)
)
;
}
_nodeIsButtonLike
(
node
)
{
if
(
node
.
nodeName
=
=
"
BUTTON
"
)
{
return
true
;
}
return
(
node
.
nodeName
=
=
"
INPUT
"
&
&
[
"
submit
"
"
color
"
"
button
"
]
.
includes
(
node
.
type
)
)
;
}
_nodeIsListItem
(
node
)
{
const
display
=
CssLogic
.
getComputedStyle
(
node
)
.
getPropertyValue
(
"
display
"
)
;
return
display
.
split
(
"
"
)
.
includes
(
"
list
-
item
"
)
;
}
_pseudoIsRelevant
(
node
pseudo
)
{
switch
(
pseudo
)
{
case
"
:
:
after
"
:
case
"
:
:
before
"
:
case
"
:
:
first
-
letter
"
:
case
"
:
:
first
-
line
"
:
case
"
:
:
selection
"
:
return
true
;
case
"
:
:
highlight
"
:
return
false
;
case
"
:
:
marker
"
:
return
this
.
_nodeIsListItem
(
node
)
;
case
"
:
:
backdrop
"
:
return
node
.
matches
(
"
:
modal
"
)
;
case
"
:
:
cue
"
:
return
node
.
nodeName
=
=
"
VIDEO
"
;
case
"
:
:
file
-
selector
-
button
"
:
return
node
.
nodeName
=
=
"
INPUT
"
&
&
node
.
type
=
=
"
file
"
;
case
"
:
:
placeholder
"
:
case
"
:
:
-
moz
-
placeholder
"
:
return
this
.
_nodeIsTextfieldLike
(
node
)
;
case
"
:
:
-
moz
-
focus
-
inner
"
:
return
this
.
_nodeIsButtonLike
(
node
)
;
case
"
:
:
-
moz
-
meter
-
bar
"
:
return
node
.
nodeName
=
=
"
METER
"
;
case
"
:
:
-
moz
-
progress
-
bar
"
:
return
node
.
nodeName
=
=
"
PROGRESS
"
;
case
"
:
:
-
moz
-
color
-
swatch
"
:
return
node
.
nodeName
=
=
"
INPUT
"
&
&
node
.
type
=
=
"
color
"
;
case
"
:
:
-
moz
-
range
-
progress
"
:
case
"
:
:
-
moz
-
range
-
thumb
"
:
case
"
:
:
-
moz
-
range
-
track
"
:
return
node
.
nodeName
=
=
"
INPUT
"
&
&
node
.
type
=
=
"
range
"
;
default
:
throw
Error
(
"
Unhandled
pseudo
-
element
"
+
pseudo
)
;
}
}
_getElementRules
(
node
pseudo
inherited
options
)
{
const
domRules
=
InspectorUtils
.
getCSSStyleRules
(
node
pseudo
CssLogic
.
hasVisitedState
(
node
)
)
;
if
(
!
domRules
)
{
return
[
]
;
}
const
rules
=
[
]
;
for
(
let
i
=
domRules
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
domRule
=
domRules
[
i
]
;
const
isSystem
=
SharedCssLogic
.
isAgentStylesheet
(
domRule
.
parentStyleSheet
)
;
if
(
isSystem
&
&
options
.
filter
!
=
SharedCssLogic
.
FILTER
.
UA
)
{
continue
;
}
if
(
inherited
)
{
const
hasInherited
=
[
.
.
.
domRule
.
style
]
.
some
(
prop
=
>
InspectorUtils
.
isInheritedProperty
(
prop
)
)
;
if
(
!
hasInherited
)
{
continue
;
}
}
const
ruleActor
=
this
.
_styleRef
(
domRule
)
;
rules
.
push
(
{
rule
:
ruleActor
inherited
isSystem
pseudoElement
:
pseudo
}
)
;
}
return
rules
;
}
findEntryMatchingRule
(
node
filterRule
)
{
const
options
=
{
matchedSelectors
:
true
inherited
:
true
}
;
let
entries
=
[
]
;
let
parent
=
this
.
walker
.
parentNode
(
node
)
;
while
(
parent
&
&
parent
.
rawNode
.
nodeType
!
=
Node
.
DOCUMENT_NODE
)
{
entries
=
entries
.
concat
(
this
.
_getAllElementRules
(
parent
parent
options
)
)
;
parent
=
this
.
walker
.
parentNode
(
parent
)
;
}
return
entries
.
filter
(
entry
=
>
entry
.
rule
.
rawRule
=
=
=
filterRule
)
;
}
getAppliedProps
(
node
entries
options
)
{
if
(
options
.
inherited
)
{
let
parent
=
this
.
walker
.
parentNode
(
node
)
;
while
(
parent
&
&
parent
.
rawNode
.
nodeType
!
=
Node
.
DOCUMENT_NODE
)
{
entries
=
entries
.
concat
(
this
.
_getAllElementRules
(
parent
parent
options
)
)
;
parent
=
this
.
walker
.
parentNode
(
parent
)
;
}
}
if
(
options
.
matchedSelectors
)
{
for
(
const
entry
of
entries
)
{
if
(
entry
.
rule
.
type
=
=
=
ELEMENT_STYLE
)
{
continue
;
}
const
domRule
=
entry
.
rule
.
rawRule
;
const
desugaredSelectors
=
entry
.
rule
.
getDesugaredSelectors
(
)
;
const
element
=
entry
.
inherited
?
entry
.
inherited
.
rawNode
:
node
.
rawNode
;
const
{
bindingElement
pseudo
}
=
CssLogic
.
getBindingElementAndPseudo
(
element
)
;
const
relevantLinkVisited
=
CssLogic
.
hasVisitedState
(
bindingElement
)
;
entry
.
matchedDesugaredSelectors
=
[
]
;
for
(
let
i
=
0
;
i
<
desugaredSelectors
.
length
;
i
+
+
)
{
if
(
domRule
.
selectorMatchesElement
(
i
bindingElement
pseudo
relevantLinkVisited
)
)
{
entry
.
matchedDesugaredSelectors
.
push
(
desugaredSelectors
[
i
]
)
;
}
}
}
}
const
computedStyle
=
this
.
cssLogic
.
computedStyle
;
if
(
computedStyle
)
{
let
animationNames
=
computedStyle
.
animationName
.
split
(
"
"
)
;
animationNames
=
animationNames
.
map
(
name
=
>
name
.
trim
(
)
)
;
if
(
animationNames
)
{
for
(
const
keyframesRule
of
this
.
cssLogic
.
keyframesRules
)
{
if
(
animationNames
.
indexOf
(
keyframesRule
.
name
)
>
-
1
)
{
for
(
const
rule
of
keyframesRule
.
cssRules
)
{
entries
.
push
(
{
rule
:
this
.
_styleRef
(
rule
)
keyframes
:
this
.
_styleRef
(
keyframesRule
)
}
)
;
}
}
}
}
}
return
entries
;
}
_expandRules
(
ruleSet
)
{
for
(
const
rule
of
ruleSet
)
{
if
(
rule
.
rawRule
.
parentRule
)
{
const
parent
=
this
.
_styleRef
(
rule
.
rawRule
.
parentRule
)
;
if
(
!
ruleSet
.
has
(
parent
)
)
{
ruleSet
.
add
(
parent
)
;
}
}
}
}
getLayout
(
node
options
)
{
this
.
cssLogic
.
highlight
(
node
.
rawNode
)
;
const
layout
=
{
}
;
const
clientRect
=
node
.
rawNode
.
getBoundingClientRect
(
)
;
layout
.
width
=
parseFloat
(
clientRect
.
width
.
toPrecision
(
6
)
)
;
layout
.
height
=
parseFloat
(
clientRect
.
height
.
toPrecision
(
6
)
)
;
const
style
=
CssLogic
.
getComputedStyle
(
node
.
rawNode
)
;
for
(
const
prop
of
[
"
position
"
"
top
"
"
right
"
"
bottom
"
"
left
"
"
margin
-
top
"
"
margin
-
right
"
"
margin
-
bottom
"
"
margin
-
left
"
"
padding
-
top
"
"
padding
-
right
"
"
padding
-
bottom
"
"
padding
-
left
"
"
border
-
top
-
width
"
"
border
-
right
-
width
"
"
border
-
bottom
-
width
"
"
border
-
left
-
width
"
"
z
-
index
"
"
box
-
sizing
"
"
display
"
"
float
"
"
line
-
height
"
]
)
{
layout
[
prop
]
=
style
.
getPropertyValue
(
prop
)
;
}
if
(
options
.
autoMargins
)
{
layout
.
autoMargins
=
this
.
processMargins
(
this
.
cssLogic
)
;
}
for
(
const
i
in
this
.
map
)
{
const
property
=
this
.
map
[
i
]
.
property
;
this
.
map
[
i
]
.
value
=
parseFloat
(
style
.
getPropertyValue
(
property
)
)
;
}
return
layout
;
}
processMargins
(
cssLogic
)
{
const
margins
=
{
}
;
for
(
const
prop
of
[
"
top
"
"
bottom
"
"
left
"
"
right
"
]
)
{
const
info
=
cssLogic
.
getPropertyInfo
(
"
margin
-
"
+
prop
)
;
const
selectors
=
info
.
matchedSelectors
;
if
(
selectors
&
&
!
!
selectors
.
length
&
&
selectors
[
0
]
.
value
=
=
"
auto
"
)
{
margins
[
prop
]
=
"
auto
"
;
}
}
return
margins
;
}
onFrameUnload
(
)
{
this
.
styleElements
=
new
WeakMap
(
)
;
}
_onStylesheetUpdated
(
{
resourceId
updateKind
updates
=
{
}
}
)
{
if
(
updateKind
!
=
"
style
-
applied
"
)
{
return
;
}
const
kind
=
updates
.
event
.
kind
;
for
(
const
styleActor
of
[
.
.
.
this
.
refMap
.
values
(
)
]
)
{
if
(
!
styleActor
.
_parentSheet
)
{
continue
;
}
const
resId
=
this
.
styleSheetsManager
.
getStyleSheetResourceId
(
styleActor
.
_parentSheet
)
;
if
(
resId
=
=
=
resourceId
)
{
styleActor
.
onStyleApplied
(
kind
)
;
}
}
this
.
_styleApplied
(
kind
)
;
}
getNewAppliedProps
(
node
rule
)
{
const
ruleActor
=
this
.
_styleRef
(
rule
)
;
return
this
.
getAppliedProps
(
node
[
{
rule
:
ruleActor
}
]
{
matchedSelectors
:
true
}
)
;
}
async
addNewRule
(
node
pseudoClasses
)
{
let
sheet
=
null
;
const
doc
=
node
.
rawNode
.
ownerDocument
;
if
(
this
.
styleElements
.
has
(
doc
)
&
&
this
.
styleElements
.
get
(
doc
)
.
ownerNode
?
.
isConnected
)
{
sheet
=
this
.
styleElements
.
get
(
doc
)
;
}
else
{
sheet
=
await
this
.
styleSheetsManager
.
addStyleSheet
(
doc
)
;
this
.
styleElements
.
set
(
doc
sheet
)
;
}
const
cssRules
=
sheet
.
cssRules
;
const
rawNode
=
node
.
rawNode
;
const
classes
=
[
.
.
.
rawNode
.
classList
]
;
let
selector
;
if
(
rawNode
.
id
)
{
selector
=
"
#
"
+
CSS
.
escape
(
rawNode
.
id
)
;
}
else
if
(
classes
.
length
)
{
selector
=
"
.
"
+
classes
.
map
(
c
=
>
CSS
.
escape
(
c
)
)
.
join
(
"
.
"
)
;
}
else
{
selector
=
rawNode
.
localName
;
}
if
(
pseudoClasses
&
&
pseudoClasses
.
length
)
{
selector
+
=
pseudoClasses
.
join
(
"
"
)
;
}
const
index
=
sheet
.
insertRule
(
selector
+
"
{
}
"
cssRules
.
length
)
;
const
resourceId
=
this
.
styleSheetsManager
.
getStyleSheetResourceId
(
sheet
)
;
let
authoredText
=
await
this
.
styleSheetsManager
.
getText
(
resourceId
)
;
authoredText
+
=
"
\
n
"
+
selector
+
"
{
\
n
"
+
"
}
"
;
await
this
.
styleSheetsManager
.
setStyleSheetText
(
resourceId
authoredText
)
;
const
cssRule
=
sheet
.
cssRules
.
item
(
index
)
;
const
ruleActor
=
this
.
_styleRef
(
cssRule
)
;
TrackChangeEmitter
.
trackChange
(
{
.
.
.
ruleActor
.
metadata
type
:
"
rule
-
add
"
add
:
null
remove
:
null
selector
}
)
;
return
{
entries
:
this
.
getNewAppliedProps
(
node
cssRule
)
}
;
}
refreshObservedRules
(
rulesToForceRefresh
)
{
for
(
const
rule
of
this
.
_observedRules
)
{
const
force
=
rulesToForceRefresh
&
&
rulesToForceRefresh
.
includes
(
rule
)
;
rule
.
maybeRefresh
(
force
)
;
}
}
getAttributesInOwnerDocument
(
search
attributeType
node
)
{
if
(
!
search
)
{
throw
new
Error
(
"
search
is
mandatory
"
)
;
}
const
targetDocument
=
node
.
rawNode
.
ownerDocument
;
const
result
=
new
Set
(
)
;
const
lcSearch
=
search
.
toLowerCase
(
)
;
this
.
_collectAttributesFromDocumentDOM
(
result
lcSearch
attributeType
targetDocument
node
.
rawNode
)
;
this
.
_collectAttributesFromDocumentStyleSheets
(
result
lcSearch
attributeType
targetDocument
)
;
return
Array
.
from
(
result
)
.
sort
(
)
;
}
_collectAttributesFromDocumentDOM
(
result
search
attributeType
targetDocument
nodeRawNode
)
{
const
attributeSelectorPositionChar
=
attributeType
=
=
=
"
class
"
?
"
*
"
:
"
^
"
;
const
selector
=
[
{
attributeType
}
{
attributeSelectorPositionChar
}
=
{
search
}
i
]
;
const
matchingElements
=
targetDocument
.
querySelectorAll
(
selector
)
;
for
(
const
element
of
matchingElements
)
{
if
(
element
=
=
=
nodeRawNode
)
{
return
;
}
if
(
attributeType
=
=
=
"
class
"
)
{
for
(
const
cls
of
element
.
classList
)
{
if
(
!
result
.
has
(
cls
)
&
&
cls
.
toLowerCase
(
)
.
startsWith
(
search
)
)
{
result
.
add
(
cls
)
;
}
}
}
else
{
const
{
value
}
=
element
.
attributes
[
attributeType
]
;
result
.
add
(
value
)
;
}
}
}
_collectAttributesFromDocumentStyleSheets
(
result
search
attributeType
targetDocument
)
{
if
(
attributeType
!
=
=
"
class
"
&
&
attributeType
!
=
=
"
id
"
)
{
return
;
}
for
(
const
styleSheet
of
targetDocument
.
styleSheets
)
{
for
(
const
rule
of
styleSheet
.
rules
)
{
this
.
_collectAttributesFromRule
(
result
rule
search
attributeType
)
;
}
}
}
_collectAttributesFromRule
(
result
rule
search
attributeType
)
{
const
shouldRetrieveClasses
=
attributeType
=
=
=
"
class
"
;
const
shouldRetrieveIds
=
attributeType
=
=
=
"
id
"
;
const
{
selectorText
}
=
rule
;
if
(
!
selectorText
|
|
!
selectorText
.
toLowerCase
(
)
.
includes
(
search
)
)
{
return
;
}
const
parseForClasses
=
shouldRetrieveClasses
&
&
selectorText
.
toLowerCase
(
)
.
includes
(
.
{
search
}
)
;
const
parseForIds
=
shouldRetrieveIds
&
&
selectorText
.
toLowerCase
(
)
.
includes
(
#
{
search
}
)
;
if
(
!
parseForClasses
&
&
!
parseForIds
)
{
return
;
}
const
lexer
=
getCSSLexer
(
selectorText
)
;
let
token
;
while
(
(
token
=
lexer
.
nextToken
(
)
)
)
{
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
(
(
shouldRetrieveClasses
&
&
token
.
text
=
=
=
"
.
"
)
|
|
(
shouldRetrieveIds
&
&
token
.
text
=
=
=
"
#
"
)
)
)
{
token
=
lexer
.
nextToken
(
)
;
if
(
token
.
tokenType
=
=
=
"
ident
"
&
&
token
.
text
.
toLowerCase
(
)
.
startsWith
(
search
)
)
{
result
.
add
(
token
.
text
)
;
}
}
}
}
}
exports
.
PageStyleActor
=
PageStyleActor
;
