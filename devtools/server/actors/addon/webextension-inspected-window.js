"
use
strict
"
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
Cc
Ci
Cu
Cr
}
=
require
(
"
chrome
"
)
;
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
loader
.
lazyGetter
(
this
"
NodeActor
"
(
)
=
>
require
(
"
devtools
/
server
/
actors
/
inspector
/
node
"
)
.
NodeActor
true
)
;
const
{
webExtensionInspectedWindowSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
addon
/
webextension
-
inspected
-
window
"
)
;
const
{
WebExtensionPolicy
}
=
Cu
.
getGlobalForObject
(
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
)
;
const
deniedWarningDocuments
=
new
WeakSet
(
)
;
function
isSystemPrincipalWindow
(
window
)
{
return
window
.
document
.
nodePrincipal
.
isSystemPrincipal
;
}
function
createExceptionInfoResult
(
props
)
{
return
{
exceptionInfo
:
{
isError
:
true
code
:
"
E_PROTOCOLERROR
"
description
:
"
Unknown
Inspector
protocol
error
"
.
.
.
props
}
}
;
}
function
logAccessDeniedWarning
(
window
callerInfo
extensionPolicy
)
{
if
(
deniedWarningDocuments
.
has
(
window
.
document
)
)
{
return
;
}
deniedWarningDocuments
.
add
(
window
.
document
)
;
const
{
name
}
=
extensionPolicy
;
const
reportedURI
=
isSystemPrincipalWindow
(
window
)
?
Services
.
io
.
newURI
(
window
.
location
.
href
)
:
window
.
document
.
nodePrincipal
.
URI
;
const
error
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
const
msg
=
The
extension
"
{
name
}
"
is
not
allowed
to
access
{
reportedURI
.
spec
}
;
const
innerWindowId
=
window
.
windowUtils
;
const
errorFlag
=
0
;
let
{
url
lineNumber
}
=
callerInfo
;
const
callerURI
=
callerInfo
.
url
&
&
Services
.
io
.
newURI
(
callerInfo
.
url
)
;
if
(
callerURI
.
filePath
=
=
=
"
/
"
)
{
url
=
extensionPolicy
.
getURL
(
"
/
manifest
.
json
"
)
;
lineNumber
=
null
;
}
error
.
initWithWindowID
(
msg
url
lineNumber
0
0
errorFlag
"
webExtensions
"
innerWindowId
)
;
Services
.
console
.
logMessage
(
error
)
;
}
function
CustomizedReload
(
params
)
{
this
.
docShell
=
params
.
targetActor
.
window
.
docShell
;
this
.
docShell
.
QueryInterface
(
Ci
.
nsIWebProgress
)
;
this
.
inspectedWindowEval
=
params
.
inspectedWindowEval
;
this
.
callerInfo
=
params
.
callerInfo
;
this
.
ignoreCache
=
params
.
ignoreCache
;
this
.
injectedScript
=
params
.
injectedScript
;
this
.
userAgent
=
params
.
userAgent
;
this
.
customizedReloadWindows
=
new
WeakSet
(
)
;
}
CustomizedReload
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
get
window
(
)
{
return
this
.
docShell
.
DOMWindow
;
}
get
webNavigation
(
)
{
return
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
;
}
start
(
)
{
if
(
!
this
.
waitForReloadCompleted
)
{
this
.
waitForReloadCompleted
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
resolveReloadCompleted
=
resolve
;
this
.
rejectReloadCompleted
=
reject
;
if
(
this
.
userAgent
)
{
this
.
docShell
.
customUserAgent
=
this
.
userAgent
;
}
let
reloadFlags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
if
(
this
.
ignoreCache
)
{
reloadFlags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
;
}
try
{
if
(
this
.
injectedScript
)
{
Services
.
obs
.
addObserver
(
this
"
document
-
element
-
inserted
"
)
;
}
this
.
docShell
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
this
.
webNavigation
.
reload
(
reloadFlags
)
;
}
catch
(
err
)
{
this
.
stop
(
err
)
;
}
}
)
;
}
return
this
.
waitForReloadCompleted
;
}
observe
(
subject
topic
data
)
{
if
(
topic
!
=
=
"
document
-
element
-
inserted
"
)
{
return
;
}
const
document
=
subject
;
const
window
=
document
&
&
document
.
defaultView
;
if
(
!
document
|
|
!
document
.
location
|
|
!
window
)
{
return
;
}
const
subjectDocShell
=
window
.
docShell
;
if
(
window
=
=
this
.
window
)
{
this
.
customizedReloadWindows
.
add
(
window
)
;
}
else
if
(
subjectDocShell
.
sameTypeParent
)
{
const
parentWindow
=
subjectDocShell
.
sameTypeParent
.
domWindow
;
if
(
parentWindow
&
&
this
.
customizedReloadWindows
.
has
(
parentWindow
)
)
{
this
.
customizedReloadWindows
.
add
(
window
)
;
}
}
if
(
this
.
customizedReloadWindows
.
has
(
window
)
)
{
const
{
apiErrorResult
}
=
this
.
inspectedWindowEval
(
this
.
callerInfo
this
.
injectedScript
{
}
window
)
;
if
(
apiErrorResult
)
{
console
.
error
(
"
Unexpected
Error
in
injectedScript
during
inspectedWindow
.
reload
for
"
{
this
.
callerInfo
.
url
}
:
{
this
.
callerInfo
.
lineNumber
}
apiErrorResult
)
;
}
}
}
onStateChange
(
webProgress
request
state
status
)
{
if
(
webProgress
.
DOMWindow
!
=
=
this
.
window
)
{
return
;
}
if
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
if
(
status
=
=
Cr
.
NS_BINDING_ABORTED
)
{
const
url
=
this
.
window
.
location
.
href
;
this
.
stop
(
new
Error
(
devtools
.
inspectedWindow
.
reload
on
{
url
}
has
been
interrupted
)
)
;
}
else
{
this
.
stop
(
)
;
}
}
}
stop
(
error
)
{
if
(
this
.
stopped
)
{
return
;
}
this
.
docShell
.
removeProgressListener
(
this
)
;
if
(
this
.
injectedScript
)
{
Services
.
obs
.
removeObserver
(
this
"
document
-
element
-
inserted
"
)
;
}
if
(
this
.
userAgent
&
&
this
.
docShell
.
customUserAgent
=
=
this
.
userAgent
)
{
this
.
docShell
.
customUserAgent
=
null
;
}
if
(
error
)
{
this
.
rejectReloadCompleted
(
error
)
;
}
else
{
this
.
resolveReloadCompleted
(
)
;
}
this
.
stopped
=
true
;
}
}
;
var
WebExtensionInspectedWindowActor
=
protocol
.
ActorClassWithSpec
(
webExtensionInspectedWindowSpec
{
initialize
(
conn
targetActor
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
targetActor
=
targetActor
;
}
destroy
(
conn
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
conn
)
;
if
(
this
.
customizedReload
)
{
this
.
customizedReload
.
stop
(
new
Error
(
"
WebExtensionInspectedWindowActor
destroyed
"
)
)
;
delete
this
.
customizedReload
;
}
if
(
this
.
_dbg
)
{
this
.
_dbg
.
enabled
=
false
;
delete
this
.
_dbg
;
}
}
get
dbg
(
)
{
if
(
this
.
_dbg
)
{
return
this
.
_dbg
;
}
this
.
_dbg
=
this
.
targetActor
.
makeDebugger
(
)
;
return
this
.
_dbg
;
}
get
window
(
)
{
return
this
.
targetActor
.
window
;
}
get
webNavigation
(
)
{
return
this
.
targetActor
.
webNavigation
;
}
createEvalBindings
(
dbgWindow
options
)
{
const
bindings
=
Object
.
create
(
null
)
;
let
selectedDOMNode
;
if
(
options
.
toolboxSelectedNodeActorID
)
{
const
actor
=
DebuggerServer
.
searchAllConnectionsForActor
(
options
.
toolboxSelectedNodeActorID
)
;
if
(
actor
&
&
actor
instanceof
NodeActor
)
{
selectedDOMNode
=
actor
.
rawNode
;
}
}
Object
.
defineProperty
(
bindings
"
0
"
{
enumerable
:
true
configurable
:
true
get
:
(
)
=
>
{
if
(
selectedDOMNode
&
&
!
Cu
.
isDeadWrapper
(
selectedDOMNode
)
)
{
return
dbgWindow
.
makeDebuggeeValue
(
selectedDOMNode
)
;
}
return
undefined
;
}
}
)
;
Object
.
defineProperty
(
bindings
"
inspect
"
{
enumerable
:
true
configurable
:
true
value
:
dbgWindow
.
makeDebuggeeValue
(
(
object
)
=
>
{
const
dbgObj
=
dbgWindow
.
makeDebuggeeValue
(
object
)
;
const
consoleActor
=
DebuggerServer
.
searchAllConnectionsForActor
(
options
.
toolboxConsoleActorID
)
;
if
(
consoleActor
)
{
consoleActor
.
inspectObject
(
dbgObj
"
webextension
-
devtools
-
inspectedWindow
-
eval
"
)
;
}
else
{
console
.
error
(
"
Toolbox
Console
RDP
Actor
not
found
"
)
;
}
}
)
}
)
;
return
bindings
;
}
reload
(
callerInfo
{
ignoreCache
userAgent
injectedScript
}
)
{
if
(
isSystemPrincipalWindow
(
this
.
window
)
)
{
console
.
error
(
"
Ignored
inspectedWindow
.
reload
on
system
principal
target
for
"
+
{
callerInfo
.
url
}
:
{
callerInfo
.
lineNumber
}
)
;
return
{
}
;
}
const
delayedReload
=
(
)
=
>
{
if
(
Services
.
startup
.
shuttingDown
)
{
return
;
}
if
(
injectedScript
|
|
userAgent
)
{
if
(
this
.
customizedReload
)
{
console
.
error
(
"
Reload
already
in
progress
.
Ignored
inspectedWindow
.
reload
for
"
+
{
callerInfo
.
url
}
:
{
callerInfo
.
lineNumber
}
)
;
return
;
}
try
{
this
.
customizedReload
=
new
CustomizedReload
(
{
targetActor
:
this
.
targetActor
inspectedWindowEval
:
this
.
eval
.
bind
(
this
)
callerInfo
injectedScript
userAgent
ignoreCache
}
)
;
this
.
customizedReload
.
start
(
)
.
then
(
(
)
=
>
{
delete
this
.
customizedReload
;
}
)
.
catch
(
err
=
>
{
delete
this
.
customizedReload
;
console
.
error
(
err
)
;
}
)
;
}
catch
(
err
)
{
if
(
this
.
customizedReload
)
{
this
.
customizedReload
.
stop
(
err
)
;
}
throw
err
;
}
}
else
{
let
reloadFlags
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
;
if
(
ignoreCache
)
{
reloadFlags
|
=
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
;
}
this
.
webNavigation
.
reload
(
reloadFlags
)
;
}
}
;
Services
.
tm
.
dispatchToMainThread
(
delayedReload
)
;
return
{
}
;
}
eval
(
callerInfo
expression
options
customTargetWindow
)
{
const
window
=
customTargetWindow
|
|
this
.
window
;
options
=
options
|
|
{
}
;
const
extensionPolicy
=
WebExtensionPolicy
.
getByID
(
callerInfo
.
addonId
)
;
if
(
!
extensionPolicy
)
{
return
createExceptionInfoResult
(
{
description
:
"
Inspector
protocol
error
:
%
s
%
s
"
details
:
[
"
Caller
extension
not
found
for
"
callerInfo
.
url
]
}
)
;
}
if
(
!
window
)
{
return
createExceptionInfoResult
(
{
description
:
"
Inspector
protocol
error
:
%
s
"
details
:
[
"
The
target
window
is
not
defined
.
inspectedWindow
.
eval
not
executed
.
"
]
}
)
;
}
const
logEvalDenied
=
(
)
=
>
{
logAccessDeniedWarning
(
window
callerInfo
extensionPolicy
)
;
}
;
if
(
isSystemPrincipalWindow
(
window
)
)
{
logEvalDenied
(
)
;
return
createExceptionInfoResult
(
{
description
:
"
Inspector
protocol
error
:
%
s
"
details
:
[
"
This
target
has
a
system
principal
.
inspectedWindow
.
eval
denied
.
"
]
}
)
;
}
const
docPrincipalURI
=
window
.
document
.
nodePrincipal
.
URI
;
if
(
WebExtensionPolicy
.
isRestrictedURI
(
docPrincipalURI
)
|
|
docPrincipalURI
.
schemeIs
(
"
about
"
)
)
{
logEvalDenied
(
)
;
return
createExceptionInfoResult
(
{
description
:
"
Inspector
protocol
error
:
%
s
%
s
"
details
:
[
"
This
extension
is
not
allowed
on
the
current
inspected
window
origin
"
docPrincipalURI
.
spec
]
}
)
;
}
const
windowAddonId
=
window
.
document
.
nodePrincipal
.
addonId
;
if
(
windowAddonId
&
&
extensionPolicy
.
id
!
=
=
windowAddonId
)
{
logEvalDenied
(
)
;
return
createExceptionInfoResult
(
{
description
:
"
Inspector
protocol
error
:
%
s
on
%
s
"
details
:
[
"
This
extension
is
not
allowed
to
access
this
extension
page
.
"
window
.
document
.
location
.
origin
]
}
)
;
}
if
(
options
.
frameURL
|
|
options
.
contextSecurityOrigin
|
|
options
.
useContentScriptContext
)
{
return
createExceptionInfoResult
(
{
description
:
"
Inspector
protocol
error
:
%
s
"
details
:
[
"
The
inspectedWindow
.
eval
options
are
currently
not
supported
"
]
}
)
;
}
const
dbgWindow
=
this
.
dbg
.
makeGlobalObjectReference
(
window
)
;
let
evalCalledFrom
=
callerInfo
.
url
;
if
(
callerInfo
.
lineNumber
)
{
evalCalledFrom
+
=
:
{
callerInfo
.
lineNumber
}
;
}
const
bindings
=
this
.
createEvalBindings
(
dbgWindow
options
)
;
const
result
=
dbgWindow
.
executeInGlobalWithBindings
(
expression
bindings
{
url
:
debugger
eval
called
from
{
evalCalledFrom
}
-
eval
code
}
)
;
let
evalResult
;
if
(
result
)
{
if
(
"
return
"
in
result
)
{
evalResult
=
result
.
return
;
}
else
if
(
"
yield
"
in
result
)
{
evalResult
=
result
.
yield
;
}
else
if
(
"
throw
"
in
result
)
{
const
throwErr
=
result
.
throw
;
const
unsafeDereference
=
throwErr
&
&
(
typeof
throwErr
=
=
=
"
object
"
)
&
&
throwErr
.
unsafeDereference
(
)
;
const
message
=
unsafeDereference
&
&
unsafeDereference
.
toString
?
unsafeDereference
.
toString
(
)
:
String
(
throwErr
)
;
const
stack
=
unsafeDereference
&
&
unsafeDereference
.
stack
?
unsafeDereference
.
stack
:
null
;
return
{
exceptionInfo
:
{
isException
:
true
value
:
{
message
}
\
n
\
t
{
stack
}
}
}
;
}
}
else
{
console
.
error
(
"
Unexpected
empty
inspectedWindow
.
eval
result
for
"
{
callerInfo
.
url
}
:
{
callerInfo
.
lineNumber
}
)
;
}
if
(
evalResult
)
{
try
{
if
(
options
.
evalResultAsGrip
)
{
if
(
!
options
.
toolboxConsoleActorID
)
{
return
createExceptionInfoResult
(
{
description
:
"
Inspector
protocol
error
:
%
s
-
%
s
"
details
:
[
"
Unexpected
invalid
sidebar
panel
expression
request
"
"
missing
toolboxConsoleActorID
"
]
}
)
;
}
const
consoleActor
=
DebuggerServer
.
searchAllConnectionsForActor
(
options
.
toolboxConsoleActorID
)
;
return
{
valueGrip
:
consoleActor
.
createValueGrip
(
evalResult
)
}
;
}
if
(
evalResult
&
&
typeof
evalResult
=
=
=
"
object
"
)
{
evalResult
=
evalResult
.
unsafeDereference
(
)
;
}
evalResult
=
JSON
.
parse
(
JSON
.
stringify
(
evalResult
)
)
;
}
catch
(
err
)
{
return
createExceptionInfoResult
(
{
description
:
"
Inspector
protocol
error
:
%
s
"
details
:
[
String
(
err
)
]
}
)
;
}
}
return
{
value
:
evalResult
}
;
}
}
)
;
exports
.
WebExtensionInspectedWindowActor
=
WebExtensionInspectedWindowActor
;
