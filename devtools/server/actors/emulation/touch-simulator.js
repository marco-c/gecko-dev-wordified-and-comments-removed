"
use
strict
"
;
const
{
Services
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorUtils
"
"
InspectorUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
PICKER_TYPES
"
"
devtools
/
shared
/
picker
-
constants
"
)
;
var
isClickHoldEnabled
=
Services
.
prefs
.
getBoolPref
(
"
ui
.
click_hold_context_menus
"
)
;
var
clickHoldDelay
=
Services
.
prefs
.
getIntPref
(
"
ui
.
click_hold_context_menus
.
delay
"
500
)
;
const
TOUCH_CONTACT
=
0x02
;
const
TOUCH_REMOVE
=
0x04
;
const
TOUCH_STATES
=
{
touchstart
:
TOUCH_CONTACT
touchmove
:
TOUCH_CONTACT
touchend
:
TOUCH_REMOVE
}
;
const
EVENTS_TO_HANDLE
=
[
"
mousedown
"
"
mousemove
"
"
mouseup
"
"
touchstart
"
"
touchend
"
"
mouseenter
"
"
mouseover
"
"
mouseout
"
"
mouseleave
"
]
;
const
kStateHover
=
0x00000004
;
class
TouchSimulator
{
constructor
(
simulatorTarget
)
{
this
.
simulatorTarget
=
simulatorTarget
;
this
.
_currentPickerMap
=
new
Map
(
)
;
}
enabled
=
false
;
start
(
)
{
if
(
this
.
enabled
)
{
return
;
}
EVENTS_TO_HANDLE
.
forEach
(
evt
=
>
{
this
.
simulatorTarget
.
addEventListener
(
evt
this
true
false
)
;
}
)
;
this
.
enabled
=
true
;
}
stop
(
)
{
if
(
!
this
.
enabled
)
{
return
;
}
EVENTS_TO_HANDLE
.
forEach
(
evt
=
>
{
this
.
simulatorTarget
.
removeEventListener
(
evt
this
true
)
;
}
)
;
this
.
enabled
=
false
;
}
_isPicking
(
)
{
const
types
=
Object
.
values
(
PICKER_TYPES
)
;
return
types
.
some
(
type
=
>
this
.
_currentPickerMap
.
get
(
type
)
)
;
}
setElementPickerState
(
state
pickerType
)
{
if
(
!
Object
.
values
(
PICKER_TYPES
)
.
includes
(
pickerType
)
)
{
throw
new
Error
(
"
Unsupported
type
in
setElementPickerState
:
"
+
pickerType
)
;
}
this
.
_currentPickerMap
.
set
(
pickerType
state
)
;
}
handleEvent
(
evt
)
{
if
(
this
.
_isPicking
(
)
)
{
return
;
}
const
content
=
this
.
getContent
(
evt
.
target
)
;
if
(
!
content
)
{
return
;
}
if
(
evt
.
type
.
startsWith
(
"
touch
"
)
)
{
const
sysFrame
=
content
.
realFrameElement
;
if
(
!
sysFrame
)
{
return
;
}
const
sysDocument
=
sysFrame
.
ownerDocument
;
const
sysWindow
=
sysDocument
.
defaultView
;
const
touchEvent
=
sysDocument
.
createEvent
(
"
touchevent
"
)
;
const
touch
=
evt
.
touches
[
0
]
|
|
evt
.
changedTouches
[
0
]
;
const
point
=
sysDocument
.
createTouch
(
sysWindow
sysFrame
0
touch
.
pageX
touch
.
pageY
touch
.
screenX
touch
.
screenY
touch
.
clientX
touch
.
clientY
1
1
0
0
)
;
const
touches
=
sysDocument
.
createTouchList
(
point
)
;
const
targetTouches
=
touches
;
const
changedTouches
=
touches
;
touchEvent
.
initTouchEvent
(
evt
.
type
true
true
sysWindow
0
false
false
false
false
touches
targetTouches
changedTouches
)
;
sysFrame
.
dispatchEvent
(
touchEvent
)
;
return
;
}
if
(
evt
.
button
|
|
evt
.
mozInputSource
!
=
evt
.
MOZ_SOURCE_MOUSE
|
|
evt
.
isSynthesized
)
{
return
;
}
const
eventTarget
=
this
.
target
;
let
type
=
"
"
;
switch
(
evt
.
type
)
{
case
"
mouseenter
"
:
case
"
mouseover
"
:
case
"
mouseout
"
:
case
"
mouseleave
"
:
evt
.
stopPropagation
(
)
;
evt
.
preventDefault
(
)
;
InspectorUtils
.
removeContentState
(
evt
.
target
kStateHover
)
;
break
;
case
"
mousedown
"
:
this
.
target
=
evt
.
target
;
if
(
isClickHoldEnabled
&
&
!
evt
.
originalTarget
.
closest
(
"
scrollbar
"
)
)
{
this
.
_contextMenuTimeout
=
this
.
sendContextMenu
(
evt
)
;
}
this
.
startX
=
evt
.
pageX
;
this
.
startY
=
evt
.
pageY
;
evt
.
target
.
setCapture
(
false
)
;
type
=
"
touchstart
"
;
break
;
case
"
mousemove
"
:
if
(
!
eventTarget
)
{
evt
.
stopPropagation
(
)
;
return
;
}
type
=
"
touchmove
"
;
break
;
case
"
mouseup
"
:
if
(
!
eventTarget
)
{
return
;
}
this
.
target
=
null
;
content
.
clearTimeout
(
this
.
_contextMenuTimeout
)
;
type
=
"
touchend
"
;
if
(
evt
.
detail
=
=
1
)
{
this
.
simulatorTarget
.
addEventListener
(
"
click
"
this
{
capture
:
true
once
:
true
}
)
;
}
break
;
}
const
target
=
eventTarget
|
|
this
.
target
;
if
(
target
&
&
type
)
{
this
.
synthesizeNativeTouch
(
content
evt
.
screenX
evt
.
screenY
type
)
;
}
evt
.
preventDefault
(
)
;
evt
.
stopImmediatePropagation
(
)
;
}
sendContextMenu
(
{
target
clientX
clientY
screenX
screenY
}
)
{
const
view
=
target
.
ownerGlobal
;
const
{
MouseEvent
}
=
view
;
const
evt
=
new
MouseEvent
(
"
contextmenu
"
{
bubbles
:
true
cancelable
:
true
view
screenX
screenY
clientX
clientY
}
)
;
const
content
=
this
.
getContent
(
target
)
;
const
timeout
=
content
.
setTimeout
(
(
)
=
>
{
target
.
dispatchEvent
(
evt
)
;
}
clickHoldDelay
)
;
return
timeout
;
}
synthesizeNativeTouch
(
win
screenX
screenY
type
)
{
const
utils
=
win
.
windowUtils
;
const
deviceScale
=
win
.
devicePixelRatio
;
const
pt
=
{
x
:
screenX
*
deviceScale
y
:
screenY
*
deviceScale
}
;
utils
.
sendNativeTouchPoint
(
0
TOUCH_STATES
[
type
]
pt
.
x
pt
.
y
1
90
null
)
;
return
true
;
}
getContent
(
target
)
{
const
win
=
target
?
.
ownerDocument
?
target
.
ownerGlobal
:
null
;
return
win
;
}
}
exports
.
TouchSimulator
=
TouchSimulator
;
