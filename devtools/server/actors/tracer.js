"
use
strict
"
;
const
{
startTracing
stopTracing
addTracingListener
removeTracingListener
NEXT_INTERACTION_MESSAGE
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
tracer
/
tracer
.
jsm
"
)
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
tracerSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
tracer
.
js
"
)
;
const
{
throttle
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
throttle
.
js
"
)
;
const
{
makeDebuggeeValue
createValueGripForTarget
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
{
TYPES
getResourceWatcher
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
index
.
js
"
)
;
const
{
JSTRACER_TRACE
}
=
TYPES
;
loader
.
lazyRequireGetter
(
this
"
GeckoProfileCollector
"
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
gecko
-
profile
-
collector
.
js
"
true
)
;
const
LOG_METHODS
=
{
STDOUT
:
"
stdout
"
CONSOLE
:
"
console
"
PROFILER
:
"
profiler
"
}
;
exports
.
LOG_METHODS
=
LOG_METHODS
;
const
VALID_LOG_METHODS
=
Object
.
values
(
LOG_METHODS
)
;
const
CONSOLE_THROTTLING_DELAY
=
250
;
class
TracerActor
extends
Actor
{
constructor
(
conn
targetActor
)
{
super
(
conn
tracerSpec
)
;
this
.
targetActor
=
targetActor
;
this
.
sourcesManager
=
this
.
targetActor
.
sourcesManager
;
this
.
throttledTraces
=
[
]
;
this
.
throttleEmitTraces
=
isWorker
?
this
.
flushTraces
.
bind
(
this
)
:
throttle
(
this
.
flushTraces
.
bind
(
this
)
CONSOLE_THROTTLING_DELAY
)
;
this
.
geckoProfileCollector
=
new
GeckoProfileCollector
(
)
;
}
destroy
(
)
{
this
.
stopTracing
(
)
;
}
getLogMethod
(
)
{
return
this
.
logMethod
;
}
toggleTracing
(
options
)
{
if
(
!
this
.
tracingListener
)
{
this
.
startTracing
(
options
)
;
return
true
;
}
this
.
stopTracing
(
)
;
return
false
;
}
startTracing
(
options
=
{
}
)
{
if
(
options
.
logMethod
&
&
!
VALID_LOG_METHODS
.
includes
(
options
.
logMethod
)
)
{
throw
new
Error
(
Invalid
log
method
'
{
options
.
logMethod
}
'
.
Only
supports
:
{
VALID_LOG_METHODS
}
)
;
}
if
(
options
.
prefix
&
&
typeof
options
.
prefix
!
=
"
string
"
)
{
throw
new
Error
(
"
Invalid
prefix
only
support
string
type
"
)
;
}
if
(
options
.
maxDepth
&
&
typeof
options
.
maxDepth
!
=
"
number
"
)
{
throw
new
Error
(
"
Invalid
max
-
depth
only
support
numbers
"
)
;
}
if
(
options
.
maxRecords
&
&
typeof
options
.
maxRecords
!
=
"
number
"
)
{
throw
new
Error
(
"
Invalid
max
-
records
only
support
numbers
"
)
;
}
if
(
options
.
traceOnNextInteraction
&
&
isWorker
)
{
return
;
}
this
.
logMethod
=
options
.
logMethod
|
|
LOG_METHODS
.
STDOUT
;
if
(
this
.
logMethod
=
=
LOG_METHODS
.
PROFILER
)
{
this
.
geckoProfileCollector
.
start
(
)
;
}
this
.
tracingListener
=
{
onTracingFrame
:
this
.
onTracingFrame
.
bind
(
this
)
onTracingFrameStep
:
this
.
onTracingFrameStep
.
bind
(
this
)
onTracingFrameExit
:
this
.
onTracingFrameExit
.
bind
(
this
)
onTracingInfiniteLoop
:
this
.
onTracingInfiniteLoop
.
bind
(
this
)
onTracingToggled
:
this
.
onTracingToggled
.
bind
(
this
)
onTracingPending
:
this
.
onTracingPending
.
bind
(
this
)
onTracingDOMMutation
:
this
.
onTracingDOMMutation
.
bind
(
this
)
}
;
addTracingListener
(
this
.
tracingListener
)
;
this
.
traceValues
=
!
!
options
.
traceValues
;
try
{
startTracing
(
{
global
:
this
.
targetActor
.
window
|
|
this
.
targetActor
.
workerGlobal
prefix
:
options
.
prefix
|
|
"
"
traceDOMEvents
:
true
traceDOMMutations
:
options
.
traceDOMMutations
traceValues
:
!
!
options
.
traceValues
traceOnNextInteraction
:
!
!
options
.
traceOnNextInteraction
traceFunctionReturn
:
!
!
options
.
traceFunctionReturn
maxDepth
:
options
.
maxDepth
maxRecords
:
options
.
maxRecords
}
)
;
}
catch
(
e
)
{
this
.
stopTracing
(
)
;
throw
e
;
}
}
stopTracing
(
)
{
if
(
!
this
.
tracingListener
)
{
return
;
}
removeTracingListener
(
this
.
tracingListener
)
;
this
.
tracingListener
=
null
;
stopTracing
(
)
;
this
.
logMethod
=
null
;
}
getProfile
(
)
{
const
profile
=
this
.
geckoProfileCollector
.
stop
(
)
;
if
(
profile
.
threads
[
0
]
.
samples
.
data
.
length
)
{
return
profile
;
}
return
null
;
}
onTracingToggled
(
enabled
reason
)
{
const
shouldLogToStdout
=
this
.
logMethod
=
=
LOG_METHODS
.
STDOUT
;
if
(
!
enabled
)
{
this
.
stopTracing
(
)
;
}
return
shouldLogToStdout
;
}
onTracingPending
(
)
{
if
(
this
.
logMethod
=
=
LOG_METHODS
.
STDOUT
)
{
return
true
;
}
if
(
this
.
logMethod
=
=
LOG_METHODS
.
CONSOLE
)
{
const
consoleMessageWatcher
=
getResourceWatcher
(
this
.
targetActor
TYPES
.
CONSOLE_MESSAGE
)
;
if
(
consoleMessageWatcher
)
{
consoleMessageWatcher
.
emitMessages
(
[
{
arguments
:
[
NEXT_INTERACTION_MESSAGE
]
styles
:
[
]
level
:
"
jstracer
"
chromeContext
:
false
timeStamp
:
ChromeUtils
.
dateNow
(
)
}
]
)
;
}
return
false
;
}
return
false
;
}
onTracingInfiniteLoop
(
)
{
if
(
this
.
logMethod
=
=
LOG_METHODS
.
STDOUT
)
{
return
true
;
}
if
(
this
.
logMethod
=
=
LOG_METHODS
.
PROFILER
)
{
this
.
geckoProfileCollector
.
stop
(
)
;
return
true
;
}
const
consoleMessageWatcher
=
getResourceWatcher
(
this
.
targetActor
TYPES
.
CONSOLE_MESSAGE
)
;
if
(
!
consoleMessageWatcher
)
{
return
true
;
}
const
message
=
"
Looks
like
an
infinite
recursion
?
We
stopped
the
JavaScript
tracer
but
code
may
still
be
running
!
"
;
consoleMessageWatcher
.
emitMessages
(
[
{
arguments
:
[
message
]
styles
:
[
]
level
:
"
jstracer
"
chromeContext
:
false
timeStamp
:
ChromeUtils
.
dateNow
(
)
}
]
)
;
return
false
;
}
onTracingDOMMutation
(
{
depth
prefix
type
caller
element
}
)
{
if
(
this
.
logMethod
=
=
LOG_METHODS
.
STDOUT
)
{
return
true
;
}
if
(
this
.
logMethod
=
=
LOG_METHODS
.
CONSOLE
)
{
const
dbgObj
=
makeDebuggeeValue
(
this
.
targetActor
element
)
;
this
.
throttledTraces
.
push
(
{
resourceType
:
JSTRACER_TRACE
prefix
timeStamp
:
ChromeUtils
.
dateNow
(
)
filename
:
caller
?
.
filename
lineNumber
:
caller
?
.
lineNumber
columnNumber
:
caller
?
.
columnNumber
sourceId
:
caller
.
sourceId
depth
mutationType
:
type
mutationElement
:
createValueGripForTarget
(
this
.
targetActor
dbgObj
)
}
)
;
this
.
throttleEmitTraces
(
)
;
return
false
;
}
return
false
;
}
onTracingFrameStep
(
{
frame
depth
prefix
}
)
{
const
{
script
}
=
frame
;
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
frame
.
offset
)
;
const
url
=
script
.
source
.
url
;
const
columnBase
=
script
.
format
=
=
=
"
wasm
"
?
0
:
1
;
if
(
this
.
sourcesManager
.
isBlackBoxed
(
url
lineNumber
columnNumber
-
columnBase
)
)
{
return
false
;
}
if
(
this
.
logMethod
=
=
LOG_METHODS
.
STDOUT
)
{
return
true
;
}
if
(
this
.
logMethod
=
=
LOG_METHODS
.
CONSOLE
)
{
this
.
throttledTraces
.
push
(
{
resourceType
:
JSTRACER_TRACE
prefix
timeStamp
:
ChromeUtils
.
dateNow
(
)
depth
filename
:
url
lineNumber
columnNumber
:
columnNumber
-
columnBase
sourceId
:
script
.
source
.
id
}
)
;
this
.
throttleEmitTraces
(
)
;
}
return
false
;
}
onTracingFrame
(
{
frameId
frame
depth
formatedDisplayName
prefix
currentDOMEvent
}
)
{
const
{
script
}
=
frame
;
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
frame
.
offset
)
;
const
url
=
script
.
source
.
url
;
const
columnBase
=
script
.
format
=
=
=
"
wasm
"
?
0
:
1
;
if
(
this
.
sourcesManager
.
isBlackBoxed
(
url
lineNumber
columnNumber
-
columnBase
)
)
{
return
false
;
}
if
(
this
.
logMethod
=
=
LOG_METHODS
.
STDOUT
)
{
return
true
;
}
if
(
this
.
logMethod
=
=
LOG_METHODS
.
CONSOLE
)
{
if
(
currentDOMEvent
&
&
depth
=
=
0
)
{
this
.
throttledTraces
.
push
(
{
resourceType
:
JSTRACER_TRACE
prefix
timeStamp
:
ChromeUtils
.
dateNow
(
)
eventName
:
currentDOMEvent
}
)
;
}
let
args
=
undefined
;
if
(
this
.
traceValues
&
&
frame
.
arguments
)
{
args
=
[
]
;
for
(
let
arg
of
frame
.
arguments
)
{
if
(
arg
?
.
unsafeDereference
)
{
arg
=
arg
.
unsafeDereference
(
)
;
}
const
dbgObj
=
makeDebuggeeValue
(
this
.
targetActor
arg
)
;
args
.
push
(
createValueGripForTarget
(
this
.
targetActor
dbgObj
)
)
;
}
}
this
.
throttledTraces
.
push
(
{
resourceType
:
JSTRACER_TRACE
prefix
timeStamp
:
ChromeUtils
.
dateNow
(
)
depth
implementation
:
frame
.
implementation
displayName
:
formatedDisplayName
filename
:
url
lineNumber
columnNumber
:
columnNumber
-
columnBase
sourceId
:
script
.
source
.
id
args
}
)
;
this
.
throttleEmitTraces
(
)
;
}
else
if
(
this
.
logMethod
=
=
LOG_METHODS
.
PROFILER
)
{
this
.
geckoProfileCollector
.
addSample
(
{
name
:
formatedDisplayName
.
replace
(
"
"
"
"
)
url
lineNumber
columnNumber
category
:
frame
.
implementation
}
depth
)
;
}
return
false
;
}
onTracingFrameExit
(
{
frameId
frame
depth
formatedDisplayName
prefix
why
rv
}
)
{
const
{
script
}
=
frame
;
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
frame
.
offset
)
;
const
url
=
script
.
source
.
url
;
const
columnBase
=
script
.
format
=
=
=
"
wasm
"
?
0
:
1
;
if
(
this
.
sourcesManager
.
isBlackBoxed
(
url
lineNumber
columnNumber
-
columnBase
)
)
{
return
false
;
}
if
(
this
.
logMethod
=
=
LOG_METHODS
.
STDOUT
)
{
return
true
;
}
if
(
this
.
logMethod
=
=
LOG_METHODS
.
CONSOLE
)
{
let
returnedValue
=
undefined
;
if
(
this
.
traceValues
)
{
if
(
rv
?
.
unsafeDereference
)
{
rv
=
rv
.
unsafeDereference
(
)
;
}
const
dbgObj
=
makeDebuggeeValue
(
this
.
targetActor
rv
)
;
returnedValue
=
createValueGripForTarget
(
this
.
targetActor
dbgObj
)
;
}
this
.
throttledTraces
.
push
(
{
resourceType
:
JSTRACER_TRACE
prefix
timeStamp
:
ChromeUtils
.
dateNow
(
)
depth
displayName
:
formatedDisplayName
filename
:
url
lineNumber
columnNumber
:
columnNumber
-
columnBase
sourceId
:
script
.
source
.
id
relatedTraceId
:
frameId
returnedValue
why
}
)
;
this
.
throttleEmitTraces
(
)
;
}
else
if
(
this
.
logMethod
=
=
LOG_METHODS
.
PROFILER
)
{
}
return
false
;
}
flushTraces
(
)
{
const
traceWatcher
=
getResourceWatcher
(
this
.
targetActor
JSTRACER_TRACE
)
;
if
(
!
traceWatcher
)
{
return
;
}
const
traces
=
this
.
throttledTraces
;
this
.
throttledTraces
=
[
]
;
traceWatcher
.
emitTraces
(
traces
)
;
}
}
exports
.
TracerActor
=
TracerActor
;
