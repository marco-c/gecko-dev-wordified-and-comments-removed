"
use
strict
"
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
JSTracer
:
"
resource
:
/
/
devtools
/
server
/
tracer
/
tracer
.
sys
.
mjs
"
}
{
global
:
"
contextual
"
}
)
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
tracerSpec
TRACER_LOG_METHODS
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
tracer
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
StdoutTracingListener
"
"
resource
:
/
/
devtools
/
server
/
actors
/
tracer
/
stdout
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleTracingListener
"
"
resource
:
/
/
devtools
/
server
/
actors
/
tracer
/
console
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ProfilerTracingListener
"
"
resource
:
/
/
devtools
/
server
/
actors
/
tracer
/
profiler
.
js
"
true
)
;
exports
.
TRACER_FIELDS_INDEXES
=
{
FRAME_IMPLEMENTATION
:
0
FRAME_NAME
:
1
FRAME_SOURCEID
:
2
FRAME_LINE
:
3
FRAME_COLUMN
:
4
FRAME_URL
:
5
}
;
const
VALID_LOG_METHODS
=
Object
.
values
(
TRACER_LOG_METHODS
)
;
class
TracerActor
extends
Actor
{
constructor
(
conn
targetActor
)
{
super
(
conn
tracerSpec
)
;
this
.
targetActor
=
targetActor
;
}
#
stopResult
=
null
;
destroy
(
)
{
this
.
stopTracing
(
)
;
}
getLogMethod
(
)
{
return
this
.
logMethod
;
}
toggleTracing
(
options
)
{
if
(
!
this
.
tracingListener
)
{
this
.
startTracing
(
options
)
;
return
true
;
}
this
.
stopTracing
(
)
;
return
false
;
}
startTracing
(
options
=
{
}
)
{
if
(
options
.
logMethod
&
&
!
VALID_LOG_METHODS
.
includes
(
options
.
logMethod
)
)
{
throw
new
Error
(
Invalid
log
method
'
{
options
.
logMethod
}
'
.
Only
supports
:
{
VALID_LOG_METHODS
}
)
;
}
if
(
options
.
prefix
&
&
typeof
options
.
prefix
!
=
"
string
"
)
{
throw
new
Error
(
"
Invalid
prefix
only
support
string
type
"
)
;
}
if
(
options
.
maxDepth
&
&
typeof
options
.
maxDepth
!
=
"
number
"
)
{
throw
new
Error
(
"
Invalid
max
-
depth
only
support
numbers
"
)
;
}
if
(
options
.
maxRecords
&
&
typeof
options
.
maxRecords
!
=
"
number
"
)
{
throw
new
Error
(
"
Invalid
max
-
records
only
support
numbers
"
)
;
}
if
(
options
.
traceOnNextInteraction
&
&
isWorker
)
{
return
;
}
if
(
this
.
targetActor
.
window
&
&
!
this
.
targetActor
.
window
.
windowGlobalChild
?
.
isProcessRoot
)
{
return
;
}
this
.
logMethod
=
options
.
logMethod
|
|
TRACER_LOG_METHODS
.
STDOUT
;
let
ListenerClass
=
null
;
switch
(
this
.
logMethod
)
{
case
TRACER_LOG_METHODS
.
STDOUT
:
ListenerClass
=
StdoutTracingListener
;
break
;
case
TRACER_LOG_METHODS
.
CONSOLE
:
ListenerClass
=
ConsoleTracingListener
;
break
;
case
TRACER_LOG_METHODS
.
PROFILER
:
ListenerClass
=
ProfilerTracingListener
;
options
.
traceFunctionReturn
=
true
;
break
;
}
this
.
tracingListener
=
new
ListenerClass
(
{
targetActor
:
this
.
targetActor
traceValues
:
!
!
options
.
traceValues
traceActor
:
this
}
)
;
lazy
.
JSTracer
.
addTracingListener
(
this
.
tracingListener
)
;
this
.
traceValues
=
!
!
options
.
traceValues
;
try
{
lazy
.
JSTracer
.
startTracing
(
{
global
:
this
.
targetActor
.
window
|
|
this
.
targetActor
.
workerGlobal
prefix
:
options
.
prefix
|
|
"
"
traceDOMEvents
:
true
traceDOMMutations
:
options
.
traceDOMMutations
traceValues
:
!
!
options
.
traceValues
traceOnNextInteraction
:
!
!
options
.
traceOnNextInteraction
traceFunctionReturn
:
!
!
options
.
traceFunctionReturn
maxDepth
:
options
.
maxDepth
maxRecords
:
options
.
maxRecords
}
)
;
}
catch
(
e
)
{
this
.
stopTracing
(
)
;
throw
e
;
}
}
stopTracing
(
)
{
if
(
!
this
.
tracingListener
)
{
return
;
}
lazy
.
JSTracer
.
removeTracingListener
(
this
.
tracingListener
)
;
this
.
#
stopResult
=
this
.
tracingListener
.
stop
(
)
;
this
.
tracingListener
=
null
;
lazy
.
JSTracer
.
stopTracing
(
)
;
this
.
logMethod
=
null
;
}
getProfile
(
)
{
const
profile
=
this
.
#
stopResult
;
if
(
profile
.
threads
[
0
]
.
samples
.
data
.
length
)
{
return
profile
;
}
return
null
;
}
}
exports
.
TracerActor
=
TracerActor
;
