"
use
strict
"
;
const
{
startTracing
stopTracing
addTracingListener
removeTracingListener
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
tracer
/
tracer
.
jsm
"
)
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
tracerSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
tracer
.
js
"
)
;
const
{
throttle
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
throttle
.
js
"
)
;
const
{
TYPES
getResourceWatcher
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
index
.
js
"
)
;
const
LOG_METHODS
=
{
STDOUT
:
"
stdout
"
CONSOLE
:
"
console
"
}
;
const
CONSOLE_ARGS_STYLES
=
[
"
color
:
var
(
-
-
theme
-
toolbarbutton
-
checked
-
hover
-
background
)
"
"
padding
-
inline
:
4px
;
margin
-
inline
:
2px
;
background
-
color
:
var
(
-
-
theme
-
toolbarbutton
-
checked
-
hover
-
background
)
;
color
:
var
(
-
-
theme
-
toolbarbutton
-
checked
-
hover
-
color
)
;
"
"
"
"
color
:
var
(
-
-
theme
-
highlight
-
blue
)
;
margin
-
inline
:
2px
;
"
]
;
const
CONSOLE_THROTTLING_DELAY
=
250
;
class
TracerActor
extends
Actor
{
constructor
(
conn
targetActor
)
{
super
(
conn
tracerSpec
)
;
this
.
targetActor
=
targetActor
;
this
.
isChromeContext
=
/
conn
\
d
+
\
.
parentProcessTarget
\
d
+
/
.
test
(
this
.
targetActor
.
actorID
)
;
this
.
throttledConsoleMessages
=
[
]
;
this
.
throttleLogMessages
=
throttle
(
this
.
flushConsoleMessages
.
bind
(
this
)
CONSOLE_THROTTLING_DELAY
)
;
}
destroy
(
)
{
this
.
stopTracing
(
)
;
}
getLogMethod
(
)
{
return
this
.
logMethod
;
}
startTracing
(
logMethod
=
LOG_METHODS
.
STDOUT
)
{
this
.
logMethod
=
logMethod
;
this
.
tracingListener
=
{
onTracingFrame
:
this
.
onTracingFrame
.
bind
(
this
)
onTracingInfiniteLoop
:
this
.
onTracingInfiniteLoop
.
bind
(
this
)
}
;
addTracingListener
(
this
.
tracingListener
)
;
startTracing
(
{
global
:
this
.
targetActor
.
window
|
|
this
.
targetActor
.
workerGlobal
}
)
;
}
stopTracing
(
)
{
if
(
!
this
.
tracingListener
)
{
return
;
}
stopTracing
(
)
;
removeTracingListener
(
this
.
tracingListener
)
;
this
.
logMethod
=
null
;
this
.
tracingListener
=
null
;
}
onTracingInfiniteLoop
(
)
{
if
(
this
.
logMethod
=
=
LOG_METHODS
.
STDOUT
)
{
return
true
;
}
const
consoleMessageWatcher
=
getResourceWatcher
(
this
.
targetActor
TYPES
.
CONSOLE_MESSAGE
)
;
if
(
!
consoleMessageWatcher
)
{
return
true
;
}
const
message
=
"
Looks
like
an
infinite
recursion
?
We
stopped
the
JavaScript
tracer
but
code
may
still
be
running
!
"
;
consoleMessageWatcher
.
emitMessages
(
[
{
arguments
:
[
message
]
styles
:
[
]
level
:
"
logTrace
"
chromeContext
:
this
.
isChromeContext
timeStamp
:
ChromeUtils
.
dateNow
(
)
}
]
)
;
return
false
;
}
onTracingFrame
(
{
frame
depth
formatedDisplayName
prefix
}
)
{
if
(
this
.
logMethod
=
=
LOG_METHODS
.
STDOUT
)
{
return
true
;
}
const
{
script
}
=
frame
;
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
frame
.
offset
)
;
const
args
=
[
prefix
+
"
"
.
repeat
(
depth
+
1
)
frame
.
implementation
"
"
formatedDisplayName
]
;
this
.
throttledConsoleMessages
.
push
(
{
filename
:
script
.
source
.
url
lineNumber
columnNumber
arguments
:
args
styles
:
CONSOLE_ARGS_STYLES
level
:
"
logTrace
"
chromeContext
:
this
.
isChromeContext
sourceId
:
script
.
source
.
id
timeStamp
:
ChromeUtils
.
dateNow
(
)
}
)
;
this
.
throttleLogMessages
(
)
;
return
false
;
}
flushConsoleMessages
(
)
{
const
consoleMessageWatcher
=
getResourceWatcher
(
this
.
targetActor
TYPES
.
CONSOLE_MESSAGE
)
;
if
(
!
consoleMessageWatcher
)
{
return
;
}
const
messages
=
this
.
throttledConsoleMessages
;
this
.
throttledConsoleMessages
=
[
]
;
consoleMessageWatcher
.
emitMessages
(
messages
)
;
}
}
exports
.
TracerActor
=
TracerActor
;
