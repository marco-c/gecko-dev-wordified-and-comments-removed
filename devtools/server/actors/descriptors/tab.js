"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
tabDescriptorSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
descriptors
/
tab
.
js
"
)
;
const
{
connectToFrame
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
connectors
/
frame
-
connector
.
js
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
}
{
global
:
"
contextual
"
}
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
{
global
:
"
contextual
"
}
)
;
const
{
createBrowserElementSessionContext
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
session
-
context
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
WatcherActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
.
js
"
true
)
;
class
TabDescriptorActor
extends
Actor
{
constructor
(
connection
browser
)
{
super
(
connection
tabDescriptorSpec
)
;
this
.
_browser
=
browser
;
}
form
(
)
{
const
form
=
{
actor
:
this
.
actorID
browserId
:
this
.
_browser
.
browserId
browsingContextID
:
this
.
_browser
&
&
this
.
_browser
.
browsingContext
?
this
.
_browser
.
browsingContext
.
id
:
null
isZombieTab
:
this
.
_isZombieTab
(
)
outerWindowID
:
this
.
_getOuterWindowId
(
)
selected
:
this
.
selected
title
:
this
.
_getTitle
(
)
traits
:
{
watcher
:
true
supportsReloadDescriptor
:
true
}
url
:
this
.
_getUrl
(
)
}
;
return
form
;
}
_getTitle
(
)
{
if
(
this
.
_browser
.
contentTitle
)
{
return
this
.
_browser
.
contentTitle
;
}
if
(
this
.
_tabbrowser
)
{
const
tab
=
this
.
_tabbrowser
.
getTabForBrowser
(
this
.
_browser
)
;
if
(
tab
)
{
return
tab
.
label
;
}
}
return
null
;
}
_getUrl
(
)
{
if
(
!
this
.
_browser
|
|
!
this
.
_browser
.
browsingContext
)
{
return
"
"
;
}
const
{
browsingContext
}
=
this
.
_browser
;
return
browsingContext
.
currentWindowGlobal
.
documentURI
.
spec
;
}
_getOuterWindowId
(
)
{
if
(
!
this
.
_browser
|
|
!
this
.
_browser
.
browsingContext
)
{
return
"
"
;
}
const
{
browsingContext
}
=
this
.
_browser
;
return
browsingContext
.
currentWindowGlobal
.
outerWindowId
;
}
get
selected
(
)
{
const
topAppWindow
=
Services
.
wm
.
getMostRecentBrowserWindow
(
)
;
const
selectedBrowser
=
topAppWindow
?
.
gBrowser
?
.
selectedBrowser
;
if
(
!
selectedBrowser
)
{
return
false
;
}
return
this
.
_browser
=
=
=
selectedBrowser
;
}
async
getTarget
(
)
{
if
(
!
this
.
conn
)
{
return
{
error
:
"
tabDestroyed
"
message
:
"
Tab
destroyed
while
performing
a
TabDescriptorActor
update
"
}
;
}
return
new
Promise
(
async
(
resolve
reject
)
=
>
{
const
onDestroy
=
(
)
=
>
{
reject
(
{
error
:
"
tabDestroyed
"
message
:
"
Tab
destroyed
while
performing
a
TabDescriptorActor
update
"
}
)
;
if
(
this
.
watcher
&
&
this
.
targetActorForm
)
{
this
.
watcher
.
notifyTargetDestroyed
(
this
.
targetActorForm
)
;
}
}
;
try
{
if
(
!
this
.
_browser
.
isConnected
)
{
onDestroy
(
)
;
return
;
}
const
connectForm
=
await
connectToFrame
(
this
.
conn
this
.
_browser
onDestroy
)
;
this
.
targetActorForm
=
connectForm
;
resolve
(
connectForm
)
;
}
catch
(
e
)
{
reject
(
{
error
:
"
tabDestroyed
"
message
:
"
Tab
destroyed
while
connecting
to
the
frame
"
}
)
;
}
}
)
;
}
getWatcher
(
config
)
{
if
(
!
this
.
watcher
)
{
this
.
watcher
=
new
WatcherActor
(
this
.
conn
createBrowserElementSessionContext
(
this
.
_browser
{
isServerTargetSwitchingEnabled
:
config
.
isServerTargetSwitchingEnabled
isPopupDebuggingEnabled
:
config
.
isPopupDebuggingEnabled
}
)
)
;
this
.
manage
(
this
.
watcher
)
;
}
return
this
.
watcher
;
}
get
_tabbrowser
(
)
{
if
(
this
.
_browser
&
&
typeof
this
.
_browser
.
getTabBrowser
=
=
"
function
"
)
{
return
this
.
_browser
.
getTabBrowser
(
)
;
}
return
null
;
}
async
getFavicon
(
)
{
if
(
!
AppConstants
.
MOZ_PLACES
)
{
return
null
;
}
try
{
const
{
data
}
=
await
lazy
.
PlacesUtils
.
promiseFaviconData
(
this
.
_getUrl
(
)
)
;
return
data
;
}
catch
(
e
)
{
return
null
;
}
}
_isZombieTab
(
)
{
const
tabbrowser
=
this
.
_tabbrowser
;
const
tab
=
tabbrowser
?
tabbrowser
.
getTabForBrowser
(
this
.
_browser
)
:
null
;
return
tab
?
.
hasAttribute
&
&
tab
.
hasAttribute
(
"
pending
"
)
;
}
reloadDescriptor
(
{
bypassCache
}
)
{
if
(
!
this
.
_browser
|
|
!
this
.
_browser
.
browsingContext
)
{
return
;
}
this
.
_browser
.
browsingContext
.
reload
(
bypassCache
?
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
)
;
}
destroy
(
)
{
this
.
emit
(
"
descriptor
-
destroyed
"
)
;
this
.
_browser
=
null
;
super
.
destroy
(
)
;
}
}
exports
.
TabDescriptorActor
=
TabDescriptorActor
;
