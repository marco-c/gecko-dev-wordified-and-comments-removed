"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
events
=
require
(
"
sdk
/
event
/
core
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
LongStringActor
}
=
require
(
"
devtools
/
server
/
actors
/
string
"
)
;
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
{
isWindowIncluded
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
specs
=
require
(
"
devtools
/
shared
/
specs
/
storage
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
loader
.
lazyImporter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
Sqlite
"
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
)
;
var
gTrackedMessageManager
=
new
Map
(
)
;
const
MAX_STORE_OBJECT_COUNT
=
50
;
const
BATCH_DELAY
=
200
;
const
MAX_COOKIE_EXPIRY
=
Math
.
pow
(
2
62
)
;
var
illegalFileNameCharacters
=
[
"
[
"
"
\
\
x00
-
\
\
x24
"
"
/
:
*
?
\
\
\
"
<
>
|
\
\
\
\
"
"
]
"
]
.
join
(
"
"
)
;
var
ILLEGAL_CHAR_REGEX
=
new
RegExp
(
illegalFileNameCharacters
"
g
"
)
;
var
storageTypePool
=
new
Map
(
)
;
function
sleep
(
time
)
{
let
deferred
=
promise
.
defer
(
)
;
setTimeout
(
(
)
=
>
{
deferred
.
resolve
(
null
)
;
}
time
)
;
return
deferred
.
promise
;
}
var
StorageActors
=
{
}
;
StorageActors
.
defaults
=
function
(
typeName
observationTopic
)
{
return
{
typeName
:
typeName
get
conn
(
)
{
return
this
.
storageActor
.
conn
;
}
get
hosts
(
)
{
let
hosts
=
new
Set
(
)
;
for
(
let
{
location
}
of
this
.
storageActor
.
windows
)
{
hosts
.
add
(
this
.
getHostName
(
location
)
)
;
}
return
hosts
;
}
get
windows
(
)
{
return
this
.
storageActor
.
windows
;
}
getHostName
(
location
)
{
return
location
.
hostname
|
|
location
.
href
;
}
initialize
(
storageActor
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
storageActor
=
storageActor
;
this
.
populateStoresForHosts
(
)
;
if
(
observationTopic
)
{
Services
.
obs
.
addObserver
(
this
observationTopic
false
)
;
}
this
.
onWindowReady
=
this
.
onWindowReady
.
bind
(
this
)
;
this
.
onWindowDestroyed
=
this
.
onWindowDestroyed
.
bind
(
this
)
;
events
.
on
(
this
.
storageActor
"
window
-
ready
"
this
.
onWindowReady
)
;
events
.
on
(
this
.
storageActor
"
window
-
destroyed
"
this
.
onWindowDestroyed
)
;
}
destroy
(
)
{
if
(
observationTopic
)
{
Services
.
obs
.
removeObserver
(
this
observationTopic
false
)
;
}
events
.
off
(
this
.
storageActor
"
window
-
ready
"
this
.
onWindowReady
)
;
events
.
off
(
this
.
storageActor
"
window
-
destroyed
"
this
.
onWindowDestroyed
)
;
this
.
hostVsStores
.
clear
(
)
;
this
.
storageActor
=
null
;
}
getNamesForHost
(
host
)
{
return
[
.
.
.
this
.
hostVsStores
.
get
(
host
)
.
keys
(
)
]
;
}
getValuesForHost
(
host
name
)
{
if
(
name
)
{
return
[
this
.
hostVsStores
.
get
(
host
)
.
get
(
name
)
]
;
}
return
[
.
.
.
this
.
hostVsStores
.
get
(
host
)
.
values
(
)
]
;
}
getObjectsSize
(
host
names
)
{
return
names
.
length
;
}
onWindowReady
:
Task
.
async
(
function
*
(
window
)
{
let
host
=
this
.
getHostName
(
window
.
location
)
;
if
(
!
this
.
hostVsStores
.
has
(
host
)
)
{
yield
this
.
populateStoresForHost
(
host
window
)
;
let
data
=
{
}
;
data
[
host
]
=
this
.
getNamesForHost
(
host
)
;
this
.
storageActor
.
update
(
"
added
"
typeName
data
)
;
}
}
)
onWindowDestroyed
(
window
)
{
if
(
!
window
.
location
)
{
return
;
}
let
host
=
this
.
getHostName
(
window
.
location
)
;
if
(
!
this
.
hosts
.
has
(
host
)
)
{
this
.
hostVsStores
.
delete
(
host
)
;
let
data
=
{
}
;
data
[
host
]
=
[
]
;
this
.
storageActor
.
update
(
"
deleted
"
typeName
data
)
;
}
}
form
(
form
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
let
hosts
=
{
}
;
for
(
let
host
of
this
.
hosts
)
{
hosts
[
host
]
=
[
]
;
}
return
{
actor
:
this
.
actorID
hosts
:
hosts
}
;
}
populateStoresForHosts
(
)
{
this
.
hostVsStores
=
new
Map
(
)
;
for
(
let
host
of
this
.
hosts
)
{
this
.
populateStoresForHost
(
host
)
;
}
}
getStoreObjects
:
Task
.
async
(
function
*
(
host
names
options
=
{
}
)
{
let
offset
=
options
.
offset
|
|
0
;
let
size
=
options
.
size
|
|
MAX_STORE_OBJECT_COUNT
;
if
(
size
>
MAX_STORE_OBJECT_COUNT
)
{
size
=
MAX_STORE_OBJECT_COUNT
;
}
let
sortOn
=
options
.
sortOn
|
|
"
name
"
;
let
toReturn
=
{
offset
:
offset
total
:
0
data
:
[
]
}
;
let
principal
=
null
;
if
(
this
.
typeName
=
=
=
"
indexedDB
"
)
{
let
win
=
this
.
storageActor
.
getWindowFromHost
(
host
)
;
if
(
win
)
{
principal
=
win
.
document
.
nodePrincipal
;
}
}
if
(
names
)
{
for
(
let
name
of
names
)
{
let
values
=
yield
this
.
getValuesForHost
(
host
name
options
this
.
hostVsStores
principal
)
;
let
{
result
objectStores
}
=
values
;
if
(
result
&
&
typeof
result
.
objectsSize
!
=
=
"
undefined
"
)
{
for
(
let
{
key
count
}
of
result
.
objectsSize
)
{
this
.
objectsSize
[
key
]
=
count
;
}
}
if
(
result
)
{
toReturn
.
data
.
push
(
.
.
.
result
.
data
)
;
}
else
if
(
objectStores
)
{
toReturn
.
data
.
push
(
.
.
.
objectStores
)
;
}
else
{
toReturn
.
data
.
push
(
.
.
.
values
)
;
}
}
toReturn
.
total
=
this
.
getObjectsSize
(
host
names
options
)
;
if
(
offset
>
toReturn
.
total
)
{
toReturn
.
offset
=
toReturn
.
total
;
toReturn
.
data
=
[
]
;
}
else
{
toReturn
.
data
=
toReturn
.
data
.
sort
(
(
a
b
)
=
>
{
return
a
[
sortOn
]
-
b
[
sortOn
]
;
}
)
.
slice
(
offset
offset
+
size
)
.
map
(
a
=
>
this
.
toStoreObject
(
a
)
)
;
}
}
else
{
let
obj
=
yield
this
.
getValuesForHost
(
host
undefined
undefined
this
.
hostVsStores
principal
)
;
if
(
obj
.
dbs
)
{
obj
=
obj
.
dbs
;
}
toReturn
.
total
=
obj
.
length
;
if
(
offset
>
toReturn
.
total
)
{
toReturn
.
offset
=
offset
=
toReturn
.
total
;
toReturn
.
data
=
[
]
;
}
else
{
toReturn
.
data
=
obj
.
sort
(
(
a
b
)
=
>
{
return
a
[
sortOn
]
-
b
[
sortOn
]
;
}
)
.
slice
(
offset
offset
+
size
)
.
map
(
object
=
>
this
.
toStoreObject
(
object
)
)
;
}
}
return
toReturn
;
}
)
}
;
}
;
StorageActors
.
createActor
=
function
(
options
=
{
}
overrides
=
{
}
)
{
let
actorObject
=
StorageActors
.
defaults
(
options
.
typeName
options
.
observationTopic
|
|
null
)
;
for
(
let
key
in
overrides
)
{
actorObject
[
key
]
=
overrides
[
key
]
;
}
let
actorSpec
=
specs
.
childSpecs
[
options
.
typeName
]
;
let
actor
=
protocol
.
ActorClassWithSpec
(
actorSpec
actorObject
)
;
storageTypePool
.
set
(
actorObject
.
typeName
actor
)
;
}
;
StorageActors
.
createActor
(
{
typeName
:
"
cookies
"
}
{
initialize
(
storageActor
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
storageActor
=
storageActor
;
this
.
maybeSetupChildProcess
(
)
;
this
.
populateStoresForHosts
(
)
;
this
.
addCookieObservers
(
)
;
this
.
onWindowReady
=
this
.
onWindowReady
.
bind
(
this
)
;
this
.
onWindowDestroyed
=
this
.
onWindowDestroyed
.
bind
(
this
)
;
events
.
on
(
this
.
storageActor
"
window
-
ready
"
this
.
onWindowReady
)
;
events
.
on
(
this
.
storageActor
"
window
-
destroyed
"
this
.
onWindowDestroyed
)
;
}
destroy
(
)
{
this
.
hostVsStores
.
clear
(
)
;
if
(
!
DebuggerServer
.
isInChildProcess
)
{
this
.
removeCookieObservers
(
)
;
}
events
.
off
(
this
.
storageActor
"
window
-
ready
"
this
.
onWindowReady
)
;
events
.
off
(
this
.
storageActor
"
window
-
destroyed
"
this
.
onWindowDestroyed
)
;
this
.
_pendingResponse
=
this
.
storageActor
=
null
;
}
getMatchingHosts
(
cookies
)
{
if
(
!
cookies
.
length
)
{
cookies
=
[
cookies
]
;
}
let
hosts
=
new
Set
(
)
;
for
(
let
host
of
this
.
hosts
)
{
for
(
let
cookie
of
cookies
)
{
if
(
this
.
isCookieAtHost
(
cookie
host
)
)
{
hosts
.
add
(
host
)
;
}
}
}
return
[
.
.
.
hosts
]
;
}
isCookieAtHost
(
cookie
host
)
{
if
(
cookie
.
host
=
=
null
)
{
return
host
=
=
null
;
}
if
(
cookie
.
host
.
startsWith
(
"
.
"
)
)
{
return
(
"
.
"
+
host
)
.
endsWith
(
cookie
.
host
)
;
}
if
(
cookie
.
host
=
=
=
"
"
)
{
return
host
.
startsWith
(
"
file
:
/
/
"
+
cookie
.
path
)
;
}
return
cookie
.
host
=
=
host
;
}
toStoreObject
(
cookie
)
{
if
(
!
cookie
)
{
return
null
;
}
return
{
name
:
cookie
.
name
path
:
cookie
.
path
|
|
"
"
host
:
cookie
.
host
|
|
"
"
expires
:
(
cookie
.
expires
|
|
0
)
*
1000
creationTime
:
cookie
.
creationTime
/
1000
lastAccessed
:
cookie
.
lastAccessed
/
1000
value
:
new
LongStringActor
(
this
.
conn
cookie
.
value
|
|
"
"
)
isDomain
:
cookie
.
isDomain
isSecure
:
cookie
.
isSecure
isHttpOnly
:
cookie
.
isHttpOnly
}
;
}
populateStoresForHost
(
host
)
{
this
.
hostVsStores
.
set
(
host
new
Map
(
)
)
;
let
doc
=
this
.
storageActor
.
document
;
let
cookies
=
this
.
getCookiesFromHost
(
host
doc
.
nodePrincipal
.
originAttributes
)
;
for
(
let
cookie
of
cookies
)
{
if
(
this
.
isCookieAtHost
(
cookie
host
)
)
{
this
.
hostVsStores
.
get
(
host
)
.
set
(
cookie
.
name
cookie
)
;
}
}
}
onCookieChanged
(
subject
topic
action
)
{
if
(
topic
!
=
=
"
cookie
-
changed
"
|
|
!
this
.
storageActor
|
|
!
this
.
storageActor
.
windows
)
{
return
null
;
}
let
hosts
=
this
.
getMatchingHosts
(
subject
)
;
let
data
=
{
}
;
switch
(
action
)
{
case
"
added
"
:
case
"
changed
"
:
if
(
hosts
.
length
)
{
for
(
let
host
of
hosts
)
{
this
.
hostVsStores
.
get
(
host
)
.
set
(
subject
.
name
subject
)
;
data
[
host
]
=
[
subject
.
name
]
;
}
this
.
storageActor
.
update
(
action
"
cookies
"
data
)
;
}
break
;
case
"
deleted
"
:
if
(
hosts
.
length
)
{
for
(
let
host
of
hosts
)
{
this
.
hostVsStores
.
get
(
host
)
.
delete
(
subject
.
name
)
;
data
[
host
]
=
[
subject
.
name
]
;
}
this
.
storageActor
.
update
(
"
deleted
"
"
cookies
"
data
)
;
}
break
;
case
"
batch
-
deleted
"
:
if
(
hosts
.
length
)
{
for
(
let
host
of
hosts
)
{
let
stores
=
[
]
;
for
(
let
cookie
of
subject
)
{
this
.
hostVsStores
.
get
(
host
)
.
delete
(
cookie
.
name
)
;
stores
.
push
(
cookie
.
name
)
;
}
data
[
host
]
=
stores
;
}
this
.
storageActor
.
update
(
"
deleted
"
"
cookies
"
data
)
;
}
break
;
case
"
cleared
"
:
this
.
storageActor
.
update
(
"
cleared
"
"
cookies
"
hosts
)
;
break
;
case
"
reload
"
:
this
.
storageActor
.
update
(
"
reloaded
"
"
cookies
"
hosts
)
;
break
;
}
return
null
;
}
getEditableFields
:
Task
.
async
(
function
*
(
)
{
return
[
"
name
"
"
path
"
"
host
"
"
expires
"
"
value
"
"
isSecure
"
"
isHttpOnly
"
]
;
}
)
editItem
:
Task
.
async
(
function
*
(
data
)
{
let
doc
=
this
.
storageActor
.
document
;
data
.
originAttributes
=
doc
.
nodePrincipal
.
originAttributes
;
this
.
editCookie
(
data
)
;
}
)
removeItem
:
Task
.
async
(
function
*
(
host
name
)
{
let
doc
=
this
.
storageActor
.
document
;
this
.
removeCookie
(
host
name
doc
.
nodePrincipal
.
originAttributes
)
;
}
)
removeAll
:
Task
.
async
(
function
*
(
host
domain
)
{
let
doc
=
this
.
storageActor
.
document
;
this
.
removeAllCookies
(
host
domain
doc
.
nodePrincipal
.
originAttributes
)
;
}
)
maybeSetupChildProcess
(
)
{
cookieHelpers
.
onCookieChanged
=
this
.
onCookieChanged
.
bind
(
this
)
;
if
(
!
DebuggerServer
.
isInChildProcess
)
{
this
.
getCookiesFromHost
=
cookieHelpers
.
getCookiesFromHost
.
bind
(
cookieHelpers
)
;
this
.
addCookieObservers
=
cookieHelpers
.
addCookieObservers
.
bind
(
cookieHelpers
)
;
this
.
removeCookieObservers
=
cookieHelpers
.
removeCookieObservers
.
bind
(
cookieHelpers
)
;
this
.
editCookie
=
cookieHelpers
.
editCookie
.
bind
(
cookieHelpers
)
;
this
.
removeCookie
=
cookieHelpers
.
removeCookie
.
bind
(
cookieHelpers
)
;
this
.
removeAllCookies
=
cookieHelpers
.
removeAllCookies
.
bind
(
cookieHelpers
)
;
return
;
}
const
{
sendSyncMessage
addMessageListener
}
=
this
.
conn
.
parentMessageManager
;
this
.
conn
.
setupInParent
(
{
module
:
"
devtools
/
server
/
actors
/
storage
"
setupParent
:
"
setupParentProcessForCookies
"
}
)
;
this
.
getCookiesFromHost
=
callParentProcess
.
bind
(
null
"
getCookiesFromHost
"
)
;
this
.
addCookieObservers
=
callParentProcess
.
bind
(
null
"
addCookieObservers
"
)
;
this
.
removeCookieObservers
=
callParentProcess
.
bind
(
null
"
removeCookieObservers
"
)
;
this
.
editCookie
=
callParentProcess
.
bind
(
null
"
editCookie
"
)
;
this
.
removeCookie
=
callParentProcess
.
bind
(
null
"
removeCookie
"
)
;
this
.
removeAllCookies
=
callParentProcess
.
bind
(
null
"
removeAllCookies
"
)
;
addMessageListener
(
"
storage
:
storage
-
cookie
-
request
-
child
"
cookieHelpers
.
handleParentRequest
)
;
function
callParentProcess
(
methodName
.
.
.
args
)
{
let
reply
=
sendSyncMessage
(
"
storage
:
storage
-
cookie
-
request
-
parent
"
{
method
:
methodName
args
:
args
}
)
;
if
(
reply
.
length
=
=
=
0
)
{
console
.
error
(
"
ERR_DIRECTOR_CHILD_NO_REPLY
from
"
+
methodName
)
;
}
else
if
(
reply
.
length
>
1
)
{
console
.
error
(
"
ERR_DIRECTOR_CHILD_MULTIPLE_REPLIES
from
"
+
methodName
)
;
}
let
result
=
reply
[
0
]
;
if
(
methodName
=
=
=
"
getCookiesFromHost
"
)
{
return
JSON
.
parse
(
result
)
;
}
return
result
;
}
}
}
)
;
var
cookieHelpers
=
{
getCookiesFromHost
(
host
originAttributes
)
{
if
(
host
.
startsWith
(
"
file
:
/
/
/
"
)
)
{
host
=
"
"
;
}
let
cookies
=
Services
.
cookies
.
getCookiesFromHost
(
host
originAttributes
)
;
let
store
=
[
]
;
while
(
cookies
.
hasMoreElements
(
)
)
{
let
cookie
=
cookies
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsICookie2
)
;
store
.
push
(
cookie
)
;
}
return
store
;
}
editCookie
(
data
)
{
let
{
field
oldValue
newValue
}
=
data
;
let
origName
=
field
=
=
=
"
name
"
?
oldValue
:
data
.
items
.
name
;
let
origHost
=
field
=
=
=
"
host
"
?
oldValue
:
data
.
items
.
host
;
let
origPath
=
field
=
=
=
"
path
"
?
oldValue
:
data
.
items
.
path
;
let
cookie
=
null
;
let
enumerator
=
Services
.
cookies
.
getCookiesFromHost
(
origHost
data
.
originAttributes
|
|
{
}
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
nsiCookie
=
enumerator
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsICookie2
)
;
if
(
nsiCookie
.
name
=
=
=
origName
&
&
nsiCookie
.
host
=
=
=
origHost
)
{
cookie
=
{
host
:
nsiCookie
.
host
path
:
nsiCookie
.
path
name
:
nsiCookie
.
name
value
:
nsiCookie
.
value
isSecure
:
nsiCookie
.
isSecure
isHttpOnly
:
nsiCookie
.
isHttpOnly
isSession
:
nsiCookie
.
isSession
expires
:
nsiCookie
.
expires
originAttributes
:
nsiCookie
.
originAttributes
}
;
break
;
}
}
if
(
!
cookie
)
{
return
;
}
let
now
=
new
Date
(
)
;
if
(
!
cookie
.
isSession
&
&
(
cookie
.
expires
*
1000
)
<
=
now
)
{
let
tenSecondsFromNow
=
(
now
.
getTime
(
)
+
10
*
1000
)
/
1000
;
cookie
.
expires
=
tenSecondsFromNow
;
}
switch
(
field
)
{
case
"
isSecure
"
:
case
"
isHttpOnly
"
:
case
"
isSession
"
:
newValue
=
newValue
=
=
=
"
true
"
;
break
;
case
"
expires
"
:
newValue
=
Date
.
parse
(
newValue
)
/
1000
;
if
(
isNaN
(
newValue
)
)
{
newValue
=
MAX_COOKIE_EXPIRY
;
}
break
;
case
"
host
"
:
case
"
name
"
:
case
"
path
"
:
Services
.
cookies
.
remove
(
origHost
origName
origPath
false
cookie
.
originAttributes
)
;
break
;
}
cookie
[
field
]
=
newValue
;
cookie
.
isSession
=
!
cookie
.
expires
;
Services
.
cookies
.
add
(
cookie
.
host
cookie
.
path
cookie
.
name
cookie
.
value
cookie
.
isSecure
cookie
.
isHttpOnly
cookie
.
isSession
cookie
.
isSession
?
MAX_COOKIE_EXPIRY
:
cookie
.
expires
cookie
.
originAttributes
)
;
}
_removeCookies
(
host
opts
=
{
}
)
{
function
hostMatches
(
cookieHost
matchHost
)
{
if
(
cookieHost
=
=
null
)
{
return
matchHost
=
=
null
;
}
if
(
cookieHost
.
startsWith
(
"
.
"
)
)
{
return
(
"
.
"
+
matchHost
)
.
endsWith
(
cookieHost
)
;
}
return
cookieHost
=
=
host
;
}
let
enumerator
=
Services
.
cookies
.
getCookiesFromHost
(
host
opts
.
originAttributes
|
|
{
}
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
cookie
=
enumerator
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsICookie2
)
;
if
(
hostMatches
(
cookie
.
host
host
)
&
&
(
!
opts
.
name
|
|
cookie
.
name
=
=
=
opts
.
name
)
&
&
(
!
opts
.
domain
|
|
cookie
.
host
=
=
=
opts
.
domain
)
)
{
Services
.
cookies
.
remove
(
cookie
.
host
cookie
.
name
cookie
.
path
false
cookie
.
originAttributes
)
;
}
}
}
removeCookie
(
host
name
originAttributes
)
{
if
(
name
!
=
=
undefined
)
{
this
.
_removeCookies
(
host
{
name
originAttributes
}
)
;
}
}
removeAllCookies
(
host
domain
originAttributes
)
{
this
.
_removeCookies
(
host
{
domain
originAttributes
}
)
;
}
addCookieObservers
(
)
{
Services
.
obs
.
addObserver
(
cookieHelpers
"
cookie
-
changed
"
false
)
;
return
null
;
}
removeCookieObservers
(
)
{
Services
.
obs
.
removeObserver
(
cookieHelpers
"
cookie
-
changed
"
false
)
;
return
null
;
}
observe
(
subject
topic
data
)
{
if
(
!
subject
)
{
return
;
}
switch
(
topic
)
{
case
"
cookie
-
changed
"
:
if
(
data
=
=
=
"
batch
-
deleted
"
)
{
let
cookiesNoInterface
=
subject
.
QueryInterface
(
Ci
.
nsIArray
)
;
let
cookies
=
[
]
;
for
(
let
i
=
0
;
i
<
cookiesNoInterface
.
length
;
i
+
+
)
{
let
cookie
=
cookiesNoInterface
.
queryElementAt
(
i
Ci
.
nsICookie2
)
;
cookies
.
push
(
cookie
)
;
}
cookieHelpers
.
onCookieChanged
(
cookies
topic
data
)
;
return
;
}
let
cookie
=
subject
.
QueryInterface
(
Ci
.
nsICookie2
)
;
cookieHelpers
.
onCookieChanged
(
cookie
topic
data
)
;
break
;
}
}
handleParentRequest
(
msg
)
{
switch
(
msg
.
json
.
method
)
{
case
"
onCookieChanged
"
:
let
[
cookie
topic
data
]
=
msg
.
data
.
args
;
cookie
=
JSON
.
parse
(
cookie
)
;
cookieHelpers
.
onCookieChanged
(
cookie
topic
data
)
;
break
;
}
}
handleChildRequest
(
msg
)
{
switch
(
msg
.
json
.
method
)
{
case
"
getCookiesFromHost
"
:
{
let
host
=
msg
.
data
.
args
[
0
]
;
let
originAttributes
=
msg
.
data
.
args
[
1
]
;
let
cookies
=
cookieHelpers
.
getCookiesFromHost
(
host
originAttributes
)
;
return
JSON
.
stringify
(
cookies
)
;
}
case
"
addCookieObservers
"
:
{
return
cookieHelpers
.
addCookieObservers
(
)
;
}
case
"
removeCookieObservers
"
:
{
return
cookieHelpers
.
removeCookieObservers
(
)
;
}
case
"
editCookie
"
:
{
let
rowdata
=
msg
.
data
.
args
[
0
]
;
return
cookieHelpers
.
editCookie
(
rowdata
)
;
}
case
"
removeCookie
"
:
{
let
host
=
msg
.
data
.
args
[
0
]
;
let
name
=
msg
.
data
.
args
[
1
]
;
let
originAttributes
=
msg
.
data
.
args
[
2
]
;
return
cookieHelpers
.
removeCookie
(
host
name
originAttributes
)
;
}
case
"
removeAllCookies
"
:
{
let
host
=
msg
.
data
.
args
[
0
]
;
let
domain
=
msg
.
data
.
args
[
1
]
;
let
originAttributes
=
msg
.
data
.
args
[
2
]
;
return
cookieHelpers
.
removeAllCookies
(
host
domain
originAttributes
)
;
}
default
:
console
.
error
(
"
ERR_DIRECTOR_PARENT_UNKNOWN_METHOD
"
msg
.
json
.
method
)
;
throw
new
Error
(
"
ERR_DIRECTOR_PARENT_UNKNOWN_METHOD
"
)
;
}
}
}
;
exports
.
setupParentProcessForCookies
=
function
(
{
mm
prefix
}
)
{
cookieHelpers
.
onCookieChanged
=
callChildProcess
.
bind
(
null
"
onCookieChanged
"
)
;
mm
.
addMessageListener
(
"
storage
:
storage
-
cookie
-
request
-
parent
"
cookieHelpers
.
handleChildRequest
)
;
DebuggerServer
.
once
(
"
disconnected
-
from
-
child
:
"
+
prefix
handleMessageManagerDisconnected
)
;
gTrackedMessageManager
.
set
(
"
cookies
"
mm
)
;
function
handleMessageManagerDisconnected
(
evt
{
mm
:
disconnectedMm
}
)
{
if
(
disconnectedMm
!
=
=
mm
|
|
!
gTrackedMessageManager
.
has
(
"
cookies
"
)
)
{
return
;
}
cookieHelpers
.
removeCookieObservers
(
)
;
gTrackedMessageManager
.
delete
(
"
cookies
"
)
;
mm
.
removeMessageListener
(
"
storage
:
storage
-
cookie
-
request
-
parent
"
cookieHelpers
.
handleChildRequest
)
;
}
function
callChildProcess
(
methodName
.
.
.
args
)
{
if
(
methodName
=
=
=
"
onCookieChanged
"
)
{
args
[
0
]
=
JSON
.
stringify
(
args
[
0
]
)
;
}
try
{
mm
.
sendAsyncMessage
(
"
storage
:
storage
-
cookie
-
request
-
child
"
{
method
:
methodName
args
:
args
}
)
;
}
catch
(
e
)
{
}
}
}
;
function
getObjectForLocalOrSessionStorage
(
type
)
{
return
{
getNamesForHost
(
host
)
{
let
storage
=
this
.
hostVsStores
.
get
(
host
)
;
return
storage
?
Object
.
keys
(
storage
)
:
[
]
;
}
getValuesForHost
(
host
name
)
{
let
storage
=
this
.
hostVsStores
.
get
(
host
)
;
if
(
!
storage
)
{
return
[
]
;
}
if
(
name
)
{
let
value
=
storage
?
storage
.
getItem
(
name
)
:
null
;
return
[
{
name
value
}
]
;
}
if
(
!
storage
)
{
return
[
]
;
}
return
Object
.
keys
(
storage
)
.
map
(
key
=
>
(
{
name
:
key
value
:
storage
.
getItem
(
key
)
}
)
)
;
}
getHostName
(
location
)
{
if
(
!
location
.
host
)
{
return
location
.
href
;
}
return
location
.
protocol
+
"
/
/
"
+
location
.
host
;
}
populateStoresForHost
(
host
window
)
{
try
{
this
.
hostVsStores
.
set
(
host
window
[
type
]
)
;
}
catch
(
ex
)
{
console
.
warn
(
Failed
to
enumerate
{
type
}
for
host
{
host
}
:
{
ex
}
)
;
}
}
populateStoresForHosts
(
)
{
this
.
hostVsStores
=
new
Map
(
)
;
for
(
let
window
of
this
.
windows
)
{
this
.
populateStoresForHost
(
this
.
getHostName
(
window
.
location
)
window
)
;
}
}
getEditableFields
:
Task
.
async
(
function
*
(
)
{
return
[
"
name
"
"
value
"
]
;
}
)
editItem
:
Task
.
async
(
function
*
(
{
host
field
oldValue
items
}
)
{
let
storage
=
this
.
hostVsStores
.
get
(
host
)
;
if
(
!
storage
)
{
return
;
}
if
(
field
=
=
=
"
name
"
)
{
storage
.
removeItem
(
oldValue
)
;
}
storage
.
setItem
(
items
.
name
items
.
value
)
;
}
)
removeItem
:
Task
.
async
(
function
*
(
host
name
)
{
let
storage
=
this
.
hostVsStores
.
get
(
host
)
;
if
(
!
storage
)
{
return
;
}
storage
.
removeItem
(
name
)
;
}
)
removeAll
:
Task
.
async
(
function
*
(
host
)
{
let
storage
=
this
.
hostVsStores
.
get
(
host
)
;
if
(
!
storage
)
{
return
;
}
storage
.
clear
(
)
;
}
)
observe
(
subject
topic
data
)
{
if
(
topic
!
=
"
dom
-
storage2
-
changed
"
|
|
data
!
=
type
)
{
return
null
;
}
let
host
=
this
.
getSchemaAndHost
(
subject
.
url
)
;
if
(
!
this
.
hostVsStores
.
has
(
host
)
)
{
return
null
;
}
let
action
=
"
changed
"
;
if
(
subject
.
key
=
=
null
)
{
return
this
.
storageActor
.
update
(
"
cleared
"
type
[
host
]
)
;
}
else
if
(
subject
.
oldValue
=
=
null
)
{
action
=
"
added
"
;
}
else
if
(
subject
.
newValue
=
=
null
)
{
action
=
"
deleted
"
;
}
let
updateData
=
{
}
;
updateData
[
host
]
=
[
subject
.
key
]
;
return
this
.
storageActor
.
update
(
action
type
updateData
)
;
}
getSchemaAndHost
(
url
)
{
let
uri
=
Services
.
io
.
newURI
(
url
null
null
)
;
if
(
!
uri
.
host
)
{
return
uri
.
spec
;
}
return
uri
.
scheme
+
"
:
/
/
"
+
uri
.
hostPort
;
}
toStoreObject
(
item
)
{
if
(
!
item
)
{
return
null
;
}
return
{
name
:
item
.
name
value
:
new
LongStringActor
(
this
.
conn
item
.
value
|
|
"
"
)
}
;
}
}
;
}
StorageActors
.
createActor
(
{
typeName
:
"
localStorage
"
observationTopic
:
"
dom
-
storage2
-
changed
"
}
getObjectForLocalOrSessionStorage
(
"
localStorage
"
)
)
;
StorageActors
.
createActor
(
{
typeName
:
"
sessionStorage
"
observationTopic
:
"
dom
-
storage2
-
changed
"
}
getObjectForLocalOrSessionStorage
(
"
sessionStorage
"
)
)
;
StorageActors
.
createActor
(
{
typeName
:
"
Cache
"
}
{
getCachesForHost
:
Task
.
async
(
function
*
(
host
)
{
let
uri
=
Services
.
io
.
newURI
(
host
null
null
)
;
let
principal
=
Services
.
scriptSecurityManager
.
getNoAppCodebasePrincipal
(
uri
)
;
let
{
CacheStorage
}
=
this
.
storageActor
.
window
;
let
cache
=
new
CacheStorage
(
"
content
"
principal
)
;
return
cache
;
}
)
preListStores
:
Task
.
async
(
function
*
(
)
{
for
(
let
host
of
this
.
hosts
)
{
yield
this
.
populateStoresForHost
(
host
)
;
}
}
)
form
(
form
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
let
hosts
=
{
}
;
for
(
let
host
of
this
.
hosts
)
{
hosts
[
host
]
=
this
.
getNamesForHost
(
host
)
;
}
return
{
actor
:
this
.
actorID
hosts
:
hosts
}
;
}
getNamesForHost
(
host
)
{
return
[
.
.
.
this
.
hostVsStores
.
get
(
host
)
.
keys
(
)
]
.
map
(
a
=
>
{
return
JSON
.
stringify
(
[
a
]
)
;
}
)
;
}
getValuesForHost
:
Task
.
async
(
function
*
(
host
name
)
{
if
(
!
name
)
{
return
[
]
;
}
name
=
JSON
.
parse
(
name
)
[
0
]
;
let
cache
=
this
.
hostVsStores
.
get
(
host
)
.
get
(
name
)
;
let
requests
=
yield
cache
.
keys
(
)
;
let
results
=
[
]
;
for
(
let
request
of
requests
)
{
let
response
=
yield
cache
.
match
(
request
)
;
response
=
response
.
cloneUnfiltered
(
)
;
results
.
push
(
yield
this
.
processEntry
(
request
response
)
)
;
}
return
results
;
}
)
processEntry
:
Task
.
async
(
function
*
(
request
response
)
{
return
{
url
:
String
(
request
.
url
)
status
:
String
(
response
.
statusText
)
}
;
}
)
getHostName
(
location
)
{
if
(
!
location
.
host
)
{
return
location
.
href
;
}
return
location
.
protocol
+
"
/
/
"
+
location
.
host
;
}
populateStoresForHost
:
Task
.
async
(
function
*
(
host
)
{
let
storeMap
=
new
Map
(
)
;
let
caches
=
yield
this
.
getCachesForHost
(
host
)
;
try
{
for
(
let
name
of
(
yield
caches
.
keys
(
)
)
)
{
storeMap
.
set
(
name
(
yield
caches
.
open
(
name
)
)
)
;
}
}
catch
(
ex
)
{
console
.
warn
(
Failed
to
enumerate
CacheStorage
for
host
{
host
}
:
{
ex
}
)
;
}
this
.
hostVsStores
.
set
(
host
storeMap
)
;
}
)
populateStoresForHosts
(
)
{
this
.
hostVsStores
=
new
Map
(
)
;
}
getSchemaAndHost
(
url
)
{
let
uri
=
Services
.
io
.
newURI
(
url
null
null
)
;
return
uri
.
scheme
+
"
:
/
/
"
+
uri
.
hostPort
;
}
toStoreObject
(
item
)
{
return
item
;
}
}
)
;
function
IndexMetadata
(
index
)
{
this
.
_name
=
index
.
name
;
this
.
_keyPath
=
index
.
keyPath
;
this
.
_unique
=
index
.
unique
;
this
.
_multiEntry
=
index
.
multiEntry
;
}
IndexMetadata
.
prototype
=
{
toObject
(
)
{
return
{
name
:
this
.
_name
keyPath
:
this
.
_keyPath
unique
:
this
.
_unique
multiEntry
:
this
.
_multiEntry
}
;
}
}
;
function
ObjectStoreMetadata
(
objectStore
)
{
this
.
_name
=
objectStore
.
name
;
this
.
_keyPath
=
objectStore
.
keyPath
;
this
.
_autoIncrement
=
objectStore
.
autoIncrement
;
this
.
_indexes
=
[
]
;
for
(
let
i
=
0
;
i
<
objectStore
.
indexNames
.
length
;
i
+
+
)
{
let
index
=
objectStore
.
index
(
objectStore
.
indexNames
[
i
]
)
;
let
newIndex
=
{
keypath
:
index
.
keyPath
multiEntry
:
index
.
multiEntry
name
:
index
.
name
objectStore
:
{
autoIncrement
:
index
.
objectStore
.
autoIncrement
indexNames
:
[
.
.
.
index
.
objectStore
.
indexNames
]
keyPath
:
index
.
objectStore
.
keyPath
name
:
index
.
objectStore
.
name
}
}
;
this
.
_indexes
.
push
(
[
newIndex
new
IndexMetadata
(
index
)
]
)
;
}
}
ObjectStoreMetadata
.
prototype
=
{
toObject
(
)
{
return
{
name
:
this
.
_name
keyPath
:
this
.
_keyPath
autoIncrement
:
this
.
_autoIncrement
indexes
:
JSON
.
stringify
(
[
.
.
.
this
.
_indexes
.
values
(
)
]
.
map
(
index
=
>
index
.
toObject
(
)
)
)
}
;
}
}
;
function
DatabaseMetadata
(
origin
db
)
{
this
.
_origin
=
origin
;
this
.
_name
=
db
.
name
;
this
.
_version
=
db
.
version
;
this
.
_objectStores
=
[
]
;
if
(
db
.
objectStoreNames
.
length
)
{
let
transaction
=
db
.
transaction
(
db
.
objectStoreNames
"
readonly
"
)
;
for
(
let
i
=
0
;
i
<
transaction
.
objectStoreNames
.
length
;
i
+
+
)
{
let
objectStore
=
transaction
.
objectStore
(
transaction
.
objectStoreNames
[
i
]
)
;
this
.
_objectStores
.
push
(
[
transaction
.
objectStoreNames
[
i
]
new
ObjectStoreMetadata
(
objectStore
)
]
)
;
}
}
}
DatabaseMetadata
.
prototype
=
{
get
objectStores
(
)
{
return
this
.
_objectStores
;
}
toObject
(
)
{
return
{
name
:
this
.
_name
origin
:
this
.
_origin
version
:
this
.
_version
objectStores
:
this
.
_objectStores
.
size
}
;
}
}
;
StorageActors
.
createActor
(
{
typeName
:
"
indexedDB
"
}
{
initialize
(
storageActor
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
storageActor
=
storageActor
;
this
.
maybeSetupChildProcess
(
)
;
this
.
objectsSize
=
{
}
;
this
.
storageActor
=
storageActor
;
this
.
onWindowReady
=
this
.
onWindowReady
.
bind
(
this
)
;
this
.
onWindowDestroyed
=
this
.
onWindowDestroyed
.
bind
(
this
)
;
events
.
on
(
this
.
storageActor
"
window
-
ready
"
this
.
onWindowReady
)
;
events
.
on
(
this
.
storageActor
"
window
-
destroyed
"
this
.
onWindowDestroyed
)
;
}
destroy
(
)
{
this
.
hostVsStores
.
clear
(
)
;
this
.
objectsSize
=
null
;
events
.
off
(
this
.
storageActor
"
window
-
ready
"
this
.
onWindowReady
)
;
events
.
off
(
this
.
storageActor
"
window
-
destroyed
"
this
.
onWindowDestroyed
)
;
}
removeDatabase
:
Task
.
async
(
function
*
(
host
name
)
{
let
win
=
this
.
storageActor
.
getWindowFromHost
(
host
)
;
if
(
!
win
)
{
return
{
error
:
Window
for
host
{
host
}
not
found
}
;
}
let
principal
=
win
.
document
.
nodePrincipal
;
return
this
.
removeDB
(
host
principal
name
)
;
}
)
getHostName
(
location
)
{
if
(
!
location
.
host
)
{
return
location
.
href
;
}
return
location
.
protocol
+
"
/
/
"
+
location
.
host
;
}
populateStoresForHosts
(
)
{
}
getNamesForHost
(
host
)
{
let
names
=
[
]
;
for
(
let
[
dbName
{
objectStores
}
]
of
this
.
hostVsStores
.
get
(
host
)
)
{
if
(
objectStores
.
size
)
{
for
(
let
objectStore
of
objectStores
.
keys
(
)
)
{
names
.
push
(
JSON
.
stringify
(
[
dbName
objectStore
]
)
)
;
}
}
else
{
names
.
push
(
JSON
.
stringify
(
[
dbName
]
)
)
;
}
}
return
names
;
}
getObjectsSize
(
host
names
options
)
{
let
name
=
names
[
0
]
;
let
parsedName
=
JSON
.
parse
(
name
)
;
if
(
parsedName
.
length
=
=
3
)
{
return
names
.
length
;
}
else
if
(
parsedName
.
length
=
=
2
)
{
let
index
=
options
.
index
;
let
[
db
objectStore
]
=
parsedName
;
if
(
this
.
objectsSize
[
host
+
db
+
objectStore
+
index
]
)
{
return
this
.
objectsSize
[
host
+
db
+
objectStore
+
index
]
;
}
}
else
if
(
parsedName
.
length
=
=
1
)
{
if
(
this
.
hostVsStores
.
has
(
host
)
&
&
this
.
hostVsStores
.
get
(
host
)
.
has
(
parsedName
[
0
]
)
)
{
return
this
.
hostVsStores
.
get
(
host
)
.
get
(
parsedName
[
0
]
)
.
objectStores
.
size
;
}
}
else
if
(
!
parsedName
|
|
!
parsedName
.
length
)
{
if
(
this
.
hostVsStores
.
has
(
host
)
)
{
return
this
.
hostVsStores
.
get
(
host
)
.
size
;
}
}
return
0
;
}
preListStores
:
Task
.
async
(
function
*
(
)
{
this
.
hostVsStores
=
new
Map
(
)
;
for
(
let
host
of
this
.
hosts
)
{
yield
this
.
populateStoresForHost
(
host
)
;
}
}
)
populateStoresForHost
:
Task
.
async
(
function
*
(
host
)
{
let
storeMap
=
new
Map
(
)
;
let
{
names
}
=
yield
this
.
getDBNamesForHost
(
host
)
;
let
win
=
this
.
storageActor
.
getWindowFromHost
(
host
)
;
if
(
win
)
{
let
principal
=
win
.
document
.
nodePrincipal
;
for
(
let
name
of
names
)
{
let
metadata
=
yield
this
.
getDBMetaData
(
host
principal
name
)
;
metadata
=
indexedDBHelpers
.
patchMetadataMapsAndProtos
(
metadata
)
;
storeMap
.
set
(
name
metadata
)
;
}
}
this
.
hostVsStores
.
set
(
host
storeMap
)
;
}
)
toStoreObject
(
item
)
{
if
(
!
item
)
{
return
null
;
}
if
(
"
indexes
"
in
item
)
{
return
{
objectStore
:
item
.
name
keyPath
:
item
.
keyPath
autoIncrement
:
item
.
autoIncrement
indexes
:
item
.
indexes
}
;
}
if
(
"
objectStores
"
in
item
)
{
return
{
db
:
item
.
name
origin
:
item
.
origin
version
:
item
.
version
objectStores
:
item
.
objectStores
}
;
}
return
{
name
:
item
.
name
value
:
new
LongStringActor
(
this
.
conn
JSON
.
stringify
(
item
.
value
)
)
}
;
}
form
(
form
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
let
hosts
=
{
}
;
for
(
let
host
of
this
.
hosts
)
{
hosts
[
host
]
=
this
.
getNamesForHost
(
host
)
;
}
return
{
actor
:
this
.
actorID
hosts
:
hosts
}
;
}
onDatabaseRemoved
(
host
name
)
{
if
(
this
.
hostVsStores
.
has
(
host
)
)
{
this
.
hostVsStores
.
get
(
host
)
.
delete
(
name
)
;
}
this
.
storageActor
.
update
(
"
deleted
"
"
indexedDB
"
{
[
host
]
:
[
JSON
.
stringify
(
[
name
]
)
]
}
)
;
}
maybeSetupChildProcess
(
)
{
if
(
!
DebuggerServer
.
isInChildProcess
)
{
this
.
backToChild
=
(
func
rv
)
=
>
rv
;
this
.
getDBMetaData
=
indexedDBHelpers
.
getDBMetaData
;
this
.
openWithPrincipal
=
indexedDBHelpers
.
openWithPrincipal
;
this
.
getDBNamesForHost
=
indexedDBHelpers
.
getDBNamesForHost
;
this
.
getSanitizedHost
=
indexedDBHelpers
.
getSanitizedHost
;
this
.
getNameFromDatabaseFile
=
indexedDBHelpers
.
getNameFromDatabaseFile
;
this
.
getValuesForHost
=
indexedDBHelpers
.
getValuesForHost
;
this
.
getObjectStoreData
=
indexedDBHelpers
.
getObjectStoreData
;
this
.
removeDB
=
indexedDBHelpers
.
removeDB
;
return
;
}
const
{
sendAsyncMessage
addMessageListener
}
=
this
.
conn
.
parentMessageManager
;
this
.
conn
.
setupInParent
(
{
module
:
"
devtools
/
server
/
actors
/
storage
"
setupParent
:
"
setupParentProcessForIndexedDB
"
}
)
;
this
.
getDBMetaData
=
callParentProcessAsync
.
bind
(
null
"
getDBMetaData
"
)
;
this
.
getDBNamesForHost
=
callParentProcessAsync
.
bind
(
null
"
getDBNamesForHost
"
)
;
this
.
getValuesForHost
=
callParentProcessAsync
.
bind
(
null
"
getValuesForHost
"
)
;
this
.
removeDB
=
callParentProcessAsync
.
bind
(
null
"
removeDB
"
)
;
addMessageListener
(
"
storage
:
storage
-
indexedDB
-
request
-
child
"
msg
=
>
{
switch
(
msg
.
json
.
method
)
{
case
"
backToChild
"
:
{
let
[
func
rv
]
=
msg
.
json
.
args
;
let
deferred
=
unresolvedPromises
.
get
(
func
)
;
if
(
deferred
)
{
unresolvedPromises
.
delete
(
func
)
;
deferred
.
resolve
(
rv
)
;
}
break
;
}
case
"
onDatabaseRemoved
"
:
{
let
[
host
name
]
=
msg
.
json
.
args
;
this
.
onDatabaseRemoved
(
host
name
)
;
}
}
}
)
;
let
unresolvedPromises
=
new
Map
(
)
;
function
callParentProcessAsync
(
methodName
.
.
.
args
)
{
let
deferred
=
promise
.
defer
(
)
;
unresolvedPromises
.
set
(
methodName
deferred
)
;
sendAsyncMessage
(
"
storage
:
storage
-
indexedDB
-
request
-
parent
"
{
method
:
methodName
args
:
args
}
)
;
return
deferred
.
promise
;
}
}
}
)
;
var
indexedDBHelpers
=
{
backToChild
(
.
.
.
args
)
{
let
mm
=
Cc
[
"
mozilla
.
org
/
globalmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsIMessageListenerManager
)
;
mm
.
broadcastAsyncMessage
(
"
storage
:
storage
-
indexedDB
-
request
-
child
"
{
method
:
"
backToChild
"
args
:
args
}
)
;
}
onDatabaseRemoved
:
function
(
host
name
)
{
let
mm
=
Cc
[
"
mozilla
.
org
/
globalmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsIMessageListenerManager
)
;
mm
.
broadcastAsyncMessage
(
"
storage
:
storage
-
indexedDB
-
request
-
child
"
{
method
:
"
onDatabaseRemoved
"
args
:
[
host
name
]
}
)
;
}
getDBMetaData
:
Task
.
async
(
function
*
(
host
principal
name
)
{
let
request
=
this
.
openWithPrincipal
(
principal
name
)
;
let
success
=
promise
.
defer
(
)
;
request
.
onsuccess
=
event
=
>
{
let
db
=
event
.
target
.
result
;
let
dbData
=
new
DatabaseMetadata
(
host
db
)
;
db
.
close
(
)
;
success
.
resolve
(
this
.
backToChild
(
"
getDBMetaData
"
dbData
)
)
;
}
;
request
.
onerror
=
(
)
=
>
{
console
.
error
(
Error
opening
indexeddb
database
{
name
}
for
host
{
host
}
)
;
success
.
resolve
(
this
.
backToChild
(
"
getDBMetaData
"
null
)
)
;
}
;
return
success
.
promise
;
}
)
openWithPrincipal
(
principal
name
)
{
return
require
(
"
indexedDB
"
)
.
openForPrincipal
(
principal
name
)
;
}
removeDB
:
Task
.
async
(
function
*
(
host
principal
name
)
{
let
request
=
require
(
"
indexedDB
"
)
.
deleteForPrincipal
(
principal
name
)
;
let
result
=
new
promise
(
resolve
=
>
{
request
.
onsuccess
=
(
)
=
>
{
resolve
(
{
}
)
;
this
.
onDatabaseRemoved
(
host
name
)
;
}
;
request
.
onblocked
=
(
)
=
>
{
console
.
error
(
Deleting
indexedDB
database
{
name
}
for
host
{
host
}
is
blocked
)
;
resolve
(
{
blocked
:
true
}
)
;
}
;
request
.
onerror
=
(
)
=
>
{
console
.
error
(
Error
deleting
indexedDB
database
{
name
}
for
host
{
host
}
)
;
resolve
(
{
error
:
request
.
error
}
)
;
}
;
setTimeout
(
(
)
=
>
resolve
(
{
blocked
:
true
}
)
3000
)
;
}
)
;
return
this
.
backToChild
(
"
removeDB
"
yield
result
)
;
}
)
getDBNamesForHost
:
Task
.
async
(
function
*
(
host
)
{
let
sanitizedHost
=
this
.
getSanitizedHost
(
host
)
;
let
directory
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
storage
"
"
default
"
sanitizedHost
"
idb
"
)
;
let
exists
=
yield
OS
.
File
.
exists
(
directory
)
;
if
(
!
exists
&
&
host
.
startsWith
(
"
about
:
"
)
)
{
sanitizedHost
=
this
.
getSanitizedHost
(
"
moz
-
safe
-
"
+
host
)
;
directory
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
storage
"
"
permanent
"
sanitizedHost
"
idb
"
)
;
exists
=
yield
OS
.
File
.
exists
(
directory
)
;
}
if
(
!
exists
)
{
return
this
.
backToChild
(
"
getDBNamesForHost
"
{
names
:
[
]
}
)
;
}
let
names
=
[
]
;
let
dirIterator
=
new
OS
.
File
.
DirectoryIterator
(
directory
)
;
try
{
yield
dirIterator
.
forEach
(
file
=
>
{
if
(
file
.
isDir
)
{
return
null
;
}
if
(
!
file
.
name
.
endsWith
(
"
.
sqlite
"
)
)
{
return
null
;
}
return
this
.
getNameFromDatabaseFile
(
file
.
path
)
.
then
(
name
=
>
{
if
(
name
)
{
names
.
push
(
name
)
;
}
return
null
;
}
)
;
}
)
;
}
finally
{
dirIterator
.
close
(
)
;
}
return
this
.
backToChild
(
"
getDBNamesForHost
"
{
names
:
names
}
)
;
}
)
getSanitizedHost
(
host
)
{
return
host
.
replace
(
ILLEGAL_CHAR_REGEX
"
+
"
)
;
}
getNameFromDatabaseFile
:
Task
.
async
(
function
*
(
path
)
{
let
connection
=
null
;
let
retryCount
=
0
;
while
(
!
connection
&
&
retryCount
+
+
<
25
)
{
try
{
connection
=
yield
Sqlite
.
openConnection
(
{
path
:
path
}
)
;
}
catch
(
ex
)
{
yield
sleep
(
100
)
;
}
}
if
(
!
connection
)
{
return
null
;
}
let
rows
=
yield
connection
.
execute
(
"
SELECT
name
FROM
database
"
)
;
if
(
rows
.
length
!
=
1
)
{
return
null
;
}
let
name
=
rows
[
0
]
.
getResultByName
(
"
name
"
)
;
yield
connection
.
close
(
)
;
return
name
;
}
)
getValuesForHost
:
Task
.
async
(
function
*
(
host
name
=
"
null
"
options
hostVsStores
principal
)
{
name
=
JSON
.
parse
(
name
)
;
if
(
!
name
|
|
!
name
.
length
)
{
let
dbs
=
[
]
;
if
(
hostVsStores
.
has
(
host
)
)
{
for
(
let
[
db
]
of
hostVsStores
.
get
(
host
)
)
{
db
=
indexedDBHelpers
.
patchMetadataMapsAndProtos
(
db
)
;
dbs
.
push
(
db
.
toObject
(
)
)
;
}
}
return
this
.
backToChild
(
"
getValuesForHost
"
{
dbs
:
dbs
}
)
;
}
let
[
db2
objectStore
id
]
=
name
;
if
(
!
objectStore
)
{
let
objectStores
=
[
]
;
if
(
hostVsStores
.
has
(
host
)
&
&
hostVsStores
.
get
(
host
)
.
has
(
db2
)
)
{
let
db
=
hostVsStores
.
get
(
host
)
.
get
(
db2
)
;
db
=
indexedDBHelpers
.
patchMetadataMapsAndProtos
(
db
)
;
let
objectStores2
=
db
.
objectStores
;
for
(
let
objectStore2
of
objectStores2
)
{
objectStores
.
push
(
objectStore2
[
1
]
.
toObject
(
)
)
;
}
}
return
this
.
backToChild
(
"
getValuesForHost
"
{
objectStores
:
objectStores
}
)
;
}
let
result
=
yield
this
.
getObjectStoreData
(
host
principal
db2
objectStore
id
options
.
index
options
.
size
)
;
return
this
.
backToChild
(
"
getValuesForHost
"
{
result
:
result
}
)
;
}
)
getObjectStoreData
(
host
principal
dbName
objectStore
id
index
offset
size
)
{
let
request
=
this
.
openWithPrincipal
(
principal
dbName
)
;
let
success
=
promise
.
defer
(
)
;
let
data
=
[
]
;
let
db
;
if
(
!
size
|
|
size
>
MAX_STORE_OBJECT_COUNT
)
{
size
=
MAX_STORE_OBJECT_COUNT
;
}
request
.
onsuccess
=
event
=
>
{
db
=
event
.
target
.
result
;
let
transaction
=
db
.
transaction
(
objectStore
"
readonly
"
)
;
let
source
=
transaction
.
objectStore
(
objectStore
)
;
if
(
index
&
&
index
!
=
"
name
"
)
{
source
=
source
.
index
(
index
)
;
}
source
.
count
(
)
.
onsuccess
=
event2
=
>
{
let
objectsSize
=
[
]
;
let
count
=
event2
.
target
.
result
;
objectsSize
.
push
(
{
key
:
host
+
dbName
+
objectStore
+
index
count
:
count
}
)
;
if
(
!
offset
)
{
offset
=
0
;
}
else
if
(
offset
>
count
)
{
db
.
close
(
)
;
success
.
resolve
(
[
]
)
;
return
;
}
if
(
id
)
{
source
.
get
(
id
)
.
onsuccess
=
event3
=
>
{
db
.
close
(
)
;
success
.
resolve
(
[
{
name
:
id
value
:
event3
.
target
.
result
}
]
)
;
}
;
}
else
{
source
.
openCursor
(
)
.
onsuccess
=
event4
=
>
{
let
cursor
=
event4
.
target
.
result
;
if
(
!
cursor
|
|
data
.
length
>
=
size
)
{
db
.
close
(
)
;
success
.
resolve
(
{
data
:
data
objectsSize
:
objectsSize
}
)
;
return
;
}
if
(
offset
-
-
<
=
0
)
{
data
.
push
(
{
name
:
cursor
.
key
value
:
cursor
.
value
}
)
;
}
cursor
.
continue
(
)
;
}
;
}
}
;
}
;
request
.
onerror
=
(
)
=
>
{
db
.
close
(
)
;
success
.
resolve
(
[
]
)
;
}
;
return
success
.
promise
;
}
patchMetadataMapsAndProtos
(
metadata
)
{
let
md
=
Object
.
create
(
DatabaseMetadata
.
prototype
)
;
Object
.
assign
(
md
metadata
)
;
md
.
_objectStores
=
new
Map
(
metadata
.
_objectStores
)
;
for
(
let
[
name
store
]
of
md
.
_objectStores
)
{
let
obj
=
Object
.
create
(
ObjectStoreMetadata
.
prototype
)
;
Object
.
assign
(
obj
store
)
;
md
.
_objectStores
.
set
(
name
obj
)
;
if
(
typeof
store
.
_indexes
.
length
!
=
=
"
undefined
"
)
{
obj
.
_indexes
=
new
Map
(
store
.
_indexes
)
;
}
for
(
let
[
name2
value
]
of
obj
.
_indexes
)
{
let
obj2
=
Object
.
create
(
IndexMetadata
.
prototype
)
;
Object
.
assign
(
obj2
value
)
;
obj
.
_indexes
.
set
(
name2
obj2
)
;
}
}
return
md
;
}
handleChildRequest
(
msg
)
{
let
args
=
msg
.
data
.
args
;
switch
(
msg
.
json
.
method
)
{
case
"
getDBMetaData
"
:
{
let
[
host
principal
name
]
=
args
;
return
indexedDBHelpers
.
getDBMetaData
(
host
principal
name
)
;
}
case
"
getDBNamesForHost
"
:
{
let
[
host
]
=
args
;
return
indexedDBHelpers
.
getDBNamesForHost
(
host
)
;
}
case
"
getValuesForHost
"
:
{
let
[
host
name
options
hostVsStores
principal
]
=
args
;
return
indexedDBHelpers
.
getValuesForHost
(
host
name
options
hostVsStores
principal
)
;
}
case
"
removeDB
"
:
{
let
[
host
principal
name
]
=
args
;
return
indexedDBHelpers
.
removeDB
(
host
principal
name
)
;
}
default
:
console
.
error
(
"
ERR_DIRECTOR_PARENT_UNKNOWN_METHOD
"
msg
.
json
.
method
)
;
throw
new
Error
(
"
ERR_DIRECTOR_PARENT_UNKNOWN_METHOD
"
)
;
}
}
}
;
exports
.
setupParentProcessForIndexedDB
=
function
(
{
mm
prefix
}
)
{
mm
.
addMessageListener
(
"
storage
:
storage
-
indexedDB
-
request
-
parent
"
indexedDBHelpers
.
handleChildRequest
)
;
DebuggerServer
.
once
(
"
disconnected
-
from
-
child
:
"
+
prefix
handleMessageManagerDisconnected
)
;
gTrackedMessageManager
.
set
(
"
indexedDB
"
mm
)
;
function
handleMessageManagerDisconnected
(
evt
{
mm
:
disconnectedMm
}
)
{
if
(
disconnectedMm
!
=
=
mm
|
|
!
gTrackedMessageManager
.
has
(
"
indexedDB
"
)
)
{
return
;
}
gTrackedMessageManager
.
delete
(
"
indexedDB
"
)
;
mm
.
removeMessageListener
(
"
storage
:
storage
-
indexedDB
-
request
-
parent
"
indexedDBHelpers
.
handleChildRequest
)
;
}
}
;
let
StorageActor
=
protocol
.
ActorClassWithSpec
(
specs
.
storageSpec
{
typeName
:
"
storage
"
get
window
(
)
{
return
this
.
parentActor
.
window
;
}
get
document
(
)
{
return
this
.
parentActor
.
window
.
document
;
}
get
windows
(
)
{
return
this
.
childWindowPool
;
}
initialize
(
conn
tabActor
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
conn
=
conn
;
this
.
parentActor
=
tabActor
;
this
.
childActorPool
=
new
Map
(
)
;
this
.
childWindowPool
=
new
Set
(
)
;
this
.
fetchChildWindows
(
this
.
parentActor
.
docShell
)
;
for
(
let
[
store
ActorConstructor
]
of
storageTypePool
)
{
this
.
childActorPool
.
set
(
store
new
ActorConstructor
(
this
)
)
;
}
Services
.
obs
.
addObserver
(
this
"
content
-
document
-
global
-
created
"
false
)
;
Services
.
obs
.
addObserver
(
this
"
inner
-
window
-
destroyed
"
false
)
;
this
.
onPageChange
=
this
.
onPageChange
.
bind
(
this
)
;
let
handler
=
tabActor
.
chromeEventHandler
;
handler
.
addEventListener
(
"
pageshow
"
this
.
onPageChange
true
)
;
handler
.
addEventListener
(
"
pagehide
"
this
.
onPageChange
true
)
;
this
.
destroyed
=
false
;
this
.
boundUpdate
=
{
}
;
}
destroy
(
)
{
clearTimeout
(
this
.
batchTimer
)
;
this
.
batchTimer
=
null
;
Services
.
obs
.
removeObserver
(
this
"
content
-
document
-
global
-
created
"
false
)
;
Services
.
obs
.
removeObserver
(
this
"
inner
-
window
-
destroyed
"
false
)
;
this
.
destroyed
=
true
;
if
(
this
.
parentActor
.
browser
)
{
this
.
parentActor
.
browser
.
removeEventListener
(
"
pageshow
"
this
.
onPageChange
true
)
;
this
.
parentActor
.
browser
.
removeEventListener
(
"
pagehide
"
this
.
onPageChange
true
)
;
}
for
(
let
actor
of
this
.
childActorPool
.
values
(
)
)
{
actor
.
destroy
(
)
;
}
this
.
childActorPool
.
clear
(
)
;
this
.
childWindowPool
.
clear
(
)
;
this
.
childWindowPool
=
this
.
childActorPool
=
this
.
__poolMap
=
this
.
conn
=
this
.
parentActor
=
this
.
boundUpdate
=
this
.
registeredPool
=
this
.
_pendingResponse
=
null
;
}
fetchChildWindows
(
item
)
{
let
docShell
=
item
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
;
if
(
!
docShell
.
contentViewer
)
{
return
null
;
}
let
window
=
docShell
.
contentViewer
.
DOMDocument
.
defaultView
;
if
(
window
.
location
.
href
=
=
"
about
:
blank
"
)
{
return
null
;
}
this
.
childWindowPool
.
add
(
window
)
;
for
(
let
i
=
0
;
i
<
docShell
.
childCount
;
i
+
+
)
{
let
child
=
docShell
.
getChildAt
(
i
)
;
this
.
fetchChildWindows
(
child
)
;
}
return
null
;
}
isIncludedInTopLevelWindow
(
window
)
{
return
isWindowIncluded
(
this
.
window
window
)
;
}
getWindowFromInnerWindowID
(
innerID
)
{
innerID
=
innerID
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
;
for
(
let
win
of
this
.
childWindowPool
.
values
(
)
)
{
let
id
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
if
(
id
=
=
innerID
)
{
return
win
;
}
}
return
null
;
}
getWindowFromHost
(
host
)
{
for
(
let
win
of
this
.
childWindowPool
.
values
(
)
)
{
let
origin
=
win
.
document
.
nodePrincipal
.
originNoSuffix
;
let
url
=
win
.
document
.
URL
;
if
(
origin
=
=
=
host
|
|
url
=
=
=
host
)
{
return
win
;
}
}
return
null
;
}
observe
(
subject
topic
)
{
if
(
subject
.
location
&
&
(
!
subject
.
location
.
href
|
|
subject
.
location
.
href
=
=
"
about
:
blank
"
)
)
{
return
null
;
}
if
(
topic
=
=
"
content
-
document
-
global
-
created
"
&
&
this
.
isIncludedInTopLevelWindow
(
subject
)
)
{
this
.
childWindowPool
.
add
(
subject
)
;
events
.
emit
(
this
"
window
-
ready
"
subject
)
;
}
else
if
(
topic
=
=
"
inner
-
window
-
destroyed
"
)
{
let
window
=
this
.
getWindowFromInnerWindowID
(
subject
)
;
if
(
window
)
{
this
.
childWindowPool
.
delete
(
window
)
;
events
.
emit
(
this
"
window
-
destroyed
"
window
)
;
}
}
return
null
;
}
onPageChange
(
{
target
type
persisted
}
)
{
if
(
this
.
destroyed
)
{
return
;
}
let
window
=
target
.
defaultView
;
if
(
type
=
=
"
pagehide
"
&
&
this
.
childWindowPool
.
delete
(
window
)
)
{
events
.
emit
(
this
"
window
-
destroyed
"
window
)
;
}
else
if
(
type
=
=
"
pageshow
"
&
&
persisted
&
&
window
.
location
.
href
&
&
window
.
location
.
href
!
=
"
about
:
blank
"
&
&
this
.
isIncludedInTopLevelWindow
(
window
)
)
{
this
.
childWindowPool
.
add
(
window
)
;
events
.
emit
(
this
"
window
-
ready
"
window
)
;
}
}
listStores
:
Task
.
async
(
function
*
(
)
{
let
toReturn
=
{
}
;
for
(
let
[
name
value
]
of
this
.
childActorPool
)
{
if
(
value
.
preListStores
)
{
yield
value
.
preListStores
(
)
;
}
toReturn
[
name
]
=
value
;
}
return
toReturn
;
}
)
update
(
action
storeType
data
)
{
if
(
action
=
=
"
cleared
"
|
|
action
=
=
"
reloaded
"
)
{
let
toSend
=
{
}
;
toSend
[
storeType
]
=
data
;
events
.
emit
(
this
"
stores
-
"
+
action
toSend
)
;
return
null
;
}
if
(
this
.
batchTimer
)
{
clearTimeout
(
this
.
batchTimer
)
;
}
if
(
!
this
.
boundUpdate
[
action
]
)
{
this
.
boundUpdate
[
action
]
=
{
}
;
}
if
(
!
this
.
boundUpdate
[
action
]
[
storeType
]
)
{
this
.
boundUpdate
[
action
]
[
storeType
]
=
{
}
;
}
for
(
let
host
in
data
)
{
if
(
!
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
)
{
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
=
[
]
;
}
for
(
let
name
of
data
[
host
]
)
{
if
(
!
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
.
includes
(
name
)
)
{
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
.
push
(
name
)
;
}
}
}
if
(
action
=
=
"
added
"
)
{
this
.
removeNamesFromUpdateList
(
"
deleted
"
storeType
data
)
;
this
.
removeNamesFromUpdateList
(
"
changed
"
storeType
data
)
;
}
else
if
(
action
=
=
"
changed
"
&
&
this
.
boundUpdate
.
added
&
&
this
.
boundUpdate
.
added
[
storeType
]
)
{
this
.
removeNamesFromUpdateList
(
"
changed
"
storeType
this
.
boundUpdate
.
added
[
storeType
]
)
;
}
else
if
(
action
=
=
"
deleted
"
)
{
this
.
removeNamesFromUpdateList
(
"
added
"
storeType
data
)
;
this
.
removeNamesFromUpdateList
(
"
changed
"
storeType
data
)
;
for
(
let
host
in
data
)
{
if
(
data
[
host
]
.
length
=
=
0
&
&
this
.
boundUpdate
.
added
&
&
this
.
boundUpdate
.
added
[
storeType
]
&
&
this
.
boundUpdate
.
added
[
storeType
]
[
host
]
)
{
delete
this
.
boundUpdate
.
added
[
storeType
]
[
host
]
;
}
if
(
data
[
host
]
.
length
=
=
0
&
&
this
.
boundUpdate
.
changed
&
&
this
.
boundUpdate
.
changed
[
storeType
]
&
&
this
.
boundUpdate
.
changed
[
storeType
]
[
host
]
)
{
delete
this
.
boundUpdate
.
changed
[
storeType
]
[
host
]
;
}
}
}
this
.
batchTimer
=
setTimeout
(
(
)
=
>
{
clearTimeout
(
this
.
batchTimer
)
;
events
.
emit
(
this
"
stores
-
update
"
this
.
boundUpdate
)
;
this
.
boundUpdate
=
{
}
;
}
BATCH_DELAY
)
;
return
null
;
}
removeNamesFromUpdateList
(
action
storeType
data
)
{
for
(
let
host
in
data
)
{
if
(
this
.
boundUpdate
[
action
]
&
&
this
.
boundUpdate
[
action
]
[
storeType
]
&
&
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
)
{
for
(
let
name
in
data
[
host
]
)
{
let
index
=
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
.
indexOf
(
name
)
;
if
(
index
>
-
1
)
{
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
.
splice
(
index
1
)
;
}
}
if
(
!
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
.
length
)
{
delete
this
.
boundUpdate
[
action
]
[
storeType
]
[
host
]
;
}
}
}
return
null
;
}
}
)
;
exports
.
StorageActor
=
StorageActor
;
