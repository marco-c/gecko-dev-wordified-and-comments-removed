"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
InspectorUtils
=
require
(
"
InspectorUtils
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
PSEUDO_CLASSES
}
=
require
(
"
devtools
/
shared
/
css
/
constants
"
)
;
const
{
nodeSpec
nodeListSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
node
"
)
;
loader
.
lazyRequireGetter
(
this
"
getCssPath
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getXPath
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
findCssSelector
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
findAllCssSelectors
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isAfterPseudoElement
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isAnonymous
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isBeforePseudoElement
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isDirectShadowHostChild
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isMarkerPseudoElement
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isNativeAnonymous
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isShadowHost
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isShadowRoot
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getShadowRootMode
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isRemoteFrame
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorActorUtils
"
"
devtools
/
server
/
actors
/
inspector
/
utils
"
)
;
loader
.
lazyRequireGetter
(
this
"
LongStringActor
"
"
devtools
/
server
/
actors
/
string
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getFontPreviewData
"
"
devtools
/
server
/
actors
/
styles
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
actors
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EventCollector
"
"
devtools
/
server
/
actors
/
inspector
/
event
-
collector
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DocumentWalker
"
"
devtools
/
server
/
actors
/
inspector
/
document
-
walker
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
scrollbarTreeWalkerFilter
"
"
devtools
/
server
/
actors
/
inspector
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DOMHelpers
"
"
devtools
/
shared
/
dom
-
helpers
"
true
)
;
const
SUBGRID_ENABLED
=
Services
.
prefs
.
getBoolPref
(
"
layout
.
css
.
grid
-
template
-
subgrid
-
value
.
enabled
"
)
;
const
FONT_FAMILY_PREVIEW_TEXT
=
"
The
quick
brown
fox
jumps
over
the
lazy
dog
"
;
const
FONT_FAMILY_PREVIEW_TEXT_SIZE
=
20
;
const
NodeActor
=
protocol
.
ActorClassWithSpec
(
nodeSpec
{
initialize
:
function
(
walker
node
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
walker
=
walker
;
this
.
rawNode
=
node
;
this
.
_eventCollector
=
new
EventCollector
(
this
.
walker
.
targetActor
)
;
this
.
currentDisplayType
=
this
.
displayType
;
this
.
wasDisplayed
=
this
.
isDisplayed
;
this
.
wasScrollable
=
this
.
isScrollable
;
}
toString
:
function
(
)
{
return
(
"
[
NodeActor
"
+
this
.
actorID
+
"
for
"
+
this
.
rawNode
.
toString
(
)
+
"
]
"
)
;
}
get
conn
(
)
{
return
this
.
walker
.
conn
;
}
isDocumentElement
:
function
(
)
{
return
(
this
.
rawNode
.
ownerDocument
&
&
this
.
rawNode
.
ownerDocument
.
documentElement
=
=
=
this
.
rawNode
)
;
}
destroy
:
function
(
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
if
(
this
.
mutationObserver
)
{
if
(
!
Cu
.
isDeadWrapper
(
this
.
mutationObserver
)
)
{
this
.
mutationObserver
.
disconnect
(
)
;
}
this
.
mutationObserver
=
null
;
}
if
(
this
.
slotchangeListener
)
{
if
(
!
InspectorActorUtils
.
isNodeDead
(
this
)
)
{
this
.
rawNode
.
removeEventListener
(
"
slotchange
"
this
.
slotchangeListener
)
;
}
this
.
slotchangeListener
=
null
;
}
this
.
_eventCollector
.
destroy
(
)
;
this
.
_eventCollector
=
null
;
this
.
rawNode
=
null
;
this
.
walker
=
null
;
}
form
:
function
(
)
{
const
parentNode
=
this
.
walker
.
parentNode
(
this
)
;
const
inlineTextChild
=
this
.
walker
.
inlineTextChild
(
this
)
;
const
shadowRoot
=
isShadowRoot
(
this
.
rawNode
)
;
const
hostActor
=
shadowRoot
?
this
.
walker
.
getNode
(
this
.
rawNode
.
host
)
:
null
;
const
form
=
{
actor
:
this
.
actorID
host
:
hostActor
?
hostActor
.
actorID
:
undefined
baseURI
:
this
.
rawNode
.
baseURI
parent
:
parentNode
?
parentNode
.
actorID
:
undefined
nodeType
:
this
.
rawNode
.
nodeType
namespaceURI
:
this
.
rawNode
.
namespaceURI
nodeName
:
this
.
rawNode
.
nodeName
nodeValue
:
this
.
rawNode
.
nodeValue
displayName
:
InspectorActorUtils
.
getNodeDisplayName
(
this
.
rawNode
)
numChildren
:
this
.
numChildren
inlineTextChild
:
inlineTextChild
?
inlineTextChild
.
form
(
)
:
undefined
displayType
:
this
.
displayType
isScrollable
:
this
.
isScrollable
name
:
this
.
rawNode
.
name
publicId
:
this
.
rawNode
.
publicId
systemId
:
this
.
rawNode
.
systemId
attrs
:
this
.
writeAttrs
(
)
customElementLocation
:
this
.
getCustomElementLocation
(
)
isMarkerPseudoElement
:
isMarkerPseudoElement
(
this
.
rawNode
)
isBeforePseudoElement
:
isBeforePseudoElement
(
this
.
rawNode
)
isAfterPseudoElement
:
isAfterPseudoElement
(
this
.
rawNode
)
isAnonymous
:
isAnonymous
(
this
.
rawNode
)
isNativeAnonymous
:
isNativeAnonymous
(
this
.
rawNode
)
isShadowRoot
:
shadowRoot
shadowRootMode
:
getShadowRootMode
(
this
.
rawNode
)
isShadowHost
:
isShadowHost
(
this
.
rawNode
)
isDirectShadowHostChild
:
isDirectShadowHostChild
(
this
.
rawNode
)
pseudoClassLocks
:
this
.
writePseudoClassLocks
(
)
mutationBreakpoints
:
this
.
walker
.
getMutationBreakpoints
(
this
)
isDisplayed
:
this
.
isDisplayed
isInHTMLDocument
:
this
.
rawNode
.
ownerDocument
&
&
this
.
rawNode
.
ownerDocument
.
contentType
=
=
=
"
text
/
html
"
hasEventListeners
:
this
.
_hasEventListeners
traits
:
{
supportsGetAllSelectors
:
true
supportsWaitForFrameLoad
:
true
}
}
;
if
(
this
.
isDocumentElement
(
)
)
{
form
.
isDocumentElement
=
true
;
}
if
(
this
.
isRemoteFrame
)
{
form
.
remoteFrame
=
true
;
form
.
numChildren
=
1
;
form
.
browsingContextID
=
this
.
rawNode
.
browsingContext
.
id
;
}
return
form
;
}
watchDocument
:
function
(
doc
callback
)
{
const
node
=
this
.
rawNode
;
const
observer
=
new
doc
.
defaultView
.
MutationObserver
(
callback
)
;
observer
.
mergeAttributeRecords
=
true
;
observer
.
observe
(
node
{
nativeAnonymousChildList
:
true
attributes
:
true
characterData
:
true
characterDataOldValue
:
true
childList
:
true
subtree
:
true
}
)
;
this
.
mutationObserver
=
observer
;
}
watchSlotchange
:
function
(
callback
)
{
this
.
slotchangeListener
=
callback
;
this
.
rawNode
.
addEventListener
(
"
slotchange
"
this
.
slotchangeListener
)
;
}
get
isRemoteFrame
(
)
{
return
isRemoteFrame
(
this
.
rawNode
)
;
}
get
numChildren
(
)
{
if
(
isMarkerPseudoElement
(
this
.
rawNode
)
|
|
isBeforePseudoElement
(
this
.
rawNode
)
|
|
isAfterPseudoElement
(
this
.
rawNode
)
)
{
return
0
;
}
const
rawNode
=
this
.
rawNode
;
let
numChildren
=
rawNode
.
childNodes
.
length
;
const
hasContentDocument
=
rawNode
.
contentDocument
;
const
hasSVGDocument
=
rawNode
.
getSVGDocument
&
&
rawNode
.
getSVGDocument
(
)
;
if
(
numChildren
=
=
=
0
&
&
(
hasContentDocument
|
|
hasSVGDocument
)
)
{
numChildren
=
1
;
}
if
(
numChildren
=
=
=
0
|
|
isShadowHost
(
this
.
rawNode
)
|
|
this
.
rawNode
.
containingShadowRoot
)
{
numChildren
=
this
.
walker
.
countChildren
(
this
)
;
}
return
numChildren
;
}
get
computedStyle
(
)
{
if
(
!
this
.
_computedStyle
)
{
this
.
_computedStyle
=
CssLogic
.
getComputedStyle
(
this
.
rawNode
)
;
}
return
this
.
_computedStyle
;
}
get
displayType
(
)
{
if
(
InspectorActorUtils
.
isNodeDead
(
this
)
|
|
this
.
rawNode
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
return
null
;
}
const
style
=
this
.
computedStyle
;
if
(
!
style
)
{
return
null
;
}
let
display
=
null
;
try
{
display
=
style
.
display
;
}
catch
(
e
)
{
}
if
(
SUBGRID_ENABLED
&
&
(
display
=
=
=
"
grid
"
|
|
display
=
=
=
"
inline
-
grid
"
)
&
&
(
style
.
gridTemplateRows
.
startsWith
(
"
subgrid
"
)
|
|
style
.
gridTemplateColumns
.
startsWith
(
"
subgrid
"
)
)
)
{
display
=
"
subgrid
"
;
}
return
display
;
}
get
isScrollable
(
)
{
if
(
this
.
rawNode
.
clientHeight
=
=
=
this
.
rawNode
.
scrollHeight
&
&
this
.
rawNode
.
clientWidth
=
=
=
this
.
rawNode
.
scrollWidth
)
{
return
false
;
}
try
{
const
walker
=
new
DocumentWalker
(
this
.
rawNode
this
.
rawNode
.
ownerGlobal
{
filter
:
scrollbarTreeWalkerFilter
}
)
;
return
!
!
walker
.
firstChild
(
)
;
}
catch
(
e
)
{
return
false
;
}
}
get
isDisplayed
(
)
{
const
type
=
this
.
displayType
;
if
(
!
type
)
{
return
true
;
}
return
type
!
=
=
"
none
"
;
}
get
_hasEventListeners
(
)
{
const
dbg
=
this
.
parent
(
)
.
targetActor
.
makeDebugger
(
)
;
return
this
.
_eventCollector
.
hasEventListeners
(
this
.
rawNode
dbg
)
;
}
writeAttrs
:
function
(
)
{
if
(
!
this
.
rawNode
.
attributes
|
|
!
(
this
.
rawNode
.
attributes
instanceof
NamedNodeMap
)
)
{
return
undefined
;
}
return
[
.
.
.
this
.
rawNode
.
attributes
]
.
map
(
attr
=
>
{
return
{
namespace
:
attr
.
namespace
name
:
attr
.
name
value
:
attr
.
value
}
;
}
)
;
}
writePseudoClassLocks
:
function
(
)
{
if
(
this
.
rawNode
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
return
undefined
;
}
let
ret
=
undefined
;
for
(
const
pseudo
of
PSEUDO_CLASSES
)
{
if
(
InspectorUtils
.
hasPseudoClassLock
(
this
.
rawNode
pseudo
)
)
{
ret
=
ret
|
|
[
]
;
ret
.
push
(
pseudo
)
;
}
}
return
ret
;
}
getEventListeners
:
function
(
node
)
{
return
this
.
_eventCollector
.
getEventListeners
(
node
)
;
}
getCustomElementLocation
:
function
(
)
{
const
name
=
this
.
rawNode
.
localName
;
if
(
!
this
.
rawNode
.
ownerGlobal
)
{
return
undefined
;
}
const
customElementsRegistry
=
this
.
rawNode
.
ownerGlobal
.
customElements
;
const
customElement
=
customElementsRegistry
&
&
customElementsRegistry
.
get
(
name
)
;
if
(
!
customElement
)
{
return
undefined
;
}
const
global
=
Cu
.
getGlobalForObject
(
customElement
)
;
const
dbg
=
this
.
parent
(
)
.
targetActor
.
makeDebugger
(
)
;
const
globalDO
=
dbg
.
addDebuggee
(
global
)
;
const
customElementDO
=
globalDO
.
makeDebuggeeValue
(
customElement
)
;
if
(
!
customElementDO
.
script
)
{
return
undefined
;
}
return
{
url
:
customElementDO
.
script
.
url
line
:
customElementDO
.
script
.
startLine
}
;
}
getNodeValue
:
function
(
)
{
return
new
LongStringActor
(
this
.
conn
this
.
rawNode
.
nodeValue
|
|
"
"
)
;
}
setNodeValue
:
function
(
value
)
{
this
.
rawNode
.
nodeValue
=
value
;
}
getUniqueSelector
:
function
(
)
{
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
)
{
return
[
]
;
}
return
findCssSelector
(
this
.
rawNode
)
;
}
getAllSelectors
:
function
(
)
{
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
)
{
return
"
"
;
}
return
findAllCssSelectors
(
this
.
rawNode
)
;
}
getCssPath
:
function
(
)
{
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
)
{
return
"
"
;
}
return
getCssPath
(
this
.
rawNode
)
;
}
getXPath
:
function
(
)
{
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
)
{
return
"
"
;
}
return
getXPath
(
this
.
rawNode
)
;
}
scrollIntoView
:
function
(
)
{
this
.
rawNode
.
scrollIntoView
(
true
)
;
}
getImageData
:
function
(
maxDim
)
{
return
InspectorActorUtils
.
imageToImageData
(
this
.
rawNode
maxDim
)
.
then
(
imageData
=
>
{
return
{
data
:
LongStringActor
(
this
.
conn
imageData
.
data
)
size
:
imageData
.
size
}
;
}
)
;
}
getEventListenerInfo
:
function
(
)
{
return
this
.
getEventListeners
(
this
.
rawNode
)
;
}
modifyAttributes
:
function
(
modifications
)
{
const
rawNode
=
this
.
rawNode
;
for
(
const
change
of
modifications
)
{
if
(
change
.
newValue
=
=
null
)
{
if
(
change
.
attributeNamespace
)
{
rawNode
.
removeAttributeNS
(
change
.
attributeNamespace
change
.
attributeName
)
;
}
else
{
rawNode
.
removeAttribute
(
change
.
attributeName
)
;
}
}
else
if
(
change
.
attributeNamespace
)
{
rawNode
.
setAttributeNS
(
change
.
attributeNamespace
change
.
attributeName
change
.
newValue
)
;
}
else
{
rawNode
.
setAttribute
(
change
.
attributeName
change
.
newValue
)
;
}
}
}
getFontFamilyDataURL
:
function
(
font
fillStyle
=
"
black
"
)
{
const
doc
=
this
.
rawNode
.
ownerDocument
;
const
options
=
{
previewText
:
FONT_FAMILY_PREVIEW_TEXT
previewFontSize
:
FONT_FAMILY_PREVIEW_TEXT_SIZE
fillStyle
:
fillStyle
}
;
const
{
dataURL
size
}
=
getFontPreviewData
(
font
doc
options
)
;
return
{
data
:
LongStringActor
(
this
.
conn
dataURL
)
size
:
size
}
;
}
getClosestBackgroundColor
:
function
(
)
{
return
InspectorActorUtils
.
getClosestBackgroundColor
(
this
.
rawNode
)
;
}
getBackgroundColor
:
function
(
)
{
return
InspectorActorUtils
.
getBackgroundColor
(
this
)
;
}
getOwnerGlobalDimensions
:
function
(
)
{
const
win
=
this
.
rawNode
.
ownerGlobal
;
return
{
innerWidth
:
win
.
innerWidth
innerHeight
:
win
.
innerHeight
}
;
}
async
waitForFrameLoad
(
)
{
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
)
{
return
;
}
const
{
contentDocument
contentWindow
}
=
this
.
rawNode
;
if
(
contentDocument
&
&
contentDocument
.
readyState
!
=
=
"
complete
"
)
{
await
new
Promise
(
resolve
=
>
{
DOMHelpers
.
onceDOMReady
(
contentWindow
resolve
)
;
}
)
;
}
}
}
)
;
const
NodeListActor
=
protocol
.
ActorClassWithSpec
(
nodeListSpec
{
typeName
:
"
domnodelist
"
initialize
:
function
(
walker
nodeList
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
)
;
this
.
walker
=
walker
;
this
.
nodeList
=
nodeList
|
|
[
]
;
}
destroy
:
function
(
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
}
get
conn
(
)
{
return
this
.
walker
.
conn
;
}
marshallPool
:
function
(
)
{
return
this
.
walker
;
}
form
:
function
(
)
{
return
{
actor
:
this
.
actorID
length
:
this
.
nodeList
?
this
.
nodeList
.
length
:
0
}
;
}
item
:
function
(
index
)
{
return
this
.
walker
.
attachElement
(
this
.
nodeList
[
index
]
)
;
}
items
:
function
(
start
=
0
end
=
this
.
nodeList
.
length
)
{
const
items
=
Array
.
prototype
.
slice
.
call
(
this
.
nodeList
start
end
)
.
map
(
item
=
>
this
.
walker
.
_ref
(
item
)
)
;
return
this
.
walker
.
attachElements
(
items
)
;
}
release
:
function
(
)
{
}
}
)
;
exports
.
NodeActor
=
NodeActor
;
exports
.
NodeListActor
=
NodeListActor
;
