"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
InspectorUtils
=
require
(
"
InspectorUtils
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
nodeSpec
nodeListSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
node
"
)
;
loader
.
lazyRequireGetter
(
this
"
colorUtils
"
"
devtools
/
shared
/
css
/
color
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getCssPath
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getXPath
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
findCssSelector
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isAfterPseudoElement
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isAnonymous
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isBeforePseudoElement
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isDirectShadowHostChild
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isNativeAnonymous
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isShadowAnonymous
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isShadowHost
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isShadowRoot
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getShadowRootMode
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isXBLAnonymous
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorActorUtils
"
"
devtools
/
server
/
actors
/
inspector
/
utils
"
)
;
loader
.
lazyRequireGetter
(
this
"
LongStringActor
"
"
devtools
/
server
/
actors
/
string
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getFontPreviewData
"
"
devtools
/
server
/
actors
/
styles
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
actors
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EventParsers
"
"
devtools
/
server
/
actors
/
inspector
/
event
-
parsers
"
true
)
;
const
SUBGRID_ENABLED
=
Services
.
prefs
.
getBoolPref
(
"
layout
.
css
.
grid
-
template
-
subgrid
-
value
.
enabled
"
)
;
const
PSEUDO_CLASSES
=
[
"
:
hover
"
"
:
active
"
"
:
focus
"
]
;
const
FONT_FAMILY_PREVIEW_TEXT
=
"
The
quick
brown
fox
jumps
over
the
lazy
dog
"
;
const
FONT_FAMILY_PREVIEW_TEXT_SIZE
=
20
;
const
NodeActor
=
protocol
.
ActorClassWithSpec
(
nodeSpec
{
initialize
:
function
(
walker
node
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
walker
=
walker
;
this
.
rawNode
=
node
;
this
.
_eventParsers
=
new
EventParsers
(
)
.
parsers
;
this
.
currentDisplayType
=
this
.
displayType
;
this
.
wasDisplayed
=
this
.
isDisplayed
;
}
toString
:
function
(
)
{
return
"
[
NodeActor
"
+
this
.
actorID
+
"
for
"
+
this
.
rawNode
.
toString
(
)
+
"
]
"
;
}
get
conn
(
)
{
return
this
.
walker
.
conn
;
}
isDocumentElement
:
function
(
)
{
return
this
.
rawNode
.
ownerDocument
&
&
this
.
rawNode
.
ownerDocument
.
documentElement
=
=
=
this
.
rawNode
;
}
destroy
:
function
(
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
if
(
this
.
mutationObserver
)
{
if
(
!
Cu
.
isDeadWrapper
(
this
.
mutationObserver
)
)
{
this
.
mutationObserver
.
disconnect
(
)
;
}
this
.
mutationObserver
=
null
;
}
if
(
this
.
slotchangeListener
)
{
if
(
!
InspectorActorUtils
.
isNodeDead
(
this
)
)
{
this
.
rawNode
.
removeEventListener
(
"
slotchange
"
this
.
slotchangeListener
)
;
}
this
.
slotchangeListener
=
null
;
}
this
.
rawNode
=
null
;
this
.
walker
=
null
;
}
form
:
function
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
const
parentNode
=
this
.
walker
.
parentNode
(
this
)
;
const
inlineTextChild
=
this
.
walker
.
inlineTextChild
(
this
)
;
const
shadowRoot
=
isShadowRoot
(
this
.
rawNode
)
;
const
hostActor
=
shadowRoot
?
this
.
walker
.
getNode
(
this
.
rawNode
.
host
)
:
null
;
const
form
=
{
actor
:
this
.
actorID
host
:
hostActor
?
hostActor
.
actorID
:
undefined
baseURI
:
this
.
rawNode
.
baseURI
parent
:
parentNode
?
parentNode
.
actorID
:
undefined
nodeType
:
this
.
rawNode
.
nodeType
namespaceURI
:
this
.
rawNode
.
namespaceURI
nodeName
:
this
.
rawNode
.
nodeName
nodeValue
:
this
.
rawNode
.
nodeValue
displayName
:
InspectorActorUtils
.
getNodeDisplayName
(
this
.
rawNode
)
numChildren
:
this
.
numChildren
inlineTextChild
:
inlineTextChild
?
inlineTextChild
.
form
(
)
:
undefined
displayType
:
this
.
displayType
name
:
this
.
rawNode
.
name
publicId
:
this
.
rawNode
.
publicId
systemId
:
this
.
rawNode
.
systemId
attrs
:
this
.
writeAttrs
(
)
customElementLocation
:
this
.
getCustomElementLocation
(
)
isBeforePseudoElement
:
isBeforePseudoElement
(
this
.
rawNode
)
isAfterPseudoElement
:
isAfterPseudoElement
(
this
.
rawNode
)
isAnonymous
:
isAnonymous
(
this
.
rawNode
)
isNativeAnonymous
:
isNativeAnonymous
(
this
.
rawNode
)
isXBLAnonymous
:
isXBLAnonymous
(
this
.
rawNode
)
isShadowAnonymous
:
isShadowAnonymous
(
this
.
rawNode
)
isShadowRoot
:
shadowRoot
shadowRootMode
:
getShadowRootMode
(
this
.
rawNode
)
isShadowHost
:
isShadowHost
(
this
.
rawNode
)
isDirectShadowHostChild
:
isDirectShadowHostChild
(
this
.
rawNode
)
pseudoClassLocks
:
this
.
writePseudoClassLocks
(
)
isDisplayed
:
this
.
isDisplayed
isInHTMLDocument
:
this
.
rawNode
.
ownerDocument
&
&
this
.
rawNode
.
ownerDocument
.
contentType
=
=
=
"
text
/
html
"
hasEventListeners
:
this
.
_hasEventListeners
}
;
if
(
this
.
isDocumentElement
(
)
)
{
form
.
isDocumentElement
=
true
;
}
return
form
;
}
watchDocument
:
function
(
doc
callback
)
{
const
node
=
this
.
rawNode
;
const
observer
=
new
doc
.
defaultView
.
MutationObserver
(
callback
)
;
observer
.
mergeAttributeRecords
=
true
;
observer
.
observe
(
node
{
nativeAnonymousChildList
:
true
attributes
:
true
characterData
:
true
characterDataOldValue
:
true
childList
:
true
subtree
:
true
}
)
;
this
.
mutationObserver
=
observer
;
}
watchSlotchange
:
function
(
callback
)
{
this
.
slotchangeListener
=
callback
;
this
.
rawNode
.
addEventListener
(
"
slotchange
"
this
.
slotchangeListener
)
;
}
get
numChildren
(
)
{
if
(
isBeforePseudoElement
(
this
.
rawNode
)
|
|
isAfterPseudoElement
(
this
.
rawNode
)
)
{
return
0
;
}
const
rawNode
=
this
.
rawNode
;
let
numChildren
=
rawNode
.
childNodes
.
length
;
const
hasAnonChildren
=
rawNode
.
nodeType
=
=
=
Node
.
ELEMENT_NODE
&
&
rawNode
.
ownerDocument
.
getAnonymousNodes
(
rawNode
)
;
const
hasContentDocument
=
rawNode
.
contentDocument
;
const
hasSVGDocument
=
rawNode
.
getSVGDocument
&
&
rawNode
.
getSVGDocument
(
)
;
if
(
numChildren
=
=
=
0
&
&
(
hasContentDocument
|
|
hasSVGDocument
)
)
{
numChildren
=
1
;
}
if
(
numChildren
=
=
=
0
|
|
hasAnonChildren
|
|
isShadowHost
(
this
.
rawNode
)
|
|
isShadowAnonymous
(
this
.
rawNode
)
)
{
numChildren
=
this
.
walker
.
countChildren
(
this
)
;
}
return
numChildren
;
}
get
computedStyle
(
)
{
if
(
!
this
.
_computedStyle
)
{
this
.
_computedStyle
=
CssLogic
.
getComputedStyle
(
this
.
rawNode
)
;
}
return
this
.
_computedStyle
;
}
get
displayType
(
)
{
if
(
InspectorActorUtils
.
isNodeDead
(
this
)
|
|
this
.
rawNode
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
|
|
isAfterPseudoElement
(
this
.
rawNode
)
|
|
isBeforePseudoElement
(
this
.
rawNode
)
)
{
return
null
;
}
const
style
=
this
.
computedStyle
;
if
(
!
style
)
{
return
null
;
}
let
display
=
null
;
try
{
display
=
style
.
display
;
}
catch
(
e
)
{
}
if
(
SUBGRID_ENABLED
&
&
(
display
=
=
=
"
grid
"
|
|
display
=
=
=
"
inline
-
grid
"
)
&
&
(
style
.
gridTemplateRows
=
=
=
"
subgrid
"
|
|
style
.
gridTemplateColumns
=
=
=
"
subgrid
"
)
)
{
display
=
"
subgrid
"
;
}
return
display
;
}
get
isDisplayed
(
)
{
const
type
=
this
.
displayType
;
if
(
!
type
)
{
return
true
;
}
return
type
!
=
=
"
none
"
;
}
get
_hasEventListeners
(
)
{
const
parsers
=
this
.
_eventParsers
;
for
(
const
[
{
hasListeners
}
]
of
parsers
)
{
try
{
if
(
hasListeners
&
&
hasListeners
(
this
.
rawNode
)
)
{
return
true
;
}
}
catch
(
e
)
{
}
}
return
false
;
}
writeAttrs
:
function
(
)
{
if
(
!
this
.
rawNode
.
attributes
)
{
return
undefined
;
}
return
[
.
.
.
this
.
rawNode
.
attributes
]
.
map
(
attr
=
>
{
return
{
namespace
:
attr
.
namespace
name
:
attr
.
name
value
:
attr
.
value
}
;
}
)
;
}
writePseudoClassLocks
:
function
(
)
{
if
(
this
.
rawNode
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
return
undefined
;
}
let
ret
=
undefined
;
for
(
const
pseudo
of
PSEUDO_CLASSES
)
{
if
(
InspectorUtils
.
hasPseudoClassLock
(
this
.
rawNode
pseudo
)
)
{
ret
=
ret
|
|
[
]
;
ret
.
push
(
pseudo
)
;
}
}
return
ret
;
}
getEventListeners
:
function
(
node
)
{
const
parsers
=
this
.
_eventParsers
;
const
dbg
=
this
.
parent
(
)
.
targetActor
.
makeDebugger
(
)
;
const
listenerArray
=
[
]
;
for
(
const
[
{
getListeners
normalizeListener
}
]
of
parsers
)
{
try
{
const
listeners
=
getListeners
(
node
)
;
if
(
!
listeners
)
{
continue
;
}
for
(
const
listener
of
listeners
)
{
if
(
normalizeListener
)
{
listener
.
normalizeListener
=
normalizeListener
;
}
this
.
processHandlerForEvent
(
node
listenerArray
dbg
listener
)
;
}
}
catch
(
e
)
{
}
}
listenerArray
.
sort
(
(
a
b
)
=
>
{
return
a
.
type
.
localeCompare
(
b
.
type
)
;
}
)
;
return
listenerArray
;
}
getCustomElementLocation
:
function
(
)
{
const
name
=
this
.
rawNode
.
localName
;
const
customElementsRegistry
=
this
.
rawNode
.
ownerGlobal
.
customElements
;
const
customElement
=
customElementsRegistry
&
&
customElementsRegistry
.
get
(
name
)
;
if
(
!
customElement
)
{
return
undefined
;
}
const
global
=
Cu
.
getGlobalForObject
(
customElement
)
;
const
dbg
=
this
.
parent
(
)
.
targetActor
.
makeDebugger
(
)
;
const
globalDO
=
dbg
.
addDebuggee
(
global
)
;
const
customElementDO
=
globalDO
.
makeDebuggeeValue
(
customElement
)
;
if
(
!
customElementDO
.
script
)
{
return
undefined
;
}
return
{
url
:
customElementDO
.
script
.
url
line
:
customElementDO
.
script
.
startLine
}
;
}
processHandlerForEvent
:
function
(
node
listenerArray
dbg
listener
)
{
const
{
handler
}
=
listener
;
const
global
=
Cu
.
getGlobalForObject
(
handler
)
;
const
globalDO
=
dbg
.
addDebuggee
(
global
)
;
let
listenerDO
=
globalDO
.
makeDebuggeeValue
(
handler
)
;
const
{
normalizeListener
}
=
listener
;
if
(
normalizeListener
)
{
listenerDO
=
normalizeListener
(
listenerDO
listener
)
;
}
const
{
capturing
}
=
listener
;
let
dom0
=
false
;
let
functionSource
=
handler
.
toString
(
)
;
const
hide
=
listener
.
hide
|
|
{
}
;
let
line
=
0
;
let
native
=
false
;
const
override
=
listener
.
override
|
|
{
}
;
const
tags
=
listener
.
tags
|
|
"
"
;
const
type
=
listener
.
type
|
|
"
"
;
let
url
=
"
"
;
if
(
listenerDO
.
class
=
=
=
"
Object
"
|
|
/
^
XUL
\
w
*
Element
/
.
test
(
listenerDO
.
class
)
)
{
let
desc
;
while
(
!
desc
&
&
listenerDO
)
{
desc
=
listenerDO
.
getOwnPropertyDescriptor
(
"
handleEvent
"
)
;
listenerDO
=
listenerDO
.
proto
;
}
if
(
desc
&
&
desc
.
value
)
{
listenerDO
=
desc
.
value
;
}
}
if
(
listenerDO
.
isBoundFunction
)
{
listenerDO
=
listenerDO
.
boundTargetFunction
;
}
const
{
isArrowFunction
name
script
parameterNames
}
=
listenerDO
;
if
(
script
)
{
const
scriptSource
=
script
.
source
.
text
;
if
(
script
.
source
.
element
)
{
dom0
=
script
.
source
.
element
.
class
!
=
=
"
HTMLScriptElement
"
;
}
else
{
dom0
=
false
;
}
line
=
script
.
startLine
;
url
=
script
.
url
;
if
(
functionSource
=
=
=
"
[
object
Object
]
"
|
|
functionSource
=
=
=
"
[
object
XULElement
]
"
|
|
functionSource
.
includes
(
"
[
native
code
]
"
)
)
{
functionSource
=
scriptSource
.
substr
(
script
.
sourceStart
script
.
sourceLength
)
;
if
(
!
isArrowFunction
)
{
functionSource
=
"
function
"
+
functionSource
;
}
}
}
else
{
native
=
true
;
}
if
(
parameterNames
&
&
parameterNames
.
length
>
0
)
{
const
prefix
=
"
function
"
+
name
+
"
(
)
"
;
const
paramString
=
parameterNames
.
join
(
"
"
)
;
if
(
functionSource
.
startsWith
(
prefix
)
)
{
functionSource
=
functionSource
.
substr
(
prefix
.
length
)
;
functionSource
=
function
{
name
}
(
{
paramString
}
)
{
functionSource
}
;
}
}
let
origin
;
if
(
native
)
{
origin
=
"
[
native
code
]
"
;
}
else
{
origin
=
url
+
(
(
dom0
|
|
line
=
=
=
0
)
?
"
"
:
"
:
"
+
line
)
;
}
const
eventObj
=
{
type
:
override
.
type
|
|
type
handler
:
override
.
handler
|
|
functionSource
.
trim
(
)
origin
:
override
.
origin
|
|
origin
tags
:
override
.
tags
|
|
tags
DOM0
:
typeof
override
.
dom0
!
=
=
"
undefined
"
?
override
.
dom0
:
dom0
capturing
:
typeof
override
.
capturing
!
=
=
"
undefined
"
?
override
.
capturing
:
capturing
hide
:
typeof
override
.
hide
!
=
=
"
undefined
"
?
override
.
hide
:
hide
native
}
;
if
(
native
|
|
dom0
)
{
eventObj
.
hide
.
debugger
=
true
;
}
listenerArray
.
push
(
eventObj
)
;
dbg
.
removeDebuggee
(
globalDO
)
;
}
getNodeValue
:
function
(
)
{
return
new
LongStringActor
(
this
.
conn
this
.
rawNode
.
nodeValue
|
|
"
"
)
;
}
setNodeValue
:
function
(
value
)
{
this
.
rawNode
.
nodeValue
=
value
;
}
getUniqueSelector
:
function
(
)
{
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
)
{
return
"
"
;
}
return
findCssSelector
(
this
.
rawNode
)
;
}
getCssPath
:
function
(
)
{
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
)
{
return
"
"
;
}
return
getCssPath
(
this
.
rawNode
)
;
}
getXPath
:
function
(
)
{
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
)
{
return
"
"
;
}
return
getXPath
(
this
.
rawNode
)
;
}
scrollIntoView
:
function
(
)
{
this
.
rawNode
.
scrollIntoView
(
true
)
;
}
getImageData
:
function
(
maxDim
)
{
return
InspectorActorUtils
.
imageToImageData
(
this
.
rawNode
maxDim
)
.
then
(
imageData
=
>
{
return
{
data
:
LongStringActor
(
this
.
conn
imageData
.
data
)
size
:
imageData
.
size
}
;
}
)
;
}
getEventListenerInfo
:
function
(
)
{
const
node
=
this
.
rawNode
;
if
(
this
.
rawNode
.
nodeName
.
toLowerCase
(
)
=
=
=
"
html
"
)
{
const
winListeners
=
this
.
getEventListeners
(
node
.
ownerGlobal
)
|
|
[
]
;
const
docElementListeners
=
this
.
getEventListeners
(
node
)
|
|
[
]
;
const
docListeners
=
this
.
getEventListeners
(
node
.
parentNode
)
|
|
[
]
;
return
[
.
.
.
winListeners
.
.
.
docElementListeners
.
.
.
docListeners
]
.
sort
(
(
a
b
)
=
>
{
return
a
.
type
.
localeCompare
(
b
.
type
)
;
}
)
;
}
return
this
.
getEventListeners
(
node
)
;
}
modifyAttributes
:
function
(
modifications
)
{
const
rawNode
=
this
.
rawNode
;
for
(
const
change
of
modifications
)
{
if
(
change
.
newValue
=
=
null
)
{
if
(
change
.
attributeNamespace
)
{
rawNode
.
removeAttributeNS
(
change
.
attributeNamespace
change
.
attributeName
)
;
}
else
{
rawNode
.
removeAttribute
(
change
.
attributeName
)
;
}
}
else
if
(
change
.
attributeNamespace
)
{
rawNode
.
setAttributeNS
(
change
.
attributeNamespace
change
.
attributeName
change
.
newValue
)
;
}
else
{
rawNode
.
setAttribute
(
change
.
attributeName
change
.
newValue
)
;
}
}
}
getFontFamilyDataURL
:
function
(
font
fillStyle
=
"
black
"
)
{
const
doc
=
this
.
rawNode
.
ownerDocument
;
const
options
=
{
previewText
:
FONT_FAMILY_PREVIEW_TEXT
previewFontSize
:
FONT_FAMILY_PREVIEW_TEXT_SIZE
fillStyle
:
fillStyle
}
;
const
{
dataURL
size
}
=
getFontPreviewData
(
font
doc
options
)
;
return
{
data
:
LongStringActor
(
this
.
conn
dataURL
)
size
:
size
}
;
}
getClosestBackgroundColor
:
function
(
)
{
let
current
=
this
.
rawNode
;
while
(
current
)
{
const
computedStyle
=
CssLogic
.
getComputedStyle
(
current
)
;
const
currentStyle
=
computedStyle
.
getPropertyValue
(
"
background
-
color
"
)
;
if
(
colorUtils
.
isValidCSSColor
(
currentStyle
)
)
{
const
currentCssColor
=
new
colorUtils
.
CssColor
(
currentStyle
)
;
if
(
!
currentCssColor
.
isTransparent
(
)
)
{
return
currentCssColor
.
rgba
;
}
}
current
=
current
.
parentNode
;
}
return
"
rgba
(
255
255
255
1
)
"
;
}
getOwnerGlobalDimensions
:
function
(
)
{
const
win
=
this
.
rawNode
.
ownerGlobal
;
return
{
innerWidth
:
win
.
innerWidth
innerHeight
:
win
.
innerHeight
}
;
}
}
)
;
const
NodeListActor
=
protocol
.
ActorClassWithSpec
(
nodeListSpec
{
typeName
:
"
domnodelist
"
initialize
:
function
(
walker
nodeList
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
)
;
this
.
walker
=
walker
;
this
.
nodeList
=
nodeList
|
|
[
]
;
}
destroy
:
function
(
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
}
get
conn
(
)
{
return
this
.
walker
.
conn
;
}
marshallPool
:
function
(
)
{
return
this
.
walker
;
}
form
:
function
(
)
{
return
{
actor
:
this
.
actorID
length
:
this
.
nodeList
?
this
.
nodeList
.
length
:
0
}
;
}
item
:
function
(
index
)
{
return
this
.
walker
.
attachElement
(
this
.
nodeList
[
index
]
)
;
}
items
:
function
(
start
=
0
end
=
this
.
nodeList
.
length
)
{
const
items
=
Array
.
prototype
.
slice
.
call
(
this
.
nodeList
start
end
)
.
map
(
item
=
>
this
.
walker
.
_ref
(
item
)
)
;
return
this
.
walker
.
attachElements
(
items
)
;
}
release
:
function
(
)
{
}
}
)
;
exports
.
NodeActor
=
NodeActor
;
exports
.
NodeListActor
=
NodeListActor
;
