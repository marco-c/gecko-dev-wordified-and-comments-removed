"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
InspectorUtils
=
require
(
"
InspectorUtils
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
PSEUDO_CLASSES
}
=
require
(
"
devtools
/
shared
/
css
/
constants
"
)
;
const
{
nodeSpec
nodeListSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
node
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
getCssPath
"
"
getXPath
"
"
findCssSelector
"
]
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
getShadowRootMode
"
"
isAfterPseudoElement
"
"
isAnonymous
"
"
isBeforePseudoElement
"
"
isDirectShadowHostChild
"
"
isFrameBlockedByCSP
"
"
isFrameWithChildTarget
"
"
isMarkerPseudoElement
"
"
isNativeAnonymous
"
"
isShadowHost
"
"
isShadowRoot
"
]
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
getBackgroundColor
"
"
getClosestBackgroundColor
"
"
getNodeDisplayName
"
"
imageToImageData
"
"
isNodeDead
"
]
"
devtools
/
server
/
actors
/
inspector
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
LongStringActor
"
"
devtools
/
server
/
actors
/
string
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getFontPreviewData
"
"
devtools
/
server
/
actors
/
utils
/
style
-
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
actors
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EventCollector
"
"
devtools
/
server
/
actors
/
inspector
/
event
-
collector
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DOMHelpers
"
"
devtools
/
shared
/
dom
-
helpers
"
true
)
;
const
SUBGRID_ENABLED
=
Services
.
prefs
.
getBoolPref
(
"
layout
.
css
.
grid
-
template
-
subgrid
-
value
.
enabled
"
)
;
const
FONT_FAMILY_PREVIEW_TEXT
=
"
The
quick
brown
fox
jumps
over
the
lazy
dog
"
;
const
FONT_FAMILY_PREVIEW_TEXT_SIZE
=
20
;
const
NodeActor
=
protocol
.
ActorClassWithSpec
(
nodeSpec
{
initialize
(
walker
node
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
walker
=
walker
;
this
.
rawNode
=
node
;
this
.
_eventCollector
=
new
EventCollector
(
this
.
walker
.
targetActor
)
;
this
.
_nsIEventListenersInfo
=
new
Map
(
)
;
const
wasScrollable
=
this
.
isScrollable
;
this
.
currentDisplayType
=
this
.
displayType
;
this
.
wasDisplayed
=
this
.
isDisplayed
;
this
.
wasScrollable
=
wasScrollable
;
if
(
wasScrollable
)
{
this
.
walker
.
updateOverflowCausingElements
(
this
this
.
walker
.
overflowCausingElementsMap
)
;
}
}
toString
(
)
{
return
(
"
[
NodeActor
"
+
this
.
actorID
+
"
for
"
+
this
.
rawNode
.
toString
(
)
+
"
]
"
)
;
}
get
conn
(
)
{
return
this
.
walker
.
conn
;
}
isDocumentElement
(
)
{
return
(
this
.
rawNode
.
ownerDocument
&
&
this
.
rawNode
.
ownerDocument
.
documentElement
=
=
=
this
.
rawNode
)
;
}
destroy
(
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
if
(
this
.
mutationObserver
)
{
if
(
!
Cu
.
isDeadWrapper
(
this
.
mutationObserver
)
)
{
this
.
mutationObserver
.
disconnect
(
)
;
}
this
.
mutationObserver
=
null
;
}
if
(
this
.
slotchangeListener
)
{
if
(
!
isNodeDead
(
this
)
)
{
this
.
rawNode
.
removeEventListener
(
"
slotchange
"
this
.
slotchangeListener
)
;
}
this
.
slotchangeListener
=
null
;
}
if
(
this
.
_waitForFrameLoadAbortController
)
{
this
.
_waitForFrameLoadAbortController
.
abort
(
)
;
this
.
_waitForFrameLoadAbortController
=
null
;
}
if
(
this
.
_waitForFrameLoadIntervalId
)
{
clearInterval
(
this
.
_waitForFrameLoadIntervalId
)
;
this
.
_waitForFrameLoadIntervalId
=
null
;
}
if
(
this
.
_nsIEventListenersInfo
)
{
for
(
const
nsIEventListenerInfo
of
this
.
_nsIEventListenersInfo
.
values
(
)
)
{
try
{
if
(
!
nsIEventListenerInfo
.
enabled
)
{
nsIEventListenerInfo
.
enabled
=
true
;
}
}
catch
(
e
)
{
}
}
this
.
_nsIEventListenersInfo
=
null
;
}
this
.
_eventCollector
.
destroy
(
)
;
this
.
_eventCollector
=
null
;
this
.
rawNode
=
null
;
this
.
walker
=
null
;
}
form
(
)
{
const
parentNode
=
this
.
walker
.
parentNode
(
this
)
;
const
inlineTextChild
=
this
.
walker
.
inlineTextChild
(
this
)
;
const
shadowRoot
=
isShadowRoot
(
this
.
rawNode
)
;
const
hostActor
=
shadowRoot
?
this
.
walker
.
getNode
(
this
.
rawNode
.
host
)
:
null
;
const
form
=
{
actor
:
this
.
actorID
host
:
hostActor
?
hostActor
.
actorID
:
undefined
baseURI
:
this
.
rawNode
.
baseURI
parent
:
parentNode
?
parentNode
.
actorID
:
undefined
nodeType
:
this
.
rawNode
.
nodeType
namespaceURI
:
this
.
rawNode
.
namespaceURI
nodeName
:
this
.
rawNode
.
nodeName
nodeValue
:
this
.
rawNode
.
nodeValue
displayName
:
getNodeDisplayName
(
this
.
rawNode
)
numChildren
:
this
.
numChildren
inlineTextChild
:
inlineTextChild
?
inlineTextChild
.
form
(
)
:
undefined
displayType
:
this
.
displayType
isScrollable
:
this
.
isScrollable
isTopLevelDocument
:
this
.
isTopLevelDocument
causesOverflow
:
this
.
walker
.
overflowCausingElementsMap
.
has
(
this
.
rawNode
)
name
:
this
.
rawNode
.
name
publicId
:
this
.
rawNode
.
publicId
systemId
:
this
.
rawNode
.
systemId
attrs
:
this
.
writeAttrs
(
)
customElementLocation
:
this
.
getCustomElementLocation
(
)
isMarkerPseudoElement
:
isMarkerPseudoElement
(
this
.
rawNode
)
isBeforePseudoElement
:
isBeforePseudoElement
(
this
.
rawNode
)
isAfterPseudoElement
:
isAfterPseudoElement
(
this
.
rawNode
)
isAnonymous
:
isAnonymous
(
this
.
rawNode
)
isNativeAnonymous
:
isNativeAnonymous
(
this
.
rawNode
)
isShadowRoot
:
shadowRoot
shadowRootMode
:
getShadowRootMode
(
this
.
rawNode
)
isShadowHost
:
isShadowHost
(
this
.
rawNode
)
isDirectShadowHostChild
:
isDirectShadowHostChild
(
this
.
rawNode
)
pseudoClassLocks
:
this
.
writePseudoClassLocks
(
)
mutationBreakpoints
:
this
.
walker
.
getMutationBreakpoints
(
this
)
isDisplayed
:
this
.
isDisplayed
isInHTMLDocument
:
this
.
rawNode
.
ownerDocument
&
&
this
.
rawNode
.
ownerDocument
.
contentType
=
=
=
"
text
/
html
"
hasEventListeners
:
this
.
_hasEventListeners
traits
:
{
}
}
;
if
(
this
.
isDocumentElement
(
)
)
{
form
.
isDocumentElement
=
true
;
}
if
(
isFrameBlockedByCSP
(
this
.
rawNode
)
)
{
form
.
numChildren
=
0
;
}
if
(
this
.
useChildTargetToFetchChildren
)
{
form
.
useChildTargetToFetchChildren
=
true
;
form
.
numChildren
=
1
;
}
form
.
browsingContextID
=
this
.
rawNode
.
browsingContext
?
.
id
;
return
form
;
}
watchDocument
(
doc
callback
)
{
if
(
!
doc
.
defaultView
)
{
return
;
}
const
node
=
this
.
rawNode
;
const
observer
=
new
doc
.
defaultView
.
MutationObserver
(
callback
)
;
observer
.
mergeAttributeRecords
=
true
;
observer
.
observe
(
node
{
nativeAnonymousChildList
:
true
attributes
:
true
characterData
:
true
characterDataOldValue
:
true
childList
:
true
subtree
:
true
}
)
;
this
.
mutationObserver
=
observer
;
}
watchSlotchange
(
callback
)
{
this
.
slotchangeListener
=
callback
;
this
.
rawNode
.
addEventListener
(
"
slotchange
"
this
.
slotchangeListener
)
;
}
get
useChildTargetToFetchChildren
(
)
{
return
isFrameWithChildTarget
(
this
.
walker
.
targetActor
this
.
rawNode
)
;
}
get
isTopLevelDocument
(
)
{
return
this
.
rawNode
=
=
=
this
.
walker
.
rootDoc
;
}
get
numChildren
(
)
{
if
(
isMarkerPseudoElement
(
this
.
rawNode
)
|
|
isBeforePseudoElement
(
this
.
rawNode
)
|
|
isAfterPseudoElement
(
this
.
rawNode
)
)
{
return
0
;
}
const
rawNode
=
this
.
rawNode
;
let
numChildren
=
rawNode
.
childNodes
.
length
;
const
hasContentDocument
=
rawNode
.
contentDocument
;
const
hasSVGDocument
=
rawNode
.
getSVGDocument
&
&
rawNode
.
getSVGDocument
(
)
;
if
(
numChildren
=
=
=
0
&
&
(
hasContentDocument
|
|
hasSVGDocument
)
)
{
numChildren
=
1
;
}
if
(
numChildren
=
=
=
0
|
|
isShadowHost
(
this
.
rawNode
)
|
|
this
.
rawNode
.
containingShadowRoot
)
{
numChildren
=
this
.
walker
.
countChildren
(
this
)
;
}
return
numChildren
;
}
get
computedStyle
(
)
{
if
(
!
this
.
_computedStyle
)
{
this
.
_computedStyle
=
CssLogic
.
getComputedStyle
(
this
.
rawNode
)
;
}
return
this
.
_computedStyle
;
}
get
displayType
(
)
{
if
(
isNodeDead
(
this
)
|
|
this
.
rawNode
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
return
null
;
}
const
style
=
this
.
computedStyle
;
if
(
!
style
)
{
return
null
;
}
let
display
=
null
;
try
{
display
=
style
.
display
;
}
catch
(
e
)
{
}
if
(
SUBGRID_ENABLED
&
&
(
display
=
=
=
"
grid
"
|
|
display
=
=
=
"
inline
-
grid
"
)
&
&
(
style
.
gridTemplateRows
.
startsWith
(
"
subgrid
"
)
|
|
style
.
gridTemplateColumns
.
startsWith
(
"
subgrid
"
)
)
)
{
display
=
"
subgrid
"
;
}
return
display
;
}
get
isScrollable
(
)
{
return
(
this
.
rawNode
.
nodeType
=
=
=
Node
.
ELEMENT_NODE
&
&
this
.
rawNode
.
hasVisibleScrollbars
)
;
}
get
isDisplayed
(
)
{
const
type
=
this
.
displayType
;
if
(
!
type
)
{
return
true
;
}
return
type
!
=
=
"
none
"
;
}
get
_hasEventListeners
(
)
{
const
dbg
=
this
.
getParent
(
)
.
targetActor
.
makeDebugger
(
)
;
return
this
.
_eventCollector
.
hasEventListeners
(
this
.
rawNode
dbg
)
;
}
writeAttrs
(
)
{
if
(
!
this
.
rawNode
.
attributes
|
|
!
NamedNodeMap
.
isInstance
(
this
.
rawNode
.
attributes
)
)
{
return
undefined
;
}
return
[
.
.
.
this
.
rawNode
.
attributes
]
.
map
(
attr
=
>
{
return
{
namespace
:
attr
.
namespace
name
:
attr
.
name
value
:
attr
.
value
}
;
}
)
;
}
writePseudoClassLocks
(
)
{
if
(
this
.
rawNode
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
return
undefined
;
}
let
ret
=
undefined
;
for
(
const
pseudo
of
PSEUDO_CLASSES
)
{
if
(
InspectorUtils
.
hasPseudoClassLock
(
this
.
rawNode
pseudo
)
)
{
ret
=
ret
|
|
[
]
;
ret
.
push
(
pseudo
)
;
}
}
return
ret
;
}
getCustomElementLocation
(
)
{
const
name
=
this
.
rawNode
.
localName
;
if
(
!
this
.
rawNode
.
ownerGlobal
)
{
return
undefined
;
}
const
customElementsRegistry
=
this
.
rawNode
.
ownerGlobal
.
customElements
;
const
customElement
=
customElementsRegistry
&
&
customElementsRegistry
.
get
(
name
)
;
if
(
!
customElement
)
{
return
undefined
;
}
const
global
=
Cu
.
getGlobalForObject
(
customElement
)
;
const
dbg
=
this
.
getParent
(
)
.
targetActor
.
makeDebugger
(
)
;
if
(
Cu
.
getObjectPrincipal
(
global
)
=
=
Cu
.
getObjectPrincipal
(
dbg
)
)
{
return
undefined
;
}
const
globalDO
=
dbg
.
addDebuggee
(
global
)
;
const
customElementDO
=
globalDO
.
makeDebuggeeValue
(
customElement
)
;
if
(
!
customElementDO
.
script
)
{
return
undefined
;
}
return
{
url
:
customElementDO
.
script
.
url
line
:
customElementDO
.
script
.
startLine
column
:
customElementDO
.
script
.
startColumn
}
;
}
getNodeValue
(
)
{
return
new
LongStringActor
(
this
.
conn
this
.
rawNode
.
nodeValue
|
|
"
"
)
;
}
setNodeValue
(
value
)
{
this
.
rawNode
.
nodeValue
=
value
;
}
getUniqueSelector
(
)
{
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
)
{
return
"
"
;
}
return
findCssSelector
(
this
.
rawNode
)
;
}
getCssPath
(
)
{
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
)
{
return
"
"
;
}
return
getCssPath
(
this
.
rawNode
)
;
}
getXPath
(
)
{
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
)
{
return
"
"
;
}
return
getXPath
(
this
.
rawNode
)
;
}
scrollIntoView
(
)
{
this
.
rawNode
.
scrollIntoView
(
true
)
;
}
getImageData
(
maxDim
)
{
return
imageToImageData
(
this
.
rawNode
maxDim
)
.
then
(
imageData
=
>
{
return
{
data
:
LongStringActor
(
this
.
conn
imageData
.
data
)
size
:
imageData
.
size
}
;
}
)
;
}
getEventListenerInfo
(
)
{
this
.
_nsIEventListenersInfo
.
clear
(
)
;
const
eventListenersData
=
this
.
_eventCollector
.
getEventListeners
(
this
.
rawNode
)
;
let
counter
=
0
;
for
(
const
eventListenerData
of
eventListenersData
)
{
if
(
eventListenerData
.
nsIEventListenerInfo
)
{
const
id
=
event
-
listener
-
info
-
{
+
+
counter
}
;
this
.
_nsIEventListenersInfo
.
set
(
id
eventListenerData
.
nsIEventListenerInfo
)
;
eventListenerData
.
eventListenerInfoId
=
id
;
delete
eventListenerData
.
nsIEventListenerInfo
;
}
}
return
eventListenersData
;
}
disableEventListener
(
eventListenerInfoId
)
{
const
nsEventListenerInfo
=
this
.
_nsIEventListenersInfo
.
get
(
eventListenerInfoId
)
;
if
(
!
nsEventListenerInfo
)
{
throw
new
Error
(
"
Unkown
nsEventListenerInfo
"
)
;
}
nsEventListenerInfo
.
enabled
=
false
;
}
enableEventListener
(
eventListenerInfoId
)
{
const
nsEventListenerInfo
=
this
.
_nsIEventListenersInfo
.
get
(
eventListenerInfoId
)
;
if
(
!
nsEventListenerInfo
)
{
throw
new
Error
(
"
Unkown
nsEventListenerInfo
"
)
;
}
nsEventListenerInfo
.
enabled
=
true
;
}
modifyAttributes
(
modifications
)
{
const
rawNode
=
this
.
rawNode
;
for
(
const
change
of
modifications
)
{
if
(
change
.
newValue
=
=
null
)
{
if
(
change
.
attributeNamespace
)
{
rawNode
.
removeAttributeNS
(
change
.
attributeNamespace
change
.
attributeName
)
;
}
else
{
rawNode
.
removeAttribute
(
change
.
attributeName
)
;
}
}
else
if
(
change
.
attributeNamespace
)
{
rawNode
.
setAttributeDevtoolsNS
(
change
.
attributeNamespace
change
.
attributeName
change
.
newValue
)
;
}
else
{
rawNode
.
setAttributeDevtools
(
change
.
attributeName
change
.
newValue
)
;
}
}
}
getFontFamilyDataURL
(
font
fillStyle
=
"
black
"
)
{
const
doc
=
this
.
rawNode
.
ownerDocument
;
const
options
=
{
previewText
:
FONT_FAMILY_PREVIEW_TEXT
previewFontSize
:
FONT_FAMILY_PREVIEW_TEXT_SIZE
fillStyle
}
;
const
{
dataURL
size
}
=
getFontPreviewData
(
font
doc
options
)
;
return
{
data
:
LongStringActor
(
this
.
conn
dataURL
)
size
}
;
}
getClosestBackgroundColor
(
)
{
return
getClosestBackgroundColor
(
this
.
rawNode
)
;
}
getBackgroundColor
(
)
{
return
getBackgroundColor
(
this
)
;
}
getOwnerGlobalDimensions
(
)
{
const
win
=
this
.
rawNode
.
ownerGlobal
;
return
{
innerWidth
:
win
.
innerWidth
innerHeight
:
win
.
innerHeight
}
;
}
async
waitForFrameLoad
(
)
{
if
(
this
.
useChildTargetToFetchChildren
)
{
throw
new
Error
(
"
iframe
content
document
has
its
own
target
use
that
one
instead
"
)
;
}
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
)
{
throw
new
Error
(
"
Node
is
dead
"
)
;
}
const
{
contentDocument
}
=
this
.
rawNode
;
if
(
!
contentDocument
)
{
throw
new
Error
(
"
Can
'
t
access
contentDocument
"
)
;
}
if
(
contentDocument
.
readyState
=
=
=
"
uninitialized
"
)
{
const
{
chromeEventHandler
}
=
this
.
rawNode
.
ownerGlobal
.
docShell
;
const
browsingContextID
=
this
.
rawNode
.
browsingContext
.
id
;
await
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_waitForFrameLoadAbortController
=
new
AbortController
(
)
;
chromeEventHandler
.
addEventListener
(
"
DOMDocElementInserted
"
e
=
>
{
const
{
browsingContext
}
=
e
.
target
.
defaultView
;
if
(
browsingContext
.
id
=
=
browsingContextID
)
{
resolve
(
)
;
this
.
_waitForFrameLoadAbortController
.
abort
(
)
;
}
}
{
signal
:
this
.
_waitForFrameLoadAbortController
.
signal
}
)
;
this
.
_waitForFrameLoadIntervalId
=
setInterval
(
(
)
=
>
{
if
(
Cu
.
isDeadWrapper
(
this
.
rawNode
)
|
|
!
this
.
rawNode
.
contentDocument
)
{
reject
(
"
Can
'
t
access
the
iframe
content
document
"
)
;
clearInterval
(
this
.
_waitForFrameLoadIntervalId
)
;
this
.
_waitForFrameLoadIntervalId
=
null
;
this
.
_waitForFrameLoadAbortController
.
abort
(
)
;
}
}
50
)
;
}
)
;
}
if
(
this
.
rawNode
.
contentDocument
.
readyState
=
=
=
"
loading
"
)
{
await
new
Promise
(
resolve
=
>
{
DOMHelpers
.
onceDOMReady
(
this
.
rawNode
.
contentWindow
resolve
)
;
}
)
;
}
}
}
)
;
const
NodeListActor
=
protocol
.
ActorClassWithSpec
(
nodeListSpec
{
initialize
(
walker
nodeList
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
)
;
this
.
walker
=
walker
;
this
.
nodeList
=
nodeList
|
|
[
]
;
}
destroy
(
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
}
get
conn
(
)
{
return
this
.
walker
.
conn
;
}
marshallPool
(
)
{
return
this
.
walker
;
}
form
(
)
{
return
{
actor
:
this
.
actorID
length
:
this
.
nodeList
?
this
.
nodeList
.
length
:
0
}
;
}
item
(
index
)
{
return
this
.
walker
.
attachElement
(
this
.
nodeList
[
index
]
)
;
}
items
(
start
=
0
end
=
this
.
nodeList
.
length
)
{
const
items
=
Array
.
prototype
.
slice
.
call
(
this
.
nodeList
start
end
)
.
map
(
item
=
>
this
.
walker
.
_getOrCreateNodeActor
(
item
)
)
;
return
this
.
walker
.
attachElements
(
items
)
;
}
release
(
)
{
}
}
)
;
exports
.
NodeActor
=
NodeActor
;
exports
.
NodeListActor
=
NodeListActor
;
