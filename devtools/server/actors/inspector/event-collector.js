"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
makeDebugger
=
require
(
"
devtools
/
server
/
actors
/
utils
/
make
-
debugger
"
)
;
const
JQUERY_LIVE_REGEX
=
/
return
typeof
\
w
+
.
*
.
event
\
.
triggered
[
\
s
\
S
]
*
\
.
event
\
.
(
dispatch
|
handle
)
.
*
arguments
/
;
const
REACT_EVENT_NAMES
=
[
"
onAbort
"
"
onAnimationEnd
"
"
onAnimationIteration
"
"
onAnimationStart
"
"
onAuxClick
"
"
onBeforeInput
"
"
onBlur
"
"
onCanPlay
"
"
onCanPlayThrough
"
"
onCancel
"
"
onChange
"
"
onClick
"
"
onClose
"
"
onCompositionEnd
"
"
onCompositionStart
"
"
onCompositionUpdate
"
"
onContextMenu
"
"
onCopy
"
"
onCut
"
"
onDoubleClick
"
"
onDrag
"
"
onDragEnd
"
"
onDragEnter
"
"
onDragExit
"
"
onDragLeave
"
"
onDragOver
"
"
onDragStart
"
"
onDrop
"
"
onDurationChange
"
"
onEmptied
"
"
onEncrypted
"
"
onEnded
"
"
onError
"
"
onFocus
"
"
onGotPointerCapture
"
"
onInput
"
"
onInvalid
"
"
onKeyDown
"
"
onKeyPress
"
"
onKeyUp
"
"
onLoad
"
"
onLoadStart
"
"
onLoadedData
"
"
onLoadedMetadata
"
"
onLostPointerCapture
"
"
onMouseDown
"
"
onMouseEnter
"
"
onMouseLeave
"
"
onMouseMove
"
"
onMouseOut
"
"
onMouseOver
"
"
onMouseUp
"
"
onPaste
"
"
onPause
"
"
onPlay
"
"
onPlaying
"
"
onPointerCancel
"
"
onPointerDown
"
"
onPointerEnter
"
"
onPointerLeave
"
"
onPointerMove
"
"
onPointerOut
"
"
onPointerOver
"
"
onPointerUp
"
"
onProgress
"
"
onRateChange
"
"
onReset
"
"
onScroll
"
"
onSeeked
"
"
onSeeking
"
"
onSelect
"
"
onStalled
"
"
onSubmit
"
"
onSuspend
"
"
onTimeUpdate
"
"
onToggle
"
"
onTouchCancel
"
"
onTouchEnd
"
"
onTouchMove
"
"
onTouchStart
"
"
onTransitionEnd
"
"
onVolumeChange
"
"
onWaiting
"
"
onWheel
"
"
onAbortCapture
"
"
onAnimationEndCapture
"
"
onAnimationIterationCapture
"
"
onAnimationStartCapture
"
"
onAuxClickCapture
"
"
onBeforeInputCapture
"
"
onBlurCapture
"
"
onCanPlayCapture
"
"
onCanPlayThroughCapture
"
"
onCancelCapture
"
"
onChangeCapture
"
"
onClickCapture
"
"
onCloseCapture
"
"
onCompositionEndCapture
"
"
onCompositionStartCapture
"
"
onCompositionUpdateCapture
"
"
onContextMenuCapture
"
"
onCopyCapture
"
"
onCutCapture
"
"
onDoubleClickCapture
"
"
onDragCapture
"
"
onDragEndCapture
"
"
onDragEnterCapture
"
"
onDragExitCapture
"
"
onDragLeaveCapture
"
"
onDragOverCapture
"
"
onDragStartCapture
"
"
onDropCapture
"
"
onDurationChangeCapture
"
"
onEmptiedCapture
"
"
onEncryptedCapture
"
"
onEndedCapture
"
"
onErrorCapture
"
"
onFocusCapture
"
"
onGotPointerCaptureCapture
"
"
onInputCapture
"
"
onInvalidCapture
"
"
onKeyDownCapture
"
"
onKeyPressCapture
"
"
onKeyUpCapture
"
"
onLoadCapture
"
"
onLoadStartCapture
"
"
onLoadedDataCapture
"
"
onLoadedMetadataCapture
"
"
onLostPointerCaptureCapture
"
"
onMouseDownCapture
"
"
onMouseEnterCapture
"
"
onMouseLeaveCapture
"
"
onMouseMoveCapture
"
"
onMouseOutCapture
"
"
onMouseOverCapture
"
"
onMouseUpCapture
"
"
onPasteCapture
"
"
onPauseCapture
"
"
onPlayCapture
"
"
onPlayingCapture
"
"
onPointerCancelCapture
"
"
onPointerDownCapture
"
"
onPointerEnterCapture
"
"
onPointerLeaveCapture
"
"
onPointerMoveCapture
"
"
onPointerOutCapture
"
"
onPointerOverCapture
"
"
onPointerUpCapture
"
"
onProgressCapture
"
"
onRateChangeCapture
"
"
onResetCapture
"
"
onScrollCapture
"
"
onSeekedCapture
"
"
onSeekingCapture
"
"
onSelectCapture
"
"
onStalledCapture
"
"
onSubmitCapture
"
"
onSuspendCapture
"
"
onTimeUpdateCapture
"
"
onToggleCapture
"
"
onTouchCancelCapture
"
"
onTouchEndCapture
"
"
onTouchMoveCapture
"
"
onTouchStartCapture
"
"
onTransitionEndCapture
"
"
onVolumeChangeCapture
"
"
onWaitingCapture
"
"
onWheelCapture
"
]
;
class
MainEventCollector
{
hasListeners
(
node
)
{
return
this
.
getListeners
(
node
{
checkOnly
:
true
}
)
;
}
getListeners
(
node
{
checkOnly
}
)
{
throw
new
Error
(
"
You
have
to
implement
the
method
getListeners
(
)
!
"
)
;
}
getDOMListeners
(
node
)
{
if
(
typeof
node
.
nodeName
!
=
=
"
undefined
"
&
&
node
.
nodeName
.
toLowerCase
(
)
=
=
=
"
html
"
)
{
const
winListeners
=
Services
.
els
.
getListenerInfoFor
(
node
.
ownerGlobal
)
|
|
[
]
;
const
docElementListeners
=
Services
.
els
.
getListenerInfoFor
(
node
)
|
|
[
]
;
const
docListeners
=
Services
.
els
.
getListenerInfoFor
(
node
.
parentNode
)
|
|
[
]
;
return
[
.
.
.
winListeners
.
.
.
docElementListeners
.
.
.
docListeners
]
;
}
return
Services
.
els
.
getListenerInfoFor
(
node
)
|
|
[
]
;
}
getJQuery
(
node
)
{
const
global
=
this
.
unwrap
(
node
.
ownerGlobal
)
;
const
hasJQuery
=
global
.
jQuery
&
&
global
.
jQuery
.
fn
&
&
global
.
jQuery
.
fn
.
jquery
;
if
(
hasJQuery
)
{
return
global
.
jQuery
;
}
return
null
;
}
unwrap
(
obj
)
{
return
Cu
.
isXrayWrapper
(
obj
)
?
obj
.
wrappedJSObject
:
obj
;
}
}
class
DOMEventCollector
extends
MainEventCollector
{
getListeners
(
node
{
checkOnly
}
=
{
}
)
{
const
handlers
=
[
]
;
const
listeners
=
this
.
getDOMListeners
(
node
)
;
for
(
const
listener
of
listeners
)
{
if
(
!
listener
.
type
)
{
continue
;
}
const
obj
=
listener
.
listenerObject
;
if
(
!
obj
)
{
continue
;
}
let
handler
=
null
;
if
(
typeof
obj
=
=
=
"
object
"
)
{
const
unwrapped
=
this
.
unwrap
(
obj
)
;
if
(
typeof
unwrapped
.
handleEvent
=
=
=
"
function
"
)
{
handler
=
Cu
.
unwaiveXrays
(
unwrapped
.
handleEvent
)
;
}
}
else
if
(
typeof
obj
=
=
=
"
function
"
)
{
if
(
JQUERY_LIVE_REGEX
.
test
(
obj
.
toString
(
)
)
)
{
continue
;
}
handler
=
obj
;
}
if
(
!
handler
)
{
continue
;
}
if
(
checkOnly
)
{
return
true
;
}
const
eventInfo
=
{
capturing
:
listener
.
capturing
type
:
listener
.
type
handler
:
handler
}
;
handlers
.
push
(
eventInfo
)
;
}
if
(
checkOnly
)
{
return
false
;
}
return
handlers
;
}
}
class
JQueryEventCollector
extends
MainEventCollector
{
getListeners
(
node
{
checkOnly
}
=
{
}
)
{
const
jQuery
=
this
.
getJQuery
(
node
)
;
const
handlers
=
[
]
;
if
(
!
jQuery
)
{
if
(
checkOnly
)
{
return
false
;
}
return
handlers
;
}
let
eventsObj
=
null
;
const
data
=
jQuery
.
_data
|
|
jQuery
.
data
;
if
(
data
)
{
eventsObj
=
data
(
node
"
events
"
)
;
}
else
{
const
entry
=
jQuery
(
node
)
[
0
]
;
if
(
!
entry
|
|
!
entry
.
events
)
{
if
(
checkOnly
)
{
return
false
;
}
return
handlers
;
}
eventsObj
=
entry
.
events
;
}
if
(
eventsObj
)
{
for
(
const
[
type
events
]
of
Object
.
entries
(
eventsObj
)
)
{
for
(
const
[
event
]
of
Object
.
entries
(
events
)
)
{
if
(
node
.
nodeType
=
=
node
.
DOCUMENT_NODE
&
&
event
.
selector
)
{
continue
;
}
if
(
typeof
event
=
=
=
"
function
"
|
|
typeof
event
=
=
=
"
object
"
)
{
if
(
checkOnly
)
{
return
true
;
}
const
eventInfo
=
{
type
:
type
handler
:
event
.
handler
|
|
event
tags
:
"
jQuery
"
hide
:
{
capturing
:
true
dom0
:
true
}
}
;
handlers
.
push
(
eventInfo
)
;
}
}
}
}
if
(
checkOnly
)
{
return
false
;
}
return
handlers
;
}
}
class
JQueryLiveEventCollector
extends
MainEventCollector
{
getListeners
(
node
{
checkOnly
}
=
{
}
)
{
const
jQuery
=
this
.
getJQuery
(
node
)
;
const
handlers
=
[
]
;
if
(
!
jQuery
)
{
if
(
checkOnly
)
{
return
false
;
}
return
handlers
;
}
const
data
=
jQuery
.
_data
|
|
jQuery
.
data
;
if
(
data
)
{
const
win
=
this
.
unwrap
(
node
.
ownerGlobal
)
;
const
events
=
data
(
win
.
document
"
events
"
)
;
if
(
events
)
{
for
(
const
[
eventHolder
]
of
Object
.
entries
(
events
)
)
{
for
(
const
[
idx
event
]
of
Object
.
entries
(
eventHolder
)
)
{
if
(
typeof
idx
!
=
=
"
string
"
|
|
isNaN
(
parseInt
(
idx
10
)
)
)
{
continue
;
}
let
selector
=
event
.
selector
;
if
(
!
selector
&
&
event
.
data
)
{
selector
=
event
.
data
.
selector
|
|
event
.
data
|
|
event
.
selector
;
}
if
(
!
selector
|
|
!
node
.
ownerDocument
)
{
continue
;
}
let
matches
;
try
{
matches
=
node
.
matches
&
&
node
.
matches
(
selector
)
;
}
catch
(
e
)
{
}
if
(
!
matches
)
{
continue
;
}
if
(
typeof
event
=
=
=
"
function
"
|
|
typeof
event
=
=
=
"
object
"
)
{
if
(
checkOnly
)
{
return
true
;
}
const
eventInfo
=
{
type
:
event
.
origType
|
|
event
.
type
.
substr
(
selector
.
length
+
1
)
handler
:
event
.
handler
|
|
event
tags
:
"
jQuery
Live
"
hide
:
{
dom0
:
true
capturing
:
true
}
}
;
if
(
!
eventInfo
.
type
&
&
event
.
data
&
&
event
.
data
.
live
)
{
eventInfo
.
type
=
event
.
data
.
live
;
}
handlers
.
push
(
eventInfo
)
;
}
}
}
}
}
if
(
checkOnly
)
{
return
false
;
}
return
handlers
;
}
normalizeListener
(
handlerDO
)
{
function
isFunctionInProxy
(
funcDO
)
{
const
displayName
=
funcDO
.
displayName
;
if
(
displayName
&
&
displayName
.
startsWith
(
"
proxy
/
"
)
)
{
return
true
;
}
const
calleeDO
=
funcDO
.
environment
.
callee
;
if
(
!
calleeDO
)
{
return
false
;
}
const
calleeName
=
calleeDO
.
displayName
;
return
calleeName
=
=
"
proxy
"
;
}
function
getFirstFunctionVariable
(
funcDO
)
{
const
names
=
funcDO
.
environment
.
names
(
)
;
for
(
const
varName
of
names
)
{
const
varDO
=
handlerDO
.
environment
.
getVariable
(
varName
)
;
if
(
!
varDO
)
{
continue
;
}
if
(
varDO
.
class
=
=
"
Function
"
)
{
return
varDO
;
}
}
return
null
;
}
if
(
!
isFunctionInProxy
(
handlerDO
)
)
{
return
handlerDO
;
}
const
MAX_NESTED_HANDLER_COUNT
=
2
;
for
(
let
i
=
0
;
i
<
MAX_NESTED_HANDLER_COUNT
;
i
+
+
)
{
const
funcDO
=
getFirstFunctionVariable
(
handlerDO
)
;
if
(
!
funcDO
)
{
return
handlerDO
;
}
handlerDO
=
funcDO
;
if
(
isFunctionInProxy
(
handlerDO
)
)
{
continue
;
}
break
;
}
return
handlerDO
;
}
}
class
ReactEventCollector
extends
MainEventCollector
{
getListeners
(
node
{
checkOnly
}
=
{
}
)
{
const
handlers
=
[
]
;
const
props
=
this
.
getProps
(
node
)
;
if
(
props
)
{
for
(
const
[
name
prop
]
of
Object
.
entries
(
props
)
)
{
if
(
REACT_EVENT_NAMES
.
includes
(
name
)
)
{
const
listener
=
prop
.
__reactBoundMethod
|
|
prop
;
if
(
typeof
listener
!
=
=
"
function
"
)
{
continue
;
}
if
(
checkOnly
)
{
return
true
;
}
const
handler
=
{
type
:
name
handler
:
listener
tags
:
"
React
"
hide
:
{
dom0
:
true
}
override
:
{
capturing
:
name
.
endsWith
(
"
Capture
"
)
}
}
;
handlers
.
push
(
handler
)
;
}
}
}
if
(
checkOnly
)
{
return
false
;
}
return
handlers
;
}
getProps
(
node
)
{
node
=
this
.
unwrap
(
node
)
;
for
(
const
key
of
Object
.
keys
(
node
)
)
{
if
(
key
.
startsWith
(
"
__reactInternalInstance
"
)
)
{
const
value
=
node
[
key
]
;
if
(
value
.
memoizedProps
)
{
return
value
.
memoizedProps
;
}
return
value
.
_currentElement
.
props
;
}
}
return
null
;
}
normalizeListener
(
handlerDO
listener
)
{
let
functionText
=
"
"
;
if
(
handlerDO
.
boundTargetFunction
)
{
handlerDO
=
handlerDO
.
boundTargetFunction
;
}
const
introScript
=
handlerDO
.
script
.
source
.
introductionScript
;
const
script
=
handlerDO
.
script
;
if
(
introScript
&
&
introScript
.
displayName
.
endsWith
(
"
/
transform
.
run
"
)
)
{
listener
.
hide
.
debugger
=
true
;
listener
.
hide
.
filename
=
true
;
if
(
!
handlerDO
.
isArrowFunction
)
{
functionText
+
=
"
function
(
"
;
}
else
{
functionText
+
=
"
(
"
;
}
functionText
+
=
handlerDO
.
parameterNames
.
join
(
"
"
)
;
functionText
+
=
"
)
{
\
n
"
;
const
scriptSource
=
script
.
source
.
text
;
functionText
+
=
scriptSource
.
substr
(
script
.
sourceStart
script
.
sourceLength
)
;
listener
.
override
.
handler
=
functionText
;
}
return
handlerDO
;
}
}
class
EventCollector
{
constructor
(
)
{
this
.
eventCollectors
=
[
new
ReactEventCollector
(
)
new
JQueryLiveEventCollector
(
)
new
JQueryEventCollector
(
)
new
DOMEventCollector
(
)
]
;
this
.
makeDebuggerForContent
=
makeDebugger
.
bind
(
null
{
findDebuggees
:
dbg
=
>
[
]
shouldAddNewGlobalAsDebuggee
:
global
=
>
true
}
)
;
}
destroy
(
)
{
this
.
eventCollectors
=
null
;
this
.
makeDebuggerForContent
=
null
;
}
hasEventListeners
(
node
)
{
for
(
const
collector
of
this
.
eventCollectors
)
{
if
(
collector
.
hasListeners
(
node
)
)
{
return
true
;
}
}
return
false
;
}
getEventListeners
(
node
)
{
const
listenerArray
=
[
]
;
const
dbg
=
this
.
makeDebuggerForContent
(
)
;
const
global
=
Cu
.
getGlobalForObject
(
node
)
;
const
globalDO
=
dbg
.
addDebuggee
(
global
)
;
for
(
const
collector
of
this
.
eventCollectors
)
{
const
listeners
=
collector
.
getListeners
(
node
)
;
if
(
!
listeners
)
{
continue
;
}
for
(
const
listener
of
listeners
)
{
if
(
collector
.
normalizeListener
)
{
listener
.
normalizeListener
=
collector
.
normalizeListener
;
}
this
.
processHandlerForEvent
(
listenerArray
listener
globalDO
)
;
}
}
dbg
.
removeDebuggee
(
globalDO
)
;
listenerArray
.
sort
(
(
a
b
)
=
>
{
return
a
.
type
.
localeCompare
(
b
.
type
)
;
}
)
;
return
listenerArray
;
}
processHandlerForEvent
(
listenerArray
listener
globalDO
)
{
const
{
capturing
handler
}
=
listener
;
let
listenerDO
=
globalDO
.
makeDebuggeeValue
(
handler
)
;
const
{
normalizeListener
}
=
listener
;
if
(
normalizeListener
)
{
listenerDO
=
normalizeListener
(
listenerDO
listener
)
;
}
const
hide
=
listener
.
hide
|
|
{
}
;
const
override
=
listener
.
override
|
|
{
}
;
const
tags
=
listener
.
tags
|
|
"
"
;
const
type
=
listener
.
type
|
|
"
"
;
let
dom0
=
false
;
let
functionSource
=
handler
.
toString
(
)
;
let
line
=
0
;
let
native
=
false
;
let
url
=
"
"
;
if
(
listenerDO
.
class
=
=
=
"
Object
"
|
|
/
^
XUL
\
w
*
Element
/
.
test
(
listenerDO
.
class
)
)
{
let
desc
;
while
(
!
desc
&
&
listenerDO
)
{
desc
=
listenerDO
.
getOwnPropertyDescriptor
(
"
handleEvent
"
)
;
listenerDO
=
listenerDO
.
proto
;
}
if
(
desc
&
&
desc
.
value
)
{
listenerDO
=
desc
.
value
;
}
}
if
(
listenerDO
.
isBoundFunction
)
{
listenerDO
=
listenerDO
.
boundTargetFunction
;
}
const
{
isArrowFunction
name
script
parameterNames
}
=
listenerDO
;
if
(
script
)
{
const
scriptSource
=
script
.
source
.
text
;
if
(
script
.
source
.
element
)
{
dom0
=
script
.
source
.
element
.
class
!
=
=
"
HTMLScriptElement
"
;
}
else
{
dom0
=
false
;
}
line
=
script
.
startLine
;
url
=
script
.
url
;
if
(
functionSource
=
=
=
"
[
object
Object
]
"
|
|
functionSource
=
=
=
"
[
object
XULElement
]
"
|
|
functionSource
.
includes
(
"
[
native
code
]
"
)
)
{
functionSource
=
scriptSource
.
substr
(
script
.
sourceStart
script
.
sourceLength
)
;
if
(
!
isArrowFunction
)
{
functionSource
=
"
function
"
+
functionSource
;
}
}
}
else
{
native
=
true
;
}
if
(
parameterNames
&
&
parameterNames
.
length
>
0
)
{
const
prefix
=
"
function
"
+
name
+
"
(
)
"
;
const
paramString
=
parameterNames
.
join
(
"
"
)
;
if
(
functionSource
.
startsWith
(
prefix
)
)
{
functionSource
=
functionSource
.
substr
(
prefix
.
length
)
;
functionSource
=
function
{
name
}
(
{
paramString
}
)
{
functionSource
}
;
}
}
let
origin
;
if
(
native
)
{
origin
=
"
[
native
code
]
"
;
}
else
{
origin
=
url
+
(
(
dom0
|
|
line
=
=
=
0
)
?
"
"
:
"
:
"
+
line
)
;
}
const
eventObj
=
{
type
:
override
.
type
|
|
type
handler
:
override
.
handler
|
|
functionSource
.
trim
(
)
origin
:
override
.
origin
|
|
origin
tags
:
override
.
tags
|
|
tags
DOM0
:
typeof
override
.
dom0
!
=
=
"
undefined
"
?
override
.
dom0
:
dom0
capturing
:
typeof
override
.
capturing
!
=
=
"
undefined
"
?
override
.
capturing
:
capturing
hide
:
typeof
override
.
hide
!
=
=
"
undefined
"
?
override
.
hide
:
hide
native
}
;
if
(
native
|
|
dom0
)
{
eventObj
.
hide
.
debugger
=
true
;
}
listenerArray
.
push
(
eventObj
)
;
}
}
exports
.
EventCollector
=
EventCollector
;
