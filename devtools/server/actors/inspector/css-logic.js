"
use
strict
"
;
const
nodeConstants
=
require
(
"
resource
:
/
/
devtools
/
shared
/
dom
-
node
-
constants
.
js
"
)
;
const
{
getBindingElementAndPseudo
getMatchingCSSRules
hasVisitedState
isAgentStylesheet
isAuthorStylesheet
isUserStylesheet
shortSource
FILTER
STATUS
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
inspector
/
css
-
logic
.
js
"
)
;
const
COMPAREMODE
=
{
BOOLEAN
:
"
bool
"
INTEGER
:
"
int
"
}
;
class
CssLogic
{
constructor
(
)
{
this
.
_propertyInfos
=
{
}
;
}
viewedElement
=
null
;
viewedDocument
=
null
;
_sheets
=
null
;
_sheetsCached
=
false
;
_ruleCount
=
0
;
_computedStyle
=
null
;
_sourceFilter
=
FILTER
.
USER
;
_passId
=
0
;
_matchId
=
0
;
_matchedRules
=
null
;
_matchedSelectors
=
null
;
_keyframesRules
=
null
;
reset
(
)
{
this
.
_propertyInfos
=
{
}
;
this
.
_ruleCount
=
0
;
this
.
_sheetIndex
=
0
;
this
.
_sheets
=
{
}
;
this
.
_sheetsCached
=
false
;
this
.
_matchedRules
=
null
;
this
.
_matchedSelectors
=
null
;
this
.
_keyframesRules
=
[
]
;
}
highlight
(
viewedElement
)
{
if
(
!
viewedElement
)
{
this
.
viewedElement
=
null
;
this
.
viewedDocument
=
null
;
this
.
_computedStyle
=
null
;
this
.
reset
(
)
;
return
;
}
if
(
viewedElement
=
=
=
this
.
viewedElement
)
{
return
;
}
this
.
viewedElement
=
viewedElement
;
const
doc
=
this
.
viewedElement
.
ownerDocument
;
if
(
doc
!
=
this
.
viewedDocument
)
{
this
.
viewedDocument
=
doc
;
this
.
_cacheSheets
(
)
;
}
else
{
this
.
_propertyInfos
=
{
}
;
}
this
.
_matchedRules
=
null
;
this
.
_matchedSelectors
=
null
;
this
.
_computedStyle
=
CssLogic
.
getComputedStyle
(
this
.
viewedElement
)
;
}
get
computedStyle
(
)
{
return
this
.
_computedStyle
;
}
get
sourceFilter
(
)
{
return
this
.
_sourceFilter
;
}
set
sourceFilter
(
value
)
{
const
oldValue
=
this
.
_sourceFilter
;
this
.
_sourceFilter
=
value
;
let
ruleCount
=
0
;
this
.
forEachSheet
(
function
(
sheet
)
{
if
(
sheet
.
authorSheet
&
&
sheet
.
sheetAllowed
)
{
ruleCount
+
=
sheet
.
ruleCount
;
}
}
this
)
;
this
.
_ruleCount
=
ruleCount
;
const
needFullUpdate
=
oldValue
=
=
FILTER
.
UA
|
|
value
=
=
FILTER
.
UA
;
if
(
needFullUpdate
)
{
this
.
_matchedRules
=
null
;
this
.
_matchedSelectors
=
null
;
this
.
_propertyInfos
=
{
}
;
}
else
{
for
(
const
property
in
this
.
_propertyInfos
)
{
this
.
_propertyInfos
[
property
]
.
needRefilter
=
true
;
}
}
}
getPropertyInfo
(
property
)
{
if
(
!
this
.
viewedElement
)
{
return
{
}
;
}
let
info
=
this
.
_propertyInfos
[
property
]
;
if
(
!
info
)
{
info
=
new
CssPropertyInfo
(
this
property
)
;
this
.
_propertyInfos
[
property
]
=
info
;
}
return
info
;
}
_cacheSheets
(
)
{
this
.
_passId
+
+
;
this
.
reset
(
)
;
const
styleSheets
=
InspectorUtils
.
getAllStyleSheets
(
this
.
viewedDocument
true
)
;
Array
.
prototype
.
forEach
.
call
(
styleSheets
this
.
_cacheSheet
this
)
;
this
.
_sheetsCached
=
true
;
}
_cacheSheet
(
domSheet
)
{
if
(
domSheet
.
disabled
)
{
return
;
}
if
(
!
this
.
mediaMatches
(
domSheet
)
)
{
return
;
}
const
cssSheet
=
this
.
getSheet
(
domSheet
this
.
_sheetIndex
+
+
)
;
if
(
cssSheet
.
_passId
!
=
this
.
_passId
)
{
cssSheet
.
_passId
=
this
.
_passId
;
const
traverseRules
=
ruleList
=
>
{
for
(
const
aDomRule
of
ruleList
)
{
const
ruleClassName
=
ChromeUtils
.
getClassName
(
aDomRule
)
;
if
(
ruleClassName
=
=
=
"
CSSImportRule
"
&
&
aDomRule
.
styleSheet
&
&
this
.
mediaMatches
(
aDomRule
)
)
{
this
.
_cacheSheet
(
aDomRule
.
styleSheet
)
;
}
else
if
(
ruleClassName
=
=
=
"
CSSKeyframesRule
"
)
{
this
.
_keyframesRules
.
push
(
aDomRule
)
;
}
if
(
aDomRule
.
cssRules
)
{
traverseRules
(
aDomRule
.
cssRules
)
;
}
}
}
;
traverseRules
(
cssSheet
.
getCssRules
(
)
)
;
}
}
get
sheets
(
)
{
if
(
!
this
.
_sheetsCached
)
{
this
.
_cacheSheets
(
)
;
}
const
sheets
=
[
]
;
this
.
forEachSheet
(
function
(
sheet
)
{
if
(
sheet
.
authorSheet
)
{
sheets
.
push
(
sheet
)
;
}
}
this
)
;
return
sheets
;
}
get
keyframesRules
(
)
{
if
(
!
this
.
_sheetsCached
)
{
this
.
_cacheSheets
(
)
;
}
return
this
.
_keyframesRules
;
}
getSheet
(
domSheet
index
)
{
let
cacheId
=
"
"
;
if
(
domSheet
.
href
)
{
cacheId
=
domSheet
.
href
;
}
else
if
(
domSheet
.
associatedDocument
)
{
cacheId
=
domSheet
.
associatedDocument
.
location
;
}
let
sheet
=
null
;
let
sheetFound
=
false
;
if
(
cacheId
in
this
.
_sheets
)
{
for
(
sheet
of
this
.
_sheets
[
cacheId
]
)
{
if
(
sheet
.
domSheet
=
=
=
domSheet
)
{
if
(
index
!
=
-
1
)
{
sheet
.
index
=
index
;
}
sheetFound
=
true
;
break
;
}
}
}
if
(
!
sheetFound
)
{
if
(
!
(
cacheId
in
this
.
_sheets
)
)
{
this
.
_sheets
[
cacheId
]
=
[
]
;
}
sheet
=
new
CssSheet
(
this
domSheet
index
)
;
if
(
sheet
.
sheetAllowed
&
&
sheet
.
authorSheet
)
{
this
.
_ruleCount
+
=
sheet
.
ruleCount
;
}
this
.
_sheets
[
cacheId
]
.
push
(
sheet
)
;
}
return
sheet
;
}
forEachSheet
(
callback
scope
)
{
for
(
const
cacheId
in
this
.
_sheets
)
{
const
sheets
=
this
.
_sheets
[
cacheId
]
;
for
(
let
i
=
0
;
i
<
sheets
.
length
;
i
+
+
)
{
try
{
const
sheet
=
sheets
[
i
]
;
sheet
.
domSheet
;
callback
.
call
(
scope
sheet
i
sheets
)
;
}
catch
(
e
)
{
sheets
.
splice
(
i
1
)
;
i
-
-
;
}
}
}
}
get
ruleCount
(
)
{
if
(
!
this
.
_sheetsCached
)
{
this
.
_cacheSheets
(
)
;
}
return
this
.
_ruleCount
;
}
processMatchedSelectors
(
callback
scope
)
{
if
(
this
.
_matchedSelectors
)
{
if
(
callback
)
{
this
.
_passId
+
+
;
this
.
_matchedSelectors
.
forEach
(
function
(
value
)
{
callback
.
call
(
scope
value
[
0
]
value
[
1
]
)
;
value
[
0
]
.
cssRule
.
_passId
=
this
.
_passId
;
}
this
)
;
}
return
;
}
if
(
!
this
.
_matchedRules
)
{
this
.
_buildMatchedRules
(
)
;
}
this
.
_matchedSelectors
=
[
]
;
this
.
_passId
+
+
;
for
(
const
matchedRule
of
this
.
_matchedRules
)
{
const
[
rule
status
distance
]
=
matchedRule
;
rule
.
selectors
.
forEach
(
function
(
selector
)
{
if
(
selector
.
_matchId
!
=
=
this
.
_matchId
&
&
(
selector
.
inlineStyle
|
|
this
.
selectorMatchesElement
(
rule
.
domRule
selector
.
selectorIndex
)
)
)
{
selector
.
_matchId
=
this
.
_matchId
;
this
.
_matchedSelectors
.
push
(
[
selector
status
distance
]
)
;
if
(
callback
)
{
callback
.
call
(
scope
selector
status
distance
)
;
}
}
}
this
)
;
rule
.
_passId
=
this
.
_passId
;
}
}
selectorMatchesElement
(
domRule
idx
)
{
let
element
=
this
.
viewedElement
;
do
{
if
(
domRule
.
selectorMatchesElement
(
idx
element
)
)
{
return
true
;
}
}
while
(
(
element
=
element
.
flattenedTreeParentNode
)
&
&
element
.
nodeType
=
=
=
nodeConstants
.
ELEMENT_NODE
)
;
return
false
;
}
hasMatchedSelectors
(
properties
)
{
if
(
!
this
.
_matchedRules
)
{
this
.
_buildMatchedRules
(
)
;
}
const
result
=
new
Set
(
)
;
for
(
const
[
rule
status
]
of
this
.
_matchedRules
)
{
let
cssText
;
const
getCssText
=
(
)
=
>
{
if
(
cssText
=
=
=
undefined
)
{
cssText
=
rule
.
domRule
.
cssText
;
}
return
cssText
;
}
;
for
(
let
i
=
properties
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
property
=
properties
[
i
]
;
if
(
(
rule
.
getPropertyValue
(
property
)
|
|
(
property
.
startsWith
(
"
-
-
"
)
&
&
new
RegExp
(
{
property
}
[
^
A
-
Za
-
z0
-
9_
-
]
)
.
test
(
getCssText
(
)
)
)
)
&
&
(
status
=
=
STATUS
.
MATCHED
|
|
(
status
=
=
STATUS
.
PARENT_MATCH
&
&
InspectorUtils
.
isInheritedProperty
(
this
.
viewedDocument
property
)
)
)
)
{
result
.
add
(
property
)
;
properties
.
splice
(
i
1
)
;
}
}
if
(
!
properties
.
length
)
{
return
result
;
}
}
return
result
;
}
_buildMatchedRules
(
)
{
let
domRules
;
let
element
=
this
.
viewedElement
;
const
filter
=
this
.
sourceFilter
;
let
sheetIndex
=
0
;
let
distance
=
0
;
this
.
_matchId
+
+
;
this
.
_passId
+
+
;
this
.
_matchedRules
=
[
]
;
if
(
!
element
)
{
return
;
}
do
{
const
status
=
this
.
viewedElement
=
=
=
element
?
STATUS
.
MATCHED
:
STATUS
.
PARENT_MATCH
;
try
{
domRules
=
getMatchingCSSRules
(
element
)
;
}
catch
(
ex
)
{
console
.
log
(
"
CL__buildMatchedRules
error
:
"
+
ex
)
;
continue
;
}
if
(
element
.
style
&
&
element
.
style
.
length
)
{
const
rule
=
new
CssRule
(
null
{
style
:
element
.
style
}
element
)
;
rule
.
_matchId
=
this
.
_matchId
;
rule
.
_passId
=
this
.
_passId
;
this
.
_matchedRules
.
push
(
[
rule
status
distance
]
)
;
}
if
(
domRules
!
=
=
null
)
{
for
(
let
i
=
domRules
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
domRule
=
domRules
[
i
]
;
const
sheet
=
this
.
getSheet
(
domRule
.
parentStyleSheet
-
1
)
;
if
(
sheet
.
_passId
!
=
=
this
.
_passId
)
{
sheet
.
index
=
sheetIndex
+
+
;
sheet
.
_passId
=
this
.
_passId
;
}
if
(
filter
=
=
=
FILTER
.
USER
&
&
!
sheet
.
authorSheet
)
{
continue
;
}
const
rule
=
sheet
.
getRule
(
domRule
)
;
if
(
rule
.
_passId
=
=
=
this
.
_passId
)
{
continue
;
}
rule
.
_matchId
=
this
.
_matchId
;
rule
.
_passId
=
this
.
_passId
;
this
.
_matchedRules
.
push
(
[
rule
status
distance
]
)
;
}
}
distance
-
-
;
}
while
(
(
element
=
element
.
flattenedTreeParentNode
)
&
&
element
.
nodeType
=
=
=
nodeConstants
.
ELEMENT_NODE
)
;
}
mediaMatches
(
domObject
)
{
const
mediaText
=
domObject
.
media
.
mediaText
;
return
(
!
mediaText
|
|
this
.
viewedDocument
.
defaultView
.
matchMedia
(
mediaText
)
.
matches
)
;
}
}
CssLogic
.
getShortName
=
function
(
element
)
{
if
(
!
element
)
{
return
"
null
"
;
}
if
(
element
.
id
)
{
return
"
#
"
+
element
.
id
;
}
let
priorSiblings
=
0
;
let
temp
=
element
;
while
(
(
temp
=
temp
.
previousElementSibling
)
)
{
priorSiblings
+
+
;
}
return
element
.
tagName
+
"
[
"
+
priorSiblings
+
"
]
"
;
}
;
CssLogic
.
getSelectors
=
function
(
domRule
desugared
=
false
)
{
if
(
ChromeUtils
.
getClassName
(
domRule
)
!
=
=
"
CSSStyleRule
"
)
{
return
[
]
;
}
const
selectors
=
[
]
;
const
len
=
domRule
.
selectorCount
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
selectors
.
push
(
domRule
.
selectorTextAt
(
i
desugared
)
)
;
}
return
selectors
;
}
;
CssLogic
.
getBindingElementAndPseudo
=
getBindingElementAndPseudo
;
CssLogic
.
getComputedStyle
=
function
(
node
)
{
if
(
!
node
|
|
Cu
.
isDeadWrapper
(
node
)
|
|
node
.
nodeType
!
=
=
nodeConstants
.
ELEMENT_NODE
|
|
!
node
.
ownerGlobal
)
{
return
null
;
}
const
{
bindingElement
pseudo
}
=
CssLogic
.
getBindingElementAndPseudo
(
node
)
;
if
(
!
bindingElement
)
{
return
null
;
}
return
node
.
ownerGlobal
.
getComputedStyle
(
bindingElement
pseudo
)
;
}
;
CssLogic
.
href
=
function
(
sheet
)
{
return
sheet
.
href
|
|
sheet
.
associatedDocument
.
location
;
}
;
CssLogic
.
hasVisitedState
=
hasVisitedState
;
class
CssSheet
{
constructor
(
cssLogic
domSheet
index
)
{
this
.
_cssLogic
=
cssLogic
;
this
.
domSheet
=
domSheet
;
this
.
index
=
this
.
authorSheet
?
index
:
-
100
*
index
;
this
.
_href
=
null
;
this
.
_shortSource
=
null
;
this
.
_sheetAllowed
=
null
;
this
.
_rules
=
{
}
;
this
.
_ruleCount
=
-
1
;
}
_passId
=
null
;
_agentSheet
=
null
;
_authorSheet
=
null
;
_userSheet
=
null
;
get
agentSheet
(
)
{
if
(
this
.
_agentSheet
=
=
=
null
)
{
this
.
_agentSheet
=
isAgentStylesheet
(
this
.
domSheet
)
;
}
return
this
.
_agentSheet
;
}
get
authorSheet
(
)
{
if
(
this
.
_authorSheet
=
=
=
null
)
{
this
.
_authorSheet
=
isAuthorStylesheet
(
this
.
domSheet
)
;
}
return
this
.
_authorSheet
;
}
get
userSheet
(
)
{
if
(
this
.
_userSheet
=
=
=
null
)
{
this
.
_userSheet
=
isUserStylesheet
(
this
.
domSheet
)
;
}
return
this
.
_userSheet
;
}
get
disabled
(
)
{
return
this
.
domSheet
.
disabled
;
}
get
href
(
)
{
if
(
this
.
_href
)
{
return
this
.
_href
;
}
this
.
_href
=
CssLogic
.
href
(
this
.
domSheet
)
;
return
this
.
_href
;
}
get
shortSource
(
)
{
if
(
this
.
_shortSource
)
{
return
this
.
_shortSource
;
}
this
.
_shortSource
=
shortSource
(
this
.
domSheet
)
;
return
this
.
_shortSource
;
}
get
sheetAllowed
(
)
{
if
(
this
.
_sheetAllowed
!
=
=
null
)
{
return
this
.
_sheetAllowed
;
}
this
.
_sheetAllowed
=
true
;
const
filter
=
this
.
_cssLogic
.
sourceFilter
;
if
(
filter
=
=
=
FILTER
.
USER
&
&
!
this
.
authorSheet
)
{
this
.
_sheetAllowed
=
false
;
}
if
(
filter
!
=
=
FILTER
.
USER
&
&
filter
!
=
=
FILTER
.
UA
)
{
this
.
_sheetAllowed
=
filter
=
=
=
this
.
href
;
}
return
this
.
_sheetAllowed
;
}
get
ruleCount
(
)
{
try
{
return
this
.
_ruleCount
>
-
1
?
this
.
_ruleCount
:
this
.
getCssRules
(
)
.
length
;
}
catch
(
e
)
{
return
0
;
}
}
getCssRules
(
)
{
try
{
return
this
.
domSheet
.
cssRules
;
}
catch
(
e
)
{
return
[
]
;
}
}
getRule
(
domRule
)
{
const
cacheId
=
domRule
.
type
+
domRule
.
selectorText
;
let
rule
=
null
;
let
ruleFound
=
false
;
if
(
cacheId
in
this
.
_rules
)
{
for
(
rule
of
this
.
_rules
[
cacheId
]
)
{
if
(
rule
.
domRule
=
=
=
domRule
)
{
ruleFound
=
true
;
break
;
}
}
}
if
(
!
ruleFound
)
{
if
(
!
(
cacheId
in
this
.
_rules
)
)
{
this
.
_rules
[
cacheId
]
=
[
]
;
}
rule
=
new
CssRule
(
this
domRule
)
;
this
.
_rules
[
cacheId
]
.
push
(
rule
)
;
}
return
rule
;
}
toString
(
)
{
return
"
CssSheet
[
"
+
this
.
shortSource
+
"
]
"
;
}
}
class
CssRule
{
constructor
(
cssSheet
domRule
element
)
{
this
.
_cssSheet
=
cssSheet
;
this
.
domRule
=
domRule
;
if
(
this
.
_cssSheet
)
{
this
.
_selectors
=
null
;
this
.
line
=
InspectorUtils
.
getRelativeRuleLine
(
this
.
domRule
)
;
this
.
column
=
InspectorUtils
.
getRuleColumn
(
this
.
domRule
)
;
this
.
href
=
this
.
_cssSheet
.
href
;
this
.
authorRule
=
this
.
_cssSheet
.
authorSheet
;
this
.
userRule
=
this
.
_cssSheet
.
userSheet
;
this
.
agentRule
=
this
.
_cssSheet
.
agentSheet
;
}
else
if
(
element
)
{
this
.
_selectors
=
[
new
CssSelector
(
this
"
element
.
style
"
0
)
]
;
this
.
line
=
-
1
;
this
.
href
=
"
#
"
;
this
.
authorRule
=
true
;
this
.
userRule
=
false
;
this
.
agentRule
=
false
;
this
.
sourceElement
=
element
;
}
}
_passId
=
null
;
get
sheetAllowed
(
)
{
return
this
.
_cssSheet
?
this
.
_cssSheet
.
sheetAllowed
:
true
;
}
get
sheetIndex
(
)
{
return
this
.
_cssSheet
?
this
.
_cssSheet
.
index
:
0
;
}
getPropertyValue
(
property
)
{
return
this
.
domRule
.
style
.
getPropertyValue
(
property
)
;
}
getPropertyPriority
(
property
)
{
return
this
.
domRule
.
style
.
getPropertyPriority
(
property
)
;
}
get
selectors
(
)
{
if
(
this
.
_selectors
)
{
return
this
.
_selectors
;
}
this
.
_selectors
=
[
]
;
if
(
!
this
.
domRule
.
selectorText
)
{
return
this
.
_selectors
;
}
const
selectors
=
CssLogic
.
getSelectors
(
this
.
domRule
)
;
for
(
let
i
=
0
len
=
selectors
.
length
;
i
<
len
;
i
+
+
)
{
this
.
_selectors
.
push
(
new
CssSelector
(
this
selectors
[
i
]
i
)
)
;
}
return
this
.
_selectors
;
}
toString
(
)
{
return
"
[
CssRule
"
+
this
.
domRule
.
selectorText
+
"
]
"
;
}
}
class
CssSelector
{
constructor
(
cssRule
selector
index
)
{
this
.
cssRule
=
cssRule
;
this
.
text
=
selector
;
this
.
inlineStyle
=
this
.
text
=
=
"
element
.
style
"
;
this
.
_specificity
=
null
;
this
.
selectorIndex
=
index
;
}
_matchId
=
null
;
get
sourceElement
(
)
{
return
this
.
cssRule
.
sourceElement
;
}
get
href
(
)
{
return
this
.
cssRule
.
href
;
}
get
agentRule
(
)
{
return
this
.
cssRule
.
agentRule
;
}
get
authorRule
(
)
{
return
this
.
cssRule
.
authorRule
;
}
get
userRule
(
)
{
return
this
.
cssRule
.
userRule
;
}
get
sheetAllowed
(
)
{
return
this
.
cssRule
.
sheetAllowed
;
}
get
sheetIndex
(
)
{
return
this
.
cssRule
.
sheetIndex
;
}
get
ruleLine
(
)
{
return
this
.
cssRule
.
line
;
}
get
ruleColumn
(
)
{
return
this
.
cssRule
.
column
;
}
get
specificity
(
)
{
if
(
this
.
inlineStyle
)
{
return
0x40000000
;
}
if
(
typeof
this
.
_specificity
!
=
=
"
number
"
)
{
this
.
_specificity
=
this
.
cssRule
.
domRule
.
selectorSpecificityAt
(
this
.
selectorIndex
)
;
}
return
this
.
_specificity
;
}
toString
(
)
{
return
this
.
text
;
}
}
class
CssPropertyInfo
{
constructor
(
cssLogic
property
)
{
this
.
_cssLogic
=
cssLogic
;
this
.
property
=
property
;
this
.
_value
=
"
"
;
this
.
_matchedSelectors
=
null
;
}
get
value
(
)
{
if
(
!
this
.
_value
&
&
this
.
_cssLogic
.
computedStyle
)
{
try
{
this
.
_value
=
this
.
_cssLogic
.
computedStyle
.
getPropertyValue
(
this
.
property
)
;
}
catch
(
ex
)
{
console
.
log
(
"
Error
reading
computed
style
for
"
+
this
.
property
)
;
console
.
log
(
ex
)
;
}
}
return
this
.
_value
;
}
get
matchedSelectors
(
)
{
if
(
!
this
.
_matchedSelectors
)
{
this
.
_findMatchedSelectors
(
)
;
}
else
if
(
this
.
needRefilter
)
{
this
.
_refilterSelectors
(
)
;
}
return
this
.
_matchedSelectors
;
}
_findMatchedSelectors
(
)
{
this
.
_matchedSelectors
=
[
]
;
this
.
needRefilter
=
false
;
this
.
_cssLogic
.
processMatchedSelectors
(
this
.
_processMatchedSelector
this
)
;
this
.
_matchedSelectors
.
sort
(
(
selectorInfo1
selectorInfo2
)
=
>
selectorInfo1
.
compareTo
(
selectorInfo2
this
.
_matchedSelectors
)
)
;
if
(
this
.
_matchedSelectors
.
length
&
&
this
.
_matchedSelectors
[
0
]
.
status
>
STATUS
.
UNMATCHED
)
{
this
.
_matchedSelectors
[
0
]
.
status
=
STATUS
.
BEST
;
}
}
_processMatchedSelector
(
selector
status
distance
)
{
const
cssRule
=
selector
.
cssRule
;
const
value
=
cssRule
.
getPropertyValue
(
this
.
property
)
;
if
(
value
&
&
(
status
=
=
STATUS
.
MATCHED
|
|
(
status
=
=
STATUS
.
PARENT_MATCH
&
&
InspectorUtils
.
isInheritedProperty
(
this
.
_cssLogic
.
viewedDocument
this
.
property
)
)
)
)
{
const
selectorInfo
=
new
CssSelectorInfo
(
selector
this
.
property
value
status
distance
)
;
this
.
_matchedSelectors
.
push
(
selectorInfo
)
;
}
}
_refilterSelectors
(
)
{
const
passId
=
+
+
this
.
_cssLogic
.
_passId
;
const
iterator
=
function
(
selectorInfo
)
{
const
cssRule
=
selectorInfo
.
selector
.
cssRule
;
if
(
cssRule
.
_passId
!
=
passId
)
{
cssRule
.
_passId
=
passId
;
}
}
;
if
(
this
.
_matchedSelectors
)
{
this
.
_matchedSelectors
.
forEach
(
iterator
)
;
}
this
.
needRefilter
=
false
;
}
toString
(
)
{
return
"
CssPropertyInfo
[
"
+
this
.
property
+
"
]
"
;
}
}
class
CssSelectorInfo
{
constructor
(
selector
property
value
status
distance
)
{
this
.
selector
=
selector
;
this
.
property
=
property
;
this
.
status
=
status
;
this
.
distance
=
distance
;
this
.
value
=
value
;
const
priority
=
this
.
selector
.
cssRule
.
getPropertyPriority
(
this
.
property
)
;
this
.
important
=
priority
=
=
=
"
important
"
;
this
.
parentLayers
=
[
]
;
let
rule
=
selector
.
cssRule
.
domRule
;
while
(
rule
)
{
const
className
=
ChromeUtils
.
getClassName
(
rule
)
;
if
(
className
=
=
"
CSSLayerBlockRule
"
)
{
this
.
parentLayers
.
push
(
rule
.
name
|
|
rule
)
;
}
else
if
(
className
=
=
"
CSSImportRule
"
&
&
rule
.
layerName
!
=
=
null
)
{
this
.
parentLayers
.
push
(
rule
.
layerName
|
|
rule
)
;
}
rule
=
rule
.
parentRule
|
|
rule
.
parentStyleSheet
?
.
ownerRule
;
}
}
get
sourceElement
(
)
{
return
this
.
selector
.
sourceElement
;
}
get
href
(
)
{
return
this
.
selector
.
href
;
}
get
inlineStyle
(
)
{
return
this
.
selector
.
inlineStyle
;
}
get
specificity
(
)
{
return
this
.
selector
.
specificity
;
}
get
sheetIndex
(
)
{
return
this
.
selector
.
sheetIndex
;
}
get
sheetAllowed
(
)
{
return
this
.
selector
.
sheetAllowed
;
}
get
ruleLine
(
)
{
return
this
.
selector
.
ruleLine
;
}
get
ruleColumn
(
)
{
return
this
.
selector
.
ruleColumn
;
}
get
agentRule
(
)
{
return
this
.
selector
.
agentRule
;
}
get
authorRule
(
)
{
return
this
.
selector
.
authorRule
;
}
get
userRule
(
)
{
return
this
.
selector
.
userRule
;
}
compareTo
(
that
selectorInfos
)
{
const
originalOrder
=
selectorInfos
.
indexOf
(
this
)
<
selectorInfos
.
indexOf
(
that
)
?
-
1
:
1
;
if
(
!
this
.
important
&
&
!
that
.
important
)
{
return
originalOrder
;
}
if
(
this
.
important
!
=
=
that
.
important
)
{
return
this
.
important
?
-
1
:
1
;
}
const
thisIsInLayer
=
!
!
this
.
parentLayers
.
length
;
const
thatIsInLayer
=
!
!
that
.
parentLayers
.
length
;
if
(
!
thisIsInLayer
&
&
!
thatIsInLayer
)
{
return
originalOrder
;
}
if
(
this
.
selector
.
inlineStyle
|
|
that
.
selector
.
inlineStyle
)
{
return
this
.
selector
.
inlineStyle
?
-
1
:
1
;
}
if
(
!
thisIsInLayer
|
|
!
thatIsInLayer
)
{
return
thisIsInLayer
?
-
1
:
1
;
}
const
inSameLayers
=
this
.
parentLayers
.
length
=
=
=
that
.
parentLayers
.
length
&
&
this
.
parentLayers
.
every
(
(
layer
i
)
=
>
layer
=
=
=
that
.
parentLayers
[
i
]
)
;
if
(
inSameLayers
)
{
return
originalOrder
;
}
return
originalOrder
*
-
1
;
}
compare
(
that
propertyName
type
)
{
switch
(
type
)
{
case
COMPAREMODE
.
BOOLEAN
:
if
(
this
[
propertyName
]
&
&
!
that
[
propertyName
]
)
{
return
-
1
;
}
if
(
!
this
[
propertyName
]
&
&
that
[
propertyName
]
)
{
return
1
;
}
break
;
case
COMPAREMODE
.
INTEGER
:
if
(
this
[
propertyName
]
>
that
[
propertyName
]
)
{
return
-
1
;
}
if
(
this
[
propertyName
]
<
that
[
propertyName
]
)
{
return
1
;
}
break
;
}
return
0
;
}
toString
(
)
{
return
this
.
selector
+
"
-
>
"
+
this
.
value
;
}
}
exports
.
CssLogic
=
CssLogic
;
exports
.
CssSelector
=
CssSelector
;
