"
use
strict
"
;
const
nodeConstants
=
require
(
"
resource
:
/
/
devtools
/
shared
/
dom
-
node
-
constants
.
js
"
)
;
const
{
getBindingElementAndPseudo
getMatchingCSSRules
hasVisitedState
isAgentStylesheet
isAuthorStylesheet
isUserStylesheet
shortSource
ELEMENT_BACKED_PSEUDO_ELEMENTS
FILTER
STATUS
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
inspector
/
css
-
logic
.
js
"
)
;
const
COMPAREMODE
=
{
BOOLEAN
:
"
bool
"
INTEGER
:
"
int
"
}
;
class
CssLogic
{
static
getShortName
(
element
)
{
if
(
!
element
)
{
return
"
null
"
;
}
if
(
element
.
id
)
{
return
"
#
"
+
element
.
id
;
}
let
priorSiblings
=
0
;
let
temp
=
element
;
while
(
(
temp
=
temp
.
previousElementSibling
)
)
{
priorSiblings
+
+
;
}
return
element
.
tagName
+
"
[
"
+
priorSiblings
+
"
]
"
;
}
static
getSelectors
(
domRule
desugared
=
false
)
{
if
(
ChromeUtils
.
getClassName
(
domRule
)
!
=
=
"
CSSStyleRule
"
)
{
return
[
]
;
}
const
selectors
=
[
]
;
const
len
=
domRule
.
selectorCount
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
selectors
.
push
(
domRule
.
selectorTextAt
(
i
desugared
)
)
;
}
return
selectors
;
}
static
getBindingElementAndPseudo
=
getBindingElementAndPseudo
;
static
getComputedStyle
(
node
)
{
if
(
!
node
|
|
Cu
.
isDeadWrapper
(
node
)
|
|
node
.
nodeType
!
=
=
nodeConstants
.
ELEMENT_NODE
|
|
!
node
.
ownerGlobal
)
{
return
null
;
}
const
{
bindingElement
pseudo
}
=
CssLogic
.
getBindingElementAndPseudo
(
node
)
;
if
(
!
bindingElement
)
{
return
null
;
}
return
node
.
ownerGlobal
.
getComputedStyle
(
bindingElement
pseudo
)
;
}
static
href
(
sheet
)
{
return
sheet
.
href
|
|
sheet
.
associatedDocument
.
location
;
}
static
hasVisitedState
=
hasVisitedState
;
matchId
=
0
;
passId
=
0
;
viewedElement
=
null
;
viewedDocument
=
null
;
#
propertyInfos
=
{
}
;
#
sheets
=
null
;
#
sheetsCached
=
false
;
#
sheetIndex
=
0
;
#
ruleCount
=
0
;
#
computedStyle
=
null
;
#
sourceFilter
=
FILTER
.
USER
;
#
matchedRules
=
null
;
#
matchedSelectors
=
null
;
#
keyframesRules
=
null
;
reset
(
)
{
this
.
#
propertyInfos
=
{
}
;
this
.
#
ruleCount
=
0
;
this
.
#
sheetIndex
=
0
;
this
.
#
sheets
=
{
}
;
this
.
#
sheetsCached
=
false
;
this
.
#
matchedRules
=
null
;
this
.
#
matchedSelectors
=
null
;
this
.
#
keyframesRules
=
[
]
;
}
highlight
(
viewedElement
)
{
if
(
!
viewedElement
)
{
this
.
viewedElement
=
null
;
this
.
viewedDocument
=
null
;
this
.
#
computedStyle
=
null
;
this
.
reset
(
)
;
return
;
}
if
(
viewedElement
=
=
=
this
.
viewedElement
)
{
return
;
}
this
.
viewedElement
=
viewedElement
;
const
doc
=
this
.
viewedElement
.
ownerDocument
;
if
(
doc
!
=
this
.
viewedDocument
)
{
this
.
viewedDocument
=
doc
;
this
.
#
cacheSheets
(
)
;
}
else
{
this
.
#
propertyInfos
=
{
}
;
}
this
.
#
matchedRules
=
null
;
this
.
#
matchedSelectors
=
null
;
this
.
#
computedStyle
=
CssLogic
.
getComputedStyle
(
this
.
viewedElement
)
;
}
get
computedStyle
(
)
{
return
this
.
#
computedStyle
;
}
get
sourceFilter
(
)
{
return
this
.
#
sourceFilter
;
}
set
sourceFilter
(
value
)
{
const
oldValue
=
this
.
#
sourceFilter
;
this
.
#
sourceFilter
=
value
;
let
ruleCount
=
0
;
this
.
forEachSheet
(
function
(
sheet
)
{
if
(
sheet
.
authorSheet
&
&
sheet
.
sheetAllowed
)
{
ruleCount
+
=
sheet
.
ruleCount
;
}
}
this
)
;
this
.
#
ruleCount
=
ruleCount
;
const
needFullUpdate
=
oldValue
=
=
FILTER
.
UA
|
|
value
=
=
FILTER
.
UA
;
if
(
needFullUpdate
)
{
this
.
#
matchedRules
=
null
;
this
.
#
matchedSelectors
=
null
;
this
.
#
propertyInfos
=
{
}
;
}
else
{
for
(
const
property
in
this
.
#
propertyInfos
)
{
this
.
#
propertyInfos
[
property
]
.
needRefilter
=
true
;
}
}
}
getPropertyInfo
(
property
)
{
if
(
!
this
.
viewedElement
)
{
return
{
}
;
}
let
info
=
this
.
#
propertyInfos
[
property
]
;
if
(
!
info
)
{
info
=
new
CssPropertyInfo
(
this
property
)
;
this
.
#
propertyInfos
[
property
]
=
info
;
}
return
info
;
}
#
cacheSheets
(
)
{
this
.
passId
+
+
;
this
.
reset
(
)
;
const
styleSheets
=
InspectorUtils
.
getAllStyleSheets
(
this
.
viewedDocument
true
)
;
Array
.
prototype
.
forEach
.
call
(
styleSheets
this
.
#
cacheSheet
this
)
;
this
.
#
sheetsCached
=
true
;
}
#
cacheSheet
(
domSheet
)
{
if
(
domSheet
.
disabled
)
{
return
;
}
if
(
!
this
.
mediaMatches
(
domSheet
)
)
{
return
;
}
const
cssSheet
=
this
.
getSheet
(
domSheet
this
.
#
sheetIndex
+
+
)
;
if
(
cssSheet
.
passId
!
=
this
.
passId
)
{
cssSheet
.
passId
=
this
.
passId
;
const
traverseRules
=
ruleList
=
>
{
for
(
const
aDomRule
of
ruleList
)
{
const
ruleClassName
=
ChromeUtils
.
getClassName
(
aDomRule
)
;
if
(
ruleClassName
=
=
=
"
CSSImportRule
"
&
&
aDomRule
.
styleSheet
&
&
this
.
mediaMatches
(
aDomRule
)
)
{
this
.
#
cacheSheet
(
aDomRule
.
styleSheet
)
;
}
else
if
(
ruleClassName
=
=
=
"
CSSKeyframesRule
"
)
{
this
.
#
keyframesRules
.
push
(
aDomRule
)
;
}
if
(
aDomRule
.
cssRules
)
{
traverseRules
(
aDomRule
.
cssRules
)
;
}
}
}
;
traverseRules
(
cssSheet
.
getCssRules
(
)
)
;
}
}
get
sheets
(
)
{
if
(
!
this
.
#
sheetsCached
)
{
this
.
#
cacheSheets
(
)
;
}
const
sheets
=
[
]
;
this
.
forEachSheet
(
function
(
sheet
)
{
if
(
sheet
.
authorSheet
)
{
sheets
.
push
(
sheet
)
;
}
}
this
)
;
return
sheets
;
}
get
keyframesRules
(
)
{
if
(
!
this
.
#
sheetsCached
)
{
this
.
#
cacheSheets
(
)
;
}
return
this
.
#
keyframesRules
;
}
getSheet
(
domSheet
index
)
{
let
cacheId
=
"
"
;
if
(
domSheet
.
href
)
{
cacheId
=
domSheet
.
href
;
}
else
if
(
domSheet
.
associatedDocument
)
{
cacheId
=
domSheet
.
associatedDocument
.
location
;
}
let
sheet
=
null
;
let
sheetFound
=
false
;
if
(
cacheId
in
this
.
#
sheets
)
{
for
(
sheet
of
this
.
#
sheets
[
cacheId
]
)
{
if
(
sheet
.
domSheet
=
=
=
domSheet
)
{
if
(
index
!
=
-
1
)
{
sheet
.
index
=
index
;
}
sheetFound
=
true
;
break
;
}
}
}
if
(
!
sheetFound
)
{
if
(
!
(
cacheId
in
this
.
#
sheets
)
)
{
this
.
#
sheets
[
cacheId
]
=
[
]
;
}
sheet
=
new
CssSheet
(
this
domSheet
index
)
;
if
(
sheet
.
sheetAllowed
&
&
sheet
.
authorSheet
)
{
this
.
#
ruleCount
+
=
sheet
.
ruleCount
;
}
this
.
#
sheets
[
cacheId
]
.
push
(
sheet
)
;
}
return
sheet
;
}
forEachSheet
(
callback
scope
)
{
for
(
const
cacheId
in
this
.
#
sheets
)
{
const
sheets
=
this
.
#
sheets
[
cacheId
]
;
for
(
let
i
=
0
;
i
<
sheets
.
length
;
i
+
+
)
{
try
{
const
sheet
=
sheets
[
i
]
;
sheet
.
domSheet
;
callback
.
call
(
scope
sheet
i
sheets
)
;
}
catch
(
e
)
{
sheets
.
splice
(
i
1
)
;
i
-
-
;
}
}
}
}
get
ruleCount
(
)
{
if
(
!
this
.
#
sheetsCached
)
{
this
.
#
cacheSheets
(
)
;
}
return
this
.
#
ruleCount
;
}
processMatchedSelectors
(
callback
scope
)
{
if
(
this
.
#
matchedSelectors
)
{
if
(
callback
)
{
this
.
passId
+
+
;
this
.
#
matchedSelectors
.
forEach
(
function
(
value
)
{
callback
.
call
(
scope
value
[
0
]
value
[
1
]
)
;
value
[
0
]
.
cssRule
.
passId
=
this
.
passId
;
}
this
)
;
}
return
;
}
if
(
!
this
.
#
matchedRules
)
{
this
.
#
buildMatchedRules
(
)
;
}
this
.
#
matchedSelectors
=
[
]
;
this
.
passId
+
+
;
for
(
const
matchedRule
of
this
.
#
matchedRules
)
{
const
[
rule
status
distance
]
=
matchedRule
;
rule
.
selectors
.
forEach
(
function
(
selector
)
{
if
(
selector
.
matchId
!
=
=
this
.
matchId
&
&
(
rule
.
domRule
.
declarationOrigin
=
=
=
"
style
-
attribute
"
|
|
rule
.
domRule
.
declarationOrigin
=
=
=
"
pres
-
hints
"
|
|
this
.
selectorMatchesElement
(
rule
.
domRule
selector
.
selectorIndex
)
)
)
{
selector
.
matchId
=
this
.
matchId
;
this
.
#
matchedSelectors
.
push
(
[
selector
status
distance
]
)
;
if
(
callback
)
{
callback
.
call
(
scope
selector
status
distance
)
;
}
}
}
this
)
;
rule
.
passId
=
this
.
passId
;
}
}
selectorMatchesElement
(
domRule
idx
)
{
let
element
=
this
.
viewedElement
;
do
{
const
{
bindingElement
pseudo
}
=
CssLogic
.
getBindingElementAndPseudo
(
element
)
;
if
(
domRule
.
selectorMatchesElement
(
idx
bindingElement
pseudo
)
)
{
return
true
;
}
for
(
const
pseudoElement
of
ELEMENT_BACKED_PSEUDO_ELEMENTS
)
{
if
(
domRule
.
selectorMatchesElement
(
idx
element
pseudoElement
)
)
{
return
true
;
}
}
}
while
(
(
element
=
element
.
flattenedTreeParentNode
)
&
&
element
.
nodeType
=
=
=
nodeConstants
.
ELEMENT_NODE
)
;
return
false
;
}
hasMatchedSelectors
(
properties
)
{
if
(
!
this
.
#
matchedRules
)
{
this
.
#
buildMatchedRules
(
)
;
}
const
result
=
new
Set
(
)
;
for
(
const
[
rule
status
]
of
this
.
#
matchedRules
)
{
let
cssText
;
const
getCssText
=
(
)
=
>
{
if
(
cssText
=
=
=
undefined
)
{
cssText
=
rule
.
domRule
.
cssText
;
}
return
cssText
;
}
;
for
(
let
i
=
properties
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
property
=
properties
[
i
]
;
if
(
(
rule
.
getPropertyValue
(
property
)
|
|
(
property
.
startsWith
(
"
-
-
"
)
&
&
new
RegExp
(
{
property
}
[
^
A
-
Za
-
z0
-
9_
-
]
)
.
test
(
getCssText
(
)
)
)
)
&
&
(
status
=
=
STATUS
.
MATCHED
|
|
(
status
=
=
STATUS
.
PARENT_MATCH
&
&
InspectorUtils
.
isInheritedProperty
(
this
.
viewedDocument
property
)
)
)
)
{
result
.
add
(
property
)
;
properties
.
splice
(
i
1
)
;
}
}
if
(
!
properties
.
length
)
{
return
result
;
}
}
return
result
;
}
#
buildMatchedRules
(
)
{
let
domRules
;
let
element
=
this
.
viewedElement
;
const
filter
=
this
.
sourceFilter
;
let
sheetIndex
=
0
;
let
distance
=
0
;
this
.
matchId
+
+
;
this
.
passId
+
+
;
this
.
#
matchedRules
=
[
]
;
if
(
!
element
)
{
return
;
}
do
{
const
status
=
this
.
viewedElement
=
=
=
element
?
STATUS
.
MATCHED
:
STATUS
.
PARENT_MATCH
;
try
{
domRules
=
getMatchingCSSRules
(
element
)
;
}
catch
(
ex
)
{
console
.
log
(
"
CL__buildMatchedRules
error
:
"
+
ex
)
;
continue
;
}
if
(
domRules
!
=
=
null
)
{
for
(
let
i
=
domRules
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
domRule
=
domRules
[
i
]
;
if
(
domRule
.
declarationOrigin
)
{
if
(
domRule
.
declarationOrigin
!
=
=
"
style
-
attribute
"
&
&
domRule
.
declarationOrigin
!
=
=
"
pres
-
hints
"
)
{
continue
;
}
const
rule
=
new
CssRule
(
null
{
style
:
domRule
.
style
declarationOrigin
:
domRule
.
declarationOrigin
}
element
)
;
rule
.
matchId
=
this
.
matchId
;
rule
.
passId
=
this
.
passId
;
this
.
#
matchedRules
.
push
(
[
rule
status
distance
]
)
;
continue
;
}
const
sheet
=
this
.
getSheet
(
domRule
.
parentStyleSheet
-
1
)
;
if
(
sheet
.
passId
!
=
=
this
.
passId
)
{
sheet
.
index
=
sheetIndex
+
+
;
sheet
.
passId
=
this
.
passId
;
}
if
(
filter
=
=
=
FILTER
.
USER
&
&
!
sheet
.
authorSheet
)
{
continue
;
}
const
rule
=
sheet
.
getRule
(
domRule
)
;
if
(
rule
.
passId
=
=
=
this
.
passId
)
{
continue
;
}
rule
.
matchId
=
this
.
matchId
;
rule
.
passId
=
this
.
passId
;
this
.
#
matchedRules
.
push
(
[
rule
status
distance
]
)
;
}
}
distance
-
-
;
}
while
(
(
element
=
element
.
flattenedTreeParentNode
)
&
&
element
.
nodeType
=
=
=
nodeConstants
.
ELEMENT_NODE
)
;
}
mediaMatches
(
domObject
)
{
const
mediaText
=
domObject
.
media
.
mediaText
;
return
(
!
mediaText
|
|
this
.
viewedDocument
.
defaultView
.
matchMedia
(
mediaText
)
.
matches
)
;
}
}
class
CssSheet
{
constructor
(
cssLogic
domSheet
index
)
{
this
.
#
cssLogic
=
cssLogic
;
this
.
domSheet
=
domSheet
;
this
.
index
=
this
.
authorSheet
?
index
:
-
100
*
index
;
}
#
cssLogic
;
#
href
=
null
;
#
shortSource
=
null
;
#
rules
=
{
}
;
#
sheetAllowed
=
null
;
#
ruleCount
=
-
1
;
passId
=
null
;
#
agentSheet
=
null
;
#
authorSheet
=
null
;
#
userSheet
=
null
;
get
agentSheet
(
)
{
if
(
this
.
#
agentSheet
=
=
=
null
)
{
this
.
#
agentSheet
=
isAgentStylesheet
(
this
.
domSheet
)
;
}
return
this
.
#
agentSheet
;
}
get
authorSheet
(
)
{
if
(
this
.
#
authorSheet
=
=
=
null
)
{
this
.
#
authorSheet
=
isAuthorStylesheet
(
this
.
domSheet
)
;
}
return
this
.
#
authorSheet
;
}
get
userSheet
(
)
{
if
(
this
.
#
userSheet
=
=
=
null
)
{
this
.
#
userSheet
=
isUserStylesheet
(
this
.
domSheet
)
;
}
return
this
.
#
userSheet
;
}
get
disabled
(
)
{
return
this
.
domSheet
.
disabled
;
}
get
href
(
)
{
if
(
this
.
#
href
)
{
return
this
.
#
href
;
}
this
.
#
href
=
CssLogic
.
href
(
this
.
domSheet
)
;
return
this
.
#
href
;
}
get
shortSource
(
)
{
if
(
this
.
#
shortSource
)
{
return
this
.
#
shortSource
;
}
this
.
#
shortSource
=
shortSource
(
this
.
domSheet
)
;
return
this
.
#
shortSource
;
}
get
sheetAllowed
(
)
{
if
(
this
.
#
sheetAllowed
!
=
=
null
)
{
return
this
.
#
sheetAllowed
;
}
this
.
#
sheetAllowed
=
true
;
const
filter
=
this
.
#
cssLogic
.
sourceFilter
;
if
(
filter
=
=
=
FILTER
.
USER
&
&
!
this
.
authorSheet
)
{
this
.
#
sheetAllowed
=
false
;
}
if
(
filter
!
=
=
FILTER
.
USER
&
&
filter
!
=
=
FILTER
.
UA
)
{
this
.
#
sheetAllowed
=
filter
=
=
=
this
.
href
;
}
return
this
.
#
sheetAllowed
;
}
get
ruleCount
(
)
{
try
{
return
this
.
#
ruleCount
>
-
1
?
this
.
#
ruleCount
:
this
.
getCssRules
(
)
.
length
;
}
catch
(
e
)
{
return
0
;
}
}
getCssRules
(
)
{
try
{
return
this
.
domSheet
.
cssRules
;
}
catch
(
e
)
{
return
[
]
;
}
}
getRule
(
domRule
)
{
const
cacheId
=
domRule
.
type
+
domRule
.
selectorText
;
let
rule
=
null
;
let
ruleFound
=
false
;
if
(
cacheId
in
this
.
#
rules
)
{
for
(
rule
of
this
.
#
rules
[
cacheId
]
)
{
if
(
rule
.
domRule
=
=
=
domRule
)
{
ruleFound
=
true
;
break
;
}
}
}
if
(
!
ruleFound
)
{
if
(
!
(
cacheId
in
this
.
#
rules
)
)
{
this
.
#
rules
[
cacheId
]
=
[
]
;
}
rule
=
new
CssRule
(
this
domRule
)
;
this
.
#
rules
[
cacheId
]
.
push
(
rule
)
;
}
return
rule
;
}
toString
(
)
{
return
"
CssSheet
[
"
+
this
.
shortSource
+
"
]
"
;
}
}
class
CssRule
{
/
*
*
*
Information
about
a
single
CSSStyleRule
.
*
*
param
{
CSSStyleSheet
|
null
}
cssSheet
the
CssSheet
object
of
the
stylesheet
that
*
holds
the
CSSStyleRule
.
If
the
rule
comes
from
element
.
style
set
this
*
argument
to
null
.
*
param
{
CSSStyleRule
|
InspectorDeclaration
}
domRule
the
DOM
CSSStyleRule
for
which
you
want
*
to
cache
data
.
If
the
rule
comes
from
element
.
style
or
presentational
attributes
it
*
will
be
an
InspectorDeclaration
(
object
of
the
form
{
style
:
element
.
style
declarationOrigin
:
string
}
)
.
*
param
{
Element
}
[
element
]
If
the
rule
comes
from
element
.
style
then
this
*
argument
must
point
to
the
element
.
*
constructor
*
/
constructor
(
cssSheet
domRule
element
)
{
this
.
#
cssSheet
=
cssSheet
;
this
.
domRule
=
domRule
;
if
(
this
.
#
cssSheet
)
{
/
/
parse
domRule
.
selectorText
on
call
to
this
.
selectors
this
.
#
selectors
=
null
;
this
.
line
=
InspectorUtils
.
getRelativeRuleLine
(
this
.
domRule
)
;
this
.
column
=
InspectorUtils
.
getRuleColumn
(
this
.
domRule
)
;
this
.
href
=
this
.
#
cssSheet
.
href
;
this
.
authorRule
=
this
.
#
cssSheet
.
authorSheet
;
this
.
userRule
=
this
.
#
cssSheet
.
userSheet
;
this
.
agentRule
=
this
.
#
cssSheet
.
agentSheet
;
}
else
if
(
element
)
{
let
selector
=
"
"
;
if
(
domRule
.
declarationOrigin
=
=
=
"
style
-
attribute
"
)
{
selector
=
"
element
.
style
"
;
}
else
if
(
domRule
.
declarationOrigin
=
=
=
"
pres
-
hints
"
)
{
selector
=
"
element
.
attributesStyle
"
;
}
this
.
#
selectors
=
[
new
CssSelector
(
this
selector
0
)
]
;
this
.
line
=
-
1
;
this
.
href
=
"
#
"
;
this
.
authorRule
=
true
;
this
.
userRule
=
false
;
this
.
agentRule
=
false
;
this
.
sourceElement
=
element
;
}
}
passId
=
null
;
#
cssSheet
;
#
selectors
;
get
sheetAllowed
(
)
{
return
this
.
#
cssSheet
?
this
.
#
cssSheet
.
sheetAllowed
:
true
;
}
get
sheetIndex
(
)
{
return
this
.
#
cssSheet
?
this
.
#
cssSheet
.
index
:
0
;
}
getStyle
(
)
{
return
this
.
domRule
.
declarationOrigin
=
=
=
"
style
-
attribute
"
?
this
.
sourceElement
.
style
:
this
.
domRule
.
style
;
}
getPropertyValue
(
property
)
{
return
this
.
getStyle
(
)
.
getPropertyValue
(
property
)
;
}
getPropertyPriority
(
property
)
{
return
this
.
getStyle
(
)
.
getPropertyPriority
(
property
)
;
}
get
selectors
(
)
{
if
(
this
.
#
selectors
)
{
return
this
.
#
selectors
;
}
this
.
#
selectors
=
[
]
;
if
(
!
this
.
domRule
.
selectorText
)
{
return
this
.
#
selectors
;
}
const
selectors
=
CssLogic
.
getSelectors
(
this
.
domRule
)
;
for
(
let
i
=
0
len
=
selectors
.
length
;
i
<
len
;
i
+
+
)
{
this
.
#
selectors
.
push
(
new
CssSelector
(
this
selectors
[
i
]
i
)
)
;
}
return
this
.
#
selectors
;
}
toString
(
)
{
return
"
[
CssRule
"
+
this
.
domRule
.
selectorText
+
"
]
"
;
}
}
class
CssSelector
{
constructor
(
cssRule
selector
index
)
{
this
.
cssRule
=
cssRule
;
this
.
text
=
selector
;
this
.
inlineStyle
=
cssRule
.
domRule
?
.
declarationOrigin
=
=
=
"
style
-
attribute
"
;
this
.
selectorIndex
=
index
;
}
matchId
=
null
;
#
specificity
=
null
;
get
sourceElement
(
)
{
return
this
.
cssRule
.
sourceElement
;
}
get
href
(
)
{
return
this
.
cssRule
.
href
;
}
get
agentRule
(
)
{
return
this
.
cssRule
.
agentRule
;
}
get
authorRule
(
)
{
return
this
.
cssRule
.
authorRule
;
}
get
userRule
(
)
{
return
this
.
cssRule
.
userRule
;
}
get
sheetAllowed
(
)
{
return
this
.
cssRule
.
sheetAllowed
;
}
get
sheetIndex
(
)
{
return
this
.
cssRule
.
sheetIndex
;
}
get
ruleLine
(
)
{
return
this
.
cssRule
.
line
;
}
get
ruleColumn
(
)
{
return
this
.
cssRule
.
column
;
}
get
specificity
(
)
{
if
(
this
.
inlineStyle
)
{
return
0x40000000
;
}
if
(
this
.
cssRule
.
declarationOrigin
=
=
=
"
pres
-
hints
"
)
{
return
0
;
}
if
(
typeof
this
.
#
specificity
!
=
=
"
number
"
)
{
this
.
#
specificity
=
this
.
cssRule
.
domRule
.
selectorSpecificityAt
(
this
.
selectorIndex
)
;
}
return
this
.
#
specificity
;
}
toString
(
)
{
return
this
.
text
;
}
}
class
CssPropertyInfo
{
constructor
(
cssLogic
property
)
{
this
.
#
cssLogic
=
cssLogic
;
this
.
property
=
property
;
}
#
matchedSelectors
=
null
;
#
cssLogic
;
#
value
=
"
"
;
get
value
(
)
{
if
(
!
this
.
#
value
&
&
this
.
#
cssLogic
.
computedStyle
)
{
try
{
this
.
#
value
=
this
.
#
cssLogic
.
computedStyle
.
getPropertyValue
(
this
.
property
)
;
}
catch
(
ex
)
{
console
.
log
(
"
Error
reading
computed
style
for
"
+
this
.
property
)
;
console
.
log
(
ex
)
;
}
}
return
this
.
#
value
;
}
get
matchedSelectors
(
)
{
if
(
!
this
.
#
matchedSelectors
)
{
this
.
#
findMatchedSelectors
(
)
;
}
else
if
(
this
.
needRefilter
)
{
this
.
#
refilterSelectors
(
)
;
}
return
this
.
#
matchedSelectors
;
}
#
findMatchedSelectors
(
)
{
this
.
#
matchedSelectors
=
[
]
;
this
.
needRefilter
=
false
;
this
.
#
cssLogic
.
processMatchedSelectors
(
this
.
#
processMatchedSelector
this
)
;
this
.
#
matchedSelectors
.
sort
(
(
selectorInfo1
selectorInfo2
)
=
>
selectorInfo1
.
compareTo
(
selectorInfo2
this
.
#
matchedSelectors
)
)
;
if
(
this
.
#
matchedSelectors
.
length
&
&
this
.
#
matchedSelectors
[
0
]
.
status
>
STATUS
.
UNMATCHED
)
{
this
.
#
matchedSelectors
[
0
]
.
status
=
STATUS
.
BEST
;
}
}
#
processMatchedSelector
(
selector
status
distance
)
{
const
cssRule
=
selector
.
cssRule
;
const
value
=
cssRule
.
getPropertyValue
(
this
.
property
)
;
if
(
value
&
&
(
status
=
=
STATUS
.
MATCHED
|
|
(
status
=
=
STATUS
.
PARENT_MATCH
&
&
InspectorUtils
.
isInheritedProperty
(
this
.
#
cssLogic
.
viewedDocument
this
.
property
)
)
)
)
{
const
selectorInfo
=
new
CssSelectorInfo
(
selector
this
.
property
value
status
distance
)
;
this
.
#
matchedSelectors
.
push
(
selectorInfo
)
;
}
}
#
refilterSelectors
(
)
{
const
passId
=
+
+
this
.
#
cssLogic
.
passId
;
const
iterator
=
function
(
selectorInfo
)
{
const
cssRule
=
selectorInfo
.
selector
.
cssRule
;
if
(
cssRule
.
passId
!
=
passId
)
{
cssRule
.
passId
=
passId
;
}
}
;
if
(
this
.
#
matchedSelectors
)
{
this
.
#
matchedSelectors
.
forEach
(
iterator
)
;
}
this
.
needRefilter
=
false
;
}
toString
(
)
{
return
"
CssPropertyInfo
[
"
+
this
.
property
+
"
]
"
;
}
}
class
CssSelectorInfo
{
/
*
*
*
A
class
that
holds
information
about
a
given
CssSelector
object
.
*
*
Instances
of
this
class
are
given
to
CssHtmlTree
in
the
array
of
matched
*
selectors
.
Each
such
object
represents
a
displayable
row
in
the
PropertyView
*
objects
.
The
information
given
by
this
object
blends
data
coming
from
the
*
CssSheet
CssRule
and
from
the
CssSelector
that
own
this
object
.
*
*
param
{
CssSelector
}
selector
The
CssSelector
object
for
which
to
*
present
information
.
*
param
{
string
}
property
The
property
for
which
information
should
*
be
retrieved
.
*
param
{
string
}
value
The
property
value
from
the
CssRule
that
owns
*
the
selector
.
*
param
{
STATUS
}
status
The
selector
match
status
.
*
param
{
number
}
distance
See
CssLogic
.
#
buildMatchedRules
for
definition
.
*
constructor
*
/
constructor
(
selector
property
value
status
distance
)
{
this
.
selector
=
selector
;
this
.
property
=
property
;
this
.
status
=
status
;
this
.
distance
=
distance
;
this
.
value
=
value
;
const
priority
=
this
.
selector
.
cssRule
.
getPropertyPriority
(
this
.
property
)
;
this
.
important
=
priority
=
=
=
"
important
"
;
/
/
Array
<
string
|
CSSLayerBlockRule
>
this
.
parentLayers
=
[
]
;
/
/
Go
through
all
parent
rules
to
populate
this
.
parentLayers
let
rule
=
selector
.
cssRule
.
domRule
;
while
(
rule
)
{
const
className
=
ChromeUtils
.
getClassName
(
rule
)
;
if
(
className
=
=
"
CSSLayerBlockRule
"
)
{
/
/
If
the
layer
has
a
name
it
'
s
enough
to
uniquely
identify
it
/
/
If
the
layer
does
not
have
a
name
.
We
put
the
actual
rule
here
so
we
'
ll
/
/
be
able
to
compare
actual
rule
instances
in
compareTo
this
.
parentLayers
.
push
(
rule
.
name
|
|
rule
)
;
}
else
if
(
className
=
=
"
CSSImportRule
"
&
&
rule
.
layerName
!
=
=
null
)
{
/
/
Same
reasoning
for
import
rule
+
layer
this
.
parentLayers
.
push
(
rule
.
layerName
|
|
rule
)
;
}
/
/
Get
the
parent
rule
(
could
be
the
parent
stylesheet
owner
rule
/
/
for
import
url
(
path
/
to
/
file
.
css
)
layer
)
rule
=
rule
.
parentRule
|
|
rule
.
parentStyleSheet
?
.
ownerRule
;
}
}
/
*
*
*
Retrieve
the
CssSelector
source
element
which
is
the
source
of
the
CssRule
*
owning
the
selector
.
This
is
only
available
when
the
CssSelector
comes
from
*
an
element
.
style
.
*
*
return
{
string
}
the
source
element
selector
.
*
/
get
sourceElement
(
)
{
return
this
.
selector
.
sourceElement
;
}
/
*
*
*
Retrieve
the
address
of
the
CssSelector
.
This
points
to
the
address
of
the
*
CssSheet
owning
this
selector
.
*
*
return
{
string
}
the
address
of
the
CssSelector
.
*
/
get
href
(
)
{
return
this
.
selector
.
href
;
}
/
*
*
*
Check
if
the
CssSelector
comes
from
element
.
style
or
not
.
*
*
return
{
boolean
}
true
if
the
CssSelector
comes
from
element
.
style
or
*
false
otherwise
.
*
/
get
inlineStyle
(
)
{
return
this
.
selector
.
inlineStyle
;
}
/
*
*
*
Retrieve
specificity
information
for
the
current
selector
.
*
*
return
{
object
}
an
object
holding
specificity
information
for
the
current
*
selector
.
*
/
get
specificity
(
)
{
return
this
.
selector
.
specificity
;
}
/
*
*
*
Retrieve
the
parent
stylesheet
index
/
position
in
the
viewed
document
.
*
*
return
{
number
}
the
parent
stylesheet
index
/
position
in
the
viewed
*
document
.
*
/
get
sheetIndex
(
)
{
return
this
.
selector
.
sheetIndex
;
}
/
*
*
*
Check
if
the
parent
stylesheet
is
allowed
by
the
CssLogic
.
sourceFilter
.
*
*
return
{
boolean
}
true
if
the
parent
stylesheet
is
allowed
by
the
current
*
sourceFilter
or
false
otherwise
.
*
/
get
sheetAllowed
(
)
{
return
this
.
selector
.
sheetAllowed
;
}
/
*
*
*
Retrieve
the
line
of
the
parent
CSSStyleRule
in
the
parent
CSSStyleSheet
.
*
*
return
{
number
}
the
line
of
the
parent
CSSStyleRule
in
the
parent
*
stylesheet
.
*
/
get
ruleLine
(
)
{
return
this
.
selector
.
ruleLine
;
}
/
*
*
*
Retrieve
the
column
of
the
parent
CSSStyleRule
in
the
parent
CSSStyleSheet
.
*
*
return
{
number
}
the
column
of
the
parent
CSSStyleRule
in
the
parent
*
stylesheet
.
*
/
get
ruleColumn
(
)
{
return
this
.
selector
.
ruleColumn
;
}
/
*
*
*
Check
if
the
selector
comes
from
a
browser
-
provided
stylesheet
.
*
*
return
{
boolean
}
true
if
the
selector
comes
from
a
browser
-
provided
*
stylesheet
or
false
otherwise
.
*
/
get
agentRule
(
)
{
return
this
.
selector
.
agentRule
;
}
/
*
*
*
Check
if
the
selector
comes
from
a
webpage
-
provided
stylesheet
.
*
*
return
{
boolean
}
true
if
the
selector
comes
from
a
webpage
-
provided
*
stylesheet
or
false
otherwise
.
*
/
get
authorRule
(
)
{
return
this
.
selector
.
authorRule
;
}
/
*
*
*
Check
if
the
selector
comes
from
a
user
stylesheet
(
userChrome
.
css
or
*
userContent
.
css
)
.
*
*
return
{
boolean
}
true
if
the
selector
comes
from
a
webpage
-
provided
*
stylesheet
or
false
otherwise
.
*
/
get
userRule
(
)
{
return
this
.
selector
.
userRule
;
}
/
*
*
*
Compare
the
current
CssSelectorInfo
instance
to
another
instance
.
*
Since
selectorInfos
is
computed
from
InspectorUtils
.
getMatchingCSSRules
*
it
'
s
already
sorted
for
regular
cases
.
We
only
need
to
handle
important
values
.
*
*
param
{
CssSelectorInfo
}
that
*
The
instance
to
compare
ourselves
against
.
*
param
{
Array
<
CssSelectorInfo
>
}
selectorInfos
*
The
list
of
CssSelectorInfo
we
are
currently
ordering
*
return
{
number
}
*
-
1
0
1
depending
on
how
that
compares
with
this
.
*
/
compareTo
(
that
selectorInfos
)
{
const
originalOrder
=
selectorInfos
.
indexOf
(
this
)
<
selectorInfos
.
indexOf
(
that
)
?
-
1
:
1
;
/
/
If
both
properties
are
not
important
we
can
keep
the
original
order
if
(
!
this
.
important
&
&
!
that
.
important
)
{
return
originalOrder
;
}
/
/
If
one
of
the
property
is
important
and
the
other
is
not
the
important
one
wins
if
(
this
.
important
!
=
=
that
.
important
)
{
return
this
.
important
?
-
1
:
1
;
}
/
/
At
this
point
this
and
that
are
both
important
const
thisIsInLayer
=
!
!
this
.
parentLayers
.
length
;
const
thatIsInLayer
=
!
!
that
.
parentLayers
.
length
;
/
/
If
they
'
re
not
in
layers
we
can
keep
the
original
rule
order
if
(
!
thisIsInLayer
&
&
!
thatIsInLayer
)
{
return
originalOrder
;
}
/
/
If
one
of
the
rule
is
the
style
attribute
it
wins
if
(
this
.
selector
.
inlineStyle
|
|
that
.
selector
.
inlineStyle
)
{
return
this
.
selector
.
inlineStyle
?
-
1
:
1
;
}
/
/
If
one
of
the
rule
is
not
in
a
layer
then
the
rule
in
a
layer
wins
.
if
(
!
thisIsInLayer
|
|
!
thatIsInLayer
)
{
return
thisIsInLayer
?
-
1
:
1
;
}
const
inSameLayers
=
this
.
parentLayers
.
length
=
=
=
that
.
parentLayers
.
length
&
&
this
.
parentLayers
.
every
(
(
layer
i
)
=
>
layer
=
=
=
that
.
parentLayers
[
i
]
)
;
/
/
If
both
rules
are
in
the
same
layer
we
keep
the
original
order
if
(
inSameLayers
)
{
return
originalOrder
;
}
/
/
When
comparing
declarations
that
belong
to
different
layers
then
for
/
/
important
rules
the
declaration
whose
cascade
layer
is
first
wins
.
/
/
We
get
the
rules
in
the
most
-
specific
to
least
-
specific
order
meaning
we
'
ll
have
/
/
rules
in
layers
in
the
reverse
order
of
the
order
of
declarations
of
layers
.
/
/
We
can
reverse
that
again
to
get
the
order
of
declarations
of
layers
.
return
originalOrder
*
-
1
;
}
compare
(
that
propertyName
type
)
{
switch
(
type
)
{
case
COMPAREMODE
.
BOOLEAN
:
if
(
this
[
propertyName
]
&
&
!
that
[
propertyName
]
)
{
return
-
1
;
}
if
(
!
this
[
propertyName
]
&
&
that
[
propertyName
]
)
{
return
1
;
}
break
;
case
COMPAREMODE
.
INTEGER
:
if
(
this
[
propertyName
]
>
that
[
propertyName
]
)
{
return
-
1
;
}
if
(
this
[
propertyName
]
<
that
[
propertyName
]
)
{
return
1
;
}
break
;
}
return
0
;
}
toString
(
)
{
return
this
.
selector
+
"
-
>
"
+
this
.
value
;
}
}
exports
.
CssLogic
=
CssLogic
;
exports
.
CssSelector
=
CssSelector
;
