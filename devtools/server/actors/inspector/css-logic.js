"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
nodeConstants
=
require
(
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
const
{
getBindingElementAndPseudo
getCSSStyleRules
l10n
hasVisitedState
isAgentStylesheet
isAuthorStylesheet
isUserStylesheet
shortSource
FILTER
STATUS
}
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
InspectorUtils
=
require
(
"
InspectorUtils
"
)
;
const
COMPAREMODE
=
{
BOOLEAN
:
"
bool
"
INTEGER
:
"
int
"
}
;
function
CssLogic
(
)
{
this
.
_propertyInfos
=
{
}
;
}
exports
.
CssLogic
=
CssLogic
;
CssLogic
.
prototype
=
{
viewedElement
:
null
viewedDocument
:
null
_sheets
:
null
_sheetsCached
:
false
_ruleCount
:
0
_computedStyle
:
null
_sourceFilter
:
FILTER
.
USER
_passId
:
0
_matchId
:
0
_matchedRules
:
null
_matchedSelectors
:
null
_keyframesRules
:
null
reset
:
function
(
)
{
this
.
_propertyInfos
=
{
}
;
this
.
_ruleCount
=
0
;
this
.
_sheetIndex
=
0
;
this
.
_sheets
=
{
}
;
this
.
_sheetsCached
=
false
;
this
.
_matchedRules
=
null
;
this
.
_matchedSelectors
=
null
;
this
.
_keyframesRules
=
[
]
;
}
highlight
:
function
(
viewedElement
)
{
if
(
!
viewedElement
)
{
this
.
viewedElement
=
null
;
this
.
viewedDocument
=
null
;
this
.
_computedStyle
=
null
;
this
.
reset
(
)
;
return
;
}
if
(
viewedElement
=
=
=
this
.
viewedElement
)
{
return
;
}
this
.
viewedElement
=
viewedElement
;
const
doc
=
this
.
viewedElement
.
ownerDocument
;
if
(
doc
!
=
this
.
viewedDocument
)
{
this
.
viewedDocument
=
doc
;
this
.
_cacheSheets
(
)
;
}
else
{
this
.
_propertyInfos
=
{
}
;
}
this
.
_matchedRules
=
null
;
this
.
_matchedSelectors
=
null
;
this
.
_computedStyle
=
CssLogic
.
getComputedStyle
(
this
.
viewedElement
)
;
}
get
computedStyle
(
)
{
return
this
.
_computedStyle
;
}
get
sourceFilter
(
)
{
return
this
.
_sourceFilter
;
}
set
sourceFilter
(
value
)
{
const
oldValue
=
this
.
_sourceFilter
;
this
.
_sourceFilter
=
value
;
let
ruleCount
=
0
;
this
.
forEachSheet
(
function
(
sheet
)
{
if
(
sheet
.
authorSheet
&
&
sheet
.
sheetAllowed
)
{
ruleCount
+
=
sheet
.
ruleCount
;
}
}
this
)
;
this
.
_ruleCount
=
ruleCount
;
const
needFullUpdate
=
oldValue
=
=
FILTER
.
UA
|
|
value
=
=
FILTER
.
UA
;
if
(
needFullUpdate
)
{
this
.
_matchedRules
=
null
;
this
.
_matchedSelectors
=
null
;
this
.
_propertyInfos
=
{
}
;
}
else
{
for
(
const
property
in
this
.
_propertyInfos
)
{
this
.
_propertyInfos
[
property
]
.
needRefilter
=
true
;
}
}
}
getPropertyInfo
:
function
(
property
)
{
if
(
!
this
.
viewedElement
)
{
return
{
}
;
}
let
info
=
this
.
_propertyInfos
[
property
]
;
if
(
!
info
)
{
info
=
new
CssPropertyInfo
(
this
property
)
;
this
.
_propertyInfos
[
property
]
=
info
;
}
return
info
;
}
_cacheSheets
:
function
(
)
{
this
.
_passId
+
+
;
this
.
reset
(
)
;
const
styleSheets
=
InspectorUtils
.
getAllStyleSheets
(
this
.
viewedDocument
true
)
;
Array
.
prototype
.
forEach
.
call
(
styleSheets
this
.
_cacheSheet
this
)
;
this
.
_sheetsCached
=
true
;
}
_cacheSheet
:
function
(
domSheet
)
{
if
(
domSheet
.
disabled
)
{
return
;
}
if
(
!
this
.
mediaMatches
(
domSheet
)
)
{
return
;
}
const
cssSheet
=
this
.
getSheet
(
domSheet
this
.
_sheetIndex
+
+
)
;
if
(
cssSheet
.
_passId
!
=
this
.
_passId
)
{
cssSheet
.
_passId
=
this
.
_passId
;
for
(
const
aDomRule
of
cssSheet
.
getCssRules
(
)
)
{
if
(
aDomRule
.
type
=
=
CSSRule
.
IMPORT_RULE
&
&
aDomRule
.
styleSheet
&
&
this
.
mediaMatches
(
aDomRule
)
)
{
this
.
_cacheSheet
(
aDomRule
.
styleSheet
)
;
}
else
if
(
aDomRule
.
type
=
=
CSSRule
.
KEYFRAMES_RULE
)
{
this
.
_keyframesRules
.
push
(
aDomRule
)
;
}
}
}
}
get
sheets
(
)
{
if
(
!
this
.
_sheetsCached
)
{
this
.
_cacheSheets
(
)
;
}
const
sheets
=
[
]
;
this
.
forEachSheet
(
function
(
sheet
)
{
if
(
sheet
.
authorSheet
)
{
sheets
.
push
(
sheet
)
;
}
}
this
)
;
return
sheets
;
}
get
keyframesRules
(
)
{
if
(
!
this
.
_sheetsCached
)
{
this
.
_cacheSheets
(
)
;
}
return
this
.
_keyframesRules
;
}
getSheet
:
function
(
domSheet
index
)
{
let
cacheId
=
"
"
;
if
(
domSheet
.
href
)
{
cacheId
=
domSheet
.
href
;
}
else
if
(
domSheet
.
ownerNode
&
&
domSheet
.
ownerNode
.
ownerDocument
)
{
cacheId
=
domSheet
.
ownerNode
.
ownerDocument
.
location
;
}
let
sheet
=
null
;
let
sheetFound
=
false
;
if
(
cacheId
in
this
.
_sheets
)
{
for
(
sheet
of
this
.
_sheets
[
cacheId
]
)
{
if
(
sheet
.
domSheet
=
=
=
domSheet
)
{
if
(
index
!
=
-
1
)
{
sheet
.
index
=
index
;
}
sheetFound
=
true
;
break
;
}
}
}
if
(
!
sheetFound
)
{
if
(
!
(
cacheId
in
this
.
_sheets
)
)
{
this
.
_sheets
[
cacheId
]
=
[
]
;
}
sheet
=
new
CssSheet
(
this
domSheet
index
)
;
if
(
sheet
.
sheetAllowed
&
&
sheet
.
authorSheet
)
{
this
.
_ruleCount
+
=
sheet
.
ruleCount
;
}
this
.
_sheets
[
cacheId
]
.
push
(
sheet
)
;
}
return
sheet
;
}
forEachSheet
:
function
(
callback
scope
)
{
for
(
const
cacheId
in
this
.
_sheets
)
{
const
sheets
=
this
.
_sheets
[
cacheId
]
;
for
(
let
i
=
0
;
i
<
sheets
.
length
;
i
+
+
)
{
try
{
const
sheet
=
sheets
[
i
]
;
sheet
.
domSheet
;
callback
.
call
(
scope
sheet
i
sheets
)
;
}
catch
(
e
)
{
sheets
.
splice
(
i
1
)
;
i
-
-
;
}
}
}
}
get
ruleCount
(
)
{
if
(
!
this
.
_sheetsCached
)
{
this
.
_cacheSheets
(
)
;
}
return
this
.
_ruleCount
;
}
processMatchedSelectors
:
function
(
callback
scope
)
{
if
(
this
.
_matchedSelectors
)
{
if
(
callback
)
{
this
.
_passId
+
+
;
this
.
_matchedSelectors
.
forEach
(
function
(
value
)
{
callback
.
call
(
scope
value
[
0
]
value
[
1
]
)
;
value
[
0
]
.
cssRule
.
_passId
=
this
.
_passId
;
}
this
)
;
}
return
;
}
if
(
!
this
.
_matchedRules
)
{
this
.
_buildMatchedRules
(
)
;
}
this
.
_matchedSelectors
=
[
]
;
this
.
_passId
+
+
;
for
(
const
matchedRule
of
this
.
_matchedRules
)
{
const
[
rule
status
distance
]
=
matchedRule
;
rule
.
selectors
.
forEach
(
function
(
selector
)
{
if
(
selector
.
_matchId
!
=
=
this
.
_matchId
&
&
(
selector
.
inlineStyle
|
|
this
.
selectorMatchesElement
(
rule
.
domRule
selector
.
selectorIndex
)
)
)
{
selector
.
_matchId
=
this
.
_matchId
;
this
.
_matchedSelectors
.
push
(
[
selector
status
distance
]
)
;
if
(
callback
)
{
callback
.
call
(
scope
selector
status
distance
)
;
}
}
}
this
)
;
rule
.
_passId
=
this
.
_passId
;
}
}
selectorMatchesElement
:
function
(
domRule
idx
)
{
let
element
=
this
.
viewedElement
;
do
{
if
(
InspectorUtils
.
selectorMatchesElement
(
element
domRule
idx
)
)
{
return
true
;
}
}
while
(
(
element
=
element
.
parentNode
)
&
&
element
.
nodeType
=
=
=
nodeConstants
.
ELEMENT_NODE
)
;
return
false
;
}
hasMatchedSelectors
:
function
(
properties
)
{
if
(
!
this
.
_matchedRules
)
{
this
.
_buildMatchedRules
(
)
;
}
const
result
=
{
}
;
this
.
_matchedRules
.
some
(
function
(
value
)
{
const
rule
=
value
[
0
]
;
const
status
=
value
[
1
]
;
properties
=
properties
.
filter
(
property
=
>
{
if
(
rule
.
getPropertyValue
(
property
)
&
&
(
status
=
=
STATUS
.
MATCHED
|
|
(
status
=
=
STATUS
.
PARENT_MATCH
&
&
InspectorUtils
.
isInheritedProperty
(
property
)
)
)
)
{
result
[
property
]
=
true
;
return
false
;
}
return
true
;
}
)
;
return
properties
.
length
=
=
0
;
}
this
)
;
return
result
;
}
_buildMatchedRules
:
function
(
)
{
let
domRules
;
let
element
=
this
.
viewedElement
;
const
filter
=
this
.
sourceFilter
;
let
sheetIndex
=
0
;
let
distance
=
0
;
this
.
_matchId
+
+
;
this
.
_passId
+
+
;
this
.
_matchedRules
=
[
]
;
if
(
!
element
)
{
return
;
}
do
{
const
status
=
this
.
viewedElement
=
=
=
element
?
STATUS
.
MATCHED
:
STATUS
.
PARENT_MATCH
;
try
{
domRules
=
getCSSStyleRules
(
element
)
;
}
catch
(
ex
)
{
console
.
log
(
"
CL__buildMatchedRules
error
:
"
+
ex
)
;
continue
;
}
for
(
const
domRule
of
domRules
|
|
[
]
)
{
if
(
domRule
.
type
!
=
=
CSSRule
.
STYLE_RULE
)
{
continue
;
}
const
sheet
=
this
.
getSheet
(
domRule
.
parentStyleSheet
-
1
)
;
if
(
sheet
.
_passId
!
=
=
this
.
_passId
)
{
sheet
.
index
=
sheetIndex
+
+
;
sheet
.
_passId
=
this
.
_passId
;
}
if
(
filter
=
=
=
FILTER
.
USER
&
&
!
sheet
.
authorSheet
)
{
continue
;
}
const
rule
=
sheet
.
getRule
(
domRule
)
;
if
(
rule
.
_passId
=
=
=
this
.
_passId
)
{
continue
;
}
rule
.
_matchId
=
this
.
_matchId
;
rule
.
_passId
=
this
.
_passId
;
this
.
_matchedRules
.
push
(
[
rule
status
distance
]
)
;
}
if
(
element
.
style
&
&
element
.
style
.
length
>
0
)
{
const
rule
=
new
CssRule
(
null
{
style
:
element
.
style
}
element
)
;
rule
.
_matchId
=
this
.
_matchId
;
rule
.
_passId
=
this
.
_passId
;
this
.
_matchedRules
.
push
(
[
rule
status
distance
]
)
;
}
distance
-
-
;
}
while
(
(
element
=
element
.
parentNode
)
&
&
element
.
nodeType
=
=
=
nodeConstants
.
ELEMENT_NODE
)
;
}
mediaMatches
:
function
(
domObject
)
{
const
mediaText
=
domObject
.
media
.
mediaText
;
return
(
!
mediaText
|
|
this
.
viewedDocument
.
defaultView
.
matchMedia
(
mediaText
)
.
matches
)
;
}
}
;
CssLogic
.
getShortName
=
function
(
element
)
{
if
(
!
element
)
{
return
"
null
"
;
}
if
(
element
.
id
)
{
return
"
#
"
+
element
.
id
;
}
let
priorSiblings
=
0
;
let
temp
=
element
;
while
(
(
temp
=
temp
.
previousElementSibling
)
)
{
priorSiblings
+
+
;
}
return
element
.
tagName
+
"
[
"
+
priorSiblings
+
"
]
"
;
}
;
CssLogic
.
getSelectors
=
function
(
domRule
)
{
const
selectors
=
[
]
;
const
len
=
InspectorUtils
.
getSelectorCount
(
domRule
)
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
const
text
=
InspectorUtils
.
getSelectorText
(
domRule
i
)
;
selectors
.
push
(
text
)
;
}
return
selectors
;
}
;
CssLogic
.
getBindingElementAndPseudo
=
getBindingElementAndPseudo
;
CssLogic
.
getComputedStyle
=
function
(
node
)
{
if
(
!
node
|
|
Cu
.
isDeadWrapper
(
node
)
|
|
node
.
nodeType
!
=
=
nodeConstants
.
ELEMENT_NODE
|
|
!
node
.
ownerGlobal
)
{
return
null
;
}
const
{
bindingElement
pseudo
}
=
CssLogic
.
getBindingElementAndPseudo
(
node
)
;
if
(
!
bindingElement
)
{
return
null
;
}
return
node
.
ownerGlobal
.
getComputedStyle
(
bindingElement
pseudo
)
;
}
;
CssLogic
.
href
=
function
(
sheet
)
{
let
href
=
sheet
.
href
;
if
(
!
href
)
{
href
=
sheet
.
ownerNode
.
ownerDocument
.
location
;
}
return
href
;
}
;
CssLogic
.
hasVisitedState
=
hasVisitedState
;
function
CssSheet
(
cssLogic
domSheet
index
)
{
this
.
_cssLogic
=
cssLogic
;
this
.
domSheet
=
domSheet
;
this
.
index
=
this
.
authorSheet
?
index
:
-
100
*
index
;
this
.
_href
=
null
;
this
.
_shortSource
=
null
;
this
.
_sheetAllowed
=
null
;
this
.
_rules
=
{
}
;
this
.
_ruleCount
=
-
1
;
}
CssSheet
.
prototype
=
{
_passId
:
null
_agentSheet
:
null
_authorSheet
:
null
_userSheet
:
null
get
agentSheet
(
)
{
if
(
this
.
_agentSheet
=
=
=
null
)
{
this
.
_agentSheet
=
isAgentStylesheet
(
this
.
domSheet
)
;
}
return
this
.
_agentSheet
;
}
get
authorSheet
(
)
{
if
(
this
.
_authorSheet
=
=
=
null
)
{
this
.
_authorSheet
=
isAuthorStylesheet
(
this
.
domSheet
)
;
}
return
this
.
_authorSheet
;
}
get
userSheet
(
)
{
if
(
this
.
_userSheet
=
=
=
null
)
{
this
.
_userSheet
=
isUserStylesheet
(
this
.
domSheet
)
;
}
return
this
.
_userSheet
;
}
get
disabled
(
)
{
return
this
.
domSheet
.
disabled
;
}
get
href
(
)
{
if
(
this
.
_href
)
{
return
this
.
_href
;
}
this
.
_href
=
CssLogic
.
href
(
this
.
domSheet
)
;
return
this
.
_href
;
}
get
shortSource
(
)
{
if
(
this
.
_shortSource
)
{
return
this
.
_shortSource
;
}
this
.
_shortSource
=
shortSource
(
this
.
domSheet
)
;
return
this
.
_shortSource
;
}
get
sheetAllowed
(
)
{
if
(
this
.
_sheetAllowed
!
=
=
null
)
{
return
this
.
_sheetAllowed
;
}
this
.
_sheetAllowed
=
true
;
const
filter
=
this
.
_cssLogic
.
sourceFilter
;
if
(
filter
=
=
=
FILTER
.
USER
&
&
!
this
.
authorSheet
)
{
this
.
_sheetAllowed
=
false
;
}
if
(
filter
!
=
=
FILTER
.
USER
&
&
filter
!
=
=
FILTER
.
UA
)
{
this
.
_sheetAllowed
=
filter
=
=
=
this
.
href
;
}
return
this
.
_sheetAllowed
;
}
get
ruleCount
(
)
{
try
{
return
this
.
_ruleCount
>
-
1
?
this
.
_ruleCount
:
this
.
getCssRules
(
)
.
length
;
}
catch
(
e
)
{
return
0
;
}
}
getCssRules
:
function
(
)
{
try
{
return
this
.
domSheet
.
cssRules
;
}
catch
(
e
)
{
return
[
]
;
}
}
getRule
:
function
(
domRule
)
{
const
cacheId
=
domRule
.
type
+
domRule
.
selectorText
;
let
rule
=
null
;
let
ruleFound
=
false
;
if
(
cacheId
in
this
.
_rules
)
{
for
(
rule
of
this
.
_rules
[
cacheId
]
)
{
if
(
rule
.
domRule
=
=
=
domRule
)
{
ruleFound
=
true
;
break
;
}
}
}
if
(
!
ruleFound
)
{
if
(
!
(
cacheId
in
this
.
_rules
)
)
{
this
.
_rules
[
cacheId
]
=
[
]
;
}
rule
=
new
CssRule
(
this
domRule
)
;
this
.
_rules
[
cacheId
]
.
push
(
rule
)
;
}
return
rule
;
}
toString
:
function
(
)
{
return
"
CssSheet
[
"
+
this
.
shortSource
+
"
]
"
;
}
}
;
function
CssRule
(
cssSheet
domRule
element
)
{
this
.
_cssSheet
=
cssSheet
;
this
.
domRule
=
domRule
;
const
parentRule
=
domRule
.
parentRule
;
if
(
parentRule
&
&
parentRule
.
type
=
=
CSSRule
.
MEDIA_RULE
)
{
this
.
mediaText
=
parentRule
.
media
.
mediaText
;
}
if
(
this
.
_cssSheet
)
{
this
.
_selectors
=
null
;
this
.
line
=
InspectorUtils
.
getRuleLine
(
this
.
domRule
)
;
this
.
column
=
InspectorUtils
.
getRuleColumn
(
this
.
domRule
)
;
this
.
source
=
this
.
_cssSheet
.
shortSource
+
"
:
"
+
this
.
line
;
if
(
this
.
mediaText
)
{
this
.
source
+
=
"
media
"
+
this
.
mediaText
;
}
this
.
href
=
this
.
_cssSheet
.
href
;
this
.
authorRule
=
this
.
_cssSheet
.
authorSheet
;
this
.
userRule
=
this
.
_cssSheet
.
userSheet
;
this
.
agentRule
=
this
.
_cssSheet
.
agentSheet
;
}
else
if
(
element
)
{
this
.
_selectors
=
[
new
CssSelector
(
this
"
element
.
style
"
0
)
]
;
this
.
line
=
-
1
;
this
.
source
=
l10n
(
"
rule
.
sourceElement
"
)
;
this
.
href
=
"
#
"
;
this
.
authorRule
=
true
;
this
.
userRule
=
false
;
this
.
agentRule
=
false
;
this
.
sourceElement
=
element
;
}
}
CssRule
.
prototype
=
{
_passId
:
null
mediaText
:
"
"
get
isMediaRule
(
)
{
return
!
!
this
.
mediaText
;
}
get
sheetAllowed
(
)
{
return
this
.
_cssSheet
?
this
.
_cssSheet
.
sheetAllowed
:
true
;
}
get
sheetIndex
(
)
{
return
this
.
_cssSheet
?
this
.
_cssSheet
.
index
:
0
;
}
getPropertyValue
:
function
(
property
)
{
return
this
.
domRule
.
style
.
getPropertyValue
(
property
)
;
}
getPropertyPriority
:
function
(
property
)
{
return
this
.
domRule
.
style
.
getPropertyPriority
(
property
)
;
}
get
selectors
(
)
{
if
(
this
.
_selectors
)
{
return
this
.
_selectors
;
}
this
.
_selectors
=
[
]
;
if
(
!
this
.
domRule
.
selectorText
)
{
return
this
.
_selectors
;
}
const
selectors
=
CssLogic
.
getSelectors
(
this
.
domRule
)
;
for
(
let
i
=
0
len
=
selectors
.
length
;
i
<
len
;
i
+
+
)
{
this
.
_selectors
.
push
(
new
CssSelector
(
this
selectors
[
i
]
i
)
)
;
}
return
this
.
_selectors
;
}
toString
:
function
(
)
{
return
"
[
CssRule
"
+
this
.
domRule
.
selectorText
+
"
]
"
;
}
}
;
function
CssSelector
(
cssRule
selector
index
)
{
this
.
cssRule
=
cssRule
;
this
.
text
=
selector
;
this
.
inlineStyle
=
this
.
text
=
=
"
element
.
style
"
;
this
.
_specificity
=
null
;
this
.
selectorIndex
=
index
;
}
exports
.
CssSelector
=
CssSelector
;
CssSelector
.
prototype
=
{
_matchId
:
null
get
source
(
)
{
return
this
.
cssRule
.
source
;
}
get
sourceElement
(
)
{
return
this
.
cssRule
.
sourceElement
;
}
get
href
(
)
{
return
this
.
cssRule
.
href
;
}
get
agentRule
(
)
{
return
this
.
cssRule
.
agentRule
;
}
get
authorRule
(
)
{
return
this
.
cssRule
.
authorRule
;
}
get
userRule
(
)
{
return
this
.
cssRule
.
userRule
;
}
get
sheetAllowed
(
)
{
return
this
.
cssRule
.
sheetAllowed
;
}
get
sheetIndex
(
)
{
return
this
.
cssRule
.
sheetIndex
;
}
get
ruleLine
(
)
{
return
this
.
cssRule
.
line
;
}
get
ruleColumn
(
)
{
return
this
.
cssRule
.
column
;
}
get
specificity
(
)
{
if
(
this
.
inlineStyle
)
{
return
0x40000000
;
}
if
(
typeof
this
.
_specificity
!
=
=
"
number
"
)
{
this
.
_specificity
=
InspectorUtils
.
getSpecificity
(
this
.
cssRule
.
domRule
this
.
selectorIndex
)
;
}
return
this
.
_specificity
;
}
toString
:
function
(
)
{
return
this
.
text
;
}
}
;
function
CssPropertyInfo
(
cssLogic
property
)
{
this
.
_cssLogic
=
cssLogic
;
this
.
property
=
property
;
this
.
_value
=
"
"
;
this
.
_matchedSelectors
=
null
;
}
CssPropertyInfo
.
prototype
=
{
get
value
(
)
{
if
(
!
this
.
_value
&
&
this
.
_cssLogic
.
computedStyle
)
{
try
{
this
.
_value
=
this
.
_cssLogic
.
computedStyle
.
getPropertyValue
(
this
.
property
)
;
}
catch
(
ex
)
{
console
.
log
(
"
Error
reading
computed
style
for
"
+
this
.
property
)
;
console
.
log
(
ex
)
;
}
}
return
this
.
_value
;
}
get
matchedSelectors
(
)
{
if
(
!
this
.
_matchedSelectors
)
{
this
.
_findMatchedSelectors
(
)
;
}
else
if
(
this
.
needRefilter
)
{
this
.
_refilterSelectors
(
)
;
}
return
this
.
_matchedSelectors
;
}
_findMatchedSelectors
:
function
(
)
{
this
.
_matchedSelectors
=
[
]
;
this
.
needRefilter
=
false
;
this
.
_cssLogic
.
processMatchedSelectors
(
this
.
_processMatchedSelector
this
)
;
this
.
_matchedSelectors
.
sort
(
function
(
selectorInfo1
selectorInfo2
)
{
return
selectorInfo1
.
compareTo
(
selectorInfo2
)
;
}
)
;
if
(
this
.
_matchedSelectors
.
length
>
0
&
&
this
.
_matchedSelectors
[
0
]
.
status
>
STATUS
.
UNMATCHED
)
{
this
.
_matchedSelectors
[
0
]
.
status
=
STATUS
.
BEST
;
}
}
_processMatchedSelector
:
function
(
selector
status
distance
)
{
const
cssRule
=
selector
.
cssRule
;
const
value
=
cssRule
.
getPropertyValue
(
this
.
property
)
;
if
(
value
&
&
(
status
=
=
STATUS
.
MATCHED
|
|
(
status
=
=
STATUS
.
PARENT_MATCH
&
&
InspectorUtils
.
isInheritedProperty
(
this
.
property
)
)
)
)
{
const
selectorInfo
=
new
CssSelectorInfo
(
selector
this
.
property
value
status
distance
)
;
this
.
_matchedSelectors
.
push
(
selectorInfo
)
;
}
}
_refilterSelectors
:
function
(
)
{
const
passId
=
+
+
this
.
_cssLogic
.
_passId
;
const
iterator
=
function
(
selectorInfo
)
{
const
cssRule
=
selectorInfo
.
selector
.
cssRule
;
if
(
cssRule
.
_passId
!
=
passId
)
{
cssRule
.
_passId
=
passId
;
}
}
;
if
(
this
.
_matchedSelectors
)
{
this
.
_matchedSelectors
.
forEach
(
iterator
)
;
}
this
.
needRefilter
=
false
;
}
toString
:
function
(
)
{
return
"
CssPropertyInfo
[
"
+
this
.
property
+
"
]
"
;
}
}
;
function
CssSelectorInfo
(
selector
property
value
status
distance
)
{
this
.
selector
=
selector
;
this
.
property
=
property
;
this
.
status
=
status
;
this
.
distance
=
distance
;
this
.
value
=
value
;
const
priority
=
this
.
selector
.
cssRule
.
getPropertyPriority
(
this
.
property
)
;
this
.
important
=
priority
=
=
=
"
important
"
;
}
CssSelectorInfo
.
prototype
=
{
get
source
(
)
{
return
this
.
selector
.
source
;
}
get
sourceElement
(
)
{
return
this
.
selector
.
sourceElement
;
}
get
href
(
)
{
return
this
.
selector
.
href
;
}
get
inlineStyle
(
)
{
return
this
.
selector
.
inlineStyle
;
}
get
specificity
(
)
{
return
this
.
selector
.
specificity
;
}
get
sheetIndex
(
)
{
return
this
.
selector
.
sheetIndex
;
}
get
sheetAllowed
(
)
{
return
this
.
selector
.
sheetAllowed
;
}
get
ruleLine
(
)
{
return
this
.
selector
.
ruleLine
;
}
get
ruleColumn
(
)
{
return
this
.
selector
.
ruleColumn
;
}
get
agentRule
(
)
{
return
this
.
selector
.
agentRule
;
}
get
authorRule
(
)
{
return
this
.
selector
.
authorRule
;
}
get
userRule
(
)
{
return
this
.
selector
.
userRule
;
}
compareTo
:
function
(
that
)
{
let
current
=
null
;
current
=
this
.
compare
(
that
"
distance
"
COMPAREMODE
.
INTEGER
)
;
if
(
current
)
{
return
current
;
}
if
(
this
.
important
)
{
for
(
const
propName
of
[
"
agentRule
"
"
userRule
"
"
authorRule
"
]
)
{
current
=
this
.
compare
(
that
propName
COMPAREMODE
.
BOOLEAN
)
;
if
(
current
)
{
return
current
;
}
}
}
for
(
const
propName
of
[
"
authorRule
"
"
userRule
"
"
agentRule
"
]
)
{
current
=
this
.
compare
(
that
propName
COMPAREMODE
.
BOOLEAN
)
;
if
(
current
)
{
return
current
;
}
}
for
(
const
propName
of
[
"
specificity
"
"
sheetIndex
"
"
ruleLine
"
"
ruleColumn
"
]
)
{
current
=
this
.
compare
(
that
propName
COMPAREMODE
.
INTEGER
)
;
if
(
current
)
{
return
current
;
}
}
return
0
;
}
compare
:
function
(
that
propertyName
type
)
{
switch
(
type
)
{
case
COMPAREMODE
.
BOOLEAN
:
if
(
this
[
propertyName
]
&
&
!
that
[
propertyName
]
)
{
return
-
1
;
}
if
(
!
this
[
propertyName
]
&
&
that
[
propertyName
]
)
{
return
1
;
}
break
;
case
COMPAREMODE
.
INTEGER
:
if
(
this
[
propertyName
]
>
that
[
propertyName
]
)
{
return
-
1
;
}
if
(
this
[
propertyName
]
<
that
[
propertyName
]
)
{
return
1
;
}
break
;
}
return
0
;
}
toString
:
function
(
)
{
return
this
.
selector
+
"
-
>
"
+
this
.
value
;
}
}
;
