"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
JQUERY_LIVE_REGEX
=
/
return
typeof
\
w
+
.
*
.
event
\
.
triggered
[
\
s
\
S
]
*
\
.
event
\
.
(
dispatch
|
handle
)
.
*
arguments
/
;
var
parsers
=
[
{
id
:
"
jQuery
events
"
hasListeners
:
function
(
node
)
{
const
global
=
node
.
ownerGlobal
.
wrappedJSObject
;
const
hasJQuery
=
global
.
jQuery
&
&
global
.
jQuery
.
fn
&
&
global
.
jQuery
.
fn
.
jquery
;
if
(
!
hasJQuery
)
{
return
false
;
}
const
jQuery
=
global
.
jQuery
;
const
handlers
=
[
]
;
const
data
=
jQuery
.
_data
|
|
jQuery
.
data
;
if
(
data
)
{
const
eventsObj
=
data
(
node
"
events
"
)
;
for
(
const
type
in
eventsObj
)
{
const
events
=
eventsObj
[
type
]
;
for
(
const
key
in
events
)
{
const
event
=
events
[
key
]
;
if
(
node
.
wrappedJSObject
=
=
global
.
document
&
&
event
.
selector
)
{
continue
;
}
if
(
typeof
event
=
=
=
"
object
"
|
|
typeof
event
=
=
=
"
function
"
)
{
return
true
;
}
}
}
}
const
entry
=
jQuery
(
node
)
[
0
]
;
if
(
!
entry
)
{
return
handlers
;
}
for
(
const
type
in
entry
.
events
)
{
const
events
=
entry
.
events
[
type
]
;
for
(
const
key
in
events
)
{
const
event
=
events
[
key
]
;
if
(
node
.
wrappedJSObject
=
=
global
.
document
&
&
event
.
selector
)
{
continue
;
}
if
(
typeof
events
[
key
]
=
=
=
"
function
"
)
{
return
true
;
}
}
}
return
false
;
}
getListeners
:
function
(
node
)
{
const
global
=
node
.
ownerGlobal
.
wrappedJSObject
;
const
hasJQuery
=
global
.
jQuery
&
&
global
.
jQuery
.
fn
&
&
global
.
jQuery
.
fn
.
jquery
;
if
(
!
hasJQuery
)
{
return
undefined
;
}
const
jQuery
=
global
.
jQuery
;
const
handlers
=
[
]
;
const
data
=
jQuery
.
_data
|
|
jQuery
.
data
;
if
(
data
)
{
const
eventsObj
=
data
(
node
"
events
"
)
;
for
(
const
type
in
eventsObj
)
{
const
events
=
eventsObj
[
type
]
;
for
(
const
key
in
events
)
{
const
event
=
events
[
key
]
;
if
(
node
.
wrappedJSObject
=
=
global
.
document
&
&
event
.
selector
)
{
continue
;
}
if
(
typeof
event
=
=
=
"
object
"
|
|
typeof
event
=
=
=
"
function
"
)
{
const
eventInfo
=
{
type
:
type
handler
:
event
.
handler
|
|
event
tags
:
"
jQuery
"
hide
:
{
capturing
:
true
dom0
:
true
}
}
;
handlers
.
push
(
eventInfo
)
;
}
}
}
}
const
entry
=
jQuery
(
node
)
[
0
]
;
if
(
!
entry
)
{
return
handlers
;
}
for
(
const
type
in
entry
.
events
)
{
const
events
=
entry
.
events
[
type
]
;
for
(
const
key
in
events
)
{
const
event
=
events
[
key
]
;
if
(
node
.
wrappedJSObject
=
=
global
.
document
&
&
event
.
selector
)
{
continue
;
}
if
(
typeof
events
[
key
]
=
=
=
"
function
"
)
{
const
eventInfo
=
{
type
:
type
handler
:
events
[
key
]
tags
:
"
jQuery
"
hide
:
{
capturing
:
true
dom0
:
true
}
}
;
handlers
.
push
(
eventInfo
)
;
}
}
}
return
handlers
;
}
}
{
id
:
"
jQuery
live
events
"
hasListeners
:
function
(
node
)
{
return
jQueryLiveGetListeners
(
node
true
)
;
}
getListeners
:
function
(
node
)
{
return
jQueryLiveGetListeners
(
node
false
)
;
}
normalizeListener
:
function
(
handlerDO
)
{
function
isFunctionInProxy
(
funcDO
)
{
const
displayName
=
funcDO
.
displayName
;
if
(
displayName
&
&
displayName
.
startsWith
(
"
proxy
/
"
)
)
{
return
true
;
}
const
calleeDO
=
funcDO
.
environment
.
callee
;
if
(
!
calleeDO
)
{
return
false
;
}
const
calleeName
=
calleeDO
.
displayName
;
return
calleeName
=
=
"
proxy
"
;
}
function
getFirstFunctionVariable
(
funcDO
)
{
const
names
=
funcDO
.
environment
.
names
(
)
;
for
(
const
varName
of
names
)
{
const
varDO
=
handlerDO
.
environment
.
getVariable
(
varName
)
;
if
(
!
varDO
)
{
continue
;
}
if
(
varDO
.
class
=
=
"
Function
"
)
{
return
varDO
;
}
}
return
null
;
}
if
(
!
isFunctionInProxy
(
handlerDO
)
)
{
return
handlerDO
;
}
const
MAX_NESTED_HANDLER_COUNT
=
2
;
for
(
let
i
=
0
;
i
<
MAX_NESTED_HANDLER_COUNT
;
i
+
+
)
{
const
funcDO
=
getFirstFunctionVariable
(
handlerDO
)
;
if
(
!
funcDO
)
{
return
handlerDO
;
}
handlerDO
=
funcDO
;
if
(
isFunctionInProxy
(
handlerDO
)
)
{
continue
;
}
break
;
}
return
handlerDO
;
}
}
{
id
:
"
DOM
events
"
hasListeners
:
function
(
node
)
{
let
listeners
;
if
(
node
.
nodeName
.
toLowerCase
(
)
=
=
=
"
html
"
)
{
const
winListeners
=
Services
.
els
.
getListenerInfoFor
(
node
.
ownerGlobal
)
|
|
[
]
;
const
docElementListeners
=
Services
.
els
.
getListenerInfoFor
(
node
)
|
|
[
]
;
const
docListeners
=
Services
.
els
.
getListenerInfoFor
(
node
.
parentNode
)
|
|
[
]
;
listeners
=
[
.
.
.
winListeners
.
.
.
docElementListeners
.
.
.
docListeners
]
;
}
else
{
listeners
=
Services
.
els
.
getListenerInfoFor
(
node
)
|
|
[
]
;
}
for
(
const
listener
of
listeners
)
{
if
(
isValidDOMListener
(
listener
)
)
{
return
true
;
}
}
return
false
;
}
getListeners
:
function
(
node
)
{
const
handlers
=
[
]
;
const
listeners
=
Services
.
els
.
getListenerInfoFor
(
node
)
;
for
(
const
listener
of
listeners
)
{
if
(
!
isValidDOMListener
(
listener
)
)
{
continue
;
}
let
obj
=
listener
.
listenerObject
;
if
(
Cu
.
isXrayWrapper
(
obj
)
)
{
obj
=
listener
.
listenerObject
.
wrappedJSObject
;
}
let
handler
=
null
;
if
(
typeof
obj
=
=
=
"
object
"
)
{
const
unwrapped
=
Cu
.
isXrayWrapper
(
obj
)
?
obj
.
wrappedJSObject
:
obj
;
if
(
typeof
unwrapped
.
handleEvent
=
=
=
"
function
"
)
{
handler
=
Cu
.
unwaiveXrays
(
unwrapped
.
handleEvent
)
;
}
}
else
if
(
typeof
obj
=
=
=
"
function
"
)
{
if
(
JQUERY_LIVE_REGEX
.
test
(
obj
.
toString
(
)
)
)
{
continue
;
}
handler
=
obj
;
}
else
{
continue
;
}
const
eventInfo
=
{
capturing
:
listener
.
capturing
type
:
listener
.
type
handler
:
handler
}
;
handlers
.
push
(
eventInfo
)
;
}
return
handlers
;
}
}
{
id
:
"
React
events
"
hasListeners
:
function
(
node
)
{
return
reactGetListeners
(
node
true
)
;
}
getListeners
:
function
(
node
)
{
return
reactGetListeners
(
node
false
)
;
}
normalizeListener
:
function
(
handlerDO
listener
)
{
let
functionText
=
"
"
;
if
(
handlerDO
.
boundTargetFunction
)
{
handlerDO
=
handlerDO
.
boundTargetFunction
;
}
const
introScript
=
handlerDO
.
script
.
source
.
introductionScript
;
const
script
=
handlerDO
.
script
;
if
(
introScript
&
&
introScript
.
displayName
.
endsWith
(
"
/
transform
.
run
"
)
)
{
listener
.
hide
.
debugger
=
true
;
listener
.
hide
.
filename
=
true
;
if
(
!
handlerDO
.
isArrowFunction
)
{
functionText
+
=
"
function
(
"
;
}
else
{
functionText
+
=
"
(
"
;
}
functionText
+
=
handlerDO
.
parameterNames
.
join
(
"
"
)
;
functionText
+
=
"
)
{
\
n
"
;
const
scriptSource
=
script
.
source
.
text
;
functionText
+
=
scriptSource
.
substr
(
script
.
sourceStart
script
.
sourceLength
)
;
listener
.
override
.
handler
=
functionText
;
}
return
handlerDO
;
}
}
]
;
function
reactGetListeners
(
node
boolOnEventFound
)
{
function
getProps
(
)
{
for
(
const
key
of
Object
.
keys
(
node
)
)
{
if
(
key
.
startsWith
(
"
__reactInternalInstance
"
)
)
{
const
value
=
node
[
key
]
;
if
(
value
.
memoizedProps
)
{
return
value
.
memoizedProps
;
}
return
value
.
_currentElement
.
props
;
}
}
return
null
;
}
node
=
node
.
wrappedJSObject
|
|
node
;
const
handlers
=
[
]
;
const
props
=
getProps
(
)
;
if
(
props
)
{
for
(
const
name
in
props
)
{
if
(
name
.
startsWith
(
"
on
"
)
)
{
const
prop
=
props
[
name
]
;
const
listener
=
prop
.
__reactBoundMethod
|
|
prop
;
if
(
typeof
listener
!
=
=
"
function
"
)
{
continue
;
}
if
(
boolOnEventFound
)
{
return
true
;
}
const
handler
=
{
type
:
name
handler
:
listener
tags
:
"
React
"
hide
:
{
dom0
:
true
}
override
:
{
capturing
:
name
.
endsWith
(
"
Capture
"
)
}
}
;
handlers
.
push
(
handler
)
;
}
}
}
if
(
boolOnEventFound
)
{
return
false
;
}
return
handlers
;
}
function
jQueryLiveGetListeners
(
node
boolOnEventFound
)
{
const
global
=
node
.
ownerGlobal
.
wrappedJSObject
;
const
hasJQuery
=
global
.
jQuery
&
&
global
.
jQuery
.
fn
&
&
global
.
jQuery
.
fn
.
jquery
;
if
(
!
hasJQuery
)
{
return
undefined
;
}
const
jQuery
=
global
.
jQuery
;
const
handlers
=
[
]
;
const
data
=
jQuery
.
_data
|
|
jQuery
.
data
;
if
(
data
)
{
const
events
=
data
(
global
.
document
"
events
"
)
;
for
(
const
type
in
events
)
{
const
eventHolder
=
events
[
type
]
;
for
(
const
idx
in
eventHolder
)
{
if
(
typeof
idx
!
=
=
"
string
"
|
|
isNaN
(
parseInt
(
idx
10
)
)
)
{
continue
;
}
const
event
=
eventHolder
[
idx
]
;
let
selector
=
event
.
selector
;
if
(
!
selector
&
&
event
.
data
)
{
selector
=
event
.
data
.
selector
|
|
event
.
data
|
|
event
.
selector
;
}
if
(
!
selector
|
|
!
node
.
ownerDocument
)
{
continue
;
}
let
matches
;
try
{
matches
=
node
.
matches
&
&
node
.
matches
(
selector
)
;
}
catch
(
e
)
{
}
if
(
boolOnEventFound
&
&
matches
)
{
return
true
;
}
if
(
!
matches
)
{
continue
;
}
if
(
!
boolOnEventFound
&
&
(
typeof
event
=
=
=
"
object
"
|
|
typeof
event
=
=
=
"
function
"
)
)
{
const
eventInfo
=
{
type
:
event
.
origType
|
|
event
.
type
.
substr
(
selector
.
length
+
1
)
handler
:
event
.
handler
|
|
event
tags
:
"
jQuery
Live
"
hide
:
{
dom0
:
true
capturing
:
true
}
}
;
if
(
!
eventInfo
.
type
&
&
event
.
data
&
&
event
.
data
.
live
)
{
eventInfo
.
type
=
event
.
data
.
live
;
}
handlers
.
push
(
eventInfo
)
;
}
}
}
}
if
(
boolOnEventFound
)
{
return
false
;
}
return
handlers
;
}
function
isValidDOMListener
(
listener
)
{
if
(
!
listener
.
type
)
{
return
false
;
}
let
obj
=
listener
.
listenerObject
;
if
(
!
obj
)
{
return
false
;
}
if
(
Cu
.
isXrayWrapper
(
obj
)
)
{
obj
=
listener
.
listenerObject
.
wrappedJSObject
;
}
if
(
typeof
obj
=
=
=
"
object
"
)
{
const
unwrapped
=
Cu
.
isXrayWrapper
(
obj
)
?
obj
.
wrappedJSObject
:
obj
;
if
(
typeof
unwrapped
.
handleEvent
=
=
=
"
function
"
)
{
return
Cu
.
unwaiveXrays
(
unwrapped
.
handleEvent
)
;
}
return
false
;
}
else
if
(
typeof
obj
=
=
=
"
function
"
)
{
if
(
JQUERY_LIVE_REGEX
.
test
(
obj
.
toString
(
)
)
)
{
return
false
;
}
return
obj
;
}
return
false
;
}
this
.
EventParsers
=
function
EventParsers
(
)
{
if
(
this
.
_eventParsers
.
size
=
=
=
0
)
{
for
(
const
parserObj
of
parsers
)
{
this
.
registerEventParser
(
parserObj
)
;
}
}
}
;
exports
.
EventParsers
=
EventParsers
;
EventParsers
.
prototype
=
{
_eventParsers
:
new
Map
(
)
get
parsers
(
)
{
return
this
.
_eventParsers
;
}
registerEventParser
:
function
(
parserObj
)
{
const
parserId
=
parserObj
.
id
;
if
(
!
parserId
)
{
throw
new
Error
(
"
Cannot
register
new
event
parser
with
id
"
+
parserId
)
;
}
if
(
this
.
_eventParsers
.
has
(
parserId
)
)
{
throw
new
Error
(
"
Duplicate
event
parser
id
"
+
parserId
)
;
}
this
.
_eventParsers
.
set
(
parserId
{
getListeners
:
parserObj
.
getListeners
hasListeners
:
parserObj
.
hasListeners
normalizeListener
:
parserObj
.
normalizeListener
}
)
;
}
unregisterEventParser
:
function
(
parserId
)
{
this
.
_eventParsers
.
delete
(
parserId
)
;
}
destroy
:
function
(
)
{
for
(
const
[
id
]
of
this
.
_eventParsers
)
{
this
.
unregisterEventParser
(
id
true
)
;
}
}
}
;
