"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
loader
.
lazyRequireGetter
(
this
"
isRemoteBrowserElement
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
const
IS_OSX
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
class
NodePicker
{
#
eventListenersAbortController
;
constructor
(
walker
targetActor
)
{
this
.
_walker
=
walker
;
this
.
_targetActor
=
targetActor
;
this
.
_isPicking
=
false
;
this
.
_hoveredNode
=
null
;
this
.
_currentNode
=
null
;
this
.
_onHovered
=
this
.
_onHovered
.
bind
(
this
)
;
this
.
_onKey
=
this
.
_onKey
.
bind
(
this
)
;
this
.
_onPick
=
this
.
_onPick
.
bind
(
this
)
;
this
.
_onSuppressedEvent
=
this
.
_onSuppressedEvent
.
bind
(
this
)
;
this
.
_preventContentEvent
=
this
.
_preventContentEvent
.
bind
(
this
)
;
}
_findAndAttachElement
(
event
)
{
const
node
=
event
.
originalTarget
|
|
event
.
target
;
return
this
.
_walker
.
attachElement
(
node
)
;
}
_isEventAllowed
(
{
view
}
)
{
if
(
this
.
_targetActor
.
window
instanceof
Ci
.
nsIDOMChromeWindow
)
{
return
true
;
}
return
this
.
_targetActor
.
windows
.
includes
(
view
)
;
}
_onPick
(
event
)
{
if
(
isRemoteBrowserElement
(
event
.
target
)
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
if
(
event
.
shiftKey
)
{
this
.
_walker
.
emit
(
"
picker
-
node
-
previewed
"
this
.
_findAndAttachElement
(
event
)
)
;
return
;
}
this
.
_stopPickerListeners
(
)
;
this
.
_isPicking
=
false
;
if
(
!
this
.
_currentNode
)
{
this
.
_currentNode
=
this
.
_findAndAttachElement
(
event
)
;
}
this
.
_walker
.
emit
(
"
picker
-
node
-
picked
"
this
.
_currentNode
)
;
}
_onHovered
(
event
)
{
if
(
isRemoteBrowserElement
(
event
.
target
)
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
this
.
_currentNode
=
this
.
_findAndAttachElement
(
event
)
;
if
(
this
.
_hoveredNode
!
=
=
this
.
_currentNode
.
node
)
{
this
.
_walker
.
emit
(
"
picker
-
node
-
hovered
"
this
.
_currentNode
)
;
this
.
_hoveredNode
=
this
.
_currentNode
.
node
;
}
}
_onKey
(
event
)
{
if
(
!
this
.
_currentNode
|
|
!
this
.
_isPicking
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
let
currentNode
=
this
.
_currentNode
.
node
.
rawNode
;
switch
(
event
.
keyCode
)
{
case
event
.
DOM_VK_LEFT
:
if
(
!
currentNode
.
parentElement
)
{
return
;
}
currentNode
=
currentNode
.
parentElement
;
break
;
case
event
.
DOM_VK_RIGHT
:
if
(
!
currentNode
.
children
.
length
)
{
return
;
}
let
child
=
currentNode
.
firstElementChild
;
const
hoveredNode
=
this
.
_hoveredNode
.
rawNode
;
for
(
const
sibling
of
currentNode
.
children
)
{
if
(
sibling
.
contains
(
hoveredNode
)
|
|
sibling
=
=
=
hoveredNode
)
{
child
=
sibling
;
}
}
currentNode
=
child
;
break
;
case
event
.
DOM_VK_RETURN
:
this
.
_onPick
(
event
)
;
return
;
case
event
.
DOM_VK_ESCAPE
:
this
.
cancelPick
(
)
;
this
.
_walker
.
emit
(
"
picker
-
node
-
canceled
"
)
;
return
;
case
event
.
DOM_VK_C
:
const
{
altKey
ctrlKey
metaKey
shiftKey
}
=
event
;
if
(
(
IS_OSX
&
&
metaKey
&
&
altKey
|
shiftKey
)
|
|
(
!
IS_OSX
&
&
ctrlKey
&
&
shiftKey
)
)
{
this
.
cancelPick
(
)
;
this
.
_walker
.
emit
(
"
picker
-
node
-
canceled
"
)
;
}
return
;
default
:
return
;
}
this
.
_currentNode
=
this
.
_walker
.
attachElement
(
currentNode
)
;
this
.
_walker
.
emit
(
"
picker
-
node
-
hovered
"
this
.
_currentNode
)
;
}
_onSuppressedEvent
(
event
)
{
if
(
event
.
type
=
=
"
mousemove
"
)
{
this
.
_onHovered
(
event
)
;
}
else
if
(
event
.
type
=
=
"
mouseup
"
)
{
this
.
_onPick
(
event
)
;
}
}
_preventContentEvent
(
event
)
{
if
(
isRemoteBrowserElement
(
event
.
target
)
)
{
return
;
}
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
_setSuppressedEventListener
(
callback
)
{
if
(
!
this
.
_targetActor
?
.
window
?
.
document
)
{
return
;
}
this
.
_targetActor
.
window
.
document
.
setSuppressedEventListener
(
callback
?
{
handleEvent
:
callback
}
:
null
)
;
}
_startPickerListeners
(
)
{
const
target
=
this
.
_targetActor
.
chromeEventHandler
;
this
.
#
eventListenersAbortController
=
new
AbortController
(
)
;
const
config
=
{
capture
:
true
signal
:
this
.
#
eventListenersAbortController
.
signal
}
;
target
.
addEventListener
(
"
mousemove
"
this
.
_onHovered
config
)
;
target
.
addEventListener
(
"
click
"
this
.
_onPick
config
)
;
target
.
addEventListener
(
"
mousedown
"
this
.
_preventContentEvent
config
)
;
target
.
addEventListener
(
"
mouseup
"
this
.
_preventContentEvent
config
)
;
target
.
addEventListener
(
"
dblclick
"
this
.
_preventContentEvent
config
)
;
target
.
addEventListener
(
"
keydown
"
this
.
_onKey
config
)
;
target
.
addEventListener
(
"
keyup
"
this
.
_preventContentEvent
config
)
;
this
.
_setSuppressedEventListener
(
this
.
_onSuppressedEvent
)
;
}
_stopPickerListeners
(
)
{
this
.
_setSuppressedEventListener
(
null
)
;
if
(
this
.
#
eventListenersAbortController
)
{
this
.
#
eventListenersAbortController
.
abort
(
)
;
this
.
#
eventListenersAbortController
=
null
;
}
}
cancelPick
(
)
{
if
(
this
.
_targetActor
.
threadActor
)
{
this
.
_targetActor
.
threadActor
.
showOverlay
(
)
;
}
if
(
this
.
_isPicking
)
{
this
.
_stopPickerListeners
(
)
;
this
.
_isPicking
=
false
;
this
.
_hoveredNode
=
null
;
}
}
pick
(
doFocus
=
false
)
{
if
(
this
.
_targetActor
.
threadActor
)
{
this
.
_targetActor
.
threadActor
.
hideOverlay
(
)
;
}
if
(
this
.
_isPicking
)
{
return
;
}
this
.
_startPickerListeners
(
)
;
this
.
_isPicking
=
true
;
if
(
doFocus
)
{
this
.
_targetActor
.
window
.
focus
(
)
;
}
}
resetHoveredNodeReference
(
)
{
this
.
_hoveredNode
=
null
;
}
destroy
(
)
{
this
.
cancelPick
(
)
;
this
.
_targetActor
=
null
;
this
.
_walker
=
null
;
}
}
exports
.
NodePicker
=
NodePicker
;
