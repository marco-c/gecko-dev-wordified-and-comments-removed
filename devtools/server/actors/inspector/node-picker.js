"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
loader
.
lazyRequireGetter
(
this
"
ChromeUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
isRemoteBrowserElement
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HighlighterEnvironment
"
"
devtools
/
server
/
actors
/
highlighters
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
RemoteNodePickerNotice
"
"
devtools
/
server
/
actors
/
highlighters
/
remote
-
node
-
picker
-
notice
.
js
"
true
)
;
const
IS_OSX
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
class
NodePicker
{
#
eventListenersAbortController
;
#
remoteNodePickerNoticeHighlighter
;
constructor
(
walker
targetActor
)
{
this
.
_walker
=
walker
;
this
.
_targetActor
=
targetActor
;
this
.
_isPicking
=
false
;
this
.
_hoveredNode
=
null
;
this
.
_currentNode
=
null
;
this
.
_onHovered
=
this
.
_onHovered
.
bind
(
this
)
;
this
.
_onKey
=
this
.
_onKey
.
bind
(
this
)
;
this
.
_onPick
=
this
.
_onPick
.
bind
(
this
)
;
this
.
_onSuppressedEvent
=
this
.
_onSuppressedEvent
.
bind
(
this
)
;
this
.
_preventContentEvent
=
this
.
_preventContentEvent
.
bind
(
this
)
;
}
get
remoteNodePickerNoticeHighlighter
(
)
{
if
(
!
this
.
#
remoteNodePickerNoticeHighlighter
)
{
const
env
=
new
HighlighterEnvironment
(
)
;
env
.
initFromTargetActor
(
this
.
_targetActor
)
;
this
.
#
remoteNodePickerNoticeHighlighter
=
new
RemoteNodePickerNotice
(
env
)
;
}
return
this
.
#
remoteNodePickerNoticeHighlighter
;
}
_findAndAttachElement
(
event
)
{
let
node
=
event
.
originalTarget
|
|
event
.
target
;
if
(
event
.
shiftKey
)
{
node
=
this
.
_findNodeAtMouseEventPosition
(
event
)
|
|
node
;
}
const
shadowRoot
=
node
.
containingShadowRoot
;
if
(
shadowRoot
?
.
isUAWidget
(
)
&
&
!
this
.
_walker
.
showAllAnonymousContent
)
{
node
=
shadowRoot
.
host
;
}
return
this
.
_walker
.
attachElement
(
node
)
;
}
_findNodeAtMouseEventPosition
(
event
)
{
const
winUtils
=
this
.
_targetActor
.
window
.
windowUtils
;
const
rectSize
=
1
;
const
elements
=
winUtils
.
nodesFromRect
(
event
.
clientX
event
.
clientY
rectSize
rectSize
rectSize
rectSize
true
false
true
1
)
;
if
(
elements
.
length
>
1
&
&
ChromeUtils
.
getClassName
(
elements
[
0
]
)
=
=
"
HTMLHtmlElement
"
)
{
return
elements
[
1
]
;
}
return
elements
[
0
]
;
}
_isEventAllowed
(
{
view
}
)
{
if
(
this
.
_targetActor
.
window
instanceof
Ci
.
nsIDOMChromeWindow
)
{
return
true
;
}
return
this
.
_targetActor
.
windows
.
includes
(
view
)
;
}
_isEventInRemoteNodePickerNotice
(
event
)
{
return
(
this
.
#
remoteNodePickerNoticeHighlighter
&
&
event
.
originalTarget
?
.
closest
?
.
(
#
{
this
.
#
remoteNodePickerNoticeHighlighter
.
rootElementId
}
)
)
;
}
/
*
*
*
Pick
a
node
on
click
.
*
*
This
method
doesn
'
t
respond
anything
interesting
however
it
starts
*
mousemove
and
click
listeners
on
the
content
document
to
fire
*
events
and
let
connected
clients
know
when
nodes
are
hovered
over
or
*
clicked
.
*
*
Once
a
node
is
picked
events
will
cease
and
listeners
will
be
removed
.
*
/
_onPick
(
event
)
{
/
/
If
the
picked
node
is
a
remote
frame
then
we
need
to
let
the
event
through
/
/
since
there
'
s
a
highlighter
actor
in
that
sub
-
frame
also
picking
.
if
(
isRemoteBrowserElement
(
event
.
target
)
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
/
/
If
the
click
was
done
inside
the
node
picker
notice
highlighter
(
e
.
g
.
clicking
the
/
/
close
button
)
directly
call
its
onClick
method
as
it
doesn
'
t
have
event
listeners
/
/
itself
to
avoid
managing
events
(
+
suppressedEventListeners
)
for
the
same
target
/
/
from
different
places
.
if
(
this
.
_isEventInRemoteNodePickerNotice
(
event
)
)
{
this
.
#
remoteNodePickerNoticeHighlighter
.
onClick
(
event
)
;
return
;
}
/
/
If
Ctrl
(
Or
Cmd
on
OSX
)
is
pressed
this
is
only
a
preview
click
.
/
/
Send
the
event
to
the
client
but
don
'
t
stop
picking
.
if
(
(
IS_OSX
&
&
event
.
metaKey
)
|
|
(
!
IS_OSX
&
&
event
.
ctrlKey
)
)
{
this
.
_walker
.
emit
(
"
picker
-
node
-
previewed
"
this
.
_findAndAttachElement
(
event
)
)
;
return
;
}
this
.
_stopPicking
(
)
;
if
(
!
this
.
_currentNode
)
{
this
.
_currentNode
=
this
.
_findAndAttachElement
(
event
)
;
}
this
.
_walker
.
emit
(
"
picker
-
node
-
picked
"
this
.
_currentNode
)
;
}
_onHovered
(
event
)
{
if
(
isRemoteBrowserElement
(
event
.
target
)
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
if
(
this
.
#
remoteNodePickerNoticeHighlighter
)
{
this
.
#
remoteNodePickerNoticeHighlighter
.
handleHoveredElement
(
event
)
;
if
(
this
.
_isEventInRemoteNodePickerNotice
(
event
)
)
{
return
;
}
}
this
.
_currentNode
=
this
.
_findAndAttachElement
(
event
)
;
if
(
this
.
_hoveredNode
!
=
=
this
.
_currentNode
.
node
)
{
this
.
_walker
.
emit
(
"
picker
-
node
-
hovered
"
this
.
_currentNode
)
;
this
.
_hoveredNode
=
this
.
_currentNode
.
node
;
}
}
_onKey
(
event
)
{
if
(
!
this
.
_currentNode
|
|
!
this
.
_isPicking
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
let
currentNode
=
this
.
_currentNode
.
node
.
rawNode
;
switch
(
event
.
keyCode
)
{
case
event
.
DOM_VK_LEFT
:
if
(
!
currentNode
.
parentElement
)
{
return
;
}
currentNode
=
currentNode
.
parentElement
;
break
;
case
event
.
DOM_VK_RIGHT
:
if
(
!
currentNode
.
children
.
length
)
{
return
;
}
let
child
=
currentNode
.
firstElementChild
;
const
hoveredNode
=
this
.
_hoveredNode
.
rawNode
;
for
(
const
sibling
of
currentNode
.
children
)
{
if
(
sibling
.
contains
(
hoveredNode
)
|
|
sibling
=
=
=
hoveredNode
)
{
child
=
sibling
;
}
}
currentNode
=
child
;
break
;
case
event
.
DOM_VK_RETURN
:
this
.
_onPick
(
event
)
;
return
;
case
event
.
DOM_VK_ESCAPE
:
this
.
cancelPick
(
)
;
this
.
_walker
.
emit
(
"
picker
-
node
-
canceled
"
)
;
return
;
case
event
.
DOM_VK_C
:
const
{
altKey
ctrlKey
metaKey
shiftKey
}
=
event
;
if
(
(
IS_OSX
&
&
metaKey
&
&
altKey
|
shiftKey
)
|
|
(
!
IS_OSX
&
&
ctrlKey
&
&
shiftKey
)
)
{
this
.
cancelPick
(
)
;
this
.
_walker
.
emit
(
"
picker
-
node
-
canceled
"
)
;
}
return
;
default
:
return
;
}
this
.
_currentNode
=
this
.
_walker
.
attachElement
(
currentNode
)
;
this
.
_walker
.
emit
(
"
picker
-
node
-
hovered
"
this
.
_currentNode
)
;
}
_onSuppressedEvent
(
event
)
{
if
(
event
.
type
=
=
"
mousemove
"
)
{
this
.
_onHovered
(
event
)
;
}
else
if
(
event
.
type
=
=
"
mouseup
"
)
{
this
.
_onPick
(
event
)
;
}
}
_preventContentEvent
(
event
)
{
if
(
isRemoteBrowserElement
(
event
.
target
)
)
{
return
;
}
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
_setSuppressedEventListener
(
callback
)
{
if
(
!
this
.
_targetActor
?
.
window
?
.
document
)
{
return
;
}
this
.
_targetActor
.
window
.
document
.
setSuppressedEventListener
(
callback
?
{
handleEvent
:
callback
}
:
null
)
;
}
_startPickerListeners
(
)
{
const
target
=
this
.
_targetActor
.
chromeEventHandler
;
this
.
#
eventListenersAbortController
=
new
AbortController
(
)
;
const
config
=
{
capture
:
true
signal
:
this
.
#
eventListenersAbortController
.
signal
}
;
target
.
addEventListener
(
"
mousemove
"
this
.
_onHovered
config
)
;
target
.
addEventListener
(
"
click
"
this
.
_onPick
config
)
;
target
.
addEventListener
(
"
mousedown
"
this
.
_preventContentEvent
config
)
;
target
.
addEventListener
(
"
mouseup
"
this
.
_preventContentEvent
config
)
;
target
.
addEventListener
(
"
dblclick
"
this
.
_preventContentEvent
config
)
;
target
.
addEventListener
(
"
keydown
"
this
.
_onKey
config
)
;
target
.
addEventListener
(
"
keyup
"
this
.
_preventContentEvent
config
)
;
this
.
_setSuppressedEventListener
(
this
.
_onSuppressedEvent
)
;
}
_stopPickerListeners
(
)
{
this
.
_setSuppressedEventListener
(
null
)
;
if
(
this
.
#
eventListenersAbortController
)
{
this
.
#
eventListenersAbortController
.
abort
(
)
;
this
.
#
eventListenersAbortController
=
null
;
}
}
_stopPicking
(
)
{
this
.
_stopPickerListeners
(
)
;
this
.
_isPicking
=
false
;
this
.
_hoveredNode
=
null
;
if
(
this
.
#
remoteNodePickerNoticeHighlighter
)
{
this
.
#
remoteNodePickerNoticeHighlighter
.
hide
(
)
;
}
}
cancelPick
(
)
{
if
(
this
.
_targetActor
.
threadActor
)
{
this
.
_targetActor
.
threadActor
.
showOverlay
(
)
;
}
if
(
this
.
_isPicking
)
{
this
.
_stopPicking
(
)
;
}
}
pick
(
doFocus
=
false
isLocalTab
=
true
)
{
if
(
this
.
_targetActor
.
threadActor
)
{
this
.
_targetActor
.
threadActor
.
hideOverlay
(
)
;
}
if
(
this
.
_isPicking
)
{
return
;
}
this
.
_startPickerListeners
(
)
;
this
.
_isPicking
=
true
;
if
(
doFocus
)
{
this
.
_targetActor
.
window
.
focus
(
)
;
}
if
(
!
isLocalTab
)
{
this
.
remoteNodePickerNoticeHighlighter
.
show
(
)
;
}
}
resetHoveredNodeReference
(
)
{
this
.
_hoveredNode
=
null
;
}
destroy
(
)
{
this
.
cancelPick
(
)
;
this
.
_targetActor
=
null
;
this
.
_walker
=
null
;
this
.
#
remoteNodePickerNoticeHighlighter
=
null
;
}
}
exports
.
NodePicker
=
NodePicker
;
