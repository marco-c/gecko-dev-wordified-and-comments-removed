"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
walkerSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
inspector
"
)
;
const
{
LongStringActor
}
=
require
(
"
devtools
/
server
/
actors
/
string
"
)
;
const
InspectorUtils
=
require
(
"
InspectorUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
getFrameElement
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isAfterPseudoElement
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isAnonymous
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isBeforePseudoElement
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isDirectShadowHostChild
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isShadowHost
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isShadowRoot
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isTemplateElement
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
loadSheet
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
throttle
"
"
devtools
/
shared
/
throttle
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
allAnonymousContentTreeWalkerFilter
"
"
devtools
/
server
/
actors
/
inspector
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isNodeDead
"
"
devtools
/
server
/
actors
/
inspector
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
nodeDocument
"
"
devtools
/
server
/
actors
/
inspector
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
standardTreeWalkerFilter
"
"
devtools
/
server
/
actors
/
inspector
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CustomElementWatcher
"
"
devtools
/
server
/
actors
/
inspector
/
custom
-
element
-
watcher
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DocumentWalker
"
"
devtools
/
server
/
actors
/
inspector
/
document
-
walker
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
SKIP_TO_SIBLING
"
"
devtools
/
server
/
actors
/
inspector
/
document
-
walker
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NodeActor
"
"
devtools
/
server
/
actors
/
inspector
/
node
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NodeListActor
"
"
devtools
/
server
/
actors
/
inspector
/
node
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
LayoutActor
"
"
devtools
/
server
/
actors
/
layout
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getLayoutChangesObserver
"
"
devtools
/
server
/
actors
/
reflow
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
releaseLayoutChangesObserver
"
"
devtools
/
server
/
actors
/
reflow
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WalkerSearch
"
"
devtools
/
server
/
actors
/
utils
/
walker
-
search
"
true
)
;
loader
.
lazyServiceGetter
(
this
"
eventListenerService
"
"
mozilla
.
org
/
eventlistenerservice
;
1
"
"
nsIEventListenerService
"
)
;
const
MUTATIONS_THROTTLING_DELAY
=
100
;
const
IMMEDIATE_MUTATIONS
=
[
"
documentUnload
"
"
frameLoad
"
"
newRoot
"
"
pseudoClassLock
"
]
;
const
HIDDEN_CLASS
=
"
__fx
-
devtools
-
hide
-
shortcut__
"
;
const
PSEUDO_SELECTORS
=
[
[
"
:
active
"
1
]
[
"
:
hover
"
1
]
[
"
:
focus
"
1
]
[
"
:
visited
"
0
]
[
"
:
link
"
0
]
[
"
:
first
-
letter
"
0
]
[
"
:
first
-
child
"
2
]
[
"
:
before
"
2
]
[
"
:
after
"
2
]
[
"
:
lang
(
"
0
]
[
"
:
not
(
"
3
]
[
"
:
first
-
of
-
type
"
0
]
[
"
:
last
-
of
-
type
"
0
]
[
"
:
only
-
of
-
type
"
0
]
[
"
:
only
-
child
"
2
]
[
"
:
nth
-
child
(
"
3
]
[
"
:
nth
-
last
-
child
(
"
0
]
[
"
:
nth
-
of
-
type
(
"
0
]
[
"
:
nth
-
last
-
of
-
type
(
"
0
]
[
"
:
last
-
child
"
2
]
[
"
:
root
"
0
]
[
"
:
empty
"
0
]
[
"
:
target
"
0
]
[
"
:
enabled
"
0
]
[
"
:
disabled
"
0
]
[
"
:
checked
"
1
]
[
"
:
:
selection
"
0
]
]
;
const
HELPER_SHEET
=
"
data
:
text
/
css
;
charset
=
utf
-
8
"
+
encodeURIComponent
(
.
__fx
-
devtools
-
hide
-
shortcut__
{
visibility
:
hidden
!
important
;
}
:
-
moz
-
devtools
-
highlighted
{
outline
:
2px
dashed
#
F06
!
important
;
outline
-
offset
:
-
2px
!
important
;
}
)
;
exports
.
DEFAULT_VALUE_SUMMARY_LENGTH
=
50
;
var
gValueSummaryLength
=
exports
.
DEFAULT_VALUE_SUMMARY_LENGTH
;
exports
.
getValueSummaryLength
=
function
(
)
{
return
gValueSummaryLength
;
}
;
exports
.
setValueSummaryLength
=
function
(
val
)
{
gValueSummaryLength
=
val
;
}
;
var
WalkerActor
=
protocol
.
ActorClassWithSpec
(
walkerSpec
{
initialize
:
function
(
conn
targetActor
options
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
targetActor
=
targetActor
;
this
.
rootWin
=
targetActor
.
window
;
this
.
rootDoc
=
this
.
rootWin
.
document
;
this
.
_refMap
=
new
Map
(
)
;
this
.
_pendingMutations
=
[
]
;
this
.
_activePseudoClassLocks
=
new
Set
(
)
;
this
.
customElementWatcher
=
new
CustomElementWatcher
(
targetActor
.
chromeEventHandler
)
;
this
.
showAllAnonymousContent
=
options
.
showAllAnonymousContent
;
this
.
walkerSearch
=
new
WalkerSearch
(
this
)
;
this
.
_orphaned
=
new
Set
(
)
;
this
.
_retainedOrphans
=
new
Set
(
)
;
this
.
onMutations
=
this
.
onMutations
.
bind
(
this
)
;
this
.
onSlotchange
=
this
.
onSlotchange
.
bind
(
this
)
;
this
.
onShadowrootattached
=
this
.
onShadowrootattached
.
bind
(
this
)
;
this
.
onFrameLoad
=
this
.
onFrameLoad
.
bind
(
this
)
;
this
.
onFrameUnload
=
this
.
onFrameUnload
.
bind
(
this
)
;
this
.
onCustomElementDefined
=
this
.
onCustomElementDefined
.
bind
(
this
)
;
this
.
_throttledEmitNewMutations
=
throttle
(
this
.
_emitNewMutations
.
bind
(
this
)
MUTATIONS_THROTTLING_DELAY
)
;
targetActor
.
on
(
"
will
-
navigate
"
this
.
onFrameUnload
)
;
targetActor
.
on
(
"
window
-
ready
"
this
.
onFrameLoad
)
;
this
.
customElementWatcher
.
on
(
"
element
-
defined
"
this
.
onCustomElementDefined
)
;
this
.
chromeEventHandler
=
targetActor
.
chromeEventHandler
;
this
.
chromeEventHandler
.
addEventListener
(
"
shadowrootattached
"
this
.
onShadowrootattached
)
;
this
.
rootNode
=
this
.
document
(
)
;
this
.
layoutChangeObserver
=
getLayoutChangesObserver
(
this
.
targetActor
)
;
this
.
_onReflows
=
this
.
_onReflows
.
bind
(
this
)
;
this
.
layoutChangeObserver
.
on
(
"
reflows
"
this
.
_onReflows
)
;
this
.
_onResize
=
this
.
_onResize
.
bind
(
this
)
;
this
.
layoutChangeObserver
.
on
(
"
resize
"
this
.
_onResize
)
;
this
.
_onEventListenerChange
=
this
.
_onEventListenerChange
.
bind
(
this
)
;
eventListenerService
.
addListenerChangeListener
(
this
.
_onEventListenerChange
)
;
}
_onEventListenerChange
:
function
(
changesEnum
)
{
const
changes
=
changesEnum
.
enumerate
(
)
;
while
(
changes
.
hasMoreElements
(
)
)
{
const
current
=
changes
.
getNext
(
)
.
QueryInterface
(
Ci
.
nsIEventListenerChange
)
;
const
target
=
current
.
target
;
if
(
this
.
_refMap
.
has
(
target
)
)
{
const
actor
=
this
.
getNode
(
target
)
;
const
mutation
=
{
type
:
"
events
"
target
:
actor
.
actorID
hasEventListeners
:
actor
.
_hasEventListeners
}
;
this
.
queueMutation
(
mutation
)
;
}
}
}
form
:
function
(
)
{
return
{
actor
:
this
.
actorID
root
:
this
.
rootNode
.
form
(
)
traits
:
{
}
}
;
}
toString
:
function
(
)
{
return
"
[
WalkerActor
"
+
this
.
actorID
+
"
]
"
;
}
getDocumentWalker
:
function
(
node
whatToShow
skipTo
)
{
const
filter
=
this
.
showAllAnonymousContent
?
allAnonymousContentTreeWalkerFilter
:
standardTreeWalkerFilter
;
return
new
DocumentWalker
(
node
this
.
rootWin
{
whatToShow
filter
skipTo
showAnonymousContent
:
true
}
)
;
}
getNonAnonymousWalker
:
function
(
node
whatToShow
skipTo
)
{
const
nodeFilter
=
standardTreeWalkerFilter
;
return
new
DocumentWalker
(
node
this
.
rootWin
{
whatToShow
nodeFilter
skipTo
showAnonymousContent
:
false
}
)
;
}
destroy
:
function
(
)
{
if
(
this
.
_destroyed
)
{
return
;
}
this
.
_destroyed
=
true
;
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
try
{
this
.
clearPseudoClassLocks
(
)
;
this
.
_activePseudoClassLocks
=
null
;
this
.
_hoveredNode
=
null
;
this
.
rootWin
=
null
;
this
.
rootDoc
=
null
;
this
.
rootNode
=
null
;
this
.
layoutHelpers
=
null
;
this
.
_orphaned
=
null
;
this
.
_retainedOrphans
=
null
;
this
.
_refMap
=
null
;
this
.
targetActor
.
off
(
"
will
-
navigate
"
this
.
onFrameUnload
)
;
this
.
targetActor
.
off
(
"
window
-
ready
"
this
.
onFrameLoad
)
;
this
.
customElementWatcher
.
off
(
"
element
-
defined
"
this
.
onCustomElementDefined
)
;
this
.
chromeEventHandler
.
removeEventListener
(
"
shadowrootattached
"
this
.
onShadowrootattached
)
;
this
.
onFrameLoad
=
null
;
this
.
onFrameUnload
=
null
;
this
.
customElementWatcher
.
destroy
(
)
;
this
.
customElementWatcher
=
null
;
this
.
walkerSearch
.
destroy
(
)
;
this
.
layoutChangeObserver
.
off
(
"
reflows
"
this
.
_onReflows
)
;
this
.
layoutChangeObserver
.
off
(
"
resize
"
this
.
_onResize
)
;
this
.
layoutChangeObserver
=
null
;
releaseLayoutChangesObserver
(
this
.
targetActor
)
;
eventListenerService
.
removeListenerChangeListener
(
this
.
_onEventListenerChange
)
;
this
.
onMutations
=
null
;
this
.
layoutActor
=
null
;
this
.
targetActor
=
null
;
this
.
chromeEventHandler
=
null
;
this
.
emit
(
"
destroyed
"
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
release
:
function
(
)
{
}
unmanage
:
function
(
actor
)
{
if
(
actor
instanceof
NodeActor
)
{
if
(
this
.
_activePseudoClassLocks
&
&
this
.
_activePseudoClassLocks
.
has
(
actor
)
)
{
this
.
clearPseudoClassLocks
(
actor
)
;
}
this
.
customElementWatcher
.
unmanageNode
(
actor
)
;
this
.
_refMap
.
delete
(
actor
.
rawNode
)
;
}
protocol
.
Actor
.
prototype
.
unmanage
.
call
(
this
actor
)
;
}
hasNode
:
function
(
rawNode
)
{
return
this
.
_refMap
.
has
(
rawNode
)
;
}
getNode
:
function
(
rawNode
)
{
return
this
.
_refMap
.
get
(
rawNode
)
;
}
_ref
:
function
(
node
)
{
let
actor
=
this
.
getNode
(
node
)
;
if
(
actor
)
{
return
actor
;
}
actor
=
new
NodeActor
(
this
node
)
;
this
.
manage
(
actor
)
;
this
.
_refMap
.
set
(
node
actor
)
;
if
(
node
.
nodeType
=
=
=
Node
.
DOCUMENT_NODE
)
{
actor
.
watchDocument
(
node
this
.
onMutations
)
;
}
if
(
isShadowRoot
(
actor
.
rawNode
)
)
{
actor
.
watchDocument
(
node
.
ownerDocument
this
.
onMutations
)
;
actor
.
watchSlotchange
(
this
.
onSlotchange
)
;
}
this
.
customElementWatcher
.
manageNode
(
actor
)
;
return
actor
;
}
onCustomElementDefined
:
function
(
actors
)
{
actors
.
forEach
(
actor
=
>
this
.
queueMutation
(
{
target
:
actor
.
actorID
type
:
"
customElementDefined
"
customElementLocation
:
actor
.
getCustomElementLocation
(
)
}
)
)
;
}
_onReflows
:
function
(
reflows
)
{
const
changes
=
[
]
;
for
(
const
[
node
actor
]
of
this
.
_refMap
)
{
if
(
Cu
.
isDeadWrapper
(
node
)
)
{
continue
;
}
const
displayType
=
actor
.
displayType
;
const
isDisplayed
=
actor
.
isDisplayed
;
if
(
displayType
!
=
=
actor
.
currentDisplayType
|
|
isDisplayed
!
=
=
actor
.
wasDisplayed
)
{
changes
.
push
(
actor
)
;
actor
.
currentDisplayType
=
displayType
;
actor
.
wasDisplayed
=
isDisplayed
;
}
}
if
(
changes
.
length
)
{
this
.
emit
(
"
display
-
change
"
changes
)
;
}
}
_onResize
:
function
(
)
{
this
.
emit
(
"
resize
"
)
;
}
attachElement
:
function
(
node
)
{
const
{
nodes
newParents
}
=
this
.
attachElements
(
[
node
]
)
;
return
{
node
:
nodes
[
0
]
newParents
:
newParents
}
;
}
attachElements
:
function
(
nodes
)
{
const
nodeActors
=
[
]
;
const
newParents
=
new
Set
(
)
;
for
(
let
node
of
nodes
)
{
if
(
!
(
node
instanceof
NodeActor
)
)
{
if
(
!
this
.
showAllAnonymousContent
&
&
isAnonymous
(
node
)
)
{
node
=
this
.
getDocumentWalker
(
node
)
.
currentNode
;
}
node
=
this
.
_ref
(
node
)
;
}
this
.
ensurePathToRoot
(
node
newParents
)
;
nodeActors
.
push
(
node
)
;
}
return
{
nodes
:
nodeActors
newParents
:
[
.
.
.
newParents
]
}
;
}
document
:
function
(
node
)
{
const
doc
=
isNodeDead
(
node
)
?
this
.
rootDoc
:
nodeDocument
(
node
.
rawNode
)
;
return
this
.
_ref
(
doc
)
;
}
documentElement
:
function
(
node
)
{
const
elt
=
isNodeDead
(
node
)
?
this
.
rootDoc
.
documentElement
:
nodeDocument
(
node
.
rawNode
)
.
documentElement
;
return
this
.
_ref
(
elt
)
;
}
parentNode
:
function
(
node
)
{
const
parent
=
this
.
rawParentNode
(
node
)
;
if
(
parent
)
{
return
this
.
_ref
(
parent
)
;
}
return
null
;
}
rawParentNode
:
function
(
node
)
{
let
parent
;
try
{
const
walker
=
isDirectShadowHostChild
(
node
.
rawNode
)
?
this
.
getNonAnonymousWalker
(
node
.
rawNode
)
:
this
.
getDocumentWalker
(
node
.
rawNode
)
;
parent
=
walker
.
parentNode
(
)
;
}
catch
(
e
)
{
const
walker
=
this
.
getNonAnonymousWalker
(
node
.
rawNode
)
;
parent
=
walker
.
parentNode
(
)
;
}
return
parent
;
}
inlineTextChild
:
function
(
node
)
{
if
(
isBeforePseudoElement
(
node
.
rawNode
)
|
|
isAfterPseudoElement
(
node
.
rawNode
)
|
|
node
.
rawNode
.
nodeType
!
=
Node
.
ELEMENT_NODE
|
|
node
.
rawNode
.
children
.
length
>
0
)
{
return
undefined
;
}
const
walker
=
isDirectShadowHostChild
(
node
.
rawNode
)
?
this
.
getNonAnonymousWalker
(
node
.
rawNode
)
:
this
.
getDocumentWalker
(
node
.
rawNode
)
;
const
firstChild
=
walker
.
firstChild
(
)
;
if
(
!
firstChild
|
|
walker
.
nextSibling
(
)
|
|
firstChild
.
nodeType
!
=
=
Node
.
TEXT_NODE
|
|
firstChild
.
nodeValue
.
length
>
gValueSummaryLength
)
{
return
undefined
;
}
return
this
.
_ref
(
firstChild
)
;
}
retainNode
:
function
(
node
)
{
node
.
retained
=
true
;
}
unretainNode
:
function
(
node
)
{
node
.
retained
=
false
;
if
(
this
.
_retainedOrphans
.
has
(
node
)
)
{
this
.
_retainedOrphans
.
delete
(
node
)
;
this
.
releaseNode
(
node
)
;
}
}
releaseNode
:
function
(
node
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
if
(
node
.
retained
&
&
!
options
.
force
)
{
this
.
_retainedOrphans
.
add
(
node
)
;
return
;
}
if
(
node
.
retained
)
{
this
.
_retainedOrphans
.
delete
(
node
)
;
}
const
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
let
child
=
walker
.
firstChild
(
)
;
while
(
child
)
{
const
childActor
=
this
.
getNode
(
child
)
;
if
(
childActor
)
{
this
.
releaseNode
(
childActor
options
)
;
}
child
=
walker
.
nextSibling
(
)
;
}
node
.
destroy
(
)
;
}
ensurePathToRoot
:
function
(
node
newParents
=
new
Set
(
)
)
{
if
(
!
node
)
{
return
newParents
;
}
let
parent
=
this
.
rawParentNode
(
node
)
;
while
(
parent
)
{
let
parentActor
=
this
.
getNode
(
parent
)
;
if
(
parentActor
)
{
return
newParents
;
}
parentActor
=
this
.
_ref
(
parent
)
;
newParents
.
add
(
parentActor
)
;
parent
=
this
.
rawParentNode
(
parentActor
)
;
}
return
newParents
;
}
countChildren
:
function
(
node
options
=
{
}
)
{
return
this
.
_getChildren
(
node
options
)
.
nodes
.
length
;
}
children
:
function
(
node
options
=
{
}
)
{
const
{
hasFirst
hasLast
nodes
}
=
this
.
_getChildren
(
node
options
)
;
return
{
hasFirst
hasLast
nodes
:
nodes
.
map
(
n
=
>
this
.
_ref
(
n
)
)
}
;
}
_getChildren
:
function
(
node
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
{
hasFirst
:
true
hasLast
:
true
nodes
:
[
]
}
;
}
if
(
options
.
center
&
&
options
.
start
)
{
throw
Error
(
"
Can
'
t
specify
both
'
center
'
and
'
start
'
options
.
"
)
;
}
let
maxNodes
=
options
.
maxNodes
|
|
-
1
;
if
(
maxNodes
=
=
-
1
)
{
maxNodes
=
Number
.
MAX_VALUE
;
}
const
directShadowHostChild
=
isDirectShadowHostChild
(
node
.
rawNode
)
;
const
shadowHost
=
isShadowHost
(
node
.
rawNode
)
;
const
shadowRoot
=
isShadowRoot
(
node
.
rawNode
)
;
const
templateElement
=
isTemplateElement
(
node
.
rawNode
)
;
if
(
templateElement
)
{
const
documentFragment
=
node
.
rawNode
.
content
;
const
nodes
=
[
documentFragment
]
;
return
{
hasFirst
:
true
hasLast
:
true
nodes
}
;
}
let
isUnslottedHostChild
=
false
;
if
(
directShadowHostChild
)
{
try
{
this
.
getDocumentWalker
(
node
.
rawNode
options
.
whatToShow
SKIP_TO_SIBLING
)
;
}
catch
(
e
)
{
isUnslottedHostChild
=
true
;
}
}
const
getFilteredWalker
=
documentWalkerNode
=
>
{
const
{
whatToShow
}
=
options
;
const
skipTo
=
SKIP_TO_SIBLING
;
const
useNonAnonymousWalker
=
shadowRoot
|
|
shadowHost
|
|
isUnslottedHostChild
;
if
(
useNonAnonymousWalker
)
{
return
this
.
getNonAnonymousWalker
(
documentWalkerNode
whatToShow
skipTo
)
;
}
return
this
.
getDocumentWalker
(
documentWalkerNode
whatToShow
skipTo
)
;
}
;
const
rawNode
=
node
.
rawNode
;
const
firstChild
=
getFilteredWalker
(
rawNode
)
.
firstChild
(
)
;
const
lastChild
=
getFilteredWalker
(
rawNode
)
.
lastChild
(
)
;
if
(
!
firstChild
&
&
!
shadowHost
)
{
return
{
hasFirst
:
true
hasLast
:
true
nodes
:
[
]
}
;
}
let
nodes
=
[
]
;
if
(
firstChild
)
{
let
start
;
if
(
options
.
center
)
{
start
=
options
.
center
.
rawNode
;
}
else
if
(
options
.
start
)
{
start
=
options
.
start
.
rawNode
;
}
else
{
start
=
firstChild
;
}
if
(
isShadowRoot
(
start
)
)
{
start
=
firstChild
;
}
const
backwardWalker
=
getFilteredWalker
(
start
)
;
if
(
backwardWalker
.
currentNode
!
=
firstChild
&
&
options
.
center
)
{
backwardWalker
.
previousSibling
(
)
;
const
backwardCount
=
Math
.
floor
(
maxNodes
/
2
)
;
const
backwardNodes
=
this
.
_readBackward
(
backwardWalker
backwardCount
)
;
nodes
=
backwardNodes
;
}
const
forwardWalker
=
getFilteredWalker
(
start
)
;
const
forwardCount
=
maxNodes
-
nodes
.
length
;
nodes
=
nodes
.
concat
(
this
.
_readForward
(
forwardWalker
forwardCount
)
)
;
const
remaining
=
maxNodes
-
nodes
.
length
;
if
(
options
.
center
&
&
remaining
>
0
&
&
nodes
[
0
]
.
rawNode
!
=
firstChild
)
{
const
firstNodes
=
this
.
_readBackward
(
backwardWalker
remaining
)
;
nodes
=
firstNodes
.
concat
(
nodes
)
;
}
}
let
hasFirst
hasLast
;
if
(
nodes
.
length
>
0
)
{
hasFirst
=
nodes
[
0
]
=
=
firstChild
;
hasLast
=
nodes
[
nodes
.
length
-
1
]
=
=
lastChild
;
}
else
{
hasFirst
=
hasLast
=
true
;
}
if
(
shadowHost
)
{
const
firstChildWalker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
const
first
=
firstChildWalker
.
firstChild
(
)
;
const
hasBefore
=
first
&
&
first
.
nodeName
=
=
=
"
_moz_generated_content_before
"
;
const
lastChildWalker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
const
last
=
lastChildWalker
.
lastChild
(
)
;
const
hasAfter
=
last
&
&
last
.
nodeName
=
=
=
"
_moz_generated_content_after
"
;
nodes
=
[
node
.
rawNode
.
openOrClosedShadowRoot
.
.
.
(
hasBefore
?
[
first
]
:
[
]
)
.
.
.
nodes
.
.
.
(
hasAfter
?
[
last
]
:
[
]
)
]
;
}
return
{
hasFirst
hasLast
nodes
}
;
}
nextSibling
:
function
(
node
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
const
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
options
.
whatToShow
)
;
const
sibling
=
walker
.
nextSibling
(
)
;
return
sibling
?
this
.
_ref
(
sibling
)
:
null
;
}
previousSibling
:
function
(
node
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
const
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
options
.
whatToShow
)
;
const
sibling
=
walker
.
previousSibling
(
)
;
return
sibling
?
this
.
_ref
(
sibling
)
:
null
;
}
_readForward
:
function
(
walker
count
)
{
const
ret
=
[
]
;
let
node
=
walker
.
currentNode
;
do
{
if
(
!
walker
.
isSkippedNode
(
node
)
)
{
ret
.
push
(
node
)
;
}
node
=
walker
.
nextSibling
(
)
;
}
while
(
node
&
&
-
-
count
)
;
return
ret
;
}
_readBackward
:
function
(
walker
count
)
{
const
ret
=
[
]
;
let
node
=
walker
.
currentNode
;
do
{
if
(
!
walker
.
isSkippedNode
(
node
)
)
{
ret
.
push
(
node
)
;
}
node
=
walker
.
previousSibling
(
)
;
}
while
(
node
&
&
-
-
count
)
;
ret
.
reverse
(
)
;
return
ret
;
}
querySelector
:
function
(
baseNode
selector
)
{
if
(
isNodeDead
(
baseNode
)
)
{
return
{
}
;
}
const
node
=
baseNode
.
rawNode
.
querySelector
(
selector
)
;
if
(
!
node
)
{
return
{
}
;
}
return
this
.
attachElement
(
node
)
;
}
querySelectorAll
:
function
(
baseNode
selector
)
{
let
nodeList
=
null
;
try
{
nodeList
=
baseNode
.
rawNode
.
querySelectorAll
(
selector
)
;
}
catch
(
e
)
{
}
return
new
NodeListActor
(
this
nodeList
)
;
}
_multiFrameQuerySelectorAll
:
function
(
selector
)
{
let
nodes
=
[
]
;
for
(
const
{
document
}
of
this
.
targetActor
.
windows
)
{
try
{
nodes
=
[
.
.
.
nodes
.
.
.
document
.
querySelectorAll
(
selector
)
]
;
}
catch
(
e
)
{
}
}
return
nodes
;
}
multiFrameQuerySelectorAll
:
function
(
selector
)
{
return
new
NodeListActor
(
this
this
.
_multiFrameQuerySelectorAll
(
selector
)
)
;
}
search
:
function
(
query
)
{
const
results
=
this
.
walkerSearch
.
search
(
query
)
;
const
nodeList
=
new
NodeListActor
(
this
results
.
map
(
r
=
>
r
.
node
)
)
;
return
{
list
:
nodeList
metadata
:
[
]
}
;
}
getSuggestionsForQuery
:
function
(
query
completing
selectorState
)
{
const
sugs
=
{
classes
:
new
Map
(
)
tags
:
new
Map
(
)
ids
:
new
Map
(
)
}
;
let
result
=
[
]
;
let
nodes
=
null
;
switch
(
selectorState
)
{
case
"
pseudo
"
:
result
=
PSEUDO_SELECTORS
.
filter
(
item
=
>
{
return
item
[
0
]
.
startsWith
(
"
:
"
+
completing
)
;
}
)
;
break
;
case
"
class
"
:
if
(
!
query
)
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
"
[
class
]
"
)
;
}
else
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
query
)
;
}
for
(
const
node
of
nodes
)
{
for
(
const
className
of
node
.
classList
)
{
sugs
.
classes
.
set
(
className
(
sugs
.
classes
.
get
(
className
)
|
0
)
+
1
)
;
}
}
sugs
.
classes
.
delete
(
"
"
)
;
sugs
.
classes
.
delete
(
HIDDEN_CLASS
)
;
for
(
const
[
className
count
]
of
sugs
.
classes
)
{
if
(
className
.
startsWith
(
completing
)
)
{
result
.
push
(
[
"
.
"
+
CSS
.
escape
(
className
)
count
selectorState
]
)
;
}
}
break
;
case
"
id
"
:
if
(
!
query
)
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
"
[
id
]
"
)
;
}
else
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
query
)
;
}
for
(
const
node
of
nodes
)
{
sugs
.
ids
.
set
(
node
.
id
(
sugs
.
ids
.
get
(
node
.
id
)
|
0
)
+
1
)
;
}
for
(
const
[
id
count
]
of
sugs
.
ids
)
{
if
(
id
.
startsWith
(
completing
)
&
&
id
!
=
=
"
"
)
{
result
.
push
(
[
"
#
"
+
CSS
.
escape
(
id
)
count
selectorState
]
)
;
}
}
break
;
case
"
tag
"
:
if
(
!
query
)
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
"
*
"
)
;
}
else
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
query
)
;
}
for
(
const
node
of
nodes
)
{
const
tag
=
node
.
localName
;
sugs
.
tags
.
set
(
tag
(
sugs
.
tags
.
get
(
tag
)
|
0
)
+
1
)
;
}
for
(
const
[
tag
count
]
of
sugs
.
tags
)
{
if
(
(
new
RegExp
(
"
^
"
+
completing
+
"
.
*
"
"
i
"
)
)
.
test
(
tag
)
)
{
result
.
push
(
[
tag
count
selectorState
]
)
;
}
}
if
(
!
query
)
{
result
=
[
.
.
.
result
.
.
.
this
.
getSuggestionsForQuery
(
null
completing
"
class
"
)
.
suggestions
.
.
.
this
.
getSuggestionsForQuery
(
null
completing
"
id
"
)
.
suggestions
]
;
}
break
;
case
"
null
"
:
nodes
=
this
.
_multiFrameQuerySelectorAll
(
query
)
;
for
(
const
node
of
nodes
)
{
sugs
.
ids
.
set
(
node
.
id
(
sugs
.
ids
.
get
(
node
.
id
)
|
0
)
+
1
)
;
const
tag
=
node
.
localName
;
sugs
.
tags
.
set
(
tag
(
sugs
.
tags
.
get
(
tag
)
|
0
)
+
1
)
;
for
(
const
className
of
node
.
classList
)
{
sugs
.
classes
.
set
(
className
(
sugs
.
classes
.
get
(
className
)
|
0
)
+
1
)
;
}
}
for
(
const
[
tag
count
]
of
sugs
.
tags
)
{
tag
&
&
result
.
push
(
[
tag
count
]
)
;
}
for
(
const
[
id
count
]
of
sugs
.
ids
)
{
id
&
&
result
.
push
(
[
"
#
"
+
id
count
]
)
;
}
sugs
.
classes
.
delete
(
"
"
)
;
sugs
.
classes
.
delete
(
HIDDEN_CLASS
)
;
for
(
const
[
className
count
]
of
sugs
.
classes
)
{
className
&
&
result
.
push
(
[
"
.
"
+
className
count
]
)
;
}
}
result
=
result
.
sort
(
(
a
b
)
=
>
{
let
sortA
=
(
10000
-
a
[
1
]
)
+
a
[
0
]
;
let
sortB
=
(
10000
-
b
[
1
]
)
+
b
[
0
]
;
const
firstA
=
a
[
0
]
.
substring
(
0
1
)
;
const
firstB
=
b
[
0
]
.
substring
(
0
1
)
;
if
(
firstA
=
=
=
"
#
"
)
{
sortA
=
"
2
"
+
sortA
;
}
else
if
(
firstA
=
=
=
"
.
"
)
{
sortA
=
"
1
"
+
sortA
;
}
else
{
sortA
=
"
0
"
+
sortA
;
}
if
(
firstB
=
=
=
"
#
"
)
{
sortB
=
"
2
"
+
sortB
;
}
else
if
(
firstB
=
=
=
"
.
"
)
{
sortB
=
"
1
"
+
sortB
;
}
else
{
sortB
=
"
0
"
+
sortB
;
}
return
sortA
.
localeCompare
(
sortB
)
;
}
)
;
result
.
slice
(
0
25
)
;
return
{
query
:
query
suggestions
:
result
}
;
}
addPseudoClassLock
:
function
(
node
pseudo
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
for
(
const
locked
of
this
.
_activePseudoClassLocks
)
{
if
(
InspectorUtils
.
hasPseudoClassLock
(
locked
.
rawNode
pseudo
)
)
{
this
.
_removePseudoClassLock
(
locked
pseudo
)
;
}
}
const
enabled
=
options
.
enabled
=
=
=
undefined
|
|
options
.
enabled
;
this
.
_addPseudoClassLock
(
node
pseudo
enabled
)
;
if
(
!
options
.
parents
)
{
return
;
}
const
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
let
cur
;
while
(
(
cur
=
walker
.
parentNode
(
)
)
)
{
const
curNode
=
this
.
_ref
(
cur
)
;
this
.
_addPseudoClassLock
(
curNode
pseudo
enabled
)
;
}
}
_queuePseudoClassMutation
:
function
(
node
)
{
this
.
queueMutation
(
{
target
:
node
.
actorID
type
:
"
pseudoClassLock
"
pseudoClassLocks
:
node
.
writePseudoClassLocks
(
)
}
)
;
}
_addPseudoClassLock
:
function
(
node
pseudo
enabled
)
{
if
(
node
.
rawNode
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
return
false
;
}
InspectorUtils
.
addPseudoClassLock
(
node
.
rawNode
pseudo
enabled
)
;
this
.
_activePseudoClassLocks
.
add
(
node
)
;
this
.
_queuePseudoClassMutation
(
node
)
;
return
true
;
}
hideNode
:
function
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
loadSheet
(
node
.
rawNode
.
ownerGlobal
HELPER_SHEET
)
;
node
.
rawNode
.
classList
.
add
(
HIDDEN_CLASS
)
;
}
unhideNode
:
function
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
node
.
rawNode
.
classList
.
remove
(
HIDDEN_CLASS
)
;
}
removePseudoClassLock
:
function
(
node
pseudo
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
this
.
_removePseudoClassLock
(
node
pseudo
)
;
for
(
const
locked
of
this
.
_activePseudoClassLocks
)
{
if
(
node
.
rawNode
.
contains
(
locked
.
rawNode
)
&
&
InspectorUtils
.
hasPseudoClassLock
(
locked
.
rawNode
pseudo
)
)
{
this
.
_removePseudoClassLock
(
locked
pseudo
)
;
}
}
if
(
!
options
.
parents
)
{
return
;
}
const
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
let
cur
;
while
(
(
cur
=
walker
.
parentNode
(
)
)
)
{
const
curNode
=
this
.
_ref
(
cur
)
;
this
.
_removePseudoClassLock
(
curNode
pseudo
)
;
}
}
_removePseudoClassLock
:
function
(
node
pseudo
)
{
if
(
node
.
rawNode
.
nodeType
!
=
Node
.
ELEMENT_NODE
)
{
return
false
;
}
InspectorUtils
.
removePseudoClassLock
(
node
.
rawNode
pseudo
)
;
if
(
!
node
.
writePseudoClassLocks
(
)
)
{
this
.
_activePseudoClassLocks
.
delete
(
node
)
;
}
this
.
_queuePseudoClassMutation
(
node
)
;
return
true
;
}
clearPseudoClassLocks
:
function
(
node
)
{
if
(
node
&
&
isNodeDead
(
node
)
)
{
return
;
}
if
(
node
)
{
InspectorUtils
.
clearPseudoClassLocks
(
node
.
rawNode
)
;
this
.
_activePseudoClassLocks
.
delete
(
node
)
;
this
.
_queuePseudoClassMutation
(
node
)
;
}
else
{
for
(
const
locked
of
this
.
_activePseudoClassLocks
)
{
InspectorUtils
.
clearPseudoClassLocks
(
locked
.
rawNode
)
;
this
.
_activePseudoClassLocks
.
delete
(
locked
)
;
this
.
_queuePseudoClassMutation
(
locked
)
;
}
}
}
innerHTML
:
function
(
node
)
{
let
html
=
"
"
;
if
(
!
isNodeDead
(
node
)
)
{
html
=
node
.
rawNode
.
innerHTML
;
}
return
LongStringActor
(
this
.
conn
html
)
;
}
setInnerHTML
:
function
(
node
value
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
const
rawNode
=
node
.
rawNode
;
if
(
rawNode
.
nodeType
!
=
=
rawNode
.
ownerDocument
.
ELEMENT_NODE
)
{
throw
new
Error
(
"
Can
only
change
innerHTML
to
element
nodes
"
)
;
}
rawNode
.
innerHTML
=
value
;
}
outerHTML
:
function
(
node
)
{
let
outerHTML
=
"
"
;
if
(
!
isNodeDead
(
node
)
)
{
outerHTML
=
node
.
rawNode
.
outerHTML
;
}
return
LongStringActor
(
this
.
conn
outerHTML
)
;
}
setOuterHTML
:
function
(
node
value
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
const
parsedDOM
=
new
DOMParser
(
)
.
parseFromString
(
value
"
text
/
html
"
)
;
const
rawNode
=
node
.
rawNode
;
const
parentNode
=
rawNode
.
parentNode
;
if
(
rawNode
.
tagName
=
=
=
"
BODY
"
)
{
if
(
parsedDOM
.
head
.
innerHTML
=
=
=
"
"
)
{
parentNode
.
replaceChild
(
parsedDOM
.
body
rawNode
)
;
}
else
{
rawNode
.
outerHTML
=
value
;
}
}
else
if
(
rawNode
.
tagName
=
=
=
"
HEAD
"
)
{
if
(
parsedDOM
.
body
.
innerHTML
=
=
=
"
"
)
{
parentNode
.
replaceChild
(
parsedDOM
.
head
rawNode
)
;
}
else
{
rawNode
.
outerHTML
=
value
;
}
}
else
if
(
node
.
isDocumentElement
(
)
)
{
const
finalAttributeModifications
=
[
]
;
const
attributeModifications
=
{
}
;
for
(
const
attribute
of
rawNode
.
attributes
)
{
attributeModifications
[
attribute
.
name
]
=
null
;
}
for
(
const
attribute
of
parsedDOM
.
documentElement
.
attributes
)
{
attributeModifications
[
attribute
.
name
]
=
attribute
.
value
;
}
for
(
const
key
in
attributeModifications
)
{
finalAttributeModifications
.
push
(
{
attributeName
:
key
newValue
:
attributeModifications
[
key
]
}
)
;
}
node
.
modifyAttributes
(
finalAttributeModifications
)
;
rawNode
.
replaceChild
(
parsedDOM
.
head
rawNode
.
querySelector
(
"
head
"
)
)
;
rawNode
.
replaceChild
(
parsedDOM
.
body
rawNode
.
querySelector
(
"
body
"
)
)
;
}
else
{
rawNode
.
outerHTML
=
value
;
}
}
insertAdjacentHTML
:
function
(
node
position
value
)
{
if
(
isNodeDead
(
node
)
)
{
return
{
node
:
[
]
newParents
:
[
]
}
;
}
const
rawNode
=
node
.
rawNode
;
const
isInsertAsSibling
=
position
=
=
=
"
beforeBegin
"
|
|
position
=
=
=
"
afterEnd
"
;
if
(
isInsertAsSibling
&
&
node
.
isDocumentElement
(
)
)
{
throw
new
Error
(
"
Can
'
t
insert
adjacent
element
to
the
root
.
"
)
;
}
const
rawParentNode
=
rawNode
.
parentNode
;
if
(
!
rawParentNode
&
&
isInsertAsSibling
)
{
throw
new
Error
(
"
Can
'
t
insert
as
sibling
without
parent
node
.
"
)
;
}
const
range
=
rawNode
.
ownerDocument
.
createRange
(
)
;
if
(
position
=
=
=
"
beforeBegin
"
|
|
position
=
=
=
"
afterEnd
"
)
{
range
.
selectNode
(
rawNode
)
;
}
else
{
range
.
selectNodeContents
(
rawNode
)
;
}
const
docFrag
=
range
.
createContextualFragment
(
value
)
;
const
newRawNodes
=
Array
.
from
(
docFrag
.
childNodes
)
;
switch
(
position
)
{
case
"
beforeBegin
"
:
rawParentNode
.
insertBefore
(
docFrag
rawNode
)
;
break
;
case
"
afterEnd
"
:
rawParentNode
.
insertBefore
(
docFrag
rawNode
.
nextSibling
)
;
break
;
case
"
afterBegin
"
:
rawNode
.
insertBefore
(
docFrag
rawNode
.
firstChild
)
;
break
;
case
"
beforeEnd
"
:
rawNode
.
appendChild
(
docFrag
)
;
break
;
default
:
throw
new
Error
(
"
Invalid
position
value
.
Must
be
either
"
+
"
'
beforeBegin
'
'
beforeEnd
'
'
afterBegin
'
or
'
afterEnd
'
.
"
)
;
}
return
this
.
attachElements
(
newRawNodes
)
;
}
duplicateNode
:
function
(
{
rawNode
}
)
{
const
clonedNode
=
rawNode
.
cloneNode
(
true
)
;
rawNode
.
parentNode
.
insertBefore
(
clonedNode
rawNode
.
nextSibling
)
;
}
isDocumentOrDocumentElementNode
:
function
(
node
)
{
return
(
(
node
.
rawNode
.
ownerDocument
&
&
node
.
rawNode
.
ownerDocument
.
documentElement
=
=
=
this
.
rawNode
)
|
|
node
.
rawNode
.
nodeType
=
=
=
Node
.
DOCUMENT_NODE
)
;
}
removeNode
:
function
(
node
)
{
if
(
isNodeDead
(
node
)
|
|
this
.
isDocumentOrDocumentElementNode
(
node
)
)
{
throw
Error
(
"
Cannot
remove
document
document
elements
or
dead
nodes
.
"
)
;
}
const
nextSibling
=
this
.
nextSibling
(
node
)
;
node
.
rawNode
.
remove
(
)
;
return
nextSibling
;
}
removeNodes
:
function
(
nodes
)
{
for
(
const
node
of
nodes
)
{
if
(
isNodeDead
(
node
)
|
|
this
.
isDocumentOrDocumentElementNode
(
node
)
)
{
throw
Error
(
"
Cannot
remove
document
document
elements
or
dead
nodes
"
)
;
}
}
for
(
const
node
of
nodes
)
{
node
.
rawNode
.
remove
(
)
;
}
}
insertBefore
:
function
(
node
parent
sibling
)
{
if
(
isNodeDead
(
node
)
|
|
isNodeDead
(
parent
)
|
|
(
sibling
&
&
isNodeDead
(
sibling
)
)
)
{
return
;
}
const
rawNode
=
node
.
rawNode
;
const
rawParent
=
parent
.
rawNode
;
const
rawSibling
=
sibling
?
sibling
.
rawNode
:
null
;
if
(
rawNode
.
parentNode
=
=
=
rawParent
)
{
let
currentNextSibling
=
this
.
nextSibling
(
node
)
;
currentNextSibling
=
currentNextSibling
?
currentNextSibling
.
rawNode
:
null
;
if
(
rawNode
=
=
=
rawSibling
|
|
currentNextSibling
=
=
=
rawSibling
)
{
return
;
}
}
rawParent
.
insertBefore
(
rawNode
rawSibling
)
;
}
editTagName
:
function
(
node
tagName
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
const
oldNode
=
node
.
rawNode
;
let
newNode
;
try
{
newNode
=
nodeDocument
(
oldNode
)
.
createElement
(
tagName
)
;
}
catch
(
x
)
{
return
Promise
.
reject
(
new
Error
(
"
Could
not
change
node
'
s
tagName
to
"
+
tagName
)
)
;
}
const
attrs
=
oldNode
.
attributes
;
for
(
let
i
=
0
;
i
<
attrs
.
length
;
i
+
+
)
{
newNode
.
setAttribute
(
attrs
[
i
]
.
name
attrs
[
i
]
.
value
)
;
}
oldNode
.
parentNode
.
insertBefore
(
newNode
oldNode
)
;
while
(
oldNode
.
firstChild
)
{
newNode
.
appendChild
(
oldNode
.
firstChild
)
;
}
oldNode
.
remove
(
)
;
return
null
;
}
getMutations
:
function
(
options
=
{
}
)
{
const
pending
=
this
.
_pendingMutations
|
|
[
]
;
this
.
_pendingMutations
=
[
]
;
this
.
_waitingForGetMutations
=
false
;
if
(
options
.
cleanup
)
{
for
(
const
node
of
this
.
_orphaned
)
{
this
.
releaseNode
(
node
)
;
}
this
.
_orphaned
=
new
Set
(
)
;
}
return
pending
;
}
queueMutation
:
function
(
mutation
)
{
if
(
!
this
.
actorID
|
|
this
.
_destroyed
)
{
return
;
}
this
.
_pendingMutations
.
push
(
mutation
)
;
if
(
this
.
_waitingForGetMutations
)
{
return
;
}
if
(
IMMEDIATE_MUTATIONS
.
includes
(
mutation
.
type
)
)
{
this
.
_emitNewMutations
(
)
;
}
else
{
this
.
_throttledEmitNewMutations
(
)
;
}
}
_emitNewMutations
:
function
(
)
{
if
(
!
this
.
actorID
|
|
this
.
_destroyed
)
{
return
;
}
if
(
this
.
_waitingForGetMutations
|
|
this
.
_pendingMutations
.
length
=
=
0
)
{
return
;
}
this
.
_waitingForGetMutations
=
true
;
this
.
emit
(
"
new
-
mutations
"
)
;
}
onMutations
:
function
(
mutations
)
{
this
.
emit
(
"
any
-
mutation
"
)
;
for
(
const
change
of
mutations
)
{
const
targetActor
=
this
.
getNode
(
change
.
target
)
;
if
(
!
targetActor
)
{
continue
;
}
const
targetNode
=
change
.
target
;
const
type
=
change
.
type
;
const
mutation
=
{
type
:
type
target
:
targetActor
.
actorID
}
;
if
(
type
=
=
=
"
attributes
"
)
{
mutation
.
attributeName
=
change
.
attributeName
;
mutation
.
attributeNamespace
=
change
.
attributeNamespace
|
|
undefined
;
mutation
.
newValue
=
targetNode
.
hasAttribute
(
mutation
.
attributeName
)
?
targetNode
.
getAttribute
(
mutation
.
attributeName
)
:
null
;
}
else
if
(
type
=
=
=
"
characterData
"
)
{
mutation
.
newValue
=
targetNode
.
nodeValue
;
this
.
_maybeQueueInlineTextChildMutation
(
change
targetNode
)
;
}
else
if
(
type
=
=
=
"
childList
"
|
|
type
=
=
=
"
nativeAnonymousChildList
"
)
{
const
removedActors
=
[
]
;
const
addedActors
=
[
]
;
for
(
const
removed
of
change
.
removedNodes
)
{
const
removedActor
=
this
.
getNode
(
removed
)
;
if
(
!
removedActor
)
{
continue
;
}
this
.
_orphaned
.
add
(
removedActor
)
;
removedActors
.
push
(
removedActor
.
actorID
)
;
}
for
(
const
added
of
change
.
addedNodes
)
{
const
addedActor
=
this
.
getNode
(
added
)
;
if
(
!
addedActor
)
{
continue
;
}
this
.
_orphaned
.
delete
(
addedActor
)
;
addedActors
.
push
(
addedActor
.
actorID
)
;
}
mutation
.
numChildren
=
targetActor
.
numChildren
;
mutation
.
removed
=
removedActors
;
mutation
.
added
=
addedActors
;
const
inlineTextChild
=
this
.
inlineTextChild
(
targetActor
)
;
if
(
inlineTextChild
)
{
mutation
.
inlineTextChild
=
inlineTextChild
.
form
(
)
;
}
}
this
.
queueMutation
(
mutation
)
;
}
}
_maybeQueueInlineTextChildMutation
:
function
(
mutation
)
{
const
{
oldValue
target
}
=
mutation
;
const
newValue
=
target
.
nodeValue
;
const
limit
=
gValueSummaryLength
;
if
(
(
oldValue
.
length
<
=
limit
&
&
newValue
.
length
<
=
limit
)
|
|
(
oldValue
.
length
>
limit
&
&
newValue
.
length
>
limit
)
)
{
return
;
}
const
parentActor
=
this
.
getNode
(
target
.
parentNode
)
;
if
(
!
parentActor
|
|
parentActor
.
rawNode
.
children
.
length
>
0
)
{
return
;
}
const
inlineTextChild
=
this
.
inlineTextChild
(
parentActor
)
;
this
.
queueMutation
(
{
type
:
"
inlineTextChild
"
target
:
parentActor
.
actorID
inlineTextChild
:
inlineTextChild
?
inlineTextChild
.
form
(
)
:
undefined
}
)
;
}
onSlotchange
:
function
(
event
)
{
const
target
=
event
.
target
;
const
targetActor
=
this
.
getNode
(
target
)
;
if
(
!
targetActor
)
{
return
;
}
this
.
queueMutation
(
{
type
:
"
slotchange
"
target
:
targetActor
.
actorID
}
)
;
}
onShadowrootattached
:
function
(
event
)
{
const
actor
=
this
.
getNode
(
event
.
target
)
;
if
(
!
actor
)
{
return
;
}
const
mutation
=
{
type
:
"
shadowRootAttached
"
target
:
actor
.
actorID
}
;
this
.
queueMutation
(
mutation
)
;
}
onFrameLoad
:
function
(
{
window
isTopLevel
}
)
{
const
{
readyState
}
=
window
.
document
;
if
(
readyState
!
=
"
interactive
"
&
&
readyState
!
=
"
complete
"
)
{
window
.
addEventListener
(
"
DOMContentLoaded
"
this
.
onFrameLoad
.
bind
(
this
{
window
isTopLevel
}
)
{
once
:
true
}
)
;
return
;
}
if
(
isTopLevel
)
{
if
(
this
.
rootDoc
&
&
!
Cu
.
isDeadWrapper
(
this
.
rootDoc
)
&
&
this
.
rootDoc
.
defaultView
)
{
this
.
onFrameUnload
(
{
window
:
this
.
rootDoc
.
defaultView
}
)
;
}
this
.
rootWin
=
window
;
this
.
rootDoc
=
window
.
document
;
this
.
rootNode
=
this
.
document
(
)
;
this
.
queueMutation
(
{
type
:
"
newRoot
"
target
:
this
.
rootNode
.
form
(
)
}
)
;
return
;
}
const
frame
=
getFrameElement
(
window
)
;
const
frameActor
=
this
.
getNode
(
frame
)
;
if
(
!
frameActor
)
{
return
;
}
this
.
queueMutation
(
{
type
:
"
frameLoad
"
target
:
frameActor
.
actorID
}
)
;
this
.
queueMutation
(
{
type
:
"
childList
"
target
:
frameActor
.
actorID
added
:
[
]
removed
:
[
]
}
)
;
}
_childOfWindow
:
function
(
window
domNode
)
{
let
win
=
nodeDocument
(
domNode
)
.
defaultView
;
while
(
win
)
{
if
(
win
=
=
=
window
)
{
return
true
;
}
win
=
getFrameElement
(
win
)
;
}
return
false
;
}
onFrameUnload
:
function
(
{
window
}
)
{
const
releasedOrphans
=
[
]
;
for
(
const
retained
of
this
.
_retainedOrphans
)
{
if
(
Cu
.
isDeadWrapper
(
retained
.
rawNode
)
|
|
this
.
_childOfWindow
(
window
retained
.
rawNode
)
)
{
this
.
_retainedOrphans
.
delete
(
retained
)
;
releasedOrphans
.
push
(
retained
.
actorID
)
;
this
.
releaseNode
(
retained
{
force
:
true
}
)
;
}
}
if
(
releasedOrphans
.
length
>
0
)
{
this
.
queueMutation
(
{
target
:
this
.
rootNode
.
actorID
type
:
"
unretained
"
nodes
:
releasedOrphans
}
)
;
}
const
doc
=
window
.
document
;
const
documentActor
=
this
.
getNode
(
doc
)
;
if
(
!
documentActor
)
{
return
;
}
if
(
this
.
rootDoc
=
=
=
doc
)
{
this
.
rootDoc
=
null
;
this
.
rootNode
=
null
;
}
this
.
queueMutation
(
{
type
:
"
documentUnload
"
target
:
documentActor
.
actorID
}
)
;
const
walker
=
this
.
getDocumentWalker
(
doc
)
;
const
parentNode
=
walker
.
parentNode
(
)
;
if
(
parentNode
)
{
this
.
queueMutation
(
{
type
:
"
childList
"
target
:
this
.
getNode
(
parentNode
)
.
actorID
added
:
[
]
removed
:
[
]
}
)
;
}
this
.
releaseNode
(
documentActor
{
force
:
true
}
)
;
}
_isInDOMTree
:
function
(
rawNode
)
{
const
walker
=
this
.
getDocumentWalker
(
rawNode
)
;
let
current
=
walker
.
currentNode
;
while
(
walker
.
parentNode
(
)
)
{
current
=
walker
.
currentNode
;
}
if
(
current
.
nodeType
=
=
=
Node
.
DOCUMENT_FRAGMENT_NODE
|
|
current
!
=
=
this
.
rootDoc
)
{
return
false
;
}
return
true
;
}
isInDOMTree
:
function
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
false
;
}
return
this
.
_isInDOMTree
(
node
.
rawNode
)
;
}
getNodeActorFromObjectActor
:
function
(
objectActorID
)
{
const
actor
=
this
.
conn
.
getActor
(
objectActorID
)
;
if
(
!
actor
)
{
return
null
;
}
const
debuggerObject
=
this
.
conn
.
getActor
(
objectActorID
)
.
obj
;
let
rawNode
=
debuggerObject
.
unsafeDereference
(
)
;
if
(
!
this
.
_isInDOMTree
(
rawNode
)
)
{
return
null
;
}
if
(
rawNode
.
defaultView
&
&
rawNode
=
=
=
rawNode
.
defaultView
.
document
)
{
rawNode
=
rawNode
.
documentElement
;
}
return
this
.
attachElement
(
rawNode
)
;
}
getNodeActorFromWindowID
:
function
(
windowID
)
{
let
win
;
try
{
win
=
Services
.
wm
.
getOuterWindowWithId
(
windowID
)
;
}
catch
(
e
)
{
}
if
(
!
win
)
{
return
{
error
:
"
noWindow
"
message
:
"
The
related
docshell
is
destroyed
or
not
found
"
}
;
}
else
if
(
!
win
.
frameElement
)
{
return
this
.
attachElement
(
win
.
document
.
body
|
|
win
.
document
.
documentElement
)
;
}
return
this
.
attachElement
(
win
.
frameElement
)
;
}
getStyleSheetOwnerNode
:
function
(
styleSheetActorID
)
{
return
this
.
getNodeFromActor
(
styleSheetActorID
[
"
ownerNode
"
]
)
;
}
getNodeFromActor
:
function
(
actorID
path
)
{
const
actor
=
this
.
conn
.
getActor
(
actorID
)
;
if
(
!
actor
)
{
return
null
;
}
let
obj
=
actor
;
for
(
const
name
of
path
)
{
if
(
!
(
name
in
obj
)
)
{
return
null
;
}
obj
=
obj
[
name
]
;
}
return
this
.
attachElement
(
obj
)
;
}
getLayoutInspector
:
function
(
)
{
if
(
!
this
.
layoutActor
)
{
this
.
layoutActor
=
new
LayoutActor
(
this
.
conn
this
.
targetActor
this
)
;
}
return
this
.
layoutActor
;
}
getOffsetParent
:
function
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
const
offsetParent
=
node
.
rawNode
.
offsetParent
;
if
(
!
offsetParent
)
{
return
null
;
}
return
this
.
_ref
(
offsetParent
)
;
}
hasAccessibilityProperties
:
async
function
(
node
)
{
if
(
isNodeDead
(
node
)
|
|
!
Services
.
appinfo
.
accessibilityEnabled
)
{
return
false
;
}
const
accService
=
Cc
[
"
mozilla
.
org
/
accessibilityService
;
1
"
]
.
getService
(
Ci
.
nsIAccessibilityService
)
;
let
acc
=
accService
.
getAccessibleFor
(
node
.
rawNode
)
;
if
(
!
acc
|
|
acc
.
indexInParent
<
0
)
{
const
inlineTextChild
=
this
.
inlineTextChild
(
node
)
;
if
(
inlineTextChild
)
{
acc
=
accService
.
getAccessibleFor
(
inlineTextChild
.
rawNode
)
;
}
}
return
acc
&
&
acc
.
indexInParent
>
-
1
;
}
}
)
;
exports
.
WalkerActor
=
WalkerActor
;
