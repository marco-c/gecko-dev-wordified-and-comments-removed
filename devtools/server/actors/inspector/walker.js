"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
walkerSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
walker
.
js
"
)
;
const
{
LongStringActor
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
string
.
js
"
)
;
const
{
EXCLUDED_LISTENER
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
inspector
/
constants
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
nodeFilterConstants
"
"
resource
:
/
/
devtools
/
shared
/
dom
-
node
-
filter
-
constants
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
getFrameElement
"
"
isAfterPseudoElement
"
"
isBeforePseudoElement
"
"
isDirectShadowHostChild
"
"
isMarkerPseudoElement
"
"
isFrameBlockedByCSP
"
"
isFrameWithChildTarget
"
"
isShadowHost
"
"
isShadowRoot
"
"
loadSheet
"
]
"
resource
:
/
/
devtools
/
shared
/
layout
/
utils
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
throttle
"
"
resource
:
/
/
devtools
/
shared
/
throttle
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
allAnonymousContentTreeWalkerFilter
"
"
findGridParentContainerForNode
"
"
isNodeDead
"
"
noAnonymousContentTreeWalkerFilter
"
"
nodeDocument
"
"
standardTreeWalkerFilter
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
inspector
/
utils
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CustomElementWatcher
"
"
resource
:
/
/
devtools
/
server
/
actors
/
inspector
/
custom
-
element
-
watcher
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
DocumentWalker
"
"
SKIP_TO_SIBLING
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
inspector
/
document
-
walker
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
NodeActor
"
"
NodeListActor
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
inspector
/
node
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NodePicker
"
"
resource
:
/
/
devtools
/
server
/
actors
/
inspector
/
node
-
picker
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
LayoutActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
layout
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
getLayoutChangesObserver
"
"
releaseLayoutChangesObserver
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
reflow
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WalkerSearch
"
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
walker
-
search
.
js
"
true
)
;
const
lazy
=
{
}
;
if
(
!
isWorker
)
{
loader
.
lazyGetter
(
lazy
"
ContentDOMReference
"
(
)
=
>
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ContentDOMReference
.
sys
.
mjs
"
{
global
:
"
shared
"
}
)
.
ContentDOMReference
)
;
}
loader
.
lazyServiceGetter
(
this
"
eventListenerService
"
"
mozilla
.
org
/
eventlistenerservice
;
1
"
"
nsIEventListenerService
"
)
;
const
MUTATIONS_THROTTLING_DELAY
=
100
;
const
IMMEDIATE_MUTATIONS
=
[
"
pseudoClassLock
"
]
;
const
HIDDEN_CLASS
=
"
__fx
-
devtools
-
hide
-
shortcut__
"
;
const
PSEUDO_SELECTORS
=
[
[
"
:
active
"
1
]
[
"
:
hover
"
1
]
[
"
:
focus
"
1
]
[
"
:
visited
"
0
]
[
"
:
link
"
0
]
[
"
:
first
-
letter
"
0
]
[
"
:
first
-
child
"
2
]
[
"
:
before
"
2
]
[
"
:
after
"
2
]
[
"
:
lang
(
"
0
]
[
"
:
not
(
"
3
]
[
"
:
first
-
of
-
type
"
0
]
[
"
:
last
-
of
-
type
"
0
]
[
"
:
only
-
of
-
type
"
0
]
[
"
:
only
-
child
"
2
]
[
"
:
nth
-
child
(
"
3
]
[
"
:
nth
-
last
-
child
(
"
0
]
[
"
:
nth
-
of
-
type
(
"
0
]
[
"
:
nth
-
last
-
of
-
type
(
"
0
]
[
"
:
last
-
child
"
2
]
[
"
:
root
"
0
]
[
"
:
empty
"
0
]
[
"
:
target
"
0
]
[
"
:
enabled
"
0
]
[
"
:
disabled
"
0
]
[
"
:
checked
"
1
]
[
"
:
:
selection
"
0
]
[
"
:
:
marker
"
0
]
]
;
const
HELPER_SHEET
=
"
data
:
text
/
css
;
charset
=
utf
-
8
"
+
encodeURIComponent
(
.
__fx
-
devtools
-
hide
-
shortcut__
{
visibility
:
hidden
!
important
;
}
)
;
exports
.
DEFAULT_VALUE_SUMMARY_LENGTH
=
50
;
var
gValueSummaryLength
=
exports
.
DEFAULT_VALUE_SUMMARY_LENGTH
;
exports
.
getValueSummaryLength
=
function
(
)
{
return
gValueSummaryLength
;
}
;
exports
.
setValueSummaryLength
=
function
(
val
)
{
gValueSummaryLength
=
val
;
}
;
class
WalkerActor
extends
Actor
{
constructor
(
conn
targetActor
options
)
{
super
(
conn
walkerSpec
)
;
this
.
targetActor
=
targetActor
;
this
.
rootWin
=
targetActor
.
window
;
this
.
rootDoc
=
this
.
rootWin
.
document
;
this
.
_nodeActorsMap
=
new
Map
(
)
;
this
.
_pendingMutations
=
[
]
;
this
.
_activePseudoClassLocks
=
new
Set
(
)
;
this
.
_mutationBreakpoints
=
new
WeakMap
(
)
;
this
.
_anonParents
=
new
WeakMap
(
)
;
this
.
customElementWatcher
=
new
CustomElementWatcher
(
targetActor
.
chromeEventHandler
)
;
this
.
overflowCausingElementsMap
=
new
Map
(
)
;
this
.
showAllAnonymousContent
=
options
.
showAllAnonymousContent
;
this
.
walkerSearch
=
new
WalkerSearch
(
this
)
;
this
.
_orphaned
=
new
Set
(
)
;
this
.
_retainedOrphans
=
new
Set
(
)
;
this
.
onSubtreeModified
=
this
.
onSubtreeModified
.
bind
(
this
)
;
this
.
onSubtreeModified
[
EXCLUDED_LISTENER
]
=
true
;
this
.
onNodeRemoved
=
this
.
onNodeRemoved
.
bind
(
this
)
;
this
.
onNodeRemoved
[
EXCLUDED_LISTENER
]
=
true
;
this
.
onAttributeModified
=
this
.
onAttributeModified
.
bind
(
this
)
;
this
.
onAttributeModified
[
EXCLUDED_LISTENER
]
=
true
;
this
.
onMutations
=
this
.
onMutations
.
bind
(
this
)
;
this
.
onSlotchange
=
this
.
onSlotchange
.
bind
(
this
)
;
this
.
onShadowrootattached
=
this
.
onShadowrootattached
.
bind
(
this
)
;
this
.
onAnonymousrootcreated
=
this
.
onAnonymousrootcreated
.
bind
(
this
)
;
this
.
onAnonymousrootremoved
=
this
.
onAnonymousrootremoved
.
bind
(
this
)
;
this
.
onFrameLoad
=
this
.
onFrameLoad
.
bind
(
this
)
;
this
.
onFrameUnload
=
this
.
onFrameUnload
.
bind
(
this
)
;
this
.
onCustomElementDefined
=
this
.
onCustomElementDefined
.
bind
(
this
)
;
this
.
_throttledEmitNewMutations
=
throttle
(
this
.
_emitNewMutations
.
bind
(
this
)
MUTATIONS_THROTTLING_DELAY
)
;
targetActor
.
on
(
"
will
-
navigate
"
this
.
onFrameUnload
)
;
targetActor
.
on
(
"
window
-
ready
"
this
.
onFrameLoad
)
;
this
.
customElementWatcher
.
on
(
"
element
-
defined
"
this
.
onCustomElementDefined
)
;
this
.
chromeEventHandler
=
targetActor
.
chromeEventHandler
;
this
.
chromeEventHandler
.
addEventListener
(
"
shadowrootattached
"
this
.
onShadowrootattached
)
;
this
.
chromeEventHandler
.
addEventListener
(
"
anonymousrootcreated
"
this
.
onAnonymousrootcreated
)
;
this
.
chromeEventHandler
.
addEventListener
(
"
anonymousrootremoved
"
this
.
onAnonymousrootremoved
)
;
for
(
const
{
document
}
of
this
.
targetActor
.
windows
)
{
document
.
devToolsAnonymousAndShadowEventsEnabled
=
true
;
}
this
.
rootNode
=
this
.
document
(
)
;
this
.
layoutChangeObserver
=
getLayoutChangesObserver
(
this
.
targetActor
)
;
this
.
_onReflows
=
this
.
_onReflows
.
bind
(
this
)
;
this
.
layoutChangeObserver
.
on
(
"
reflows
"
this
.
_onReflows
)
;
this
.
_onResize
=
this
.
_onResize
.
bind
(
this
)
;
this
.
layoutChangeObserver
.
on
(
"
resize
"
this
.
_onResize
)
;
this
.
_onEventListenerChange
=
this
.
_onEventListenerChange
.
bind
(
this
)
;
eventListenerService
.
addListenerChangeListener
(
this
.
_onEventListenerChange
)
;
}
get
nodePicker
(
)
{
if
(
!
this
.
_nodePicker
)
{
this
.
_nodePicker
=
new
NodePicker
(
this
this
.
targetActor
)
;
}
return
this
.
_nodePicker
;
}
watchRootNode
(
)
{
if
(
this
.
rootNode
)
{
this
.
emit
(
"
root
-
available
"
this
.
rootNode
)
;
}
}
_onEventListenerChange
(
changesEnum
)
{
for
(
const
current
of
changesEnum
.
enumerate
(
Ci
.
nsIEventListenerChange
)
)
{
const
target
=
current
.
target
;
if
(
this
.
_nodeActorsMap
.
has
(
target
)
)
{
const
actor
=
this
.
getNode
(
target
)
;
const
mutation
=
{
type
:
"
events
"
target
:
actor
.
actorID
hasEventListeners
:
actor
.
_hasEventListeners
}
;
this
.
queueMutation
(
mutation
)
;
}
}
}
form
(
)
{
return
{
actor
:
this
.
actorID
root
:
this
.
rootNode
.
form
(
)
traits
:
{
hasGetIdrefNode
:
true
}
}
;
}
toString
(
)
{
return
"
[
WalkerActor
"
+
this
.
actorID
+
"
]
"
;
}
getDocumentWalker
(
node
skipTo
)
{
const
filter
=
this
.
showAllAnonymousContent
?
allAnonymousContentTreeWalkerFilter
:
standardTreeWalkerFilter
;
return
new
DocumentWalker
(
node
this
.
rootWin
{
filter
skipTo
showAnonymousContent
:
true
}
)
;
}
destroy
(
)
{
if
(
this
.
_destroyed
)
{
return
;
}
this
.
_destroyed
=
true
;
super
.
destroy
(
)
;
try
{
this
.
clearPseudoClassLocks
(
)
;
this
.
_activePseudoClassLocks
=
null
;
this
.
overflowCausingElementsMap
.
clear
(
)
;
this
.
overflowCausingElementsMap
=
null
;
this
.
_hoveredNode
=
null
;
this
.
rootWin
=
null
;
this
.
rootDoc
=
null
;
this
.
rootNode
=
null
;
this
.
layoutHelpers
=
null
;
this
.
_orphaned
=
null
;
this
.
_retainedOrphans
=
null
;
this
.
_nodeActorsMap
=
null
;
this
.
targetActor
.
off
(
"
will
-
navigate
"
this
.
onFrameUnload
)
;
this
.
targetActor
.
off
(
"
window
-
ready
"
this
.
onFrameLoad
)
;
this
.
customElementWatcher
.
off
(
"
element
-
defined
"
this
.
onCustomElementDefined
)
;
this
.
chromeEventHandler
.
removeEventListener
(
"
shadowrootattached
"
this
.
onShadowrootattached
)
;
this
.
chromeEventHandler
.
removeEventListener
(
"
anonymousrootcreated
"
this
.
onAnonymousrootcreated
)
;
this
.
chromeEventHandler
.
removeEventListener
(
"
anonymousrootremoved
"
this
.
onAnonymousrootremoved
)
;
for
(
const
{
document
}
of
this
.
targetActor
.
windows
)
{
document
.
devToolsAnonymousAndShadowEventsEnabled
=
false
;
}
this
.
onFrameLoad
=
null
;
this
.
onFrameUnload
=
null
;
this
.
customElementWatcher
.
destroy
(
)
;
this
.
customElementWatcher
=
null
;
this
.
walkerSearch
.
destroy
(
)
;
if
(
this
.
_nodePicker
)
{
this
.
_nodePicker
.
destroy
(
)
;
this
.
_nodePicker
=
null
;
}
this
.
layoutChangeObserver
.
off
(
"
reflows
"
this
.
_onReflows
)
;
this
.
layoutChangeObserver
.
off
(
"
resize
"
this
.
_onResize
)
;
this
.
layoutChangeObserver
=
null
;
releaseLayoutChangesObserver
(
this
.
targetActor
)
;
eventListenerService
.
removeListenerChangeListener
(
this
.
_onEventListenerChange
)
;
this
.
onMutations
=
null
;
this
.
layoutActor
=
null
;
this
.
targetActor
=
null
;
this
.
chromeEventHandler
=
null
;
this
.
emit
(
"
destroyed
"
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
release
(
)
{
}
unmanage
(
actor
)
{
if
(
actor
instanceof
NodeActor
)
{
if
(
this
.
_activePseudoClassLocks
&
&
this
.
_activePseudoClassLocks
.
has
(
actor
)
)
{
this
.
clearPseudoClassLocks
(
actor
)
;
}
this
.
customElementWatcher
.
unmanageNode
(
actor
)
;
this
.
_nodeActorsMap
.
delete
(
actor
.
rawNode
)
;
}
super
.
unmanage
(
actor
)
;
}
hasNode
(
rawNode
)
{
return
this
.
_nodeActorsMap
.
has
(
rawNode
)
;
}
getNode
(
rawNode
)
{
return
this
.
_nodeActorsMap
.
get
(
rawNode
)
;
}
_getOrCreateNodeActor
(
node
)
{
let
actor
=
this
.
getNode
(
node
)
;
if
(
actor
)
{
return
actor
;
}
actor
=
new
NodeActor
(
this
node
)
;
this
.
manage
(
actor
)
;
this
.
_nodeActorsMap
.
set
(
node
actor
)
;
if
(
node
.
nodeType
=
=
=
Node
.
DOCUMENT_NODE
)
{
actor
.
watchDocument
(
node
this
.
onMutations
)
;
}
if
(
isShadowRoot
(
actor
.
rawNode
)
)
{
actor
.
watchDocument
(
node
.
ownerDocument
this
.
onMutations
)
;
actor
.
watchSlotchange
(
this
.
onSlotchange
)
;
}
this
.
customElementWatcher
.
manageNode
(
actor
)
;
return
actor
;
}
onCustomElementDefined
(
{
actors
}
)
{
actors
.
forEach
(
actor
=
>
this
.
queueMutation
(
{
target
:
actor
.
actorID
type
:
"
customElementDefined
"
customElementLocation
:
actor
.
getCustomElementLocation
(
)
}
)
)
;
}
_onReflows
(
)
{
const
containerTypeChanges
=
[
]
;
const
displayTypeChanges
=
[
]
;
const
scrollableStateChanges
=
[
]
;
const
currentOverflowCausingElementsMap
=
new
Map
(
)
;
for
(
const
[
node
actor
]
of
this
.
_nodeActorsMap
)
{
if
(
Cu
.
isDeadWrapper
(
node
)
)
{
continue
;
}
const
displayType
=
actor
.
displayType
;
const
isDisplayed
=
actor
.
isDisplayed
;
if
(
displayType
!
=
=
actor
.
currentDisplayType
|
|
isDisplayed
!
=
=
actor
.
wasDisplayed
)
{
displayTypeChanges
.
push
(
actor
)
;
actor
.
currentDisplayType
=
displayType
;
actor
.
wasDisplayed
=
isDisplayed
;
}
const
isScrollable
=
actor
.
isScrollable
;
if
(
isScrollable
!
=
=
actor
.
wasScrollable
)
{
scrollableStateChanges
.
push
(
actor
)
;
actor
.
wasScrollable
=
isScrollable
;
}
if
(
isScrollable
)
{
this
.
updateOverflowCausingElements
(
actor
currentOverflowCausingElementsMap
)
;
}
const
containerType
=
actor
.
containerType
;
if
(
containerType
!
=
=
actor
.
currentContainerType
)
{
containerTypeChanges
.
push
(
actor
)
;
actor
.
currentContainerType
=
containerType
;
}
}
const
overflowStateChanges
=
[
.
.
.
currentOverflowCausingElementsMap
.
keys
(
)
]
.
filter
(
node
=
>
!
this
.
overflowCausingElementsMap
.
has
(
node
)
)
.
concat
(
[
.
.
.
this
.
overflowCausingElementsMap
.
keys
(
)
]
.
filter
(
node
=
>
!
currentOverflowCausingElementsMap
.
has
(
node
)
)
)
.
filter
(
node
=
>
this
.
hasNode
(
node
)
)
.
map
(
node
=
>
this
.
getNode
(
node
)
)
;
this
.
overflowCausingElementsMap
=
currentOverflowCausingElementsMap
;
if
(
overflowStateChanges
.
length
)
{
this
.
emit
(
"
overflow
-
change
"
overflowStateChanges
)
;
}
if
(
displayTypeChanges
.
length
)
{
this
.
emit
(
"
display
-
change
"
displayTypeChanges
)
;
}
if
(
scrollableStateChanges
.
length
)
{
this
.
emit
(
"
scrollable
-
change
"
scrollableStateChanges
)
;
}
if
(
containerTypeChanges
.
length
)
{
this
.
emit
(
"
container
-
type
-
change
"
containerTypeChanges
)
;
}
}
_onResize
(
)
{
this
.
emit
(
"
resize
"
)
;
}
attachElement
(
node
)
{
const
{
nodes
newParents
}
=
this
.
attachElements
(
[
node
]
)
;
return
{
node
:
nodes
[
0
]
newParents
}
;
}
attachElements
(
nodes
)
{
const
nodeActors
=
[
]
;
const
newParents
=
new
Set
(
)
;
for
(
let
node
of
nodes
)
{
if
(
!
(
node
instanceof
NodeActor
)
)
{
if
(
!
this
.
showAllAnonymousContent
)
{
while
(
node
&
&
standardTreeWalkerFilter
(
node
)
!
=
nodeFilterConstants
.
FILTER_ACCEPT
)
{
node
=
this
.
rawParentNode
(
node
)
;
}
if
(
!
node
)
{
continue
;
}
}
node
=
this
.
_getOrCreateNodeActor
(
node
)
;
}
this
.
ensurePathToRoot
(
node
newParents
)
;
nodeActors
.
push
(
node
)
;
}
return
{
nodes
:
nodeActors
newParents
:
[
.
.
.
newParents
]
}
;
}
document
(
node
)
{
const
doc
=
isNodeDead
(
node
)
?
this
.
rootDoc
:
nodeDocument
(
node
.
rawNode
)
;
return
this
.
_getOrCreateNodeActor
(
doc
)
;
}
documentElement
(
node
)
{
const
elt
=
isNodeDead
(
node
)
?
this
.
rootDoc
.
documentElement
:
nodeDocument
(
node
.
rawNode
)
.
documentElement
;
return
this
.
_getOrCreateNodeActor
(
elt
)
;
}
parentNode
(
node
)
{
const
parent
=
this
.
rawParentNode
(
node
)
;
if
(
parent
)
{
return
this
.
_getOrCreateNodeActor
(
parent
)
;
}
return
null
;
}
rawParentNode
(
node
)
{
const
rawNode
=
node
instanceof
NodeActor
?
node
.
rawNode
:
node
;
if
(
rawNode
=
=
this
.
rootDoc
)
{
return
null
;
}
return
InspectorUtils
.
getParentForNode
(
rawNode
true
)
;
}
inlineTextChild
(
{
rawNode
}
)
{
if
(
isMarkerPseudoElement
(
rawNode
)
|
|
isBeforePseudoElement
(
rawNode
)
|
|
isAfterPseudoElement
(
rawNode
)
|
|
isShadowHost
(
rawNode
)
|
|
rawNode
.
nodeType
!
=
Node
.
ELEMENT_NODE
|
|
!
!
rawNode
.
children
.
length
|
|
isFrameWithChildTarget
(
this
.
targetActor
rawNode
)
|
|
isFrameBlockedByCSP
(
rawNode
)
)
{
return
undefined
;
}
const
children
=
this
.
_rawChildren
(
rawNode
true
)
;
const
firstChild
=
children
[
0
]
;
const
isAssignedToSlot
=
firstChild
&
&
rawNode
.
nodeName
=
=
=
"
SLOT
"
&
&
isDirectShadowHostChild
(
firstChild
)
;
const
isFlexItem
=
!
!
firstChild
?
.
parentFlexElement
;
if
(
!
firstChild
|
|
children
.
length
>
1
|
|
firstChild
.
nodeType
!
=
=
Node
.
TEXT_NODE
|
|
firstChild
.
nodeValue
.
length
>
gValueSummaryLength
|
|
isAssignedToSlot
|
|
isFlexItem
)
{
return
undefined
;
}
return
this
.
_getOrCreateNodeActor
(
firstChild
)
;
}
retainNode
(
node
)
{
node
.
retained
=
true
;
}
unretainNode
(
node
)
{
node
.
retained
=
false
;
if
(
this
.
_retainedOrphans
.
has
(
node
)
)
{
this
.
_retainedOrphans
.
delete
(
node
)
;
this
.
releaseNode
(
node
)
;
}
}
releaseNode
(
node
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
if
(
node
.
retained
&
&
!
options
.
force
)
{
this
.
_retainedOrphans
.
add
(
node
)
;
return
;
}
if
(
node
.
retained
)
{
this
.
_retainedOrphans
.
delete
(
node
)
;
}
for
(
const
child
of
this
.
_rawChildren
(
node
.
rawNode
)
)
{
const
childActor
=
this
.
getNode
(
child
)
;
if
(
childActor
)
{
this
.
releaseNode
(
childActor
options
)
;
}
}
node
.
destroy
(
)
;
}
ensurePathToRoot
(
node
newParents
=
new
Set
(
)
)
{
if
(
!
node
)
{
return
newParents
;
}
let
parent
=
this
.
rawParentNode
(
node
)
;
while
(
parent
)
{
let
parentActor
=
this
.
getNode
(
parent
)
;
if
(
parentActor
)
{
return
newParents
;
}
parentActor
=
this
.
_getOrCreateNodeActor
(
parent
)
;
newParents
.
add
(
parentActor
)
;
parent
=
this
.
rawParentNode
(
parentActor
)
;
}
return
newParents
;
}
countChildren
(
node
options
=
{
}
)
{
return
this
.
_getChildren
(
node
options
)
.
nodes
.
length
;
}
children
(
node
options
=
{
}
)
{
const
{
hasFirst
hasLast
nodes
}
=
this
.
_getChildren
(
node
options
)
;
return
{
hasFirst
hasLast
nodes
:
nodes
.
map
(
n
=
>
this
.
_getOrCreateNodeActor
(
n
)
)
}
;
}
_rawChildren
(
rawNode
includeAssigned
)
{
const
filter
=
this
.
showAllAnonymousContent
?
allAnonymousContentTreeWalkerFilter
:
standardTreeWalkerFilter
;
const
ret
=
[
]
;
const
children
=
InspectorUtils
.
getChildrenForNode
(
rawNode
true
includeAssigned
)
;
for
(
const
child
of
children
)
{
if
(
filter
(
child
)
=
=
nodeFilterConstants
.
FILTER_ACCEPT
)
{
ret
.
push
(
child
)
;
}
}
return
ret
;
}
_getChildren
(
node
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
|
|
isFrameBlockedByCSP
(
node
.
rawNode
)
)
{
return
{
hasFirst
:
true
hasLast
:
true
nodes
:
[
]
}
;
}
if
(
options
.
center
&
&
options
.
start
)
{
throw
Error
(
"
Can
'
t
specify
both
'
center
'
and
'
start
'
options
.
"
)
;
}
let
maxNodes
=
options
.
maxNodes
|
|
-
1
;
if
(
maxNodes
=
=
-
1
)
{
maxNodes
=
Number
.
MAX_VALUE
;
}
let
nodes
=
this
.
_rawChildren
(
node
.
rawNode
true
)
;
let
hasFirst
=
true
;
let
hasLast
=
true
;
if
(
nodes
.
length
>
maxNodes
)
{
let
startIndex
;
if
(
options
.
center
)
{
const
centerIndex
=
nodes
.
indexOf
(
options
.
center
.
rawNode
)
;
const
backwardCount
=
Math
.
floor
(
maxNodes
/
2
)
;
if
(
centerIndex
-
backwardCount
+
maxNodes
>
=
nodes
.
length
)
{
startIndex
=
nodes
.
length
-
maxNodes
;
}
else
{
startIndex
=
Math
.
max
(
0
centerIndex
-
backwardCount
)
;
}
}
else
if
(
options
.
start
)
{
startIndex
=
Math
.
max
(
0
nodes
.
indexOf
(
options
.
start
.
rawNode
)
)
;
}
else
{
startIndex
=
0
;
}
const
endIndex
=
Math
.
min
(
startIndex
+
maxNodes
nodes
.
length
)
;
hasFirst
=
startIndex
=
=
0
;
hasLast
=
endIndex
>
=
nodes
.
length
;
nodes
=
nodes
.
slice
(
startIndex
endIndex
)
;
}
return
{
hasFirst
hasLast
nodes
}
;
}
nextSibling
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
const
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
const
sibling
=
walker
.
nextSibling
(
)
;
return
sibling
?
this
.
_getOrCreateNodeActor
(
sibling
)
:
null
;
}
previousSibling
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
const
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
const
sibling
=
walker
.
previousSibling
(
)
;
return
sibling
?
this
.
_getOrCreateNodeActor
(
sibling
)
:
null
;
}
_readForward
(
walker
count
)
{
const
ret
=
[
]
;
let
node
=
walker
.
currentNode
;
do
{
if
(
!
walker
.
isSkippedNode
(
node
)
)
{
ret
.
push
(
node
)
;
}
node
=
walker
.
nextSibling
(
)
;
}
while
(
node
&
&
-
-
count
)
;
return
ret
;
}
querySelector
(
baseNode
selector
)
{
if
(
isNodeDead
(
baseNode
)
)
{
return
{
}
;
}
const
node
=
baseNode
.
rawNode
.
querySelector
(
selector
)
;
if
(
!
node
)
{
return
{
}
;
}
return
this
.
attachElement
(
node
)
;
}
querySelectorAll
(
baseNode
selector
)
{
let
nodeList
=
null
;
try
{
nodeList
=
baseNode
.
rawNode
.
querySelectorAll
(
selector
)
;
}
catch
(
e
)
{
}
return
new
NodeListActor
(
this
nodeList
)
;
}
getIdrefNode
(
baseNode
id
)
{
if
(
isNodeDead
(
baseNode
)
)
{
return
{
}
;
}
const
rootNode
=
baseNode
.
rawNode
.
getRootNode
(
{
composed
:
false
}
)
;
if
(
!
rootNode
)
{
return
{
}
;
}
const
node
=
rootNode
.
getElementById
(
id
)
;
if
(
!
node
)
{
return
{
}
;
}
return
this
.
attachElement
(
node
)
;
}
_multiFrameQuerySelectorAll
(
selector
)
{
let
nodes
=
[
]
;
for
(
const
{
document
}
of
this
.
targetActor
.
windows
)
{
try
{
nodes
=
[
.
.
.
nodes
.
.
.
document
.
querySelectorAll
(
selector
)
]
;
}
catch
(
e
)
{
}
}
return
nodes
;
}
_multiFrameXPath
(
xPath
)
{
const
nodes
=
[
]
;
for
(
const
window
of
this
.
targetActor
.
windows
)
{
const
document
=
window
.
document
;
try
{
const
result
=
document
.
evaluate
(
xPath
document
.
documentElement
null
window
.
XPathResult
.
ORDERED_NODE_SNAPSHOT_TYPE
null
)
;
for
(
let
i
=
0
;
i
<
result
.
snapshotLength
;
i
+
+
)
{
nodes
.
push
(
result
.
snapshotItem
(
i
)
)
;
}
}
catch
(
e
)
{
}
}
return
nodes
;
}
multiFrameXPath
(
xPath
)
{
return
new
NodeListActor
(
this
this
.
_multiFrameXPath
(
xPath
)
)
;
}
search
(
query
)
{
const
results
=
this
.
walkerSearch
.
search
(
query
)
;
const
nodeList
=
new
NodeListActor
(
this
results
.
map
(
r
=
>
r
.
node
)
)
;
return
{
list
:
nodeList
metadata
:
[
]
}
;
}
getSuggestionsForQuery
(
query
completing
selectorState
)
{
const
sugs
=
{
classes
:
new
Map
(
)
tags
:
new
Map
(
)
ids
:
new
Map
(
)
}
;
let
result
=
[
]
;
let
nodes
=
null
;
switch
(
selectorState
)
{
case
"
pseudo
"
:
result
=
PSEUDO_SELECTORS
.
filter
(
item
=
>
{
return
item
[
0
]
.
startsWith
(
"
:
"
+
completing
)
;
}
)
;
break
;
case
"
class
"
:
if
(
!
query
)
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
"
[
class
]
"
)
;
}
else
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
query
)
;
}
for
(
const
node
of
nodes
)
{
for
(
const
className
of
node
.
classList
)
{
sugs
.
classes
.
set
(
className
(
sugs
.
classes
.
get
(
className
)
|
0
)
+
1
)
;
}
}
sugs
.
classes
.
delete
(
"
"
)
;
sugs
.
classes
.
delete
(
HIDDEN_CLASS
)
;
for
(
const
[
className
count
]
of
sugs
.
classes
)
{
if
(
className
.
startsWith
(
completing
)
)
{
result
.
push
(
[
"
.
"
+
CSS
.
escape
(
className
)
count
selectorState
]
)
;
}
}
break
;
case
"
id
"
:
if
(
!
query
)
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
"
[
id
]
"
)
;
}
else
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
query
)
;
}
for
(
const
node
of
nodes
)
{
sugs
.
ids
.
set
(
node
.
id
(
sugs
.
ids
.
get
(
node
.
id
)
|
0
)
+
1
)
;
}
for
(
const
[
id
count
]
of
sugs
.
ids
)
{
if
(
id
.
startsWith
(
completing
)
&
&
id
!
=
=
"
"
)
{
result
.
push
(
[
"
#
"
+
CSS
.
escape
(
id
)
count
selectorState
]
)
;
}
}
break
;
case
"
tag
"
:
if
(
!
query
)
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
"
*
"
)
;
}
else
{
nodes
=
this
.
_multiFrameQuerySelectorAll
(
query
)
;
}
for
(
const
node
of
nodes
)
{
const
tag
=
node
.
localName
;
sugs
.
tags
.
set
(
tag
(
sugs
.
tags
.
get
(
tag
)
|
0
)
+
1
)
;
}
for
(
const
[
tag
count
]
of
sugs
.
tags
)
{
if
(
new
RegExp
(
"
^
"
+
completing
+
"
.
*
"
"
i
"
)
.
test
(
tag
)
)
{
result
.
push
(
[
tag
count
selectorState
]
)
;
}
}
if
(
!
query
)
{
result
=
[
.
.
.
result
.
.
.
this
.
getSuggestionsForQuery
(
null
completing
"
class
"
)
.
suggestions
.
.
.
this
.
getSuggestionsForQuery
(
null
completing
"
id
"
)
.
suggestions
]
;
}
break
;
case
"
null
"
:
nodes
=
this
.
_multiFrameQuerySelectorAll
(
query
)
;
for
(
const
node
of
nodes
)
{
sugs
.
ids
.
set
(
node
.
id
(
sugs
.
ids
.
get
(
node
.
id
)
|
0
)
+
1
)
;
const
tag
=
node
.
localName
;
sugs
.
tags
.
set
(
tag
(
sugs
.
tags
.
get
(
tag
)
|
0
)
+
1
)
;
for
(
const
className
of
node
.
classList
)
{
sugs
.
classes
.
set
(
className
(
sugs
.
classes
.
get
(
className
)
|
0
)
+
1
)
;
}
}
for
(
const
[
tag
count
]
of
sugs
.
tags
)
{
tag
&
&
result
.
push
(
[
tag
count
]
)
;
}
for
(
const
[
id
count
]
of
sugs
.
ids
)
{
id
&
&
result
.
push
(
[
"
#
"
+
id
count
]
)
;
}
sugs
.
classes
.
delete
(
"
"
)
;
sugs
.
classes
.
delete
(
HIDDEN_CLASS
)
;
for
(
const
[
className
count
]
of
sugs
.
classes
)
{
className
&
&
result
.
push
(
[
"
.
"
+
className
count
]
)
;
}
}
result
=
result
.
sort
(
(
a
b
)
=
>
{
let
sortA
=
10000
-
a
[
1
]
+
a
[
0
]
;
let
sortB
=
10000
-
b
[
1
]
+
b
[
0
]
;
const
firstA
=
a
[
0
]
.
substring
(
0
1
)
;
const
firstB
=
b
[
0
]
.
substring
(
0
1
)
;
const
getSortKeyPrefix
=
firstLetter
=
>
{
if
(
firstLetter
=
=
=
"
#
"
)
{
return
"
2
"
;
}
if
(
firstLetter
=
=
=
"
.
"
)
{
return
"
1
"
;
}
return
"
0
"
;
}
;
sortA
=
getSortKeyPrefix
(
firstA
)
+
sortA
;
sortB
=
getSortKeyPrefix
(
firstB
)
+
sortB
;
return
sortA
.
localeCompare
(
sortB
)
;
}
)
;
result
=
result
.
slice
(
0
25
)
;
return
{
query
suggestions
:
result
}
;
}
addPseudoClassLock
(
node
pseudo
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
for
(
const
locked
of
this
.
_activePseudoClassLocks
)
{
if
(
InspectorUtils
.
hasPseudoClassLock
(
locked
.
rawNode
pseudo
)
)
{
this
.
_removePseudoClassLock
(
locked
pseudo
)
;
}
}
const
enabled
=
options
.
enabled
=
=
=
undefined
|
|
options
.
enabled
;
this
.
_addPseudoClassLock
(
node
pseudo
enabled
)
;
if
(
!
options
.
parents
)
{
return
;
}
const
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
let
cur
;
while
(
(
cur
=
walker
.
parentNode
(
)
)
)
{
const
curNode
=
this
.
_getOrCreateNodeActor
(
cur
)
;
this
.
_addPseudoClassLock
(
curNode
pseudo
enabled
)
;
}
}
_queuePseudoClassMutation
(
node
)
{
this
.
queueMutation
(
{
target
:
node
.
actorID
type
:
"
pseudoClassLock
"
pseudoClassLocks
:
node
.
writePseudoClassLocks
(
)
}
)
;
}
_addPseudoClassLock
(
node
pseudo
enabled
)
{
if
(
node
.
rawNode
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
return
false
;
}
InspectorUtils
.
addPseudoClassLock
(
node
.
rawNode
pseudo
enabled
)
;
this
.
_activePseudoClassLocks
.
add
(
node
)
;
this
.
_queuePseudoClassMutation
(
node
)
;
return
true
;
}
hideNode
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
loadSheet
(
node
.
rawNode
.
ownerGlobal
HELPER_SHEET
)
;
node
.
rawNode
.
classList
.
add
(
HIDDEN_CLASS
)
;
}
unhideNode
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
node
.
rawNode
.
classList
.
remove
(
HIDDEN_CLASS
)
;
}
removePseudoClassLock
(
node
pseudo
options
=
{
}
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
this
.
_removePseudoClassLock
(
node
pseudo
)
;
for
(
const
locked
of
this
.
_activePseudoClassLocks
)
{
if
(
node
.
rawNode
.
contains
(
locked
.
rawNode
)
&
&
InspectorUtils
.
hasPseudoClassLock
(
locked
.
rawNode
pseudo
)
)
{
this
.
_removePseudoClassLock
(
locked
pseudo
)
;
}
}
if
(
!
options
.
parents
)
{
return
;
}
const
walker
=
this
.
getDocumentWalker
(
node
.
rawNode
)
;
let
cur
;
while
(
(
cur
=
walker
.
parentNode
(
)
)
)
{
const
curNode
=
this
.
_getOrCreateNodeActor
(
cur
)
;
this
.
_removePseudoClassLock
(
curNode
pseudo
)
;
}
}
_removePseudoClassLock
(
node
pseudo
)
{
if
(
node
.
rawNode
.
nodeType
!
=
Node
.
ELEMENT_NODE
)
{
return
false
;
}
InspectorUtils
.
removePseudoClassLock
(
node
.
rawNode
pseudo
)
;
if
(
!
node
.
writePseudoClassLocks
(
)
)
{
this
.
_activePseudoClassLocks
.
delete
(
node
)
;
}
this
.
_queuePseudoClassMutation
(
node
)
;
return
true
;
}
clearPseudoClassLocks
(
node
)
{
if
(
node
&
&
isNodeDead
(
node
)
)
{
return
;
}
if
(
node
)
{
InspectorUtils
.
clearPseudoClassLocks
(
node
.
rawNode
)
;
this
.
_activePseudoClassLocks
.
delete
(
node
)
;
this
.
_queuePseudoClassMutation
(
node
)
;
}
else
{
for
(
const
locked
of
this
.
_activePseudoClassLocks
)
{
InspectorUtils
.
clearPseudoClassLocks
(
locked
.
rawNode
)
;
this
.
_activePseudoClassLocks
.
delete
(
locked
)
;
this
.
_queuePseudoClassMutation
(
locked
)
;
}
}
}
innerHTML
(
node
)
{
let
html
=
"
"
;
if
(
!
isNodeDead
(
node
)
)
{
html
=
node
.
rawNode
.
innerHTML
;
}
return
new
LongStringActor
(
this
.
conn
html
)
;
}
setInnerHTML
(
node
value
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
const
rawNode
=
node
.
rawNode
;
if
(
rawNode
.
nodeType
!
=
=
rawNode
.
ownerDocument
.
ELEMENT_NODE
&
&
rawNode
.
nodeType
!
=
=
rawNode
.
ownerDocument
.
DOCUMENT_FRAGMENT_NODE
)
{
throw
new
Error
(
"
Can
only
change
innerHTML
to
element
or
fragment
nodes
"
)
;
}
rawNode
.
innerHTML
=
value
;
}
outerHTML
(
node
)
{
let
outerHTML
=
"
"
;
if
(
!
isNodeDead
(
node
)
)
{
outerHTML
=
node
.
rawNode
.
outerHTML
;
}
return
new
LongStringActor
(
this
.
conn
outerHTML
)
;
}
setOuterHTML
(
node
value
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
const
rawNode
=
node
.
rawNode
;
const
doc
=
nodeDocument
(
rawNode
)
;
const
win
=
doc
.
defaultView
;
let
parser
;
if
(
!
win
)
{
throw
new
Error
(
"
The
window
object
shouldn
'
t
be
null
"
)
;
}
else
{
parser
=
new
win
.
DOMParser
(
)
;
}
const
mimeType
=
rawNode
.
tagName
=
=
=
"
svg
"
?
"
image
/
svg
+
xml
"
:
"
text
/
html
"
;
const
parsedDOM
=
parser
.
parseFromString
(
value
mimeType
)
;
const
parentNode
=
rawNode
.
parentNode
;
if
(
rawNode
.
tagName
=
=
=
"
BODY
"
)
{
if
(
parsedDOM
.
head
.
innerHTML
=
=
=
"
"
)
{
parentNode
.
replaceChild
(
parsedDOM
.
body
rawNode
)
;
}
else
{
rawNode
.
outerHTML
=
value
;
}
}
else
if
(
rawNode
.
tagName
=
=
=
"
HEAD
"
)
{
if
(
parsedDOM
.
body
.
innerHTML
=
=
=
"
"
)
{
parentNode
.
replaceChild
(
parsedDOM
.
head
rawNode
)
;
}
else
{
rawNode
.
outerHTML
=
value
;
}
}
else
if
(
node
.
isDocumentElement
(
)
)
{
const
finalAttributeModifications
=
[
]
;
const
attributeModifications
=
{
}
;
for
(
const
attribute
of
rawNode
.
attributes
)
{
attributeModifications
[
attribute
.
name
]
=
null
;
}
for
(
const
attribute
of
parsedDOM
.
documentElement
.
attributes
)
{
attributeModifications
[
attribute
.
name
]
=
attribute
.
value
;
}
for
(
const
key
in
attributeModifications
)
{
finalAttributeModifications
.
push
(
{
attributeName
:
key
newValue
:
attributeModifications
[
key
]
}
)
;
}
node
.
modifyAttributes
(
finalAttributeModifications
)
;
rawNode
.
replaceChildren
(
.
.
.
parsedDOM
.
firstElementChild
.
childNodes
)
;
}
else
{
rawNode
.
outerHTML
=
value
;
}
}
insertAdjacentHTML
(
node
position
value
)
{
if
(
isNodeDead
(
node
)
)
{
return
{
node
:
[
]
newParents
:
[
]
}
;
}
const
rawNode
=
node
.
rawNode
;
const
isInsertAsSibling
=
position
=
=
=
"
beforeBegin
"
|
|
position
=
=
=
"
afterEnd
"
;
if
(
isInsertAsSibling
&
&
node
.
isDocumentElement
(
)
)
{
throw
new
Error
(
"
Can
'
t
insert
adjacent
element
to
the
root
.
"
)
;
}
const
rawParentNode
=
rawNode
.
parentNode
;
if
(
!
rawParentNode
&
&
isInsertAsSibling
)
{
throw
new
Error
(
"
Can
'
t
insert
as
sibling
without
parent
node
.
"
)
;
}
const
range
=
rawNode
.
ownerDocument
.
createRange
(
)
;
if
(
position
=
=
=
"
beforeBegin
"
|
|
position
=
=
=
"
afterEnd
"
)
{
range
.
selectNode
(
rawNode
)
;
}
else
{
range
.
selectNodeContents
(
rawNode
)
;
}
const
docFrag
=
range
.
createContextualFragment
(
value
)
;
const
newRawNodes
=
Array
.
from
(
docFrag
.
childNodes
)
;
switch
(
position
)
{
case
"
beforeBegin
"
:
rawParentNode
.
insertBefore
(
docFrag
rawNode
)
;
break
;
case
"
afterEnd
"
:
rawParentNode
.
insertBefore
(
docFrag
rawNode
.
nextSibling
)
;
break
;
case
"
afterBegin
"
:
rawNode
.
insertBefore
(
docFrag
rawNode
.
firstChild
)
;
break
;
case
"
beforeEnd
"
:
rawNode
.
appendChild
(
docFrag
)
;
break
;
default
:
throw
new
Error
(
"
Invalid
position
value
.
Must
be
either
"
+
"
'
beforeBegin
'
'
beforeEnd
'
'
afterBegin
'
or
'
afterEnd
'
.
"
)
;
}
return
this
.
attachElements
(
newRawNodes
)
;
}
duplicateNode
(
{
rawNode
}
)
{
const
clonedNode
=
rawNode
.
cloneNode
(
true
)
;
rawNode
.
parentNode
.
insertBefore
(
clonedNode
rawNode
.
nextSibling
)
;
}
isDocumentOrDocumentElementNode
(
node
)
{
return
(
(
node
.
rawNode
.
ownerDocument
&
&
node
.
rawNode
.
ownerDocument
.
documentElement
=
=
=
this
.
rawNode
)
|
|
node
.
rawNode
.
nodeType
=
=
=
Node
.
DOCUMENT_NODE
)
;
}
removeNode
(
node
)
{
if
(
isNodeDead
(
node
)
|
|
this
.
isDocumentOrDocumentElementNode
(
node
)
)
{
throw
Error
(
"
Cannot
remove
document
document
elements
or
dead
nodes
.
"
)
;
}
const
nextSibling
=
this
.
nextSibling
(
node
)
;
node
.
rawNode
.
remove
(
)
;
return
nextSibling
;
}
removeNodes
(
nodes
)
{
for
(
const
node
of
nodes
)
{
if
(
isNodeDead
(
node
)
|
|
this
.
isDocumentOrDocumentElementNode
(
node
)
)
{
throw
Error
(
"
Cannot
remove
document
document
elements
or
dead
nodes
"
)
;
}
}
for
(
const
node
of
nodes
)
{
node
.
rawNode
.
remove
(
)
;
}
}
insertBefore
(
node
parent
sibling
)
{
if
(
isNodeDead
(
node
)
|
|
isNodeDead
(
parent
)
|
|
(
sibling
&
&
isNodeDead
(
sibling
)
)
)
{
return
;
}
const
rawNode
=
node
.
rawNode
;
const
rawParent
=
parent
.
rawNode
;
const
rawSibling
=
sibling
?
sibling
.
rawNode
:
null
;
if
(
rawNode
.
parentNode
=
=
=
rawParent
)
{
let
currentNextSibling
=
this
.
nextSibling
(
node
)
;
currentNextSibling
=
currentNextSibling
?
currentNextSibling
.
rawNode
:
null
;
if
(
rawNode
=
=
=
rawSibling
|
|
currentNextSibling
=
=
=
rawSibling
)
{
return
;
}
}
rawParent
.
insertBefore
(
rawNode
rawSibling
)
;
}
editTagName
(
node
tagName
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
const
oldNode
=
node
.
rawNode
;
let
newNode
;
try
{
newNode
=
nodeDocument
(
oldNode
)
.
createElement
(
tagName
)
;
}
catch
(
x
)
{
return
Promise
.
reject
(
new
Error
(
"
Could
not
change
node
'
s
tagName
to
"
+
tagName
)
)
;
}
const
attrs
=
oldNode
.
attributes
;
for
(
let
i
=
0
;
i
<
attrs
.
length
;
i
+
+
)
{
newNode
.
setAttribute
(
attrs
[
i
]
.
name
attrs
[
i
]
.
value
)
;
}
oldNode
.
parentNode
.
insertBefore
(
newNode
oldNode
)
;
while
(
oldNode
.
firstChild
)
{
newNode
.
appendChild
(
oldNode
.
firstChild
)
;
}
oldNode
.
remove
(
)
;
return
null
;
}
getMutationBreakpoints
(
node
)
{
let
bps
;
if
(
!
isNodeDead
(
node
)
)
{
bps
=
this
.
_breakpointInfoForNode
(
node
.
rawNode
)
;
}
return
(
bps
|
|
{
subtree
:
false
removal
:
false
attribute
:
false
}
)
;
}
setMutationBreakpoints
(
node
bps
)
{
if
(
isNodeDead
(
node
)
)
{
return
;
}
const
rawNode
=
node
.
rawNode
;
if
(
rawNode
.
ownerDocument
&
&
rawNode
.
getRootNode
(
{
composed
:
true
}
)
!
=
rawNode
.
ownerDocument
)
{
return
;
}
const
bpsForNode
=
Object
.
keys
(
bps
)
.
reduce
(
(
obj
bp
)
=
>
{
if
(
typeof
bps
[
bp
]
=
=
=
"
boolean
"
)
{
obj
[
bp
]
=
bps
[
bp
]
;
}
return
obj
;
}
{
}
)
;
this
.
_updateMutationBreakpointState
(
"
api
"
rawNode
{
.
.
.
this
.
getMutationBreakpoints
(
node
)
.
.
.
bpsForNode
}
)
;
}
_updateMutationBreakpointState
(
mutationReason
rawNode
bpsForNode
)
{
const
rawDoc
=
rawNode
.
ownerDocument
|
|
rawNode
;
const
docMutationBreakpoints
=
this
.
_mutationBreakpointsForDoc
(
rawDoc
true
)
;
let
originalBpsForNode
=
this
.
_breakpointInfoForNode
(
rawNode
)
;
if
(
!
bpsForNode
&
&
!
originalBpsForNode
)
{
return
;
}
bpsForNode
=
bpsForNode
|
|
{
}
;
originalBpsForNode
=
originalBpsForNode
|
|
{
}
;
if
(
Object
.
values
(
bpsForNode
)
.
some
(
Boolean
)
)
{
docMutationBreakpoints
.
nodes
.
set
(
rawNode
bpsForNode
)
;
}
else
{
docMutationBreakpoints
.
nodes
.
delete
(
rawNode
)
;
}
if
(
originalBpsForNode
.
subtree
&
&
!
bpsForNode
.
subtree
)
{
docMutationBreakpoints
.
counts
.
subtree
-
=
1
;
}
else
if
(
!
originalBpsForNode
.
subtree
&
&
bpsForNode
.
subtree
)
{
docMutationBreakpoints
.
counts
.
subtree
+
=
1
;
}
if
(
originalBpsForNode
.
removal
&
&
!
bpsForNode
.
removal
)
{
docMutationBreakpoints
.
counts
.
removal
-
=
1
;
}
else
if
(
!
originalBpsForNode
.
removal
&
&
bpsForNode
.
removal
)
{
docMutationBreakpoints
.
counts
.
removal
+
=
1
;
}
if
(
originalBpsForNode
.
attribute
&
&
!
bpsForNode
.
attribute
)
{
docMutationBreakpoints
.
counts
.
attribute
-
=
1
;
}
else
if
(
!
originalBpsForNode
.
attribute
&
&
bpsForNode
.
attribute
)
{
docMutationBreakpoints
.
counts
.
attribute
+
=
1
;
}
this
.
_updateDocumentMutationListeners
(
rawDoc
)
;
const
actor
=
this
.
getNode
(
rawNode
)
;
if
(
actor
)
{
this
.
queueMutation
(
{
target
:
actor
.
actorID
type
:
"
mutationBreakpoint
"
mutationBreakpoints
:
this
.
getMutationBreakpoints
(
actor
)
mutationReason
}
)
;
}
}
_updateDocumentMutationListeners
(
rawDoc
)
{
const
docMutationBreakpoints
=
this
.
_mutationBreakpointsForDoc
(
rawDoc
)
;
if
(
!
docMutationBreakpoints
)
{
rawDoc
.
devToolsWatchingDOMMutations
=
false
;
return
;
}
const
anyBreakpoint
=
docMutationBreakpoints
.
counts
.
subtree
>
0
|
|
docMutationBreakpoints
.
counts
.
removal
>
0
|
|
docMutationBreakpoints
.
counts
.
attribute
>
0
;
rawDoc
.
devToolsWatchingDOMMutations
=
anyBreakpoint
;
if
(
docMutationBreakpoints
.
counts
.
subtree
>
0
)
{
this
.
chromeEventHandler
.
addEventListener
(
"
devtoolschildinserted
"
this
.
onSubtreeModified
true
)
;
}
else
{
this
.
chromeEventHandler
.
removeEventListener
(
"
devtoolschildinserted
"
this
.
onSubtreeModified
true
)
;
}
if
(
anyBreakpoint
)
{
this
.
chromeEventHandler
.
addEventListener
(
"
devtoolschildremoved
"
this
.
onNodeRemoved
true
)
;
}
else
{
this
.
chromeEventHandler
.
removeEventListener
(
"
devtoolschildremoved
"
this
.
onNodeRemoved
true
)
;
}
if
(
docMutationBreakpoints
.
counts
.
attribute
>
0
)
{
this
.
chromeEventHandler
.
addEventListener
(
"
devtoolsattrmodified
"
this
.
onAttributeModified
true
)
;
}
else
{
this
.
chromeEventHandler
.
removeEventListener
(
"
devtoolsattrmodified
"
this
.
onAttributeModified
true
)
;
}
}
_breakOnMutation
(
mutationType
targetNode
ancestorNode
action
)
{
this
.
targetActor
.
threadActor
.
pauseForMutationBreakpoint
(
mutationType
targetNode
ancestorNode
action
)
;
}
_mutationBreakpointsForDoc
(
rawDoc
createIfNeeded
=
false
)
{
let
docMutationBreakpoints
=
this
.
_mutationBreakpoints
.
get
(
rawDoc
)
;
if
(
!
docMutationBreakpoints
&
&
createIfNeeded
)
{
docMutationBreakpoints
=
{
counts
:
{
subtree
:
0
removal
:
0
attribute
:
0
}
nodes
:
new
Map
(
)
}
;
this
.
_mutationBreakpoints
.
set
(
rawDoc
docMutationBreakpoints
)
;
}
return
docMutationBreakpoints
;
}
_breakpointInfoForNode
(
target
)
{
const
docMutationBreakpoints
=
this
.
_mutationBreakpointsForDoc
(
target
.
ownerDocument
|
|
target
)
;
return
(
(
docMutationBreakpoints
&
&
docMutationBreakpoints
.
nodes
.
get
(
target
)
)
|
|
null
)
;
}
onNodeRemoved
(
evt
)
{
const
mutationBpInfo
=
this
.
_breakpointInfoForNode
(
evt
.
target
)
;
const
hasNodeRemovalEvent
=
mutationBpInfo
?
.
removal
;
this
.
_clearMutationBreakpointsFromSubtree
(
evt
.
target
)
;
if
(
hasNodeRemovalEvent
)
{
this
.
_breakOnMutation
(
"
nodeRemoved
"
evt
.
target
)
;
}
else
{
this
.
onSubtreeModified
(
evt
)
;
}
}
onAttributeModified
(
evt
)
{
const
mutationBpInfo
=
this
.
_breakpointInfoForNode
(
evt
.
target
)
;
if
(
mutationBpInfo
?
.
attribute
)
{
this
.
_breakOnMutation
(
"
attributeModified
"
evt
.
target
)
;
}
}
onSubtreeModified
(
evt
)
{
const
action
=
evt
.
type
=
=
=
"
devtoolschildinserted
"
?
"
add
"
:
"
remove
"
;
let
node
=
evt
.
target
;
if
(
node
.
isNativeAnonymous
&
&
!
this
.
showAllAnonymousContent
)
{
return
;
}
while
(
(
node
=
node
.
parentNode
)
!
=
=
null
)
{
const
mutationBpInfo
=
this
.
_breakpointInfoForNode
(
node
)
;
if
(
mutationBpInfo
?
.
subtree
)
{
this
.
_breakOnMutation
(
"
subtreeModified
"
evt
.
target
node
action
)
;
break
;
}
}
}
_clearMutationBreakpointsFromSubtree
(
targetNode
)
{
const
targetDoc
=
targetNode
.
ownerDocument
|
|
targetNode
;
const
docMutationBreakpoints
=
this
.
_mutationBreakpointsForDoc
(
targetDoc
)
;
if
(
!
docMutationBreakpoints
|
|
docMutationBreakpoints
.
nodes
.
size
=
=
=
0
)
{
return
;
}
const
nextWalkerSibling
=
this
.
_getNextTraversalSibling
(
targetNode
)
;
const
walker
=
new
DocumentWalker
(
targetNode
this
.
rootWin
{
filter
:
noAnonymousContentTreeWalkerFilter
skipTo
:
SKIP_TO_SIBLING
}
)
;
do
{
this
.
_updateMutationBreakpointState
(
"
detach
"
walker
.
currentNode
null
)
;
}
while
(
walker
.
nextNode
(
)
&
&
walker
.
currentNode
!
=
=
nextWalkerSibling
)
;
}
_getNextTraversalSibling
(
targetNode
)
{
const
walker
=
new
DocumentWalker
(
targetNode
this
.
rootWin
{
filter
:
noAnonymousContentTreeWalkerFilter
skipTo
:
SKIP_TO_SIBLING
}
)
;
while
(
!
walker
.
nextSibling
(
)
)
{
if
(
!
walker
.
parentNode
(
)
)
{
return
null
;
}
}
return
walker
.
currentNode
;
}
getMutations
(
options
=
{
}
)
{
const
pending
=
this
.
_pendingMutations
|
|
[
]
;
this
.
_pendingMutations
=
[
]
;
this
.
_waitingForGetMutations
=
false
;
if
(
options
.
cleanup
)
{
for
(
const
node
of
this
.
_orphaned
)
{
this
.
releaseNode
(
node
)
;
}
this
.
_orphaned
=
new
Set
(
)
;
}
return
pending
;
}
queueMutation
(
mutation
)
{
if
(
!
this
.
actorID
|
|
this
.
_destroyed
)
{
return
;
}
this
.
_pendingMutations
.
push
(
mutation
)
;
if
(
this
.
_waitingForGetMutations
)
{
return
;
}
if
(
IMMEDIATE_MUTATIONS
.
includes
(
mutation
.
type
)
)
{
this
.
_emitNewMutations
(
)
;
}
else
{
this
.
_throttledEmitNewMutations
(
)
;
}
}
_emitNewMutations
(
)
{
if
(
!
this
.
actorID
|
|
this
.
_destroyed
)
{
return
;
}
if
(
this
.
_waitingForGetMutations
|
|
!
this
.
_pendingMutations
.
length
)
{
return
;
}
this
.
_waitingForGetMutations
=
true
;
this
.
emit
(
"
new
-
mutations
"
)
;
}
onMutations
(
mutations
)
{
this
.
emit
(
"
any
-
mutation
"
)
;
for
(
const
change
of
mutations
)
{
const
targetActor
=
this
.
getNode
(
change
.
target
)
;
if
(
!
targetActor
)
{
continue
;
}
const
targetNode
=
change
.
target
;
const
type
=
change
.
type
;
const
mutation
=
{
type
target
:
targetActor
.
actorID
}
;
if
(
type
=
=
=
"
attributes
"
)
{
mutation
.
attributeName
=
change
.
attributeName
;
mutation
.
attributeNamespace
=
change
.
attributeNamespace
|
|
undefined
;
mutation
.
newValue
=
targetNode
.
hasAttribute
(
mutation
.
attributeName
)
?
targetNode
.
getAttribute
(
mutation
.
attributeName
)
:
null
;
}
else
if
(
type
=
=
=
"
characterData
"
)
{
mutation
.
newValue
=
targetNode
.
nodeValue
;
this
.
_maybeQueueInlineTextChildMutation
(
change
targetNode
)
;
}
else
if
(
type
=
=
=
"
childList
"
)
{
const
removedActors
=
[
]
;
const
addedActors
=
[
]
;
for
(
const
removed
of
change
.
removedNodes
)
{
const
removedActor
=
this
.
getNode
(
removed
)
;
if
(
!
removedActor
)
{
continue
;
}
this
.
_orphaned
.
add
(
removedActor
)
;
removedActors
.
push
(
removedActor
.
actorID
)
;
}
for
(
const
added
of
change
.
addedNodes
)
{
const
addedActor
=
this
.
getNode
(
added
)
;
if
(
!
addedActor
)
{
continue
;
}
this
.
_orphaned
.
delete
(
addedActor
)
;
addedActors
.
push
(
addedActor
.
actorID
)
;
}
mutation
.
numChildren
=
targetActor
.
numChildren
;
mutation
.
removed
=
removedActors
;
mutation
.
added
=
addedActors
;
const
inlineTextChild
=
this
.
inlineTextChild
(
targetActor
)
;
if
(
inlineTextChild
)
{
mutation
.
inlineTextChild
=
inlineTextChild
.
form
(
)
;
}
}
this
.
queueMutation
(
mutation
)
;
}
}
_maybeQueueInlineTextChildMutation
(
mutation
)
{
const
{
oldValue
target
}
=
mutation
;
const
newValue
=
target
.
nodeValue
;
const
limit
=
gValueSummaryLength
;
if
(
(
oldValue
.
length
<
=
limit
&
&
newValue
.
length
<
=
limit
)
|
|
(
oldValue
.
length
>
limit
&
&
newValue
.
length
>
limit
)
)
{
return
;
}
const
parentActor
=
this
.
getNode
(
target
.
parentNode
)
;
if
(
!
parentActor
|
|
parentActor
.
rawNode
.
children
.
length
)
{
return
;
}
const
inlineTextChild
=
this
.
inlineTextChild
(
parentActor
)
;
this
.
queueMutation
(
{
type
:
"
inlineTextChild
"
target
:
parentActor
.
actorID
inlineTextChild
:
inlineTextChild
?
inlineTextChild
.
form
(
)
:
undefined
}
)
;
}
onSlotchange
(
event
)
{
const
target
=
event
.
target
;
const
targetActor
=
this
.
getNode
(
target
)
;
if
(
!
targetActor
)
{
return
;
}
this
.
queueMutation
(
{
type
:
"
slotchange
"
target
:
targetActor
.
actorID
}
)
;
}
onAnonymousrootcreated
(
event
)
{
const
root
=
event
.
target
;
const
parent
=
this
.
rawParentNode
(
root
)
;
if
(
!
parent
)
{
return
;
}
this
.
_anonParents
.
set
(
root
parent
)
;
this
.
onMutations
(
[
{
type
:
"
childList
"
target
:
parent
addedNodes
:
[
root
]
removedNodes
:
[
]
}
]
)
;
}
onAnonymousrootremoved
(
event
)
{
const
root
=
event
.
target
;
const
parent
=
this
.
_anonParents
.
get
(
root
)
;
if
(
!
parent
)
{
return
;
}
this
.
_anonParents
.
delete
(
root
)
;
this
.
onMutations
(
[
{
type
:
"
childList
"
target
:
parent
addedNodes
:
[
]
removedNodes
:
[
root
]
}
]
)
;
}
onShadowrootattached
(
event
)
{
const
actor
=
this
.
getNode
(
event
.
target
)
;
if
(
!
actor
)
{
return
;
}
const
mutation
=
{
type
:
"
shadowRootAttached
"
target
:
actor
.
actorID
}
;
this
.
queueMutation
(
mutation
)
;
}
onFrameLoad
(
{
window
isTopLevel
}
)
{
if
(
this
.
_destroyed
)
{
return
;
}
const
{
readyState
}
=
window
.
document
;
if
(
readyState
!
=
"
interactive
"
&
&
readyState
!
=
"
complete
"
)
{
window
.
addEventListener
(
"
DOMContentLoaded
"
this
.
onFrameLoad
.
bind
(
this
{
window
isTopLevel
}
)
{
once
:
true
}
)
;
return
;
}
window
.
document
.
shadowRootAttachedEventEnabled
=
true
;
if
(
isTopLevel
)
{
if
(
this
.
rootDoc
&
&
this
.
rootDoc
!
=
=
window
.
document
&
&
!
Cu
.
isDeadWrapper
(
this
.
rootDoc
)
&
&
this
.
rootDoc
.
defaultView
)
{
this
.
onFrameUnload
(
{
window
:
this
.
rootDoc
.
defaultView
}
)
;
}
this
.
rootWin
=
window
;
this
.
rootDoc
=
window
.
document
;
this
.
rootNode
=
this
.
document
(
)
;
this
.
emit
(
"
root
-
available
"
this
.
rootNode
)
;
}
else
{
const
frame
=
getFrameElement
(
window
)
;
const
frameActor
=
this
.
getNode
(
frame
)
;
if
(
frameActor
)
{
const
documentActor
=
this
.
_getOrCreateNodeActor
(
window
.
document
)
;
this
.
emit
(
"
root
-
available
"
documentActor
)
;
}
}
}
_childOfWindow
(
window
domNode
)
{
while
(
domNode
)
{
const
win
=
nodeDocument
(
domNode
)
.
defaultView
;
if
(
win
=
=
=
window
)
{
return
true
;
}
domNode
=
getFrameElement
(
win
)
;
}
return
false
;
}
onFrameUnload
(
{
window
}
)
{
const
releasedOrphans
=
[
]
;
for
(
const
retained
of
this
.
_retainedOrphans
)
{
if
(
Cu
.
isDeadWrapper
(
retained
.
rawNode
)
|
|
this
.
_childOfWindow
(
window
retained
.
rawNode
)
)
{
this
.
_retainedOrphans
.
delete
(
retained
)
;
releasedOrphans
.
push
(
retained
.
actorID
)
;
this
.
releaseNode
(
retained
{
force
:
true
}
)
;
}
}
if
(
releasedOrphans
.
length
)
{
this
.
queueMutation
(
{
target
:
this
.
rootNode
.
actorID
type
:
"
unretained
"
nodes
:
releasedOrphans
}
)
;
}
const
doc
=
window
.
document
;
const
documentActor
=
this
.
getNode
(
doc
)
;
if
(
!
documentActor
)
{
return
;
}
const
mutationBps
=
this
.
_mutationBreakpointsForDoc
(
doc
)
;
const
nodes
=
mutationBps
?
Array
.
from
(
mutationBps
.
nodes
.
keys
(
)
)
:
[
]
;
for
(
const
node
of
nodes
)
{
this
.
_updateMutationBreakpointState
(
"
unload
"
node
null
)
;
}
this
.
emit
(
"
root
-
destroyed
"
documentActor
)
;
if
(
this
.
rootDoc
=
=
=
doc
)
{
this
.
rootDoc
=
null
;
this
.
rootNode
=
null
;
}
this
.
releaseNode
(
documentActor
{
force
:
true
}
)
;
}
_isInDOMTree
(
rawNode
)
{
let
walker
;
try
{
walker
=
this
.
getDocumentWalker
(
rawNode
)
;
}
catch
(
e
)
{
if
(
e
.
name
=
=
"
NS_ERROR_ILLEGAL_VALUE
"
)
{
return
false
;
}
throw
e
;
}
let
current
=
walker
.
currentNode
;
while
(
walker
.
parentNode
(
)
)
{
current
=
walker
.
currentNode
;
}
if
(
current
.
nodeType
=
=
=
Node
.
DOCUMENT_FRAGMENT_NODE
|
|
current
!
=
=
this
.
rootDoc
)
{
return
false
;
}
return
true
;
}
isInDOMTree
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
false
;
}
return
this
.
_isInDOMTree
(
node
.
rawNode
)
;
}
getNodeActorFromWindowID
(
windowID
)
{
let
win
;
try
{
win
=
Services
.
wm
.
getOuterWindowWithId
(
windowID
)
;
}
catch
(
e
)
{
}
if
(
!
win
)
{
return
{
error
:
"
noWindow
"
message
:
"
The
related
docshell
is
destroyed
or
not
found
"
}
;
}
else
if
(
!
win
.
frameElement
)
{
return
this
.
attachElement
(
win
.
document
.
body
|
|
win
.
document
.
documentElement
)
;
}
return
this
.
attachElement
(
win
.
frameElement
)
;
}
getNodeActorFromContentDomReference
(
contentDomReference
)
{
let
rawNode
=
lazy
.
ContentDOMReference
.
resolve
(
contentDomReference
)
;
if
(
!
rawNode
|
|
!
this
.
_isInDOMTree
(
rawNode
)
)
{
return
null
;
}
if
(
rawNode
.
defaultView
&
&
rawNode
=
=
=
rawNode
.
defaultView
.
document
)
{
rawNode
=
rawNode
.
documentElement
;
}
return
this
.
attachElement
(
rawNode
)
;
}
getStyleSheetOwnerNode
(
resourceId
)
{
const
manager
=
this
.
targetActor
.
getStyleSheetsManager
(
)
;
const
ownerNode
=
manager
.
getOwnerNode
(
resourceId
)
;
return
this
.
attachElement
(
ownerNode
)
;
}
getNodeFromActor
(
actorID
path
)
{
const
actor
=
this
.
conn
.
getActor
(
actorID
)
;
if
(
!
actor
)
{
return
null
;
}
let
obj
=
actor
;
for
(
const
name
of
path
)
{
if
(
!
(
name
in
obj
)
)
{
return
null
;
}
obj
=
obj
[
name
]
;
}
return
this
.
attachElement
(
obj
)
;
}
getLayoutInspector
(
)
{
if
(
!
this
.
layoutActor
)
{
this
.
layoutActor
=
new
LayoutActor
(
this
.
conn
this
.
targetActor
this
)
;
}
return
this
.
layoutActor
;
}
getParentGridNode
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
const
parentGridNode
=
findGridParentContainerForNode
(
node
.
rawNode
)
;
return
parentGridNode
?
this
.
_getOrCreateNodeActor
(
parentGridNode
)
:
null
;
}
getOffsetParent
(
node
)
{
if
(
isNodeDead
(
node
)
)
{
return
null
;
}
const
offsetParent
=
node
.
rawNode
.
offsetParent
;
if
(
!
offsetParent
)
{
return
null
;
}
return
this
.
_getOrCreateNodeActor
(
offsetParent
)
;
}
getEmbedderElement
(
browsingContextID
)
{
const
browsingContext
=
BrowsingContext
.
get
(
browsingContextID
)
;
let
rawNode
=
browsingContext
.
embedderElement
;
if
(
!
this
.
_isInDOMTree
(
rawNode
)
)
{
return
null
;
}
if
(
rawNode
.
defaultView
&
&
rawNode
=
=
=
rawNode
.
defaultView
.
document
)
{
rawNode
=
rawNode
.
documentElement
;
}
return
this
.
attachElement
(
rawNode
)
;
}
pick
(
doFocus
isLocalTab
)
{
this
.
nodePicker
.
pick
(
doFocus
isLocalTab
)
;
}
cancelPick
(
)
{
this
.
nodePicker
.
cancelPick
(
)
;
}
clearPicker
(
)
{
this
.
nodePicker
.
resetHoveredNodeReference
(
)
;
}
updateOverflowCausingElements
(
scrollableNode
map
)
{
if
(
isNodeDead
(
scrollableNode
)
|
|
scrollableNode
.
rawNode
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
return
;
}
const
overflowCausingChildren
=
[
.
.
.
InspectorUtils
.
getOverflowingChildrenOfElement
(
scrollableNode
.
rawNode
)
]
;
for
(
let
overflowCausingChild
of
overflowCausingChildren
)
{
if
(
overflowCausingChild
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
overflowCausingChild
=
overflowCausingChild
.
parentElement
;
}
map
.
set
(
overflowCausingChild
scrollableNode
)
;
}
}
getOverflowCausingElements
(
node
)
{
if
(
isNodeDead
(
node
)
|
|
node
.
rawNode
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
|
|
!
node
.
isScrollable
)
{
return
[
]
;
}
const
overflowCausingElements
=
[
.
.
.
InspectorUtils
.
getOverflowingChildrenOfElement
(
node
.
rawNode
)
]
.
map
(
overflowCausingChild
=
>
{
if
(
overflowCausingChild
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
overflowCausingChild
=
overflowCausingChild
.
parentElement
;
}
return
overflowCausingChild
;
}
)
;
return
this
.
attachElements
(
overflowCausingElements
)
;
}
getScrollableAncestorNode
(
overflowCausingNode
)
{
if
(
isNodeDead
(
overflowCausingNode
)
|
|
!
this
.
overflowCausingElementsMap
.
has
(
overflowCausingNode
.
rawNode
)
)
{
return
null
;
}
return
this
.
overflowCausingElementsMap
.
get
(
overflowCausingNode
.
rawNode
)
;
}
}
exports
.
WalkerActor
=
WalkerActor
;
