"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
loader
.
lazyRequireGetter
(
this
"
isShadowRoot
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
nodeFilterConstants
"
"
devtools
/
shared
/
dom
-
node
-
filter
-
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
standardTreeWalkerFilter
"
"
devtools
/
server
/
actors
/
inspector
/
utils
"
true
)
;
const
SKIP_TO_PARENT
=
"
SKIP_TO_PARENT
"
;
const
SKIP_TO_SIBLING
=
"
SKIP_TO_SIBLING
"
;
function
DocumentWalker
(
node
rootWin
{
whatToShow
=
nodeFilterConstants
.
SHOW_ALL
filter
=
standardTreeWalkerFilter
skipTo
=
SKIP_TO_PARENT
showAnonymousContent
=
true
}
=
{
}
)
{
if
(
Cu
.
isDeadWrapper
(
rootWin
)
|
|
!
rootWin
.
location
)
{
throw
new
Error
(
"
Got
an
invalid
root
window
in
DocumentWalker
"
)
;
}
this
.
walker
=
Cc
[
"
mozilla
.
org
/
inspector
/
deep
-
tree
-
walker
;
1
"
]
.
createInstance
(
Ci
.
inIDeepTreeWalker
)
;
this
.
walker
.
showAnonymousContent
=
showAnonymousContent
;
this
.
walker
.
showSubDocuments
=
true
;
this
.
walker
.
showDocumentsAsNodes
=
true
;
this
.
walker
.
init
(
rootWin
.
document
whatToShow
)
;
this
.
filter
=
filter
;
this
.
walker
.
currentNode
=
this
.
getStartingNode
(
node
skipTo
)
;
}
DocumentWalker
.
prototype
=
{
get
whatToShow
(
)
{
return
this
.
walker
.
whatToShow
;
}
get
currentNode
(
)
{
return
this
.
walker
.
currentNode
;
}
set
currentNode
(
val
)
{
this
.
walker
.
currentNode
=
val
;
}
parentNode
(
)
{
if
(
isShadowRoot
(
this
.
currentNode
)
)
{
this
.
currentNode
=
this
.
currentNode
.
host
;
return
this
.
currentNode
;
}
const
parentNode
=
this
.
currentNode
.
parentNode
;
if
(
parentNode
&
&
isShadowRoot
(
parentNode
)
)
{
this
.
currentNode
=
parentNode
;
return
this
.
currentNode
;
}
return
this
.
walker
.
parentNode
(
)
;
}
nextNode
(
)
{
const
node
=
this
.
walker
.
currentNode
;
if
(
!
node
)
{
return
null
;
}
let
nextNode
=
this
.
walker
.
nextNode
(
)
;
while
(
nextNode
&
&
this
.
isSkippedNode
(
nextNode
)
)
{
nextNode
=
this
.
walker
.
nextNode
(
)
;
}
return
nextNode
;
}
firstChild
(
)
{
const
node
=
this
.
walker
.
currentNode
;
if
(
!
node
)
{
return
null
;
}
let
firstChild
=
this
.
walker
.
firstChild
(
)
;
while
(
firstChild
&
&
this
.
isSkippedNode
(
firstChild
)
)
{
firstChild
=
this
.
walker
.
nextSibling
(
)
;
}
return
firstChild
;
}
lastChild
(
)
{
const
node
=
this
.
walker
.
currentNode
;
if
(
!
node
)
{
return
null
;
}
let
lastChild
=
this
.
walker
.
lastChild
(
)
;
while
(
lastChild
&
&
this
.
isSkippedNode
(
lastChild
)
)
{
lastChild
=
this
.
walker
.
previousSibling
(
)
;
}
return
lastChild
;
}
previousSibling
(
)
{
let
node
=
this
.
walker
.
previousSibling
(
)
;
while
(
node
&
&
this
.
isSkippedNode
(
node
)
)
{
node
=
this
.
walker
.
previousSibling
(
)
;
}
return
node
;
}
nextSibling
(
)
{
let
node
=
this
.
walker
.
nextSibling
(
)
;
while
(
node
&
&
this
.
isSkippedNode
(
node
)
)
{
node
=
this
.
walker
.
nextSibling
(
)
;
}
return
node
;
}
getStartingNode
(
node
skipTo
)
{
const
startingNode
=
node
;
if
(
skipTo
=
=
=
SKIP_TO_PARENT
)
{
while
(
node
&
&
this
.
isSkippedNode
(
node
)
)
{
node
=
node
.
parentNode
;
}
}
else
if
(
skipTo
=
=
=
SKIP_TO_SIBLING
)
{
node
=
this
.
getClosestAcceptedSibling
(
node
)
;
}
return
node
|
|
startingNode
;
}
getClosestAcceptedSibling
(
node
)
{
if
(
this
.
filter
(
node
)
=
=
=
nodeFilterConstants
.
FILTER_ACCEPT
)
{
return
node
;
}
let
previous
=
node
;
let
next
=
node
;
while
(
previous
|
|
next
)
{
previous
=
previous
?
.
previousSibling
;
next
=
next
?
.
nextSibling
;
if
(
previous
&
&
this
.
filter
(
previous
)
=
=
=
nodeFilterConstants
.
FILTER_ACCEPT
)
{
return
previous
;
}
if
(
next
&
&
this
.
filter
(
next
)
=
=
=
nodeFilterConstants
.
FILTER_ACCEPT
)
{
return
next
;
}
}
return
null
;
}
isSkippedNode
(
node
)
{
return
this
.
filter
(
node
)
=
=
=
nodeFilterConstants
.
FILTER_SKIP
;
}
}
;
exports
.
DocumentWalker
=
DocumentWalker
;
exports
.
SKIP_TO_PARENT
=
SKIP_TO_PARENT
;
exports
.
SKIP_TO_SIBLING
=
SKIP_TO_SIBLING
;
