"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
loader
.
lazyRequireGetter
(
this
"
colorUtils
"
"
devtools
/
shared
/
css
/
color
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
AsyncUtils
"
"
devtools
/
shared
/
async
-
utils
"
)
;
loader
.
lazyRequireGetter
(
this
"
flags
"
"
devtools
/
shared
/
flags
"
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsUtils
"
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
nodeFilterConstants
"
"
devtools
/
shared
/
dom
-
node
-
filter
-
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
isNativeAnonymous
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
actors
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getBackgroundFor
"
"
devtools
/
server
/
actors
/
accessibility
/
audit
/
contrast
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
loadSheetForBackgroundCalculation
"
"
devtools
/
server
/
actors
/
utils
/
accessibility
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
removeSheetForBackgroundCalculation
"
"
devtools
/
server
/
actors
/
utils
/
accessibility
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getAdjustedQuads
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getTextProperties
"
"
devtools
/
shared
/
accessibility
"
true
)
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
IMAGE_FETCHING_TIMEOUT
=
500
;
const
getNodeDisplayName
=
function
(
rawNode
)
{
if
(
rawNode
.
nodeName
&
&
!
rawNode
.
localName
)
{
return
rawNode
.
nodeName
;
}
return
(
rawNode
.
prefix
?
rawNode
.
prefix
+
"
:
"
:
"
"
)
+
rawNode
.
localName
;
}
;
function
getNodeGridFlexType
(
node
)
{
return
{
grid
:
getNodeGridType
(
node
)
flex
:
getNodeFlexType
(
node
)
}
;
}
function
getNodeFlexType
(
node
)
{
return
{
isContainer
:
node
.
getAsFlexContainer
&
&
!
!
node
.
getAsFlexContainer
(
)
isItem
:
!
!
node
.
parentFlexElement
}
;
}
function
getNodeGridType
(
node
)
{
return
{
isContainer
:
node
.
getGridFragments
&
&
node
.
getGridFragments
(
)
.
length
isItem
:
!
!
findGridParentContainerForNode
(
node
)
}
;
}
function
nodeDocument
(
node
)
{
if
(
Cu
.
isDeadWrapper
(
node
)
)
{
return
null
;
}
return
(
node
.
ownerDocument
|
|
(
node
.
nodeType
=
=
Node
.
DOCUMENT_NODE
?
node
:
null
)
)
;
}
function
isNodeDead
(
node
)
{
return
!
node
|
|
!
node
.
rawNode
|
|
Cu
.
isDeadWrapper
(
node
.
rawNode
)
;
}
function
isInXULDocument
(
el
)
{
const
doc
=
nodeDocument
(
el
)
;
return
doc
?
.
documentElement
&
&
doc
.
documentElement
.
namespaceURI
=
=
=
XUL_NS
;
}
function
standardTreeWalkerFilter
(
node
)
{
if
(
node
.
nodeName
=
=
=
"
_moz_generated_content_marker
"
|
|
node
.
nodeName
=
=
=
"
_moz_generated_content_before
"
|
|
node
.
nodeName
=
=
=
"
_moz_generated_content_after
"
)
{
return
nodeFilterConstants
.
FILTER_ACCEPT
;
}
if
(
isWhitespaceTextNode
(
node
)
)
{
return
nodeHasSize
(
node
)
?
nodeFilterConstants
.
FILTER_ACCEPT
:
nodeFilterConstants
.
FILTER_SKIP
;
}
if
(
!
isInXULDocument
(
node
)
&
&
isNativeAnonymous
(
node
)
)
{
return
nodeFilterConstants
.
FILTER_SKIP
;
}
return
nodeFilterConstants
.
FILTER_ACCEPT
;
}
function
noAnonymousContentTreeWalkerFilter
(
node
)
{
if
(
!
isInXULDocument
(
node
)
&
&
isNativeAnonymous
(
node
)
)
{
return
nodeFilterConstants
.
FILTER_SKIP
;
}
return
nodeFilterConstants
.
FILTER_ACCEPT
;
}
function
allAnonymousContentTreeWalkerFilter
(
node
)
{
if
(
isWhitespaceTextNode
(
node
)
)
{
return
nodeHasSize
(
node
)
?
nodeFilterConstants
.
FILTER_ACCEPT
:
nodeFilterConstants
.
FILTER_SKIP
;
}
return
nodeFilterConstants
.
FILTER_ACCEPT
;
}
function
scrollbarTreeWalkerFilter
(
node
)
{
if
(
node
.
nodeName
=
=
=
"
scrollbar
"
&
&
nodeHasSize
(
node
)
)
{
return
nodeFilterConstants
.
FILTER_ACCEPT
;
}
return
nodeFilterConstants
.
FILTER_SKIP
;
}
function
isWhitespaceTextNode
(
node
)
{
return
node
.
nodeType
=
=
Node
.
TEXT_NODE
&
&
!
/
[
^
\
s
]
/
.
exec
(
node
.
nodeValue
)
;
}
function
nodeHasSize
(
node
)
{
if
(
!
node
.
getBoxQuads
)
{
return
false
;
}
const
quads
=
node
.
getBoxQuads
(
{
createFramesForSuppressedWhitespace
:
false
}
)
;
return
quads
.
some
(
quad
=
>
{
const
bounds
=
quad
.
getBounds
(
)
;
return
bounds
.
width
&
&
bounds
.
height
;
}
)
;
}
function
ensureImageLoaded
(
image
timeout
)
{
const
{
HTMLImageElement
}
=
image
.
ownerGlobal
;
if
(
!
(
image
instanceof
HTMLImageElement
)
)
{
return
Promise
.
reject
(
"
image
must
be
an
HTMLImageELement
"
)
;
}
if
(
image
.
complete
)
{
return
Promise
.
resolve
(
)
;
}
const
onLoad
=
AsyncUtils
.
listenOnce
(
image
"
load
"
)
;
const
onError
=
AsyncUtils
.
listenOnce
(
image
"
error
"
)
.
then
(
(
)
=
>
{
return
Promise
.
reject
(
"
Image
'
"
+
image
.
src
+
"
'
failed
to
load
.
"
)
;
}
)
;
let
onAbort
=
new
Promise
(
(
)
=
>
{
}
)
;
if
(
!
flags
.
testing
)
{
onAbort
=
DevToolsUtils
.
waitForTime
(
timeout
)
.
then
(
(
)
=
>
{
return
Promise
.
reject
(
"
Image
'
"
+
image
.
src
+
"
'
took
too
long
to
load
.
"
)
;
}
)
;
}
return
Promise
.
race
(
[
onLoad
onError
onAbort
]
)
;
}
const
imageToImageData
=
async
function
(
node
maxDim
)
{
const
{
HTMLCanvasElement
HTMLImageElement
}
=
node
.
ownerGlobal
;
const
isImg
=
node
instanceof
HTMLImageElement
;
const
isCanvas
=
node
instanceof
HTMLCanvasElement
;
if
(
!
isImg
&
&
!
isCanvas
)
{
throw
new
Error
(
"
node
is
not
a
<
canvas
>
or
<
img
>
element
.
"
)
;
}
if
(
isImg
)
{
await
ensureImageLoaded
(
node
IMAGE_FETCHING_TIMEOUT
)
;
}
let
resizeRatio
=
1
;
const
imgWidth
=
node
.
naturalWidth
|
|
node
.
width
;
const
imgHeight
=
node
.
naturalHeight
|
|
node
.
height
;
const
imgMax
=
Math
.
max
(
imgWidth
imgHeight
)
;
if
(
maxDim
&
&
imgMax
>
maxDim
)
{
resizeRatio
=
maxDim
/
imgMax
;
}
let
imageData
;
if
(
isImg
&
&
node
.
src
.
startsWith
(
"
data
:
"
)
&
&
resizeRatio
=
=
=
1
)
{
imageData
=
node
.
src
;
}
else
{
const
canvas
=
node
.
ownerDocument
.
createElementNS
(
XHTML_NS
"
canvas
"
)
;
canvas
.
width
=
imgWidth
*
resizeRatio
;
canvas
.
height
=
imgHeight
*
resizeRatio
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
drawImage
(
node
0
0
canvas
.
width
canvas
.
height
)
;
imageData
=
canvas
.
toDataURL
(
"
image
/
png
"
)
;
}
return
{
data
:
imageData
size
:
{
naturalWidth
:
imgWidth
naturalHeight
:
imgHeight
resized
:
resizeRatio
!
=
=
1
}
}
;
}
;
function
getClosestBackgroundColor
(
node
)
{
let
current
=
node
;
while
(
current
)
{
const
computedStyle
=
CssLogic
.
getComputedStyle
(
current
)
;
if
(
computedStyle
)
{
const
currentStyle
=
computedStyle
.
getPropertyValue
(
"
background
-
color
"
)
;
if
(
colorUtils
.
isValidCSSColor
(
currentStyle
)
)
{
const
currentCssColor
=
new
colorUtils
.
CssColor
(
currentStyle
)
;
if
(
!
currentCssColor
.
isTransparent
(
)
)
{
return
currentCssColor
.
rgba
;
}
}
}
current
=
current
.
parentNode
;
}
return
"
rgba
(
255
255
255
1
)
"
;
}
function
getClosestBackgroundImage
(
node
)
{
let
current
=
node
;
while
(
current
)
{
const
computedStyle
=
CssLogic
.
getComputedStyle
(
current
)
;
if
(
computedStyle
)
{
const
currentBackgroundImage
=
computedStyle
.
getPropertyValue
(
"
background
-
image
"
)
;
if
(
currentBackgroundImage
!
=
=
"
none
"
)
{
return
currentBackgroundImage
;
}
}
current
=
current
.
parentNode
;
}
return
"
none
"
;
}
function
findGridParentContainerForNode
(
node
)
{
try
{
while
(
(
node
=
node
.
parentNode
)
)
{
const
display
=
node
.
ownerGlobal
.
getComputedStyle
(
node
)
.
display
;
if
(
display
.
includes
(
"
grid
"
)
)
{
return
node
;
}
else
if
(
display
=
=
=
"
contents
"
)
{
continue
;
}
break
;
}
}
catch
(
e
)
{
}
return
null
;
}
async
function
getBackgroundColor
(
{
rawNode
:
node
walker
}
)
{
if
(
node
.
nodeType
!
=
Node
.
ELEMENT_NODE
|
|
node
.
childNodes
.
length
>
1
|
|
!
node
.
firstChild
)
{
return
{
value
:
colorUtils
.
colorToRGBA
(
getClosestBackgroundColor
(
node
)
true
true
)
}
;
}
const
bounds
=
getAdjustedQuads
(
node
.
ownerGlobal
node
.
firstChild
"
content
"
)
[
0
]
.
bounds
;
if
(
!
bounds
)
{
return
{
value
:
colorUtils
.
colorToRGBA
(
getClosestBackgroundColor
(
node
)
true
true
)
}
;
}
const
docWalker
=
walker
.
getDocumentWalker
(
node
)
;
const
firstChild
=
docWalker
.
firstChild
(
)
;
if
(
!
firstChild
|
|
docWalker
.
nextSibling
(
)
|
|
firstChild
.
nodeType
!
=
=
Node
.
TEXT_NODE
)
{
return
{
value
:
colorUtils
.
colorToRGBA
(
getClosestBackgroundColor
(
node
)
true
true
)
}
;
}
const
win
=
node
.
ownerGlobal
;
loadSheetForBackgroundCalculation
(
win
)
;
const
computedStyle
=
CssLogic
.
getComputedStyle
(
node
)
;
const
props
=
computedStyle
?
getTextProperties
(
computedStyle
)
:
null
;
if
(
!
props
)
{
return
{
value
:
colorUtils
.
colorToRGBA
(
getClosestBackgroundColor
(
node
)
true
true
)
}
;
}
const
bgColor
=
await
getBackgroundFor
(
node
{
bounds
win
convertBoundsRelativeToViewport
:
false
size
:
props
.
size
isBoldText
:
props
.
isBoldText
}
)
;
removeSheetForBackgroundCalculation
(
win
)
;
return
(
bgColor
|
|
{
value
:
colorUtils
.
colorToRGBA
(
getClosestBackgroundColor
(
node
)
true
true
)
}
)
;
}
module
.
exports
=
{
allAnonymousContentTreeWalkerFilter
isWhitespaceTextNode
findGridParentContainerForNode
getBackgroundColor
getClosestBackgroundColor
getClosestBackgroundImage
getNodeDisplayName
getNodeGridFlexType
imageToImageData
isNodeDead
nodeDocument
scrollbarTreeWalkerFilter
standardTreeWalkerFilter
noAnonymousContentTreeWalkerFilter
}
;
