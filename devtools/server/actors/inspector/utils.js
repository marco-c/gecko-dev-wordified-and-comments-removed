"
use
strict
"
;
const
{
Ci
Cu
}
=
require
(
"
chrome
"
)
;
loader
.
lazyRequireGetter
(
this
"
AsyncUtils
"
"
devtools
/
shared
/
async
-
utils
"
)
;
loader
.
lazyRequireGetter
(
this
"
flags
"
"
devtools
/
shared
/
flags
"
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsUtils
"
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
nodeFilterConstants
"
"
devtools
/
shared
/
dom
-
node
-
filter
-
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
isNativeAnonymous
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isXBLAnonymous
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
IMAGE_FETCHING_TIMEOUT
=
500
;
const
getNodeDisplayName
=
function
(
rawNode
)
{
if
(
rawNode
.
nodeName
&
&
!
rawNode
.
localName
)
{
return
rawNode
.
nodeName
;
}
return
(
rawNode
.
prefix
?
rawNode
.
prefix
+
"
:
"
:
"
"
)
+
rawNode
.
localName
;
}
;
function
nodeDocument
(
node
)
{
if
(
Cu
.
isDeadWrapper
(
node
)
)
{
return
null
;
}
return
node
.
ownerDocument
|
|
(
node
.
nodeType
=
=
Ci
.
nsIDOMNode
.
DOCUMENT_NODE
?
node
:
null
)
;
}
function
isNodeDead
(
node
)
{
return
!
node
|
|
!
node
.
rawNode
|
|
Cu
.
isDeadWrapper
(
node
.
rawNode
)
;
}
function
isInXULDocument
(
el
)
{
let
doc
=
nodeDocument
(
el
)
;
return
doc
&
&
doc
.
documentElement
&
&
doc
.
documentElement
.
namespaceURI
=
=
=
XUL_NS
;
}
function
standardTreeWalkerFilter
(
node
)
{
if
(
node
.
nodeName
=
=
=
"
_moz_generated_content_before
"
|
|
node
.
nodeName
=
=
=
"
_moz_generated_content_after
"
)
{
return
nodeFilterConstants
.
FILTER_ACCEPT
;
}
if
(
isWhitespaceTextNode
(
node
)
)
{
return
nodeHasSize
(
node
)
?
nodeFilterConstants
.
FILTER_ACCEPT
:
nodeFilterConstants
.
FILTER_SKIP
;
}
if
(
!
isInXULDocument
(
node
)
&
&
(
isXBLAnonymous
(
node
)
|
|
isNativeAnonymous
(
node
)
)
)
{
return
nodeFilterConstants
.
FILTER_SKIP
;
}
return
nodeFilterConstants
.
FILTER_ACCEPT
;
}
function
allAnonymousContentTreeWalkerFilter
(
node
)
{
if
(
isWhitespaceTextNode
(
node
)
)
{
return
nodeHasSize
(
node
)
?
nodeFilterConstants
.
FILTER_ACCEPT
:
nodeFilterConstants
.
FILTER_SKIP
;
}
return
nodeFilterConstants
.
FILTER_ACCEPT
;
}
function
isWhitespaceTextNode
(
node
)
{
return
node
.
nodeType
=
=
Ci
.
nsIDOMNode
.
TEXT_NODE
&
&
!
/
[
^
\
s
]
/
.
exec
(
node
.
nodeValue
)
;
}
function
nodeHasSize
(
node
)
{
if
(
!
node
.
getBoxQuads
)
{
return
false
;
}
let
quads
=
node
.
getBoxQuads
(
)
;
return
quads
.
length
&
&
quads
.
some
(
quad
=
>
quad
.
bounds
.
width
&
&
quad
.
bounds
.
height
)
;
}
function
ensureImageLoaded
(
image
timeout
)
{
let
{
HTMLImageElement
}
=
image
.
ownerGlobal
;
if
(
!
(
image
instanceof
HTMLImageElement
)
)
{
return
Promise
.
reject
(
"
image
must
be
an
HTMLImageELement
"
)
;
}
if
(
image
.
complete
)
{
return
Promise
.
resolve
(
)
;
}
let
onLoad
=
AsyncUtils
.
listenOnce
(
image
"
load
"
)
;
let
onError
=
AsyncUtils
.
listenOnce
(
image
"
error
"
)
.
then
(
(
)
=
>
{
return
Promise
.
reject
(
"
Image
'
"
+
image
.
src
+
"
'
failed
to
load
.
"
)
;
}
)
;
let
onAbort
=
new
Promise
(
(
)
=
>
{
}
)
;
if
(
!
flags
.
testing
)
{
onAbort
=
DevToolsUtils
.
waitForTime
(
timeout
)
.
then
(
(
)
=
>
{
return
Promise
.
reject
(
"
Image
'
"
+
image
.
src
+
"
'
took
too
long
to
load
.
"
)
;
}
)
;
}
return
Promise
.
race
(
[
onLoad
onError
onAbort
]
)
;
}
const
imageToImageData
=
async
function
(
node
maxDim
)
{
let
{
HTMLCanvasElement
HTMLImageElement
}
=
node
.
ownerGlobal
;
let
isImg
=
node
instanceof
HTMLImageElement
;
let
isCanvas
=
node
instanceof
HTMLCanvasElement
;
if
(
!
isImg
&
&
!
isCanvas
)
{
throw
new
Error
(
"
node
is
not
a
<
canvas
>
or
<
img
>
element
.
"
)
;
}
if
(
isImg
)
{
await
ensureImageLoaded
(
node
IMAGE_FETCHING_TIMEOUT
)
;
}
let
resizeRatio
=
1
;
let
imgWidth
=
node
.
naturalWidth
|
|
node
.
width
;
let
imgHeight
=
node
.
naturalHeight
|
|
node
.
height
;
let
imgMax
=
Math
.
max
(
imgWidth
imgHeight
)
;
if
(
maxDim
&
&
imgMax
>
maxDim
)
{
resizeRatio
=
maxDim
/
imgMax
;
}
let
imageData
;
if
(
isImg
&
&
node
.
src
.
startsWith
(
"
data
:
"
)
&
&
resizeRatio
=
=
=
1
)
{
imageData
=
node
.
src
;
}
else
{
let
canvas
=
node
.
ownerDocument
.
createElementNS
(
XHTML_NS
"
canvas
"
)
;
canvas
.
width
=
imgWidth
*
resizeRatio
;
canvas
.
height
=
imgHeight
*
resizeRatio
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
drawImage
(
node
0
0
canvas
.
width
canvas
.
height
)
;
imageData
=
canvas
.
toDataURL
(
"
image
/
png
"
)
;
}
return
{
data
:
imageData
size
:
{
naturalWidth
:
imgWidth
naturalHeight
:
imgHeight
resized
:
resizeRatio
!
=
=
1
}
}
;
}
;
module
.
exports
=
{
allAnonymousContentTreeWalkerFilter
getNodeDisplayName
imageToImageData
isNodeDead
nodeDocument
standardTreeWalkerFilter
}
;
