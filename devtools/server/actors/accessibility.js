"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Actor
ActorClassWithSpec
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
events
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
accessibleSpec
accessibleWalkerSpec
accessibilitySpec
}
=
require
(
"
devtools
/
shared
/
specs
/
accessibility
"
)
;
const
{
isXUL
}
=
require
(
"
devtools
/
server
/
actors
/
highlighters
/
utils
/
markup
"
)
;
const
{
isWindowIncluded
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
{
CustomHighlighterActor
register
}
=
require
(
"
devtools
/
server
/
actors
/
highlighters
"
)
;
const
PREF_ACCESSIBILITY_FORCE_DISABLED
=
"
accessibility
.
force_disabled
"
;
const
nsIAccessibleEvent
=
Ci
.
nsIAccessibleEvent
;
const
nsIAccessibleStateChangeEvent
=
Ci
.
nsIAccessibleStateChangeEvent
;
const
nsIPropertyElement
=
Ci
.
nsIPropertyElement
;
const
nsIAccessibleRole
=
Ci
.
nsIAccessibleRole
;
const
{
EVENT_TEXT_CHANGED
EVENT_TEXT_INSERTED
EVENT_TEXT_REMOVED
EVENT_ACCELERATOR_CHANGE
EVENT_ACTION_CHANGE
EVENT_DEFACTION_CHANGE
EVENT_DESCRIPTION_CHANGE
EVENT_DOCUMENT_ATTRIBUTES_CHANGED
EVENT_HELP_CHANGE
EVENT_HIDE
EVENT_NAME_CHANGE
EVENT_OBJECT_ATTRIBUTE_CHANGED
EVENT_REORDER
EVENT_STATE_CHANGE
EVENT_TEXT_ATTRIBUTE_CHANGED
EVENT_VALUE_CHANGE
}
=
nsIAccessibleEvent
;
const
NAME_FROM_SUBTREE_RULE_ROLES
=
new
Set
(
[
nsIAccessibleRole
.
ROLE_BUTTONDROPDOWN
nsIAccessibleRole
.
ROLE_BUTTONDROPDOWNGRID
nsIAccessibleRole
.
ROLE_BUTTONMENU
nsIAccessibleRole
.
ROLE_CELL
nsIAccessibleRole
.
ROLE_CHECKBUTTON
nsIAccessibleRole
.
ROLE_CHECK_MENU_ITEM
nsIAccessibleRole
.
ROLE_CHECK_RICH_OPTION
nsIAccessibleRole
.
ROLE_COLUMN
nsIAccessibleRole
.
ROLE_COLUMNHEADER
nsIAccessibleRole
.
ROLE_COMBOBOX_OPTION
nsIAccessibleRole
.
ROLE_DEFINITION
nsIAccessibleRole
.
ROLE_GRID_CELL
nsIAccessibleRole
.
ROLE_HEADING
nsIAccessibleRole
.
ROLE_HELPBALLOON
nsIAccessibleRole
.
ROLE_HTML_CONTAINER
nsIAccessibleRole
.
ROLE_KEY
nsIAccessibleRole
.
ROLE_LABEL
nsIAccessibleRole
.
ROLE_LINK
nsIAccessibleRole
.
ROLE_LISTITEM
nsIAccessibleRole
.
ROLE_MATHML_IDENTIFIER
nsIAccessibleRole
.
ROLE_MATHML_NUMBER
nsIAccessibleRole
.
ROLE_MATHML_OPERATOR
nsIAccessibleRole
.
ROLE_MATHML_TEXT
nsIAccessibleRole
.
ROLE_MATHML_STRING_LITERAL
nsIAccessibleRole
.
ROLE_MATHML_GLYPH
nsIAccessibleRole
.
ROLE_MENUITEM
nsIAccessibleRole
.
ROLE_OPTION
nsIAccessibleRole
.
ROLE_OUTLINEITEM
nsIAccessibleRole
.
ROLE_PAGETAB
nsIAccessibleRole
.
ROLE_PARENT_MENUITEM
nsIAccessibleRole
.
ROLE_PUSHBUTTON
nsIAccessibleRole
.
ROLE_RADIOBUTTON
nsIAccessibleRole
.
ROLE_RADIO_MENU_ITEM
nsIAccessibleRole
.
ROLE_RICH_OPTION
nsIAccessibleRole
.
ROLE_ROW
nsIAccessibleRole
.
ROLE_ROWHEADER
nsIAccessibleRole
.
ROLE_SUMMARY
nsIAccessibleRole
.
ROLE_SWITCH
nsIAccessibleRole
.
ROLE_TABLE_COLUMN_HEADER
nsIAccessibleRole
.
ROLE_TABLE_ROW_HEADER
nsIAccessibleRole
.
ROLE_TEAR_OFF_MENU_ITEM
nsIAccessibleRole
.
ROLE_TERM
nsIAccessibleRole
.
ROLE_TOGGLE_BUTTON
nsIAccessibleRole
.
ROLE_TOOLTIP
]
)
;
const
IS_OSX
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
register
(
"
AccessibleHighlighter
"
"
accessible
"
)
;
register
(
"
XULWindowAccessibleHighlighter
"
"
xul
-
accessible
"
)
;
function
isDefunct
(
accessible
)
{
if
(
!
Services
.
appinfo
.
accessibilityEnabled
)
{
return
true
;
}
let
defunct
=
false
;
try
{
const
extraState
=
{
}
;
accessible
.
getState
(
{
}
extraState
)
;
defunct
=
!
!
(
extraState
.
value
&
Ci
.
nsIAccessibleStates
.
EXT_STATE_DEFUNCT
)
;
}
catch
(
e
)
{
defunct
=
true
;
}
return
defunct
;
}
function
isStale
(
accessible
)
{
const
extraState
=
{
}
;
accessible
.
getState
(
{
}
extraState
)
;
return
!
!
(
extraState
.
value
&
Ci
.
nsIAccessibleStates
.
EXT_STATE_STALE
)
;
}
const
AccessibleActor
=
ActorClassWithSpec
(
accessibleSpec
{
initialize
(
walker
rawAccessible
)
{
Actor
.
prototype
.
initialize
.
call
(
this
walker
.
conn
)
;
this
.
walker
=
walker
;
this
.
rawAccessible
=
rawAccessible
;
Object
.
defineProperty
(
this
"
isDefunct
"
{
get
(
)
{
const
defunct
=
isDefunct
(
this
.
rawAccessible
)
;
if
(
defunct
)
{
delete
this
.
isDefunct
;
this
.
isDefunct
=
true
;
return
this
.
isDefunct
;
}
return
defunct
;
}
configurable
:
true
}
)
;
}
marshallPool
(
)
{
return
this
.
walker
;
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
walker
=
null
;
this
.
rawAccessible
=
null
;
}
get
role
(
)
{
if
(
this
.
isDefunct
)
{
return
null
;
}
return
this
.
walker
.
a11yService
.
getStringRole
(
this
.
rawAccessible
.
role
)
;
}
get
name
(
)
{
if
(
this
.
isDefunct
)
{
return
null
;
}
return
this
.
rawAccessible
.
name
;
}
get
value
(
)
{
if
(
this
.
isDefunct
)
{
return
null
;
}
return
this
.
rawAccessible
.
value
;
}
get
description
(
)
{
if
(
this
.
isDefunct
)
{
return
null
;
}
return
this
.
rawAccessible
.
description
;
}
get
help
(
)
{
if
(
this
.
isDefunct
)
{
return
null
;
}
return
this
.
rawAccessible
.
help
;
}
get
keyboardShortcut
(
)
{
if
(
this
.
isDefunct
)
{
return
null
;
}
return
this
.
rawAccessible
.
accessKey
|
|
this
.
rawAccessible
.
keyboardShortcut
;
}
get
childCount
(
)
{
if
(
this
.
isDefunct
)
{
return
0
;
}
return
this
.
rawAccessible
.
childCount
;
}
get
domNodeType
(
)
{
if
(
this
.
isDefunct
)
{
return
0
;
}
return
this
.
rawAccessible
.
DOMNode
?
this
.
rawAccessible
.
DOMNode
.
nodeType
:
0
;
}
get
parentAcc
(
)
{
if
(
this
.
isDefunct
)
{
return
null
;
}
return
this
.
walker
.
addRef
(
this
.
rawAccessible
.
parent
)
;
}
children
(
)
{
const
children
=
[
]
;
if
(
this
.
isDefunct
)
{
return
children
;
}
for
(
let
child
=
this
.
rawAccessible
.
firstChild
;
child
;
child
=
child
.
nextSibling
)
{
children
.
push
(
this
.
walker
.
addRef
(
child
)
)
;
}
return
children
;
}
get
indexInParent
(
)
{
if
(
this
.
isDefunct
)
{
return
-
1
;
}
try
{
return
this
.
rawAccessible
.
indexInParent
;
}
catch
(
e
)
{
return
-
1
;
}
}
get
actions
(
)
{
const
actions
=
[
]
;
if
(
this
.
isDefunct
)
{
return
actions
;
}
for
(
let
i
=
0
;
i
<
this
.
rawAccessible
.
actionCount
;
i
+
+
)
{
actions
.
push
(
this
.
rawAccessible
.
getActionDescription
(
i
)
)
;
}
return
actions
;
}
get
states
(
)
{
if
(
this
.
isDefunct
)
{
return
[
]
;
}
const
state
=
{
}
;
const
extState
=
{
}
;
this
.
rawAccessible
.
getState
(
state
extState
)
;
return
[
.
.
.
this
.
walker
.
a11yService
.
getStringStates
(
state
.
value
extState
.
value
)
]
;
}
get
attributes
(
)
{
if
(
this
.
isDefunct
|
|
!
this
.
rawAccessible
.
attributes
)
{
return
{
}
;
}
const
attributes
=
{
}
;
const
attrsEnum
=
this
.
rawAccessible
.
attributes
.
enumerate
(
)
;
while
(
attrsEnum
.
hasMoreElements
(
)
)
{
const
{
key
value
}
=
attrsEnum
.
getNext
(
)
.
QueryInterface
(
nsIPropertyElement
)
;
attributes
[
key
]
=
value
;
}
return
attributes
;
}
get
bounds
(
)
{
if
(
this
.
isDefunct
)
{
return
null
;
}
let
x
=
{
}
y
=
{
}
w
=
{
}
h
=
{
}
;
try
{
this
.
rawAccessible
.
getBoundsInCSSPixels
(
x
y
w
h
)
;
x
=
x
.
value
;
y
=
y
.
value
;
w
=
w
.
value
;
h
=
h
.
value
;
}
catch
(
e
)
{
return
null
;
}
return
{
x
y
w
h
}
;
}
form
(
)
{
return
{
actor
:
this
.
actorID
role
:
this
.
role
name
:
this
.
name
value
:
this
.
value
description
:
this
.
description
help
:
this
.
help
keyboardShortcut
:
this
.
keyboardShortcut
childCount
:
this
.
childCount
domNodeType
:
this
.
domNodeType
indexInParent
:
this
.
indexInParent
states
:
this
.
states
actions
:
this
.
actions
attributes
:
this
.
attributes
}
;
}
}
)
;
const
AccessibleWalkerActor
=
ActorClassWithSpec
(
accessibleWalkerSpec
{
initialize
(
conn
targetActor
)
{
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
targetActor
=
targetActor
;
this
.
refMap
=
new
Map
(
)
;
this
.
setA11yServiceGetter
(
)
;
this
.
onPick
=
this
.
onPick
.
bind
(
this
)
;
this
.
onHovered
=
this
.
onHovered
.
bind
(
this
)
;
this
.
onKey
=
this
.
onKey
.
bind
(
this
)
;
this
.
highlighter
=
CustomHighlighterActor
(
this
isXUL
(
this
.
rootWin
)
?
"
XULWindowAccessibleHighlighter
"
:
"
AccessibleHighlighter
"
)
;
}
setA11yServiceGetter
(
)
{
DevToolsUtils
.
defineLazyGetter
(
this
"
a11yService
"
(
)
=
>
{
Services
.
obs
.
addObserver
(
this
"
accessible
-
event
"
)
;
return
Cc
[
"
mozilla
.
org
/
accessibilityService
;
1
"
]
.
getService
(
Ci
.
nsIAccessibilityService
)
;
}
)
;
}
get
rootWin
(
)
{
return
this
.
targetActor
&
&
this
.
targetActor
.
window
;
}
get
rootDoc
(
)
{
return
this
.
targetActor
&
&
this
.
targetActor
.
window
.
document
;
}
reset
(
)
{
try
{
Services
.
obs
.
removeObserver
(
this
"
accessible
-
event
"
)
;
}
catch
(
e
)
{
}
this
.
cancelPick
(
)
;
if
(
this
.
refMap
.
size
>
0
)
{
try
{
if
(
this
.
rootDoc
)
{
this
.
purgeSubtree
(
this
.
getRawAccessibleFor
(
this
.
rootDoc
)
this
.
rootDoc
)
;
}
}
catch
(
e
)
{
}
finally
{
this
.
refMap
.
clear
(
)
;
}
}
this
.
_childrenPromise
=
null
;
delete
this
.
a11yService
;
this
.
setA11yServiceGetter
(
)
;
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
reset
(
)
;
this
.
highlighter
.
destroy
(
)
;
this
.
highlighter
=
null
;
this
.
targetActor
=
null
;
this
.
refMap
=
null
;
}
getRef
(
rawAccessible
)
{
return
this
.
refMap
.
get
(
rawAccessible
)
;
}
addRef
(
rawAccessible
)
{
let
actor
=
this
.
refMap
.
get
(
rawAccessible
)
;
if
(
actor
)
{
return
actor
;
}
actor
=
new
AccessibleActor
(
this
rawAccessible
)
;
this
.
manage
(
actor
)
;
this
.
refMap
.
set
(
rawAccessible
actor
)
;
return
actor
;
}
purgeSubtree
(
rawAccessible
rawNode
)
{
if
(
!
rawAccessible
)
{
return
;
}
const
actor
=
this
.
getRef
(
rawAccessible
)
;
if
(
actor
&
&
rawAccessible
&
&
!
actor
.
isDefunct
)
{
for
(
let
child
=
rawAccessible
.
firstChild
;
child
;
child
=
child
.
nextSibling
)
{
this
.
purgeSubtree
(
child
)
;
}
}
this
.
refMap
.
delete
(
rawAccessible
)
;
if
(
actor
)
{
events
.
emit
(
this
"
accessible
-
destroy
"
actor
)
;
actor
.
destroy
(
)
;
}
if
(
rawNode
&
&
rawNode
=
=
=
this
.
rootDoc
)
{
this
.
refMap
.
clear
(
)
;
}
}
async
children
(
)
{
if
(
this
.
_childrenPromise
)
{
return
this
.
_childrenPromise
;
}
this
.
_childrenPromise
=
Promise
.
all
(
[
this
.
getDocument
(
)
]
)
;
const
children
=
await
this
.
_childrenPromise
;
this
.
_childrenPromise
=
null
;
return
children
;
}
getDocument
(
)
{
if
(
!
this
.
rootDoc
|
|
!
this
.
rootDoc
.
documentElement
)
{
return
this
.
once
(
"
document
-
ready
"
)
.
then
(
docAcc
=
>
this
.
addRef
(
docAcc
)
)
;
}
if
(
isXUL
(
this
.
rootWin
)
)
{
const
doc
=
this
.
addRef
(
this
.
getRawAccessibleFor
(
this
.
rootDoc
)
)
;
return
Promise
.
resolve
(
doc
)
;
}
const
doc
=
this
.
getRawAccessibleFor
(
this
.
rootDoc
)
;
if
(
isStale
(
doc
)
)
{
return
this
.
once
(
"
document
-
ready
"
)
.
then
(
docAcc
=
>
this
.
addRef
(
docAcc
)
)
;
}
return
Promise
.
resolve
(
this
.
addRef
(
doc
)
)
;
}
getAccessibleFor
(
domNode
)
{
return
this
.
getDocument
(
)
.
then
(
(
)
=
>
this
.
addRef
(
this
.
getRawAccessibleFor
(
domNode
.
rawNode
)
)
)
;
}
getRawAccessibleFor
(
rawNode
)
{
if
(
!
Services
.
appinfo
.
accessibilityEnabled
)
{
return
null
;
}
return
this
.
a11yService
.
getAccessibleFor
(
rawNode
)
;
}
async
getAncestry
(
accessible
)
{
if
(
accessible
.
indexInParent
=
=
=
-
1
)
{
return
[
]
;
}
const
doc
=
await
this
.
getDocument
(
)
;
const
ancestry
=
[
]
;
try
{
let
parent
=
accessible
;
while
(
parent
&
&
(
parent
=
parent
.
parentAcc
)
&
&
parent
!
=
doc
)
{
ancestry
.
push
(
parent
)
;
}
ancestry
.
push
(
doc
)
;
}
catch
(
error
)
{
throw
new
Error
(
Failed
to
get
ancestor
for
{
accessible
}
:
{
error
}
)
;
}
return
ancestry
.
map
(
parent
=
>
(
{
accessible
:
parent
children
:
parent
.
children
(
)
}
)
)
;
}
observe
(
subject
)
{
const
event
=
subject
.
QueryInterface
(
nsIAccessibleEvent
)
;
const
rawAccessible
=
event
.
accessible
;
const
accessible
=
this
.
getRef
(
rawAccessible
)
;
if
(
(
rawAccessible
instanceof
Ci
.
nsIAccessibleDocument
)
&
&
!
accessible
)
{
const
rootDocAcc
=
this
.
getRawAccessibleFor
(
this
.
rootDoc
)
;
if
(
rawAccessible
=
=
=
rootDocAcc
&
&
!
isStale
(
rawAccessible
)
)
{
this
.
purgeSubtree
(
rawAccessible
event
.
DOMNode
)
;
events
.
emit
(
this
"
document
-
ready
"
rawAccessible
)
;
}
}
switch
(
event
.
eventType
)
{
case
EVENT_STATE_CHANGE
:
const
{
state
isEnabled
}
=
event
.
QueryInterface
(
nsIAccessibleStateChangeEvent
)
;
const
isBusy
=
state
&
Ci
.
nsIAccessibleStates
.
STATE_BUSY
;
if
(
accessible
)
{
if
(
isBusy
&
&
isEnabled
)
{
if
(
rawAccessible
instanceof
Ci
.
nsIAccessibleDocument
)
{
this
.
purgeSubtree
(
rawAccessible
event
.
DOMNode
)
;
}
return
;
}
events
.
emit
(
accessible
"
states
-
change
"
accessible
.
states
)
;
}
break
;
case
EVENT_NAME_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
name
-
change
"
rawAccessible
.
name
event
.
DOMNode
=
=
this
.
rootDoc
?
undefined
:
this
.
getRef
(
rawAccessible
.
parent
)
this
)
;
}
break
;
case
EVENT_VALUE_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
value
-
change
"
rawAccessible
.
value
)
;
}
break
;
case
EVENT_DESCRIPTION_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
description
-
change
"
rawAccessible
.
description
)
;
}
break
;
case
EVENT_HELP_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
help
-
change
"
rawAccessible
.
help
)
;
}
break
;
case
EVENT_REORDER
:
if
(
accessible
)
{
accessible
.
children
(
)
.
forEach
(
child
=
>
events
.
emit
(
child
"
index
-
in
-
parent
-
change
"
child
.
indexInParent
)
)
;
events
.
emit
(
accessible
"
reorder
"
rawAccessible
.
childCount
this
)
;
}
break
;
case
EVENT_HIDE
:
this
.
purgeSubtree
(
rawAccessible
)
;
break
;
case
EVENT_DEFACTION_CHANGE
:
case
EVENT_ACTION_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
actions
-
change
"
accessible
.
actions
)
;
}
break
;
case
EVENT_TEXT_CHANGED
:
case
EVENT_TEXT_INSERTED
:
case
EVENT_TEXT_REMOVED
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
text
-
change
"
this
)
;
if
(
NAME_FROM_SUBTREE_RULE_ROLES
.
has
(
rawAccessible
.
role
)
)
{
events
.
emit
(
accessible
"
name
-
change
"
rawAccessible
.
name
event
.
DOMNode
=
=
this
.
rootDoc
?
undefined
:
this
.
getRef
(
rawAccessible
.
parent
)
this
)
;
}
}
break
;
case
EVENT_DOCUMENT_ATTRIBUTES_CHANGED
:
case
EVENT_OBJECT_ATTRIBUTE_CHANGED
:
case
EVENT_TEXT_ATTRIBUTE_CHANGED
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
attributes
-
change
"
accessible
.
attributes
)
;
}
break
;
case
EVENT_ACCELERATOR_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
shortcut
-
change
"
accessible
.
keyboardShortcut
)
;
}
break
;
default
:
break
;
}
}
highlightAccessible
(
accessible
options
=
{
}
)
{
const
bounds
=
accessible
.
bounds
;
if
(
!
bounds
)
{
return
false
;
}
return
this
.
highlighter
.
show
(
{
rawNode
:
accessible
.
rawAccessible
.
DOMNode
}
{
.
.
.
options
.
.
.
bounds
}
)
;
}
unhighlight
(
)
{
this
.
highlighter
.
hide
(
)
;
}
_isPicking
:
false
_currentAccessible
:
null
_isEventAllowed
:
function
(
{
view
}
)
{
return
this
.
rootWin
instanceof
Ci
.
nsIDOMChromeWindow
|
|
isWindowIncluded
(
this
.
rootWin
view
)
;
}
_preventContentEvent
(
event
)
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
async
onPick
(
event
)
{
if
(
!
this
.
_isPicking
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
if
(
event
.
shiftKey
)
{
if
(
!
this
.
_currentAccessible
)
{
this
.
_currentAccessible
=
await
this
.
_findAndAttachAccessible
(
event
)
;
}
events
.
emit
(
this
"
picker
-
accessible
-
previewed
"
this
.
_currentAccessible
)
;
return
;
}
this
.
_stopPickerListeners
(
)
;
this
.
_isPicking
=
false
;
if
(
!
this
.
_currentAccessible
)
{
this
.
_currentAccessible
=
await
this
.
_findAndAttachAccessible
(
event
)
;
}
events
.
emit
(
this
"
picker
-
accessible
-
picked
"
this
.
_currentAccessible
)
;
}
async
onHovered
(
event
)
{
if
(
!
this
.
_isPicking
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
const
accessible
=
await
this
.
_findAndAttachAccessible
(
event
)
;
if
(
!
accessible
)
{
return
;
}
if
(
this
.
_currentAccessible
!
=
=
accessible
)
{
const
{
bounds
}
=
accessible
;
if
(
bounds
)
{
this
.
highlighter
.
show
(
{
rawNode
:
event
.
originalTarget
|
|
event
.
target
}
bounds
)
;
}
events
.
emit
(
this
"
picker
-
accessible
-
hovered
"
accessible
)
;
this
.
_currentAccessible
=
accessible
;
}
}
onKey
(
event
)
{
if
(
!
this
.
_currentAccessible
|
|
!
this
.
_isPicking
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
switch
(
event
.
keyCode
)
{
case
event
.
DOM_VK_RETURN
:
this
.
_onPick
(
event
)
;
break
;
case
event
.
DOM_VK_ESCAPE
:
this
.
cancelPick
(
)
;
events
.
emit
(
this
"
picker
-
accessible
-
canceled
"
)
;
break
;
case
event
.
DOM_VK_C
:
if
(
(
IS_OSX
&
&
event
.
metaKey
&
&
event
.
altKey
)
|
|
(
!
IS_OSX
&
&
event
.
ctrlKey
&
&
event
.
shiftKey
)
)
{
this
.
cancelPick
(
)
;
events
.
emit
(
this
"
picker
-
accessible
-
canceled
"
)
;
}
break
;
default
:
break
;
}
}
pick
:
function
(
)
{
if
(
!
this
.
_isPicking
)
{
this
.
_isPicking
=
true
;
this
.
_startPickerListeners
(
)
;
}
}
pickAndFocus
:
function
(
)
{
this
.
pick
(
)
;
this
.
rootWin
.
focus
(
)
;
}
async
_findAndAttachAccessible
(
event
)
{
let
target
=
event
.
originalTarget
|
|
event
.
target
;
let
rawAccessible
;
while
(
!
rawAccessible
&
&
target
)
{
rawAccessible
=
this
.
getRawAccessibleFor
(
target
)
;
target
=
target
.
parentNode
;
}
if
(
!
rawAccessible
|
|
isDefunct
(
rawAccessible
)
|
|
rawAccessible
.
indexInParent
<
0
)
{
return
null
;
}
const
doc
=
await
this
.
getDocument
(
)
;
const
accessible
=
this
.
addRef
(
rawAccessible
)
;
try
{
let
parent
=
accessible
;
while
(
parent
&
&
parent
!
=
doc
)
{
parent
=
parent
.
parentAcc
;
}
}
catch
(
error
)
{
throw
new
Error
(
Failed
to
get
ancestor
for
{
accessible
}
:
{
error
}
)
;
}
return
accessible
;
}
_startPickerListeners
:
function
(
)
{
const
target
=
this
.
targetActor
.
chromeEventHandler
;
target
.
addEventListener
(
"
mousemove
"
this
.
onHovered
true
)
;
target
.
addEventListener
(
"
click
"
this
.
onPick
true
)
;
target
.
addEventListener
(
"
mousedown
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
mouseup
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
dblclick
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
keydown
"
this
.
onKey
true
)
;
target
.
addEventListener
(
"
keyup
"
this
.
_preventContentEvent
true
)
;
}
_stopPickerListeners
:
function
(
)
{
const
target
=
this
.
targetActor
.
chromeEventHandler
;
if
(
!
target
)
{
return
;
}
target
.
removeEventListener
(
"
mousemove
"
this
.
onHovered
true
)
;
target
.
removeEventListener
(
"
click
"
this
.
onPick
true
)
;
target
.
removeEventListener
(
"
mousedown
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
mouseup
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
dblclick
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
keydown
"
this
.
onKey
true
)
;
target
.
removeEventListener
(
"
keyup
"
this
.
_preventContentEvent
true
)
;
}
cancelPick
:
function
(
)
{
this
.
highlighter
.
hide
(
)
;
if
(
this
.
_isPicking
)
{
this
.
_stopPickerListeners
(
)
;
this
.
_isPicking
=
false
;
this
.
_currentAccessible
=
null
;
}
}
}
)
;
const
AccessibilityActor
=
ActorClassWithSpec
(
accessibilitySpec
{
initialize
(
conn
targetActor
)
{
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
initializedDeferred
=
defer
(
)
;
if
(
DebuggerServer
.
isInChildProcess
)
{
this
.
_msgName
=
debug
:
{
this
.
conn
.
prefix
}
accessibility
;
this
.
conn
.
setupInParent
(
{
module
:
"
devtools
/
server
/
actors
/
accessibility
-
parent
"
setupParent
:
"
setupParentProcess
"
}
)
;
this
.
onMessage
=
this
.
onMessage
.
bind
(
this
)
;
this
.
messageManager
.
addMessageListener
(
{
this
.
_msgName
}
:
event
this
.
onMessage
)
;
}
else
{
this
.
userPref
=
Services
.
prefs
.
getIntPref
(
PREF_ACCESSIBILITY_FORCE_DISABLED
)
;
Services
.
obs
.
addObserver
(
this
"
a11y
-
consumers
-
changed
"
)
;
Services
.
prefs
.
addObserver
(
PREF_ACCESSIBILITY_FORCE_DISABLED
this
)
;
this
.
initializedDeferred
.
resolve
(
)
;
}
Services
.
obs
.
addObserver
(
this
"
a11y
-
init
-
or
-
shutdown
"
)
;
this
.
targetActor
=
targetActor
;
}
bootstrap
(
)
{
return
this
.
initializedDeferred
.
promise
.
then
(
(
)
=
>
(
{
enabled
:
this
.
enabled
canBeEnabled
:
this
.
canBeEnabled
canBeDisabled
:
this
.
canBeDisabled
}
)
)
;
}
get
enabled
(
)
{
return
Services
.
appinfo
.
accessibilityEnabled
;
}
get
canBeEnabled
(
)
{
if
(
DebuggerServer
.
isInChildProcess
)
{
return
this
.
_canBeEnabled
;
}
return
Services
.
prefs
.
getIntPref
(
PREF_ACCESSIBILITY_FORCE_DISABLED
)
<
1
;
}
get
canBeDisabled
(
)
{
if
(
DebuggerServer
.
isInChildProcess
)
{
return
this
.
_canBeDisabled
;
}
else
if
(
!
this
.
enabled
)
{
return
true
;
}
const
{
PlatformAPI
}
=
JSON
.
parse
(
this
.
walker
.
a11yService
.
getConsumers
(
)
)
;
return
!
PlatformAPI
;
}
get
messageManager
(
)
{
if
(
!
DebuggerServer
.
isInChildProcess
)
{
throw
new
Error
(
"
Message
manager
should
only
be
used
when
actor
is
in
child
process
.
"
)
;
}
return
this
.
conn
.
parentMessageManager
;
}
onMessage
(
msg
)
{
const
{
topic
data
}
=
msg
.
data
;
switch
(
topic
)
{
case
"
initialized
"
:
this
.
_canBeEnabled
=
data
.
canBeEnabled
;
this
.
_canBeDisabled
=
data
.
canBeDisabled
;
if
(
!
data
.
enabled
&
&
this
.
enabled
&
&
data
.
canBeEnabled
)
{
this
.
messageManager
.
sendAsyncMessage
(
this
.
_msgName
{
action
:
"
enable
"
}
)
;
}
this
.
initializedDeferred
.
resolve
(
)
;
break
;
case
"
can
-
be
-
disabled
-
change
"
:
this
.
_canBeDisabled
=
data
;
events
.
emit
(
this
"
can
-
be
-
disabled
-
change
"
this
.
canBeDisabled
)
;
break
;
case
"
can
-
be
-
enabled
-
change
"
:
this
.
_canBeEnabled
=
data
;
events
.
emit
(
this
"
can
-
be
-
enabled
-
change
"
this
.
canBeEnabled
)
;
break
;
default
:
break
;
}
}
async
enable
(
)
{
if
(
this
.
enabled
|
|
!
this
.
canBeEnabled
)
{
return
;
}
const
initPromise
=
this
.
once
(
"
init
"
)
;
if
(
DebuggerServer
.
isInChildProcess
)
{
this
.
messageManager
.
sendAsyncMessage
(
this
.
_msgName
{
action
:
"
enable
"
}
)
;
}
else
{
this
.
walker
.
a11yService
;
}
await
initPromise
;
}
async
disable
(
)
{
if
(
!
this
.
enabled
|
|
!
this
.
canBeDisabled
)
{
return
;
}
this
.
disabling
=
true
;
const
shutdownPromise
=
this
.
once
(
"
shutdown
"
)
;
if
(
DebuggerServer
.
isInChildProcess
)
{
this
.
messageManager
.
sendAsyncMessage
(
this
.
_msgName
{
action
:
"
disable
"
}
)
;
}
else
{
Services
.
prefs
.
setIntPref
(
PREF_ACCESSIBILITY_FORCE_DISABLED
1
)
;
Services
.
prefs
.
setIntPref
(
PREF_ACCESSIBILITY_FORCE_DISABLED
this
.
userPref
)
;
}
await
shutdownPromise
;
delete
this
.
disabling
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
"
a11y
-
init
-
or
-
shutdown
"
)
{
const
enabled
=
data
=
=
=
"
1
"
;
if
(
enabled
&
&
this
.
enabled
)
{
events
.
emit
(
this
"
init
"
)
;
}
else
if
(
!
enabled
&
&
!
this
.
enabled
)
{
if
(
this
.
walker
)
{
this
.
walker
.
reset
(
)
;
}
events
.
emit
(
this
"
shutdown
"
)
;
}
}
else
if
(
topic
=
=
=
"
a11y
-
consumers
-
changed
"
)
{
const
{
PlatformAPI
}
=
JSON
.
parse
(
data
)
;
events
.
emit
(
this
"
can
-
be
-
disabled
-
change
"
!
PlatformAPI
)
;
}
else
if
(
!
this
.
disabling
&
&
topic
=
=
=
"
nsPref
:
changed
"
&
&
data
=
=
=
PREF_ACCESSIBILITY_FORCE_DISABLED
)
{
events
.
emit
(
this
"
can
-
be
-
enabled
-
change
"
this
.
canBeEnabled
)
;
}
}
getWalker
(
)
{
if
(
!
this
.
walker
)
{
this
.
walker
=
new
AccessibleWalkerActor
(
this
.
conn
this
.
targetActor
)
;
}
return
this
.
walker
;
}
async
destroy
(
)
{
if
(
this
.
destroyed
)
{
await
this
.
destroyed
;
return
;
}
let
resolver
;
this
.
destroyed
=
new
Promise
(
resolve
=
>
{
resolver
=
resolve
;
}
)
;
if
(
this
.
walker
)
{
this
.
walker
.
reset
(
)
;
}
Services
.
obs
.
removeObserver
(
this
"
a11y
-
init
-
or
-
shutdown
"
)
;
if
(
DebuggerServer
.
isInChildProcess
)
{
this
.
messageManager
.
removeMessageListener
(
{
this
.
_msgName
}
:
event
this
.
onMessage
)
;
}
else
{
Services
.
obs
.
removeObserver
(
this
"
a11y
-
consumers
-
changed
"
)
;
Services
.
prefs
.
removeObserver
(
PREF_ACCESSIBILITY_FORCE_DISABLED
this
)
;
}
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
walker
=
null
;
this
.
targetActor
=
null
;
resolver
(
)
;
}
}
)
;
exports
.
AccessibleActor
=
AccessibleActor
;
exports
.
AccessibleWalkerActor
=
AccessibleWalkerActor
;
exports
.
AccessibilityActor
=
AccessibilityActor
;
