"
use
strict
"
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
CallWatcherActor
}
=
require
(
"
devtools
/
server
/
actors
/
call
-
watcher
"
)
;
const
{
CallWatcherFront
}
=
require
(
"
devtools
/
shared
/
fronts
/
call
-
watcher
"
)
;
const
{
WebGLPrimitiveCounter
}
=
require
(
"
devtools
/
server
/
actors
/
canvas
/
primitive
"
)
;
const
{
frameSnapshotSpec
canvasSpec
CANVAS_CONTEXTS
ANIMATION_GENERATORS
LOOP_GENERATORS
}
=
require
(
"
devtools
/
shared
/
specs
/
canvas
"
)
;
const
{
CanvasFront
}
=
require
(
"
devtools
/
shared
/
fronts
/
canvas
"
)
;
var
FrameSnapshotActor
=
protocol
.
ActorClassWithSpec
(
frameSnapshotSpec
{
initialize
:
function
(
conn
{
canvas
calls
screenshot
primitive
}
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
_contentCanvas
=
canvas
;
this
.
_functionCalls
=
calls
;
this
.
_animationFrameEndScreenshot
=
screenshot
;
this
.
_primitive
=
primitive
;
}
getOverview
:
function
(
)
{
return
{
calls
:
this
.
_functionCalls
thumbnails
:
this
.
_functionCalls
.
map
(
e
=
>
e
.
_thumbnail
)
.
filter
(
e
=
>
!
!
e
)
screenshot
:
this
.
_animationFrameEndScreenshot
primitive
:
{
tris
:
this
.
_primitive
.
tris
vertices
:
this
.
_primitive
.
vertices
points
:
this
.
_primitive
.
points
lines
:
this
.
_primitive
.
lines
}
}
;
}
generateScreenshotFor
:
function
(
functionCall
)
{
const
global
=
functionCall
.
details
.
global
;
const
canvas
=
this
.
_contentCanvas
;
const
calls
=
this
.
_functionCalls
;
const
index
=
calls
.
indexOf
(
functionCall
)
;
const
replayData
=
ContextUtils
.
replayAnimationFrame
(
{
contextType
:
global
canvas
:
canvas
calls
:
calls
first
:
0
last
:
index
}
)
;
const
{
replayContext
replayContextScaling
lastDrawCallIndex
doCleanup
}
=
replayData
;
const
[
left
top
width
height
]
=
replayData
.
replayViewport
;
let
screenshot
;
if
(
global
=
=
"
WebGLRenderingContext
"
)
{
screenshot
=
ContextUtils
.
getPixelsForWebGL
(
replayContext
left
top
width
height
)
;
screenshot
.
flipped
=
true
;
}
else
if
(
global
=
=
"
CanvasRenderingContext2D
"
)
{
screenshot
=
ContextUtils
.
getPixelsFor2D
(
replayContext
left
top
width
height
)
;
screenshot
.
flipped
=
false
;
}
doCleanup
(
)
;
screenshot
.
scaling
=
replayContextScaling
;
screenshot
.
index
=
lastDrawCallIndex
;
return
screenshot
;
}
}
)
;
exports
.
CanvasActor
=
protocol
.
ActorClassWithSpec
(
canvasSpec
{
_animationContainsDrawCall
:
false
initialize
:
function
(
conn
tabActor
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
tabActor
=
tabActor
;
this
.
_webGLPrimitiveCounter
=
new
WebGLPrimitiveCounter
(
tabActor
)
;
this
.
_onContentFunctionCall
=
this
.
_onContentFunctionCall
.
bind
(
this
)
;
}
destroy
:
function
(
conn
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
conn
)
;
this
.
_webGLPrimitiveCounter
.
destroy
(
)
;
this
.
finalize
(
)
;
}
setup
:
function
(
{
reload
}
)
{
if
(
this
.
_initialized
)
{
if
(
reload
)
{
this
.
tabActor
.
window
.
location
.
reload
(
)
;
}
return
;
}
this
.
_initialized
=
true
;
this
.
_callWatcher
=
new
CallWatcherActor
(
this
.
conn
this
.
tabActor
)
;
this
.
_callWatcher
.
onCall
=
this
.
_onContentFunctionCall
;
this
.
_callWatcher
.
setup
(
{
tracedGlobals
:
CANVAS_CONTEXTS
tracedFunctions
:
[
.
.
.
ANIMATION_GENERATORS
.
.
.
LOOP_GENERATORS
]
performReload
:
reload
storeCalls
:
true
}
)
;
}
finalize
:
function
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
false
;
this
.
_callWatcher
.
finalize
(
)
;
this
.
_callWatcher
=
null
;
}
isInitialized
:
function
(
)
{
return
!
!
this
.
_initialized
;
}
isRecording
:
function
(
)
{
return
!
!
this
.
_callWatcher
.
isRecording
(
)
;
}
recordAnimationFrame
:
function
(
)
{
if
(
this
.
_callWatcher
.
isRecording
(
)
)
{
return
this
.
_currentAnimationFrameSnapshot
.
promise
;
}
this
.
_recordingContainsDrawCall
=
false
;
this
.
_callWatcher
.
eraseRecording
(
)
;
this
.
_callWatcher
.
initTimestampEpoch
(
)
;
this
.
_webGLPrimitiveCounter
.
resetCounts
(
)
;
this
.
_callWatcher
.
resumeRecording
(
)
;
const
deferred
=
this
.
_currentAnimationFrameSnapshot
=
defer
(
)
;
return
deferred
.
promise
;
}
stopRecordingAnimationFrame
:
function
(
)
{
if
(
!
this
.
_callWatcher
.
isRecording
(
)
)
{
return
;
}
this
.
_animationStarted
=
false
;
this
.
_callWatcher
.
pauseRecording
(
)
;
this
.
_callWatcher
.
eraseRecording
(
)
;
this
.
_currentAnimationFrameSnapshot
.
resolve
(
null
)
;
this
.
_currentAnimationFrameSnapshot
=
null
;
}
_onContentFunctionCall
:
function
(
functionCall
)
{
const
{
window
name
args
}
=
functionCall
.
details
;
inplaceShallowCloneArrays
(
args
window
)
;
if
(
CanvasFront
.
ANIMATION_GENERATORS
.
has
(
name
)
)
{
this
.
_handleAnimationFrame
(
functionCall
)
;
return
;
}
if
(
CanvasFront
.
LOOP_GENERATORS
.
has
(
name
)
)
{
this
.
_handleAnimationFrame
(
functionCall
)
;
return
;
}
if
(
CanvasFront
.
DRAW_CALLS
.
has
(
name
)
&
&
this
.
_animationStarted
)
{
this
.
_handleDrawCall
(
functionCall
)
;
this
.
_webGLPrimitiveCounter
.
handleDrawPrimitive
(
functionCall
)
;
}
}
_handleAnimationFrame
:
function
(
functionCall
)
{
if
(
!
this
.
_animationStarted
)
{
this
.
_handleAnimationFrameBegin
(
)
;
}
else
if
(
this
.
_animationContainsDrawCall
)
{
this
.
_handleAnimationFrameEnd
(
functionCall
)
;
}
}
_handleAnimationFrameBegin
:
function
(
)
{
this
.
_callWatcher
.
eraseRecording
(
)
;
this
.
_animationStarted
=
true
;
}
_handleAnimationFrameEnd
:
function
(
)
{
const
functionCalls
=
this
.
_callWatcher
.
pauseRecording
(
)
;
this
.
_callWatcher
.
eraseRecording
(
)
;
this
.
_animationContainsDrawCall
=
false
;
const
index
=
this
.
_lastDrawCallIndex
;
const
width
=
this
.
_lastContentCanvasWidth
;
const
height
=
this
.
_lastContentCanvasHeight
;
const
flipped
=
!
!
this
.
_lastThumbnailFlipped
;
const
pixels
=
ContextUtils
.
getPixelStorage
(
)
[
"
8bit
"
]
;
const
primitiveResult
=
this
.
_webGLPrimitiveCounter
.
getCounts
(
)
;
const
animationFrameEndScreenshot
=
{
index
:
index
width
:
width
height
:
height
scaling
:
1
flipped
:
flipped
pixels
:
pixels
.
subarray
(
0
width
*
height
*
4
)
}
;
const
frameSnapshot
=
new
FrameSnapshotActor
(
this
.
conn
{
canvas
:
this
.
_lastDrawCallCanvas
calls
:
functionCalls
screenshot
:
animationFrameEndScreenshot
primitive
:
{
tris
:
primitiveResult
.
tris
vertices
:
primitiveResult
.
vertices
points
:
primitiveResult
.
points
lines
:
primitiveResult
.
lines
}
}
)
;
this
.
_currentAnimationFrameSnapshot
.
resolve
(
frameSnapshot
)
;
this
.
_currentAnimationFrameSnapshot
=
null
;
this
.
_animationStarted
=
false
;
}
_handleDrawCall
:
function
(
functionCall
)
{
const
functionCalls
=
this
.
_callWatcher
.
pauseRecording
(
)
;
const
caller
=
functionCall
.
details
.
caller
;
const
global
=
functionCall
.
details
.
global
;
const
contentCanvas
=
this
.
_lastDrawCallCanvas
=
caller
.
canvas
;
const
index
=
this
.
_lastDrawCallIndex
=
functionCalls
.
indexOf
(
functionCall
)
;
const
w
=
this
.
_lastContentCanvasWidth
=
contentCanvas
.
width
;
const
h
=
this
.
_lastContentCanvasHeight
=
contentCanvas
.
height
;
const
dimensions
=
CanvasFront
.
THUMBNAIL_SIZE
;
let
thumbnail
;
this
.
_animationContainsDrawCall
=
true
;
if
(
global
=
=
"
WebGLRenderingContext
"
)
{
const
framebufferBinding
=
caller
.
getParameter
(
caller
.
FRAMEBUFFER_BINDING
)
;
if
(
framebufferBinding
=
=
null
)
{
thumbnail
=
ContextUtils
.
getPixelsForWebGL
(
caller
0
0
w
h
dimensions
)
;
thumbnail
.
flipped
=
this
.
_lastThumbnailFlipped
=
true
;
thumbnail
.
index
=
index
;
}
}
else
if
(
global
=
=
"
CanvasRenderingContext2D
"
)
{
thumbnail
=
ContextUtils
.
getPixelsFor2D
(
caller
0
0
w
h
dimensions
)
;
thumbnail
.
flipped
=
this
.
_lastThumbnailFlipped
=
false
;
thumbnail
.
index
=
index
;
}
functionCall
.
_thumbnail
=
thumbnail
;
this
.
_callWatcher
.
resumeRecording
(
)
;
}
}
)
;
var
ContextUtils
=
{
getWebGLContext
:
function
(
canvas
)
{
return
canvas
.
getContext
(
"
webgl
"
)
|
|
canvas
.
getContext
(
"
experimental
-
webgl
"
)
;
}
getPixelsForWebGL
:
function
(
gl
srcX
=
0
srcY
=
0
srcWidth
=
gl
.
canvas
.
width
srcHeight
=
gl
.
canvas
.
height
dstHeight
=
srcHeight
)
{
const
contentPixels
=
ContextUtils
.
getPixelStorage
(
srcWidth
srcHeight
)
;
const
{
"
8bit
"
:
charView
"
32bit
"
:
intView
}
=
contentPixels
;
gl
.
readPixels
(
srcX
srcY
srcWidth
srcHeight
gl
.
RGBA
gl
.
UNSIGNED_BYTE
charView
)
;
return
this
.
resizePixels
(
intView
srcWidth
srcHeight
dstHeight
)
;
}
getPixelsFor2D
:
function
(
ctx
srcX
=
0
srcY
=
0
srcWidth
=
ctx
.
canvas
.
width
srcHeight
=
ctx
.
canvas
.
height
dstHeight
=
srcHeight
)
{
const
{
data
}
=
ctx
.
getImageData
(
srcX
srcY
srcWidth
srcHeight
)
;
const
{
"
32bit
"
:
intView
}
=
ContextUtils
.
usePixelStorage
(
data
.
buffer
)
;
return
this
.
resizePixels
(
intView
srcWidth
srcHeight
dstHeight
)
;
}
resizePixels
:
function
(
srcPixels
srcWidth
srcHeight
dstHeight
)
{
const
screenshotRatio
=
dstHeight
/
srcHeight
;
const
dstWidth
=
(
srcWidth
*
screenshotRatio
)
|
0
;
const
dstPixels
=
new
Uint32Array
(
dstWidth
*
dstHeight
)
;
let
isTransparent
=
true
;
for
(
let
dstX
=
0
;
dstX
<
dstWidth
;
dstX
+
+
)
{
for
(
let
dstY
=
0
;
dstY
<
dstHeight
;
dstY
+
+
)
{
const
srcX
=
(
dstX
/
screenshotRatio
)
|
0
;
const
srcY
=
(
dstY
/
screenshotRatio
)
|
0
;
const
cPos
=
srcX
+
srcWidth
*
srcY
;
const
dPos
=
dstX
+
dstWidth
*
dstY
;
const
color
=
dstPixels
[
dPos
]
=
srcPixels
[
cPos
]
;
if
(
color
)
{
isTransparent
=
false
;
}
}
}
return
{
width
:
dstWidth
height
:
dstHeight
pixels
:
isTransparent
?
[
]
:
new
Uint8Array
(
dstPixels
.
buffer
)
}
;
}
replayAnimationFrame
:
function
(
{
contextType
canvas
calls
first
last
}
)
{
let
w
=
canvas
.
width
;
let
h
=
canvas
.
height
;
let
replayContext
;
let
replayContextScaling
;
let
customViewport
;
let
customFramebuffer
;
let
lastDrawCallIndex
=
-
1
;
let
doCleanup
=
(
)
=
>
{
}
;
if
(
contextType
=
=
"
WebGLRenderingContext
"
)
{
const
scaling
=
Math
.
min
(
CanvasFront
.
WEBGL_SCREENSHOT_MAX_HEIGHT
h
)
/
h
;
replayContextScaling
=
scaling
;
w
=
(
w
*
scaling
)
|
0
;
h
=
(
h
*
scaling
)
|
0
;
const
gl
=
replayContext
=
this
.
getWebGLContext
(
canvas
)
;
const
{
newFramebuffer
oldFramebuffer
}
=
this
.
createBoundFramebuffer
(
gl
w
h
)
;
customFramebuffer
=
newFramebuffer
;
const
{
newViewport
oldViewport
}
=
this
.
setCustomViewport
(
gl
w
h
)
;
customViewport
=
newViewport
;
doCleanup
=
(
)
=
>
{
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
oldFramebuffer
)
;
gl
.
viewport
.
apply
(
gl
oldViewport
)
;
}
;
}
else
if
(
contextType
=
=
"
CanvasRenderingContext2D
"
)
{
const
contentDocument
=
canvas
.
ownerDocument
;
const
replayCanvas
=
contentDocument
.
createElement
(
"
canvas
"
)
;
replayCanvas
.
width
=
w
;
replayCanvas
.
height
=
h
;
replayContext
=
replayCanvas
.
getContext
(
"
2d
"
)
;
replayContextScaling
=
1
;
customViewport
=
[
0
0
w
h
]
;
}
for
(
let
i
=
first
;
i
<
=
last
;
i
+
+
)
{
const
{
type
name
args
}
=
calls
[
i
]
.
details
;
if
(
name
=
=
"
bindFramebuffer
"
&
&
args
[
1
]
=
=
null
)
{
replayContext
.
bindFramebuffer
(
replayContext
.
FRAMEBUFFER
customFramebuffer
)
;
continue
;
}
if
(
name
=
=
"
viewport
"
)
{
const
framebufferBinding
=
replayContext
.
getParameter
(
replayContext
.
FRAMEBUFFER_BINDING
)
;
if
(
framebufferBinding
=
=
customFramebuffer
)
{
replayContext
.
viewport
.
apply
(
replayContext
customViewport
)
;
continue
;
}
}
if
(
type
=
=
CallWatcherFront
.
METHOD_FUNCTION
)
{
replayContext
[
name
]
.
apply
(
replayContext
args
)
;
}
else
if
(
type
=
=
CallWatcherFront
.
SETTER_FUNCTION
)
{
replayContext
[
name
]
=
args
;
}
if
(
CanvasFront
.
DRAW_CALLS
.
has
(
name
)
)
{
lastDrawCallIndex
=
i
;
}
}
return
{
replayContext
:
replayContext
replayContextScaling
:
replayContextScaling
replayViewport
:
customViewport
lastDrawCallIndex
:
lastDrawCallIndex
doCleanup
:
doCleanup
}
;
}
getPixelStorage
:
function
(
w
=
0
h
=
0
)
{
const
storage
=
this
.
_currentPixelStorage
;
if
(
storage
&
&
storage
[
"
32bit
"
]
.
length
>
=
w
*
h
)
{
return
storage
;
}
return
this
.
usePixelStorage
(
new
ArrayBuffer
(
w
*
h
*
4
)
)
;
}
usePixelStorage
:
function
(
buffer
)
{
const
array8bit
=
new
Uint8Array
(
buffer
)
;
const
array32bit
=
new
Uint32Array
(
buffer
)
;
this
.
_currentPixelStorage
=
{
"
8bit
"
:
array8bit
"
32bit
"
:
array32bit
}
;
return
this
.
_currentPixelStorage
;
}
createBoundFramebuffer
:
function
(
gl
width
height
)
{
const
oldFramebuffer
=
gl
.
getParameter
(
gl
.
FRAMEBUFFER_BINDING
)
;
const
oldRenderbufferBinding
=
gl
.
getParameter
(
gl
.
RENDERBUFFER_BINDING
)
;
const
oldTextureBinding
=
gl
.
getParameter
(
gl
.
TEXTURE_BINDING_2D
)
;
const
newFramebuffer
=
gl
.
createFramebuffer
(
)
;
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
newFramebuffer
)
;
const
colorBuffer
=
gl
.
createTexture
(
)
;
gl
.
bindTexture
(
gl
.
TEXTURE_2D
colorBuffer
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
gl
.
NEAREST
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
gl
.
NEAREST
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_S
gl
.
CLAMP_TO_EDGE
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_T
gl
.
CLAMP_TO_EDGE
)
;
gl
.
texImage2D
(
gl
.
TEXTURE_2D
0
gl
.
RGBA
width
height
0
gl
.
RGBA
gl
.
UNSIGNED_BYTE
null
)
;
const
depthBuffer
=
gl
.
createRenderbuffer
(
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
depthBuffer
)
;
gl
.
renderbufferStorage
(
gl
.
RENDERBUFFER
gl
.
DEPTH_COMPONENT16
width
height
)
;
gl
.
framebufferTexture2D
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
TEXTURE_2D
colorBuffer
0
)
;
gl
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
DEPTH_ATTACHMENT
gl
.
RENDERBUFFER
depthBuffer
)
;
gl
.
bindTexture
(
gl
.
TEXTURE_2D
oldTextureBinding
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
oldRenderbufferBinding
)
;
return
{
oldFramebuffer
newFramebuffer
}
;
}
setCustomViewport
:
function
(
gl
width
height
)
{
const
oldViewport
=
XPCNativeWrapper
.
unwrap
(
gl
.
getParameter
(
gl
.
VIEWPORT
)
)
;
const
newViewport
=
[
0
0
width
height
]
;
gl
.
viewport
.
apply
(
gl
newViewport
)
;
return
{
oldViewport
newViewport
}
;
}
}
;
function
inplaceShallowCloneArrays
(
functionArguments
contentWindow
)
{
const
{
Object
Array
ArrayBuffer
}
=
contentWindow
;
functionArguments
.
forEach
(
(
arg
index
store
)
=
>
{
if
(
arg
instanceof
Array
)
{
store
[
index
]
=
arg
.
slice
(
)
;
}
if
(
arg
instanceof
Object
&
&
arg
.
buffer
instanceof
ArrayBuffer
)
{
store
[
index
]
=
new
arg
.
constructor
(
arg
)
;
}
}
)
;
}
