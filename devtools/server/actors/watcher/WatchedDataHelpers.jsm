"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
WatchedDataHelpers
"
]
;
if
(
typeof
module
=
=
"
object
"
)
{
loader
.
lazyRequireGetter
(
this
"
validateBreakpointLocation
"
"
devtools
/
shared
/
validate
-
breakpoint
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
validateEventBreakpoint
"
"
devtools
/
server
/
actors
/
utils
/
event
-
breakpoints
"
true
)
;
}
else
{
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
validateBreakpointLocation
"
(
)
=
>
{
return
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
validate
-
breakpoint
.
jsm
"
)
.
validateBreakpointLocation
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
validateEventBreakpoint
"
(
)
=
>
{
const
{
loader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
return
loader
.
require
(
"
devtools
/
server
/
actors
/
utils
/
event
-
breakpoints
"
)
.
validateEventBreakpoint
;
}
)
;
}
const
SUPPORTED_DATA
=
{
BREAKPOINTS
:
"
breakpoints
"
XHR_BREAKPOINTS
:
"
xhr
-
breakpoints
"
EVENT_BREAKPOINTS
:
"
event
-
breakpoints
"
RESOURCES
:
"
resources
"
TARGET_CONFIGURATION
:
"
target
-
configuration
"
THREAD_CONFIGURATION
:
"
thread
-
configuration
"
TARGETS
:
"
targets
"
}
;
const
DATA_KEY_FUNCTION
=
{
[
SUPPORTED_DATA
.
BREAKPOINTS
]
:
function
(
{
location
}
)
{
validateBreakpointLocation
(
location
)
;
const
{
sourceUrl
sourceId
line
column
}
=
location
;
return
{
sourceUrl
}
:
{
sourceId
}
:
{
line
}
:
{
column
}
;
}
[
SUPPORTED_DATA
.
TARGET_CONFIGURATION
]
:
function
(
{
key
}
)
{
return
key
;
}
[
SUPPORTED_DATA
.
THREAD_CONFIGURATION
]
:
function
(
{
key
}
)
{
return
key
;
}
[
SUPPORTED_DATA
.
XHR_BREAKPOINTS
]
:
function
(
{
path
method
}
)
{
if
(
typeof
path
!
=
"
string
"
)
{
throw
new
Error
(
XHR
Breakpoints
expect
to
have
path
string
got
{
typeof
path
}
instead
.
)
;
}
if
(
typeof
method
!
=
"
string
"
)
{
throw
new
Error
(
XHR
Breakpoints
expect
to
have
method
string
got
{
typeof
method
}
instead
.
)
;
}
return
{
path
}
:
{
method
}
;
}
[
SUPPORTED_DATA
.
EVENT_BREAKPOINTS
]
:
function
(
id
)
{
if
(
typeof
id
!
=
"
string
"
)
{
throw
new
Error
(
Event
Breakpoints
expect
the
id
to
be
a
string
got
{
typeof
id
}
instead
.
)
;
}
if
(
!
validateEventBreakpoint
(
id
)
)
{
throw
new
Error
(
The
id
string
should
be
a
valid
event
breakpoint
id
{
id
}
is
not
.
)
;
}
return
id
;
}
}
;
function
idFunction
(
v
)
{
if
(
typeof
v
!
=
"
string
"
)
{
throw
new
Error
(
Expect
data
entry
values
to
be
string
or
be
using
custom
data
key
functions
.
Got
{
typeof
v
}
type
instead
.
)
;
}
return
v
;
}
const
WatchedDataHelpers
=
{
SUPPORTED_DATA
addWatchedDataEntry
(
watchedData
type
entries
)
{
const
toBeAdded
=
[
]
;
const
keyFunction
=
DATA_KEY_FUNCTION
[
type
]
|
|
idFunction
;
for
(
const
entry
of
entries
)
{
const
existingIndex
=
watchedData
[
type
]
.
findIndex
(
existingEntry
=
>
{
return
keyFunction
(
existingEntry
)
=
=
=
keyFunction
(
entry
)
;
}
)
;
if
(
existingIndex
=
=
=
-
1
)
{
toBeAdded
.
push
(
entry
)
;
}
else
{
watchedData
[
type
]
[
existingIndex
]
=
entry
;
}
}
watchedData
[
type
]
.
push
(
.
.
.
toBeAdded
)
;
}
removeWatchedDataEntry
(
watchedData
type
entries
)
{
let
includesAtLeastOne
=
false
;
const
keyFunction
=
DATA_KEY_FUNCTION
[
type
]
|
|
idFunction
;
for
(
const
entry
of
entries
)
{
const
idx
=
watchedData
[
type
]
.
findIndex
(
existingEntry
=
>
{
return
keyFunction
(
existingEntry
)
=
=
=
keyFunction
(
entry
)
;
}
)
;
if
(
idx
!
=
=
-
1
)
{
watchedData
[
type
]
.
splice
(
idx
1
)
;
includesAtLeastOne
=
true
;
}
}
if
(
!
includesAtLeastOne
)
{
return
false
;
}
return
true
;
}
}
;
if
(
typeof
module
=
=
"
object
"
)
{
module
.
exports
.
WatchedDataHelpers
=
WatchedDataHelpers
;
}
