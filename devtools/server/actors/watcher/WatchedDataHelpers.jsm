"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
WatchedDataHelpers
"
]
;
const
SUPPORTED_DATA
=
{
BREAKPOINTS
:
"
breakpoints
"
RESOURCES
:
"
resources
"
TARGETS
:
"
targets
"
}
;
const
DATA_KEY_FUNCTION
=
{
[
SUPPORTED_DATA
.
BREAKPOINTS
]
:
function
(
{
location
:
{
sourceUrl
sourceId
line
column
}
}
)
{
if
(
!
sourceUrl
&
&
!
sourceId
)
{
throw
new
Error
(
Breakpoints
expect
to
have
either
a
sourceUrl
or
a
sourceId
.
)
;
}
if
(
sourceUrl
&
&
typeof
sourceUrl
!
=
"
string
"
)
{
throw
new
Error
(
Breakpoints
expect
to
have
sourceUrl
string
got
{
typeof
sourceUrl
}
instead
.
)
;
}
if
(
sourceId
&
&
typeof
sourceId
!
=
"
string
"
)
{
throw
new
Error
(
Breakpoints
expect
to
have
sourceId
string
got
{
typeof
sourceId
}
instead
.
)
;
}
if
(
typeof
line
!
=
"
number
"
)
{
throw
new
Error
(
Breakpoints
expect
to
have
line
number
got
{
typeof
line
}
instead
.
)
;
}
if
(
typeof
column
!
=
"
number
"
)
{
throw
new
Error
(
Breakpoints
expect
to
have
column
number
got
{
typeof
column
}
instead
.
)
;
}
return
{
sourceUrl
}
:
{
sourceId
}
:
{
line
}
:
{
column
}
;
}
}
;
function
idFunction
(
v
)
{
if
(
typeof
v
!
=
"
string
"
)
{
throw
new
Error
(
Expect
data
entry
values
to
be
string
or
be
using
custom
data
key
functions
.
Got
{
typeof
v
}
type
instead
.
)
;
}
return
v
;
}
const
WatchedDataHelpers
=
{
SUPPORTED_DATA
addWatchedDataEntry
(
watchedData
type
entries
)
{
const
toBeAdded
=
[
]
;
const
keyFunction
=
DATA_KEY_FUNCTION
[
type
]
|
|
idFunction
;
for
(
const
entry
of
entries
)
{
const
alreadyExists
=
watchedData
[
type
]
.
some
(
existingEntry
=
>
{
return
keyFunction
(
existingEntry
)
=
=
=
keyFunction
(
entry
)
;
}
)
;
if
(
!
alreadyExists
)
{
toBeAdded
.
push
(
entry
)
;
}
}
watchedData
[
type
]
.
push
(
.
.
.
toBeAdded
)
;
}
removeWatchedDataEntry
(
watchedData
type
entries
)
{
let
includesAtLeastOne
=
false
;
const
keyFunction
=
DATA_KEY_FUNCTION
[
type
]
|
|
idFunction
;
for
(
const
entry
of
entries
)
{
const
idx
=
watchedData
[
type
]
.
findIndex
(
existingEntry
=
>
{
return
keyFunction
(
existingEntry
)
=
=
=
keyFunction
(
entry
)
;
}
)
;
if
(
idx
!
=
=
-
1
)
{
watchedData
[
type
]
.
splice
(
idx
1
)
;
includesAtLeastOne
=
true
;
}
}
if
(
!
includesAtLeastOne
)
{
return
false
;
}
return
true
;
}
}
;
if
(
typeof
module
=
=
"
object
"
)
{
module
.
exports
.
WatchedDataHelpers
=
WatchedDataHelpers
;
}
