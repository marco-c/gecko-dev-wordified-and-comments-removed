"
use
strict
"
;
const
{
waitForTick
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
PROCESS_SCRIPT_URL
=
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
target
-
helpers
/
service
-
worker
-
jsprocessactor
-
startup
.
js
"
;
const
PROCESS_ACTOR_NAME
=
"
DevToolsServiceWorker
"
;
const
PROCESS_ACTOR_OPTIONS
=
{
includeParent
:
false
parent
:
{
esModuleURI
:
"
resource
:
/
/
devtools
/
server
/
connectors
/
process
-
actor
/
DevToolsServiceWorkerParent
.
sys
.
mjs
"
}
child
:
{
esModuleURI
:
"
resource
:
/
/
devtools
/
server
/
connectors
/
process
-
actor
/
DevToolsServiceWorkerChild
.
sys
.
mjs
"
observers
:
[
"
init
-
devtools
-
service
-
worker
-
actor
"
]
}
}
;
const
gWatchers
=
new
Set
(
)
;
function
maybeRegisterProcessActor
(
watcher
)
{
const
sizeBefore
=
gWatchers
.
size
;
gWatchers
.
add
(
watcher
)
;
if
(
sizeBefore
=
=
0
&
&
gWatchers
.
size
=
=
1
)
{
ChromeUtils
.
registerProcessActor
(
PROCESS_ACTOR_NAME
PROCESS_ACTOR_OPTIONS
)
;
Services
.
ppmm
.
loadProcessScript
(
PROCESS_SCRIPT_URL
true
)
;
}
}
function
maybeUnregisterProcessActor
(
watcher
)
{
const
sizeBefore
=
gWatchers
.
size
;
gWatchers
.
delete
(
watcher
)
;
if
(
sizeBefore
=
=
1
&
&
gWatchers
.
size
=
=
0
)
{
ChromeUtils
.
unregisterProcessActor
(
PROCESS_ACTOR_NAME
PROCESS_ACTOR_OPTIONS
)
;
Services
.
ppmm
.
removeDelayedProcessScript
(
PROCESS_SCRIPT_URL
)
;
}
}
function
getAllContentProcesses
(
)
{
return
ChromeUtils
.
getAllDOMProcesses
(
)
.
filter
(
process
=
>
process
.
childID
!
=
=
0
)
;
}
async
function
createTargets
(
watcher
)
{
maybeRegisterProcessActor
(
watcher
)
;
const
promises
=
[
]
;
for
(
const
process
of
getAllContentProcesses
(
)
)
{
const
promise
=
process
.
getActor
(
PROCESS_ACTOR_NAME
)
.
instantiateServiceWorkerTargets
(
{
watcherActorID
:
watcher
.
actorID
connectionPrefix
:
watcher
.
conn
.
prefix
sessionContext
:
watcher
.
sessionContext
sessionData
:
watcher
.
sessionData
}
)
;
promises
.
push
(
promise
)
;
}
return
Promise
.
all
(
promises
)
;
}
async
function
destroyTargets
(
watcher
)
{
for
(
const
process
of
getAllContentProcesses
(
)
)
{
let
processActor
;
try
{
processActor
=
process
.
getActor
(
PROCESS_ACTOR_NAME
)
;
}
catch
(
e
)
{
continue
;
}
processActor
.
destroyServiceWorkerTargets
(
{
watcherActorID
:
watcher
.
actorID
sessionContext
:
watcher
.
sessionContext
}
)
;
}
await
waitForTick
(
)
;
maybeUnregisterProcessActor
(
watcher
)
;
}
async
function
addOrSetSessionDataEntry
(
{
watcher
type
entries
updateType
}
)
{
maybeRegisterProcessActor
(
watcher
)
;
const
promises
=
[
]
;
for
(
const
process
of
getAllContentProcesses
(
)
)
{
const
promise
=
process
.
getActor
(
PROCESS_ACTOR_NAME
)
.
addOrSetSessionDataEntry
(
{
watcherActorID
:
watcher
.
actorID
sessionContext
:
watcher
.
sessionContext
type
entries
updateType
}
)
;
promises
.
push
(
promise
)
;
}
return
Promise
.
all
(
promises
)
;
}
function
removeSessionDataEntry
(
{
watcher
type
entries
}
)
{
for
(
const
process
of
getAllContentProcesses
(
)
)
{
process
.
getActor
(
PROCESS_ACTOR_NAME
)
.
removeSessionDataEntry
(
{
watcherActorID
:
watcher
.
actorID
sessionContext
:
watcher
.
sessionContext
type
entries
}
)
;
}
}
module
.
exports
=
{
createTargets
destroyTargets
addOrSetSessionDataEntry
removeSessionDataEntry
}
;
