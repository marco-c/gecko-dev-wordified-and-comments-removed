"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
WatcherRegistry
}
=
require
(
"
devtools
/
server
/
actors
/
watcher
/
WatcherRegistry
.
jsm
"
)
;
const
{
WindowGlobalLogger
}
=
require
(
"
devtools
/
server
/
connectors
/
js
-
window
-
actor
/
WindowGlobalLogger
.
jsm
"
)
;
const
Targets
=
require
(
"
devtools
/
server
/
actors
/
targets
/
index
"
)
;
const
{
getAllRemoteBrowsingContexts
shouldNotifyWindowGlobal
}
=
require
(
"
devtools
/
server
/
actors
/
watcher
/
target
-
helpers
/
utils
.
js
"
)
;
const
browsingContextAttachedObserverByWatcher
=
new
Map
(
)
;
const
isEveryFrameTargetEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
every
-
frame
-
target
.
enabled
"
false
)
;
async
function
createTargets
(
watcher
)
{
if
(
watcher
.
browserElement
)
{
watcher
.
browserElement
.
browsingContext
.
watchedByDevTools
=
true
;
}
if
(
!
browsingContextAttachedObserverByWatcher
.
has
(
watcher
)
)
{
const
browserId
=
watcher
.
browserElement
?
.
browserId
;
const
onBrowsingContextAttached
=
browsingContext
=
>
{
if
(
!
browsingContext
.
parent
&
&
(
!
watcher
.
browserElement
|
|
browserId
=
=
=
browsingContext
.
browserId
)
)
{
browsingContext
.
watchedByDevTools
=
true
;
}
}
;
Services
.
obs
.
addObserver
(
onBrowsingContextAttached
"
browsing
-
context
-
attached
"
)
;
browsingContextAttachedObserverByWatcher
.
set
(
watcher
onBrowsingContextAttached
)
;
}
if
(
watcher
.
isServerTargetSwitchingEnabled
&
&
watcher
.
browserElement
)
{
await
createTargetForBrowsingContext
(
{
watcher
browsingContext
:
watcher
.
browserElement
.
browsingContext
retryOnAbortError
:
true
}
)
;
}
const
browsingContexts
=
getFilteredRemoteBrowsingContext
(
watcher
.
browserElement
)
;
await
Promise
.
allSettled
(
browsingContexts
.
map
(
browsingContext
=
>
createTargetForBrowsingContext
(
{
watcher
browsingContext
}
)
)
)
;
}
async
function
createTargetForBrowsingContext
(
{
watcher
browsingContext
retryOnAbortError
=
false
}
)
{
logWindowGlobal
(
browsingContext
.
currentWindowGlobal
"
Existing
WindowGlobal
"
)
;
if
(
!
browsingContext
.
parent
)
{
browsingContext
.
watchedByDevTools
=
true
;
}
try
{
await
browsingContext
.
currentWindowGlobal
.
getActor
(
"
DevToolsFrame
"
)
.
instantiateTarget
(
{
watcherActorID
:
watcher
.
actorID
connectionPrefix
:
watcher
.
conn
.
prefix
browserId
:
watcher
.
browserId
watchedData
:
watcher
.
watchedData
}
)
;
}
catch
(
e
)
{
console
.
warn
(
"
Failed
to
create
DevTools
Frame
target
for
browsingContext
"
browsingContext
.
id
"
:
"
e
retryOnAbortError
?
"
retrying
"
:
"
"
)
;
if
(
retryOnAbortError
&
&
e
.
name
=
=
=
"
AbortError
"
)
{
await
createTargetForBrowsingContext
(
{
watcher
browsingContext
retryOnAbortError
}
)
;
}
else
{
throw
e
;
}
}
}
function
destroyTargets
(
watcher
)
{
const
browsingContexts
=
getFilteredRemoteBrowsingContext
(
watcher
.
browserElement
)
;
if
(
watcher
.
isServerTargetSwitchingEnabled
&
&
watcher
.
browserElement
)
{
browsingContexts
.
push
(
watcher
.
browserElement
.
browsingContext
)
;
}
for
(
const
browsingContext
of
browsingContexts
)
{
logWindowGlobal
(
browsingContext
.
currentWindowGlobal
"
Existing
WindowGlobal
"
)
;
if
(
!
browsingContext
.
parent
)
{
browsingContext
.
watchedByDevTools
=
false
;
}
browsingContext
.
currentWindowGlobal
.
getActor
(
"
DevToolsFrame
"
)
.
destroyTarget
(
{
watcherActorID
:
watcher
.
actorID
browserId
:
watcher
.
browserId
}
)
;
}
if
(
watcher
.
browserElement
)
{
watcher
.
browserElement
.
browsingContext
.
watchedByDevTools
=
false
;
}
if
(
browsingContextAttachedObserverByWatcher
.
has
(
watcher
)
)
{
Services
.
obs
.
removeObserver
(
browsingContextAttachedObserverByWatcher
.
get
(
watcher
)
"
browsing
-
context
-
attached
"
)
;
browsingContextAttachedObserverByWatcher
.
delete
(
watcher
)
;
}
}
async
function
addWatcherDataEntry
(
{
watcher
type
entries
}
)
{
const
browsingContexts
=
getWatchingBrowsingContexts
(
watcher
)
;
const
promises
=
[
]
;
for
(
const
browsingContext
of
browsingContexts
)
{
logWindowGlobal
(
browsingContext
.
currentWindowGlobal
"
Existing
WindowGlobal
"
)
;
const
promise
=
browsingContext
.
currentWindowGlobal
.
getActor
(
"
DevToolsFrame
"
)
.
addWatcherDataEntry
(
{
watcherActorID
:
watcher
.
actorID
browserId
:
watcher
.
browserId
type
entries
}
)
;
promises
.
push
(
promise
)
;
}
return
Promise
.
all
(
promises
)
;
}
function
removeWatcherDataEntry
(
{
watcher
type
entries
}
)
{
const
browsingContexts
=
getWatchingBrowsingContexts
(
watcher
)
;
for
(
const
browsingContext
of
browsingContexts
)
{
logWindowGlobal
(
browsingContext
.
currentWindowGlobal
"
Existing
WindowGlobal
"
)
;
browsingContext
.
currentWindowGlobal
.
getActor
(
"
DevToolsFrame
"
)
.
removeWatcherDataEntry
(
{
watcherActorID
:
watcher
.
actorID
browserId
:
watcher
.
browserId
type
entries
}
)
;
}
}
module
.
exports
=
{
createTargets
destroyTargets
addWatcherDataEntry
removeWatcherDataEntry
}
;
function
getWatchingBrowsingContexts
(
watcher
)
{
const
watchingAdditionalTargets
=
WatcherRegistry
.
isWatchingTargets
(
watcher
Targets
.
TYPES
.
FRAME
)
;
const
{
browserElement
}
=
watcher
;
const
browsingContexts
=
watchingAdditionalTargets
?
getFilteredRemoteBrowsingContext
(
browserElement
)
:
[
]
;
if
(
browserElement
)
{
const
topBrowsingContext
=
browserElement
.
browsingContext
;
if
(
topBrowsingContext
.
currentWindowGlobal
.
osPid
!
=
-
1
)
{
browsingContexts
.
push
(
topBrowsingContext
)
;
}
}
return
browsingContexts
;
}
function
getFilteredRemoteBrowsingContext
(
browserElement
)
{
return
getAllRemoteBrowsingContexts
(
browserElement
?
.
browsingContext
)
.
filter
(
browsingContext
=
>
shouldNotifyWindowGlobal
(
browsingContext
browserElement
?
.
browserId
{
acceptNonRemoteFrame
:
isEveryFrameTargetEnabled
}
)
)
;
}
const
DEBUG
=
false
;
function
logWindowGlobal
(
windowGlobal
message
)
{
if
(
!
DEBUG
)
{
return
;
}
WindowGlobalLogger
.
logWindowGlobal
(
windowGlobal
message
)
;
}
