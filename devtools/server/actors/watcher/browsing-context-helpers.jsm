"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
isBrowsingContextPartOfContext
"
"
isWindowGlobalPartOfContext
"
"
getAddonIdForWindowGlobal
"
"
getAllBrowsingContextsForContext
"
]
;
const
isEveryFrameTargetEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
every
-
frame
-
target
.
enabled
"
false
)
;
const
WEBEXTENSION_FALLBACK_DOC_URL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
webextension
-
fallback
.
html
"
;
function
getAddonIdForWindowGlobal
(
windowGlobal
)
{
const
browsingContext
=
windowGlobal
.
browsingContext
;
const
isParent
=
CanonicalBrowsingContext
.
isInstance
(
browsingContext
)
;
const
principal
=
isParent
?
windowGlobal
.
documentPrincipal
:
browsingContext
.
window
.
document
.
nodePrincipal
;
if
(
!
principal
)
{
return
null
;
}
if
(
principal
.
addonId
)
{
return
principal
.
addonId
;
}
const
href
=
isParent
?
windowGlobal
.
documentURI
?
.
displaySpec
:
browsingContext
.
window
.
document
.
location
.
href
;
if
(
href
&
&
href
.
startsWith
(
WEBEXTENSION_FALLBACK_DOC_URL
)
)
{
const
[
addonId
]
=
href
.
split
(
"
#
"
)
;
return
addonId
;
}
return
null
;
}
function
isBrowsingContextPartOfContext
(
browsingContext
sessionContext
options
=
{
}
)
{
let
{
forceAcceptTopLevelTarget
=
false
acceptNoWindowGlobal
=
false
windowGlobal
}
=
options
;
if
(
CanonicalBrowsingContext
.
isInstance
(
browsingContext
)
&
&
!
browsingContext
.
isContent
)
{
return
false
;
}
if
(
!
windowGlobal
)
{
if
(
CanonicalBrowsingContext
.
isInstance
(
browsingContext
)
)
{
windowGlobal
=
browsingContext
.
currentWindowGlobal
;
}
else
if
(
!
windowGlobal
&
&
!
acceptNoWindowGlobal
)
{
throw
new
Error
(
"
isBrowsingContextPartOfContext
expect
a
windowGlobal
argument
when
called
from
the
content
process
"
)
;
}
}
if
(
windowGlobal
&
&
!
_validateWindowGlobal
(
windowGlobal
sessionContext
options
)
)
{
return
false
;
}
if
(
!
windowGlobal
&
&
!
acceptNoWindowGlobal
)
{
return
false
;
}
if
(
sessionContext
.
type
=
=
"
all
"
)
{
return
true
;
}
if
(
sessionContext
.
type
=
=
"
browser
-
element
"
)
{
const
isMatchingTheBrowserElement
=
browsingContext
.
browserId
=
=
sessionContext
.
browserId
;
if
(
!
isMatchingTheBrowserElement
&
&
!
isPopupToDebug
(
browsingContext
sessionContext
)
)
{
return
false
;
}
const
isClientSideTargetSwitching
=
!
sessionContext
.
isServerTargetSwitchingEnabled
;
const
isTopLevelBrowsingContext
=
!
browsingContext
.
parent
;
if
(
isClientSideTargetSwitching
&
&
!
forceAcceptTopLevelTarget
&
&
isTopLevelBrowsingContext
)
{
return
false
;
}
return
true
;
}
if
(
sessionContext
.
type
=
=
"
webextension
"
)
{
if
(
!
windowGlobal
)
{
return
false
;
}
return
getAddonIdForWindowGlobal
(
windowGlobal
)
=
=
sessionContext
.
addonId
;
}
throw
new
Error
(
"
Unsupported
session
context
type
:
"
+
sessionContext
.
type
)
;
}
function
isPopupToDebug
(
browsingContext
sessionContext
)
{
return
(
sessionContext
.
isPopupDebuggingEnabled
&
&
browsingContext
.
opener
&
&
browsingContext
.
opener
.
browserId
=
=
sessionContext
.
browserId
)
;
}
function
_validateWindowGlobal
(
windowGlobal
sessionContext
{
acceptInitialDocument
acceptSameProcessIframes
}
)
{
const
isInitialDocument
=
windowGlobal
.
isInitialDocument
|
|
windowGlobal
.
browsingContext
.
window
?
.
document
.
isInitialDocument
;
if
(
isInitialDocument
&
&
!
acceptInitialDocument
)
{
return
false
;
}
const
isSameProcessIframe
=
!
windowGlobal
.
isProcessRoot
;
if
(
isSameProcessIframe
&
&
!
acceptSameProcessIframes
&
&
!
isEveryFrameTargetEnabled
)
{
return
false
;
}
return
true
;
}
function
isWindowGlobalPartOfContext
(
windowGlobal
sessionContext
options
)
{
return
isBrowsingContextPartOfContext
(
windowGlobal
.
browsingContext
sessionContext
{
.
.
.
options
windowGlobal
}
)
;
}
function
getAllBrowsingContextsForContext
(
sessionContext
{
acceptSameProcessIframes
=
false
}
=
{
}
)
{
const
browsingContexts
=
[
]
;
function
walk
(
browsingContext
)
{
if
(
browsingContexts
.
includes
(
browsingContext
)
)
{
return
;
}
browsingContexts
.
push
(
browsingContext
)
;
for
(
const
child
of
browsingContext
.
children
)
{
walk
(
child
)
;
}
if
(
(
sessionContext
.
type
=
=
"
all
"
|
|
sessionContext
.
type
=
=
"
webextension
"
)
&
&
browsingContext
.
window
)
{
for
(
const
browser
of
browsingContext
.
window
.
document
.
querySelectorAll
(
browser
[
remote
=
"
true
"
]
)
)
{
walk
(
browser
.
browsingContext
)
;
}
}
}
if
(
sessionContext
.
type
=
=
"
browser
-
element
"
)
{
const
topBrowsingContext
=
BrowsingContext
.
getCurrentTopByBrowserId
(
sessionContext
.
browserId
)
;
const
realTopBrowsingContext
=
topBrowsingContext
.
embedderElement
.
browsingContext
;
walk
(
realTopBrowsingContext
)
;
}
else
if
(
sessionContext
.
type
=
=
"
all
"
|
|
sessionContext
.
type
=
=
"
webextension
"
)
{
for
(
const
window
of
Services
.
ww
.
getWindowEnumerator
(
)
)
{
if
(
window
.
docShell
.
browsingContext
)
{
walk
(
window
.
docShell
.
browsingContext
)
;
}
}
}
else
{
throw
new
Error
(
"
Unsupported
session
context
type
:
"
+
sessionContext
.
type
)
;
}
return
browsingContexts
.
filter
(
bc
=
>
isBrowsingContextPartOfContext
(
bc
sessionContext
{
forceAcceptTopLevelTarget
:
true
acceptSameProcessIframes
}
)
)
;
}
if
(
typeof
module
=
=
"
object
"
)
{
module
.
exports
=
{
isBrowsingContextPartOfContext
isWindowGlobalPartOfContext
getAddonIdForWindowGlobal
getAllBrowsingContextsForContext
}
;
}
