"
use
strict
"
;
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
debugger
-
server
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
assert
}
=
DevToolsUtils
;
loader
.
lazyRequireGetter
(
this
"
longStringGrip
"
"
devtools
/
server
/
actors
/
object
/
long
-
string
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
symbolGrip
"
"
devtools
/
server
/
actors
/
object
/
symbol
"
true
)
;
function
getPromiseState
(
obj
)
{
if
(
obj
.
class
!
=
"
Promise
"
)
{
throw
new
Error
(
"
Can
'
t
call
getPromiseState
on
Debugger
.
Object
s
that
don
'
t
"
+
"
refer
to
Promise
objects
.
"
)
;
}
const
state
=
{
state
:
obj
.
promiseState
}
;
if
(
state
.
state
=
=
=
"
fulfilled
"
)
{
state
.
value
=
obj
.
promiseValue
;
}
else
if
(
state
.
state
=
=
=
"
rejected
"
)
{
state
.
reason
=
obj
.
promiseReason
;
}
return
state
;
}
function
makeDebuggeeValueIfNeeded
(
obj
value
)
{
if
(
value
&
&
(
typeof
value
=
=
"
object
"
|
|
typeof
value
=
=
"
function
"
)
)
{
return
obj
.
makeDebuggeeValue
(
value
)
;
}
return
value
;
}
function
unwrapDebuggeeValue
(
value
)
{
if
(
value
&
&
typeof
value
=
=
"
object
"
)
{
return
value
.
unsafeDereference
(
)
;
}
return
value
;
}
function
createValueGrip
(
value
pool
makeObjectGrip
)
{
switch
(
typeof
value
)
{
case
"
boolean
"
:
return
value
;
case
"
string
"
:
if
(
stringIsLong
(
value
)
)
{
return
longStringGrip
(
value
pool
)
;
}
return
value
;
case
"
number
"
:
if
(
value
=
=
=
Infinity
)
{
return
{
type
:
"
Infinity
"
}
;
}
else
if
(
value
=
=
=
-
Infinity
)
{
return
{
type
:
"
-
Infinity
"
}
;
}
else
if
(
Number
.
isNaN
(
value
)
)
{
return
{
type
:
"
NaN
"
}
;
}
else
if
(
!
value
&
&
1
/
value
=
=
=
-
Infinity
)
{
return
{
type
:
"
-
0
"
}
;
}
return
value
;
case
"
bigint
"
:
return
{
type
:
"
BigInt
"
text
:
value
.
toString
(
)
}
;
case
"
undefined
"
:
return
{
type
:
"
undefined
"
}
;
case
"
object
"
:
if
(
value
=
=
=
null
)
{
return
{
type
:
"
null
"
}
;
}
else
if
(
value
.
optimizedOut
|
|
value
.
uninitialized
|
|
value
.
missingArguments
)
{
return
{
type
:
"
null
"
optimizedOut
:
value
.
optimizedOut
uninitialized
:
value
.
uninitialized
missingArguments
:
value
.
missingArguments
}
;
}
return
makeObjectGrip
(
value
pool
)
;
case
"
symbol
"
:
return
symbolGrip
(
value
pool
)
;
default
:
assert
(
false
"
Failed
to
provide
a
grip
for
:
"
+
value
)
;
return
null
;
}
}
function
stringIsLong
(
str
)
{
return
str
.
length
>
=
DebuggerServer
.
LONG_STRING_LENGTH
;
}
const
TYPED_ARRAY_CLASSES
=
[
"
Uint8Array
"
"
Uint8ClampedArray
"
"
Uint16Array
"
"
Uint32Array
"
"
Int8Array
"
"
Int16Array
"
"
Int32Array
"
"
Float32Array
"
"
Float64Array
"
]
;
function
isTypedArray
(
object
)
{
return
TYPED_ARRAY_CLASSES
.
includes
(
object
.
class
)
;
}
function
isArray
(
object
)
{
return
isTypedArray
(
object
)
|
|
object
.
class
=
=
=
"
Array
"
;
}
function
getArrayLength
(
object
)
{
if
(
!
isArray
(
object
)
)
{
throw
new
Error
(
"
Expected
an
array
got
a
"
+
object
.
class
)
;
}
if
(
object
.
class
=
=
=
"
Array
"
)
{
return
DevToolsUtils
.
getProperty
(
object
"
length
"
)
;
}
const
typedProto
=
Object
.
getPrototypeOf
(
Uint8Array
.
prototype
)
;
const
getter
=
Object
.
getOwnPropertyDescriptor
(
typedProto
"
length
"
)
.
get
;
return
getter
.
call
(
object
.
unsafeDereference
(
)
)
;
}
function
isArrayIndex
(
str
)
{
const
num
=
str
>
>
>
0
;
return
(
num
+
"
"
=
=
=
str
&
&
num
!
=
-
1
>
>
>
0
)
;
}
function
isStorage
(
object
)
{
return
object
.
class
=
=
=
"
Storage
"
;
}
function
getStorageLength
(
object
)
{
if
(
!
isStorage
(
object
)
)
{
throw
new
Error
(
"
Expected
a
storage
object
got
a
"
+
object
.
class
)
;
}
return
DevToolsUtils
.
getProperty
(
object
"
length
"
)
;
}
module
.
exports
=
{
getPromiseState
makeDebuggeeValueIfNeeded
unwrapDebuggeeValue
createValueGrip
stringIsLong
isTypedArray
isArray
isStorage
getArrayLength
getStorageLength
isArrayIndex
}
;
