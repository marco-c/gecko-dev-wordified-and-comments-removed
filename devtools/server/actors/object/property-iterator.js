"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
propertyIteratorSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
property
-
iterator
"
)
;
loader
.
lazyRequireGetter
(
this
"
ChromeUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
ObjectUtils
"
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
PropertyIteratorActor
=
protocol
.
ActorClassWithSpec
(
propertyIteratorSpec
{
initialize
(
objectActor
options
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
)
;
if
(
!
DevToolsUtils
.
isSafeDebuggerObject
(
objectActor
.
obj
)
)
{
this
.
iterator
=
{
size
:
0
propertyName
:
index
=
>
undefined
propertyDescription
:
index
=
>
undefined
}
;
}
else
if
(
options
.
enumEntries
)
{
let
cls
=
objectActor
.
obj
.
class
;
if
(
cls
=
=
"
Map
"
)
{
this
.
iterator
=
enumMapEntries
(
objectActor
)
;
}
else
if
(
cls
=
=
"
WeakMap
"
)
{
this
.
iterator
=
enumWeakMapEntries
(
objectActor
)
;
}
else
if
(
cls
=
=
"
Set
"
)
{
this
.
iterator
=
enumSetEntries
(
objectActor
)
;
}
else
if
(
cls
=
=
"
WeakSet
"
)
{
this
.
iterator
=
enumWeakSetEntries
(
objectActor
)
;
}
else
{
throw
new
Error
(
"
Unsupported
class
to
enumerate
entries
from
:
"
+
cls
)
;
}
}
else
if
(
ObjectUtils
.
isArray
(
objectActor
.
obj
)
&
&
options
.
ignoreNonIndexedProperties
&
&
!
options
.
query
)
{
this
.
iterator
=
enumArrayProperties
(
objectActor
options
)
;
}
else
{
this
.
iterator
=
enumObjectProperties
(
objectActor
options
)
;
}
}
form
(
)
{
return
{
type
:
this
.
typeName
actor
:
this
.
actorID
count
:
this
.
iterator
.
size
}
;
}
names
(
{
indexes
}
)
{
let
list
=
[
]
;
for
(
let
idx
of
indexes
)
{
list
.
push
(
this
.
iterator
.
propertyName
(
idx
)
)
;
}
return
{
names
:
indexes
}
;
}
slice
(
{
start
count
}
)
{
let
ownProperties
=
Object
.
create
(
null
)
;
for
(
let
i
=
start
m
=
start
+
count
;
i
<
m
;
i
+
+
)
{
let
name
=
this
.
iterator
.
propertyName
(
i
)
;
ownProperties
[
name
]
=
this
.
iterator
.
propertyDescription
(
i
)
;
}
return
{
ownProperties
}
;
}
all
(
)
{
return
this
.
slice
(
{
start
:
0
count
:
this
.
iterator
.
size
}
)
;
}
}
)
;
function
gripFromEntry
(
{
obj
hooks
}
entry
)
{
return
hooks
.
createValueGrip
(
ObjectUtils
.
makeDebuggeeValueIfNeeded
(
obj
Cu
.
unwaiveXrays
(
entry
)
)
)
;
}
function
enumArrayProperties
(
objectActor
options
)
{
return
{
size
:
ObjectUtils
.
getArrayLength
(
objectActor
.
obj
)
propertyName
(
index
)
{
return
index
;
}
propertyDescription
(
index
)
{
return
objectActor
.
_propertyDescriptor
(
index
)
;
}
}
;
}
function
enumObjectProperties
(
objectActor
options
)
{
let
names
=
[
]
;
try
{
names
=
objectActor
.
obj
.
getOwnPropertyNames
(
)
;
}
catch
(
ex
)
{
}
if
(
options
.
ignoreNonIndexedProperties
|
|
options
.
ignoreIndexedProperties
)
{
let
length
=
DevToolsUtils
.
getProperty
(
objectActor
.
obj
"
length
"
)
;
let
sliceIndex
;
const
isLengthTrustworthy
=
isUint32
(
length
)
&
&
(
!
length
|
|
ObjectUtils
.
isArrayIndex
(
names
[
length
-
1
]
)
)
&
&
!
ObjectUtils
.
isArrayIndex
(
names
[
length
]
)
;
if
(
!
isLengthTrustworthy
)
{
if
(
!
ObjectUtils
.
isArrayIndex
(
names
[
0
]
)
)
{
sliceIndex
=
0
;
}
else
{
sliceIndex
=
names
.
length
;
while
(
sliceIndex
>
0
)
{
if
(
ObjectUtils
.
isArrayIndex
(
names
[
sliceIndex
-
1
]
)
)
{
break
;
}
sliceIndex
-
-
;
}
}
}
else
{
sliceIndex
=
length
;
}
if
(
options
.
ignoreIndexedProperties
)
{
names
=
names
.
slice
(
sliceIndex
)
;
}
else
if
(
options
.
ignoreNonIndexedProperties
)
{
names
.
length
=
sliceIndex
;
}
}
let
safeGetterValues
=
objectActor
.
_findSafeGetterValues
(
names
0
)
;
let
safeGetterNames
=
Object
.
keys
(
safeGetterValues
)
;
for
(
let
name
of
safeGetterNames
)
{
if
(
!
names
.
includes
(
name
)
)
{
names
.
push
(
name
)
;
}
}
if
(
options
.
query
)
{
let
{
query
}
=
options
;
query
=
query
.
toLowerCase
(
)
;
names
=
names
.
filter
(
name
=
>
{
if
(
name
.
toLowerCase
(
)
.
includes
(
query
)
)
{
return
true
;
}
let
desc
;
try
{
desc
=
objectActor
.
obj
.
getOwnPropertyDescriptor
(
name
)
;
}
catch
(
e
)
{
}
if
(
desc
&
&
desc
.
value
&
&
String
(
desc
.
value
)
.
includes
(
query
)
)
{
return
true
;
}
return
false
;
}
)
;
}
if
(
options
.
sort
)
{
names
.
sort
(
)
;
}
return
{
size
:
names
.
length
propertyName
(
index
)
{
return
names
[
index
]
;
}
propertyDescription
(
index
)
{
let
name
=
names
[
index
]
;
let
desc
=
objectActor
.
_propertyDescriptor
(
name
)
;
if
(
!
desc
)
{
desc
=
safeGetterValues
[
name
]
;
}
else
if
(
name
in
safeGetterValues
)
{
let
{
getterValue
getterPrototypeLevel
}
=
safeGetterValues
[
name
]
;
desc
.
getterValue
=
getterValue
;
desc
.
getterPrototypeLevel
=
getterPrototypeLevel
;
}
return
desc
;
}
}
;
}
function
enumMapEntries
(
objectActor
)
{
let
raw
=
objectActor
.
obj
.
unsafeDereference
(
)
;
let
keys
=
[
.
.
.
Cu
.
waiveXrays
(
Map
.
prototype
.
keys
.
call
(
raw
)
)
]
;
return
{
[
Symbol
.
iterator
]
:
function
*
(
)
{
for
(
let
key
of
keys
)
{
let
value
=
Map
.
prototype
.
get
.
call
(
raw
key
)
;
yield
[
key
value
]
.
map
(
val
=
>
gripFromEntry
(
objectActor
val
)
)
;
}
}
size
:
keys
.
length
propertyName
(
index
)
{
return
index
;
}
propertyDescription
(
index
)
{
let
key
=
keys
[
index
]
;
let
val
=
Map
.
prototype
.
get
.
call
(
raw
key
)
;
return
{
enumerable
:
true
value
:
{
type
:
"
mapEntry
"
preview
:
{
key
:
gripFromEntry
(
objectActor
key
)
value
:
gripFromEntry
(
objectActor
val
)
}
}
}
;
}
}
;
}
function
enumWeakMapEntries
(
objectActor
)
{
let
raw
=
objectActor
.
obj
.
unsafeDereference
(
)
;
let
keys
=
Cu
.
waiveXrays
(
ChromeUtils
.
nondeterministicGetWeakMapKeys
(
raw
)
)
;
return
{
[
Symbol
.
iterator
]
:
function
*
(
)
{
for
(
let
key
of
keys
)
{
let
value
=
WeakMap
.
prototype
.
get
.
call
(
raw
key
)
;
yield
[
key
value
]
.
map
(
val
=
>
gripFromEntry
(
objectActor
val
)
)
;
}
}
size
:
keys
.
length
propertyName
(
index
)
{
return
index
;
}
propertyDescription
(
index
)
{
let
key
=
keys
[
index
]
;
let
val
=
WeakMap
.
prototype
.
get
.
call
(
raw
key
)
;
return
{
enumerable
:
true
value
:
{
type
:
"
mapEntry
"
preview
:
{
key
:
gripFromEntry
(
objectActor
key
)
value
:
gripFromEntry
(
objectActor
val
)
}
}
}
;
}
}
;
}
function
enumSetEntries
(
objectActor
)
{
let
raw
=
objectActor
.
obj
.
unsafeDereference
(
)
;
let
values
=
[
.
.
.
Cu
.
waiveXrays
(
Set
.
prototype
.
values
.
call
(
raw
)
)
]
;
return
{
[
Symbol
.
iterator
]
:
function
*
(
)
{
for
(
let
item
of
values
)
{
yield
gripFromEntry
(
objectActor
item
)
;
}
}
size
:
values
.
length
propertyName
(
index
)
{
return
index
;
}
propertyDescription
(
index
)
{
let
val
=
values
[
index
]
;
return
{
enumerable
:
true
value
:
gripFromEntry
(
objectActor
val
)
}
;
}
}
;
}
function
enumWeakSetEntries
(
objectActor
)
{
let
raw
=
objectActor
.
obj
.
unsafeDereference
(
)
;
let
keys
=
Cu
.
waiveXrays
(
ChromeUtils
.
nondeterministicGetWeakSetKeys
(
raw
)
)
;
return
{
[
Symbol
.
iterator
]
:
function
*
(
)
{
for
(
let
item
of
keys
)
{
yield
gripFromEntry
(
objectActor
item
)
;
}
}
size
:
keys
.
length
propertyName
(
index
)
{
return
index
;
}
propertyDescription
(
index
)
{
let
val
=
keys
[
index
]
;
return
{
enumerable
:
true
value
:
gripFromEntry
(
objectActor
val
)
}
;
}
}
;
}
function
isUint32
(
num
)
{
return
num
>
>
>
0
=
=
=
num
;
}
module
.
exports
=
{
PropertyIteratorActor
enumMapEntries
enumSetEntries
enumWeakMapEntries
enumWeakSetEntries
}
;
