"
use
strict
"
;
const
{
Cu
Ci
}
=
require
(
"
chrome
"
)
;
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
ObjectUtils
"
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
loader
.
lazyRequireGetter
(
this
"
PropertyIterators
"
"
devtools
/
server
/
actors
/
object
/
property
-
iterator
"
)
;
const
OBJECT_PREVIEW_MAX_ITEMS
=
10
;
const
previewers
=
{
String
:
[
function
(
objectActor
grip
rawObj
)
{
return
wrappedPrimitivePreviewer
(
"
String
"
String
objectActor
grip
rawObj
)
;
}
]
Boolean
:
[
function
(
objectActor
grip
rawObj
)
{
return
wrappedPrimitivePreviewer
(
"
Boolean
"
Boolean
objectActor
grip
rawObj
)
;
}
]
Number
:
[
function
(
objectActor
grip
rawObj
)
{
return
wrappedPrimitivePreviewer
(
"
Number
"
Number
objectActor
grip
rawObj
)
;
}
]
Symbol
:
[
function
(
objectActor
grip
rawObj
)
{
return
wrappedPrimitivePreviewer
(
"
Symbol
"
Symbol
objectActor
grip
rawObj
)
;
}
]
Function
:
[
function
(
{
obj
hooks
}
grip
)
{
if
(
obj
.
name
)
{
grip
.
name
=
obj
.
name
;
}
if
(
obj
.
displayName
)
{
grip
.
displayName
=
obj
.
displayName
.
substr
(
0
500
)
;
}
if
(
obj
.
parameterNames
)
{
grip
.
parameterNames
=
obj
.
parameterNames
;
}
let
userDisplayName
;
try
{
userDisplayName
=
obj
.
getOwnPropertyDescriptor
(
"
displayName
"
)
;
}
catch
(
e
)
{
}
if
(
userDisplayName
&
&
typeof
userDisplayName
.
value
=
=
"
string
"
&
&
userDisplayName
.
value
)
{
grip
.
userDisplayName
=
hooks
.
createValueGrip
(
userDisplayName
.
value
)
;
}
let
dbgGlobal
=
hooks
.
getGlobalDebugObject
(
)
;
if
(
dbgGlobal
)
{
let
script
=
dbgGlobal
.
makeDebuggeeValue
(
obj
.
unsafeDereference
(
)
)
.
script
;
if
(
script
)
{
grip
.
location
=
{
url
:
script
.
url
line
:
script
.
startLine
}
;
}
}
return
true
;
}
]
RegExp
:
[
function
(
{
obj
hooks
}
grip
)
{
let
str
=
DevToolsUtils
.
callPropertyOnObject
(
obj
"
toString
"
)
;
if
(
typeof
str
!
=
"
string
"
)
{
return
false
;
}
grip
.
displayString
=
hooks
.
createValueGrip
(
str
)
;
return
true
;
}
]
Date
:
[
function
(
{
obj
hooks
}
grip
)
{
let
time
=
DevToolsUtils
.
callPropertyOnObject
(
obj
"
getTime
"
)
;
if
(
typeof
time
!
=
"
number
"
)
{
return
false
;
}
grip
.
preview
=
{
timestamp
:
hooks
.
createValueGrip
(
time
)
}
;
return
true
;
}
]
Array
:
[
function
(
{
obj
hooks
}
grip
)
{
let
length
=
ObjectUtils
.
getArrayLength
(
obj
)
;
grip
.
preview
=
{
kind
:
"
ArrayLike
"
length
:
length
}
;
if
(
hooks
.
getGripDepth
(
)
>
1
)
{
return
true
;
}
let
raw
=
obj
.
unsafeDereference
(
)
;
let
items
=
grip
.
preview
.
items
=
[
]
;
for
(
let
i
=
0
;
i
<
length
;
+
+
i
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
Cu
.
waiveXrays
(
raw
)
i
)
;
if
(
desc
&
&
!
desc
.
get
&
&
!
desc
.
set
)
{
let
value
=
Cu
.
unwaiveXrays
(
desc
.
value
)
;
value
=
ObjectUtils
.
makeDebuggeeValueIfNeeded
(
obj
value
)
;
items
.
push
(
hooks
.
createValueGrip
(
value
)
)
;
}
else
{
items
.
push
(
null
)
;
}
if
(
items
.
length
=
=
OBJECT_PREVIEW_MAX_ITEMS
)
{
break
;
}
}
return
true
;
}
]
Set
:
[
function
(
objectActor
grip
)
{
let
size
=
DevToolsUtils
.
getProperty
(
objectActor
.
obj
"
size
"
)
;
if
(
typeof
size
!
=
"
number
"
)
{
return
false
;
}
grip
.
preview
=
{
kind
:
"
ArrayLike
"
length
:
size
}
;
if
(
objectActor
.
hooks
.
getGripDepth
(
)
>
1
)
{
return
true
;
}
let
items
=
grip
.
preview
.
items
=
[
]
;
for
(
let
item
of
PropertyIterators
.
enumSetEntries
(
objectActor
)
)
{
items
.
push
(
item
)
;
if
(
items
.
length
=
=
OBJECT_PREVIEW_MAX_ITEMS
)
{
break
;
}
}
return
true
;
}
]
WeakSet
:
[
function
(
objectActor
grip
)
{
let
enumEntries
=
PropertyIterators
.
enumWeakSetEntries
(
objectActor
)
;
grip
.
preview
=
{
kind
:
"
ArrayLike
"
length
:
enumEntries
.
size
}
;
if
(
objectActor
.
hooks
.
getGripDepth
(
)
>
1
)
{
return
true
;
}
let
items
=
grip
.
preview
.
items
=
[
]
;
for
(
let
item
of
enumEntries
)
{
items
.
push
(
item
)
;
if
(
items
.
length
=
=
OBJECT_PREVIEW_MAX_ITEMS
)
{
break
;
}
}
return
true
;
}
]
Map
:
[
function
(
objectActor
grip
)
{
let
size
=
DevToolsUtils
.
getProperty
(
objectActor
.
obj
"
size
"
)
;
if
(
typeof
size
!
=
"
number
"
)
{
return
false
;
}
grip
.
preview
=
{
kind
:
"
MapLike
"
size
:
size
}
;
if
(
objectActor
.
hooks
.
getGripDepth
(
)
>
1
)
{
return
true
;
}
let
entries
=
grip
.
preview
.
entries
=
[
]
;
for
(
let
entry
of
PropertyIterators
.
enumMapEntries
(
objectActor
)
)
{
entries
.
push
(
entry
)
;
if
(
entries
.
length
=
=
OBJECT_PREVIEW_MAX_ITEMS
)
{
break
;
}
}
return
true
;
}
]
WeakMap
:
[
function
(
objectActor
grip
)
{
let
enumEntries
=
PropertyIterators
.
enumWeakMapEntries
(
objectActor
)
;
grip
.
preview
=
{
kind
:
"
MapLike
"
size
:
enumEntries
.
size
}
;
if
(
objectActor
.
hooks
.
getGripDepth
(
)
>
1
)
{
return
true
;
}
let
entries
=
grip
.
preview
.
entries
=
[
]
;
for
(
let
entry
of
enumEntries
)
{
entries
.
push
(
entry
)
;
if
(
entries
.
length
=
=
OBJECT_PREVIEW_MAX_ITEMS
)
{
break
;
}
}
return
true
;
}
]
DOMStringMap
:
[
function
(
{
obj
hooks
}
grip
rawObj
)
{
if
(
!
rawObj
)
{
return
false
;
}
let
keys
=
obj
.
getOwnPropertyNames
(
)
;
grip
.
preview
=
{
kind
:
"
MapLike
"
size
:
keys
.
length
}
;
if
(
hooks
.
getGripDepth
(
)
>
1
)
{
return
true
;
}
let
entries
=
grip
.
preview
.
entries
=
[
]
;
for
(
let
key
of
keys
)
{
let
value
=
ObjectUtils
.
makeDebuggeeValueIfNeeded
(
obj
rawObj
[
key
]
)
;
entries
.
push
(
[
key
hooks
.
createValueGrip
(
value
)
]
)
;
if
(
entries
.
length
=
=
OBJECT_PREVIEW_MAX_ITEMS
)
{
break
;
}
}
return
true
;
}
]
Proxy
:
[
function
(
{
obj
hooks
}
grip
rawObj
)
{
let
hasTargetAndHandler
=
obj
.
isProxy
;
if
(
hasTargetAndHandler
)
{
grip
.
proxyTarget
=
hooks
.
createValueGrip
(
obj
.
proxyTarget
)
;
grip
.
proxyHandler
=
hooks
.
createValueGrip
(
obj
.
proxyHandler
)
;
}
grip
.
preview
=
{
kind
:
"
Object
"
ownProperties
:
Object
.
create
(
null
)
ownPropertiesLength
:
2
*
hasTargetAndHandler
}
;
if
(
hooks
.
getGripDepth
(
)
>
1
)
{
return
true
;
}
if
(
hasTargetAndHandler
)
{
grip
.
preview
.
ownProperties
[
"
<
target
>
"
]
=
{
value
:
grip
.
proxyTarget
}
;
grip
.
preview
.
ownProperties
[
"
<
handler
>
"
]
=
{
value
:
grip
.
proxyHandler
}
;
}
return
true
;
}
]
}
;
function
wrappedPrimitivePreviewer
(
className
classObj
objectActor
grip
rawObj
)
{
let
{
obj
hooks
}
=
objectActor
;
let
v
=
null
;
try
{
v
=
classObj
.
prototype
.
valueOf
.
call
(
rawObj
)
;
}
catch
(
ex
)
{
return
false
;
}
if
(
v
=
=
=
null
)
{
return
false
;
}
let
canHandle
=
GenericObject
(
objectActor
grip
rawObj
className
=
=
=
"
String
"
)
;
if
(
!
canHandle
)
{
return
false
;
}
grip
.
preview
.
wrappedValue
=
hooks
.
createValueGrip
(
ObjectUtils
.
makeDebuggeeValueIfNeeded
(
obj
v
)
)
;
return
true
;
}
function
GenericObject
(
objectActor
grip
rawObj
specialStringBehavior
=
false
)
{
let
{
obj
hooks
}
=
objectActor
;
if
(
grip
.
preview
|
|
grip
.
displayString
|
|
hooks
.
getGripDepth
(
)
>
1
)
{
return
false
;
}
let
i
=
0
names
=
[
]
symbols
=
[
]
;
let
preview
=
grip
.
preview
=
{
kind
:
"
Object
"
ownProperties
:
Object
.
create
(
null
)
ownSymbols
:
[
]
}
;
try
{
if
(
ObjectUtils
.
isStorage
(
obj
)
)
{
for
(
let
j
=
0
;
j
<
rawObj
.
length
;
j
+
+
)
{
names
.
push
(
rawObj
.
key
(
j
)
)
;
}
}
else
{
names
=
obj
.
getOwnPropertyNames
(
)
;
}
symbols
=
obj
.
getOwnPropertySymbols
(
)
;
}
catch
(
ex
)
{
}
preview
.
ownPropertiesLength
=
names
.
length
;
preview
.
ownSymbolsLength
=
symbols
.
length
;
let
length
;
if
(
specialStringBehavior
)
{
length
=
DevToolsUtils
.
getProperty
(
obj
"
length
"
)
;
if
(
typeof
length
!
=
"
number
"
)
{
specialStringBehavior
=
false
;
}
}
for
(
let
name
of
names
)
{
if
(
specialStringBehavior
&
&
/
^
[
0
-
9
]
+
/
.
test
(
name
)
)
{
let
num
=
parseInt
(
name
10
)
;
if
(
num
.
toString
(
)
=
=
=
name
&
&
num
>
=
0
&
&
num
<
length
)
{
continue
;
}
}
let
desc
=
objectActor
.
_propertyDescriptor
(
name
true
)
;
if
(
!
desc
)
{
continue
;
}
preview
.
ownProperties
[
name
]
=
desc
;
if
(
+
+
i
=
=
OBJECT_PREVIEW_MAX_ITEMS
)
{
break
;
}
}
for
(
let
symbol
of
symbols
)
{
let
descriptor
=
objectActor
.
_propertyDescriptor
(
symbol
true
)
;
if
(
!
descriptor
)
{
continue
;
}
preview
.
ownSymbols
.
push
(
Object
.
assign
(
{
descriptor
}
hooks
.
createValueGrip
(
symbol
)
)
)
;
if
(
+
+
i
=
=
OBJECT_PREVIEW_MAX_ITEMS
)
{
break
;
}
}
if
(
i
<
OBJECT_PREVIEW_MAX_ITEMS
)
{
preview
.
safeGetterValues
=
objectActor
.
_findSafeGetterValues
(
Object
.
keys
(
preview
.
ownProperties
)
OBJECT_PREVIEW_MAX_ITEMS
-
i
)
;
}
return
true
;
}
previewers
.
Object
=
[
function
TypedArray
(
{
obj
hooks
}
grip
)
{
if
(
!
ObjectUtils
.
isTypedArray
(
obj
)
)
{
return
false
;
}
grip
.
preview
=
{
kind
:
"
ArrayLike
"
length
:
ObjectUtils
.
getArrayLength
(
obj
)
}
;
if
(
hooks
.
getGripDepth
(
)
>
1
)
{
return
true
;
}
let
raw
=
obj
.
unsafeDereference
(
)
;
let
global
=
Cu
.
getGlobalForObject
(
DebuggerServer
)
;
let
classProto
=
global
[
obj
.
class
]
.
prototype
;
let
safeView
=
Cu
.
cloneInto
(
classProto
.
subarray
.
call
(
raw
0
OBJECT_PREVIEW_MAX_ITEMS
)
global
)
;
let
items
=
grip
.
preview
.
items
=
[
]
;
for
(
let
i
=
0
;
i
<
safeView
.
length
;
i
+
+
)
{
items
.
push
(
safeView
[
i
]
)
;
}
return
true
;
}
function
Error
(
{
obj
hooks
}
grip
)
{
switch
(
obj
.
class
)
{
case
"
Error
"
:
case
"
EvalError
"
:
case
"
RangeError
"
:
case
"
ReferenceError
"
:
case
"
SyntaxError
"
:
case
"
TypeError
"
:
case
"
URIError
"
:
let
name
=
DevToolsUtils
.
getProperty
(
obj
"
name
"
)
;
let
msg
=
DevToolsUtils
.
getProperty
(
obj
"
message
"
)
;
let
stack
=
DevToolsUtils
.
getProperty
(
obj
"
stack
"
)
;
let
fileName
=
DevToolsUtils
.
getProperty
(
obj
"
fileName
"
)
;
let
lineNumber
=
DevToolsUtils
.
getProperty
(
obj
"
lineNumber
"
)
;
let
columnNumber
=
DevToolsUtils
.
getProperty
(
obj
"
columnNumber
"
)
;
grip
.
preview
=
{
kind
:
"
Error
"
name
:
hooks
.
createValueGrip
(
name
)
message
:
hooks
.
createValueGrip
(
msg
)
stack
:
hooks
.
createValueGrip
(
stack
)
fileName
:
hooks
.
createValueGrip
(
fileName
)
lineNumber
:
hooks
.
createValueGrip
(
lineNumber
)
columnNumber
:
hooks
.
createValueGrip
(
columnNumber
)
}
;
return
true
;
default
:
return
false
;
}
}
function
CSSMediaRule
(
{
obj
hooks
}
grip
rawObj
)
{
if
(
isWorker
|
|
!
rawObj
|
|
obj
.
class
!
=
"
CSSMediaRule
"
)
{
return
false
;
}
grip
.
preview
=
{
kind
:
"
ObjectWithText
"
text
:
hooks
.
createValueGrip
(
rawObj
.
conditionText
)
}
;
return
true
;
}
function
CSSStyleRule
(
{
obj
hooks
}
grip
rawObj
)
{
if
(
isWorker
|
|
!
rawObj
|
|
obj
.
class
!
=
"
CSSStyleRule
"
)
{
return
false
;
}
grip
.
preview
=
{
kind
:
"
ObjectWithText
"
text
:
hooks
.
createValueGrip
(
rawObj
.
selectorText
)
}
;
return
true
;
}
function
ObjectWithURL
(
{
obj
hooks
}
grip
rawObj
)
{
if
(
isWorker
|
|
!
rawObj
|
|
!
(
obj
.
class
=
=
"
CSSImportRule
"
|
|
obj
.
class
=
=
"
CSSStyleSheet
"
|
|
obj
.
class
=
=
"
Location
"
|
|
rawObj
instanceof
Ci
.
nsIDOMWindow
)
)
{
return
false
;
}
let
url
;
if
(
rawObj
instanceof
Ci
.
nsIDOMWindow
&
&
rawObj
.
location
)
{
url
=
rawObj
.
location
.
href
;
}
else
if
(
rawObj
.
href
)
{
url
=
rawObj
.
href
;
}
else
{
return
false
;
}
grip
.
preview
=
{
kind
:
"
ObjectWithURL
"
url
:
hooks
.
createValueGrip
(
url
)
}
;
return
true
;
}
function
ArrayLike
(
{
obj
hooks
}
grip
rawObj
)
{
if
(
isWorker
|
|
!
rawObj
|
|
obj
.
class
!
=
"
DOMStringList
"
&
&
obj
.
class
!
=
"
DOMTokenList
"
&
&
obj
.
class
!
=
"
CSSRuleList
"
&
&
obj
.
class
!
=
"
MediaList
"
&
&
obj
.
class
!
=
"
StyleSheetList
"
&
&
obj
.
class
!
=
"
CSSValueList
"
&
&
obj
.
class
!
=
"
NamedNodeMap
"
&
&
obj
.
class
!
=
"
FileList
"
&
&
obj
.
class
!
=
"
NodeList
"
)
{
return
false
;
}
if
(
typeof
rawObj
.
length
!
=
"
number
"
)
{
return
false
;
}
grip
.
preview
=
{
kind
:
"
ArrayLike
"
length
:
rawObj
.
length
}
;
if
(
hooks
.
getGripDepth
(
)
>
1
)
{
return
true
;
}
let
items
=
grip
.
preview
.
items
=
[
]
;
for
(
let
i
=
0
;
i
<
rawObj
.
length
&
&
items
.
length
<
OBJECT_PREVIEW_MAX_ITEMS
;
i
+
+
)
{
let
value
=
ObjectUtils
.
makeDebuggeeValueIfNeeded
(
obj
rawObj
[
i
]
)
;
items
.
push
(
hooks
.
createValueGrip
(
value
)
)
;
}
return
true
;
}
function
CSSStyleDeclaration
(
{
obj
hooks
}
grip
rawObj
)
{
if
(
isWorker
|
|
!
rawObj
|
|
(
obj
.
class
!
=
"
CSSStyleDeclaration
"
&
&
obj
.
class
!
=
"
CSS2Properties
"
)
)
{
return
false
;
}
grip
.
preview
=
{
kind
:
"
MapLike
"
size
:
rawObj
.
length
}
;
let
entries
=
grip
.
preview
.
entries
=
[
]
;
for
(
let
i
=
0
;
i
<
OBJECT_PREVIEW_MAX_ITEMS
&
&
i
<
rawObj
.
length
;
i
+
+
)
{
let
prop
=
rawObj
[
i
]
;
let
value
=
rawObj
.
getPropertyValue
(
prop
)
;
entries
.
push
(
[
prop
hooks
.
createValueGrip
(
value
)
]
)
;
}
return
true
;
}
function
DOMNode
(
{
obj
hooks
}
grip
rawObj
)
{
if
(
isWorker
|
|
obj
.
class
=
=
"
Object
"
|
|
!
rawObj
|
|
!
(
rawObj
instanceof
Ci
.
nsIDOMNode
)
)
{
return
false
;
}
let
preview
=
grip
.
preview
=
{
kind
:
"
DOMNode
"
nodeType
:
rawObj
.
nodeType
nodeName
:
rawObj
.
nodeName
isConnected
:
rawObj
.
isConnected
=
=
=
true
}
;
if
(
rawObj
instanceof
Ci
.
nsIDOMDocument
&
&
rawObj
.
location
)
{
preview
.
location
=
hooks
.
createValueGrip
(
rawObj
.
location
.
href
)
;
}
else
if
(
obj
.
class
=
=
"
DocumentFragment
"
)
{
preview
.
childNodesLength
=
rawObj
.
childNodes
.
length
;
if
(
hooks
.
getGripDepth
(
)
<
2
)
{
preview
.
childNodes
=
[
]
;
for
(
let
node
of
rawObj
.
childNodes
)
{
let
actor
=
hooks
.
createValueGrip
(
obj
.
makeDebuggeeValue
(
node
)
)
;
preview
.
childNodes
.
push
(
actor
)
;
if
(
preview
.
childNodes
.
length
=
=
OBJECT_PREVIEW_MAX_ITEMS
)
{
break
;
}
}
}
}
else
if
(
Element
.
isInstance
(
rawObj
)
)
{
if
(
rawObj
.
namespaceURI
=
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
)
{
preview
.
nodeName
=
preview
.
nodeName
.
toLowerCase
(
)
;
}
preview
.
attributes
=
{
}
;
preview
.
attributesLength
=
rawObj
.
attributes
.
length
;
for
(
let
attr
of
rawObj
.
attributes
)
{
preview
.
attributes
[
attr
.
nodeName
]
=
hooks
.
createValueGrip
(
attr
.
value
)
;
}
}
else
if
(
obj
.
class
=
=
"
Attr
"
)
{
preview
.
value
=
hooks
.
createValueGrip
(
rawObj
.
value
)
;
}
else
if
(
obj
.
class
=
=
"
Text
"
|
|
obj
.
class
=
=
"
CDATASection
"
|
|
obj
.
class
=
=
"
Comment
"
)
{
preview
.
textContent
=
hooks
.
createValueGrip
(
rawObj
.
textContent
)
;
}
return
true
;
}
function
DOMEvent
(
{
obj
hooks
}
grip
rawObj
)
{
if
(
isWorker
|
|
!
rawObj
|
|
!
Event
.
isInstance
(
rawObj
)
)
{
return
false
;
}
let
preview
=
grip
.
preview
=
{
kind
:
"
DOMEvent
"
type
:
rawObj
.
type
properties
:
Object
.
create
(
null
)
}
;
if
(
hooks
.
getGripDepth
(
)
<
2
)
{
let
target
=
obj
.
makeDebuggeeValue
(
rawObj
.
target
)
;
preview
.
target
=
hooks
.
createValueGrip
(
target
)
;
}
let
props
=
[
]
;
if
(
obj
.
class
=
=
"
MouseEvent
"
|
|
obj
.
class
=
=
"
DragEvent
"
|
|
obj
.
class
=
=
"
PointerEvent
"
|
|
obj
.
class
=
=
"
SimpleGestureEvent
"
|
|
obj
.
class
=
=
"
WheelEvent
"
)
{
props
.
push
(
"
buttons
"
"
clientX
"
"
clientY
"
"
layerX
"
"
layerY
"
)
;
}
else
if
(
obj
.
class
=
=
"
KeyboardEvent
"
)
{
let
modifiers
=
[
]
;
if
(
rawObj
.
altKey
)
{
modifiers
.
push
(
"
Alt
"
)
;
}
if
(
rawObj
.
ctrlKey
)
{
modifiers
.
push
(
"
Control
"
)
;
}
if
(
rawObj
.
metaKey
)
{
modifiers
.
push
(
"
Meta
"
)
;
}
if
(
rawObj
.
shiftKey
)
{
modifiers
.
push
(
"
Shift
"
)
;
}
preview
.
eventKind
=
"
key
"
;
preview
.
modifiers
=
modifiers
;
props
.
push
(
"
key
"
"
charCode
"
"
keyCode
"
)
;
}
else
if
(
obj
.
class
=
=
"
TransitionEvent
"
)
{
props
.
push
(
"
propertyName
"
"
pseudoElement
"
)
;
}
else
if
(
obj
.
class
=
=
"
AnimationEvent
"
)
{
props
.
push
(
"
animationName
"
"
pseudoElement
"
)
;
}
else
if
(
obj
.
class
=
=
"
ClipboardEvent
"
)
{
props
.
push
(
"
clipboardData
"
)
;
}
for
(
let
prop
of
props
)
{
let
value
=
rawObj
[
prop
]
;
if
(
value
&
&
(
typeof
value
=
=
"
object
"
|
|
typeof
value
=
=
"
function
"
)
)
{
if
(
hooks
.
getGripDepth
(
)
>
1
)
{
continue
;
}
value
=
obj
.
makeDebuggeeValue
(
value
)
;
}
preview
.
properties
[
prop
]
=
hooks
.
createValueGrip
(
value
)
;
}
if
(
!
props
.
length
)
{
let
i
=
0
;
for
(
let
prop
in
rawObj
)
{
let
value
=
rawObj
[
prop
]
;
if
(
prop
=
=
"
target
"
|
|
prop
=
=
"
type
"
|
|
value
=
=
=
null
|
|
typeof
value
=
=
"
function
"
)
{
continue
;
}
if
(
value
&
&
typeof
value
=
=
"
object
"
)
{
if
(
hooks
.
getGripDepth
(
)
>
1
)
{
continue
;
}
value
=
obj
.
makeDebuggeeValue
(
value
)
;
}
preview
.
properties
[
prop
]
=
hooks
.
createValueGrip
(
value
)
;
if
(
+
+
i
=
=
OBJECT_PREVIEW_MAX_ITEMS
)
{
break
;
}
}
}
return
true
;
}
function
DOMException
(
{
obj
hooks
}
grip
rawObj
)
{
if
(
isWorker
|
|
!
rawObj
|
|
obj
.
class
!
=
=
"
DOMException
"
)
{
return
false
;
}
grip
.
preview
=
{
kind
:
"
DOMException
"
name
:
hooks
.
createValueGrip
(
rawObj
.
name
)
message
:
hooks
.
createValueGrip
(
rawObj
.
message
)
code
:
hooks
.
createValueGrip
(
rawObj
.
code
)
result
:
hooks
.
createValueGrip
(
rawObj
.
result
)
filename
:
hooks
.
createValueGrip
(
rawObj
.
filename
)
lineNumber
:
hooks
.
createValueGrip
(
rawObj
.
lineNumber
)
columnNumber
:
hooks
.
createValueGrip
(
rawObj
.
columnNumber
)
}
;
return
true
;
}
function
PseudoArray
(
{
obj
hooks
}
grip
rawObj
)
{
let
keys
;
try
{
keys
=
obj
.
getOwnPropertyNames
(
)
;
}
catch
(
err
)
{
return
false
;
}
let
{
length
}
=
keys
;
if
(
length
=
=
=
0
)
{
return
false
;
}
if
(
keys
[
length
-
1
]
=
=
=
"
length
"
)
{
-
-
length
;
if
(
length
=
=
=
0
|
|
length
!
=
=
DevToolsUtils
.
getProperty
(
obj
"
length
"
)
)
{
return
false
;
}
}
let
lastKey
=
keys
[
length
-
1
]
;
if
(
!
ObjectUtils
.
isArrayIndex
(
lastKey
)
|
|
+
lastKey
!
=
=
length
-
1
)
{
return
false
;
}
grip
.
preview
=
{
kind
:
"
ArrayLike
"
length
:
length
}
;
if
(
hooks
.
getGripDepth
(
)
>
1
)
{
return
true
;
}
let
items
=
grip
.
preview
.
items
=
[
]
;
let
numItems
=
Math
.
min
(
OBJECT_PREVIEW_MAX_ITEMS
length
)
;
for
(
let
i
=
0
;
i
<
numItems
;
+
+
i
)
{
let
desc
=
obj
.
getOwnPropertyDescriptor
(
i
)
;
if
(
desc
&
&
"
value
"
in
desc
)
{
items
.
push
(
hooks
.
createValueGrip
(
desc
.
value
)
)
;
}
else
{
items
.
push
(
null
)
;
}
}
return
true
;
}
function
Object
(
objectActor
grip
rawObj
)
{
return
GenericObject
(
objectActor
grip
rawObj
false
)
;
}
]
;
module
.
exports
=
previewers
;
