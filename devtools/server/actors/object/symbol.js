"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
symbolSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
symbol
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
createValueGrip
"
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
utils
.
js
"
true
)
;
class
SymbolActor
extends
Actor
{
constructor
(
threadActor
symbol
)
{
super
(
threadActor
.
conn
symbolSpec
)
;
this
.
threadActor
=
threadActor
;
this
.
symbol
=
symbol
;
this
.
rawObj
=
this
.
symbol
;
}
destroy
(
)
{
this
.
_releaseActor
(
)
;
super
.
destroy
(
)
;
this
.
threadActor
=
null
;
}
form
(
)
{
const
form
=
{
type
:
this
.
typeName
actor
:
this
.
actorID
}
;
const
name
=
getSymbolName
(
this
.
symbol
)
;
if
(
name
!
=
=
undefined
)
{
form
.
name
=
createValueGrip
(
this
.
threadActor
name
this
.
getParent
(
)
)
;
}
return
form
;
}
release
(
)
{
this
.
_releaseActor
(
)
;
this
.
destroy
(
)
;
return
{
}
;
}
_releaseActor
(
)
{
const
parent
=
this
.
getParent
(
)
;
if
(
parent
&
&
parent
.
symbolActors
)
{
delete
parent
.
symbolActors
[
this
.
symbol
]
;
}
}
}
const
symbolProtoToString
=
Symbol
.
prototype
.
toString
;
function
getSymbolName
(
symbol
)
{
const
name
=
symbolProtoToString
.
call
(
symbol
)
.
slice
(
"
Symbol
(
"
.
length
-
1
)
;
return
name
|
|
undefined
;
}
function
symbolGrip
(
threadActor
sym
pool
)
{
if
(
!
pool
.
symbolActors
)
{
pool
.
symbolActors
=
Object
.
create
(
null
)
;
}
if
(
sym
in
pool
.
symbolActors
)
{
return
pool
.
symbolActors
[
sym
]
.
form
(
)
;
}
const
actor
=
new
SymbolActor
(
threadActor
sym
)
;
pool
.
manage
(
actor
)
;
pool
.
symbolActors
[
sym
]
=
actor
;
return
actor
.
form
(
)
;
}
module
.
exports
=
{
SymbolActor
symbolGrip
}
;
