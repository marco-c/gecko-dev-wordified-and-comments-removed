"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
debugger
-
server
"
)
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
workerTargetSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
targets
/
worker
"
)
;
loader
.
lazyRequireGetter
(
this
"
ChromeUtils
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
swm
"
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
"
nsIServiceWorkerManager
"
)
;
const
WorkerTargetActor
=
protocol
.
ActorClassWithSpec
(
workerTargetSpec
{
initialize
(
conn
dbg
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
_dbg
=
dbg
;
this
.
_attached
=
false
;
this
.
_threadActor
=
null
;
this
.
_transport
=
null
;
}
form
(
)
{
const
form
=
{
actor
:
this
.
actorID
consoleActor
:
this
.
_consoleActor
threadActor
:
this
.
_threadActor
id
:
this
.
_dbg
.
id
url
:
this
.
_dbg
.
url
traits
:
{
isParentInterceptEnabled
:
swm
.
isParentInterceptEnabled
(
)
}
type
:
this
.
_dbg
.
type
}
;
if
(
this
.
_dbg
.
type
=
=
=
Ci
.
nsIWorkerDebugger
.
TYPE_SERVICE
)
{
if
(
!
swm
.
isParentInterceptEnabled
(
)
|
|
!
DebuggerServer
.
isInChildProcess
)
{
const
registration
=
this
.
_getServiceWorkerRegistrationInfo
(
)
;
form
.
scope
=
registration
.
scope
;
const
newestWorker
=
registration
.
activeWorker
|
|
registration
.
waitingWorker
|
|
registration
.
installingWorker
;
form
.
fetch
=
newestWorker
&
&
newestWorker
.
handlesFetchEvents
;
}
}
return
form
;
}
attach
(
)
{
if
(
this
.
_dbg
.
isClosed
)
{
return
{
error
:
"
closed
"
}
;
}
if
(
!
this
.
_attached
)
{
const
isServiceWorker
=
this
.
_dbg
.
type
=
=
Ci
.
nsIWorkerDebugger
.
TYPE_SERVICE
;
if
(
isServiceWorker
)
{
this
.
_preventServiceWorkerShutdown
(
)
;
}
this
.
_dbg
.
addListener
(
this
)
;
this
.
_attached
=
true
;
}
return
{
type
:
"
attached
"
url
:
this
.
_dbg
.
url
}
;
}
detach
(
)
{
if
(
!
this
.
_attached
)
{
return
{
error
:
"
wrongState
"
}
;
}
this
.
_detach
(
)
;
return
{
type
:
"
detached
"
}
;
}
destroy
(
)
{
if
(
this
.
_attached
)
{
this
.
_detach
(
)
;
}
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
}
connect
(
options
)
{
if
(
!
this
.
_attached
)
{
return
{
error
:
"
wrongState
"
}
;
}
if
(
this
.
_threadActor
!
=
=
null
)
{
return
{
type
:
"
connected
"
threadActor
:
this
.
_threadActor
}
;
}
return
DebuggerServer
.
connectToWorker
(
this
.
conn
this
.
_dbg
this
.
actorID
options
)
.
then
(
(
{
threadActor
transport
consoleActor
}
)
=
>
{
this
.
_threadActor
=
threadActor
;
this
.
_transport
=
transport
;
this
.
_consoleActor
=
consoleActor
;
return
{
type
:
"
connected
"
threadActor
:
this
.
_threadActor
consoleActor
:
this
.
_consoleActor
}
;
}
error
=
>
{
return
{
error
:
error
.
toString
(
)
}
;
}
)
;
}
push
(
)
{
if
(
this
.
_dbg
.
type
!
=
=
Ci
.
nsIWorkerDebugger
.
TYPE_SERVICE
)
{
return
{
error
:
"
wrongType
"
}
;
}
const
registration
=
this
.
_getServiceWorkerRegistrationInfo
(
)
;
const
originAttributes
=
ChromeUtils
.
originAttributesToSuffix
(
this
.
_dbg
.
principal
.
originAttributes
)
;
swm
.
sendPushEvent
(
originAttributes
registration
.
scope
)
;
return
{
type
:
"
pushed
"
}
;
}
onClose
(
)
{
if
(
this
.
_attached
)
{
this
.
_detach
(
)
;
}
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
close
"
)
;
}
onError
(
filename
lineno
message
)
{
reportError
(
"
ERROR
:
"
+
filename
+
"
:
"
+
lineno
+
"
:
"
+
message
+
"
\
n
"
)
;
}
_getServiceWorkerRegistrationInfo
(
)
{
return
swm
.
getRegistrationByPrincipal
(
this
.
_dbg
.
principal
this
.
_dbg
.
url
)
;
}
_getServiceWorkerInfo
(
)
{
const
registration
=
this
.
_getServiceWorkerRegistrationInfo
(
)
;
return
registration
.
getWorkerByID
(
this
.
_dbg
.
serviceWorkerID
)
;
}
_detach
(
)
{
if
(
this
.
_threadActor
!
=
=
null
)
{
this
.
_transport
.
close
(
)
;
this
.
_transport
=
null
;
this
.
_threadActor
=
null
;
}
let
type
;
try
{
type
=
this
.
_dbg
.
type
;
}
catch
(
e
)
{
}
const
isServiceWorker
=
type
=
=
Ci
.
nsIWorkerDebugger
.
TYPE_SERVICE
;
if
(
isServiceWorker
)
{
this
.
_allowServiceWorkerShutdown
(
)
;
}
this
.
_dbg
.
removeListener
(
this
)
;
this
.
_attached
=
false
;
}
_preventServiceWorkerShutdown
(
)
{
if
(
swm
.
isParentInterceptEnabled
(
)
)
{
return
;
}
const
worker
=
this
.
_getServiceWorkerInfo
(
)
;
if
(
worker
)
{
worker
.
attachDebugger
(
)
;
}
}
_allowServiceWorkerShutdown
(
)
{
if
(
swm
.
isParentInterceptEnabled
(
)
)
{
return
;
}
const
worker
=
this
.
_getServiceWorkerInfo
(
)
;
if
(
worker
)
{
worker
.
detachDebugger
(
)
;
}
}
}
)
;
exports
.
WorkerTargetActor
=
WorkerTargetActor
;
