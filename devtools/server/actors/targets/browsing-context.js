"
use
strict
"
;
var
{
Ci
Cu
Cr
Cc
}
=
require
(
"
chrome
"
)
;
var
Services
=
require
(
"
Services
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
var
{
ActorRegistry
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
actor
-
registry
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
{
assert
}
=
DevToolsUtils
;
var
{
TabSources
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
TabSources
"
)
;
var
makeDebugger
=
require
(
"
devtools
/
server
/
actors
/
utils
/
make
-
debugger
"
)
;
const
InspectorUtils
=
require
(
"
InspectorUtils
"
)
;
const
{
TargetActorRegistry
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
target
-
actor
-
registry
.
jsm
"
)
;
const
EXTENSION_CONTENT_JSM
=
"
resource
:
/
/
gre
/
modules
/
ExtensionContent
.
jsm
"
;
const
{
ActorClassWithSpec
Actor
Pool
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
LazyPool
createExtraActors
}
=
require
(
"
devtools
/
shared
/
protocol
/
lazy
-
pool
"
)
;
const
{
browsingContextTargetSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
targets
/
browsing
-
context
"
)
;
const
Resources
=
require
(
"
devtools
/
server
/
actors
/
resources
/
index
"
)
;
loader
.
lazyRequireGetter
(
this
"
ThreadActor
"
"
devtools
/
server
/
actors
/
thread
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
unwrapDebuggerObjectGlobal
"
"
devtools
/
server
/
actors
/
thread
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WorkerTargetActorList
"
"
devtools
/
server
/
actors
/
worker
/
worker
-
target
-
actor
-
list
"
true
)
;
loader
.
lazyImporter
(
this
"
ExtensionContent
"
EXTENSION_CONTENT_JSM
)
;
loader
.
lazyRequireGetter
(
this
"
StyleSheetActor
"
"
devtools
/
server
/
actors
/
stylesheets
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getSheetText
"
"
devtools
/
server
/
actors
/
stylesheets
"
true
)
;
function
getWindowID
(
window
)
{
return
window
.
windowUtils
.
currentInnerWindowID
;
}
function
getDocShellChromeEventHandler
(
docShell
)
{
let
handler
=
docShell
.
chromeEventHandler
;
if
(
!
handler
)
{
try
{
handler
=
docShell
.
domWindow
;
}
catch
(
e
)
{
}
}
return
handler
;
}
function
getChildDocShells
(
parentDocShell
)
{
const
allDocShells
=
parentDocShell
.
getAllDocShellsInSubtree
(
Ci
.
nsIDocShellTreeItem
.
typeAll
Ci
.
nsIDocShell
.
ENUMERATE_FORWARDS
)
;
const
docShells
=
[
]
;
for
(
const
docShell
of
allDocShells
)
{
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
docShells
.
push
(
docShell
)
;
}
return
docShells
;
}
exports
.
getChildDocShells
=
getChildDocShells
;
function
getInnerId
(
window
)
{
return
window
.
windowUtils
.
currentInnerWindowID
;
}
const
browsingContextTargetPrototype
=
{
initialize
:
function
(
connection
docShell
options
=
{
}
)
{
Actor
.
prototype
.
initialize
.
call
(
this
connection
)
;
if
(
!
docShell
)
{
throw
new
Error
(
"
A
docShell
should
be
provided
as
constructor
argument
of
BrowsingContextTargetActor
"
)
;
}
this
.
docShell
=
docShell
;
this
.
followWindowGlobalLifeCycle
=
options
.
followWindowGlobalLifeCycle
;
this
.
doNotFireFrameUpdates
=
options
.
doNotFireFrameUpdates
;
this
.
_extraActors
=
{
}
;
this
.
_exited
=
false
;
this
.
_sources
=
null
;
this
.
_styleSheetActors
=
new
Map
(
)
;
this
.
_shouldAddNewGlobalAsDebuggee
=
this
.
_shouldAddNewGlobalAsDebuggee
.
bind
(
this
)
;
this
.
makeDebugger
=
makeDebugger
.
bind
(
null
{
findDebuggees
:
(
)
=
>
{
return
this
.
windows
.
concat
(
this
.
webextensionsContentScriptGlobals
)
;
}
shouldAddNewGlobalAsDebuggee
:
this
.
_shouldAddNewGlobalAsDebuggee
}
)
;
this
.
watchNewDocShells
=
false
;
this
.
traits
=
{
reconfigure
:
true
frames
:
true
logInPage
:
true
watchpoints
:
true
navigation
:
true
}
;
this
.
_workerTargetActorList
=
null
;
this
.
_workerTargetActorPool
=
null
;
this
.
_onWorkerTargetActorListChanged
=
this
.
_onWorkerTargetActorListChanged
.
bind
(
this
)
;
TargetActorRegistry
.
registerTargetActor
(
this
)
;
this
.
_watchedResources
=
new
Set
(
)
;
}
watchTargetResources
(
resourceTypes
)
{
for
(
const
resourceType
of
resourceTypes
)
{
if
(
this
.
_watchedResources
.
has
(
resourceType
)
)
{
continue
;
}
this
.
_watchedResources
.
add
(
resourceType
)
;
this
.
_watchResource
(
resourceType
)
;
}
}
unwatchTargetResources
(
resourceTypes
)
{
for
(
const
resourceType
of
resourceTypes
)
{
if
(
!
this
.
_watchedResources
.
has
(
resourceType
)
)
{
continue
;
}
this
.
_watchedResources
.
delete
(
resourceType
)
;
this
.
_unwatchResource
(
resourceType
)
;
}
}
_watchResource
(
resourceType
)
{
if
(
!
(
resourceType
in
Resources
.
LISTENERS
)
)
{
throw
new
Error
(
Unsupported
resource
type
'
{
resourceType
}
'
)
;
}
const
onAvailable
=
resources
=
>
{
this
.
emit
(
"
resource
-
available
-
form
"
resources
)
;
}
;
Resources
.
LISTENERS
[
resourceType
]
.
watch
(
this
{
onAvailable
}
)
;
}
_unwatchResource
(
resourceType
)
{
if
(
!
(
resourceType
in
Resources
.
LISTENERS
)
)
{
throw
new
Error
(
Unsupported
resource
type
'
{
resourceType
}
'
)
;
}
Resources
.
LISTENERS
[
resourceType
]
.
unwatch
(
this
)
;
}
traits
:
null
consoleAPIListenerOptions
:
{
}
_allowSource
(
)
{
return
true
;
}
get
exited
(
)
{
return
this
.
_exited
;
}
get
attached
(
)
{
return
!
!
this
.
_attached
;
}
get
dbg
(
)
{
if
(
!
this
.
_dbg
)
{
this
.
_dbg
=
this
.
makeDebugger
(
)
;
}
return
this
.
_dbg
;
}
get
_consoleActor
(
)
{
if
(
this
.
exited
|
|
!
this
.
actorID
)
{
return
null
;
}
const
form
=
this
.
form
(
)
;
return
this
.
conn
.
_getOrCreateActor
(
form
.
consoleActor
)
;
}
_targetScopedActorPool
:
null
typeName
:
"
browsingContextTarget
"
get
chromeEventHandler
(
)
{
return
getDocShellChromeEventHandler
(
this
.
docShell
)
;
}
get
messageManager
(
)
{
try
{
return
this
.
docShell
.
messageManager
;
}
catch
(
e
)
{
return
null
;
}
}
get
docShells
(
)
{
return
getChildDocShells
(
this
.
docShell
)
;
}
get
window
(
)
{
return
this
.
docShell
&
&
this
.
docShell
.
domWindow
;
}
get
outerWindowID
(
)
{
if
(
this
.
window
)
{
return
this
.
window
.
windowUtils
.
outerWindowID
;
}
return
null
;
}
get
browsingContextID
(
)
{
return
this
.
docShell
&
&
this
.
docShell
.
browsingContext
.
id
;
}
get
webextensionsContentScriptGlobals
(
)
{
if
(
Cu
.
isModuleLoaded
(
EXTENSION_CONTENT_JSM
)
)
{
return
ExtensionContent
.
getContentScriptGlobals
(
this
.
window
)
;
}
return
[
]
;
}
get
windows
(
)
{
return
this
.
docShells
.
map
(
docShell
=
>
{
return
docShell
.
domWindow
;
}
)
;
}
get
originalDocShell
(
)
{
if
(
!
this
.
_originalWindow
)
{
return
this
.
docShell
;
}
return
this
.
_originalWindow
.
docShell
;
}
get
originalWindow
(
)
{
return
this
.
_originalWindow
|
|
this
.
window
;
}
get
webProgress
(
)
{
return
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
}
get
webNavigation
(
)
{
return
this
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
}
get
contentDocument
(
)
{
return
this
.
webNavigation
.
document
;
}
get
title
(
)
{
return
this
.
contentDocument
.
contentTitle
;
}
get
url
(
)
{
if
(
this
.
webNavigation
.
currentURI
)
{
return
this
.
webNavigation
.
currentURI
.
spec
;
}
return
null
;
}
get
sources
(
)
{
if
(
!
this
.
_sources
)
{
this
.
_sources
=
new
TabSources
(
this
.
threadActor
this
.
_allowSource
)
;
}
return
this
.
_sources
;
}
_createExtraActors
(
)
{
if
(
!
this
.
_targetScopedActorPool
)
{
this
.
_targetScopedActorPool
=
new
LazyPool
(
this
.
conn
)
;
}
return
createExtraActors
(
ActorRegistry
.
targetScopedActorFactories
this
.
_targetScopedActorPool
this
)
;
}
form
(
)
{
assert
(
!
this
.
exited
"
form
(
)
shouldn
'
t
be
called
on
exited
browser
actor
.
"
)
;
assert
(
this
.
actorID
"
Actor
should
have
an
actorID
.
"
)
;
const
response
=
{
actor
:
this
.
actorID
browsingContextID
:
this
.
browsingContextID
traits
:
{
isBrowsingContext
:
true
}
}
;
if
(
!
this
.
docShell
.
isBeingDestroyed
(
)
)
{
response
.
title
=
this
.
title
;
response
.
url
=
this
.
url
;
response
.
outerWindowID
=
this
.
outerWindowID
;
}
const
actors
=
this
.
_createExtraActors
(
)
;
Object
.
assign
(
response
actors
)
;
if
(
this
.
threadActor
)
{
Object
.
assign
(
response
{
threadActor
:
this
.
threadActor
.
actorID
}
)
;
}
return
response
;
}
destroy
(
)
{
this
.
exit
(
)
;
Actor
.
prototype
.
destroy
.
call
(
this
)
;
TargetActorRegistry
.
unregisterTargetActor
(
this
)
;
if
(
this
.
_watchedResources
)
{
this
.
unwatchTargetResources
(
[
.
.
.
this
.
_watchedResources
]
)
;
}
}
exit
(
)
{
if
(
this
.
exited
)
{
return
;
}
if
(
this
.
_attached
)
{
this
.
threadActor
.
_parentClosed
=
true
;
}
this
.
_detach
(
)
;
this
.
docShell
=
null
;
this
.
_extraActors
=
null
;
this
.
_exited
=
true
;
}
_shouldAddNewGlobalAsDebuggee
(
wrappedGlobal
)
{
if
(
wrappedGlobal
.
hostAnnotations
&
&
wrappedGlobal
.
hostAnnotations
.
type
=
=
"
document
"
&
&
wrappedGlobal
.
hostAnnotations
.
element
=
=
=
this
.
window
)
{
return
true
;
}
const
global
=
unwrapDebuggerObjectGlobal
(
wrappedGlobal
)
;
if
(
!
global
)
{
return
false
;
}
let
metadata
=
{
}
;
let
id
=
"
"
;
try
{
id
=
getInnerId
(
this
.
window
)
;
metadata
=
Cu
.
getSandboxMetadata
(
global
)
;
}
catch
(
e
)
{
}
if
(
metadata
?
.
[
"
inner
-
window
-
id
"
]
&
&
metadata
[
"
inner
-
window
-
id
"
]
=
=
id
)
{
return
true
;
}
return
false
;
}
_attach
(
)
{
if
(
this
.
_attached
)
{
return
;
}
this
.
_createThreadActor
(
)
;
this
.
_progressListener
=
new
DebuggerProgressListener
(
this
)
;
this
.
_originalWindow
=
this
.
window
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
this
.
_watchDocshells
(
)
)
;
this
.
_attached
=
true
;
}
_watchDocshells
(
)
{
Services
.
obs
.
addObserver
(
this
"
webnavigation
-
create
"
)
;
Services
.
obs
.
addObserver
(
this
"
webnavigation
-
destroy
"
)
;
this
.
_progressListener
.
watch
(
this
.
docShell
)
;
this
.
_updateChildDocShells
(
)
;
}
_unwatchDocShell
(
docShell
)
{
if
(
this
.
_progressListener
)
{
this
.
_progressListener
.
unwatch
(
docShell
)
;
}
}
switchToFrame
(
request
)
{
const
windowId
=
request
.
windowId
;
let
win
;
try
{
win
=
Services
.
wm
.
getOuterWindowWithId
(
windowId
)
;
}
catch
(
e
)
{
}
if
(
!
win
)
{
throw
{
error
:
"
noWindow
"
message
:
"
The
related
docshell
is
destroyed
or
not
found
"
}
;
}
else
if
(
win
=
=
this
.
window
)
{
return
{
}
;
}
DevToolsUtils
.
executeSoon
(
(
)
=
>
this
.
_changeTopLevelDocument
(
win
)
)
;
return
{
}
;
}
listFrames
(
request
)
{
const
windows
=
this
.
_docShellsToWindows
(
this
.
docShells
)
;
return
{
frames
:
windows
}
;
}
ensureWorkerTargetActorList
(
)
{
if
(
this
.
_workerTargetActorList
=
=
=
null
)
{
this
.
_workerTargetActorList
=
new
WorkerTargetActorList
(
this
.
conn
{
type
:
Ci
.
nsIWorkerDebugger
.
TYPE_DEDICATED
window
:
this
.
window
}
)
;
}
return
this
.
_workerTargetActorList
;
}
pauseWorkersUntilAttach
(
shouldPause
)
{
this
.
ensureWorkerTargetActorList
(
)
.
workerPauser
.
setPauseMatching
(
shouldPause
)
;
}
listWorkers
(
request
)
{
if
(
!
this
.
attached
)
{
throw
{
error
:
"
wrongState
"
}
;
}
return
this
.
ensureWorkerTargetActorList
(
)
.
getList
(
)
.
then
(
actors
=
>
{
const
pool
=
new
Pool
(
this
.
conn
"
worker
-
targets
"
)
;
for
(
const
actor
of
actors
)
{
pool
.
manage
(
actor
)
;
}
if
(
this
.
_workerTargetActorPool
)
{
this
.
_workerTargetActorPool
.
destroy
(
)
;
}
this
.
_workerTargetActorPool
=
pool
;
this
.
_workerTargetActorList
.
onListChanged
=
this
.
_onWorkerTargetActorListChanged
;
return
{
workers
:
actors
}
;
}
)
;
}
logInPage
(
request
)
{
const
{
text
category
flags
}
=
request
;
const
scriptErrorClass
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
;
const
scriptError
=
scriptErrorClass
.
createInstance
(
Ci
.
nsIScriptError
)
;
scriptError
.
initWithWindowID
(
text
null
null
0
0
flags
category
getInnerId
(
this
.
window
)
)
;
Services
.
console
.
logMessage
(
scriptError
)
;
return
{
}
;
}
_onWorkerTargetActorListChanged
(
)
{
this
.
_workerTargetActorList
.
onListChanged
=
null
;
this
.
emit
(
"
workerListChanged
"
)
;
}
observe
(
subject
topic
data
)
{
if
(
!
this
.
attached
)
{
return
;
}
subject
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
if
(
topic
=
=
"
webnavigation
-
create
"
)
{
this
.
_onDocShellCreated
(
subject
)
;
}
else
if
(
topic
=
=
"
webnavigation
-
destroy
"
)
{
this
.
_onDocShellDestroy
(
subject
)
;
}
}
_onDocShellCreated
(
docShell
)
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
if
(
docShell
.
isBeingDestroyed
(
)
)
{
return
;
}
if
(
this
.
_isRootDocShell
(
docShell
)
&
&
this
.
watchNewDocShells
)
{
this
.
_progressListener
.
watch
(
docShell
)
;
}
this
.
_notifyDocShellsUpdate
(
[
docShell
]
)
;
}
)
;
}
_onDocShellDestroy
(
docShell
)
{
this
.
_unwatchDocShell
(
docShell
)
;
const
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
this
.
_notifyDocShellDestroy
(
webProgress
)
;
if
(
webProgress
.
DOMWindow
=
=
this
.
_originalWindow
)
{
const
rootDocShells
=
this
.
docShells
.
filter
(
d
=
>
{
return
d
!
=
this
.
docShell
&
&
this
.
_isRootDocShell
(
d
)
;
}
)
;
if
(
rootDocShells
.
length
>
0
)
{
const
newRoot
=
rootDocShells
[
0
]
;
this
.
_originalWindow
=
newRoot
.
DOMWindow
;
this
.
_changeTopLevelDocument
(
this
.
_originalWindow
)
;
}
else
{
this
.
exit
(
)
;
}
return
;
}
if
(
webProgress
.
DOMWindow
=
=
this
.
window
&
&
this
.
window
!
=
this
.
_originalWindow
)
{
this
.
_changeTopLevelDocument
(
this
.
_originalWindow
)
;
}
}
_isRootDocShell
(
docShell
)
{
return
!
docShell
.
parent
;
}
_docShellToWindow
(
docShell
)
{
const
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
const
window
=
webProgress
.
DOMWindow
;
const
id
=
window
.
windowUtils
.
outerWindowID
;
let
parentID
=
undefined
;
if
(
window
.
parent
&
&
window
.
parent
!
=
window
&
&
window
!
=
this
.
_originalWindow
)
{
parentID
=
window
.
parent
.
windowUtils
.
outerWindowID
;
}
return
{
id
parentID
url
:
window
.
location
.
href
title
:
window
.
document
.
title
}
;
}
_docShellsToWindows
(
docshells
)
{
return
docshells
.
map
(
docShell
=
>
this
.
_docShellToWindow
(
docShell
)
)
;
}
_notifyDocShellsUpdate
(
docshells
)
{
if
(
this
.
doNotFireFrameUpdates
)
{
return
;
}
const
windows
=
this
.
_docShellsToWindows
(
docshells
)
;
if
(
windows
.
length
=
=
0
)
{
return
;
}
this
.
emit
(
"
frameUpdate
"
{
frames
:
windows
}
)
;
}
_updateChildDocShells
(
)
{
this
.
_notifyDocShellsUpdate
(
this
.
docShells
)
;
}
_notifyDocShellDestroy
(
webProgress
)
{
if
(
this
.
doNotFireFrameUpdates
)
{
return
;
}
webProgress
=
webProgress
.
QueryInterface
(
Ci
.
nsIWebProgress
)
;
const
id
=
webProgress
.
DOMWindow
.
windowUtils
.
outerWindowID
;
this
.
emit
(
"
frameUpdate
"
{
frames
:
[
{
id
destroy
:
true
}
]
}
)
;
}
_notifyDocShellDestroyAll
(
)
{
if
(
this
.
doNotFireFrameUpdates
)
{
return
;
}
this
.
emit
(
"
frameUpdate
"
{
destroyAll
:
true
}
)
;
}
_createThreadActor
(
)
{
this
.
threadActor
=
new
ThreadActor
(
this
this
.
window
)
;
this
.
manage
(
this
.
threadActor
)
;
}
_destroyThreadActor
(
)
{
this
.
threadActor
.
exit
(
)
;
this
.
threadActor
=
null
;
if
(
this
.
_sources
)
{
this
.
_sources
.
destroy
(
)
;
this
.
_sources
=
null
;
}
}
_detach
(
)
{
if
(
!
this
.
attached
)
{
return
false
;
}
if
(
this
.
docShell
)
{
this
.
_unwatchDocShell
(
this
.
docShell
)
;
this
.
_restoreDocumentSettings
(
)
;
}
if
(
this
.
_progressListener
)
{
this
.
_progressListener
.
destroy
(
)
;
this
.
_progressListener
=
null
;
this
.
_originalWindow
=
null
;
Services
.
obs
.
removeObserver
(
this
"
webnavigation
-
create
"
)
;
Services
.
obs
.
removeObserver
(
this
"
webnavigation
-
destroy
"
)
;
}
this
.
_destroyThreadActor
(
)
;
this
.
_styleSheetActors
.
clear
(
)
;
if
(
this
.
_targetScopedActorPool
)
{
this
.
_targetScopedActorPool
.
destroy
(
)
;
this
.
_targetScopedActorPool
=
null
;
}
if
(
this
.
_workerTargetActorList
!
=
=
null
)
{
this
.
_workerTargetActorList
.
destroy
(
)
;
this
.
_workerTargetActorList
=
null
;
}
if
(
this
.
_workerTargetActorPool
!
=
=
null
)
{
this
.
_workerTargetActorPool
.
destroy
(
)
;
this
.
_workerTargetActorPool
=
null
;
}
if
(
this
.
_dbg
)
{
this
.
_dbg
.
disable
(
)
;
this
.
_dbg
=
null
;
}
this
.
_attached
=
false
;
if
(
this
.
followWindowGlobalLifeCycle
)
{
return
true
;
}
this
.
emit
(
"
tabDetached
"
)
;
return
true
;
}
attach
(
request
)
{
if
(
this
.
exited
)
{
throw
{
error
:
"
exited
"
}
;
}
this
.
_attach
(
)
;
return
{
threadActor
:
this
.
threadActor
.
actorID
cacheDisabled
:
this
.
_getCacheDisabled
(
)
javascriptEnabled
:
this
.
_getJavascriptEnabled
(
)
traits
:
this
.
traits
}
;
}
detach
(
request
)
{
if
(
!
this
.
_detach
(
)
)
{
throw
{
error
:
"
wrongState
"
}
;
}
return
{
}
;
}
focus
(
)
{
if
(
this
.
window
)
{
this
.
window
.
focus
(
)
;
}
return
{
}
;
}
goForward
(
)
{
Services
.
tm
.
dispatchToMainThread
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
Services
.
startup
.
shuttingDown
)
{
return
;
}
this
.
webNavigation
.
goForward
(
)
;
}
"
BrowsingContextTargetActor
.
prototype
.
goForward
'
s
delayed
body
"
)
)
;
return
{
}
;
}
goBack
(
)
{
Services
.
tm
.
dispatchToMainThread
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
Services
.
startup
.
shuttingDown
)
{
return
;
}
this
.
webNavigation
.
goBack
(
)
;
}
"
BrowsingContextTargetActor
.
prototype
.
goBack
'
s
delayed
body
"
)
)
;
return
{
}
;
}
reload
(
request
)
{
const
force
=
request
?
.
options
?
.
force
;
Services
.
tm
.
dispatchToMainThread
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
Services
.
startup
.
shuttingDown
)
{
return
;
}
this
.
webNavigation
.
reload
(
force
?
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
)
;
}
"
BrowsingContextTargetActor
.
prototype
.
reload
'
s
delayed
body
"
)
)
;
return
{
}
;
}
navigateTo
(
request
)
{
Services
.
tm
.
dispatchToMainThread
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
this
.
window
.
location
=
request
.
url
;
}
"
BrowsingContextTargetActor
.
prototype
.
navigateTo
'
s
delayed
body
:
"
+
request
.
url
)
)
;
return
{
}
;
}
reconfigure
(
request
)
{
const
options
=
request
.
options
|
|
{
}
;
if
(
!
this
.
docShell
)
{
return
{
}
;
}
this
.
_toggleDevToolsSettings
(
options
)
;
return
{
}
;
}
async
ensureCSSErrorReportingEnabled
(
request
)
{
const
promises
=
[
]
;
for
(
const
docShell
of
this
.
docShells
)
{
if
(
docShell
.
cssErrorReportingEnabled
)
{
continue
;
}
try
{
docShell
.
cssErrorReportingEnabled
=
true
;
}
catch
(
e
)
{
continue
;
}
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
const
sheets
=
InspectorUtils
.
getAllStyleSheets
(
docShell
.
document
true
)
;
for
(
const
sheet
of
sheets
)
{
if
(
InspectorUtils
.
hasRulesModifiedByCSSOM
(
sheet
)
)
{
continue
;
}
const
onStyleSheetParsed
=
getSheetText
(
sheet
this
.
_consoleActor
)
.
then
(
text
=
>
{
InspectorUtils
.
parseStyleSheet
(
sheet
text
false
)
;
}
)
.
catch
(
e
=
>
console
.
error
(
"
Error
while
parsing
stylesheet
"
)
)
;
promises
.
push
(
onStyleSheetParsed
)
;
}
}
await
Promise
.
all
(
promises
)
;
return
{
}
;
}
_toggleDevToolsSettings
(
options
)
{
let
reload
=
false
;
if
(
typeof
options
.
javascriptEnabled
!
=
=
"
undefined
"
&
&
options
.
javascriptEnabled
!
=
=
this
.
_getJavascriptEnabled
(
)
)
{
this
.
_setJavascriptEnabled
(
options
.
javascriptEnabled
)
;
reload
=
true
;
}
if
(
typeof
options
.
cacheDisabled
!
=
=
"
undefined
"
&
&
options
.
cacheDisabled
!
=
=
this
.
_getCacheDisabled
(
)
)
{
this
.
_setCacheDisabled
(
options
.
cacheDisabled
)
;
}
if
(
typeof
options
.
paintFlashing
!
=
=
"
undefined
"
&
&
options
.
PaintFlashing
!
=
=
this
.
_getPaintFlashing
(
)
)
{
this
.
_setPaintFlashingEnabled
(
options
.
paintFlashing
)
;
}
if
(
typeof
options
.
serviceWorkersTestingEnabled
!
=
=
"
undefined
"
&
&
options
.
serviceWorkersTestingEnabled
!
=
=
this
.
_getServiceWorkersTestingEnabled
(
)
)
{
this
.
_setServiceWorkersTestingEnabled
(
options
.
serviceWorkersTestingEnabled
)
;
}
if
(
typeof
options
.
restoreFocus
=
=
"
boolean
"
)
{
this
.
_restoreFocus
=
options
.
restoreFocus
;
}
const
hasExplicitReloadFlag
=
"
performReload
"
in
options
;
if
(
(
hasExplicitReloadFlag
&
&
options
.
performReload
)
|
|
(
!
hasExplicitReloadFlag
&
&
reload
)
)
{
this
.
reload
(
)
;
}
}
_restoreDocumentSettings
(
)
{
this
.
_restoreJavascript
(
)
;
this
.
_setCacheDisabled
(
false
)
;
this
.
_setServiceWorkersTestingEnabled
(
false
)
;
this
.
_setPaintFlashingEnabled
(
false
)
;
if
(
this
.
_restoreFocus
&
&
this
.
window
.
docShell
.
isActive
)
{
this
.
window
.
focus
(
)
;
}
}
_setCacheDisabled
(
disabled
)
{
const
enable
=
Ci
.
nsIRequest
.
LOAD_NORMAL
;
const
disable
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
;
this
.
docShell
.
defaultLoadFlags
=
disabled
?
disable
:
enable
;
}
_wasJavascriptEnabled
:
null
_setJavascriptEnabled
(
allow
)
{
if
(
this
.
_wasJavascriptEnabled
=
=
=
null
)
{
this
.
_wasJavascriptEnabled
=
this
.
docShell
.
allowJavascript
;
}
this
.
docShell
.
allowJavascript
=
allow
;
}
_restoreJavascript
(
)
{
if
(
this
.
_wasJavascriptEnabled
!
=
=
null
)
{
this
.
_setJavascriptEnabled
(
this
.
_wasJavascriptEnabled
)
;
this
.
_wasJavascriptEnabled
=
null
;
}
}
_getJavascriptEnabled
(
)
{
if
(
!
this
.
docShell
)
{
return
null
;
}
return
this
.
docShell
.
allowJavascript
;
}
_setServiceWorkersTestingEnabled
(
enabled
)
{
const
windowUtils
=
this
.
window
.
windowUtils
;
windowUtils
.
serviceWorkersTestingEnabled
=
enabled
;
}
_setPaintFlashingEnabled
(
enabled
)
{
const
windowUtils
=
this
.
window
.
windowUtils
;
windowUtils
.
paintFlashing
=
enabled
;
}
_getCacheDisabled
(
)
{
if
(
!
this
.
docShell
)
{
return
null
;
}
const
disable
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
;
return
this
.
docShell
.
defaultLoadFlags
=
=
=
disable
;
}
_getPaintFlashing
(
)
{
if
(
!
this
.
docShell
)
{
return
null
;
}
return
this
.
window
.
windowUtils
.
paintFlashing
;
}
_getServiceWorkersTestingEnabled
(
)
{
if
(
!
this
.
docShell
)
{
return
null
;
}
const
windowUtils
=
this
.
window
.
windowUtils
;
return
windowUtils
.
serviceWorkersTestingEnabled
;
}
_changeTopLevelDocument
(
window
)
{
this
.
_willNavigate
(
this
.
window
window
.
location
.
href
null
true
)
;
this
.
_windowDestroyed
(
this
.
window
null
true
)
;
this
.
_setWindow
(
window
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
if
(
!
this
.
attached
)
{
return
;
}
this
.
_windowReady
(
window
{
isFrameSwitching
:
true
}
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
this
.
_navigate
(
window
true
)
;
}
)
;
}
)
;
}
_setWindow
(
window
)
{
this
.
docShell
=
window
.
docShell
;
this
.
emit
(
"
changed
-
toplevel
-
document
"
)
;
this
.
emit
(
"
frameUpdate
"
{
selected
:
this
.
outerWindowID
}
)
;
}
_windowReady
(
window
{
isFrameSwitching
isBFCache
}
=
{
}
)
{
const
isTopLevel
=
window
=
=
this
.
window
;
if
(
window
=
=
this
.
_originalWindow
&
&
!
isFrameSwitching
)
{
this
.
_updateChildDocShells
(
)
;
}
this
.
emit
(
"
window
-
ready
"
{
window
:
window
isTopLevel
:
isTopLevel
isBFCache
id
:
getWindowID
(
window
)
}
)
;
}
_windowDestroyed
(
window
id
=
null
isFrozen
=
false
)
{
this
.
emit
(
"
window
-
destroyed
"
{
window
:
window
isTopLevel
:
window
=
=
this
.
window
id
:
id
|
|
getWindowID
(
window
)
isFrozen
:
isFrozen
}
)
;
}
_willNavigate
(
window
newURI
request
isFrameSwitching
=
false
)
{
let
isTopLevel
=
window
=
=
this
.
window
;
let
reset
=
false
;
if
(
window
=
=
this
.
_originalWindow
&
&
!
isFrameSwitching
)
{
this
.
_notifyDocShellDestroyAll
(
)
;
if
(
this
.
window
!
=
this
.
_originalWindow
)
{
reset
=
true
;
window
=
this
.
window
;
isTopLevel
=
true
;
}
}
this
.
emit
(
"
will
-
navigate
"
{
window
:
window
isTopLevel
:
isTopLevel
newURI
:
newURI
request
:
request
}
)
;
if
(
!
isTopLevel
)
{
return
;
}
if
(
!
this
.
followWindowGlobalLifeCycle
)
{
this
.
emit
(
"
tabNavigated
"
{
url
:
newURI
nativeConsoleAPI
:
true
state
:
"
start
"
isFrameSwitching
:
isFrameSwitching
}
)
;
}
if
(
reset
)
{
this
.
_setWindow
(
this
.
_originalWindow
)
;
}
}
_navigate
(
window
isFrameSwitching
=
false
)
{
const
isTopLevel
=
window
=
=
this
.
window
;
this
.
emit
(
"
navigate
"
{
window
:
window
isTopLevel
:
isTopLevel
}
)
;
if
(
!
isTopLevel
)
{
return
;
}
if
(
this
.
followWindowGlobalLifeCycle
)
{
return
;
}
this
.
emit
(
"
tabNavigated
"
{
url
:
this
.
url
title
:
this
.
title
nativeConsoleAPI
:
this
.
hasNativeConsoleAPI
(
this
.
window
)
state
:
"
stop
"
isFrameSwitching
:
isFrameSwitching
}
)
;
}
hasNativeConsoleAPI
(
window
)
{
let
isNative
=
false
;
try
{
const
console
=
window
.
wrappedJSObject
.
console
;
isNative
=
new
XPCNativeWrapper
(
console
)
.
IS_NATIVE_CONSOLE
;
}
catch
(
ex
)
{
}
return
isNative
;
}
createStyleSheetActor
(
styleSheet
)
{
assert
(
!
this
.
exited
"
Target
must
not
be
exited
to
create
a
sheet
actor
.
"
)
;
if
(
this
.
_styleSheetActors
.
has
(
styleSheet
)
)
{
return
this
.
_styleSheetActors
.
get
(
styleSheet
)
;
}
const
actor
=
new
StyleSheetActor
(
styleSheet
this
)
;
this
.
_styleSheetActors
.
set
(
styleSheet
actor
)
;
this
.
_targetScopedActorPool
.
manage
(
actor
)
;
this
.
emit
(
"
stylesheet
-
added
"
actor
)
;
return
actor
;
}
removeActorByName
(
name
)
{
if
(
name
in
this
.
_extraActors
)
{
const
actor
=
this
.
_extraActors
[
name
]
;
if
(
this
.
_targetScopedActorPool
.
has
(
actor
)
)
{
this
.
_targetScopedActorPool
.
removeActor
(
actor
)
;
}
delete
this
.
_extraActors
[
name
]
;
}
}
}
;
exports
.
browsingContextTargetPrototype
=
browsingContextTargetPrototype
;
exports
.
BrowsingContextTargetActor
=
ActorClassWithSpec
(
browsingContextTargetSpec
browsingContextTargetPrototype
)
;
function
DebuggerProgressListener
(
targetActor
)
{
this
.
_targetActor
=
targetActor
;
this
.
_onWindowCreated
=
this
.
onWindowCreated
.
bind
(
this
)
;
this
.
_onWindowHidden
=
this
.
onWindowHidden
.
bind
(
this
)
;
Services
.
obs
.
addObserver
(
this
"
inner
-
window
-
destroyed
"
)
;
this
.
_knownWindowIDs
=
new
Map
(
)
;
this
.
_watchedDocShells
=
new
WeakSet
(
)
;
}
DebuggerProgressListener
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
"
inner
-
window
-
destroyed
"
)
;
this
.
_knownWindowIDs
.
clear
(
)
;
this
.
_knownWindowIDs
=
null
;
}
watch
(
docShell
)
{
const
docShellWindow
=
docShell
.
domWindow
;
this
.
_watchedDocShells
.
add
(
docShellWindow
)
;
const
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
const
handler
=
getDocShellChromeEventHandler
(
docShell
)
;
handler
.
addEventListener
(
"
DOMWindowCreated
"
this
.
_onWindowCreated
true
)
;
handler
.
addEventListener
(
"
pageshow
"
this
.
_onWindowCreated
true
)
;
handler
.
addEventListener
(
"
pagehide
"
this
.
_onWindowHidden
true
)
;
for
(
const
win
of
this
.
_getWindowsInDocShell
(
docShell
)
)
{
this
.
_targetActor
.
_windowReady
(
win
)
;
this
.
_knownWindowIDs
.
set
(
getWindowID
(
win
)
win
)
;
}
if
(
docShell
.
browsingContext
.
top
=
=
docShell
.
browsingContext
)
{
docShell
.
browsingContext
.
watchedByDevTools
=
true
;
}
}
unwatch
(
docShell
)
{
const
docShellWindow
=
docShell
.
domWindow
;
if
(
!
this
.
_watchedDocShells
.
has
(
docShellWindow
)
)
{
return
;
}
this
.
_watchedDocShells
.
delete
(
docShellWindow
)
;
const
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
try
{
webProgress
.
removeProgressListener
(
this
)
;
}
catch
(
e
)
{
}
const
handler
=
getDocShellChromeEventHandler
(
docShell
)
;
handler
.
removeEventListener
(
"
DOMWindowCreated
"
this
.
_onWindowCreated
true
)
;
handler
.
removeEventListener
(
"
pageshow
"
this
.
_onWindowCreated
true
)
;
handler
.
removeEventListener
(
"
pagehide
"
this
.
_onWindowHidden
true
)
;
for
(
const
win
of
this
.
_getWindowsInDocShell
(
docShell
)
)
{
this
.
_knownWindowIDs
.
delete
(
getWindowID
(
win
)
)
;
}
if
(
docShell
.
browsingContext
.
top
=
=
docShell
.
browsingContext
)
{
docShell
.
browsingContext
.
watchedByDevTools
=
false
;
}
}
_getWindowsInDocShell
(
docShell
)
{
return
getChildDocShells
(
docShell
)
.
map
(
d
=
>
{
return
d
.
domWindow
;
}
)
;
}
onWindowCreated
:
DevToolsUtils
.
makeInfallible
(
function
(
evt
)
{
if
(
!
this
.
_targetActor
.
attached
)
{
return
;
}
if
(
evt
.
inFrameSwap
)
{
return
;
}
const
window
=
evt
.
target
.
defaultView
;
const
innerID
=
getWindowID
(
window
)
;
if
(
this
.
_knownWindowIDs
.
has
(
innerID
)
)
{
return
;
}
this
.
_knownWindowIDs
.
set
(
innerID
window
)
;
const
isBFCache
=
evt
.
type
=
=
"
pageshow
"
;
this
.
_targetActor
.
_windowReady
(
window
{
isBFCache
}
)
;
}
"
DebuggerProgressListener
.
prototype
.
onWindowCreated
"
)
onWindowHidden
:
DevToolsUtils
.
makeInfallible
(
function
(
evt
)
{
if
(
!
this
.
_targetActor
.
attached
)
{
return
;
}
if
(
evt
.
inFrameSwap
)
{
return
;
}
if
(
!
evt
.
persisted
)
{
return
;
}
const
window
=
evt
.
target
.
defaultView
;
this
.
_targetActor
.
_windowDestroyed
(
window
null
true
)
;
this
.
_knownWindowIDs
.
delete
(
getWindowID
(
window
)
)
;
}
"
DebuggerProgressListener
.
prototype
.
onWindowHidden
"
)
observe
:
DevToolsUtils
.
makeInfallible
(
function
(
subject
topic
)
{
if
(
!
this
.
_targetActor
.
attached
)
{
return
;
}
const
innerID
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
;
const
window
=
this
.
_knownWindowIDs
.
get
(
innerID
)
;
if
(
window
)
{
this
.
_knownWindowIDs
.
delete
(
innerID
)
;
this
.
_targetActor
.
_windowDestroyed
(
window
innerID
)
;
}
if
(
this
.
_watchedDocShells
.
has
(
window
)
&
&
!
window
.
docShell
.
chromeEventHandler
)
{
this
.
unwatch
(
window
.
docShell
)
;
this
.
watch
(
window
.
docShell
)
;
}
}
"
DebuggerProgressListener
.
prototype
.
observe
"
)
onStateChange
:
DevToolsUtils
.
makeInfallible
(
function
(
progress
request
flag
status
)
{
if
(
!
this
.
_targetActor
.
attached
)
{
return
;
}
progress
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
if
(
progress
.
isBeingDestroyed
(
)
)
{
return
;
}
const
isStart
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_START
;
const
isStop
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
;
const
isDocument
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_IS_DOCUMENT
;
const
isWindow
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
;
if
(
isDocument
&
&
isStop
)
{
this
.
_targetActor
.
_notifyDocShellsUpdate
(
[
progress
]
)
;
}
const
window
=
progress
.
DOMWindow
;
if
(
isDocument
&
&
isStart
)
{
const
newURI
=
request
instanceof
Ci
.
nsIChannel
?
request
.
URI
.
spec
:
null
;
this
.
_targetActor
.
_willNavigate
(
window
newURI
request
)
;
}
if
(
isWindow
&
&
isStop
)
{
if
(
request
.
status
!
=
Cr
.
NS_OK
&
&
request
.
status
!
=
Cr
.
NS_BINDING_ABORTED
)
{
const
handler
=
getDocShellChromeEventHandler
(
progress
)
;
const
onLoad
=
evt
=
>
{
if
(
evt
.
target
=
=
=
window
.
document
)
{
handler
.
removeEventListener
(
"
DOMContentLoaded
"
onLoad
true
)
;
this
.
_targetActor
.
_navigate
(
window
)
;
}
}
;
handler
.
addEventListener
(
"
DOMContentLoaded
"
onLoad
true
)
;
}
else
{
this
.
_targetActor
.
_navigate
(
window
)
;
}
}
}
"
DebuggerProgressListener
.
prototype
.
onStateChange
"
)
}
;
