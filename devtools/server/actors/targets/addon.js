"
use
strict
"
;
var
{
Ci
Cu
}
=
require
(
"
chrome
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
{
ActorPool
}
=
require
(
"
devtools
/
server
/
actors
/
common
"
)
;
var
{
TabSources
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
TabSources
"
)
;
var
makeDebugger
=
require
(
"
devtools
/
server
/
actors
/
utils
/
make
-
debugger
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
{
assert
}
=
DevToolsUtils
;
loader
.
lazyRequireGetter
(
this
"
AddonThreadActor
"
"
devtools
/
server
/
actors
/
thread
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
unwrapDebuggerObjectGlobal
"
"
devtools
/
server
/
actors
/
thread
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
AddonConsoleActor
"
"
devtools
/
server
/
actors
/
addon
/
console
"
true
)
;
loader
.
lazyImporter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
function
AddonTargetActor
(
connection
addon
)
{
this
.
conn
=
connection
;
this
.
_addon
=
addon
;
this
.
_contextPool
=
new
ActorPool
(
this
.
conn
)
;
this
.
conn
.
addActorPool
(
this
.
_contextPool
)
;
this
.
threadActor
=
null
;
this
.
_global
=
null
;
this
.
_shouldAddNewGlobalAsDebuggee
=
this
.
_shouldAddNewGlobalAsDebuggee
.
bind
(
this
)
;
this
.
makeDebugger
=
makeDebugger
.
bind
(
null
{
findDebuggees
:
this
.
_findDebuggees
.
bind
(
this
)
shouldAddNewGlobalAsDebuggee
:
this
.
_shouldAddNewGlobalAsDebuggee
}
)
;
AddonManager
.
addAddonListener
(
this
)
;
}
exports
.
AddonTargetActor
=
AddonTargetActor
;
AddonTargetActor
.
prototype
=
{
actorPrefix
:
"
addonTarget
"
get
exited
(
)
{
return
!
this
.
_addon
;
}
get
addonId
(
)
{
return
this
.
_addon
.
id
;
}
get
url
(
)
{
return
this
.
_addon
.
sourceURI
?
this
.
_addon
.
sourceURI
.
spec
:
undefined
;
}
get
attached
(
)
{
return
this
.
threadActor
;
}
get
global
(
)
{
return
this
.
_global
;
}
get
sources
(
)
{
if
(
!
this
.
_sources
)
{
assert
(
this
.
threadActor
"
threadActor
should
exist
when
creating
sources
.
"
)
;
this
.
_sources
=
new
TabSources
(
this
.
threadActor
this
.
_allowSource
)
;
}
return
this
.
_sources
;
}
form
:
function
BAAForm
(
)
{
assert
(
this
.
actorID
"
addon
should
have
an
actorID
.
"
)
;
if
(
!
this
.
_consoleActor
)
{
this
.
_consoleActor
=
new
AddonConsoleActor
(
this
.
_addon
this
.
conn
this
)
;
this
.
_contextPool
.
addActor
(
this
.
_consoleActor
)
;
}
return
{
actor
:
this
.
actorID
id
:
this
.
addonId
name
:
this
.
_addon
.
name
url
:
this
.
url
iconURL
:
this
.
_addon
.
iconURL
isSystem
:
this
.
_addon
.
isSystem
debuggable
:
this
.
_addon
.
isDebuggable
temporarilyInstalled
:
this
.
_addon
.
temporarilyInstalled
type
:
this
.
_addon
.
type
isWebExtension
:
this
.
_addon
.
isWebExtension
isAPIExtension
:
this
.
_addon
.
isAPIExtension
consoleActor
:
this
.
_consoleActor
.
actorID
traits
:
{
networkMonitor
:
false
}
}
;
}
destroy
(
)
{
this
.
conn
.
removeActorPool
(
this
.
_contextPool
)
;
this
.
_contextPool
=
null
;
this
.
_consoleActor
=
null
;
this
.
_addon
=
null
;
this
.
_global
=
null
;
AddonManager
.
removeAddonListener
(
this
)
;
}
setOptions
:
function
BAASetOptions
(
options
)
{
if
(
"
global
"
in
options
)
{
this
.
_global
=
options
.
global
;
}
}
onInstalled
:
function
BAAUpdateAddonWrapper
(
addon
)
{
if
(
addon
.
id
!
=
this
.
_addon
.
id
)
{
return
;
}
this
.
_addon
=
addon
;
}
onDisabled
:
function
BAAOnDisabled
(
addon
)
{
if
(
addon
!
=
this
.
_addon
)
{
return
;
}
this
.
_global
=
null
;
}
onUninstalled
:
function
BAAOnUninstalled
(
addon
)
{
if
(
addon
!
=
this
.
_addon
)
{
return
;
}
if
(
this
.
attached
)
{
this
.
onDetach
(
)
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
tabDetached
"
}
)
;
}
this
.
destroy
(
)
;
}
onAttach
:
function
BAAOnAttach
(
)
{
if
(
this
.
exited
)
{
return
{
type
:
"
exited
"
}
;
}
if
(
!
this
.
attached
)
{
this
.
threadActor
=
new
AddonThreadActor
(
this
.
conn
this
)
;
this
.
_contextPool
.
addActor
(
this
.
threadActor
)
;
}
return
{
type
:
"
tabAttached
"
threadActor
:
this
.
threadActor
.
actorID
}
;
}
onDetach
:
function
BAAOnDetach
(
)
{
if
(
!
this
.
attached
)
{
return
{
error
:
"
wrongState
"
}
;
}
this
.
_contextPool
.
removeActor
(
this
.
threadActor
)
;
this
.
threadActor
=
null
;
this
.
_sources
=
null
;
return
{
type
:
"
detached
"
}
;
}
onReload
:
function
BAAOnReload
(
)
{
return
this
.
_addon
.
reload
(
)
.
then
(
(
)
=
>
{
return
{
}
;
}
)
;
}
preNest
:
function
(
)
{
for
(
const
{
windowUtils
}
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
windowUtils
.
suppressEventHandling
(
true
)
;
windowUtils
.
suspendTimeouts
(
)
;
}
}
postNest
:
function
(
)
{
for
(
const
{
windowUtils
}
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
windowUtils
.
resumeTimeouts
(
)
;
windowUtils
.
suppressEventHandling
(
false
)
;
}
}
_shouldAddNewGlobalAsDebuggee
:
function
(
givenGlobal
)
{
const
global
=
unwrapDebuggerObjectGlobal
(
givenGlobal
)
;
try
{
const
metadata
=
Cu
.
getSandboxMetadata
(
global
)
;
if
(
metadata
)
{
return
metadata
.
addonID
=
=
=
this
.
addonId
;
}
}
catch
(
e
)
{
}
if
(
global
instanceof
Ci
.
nsIDOMWindow
)
{
return
global
.
document
.
nodePrincipal
.
addonId
=
=
this
.
addonId
;
}
return
false
;
}
_allowSource
:
function
(
source
)
{
if
(
source
.
url
=
=
=
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIProvider
.
jsm
"
)
{
return
false
;
}
return
true
;
}
_findDebuggees
:
function
(
dbg
)
{
return
dbg
.
findAllGlobals
(
)
.
filter
(
this
.
_shouldAddNewGlobalAsDebuggee
)
;
}
}
;
AddonTargetActor
.
prototype
.
requestTypes
=
{
"
attach
"
:
AddonTargetActor
.
prototype
.
onAttach
"
detach
"
:
AddonTargetActor
.
prototype
.
onDetach
"
reload
"
:
AddonTargetActor
.
prototype
.
onReload
}
;
