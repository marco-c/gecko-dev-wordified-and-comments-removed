"
use
strict
"
;
var
{
ActorRegistry
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
actor
-
registry
.
js
"
)
;
var
DevToolsUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
var
{
assert
}
=
DevToolsUtils
;
var
{
SourcesManager
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
sources
-
manager
.
js
"
)
;
var
makeDebugger
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
make
-
debugger
.
js
"
)
;
const
Targets
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
index
.
js
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
WEBEXTENSION_FALLBACK_DOC_URL
:
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
browsing
-
context
-
helpers
.
sys
.
mjs
"
getAddonIdForWindowGlobal
:
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
browsing
-
context
-
helpers
.
sys
.
mjs
"
}
{
global
:
"
contextual
"
}
)
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
TargetActorRegistry
:
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
target
-
actor
-
registry
.
sys
.
mjs
"
}
{
global
:
"
shared
"
}
)
;
const
{
Pool
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
LazyPool
createExtraActors
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
/
lazy
-
pool
.
js
"
)
;
const
{
windowGlobalTargetSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
targets
/
window
-
global
.
js
"
)
;
const
Resources
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
index
.
js
"
)
;
const
{
BaseTargetActor
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
base
-
target
-
actor
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
ThreadActor
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
thread
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WorkerDescriptorActorList
"
"
resource
:
/
/
devtools
/
server
/
actors
/
worker
/
worker
-
descriptor
-
actor
-
list
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
StyleSheetsManager
"
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
stylesheets
-
manager
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TouchSimulator
"
"
resource
:
/
/
devtools
/
server
/
actors
/
emulation
/
touch
-
simulator
.
js
"
true
)
;
function
getWindowID
(
window
)
{
return
window
.
windowGlobalChild
.
innerWindowId
;
}
function
getDocShellChromeEventHandler
(
docShell
)
{
let
handler
=
docShell
.
chromeEventHandler
;
if
(
!
handler
)
{
try
{
handler
=
docShell
.
domWindow
;
}
catch
(
e
)
{
}
}
return
handler
;
}
function
getChildDocShells
(
parentDocShell
)
{
return
parentDocShell
.
browsingContext
.
getAllBrowsingContextsInSubtree
(
)
.
filter
(
browsingContext
=
>
{
return
browsingContext
.
docShell
;
}
)
.
map
(
browsingContext
=
>
{
return
browsingContext
.
docShell
;
}
)
;
}
exports
.
getChildDocShells
=
getChildDocShells
;
function
getInnerId
(
window
)
{
return
window
.
windowGlobalChild
.
innerWindowId
;
}
class
WindowGlobalTargetActor
extends
BaseTargetActor
{
constructor
(
conn
{
docShell
followWindowGlobalLifeCycle
isTopLevelTarget
ignoreSubFrames
sessionContext
customSpec
=
windowGlobalTargetSpec
}
)
{
super
(
conn
Targets
.
TYPES
.
FRAME
customSpec
)
;
this
.
followWindowGlobalLifeCycle
=
followWindowGlobalLifeCycle
;
this
.
isTopLevelTarget
=
!
!
isTopLevelTarget
;
this
.
ignoreSubFrames
=
ignoreSubFrames
;
this
.
sessionContext
=
sessionContext
;
this
.
_extraActors
=
{
}
;
this
.
_sourcesManager
=
null
;
this
.
_shouldAddNewGlobalAsDebuggee
=
this
.
_shouldAddNewGlobalAsDebuggee
.
bind
(
this
)
;
this
.
makeDebugger
=
makeDebugger
.
bind
(
null
{
findDebuggees
:
(
)
=
>
{
const
result
=
[
]
;
const
inspectUAWidgets
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
inspector
.
showAllAnonymousContent
"
false
)
;
for
(
const
win
of
this
.
windows
)
{
result
.
push
(
win
)
;
if
(
inspectUAWidgets
)
{
const
principal
=
win
.
document
.
nodePrincipal
;
if
(
!
principal
.
isSystemPrincipal
)
{
result
.
push
(
Cu
.
getUAWidgetScope
(
principal
)
)
;
}
}
}
return
result
;
}
shouldAddNewGlobalAsDebuggee
:
this
.
_shouldAddNewGlobalAsDebuggee
}
)
;
this
.
watchNewDocShells
=
false
;
this
.
_workerDescriptorActorList
=
null
;
this
.
_workerDescriptorActorPool
=
null
;
this
.
_onWorkerDescriptorActorListChanged
=
this
.
_onWorkerDescriptorActorListChanged
.
bind
(
this
)
;
this
.
_onConsoleApiProfilerEvent
=
this
.
_onConsoleApiProfilerEvent
.
bind
(
this
)
;
Services
.
obs
.
addObserver
(
this
.
_onConsoleApiProfilerEvent
"
console
-
api
-
profiler
"
)
;
this
.
_progressListener
=
new
DebuggerProgressListener
(
this
)
;
lazy
.
TargetActorRegistry
.
registerTargetActor
(
this
)
;
if
(
docShell
)
{
this
.
setDocShell
(
docShell
)
;
}
}
#
isFallbackExtensionDocument
=
false
;
setDocShell
(
docShell
)
{
Object
.
defineProperty
(
this
"
docShell
"
{
value
:
docShell
configurable
:
true
writable
:
true
}
)
;
if
(
this
.
followWindowGlobalLifeCycle
)
{
Object
.
defineProperty
(
this
"
innerWindowId
"
{
value
:
this
.
innerWindowId
configurable
:
false
writable
:
false
}
)
;
}
this
.
_originalWindow
=
this
.
window
;
this
.
isPrivate
=
lazy
.
PrivateBrowsingUtils
.
isContentWindowPrivate
(
this
.
window
)
;
this
.
_createThreadActor
(
)
;
this
.
_docShellsObserved
=
false
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
this
.
_watchDocshells
(
)
)
;
if
(
!
this
.
browsingContext
.
parent
)
{
this
.
browsingContext
.
watchedByDevTools
=
true
;
}
if
(
this
.
sessionContext
.
type
=
=
"
webextension
"
)
{
if
(
this
.
window
.
location
.
href
.
startsWith
(
lazy
.
WEBEXTENSION_FALLBACK_DOC_URL
)
)
{
this
.
#
isFallbackExtensionDocument
=
true
;
}
}
}
get
docShell
(
)
{
throw
new
Error
(
"
A
docShell
should
be
provided
as
constructor
argument
of
WindowGlobalTargetActor
or
redefined
by
the
subclass
"
)
;
}
get
dbg
(
)
{
if
(
!
this
.
_dbg
)
{
this
.
_dbg
=
this
.
makeDebugger
(
)
;
}
return
this
.
_dbg
;
}
get
_consoleActor
(
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
null
;
}
const
form
=
this
.
form
(
)
;
return
this
.
conn
.
_getOrCreateActor
(
form
.
consoleActor
)
;
}
get
_memoryActor
(
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
null
;
}
const
form
=
this
.
form
(
)
;
return
this
.
conn
.
_getOrCreateActor
(
form
.
memoryActor
)
;
}
_targetScopedActorPool
=
null
;
get
chromeEventHandler
(
)
{
return
getDocShellChromeEventHandler
(
this
.
docShell
)
;
}
get
messageManager
(
)
{
try
{
return
this
.
docShell
.
messageManager
;
}
catch
(
e
)
{
return
null
;
}
}
get
docShells
(
)
{
if
(
this
.
ignoreSubFrames
)
{
return
[
this
.
docShell
]
;
}
return
getChildDocShells
(
this
.
docShell
)
;
}
get
window
(
)
{
try
{
return
this
.
docShell
?
.
domWindow
;
}
catch
(
e
)
{
return
null
;
}
}
get
targetGlobal
(
)
{
return
this
.
window
;
}
get
outerWindowID
(
)
{
if
(
this
.
docShell
)
{
return
this
.
docShell
.
outerWindowID
;
}
return
null
;
}
get
browsingContext
(
)
{
return
this
.
docShell
?
.
browsingContext
;
}
get
browsingContextID
(
)
{
return
this
.
browsingContext
?
.
id
;
}
get
innerWindowId
(
)
{
return
this
.
window
?
.
windowGlobalChild
.
innerWindowId
;
}
get
browserId
(
)
{
return
this
.
browsingContext
?
.
browserId
;
}
get
openerBrowserId
(
)
{
return
this
.
browsingContext
?
.
opener
?
.
browserId
;
}
get
windows
(
)
{
const
windows
=
[
]
;
for
(
const
docShell
of
this
.
docShells
)
{
try
{
windows
.
push
(
docShell
.
domWindow
)
;
}
catch
(
e
)
{
}
}
return
windows
;
}
get
originalDocShell
(
)
{
if
(
!
this
.
_originalWindow
|
|
Cu
.
isDeadWrapper
(
this
.
_originalWindow
)
)
{
return
this
.
docShell
;
}
return
this
.
_originalWindow
.
docShell
;
}
get
originalWindow
(
)
{
return
this
.
_originalWindow
|
|
this
.
window
;
}
get
webProgress
(
)
{
return
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
}
get
webNavigation
(
)
{
return
this
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
}
get
contentDocument
(
)
{
return
this
.
webNavigation
.
document
;
}
get
title
(
)
{
return
this
.
contentDocument
.
title
;
}
get
url
(
)
{
if
(
this
.
webNavigation
.
currentURI
)
{
return
this
.
webNavigation
.
currentURI
.
spec
;
}
return
null
;
}
get
sourcesManager
(
)
{
if
(
!
this
.
_sourcesManager
)
{
this
.
_sourcesManager
=
new
SourcesManager
(
this
.
threadActor
)
;
}
return
this
.
_sourcesManager
;
}
getStyleSheetsManager
(
)
{
if
(
!
this
.
_styleSheetsManager
)
{
this
.
_styleSheetsManager
=
new
StyleSheetsManager
(
this
)
;
}
return
this
.
_styleSheetsManager
;
}
_createExtraActors
(
)
{
if
(
!
this
.
_targetScopedActorPool
)
{
this
.
_targetScopedActorPool
=
new
LazyPool
(
this
.
conn
)
;
}
return
createExtraActors
(
ActorRegistry
.
targetScopedActorFactories
this
.
_targetScopedActorPool
this
)
;
}
form
(
)
{
assert
(
!
this
.
isDestroyed
(
)
"
form
(
)
shouldn
'
t
be
called
on
destroyed
browser
actor
.
"
)
;
assert
(
this
.
actorID
"
Actor
should
have
an
actorID
.
"
)
;
if
(
this
.
destroying
|
|
!
this
.
originalDocShell
)
{
return
{
actor
:
this
.
actorID
innerWindowId
:
this
.
innerWindowId
isTopLevelTarget
:
this
.
isTopLevelTarget
}
;
}
const
originalBrowsingContext
=
this
.
originalDocShell
.
browsingContext
;
if
(
!
originalBrowsingContext
.
currentWindowContext
)
{
return
{
actor
:
this
.
actorID
}
;
}
const
browsingContextID
=
originalBrowsingContext
.
id
;
const
innerWindowId
=
originalBrowsingContext
.
currentWindowContext
.
innerWindowId
;
const
parentInnerWindowId
=
originalBrowsingContext
.
parent
?
.
currentWindowContext
.
innerWindowId
;
const
isPopup
=
!
!
originalBrowsingContext
.
opener
&
&
originalBrowsingContext
.
browserId
!
=
originalBrowsingContext
.
opener
.
browserId
;
const
response
=
{
actor
:
this
.
actorID
targetType
:
this
.
targetType
browsingContextID
processID
:
Services
.
appinfo
.
processID
followWindowGlobalLifeCycle
:
this
.
followWindowGlobalLifeCycle
innerWindowId
parentInnerWindowId
topInnerWindowId
:
this
.
browsingContext
.
topWindowContext
.
innerWindowId
isTopLevelTarget
:
this
.
isTopLevelTarget
ignoreSubFrames
:
this
.
ignoreSubFrames
isPopup
isPrivate
:
this
.
isPrivate
title
:
this
.
title
url
:
this
.
url
outerWindowID
:
this
.
outerWindowID
isFallbackExtensionDocument
:
this
.
#
isFallbackExtensionDocument
addonId
:
lazy
.
getAddonIdForWindowGlobal
(
this
.
window
.
windowGlobalChild
)
traits
:
{
isBrowsingContext
:
true
supportsTopLevelTargetFlag
:
true
frames
:
true
logInPage
:
true
watchpoints
:
true
navigation
:
true
}
}
;
const
actors
=
this
.
_createExtraActors
(
)
;
Object
.
assign
(
response
actors
)
;
if
(
this
.
threadActor
)
{
Object
.
assign
(
response
{
threadActor
:
this
.
threadActor
.
actorID
}
)
;
}
return
response
;
}
destroy
(
{
isTargetSwitching
=
false
isModeSwitching
=
false
}
=
{
}
)
{
if
(
this
.
destroying
)
{
return
;
}
this
.
destroying
=
true
;
if
(
!
this
.
isDestroyed
(
)
)
{
this
.
emitResources
(
)
;
}
if
(
this
.
threadActor
)
{
this
.
threadActor
.
_parentClosed
=
true
;
}
if
(
this
.
_touchSimulator
)
{
this
.
_touchSimulator
.
stop
(
)
;
this
.
_touchSimulator
=
null
;
}
if
(
this
.
browsingContext
?
.
watchedByDevTools
&
&
!
this
.
browsingContext
.
parent
&
&
!
this
.
browsingContext
.
isDiscarded
)
{
this
.
browsingContext
.
watchedByDevTools
=
false
;
}
if
(
this
.
docShell
)
{
this
.
_unwatchDocShell
(
this
.
docShell
)
;
if
(
!
isTargetSwitching
&
&
!
isModeSwitching
)
{
this
.
_restoreTargetConfiguration
(
)
;
}
}
this
.
_unwatchDocshells
(
)
;
this
.
_destroyThreadActor
(
)
;
if
(
this
.
_styleSheetsManager
)
{
this
.
_styleSheetsManager
.
destroy
(
)
;
this
.
_styleSheetsManager
=
null
;
}
if
(
this
.
_targetScopedActorPool
)
{
this
.
_targetScopedActorPool
.
destroy
(
)
;
this
.
_targetScopedActorPool
=
null
;
}
if
(
this
.
_workerDescriptorActorList
!
=
=
null
)
{
this
.
_workerDescriptorActorList
.
destroy
(
)
;
this
.
_workerDescriptorActorList
=
null
;
}
if
(
this
.
_workerDescriptorActorPool
!
=
=
null
)
{
this
.
_workerDescriptorActorPool
.
destroy
(
)
;
this
.
_workerDescriptorActorPool
=
null
;
}
if
(
this
.
_dbg
)
{
this
.
_dbg
.
disable
(
)
;
this
.
_dbg
=
null
;
}
this
.
emit
(
"
destroyed
"
{
isTargetSwitching
isModeSwitching
}
)
;
super
.
destroy
(
)
;
this
.
docShell
=
null
;
this
.
_extraActors
=
null
;
Services
.
obs
.
removeObserver
(
this
.
_onConsoleApiProfilerEvent
"
console
-
api
-
profiler
"
)
;
lazy
.
TargetActorRegistry
.
unregisterTargetActor
(
this
)
;
Resources
.
unwatchAllResources
(
this
)
;
}
_shouldAddNewGlobalAsDebuggee
(
)
{
return
false
;
}
_watchDocshells
(
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
if
(
this
.
docShell
.
isBeingDestroyed
(
)
)
{
this
.
destroy
(
)
;
return
;
}
if
(
!
this
.
ignoreSubFrames
)
{
Services
.
obs
.
addObserver
(
this
"
webnavigation
-
create
"
)
;
Services
.
obs
.
addObserver
(
this
"
webnavigation
-
destroy
"
)
;
this
.
_docShellsObserved
=
true
;
}
this
.
_progressListener
.
watch
(
this
.
docShell
)
;
if
(
!
this
.
ignoreSubFrames
)
{
this
.
_updateChildDocShells
(
)
;
}
}
_unwatchDocshells
(
)
{
if
(
this
.
_progressListener
)
{
this
.
_progressListener
.
destroy
(
)
;
this
.
_progressListener
=
null
;
this
.
_originalWindow
=
null
;
}
if
(
this
.
_docShellsObserved
)
{
Services
.
obs
.
removeObserver
(
this
"
webnavigation
-
create
"
)
;
Services
.
obs
.
removeObserver
(
this
"
webnavigation
-
destroy
"
)
;
this
.
_docShellsObserved
=
false
;
}
}
_unwatchDocShell
(
docShell
)
{
if
(
this
.
_progressListener
)
{
this
.
_progressListener
.
unwatch
(
docShell
)
;
}
}
switchToFrame
(
request
)
{
const
windowId
=
request
.
windowId
;
let
win
;
try
{
win
=
Services
.
wm
.
getOuterWindowWithId
(
windowId
)
;
}
catch
(
e
)
{
}
if
(
!
win
)
{
throw
{
error
:
"
noWindow
"
message
:
"
The
related
docshell
is
destroyed
or
not
found
"
}
;
}
else
if
(
win
=
=
this
.
window
)
{
return
{
}
;
}
DevToolsUtils
.
executeSoon
(
(
)
=
>
this
.
_changeTopLevelDocument
(
win
)
)
;
return
{
}
;
}
listFrames
(
)
{
const
windows
=
this
.
_docShellsToWindows
(
this
.
docShells
)
;
return
{
frames
:
windows
}
;
}
ensureWorkerDescriptorActorList
(
)
{
if
(
this
.
_workerDescriptorActorList
=
=
=
null
)
{
this
.
_workerDescriptorActorList
=
new
WorkerDescriptorActorList
(
this
.
conn
{
type
:
Ci
.
nsIWorkerDebugger
.
TYPE_DEDICATED
window
:
this
.
window
}
)
;
}
return
this
.
_workerDescriptorActorList
;
}
pauseWorkersUntilAttach
(
shouldPause
)
{
this
.
ensureWorkerDescriptorActorList
(
)
.
workerPauser
.
setPauseMatching
(
shouldPause
)
;
}
listWorkers
(
)
{
return
this
.
ensureWorkerDescriptorActorList
(
)
.
getList
(
)
.
then
(
actors
=
>
{
const
pool
=
new
Pool
(
this
.
conn
"
worker
-
targets
"
)
;
for
(
const
actor
of
actors
)
{
pool
.
manage
(
actor
)
;
}
if
(
this
.
_workerDescriptorActorPool
)
{
this
.
_workerDescriptorActorPool
.
destroy
(
)
;
}
this
.
_workerDescriptorActorPool
=
pool
;
this
.
_workerDescriptorActorList
.
onListChanged
=
this
.
_onWorkerDescriptorActorListChanged
;
return
{
workers
:
actors
}
;
}
)
;
}
logInPage
(
request
)
{
const
{
text
category
flags
}
=
request
;
const
scriptErrorClass
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
;
const
scriptError
=
scriptErrorClass
.
createInstance
(
Ci
.
nsIScriptError
)
;
scriptError
.
initWithWindowID
(
text
null
0
0
flags
category
getInnerId
(
this
.
window
)
)
;
Services
.
console
.
logMessage
(
scriptError
)
;
return
{
}
;
}
_onWorkerDescriptorActorListChanged
(
)
{
this
.
_workerDescriptorActorList
.
onListChanged
=
null
;
this
.
emit
(
"
workerListChanged
"
)
;
}
_onConsoleApiProfilerEvent
(
)
{
const
warningFlag
=
1
;
this
.
logInPage
(
{
text
:
"
console
.
profile
is
not
compatible
with
the
new
Performance
recorder
.
"
+
"
See
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1730896
"
category
:
"
console
.
profile
unavailable
"
flags
:
warningFlag
}
)
;
}
observe
(
subject
topic
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
subject
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
if
(
topic
=
=
"
webnavigation
-
create
"
)
{
this
.
_onDocShellCreated
(
subject
)
;
}
else
if
(
topic
=
=
"
webnavigation
-
destroy
"
)
{
this
.
_onDocShellDestroy
(
subject
)
;
}
}
_onDocShellCreated
(
docShell
)
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
if
(
docShell
.
isBeingDestroyed
(
)
)
{
return
;
}
if
(
this
.
_isRootDocShell
(
docShell
)
&
&
this
.
watchNewDocShells
)
{
this
.
_progressListener
.
watch
(
docShell
)
;
}
this
.
_notifyDocShellsUpdate
(
[
docShell
]
)
;
}
)
;
}
_onDocShellDestroy
(
docShell
)
{
this
.
_unwatchDocShell
(
docShell
)
;
const
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
this
.
_notifyDocShellDestroy
(
webProgress
)
;
if
(
webProgress
.
DOMWindow
=
=
this
.
_originalWindow
)
{
const
rootDocShells
=
this
.
docShells
.
filter
(
d
=
>
{
return
d
!
=
this
.
docShell
&
&
this
.
_isRootDocShell
(
d
)
&
&
d
.
DOMWindow
;
}
)
;
if
(
rootDocShells
.
length
)
{
const
newRoot
=
rootDocShells
[
0
]
;
this
.
_originalWindow
=
newRoot
.
DOMWindow
;
this
.
_changeTopLevelDocument
(
this
.
_originalWindow
)
;
}
else
{
this
.
destroy
(
)
;
}
return
;
}
if
(
webProgress
.
DOMWindow
=
=
this
.
window
&
&
this
.
window
!
=
this
.
_originalWindow
)
{
this
.
_changeTopLevelDocument
(
this
.
_originalWindow
)
;
}
}
_isRootDocShell
(
docShell
)
{
return
!
docShell
.
parent
;
}
_docShellToWindow
(
docShell
)
{
const
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
const
window
=
webProgress
.
DOMWindow
;
const
id
=
docShell
.
outerWindowID
;
let
parentID
=
undefined
;
if
(
window
.
parent
&
&
window
.
parent
!
=
window
&
&
window
!
=
this
.
_originalWindow
)
{
parentID
=
window
.
parent
.
docShell
.
outerWindowID
;
}
return
{
id
parentID
isTopLevel
:
window
=
=
this
.
originalWindow
&
&
this
.
isTopLevelTarget
url
:
window
.
location
.
href
title
:
window
.
document
.
title
}
;
}
_docShellsToWindows
(
docshells
)
{
return
docshells
.
filter
(
docShell
=
>
{
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
if
(
docShell
.
document
.
isInitialDocument
)
{
return
false
;
}
return
true
;
}
)
.
map
(
docShell
=
>
this
.
_docShellToWindow
(
docShell
)
)
;
}
_notifyDocShellsUpdate
(
docshells
)
{
if
(
!
this
.
isTopLevelTarget
)
{
return
;
}
const
windows
=
this
.
_docShellsToWindows
(
docshells
)
;
if
(
!
windows
.
length
)
{
return
;
}
this
.
emit
(
"
frameUpdate
"
{
frames
:
windows
}
)
;
}
_updateChildDocShells
(
)
{
this
.
_notifyDocShellsUpdate
(
this
.
docShells
)
;
}
_notifyDocShellDestroy
(
webProgress
)
{
if
(
!
this
.
isTopLevelTarget
)
{
return
;
}
webProgress
=
webProgress
.
QueryInterface
(
Ci
.
nsIWebProgress
)
;
const
id
=
webProgress
.
DOMWindow
.
docShell
.
outerWindowID
;
this
.
emit
(
"
frameUpdate
"
{
frames
:
[
{
id
destroy
:
true
}
]
}
)
;
}
_createThreadActor
(
)
{
this
.
threadActor
=
new
ThreadActor
(
this
)
;
this
.
manage
(
this
.
threadActor
)
;
}
_destroyThreadActor
(
)
{
if
(
this
.
threadActor
)
{
this
.
threadActor
.
destroy
(
)
;
this
.
threadActor
=
null
;
}
if
(
this
.
_sourcesManager
)
{
this
.
_sourcesManager
.
destroy
(
)
;
this
.
_sourcesManager
=
null
;
}
}
detach
(
)
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
this
.
destroy
(
)
;
}
)
;
return
{
}
;
}
focus
(
)
{
if
(
this
.
window
)
{
this
.
window
.
focus
(
)
;
}
return
{
}
;
}
goForward
(
)
{
Services
.
tm
.
dispatchToMainThread
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
Services
.
startup
.
shuttingDown
)
{
return
;
}
this
.
webNavigation
.
goForward
(
)
;
}
"
WindowGlobalTargetActor
.
prototype
.
goForward
'
s
delayed
body
"
)
)
;
return
{
}
;
}
goBack
(
)
{
Services
.
tm
.
dispatchToMainThread
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
Services
.
startup
.
shuttingDown
)
{
return
;
}
this
.
webNavigation
.
goBack
(
)
;
}
"
WindowGlobalTargetActor
.
prototype
.
goBack
'
s
delayed
body
"
)
)
;
return
{
}
;
}
reload
(
request
)
{
const
force
=
request
?
.
options
?
.
force
;
Services
.
tm
.
dispatchToMainThread
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
Services
.
startup
.
shuttingDown
)
{
return
;
}
this
.
webNavigation
.
reload
(
force
?
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
)
;
}
"
WindowGlobalTargetActor
.
prototype
.
reload
'
s
delayed
body
"
)
)
;
return
{
}
;
}
navigateTo
(
request
)
{
Services
.
tm
.
dispatchToMainThread
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
this
.
window
.
location
=
request
.
url
;
}
"
WindowGlobalTargetActor
.
prototype
.
navigateTo
'
s
delayed
body
:
"
+
request
.
url
)
)
;
return
{
}
;
}
reconfigure
(
request
)
{
const
options
=
request
.
options
|
|
{
}
;
return
this
.
updateTargetConfiguration
(
options
)
;
}
updateTargetConfiguration
(
options
=
{
}
calledFromDocumentCreation
=
false
)
{
if
(
!
this
.
docShell
)
{
return
;
}
super
.
updateTargetConfiguration
(
options
calledFromDocumentCreation
)
;
let
reload
=
false
;
if
(
typeof
options
.
touchEventsOverride
!
=
=
"
undefined
"
)
{
const
enableTouchSimulator
=
options
.
touchEventsOverride
=
=
=
"
enabled
"
;
if
(
enableTouchSimulator
!
=
=
this
.
touchSimulator
.
enabled
&
&
options
.
reloadOnTouchSimulationToggle
=
=
=
true
&
&
this
.
isTopLevelTarget
&
&
!
calledFromDocumentCreation
)
{
reload
=
true
;
}
if
(
enableTouchSimulator
)
{
this
.
touchSimulator
.
start
(
)
;
}
else
{
this
.
touchSimulator
.
stop
(
)
;
}
}
if
(
typeof
options
.
customFormatters
!
=
=
"
undefined
"
)
{
this
.
customFormatters
=
options
.
customFormatters
;
}
if
(
typeof
options
.
useSimpleHighlightersForReducedMotion
=
=
"
boolean
"
)
{
this
.
_useSimpleHighlightersForReducedMotion
=
options
.
useSimpleHighlightersForReducedMotion
;
this
.
emit
(
"
use
-
simple
-
highlighters
-
updated
"
)
;
}
if
(
!
this
.
isTopLevelTarget
)
{
return
;
}
if
(
typeof
options
.
restoreFocus
=
=
"
boolean
"
)
{
this
.
_restoreFocus
=
options
.
restoreFocus
;
}
if
(
typeof
options
.
recordAllocations
=
=
"
object
"
)
{
const
actor
=
this
.
_memoryActor
;
if
(
options
.
recordAllocations
=
=
null
)
{
actor
.
stopRecordingAllocations
(
)
;
}
else
{
actor
.
attach
(
)
;
actor
.
startRecordingAllocations
(
options
.
recordAllocations
)
;
}
}
if
(
reload
)
{
this
.
webNavigation
.
reload
(
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
)
;
}
}
get
touchSimulator
(
)
{
if
(
!
this
.
_touchSimulator
)
{
this
.
_touchSimulator
=
new
TouchSimulator
(
this
)
;
}
return
this
.
_touchSimulator
;
}
_restoreTargetConfiguration
(
)
{
if
(
this
.
_restoreFocus
&
&
this
.
browsingContext
?
.
isActive
&
&
this
.
window
)
{
try
{
this
.
window
.
focus
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_XPC_SECURITY_MANAGER_VETO
)
{
throw
e
;
}
}
}
}
_changeTopLevelDocument
(
window
)
{
if
(
!
this
.
docShell
.
isBeingDestroyed
(
)
&
&
this
.
window
)
{
this
.
_willNavigate
(
{
window
:
this
.
window
newURI
:
window
.
location
.
href
request
:
null
isFrameSwitching
:
true
navigationStart
:
Date
.
now
(
)
}
)
;
this
.
_windowDestroyed
(
this
.
window
{
isFrozen
:
true
isFrameSwitching
:
true
}
)
;
}
this
.
_setWindow
(
window
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_windowReady
(
window
{
isFrameSwitching
:
true
}
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
this
.
_navigate
(
window
true
)
;
}
)
;
}
)
;
}
_setWindow
(
window
)
{
this
.
docShell
=
window
.
docShell
;
this
.
emit
(
"
changed
-
toplevel
-
document
"
)
;
this
.
emit
(
"
frameUpdate
"
{
selected
:
this
.
outerWindowID
}
)
;
}
_windowReady
(
window
{
isFrameSwitching
isBFCache
}
=
{
}
)
{
if
(
this
.
ignoreSubFrames
)
{
return
;
}
const
isTopLevel
=
window
=
=
this
.
window
;
if
(
window
=
=
this
.
_originalWindow
&
&
!
isFrameSwitching
)
{
this
.
_updateChildDocShells
(
)
;
}
if
(
this
.
followWindowGlobalLifeCycle
&
&
isTopLevel
&
&
!
isFrameSwitching
)
{
return
;
}
this
.
emit
(
"
window
-
ready
"
{
window
isTopLevel
isBFCache
id
:
getWindowID
(
window
)
isFrameSwitching
}
)
;
}
_windowDestroyed
(
window
{
id
=
null
isFrozen
=
false
isFrameSwitching
=
false
}
)
{
if
(
this
.
ignoreSubFrames
)
{
return
;
}
const
isTopLevel
=
window
=
=
this
.
window
;
if
(
this
.
followWindowGlobalLifeCycle
&
&
isTopLevel
&
&
!
isFrameSwitching
)
{
return
;
}
this
.
emit
(
"
window
-
destroyed
"
{
window
isTopLevel
id
:
id
|
|
getWindowID
(
window
)
isFrozen
}
)
;
}
_willNavigate
(
{
window
newURI
request
isFrameSwitching
=
false
navigationStart
}
)
{
if
(
this
.
ignoreSubFrames
)
{
return
;
}
let
isTopLevel
=
window
=
=
this
.
window
;
let
reset
=
false
;
if
(
window
=
=
this
.
_originalWindow
&
&
!
isFrameSwitching
)
{
if
(
this
.
window
!
=
this
.
_originalWindow
)
{
reset
=
true
;
window
=
this
.
window
;
isTopLevel
=
true
;
}
}
this
.
emit
(
"
will
-
navigate
"
{
window
isTopLevel
newURI
request
navigationStart
isFrameSwitching
}
)
;
if
(
!
isTopLevel
)
{
return
;
}
if
(
!
this
.
followWindowGlobalLifeCycle
)
{
this
.
emit
(
"
tabNavigated
"
{
url
:
newURI
state
:
"
start
"
isFrameSwitching
}
)
;
}
if
(
reset
)
{
this
.
_setWindow
(
this
.
_originalWindow
)
;
}
}
_navigate
(
window
isFrameSwitching
=
false
)
{
if
(
this
.
ignoreSubFrames
)
{
return
;
}
const
isTopLevel
=
window
=
=
this
.
window
;
this
.
emit
(
"
navigate
"
{
window
isTopLevel
}
)
;
if
(
!
isTopLevel
)
{
return
;
}
if
(
this
.
followWindowGlobalLifeCycle
)
{
return
;
}
this
.
emit
(
"
tabNavigated
"
{
url
:
this
.
url
title
:
this
.
title
state
:
"
stop
"
isFrameSwitching
}
)
;
}
removeActorByName
(
name
)
{
if
(
name
in
this
.
_extraActors
)
{
const
actor
=
this
.
_extraActors
[
name
]
;
if
(
this
.
_targetScopedActorPool
.
has
(
actor
)
)
{
this
.
_targetScopedActorPool
.
removeActor
(
actor
)
;
}
delete
this
.
_extraActors
[
name
]
;
}
}
}
exports
.
WindowGlobalTargetActor
=
WindowGlobalTargetActor
;
class
DebuggerProgressListener
{
constructor
(
targetActor
)
{
this
.
_targetActor
=
targetActor
;
this
.
_onWindowCreated
=
this
.
onWindowCreated
.
bind
(
this
)
;
this
.
_onWindowHidden
=
this
.
onWindowHidden
.
bind
(
this
)
;
Services
.
obs
.
addObserver
(
this
"
inner
-
window
-
destroyed
"
)
;
this
.
_knownWindowIDs
=
new
Map
(
)
;
this
.
_watchedDocShells
=
new
WeakSet
(
)
;
}
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
;
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
"
inner
-
window
-
destroyed
"
)
;
this
.
_knownWindowIDs
.
clear
(
)
;
this
.
_knownWindowIDs
=
null
;
}
watch
(
docShell
)
{
const
docShellWindow
=
docShell
.
domWindow
;
this
.
_watchedDocShells
.
add
(
docShellWindow
)
;
const
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
const
handler
=
getDocShellChromeEventHandler
(
docShell
)
;
handler
.
addEventListener
(
"
DOMWindowCreated
"
this
.
_onWindowCreated
true
)
;
handler
.
addEventListener
(
"
pageshow
"
this
.
_onWindowCreated
true
)
;
handler
.
addEventListener
(
"
pagehide
"
this
.
_onWindowHidden
true
)
;
const
windows
=
this
.
_targetActor
.
ignoreSubFrames
?
[
docShellWindow
]
:
this
.
_getWindowsInDocShell
(
docShell
)
;
for
(
const
win
of
windows
)
{
this
.
_targetActor
.
_windowReady
(
win
)
;
this
.
_knownWindowIDs
.
set
(
getWindowID
(
win
)
win
)
;
}
if
(
this
.
_targetActor
.
isRootActor
&
&
this
.
_targetActor
.
docShell
.
cssErrorReportingEnabled
)
{
docShell
.
cssErrorReportingEnabled
=
true
;
}
}
unwatch
(
docShell
)
{
if
(
docShell
.
isBeingDestroyed
(
)
)
{
return
;
}
const
docShellWindow
=
docShell
.
domWindow
;
if
(
!
this
.
_watchedDocShells
.
has
(
docShellWindow
)
)
{
return
;
}
this
.
_watchedDocShells
.
delete
(
docShellWindow
)
;
const
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
try
{
webProgress
.
removeProgressListener
(
this
)
;
}
catch
(
e
)
{
}
const
handler
=
getDocShellChromeEventHandler
(
docShell
)
;
handler
.
removeEventListener
(
"
DOMWindowCreated
"
this
.
_onWindowCreated
true
)
;
handler
.
removeEventListener
(
"
pageshow
"
this
.
_onWindowCreated
true
)
;
handler
.
removeEventListener
(
"
pagehide
"
this
.
_onWindowHidden
true
)
;
const
windows
=
this
.
_targetActor
.
ignoreSubFrames
?
[
docShellWindow
]
:
this
.
_getWindowsInDocShell
(
docShell
)
;
for
(
const
win
of
windows
)
{
this
.
_knownWindowIDs
.
delete
(
getWindowID
(
win
)
)
;
}
}
_getWindowsInDocShell
(
docShell
)
{
return
getChildDocShells
(
docShell
)
.
map
(
d
=
>
{
return
d
.
domWindow
;
}
)
;
}
onWindowCreated
=
DevToolsUtils
.
makeInfallible
(
function
(
evt
)
{
if
(
this
.
_targetActor
.
isDestroyed
(
)
)
{
return
;
}
if
(
evt
.
inFrameSwap
)
{
return
;
}
const
window
=
evt
.
target
.
defaultView
;
if
(
!
window
)
{
return
;
}
const
innerID
=
getWindowID
(
window
)
;
if
(
this
.
_knownWindowIDs
.
has
(
innerID
)
)
{
return
;
}
this
.
_knownWindowIDs
.
set
(
innerID
window
)
;
const
isBFCache
=
evt
.
type
=
=
"
pageshow
"
;
this
.
_targetActor
.
_windowReady
(
window
{
isBFCache
}
)
;
}
"
DebuggerProgressListener
.
prototype
.
onWindowCreated
"
)
;
onWindowHidden
=
DevToolsUtils
.
makeInfallible
(
function
(
evt
)
{
if
(
this
.
_targetActor
.
isDestroyed
(
)
)
{
return
;
}
if
(
evt
.
inFrameSwap
)
{
return
;
}
if
(
!
evt
.
persisted
)
{
return
;
}
const
window
=
evt
.
target
.
defaultView
;
if
(
!
window
)
{
return
;
}
this
.
_targetActor
.
_windowDestroyed
(
window
{
isFrozen
:
true
}
)
;
this
.
_knownWindowIDs
.
delete
(
getWindowID
(
window
)
)
;
}
"
DebuggerProgressListener
.
prototype
.
onWindowHidden
"
)
;
observe
=
DevToolsUtils
.
makeInfallible
(
function
(
subject
)
{
if
(
this
.
_targetActor
.
isDestroyed
(
)
)
{
return
;
}
const
innerID
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
;
const
window
=
this
.
_knownWindowIDs
.
get
(
innerID
)
;
if
(
window
)
{
this
.
_knownWindowIDs
.
delete
(
innerID
)
;
this
.
_targetActor
.
_windowDestroyed
(
window
{
id
:
innerID
}
)
;
}
if
(
this
.
_watchedDocShells
.
has
(
window
)
&
&
!
Cu
.
isRemoteProxy
(
window
)
&
&
window
.
docShell
&
&
!
window
.
docShell
.
chromeEventHandler
)
{
this
.
unwatch
(
window
.
docShell
)
;
this
.
watch
(
window
.
docShell
)
;
}
}
"
DebuggerProgressListener
.
prototype
.
observe
"
)
;
onStateChange
=
DevToolsUtils
.
makeInfallible
(
function
(
progress
request
flag
)
{
if
(
this
.
_targetActor
.
isDestroyed
(
)
)
{
return
;
}
progress
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
if
(
progress
.
isBeingDestroyed
(
)
)
{
return
;
}
const
isStart
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_START
;
const
isStop
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
;
const
isDocument
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_IS_DOCUMENT
;
const
isWindow
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
;
const
navigationStart
=
Date
.
now
(
)
;
if
(
isDocument
&
&
isStop
)
{
this
.
_targetActor
.
_notifyDocShellsUpdate
(
[
progress
]
)
;
}
const
window
=
progress
.
DOMWindow
;
if
(
isDocument
&
&
isStart
)
{
const
newURI
=
request
instanceof
Ci
.
nsIChannel
?
request
.
URI
.
spec
:
null
;
this
.
_targetActor
.
_willNavigate
(
{
window
newURI
request
isFrameSwitching
:
false
navigationStart
}
)
;
}
if
(
isWindow
&
&
isStop
)
{
if
(
request
.
status
!
=
Cr
.
NS_OK
&
&
request
.
status
!
=
Cr
.
NS_BINDING_ABORTED
)
{
const
handler
=
getDocShellChromeEventHandler
(
progress
)
;
const
onLoad
=
evt
=
>
{
if
(
evt
.
target
=
=
=
window
.
document
)
{
handler
.
removeEventListener
(
"
DOMContentLoaded
"
onLoad
true
)
;
this
.
_targetActor
.
_navigate
(
window
)
;
}
}
;
handler
.
addEventListener
(
"
DOMContentLoaded
"
onLoad
true
)
;
}
else
{
this
.
_targetActor
.
_navigate
(
window
)
;
}
}
}
"
DebuggerProgressListener
.
prototype
.
onStateChange
"
)
;
}
