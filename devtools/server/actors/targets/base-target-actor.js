"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
TYPES
:
{
DOCUMENT_EVENT
NETWORK_EVENT_STACKTRACE
CONSOLE_MESSAGE
}
getResourceWatcher
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
index
.
js
"
)
;
const
Targets
=
require
(
"
devtools
/
server
/
actors
/
targets
/
index
"
)
;
const
{
ObjectActorPool
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
ObjectActorPool
.
js
"
)
;
const
{
throttle
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
throttle
.
js
"
)
;
const
RESOURCES_THROTTLING_DELAY
=
100
;
loader
.
lazyRequireGetter
(
this
"
SessionDataProcessors
"
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
session
-
data
-
processors
/
index
.
js
"
true
)
;
class
BaseTargetActor
extends
Actor
{
constructor
(
conn
targetType
spec
)
{
super
(
conn
spec
)
;
this
.
targetType
=
targetType
;
this
.
#
throttledResources
=
{
available
:
[
]
updated
:
[
]
destroyed
:
[
]
}
;
this
.
#
throttledEmitResources
=
throttle
(
this
.
emitResources
.
bind
(
this
)
RESOURCES_THROTTLING_DELAY
)
;
}
get
objectsPool
(
)
{
if
(
this
.
_objectsPool
)
{
return
this
.
_objectsPool
;
}
this
.
_objectsPool
=
new
ObjectActorPool
(
this
.
threadActor
"
target
-
objects
"
)
;
this
.
manage
(
this
.
_objectsPool
)
;
return
this
.
_objectsPool
;
}
#
throttledResources
;
#
throttledEmitResources
;
async
addOrSetSessionDataEntry
(
type
entries
isDocumentCreation
=
false
updateType
)
{
const
processor
=
SessionDataProcessors
[
type
]
;
if
(
processor
)
{
await
processor
.
addOrSetSessionDataEntry
(
this
entries
isDocumentCreation
updateType
)
;
}
}
removeSessionDataEntry
(
type
entries
)
{
const
processor
=
SessionDataProcessors
[
type
]
;
if
(
processor
)
{
processor
.
removeSessionDataEntry
(
this
entries
)
;
}
}
notifyResources
(
updateType
resourceType
resources
)
{
if
(
resources
.
length
=
=
=
0
|
|
this
.
isDestroyed
(
)
)
{
return
;
}
if
(
this
.
devtoolsSpawnedBrowsingContextForWebExtension
)
{
this
.
overrideResourceBrowsingContextForWebExtension
(
resources
)
;
}
const
shouldEmitSynchronously
=
resourceType
=
=
NETWORK_EVENT_STACKTRACE
|
|
(
resourceType
=
=
DOCUMENT_EVENT
&
&
resources
.
some
(
resource
=
>
resource
.
name
=
=
"
will
-
navigate
"
)
)
;
const
lastResourceInThrottleCache
=
this
.
#
throttledResources
[
updateType
]
.
at
(
-
1
)
;
if
(
lastResourceInThrottleCache
&
&
lastResourceInThrottleCache
[
0
]
=
=
=
resourceType
)
{
lastResourceInThrottleCache
[
1
]
.
push
.
apply
(
lastResourceInThrottleCache
[
1
]
resources
)
;
}
else
{
this
.
#
throttledResources
[
updateType
]
.
push
(
[
resourceType
resources
]
)
;
}
if
(
shouldEmitSynchronously
)
{
this
.
emitResources
(
)
;
}
else
{
this
.
#
throttledEmitResources
(
)
;
}
}
emitResources
(
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
for
(
const
updateType
of
[
"
available
"
"
updated
"
"
destroyed
"
]
)
{
const
resources
=
this
.
#
throttledResources
[
updateType
]
;
if
(
!
resources
.
length
)
{
continue
;
}
this
.
#
throttledResources
[
updateType
]
=
[
]
;
this
.
emit
(
resources
-
{
updateType
}
-
array
resources
)
;
}
}
overrideResourceBrowsingContextForWebExtension
(
resources
)
{
const
browsingContextID
=
this
.
devtoolsSpawnedBrowsingContextForWebExtension
.
id
;
resources
.
forEach
(
resource
=
>
(
resource
.
browsingContextID
=
browsingContextID
)
)
;
}
#
instantiatedTargetScopedActors
=
new
Set
(
)
;
getTargetScopedActor
(
prefix
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
null
;
}
const
form
=
this
.
form
(
)
;
this
.
#
instantiatedTargetScopedActors
.
add
(
prefix
)
;
return
this
.
conn
.
_getOrCreateActor
(
form
[
prefix
+
"
Actor
"
]
)
;
}
hasTargetScopedActor
(
prefix
)
{
return
this
.
#
instantiatedTargetScopedActors
.
has
(
prefix
)
;
}
isTracerFeatureEnabled
=
false
;
updateTargetConfiguration
(
options
=
{
}
calledFromDocumentCreation
=
false
)
{
if
(
typeof
options
.
isTracerFeatureEnabled
=
=
=
"
boolean
"
)
{
this
.
isTracerFeatureEnabled
=
options
.
isTracerFeatureEnabled
;
}
if
(
options
.
tracerOptions
)
{
if
(
options
.
tracerOptions
.
traceOnNextLoad
&
&
(
!
calledFromDocumentCreation
|
|
!
this
.
isTopLevelTarget
)
)
{
if
(
this
.
isTopLevelTarget
)
{
const
consoleMessageWatcher
=
getResourceWatcher
(
this
CONSOLE_MESSAGE
)
;
if
(
consoleMessageWatcher
)
{
consoleMessageWatcher
.
emitMessages
(
[
{
arguments
:
[
"
Waiting
for
next
navigation
or
page
reload
before
starting
tracing
"
]
styles
:
[
]
level
:
"
jstracer
"
chromeContext
:
false
timeStamp
:
ChromeUtils
.
dateNow
(
)
}
]
)
;
}
}
return
;
}
if
(
this
.
targetType
=
=
Targets
.
TYPES
.
PROCESS
|
|
this
.
url
?
.
startsWith
(
"
moz
-
extension
:
/
/
"
)
)
{
return
;
}
if
(
this
.
sessionContext
.
type
=
=
"
all
"
&
&
this
.
targetType
=
=
=
Targets
.
TYPES
.
FRAME
&
&
this
.
typeName
!
=
"
parentProcessTarget
"
&
&
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
return
;
}
const
tracerActor
=
this
.
getTargetScopedActor
(
"
tracer
"
)
;
tracerActor
.
startTracing
(
options
.
tracerOptions
)
;
}
else
if
(
this
.
hasTargetScopedActor
(
"
tracer
"
)
)
{
const
tracerActor
=
this
.
getTargetScopedActor
(
"
tracer
"
)
;
tracerActor
.
stopTracing
(
)
;
}
}
}
exports
.
BaseTargetActor
=
BaseTargetActor
;
