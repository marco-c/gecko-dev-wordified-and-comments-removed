"
use
strict
"
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
const
{
Ci
Cu
Cc
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
ParentProcessTargetActor
parentProcessTargetPrototype
}
=
require
(
"
devtools
/
server
/
actors
/
targets
/
parent
-
process
"
)
;
const
makeDebugger
=
require
(
"
devtools
/
server
/
actors
/
utils
/
make
-
debugger
"
)
;
const
{
ActorClassWithSpec
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
webExtensionTargetSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
targets
/
webextension
"
)
;
loader
.
lazyRequireGetter
(
this
"
unwrapDebuggerObjectGlobal
"
"
devtools
/
server
/
actors
/
thread
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ChromeUtils
"
)
;
const
FALLBACK_DOC_MESSAGE
=
"
Your
addon
does
not
have
any
document
opened
yet
.
"
;
const
webExtensionTargetPrototype
=
extend
(
{
}
parentProcessTargetPrototype
)
;
webExtensionTargetPrototype
.
initialize
=
function
(
conn
chromeGlobal
prefix
addonId
)
{
parentProcessTargetPrototype
.
initialize
.
call
(
this
conn
)
;
this
.
_chromeGlobal
=
chromeGlobal
;
this
.
_prefix
=
prefix
;
this
.
id
=
addonId
;
Object
.
defineProperty
(
this
"
messageManager
"
{
enumerable
:
true
configurable
:
true
get
:
(
)
=
>
{
return
this
.
_chromeGlobal
;
}
}
)
;
this
.
_allowSource
=
this
.
_allowSource
.
bind
(
this
)
;
this
.
_onParentExit
=
this
.
_onParentExit
.
bind
(
this
)
;
this
.
_chromeGlobal
.
addMessageListener
(
"
debug
:
webext_parent_exit
"
this
.
_onParentExit
)
;
this
.
consoleAPIListenerOptions
=
{
addonId
:
this
.
id
}
;
this
.
aps
=
Cc
[
"
mozilla
.
org
/
addons
/
policy
-
service
;
1
"
]
.
getService
(
Ci
.
nsIAddonPolicyService
)
;
this
.
makeDebugger
=
makeDebugger
.
bind
(
null
{
findDebuggees
:
dbg
=
>
{
return
dbg
.
findAllGlobals
(
)
.
filter
(
this
.
_shouldAddNewGlobalAsDebuggee
)
;
}
shouldAddNewGlobalAsDebuggee
:
this
.
_shouldAddNewGlobalAsDebuggee
.
bind
(
this
)
}
)
;
const
extensionWindow
=
this
.
_searchForExtensionWindow
(
)
;
if
(
extensionWindow
)
{
this
.
_setWindow
(
extensionWindow
)
;
}
}
;
webExtensionTargetPrototype
.
isRootActor
=
true
;
webExtensionTargetPrototype
.
exit
=
function
(
)
{
if
(
this
.
_chromeGlobal
)
{
const
chromeGlobal
=
this
.
_chromeGlobal
;
this
.
_chromeGlobal
=
null
;
chromeGlobal
.
removeMessageListener
(
"
debug
:
webext_parent_exit
"
this
.
_onParentExit
)
;
chromeGlobal
.
sendAsyncMessage
(
"
debug
:
webext_child_exit
"
{
actor
:
this
.
actorID
}
)
;
}
this
.
addon
=
null
;
this
.
id
=
null
;
return
ParentProcessTargetActor
.
prototype
.
exit
.
apply
(
this
)
;
}
;
webExtensionTargetPrototype
.
_createFallbackWindow
=
function
(
)
{
if
(
this
.
fallbackWindow
)
{
return
;
}
this
.
fallbackWebNav
=
Services
.
appShell
.
createWindowlessBrowser
(
true
)
;
this
.
fallbackWindow
=
this
.
fallbackWebNav
.
document
.
defaultView
;
this
.
fallbackWindow
.
document
.
body
.
innerText
=
FALLBACK_DOC_MESSAGE
;
}
;
webExtensionTargetPrototype
.
_destroyFallbackWindow
=
function
(
)
{
if
(
this
.
fallbackWebNav
)
{
this
.
fallbackWebNav
.
loadURI
(
"
about
:
blank
"
0
null
null
null
)
;
this
.
fallbackWebNav
.
close
(
)
;
this
.
fallbackWebNav
=
null
;
this
.
fallbackWindow
=
null
;
}
}
;
webExtensionTargetPrototype
.
_searchForExtensionWindow
=
function
(
)
{
const
e
=
Services
.
ww
.
getWindowEnumerator
(
null
)
;
while
(
e
.
hasMoreElements
(
)
)
{
const
window
=
e
.
getNext
(
)
;
if
(
window
.
document
.
nodePrincipal
.
addonId
=
=
this
.
id
)
{
return
window
;
}
}
return
undefined
;
}
;
webExtensionTargetPrototype
.
_onDocShellDestroy
=
function
(
docShell
)
{
this
.
_unwatchDocShell
(
docShell
)
;
const
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
this
.
_notifyDocShellDestroy
(
webProgress
)
;
if
(
this
.
attached
&
&
docShell
=
=
this
.
docShell
)
{
this
.
_createFallbackWindow
(
)
;
this
.
_changeTopLevelDocument
(
this
.
fallbackWindow
)
;
}
}
;
webExtensionTargetPrototype
.
_onNewExtensionWindow
=
function
(
window
)
{
if
(
!
this
.
window
|
|
this
.
window
=
=
=
this
.
fallbackWindow
)
{
this
.
_changeTopLevelDocument
(
window
)
;
}
}
;
webExtensionTargetPrototype
.
_attach
=
function
(
)
{
if
(
!
this
.
window
|
|
this
.
window
.
document
.
nodePrincipal
.
addonId
!
=
=
this
.
id
)
{
const
extensionWindow
=
this
.
_searchForExtensionWindow
(
)
;
if
(
!
extensionWindow
)
{
this
.
_createFallbackWindow
(
)
;
this
.
_setWindow
(
this
.
fallbackWindow
)
;
}
else
{
this
.
_setWindow
(
extensionWindow
)
;
}
}
ParentProcessTargetActor
.
prototype
.
_attach
.
apply
(
this
)
;
}
;
webExtensionTargetPrototype
.
_detach
=
function
(
)
{
ParentProcessTargetActor
.
prototype
.
_detach
.
apply
(
this
)
;
this
.
_destroyFallbackWindow
(
)
;
}
;
webExtensionTargetPrototype
.
_docShellToWindow
=
function
(
docShell
)
{
const
baseWindowDetails
=
ParentProcessTargetActor
.
prototype
.
_docShellToWindow
.
call
(
this
docShell
)
;
const
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
const
window
=
webProgress
.
DOMWindow
;
const
addonID
=
window
.
document
.
nodePrincipal
.
addonId
;
const
sameTypeRootAddonID
=
docShell
.
sameTypeRootTreeItem
.
domWindow
.
document
.
nodePrincipal
.
addonId
;
return
Object
.
assign
(
baseWindowDetails
{
addonID
sameTypeRootAddonID
}
)
;
}
;
webExtensionTargetPrototype
.
_docShellsToWindows
=
function
(
docshells
)
{
return
ParentProcessTargetActor
.
prototype
.
_docShellsToWindows
.
call
(
this
docshells
)
.
filter
(
windowDetails
=
>
{
return
windowDetails
.
addonID
=
=
=
this
.
id
|
|
windowDetails
.
sameTypeRootAddonID
=
=
=
this
.
id
;
}
)
;
}
;
webExtensionTargetPrototype
.
isExtensionWindow
=
function
(
window
)
{
return
window
.
document
.
nodePrincipal
.
addonId
=
=
this
.
id
;
}
;
webExtensionTargetPrototype
.
isExtensionWindowDescendent
=
function
(
window
)
{
const
rootWin
=
window
.
document
.
docShell
.
sameTypeRootTreeItem
.
domWindow
;
return
this
.
isExtensionWindow
(
rootWin
)
;
}
;
webExtensionTargetPrototype
.
_allowSource
=
function
(
source
)
{
if
(
source
.
element
)
{
const
domEl
=
unwrapDebuggerObjectGlobal
(
source
.
element
)
;
return
(
this
.
isExtensionWindow
(
domEl
.
ownerGlobal
)
|
|
this
.
isExtensionWindowDescendent
(
domEl
.
ownerGlobal
)
)
;
}
const
url
=
source
.
url
.
split
(
"
-
>
"
)
.
pop
(
)
;
if
(
url
=
=
=
"
debugger
eval
code
"
)
{
return
false
;
}
let
uri
;
try
{
uri
=
Services
.
io
.
newURI
(
url
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
Unexpected
invalid
url
:
{
url
}
)
;
return
false
;
}
if
(
[
"
resource
"
"
chrome
"
"
file
"
]
.
includes
(
uri
.
scheme
)
)
{
return
false
;
}
try
{
const
addonID
=
this
.
aps
.
extensionURIToAddonId
(
uri
)
;
return
addonID
=
=
this
.
id
;
}
catch
(
err
)
{
return
false
;
}
}
;
webExtensionTargetPrototype
.
_shouldAddNewGlobalAsDebuggee
=
function
(
newGlobal
)
{
const
global
=
unwrapDebuggerObjectGlobal
(
newGlobal
)
;
if
(
global
instanceof
Ci
.
nsIDOMWindow
)
{
try
{
global
.
document
;
}
catch
(
e
)
{
return
false
;
}
if
(
ChromeUtils
.
getClassName
(
global
.
document
)
=
=
"
XULDocument
"
)
{
return
false
;
}
if
(
global
.
document
.
ownerGlobal
&
&
this
.
isExtensionWindow
(
global
)
)
{
this
.
_onNewExtensionWindow
(
global
.
document
.
ownerGlobal
)
;
}
return
global
.
document
.
ownerGlobal
&
&
this
.
isExtensionWindowDescendent
(
global
.
document
.
ownerGlobal
)
;
}
try
{
const
metadata
=
Cu
.
getSandboxMetadata
(
global
)
;
if
(
metadata
)
{
return
metadata
.
addonID
=
=
=
this
.
id
;
}
}
catch
(
e
)
{
}
return
false
;
}
;
webExtensionTargetPrototype
.
_onParentExit
=
function
(
msg
)
{
if
(
msg
.
json
.
actor
!
=
=
this
.
actorID
)
{
return
;
}
this
.
exit
(
)
;
}
;
exports
.
WebExtensionTargetActor
=
ActorClassWithSpec
(
webExtensionTargetSpec
webExtensionTargetPrototype
)
;
