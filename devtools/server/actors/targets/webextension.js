"
use
strict
"
;
const
{
ParentProcessTargetActor
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
parent
-
process
.
js
"
)
;
const
makeDebugger
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
make
-
debugger
.
js
"
)
;
const
{
webExtensionTargetSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
targets
/
webextension
.
js
"
)
;
const
{
getChildDocShells
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
window
-
global
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
unwrapDebuggerObjectGlobal
"
"
resource
:
/
/
devtools
/
server
/
actors
/
thread
.
js
"
true
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
getAddonIdForWindowGlobal
:
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
browsing
-
context
-
helpers
.
sys
.
mjs
"
}
)
;
const
FALLBACK_DOC_URL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
webextension
-
fallback
.
html
"
;
class
WebExtensionTargetActor
extends
ParentProcessTargetActor
{
constructor
(
conn
{
addonId
addonBrowsingContextGroupId
chromeGlobal
isTopLevelTarget
prefix
sessionContext
}
)
{
super
(
conn
{
isTopLevelTarget
sessionContext
customSpec
:
webExtensionTargetSpec
}
)
;
this
.
addonId
=
addonId
;
this
.
addonBrowsingContextGroupId
=
addonBrowsingContextGroupId
;
this
.
_chromeGlobal
=
chromeGlobal
;
this
.
_prefix
=
prefix
;
this
.
devtoolsSpawnedBrowsingContextForWebExtension
=
chromeGlobal
.
browsingContext
;
Object
.
defineProperty
(
this
"
messageManager
"
{
enumerable
:
true
configurable
:
true
get
:
(
)
=
>
{
return
this
.
_chromeGlobal
;
}
}
)
;
this
.
_onParentExit
=
this
.
_onParentExit
.
bind
(
this
)
;
this
.
_chromeGlobal
.
addMessageListener
(
"
debug
:
webext_parent_exit
"
this
.
_onParentExit
)
;
this
.
consoleAPIListenerOptions
=
{
addonId
:
this
.
addonId
}
;
this
.
makeDebugger
=
makeDebugger
.
bind
(
null
{
findDebuggees
:
dbg
=
>
{
return
dbg
.
findAllGlobals
(
)
.
filter
(
this
.
_shouldAddNewGlobalAsDebuggee
)
.
map
(
g
=
>
g
.
unsafeDereference
(
)
)
;
}
shouldAddNewGlobalAsDebuggee
:
this
.
_shouldAddNewGlobalAsDebuggee
.
bind
(
this
)
}
)
;
this
.
isRootActor
=
true
;
const
extensionWindow
=
this
.
_searchForExtensionWindow
(
)
;
this
.
setDocShell
(
extensionWindow
.
docShell
)
;
this
.
threadActor
.
attach
(
{
}
)
;
}
get
docShells
(
)
{
let
docShells
=
[
]
;
for
(
const
window
of
Services
.
ww
.
getWindowEnumerator
(
null
)
)
{
docShells
=
docShells
.
concat
(
getChildDocShells
(
window
.
docShell
)
)
;
}
return
docShells
.
filter
(
docShell
=
>
{
return
this
.
isExtensionWindowDescendent
(
docShell
.
domWindow
)
;
}
)
;
}
destroy
(
)
{
if
(
this
.
_chromeGlobal
)
{
const
chromeGlobal
=
this
.
_chromeGlobal
;
this
.
_chromeGlobal
=
null
;
chromeGlobal
.
removeMessageListener
(
"
debug
:
webext_parent_exit
"
this
.
_onParentExit
)
;
chromeGlobal
.
sendAsyncMessage
(
"
debug
:
webext_child_exit
"
{
actor
:
this
.
actorID
}
)
;
}
if
(
this
.
fallbackWindow
)
{
this
.
fallbackWindow
=
null
;
}
this
.
addon
=
null
;
this
.
addonId
=
null
;
return
super
.
destroy
(
)
;
}
_searchFallbackWindow
(
)
{
if
(
this
.
fallbackWindow
)
{
return
this
.
fallbackWindow
;
}
this
.
fallbackWindow
=
this
.
_chromeGlobal
.
content
;
this
.
fallbackWindow
.
document
.
location
.
href
=
{
FALLBACK_DOC_URL
}
#
{
this
.
addonId
}
;
return
this
.
fallbackWindow
;
}
_searchForExtensionWindow
(
)
{
const
docShell
=
this
.
docShells
.
find
(
d
=
>
this
.
isTopLevelExtensionWindow
(
d
.
domWindow
)
)
;
if
(
docShell
)
{
return
docShell
.
domWindow
;
}
return
this
.
_searchFallbackWindow
(
)
;
}
_onDocShellCreated
(
docShell
)
{
if
(
docShell
.
browsingContext
.
group
.
id
!
=
this
.
addonBrowsingContextGroupId
)
{
return
;
}
super
.
_onDocShellCreated
(
docShell
)
;
}
_onDocShellDestroy
(
docShell
)
{
if
(
docShell
.
browsingContext
.
group
.
id
!
=
this
.
addonBrowsingContextGroupId
)
{
return
;
}
this
.
_unwatchDocShell
(
docShell
)
;
const
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
this
.
_notifyDocShellDestroy
(
webProgress
)
;
if
(
!
this
.
isDestroyed
(
)
&
&
docShell
=
=
this
.
docShell
&
&
!
docShell
.
domWindow
.
location
.
href
.
includes
(
"
_generated_background_page
.
html
"
)
)
{
this
.
_changeTopLevelDocument
(
this
.
_searchForExtensionWindow
(
)
)
;
}
}
_onNewExtensionWindow
(
window
)
{
if
(
!
this
.
window
|
|
this
.
window
=
=
=
this
.
fallbackWindow
)
{
this
.
_changeTopLevelDocument
(
window
)
;
this
.
addonBrowsingContextGroupId
=
window
.
docShell
.
browsingContext
.
group
.
id
;
}
}
isTopLevelExtensionWindow
(
window
)
{
const
{
docShell
}
=
window
;
const
isTopLevel
=
docShell
.
sameTypeRootTreeItem
=
=
docShell
;
return
isTopLevel
&
&
window
.
document
.
nodePrincipal
.
addonId
=
=
this
.
addonId
;
}
isExtensionWindowDescendent
(
window
)
{
const
rootWin
=
window
.
docShell
.
sameTypeRootTreeItem
.
domWindow
;
const
addonId
=
lazy
.
getAddonIdForWindowGlobal
(
rootWin
.
windowGlobalChild
)
;
return
addonId
=
=
this
.
addonId
;
}
_shouldAddNewGlobalAsDebuggee
(
newGlobal
)
{
const
global
=
unwrapDebuggerObjectGlobal
(
newGlobal
)
;
if
(
global
instanceof
Ci
.
nsIDOMWindow
)
{
try
{
global
.
document
;
}
catch
(
e
)
{
return
false
;
}
const
window
=
global
.
document
.
ownerGlobal
;
if
(
!
window
)
{
return
false
;
}
if
(
this
.
isTopLevelExtensionWindow
(
window
)
)
{
this
.
_onNewExtensionWindow
(
window
)
;
}
return
this
.
isExtensionWindowDescendent
(
window
)
;
}
try
{
const
metadata
=
Cu
.
getSandboxMetadata
(
global
)
;
if
(
metadata
)
{
return
metadata
.
addonID
=
=
=
this
.
addonId
;
}
}
catch
(
e
)
{
}
return
false
;
}
_onParentExit
(
msg
)
{
if
(
msg
.
json
.
actor
!
=
=
this
.
actorID
)
{
return
;
}
this
.
destroy
(
)
;
}
}
exports
.
WebExtensionTargetActor
=
WebExtensionTargetActor
;
