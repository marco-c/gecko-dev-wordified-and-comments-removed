"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
TargetActorRegistry
"
]
;
const
windowGlobalTargetActors
=
new
Set
(
)
;
let
xpcShellTargetActor
=
null
;
var
TargetActorRegistry
=
{
registerTargetActor
(
targetActor
)
{
windowGlobalTargetActors
.
add
(
targetActor
)
;
}
unregisterTargetActor
(
targetActor
)
{
windowGlobalTargetActors
.
delete
(
targetActor
)
;
}
registerXpcShellTargetActor
(
targetActor
)
{
xpcShellTargetActor
=
targetActor
;
}
unregisterXpcShellTargetActor
(
targetActor
)
{
xpcShellTargetActor
=
null
;
}
getTopLevelTargetActorForContext
(
context
connectionPrefix
)
{
if
(
context
.
type
=
=
"
all
"
)
{
if
(
Services
.
appinfo
.
processType
=
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
if
(
xpcShellTargetActor
)
{
return
xpcShellTargetActor
;
}
const
actors
=
this
.
getTargetActors
(
context
connectionPrefix
)
;
return
actors
[
0
]
;
}
return
null
;
}
else
if
(
context
.
type
=
=
"
browser
-
element
"
)
{
const
actors
=
this
.
getTargetActors
(
context
connectionPrefix
)
;
return
actors
.
find
(
actor
=
>
{
return
actor
.
isTopLevelTarget
;
}
)
;
}
throw
new
Error
(
"
Unsupported
context
type
:
"
+
context
.
type
)
;
}
getTargetActors
(
context
connectionPrefix
)
{
const
actors
=
[
]
;
for
(
const
actor
of
windowGlobalTargetActors
)
{
const
isMatchingPrefix
=
actor
.
actorID
.
startsWith
(
connectionPrefix
)
;
const
isMatchingContext
=
(
context
.
type
=
=
"
all
"
&
&
actor
.
typeName
=
=
=
"
parentProcessTarget
"
)
|
|
(
context
.
type
=
=
"
browser
-
element
"
&
&
actor
.
browserId
=
=
context
.
browserId
)
;
if
(
isMatchingPrefix
&
&
isMatchingContext
)
{
actors
.
push
(
actor
)
;
}
}
return
actors
;
}
}
;
