"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
{
DebuggerServer
ActorPool
}
=
require
(
"
devtools
/
server
/
main
"
)
;
const
{
ThreadActor
}
=
require
(
"
devtools
/
server
/
actors
/
thread
"
)
;
const
{
ObjectActor
LongStringActor
createValueGrip
stringIsLong
}
=
require
(
"
devtools
/
server
/
actors
/
object
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
ErrorDocs
=
require
(
"
devtools
/
server
/
actors
/
errordocs
"
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkMonitor
"
"
devtools
/
shared
/
webconsole
/
network
-
monitor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkMonitorChild
"
"
devtools
/
shared
/
webconsole
/
network
-
monitor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleProgressListener
"
"
devtools
/
shared
/
webconsole
/
network
-
monitor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
StackTraceCollector
"
"
devtools
/
shared
/
webconsole
/
network
-
monitor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ServerLoggingListener
"
"
devtools
/
shared
/
webconsole
/
server
-
logger
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
JSPropertyProvider
"
"
devtools
/
shared
/
webconsole
/
js
-
property
-
provider
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Parser
"
"
resource
:
/
/
devtools
/
shared
/
Parser
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
addWebConsoleCommands
"
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CONSOLE_WORKER_IDS
"
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebConsoleUtils
"
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EnvironmentActor
"
"
devtools
/
server
/
actors
/
environment
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
if
(
isWorker
)
{
loader
.
lazyRequireGetter
(
this
"
ConsoleAPIListener
"
"
devtools
/
server
/
actors
/
webconsole
/
worker
-
listeners
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleServiceListener
"
"
devtools
/
server
/
actors
/
webconsole
/
worker
-
listeners
"
true
)
;
}
else
{
loader
.
lazyRequireGetter
(
this
"
ConsoleAPIListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleServiceListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleReflowListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ContentProcessListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DocumentEventsListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
"
true
)
;
}
function
isObject
(
value
)
{
return
Object
(
value
)
=
=
=
value
;
}
function
WebConsoleActor
(
connection
parentActor
)
{
this
.
conn
=
connection
;
this
.
parentActor
=
parentActor
;
this
.
_actorPool
=
new
ActorPool
(
this
.
conn
)
;
this
.
conn
.
addActorPool
(
this
.
_actorPool
)
;
this
.
_prefs
=
{
}
;
this
.
dbg
=
this
.
parentActor
.
makeDebugger
(
)
;
this
.
_netEvents
=
new
Map
(
)
;
this
.
_networkEventActorsByURL
=
new
Map
(
)
;
this
.
_gripDepth
=
0
;
this
.
_listeners
=
new
Set
(
)
;
this
.
_lastConsoleInputEvaluation
=
undefined
;
this
.
objectGrip
=
this
.
objectGrip
.
bind
(
this
)
;
this
.
_onWillNavigate
=
this
.
_onWillNavigate
.
bind
(
this
)
;
this
.
_onChangedToplevelDocument
=
this
.
_onChangedToplevelDocument
.
bind
(
this
)
;
EventEmitter
.
on
(
this
.
parentActor
"
changed
-
toplevel
-
document
"
this
.
_onChangedToplevelDocument
)
;
this
.
_onObserverNotification
=
this
.
_onObserverNotification
.
bind
(
this
)
;
if
(
this
.
parentActor
.
isRootActor
)
{
Services
.
obs
.
addObserver
(
this
.
_onObserverNotification
"
last
-
pb
-
context
-
exited
"
)
;
}
this
.
traits
=
{
customNetworkRequest
:
!
this
.
_parentIsContentActor
evaluateJSAsync
:
true
transferredResponseSize
:
true
selectedObjectActor
:
true
}
;
}
WebConsoleActor
.
prototype
=
{
dbg
:
null
_gripDepth
:
null
_actorPool
:
null
_prefs
:
null
_netEvents
:
null
_networkEventActorsByURL
:
null
_listeners
:
null
conn
:
null
traits
:
null
get
_parentIsContentActor
(
)
{
return
this
.
parentActor
.
constructor
.
name
=
=
"
ContentActor
"
;
}
get
window
(
)
{
if
(
this
.
parentActor
.
isRootActor
)
{
return
this
.
_getWindowForBrowserConsole
(
)
;
}
return
this
.
parentActor
.
window
;
}
_getWindowForBrowserConsole
:
function
(
)
{
let
window
=
this
.
_lastChromeWindow
&
&
this
.
_lastChromeWindow
.
get
(
)
;
if
(
!
window
|
|
window
.
closed
)
{
window
=
this
.
parentActor
.
window
;
if
(
!
window
)
{
window
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webconsole
"
)
;
let
onChromeWindowOpened
=
(
)
=
>
{
Services
.
obs
.
removeObserver
(
onChromeWindowOpened
"
domwindowopened
"
)
;
this
.
_lastChromeWindow
=
null
;
}
;
Services
.
obs
.
addObserver
(
onChromeWindowOpened
"
domwindowopened
"
)
;
}
this
.
_handleNewWindow
(
window
)
;
}
return
window
;
}
_handleNewWindow
:
function
(
window
)
{
if
(
window
)
{
if
(
this
.
_hadChromeWindow
)
{
Services
.
console
.
logStringMessage
(
"
Webconsole
context
has
changed
"
)
;
}
this
.
_lastChromeWindow
=
Cu
.
getWeakReference
(
window
)
;
this
.
_hadChromeWindow
=
true
;
}
else
{
this
.
_lastChromeWindow
=
null
;
}
}
_hadChromeWindow
:
false
_lastChromeWindow
:
null
_evalWindow
:
null
get
evalWindow
(
)
{
return
this
.
_evalWindow
|
|
this
.
window
;
}
set
evalWindow
(
window
)
{
this
.
_evalWindow
=
window
;
if
(
!
this
.
_progressListenerActive
)
{
EventEmitter
.
on
(
this
.
parentActor
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_progressListenerActive
=
true
;
}
}
_progressListenerActive
:
false
consoleServiceListener
:
null
consoleAPIListener
:
null
networkMonitor
:
null
networkMonitorChild
:
null
consoleProgressListener
:
null
consoleReflowListener
:
null
_webConsoleCommandsCache
:
null
actorPrefix
:
"
console
"
get
globalDebugObject
(
)
{
return
this
.
parentActor
.
threadActor
.
globalDebugObject
;
}
grip
:
function
(
)
{
return
{
actor
:
this
.
actorID
}
;
}
hasNativeConsoleAPI
:
function
(
window
)
{
if
(
isWorker
)
{
return
true
;
}
let
isNative
=
false
;
try
{
let
console
=
window
.
wrappedJSObject
.
console
;
isNative
=
new
XPCNativeWrapper
(
console
)
.
IS_NATIVE_CONSOLE
;
}
catch
(
ex
)
{
}
return
isNative
;
}
_findProtoChain
:
ThreadActor
.
prototype
.
_findProtoChain
_removeFromProtoChain
:
ThreadActor
.
prototype
.
_removeFromProtoChain
destroy
(
)
{
if
(
this
.
consoleServiceListener
)
{
this
.
consoleServiceListener
.
destroy
(
)
;
this
.
consoleServiceListener
=
null
;
}
if
(
this
.
consoleAPIListener
)
{
this
.
consoleAPIListener
.
destroy
(
)
;
this
.
consoleAPIListener
=
null
;
}
if
(
this
.
networkMonitor
)
{
this
.
networkMonitor
.
destroy
(
)
;
this
.
networkMonitor
=
null
;
}
if
(
this
.
networkMonitorChild
)
{
this
.
networkMonitorChild
.
destroy
(
)
;
this
.
networkMonitorChild
=
null
;
}
if
(
this
.
stackTraceCollector
)
{
this
.
stackTraceCollector
.
destroy
(
)
;
this
.
stackTraceCollector
=
null
;
}
if
(
this
.
consoleProgressListener
)
{
this
.
consoleProgressListener
.
destroy
(
)
;
this
.
consoleProgressListener
=
null
;
}
if
(
this
.
consoleReflowListener
)
{
this
.
consoleReflowListener
.
destroy
(
)
;
this
.
consoleReflowListener
=
null
;
}
if
(
this
.
serverLoggingListener
)
{
this
.
serverLoggingListener
.
destroy
(
)
;
this
.
serverLoggingListener
=
null
;
}
if
(
this
.
contentProcessListener
)
{
this
.
contentProcessListener
.
destroy
(
)
;
this
.
contentProcessListener
=
null
;
}
EventEmitter
.
off
(
this
.
parentActor
"
changed
-
toplevel
-
document
"
this
.
_onChangedToplevelDocument
)
;
this
.
conn
.
removeActorPool
(
this
.
_actorPool
)
;
if
(
this
.
parentActor
.
isRootActor
)
{
Services
.
obs
.
removeObserver
(
this
.
_onObserverNotification
"
last
-
pb
-
context
-
exited
"
)
;
}
this
.
_actorPool
=
null
;
this
.
_webConsoleCommandsCache
=
null
;
this
.
_lastConsoleInputEvaluation
=
null
;
this
.
_evalWindow
=
null
;
this
.
_netEvents
.
clear
(
)
;
this
.
dbg
.
enabled
=
false
;
this
.
dbg
=
null
;
this
.
conn
=
null
;
}
createEnvironmentActor
:
function
(
environment
)
{
if
(
!
environment
)
{
return
undefined
;
}
if
(
environment
.
actor
)
{
return
environment
.
actor
;
}
let
actor
=
new
EnvironmentActor
(
environment
this
)
;
this
.
_actorPool
.
addActor
(
actor
)
;
environment
.
actor
=
actor
;
return
actor
;
}
createValueGrip
:
function
(
value
)
{
return
createValueGrip
(
value
this
.
_actorPool
this
.
objectGrip
)
;
}
makeDebuggeeValue
:
function
(
value
useObjectGlobal
)
{
if
(
useObjectGlobal
&
&
isObject
(
value
)
)
{
try
{
let
global
=
Cu
.
getGlobalForObject
(
value
)
;
let
dbgGlobal
=
this
.
dbg
.
makeGlobalObjectReference
(
global
)
;
return
dbgGlobal
.
makeDebuggeeValue
(
value
)
;
}
catch
(
ex
)
{
}
}
let
dbgGlobal
=
this
.
dbg
.
makeGlobalObjectReference
(
this
.
window
)
;
return
dbgGlobal
.
makeDebuggeeValue
(
value
)
;
}
objectGrip
:
function
(
object
pool
)
{
let
actor
=
new
ObjectActor
(
object
{
getGripDepth
:
(
)
=
>
this
.
_gripDepth
incrementGripDepth
:
(
)
=
>
this
.
_gripDepth
+
+
decrementGripDepth
:
(
)
=
>
this
.
_gripDepth
-
-
createValueGrip
:
v
=
>
this
.
createValueGrip
(
v
)
sources
:
(
)
=
>
DevToolsUtils
.
reportException
(
"
WebConsoleActor
"
Error
(
"
sources
not
yet
implemented
"
)
)
createEnvironmentActor
:
(
env
)
=
>
this
.
createEnvironmentActor
(
env
)
getGlobalDebugObject
:
(
)
=
>
this
.
globalDebugObject
}
)
;
pool
.
addActor
(
actor
)
;
return
actor
.
grip
(
)
;
}
longStringGrip
:
function
(
string
pool
)
{
let
actor
=
new
LongStringActor
(
string
)
;
pool
.
addActor
(
actor
)
;
return
actor
.
grip
(
)
;
}
_createStringGrip
:
function
(
string
)
{
if
(
string
&
&
stringIsLong
(
string
)
)
{
return
this
.
longStringGrip
(
string
this
.
_actorPool
)
;
}
return
string
;
}
getActorByID
:
function
(
actorID
)
{
return
this
.
_actorPool
.
get
(
actorID
)
;
}
releaseActor
:
function
(
actor
)
{
this
.
_actorPool
.
removeActor
(
actor
)
;
}
getLastConsoleInputEvaluation
:
function
(
)
{
return
this
.
_lastConsoleInputEvaluation
;
}
inspectObject
(
dbgObj
inspectFromAnnotation
)
{
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
inspectObject
"
{
objectActor
:
this
.
createValueGrip
(
dbgObj
)
inspectFromAnnotation
}
)
;
}
onStartListeners
:
function
(
request
)
{
let
startedListeners
=
[
]
;
let
window
=
!
this
.
parentActor
.
isRootActor
?
this
.
window
:
null
;
let
messageManager
=
null
;
if
(
this
.
_parentIsContentActor
)
{
messageManager
=
this
.
parentActor
.
messageManager
;
}
while
(
request
.
listeners
.
length
>
0
)
{
let
listener
=
request
.
listeners
.
shift
(
)
;
switch
(
listener
)
{
case
"
PageError
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
consoleServiceListener
)
{
this
.
consoleServiceListener
=
new
ConsoleServiceListener
(
window
this
)
;
this
.
consoleServiceListener
.
init
(
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
ConsoleAPI
"
:
if
(
!
this
.
consoleAPIListener
)
{
this
.
consoleAPIListener
=
new
ConsoleAPIListener
(
window
this
this
.
parentActor
.
consoleAPIListenerOptions
)
;
this
.
consoleAPIListener
.
init
(
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
NetworkActivity
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
networkMonitor
)
{
this
.
stackTraceCollector
=
new
StackTraceCollector
(
{
window
}
)
;
this
.
stackTraceCollector
.
init
(
)
;
let
processBoundary
=
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
;
if
(
messageManager
&
&
processBoundary
)
{
this
.
networkMonitor
=
new
NetworkMonitorChild
(
this
.
parentActor
.
outerWindowID
messageManager
this
.
conn
this
)
;
this
.
networkMonitor
.
init
(
)
;
this
.
networkMonitorChild
=
new
NetworkMonitor
(
{
window
}
this
)
;
this
.
networkMonitorChild
.
init
(
)
;
}
else
{
this
.
networkMonitor
=
new
NetworkMonitor
(
{
window
}
this
)
;
this
.
networkMonitor
.
init
(
)
;
}
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
FileActivity
"
:
if
(
isWorker
)
{
break
;
}
if
(
this
.
window
instanceof
Ci
.
nsIDOMWindow
)
{
if
(
!
this
.
consoleProgressListener
)
{
this
.
consoleProgressListener
=
new
ConsoleProgressListener
(
this
.
window
this
)
;
}
this
.
consoleProgressListener
.
startMonitor
(
this
.
consoleProgressListener
.
MONITOR_FILE_ACTIVITY
)
;
startedListeners
.
push
(
listener
)
;
}
break
;
case
"
ReflowActivity
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
consoleReflowListener
)
{
this
.
consoleReflowListener
=
new
ConsoleReflowListener
(
this
.
window
this
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
ServerLogging
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
serverLoggingListener
)
{
this
.
serverLoggingListener
=
new
ServerLoggingListener
(
this
.
window
this
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
ContentProcessMessages
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
contentProcessListener
)
{
this
.
contentProcessListener
=
new
ContentProcessListener
(
this
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
DocumentEvents
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
documentEventsListener
)
{
this
.
documentEventsListener
=
new
DocumentEventsListener
(
this
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
}
}
startedListeners
.
forEach
(
this
.
_listeners
.
add
this
.
_listeners
)
;
return
{
startedListeners
:
startedListeners
nativeConsoleAPI
:
this
.
hasNativeConsoleAPI
(
this
.
window
)
traits
:
this
.
traits
}
;
}
onStopListeners
:
function
(
request
)
{
let
stoppedListeners
=
[
]
;
let
toDetach
=
request
.
listeners
|
|
[
"
PageError
"
"
ConsoleAPI
"
"
NetworkActivity
"
"
FileActivity
"
"
ServerLogging
"
"
ContentProcessMessages
"
]
;
while
(
toDetach
.
length
>
0
)
{
let
listener
=
toDetach
.
shift
(
)
;
switch
(
listener
)
{
case
"
PageError
"
:
if
(
this
.
consoleServiceListener
)
{
this
.
consoleServiceListener
.
destroy
(
)
;
this
.
consoleServiceListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
ConsoleAPI
"
:
if
(
this
.
consoleAPIListener
)
{
this
.
consoleAPIListener
.
destroy
(
)
;
this
.
consoleAPIListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
NetworkActivity
"
:
if
(
this
.
networkMonitor
)
{
this
.
networkMonitor
.
destroy
(
)
;
this
.
networkMonitor
=
null
;
}
if
(
this
.
networkMonitorChild
)
{
this
.
networkMonitorChild
.
destroy
(
)
;
this
.
networkMonitorChild
=
null
;
}
if
(
this
.
stackTraceCollector
)
{
this
.
stackTraceCollector
.
destroy
(
)
;
this
.
stackTraceCollector
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
FileActivity
"
:
if
(
this
.
consoleProgressListener
)
{
this
.
consoleProgressListener
.
stopMonitor
(
this
.
consoleProgressListener
.
MONITOR_FILE_ACTIVITY
)
;
this
.
consoleProgressListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
ReflowActivity
"
:
if
(
this
.
consoleReflowListener
)
{
this
.
consoleReflowListener
.
destroy
(
)
;
this
.
consoleReflowListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
ServerLogging
"
:
if
(
this
.
serverLoggingListener
)
{
this
.
serverLoggingListener
.
destroy
(
)
;
this
.
serverLoggingListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
ContentProcessMessages
"
:
if
(
this
.
contentProcessListener
)
{
this
.
contentProcessListener
.
destroy
(
)
;
this
.
contentProcessListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
DocumentEvents
"
:
if
(
this
.
documentEventsListener
)
{
this
.
documentEventsListener
.
destroy
(
)
;
this
.
documentEventsListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
}
}
stoppedListeners
.
forEach
(
this
.
_listeners
.
delete
this
.
_listeners
)
;
return
{
stoppedListeners
:
stoppedListeners
}
;
}
onGetCachedMessages
:
function
(
request
)
{
let
types
=
request
.
messageTypes
;
if
(
!
types
)
{
return
{
error
:
"
missingParameter
"
message
:
"
The
messageTypes
parameter
is
missing
.
"
}
;
}
let
messages
=
[
]
;
while
(
types
.
length
>
0
)
{
let
type
=
types
.
shift
(
)
;
switch
(
type
)
{
case
"
ConsoleAPI
"
:
{
if
(
!
this
.
consoleAPIListener
)
{
break
;
}
let
winStartTime
=
this
.
window
&
&
this
.
window
.
performance
?
this
.
window
.
performance
.
timing
.
navigationStart
:
0
;
let
cache
=
this
.
consoleAPIListener
.
getCachedMessages
(
!
this
.
parentActor
.
isRootActor
)
;
cache
.
forEach
(
(
cachedMessage
)
=
>
{
if
(
cachedMessage
.
innerID
=
=
=
"
ServiceWorker
"
&
&
winStartTime
>
cachedMessage
.
timeStamp
)
{
return
;
}
let
message
=
this
.
prepareConsoleMessageForRemote
(
cachedMessage
)
;
message
.
_type
=
type
;
messages
.
push
(
message
)
;
}
)
;
break
;
}
case
"
PageError
"
:
{
if
(
!
this
.
consoleServiceListener
)
{
break
;
}
let
cache
=
this
.
consoleServiceListener
.
getCachedMessages
(
!
this
.
parentActor
.
isRootActor
)
;
cache
.
forEach
(
(
cachedMessage
)
=
>
{
let
message
=
null
;
if
(
cachedMessage
instanceof
Ci
.
nsIScriptError
)
{
message
=
this
.
preparePageErrorForRemote
(
cachedMessage
)
;
message
.
_type
=
type
;
}
else
{
message
=
{
_type
:
"
LogMessage
"
message
:
this
.
_createStringGrip
(
cachedMessage
.
message
)
timeStamp
:
cachedMessage
.
timeStamp
}
;
}
messages
.
push
(
message
)
;
}
)
;
break
;
}
}
}
return
{
from
:
this
.
actorID
messages
:
messages
}
;
}
onEvaluateJSAsync
:
function
(
request
)
{
let
resultID
=
Date
.
now
(
)
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
resultID
:
resultID
}
)
;
let
response
=
this
.
onEvaluateJS
(
request
)
;
response
.
resultID
=
resultID
;
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
evaluationResult
"
response
)
;
}
onEvaluateJS
:
function
(
request
)
{
let
input
=
request
.
text
;
let
timestamp
=
Date
.
now
(
)
;
let
evalOptions
=
{
bindObjectActor
:
request
.
bindObjectActor
frameActor
:
request
.
frameActor
url
:
request
.
url
selectedNodeActor
:
request
.
selectedNodeActor
selectedObjectActor
:
request
.
selectedObjectActor
}
;
let
evalInfo
=
this
.
evalWithDebugger
(
input
evalOptions
)
;
let
evalResult
=
evalInfo
.
result
;
let
helperResult
=
evalInfo
.
helperResult
;
let
result
errorDocURL
errorMessage
errorNotes
=
null
errorGrip
=
null
frame
=
null
;
if
(
evalResult
)
{
if
(
"
return
"
in
evalResult
)
{
result
=
evalResult
.
return
;
}
else
if
(
"
yield
"
in
evalResult
)
{
result
=
evalResult
.
yield
;
}
else
if
(
"
throw
"
in
evalResult
)
{
let
error
=
evalResult
.
throw
;
errorGrip
=
this
.
createValueGrip
(
error
)
;
errorMessage
=
String
(
error
)
;
if
(
typeof
error
=
=
=
"
object
"
&
&
error
!
=
=
null
)
{
try
{
errorMessage
=
DevToolsUtils
.
callPropertyOnObject
(
error
"
toString
"
)
;
}
catch
(
e
)
{
if
(
typeof
error
.
unsafeDereference
=
=
=
"
function
"
)
{
errorMessage
=
error
.
unsafeDereference
(
)
.
toString
(
)
;
}
}
}
try
{
errorDocURL
=
ErrorDocs
.
GetURL
(
error
)
;
}
catch
(
ex
)
{
}
try
{
let
line
=
error
.
errorLineNumber
;
let
column
=
error
.
errorColumnNumber
;
if
(
typeof
line
=
=
=
"
number
"
&
&
typeof
column
=
=
=
"
number
"
)
{
frame
=
{
source
:
"
debugger
eval
code
"
line
column
}
;
}
}
catch
(
ex
)
{
}
try
{
let
notes
=
error
.
errorNotes
;
if
(
notes
&
&
notes
.
length
)
{
errorNotes
=
[
]
;
for
(
let
note
of
notes
)
{
errorNotes
.
push
(
{
messageBody
:
this
.
_createStringGrip
(
note
.
message
)
frame
:
{
source
:
note
.
fileName
line
:
note
.
lineNumber
column
:
note
.
columnNumber
}
}
)
;
}
}
}
catch
(
ex
)
{
}
}
}
let
resultGrip
;
try
{
resultGrip
=
this
.
createValueGrip
(
result
)
;
}
catch
(
e
)
{
errorMessage
=
e
;
}
this
.
_lastConsoleInputEvaluation
=
result
;
return
{
from
:
this
.
actorID
input
:
input
result
:
resultGrip
timestamp
:
timestamp
exception
:
errorGrip
exceptionMessage
:
this
.
_createStringGrip
(
errorMessage
)
exceptionDocURL
:
errorDocURL
frame
helperResult
:
helperResult
notes
:
errorNotes
}
;
}
onAutocomplete
:
function
(
request
)
{
let
frameActorId
=
request
.
frameActor
;
let
dbgObject
=
null
;
let
environment
=
null
;
let
hadDebuggee
=
false
;
if
(
frameActorId
)
{
let
frameActor
=
this
.
conn
.
getActor
(
frameActorId
)
;
try
{
let
frame
=
frameActor
.
frame
;
environment
=
frame
.
environment
;
}
catch
(
e
)
{
DevToolsUtils
.
reportException
(
"
onAutocomplete
"
Error
(
"
The
frame
actor
was
not
found
:
"
+
frameActorId
)
)
;
}
}
else
{
hadDebuggee
=
this
.
dbg
.
hasDebuggee
(
this
.
evalWindow
)
;
dbgObject
=
this
.
dbg
.
addDebuggee
(
this
.
evalWindow
)
;
}
let
result
=
JSPropertyProvider
(
dbgObject
environment
request
.
text
request
.
cursor
frameActorId
)
|
|
{
}
;
if
(
!
hadDebuggee
&
&
dbgObject
)
{
this
.
dbg
.
removeDebuggee
(
this
.
evalWindow
)
;
}
let
matches
=
result
.
matches
|
|
[
]
;
let
reqText
=
request
.
text
.
substr
(
0
request
.
cursor
)
;
let
lastNonAlphaIsDot
=
/
[
.
]
[
a
-
zA
-
Z0
-
9
]
*
/
.
test
(
reqText
)
;
if
(
!
lastNonAlphaIsDot
)
{
if
(
!
this
.
_webConsoleCommandsCache
)
{
let
helpers
=
{
sandbox
:
Object
.
create
(
null
)
}
;
addWebConsoleCommands
(
helpers
)
;
this
.
_webConsoleCommandsCache
=
Object
.
getOwnPropertyNames
(
helpers
.
sandbox
)
;
}
matches
=
matches
.
concat
(
this
.
_webConsoleCommandsCache
.
filter
(
n
=
>
n
.
startsWith
(
result
.
matchProp
)
)
)
;
}
return
{
from
:
this
.
actorID
matches
:
matches
.
sort
(
)
matchProp
:
result
.
matchProp
}
;
}
onClearMessagesCache
:
function
(
)
{
let
windowId
=
!
this
.
parentActor
.
isRootActor
?
WebConsoleUtils
.
getInnerWindowId
(
this
.
window
)
:
null
;
let
ConsoleAPIStorage
=
Cc
[
"
mozilla
.
org
/
consoleAPI
-
storage
;
1
"
]
.
getService
(
Ci
.
nsIConsoleAPIStorage
)
;
ConsoleAPIStorage
.
clearEvents
(
windowId
)
;
CONSOLE_WORKER_IDS
.
forEach
(
(
id
)
=
>
{
ConsoleAPIStorage
.
clearEvents
(
id
)
;
}
)
;
if
(
this
.
parentActor
.
isRootActor
)
{
Services
.
console
.
logStringMessage
(
null
)
;
Services
.
console
.
reset
(
)
;
}
return
{
}
;
}
onGetPreferences
:
function
(
request
)
{
let
prefs
=
Object
.
create
(
null
)
;
for
(
let
key
of
request
.
preferences
)
{
prefs
[
key
]
=
this
.
_prefs
[
key
]
;
}
return
{
preferences
:
prefs
}
;
}
onSetPreferences
:
function
(
request
)
{
for
(
let
key
in
request
.
preferences
)
{
this
.
_prefs
[
key
]
=
request
.
preferences
[
key
]
;
if
(
this
.
networkMonitor
)
{
if
(
key
=
=
"
NetworkMonitor
.
saveRequestAndResponseBodies
"
)
{
this
.
networkMonitor
.
saveRequestAndResponseBodies
=
this
.
_prefs
[
key
]
;
if
(
this
.
networkMonitorChild
)
{
this
.
networkMonitorChild
.
saveRequestAndResponseBodies
=
this
.
_prefs
[
key
]
;
}
}
else
if
(
key
=
=
"
NetworkMonitor
.
throttleData
"
)
{
this
.
networkMonitor
.
throttleData
=
this
.
_prefs
[
key
]
;
if
(
this
.
networkMonitorChild
)
{
this
.
networkMonitorChild
.
throttleData
=
this
.
_prefs
[
key
]
;
}
}
}
}
return
{
updated
:
Object
.
keys
(
request
.
preferences
)
}
;
}
_getWebConsoleCommands
:
function
(
debuggerGlobal
)
{
let
helpers
=
{
window
:
this
.
evalWindow
chromeWindow
:
this
.
chromeWindow
.
bind
(
this
)
makeDebuggeeValue
:
debuggerGlobal
.
makeDebuggeeValue
.
bind
(
debuggerGlobal
)
createValueGrip
:
this
.
createValueGrip
.
bind
(
this
)
sandbox
:
Object
.
create
(
null
)
helperResult
:
null
consoleActor
:
this
}
;
addWebConsoleCommands
(
helpers
)
;
let
evalWindow
=
this
.
evalWindow
;
function
maybeExport
(
obj
name
)
{
if
(
typeof
obj
[
name
]
!
=
"
function
"
)
{
return
;
}
obj
[
name
]
=
Cu
.
exportFunction
(
obj
[
name
]
evalWindow
{
allowCrossOriginArguments
:
true
}
)
;
}
for
(
let
name
in
helpers
.
sandbox
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
helpers
.
sandbox
name
)
;
if
(
!
isWorker
)
{
maybeExport
(
desc
"
get
"
)
;
maybeExport
(
desc
"
set
"
)
;
maybeExport
(
desc
"
value
"
)
;
}
if
(
desc
.
value
)
{
desc
.
value
=
debuggerGlobal
.
makeDebuggeeValue
(
desc
.
value
)
;
}
Object
.
defineProperty
(
helpers
.
sandbox
name
desc
)
;
}
return
helpers
;
}
evalWithDebugger
:
function
(
string
options
=
{
}
)
{
let
trimmedString
=
string
.
trim
(
)
;
if
(
trimmedString
=
=
"
help
"
|
|
trimmedString
=
=
"
?
"
)
{
string
=
"
help
(
)
"
;
}
if
(
trimmedString
=
=
"
console
.
mihai
(
)
"
|
|
trimmedString
=
=
"
console
.
mihai
(
)
;
"
)
{
string
=
"
\
"
http
:
/
/
incompleteness
.
me
/
blog
/
2015
/
02
/
09
/
console
-
dot
-
mihai
/
\
"
"
;
}
let
frame
=
null
frameActor
=
null
;
if
(
options
.
frameActor
)
{
frameActor
=
this
.
conn
.
getActor
(
options
.
frameActor
)
;
if
(
frameActor
)
{
frame
=
frameActor
.
frame
;
}
else
{
DevToolsUtils
.
reportException
(
"
evalWithDebugger
"
Error
(
"
The
frame
actor
was
not
found
:
"
+
options
.
frameActor
)
)
;
}
}
let
dbg
=
frame
?
frameActor
.
threadActor
.
dbg
:
this
.
dbg
;
let
dbgWindow
=
dbg
.
makeGlobalObjectReference
(
this
.
evalWindow
)
;
let
bindSelf
=
null
;
if
(
options
.
bindObjectActor
|
|
options
.
selectedObjectActor
)
{
let
objActor
=
this
.
getActorByID
(
options
.
bindObjectActor
|
|
options
.
selectedObjectActor
)
;
if
(
objActor
)
{
let
jsVal
=
objActor
.
rawValue
(
)
;
if
(
isObject
(
jsVal
)
)
{
bindSelf
=
dbgWindow
.
makeDebuggeeValue
(
jsVal
)
;
if
(
options
.
bindObjectActor
)
{
let
global
=
Cu
.
getGlobalForObject
(
jsVal
)
;
try
{
let
_dbgWindow
=
dbg
.
makeGlobalObjectReference
(
global
)
;
dbgWindow
=
_dbgWindow
;
}
catch
(
err
)
{
}
}
}
else
{
bindSelf
=
jsVal
;
}
}
}
let
helpers
=
this
.
_getWebConsoleCommands
(
dbgWindow
)
;
let
bindings
=
helpers
.
sandbox
;
if
(
bindSelf
)
{
bindings
.
_self
=
bindSelf
;
}
if
(
options
.
selectedNodeActor
)
{
let
actor
=
this
.
conn
.
getActor
(
options
.
selectedNodeActor
)
;
if
(
actor
)
{
helpers
.
selectedNode
=
actor
.
rawNode
;
}
}
let
found
=
false
found
=
false
;
if
(
frame
)
{
let
env
=
frame
.
environment
;
if
(
env
)
{
found
=
!
!
env
.
find
(
"
"
)
;
found
=
!
!
env
.
find
(
"
"
)
;
}
}
else
{
found
=
!
!
dbgWindow
.
getOwnPropertyDescriptor
(
"
"
)
;
found
=
!
!
dbgWindow
.
getOwnPropertyDescriptor
(
"
"
)
;
}
let
=
null
=
null
;
if
(
found
)
{
=
bindings
.
;
delete
bindings
.
;
}
if
(
found
)
{
=
bindings
.
;
delete
bindings
.
;
}
helpers
.
evalInput
=
string
;
let
evalOptions
;
if
(
typeof
options
.
url
=
=
"
string
"
)
{
evalOptions
=
{
url
:
options
.
url
}
;
}
if
(
this
.
_lastConsoleInputEvaluation
&
&
this
.
_lastConsoleInputEvaluation
.
global
!
=
=
dbgWindow
)
{
this
.
_lastConsoleInputEvaluation
=
dbg
.
adoptDebuggeeValue
(
this
.
_lastConsoleInputEvaluation
)
;
}
let
result
;
if
(
frame
)
{
result
=
frame
.
evalWithBindings
(
string
bindings
evalOptions
)
;
}
else
{
result
=
dbgWindow
.
executeInGlobalWithBindings
(
string
bindings
evalOptions
)
;
if
(
"
throw
"
in
result
)
{
let
ast
;
try
{
ast
=
Parser
.
reflectionAPI
.
parse
(
string
)
;
}
catch
(
ex
)
{
ast
=
{
"
body
"
:
[
]
}
;
}
for
(
let
line
of
ast
.
body
)
{
if
(
!
(
line
.
kind
=
=
"
let
"
|
|
line
.
kind
=
=
"
const
"
)
)
{
continue
;
}
let
identifiers
=
[
]
;
for
(
let
decl
of
line
.
declarations
)
{
switch
(
decl
.
id
.
type
)
{
case
"
Identifier
"
:
identifiers
.
push
(
decl
.
id
.
name
)
;
break
;
case
"
ArrayPattern
"
:
for
(
let
e
of
decl
.
id
.
elements
)
{
if
(
e
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
e
.
name
)
;
}
else
if
(
e
.
type
=
=
"
AssignmentExpression
"
)
{
identifiers
.
push
(
e
.
left
.
name
)
;
}
}
break
;
case
"
ObjectPattern
"
:
for
(
let
prop
of
decl
.
id
.
properties
)
{
if
(
prop
.
key
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
prop
.
key
.
name
)
;
}
if
(
prop
.
value
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
prop
.
value
.
name
)
;
}
else
if
(
prop
.
value
.
type
=
=
"
AssignmentExpression
"
)
{
identifiers
.
push
(
prop
.
value
.
left
.
name
)
;
}
}
break
;
}
}
for
(
let
name
of
identifiers
)
{
dbgWindow
.
forceLexicalInitializationByName
(
name
)
;
}
}
}
}
let
helperResult
=
helpers
.
helperResult
;
delete
helpers
.
evalInput
;
delete
helpers
.
helperResult
;
delete
helpers
.
selectedNode
;
if
(
)
{
bindings
.
=
;
}
if
(
)
{
bindings
.
=
;
}
if
(
bindings
.
_self
)
{
delete
bindings
.
_self
;
}
return
{
result
:
result
helperResult
:
helperResult
dbg
:
dbg
frame
:
frame
window
:
dbgWindow
}
;
}
onConsoleServiceMessage
:
function
(
message
)
{
let
packet
;
if
(
message
instanceof
Ci
.
nsIScriptError
)
{
packet
=
{
from
:
this
.
actorID
type
:
"
pageError
"
pageError
:
this
.
preparePageErrorForRemote
(
message
)
}
;
}
else
{
packet
=
{
from
:
this
.
actorID
type
:
"
logMessage
"
message
:
this
.
_createStringGrip
(
message
.
message
)
timeStamp
:
message
.
timeStamp
}
;
}
this
.
conn
.
send
(
packet
)
;
}
preparePageErrorForRemote
:
function
(
pageError
)
{
let
stack
=
null
;
if
(
pageError
.
stack
&
&
!
Cu
.
isDeadWrapper
(
pageError
.
stack
)
)
{
stack
=
[
]
;
let
s
=
pageError
.
stack
;
while
(
s
!
=
=
null
)
{
stack
.
push
(
{
filename
:
s
.
source
lineNumber
:
s
.
line
columnNumber
:
s
.
column
functionName
:
s
.
functionDisplayName
}
)
;
s
=
s
.
parent
;
}
}
let
lineText
=
pageError
.
sourceLine
;
if
(
lineText
&
&
lineText
.
length
>
DebuggerServer
.
LONG_STRING_INITIAL_LENGTH
)
{
lineText
=
lineText
.
substr
(
0
DebuggerServer
.
LONG_STRING_INITIAL_LENGTH
)
;
}
let
notesArray
=
null
;
let
notes
=
pageError
.
notes
;
if
(
notes
&
&
notes
.
length
)
{
notesArray
=
[
]
;
for
(
let
i
=
0
len
=
notes
.
length
;
i
<
len
;
i
+
+
)
{
let
note
=
notes
.
queryElementAt
(
i
Ci
.
nsIScriptErrorNote
)
;
notesArray
.
push
(
{
messageBody
:
this
.
_createStringGrip
(
note
.
errorMessage
)
frame
:
{
source
:
note
.
sourceName
line
:
note
.
lineNumber
column
:
note
.
columnNumber
}
}
)
;
}
}
return
{
errorMessage
:
this
.
_createStringGrip
(
pageError
.
errorMessage
)
errorMessageName
:
pageError
.
errorMessageName
exceptionDocURL
:
ErrorDocs
.
GetURL
(
pageError
)
sourceName
:
pageError
.
sourceName
lineText
:
lineText
lineNumber
:
pageError
.
lineNumber
columnNumber
:
pageError
.
columnNumber
category
:
pageError
.
category
timeStamp
:
pageError
.
timeStamp
warning
:
!
!
(
pageError
.
flags
&
pageError
.
warningFlag
)
error
:
!
!
(
pageError
.
flags
&
pageError
.
errorFlag
)
exception
:
!
!
(
pageError
.
flags
&
pageError
.
exceptionFlag
)
strict
:
!
!
(
pageError
.
flags
&
pageError
.
strictFlag
)
info
:
!
!
(
pageError
.
flags
&
pageError
.
infoFlag
)
private
:
pageError
.
isFromPrivateWindow
stacktrace
:
stack
notes
:
notesArray
}
;
}
onConsoleAPICall
:
function
(
message
)
{
let
packet
=
{
from
:
this
.
actorID
type
:
"
consoleAPICall
"
message
:
this
.
prepareConsoleMessageForRemote
(
message
)
}
;
this
.
conn
.
send
(
packet
)
;
}
onNetworkEvent
:
function
(
event
)
{
let
actor
=
this
.
getNetworkEventActor
(
event
.
channelId
)
;
actor
.
init
(
event
)
;
this
.
_networkEventActorsByURL
.
set
(
actor
.
_request
.
url
actor
)
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEvent
"
eventActor
:
actor
.
grip
(
)
}
;
this
.
conn
.
send
(
packet
)
;
return
actor
;
}
getNetworkEventActor
:
function
(
channelId
)
{
let
actor
=
this
.
_netEvents
.
get
(
channelId
)
;
if
(
actor
)
{
this
.
_netEvents
.
delete
(
channelId
)
;
return
actor
;
}
actor
=
new
NetworkEventActor
(
this
)
;
this
.
_actorPool
.
addActor
(
actor
)
;
return
actor
;
}
getNetworkEventActorForURL
(
url
)
{
return
this
.
_networkEventActorsByURL
.
get
(
url
)
;
}
onSendHTTPRequest
(
message
)
{
let
{
url
method
headers
body
}
=
message
.
request
;
let
doc
=
this
.
window
.
document
;
let
channel
=
NetUtil
.
newChannel
(
{
uri
:
NetUtil
.
newURI
(
url
)
loadingNode
:
doc
securityFlags
:
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_OTHER
}
)
;
channel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
channel
.
loadGroup
=
doc
.
documentLoadGroup
;
channel
.
loadFlags
|
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
|
Ci
.
nsIRequest
.
INHIBIT_CACHING
|
Ci
.
nsIRequest
.
LOAD_ANONYMOUS
;
channel
.
requestMethod
=
method
;
for
(
let
{
name
value
}
of
headers
)
{
channel
.
setRequestHeader
(
name
value
false
)
;
}
if
(
body
)
{
channel
.
QueryInterface
(
Ci
.
nsIUploadChannel2
)
;
let
bodyStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
bodyStream
.
setData
(
body
body
.
length
)
;
channel
.
explicitSetUploadStream
(
bodyStream
null
-
1
method
false
)
;
}
NetUtil
.
asyncFetch
(
channel
(
)
=
>
{
}
)
;
let
actor
=
this
.
getNetworkEventActor
(
channel
.
channelId
)
;
this
.
_netEvents
.
set
(
channel
.
channelId
actor
)
;
return
{
from
:
this
.
actorID
eventActor
:
actor
.
grip
(
)
}
;
}
onFileActivity
:
function
(
fileURI
)
{
let
packet
=
{
from
:
this
.
actorID
type
:
"
fileActivity
"
uri
:
fileURI
}
;
this
.
conn
.
send
(
packet
)
;
}
onReflowActivity
:
function
(
reflowInfo
)
{
let
packet
=
{
from
:
this
.
actorID
type
:
"
reflowActivity
"
interruptible
:
reflowInfo
.
interruptible
start
:
reflowInfo
.
start
end
:
reflowInfo
.
end
sourceURL
:
reflowInfo
.
sourceURL
sourceLine
:
reflowInfo
.
sourceLine
functionName
:
reflowInfo
.
functionName
}
;
this
.
conn
.
send
(
packet
)
;
}
onServerLogCall
:
function
(
message
)
{
let
msg
=
Cu
.
cloneInto
(
message
this
.
window
)
;
msg
=
this
.
prepareConsoleMessageForRemote
(
msg
false
)
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
serverLogCall
"
message
:
msg
}
;
this
.
conn
.
send
(
packet
)
;
}
prepareConsoleMessageForRemote
:
function
(
message
useObjectGlobal
=
true
)
{
let
result
=
WebConsoleUtils
.
cloneObject
(
message
)
;
result
.
workerType
=
WebConsoleUtils
.
getWorkerType
(
result
)
|
|
"
none
"
;
delete
result
.
wrappedJSObject
;
delete
result
.
ID
;
delete
result
.
innerID
;
delete
result
.
consoleID
;
result
.
arguments
=
Array
.
map
(
message
.
arguments
|
|
[
]
(
obj
)
=
>
{
let
dbgObj
=
this
.
makeDebuggeeValue
(
obj
useObjectGlobal
)
;
return
this
.
createValueGrip
(
dbgObj
)
;
}
)
;
result
.
styles
=
Array
.
map
(
message
.
styles
|
|
[
]
(
string
)
=
>
{
return
this
.
createValueGrip
(
string
)
;
}
)
;
result
.
category
=
message
.
category
|
|
"
webdev
"
;
return
result
;
}
chromeWindow
:
function
(
)
{
let
window
=
null
;
try
{
window
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
chromeEventHandler
.
ownerGlobal
;
}
catch
(
ex
)
{
}
return
window
;
}
_onObserverNotification
:
function
(
subject
topic
)
{
switch
(
topic
)
{
case
"
last
-
pb
-
context
-
exited
"
:
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
lastPrivateContextExited
"
}
)
;
break
;
}
}
_onWillNavigate
:
function
(
{
window
isTopLevel
}
)
{
if
(
isTopLevel
)
{
this
.
_evalWindow
=
null
;
EventEmitter
.
off
(
this
.
parentActor
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_progressListenerActive
=
false
;
}
}
_onChangedToplevelDocument
:
function
(
)
{
let
listeners
=
[
.
.
.
this
.
_listeners
]
;
this
.
onStopListeners
(
{
listeners
:
listeners
.
slice
(
)
}
)
;
this
.
onStartListeners
(
{
listeners
:
listeners
}
)
;
this
.
_lastChromeWindow
=
null
;
}
}
;
WebConsoleActor
.
prototype
.
requestTypes
=
{
startListeners
:
WebConsoleActor
.
prototype
.
onStartListeners
stopListeners
:
WebConsoleActor
.
prototype
.
onStopListeners
getCachedMessages
:
WebConsoleActor
.
prototype
.
onGetCachedMessages
evaluateJS
:
WebConsoleActor
.
prototype
.
onEvaluateJS
evaluateJSAsync
:
WebConsoleActor
.
prototype
.
onEvaluateJSAsync
autocomplete
:
WebConsoleActor
.
prototype
.
onAutocomplete
clearMessagesCache
:
WebConsoleActor
.
prototype
.
onClearMessagesCache
getPreferences
:
WebConsoleActor
.
prototype
.
onGetPreferences
setPreferences
:
WebConsoleActor
.
prototype
.
onSetPreferences
sendHTTPRequest
:
WebConsoleActor
.
prototype
.
onSendHTTPRequest
}
;
exports
.
WebConsoleActor
=
WebConsoleActor
;
function
NetworkEventActor
(
webConsoleActor
)
{
this
.
parent
=
webConsoleActor
;
this
.
conn
=
this
.
parent
.
conn
;
this
.
_request
=
{
method
:
null
url
:
null
httpVersion
:
null
headers
:
[
]
cookies
:
[
]
headersSize
:
null
postData
:
{
}
}
;
this
.
_response
=
{
headers
:
[
]
cookies
:
[
]
content
:
{
}
}
;
this
.
_timings
=
{
}
;
this
.
_stackTrace
=
{
}
;
this
.
_longStringActors
=
new
Set
(
)
;
}
NetworkEventActor
.
prototype
=
{
_request
:
null
_response
:
null
_timings
:
null
_longStringActors
:
null
actorPrefix
:
"
netEvent
"
grip
:
function
(
)
{
return
{
actor
:
this
.
actorID
startedDateTime
:
this
.
_startedDateTime
timeStamp
:
Date
.
parse
(
this
.
_startedDateTime
)
url
:
this
.
_request
.
url
method
:
this
.
_request
.
method
isXHR
:
this
.
_isXHR
cause
:
this
.
_cause
fromCache
:
this
.
_fromCache
fromServiceWorker
:
this
.
_fromServiceWorker
private
:
this
.
_private
}
;
}
release
:
function
(
)
{
for
(
let
grip
of
this
.
_longStringActors
)
{
let
actor
=
this
.
parent
.
getActorByID
(
grip
.
actor
)
;
if
(
actor
)
{
this
.
parent
.
releaseActor
(
actor
)
;
}
}
this
.
_longStringActors
=
new
Set
(
)
;
if
(
this
.
_request
.
url
)
{
this
.
parent
.
_networkEventActorsByURL
.
delete
(
this
.
_request
.
url
)
;
}
if
(
this
.
channel
)
{
this
.
parent
.
_netEvents
.
delete
(
this
.
channel
)
;
}
this
.
parent
.
releaseActor
(
this
)
;
}
onRelease
:
function
(
)
{
this
.
release
(
)
;
return
{
}
;
}
init
:
function
(
networkEvent
)
{
this
.
_startedDateTime
=
networkEvent
.
startedDateTime
;
this
.
_isXHR
=
networkEvent
.
isXHR
;
this
.
_cause
=
networkEvent
.
cause
;
this
.
_fromCache
=
networkEvent
.
fromCache
;
this
.
_fromServiceWorker
=
networkEvent
.
fromServiceWorker
;
this
.
_stackTrace
=
networkEvent
.
cause
.
stacktrace
;
delete
networkEvent
.
cause
.
stacktrace
;
networkEvent
.
cause
.
stacktraceAvailable
=
!
!
(
this
.
_stackTrace
&
&
this
.
_stackTrace
.
length
)
;
for
(
let
prop
of
[
"
method
"
"
url
"
"
httpVersion
"
"
headersSize
"
]
)
{
this
.
_request
[
prop
]
=
networkEvent
[
prop
]
;
}
this
.
_discardRequestBody
=
networkEvent
.
discardRequestBody
;
this
.
_discardResponseBody
=
networkEvent
.
discardResponseBody
;
this
.
_truncated
=
false
;
this
.
_private
=
networkEvent
.
private
;
}
onGetRequestHeaders
:
function
(
)
{
return
{
from
:
this
.
actorID
headers
:
this
.
_request
.
headers
headersSize
:
this
.
_request
.
headersSize
rawHeaders
:
this
.
_request
.
rawHeaders
}
;
}
onGetRequestCookies
:
function
(
)
{
return
{
from
:
this
.
actorID
cookies
:
this
.
_request
.
cookies
}
;
}
onGetRequestPostData
:
function
(
)
{
return
{
from
:
this
.
actorID
postData
:
this
.
_request
.
postData
postDataDiscarded
:
this
.
_discardRequestBody
}
;
}
onGetSecurityInfo
:
function
(
)
{
return
{
from
:
this
.
actorID
securityInfo
:
this
.
_securityInfo
}
;
}
onGetResponseHeaders
:
function
(
)
{
return
{
from
:
this
.
actorID
headers
:
this
.
_response
.
headers
headersSize
:
this
.
_response
.
headersSize
rawHeaders
:
this
.
_response
.
rawHeaders
}
;
}
onGetResponseCookies
:
function
(
)
{
return
{
from
:
this
.
actorID
cookies
:
this
.
_response
.
cookies
}
;
}
onGetResponseContent
:
function
(
)
{
return
{
from
:
this
.
actorID
content
:
this
.
_response
.
content
contentDiscarded
:
this
.
_discardResponseBody
}
;
}
onGetEventTimings
:
function
(
)
{
return
{
from
:
this
.
actorID
timings
:
this
.
_timings
totalTime
:
this
.
_totalTime
offsets
:
this
.
_offsets
}
;
}
onGetStackTrace
:
function
(
)
{
return
{
from
:
this
.
actorID
stacktrace
:
this
.
_stackTrace
}
;
}
addRequestHeaders
:
function
(
headers
rawHeaders
)
{
this
.
_request
.
headers
=
headers
;
this
.
_prepareHeaders
(
headers
)
;
rawHeaders
=
this
.
parent
.
_createStringGrip
(
rawHeaders
)
;
if
(
typeof
rawHeaders
=
=
"
object
"
)
{
this
.
_longStringActors
.
add
(
rawHeaders
)
;
}
this
.
_request
.
rawHeaders
=
rawHeaders
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
requestHeaders
"
headers
:
headers
.
length
headersSize
:
this
.
_request
.
headersSize
}
;
this
.
conn
.
send
(
packet
)
;
}
addRequestCookies
:
function
(
cookies
)
{
this
.
_request
.
cookies
=
cookies
;
this
.
_prepareHeaders
(
cookies
)
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
requestCookies
"
cookies
:
cookies
.
length
}
;
this
.
conn
.
send
(
packet
)
;
}
addRequestPostData
:
function
(
postData
)
{
this
.
_request
.
postData
=
postData
;
postData
.
text
=
this
.
parent
.
_createStringGrip
(
postData
.
text
)
;
if
(
typeof
postData
.
text
=
=
"
object
"
)
{
this
.
_longStringActors
.
add
(
postData
.
text
)
;
}
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
requestPostData
"
dataSize
:
postData
.
text
.
length
discardRequestBody
:
this
.
_discardRequestBody
}
;
this
.
conn
.
send
(
packet
)
;
}
addResponseStart
:
function
(
info
rawHeaders
)
{
rawHeaders
=
this
.
parent
.
_createStringGrip
(
rawHeaders
)
;
if
(
typeof
rawHeaders
=
=
"
object
"
)
{
this
.
_longStringActors
.
add
(
rawHeaders
)
;
}
this
.
_response
.
rawHeaders
=
rawHeaders
;
this
.
_response
.
httpVersion
=
info
.
httpVersion
;
this
.
_response
.
status
=
info
.
status
;
this
.
_response
.
statusText
=
info
.
statusText
;
this
.
_response
.
headersSize
=
info
.
headersSize
;
this
.
_discardResponseBody
=
info
.
discardResponseBody
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
responseStart
"
response
:
info
}
;
this
.
conn
.
send
(
packet
)
;
}
addSecurityInfo
:
function
(
info
)
{
this
.
_securityInfo
=
info
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
securityInfo
"
state
:
info
.
state
}
;
this
.
conn
.
send
(
packet
)
;
}
addResponseHeaders
:
function
(
headers
)
{
this
.
_response
.
headers
=
headers
;
this
.
_prepareHeaders
(
headers
)
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
responseHeaders
"
headers
:
headers
.
length
headersSize
:
this
.
_response
.
headersSize
}
;
this
.
conn
.
send
(
packet
)
;
}
addResponseCookies
:
function
(
cookies
)
{
this
.
_response
.
cookies
=
cookies
;
this
.
_prepareHeaders
(
cookies
)
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
responseCookies
"
cookies
:
cookies
.
length
}
;
this
.
conn
.
send
(
packet
)
;
}
addResponseContent
:
function
(
content
{
discardResponseBody
truncated
}
)
{
this
.
_truncated
=
truncated
;
this
.
_response
.
content
=
content
;
content
.
text
=
this
.
parent
.
_createStringGrip
(
content
.
text
)
;
if
(
typeof
content
.
text
=
=
"
object
"
)
{
this
.
_longStringActors
.
add
(
content
.
text
)
;
}
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
responseContent
"
mimeType
:
content
.
mimeType
contentSize
:
content
.
size
encoding
:
content
.
encoding
transferredSize
:
content
.
transferredSize
discardResponseBody
}
;
this
.
conn
.
send
(
packet
)
;
}
addEventTimings
:
function
(
total
timings
offsets
)
{
this
.
_totalTime
=
total
;
this
.
_timings
=
timings
;
this
.
_offsets
=
offsets
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
eventTimings
"
totalTime
:
total
}
;
this
.
conn
.
send
(
packet
)
;
}
_prepareHeaders
:
function
(
headers
)
{
for
(
let
header
of
headers
)
{
header
.
value
=
this
.
parent
.
_createStringGrip
(
header
.
value
)
;
if
(
typeof
header
.
value
=
=
"
object
"
)
{
this
.
_longStringActors
.
add
(
header
.
value
)
;
}
}
}
}
;
NetworkEventActor
.
prototype
.
requestTypes
=
{
"
release
"
:
NetworkEventActor
.
prototype
.
onRelease
"
getRequestHeaders
"
:
NetworkEventActor
.
prototype
.
onGetRequestHeaders
"
getRequestCookies
"
:
NetworkEventActor
.
prototype
.
onGetRequestCookies
"
getRequestPostData
"
:
NetworkEventActor
.
prototype
.
onGetRequestPostData
"
getResponseHeaders
"
:
NetworkEventActor
.
prototype
.
onGetResponseHeaders
"
getResponseCookies
"
:
NetworkEventActor
.
prototype
.
onGetResponseCookies
"
getResponseContent
"
:
NetworkEventActor
.
prototype
.
onGetResponseContent
"
getEventTimings
"
:
NetworkEventActor
.
prototype
.
onGetEventTimings
"
getSecurityInfo
"
:
NetworkEventActor
.
prototype
.
onGetSecurityInfo
"
getStackTrace
"
:
NetworkEventActor
.
prototype
.
onGetStackTrace
}
;
