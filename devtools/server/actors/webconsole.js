"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
{
DebuggerServer
ActorPool
}
=
require
(
"
devtools
/
server
/
main
"
)
;
const
{
EnvironmentActor
}
=
require
(
"
devtools
/
server
/
actors
/
environment
"
)
;
const
{
ThreadActor
}
=
require
(
"
devtools
/
server
/
actors
/
script
"
)
;
const
{
ObjectActor
LongStringActor
createValueGrip
stringIsLong
}
=
require
(
"
devtools
/
server
/
actors
/
object
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
ErrorDocs
=
require
(
"
devtools
/
server
/
actors
/
errordocs
"
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkMonitor
"
"
devtools
/
shared
/
webconsole
/
network
-
monitor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkMonitorChild
"
"
devtools
/
shared
/
webconsole
/
network
-
monitor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleProgressListener
"
"
devtools
/
shared
/
webconsole
/
network
-
monitor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
StackTraceCollector
"
"
devtools
/
shared
/
webconsole
/
network
-
monitor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
events
"
"
sdk
/
event
/
core
"
)
;
loader
.
lazyRequireGetter
(
this
"
ServerLoggingListener
"
"
devtools
/
shared
/
webconsole
/
server
-
logger
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
JSPropertyProvider
"
"
devtools
/
shared
/
webconsole
/
js
-
property
-
provider
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Parser
"
"
resource
:
/
/
devtools
/
shared
/
Parser
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
true
)
;
for
(
let
name
of
[
"
WebConsoleUtils
"
"
ConsoleServiceListener
"
"
ConsoleAPIListener
"
"
addWebConsoleCommands
"
"
ConsoleReflowListener
"
"
CONSOLE_WORKER_IDS
"
]
)
{
Object
.
defineProperty
(
this
name
{
get
:
function
(
prop
)
{
if
(
prop
=
=
"
WebConsoleUtils
"
)
{
prop
=
"
Utils
"
;
}
if
(
isWorker
)
{
return
require
(
"
devtools
/
server
/
actors
/
utils
/
webconsole
-
worker
-
utils
"
)
[
prop
]
;
}
else
{
return
require
(
"
devtools
/
server
/
actors
/
utils
/
webconsole
-
utils
"
)
[
prop
]
;
}
}
.
bind
(
null
name
)
configurable
:
true
enumerable
:
true
}
)
;
}
function
WebConsoleActor
(
aConnection
aParentActor
)
{
this
.
conn
=
aConnection
;
this
.
parentActor
=
aParentActor
;
this
.
_actorPool
=
new
ActorPool
(
this
.
conn
)
;
this
.
conn
.
addActorPool
(
this
.
_actorPool
)
;
this
.
_prefs
=
{
}
;
this
.
dbg
=
this
.
parentActor
.
makeDebugger
(
)
;
this
.
_netEvents
=
new
Map
(
)
;
this
.
_gripDepth
=
0
;
this
.
_listeners
=
new
Set
(
)
;
this
.
_lastConsoleInputEvaluation
=
undefined
;
this
.
objectGrip
=
this
.
objectGrip
.
bind
(
this
)
;
this
.
_onWillNavigate
=
this
.
_onWillNavigate
.
bind
(
this
)
;
this
.
_onChangedToplevelDocument
=
this
.
_onChangedToplevelDocument
.
bind
(
this
)
;
events
.
on
(
this
.
parentActor
"
changed
-
toplevel
-
document
"
this
.
_onChangedToplevelDocument
)
;
this
.
_onObserverNotification
=
this
.
_onObserverNotification
.
bind
(
this
)
;
if
(
this
.
parentActor
.
isRootActor
)
{
Services
.
obs
.
addObserver
(
this
.
_onObserverNotification
"
last
-
pb
-
context
-
exited
"
false
)
;
}
this
.
traits
=
{
customNetworkRequest
:
!
this
.
_parentIsContentActor
evaluateJSAsync
:
true
transferredResponseSize
:
true
selectedObjectActor
:
true
}
;
}
WebConsoleActor
.
prototype
=
{
dbg
:
null
_gripDepth
:
null
_actorPool
:
null
_prefs
:
null
_netEvents
:
null
_listeners
:
null
conn
:
null
traits
:
null
get
_parentIsContentActor
(
)
{
return
"
ContentActor
"
in
DebuggerServer
&
&
this
.
parentActor
instanceof
DebuggerServer
.
ContentActor
;
}
get
window
(
)
{
if
(
this
.
parentActor
.
isRootActor
)
{
return
this
.
_getWindowForBrowserConsole
(
)
;
}
return
this
.
parentActor
.
window
;
}
_getWindowForBrowserConsole
:
function
WCA__getWindowForBrowserConsole
(
)
{
let
window
=
this
.
_lastChromeWindow
&
&
this
.
_lastChromeWindow
.
get
(
)
;
if
(
!
window
|
|
window
.
closed
)
{
window
=
this
.
parentActor
.
window
;
if
(
!
window
)
{
window
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webconsole
"
)
;
let
onChromeWindowOpened
=
(
)
=
>
{
Services
.
obs
.
removeObserver
(
onChromeWindowOpened
"
domwindowopened
"
)
;
this
.
_lastChromeWindow
=
null
;
}
;
Services
.
obs
.
addObserver
(
onChromeWindowOpened
"
domwindowopened
"
false
)
;
}
this
.
_handleNewWindow
(
window
)
;
}
return
window
;
}
_handleNewWindow
:
function
WCA__handleNewWindow
(
window
)
{
if
(
window
)
{
if
(
this
.
_hadChromeWindow
)
{
Services
.
console
.
logStringMessage
(
'
Webconsole
context
has
changed
'
)
;
}
this
.
_lastChromeWindow
=
Cu
.
getWeakReference
(
window
)
;
this
.
_hadChromeWindow
=
true
;
}
else
{
this
.
_lastChromeWindow
=
null
;
}
}
_hadChromeWindow
:
false
_lastChromeWindow
:
null
_evalWindow
:
null
get
evalWindow
(
)
{
return
this
.
_evalWindow
|
|
this
.
window
;
}
set
evalWindow
(
aWindow
)
{
this
.
_evalWindow
=
aWindow
;
if
(
!
this
.
_progressListenerActive
)
{
events
.
on
(
this
.
parentActor
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_progressListenerActive
=
true
;
}
}
_progressListenerActive
:
false
consoleServiceListener
:
null
consoleAPIListener
:
null
networkMonitor
:
null
networkMonitorChild
:
null
consoleProgressListener
:
null
consoleReflowListener
:
null
_webConsoleCommandsCache
:
null
actorPrefix
:
"
console
"
get
globalDebugObject
(
)
{
return
this
.
parentActor
.
threadActor
.
globalDebugObject
;
}
grip
:
function
WCA_grip
(
)
{
return
{
actor
:
this
.
actorID
}
;
}
hasNativeConsoleAPI
:
function
WCA_hasNativeConsoleAPI
(
aWindow
)
{
let
isNative
=
false
;
try
{
let
console
=
aWindow
.
wrappedJSObject
.
console
;
isNative
=
new
XPCNativeWrapper
(
console
)
.
IS_NATIVE_CONSOLE
}
catch
(
ex
)
{
}
return
isNative
;
}
_findProtoChain
:
ThreadActor
.
prototype
.
_findProtoChain
_removeFromProtoChain
:
ThreadActor
.
prototype
.
_removeFromProtoChain
disconnect
:
function
WCA_disconnect
(
)
{
if
(
this
.
consoleServiceListener
)
{
this
.
consoleServiceListener
.
destroy
(
)
;
this
.
consoleServiceListener
=
null
;
}
if
(
this
.
consoleAPIListener
)
{
this
.
consoleAPIListener
.
destroy
(
)
;
this
.
consoleAPIListener
=
null
;
}
if
(
this
.
networkMonitor
)
{
this
.
networkMonitor
.
destroy
(
)
;
this
.
networkMonitor
=
null
;
}
if
(
this
.
networkMonitorChild
)
{
this
.
networkMonitorChild
.
destroy
(
)
;
this
.
networkMonitorChild
=
null
;
}
if
(
this
.
stackTraceCollector
)
{
this
.
stackTraceCollector
.
destroy
(
)
;
this
.
stackTraceCollector
=
null
;
}
if
(
this
.
consoleProgressListener
)
{
this
.
consoleProgressListener
.
destroy
(
)
;
this
.
consoleProgressListener
=
null
;
}
if
(
this
.
consoleReflowListener
)
{
this
.
consoleReflowListener
.
destroy
(
)
;
this
.
consoleReflowListener
=
null
;
}
if
(
this
.
serverLoggingListener
)
{
this
.
serverLoggingListener
.
destroy
(
)
;
this
.
serverLoggingListener
=
null
;
}
events
.
off
(
this
.
parentActor
"
changed
-
toplevel
-
document
"
this
.
_onChangedToplevelDocument
)
;
this
.
conn
.
removeActorPool
(
this
.
_actorPool
)
;
if
(
this
.
parentActor
.
isRootActor
)
{
Services
.
obs
.
removeObserver
(
this
.
_onObserverNotification
"
last
-
pb
-
context
-
exited
"
)
;
}
this
.
_actorPool
=
null
;
this
.
_webConsoleCommandsCache
=
null
;
this
.
_lastConsoleInputEvaluation
=
null
;
this
.
_evalWindow
=
null
;
this
.
_netEvents
.
clear
(
)
;
this
.
dbg
.
enabled
=
false
;
this
.
dbg
=
null
;
this
.
conn
=
null
;
}
createEnvironmentActor
:
function
WCA_createEnvironmentActor
(
aEnvironment
)
{
if
(
!
aEnvironment
)
{
return
undefined
;
}
if
(
aEnvironment
.
actor
)
{
return
aEnvironment
.
actor
;
}
let
actor
=
new
EnvironmentActor
(
aEnvironment
this
)
;
this
.
_actorPool
.
addActor
(
actor
)
;
aEnvironment
.
actor
=
actor
;
return
actor
;
}
createValueGrip
:
function
WCA_createValueGrip
(
aValue
)
{
return
createValueGrip
(
aValue
this
.
_actorPool
this
.
objectGrip
)
;
}
makeDebuggeeValue
:
function
WCA_makeDebuggeeValue
(
aValue
aUseObjectGlobal
)
{
if
(
aUseObjectGlobal
&
&
typeof
aValue
=
=
"
object
"
)
{
try
{
let
global
=
Cu
.
getGlobalForObject
(
aValue
)
;
let
dbgGlobal
=
this
.
dbg
.
makeGlobalObjectReference
(
global
)
;
return
dbgGlobal
.
makeDebuggeeValue
(
aValue
)
;
}
catch
(
ex
)
{
}
}
let
dbgGlobal
=
this
.
dbg
.
makeGlobalObjectReference
(
this
.
window
)
;
return
dbgGlobal
.
makeDebuggeeValue
(
aValue
)
;
}
objectGrip
:
function
WCA_objectGrip
(
aObject
aPool
)
{
let
actor
=
new
ObjectActor
(
aObject
{
getGripDepth
:
(
)
=
>
this
.
_gripDepth
incrementGripDepth
:
(
)
=
>
this
.
_gripDepth
+
+
decrementGripDepth
:
(
)
=
>
this
.
_gripDepth
-
-
createValueGrip
:
v
=
>
this
.
createValueGrip
(
v
)
sources
:
(
)
=
>
DevToolsUtils
.
reportException
(
"
WebConsoleActor
"
Error
(
"
sources
not
yet
implemented
"
)
)
createEnvironmentActor
:
(
env
)
=
>
this
.
createEnvironmentActor
(
env
)
getGlobalDebugObject
:
(
)
=
>
this
.
globalDebugObject
}
)
;
aPool
.
addActor
(
actor
)
;
return
actor
.
grip
(
)
;
}
longStringGrip
:
function
WCA_longStringGrip
(
aString
aPool
)
{
let
actor
=
new
LongStringActor
(
aString
)
;
aPool
.
addActor
(
actor
)
;
return
actor
.
grip
(
)
;
}
_createStringGrip
:
function
NEA__createStringGrip
(
aString
)
{
if
(
aString
&
&
stringIsLong
(
aString
)
)
{
return
this
.
longStringGrip
(
aString
this
.
_actorPool
)
;
}
return
aString
;
}
getActorByID
:
function
WCA_getActorByID
(
aActorID
)
{
return
this
.
_actorPool
.
get
(
aActorID
)
;
}
releaseActor
:
function
WCA_releaseActor
(
aActor
)
{
this
.
_actorPool
.
removeActor
(
aActor
.
actorID
)
;
}
getLastConsoleInputEvaluation
:
function
WCU_getLastConsoleInputEvaluation
(
)
{
return
this
.
_lastConsoleInputEvaluation
;
}
onStartListeners
:
function
WCA_onStartListeners
(
aRequest
)
{
if
(
isWorker
)
{
aRequest
.
listeners
=
[
]
;
}
let
startedListeners
=
[
]
;
let
window
=
!
this
.
parentActor
.
isRootActor
?
this
.
window
:
null
;
let
appId
=
null
;
let
messageManager
=
null
;
if
(
this
.
_parentIsContentActor
)
{
appId
=
this
.
parentActor
.
docShell
.
appId
;
messageManager
=
this
.
parentActor
.
messageManager
;
}
while
(
aRequest
.
listeners
.
length
>
0
)
{
let
listener
=
aRequest
.
listeners
.
shift
(
)
;
switch
(
listener
)
{
case
"
PageError
"
:
if
(
!
this
.
consoleServiceListener
)
{
this
.
consoleServiceListener
=
new
ConsoleServiceListener
(
window
this
)
;
this
.
consoleServiceListener
.
init
(
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
ConsoleAPI
"
:
if
(
!
this
.
consoleAPIListener
)
{
this
.
consoleAPIListener
=
new
ConsoleAPIListener
(
window
this
this
.
parentActor
.
consoleAPIListenerOptions
)
;
this
.
consoleAPIListener
.
init
(
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
NetworkActivity
"
:
if
(
!
this
.
networkMonitor
)
{
this
.
stackTraceCollector
=
new
StackTraceCollector
(
{
window
appId
}
)
;
this
.
stackTraceCollector
.
init
(
)
;
let
processBoundary
=
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
;
if
(
(
appId
|
|
messageManager
)
&
&
processBoundary
)
{
this
.
networkMonitor
=
new
NetworkMonitorChild
(
appId
this
.
parentActor
.
outerWindowID
messageManager
this
.
conn
this
)
;
this
.
networkMonitor
.
init
(
)
;
this
.
networkMonitorChild
=
new
NetworkMonitor
(
{
window
}
this
)
;
this
.
networkMonitorChild
.
init
(
)
;
}
else
{
this
.
networkMonitor
=
new
NetworkMonitor
(
{
window
}
this
)
;
this
.
networkMonitor
.
init
(
)
;
}
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
FileActivity
"
:
if
(
this
.
window
instanceof
Ci
.
nsIDOMWindow
)
{
if
(
!
this
.
consoleProgressListener
)
{
this
.
consoleProgressListener
=
new
ConsoleProgressListener
(
this
.
window
this
)
;
}
this
.
consoleProgressListener
.
startMonitor
(
this
.
consoleProgressListener
.
MONITOR_FILE_ACTIVITY
)
;
startedListeners
.
push
(
listener
)
;
}
break
;
case
"
ReflowActivity
"
:
if
(
!
this
.
consoleReflowListener
)
{
this
.
consoleReflowListener
=
new
ConsoleReflowListener
(
this
.
window
this
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
ServerLogging
"
:
if
(
!
this
.
serverLoggingListener
)
{
this
.
serverLoggingListener
=
new
ServerLoggingListener
(
this
.
window
this
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
}
}
startedListeners
.
forEach
(
this
.
_listeners
.
add
this
.
_listeners
)
;
return
{
startedListeners
:
startedListeners
nativeConsoleAPI
:
this
.
hasNativeConsoleAPI
(
this
.
window
)
traits
:
this
.
traits
}
;
}
onStopListeners
:
function
WCA_onStopListeners
(
aRequest
)
{
let
stoppedListeners
=
[
]
;
let
toDetach
=
aRequest
.
listeners
|
|
[
"
PageError
"
"
ConsoleAPI
"
"
NetworkActivity
"
"
FileActivity
"
"
ServerLogging
"
]
;
while
(
toDetach
.
length
>
0
)
{
let
listener
=
toDetach
.
shift
(
)
;
switch
(
listener
)
{
case
"
PageError
"
:
if
(
this
.
consoleServiceListener
)
{
this
.
consoleServiceListener
.
destroy
(
)
;
this
.
consoleServiceListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
ConsoleAPI
"
:
if
(
this
.
consoleAPIListener
)
{
this
.
consoleAPIListener
.
destroy
(
)
;
this
.
consoleAPIListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
NetworkActivity
"
:
if
(
this
.
networkMonitor
)
{
this
.
networkMonitor
.
destroy
(
)
;
this
.
networkMonitor
=
null
;
}
if
(
this
.
networkMonitorChild
)
{
this
.
networkMonitorChild
.
destroy
(
)
;
this
.
networkMonitorChild
=
null
;
}
if
(
this
.
stackTraceCollector
)
{
this
.
stackTraceCollector
.
destroy
(
)
;
this
.
stackTraceCollector
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
FileActivity
"
:
if
(
this
.
consoleProgressListener
)
{
this
.
consoleProgressListener
.
stopMonitor
(
this
.
consoleProgressListener
.
MONITOR_FILE_ACTIVITY
)
;
this
.
consoleProgressListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
ReflowActivity
"
:
if
(
this
.
consoleReflowListener
)
{
this
.
consoleReflowListener
.
destroy
(
)
;
this
.
consoleReflowListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
ServerLogging
"
:
if
(
this
.
serverLoggingListener
)
{
this
.
serverLoggingListener
.
destroy
(
)
;
this
.
serverLoggingListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
}
}
stoppedListeners
.
forEach
(
this
.
_listeners
.
delete
this
.
_listeners
)
;
return
{
stoppedListeners
:
stoppedListeners
}
;
}
onGetCachedMessages
:
function
WCA_onGetCachedMessages
(
aRequest
)
{
let
types
=
aRequest
.
messageTypes
;
if
(
!
types
)
{
return
{
error
:
"
missingParameter
"
message
:
"
The
messageTypes
parameter
is
missing
.
"
}
;
}
let
messages
=
[
]
;
while
(
types
.
length
>
0
)
{
let
type
=
types
.
shift
(
)
;
switch
(
type
)
{
case
"
ConsoleAPI
"
:
{
if
(
!
this
.
consoleAPIListener
)
{
break
;
}
let
requestStartTime
=
this
.
window
&
&
this
.
window
.
performance
?
this
.
window
.
performance
.
timing
.
requestStart
:
0
;
let
cache
=
this
.
consoleAPIListener
.
getCachedMessages
(
!
this
.
parentActor
.
isRootActor
)
;
cache
.
forEach
(
(
aMessage
)
=
>
{
if
(
aMessage
.
innerID
=
=
=
"
ServiceWorker
"
&
&
requestStartTime
>
aMessage
.
timeStamp
)
{
return
;
}
let
message
=
this
.
prepareConsoleMessageForRemote
(
aMessage
)
;
message
.
_type
=
type
;
messages
.
push
(
message
)
;
}
)
;
break
;
}
case
"
PageError
"
:
{
if
(
!
this
.
consoleServiceListener
)
{
break
;
}
let
cache
=
this
.
consoleServiceListener
.
getCachedMessages
(
!
this
.
parentActor
.
isRootActor
)
;
cache
.
forEach
(
(
aMessage
)
=
>
{
let
message
=
null
;
if
(
aMessage
instanceof
Ci
.
nsIScriptError
)
{
message
=
this
.
preparePageErrorForRemote
(
aMessage
)
;
message
.
_type
=
type
;
}
else
{
message
=
{
_type
:
"
LogMessage
"
message
:
this
.
_createStringGrip
(
aMessage
.
message
)
timeStamp
:
aMessage
.
timeStamp
}
;
}
messages
.
push
(
message
)
;
}
)
;
break
;
}
}
}
return
{
from
:
this
.
actorID
messages
:
messages
}
;
}
onEvaluateJSAsync
:
function
WCA_onEvaluateJSAsync
(
aRequest
)
{
let
resultID
=
Date
.
now
(
)
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
resultID
:
resultID
}
)
;
let
response
=
this
.
onEvaluateJS
(
aRequest
)
;
response
.
resultID
=
resultID
;
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
evaluationResult
"
response
)
;
}
onEvaluateJS
:
function
WCA_onEvaluateJS
(
aRequest
)
{
let
input
=
aRequest
.
text
;
let
timestamp
=
Date
.
now
(
)
;
let
evalOptions
=
{
bindObjectActor
:
aRequest
.
bindObjectActor
frameActor
:
aRequest
.
frameActor
url
:
aRequest
.
url
selectedNodeActor
:
aRequest
.
selectedNodeActor
selectedObjectActor
:
aRequest
.
selectedObjectActor
}
;
let
evalInfo
=
this
.
evalWithDebugger
(
input
evalOptions
)
;
let
evalResult
=
evalInfo
.
result
;
let
helperResult
=
evalInfo
.
helperResult
;
let
result
errorDocURL
errorMessage
errorGrip
=
null
;
if
(
evalResult
)
{
if
(
"
return
"
in
evalResult
)
{
result
=
evalResult
.
return
;
}
else
if
(
"
yield
"
in
evalResult
)
{
result
=
evalResult
.
yield
;
}
else
if
(
"
throw
"
in
evalResult
)
{
let
error
=
evalResult
.
throw
;
errorGrip
=
this
.
createValueGrip
(
error
)
;
let
unsafeDereference
=
error
&
&
(
typeof
error
=
=
=
"
object
"
)
&
&
error
.
unsafeDereference
(
)
;
errorMessage
=
unsafeDereference
&
&
unsafeDereference
.
toString
?
unsafeDereference
.
toString
(
)
:
String
(
error
)
;
try
{
errorDocURL
=
ErrorDocs
.
GetURL
(
error
)
;
}
catch
(
ex
)
{
}
}
}
let
resultGrip
;
try
{
resultGrip
=
this
.
createValueGrip
(
result
)
;
}
catch
(
e
)
{
errorMessage
=
e
;
}
this
.
_lastConsoleInputEvaluation
=
result
;
return
{
from
:
this
.
actorID
input
:
input
result
:
resultGrip
timestamp
:
timestamp
exception
:
errorGrip
exceptionMessage
:
this
.
_createStringGrip
(
errorMessage
)
exceptionDocURL
:
errorDocURL
helperResult
:
helperResult
}
;
}
onAutocomplete
:
function
WCA_onAutocomplete
(
aRequest
)
{
let
frameActorId
=
aRequest
.
frameActor
;
let
dbgObject
=
null
;
let
environment
=
null
;
let
hadDebuggee
=
false
;
if
(
frameActorId
)
{
let
frameActor
=
this
.
conn
.
getActor
(
frameActorId
)
;
try
{
let
frame
=
frameActor
.
frame
;
environment
=
frame
.
environment
;
}
catch
(
e
)
{
DevToolsUtils
.
reportException
(
"
onAutocomplete
"
Error
(
"
The
frame
actor
was
not
found
:
"
+
frameActorId
)
)
;
}
}
else
{
hadDebuggee
=
this
.
dbg
.
hasDebuggee
(
this
.
evalWindow
)
;
dbgObject
=
this
.
dbg
.
addDebuggee
(
this
.
evalWindow
)
;
}
let
result
=
JSPropertyProvider
(
dbgObject
environment
aRequest
.
text
aRequest
.
cursor
frameActorId
)
|
|
{
}
;
if
(
!
hadDebuggee
&
&
dbgObject
)
{
this
.
dbg
.
removeDebuggee
(
this
.
evalWindow
)
;
}
let
matches
=
result
.
matches
|
|
[
]
;
let
reqText
=
aRequest
.
text
.
substr
(
0
aRequest
.
cursor
)
;
let
lastNonAlphaIsDot
=
/
[
.
]
[
a
-
zA
-
Z0
-
9
]
*
/
.
test
(
reqText
)
;
if
(
!
lastNonAlphaIsDot
)
{
if
(
!
this
.
_webConsoleCommandsCache
)
{
let
helpers
=
{
sandbox
:
Object
.
create
(
null
)
}
;
addWebConsoleCommands
(
helpers
)
;
this
.
_webConsoleCommandsCache
=
Object
.
getOwnPropertyNames
(
helpers
.
sandbox
)
;
}
matches
=
matches
.
concat
(
this
.
_webConsoleCommandsCache
.
filter
(
n
=
>
n
.
startsWith
(
result
.
matchProp
)
)
)
;
}
return
{
from
:
this
.
actorID
matches
:
matches
.
sort
(
)
matchProp
:
result
.
matchProp
}
;
}
onClearMessagesCache
:
function
WCA_onClearMessagesCache
(
)
{
let
windowId
=
!
this
.
parentActor
.
isRootActor
?
WebConsoleUtils
.
getInnerWindowId
(
this
.
window
)
:
null
;
let
ConsoleAPIStorage
=
Cc
[
"
mozilla
.
org
/
consoleAPI
-
storage
;
1
"
]
.
getService
(
Ci
.
nsIConsoleAPIStorage
)
;
ConsoleAPIStorage
.
clearEvents
(
windowId
)
;
CONSOLE_WORKER_IDS
.
forEach
(
(
aId
)
=
>
{
ConsoleAPIStorage
.
clearEvents
(
aId
)
;
}
)
;
if
(
this
.
parentActor
.
isRootActor
)
{
Services
.
console
.
logStringMessage
(
null
)
;
Services
.
console
.
reset
(
)
;
}
return
{
}
;
}
onGetPreferences
:
function
WCA_onGetPreferences
(
aRequest
)
{
let
prefs
=
Object
.
create
(
null
)
;
for
(
let
key
of
aRequest
.
preferences
)
{
prefs
[
key
]
=
!
!
this
.
_prefs
[
key
]
;
}
return
{
preferences
:
prefs
}
;
}
onSetPreferences
:
function
WCA_onSetPreferences
(
aRequest
)
{
for
(
let
key
in
aRequest
.
preferences
)
{
this
.
_prefs
[
key
]
=
aRequest
.
preferences
[
key
]
;
if
(
this
.
networkMonitor
)
{
if
(
key
=
=
"
NetworkMonitor
.
saveRequestAndResponseBodies
"
)
{
this
.
networkMonitor
.
saveRequestAndResponseBodies
=
this
.
_prefs
[
key
]
;
if
(
this
.
networkMonitorChild
)
{
this
.
networkMonitorChild
.
saveRequestAndResponseBodies
=
this
.
_prefs
[
key
]
;
}
}
else
if
(
key
=
=
"
NetworkMonitor
.
throttleData
"
)
{
this
.
networkMonitor
.
throttleData
=
this
.
_prefs
[
key
]
;
if
(
this
.
networkMonitorChild
)
{
this
.
networkMonitorChild
.
throttleData
=
this
.
_prefs
[
key
]
;
}
}
}
}
return
{
updated
:
Object
.
keys
(
aRequest
.
preferences
)
}
;
}
_getWebConsoleCommands
:
function
(
aDebuggerGlobal
)
{
let
helpers
=
{
window
:
this
.
evalWindow
chromeWindow
:
this
.
chromeWindow
.
bind
(
this
)
makeDebuggeeValue
:
aDebuggerGlobal
.
makeDebuggeeValue
.
bind
(
aDebuggerGlobal
)
createValueGrip
:
this
.
createValueGrip
.
bind
(
this
)
sandbox
:
Object
.
create
(
null
)
helperResult
:
null
consoleActor
:
this
}
;
addWebConsoleCommands
(
helpers
)
;
let
evalWindow
=
this
.
evalWindow
;
function
maybeExport
(
obj
name
)
{
if
(
typeof
obj
[
name
]
!
=
"
function
"
)
{
return
;
}
obj
[
name
]
=
Cu
.
exportFunction
(
obj
[
name
]
evalWindow
{
allowCrossOriginArguments
:
true
}
)
;
}
for
(
let
name
in
helpers
.
sandbox
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
helpers
.
sandbox
name
)
;
if
(
!
isWorker
)
{
maybeExport
(
desc
"
get
"
)
;
maybeExport
(
desc
"
set
"
)
;
maybeExport
(
desc
"
value
"
)
;
}
if
(
desc
.
value
)
{
desc
.
value
=
aDebuggerGlobal
.
makeDebuggeeValue
(
desc
.
value
)
;
}
Object
.
defineProperty
(
helpers
.
sandbox
name
desc
)
;
}
return
helpers
;
}
evalWithDebugger
:
function
WCA_evalWithDebugger
(
aString
aOptions
=
{
}
)
{
let
trimmedString
=
aString
.
trim
(
)
;
if
(
trimmedString
=
=
"
help
"
|
|
trimmedString
=
=
"
?
"
)
{
aString
=
"
help
(
)
"
;
}
if
(
trimmedString
=
=
"
console
.
mihai
(
)
"
|
|
trimmedString
=
=
"
console
.
mihai
(
)
;
"
)
{
aString
=
"
\
"
http
:
/
/
incompleteness
.
me
/
blog
/
2015
/
02
/
09
/
console
-
dot
-
mihai
/
\
"
"
;
}
let
frame
=
null
frameActor
=
null
;
if
(
aOptions
.
frameActor
)
{
frameActor
=
this
.
conn
.
getActor
(
aOptions
.
frameActor
)
;
if
(
frameActor
)
{
frame
=
frameActor
.
frame
;
}
else
{
DevToolsUtils
.
reportException
(
"
evalWithDebugger
"
Error
(
"
The
frame
actor
was
not
found
:
"
+
aOptions
.
frameActor
)
)
;
}
}
let
dbg
=
frame
?
frameActor
.
threadActor
.
dbg
:
this
.
dbg
;
let
dbgWindow
=
dbg
.
makeGlobalObjectReference
(
this
.
evalWindow
)
;
let
bindSelf
=
null
;
if
(
aOptions
.
bindObjectActor
|
|
aOptions
.
selectedObjectActor
)
{
let
objActor
=
this
.
getActorByID
(
aOptions
.
bindObjectActor
|
|
aOptions
.
selectedObjectActor
)
;
if
(
objActor
)
{
let
jsObj
=
objActor
.
obj
.
unsafeDereference
(
)
;
let
global
=
Cu
.
getGlobalForObject
(
jsObj
)
;
let
_dbgWindow
=
dbg
.
makeGlobalObjectReference
(
global
)
;
bindSelf
=
dbgWindow
.
makeDebuggeeValue
(
jsObj
)
;
if
(
aOptions
.
bindObjectActor
)
{
dbgWindow
=
_dbgWindow
;
}
}
}
let
helpers
=
this
.
_getWebConsoleCommands
(
dbgWindow
)
;
let
bindings
=
helpers
.
sandbox
;
if
(
bindSelf
)
{
bindings
.
_self
=
bindSelf
;
}
if
(
aOptions
.
selectedNodeActor
)
{
let
actor
=
this
.
conn
.
getActor
(
aOptions
.
selectedNodeActor
)
;
if
(
actor
)
{
helpers
.
selectedNode
=
actor
.
rawNode
;
}
}
let
found
=
false
found
=
false
;
if
(
frame
)
{
let
env
=
frame
.
environment
;
if
(
env
)
{
found
=
!
!
env
.
find
(
"
"
)
;
found
=
!
!
env
.
find
(
"
"
)
;
}
}
else
{
found
=
!
!
dbgWindow
.
getOwnPropertyDescriptor
(
"
"
)
;
found
=
!
!
dbgWindow
.
getOwnPropertyDescriptor
(
"
"
)
;
}
let
=
null
=
null
;
if
(
found
)
{
=
bindings
.
;
delete
bindings
.
;
}
if
(
found
)
{
=
bindings
.
;
delete
bindings
.
;
}
helpers
.
evalInput
=
aString
;
let
evalOptions
;
if
(
typeof
aOptions
.
url
=
=
"
string
"
)
{
evalOptions
=
{
url
:
aOptions
.
url
}
;
}
if
(
this
.
_lastConsoleInputEvaluation
&
&
this
.
_lastConsoleInputEvaluation
.
global
!
=
=
dbgWindow
)
{
this
.
_lastConsoleInputEvaluation
=
dbg
.
adoptDebuggeeValue
(
this
.
_lastConsoleInputEvaluation
)
;
}
let
result
;
if
(
frame
)
{
result
=
frame
.
evalWithBindings
(
aString
bindings
evalOptions
)
;
}
else
{
result
=
dbgWindow
.
executeInGlobalWithBindings
(
aString
bindings
evalOptions
)
;
if
(
"
throw
"
in
result
)
{
let
ast
;
try
{
ast
=
Parser
.
reflectionAPI
.
parse
(
aString
)
;
}
catch
(
ex
)
{
ast
=
{
"
body
"
:
[
]
}
;
}
for
(
let
line
of
ast
.
body
)
{
if
(
!
(
line
.
kind
=
=
"
let
"
|
|
line
.
kind
=
=
"
const
"
)
)
continue
;
let
identifiers
=
[
]
;
for
(
let
decl
of
line
.
declarations
)
{
switch
(
decl
.
id
.
type
)
{
case
"
Identifier
"
:
identifiers
.
push
(
decl
.
id
.
name
)
;
break
;
case
"
ArrayPattern
"
:
for
(
let
e
of
decl
.
id
.
elements
)
{
if
(
e
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
e
.
name
)
;
}
else
if
(
e
.
type
=
=
"
AssignmentExpression
"
)
{
identifiers
.
push
(
e
.
left
.
name
)
;
}
}
break
;
case
"
ObjectPattern
"
:
for
(
let
prop
of
decl
.
id
.
properties
)
{
if
(
prop
.
key
.
type
=
=
"
Identifier
"
)
identifiers
.
push
(
prop
.
key
.
name
)
;
if
(
prop
.
value
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
prop
.
value
.
name
)
;
}
else
if
(
prop
.
value
.
type
=
=
"
AssignmentExpression
"
)
{
identifiers
.
push
(
prop
.
value
.
left
.
name
)
;
}
}
break
;
}
}
for
(
let
name
of
identifiers
)
dbgWindow
.
forceLexicalInitializationByName
(
name
)
;
}
}
}
let
helperResult
=
helpers
.
helperResult
;
delete
helpers
.
evalInput
;
delete
helpers
.
helperResult
;
delete
helpers
.
selectedNode
;
if
(
)
{
bindings
.
=
;
}
if
(
)
{
bindings
.
=
;
}
if
(
bindings
.
_self
)
{
delete
bindings
.
_self
;
}
return
{
result
:
result
helperResult
:
helperResult
dbg
:
dbg
frame
:
frame
window
:
dbgWindow
}
;
}
onConsoleServiceMessage
:
function
WCA_onConsoleServiceMessage
(
aMessage
)
{
let
packet
;
if
(
aMessage
instanceof
Ci
.
nsIScriptError
)
{
packet
=
{
from
:
this
.
actorID
type
:
"
pageError
"
pageError
:
this
.
preparePageErrorForRemote
(
aMessage
)
}
;
}
else
{
packet
=
{
from
:
this
.
actorID
type
:
"
logMessage
"
message
:
this
.
_createStringGrip
(
aMessage
.
message
)
timeStamp
:
aMessage
.
timeStamp
}
;
}
this
.
conn
.
send
(
packet
)
;
}
preparePageErrorForRemote
:
function
WCA_preparePageErrorForRemote
(
aPageError
)
{
let
stack
=
null
;
if
(
aPageError
.
stack
)
{
stack
=
[
]
;
let
s
=
aPageError
.
stack
;
while
(
s
!
=
=
null
)
{
stack
.
push
(
{
filename
:
s
.
source
lineNumber
:
s
.
line
columnNumber
:
s
.
column
functionName
:
s
.
functionDisplayName
}
)
;
s
=
s
.
parent
;
}
}
let
lineText
=
aPageError
.
sourceLine
;
if
(
lineText
&
&
lineText
.
length
>
DebuggerServer
.
LONG_STRING_INITIAL_LENGTH
)
{
lineText
=
lineText
.
substr
(
0
DebuggerServer
.
LONG_STRING_INITIAL_LENGTH
)
;
}
return
{
errorMessage
:
this
.
_createStringGrip
(
aPageError
.
errorMessage
)
errorMessageName
:
aPageError
.
errorMessageName
exceptionDocURL
:
ErrorDocs
.
GetURL
(
aPageError
)
sourceName
:
aPageError
.
sourceName
lineText
:
lineText
lineNumber
:
aPageError
.
lineNumber
columnNumber
:
aPageError
.
columnNumber
category
:
aPageError
.
category
timeStamp
:
aPageError
.
timeStamp
warning
:
!
!
(
aPageError
.
flags
&
aPageError
.
warningFlag
)
error
:
!
!
(
aPageError
.
flags
&
aPageError
.
errorFlag
)
exception
:
!
!
(
aPageError
.
flags
&
aPageError
.
exceptionFlag
)
strict
:
!
!
(
aPageError
.
flags
&
aPageError
.
strictFlag
)
info
:
!
!
(
aPageError
.
flags
&
aPageError
.
infoFlag
)
private
:
aPageError
.
isFromPrivateWindow
stacktrace
:
stack
}
;
}
onConsoleAPICall
:
function
WCA_onConsoleAPICall
(
aMessage
)
{
let
packet
=
{
from
:
this
.
actorID
type
:
"
consoleAPICall
"
message
:
this
.
prepareConsoleMessageForRemote
(
aMessage
)
}
;
this
.
conn
.
send
(
packet
)
;
}
onNetworkEvent
:
function
WCA_onNetworkEvent
(
aEvent
)
{
let
actor
=
this
.
getNetworkEventActor
(
aEvent
.
channelId
)
;
actor
.
init
(
aEvent
)
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEvent
"
eventActor
:
actor
.
grip
(
)
}
;
this
.
conn
.
send
(
packet
)
;
return
actor
;
}
getNetworkEventActor
:
function
WCA_getNetworkEventActor
(
channelId
)
{
let
actor
=
this
.
_netEvents
.
get
(
channelId
)
;
if
(
actor
)
{
this
.
_netEvents
.
delete
(
channelId
)
;
return
actor
;
}
actor
=
new
NetworkEventActor
(
this
)
;
this
.
_actorPool
.
addActor
(
actor
)
;
return
actor
;
}
onSendHTTPRequest
(
message
)
{
let
{
url
method
headers
body
}
=
message
.
request
;
let
doc
=
this
.
window
.
document
;
let
channel
=
NetUtil
.
newChannel
(
{
uri
:
NetUtil
.
newURI
(
url
)
loadingNode
:
doc
securityFlags
:
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_OTHER
}
)
;
channel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
channel
.
loadGroup
=
doc
.
documentLoadGroup
;
channel
.
loadFlags
|
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
|
Ci
.
nsIRequest
.
INHIBIT_CACHING
|
Ci
.
nsIRequest
.
LOAD_ANONYMOUS
;
channel
.
requestMethod
=
method
;
for
(
let
{
name
value
}
of
headers
)
{
channel
.
setRequestHeader
(
name
value
false
)
;
}
if
(
body
)
{
channel
.
QueryInterface
(
Ci
.
nsIUploadChannel2
)
;
let
bodyStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
bodyStream
.
setData
(
body
body
.
length
)
;
channel
.
explicitSetUploadStream
(
bodyStream
null
-
1
method
false
)
;
}
NetUtil
.
asyncFetch
(
channel
(
)
=
>
{
}
)
;
let
actor
=
this
.
getNetworkEventActor
(
channel
.
channelId
)
;
this
.
_netEvents
.
set
(
channel
.
channelId
actor
)
;
return
{
from
:
this
.
actorID
eventActor
:
actor
.
grip
(
)
}
;
}
onFileActivity
:
function
WCA_onFileActivity
(
aFileURI
)
{
let
packet
=
{
from
:
this
.
actorID
type
:
"
fileActivity
"
uri
:
aFileURI
}
;
this
.
conn
.
send
(
packet
)
;
}
onReflowActivity
:
function
WCA_onReflowActivity
(
aReflowInfo
)
{
let
packet
=
{
from
:
this
.
actorID
type
:
"
reflowActivity
"
interruptible
:
aReflowInfo
.
interruptible
start
:
aReflowInfo
.
start
end
:
aReflowInfo
.
end
sourceURL
:
aReflowInfo
.
sourceURL
sourceLine
:
aReflowInfo
.
sourceLine
functionName
:
aReflowInfo
.
functionName
}
;
this
.
conn
.
send
(
packet
)
;
}
onServerLogCall
:
function
WCA_onServerLogCall
(
aMessage
)
{
let
msg
=
Cu
.
cloneInto
(
aMessage
this
.
window
)
;
msg
=
this
.
prepareConsoleMessageForRemote
(
msg
false
)
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
serverLogCall
"
message
:
msg
}
;
this
.
conn
.
send
(
packet
)
;
}
prepareConsoleMessageForRemote
:
function
WCA_prepareConsoleMessageForRemote
(
aMessage
aUseObjectGlobal
=
true
)
{
let
result
=
WebConsoleUtils
.
cloneObject
(
aMessage
)
;
result
.
workerType
=
WebConsoleUtils
.
getWorkerType
(
result
)
|
|
"
none
"
;
delete
result
.
wrappedJSObject
;
delete
result
.
ID
;
delete
result
.
innerID
;
delete
result
.
consoleID
;
result
.
arguments
=
Array
.
map
(
aMessage
.
arguments
|
|
[
]
(
aObj
)
=
>
{
let
dbgObj
=
this
.
makeDebuggeeValue
(
aObj
aUseObjectGlobal
)
;
return
this
.
createValueGrip
(
dbgObj
)
;
}
)
;
result
.
styles
=
Array
.
map
(
aMessage
.
styles
|
|
[
]
(
aString
)
=
>
{
return
this
.
createValueGrip
(
aString
)
;
}
)
;
result
.
category
=
aMessage
.
category
|
|
"
webdev
"
;
return
result
;
}
chromeWindow
:
function
WCA_chromeWindow
(
)
{
let
window
=
null
;
try
{
window
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
chromeEventHandler
.
ownerDocument
.
defaultView
;
}
catch
(
ex
)
{
}
return
window
;
}
_onObserverNotification
:
function
WCA__onObserverNotification
(
aSubject
aTopic
)
{
switch
(
aTopic
)
{
case
"
last
-
pb
-
context
-
exited
"
:
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
lastPrivateContextExited
"
}
)
;
break
;
}
}
_onWillNavigate
:
function
WCA__onWillNavigate
(
{
window
isTopLevel
}
)
{
if
(
isTopLevel
)
{
this
.
_evalWindow
=
null
;
events
.
off
(
this
.
parentActor
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_progressListenerActive
=
false
;
}
}
_onChangedToplevelDocument
:
function
WCA__onChangedToplevelDocument
(
)
{
let
listeners
=
[
.
.
.
this
.
_listeners
]
;
this
.
onStopListeners
(
{
listeners
:
listeners
.
slice
(
)
}
)
;
this
.
onStartListeners
(
{
listeners
:
listeners
}
)
;
this
.
_lastChromeWindow
=
null
;
}
}
;
WebConsoleActor
.
prototype
.
requestTypes
=
{
startListeners
:
WebConsoleActor
.
prototype
.
onStartListeners
stopListeners
:
WebConsoleActor
.
prototype
.
onStopListeners
getCachedMessages
:
WebConsoleActor
.
prototype
.
onGetCachedMessages
evaluateJS
:
WebConsoleActor
.
prototype
.
onEvaluateJS
evaluateJSAsync
:
WebConsoleActor
.
prototype
.
onEvaluateJSAsync
autocomplete
:
WebConsoleActor
.
prototype
.
onAutocomplete
clearMessagesCache
:
WebConsoleActor
.
prototype
.
onClearMessagesCache
getPreferences
:
WebConsoleActor
.
prototype
.
onGetPreferences
setPreferences
:
WebConsoleActor
.
prototype
.
onSetPreferences
sendHTTPRequest
:
WebConsoleActor
.
prototype
.
onSendHTTPRequest
}
;
exports
.
WebConsoleActor
=
WebConsoleActor
;
function
NetworkEventActor
(
webConsoleActor
)
{
this
.
parent
=
webConsoleActor
;
this
.
conn
=
this
.
parent
.
conn
;
this
.
_request
=
{
method
:
null
url
:
null
httpVersion
:
null
headers
:
[
]
cookies
:
[
]
headersSize
:
null
postData
:
{
}
}
;
this
.
_response
=
{
headers
:
[
]
cookies
:
[
]
content
:
{
}
}
;
this
.
_timings
=
{
}
;
this
.
_longStringActors
=
new
Set
(
)
;
}
NetworkEventActor
.
prototype
=
{
_request
:
null
_response
:
null
_timings
:
null
_longStringActors
:
null
actorPrefix
:
"
netEvent
"
grip
:
function
NEA_grip
(
)
{
return
{
actor
:
this
.
actorID
startedDateTime
:
this
.
_startedDateTime
timeStamp
:
Date
.
parse
(
this
.
_startedDateTime
)
url
:
this
.
_request
.
url
method
:
this
.
_request
.
method
isXHR
:
this
.
_isXHR
cause
:
this
.
_cause
fromCache
:
this
.
_fromCache
fromServiceWorker
:
this
.
_fromServiceWorker
private
:
this
.
_private
}
;
}
release
:
function
NEA_release
(
)
{
for
(
let
grip
of
this
.
_longStringActors
)
{
let
actor
=
this
.
parent
.
getActorByID
(
grip
.
actor
)
;
if
(
actor
)
{
this
.
parent
.
releaseActor
(
actor
)
;
}
}
this
.
_longStringActors
=
new
Set
(
)
;
if
(
this
.
channel
)
{
this
.
parent
.
_netEvents
.
delete
(
this
.
channel
)
;
}
this
.
parent
.
releaseActor
(
this
)
;
}
onRelease
:
function
NEA_onRelease
(
)
{
this
.
release
(
)
;
return
{
}
;
}
init
:
function
NEA_init
(
aNetworkEvent
)
{
this
.
_startedDateTime
=
aNetworkEvent
.
startedDateTime
;
this
.
_isXHR
=
aNetworkEvent
.
isXHR
;
this
.
_cause
=
aNetworkEvent
.
cause
;
this
.
_fromCache
=
aNetworkEvent
.
fromCache
;
this
.
_fromServiceWorker
=
aNetworkEvent
.
fromServiceWorker
;
for
(
let
prop
of
[
"
method
"
"
url
"
"
httpVersion
"
"
headersSize
"
]
)
{
this
.
_request
[
prop
]
=
aNetworkEvent
[
prop
]
;
}
this
.
_discardRequestBody
=
aNetworkEvent
.
discardRequestBody
;
this
.
_discardResponseBody
=
aNetworkEvent
.
discardResponseBody
;
this
.
_private
=
aNetworkEvent
.
private
;
}
onGetRequestHeaders
:
function
NEA_onGetRequestHeaders
(
)
{
return
{
from
:
this
.
actorID
headers
:
this
.
_request
.
headers
headersSize
:
this
.
_request
.
headersSize
rawHeaders
:
this
.
_request
.
rawHeaders
}
;
}
onGetRequestCookies
:
function
NEA_onGetRequestCookies
(
)
{
return
{
from
:
this
.
actorID
cookies
:
this
.
_request
.
cookies
}
;
}
onGetRequestPostData
:
function
NEA_onGetRequestPostData
(
)
{
return
{
from
:
this
.
actorID
postData
:
this
.
_request
.
postData
postDataDiscarded
:
this
.
_discardRequestBody
}
;
}
onGetSecurityInfo
:
function
NEA_onGetSecurityInfo
(
)
{
return
{
from
:
this
.
actorID
securityInfo
:
this
.
_securityInfo
}
;
}
onGetResponseHeaders
:
function
NEA_onGetResponseHeaders
(
)
{
return
{
from
:
this
.
actorID
headers
:
this
.
_response
.
headers
headersSize
:
this
.
_response
.
headersSize
rawHeaders
:
this
.
_response
.
rawHeaders
}
;
}
onGetResponseCookies
:
function
NEA_onGetResponseCookies
(
)
{
return
{
from
:
this
.
actorID
cookies
:
this
.
_response
.
cookies
}
;
}
onGetResponseContent
:
function
NEA_onGetResponseContent
(
)
{
return
{
from
:
this
.
actorID
content
:
this
.
_response
.
content
contentDiscarded
:
this
.
_discardResponseBody
}
;
}
onGetEventTimings
:
function
NEA_onGetEventTimings
(
)
{
return
{
from
:
this
.
actorID
timings
:
this
.
_timings
totalTime
:
this
.
_totalTime
}
;
}
addRequestHeaders
:
function
NEA_addRequestHeaders
(
aHeaders
aRawHeaders
)
{
this
.
_request
.
headers
=
aHeaders
;
this
.
_prepareHeaders
(
aHeaders
)
;
var
rawHeaders
=
this
.
parent
.
_createStringGrip
(
aRawHeaders
)
;
if
(
typeof
rawHeaders
=
=
"
object
"
)
{
this
.
_longStringActors
.
add
(
rawHeaders
)
;
}
this
.
_request
.
rawHeaders
=
rawHeaders
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
requestHeaders
"
headers
:
aHeaders
.
length
headersSize
:
this
.
_request
.
headersSize
}
;
this
.
conn
.
send
(
packet
)
;
}
addRequestCookies
:
function
NEA_addRequestCookies
(
aCookies
)
{
this
.
_request
.
cookies
=
aCookies
;
this
.
_prepareHeaders
(
aCookies
)
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
requestCookies
"
cookies
:
aCookies
.
length
}
;
this
.
conn
.
send
(
packet
)
;
}
addRequestPostData
:
function
NEA_addRequestPostData
(
aPostData
)
{
this
.
_request
.
postData
=
aPostData
;
aPostData
.
text
=
this
.
parent
.
_createStringGrip
(
aPostData
.
text
)
;
if
(
typeof
aPostData
.
text
=
=
"
object
"
)
{
this
.
_longStringActors
.
add
(
aPostData
.
text
)
;
}
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
requestPostData
"
dataSize
:
aPostData
.
text
.
length
discardRequestBody
:
this
.
_discardRequestBody
}
;
this
.
conn
.
send
(
packet
)
;
}
addResponseStart
:
function
NEA_addResponseStart
(
aInfo
aRawHeaders
)
{
var
rawHeaders
=
this
.
parent
.
_createStringGrip
(
aRawHeaders
)
;
if
(
typeof
rawHeaders
=
=
"
object
"
)
{
this
.
_longStringActors
.
add
(
rawHeaders
)
;
}
this
.
_response
.
rawHeaders
=
rawHeaders
;
this
.
_response
.
httpVersion
=
aInfo
.
httpVersion
;
this
.
_response
.
status
=
aInfo
.
status
;
this
.
_response
.
statusText
=
aInfo
.
statusText
;
this
.
_response
.
headersSize
=
aInfo
.
headersSize
;
this
.
_discardResponseBody
=
aInfo
.
discardResponseBody
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
responseStart
"
response
:
aInfo
}
;
this
.
conn
.
send
(
packet
)
;
}
addSecurityInfo
:
function
NEA_addSecurityInfo
(
info
)
{
this
.
_securityInfo
=
info
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
securityInfo
"
state
:
info
.
state
}
;
this
.
conn
.
send
(
packet
)
;
}
addResponseHeaders
:
function
NEA_addResponseHeaders
(
aHeaders
)
{
this
.
_response
.
headers
=
aHeaders
;
this
.
_prepareHeaders
(
aHeaders
)
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
responseHeaders
"
headers
:
aHeaders
.
length
headersSize
:
this
.
_response
.
headersSize
}
;
this
.
conn
.
send
(
packet
)
;
}
addResponseCookies
:
function
NEA_addResponseCookies
(
aCookies
)
{
this
.
_response
.
cookies
=
aCookies
;
this
.
_prepareHeaders
(
aCookies
)
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
responseCookies
"
cookies
:
aCookies
.
length
}
;
this
.
conn
.
send
(
packet
)
;
}
addResponseContent
:
function
NEA_addResponseContent
(
aContent
aDiscardedResponseBody
)
{
this
.
_response
.
content
=
aContent
;
aContent
.
text
=
this
.
parent
.
_createStringGrip
(
aContent
.
text
)
;
if
(
typeof
aContent
.
text
=
=
"
object
"
)
{
this
.
_longStringActors
.
add
(
aContent
.
text
)
;
}
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
responseContent
"
mimeType
:
aContent
.
mimeType
contentSize
:
aContent
.
size
encoding
:
aContent
.
encoding
transferredSize
:
aContent
.
transferredSize
discardResponseBody
:
aDiscardedResponseBody
}
;
this
.
conn
.
send
(
packet
)
;
}
addEventTimings
:
function
NEA_addEventTimings
(
aTotal
aTimings
)
{
this
.
_totalTime
=
aTotal
;
this
.
_timings
=
aTimings
;
let
packet
=
{
from
:
this
.
actorID
type
:
"
networkEventUpdate
"
updateType
:
"
eventTimings
"
totalTime
:
aTotal
}
;
this
.
conn
.
send
(
packet
)
;
}
_prepareHeaders
:
function
NEA__prepareHeaders
(
aHeaders
)
{
for
(
let
header
of
aHeaders
)
{
header
.
value
=
this
.
parent
.
_createStringGrip
(
header
.
value
)
;
if
(
typeof
header
.
value
=
=
"
object
"
)
{
this
.
_longStringActors
.
add
(
header
.
value
)
;
}
}
}
}
;
NetworkEventActor
.
prototype
.
requestTypes
=
{
"
release
"
:
NetworkEventActor
.
prototype
.
onRelease
"
getRequestHeaders
"
:
NetworkEventActor
.
prototype
.
onGetRequestHeaders
"
getRequestCookies
"
:
NetworkEventActor
.
prototype
.
onGetRequestCookies
"
getRequestPostData
"
:
NetworkEventActor
.
prototype
.
onGetRequestPostData
"
getResponseHeaders
"
:
NetworkEventActor
.
prototype
.
onGetResponseHeaders
"
getResponseCookies
"
:
NetworkEventActor
.
prototype
.
onGetResponseCookies
"
getResponseContent
"
:
NetworkEventActor
.
prototype
.
onGetResponseContent
"
getEventTimings
"
:
NetworkEventActor
.
prototype
.
onGetEventTimings
"
getSecurityInfo
"
:
NetworkEventActor
.
prototype
.
onGetSecurityInfo
}
;
