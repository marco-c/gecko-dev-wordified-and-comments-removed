"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
webconsoleSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
webconsole
.
js
"
)
;
const
{
DevToolsServer
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
devtools
-
server
.
js
"
)
;
const
{
ThreadActor
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
thread
.
js
"
)
;
const
{
ObjectActor
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
object
.
js
"
)
;
const
{
LongStringActor
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
string
.
js
"
)
;
const
{
createValueGrip
isArray
stringIsLong
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
utils
.
js
"
)
;
const
DevToolsUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
ErrorDocs
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
errordocs
.
js
"
)
;
const
Targets
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
index
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
evalWithDebugger
"
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
eval
-
with
-
debugger
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleFileActivityListener
"
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
listeners
/
console
-
file
-
activity
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
JSPropertyProvider
"
"
resource
:
/
/
devtools
/
shared
/
webconsole
/
js
-
property
-
provider
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
isCommand
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
commands
/
parser
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
CONSOLE_WORKER_IDS
"
"
WebConsoleUtils
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
utils
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
addWebConsoleCommands
"
"
validCommands
"
"
WebConsoleCommandsManager
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
commands
/
manager
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EnvironmentActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
environment
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
MESSAGE_CATEGORY
"
"
resource
:
/
/
devtools
/
shared
/
constants
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
RESERVED_JS_KEYWORDS
"
"
resource
:
/
/
devtools
/
shared
/
webconsole
/
reserved
-
js
-
words
.
js
"
)
;
if
(
isWorker
)
{
loader
.
lazyRequireGetter
(
this
[
"
ConsoleAPIListener
"
"
ConsoleServiceListener
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
worker
-
listeners
.
js
"
true
)
;
}
else
{
loader
.
lazyRequireGetter
(
this
"
ConsoleAPIListener
"
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
listeners
/
console
-
api
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleServiceListener
"
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
listeners
/
console
-
service
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleReflowListener
"
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
listeners
/
console
-
reflow
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DocumentEventsListener
"
"
resource
:
/
/
devtools
/
server
/
actors
/
webconsole
/
listeners
/
document
-
events
.
js
"
true
)
;
}
loader
.
lazyRequireGetter
(
this
"
ObjectUtils
"
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
utils
.
js
"
)
;
function
isObject
(
value
)
{
return
Object
(
value
)
=
=
=
value
;
}
class
WebConsoleActor
extends
Actor
{
constructor
(
connection
parentActor
)
{
super
(
connection
webconsoleSpec
)
;
this
.
parentActor
=
parentActor
;
this
.
dbg
=
this
.
parentActor
.
dbg
;
this
.
_gripDepth
=
0
;
this
.
_evalCounter
=
0
;
this
.
_listeners
=
new
Set
(
)
;
this
.
_lastConsoleInputEvaluation
=
undefined
;
this
.
objectGrip
=
this
.
objectGrip
.
bind
(
this
)
;
this
.
_onWillNavigate
=
this
.
_onWillNavigate
.
bind
(
this
)
;
this
.
_onChangedToplevelDocument
=
this
.
_onChangedToplevelDocument
.
bind
(
this
)
;
this
.
onConsoleServiceMessage
=
this
.
onConsoleServiceMessage
.
bind
(
this
)
;
this
.
onConsoleAPICall
=
this
.
onConsoleAPICall
.
bind
(
this
)
;
this
.
onDocumentEvent
=
this
.
onDocumentEvent
.
bind
(
this
)
;
EventEmitter
.
on
(
this
.
parentActor
"
changed
-
toplevel
-
document
"
this
.
_onChangedToplevelDocument
)
;
}
dbg
=
null
;
_gripDepth
=
null
;
_listeners
=
null
;
get
global
(
)
{
if
(
this
.
parentActor
.
isRootActor
)
{
return
this
.
_getWindowForBrowserConsole
(
)
;
}
return
this
.
parentActor
.
window
|
|
this
.
parentActor
.
workerGlobal
;
}
_getWindowForBrowserConsole
(
)
{
let
window
=
this
.
_lastChromeWindow
&
&
this
.
_lastChromeWindow
.
get
(
)
;
if
(
!
window
|
|
Cu
.
isDeadWrapper
(
window
)
|
|
window
.
closed
)
{
window
=
this
.
parentActor
.
window
;
if
(
!
window
)
{
window
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webconsole
"
)
;
const
onChromeWindowOpened
=
(
)
=
>
{
Services
.
obs
.
removeObserver
(
onChromeWindowOpened
"
domwindowopened
"
)
;
this
.
_lastChromeWindow
=
null
;
}
;
Services
.
obs
.
addObserver
(
onChromeWindowOpened
"
domwindowopened
"
)
;
}
this
.
_handleNewWindow
(
window
)
;
}
return
window
;
}
_handleNewWindow
(
window
)
{
if
(
window
)
{
if
(
this
.
_hadChromeWindow
)
{
Services
.
console
.
logStringMessage
(
"
Webconsole
context
has
changed
"
)
;
}
this
.
_lastChromeWindow
=
Cu
.
getWeakReference
(
window
)
;
this
.
_hadChromeWindow
=
true
;
}
else
{
this
.
_lastChromeWindow
=
null
;
}
}
_hadChromeWindow
=
false
;
_lastChromeWindow
=
null
;
_evalGlobal
=
null
;
get
evalGlobal
(
)
{
return
this
.
_evalGlobal
|
|
this
.
global
;
}
set
evalGlobal
(
global
)
{
this
.
_evalGlobal
=
global
;
if
(
!
this
.
_progressListenerActive
)
{
EventEmitter
.
on
(
this
.
parentActor
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_progressListenerActive
=
true
;
}
}
_progressListenerActive
=
false
;
consoleServiceListener
=
null
;
consoleAPIListener
=
null
;
consoleFileActivityListener
=
null
;
consoleReflowListener
=
null
;
grip
(
)
{
return
{
actor
:
this
.
actorID
}
;
}
_findProtoChain
=
ThreadActor
.
prototype
.
_findProtoChain
;
_removeFromProtoChain
=
ThreadActor
.
prototype
.
_removeFromProtoChain
;
destroy
(
)
{
this
.
stopListeners
(
)
;
super
.
destroy
(
)
;
EventEmitter
.
off
(
this
.
parentActor
"
changed
-
toplevel
-
document
"
this
.
_onChangedToplevelDocument
)
;
this
.
_lastConsoleInputEvaluation
=
null
;
this
.
_evalGlobal
=
null
;
this
.
dbg
=
null
;
}
createEnvironmentActor
(
environment
)
{
if
(
!
environment
)
{
return
undefined
;
}
if
(
environment
.
actor
)
{
return
environment
.
actor
;
}
const
actor
=
new
EnvironmentActor
(
environment
this
)
;
this
.
manage
(
actor
)
;
environment
.
actor
=
actor
;
return
actor
;
}
createValueGrip
(
value
)
{
return
createValueGrip
(
value
this
this
.
objectGrip
)
;
}
makeDebuggeeValue
(
value
useObjectGlobal
)
{
if
(
useObjectGlobal
&
&
isObject
(
value
)
)
{
try
{
const
global
=
Cu
.
getGlobalForObject
(
value
)
;
const
dbgGlobal
=
this
.
dbg
.
makeGlobalObjectReference
(
global
)
;
return
dbgGlobal
.
makeDebuggeeValue
(
value
)
;
}
catch
(
ex
)
{
}
}
const
dbgGlobal
=
this
.
dbg
.
makeGlobalObjectReference
(
this
.
global
)
;
return
dbgGlobal
.
makeDebuggeeValue
(
value
)
;
}
objectGrip
(
object
pool
)
{
const
actor
=
new
ObjectActor
(
object
{
thread
:
this
.
parentActor
.
threadActor
getGripDepth
:
(
)
=
>
this
.
_gripDepth
incrementGripDepth
:
(
)
=
>
this
.
_gripDepth
+
+
decrementGripDepth
:
(
)
=
>
this
.
_gripDepth
-
-
createValueGrip
:
v
=
>
this
.
createValueGrip
(
v
)
createEnvironmentActor
:
env
=
>
this
.
createEnvironmentActor
(
env
)
}
this
.
conn
)
;
pool
.
manage
(
actor
)
;
return
actor
.
form
(
)
;
}
longStringGrip
(
string
pool
)
{
const
actor
=
new
LongStringActor
(
this
.
conn
string
)
;
pool
.
manage
(
actor
)
;
return
actor
.
form
(
)
;
}
_createStringGrip
(
string
)
{
if
(
string
&
&
stringIsLong
(
string
)
)
{
return
this
.
longStringGrip
(
string
this
)
;
}
return
string
;
}
getLastConsoleInputEvaluation
(
)
{
return
this
.
_lastConsoleInputEvaluation
;
}
preprocessDebuggerObject
(
dbgObj
)
{
if
(
dbgObj
?
.
isBoundFunction
&
&
dbgObj
?
.
boundTargetFunction
)
{
return
dbgObj
.
boundTargetFunction
;
}
return
dbgObj
;
}
inspectObject
(
dbgObj
inspectFromAnnotation
)
{
dbgObj
=
this
.
preprocessDebuggerObject
(
dbgObj
)
;
this
.
emit
(
"
inspectObject
"
{
objectActor
:
this
.
createValueGrip
(
dbgObj
)
inspectFromAnnotation
}
)
;
}
async
startListeners
(
listeners
)
{
const
startedListeners
=
[
]
;
const
global
=
!
this
.
parentActor
.
isRootActor
?
this
.
global
:
null
;
const
isTargetActorContentProcess
=
this
.
parentActor
.
targetType
=
=
=
Targets
.
TYPES
.
PROCESS
;
for
(
const
event
of
listeners
)
{
switch
(
event
)
{
case
"
PageError
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
consoleServiceListener
)
{
this
.
consoleServiceListener
=
new
ConsoleServiceListener
(
global
this
.
onConsoleServiceMessage
{
matchExactWindow
:
this
.
parentActor
.
ignoreSubFrames
}
)
;
this
.
consoleServiceListener
.
init
(
)
;
}
startedListeners
.
push
(
event
)
;
break
;
case
"
ConsoleAPI
"
:
if
(
!
this
.
consoleAPIListener
)
{
this
.
consoleAPIListener
=
new
ConsoleAPIListener
(
global
this
.
onConsoleAPICall
{
matchExactWindow
:
this
.
parentActor
.
ignoreSubFrames
.
.
.
(
this
.
parentActor
.
consoleAPIListenerOptions
|
|
{
}
)
}
)
;
this
.
consoleAPIListener
.
init
(
)
;
}
startedListeners
.
push
(
event
)
;
break
;
case
"
NetworkActivity
"
:
if
(
isWorker
)
{
break
;
}
const
errorMessage
=
"
NetworkActivity
is
no
longer
supported
.
"
+
"
Instead
use
Watcher
actor
'
s
watchResources
and
listen
to
NETWORK_EVENT
resource
"
;
dump
(
errorMessage
+
"
\
n
"
)
;
throw
new
Error
(
errorMessage
)
;
case
"
FileActivity
"
:
if
(
isWorker
)
{
break
;
}
if
(
this
.
global
instanceof
Ci
.
nsIDOMWindow
)
{
if
(
!
this
.
consoleFileActivityListener
)
{
this
.
consoleFileActivityListener
=
new
ConsoleFileActivityListener
(
this
.
global
this
)
;
}
this
.
consoleFileActivityListener
.
startMonitor
(
)
;
startedListeners
.
push
(
event
)
;
}
break
;
case
"
ReflowActivity
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
consoleReflowListener
)
{
this
.
consoleReflowListener
=
new
ConsoleReflowListener
(
this
.
global
this
)
;
}
startedListeners
.
push
(
event
)
;
break
;
case
"
DocumentEvents
"
:
if
(
isWorker
|
|
isTargetActorContentProcess
)
{
break
;
}
if
(
!
this
.
documentEventsListener
)
{
this
.
documentEventsListener
=
new
DocumentEventsListener
(
this
.
parentActor
)
;
this
.
documentEventsListener
.
on
(
"
dom
-
loading
"
data
=
>
this
.
onDocumentEvent
(
"
dom
-
loading
"
data
)
)
;
this
.
documentEventsListener
.
on
(
"
dom
-
interactive
"
data
=
>
this
.
onDocumentEvent
(
"
dom
-
interactive
"
data
)
)
;
this
.
documentEventsListener
.
on
(
"
dom
-
complete
"
data
=
>
this
.
onDocumentEvent
(
"
dom
-
complete
"
data
)
)
;
this
.
documentEventsListener
.
listen
(
)
;
}
startedListeners
.
push
(
event
)
;
break
;
}
}
startedListeners
.
forEach
(
this
.
_listeners
.
add
this
.
_listeners
)
;
return
{
startedListeners
}
;
}
stopListeners
(
listeners
)
{
const
stoppedListeners
=
[
]
;
const
eventsToDetach
=
listeners
|
|
[
"
PageError
"
"
ConsoleAPI
"
"
FileActivity
"
"
ReflowActivity
"
"
DocumentEvents
"
]
;
for
(
const
event
of
eventsToDetach
)
{
switch
(
event
)
{
case
"
PageError
"
:
if
(
this
.
consoleServiceListener
)
{
this
.
consoleServiceListener
.
destroy
(
)
;
this
.
consoleServiceListener
=
null
;
}
stoppedListeners
.
push
(
event
)
;
break
;
case
"
ConsoleAPI
"
:
if
(
this
.
consoleAPIListener
)
{
this
.
consoleAPIListener
.
destroy
(
)
;
this
.
consoleAPIListener
=
null
;
}
stoppedListeners
.
push
(
event
)
;
break
;
case
"
FileActivity
"
:
if
(
this
.
consoleFileActivityListener
)
{
this
.
consoleFileActivityListener
.
stopMonitor
(
)
;
this
.
consoleFileActivityListener
=
null
;
}
stoppedListeners
.
push
(
event
)
;
break
;
case
"
ReflowActivity
"
:
if
(
this
.
consoleReflowListener
)
{
this
.
consoleReflowListener
.
destroy
(
)
;
this
.
consoleReflowListener
=
null
;
}
stoppedListeners
.
push
(
event
)
;
break
;
case
"
DocumentEvents
"
:
if
(
this
.
documentEventsListener
)
{
this
.
documentEventsListener
.
destroy
(
)
;
this
.
documentEventsListener
=
null
;
}
stoppedListeners
.
push
(
event
)
;
break
;
}
}
stoppedListeners
.
forEach
(
this
.
_listeners
.
delete
this
.
_listeners
)
;
return
{
stoppedListeners
}
;
}
getCachedMessages
(
messageTypes
)
{
if
(
!
messageTypes
)
{
return
{
error
:
"
missingParameter
"
message
:
"
The
messageTypes
parameter
is
missing
.
"
}
;
}
const
messages
=
[
]
;
const
consoleServiceCachedMessages
=
messageTypes
.
includes
(
"
PageError
"
)
|
|
messageTypes
.
includes
(
"
LogMessage
"
)
?
this
.
consoleServiceListener
?
.
getCachedMessages
(
!
this
.
parentActor
.
isRootActor
)
:
null
;
for
(
const
type
of
messageTypes
)
{
switch
(
type
)
{
case
"
ConsoleAPI
"
:
{
if
(
!
this
.
consoleAPIListener
)
{
break
;
}
const
winStartTime
=
this
.
global
?
.
performance
?
.
timing
?
.
navigationStart
;
const
cache
=
this
.
consoleAPIListener
.
getCachedMessages
(
!
this
.
parentActor
.
isRootActor
)
;
cache
.
forEach
(
cachedMessage
=
>
{
if
(
cachedMessage
.
innerID
=
=
=
"
ServiceWorker
"
&
&
winStartTime
>
cachedMessage
.
timeStamp
)
{
return
;
}
messages
.
push
(
{
message
:
this
.
prepareConsoleMessageForRemote
(
cachedMessage
)
type
:
"
consoleAPICall
"
}
)
;
}
)
;
break
;
}
case
"
PageError
"
:
{
if
(
!
consoleServiceCachedMessages
)
{
break
;
}
for
(
const
cachedMessage
of
consoleServiceCachedMessages
)
{
if
(
!
(
cachedMessage
instanceof
Ci
.
nsIScriptError
)
)
{
continue
;
}
messages
.
push
(
{
pageError
:
this
.
preparePageErrorForRemote
(
cachedMessage
)
type
:
"
pageError
"
}
)
;
}
break
;
}
case
"
LogMessage
"
:
{
if
(
!
consoleServiceCachedMessages
)
{
break
;
}
for
(
const
cachedMessage
of
consoleServiceCachedMessages
)
{
if
(
cachedMessage
instanceof
Ci
.
nsIScriptError
)
{
continue
;
}
messages
.
push
(
{
message
:
this
.
_createStringGrip
(
cachedMessage
.
message
)
timeStamp
:
cachedMessage
.
microSecondTimeStamp
/
1000
type
:
"
logMessage
"
}
)
;
}
break
;
}
}
}
return
{
messages
}
;
}
async
evaluateJSAsync
(
request
)
{
const
startTime
=
ChromeUtils
.
dateNow
(
)
;
const
resultID
=
startTime
+
"
-
"
+
this
.
_evalCounter
+
+
;
DevToolsUtils
.
executeSoonWithMicroTask
(
async
(
)
=
>
{
try
{
let
response
=
await
this
.
evaluateJS
(
request
)
;
response
=
await
this
.
_maybeWaitForResponseResult
(
response
)
;
response
.
timestamp
=
ChromeUtils
.
dateNow
(
)
;
this
.
emit
(
"
evaluationResult
"
{
type
:
"
evaluationResult
"
resultID
startTime
.
.
.
response
}
)
;
return
;
}
catch
(
e
)
{
const
message
=
Encountered
error
while
waiting
for
Helper
Result
:
{
e
}
\
n
{
e
.
stack
}
;
DevToolsUtils
.
reportException
(
"
evaluateJSAsync
"
Error
(
message
)
)
;
}
}
)
;
return
{
resultID
}
;
}
async
_maybeWaitForResponseResult
(
response
)
{
if
(
!
response
)
{
return
response
;
}
const
thenable
=
obj
=
>
obj
&
&
typeof
obj
.
then
=
=
=
"
function
"
;
const
waitForHelperResult
=
response
.
helperResult
&
&
thenable
(
response
.
helperResult
)
;
const
waitForAwaitResult
=
response
.
awaitResult
&
&
thenable
(
response
.
awaitResult
)
;
if
(
!
waitForAwaitResult
&
&
!
waitForHelperResult
)
{
return
response
;
}
if
(
waitForHelperResult
)
{
response
.
helperResult
=
await
response
.
helperResult
;
}
else
if
(
waitForAwaitResult
)
{
let
result
;
try
{
result
=
await
response
.
awaitResult
;
const
dbgResult
=
this
.
makeDebuggeeValue
(
result
)
;
response
.
result
=
this
.
createValueGrip
(
dbgResult
)
;
}
catch
(
e
)
{
response
.
topLevelAwaitRejected
=
true
;
}
delete
response
.
awaitResult
;
}
return
response
;
}
evaluateJS
(
request
)
{
const
input
=
request
.
text
;
const
evalOptions
=
{
frameActor
:
request
.
frameActor
url
:
request
.
url
innerWindowID
:
request
.
innerWindowID
selectedNodeActor
:
request
.
selectedNodeActor
selectedObjectActor
:
request
.
selectedObjectActor
eager
:
request
.
eager
bindings
:
request
.
bindings
lineNumber
:
request
.
lineNumber
}
;
const
{
mapped
}
=
request
;
this
.
parentActor
.
threadActor
.
insideClientEvaluation
=
evalOptions
;
const
evalInfo
=
evalWithDebugger
(
input
evalOptions
this
)
;
this
.
parentActor
.
threadActor
.
insideClientEvaluation
=
null
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
try
{
const
result
=
this
.
prepareEvaluationResult
(
evalInfo
input
request
.
eager
mapped
)
;
resolve
(
result
)
;
}
catch
(
err
)
{
reject
(
err
)
;
}
}
)
;
}
)
;
}
prepareEvaluationResult
(
evalInfo
input
eager
mapped
)
{
const
evalResult
=
evalInfo
.
result
;
const
helperResult
=
evalInfo
.
helperResult
;
let
result
errorDocURL
errorMessage
errorNotes
=
null
errorGrip
=
null
frame
=
null
awaitResult
errorMessageName
exceptionStack
;
if
(
evalResult
)
{
if
(
"
return
"
in
evalResult
)
{
result
=
evalResult
.
return
;
if
(
mapped
?
.
await
&
&
result
&
&
result
.
class
=
=
=
"
Promise
"
&
&
typeof
result
.
unsafeDereference
=
=
=
"
function
"
)
{
awaitResult
=
result
.
unsafeDereference
(
)
;
}
}
else
if
(
"
yield
"
in
evalResult
)
{
result
=
evalResult
.
yield
;
}
else
if
(
"
throw
"
in
evalResult
)
{
const
error
=
evalResult
.
throw
;
errorGrip
=
this
.
createValueGrip
(
error
)
;
exceptionStack
=
this
.
prepareStackForRemote
(
evalResult
.
stack
)
;
if
(
exceptionStack
)
{
const
{
filename
:
source
sourceId
lineNumber
:
line
columnNumber
:
column
}
=
exceptionStack
[
0
]
;
frame
=
{
source
sourceId
line
column
}
;
exceptionStack
=
WebConsoleUtils
.
removeFramesAboveDebuggerEval
(
exceptionStack
)
;
}
errorMessage
=
String
(
error
)
;
if
(
typeof
error
=
=
=
"
object
"
&
&
error
!
=
=
null
)
{
try
{
errorMessage
=
DevToolsUtils
.
callPropertyOnObject
(
error
"
toString
"
)
;
}
catch
(
e
)
{
if
(
typeof
error
.
unsafeDereference
=
=
=
"
function
"
)
{
const
rawError
=
error
.
unsafeDereference
(
)
;
errorMessage
=
rawError
?
rawError
.
toString
(
)
:
"
"
;
}
}
}
try
{
errorDocURL
=
ErrorDocs
.
GetURL
(
error
)
;
errorMessageName
=
error
.
errorMessageName
;
}
catch
(
ex
)
{
}
try
{
const
line
=
error
.
errorLineNumber
;
const
column
=
error
.
errorColumnNumber
;
if
(
typeof
line
=
=
=
"
number
"
&
&
typeof
column
=
=
=
"
number
"
)
{
frame
=
{
source
:
"
debugger
eval
code
"
line
column
}
;
}
}
catch
(
ex
)
{
}
try
{
const
notes
=
error
.
errorNotes
;
if
(
notes
?
.
length
)
{
errorNotes
=
[
]
;
for
(
const
note
of
notes
)
{
errorNotes
.
push
(
{
messageBody
:
this
.
_createStringGrip
(
note
.
message
)
frame
:
{
source
:
note
.
fileName
line
:
note
.
lineNumber
column
:
note
.
columnNumber
}
}
)
;
}
}
}
catch
(
ex
)
{
}
}
}
let
resultGrip
;
if
(
!
awaitResult
)
{
try
{
const
objectActor
=
this
.
parentActor
.
threadActor
.
getThreadLifetimeObject
(
result
)
;
if
(
objectActor
)
{
resultGrip
=
this
.
parentActor
.
threadActor
.
createValueGrip
(
result
)
;
}
else
{
resultGrip
=
this
.
createValueGrip
(
result
)
;
}
}
catch
(
e
)
{
errorMessage
=
e
;
}
}
if
(
!
eager
)
{
if
(
!
awaitResult
)
{
this
.
_lastConsoleInputEvaluation
=
result
;
}
else
{
const
p
=
awaitResult
.
then
(
res
=
>
{
this
.
_lastConsoleInputEvaluation
=
this
.
makeDebuggeeValue
(
res
)
;
}
)
;
const
{
state
}
=
ObjectUtils
.
getPromiseState
(
evalResult
.
return
)
;
if
(
state
=
=
=
"
rejected
"
)
{
p
.
catch
(
(
)
=
>
{
}
)
;
}
}
}
return
{
input
result
:
resultGrip
awaitResult
exception
:
errorGrip
exceptionMessage
:
this
.
_createStringGrip
(
errorMessage
)
exceptionDocURL
:
errorDocURL
exceptionStack
hasException
:
errorGrip
!
=
=
null
errorMessageName
frame
helperResult
notes
:
errorNotes
}
;
}
autocomplete
(
text
cursor
frameActorId
selectedNodeActor
authorizedEvaluations
expressionVars
=
[
]
)
{
let
dbgObject
=
null
;
let
environment
=
null
;
let
matches
=
[
]
;
let
matchProp
;
let
isElementAccess
;
const
reqText
=
text
.
substr
(
0
cursor
)
;
if
(
isCommand
(
reqText
)
)
{
matchProp
=
reqText
;
matches
=
validCommands
.
filter
(
c
=
>
:
{
c
}
.
startsWith
(
reqText
)
)
.
map
(
c
=
>
:
{
c
}
)
;
}
else
{
if
(
frameActorId
)
{
const
frameActor
=
this
.
conn
.
getActor
(
frameActorId
)
;
try
{
const
frame
=
frameActor
.
frame
;
environment
=
frame
.
environment
;
}
catch
(
e
)
{
DevToolsUtils
.
reportException
(
"
autocomplete
"
Error
(
"
The
frame
actor
was
not
found
:
"
+
frameActorId
)
)
;
}
}
else
{
dbgObject
=
this
.
dbg
.
addDebuggee
(
this
.
evalGlobal
)
;
}
const
result
=
JSPropertyProvider
(
{
dbgObject
environment
frameActorId
inputValue
:
text
cursor
webconsoleActor
:
this
selectedNodeActor
authorizedEvaluations
expressionVars
}
)
;
if
(
result
=
=
=
null
)
{
return
{
matches
:
null
}
;
}
if
(
result
&
&
result
.
isUnsafeGetter
=
=
=
true
)
{
return
{
isUnsafeGetter
:
true
getterPath
:
result
.
getterPath
}
;
}
matches
=
result
.
matches
|
|
new
Set
(
)
;
matchProp
=
result
.
matchProp
|
|
"
"
;
isElementAccess
=
result
.
isElementAccess
;
const
lastNonAlphaIsDot
=
/
[
.
]
[
a
-
zA
-
Z0
-
9
\
s
]
*
/
.
test
(
reqText
)
;
if
(
matchProp
&
&
!
lastNonAlphaIsDot
&
&
!
isElementAccess
)
{
for
(
const
name
of
WebConsoleCommandsManager
.
getAllCommandNames
(
)
)
{
if
(
name
!
=
=
"
screenshot
"
&
&
name
.
startsWith
(
result
.
matchProp
)
)
{
matches
.
add
(
name
)
;
}
}
for
(
const
keyword
of
RESERVED_JS_KEYWORDS
)
{
if
(
keyword
.
startsWith
(
result
.
matchProp
)
)
{
matches
.
add
(
keyword
)
;
}
}
}
const
firstMeaningfulCharIndex
=
isElementAccess
?
1
:
0
;
matches
=
Array
.
from
(
matches
)
.
sort
(
(
a
b
)
=
>
{
const
aFirstMeaningfulChar
=
a
[
firstMeaningfulCharIndex
]
;
const
bFirstMeaningfulChar
=
b
[
firstMeaningfulCharIndex
]
;
const
lA
=
aFirstMeaningfulChar
.
toLocaleLowerCase
(
)
=
=
=
aFirstMeaningfulChar
;
const
lB
=
bFirstMeaningfulChar
.
toLocaleLowerCase
(
)
=
=
=
bFirstMeaningfulChar
;
if
(
lA
=
=
=
lB
)
{
if
(
a
=
=
=
matchProp
)
{
return
-
1
;
}
if
(
b
=
=
=
matchProp
)
{
return
1
;
}
return
a
.
localeCompare
(
b
)
;
}
return
lA
?
-
1
:
1
;
}
)
;
}
return
{
matches
matchProp
isElementAccess
:
isElementAccess
=
=
=
true
}
;
}
clearMessagesCacheAsync
(
)
{
if
(
isWorker
)
{
clearConsoleEvents
(
)
;
return
;
}
const
windowId
=
!
this
.
parentActor
.
isRootActor
?
WebConsoleUtils
.
getInnerWindowId
(
this
.
global
)
:
null
;
const
ConsoleAPIStorage
=
Cc
[
"
mozilla
.
org
/
consoleAPI
-
storage
;
1
"
]
.
getService
(
Ci
.
nsIConsoleAPIStorage
)
;
ConsoleAPIStorage
.
clearEvents
(
windowId
)
;
CONSOLE_WORKER_IDS
.
forEach
(
id
=
>
{
ConsoleAPIStorage
.
clearEvents
(
id
)
;
}
)
;
if
(
this
.
parentActor
.
isRootActor
|
|
!
this
.
global
)
{
Services
.
console
.
reset
(
)
;
}
else
if
(
this
.
parentActor
.
ignoreSubFrames
)
{
Services
.
console
.
resetWindow
(
windowId
)
;
}
else
{
WebConsoleUtils
.
getInnerWindowIDsForFrames
(
this
.
global
)
.
forEach
(
id
=
>
Services
.
console
.
resetWindow
(
id
)
)
;
}
}
_getWebConsoleCommands
(
debuggerGlobal
evalInput
selectedNodeActorID
)
{
const
helpers
=
{
window
:
this
.
evalGlobal
makeDebuggeeValue
:
debuggerGlobal
.
makeDebuggeeValue
.
bind
(
debuggerGlobal
)
createValueGrip
:
this
.
createValueGrip
.
bind
(
this
)
preprocessDebuggerObject
:
this
.
preprocessDebuggerObject
.
bind
(
this
)
sandbox
:
Object
.
create
(
null
)
helperResult
:
null
consoleActor
:
this
evalInput
}
;
if
(
selectedNodeActorID
)
{
const
actor
=
this
.
conn
.
getActor
(
selectedNodeActorID
)
;
if
(
actor
)
{
helpers
.
selectedNode
=
actor
.
rawNode
;
}
}
addWebConsoleCommands
(
helpers
)
;
const
evalGlobal
=
this
.
evalGlobal
;
function
maybeExport
(
obj
name
)
{
if
(
typeof
obj
[
name
]
!
=
"
function
"
)
{
return
;
}
obj
[
name
]
=
Cu
.
exportFunction
(
obj
[
name
]
evalGlobal
{
allowCrossOriginArguments
:
true
}
)
;
}
for
(
const
name
in
helpers
.
sandbox
)
{
const
desc
=
Object
.
getOwnPropertyDescriptor
(
helpers
.
sandbox
name
)
;
if
(
!
isWorker
)
{
maybeExport
(
desc
"
get
"
)
;
maybeExport
(
desc
"
set
"
)
;
maybeExport
(
desc
"
value
"
)
;
}
if
(
desc
.
value
)
{
desc
.
value
=
debuggerGlobal
.
makeDebuggeeValue
(
desc
.
value
)
;
}
Object
.
defineProperty
(
helpers
.
sandbox
name
desc
)
;
}
return
helpers
;
}
onConsoleServiceMessage
(
message
)
{
if
(
message
instanceof
Ci
.
nsIScriptError
)
{
this
.
emit
(
"
pageError
"
{
pageError
:
this
.
preparePageErrorForRemote
(
message
)
}
)
;
}
else
{
this
.
emit
(
"
logMessage
"
{
message
:
this
.
_createStringGrip
(
message
.
message
)
timeStamp
:
message
.
microSecondTimeStamp
/
1000
}
)
;
}
}
getActorIdForInternalSourceId
(
id
)
{
const
actor
=
this
.
parentActor
.
sourcesManager
.
getSourceActorByInternalSourceId
(
id
)
;
return
actor
?
actor
.
actorID
:
null
;
}
prepareStackForRemote
(
errorStack
)
{
if
(
!
errorStack
|
|
(
Cu
&
&
Cu
.
isDeadWrapper
(
errorStack
)
)
)
{
return
null
;
}
const
stack
=
[
]
;
let
s
=
errorStack
;
while
(
s
)
{
stack
.
push
(
{
filename
:
s
.
source
sourceId
:
this
.
getActorIdForInternalSourceId
(
s
.
sourceId
)
lineNumber
:
s
.
line
columnNumber
:
s
.
column
functionName
:
s
.
functionDisplayName
asyncCause
:
s
.
asyncCause
?
s
.
asyncCause
:
undefined
}
)
;
s
=
s
.
parent
|
|
s
.
asyncParent
;
}
return
stack
;
}
preparePageErrorForRemote
(
pageError
)
{
const
stack
=
this
.
prepareStackForRemote
(
pageError
.
stack
)
;
let
lineText
=
pageError
.
sourceLine
;
if
(
lineText
&
&
lineText
.
length
>
DevToolsServer
.
LONG_STRING_INITIAL_LENGTH
)
{
lineText
=
lineText
.
substr
(
0
DevToolsServer
.
LONG_STRING_INITIAL_LENGTH
)
;
}
let
notesArray
=
null
;
const
notes
=
pageError
.
notes
;
if
(
notes
?
.
length
)
{
notesArray
=
[
]
;
for
(
let
i
=
0
len
=
notes
.
length
;
i
<
len
;
i
+
+
)
{
const
note
=
notes
.
queryElementAt
(
i
Ci
.
nsIScriptErrorNote
)
;
notesArray
.
push
(
{
messageBody
:
this
.
_createStringGrip
(
note
.
errorMessage
)
frame
:
{
source
:
note
.
sourceName
sourceId
:
this
.
getActorIdForInternalSourceId
(
note
.
sourceId
)
line
:
note
.
lineNumber
column
:
note
.
columnNumber
}
}
)
;
}
}
let
{
sourceName
sourceId
lineNumber
columnNumber
}
=
pageError
;
if
(
!
sourceName
&
&
!
sourceId
&
&
!
lineNumber
&
&
!
columnNumber
&
&
stack
)
{
sourceName
=
stack
[
0
]
.
filename
;
sourceId
=
stack
[
0
]
.
sourceId
;
lineNumber
=
stack
[
0
]
.
lineNumber
;
columnNumber
=
stack
[
0
]
.
columnNumber
;
}
const
isCSSMessage
=
pageError
.
category
=
=
=
MESSAGE_CATEGORY
.
CSS_PARSER
;
const
result
=
{
errorMessage
:
this
.
_createStringGrip
(
pageError
.
errorMessage
)
errorMessageName
:
isCSSMessage
?
undefined
:
pageError
.
errorMessageName
exceptionDocURL
:
ErrorDocs
.
GetURL
(
pageError
)
sourceName
sourceId
:
this
.
getActorIdForInternalSourceId
(
sourceId
)
lineText
lineNumber
columnNumber
category
:
pageError
.
category
innerWindowID
:
pageError
.
innerWindowID
timeStamp
:
pageError
.
microSecondTimeStamp
/
1000
warning
:
!
!
(
pageError
.
flags
&
pageError
.
warningFlag
)
error
:
!
(
pageError
.
flags
&
(
pageError
.
warningFlag
|
pageError
.
infoFlag
)
)
info
:
!
!
(
pageError
.
flags
&
pageError
.
infoFlag
)
private
:
pageError
.
isFromPrivateWindow
stacktrace
:
stack
notes
:
notesArray
chromeContext
:
pageError
.
isFromChromeContext
isPromiseRejection
:
isCSSMessage
?
undefined
:
pageError
.
isPromiseRejection
isForwardedFromContentProcess
:
pageError
.
isForwardedFromContentProcess
cssSelectors
:
isCSSMessage
?
pageError
.
cssSelectors
:
undefined
}
;
if
(
pageError
.
hasException
)
{
try
{
const
obj
=
this
.
makeDebuggeeValue
(
pageError
.
exception
true
)
;
if
(
obj
?
.
class
!
=
=
"
DeadObject
"
)
{
result
.
exception
=
this
.
createValueGrip
(
obj
)
;
result
.
hasException
=
true
;
}
}
catch
(
e
)
{
}
}
return
result
;
}
onConsoleAPICall
(
message
extraProperties
=
{
}
)
{
this
.
emit
(
"
consoleAPICall
"
{
message
:
this
.
prepareConsoleMessageForRemote
(
message
)
.
.
.
extraProperties
}
)
;
}
onDocumentEvent
(
name
{
time
hasNativeConsoleAPI
}
)
{
this
.
emit
(
"
documentEvent
"
{
name
time
hasNativeConsoleAPI
}
)
;
}
onFileActivity
(
fileURI
)
{
this
.
emit
(
"
fileActivity
"
{
uri
:
fileURI
}
)
;
}
prepareConsoleMessageForRemote
(
message
useObjectGlobal
=
true
)
{
const
result
=
{
arguments
:
message
.
arguments
?
message
.
arguments
.
map
(
obj
=
>
{
const
dbgObj
=
this
.
makeDebuggeeValue
(
obj
useObjectGlobal
)
;
return
this
.
createValueGrip
(
dbgObj
)
;
}
)
:
[
]
chromeContext
:
message
.
chromeContext
columnNumber
:
message
.
columnNumber
filename
:
message
.
filename
level
:
message
.
level
lineNumber
:
message
.
lineNumber
timeStamp
:
message
.
microSecondTimeStamp
?
message
.
microSecondTimeStamp
/
1000
:
message
.
timeStamp
sourceId
:
this
.
getActorIdForInternalSourceId
(
message
.
sourceId
)
category
:
message
.
category
|
|
"
webdev
"
innerWindowID
:
message
.
innerID
}
;
if
(
message
.
counter
)
{
result
.
counter
=
message
.
counter
;
}
if
(
message
.
private
)
{
result
.
private
=
message
.
private
;
}
if
(
message
.
prefix
)
{
result
.
prefix
=
message
.
prefix
;
}
if
(
message
.
stacktrace
)
{
result
.
stacktrace
=
message
.
stacktrace
.
map
(
frame
=
>
{
return
{
.
.
.
frame
sourceId
:
this
.
getActorIdForInternalSourceId
(
frame
.
sourceId
)
}
;
}
)
;
}
if
(
message
.
styles
&
&
message
.
styles
.
length
)
{
result
.
styles
=
message
.
styles
.
map
(
string
=
>
{
return
this
.
createValueGrip
(
string
)
;
}
)
;
}
if
(
message
.
timer
)
{
result
.
timer
=
message
.
timer
;
}
if
(
message
.
level
=
=
=
"
table
"
)
{
const
tableItems
=
this
.
_getConsoleTableMessageItems
(
result
)
;
if
(
tableItems
)
{
result
.
arguments
[
0
]
.
ownProperties
=
tableItems
;
result
.
arguments
[
0
]
.
preview
=
null
;
}
result
.
arguments
=
result
.
arguments
.
slice
(
0
2
)
;
}
return
result
;
}
_getConsoleTableMessageItems
(
result
)
{
if
(
!
result
|
|
!
Array
.
isArray
(
result
.
arguments
)
|
|
!
result
.
arguments
.
length
)
{
return
null
;
}
const
[
tableItemGrip
]
=
result
.
arguments
;
const
dataType
=
tableItemGrip
.
class
;
const
needEntries
=
[
"
Map
"
"
WeakMap
"
"
Set
"
"
WeakSet
"
]
.
includes
(
dataType
)
;
const
ignoreNonIndexedProperties
=
isArray
(
tableItemGrip
)
;
const
tableItemActor
=
this
.
getActorByID
(
tableItemGrip
.
actor
)
;
if
(
!
tableItemActor
)
{
return
null
;
}
const
iterator
=
needEntries
?
tableItemActor
.
enumEntries
(
)
:
tableItemActor
.
enumProperties
(
{
ignoreNonIndexedProperties
}
)
;
const
{
ownProperties
}
=
iterator
.
all
(
)
;
const
descriptorKeys
=
[
"
safeGetterValues
"
"
getterValue
"
"
value
"
]
;
Object
.
values
(
ownProperties
)
.
forEach
(
desc
=
>
{
if
(
typeof
desc
!
=
=
"
undefined
"
)
{
descriptorKeys
.
forEach
(
key
=
>
{
if
(
desc
&
&
desc
.
hasOwnProperty
(
key
)
)
{
const
grip
=
desc
[
key
]
;
const
actor
=
grip
&
&
this
.
getActorByID
(
grip
.
actor
)
;
if
(
actor
)
{
const
res
=
actor
.
enumProperties
(
{
ignoreNonIndexedProperties
:
isArray
(
grip
)
}
)
.
all
(
)
;
if
(
res
?
.
ownProperties
)
{
desc
[
key
]
.
ownProperties
=
res
.
ownProperties
;
}
}
}
}
)
;
}
}
)
;
return
ownProperties
;
}
_onWillNavigate
(
{
window
isTopLevel
}
)
{
if
(
isTopLevel
)
{
this
.
_evalGlobal
=
null
;
EventEmitter
.
off
(
this
.
parentActor
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_progressListenerActive
=
false
;
}
}
_onChangedToplevelDocument
(
)
{
const
listeners
=
[
.
.
.
this
.
_listeners
]
;
this
.
stopListeners
(
listeners
.
slice
(
)
)
;
this
.
startListeners
(
listeners
)
;
this
.
_lastChromeWindow
=
null
;
}
}
exports
.
WebConsoleActor
=
WebConsoleActor
;
