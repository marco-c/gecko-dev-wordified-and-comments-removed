"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
const
{
ActorPool
}
=
require
(
"
devtools
/
server
/
actors
/
common
"
)
;
const
{
ThreadActor
}
=
require
(
"
devtools
/
server
/
actors
/
thread
"
)
;
const
{
ObjectActor
}
=
require
(
"
devtools
/
server
/
actors
/
object
"
)
;
const
{
LongStringActor
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
long
-
string
"
)
;
const
{
createValueGrip
stringIsLong
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
ErrorDocs
=
require
(
"
devtools
/
server
/
actors
/
errordocs
"
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkMonitorActor
"
"
devtools
/
server
/
actors
/
network
-
monitor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleProgressListener
"
"
devtools
/
shared
/
webconsole
/
network
-
monitor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
StackTraceCollector
"
"
devtools
/
shared
/
webconsole
/
network
-
monitor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
JSPropertyProvider
"
"
devtools
/
shared
/
webconsole
/
js
-
property
-
provider
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Parser
"
"
resource
:
/
/
devtools
/
shared
/
Parser
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebConsoleCommands
"
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
addWebConsoleCommands
"
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
formatCommand
"
"
devtools
/
server
/
actors
/
webconsole
/
commands
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isCommand
"
"
devtools
/
server
/
actors
/
webconsole
/
commands
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
validCommands
"
"
devtools
/
server
/
actors
/
webconsole
/
commands
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CONSOLE_WORKER_IDS
"
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebConsoleUtils
"
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EnvironmentActor
"
"
devtools
/
server
/
actors
/
environment
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
if
(
isWorker
)
{
loader
.
lazyRequireGetter
(
this
"
ConsoleAPIListener
"
"
devtools
/
server
/
actors
/
webconsole
/
worker
-
listeners
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleServiceListener
"
"
devtools
/
server
/
actors
/
webconsole
/
worker
-
listeners
"
true
)
;
}
else
{
loader
.
lazyRequireGetter
(
this
"
ConsoleAPIListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleServiceListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleReflowListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ContentProcessListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DocumentEventsListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
"
true
)
;
}
function
isObject
(
value
)
{
return
Object
(
value
)
=
=
=
value
;
}
function
WebConsoleActor
(
connection
parentActor
)
{
this
.
conn
=
connection
;
this
.
parentActor
=
parentActor
;
this
.
_actorPool
=
new
ActorPool
(
this
.
conn
)
;
this
.
conn
.
addActorPool
(
this
.
_actorPool
)
;
this
.
_prefs
=
{
}
;
this
.
dbg
=
this
.
parentActor
.
makeDebugger
(
)
;
this
.
_gripDepth
=
0
;
this
.
_listeners
=
new
Set
(
)
;
this
.
_lastConsoleInputEvaluation
=
undefined
;
this
.
objectGrip
=
this
.
objectGrip
.
bind
(
this
)
;
this
.
_onWillNavigate
=
this
.
_onWillNavigate
.
bind
(
this
)
;
this
.
_onChangedToplevelDocument
=
this
.
_onChangedToplevelDocument
.
bind
(
this
)
;
EventEmitter
.
on
(
this
.
parentActor
"
changed
-
toplevel
-
document
"
this
.
_onChangedToplevelDocument
)
;
this
.
_onObserverNotification
=
this
.
_onObserverNotification
.
bind
(
this
)
;
if
(
this
.
parentActor
.
isRootActor
)
{
Services
.
obs
.
addObserver
(
this
.
_onObserverNotification
"
last
-
pb
-
context
-
exited
"
)
;
}
this
.
traits
=
{
evaluateJSAsync
:
true
transferredResponseSize
:
true
selectedObjectActor
:
true
fetchCacheDescriptor
:
true
}
;
}
WebConsoleActor
.
prototype
=
{
dbg
:
null
_gripDepth
:
null
_actorPool
:
null
_prefs
:
null
_listeners
:
null
conn
:
null
traits
:
null
get
window
(
)
{
if
(
this
.
parentActor
.
isRootActor
)
{
return
this
.
_getWindowForBrowserConsole
(
)
;
}
return
this
.
parentActor
.
window
;
}
_getWindowForBrowserConsole
:
function
(
)
{
let
window
=
this
.
_lastChromeWindow
&
&
this
.
_lastChromeWindow
.
get
(
)
;
if
(
!
window
|
|
window
.
closed
)
{
window
=
this
.
parentActor
.
window
;
if
(
!
window
)
{
window
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webconsole
"
)
;
const
onChromeWindowOpened
=
(
)
=
>
{
Services
.
obs
.
removeObserver
(
onChromeWindowOpened
"
domwindowopened
"
)
;
this
.
_lastChromeWindow
=
null
;
}
;
Services
.
obs
.
addObserver
(
onChromeWindowOpened
"
domwindowopened
"
)
;
}
this
.
_handleNewWindow
(
window
)
;
}
return
window
;
}
_handleNewWindow
:
function
(
window
)
{
if
(
window
)
{
if
(
this
.
_hadChromeWindow
)
{
Services
.
console
.
logStringMessage
(
"
Webconsole
context
has
changed
"
)
;
}
this
.
_lastChromeWindow
=
Cu
.
getWeakReference
(
window
)
;
this
.
_hadChromeWindow
=
true
;
}
else
{
this
.
_lastChromeWindow
=
null
;
}
}
_hadChromeWindow
:
false
_lastChromeWindow
:
null
_evalWindow
:
null
get
evalWindow
(
)
{
return
this
.
_evalWindow
|
|
this
.
window
;
}
set
evalWindow
(
window
)
{
this
.
_evalWindow
=
window
;
if
(
!
this
.
_progressListenerActive
)
{
EventEmitter
.
on
(
this
.
parentActor
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_progressListenerActive
=
true
;
}
}
_progressListenerActive
:
false
consoleServiceListener
:
null
consoleAPIListener
:
null
consoleProgressListener
:
null
consoleReflowListener
:
null
_webConsoleCommandsCache
:
null
typeName
:
"
console
"
get
globalDebugObject
(
)
{
return
this
.
parentActor
.
threadActor
.
globalDebugObject
;
}
grip
:
function
(
)
{
return
{
actor
:
this
.
actorID
}
;
}
hasNativeConsoleAPI
:
function
(
window
)
{
if
(
isWorker
)
{
return
true
;
}
let
isNative
=
false
;
try
{
const
console
=
window
.
wrappedJSObject
.
console
;
isNative
=
new
XPCNativeWrapper
(
console
)
.
IS_NATIVE_CONSOLE
;
}
catch
(
ex
)
{
}
return
isNative
;
}
_findProtoChain
:
ThreadActor
.
prototype
.
_findProtoChain
_removeFromProtoChain
:
ThreadActor
.
prototype
.
_removeFromProtoChain
destroy
(
)
{
if
(
this
.
consoleServiceListener
)
{
this
.
consoleServiceListener
.
destroy
(
)
;
this
.
consoleServiceListener
=
null
;
}
if
(
this
.
networkMonitorActor
)
{
this
.
networkMonitorActor
.
destroy
(
)
;
this
.
networkMonitorActor
=
null
;
}
if
(
this
.
networkMonitorActorId
)
{
const
messageManager
=
this
.
parentActor
.
messageManager
;
if
(
messageManager
)
{
messageManager
.
sendAsyncMessage
(
"
debug
:
destroy
-
network
-
monitor
"
{
actorId
:
this
.
networkMonitorActorId
}
)
;
}
this
.
networkMonitorActorId
=
null
;
}
if
(
this
.
networkMonitorChildActor
)
{
this
.
networkMonitorChildActor
.
destroy
(
)
;
this
.
networkMonitorChildActor
=
null
;
}
if
(
this
.
consoleAPIListener
)
{
this
.
consoleAPIListener
.
destroy
(
)
;
this
.
consoleAPIListener
=
null
;
}
if
(
this
.
stackTraceCollector
)
{
this
.
stackTraceCollector
.
destroy
(
)
;
this
.
stackTraceCollector
=
null
;
}
if
(
this
.
consoleProgressListener
)
{
this
.
consoleProgressListener
.
destroy
(
)
;
this
.
consoleProgressListener
=
null
;
}
if
(
this
.
consoleReflowListener
)
{
this
.
consoleReflowListener
.
destroy
(
)
;
this
.
consoleReflowListener
=
null
;
}
if
(
this
.
contentProcessListener
)
{
this
.
contentProcessListener
.
destroy
(
)
;
this
.
contentProcessListener
=
null
;
}
EventEmitter
.
off
(
this
.
parentActor
"
changed
-
toplevel
-
document
"
this
.
_onChangedToplevelDocument
)
;
this
.
conn
.
removeActorPool
(
this
.
_actorPool
)
;
if
(
this
.
parentActor
.
isRootActor
)
{
Services
.
obs
.
removeObserver
(
this
.
_onObserverNotification
"
last
-
pb
-
context
-
exited
"
)
;
}
this
.
_actorPool
=
null
;
this
.
_webConsoleCommandsCache
=
null
;
this
.
_lastConsoleInputEvaluation
=
null
;
this
.
_evalWindow
=
null
;
this
.
dbg
.
enabled
=
false
;
this
.
dbg
=
null
;
this
.
conn
=
null
;
}
createEnvironmentActor
:
function
(
environment
)
{
if
(
!
environment
)
{
return
undefined
;
}
if
(
environment
.
actor
)
{
return
environment
.
actor
;
}
const
actor
=
new
EnvironmentActor
(
environment
this
)
;
this
.
_actorPool
.
addActor
(
actor
)
;
environment
.
actor
=
actor
;
return
actor
;
}
createValueGrip
:
function
(
value
)
{
return
createValueGrip
(
value
this
.
_actorPool
this
.
objectGrip
)
;
}
makeDebuggeeValue
:
function
(
value
useObjectGlobal
)
{
if
(
useObjectGlobal
&
&
isObject
(
value
)
)
{
try
{
const
global
=
Cu
.
getGlobalForObject
(
value
)
;
const
dbgGlobal
=
this
.
dbg
.
makeGlobalObjectReference
(
global
)
;
return
dbgGlobal
.
makeDebuggeeValue
(
value
)
;
}
catch
(
ex
)
{
}
}
const
dbgGlobal
=
this
.
dbg
.
makeGlobalObjectReference
(
this
.
window
)
;
return
dbgGlobal
.
makeDebuggeeValue
(
value
)
;
}
objectGrip
:
function
(
object
pool
)
{
const
actor
=
new
ObjectActor
(
object
{
getGripDepth
:
(
)
=
>
this
.
_gripDepth
incrementGripDepth
:
(
)
=
>
this
.
_gripDepth
+
+
decrementGripDepth
:
(
)
=
>
this
.
_gripDepth
-
-
createValueGrip
:
v
=
>
this
.
createValueGrip
(
v
)
sources
:
(
)
=
>
DevToolsUtils
.
reportException
(
"
WebConsoleActor
"
Error
(
"
sources
not
yet
implemented
"
)
)
createEnvironmentActor
:
(
env
)
=
>
this
.
createEnvironmentActor
(
env
)
getGlobalDebugObject
:
(
)
=
>
this
.
globalDebugObject
}
this
.
conn
)
;
pool
.
addActor
(
actor
)
;
return
actor
.
form
(
)
;
}
longStringGrip
:
function
(
string
pool
)
{
const
actor
=
new
LongStringActor
(
string
)
;
pool
.
addActor
(
actor
)
;
return
actor
.
grip
(
)
;
}
_createStringGrip
:
function
(
string
)
{
if
(
string
&
&
stringIsLong
(
string
)
)
{
return
this
.
longStringGrip
(
string
this
.
_actorPool
)
;
}
return
string
;
}
getActorByID
:
function
(
actorID
)
{
return
this
.
_actorPool
.
get
(
actorID
)
;
}
releaseActor
:
function
(
actor
)
{
this
.
_actorPool
.
removeActor
(
actor
)
;
}
getLastConsoleInputEvaluation
:
function
(
)
{
return
this
.
_lastConsoleInputEvaluation
;
}
inspectObject
(
dbgObj
inspectFromAnnotation
)
{
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
inspectObject
"
{
objectActor
:
this
.
createValueGrip
(
dbgObj
)
inspectFromAnnotation
}
)
;
}
startListeners
:
async
function
(
request
)
{
const
startedListeners
=
[
]
;
const
window
=
!
this
.
parentActor
.
isRootActor
?
this
.
window
:
null
;
let
messageManager
=
null
;
const
processBoundary
=
Services
.
appinfo
&
&
(
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
)
;
if
(
processBoundary
)
{
messageManager
=
this
.
parentActor
.
messageManager
;
}
while
(
request
.
listeners
.
length
>
0
)
{
const
listener
=
request
.
listeners
.
shift
(
)
;
switch
(
listener
)
{
case
"
PageError
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
consoleServiceListener
)
{
this
.
consoleServiceListener
=
new
ConsoleServiceListener
(
window
this
)
;
this
.
consoleServiceListener
.
init
(
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
ConsoleAPI
"
:
if
(
!
this
.
consoleAPIListener
)
{
this
.
consoleAPIListener
=
new
ConsoleAPIListener
(
window
this
this
.
parentActor
.
consoleAPIListenerOptions
)
;
this
.
consoleAPIListener
.
init
(
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
NetworkActivity
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
networkMonitorActorId
&
&
!
this
.
networkMonitorActor
)
{
this
.
stackTraceCollector
=
new
StackTraceCollector
(
{
window
}
messageManager
)
;
this
.
stackTraceCollector
.
init
(
)
;
if
(
messageManager
&
&
processBoundary
)
{
this
.
networkMonitorActorId
=
await
this
.
conn
.
spawnActorInParentProcess
(
this
.
actorID
{
module
:
"
devtools
/
server
/
actors
/
network
-
monitor
"
constructor
:
"
NetworkMonitorActor
"
args
:
[
{
outerWindowID
:
this
.
parentActor
.
outerWindowID
}
this
.
actorID
]
}
)
;
this
.
networkMonitorChildActor
=
new
NetworkMonitorActor
(
this
.
conn
{
window
}
this
.
actorID
null
this
.
stackTraceCollector
)
;
}
else
{
this
.
networkMonitorActor
=
new
NetworkMonitorActor
(
this
.
conn
{
window
}
this
.
actorID
null
this
.
stackTraceCollector
)
;
}
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
FileActivity
"
:
if
(
isWorker
)
{
break
;
}
if
(
this
.
window
instanceof
Ci
.
nsIDOMWindow
)
{
if
(
!
this
.
consoleProgressListener
)
{
this
.
consoleProgressListener
=
new
ConsoleProgressListener
(
this
.
window
this
)
;
}
this
.
consoleProgressListener
.
startMonitor
(
this
.
consoleProgressListener
.
MONITOR_FILE_ACTIVITY
)
;
startedListeners
.
push
(
listener
)
;
}
break
;
case
"
ReflowActivity
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
consoleReflowListener
)
{
this
.
consoleReflowListener
=
new
ConsoleReflowListener
(
this
.
window
this
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
ContentProcessMessages
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
contentProcessListener
)
{
this
.
contentProcessListener
=
new
ContentProcessListener
(
this
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
case
"
DocumentEvents
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
documentEventsListener
)
{
this
.
documentEventsListener
=
new
DocumentEventsListener
(
this
)
;
}
startedListeners
.
push
(
listener
)
;
break
;
}
}
startedListeners
.
forEach
(
this
.
_listeners
.
add
this
.
_listeners
)
;
return
{
startedListeners
:
startedListeners
nativeConsoleAPI
:
this
.
hasNativeConsoleAPI
(
this
.
window
)
traits
:
this
.
traits
}
;
}
stopListeners
:
function
(
request
)
{
const
stoppedListeners
=
[
]
;
const
toDetach
=
request
.
listeners
|
|
[
"
PageError
"
"
ConsoleAPI
"
"
NetworkActivity
"
"
FileActivity
"
"
ContentProcessMessages
"
]
;
while
(
toDetach
.
length
>
0
)
{
const
listener
=
toDetach
.
shift
(
)
;
switch
(
listener
)
{
case
"
PageError
"
:
if
(
this
.
consoleServiceListener
)
{
this
.
consoleServiceListener
.
destroy
(
)
;
this
.
consoleServiceListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
ConsoleAPI
"
:
if
(
this
.
consoleAPIListener
)
{
this
.
consoleAPIListener
.
destroy
(
)
;
this
.
consoleAPIListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
NetworkActivity
"
:
if
(
this
.
networkMonitorActor
)
{
this
.
networkMonitorActor
.
destroy
(
)
;
this
.
networkMonitorActor
=
null
;
}
if
(
this
.
networkMonitorActorId
)
{
const
messageManager
=
this
.
parentActor
.
messageManager
;
if
(
messageManager
)
{
messageManager
.
sendAsyncMessage
(
"
debug
:
destroy
-
network
-
monitor
"
{
actorId
:
this
.
networkMonitorActorId
}
)
;
}
this
.
networkMonitorActorId
=
null
;
}
if
(
this
.
networkMonitorChildActor
)
{
this
.
networkMonitorChildActor
.
destroy
(
)
;
this
.
networkMonitorChildActor
=
null
;
}
if
(
this
.
stackTraceCollector
)
{
this
.
stackTraceCollector
.
destroy
(
)
;
this
.
stackTraceCollector
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
FileActivity
"
:
if
(
this
.
consoleProgressListener
)
{
this
.
consoleProgressListener
.
stopMonitor
(
this
.
consoleProgressListener
.
MONITOR_FILE_ACTIVITY
)
;
this
.
consoleProgressListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
ReflowActivity
"
:
if
(
this
.
consoleReflowListener
)
{
this
.
consoleReflowListener
.
destroy
(
)
;
this
.
consoleReflowListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
ContentProcessMessages
"
:
if
(
this
.
contentProcessListener
)
{
this
.
contentProcessListener
.
destroy
(
)
;
this
.
contentProcessListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
case
"
DocumentEvents
"
:
if
(
this
.
documentEventsListener
)
{
this
.
documentEventsListener
.
destroy
(
)
;
this
.
documentEventsListener
=
null
;
}
stoppedListeners
.
push
(
listener
)
;
break
;
}
}
stoppedListeners
.
forEach
(
this
.
_listeners
.
delete
this
.
_listeners
)
;
return
{
stoppedListeners
:
stoppedListeners
}
;
}
getCachedMessages
:
function
(
request
)
{
const
types
=
request
.
messageTypes
;
if
(
!
types
)
{
return
{
error
:
"
missingParameter
"
message
:
"
The
messageTypes
parameter
is
missing
.
"
}
;
}
const
messages
=
[
]
;
while
(
types
.
length
>
0
)
{
const
type
=
types
.
shift
(
)
;
switch
(
type
)
{
case
"
ConsoleAPI
"
:
{
if
(
!
this
.
consoleAPIListener
)
{
break
;
}
const
winStartTime
=
this
.
window
&
&
this
.
window
.
performance
?
this
.
window
.
performance
.
timing
.
navigationStart
:
0
;
const
cache
=
this
.
consoleAPIListener
.
getCachedMessages
(
!
this
.
parentActor
.
isRootActor
)
;
cache
.
forEach
(
(
cachedMessage
)
=
>
{
if
(
cachedMessage
.
innerID
=
=
=
"
ServiceWorker
"
&
&
winStartTime
>
cachedMessage
.
timeStamp
)
{
return
;
}
const
message
=
this
.
prepareConsoleMessageForRemote
(
cachedMessage
)
;
message
.
_type
=
type
;
messages
.
push
(
message
)
;
}
)
;
break
;
}
case
"
PageError
"
:
{
if
(
!
this
.
consoleServiceListener
)
{
break
;
}
const
cache
=
this
.
consoleServiceListener
.
getCachedMessages
(
!
this
.
parentActor
.
isRootActor
)
;
cache
.
forEach
(
(
cachedMessage
)
=
>
{
let
message
=
null
;
if
(
cachedMessage
instanceof
Ci
.
nsIScriptError
)
{
message
=
this
.
preparePageErrorForRemote
(
cachedMessage
)
;
message
.
_type
=
type
;
}
else
{
message
=
{
_type
:
"
LogMessage
"
message
:
this
.
_createStringGrip
(
cachedMessage
.
message
)
timeStamp
:
cachedMessage
.
timeStamp
}
;
}
messages
.
push
(
message
)
;
}
)
;
break
;
}
}
}
return
{
from
:
this
.
actorID
messages
:
messages
}
;
}
evaluateJSAsync
:
function
(
request
)
{
const
resultID
=
Date
.
now
(
)
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
resultID
:
resultID
}
)
;
const
response
=
this
.
evaluateJS
(
request
)
;
response
.
resultID
=
resultID
;
this
.
_waitForHelperResultAndSend
(
response
)
.
catch
(
e
=
>
DevToolsUtils
.
reportException
(
"
evaluateJSAsync
"
Error
(
Encountered
error
while
waiting
for
Helper
Result
:
{
e
}
)
)
)
;
}
_waitForHelperResultAndSend
:
async
function
(
response
)
{
if
(
response
.
helperResult
&
&
typeof
response
.
helperResult
.
then
=
=
"
function
"
)
{
response
.
helperResult
=
await
response
.
helperResult
;
}
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
evaluationResult
"
response
)
;
}
evaluateJS
:
function
(
request
)
{
const
input
=
request
.
text
;
const
timestamp
=
Date
.
now
(
)
;
const
evalOptions
=
{
bindObjectActor
:
request
.
bindObjectActor
frameActor
:
request
.
frameActor
url
:
request
.
url
selectedNodeActor
:
request
.
selectedNodeActor
selectedObjectActor
:
request
.
selectedObjectActor
}
;
const
evalInfo
=
this
.
evalWithDebugger
(
input
evalOptions
)
;
const
evalResult
=
evalInfo
.
result
;
const
helperResult
=
evalInfo
.
helperResult
;
let
result
errorDocURL
errorMessage
errorNotes
=
null
errorGrip
=
null
frame
=
null
;
if
(
evalResult
)
{
if
(
"
return
"
in
evalResult
)
{
result
=
evalResult
.
return
;
}
else
if
(
"
yield
"
in
evalResult
)
{
result
=
evalResult
.
yield
;
}
else
if
(
"
throw
"
in
evalResult
)
{
const
error
=
evalResult
.
throw
;
errorGrip
=
this
.
createValueGrip
(
error
)
;
errorMessage
=
String
(
error
)
;
if
(
typeof
error
=
=
=
"
object
"
&
&
error
!
=
=
null
)
{
try
{
errorMessage
=
DevToolsUtils
.
callPropertyOnObject
(
error
"
toString
"
)
;
}
catch
(
e
)
{
if
(
typeof
error
.
unsafeDereference
=
=
=
"
function
"
)
{
errorMessage
=
error
.
unsafeDereference
(
)
.
toString
(
)
;
}
}
}
try
{
errorDocURL
=
ErrorDocs
.
GetURL
(
error
)
;
}
catch
(
ex
)
{
}
try
{
const
line
=
error
.
errorLineNumber
;
const
column
=
error
.
errorColumnNumber
;
if
(
typeof
line
=
=
=
"
number
"
&
&
typeof
column
=
=
=
"
number
"
)
{
frame
=
{
source
:
"
debugger
eval
code
"
line
column
}
;
}
}
catch
(
ex
)
{
}
try
{
const
notes
=
error
.
errorNotes
;
if
(
notes
&
&
notes
.
length
)
{
errorNotes
=
[
]
;
for
(
const
note
of
notes
)
{
errorNotes
.
push
(
{
messageBody
:
this
.
_createStringGrip
(
note
.
message
)
frame
:
{
source
:
note
.
fileName
line
:
note
.
lineNumber
column
:
note
.
columnNumber
}
}
)
;
}
}
}
catch
(
ex
)
{
}
}
}
let
resultGrip
;
try
{
resultGrip
=
this
.
createValueGrip
(
result
)
;
}
catch
(
e
)
{
errorMessage
=
e
;
}
this
.
_lastConsoleInputEvaluation
=
result
;
return
{
from
:
this
.
actorID
input
:
input
result
:
resultGrip
timestamp
:
timestamp
exception
:
errorGrip
exceptionMessage
:
this
.
_createStringGrip
(
errorMessage
)
exceptionDocURL
:
errorDocURL
frame
helperResult
:
helperResult
notes
:
errorNotes
}
;
}
autocomplete
:
function
(
request
)
{
const
frameActorId
=
request
.
frameActor
;
let
dbgObject
=
null
;
let
environment
=
null
;
let
hadDebuggee
=
false
;
let
matches
=
[
]
;
let
matchProp
;
const
reqText
=
request
.
text
.
substr
(
0
request
.
cursor
)
;
if
(
isCommand
(
reqText
)
)
{
const
commandsCache
=
this
.
_getWebConsoleCommandsCache
(
)
;
matchProp
=
reqText
;
matches
=
validCommands
.
filter
(
c
=
>
:
{
c
}
.
startsWith
(
reqText
)
&
&
commandsCache
.
find
(
n
=
>
:
{
n
}
.
startsWith
(
reqText
)
)
)
.
map
(
c
=
>
:
{
c
}
)
;
}
else
{
if
(
frameActorId
)
{
const
frameActor
=
this
.
conn
.
getActor
(
frameActorId
)
;
try
{
const
frame
=
frameActor
.
frame
;
environment
=
frame
.
environment
;
}
catch
(
e
)
{
DevToolsUtils
.
reportException
(
"
autocomplete
"
Error
(
"
The
frame
actor
was
not
found
:
"
+
frameActorId
)
)
;
}
}
else
{
hadDebuggee
=
this
.
dbg
.
hasDebuggee
(
this
.
evalWindow
)
;
dbgObject
=
this
.
dbg
.
addDebuggee
(
this
.
evalWindow
)
;
}
const
result
=
JSPropertyProvider
(
dbgObject
environment
request
.
text
request
.
cursor
frameActorId
)
|
|
{
}
;
if
(
!
hadDebuggee
&
&
dbgObject
)
{
this
.
dbg
.
removeDebuggee
(
this
.
evalWindow
)
;
}
matches
=
result
.
matches
|
|
[
]
;
matchProp
=
result
.
matchProp
;
const
lastNonAlphaIsDot
=
/
[
.
]
[
a
-
zA
-
Z0
-
9
]
*
/
.
test
(
reqText
)
;
if
(
!
lastNonAlphaIsDot
)
{
matches
=
matches
.
concat
(
this
.
_getWebConsoleCommandsCache
(
)
.
filter
(
n
=
>
n
!
=
=
"
screenshot
"
&
&
n
.
startsWith
(
result
.
matchProp
)
)
)
;
}
}
matches
=
[
.
.
.
new
Set
(
matches
)
]
.
sort
(
)
;
return
{
from
:
this
.
actorID
matches
matchProp
}
;
}
clearMessagesCache
:
function
(
)
{
const
windowId
=
!
this
.
parentActor
.
isRootActor
?
WebConsoleUtils
.
getInnerWindowId
(
this
.
window
)
:
null
;
const
ConsoleAPIStorage
=
Cc
[
"
mozilla
.
org
/
consoleAPI
-
storage
;
1
"
]
.
getService
(
Ci
.
nsIConsoleAPIStorage
)
;
ConsoleAPIStorage
.
clearEvents
(
windowId
)
;
CONSOLE_WORKER_IDS
.
forEach
(
(
id
)
=
>
{
ConsoleAPIStorage
.
clearEvents
(
id
)
;
}
)
;
if
(
this
.
parentActor
.
isRootActor
)
{
Services
.
console
.
logStringMessage
(
null
)
;
Services
.
console
.
reset
(
)
;
}
return
{
}
;
}
getPreferences
:
function
(
request
)
{
const
prefs
=
Object
.
create
(
null
)
;
for
(
const
key
of
request
.
preferences
)
{
prefs
[
key
]
=
this
.
_prefs
[
key
]
;
}
return
{
preferences
:
prefs
}
;
}
setPreferences
:
function
(
request
)
{
for
(
const
key
in
request
.
preferences
)
{
this
.
_prefs
[
key
]
=
request
.
preferences
[
key
]
;
if
(
this
.
networkMonitor
)
{
if
(
key
=
=
"
NetworkMonitor
.
saveRequestAndResponseBodies
"
)
{
this
.
networkMonitor
.
saveRequestAndResponseBodies
=
this
.
_prefs
[
key
]
;
if
(
this
.
networkMonitorChild
)
{
this
.
networkMonitorChild
.
saveRequestAndResponseBodies
=
this
.
_prefs
[
key
]
;
}
}
else
if
(
key
=
=
"
NetworkMonitor
.
throttleData
"
)
{
this
.
networkMonitor
.
throttleData
=
this
.
_prefs
[
key
]
;
if
(
this
.
networkMonitorChild
)
{
this
.
networkMonitorChild
.
throttleData
=
this
.
_prefs
[
key
]
;
}
}
}
}
return
{
updated
:
Object
.
keys
(
request
.
preferences
)
}
;
}
_getWebConsoleCommands
:
function
(
debuggerGlobal
)
{
const
helpers
=
{
window
:
this
.
evalWindow
chromeWindow
:
this
.
chromeWindow
.
bind
(
this
)
makeDebuggeeValue
:
debuggerGlobal
.
makeDebuggeeValue
.
bind
(
debuggerGlobal
)
createValueGrip
:
this
.
createValueGrip
.
bind
(
this
)
sandbox
:
Object
.
create
(
null
)
helperResult
:
null
consoleActor
:
this
}
;
addWebConsoleCommands
(
helpers
)
;
const
evalWindow
=
this
.
evalWindow
;
function
maybeExport
(
obj
name
)
{
if
(
typeof
obj
[
name
]
!
=
"
function
"
)
{
return
;
}
obj
[
name
]
=
Cu
.
exportFunction
(
obj
[
name
]
evalWindow
{
allowCrossOriginArguments
:
true
}
)
;
}
for
(
const
name
in
helpers
.
sandbox
)
{
const
desc
=
Object
.
getOwnPropertyDescriptor
(
helpers
.
sandbox
name
)
;
if
(
!
isWorker
)
{
maybeExport
(
desc
"
get
"
)
;
maybeExport
(
desc
"
set
"
)
;
maybeExport
(
desc
"
value
"
)
;
}
if
(
desc
.
value
)
{
desc
.
value
=
debuggerGlobal
.
makeDebuggeeValue
(
desc
.
value
)
;
}
Object
.
defineProperty
(
helpers
.
sandbox
name
desc
)
;
}
return
helpers
;
}
_getWebConsoleCommandsCache
:
function
(
)
{
if
(
!
this
.
_webConsoleCommandsCache
)
{
const
helpers
=
{
sandbox
:
Object
.
create
(
null
)
}
;
addWebConsoleCommands
(
helpers
)
;
this
.
_webConsoleCommandsCache
=
Object
.
getOwnPropertyNames
(
helpers
.
sandbox
)
;
}
return
this
.
_webConsoleCommandsCache
;
}
evalWithDebugger
:
function
(
string
options
=
{
}
)
{
const
trimmedString
=
string
.
trim
(
)
;
if
(
trimmedString
=
=
"
help
"
|
|
trimmedString
=
=
"
?
"
)
{
string
=
"
help
(
)
"
;
}
const
isCmd
=
isCommand
(
string
)
;
if
(
isCmd
)
{
try
{
string
=
formatCommand
(
string
)
;
}
catch
(
e
)
{
string
=
throw
"
{
e
}
"
;
}
}
if
(
trimmedString
=
=
"
console
.
mihai
(
)
"
|
|
trimmedString
=
=
"
console
.
mihai
(
)
;
"
)
{
string
=
"
\
"
http
:
/
/
incompleteness
.
me
/
blog
/
2015
/
02
/
09
/
console
-
dot
-
mihai
/
\
"
"
;
}
let
frame
=
null
frameActor
=
null
;
if
(
options
.
frameActor
)
{
frameActor
=
this
.
conn
.
getActor
(
options
.
frameActor
)
;
if
(
frameActor
)
{
frame
=
frameActor
.
frame
;
}
else
{
DevToolsUtils
.
reportException
(
"
evalWithDebugger
"
Error
(
"
The
frame
actor
was
not
found
:
"
+
options
.
frameActor
)
)
;
}
}
const
dbg
=
frame
?
frameActor
.
threadActor
.
dbg
:
this
.
dbg
;
if
(
dbg
.
replaying
)
{
let
result
;
if
(
frame
)
{
try
{
result
=
frame
.
eval
(
string
)
;
}
catch
(
e
)
{
result
=
{
"
throw
"
:
e
}
;
}
}
else
{
result
=
{
"
throw
"
:
"
Cannot
evaluate
while
replaying
without
a
frame
"
}
;
}
return
{
result
:
result
helperResult
:
null
dbg
:
dbg
frame
:
frame
window
:
null
}
;
}
let
dbgWindow
=
dbg
.
makeGlobalObjectReference
(
this
.
evalWindow
)
;
let
bindSelf
=
null
;
if
(
options
.
bindObjectActor
|
|
options
.
selectedObjectActor
)
{
const
objActor
=
this
.
getActorByID
(
options
.
bindObjectActor
|
|
options
.
selectedObjectActor
)
;
if
(
objActor
)
{
const
jsVal
=
objActor
.
rawValue
(
)
;
if
(
isObject
(
jsVal
)
)
{
bindSelf
=
dbgWindow
.
makeDebuggeeValue
(
jsVal
)
;
if
(
options
.
bindObjectActor
)
{
const
global
=
Cu
.
getGlobalForObject
(
jsVal
)
;
try
{
const
_dbgWindow
=
dbg
.
makeGlobalObjectReference
(
global
)
;
dbgWindow
=
_dbgWindow
;
}
catch
(
err
)
{
}
}
}
else
{
bindSelf
=
jsVal
;
}
}
}
const
helpers
=
this
.
_getWebConsoleCommands
(
dbgWindow
)
;
const
bindings
=
helpers
.
sandbox
;
if
(
bindSelf
)
{
bindings
.
_self
=
bindSelf
;
}
if
(
options
.
selectedNodeActor
)
{
const
actor
=
this
.
conn
.
getActor
(
options
.
selectedNodeActor
)
;
if
(
actor
)
{
helpers
.
selectedNode
=
actor
.
rawNode
;
}
}
const
availableHelpers
=
[
.
.
.
WebConsoleCommands
.
_originalCommands
.
keys
(
)
]
.
filter
(
h
=
>
h
!
=
=
"
print
"
)
;
let
helpersToDisable
=
[
]
;
const
helperCache
=
{
}
;
if
(
!
isCmd
)
{
if
(
frame
)
{
const
env
=
frame
.
environment
;
if
(
env
)
{
helpersToDisable
=
availableHelpers
.
filter
(
name
=
>
!
!
env
.
find
(
name
)
)
;
}
}
else
{
helpersToDisable
=
availableHelpers
.
filter
(
name
=
>
!
!
dbgWindow
.
getOwnPropertyDescriptor
(
name
)
)
;
}
helpersToDisable
.
push
(
"
screenshot
"
)
;
}
for
(
const
helper
of
helpersToDisable
)
{
helperCache
[
helper
]
=
bindings
[
helper
]
;
delete
bindings
[
helper
]
;
}
helpers
.
evalInput
=
string
;
let
evalOptions
;
if
(
typeof
options
.
url
=
=
"
string
"
)
{
evalOptions
=
{
url
:
options
.
url
}
;
}
if
(
this
.
_lastConsoleInputEvaluation
)
{
this
.
_lastConsoleInputEvaluation
=
dbg
.
adoptDebuggeeValue
(
this
.
_lastConsoleInputEvaluation
)
;
}
let
result
;
if
(
frame
)
{
result
=
frame
.
evalWithBindings
(
string
bindings
evalOptions
)
;
}
else
{
result
=
dbgWindow
.
executeInGlobalWithBindings
(
string
bindings
evalOptions
)
;
if
(
"
throw
"
in
result
)
{
let
ast
;
try
{
ast
=
Parser
.
reflectionAPI
.
parse
(
string
)
;
}
catch
(
ex
)
{
ast
=
{
"
body
"
:
[
]
}
;
}
for
(
const
line
of
ast
.
body
)
{
if
(
!
(
line
.
kind
=
=
"
let
"
|
|
line
.
kind
=
=
"
const
"
)
)
{
continue
;
}
const
identifiers
=
[
]
;
for
(
const
decl
of
line
.
declarations
)
{
switch
(
decl
.
id
.
type
)
{
case
"
Identifier
"
:
identifiers
.
push
(
decl
.
id
.
name
)
;
break
;
case
"
ArrayPattern
"
:
for
(
const
e
of
decl
.
id
.
elements
)
{
if
(
e
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
e
.
name
)
;
}
else
if
(
e
.
type
=
=
"
AssignmentExpression
"
)
{
identifiers
.
push
(
e
.
left
.
name
)
;
}
}
break
;
case
"
ObjectPattern
"
:
for
(
const
prop
of
decl
.
id
.
properties
)
{
if
(
prop
.
key
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
prop
.
key
.
name
)
;
}
if
(
prop
.
value
.
type
=
=
"
Identifier
"
)
{
identifiers
.
push
(
prop
.
value
.
name
)
;
}
else
if
(
prop
.
value
.
type
=
=
"
AssignmentExpression
"
)
{
identifiers
.
push
(
prop
.
value
.
left
.
name
)
;
}
}
break
;
}
}
for
(
const
name
of
identifiers
)
{
dbgWindow
.
forceLexicalInitializationByName
(
name
)
;
}
}
}
}
const
helperResult
=
helpers
.
helperResult
;
delete
helpers
.
evalInput
;
delete
helpers
.
helperResult
;
delete
helpers
.
selectedNode
;
for
(
const
[
helperName
helper
]
of
Object
.
entries
(
helperCache
)
)
{
bindings
[
helperName
]
=
helper
;
}
if
(
bindings
.
_self
)
{
delete
bindings
.
_self
;
}
return
{
result
:
result
helperResult
:
helperResult
dbg
:
dbg
frame
:
frame
window
:
dbgWindow
}
;
}
onConsoleServiceMessage
:
function
(
message
)
{
let
packet
;
if
(
message
instanceof
Ci
.
nsIScriptError
)
{
packet
=
{
from
:
this
.
actorID
type
:
"
pageError
"
pageError
:
this
.
preparePageErrorForRemote
(
message
)
}
;
}
else
{
packet
=
{
from
:
this
.
actorID
type
:
"
logMessage
"
message
:
this
.
_createStringGrip
(
message
.
message
)
timeStamp
:
message
.
timeStamp
}
;
}
this
.
conn
.
send
(
packet
)
;
}
preparePageErrorForRemote
:
function
(
pageError
)
{
let
stack
=
null
;
if
(
pageError
.
stack
&
&
!
Cu
.
isDeadWrapper
(
pageError
.
stack
)
)
{
stack
=
[
]
;
let
s
=
pageError
.
stack
;
while
(
s
!
=
=
null
)
{
stack
.
push
(
{
filename
:
s
.
source
lineNumber
:
s
.
line
columnNumber
:
s
.
column
functionName
:
s
.
functionDisplayName
}
)
;
s
=
s
.
parent
;
}
}
let
lineText
=
pageError
.
sourceLine
;
if
(
lineText
&
&
lineText
.
length
>
DebuggerServer
.
LONG_STRING_INITIAL_LENGTH
)
{
lineText
=
lineText
.
substr
(
0
DebuggerServer
.
LONG_STRING_INITIAL_LENGTH
)
;
}
let
notesArray
=
null
;
const
notes
=
pageError
.
notes
;
if
(
notes
&
&
notes
.
length
)
{
notesArray
=
[
]
;
for
(
let
i
=
0
len
=
notes
.
length
;
i
<
len
;
i
+
+
)
{
const
note
=
notes
.
queryElementAt
(
i
Ci
.
nsIScriptErrorNote
)
;
notesArray
.
push
(
{
messageBody
:
this
.
_createStringGrip
(
note
.
errorMessage
)
frame
:
{
source
:
note
.
sourceName
line
:
note
.
lineNumber
column
:
note
.
columnNumber
}
}
)
;
}
}
return
{
errorMessage
:
this
.
_createStringGrip
(
pageError
.
errorMessage
)
errorMessageName
:
pageError
.
errorMessageName
exceptionDocURL
:
ErrorDocs
.
GetURL
(
pageError
)
sourceName
:
pageError
.
sourceName
lineText
:
lineText
lineNumber
:
pageError
.
lineNumber
columnNumber
:
pageError
.
columnNumber
category
:
pageError
.
category
timeStamp
:
pageError
.
timeStamp
warning
:
!
!
(
pageError
.
flags
&
pageError
.
warningFlag
)
error
:
!
!
(
pageError
.
flags
&
pageError
.
errorFlag
)
exception
:
!
!
(
pageError
.
flags
&
pageError
.
exceptionFlag
)
strict
:
!
!
(
pageError
.
flags
&
pageError
.
strictFlag
)
info
:
!
!
(
pageError
.
flags
&
pageError
.
infoFlag
)
private
:
pageError
.
isFromPrivateWindow
stacktrace
:
stack
notes
:
notesArray
}
;
}
onConsoleAPICall
:
function
(
message
)
{
const
packet
=
{
from
:
this
.
actorID
type
:
"
consoleAPICall
"
message
:
this
.
prepareConsoleMessageForRemote
(
message
)
}
;
this
.
conn
.
send
(
packet
)
;
}
getRequestContentForURL
(
url
)
{
if
(
this
.
networkMonitorActor
)
{
return
this
.
networkMonitorActor
.
getRequestContentForURL
(
url
)
;
}
else
if
(
this
.
networkMonitorActorId
)
{
const
messageManager
=
this
.
parentActor
.
messageManager
;
return
new
Promise
(
resolve
=
>
{
const
onMessage
=
(
{
data
}
)
=
>
{
if
(
data
.
url
=
=
url
)
{
messageManager
.
removeMessageListener
(
"
debug
:
request
-
content
"
onMessage
)
;
resolve
(
data
.
content
)
;
}
}
;
messageManager
.
addMessageListener
(
"
debug
:
request
-
content
"
onMessage
)
;
messageManager
.
sendAsyncMessage
(
"
debug
:
request
-
content
"
{
url
}
)
;
}
)
;
}
return
null
;
}
sendHTTPRequest
(
message
)
{
const
{
url
method
headers
body
}
=
message
.
request
;
const
doc
=
this
.
window
.
document
;
const
channel
=
NetUtil
.
newChannel
(
{
uri
:
NetUtil
.
newURI
(
url
)
loadingNode
:
doc
securityFlags
:
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_OTHER
}
)
;
channel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
channel
.
loadGroup
=
doc
.
documentLoadGroup
;
channel
.
loadFlags
|
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
|
Ci
.
nsIRequest
.
INHIBIT_CACHING
|
Ci
.
nsIRequest
.
LOAD_ANONYMOUS
;
channel
.
requestMethod
=
method
;
for
(
const
{
name
value
}
of
headers
)
{
channel
.
setRequestHeader
(
name
value
false
)
;
}
if
(
body
)
{
channel
.
QueryInterface
(
Ci
.
nsIUploadChannel2
)
;
const
bodyStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
bodyStream
.
setData
(
body
body
.
length
)
;
channel
.
explicitSetUploadStream
(
bodyStream
null
-
1
method
false
)
;
}
NetUtil
.
asyncFetch
(
channel
(
)
=
>
{
}
)
;
const
actor
=
this
.
getNetworkEventActor
(
channel
.
channelId
)
;
this
.
_netEvents
.
set
(
channel
.
channelId
actor
)
;
return
{
from
:
this
.
actorID
eventActor
:
actor
.
form
(
)
}
;
}
onFileActivity
:
function
(
fileURI
)
{
const
packet
=
{
from
:
this
.
actorID
type
:
"
fileActivity
"
uri
:
fileURI
}
;
this
.
conn
.
send
(
packet
)
;
}
onReflowActivity
:
function
(
reflowInfo
)
{
const
packet
=
{
from
:
this
.
actorID
type
:
"
reflowActivity
"
interruptible
:
reflowInfo
.
interruptible
start
:
reflowInfo
.
start
end
:
reflowInfo
.
end
sourceURL
:
reflowInfo
.
sourceURL
sourceLine
:
reflowInfo
.
sourceLine
functionName
:
reflowInfo
.
functionName
}
;
this
.
conn
.
send
(
packet
)
;
}
prepareConsoleMessageForRemote
:
function
(
message
useObjectGlobal
=
true
)
{
const
result
=
WebConsoleUtils
.
cloneObject
(
message
)
;
result
.
workerType
=
WebConsoleUtils
.
getWorkerType
(
result
)
|
|
"
none
"
;
delete
result
.
wrappedJSObject
;
delete
result
.
ID
;
delete
result
.
innerID
;
delete
result
.
consoleID
;
result
.
arguments
=
Array
.
map
(
message
.
arguments
|
|
[
]
(
obj
)
=
>
{
const
dbgObj
=
this
.
makeDebuggeeValue
(
obj
useObjectGlobal
)
;
return
this
.
createValueGrip
(
dbgObj
)
;
}
)
;
result
.
styles
=
Array
.
map
(
message
.
styles
|
|
[
]
(
string
)
=
>
{
return
this
.
createValueGrip
(
string
)
;
}
)
;
result
.
category
=
message
.
category
|
|
"
webdev
"
;
return
result
;
}
chromeWindow
:
function
(
)
{
let
window
=
null
;
try
{
window
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
.
chromeEventHandler
.
ownerGlobal
;
}
catch
(
ex
)
{
}
return
window
;
}
_onObserverNotification
:
function
(
subject
topic
)
{
switch
(
topic
)
{
case
"
last
-
pb
-
context
-
exited
"
:
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
lastPrivateContextExited
"
}
)
;
break
;
}
}
_onWillNavigate
:
function
(
{
window
isTopLevel
}
)
{
if
(
isTopLevel
)
{
this
.
_evalWindow
=
null
;
EventEmitter
.
off
(
this
.
parentActor
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_progressListenerActive
=
false
;
}
}
_onChangedToplevelDocument
:
function
(
)
{
const
listeners
=
[
.
.
.
this
.
_listeners
]
;
this
.
stopListeners
(
{
listeners
:
listeners
.
slice
(
)
}
)
;
this
.
startListeners
(
{
listeners
:
listeners
}
)
;
this
.
_lastChromeWindow
=
null
;
}
}
;
WebConsoleActor
.
prototype
.
requestTypes
=
{
startListeners
:
WebConsoleActor
.
prototype
.
startListeners
stopListeners
:
WebConsoleActor
.
prototype
.
stopListeners
getCachedMessages
:
WebConsoleActor
.
prototype
.
getCachedMessages
evaluateJS
:
WebConsoleActor
.
prototype
.
evaluateJS
evaluateJSAsync
:
WebConsoleActor
.
prototype
.
evaluateJSAsync
autocomplete
:
WebConsoleActor
.
prototype
.
autocomplete
clearMessagesCache
:
WebConsoleActor
.
prototype
.
clearMessagesCache
getPreferences
:
WebConsoleActor
.
prototype
.
getPreferences
setPreferences
:
WebConsoleActor
.
prototype
.
setPreferences
sendHTTPRequest
:
WebConsoleActor
.
prototype
.
sendHTTPRequest
}
;
exports
.
WebConsoleActor
=
WebConsoleActor
;
