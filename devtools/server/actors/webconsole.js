"
use
strict
"
;
const
{
ActorClassWithSpec
Actor
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
webconsoleSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
webconsole
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
{
DevToolsServer
}
=
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
const
{
ThreadActor
}
=
require
(
"
devtools
/
server
/
actors
/
thread
"
)
;
const
{
ObjectActor
}
=
require
(
"
devtools
/
server
/
actors
/
object
"
)
;
const
{
LongStringActor
}
=
require
(
"
devtools
/
server
/
actors
/
string
"
)
;
const
{
createValueGrip
isArray
stringIsLong
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
ErrorDocs
=
require
(
"
devtools
/
server
/
actors
/
errordocs
"
)
;
loader
.
lazyRequireGetter
(
this
"
evalWithDebugger
"
"
devtools
/
server
/
actors
/
webconsole
/
eval
-
with
-
debugger
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkMonitorActor
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
network
-
monitor
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleFileActivityListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
/
console
-
file
-
activity
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
StackTraceCollector
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
stack
-
trace
-
collector
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
JSPropertyProvider
"
"
devtools
/
shared
/
webconsole
/
js
-
property
-
provider
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
addWebConsoleCommands
"
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isCommand
"
"
devtools
/
server
/
actors
/
webconsole
/
commands
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
validCommands
"
"
devtools
/
server
/
actors
/
webconsole
/
commands
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
createMessageManagerMocks
"
"
devtools
/
server
/
actors
/
webconsole
/
message
-
manager
-
mock
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CONSOLE_WORKER_IDS
"
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebConsoleUtils
"
"
devtools
/
server
/
actors
/
webconsole
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EnvironmentActor
"
"
devtools
/
server
/
actors
/
environment
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
stringToCauseType
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
network
-
observer
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
RESERVED_JS_KEYWORDS
"
"
devtools
/
shared
/
webconsole
/
reserved
-
js
-
words
"
)
;
if
(
isWorker
)
{
loader
.
lazyRequireGetter
(
this
"
ConsoleAPIListener
"
"
devtools
/
server
/
actors
/
webconsole
/
worker
-
listeners
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleServiceListener
"
"
devtools
/
server
/
actors
/
webconsole
/
worker
-
listeners
"
true
)
;
}
else
{
loader
.
lazyRequireGetter
(
this
"
ConsoleAPIListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
/
console
-
api
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleServiceListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
/
console
-
service
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleReflowListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
/
console
-
reflow
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ContentProcessListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
/
content
-
process
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DocumentEventsListener
"
"
devtools
/
server
/
actors
/
webconsole
/
listeners
/
document
-
events
"
true
)
;
}
function
isObject
(
value
)
{
return
Object
(
value
)
=
=
=
value
;
}
const
WebConsoleActor
=
ActorClassWithSpec
(
webconsoleSpec
{
initialize
:
function
(
connection
parentActor
)
{
Actor
.
prototype
.
initialize
.
call
(
this
connection
)
;
this
.
conn
=
connection
;
this
.
parentActor
=
parentActor
;
this
.
_prefs
=
{
}
;
this
.
dbg
=
this
.
parentActor
.
dbg
;
this
.
_gripDepth
=
0
;
this
.
_evalCounter
=
0
;
this
.
_listeners
=
new
Set
(
)
;
this
.
_lastConsoleInputEvaluation
=
undefined
;
this
.
objectGrip
=
this
.
objectGrip
.
bind
(
this
)
;
this
.
_onWillNavigate
=
this
.
_onWillNavigate
.
bind
(
this
)
;
this
.
_onChangedToplevelDocument
=
this
.
_onChangedToplevelDocument
.
bind
(
this
)
;
this
.
onConsoleServiceMessage
=
this
.
onConsoleServiceMessage
.
bind
(
this
)
;
this
.
onConsoleAPICall
=
this
.
onConsoleAPICall
.
bind
(
this
)
;
EventEmitter
.
on
(
this
.
parentActor
"
changed
-
toplevel
-
document
"
this
.
_onChangedToplevelDocument
)
;
this
.
_onObserverNotification
=
this
.
_onObserverNotification
.
bind
(
this
)
;
if
(
this
.
parentActor
.
isRootActor
)
{
Services
.
obs
.
addObserver
(
this
.
_onObserverNotification
"
last
-
pb
-
context
-
exited
"
)
;
}
this
.
traits
=
{
newCacheStructure
:
true
blockedUrls
:
true
}
;
}
dbg
:
null
_gripDepth
:
null
_prefs
:
null
_listeners
:
null
conn
:
null
traits
:
null
get
window
(
)
{
if
(
this
.
parentActor
.
isRootActor
)
{
return
this
.
_getWindowForBrowserConsole
(
)
;
}
return
this
.
parentActor
.
window
;
}
_getWindowForBrowserConsole
:
function
(
)
{
let
window
=
this
.
_lastChromeWindow
&
&
this
.
_lastChromeWindow
.
get
(
)
;
if
(
!
window
|
|
window
.
closed
)
{
window
=
this
.
parentActor
.
window
;
if
(
!
window
)
{
window
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webconsole
"
)
;
const
onChromeWindowOpened
=
(
)
=
>
{
Services
.
obs
.
removeObserver
(
onChromeWindowOpened
"
domwindowopened
"
)
;
this
.
_lastChromeWindow
=
null
;
}
;
Services
.
obs
.
addObserver
(
onChromeWindowOpened
"
domwindowopened
"
)
;
}
this
.
_handleNewWindow
(
window
)
;
}
return
window
;
}
_handleNewWindow
:
function
(
window
)
{
if
(
window
)
{
if
(
this
.
_hadChromeWindow
)
{
Services
.
console
.
logStringMessage
(
"
Webconsole
context
has
changed
"
)
;
}
this
.
_lastChromeWindow
=
Cu
.
getWeakReference
(
window
)
;
this
.
_hadChromeWindow
=
true
;
}
else
{
this
.
_lastChromeWindow
=
null
;
}
}
_hadChromeWindow
:
false
_lastChromeWindow
:
null
_evalWindow
:
null
get
evalWindow
(
)
{
return
this
.
_evalWindow
|
|
this
.
window
;
}
set
evalWindow
(
window
)
{
this
.
_evalWindow
=
window
;
if
(
!
this
.
_progressListenerActive
)
{
EventEmitter
.
on
(
this
.
parentActor
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_progressListenerActive
=
true
;
}
}
_progressListenerActive
:
false
consoleServiceListener
:
null
consoleAPIListener
:
null
consoleFileActivityListener
:
null
consoleReflowListener
:
null
_webConsoleCommandsCache
:
null
typeName
:
"
console
"
grip
:
function
(
)
{
return
{
actor
:
this
.
actorID
}
;
}
hasNativeConsoleAPI
:
function
(
window
)
{
if
(
isWorker
|
|
!
(
window
instanceof
Ci
.
nsIDOMWindow
)
)
{
return
true
;
}
let
isNative
=
false
;
try
{
const
console
=
window
.
wrappedJSObject
.
console
;
if
(
console
)
{
isNative
=
new
XPCNativeWrapper
(
console
)
.
IS_NATIVE_CONSOLE
;
}
}
catch
(
ex
)
{
}
return
isNative
;
}
_findProtoChain
:
ThreadActor
.
prototype
.
_findProtoChain
_removeFromProtoChain
:
ThreadActor
.
prototype
.
_removeFromProtoChain
destroy
(
)
{
this
.
stopListeners
(
)
;
Actor
.
prototype
.
destroy
.
call
(
this
)
;
EventEmitter
.
off
(
this
.
parentActor
"
changed
-
toplevel
-
document
"
this
.
_onChangedToplevelDocument
)
;
if
(
this
.
parentActor
.
isRootActor
)
{
Services
.
obs
.
removeObserver
(
this
.
_onObserverNotification
"
last
-
pb
-
context
-
exited
"
)
;
}
this
.
_webConsoleCommandsCache
=
null
;
this
.
_lastConsoleInputEvaluation
=
null
;
this
.
_evalWindow
=
null
;
this
.
dbg
=
null
;
this
.
conn
=
null
;
}
createEnvironmentActor
:
function
(
environment
)
{
if
(
!
environment
)
{
return
undefined
;
}
if
(
environment
.
actor
)
{
return
environment
.
actor
;
}
const
actor
=
new
EnvironmentActor
(
environment
this
)
;
this
.
manage
(
actor
)
;
environment
.
actor
=
actor
;
return
actor
;
}
createValueGrip
:
function
(
value
)
{
return
createValueGrip
(
value
this
this
.
objectGrip
)
;
}
makeDebuggeeValue
:
function
(
value
useObjectGlobal
)
{
if
(
useObjectGlobal
&
&
isObject
(
value
)
)
{
try
{
const
global
=
Cu
.
getGlobalForObject
(
value
)
;
const
dbgGlobal
=
this
.
dbg
.
makeGlobalObjectReference
(
global
)
;
return
dbgGlobal
.
makeDebuggeeValue
(
value
)
;
}
catch
(
ex
)
{
}
}
const
dbgGlobal
=
this
.
dbg
.
makeGlobalObjectReference
(
this
.
window
)
;
return
dbgGlobal
.
makeDebuggeeValue
(
value
)
;
}
objectGrip
:
function
(
object
pool
)
{
const
actor
=
new
ObjectActor
(
object
{
thread
:
this
.
parentActor
.
threadActor
getGripDepth
:
(
)
=
>
this
.
_gripDepth
incrementGripDepth
:
(
)
=
>
this
.
_gripDepth
+
+
decrementGripDepth
:
(
)
=
>
this
.
_gripDepth
-
-
createValueGrip
:
v
=
>
this
.
createValueGrip
(
v
)
sources
:
(
)
=
>
DevToolsUtils
.
reportException
(
"
WebConsoleActor
"
Error
(
"
sources
not
yet
implemented
"
)
)
createEnvironmentActor
:
env
=
>
this
.
createEnvironmentActor
(
env
)
}
this
.
conn
)
;
pool
.
manage
(
actor
)
;
return
actor
.
form
(
)
;
}
longStringGrip
:
function
(
string
pool
)
{
const
actor
=
new
LongStringActor
(
this
.
conn
string
)
;
pool
.
manage
(
actor
)
;
return
actor
.
form
(
)
;
}
_createStringGrip
:
function
(
string
)
{
if
(
string
&
&
stringIsLong
(
string
)
)
{
return
this
.
longStringGrip
(
string
this
)
;
}
return
string
;
}
getLastConsoleInputEvaluation
:
function
(
)
{
return
this
.
_lastConsoleInputEvaluation
;
}
preprocessDebuggerObject
(
dbgObj
)
{
if
(
dbgObj
?
.
isBoundFunction
&
&
dbgObj
?
.
boundTargetFunction
)
{
return
dbgObj
.
boundTargetFunction
;
}
return
dbgObj
;
}
inspectObject
(
dbgObj
inspectFromAnnotation
)
{
dbgObj
=
this
.
preprocessDebuggerObject
(
dbgObj
)
;
this
.
emit
(
"
inspectObject
"
{
objectActor
:
this
.
createValueGrip
(
dbgObj
)
inspectFromAnnotation
}
)
;
}
startListeners
:
async
function
(
listeners
)
{
const
startedListeners
=
[
]
;
const
window
=
!
this
.
parentActor
.
isRootActor
?
this
.
window
:
null
;
for
(
const
event
of
listeners
)
{
switch
(
event
)
{
case
"
PageError
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
consoleServiceListener
)
{
this
.
consoleServiceListener
=
new
ConsoleServiceListener
(
window
this
.
onConsoleServiceMessage
)
;
this
.
consoleServiceListener
.
init
(
)
;
}
startedListeners
.
push
(
event
)
;
break
;
case
"
ConsoleAPI
"
:
if
(
!
this
.
consoleAPIListener
)
{
this
.
consoleAPIListener
=
new
ConsoleAPIListener
(
window
this
.
onConsoleAPICall
this
.
parentActor
.
consoleAPIListenerOptions
)
;
this
.
consoleAPIListener
.
init
(
)
;
}
startedListeners
.
push
(
event
)
;
break
;
case
"
NetworkActivity
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
netmonitors
)
{
const
[
mmMockParent
mmMockChild
]
=
createMessageManagerMocks
(
)
;
this
.
netmonitors
=
[
]
;
const
isInContentProcess
=
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
&
&
this
.
parentActor
.
messageManager
;
if
(
isInContentProcess
)
{
await
this
.
conn
.
spawnActorInParentProcess
(
this
.
actorID
{
module
:
"
devtools
/
server
/
actors
/
network
-
monitor
/
network
-
monitor
"
constructor
:
"
NetworkMonitorActor
"
args
:
[
{
browsingContextID
:
this
.
parentActor
.
browsingContextID
}
this
.
actorID
]
}
)
;
this
.
netmonitors
.
push
(
{
messageManager
:
this
.
parentActor
.
messageManager
parentProcess
:
true
}
)
;
}
new
NetworkMonitorActor
(
this
.
conn
{
window
}
this
.
actorID
mmMockParent
)
;
this
.
netmonitors
.
push
(
{
messageManager
:
mmMockChild
parentProcess
:
!
isInContentProcess
}
)
;
this
.
stackTraceCollector
=
new
StackTraceCollector
(
{
window
}
this
.
netmonitors
)
;
this
.
stackTraceCollector
.
init
(
)
;
}
startedListeners
.
push
(
event
)
;
break
;
case
"
FileActivity
"
:
if
(
isWorker
)
{
break
;
}
if
(
this
.
window
instanceof
Ci
.
nsIDOMWindow
)
{
if
(
!
this
.
consoleFileActivityListener
)
{
this
.
consoleFileActivityListener
=
new
ConsoleFileActivityListener
(
this
.
window
this
)
;
}
this
.
consoleFileActivityListener
.
startMonitor
(
)
;
startedListeners
.
push
(
event
)
;
}
break
;
case
"
ReflowActivity
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
consoleReflowListener
)
{
this
.
consoleReflowListener
=
new
ConsoleReflowListener
(
this
.
window
this
)
;
}
startedListeners
.
push
(
event
)
;
break
;
case
"
ContentProcessMessages
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
contentProcessListener
)
{
this
.
contentProcessListener
=
new
ContentProcessListener
(
this
.
onConsoleAPICall
)
;
}
startedListeners
.
push
(
event
)
;
break
;
case
"
DocumentEvents
"
:
if
(
isWorker
)
{
break
;
}
if
(
!
this
.
documentEventsListener
)
{
this
.
documentEventsListener
=
new
DocumentEventsListener
(
this
)
;
}
startedListeners
.
push
(
event
)
;
break
;
}
}
startedListeners
.
forEach
(
this
.
_listeners
.
add
this
.
_listeners
)
;
return
{
startedListeners
:
startedListeners
nativeConsoleAPI
:
this
.
hasNativeConsoleAPI
(
this
.
window
)
traits
:
this
.
traits
}
;
}
stopListeners
:
function
(
listeners
)
{
const
stoppedListeners
=
[
]
;
const
eventsToDetach
=
listeners
|
|
[
"
PageError
"
"
ConsoleAPI
"
"
NetworkActivity
"
"
FileActivity
"
"
ReflowActivity
"
"
ContentProcessMessages
"
"
DocumentEvents
"
]
;
for
(
const
event
of
eventsToDetach
)
{
switch
(
event
)
{
case
"
PageError
"
:
if
(
this
.
consoleServiceListener
)
{
this
.
consoleServiceListener
.
destroy
(
)
;
this
.
consoleServiceListener
=
null
;
}
stoppedListeners
.
push
(
event
)
;
break
;
case
"
ConsoleAPI
"
:
if
(
this
.
consoleAPIListener
)
{
this
.
consoleAPIListener
.
destroy
(
)
;
this
.
consoleAPIListener
=
null
;
}
stoppedListeners
.
push
(
event
)
;
break
;
case
"
NetworkActivity
"
:
if
(
this
.
netmonitors
)
{
for
(
const
{
messageManager
}
of
this
.
netmonitors
)
{
messageManager
.
sendAsyncMessage
(
"
debug
:
destroy
-
network
-
monitor
"
{
actorID
:
this
.
actorID
}
)
;
}
this
.
netmonitors
=
null
;
}
if
(
this
.
stackTraceCollector
)
{
this
.
stackTraceCollector
.
destroy
(
)
;
this
.
stackTraceCollector
=
null
;
}
stoppedListeners
.
push
(
event
)
;
break
;
case
"
FileActivity
"
:
if
(
this
.
consoleFileActivityListener
)
{
this
.
consoleFileActivityListener
.
stopMonitor
(
)
;
this
.
consoleFileActivityListener
=
null
;
}
stoppedListeners
.
push
(
event
)
;
break
;
case
"
ReflowActivity
"
:
if
(
this
.
consoleReflowListener
)
{
this
.
consoleReflowListener
.
destroy
(
)
;
this
.
consoleReflowListener
=
null
;
}
stoppedListeners
.
push
(
event
)
;
break
;
case
"
ContentProcessMessages
"
:
if
(
this
.
contentProcessListener
)
{
this
.
contentProcessListener
.
destroy
(
)
;
this
.
contentProcessListener
=
null
;
}
stoppedListeners
.
push
(
event
)
;
break
;
case
"
DocumentEvents
"
:
if
(
this
.
documentEventsListener
)
{
this
.
documentEventsListener
.
destroy
(
)
;
this
.
documentEventsListener
=
null
;
}
stoppedListeners
.
push
(
event
)
;
break
;
}
}
stoppedListeners
.
forEach
(
this
.
_listeners
.
delete
this
.
_listeners
)
;
return
{
stoppedListeners
:
stoppedListeners
}
;
}
getCachedMessages
:
function
(
messageTypes
)
{
if
(
!
messageTypes
)
{
return
{
error
:
"
missingParameter
"
message
:
"
The
messageTypes
parameter
is
missing
.
"
}
;
}
const
messages
=
[
]
;
const
consoleServiceCachedMessages
=
messageTypes
.
includes
(
"
PageError
"
)
|
|
messageTypes
.
includes
(
"
LogMessage
"
)
?
this
.
consoleServiceListener
?
.
getCachedMessages
(
!
this
.
parentActor
.
isRootActor
)
:
null
;
for
(
const
type
of
messageTypes
)
{
switch
(
type
)
{
case
"
ConsoleAPI
"
:
{
if
(
!
this
.
consoleAPIListener
)
{
break
;
}
const
winStartTime
=
this
.
window
&
&
this
.
window
.
performance
?
this
.
window
.
performance
.
timing
.
navigationStart
:
0
;
const
cache
=
this
.
consoleAPIListener
.
getCachedMessages
(
!
this
.
parentActor
.
isRootActor
)
;
cache
.
forEach
(
cachedMessage
=
>
{
if
(
cachedMessage
.
innerID
=
=
=
"
ServiceWorker
"
&
&
winStartTime
>
cachedMessage
.
timeStamp
)
{
return
;
}
messages
.
push
(
{
message
:
this
.
prepareConsoleMessageForRemote
(
cachedMessage
)
type
:
"
consoleAPICall
"
}
)
;
}
)
;
break
;
}
case
"
PageError
"
:
{
if
(
!
consoleServiceCachedMessages
)
{
break
;
}
for
(
const
cachedMessage
of
consoleServiceCachedMessages
)
{
if
(
!
(
cachedMessage
instanceof
Ci
.
nsIScriptError
)
)
{
continue
;
}
messages
.
push
(
{
pageError
:
this
.
preparePageErrorForRemote
(
cachedMessage
)
type
:
"
pageError
"
}
)
;
}
break
;
}
case
"
LogMessage
"
:
{
if
(
!
consoleServiceCachedMessages
)
{
break
;
}
for
(
const
cachedMessage
of
consoleServiceCachedMessages
)
{
if
(
cachedMessage
instanceof
Ci
.
nsIScriptError
)
{
continue
;
}
messages
.
push
(
{
message
:
this
.
_createStringGrip
(
cachedMessage
.
message
)
timeStamp
:
cachedMessage
.
timeStamp
type
:
"
logMessage
"
}
)
;
}
break
;
}
}
}
return
{
messages
:
messages
}
;
}
evaluateJSAsync
:
async
function
(
request
)
{
const
startTime
=
Date
.
now
(
)
;
const
resultID
=
startTime
+
"
-
"
+
this
.
_evalCounter
+
+
;
DevToolsUtils
.
executeSoon
(
async
(
)
=
>
{
try
{
let
response
=
this
.
evaluateJS
(
request
)
;
response
=
await
this
.
_maybeWaitForResponseResult
(
response
)
;
response
.
timestamp
=
Date
.
now
(
)
;
this
.
emit
(
"
evaluationResult
"
{
type
:
"
evaluationResult
"
resultID
startTime
.
.
.
response
}
)
;
return
;
}
catch
(
e
)
{
const
message
=
Encountered
error
while
waiting
for
Helper
Result
:
{
e
}
;
DevToolsUtils
.
reportException
(
"
evaluateJSAsync
"
Error
(
message
)
)
;
}
}
)
;
return
{
resultID
}
;
}
_maybeWaitForResponseResult
:
async
function
(
response
)
{
if
(
!
response
)
{
return
response
;
}
const
thenable
=
obj
=
>
obj
&
&
typeof
obj
.
then
=
=
=
"
function
"
;
const
waitForHelperResult
=
response
.
helperResult
&
&
thenable
(
response
.
helperResult
)
;
const
waitForAwaitResult
=
response
.
awaitResult
&
&
thenable
(
response
.
awaitResult
)
;
if
(
!
waitForAwaitResult
&
&
!
waitForHelperResult
)
{
return
response
;
}
if
(
waitForHelperResult
)
{
response
.
helperResult
=
await
response
.
helperResult
;
}
else
if
(
waitForAwaitResult
)
{
let
result
;
try
{
result
=
await
response
.
awaitResult
;
const
dbgResult
=
this
.
makeDebuggeeValue
(
result
)
;
response
.
result
=
this
.
createValueGrip
(
dbgResult
)
;
}
catch
(
e
)
{
response
.
topLevelAwaitRejected
=
true
;
}
delete
response
.
awaitResult
;
}
return
response
;
}
evaluateJS
:
function
(
request
)
{
const
input
=
request
.
text
;
const
evalOptions
=
{
frameActor
:
request
.
frameActor
url
:
request
.
url
innerWindowID
:
request
.
innerWindowID
selectedNodeActor
:
request
.
selectedNodeActor
selectedObjectActor
:
request
.
selectedObjectActor
eager
:
request
.
eager
bindings
:
request
.
bindings
lineNumber
:
request
.
lineNumber
}
;
const
{
mapped
}
=
request
;
this
.
parentActor
.
threadActor
.
insideClientEvaluation
=
evalOptions
;
const
evalInfo
=
evalWithDebugger
(
input
evalOptions
this
)
;
this
.
parentActor
.
threadActor
.
insideClientEvaluation
=
null
;
const
evalResult
=
evalInfo
.
result
;
const
helperResult
=
evalInfo
.
helperResult
;
let
result
errorDocURL
errorMessage
errorNotes
=
null
errorGrip
=
null
frame
=
null
awaitResult
errorMessageName
exceptionStack
;
if
(
evalResult
)
{
if
(
"
return
"
in
evalResult
)
{
result
=
evalResult
.
return
;
if
(
mapped
?
.
await
&
&
result
&
&
result
.
class
=
=
=
"
Promise
"
&
&
typeof
result
.
unsafeDereference
=
=
=
"
function
"
)
{
awaitResult
=
result
.
unsafeDereference
(
)
;
}
}
else
if
(
"
yield
"
in
evalResult
)
{
result
=
evalResult
.
yield
;
}
else
if
(
"
throw
"
in
evalResult
)
{
const
error
=
evalResult
.
throw
;
errorGrip
=
this
.
createValueGrip
(
error
)
;
exceptionStack
=
this
.
prepareStackForRemote
(
evalResult
.
stack
)
;
if
(
exceptionStack
)
{
const
{
filename
:
source
sourceId
lineNumber
:
line
columnNumber
:
column
}
=
exceptionStack
[
0
]
;
frame
=
{
source
sourceId
line
column
}
;
exceptionStack
=
WebConsoleUtils
.
removeFramesAboveDebuggerEval
(
exceptionStack
)
;
}
errorMessage
=
String
(
error
)
;
if
(
typeof
error
=
=
=
"
object
"
&
&
error
!
=
=
null
)
{
try
{
errorMessage
=
DevToolsUtils
.
callPropertyOnObject
(
error
"
toString
"
)
;
}
catch
(
e
)
{
if
(
typeof
error
.
unsafeDereference
=
=
=
"
function
"
)
{
const
rawError
=
error
.
unsafeDereference
(
)
;
errorMessage
=
rawError
?
rawError
.
toString
(
)
:
"
"
;
}
}
}
try
{
errorDocURL
=
ErrorDocs
.
GetURL
(
error
)
;
errorMessageName
=
error
.
errorMessageName
;
}
catch
(
ex
)
{
}
try
{
const
line
=
error
.
errorLineNumber
;
const
column
=
error
.
errorColumnNumber
;
if
(
typeof
line
=
=
=
"
number
"
&
&
typeof
column
=
=
=
"
number
"
)
{
frame
=
{
source
:
"
debugger
eval
code
"
line
column
}
;
}
}
catch
(
ex
)
{
}
try
{
const
notes
=
error
.
errorNotes
;
if
(
notes
?
.
length
)
{
errorNotes
=
[
]
;
for
(
const
note
of
notes
)
{
errorNotes
.
push
(
{
messageBody
:
this
.
_createStringGrip
(
note
.
message
)
frame
:
{
source
:
note
.
fileName
line
:
note
.
lineNumber
column
:
note
.
columnNumber
}
}
)
;
}
}
}
catch
(
ex
)
{
}
}
}
let
resultGrip
;
if
(
!
awaitResult
)
{
try
{
const
objectActor
=
this
.
parentActor
.
threadActor
.
getThreadLifetimeObject
(
result
)
;
if
(
objectActor
)
{
resultGrip
=
this
.
parentActor
.
threadActor
.
createValueGrip
(
result
)
;
}
else
{
resultGrip
=
this
.
createValueGrip
(
result
)
;
}
}
catch
(
e
)
{
errorMessage
=
e
;
}
}
if
(
!
request
.
eager
)
{
if
(
!
awaitResult
)
{
this
.
_lastConsoleInputEvaluation
=
result
;
}
else
{
awaitResult
.
then
(
res
=
>
{
this
.
_lastConsoleInputEvaluation
=
this
.
makeDebuggeeValue
(
res
)
;
}
)
;
}
}
return
{
input
:
input
result
:
resultGrip
awaitResult
exception
:
errorGrip
exceptionMessage
:
this
.
_createStringGrip
(
errorMessage
)
exceptionDocURL
:
errorDocURL
exceptionStack
hasException
:
errorGrip
!
=
=
null
errorMessageName
frame
helperResult
:
helperResult
notes
:
errorNotes
}
;
}
autocomplete
:
function
(
text
cursor
frameActorId
selectedNodeActor
authorizedEvaluations
expressionVars
=
[
]
)
{
let
dbgObject
=
null
;
let
environment
=
null
;
let
matches
=
[
]
;
let
matchProp
;
let
isElementAccess
;
const
reqText
=
text
.
substr
(
0
cursor
)
;
if
(
isCommand
(
reqText
)
)
{
const
commandsCache
=
this
.
_getWebConsoleCommandsCache
(
)
;
matchProp
=
reqText
;
matches
=
validCommands
.
filter
(
c
=
>
:
{
c
}
.
startsWith
(
reqText
)
&
&
commandsCache
.
find
(
n
=
>
:
{
n
}
.
startsWith
(
reqText
)
)
)
.
map
(
c
=
>
:
{
c
}
)
;
}
else
{
if
(
frameActorId
)
{
const
frameActor
=
this
.
conn
.
getActor
(
frameActorId
)
;
try
{
const
frame
=
frameActor
.
frame
;
environment
=
frame
.
environment
;
}
catch
(
e
)
{
DevToolsUtils
.
reportException
(
"
autocomplete
"
Error
(
"
The
frame
actor
was
not
found
:
"
+
frameActorId
)
)
;
}
}
else
{
dbgObject
=
this
.
dbg
.
addDebuggee
(
this
.
evalWindow
)
;
}
const
result
=
JSPropertyProvider
(
{
dbgObject
environment
inputValue
:
text
cursor
webconsoleActor
:
this
selectedNodeActor
authorizedEvaluations
expressionVars
}
)
;
if
(
result
=
=
=
null
)
{
return
{
matches
:
null
}
;
}
if
(
result
&
&
result
.
isUnsafeGetter
=
=
=
true
)
{
return
{
isUnsafeGetter
:
true
getterPath
:
result
.
getterPath
}
;
}
matches
=
result
.
matches
|
|
new
Set
(
)
;
matchProp
=
result
.
matchProp
;
isElementAccess
=
result
.
isElementAccess
;
const
lastNonAlphaIsDot
=
/
[
.
]
[
a
-
zA
-
Z0
-
9
\
s
]
*
/
.
test
(
reqText
)
;
if
(
!
lastNonAlphaIsDot
&
&
!
isElementAccess
)
{
this
.
_getWebConsoleCommandsCache
(
)
.
forEach
(
n
=
>
{
if
(
n
!
=
=
"
screenshot
"
&
&
n
.
startsWith
(
result
.
matchProp
)
)
{
matches
.
add
(
n
)
;
}
}
)
;
for
(
const
keyword
of
RESERVED_JS_KEYWORDS
)
{
if
(
keyword
.
startsWith
(
result
.
matchProp
)
)
{
matches
.
add
(
keyword
)
;
}
}
}
const
firstMeaningfulCharIndex
=
isElementAccess
?
1
:
0
;
matches
=
Array
.
from
(
matches
)
.
sort
(
(
a
b
)
=
>
{
const
aFirstMeaningfulChar
=
a
[
firstMeaningfulCharIndex
]
;
const
bFirstMeaningfulChar
=
b
[
firstMeaningfulCharIndex
]
;
const
lA
=
aFirstMeaningfulChar
.
toLocaleLowerCase
(
)
=
=
=
aFirstMeaningfulChar
;
const
lB
=
bFirstMeaningfulChar
.
toLocaleLowerCase
(
)
=
=
=
bFirstMeaningfulChar
;
if
(
lA
=
=
=
lB
)
{
if
(
a
=
=
=
matchProp
)
{
return
-
1
;
}
if
(
b
=
=
=
matchProp
)
{
return
1
;
}
return
a
.
localeCompare
(
b
)
;
}
return
lA
?
-
1
:
1
;
}
)
;
}
return
{
matches
matchProp
isElementAccess
:
isElementAccess
=
=
=
true
}
;
}
clearMessagesCache
:
function
(
)
{
const
windowId
=
!
this
.
parentActor
.
isRootActor
?
WebConsoleUtils
.
getInnerWindowId
(
this
.
window
)
:
null
;
const
ConsoleAPIStorage
=
Cc
[
"
mozilla
.
org
/
consoleAPI
-
storage
;
1
"
]
.
getService
(
Ci
.
nsIConsoleAPIStorage
)
;
ConsoleAPIStorage
.
clearEvents
(
windowId
)
;
CONSOLE_WORKER_IDS
.
forEach
(
id
=
>
{
ConsoleAPIStorage
.
clearEvents
(
id
)
;
}
)
;
if
(
this
.
parentActor
.
isRootActor
)
{
Services
.
console
.
reset
(
)
;
}
else
{
this
.
consoleServiceListener
.
clearCachedMessages
(
)
;
}
}
getPreferences
:
function
(
preferences
)
{
const
prefs
=
Object
.
create
(
null
)
;
for
(
const
key
of
preferences
)
{
prefs
[
key
]
=
this
.
_prefs
[
key
]
;
}
return
{
preferences
:
prefs
}
;
}
setPreferences
:
function
(
preferences
)
{
for
(
const
key
in
preferences
)
{
this
.
_prefs
[
key
]
=
preferences
[
key
]
;
if
(
this
.
netmonitors
)
{
if
(
key
=
=
"
NetworkMonitor
.
saveRequestAndResponseBodies
"
)
{
for
(
const
{
messageManager
}
of
this
.
netmonitors
)
{
messageManager
.
sendAsyncMessage
(
"
debug
:
netmonitor
-
preference
"
{
saveRequestAndResponseBodies
:
this
.
_prefs
[
key
]
}
)
;
}
}
else
if
(
key
=
=
"
NetworkMonitor
.
throttleData
"
)
{
for
(
const
{
messageManager
}
of
this
.
netmonitors
)
{
messageManager
.
sendAsyncMessage
(
"
debug
:
netmonitor
-
preference
"
{
throttleData
:
this
.
_prefs
[
key
]
}
)
;
}
}
}
}
return
{
updated
:
Object
.
keys
(
preferences
)
}
;
}
_getWebConsoleCommands
:
function
(
debuggerGlobal
)
{
const
helpers
=
{
window
:
this
.
evalWindow
chromeWindow
:
this
.
chromeWindow
.
bind
(
this
)
makeDebuggeeValue
:
debuggerGlobal
.
makeDebuggeeValue
.
bind
(
debuggerGlobal
)
createValueGrip
:
this
.
createValueGrip
.
bind
(
this
)
preprocessDebuggerObject
:
this
.
preprocessDebuggerObject
.
bind
(
this
)
sandbox
:
Object
.
create
(
null
)
helperResult
:
null
consoleActor
:
this
}
;
addWebConsoleCommands
(
helpers
)
;
const
evalWindow
=
this
.
evalWindow
;
function
maybeExport
(
obj
name
)
{
if
(
typeof
obj
[
name
]
!
=
"
function
"
)
{
return
;
}
obj
[
name
]
=
Cu
.
exportFunction
(
obj
[
name
]
evalWindow
{
allowCrossOriginArguments
:
true
}
)
;
}
for
(
const
name
in
helpers
.
sandbox
)
{
const
desc
=
Object
.
getOwnPropertyDescriptor
(
helpers
.
sandbox
name
)
;
if
(
!
isWorker
)
{
maybeExport
(
desc
"
get
"
)
;
maybeExport
(
desc
"
set
"
)
;
maybeExport
(
desc
"
value
"
)
;
}
if
(
desc
.
value
)
{
desc
.
value
=
debuggerGlobal
.
makeDebuggeeValue
(
desc
.
value
)
;
}
Object
.
defineProperty
(
helpers
.
sandbox
name
desc
)
;
}
return
helpers
;
}
_getWebConsoleCommandsCache
:
function
(
)
{
if
(
!
this
.
_webConsoleCommandsCache
)
{
const
helpers
=
{
sandbox
:
Object
.
create
(
null
)
}
;
addWebConsoleCommands
(
helpers
)
;
this
.
_webConsoleCommandsCache
=
Object
.
getOwnPropertyNames
(
helpers
.
sandbox
)
;
}
return
this
.
_webConsoleCommandsCache
;
}
onConsoleServiceMessage
:
function
(
message
)
{
if
(
message
instanceof
Ci
.
nsIScriptError
)
{
this
.
emit
(
"
pageError
"
{
pageError
:
this
.
preparePageErrorForRemote
(
message
)
}
)
;
}
else
{
this
.
emit
(
"
logMessage
"
{
message
:
this
.
_createStringGrip
(
message
.
message
)
timeStamp
:
message
.
timeStamp
}
)
;
}
}
getActorIdForInternalSourceId
(
id
)
{
const
actor
=
this
.
parentActor
.
sources
.
getSourceActorByInternalSourceId
(
id
)
;
return
actor
?
actor
.
actorID
:
null
;
}
prepareStackForRemote
(
errorStack
)
{
if
(
!
errorStack
|
|
(
Cu
&
&
Cu
.
isDeadWrapper
(
errorStack
)
)
)
{
return
null
;
}
const
stack
=
[
]
;
let
s
=
errorStack
;
while
(
s
)
{
stack
.
push
(
{
filename
:
s
.
source
sourceId
:
this
.
getActorIdForInternalSourceId
(
s
.
sourceId
)
lineNumber
:
s
.
line
columnNumber
:
s
.
column
functionName
:
s
.
functionDisplayName
asyncCause
:
s
.
asyncCause
?
s
.
asyncCause
:
undefined
}
)
;
s
=
s
.
parent
|
|
s
.
asyncParent
;
}
return
stack
;
}
preparePageErrorForRemote
:
function
(
pageError
)
{
const
stack
=
this
.
prepareStackForRemote
(
pageError
.
stack
)
;
let
lineText
=
pageError
.
sourceLine
;
if
(
lineText
&
&
lineText
.
length
>
DevToolsServer
.
LONG_STRING_INITIAL_LENGTH
)
{
lineText
=
lineText
.
substr
(
0
DevToolsServer
.
LONG_STRING_INITIAL_LENGTH
)
;
}
let
notesArray
=
null
;
const
notes
=
pageError
.
notes
;
if
(
notes
?
.
length
)
{
notesArray
=
[
]
;
for
(
let
i
=
0
len
=
notes
.
length
;
i
<
len
;
i
+
+
)
{
const
note
=
notes
.
queryElementAt
(
i
Ci
.
nsIScriptErrorNote
)
;
notesArray
.
push
(
{
messageBody
:
this
.
_createStringGrip
(
note
.
errorMessage
)
frame
:
{
source
:
note
.
sourceName
sourceId
:
this
.
getActorIdForInternalSourceId
(
note
.
sourceId
)
line
:
note
.
lineNumber
column
:
note
.
columnNumber
}
}
)
;
}
}
let
{
sourceName
sourceId
lineNumber
columnNumber
}
=
pageError
;
if
(
!
sourceName
&
&
!
sourceId
&
&
!
lineNumber
&
&
!
columnNumber
&
&
stack
)
{
sourceName
=
stack
[
0
]
.
filename
;
sourceId
=
stack
[
0
]
.
sourceId
;
lineNumber
=
stack
[
0
]
.
lineNumber
;
columnNumber
=
stack
[
0
]
.
columnNumber
;
}
const
result
=
{
errorMessage
:
this
.
_createStringGrip
(
pageError
.
errorMessage
)
errorMessageName
:
pageError
.
errorMessageName
exceptionDocURL
:
ErrorDocs
.
GetURL
(
pageError
)
sourceName
sourceId
:
this
.
getActorIdForInternalSourceId
(
sourceId
)
lineText
lineNumber
columnNumber
category
:
pageError
.
category
innerWindowID
:
pageError
.
innerWindowID
timeStamp
:
pageError
.
timeStamp
warning
:
!
!
(
pageError
.
flags
&
pageError
.
warningFlag
)
error
:
!
(
pageError
.
flags
&
(
pageError
.
warningFlag
|
pageError
.
infoFlag
)
)
info
:
!
!
(
pageError
.
flags
&
pageError
.
infoFlag
)
private
:
pageError
.
isFromPrivateWindow
stacktrace
:
stack
notes
:
notesArray
chromeContext
:
pageError
.
isFromChromeContext
isPromiseRejection
:
pageError
.
isPromiseRejection
isForwardedFromContentProcess
:
pageError
.
isForwardedFromContentProcess
}
;
if
(
pageError
.
category
=
=
=
"
CSS
Parser
"
)
{
result
.
cssSelectors
=
pageError
.
cssSelectors
;
}
if
(
pageError
.
hasException
)
{
try
{
const
obj
=
this
.
makeDebuggeeValue
(
pageError
.
exception
true
)
;
if
(
obj
?
.
class
!
=
=
"
DeadObject
"
)
{
result
.
exception
=
this
.
createValueGrip
(
obj
)
;
result
.
hasException
=
true
;
}
}
catch
(
e
)
{
}
}
return
result
;
}
onConsoleAPICall
:
function
(
message
)
{
this
.
emit
(
"
consoleAPICall
"
{
message
:
this
.
prepareConsoleMessageForRemote
(
message
)
}
)
;
}
getRequestContentForURL
(
url
)
{
if
(
!
this
.
netmonitors
)
{
return
null
;
}
return
new
Promise
(
resolve
=
>
{
let
messagesReceived
=
0
;
const
onMessage
=
(
{
data
}
)
=
>
{
if
(
!
this
.
netmonitors
)
{
resolve
(
null
)
;
return
;
}
if
(
data
.
url
!
=
url
)
{
return
;
}
messagesReceived
+
+
;
if
(
data
.
content
|
|
messagesReceived
=
=
this
.
netmonitors
.
length
)
{
for
(
const
{
messageManager
}
of
this
.
netmonitors
)
{
messageManager
.
removeMessageListener
(
"
debug
:
request
-
content
:
response
"
onMessage
)
;
}
resolve
(
data
.
content
)
;
}
}
;
for
(
const
{
messageManager
}
of
this
.
netmonitors
)
{
messageManager
.
addMessageListener
(
"
debug
:
request
-
content
:
response
"
onMessage
)
;
messageManager
.
sendAsyncMessage
(
"
debug
:
request
-
content
:
request
"
{
url
}
)
;
}
}
)
;
}
async
sendHTTPRequest
(
request
)
{
const
{
url
method
headers
body
cause
}
=
request
;
const
doc
=
this
.
window
.
document
;
const
channel
=
NetUtil
.
newChannel
(
{
uri
:
NetUtil
.
newURI
(
url
)
loadingNode
:
doc
securityFlags
:
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
contentPolicyType
:
stringToCauseType
(
cause
.
type
)
|
|
Ci
.
nsIContentPolicy
.
TYPE_OTHER
}
)
;
channel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
channel
.
loadGroup
=
doc
.
documentLoadGroup
;
channel
.
loadFlags
|
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
|
Ci
.
nsIRequest
.
INHIBIT_CACHING
|
Ci
.
nsIRequest
.
LOAD_ANONYMOUS
;
channel
.
requestMethod
=
method
;
if
(
headers
)
{
for
(
const
{
name
value
}
of
headers
)
{
channel
.
setRequestHeader
(
name
value
false
)
;
}
}
if
(
body
)
{
channel
.
QueryInterface
(
Ci
.
nsIUploadChannel2
)
;
const
bodyStream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
bodyStream
.
setData
(
body
body
.
length
)
;
channel
.
explicitSetUploadStream
(
bodyStream
null
-
1
method
false
)
;
}
NetUtil
.
asyncFetch
(
channel
(
)
=
>
{
}
)
;
if
(
!
this
.
netmonitors
)
{
return
null
;
}
const
{
channelId
}
=
channel
;
const
netmonitor
=
this
.
netmonitors
.
filter
(
(
{
parentProcess
}
)
=
>
parentProcess
)
[
0
]
;
const
{
messageManager
}
=
netmonitor
;
return
new
Promise
(
resolve
=
>
{
const
onMessage
=
(
{
data
}
)
=
>
{
if
(
data
.
channelId
=
=
channelId
)
{
messageManager
.
removeMessageListener
(
"
debug
:
get
-
network
-
event
-
actor
:
response
"
onMessage
)
;
resolve
(
{
eventActor
:
data
.
actor
}
)
;
}
}
;
messageManager
.
addMessageListener
(
"
debug
:
get
-
network
-
event
-
actor
:
response
"
onMessage
)
;
messageManager
.
sendAsyncMessage
(
"
debug
:
get
-
network
-
event
-
actor
:
request
"
{
channelId
}
)
;
}
)
;
}
async
_sendMessageToNetmonitors
(
messageName
responseName
args
)
{
if
(
!
this
.
netmonitors
)
{
return
null
;
}
const
results
=
await
Promise
.
all
(
this
.
netmonitors
.
map
(
(
{
messageManager
}
)
=
>
{
const
onResponseReceived
=
new
Promise
(
resolve
=
>
{
messageManager
.
addMessageListener
(
responseName
function
onResponse
(
response
)
{
messageManager
.
removeMessageListener
(
responseName
onResponse
)
;
resolve
(
response
)
;
}
)
;
}
)
;
messageManager
.
sendAsyncMessage
(
messageName
args
)
;
return
onResponseReceived
;
}
)
)
;
return
results
;
}
async
blockRequest
(
filter
)
{
await
this
.
_sendMessageToNetmonitors
(
"
debug
:
block
-
request
"
"
debug
:
block
-
request
:
response
"
{
filter
}
)
;
return
{
}
;
}
async
unblockRequest
(
filter
)
{
await
this
.
_sendMessageToNetmonitors
(
"
debug
:
unblock
-
request
"
"
debug
:
unblock
-
request
:
response
"
{
filter
}
)
;
return
{
}
;
}
async
getBlockedUrls
(
)
{
const
responses
=
(
await
this
.
_sendMessageToNetmonitors
(
"
debug
:
get
-
blocked
-
urls
"
"
debug
:
get
-
blocked
-
urls
:
response
"
)
)
|
|
[
]
;
if
(
!
responses
|
|
responses
.
length
=
=
0
)
{
return
[
]
;
}
return
Array
.
from
(
new
Set
(
responses
.
filter
(
response
=
>
response
.
data
)
.
map
(
response
=
>
response
.
data
)
)
)
;
}
async
setBlockedUrls
(
urls
)
{
await
this
.
_sendMessageToNetmonitors
(
"
debug
:
set
-
blocked
-
urls
"
"
debug
:
set
-
blocked
-
urls
:
response
"
{
urls
}
)
;
return
{
}
;
}
onFileActivity
:
function
(
fileURI
)
{
this
.
emit
(
"
fileActivity
"
{
uri
:
fileURI
}
)
;
}
prepareConsoleMessageForRemote
:
function
(
message
useObjectGlobal
=
true
)
{
const
result
=
WebConsoleUtils
.
cloneObject
(
message
)
;
result
.
workerType
=
WebConsoleUtils
.
getWorkerType
(
result
)
|
|
"
none
"
;
result
.
sourceId
=
this
.
getActorIdForInternalSourceId
(
result
.
sourceId
)
;
delete
result
.
wrappedJSObject
;
delete
result
.
ID
;
delete
result
.
innerID
;
delete
result
.
consoleID
;
if
(
result
.
stacktrace
)
{
result
.
stacktrace
=
result
.
stacktrace
.
map
(
frame
=
>
{
return
{
.
.
.
frame
sourceId
:
this
.
getActorIdForInternalSourceId
(
frame
.
sourceId
)
}
;
}
)
;
}
result
.
arguments
=
(
message
.
arguments
|
|
[
]
)
.
map
(
obj
=
>
{
const
dbgObj
=
this
.
makeDebuggeeValue
(
obj
useObjectGlobal
)
;
return
this
.
createValueGrip
(
dbgObj
)
;
}
)
;
result
.
styles
=
(
message
.
styles
|
|
[
]
)
.
map
(
string
=
>
{
return
this
.
createValueGrip
(
string
)
;
}
)
;
if
(
result
.
level
=
=
=
"
table
"
)
{
const
tableItems
=
this
.
_getConsoleTableMessageItems
(
result
)
;
if
(
tableItems
)
{
result
.
arguments
[
0
]
.
ownProperties
=
tableItems
;
result
.
arguments
[
0
]
.
preview
=
null
;
}
result
.
arguments
=
result
.
arguments
.
slice
(
0
2
)
;
}
result
.
category
=
message
.
category
|
|
"
webdev
"
;
result
.
innerWindowID
=
message
.
innerID
;
return
result
;
}
_getConsoleTableMessageItems
:
function
(
result
)
{
if
(
!
result
|
|
!
Array
.
isArray
(
result
.
arguments
)
|
|
result
.
arguments
.
length
=
=
0
)
{
return
null
;
}
const
[
tableItemGrip
]
=
result
.
arguments
;
const
dataType
=
tableItemGrip
.
class
;
const
needEntries
=
[
"
Map
"
"
WeakMap
"
"
Set
"
"
WeakSet
"
]
.
includes
(
dataType
)
;
const
ignoreNonIndexedProperties
=
isArray
(
tableItemGrip
)
;
const
tableItemActor
=
this
.
getActorByID
(
tableItemGrip
.
actor
)
;
if
(
!
tableItemActor
)
{
return
null
;
}
const
iterator
=
needEntries
?
tableItemActor
.
enumEntries
(
)
:
tableItemActor
.
enumProperties
(
{
ignoreNonIndexedProperties
}
)
;
const
{
ownProperties
}
=
iterator
.
all
(
)
;
const
descriptorKeys
=
[
"
safeGetterValues
"
"
getterValue
"
"
value
"
]
;
Object
.
values
(
ownProperties
)
.
forEach
(
desc
=
>
{
if
(
typeof
desc
!
=
=
"
undefined
"
)
{
descriptorKeys
.
forEach
(
key
=
>
{
if
(
desc
&
&
desc
.
hasOwnProperty
(
key
)
)
{
const
grip
=
desc
[
key
]
;
const
actor
=
grip
&
&
this
.
getActorByID
(
grip
.
actor
)
;
if
(
actor
)
{
const
res
=
actor
.
enumProperties
(
{
ignoreNonIndexedProperties
:
isArray
(
grip
)
}
)
.
all
(
)
;
if
(
res
?
.
ownProperties
)
{
desc
[
key
]
.
ownProperties
=
res
.
ownProperties
;
}
}
}
}
)
;
}
}
)
;
return
ownProperties
;
}
chromeWindow
:
function
(
)
{
let
window
=
null
;
try
{
window
=
this
.
window
.
docShell
.
chromeEventHandler
.
ownerGlobal
;
}
catch
(
ex
)
{
}
return
window
;
}
_onObserverNotification
:
function
(
subject
topic
)
{
if
(
topic
=
=
=
"
last
-
pb
-
context
-
exited
"
)
{
this
.
emit
(
"
lastPrivateContextExited
"
)
;
}
}
_onWillNavigate
:
function
(
{
window
isTopLevel
}
)
{
if
(
isTopLevel
)
{
this
.
_evalWindow
=
null
;
EventEmitter
.
off
(
this
.
parentActor
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_progressListenerActive
=
false
;
}
}
_onChangedToplevelDocument
:
function
(
)
{
const
listeners
=
[
.
.
.
this
.
_listeners
]
;
this
.
stopListeners
(
listeners
.
slice
(
)
)
;
this
.
startListeners
(
listeners
)
;
this
.
_lastChromeWindow
=
null
;
}
}
)
;
exports
.
WebConsoleActor
=
WebConsoleActor
;
