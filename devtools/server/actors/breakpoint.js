"
use
strict
"
;
const
{
evalAndLogEvent
getThrownMessage
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
logEvent
.
js
"
)
;
function
setBreakpointAtEntryPoints
(
actor
entryPoints
)
{
for
(
const
{
script
offsets
}
of
entryPoints
)
{
actor
.
addScript
(
script
offsets
)
;
}
}
exports
.
setBreakpointAtEntryPoints
=
setBreakpointAtEntryPoints
;
class
BreakpointActor
{
constructor
(
threadActor
location
)
{
this
.
scripts
=
new
Map
(
)
;
this
.
threadActor
=
threadActor
;
this
.
location
=
location
;
this
.
options
=
null
;
}
setOptions
(
options
)
{
const
oldOptions
=
this
.
options
;
this
.
options
=
options
;
for
(
const
[
script
offsets
]
of
this
.
scripts
)
{
this
.
_newOffsetsOrOptions
(
script
offsets
oldOptions
)
;
}
}
destroy
(
)
{
this
.
removeScripts
(
)
;
this
.
options
=
null
;
}
hasScript
(
script
)
{
return
this
.
scripts
.
has
(
script
)
;
}
addScript
(
script
offsets
)
{
this
.
scripts
.
set
(
script
offsets
.
concat
(
this
.
scripts
.
get
(
offsets
)
|
|
[
]
)
)
;
this
.
_newOffsetsOrOptions
(
script
offsets
null
)
;
}
removeScripts
(
)
{
for
(
const
[
script
]
of
this
.
scripts
)
{
script
.
clearBreakpoint
(
this
)
;
}
this
.
scripts
.
clear
(
)
;
}
_newOffsetsOrOptions
(
script
offsets
)
{
for
(
const
offset
of
offsets
)
{
script
.
clearBreakpoint
(
this
offset
)
;
}
for
(
const
offset
of
offsets
)
{
script
.
setBreakpoint
(
offset
this
)
;
}
}
checkCondition
(
frame
condition
)
{
this
.
threadActor
.
insideClientEvaluation
=
{
disableBreaks
:
true
reportExceptionsWhenBreaksAreDisabled
:
true
}
;
let
completion
;
const
hadToEnablePauseOnException
=
!
this
.
threadActor
.
isPauseOnExceptionsEnabled
(
)
;
try
{
if
(
hadToEnablePauseOnException
)
{
this
.
threadActor
.
setPauseOnExceptions
(
true
)
;
}
completion
=
frame
.
eval
(
condition
{
hideFromDebugger
:
true
}
)
;
}
finally
{
this
.
threadActor
.
insideClientEvaluation
=
null
;
if
(
hadToEnablePauseOnException
)
{
this
.
threadActor
.
setPauseOnExceptions
(
false
)
;
}
}
if
(
completion
)
{
if
(
completion
.
throw
)
{
return
{
result
:
true
message
:
getThrownMessage
(
completion
)
}
;
}
else
if
(
completion
.
yield
)
{
assert
(
false
"
Shouldn
'
t
ever
get
yield
completions
from
an
eval
"
)
;
}
else
{
return
{
result
:
!
!
completion
.
return
}
;
}
}
return
{
result
:
undefined
}
;
}
hit
(
frame
)
{
if
(
this
.
threadActor
.
shouldSkipAnyBreakpoint
)
{
return
undefined
;
}
const
location
=
this
.
threadActor
.
sourcesManager
.
getFrameLocation
(
frame
)
;
if
(
this
.
threadActor
.
sourcesManager
.
isFrameBlackBoxed
(
frame
)
)
{
return
undefined
;
}
const
locationAtFinish
=
frame
.
onPop
?
.
location
;
if
(
locationAtFinish
&
&
locationAtFinish
.
line
=
=
=
location
.
line
&
&
locationAtFinish
.
column
=
=
=
location
.
column
)
{
return
undefined
;
}
if
(
!
this
.
threadActor
.
hasMoved
(
frame
"
breakpoint
"
)
)
{
return
undefined
;
}
const
reason
=
{
type
:
"
breakpoint
"
actors
:
[
this
.
actorID
]
}
;
const
{
condition
logValue
}
=
this
.
options
|
|
{
}
;
if
(
condition
)
{
const
{
result
message
}
=
this
.
checkCondition
(
frame
condition
)
;
if
(
!
result
)
{
return
undefined
;
}
if
(
message
)
{
reason
.
type
=
"
breakpointConditionThrown
"
;
reason
.
message
=
message
;
}
}
if
(
logValue
)
{
return
evalAndLogEvent
(
{
threadActor
:
this
.
threadActor
frame
level
:
"
logPoint
"
expression
:
[
{
logValue
}
]
}
)
;
}
return
this
.
threadActor
.
_pauseAndRespond
(
frame
reason
)
;
}
delete
(
)
{
this
.
threadActor
.
breakpointActorMap
.
deleteActor
(
this
.
location
)
;
this
.
removeScripts
(
)
;
this
.
destroy
(
)
;
}
}
exports
.
BreakpointActor
=
BreakpointActor
;
