"
use
strict
"
;
const
{
ActorClassWithSpec
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
breakpointSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
breakpoint
"
)
;
function
setBreakpointAtEntryPoints
(
actor
entryPoints
)
{
for
(
const
{
script
offsets
}
of
entryPoints
)
{
actor
.
addScript
(
script
offsets
)
;
}
}
exports
.
setBreakpointAtEntryPoints
=
setBreakpointAtEntryPoints
;
const
BreakpointActor
=
ActorClassWithSpec
(
breakpointSpec
{
initialize
:
function
(
threadActor
generatedLocation
)
{
this
.
scripts
=
new
Map
(
)
;
this
.
threadActor
=
threadActor
;
this
.
generatedLocation
=
generatedLocation
;
this
.
options
=
null
;
this
.
isPending
=
true
;
}
setOptions
(
options
)
{
for
(
const
[
script
offsets
]
of
this
.
scripts
)
{
this
.
_updateOptionsForScript
(
script
offsets
this
.
options
options
)
;
}
this
.
options
=
options
;
}
destroy
:
function
(
)
{
this
.
removeScripts
(
)
;
}
hasScript
:
function
(
script
)
{
return
this
.
scripts
.
has
(
script
)
;
}
addScript
:
function
(
script
offsets
)
{
this
.
scripts
.
set
(
script
offsets
.
concat
(
this
.
scripts
.
get
(
offsets
)
|
|
[
]
)
)
;
for
(
const
offset
of
offsets
)
{
script
.
setBreakpoint
(
offset
this
)
;
}
this
.
isPending
=
false
;
this
.
_updateOptionsForScript
(
script
offsets
null
this
.
options
)
;
}
removeScripts
:
function
(
)
{
for
(
const
[
script
offsets
]
of
this
.
scripts
)
{
this
.
_updateOptionsForScript
(
script
offsets
this
.
options
null
)
;
script
.
clearBreakpoint
(
this
)
;
}
this
.
scripts
.
clear
(
)
;
}
_updateOptionsForScript
(
script
offsets
oldOptions
newOptions
)
{
if
(
this
.
threadActor
.
dbg
.
replaying
)
{
const
oldLogValue
=
oldOptions
&
&
oldOptions
.
logValue
;
const
newLogValue
=
newOptions
&
&
newOptions
.
logValue
;
if
(
oldLogValue
!
=
newLogValue
)
{
for
(
const
offset
of
offsets
)
{
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetLocation
(
offset
)
;
script
.
replayVirtualConsoleLog
(
offset
newLogValue
(
point
rv
)
=
>
{
const
packet
=
{
from
:
this
.
actorID
type
:
"
virtualConsoleLog
"
url
:
script
.
url
line
:
lineNumber
column
:
columnNumber
executionPoint
:
point
message
:
"
return
"
in
rv
?
"
"
+
rv
.
return
:
"
"
+
rv
.
throw
}
;
this
.
conn
.
send
(
packet
)
;
}
)
;
}
}
}
}
checkCondition
:
function
(
frame
condition
)
{
const
completion
=
frame
.
eval
(
condition
)
;
if
(
completion
)
{
if
(
completion
.
throw
)
{
let
message
=
"
Unknown
exception
"
;
try
{
if
(
completion
.
throw
.
getOwnPropertyDescriptor
)
{
message
=
completion
.
throw
.
getOwnPropertyDescriptor
(
"
message
"
)
.
value
;
}
else
if
(
completion
.
toString
)
{
message
=
completion
.
toString
(
)
;
}
}
catch
(
ex
)
{
}
return
{
result
:
true
message
:
message
}
;
}
else
if
(
completion
.
yield
)
{
assert
(
false
"
Shouldn
'
t
ever
get
yield
completions
from
an
eval
"
)
;
}
else
{
return
{
result
:
!
!
completion
.
return
}
;
}
}
return
{
result
:
undefined
}
;
}
hit
:
function
(
frame
)
{
const
{
generatedSourceActor
generatedLine
generatedColumn
}
=
this
.
threadActor
.
sources
.
getFrameLocation
(
frame
)
;
const
url
=
generatedSourceActor
.
url
;
if
(
this
.
threadActor
.
sources
.
isBlackBoxed
(
url
generatedLine
generatedColumn
)
|
|
this
.
threadActor
.
skipBreakpoints
|
|
frame
.
onStep
)
{
return
undefined
;
}
const
locationAtFinish
=
frame
.
onPop
&
&
frame
.
onPop
.
generatedLocation
;
if
(
locationAtFinish
&
&
locationAtFinish
.
generatedLine
=
=
=
generatedLine
&
&
locationAtFinish
.
generatedColumn
=
=
=
generatedColumn
)
{
return
undefined
;
}
const
reason
=
{
}
;
const
{
condition
logValue
}
=
this
.
options
|
|
{
}
;
if
(
this
.
threadActor
.
_hiddenBreakpoints
.
has
(
this
.
actorID
)
)
{
reason
.
type
=
"
pauseOnDOMEvents
"
;
}
else
if
(
!
condition
&
&
!
logValue
)
{
reason
.
type
=
"
breakpoint
"
;
reason
.
actors
=
[
this
.
actorID
]
;
}
else
{
if
(
logValue
&
&
this
.
threadActor
.
dbg
.
replaying
)
{
return
undefined
;
}
let
condstr
=
condition
;
if
(
logValue
)
{
condstr
=
condition
?
(
{
condition
}
)
&
&
console
.
log
(
{
logValue
}
)
:
console
.
log
(
{
logValue
}
)
;
}
const
{
result
message
}
=
this
.
checkCondition
(
frame
condstr
)
;
if
(
result
)
{
if
(
!
message
)
{
reason
.
type
=
"
breakpoint
"
;
}
else
{
reason
.
type
=
"
breakpointConditionThrown
"
;
reason
.
message
=
message
;
}
reason
.
actors
=
[
this
.
actorID
]
;
}
else
{
return
undefined
;
}
}
return
this
.
threadActor
.
_pauseAndRespond
(
frame
reason
)
;
}
delete
:
function
(
)
{
if
(
this
.
generatedLocation
)
{
this
.
threadActor
.
breakpointActorMap
.
deleteActor
(
this
.
generatedLocation
)
;
}
this
.
threadActor
.
threadLifetimePool
.
removeActor
(
this
)
;
this
.
removeScripts
(
)
;
}
}
)
;
exports
.
BreakpointActor
=
BreakpointActor
;
