"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Actor
ActorClassWithSpec
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
accessibleWalkerSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
accessibility
"
)
;
const
{
simulation
:
{
COLOR_TRANSFORMATION_MATRICES
}
}
=
require
(
"
devtools
/
server
/
actors
/
accessibility
/
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
AccessibleActor
"
"
devtools
/
server
/
actors
/
accessibility
/
accessible
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
CustomHighlighterActor
"
]
"
devtools
/
server
/
actors
/
highlighters
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsUtils
"
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
events
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
getCurrentZoom
"
"
isWindowIncluded
"
"
isFrameWithChildTarget
"
]
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorUtils
"
"
InspectorUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
isXUL
"
"
devtools
/
server
/
actors
/
highlighters
/
utils
/
markup
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
isDefunct
"
"
loadSheetForBackgroundCalculation
"
"
removeSheetForBackgroundCalculation
"
]
"
devtools
/
server
/
actors
/
utils
/
accessibility
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
accessibility
"
"
devtools
/
shared
/
constants
"
true
)
;
const
kStateHover
=
0x00000004
;
const
{
EVENT_TEXT_CHANGED
EVENT_TEXT_INSERTED
EVENT_TEXT_REMOVED
EVENT_ACCELERATOR_CHANGE
EVENT_ACTION_CHANGE
EVENT_DEFACTION_CHANGE
EVENT_DESCRIPTION_CHANGE
EVENT_DOCUMENT_ATTRIBUTES_CHANGED
EVENT_HIDE
EVENT_NAME_CHANGE
EVENT_OBJECT_ATTRIBUTE_CHANGED
EVENT_REORDER
EVENT_STATE_CHANGE
EVENT_TEXT_ATTRIBUTE_CHANGED
EVENT_VALUE_CHANGE
}
=
Ci
.
nsIAccessibleEvent
;
const
NAME_FROM_SUBTREE_RULE_ROLES
=
new
Set
(
[
Ci
.
nsIAccessibleRole
.
ROLE_BUTTONDROPDOWN
Ci
.
nsIAccessibleRole
.
ROLE_BUTTONDROPDOWNGRID
Ci
.
nsIAccessibleRole
.
ROLE_BUTTONMENU
Ci
.
nsIAccessibleRole
.
ROLE_CELL
Ci
.
nsIAccessibleRole
.
ROLE_CHECKBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_CHECK_MENU_ITEM
Ci
.
nsIAccessibleRole
.
ROLE_CHECK_RICH_OPTION
Ci
.
nsIAccessibleRole
.
ROLE_COLUMN
Ci
.
nsIAccessibleRole
.
ROLE_COLUMNHEADER
Ci
.
nsIAccessibleRole
.
ROLE_COMBOBOX_OPTION
Ci
.
nsIAccessibleRole
.
ROLE_DEFINITION
Ci
.
nsIAccessibleRole
.
ROLE_GRID_CELL
Ci
.
nsIAccessibleRole
.
ROLE_HEADING
Ci
.
nsIAccessibleRole
.
ROLE_HELPBALLOON
Ci
.
nsIAccessibleRole
.
ROLE_HTML_CONTAINER
Ci
.
nsIAccessibleRole
.
ROLE_KEY
Ci
.
nsIAccessibleRole
.
ROLE_LABEL
Ci
.
nsIAccessibleRole
.
ROLE_LINK
Ci
.
nsIAccessibleRole
.
ROLE_LISTITEM
Ci
.
nsIAccessibleRole
.
ROLE_MATHML_IDENTIFIER
Ci
.
nsIAccessibleRole
.
ROLE_MATHML_NUMBER
Ci
.
nsIAccessibleRole
.
ROLE_MATHML_OPERATOR
Ci
.
nsIAccessibleRole
.
ROLE_MATHML_TEXT
Ci
.
nsIAccessibleRole
.
ROLE_MATHML_STRING_LITERAL
Ci
.
nsIAccessibleRole
.
ROLE_MATHML_GLYPH
Ci
.
nsIAccessibleRole
.
ROLE_MENUITEM
Ci
.
nsIAccessibleRole
.
ROLE_OPTION
Ci
.
nsIAccessibleRole
.
ROLE_OUTLINEITEM
Ci
.
nsIAccessibleRole
.
ROLE_PAGETAB
Ci
.
nsIAccessibleRole
.
ROLE_PARENT_MENUITEM
Ci
.
nsIAccessibleRole
.
ROLE_PUSHBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_RADIOBUTTON
Ci
.
nsIAccessibleRole
.
ROLE_RADIO_MENU_ITEM
Ci
.
nsIAccessibleRole
.
ROLE_RICH_OPTION
Ci
.
nsIAccessibleRole
.
ROLE_ROW
Ci
.
nsIAccessibleRole
.
ROLE_ROWHEADER
Ci
.
nsIAccessibleRole
.
ROLE_SUMMARY
Ci
.
nsIAccessibleRole
.
ROLE_SWITCH
Ci
.
nsIAccessibleRole
.
ROLE_TABLE_COLUMN_HEADER
Ci
.
nsIAccessibleRole
.
ROLE_TABLE_ROW_HEADER
Ci
.
nsIAccessibleRole
.
ROLE_TEAR_OFF_MENU_ITEM
Ci
.
nsIAccessibleRole
.
ROLE_TERM
Ci
.
nsIAccessibleRole
.
ROLE_TOGGLE_BUTTON
Ci
.
nsIAccessibleRole
.
ROLE_TOOLTIP
]
)
;
const
IS_OSX
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
const
{
SCORES
:
{
BEST_PRACTICES
FAIL
WARNING
}
}
=
accessibility
;
function
isStale
(
accessible
)
{
const
extraState
=
{
}
;
accessible
.
getState
(
{
}
extraState
)
;
return
!
!
(
extraState
.
value
&
Ci
.
nsIAccessibleStates
.
EXT_STATE_STALE
)
;
}
function
getAudit
(
acc
options
report
progress
)
{
if
(
acc
.
isDefunct
)
{
return
;
}
report
.
set
(
acc
acc
.
audit
(
options
)
.
then
(
result
=
>
{
report
.
set
(
acc
result
)
;
progress
.
increment
(
)
;
}
)
)
;
for
(
const
child
of
acc
.
children
(
)
)
{
getAudit
(
child
options
report
progress
)
;
}
}
class
AuditProgress
{
constructor
(
walker
)
{
this
.
completed
=
0
;
this
.
percentage
=
0
;
this
.
walker
=
walker
;
}
setTotal
(
size
)
{
this
.
size
=
size
;
}
notify
(
)
{
this
.
walker
.
emit
(
"
audit
-
event
"
{
type
:
"
progress
"
progress
:
{
total
:
this
.
size
percentage
:
this
.
percentage
completed
:
this
.
completed
}
}
)
;
}
increment
(
)
{
this
.
completed
+
+
;
const
{
completed
size
}
=
this
;
if
(
!
size
)
{
return
;
}
const
percentage
=
Math
.
round
(
(
completed
/
size
)
*
100
)
;
if
(
percentage
>
this
.
percentage
)
{
this
.
percentage
=
percentage
;
this
.
notify
(
)
;
}
}
destroy
(
)
{
this
.
walker
=
null
;
}
}
const
AccessibleWalkerActor
=
ActorClassWithSpec
(
accessibleWalkerSpec
{
initialize
(
conn
targetActor
)
{
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
targetActor
=
targetActor
;
this
.
refMap
=
new
Map
(
)
;
this
.
_loadedSheets
=
new
WeakMap
(
)
;
this
.
setA11yServiceGetter
(
)
;
this
.
onPick
=
this
.
onPick
.
bind
(
this
)
;
this
.
onHovered
=
this
.
onHovered
.
bind
(
this
)
;
this
.
_preventContentEvent
=
this
.
_preventContentEvent
.
bind
(
this
)
;
this
.
onKey
=
this
.
onKey
.
bind
(
this
)
;
this
.
onFocusIn
=
this
.
onFocusIn
.
bind
(
this
)
;
this
.
onFocusOut
=
this
.
onFocusOut
.
bind
(
this
)
;
this
.
onHighlighterEvent
=
this
.
onHighlighterEvent
.
bind
(
this
)
;
}
get
highlighter
(
)
{
if
(
!
this
.
_highlighter
)
{
this
.
_highlighter
=
CustomHighlighterActor
(
this
"
AccessibleHighlighter
"
)
;
this
.
manage
(
this
.
_highlighter
)
;
this
.
_highlighter
.
on
(
"
highlighter
-
event
"
this
.
onHighlighterEvent
)
;
}
return
this
.
_highlighter
;
}
get
tabbingOrderHighlighter
(
)
{
if
(
!
this
.
_tabbingOrderHighlighter
)
{
this
.
_tabbingOrderHighlighter
=
CustomHighlighterActor
(
this
"
TabbingOrderHighlighter
"
)
;
this
.
manage
(
this
.
_tabbingOrderHighlighter
)
;
}
return
this
.
_tabbingOrderHighlighter
;
}
setA11yServiceGetter
(
)
{
DevToolsUtils
.
defineLazyGetter
(
this
"
a11yService
"
(
)
=
>
{
Services
.
obs
.
addObserver
(
this
"
accessible
-
event
"
)
;
return
Cc
[
"
mozilla
.
org
/
accessibilityService
;
1
"
]
.
getService
(
Ci
.
nsIAccessibilityService
)
;
}
)
;
}
get
rootWin
(
)
{
return
this
.
targetActor
&
&
this
.
targetActor
.
window
;
}
get
rootDoc
(
)
{
return
this
.
targetActor
&
&
this
.
targetActor
.
window
.
document
;
}
get
isXUL
(
)
{
return
isXUL
(
this
.
rootWin
)
;
}
get
colorMatrix
(
)
{
if
(
!
this
.
targetActor
.
docShell
)
{
return
null
;
}
const
colorMatrix
=
this
.
targetActor
.
docShell
.
getColorMatrix
(
)
;
if
(
colorMatrix
.
length
=
=
=
0
|
|
colorMatrix
=
=
=
COLOR_TRANSFORMATION_MATRICES
.
NONE
)
{
return
null
;
}
return
colorMatrix
;
}
reset
(
)
{
try
{
Services
.
obs
.
removeObserver
(
this
"
accessible
-
event
"
)
;
}
catch
(
e
)
{
}
this
.
cancelPick
(
)
;
this
.
clearRefs
(
)
;
this
.
_childrenPromise
=
null
;
delete
this
.
a11yService
;
this
.
setA11yServiceGetter
(
)
;
}
clearRefs
(
)
{
for
(
const
actor
of
this
.
refMap
.
values
(
)
)
{
actor
.
destroy
(
)
;
}
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
reset
(
)
;
if
(
this
.
_highlighter
)
{
this
.
_highlighter
.
off
(
"
highlighter
-
event
"
this
.
onHighlighterEvent
)
;
this
.
_highlighter
=
null
;
}
if
(
this
.
_tabbingOrderHighlighter
)
{
this
.
_tabbingOrderHighlighter
=
null
;
}
this
.
targetActor
=
null
;
this
.
refMap
=
null
;
}
getRef
(
rawAccessible
)
{
return
this
.
refMap
.
get
(
rawAccessible
)
;
}
addRef
(
rawAccessible
)
{
let
actor
=
this
.
refMap
.
get
(
rawAccessible
)
;
if
(
actor
)
{
return
actor
;
}
actor
=
new
AccessibleActor
(
this
rawAccessible
)
;
this
.
manage
(
actor
)
;
this
.
refMap
.
set
(
rawAccessible
actor
)
;
return
actor
;
}
purgeSubtree
(
rawAccessible
)
{
if
(
!
rawAccessible
)
{
return
;
}
try
{
for
(
let
child
=
rawAccessible
.
firstChild
;
child
;
child
=
child
.
nextSibling
)
{
this
.
purgeSubtree
(
child
)
;
}
}
catch
(
e
)
{
}
const
actor
=
this
.
getRef
(
rawAccessible
)
;
if
(
actor
)
{
actor
.
destroy
(
)
;
}
}
unmanage
(
actor
)
{
if
(
actor
instanceof
AccessibleActor
)
{
this
.
refMap
.
delete
(
actor
.
rawAccessible
)
;
}
Actor
.
prototype
.
unmanage
.
call
(
this
actor
)
;
}
async
children
(
)
{
if
(
this
.
_childrenPromise
)
{
return
this
.
_childrenPromise
;
}
this
.
_childrenPromise
=
Promise
.
all
(
[
this
.
getDocument
(
)
]
)
;
const
children
=
await
this
.
_childrenPromise
;
this
.
_childrenPromise
=
null
;
return
children
;
}
getDocument
(
)
{
if
(
!
this
.
rootDoc
|
|
!
this
.
rootDoc
.
documentElement
)
{
return
this
.
once
(
"
document
-
ready
"
)
.
then
(
docAcc
=
>
this
.
addRef
(
docAcc
)
)
;
}
if
(
this
.
isXUL
)
{
const
doc
=
this
.
addRef
(
this
.
getRawAccessibleFor
(
this
.
rootDoc
)
)
;
return
Promise
.
resolve
(
doc
)
;
}
const
doc
=
this
.
getRawAccessibleFor
(
this
.
rootDoc
)
;
if
(
!
doc
|
|
isStale
(
doc
)
)
{
return
this
.
once
(
"
document
-
ready
"
)
.
then
(
docAcc
=
>
this
.
addRef
(
docAcc
)
)
;
}
return
Promise
.
resolve
(
this
.
addRef
(
doc
)
)
;
}
getAccessibleFor
(
domNode
)
{
return
this
.
getDocument
(
)
.
then
(
(
)
=
>
{
const
rawAccessible
=
this
.
getRawAccessibleFor
(
domNode
.
rawNode
)
;
if
(
!
rawAccessible
)
{
return
null
;
}
return
this
.
addRef
(
rawAccessible
)
;
}
)
;
}
getRawAccessibleFor
(
rawNode
)
{
if
(
!
Services
.
appinfo
.
accessibilityEnabled
)
{
return
null
;
}
return
this
.
a11yService
.
getAccessibleFor
(
rawNode
)
;
}
async
getAncestry
(
accessible
)
{
if
(
!
accessible
|
|
accessible
.
indexInParent
=
=
=
-
1
)
{
return
[
]
;
}
const
doc
=
await
this
.
getDocument
(
)
;
const
ancestry
=
[
]
;
if
(
accessible
=
=
=
doc
)
{
return
ancestry
;
}
try
{
let
parent
=
accessible
;
while
(
parent
&
&
(
parent
=
parent
.
parentAcc
)
&
&
parent
!
=
doc
)
{
ancestry
.
push
(
parent
)
;
}
ancestry
.
push
(
doc
)
;
}
catch
(
error
)
{
throw
new
Error
(
Failed
to
get
ancestor
for
{
accessible
}
:
{
error
}
)
;
}
return
ancestry
.
map
(
parent
=
>
(
{
accessible
:
parent
children
:
parent
.
children
(
)
}
)
)
;
}
async
audit
(
options
)
{
const
doc
=
await
this
.
getDocument
(
)
;
const
report
=
new
Map
(
)
;
this
.
_auditProgress
=
new
AuditProgress
(
this
)
;
getAudit
(
doc
options
report
this
.
_auditProgress
)
;
this
.
_auditProgress
.
setTotal
(
report
.
size
)
;
await
Promise
.
all
(
report
.
values
(
)
)
;
const
ancestries
=
[
]
;
for
(
const
[
acc
audit
]
of
report
.
entries
(
)
)
{
if
(
audit
&
&
Object
.
values
(
audit
)
.
some
(
check
=
>
check
!
=
null
&
&
!
check
.
error
&
&
[
BEST_PRACTICES
FAIL
WARNING
]
.
includes
(
check
.
score
)
)
)
{
ancestries
.
push
(
this
.
getAncestry
(
acc
)
)
;
}
}
return
Promise
.
all
(
ancestries
)
;
}
startAudit
(
options
)
{
if
(
this
.
_auditing
)
{
return
;
}
this
.
_auditing
=
this
.
audit
(
options
)
.
then
(
ancestries
=
>
this
.
emit
(
"
audit
-
event
"
{
type
:
"
completed
"
ancestries
}
)
)
.
catch
(
(
)
=
>
this
.
emit
(
"
audit
-
event
"
{
type
:
"
error
"
}
)
)
.
finally
(
(
)
=
>
{
this
.
_auditing
=
null
;
this
.
_auditProgress
.
destroy
(
)
;
this
.
_auditProgress
=
null
;
}
)
;
}
onHighlighterEvent
(
data
)
{
this
.
emit
(
"
highlighter
-
event
"
data
)
;
}
observe
(
subject
)
{
const
event
=
subject
.
QueryInterface
(
Ci
.
nsIAccessibleEvent
)
;
const
rawAccessible
=
event
.
accessible
;
const
accessible
=
this
.
getRef
(
rawAccessible
)
;
if
(
rawAccessible
instanceof
Ci
.
nsIAccessibleDocument
&
&
!
accessible
)
{
const
rootDocAcc
=
this
.
getRawAccessibleFor
(
this
.
rootDoc
)
;
if
(
rawAccessible
=
=
=
rootDocAcc
&
&
!
isStale
(
rawAccessible
)
)
{
this
.
clearRefs
(
)
;
events
.
emit
(
this
"
document
-
ready
"
rawAccessible
)
;
}
}
switch
(
event
.
eventType
)
{
case
EVENT_STATE_CHANGE
:
const
{
state
isEnabled
}
=
event
.
QueryInterface
(
Ci
.
nsIAccessibleStateChangeEvent
)
;
const
isBusy
=
state
&
Ci
.
nsIAccessibleStates
.
STATE_BUSY
;
if
(
accessible
)
{
if
(
isBusy
&
&
isEnabled
)
{
if
(
rawAccessible
instanceof
Ci
.
nsIAccessibleDocument
)
{
this
.
clearRefs
(
)
;
}
return
;
}
events
.
emit
(
accessible
"
states
-
change
"
accessible
.
states
)
;
}
break
;
case
EVENT_NAME_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
name
-
change
"
rawAccessible
.
name
event
.
DOMNode
=
=
this
.
rootDoc
?
undefined
:
this
.
getRef
(
rawAccessible
.
parent
)
)
;
}
break
;
case
EVENT_VALUE_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
value
-
change
"
rawAccessible
.
value
)
;
}
break
;
case
EVENT_DESCRIPTION_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
description
-
change
"
rawAccessible
.
description
)
;
}
break
;
case
EVENT_REORDER
:
if
(
accessible
)
{
accessible
.
children
(
)
.
forEach
(
child
=
>
events
.
emit
(
child
"
index
-
in
-
parent
-
change
"
child
.
indexInParent
)
)
;
events
.
emit
(
accessible
"
reorder
"
rawAccessible
.
childCount
)
;
}
break
;
case
EVENT_HIDE
:
if
(
event
.
DOMNode
=
=
this
.
rootDoc
)
{
this
.
clearRefs
(
)
;
}
else
{
this
.
purgeSubtree
(
rawAccessible
)
;
}
break
;
case
EVENT_DEFACTION_CHANGE
:
case
EVENT_ACTION_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
actions
-
change
"
accessible
.
actions
)
;
}
break
;
case
EVENT_TEXT_CHANGED
:
case
EVENT_TEXT_INSERTED
:
case
EVENT_TEXT_REMOVED
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
text
-
change
"
)
;
if
(
NAME_FROM_SUBTREE_RULE_ROLES
.
has
(
rawAccessible
.
role
)
)
{
events
.
emit
(
accessible
"
name
-
change
"
rawAccessible
.
name
event
.
DOMNode
=
=
this
.
rootDoc
?
undefined
:
this
.
getRef
(
rawAccessible
.
parent
)
)
;
}
}
break
;
case
EVENT_DOCUMENT_ATTRIBUTES_CHANGED
:
case
EVENT_OBJECT_ATTRIBUTE_CHANGED
:
case
EVENT_TEXT_ATTRIBUTE_CHANGED
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
attributes
-
change
"
accessible
.
attributes
)
;
}
break
;
case
EVENT_ACCELERATOR_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
shortcut
-
change
"
accessible
.
keyboardShortcut
)
;
}
break
;
default
:
break
;
}
}
async
clearStyles
(
win
)
{
const
requests
=
this
.
_loadedSheets
.
get
(
win
)
;
if
(
requests
!
=
null
)
{
this
.
_loadedSheets
.
set
(
win
requests
+
1
)
;
return
;
}
loadSheetForBackgroundCalculation
(
win
)
;
this
.
_loadedSheets
.
set
(
win
1
)
;
await
this
.
hideHighlighter
(
)
;
}
async
restoreStyles
(
win
)
{
const
requests
=
this
.
_loadedSheets
.
get
(
win
)
;
if
(
!
requests
)
{
return
;
}
if
(
requests
>
1
)
{
this
.
_loadedSheets
.
set
(
win
requests
-
1
)
;
return
;
}
await
this
.
showHighlighter
(
)
;
removeSheetForBackgroundCalculation
(
win
)
;
this
.
_loadedSheets
.
delete
(
win
)
;
}
async
hideHighlighter
(
)
{
if
(
this
.
_highlighter
)
{
const
highlighter
=
this
.
_highlighter
.
instance
;
await
highlighter
.
isReady
;
highlighter
.
hideAccessibleBounds
(
)
;
}
}
async
showHighlighter
(
)
{
if
(
this
.
_highlighter
)
{
const
highlighter
=
this
.
_highlighter
.
instance
;
await
highlighter
.
isReady
;
highlighter
.
showAccessibleBounds
(
)
;
}
}
async
highlightAccessible
(
accessible
options
=
{
}
)
{
this
.
unhighlight
(
)
;
if
(
!
accessible
|
|
accessible
.
isDefunct
|
|
accessible
.
indexInParent
<
0
)
{
return
false
;
}
this
.
_highlightingAccessible
=
accessible
;
const
{
bounds
}
=
accessible
;
if
(
!
bounds
)
{
return
false
;
}
const
{
DOMNode
:
rawNode
}
=
accessible
.
rawAccessible
;
const
audit
=
await
accessible
.
audit
(
)
;
if
(
this
.
_highlightingAccessible
!
=
=
accessible
)
{
return
false
;
}
const
{
name
role
}
=
accessible
;
const
{
highlighter
}
=
this
;
await
highlighter
.
instance
.
isReady
;
if
(
this
.
_highlightingAccessible
!
=
=
accessible
)
{
return
false
;
}
const
shown
=
highlighter
.
show
(
{
rawNode
}
{
.
.
.
options
.
.
.
bounds
name
role
audit
isXUL
:
this
.
isXUL
}
)
;
this
.
_highlightingAccessible
=
null
;
return
shown
;
}
unhighlight
(
)
{
if
(
!
this
.
_highlighter
)
{
return
;
}
this
.
highlighter
.
hide
(
)
;
this
.
_highlightingAccessible
=
null
;
}
_isPicking
:
false
_currentAccessible
:
null
_isEventAllowed
(
{
view
}
)
{
return
(
this
.
rootWin
instanceof
Ci
.
nsIDOMChromeWindow
|
|
isWindowIncluded
(
this
.
rootWin
view
)
)
;
}
_ignoreEventWhenPicking
(
event
)
{
return
(
!
this
.
_isPicking
|
|
isFrameWithChildTarget
(
this
.
targetActor
event
.
originalTarget
|
|
event
.
target
)
)
;
}
_preventContentEvent
(
event
)
{
if
(
this
.
_ignoreEventWhenPicking
(
event
)
)
{
return
;
}
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
const
target
=
event
.
originalTarget
|
|
event
.
target
;
if
(
target
!
=
=
this
.
_currentTarget
)
{
this
.
_resetStateAndReleaseTarget
(
)
;
this
.
_currentTarget
=
target
;
this
.
_currentTargetHoverState
=
InspectorUtils
.
getContentState
(
target
)
&
kStateHover
;
InspectorUtils
.
removeContentState
(
target
kStateHover
)
;
}
}
onPick
(
event
)
{
if
(
this
.
_ignoreEventWhenPicking
(
event
)
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
if
(
event
.
shiftKey
)
{
if
(
!
this
.
_currentAccessible
)
{
this
.
_currentAccessible
=
this
.
_findAndAttachAccessible
(
event
)
;
}
events
.
emit
(
this
"
picker
-
accessible
-
previewed
"
this
.
_currentAccessible
)
;
return
;
}
this
.
_unsetPickerEnvironment
(
)
;
this
.
_isPicking
=
false
;
if
(
!
this
.
_currentAccessible
)
{
this
.
_currentAccessible
=
this
.
_findAndAttachAccessible
(
event
)
;
}
events
.
emit
(
this
"
picker
-
accessible
-
picked
"
this
.
_currentAccessible
)
;
}
async
onHovered
(
event
)
{
if
(
this
.
_ignoreEventWhenPicking
(
event
)
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
const
accessible
=
this
.
_findAndAttachAccessible
(
event
)
;
if
(
!
accessible
|
|
this
.
_currentAccessible
=
=
=
accessible
)
{
return
;
}
this
.
_currentAccessible
=
accessible
;
const
shown
=
await
this
.
highlightAccessible
(
accessible
)
;
if
(
this
.
_isPicking
&
&
shown
&
&
accessible
=
=
=
this
.
_currentAccessible
)
{
events
.
emit
(
this
"
picker
-
accessible
-
hovered
"
accessible
)
;
}
}
onKey
(
event
)
{
if
(
!
this
.
_currentAccessible
|
|
this
.
_ignoreEventWhenPicking
(
event
)
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
switch
(
event
.
keyCode
)
{
case
event
.
DOM_VK_RETURN
:
this
.
onPick
(
event
)
;
break
;
case
event
.
DOM_VK_ESCAPE
:
this
.
cancelPick
(
)
;
events
.
emit
(
this
"
picker
-
accessible
-
canceled
"
)
;
break
;
case
event
.
DOM_VK_C
:
if
(
(
IS_OSX
&
&
event
.
metaKey
&
&
event
.
altKey
)
|
|
(
!
IS_OSX
&
&
event
.
ctrlKey
&
&
event
.
shiftKey
)
)
{
this
.
cancelPick
(
)
;
events
.
emit
(
this
"
picker
-
accessible
-
canceled
"
)
;
}
break
;
default
:
break
;
}
}
pick
(
)
{
if
(
!
this
.
_isPicking
)
{
this
.
_isPicking
=
true
;
this
.
_setPickerEnvironment
(
)
;
}
}
pickAndFocus
(
)
{
this
.
pick
(
)
;
this
.
rootWin
.
focus
(
)
;
}
attachAccessible
(
rawAccessible
accessibleDocument
)
{
if
(
!
rawAccessible
|
|
isDefunct
(
rawAccessible
)
|
|
rawAccessible
.
indexInParent
<
0
)
{
return
null
;
}
const
accessible
=
this
.
addRef
(
rawAccessible
)
;
try
{
let
parent
=
accessible
;
while
(
parent
&
&
parent
.
rawAccessible
!
=
accessibleDocument
)
{
parent
=
parent
.
parentAcc
;
}
}
catch
(
error
)
{
throw
new
Error
(
Failed
to
get
ancestor
for
{
accessible
}
:
{
error
}
)
;
}
return
accessible
;
}
get
pixelRatio
(
)
{
return
this
.
rootWin
.
devicePixelRatio
;
}
_findAndAttachAccessible
(
event
)
{
const
target
=
event
.
originalTarget
|
|
event
.
target
;
const
docAcc
=
this
.
getRawAccessibleFor
(
this
.
rootDoc
)
;
const
win
=
target
.
ownerGlobal
;
const
zoom
=
this
.
isXUL
?
1
:
getCurrentZoom
(
win
)
;
const
scale
=
this
.
pixelRatio
/
zoom
;
const
rawAccessible
=
docAcc
.
getDeepestChildAtPointInProcess
(
event
.
screenX
*
scale
event
.
screenY
*
scale
)
;
return
this
.
attachAccessible
(
rawAccessible
docAcc
)
;
}
_setPickerEnvironment
(
)
{
const
target
=
this
.
targetActor
.
chromeEventHandler
;
target
.
addEventListener
(
"
mousemove
"
this
.
onHovered
true
)
;
target
.
addEventListener
(
"
click
"
this
.
onPick
true
)
;
target
.
addEventListener
(
"
mousedown
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
mouseup
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
mouseover
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
mouseout
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
mouseleave
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
mouseenter
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
dblclick
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
keydown
"
this
.
onKey
true
)
;
target
.
addEventListener
(
"
keyup
"
this
.
_preventContentEvent
true
)
;
}
_unsetPickerEnvironment
(
)
{
const
target
=
this
.
targetActor
.
chromeEventHandler
;
if
(
!
target
)
{
return
;
}
target
.
removeEventListener
(
"
mousemove
"
this
.
onHovered
true
)
;
target
.
removeEventListener
(
"
click
"
this
.
onPick
true
)
;
target
.
removeEventListener
(
"
mousedown
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
mouseup
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
mouseover
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
mouseout
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
mouseleave
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
mouseenter
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
dblclick
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
keydown
"
this
.
onKey
true
)
;
target
.
removeEventListener
(
"
keyup
"
this
.
_preventContentEvent
true
)
;
this
.
_resetStateAndReleaseTarget
(
)
;
}
_resetStateAndReleaseTarget
(
)
{
if
(
!
this
.
_currentTarget
)
{
return
;
}
try
{
if
(
this
.
_currentTargetHoverState
)
{
InspectorUtils
.
setContentState
(
this
.
_currentTarget
kStateHover
)
;
}
}
catch
(
e
)
{
}
this
.
_currentTarget
=
null
;
this
.
_currentTargetState
=
null
;
}
cancelPick
(
)
{
this
.
unhighlight
(
)
;
if
(
this
.
_isPicking
)
{
this
.
_unsetPickerEnvironment
(
)
;
this
.
_isPicking
=
false
;
this
.
_currentAccessible
=
null
;
}
}
_isTrackingTabbingOrderFocus
:
false
_currentFocusedTabbingOrder
:
null
async
onFocusIn
(
event
)
{
if
(
!
this
.
_isTrackingTabbingOrderFocus
)
{
return
;
}
const
target
=
event
.
originalTarget
|
|
event
.
target
;
if
(
target
=
=
=
this
.
_currentFocusedTabbingOrder
)
{
return
;
}
this
.
_currentFocusedTabbingOrder
=
target
;
this
.
tabbingOrderHighlighter
.
_highlighter
.
updateFocus
(
{
node
:
target
focused
:
true
}
)
;
}
async
onFocusOut
(
event
)
{
if
(
!
this
.
_isTrackingTabbingOrderFocus
|
|
!
this
.
_currentFocusedTabbingOrder
)
{
return
;
}
const
target
=
event
.
originalTarget
|
|
event
.
target
;
if
(
target
!
=
=
this
.
_currentFocusedTabbingOrder
)
{
console
.
warn
(
focusout
target
:
{
target
}
does
not
match
current
focused
element
in
tabbing
order
:
{
this
.
_currentFocusedTabbingOrder
}
)
;
}
this
.
tabbingOrderHighlighter
.
_highlighter
.
updateFocus
(
{
node
:
this
.
_currentFocusedTabbingOrder
focused
:
false
}
)
;
this
.
_currentFocusedTabbingOrder
=
null
;
}
showTabbingOrder
(
elm
index
)
{
if
(
!
this
.
_isTrackingTabbingOrderFocus
)
{
this
.
_isTrackingTabbingOrderFocus
=
true
;
const
target
=
this
.
targetActor
.
chromeEventHandler
;
target
.
addEventListener
(
"
focusin
"
this
.
onFocusIn
true
)
;
target
.
addEventListener
(
"
focusout
"
this
.
onFocusOut
true
)
;
}
return
this
.
tabbingOrderHighlighter
.
show
(
elm
{
index
}
)
;
}
hideTabbingOrder
(
)
{
if
(
!
this
.
_tabbingOrderHighlighter
)
{
return
;
}
this
.
tabbingOrderHighlighter
.
hide
(
)
;
if
(
!
this
.
_isTrackingTabbingOrderFocus
)
{
return
;
}
this
.
_isTrackingTabbingOrderFocus
=
false
;
this
.
_currentFocusedTabbingOrder
=
null
;
const
target
=
this
.
targetActor
.
chromeEventHandler
;
if
(
target
)
{
target
.
removeEventListener
(
"
focusin
"
this
.
onFocusIn
true
)
;
target
.
removeEventListener
(
"
focusout
"
this
.
onFocusOut
true
)
;
}
}
}
)
;
exports
.
AccessibleWalkerActor
=
AccessibleWalkerActor
;
