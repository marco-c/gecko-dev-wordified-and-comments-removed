"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Actor
ActorClassWithSpec
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
accessibleWalkerSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
accessibility
"
)
;
loader
.
lazyRequireGetter
(
this
"
AccessibleActor
"
"
devtools
/
server
/
actors
/
accessibility
/
accessible
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CustomHighlighterActor
"
"
devtools
/
server
/
actors
/
highlighters
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsUtils
"
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
events
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
getCurrentZoom
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorUtils
"
"
InspectorUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
isDefunct
"
"
devtools
/
server
/
actors
/
utils
/
accessibility
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isTypeRegistered
"
"
devtools
/
server
/
actors
/
highlighters
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isWindowIncluded
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isXUL
"
"
devtools
/
server
/
actors
/
highlighters
/
utils
/
markup
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
loadSheet
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
register
"
"
devtools
/
server
/
actors
/
highlighters
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
removeSheet
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
const
kStateHover
=
0x00000004
;
const
HIGHLIGHTER_STYLES_SHEET
=
data
:
text
/
css
;
charset
=
utf
-
8
*
{
transition
:
none
!
important
;
}
:
-
moz
-
devtools
-
highlighted
{
color
:
transparent
!
important
;
text
-
shadow
:
none
!
important
;
}
;
const
nsIAccessibleEvent
=
Ci
.
nsIAccessibleEvent
;
const
nsIAccessibleStateChangeEvent
=
Ci
.
nsIAccessibleStateChangeEvent
;
const
nsIAccessibleRole
=
Ci
.
nsIAccessibleRole
;
const
{
EVENT_TEXT_CHANGED
EVENT_TEXT_INSERTED
EVENT_TEXT_REMOVED
EVENT_ACCELERATOR_CHANGE
EVENT_ACTION_CHANGE
EVENT_DEFACTION_CHANGE
EVENT_DESCRIPTION_CHANGE
EVENT_DOCUMENT_ATTRIBUTES_CHANGED
EVENT_HIDE
EVENT_NAME_CHANGE
EVENT_OBJECT_ATTRIBUTE_CHANGED
EVENT_REORDER
EVENT_STATE_CHANGE
EVENT_TEXT_ATTRIBUTE_CHANGED
EVENT_VALUE_CHANGE
}
=
nsIAccessibleEvent
;
const
NAME_FROM_SUBTREE_RULE_ROLES
=
new
Set
(
[
nsIAccessibleRole
.
ROLE_BUTTONDROPDOWN
nsIAccessibleRole
.
ROLE_BUTTONDROPDOWNGRID
nsIAccessibleRole
.
ROLE_BUTTONMENU
nsIAccessibleRole
.
ROLE_CELL
nsIAccessibleRole
.
ROLE_CHECKBUTTON
nsIAccessibleRole
.
ROLE_CHECK_MENU_ITEM
nsIAccessibleRole
.
ROLE_CHECK_RICH_OPTION
nsIAccessibleRole
.
ROLE_COLUMN
nsIAccessibleRole
.
ROLE_COLUMNHEADER
nsIAccessibleRole
.
ROLE_COMBOBOX_OPTION
nsIAccessibleRole
.
ROLE_DEFINITION
nsIAccessibleRole
.
ROLE_GRID_CELL
nsIAccessibleRole
.
ROLE_HEADING
nsIAccessibleRole
.
ROLE_HELPBALLOON
nsIAccessibleRole
.
ROLE_HTML_CONTAINER
nsIAccessibleRole
.
ROLE_KEY
nsIAccessibleRole
.
ROLE_LABEL
nsIAccessibleRole
.
ROLE_LINK
nsIAccessibleRole
.
ROLE_LISTITEM
nsIAccessibleRole
.
ROLE_MATHML_IDENTIFIER
nsIAccessibleRole
.
ROLE_MATHML_NUMBER
nsIAccessibleRole
.
ROLE_MATHML_OPERATOR
nsIAccessibleRole
.
ROLE_MATHML_TEXT
nsIAccessibleRole
.
ROLE_MATHML_STRING_LITERAL
nsIAccessibleRole
.
ROLE_MATHML_GLYPH
nsIAccessibleRole
.
ROLE_MENUITEM
nsIAccessibleRole
.
ROLE_OPTION
nsIAccessibleRole
.
ROLE_OUTLINEITEM
nsIAccessibleRole
.
ROLE_PAGETAB
nsIAccessibleRole
.
ROLE_PARENT_MENUITEM
nsIAccessibleRole
.
ROLE_PUSHBUTTON
nsIAccessibleRole
.
ROLE_RADIOBUTTON
nsIAccessibleRole
.
ROLE_RADIO_MENU_ITEM
nsIAccessibleRole
.
ROLE_RICH_OPTION
nsIAccessibleRole
.
ROLE_ROW
nsIAccessibleRole
.
ROLE_ROWHEADER
nsIAccessibleRole
.
ROLE_SUMMARY
nsIAccessibleRole
.
ROLE_SWITCH
nsIAccessibleRole
.
ROLE_TABLE_COLUMN_HEADER
nsIAccessibleRole
.
ROLE_TABLE_ROW_HEADER
nsIAccessibleRole
.
ROLE_TEAR_OFF_MENU_ITEM
nsIAccessibleRole
.
ROLE_TERM
nsIAccessibleRole
.
ROLE_TOGGLE_BUTTON
nsIAccessibleRole
.
ROLE_TOOLTIP
]
)
;
const
IS_OSX
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
function
isStale
(
accessible
)
{
const
extraState
=
{
}
;
accessible
.
getState
(
{
}
extraState
)
;
return
!
!
(
extraState
.
value
&
Ci
.
nsIAccessibleStates
.
EXT_STATE_STALE
)
;
}
const
AccessibleWalkerActor
=
ActorClassWithSpec
(
accessibleWalkerSpec
{
initialize
(
conn
targetActor
)
{
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
targetActor
=
targetActor
;
this
.
refMap
=
new
Map
(
)
;
this
.
setA11yServiceGetter
(
)
;
this
.
onPick
=
this
.
onPick
.
bind
(
this
)
;
this
.
onHovered
=
this
.
onHovered
.
bind
(
this
)
;
this
.
_preventContentEvent
=
this
.
_preventContentEvent
.
bind
(
this
)
;
this
.
onKey
=
this
.
onKey
.
bind
(
this
)
;
this
.
onHighlighterEvent
=
this
.
onHighlighterEvent
.
bind
(
this
)
;
}
get
highlighter
(
)
{
if
(
!
this
.
_highlighter
)
{
if
(
isXUL
(
this
.
rootWin
)
)
{
if
(
!
isTypeRegistered
(
"
XULWindowAccessibleHighlighter
"
)
)
{
register
(
"
XULWindowAccessibleHighlighter
"
"
xul
-
accessible
"
)
;
}
this
.
_highlighter
=
CustomHighlighterActor
(
this
"
XULWindowAccessibleHighlighter
"
)
;
}
else
{
if
(
!
isTypeRegistered
(
"
AccessibleHighlighter
"
)
)
{
register
(
"
AccessibleHighlighter
"
"
accessible
"
)
;
}
this
.
_highlighter
=
CustomHighlighterActor
(
this
"
AccessibleHighlighter
"
)
;
}
this
.
manage
(
this
.
_highlighter
)
;
this
.
_highlighter
.
on
(
"
highlighter
-
event
"
this
.
onHighlighterEvent
)
;
}
return
this
.
_highlighter
;
}
setA11yServiceGetter
(
)
{
DevToolsUtils
.
defineLazyGetter
(
this
"
a11yService
"
(
)
=
>
{
Services
.
obs
.
addObserver
(
this
"
accessible
-
event
"
)
;
return
Cc
[
"
mozilla
.
org
/
accessibilityService
;
1
"
]
.
getService
(
Ci
.
nsIAccessibilityService
)
;
}
)
;
}
get
rootWin
(
)
{
return
this
.
targetActor
&
&
this
.
targetActor
.
window
;
}
get
rootDoc
(
)
{
return
this
.
targetActor
&
&
this
.
targetActor
.
window
.
document
;
}
reset
(
)
{
try
{
Services
.
obs
.
removeObserver
(
this
"
accessible
-
event
"
)
;
}
catch
(
e
)
{
}
this
.
cancelPick
(
)
;
if
(
this
.
refMap
.
size
>
0
)
{
try
{
if
(
this
.
rootDoc
)
{
this
.
purgeSubtree
(
this
.
getRawAccessibleFor
(
this
.
rootDoc
)
this
.
rootDoc
)
;
}
}
catch
(
e
)
{
}
finally
{
this
.
refMap
.
clear
(
)
;
}
}
this
.
_childrenPromise
=
null
;
delete
this
.
a11yService
;
this
.
setA11yServiceGetter
(
)
;
}
destroy
(
)
{
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
reset
(
)
;
if
(
this
.
_highlighter
)
{
this
.
_highlighter
.
off
(
"
highlighter
-
event
"
this
.
onHighlighterEvent
)
;
this
.
_highlighter
=
null
;
}
this
.
targetActor
=
null
;
this
.
refMap
=
null
;
}
getRef
(
rawAccessible
)
{
return
this
.
refMap
.
get
(
rawAccessible
)
;
}
addRef
(
rawAccessible
)
{
let
actor
=
this
.
refMap
.
get
(
rawAccessible
)
;
if
(
actor
)
{
return
actor
;
}
actor
=
new
AccessibleActor
(
this
rawAccessible
)
;
this
.
manage
(
actor
)
;
this
.
refMap
.
set
(
rawAccessible
actor
)
;
return
actor
;
}
purgeSubtree
(
rawAccessible
rawNode
)
{
if
(
!
rawAccessible
)
{
return
;
}
const
actor
=
this
.
getRef
(
rawAccessible
)
;
if
(
actor
&
&
rawAccessible
&
&
!
actor
.
isDefunct
)
{
for
(
let
child
=
rawAccessible
.
firstChild
;
child
;
child
=
child
.
nextSibling
)
{
this
.
purgeSubtree
(
child
)
;
}
}
this
.
refMap
.
delete
(
rawAccessible
)
;
if
(
actor
)
{
events
.
emit
(
this
"
accessible
-
destroy
"
actor
)
;
actor
.
destroy
(
)
;
}
if
(
rawNode
&
&
rawNode
=
=
=
this
.
rootDoc
)
{
this
.
refMap
.
clear
(
)
;
}
}
async
children
(
)
{
if
(
this
.
_childrenPromise
)
{
return
this
.
_childrenPromise
;
}
this
.
_childrenPromise
=
Promise
.
all
(
[
this
.
getDocument
(
)
]
)
;
const
children
=
await
this
.
_childrenPromise
;
this
.
_childrenPromise
=
null
;
return
children
;
}
getDocument
(
)
{
if
(
!
this
.
rootDoc
|
|
!
this
.
rootDoc
.
documentElement
)
{
return
this
.
once
(
"
document
-
ready
"
)
.
then
(
docAcc
=
>
this
.
addRef
(
docAcc
)
)
;
}
if
(
isXUL
(
this
.
rootWin
)
)
{
const
doc
=
this
.
addRef
(
this
.
getRawAccessibleFor
(
this
.
rootDoc
)
)
;
return
Promise
.
resolve
(
doc
)
;
}
const
doc
=
this
.
getRawAccessibleFor
(
this
.
rootDoc
)
;
if
(
isStale
(
doc
)
)
{
return
this
.
once
(
"
document
-
ready
"
)
.
then
(
docAcc
=
>
this
.
addRef
(
docAcc
)
)
;
}
return
Promise
.
resolve
(
this
.
addRef
(
doc
)
)
;
}
getAccessibleFor
(
domNode
)
{
return
this
.
getDocument
(
)
.
then
(
(
)
=
>
this
.
addRef
(
this
.
getRawAccessibleFor
(
domNode
.
rawNode
)
)
)
;
}
getRawAccessibleFor
(
rawNode
)
{
if
(
!
Services
.
appinfo
.
accessibilityEnabled
)
{
return
null
;
}
return
this
.
a11yService
.
getAccessibleFor
(
rawNode
)
;
}
async
getAncestry
(
accessible
)
{
if
(
!
accessible
|
|
accessible
.
indexInParent
=
=
=
-
1
)
{
return
[
]
;
}
const
doc
=
await
this
.
getDocument
(
)
;
const
ancestry
=
[
]
;
if
(
accessible
=
=
=
doc
)
{
return
ancestry
;
}
try
{
let
parent
=
accessible
;
while
(
parent
&
&
(
parent
=
parent
.
parentAcc
)
&
&
parent
!
=
doc
)
{
ancestry
.
push
(
parent
)
;
}
ancestry
.
push
(
doc
)
;
}
catch
(
error
)
{
throw
new
Error
(
Failed
to
get
ancestor
for
{
accessible
}
:
{
error
}
)
;
}
return
ancestry
.
map
(
parent
=
>
(
{
accessible
:
parent
children
:
parent
.
children
(
)
}
)
)
;
}
onHighlighterEvent
:
function
(
data
)
{
this
.
emit
(
"
highlighter
-
event
"
data
)
;
}
observe
(
subject
)
{
const
event
=
subject
.
QueryInterface
(
nsIAccessibleEvent
)
;
const
rawAccessible
=
event
.
accessible
;
const
accessible
=
this
.
getRef
(
rawAccessible
)
;
if
(
(
rawAccessible
instanceof
Ci
.
nsIAccessibleDocument
)
&
&
!
accessible
)
{
const
rootDocAcc
=
this
.
getRawAccessibleFor
(
this
.
rootDoc
)
;
if
(
rawAccessible
=
=
=
rootDocAcc
&
&
!
isStale
(
rawAccessible
)
)
{
this
.
purgeSubtree
(
rawAccessible
event
.
DOMNode
)
;
events
.
emit
(
this
"
document
-
ready
"
rawAccessible
)
;
}
}
switch
(
event
.
eventType
)
{
case
EVENT_STATE_CHANGE
:
const
{
state
isEnabled
}
=
event
.
QueryInterface
(
nsIAccessibleStateChangeEvent
)
;
const
isBusy
=
state
&
Ci
.
nsIAccessibleStates
.
STATE_BUSY
;
if
(
accessible
)
{
if
(
isBusy
&
&
isEnabled
)
{
if
(
rawAccessible
instanceof
Ci
.
nsIAccessibleDocument
)
{
this
.
purgeSubtree
(
rawAccessible
event
.
DOMNode
)
;
}
return
;
}
events
.
emit
(
accessible
"
states
-
change
"
accessible
.
states
)
;
}
break
;
case
EVENT_NAME_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
name
-
change
"
rawAccessible
.
name
event
.
DOMNode
=
=
this
.
rootDoc
?
undefined
:
this
.
getRef
(
rawAccessible
.
parent
)
this
)
;
}
break
;
case
EVENT_VALUE_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
value
-
change
"
rawAccessible
.
value
)
;
}
break
;
case
EVENT_DESCRIPTION_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
description
-
change
"
rawAccessible
.
description
)
;
}
break
;
case
EVENT_REORDER
:
if
(
accessible
)
{
accessible
.
children
(
)
.
forEach
(
child
=
>
events
.
emit
(
child
"
index
-
in
-
parent
-
change
"
child
.
indexInParent
)
)
;
events
.
emit
(
accessible
"
reorder
"
rawAccessible
.
childCount
this
)
;
}
break
;
case
EVENT_HIDE
:
this
.
purgeSubtree
(
rawAccessible
)
;
break
;
case
EVENT_DEFACTION_CHANGE
:
case
EVENT_ACTION_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
actions
-
change
"
accessible
.
actions
)
;
}
break
;
case
EVENT_TEXT_CHANGED
:
case
EVENT_TEXT_INSERTED
:
case
EVENT_TEXT_REMOVED
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
text
-
change
"
this
)
;
if
(
NAME_FROM_SUBTREE_RULE_ROLES
.
has
(
rawAccessible
.
role
)
)
{
events
.
emit
(
accessible
"
name
-
change
"
rawAccessible
.
name
event
.
DOMNode
=
=
this
.
rootDoc
?
undefined
:
this
.
getRef
(
rawAccessible
.
parent
)
this
)
;
}
}
break
;
case
EVENT_DOCUMENT_ATTRIBUTES_CHANGED
:
case
EVENT_OBJECT_ATTRIBUTE_CHANGED
:
case
EVENT_TEXT_ATTRIBUTE_CHANGED
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
attributes
-
change
"
accessible
.
attributes
)
;
}
break
;
case
EVENT_ACCELERATOR_CHANGE
:
if
(
accessible
)
{
events
.
emit
(
accessible
"
shortcut
-
change
"
accessible
.
keyboardShortcut
)
;
}
break
;
default
:
break
;
}
}
loadTransitionDisablingStyleSheet
(
win
)
{
if
(
this
.
_sheetLoaded
)
{
return
;
}
loadSheet
(
win
HIGHLIGHTER_STYLES_SHEET
)
;
this
.
_sheetLoaded
=
true
;
}
removeTransitionDisablingStyleSheet
(
win
)
{
if
(
!
this
.
_sheetLoaded
)
{
return
;
}
removeSheet
(
win
HIGHLIGHTER_STYLES_SHEET
)
;
this
.
_sheetLoaded
=
false
;
}
async
highlightAccessible
(
accessible
options
=
{
}
)
{
this
.
unhighlight
(
)
;
if
(
!
accessible
|
|
accessible
.
isDefunct
|
|
accessible
.
indexInParent
<
0
)
{
return
false
;
}
this
.
_highlightingAccessible
=
accessible
;
const
{
bounds
}
=
accessible
;
if
(
!
bounds
)
{
return
false
;
}
const
{
DOMNode
:
rawNode
}
=
accessible
.
rawAccessible
;
const
audit
=
await
accessible
.
audit
(
)
;
if
(
this
.
_highlightingAccessible
!
=
=
accessible
)
{
return
false
;
}
const
{
name
role
}
=
accessible
;
const
shown
=
this
.
highlighter
.
show
(
{
rawNode
}
{
.
.
.
options
.
.
.
bounds
name
role
audit
}
)
;
this
.
_highlightingAccessible
=
null
;
return
shown
;
}
unhighlight
(
)
{
if
(
!
this
.
_highlighter
)
{
return
;
}
this
.
highlighter
.
hide
(
)
;
this
.
_highlightingAccessible
=
null
;
}
_isPicking
:
false
_currentAccessible
:
null
_isEventAllowed
:
function
(
{
view
}
)
{
return
this
.
rootWin
instanceof
Ci
.
nsIDOMChromeWindow
|
|
isWindowIncluded
(
this
.
rootWin
view
)
;
}
_preventContentEvent
(
event
)
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
const
target
=
event
.
originalTarget
|
|
event
.
target
;
if
(
target
!
=
=
this
.
_currentTarget
)
{
this
.
_resetStateAndReleaseTarget
(
)
;
this
.
_currentTarget
=
target
;
this
.
_currentTargetHoverState
=
InspectorUtils
.
getContentState
(
target
)
&
kStateHover
;
InspectorUtils
.
removeContentState
(
target
kStateHover
)
;
}
}
onPick
(
event
)
{
if
(
!
this
.
_isPicking
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
if
(
event
.
shiftKey
)
{
if
(
!
this
.
_currentAccessible
)
{
this
.
_currentAccessible
=
this
.
_findAndAttachAccessible
(
event
)
;
}
events
.
emit
(
this
"
picker
-
accessible
-
previewed
"
this
.
_currentAccessible
)
;
return
;
}
this
.
_unsetPickerEnvironment
(
)
;
this
.
_isPicking
=
false
;
if
(
!
this
.
_currentAccessible
)
{
this
.
_currentAccessible
=
this
.
_findAndAttachAccessible
(
event
)
;
}
events
.
emit
(
this
"
picker
-
accessible
-
picked
"
this
.
_currentAccessible
)
;
}
async
onHovered
(
event
)
{
if
(
!
this
.
_isPicking
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
const
accessible
=
this
.
_findAndAttachAccessible
(
event
)
;
if
(
!
accessible
|
|
this
.
_currentAccessible
=
=
=
accessible
)
{
return
;
}
this
.
_currentAccessible
=
accessible
;
const
shown
=
await
this
.
highlightAccessible
(
accessible
)
;
if
(
this
.
_isPicking
&
&
shown
&
&
accessible
=
=
=
this
.
_currentAccessible
)
{
events
.
emit
(
this
"
picker
-
accessible
-
hovered
"
accessible
)
;
}
}
onKey
(
event
)
{
if
(
!
this
.
_currentAccessible
|
|
!
this
.
_isPicking
)
{
return
;
}
this
.
_preventContentEvent
(
event
)
;
if
(
!
this
.
_isEventAllowed
(
event
)
)
{
return
;
}
switch
(
event
.
keyCode
)
{
case
event
.
DOM_VK_RETURN
:
this
.
_onPick
(
event
)
;
break
;
case
event
.
DOM_VK_ESCAPE
:
this
.
cancelPick
(
)
;
events
.
emit
(
this
"
picker
-
accessible
-
canceled
"
)
;
break
;
case
event
.
DOM_VK_C
:
if
(
(
IS_OSX
&
&
event
.
metaKey
&
&
event
.
altKey
)
|
|
(
!
IS_OSX
&
&
event
.
ctrlKey
&
&
event
.
shiftKey
)
)
{
this
.
cancelPick
(
)
;
events
.
emit
(
this
"
picker
-
accessible
-
canceled
"
)
;
}
break
;
default
:
break
;
}
}
pick
:
function
(
)
{
if
(
!
this
.
_isPicking
)
{
this
.
_isPicking
=
true
;
this
.
_setPickerEnvironment
(
)
;
}
}
pickAndFocus
:
function
(
)
{
this
.
pick
(
)
;
this
.
rootWin
.
focus
(
)
;
}
attachAccessible
(
rawAccessible
accessibleDocument
)
{
if
(
!
rawAccessible
|
|
isDefunct
(
rawAccessible
)
|
|
rawAccessible
.
indexInParent
<
0
)
{
return
null
;
}
const
accessible
=
this
.
addRef
(
rawAccessible
)
;
try
{
let
parent
=
accessible
;
while
(
parent
&
&
parent
.
rawAccessible
!
=
accessibleDocument
)
{
parent
=
parent
.
parentAcc
;
}
}
catch
(
error
)
{
throw
new
Error
(
Failed
to
get
ancestor
for
{
accessible
}
:
{
error
}
)
;
}
return
accessible
;
}
get
pixelRatio
(
)
{
const
{
contentViewer
}
=
this
.
targetActor
.
docShell
;
const
{
windowUtils
}
=
this
.
rootWin
;
const
overrideDPPX
=
contentViewer
.
overrideDPPX
;
let
ratio
;
if
(
overrideDPPX
)
{
contentViewer
.
overrideDPPX
=
0
;
ratio
=
windowUtils
.
screenPixelsPerCSSPixel
;
contentViewer
.
overrideDPPX
=
overrideDPPX
;
}
else
{
ratio
=
windowUtils
.
screenPixelsPerCSSPixel
;
}
return
ratio
;
}
_findAndAttachAccessible
(
event
)
{
const
target
=
event
.
originalTarget
|
|
event
.
target
;
const
docAcc
=
this
.
getRawAccessibleFor
(
this
.
rootDoc
)
;
const
win
=
target
.
ownerGlobal
;
const
scale
=
this
.
pixelRatio
/
getCurrentZoom
(
win
)
;
const
rawAccessible
=
docAcc
.
getDeepestChildAtPoint
(
event
.
screenX
*
scale
event
.
screenY
*
scale
)
;
return
this
.
attachAccessible
(
rawAccessible
docAcc
)
;
}
_setPickerEnvironment
:
function
(
)
{
const
target
=
this
.
targetActor
.
chromeEventHandler
;
target
.
addEventListener
(
"
mousemove
"
this
.
onHovered
true
)
;
target
.
addEventListener
(
"
click
"
this
.
onPick
true
)
;
target
.
addEventListener
(
"
mousedown
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
mouseup
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
mouseover
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
mouseout
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
mouseleave
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
mouseenter
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
dblclick
"
this
.
_preventContentEvent
true
)
;
target
.
addEventListener
(
"
keydown
"
this
.
onKey
true
)
;
target
.
addEventListener
(
"
keyup
"
this
.
_preventContentEvent
true
)
;
}
_unsetPickerEnvironment
:
function
(
)
{
const
target
=
this
.
targetActor
.
chromeEventHandler
;
if
(
!
target
)
{
return
;
}
target
.
removeEventListener
(
"
mousemove
"
this
.
onHovered
true
)
;
target
.
removeEventListener
(
"
click
"
this
.
onPick
true
)
;
target
.
removeEventListener
(
"
mousedown
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
mouseup
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
mouseover
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
mouseout
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
mouseleave
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
mouseenter
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
dblclick
"
this
.
_preventContentEvent
true
)
;
target
.
removeEventListener
(
"
keydown
"
this
.
onKey
true
)
;
target
.
removeEventListener
(
"
keyup
"
this
.
_preventContentEvent
true
)
;
this
.
_resetStateAndReleaseTarget
(
)
;
}
_resetStateAndReleaseTarget
(
)
{
if
(
!
this
.
_currentTarget
)
{
return
;
}
try
{
if
(
this
.
_currentTargetHoverState
)
{
InspectorUtils
.
setContentState
(
this
.
_currentTarget
kStateHover
)
;
}
}
catch
(
e
)
{
}
this
.
_currentTarget
=
null
;
this
.
_currentTargetState
=
null
;
}
cancelPick
:
function
(
)
{
this
.
unhighlight
(
)
;
if
(
this
.
_isPicking
)
{
this
.
_unsetPickerEnvironment
(
)
;
this
.
_isPicking
=
false
;
this
.
_currentAccessible
=
null
;
}
}
}
)
;
exports
.
AccessibleWalkerActor
=
AccessibleWalkerActor
;
