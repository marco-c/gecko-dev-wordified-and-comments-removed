"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
"
colorUtils
"
"
devtools
/
shared
/
css
/
color
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
actors
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getBounds
"
"
devtools
/
server
/
actors
/
highlighters
/
utils
/
accessibility
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getCurrentZoom
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
addPseudoClassLock
"
"
devtools
/
server
/
actors
/
highlighters
/
utils
/
markup
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
removePseudoClassLock
"
"
devtools
/
server
/
actors
/
highlighters
/
utils
/
markup
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getContrastRatioScore
"
"
devtools
/
shared
/
accessibility
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getTextProperties
"
"
devtools
/
shared
/
accessibility
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsWorker
"
"
devtools
/
shared
/
worker
/
worker
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorActorUtils
"
"
devtools
/
server
/
actors
/
inspector
/
utils
"
)
;
const
WORKER_URL
=
"
resource
:
/
/
devtools
/
server
/
actors
/
accessibility
/
worker
.
js
"
;
const
HIGHLIGHTED_PSEUDO_CLASS
=
"
:
-
moz
-
devtools
-
highlighted
"
;
const
{
LARGE_TEXT
:
{
BOLD_LARGE_TEXT_MIN_PIXELS
LARGE_TEXT_MIN_PIXELS
}
}
=
require
(
"
devtools
/
shared
/
accessibility
"
)
;
loader
.
lazyGetter
(
this
"
worker
"
(
)
=
>
new
DevToolsWorker
(
WORKER_URL
)
)
;
function
getImageCtx
(
win
bounds
zoom
scale
node
)
{
const
doc
=
win
.
document
;
const
canvas
=
doc
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
const
{
left
top
width
height
}
=
bounds
;
canvas
.
width
=
width
*
zoom
*
scale
;
canvas
.
height
=
height
*
zoom
*
scale
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
{
alpha
:
false
}
)
;
ctx
.
imageSmoothingEnabled
=
false
;
ctx
.
scale
(
scale
scale
)
;
if
(
node
)
{
addPseudoClassLock
(
node
HIGHLIGHTED_PSEUDO_CLASS
)
;
}
ctx
.
drawWindow
(
win
left
*
zoom
top
*
zoom
width
*
zoom
height
*
zoom
"
#
fff
"
ctx
.
DRAWWINDOW_USE_WIDGET_LAYERS
)
;
if
(
node
)
{
removePseudoClassLock
(
node
HIGHLIGHTED_PSEUDO_CLASS
)
;
}
return
ctx
;
}
async
function
getContrastRatioFor
(
node
options
=
{
}
)
{
const
computedStyle
=
CssLogic
.
getComputedStyle
(
node
)
;
const
props
=
computedStyle
?
getTextProperties
(
computedStyle
)
:
null
;
if
(
!
props
)
{
return
{
error
:
true
}
;
}
const
{
color
isLargeText
isBoldText
size
opacity
}
=
props
;
const
bounds
=
getBounds
(
options
.
win
options
.
bounds
)
;
const
zoom
=
1
/
getCurrentZoom
(
options
.
win
)
;
let
scale
=
(
(
isBoldText
?
BOLD_LARGE_TEXT_MIN_PIXELS
:
LARGE_TEXT_MIN_PIXELS
)
/
size
)
*
zoom
;
scale
=
scale
>
1
?
1
:
scale
;
const
textContext
=
getImageCtx
(
options
.
win
bounds
zoom
scale
)
;
const
backgroundContext
=
getImageCtx
(
options
.
win
bounds
zoom
scale
node
)
;
const
{
data
:
dataText
}
=
textContext
.
getImageData
(
0
0
bounds
.
width
*
scale
bounds
.
height
*
scale
)
;
const
{
data
:
dataBackground
}
=
backgroundContext
.
getImageData
(
0
0
bounds
.
width
*
scale
bounds
.
height
*
scale
)
;
const
rgba
=
await
worker
.
performTask
(
"
getBgRGBA
"
{
dataTextBuf
:
dataText
.
buffer
dataBackgroundBuf
:
dataBackground
.
buffer
}
[
dataText
.
buffer
dataBackground
.
buffer
]
)
;
if
(
!
rgba
)
{
const
backgroundColor
=
InspectorActorUtils
.
getClosestBackgroundColor
(
node
)
;
const
backgroundImage
=
InspectorActorUtils
.
getClosestBackgroundImage
(
node
)
;
if
(
backgroundImage
!
=
=
"
none
"
)
{
return
{
error
:
true
}
;
}
let
{
r
g
b
a
}
=
colorUtils
.
colorToRGBA
(
backgroundColor
true
)
;
if
(
opacity
<
1
)
{
a
=
opacity
*
a
;
}
const
value
=
colorUtils
.
calculateContrastRatio
(
[
r
g
b
a
]
color
)
;
return
{
value
color
backgroundColor
:
[
r
g
b
a
]
isLargeText
score
:
getContrastRatioScore
(
value
isLargeText
)
}
;
}
if
(
rgba
.
value
)
{
const
value
=
colorUtils
.
calculateContrastRatio
(
rgba
.
value
color
)
;
return
{
value
color
backgroundColor
:
rgba
.
value
isLargeText
score
:
getContrastRatioScore
(
value
isLargeText
)
}
;
}
let
min
=
colorUtils
.
calculateContrastRatio
(
rgba
.
min
color
)
;
let
max
=
colorUtils
.
calculateContrastRatio
(
rgba
.
max
color
)
;
if
(
min
>
max
)
{
[
min
max
]
=
[
max
min
]
;
[
rgba
.
min
rgba
.
max
]
=
[
rgba
.
max
rgba
.
min
]
;
}
const
score
=
getContrastRatioScore
(
min
isLargeText
)
;
return
{
min
max
color
backgroundColorMin
:
rgba
.
min
backgroundColorMax
:
rgba
.
max
isLargeText
score
scoreMin
:
score
scoreMax
:
getContrastRatioScore
(
max
isLargeText
)
}
;
}
exports
.
getContrastRatioFor
=
getContrastRatioFor
;
