"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
"
colorUtils
"
"
devtools
/
shared
/
css
/
color
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
actors
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getBounds
"
"
devtools
/
server
/
actors
/
highlighters
/
utils
/
accessibility
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getCurrentZoom
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
addPseudoClassLock
"
"
devtools
/
server
/
actors
/
highlighters
/
utils
/
markup
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
removePseudoClassLock
"
"
devtools
/
server
/
actors
/
highlighters
/
utils
/
markup
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsWorker
"
"
devtools
/
shared
/
worker
/
worker
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
accessibility
"
"
devtools
/
shared
/
constants
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorActorUtils
"
"
devtools
/
server
/
actors
/
inspector
/
utils
"
)
;
const
WORKER_URL
=
"
resource
:
/
/
devtools
/
server
/
actors
/
accessibility
/
worker
.
js
"
;
const
HIGHLIGHTED_PSEUDO_CLASS
=
"
:
-
moz
-
devtools
-
highlighted
"
;
const
BOLD_LARGE_TEXT_MIN_PIXELS
=
18
.
66
;
const
LARGE_TEXT_MIN_PIXELS
=
24
;
loader
.
lazyGetter
(
this
"
worker
"
(
)
=
>
new
DevToolsWorker
(
WORKER_URL
)
)
;
function
getTextProperties
(
node
)
{
const
computedStyles
=
CssLogic
.
getComputedStyle
(
node
)
;
if
(
!
computedStyles
)
{
return
null
;
}
const
{
color
"
font
-
size
"
:
fontSize
"
font
-
weight
"
:
fontWeight
}
=
computedStyles
;
const
opacity
=
parseFloat
(
computedStyles
.
opacity
)
;
let
{
r
g
b
a
}
=
colorUtils
.
colorToRGBA
(
color
true
)
;
a
=
opacity
*
a
;
const
textRgbaColor
=
new
colorUtils
.
CssColor
(
rgba
(
{
r
}
{
g
}
{
b
}
{
a
}
)
true
)
;
if
(
textRgbaColor
.
isTransparent
(
)
)
{
return
null
;
}
const
isBoldText
=
parseInt
(
fontWeight
10
)
>
=
600
;
const
size
=
parseFloat
(
fontSize
)
;
const
isLargeText
=
size
>
=
(
isBoldText
?
BOLD_LARGE_TEXT_MIN_PIXELS
:
LARGE_TEXT_MIN_PIXELS
)
;
return
{
color
:
[
r
g
b
a
]
isLargeText
isBoldText
size
opacity
}
;
}
function
getImageCtx
(
win
bounds
zoom
scale
node
)
{
const
doc
=
win
.
document
;
const
canvas
=
doc
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
const
{
left
top
width
height
}
=
bounds
;
canvas
.
width
=
width
*
zoom
*
scale
;
canvas
.
height
=
height
*
zoom
*
scale
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
{
alpha
:
false
}
)
;
ctx
.
imageSmoothingEnabled
=
false
;
ctx
.
scale
(
scale
scale
)
;
if
(
node
)
{
addPseudoClassLock
(
node
HIGHLIGHTED_PSEUDO_CLASS
)
;
}
ctx
.
drawWindow
(
win
left
*
zoom
top
*
zoom
width
*
zoom
height
*
zoom
"
#
fff
"
ctx
.
DRAWWINDOW_USE_WIDGET_LAYERS
)
;
if
(
node
)
{
removePseudoClassLock
(
node
HIGHLIGHTED_PSEUDO_CLASS
)
;
}
return
ctx
;
}
function
getContrastRatioScore
(
ratio
isLargeText
)
{
const
{
SCORES
:
{
FAIL
AA
AAA
}
}
=
accessibility
;
const
levels
=
isLargeText
?
{
AA
:
3
AAA
:
4
.
5
}
:
{
AA
:
4
.
5
AAA
:
7
}
;
let
score
=
FAIL
;
if
(
ratio
>
=
levels
.
AAA
)
{
score
=
AAA
;
}
else
if
(
ratio
>
=
levels
.
AA
)
{
score
=
AA
;
}
return
score
;
}
async
function
getContrastRatioFor
(
node
options
=
{
}
)
{
const
props
=
getTextProperties
(
node
)
;
if
(
!
props
)
{
return
{
error
:
true
}
;
}
const
{
color
isLargeText
isBoldText
size
opacity
}
=
props
;
const
bounds
=
getBounds
(
options
.
win
options
.
bounds
)
;
const
zoom
=
1
/
getCurrentZoom
(
options
.
win
)
;
let
scale
=
(
(
isBoldText
?
BOLD_LARGE_TEXT_MIN_PIXELS
:
LARGE_TEXT_MIN_PIXELS
)
/
size
)
*
zoom
;
scale
=
scale
>
1
?
1
:
scale
;
const
textContext
=
getImageCtx
(
options
.
win
bounds
zoom
scale
)
;
const
backgroundContext
=
getImageCtx
(
options
.
win
bounds
zoom
scale
node
)
;
const
{
data
:
dataText
}
=
textContext
.
getImageData
(
0
0
bounds
.
width
*
scale
bounds
.
height
*
scale
)
;
const
{
data
:
dataBackground
}
=
backgroundContext
.
getImageData
(
0
0
bounds
.
width
*
scale
bounds
.
height
*
scale
)
;
const
rgba
=
await
worker
.
performTask
(
"
getBgRGBA
"
{
dataTextBuf
:
dataText
.
buffer
dataBackgroundBuf
:
dataBackground
.
buffer
}
[
dataText
.
buffer
dataBackground
.
buffer
]
)
;
if
(
!
rgba
)
{
const
backgroundColor
=
InspectorActorUtils
.
getClosestBackgroundColor
(
node
)
;
const
backgroundImage
=
InspectorActorUtils
.
getClosestBackgroundImage
(
node
)
;
if
(
backgroundImage
!
=
=
"
none
"
)
{
return
{
error
:
true
}
;
}
let
{
r
g
b
a
}
=
colorUtils
.
colorToRGBA
(
backgroundColor
true
)
;
if
(
opacity
<
1
)
{
a
=
opacity
*
a
;
}
const
value
=
colorUtils
.
calculateContrastRatio
(
[
r
g
b
a
]
color
)
;
return
{
value
color
backgroundColor
:
[
r
g
b
a
]
isLargeText
score
:
getContrastRatioScore
(
value
isLargeText
)
}
;
}
if
(
rgba
.
value
)
{
const
value
=
colorUtils
.
calculateContrastRatio
(
rgba
.
value
color
)
;
return
{
value
color
backgroundColor
:
rgba
.
value
isLargeText
score
:
getContrastRatioScore
(
value
isLargeText
)
}
;
}
let
min
=
colorUtils
.
calculateContrastRatio
(
rgba
.
min
color
)
;
let
max
=
colorUtils
.
calculateContrastRatio
(
rgba
.
max
color
)
;
if
(
min
>
max
)
{
[
min
max
]
=
[
max
min
]
;
[
rgba
.
min
rgba
.
max
]
=
[
rgba
.
max
rgba
.
min
]
;
}
const
score
=
getContrastRatioScore
(
min
isLargeText
)
;
return
{
min
max
color
backgroundColorMin
:
rgba
.
min
backgroundColorMax
:
rgba
.
max
isLargeText
score
scoreMin
:
score
scoreMax
:
getContrastRatioScore
(
max
isLargeText
)
}
;
}
exports
.
getContrastRatioFor
=
getContrastRatioFor
;
