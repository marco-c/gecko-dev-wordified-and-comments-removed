"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
"
colorUtils
"
"
devtools
/
shared
/
css
/
color
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
actors
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getCurrentZoom
"
"
devtools
/
shared
/
layout
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getContrastRatioAgainstBackground
"
"
devtools
/
shared
/
accessibility
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getTextProperties
"
"
devtools
/
shared
/
accessibility
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsWorker
"
"
devtools
/
shared
/
worker
/
worker
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorActorUtils
"
"
devtools
/
server
/
actors
/
inspector
/
utils
"
)
;
const
WORKER_URL
=
"
resource
:
/
/
devtools
/
server
/
actors
/
accessibility
/
worker
.
js
"
;
const
{
LARGE_TEXT
:
{
BOLD_LARGE_TEXT_MIN_PIXELS
LARGE_TEXT_MIN_PIXELS
}
}
=
require
(
"
devtools
/
shared
/
accessibility
"
)
;
loader
.
lazyGetter
(
this
"
worker
"
(
)
=
>
new
DevToolsWorker
(
WORKER_URL
)
)
;
const
RESET_PROPERTIES
=
{
color
:
"
transparent
"
"
text
-
shadow
"
:
"
none
"
}
;
function
getImageCtx
(
win
bounds
zoom
scale
node
)
{
const
doc
=
win
.
document
;
const
canvas
=
doc
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
const
{
left
top
width
height
}
=
bounds
;
canvas
.
width
=
width
*
zoom
*
scale
;
canvas
.
height
=
height
*
zoom
*
scale
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
{
alpha
:
false
}
)
;
ctx
.
imageSmoothingEnabled
=
false
;
ctx
.
scale
(
scale
scale
)
;
const
stylePropertiesToRestore
=
{
}
;
const
nodeHadStyle
=
node
&
&
node
.
getAttribute
(
"
style
"
)
!
=
=
null
;
if
(
node
&
&
node
.
style
)
{
for
(
const
property
in
RESET_PROPERTIES
)
{
stylePropertiesToRestore
[
property
]
=
{
value
:
node
.
style
.
getPropertyValue
(
property
)
priority
:
node
.
style
.
getPropertyPriority
(
property
)
}
;
node
.
style
.
setProperty
(
property
RESET_PROPERTIES
[
property
]
"
important
"
)
;
}
}
ctx
.
drawWindow
(
win
left
*
zoom
top
*
zoom
width
*
zoom
height
*
zoom
"
#
fff
"
ctx
.
DRAWWINDOW_USE_WIDGET_LAYERS
)
;
if
(
node
)
{
if
(
nodeHadStyle
)
{
for
(
const
property
in
stylePropertiesToRestore
)
{
const
{
value
priority
}
=
stylePropertiesToRestore
[
property
]
;
node
.
style
.
setProperty
(
property
value
priority
)
;
}
}
else
{
node
.
removeAttribute
(
"
style
"
)
;
}
}
return
ctx
;
}
function
getTransformedRGBA
(
rgba
colorMatrix
)
{
const
transformedRGBA
=
[
0
0
0
0
]
;
for
(
let
i
=
0
;
i
<
16
;
i
+
+
)
{
const
row
=
i
%
4
;
const
col
=
Math
.
floor
(
i
/
4
)
;
transformedRGBA
[
row
]
+
=
colorMatrix
[
i
]
*
rgba
[
col
]
;
}
return
transformedRGBA
;
}
function
getBackgroundFor
(
node
{
win
bounds
size
isBoldText
}
)
{
const
zoom
=
1
/
getCurrentZoom
(
win
)
;
let
scale
=
(
(
isBoldText
?
BOLD_LARGE_TEXT_MIN_PIXELS
:
LARGE_TEXT_MIN_PIXELS
)
/
size
)
*
zoom
;
scale
=
scale
>
1
?
1
:
scale
;
const
textContext
=
getImageCtx
(
win
bounds
zoom
scale
)
;
const
backgroundContext
=
getImageCtx
(
win
bounds
zoom
scale
node
)
;
const
{
data
:
dataText
}
=
textContext
.
getImageData
(
0
0
bounds
.
width
*
scale
bounds
.
height
*
scale
)
;
const
{
data
:
dataBackground
}
=
backgroundContext
.
getImageData
(
0
0
bounds
.
width
*
scale
bounds
.
height
*
scale
)
;
return
worker
.
performTask
(
"
getBgRGBA
"
{
dataTextBuf
:
dataText
.
buffer
dataBackgroundBuf
:
dataBackground
.
buffer
}
[
dataText
.
buffer
dataBackground
.
buffer
]
)
;
}
async
function
getContrastRatioFor
(
node
options
=
{
}
)
{
const
computedStyle
=
CssLogic
.
getComputedStyle
(
node
)
;
const
props
=
computedStyle
?
getTextProperties
(
computedStyle
)
:
null
;
if
(
!
props
)
{
return
{
error
:
true
}
;
}
const
{
isLargeText
isBoldText
size
opacity
}
=
props
;
const
{
appliedColorMatrix
}
=
options
;
const
color
=
appliedColorMatrix
?
getTransformedRGBA
(
props
.
color
appliedColorMatrix
)
:
props
.
color
;
let
rgba
=
await
getBackgroundFor
(
node
{
.
.
.
options
isBoldText
size
}
)
;
if
(
!
rgba
)
{
const
backgroundColor
=
InspectorActorUtils
.
getClosestBackgroundColor
(
node
)
;
const
backgroundImage
=
InspectorActorUtils
.
getClosestBackgroundImage
(
node
)
;
if
(
backgroundImage
!
=
=
"
none
"
)
{
return
{
error
:
true
}
;
}
let
{
r
g
b
a
}
=
colorUtils
.
colorToRGBA
(
backgroundColor
true
)
;
if
(
opacity
<
1
)
{
a
=
opacity
*
a
;
}
return
getContrastRatioAgainstBackground
(
{
value
:
appliedColorMatrix
?
getTransformedRGBA
(
[
r
g
b
a
]
appliedColorMatrix
)
:
[
r
g
b
a
]
}
{
color
isLargeText
}
)
;
}
if
(
appliedColorMatrix
)
{
rgba
=
rgba
.
value
?
{
value
:
getTransformedRGBA
(
rgba
.
value
appliedColorMatrix
)
}
:
{
min
:
getTransformedRGBA
(
rgba
.
min
appliedColorMatrix
)
max
:
getTransformedRGBA
(
rgba
.
max
appliedColorMatrix
)
}
;
}
return
getContrastRatioAgainstBackground
(
rgba
{
color
isLargeText
}
)
;
}
exports
.
getContrastRatioFor
=
getContrastRatioFor
;
exports
.
getBackgroundFor
=
getBackgroundFor
;
