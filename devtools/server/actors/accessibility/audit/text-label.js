"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
{
accessibility
:
{
AUDIT_TYPE
:
{
TEXT_LABEL
}
ISSUE_TYPE
SCORES
:
{
BEST_PRACTICES
FAIL
WARNING
}
}
}
=
require
(
"
devtools
/
shared
/
constants
"
)
;
const
{
AREA_NO_NAME_FROM_ALT
DIALOG_NO_NAME
DOCUMENT_NO_TITLE
EMBED_NO_NAME
FIGURE_NO_NAME
FORM_FIELDSET_NO_NAME
FORM_FIELDSET_NO_NAME_FROM_LEGEND
FORM_NO_NAME
FORM_NO_VISIBLE_NAME
FORM_OPTGROUP_NO_NAME_FROM_LABEL
FRAME_NO_NAME
HEADING_NO_CONTENT
HEADING_NO_NAME
IFRAME_NO_NAME_FROM_TITLE
IMAGE_NO_NAME
INTERACTIVE_NO_NAME
MATHML_GLYPH_NO_NAME
TOOLBAR_NO_NAME
}
=
ISSUE_TYPE
[
TEXT_LABEL
]
;
function
isVisible
(
accessible
)
{
const
state
=
{
}
;
accessible
.
getState
(
state
{
}
)
;
return
!
(
state
.
value
&
Ci
.
nsIAccessibleStates
.
STATE_INVISIBLE
)
;
}
function
getLabels
(
accessible
)
{
const
relation
=
accessible
.
getRelationByType
(
Ci
.
nsIAccessibleRelation
.
RELATION_LABELLED_BY
)
;
return
[
.
.
.
relation
.
getTargets
(
)
.
enumerate
(
Ci
.
nsIAccessible
)
]
;
}
function
getAccessibleName
(
accessible
)
{
return
accessible
.
name
&
&
accessible
.
name
.
trim
(
)
;
}
const
mustHaveNonEmptyNameRule
=
function
(
issue
accessible
)
{
const
name
=
getAccessibleName
(
accessible
)
;
return
name
?
null
:
{
score
:
FAIL
issue
}
;
}
;
const
shouldHaveNonEmptyNameRule
=
function
(
issue
accessible
)
{
const
name
=
getAccessibleName
(
accessible
)
;
return
name
?
null
:
{
score
:
BEST_PRACTICES
issue
}
;
}
;
const
interactiveRule
=
mustHaveNonEmptyNameRule
.
bind
(
null
INTERACTIVE_NO_NAME
)
;
const
dialogRule
=
shouldHaveNonEmptyNameRule
.
bind
(
null
DIALOG_NO_NAME
)
;
const
imageRule
=
function
(
accessible
)
{
const
name
=
getAccessibleName
(
accessible
)
;
return
name
!
=
null
?
null
:
{
score
:
FAIL
issue
:
IMAGE_NO_NAME
}
;
}
;
const
formRule
=
function
(
accessible
)
{
const
name
=
getAccessibleName
(
accessible
)
;
if
(
!
name
)
{
return
{
score
:
FAIL
issue
:
FORM_NO_NAME
}
;
}
const
labels
=
getLabels
(
accessible
)
;
const
hasNameFromVisibleLabel
=
labels
.
some
(
label
=
>
isVisible
(
label
)
)
;
return
hasNameFromVisibleLabel
?
null
:
{
score
:
WARNING
issue
:
FORM_NO_VISIBLE_NAME
}
;
}
;
const
formGroupingRule
=
function
(
accessible
)
{
const
name
=
getAccessibleName
(
accessible
)
;
const
{
DOMNode
}
=
accessible
;
switch
(
DOMNode
.
nodeName
)
{
case
"
OPTGROUP
"
:
return
name
&
&
DOMNode
.
label
&
&
DOMNode
.
label
.
trim
(
)
=
=
=
name
?
null
:
{
score
:
FAIL
issue
:
FORM_OPTGROUP_NO_NAME_FROM_LABEL
}
;
case
"
FIELDSET
"
:
if
(
!
name
)
{
return
{
score
:
FAIL
issue
:
FORM_FIELDSET_NO_NAME
}
;
}
const
labels
=
getLabels
(
accessible
)
;
const
hasNameFromLegend
=
labels
.
some
(
label
=
>
label
.
DOMNode
.
nodeName
=
=
=
"
LEGEND
"
&
&
label
.
name
&
&
label
.
name
.
trim
(
)
=
=
=
name
&
&
isVisible
(
label
)
)
;
return
hasNameFromLegend
?
null
:
{
score
:
WARNING
issue
:
FORM_FIELDSET_NO_NAME_FROM_LEGEND
}
;
default
:
return
null
;
}
}
;
const
textContainerRule
=
function
(
accessible
)
{
const
{
DOMNode
}
=
accessible
;
switch
(
DOMNode
.
nodeName
)
{
case
"
DIALOG
"
:
return
dialogRule
(
accessible
)
;
case
"
METER
"
:
return
formRule
(
accessible
)
;
default
:
return
null
;
}
}
;
const
internalFrameRule
=
function
(
accessible
)
{
const
{
DOMNode
}
=
accessible
;
switch
(
DOMNode
.
nodeName
)
{
case
"
FRAME
"
:
return
mustHaveNonEmptyNameRule
(
FRAME_NO_NAME
accessible
)
;
case
"
IFRAME
"
:
const
name
=
getAccessibleName
(
accessible
)
;
const
title
=
DOMNode
.
title
&
&
DOMNode
.
title
.
trim
(
)
;
return
title
&
&
title
=
=
=
name
?
null
:
{
score
:
FAIL
issue
:
IFRAME_NO_NAME_FROM_TITLE
}
;
case
"
OBJECT
"
:
const
type
=
DOMNode
.
getAttribute
(
"
type
"
)
;
if
(
!
type
|
|
!
type
.
startsWith
(
"
image
/
"
)
)
{
return
null
;
}
return
imageRule
(
accessible
)
;
case
"
EMBED
"
:
return
mustHaveNonEmptyNameRule
(
EMBED_NO_NAME
accessible
)
;
default
:
return
null
;
}
}
;
const
documentRule
=
function
(
accessible
)
{
const
title
=
accessible
.
DOMNode
.
title
&
&
accessible
.
DOMNode
.
title
.
trim
(
)
;
return
title
?
null
:
{
score
:
FAIL
issue
:
DOCUMENT_NO_TITLE
}
;
}
;
const
headingRule
=
function
(
accessible
)
{
const
name
=
getAccessibleName
(
accessible
)
;
if
(
!
name
)
{
return
{
score
:
FAIL
issue
:
HEADING_NO_NAME
}
;
}
const
content
=
accessible
.
DOMNode
.
textContent
&
&
accessible
.
DOMNode
.
textContent
.
trim
(
)
;
return
content
?
null
:
{
score
:
FAIL
issue
:
HEADING_NO_CONTENT
}
;
}
;
const
toolbarRule
=
function
(
accessible
)
{
const
toolbars
=
accessible
.
DOMNode
.
ownerDocument
.
querySelectorAll
(
[
role
=
"
toolbar
"
]
)
;
return
toolbars
.
length
>
1
?
mustHaveNonEmptyNameRule
(
TOOLBAR_NO_NAME
accessible
)
:
null
;
}
;
const
linkRule
=
function
(
accessible
)
{
const
{
DOMNode
}
=
accessible
;
if
(
DOMNode
.
nodeName
=
=
=
"
AREA
"
&
&
DOMNode
.
hasAttribute
(
"
href
"
)
)
{
const
alt
=
DOMNode
.
getAttribute
(
"
alt
"
)
;
const
name
=
getAccessibleName
(
accessible
)
;
return
alt
&
&
alt
.
trim
(
)
=
=
=
name
?
null
:
{
score
:
FAIL
issue
:
AREA_NO_NAME_FROM_ALT
}
;
}
return
interactiveRule
(
accessible
)
;
}
;
const
mathmlGlyphRule
=
function
(
accessible
)
{
const
name
=
getAccessibleName
(
accessible
)
;
if
(
name
)
{
return
null
;
}
const
{
DOMNode
}
=
accessible
;
const
alt
=
DOMNode
.
getAttribute
(
"
alt
"
)
;
return
alt
&
&
alt
.
trim
(
)
?
null
:
{
score
:
FAIL
issue
:
MATHML_GLYPH_NO_NAME
}
;
}
;
const
RULES
=
{
[
Ci
.
nsIAccessibleRole
.
ROLE_BUTTONMENU
]
:
interactiveRule
[
Ci
.
nsIAccessibleRole
.
ROLE_CANVAS
]
:
imageRule
[
Ci
.
nsIAccessibleRole
.
ROLE_CHECKBUTTON
]
:
formRule
[
Ci
.
nsIAccessibleRole
.
ROLE_CHECK_MENU_ITEM
]
:
interactiveRule
[
Ci
.
nsIAccessibleRole
.
ROLE_CHECK_RICH_OPTION
]
:
formRule
[
Ci
.
nsIAccessibleRole
.
ROLE_COLUMNHEADER
]
:
interactiveRule
[
Ci
.
nsIAccessibleRole
.
ROLE_COMBOBOX
]
:
formRule
[
Ci
.
nsIAccessibleRole
.
ROLE_COMBOBOX_OPTION
]
:
interactiveRule
[
Ci
.
nsIAccessibleRole
.
ROLE_DIAGRAM
]
:
imageRule
[
Ci
.
nsIAccessibleRole
.
ROLE_DIALOG
]
:
dialogRule
[
Ci
.
nsIAccessibleRole
.
ROLE_DOCUMENT
]
:
documentRule
[
Ci
.
nsIAccessibleRole
.
ROLE_EDITCOMBOBOX
]
:
formRule
[
Ci
.
nsIAccessibleRole
.
ROLE_ENTRY
]
:
formRule
[
Ci
.
nsIAccessibleRole
.
ROLE_FIGURE
]
:
shouldHaveNonEmptyNameRule
.
bind
(
null
FIGURE_NO_NAME
)
[
Ci
.
nsIAccessibleRole
.
ROLE_GRAPHIC
]
:
imageRule
[
Ci
.
nsIAccessibleRole
.
ROLE_GROUPING
]
:
formGroupingRule
[
Ci
.
nsIAccessibleRole
.
ROLE_HEADING
]
:
headingRule
[
Ci
.
nsIAccessibleRole
.
ROLE_IMAGE_MAP
]
:
imageRule
[
Ci
.
nsIAccessibleRole
.
ROLE_INTERNAL_FRAME
]
:
internalFrameRule
[
Ci
.
nsIAccessibleRole
.
ROLE_LINK
]
:
linkRule
[
Ci
.
nsIAccessibleRole
.
ROLE_LISTBOX
]
:
formRule
[
Ci
.
nsIAccessibleRole
.
ROLE_MATHML_GLYPH
]
:
mathmlGlyphRule
[
Ci
.
nsIAccessibleRole
.
ROLE_MENUITEM
]
:
interactiveRule
[
Ci
.
nsIAccessibleRole
.
ROLE_OPTION
]
:
interactiveRule
[
Ci
.
nsIAccessibleRole
.
ROLE_OUTLINEITEM
]
:
interactiveRule
[
Ci
.
nsIAccessibleRole
.
ROLE_PAGETAB
]
:
interactiveRule
[
Ci
.
nsIAccessibleRole
.
ROLE_PASSWORD_TEXT
]
:
formRule
[
Ci
.
nsIAccessibleRole
.
ROLE_PROGRESSBAR
]
:
formRule
[
Ci
.
nsIAccessibleRole
.
ROLE_PUSHBUTTON
]
:
interactiveRule
[
Ci
.
nsIAccessibleRole
.
ROLE_RADIOBUTTON
]
:
formRule
[
Ci
.
nsIAccessibleRole
.
ROLE_RADIO_MENU_ITEM
]
:
interactiveRule
[
Ci
.
nsIAccessibleRole
.
ROLE_ROWHEADER
]
:
interactiveRule
[
Ci
.
nsIAccessibleRole
.
ROLE_SLIDER
]
:
formRule
[
Ci
.
nsIAccessibleRole
.
ROLE_SPINBUTTON
]
:
formRule
[
Ci
.
nsIAccessibleRole
.
ROLE_SWITCH
]
:
formRule
[
Ci
.
nsIAccessibleRole
.
ROLE_TEXT_CONTAINER
]
:
textContainerRule
[
Ci
.
nsIAccessibleRole
.
ROLE_TOGGLE_BUTTON
]
:
interactiveRule
[
Ci
.
nsIAccessibleRole
.
ROLE_TOOLBAR
]
:
toolbarRule
}
;
function
auditTextLabel
(
accessible
)
{
const
rule
=
RULES
[
accessible
.
role
]
;
return
rule
?
rule
(
accessible
)
:
null
;
}
module
.
exports
.
auditTextLabel
=
auditTextLabel
;
