"
use
strict
"
;
function
ArrayBufferActor
(
buffer
)
{
this
.
buffer
=
buffer
;
this
.
bufferLength
=
buffer
.
byteLength
;
}
ArrayBufferActor
.
prototype
=
{
actorPrefix
:
"
arrayBuffer
"
rawValue
:
function
(
)
{
return
this
.
buffer
;
}
destroy
:
function
(
)
{
}
grip
(
)
{
return
{
"
type
"
:
"
arrayBuffer
"
"
length
"
:
this
.
bufferLength
"
actor
"
:
this
.
actorID
}
;
}
onSlice
(
{
start
count
}
)
{
const
slice
=
new
Uint8Array
(
this
.
buffer
start
count
)
;
const
parts
=
[
]
;
let
offset
=
0
;
const
PortionSize
=
0x6000
;
while
(
offset
+
PortionSize
<
count
)
{
parts
.
push
(
btoa
(
String
.
fromCharCode
.
apply
(
null
slice
.
subarray
(
offset
offset
+
PortionSize
)
)
)
)
;
offset
+
=
PortionSize
;
}
parts
.
push
(
btoa
(
String
.
fromCharCode
.
apply
(
null
slice
.
subarray
(
offset
count
)
)
)
)
;
return
{
"
from
"
:
this
.
actorID
"
encoded
"
:
parts
.
join
(
"
"
)
}
;
}
}
;
ArrayBufferActor
.
prototype
.
requestTypes
=
{
"
slice
"
:
ArrayBufferActor
.
prototype
.
onSlice
}
;
function
arrayBufferGrip
(
buffer
pool
)
{
if
(
!
pool
.
arrayBufferActors
)
{
pool
.
arrayBufferActors
=
new
WeakMap
(
)
;
}
if
(
pool
.
arrayBufferActors
.
has
(
buffer
)
)
{
return
pool
.
arrayBufferActors
.
get
(
buffer
)
.
grip
(
)
;
}
const
actor
=
new
ArrayBufferActor
(
buffer
)
;
pool
.
addActor
(
actor
)
;
pool
.
arrayBufferActors
.
set
(
buffer
actor
)
;
return
actor
.
grip
(
)
;
}
module
.
exports
=
{
ArrayBufferActor
arrayBufferGrip
}
;
