"
use
strict
"
;
const
{
ActorClassWithSpec
Actor
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
targetConfigurationSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
target
-
configuration
"
)
;
const
{
WatchedDataHelpers
}
=
require
(
"
devtools
/
server
/
actors
/
watcher
/
WatchedDataHelpers
.
jsm
"
)
;
const
{
SUPPORTED_DATA
}
=
WatchedDataHelpers
;
const
{
TARGET_CONFIGURATION
}
=
SUPPORTED_DATA
;
const
SUPPORTED_OPTIONS
=
{
cacheDisabled
:
true
colorSchemeSimulation
:
true
javascriptEnabled
:
true
paintFlashing
:
true
printSimulationEnabled
:
true
restoreFocus
:
true
serviceWorkersTestingEnabled
:
true
}
;
const
TargetConfigurationActor
=
ActorClassWithSpec
(
targetConfigurationSpec
{
initialize
(
watcherActor
)
{
this
.
watcherActor
=
watcherActor
;
Actor
.
prototype
.
initialize
.
call
(
this
this
.
watcherActor
.
conn
)
;
}
form
(
)
{
return
{
actor
:
this
.
actorID
configuration
:
this
.
_getConfiguration
(
)
traits
:
{
supportedOptions
:
SUPPORTED_OPTIONS
}
}
;
}
_getConfiguration
(
)
{
const
targetConfigurationData
=
this
.
watcherActor
.
getWatchedData
(
TARGET_CONFIGURATION
)
;
if
(
!
targetConfigurationData
)
{
return
{
}
;
}
const
cfgMap
=
{
}
;
for
(
const
{
key
value
}
of
targetConfigurationData
)
{
cfgMap
[
key
]
=
value
;
}
return
cfgMap
;
}
async
updateConfiguration
(
configuration
)
{
const
cfgArray
=
Object
.
keys
(
configuration
)
.
filter
(
key
=
>
{
if
(
!
SUPPORTED_OPTIONS
[
key
]
)
{
console
.
warn
(
Unsupported
option
for
TargetConfiguration
:
{
key
}
)
;
return
false
;
}
return
true
;
}
)
.
map
(
key
=
>
(
{
key
value
:
configuration
[
key
]
}
)
)
;
await
this
.
watcherActor
.
addDataEntry
(
TARGET_CONFIGURATION
cfgArray
)
;
return
this
.
_getConfiguration
(
)
;
}
}
)
;
exports
.
TargetConfigurationActor
=
TargetConfigurationActor
;
