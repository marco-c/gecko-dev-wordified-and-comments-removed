"
use
strict
"
;
const
_SUPPORT_STATE_BROWSER_NOT_FOUND
=
"
BROWSER_NOT_FOUND
"
;
const
_SUPPORT_STATE_SUPPORTED
=
"
SUPPORTED
"
;
const
_SUPPORT_STATE_UNSUPPORTED
=
"
UNSUPPORTED
"
;
const
_SUPPORT_STATE_UNSUPPORTED_PREFIX_NEEDED
=
"
UNSUPPORTED_PREFIX_NEEDED
"
;
loader
.
lazyRequireGetter
(
this
"
COMPATIBILITY_ISSUE_TYPE
"
"
resource
:
/
/
devtools
/
shared
/
constants
.
js
"
true
)
;
const
PREFIX_REGEX
=
/
^
-
\
w
+
-
/
;
class
MDNCompatibility
{
constructor
(
cssPropertiesCompatData
)
{
this
.
_cssPropertiesCompatData
=
cssPropertiesCompatData
;
}
getCSSDeclarationBlockIssues
(
declarations
browsers
)
{
const
summaries
=
[
]
;
for
(
const
{
name
:
property
}
of
declarations
)
{
if
(
property
.
startsWith
(
"
-
-
"
)
)
{
continue
;
}
summaries
.
push
(
this
.
_getCSSPropertyCompatSummary
(
browsers
property
)
)
;
}
const
{
aliasSummaries
normalSummaries
}
=
this
.
_classifyCSSCompatSummaries
(
summaries
browsers
)
;
return
this
.
_toCSSIssues
(
normalSummaries
.
concat
(
aliasSummaries
)
)
;
}
_classifyCSSCompatSummaries
(
summaries
browsers
)
{
const
aliasSummariesMap
=
new
Map
(
)
;
const
normalSummaries
=
summaries
.
filter
(
s
=
>
{
const
{
database
invalid
terms
unsupportedBrowsers
prefixNeededBrowsers
}
=
s
;
if
(
invalid
)
{
return
true
;
}
const
alias
=
this
.
_getAlias
(
database
terms
)
;
if
(
!
alias
)
{
return
true
;
}
if
(
!
aliasSummariesMap
.
has
(
alias
)
)
{
aliasSummariesMap
.
set
(
alias
Object
.
assign
(
s
{
property
:
alias
aliases
:
[
]
unsupportedBrowsers
:
browsers
prefixNeededBrowsers
:
browsers
}
)
)
;
}
const
terminal
=
terms
.
pop
(
)
;
const
aliasSummary
=
aliasSummariesMap
.
get
(
alias
)
;
if
(
!
aliasSummary
.
aliases
.
includes
(
terminal
)
)
{
aliasSummary
.
aliases
.
push
(
terminal
)
;
}
aliasSummary
.
unsupportedBrowsers
=
aliasSummary
.
unsupportedBrowsers
.
filter
(
b
=
>
unsupportedBrowsers
.
includes
(
b
)
)
;
aliasSummary
.
prefixNeededBrowsers
=
aliasSummary
.
prefixNeededBrowsers
.
filter
(
b
=
>
prefixNeededBrowsers
.
includes
(
b
)
)
;
return
false
;
}
)
;
const
aliasSummaries
=
[
.
.
.
aliasSummariesMap
.
values
(
)
]
.
map
(
s
=
>
{
s
.
prefixNeeded
=
s
.
prefixNeededBrowsers
.
length
!
=
=
0
;
return
s
;
}
)
;
return
{
aliasSummaries
normalSummaries
}
;
}
_getAlias
(
compatNode
terms
)
{
const
targetNode
=
this
.
_getCompatNode
(
compatNode
terms
)
;
return
targetNode
?
targetNode
.
_aliasOf
:
null
;
}
_getChildCompatNode
(
compatNode
term
)
{
term
=
term
.
toLowerCase
(
)
;
let
child
=
null
;
for
(
const
field
in
compatNode
)
{
if
(
field
.
toLowerCase
(
)
=
=
=
term
)
{
child
=
compatNode
[
field
]
;
break
;
}
}
if
(
!
child
)
{
return
null
;
}
if
(
child
.
_aliasOf
)
{
child
=
compatNode
[
child
.
_aliasOf
]
;
}
return
child
;
}
_getCompatNode
(
compatNode
terms
)
{
for
(
const
term
of
terms
)
{
compatNode
=
this
.
_getChildCompatNode
(
compatNode
term
)
;
if
(
!
compatNode
)
{
return
null
;
}
}
return
compatNode
;
}
_getCompatTable
(
compatNode
terms
)
{
let
targetNode
=
this
.
_getCompatNode
(
compatNode
terms
)
;
if
(
!
targetNode
)
{
return
null
;
}
if
(
!
targetNode
.
__compat
)
{
for
(
const
field
in
targetNode
)
{
if
(
field
.
endsWith
(
"
_context
"
)
)
{
targetNode
=
targetNode
[
field
]
;
break
;
}
}
}
return
targetNode
.
__compat
;
}
_getCompatSummary
(
browsers
database
terms
)
{
const
compatTable
=
this
.
_getCompatTable
(
database
terms
)
;
if
(
!
compatTable
)
{
return
{
invalid
:
true
unsupportedBrowsers
:
[
]
}
;
}
const
unsupportedBrowsers
=
[
]
;
const
prefixNeededBrowsers
=
[
]
;
for
(
const
browser
of
browsers
)
{
const
state
=
this
.
_getSupportState
(
compatTable
browser
database
terms
)
;
switch
(
state
)
{
case
_SUPPORT_STATE_UNSUPPORTED_PREFIX_NEEDED
:
{
prefixNeededBrowsers
.
push
(
browser
)
;
unsupportedBrowsers
.
push
(
browser
)
;
break
;
}
case
_SUPPORT_STATE_UNSUPPORTED
:
{
unsupportedBrowsers
.
push
(
browser
)
;
break
;
}
}
}
const
{
deprecated
experimental
}
=
compatTable
.
status
|
|
{
}
;
return
{
database
terms
url
:
compatTable
.
mdn_url
specUrl
:
compatTable
.
spec_url
deprecated
experimental
unsupportedBrowsers
prefixNeededBrowsers
}
;
}
_getCSSPropertyCompatSummary
(
browsers
property
)
{
const
summary
=
this
.
_getCompatSummary
(
browsers
this
.
_cssPropertiesCompatData
[
property
]
)
;
return
Object
.
assign
(
summary
{
property
}
)
;
}
_getSupportState
(
compatTable
browser
compatNode
terms
)
{
const
supportList
=
compatTable
.
support
[
browser
.
id
]
;
if
(
!
supportList
)
{
return
_SUPPORT_STATE_BROWSER_NOT_FOUND
;
}
const
version
=
parseFloat
(
browser
.
version
)
;
const
terminal
=
terms
.
at
(
-
1
)
;
const
prefix
=
terminal
.
match
(
PREFIX_REGEX
)
?
.
[
0
]
;
let
prefixNeeded
=
false
;
for
(
const
support
of
supportList
)
{
const
{
alternative_name
:
alternativeName
added
removed
}
=
support
;
if
(
(
added
=
=
=
true
|
|
added
=
=
=
null
|
|
added
=
=
=
undefined
|
|
added
<
=
version
)
&
&
added
!
=
=
false
&
&
(
removed
=
=
=
false
|
|
removed
=
=
=
null
|
|
removed
=
=
=
undefined
|
|
version
<
=
removed
)
)
{
if
(
alternativeName
)
{
if
(
alternativeName
=
=
=
terminal
)
{
return
_SUPPORT_STATE_SUPPORTED
;
}
}
else
if
(
support
.
prefix
=
=
=
prefix
|
|
(
prefix
&
&
!
this
.
_getAlias
(
compatNode
terms
)
)
)
{
return
_SUPPORT_STATE_SUPPORTED
;
}
prefixNeeded
=
true
;
}
}
return
prefixNeeded
?
_SUPPORT_STATE_UNSUPPORTED_PREFIX_NEEDED
:
_SUPPORT_STATE_UNSUPPORTED
;
}
_hasIssue
(
{
unsupportedBrowsers
deprecated
experimental
invalid
}
)
{
return
(
!
invalid
&
&
(
unsupportedBrowsers
.
length
|
|
deprecated
|
|
experimental
)
)
;
}
_toIssue
(
summary
type
)
{
const
issue
=
Object
.
assign
(
{
}
summary
{
type
}
)
;
delete
issue
.
database
;
delete
issue
.
terms
;
delete
issue
.
prefixNeededBrowsers
;
return
issue
;
}
_toCSSIssues
(
summaries
)
{
const
issues
=
[
]
;
for
(
const
summary
of
summaries
)
{
if
(
!
this
.
_hasIssue
(
summary
)
)
{
continue
;
}
const
type
=
summary
.
aliases
?
COMPATIBILITY_ISSUE_TYPE
.
CSS_PROPERTY_ALIASES
:
COMPATIBILITY_ISSUE_TYPE
.
CSS_PROPERTY
;
issues
.
push
(
this
.
_toIssue
(
summary
type
)
)
;
}
return
issues
;
}
}
module
.
exports
=
MDNCompatibility
;
