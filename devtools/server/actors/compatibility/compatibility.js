"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
compatibilitySpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
compatibility
.
js
"
)
;
loader
.
lazyGetter
(
this
"
mdnCompatibility
"
(
)
=
>
{
const
MDNCompatibility
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
compatibility
/
lib
/
MDNCompatibility
.
js
"
)
;
const
cssPropertiesCompatData
=
require
(
"
resource
:
/
/
devtools
/
shared
/
compatibility
/
dataset
/
css
-
properties
.
json
"
)
;
return
new
MDNCompatibility
(
cssPropertiesCompatData
)
;
}
)
;
class
CompatibilityActor
extends
Actor
{
constructor
(
inspector
)
{
super
(
inspector
.
conn
compatibilitySpec
)
;
this
.
inspector
=
inspector
;
}
destroy
(
)
{
super
.
destroy
(
)
;
this
.
inspector
=
null
;
}
form
(
)
{
return
{
actor
:
this
.
actorID
}
;
}
getTraits
(
)
{
return
{
traits
:
{
}
}
;
}
getCSSDeclarationBlockIssues
(
domRulesDeclarations
targetBrowsers
)
{
return
domRulesDeclarations
.
map
(
declarationBlock
=
>
mdnCompatibility
.
getCSSDeclarationBlockIssues
(
declarationBlock
targetBrowsers
)
)
;
}
async
getNodeCssIssues
(
node
targetBrowsers
)
{
const
pageStyle
=
await
this
.
inspector
.
getPageStyle
(
)
;
const
styles
=
await
pageStyle
.
getApplied
(
node
{
skipPseudo
:
false
}
)
;
const
declarations
=
[
]
;
const
propertyNames
=
new
Set
(
)
;
for
(
const
{
rule
}
of
styles
.
entries
)
{
for
(
const
declaration
of
rule
.
parseRuleDeclarations
(
{
parseComments
:
false
}
)
)
{
if
(
propertyNames
.
has
(
declaration
.
name
)
)
{
continue
;
}
propertyNames
.
add
(
declaration
.
name
)
;
declarations
.
push
(
declaration
)
;
}
}
return
mdnCompatibility
.
getCSSDeclarationBlockIssues
(
declarations
targetBrowsers
)
;
}
}
exports
.
CompatibilityActor
=
CompatibilityActor
;
