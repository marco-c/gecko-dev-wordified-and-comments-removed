"
use
strict
"
;
var
{
Ci
Cu
Cr
}
=
require
(
"
chrome
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
var
promise
=
require
(
"
promise
"
)
;
var
{
ActorPool
createExtraActors
appendExtraActors
GeneratedLocation
}
=
require
(
"
devtools
/
server
/
actors
/
common
"
)
;
var
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
{
assert
}
=
DevToolsUtils
;
var
{
TabSources
}
=
require
(
"
.
/
utils
/
TabSources
"
)
;
var
makeDebugger
=
require
(
"
.
/
utils
/
make
-
debugger
"
)
;
loader
.
lazyRequireGetter
(
this
"
ThreadActor
"
"
devtools
/
server
/
actors
/
script
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
unwrapDebuggerObjectGlobal
"
"
devtools
/
server
/
actors
/
script
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WorkerActorList
"
"
devtools
/
server
/
actors
/
worker
-
list
"
true
)
;
loader
.
lazyImporter
(
this
"
ExtensionContent
"
"
resource
:
/
/
gre
/
modules
/
ExtensionContent
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
events
"
"
sdk
/
event
/
core
"
)
;
loader
.
lazyRequireGetter
(
this
"
StyleSheetActor
"
"
devtools
/
server
/
actors
/
stylesheets
"
true
)
;
function
getWindowID
(
window
)
{
return
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
}
function
getDocShellChromeEventHandler
(
docShell
)
{
let
handler
=
docShell
.
chromeEventHandler
;
if
(
!
handler
)
{
try
{
handler
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
catch
(
e
)
{
}
}
return
handler
;
}
function
getChildDocShells
(
parentDocShell
)
{
let
docShellsEnum
=
parentDocShell
.
getDocShellEnumerator
(
Ci
.
nsIDocShellTreeItem
.
typeAll
Ci
.
nsIDocShell
.
ENUMERATE_FORWARDS
)
;
let
docShells
=
[
]
;
while
(
docShellsEnum
.
hasMoreElements
(
)
)
{
let
docShell
=
docShellsEnum
.
getNext
(
)
;
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
docShells
.
push
(
docShell
)
;
}
return
docShells
;
}
exports
.
getChildDocShells
=
getChildDocShells
;
function
getInnerId
(
window
)
{
return
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
}
function
TabActor
(
connection
)
{
this
.
conn
=
connection
;
this
.
_tabActorPool
=
null
;
this
.
_extraActors
=
{
}
;
this
.
_exited
=
false
;
this
.
_sources
=
null
;
this
.
_styleSheetActors
=
new
Map
(
)
;
this
.
_shouldAddNewGlobalAsDebuggee
=
this
.
_shouldAddNewGlobalAsDebuggee
.
bind
(
this
)
;
this
.
makeDebugger
=
makeDebugger
.
bind
(
null
{
findDebuggees
:
(
)
=
>
{
return
this
.
windows
.
concat
(
this
.
webextensionsContentScriptGlobals
)
;
}
shouldAddNewGlobalAsDebuggee
:
this
.
_shouldAddNewGlobalAsDebuggee
}
)
;
this
.
listenForNewDocShells
=
false
;
this
.
traits
=
{
reconfigure
:
true
frames
:
true
noTabReconfigureOnClose
:
true
}
;
this
.
_workerActorList
=
null
;
this
.
_workerActorPool
=
null
;
this
.
_onWorkerActorListChanged
=
this
.
_onWorkerActorListChanged
.
bind
(
this
)
;
}
TabActor
.
prototype
=
{
traits
:
null
consoleAPIListenerOptions
:
{
}
_allowSource
(
)
{
return
true
;
}
get
exited
(
)
{
return
this
.
_exited
;
}
get
attached
(
)
{
return
!
!
this
.
_attached
;
}
_tabPool
:
null
get
tabActorPool
(
)
{
return
this
.
_tabPool
;
}
_contextPool
:
null
get
contextActorPool
(
)
{
return
this
.
_contextPool
;
}
actorPrefix
:
"
tab
"
get
chromeEventHandler
(
)
{
return
getDocShellChromeEventHandler
(
this
.
docShell
)
;
}
get
messageManager
(
)
{
try
{
return
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIContentFrameMessageManager
)
;
}
catch
(
e
)
{
return
null
;
}
}
get
docShell
(
)
{
throw
new
Error
(
"
The
docShell
getter
should
be
implemented
by
a
subclass
of
TabActor
"
)
;
}
get
docShells
(
)
{
return
getChildDocShells
(
this
.
docShell
)
;
}
get
window
(
)
{
if
(
this
.
docShell
)
{
return
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
return
null
;
}
get
outerWindowID
(
)
{
if
(
this
.
window
)
{
return
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
}
return
null
;
}
get
webextensionsContentScriptGlobals
(
)
{
if
(
this
.
window
)
{
return
ExtensionContent
.
getContentScriptGlobalsForWindow
(
this
.
window
)
;
}
return
[
]
;
}
get
windows
(
)
{
return
this
.
docShells
.
map
(
docShell
=
>
{
return
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
)
;
}
get
originalDocShell
(
)
{
if
(
!
this
.
_originalWindow
)
{
return
this
.
docShell
;
}
return
this
.
_originalWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
}
get
originalWindow
(
)
{
return
this
.
_originalWindow
|
|
this
.
window
;
}
get
webProgress
(
)
{
return
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
}
get
webNavigation
(
)
{
return
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
;
}
get
contentDocument
(
)
{
return
this
.
webNavigation
.
document
;
}
get
title
(
)
{
return
this
.
contentDocument
.
contentTitle
;
}
get
url
(
)
{
if
(
this
.
webNavigation
.
currentURI
)
{
return
this
.
webNavigation
.
currentURI
.
spec
;
}
return
null
;
}
get
sources
(
)
{
if
(
!
this
.
_sources
)
{
this
.
_sources
=
new
TabSources
(
this
.
threadActor
this
.
_allowSource
)
;
}
return
this
.
_sources
;
}
update
(
)
{
return
promise
.
resolve
(
this
)
;
}
form
(
)
{
assert
(
!
this
.
exited
"
form
(
)
shouldn
'
t
be
called
on
exited
browser
actor
.
"
)
;
assert
(
this
.
actorID
"
tab
should
have
an
actorID
.
"
)
;
let
response
=
{
actor
:
this
.
actorID
}
;
if
(
this
.
docShell
&
&
!
this
.
docShell
.
isBeingDestroyed
(
)
)
{
response
.
title
=
this
.
title
;
response
.
url
=
this
.
url
;
response
.
outerWindowID
=
this
.
outerWindowID
;
}
if
(
!
this
.
_tabActorPool
)
{
this
.
_tabActorPool
=
new
ActorPool
(
this
.
conn
)
;
this
.
conn
.
addActorPool
(
this
.
_tabActorPool
)
;
}
this
.
_createExtraActors
(
DebuggerServer
.
tabActorFactories
this
.
_tabActorPool
)
;
this
.
_appendExtraActors
(
response
)
;
return
response
;
}
destroy
(
)
{
this
.
exit
(
)
;
}
exit
(
)
{
if
(
this
.
exited
)
{
return
;
}
if
(
this
.
_attached
)
{
this
.
threadActor
.
_tabClosed
=
true
;
}
this
.
_detach
(
)
;
Object
.
defineProperty
(
this
"
docShell
"
{
value
:
null
configurable
:
true
}
)
;
this
.
_extraActors
=
null
;
this
.
_exited
=
true
;
}
_shouldAddNewGlobalAsDebuggee
(
wrappedGlobal
)
{
if
(
wrappedGlobal
.
hostAnnotations
&
&
wrappedGlobal
.
hostAnnotations
.
type
=
=
"
document
"
&
&
wrappedGlobal
.
hostAnnotations
.
element
=
=
=
this
.
window
)
{
return
true
;
}
let
global
=
unwrapDebuggerObjectGlobal
(
wrappedGlobal
)
;
if
(
!
global
)
{
return
false
;
}
let
metadata
=
{
}
;
let
id
=
"
"
;
try
{
id
=
getInnerId
(
this
.
window
)
;
metadata
=
Cu
.
getSandboxMetadata
(
global
)
;
}
catch
(
e
)
{
}
if
(
metadata
&
&
metadata
[
"
inner
-
window
-
id
"
]
&
&
metadata
[
"
inner
-
window
-
id
"
]
=
=
id
)
{
return
true
;
}
return
false
;
}
_createExtraActors
:
createExtraActors
_appendExtraActors
:
appendExtraActors
_attach
(
)
{
if
(
this
.
_attached
)
{
return
;
}
assert
(
!
this
.
_tabPool
"
Shouldn
'
t
have
a
tab
pool
if
we
weren
'
t
attached
.
"
)
;
this
.
_tabPool
=
new
ActorPool
(
this
.
conn
)
;
this
.
conn
.
addActorPool
(
this
.
_tabPool
)
;
this
.
_pushContext
(
)
;
if
(
this
.
window
)
{
this
.
_progressListener
=
new
DebuggerProgressListener
(
this
)
;
this
.
_originalWindow
=
this
.
window
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
this
.
_watchDocshells
(
)
)
;
}
this
.
_attached
=
true
;
}
_watchDocshells
(
)
{
if
(
this
.
listenForNewDocShells
)
{
Services
.
obs
.
addObserver
(
this
"
webnavigation
-
create
"
false
)
;
}
Services
.
obs
.
addObserver
(
this
"
webnavigation
-
destroy
"
false
)
;
this
.
_progressListener
.
watch
(
this
.
docShell
)
;
this
.
_updateChildDocShells
(
)
;
}
onSwitchToFrame
(
request
)
{
let
windowId
=
request
.
windowId
;
let
win
;
try
{
win
=
Services
.
wm
.
getOuterWindowWithId
(
windowId
)
;
}
catch
(
e
)
{
}
if
(
!
win
)
{
return
{
error
:
"
noWindow
"
message
:
"
The
related
docshell
is
destroyed
or
not
found
"
}
;
}
else
if
(
win
=
=
this
.
window
)
{
return
{
}
;
}
DevToolsUtils
.
executeSoon
(
(
)
=
>
this
.
_changeTopLevelDocument
(
win
)
)
;
return
{
}
;
}
onListFrames
(
request
)
{
let
windows
=
this
.
_docShellsToWindows
(
this
.
docShells
)
;
return
{
frames
:
windows
}
;
}
onListWorkers
(
request
)
{
if
(
!
this
.
attached
)
{
return
{
error
:
"
wrongState
"
}
;
}
if
(
this
.
_workerActorList
=
=
=
null
)
{
this
.
_workerActorList
=
new
WorkerActorList
(
this
.
conn
{
type
:
Ci
.
nsIWorkerDebugger
.
TYPE_DEDICATED
window
:
this
.
window
}
)
;
}
return
this
.
_workerActorList
.
getList
(
)
.
then
(
(
actors
)
=
>
{
let
pool
=
new
ActorPool
(
this
.
conn
)
;
for
(
let
actor
of
actors
)
{
pool
.
addActor
(
actor
)
;
}
this
.
conn
.
removeActorPool
(
this
.
_workerActorPool
)
;
this
.
_workerActorPool
=
pool
;
this
.
conn
.
addActorPool
(
this
.
_workerActorPool
)
;
this
.
_workerActorList
.
onListChanged
=
this
.
_onWorkerActorListChanged
;
return
{
"
from
"
:
this
.
actorID
"
workers
"
:
actors
.
map
(
(
actor
)
=
>
actor
.
form
(
)
)
}
;
}
)
;
}
_onWorkerActorListChanged
(
)
{
this
.
_workerActorList
.
onListChanged
=
null
;
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
workerListChanged
"
)
;
}
observe
(
subject
topic
data
)
{
if
(
!
this
.
attached
)
{
return
;
}
if
(
topic
=
=
"
webnavigation
-
create
"
)
{
subject
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
this
.
_onDocShellCreated
(
subject
)
;
}
else
if
(
topic
=
=
"
webnavigation
-
destroy
"
)
{
this
.
_onDocShellDestroy
(
subject
)
;
}
}
_onDocShellCreated
(
docShell
)
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
if
(
docShell
.
isBeingDestroyed
(
)
)
{
return
;
}
if
(
this
.
_isRootDocShell
(
docShell
)
)
{
this
.
_progressListener
.
watch
(
docShell
)
;
}
this
.
_notifyDocShellsUpdate
(
[
docShell
]
)
;
}
)
;
}
_onDocShellDestroy
(
docShell
)
{
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
this
.
_notifyDocShellDestroy
(
webProgress
)
;
}
_isRootDocShell
(
docShell
)
{
return
!
docShell
.
parent
;
}
_docShellsToWindows
(
docshells
)
{
return
docshells
.
map
(
docShell
=
>
{
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
let
window
=
webProgress
.
DOMWindow
;
let
id
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
let
parentID
=
undefined
;
if
(
window
.
parent
&
&
window
!
=
this
.
_originalWindow
)
{
parentID
=
window
.
parent
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
}
let
addonID
=
window
.
document
.
nodePrincipal
.
originAttributes
.
addonId
;
return
{
id
parentID
addonID
url
:
window
.
location
.
href
title
:
window
.
document
.
title
}
;
}
)
;
}
_notifyDocShellsUpdate
(
docshells
)
{
let
windows
=
this
.
_docShellsToWindows
(
docshells
)
;
if
(
windows
.
length
=
=
0
)
{
return
;
}
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
frameUpdate
"
frames
:
windows
}
)
;
}
_updateChildDocShells
(
)
{
this
.
_notifyDocShellsUpdate
(
this
.
docShells
)
;
}
_notifyDocShellDestroy
(
webProgress
)
{
webProgress
=
webProgress
.
QueryInterface
(
Ci
.
nsIWebProgress
)
;
let
id
=
webProgress
.
DOMWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
outerWindowID
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
frameUpdate
"
frames
:
[
{
id
destroy
:
true
}
]
}
)
;
webProgress
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
this
.
_progressListener
.
unwatch
(
webProgress
)
;
if
(
webProgress
.
DOMWindow
=
=
this
.
_originalWindow
)
{
let
rootDocShells
=
this
.
docShells
.
filter
(
d
=
>
{
return
d
!
=
this
.
docShell
&
&
this
.
_isRootDocShell
(
d
)
;
}
)
;
if
(
rootDocShells
.
length
>
0
)
{
let
newRoot
=
rootDocShells
[
0
]
;
this
.
_originalWindow
=
newRoot
.
DOMWindow
;
this
.
_changeTopLevelDocument
(
this
.
_originalWindow
)
;
}
else
{
this
.
exit
(
)
;
}
return
;
}
if
(
webProgress
.
DOMWindow
=
=
this
.
window
&
&
this
.
window
!
=
this
.
_originalWindow
)
{
this
.
_changeTopLevelDocument
(
this
.
_originalWindow
)
;
}
}
_notifyDocShellDestroyAll
(
)
{
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
frameUpdate
"
destroyAll
:
true
}
)
;
}
_pushContext
(
)
{
assert
(
!
this
.
_contextPool
"
Can
'
t
push
multiple
contexts
"
)
;
this
.
_contextPool
=
new
ActorPool
(
this
.
conn
)
;
this
.
conn
.
addActorPool
(
this
.
_contextPool
)
;
this
.
threadActor
=
new
ThreadActor
(
this
this
.
window
)
;
this
.
_contextPool
.
addActor
(
this
.
threadActor
)
;
}
_popContext
(
)
{
assert
(
!
!
this
.
_contextPool
"
No
context
to
pop
.
"
)
;
this
.
conn
.
removeActorPool
(
this
.
_contextPool
)
;
this
.
_contextPool
=
null
;
this
.
threadActor
.
exit
(
)
;
this
.
threadActor
=
null
;
this
.
_sources
=
null
;
}
_detach
(
)
{
if
(
!
this
.
attached
)
{
return
false
;
}
if
(
this
.
docShell
)
{
this
.
_progressListener
.
unwatch
(
this
.
docShell
)
;
this
.
_restoreDocumentSettings
(
)
;
}
if
(
this
.
_progressListener
)
{
this
.
_progressListener
.
destroy
(
)
;
this
.
_progressListener
=
null
;
this
.
_originalWindow
=
null
;
if
(
this
.
listenForNewDocShells
)
{
Services
.
obs
.
removeObserver
(
this
"
webnavigation
-
create
"
)
;
}
Services
.
obs
.
removeObserver
(
this
"
webnavigation
-
destroy
"
)
;
}
this
.
_popContext
(
)
;
for
(
let
sheetActor
of
this
.
_styleSheetActors
.
values
(
)
)
{
this
.
_tabPool
.
removeActor
(
sheetActor
)
;
}
this
.
_styleSheetActors
.
clear
(
)
;
this
.
conn
.
removeActorPool
(
this
.
_tabPool
)
;
this
.
_tabPool
=
null
;
if
(
this
.
_tabActorPool
)
{
this
.
conn
.
removeActorPool
(
this
.
_tabActorPool
)
;
this
.
_tabActorPool
=
null
;
}
if
(
this
.
_workerActorList
!
=
=
null
)
{
this
.
_workerActorList
.
onListChanged
=
null
;
this
.
_workerActorList
=
null
;
}
if
(
this
.
_workerActorPool
!
=
=
null
)
{
this
.
conn
.
removeActorPool
(
this
.
_workerActorPool
)
;
this
.
_workerActorPool
=
null
;
}
this
.
_attached
=
false
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
tabDetached
"
}
)
;
return
true
;
}
onAttach
(
request
)
{
if
(
this
.
exited
)
{
return
{
type
:
"
exited
"
}
;
}
this
.
_attach
(
)
;
return
{
type
:
"
tabAttached
"
threadActor
:
this
.
threadActor
.
actorID
cacheDisabled
:
this
.
_getCacheDisabled
(
)
javascriptEnabled
:
this
.
_getJavascriptEnabled
(
)
traits
:
this
.
traits
}
;
}
onDetach
(
request
)
{
if
(
!
this
.
_detach
(
)
)
{
return
{
error
:
"
wrongState
"
}
;
}
return
{
type
:
"
detached
"
}
;
}
onFocus
(
)
{
if
(
this
.
window
)
{
this
.
window
.
focus
(
)
;
}
return
{
}
;
}
onReload
(
request
)
{
let
force
=
request
&
&
request
.
options
&
&
request
.
options
.
force
;
Services
.
tm
.
currentThread
.
dispatch
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
Services
.
startup
.
shuttingDown
)
{
return
;
}
this
.
webNavigation
.
reload
(
force
?
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_CACHE
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_NONE
)
;
}
"
TabActor
.
prototype
.
onReload
'
s
delayed
body
"
)
0
)
;
return
{
}
;
}
onNavigateTo
(
request
)
{
Services
.
tm
.
currentThread
.
dispatch
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
this
.
window
.
location
=
request
.
url
;
}
"
TabActor
.
prototype
.
onNavigateTo
'
s
delayed
body
"
)
0
)
;
return
{
}
;
}
onReconfigure
(
request
)
{
let
options
=
request
.
options
|
|
{
}
;
if
(
!
this
.
docShell
)
{
return
{
}
;
}
this
.
_toggleDevToolsSettings
(
options
)
;
return
{
}
;
}
_toggleDevToolsSettings
(
options
)
{
let
reload
=
false
;
if
(
typeof
options
.
javascriptEnabled
!
=
=
"
undefined
"
&
&
options
.
javascriptEnabled
!
=
=
this
.
_getJavascriptEnabled
(
)
)
{
this
.
_setJavascriptEnabled
(
options
.
javascriptEnabled
)
;
reload
=
true
;
}
if
(
typeof
options
.
cacheDisabled
!
=
=
"
undefined
"
&
&
options
.
cacheDisabled
!
=
=
this
.
_getCacheDisabled
(
)
)
{
this
.
_setCacheDisabled
(
options
.
cacheDisabled
)
;
}
if
(
(
typeof
options
.
serviceWorkersTestingEnabled
!
=
=
"
undefined
"
)
&
&
(
options
.
serviceWorkersTestingEnabled
!
=
=
this
.
_getServiceWorkersTestingEnabled
(
)
)
)
{
this
.
_setServiceWorkersTestingEnabled
(
options
.
serviceWorkersTestingEnabled
)
;
}
let
hasExplicitReloadFlag
=
"
performReload
"
in
options
;
if
(
(
hasExplicitReloadFlag
&
&
options
.
performReload
)
|
|
(
!
hasExplicitReloadFlag
&
&
reload
)
)
{
this
.
onReload
(
)
;
}
}
_restoreDocumentSettings
(
)
{
this
.
_restoreJavascript
(
)
;
this
.
_setCacheDisabled
(
false
)
;
this
.
_setServiceWorkersTestingEnabled
(
false
)
;
}
_setCacheDisabled
(
disabled
)
{
let
enable
=
Ci
.
nsIRequest
.
LOAD_NORMAL
;
let
disable
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
|
Ci
.
nsIRequest
.
INHIBIT_CACHING
;
this
.
docShell
.
defaultLoadFlags
=
disabled
?
disable
:
enable
;
}
_wasJavascriptEnabled
:
null
_setJavascriptEnabled
(
allow
)
{
if
(
this
.
_wasJavascriptEnabled
=
=
=
null
)
{
this
.
_wasJavascriptEnabled
=
this
.
docShell
.
allowJavascript
;
}
this
.
docShell
.
allowJavascript
=
allow
;
}
_restoreJavascript
(
)
{
if
(
this
.
_wasJavascriptEnabled
!
=
=
null
)
{
this
.
_setJavascriptEnabled
(
this
.
_wasJavascriptEnabled
)
;
this
.
_wasJavascriptEnabled
=
null
;
}
}
_getJavascriptEnabled
(
)
{
if
(
!
this
.
docShell
)
{
return
null
;
}
return
this
.
docShell
.
allowJavascript
;
}
_setServiceWorkersTestingEnabled
(
enabled
)
{
let
windowUtils
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
windowUtils
.
serviceWorkersTestingEnabled
=
enabled
;
}
_getCacheDisabled
(
)
{
if
(
!
this
.
docShell
)
{
return
null
;
}
let
disable
=
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
|
Ci
.
nsIRequest
.
INHIBIT_CACHING
;
return
this
.
docShell
.
defaultLoadFlags
=
=
=
disable
;
}
_getServiceWorkersTestingEnabled
(
)
{
if
(
!
this
.
docShell
)
{
return
null
;
}
let
windowUtils
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
return
windowUtils
.
serviceWorkersTestingEnabled
;
}
preNest
(
)
{
if
(
!
this
.
window
)
{
return
;
}
let
windowUtils
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
windowUtils
.
suppressEventHandling
(
true
)
;
windowUtils
.
suspendTimeouts
(
)
;
}
postNest
(
nestData
)
{
if
(
!
this
.
window
)
{
return
;
}
let
windowUtils
=
this
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
windowUtils
.
resumeTimeouts
(
)
;
windowUtils
.
suppressEventHandling
(
false
)
;
}
_changeTopLevelDocument
(
window
)
{
this
.
_willNavigate
(
this
.
window
window
.
location
.
href
null
true
)
;
this
.
_windowDestroyed
(
this
.
window
null
true
)
;
this
.
_setWindow
(
window
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
this
.
_windowReady
(
window
true
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
this
.
_navigate
(
window
true
)
;
}
)
;
}
)
;
}
_setWindow
(
window
)
{
let
docShell
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
Object
.
defineProperty
(
this
"
docShell
"
{
value
:
docShell
enumerable
:
true
configurable
:
true
}
)
;
events
.
emit
(
this
"
changed
-
toplevel
-
document
"
)
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
frameUpdate
"
selected
:
this
.
outerWindowID
}
)
;
}
_windowReady
(
window
isFrameSwitching
=
false
)
{
let
isTopLevel
=
window
=
=
this
.
window
;
if
(
window
=
=
this
.
_originalWindow
&
&
!
isFrameSwitching
)
{
this
.
_updateChildDocShells
(
)
;
}
events
.
emit
(
this
"
window
-
ready
"
{
window
:
window
isTopLevel
:
isTopLevel
id
:
getWindowID
(
window
)
}
)
;
let
threadActor
=
this
.
threadActor
;
if
(
isTopLevel
&
&
threadActor
.
state
!
=
"
detached
"
)
{
this
.
sources
.
reset
(
{
sourceMaps
:
true
}
)
;
threadActor
.
clearDebuggees
(
)
;
threadActor
.
dbg
.
enabled
=
true
;
threadActor
.
maybePauseOnExceptions
(
)
;
threadActor
.
global
=
window
;
}
if
(
threadActor
.
attached
)
{
threadActor
.
dbg
.
addDebuggees
(
)
;
}
}
_windowDestroyed
(
window
id
=
null
isFrozen
=
false
)
{
events
.
emit
(
this
"
window
-
destroyed
"
{
window
:
window
isTopLevel
:
window
=
=
this
.
window
id
:
id
|
|
getWindowID
(
window
)
isFrozen
:
isFrozen
}
)
;
}
_willNavigate
(
window
newURI
request
isFrameSwitching
=
false
)
{
let
isTopLevel
=
window
=
=
this
.
window
;
let
reset
=
false
;
if
(
window
=
=
this
.
_originalWindow
&
&
!
isFrameSwitching
)
{
this
.
_notifyDocShellDestroyAll
(
)
;
if
(
this
.
window
!
=
this
.
_originalWindow
)
{
reset
=
true
;
window
=
this
.
window
;
isTopLevel
=
true
;
}
}
events
.
emit
(
this
"
will
-
navigate
"
{
window
:
window
isTopLevel
:
isTopLevel
newURI
:
newURI
request
:
request
}
)
;
if
(
!
isTopLevel
)
{
return
;
}
let
threadActor
=
this
.
threadActor
;
if
(
threadActor
.
state
=
=
"
paused
"
)
{
this
.
conn
.
send
(
threadActor
.
unsafeSynchronize
(
Promise
.
resolve
(
threadActor
.
onResume
(
)
)
)
)
;
threadActor
.
dbg
.
enabled
=
false
;
}
threadActor
.
disableAllBreakpoints
(
)
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
tabNavigated
"
url
:
newURI
nativeConsoleAPI
:
true
state
:
"
start
"
isFrameSwitching
:
isFrameSwitching
}
)
;
if
(
reset
)
{
this
.
_setWindow
(
this
.
_originalWindow
)
;
}
}
_navigate
(
window
isFrameSwitching
=
false
)
{
let
isTopLevel
=
window
=
=
this
.
window
;
events
.
emit
(
this
"
navigate
"
{
window
:
window
isTopLevel
:
isTopLevel
}
)
;
if
(
!
isTopLevel
)
{
return
;
}
let
threadActor
=
this
.
threadActor
;
if
(
threadActor
.
state
=
=
"
running
"
)
{
threadActor
.
dbg
.
enabled
=
true
;
}
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
tabNavigated
"
url
:
this
.
url
title
:
this
.
title
nativeConsoleAPI
:
this
.
hasNativeConsoleAPI
(
this
.
window
)
state
:
"
stop
"
isFrameSwitching
:
isFrameSwitching
}
)
;
}
hasNativeConsoleAPI
(
window
)
{
let
isNative
=
false
;
try
{
let
console
=
window
.
wrappedJSObject
.
console
;
isNative
=
new
XPCNativeWrapper
(
console
)
.
IS_NATIVE_CONSOLE
;
}
catch
(
ex
)
{
}
return
isNative
;
}
createStyleSheetActor
(
styleSheet
)
{
if
(
this
.
_styleSheetActors
.
has
(
styleSheet
)
)
{
return
this
.
_styleSheetActors
.
get
(
styleSheet
)
;
}
let
actor
=
new
StyleSheetActor
(
styleSheet
this
)
;
this
.
_styleSheetActors
.
set
(
styleSheet
actor
)
;
this
.
_tabPool
.
addActor
(
actor
)
;
events
.
emit
(
this
"
stylesheet
-
added
"
actor
)
;
return
actor
;
}
removeActorByName
(
name
)
{
if
(
name
in
this
.
_extraActors
)
{
const
actor
=
this
.
_extraActors
[
name
]
;
if
(
this
.
_tabActorPool
.
has
(
actor
)
)
{
this
.
_tabActorPool
.
removeActor
(
actor
)
;
}
delete
this
.
_extraActors
[
name
]
;
}
}
onResolveLocation
(
request
)
{
let
{
url
line
}
=
request
;
let
column
=
request
.
column
|
|
0
;
const
scripts
=
this
.
threadActor
.
dbg
.
findScripts
(
{
url
}
)
;
if
(
!
scripts
[
0
]
|
|
!
scripts
[
0
]
.
source
)
{
return
promise
.
resolve
(
{
from
:
this
.
actorID
type
:
"
resolveLocation
"
error
:
"
SOURCE_NOT_FOUND
"
}
)
;
}
const
source
=
scripts
[
0
]
.
source
;
const
generatedActor
=
this
.
sources
.
createNonSourceMappedActor
(
source
)
;
let
generatedLocation
=
new
GeneratedLocation
(
generatedActor
line
column
)
;
return
this
.
sources
.
getOriginalLocation
(
generatedLocation
)
.
then
(
loc
=
>
{
if
(
loc
.
originalLine
=
=
null
)
{
return
{
type
:
"
resolveLocation
"
error
:
"
MAP_NOT_FOUND
"
}
;
}
loc
=
loc
.
toJSON
(
)
;
return
{
from
:
this
.
actorID
url
:
loc
.
source
.
url
column
:
loc
.
column
line
:
loc
.
line
}
;
}
)
;
}
}
;
TabActor
.
prototype
.
requestTypes
=
{
"
attach
"
:
TabActor
.
prototype
.
onAttach
"
detach
"
:
TabActor
.
prototype
.
onDetach
"
focus
"
:
TabActor
.
prototype
.
onFocus
"
reload
"
:
TabActor
.
prototype
.
onReload
"
navigateTo
"
:
TabActor
.
prototype
.
onNavigateTo
"
reconfigure
"
:
TabActor
.
prototype
.
onReconfigure
"
switchToFrame
"
:
TabActor
.
prototype
.
onSwitchToFrame
"
listFrames
"
:
TabActor
.
prototype
.
onListFrames
"
listWorkers
"
:
TabActor
.
prototype
.
onListWorkers
"
resolveLocation
"
:
TabActor
.
prototype
.
onResolveLocation
}
;
exports
.
TabActor
=
TabActor
;
function
DebuggerProgressListener
(
tabActor
)
{
this
.
_tabActor
=
tabActor
;
this
.
_onWindowCreated
=
this
.
onWindowCreated
.
bind
(
this
)
;
this
.
_onWindowHidden
=
this
.
onWindowHidden
.
bind
(
this
)
;
Services
.
obs
.
addObserver
(
this
"
inner
-
window
-
destroyed
"
false
)
;
this
.
_knownWindowIDs
=
new
Map
(
)
;
this
.
_watchedDocShells
=
new
WeakSet
(
)
;
}
DebuggerProgressListener
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
Ci
.
nsISupports
]
)
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
"
inner
-
window
-
destroyed
"
)
;
this
.
_knownWindowIDs
.
clear
(
)
;
this
.
_knownWindowIDs
=
null
;
}
watch
(
docShell
)
{
let
docShellWindow
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
this
.
_watchedDocShells
.
add
(
docShellWindow
)
;
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATUS
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
let
handler
=
getDocShellChromeEventHandler
(
docShell
)
;
handler
.
addEventListener
(
"
DOMWindowCreated
"
this
.
_onWindowCreated
true
)
;
handler
.
addEventListener
(
"
pageshow
"
this
.
_onWindowCreated
true
)
;
handler
.
addEventListener
(
"
pagehide
"
this
.
_onWindowHidden
true
)
;
for
(
let
win
of
this
.
_getWindowsInDocShell
(
docShell
)
)
{
this
.
_tabActor
.
_windowReady
(
win
)
;
this
.
_knownWindowIDs
.
set
(
getWindowID
(
win
)
win
)
;
}
}
unwatch
(
docShell
)
{
let
docShellWindow
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
if
(
!
this
.
_watchedDocShells
.
has
(
docShellWindow
)
)
{
return
;
}
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
try
{
webProgress
.
removeProgressListener
(
this
)
;
}
catch
(
e
)
{
}
let
handler
=
getDocShellChromeEventHandler
(
docShell
)
;
handler
.
removeEventListener
(
"
DOMWindowCreated
"
this
.
_onWindowCreated
true
)
;
handler
.
removeEventListener
(
"
pageshow
"
this
.
_onWindowCreated
true
)
;
handler
.
removeEventListener
(
"
pagehide
"
this
.
_onWindowHidden
true
)
;
for
(
let
win
of
this
.
_getWindowsInDocShell
(
docShell
)
)
{
this
.
_knownWindowIDs
.
delete
(
getWindowID
(
win
)
)
;
}
}
_getWindowsInDocShell
(
docShell
)
{
return
getChildDocShells
(
docShell
)
.
map
(
d
=
>
{
return
d
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
)
;
}
onWindowCreated
:
DevToolsUtils
.
makeInfallible
(
function
(
evt
)
{
if
(
!
this
.
_tabActor
.
attached
)
{
return
;
}
if
(
evt
.
type
=
=
"
pageshow
"
&
&
!
evt
.
persisted
)
{
return
;
}
let
window
=
evt
.
target
.
defaultView
;
this
.
_tabActor
.
_windowReady
(
window
)
;
if
(
evt
.
type
!
=
=
"
pageshow
"
)
{
this
.
_knownWindowIDs
.
set
(
getWindowID
(
window
)
window
)
;
}
}
"
DebuggerProgressListener
.
prototype
.
onWindowCreated
"
)
onWindowHidden
:
DevToolsUtils
.
makeInfallible
(
function
(
evt
)
{
if
(
!
this
.
_tabActor
.
attached
)
{
return
;
}
if
(
!
evt
.
persisted
)
{
return
;
}
let
window
=
evt
.
target
.
defaultView
;
this
.
_tabActor
.
_windowDestroyed
(
window
null
true
)
;
}
"
DebuggerProgressListener
.
prototype
.
onWindowHidden
"
)
observe
:
DevToolsUtils
.
makeInfallible
(
function
(
subject
topic
)
{
if
(
!
this
.
_tabActor
.
attached
)
{
return
;
}
let
innerID
=
subject
.
QueryInterface
(
Ci
.
nsISupportsPRUint64
)
.
data
;
let
window
=
this
.
_knownWindowIDs
.
get
(
innerID
)
;
if
(
window
)
{
this
.
_knownWindowIDs
.
delete
(
innerID
)
;
this
.
_tabActor
.
_windowDestroyed
(
window
innerID
)
;
}
}
"
DebuggerProgressListener
.
prototype
.
observe
"
)
onStateChange
:
DevToolsUtils
.
makeInfallible
(
function
(
progress
request
flag
status
)
{
if
(
!
this
.
_tabActor
.
attached
)
{
return
;
}
let
isStart
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_START
;
let
isStop
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
;
let
isDocument
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_IS_DOCUMENT
;
let
isWindow
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_IS_WINDOW
;
if
(
isDocument
&
&
isStop
)
{
progress
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
this
.
_tabActor
.
_notifyDocShellsUpdate
(
[
progress
]
)
;
}
let
window
=
progress
.
DOMWindow
;
if
(
isDocument
&
&
isStart
)
{
let
newURI
=
request
instanceof
Ci
.
nsIChannel
?
request
.
URI
.
spec
:
null
;
this
.
_tabActor
.
_willNavigate
(
window
newURI
request
)
;
}
if
(
isWindow
&
&
isStop
)
{
if
(
request
.
status
!
=
Cr
.
NS_OK
)
{
let
handler
=
getDocShellChromeEventHandler
(
progress
)
;
let
onLoad
=
evt
=
>
{
if
(
evt
.
target
=
=
window
.
document
)
{
handler
.
removeEventListener
(
"
DOMContentLoaded
"
onLoad
true
)
;
this
.
_tabActor
.
_navigate
(
window
)
;
}
}
;
handler
.
addEventListener
(
"
DOMContentLoaded
"
onLoad
true
)
;
}
else
{
this
.
_tabActor
.
_navigate
(
window
)
;
}
}
}
"
DebuggerProgressListener
.
prototype
.
onStateChange
"
)
}
;
