"
use
strict
"
;
const
{
Cc
Ci
Cu
components
}
=
require
(
"
chrome
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
method
RetVal
Arg
types
}
=
protocol
;
const
{
Memory
}
=
require
(
"
devtools
/
server
/
performance
/
memory
"
)
;
const
{
actorBridge
}
=
require
(
"
devtools
/
server
/
actors
/
common
"
)
;
loader
.
lazyRequireGetter
(
this
"
events
"
"
sdk
/
event
/
core
"
)
;
loader
.
lazyRequireGetter
(
this
"
StackFrameCache
"
"
devtools
/
server
/
actors
/
utils
/
stack
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HeapSnapshotFileUtils
"
"
devtools
/
shared
/
heapsnapshot
/
HeapSnapshotFileUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
ThreadSafeChromeUtils
"
)
;
types
.
addDictType
(
"
AllocationsRecordingOptions
"
{
probability
:
"
number
"
maxLogLength
:
"
number
"
}
)
;
var
MemoryActor
=
exports
.
MemoryActor
=
protocol
.
ActorClass
(
{
typeName
:
"
memory
"
events
:
{
"
garbage
-
collection
"
:
{
type
:
"
garbage
-
collection
"
data
:
Arg
(
0
"
json
"
)
}
"
allocations
"
:
{
type
:
"
allocations
"
data
:
Arg
(
0
"
json
"
)
}
}
initialize
:
function
(
conn
parent
frameCache
=
new
StackFrameCache
(
)
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
_onGarbageCollection
=
this
.
_onGarbageCollection
.
bind
(
this
)
;
this
.
_onAllocations
=
this
.
_onAllocations
.
bind
(
this
)
;
this
.
bridge
=
new
Memory
(
parent
frameCache
)
;
this
.
bridge
.
on
(
"
garbage
-
collection
"
this
.
_onGarbageCollection
)
;
this
.
bridge
.
on
(
"
allocations
"
this
.
_onAllocations
)
;
}
destroy
:
function
(
)
{
this
.
bridge
.
off
(
"
garbage
-
collection
"
this
.
_onGarbageCollection
)
;
this
.
bridge
.
off
(
"
allocations
"
this
.
_onAllocations
)
;
this
.
bridge
.
destroy
(
)
;
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
}
attach
:
actorBridge
(
"
attach
"
{
request
:
{
}
response
:
{
type
:
"
attached
"
}
}
)
detach
:
actorBridge
(
"
detach
"
{
request
:
{
}
response
:
{
type
:
"
detached
"
}
}
)
getState
:
actorBridge
(
"
getState
"
{
response
:
{
state
:
RetVal
(
0
"
string
"
)
}
}
)
saveHeapSnapshot
:
method
(
function
(
)
{
return
this
.
bridge
.
saveHeapSnapshot
(
)
;
}
{
response
:
{
snapshotId
:
RetVal
(
"
string
"
)
}
}
)
takeCensus
:
actorBridge
(
"
takeCensus
"
{
request
:
{
}
response
:
RetVal
(
"
json
"
)
}
)
startRecordingAllocations
:
actorBridge
(
"
startRecordingAllocations
"
{
request
:
{
options
:
Arg
(
0
"
nullable
:
AllocationsRecordingOptions
"
)
}
response
:
{
value
:
RetVal
(
0
"
nullable
:
number
"
)
}
}
)
stopRecordingAllocations
:
actorBridge
(
"
stopRecordingAllocations
"
{
request
:
{
}
response
:
{
value
:
RetVal
(
0
"
nullable
:
number
"
)
}
}
)
getAllocationsSettings
:
actorBridge
(
"
getAllocationsSettings
"
{
request
:
{
}
response
:
{
options
:
RetVal
(
0
"
json
"
)
}
}
)
getAllocations
:
actorBridge
(
"
getAllocations
"
{
request
:
{
}
response
:
RetVal
(
"
json
"
)
}
)
forceGarbageCollection
:
actorBridge
(
"
forceGarbageCollection
"
{
request
:
{
}
response
:
{
}
}
)
forceCycleCollection
:
actorBridge
(
"
forceCycleCollection
"
{
request
:
{
}
response
:
{
}
}
)
measure
:
actorBridge
(
"
measure
"
{
request
:
{
}
response
:
RetVal
(
"
json
"
)
}
)
residentUnique
:
actorBridge
(
"
residentUnique
"
{
request
:
{
}
response
:
{
value
:
RetVal
(
"
number
"
)
}
}
)
_onGarbageCollection
:
function
(
data
)
{
if
(
this
.
conn
.
transport
)
{
events
.
emit
(
this
"
garbage
-
collection
"
data
)
;
}
}
_onAllocations
:
function
(
data
)
{
if
(
this
.
conn
.
transport
)
{
events
.
emit
(
this
"
allocations
"
data
)
;
}
}
}
)
;
exports
.
MemoryFront
=
protocol
.
FrontClass
(
MemoryActor
{
initialize
:
function
(
client
form
rootForm
=
null
)
{
protocol
.
Front
.
prototype
.
initialize
.
call
(
this
client
form
)
;
this
.
_client
=
client
;
this
.
actorID
=
form
.
memoryActor
;
this
.
heapSnapshotFileActorID
=
rootForm
?
rootForm
.
heapSnapshotFileActor
:
null
;
this
.
manage
(
this
)
;
}
saveHeapSnapshot
:
protocol
.
custom
(
Task
.
async
(
function
*
(
options
=
{
}
)
{
const
snapshotId
=
yield
this
.
_saveHeapSnapshotImpl
(
)
;
if
(
!
options
.
forceCopy
&
&
(
yield
HeapSnapshotFileUtils
.
haveHeapSnapshotTempFile
(
snapshotId
)
)
)
{
return
HeapSnapshotFileUtils
.
getHeapSnapshotTempFilePath
(
snapshotId
)
;
}
return
yield
this
.
transferHeapSnapshot
(
snapshotId
)
;
}
)
{
impl
:
"
_saveHeapSnapshotImpl
"
}
)
transferHeapSnapshot
:
protocol
.
custom
(
function
(
snapshotId
)
{
if
(
!
this
.
heapSnapshotFileActorID
)
{
throw
new
Error
(
"
MemoryFront
initialized
without
a
rootForm
"
)
;
}
const
request
=
this
.
_client
.
request
(
{
to
:
this
.
heapSnapshotFileActorID
type
:
"
transferHeapSnapshot
"
snapshotId
}
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
outFilePath
=
HeapSnapshotFileUtils
.
getNewUniqueHeapSnapshotTempFilePath
(
)
;
const
outFile
=
new
FileUtils
.
File
(
outFilePath
)
;
const
outFileStream
=
FileUtils
.
openSafeFileOutputStream
(
outFile
)
;
request
.
on
(
"
bulk
-
reply
"
Task
.
async
(
function
*
(
{
copyTo
}
)
{
yield
copyTo
(
outFileStream
)
;
FileUtils
.
closeSafeFileOutputStream
(
outFileStream
)
;
resolve
(
outFilePath
)
;
}
)
)
;
}
)
;
}
)
}
)
;
