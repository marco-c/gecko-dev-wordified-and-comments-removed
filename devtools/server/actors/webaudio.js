"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
CallWatcherActor
}
=
require
(
"
devtools
/
server
/
actors
/
call
-
watcher
"
)
;
const
{
createValueGrip
}
=
require
(
"
devtools
/
server
/
actors
/
object
"
)
;
const
AutomationTimeline
=
require
(
"
.
/
utils
/
automation
-
timeline
"
)
;
const
{
audionodeSpec
webAudioSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
webaudio
"
)
;
const
{
WebAudioFront
}
=
require
(
"
devtools
/
shared
/
fronts
/
webaudio
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
AUDIO_NODE_DEFINITION
=
require
(
"
devtools
/
server
/
actors
/
utils
/
audionodes
.
json
"
)
;
const
ENABLE_AUTOMATION
=
false
;
const
AUTOMATION_GRANULARITY
=
2000
;
const
AUTOMATION_GRANULARITY_MAX
=
6000
;
const
AUDIO_GLOBALS
=
[
"
BaseAudioContext
"
"
AudioContext
"
"
AudioNode
"
"
AudioParam
"
]
;
var
AudioNodeActor
=
exports
.
AudioNodeActor
=
protocol
.
ActorClassWithSpec
(
audionodeSpec
{
form
:
function
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
return
{
actor
:
this
.
actorID
type
:
this
.
type
source
:
this
.
source
bypassable
:
this
.
bypassable
}
;
}
initialize
:
function
(
conn
node
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
nativeID
=
node
.
id
;
this
.
node
=
Cu
.
getWeakReference
(
node
)
;
this
.
automation
=
{
}
;
try
{
this
.
type
=
getConstructorName
(
node
)
;
}
catch
(
e
)
{
this
.
type
=
"
"
;
}
this
.
source
=
!
!
AUDIO_NODE_DEFINITION
[
this
.
type
]
.
source
;
this
.
bypassable
=
!
AUDIO_NODE_DEFINITION
[
this
.
type
]
.
unbypassable
;
Object
.
keys
(
AUDIO_NODE_DEFINITION
[
this
.
type
]
.
properties
|
|
{
}
)
.
filter
(
isAudioParam
.
bind
(
null
node
)
)
.
forEach
(
paramName
=
>
{
this
.
automation
[
paramName
]
=
new
AutomationTimeline
(
node
[
paramName
]
.
defaultValue
)
;
}
)
;
}
getType
:
function
(
)
{
return
this
.
type
;
}
isBypassed
:
function
(
)
{
let
node
=
this
.
node
.
get
(
)
;
if
(
node
=
=
=
null
)
{
return
false
;
}
return
!
!
node
.
passThrough
;
}
bypass
:
function
(
enable
)
{
let
node
=
this
.
node
.
get
(
)
;
if
(
node
=
=
=
null
)
{
return
undefined
;
}
if
(
this
.
bypassable
)
{
node
.
passThrough
=
enable
;
}
return
this
.
isBypassed
(
)
;
}
setParam
:
function
(
param
value
)
{
let
node
=
this
.
node
.
get
(
)
;
if
(
node
=
=
=
null
)
{
return
CollectedAudioNodeError
(
)
;
}
try
{
if
(
isAudioParam
(
node
param
)
)
{
node
[
param
]
.
value
=
value
;
this
.
automation
[
param
]
.
setValue
(
value
)
;
}
else
{
node
[
param
]
=
value
;
}
return
undefined
;
}
catch
(
e
)
{
return
constructError
(
e
)
;
}
}
getParam
:
function
(
param
)
{
let
node
=
this
.
node
.
get
(
)
;
if
(
node
=
=
=
null
)
{
return
CollectedAudioNodeError
(
)
;
}
let
value
=
isAudioParam
(
node
param
)
?
node
[
param
]
.
value
:
node
[
param
]
;
let
grip
=
createValueGrip
(
value
null
createObjectGrip
)
;
return
grip
;
}
getParamFlags
:
function
(
param
)
{
return
(
(
AUDIO_NODE_DEFINITION
[
this
.
type
]
|
|
{
}
)
.
properties
|
|
{
}
)
[
param
]
;
}
getParams
:
function
(
param
)
{
let
props
=
Object
.
keys
(
AUDIO_NODE_DEFINITION
[
this
.
type
]
.
properties
|
|
{
}
)
;
return
props
.
map
(
prop
=
>
(
{
param
:
prop
value
:
this
.
getParam
(
prop
)
flags
:
this
.
getParamFlags
(
prop
)
}
)
)
;
}
connectParam
:
function
(
destActor
paramName
output
)
{
let
srcNode
=
this
.
node
.
get
(
)
;
let
destNode
=
destActor
.
node
.
get
(
)
;
if
(
srcNode
=
=
=
null
|
|
destNode
=
=
=
null
)
{
return
CollectedAudioNodeError
(
)
;
}
try
{
XPCNativeWrapper
.
unwrap
(
srcNode
)
.
connect
(
destNode
[
paramName
]
output
)
;
}
catch
(
e
)
{
return
constructError
(
e
)
;
}
return
undefined
;
}
connectNode
:
function
(
destActor
output
input
)
{
let
srcNode
=
this
.
node
.
get
(
)
;
let
destNode
=
destActor
.
node
.
get
(
)
;
if
(
srcNode
=
=
=
null
|
|
destNode
=
=
=
null
)
{
return
CollectedAudioNodeError
(
)
;
}
try
{
XPCNativeWrapper
.
unwrap
(
srcNode
)
.
connect
(
destNode
output
input
)
;
}
catch
(
e
)
{
return
constructError
(
e
)
;
}
return
undefined
;
}
disconnect
:
function
(
destActor
output
)
{
let
node
=
this
.
node
.
get
(
)
;
if
(
node
=
=
=
null
)
{
return
CollectedAudioNodeError
(
)
;
}
try
{
XPCNativeWrapper
.
unwrap
(
node
)
.
disconnect
(
output
)
;
}
catch
(
e
)
{
return
constructError
(
e
)
;
}
return
undefined
;
}
getAutomationData
:
function
(
paramName
)
{
let
timeline
=
this
.
automation
[
paramName
]
;
if
(
!
timeline
)
{
return
null
;
}
let
values
=
[
]
;
let
i
=
0
;
if
(
!
timeline
.
events
.
length
)
{
return
{
events
:
timeline
.
events
values
}
;
}
let
firstEvent
=
timeline
.
events
[
0
]
;
let
lastEvent
=
timeline
.
events
[
timeline
.
events
.
length
-
1
]
;
let
timeDelta
=
(
lastEvent
.
time
+
lastEvent
.
duration
)
-
firstEvent
.
time
;
let
scale
=
timeDelta
/
AUTOMATION_GRANULARITY
;
for
(
;
i
<
AUTOMATION_GRANULARITY
;
i
+
+
)
{
let
delta
=
firstEvent
.
time
+
(
i
*
scale
)
;
let
value
=
timeline
.
getValueAtTime
(
delta
)
;
values
.
push
(
{
delta
value
}
)
;
}
if
(
lastEvent
.
type
=
=
=
"
setTargetAtTime
"
)
{
for
(
;
i
<
AUTOMATION_GRANULARITY_MAX
;
i
+
+
)
{
let
delta
=
firstEvent
.
time
+
(
+
+
i
*
scale
)
;
let
value
=
timeline
.
getValueAtTime
(
delta
)
;
values
.
push
(
{
delta
value
}
)
;
}
}
return
{
events
:
timeline
.
events
values
}
;
}
addAutomationEvent
:
function
(
paramName
eventName
args
=
[
]
)
{
let
node
=
this
.
node
.
get
(
)
;
let
timeline
=
this
.
automation
[
paramName
]
;
if
(
node
=
=
=
null
)
{
return
CollectedAudioNodeError
(
)
;
}
if
(
!
timeline
|
|
!
node
[
paramName
]
[
eventName
]
)
{
return
InvalidCommandError
(
)
;
}
try
{
let
param
=
XPCNativeWrapper
.
unwrap
(
node
[
paramName
]
)
;
let
contentGlobal
=
Cu
.
getGlobalForObject
(
param
)
;
let
contentArgs
=
Cu
.
cloneInto
(
args
contentGlobal
)
;
if
(
eventName
=
=
=
"
setValueCurveAtTime
"
)
{
let
curve
=
new
contentGlobal
.
Float32Array
(
contentArgs
[
0
]
)
;
contentArgs
[
0
]
=
curve
;
}
param
[
eventName
]
.
apply
(
param
contentArgs
)
;
}
catch
(
e
)
{
return
constructError
(
e
)
;
}
return
undefined
;
}
_recordAutomationEvent
:
function
(
paramName
eventName
args
)
{
let
timeline
=
this
.
automation
[
paramName
]
;
timeline
[
eventName
]
.
apply
(
timeline
args
)
;
}
}
)
;
exports
.
WebAudioActor
=
protocol
.
ActorClassWithSpec
(
webAudioSpec
{
initialize
:
function
(
conn
tabActor
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
tabActor
=
tabActor
;
this
.
_onContentFunctionCall
=
this
.
_onContentFunctionCall
.
bind
(
this
)
;
this
.
_nativeToActorID
=
new
Map
(
)
;
this
.
_onGlobalDestroyed
=
this
.
_onGlobalDestroyed
.
bind
(
this
)
;
this
.
_onGlobalCreated
=
this
.
_onGlobalCreated
.
bind
(
this
)
;
}
destroy
:
function
(
conn
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
conn
)
;
this
.
finalize
(
)
;
}
getDefinition
:
function
(
)
{
return
AUDIO_NODE_DEFINITION
;
}
setup
:
function
(
{
reload
}
)
{
this
.
_firstNodeCreated
=
false
;
this
.
_nativeToActorID
.
clear
(
)
;
if
(
this
.
_initialized
)
{
if
(
reload
)
{
this
.
tabActor
.
window
.
location
.
reload
(
)
;
}
return
;
}
this
.
_initialized
=
true
;
this
.
_callWatcher
=
new
CallWatcherActor
(
this
.
conn
this
.
tabActor
)
;
this
.
_callWatcher
.
onCall
=
this
.
_onContentFunctionCall
;
this
.
_callWatcher
.
setup
(
{
tracedGlobals
:
AUDIO_GLOBALS
startRecording
:
true
performReload
:
reload
holdWeak
:
true
storeCalls
:
false
}
)
;
this
.
tabActor
.
on
(
"
window
-
ready
"
this
.
_onGlobalCreated
)
;
this
.
tabActor
.
on
(
"
window
-
destroyed
"
this
.
_onGlobalDestroyed
)
;
}
_onContentFunctionCall
:
function
(
functionCall
)
{
let
{
name
}
=
functionCall
.
details
;
if
(
WebAudioFront
.
NODE_ROUTING_METHODS
.
has
(
name
)
)
{
this
.
_handleRoutingCall
(
functionCall
)
;
}
else
if
(
WebAudioFront
.
NODE_CREATION_METHODS
.
has
(
name
)
)
{
this
.
_handleCreationCall
(
functionCall
)
;
}
else
if
(
ENABLE_AUTOMATION
&
&
WebAudioFront
.
AUTOMATION_METHODS
.
has
(
name
)
)
{
this
.
_handleAutomationCall
(
functionCall
)
;
}
}
_handleRoutingCall
:
function
(
functionCall
)
{
let
{
caller
args
name
}
=
functionCall
.
details
;
let
source
=
caller
;
let
dest
=
args
[
0
]
;
let
isAudioPar
=
dest
?
getConstructorName
(
dest
)
=
=
=
"
AudioParam
"
:
false
;
if
(
name
=
=
=
"
connect
"
&
&
isAudioPar
)
{
this
.
_onConnectParam
(
source
dest
)
;
}
else
if
(
name
=
=
=
"
connect
"
)
{
this
.
_onConnectNode
(
source
dest
)
;
}
else
if
(
name
=
=
=
"
disconnect
"
)
{
this
.
_onDisconnectNode
(
source
)
;
}
}
_handleCreationCall
:
function
(
functionCall
)
{
let
{
caller
result
}
=
functionCall
.
details
;
if
(
!
this
.
_firstNodeCreated
)
{
this
.
_onStartContext
(
)
;
this
.
_onCreateNode
(
caller
.
destination
)
;
this
.
_firstNodeCreated
=
true
;
}
this
.
_onCreateNode
(
result
)
;
}
_handleAutomationCall
:
function
(
functionCall
)
{
let
{
caller
name
args
}
=
functionCall
.
details
;
let
wrappedParam
=
new
XPCNativeWrapper
(
caller
)
;
args
=
sanitizeAutomationArgs
(
args
)
;
let
nodeActor
=
this
.
_getActorByNativeID
(
wrappedParam
.
_parentID
)
;
nodeActor
.
_recordAutomationEvent
(
wrappedParam
.
_paramName
name
args
)
;
this
.
_onAutomationEvent
(
{
node
:
nodeActor
paramName
:
wrappedParam
.
_paramName
eventName
:
name
args
:
args
}
)
;
}
finalize
:
function
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
false
;
try
{
Services
.
obs
.
removeObserver
(
this
"
webaudio
-
node
-
demise
"
)
;
}
catch
(
e
)
{
}
this
.
tabActor
.
off
(
"
window
-
destroyed
"
this
.
_onGlobalDestroyed
)
;
this
.
tabActor
.
off
(
"
window
-
ready
"
this
.
_onGlobalCreated
)
;
this
.
tabActor
=
null
;
this
.
_nativeToActorID
=
null
;
this
.
_callWatcher
.
eraseRecording
(
)
;
this
.
_callWatcher
.
finalize
(
)
;
this
.
_callWatcher
=
null
;
}
_constructAudioNode
:
function
(
node
)
{
node
=
new
XPCNativeWrapper
(
node
)
;
this
.
_instrumentParams
(
node
)
;
let
actor
=
new
AudioNodeActor
(
this
.
conn
node
)
;
this
.
manage
(
actor
)
;
this
.
_nativeToActorID
.
set
(
node
.
id
actor
.
actorID
)
;
return
actor
;
}
_instrumentParams
:
function
(
node
)
{
let
type
=
getConstructorName
(
node
)
;
Object
.
keys
(
AUDIO_NODE_DEFINITION
[
type
]
.
properties
|
|
{
}
)
.
filter
(
isAudioParam
.
bind
(
null
node
)
)
.
forEach
(
paramName
=
>
{
let
param
=
node
[
paramName
]
;
param
.
_parentID
=
node
.
id
;
param
.
_paramName
=
paramName
;
}
)
;
}
_getActorByNativeID
:
function
(
nativeID
)
{
nativeID
=
~
~
nativeID
;
let
actorID
=
this
.
_nativeToActorID
.
get
(
nativeID
)
;
let
actor
=
actorID
!
=
null
?
this
.
conn
.
getActor
(
actorID
)
:
null
;
return
actor
;
}
_onStartContext
:
function
(
)
{
Services
.
obs
.
addObserver
(
this
"
webaudio
-
node
-
demise
"
)
;
this
.
emit
(
"
start
-
context
"
)
;
}
_onConnectNode
:
function
(
source
dest
)
{
let
sourceActor
=
this
.
_getActorByNativeID
(
source
.
id
)
;
let
destActor
=
this
.
_getActorByNativeID
(
dest
.
id
)
;
this
.
emit
(
"
connect
-
node
"
{
source
:
sourceActor
dest
:
destActor
}
)
;
}
_onConnectParam
:
function
(
source
param
)
{
let
sourceActor
=
this
.
_getActorByNativeID
(
source
.
id
)
;
let
destActor
=
this
.
_getActorByNativeID
(
param
.
_parentID
)
;
this
.
emit
(
"
connect
-
param
"
{
source
:
sourceActor
dest
:
destActor
param
:
param
.
_paramName
}
)
;
}
_onDisconnectNode
:
function
(
node
)
{
let
actor
=
this
.
_getActorByNativeID
(
node
.
id
)
;
this
.
emit
(
"
disconnect
-
node
"
actor
)
;
}
_onParamChange
:
function
(
node
param
value
)
{
let
actor
=
this
.
_getActorByNativeID
(
node
.
id
)
;
this
.
emit
(
"
param
-
change
"
{
source
:
actor
param
:
param
value
:
value
}
)
;
}
_onCreateNode
:
function
(
node
)
{
let
actor
=
this
.
_constructAudioNode
(
node
)
;
this
.
emit
(
"
create
-
node
"
actor
)
;
}
observe
:
function
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
webaudio
-
node
-
demise
"
:
this
.
_handleNodeDestroyed
(
~
~
data
)
;
break
;
}
}
_handleNodeDestroyed
:
function
(
nodeNativeID
)
{
let
actor
=
this
.
_getActorByNativeID
(
nodeNativeID
)
;
if
(
actor
)
{
this
.
_nativeToActorID
.
delete
(
nodeNativeID
)
;
this
.
emit
(
"
destroy
-
node
"
actor
)
;
}
}
_onGlobalCreated
:
function
(
)
{
this
.
_firstNodeCreated
=
false
;
this
.
_nativeToActorID
.
clear
(
)
;
this
.
_callWatcher
.
resumeRecording
(
)
;
}
_onAutomationEvent
:
function
(
{
node
paramName
eventName
args
}
)
{
this
.
emit
(
"
automation
-
event
"
{
node
:
node
paramName
:
paramName
eventName
:
eventName
args
:
args
}
)
;
}
_onGlobalDestroyed
:
function
(
{
id
}
)
{
if
(
this
.
_callWatcher
.
_tracedWindowId
!
=
=
id
)
{
return
;
}
if
(
this
.
_nativeToActorID
)
{
this
.
_nativeToActorID
.
clear
(
)
;
}
Services
.
obs
.
removeObserver
(
this
"
webaudio
-
node
-
demise
"
)
;
}
}
)
;
function
isAudioParam
(
node
prop
)
{
return
!
!
(
node
[
prop
]
&
&
/
AudioParam
/
.
test
(
node
[
prop
]
.
toString
(
)
)
)
;
}
function
constructError
(
err
)
{
return
{
message
:
err
.
message
type
:
err
.
constructor
.
name
}
;
}
function
CollectedAudioNodeError
(
)
{
return
{
message
:
"
AudioNode
has
been
garbage
collected
and
can
no
longer
be
reached
.
"
type
:
"
UnreachableAudioNode
"
}
;
}
function
InvalidCommandError
(
)
{
return
{
message
:
"
The
command
on
AudioNode
is
invalid
.
"
type
:
"
InvalidCommand
"
}
;
}
function
getConstructorName
(
obj
)
{
return
Object
.
prototype
.
toString
.
call
(
obj
)
.
match
(
/
\
[
object
(
[
^
\
[
\
]
]
*
)
\
]
\
]
?
/
)
[
1
]
;
}
function
createObjectGrip
(
value
)
{
return
{
type
:
"
object
"
preview
:
{
kind
:
"
ObjectWithText
"
text
:
"
"
}
class
:
getConstructorName
(
value
)
}
;
}
function
sanitizeAutomationArgs
(
args
)
{
return
args
.
reduce
(
(
newArgs
el
)
=
>
{
let
isArray
=
typeof
el
=
=
=
"
object
"
&
&
getConstructorName
(
el
)
=
=
=
"
Float32Array
"
;
newArgs
.
push
(
isArray
?
castToArray
(
el
)
:
el
)
;
return
newArgs
;
}
[
]
)
;
}
function
castToArray
(
typedArray
)
{
let
global
=
Cu
.
getGlobalForObject
(
this
)
;
let
safeView
=
Cu
.
cloneInto
(
typedArray
.
subarray
(
)
global
)
;
return
copyInto
(
[
]
safeView
)
;
}
function
copyInto
(
dest
source
)
{
for
(
let
i
=
0
;
i
<
source
.
length
;
i
+
+
)
{
dest
[
i
]
=
source
[
i
]
;
}
return
dest
;
}
