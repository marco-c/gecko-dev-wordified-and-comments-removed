"
use
strict
"
;
const
{
Cc
Ci
Cu
Cr
}
=
require
(
"
chrome
"
)
;
const
events
=
require
(
"
sdk
/
event
/
core
"
)
;
const
protocol
=
require
(
"
devtools
/
server
/
protocol
"
)
;
const
{
serializeStack
parseStack
}
=
require
(
"
toolkit
/
loader
"
)
;
const
{
on
once
off
emit
}
=
events
;
const
{
method
Arg
Option
RetVal
}
=
protocol
;
protocol
.
types
.
addDictType
(
"
call
-
stack
-
item
"
{
name
:
"
string
"
file
:
"
string
"
line
:
"
number
"
}
)
;
protocol
.
types
.
addDictType
(
"
call
-
details
"
{
type
:
"
number
"
name
:
"
string
"
stack
:
"
array
:
call
-
stack
-
item
"
}
)
;
var
FunctionCallActor
=
protocol
.
ActorClass
(
{
typeName
:
"
function
-
call
"
initialize
:
function
(
conn
[
window
global
caller
type
name
stack
timestamp
args
result
]
holdWeak
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
details
=
{
global
:
global
type
:
type
name
:
name
stack
:
stack
timestamp
:
timestamp
}
;
if
(
holdWeak
)
{
let
weakRefs
=
{
window
:
Cu
.
getWeakReference
(
window
)
caller
:
Cu
.
getWeakReference
(
caller
)
args
:
Cu
.
getWeakReference
(
args
)
result
:
Cu
.
getWeakReference
(
result
)
}
;
Object
.
defineProperties
(
this
.
details
{
window
:
{
get
:
(
)
=
>
weakRefs
.
window
.
get
(
)
}
caller
:
{
get
:
(
)
=
>
weakRefs
.
caller
.
get
(
)
}
args
:
{
get
:
(
)
=
>
weakRefs
.
args
.
get
(
)
}
result
:
{
get
:
(
)
=
>
weakRefs
.
result
.
get
(
)
}
}
)
;
}
else
{
this
.
details
.
window
=
window
;
this
.
details
.
caller
=
caller
;
this
.
details
.
args
=
args
;
this
.
details
.
result
=
result
;
}
this
.
details
.
previews
=
{
caller
:
this
.
_generateStringPreview
(
caller
)
args
:
this
.
_generateArgsPreview
(
args
)
result
:
this
.
_generateStringPreview
(
result
)
}
;
}
form
:
function
(
)
{
return
{
actor
:
this
.
actorID
type
:
this
.
details
.
type
name
:
this
.
details
.
name
file
:
this
.
details
.
stack
[
0
]
.
file
line
:
this
.
details
.
stack
[
0
]
.
line
timestamp
:
this
.
details
.
timestamp
callerPreview
:
this
.
details
.
previews
.
caller
argsPreview
:
this
.
details
.
previews
.
args
resultPreview
:
this
.
details
.
previews
.
result
}
;
}
getDetails
:
method
(
function
(
)
{
let
{
type
name
stack
timestamp
}
=
this
.
details
;
for
(
let
i
=
stack
.
length
-
1
;
;
)
{
if
(
stack
[
i
]
.
file
)
{
break
;
}
stack
.
pop
(
)
;
i
-
-
;
}
return
{
type
:
type
name
:
name
stack
:
stack
timestamp
:
timestamp
}
;
}
{
response
:
{
info
:
RetVal
(
"
call
-
details
"
)
}
}
)
_generateArgsPreview
:
function
(
args
)
{
let
{
global
name
caller
}
=
this
.
details
;
let
methodSignatureEnums
;
let
knownGlobal
=
CallWatcherFront
.
KNOWN_METHODS
[
global
]
;
if
(
knownGlobal
)
{
let
knownMethod
=
knownGlobal
[
name
]
;
if
(
knownMethod
)
{
let
isOverloaded
=
typeof
knownMethod
.
enums
=
=
=
"
function
"
;
if
(
isOverloaded
)
{
methodSignatureEnums
=
methodSignatureEnums
(
args
)
;
}
else
{
methodSignatureEnums
=
knownMethod
.
enums
;
}
}
}
let
serializeArgs
=
(
)
=
>
args
.
map
(
(
arg
i
)
=
>
{
if
(
arg
=
=
=
undefined
)
{
return
"
undefined
"
;
}
if
(
arg
=
=
=
null
)
{
return
"
null
"
;
}
if
(
typeof
arg
=
=
"
function
"
)
{
return
"
Function
"
;
}
if
(
typeof
arg
=
=
"
object
"
)
{
return
"
Object
"
;
}
if
(
methodSignatureEnums
&
&
methodSignatureEnums
.
has
(
i
)
)
{
return
getBitToEnumValue
(
global
caller
arg
)
;
}
return
arg
+
"
"
;
}
)
;
return
serializeArgs
(
)
.
join
(
"
"
)
;
}
_generateStringPreview
:
function
(
data
)
{
if
(
data
=
=
=
undefined
)
{
return
"
undefined
"
;
}
if
(
data
=
=
=
null
)
{
return
"
null
"
;
}
if
(
typeof
data
=
=
"
function
"
)
{
return
"
Function
"
;
}
if
(
typeof
data
=
=
"
object
"
)
{
return
"
Object
"
;
}
return
data
+
"
"
;
}
}
)
;
var
FunctionCallFront
=
protocol
.
FrontClass
(
FunctionCallActor
{
initialize
:
function
(
client
form
)
{
protocol
.
Front
.
prototype
.
initialize
.
call
(
this
client
form
)
;
}
form
:
function
(
form
)
{
this
.
actorID
=
form
.
actor
;
this
.
type
=
form
.
type
;
this
.
name
=
form
.
name
;
this
.
file
=
form
.
file
;
this
.
line
=
form
.
line
;
this
.
timestamp
=
form
.
timestamp
;
this
.
callerPreview
=
form
.
callerPreview
;
this
.
argsPreview
=
form
.
argsPreview
;
this
.
resultPreview
=
form
.
resultPreview
;
}
}
)
;
var
CallWatcherActor
=
exports
.
CallWatcherActor
=
protocol
.
ActorClass
(
{
typeName
:
"
call
-
watcher
"
initialize
:
function
(
conn
tabActor
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
tabActor
=
tabActor
;
this
.
_onGlobalCreated
=
this
.
_onGlobalCreated
.
bind
(
this
)
;
this
.
_onGlobalDestroyed
=
this
.
_onGlobalDestroyed
.
bind
(
this
)
;
this
.
_onContentFunctionCall
=
this
.
_onContentFunctionCall
.
bind
(
this
)
;
}
destroy
:
function
(
conn
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
conn
)
;
this
.
finalize
(
)
;
}
events
:
{
"
call
"
:
{
type
:
"
call
"
function
:
Arg
(
0
"
function
-
call
"
)
}
}
onCall
:
null
setup
:
method
(
function
(
{
tracedGlobals
tracedFunctions
startRecording
performReload
holdWeak
storeCalls
}
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
this
.
_timestampEpoch
=
0
;
this
.
_functionCalls
=
[
]
;
this
.
_tracedGlobals
=
tracedGlobals
|
|
[
]
;
this
.
_tracedFunctions
=
tracedFunctions
|
|
[
]
;
this
.
_holdWeak
=
!
!
holdWeak
;
this
.
_storeCalls
=
!
!
storeCalls
;
on
(
this
.
tabActor
"
window
-
ready
"
this
.
_onGlobalCreated
)
;
on
(
this
.
tabActor
"
window
-
destroyed
"
this
.
_onGlobalDestroyed
)
;
if
(
startRecording
)
{
this
.
resumeRecording
(
)
;
}
if
(
performReload
)
{
this
.
tabActor
.
window
.
location
.
reload
(
)
;
}
}
{
request
:
{
tracedGlobals
:
Option
(
0
"
nullable
:
array
:
string
"
)
tracedFunctions
:
Option
(
0
"
nullable
:
array
:
string
"
)
startRecording
:
Option
(
0
"
boolean
"
)
performReload
:
Option
(
0
"
boolean
"
)
holdWeak
:
Option
(
0
"
boolean
"
)
storeCalls
:
Option
(
0
"
boolean
"
)
}
oneway
:
true
}
)
finalize
:
method
(
function
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
false
;
this
.
_finalized
=
true
;
off
(
this
.
tabActor
"
window
-
ready
"
this
.
_onGlobalCreated
)
;
off
(
this
.
tabActor
"
window
-
destroyed
"
this
.
_onGlobalDestroyed
)
;
this
.
_tracedGlobals
=
null
;
this
.
_tracedFunctions
=
null
;
}
{
oneway
:
true
}
)
isRecording
:
method
(
function
(
)
{
return
this
.
_recording
;
}
{
response
:
RetVal
(
"
boolean
"
)
}
)
initTimestampEpoch
:
method
(
function
(
)
{
this
.
_timestampEpoch
=
this
.
tabActor
.
window
.
performance
.
now
(
)
;
}
)
resumeRecording
:
method
(
function
(
)
{
this
.
_recording
=
true
;
}
)
pauseRecording
:
method
(
function
(
)
{
this
.
_recording
=
false
;
return
this
.
_functionCalls
;
}
{
response
:
{
calls
:
RetVal
(
"
array
:
function
-
call
"
)
}
}
)
eraseRecording
:
method
(
function
(
)
{
this
.
_functionCalls
=
[
]
;
}
)
_onGlobalCreated
:
function
(
{
window
id
isTopLevel
}
)
{
if
(
!
isTopLevel
)
{
return
;
}
let
self
=
this
;
this
.
_tracedWindowId
=
id
;
let
unwrappedWindow
=
XPCNativeWrapper
.
unwrap
(
window
)
;
let
callback
=
this
.
_onContentFunctionCall
;
for
(
let
global
of
this
.
_tracedGlobals
)
{
let
prototype
=
unwrappedWindow
[
global
]
.
prototype
;
let
properties
=
Object
.
keys
(
prototype
)
;
properties
.
forEach
(
name
=
>
overrideSymbol
(
global
prototype
name
callback
)
)
;
}
for
(
let
name
of
this
.
_tracedFunctions
)
{
overrideSymbol
(
"
window
"
unwrappedWindow
name
callback
)
;
}
function
overrideSymbol
(
global
target
name
callback
)
{
let
propertyDescriptor
=
Object
.
getOwnPropertyDescriptor
(
target
name
)
;
if
(
propertyDescriptor
.
get
|
|
propertyDescriptor
.
set
)
{
overrideAccessor
(
global
target
name
propertyDescriptor
callback
)
;
return
;
}
if
(
propertyDescriptor
.
writable
&
&
typeof
propertyDescriptor
.
value
=
=
"
function
"
)
{
overrideFunction
(
global
target
name
propertyDescriptor
callback
)
;
return
;
}
}
function
overrideFunction
(
global
target
name
descriptor
callback
)
{
let
originalFunc
=
Cu
.
unwaiveXrays
(
target
[
name
]
)
;
Cu
.
exportFunction
(
function
(
.
.
.
args
)
{
let
result
;
try
{
result
=
Cu
.
waiveXrays
(
originalFunc
.
apply
(
this
args
)
)
;
}
catch
(
e
)
{
throw
createContentError
(
e
unwrappedWindow
)
;
}
if
(
self
.
_recording
)
{
let
type
=
CallWatcherFront
.
METHOD_FUNCTION
;
let
stack
=
getStack
(
name
)
;
let
timestamp
=
self
.
tabActor
.
window
.
performance
.
now
(
)
-
self
.
_timestampEpoch
;
callback
(
unwrappedWindow
global
this
type
name
stack
timestamp
args
result
)
;
}
return
result
;
}
target
{
defineAs
:
name
}
)
;
Object
.
defineProperty
(
target
name
{
configurable
:
descriptor
.
configurable
enumerable
:
descriptor
.
enumerable
writable
:
true
}
)
;
}
function
overrideAccessor
(
global
target
name
descriptor
callback
)
{
let
originalGetter
=
Cu
.
unwaiveXrays
(
target
.
__lookupGetter__
(
name
)
)
;
let
originalSetter
=
Cu
.
unwaiveXrays
(
target
.
__lookupSetter__
(
name
)
)
;
Object
.
defineProperty
(
target
name
{
get
:
function
(
.
.
.
args
)
{
if
(
!
originalGetter
)
return
undefined
;
let
result
=
Cu
.
waiveXrays
(
originalGetter
.
apply
(
this
args
)
)
;
if
(
self
.
_recording
)
{
let
type
=
CallWatcherFront
.
GETTER_FUNCTION
;
let
stack
=
getStack
(
name
)
;
let
timestamp
=
self
.
tabActor
.
window
.
performance
.
now
(
)
-
self
.
_timestampEpoch
;
callback
(
unwrappedWindow
global
this
type
name
stack
timestamp
args
result
)
;
}
return
result
;
}
set
:
function
(
.
.
.
args
)
{
if
(
!
originalSetter
)
return
;
originalSetter
.
apply
(
this
args
)
;
if
(
self
.
_recording
)
{
let
type
=
CallWatcherFront
.
SETTER_FUNCTION
;
let
stack
=
getStack
(
name
)
;
let
timestamp
=
self
.
tabActor
.
window
.
performance
.
now
(
)
-
self
.
_timestampEpoch
;
callback
(
unwrappedWindow
global
this
type
name
stack
timestamp
args
undefined
)
;
}
}
configurable
:
descriptor
.
configurable
enumerable
:
descriptor
.
enumerable
}
)
;
}
function
getStack
(
caller
)
{
try
{
throw
new
Error
(
)
;
}
catch
(
e
)
{
var
stack
=
e
.
stack
;
}
let
calls
=
[
]
;
let
callIndex
=
0
;
let
currNewLinePivot
=
stack
.
indexOf
(
"
\
n
"
)
+
1
;
let
nextNewLinePivot
=
stack
.
indexOf
(
"
\
n
"
currNewLinePivot
)
;
while
(
nextNewLinePivot
>
0
)
{
let
nameDelimiterIndex
=
stack
.
indexOf
(
"
"
currNewLinePivot
)
;
let
columnDelimiterIndex
=
stack
.
lastIndexOf
(
"
:
"
nextNewLinePivot
-
1
)
;
let
lineDelimiterIndex
=
stack
.
lastIndexOf
(
"
:
"
columnDelimiterIndex
-
1
)
;
if
(
!
calls
[
callIndex
]
)
{
calls
[
callIndex
]
=
{
name
:
"
"
file
:
"
"
line
:
0
}
;
}
if
(
!
calls
[
callIndex
+
1
]
)
{
calls
[
callIndex
+
1
]
=
{
name
:
"
"
file
:
"
"
line
:
0
}
;
}
if
(
callIndex
>
0
)
{
let
file
=
stack
.
substring
(
nameDelimiterIndex
+
1
lineDelimiterIndex
)
;
let
line
=
stack
.
substring
(
lineDelimiterIndex
+
1
columnDelimiterIndex
)
;
let
name
=
stack
.
substring
(
currNewLinePivot
nameDelimiterIndex
)
;
calls
[
callIndex
]
.
name
=
name
;
calls
[
callIndex
-
1
]
.
file
=
file
;
calls
[
callIndex
-
1
]
.
line
=
line
;
}
else
{
calls
[
0
]
.
name
=
caller
;
}
currNewLinePivot
=
nextNewLinePivot
+
1
;
nextNewLinePivot
=
stack
.
indexOf
(
"
\
n
"
currNewLinePivot
)
;
callIndex
+
+
;
}
return
calls
;
}
}
_onGlobalDestroyed
:
function
(
{
window
id
isTopLevel
}
)
{
if
(
this
.
_tracedWindowId
=
=
id
)
{
this
.
pauseRecording
(
)
;
this
.
eraseRecording
(
)
;
this
.
_timestampEpoch
=
0
;
}
}
_onContentFunctionCall
:
function
(
.
.
.
details
)
{
if
(
this
.
_finalized
)
{
return
;
}
let
functionCall
=
new
FunctionCallActor
(
this
.
conn
details
this
.
_holdWeak
)
;
if
(
this
.
_storeCalls
)
{
this
.
_functionCalls
.
push
(
functionCall
)
;
}
if
(
this
.
onCall
)
{
this
.
onCall
(
functionCall
)
;
}
else
{
emit
(
this
"
call
"
functionCall
)
;
}
}
}
)
;
var
CallWatcherFront
=
exports
.
CallWatcherFront
=
protocol
.
FrontClass
(
CallWatcherActor
{
initialize
:
function
(
client
{
callWatcherActor
}
)
{
protocol
.
Front
.
prototype
.
initialize
.
call
(
this
client
{
actor
:
callWatcherActor
}
)
;
this
.
manage
(
this
)
;
}
}
)
;
CallWatcherFront
.
METHOD_FUNCTION
=
0
;
CallWatcherFront
.
GETTER_FUNCTION
=
1
;
CallWatcherFront
.
SETTER_FUNCTION
=
2
;
CallWatcherFront
.
KNOWN_METHODS
=
{
}
;
CallWatcherFront
.
KNOWN_METHODS
[
"
CanvasRenderingContext2D
"
]
=
{
asyncDrawXULElement
:
{
enums
:
new
Set
(
[
6
]
)
}
drawWindow
:
{
enums
:
new
Set
(
[
6
]
)
}
}
;
CallWatcherFront
.
KNOWN_METHODS
[
"
WebGLRenderingContext
"
]
=
{
activeTexture
:
{
enums
:
new
Set
(
[
0
]
)
}
bindBuffer
:
{
enums
:
new
Set
(
[
0
]
)
}
bindFramebuffer
:
{
enums
:
new
Set
(
[
0
]
)
}
bindRenderbuffer
:
{
enums
:
new
Set
(
[
0
]
)
}
bindTexture
:
{
enums
:
new
Set
(
[
0
]
)
}
blendEquation
:
{
enums
:
new
Set
(
[
0
]
)
}
blendEquationSeparate
:
{
enums
:
new
Set
(
[
0
1
]
)
}
blendFunc
:
{
enums
:
new
Set
(
[
0
1
]
)
}
blendFuncSeparate
:
{
enums
:
new
Set
(
[
0
1
2
3
]
)
}
bufferData
:
{
enums
:
new
Set
(
[
0
1
2
]
)
}
bufferSubData
:
{
enums
:
new
Set
(
[
0
1
]
)
}
checkFramebufferStatus
:
{
enums
:
new
Set
(
[
0
]
)
}
clear
:
{
enums
:
new
Set
(
[
0
]
)
}
compressedTexImage2D
:
{
enums
:
new
Set
(
[
0
2
]
)
}
compressedTexSubImage2D
:
{
enums
:
new
Set
(
[
0
6
]
)
}
copyTexImage2D
:
{
enums
:
new
Set
(
[
0
2
]
)
}
copyTexSubImage2D
:
{
enums
:
new
Set
(
[
0
]
)
}
createShader
:
{
enums
:
new
Set
(
[
0
]
)
}
cullFace
:
{
enums
:
new
Set
(
[
0
]
)
}
depthFunc
:
{
enums
:
new
Set
(
[
0
]
)
}
disable
:
{
enums
:
new
Set
(
[
0
]
)
}
drawArrays
:
{
enums
:
new
Set
(
[
0
]
)
}
drawElements
:
{
enums
:
new
Set
(
[
0
2
]
)
}
enable
:
{
enums
:
new
Set
(
[
0
]
)
}
framebufferRenderbuffer
:
{
enums
:
new
Set
(
[
0
1
2
]
)
}
framebufferTexture2D
:
{
enums
:
new
Set
(
[
0
1
2
]
)
}
frontFace
:
{
enums
:
new
Set
(
[
0
]
)
}
generateMipmap
:
{
enums
:
new
Set
(
[
0
]
)
}
getBufferParameter
:
{
enums
:
new
Set
(
[
0
1
]
)
}
getParameter
:
{
enums
:
new
Set
(
[
0
]
)
}
getFramebufferAttachmentParameter
:
{
enums
:
new
Set
(
[
0
1
2
]
)
}
getProgramParameter
:
{
enums
:
new
Set
(
[
1
]
)
}
getRenderbufferParameter
:
{
enums
:
new
Set
(
[
0
1
]
)
}
getShaderParameter
:
{
enums
:
new
Set
(
[
1
]
)
}
getShaderPrecisionFormat
:
{
enums
:
new
Set
(
[
0
1
]
)
}
getTexParameter
:
{
enums
:
new
Set
(
[
0
1
]
)
}
getVertexAttrib
:
{
enums
:
new
Set
(
[
1
]
)
}
getVertexAttribOffset
:
{
enums
:
new
Set
(
[
1
]
)
}
hint
:
{
enums
:
new
Set
(
[
0
1
]
)
}
isEnabled
:
{
enums
:
new
Set
(
[
0
]
)
}
pixelStorei
:
{
enums
:
new
Set
(
[
0
]
)
}
readPixels
:
{
enums
:
new
Set
(
[
4
5
]
)
}
renderbufferStorage
:
{
enums
:
new
Set
(
[
0
1
]
)
}
stencilFunc
:
{
enums
:
new
Set
(
[
0
]
)
}
stencilFuncSeparate
:
{
enums
:
new
Set
(
[
0
1
]
)
}
stencilMaskSeparate
:
{
enums
:
new
Set
(
[
0
]
)
}
stencilOp
:
{
enums
:
new
Set
(
[
0
1
2
]
)
}
stencilOpSeparate
:
{
enums
:
new
Set
(
[
0
1
2
3
]
)
}
texImage2D
:
{
enums
:
args
=
>
args
.
length
>
6
?
new
Set
(
[
0
2
6
7
]
)
:
new
Set
(
[
0
2
3
4
]
)
}
texParameterf
:
{
enums
:
new
Set
(
[
0
1
]
)
}
texParameteri
:
{
enums
:
new
Set
(
[
0
1
2
]
)
}
texSubImage2D
:
{
enums
:
args
=
>
args
.
length
=
=
=
9
?
new
Set
(
[
0
6
7
]
)
:
new
Set
(
[
0
4
5
]
)
}
vertexAttribPointer
:
{
enums
:
new
Set
(
[
2
]
)
}
}
;
var
gEnumRegex
=
/
^
[
A
-
Z
]
[
A
-
Z0
-
9_
]
+
/
;
var
gEnumsLookupTable
=
{
}
;
var
INVALID_ENUMS
=
[
"
INVALID_ENUM
"
"
NO_ERROR
"
"
INVALID_VALUE
"
"
OUT_OF_MEMORY
"
"
NONE
"
]
;
function
getBitToEnumValue
(
type
object
arg
)
{
let
table
=
gEnumsLookupTable
[
type
]
;
if
(
!
table
)
{
table
=
gEnumsLookupTable
[
type
]
=
{
}
;
for
(
let
key
in
object
)
{
if
(
key
.
match
(
gEnumRegex
)
)
{
table
[
object
[
key
]
]
=
key
;
}
}
}
if
(
table
[
arg
]
)
{
return
table
[
arg
]
;
}
let
flags
=
[
]
;
for
(
let
flag
in
table
)
{
if
(
INVALID_ENUMS
.
indexOf
(
table
[
flag
]
)
!
=
=
-
1
)
{
continue
;
}
flag
=
flag
|
0
;
if
(
flag
&
&
(
arg
&
flag
)
=
=
=
flag
)
{
flags
.
push
(
table
[
flag
]
)
;
}
}
return
table
[
arg
]
=
flags
.
join
(
"
|
"
)
|
|
arg
;
}
function
createContentError
(
e
win
)
{
let
{
message
name
stack
}
=
e
;
let
parsedStack
=
parseStack
(
stack
)
;
let
{
fileName
lineNumber
columnNumber
}
=
parsedStack
[
parsedStack
.
length
-
1
]
;
let
error
;
let
isDOMException
=
e
instanceof
Ci
.
nsIDOMDOMException
;
let
constructor
=
isDOMException
?
win
.
DOMException
:
(
win
[
e
.
name
]
|
|
win
.
Error
)
;
if
(
isDOMException
)
{
error
=
new
constructor
(
message
name
)
;
Object
.
defineProperties
(
error
{
code
:
{
value
:
e
.
code
}
columnNumber
:
{
value
:
0
}
filename
:
{
value
:
fileName
}
lineNumber
:
{
value
:
lineNumber
}
result
:
{
value
:
e
.
result
}
stack
:
{
value
:
serializeStack
(
parsedStack
)
}
}
)
;
}
else
{
error
=
new
constructor
(
message
fileName
lineNumber
)
;
Object
.
defineProperty
(
error
"
columnNumber
"
{
value
:
columnNumber
}
)
;
}
return
error
;
}
