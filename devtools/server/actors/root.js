"
use
strict
"
;
const
{
Actor
Pool
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
rootSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
root
.
js
"
)
;
const
{
LazyPool
createExtraActors
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
/
lazy
-
pool
.
js
"
)
;
const
{
DevToolsServer
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
devtools
-
server
.
js
"
)
;
const
Resources
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
index
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
ProcessDescriptorActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
descriptors
/
process
.
js
"
true
)
;
class
RootActor
extends
Actor
{
constructor
(
conn
parameters
)
{
super
(
conn
rootSpec
)
;
this
.
_parameters
=
parameters
;
this
.
_onTabListChanged
=
this
.
onTabListChanged
.
bind
(
this
)
;
this
.
_onAddonListChanged
=
this
.
onAddonListChanged
.
bind
(
this
)
;
this
.
_onWorkerListChanged
=
this
.
onWorkerListChanged
.
bind
(
this
)
;
this
.
_onServiceWorkerRegistrationListChanged
=
this
.
onServiceWorkerRegistrationListChanged
.
bind
(
this
)
;
this
.
_onProcessListChanged
=
this
.
onProcessListChanged
.
bind
(
this
)
;
this
.
_extraActors
=
{
}
;
this
.
_globalActorPool
=
new
LazyPool
(
this
.
conn
)
;
this
.
applicationType
=
"
browser
"
;
const
supportedResources
=
{
}
;
for
(
const
resourceType
in
Resources
.
RootResources
)
{
supportedResources
[
resourceType
]
=
true
;
}
this
.
traits
=
{
networkMonitor
:
true
resources
:
supportedResources
workerConsoleApiMessagesDispatchedToMainThread
:
Services
.
prefs
?
Services
.
prefs
.
getBoolPref
(
"
dom
.
worker
.
console
.
dispatch_events_to_main_thread
"
)
:
true
}
;
}
sayHello
(
)
{
return
{
from
:
this
.
actorID
applicationType
:
this
.
applicationType
testConnectionPrefix
:
this
.
conn
.
prefix
traits
:
this
.
traits
}
;
}
forwardingCancelled
(
prefix
)
{
return
{
from
:
this
.
actorID
type
:
"
forwardingCancelled
"
prefix
}
;
}
destroy
(
)
{
Resources
.
unwatchAllResources
(
this
)
;
super
.
destroy
(
)
;
if
(
this
.
_parameters
.
tabList
)
{
this
.
_parameters
.
tabList
.
destroy
(
)
;
}
if
(
this
.
_parameters
.
addonList
)
{
this
.
_parameters
.
addonList
.
onListChanged
=
null
;
}
if
(
this
.
_parameters
.
workerList
)
{
this
.
_parameters
.
workerList
.
destroy
(
)
;
}
if
(
this
.
_parameters
.
serviceWorkerRegistrationList
)
{
this
.
_parameters
.
serviceWorkerRegistrationList
.
onListChanged
=
null
;
}
if
(
this
.
_parameters
.
processList
)
{
this
.
_parameters
.
processList
.
onListChanged
=
null
;
}
if
(
typeof
this
.
_parameters
.
onShutdown
=
=
=
"
function
"
)
{
this
.
_parameters
.
onShutdown
(
)
;
}
if
(
this
.
_tabDescriptorActorPool
)
{
this
.
_tabDescriptorActorPool
.
destroy
(
)
;
}
if
(
this
.
_processDescriptorActorPool
)
{
this
.
_processDescriptorActorPool
.
destroy
(
)
;
}
if
(
this
.
_globalActorPool
)
{
this
.
_globalActorPool
.
destroy
(
)
;
}
if
(
this
.
_addonTargetActorPool
)
{
this
.
_addonTargetActorPool
.
destroy
(
)
;
}
if
(
this
.
_workerDescriptorActorPool
)
{
this
.
_workerDescriptorActorPool
.
destroy
(
)
;
}
if
(
this
.
_frameDescriptorActorPool
)
{
this
.
_frameDescriptorActorPool
.
destroy
(
)
;
}
if
(
this
.
_serviceWorkerRegistrationActorPool
)
{
this
.
_serviceWorkerRegistrationActorPool
.
destroy
(
)
;
}
this
.
_extraActors
=
null
;
this
.
_tabDescriptorActorPool
=
null
;
this
.
_globalActorPool
=
null
;
this
.
_parameters
=
null
;
}
connect
(
{
frontendVersion
}
)
{
}
getRoot
(
)
{
if
(
!
this
.
_globalActorPool
)
{
this
.
_globalActorPool
=
new
LazyPool
(
this
.
conn
)
;
}
const
actors
=
createExtraActors
(
this
.
_parameters
.
globalActorFactories
this
.
_globalActorPool
this
)
;
return
actors
;
}
async
listTabs
(
)
{
const
tabList
=
this
.
_parameters
.
tabList
;
if
(
!
tabList
)
{
throw
{
error
:
"
noTabs
"
message
:
"
This
root
actor
has
no
browser
tabs
.
"
}
;
}
tabList
.
onListChanged
=
this
.
_onTabListChanged
;
const
newActorPool
=
new
Pool
(
this
.
conn
"
listTabs
-
tab
-
descriptors
"
)
;
const
tabDescriptorActors
=
await
tabList
.
getList
(
)
;
for
(
const
tabDescriptorActor
of
tabDescriptorActors
)
{
newActorPool
.
manage
(
tabDescriptorActor
)
;
}
if
(
this
.
_tabDescriptorActorPool
)
{
this
.
_tabDescriptorActorPool
.
destroy
(
)
;
}
this
.
_tabDescriptorActorPool
=
newActorPool
;
return
tabDescriptorActors
;
}
async
getTab
(
{
browserId
}
)
{
const
tabList
=
this
.
_parameters
.
tabList
;
if
(
!
tabList
)
{
throw
{
error
:
"
noTabs
"
message
:
"
This
root
actor
has
no
browser
tabs
.
"
}
;
}
if
(
!
this
.
_tabDescriptorActorPool
)
{
this
.
_tabDescriptorActorPool
=
new
Pool
(
this
.
conn
"
getTab
-
tab
-
descriptors
"
)
;
}
let
descriptorActor
;
try
{
descriptorActor
=
await
tabList
.
getTab
(
{
browserId
}
)
;
}
catch
(
error
)
{
if
(
error
.
error
)
{
throw
error
;
}
throw
{
error
:
"
noTab
"
message
:
"
Unexpected
error
while
calling
getTab
(
)
:
"
+
error
}
;
}
descriptorActor
.
parentID
=
this
.
actorID
;
this
.
_tabDescriptorActorPool
.
manage
(
descriptorActor
)
;
return
descriptorActor
;
}
onTabListChanged
(
)
{
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
tabListChanged
"
}
)
;
this
.
_parameters
.
tabList
.
onListChanged
=
null
;
}
async
listAddons
(
option
)
{
const
addonList
=
this
.
_parameters
.
addonList
;
if
(
!
addonList
)
{
throw
{
error
:
"
noAddons
"
message
:
"
This
root
actor
has
no
browser
addons
.
"
}
;
}
addonList
.
onListChanged
=
this
.
_onAddonListChanged
;
const
addonTargetActors
=
await
addonList
.
getList
(
)
;
const
addonTargetActorPool
=
new
Pool
(
this
.
conn
"
addon
-
descriptors
"
)
;
for
(
const
addonTargetActor
of
addonTargetActors
)
{
if
(
option
.
iconDataURL
)
{
await
addonTargetActor
.
loadIconDataURL
(
)
;
}
addonTargetActorPool
.
manage
(
addonTargetActor
)
;
}
if
(
this
.
_addonTargetActorPool
)
{
this
.
_addonTargetActorPool
.
destroy
(
)
;
}
this
.
_addonTargetActorPool
=
addonTargetActorPool
;
return
addonTargetActors
;
}
onAddonListChanged
(
)
{
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
addonListChanged
"
}
)
;
this
.
_parameters
.
addonList
.
onListChanged
=
null
;
}
listWorkers
(
)
{
const
workerList
=
this
.
_parameters
.
workerList
;
if
(
!
workerList
)
{
throw
{
error
:
"
noWorkers
"
message
:
"
This
root
actor
has
no
workers
.
"
}
;
}
workerList
.
onListChanged
=
this
.
_onWorkerListChanged
;
return
workerList
.
getList
(
)
.
then
(
actors
=
>
{
const
pool
=
new
Pool
(
this
.
conn
"
worker
-
targets
"
)
;
for
(
const
actor
of
actors
)
{
pool
.
manage
(
actor
)
;
}
if
(
this
.
_workerDescriptorActorPool
)
{
this
.
_workerDescriptorActorPool
.
destroy
(
)
;
}
this
.
_workerDescriptorActorPool
=
pool
;
return
{
workers
:
actors
}
;
}
)
;
}
onWorkerListChanged
(
)
{
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
workerListChanged
"
}
)
;
this
.
_parameters
.
workerList
.
onListChanged
=
null
;
}
listServiceWorkerRegistrations
(
)
{
const
registrationList
=
this
.
_parameters
.
serviceWorkerRegistrationList
;
if
(
!
registrationList
)
{
throw
{
error
:
"
noServiceWorkerRegistrations
"
message
:
"
This
root
actor
has
no
service
worker
registrations
.
"
}
;
}
registrationList
.
onListChanged
=
this
.
_onServiceWorkerRegistrationListChanged
;
return
registrationList
.
getList
(
)
.
then
(
actors
=
>
{
const
pool
=
new
Pool
(
this
.
conn
"
service
-
workers
-
registrations
"
)
;
for
(
const
actor
of
actors
)
{
pool
.
manage
(
actor
)
;
}
if
(
this
.
_serviceWorkerRegistrationActorPool
)
{
this
.
_serviceWorkerRegistrationActorPool
.
destroy
(
)
;
}
this
.
_serviceWorkerRegistrationActorPool
=
pool
;
return
{
registrations
:
actors
}
;
}
)
;
}
onServiceWorkerRegistrationListChanged
(
)
{
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
serviceWorkerRegistrationListChanged
"
}
)
;
this
.
_parameters
.
serviceWorkerRegistrationList
.
onListChanged
=
null
;
}
listProcesses
(
)
{
const
{
processList
}
=
this
.
_parameters
;
if
(
!
processList
)
{
throw
{
error
:
"
noProcesses
"
message
:
"
This
root
actor
has
no
processes
.
"
}
;
}
processList
.
onListChanged
=
this
.
_onProcessListChanged
;
const
processes
=
processList
.
getList
(
)
;
const
pool
=
new
Pool
(
this
.
conn
"
process
-
descriptors
"
)
;
for
(
const
metadata
of
processes
)
{
let
processDescriptor
=
this
.
_getKnownDescriptor
(
metadata
.
id
this
.
_processDescriptorActorPool
)
;
if
(
!
processDescriptor
)
{
processDescriptor
=
new
ProcessDescriptorActor
(
this
.
conn
metadata
)
;
}
pool
.
manage
(
processDescriptor
)
;
}
if
(
this
.
_processDescriptorActorPool
)
{
this
.
_processDescriptorActorPool
.
destroy
(
)
;
}
this
.
_processDescriptorActorPool
=
pool
;
return
[
.
.
.
this
.
_processDescriptorActorPool
.
poolChildren
(
)
]
;
}
onProcessListChanged
(
)
{
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
processListChanged
"
}
)
;
this
.
_parameters
.
processList
.
onListChanged
=
null
;
}
async
getProcess
(
id
)
{
if
(
!
DevToolsServer
.
allowChromeProcess
)
{
throw
{
error
:
"
forbidden
"
message
:
"
You
are
not
allowed
to
debug
chrome
.
"
}
;
}
if
(
typeof
id
!
=
"
number
"
)
{
throw
{
error
:
"
wrongParameter
"
message
:
"
getProcess
requires
a
valid
id
attribute
.
"
}
;
}
this
.
_processDescriptorActorPool
=
this
.
_processDescriptorActorPool
|
|
new
Pool
(
this
.
conn
"
process
-
descriptors
"
)
;
let
processDescriptor
=
this
.
_getKnownDescriptor
(
id
this
.
_processDescriptorActorPool
)
;
if
(
!
processDescriptor
)
{
const
options
=
{
id
parent
:
id
=
=
=
0
}
;
processDescriptor
=
new
ProcessDescriptorActor
(
this
.
conn
options
)
;
this
.
_processDescriptorActorPool
.
manage
(
processDescriptor
)
;
}
return
processDescriptor
;
}
_getKnownDescriptor
(
id
pool
)
{
if
(
!
pool
)
{
return
null
;
}
for
(
const
descriptor
of
pool
.
poolChildren
(
)
)
{
if
(
descriptor
.
id
=
=
=
id
)
{
return
descriptor
;
}
}
return
null
;
}
removeActorByName
(
name
)
{
if
(
name
in
this
.
_extraActors
)
{
const
actor
=
this
.
_extraActors
[
name
]
;
if
(
this
.
_globalActorPool
.
has
(
actor
.
actorID
)
)
{
actor
.
destroy
(
)
;
}
if
(
this
.
_tabDescriptorActorPool
)
{
for
(
const
tab
in
this
.
_tabDescriptorActorPool
.
poolChildren
(
)
)
{
tab
.
removeActorByName
(
name
)
;
}
}
delete
this
.
_extraActors
[
name
]
;
}
}
async
watchResources
(
resourceTypes
)
{
await
Resources
.
watchResources
(
this
resourceTypes
)
;
}
unwatchResources
(
resourceTypes
)
{
Resources
.
unwatchResources
(
this
resourceTypes
)
;
}
clearResources
(
resourceTypes
)
{
Resources
.
clearResources
(
this
resourceTypes
)
;
}
notifyResources
(
updateType
resourceType
resources
)
{
if
(
resources
.
length
=
=
=
0
)
{
return
;
}
switch
(
updateType
)
{
case
"
available
"
:
this
.
emit
(
resources
-
available
-
array
[
[
resourceType
resources
]
]
)
;
break
;
case
"
updated
"
:
this
.
emit
(
resources
-
updated
-
array
[
[
resourceType
resources
]
]
)
;
break
;
case
"
destroyed
"
:
this
.
emit
(
resources
-
destroyed
-
array
[
[
resourceType
resources
]
]
)
;
break
;
default
:
throw
new
Error
(
"
Unsupported
update
type
:
"
+
updateType
)
;
}
}
}
exports
.
RootActor
=
RootActor
;
