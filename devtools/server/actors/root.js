"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Pool
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
LazyPool
createExtraActors
}
=
require
(
"
devtools
/
shared
/
protocol
/
lazy
-
pool
"
)
;
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
debugger
-
server
"
)
;
loader
.
lazyRequireGetter
(
this
"
ChromeWindowTargetActor
"
"
devtools
/
server
/
actors
/
targets
/
chrome
-
window
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ProcessDescriptorActor
"
"
devtools
/
server
/
actors
/
descriptors
/
process
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
FrameDescriptorActor
"
"
devtools
/
server
/
actors
/
descriptors
/
frame
"
true
)
;
function
RootActor
(
connection
parameters
)
{
this
.
conn
=
connection
;
this
.
_parameters
=
parameters
;
this
.
_onTabListChanged
=
this
.
onTabListChanged
.
bind
(
this
)
;
this
.
_onAddonListChanged
=
this
.
onAddonListChanged
.
bind
(
this
)
;
this
.
_onWorkerListChanged
=
this
.
onWorkerListChanged
.
bind
(
this
)
;
this
.
_onServiceWorkerRegistrationListChanged
=
this
.
onServiceWorkerRegistrationListChanged
.
bind
(
this
)
;
this
.
_onProcessListChanged
=
this
.
onProcessListChanged
.
bind
(
this
)
;
this
.
_extraActors
=
{
}
;
this
.
_globalActorPool
=
new
LazyPool
(
this
.
conn
)
;
}
RootActor
.
prototype
=
{
constructor
:
RootActor
applicationType
:
"
browser
"
traits
:
{
sources
:
true
networkMonitor
:
true
storageInspector
:
true
wasmBinarySource
:
true
bulk
:
true
webConsoleCommands
:
true
get
allowChromeProcess
(
)
{
return
DebuggerServer
.
allowChromeProcess
;
}
heapSnapshots
:
true
perfActorVersion
:
1
watchpoints
:
true
}
sayHello
:
function
(
)
{
return
{
from
:
this
.
actorID
applicationType
:
this
.
applicationType
testConnectionPrefix
:
this
.
conn
.
prefix
traits
:
this
.
traits
}
;
}
forwardingCancelled
:
function
(
prefix
)
{
return
{
from
:
this
.
actorID
type
:
"
forwardingCancelled
"
prefix
}
;
}
destroy
:
function
(
)
{
if
(
this
.
_parameters
.
tabList
)
{
this
.
_parameters
.
tabList
.
destroy
(
)
;
}
if
(
this
.
_parameters
.
addonList
)
{
this
.
_parameters
.
addonList
.
onListChanged
=
null
;
}
if
(
this
.
_parameters
.
workerList
)
{
this
.
_parameters
.
workerList
.
onListChanged
=
null
;
}
if
(
this
.
_parameters
.
serviceWorkerRegistrationList
)
{
this
.
_parameters
.
serviceWorkerRegistrationList
.
onListChanged
=
null
;
}
if
(
this
.
_parameters
.
processList
)
{
this
.
_parameters
.
processList
.
onListChanged
=
null
;
}
if
(
typeof
this
.
_parameters
.
onShutdown
=
=
=
"
function
"
)
{
this
.
_parameters
.
onShutdown
(
)
;
}
if
(
this
.
_tabTargetActorPool
)
{
this
.
_tabTargetActorPool
.
destroy
(
)
;
}
if
(
this
.
_processDescriptorActorPool
)
{
this
.
_processDescriptorActorPool
.
destroy
(
)
;
}
if
(
this
.
_globalActorPool
)
{
this
.
_globalActorPool
.
destroy
(
)
;
}
if
(
this
.
_chromeWindowActorPool
)
{
this
.
_chromeWindowActorPool
.
destroy
(
)
;
}
if
(
this
.
_addonTargetActorPool
)
{
this
.
_addonTargetActorPool
.
destroy
(
)
;
}
if
(
this
.
_workerTargetActorPool
)
{
this
.
_workerTargetActorPool
.
destroy
(
)
;
}
if
(
this
.
_frameDescriptorActorPool
)
{
this
.
_frameDescriptorActorPool
.
destroy
(
)
;
}
if
(
this
.
_serviceWorkerRegistrationActorPool
)
{
this
.
_serviceWorkerRegistrationActorPool
.
destroy
(
)
;
}
this
.
_extraActors
=
null
;
this
.
conn
=
null
;
this
.
_tabTargetActorPool
=
null
;
this
.
_globalActorPool
=
null
;
this
.
_chromeWindowActorPool
=
null
;
this
.
_parameters
=
null
;
}
onGetRoot
:
function
(
)
{
if
(
!
this
.
_globalActorPool
)
{
this
.
_globalActorPool
=
new
LazyPool
(
this
.
conn
)
;
}
const
actors
=
createExtraActors
(
this
.
_parameters
.
globalActorFactories
this
.
_globalActorPool
this
)
;
return
actors
;
}
onListTabs
:
async
function
(
options
)
{
const
tabList
=
this
.
_parameters
.
tabList
;
if
(
!
tabList
)
{
return
{
from
:
this
.
actorID
error
:
"
noTabs
"
message
:
"
This
root
actor
has
no
browser
tabs
.
"
}
;
}
tabList
.
onListChanged
=
this
.
_onTabListChanged
;
const
newActorPool
=
new
Pool
(
this
.
conn
)
;
const
targetActorList
=
[
]
;
let
selected
;
const
targetActors
=
await
tabList
.
getList
(
options
)
;
for
(
const
targetActor
of
targetActors
)
{
if
(
targetActor
.
exited
)
{
continue
;
}
if
(
targetActor
.
selected
)
{
selected
=
targetActorList
.
length
;
}
targetActor
.
parentID
=
this
.
actorID
;
newActorPool
.
manage
(
targetActor
)
;
targetActorList
.
push
(
targetActor
)
;
}
const
reply
=
this
.
onGetRoot
(
)
;
if
(
this
.
_tabTargetActorPool
)
{
this
.
_tabTargetActorPool
.
destroy
(
)
;
}
this
.
_tabTargetActorPool
=
newActorPool
;
Object
.
assign
(
reply
{
selected
:
selected
|
|
0
tabs
:
targetActorList
.
map
(
actor
=
>
actor
.
form
(
)
)
}
)
;
return
reply
;
}
onGetTab
:
async
function
(
options
)
{
const
tabList
=
this
.
_parameters
.
tabList
;
if
(
!
tabList
)
{
return
{
error
:
"
noTabs
"
message
:
"
This
root
actor
has
no
browser
tabs
.
"
}
;
}
if
(
!
this
.
_tabTargetActorPool
)
{
this
.
_tabTargetActorPool
=
new
Pool
(
this
.
conn
)
;
}
let
targetActor
;
try
{
targetActor
=
await
tabList
.
getTab
(
options
{
forceUnzombify
:
true
}
)
;
}
catch
(
error
)
{
if
(
error
.
error
)
{
return
error
;
}
return
{
error
:
"
noTab
"
message
:
"
Unexpected
error
while
calling
getTab
(
)
:
"
+
error
}
;
}
targetActor
.
parentID
=
this
.
actorID
;
this
.
_tabTargetActorPool
.
manage
(
targetActor
)
;
return
{
tab
:
targetActor
.
form
(
)
}
;
}
onGetWindow
:
function
(
{
outerWindowID
}
)
{
if
(
!
DebuggerServer
.
allowChromeProcess
)
{
return
{
from
:
this
.
actorID
error
:
"
forbidden
"
message
:
"
You
are
not
allowed
to
debug
windows
.
"
}
;
}
const
window
=
Services
.
wm
.
getOuterWindowWithId
(
outerWindowID
)
;
if
(
!
window
)
{
return
{
from
:
this
.
actorID
error
:
"
notFound
"
message
:
No
window
found
with
outerWindowID
{
outerWindowID
}
}
;
}
if
(
!
this
.
_chromeWindowActorPool
)
{
this
.
_chromeWindowActorPool
=
new
Pool
(
this
.
conn
)
;
}
const
actor
=
new
ChromeWindowTargetActor
(
this
.
conn
window
)
;
actor
.
parentID
=
this
.
actorID
;
this
.
_chromeWindowActorPool
.
manage
(
actor
)
;
return
{
from
:
this
.
actorID
window
:
actor
.
form
(
)
}
;
}
onTabListChanged
:
function
(
)
{
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
tabListChanged
"
}
)
;
this
.
_parameters
.
tabList
.
onListChanged
=
null
;
}
onListAddons
:
async
function
(
option
)
{
const
addonList
=
this
.
_parameters
.
addonList
;
if
(
!
addonList
)
{
return
{
from
:
this
.
actorID
error
:
"
noAddons
"
message
:
"
This
root
actor
has
no
browser
addons
.
"
}
;
}
addonList
.
onListChanged
=
this
.
_onAddonListChanged
;
const
addonTargetActors
=
await
addonList
.
getList
(
)
;
const
addonTargetActorPool
=
new
Pool
(
this
.
conn
)
;
for
(
const
addonTargetActor
of
addonTargetActors
)
{
if
(
option
.
iconDataURL
)
{
await
addonTargetActor
.
loadIconDataURL
(
)
;
}
addonTargetActorPool
.
manage
(
addonTargetActor
)
;
}
if
(
this
.
_addonTargetActorPool
)
{
this
.
_addonTargetActorPool
.
destroy
(
)
;
}
this
.
_addonTargetActorPool
=
addonTargetActorPool
;
return
{
from
:
this
.
actorID
addons
:
addonTargetActors
.
map
(
addonTargetActor
=
>
addonTargetActor
.
form
(
)
)
}
;
}
onAddonListChanged
:
function
(
)
{
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
addonListChanged
"
}
)
;
this
.
_parameters
.
addonList
.
onListChanged
=
null
;
}
onListWorkers
:
function
(
)
{
const
workerList
=
this
.
_parameters
.
workerList
;
if
(
!
workerList
)
{
return
{
from
:
this
.
actorID
error
:
"
noWorkers
"
message
:
"
This
root
actor
has
no
workers
.
"
}
;
}
workerList
.
onListChanged
=
this
.
_onWorkerListChanged
;
return
workerList
.
getList
(
)
.
then
(
actors
=
>
{
const
pool
=
new
Pool
(
this
.
conn
)
;
for
(
const
actor
of
actors
)
{
pool
.
manage
(
actor
)
;
}
if
(
this
.
_workerTargetActorPool
)
{
this
.
_workerTargetActorPool
.
destroy
(
)
;
}
this
.
_workerTargetActorPool
=
pool
;
return
{
from
:
this
.
actorID
workers
:
actors
.
map
(
actor
=
>
actor
.
form
(
)
)
}
;
}
)
;
}
onWorkerListChanged
:
function
(
)
{
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
workerListChanged
"
}
)
;
this
.
_parameters
.
workerList
.
onListChanged
=
null
;
}
onListServiceWorkerRegistrations
:
function
(
)
{
const
registrationList
=
this
.
_parameters
.
serviceWorkerRegistrationList
;
if
(
!
registrationList
)
{
return
{
from
:
this
.
actorID
error
:
"
noServiceWorkerRegistrations
"
message
:
"
This
root
actor
has
no
service
worker
registrations
.
"
}
;
}
registrationList
.
onListChanged
=
this
.
_onServiceWorkerRegistrationListChanged
;
return
registrationList
.
getList
(
)
.
then
(
actors
=
>
{
const
pool
=
new
Pool
(
this
.
conn
)
;
for
(
const
actor
of
actors
)
{
pool
.
manage
(
actor
)
;
}
if
(
this
.
_serviceWorkerRegistrationActorPool
)
{
this
.
_serviceWorkerRegistrationActorPool
.
destroy
(
)
;
}
this
.
_serviceWorkerRegistrationActorPool
=
pool
;
return
{
from
:
this
.
actorID
registrations
:
actors
.
map
(
actor
=
>
actor
.
form
(
)
)
}
;
}
)
;
}
onServiceWorkerRegistrationListChanged
:
function
(
)
{
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
serviceWorkerRegistrationListChanged
"
}
)
;
this
.
_parameters
.
serviceWorkerRegistrationList
.
onListChanged
=
null
;
}
onListProcesses
:
function
(
)
{
const
{
processList
}
=
this
.
_parameters
;
if
(
!
processList
)
{
return
{
from
:
this
.
actorID
error
:
"
noProcesses
"
message
:
"
This
root
actor
has
no
processes
.
"
}
;
}
processList
.
onListChanged
=
this
.
_onProcessListChanged
;
const
processes
=
processList
.
getList
(
)
;
const
pool
=
new
Pool
(
this
.
conn
)
;
for
(
const
metadata
of
processes
)
{
let
processDescriptor
=
this
.
_getKnownDescriptor
(
metadata
.
id
this
.
_processDescriptorActorPool
)
;
if
(
!
processDescriptor
)
{
processDescriptor
=
new
ProcessDescriptorActor
(
this
.
conn
metadata
)
;
}
pool
.
manage
(
processDescriptor
)
;
}
if
(
this
.
_processDescriptorActorPool
)
{
this
.
_processDescriptorActorPool
.
destroy
(
)
;
}
this
.
_processDescriptorActorPool
=
pool
;
const
processActors
=
[
.
.
.
this
.
_processDescriptorActorPool
.
poolChildren
(
)
]
;
return
{
processes
:
processActors
.
map
(
actor
=
>
actor
.
form
(
)
)
}
;
}
onProcessListChanged
:
function
(
)
{
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
processListChanged
"
}
)
;
this
.
_parameters
.
processList
.
onListChanged
=
null
;
}
async
onGetProcess
(
request
)
{
if
(
!
DebuggerServer
.
allowChromeProcess
)
{
return
{
error
:
"
forbidden
"
message
:
"
You
are
not
allowed
to
debug
chrome
.
"
}
;
}
if
(
"
id
"
in
request
&
&
typeof
request
.
id
!
=
"
number
"
)
{
return
{
error
:
"
wrongParameter
"
message
:
"
getProcess
requires
a
valid
id
attribute
.
"
}
;
}
const
id
=
request
.
id
|
|
0
;
this
.
_processDescriptorActorPool
=
this
.
_processDescriptorActorPool
|
|
new
Pool
(
this
.
conn
)
;
let
processDescriptor
=
this
.
_getKnownDescriptor
(
id
this
.
_processDescriptorActorPool
)
;
if
(
!
processDescriptor
)
{
const
options
=
{
id
parent
:
id
=
=
=
0
}
;
processDescriptor
=
new
ProcessDescriptorActor
(
this
.
conn
options
)
;
this
.
_processDescriptorActorPool
.
manage
(
processDescriptor
)
;
}
return
{
form
:
processDescriptor
.
form
(
)
}
;
}
async
_getChildBrowsingContexts
(
id
)
{
const
window
=
Services
.
wm
.
getMostRecentWindow
(
DebuggerServer
.
chromeWindowType
)
;
if
(
window
&
&
window
.
docShell
.
browsingContext
.
id
=
=
=
id
)
{
return
[
.
.
.
window
.
document
.
querySelectorAll
(
browser
[
remote
=
"
true
"
]
)
]
.
map
(
browser
=
>
browser
.
browsingContext
)
;
}
const
parentBrowsingContext
=
BrowsingContext
.
get
(
id
)
;
return
parentBrowsingContext
.
getChildren
(
)
;
}
async
onListRemoteFrames
(
{
id
}
)
{
const
frames
=
[
]
;
const
contextsToWalk
=
await
this
.
_getChildBrowsingContexts
(
id
)
;
if
(
contextsToWalk
.
length
=
=
0
)
{
return
{
frames
}
;
}
const
pool
=
new
Pool
(
this
.
conn
)
;
while
(
contextsToWalk
.
length
)
{
const
currentContext
=
contextsToWalk
.
pop
(
)
;
let
frameDescriptor
=
this
.
_getKnownDescriptor
(
currentContext
.
id
this
.
_frameDescriptorActorPool
)
;
if
(
!
frameDescriptor
)
{
frameDescriptor
=
new
FrameDescriptorActor
(
this
.
conn
currentContext
)
;
}
pool
.
manage
(
frameDescriptor
)
;
frames
.
push
(
frameDescriptor
)
;
contextsToWalk
.
push
(
.
.
.
currentContext
.
getChildren
(
)
)
;
}
if
(
this
.
_frameDescriptorActorPool
)
{
this
.
_frameDescriptorActorPool
.
destroy
(
)
;
}
this
.
_frameDescriptorActorPool
=
pool
;
return
{
frames
:
frames
.
map
(
f
=
>
f
.
form
(
)
)
}
;
}
_getKnownDescriptor
(
id
pool
)
{
if
(
!
pool
)
{
return
null
;
}
for
(
const
descriptor
of
pool
.
poolChildren
(
)
)
{
if
(
descriptor
.
id
=
=
=
id
)
{
return
descriptor
;
}
}
return
null
;
}
_getParentProcessDescriptor
(
)
{
if
(
!
this
.
_processDescriptorActorPool
)
{
this
.
_processDescriptorActorPool
=
new
Pool
(
this
.
conn
)
;
const
options
=
{
id
:
0
parent
:
true
}
;
const
descriptor
=
new
ProcessDescriptorActor
(
this
.
conn
options
)
;
this
.
_processDescriptorActorPool
.
manage
(
descriptor
)
;
return
descriptor
;
}
for
(
const
descriptor
of
this
.
_processDescriptorActorPool
.
poolChildren
(
)
)
{
if
(
descriptor
.
isParent
)
{
return
descriptor
;
}
}
return
null
;
}
_isParentBrowsingContext
(
id
)
{
const
window
=
Services
.
wm
.
getMostRecentWindow
(
DebuggerServer
.
chromeWindowType
)
;
return
id
=
=
window
.
docShell
.
browsingContext
.
id
;
}
onGetBrowsingContextDescriptor
(
{
id
}
)
{
const
frameDescriptor
=
this
.
_getKnownDescriptor
(
id
this
.
_frameDescriptorActorPool
)
;
if
(
frameDescriptor
)
{
return
frameDescriptor
.
form
(
)
;
}
if
(
this
.
_isParentBrowsingContext
(
id
)
)
{
const
parentProcessDescriptor
=
this
.
_getParentProcessDescriptor
(
)
;
return
parentProcessDescriptor
.
form
(
)
;
}
const
context
=
BrowsingContext
.
get
(
id
)
;
const
newFrameDescriptor
=
new
FrameDescriptorActor
(
this
.
conn
context
)
;
if
(
!
this
.
_frameDescriptorActorPool
)
{
this
.
_frameDescriptorActorPool
=
new
Pool
(
this
.
conn
)
;
}
this
.
_frameDescriptorActorPool
.
manage
(
newFrameDescriptor
)
;
return
newFrameDescriptor
.
form
(
)
;
}
onEcho
:
function
(
request
)
{
return
Cu
.
cloneInto
(
request
{
}
)
;
}
onProtocolDescription
:
function
(
)
{
return
require
(
"
devtools
/
shared
/
protocol
"
)
.
dumpProtocolSpec
(
)
;
}
removeActorByName
:
function
(
name
)
{
if
(
name
in
this
.
_extraActors
)
{
const
actor
=
this
.
_extraActors
[
name
]
;
if
(
this
.
_globalActorPool
.
has
(
actor
.
actorID
)
)
{
actor
.
destroy
(
)
;
}
if
(
this
.
_tabTargetActorPool
)
{
for
(
const
tab
in
this
.
_tabTargetActorPool
.
poolChildren
(
)
)
{
tab
.
removeActorByName
(
name
)
;
}
}
delete
this
.
_extraActors
[
name
]
;
}
}
}
;
RootActor
.
prototype
.
requestTypes
=
{
getRoot
:
RootActor
.
prototype
.
onGetRoot
listTabs
:
RootActor
.
prototype
.
onListTabs
getTab
:
RootActor
.
prototype
.
onGetTab
getWindow
:
RootActor
.
prototype
.
onGetWindow
listAddons
:
RootActor
.
prototype
.
onListAddons
listWorkers
:
RootActor
.
prototype
.
onListWorkers
listServiceWorkerRegistrations
:
RootActor
.
prototype
.
onListServiceWorkerRegistrations
listProcesses
:
RootActor
.
prototype
.
onListProcesses
getProcess
:
RootActor
.
prototype
.
onGetProcess
getBrowsingContextDescriptor
:
RootActor
.
prototype
.
onGetBrowsingContextDescriptor
listRemoteFrames
:
RootActor
.
prototype
.
onListRemoteFrames
echo
:
RootActor
.
prototype
.
onEcho
protocolDescription
:
RootActor
.
prototype
.
onProtocolDescription
}
;
exports
.
RootActor
=
RootActor
;
