"
use
strict
"
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
const
{
ObjectActorProto
}
=
require
(
"
devtools
/
server
/
actors
/
object
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
ActorClassWithSpec
}
=
protocol
;
const
{
objectSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
object
"
)
;
const
proto
=
extend
(
{
}
ObjectActorProto
)
;
Object
.
assign
(
proto
{
initialize
(
obj
hooks
conn
)
{
ObjectActorProto
.
initialize
.
call
(
this
obj
hooks
conn
)
;
this
.
hooks
.
promote
=
hooks
.
promote
;
this
.
hooks
.
isThreadLifetimePool
=
hooks
.
isThreadLifetimePool
;
}
isPaused
(
)
{
return
this
.
threadActor
?
this
.
threadActor
.
state
=
=
=
"
paused
"
:
true
;
}
withPaused
(
method
)
{
return
function
(
)
{
if
(
this
.
isPaused
(
)
)
{
return
method
.
apply
(
this
arguments
)
;
}
return
{
error
:
"
wrongState
"
message
:
this
.
constructor
.
name
+
"
actors
can
only
be
accessed
while
the
thread
is
paused
.
"
}
;
}
;
}
}
)
;
const
guardWithPaused
=
[
"
decompile
"
"
displayString
"
"
ownPropertyNames
"
"
parameterNames
"
"
property
"
"
prototype
"
"
prototypeAndProperties
"
"
scope
"
]
;
guardWithPaused
.
forEach
(
f
=
>
{
proto
[
f
]
=
proto
.
withPaused
(
ObjectActorProto
[
f
]
)
;
}
)
;
Object
.
assign
(
proto
{
threadGrip
:
proto
.
withPaused
(
function
(
request
)
{
this
.
hooks
.
promote
(
)
;
return
{
}
;
}
)
destroy
:
proto
.
withPaused
(
function
(
request
)
{
if
(
this
.
hooks
.
isThreadLifetimePool
(
)
)
{
return
{
error
:
"
notReleasable
"
message
:
"
Only
thread
-
lifetime
actors
can
be
released
.
"
}
;
}
return
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
}
)
}
)
;
exports
.
PauseScopedObjectActor
=
ActorClassWithSpec
(
objectSpec
proto
)
;
