"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
watcherSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
watcher
.
js
"
)
;
const
Resources
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
index
.
js
"
)
;
const
{
TargetActorRegistry
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
target
-
actor
-
registry
.
sys
.
mjs
"
{
global
:
"
shared
"
}
)
;
const
{
ParentProcessWatcherRegistry
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
ParentProcessWatcherRegistry
.
sys
.
mjs
"
{
global
:
"
shared
"
}
)
;
const
{
getAllBrowsingContextsForContext
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
browsing
-
context
-
helpers
.
sys
.
mjs
"
{
global
:
"
contextual
"
}
)
;
const
{
SESSION_TYPES
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
session
-
context
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
throttle
"
"
resource
:
/
/
devtools
/
shared
/
throttle
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkParentActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
network
-
monitor
/
network
-
parent
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BlackboxingActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
blackboxing
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BreakpointListActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
breakpoint
-
list
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TargetConfigurationActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
target
-
configuration
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ThreadConfigurationActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
thread
-
configuration
.
js
"
true
)
;
const
RESOURCES_THROTTLING_DELAY
=
100
;
exports
.
WatcherActor
=
class
WatcherActor
extends
Actor
{
constructor
(
conn
sessionContext
)
{
super
(
conn
watcherSpec
)
;
this
.
_sessionContext
=
sessionContext
;
if
(
sessionContext
.
type
=
=
SESSION_TYPES
.
BROWSER_ELEMENT
)
{
const
browsingContext
=
BrowsingContext
.
getCurrentTopByBrowserId
(
sessionContext
.
browserId
)
;
if
(
!
browsingContext
)
{
throw
new
Error
(
"
Unable
to
retrieve
the
<
browser
>
element
for
browserId
=
"
+
sessionContext
.
browserId
)
;
}
this
.
_browserElement
=
browsingContext
.
embedderElement
;
}
this
.
watcherConnectionPrefix
=
conn
.
allocID
(
"
watcher
"
)
;
this
.
#
throttledResources
=
{
available
:
[
]
updated
:
[
]
destroyed
:
[
]
}
;
this
.
#
throttledEmitResources
=
throttle
(
this
.
emitResources
.
bind
(
this
)
RESOURCES_THROTTLING_DELAY
)
;
this
.
_earlyIframeTargets
=
{
}
;
this
.
_currentWindowGlobalTargets
=
new
Map
(
)
;
this
.
_jsActorName
=
sessionContext
.
type
=
=
SESSION_TYPES
.
ALL
?
"
BrowserToolboxDevToolsProcess
"
:
"
DevToolsProcess
"
;
}
#
throttledResources
;
#
throttledEmitResources
;
get
sessionContext
(
)
{
return
this
.
_sessionContext
;
}
get
browserElement
(
)
{
return
this
.
_browserElement
;
}
getAllBrowsingContexts
(
)
{
return
getAllBrowsingContextsForContext
(
this
.
sessionContext
)
;
}
isContextDestroyed
(
)
{
if
(
this
.
sessionContext
.
type
=
=
"
browser
-
element
"
)
{
return
!
this
.
browserElement
.
browsingContext
;
}
else
if
(
this
.
sessionContext
.
type
=
=
"
webextension
"
)
{
return
false
;
}
else
if
(
this
.
sessionContext
.
type
=
=
"
all
"
)
{
return
false
;
}
throw
new
Error
(
"
Unsupported
session
context
type
:
"
+
this
.
sessionContext
.
type
)
;
}
destroy
(
)
{
if
(
ParentProcessWatcherRegistry
.
getWatcher
(
this
.
actorID
)
)
{
const
domProcesses
=
ChromeUtils
.
getAllDOMProcesses
(
)
;
for
(
const
domProcess
of
domProcesses
)
{
domProcess
.
getActor
(
this
.
_jsActorName
)
.
destroyWatcher
(
{
watcherActorID
:
this
.
actorID
}
)
;
}
}
Resources
.
unwatchResources
(
this
Resources
.
getParentProcessResourceTypes
(
Object
.
values
(
Resources
.
TYPES
)
)
)
;
ParentProcessWatcherRegistry
.
unregisterWatcher
(
this
.
actorID
)
;
this
.
_browserElement
=
null
;
super
.
destroy
(
)
;
}
get
sessionData
(
)
{
return
ParentProcessWatcherRegistry
.
getSessionData
(
this
)
;
}
form
(
)
{
return
{
actor
:
this
.
actorID
traits
:
{
.
.
.
this
.
sessionContext
.
supportedTargets
resources
:
this
.
sessionContext
.
supportedResources
multipleNetworkEventUpdates
:
true
}
}
;
}
async
watchTargets
(
targetType
)
{
ParentProcessWatcherRegistry
.
watchTargets
(
this
targetType
)
;
let
topLevelTargetProcess
;
if
(
this
.
sessionContext
.
type
=
=
SESSION_TYPES
.
BROWSER_ELEMENT
)
{
topLevelTargetProcess
=
this
.
browserElement
.
browsingContext
.
currentWindowGlobal
?
.
domProcess
;
if
(
topLevelTargetProcess
)
{
await
topLevelTargetProcess
.
getActor
(
this
.
_jsActorName
)
.
watchTargets
(
{
watcherActorID
:
this
.
actorID
targetType
}
)
;
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
}
}
const
domProcesses
=
ChromeUtils
.
getAllDOMProcesses
(
)
;
const
promises
=
[
]
;
for
(
const
domProcess
of
domProcesses
)
{
if
(
domProcess
=
=
topLevelTargetProcess
)
{
continue
;
}
promises
.
push
(
domProcess
.
getActor
(
this
.
_jsActorName
)
.
watchTargets
(
{
watcherActorID
:
this
.
actorID
targetType
}
)
.
catch
(
e
=
>
{
if
(
!
domProcess
.
canSend
)
{
console
.
warn
(
"
Content
process
closed
while
requesting
targets
"
domProcess
.
name
domProcess
.
remoteType
)
;
return
;
}
throw
e
;
}
)
)
;
}
await
Promise
.
all
(
promises
)
;
}
unwatchTargets
(
targetType
options
=
{
}
)
{
const
isWatchingTargets
=
ParentProcessWatcherRegistry
.
unwatchTargets
(
this
targetType
)
;
if
(
!
isWatchingTargets
)
{
return
;
}
const
domProcesses
=
ChromeUtils
.
getAllDOMProcesses
(
)
;
for
(
const
domProcess
of
domProcesses
)
{
domProcess
.
getActor
(
this
.
_jsActorName
)
.
unwatchTargets
(
{
watcherActorID
:
this
.
actorID
targetType
options
}
)
;
}
}
_flushIframeTargets
(
topInnerWindowID
)
{
while
(
this
.
_earlyIframeTargets
[
topInnerWindowID
]
?
.
length
>
0
)
{
const
actor
=
this
.
_earlyIframeTargets
[
topInnerWindowID
]
.
shift
(
)
;
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
}
}
notifyTargetAvailable
(
actor
)
{
if
(
!
actor
.
traits
?
.
isBrowsingContext
)
{
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
return
;
}
this
.
_currentWindowGlobalTargets
.
set
(
actor
.
innerWindowId
actor
)
;
if
(
this
.
sessionContext
.
type
=
=
"
all
"
)
{
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
return
;
}
if
(
actor
.
isTopLevelTarget
)
{
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
this
.
_flushIframeTargets
(
actor
.
innerWindowId
)
;
if
(
this
.
sessionContext
.
type
=
=
SESSION_TYPES
.
BROWSER_ELEMENT
)
{
this
.
updateDomainSessionDataForServiceWorkers
(
actor
.
url
)
.
catch
(
(
)
=
>
{
}
)
;
}
}
else
if
(
this
.
_currentWindowGlobalTargets
.
has
(
actor
.
topInnerWindowId
)
)
{
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
}
else
if
(
this
.
_earlyIframeTargets
[
actor
.
topInnerWindowId
]
)
{
this
.
_earlyIframeTargets
[
actor
.
topInnerWindowId
]
.
push
(
actor
)
;
}
else
{
this
.
_earlyIframeTargets
[
actor
.
topInnerWindowId
]
=
[
actor
]
;
}
}
async
notifyTargetDestroyed
(
actor
options
=
{
}
)
{
if
(
!
actor
.
innerWindowId
)
{
this
.
emit
(
"
target
-
destroyed
-
form
"
actor
options
)
;
return
;
}
if
(
actor
.
isTopLevelTarget
)
{
const
childrenActors
=
[
.
.
.
this
.
_currentWindowGlobalTargets
.
values
(
)
]
.
filter
(
form
=
>
form
.
topInnerWindowId
=
=
actor
.
innerWindowId
&
&
form
.
innerWindowId
!
=
actor
.
innerWindowId
)
;
childrenActors
.
map
(
form
=
>
this
.
notifyTargetDestroyed
(
form
options
)
)
;
}
if
(
this
.
_earlyIframeTargets
[
actor
.
innerWindowId
]
)
{
delete
this
.
_earlyIframeTargets
[
actor
.
innerWindowId
]
;
}
this
.
_currentWindowGlobalTargets
.
delete
(
actor
.
innerWindowId
)
;
const
documentEventWatcher
=
Resources
.
getResourceWatcher
(
this
Resources
.
TYPES
.
DOCUMENT_EVENT
)
;
if
(
documentEventWatcher
&
&
this
.
sessionContext
.
isServerTargetSwitchingEnabled
&
&
actor
.
isTopLevelTarget
)
{
await
documentEventWatcher
.
onceWillNavigateIsEmitted
(
actor
.
innerWindowId
)
;
}
this
.
emit
(
"
target
-
destroyed
-
form
"
actor
options
)
;
}
getParentBrowsingContextID
(
browsingContextID
)
{
const
browsingContext
=
BrowsingContext
.
get
(
browsingContextID
)
;
if
(
!
browsingContext
)
{
throw
new
Error
(
BrowsingContext
with
ID
=
{
browsingContextID
}
doesn
'
t
exist
.
)
;
}
if
(
browsingContext
.
parent
)
{
return
browsingContext
.
parent
.
id
;
}
if
(
browsingContext
.
embedderWindowGlobal
)
{
return
browsingContext
.
embedderWindowGlobal
.
browsingContext
.
id
;
}
return
null
;
}
notifyResources
(
updateType
resourceType
resources
)
{
if
(
resources
.
length
=
=
=
0
)
{
return
;
}
const
shouldEmitSynchronously
=
resourceType
=
=
Resources
.
TYPES
.
DOCUMENT_EVENT
&
&
resources
.
some
(
resource
=
>
resource
.
name
=
=
"
will
-
navigate
"
)
;
const
lastResourceInThrottleCache
=
this
.
#
throttledResources
[
updateType
]
.
at
(
-
1
)
;
if
(
lastResourceInThrottleCache
&
&
lastResourceInThrottleCache
[
0
]
=
=
=
resourceType
)
{
lastResourceInThrottleCache
[
1
]
.
push
.
apply
(
lastResourceInThrottleCache
[
1
]
resources
)
;
}
else
{
this
.
#
throttledResources
[
updateType
]
.
push
(
[
resourceType
resources
]
)
;
}
if
(
shouldEmitSynchronously
)
{
this
.
emitResources
(
)
;
}
else
{
this
.
#
throttledEmitResources
(
)
;
}
}
emitResources
(
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
for
(
const
updateType
of
[
"
available
"
"
updated
"
"
destroyed
"
]
)
{
const
resources
=
this
.
#
throttledResources
[
updateType
]
;
if
(
!
resources
.
length
)
{
continue
;
}
this
.
#
throttledResources
[
updateType
]
=
[
]
;
this
.
emit
(
resources
-
{
updateType
}
-
array
resources
)
;
}
}
getTargetActorsInParentProcess
(
)
{
if
(
TargetActorRegistry
.
xpcShellTargetActors
.
size
)
{
return
TargetActorRegistry
.
xpcShellTargetActors
;
}
const
actors
=
TargetActorRegistry
.
getTargetActors
(
this
.
sessionContext
this
.
conn
.
prefix
)
;
switch
(
this
.
sessionContext
.
type
)
{
case
"
all
"
:
const
parentProcessTargetActor
=
actors
.
find
(
actor
=
>
actor
.
typeName
=
=
=
"
parentProcessTarget
"
)
;
if
(
parentProcessTargetActor
)
{
return
new
Set
(
[
parentProcessTargetActor
]
)
;
}
return
new
Set
(
)
;
case
"
browser
-
element
"
:
case
"
webextension
"
:
return
new
Set
(
)
;
default
:
throw
new
Error
(
"
Unsupported
session
context
type
:
"
+
this
.
sessionContext
.
type
)
;
}
}
async
watchResources
(
resourceTypes
)
{
await
Resources
.
watchResources
(
this
Resources
.
getParentProcessResourceTypes
(
resourceTypes
)
)
;
if
(
!
Resources
.
hasResourceTypesForTargets
(
resourceTypes
)
)
{
return
;
}
ParentProcessWatcherRegistry
.
watchResources
(
this
resourceTypes
)
;
const
promises
=
[
]
;
const
domProcesses
=
ChromeUtils
.
getAllDOMProcesses
(
)
;
for
(
const
domProcess
of
domProcesses
)
{
promises
.
push
(
domProcess
.
getActor
(
this
.
_jsActorName
)
.
addOrSetSessionDataEntry
(
{
watcherActorID
:
this
.
actorID
sessionContext
:
this
.
sessionContext
type
:
"
resources
"
entries
:
resourceTypes
updateType
:
"
add
"
}
)
.
catch
(
e
=
>
{
if
(
!
domProcess
.
canSend
)
{
console
.
warn
(
"
Content
process
closed
while
requesting
resources
"
domProcess
.
name
domProcess
.
remoteType
)
;
return
;
}
throw
e
;
}
)
)
;
}
await
Promise
.
all
(
promises
)
;
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
const
targetActors
=
this
.
getTargetActorsInParentProcess
(
)
;
for
(
const
targetActor
of
targetActors
)
{
const
targetActorResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
targetActor
.
targetType
)
;
await
targetActor
.
addOrSetSessionDataEntry
(
"
resources
"
targetActorResourceTypes
false
"
add
"
)
;
}
}
unwatchResources
(
resourceTypes
)
{
Resources
.
unwatchResources
(
this
Resources
.
getParentProcessResourceTypes
(
resourceTypes
)
)
;
if
(
!
Resources
.
hasResourceTypesForTargets
(
resourceTypes
)
)
{
return
;
}
const
isWatchingResources
=
ParentProcessWatcherRegistry
.
unwatchResources
(
this
resourceTypes
)
;
if
(
!
isWatchingResources
)
{
return
;
}
if
(
!
this
.
isContextDestroyed
(
)
)
{
const
domProcesses
=
ChromeUtils
.
getAllDOMProcesses
(
)
;
for
(
const
domProcess
of
domProcesses
)
{
domProcess
.
getActor
(
this
.
_jsActorName
)
.
removeSessionDataEntry
(
{
watcherActorID
:
this
.
actorID
sessionContext
:
this
.
sessionContext
type
:
"
resources
"
entries
:
resourceTypes
}
)
;
}
}
const
targetActors
=
this
.
getTargetActorsInParentProcess
(
)
;
for
(
const
targetActor
of
targetActors
)
{
const
targetActorResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
targetActor
.
targetType
)
;
targetActor
.
removeSessionDataEntry
(
"
resources
"
targetActorResourceTypes
)
;
}
}
clearResources
(
resourceTypes
)
{
Resources
.
clearResources
(
this
Resources
.
getParentProcessResourceTypes
(
resourceTypes
)
)
;
}
getNetworkParentActor
(
)
{
if
(
!
this
.
_networkParentActor
)
{
this
.
_networkParentActor
=
new
NetworkParentActor
(
this
)
;
}
return
this
.
_networkParentActor
;
}
getBlackboxingActor
(
)
{
if
(
!
this
.
_blackboxingActor
)
{
this
.
_blackboxingActor
=
new
BlackboxingActor
(
this
)
;
}
return
this
.
_blackboxingActor
;
}
getBreakpointListActor
(
)
{
if
(
!
this
.
_breakpointListActor
)
{
this
.
_breakpointListActor
=
new
BreakpointListActor
(
this
)
;
}
return
this
.
_breakpointListActor
;
}
getTargetConfigurationActor
(
)
{
if
(
!
this
.
_targetConfigurationListActor
)
{
this
.
_targetConfigurationListActor
=
new
TargetConfigurationActor
(
this
)
;
}
return
this
.
_targetConfigurationListActor
;
}
getThreadConfigurationActor
(
)
{
if
(
!
this
.
_threadConfigurationListActor
)
{
this
.
_threadConfigurationListActor
=
new
ThreadConfigurationActor
(
this
)
;
}
return
this
.
_threadConfigurationListActor
;
}
async
addOrSetDataEntry
(
type
entries
updateType
)
{
ParentProcessWatcherRegistry
.
addOrSetSessionDataEntry
(
this
type
entries
updateType
)
;
const
promises
=
[
]
;
const
domProcesses
=
ChromeUtils
.
getAllDOMProcesses
(
)
;
for
(
const
domProcess
of
domProcesses
)
{
promises
.
push
(
domProcess
.
getActor
(
this
.
_jsActorName
)
.
addOrSetSessionDataEntry
(
{
watcherActorID
:
this
.
actorID
sessionContext
:
this
.
sessionContext
type
entries
updateType
}
)
.
catch
(
e
=
>
{
if
(
!
domProcess
.
canSend
)
{
console
.
warn
(
"
Content
process
closed
while
sending
session
data
"
domProcess
.
name
domProcess
.
remoteType
)
;
return
;
}
throw
e
;
}
)
)
;
}
await
Promise
.
all
(
promises
)
;
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
const
targetActors
=
this
.
getTargetActorsInParentProcess
(
)
;
for
(
const
targetActor
of
targetActors
)
{
await
targetActor
.
addOrSetSessionDataEntry
(
type
entries
false
updateType
)
;
}
}
removeDataEntry
(
type
entries
)
{
ParentProcessWatcherRegistry
.
removeSessionDataEntry
(
this
type
entries
)
;
const
domProcesses
=
ChromeUtils
.
getAllDOMProcesses
(
)
;
for
(
const
domProcess
of
domProcesses
)
{
domProcess
.
getActor
(
this
.
_jsActorName
)
.
removeSessionDataEntry
(
{
watcherActorID
:
this
.
actorID
sessionContext
:
this
.
sessionContext
type
entries
}
)
;
}
const
targetActors
=
this
.
getTargetActorsInParentProcess
(
)
;
for
(
const
targetActor
of
targetActors
)
{
targetActor
.
removeSessionDataEntry
(
type
entries
)
;
}
}
getSessionDataForType
(
type
)
{
return
this
.
sessionData
?
.
[
type
]
;
}
async
updateDomainSessionDataForServiceWorkers
(
newTargetUrl
)
{
const
host
=
URL
.
parse
(
newTargetUrl
)
?
.
host
?
?
"
"
;
ParentProcessWatcherRegistry
.
addOrSetSessionDataEntry
(
this
"
browser
-
element
-
host
"
[
host
]
"
set
"
)
;
return
this
.
addOrSetDataEntry
(
"
browser
-
element
-
host
"
[
host
]
"
set
"
)
;
}
}
;
