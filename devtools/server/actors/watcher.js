"
use
strict
"
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
watcherSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
watcher
"
)
;
const
Resources
=
require
(
"
devtools
/
server
/
actors
/
resources
/
index
"
)
;
const
{
TargetActorRegistry
}
=
require
(
"
devtools
/
server
/
actors
/
targets
/
target
-
actor
-
registry
.
jsm
"
)
;
const
{
WatcherRegistry
}
=
require
(
"
devtools
/
server
/
actors
/
watcher
/
WatcherRegistry
.
jsm
"
)
;
const
Targets
=
require
(
"
devtools
/
server
/
actors
/
targets
/
index
"
)
;
const
{
getAllBrowsingContextsForContext
}
=
require
(
"
devtools
/
server
/
actors
/
watcher
/
browsing
-
context
-
helpers
.
jsm
"
)
;
const
TARGET_HELPERS
=
{
}
;
loader
.
lazyRequireGetter
(
TARGET_HELPERS
Targets
.
TYPES
.
FRAME
"
devtools
/
server
/
actors
/
watcher
/
target
-
helpers
/
frame
-
helper
"
)
;
loader
.
lazyRequireGetter
(
TARGET_HELPERS
Targets
.
TYPES
.
PROCESS
"
devtools
/
server
/
actors
/
watcher
/
target
-
helpers
/
process
-
helper
"
)
;
loader
.
lazyRequireGetter
(
TARGET_HELPERS
Targets
.
TYPES
.
WORKER
"
devtools
/
server
/
actors
/
watcher
/
target
-
helpers
/
worker
-
helper
"
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkParentActor
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
network
-
parent
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BlackboxingActor
"
"
devtools
/
server
/
actors
/
blackboxing
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BreakpointListActor
"
"
devtools
/
server
/
actors
/
breakpoint
-
list
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TargetConfigurationActor
"
"
devtools
/
server
/
actors
/
target
-
configuration
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ThreadConfigurationActor
"
"
devtools
/
server
/
actors
/
thread
-
configuration
"
true
)
;
exports
.
WatcherActor
=
protocol
.
ActorClassWithSpec
(
watcherSpec
{
initialize
(
conn
sessionContext
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
_sessionContext
=
sessionContext
;
if
(
sessionContext
.
type
=
=
"
browser
-
element
"
)
{
const
browsingContext
=
BrowsingContext
.
getCurrentTopByBrowserId
(
sessionContext
.
browserId
)
;
if
(
!
browsingContext
)
{
throw
new
Error
(
"
Unable
to
retrieve
the
<
browser
>
element
for
browserId
=
"
+
sessionContext
.
browserId
)
;
}
this
.
_browserElement
=
browsingContext
.
embedderElement
;
}
this
.
_earlyIframeTargets
=
{
}
;
this
.
_currentWindowGlobalTargets
=
new
Map
(
)
;
}
get
sessionContext
(
)
{
return
this
.
_sessionContext
;
}
get
browserElement
(
)
{
return
this
.
_browserElement
;
}
getAllBrowsingContexts
(
options
)
{
return
getAllBrowsingContextsForContext
(
this
.
sessionContext
options
)
;
}
isContextDestroyed
(
)
{
if
(
this
.
sessionContext
.
type
=
=
"
browser
-
element
"
)
{
return
!
this
.
browserElement
.
browsingContext
;
}
else
if
(
this
.
sessionContext
.
type
=
=
"
webextension
"
)
{
return
!
BrowsingContext
.
get
(
this
.
sessionContext
.
addonBrowsingContextID
)
;
}
else
if
(
this
.
sessionContext
.
type
=
=
"
all
"
)
{
return
false
;
}
throw
new
Error
(
"
Unsupported
session
context
type
:
"
+
this
.
sessionContext
.
type
)
;
}
destroy
(
)
{
for
(
const
targetType
of
Object
.
values
(
Targets
.
TYPES
)
)
{
this
.
unwatchTargets
(
targetType
)
;
}
this
.
unwatchResources
(
Object
.
values
(
Resources
.
TYPES
)
)
;
WatcherRegistry
.
unregisterWatcher
(
this
)
;
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
}
get
sessionData
(
)
{
return
WatcherRegistry
.
getSessionData
(
this
)
;
}
form
(
)
{
return
{
actor
:
this
.
actorID
traits
:
{
.
.
.
this
.
sessionContext
.
supportedTargets
resources
:
this
.
sessionContext
.
supportedResources
}
}
;
}
async
watchTargets
(
targetType
)
{
WatcherRegistry
.
watchTargets
(
this
targetType
)
;
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
await
targetHelperModule
.
createTargets
(
this
)
;
}
unwatchTargets
(
targetType
options
=
{
}
)
{
const
isWatchingTargets
=
WatcherRegistry
.
unwatchTargets
(
this
targetType
options
)
;
if
(
!
isWatchingTargets
)
{
return
;
}
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
targetHelperModule
.
destroyTargets
(
this
options
)
;
if
(
!
options
.
isModeSwitching
)
{
WatcherRegistry
.
maybeUnregisteringJSWindowActor
(
)
;
}
}
_flushIframeTargets
(
topInnerWindowID
)
{
while
(
this
.
_earlyIframeTargets
[
topInnerWindowID
]
?
.
length
>
0
)
{
const
actor
=
this
.
_earlyIframeTargets
[
topInnerWindowID
]
.
shift
(
)
;
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
}
}
notifyTargetAvailable
(
actor
)
{
if
(
!
actor
.
traits
?
.
isBrowsingContext
)
{
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
return
;
}
this
.
_currentWindowGlobalTargets
.
set
(
actor
.
innerWindowId
actor
)
;
if
(
this
.
sessionContext
.
type
=
=
"
all
"
)
{
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
return
;
}
if
(
actor
.
isTopLevelTarget
)
{
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
this
.
_flushIframeTargets
(
actor
.
innerWindowId
)
;
}
else
if
(
this
.
_currentWindowGlobalTargets
.
has
(
actor
.
topInnerWindowId
)
)
{
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
}
else
if
(
this
.
_earlyIframeTargets
[
actor
.
topInnerWindowId
]
)
{
this
.
_earlyIframeTargets
[
actor
.
topInnerWindowId
]
.
push
(
actor
)
;
}
else
{
this
.
_earlyIframeTargets
[
actor
.
topInnerWindowId
]
=
[
actor
]
;
}
}
async
notifyTargetDestroyed
(
actor
options
=
{
}
)
{
if
(
!
actor
.
innerWindowId
)
{
this
.
emit
(
"
target
-
destroyed
-
form
"
actor
options
)
;
return
;
}
if
(
actor
.
isTopLevelTarget
)
{
const
childrenActors
=
[
.
.
.
this
.
_currentWindowGlobalTargets
.
values
(
)
]
.
filter
(
form
=
>
form
.
topInnerWindowId
=
=
actor
.
innerWindowId
&
&
form
.
innerWindowId
!
=
actor
.
innerWindowId
)
;
childrenActors
.
map
(
form
=
>
this
.
notifyTargetDestroyed
(
form
options
)
)
;
}
if
(
this
.
_earlyIframeTargets
[
actor
.
innerWindowId
]
)
{
delete
this
.
_earlyIframeTargets
[
actor
.
innerWindowId
]
;
}
this
.
_currentWindowGlobalTargets
.
delete
(
actor
.
innerWindowId
)
;
const
documentEventWatcher
=
Resources
.
getResourceWatcher
(
this
Resources
.
TYPES
.
DOCUMENT_EVENT
)
;
if
(
documentEventWatcher
&
&
this
.
sessionContext
.
isServerTargetSwitchingEnabled
&
&
actor
.
isTopLevelTarget
)
{
await
documentEventWatcher
.
onceWillNavigateIsEmitted
(
actor
.
innerWindowId
)
;
}
this
.
emit
(
"
target
-
destroyed
-
form
"
actor
options
)
;
}
getParentBrowsingContextID
(
browsingContextID
)
{
const
browsingContext
=
BrowsingContext
.
get
(
browsingContextID
)
;
if
(
!
browsingContext
)
{
throw
new
Error
(
BrowsingContext
with
ID
=
{
browsingContextID
}
doesn
'
t
exist
.
)
;
}
if
(
browsingContext
.
parent
)
{
return
browsingContext
.
parent
.
id
;
}
if
(
browsingContext
.
embedderWindowGlobal
)
{
return
browsingContext
.
embedderWindowGlobal
.
browsingContext
.
id
;
}
return
null
;
}
notifyResources
(
updateType
resources
)
{
if
(
resources
.
length
=
=
=
0
)
{
return
;
}
if
(
this
.
sessionContext
.
type
=
=
"
webextension
"
)
{
this
.
_overrideResourceBrowsingContextForWebExtension
(
resources
)
;
}
this
.
emit
(
resource
-
{
updateType
}
-
form
resources
)
;
}
_overrideResourceBrowsingContextForWebExtension
(
resources
)
{
resources
.
forEach
(
resource
=
>
{
resource
.
browsingContextID
=
this
.
sessionContext
.
addonBrowsingContextID
;
}
)
;
}
_getTargetActorInParentProcess
(
)
{
return
TargetActorRegistry
.
getTopLevelTargetActorForContext
(
this
.
sessionContext
this
.
conn
.
prefix
)
;
}
async
watchResources
(
resourceTypes
)
{
await
Resources
.
watchResources
(
this
Resources
.
getParentProcessResourceTypes
(
resourceTypes
)
)
;
if
(
!
Resources
.
hasResourceTypesForTargets
(
resourceTypes
)
)
{
return
;
}
WatcherRegistry
.
watchResources
(
this
resourceTypes
)
;
for
(
const
targetType
in
TARGET_HELPERS
)
{
if
(
!
WatcherRegistry
.
isWatchingTargets
(
this
targetType
)
&
&
targetType
!
=
Targets
.
TYPES
.
FRAME
)
{
continue
;
}
const
targetResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
targetType
)
;
if
(
!
targetResourceTypes
.
length
)
{
continue
;
}
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
await
targetHelperModule
.
addSessionDataEntry
(
{
watcher
:
this
type
:
"
resources
"
entries
:
targetResourceTypes
}
)
;
}
const
frameResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
Targets
.
TYPES
.
FRAME
)
;
if
(
frameResourceTypes
.
length
)
{
const
targetActor
=
this
.
_getTargetActorInParentProcess
(
)
;
if
(
targetActor
)
{
await
targetActor
.
addSessionDataEntry
(
"
resources
"
frameResourceTypes
)
;
}
}
}
unwatchResources
(
resourceTypes
)
{
Resources
.
unwatchResources
(
this
Resources
.
getParentProcessResourceTypes
(
resourceTypes
)
)
;
if
(
!
Resources
.
hasResourceTypesForTargets
(
resourceTypes
)
)
{
return
;
}
const
isWatchingResources
=
WatcherRegistry
.
unwatchResources
(
this
resourceTypes
)
;
if
(
!
isWatchingResources
)
{
return
;
}
if
(
!
this
.
isContextDestroyed
(
)
)
{
for
(
const
targetType
in
TARGET_HELPERS
)
{
if
(
!
WatcherRegistry
.
isWatchingTargets
(
this
targetType
)
&
&
targetType
!
=
Targets
.
TYPES
.
FRAME
)
{
continue
;
}
const
targetResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
targetType
)
;
if
(
!
targetResourceTypes
.
length
)
{
continue
;
}
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
targetHelperModule
.
removeSessionDataEntry
(
{
watcher
:
this
type
:
"
resources
"
entries
:
targetResourceTypes
}
)
;
}
}
const
frameResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
Targets
.
TYPES
.
FRAME
)
;
if
(
frameResourceTypes
.
length
)
{
const
targetActor
=
this
.
_getTargetActorInParentProcess
(
)
;
if
(
targetActor
)
{
targetActor
.
removeSessionDataEntry
(
"
resources
"
frameResourceTypes
)
;
}
}
WatcherRegistry
.
maybeUnregisteringJSWindowActor
(
)
;
}
clearResources
(
resourceTypes
)
{
Resources
.
clearResources
(
this
Resources
.
getParentProcessResourceTypes
(
resourceTypes
)
)
;
}
getNetworkParentActor
(
)
{
if
(
!
this
.
_networkParentActor
)
{
this
.
_networkParentActor
=
new
NetworkParentActor
(
this
)
;
}
return
this
.
_networkParentActor
;
}
getBlackboxingActor
(
)
{
if
(
!
this
.
_blackboxingActor
)
{
this
.
_blackboxingActor
=
new
BlackboxingActor
(
this
)
;
}
return
this
.
_blackboxingActor
;
}
getBreakpointListActor
(
)
{
if
(
!
this
.
_breakpointListActor
)
{
this
.
_breakpointListActor
=
new
BreakpointListActor
(
this
)
;
}
return
this
.
_breakpointListActor
;
}
getTargetConfigurationActor
(
)
{
if
(
!
this
.
_targetConfigurationListActor
)
{
this
.
_targetConfigurationListActor
=
new
TargetConfigurationActor
(
this
)
;
}
return
this
.
_targetConfigurationListActor
;
}
getThreadConfigurationActor
(
)
{
if
(
!
this
.
_threadConfigurationListActor
)
{
this
.
_threadConfigurationListActor
=
new
ThreadConfigurationActor
(
this
)
;
}
return
this
.
_threadConfigurationListActor
;
}
async
addDataEntry
(
type
entries
)
{
WatcherRegistry
.
addSessionDataEntry
(
this
type
entries
)
;
await
Promise
.
all
(
Object
.
values
(
Targets
.
TYPES
)
.
filter
(
targetType
=
>
WatcherRegistry
.
isWatchingTargets
(
this
targetType
)
|
|
targetType
=
=
=
Targets
.
TYPES
.
FRAME
)
.
map
(
async
targetType
=
>
{
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
await
targetHelperModule
.
addSessionDataEntry
(
{
watcher
:
this
type
entries
}
)
;
}
)
)
;
const
targetActor
=
this
.
_getTargetActorInParentProcess
(
)
;
if
(
targetActor
)
{
await
targetActor
.
addSessionDataEntry
(
type
entries
)
;
}
}
removeDataEntry
(
type
entries
)
{
WatcherRegistry
.
removeSessionDataEntry
(
this
type
entries
)
;
Object
.
values
(
Targets
.
TYPES
)
.
filter
(
targetType
=
>
WatcherRegistry
.
isWatchingTargets
(
this
targetType
)
|
|
targetType
=
=
=
Targets
.
TYPES
.
FRAME
)
.
forEach
(
targetType
=
>
{
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
targetHelperModule
.
removeSessionDataEntry
(
{
watcher
:
this
type
entries
}
)
;
}
)
;
const
targetActor
=
this
.
_getTargetActorInParentProcess
(
)
;
if
(
targetActor
)
{
targetActor
.
removeSessionDataEntry
(
type
entries
)
;
}
}
getSessionDataForType
(
type
)
{
return
this
.
sessionData
?
.
[
type
]
;
}
}
)
;
