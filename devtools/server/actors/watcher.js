"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
watcherSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
watcher
.
js
"
)
;
const
Resources
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
index
.
js
"
)
;
const
{
TargetActorRegistry
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
target
-
actor
-
registry
.
sys
.
mjs
"
{
global
:
"
shared
"
}
)
;
const
{
WatcherRegistry
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
WatcherRegistry
.
sys
.
mjs
"
{
global
:
"
shared
"
}
)
;
const
Targets
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
index
.
js
"
)
;
const
{
getAllBrowsingContextsForContext
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
browsing
-
context
-
helpers
.
sys
.
mjs
"
{
global
:
"
contextual
"
}
)
;
const
{
SESSION_TYPES
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
session
-
context
.
js
"
)
;
const
TARGET_HELPERS
=
{
}
;
loader
.
lazyRequireGetter
(
TARGET_HELPERS
Targets
.
TYPES
.
FRAME
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
target
-
helpers
/
frame
-
helper
.
js
"
)
;
loader
.
lazyRequireGetter
(
TARGET_HELPERS
Targets
.
TYPES
.
PROCESS
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
target
-
helpers
/
process
-
helper
.
js
"
)
;
loader
.
lazyRequireGetter
(
TARGET_HELPERS
Targets
.
TYPES
.
SERVICE_WORKER
"
devtools
/
server
/
actors
/
watcher
/
target
-
helpers
/
service
-
worker
-
helper
"
)
;
loader
.
lazyRequireGetter
(
TARGET_HELPERS
Targets
.
TYPES
.
WORKER
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
target
-
helpers
/
worker
-
helper
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkParentActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
network
-
monitor
/
network
-
parent
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BlackboxingActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
blackboxing
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BreakpointListActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
breakpoint
-
list
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TargetConfigurationActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
target
-
configuration
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ThreadConfigurationActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
thread
-
configuration
.
js
"
true
)
;
exports
.
WatcherActor
=
class
WatcherActor
extends
Actor
{
constructor
(
conn
sessionContext
)
{
super
(
conn
watcherSpec
)
;
this
.
_sessionContext
=
sessionContext
;
if
(
sessionContext
.
type
=
=
SESSION_TYPES
.
BROWSER_ELEMENT
)
{
const
browsingContext
=
BrowsingContext
.
getCurrentTopByBrowserId
(
sessionContext
.
browserId
)
;
if
(
!
browsingContext
)
{
throw
new
Error
(
"
Unable
to
retrieve
the
<
browser
>
element
for
browserId
=
"
+
sessionContext
.
browserId
)
;
}
this
.
_browserElement
=
browsingContext
.
embedderElement
;
}
this
.
_earlyIframeTargets
=
{
}
;
this
.
_currentWindowGlobalTargets
=
new
Map
(
)
;
}
get
sessionContext
(
)
{
return
this
.
_sessionContext
;
}
get
browserElement
(
)
{
return
this
.
_browserElement
;
}
getAllBrowsingContexts
(
options
)
{
return
getAllBrowsingContextsForContext
(
this
.
sessionContext
options
)
;
}
isContextDestroyed
(
)
{
if
(
this
.
sessionContext
.
type
=
=
"
browser
-
element
"
)
{
return
!
this
.
browserElement
.
browsingContext
;
}
else
if
(
this
.
sessionContext
.
type
=
=
"
webextension
"
)
{
return
!
BrowsingContext
.
get
(
this
.
sessionContext
.
addonBrowsingContextID
)
;
}
else
if
(
this
.
sessionContext
.
type
=
=
"
all
"
)
{
return
false
;
}
throw
new
Error
(
"
Unsupported
session
context
type
:
"
+
this
.
sessionContext
.
type
)
;
}
destroy
(
)
{
for
(
const
targetType
of
Object
.
values
(
Targets
.
TYPES
)
)
{
this
.
unwatchTargets
(
targetType
)
;
}
this
.
unwatchResources
(
Object
.
values
(
Resources
.
TYPES
)
)
;
WatcherRegistry
.
unregisterWatcher
(
this
)
;
super
.
destroy
(
)
;
}
get
sessionData
(
)
{
return
WatcherRegistry
.
getSessionData
(
this
)
;
}
form
(
)
{
return
{
actor
:
this
.
actorID
traits
:
{
.
.
.
this
.
sessionContext
.
supportedTargets
resources
:
this
.
sessionContext
.
supportedResources
}
}
;
}
async
watchTargets
(
targetType
)
{
WatcherRegistry
.
watchTargets
(
this
targetType
)
;
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
await
targetHelperModule
.
createTargets
(
this
)
;
}
unwatchTargets
(
targetType
options
=
{
}
)
{
const
isWatchingTargets
=
WatcherRegistry
.
unwatchTargets
(
this
targetType
options
)
;
if
(
!
isWatchingTargets
)
{
return
;
}
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
targetHelperModule
.
destroyTargets
(
this
options
)
;
if
(
!
options
.
isModeSwitching
)
{
WatcherRegistry
.
maybeUnregisterJSActors
(
)
;
}
}
_flushIframeTargets
(
topInnerWindowID
)
{
while
(
this
.
_earlyIframeTargets
[
topInnerWindowID
]
?
.
length
>
0
)
{
const
actor
=
this
.
_earlyIframeTargets
[
topInnerWindowID
]
.
shift
(
)
;
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
}
}
notifyTargetAvailable
(
actor
)
{
if
(
!
actor
.
traits
?
.
isBrowsingContext
)
{
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
return
;
}
this
.
_currentWindowGlobalTargets
.
set
(
actor
.
innerWindowId
actor
)
;
if
(
this
.
sessionContext
.
type
=
=
"
all
"
)
{
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
return
;
}
if
(
actor
.
isTopLevelTarget
)
{
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
this
.
_flushIframeTargets
(
actor
.
innerWindowId
)
;
if
(
this
.
sessionContext
.
type
=
=
SESSION_TYPES
.
BROWSER_ELEMENT
)
{
this
.
updateDomainSessionDataForServiceWorkers
(
actor
.
url
)
;
}
}
else
if
(
this
.
_currentWindowGlobalTargets
.
has
(
actor
.
topInnerWindowId
)
)
{
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
}
else
if
(
this
.
_earlyIframeTargets
[
actor
.
topInnerWindowId
]
)
{
this
.
_earlyIframeTargets
[
actor
.
topInnerWindowId
]
.
push
(
actor
)
;
}
else
{
this
.
_earlyIframeTargets
[
actor
.
topInnerWindowId
]
=
[
actor
]
;
}
}
async
notifyTargetDestroyed
(
actor
options
=
{
}
)
{
if
(
!
actor
.
innerWindowId
)
{
this
.
emit
(
"
target
-
destroyed
-
form
"
actor
options
)
;
return
;
}
if
(
actor
.
isTopLevelTarget
)
{
const
childrenActors
=
[
.
.
.
this
.
_currentWindowGlobalTargets
.
values
(
)
]
.
filter
(
form
=
>
form
.
topInnerWindowId
=
=
actor
.
innerWindowId
&
&
form
.
innerWindowId
!
=
actor
.
innerWindowId
)
;
childrenActors
.
map
(
form
=
>
this
.
notifyTargetDestroyed
(
form
options
)
)
;
}
if
(
this
.
_earlyIframeTargets
[
actor
.
innerWindowId
]
)
{
delete
this
.
_earlyIframeTargets
[
actor
.
innerWindowId
]
;
}
this
.
_currentWindowGlobalTargets
.
delete
(
actor
.
innerWindowId
)
;
const
documentEventWatcher
=
Resources
.
getResourceWatcher
(
this
Resources
.
TYPES
.
DOCUMENT_EVENT
)
;
if
(
documentEventWatcher
&
&
this
.
sessionContext
.
isServerTargetSwitchingEnabled
&
&
actor
.
isTopLevelTarget
)
{
await
documentEventWatcher
.
onceWillNavigateIsEmitted
(
actor
.
innerWindowId
)
;
}
this
.
emit
(
"
target
-
destroyed
-
form
"
actor
options
)
;
}
getParentBrowsingContextID
(
browsingContextID
)
{
const
browsingContext
=
BrowsingContext
.
get
(
browsingContextID
)
;
if
(
!
browsingContext
)
{
throw
new
Error
(
BrowsingContext
with
ID
=
{
browsingContextID
}
doesn
'
t
exist
.
)
;
}
if
(
browsingContext
.
parent
)
{
return
browsingContext
.
parent
.
id
;
}
if
(
browsingContext
.
embedderWindowGlobal
)
{
return
browsingContext
.
embedderWindowGlobal
.
browsingContext
.
id
;
}
return
null
;
}
notifyResources
(
updateType
resources
)
{
if
(
resources
.
length
=
=
=
0
)
{
return
;
}
if
(
this
.
sessionContext
.
type
=
=
"
webextension
"
)
{
this
.
_overrideResourceBrowsingContextForWebExtension
(
resources
)
;
}
this
.
emit
(
resource
-
{
updateType
}
-
form
resources
)
;
}
_overrideResourceBrowsingContextForWebExtension
(
resources
)
{
resources
.
forEach
(
resource
=
>
{
resource
.
browsingContextID
=
this
.
sessionContext
.
addonBrowsingContextID
;
}
)
;
}
getTargetActorsInParentProcess
(
)
{
if
(
TargetActorRegistry
.
xpcShellTargetActors
.
size
)
{
return
TargetActorRegistry
.
xpcShellTargetActors
;
}
const
actors
=
TargetActorRegistry
.
getTargetActors
(
this
.
sessionContext
this
.
conn
.
prefix
)
;
switch
(
this
.
sessionContext
.
type
)
{
case
"
all
"
:
const
parentProcessTargetActor
=
actors
.
find
(
actor
=
>
actor
.
typeName
=
=
=
"
parentProcessTarget
"
)
;
if
(
parentProcessTargetActor
)
{
return
new
Set
(
[
parentProcessTargetActor
]
)
;
}
return
new
Set
(
)
;
case
"
browser
-
element
"
:
case
"
webextension
"
:
return
new
Set
(
)
;
default
:
throw
new
Error
(
"
Unsupported
session
context
type
:
"
+
this
.
sessionContext
.
type
)
;
}
}
async
watchResources
(
resourceTypes
)
{
await
Resources
.
watchResources
(
this
Resources
.
getParentProcessResourceTypes
(
resourceTypes
)
)
;
if
(
!
Resources
.
hasResourceTypesForTargets
(
resourceTypes
)
)
{
return
;
}
WatcherRegistry
.
watchResources
(
this
resourceTypes
)
;
for
(
const
targetType
in
TARGET_HELPERS
)
{
if
(
!
WatcherRegistry
.
isWatchingTargets
(
this
targetType
)
&
&
targetType
!
=
Targets
.
TYPES
.
FRAME
)
{
continue
;
}
const
targetResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
targetType
)
;
if
(
!
targetResourceTypes
.
length
)
{
continue
;
}
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
await
targetHelperModule
.
addOrSetSessionDataEntry
(
{
watcher
:
this
type
:
"
resources
"
entries
:
targetResourceTypes
updateType
:
"
add
"
}
)
;
}
const
targetActors
=
this
.
getTargetActorsInParentProcess
(
)
;
for
(
const
targetActor
of
targetActors
)
{
const
targetActorResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
targetActor
.
targetType
)
;
await
targetActor
.
addOrSetSessionDataEntry
(
"
resources
"
targetActorResourceTypes
false
"
add
"
)
;
}
}
unwatchResources
(
resourceTypes
)
{
Resources
.
unwatchResources
(
this
Resources
.
getParentProcessResourceTypes
(
resourceTypes
)
)
;
if
(
!
Resources
.
hasResourceTypesForTargets
(
resourceTypes
)
)
{
return
;
}
const
isWatchingResources
=
WatcherRegistry
.
unwatchResources
(
this
resourceTypes
)
;
if
(
!
isWatchingResources
)
{
return
;
}
if
(
!
this
.
isContextDestroyed
(
)
)
{
for
(
const
targetType
in
TARGET_HELPERS
)
{
if
(
!
WatcherRegistry
.
isWatchingTargets
(
this
targetType
)
&
&
targetType
!
=
Targets
.
TYPES
.
FRAME
)
{
continue
;
}
const
targetResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
targetType
)
;
if
(
!
targetResourceTypes
.
length
)
{
continue
;
}
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
targetHelperModule
.
removeSessionDataEntry
(
{
watcher
:
this
type
:
"
resources
"
entries
:
targetResourceTypes
}
)
;
}
}
const
targetActors
=
this
.
getTargetActorsInParentProcess
(
)
;
for
(
const
targetActor
of
targetActors
)
{
const
targetActorResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
targetActor
.
targetType
)
;
targetActor
.
removeSessionDataEntry
(
"
resources
"
targetActorResourceTypes
)
;
}
WatcherRegistry
.
maybeUnregisterJSActors
(
)
;
}
clearResources
(
resourceTypes
)
{
Resources
.
clearResources
(
this
Resources
.
getParentProcessResourceTypes
(
resourceTypes
)
)
;
}
getNetworkParentActor
(
)
{
if
(
!
this
.
_networkParentActor
)
{
this
.
_networkParentActor
=
new
NetworkParentActor
(
this
)
;
}
return
this
.
_networkParentActor
;
}
getBlackboxingActor
(
)
{
if
(
!
this
.
_blackboxingActor
)
{
this
.
_blackboxingActor
=
new
BlackboxingActor
(
this
)
;
}
return
this
.
_blackboxingActor
;
}
getBreakpointListActor
(
)
{
if
(
!
this
.
_breakpointListActor
)
{
this
.
_breakpointListActor
=
new
BreakpointListActor
(
this
)
;
}
return
this
.
_breakpointListActor
;
}
getTargetConfigurationActor
(
)
{
if
(
!
this
.
_targetConfigurationListActor
)
{
this
.
_targetConfigurationListActor
=
new
TargetConfigurationActor
(
this
)
;
}
return
this
.
_targetConfigurationListActor
;
}
getThreadConfigurationActor
(
)
{
if
(
!
this
.
_threadConfigurationListActor
)
{
this
.
_threadConfigurationListActor
=
new
ThreadConfigurationActor
(
this
)
;
}
return
this
.
_threadConfigurationListActor
;
}
async
addOrSetDataEntry
(
type
entries
updateType
)
{
WatcherRegistry
.
addOrSetSessionDataEntry
(
this
type
entries
updateType
)
;
await
Promise
.
all
(
Object
.
values
(
Targets
.
TYPES
)
.
filter
(
targetType
=
>
WatcherRegistry
.
isWatchingTargets
(
this
targetType
)
|
|
targetType
=
=
=
Targets
.
TYPES
.
FRAME
)
.
map
(
async
targetType
=
>
{
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
await
targetHelperModule
.
addOrSetSessionDataEntry
(
{
watcher
:
this
type
entries
updateType
}
)
;
}
)
)
;
const
targetActors
=
this
.
getTargetActorsInParentProcess
(
)
;
for
(
const
targetActor
of
targetActors
)
{
await
targetActor
.
addOrSetSessionDataEntry
(
type
entries
false
updateType
)
;
}
}
removeDataEntry
(
type
entries
)
{
WatcherRegistry
.
removeSessionDataEntry
(
this
type
entries
)
;
Object
.
values
(
Targets
.
TYPES
)
.
filter
(
targetType
=
>
WatcherRegistry
.
isWatchingTargets
(
this
targetType
)
|
|
targetType
=
=
=
Targets
.
TYPES
.
FRAME
)
.
forEach
(
targetType
=
>
{
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
targetHelperModule
.
removeSessionDataEntry
(
{
watcher
:
this
type
entries
}
)
;
}
)
;
const
targetActors
=
this
.
getTargetActorsInParentProcess
(
)
;
for
(
const
targetActor
of
targetActors
)
{
targetActor
.
removeSessionDataEntry
(
type
entries
)
;
}
}
getSessionDataForType
(
type
)
{
return
this
.
sessionData
?
.
[
type
]
;
}
async
updateDomainSessionDataForServiceWorkers
(
newTargetUrl
)
{
let
host
=
"
"
;
try
{
host
=
new
URL
(
newTargetUrl
)
.
host
;
}
catch
(
e
)
{
}
WatcherRegistry
.
addOrSetSessionDataEntry
(
this
"
browser
-
element
-
host
"
[
host
]
"
set
"
)
;
if
(
!
WatcherRegistry
.
isWatchingTargets
(
this
Targets
.
TYPES
.
SERVICE_WORKER
)
)
{
return
;
}
const
targetHelperModule
=
TARGET_HELPERS
[
Targets
.
TYPES
.
SERVICE_WORKER
]
;
await
targetHelperModule
.
addOrSetSessionDataEntry
(
{
watcher
:
this
type
:
"
browser
-
element
-
host
"
entries
:
[
host
]
updateType
:
"
set
"
}
)
;
}
}
;
