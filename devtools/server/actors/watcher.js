"
use
strict
"
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
watcherSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
watcher
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
Resources
=
require
(
"
devtools
/
server
/
actors
/
resources
/
index
"
)
;
const
{
TargetActorRegistry
}
=
require
(
"
devtools
/
server
/
actors
/
targets
/
target
-
actor
-
registry
.
jsm
"
)
;
const
{
WatcherRegistry
}
=
require
(
"
devtools
/
server
/
actors
/
watcher
/
WatcherRegistry
.
jsm
"
)
;
const
Targets
=
require
(
"
devtools
/
server
/
actors
/
targets
/
index
"
)
;
const
TARGET_HELPERS
=
{
}
;
loader
.
lazyRequireGetter
(
TARGET_HELPERS
Targets
.
TYPES
.
FRAME
"
devtools
/
server
/
actors
/
watcher
/
target
-
helpers
/
frame
-
helper
"
)
;
loader
.
lazyRequireGetter
(
TARGET_HELPERS
Targets
.
TYPES
.
PROCESS
"
devtools
/
server
/
actors
/
watcher
/
target
-
helpers
/
process
-
helper
"
)
;
loader
.
lazyRequireGetter
(
TARGET_HELPERS
Targets
.
TYPES
.
WORKER
"
devtools
/
server
/
actors
/
watcher
/
target
-
helpers
/
worker
-
helper
"
)
;
loader
.
lazyRequireGetter
(
this
"
NetworkParentActor
"
"
devtools
/
server
/
actors
/
network
-
monitor
/
network
-
parent
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BreakpointListActor
"
"
devtools
/
server
/
actors
/
breakpoint
-
list
"
true
)
;
exports
.
WatcherActor
=
protocol
.
ActorClassWithSpec
(
watcherSpec
{
initialize
:
function
(
conn
options
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
_browser
=
options
&
&
options
.
browser
;
this
.
notifyResourceAvailable
=
this
.
notifyResourceAvailable
.
bind
(
this
)
;
this
.
notifyResourceDestroyed
=
this
.
notifyResourceDestroyed
.
bind
(
this
)
;
this
.
notifyResourceUpdated
=
this
.
notifyResourceUpdated
.
bind
(
this
)
;
}
get
browserElement
(
)
{
return
this
.
_browser
;
}
get
browserId
(
)
{
return
this
.
_browser
?
.
browserId
;
}
destroy
:
function
(
)
{
for
(
const
targetType
of
Object
.
values
(
Targets
.
TYPES
)
)
{
this
.
unwatchTargets
(
targetType
)
;
}
this
.
unwatchResources
(
Object
.
values
(
Resources
.
TYPES
)
)
;
WatcherRegistry
.
unregisterWatcher
(
this
)
;
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
}
get
watchedData
(
)
{
return
WatcherRegistry
.
getWatchedData
(
this
)
;
}
form
(
)
{
const
enableServerWatcher
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
testing
.
enableServerWatcherSupport
"
false
)
;
const
hasBrowserElement
=
!
!
this
.
browserElement
;
return
{
actor
:
this
.
actorID
traits
:
{
[
Targets
.
TYPES
.
FRAME
]
:
true
[
Targets
.
TYPES
.
PROCESS
]
:
true
[
Targets
.
TYPES
.
WORKER
]
:
hasBrowserElement
resources
:
{
[
Resources
.
TYPES
.
CONSOLE_MESSAGE
]
:
hasBrowserElement
[
Resources
.
TYPES
.
CSS_CHANGE
]
:
hasBrowserElement
[
Resources
.
TYPES
.
CSS_MESSAGE
]
:
hasBrowserElement
[
Resources
.
TYPES
.
DOCUMENT_EVENT
]
:
hasBrowserElement
[
Resources
.
TYPES
.
ERROR_MESSAGE
]
:
hasBrowserElement
[
Resources
.
TYPES
.
LOCAL_STORAGE
]
:
hasBrowserElement
[
Resources
.
TYPES
.
SESSION_STORAGE
]
:
hasBrowserElement
[
Resources
.
TYPES
.
PLATFORM_MESSAGE
]
:
true
[
Resources
.
TYPES
.
NETWORK_EVENT
]
:
hasBrowserElement
[
Resources
.
TYPES
.
NETWORK_EVENT_STACKTRACE
]
:
hasBrowserElement
[
Resources
.
TYPES
.
STYLESHEET
]
:
enableServerWatcher
&
&
hasBrowserElement
[
Resources
.
TYPES
.
SOURCE
]
:
hasBrowserElement
[
Resources
.
TYPES
.
THREAD_STATE
]
:
hasBrowserElement
}
"
set
-
breakpoints
"
:
true
}
}
;
}
async
watchTargets
(
targetType
)
{
WatcherRegistry
.
watchTargets
(
this
targetType
)
;
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
await
targetHelperModule
.
createTargets
(
this
)
;
}
unwatchTargets
(
targetType
)
{
const
isWatchingTargets
=
WatcherRegistry
.
unwatchTargets
(
this
targetType
)
;
if
(
!
isWatchingTargets
)
{
return
;
}
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
targetHelperModule
.
destroyTargets
(
this
)
;
WatcherRegistry
.
maybeUnregisteringJSWindowActor
(
)
;
}
notifyTargetAvailable
(
actor
)
{
this
.
emit
(
"
target
-
available
-
form
"
actor
)
;
}
notifyTargetDestroyed
(
actor
)
{
this
.
emit
(
"
target
-
destroyed
-
form
"
actor
)
;
}
getParentBrowsingContextID
(
browsingContextID
)
{
const
browsingContext
=
BrowsingContext
.
get
(
browsingContextID
)
;
if
(
!
browsingContext
)
{
throw
new
Error
(
BrowsingContext
with
ID
=
{
browsingContextID
}
doesn
'
t
exist
.
)
;
}
if
(
browsingContext
.
parent
)
{
return
browsingContext
.
parent
.
id
;
}
if
(
browsingContext
.
embedderWindowGlobal
)
{
return
browsingContext
.
embedderWindowGlobal
.
browsingContext
.
id
;
}
return
null
;
}
notifyResourceAvailable
(
resources
)
{
this
.
_emitResourcesForm
(
"
resource
-
available
-
form
"
resources
)
;
}
notifyResourceDestroyed
(
resources
)
{
this
.
_emitResourcesForm
(
"
resource
-
destroyed
-
form
"
resources
)
;
}
notifyResourceUpdated
(
resources
)
{
this
.
_emitResourcesForm
(
"
resource
-
updated
-
form
"
resources
)
;
}
_emitResourcesForm
(
name
resources
)
{
if
(
resources
.
length
=
=
=
0
)
{
return
;
}
this
.
emit
(
name
resources
)
;
}
_getTargetActorInParentProcess
(
)
{
return
this
.
browserElement
?
TargetActorRegistry
.
getTargetActor
(
this
.
browserId
)
:
TargetActorRegistry
.
getParentProcessTargetActor
(
)
;
}
async
watchResources
(
resourceTypes
)
{
await
Resources
.
watchResources
(
this
Resources
.
getParentProcessResourceTypes
(
resourceTypes
)
)
;
if
(
!
Resources
.
hasResourceTypesForTargets
(
resourceTypes
)
)
{
return
;
}
WatcherRegistry
.
watchResources
(
this
resourceTypes
)
;
for
(
const
targetType
in
TARGET_HELPERS
)
{
if
(
!
WatcherRegistry
.
isWatchingTargets
(
this
targetType
)
&
&
targetType
!
=
Targets
.
TYPES
.
FRAME
)
{
continue
;
}
const
targetResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
targetType
)
;
if
(
targetResourceTypes
.
length
=
=
0
)
{
continue
;
}
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
await
targetHelperModule
.
addWatcherDataEntry
(
{
watcher
:
this
type
:
"
resources
"
entries
:
targetResourceTypes
}
)
;
}
const
frameResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
Targets
.
TYPES
.
FRAME
)
;
if
(
frameResourceTypes
.
length
>
0
)
{
const
targetActor
=
this
.
_getTargetActorInParentProcess
(
)
;
if
(
targetActor
)
{
await
targetActor
.
addWatcherDataEntry
(
"
resources
"
frameResourceTypes
)
;
}
}
}
unwatchResources
(
resourceTypes
)
{
Resources
.
unwatchResources
(
this
Resources
.
getParentProcessResourceTypes
(
resourceTypes
)
)
;
if
(
!
Resources
.
hasResourceTypesForTargets
(
resourceTypes
)
)
{
return
;
}
const
isWatchingResources
=
WatcherRegistry
.
unwatchResources
(
this
resourceTypes
)
;
if
(
!
isWatchingResources
)
{
return
;
}
if
(
!
this
.
browserElement
|
|
this
.
browserElement
.
browsingContext
)
{
for
(
const
targetType
in
TARGET_HELPERS
)
{
if
(
!
WatcherRegistry
.
isWatchingTargets
(
this
targetType
)
&
&
targetType
!
=
Targets
.
TYPES
.
FRAME
)
{
continue
;
}
const
targetResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
targetType
)
;
if
(
targetResourceTypes
.
length
=
=
0
)
{
continue
;
}
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
targetHelperModule
.
removeWatcherDataEntry
(
{
watcher
:
this
type
:
"
resources
"
entries
:
targetResourceTypes
}
)
;
}
}
const
frameResourceTypes
=
Resources
.
getResourceTypesForTargetType
(
resourceTypes
Targets
.
TYPES
.
FRAME
)
;
if
(
frameResourceTypes
.
length
>
0
)
{
const
targetActor
=
this
.
_getTargetActorInParentProcess
(
)
;
if
(
targetActor
)
{
targetActor
.
removeWatcherDataEntry
(
"
resources
"
frameResourceTypes
)
;
}
}
WatcherRegistry
.
maybeUnregisteringJSWindowActor
(
)
;
}
getNetworkParentActor
(
)
{
if
(
!
this
.
_networkParentActor
)
{
this
.
_networkParentActor
=
new
NetworkParentActor
(
this
)
;
}
return
this
.
_networkParentActor
;
}
getBreakpointListActor
(
)
{
if
(
!
this
.
_breakpointListActor
)
{
this
.
_breakpointListActor
=
new
BreakpointListActor
(
this
)
;
}
return
this
.
_breakpointListActor
;
}
async
addDataEntry
(
type
entries
)
{
WatcherRegistry
.
addWatcherDataEntry
(
this
type
entries
)
;
await
Promise
.
all
(
Object
.
values
(
Targets
.
TYPES
)
.
filter
(
targetType
=
>
WatcherRegistry
.
isWatchingTargets
(
this
targetType
)
)
.
map
(
async
targetType
=
>
{
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
await
targetHelperModule
.
addWatcherDataEntry
(
{
watcher
:
this
type
entries
}
)
;
}
)
)
;
const
targetActor
=
this
.
_getTargetActorInParentProcess
(
)
;
if
(
targetActor
)
{
await
targetActor
.
addWatcherDataEntry
(
type
entries
)
;
}
}
removeDataEntry
(
type
entries
)
{
WatcherRegistry
.
removeWatcherDataEntry
(
this
type
entries
)
;
Object
.
values
(
Targets
.
TYPES
)
.
filter
(
targetType
=
>
WatcherRegistry
.
isWatchingTargets
(
this
targetType
)
)
.
forEach
(
targetType
=
>
{
const
targetHelperModule
=
TARGET_HELPERS
[
targetType
]
;
targetHelperModule
.
removeWatcherDataEntry
(
{
watcher
:
this
type
entries
}
)
;
}
)
;
const
targetActor
=
this
.
_getTargetActorInParentProcess
(
)
;
if
(
targetActor
)
{
targetActor
.
removeWatcherDataEntry
(
type
entries
)
;
}
}
}
)
;
