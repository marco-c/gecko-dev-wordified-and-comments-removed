"
use
strict
"
;
const
{
Actor
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
/
Actor
.
js
"
)
;
const
{
Pool
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
/
Pool
.
js
"
)
;
const
{
threadSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
thread
.
js
"
)
;
const
{
createValueGrip
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
utils
.
js
"
)
;
const
{
ObjectActorPool
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
object
/
ObjectActorPool
.
js
"
)
;
const
DevToolsUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
Debugger
=
require
(
"
Debugger
"
)
;
const
{
assert
dumpn
reportException
}
=
DevToolsUtils
;
const
{
getAvailableEventBreakpoints
eventBreakpointForNotification
eventsRequireNotifications
firstStatementBreakpointId
makeEventBreakpointMessage
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
event
-
breakpoints
.
js
"
)
;
const
{
WatchpointMap
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
watchpoint
-
map
.
js
"
)
;
const
Targets
=
require
(
"
devtools
/
server
/
actors
/
targets
/
index
"
)
;
loader
.
lazyRequireGetter
(
this
"
logEvent
"
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
logEvent
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EnvironmentActor
"
"
resource
:
/
/
devtools
/
server
/
actors
/
environment
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BreakpointActorMap
"
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
breakpoint
-
actor
-
map
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EventLoop
"
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
event
-
loop
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
FrameActor
"
"
getSavedFrameParent
"
"
isValidSavedFrame
"
]
"
resource
:
/
/
devtools
/
server
/
actors
/
frame
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HighlighterEnvironment
"
"
resource
:
/
/
devtools
/
server
/
actors
/
highlighters
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
PausedDebuggerOverlay
"
"
resource
:
/
/
devtools
/
server
/
actors
/
highlighters
/
paused
-
debugger
.
js
"
true
)
;
const
PROMISE_REACTIONS
=
new
WeakMap
(
)
;
function
cacheReactionsForFrame
(
frame
)
{
if
(
frame
.
asyncPromise
)
{
const
reactions
=
frame
.
asyncPromise
.
getPromiseReactions
(
)
;
const
existingReactions
=
PROMISE_REACTIONS
.
get
(
frame
.
asyncPromise
)
;
if
(
reactions
.
length
&
&
(
!
existingReactions
|
|
reactions
.
length
>
existingReactions
.
length
)
)
{
PROMISE_REACTIONS
.
set
(
frame
.
asyncPromise
reactions
)
;
}
}
}
function
createStepForReactionTracking
(
onStep
)
{
return
function
(
)
{
cacheReactionsForFrame
(
this
)
;
return
onStep
?
onStep
.
apply
(
this
arguments
)
:
undefined
;
}
;
}
const
getAsyncParentFrame
=
frame
=
>
{
if
(
!
frame
.
asyncPromise
)
{
return
null
;
}
let
reactions
=
PROMISE_REACTIONS
.
get
(
frame
.
asyncPromise
)
|
|
frame
.
asyncPromise
.
getPromiseReactions
(
)
;
while
(
true
)
{
if
(
!
(
reactions
[
0
]
instanceof
Debugger
.
Object
)
)
{
break
;
}
reactions
=
reactions
[
0
]
.
getPromiseReactions
(
)
;
}
if
(
reactions
[
0
]
instanceof
Debugger
.
Frame
)
{
return
reactions
[
0
]
;
}
return
null
;
}
;
const
RESTARTED_FRAMES
=
new
WeakSet
(
)
;
const
STATES
=
{
DETACHED
:
"
detached
"
EXITED
:
"
exited
"
RUNNING
:
"
running
"
PAUSED
:
"
paused
"
}
;
exports
.
STATES
=
STATES
;
const
PAUSE_REASONS
=
{
ALREADY_PAUSED
:
"
alreadyPaused
"
INTERRUPTED
:
"
interrupted
"
MUTATION_BREAKPOINT
:
"
mutationBreakpoint
"
DEBUGGER_STATEMENT
:
"
debuggerStatement
"
EXCEPTION
:
"
exception
"
XHR
:
"
XHR
"
EVENT_BREAKPOINT
:
"
eventBreakpoint
"
RESUME_LIMIT
:
"
resumeLimit
"
}
;
exports
.
PAUSE_REASONS
=
PAUSE_REASONS
;
class
ThreadActor
extends
Actor
{
constructor
(
targetActor
)
{
super
(
targetActor
.
conn
threadSpec
)
;
this
.
targetActor
=
targetActor
;
this
.
_state
=
STATES
.
DETACHED
;
this
.
_options
=
{
skipBreakpoints
:
false
}
;
this
.
_gripDepth
=
0
;
this
.
_targetActorClosed
=
false
;
this
.
_observingNetwork
=
false
;
this
.
_shouldShowPauseOverlay
=
true
;
this
.
_frameActors
=
[
]
;
this
.
_xhrBreakpoints
=
[
]
;
this
.
_dbg
=
null
;
this
.
_threadLifetimePool
=
null
;
this
.
_activeEventPause
=
null
;
this
.
_pauseOverlay
=
null
;
this
.
_priorPause
=
null
;
this
.
_activeEventBreakpoints
=
new
Set
(
)
;
this
.
_frameActorMap
=
new
WeakMap
(
)
;
this
.
_debuggerSourcesSeen
=
new
WeakSet
(
)
;
this
.
_onLoadBreakpointURLs
=
new
Set
(
)
;
this
.
_handledFrameExceptions
=
new
WeakMap
(
)
;
this
.
_watchpointsMap
=
new
WatchpointMap
(
this
)
;
this
.
breakpointActorMap
=
new
BreakpointActorMap
(
this
)
;
this
.
_nestedEventLoop
=
new
EventLoop
(
{
thread
:
this
}
)
;
this
.
onNewSourceEvent
=
this
.
onNewSourceEvent
.
bind
(
this
)
;
this
.
createCompletionGrip
=
this
.
createCompletionGrip
.
bind
(
this
)
;
this
.
onDebuggerStatement
=
this
.
onDebuggerStatement
.
bind
(
this
)
;
this
.
onNewScript
=
this
.
onNewScript
.
bind
(
this
)
;
this
.
_onOpeningRequest
=
this
.
_onOpeningRequest
.
bind
(
this
)
;
this
.
_onNewDebuggee
=
this
.
_onNewDebuggee
.
bind
(
this
)
;
this
.
_onExceptionUnwind
=
this
.
_onExceptionUnwind
.
bind
(
this
)
;
this
.
_eventBreakpointListener
=
this
.
_eventBreakpointListener
.
bind
(
this
)
;
this
.
_onWindowReady
=
this
.
_onWindowReady
.
bind
(
this
)
;
this
.
_onWillNavigate
=
this
.
_onWillNavigate
.
bind
(
this
)
;
this
.
_onNavigate
=
this
.
_onNavigate
.
bind
(
this
)
;
this
.
targetActor
.
on
(
"
window
-
ready
"
this
.
_onWindowReady
)
;
this
.
targetActor
.
on
(
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
targetActor
.
on
(
"
navigate
"
this
.
_onNavigate
)
;
this
.
_firstStatementBreakpoint
=
null
;
this
.
_debuggerNotificationObserver
=
new
DebuggerNotificationObserver
(
)
;
}
_gripDepth
=
null
;
get
dbg
(
)
{
if
(
!
this
.
_dbg
)
{
this
.
_dbg
=
this
.
targetActor
.
dbg
;
if
(
this
.
_state
=
=
=
STATES
.
DETACHED
)
{
this
.
_dbg
.
disable
(
)
;
}
else
{
this
.
_dbg
.
enable
(
)
;
}
}
return
this
.
_dbg
;
}
get
state
(
)
{
return
this
.
_state
;
}
get
attached
(
)
{
return
this
.
state
=
=
STATES
.
RUNNING
|
|
this
.
state
=
=
STATES
.
PAUSED
;
}
get
pauseLifetimePool
(
)
{
return
this
.
_pausePool
;
}
get
threadLifetimePool
(
)
{
if
(
!
this
.
_threadLifetimePool
)
{
this
.
_threadLifetimePool
=
new
ObjectActorPool
(
this
"
thread
"
true
)
;
this
.
_threadLifetimePool
.
objectActors
=
new
WeakMap
(
)
;
}
return
this
.
_threadLifetimePool
;
}
getThreadLifetimeObject
(
raw
)
{
return
this
.
threadLifetimePool
.
objectActors
.
get
(
raw
)
;
}
promoteObjectToThreadLifetime
(
objectActor
)
{
this
.
threadLifetimePool
.
manage
(
objectActor
)
;
this
.
threadLifetimePool
.
objectActors
.
set
(
objectActor
.
obj
objectActor
)
;
}
get
sourcesManager
(
)
{
return
this
.
targetActor
.
sourcesManager
;
}
get
breakpoints
(
)
{
return
this
.
targetActor
.
breakpoints
;
}
get
youngestFrame
(
)
{
if
(
this
.
state
!
=
STATES
.
PAUSED
)
{
return
null
;
}
return
this
.
dbg
.
getNewestFrame
(
)
;
}
get
shouldSkipAnyBreakpoint
(
)
{
return
(
this
.
_options
.
skipBreakpoints
|
|
this
.
insideClientEvaluation
?
.
disableBreaks
)
;
}
isPaused
(
)
{
return
this
.
_state
=
=
=
STATES
.
PAUSED
;
}
lastPausedPacket
(
)
{
return
this
.
_priorPause
;
}
clearDebuggees
(
)
{
if
(
this
.
_dbg
)
{
this
.
dbg
.
removeAllDebuggees
(
)
;
}
}
destroy
(
)
{
dumpn
(
"
in
ThreadActor
.
prototype
.
destroy
"
)
;
if
(
this
.
_state
=
=
STATES
.
PAUSED
)
{
this
.
doResume
(
)
;
}
this
.
removeAllWatchpoints
(
)
;
this
.
_xhrBreakpoints
=
[
]
;
this
.
_updateNetworkObserver
(
)
;
this
.
_activeEventBreakpoints
=
new
Set
(
)
;
this
.
_debuggerNotificationObserver
.
removeListener
(
this
.
_eventBreakpointListener
)
;
for
(
const
global
of
this
.
dbg
.
getDebuggees
(
)
)
{
try
{
this
.
_debuggerNotificationObserver
.
disconnect
(
global
.
unsafeDereference
(
)
)
;
}
catch
(
e
)
{
}
}
this
.
targetActor
.
off
(
"
window
-
ready
"
this
.
_onWindowReady
)
;
this
.
targetActor
.
off
(
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
targetActor
.
off
(
"
navigate
"
this
.
_onNavigate
)
;
this
.
sourcesManager
.
off
(
"
newSource
"
this
.
onNewSourceEvent
)
;
this
.
clearDebuggees
(
)
;
this
.
_threadLifetimePool
.
destroy
(
)
;
this
.
_threadLifetimePool
=
null
;
this
.
_dbg
=
null
;
this
.
_state
=
STATES
.
EXITED
;
super
.
destroy
(
)
;
}
isAttached
(
)
{
return
!
!
this
.
alreadyAttached
;
}
attach
(
options
)
{
if
(
this
.
alreadyAttached
)
{
return
;
}
if
(
this
.
state
=
=
=
STATES
.
EXITED
)
{
throw
{
error
:
"
exited
"
message
:
"
threadActor
has
exited
"
}
;
}
if
(
this
.
state
!
=
=
STATES
.
DETACHED
)
{
throw
{
error
:
"
wrongState
"
message
:
"
Current
state
is
"
+
this
.
state
}
;
}
this
.
dbg
.
onDebuggerStatement
=
this
.
onDebuggerStatement
;
this
.
dbg
.
onNewScript
=
this
.
onNewScript
;
this
.
dbg
.
onNewDebuggee
=
this
.
_onNewDebuggee
;
this
.
sourcesManager
.
on
(
"
newSource
"
this
.
onNewSourceEvent
)
;
this
.
reconfigure
(
options
)
;
this
.
_state
=
STATES
.
RUNNING
;
this
.
alreadyAttached
=
true
;
this
.
dbg
.
enable
(
)
;
if
(
Services
.
obs
)
{
this
.
wrappedJSObject
=
this
;
Services
.
obs
.
notifyObservers
(
this
"
devtools
-
thread
-
ready
"
)
;
}
}
toggleEventLogging
(
logEventBreakpoints
)
{
this
.
_options
.
logEventBreakpoints
=
logEventBreakpoints
;
return
this
.
_options
.
logEventBreakpoints
;
}
get
pauseOverlay
(
)
{
if
(
this
.
_pauseOverlay
)
{
return
this
.
_pauseOverlay
;
}
const
env
=
new
HighlighterEnvironment
(
)
;
env
.
initFromTargetActor
(
this
.
targetActor
)
;
const
highlighter
=
new
PausedDebuggerOverlay
(
env
{
resume
:
(
)
=
>
this
.
resume
(
null
)
stepOver
:
(
)
=
>
this
.
resume
(
{
type
:
"
next
"
}
)
}
)
;
this
.
_pauseOverlay
=
highlighter
;
return
highlighter
;
}
_canShowOverlay
(
)
{
if
(
this
.
targetActor
.
targetType
!
=
Targets
.
TYPES
.
FRAME
)
{
return
false
;
}
const
{
window
}
=
this
.
targetActor
;
if
(
!
window
?
.
document
?
.
documentElement
)
{
return
false
;
}
if
(
window
.
isChromeWindow
)
{
return
false
;
}
return
true
;
}
async
showOverlay
(
)
{
if
(
!
this
.
_shouldShowPauseOverlay
|
|
!
this
.
isPaused
(
)
|
|
!
this
.
_canShowOverlay
(
)
)
{
return
;
}
const
reason
=
this
.
_priorPause
.
why
.
type
;
await
this
.
pauseOverlay
.
isReady
;
if
(
!
this
.
isPaused
(
)
)
{
return
;
}
this
.
pauseOverlay
.
show
(
reason
)
;
}
hideOverlay
(
)
{
if
(
this
.
_canShowOverlay
(
)
&
&
this
.
_pauseOverlay
)
{
this
.
pauseOverlay
.
hide
(
)
;
}
}
setBreakpointOnLoad
(
urls
)
{
this
.
_onLoadBreakpointURLs
=
new
Set
(
urls
)
;
}
_findXHRBreakpointIndex
(
p
m
)
{
return
this
.
_xhrBreakpoints
.
findIndex
(
(
{
path
method
}
)
=
>
path
=
=
=
p
&
&
method
=
=
=
m
)
;
}
_maybeClearPriorPause
(
location
)
{
if
(
!
this
.
_priorPause
)
{
return
;
}
const
{
where
}
=
this
.
_priorPause
.
frame
;
if
(
where
.
line
=
=
=
location
.
line
&
&
where
.
column
=
=
=
location
.
column
)
{
this
.
_priorPause
=
null
;
}
}
async
setBreakpoint
(
location
options
)
{
if
(
this
.
_state
=
=
=
STATES
.
DETACHED
)
{
this
.
attach
(
{
}
)
;
this
.
addAllSources
(
)
;
}
let
actor
=
this
.
breakpointActorMap
.
get
(
location
)
;
if
(
actor
&
&
JSON
.
stringify
(
actor
.
options
)
=
=
JSON
.
stringify
(
options
)
)
{
return
;
}
if
(
!
actor
)
{
actor
=
this
.
breakpointActorMap
.
getOrCreateBreakpointActor
(
location
)
;
}
actor
.
setOptions
(
options
)
;
this
.
_maybeClearPriorPause
(
location
)
;
if
(
location
.
sourceUrl
)
{
const
sourceActors
=
this
.
sourcesManager
.
getSourceActorsByURL
(
location
.
sourceUrl
)
;
for
(
const
sourceActor
of
sourceActors
)
{
await
sourceActor
.
applyBreakpoint
(
actor
)
;
}
}
else
{
const
sourceActor
=
this
.
sourcesManager
.
getSourceActorById
(
location
.
sourceId
)
;
if
(
sourceActor
)
{
await
sourceActor
.
applyBreakpoint
(
actor
)
;
}
}
}
removeBreakpoint
(
location
)
{
const
actor
=
this
.
breakpointActorMap
.
getOrCreateBreakpointActor
(
location
)
;
this
.
_maybeClearPriorPause
(
location
)
;
actor
.
delete
(
)
;
}
removeAllXHRBreakpoints
(
)
{
this
.
_xhrBreakpoints
=
[
]
;
return
this
.
_updateNetworkObserver
(
)
;
}
removeXHRBreakpoint
(
path
method
)
{
const
index
=
this
.
_findXHRBreakpointIndex
(
path
method
)
;
if
(
index
>
=
0
)
{
this
.
_xhrBreakpoints
.
splice
(
index
1
)
;
}
return
this
.
_updateNetworkObserver
(
)
;
}
setXHRBreakpoint
(
path
method
)
{
const
index
=
this
.
_findXHRBreakpointIndex
(
path
method
)
;
if
(
index
=
=
=
-
1
)
{
this
.
_xhrBreakpoints
.
push
(
{
path
method
}
)
;
}
return
this
.
_updateNetworkObserver
(
)
;
}
getAvailableEventBreakpoints
(
)
{
return
getAvailableEventBreakpoints
(
this
.
targetActor
.
targetGlobal
)
;
}
getActiveEventBreakpoints
(
)
{
return
Array
.
from
(
this
.
_activeEventBreakpoints
)
;
}
addEventBreakpoints
(
ids
)
{
this
.
setActiveEventBreakpoints
(
this
.
getActiveEventBreakpoints
(
)
.
concat
(
ids
)
)
;
}
removeEventBreakpoints
(
ids
)
{
this
.
setActiveEventBreakpoints
(
this
.
getActiveEventBreakpoints
(
)
.
filter
(
eventBp
=
>
!
ids
.
includes
(
eventBp
)
)
)
;
}
setActiveEventBreakpoints
(
ids
)
{
this
.
_activeEventBreakpoints
=
new
Set
(
ids
)
;
if
(
eventsRequireNotifications
(
ids
)
)
{
this
.
_debuggerNotificationObserver
.
addListener
(
this
.
_eventBreakpointListener
)
;
}
else
{
this
.
_debuggerNotificationObserver
.
removeListener
(
this
.
_eventBreakpointListener
)
;
}
if
(
this
.
_activeEventBreakpoints
.
has
(
firstStatementBreakpointId
(
)
)
)
{
this
.
_ensureFirstStatementBreakpointInitialized
(
)
;
this
.
_firstStatementBreakpoint
.
hit
=
frame
=
>
this
.
_pauseAndRespondEventBreakpoint
(
frame
firstStatementBreakpointId
(
)
)
;
}
else
if
(
this
.
_firstStatementBreakpoint
)
{
this
.
_firstStatementBreakpoint
.
hit
=
null
;
}
}
_ensureFirstStatementBreakpointInitialized
(
)
{
if
(
this
.
_firstStatementBreakpoint
)
{
return
;
}
this
.
_firstStatementBreakpoint
=
{
hit
:
null
}
;
for
(
const
script
of
this
.
dbg
.
findScripts
(
)
)
{
this
.
_maybeTrackFirstStatementBreakpoint
(
script
)
;
}
}
_maybeTrackFirstStatementBreakpointForNewGlobal
(
global
)
{
if
(
this
.
_firstStatementBreakpoint
)
{
for
(
const
script
of
this
.
dbg
.
findScripts
(
{
global
}
)
)
{
this
.
_maybeTrackFirstStatementBreakpoint
(
script
)
;
}
}
}
_maybeTrackFirstStatementBreakpoint
(
script
)
{
if
(
!
this
.
_firstStatementBreakpoint
|
|
script
.
format
!
=
=
"
js
"
|
|
script
.
isFunction
)
{
return
;
}
const
bps
=
script
.
getPossibleBreakpoints
(
)
;
let
meta
=
bps
.
find
(
bp
=
>
bp
.
isStepStart
)
|
|
bps
[
0
]
;
if
(
!
meta
)
{
meta
=
script
.
getAllColumnOffsets
(
)
[
0
]
;
}
if
(
!
meta
)
{
return
;
}
script
.
setBreakpoint
(
meta
.
offset
this
.
_firstStatementBreakpoint
)
;
}
_onNewDebuggee
(
global
)
{
this
.
_maybeTrackFirstStatementBreakpointForNewGlobal
(
global
)
;
try
{
this
.
_debuggerNotificationObserver
.
connect
(
global
.
unsafeDereference
(
)
)
;
}
catch
(
e
)
{
}
}
_updateNetworkObserver
(
)
{
if
(
isWorker
)
{
return
false
;
}
if
(
this
.
_xhrBreakpoints
.
length
&
&
!
this
.
_observingNetwork
)
{
this
.
_observingNetwork
=
true
;
Services
.
obs
.
addObserver
(
this
.
_onOpeningRequest
"
http
-
on
-
opening
-
request
"
)
;
}
else
if
(
this
.
_xhrBreakpoints
.
length
=
=
=
0
&
&
this
.
_observingNetwork
)
{
this
.
_observingNetwork
=
false
;
Services
.
obs
.
removeObserver
(
this
.
_onOpeningRequest
"
http
-
on
-
opening
-
request
"
)
;
}
return
true
;
}
_onOpeningRequest
(
subject
)
{
if
(
this
.
shouldSkipAnyBreakpoint
)
{
return
;
}
const
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
const
url
=
channel
.
URI
.
asciiSpec
;
const
requestMethod
=
channel
.
requestMethod
;
let
causeType
=
Ci
.
nsIContentPolicy
.
TYPE_OTHER
;
if
(
channel
.
loadInfo
)
{
causeType
=
channel
.
loadInfo
.
externalContentPolicyType
;
}
const
isXHR
=
causeType
=
=
=
Ci
.
nsIContentPolicy
.
TYPE_XMLHTTPREQUEST
|
|
causeType
=
=
=
Ci
.
nsIContentPolicy
.
TYPE_FETCH
;
if
(
!
isXHR
)
{
return
;
}
let
shouldPause
=
false
;
for
(
const
{
path
method
}
of
this
.
_xhrBreakpoints
)
{
if
(
method
!
=
=
"
ANY
"
&
&
method
!
=
=
requestMethod
)
{
continue
;
}
if
(
url
.
includes
(
path
)
)
{
shouldPause
=
true
;
break
;
}
}
if
(
shouldPause
)
{
const
frame
=
this
.
dbg
.
getNewestFrame
(
)
;
if
(
frame
)
{
this
.
_pauseAndRespond
(
frame
{
type
:
PAUSE_REASONS
.
XHR
}
)
;
}
}
}
reconfigure
(
options
=
{
}
)
{
if
(
this
.
state
=
=
STATES
.
EXITED
)
{
throw
{
error
:
"
wrongState
"
}
;
}
this
.
_options
=
{
.
.
.
this
.
_options
.
.
.
options
}
;
if
(
"
observeAsmJS
"
in
options
)
{
this
.
dbg
.
allowUnobservedAsmJS
=
!
options
.
observeAsmJS
;
}
if
(
"
observeWasm
"
in
options
)
{
this
.
dbg
.
allowUnobservedWasm
=
!
options
.
observeWasm
;
}
if
(
"
pauseOverlay
"
in
options
)
{
this
.
_shouldShowPauseOverlay
=
!
!
options
.
pauseOverlay
;
if
(
this
.
isPaused
(
)
)
{
if
(
!
this
.
_shouldShowPauseOverlay
)
{
this
.
hideOverlay
(
)
;
}
else
{
this
.
showOverlay
(
)
;
}
}
}
if
(
"
pauseWorkersUntilAttach
"
in
options
&
&
this
.
targetActor
.
pauseWorkersUntilAttach
)
{
this
.
targetActor
.
pauseWorkersUntilAttach
(
options
.
pauseWorkersUntilAttach
)
;
}
if
(
options
.
breakpoints
)
{
for
(
const
breakpoint
of
Object
.
values
(
options
.
breakpoints
)
)
{
this
.
setBreakpoint
(
breakpoint
.
location
breakpoint
.
options
)
;
}
}
if
(
options
.
eventBreakpoints
)
{
this
.
setActiveEventBreakpoints
(
options
.
eventBreakpoints
)
;
}
if
(
typeof
this
.
_options
.
shouldPauseOnDebuggerStatement
=
=
"
boolean
"
)
{
this
.
setPauseOnDebuggerStatement
(
this
.
_options
.
shouldPauseOnDebuggerStatement
)
;
}
this
.
setPauseOnExceptions
(
this
.
_options
.
pauseOnExceptions
)
;
}
_eventBreakpointListener
(
notification
)
{
if
(
this
.
_state
=
=
=
STATES
.
PAUSED
|
|
this
.
_state
=
=
=
STATES
.
DETACHED
)
{
return
;
}
const
eventBreakpoint
=
eventBreakpointForNotification
(
this
.
dbg
notification
)
;
if
(
!
this
.
_activeEventBreakpoints
.
has
(
eventBreakpoint
)
)
{
return
;
}
if
(
notification
.
phase
=
=
=
"
pre
"
&
&
!
this
.
_activeEventPause
)
{
this
.
_activeEventPause
=
this
.
_captureDebuggerHooks
(
)
;
this
.
dbg
.
onEnterFrame
=
this
.
_makeEventBreakpointEnterFrame
(
eventBreakpoint
)
;
}
else
if
(
notification
.
phase
=
=
=
"
post
"
&
&
this
.
_activeEventPause
)
{
this
.
_restoreDebuggerHooks
(
this
.
_activeEventPause
)
;
this
.
_activeEventPause
=
null
;
}
else
if
(
!
notification
.
phase
&
&
!
this
.
_activeEventPause
)
{
const
frame
=
this
.
dbg
.
getNewestFrame
(
)
;
if
(
frame
)
{
if
(
this
.
sourcesManager
.
isFrameBlackBoxed
(
frame
)
)
{
return
;
}
this
.
_pauseAndRespondEventBreakpoint
(
frame
eventBreakpoint
)
;
}
}
}
_makeEventBreakpointEnterFrame
(
eventBreakpoint
)
{
return
frame
=
>
{
if
(
this
.
sourcesManager
.
isFrameBlackBoxed
(
frame
)
)
{
return
undefined
;
}
this
.
_restoreDebuggerHooks
(
this
.
_activeEventPause
)
;
this
.
_activeEventPause
=
null
;
return
this
.
_pauseAndRespondEventBreakpoint
(
frame
eventBreakpoint
)
;
}
;
}
_pauseAndRespondEventBreakpoint
(
frame
eventBreakpoint
)
{
if
(
this
.
shouldSkipAnyBreakpoint
)
{
return
undefined
;
}
if
(
this
.
_options
.
logEventBreakpoints
)
{
return
logEvent
(
{
threadActor
:
this
frame
}
)
;
}
return
this
.
_pauseAndRespond
(
frame
{
type
:
PAUSE_REASONS
.
EVENT_BREAKPOINT
breakpoint
:
eventBreakpoint
message
:
makeEventBreakpointMessage
(
eventBreakpoint
)
}
)
;
}
_captureDebuggerHooks
(
)
{
return
{
onEnterFrame
:
this
.
dbg
.
onEnterFrame
onStep
:
this
.
dbg
.
onStep
onPop
:
this
.
dbg
.
onPop
}
;
}
_restoreDebuggerHooks
(
hooks
)
{
this
.
dbg
.
onEnterFrame
=
hooks
.
onEnterFrame
;
this
.
dbg
.
onStep
=
hooks
.
onStep
;
this
.
dbg
.
onPop
=
hooks
.
onPop
;
}
_pauseAndRespond
(
frame
reason
onPacket
=
k
=
>
k
)
{
try
{
const
packet
=
this
.
_paused
(
frame
)
;
if
(
!
packet
)
{
return
undefined
;
}
const
{
sourceActor
line
column
}
=
this
.
sourcesManager
.
getFrameLocation
(
frame
)
;
packet
.
why
=
reason
;
if
(
!
sourceActor
)
{
return
undefined
;
}
packet
.
frame
.
where
=
{
actor
:
sourceActor
.
actorID
line
column
}
;
const
pkt
=
onPacket
(
packet
)
;
this
.
_priorPause
=
pkt
;
this
.
emit
(
"
paused
"
pkt
)
;
this
.
showOverlay
(
)
;
}
catch
(
error
)
{
reportException
(
"
DBG
-
SERVER
"
error
)
;
this
.
conn
.
send
(
{
error
:
"
unknownError
"
message
:
error
.
message
+
"
\
n
"
+
error
.
stack
}
)
;
return
undefined
;
}
try
{
this
.
_nestedEventLoop
.
enter
(
)
;
}
catch
(
e
)
{
reportException
(
"
TA__pauseAndRespond
"
e
)
;
}
if
(
this
.
_requestedFrameRestart
)
{
return
null
;
}
return
this
.
_targetActorClosed
?
null
:
undefined
;
}
_makeOnEnterFrame
(
)
{
return
frame
=
>
{
if
(
this
.
_requestedFrameRestart
)
{
return
null
;
}
const
{
onStep
onPop
}
=
this
.
_makeSteppingHooks
(
{
steppingType
:
"
next
"
}
)
;
if
(
this
.
sourcesManager
.
isFrameBlackBoxed
(
frame
)
)
{
return
undefined
;
}
frame
.
onStep
=
onStep
;
frame
.
onPop
=
onPop
;
return
undefined
;
}
;
}
_makeOnPop
(
{
pauseAndRespond
steppingType
}
)
{
const
thread
=
this
;
return
function
(
completion
)
{
if
(
thread
.
_requestedFrameRestart
=
=
=
this
)
{
return
thread
.
restartFrame
(
this
)
;
}
if
(
steppingType
!
=
"
finish
"
&
&
(
completion
.
await
|
|
completion
.
yield
)
)
{
thread
.
suspendedFrame
=
this
;
thread
.
dbg
.
onEnterFrame
=
undefined
;
return
undefined
;
}
this
.
reportedPop
=
true
;
thread
.
suspendedFrame
=
this
;
if
(
steppingType
!
=
"
finish
"
&
&
!
thread
.
sourcesManager
.
isFrameBlackBoxed
(
this
)
)
{
const
pauseAndRespValue
=
pauseAndRespond
(
this
packet
=
>
thread
.
createCompletionGrip
(
packet
completion
)
)
;
if
(
thread
.
_requestedFrameRestart
=
=
=
this
)
{
return
thread
.
restartFrame
(
this
)
;
}
return
pauseAndRespValue
;
}
thread
.
_attachSteppingHooks
(
this
"
next
"
completion
)
;
return
undefined
;
}
;
}
restartFrame
(
frame
)
{
this
.
_requestedFrameRestart
=
null
;
this
.
_priorPause
=
null
;
if
(
frame
.
type
!
=
=
"
call
"
|
|
frame
.
script
.
isGeneratorFunction
|
|
frame
.
script
.
isAsyncFunction
)
{
return
undefined
;
}
RESTARTED_FRAMES
.
add
(
frame
)
;
const
completion
=
frame
.
callee
.
apply
(
frame
.
this
frame
.
arguments
)
;
return
completion
;
}
hasMoved
(
frame
newType
)
{
const
newLocation
=
this
.
sourcesManager
.
getFrameLocation
(
frame
)
;
if
(
!
this
.
_priorPause
)
{
return
true
;
}
const
{
type
}
=
this
.
_priorPause
.
why
;
if
(
type
=
=
newType
|
|
(
type
=
=
"
breakpointConditionThrown
"
&
&
newType
=
=
"
breakpoint
"
)
)
{
return
true
;
}
const
{
line
column
}
=
this
.
_priorPause
.
frame
.
where
;
return
line
!
=
=
newLocation
.
line
|
|
column
!
=
=
newLocation
.
column
;
}
_makeOnStep
(
{
pauseAndRespond
startFrame
completion
}
)
{
const
thread
=
this
;
return
function
(
)
{
if
(
thread
.
_validFrameStepOffset
(
this
startFrame
this
.
offset
)
)
{
return
pauseAndRespond
(
this
packet
=
>
thread
.
createCompletionGrip
(
packet
completion
)
)
;
}
return
undefined
;
}
;
}
_validFrameStepOffset
(
frame
startFrame
offset
)
{
const
meta
=
frame
.
script
.
getOffsetMetadata
(
offset
)
;
if
(
!
meta
.
isBreakpoint
|
|
this
.
sourcesManager
.
isFrameBlackBoxed
(
frame
)
|
|
!
this
.
hasMoved
(
frame
)
)
{
return
false
;
}
return
frame
!
=
=
startFrame
|
|
meta
.
isStepStart
;
}
atBreakpointLocation
(
frame
)
{
const
location
=
this
.
sourcesManager
.
getFrameLocation
(
frame
)
;
return
!
!
this
.
breakpointActorMap
.
get
(
location
)
;
}
createCompletionGrip
(
packet
completion
)
{
if
(
!
completion
)
{
return
packet
;
}
packet
.
why
.
frameFinished
=
{
}
;
if
(
completion
.
hasOwnProperty
(
"
return
"
)
)
{
packet
.
why
.
frameFinished
.
return
=
this
.
createValueGrip
(
completion
.
return
)
;
}
else
if
(
completion
.
hasOwnProperty
(
"
yield
"
)
)
{
packet
.
why
.
frameFinished
.
return
=
this
.
createValueGrip
(
completion
.
yield
)
;
}
else
if
(
completion
.
hasOwnProperty
(
"
throw
"
)
)
{
packet
.
why
.
frameFinished
.
throw
=
this
.
createValueGrip
(
completion
.
throw
)
;
}
return
packet
;
}
_makeSteppingHooks
(
{
steppingType
startFrame
completion
}
)
{
const
steppingHookState
=
{
pauseAndRespond
:
(
frame
onPacket
=
k
=
>
k
)
=
>
this
.
_pauseAndRespond
(
frame
{
type
:
PAUSE_REASONS
.
RESUME_LIMIT
}
onPacket
)
startFrame
:
startFrame
|
|
this
.
youngestFrame
steppingType
completion
}
;
return
{
onEnterFrame
:
this
.
_makeOnEnterFrame
(
steppingHookState
)
onPop
:
this
.
_makeOnPop
(
steppingHookState
)
onStep
:
this
.
_makeOnStep
(
steppingHookState
)
}
;
}
async
_handleResumeLimit
(
{
resumeLimit
frameActorID
}
)
{
const
steppingType
=
resumeLimit
.
type
;
if
(
!
[
"
break
"
"
step
"
"
next
"
"
finish
"
"
restart
"
]
.
includes
(
steppingType
)
)
{
return
Promise
.
reject
(
{
error
:
"
badParameterType
"
message
:
"
Unknown
resumeLimit
type
"
}
)
;
}
let
frame
=
this
.
youngestFrame
;
if
(
frameActorID
)
{
frame
=
this
.
_framesPool
.
getActorByID
(
frameActorID
)
.
frame
;
if
(
!
frame
)
{
throw
new
Error
(
"
Frame
should
exist
in
the
frames
pool
.
"
)
;
}
}
if
(
steppingType
=
=
=
"
restart
"
)
{
if
(
frame
.
type
!
=
=
"
call
"
|
|
frame
.
script
.
isGeneratorFunction
|
|
frame
.
script
.
isAsyncFunction
)
{
return
undefined
;
}
this
.
_requestedFrameRestart
=
frame
;
}
return
this
.
_attachSteppingHooks
(
frame
steppingType
undefined
)
;
}
_attachSteppingHooks
(
frame
steppingType
completion
)
{
if
(
steppingType
=
=
=
"
finish
"
&
&
frame
.
reportedPop
)
{
steppingType
=
"
next
"
;
}
const
stepFrame
=
this
.
_getNextStepFrame
(
frame
)
;
if
(
!
stepFrame
)
{
steppingType
=
"
step
"
;
}
const
{
onEnterFrame
onPop
onStep
}
=
this
.
_makeSteppingHooks
(
{
steppingType
completion
startFrame
:
frame
}
)
;
if
(
steppingType
=
=
=
"
step
"
|
|
steppingType
=
=
=
"
restart
"
)
{
this
.
dbg
.
onEnterFrame
=
onEnterFrame
;
}
if
(
stepFrame
)
{
switch
(
steppingType
)
{
case
"
step
"
:
case
"
break
"
:
case
"
next
"
:
if
(
stepFrame
.
script
)
{
if
(
!
this
.
sourcesManager
.
isFrameBlackBoxed
(
stepFrame
)
)
{
stepFrame
.
onStep
=
onStep
;
}
}
case
"
finish
"
:
stepFrame
.
onStep
=
createStepForReactionTracking
(
stepFrame
.
onStep
)
;
case
"
restart
"
:
stepFrame
.
onPop
=
onPop
;
break
;
}
}
return
true
;
}
_clearSteppingHooks
(
)
{
if
(
this
.
suspendedFrame
)
{
this
.
suspendedFrame
.
onStep
=
undefined
;
this
.
suspendedFrame
.
onPop
=
undefined
;
this
.
suspendedFrame
=
undefined
;
}
let
frame
=
this
.
youngestFrame
;
if
(
frame
?
.
onStack
)
{
while
(
frame
)
{
frame
.
onStep
=
undefined
;
frame
.
onPop
=
undefined
;
frame
=
frame
.
older
;
}
}
}
async
resume
(
resumeLimit
frameActorID
)
{
if
(
this
.
_state
!
=
=
STATES
.
PAUSED
)
{
return
{
error
:
"
wrongState
"
message
:
"
Can
'
t
resume
when
debuggee
isn
'
t
paused
.
Current
state
is
'
"
+
this
.
_state
+
"
'
"
state
:
this
.
_state
}
;
}
if
(
!
this
.
_nestedEventLoop
.
isTheLastPausedThreadActor
(
)
)
{
return
{
error
:
"
wrongOrder
"
message
:
"
trying
to
resume
in
the
wrong
order
.
"
}
;
}
try
{
if
(
resumeLimit
)
{
await
this
.
_handleResumeLimit
(
{
resumeLimit
frameActorID
}
)
;
}
else
{
this
.
_clearSteppingHooks
(
)
;
}
this
.
doResume
(
{
resumeLimit
}
)
;
return
{
}
;
}
catch
(
error
)
{
return
error
instanceof
Error
?
{
error
:
"
unknownError
"
message
:
DevToolsUtils
.
safeErrorString
(
error
)
}
:
error
;
}
}
doResume
(
)
{
this
.
_state
=
STATES
.
RUNNING
;
this
.
_pausePool
.
destroy
(
)
;
this
.
_pausePool
=
null
;
this
.
_pauseActor
=
null
;
this
.
_nestedEventLoop
.
exit
(
)
;
this
.
emit
(
"
resumed
"
)
;
this
.
hideOverlay
(
)
;
}
setPauseOnExceptions
(
doPause
)
{
if
(
doPause
)
{
this
.
dbg
.
onExceptionUnwind
=
this
.
_onExceptionUnwind
;
}
else
{
this
.
dbg
.
onExceptionUnwind
=
undefined
;
}
}
setPauseOnDebuggerStatement
(
doPause
)
{
this
.
dbg
.
onDebuggerStatement
=
doPause
?
this
.
onDebuggerStatement
:
undefined
;
}
isPauseOnExceptionsEnabled
(
)
{
return
this
.
dbg
.
onExceptionUnwind
=
=
this
.
_onExceptionUnwind
;
}
_getNextStepFrame
(
frame
)
{
const
endOfFrame
=
frame
.
reportedPop
;
const
stepFrame
=
endOfFrame
?
frame
.
older
|
|
getAsyncParentFrame
(
frame
)
:
frame
;
if
(
!
stepFrame
|
|
!
stepFrame
.
script
)
{
return
null
;
}
if
(
RESTARTED_FRAMES
.
has
(
stepFrame
)
)
{
return
this
.
_getNextStepFrame
(
stepFrame
.
older
)
;
}
return
stepFrame
;
}
frames
(
start
count
)
{
if
(
this
.
state
!
=
=
STATES
.
PAUSED
)
{
return
{
error
:
"
wrongState
"
message
:
"
Stack
frames
are
only
available
while
the
debuggee
is
paused
.
"
}
;
}
let
frame
=
this
.
youngestFrame
;
const
walkToParentFrame
=
(
)
=
>
{
if
(
!
frame
)
{
return
;
}
const
currentFrame
=
frame
;
frame
=
null
;
if
(
!
(
currentFrame
instanceof
Debugger
.
Frame
)
)
{
frame
=
getSavedFrameParent
(
this
currentFrame
)
;
}
else
if
(
currentFrame
.
older
)
{
frame
=
currentFrame
.
older
;
}
else
if
(
this
.
_options
.
shouldIncludeSavedFrames
&
&
currentFrame
.
olderSavedFrame
)
{
frame
=
currentFrame
.
olderSavedFrame
;
if
(
frame
&
&
!
isValidSavedFrame
(
this
frame
)
)
{
frame
=
null
;
}
}
else
if
(
this
.
_options
.
shouldIncludeAsyncLiveFrames
&
&
currentFrame
.
asyncPromise
)
{
const
asyncFrame
=
getAsyncParentFrame
(
currentFrame
)
;
if
(
asyncFrame
)
{
frame
=
asyncFrame
;
}
}
}
;
let
i
=
0
;
while
(
frame
&
&
i
<
start
)
{
walkToParentFrame
(
)
;
i
+
+
;
}
const
frames
=
[
]
;
for
(
;
frame
&
&
(
!
count
|
|
i
<
start
+
count
)
;
i
+
+
walkToParentFrame
(
)
)
{
if
(
frame
instanceof
Debugger
.
Frame
)
{
this
.
sourcesManager
.
createSourceActor
(
frame
.
script
.
source
)
;
}
if
(
RESTARTED_FRAMES
.
has
(
frame
)
)
{
continue
;
}
const
frameActor
=
this
.
_createFrameActor
(
frame
i
)
;
frames
.
push
(
frameActor
)
;
}
return
{
frames
}
;
}
addAllSources
(
)
{
const
urlMap
=
{
}
;
for
(
const
url
of
this
.
dbg
.
findSourceURLs
(
)
)
{
if
(
url
!
=
=
"
self
-
hosted
"
)
{
if
(
!
urlMap
[
url
]
)
{
urlMap
[
url
]
=
{
count
:
0
sources
:
[
]
hasWasm
:
false
}
;
}
urlMap
[
url
]
.
count
+
+
;
}
}
const
sources
=
this
.
dbg
.
findSources
(
)
;
for
(
const
source
of
sources
)
{
this
.
_addSource
(
source
)
;
if
(
source
.
introductionType
=
=
=
"
wasm
"
)
{
const
origURL
=
source
.
url
.
replace
(
/
^
wasm
:
/
"
"
)
;
if
(
urlMap
[
origURL
]
)
{
urlMap
[
origURL
]
.
hasWasm
=
true
;
}
}
if
(
!
source
.
introductionScript
&
&
urlMap
[
source
.
url
]
)
{
urlMap
[
source
.
url
]
.
count
-
-
;
urlMap
[
source
.
url
]
.
sources
.
push
(
source
)
;
}
}
for
(
const
[
url
data
]
of
Object
.
entries
(
urlMap
)
)
{
if
(
data
.
count
>
0
)
{
this
.
_resurrectSource
(
url
data
.
sources
data
.
hasWasm
)
;
}
}
}
sources
(
)
{
this
.
addAllSources
(
)
;
const
forms
=
[
]
;
for
(
const
source
of
this
.
sourcesManager
.
iter
(
)
)
{
forms
.
push
(
source
.
form
(
)
)
;
}
return
forms
;
}
disableAllBreakpoints
(
)
{
for
(
const
bpActor
of
this
.
breakpointActorMap
.
findActors
(
)
)
{
bpActor
.
removeScripts
(
)
;
}
}
removeAllBreakpoints
(
)
{
this
.
breakpointActorMap
.
removeAllBreakpoints
(
)
;
}
removeAllWatchpoints
(
)
{
for
(
const
actor
of
this
.
threadLifetimePool
.
poolChildren
(
)
)
{
if
(
actor
.
typeName
=
=
"
obj
"
)
{
actor
.
removeWatchpoints
(
)
;
}
}
}
addWatchpoint
(
objActor
data
)
{
this
.
_watchpointsMap
.
add
(
objActor
data
)
;
}
removeWatchpoint
(
objActor
property
)
{
this
.
_watchpointsMap
.
remove
(
objActor
property
)
;
}
getWatchpoint
(
obj
property
)
{
return
this
.
_watchpointsMap
.
get
(
obj
property
)
;
}
interrupt
(
when
)
{
if
(
this
.
state
=
=
STATES
.
EXITED
)
{
return
{
type
:
"
exited
"
}
;
}
else
if
(
this
.
state
=
=
STATES
.
PAUSED
)
{
this
.
emit
(
"
paused
"
{
why
:
{
type
:
PAUSE_REASONS
.
ALREADY_PAUSED
}
}
)
;
return
{
}
;
}
else
if
(
this
.
state
!
=
STATES
.
RUNNING
)
{
return
{
error
:
"
wrongState
"
message
:
"
Received
interrupt
request
in
"
+
this
.
state
+
"
state
.
"
}
;
}
try
{
if
(
when
=
=
"
onNext
"
)
{
const
onEnterFrame
=
frame
=
>
{
this
.
_pauseAndRespond
(
frame
{
type
:
PAUSE_REASONS
.
INTERRUPTED
onNext
:
true
}
)
;
}
;
this
.
dbg
.
onEnterFrame
=
onEnterFrame
;
return
{
}
;
}
const
packet
=
this
.
_paused
(
)
;
if
(
!
packet
)
{
return
{
error
:
"
notInterrupted
"
}
;
}
packet
.
why
=
{
type
:
PAUSE_REASONS
.
INTERRUPTED
onNext
:
false
}
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
interrupt
"
}
)
;
this
.
emit
(
"
paused
"
packet
)
;
this
.
_nestedEventLoop
.
enter
(
)
;
return
null
;
}
catch
(
e
)
{
reportException
(
"
DBG
-
SERVER
"
e
)
;
return
{
error
:
"
notInterrupted
"
message
:
e
.
toString
(
)
}
;
}
}
_paused
(
frame
)
{
if
(
this
.
state
=
=
=
STATES
.
PAUSED
)
{
return
undefined
;
}
this
.
_state
=
STATES
.
PAUSED
;
this
.
dbg
.
onEnterFrame
=
undefined
;
this
.
_requestedFrameRestart
=
null
;
this
.
_clearSteppingHooks
(
)
;
assert
(
!
this
.
_pausePool
"
No
pause
pool
should
exist
yet
"
)
;
this
.
_pausePool
=
new
ObjectActorPool
(
this
"
pause
"
true
)
;
this
.
_pausePool
.
threadActor
=
this
;
assert
(
!
this
.
_pauseActor
"
No
pause
actor
should
exist
yet
"
)
;
this
.
_pauseActor
=
new
PauseActor
(
this
.
_pausePool
)
;
this
.
_pausePool
.
manage
(
this
.
_pauseActor
)
;
this
.
_updateFrames
(
)
;
const
packet
=
{
actor
:
this
.
_pauseActor
.
actorID
}
;
if
(
frame
)
{
packet
.
frame
=
this
.
_createFrameActor
(
frame
)
;
}
return
packet
;
}
_updateFrames
(
)
{
const
framesPool
=
new
Pool
(
this
.
conn
"
frames
"
)
;
const
frameList
=
[
]
;
for
(
const
frameActor
of
this
.
_frameActors
)
{
if
(
frameActor
.
frame
.
onStack
)
{
framesPool
.
manage
(
frameActor
)
;
frameList
.
push
(
frameActor
)
;
}
}
if
(
this
.
_framesPool
)
{
this
.
_framesPool
.
destroy
(
)
;
}
this
.
_frameActors
=
frameList
;
this
.
_framesPool
=
framesPool
;
}
_createFrameActor
(
frame
depth
)
{
let
actor
=
this
.
_frameActorMap
.
get
(
frame
)
;
if
(
!
actor
|
|
actor
.
isDestroyed
(
)
)
{
actor
=
new
FrameActor
(
frame
this
depth
)
;
this
.
_frameActors
.
push
(
actor
)
;
this
.
_framesPool
.
manage
(
actor
)
;
this
.
_frameActorMap
.
set
(
frame
actor
)
;
}
return
actor
;
}
createEnvironmentActor
(
environment
pool
)
{
if
(
!
environment
)
{
return
undefined
;
}
if
(
environment
.
actor
)
{
return
environment
.
actor
;
}
const
actor
=
new
EnvironmentActor
(
environment
this
)
;
pool
.
manage
(
actor
)
;
environment
.
actor
=
actor
;
return
actor
;
}
createValueGrip
(
value
)
{
const
pool
=
this
.
_pausePool
|
|
this
.
threadLifetimePool
;
return
createValueGrip
(
this
value
pool
)
;
}
_onWindowReady
(
{
isTopLevel
isBFCache
}
)
{
if
(
isTopLevel
&
&
this
.
state
!
=
STATES
.
DETACHED
)
{
this
.
sourcesManager
.
reset
(
)
;
this
.
clearDebuggees
(
)
;
this
.
dbg
.
enable
(
)
;
}
if
(
this
.
attached
)
{
this
.
dbg
.
addDebuggees
(
)
;
}
if
(
isBFCache
)
{
this
.
addAllSources
(
)
;
}
}
_onWillNavigate
(
{
isTopLevel
}
)
{
if
(
!
isTopLevel
)
{
return
;
}
if
(
this
.
state
=
=
STATES
.
PAUSED
)
{
this
.
doResume
(
)
;
this
.
dbg
.
disable
(
)
;
}
this
.
removeAllWatchpoints
(
)
;
this
.
disableAllBreakpoints
(
)
;
this
.
dbg
.
onEnterFrame
=
undefined
;
}
_onNavigate
(
)
{
if
(
this
.
state
=
=
STATES
.
RUNNING
)
{
this
.
dbg
.
enable
(
)
;
}
}
pauseForMutationBreakpoint
(
mutationType
targetNode
ancestorNode
action
=
"
"
)
{
if
(
!
[
"
subtreeModified
"
"
nodeRemoved
"
"
attributeModified
"
]
.
includes
(
mutationType
)
)
{
throw
new
Error
(
"
Unexpected
mutation
breakpoint
type
"
)
;
}
if
(
this
.
shouldSkipAnyBreakpoint
)
{
return
undefined
;
}
const
frame
=
this
.
dbg
.
getNewestFrame
(
)
;
if
(
!
frame
)
{
return
undefined
;
}
if
(
this
.
sourcesManager
.
isFrameBlackBoxed
(
frame
)
)
{
return
undefined
;
}
const
global
=
(
targetNode
.
ownerDocument
|
|
targetNode
)
.
defaultView
;
assert
(
global
&
&
this
.
dbg
.
hasDebuggee
(
global
)
)
;
const
targetObj
=
this
.
dbg
.
makeGlobalObjectReference
(
global
)
.
makeDebuggeeValue
(
targetNode
)
;
let
ancestorObj
=
null
;
if
(
ancestorNode
)
{
ancestorObj
=
this
.
dbg
.
makeGlobalObjectReference
(
global
)
.
makeDebuggeeValue
(
ancestorNode
)
;
}
return
this
.
_pauseAndRespond
(
frame
{
type
:
PAUSE_REASONS
.
MUTATION_BREAKPOINT
mutationType
message
:
DOM
Mutation
:
'
{
mutationType
}
'
}
pkt
=
>
{
pkt
.
why
.
nodeGrip
=
this
.
createValueGrip
(
targetObj
)
;
pkt
.
why
.
ancestorGrip
=
ancestorObj
?
this
.
createValueGrip
(
ancestorObj
)
:
null
;
pkt
.
why
.
action
=
action
;
return
pkt
;
}
)
;
}
onDebuggerStatement
(
frame
)
{
if
(
this
.
shouldSkipAnyBreakpoint
|
|
!
this
.
hasMoved
(
frame
"
debuggerStatement
"
)
|
|
this
.
sourcesManager
.
isFrameBlackBoxed
(
frame
)
|
|
this
.
atBreakpointLocation
(
frame
)
)
{
return
undefined
;
}
return
this
.
_pauseAndRespond
(
frame
{
type
:
PAUSE_REASONS
.
DEBUGGER_STATEMENT
}
)
;
}
skipBreakpoints
(
skip
)
{
this
.
_options
.
skipBreakpoints
=
skip
;
return
{
skip
}
;
}
pauseOnExceptions
(
pauseOnExceptions
ignoreCaughtExceptions
)
{
this
.
reconfigure
(
{
pauseOnExceptions
ignoreCaughtExceptions
}
)
;
return
{
}
;
}
_onExceptionUnwind
(
youngestFrame
value
)
{
if
(
this
.
isPaused
(
)
)
{
return
undefined
;
}
if
(
this
.
shouldSkipAnyBreakpoint
&
&
!
this
.
insideClientEvaluation
?
.
reportExceptionsWhenBreaksAreDisabled
)
{
return
undefined
;
}
let
willBeCaught
=
false
;
for
(
let
frame
=
youngestFrame
;
frame
!
=
null
;
frame
=
frame
.
older
)
{
if
(
frame
.
script
.
isInCatchScope
(
frame
.
offset
)
)
{
willBeCaught
=
true
;
break
;
}
}
if
(
willBeCaught
&
&
this
.
_options
.
ignoreCaughtExceptions
)
{
return
undefined
;
}
if
(
this
.
_handledFrameExceptions
.
has
(
youngestFrame
)
&
&
this
.
_handledFrameExceptions
.
get
(
youngestFrame
)
=
=
=
value
)
{
return
undefined
;
}
if
(
!
isWorker
&
&
value
=
=
Cr
.
NS_ERROR_NO_INTERFACE
)
{
return
undefined
;
}
if
(
this
.
insideClientEvaluation
)
{
return
undefined
;
}
if
(
this
.
sourcesManager
.
isFrameBlackBoxed
(
youngestFrame
)
)
{
return
undefined
;
}
for
(
let
frame
=
youngestFrame
.
older
;
frame
!
=
null
;
frame
=
frame
.
older
)
{
this
.
_handledFrameExceptions
.
set
(
frame
value
)
;
}
try
{
const
packet
=
this
.
_paused
(
youngestFrame
)
;
if
(
!
packet
)
{
return
undefined
;
}
packet
.
why
=
{
type
:
PAUSE_REASONS
.
EXCEPTION
exception
:
this
.
createValueGrip
(
value
)
}
;
this
.
emit
(
"
paused
"
packet
)
;
this
.
_nestedEventLoop
.
enter
(
)
;
}
catch
(
e
)
{
reportException
(
"
TA_onExceptionUnwind
"
e
)
;
}
return
undefined
;
}
onNewScript
(
script
)
{
this
.
_addSource
(
script
.
source
)
;
this
.
_maybeTrackFirstStatementBreakpoint
(
script
)
;
}
onNewSourceEvent
(
source
)
{
if
(
!
this
.
_shouldEmitNewSource
)
{
return
;
}
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
emit
(
"
newSource
"
{
source
:
source
.
form
(
)
}
)
;
}
)
;
}
_shouldEmitNewSource
=
true
;
disableNewSourceEvents
(
)
{
this
.
_shouldEmitNewSource
=
false
;
}
_acceptSource
(
source
)
{
if
(
this
.
targetActor
.
sessionContext
.
type
=
=
"
browser
-
element
"
&
&
source
.
url
.
endsWith
(
"
ExtensionContent
.
sys
.
mjs
"
)
)
{
return
false
;
}
return
true
;
}
_addSource
(
source
)
{
if
(
!
this
.
_acceptSource
(
source
)
)
{
return
;
}
let
sourceActor
;
if
(
this
.
_debuggerSourcesSeen
.
has
(
source
)
&
&
this
.
sourcesManager
.
hasSourceActor
(
source
)
)
{
sourceActor
=
this
.
sourcesManager
.
getSourceActor
(
source
)
;
sourceActor
.
resetDebuggeeScripts
(
)
;
}
else
{
sourceActor
=
this
.
sourcesManager
.
createSourceActor
(
source
)
;
}
const
sourceUrl
=
sourceActor
.
url
;
if
(
this
.
_onLoadBreakpointURLs
.
has
(
sourceUrl
)
)
{
this
.
setBreakpoint
(
{
sourceUrl
line
:
1
}
{
}
)
;
(
async
(
)
=
>
{
const
[
firstLine
]
=
await
sourceActor
.
getBreakableLines
(
)
;
if
(
firstLine
!
=
1
)
{
this
.
setBreakpoint
(
{
sourceUrl
line
:
firstLine
}
{
}
)
;
}
}
)
(
)
;
}
const
bpActors
=
this
.
breakpointActorMap
.
findActors
(
)
.
filter
(
actor
=
>
actor
.
location
.
sourceUrl
&
&
actor
.
location
.
sourceUrl
=
=
sourceUrl
)
;
for
(
const
actor
of
bpActors
)
{
sourceActor
.
applyBreakpoint
(
actor
)
;
}
this
.
_debuggerSourcesSeen
.
add
(
source
)
;
}
async
_resurrectSource
(
url
existingInlineSources
forceEnableAsmJS
)
{
let
{
content
contentType
sourceMapURL
}
=
await
this
.
sourcesManager
.
urlContents
(
url
false
true
)
;
content
=
content
.
replace
(
/
\
r
\
n
?
|
\
u2028
|
\
u2029
/
g
"
\
n
"
)
;
if
(
contentType
=
=
"
text
/
html
"
)
{
if
(
!
this
.
targetActor
.
window
)
{
return
;
}
const
scriptTagMatches
=
content
.
matchAll
(
/
<
script
[
^
>
]
*
>
/
gi
)
;
const
scriptStartOffsets
=
[
.
.
.
scriptTagMatches
]
.
map
(
rv
=
>
rv
.
index
+
rv
[
0
]
.
length
)
;
const
document
=
new
DOMParser
(
)
.
parseFromString
(
content
"
text
/
html
"
)
;
[
.
.
.
document
.
scripts
]
.
forEach
(
script
=
>
{
const
text
=
script
.
innerText
;
if
(
script
.
src
)
{
return
;
}
if
(
!
text
.
trim
(
)
)
{
return
;
}
const
scriptStartOffsetIndex
=
scriptStartOffsets
.
findIndex
(
offset
=
>
content
.
substring
(
offset
offset
+
text
.
length
)
=
=
text
)
;
if
(
scriptStartOffsetIndex
=
=
-
1
)
{
return
;
}
const
scriptStartOffset
=
scriptStartOffsets
[
scriptStartOffsetIndex
]
;
scriptStartOffsets
.
splice
(
scriptStartOffsetIndex
1
)
;
const
allLineBreaks
=
[
.
.
.
content
.
substring
(
0
scriptStartOffset
)
.
matchAll
(
"
\
n
"
)
]
;
const
startLine
=
1
+
allLineBreaks
.
length
;
const
startColumn
=
1
+
scriptStartOffset
-
(
allLineBreaks
.
length
?
allLineBreaks
.
at
(
-
1
)
.
index
-
1
:
0
)
;
if
(
existingInlineSources
.
find
(
source
=
>
source
.
startLine
=
=
startLine
&
&
source
.
startColumn
=
=
startColumn
)
)
{
return
;
}
try
{
const
global
=
this
.
dbg
.
getDebuggees
(
)
[
0
]
;
this
.
_addSource
(
global
.
createSource
(
{
text
url
startLine
startColumn
isScriptElement
:
true
forceEnableAsmJS
}
)
)
;
}
catch
(
e
)
{
}
}
)
;
if
(
document
.
scripts
.
length
)
{
return
;
}
}
try
{
const
global
=
this
.
dbg
.
getDebuggees
(
)
[
0
]
;
this
.
_addSource
(
global
.
createSource
(
{
text
:
content
url
startLine
:
1
sourceMapURL
forceEnableAsmJS
}
)
)
;
}
catch
(
e
)
{
}
}
dumpThread
(
)
{
return
{
pauseOnExceptions
:
this
.
_options
.
pauseOnExceptions
ignoreCaughtExceptions
:
this
.
_options
.
ignoreCaughtExceptions
logEventBreakpoints
:
this
.
_options
.
logEventBreakpoints
skipBreakpoints
:
this
.
shouldSkipAnyBreakpoint
breakpoints
:
this
.
breakpointActorMap
.
listKeys
(
)
}
;
}
dumpPools
(
)
{
return
this
.
conn
.
dumpPools
(
)
;
}
logLocation
(
prefix
frame
)
{
const
loc
=
this
.
sourcesManager
.
getFrameLocation
(
frame
)
;
dump
(
{
prefix
}
(
{
loc
.
line
}
{
loc
.
column
}
)
\
n
)
;
}
}
exports
.
ThreadActor
=
ThreadActor
;
function
PauseActor
(
pool
)
{
this
.
pool
=
pool
;
}
PauseActor
.
prototype
=
{
typeName
:
"
pause
"
}
;
exports
.
unwrapDebuggerObjectGlobal
=
wrappedGlobal
=
>
{
try
{
const
global
=
wrappedGlobal
.
unsafeDereference
(
)
;
Object
.
getPrototypeOf
(
global
)
+
"
"
;
return
global
;
}
catch
(
e
)
{
return
undefined
;
}
}
;
