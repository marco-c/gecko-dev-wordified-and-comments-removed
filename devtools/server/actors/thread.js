"
use
strict
"
;
const
DebuggerNotificationObserver
=
require
(
"
DebuggerNotificationObserver
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Cr
Ci
}
=
require
(
"
chrome
"
)
;
const
{
ActorPool
}
=
require
(
"
devtools
/
server
/
actors
/
common
"
)
;
const
{
createValueGrip
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
{
ActorClassWithSpec
Actor
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
assert
dumpn
}
=
DevToolsUtils
;
const
{
threadSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
thread
"
)
;
const
{
getAvailableEventBreakpoints
eventBreakpointForNotification
makeEventBreakpointMessage
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
event
-
breakpoints
"
)
;
loader
.
lazyRequireGetter
(
this
"
EnvironmentActor
"
"
devtools
/
server
/
actors
/
environment
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BreakpointActorMap
"
"
devtools
/
server
/
actors
/
utils
/
breakpoint
-
actor
-
map
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
PauseScopedObjectActor
"
"
devtools
/
server
/
actors
/
pause
-
scoped
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EventLoopStack
"
"
devtools
/
server
/
actors
/
utils
/
event
-
loop
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
FrameActor
"
"
devtools
/
server
/
actors
/
frame
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
throttle
"
"
devtools
/
shared
/
throttle
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HighlighterEnvironment
"
"
devtools
/
server
/
actors
/
highlighters
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
PausedDebuggerOverlay
"
"
devtools
/
server
/
actors
/
highlighters
/
paused
-
debugger
"
true
)
;
const
ThreadActor
=
ActorClassWithSpec
(
threadSpec
{
initialize
:
function
(
parent
global
)
{
Actor
.
prototype
.
initialize
.
call
(
this
parent
.
conn
)
;
this
.
_state
=
"
detached
"
;
this
.
_frameActors
=
[
]
;
this
.
_parent
=
parent
;
this
.
_dbg
=
null
;
this
.
_gripDepth
=
0
;
this
.
_threadLifetimePool
=
null
;
this
.
_parentClosed
=
false
;
this
.
_scripts
=
null
;
this
.
_xhrBreakpoints
=
[
]
;
this
.
_observingNetwork
=
false
;
this
.
_activeEventBreakpoints
=
new
Set
(
)
;
this
.
_activeEventPause
=
null
;
this
.
_pauseOverlay
=
null
;
this
.
_priorPause
=
null
;
this
.
_options
=
{
autoBlackBox
:
false
}
;
this
.
breakpointActorMap
=
new
BreakpointActorMap
(
this
)
;
this
.
_debuggerSourcesSeen
=
null
;
this
.
_onLoadBreakpointURLs
=
new
Set
(
)
;
this
.
_handledFrameExceptions
=
new
WeakMap
(
)
;
this
.
global
=
global
;
this
.
onNewSourceEvent
=
this
.
onNewSourceEvent
.
bind
(
this
)
;
this
.
uncaughtExceptionHook
=
this
.
uncaughtExceptionHook
.
bind
(
this
)
;
this
.
createCompletionGrip
=
this
.
createCompletionGrip
.
bind
(
this
)
;
this
.
onDebuggerStatement
=
this
.
onDebuggerStatement
.
bind
(
this
)
;
this
.
onNewScript
=
this
.
onNewScript
.
bind
(
this
)
;
this
.
objectGrip
=
this
.
objectGrip
.
bind
(
this
)
;
this
.
pauseObjectGrip
=
this
.
pauseObjectGrip
.
bind
(
this
)
;
this
.
_onOpeningRequest
=
this
.
_onOpeningRequest
.
bind
(
this
)
;
this
.
_onNewDebuggee
=
this
.
_onNewDebuggee
.
bind
(
this
)
;
this
.
_eventBreakpointListener
=
this
.
_eventBreakpointListener
.
bind
(
this
)
;
this
.
_debuggerNotificationObserver
=
new
DebuggerNotificationObserver
(
)
;
if
(
Services
.
obs
)
{
this
.
wrappedJSObject
=
this
;
Services
.
obs
.
notifyObservers
(
this
"
devtools
-
thread
-
instantiated
"
)
;
}
}
_gripDepth
:
null
get
dbg
(
)
{
if
(
!
this
.
_dbg
)
{
this
.
_dbg
=
this
.
_parent
.
makeDebugger
(
)
;
this
.
_dbg
.
uncaughtExceptionHook
=
this
.
uncaughtExceptionHook
;
this
.
_dbg
.
onDebuggerStatement
=
this
.
onDebuggerStatement
;
this
.
_dbg
.
onNewScript
=
this
.
onNewScript
;
this
.
_dbg
.
onNewDebuggee
=
this
.
_onNewDebuggee
;
if
(
this
.
_dbg
.
replaying
)
{
this
.
_dbg
.
replayingOnForcedPause
=
this
.
replayingOnForcedPause
.
bind
(
this
)
;
this
.
_dbg
.
replayingOnPositionChange
=
this
.
_makeReplayingOnPositionChange
(
)
;
}
this
.
_dbg
.
enabled
=
this
.
_state
!
=
"
detached
"
;
}
return
this
.
_dbg
;
}
get
globalDebugObject
(
)
{
if
(
!
this
.
_parent
.
window
|
|
this
.
dbg
.
replaying
)
{
return
null
;
}
return
this
.
dbg
.
makeGlobalObjectReference
(
this
.
_parent
.
window
)
;
}
get
state
(
)
{
return
this
.
_state
;
}
get
attached
(
)
{
return
(
this
.
state
=
=
"
attached
"
|
|
this
.
state
=
=
"
running
"
|
|
this
.
state
=
=
"
paused
"
)
;
}
get
threadLifetimePool
(
)
{
if
(
!
this
.
_threadLifetimePool
)
{
this
.
_threadLifetimePool
=
new
ActorPool
(
this
.
conn
)
;
this
.
conn
.
addActorPool
(
this
.
_threadLifetimePool
)
;
this
.
_threadLifetimePool
.
objectActors
=
new
WeakMap
(
)
;
}
return
this
.
_threadLifetimePool
;
}
get
sources
(
)
{
return
this
.
_parent
.
sources
;
}
get
breakpoints
(
)
{
return
this
.
_parent
.
breakpoints
;
}
get
youngestFrame
(
)
{
if
(
this
.
state
!
=
"
paused
"
)
{
return
null
;
}
return
this
.
dbg
.
getNewestFrame
(
)
;
}
_threadPauseEventLoops
:
null
_pushThreadPause
:
function
(
)
{
if
(
this
.
dbg
.
replaying
)
{
this
.
dbg
.
replayPushThreadPause
(
)
;
}
if
(
!
this
.
_threadPauseEventLoops
)
{
this
.
_threadPauseEventLoops
=
[
]
;
}
const
eventLoop
=
this
.
_nestedEventLoops
.
push
(
)
;
this
.
_threadPauseEventLoops
.
push
(
eventLoop
)
;
eventLoop
.
enter
(
)
;
}
_popThreadPause
:
function
(
)
{
const
eventLoop
=
this
.
_threadPauseEventLoops
.
pop
(
)
;
assert
(
eventLoop
"
Should
have
an
event
loop
.
"
)
;
eventLoop
.
resolve
(
)
;
if
(
this
.
dbg
.
replaying
)
{
this
.
dbg
.
replayPopThreadPause
(
)
;
}
}
isPaused
(
)
{
return
this
.
_state
=
=
=
"
paused
"
;
}
clearDebuggees
:
function
(
)
{
if
(
this
.
_dbg
)
{
this
.
dbg
.
removeAllDebuggees
(
)
;
}
this
.
_sources
=
null
;
this
.
_scripts
=
null
;
}
destroy
:
function
(
)
{
dumpn
(
"
in
ThreadActor
.
prototype
.
destroy
"
)
;
if
(
this
.
_state
=
=
"
paused
"
)
{
this
.
doResume
(
)
;
}
this
.
_xhrBreakpoints
=
[
]
;
this
.
_updateNetworkObserver
(
)
;
this
.
_activeEventBreakpoints
=
new
Set
(
)
;
this
.
_debuggerNotificationObserver
.
removeListener
(
this
.
_eventBreakpointListener
)
;
for
(
const
global
of
this
.
dbg
.
getDebuggees
(
)
)
{
try
{
this
.
_debuggerNotificationObserver
.
disconnect
(
global
)
;
}
catch
(
e
)
{
}
}
this
.
sources
.
off
(
"
newSource
"
this
.
onNewSourceEvent
)
;
this
.
clearDebuggees
(
)
;
this
.
conn
.
removeActorPool
(
this
.
_threadLifetimePool
)
;
this
.
_threadLifetimePool
=
null
;
if
(
!
this
.
_dbg
)
{
return
;
}
this
.
_dbg
.
disable
(
)
;
this
.
_dbg
=
null
;
}
exit
:
function
(
)
{
this
.
destroy
(
)
;
this
.
_state
=
"
exited
"
;
Actor
.
prototype
.
destroy
.
call
(
this
)
;
}
onAttach
:
function
(
{
options
}
)
{
if
(
this
.
state
=
=
=
"
exited
"
)
{
return
{
error
:
"
exited
"
message
:
"
threadActor
has
exited
"
}
;
}
if
(
this
.
state
!
=
=
"
detached
"
)
{
return
{
error
:
"
wrongState
"
message
:
"
Current
state
is
"
+
this
.
state
}
;
}
this
.
_state
=
"
attached
"
;
this
.
_debuggerSourcesSeen
=
new
WeakSet
(
)
;
Object
.
assign
(
this
.
_options
options
|
|
{
}
)
;
this
.
sources
.
setOptions
(
this
.
_options
)
;
this
.
sources
.
on
(
"
newSource
"
this
.
onNewSourceEvent
)
;
this
.
_nestedEventLoops
=
new
EventLoopStack
(
{
hooks
:
this
.
_parent
connection
:
this
.
conn
thread
:
this
}
)
;
if
(
options
.
breakpoints
)
{
this
.
_setBreakpointsOnAttach
(
options
.
breakpoints
)
;
}
if
(
options
.
eventBreakpoints
)
{
this
.
setActiveEventBreakpoints
(
options
.
eventBreakpoints
)
;
}
this
.
dbg
.
enable
(
)
;
if
(
"
observeAsmJS
"
in
this
.
_options
)
{
this
.
dbg
.
allowUnobservedAsmJS
=
!
this
.
_options
.
observeAsmJS
;
}
if
(
this
.
_parent
.
onThreadAttached
)
{
this
.
_parent
.
onThreadAttached
(
)
;
}
try
{
const
packet
=
this
.
_paused
(
)
;
if
(
!
packet
)
{
return
{
error
:
"
notAttached
"
message
:
"
cannot
attach
could
not
create
pause
packet
"
}
;
}
packet
.
why
=
{
type
:
"
attached
"
}
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
}
)
;
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
paused
"
packet
)
;
this
.
_pushThreadPause
(
)
;
return
null
;
}
catch
(
e
)
{
reportError
(
e
)
;
return
{
error
:
"
notAttached
"
message
:
e
.
toString
(
)
}
;
}
}
_setBreakpointsOnAttach
(
breakpoints
)
{
for
(
const
{
location
options
}
of
Object
.
values
(
breakpoints
)
)
{
this
.
setBreakpoint
(
location
options
)
;
}
}
get
pauseOverlay
(
)
{
if
(
this
.
_pauseOverlay
)
{
return
this
.
_pauseOverlay
;
}
const
env
=
new
HighlighterEnvironment
(
)
;
env
.
initFromTargetActor
(
this
.
_parent
)
;
const
highlighter
=
new
PausedDebuggerOverlay
(
env
{
showOverlayStepButtons
:
this
.
_options
.
showOverlayStepButtons
resume
:
(
)
=
>
this
.
onResume
(
{
resumeLimit
:
null
}
)
stepOver
:
(
)
=
>
this
.
onResume
(
{
resumeLimit
:
{
type
:
"
next
"
}
}
)
}
)
;
this
.
_pauseOverlay
=
highlighter
;
return
highlighter
;
}
showOverlay
(
)
{
if
(
this
.
isPaused
(
)
&
&
this
.
_parent
.
on
&
&
this
.
_parent
.
window
.
document
&
&
!
this
.
_parent
.
window
.
isChromeWindow
&
&
this
.
pauseOverlay
)
{
const
reason
=
this
.
_priorPause
.
why
.
type
;
this
.
pauseOverlay
.
show
(
null
{
reason
}
)
;
}
}
hideOverlay
(
msg
)
{
if
(
this
.
_parent
.
window
.
document
&
&
this
.
_parent
.
on
&
&
!
this
.
_parent
.
window
.
isChromeWindow
)
{
this
.
pauseOverlay
.
hide
(
)
;
}
}
setBreakpointOnLoad
(
urls
)
{
this
.
_onLoadBreakpointURLs
=
new
Set
(
urls
)
;
}
_findXHRBreakpointIndex
(
p
m
)
{
return
this
.
_xhrBreakpoints
.
findIndex
(
(
{
path
method
}
)
=
>
path
=
=
=
p
&
&
method
=
=
=
m
)
;
}
setBreakpoint
(
location
options
)
{
const
actor
=
this
.
breakpointActorMap
.
getOrCreateBreakpointActor
(
location
)
;
actor
.
setOptions
(
options
)
;
if
(
location
.
sourceUrl
)
{
const
sourceActors
=
this
.
sources
.
getSourceActorsByURL
(
location
.
sourceUrl
)
;
sourceActors
.
map
(
sourceActor
=
>
sourceActor
.
applyBreakpoint
(
actor
)
)
;
}
else
{
const
sourceActor
=
this
.
sources
.
getSourceActorById
(
location
.
sourceId
)
;
if
(
sourceActor
)
{
sourceActor
.
applyBreakpoint
(
actor
)
;
}
}
}
removeBreakpoint
(
location
)
{
const
actor
=
this
.
breakpointActorMap
.
getOrCreateBreakpointActor
(
location
)
;
actor
.
delete
(
)
;
}
removeXHRBreakpoint
:
function
(
path
method
)
{
const
index
=
this
.
_findXHRBreakpointIndex
(
path
method
)
;
if
(
index
>
=
0
)
{
this
.
_xhrBreakpoints
.
splice
(
index
1
)
;
}
return
this
.
_updateNetworkObserver
(
)
;
}
setXHRBreakpoint
:
function
(
path
method
)
{
const
index
=
this
.
_findXHRBreakpointIndex
(
path
method
)
;
if
(
index
=
=
=
-
1
)
{
this
.
_xhrBreakpoints
.
push
(
{
path
method
}
)
;
}
return
this
.
_updateNetworkObserver
(
)
;
}
getAvailableEventBreakpoints
:
function
(
)
{
return
getAvailableEventBreakpoints
(
)
;
}
getActiveEventBreakpoints
:
function
(
)
{
return
Array
.
from
(
this
.
_activeEventBreakpoints
)
;
}
setActiveEventBreakpoints
:
function
(
ids
)
{
this
.
_activeEventBreakpoints
=
new
Set
(
ids
)
;
if
(
this
.
_activeEventBreakpoints
.
size
=
=
=
0
)
{
this
.
_debuggerNotificationObserver
.
removeListener
(
this
.
_eventBreakpointListener
)
;
}
else
{
this
.
_debuggerNotificationObserver
.
addListener
(
this
.
_eventBreakpointListener
)
;
}
}
_onNewDebuggee
(
global
)
{
try
{
this
.
_debuggerNotificationObserver
.
connect
(
global
)
;
}
catch
(
e
)
{
}
}
_updateNetworkObserver
(
)
{
if
(
isWorker
)
{
return
false
;
}
if
(
this
.
_xhrBreakpoints
.
length
>
0
&
&
!
this
.
_observingNetwork
)
{
this
.
_observingNetwork
=
true
;
Services
.
obs
.
addObserver
(
this
.
_onOpeningRequest
"
http
-
on
-
opening
-
request
"
)
;
}
else
if
(
this
.
_xhrBreakpoints
.
length
=
=
=
0
&
&
this
.
_observingNetwork
)
{
this
.
_observingNetwork
=
false
;
Services
.
obs
.
removeObserver
(
this
.
_onOpeningRequest
"
http
-
on
-
opening
-
request
"
)
;
}
return
true
;
}
_onOpeningRequest
:
function
(
subject
)
{
if
(
this
.
skipBreakpoints
)
{
return
;
}
const
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
const
url
=
channel
.
URI
.
asciiSpec
;
const
requestMethod
=
channel
.
requestMethod
;
let
causeType
=
Ci
.
nsIContentPolicy
.
TYPE_OTHER
;
if
(
channel
.
loadInfo
)
{
causeType
=
channel
.
loadInfo
.
externalContentPolicyType
;
}
const
isXHR
=
causeType
=
=
=
Ci
.
nsIContentPolicy
.
TYPE_XMLHTTPREQUEST
|
|
causeType
=
=
=
Ci
.
nsIContentPolicy
.
TYPE_FETCH
;
if
(
!
isXHR
)
{
return
;
}
let
shouldPause
=
false
;
for
(
const
{
path
method
}
of
this
.
_xhrBreakpoints
)
{
if
(
method
!
=
=
"
ANY
"
&
&
method
!
=
=
requestMethod
)
{
continue
;
}
if
(
url
.
includes
(
path
)
)
{
shouldPause
=
true
;
break
;
}
}
if
(
shouldPause
)
{
const
frame
=
this
.
dbg
.
getNewestFrame
(
)
;
if
(
frame
)
{
this
.
_pauseAndRespond
(
frame
{
type
:
"
XHR
"
}
)
;
}
}
}
onDetach
:
function
(
request
)
{
this
.
destroy
(
)
;
this
.
_state
=
"
detached
"
;
this
.
_debuggerSourcesSeen
=
null
;
dumpn
(
"
ThreadActor
.
prototype
.
onDetach
:
returning
'
detached
'
packet
"
)
;
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
detached
"
)
;
return
{
}
;
}
onReconfigure
:
function
(
request
)
{
if
(
this
.
state
=
=
"
exited
"
)
{
return
{
error
:
"
wrongState
"
}
;
}
const
options
=
request
.
options
|
|
{
}
;
if
(
"
observeAsmJS
"
in
options
)
{
this
.
dbg
.
allowUnobservedAsmJS
=
!
options
.
observeAsmJS
;
}
if
(
"
skipBreakpoints
"
in
options
)
{
this
.
skipBreakpoints
=
options
.
skipBreakpoints
;
}
if
(
"
pauseWorkersUntilAttach
"
in
options
)
{
if
(
this
.
_parent
.
pauseWorkersUntilAttach
)
{
this
.
_parent
.
pauseWorkersUntilAttach
(
options
.
pauseWorkersUntilAttach
)
;
}
}
Object
.
assign
(
this
.
_options
options
)
;
this
.
sources
.
setOptions
(
options
)
;
return
{
}
;
}
_eventBreakpointListener
(
notification
)
{
if
(
this
.
_state
=
=
=
"
paused
"
|
|
this
.
_state
=
=
=
"
detached
"
)
{
return
;
}
const
eventBreakpoint
=
eventBreakpointForNotification
(
this
.
dbg
notification
)
;
if
(
!
this
.
_activeEventBreakpoints
.
has
(
eventBreakpoint
)
)
{
return
;
}
if
(
notification
.
phase
=
=
=
"
pre
"
&
&
!
this
.
_activeEventPause
)
{
this
.
_activeEventPause
=
this
.
_captureDebuggerHooks
(
)
;
this
.
dbg
.
onEnterFrame
=
this
.
_makeEventBreakpointEnterFrame
(
eventBreakpoint
)
;
}
else
if
(
notification
.
phase
=
=
=
"
post
"
&
&
this
.
_activeEventPause
)
{
this
.
_restoreDebuggerHooks
(
this
.
_activeEventPause
)
;
this
.
_activeEventPause
=
null
;
}
else
if
(
!
notification
.
phase
&
&
!
this
.
_activeEventPause
)
{
const
frame
=
this
.
dbg
.
getNewestFrame
(
)
;
if
(
frame
)
{
const
{
sourceActor
}
=
this
.
sources
.
getFrameLocation
(
frame
)
;
const
url
=
sourceActor
.
url
;
if
(
this
.
sources
.
isBlackBoxed
(
url
)
)
{
return
;
}
this
.
_pauseAndRespondEventBreakpoint
(
frame
eventBreakpoint
)
;
}
}
}
_makeEventBreakpointEnterFrame
(
eventBreakpoint
)
{
return
frame
=
>
{
const
{
sourceActor
}
=
this
.
sources
.
getFrameLocation
(
frame
)
;
const
url
=
sourceActor
.
url
;
if
(
this
.
sources
.
isBlackBoxed
(
url
)
)
{
return
undefined
;
}
this
.
_restoreDebuggerHooks
(
this
.
_activeEventPause
)
;
this
.
_activeEventPause
=
null
;
return
this
.
_pauseAndRespondEventBreakpoint
(
frame
eventBreakpoint
)
;
}
;
}
_pauseAndRespondEventBreakpoint
(
frame
eventBreakpoint
)
{
if
(
this
.
skipBreakpoints
)
{
return
undefined
;
}
return
this
.
_pauseAndRespond
(
frame
{
type
:
"
eventBreakpoint
"
breakpoint
:
eventBreakpoint
message
:
makeEventBreakpointMessage
(
eventBreakpoint
)
}
)
;
}
_captureDebuggerHooks
(
)
{
return
{
onEnterFrame
:
this
.
dbg
.
onEnterFrame
onStep
:
this
.
dbg
.
onStep
onPop
:
this
.
dbg
.
onPop
}
;
}
_restoreDebuggerHooks
(
hooks
)
{
this
.
dbg
.
onEnterFrame
=
hooks
.
onEnterFrame
;
this
.
dbg
.
onStep
=
hooks
.
onStep
;
this
.
dbg
.
onPop
=
hooks
.
onPop
;
}
_pauseAndRespond
:
function
(
frame
reason
onPacket
=
k
=
>
k
)
{
try
{
const
packet
=
this
.
_paused
(
frame
)
;
if
(
!
packet
)
{
return
undefined
;
}
packet
.
why
=
reason
;
const
{
sourceActor
line
column
}
=
this
.
sources
.
getFrameLocation
(
frame
)
;
if
(
!
sourceActor
)
{
return
undefined
;
}
packet
.
frame
.
where
=
{
actor
:
sourceActor
.
actorID
line
:
line
column
:
column
}
;
const
pkt
=
onPacket
(
packet
)
;
this
.
_priorPause
=
pkt
;
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
paused
"
pkt
)
;
this
.
showOverlay
(
)
;
}
catch
(
error
)
{
reportError
(
error
)
;
this
.
conn
.
send
(
{
error
:
"
unknownError
"
message
:
error
.
message
+
"
\
n
"
+
error
.
stack
}
)
;
return
undefined
;
}
try
{
this
.
_pushThreadPause
(
)
;
}
catch
(
e
)
{
reportError
(
e
"
Got
an
exception
during
TA__pauseAndRespond
:
"
)
;
}
return
this
.
_parentClosed
?
null
:
undefined
;
}
_makeOnEnterFrame
:
function
(
{
pauseAndRespond
}
)
{
return
frame
=
>
{
const
{
sourceActor
}
=
this
.
sources
.
getFrameLocation
(
frame
)
;
const
url
=
sourceActor
.
url
;
if
(
this
.
sources
.
isBlackBoxed
(
url
)
)
{
return
undefined
;
}
if
(
frame
.
script
.
getOffsetMetadata
(
frame
.
offset
)
.
isStepStart
)
{
return
pauseAndRespond
(
frame
)
;
}
const
{
onStep
onPop
}
=
this
.
_makeSteppingHooks
(
null
"
next
"
false
null
)
;
if
(
this
.
dbg
.
replaying
)
{
const
offsets
=
this
.
_findReplayingStepOffsets
(
null
frame
false
)
;
frame
.
setReplayingOnStep
(
onStep
offsets
)
;
}
else
{
frame
.
onStep
=
onStep
;
}
frame
.
onPop
=
onPop
;
return
undefined
;
}
;
}
_makeOnPop
:
function
(
{
pauseAndRespond
startLocation
steppingType
}
)
{
const
thread
=
this
;
const
result
=
function
(
completion
)
{
const
location
=
thread
.
sources
.
getFrameLocation
(
this
)
;
const
{
sourceActor
}
=
location
;
const
url
=
sourceActor
.
url
;
if
(
thread
.
sources
.
isBlackBoxed
(
url
)
)
{
return
undefined
;
}
this
.
reportedPop
=
true
;
if
(
steppingType
=
=
"
finish
"
)
{
const
parentFrame
=
thread
.
_getNextStepFrame
(
this
)
;
if
(
parentFrame
&
&
parentFrame
.
script
)
{
const
ncompletion
=
thread
.
dbg
.
replaying
?
null
:
completion
;
const
{
onStep
onPop
}
=
thread
.
_makeSteppingHooks
(
location
"
next
"
false
ncompletion
)
;
if
(
thread
.
dbg
.
replaying
)
{
const
parentLocation
=
thread
.
sources
.
getFrameLocation
(
parentFrame
)
;
const
offsets
=
thread
.
_findReplayingStepOffsets
(
parentLocation
parentFrame
false
)
;
parentFrame
.
setReplayingOnStep
(
onStep
offsets
)
;
}
else
{
parentFrame
.
onStep
=
onStep
;
}
parentFrame
.
onPop
=
onPop
;
return
undefined
;
}
}
return
pauseAndRespond
(
this
packet
=
>
{
if
(
completion
)
{
thread
.
createCompletionGrip
(
packet
completion
)
;
}
else
{
packet
.
why
.
frameFinished
=
{
terminated
:
true
}
;
}
return
packet
;
}
)
;
}
;
result
.
location
=
startLocation
;
return
result
;
}
hasMoved
:
function
(
newLocation
newType
)
{
if
(
!
this
.
_priorPause
)
{
return
true
;
}
const
{
type
}
=
this
.
_priorPause
.
why
;
if
(
type
=
=
newType
)
{
return
true
;
}
const
{
line
column
}
=
this
.
_priorPause
.
frame
.
where
;
return
line
!
=
=
newLocation
.
line
|
|
column
!
=
=
newLocation
.
column
;
}
_intraFrameLocationIsStepTarget
:
function
(
startLocation
script
offset
)
{
if
(
!
script
.
getOffsetMetadata
(
offset
)
.
isBreakpoint
)
{
return
false
;
}
const
location
=
this
.
sources
.
getScriptOffsetLocation
(
script
offset
)
;
if
(
!
startLocation
|
|
startLocation
.
url
!
=
=
location
.
url
)
{
return
true
;
}
if
(
!
this
.
hasMoved
(
location
)
)
{
return
false
;
}
const
pausePoints
=
location
.
sourceActor
.
pausePoints
;
const
pausePoint
=
pausePoints
&
&
findPausePointForLocation
(
pausePoints
location
)
;
if
(
pausePoint
)
{
return
pausePoint
.
step
;
}
return
script
.
getOffsetMetadata
(
offset
)
.
isStepStart
;
}
_makeOnStep
:
function
(
{
pauseAndRespond
startFrame
startLocation
steppingType
completion
rewinding
}
)
{
const
thread
=
this
;
return
function
(
)
{
const
location
=
thread
.
sources
.
getFrameLocation
(
this
)
;
if
(
location
.
url
=
=
null
|
|
thread
.
sources
.
isBlackBoxed
(
location
.
url
)
)
{
return
undefined
;
}
if
(
rewinding
&
&
this
!
=
=
startFrame
)
{
return
pauseAndRespond
(
this
)
;
}
if
(
thread
.
_intraFrameLocationIsStepTarget
(
startLocation
this
.
script
this
.
offset
)
)
{
return
pauseAndRespond
(
this
packet
=
>
thread
.
createCompletionGrip
(
packet
completion
)
)
;
}
return
undefined
;
}
;
}
createCompletionGrip
:
function
(
packet
completion
)
{
if
(
!
completion
)
{
return
packet
;
}
const
createGrip
=
value
=
>
createValueGrip
(
value
this
.
_pausePool
this
.
objectGrip
)
;
packet
.
why
.
frameFinished
=
{
}
;
if
(
completion
.
hasOwnProperty
(
"
return
"
)
)
{
packet
.
why
.
frameFinished
.
return
=
createGrip
(
completion
.
return
)
;
}
else
if
(
completion
.
hasOwnProperty
(
"
yield
"
)
)
{
packet
.
why
.
frameFinished
.
return
=
createGrip
(
completion
.
yield
)
;
}
else
if
(
completion
.
hasOwnProperty
(
"
throw
"
)
)
{
packet
.
why
.
frameFinished
.
throw
=
createGrip
(
completion
.
throw
)
;
}
return
packet
;
}
_findReplayingStepOffsets
:
function
(
startLocation
frame
rewinding
)
{
const
worklist
=
[
frame
.
offset
]
seen
=
[
]
result
=
[
]
;
while
(
worklist
.
length
)
{
const
offset
=
worklist
.
pop
(
)
;
if
(
seen
.
includes
(
offset
)
)
{
continue
;
}
seen
.
push
(
offset
)
;
if
(
this
.
_intraFrameLocationIsStepTarget
(
startLocation
frame
.
script
offset
)
)
{
if
(
!
result
.
includes
(
offset
)
)
{
result
.
push
(
offset
)
;
}
}
else
{
const
neighbors
=
rewinding
?
frame
.
script
.
getPredecessorOffsets
(
offset
)
:
frame
.
script
.
getSuccessorOffsets
(
offset
)
;
for
(
const
n
of
neighbors
)
{
worklist
.
push
(
n
)
;
}
}
}
return
result
;
}
_makeSteppingHooks
:
function
(
startLocation
steppingType
rewinding
completion
)
{
const
steppingHookState
=
{
pauseAndRespond
:
(
frame
onPacket
=
k
=
>
k
)
=
>
this
.
_pauseAndRespond
(
frame
{
type
:
"
resumeLimit
"
}
onPacket
)
startFrame
:
this
.
youngestFrame
startLocation
:
startLocation
steppingType
:
steppingType
rewinding
:
rewinding
completion
}
;
return
{
onEnterFrame
:
this
.
_makeOnEnterFrame
(
steppingHookState
)
onPop
:
this
.
_makeOnPop
(
steppingHookState
)
onStep
:
this
.
_makeOnStep
(
steppingHookState
)
}
;
}
_handleResumeLimit
:
async
function
(
{
rewind
resumeLimit
}
)
{
let
steppingType
=
resumeLimit
.
type
;
const
rewinding
=
rewind
;
if
(
!
[
"
break
"
"
step
"
"
next
"
"
finish
"
"
warp
"
]
.
includes
(
steppingType
)
)
{
return
Promise
.
reject
(
{
error
:
"
badParameterType
"
message
:
"
Unknown
resumeLimit
type
"
}
)
;
}
if
(
steppingType
=
=
"
warp
"
)
{
return
true
;
}
if
(
steppingType
=
=
=
"
finish
"
&
&
this
.
youngestFrame
.
reportedPop
)
{
steppingType
=
"
next
"
;
}
const
location
=
this
.
sources
.
getFrameLocation
(
this
.
youngestFrame
)
;
const
{
onEnterFrame
onPop
onStep
}
=
this
.
_makeSteppingHooks
(
location
steppingType
rewinding
)
;
const
stepFrame
=
this
.
_getNextStepFrame
(
this
.
youngestFrame
rewinding
)
;
if
(
stepFrame
)
{
switch
(
steppingType
)
{
case
"
step
"
:
assert
(
!
rewinding
"
'
step
'
resume
limit
cannot
be
used
while
rewinding
"
)
;
this
.
dbg
.
onEnterFrame
=
onEnterFrame
;
case
"
break
"
:
case
"
next
"
:
if
(
stepFrame
.
script
)
{
if
(
this
.
dbg
.
replaying
)
{
const
offsets
=
this
.
_findReplayingStepOffsets
(
location
stepFrame
rewinding
)
;
stepFrame
.
setReplayingOnStep
(
onStep
offsets
)
;
}
else
{
stepFrame
.
onStep
=
onStep
;
}
}
case
"
finish
"
:
if
(
rewinding
)
{
let
olderFrame
=
stepFrame
.
older
;
while
(
olderFrame
&
&
!
olderFrame
.
script
)
{
olderFrame
=
olderFrame
.
older
;
}
if
(
olderFrame
)
{
const
offsets
=
this
.
_findReplayingStepOffsets
(
{
}
olderFrame
true
)
;
olderFrame
.
setReplayingOnStep
(
onStep
offsets
)
;
}
}
else
{
stepFrame
.
onPop
=
onPop
;
}
break
;
}
}
return
true
;
}
_clearSteppingHooks
:
function
(
)
{
if
(
this
.
dbg
.
replaying
)
{
this
.
dbg
.
replayClearSteppingHooks
(
)
;
}
else
{
let
frame
=
this
.
youngestFrame
;
if
(
frame
&
&
frame
.
live
)
{
while
(
frame
)
{
frame
.
onStep
=
undefined
;
frame
.
onPop
=
undefined
;
frame
=
frame
.
older
;
}
}
}
}
onResume
:
async
function
(
{
resumeLimit
rewind
}
)
{
if
(
this
.
_state
!
=
=
"
paused
"
)
{
return
{
error
:
"
wrongState
"
message
:
"
Can
'
t
resume
when
debuggee
isn
'
t
paused
.
Current
state
is
'
"
+
this
.
_state
+
"
'
"
state
:
this
.
_state
}
;
}
if
(
this
.
_nestedEventLoops
.
size
&
&
this
.
_nestedEventLoops
.
lastPausedUrl
&
&
(
this
.
_nestedEventLoops
.
lastPausedUrl
!
=
=
this
.
_parent
.
url
|
|
this
.
_nestedEventLoops
.
lastConnection
!
=
=
this
.
conn
)
)
{
return
{
error
:
"
wrongOrder
"
message
:
"
trying
to
resume
in
the
wrong
order
.
"
lastPausedUrl
:
this
.
_nestedEventLoops
.
lastPausedUrl
}
;
}
if
(
rewind
&
&
!
this
.
dbg
.
replaying
)
{
return
{
error
:
"
cantRewind
"
message
:
"
Can
'
t
rewind
a
debuggee
that
is
not
replaying
.
"
}
;
}
try
{
if
(
resumeLimit
)
{
await
this
.
_handleResumeLimit
(
{
resumeLimit
rewind
}
)
;
}
else
{
this
.
_clearSteppingHooks
(
)
;
}
this
.
doResume
(
{
resumeLimit
rewind
}
)
;
return
{
}
;
}
catch
(
error
)
{
return
error
instanceof
Error
?
{
error
:
"
unknownError
"
message
:
DevToolsUtils
.
safeErrorString
(
error
)
}
:
error
;
}
}
doResume
(
{
resumeLimit
rewind
}
=
{
}
)
{
if
(
this
.
dbg
.
replaying
)
{
if
(
resumeLimit
&
&
resumeLimit
.
type
=
=
"
warp
"
)
{
this
.
dbg
.
replayTimeWarp
(
resumeLimit
.
target
)
;
}
else
if
(
rewind
)
{
this
.
dbg
.
replayResumeBackward
(
)
;
}
else
{
this
.
dbg
.
replayResumeForward
(
)
;
}
}
this
.
maybePauseOnExceptions
(
)
;
this
.
_state
=
"
running
"
;
this
.
conn
.
removeActorPool
(
this
.
_pausePool
)
;
this
.
_pausePool
=
null
;
this
.
_pauseActor
=
null
;
this
.
_popThreadPause
(
)
;
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
resumed
"
)
;
this
.
hideOverlay
(
)
;
if
(
Services
.
obs
)
{
Services
.
obs
.
notifyObservers
(
this
"
devtools
-
thread
-
resumed
"
)
;
}
}
unsafeSynchronize
:
function
(
p
)
{
let
needNest
=
true
;
let
eventLoop
;
let
returnVal
;
p
.
then
(
resolvedVal
=
>
{
needNest
=
false
;
returnVal
=
resolvedVal
;
}
)
.
catch
(
error
=
>
{
reportError
(
error
"
Error
inside
unsafeSynchronize
:
"
)
;
}
)
.
then
(
(
)
=
>
{
if
(
eventLoop
)
{
eventLoop
.
resolve
(
)
;
}
}
)
;
if
(
needNest
)
{
eventLoop
=
this
.
_nestedEventLoops
.
push
(
)
;
eventLoop
.
enter
(
)
;
}
return
returnVal
;
}
maybePauseOnExceptions
:
function
(
)
{
if
(
this
.
_options
.
pauseOnExceptions
)
{
this
.
dbg
.
onExceptionUnwind
=
this
.
onExceptionUnwind
.
bind
(
this
)
;
}
else
{
this
.
dbg
.
onExceptionUnwind
=
undefined
;
}
}
_getNextStepFrame
:
function
(
frame
rewinding
)
{
const
endOfFrame
=
rewinding
?
frame
.
offset
=
=
frame
.
script
.
mainOffset
:
frame
.
reportedPop
;
const
stepFrame
=
endOfFrame
?
frame
.
older
:
frame
;
if
(
!
stepFrame
|
|
!
stepFrame
.
script
)
{
return
null
;
}
return
stepFrame
;
}
onFrames
:
function
(
request
)
{
if
(
this
.
state
!
=
=
"
paused
"
)
{
return
{
error
:
"
wrongState
"
message
:
"
Stack
frames
are
only
available
while
the
debuggee
is
paused
.
"
}
;
}
const
start
=
request
.
start
?
request
.
start
:
0
;
const
count
=
request
.
count
;
let
frame
=
this
.
youngestFrame
;
let
i
=
0
;
while
(
frame
&
&
i
<
start
)
{
frame
=
frame
.
older
;
i
+
+
;
}
const
frames
=
[
]
;
for
(
;
frame
&
&
(
!
count
|
|
i
<
start
+
count
)
;
i
+
+
frame
=
frame
.
older
)
{
const
form
=
this
.
_createFrameActor
(
frame
)
.
form
(
)
;
form
.
depth
=
i
;
let
frameItem
=
null
;
const
frameSourceActor
=
this
.
sources
.
createSourceActor
(
frame
.
script
.
source
)
;
if
(
frameSourceActor
)
{
form
.
where
=
{
actor
:
frameSourceActor
.
actorID
line
:
form
.
where
.
line
column
:
form
.
where
.
column
}
;
frameItem
=
form
;
}
frames
.
push
(
frameItem
)
;
}
return
{
frames
:
frames
.
filter
(
x
=
>
!
!
x
)
}
;
}
onSources
:
function
(
request
)
{
for
(
const
source
of
this
.
dbg
.
findSources
(
)
)
{
this
.
_addSource
(
source
)
;
}
return
{
sources
:
this
.
sources
.
iter
(
)
.
map
(
s
=
>
s
.
form
(
)
)
}
;
}
disableAllBreakpoints
:
function
(
)
{
for
(
const
bpActor
of
this
.
breakpointActorMap
.
findActors
(
)
)
{
bpActor
.
removeScripts
(
)
;
}
}
onInterrupt
:
function
(
{
when
}
)
{
if
(
this
.
state
=
=
"
exited
"
)
{
return
{
type
:
"
exited
"
}
;
}
else
if
(
this
.
state
=
=
"
paused
"
)
{
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
paused
"
{
why
:
{
type
:
"
alreadyPaused
"
}
}
)
;
return
{
}
;
}
else
if
(
this
.
state
!
=
"
running
"
)
{
return
{
error
:
"
wrongState
"
message
:
"
Received
interrupt
request
in
"
+
this
.
state
+
"
state
.
"
}
;
}
try
{
if
(
when
=
=
"
onNext
"
&
&
!
this
.
dbg
.
replaying
)
{
const
onEnterFrame
=
frame
=
>
{
this
.
_pauseAndRespond
(
frame
{
type
:
"
interrupted
"
onNext
:
true
}
)
;
}
;
this
.
dbg
.
onEnterFrame
=
onEnterFrame
;
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
willInterrupt
"
)
;
return
{
}
;
}
if
(
this
.
dbg
.
replaying
)
{
this
.
dbg
.
replayPause
(
)
;
}
const
packet
=
this
.
_paused
(
)
;
if
(
!
packet
)
{
return
{
error
:
"
notInterrupted
"
}
;
}
packet
.
why
=
{
type
:
"
interrupted
"
onNext
:
this
.
dbg
.
replaying
}
;
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
interrupt
"
}
)
;
this
.
conn
.
sendActorEvent
(
this
.
actorID
"
paused
"
packet
)
;
this
.
_pushThreadPause
(
)
;
return
null
;
}
catch
(
e
)
{
reportError
(
e
)
;
return
{
error
:
"
notInterrupted
"
message
:
e
.
toString
(
)
}
;
}
}
_requestFrame
:
function
(
frameID
)
{
if
(
!
frameID
)
{
return
this
.
youngestFrame
;
}
if
(
this
.
_framePool
.
has
(
frameID
)
)
{
return
this
.
_framePool
.
get
(
frameID
)
.
frame
;
}
return
undefined
;
}
_paused
:
function
(
frame
)
{
if
(
this
.
state
=
=
=
"
paused
"
)
{
return
undefined
;
}
this
.
_state
=
"
paused
"
;
this
.
dbg
.
onEnterFrame
=
undefined
;
this
.
dbg
.
onExceptionUnwind
=
undefined
;
this
.
_clearSteppingHooks
(
)
;
assert
(
!
this
.
_pausePool
"
No
pause
pool
should
exist
yet
"
)
;
this
.
_pausePool
=
new
ActorPool
(
this
.
conn
)
;
this
.
conn
.
addActorPool
(
this
.
_pausePool
)
;
this
.
_pausePool
.
threadActor
=
this
;
assert
(
!
this
.
_pauseActor
"
No
pause
actor
should
exist
yet
"
)
;
this
.
_pauseActor
=
new
PauseActor
(
this
.
_pausePool
)
;
this
.
_pausePool
.
addActor
(
this
.
_pauseActor
)
;
const
poppedFrames
=
this
.
_updateFrames
(
)
;
const
packet
=
{
from
:
this
.
actorID
type
:
"
paused
"
actor
:
this
.
_pauseActor
.
actorID
}
;
if
(
frame
)
{
packet
.
frame
=
this
.
_createFrameActor
(
frame
)
.
form
(
)
;
}
if
(
this
.
dbg
.
replaying
)
{
packet
.
executionPoint
=
this
.
dbg
.
replayCurrentExecutionPoint
(
)
;
packet
.
recordingEndpoint
=
this
.
dbg
.
replayRecordingEndpoint
(
)
;
}
if
(
poppedFrames
)
{
packet
.
poppedFrames
=
poppedFrames
;
}
return
packet
;
}
_updateFrames
:
function
(
)
{
const
popped
=
[
]
;
const
framePool
=
new
ActorPool
(
this
.
conn
)
;
const
frameList
=
[
]
;
for
(
const
frameActor
of
this
.
_frameActors
)
{
if
(
frameActor
.
frame
.
live
)
{
framePool
.
addActor
(
frameActor
)
;
frameList
.
push
(
frameActor
)
;
}
else
{
popped
.
push
(
frameActor
.
actorID
)
;
}
}
if
(
this
.
_framePool
)
{
this
.
conn
.
removeActorPool
(
this
.
_framePool
)
;
}
this
.
_frameActors
=
frameList
;
this
.
_framePool
=
framePool
;
this
.
conn
.
addActorPool
(
framePool
)
;
return
popped
;
}
_createFrameActor
:
function
(
frame
)
{
if
(
frame
.
actor
)
{
return
frame
.
actor
;
}
const
actor
=
new
FrameActor
(
frame
this
)
;
this
.
_frameActors
.
push
(
actor
)
;
this
.
_framePool
.
addActor
(
actor
)
;
frame
.
actor
=
actor
;
return
actor
;
}
createEnvironmentActor
:
function
(
environment
pool
)
{
if
(
!
environment
)
{
return
undefined
;
}
if
(
environment
.
actor
)
{
return
environment
.
actor
;
}
const
actor
=
new
EnvironmentActor
(
environment
this
)
;
pool
.
addActor
(
actor
)
;
environment
.
actor
=
actor
;
return
actor
;
}
createProtocolCompletionValue
:
function
(
completion
)
{
const
protoValue
=
{
}
;
if
(
completion
=
=
null
)
{
protoValue
.
terminated
=
true
;
}
else
if
(
"
return
"
in
completion
)
{
protoValue
.
return
=
createValueGrip
(
completion
.
return
this
.
_pausePool
this
.
objectGrip
)
;
}
else
if
(
"
throw
"
in
completion
)
{
protoValue
.
throw
=
createValueGrip
(
completion
.
throw
this
.
_pausePool
this
.
objectGrip
)
;
}
else
{
protoValue
.
return
=
createValueGrip
(
completion
.
yield
this
.
_pausePool
this
.
objectGrip
)
;
}
return
protoValue
;
}
objectGrip
:
function
(
value
pool
)
{
if
(
!
pool
.
objectActors
)
{
pool
.
objectActors
=
new
WeakMap
(
)
;
}
if
(
pool
.
objectActors
.
has
(
value
)
)
{
return
pool
.
objectActors
.
get
(
value
)
.
form
(
)
;
}
if
(
this
.
threadLifetimePool
.
objectActors
.
has
(
value
)
)
{
return
this
.
threadLifetimePool
.
objectActors
.
get
(
value
)
.
form
(
)
;
}
const
actor
=
new
PauseScopedObjectActor
(
value
{
getGripDepth
:
(
)
=
>
this
.
_gripDepth
incrementGripDepth
:
(
)
=
>
this
.
_gripDepth
+
+
decrementGripDepth
:
(
)
=
>
this
.
_gripDepth
-
-
createValueGrip
:
v
=
>
{
if
(
this
.
_pausePool
)
{
return
createValueGrip
(
v
this
.
_pausePool
this
.
pauseObjectGrip
)
;
}
return
createValueGrip
(
v
this
.
threadLifetimePool
this
.
objectGrip
)
;
}
sources
:
(
)
=
>
this
.
sources
createEnvironmentActor
:
(
e
p
)
=
>
this
.
createEnvironmentActor
(
e
p
)
promote
:
(
)
=
>
this
.
threadObjectGrip
(
actor
)
isThreadLifetimePool
:
(
)
=
>
actor
.
registeredPool
!
=
=
this
.
threadLifetimePool
getGlobalDebugObject
:
(
)
=
>
this
.
globalDebugObject
}
this
.
conn
)
;
pool
.
addActor
(
actor
)
;
pool
.
objectActors
.
set
(
value
actor
)
;
return
actor
.
form
(
)
;
}
pauseObjectGrip
:
function
(
value
)
{
if
(
!
this
.
_pausePool
)
{
throw
new
Error
(
"
Object
grip
requested
while
not
paused
.
"
)
;
}
return
this
.
objectGrip
(
value
this
.
_pausePool
)
;
}
threadObjectGrip
:
function
(
actor
)
{
actor
.
registeredPool
.
objectActors
.
delete
(
actor
.
obj
)
;
this
.
threadLifetimePool
.
addActor
(
actor
)
;
this
.
threadLifetimePool
.
objectActors
.
set
(
actor
.
obj
actor
)
;
}
onThreadGrips
:
function
(
request
)
{
if
(
this
.
state
!
=
"
paused
"
)
{
return
{
error
:
"
wrongState
"
}
;
}
if
(
!
request
.
actors
)
{
return
{
error
:
"
missingParameter
"
message
:
"
no
actors
were
specified
"
}
;
}
for
(
const
actorID
of
request
.
actors
)
{
const
actor
=
this
.
_pausePool
.
get
(
actorID
)
;
if
(
actor
)
{
this
.
threadObjectGrip
(
actor
)
;
}
}
return
{
}
;
}
uncaughtExceptionHook
:
function
(
exception
)
{
dumpn
(
"
Got
an
exception
:
"
+
exception
.
message
+
"
\
n
"
+
exception
.
stack
)
;
}
pauseForMutationBreakpoint
:
function
(
mutationType
)
{
if
(
!
[
"
subtreeModified
"
"
nodeRemoved
"
"
attributeModified
"
]
.
includes
(
mutationType
)
)
{
throw
new
Error
(
"
Unexpected
mutation
breakpoint
type
"
)
;
}
if
(
this
.
skipBreakpoints
)
{
return
;
}
const
frame
=
this
.
dbg
.
getNewestFrame
(
)
;
if
(
frame
)
{
this
.
_pauseAndRespond
(
frame
{
type
:
"
mutationBreakpoint
"
mutationType
message
:
DOM
Mutation
:
'
{
mutationType
}
'
}
)
;
}
}
onDebuggerStatement
:
function
(
frame
)
{
const
location
=
this
.
sources
.
getFrameLocation
(
frame
)
;
const
url
=
location
.
sourceActor
.
url
;
if
(
!
this
.
hasMoved
(
location
"
debuggerStatement
"
)
|
|
this
.
skipBreakpoints
|
|
this
.
sources
.
isBlackBoxed
(
url
)
)
{
return
undefined
;
}
return
this
.
_pauseAndRespond
(
frame
{
type
:
"
debuggerStatement
"
}
)
;
}
onSkipBreakpoints
:
function
(
{
skip
}
)
{
this
.
skipBreakpoints
=
skip
;
return
{
skip
}
;
}
onPauseOnExceptions
:
function
(
{
pauseOnExceptions
ignoreCaughtExceptions
}
)
{
Object
.
assign
(
this
.
_options
{
pauseOnExceptions
ignoreCaughtExceptions
}
)
;
this
.
maybePauseOnExceptions
(
)
;
return
{
}
;
}
_makeReplayingOnPositionChange
(
)
{
return
throttle
(
(
)
=
>
{
if
(
this
.
attached
)
{
const
recording
=
this
.
dbg
.
replayIsRecording
(
)
;
const
executionPoint
=
this
.
dbg
.
replayCurrentExecutionPoint
(
)
;
const
unscannedRegions
=
this
.
dbg
.
replayUnscannedRegions
(
)
;
const
cachedPoints
=
this
.
dbg
.
replayCachedPoints
(
)
;
this
.
conn
.
send
(
{
type
:
"
progress
"
from
:
this
.
actorID
recording
executionPoint
unscannedRegions
cachedPoints
}
)
;
}
}
100
)
;
}
replayingOnForcedPause
:
function
(
frame
)
{
if
(
frame
)
{
this
.
_pauseAndRespond
(
frame
{
type
:
"
replayForcedPause
"
}
)
;
}
else
{
const
packet
=
this
.
_paused
(
frame
)
;
if
(
!
packet
)
{
return
;
}
packet
.
why
=
"
replayForcedPause
"
;
this
.
conn
.
send
(
packet
)
;
this
.
_pushThreadPause
(
)
;
}
}
onExceptionUnwind
:
function
(
youngestFrame
value
)
{
let
willBeCaught
=
false
;
for
(
let
frame
=
youngestFrame
;
frame
!
=
null
;
frame
=
frame
.
older
)
{
if
(
frame
.
script
.
isInCatchScope
(
frame
.
offset
)
)
{
willBeCaught
=
true
;
break
;
}
}
if
(
willBeCaught
&
&
this
.
_options
.
ignoreCaughtExceptions
)
{
return
undefined
;
}
if
(
this
.
_handledFrameExceptions
.
has
(
youngestFrame
)
&
&
this
.
_handledFrameExceptions
.
get
(
youngestFrame
)
=
=
=
value
)
{
return
undefined
;
}
if
(
value
=
=
Cr
.
NS_ERROR_NO_INTERFACE
)
{
return
undefined
;
}
const
{
sourceActor
}
=
this
.
sources
.
getFrameLocation
(
youngestFrame
)
;
const
url
=
sourceActor
?
sourceActor
.
url
:
null
;
if
(
this
.
insideClientEvaluation
)
{
return
undefined
;
}
if
(
this
.
skipBreakpoints
|
|
this
.
sources
.
isBlackBoxed
(
url
)
)
{
return
undefined
;
}
for
(
let
frame
=
youngestFrame
.
older
;
frame
!
=
null
;
frame
=
frame
.
older
)
{
this
.
_handledFrameExceptions
.
set
(
frame
value
)
;
}
try
{
const
packet
=
this
.
_paused
(
youngestFrame
)
;
if
(
!
packet
)
{
return
undefined
;
}
packet
.
why
=
{
type
:
"
exception
"
exception
:
createValueGrip
(
value
this
.
_pausePool
this
.
objectGrip
)
}
;
this
.
conn
.
send
(
packet
)
;
this
.
_pushThreadPause
(
)
;
}
catch
(
e
)
{
reportError
(
e
"
Got
an
exception
during
TA_onExceptionUnwind
:
"
)
;
}
return
undefined
;
}
onNewScript
:
function
(
script
global
)
{
this
.
_addSource
(
script
.
source
)
;
}
onNewSourceEvent
:
function
(
source
)
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
this
.
conn
.
send
(
{
from
:
this
.
actorID
type
:
"
newSource
"
source
:
source
.
form
(
)
}
)
;
}
)
;
}
_addSource
:
function
(
source
)
{
if
(
!
this
.
sources
.
allowSource
(
source
)
)
{
return
false
;
}
let
sourceActor
;
if
(
this
.
_debuggerSourcesSeen
.
has
(
source
)
&
&
this
.
sources
.
hasSourceActor
(
source
)
)
{
sourceActor
=
this
.
sources
.
getSourceActor
(
source
)
;
}
else
{
sourceActor
=
this
.
sources
.
createSourceActor
(
source
)
;
}
const
sourceUrl
=
sourceActor
.
url
;
if
(
this
.
_onLoadBreakpointURLs
.
has
(
sourceUrl
)
)
{
this
.
setBreakpoint
(
{
sourceUrl
line
:
1
}
{
}
)
;
}
const
bpActors
=
this
.
breakpointActorMap
.
findActors
(
)
.
filter
(
actor
=
>
actor
.
location
.
sourceUrl
&
&
actor
.
location
.
sourceUrl
=
=
sourceUrl
)
;
for
(
const
actor
of
bpActors
)
{
sourceActor
.
applyBreakpoint
(
actor
)
;
}
this
.
_debuggerSourcesSeen
.
add
(
source
)
;
return
true
;
}
onDump
:
function
(
)
{
return
{
pauseOnExceptions
:
this
.
_options
.
pauseOnExceptions
ignoreCaughtExceptions
:
this
.
_options
.
ignoreCaughtExceptions
skipBreakpoints
:
this
.
skipBreakpoints
breakpoints
:
this
.
breakpointActorMap
.
listKeys
(
)
}
;
}
}
)
;
Object
.
assign
(
ThreadActor
.
prototype
.
requestTypes
{
attach
:
ThreadActor
.
prototype
.
onAttach
detach
:
ThreadActor
.
prototype
.
onDetach
reconfigure
:
ThreadActor
.
prototype
.
onReconfigure
resume
:
ThreadActor
.
prototype
.
onResume
frames
:
ThreadActor
.
prototype
.
onFrames
interrupt
:
ThreadActor
.
prototype
.
onInterrupt
sources
:
ThreadActor
.
prototype
.
onSources
threadGrips
:
ThreadActor
.
prototype
.
onThreadGrips
skipBreakpoints
:
ThreadActor
.
prototype
.
onSkipBreakpoints
pauseOnExceptions
:
ThreadActor
.
prototype
.
onPauseOnExceptions
dumpThread
:
ThreadActor
.
prototype
.
onDump
}
)
;
exports
.
ThreadActor
=
ThreadActor
;
function
PauseActor
(
pool
)
{
this
.
pool
=
pool
;
}
PauseActor
.
prototype
=
{
actorPrefix
:
"
pause
"
}
;
function
ChromeDebuggerActor
(
connection
parent
)
{
ThreadActor
.
prototype
.
initialize
.
call
(
this
parent
)
;
}
ChromeDebuggerActor
.
prototype
=
Object
.
create
(
ThreadActor
.
prototype
)
;
Object
.
assign
(
ChromeDebuggerActor
.
prototype
{
constructor
:
ChromeDebuggerActor
actorPrefix
:
"
chromeDebugger
"
}
)
;
exports
.
ChromeDebuggerActor
=
ChromeDebuggerActor
;
var
oldReportError
=
reportError
;
this
.
reportError
=
function
(
error
prefix
=
"
"
)
{
assert
(
error
instanceof
Error
"
Must
pass
Error
objects
to
reportError
"
)
;
const
msg
=
prefix
+
error
.
message
+
"
:
\
n
"
+
error
.
stack
;
oldReportError
(
msg
)
;
dumpn
(
msg
)
;
}
;
function
findPausePointForLocation
(
pausePoints
location
)
{
const
{
line
:
line
column
:
column
}
=
location
;
return
pausePoints
[
line
]
&
&
pausePoints
[
line
]
[
column
]
;
}
exports
.
unwrapDebuggerObjectGlobal
=
wrappedGlobal
=
>
{
try
{
const
global
=
wrappedGlobal
.
unsafeDereference
(
)
;
Object
.
getPrototypeOf
(
global
)
+
"
"
;
return
global
;
}
catch
(
e
)
{
return
undefined
;
}
}
;
