"
use
strict
"
;
const
DEFAULT_COLOR
=
"
grey
"
;
const
DEFAULT_CATEGORIES
=
[
{
name
:
"
Mixed
"
color
:
DEFAULT_COLOR
subcategories
:
[
"
Other
"
]
}
]
;
const
PREDEFINED_COLORS
=
{
interpreter
:
"
yellow
"
baseline
:
"
orange
"
ion
:
"
blue
"
wasm
:
"
purple
"
label
:
"
lightblue
"
}
;
const
INDEXES
=
{
stacks
:
{
prefix
:
0
frame
:
1
}
frames
:
{
location
:
0
relevantForJS
:
1
innerWindowID
:
2
implementation
:
3
line
:
4
column
:
5
category
:
6
subcategory
:
7
}
}
;
class
ProfilerTracingListener
{
constructor
(
{
targetActor
traceValues
traceActor
}
)
{
this
.
targetActor
=
targetActor
;
this
.
traceValues
=
traceValues
;
this
.
sourcesManager
=
targetActor
.
sourcesManager
;
this
.
traceActor
=
traceActor
;
this
.
#
reset
(
)
;
this
.
#
thread
=
this
.
#
getEmptyThread
(
)
;
this
.
#
startTime
=
ChromeUtils
.
dateNow
(
)
;
}
#
thread
=
null
;
#
stackMap
=
new
Map
(
)
;
#
frameMap
=
new
Map
(
)
;
#
categories
=
DEFAULT_CATEGORIES
;
#
currentStackIndex
=
null
;
#
startTime
=
null
;
stop
(
nativeTrace
)
{
if
(
nativeTrace
)
{
const
KIND_INDEX
=
0
;
const
LINENO_INDEX
=
1
;
const
COLUMN_INDEX
=
2
;
const
SCRIPT_ID_INDEX
=
3
;
const
FUNCTION_NAME_ID_INDEX
=
4
;
const
IMPLEMENTATION_INDEX
=
5
;
const
TIME_INDEX
=
6
;
const
LABEL_INDEX
=
1
;
const
LABEL_TIME_INDEX
=
2
;
const
IMPLEMENTATION_STRINGS
=
[
"
interpreter
"
"
baseline
"
"
ion
"
"
wasm
"
]
;
for
(
const
entry
of
nativeTrace
.
events
)
{
const
kind
=
entry
[
KIND_INDEX
]
;
switch
(
kind
)
{
case
Debugger
.
TRACING_EVENT_KIND_FUNCTION_ENTER
:
{
this
.
#
onFramePush
(
{
name
:
nativeTrace
.
atoms
[
entry
[
FUNCTION_NAME_ID_INDEX
]
]
url
:
nativeTrace
.
scriptURLs
[
entry
[
SCRIPT_ID_INDEX
]
]
lineNumber
:
entry
[
LINENO_INDEX
]
columnNumber
:
entry
[
COLUMN_INDEX
]
category
:
IMPLEMENTATION_STRINGS
[
entry
[
IMPLEMENTATION_INDEX
]
]
sourceId
:
entry
[
SCRIPT_ID_INDEX
]
}
entry
[
TIME_INDEX
]
)
;
break
;
}
case
Debugger
.
TRACING_EVENT_KIND_FUNCTION_LEAVE
:
{
this
.
#
onFramePop
(
entry
[
TIME_INDEX
]
false
)
;
break
;
}
case
Debugger
.
TRACING_EVENT_KIND_LABEL_ENTER
:
{
this
.
#
logDOMEvent
(
entry
[
LABEL_INDEX
]
entry
[
LABEL_TIME_INDEX
]
)
;
break
;
}
case
Debugger
.
TRACING_EVENT_KIND_LABEL_LEAVE
:
{
this
.
#
onFramePop
(
entry
[
LABEL_TIME_INDEX
]
false
)
;
break
;
}
}
}
}
const
profile
=
this
.
#
getEmptyProfile
(
)
;
profile
.
meta
.
categories
=
this
.
#
categories
;
profile
.
threads
.
push
(
this
.
#
thread
)
;
this
.
#
reset
(
)
;
return
profile
;
}
#
reset
(
)
{
this
.
#
thread
=
null
;
this
.
#
stackMap
=
new
Map
(
)
;
this
.
#
frameMap
=
new
Map
(
)
;
this
.
#
categories
=
DEFAULT_CATEGORIES
;
this
.
#
currentStackIndex
=
null
;
}
#
getEmptyProfile
(
)
{
const
httpHandler
=
isWorker
?
{
}
:
Cc
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
http
"
]
.
getService
(
Ci
.
nsIHttpProtocolHandler
)
;
return
{
meta
:
{
interval
:
1
startTime
:
this
.
#
startTime
product
:
Services
.
appinfo
?
.
name
importedFrom
:
"
JS
Tracer
"
version
:
28
presymbolicated
:
true
abi
:
Services
.
appinfo
?
.
XPCOMABI
misc
:
httpHandler
.
misc
oscpu
:
httpHandler
.
oscpu
platform
:
httpHandler
.
platform
processType
:
Services
.
appinfo
?
.
processType
categories
:
[
]
stackwalk
:
0
toolkit
:
Services
.
appinfo
?
.
widgetToolkit
appBuildID
:
Services
.
appinfo
?
.
appBuildID
sourceURL
:
Services
.
appinfo
?
.
sourceURL
physicalCPUs
:
0
logicalCPUs
:
0
CPUName
:
"
"
markerSchema
:
[
]
}
libs
:
[
]
pages
:
[
]
threads
:
[
]
processes
:
[
]
}
;
}
#
getEmptyThread
(
)
{
return
{
processType
:
"
default
"
processStartupTime
:
0
processShutdownTime
:
null
registerTime
:
0
unregisterTime
:
null
pausedRanges
:
[
]
name
:
"
GeckoMain
"
"
eTLD
+
1
"
:
"
JS
Tracer
"
isMainThread
:
true
pid
:
Services
.
appinfo
?
.
processID
tid
:
0
samples
:
{
schema
:
{
stack
:
0
time
:
1
eventDelay
:
2
}
data
:
[
]
}
markers
:
{
schema
:
{
name
:
0
startTime
:
1
endTime
:
2
phase
:
3
category
:
4
data
:
5
}
data
:
[
]
}
stackTable
:
{
schema
:
INDEXES
.
stacks
data
:
[
]
}
frameTable
:
{
schema
:
INDEXES
.
frames
data
:
[
]
}
stringTable
:
[
]
}
;
}
#
getOrCreateLabelFrame
(
label
)
{
const
{
frameTable
stringTable
}
=
this
.
#
thread
;
const
key
=
label
:
{
label
}
;
let
frameIndex
=
this
.
#
frameMap
.
get
(
key
)
;
if
(
frameIndex
=
=
=
undefined
)
{
frameIndex
=
frameTable
.
data
.
length
;
const
locationStringIndex
=
stringTable
.
length
;
stringTable
.
push
(
label
)
;
const
categoryIndex
=
this
.
#
getOrCreateCategory
(
"
label
"
)
;
frameTable
.
data
.
push
(
[
locationStringIndex
true
0
null
null
null
categoryIndex
0
]
)
;
this
.
#
frameMap
.
set
(
key
frameIndex
)
;
}
return
frameIndex
;
}
#
getOrCreateFrame
(
frameInfo
)
{
const
{
frameTable
stringTable
}
=
this
.
#
thread
;
const
key
=
{
frameInfo
.
sourceId
}
:
{
frameInfo
.
lineNumber
}
:
{
frameInfo
.
columnNumber
}
:
{
frameInfo
.
category
}
;
let
frameIndex
=
this
.
#
frameMap
.
get
(
key
)
;
if
(
frameIndex
=
=
=
undefined
)
{
frameIndex
=
frameTable
.
data
.
length
;
const
locationStringIndex
=
stringTable
.
length
;
stringTable
.
push
(
{
frameInfo
.
name
}
(
{
frameInfo
.
url
}
:
{
frameInfo
.
lineNumber
}
:
{
frameInfo
.
columnNumber
}
)
)
;
const
categoryIndex
=
this
.
#
getOrCreateCategory
(
frameInfo
.
category
)
;
frameTable
.
data
.
push
(
[
locationStringIndex
true
0
null
frameInfo
.
lineNumber
frameInfo
.
columnNumber
categoryIndex
0
]
)
;
this
.
#
frameMap
.
set
(
key
frameIndex
)
;
}
return
frameIndex
;
}
#
getOrCreateStack
(
frameIndex
prefix
)
{
const
{
stackTable
}
=
this
.
#
thread
;
const
key
=
prefix
=
=
=
null
?
{
frameIndex
}
:
{
frameIndex
}
{
prefix
}
;
let
stackIndex
=
this
.
#
stackMap
.
get
(
key
)
;
if
(
stackIndex
=
=
=
undefined
)
{
stackIndex
=
stackTable
.
data
.
length
;
stackTable
.
data
.
push
(
[
prefix
frameIndex
]
)
;
this
.
#
stackMap
.
set
(
key
stackIndex
)
;
}
return
stackIndex
;
}
#
getOrCreateCategory
(
category
)
{
const
categories
=
this
.
#
categories
;
let
categoryIndex
=
categories
.
findIndex
(
c
=
>
c
.
name
=
=
=
category
)
;
if
(
categoryIndex
=
=
=
-
1
)
{
categoryIndex
=
categories
.
length
;
categories
.
push
(
{
name
:
category
color
:
PREDEFINED_COLORS
[
category
]
?
?
DEFAULT_COLOR
subcategories
:
[
"
Other
"
]
}
)
;
}
return
categoryIndex
;
}
onTracingToggled
(
enabled
)
{
if
(
!
enabled
)
{
this
.
traceActor
.
stopTracing
(
)
;
}
return
false
;
}
onTracingPending
(
)
{
return
false
;
}
onTracingDOMMutation
(
{
depth
prefix
type
caller
element
}
)
{
return
false
;
}
onTracingFrameStep
(
{
frame
depth
prefix
}
)
{
return
false
;
}
onTracingFrame
(
{
frame
depth
formatedDisplayName
prefix
currentDOMEvent
}
)
{
const
{
script
}
=
frame
;
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
frame
.
offset
)
;
const
url
=
script
.
source
.
url
;
const
columnBase
=
script
.
format
=
=
=
"
wasm
"
?
0
:
1
;
const
column
=
columnNumber
-
columnBase
;
if
(
this
.
sourcesManager
.
isBlackBoxed
(
url
lineNumber
column
)
)
{
return
false
;
}
if
(
currentDOMEvent
&
&
depth
=
=
0
)
{
this
.
#
logDOMEvent
(
currentDOMEvent
)
;
}
this
.
#
onFramePush
(
{
name
:
formatedDisplayName
.
replace
(
"
"
"
"
)
url
lineNumber
columnNumber
category
:
frame
.
implementation
sourceId
:
script
.
source
.
id
}
)
;
return
false
;
}
#
logDOMEvent
(
domEventName
time
=
undefined
)
{
if
(
time
=
=
=
undefined
)
{
time
=
ChromeUtils
.
dateNow
(
)
;
}
const
frameIndex
=
this
.
#
getOrCreateLabelFrame
(
domEventName
)
;
this
.
#
currentStackIndex
=
this
.
#
getOrCreateStack
(
frameIndex
this
.
#
currentStackIndex
)
;
this
.
#
thread
.
samples
.
data
.
push
(
[
this
.
#
currentStackIndex
time
-
this
.
#
startTime
0
]
)
;
}
onTracingFrameExit
(
{
frameId
frame
depth
formatedDisplayName
prefix
why
rv
}
)
{
const
{
script
}
=
frame
;
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
frame
.
offset
)
;
const
url
=
script
.
source
.
url
;
const
columnBase
=
script
.
format
=
=
=
"
wasm
"
?
0
:
1
;
const
column
=
columnNumber
-
columnBase
;
if
(
this
.
sourcesManager
.
isBlackBoxed
(
url
lineNumber
column
)
)
{
return
false
;
}
this
.
#
onFramePop
(
)
;
return
false
;
}
#
onFramePush
(
frameInfo
time
)
{
if
(
time
=
=
=
undefined
)
{
time
=
ChromeUtils
.
dateNow
(
)
;
}
const
frameIndex
=
this
.
#
getOrCreateFrame
(
frameInfo
)
;
this
.
#
currentStackIndex
=
this
.
#
getOrCreateStack
(
frameIndex
this
.
#
currentStackIndex
)
;
this
.
#
thread
.
samples
.
data
.
push
(
[
this
.
#
currentStackIndex
time
-
this
.
#
startTime
0
]
)
;
}
#
onFramePop
(
time
=
undefined
autoPopLabels
=
true
)
{
if
(
this
.
#
currentStackIndex
=
=
=
null
)
{
return
;
}
if
(
time
=
=
=
undefined
)
{
time
=
ChromeUtils
.
dateNow
(
)
;
}
this
.
#
currentStackIndex
=
this
.
#
thread
.
stackTable
.
data
[
this
.
#
currentStackIndex
]
[
INDEXES
.
stacks
.
prefix
]
;
this
.
#
thread
.
samples
.
data
.
push
(
[
this
.
#
currentStackIndex
time
-
this
.
#
startTime
0
]
)
;
if
(
autoPopLabels
&
&
this
.
#
currentStackIndex
!
=
=
null
)
{
const
currentFrameIndex
=
this
.
#
thread
.
stackTable
.
data
[
this
.
#
currentStackIndex
]
[
INDEXES
.
stacks
.
frame
]
;
const
currentFrameLine
=
this
.
#
thread
.
frameTable
.
data
[
currentFrameIndex
]
[
INDEXES
.
frames
.
line
]
;
if
(
currentFrameLine
=
=
null
)
{
this
.
#
onFramePop
(
time
)
;
}
}
}
}
exports
.
ProfilerTracingListener
=
ProfilerTracingListener
;
