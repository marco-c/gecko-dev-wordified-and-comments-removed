"
use
strict
"
;
const
{
throttle
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
throttle
.
js
"
)
;
const
{
makeDebuggeeValue
createValueGripForTarget
}
=
require
(
"
devtools
/
server
/
actors
/
object
/
utils
"
)
;
const
{
TYPES
getResourceWatcher
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
resources
/
index
.
js
"
)
;
const
{
JSTRACER_TRACE
}
=
TYPES
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
JSTracer
:
"
resource
:
/
/
devtools
/
server
/
tracer
/
tracer
.
sys
.
mjs
"
}
{
global
:
"
contextual
"
}
)
;
const
{
getActorIdForInternalSourceId
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
dbg
-
source
.
js
"
)
;
const
THROTTLING_DELAY
=
250
;
class
ResourcesTracingListener
{
constructor
(
{
targetActor
traceValues
traceActor
}
)
{
this
.
targetActor
=
targetActor
;
this
.
traceValues
=
traceValues
;
this
.
sourcesManager
=
targetActor
.
sourcesManager
;
this
.
traceActor
=
traceActor
;
this
.
throttleEmitTraces
=
isWorker
?
this
.
flushTraces
.
bind
(
this
)
:
throttle
(
this
.
flushTraces
.
bind
(
this
)
THROTTLING_DELAY
)
;
}
#
throttledTraces
=
[
]
;
#
frameIndex
=
0
;
#
frameMap
=
new
Map
(
)
;
stop
(
)
{
this
.
#
frameIndex
=
0
;
this
.
#
frameMap
.
clear
(
)
;
}
flushTraces
(
)
{
const
traceWatcher
=
getResourceWatcher
(
this
.
targetActor
JSTRACER_TRACE
)
;
if
(
!
traceWatcher
)
{
return
;
}
const
traces
=
this
.
#
throttledTraces
;
this
.
#
throttledTraces
=
[
]
;
traceWatcher
.
emitTraces
(
traces
)
;
}
onTracingToggled
(
enabled
)
{
if
(
!
enabled
)
{
this
.
traceActor
.
stopTracing
(
)
;
}
return
false
;
}
onTracingPending
(
)
{
const
consoleMessageWatcher
=
getResourceWatcher
(
this
.
targetActor
TYPES
.
CONSOLE_MESSAGE
)
;
if
(
consoleMessageWatcher
)
{
consoleMessageWatcher
.
emitMessages
(
[
{
arguments
:
[
lazy
.
JSTracer
.
NEXT_INTERACTION_MESSAGE
]
styles
:
[
]
level
:
"
jstracer
"
chromeContext
:
false
timeStamp
:
ChromeUtils
.
dateNow
(
)
}
]
)
;
}
return
false
;
}
onTracingInfiniteLoop
(
)
{
const
consoleMessageWatcher
=
getResourceWatcher
(
this
.
targetActor
TYPES
.
CONSOLE_MESSAGE
)
;
if
(
!
consoleMessageWatcher
)
{
return
true
;
}
const
message
=
"
Looks
like
an
infinite
recursion
?
We
stopped
the
JavaScript
tracer
but
code
may
still
be
running
!
"
+
(
This
is
configurable
via
{
lazy
.
JSTracer
.
MAX_DEPTH_PREF
}
preference
)
;
consoleMessageWatcher
.
emitMessages
(
[
{
arguments
:
[
message
]
styles
:
[
]
level
:
"
jstracer
"
chromeContext
:
false
timeStamp
:
ChromeUtils
.
dateNow
(
)
}
]
)
;
return
false
;
}
onTracingDOMMutation
(
{
depth
prefix
type
caller
element
}
)
{
const
dbgObj
=
makeDebuggeeValue
(
this
.
targetActor
element
)
;
const
frameIndex
=
this
.
#
getFrameIndex
(
null
null
caller
?
getActorIdForInternalSourceId
(
this
.
targetActor
caller
.
sourceId
)
:
null
caller
?
.
lineNumber
caller
?
.
columnNumber
caller
?
.
filename
)
;
this
.
#
throttledTraces
.
push
(
[
"
dom
-
mutation
"
prefix
frameIndex
ChromeUtils
.
dateNow
(
)
depth
type
createValueGripForTarget
(
this
.
targetActor
dbgObj
)
]
)
;
this
.
throttleEmitTraces
(
)
;
return
false
;
}
onTracingFrameStep
(
{
frame
depth
prefix
}
)
{
const
{
script
}
=
frame
;
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
frame
.
offset
)
;
const
url
=
script
.
source
.
url
;
const
columnBase
=
script
.
format
=
=
=
"
wasm
"
?
0
:
1
;
const
column
=
columnNumber
-
columnBase
;
if
(
this
.
sourcesManager
.
isBlackBoxed
(
url
lineNumber
column
)
)
{
return
false
;
}
const
frameIndex
=
this
.
#
getFrameIndex
(
frame
.
implementation
null
getActorIdForInternalSourceId
(
this
.
targetActor
script
.
source
.
id
)
lineNumber
column
url
)
;
this
.
#
throttledTraces
.
push
(
[
"
step
"
prefix
frameIndex
ChromeUtils
.
dateNow
(
)
depth
null
]
)
;
this
.
throttleEmitTraces
(
)
;
return
false
;
}
#
getFrameIndex
(
implementation
name
sourceId
line
column
url
)
{
const
key
=
{
sourceId
}
:
{
line
}
:
{
column
}
;
let
frameIndex
=
this
.
#
frameMap
.
get
(
key
)
;
if
(
frameIndex
=
=
undefined
)
{
frameIndex
=
this
.
#
frameIndex
+
+
;
const
frameArray
=
[
"
frame
"
implementation
name
sourceId
line
column
url
]
;
this
.
#
frameMap
.
set
(
key
frameIndex
)
;
this
.
#
throttledTraces
.
push
(
frameArray
)
;
}
return
frameIndex
;
}
onTracingFrame
(
{
frame
depth
formatedDisplayName
prefix
currentDOMEvent
}
)
{
const
{
script
}
=
frame
;
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
frame
.
offset
)
;
const
url
=
script
.
source
.
url
;
const
columnBase
=
script
.
format
=
=
=
"
wasm
"
?
0
:
1
;
const
column
=
columnNumber
-
columnBase
;
if
(
this
.
sourcesManager
.
isBlackBoxed
(
url
lineNumber
column
)
)
{
return
false
;
}
if
(
currentDOMEvent
&
&
depth
=
=
0
)
{
this
.
#
throttledTraces
.
push
(
[
"
event
"
prefix
null
ChromeUtils
.
dateNow
(
)
-
1
currentDOMEvent
]
)
;
}
let
args
=
undefined
;
if
(
this
.
traceValues
&
&
frame
.
arguments
)
{
args
=
[
]
;
for
(
let
arg
of
frame
.
arguments
)
{
if
(
arg
?
.
unsafeDereference
)
{
arg
=
arg
.
unsafeDereference
(
)
;
}
const
dbgObj
=
makeDebuggeeValue
(
this
.
targetActor
arg
)
;
args
.
push
(
createValueGripForTarget
(
this
.
targetActor
dbgObj
)
)
;
}
}
this
.
sourcesManager
.
getOrCreateSourceActor
(
script
.
source
)
;
const
frameIndex
=
this
.
#
getFrameIndex
(
frame
.
implementation
formatedDisplayName
getActorIdForInternalSourceId
(
this
.
targetActor
script
.
source
.
id
)
lineNumber
column
url
)
;
this
.
#
throttledTraces
.
push
(
[
"
enter
"
prefix
frameIndex
ChromeUtils
.
dateNow
(
)
depth
args
]
)
;
this
.
throttleEmitTraces
(
)
;
return
false
;
}
onTracingFrameExit
(
{
frameId
frame
depth
formatedDisplayName
prefix
why
rv
}
)
{
const
{
script
}
=
frame
;
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
frame
.
offset
)
;
const
url
=
script
.
source
.
url
;
const
columnBase
=
script
.
format
=
=
=
"
wasm
"
?
0
:
1
;
const
column
=
columnNumber
-
columnBase
;
if
(
this
.
sourcesManager
.
isBlackBoxed
(
url
lineNumber
column
)
)
{
return
false
;
}
let
returnedValue
=
undefined
;
if
(
this
.
traceValues
)
{
if
(
rv
?
.
unsafeDereference
)
{
rv
=
rv
.
unsafeDereference
(
)
;
}
const
dbgObj
=
makeDebuggeeValue
(
this
.
targetActor
rv
)
;
returnedValue
=
createValueGripForTarget
(
this
.
targetActor
dbgObj
)
;
}
const
frameIndex
=
this
.
#
getFrameIndex
(
frame
.
implementation
formatedDisplayName
getActorIdForInternalSourceId
(
this
.
targetActor
script
.
source
.
id
)
lineNumber
column
url
)
;
this
.
#
throttledTraces
.
push
(
[
"
exit
"
prefix
frameIndex
ChromeUtils
.
dateNow
(
)
depth
frameId
returnedValue
why
]
)
;
this
.
throttleEmitTraces
(
)
;
return
false
;
}
}
exports
.
ResourcesTracingListener
=
ResourcesTracingListener
;
