"
use
strict
"
;
const
{
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
ChromeActor
}
=
require
(
"
.
/
chrome
"
)
;
const
makeDebugger
=
require
(
"
.
/
utils
/
make
-
debugger
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
{
assert
}
=
DevToolsUtils
;
loader
.
lazyRequireGetter
(
this
"
mapURIToAddonID
"
"
devtools
/
server
/
actors
/
utils
/
map
-
uri
-
to
-
addon
-
id
"
)
;
loader
.
lazyRequireGetter
(
this
"
unwrapDebuggerObjectGlobal
"
"
devtools
/
server
/
actors
/
script
"
true
)
;
loader
.
lazyImporter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
XPIProvider
"
"
resource
:
/
/
gre
/
modules
/
addons
/
XPIProvider
.
jsm
"
)
;
const
FALLBACK_DOC_MESSAGE
=
"
Your
addon
does
not
have
any
document
opened
yet
.
"
;
function
WebExtensionActor
(
conn
addon
)
{
ChromeActor
.
call
(
this
conn
)
;
this
.
id
=
addon
.
id
;
this
.
addon
=
addon
;
this
.
_allowSource
=
this
.
_allowSource
.
bind
(
this
)
;
this
.
consoleAPIListenerOptions
=
{
addonId
:
addon
.
id
}
;
this
.
makeDebugger
=
makeDebugger
.
bind
(
null
{
findDebuggees
:
dbg
=
>
{
return
dbg
.
findAllGlobals
(
)
.
filter
(
this
.
_shouldAddNewGlobalAsDebuggee
)
;
}
shouldAddNewGlobalAsDebuggee
:
this
.
_shouldAddNewGlobalAsDebuggee
.
bind
(
this
)
}
)
;
this
.
preferredTargetWindow
=
null
;
this
.
_findAddonPreferredTargetWindow
(
)
;
AddonManager
.
addAddonListener
(
this
)
;
}
exports
.
WebExtensionActor
=
WebExtensionActor
;
WebExtensionActor
.
prototype
=
Object
.
create
(
ChromeActor
.
prototype
)
;
WebExtensionActor
.
prototype
.
actorPrefix
=
"
webExtension
"
;
WebExtensionActor
.
prototype
.
constructor
=
WebExtensionActor
;
WebExtensionActor
.
prototype
.
isRootActor
=
true
;
WebExtensionActor
.
prototype
.
form
=
function
(
)
{
assert
(
this
.
actorID
"
addon
should
have
an
actorID
.
"
)
;
let
baseForm
=
ChromeActor
.
prototype
.
form
.
call
(
this
)
;
return
Object
.
assign
(
baseForm
{
actor
:
this
.
actorID
id
:
this
.
id
name
:
this
.
addon
.
name
url
:
this
.
addon
.
sourceURI
?
this
.
addon
.
sourceURI
.
spec
:
undefined
iconURL
:
this
.
addon
.
iconURL
debuggable
:
this
.
addon
.
isDebuggable
temporarilyInstalled
:
this
.
addon
.
temporarilyInstalled
isWebExtension
:
this
.
addon
.
isWebExtension
}
)
;
}
;
WebExtensionActor
.
prototype
.
_attach
=
function
(
)
{
if
(
this
.
preferredTargetWindow
)
{
this
.
_setWindow
(
this
.
preferredTargetWindow
)
;
}
else
{
this
.
_createFallbackWindow
(
)
;
}
ChromeActor
.
prototype
.
_attach
.
apply
(
this
)
;
}
;
WebExtensionActor
.
prototype
.
_detach
=
function
(
)
{
this
.
_destroyFallbackWindow
(
)
;
ChromeActor
.
prototype
.
_detach
.
apply
(
this
)
;
}
;
WebExtensionActor
.
prototype
.
exit
=
function
(
)
{
AddonManager
.
removeAddonListener
(
this
)
;
this
.
preferredTargetWindow
=
null
;
this
.
addon
=
null
;
this
.
id
=
null
;
return
ChromeActor
.
prototype
.
exit
.
apply
(
this
)
;
}
;
WebExtensionActor
.
prototype
.
onReload
=
function
(
)
{
return
this
.
addon
.
reload
(
)
.
then
(
(
)
=
>
{
return
{
}
;
}
)
;
}
;
WebExtensionActor
.
prototype
.
setOptions
=
function
(
addonOptions
)
{
if
(
"
global
"
in
addonOptions
)
{
this
.
preferredTargetWindow
=
addonOptions
.
global
;
}
}
;
WebExtensionActor
.
prototype
.
onInstalled
=
function
(
addon
)
{
if
(
addon
.
id
!
=
this
.
id
)
{
return
;
}
this
.
addon
=
addon
;
}
;
WebExtensionActor
.
prototype
.
onUninstalled
=
function
(
addon
)
{
if
(
addon
!
=
this
.
addon
)
{
return
;
}
this
.
exit
(
)
;
}
;
WebExtensionActor
.
prototype
.
onPropertyChanged
=
function
(
addon
changedPropNames
)
{
if
(
addon
!
=
this
.
addon
)
{
return
;
}
if
(
changedPropNames
.
includes
(
"
debugGlobal
"
)
)
{
this
.
_findAddonPreferredTargetWindow
(
)
;
}
}
;
WebExtensionActor
.
prototype
.
_createFallbackWindow
=
function
(
)
{
if
(
this
.
fallbackWindow
)
{
return
;
}
this
.
fallbackWebNav
=
Services
.
appShell
.
createWindowlessBrowser
(
true
)
;
this
.
fallbackWebNav
.
loadURI
(
data
:
text
/
html
;
charset
=
utf
-
8
{
FALLBACK_DOC_MESSAGE
}
0
null
null
null
)
;
this
.
fallbackDocShell
=
this
.
fallbackWebNav
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
;
Object
.
defineProperty
(
this
"
docShell
"
{
value
:
this
.
fallbackDocShell
configurable
:
true
}
)
;
this
.
fallbackWindow
=
this
.
fallbackDocShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
;
WebExtensionActor
.
prototype
.
_destroyFallbackWindow
=
function
(
)
{
if
(
this
.
fallbackWebNav
)
{
this
.
fallbackWebNav
.
loadURI
(
"
about
:
blank
"
0
null
null
null
)
;
this
.
fallbackWebNav
.
close
(
)
;
this
.
fallbackWebNav
=
null
;
this
.
fallbackWindow
=
null
;
}
}
;
WebExtensionActor
.
prototype
.
_findAddonPreferredTargetWindow
=
function
(
)
{
return
new
Promise
(
resolve
=
>
{
let
activeAddon
=
XPIProvider
.
activeAddons
.
get
(
this
.
id
)
;
if
(
!
activeAddon
)
{
resolve
(
null
)
;
}
else
{
AddonManager
.
getAddonByInstanceID
(
activeAddon
.
instanceID
)
.
then
(
privateWrapper
=
>
{
let
targetWindow
=
privateWrapper
.
getDebugGlobal
(
)
;
if
(
!
(
targetWindow
instanceof
Ci
.
nsIDOMWindow
)
)
{
targetWindow
=
null
;
}
resolve
(
targetWindow
)
;
}
)
;
}
}
)
.
then
(
preferredTargetWindow
=
>
{
this
.
preferredTargetWindow
=
preferredTargetWindow
;
if
(
!
preferredTargetWindow
)
{
this
.
_createFallbackWindow
(
)
;
}
else
if
(
this
.
attached
)
{
this
.
_changeTopLevelDocument
(
preferredTargetWindow
)
;
}
}
)
;
}
;
WebExtensionActor
.
prototype
.
_docShellsToWindows
=
function
(
docshells
)
{
return
ChromeActor
.
prototype
.
_docShellsToWindows
.
call
(
this
docshells
)
.
filter
(
windowDetails
=
>
{
return
windowDetails
.
addonID
=
=
this
.
id
;
}
)
;
}
;
WebExtensionActor
.
prototype
.
_allowSource
=
function
(
source
)
{
try
{
let
uri
=
Services
.
io
.
newURI
(
source
.
url
null
null
)
;
let
addonID
=
mapURIToAddonID
(
uri
)
;
return
addonID
=
=
this
.
id
;
}
catch
(
e
)
{
return
false
;
}
}
;
WebExtensionActor
.
prototype
.
_shouldAddNewGlobalAsDebuggee
=
function
(
newGlobal
)
{
const
global
=
unwrapDebuggerObjectGlobal
(
newGlobal
)
;
if
(
global
instanceof
Ci
.
nsIDOMWindow
)
{
return
global
.
document
.
nodePrincipal
.
originAttributes
.
addonId
=
=
this
.
id
;
}
try
{
let
metadata
=
Cu
.
getSandboxMetadata
(
global
)
;
if
(
metadata
)
{
return
metadata
.
addonID
=
=
=
this
.
id
;
}
}
catch
(
e
)
{
}
return
false
;
}
;
WebExtensionActor
.
prototype
.
requestTypes
.
reload
=
WebExtensionActor
.
prototype
.
onReload
;
