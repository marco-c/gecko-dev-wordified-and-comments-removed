"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
serviceWorkerRegistrationSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
worker
/
service
-
worker
-
registration
"
)
;
const
{
PushSubscriptionActor
}
=
require
(
"
devtools
/
server
/
actors
/
worker
/
push
-
subscription
"
)
;
const
{
ServiceWorkerActor
}
=
require
(
"
devtools
/
server
/
actors
/
worker
/
service
-
worker
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
swm
"
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
"
nsIServiceWorkerManager
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
PushService
"
"
mozilla
.
org
/
push
/
Service
;
1
"
"
nsIPushService
"
)
;
let
_serviceWorkerProcessScriptLoaded
=
false
;
const
ServiceWorkerRegistrationActor
=
protocol
.
ActorClassWithSpec
(
serviceWorkerRegistrationSpec
{
initialize
(
conn
registration
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
conn
)
;
this
.
_conn
=
conn
;
this
.
_registration
=
registration
;
this
.
_pushSubscriptionActor
=
null
;
this
.
_preventedShutdown
=
false
;
this
.
_registration
.
addListener
(
this
)
;
this
.
_createServiceWorkerActors
(
)
;
Services
.
obs
.
addObserver
(
this
PushService
.
subscriptionModifiedTopic
)
;
}
onChange
(
)
{
this
.
_destroyServiceWorkerActors
(
)
;
this
.
_createServiceWorkerActors
(
)
;
this
.
emit
(
"
registration
-
changed
"
)
;
}
form
(
)
{
const
registration
=
this
.
_registration
;
const
installingWorker
=
this
.
_installingWorker
.
form
(
)
;
const
waitingWorker
=
this
.
_waitingWorker
.
form
(
)
;
const
activeWorker
=
this
.
_activeWorker
.
form
(
)
;
const
newestWorker
=
activeWorker
|
|
waitingWorker
|
|
installingWorker
;
const
isParentInterceptEnabled
=
swm
.
isParentInterceptEnabled
(
)
;
const
isMultiE10sWithOldImplementation
=
Services
.
appinfo
.
browserTabsRemoteAutostart
&
&
!
isParentInterceptEnabled
;
return
{
actor
:
this
.
actorID
scope
:
registration
.
scope
url
:
registration
.
scriptSpec
installingWorker
waitingWorker
activeWorker
fetch
:
newestWorker
&
&
newestWorker
.
fetch
active
:
isMultiE10sWithOldImplementation
?
true
:
!
!
activeWorker
lastUpdateTime
:
registration
.
lastUpdateTime
traits
:
{
isParentInterceptEnabled
}
}
;
}
destroy
(
)
{
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
if
(
swm
.
isParentInterceptEnabled
(
)
&
&
this
.
_registration
.
activeWorker
&
&
this
.
_preventedShutdown
)
{
this
.
allowShutdown
(
)
;
}
Services
.
obs
.
removeObserver
(
this
PushService
.
subscriptionModifiedTopic
)
;
this
.
_registration
.
removeListener
(
this
)
;
this
.
_registration
=
null
;
if
(
this
.
_pushSubscriptionActor
)
{
this
.
_pushSubscriptionActor
.
destroy
(
)
;
}
this
.
_pushSubscriptionActor
=
null
;
this
.
_destroyServiceWorkerActors
(
)
;
this
.
_installingWorker
=
null
;
this
.
_waitingWorker
=
null
;
this
.
_activeWorker
=
null
;
}
observe
(
subject
topic
data
)
{
const
scope
=
this
.
_registration
.
scope
;
if
(
data
!
=
=
scope
)
{
return
;
}
switch
(
topic
)
{
case
PushService
.
subscriptionModifiedTopic
:
if
(
this
.
_pushSubscriptionActor
)
{
this
.
_pushSubscriptionActor
.
destroy
(
)
;
this
.
_pushSubscriptionActor
=
null
;
}
this
.
emit
(
"
push
-
subscription
-
modified
"
)
;
break
;
}
}
start
(
)
{
if
(
swm
.
isParentInterceptEnabled
(
)
)
{
const
{
activeWorker
}
=
this
.
_registration
;
if
(
activeWorker
)
{
activeWorker
.
attachDebugger
(
)
;
activeWorker
.
detachDebugger
(
)
;
}
return
{
type
:
"
started
"
}
;
}
if
(
!
_serviceWorkerProcessScriptLoaded
)
{
Services
.
ppmm
.
loadProcessScript
(
"
resource
:
/
/
devtools
/
server
/
actors
/
worker
/
service
-
worker
-
process
.
js
"
true
)
;
_serviceWorkerProcessScriptLoaded
=
true
;
}
Services
.
perms
.
broadcastPermissionsForPrincipalToAllContentProcesses
(
this
.
_registration
.
principal
)
;
Services
.
ppmm
.
broadcastAsyncMessage
(
"
serviceWorkerRegistration
:
start
"
{
scope
:
this
.
_registration
.
scope
}
)
;
return
{
type
:
"
started
"
}
;
}
unregister
(
)
{
const
{
principal
scope
}
=
this
.
_registration
;
const
unregisterCallback
=
{
unregisterSucceeded
:
function
(
)
{
}
unregisterFailed
:
function
(
)
{
console
.
error
(
"
Failed
to
unregister
the
service
worker
for
"
+
scope
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIServiceWorkerUnregisterCallback
]
)
}
;
swm
.
propagateUnregister
(
principal
unregisterCallback
scope
)
;
return
{
type
:
"
unregistered
"
}
;
}
push
(
)
{
if
(
!
swm
.
isParentInterceptEnabled
(
)
)
{
throw
new
Error
(
"
ServiceWorkerRegistrationActor
.
push
can
only
be
used
"
+
"
in
parent
-
intercept
mode
"
)
;
}
const
{
principal
scope
}
=
this
.
_registration
;
const
originAttributes
=
ChromeUtils
.
originAttributesToSuffix
(
principal
.
originAttributes
)
;
swm
.
sendPushEvent
(
originAttributes
scope
)
;
}
preventShutdown
(
)
{
if
(
!
swm
.
isParentInterceptEnabled
(
)
)
{
throw
new
Error
(
"
ServiceWorkerRegistrationActor
.
preventShutdown
can
only
be
used
"
+
"
in
parent
-
intercept
mode
"
)
;
}
if
(
!
this
.
_registration
.
activeWorker
)
{
throw
new
Error
(
"
ServiceWorkerRegistrationActor
.
preventShutdown
could
not
find
"
+
"
activeWorker
in
parent
-
intercept
mode
"
)
;
}
this
.
_registration
.
activeWorker
.
attachDebugger
(
)
;
this
.
_preventedShutdown
=
true
;
}
allowShutdown
(
)
{
if
(
!
swm
.
isParentInterceptEnabled
(
)
)
{
throw
new
Error
(
"
ServiceWorkerRegistrationActor
.
allowShutdown
can
only
be
used
"
+
"
in
parent
-
intercept
mode
"
)
;
}
if
(
!
this
.
_registration
.
activeWorker
)
{
throw
new
Error
(
"
ServiceWorkerRegistrationActor
.
allowShutdown
could
not
find
"
+
"
activeWorker
in
parent
-
intercept
mode
"
)
;
}
this
.
_registration
.
activeWorker
.
detachDebugger
(
)
;
this
.
_preventedShutdown
=
false
;
}
getPushSubscription
(
)
{
const
registration
=
this
.
_registration
;
let
pushSubscriptionActor
=
this
.
_pushSubscriptionActor
;
if
(
pushSubscriptionActor
)
{
return
Promise
.
resolve
(
pushSubscriptionActor
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
PushService
.
getSubscription
(
registration
.
scope
registration
.
principal
(
result
subscription
)
=
>
{
if
(
!
subscription
)
{
resolve
(
null
)
;
return
;
}
pushSubscriptionActor
=
new
PushSubscriptionActor
(
this
.
_conn
subscription
)
;
this
.
_pushSubscriptionActor
=
pushSubscriptionActor
;
resolve
(
pushSubscriptionActor
)
;
}
)
;
}
)
;
}
_destroyServiceWorkerActors
(
)
{
this
.
_installingWorker
.
destroy
(
)
;
this
.
_waitingWorker
.
destroy
(
)
;
this
.
_activeWorker
.
destroy
(
)
;
}
_createServiceWorkerActors
(
)
{
const
{
installingWorker
waitingWorker
activeWorker
}
=
this
.
_registration
;
this
.
_installingWorker
=
new
ServiceWorkerActor
(
this
.
_conn
installingWorker
)
;
this
.
_waitingWorker
=
new
ServiceWorkerActor
(
this
.
_conn
waitingWorker
)
;
this
.
_activeWorker
=
new
ServiceWorkerActor
(
this
.
_conn
activeWorker
)
;
this
.
manage
(
this
.
_installingWorker
)
;
this
.
manage
(
this
.
_waitingWorker
)
;
this
.
manage
(
this
.
_activeWorker
)
;
}
}
)
;
exports
.
ServiceWorkerRegistrationActor
=
ServiceWorkerRegistrationActor
;
