"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
events
=
require
(
"
sdk
/
event
/
core
"
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
fetch
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
oldStyleSheetSpec
styleEditorSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
styleeditor
"
)
;
loader
.
lazyGetter
(
this
"
CssLogic
"
(
)
=
>
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
)
;
var
TRANSITION_CLASS
=
"
moz
-
styleeditor
-
transitioning
"
;
var
TRANSITION_DURATION_MS
=
500
;
var
TRANSITION_RULE
=
"
:
root
.
moz
-
styleeditor
-
transitioning
"
+
"
:
root
.
moz
-
styleeditor
-
transitioning
*
{
\
n
"
+
"
transition
-
duration
:
"
+
TRANSITION_DURATION_MS
+
"
ms
!
important
;
\
n
"
+
"
transition
-
delay
:
0ms
!
important
;
\
n
"
+
"
transition
-
timing
-
function
:
ease
-
out
!
important
;
\
n
"
+
"
transition
-
property
:
all
!
important
;
\
n
"
+
"
}
"
;
var
OldStyleSheetActor
=
protocol
.
ActorClassWithSpec
(
oldStyleSheetSpec
{
toString
:
function
(
)
{
return
"
[
OldStyleSheetActor
"
+
this
.
actorID
+
"
]
"
;
}
get
window
(
)
{
return
this
.
_window
|
|
this
.
parentActor
.
window
;
}
get
document
(
)
{
return
this
.
window
.
document
;
}
get
href
(
)
{
return
this
.
rawSheet
.
href
;
}
get
styleSheetIndex
(
)
{
if
(
this
.
_styleSheetIndex
=
=
-
1
)
{
for
(
let
i
=
0
;
i
<
this
.
document
.
styleSheets
.
length
;
i
+
+
)
{
if
(
this
.
document
.
styleSheets
[
i
]
=
=
this
.
rawSheet
)
{
this
.
_styleSheetIndex
=
i
;
break
;
}
}
}
return
this
.
_styleSheetIndex
;
}
initialize
:
function
(
styleSheet
parentActor
window
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
rawSheet
=
styleSheet
;
this
.
parentActor
=
parentActor
;
this
.
conn
=
this
.
parentActor
.
conn
;
this
.
_window
=
window
;
this
.
text
=
null
;
this
.
_styleSheetIndex
=
-
1
;
this
.
_transitionRefCount
=
0
;
let
ownerNode
=
this
.
rawSheet
.
ownerNode
;
if
(
ownerNode
)
{
let
onSheetLoaded
=
(
event
)
=
>
{
ownerNode
.
removeEventListener
(
"
load
"
onSheetLoaded
)
;
this
.
_notifyPropertyChanged
(
"
ruleCount
"
)
;
}
;
ownerNode
.
addEventListener
(
"
load
"
onSheetLoaded
)
;
}
}
form
:
function
(
detail
)
{
if
(
detail
=
=
=
"
actorid
"
)
{
return
this
.
actorID
;
}
let
docHref
;
if
(
this
.
rawSheet
.
ownerNode
)
{
if
(
this
.
rawSheet
.
ownerNode
instanceof
Ci
.
nsIDOMHTMLDocument
)
{
docHref
=
this
.
rawSheet
.
ownerNode
.
location
.
href
;
}
if
(
this
.
rawSheet
.
ownerNode
.
ownerDocument
)
{
docHref
=
this
.
rawSheet
.
ownerNode
.
ownerDocument
.
location
.
href
;
}
}
let
form
=
{
actor
:
this
.
actorID
href
:
this
.
href
nodeHref
:
docHref
disabled
:
this
.
rawSheet
.
disabled
title
:
this
.
rawSheet
.
title
system
:
!
CssLogic
.
isContentStylesheet
(
this
.
rawSheet
)
styleSheetIndex
:
this
.
styleSheetIndex
}
;
try
{
form
.
ruleCount
=
this
.
rawSheet
.
cssRules
.
length
;
}
catch
(
e
)
{
}
return
form
;
}
toggleDisabled
:
function
(
)
{
this
.
rawSheet
.
disabled
=
!
this
.
rawSheet
.
disabled
;
this
.
_notifyPropertyChanged
(
"
disabled
"
)
;
return
this
.
rawSheet
.
disabled
;
}
_notifyPropertyChanged
:
function
(
property
)
{
events
.
emit
(
this
"
property
-
change
"
property
this
.
form
(
)
[
property
]
)
;
}
fetchSource
:
function
(
)
{
this
.
_getText
(
)
.
then
(
(
content
)
=
>
{
events
.
emit
(
this
"
source
-
load
"
this
.
text
)
;
}
)
;
}
_getText
:
function
(
)
{
if
(
this
.
text
)
{
return
promise
.
resolve
(
this
.
text
)
;
}
if
(
!
this
.
href
)
{
let
content
=
this
.
rawSheet
.
ownerNode
.
textContent
;
this
.
text
=
content
;
return
promise
.
resolve
(
content
)
;
}
let
options
=
{
policy
:
Ci
.
nsIContentPolicy
.
TYPE_INTERNAL_STYLESHEET
window
:
this
.
window
charset
:
this
.
_getCSSCharset
(
)
}
;
return
fetch
(
this
.
href
options
)
.
then
(
(
{
content
}
)
=
>
{
this
.
text
=
content
;
return
content
;
}
)
;
}
_getCSSCharset
:
function
(
)
{
let
sheet
=
this
.
rawSheet
;
if
(
sheet
)
{
if
(
sheet
.
cssRules
)
{
let
rules
=
sheet
.
cssRules
;
if
(
rules
.
length
&
&
rules
.
item
(
0
)
.
type
=
=
Ci
.
nsIDOMCSSRule
.
CHARSET_RULE
)
{
return
rules
.
item
(
0
)
.
encoding
;
}
}
if
(
sheet
.
ownerNode
&
&
sheet
.
ownerNode
.
getAttribute
)
{
let
linkCharset
=
sheet
.
ownerNode
.
getAttribute
(
"
charset
"
)
;
if
(
linkCharset
!
=
null
)
{
return
linkCharset
;
}
}
let
parentSheet
=
sheet
.
parentStyleSheet
;
if
(
parentSheet
&
&
parentSheet
.
cssRules
&
&
parentSheet
.
cssRules
[
0
]
.
type
=
=
Ci
.
nsIDOMCSSRule
.
CHARSET_RULE
)
{
return
parentSheet
.
cssRules
[
0
]
.
encoding
;
}
if
(
sheet
.
ownerNode
&
&
sheet
.
ownerNode
.
ownerDocument
.
characterSet
)
{
return
sheet
.
ownerNode
.
ownerDocument
.
characterSet
;
}
}
return
"
UTF
-
8
"
;
}
update
:
function
(
text
transition
)
{
DOMUtils
.
parseStyleSheet
(
this
.
rawSheet
text
)
;
this
.
text
=
text
;
this
.
_notifyPropertyChanged
(
"
ruleCount
"
)
;
if
(
transition
)
{
this
.
_insertTransistionRule
(
)
;
}
else
{
this
.
_notifyStyleApplied
(
)
;
}
}
_insertTransistionRule
:
function
(
)
{
if
(
this
.
_transitionRefCount
=
=
0
)
{
this
.
rawSheet
.
insertRule
(
TRANSITION_RULE
this
.
rawSheet
.
cssRules
.
length
)
;
this
.
document
.
documentElement
.
classList
.
add
(
TRANSITION_CLASS
)
;
}
this
.
_transitionRefCount
+
+
;
this
.
window
.
setTimeout
(
this
.
_onTransitionEnd
.
bind
(
this
)
Math
.
floor
(
TRANSITION_DURATION_MS
*
1
.
1
)
)
;
}
_onTransitionEnd
:
function
(
)
{
if
(
-
-
this
.
_transitionRefCount
=
=
0
)
{
this
.
document
.
documentElement
.
classList
.
remove
(
TRANSITION_CLASS
)
;
this
.
rawSheet
.
deleteRule
(
this
.
rawSheet
.
cssRules
.
length
-
1
)
;
}
events
.
emit
(
this
"
style
-
applied
"
)
;
}
}
)
;
exports
.
OldStyleSheetActor
=
OldStyleSheetActor
;
var
StyleEditorActor
=
protocol
.
ActorClassWithSpec
(
styleEditorSpec
{
get
window
(
)
{
return
this
.
parentActor
.
window
;
}
get
document
(
)
{
return
this
.
window
.
document
;
}
form
:
function
(
)
{
return
{
actor
:
this
.
actorID
}
;
}
initialize
:
function
(
conn
tabActor
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
parentActor
=
tabActor
;
this
.
_sheets
=
new
Map
(
)
;
}
destroy
:
function
(
)
{
this
.
_sheets
.
clear
(
)
;
}
newDocument
:
function
(
)
{
this
.
_clearStyleSheetActors
(
)
;
if
(
this
.
document
.
readyState
=
=
"
complete
"
)
{
this
.
_onDocumentLoaded
(
)
;
}
else
{
this
.
window
.
addEventListener
(
"
load
"
this
.
_onDocumentLoaded
)
;
}
return
{
}
;
}
_onDocumentLoaded
:
function
(
event
)
{
if
(
event
)
{
this
.
window
.
removeEventListener
(
"
load
"
this
.
_onDocumentLoaded
)
;
}
let
documents
=
[
this
.
document
]
;
let
forms
=
[
]
;
for
(
let
doc
of
documents
)
{
let
sheetForms
=
this
.
_addStyleSheets
(
doc
.
styleSheets
)
;
forms
=
forms
.
concat
(
sheetForms
)
;
for
(
let
iframe
of
doc
.
getElementsByTagName
(
"
iframe
"
)
)
{
documents
.
push
(
iframe
.
contentDocument
)
;
}
}
events
.
emit
(
this
"
document
-
load
"
forms
)
;
}
_addStyleSheets
:
function
(
styleSheets
)
{
let
sheets
=
[
]
;
for
(
let
i
=
0
;
i
<
styleSheets
.
length
;
i
+
+
)
{
let
styleSheet
=
styleSheets
[
i
]
;
sheets
.
push
(
styleSheet
)
;
let
imports
=
this
.
_getImported
(
styleSheet
)
;
sheets
=
sheets
.
concat
(
imports
)
;
}
let
actors
=
sheets
.
map
(
this
.
_createStyleSheetActor
.
bind
(
this
)
)
;
return
actors
;
}
_createStyleSheetActor
:
function
(
styleSheet
)
{
if
(
this
.
_sheets
.
has
(
styleSheet
)
)
{
return
this
.
_sheets
.
get
(
styleSheet
)
;
}
let
actor
=
new
OldStyleSheetActor
(
styleSheet
this
)
;
this
.
manage
(
actor
)
;
this
.
_sheets
.
set
(
styleSheet
actor
)
;
return
actor
;
}
_getImported
:
function
(
styleSheet
)
{
let
imported
=
[
]
;
for
(
let
i
=
0
;
i
<
styleSheet
.
cssRules
.
length
;
i
+
+
)
{
let
rule
=
styleSheet
.
cssRules
[
i
]
;
if
(
rule
.
type
=
=
Ci
.
nsIDOMCSSRule
.
IMPORT_RULE
)
{
if
(
!
rule
.
styleSheet
)
{
continue
;
}
imported
.
push
(
rule
.
styleSheet
)
;
imported
=
imported
.
concat
(
this
.
_getImported
(
rule
.
styleSheet
)
)
;
}
else
if
(
rule
.
type
!
=
Ci
.
nsIDOMCSSRule
.
CHARSET_RULE
)
{
break
;
}
}
return
imported
;
}
_clearStyleSheetActors
:
function
(
)
{
for
(
let
actor
in
this
.
_sheets
)
{
this
.
unmanage
(
this
.
_sheets
[
actor
]
)
;
}
this
.
_sheets
.
clear
(
)
;
}
newStyleSheet
:
function
(
text
)
{
let
parent
=
this
.
document
.
documentElement
;
let
style
=
this
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
style
"
)
;
style
.
setAttribute
(
"
type
"
"
text
/
css
"
)
;
if
(
text
)
{
style
.
appendChild
(
this
.
document
.
createTextNode
(
text
)
)
;
}
parent
.
appendChild
(
style
)
;
let
actor
=
this
.
_createStyleSheetActor
(
style
.
sheet
)
;
return
actor
;
}
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
DOMUtils
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
inspector
/
dom
-
utils
;
1
"
]
.
getService
(
Ci
.
inIDOMUtils
)
;
}
)
;
exports
.
StyleEditorActor
=
StyleEditorActor
;
