"
use
strict
"
;
const
{
AutoRefreshHighlighter
}
=
require
(
"
.
/
auto
-
refresh
"
)
;
const
{
CANVAS_SIZE
DEFAULT_COLOR
clearRect
drawRect
getCurrentMatrix
updateCanvasElement
updateCanvasPosition
}
=
require
(
"
.
/
utils
/
canvas
"
)
;
const
{
CanvasFrameAnonymousContentHelper
createNode
getComputedStyle
}
=
require
(
"
.
/
utils
/
markup
"
)
;
const
{
getAdjustedQuads
getDisplayPixelRatio
setIgnoreLayoutChanges
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
FLEXBOX_LINES_PROPERTIES
=
{
"
edge
"
:
{
lineDash
:
[
12
10
]
}
"
item
"
:
{
lineDash
:
[
0
0
]
}
}
;
const
FLEXBOX_CONTAINER_PATTERN_WIDTH
=
14
;
const
FLEXBOX_CONTAINER_PATTERN_HEIGHT
=
14
;
const
FLEXBOX_JUSTIFY_CONTENT_PATTERN_WIDTH
=
7
;
const
FLEXBOX_JUSTIFY_CONTENT_PATTERN_HEIGHT
=
7
;
const
FLEXBOX_CONTAINER_PATTERN_LINE_DISH
=
[
5
3
]
;
const
BASIS_FILL_COLOR
=
"
rgb
(
109
184
255
0
.
4
)
"
;
const
gCachedFlexboxPattern
=
new
Map
(
)
;
const
FLEXBOX
=
"
flexbox
"
;
const
JUSTIFY_CONTENT
=
"
justify
-
content
"
;
class
FlexboxHighlighter
extends
AutoRefreshHighlighter
{
constructor
(
highlighterEnv
)
{
super
(
highlighterEnv
)
;
this
.
ID_CLASS_PREFIX
=
"
flexbox
-
"
;
this
.
markup
=
new
CanvasFrameAnonymousContentHelper
(
this
.
highlighterEnv
this
.
_buildMarkup
.
bind
(
this
)
)
;
this
.
onPageHide
=
this
.
onPageHide
.
bind
(
this
)
;
this
.
onWillNavigate
=
this
.
onWillNavigate
.
bind
(
this
)
;
this
.
highlighterEnv
.
on
(
"
will
-
navigate
"
this
.
onWillNavigate
)
;
let
{
pageListenerTarget
}
=
highlighterEnv
;
pageListenerTarget
.
addEventListener
(
"
pagehide
"
this
.
onPageHide
)
;
this
.
_canvasPosition
=
{
x
:
0
y
:
0
}
;
updateCanvasPosition
(
this
.
_canvasPosition
this
.
_scroll
this
.
win
this
.
_winDimensions
)
;
}
_buildMarkup
(
)
{
let
container
=
createNode
(
this
.
win
{
attributes
:
{
"
class
"
:
"
highlighter
-
container
"
}
}
)
;
let
root
=
createNode
(
this
.
win
{
parent
:
container
attributes
:
{
"
id
"
:
"
root
"
"
class
"
:
"
root
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
parent
:
root
nodeType
:
"
canvas
"
attributes
:
{
"
id
"
:
"
canvas
"
"
class
"
:
"
canvas
"
"
hidden
"
:
"
true
"
"
width
"
:
CANVAS_SIZE
"
height
"
:
CANVAS_SIZE
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
return
container
;
}
clearCache
(
)
{
gCachedFlexboxPattern
.
clear
(
)
;
}
destroy
(
)
{
let
{
highlighterEnv
}
=
this
;
highlighterEnv
.
off
(
"
will
-
navigate
"
this
.
onWillNavigate
)
;
let
{
pageListenerTarget
}
=
highlighterEnv
;
if
(
pageListenerTarget
)
{
pageListenerTarget
.
removeEventListener
(
"
pagehide
"
this
.
onPageHide
)
;
}
this
.
markup
.
destroy
(
)
;
this
.
clearCache
(
)
;
AutoRefreshHighlighter
.
prototype
.
destroy
.
call
(
this
)
;
}
drawJustifyContent
(
left
top
right
bottom
)
{
let
{
devicePixelRatio
}
=
this
.
win
;
this
.
ctx
.
fillStyle
=
this
.
getJustifyContentPattern
(
devicePixelRatio
)
;
drawRect
(
this
.
ctx
left
top
right
bottom
this
.
currentMatrix
)
;
this
.
ctx
.
fill
(
)
;
}
get
canvas
(
)
{
return
this
.
getElement
(
"
canvas
"
)
;
}
get
ctx
(
)
{
return
this
.
canvas
.
getCanvasContext
(
"
2d
"
)
;
}
getElement
(
id
)
{
return
this
.
markup
.
getElement
(
this
.
ID_CLASS_PREFIX
+
id
)
;
}
getFlexContainerPattern
(
devicePixelRatio
)
{
let
flexboxPatternMap
=
null
;
if
(
gCachedFlexboxPattern
.
has
(
devicePixelRatio
)
)
{
flexboxPatternMap
=
gCachedFlexboxPattern
.
get
(
devicePixelRatio
)
;
}
else
{
flexboxPatternMap
=
new
Map
(
)
;
}
if
(
gCachedFlexboxPattern
.
has
(
FLEXBOX
)
)
{
return
gCachedFlexboxPattern
.
get
(
FLEXBOX
)
;
}
let
canvas
=
createNode
(
this
.
win
{
nodeType
:
"
canvas
"
}
)
;
let
width
=
canvas
.
width
=
FLEXBOX_CONTAINER_PATTERN_WIDTH
*
devicePixelRatio
;
let
height
=
canvas
.
height
=
FLEXBOX_CONTAINER_PATTERN_HEIGHT
*
devicePixelRatio
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
save
(
)
;
ctx
.
setLineDash
(
FLEXBOX_CONTAINER_PATTERN_LINE_DISH
)
;
ctx
.
beginPath
(
)
;
ctx
.
translate
(
.
5
.
5
)
;
ctx
.
moveTo
(
0
0
)
;
ctx
.
lineTo
(
width
height
)
;
ctx
.
strokeStyle
=
DEFAULT_COLOR
;
ctx
.
stroke
(
)
;
ctx
.
restore
(
)
;
let
pattern
=
ctx
.
createPattern
(
canvas
"
repeat
"
)
;
flexboxPatternMap
.
set
(
FLEXBOX
pattern
)
;
gCachedFlexboxPattern
.
set
(
devicePixelRatio
flexboxPatternMap
)
;
return
pattern
;
}
getJustifyContentPattern
(
devicePixelRatio
)
{
let
flexboxPatternMap
=
null
;
if
(
gCachedFlexboxPattern
.
has
(
devicePixelRatio
)
)
{
flexboxPatternMap
=
gCachedFlexboxPattern
.
get
(
devicePixelRatio
)
;
}
else
{
flexboxPatternMap
=
new
Map
(
)
;
}
if
(
gCachedFlexboxPattern
.
has
(
JUSTIFY_CONTENT
)
)
{
return
gCachedFlexboxPattern
.
get
(
JUSTIFY_CONTENT
)
;
}
let
canvas
=
createNode
(
this
.
win
{
nodeType
:
"
canvas
"
}
)
;
let
width
=
canvas
.
width
=
FLEXBOX_JUSTIFY_CONTENT_PATTERN_WIDTH
*
devicePixelRatio
;
let
height
=
canvas
.
height
=
FLEXBOX_JUSTIFY_CONTENT_PATTERN_HEIGHT
*
devicePixelRatio
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
save
(
)
;
ctx
.
setLineDash
(
FLEXBOX_CONTAINER_PATTERN_LINE_DISH
)
;
ctx
.
beginPath
(
)
;
ctx
.
translate
(
.
5
.
5
)
;
ctx
.
moveTo
(
0
height
)
;
ctx
.
lineTo
(
width
0
)
;
ctx
.
strokeStyle
=
DEFAULT_COLOR
;
ctx
.
stroke
(
)
;
ctx
.
restore
(
)
;
let
pattern
=
ctx
.
createPattern
(
canvas
"
repeat
"
)
;
flexboxPatternMap
.
set
(
JUSTIFY_CONTENT
pattern
)
;
gCachedFlexboxPattern
.
set
(
devicePixelRatio
flexboxPatternMap
)
;
return
pattern
;
}
_hasMoved
(
)
{
let
hasMoved
=
AutoRefreshHighlighter
.
prototype
.
_hasMoved
.
call
(
this
)
;
return
hasMoved
;
}
_hide
(
)
{
setIgnoreLayoutChanges
(
true
)
;
this
.
_hideFlexbox
(
)
;
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
document
.
documentElement
)
;
}
_hideFlexbox
(
)
{
this
.
getElement
(
"
canvas
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
_scrollUpdate
(
)
{
let
hasUpdated
=
updateCanvasPosition
(
this
.
_canvasPosition
this
.
_scroll
this
.
win
this
.
_winDimensions
)
;
if
(
hasUpdated
)
{
this
.
_update
(
)
;
}
}
_show
(
)
{
this
.
_hide
(
)
;
return
this
.
_update
(
)
;
}
_showFlexbox
(
)
{
this
.
getElement
(
"
canvas
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
onPageHide
(
{
target
}
)
{
if
(
target
.
defaultView
=
=
=
this
.
win
)
{
this
.
hide
(
)
;
}
}
onWillNavigate
(
{
isTopLevel
}
)
{
this
.
clearCache
(
)
;
if
(
isTopLevel
)
{
this
.
hide
(
)
;
}
}
renderFlexContainerBorder
(
)
{
if
(
!
this
.
currentQuads
.
content
|
|
!
this
.
currentQuads
.
content
[
0
]
)
{
return
;
}
let
{
devicePixelRatio
}
=
this
.
win
;
let
lineWidth
=
getDisplayPixelRatio
(
this
.
win
)
*
2
;
let
offset
=
(
lineWidth
/
2
)
%
1
;
let
canvasX
=
Math
.
round
(
this
.
_canvasPosition
.
x
*
devicePixelRatio
)
;
let
canvasY
=
Math
.
round
(
this
.
_canvasPosition
.
y
*
devicePixelRatio
)
;
this
.
ctx
.
save
(
)
;
this
.
ctx
.
translate
(
offset
-
canvasX
offset
-
canvasY
)
;
this
.
ctx
.
setLineDash
(
FLEXBOX_LINES_PROPERTIES
.
edge
.
lineDash
)
;
this
.
ctx
.
lineWidth
=
lineWidth
;
this
.
ctx
.
strokeStyle
=
DEFAULT_COLOR
;
let
{
bounds
}
=
this
.
currentQuads
.
content
[
0
]
;
drawRect
(
this
.
ctx
0
0
bounds
.
width
bounds
.
height
this
.
currentMatrix
)
;
this
.
ctx
.
stroke
(
)
;
this
.
ctx
.
restore
(
)
;
}
renderFlexContainerFill
(
)
{
if
(
!
this
.
currentQuads
.
content
|
|
!
this
.
currentQuads
.
content
[
0
]
)
{
return
;
}
let
{
devicePixelRatio
}
=
this
.
win
;
let
lineWidth
=
getDisplayPixelRatio
(
this
.
win
)
;
let
offset
=
(
lineWidth
/
2
)
%
1
;
let
canvasX
=
Math
.
round
(
this
.
_canvasPosition
.
x
*
devicePixelRatio
)
;
let
canvasY
=
Math
.
round
(
this
.
_canvasPosition
.
y
*
devicePixelRatio
)
;
this
.
ctx
.
save
(
)
;
this
.
ctx
.
translate
(
offset
-
canvasX
offset
-
canvasY
)
;
this
.
ctx
.
setLineDash
(
FLEXBOX_LINES_PROPERTIES
.
edge
.
lineDash
)
;
this
.
ctx
.
lineWidth
=
0
;
this
.
ctx
.
strokeStyle
=
DEFAULT_COLOR
;
this
.
ctx
.
fillStyle
=
this
.
getFlexContainerPattern
(
devicePixelRatio
)
;
let
{
bounds
}
=
this
.
currentQuads
.
content
[
0
]
;
drawRect
(
this
.
ctx
0
0
bounds
.
width
bounds
.
height
this
.
currentMatrix
)
;
this
.
ctx
.
fill
(
)
;
this
.
ctx
.
stroke
(
)
;
this
.
ctx
.
restore
(
)
;
}
renderFlexItemBasis
(
flexItem
left
top
right
bottom
boundsWidth
)
{
let
computedStyle
=
getComputedStyle
(
flexItem
)
;
let
basis
=
computedStyle
.
getPropertyValue
(
"
flex
-
basis
"
)
;
if
(
basis
.
endsWith
(
"
px
"
)
)
{
right
=
Math
.
round
(
left
+
parseFloat
(
basis
)
)
;
}
else
if
(
basis
.
endsWith
(
"
%
"
)
)
{
basis
=
parseFloat
(
basis
)
/
100
*
boundsWidth
;
right
=
Math
.
round
(
left
+
basis
)
;
}
this
.
ctx
.
fillStyle
=
BASIS_FILL_COLOR
;
drawRect
(
this
.
ctx
left
top
right
bottom
this
.
currentMatrix
)
;
this
.
ctx
.
fill
(
)
;
}
renderFlexItems
(
)
{
if
(
!
this
.
currentQuads
.
content
|
|
!
this
.
currentQuads
.
content
[
0
]
)
{
return
;
}
let
{
devicePixelRatio
}
=
this
.
win
;
let
lineWidth
=
getDisplayPixelRatio
(
this
.
win
)
;
let
offset
=
(
lineWidth
/
2
)
%
1
;
let
canvasX
=
Math
.
round
(
this
.
_canvasPosition
.
x
*
devicePixelRatio
)
;
let
canvasY
=
Math
.
round
(
this
.
_canvasPosition
.
y
*
devicePixelRatio
)
;
this
.
ctx
.
save
(
)
;
this
.
ctx
.
translate
(
offset
-
canvasX
offset
-
canvasY
)
;
this
.
ctx
.
setLineDash
(
FLEXBOX_LINES_PROPERTIES
.
item
.
lineDash
)
;
this
.
ctx
.
lineWidth
=
lineWidth
;
this
.
ctx
.
strokeStyle
=
DEFAULT_COLOR
;
let
{
bounds
}
=
this
.
currentQuads
.
content
[
0
]
;
let
flexItems
=
this
.
currentNode
.
children
;
for
(
let
flexItem
of
flexItems
)
{
let
quads
=
getAdjustedQuads
(
this
.
win
flexItem
"
border
"
)
;
if
(
!
quads
.
length
)
{
continue
;
}
let
{
bounds
:
flexItemBounds
}
=
quads
[
0
]
;
let
left
=
Math
.
round
(
flexItemBounds
.
left
-
bounds
.
left
)
;
let
top
=
Math
.
round
(
flexItemBounds
.
top
-
bounds
.
top
)
;
let
right
=
Math
.
round
(
flexItemBounds
.
right
-
bounds
.
left
)
;
let
bottom
=
Math
.
round
(
flexItemBounds
.
bottom
-
bounds
.
top
)
;
clearRect
(
this
.
ctx
left
top
right
bottom
this
.
currentMatrix
)
;
drawRect
(
this
.
ctx
left
top
right
bottom
this
.
currentMatrix
)
;
this
.
ctx
.
stroke
(
)
;
this
.
renderFlexItemBasis
(
flexItem
left
top
right
bottom
bounds
.
width
)
;
}
this
.
ctx
.
restore
(
)
;
}
renderFlexLines
(
)
{
if
(
!
this
.
currentQuads
.
content
|
|
!
this
.
currentQuads
.
content
[
0
]
)
{
return
;
}
let
{
devicePixelRatio
}
=
this
.
win
;
let
lineWidth
=
getDisplayPixelRatio
(
this
.
win
)
;
let
offset
=
(
lineWidth
/
2
)
%
1
;
let
canvasX
=
Math
.
round
(
this
.
_canvasPosition
.
x
*
devicePixelRatio
)
;
let
canvasY
=
Math
.
round
(
this
.
_canvasPosition
.
y
*
devicePixelRatio
)
;
this
.
ctx
.
save
(
)
;
this
.
ctx
.
translate
(
offset
-
canvasX
offset
-
canvasY
)
;
this
.
ctx
.
lineWidth
=
lineWidth
;
this
.
ctx
.
strokeStyle
=
DEFAULT_COLOR
;
let
{
bounds
}
=
this
.
currentQuads
.
content
[
0
]
;
let
flexLines
=
this
.
currentNode
.
getAsFlexContainer
(
)
.
getLines
(
)
;
let
computedStyle
=
getComputedStyle
(
this
.
currentNode
)
;
let
direction
=
computedStyle
.
getPropertyValue
(
"
flex
-
direction
"
)
;
for
(
let
flexLine
of
flexLines
)
{
let
{
crossStart
crossSize
}
=
flexLine
;
if
(
direction
.
startsWith
(
"
column
"
)
)
{
clearRect
(
this
.
ctx
crossStart
0
crossStart
+
crossSize
bounds
.
height
this
.
currentMatrix
)
;
drawRect
(
this
.
ctx
crossStart
0
crossStart
bounds
.
height
this
.
currentMatrix
)
;
this
.
ctx
.
stroke
(
)
;
drawRect
(
this
.
ctx
crossStart
+
crossSize
0
crossStart
+
crossSize
bounds
.
height
this
.
currentMatrix
)
;
this
.
ctx
.
stroke
(
)
;
}
else
{
clearRect
(
this
.
ctx
0
crossStart
bounds
.
width
crossStart
+
crossSize
this
.
currentMatrix
)
;
drawRect
(
this
.
ctx
0
crossStart
bounds
.
width
crossStart
this
.
currentMatrix
)
;
this
.
ctx
.
stroke
(
)
;
drawRect
(
this
.
ctx
0
crossStart
+
crossSize
bounds
.
width
crossStart
+
crossSize
this
.
currentMatrix
)
;
this
.
ctx
.
stroke
(
)
;
}
}
this
.
ctx
.
restore
(
)
;
}
renderJustifyContent
(
)
{
if
(
!
this
.
currentQuads
.
content
|
|
!
this
.
currentQuads
.
content
[
0
]
)
{
return
;
}
let
{
bounds
}
=
this
.
currentQuads
.
content
[
0
]
;
let
flexItems
=
this
.
currentNode
.
children
;
let
flexLines
=
this
.
currentNode
.
getAsFlexContainer
(
)
.
getLines
(
)
;
let
computedStyle
=
getComputedStyle
(
this
.
currentNode
)
;
let
direction
=
computedStyle
.
getPropertyValue
(
"
flex
-
direction
"
)
;
for
(
let
flexLine
of
flexLines
)
{
let
{
crossStart
crossSize
}
=
flexLine
;
if
(
direction
.
startsWith
(
"
column
"
)
)
{
this
.
drawJustifyContent
(
crossStart
0
crossStart
+
crossSize
bounds
.
height
)
;
}
else
{
this
.
drawJustifyContent
(
0
crossStart
bounds
.
width
crossStart
+
crossSize
)
;
}
}
for
(
let
flexItem
of
flexItems
)
{
let
quads
=
getAdjustedQuads
(
this
.
win
flexItem
"
border
"
)
;
if
(
!
quads
.
length
)
{
continue
;
}
let
{
bounds
:
flexItemBounds
}
=
quads
[
0
]
;
let
left
=
Math
.
round
(
flexItemBounds
.
left
-
bounds
.
left
)
;
let
top
=
Math
.
round
(
flexItemBounds
.
top
-
bounds
.
top
)
;
let
right
=
Math
.
round
(
flexItemBounds
.
right
-
bounds
.
left
)
;
let
bottom
=
Math
.
round
(
flexItemBounds
.
bottom
-
bounds
.
top
)
;
let
flexItemComputedStyle
=
getComputedStyle
(
flexItem
)
;
for
(
let
flexLine
of
flexLines
)
{
let
{
crossStart
crossSize
}
=
flexLine
;
crossSize
=
Math
.
round
(
crossSize
)
;
crossStart
=
Math
.
round
(
crossStart
)
;
if
(
direction
.
startsWith
(
"
column
"
)
&
&
crossStart
<
=
left
&
&
left
<
=
right
&
&
right
<
=
crossSize
+
crossStart
)
{
let
marginTop
=
Math
.
round
(
parseFloat
(
flexItemComputedStyle
.
getPropertyValue
(
"
margin
-
top
"
)
)
)
;
let
marginBottom
=
Math
.
round
(
parseFloat
(
flexItemComputedStyle
.
getPropertyValue
(
"
margin
-
bottom
"
)
)
)
;
clearRect
(
this
.
ctx
crossStart
top
-
marginTop
crossSize
+
crossStart
bottom
+
marginBottom
this
.
currentMatrix
)
;
break
;
}
else
if
(
crossStart
<
=
top
&
&
top
<
=
bottom
&
&
bottom
<
=
crossSize
+
crossStart
)
{
let
marginLeft
=
Math
.
round
(
parseFloat
(
flexItemComputedStyle
.
getPropertyValue
(
"
margin
-
left
"
)
)
)
;
let
marginRight
=
Math
.
round
(
parseFloat
(
flexItemComputedStyle
.
getPropertyValue
(
"
margin
-
right
"
)
)
)
;
clearRect
(
this
.
ctx
left
-
marginLeft
crossStart
right
+
marginRight
crossSize
+
crossStart
this
.
currentMatrix
)
;
break
;
}
}
}
this
.
ctx
.
restore
(
)
;
}
_update
(
)
{
setIgnoreLayoutChanges
(
true
)
;
let
root
=
this
.
getElement
(
"
root
"
)
;
root
.
setAttribute
(
"
style
"
"
display
:
none
"
)
;
this
.
win
.
document
.
documentElement
.
offsetWidth
;
let
{
width
height
}
=
this
.
_winDimensions
;
updateCanvasElement
(
this
.
canvas
this
.
_canvasPosition
this
.
win
.
devicePixelRatio
)
;
let
{
currentMatrix
hasNodeTransformations
}
=
getCurrentMatrix
(
this
.
currentNode
this
.
win
)
;
this
.
currentMatrix
=
currentMatrix
;
this
.
hasNodeTransformations
=
hasNodeTransformations
;
this
.
renderFlexContainerFill
(
)
;
this
.
renderFlexLines
(
)
;
this
.
renderJustifyContent
(
)
;
this
.
renderFlexItems
(
)
;
this
.
renderFlexContainerBorder
(
)
;
this
.
_showFlexbox
(
)
;
root
.
setAttribute
(
"
style
"
position
:
absolute
;
width
:
{
width
}
px
;
height
:
{
height
}
px
;
overflow
:
hidden
)
;
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
document
.
documentElement
)
;
return
true
;
}
}
exports
.
FlexboxHighlighter
=
FlexboxHighlighter
;
