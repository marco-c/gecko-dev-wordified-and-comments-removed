"
use
strict
"
;
const
{
AutoRefreshHighlighter
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
highlighters
/
auto
-
refresh
.
js
"
)
;
const
{
CanvasFrameAnonymousContentHelper
isNodeValid
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
highlighters
/
utils
/
markup
.
js
"
)
;
const
{
TEXT_NODE
DOCUMENT_NODE
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
dom
-
node
-
constants
.
js
"
)
;
const
{
getCurrentZoom
setIgnoreLayoutChanges
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
layout
/
utils
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
getBounds
"
"
getBoundsXUL
"
"
Infobar
"
]
"
devtools
/
server
/
actors
/
highlighters
/
utils
/
accessibility
"
true
)
;
class
AccessibleHighlighter
extends
AutoRefreshHighlighter
{
constructor
(
highlighterEnv
)
{
super
(
highlighterEnv
)
;
this
.
ID_CLASS_PREFIX
=
"
accessible
-
"
;
this
.
accessibleInfobar
=
new
Infobar
(
this
)
;
this
.
markup
=
new
CanvasFrameAnonymousContentHelper
(
this
.
highlighterEnv
this
.
_buildMarkup
.
bind
(
this
)
)
;
this
.
isReady
=
this
.
markup
.
initialize
(
)
;
this
.
onPageHide
=
this
.
onPageHide
.
bind
(
this
)
;
this
.
onWillNavigate
=
this
.
onWillNavigate
.
bind
(
this
)
;
this
.
highlighterEnv
.
on
(
"
will
-
navigate
"
this
.
onWillNavigate
)
;
this
.
pageListenerTarget
=
highlighterEnv
.
pageListenerTarget
;
this
.
pageListenerTarget
.
addEventListener
(
"
pagehide
"
this
.
onPageHide
)
;
}
static
get
XULSupported
(
)
{
return
true
;
}
_buildMarkup
(
)
{
const
container
=
this
.
markup
.
createNode
(
{
attributes
:
{
class
:
"
highlighter
-
container
"
"
aria
-
hidden
"
:
"
true
"
}
}
)
;
const
root
=
this
.
markup
.
createNode
(
{
parent
:
container
attributes
:
{
id
:
"
root
"
class
:
"
root
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
const
svg
=
this
.
markup
.
createSVGNode
(
{
nodeType
:
"
svg
"
parent
:
root
attributes
:
{
id
:
"
elements
"
width
:
"
100
%
"
height
:
"
100
%
"
hidden
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
this
.
markup
.
createSVGNode
(
{
nodeType
:
"
path
"
parent
:
svg
attributes
:
{
class
:
"
bounds
"
id
:
"
bounds
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
this
.
accessibleInfobar
.
buildMarkup
(
root
)
;
return
container
;
}
destroy
(
)
{
if
(
this
.
_highlightTimer
)
{
clearTimeout
(
this
.
_highlightTimer
)
;
this
.
_highlightTimer
=
null
;
}
this
.
highlighterEnv
.
off
(
"
will
-
navigate
"
this
.
onWillNavigate
)
;
this
.
pageListenerTarget
.
removeEventListener
(
"
pagehide
"
this
.
onPageHide
)
;
this
.
pageListenerTarget
=
null
;
AutoRefreshHighlighter
.
prototype
.
destroy
.
call
(
this
)
;
this
.
accessibleInfobar
.
destroy
(
)
;
this
.
accessibleInfobar
=
null
;
this
.
markup
.
destroy
(
)
;
}
getElement
(
id
)
{
return
this
.
markup
.
getElement
(
this
.
ID_CLASS_PREFIX
+
id
)
;
}
_isNodeValid
(
node
)
{
return
(
super
.
_isNodeValid
(
node
)
|
|
isNodeValid
(
node
TEXT_NODE
)
|
|
isNodeValid
(
node
DOCUMENT_NODE
)
)
;
}
_show
(
)
{
if
(
this
.
_highlightTimer
)
{
clearTimeout
(
this
.
_highlightTimer
)
;
this
.
_highlightTimer
=
null
;
}
const
{
duration
}
=
this
.
options
;
const
shown
=
this
.
_update
(
)
;
if
(
shown
)
{
this
.
emit
(
"
highlighter
-
event
"
{
options
:
this
.
options
type
:
"
shown
"
}
)
;
if
(
duration
)
{
this
.
_highlightTimer
=
setTimeout
(
(
)
=
>
{
this
.
hide
(
)
;
}
duration
)
;
}
}
return
shown
;
}
_update
(
)
{
let
shown
=
false
;
setIgnoreLayoutChanges
(
true
)
;
if
(
this
.
_updateAccessibleBounds
(
)
)
{
this
.
_showAccessibleBounds
(
)
;
this
.
accessibleInfobar
.
show
(
)
;
shown
=
true
;
}
else
{
this
.
hide
(
)
;
}
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
window
.
document
.
documentElement
)
;
return
shown
;
}
_hide
(
)
{
setIgnoreLayoutChanges
(
true
)
;
this
.
_hideAccessibleBounds
(
)
;
this
.
accessibleInfobar
.
hide
(
)
;
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
window
.
document
.
documentElement
)
;
}
hideAccessibleBounds
(
)
{
if
(
this
.
getElement
(
"
elements
"
)
.
hasAttribute
(
"
hidden
"
)
)
{
return
;
}
this
.
_hideAccessibleBounds
(
)
;
this
.
_shouldRestoreBoundsVisibility
=
true
;
}
showAccessibleBounds
(
)
{
if
(
this
.
_shouldRestoreBoundsVisibility
)
{
this
.
_showAccessibleBounds
(
)
;
}
}
_hideAccessibleBounds
(
)
{
this
.
_shouldRestoreBoundsVisibility
=
null
;
setIgnoreLayoutChanges
(
true
)
;
this
.
getElement
(
"
elements
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
window
.
document
.
documentElement
)
;
}
_showAccessibleBounds
(
)
{
this
.
_shouldRestoreBoundsVisibility
=
null
;
if
(
!
this
.
currentNode
|
|
!
this
.
highlighterEnv
.
window
)
{
return
;
}
setIgnoreLayoutChanges
(
true
)
;
this
.
getElement
(
"
elements
"
)
.
removeAttribute
(
"
hidden
"
)
;
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
window
.
document
.
documentElement
)
;
}
get
_bounds
(
)
{
let
{
win
options
}
=
this
;
let
getBoundsFn
=
getBounds
;
if
(
this
.
options
.
isXUL
)
{
let
zoom
=
getCurrentZoom
(
this
.
currentNode
)
;
zoom
*
=
zoom
;
options
=
{
.
.
.
options
zoom
}
;
getBoundsFn
=
getBoundsXUL
;
win
=
this
.
win
.
parent
.
ownerGlobal
;
}
return
getBoundsFn
(
win
options
)
;
}
_updateAccessibleBounds
(
)
{
const
bounds
=
this
.
_bounds
;
if
(
!
bounds
)
{
this
.
_hide
(
)
;
return
false
;
}
const
boundsEl
=
this
.
getElement
(
"
bounds
"
)
;
const
{
left
right
top
bottom
}
=
bounds
;
const
path
=
M
{
left
}
{
top
}
L
{
right
}
{
top
}
L
{
right
}
{
bottom
}
L
{
left
}
{
bottom
}
;
boundsEl
.
setAttribute
(
"
d
"
path
)
;
const
rootId
=
this
.
ID_CLASS_PREFIX
+
"
elements
"
;
this
.
markup
.
scaleRootElement
(
this
.
currentNode
rootId
)
;
return
true
;
}
onPageHide
(
{
target
}
)
{
if
(
target
.
defaultView
=
=
=
this
.
win
)
{
this
.
hide
(
)
;
}
}
onWillNavigate
(
{
isTopLevel
}
)
{
if
(
isTopLevel
)
{
this
.
hide
(
)
;
}
}
}
exports
.
AccessibleHighlighter
=
AccessibleHighlighter
;
