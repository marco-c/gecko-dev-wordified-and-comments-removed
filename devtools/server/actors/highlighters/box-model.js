"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
{
extend
}
=
require
(
"
sdk
/
core
/
heritage
"
)
;
const
{
AutoRefreshHighlighter
}
=
require
(
"
.
/
auto
-
refresh
"
)
;
const
{
CssGridHighlighter
}
=
require
(
"
.
/
css
-
grid
"
)
;
const
{
CanvasFrameAnonymousContentHelper
createNode
createSVGNode
getBindingElementAndPseudo
hasPseudoClassLock
isNodeValid
moveInfobar
}
=
require
(
"
.
/
utils
/
markup
"
)
;
const
{
setIgnoreLayoutChanges
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
inspector
=
require
(
"
devtools
/
server
/
actors
/
inspector
"
)
;
const
nodeConstants
=
require
(
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
BOX_MODEL_REGIONS
=
[
"
margin
"
"
border
"
"
padding
"
"
content
"
]
;
const
BOX_MODEL_SIDES
=
[
"
top
"
"
right
"
"
bottom
"
"
left
"
]
;
const
GUIDE_STROKE_WIDTH
=
1
;
const
PSEUDO_CLASSES
=
[
"
:
hover
"
"
:
active
"
"
:
focus
"
]
;
const
GRID_ENABLED_PREF
=
"
layout
.
css
.
grid
.
enabled
"
;
function
BoxModelHighlighter
(
highlighterEnv
)
{
AutoRefreshHighlighter
.
call
(
this
highlighterEnv
)
;
if
(
Services
.
prefs
.
getBoolPref
(
GRID_ENABLED_PREF
)
)
{
this
.
cssGridHighlighter
=
new
CssGridHighlighter
(
this
.
highlighterEnv
)
;
}
this
.
markup
=
new
CanvasFrameAnonymousContentHelper
(
this
.
highlighterEnv
this
.
_buildMarkup
.
bind
(
this
)
)
;
this
.
regionFill
=
{
}
;
}
BoxModelHighlighter
.
prototype
=
extend
(
AutoRefreshHighlighter
.
prototype
{
typeName
:
"
BoxModelHighlighter
"
ID_CLASS_PREFIX
:
"
box
-
model
-
"
_buildMarkup
:
function
(
)
{
let
doc
=
this
.
win
.
document
;
let
highlighterContainer
=
doc
.
createElement
(
"
div
"
)
;
highlighterContainer
.
className
=
"
highlighter
-
container
"
;
let
rootWrapper
=
createNode
(
this
.
win
{
parent
:
highlighterContainer
attributes
:
{
"
id
"
:
"
root
"
"
class
"
:
"
root
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
svg
=
createSVGNode
(
this
.
win
{
nodeType
:
"
svg
"
parent
:
rootWrapper
attributes
:
{
"
id
"
:
"
elements
"
"
width
"
:
"
100
%
"
"
height
"
:
"
100
%
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
regions
=
createSVGNode
(
this
.
win
{
nodeType
:
"
g
"
parent
:
svg
attributes
:
{
"
class
"
:
"
regions
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
for
(
let
region
of
BOX_MODEL_REGIONS
)
{
createSVGNode
(
this
.
win
{
nodeType
:
"
path
"
parent
:
regions
attributes
:
{
"
class
"
:
region
"
id
"
:
region
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
}
for
(
let
side
of
BOX_MODEL_SIDES
)
{
createSVGNode
(
this
.
win
{
nodeType
:
"
line
"
parent
:
svg
attributes
:
{
"
class
"
:
"
guide
-
"
+
side
"
id
"
:
"
guide
-
"
+
side
"
stroke
-
width
"
:
GUIDE_STROKE_WIDTH
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
}
let
infobarContainer
=
createNode
(
this
.
win
{
parent
:
rootWrapper
attributes
:
{
"
class
"
:
"
infobar
-
container
"
"
id
"
:
"
infobar
-
container
"
"
position
"
:
"
top
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
infobar
=
createNode
(
this
.
win
{
parent
:
infobarContainer
attributes
:
{
"
class
"
:
"
infobar
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
texthbox
=
createNode
(
this
.
win
{
parent
:
infobar
attributes
:
{
"
class
"
:
"
infobar
-
text
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
span
"
parent
:
texthbox
attributes
:
{
"
class
"
:
"
infobar
-
tagname
"
"
id
"
:
"
infobar
-
tagname
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
span
"
parent
:
texthbox
attributes
:
{
"
class
"
:
"
infobar
-
id
"
"
id
"
:
"
infobar
-
id
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
span
"
parent
:
texthbox
attributes
:
{
"
class
"
:
"
infobar
-
classes
"
"
id
"
:
"
infobar
-
classes
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
span
"
parent
:
texthbox
attributes
:
{
"
class
"
:
"
infobar
-
pseudo
-
classes
"
"
id
"
:
"
infobar
-
pseudo
-
classes
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
span
"
parent
:
texthbox
attributes
:
{
"
class
"
:
"
infobar
-
dimensions
"
"
id
"
:
"
infobar
-
dimensions
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
return
highlighterContainer
;
}
destroy
:
function
(
)
{
AutoRefreshHighlighter
.
prototype
.
destroy
.
call
(
this
)
;
this
.
markup
.
destroy
(
)
;
if
(
this
.
cssGridHighlighter
)
{
this
.
cssGridHighlighter
.
destroy
(
)
;
this
.
cssGridHighlighter
=
null
;
}
}
getElement
:
function
(
id
)
{
return
this
.
markup
.
getElement
(
this
.
ID_CLASS_PREFIX
+
id
)
;
}
_isNodeValid
:
function
(
node
)
{
return
node
&
&
(
isNodeValid
(
node
)
|
|
isNodeValid
(
node
nodeConstants
.
TEXT_NODE
)
)
;
}
_show
:
function
(
)
{
if
(
BOX_MODEL_REGIONS
.
indexOf
(
this
.
options
.
region
)
=
=
-
1
)
{
this
.
options
.
region
=
"
content
"
;
}
if
(
this
.
cssGridHighlighter
)
{
this
.
cssGridHighlighter
.
hide
(
)
;
let
gridNode
;
if
(
this
.
currentNode
&
&
this
.
currentNode
.
getGridFragments
&
&
this
.
currentNode
.
getGridFragments
(
)
.
length
)
{
gridNode
=
this
.
currentNode
;
}
else
if
(
this
.
currentNode
.
parentNode
&
&
this
.
currentNode
.
parentNode
.
getGridFragments
&
&
this
.
currentNode
.
parentNode
.
getGridFragments
(
)
.
length
)
{
gridNode
=
this
.
currentNode
.
parentNode
;
}
if
(
gridNode
)
{
this
.
cssGridHighlighter
.
show
(
gridNode
)
;
this
.
options
.
hideGuides
=
true
;
}
}
let
shown
=
this
.
_update
(
)
;
this
.
_trackMutations
(
)
;
this
.
emit
(
"
ready
"
)
;
return
shown
;
}
_trackMutations
:
function
(
)
{
if
(
isNodeValid
(
this
.
currentNode
)
)
{
let
win
=
this
.
currentNode
.
ownerDocument
.
defaultView
;
this
.
currentNodeObserver
=
new
win
.
MutationObserver
(
this
.
update
)
;
this
.
currentNodeObserver
.
observe
(
this
.
currentNode
{
attributes
:
true
}
)
;
}
}
_untrackMutations
:
function
(
)
{
if
(
isNodeValid
(
this
.
currentNode
)
&
&
this
.
currentNodeObserver
)
{
this
.
currentNodeObserver
.
disconnect
(
)
;
this
.
currentNodeObserver
=
null
;
}
}
_update
:
function
(
)
{
let
shown
=
false
;
setIgnoreLayoutChanges
(
true
)
;
if
(
this
.
_updateBoxModel
(
)
)
{
if
(
!
this
.
options
.
hideInfoBar
&
&
this
.
currentNode
.
nodeType
=
=
=
this
.
currentNode
.
ELEMENT_NODE
)
{
this
.
_showInfobar
(
)
;
}
else
{
this
.
_hideInfobar
(
)
;
}
this
.
_showBoxModel
(
)
;
shown
=
true
;
}
else
{
this
.
_hide
(
)
;
}
setIgnoreLayoutChanges
(
false
this
.
currentNode
.
ownerDocument
.
documentElement
)
;
return
shown
;
}
_hide
:
function
(
)
{
setIgnoreLayoutChanges
(
true
)
;
this
.
_untrackMutations
(
)
;
this
.
_hideBoxModel
(
)
;
this
.
_hideInfobar
(
)
;
if
(
this
.
cssGridHighlighter
)
{
this
.
cssGridHighlighter
.
hide
(
)
;
}
setIgnoreLayoutChanges
(
false
this
.
currentNode
.
ownerDocument
.
documentElement
)
;
}
_hideInfobar
:
function
(
)
{
this
.
getElement
(
"
infobar
-
container
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
_showInfobar
:
function
(
)
{
this
.
getElement
(
"
infobar
-
container
"
)
.
removeAttribute
(
"
hidden
"
)
;
this
.
_updateInfobar
(
)
;
}
_hideBoxModel
:
function
(
)
{
this
.
getElement
(
"
elements
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
_showBoxModel
:
function
(
)
{
this
.
getElement
(
"
elements
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
_getOuterQuad
:
function
(
region
)
{
let
quads
=
this
.
currentQuads
[
region
]
;
if
(
!
quads
.
length
)
{
return
null
;
}
let
quad
=
{
p1
:
{
x
:
Infinity
y
:
Infinity
}
p2
:
{
x
:
-
Infinity
y
:
Infinity
}
p3
:
{
x
:
-
Infinity
y
:
-
Infinity
}
p4
:
{
x
:
Infinity
y
:
-
Infinity
}
bounds
:
{
bottom
:
-
Infinity
height
:
0
left
:
Infinity
right
:
-
Infinity
top
:
Infinity
width
:
0
x
:
0
y
:
0
}
}
;
for
(
let
q
of
quads
)
{
quad
.
p1
.
x
=
Math
.
min
(
quad
.
p1
.
x
q
.
p1
.
x
)
;
quad
.
p1
.
y
=
Math
.
min
(
quad
.
p1
.
y
q
.
p1
.
y
)
;
quad
.
p2
.
x
=
Math
.
max
(
quad
.
p2
.
x
q
.
p2
.
x
)
;
quad
.
p2
.
y
=
Math
.
min
(
quad
.
p2
.
y
q
.
p2
.
y
)
;
quad
.
p3
.
x
=
Math
.
max
(
quad
.
p3
.
x
q
.
p3
.
x
)
;
quad
.
p3
.
y
=
Math
.
max
(
quad
.
p3
.
y
q
.
p3
.
y
)
;
quad
.
p4
.
x
=
Math
.
min
(
quad
.
p4
.
x
q
.
p4
.
x
)
;
quad
.
p4
.
y
=
Math
.
max
(
quad
.
p4
.
y
q
.
p4
.
y
)
;
quad
.
bounds
.
bottom
=
Math
.
max
(
quad
.
bounds
.
bottom
q
.
bounds
.
bottom
)
;
quad
.
bounds
.
top
=
Math
.
min
(
quad
.
bounds
.
top
q
.
bounds
.
top
)
;
quad
.
bounds
.
left
=
Math
.
min
(
quad
.
bounds
.
left
q
.
bounds
.
left
)
;
quad
.
bounds
.
right
=
Math
.
max
(
quad
.
bounds
.
right
q
.
bounds
.
right
)
;
}
quad
.
bounds
.
x
=
quad
.
bounds
.
left
;
quad
.
bounds
.
y
=
quad
.
bounds
.
top
;
quad
.
bounds
.
width
=
quad
.
bounds
.
right
-
quad
.
bounds
.
left
;
quad
.
bounds
.
height
=
quad
.
bounds
.
bottom
-
quad
.
bounds
.
top
;
return
quad
;
}
_updateBoxModel
:
function
(
)
{
let
options
=
this
.
options
;
options
.
region
=
options
.
region
|
|
"
content
"
;
if
(
!
this
.
_nodeNeedsHighlighting
(
)
)
{
this
.
_hideBoxModel
(
)
;
return
false
;
}
for
(
let
i
=
0
;
i
<
BOX_MODEL_REGIONS
.
length
;
i
+
+
)
{
let
boxType
=
BOX_MODEL_REGIONS
[
i
]
;
let
nextBoxType
=
BOX_MODEL_REGIONS
[
i
+
1
]
;
let
box
=
this
.
getElement
(
boxType
)
;
if
(
this
.
regionFill
[
boxType
]
)
{
box
.
setAttribute
(
"
style
"
"
fill
:
"
+
this
.
regionFill
[
boxType
]
)
;
}
else
{
box
.
setAttribute
(
"
style
"
"
"
)
;
}
let
path
=
[
]
;
for
(
let
j
=
0
;
j
<
this
.
currentQuads
[
boxType
]
.
length
;
j
+
+
)
{
let
boxQuad
=
this
.
currentQuads
[
boxType
]
[
j
]
;
let
nextBoxQuad
=
this
.
currentQuads
[
nextBoxType
]
?
this
.
currentQuads
[
nextBoxType
]
[
j
]
:
null
;
path
.
push
(
this
.
_getBoxPathCoordinates
(
boxQuad
nextBoxQuad
)
)
;
}
box
.
setAttribute
(
"
d
"
path
.
join
(
"
"
)
)
;
box
.
removeAttribute
(
"
faded
"
)
;
if
(
options
.
showOnly
&
&
options
.
showOnly
!
=
=
boxType
)
{
if
(
options
.
onlyRegionArea
)
{
box
.
setAttribute
(
"
faded
"
"
true
"
)
;
}
else
{
box
.
removeAttribute
(
"
d
"
)
;
}
}
if
(
boxType
=
=
=
options
.
region
&
&
!
options
.
hideGuides
)
{
this
.
_showGuides
(
boxType
)
;
}
else
if
(
options
.
hideGuides
)
{
this
.
_hideGuides
(
)
;
}
}
let
rootId
=
this
.
ID_CLASS_PREFIX
+
"
root
"
;
this
.
markup
.
scaleRootElement
(
this
.
currentNode
rootId
)
;
return
true
;
}
_getBoxPathCoordinates
:
function
(
boxQuad
nextBoxQuad
)
{
let
{
p1
p2
p3
p4
}
=
boxQuad
;
let
path
;
if
(
!
nextBoxQuad
|
|
!
this
.
options
.
onlyRegionArea
)
{
path
=
"
M
"
+
p1
.
x
+
"
"
+
p1
.
y
+
"
"
+
"
L
"
+
p2
.
x
+
"
"
+
p2
.
y
+
"
"
+
"
L
"
+
p3
.
x
+
"
"
+
p3
.
y
+
"
"
+
"
L
"
+
p4
.
x
+
"
"
+
p4
.
y
;
}
else
{
let
{
p1
:
np1
p2
:
np2
p3
:
np3
p4
:
np4
}
=
nextBoxQuad
;
path
=
"
M
"
+
p1
.
x
+
"
"
+
p1
.
y
+
"
"
+
"
L
"
+
p2
.
x
+
"
"
+
p2
.
y
+
"
"
+
"
L
"
+
p3
.
x
+
"
"
+
p3
.
y
+
"
"
+
"
L
"
+
p4
.
x
+
"
"
+
p4
.
y
+
"
"
+
"
L
"
+
p1
.
x
+
"
"
+
p1
.
y
+
"
"
+
"
L
"
+
np1
.
x
+
"
"
+
np1
.
y
+
"
"
+
"
L
"
+
np4
.
x
+
"
"
+
np4
.
y
+
"
"
+
"
L
"
+
np3
.
x
+
"
"
+
np3
.
y
+
"
"
+
"
L
"
+
np2
.
x
+
"
"
+
np2
.
y
+
"
"
+
"
L
"
+
np1
.
x
+
"
"
+
np1
.
y
;
}
return
path
;
}
_nodeNeedsHighlighting
:
function
(
)
{
return
this
.
currentQuads
.
margin
.
length
|
|
this
.
currentQuads
.
border
.
length
|
|
this
.
currentQuads
.
padding
.
length
|
|
this
.
currentQuads
.
content
.
length
;
}
_getOuterBounds
:
function
(
)
{
for
(
let
region
of
[
"
margin
"
"
border
"
"
padding
"
"
content
"
]
)
{
let
quad
=
this
.
_getOuterQuad
(
region
)
;
if
(
!
quad
)
{
break
;
}
let
{
bottom
height
left
right
top
width
x
y
}
=
quad
.
bounds
;
if
(
width
>
0
|
|
height
>
0
)
{
return
{
bottom
height
left
right
top
width
x
y
}
;
}
}
return
{
bottom
:
0
height
:
0
left
:
0
right
:
0
top
:
0
width
:
0
x
:
0
y
:
0
}
;
}
_showGuides
:
function
(
region
)
{
let
{
p1
p2
p3
p4
}
=
this
.
_getOuterQuad
(
region
)
;
let
allX
=
[
p1
.
x
p2
.
x
p3
.
x
p4
.
x
]
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
let
allY
=
[
p1
.
y
p2
.
y
p3
.
y
p4
.
y
]
.
sort
(
(
a
b
)
=
>
a
-
b
)
;
let
toShowX
=
[
]
;
let
toShowY
=
[
]
;
for
(
let
arr
of
[
allX
allY
]
)
{
for
(
let
i
=
0
;
i
<
arr
.
length
;
i
+
+
)
{
let
val
=
arr
[
i
]
;
if
(
i
!
=
=
arr
.
lastIndexOf
(
val
)
)
{
if
(
arr
=
=
=
allX
)
{
toShowX
.
push
(
val
)
;
}
else
{
toShowY
.
push
(
val
)
;
}
arr
.
splice
(
arr
.
lastIndexOf
(
val
)
1
)
;
}
}
}
this
.
_updateGuide
(
"
top
"
toShowY
[
0
]
)
;
this
.
_updateGuide
(
"
right
"
toShowX
[
1
]
)
;
this
.
_updateGuide
(
"
bottom
"
toShowY
[
1
]
)
;
this
.
_updateGuide
(
"
left
"
toShowX
[
0
]
)
;
}
_hideGuides
:
function
(
)
{
for
(
let
side
of
BOX_MODEL_SIDES
)
{
this
.
getElement
(
"
guide
-
"
+
side
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
_updateGuide
:
function
(
side
point
=
-
1
)
{
let
guide
=
this
.
getElement
(
"
guide
-
"
+
side
)
;
if
(
point
<
=
0
)
{
guide
.
setAttribute
(
"
hidden
"
"
true
"
)
;
return
false
;
}
if
(
side
=
=
=
"
top
"
|
|
side
=
=
=
"
bottom
"
)
{
guide
.
setAttribute
(
"
x1
"
"
0
"
)
;
guide
.
setAttribute
(
"
y1
"
point
+
"
"
)
;
guide
.
setAttribute
(
"
x2
"
"
100
%
"
)
;
guide
.
setAttribute
(
"
y2
"
point
+
"
"
)
;
}
else
{
guide
.
setAttribute
(
"
x1
"
point
+
"
"
)
;
guide
.
setAttribute
(
"
y1
"
"
0
"
)
;
guide
.
setAttribute
(
"
x2
"
point
+
"
"
)
;
guide
.
setAttribute
(
"
y2
"
"
100
%
"
)
;
}
guide
.
removeAttribute
(
"
hidden
"
)
;
return
true
;
}
_updateInfobar
:
function
(
)
{
if
(
!
this
.
currentNode
)
{
return
;
}
let
{
bindingElement
:
node
pseudo
}
=
getBindingElementAndPseudo
(
this
.
currentNode
)
;
let
displayName
=
inspector
.
getNodeDisplayName
(
node
)
;
let
id
=
node
.
id
?
"
#
"
+
node
.
id
:
"
"
;
let
classList
=
(
node
.
classList
|
|
[
]
)
.
length
?
"
.
"
+
[
.
.
.
node
.
classList
]
.
join
(
"
.
"
)
:
"
"
;
let
pseudos
=
PSEUDO_CLASSES
.
filter
(
pseudo
=
>
{
return
hasPseudoClassLock
(
node
pseudo
)
;
}
this
)
.
join
(
"
"
)
;
if
(
pseudo
)
{
pseudos
+
=
"
:
"
+
pseudo
;
}
let
rect
=
this
.
_getOuterQuad
(
"
border
"
)
.
bounds
;
let
dim
=
parseFloat
(
rect
.
width
.
toPrecision
(
6
)
)
+
"
\
u00D7
"
+
parseFloat
(
rect
.
height
.
toPrecision
(
6
)
)
;
this
.
getElement
(
"
infobar
-
tagname
"
)
.
setTextContent
(
displayName
)
;
this
.
getElement
(
"
infobar
-
id
"
)
.
setTextContent
(
id
)
;
this
.
getElement
(
"
infobar
-
classes
"
)
.
setTextContent
(
classList
)
;
this
.
getElement
(
"
infobar
-
pseudo
-
classes
"
)
.
setTextContent
(
pseudos
)
;
this
.
getElement
(
"
infobar
-
dimensions
"
)
.
setTextContent
(
dim
)
;
this
.
_moveInfobar
(
)
;
}
_moveInfobar
:
function
(
)
{
let
bounds
=
this
.
_getOuterBounds
(
)
;
let
container
=
this
.
getElement
(
"
infobar
-
container
"
)
;
moveInfobar
(
container
bounds
this
.
win
)
;
}
}
)
;
exports
.
BoxModelHighlighter
=
BoxModelHighlighter
;
