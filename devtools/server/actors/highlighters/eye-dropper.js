"
use
strict
"
;
const
{
Ci
Cc
}
=
require
(
"
chrome
"
)
;
const
{
CanvasFrameAnonymousContentHelper
createNode
}
=
require
(
"
.
/
utils
/
markup
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
rgbToHsl
rgbToColorName
}
=
require
(
"
devtools
/
shared
/
css
/
color
"
)
.
colorUtils
;
const
{
getCurrentZoom
getFrameOffsets
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
loader
.
lazyGetter
(
this
"
clipboardHelper
"
(
)
=
>
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
)
;
loader
.
lazyGetter
(
this
"
l10n
"
(
)
=
>
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
devtools
/
locale
/
eyedropper
.
properties
"
)
)
;
const
ZOOM_LEVEL_PREF
=
"
devtools
.
eyedropper
.
zoom
"
;
const
FORMAT_PREF
=
"
devtools
.
defaultColorUnit
"
;
const
MAGNIFIER_WIDTH
=
96
;
const
MAGNIFIER_HEIGHT
=
96
;
const
DEFAULT_START_POS_X
=
100
;
const
DEFAULT_START_POS_Y
=
100
;
const
CLOSE_DELAY
=
750
;
function
EyeDropper
(
highlighterEnv
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
highlighterEnv
=
highlighterEnv
;
this
.
markup
=
new
CanvasFrameAnonymousContentHelper
(
this
.
highlighterEnv
this
.
_buildMarkup
.
bind
(
this
)
)
;
this
.
format
=
Services
.
prefs
.
getCharPref
(
FORMAT_PREF
)
;
this
.
eyeDropperZoomLevel
=
Services
.
prefs
.
getIntPref
(
ZOOM_LEVEL_PREF
)
;
}
EyeDropper
.
prototype
=
{
typeName
:
"
EyeDropper
"
ID_CLASS_PREFIX
:
"
eye
-
dropper
-
"
get
win
(
)
{
return
this
.
highlighterEnv
.
window
;
}
_buildMarkup
(
)
{
let
container
=
createNode
(
this
.
win
{
attributes
:
{
"
class
"
:
"
highlighter
-
container
"
}
}
)
;
let
wrapper
=
createNode
(
this
.
win
{
parent
:
container
attributes
:
{
"
id
"
:
"
root
"
"
class
"
:
"
root
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
parent
:
wrapper
nodeType
:
"
canvas
"
attributes
:
{
"
id
"
:
"
canvas
"
"
class
"
:
"
canvas
"
"
width
"
:
MAGNIFIER_WIDTH
"
height
"
:
MAGNIFIER_HEIGHT
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
colorLabelContainer
=
createNode
(
this
.
win
{
parent
:
wrapper
attributes
:
{
"
class
"
:
"
color
-
container
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
div
"
parent
:
colorLabelContainer
attributes
:
{
"
id
"
:
"
color
-
preview
"
"
class
"
:
"
color
-
preview
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
div
"
parent
:
colorLabelContainer
attributes
:
{
"
id
"
:
"
color
-
value
"
"
class
"
:
"
color
-
value
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
return
container
;
}
destroy
(
)
{
this
.
hide
(
)
;
this
.
markup
.
destroy
(
)
;
}
getElement
(
id
)
{
return
this
.
markup
.
getElement
(
this
.
ID_CLASS_PREFIX
+
id
)
;
}
show
(
node
options
=
{
}
)
{
if
(
this
.
highlighterEnv
.
isXUL
)
{
return
false
;
}
this
.
options
=
options
;
this
.
pageZoom
=
getCurrentZoom
(
this
.
win
)
;
this
.
prepareImageCapture
(
)
;
let
{
pageListenerTarget
}
=
this
.
highlighterEnv
;
pageListenerTarget
.
addEventListener
(
"
mousemove
"
this
)
;
pageListenerTarget
.
addEventListener
(
"
click
"
this
true
)
;
pageListenerTarget
.
addEventListener
(
"
keydown
"
this
)
;
pageListenerTarget
.
addEventListener
(
"
DOMMouseScroll
"
this
)
;
pageListenerTarget
.
addEventListener
(
"
FullZoomChange
"
this
)
;
this
.
getElement
(
"
root
"
)
.
removeAttribute
(
"
hidden
"
)
;
this
.
ctx
=
this
.
getElement
(
"
canvas
"
)
.
getCanvasContext
(
)
;
this
.
ctx
.
imageSmoothingEnabled
=
false
;
this
.
magnifiedArea
=
{
width
:
MAGNIFIER_WIDTH
height
:
MAGNIFIER_HEIGHT
x
:
DEFAULT_START_POS_X
y
:
DEFAULT_START_POS_Y
}
;
this
.
moveTo
(
DEFAULT_START_POS_X
DEFAULT_START_POS_Y
)
;
this
.
win
.
focus
(
)
;
return
true
;
}
hide
(
)
{
if
(
this
.
highlighterEnv
.
isXUL
)
{
return
;
}
this
.
pageImage
=
null
;
let
{
pageListenerTarget
}
=
this
.
highlighterEnv
;
pageListenerTarget
.
removeEventListener
(
"
mousemove
"
this
)
;
pageListenerTarget
.
removeEventListener
(
"
click
"
this
true
)
;
pageListenerTarget
.
removeEventListener
(
"
keydown
"
this
)
;
pageListenerTarget
.
removeEventListener
(
"
DOMMouseScroll
"
this
)
;
pageListenerTarget
.
removeEventListener
(
"
FullZoomChange
"
this
)
;
this
.
getElement
(
"
root
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
this
.
getElement
(
"
root
"
)
.
removeAttribute
(
"
drawn
"
)
;
this
.
emit
(
"
hidden
"
)
;
}
prepareImageCapture
(
)
{
let
imageData
=
getWindowAsImageData
(
this
.
win
)
;
this
.
win
.
createImageBitmap
(
imageData
)
.
then
(
image
=
>
{
this
.
pageImage
=
image
;
this
.
draw
(
)
;
this
.
getElement
(
"
root
"
)
.
setAttribute
(
"
drawn
"
"
true
"
)
;
}
)
;
}
get
cellsWide
(
)
{
let
cellsWide
=
Math
.
ceil
(
this
.
magnifiedArea
.
width
/
this
.
eyeDropperZoomLevel
)
;
cellsWide
+
=
cellsWide
%
2
;
return
cellsWide
;
}
get
cellSize
(
)
{
return
this
.
magnifiedArea
.
width
/
this
.
cellsWide
;
}
get
centerCell
(
)
{
return
Math
.
floor
(
this
.
cellsWide
/
2
)
;
}
get
centerColor
(
)
{
let
pos
=
(
this
.
centerCell
*
this
.
cellSize
)
+
(
this
.
cellSize
/
2
)
;
let
rgb
=
this
.
ctx
.
getImageData
(
pos
pos
1
1
)
.
data
;
return
rgb
;
}
draw
(
)
{
if
(
!
this
.
pageImage
)
{
return
;
}
let
{
width
height
x
y
}
=
this
.
magnifiedArea
;
let
zoomedWidth
=
width
/
this
.
eyeDropperZoomLevel
;
let
zoomedHeight
=
height
/
this
.
eyeDropperZoomLevel
;
let
sx
=
x
-
(
zoomedWidth
/
2
)
;
let
sy
=
y
-
(
zoomedHeight
/
2
)
;
let
sw
=
zoomedWidth
;
let
sh
=
zoomedHeight
;
this
.
ctx
.
drawImage
(
this
.
pageImage
sx
sy
sw
sh
0
0
width
height
)
;
if
(
this
.
eyeDropperZoomLevel
>
2
)
{
this
.
drawGrid
(
)
;
}
this
.
drawCrosshair
(
)
;
let
rgb
=
this
.
centerColor
;
this
.
getElement
(
"
color
-
preview
"
)
.
setAttribute
(
"
style
"
background
-
color
:
{
toColorString
(
rgb
"
rgb
"
)
}
;
)
;
this
.
getElement
(
"
color
-
value
"
)
.
setTextContent
(
toColorString
(
rgb
this
.
format
)
)
;
}
drawGrid
(
)
{
let
{
width
height
}
=
this
.
magnifiedArea
;
this
.
ctx
.
lineWidth
=
1
;
this
.
ctx
.
strokeStyle
=
"
rgba
(
143
143
143
0
.
2
)
"
;
for
(
let
i
=
0
;
i
<
width
;
i
+
=
this
.
cellSize
)
{
this
.
ctx
.
beginPath
(
)
;
this
.
ctx
.
moveTo
(
i
-
.
5
0
)
;
this
.
ctx
.
lineTo
(
i
-
.
5
height
)
;
this
.
ctx
.
stroke
(
)
;
this
.
ctx
.
beginPath
(
)
;
this
.
ctx
.
moveTo
(
0
i
-
.
5
)
;
this
.
ctx
.
lineTo
(
width
i
-
.
5
)
;
this
.
ctx
.
stroke
(
)
;
}
}
drawCrosshair
(
)
{
let
pos
=
this
.
centerCell
*
this
.
cellSize
;
this
.
ctx
.
lineWidth
=
1
;
this
.
ctx
.
lineJoin
=
"
miter
"
;
this
.
ctx
.
strokeStyle
=
"
rgba
(
0
0
0
1
)
"
;
this
.
ctx
.
strokeRect
(
pos
-
1
.
5
pos
-
1
.
5
this
.
cellSize
+
2
this
.
cellSize
+
2
)
;
this
.
ctx
.
strokeStyle
=
"
rgba
(
255
255
255
1
)
"
;
this
.
ctx
.
strokeRect
(
pos
-
0
.
5
pos
-
0
.
5
this
.
cellSize
this
.
cellSize
)
;
}
handleEvent
(
e
)
{
switch
(
e
.
type
)
{
case
"
mousemove
"
:
let
[
xOffset
yOffset
]
=
getFrameOffsets
(
this
.
win
e
.
target
)
;
let
x
=
xOffset
+
e
.
pageX
-
this
.
win
.
scrollX
;
let
y
=
yOffset
+
e
.
pageY
-
this
.
win
.
scrollY
;
this
.
magnifiedArea
.
x
=
x
*
this
.
pageZoom
;
this
.
magnifiedArea
.
y
=
y
*
this
.
pageZoom
;
this
.
draw
(
)
;
this
.
moveTo
(
x
y
)
;
break
;
case
"
click
"
:
this
.
selectColor
(
)
;
break
;
case
"
keydown
"
:
this
.
handleKeyDown
(
e
)
;
break
;
case
"
DOMMouseScroll
"
:
e
.
preventDefault
(
)
;
break
;
case
"
FullZoomChange
"
:
this
.
hide
(
)
;
this
.
show
(
)
;
break
;
}
}
moveTo
(
x
y
)
{
let
root
=
this
.
getElement
(
"
root
"
)
;
root
.
setAttribute
(
"
style
"
top
:
{
y
}
px
;
left
:
{
x
}
px
;
)
;
if
(
y
>
=
this
.
win
.
innerHeight
-
MAGNIFIER_HEIGHT
)
{
root
.
setAttribute
(
"
top
"
"
"
)
;
}
else
{
root
.
removeAttribute
(
"
top
"
)
;
}
root
.
removeAttribute
(
"
left
"
)
;
root
.
removeAttribute
(
"
right
"
)
;
if
(
x
<
=
MAGNIFIER_WIDTH
)
{
root
.
setAttribute
(
"
right
"
"
"
)
;
}
else
if
(
x
>
=
this
.
win
.
innerWidth
-
MAGNIFIER_WIDTH
)
{
root
.
setAttribute
(
"
left
"
"
"
)
;
}
}
selectColor
(
)
{
let
onColorSelected
=
Promise
.
resolve
(
)
;
if
(
this
.
options
.
copyOnSelect
)
{
onColorSelected
=
this
.
copyColor
(
)
;
}
this
.
emit
(
"
selected
"
toColorString
(
this
.
centerColor
this
.
format
)
)
;
onColorSelected
.
then
(
(
)
=
>
this
.
hide
(
)
e
=
>
console
.
error
(
e
)
)
;
}
handleKeyDown
(
e
)
{
if
(
e
.
metaKey
|
|
e
.
ctrlKey
|
|
e
.
altKey
)
{
return
;
}
if
(
e
.
keyCode
=
=
=
e
.
DOM_VK_RETURN
)
{
this
.
selectColor
(
)
;
e
.
preventDefault
(
)
;
return
;
}
if
(
e
.
keyCode
=
=
=
e
.
DOM_VK_ESCAPE
)
{
this
.
emit
(
"
canceled
"
)
;
this
.
hide
(
)
;
e
.
preventDefault
(
)
;
return
;
}
let
offsetX
=
0
;
let
offsetY
=
0
;
let
modifier
=
1
;
if
(
e
.
keyCode
=
=
=
e
.
DOM_VK_LEFT
)
{
offsetX
=
-
1
;
}
else
if
(
e
.
keyCode
=
=
=
e
.
DOM_VK_RIGHT
)
{
offsetX
=
1
;
}
else
if
(
e
.
keyCode
=
=
=
e
.
DOM_VK_UP
)
{
offsetY
=
-
1
;
}
else
if
(
e
.
keyCode
=
=
=
e
.
DOM_VK_DOWN
)
{
offsetY
=
1
;
}
if
(
e
.
shiftKey
)
{
modifier
=
10
;
}
offsetY
*
=
modifier
;
offsetX
*
=
modifier
;
if
(
offsetX
!
=
=
0
|
|
offsetY
!
=
=
0
)
{
this
.
magnifiedArea
.
x
=
cap
(
this
.
magnifiedArea
.
x
+
offsetX
0
this
.
win
.
innerWidth
*
this
.
pageZoom
)
;
this
.
magnifiedArea
.
y
=
cap
(
this
.
magnifiedArea
.
y
+
offsetY
0
this
.
win
.
innerHeight
*
this
.
pageZoom
)
;
this
.
draw
(
)
;
this
.
moveTo
(
this
.
magnifiedArea
.
x
/
this
.
pageZoom
this
.
magnifiedArea
.
y
/
this
.
pageZoom
)
;
e
.
preventDefault
(
)
;
}
}
copyColor
(
)
{
let
color
=
toColorString
(
this
.
centerColor
this
.
format
)
;
clipboardHelper
.
copyString
(
color
)
;
this
.
getElement
(
"
color
-
value
"
)
.
setTextContent
(
"
"
+
l10n
.
GetStringFromName
(
"
colorValue
.
copied
"
)
)
;
clearTimeout
(
this
.
_copyTimeout
)
;
return
new
Promise
(
resolve
=
>
{
this
.
_copyTimeout
=
setTimeout
(
resolve
CLOSE_DELAY
)
;
}
)
;
}
}
;
exports
.
EyeDropper
=
EyeDropper
;
function
getWindowAsImageData
(
win
)
{
let
canvas
=
win
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
let
scale
=
getCurrentZoom
(
win
)
;
let
width
=
win
.
innerWidth
;
let
height
=
win
.
innerHeight
;
canvas
.
width
=
width
*
scale
;
canvas
.
height
=
height
*
scale
;
canvas
.
mozOpaque
=
true
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
scale
(
scale
scale
)
;
ctx
.
drawWindow
(
win
win
.
scrollX
win
.
scrollY
width
height
"
#
fff
"
)
;
return
ctx
.
getImageData
(
0
0
canvas
.
width
canvas
.
height
)
;
}
function
toColorString
(
rgb
format
)
{
let
[
r
g
b
]
=
rgb
;
switch
(
format
)
{
case
"
hex
"
:
return
hexString
(
rgb
)
;
case
"
rgb
"
:
return
"
rgb
(
"
+
r
+
"
"
+
g
+
"
"
+
b
+
"
)
"
;
case
"
hsl
"
:
let
[
h
s
l
]
=
rgbToHsl
(
rgb
)
;
return
"
hsl
(
"
+
h
+
"
"
+
s
+
"
%
"
+
l
+
"
%
)
"
;
case
"
name
"
:
let
str
;
try
{
str
=
rgbToColorName
(
r
g
b
)
;
}
catch
(
e
)
{
str
=
hexString
(
rgb
)
;
}
return
str
;
default
:
return
hexString
(
rgb
)
;
}
}
function
hexString
(
[
r
g
b
]
)
{
let
val
=
(
1
<
<
24
)
+
(
r
<
<
16
)
+
(
g
<
<
8
)
+
(
b
<
<
0
)
;
return
"
#
"
+
val
.
toString
(
16
)
.
substr
(
-
6
)
.
toUpperCase
(
)
;
}
function
cap
(
value
min
max
)
{
return
Math
.
max
(
min
Math
.
min
(
value
max
)
)
;
}
