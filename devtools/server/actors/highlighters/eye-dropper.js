"
use
strict
"
;
const
{
CanvasFrameAnonymousContentHelper
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
highlighters
/
utils
/
markup
.
js
"
)
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
const
{
rgbToHsl
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
css
/
color
.
js
"
)
.
colorUtils
;
const
{
getCurrentZoom
getFrameOffsets
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
layout
/
utils
.
js
"
)
;
const
{
debounce
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
debounce
.
js
"
)
;
loader
.
lazyGetter
(
this
"
clipboardHelper
"
(
)
=
>
Cc
[
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
]
.
getService
(
Ci
.
nsIClipboardHelper
)
)
;
loader
.
lazyGetter
(
this
"
l10n
"
(
)
=
>
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
devtools
-
shared
/
locale
/
eyedropper
.
properties
"
)
)
;
const
ZOOM_LEVEL_PREF
=
"
devtools
.
eyedropper
.
zoom
"
;
const
FORMAT_PREF
=
"
devtools
.
defaultColorUnit
"
;
const
MAGNIFIER_WIDTH
=
96
;
const
MAGNIFIER_HEIGHT
=
96
;
const
DEFAULT_START_POS_X
=
100
;
const
DEFAULT_START_POS_Y
=
100
;
const
CLOSE_DELAY
=
750
;
class
EyeDropper
{
#
pageEventListenersAbortController
;
#
debouncedUpdateScreenshot
;
constructor
(
highlighterEnv
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
highlighterEnv
=
highlighterEnv
;
this
.
markup
=
new
CanvasFrameAnonymousContentHelper
(
this
.
highlighterEnv
this
.
_buildMarkup
.
bind
(
this
)
)
;
this
.
isReady
=
this
.
markup
.
initialize
(
)
;
this
.
format
=
Services
.
prefs
.
getCharPref
(
FORMAT_PREF
)
;
this
.
eyeDropperZoomLevel
=
Services
.
prefs
.
getIntPref
(
ZOOM_LEVEL_PREF
)
;
this
.
#
debouncedUpdateScreenshot
=
debounce
(
this
.
updateScreenshot
.
bind
(
this
)
200
this
)
;
}
get
win
(
)
{
return
this
.
highlighterEnv
.
window
;
}
_buildMarkup
(
)
{
const
container
=
this
.
markup
.
createNode
(
{
attributes
:
{
class
:
"
highlighter
-
container
"
}
}
)
;
const
wrapper
=
this
.
markup
.
createNode
(
{
parent
:
container
attributes
:
{
id
:
"
eye
-
dropper
-
root
"
class
:
"
eye
-
dropper
-
root
"
hidden
:
"
true
"
}
}
)
;
this
.
markup
.
createNode
(
{
parent
:
wrapper
nodeType
:
"
canvas
"
attributes
:
{
id
:
"
eye
-
dropper
-
canvas
"
class
:
"
eye
-
dropper
-
canvas
"
width
:
MAGNIFIER_WIDTH
height
:
MAGNIFIER_HEIGHT
}
}
)
;
const
colorLabelContainer
=
this
.
markup
.
createNode
(
{
parent
:
wrapper
attributes
:
{
class
:
"
eye
-
dropper
-
color
-
container
"
}
}
)
;
this
.
markup
.
createNode
(
{
nodeType
:
"
div
"
parent
:
colorLabelContainer
attributes
:
{
id
:
"
eye
-
dropper
-
color
-
preview
"
class
:
"
eye
-
dropper
-
color
-
preview
"
}
}
)
;
this
.
markup
.
createNode
(
{
nodeType
:
"
div
"
parent
:
colorLabelContainer
attributes
:
{
id
:
"
eye
-
dropper
-
color
-
value
"
class
:
"
eye
-
dropper
-
color
-
value
"
}
}
)
;
return
container
;
}
destroy
(
)
{
this
.
hide
(
)
;
this
.
markup
.
destroy
(
)
;
}
getElement
(
id
)
{
return
this
.
markup
.
getElement
(
id
)
;
}
show
(
node
options
=
{
}
)
{
if
(
this
.
highlighterEnv
.
isXUL
)
{
return
false
;
}
this
.
options
=
options
;
this
.
pageZoom
=
getCurrentZoom
(
this
.
win
)
;
this
.
updateScreenshot
(
options
.
screenshot
)
;
const
{
pageListenerTarget
}
=
this
.
highlighterEnv
;
this
.
#
pageEventListenersAbortController
=
new
AbortController
(
)
;
const
signal
=
this
.
#
pageEventListenersAbortController
.
signal
;
pageListenerTarget
.
addEventListener
(
"
mousemove
"
this
{
signal
}
)
;
pageListenerTarget
.
addEventListener
(
"
click
"
this
{
signal
useCapture
:
true
}
)
;
pageListenerTarget
.
addEventListener
(
"
keydown
"
this
{
signal
}
)
;
pageListenerTarget
.
addEventListener
(
"
DOMMouseScroll
"
this
{
signal
}
)
;
pageListenerTarget
.
addEventListener
(
"
FullZoomChange
"
this
{
signal
}
)
;
pageListenerTarget
.
addEventListener
(
"
resize
"
this
{
signal
}
)
;
this
.
ctx
=
this
.
getElement
(
"
eye
-
dropper
-
canvas
"
)
.
getCanvasContext
(
)
;
this
.
ctx
.
imageSmoothingEnabled
=
false
;
this
.
magnifiedArea
=
{
width
:
MAGNIFIER_WIDTH
height
:
MAGNIFIER_HEIGHT
x
:
DEFAULT_START_POS_X
y
:
DEFAULT_START_POS_Y
}
;
this
.
moveTo
(
DEFAULT_START_POS_X
DEFAULT_START_POS_Y
)
;
this
.
win
.
focus
(
)
;
this
.
win
.
document
.
setSuppressedEventListener
(
this
)
;
return
true
;
}
hide
(
)
{
this
.
pageImage
=
null
;
if
(
this
.
#
pageEventListenersAbortController
)
{
this
.
#
pageEventListenersAbortController
.
abort
(
)
;
this
.
#
pageEventListenersAbortController
=
null
;
const
rootElement
=
this
.
getElement
(
"
eye
-
dropper
-
root
"
)
;
rootElement
.
setAttribute
(
"
hidden
"
"
true
"
)
;
rootElement
.
removeAttribute
(
"
drawn
"
)
;
this
.
emit
(
"
hidden
"
)
;
this
.
win
.
document
.
setSuppressedEventListener
(
null
)
;
}
}
#
dataURItoBlob
(
dataURI
)
{
const
byteString
=
atob
(
dataURI
.
split
(
"
"
)
[
1
]
)
;
const
buffer
=
new
ArrayBuffer
(
byteString
.
length
)
;
const
typedArray
=
new
Uint8Array
(
buffer
)
;
for
(
let
i
=
0
;
i
<
byteString
.
length
;
i
+
+
)
{
typedArray
[
i
]
=
byteString
.
charCodeAt
(
i
)
;
}
return
new
Blob
(
[
buffer
]
{
type
:
"
image
/
png
"
}
)
;
}
async
updateScreenshot
(
screenshot
)
{
const
rootElement
=
this
.
getElement
(
"
eye
-
dropper
-
root
"
)
;
let
imageSource
;
if
(
screenshot
)
{
imageSource
=
this
.
#
dataURItoBlob
(
screenshot
)
;
}
else
{
rootElement
.
setAttribute
(
"
hidden
"
"
true
"
)
;
imageSource
=
getWindowAsImageData
(
this
.
win
)
;
}
const
image
=
await
this
.
win
.
createImageBitmap
(
imageSource
)
;
this
.
pageImage
=
image
;
this
.
draw
(
)
;
rootElement
.
setAttribute
(
"
drawn
"
"
true
"
)
;
rootElement
.
removeAttribute
(
"
hidden
"
)
;
}
get
cellsWide
(
)
{
let
cellsWide
=
Math
.
ceil
(
this
.
magnifiedArea
.
width
/
this
.
eyeDropperZoomLevel
)
;
cellsWide
+
=
cellsWide
%
2
;
return
cellsWide
;
}
get
cellSize
(
)
{
return
this
.
magnifiedArea
.
width
/
this
.
cellsWide
;
}
get
centerCell
(
)
{
return
Math
.
floor
(
this
.
cellsWide
/
2
)
;
}
get
centerColor
(
)
{
const
pos
=
this
.
centerCell
*
this
.
cellSize
+
this
.
cellSize
/
2
;
const
rgb
=
this
.
ctx
.
getImageData
(
pos
pos
1
1
)
.
data
;
return
rgb
;
}
draw
(
)
{
if
(
!
this
.
pageImage
)
{
return
;
}
const
{
width
height
x
y
}
=
this
.
magnifiedArea
;
const
zoomedWidth
=
width
/
this
.
eyeDropperZoomLevel
;
const
zoomedHeight
=
height
/
this
.
eyeDropperZoomLevel
;
const
sx
=
x
-
zoomedWidth
/
2
;
const
sy
=
y
-
zoomedHeight
/
2
;
const
sw
=
zoomedWidth
;
const
sh
=
zoomedHeight
;
this
.
ctx
.
drawImage
(
this
.
pageImage
sx
sy
sw
sh
0
0
width
height
)
;
if
(
this
.
eyeDropperZoomLevel
>
2
)
{
this
.
drawGrid
(
)
;
}
this
.
drawCrosshair
(
)
;
const
rgb
=
this
.
centerColor
;
this
.
getElement
(
"
eye
-
dropper
-
color
-
preview
"
)
.
setAttribute
(
"
style
"
background
-
color
:
{
toColorString
(
rgb
"
rgb
"
)
}
;
)
;
this
.
getElement
(
"
eye
-
dropper
-
color
-
value
"
)
.
setTextContent
(
toColorString
(
rgb
this
.
format
)
)
;
}
drawGrid
(
)
{
const
{
width
height
}
=
this
.
magnifiedArea
;
this
.
ctx
.
lineWidth
=
1
;
this
.
ctx
.
strokeStyle
=
"
rgba
(
143
143
143
0
.
2
)
"
;
for
(
let
i
=
0
;
i
<
width
;
i
+
=
this
.
cellSize
)
{
this
.
ctx
.
beginPath
(
)
;
this
.
ctx
.
moveTo
(
i
-
0
.
5
0
)
;
this
.
ctx
.
lineTo
(
i
-
0
.
5
height
)
;
this
.
ctx
.
stroke
(
)
;
this
.
ctx
.
beginPath
(
)
;
this
.
ctx
.
moveTo
(
0
i
-
0
.
5
)
;
this
.
ctx
.
lineTo
(
width
i
-
0
.
5
)
;
this
.
ctx
.
stroke
(
)
;
}
}
drawCrosshair
(
)
{
const
pos
=
this
.
centerCell
*
this
.
cellSize
;
this
.
ctx
.
lineWidth
=
1
;
this
.
ctx
.
lineJoin
=
"
miter
"
;
this
.
ctx
.
strokeStyle
=
"
rgba
(
0
0
0
1
)
"
;
this
.
ctx
.
strokeRect
(
pos
-
1
.
5
pos
-
1
.
5
this
.
cellSize
+
2
this
.
cellSize
+
2
)
;
this
.
ctx
.
strokeStyle
=
"
rgba
(
255
255
255
1
)
"
;
this
.
ctx
.
strokeRect
(
pos
-
0
.
5
pos
-
0
.
5
this
.
cellSize
this
.
cellSize
)
;
}
handleEvent
(
e
)
{
switch
(
e
.
type
)
{
case
"
mousemove
"
:
const
[
xOffset
yOffset
]
=
getFrameOffsets
(
this
.
win
e
.
target
)
;
const
x
=
xOffset
+
e
.
pageX
-
this
.
win
.
scrollX
;
const
y
=
yOffset
+
e
.
pageY
-
this
.
win
.
scrollY
;
this
.
magnifiedArea
.
x
=
x
*
this
.
pageZoom
;
this
.
magnifiedArea
.
y
=
y
*
this
.
pageZoom
;
this
.
draw
(
)
;
this
.
moveTo
(
x
y
)
;
break
;
case
"
click
"
:
case
"
mouseup
"
:
this
.
selectColor
(
)
;
break
;
case
"
keydown
"
:
this
.
handleKeyDown
(
e
)
;
break
;
case
"
DOMMouseScroll
"
:
e
.
preventDefault
(
)
;
break
;
case
"
FullZoomChange
"
:
this
.
hide
(
)
;
this
.
show
(
)
;
break
;
case
"
resize
"
:
this
.
getElement
(
"
eye
-
dropper
-
root
"
)
.
removeAttribute
(
"
drawn
"
)
;
this
.
#
debouncedUpdateScreenshot
(
)
;
break
;
}
}
moveTo
(
x
y
)
{
const
root
=
this
.
getElement
(
"
eye
-
dropper
-
root
"
)
;
root
.
setAttribute
(
"
style
"
top
:
{
y
}
px
;
left
:
{
x
}
px
;
)
;
if
(
y
>
=
this
.
win
.
innerHeight
-
MAGNIFIER_HEIGHT
)
{
root
.
setAttribute
(
"
top
"
"
"
)
;
}
else
{
root
.
removeAttribute
(
"
top
"
)
;
}
root
.
removeAttribute
(
"
left
"
)
;
root
.
removeAttribute
(
"
right
"
)
;
if
(
x
<
=
MAGNIFIER_WIDTH
)
{
root
.
setAttribute
(
"
right
"
"
"
)
;
}
else
if
(
x
>
=
this
.
win
.
innerWidth
-
MAGNIFIER_WIDTH
)
{
root
.
setAttribute
(
"
left
"
"
"
)
;
}
}
selectColor
(
)
{
let
onColorSelected
=
Promise
.
resolve
(
)
;
if
(
this
.
options
.
copyOnSelect
)
{
onColorSelected
=
this
.
copyColor
(
)
;
}
this
.
emit
(
"
selected
"
toColorString
(
this
.
centerColor
this
.
format
)
)
;
onColorSelected
.
then
(
(
)
=
>
this
.
hide
(
)
console
.
error
)
;
}
handleKeyDown
(
e
)
{
if
(
e
.
metaKey
|
|
e
.
ctrlKey
|
|
e
.
altKey
)
{
return
;
}
if
(
e
.
keyCode
=
=
=
e
.
DOM_VK_RETURN
)
{
this
.
selectColor
(
)
;
e
.
preventDefault
(
)
;
return
;
}
if
(
e
.
keyCode
=
=
=
e
.
DOM_VK_ESCAPE
)
{
this
.
emit
(
"
canceled
"
)
;
this
.
hide
(
)
;
e
.
preventDefault
(
)
;
return
;
}
let
offsetX
=
0
;
let
offsetY
=
0
;
let
modifier
=
1
;
if
(
e
.
keyCode
=
=
=
e
.
DOM_VK_LEFT
)
{
offsetX
=
-
1
;
}
else
if
(
e
.
keyCode
=
=
=
e
.
DOM_VK_RIGHT
)
{
offsetX
=
1
;
}
else
if
(
e
.
keyCode
=
=
=
e
.
DOM_VK_UP
)
{
offsetY
=
-
1
;
}
else
if
(
e
.
keyCode
=
=
=
e
.
DOM_VK_DOWN
)
{
offsetY
=
1
;
}
if
(
e
.
shiftKey
)
{
modifier
=
10
;
}
offsetY
*
=
modifier
;
offsetX
*
=
modifier
;
if
(
offsetX
!
=
=
0
|
|
offsetY
!
=
=
0
)
{
this
.
magnifiedArea
.
x
=
cap
(
this
.
magnifiedArea
.
x
+
offsetX
0
this
.
win
.
innerWidth
*
this
.
pageZoom
)
;
this
.
magnifiedArea
.
y
=
cap
(
this
.
magnifiedArea
.
y
+
offsetY
0
this
.
win
.
innerHeight
*
this
.
pageZoom
)
;
this
.
draw
(
)
;
this
.
moveTo
(
this
.
magnifiedArea
.
x
/
this
.
pageZoom
this
.
magnifiedArea
.
y
/
this
.
pageZoom
)
;
e
.
preventDefault
(
)
;
}
}
copyColor
(
)
{
const
color
=
toColorString
(
this
.
centerColor
this
.
format
)
;
clipboardHelper
.
copyString
(
color
)
;
this
.
getElement
(
"
eye
-
dropper
-
color
-
value
"
)
.
setTextContent
(
"
"
+
l10n
.
GetStringFromName
(
"
colorValue
.
copied
"
)
)
;
clearTimeout
(
this
.
_copyTimeout
)
;
return
new
Promise
(
resolve
=
>
{
this
.
_copyTimeout
=
setTimeout
(
resolve
CLOSE_DELAY
)
;
}
)
;
}
}
exports
.
EyeDropper
=
EyeDropper
;
function
getWindowAsImageData
(
win
)
{
const
canvas
=
win
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
const
scale
=
getCurrentZoom
(
win
)
;
const
width
=
win
.
innerWidth
;
const
height
=
win
.
innerHeight
;
canvas
.
width
=
width
*
scale
;
canvas
.
height
=
height
*
scale
;
canvas
.
mozOpaque
=
true
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
scale
(
scale
scale
)
;
ctx
.
drawWindow
(
win
win
.
scrollX
win
.
scrollY
width
height
"
#
fff
"
)
;
return
ctx
.
getImageData
(
0
0
canvas
.
width
canvas
.
height
)
;
}
function
toColorString
(
rgb
format
)
{
const
[
r
g
b
]
=
rgb
;
switch
(
format
)
{
case
"
hex
"
:
return
hexString
(
rgb
)
;
case
"
rgb
"
:
return
"
rgb
(
"
+
r
+
"
"
+
g
+
"
"
+
b
+
"
)
"
;
case
"
hsl
"
:
const
[
h
s
l
]
=
rgbToHsl
(
rgb
)
;
return
"
hsl
(
"
+
h
+
"
"
+
s
+
"
%
"
+
l
+
"
%
)
"
;
case
"
name
"
:
const
str
=
InspectorUtils
.
rgbToColorName
(
r
g
b
)
|
|
hexString
(
rgb
)
;
return
str
;
default
:
return
hexString
(
rgb
)
;
}
}
function
hexString
(
[
r
g
b
]
)
{
const
val
=
(
1
<
<
24
)
+
(
r
<
<
16
)
+
(
g
<
<
8
)
+
(
b
<
<
0
)
;
return
"
#
"
+
val
.
toString
(
16
)
.
substr
(
-
6
)
;
}
function
cap
(
value
min
max
)
{
return
Math
.
max
(
min
Math
.
min
(
value
max
)
)
;
}
