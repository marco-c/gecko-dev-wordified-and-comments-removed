"
use
strict
"
;
const
{
CanvasFrameAnonymousContentHelper
createSVGNode
createNode
getComputedStyle
}
=
require
(
"
.
/
utils
/
markup
"
)
;
const
{
setIgnoreLayoutChanges
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
{
AutoRefreshHighlighter
}
=
require
(
"
.
/
auto
-
refresh
"
)
;
const
MARKER_SIZE
=
10
;
class
ShapesHighlighter
extends
AutoRefreshHighlighter
{
constructor
(
highlighterEnv
)
{
super
(
highlighterEnv
)
;
this
.
ID_CLASS_PREFIX
=
"
shapes
-
"
;
this
.
markup
=
new
CanvasFrameAnonymousContentHelper
(
this
.
highlighterEnv
this
.
_buildMarkup
.
bind
(
this
)
)
;
}
_buildMarkup
(
)
{
let
container
=
createNode
(
this
.
win
{
attributes
:
{
"
class
"
:
"
highlighter
-
container
"
}
}
)
;
let
rootWrapper
=
createNode
(
this
.
win
{
parent
:
container
attributes
:
{
"
id
"
:
"
root
"
"
class
"
:
"
root
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
mainSvg
=
createSVGNode
(
this
.
win
{
nodeType
:
"
svg
"
parent
:
rootWrapper
attributes
:
{
"
id
"
:
"
shape
-
container
"
"
class
"
:
"
shape
-
container
"
"
viewBox
"
:
"
0
0
100
100
"
"
preserveAspectRatio
"
:
"
none
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
div
"
parent
:
rootWrapper
attributes
:
{
"
id
"
:
"
markers
-
container
"
"
class
"
:
"
markers
-
container
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
polygon
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
polygon
"
"
class
"
:
"
polygon
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
ellipse
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
ellipse
"
"
class
"
:
"
ellipse
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
rect
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
rect
"
"
class
"
:
"
rect
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
return
container
;
}
get
currentDimensions
(
)
{
return
{
width
:
this
.
currentQuads
.
border
[
0
]
.
bounds
.
width
height
:
this
.
currentQuads
.
border
[
0
]
.
bounds
.
height
}
;
}
_parseCSSShapeValue
(
definition
)
{
const
types
=
[
{
name
:
"
polygon
"
prefix
:
"
polygon
(
"
coordParser
:
this
.
polygonPoints
.
bind
(
this
)
}
{
name
:
"
circle
"
prefix
:
"
circle
(
"
coordParser
:
this
.
circlePoints
.
bind
(
this
)
}
{
name
:
"
ellipse
"
prefix
:
"
ellipse
(
"
coordParser
:
this
.
ellipsePoints
.
bind
(
this
)
}
{
name
:
"
inset
"
prefix
:
"
inset
(
"
coordParser
:
this
.
insetPoints
.
bind
(
this
)
}
]
;
for
(
let
{
name
prefix
coordParser
}
of
types
)
{
if
(
definition
.
includes
(
prefix
)
)
{
definition
=
definition
.
substring
(
prefix
.
length
definition
.
length
-
1
)
;
return
{
shapeType
:
name
coordinates
:
coordParser
(
definition
)
}
;
}
}
return
null
;
}
polygonPoints
(
definition
)
{
return
definition
.
split
(
"
"
)
.
map
(
coords
=
>
{
return
splitCoords
(
coords
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
}
)
;
}
circlePoints
(
definition
)
{
let
values
=
definition
.
split
(
"
at
"
)
;
let
radius
=
values
[
0
]
;
let
elemWidth
=
this
.
currentDimensions
.
width
;
let
elemHeight
=
this
.
currentDimensions
.
height
;
let
center
=
splitCoords
(
values
[
1
]
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
if
(
radius
=
=
=
"
closest
-
side
"
)
{
radius
=
Math
.
min
(
center
[
0
]
center
[
1
]
100
-
center
[
0
]
100
-
center
[
1
]
)
;
}
else
if
(
radius
=
=
=
"
farthest
-
side
"
)
{
radius
=
Math
.
max
(
center
[
0
]
center
[
1
]
100
-
center
[
0
]
100
-
center
[
1
]
)
;
}
else
{
radius
=
coordToPercent
(
radius
Math
.
max
(
elemWidth
elemHeight
)
)
;
}
let
computedSize
=
Math
.
sqrt
(
(
elemWidth
*
*
2
)
+
(
elemHeight
*
*
2
)
)
/
Math
.
sqrt
(
2
)
;
let
ratioX
=
elemWidth
/
computedSize
;
let
ratioY
=
elemHeight
/
computedSize
;
let
radiusX
=
radius
/
ratioX
;
let
radiusY
=
radius
/
ratioY
;
return
{
rx
:
radiusX
ry
:
radiusY
cx
:
center
[
0
]
cy
:
center
[
1
]
}
;
}
ellipsePoints
(
definition
)
{
let
values
=
definition
.
split
(
"
at
"
)
;
let
elemWidth
=
this
.
currentDimensions
.
width
;
let
elemHeight
=
this
.
currentDimensions
.
height
;
let
center
=
splitCoords
(
values
[
1
]
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
let
radii
=
values
[
0
]
.
trim
(
)
.
split
(
"
"
)
.
map
(
(
radius
i
)
=
>
{
let
size
=
i
%
2
=
=
=
0
?
elemWidth
:
elemHeight
;
if
(
radius
=
=
=
"
closest
-
side
"
)
{
return
i
%
2
=
=
=
0
?
Math
.
min
(
center
[
0
]
100
-
center
[
0
]
)
:
Math
.
min
(
center
[
1
]
100
-
center
[
1
]
)
;
}
else
if
(
radius
=
=
=
"
farthest
-
side
"
)
{
return
i
%
2
=
=
=
0
?
Math
.
max
(
center
[
0
]
100
-
center
[
0
]
)
:
Math
.
max
(
center
[
1
]
100
-
center
[
1
]
)
;
}
return
coordToPercent
(
radius
size
)
;
}
)
;
return
{
rx
:
radii
[
0
]
ry
:
radii
[
1
]
cx
:
center
[
0
]
cy
:
center
[
1
]
}
;
}
insetPoints
(
definition
)
{
let
values
=
definition
.
split
(
"
round
"
)
;
let
offsets
=
splitCoords
(
values
[
0
]
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
let
x
y
=
0
;
let
width
=
this
.
currentDimensions
.
width
;
let
height
=
this
.
currentDimensions
.
height
;
if
(
offsets
.
length
=
=
=
1
)
{
x
=
y
=
offsets
[
0
]
;
width
=
height
=
100
-
2
*
x
;
}
else
if
(
offsets
.
length
=
=
=
2
)
{
y
=
offsets
[
0
]
;
x
=
offsets
[
1
]
;
height
=
100
-
2
*
y
;
width
=
100
-
2
*
x
;
}
else
if
(
offsets
.
length
=
=
=
3
)
{
y
=
offsets
[
0
]
;
x
=
offsets
[
1
]
;
height
=
100
-
y
-
offsets
[
2
]
;
width
=
100
-
2
*
x
;
}
else
if
(
offsets
.
length
=
=
=
4
)
{
y
=
offsets
[
0
]
;
x
=
offsets
[
3
]
;
height
=
100
-
y
-
offsets
[
2
]
;
width
=
100
-
x
-
offsets
[
1
]
;
}
return
{
x
y
width
height
}
;
}
convertCoordsToPercent
(
coord
i
)
{
let
elemWidth
=
this
.
currentDimensions
.
width
;
let
elemHeight
=
this
.
currentDimensions
.
height
;
let
size
=
i
%
2
=
=
=
0
?
elemWidth
:
elemHeight
;
if
(
coord
.
includes
(
"
calc
(
"
)
)
{
return
evalCalcExpression
(
coord
.
substring
(
5
coord
.
length
-
1
)
size
)
;
}
return
coordToPercent
(
coord
size
)
;
}
destroy
(
)
{
AutoRefreshHighlighter
.
prototype
.
destroy
.
call
(
this
)
;
this
.
markup
.
destroy
(
)
;
}
getElement
(
id
)
{
return
this
.
markup
.
getElement
(
this
.
ID_CLASS_PREFIX
+
id
)
;
}
_show
(
)
{
return
this
.
_update
(
)
;
}
_hasMoved
(
)
{
let
hasMoved
=
AutoRefreshHighlighter
.
prototype
.
_hasMoved
.
call
(
this
)
;
let
oldShapeCoordinates
=
JSON
.
stringify
(
this
.
coordinates
)
;
if
(
this
.
options
.
mode
.
startsWith
(
"
css
"
)
)
{
let
property
=
shapeModeToCssPropertyName
(
this
.
options
.
mode
)
;
let
style
=
getComputedStyle
(
this
.
currentNode
)
[
property
]
;
if
(
!
style
|
|
style
=
=
=
"
none
"
)
{
this
.
coordinates
=
[
]
;
this
.
shapeType
=
"
none
"
;
}
else
{
let
{
coordinates
shapeType
}
=
this
.
_parseCSSShapeValue
(
style
)
;
this
.
coordinates
=
coordinates
;
this
.
shapeType
=
shapeType
;
}
}
let
newShapeCoordinates
=
JSON
.
stringify
(
this
.
coordinates
)
;
return
hasMoved
|
|
oldShapeCoordinates
!
=
=
newShapeCoordinates
;
}
_hideShapes
(
)
{
this
.
getElement
(
"
ellipse
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
polygon
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
rect
"
)
.
setAttribute
(
"
hidden
"
true
)
;
}
_update
(
)
{
setIgnoreLayoutChanges
(
true
)
;
let
{
top
left
width
height
}
=
this
.
currentQuads
.
border
[
0
]
.
bounds
;
this
.
getElement
(
"
shape
-
container
"
)
.
setAttribute
(
"
style
"
top
:
{
top
}
px
;
left
:
{
left
}
px
;
width
:
{
width
}
px
;
height
:
{
height
}
px
;
)
;
this
.
_hideShapes
(
)
;
this
.
getElement
(
"
markers
-
container
"
)
.
setAttribute
(
"
style
"
"
"
)
;
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_updatePolygonShape
(
top
left
width
height
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_updateCircleShape
(
top
left
width
height
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_updateEllipseShape
(
top
left
width
height
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
_updateInsetShape
(
top
left
width
height
)
;
}
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
window
.
document
.
documentElement
)
;
return
true
;
}
_updatePolygonShape
(
top
left
width
height
)
{
let
points
=
this
.
coordinates
.
map
(
point
=
>
point
.
join
(
"
"
)
)
.
join
(
"
"
)
;
let
polygonEl
=
this
.
getElement
(
"
polygon
"
)
;
polygonEl
.
setAttribute
(
"
points
"
points
)
;
polygonEl
.
removeAttribute
(
"
hidden
"
)
;
let
shadows
=
this
.
coordinates
.
map
(
(
[
x
y
]
)
=
>
{
return
{
MARKER_SIZE
+
x
*
width
/
100
}
px
{
MARKER_SIZE
+
y
*
height
/
100
}
px
0
0
;
}
)
.
join
(
"
"
)
;
this
.
getElement
(
"
markers
-
container
"
)
.
setAttribute
(
"
style
"
top
:
{
top
-
MARKER_SIZE
}
px
;
left
:
{
left
-
MARKER_SIZE
}
px
;
box
-
shadow
:
{
shadows
}
;
)
;
}
_updateCircleShape
(
top
left
width
height
)
{
let
{
rx
ry
cx
cy
}
=
this
.
coordinates
;
let
ellipseEl
=
this
.
getElement
(
"
ellipse
"
)
;
ellipseEl
.
setAttribute
(
"
rx
"
rx
)
;
ellipseEl
.
setAttribute
(
"
ry
"
ry
)
;
ellipseEl
.
setAttribute
(
"
cx
"
cx
)
;
ellipseEl
.
setAttribute
(
"
cy
"
cy
)
;
ellipseEl
.
removeAttribute
(
"
hidden
"
)
;
let
shadows
=
{
MARKER_SIZE
+
cx
*
width
/
100
}
px
{
MARKER_SIZE
+
cy
*
height
/
100
}
px
0
0
;
this
.
getElement
(
"
markers
-
container
"
)
.
setAttribute
(
"
style
"
top
:
{
top
-
MARKER_SIZE
}
px
;
left
:
{
left
-
MARKER_SIZE
}
px
;
box
-
shadow
:
{
shadows
}
;
)
;
}
_updateEllipseShape
(
top
left
width
height
)
{
let
{
rx
ry
cx
cy
}
=
this
.
coordinates
;
let
ellipseEl
=
this
.
getElement
(
"
ellipse
"
)
;
ellipseEl
.
setAttribute
(
"
rx
"
rx
)
;
ellipseEl
.
setAttribute
(
"
ry
"
ry
)
;
ellipseEl
.
setAttribute
(
"
cx
"
cx
)
;
ellipseEl
.
setAttribute
(
"
cy
"
cy
)
;
ellipseEl
.
removeAttribute
(
"
hidden
"
)
;
let
shadows
=
{
MARKER_SIZE
+
cx
*
width
/
100
}
px
{
MARKER_SIZE
+
cy
*
height
/
100
}
px
0
0
{
MARKER_SIZE
+
(
cx
+
rx
)
*
height
/
100
}
px
{
MARKER_SIZE
+
cy
*
height
/
100
}
px
0
0
{
MARKER_SIZE
+
cx
*
height
/
100
}
px
{
MARKER_SIZE
+
(
cy
+
ry
)
*
height
/
100
}
px
0
0
;
this
.
getElement
(
"
markers
-
container
"
)
.
setAttribute
(
"
style
"
top
:
{
top
-
MARKER_SIZE
}
px
;
left
:
{
left
-
MARKER_SIZE
}
px
;
box
-
shadow
:
{
shadows
}
;
)
;
}
_updateInsetShape
(
top
left
width
height
)
{
let
rectEl
=
this
.
getElement
(
"
rect
"
)
;
rectEl
.
setAttribute
(
"
x
"
this
.
coordinates
.
x
)
;
rectEl
.
setAttribute
(
"
y
"
this
.
coordinates
.
y
)
;
rectEl
.
setAttribute
(
"
width
"
this
.
coordinates
.
width
)
;
rectEl
.
setAttribute
(
"
height
"
this
.
coordinates
.
height
)
;
rectEl
.
removeAttribute
(
"
hidden
"
)
;
this
.
getElement
(
"
markers
-
container
"
)
.
setAttribute
(
"
style
"
top
:
{
top
-
MARKER_SIZE
}
px
;
left
:
{
left
-
MARKER_SIZE
}
px
;
box
-
shadow
:
none
;
)
;
}
_hide
(
)
{
setIgnoreLayoutChanges
(
true
)
;
this
.
_hideShapes
(
)
;
this
.
getElement
(
"
markers
-
container
"
)
.
setAttribute
(
"
style
"
"
"
)
;
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
window
.
document
.
documentElement
)
;
}
}
function
splitCoords
(
coords
)
{
return
coords
.
trim
(
)
.
replace
(
/
\
+
/
g
"
+
"
)
.
split
(
"
"
)
;
}
function
coordToPercent
(
coord
size
)
{
if
(
coord
.
includes
(
"
%
"
)
)
{
return
parseFloat
(
coord
.
replace
(
"
%
"
"
"
)
)
;
}
else
if
(
coord
.
includes
(
"
px
"
)
)
{
let
px
=
parseFloat
(
coord
.
replace
(
"
px
"
"
"
)
)
;
return
px
*
100
/
size
;
}
return
0
;
}
function
evalCalcExpression
(
expression
size
)
{
let
values
=
expression
.
split
(
"
+
"
)
.
map
(
v
=
>
v
.
trim
(
)
)
;
return
values
.
reduce
(
(
prev
curr
)
=
>
{
return
prev
+
coordToPercent
(
curr
size
)
;
}
0
)
;
}
const
shapeModeToCssPropertyName
=
mode
=
>
{
let
property
=
mode
.
substring
(
3
)
;
return
property
.
substring
(
0
1
)
.
toLowerCase
(
)
+
property
.
substring
(
1
)
;
}
;
exports
.
ShapesHighlighter
=
ShapesHighlighter
;
exports
.
splitCoords
=
splitCoords
;
exports
.
coordToPercent
=
coordToPercent
;
exports
.
evalCalcExpression
=
evalCalcExpression
;
exports
.
shapeModeToCssPropertyName
=
shapeModeToCssPropertyName
;
