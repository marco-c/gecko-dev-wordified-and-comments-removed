"
use
strict
"
;
const
{
CanvasFrameAnonymousContentHelper
createSVGNode
createNode
getComputedStyle
}
=
require
(
"
.
/
utils
/
markup
"
)
;
const
{
setIgnoreLayoutChanges
getCurrentZoom
getAdjustedQuads
getFrameOffsets
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
{
AutoRefreshHighlighter
}
=
require
(
"
.
/
auto
-
refresh
"
)
;
const
{
getDistance
clickedOnEllipseEdge
distanceToLine
projection
clickedOnPoint
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
shapes
-
utils
"
)
;
const
{
identity
apply
translate
multiply
scale
rotate
changeMatrixBase
getBasis
}
=
require
(
"
devtools
/
shared
/
layout
/
dom
-
matrix
-
2d
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
getCSSStyleRules
}
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
BASE_MARKER_SIZE
=
5
;
const
LINE_CLICK_WIDTH
=
5
;
const
ROTATE_LINE_LENGTH
=
50
;
const
DOM_EVENTS
=
[
"
mousedown
"
"
mousemove
"
"
mouseup
"
"
dblclick
"
]
;
const
_dragging
=
Symbol
(
"
shapes
/
dragging
"
)
;
class
ShapesHighlighter
extends
AutoRefreshHighlighter
{
constructor
(
highlighterEnv
)
{
super
(
highlighterEnv
)
;
EventEmitter
.
decorate
(
this
)
;
this
.
ID_CLASS_PREFIX
=
"
shapes
-
"
;
this
.
referenceBox
=
"
border
"
;
this
.
useStrokeBox
=
false
;
this
.
geometryBox
=
"
"
;
this
.
hoveredPoint
=
null
;
this
.
fillRule
=
"
"
;
this
.
numInsetPoints
=
0
;
this
.
transformMode
=
false
;
this
.
viewport
=
{
}
;
this
.
markup
=
new
CanvasFrameAnonymousContentHelper
(
this
.
highlighterEnv
this
.
_buildMarkup
.
bind
(
this
)
)
;
this
.
onPageHide
=
this
.
onPageHide
.
bind
(
this
)
;
let
{
pageListenerTarget
}
=
this
.
highlighterEnv
;
DOM_EVENTS
.
forEach
(
event
=
>
pageListenerTarget
.
addEventListener
(
event
this
)
)
;
pageListenerTarget
.
addEventListener
(
"
pagehide
"
this
.
onPageHide
)
;
}
_buildMarkup
(
)
{
let
container
=
createNode
(
this
.
win
{
attributes
:
{
"
class
"
:
"
highlighter
-
container
"
}
}
)
;
let
rootWrapper
=
createNode
(
this
.
win
{
parent
:
container
attributes
:
{
"
id
"
:
"
root
"
"
class
"
:
"
root
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
mainSvg
=
createSVGNode
(
this
.
win
{
nodeType
:
"
svg
"
parent
:
rootWrapper
attributes
:
{
"
id
"
:
"
shape
-
container
"
"
class
"
:
"
shape
-
container
"
"
viewBox
"
:
"
0
0
100
100
"
"
preserveAspectRatio
"
:
"
none
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
clipSvg
=
createSVGNode
(
this
.
win
{
nodeType
:
"
clipPath
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
clip
-
path
"
"
class
"
:
"
clip
-
path
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
polygon
"
parent
:
clipSvg
attributes
:
{
"
id
"
:
"
clip
-
polygon
"
"
class
"
:
"
clip
-
polygon
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
ellipse
"
parent
:
clipSvg
attributes
:
{
"
id
"
:
"
clip
-
ellipse
"
"
class
"
:
"
clip
-
ellipse
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
rect
"
parent
:
clipSvg
attributes
:
{
"
id
"
:
"
clip
-
rect
"
"
class
"
:
"
clip
-
rect
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
rect
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
quad
"
"
class
"
:
"
quad
"
"
hidden
"
:
"
true
"
"
clip
-
path
"
:
"
url
(
#
shapes
-
clip
-
path
)
"
"
x
"
:
0
"
y
"
:
0
"
width
"
:
100
"
height
"
:
100
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
shapeClipSvg
=
createSVGNode
(
this
.
win
{
nodeType
:
"
clipPath
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
quad
-
clip
-
path
"
"
class
"
:
"
quad
-
clip
-
path
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
rect
"
parent
:
shapeClipSvg
attributes
:
{
"
id
"
:
"
quad
-
clip
"
"
class
"
:
"
quad
-
clip
"
"
x
"
:
-
1
"
y
"
:
-
1
"
width
"
:
102
"
height
"
:
102
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
mainGroup
=
createSVGNode
(
this
.
win
{
nodeType
:
"
g
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
group
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
polygon
"
parent
:
mainGroup
attributes
:
{
"
id
"
:
"
polygon
"
"
class
"
:
"
polygon
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
ellipse
"
parent
:
mainGroup
attributes
:
{
"
id
"
:
"
ellipse
"
"
class
"
:
"
ellipse
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
rect
"
parent
:
mainGroup
attributes
:
{
"
id
"
:
"
rect
"
"
class
"
:
"
rect
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
polygon
"
parent
:
mainGroup
attributes
:
{
"
id
"
:
"
dashed
-
polygon
"
"
class
"
:
"
polygon
"
"
hidden
"
:
"
true
"
"
stroke
-
dasharray
"
:
"
5
5
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
ellipse
"
parent
:
mainGroup
attributes
:
{
"
id
"
:
"
dashed
-
ellipse
"
"
class
"
:
"
ellipse
"
"
hidden
"
:
"
true
"
"
stroke
-
dasharray
"
:
"
5
5
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
rect
"
parent
:
mainGroup
attributes
:
{
"
id
"
:
"
dashed
-
rect
"
"
class
"
:
"
rect
"
"
hidden
"
:
"
true
"
"
stroke
-
dasharray
"
:
"
5
5
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
path
"
parent
:
mainGroup
attributes
:
{
"
id
"
:
"
bounding
-
box
"
"
class
"
:
"
bounding
-
box
"
"
stroke
-
dasharray
"
:
"
5
5
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
path
"
parent
:
mainGroup
attributes
:
{
"
id
"
:
"
rotate
-
line
"
"
class
"
:
"
rotate
-
line
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
path
"
parent
:
mainGroup
attributes
:
{
"
id
"
:
"
markers
-
outline
"
"
class
"
:
"
markers
-
outline
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
path
"
parent
:
mainGroup
attributes
:
{
"
id
"
:
"
markers
"
"
class
"
:
"
markers
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
path
"
parent
:
mainGroup
attributes
:
{
"
id
"
:
"
marker
-
hover
"
"
class
"
:
"
marker
-
hover
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
return
container
;
}
get
currentDimensions
(
)
{
let
dims
=
this
.
currentQuads
[
this
.
referenceBox
]
[
0
]
.
bounds
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
if
(
this
.
currentNode
.
getBBox
&
&
getComputedStyle
(
this
.
currentNode
)
.
stroke
!
=
=
"
none
"
&
&
!
this
.
useStrokeBox
)
{
dims
=
getObjectBoundingBox
(
dims
.
top
dims
.
left
dims
.
width
dims
.
height
this
.
currentNode
)
;
}
return
{
top
:
dims
.
top
/
zoom
left
:
dims
.
left
/
zoom
width
:
dims
.
width
/
zoom
height
:
dims
.
height
/
zoom
}
;
}
get
frameDimensions
(
)
{
let
dims
=
this
.
highlighterEnv
.
window
.
document
=
=
=
this
.
currentNode
.
ownerDocument
?
this
.
currentQuads
[
this
.
referenceBox
]
[
0
]
.
bounds
:
getAdjustedQuads
(
this
.
currentNode
.
ownerGlobal
this
.
currentNode
this
.
referenceBox
)
[
0
]
.
bounds
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
if
(
this
.
currentNode
.
getBBox
&
&
getComputedStyle
(
this
.
currentNode
)
.
stroke
!
=
=
"
none
"
&
&
!
this
.
useStrokeBox
)
{
dims
=
getObjectBoundingBox
(
dims
.
top
dims
.
left
dims
.
width
dims
.
height
this
.
currentNode
)
;
}
return
{
top
:
dims
.
top
/
zoom
left
:
dims
.
left
/
zoom
width
:
dims
.
width
/
zoom
height
:
dims
.
height
/
zoom
}
;
}
setCursor
(
cursorType
)
{
let
container
=
this
.
getElement
(
"
root
"
)
;
let
style
=
container
.
getAttribute
(
"
style
"
)
;
style
=
style
.
replace
(
/
cursor
:
.
*
?
;
/
g
"
"
)
;
style
=
style
.
replace
(
/
pointer
-
events
:
.
*
?
;
/
g
"
"
)
;
let
pointerEvents
=
cursorType
=
=
=
"
auto
"
?
"
none
"
:
"
auto
"
;
container
.
setAttribute
(
"
style
"
{
style
}
pointer
-
events
:
{
pointerEvents
}
;
cursor
:
{
cursorType
}
;
)
;
}
setViewport
(
padding
=
0
)
{
let
xOffset
=
0
;
let
yOffset
=
0
;
if
(
this
.
currentNode
.
ownerGlobal
!
=
=
this
.
win
)
{
const
win
=
this
.
win
;
const
nodeWin
=
this
.
currentNode
.
ownerGlobal
;
const
{
bounds
}
=
nodeWin
.
document
.
getBoxQuads
(
{
relativeTo
:
win
.
document
}
)
[
0
]
;
xOffset
=
bounds
.
left
-
nodeWin
.
scrollX
+
win
.
scrollX
;
yOffset
=
bounds
.
top
-
nodeWin
.
scrollY
+
win
.
scrollY
;
}
const
{
pageXOffset
pageYOffset
innerWidth
innerHeight
}
=
this
.
win
;
const
left
=
pageXOffset
+
padding
-
xOffset
;
const
right
=
innerWidth
+
pageXOffset
-
padding
-
xOffset
;
const
top
=
pageYOffset
+
padding
-
yOffset
;
const
bottom
=
innerHeight
+
pageYOffset
-
padding
-
yOffset
;
this
.
viewport
=
{
left
right
top
bottom
padding
}
;
}
handleEvent
(
event
id
)
{
if
(
this
.
areShapesHidden
(
)
)
{
return
;
}
let
{
target
type
pageX
pageY
}
=
event
;
let
nodeDocument
=
this
.
currentNode
.
ownerDocument
;
if
(
target
!
=
=
nodeDocument
&
&
target
.
ownerDocument
!
=
=
nodeDocument
)
{
let
[
xOffset
yOffset
]
=
getFrameOffsets
(
target
.
ownerGlobal
this
.
currentNode
)
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
viewportLeft
=
pageX
-
event
.
clientX
;
let
viewportTop
=
pageY
-
event
.
clientY
;
let
{
scrollTop
scrollLeft
}
=
nodeDocument
.
documentElement
;
pageX
-
=
viewportLeft
+
xOffset
/
zoom
-
scrollLeft
;
pageY
-
=
viewportTop
+
yOffset
/
zoom
-
scrollTop
;
}
switch
(
type
)
{
case
"
pagehide
"
:
if
(
target
.
defaultView
=
=
=
this
.
win
)
{
this
.
destroy
(
)
;
}
break
;
case
"
mousedown
"
:
if
(
this
.
transformMode
)
{
this
.
_handleTransformClick
(
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_handlePolygonClick
(
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_handleCircleClick
(
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_handleEllipseClick
(
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
_handleInsetClick
(
pageX
pageY
)
;
}
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
this
.
setViewport
(
BASE_MARKER_SIZE
)
;
break
;
case
"
mouseup
"
:
if
(
this
[
_dragging
]
)
{
this
[
_dragging
]
=
null
;
this
.
_handleMarkerHover
(
this
.
hoveredPoint
)
;
}
break
;
case
"
mousemove
"
:
if
(
!
this
[
_dragging
]
)
{
this
.
_handleMouseMoveNotDragging
(
pageX
pageY
)
;
return
;
}
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
const
{
left
right
top
bottom
}
=
this
.
viewport
;
pageX
=
Math
.
min
(
Math
.
max
(
left
pageX
)
right
)
;
pageY
=
Math
.
min
(
Math
.
max
(
top
pageY
)
bottom
)
;
let
{
point
}
=
this
[
_dragging
]
;
if
(
this
.
transformMode
)
{
this
.
_handleTransformMove
(
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_handlePolygonMove
(
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_handleCircleMove
(
point
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_handleEllipseMove
(
point
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
_handleInsetMove
(
point
pageX
pageY
)
;
}
break
;
case
"
dblclick
"
:
if
(
this
.
shapeType
=
=
=
"
polygon
"
&
&
!
this
.
transformMode
)
{
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
index
=
this
.
getPolygonPointAt
(
percentX
percentY
)
;
if
(
index
=
=
=
-
1
)
{
this
.
getPolygonClickedLine
(
percentX
percentY
)
;
return
;
}
this
.
_deletePolygonPoint
(
index
)
;
}
break
;
}
}
_handleTransformClick
(
pageX
pageY
)
{
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
type
=
this
.
getTransformPointAt
(
percentX
percentY
)
;
if
(
!
type
)
{
return
;
}
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_handlePolygonTransformClick
(
pageX
pageY
type
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_handleCircleTransformClick
(
pageX
pageY
type
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_handleEllipseTransformClick
(
pageX
pageY
type
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
_handleInsetTransformClick
(
pageX
pageY
type
)
;
}
}
_handlePolygonTransformClick
(
pageX
pageY
type
)
{
let
{
width
height
}
=
this
.
currentDimensions
;
let
pointsInfo
=
this
.
origCoordUnits
.
map
(
(
[
x
y
]
i
)
=
>
{
let
xComputed
=
this
.
origCoordinates
[
i
]
[
0
]
/
100
*
width
;
let
yComputed
=
this
.
origCoordinates
[
i
]
[
1
]
/
100
*
height
;
let
unitX
=
getUnit
(
x
)
;
let
unitY
=
getUnit
(
y
)
;
let
valueX
=
(
isUnitless
(
x
)
)
?
xComputed
:
parseFloat
(
x
)
;
let
valueY
=
(
isUnitless
(
y
)
)
?
yComputed
:
parseFloat
(
y
)
;
let
ratioX
=
this
.
getUnitToPixelRatio
(
unitX
width
)
;
let
ratioY
=
this
.
getUnitToPixelRatio
(
unitY
height
)
;
return
{
unitX
unitY
valueX
valueY
ratioX
ratioY
}
;
}
)
;
this
[
_dragging
]
=
{
type
pointsInfo
x
:
pageX
y
:
pageY
bb
:
this
.
boundingBox
matrix
:
this
.
transformMatrix
transformedBB
:
this
.
transformedBoundingBox
}
;
}
_handleCircleTransformClick
(
pageX
pageY
type
)
{
let
{
width
height
}
=
this
.
currentDimensions
;
let
{
cx
cy
}
=
this
.
origCoordUnits
;
let
cxComputed
=
this
.
origCoordinates
.
cx
/
100
*
width
;
let
cyComputed
=
this
.
origCoordinates
.
cy
/
100
*
height
;
let
unitX
=
getUnit
(
cx
)
;
let
unitY
=
getUnit
(
cy
)
;
let
valueX
=
(
isUnitless
(
cx
)
)
?
cxComputed
:
parseFloat
(
cx
)
;
let
valueY
=
(
isUnitless
(
cy
)
)
?
cyComputed
:
parseFloat
(
cy
)
;
let
ratioX
=
this
.
getUnitToPixelRatio
(
unitX
width
)
;
let
ratioY
=
this
.
getUnitToPixelRatio
(
unitY
height
)
;
let
{
radius
}
=
this
.
origCoordinates
;
let
computedSize
=
Math
.
sqrt
(
(
width
*
*
2
)
+
(
height
*
*
2
)
)
/
Math
.
sqrt
(
2
)
;
radius
=
radius
/
100
*
computedSize
;
let
valueRad
=
this
.
origCoordUnits
.
radius
;
let
unitRad
=
getUnit
(
valueRad
)
;
valueRad
=
(
isUnitless
(
valueRad
)
)
?
radius
:
parseFloat
(
valueRad
)
;
let
ratioRad
=
this
.
getUnitToPixelRatio
(
unitRad
computedSize
)
;
this
[
_dragging
]
=
{
type
unitX
unitY
unitRad
valueX
valueY
ratioX
ratioY
ratioRad
x
:
pageX
y
:
pageY
bb
:
this
.
boundingBox
matrix
:
this
.
transformMatrix
transformedBB
:
this
.
transformedBoundingBox
}
;
}
_handleEllipseTransformClick
(
pageX
pageY
type
)
{
let
{
width
height
}
=
this
.
currentDimensions
;
let
{
cx
cy
}
=
this
.
origCoordUnits
;
let
cxComputed
=
this
.
origCoordinates
.
cx
/
100
*
width
;
let
cyComputed
=
this
.
origCoordinates
.
cy
/
100
*
height
;
let
unitX
=
getUnit
(
cx
)
;
let
unitY
=
getUnit
(
cy
)
;
let
valueX
=
(
isUnitless
(
cx
)
)
?
cxComputed
:
parseFloat
(
cx
)
;
let
valueY
=
(
isUnitless
(
cy
)
)
?
cyComputed
:
parseFloat
(
cy
)
;
let
ratioX
=
this
.
getUnitToPixelRatio
(
unitX
width
)
;
let
ratioY
=
this
.
getUnitToPixelRatio
(
unitY
height
)
;
let
{
rx
ry
}
=
this
.
origCoordinates
;
rx
=
rx
/
100
*
width
;
let
valueRX
=
this
.
origCoordUnits
.
rx
;
let
unitRX
=
getUnit
(
valueRX
)
;
valueRX
=
(
isUnitless
(
valueRX
)
)
?
rx
:
parseFloat
(
valueRX
)
;
let
ratioRX
=
(
valueRX
/
rx
)
|
|
1
;
ry
=
ry
/
100
*
height
;
let
valueRY
=
this
.
origCoordUnits
.
ry
;
let
unitRY
=
getUnit
(
valueRY
)
;
valueRY
=
(
isUnitless
(
valueRY
)
)
?
ry
:
parseFloat
(
valueRY
)
;
let
ratioRY
=
(
valueRY
/
ry
)
|
|
1
;
this
[
_dragging
]
=
{
type
unitX
unitY
unitRX
unitRY
valueX
valueY
ratioX
ratioY
ratioRX
ratioRY
x
:
pageX
y
:
pageY
bb
:
this
.
boundingBox
matrix
:
this
.
transformMatrix
transformedBB
:
this
.
transformedBoundingBox
}
;
}
_handleInsetTransformClick
(
pageX
pageY
type
)
{
let
{
width
height
}
=
this
.
currentDimensions
;
let
pointsInfo
=
{
}
;
[
"
top
"
"
right
"
"
bottom
"
"
left
"
]
.
forEach
(
point
=
>
{
let
value
=
this
.
origCoordUnits
[
point
]
;
let
size
=
(
point
=
=
=
"
left
"
|
|
point
=
=
=
"
right
"
)
?
width
:
height
;
let
computedValue
=
this
.
origCoordinates
[
point
]
/
100
*
size
;
let
unit
=
getUnit
(
value
)
;
value
=
(
isUnitless
(
value
)
)
?
computedValue
:
parseFloat
(
value
)
;
let
ratio
=
this
.
getUnitToPixelRatio
(
unit
size
)
;
pointsInfo
[
point
]
=
{
value
unit
ratio
}
;
}
)
;
this
[
_dragging
]
=
{
type
pointsInfo
x
:
pageX
y
:
pageY
bb
:
this
.
boundingBox
matrix
:
this
.
transformMatrix
transformedBB
:
this
.
transformedBoundingBox
}
;
}
_handleTransformMove
(
pageX
pageY
)
{
let
{
type
}
=
this
[
_dragging
]
;
if
(
type
=
=
=
"
translate
"
)
{
this
.
_translateShape
(
pageX
pageY
)
;
}
else
if
(
type
.
includes
(
"
scale
"
)
)
{
this
.
_scaleShape
(
pageX
pageY
)
;
}
else
if
(
type
=
=
=
"
rotate
"
&
&
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_rotateShape
(
pageX
pageY
)
;
}
this
.
transformedBoundingBox
=
this
.
calculateTransformedBoundingBox
(
)
;
}
_translateShape
(
pageX
pageY
)
{
let
{
x
y
matrix
}
=
this
[
_dragging
]
;
let
deltaX
=
pageX
-
x
;
let
deltaY
=
pageY
-
y
;
this
.
transformMatrix
=
multiply
(
translate
(
deltaX
deltaY
)
matrix
)
;
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_transformPolygon
(
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_transformCircle
(
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_transformEllipse
(
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
_transformInset
(
)
;
}
}
_scaleShape
(
pageX
pageY
)
{
let
{
type
x
y
matrix
}
=
this
[
_dragging
]
;
let
{
width
height
}
=
this
.
currentDimensions
;
let
anchor
=
getAnchorPoint
(
type
)
;
let
{
ne
nw
sw
}
=
this
[
_dragging
]
.
transformedBB
;
let
u
=
[
(
ne
[
0
]
-
nw
[
0
]
)
/
100
*
width
(
ne
[
1
]
-
nw
[
1
]
)
/
100
*
height
]
;
let
v
=
[
(
sw
[
0
]
-
nw
[
0
]
)
/
100
*
width
(
sw
[
1
]
-
nw
[
1
]
)
/
100
*
height
]
;
let
{
basis
invertedBasis
uLength
vLength
}
=
getBasis
(
u
v
)
;
let
transX
=
this
[
_dragging
]
.
transformedBB
[
anchor
]
[
0
]
/
100
*
width
;
let
transY
=
this
[
_dragging
]
.
transformedBB
[
anchor
]
[
1
]
/
100
*
height
;
let
distanceX
=
pageX
-
x
;
let
distanceY
=
pageY
-
y
;
let
tDistanceX
=
invertedBasis
[
0
]
*
distanceX
+
invertedBasis
[
1
]
*
distanceY
;
let
tDistanceY
=
invertedBasis
[
3
]
*
distanceX
+
invertedBasis
[
4
]
*
distanceY
;
let
proportionX
=
tDistanceX
/
uLength
;
let
proportionY
=
tDistanceY
/
vLength
;
let
scaleX
=
(
type
.
includes
(
"
w
"
)
)
?
1
-
proportionX
:
1
+
proportionX
;
let
scaleY
=
(
type
.
includes
(
"
n
"
)
)
?
1
-
proportionY
:
1
+
proportionY
;
let
scaleXY
=
(
scaleX
+
scaleY
)
/
2
;
let
translateMatrix
=
translate
(
-
transX
-
transY
)
;
let
scaleMatrix
=
identity
(
)
;
if
(
type
=
=
=
"
scale
-
e
"
|
|
type
=
=
=
"
scale
-
w
"
)
{
scaleMatrix
=
changeMatrixBase
(
scale
(
scaleX
1
)
invertedBasis
basis
)
;
}
else
if
(
type
=
=
=
"
scale
-
n
"
|
|
type
=
=
=
"
scale
-
s
"
)
{
scaleMatrix
=
changeMatrixBase
(
scale
(
1
scaleY
)
invertedBasis
basis
)
;
}
else
{
scaleMatrix
=
changeMatrixBase
(
scale
(
scaleXY
scaleXY
)
invertedBasis
basis
)
;
}
let
translateBackMatrix
=
translate
(
transX
transY
)
;
this
.
transformMatrix
=
multiply
(
translateBackMatrix
multiply
(
scaleMatrix
multiply
(
translateMatrix
matrix
)
)
)
;
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_transformPolygon
(
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_transformCircle
(
transX
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_transformEllipse
(
transX
transY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
_transformInset
(
)
;
}
}
_rotateShape
(
pageX
pageY
)
{
let
{
matrix
}
=
this
[
_dragging
]
;
let
{
center
ne
nw
sw
}
=
this
[
_dragging
]
.
transformedBB
;
let
{
width
height
}
=
this
.
currentDimensions
;
let
centerX
=
center
[
0
]
/
100
*
width
;
let
centerY
=
center
[
1
]
/
100
*
height
;
let
{
x
:
pageCenterX
y
:
pageCenterY
}
=
this
.
convertPercentToPageCoords
(
.
.
.
center
)
;
let
dx
=
pageCenterX
-
pageX
;
let
dy
=
pageCenterY
-
pageY
;
let
u
=
[
(
ne
[
0
]
-
nw
[
0
]
)
/
100
*
width
(
ne
[
1
]
-
nw
[
1
]
)
/
100
*
height
]
;
let
v
=
[
(
sw
[
0
]
-
nw
[
0
]
)
/
100
*
width
(
sw
[
1
]
-
nw
[
1
]
)
/
100
*
height
]
;
let
{
invertedBasis
}
=
getBasis
(
u
v
)
;
let
tdx
=
invertedBasis
[
0
]
*
dx
+
invertedBasis
[
1
]
*
dy
;
let
tdy
=
invertedBasis
[
3
]
*
dx
+
invertedBasis
[
4
]
*
dy
;
let
angle
=
Math
.
atan2
(
tdx
tdy
)
;
let
translateMatrix
=
translate
(
-
centerX
-
centerY
)
;
let
rotateMatrix
=
rotate
(
angle
)
;
let
translateBackMatrix
=
translate
(
centerX
centerY
)
;
this
.
transformMatrix
=
multiply
(
translateBackMatrix
multiply
(
rotateMatrix
multiply
(
translateMatrix
matrix
)
)
)
;
this
.
_transformPolygon
(
)
;
}
_transformPolygon
(
)
{
let
{
pointsInfo
}
=
this
[
_dragging
]
;
let
polygonDef
=
(
this
.
fillRule
)
?
{
this
.
fillRule
}
:
"
"
;
polygonDef
+
=
pointsInfo
.
map
(
point
=
>
{
let
{
unitX
unitY
valueX
valueY
ratioX
ratioY
}
=
point
;
let
vector
=
[
valueX
/
ratioX
valueY
/
ratioY
]
;
let
[
newX
newY
]
=
apply
(
this
.
transformMatrix
vector
)
;
newX
=
round
(
newX
*
ratioX
unitX
)
;
newY
=
round
(
newY
*
ratioY
unitY
)
;
return
{
newX
}
{
unitX
}
{
newY
}
{
unitY
}
;
}
)
.
join
(
"
"
)
;
polygonDef
=
polygon
(
{
polygonDef
}
)
{
this
.
geometryBox
}
.
trim
(
)
;
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
change
"
value
:
polygonDef
}
)
;
}
_transformCircle
(
transX
=
null
)
{
let
{
unitX
unitY
unitRad
valueX
valueY
ratioX
ratioY
ratioRad
}
=
this
[
_dragging
]
;
let
{
radius
}
=
this
.
coordUnits
;
let
[
newCx
newCy
]
=
apply
(
this
.
transformMatrix
[
valueX
/
ratioX
valueY
/
ratioY
]
)
;
if
(
transX
!
=
=
null
)
{
radius
=
round
(
Math
.
abs
(
(
newCx
-
transX
)
*
ratioRad
)
unitRad
)
;
radius
=
{
radius
}
{
unitRad
}
;
}
newCx
=
round
(
newCx
*
ratioX
unitX
)
;
newCy
=
round
(
newCy
*
ratioY
unitY
)
;
let
circleDef
=
circle
(
{
radius
}
at
{
newCx
}
{
unitX
}
{
newCy
}
{
unitY
}
)
+
{
this
.
geometryBox
}
.
trim
(
)
;
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
change
"
value
:
circleDef
}
)
;
}
_transformEllipse
(
transX
=
null
transY
=
null
)
{
let
{
unitX
unitY
unitRX
unitRY
valueX
valueY
ratioX
ratioY
ratioRX
ratioRY
}
=
this
[
_dragging
]
;
let
{
rx
ry
}
=
this
.
coordUnits
;
let
[
newCx
newCy
]
=
apply
(
this
.
transformMatrix
[
valueX
/
ratioX
valueY
/
ratioY
]
)
;
if
(
transX
!
=
=
null
&
&
transY
!
=
=
null
)
{
rx
=
round
(
Math
.
abs
(
(
newCx
-
transX
)
*
ratioRX
)
unitRX
)
;
rx
=
{
rx
}
{
unitRX
}
;
ry
=
round
(
Math
.
abs
(
(
newCy
-
transY
)
*
ratioRY
)
unitRY
)
;
ry
=
{
ry
}
{
unitRY
}
;
}
newCx
=
round
(
newCx
*
ratioX
unitX
)
;
newCy
=
round
(
newCy
*
ratioY
unitY
)
;
let
centerStr
=
{
newCx
}
{
unitX
}
{
newCy
}
{
unitY
}
;
let
ellipseDef
=
ellipse
(
{
rx
}
{
ry
}
at
{
centerStr
}
)
{
this
.
geometryBox
}
.
trim
(
)
;
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
change
"
value
:
ellipseDef
}
)
;
}
_transformInset
(
)
{
let
{
top
left
right
bottom
}
=
this
[
_dragging
]
.
pointsInfo
;
let
{
width
height
}
=
this
.
currentDimensions
;
let
topLeft
=
[
left
.
value
/
left
.
ratio
top
.
value
/
top
.
ratio
]
;
let
[
newLeft
newTop
]
=
apply
(
this
.
transformMatrix
topLeft
)
;
newLeft
=
round
(
newLeft
*
left
.
ratio
left
.
unit
)
;
newLeft
=
{
newLeft
}
{
left
.
unit
}
;
newTop
=
round
(
newTop
*
top
.
ratio
top
.
unit
)
;
newTop
=
{
newTop
}
{
top
.
unit
}
;
let
bottomRight
=
[
width
-
right
.
value
/
right
.
ratio
height
-
bottom
.
value
/
bottom
.
ratio
]
;
let
[
newRight
newBottom
]
=
apply
(
this
.
transformMatrix
bottomRight
)
;
newRight
=
round
(
(
width
-
newRight
)
*
right
.
ratio
right
.
unit
)
;
newRight
=
{
newRight
}
{
right
.
unit
}
;
newBottom
=
round
(
(
height
-
newBottom
)
*
bottom
.
ratio
bottom
.
unit
)
;
newBottom
=
{
newBottom
}
{
bottom
.
unit
}
;
let
insetDef
=
(
this
.
insetRound
)
?
inset
(
{
newTop
}
{
newRight
}
{
newBottom
}
{
newLeft
}
round
{
this
.
insetRound
}
)
:
inset
(
{
newTop
}
{
newRight
}
{
newBottom
}
{
newLeft
}
)
;
insetDef
+
=
(
this
.
geometryBox
)
?
this
.
geometryBox
:
"
"
;
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
change
"
value
:
insetDef
}
)
;
}
_handlePolygonClick
(
pageX
pageY
)
{
let
{
width
height
}
=
this
.
currentDimensions
;
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
point
=
this
.
getPolygonPointAt
(
percentX
percentY
)
;
if
(
point
=
=
=
-
1
)
{
return
;
}
let
[
x
y
]
=
this
.
coordUnits
[
point
]
;
let
xComputed
=
this
.
coordinates
[
point
]
[
0
]
/
100
*
width
;
let
yComputed
=
this
.
coordinates
[
point
]
[
1
]
/
100
*
height
;
let
unitX
=
getUnit
(
x
)
;
let
unitY
=
getUnit
(
y
)
;
let
valueX
=
(
isUnitless
(
x
)
)
?
xComputed
:
parseFloat
(
x
)
;
let
valueY
=
(
isUnitless
(
y
)
)
?
yComputed
:
parseFloat
(
y
)
;
let
ratioX
=
this
.
getUnitToPixelRatio
(
unitX
width
)
;
let
ratioY
=
this
.
getUnitToPixelRatio
(
unitY
height
)
;
this
.
setCursor
(
"
grabbing
"
)
;
this
[
_dragging
]
=
{
point
unitX
unitY
valueX
valueY
ratioX
ratioY
x
:
pageX
y
:
pageY
}
;
}
_handlePolygonMove
(
pageX
pageY
)
{
let
{
point
unitX
unitY
valueX
valueY
ratioX
ratioY
x
y
}
=
this
[
_dragging
]
;
let
deltaX
=
(
pageX
-
x
)
*
ratioX
;
let
deltaY
=
(
pageY
-
y
)
*
ratioY
;
let
newX
=
round
(
valueX
+
deltaX
unitX
)
;
let
newY
=
round
(
valueY
+
deltaY
unitY
)
;
let
polygonDef
=
(
this
.
fillRule
)
?
{
this
.
fillRule
}
:
"
"
;
polygonDef
+
=
this
.
coordUnits
.
map
(
(
coords
i
)
=
>
{
return
(
i
=
=
=
point
)
?
{
newX
}
{
unitX
}
{
newY
}
{
unitY
}
:
{
coords
[
0
]
}
{
coords
[
1
]
}
;
}
)
.
join
(
"
"
)
;
polygonDef
=
polygon
(
{
polygonDef
}
)
{
this
.
geometryBox
}
.
trim
(
)
;
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
change
"
value
:
polygonDef
}
)
;
}
_addPolygonPoint
(
after
x
y
)
{
let
polygonDef
=
(
this
.
fillRule
)
?
{
this
.
fillRule
}
:
"
"
;
polygonDef
+
=
this
.
coordUnits
.
map
(
(
coords
i
)
=
>
{
return
(
i
=
=
=
after
)
?
{
coords
[
0
]
}
{
coords
[
1
]
}
{
x
}
%
{
y
}
%
:
{
coords
[
0
]
}
{
coords
[
1
]
}
;
}
)
.
join
(
"
"
)
;
polygonDef
=
polygon
(
{
polygonDef
}
)
{
this
.
geometryBox
}
.
trim
(
)
;
this
.
hoveredPoint
=
after
+
1
;
this
.
_emitHoverEvent
(
this
.
hoveredPoint
)
;
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
change
"
value
:
polygonDef
}
)
;
}
_deletePolygonPoint
(
point
)
{
let
coordinates
=
this
.
coordUnits
.
slice
(
)
;
coordinates
.
splice
(
point
1
)
;
let
polygonDef
=
(
this
.
fillRule
)
?
{
this
.
fillRule
}
:
"
"
;
polygonDef
+
=
coordinates
.
map
(
(
coords
i
)
=
>
{
return
{
coords
[
0
]
}
{
coords
[
1
]
}
;
}
)
.
join
(
"
"
)
;
polygonDef
=
polygon
(
{
polygonDef
}
)
{
this
.
geometryBox
}
.
trim
(
)
;
this
.
hoveredPoint
=
null
;
this
.
_emitHoverEvent
(
this
.
hoveredPoint
)
;
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
change
"
value
:
polygonDef
}
)
;
}
_handleCircleClick
(
pageX
pageY
)
{
let
{
width
height
}
=
this
.
currentDimensions
;
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
point
=
this
.
getCirclePointAt
(
percentX
percentY
)
;
if
(
!
point
)
{
return
;
}
this
.
setCursor
(
"
grabbing
"
)
;
if
(
point
=
=
=
"
center
"
)
{
let
{
cx
cy
}
=
this
.
coordUnits
;
let
cxComputed
=
this
.
coordinates
.
cx
/
100
*
width
;
let
cyComputed
=
this
.
coordinates
.
cy
/
100
*
height
;
let
unitX
=
getUnit
(
cx
)
;
let
unitY
=
getUnit
(
cy
)
;
let
valueX
=
(
isUnitless
(
cx
)
)
?
cxComputed
:
parseFloat
(
cx
)
;
let
valueY
=
(
isUnitless
(
cy
)
)
?
cyComputed
:
parseFloat
(
cy
)
;
let
ratioX
=
this
.
getUnitToPixelRatio
(
unitX
width
)
;
let
ratioY
=
this
.
getUnitToPixelRatio
(
unitY
height
)
;
this
[
_dragging
]
=
{
point
unitX
unitY
valueX
valueY
ratioX
ratioY
x
:
pageX
y
:
pageY
}
;
}
else
if
(
point
=
=
=
"
radius
"
)
{
let
{
radius
}
=
this
.
coordinates
;
let
computedSize
=
Math
.
sqrt
(
(
width
*
*
2
)
+
(
height
*
*
2
)
)
/
Math
.
sqrt
(
2
)
;
radius
=
radius
/
100
*
computedSize
;
let
value
=
this
.
coordUnits
.
radius
;
let
unit
=
getUnit
(
value
)
;
value
=
(
isUnitless
(
value
)
)
?
radius
:
parseFloat
(
value
)
;
let
ratio
=
this
.
getUnitToPixelRatio
(
unit
computedSize
)
;
this
[
_dragging
]
=
{
point
value
origRadius
:
radius
unit
ratio
}
;
}
}
_handleCircleMove
(
point
pageX
pageY
)
{
let
{
radius
cx
cy
}
=
this
.
coordUnits
;
if
(
point
=
=
=
"
center
"
)
{
let
{
unitX
unitY
valueX
valueY
ratioX
ratioY
x
y
}
=
this
[
_dragging
]
;
let
deltaX
=
(
pageX
-
x
)
*
ratioX
;
let
deltaY
=
(
pageY
-
y
)
*
ratioY
;
let
newCx
=
{
round
(
valueX
+
deltaX
unitX
)
}
{
unitX
}
;
let
newCy
=
{
round
(
valueY
+
deltaY
unitY
)
}
{
unitY
}
;
let
circleDef
=
circle
(
{
radius
}
at
{
newCx
}
{
newCy
}
)
{
this
.
geometryBox
}
.
trim
(
)
;
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
change
"
value
:
circleDef
}
)
;
}
else
if
(
point
=
=
=
"
radius
"
)
{
let
{
value
unit
origRadius
ratio
}
=
this
[
_dragging
]
;
let
{
x
:
pageCx
y
:
pageCy
}
=
this
.
convertPercentToPageCoords
(
this
.
coordinates
.
cx
this
.
coordinates
.
cy
)
;
let
newRadiusPx
=
getDistance
(
pageCx
pageCy
pageX
pageY
)
;
let
delta
=
(
newRadiusPx
-
origRadius
)
*
ratio
;
let
newRadius
=
{
round
(
value
+
delta
unit
)
}
{
unit
}
;
let
circleDef
=
circle
(
{
newRadius
}
at
{
cx
}
{
cy
}
)
{
this
.
geometryBox
}
.
trim
(
)
;
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
change
"
value
:
circleDef
}
)
;
}
}
_handleEllipseClick
(
pageX
pageY
)
{
let
{
width
height
}
=
this
.
currentDimensions
;
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
point
=
this
.
getEllipsePointAt
(
percentX
percentY
)
;
if
(
!
point
)
{
return
;
}
this
.
setCursor
(
"
grabbing
"
)
;
if
(
point
=
=
=
"
center
"
)
{
let
{
cx
cy
}
=
this
.
coordUnits
;
let
cxComputed
=
this
.
coordinates
.
cx
/
100
*
width
;
let
cyComputed
=
this
.
coordinates
.
cy
/
100
*
height
;
let
unitX
=
getUnit
(
cx
)
;
let
unitY
=
getUnit
(
cy
)
;
let
valueX
=
(
isUnitless
(
cx
)
)
?
cxComputed
:
parseFloat
(
cx
)
;
let
valueY
=
(
isUnitless
(
cy
)
)
?
cyComputed
:
parseFloat
(
cy
)
;
let
ratioX
=
this
.
getUnitToPixelRatio
(
unitX
width
)
;
let
ratioY
=
this
.
getUnitToPixelRatio
(
unitY
height
)
;
this
[
_dragging
]
=
{
point
unitX
unitY
valueX
valueY
ratioX
ratioY
x
:
pageX
y
:
pageY
}
;
}
else
if
(
point
=
=
=
"
rx
"
)
{
let
{
rx
}
=
this
.
coordinates
;
rx
=
rx
/
100
*
width
;
let
value
=
this
.
coordUnits
.
rx
;
let
unit
=
getUnit
(
value
)
;
value
=
(
isUnitless
(
value
)
)
?
rx
:
parseFloat
(
value
)
;
let
ratio
=
this
.
getUnitToPixelRatio
(
unit
width
)
;
this
[
_dragging
]
=
{
point
value
origRadius
:
rx
unit
ratio
}
;
}
else
if
(
point
=
=
=
"
ry
"
)
{
let
{
ry
}
=
this
.
coordinates
;
ry
=
ry
/
100
*
height
;
let
value
=
this
.
coordUnits
.
ry
;
let
unit
=
getUnit
(
value
)
;
value
=
(
isUnitless
(
value
)
)
?
ry
:
parseFloat
(
value
)
;
let
ratio
=
this
.
getUnitToPixelRatio
(
unit
height
)
;
this
[
_dragging
]
=
{
point
value
origRadius
:
ry
unit
ratio
}
;
}
}
_handleEllipseMove
(
point
pageX
pageY
)
{
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
{
rx
ry
cx
cy
}
=
this
.
coordUnits
;
if
(
point
=
=
=
"
center
"
)
{
let
{
unitX
unitY
valueX
valueY
ratioX
ratioY
x
y
}
=
this
[
_dragging
]
;
let
deltaX
=
(
pageX
-
x
)
*
ratioX
;
let
deltaY
=
(
pageY
-
y
)
*
ratioY
;
let
newCx
=
{
round
(
valueX
+
deltaX
unitX
)
}
{
unitX
}
;
let
newCy
=
{
round
(
valueY
+
deltaY
unitY
)
}
{
unitY
}
;
let
ellipseDef
=
ellipse
(
{
rx
}
{
ry
}
at
{
newCx
}
{
newCy
}
)
{
this
.
geometryBox
}
.
trim
(
)
;
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
change
"
value
:
ellipseDef
}
)
;
}
else
if
(
point
=
=
=
"
rx
"
)
{
let
{
value
unit
origRadius
ratio
}
=
this
[
_dragging
]
;
let
newRadiusPercent
=
Math
.
abs
(
percentX
-
this
.
coordinates
.
cx
)
;
let
{
width
}
=
this
.
currentDimensions
;
let
delta
=
(
(
newRadiusPercent
/
100
*
width
)
-
origRadius
)
*
ratio
;
let
newRadius
=
{
round
(
value
+
delta
unit
)
}
{
unit
}
;
let
ellipseDef
=
ellipse
(
{
newRadius
}
{
ry
}
at
{
cx
}
{
cy
}
)
{
this
.
geometryBox
}
.
trim
(
)
;
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
change
"
value
:
ellipseDef
}
)
;
}
else
if
(
point
=
=
=
"
ry
"
)
{
let
{
value
unit
origRadius
ratio
}
=
this
[
_dragging
]
;
let
newRadiusPercent
=
Math
.
abs
(
percentY
-
this
.
coordinates
.
cy
)
;
let
{
height
}
=
this
.
currentDimensions
;
let
delta
=
(
(
newRadiusPercent
/
100
*
height
)
-
origRadius
)
*
ratio
;
let
newRadius
=
{
round
(
value
+
delta
unit
)
}
{
unit
}
;
let
ellipseDef
=
ellipse
(
{
rx
}
{
newRadius
}
at
{
cx
}
{
cy
}
)
{
this
.
geometryBox
}
.
trim
(
)
;
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
change
"
value
:
ellipseDef
}
)
;
}
}
_handleInsetClick
(
pageX
pageY
)
{
let
{
width
height
}
=
this
.
currentDimensions
;
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
point
=
this
.
getInsetPointAt
(
percentX
percentY
)
;
if
(
!
point
)
{
return
;
}
this
.
setCursor
(
"
grabbing
"
)
;
let
value
=
this
.
coordUnits
[
point
]
;
let
size
=
(
point
=
=
=
"
left
"
|
|
point
=
=
=
"
right
"
)
?
width
:
height
;
let
computedValue
=
this
.
coordinates
[
point
]
/
100
*
size
;
let
unit
=
getUnit
(
value
)
;
value
=
(
isUnitless
(
value
)
)
?
computedValue
:
parseFloat
(
value
)
;
let
ratio
=
this
.
getUnitToPixelRatio
(
unit
size
)
;
let
origValue
=
(
point
=
=
=
"
left
"
|
|
point
=
=
=
"
right
"
)
?
pageX
:
pageY
;
this
[
_dragging
]
=
{
point
value
origValue
unit
ratio
}
;
}
_handleInsetMove
(
point
pageX
pageY
)
{
let
{
top
left
right
bottom
}
=
this
.
coordUnits
;
let
{
value
origValue
unit
ratio
}
=
this
[
_dragging
]
;
if
(
point
=
=
=
"
left
"
)
{
let
delta
=
(
pageX
-
origValue
)
*
ratio
;
left
=
{
round
(
value
+
delta
unit
)
}
{
unit
}
;
}
else
if
(
point
=
=
=
"
right
"
)
{
let
delta
=
(
pageX
-
origValue
)
*
ratio
;
right
=
{
round
(
value
-
delta
unit
)
}
{
unit
}
;
}
else
if
(
point
=
=
=
"
top
"
)
{
let
delta
=
(
pageY
-
origValue
)
*
ratio
;
top
=
{
round
(
value
+
delta
unit
)
}
{
unit
}
;
}
else
if
(
point
=
=
=
"
bottom
"
)
{
let
delta
=
(
pageY
-
origValue
)
*
ratio
;
bottom
=
{
round
(
value
-
delta
unit
)
}
{
unit
}
;
}
let
insetDef
=
(
this
.
insetRound
)
?
inset
(
{
top
}
{
right
}
{
bottom
}
{
left
}
round
{
this
.
insetRound
}
)
:
inset
(
{
top
}
{
right
}
{
bottom
}
{
left
}
)
;
insetDef
+
=
(
this
.
geometryBox
)
?
this
.
geometryBox
:
"
"
;
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
change
"
value
:
insetDef
}
)
;
}
_handleMouseMoveNotDragging
(
pageX
pageY
)
{
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
if
(
this
.
transformMode
)
{
let
point
=
this
.
getTransformPointAt
(
percentX
percentY
)
;
this
.
hoveredPoint
=
point
;
this
.
_handleMarkerHover
(
point
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
let
point
=
this
.
getPolygonPointAt
(
percentX
percentY
)
;
let
oldHoveredPoint
=
this
.
hoveredPoint
;
this
.
hoveredPoint
=
(
point
!
=
=
-
1
)
?
point
:
null
;
if
(
this
.
hoveredPoint
!
=
=
oldHoveredPoint
)
{
this
.
_emitHoverEvent
(
this
.
hoveredPoint
)
;
}
this
.
_handleMarkerHover
(
point
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
let
point
=
this
.
getCirclePointAt
(
percentX
percentY
)
;
let
oldHoveredPoint
=
this
.
hoveredPoint
;
this
.
hoveredPoint
=
point
?
point
:
null
;
if
(
this
.
hoveredPoint
!
=
=
oldHoveredPoint
)
{
this
.
_emitHoverEvent
(
this
.
hoveredPoint
)
;
}
this
.
_handleMarkerHover
(
point
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
let
point
=
this
.
getEllipsePointAt
(
percentX
percentY
)
;
let
oldHoveredPoint
=
this
.
hoveredPoint
;
this
.
hoveredPoint
=
point
?
point
:
null
;
if
(
this
.
hoveredPoint
!
=
=
oldHoveredPoint
)
{
this
.
_emitHoverEvent
(
this
.
hoveredPoint
)
;
}
this
.
_handleMarkerHover
(
point
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
let
point
=
this
.
getInsetPointAt
(
percentX
percentY
)
;
let
oldHoveredPoint
=
this
.
hoveredPoint
;
this
.
hoveredPoint
=
point
?
point
:
null
;
if
(
this
.
hoveredPoint
!
=
=
oldHoveredPoint
)
{
this
.
_emitHoverEvent
(
this
.
hoveredPoint
)
;
}
this
.
_handleMarkerHover
(
point
)
;
}
}
_handleMarkerHover
(
point
)
{
this
.
getElement
(
"
marker
-
hover
"
)
.
setAttribute
(
"
hidden
"
true
)
;
if
(
!
point
&
&
point
!
=
=
0
)
{
this
.
setCursor
(
"
auto
"
)
;
return
;
}
let
hoverCursor
=
(
this
[
_dragging
]
)
?
"
grabbing
"
:
"
grab
"
;
if
(
this
.
transformMode
)
{
if
(
!
point
)
{
this
.
setCursor
(
"
auto
"
)
;
return
;
}
let
{
nw
ne
sw
se
n
w
s
e
rotatePoint
center
}
=
this
.
transformedBoundingBox
;
const
points
=
[
{
pointName
:
"
translate
"
x
:
center
[
0
]
y
:
center
[
1
]
cursor
:
"
move
"
}
{
pointName
:
"
scale
-
se
"
x
:
se
[
0
]
y
:
se
[
1
]
anchor
:
"
nw
"
}
{
pointName
:
"
scale
-
ne
"
x
:
ne
[
0
]
y
:
ne
[
1
]
anchor
:
"
sw
"
}
{
pointName
:
"
scale
-
sw
"
x
:
sw
[
0
]
y
:
sw
[
1
]
anchor
:
"
ne
"
}
{
pointName
:
"
scale
-
nw
"
x
:
nw
[
0
]
y
:
nw
[
1
]
anchor
:
"
se
"
}
{
pointName
:
"
scale
-
n
"
x
:
n
[
0
]
y
:
n
[
1
]
anchor
:
"
s
"
}
{
pointName
:
"
scale
-
s
"
x
:
s
[
0
]
y
:
s
[
1
]
anchor
:
"
n
"
}
{
pointName
:
"
scale
-
e
"
x
:
e
[
0
]
y
:
e
[
1
]
anchor
:
"
w
"
}
{
pointName
:
"
scale
-
w
"
x
:
w
[
0
]
y
:
w
[
1
]
anchor
:
"
e
"
}
{
pointName
:
"
rotate
"
x
:
rotatePoint
[
0
]
y
:
rotatePoint
[
1
]
cursor
:
"
grab
"
}
]
;
for
(
let
{
pointName
x
y
cursor
anchor
}
of
points
)
{
if
(
point
=
=
=
pointName
)
{
this
.
_drawHoverMarker
(
[
[
x
y
]
]
)
;
if
(
pointName
.
includes
(
"
scale
"
)
)
{
let
direction
=
this
.
getRoughDirection
(
pointName
anchor
)
;
this
.
setCursor
(
{
direction
}
-
resize
)
;
}
else
{
this
.
setCursor
(
cursor
)
;
}
}
}
}
else
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
if
(
point
=
=
=
-
1
)
{
this
.
setCursor
(
"
auto
"
)
;
return
;
}
this
.
setCursor
(
hoverCursor
)
;
this
.
_drawHoverMarker
(
[
this
.
coordinates
[
point
]
]
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
setCursor
(
hoverCursor
)
;
let
{
cx
cy
rx
}
=
this
.
coordinates
;
if
(
point
=
=
=
"
radius
"
)
{
this
.
_drawHoverMarker
(
[
[
cx
+
rx
cy
]
]
)
;
}
else
if
(
point
=
=
=
"
center
"
)
{
this
.
_drawHoverMarker
(
[
[
cx
cy
]
]
)
;
}
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
setCursor
(
hoverCursor
)
;
if
(
point
=
=
=
"
center
"
)
{
let
{
cx
cy
}
=
this
.
coordinates
;
this
.
_drawHoverMarker
(
[
[
cx
cy
]
]
)
;
}
else
if
(
point
=
=
=
"
rx
"
)
{
let
{
cx
cy
rx
}
=
this
.
coordinates
;
this
.
_drawHoverMarker
(
[
[
cx
+
rx
cy
]
]
)
;
}
else
if
(
point
=
=
=
"
ry
"
)
{
let
{
cx
cy
ry
}
=
this
.
coordinates
;
this
.
_drawHoverMarker
(
[
[
cx
cy
+
ry
]
]
)
;
}
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
setCursor
(
hoverCursor
)
;
let
{
top
right
bottom
left
}
=
this
.
coordinates
;
let
centerX
=
(
left
+
(
100
-
right
)
)
/
2
;
let
centerY
=
(
top
+
(
100
-
bottom
)
)
/
2
;
let
points
=
point
.
split
(
"
"
)
;
let
coords
=
points
.
map
(
side
=
>
{
if
(
side
=
=
=
"
top
"
)
{
return
[
centerX
top
]
;
}
else
if
(
side
=
=
=
"
right
"
)
{
return
[
100
-
right
centerY
]
;
}
else
if
(
side
=
=
=
"
bottom
"
)
{
return
[
centerX
100
-
bottom
]
;
}
else
if
(
side
=
=
=
"
left
"
)
{
return
[
left
centerY
]
;
}
return
null
;
}
)
;
this
.
_drawHoverMarker
(
coords
)
;
}
}
_drawHoverMarker
(
points
)
{
let
{
width
height
}
=
this
.
currentDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
path
=
points
.
map
(
(
[
x
y
]
)
=
>
{
return
getCirclePath
(
BASE_MARKER_SIZE
x
y
width
height
zoom
)
;
}
)
.
join
(
"
"
)
;
let
markerHover
=
this
.
getElement
(
"
marker
-
hover
"
)
;
markerHover
.
setAttribute
(
"
d
"
path
)
;
markerHover
.
removeAttribute
(
"
hidden
"
)
;
}
_emitHoverEvent
(
point
)
{
if
(
point
=
=
=
null
|
|
point
=
=
=
undefined
)
{
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
hover
-
off
"
}
)
;
}
else
{
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
hover
-
on
"
point
:
point
.
toString
(
)
}
)
;
}
}
convertPageCoordsToPercent
(
pageX
pageY
)
{
let
dims
=
this
.
frameDimensions
;
let
{
top
left
width
height
}
=
dims
;
pageX
-
=
left
;
pageY
-
=
top
;
let
percentX
=
pageX
*
100
/
width
;
let
percentY
=
pageY
*
100
/
height
;
return
{
percentX
percentY
}
;
}
convertPercentToPageCoords
(
x
y
)
{
let
dims
=
this
.
frameDimensions
;
let
{
top
left
width
height
}
=
dims
;
x
=
x
*
width
/
100
;
y
=
y
*
height
/
100
;
x
+
=
left
;
y
+
=
top
;
return
{
x
y
}
;
}
getTransformPointAt
(
pageX
pageY
)
{
let
{
nw
ne
sw
se
n
w
s
e
rotatePoint
center
}
=
this
.
transformedBoundingBox
;
let
{
width
height
}
=
this
.
currentDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
clickRadiusX
=
BASE_MARKER_SIZE
/
zoom
*
100
/
width
;
let
clickRadiusY
=
BASE_MARKER_SIZE
/
zoom
*
100
/
height
;
let
points
=
[
{
pointName
:
"
translate
"
x
:
center
[
0
]
y
:
center
[
1
]
}
{
pointName
:
"
scale
-
se
"
x
:
se
[
0
]
y
:
se
[
1
]
}
{
pointName
:
"
scale
-
ne
"
x
:
ne
[
0
]
y
:
ne
[
1
]
}
{
pointName
:
"
scale
-
sw
"
x
:
sw
[
0
]
y
:
sw
[
1
]
}
{
pointName
:
"
scale
-
nw
"
x
:
nw
[
0
]
y
:
nw
[
1
]
}
]
;
if
(
this
.
shapeType
=
=
=
"
polygon
"
|
|
this
.
shapeType
=
=
=
"
ellipse
"
)
{
points
.
push
(
{
pointName
:
"
scale
-
n
"
x
:
n
[
0
]
y
:
n
[
1
]
}
{
pointName
:
"
scale
-
s
"
x
:
s
[
0
]
y
:
s
[
1
]
}
{
pointName
:
"
scale
-
e
"
x
:
e
[
0
]
y
:
e
[
1
]
}
{
pointName
:
"
scale
-
w
"
x
:
w
[
0
]
y
:
w
[
1
]
}
)
;
}
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
let
x
=
rotatePoint
[
0
]
;
let
y
=
rotatePoint
[
1
]
;
if
(
pageX
>
=
x
-
clickRadiusX
&
&
pageX
<
=
x
+
clickRadiusX
&
&
pageY
>
=
y
-
clickRadiusY
&
&
pageY
<
=
y
+
clickRadiusY
)
{
return
"
rotate
"
;
}
}
for
(
let
{
pointName
x
y
}
of
points
)
{
if
(
pageX
>
=
x
-
clickRadiusX
&
&
pageX
<
=
x
+
clickRadiusX
&
&
pageY
>
=
y
-
clickRadiusY
&
&
pageY
<
=
y
+
clickRadiusY
)
{
return
pointName
;
}
}
return
"
"
;
}
getPolygonPointAt
(
pageX
pageY
)
{
let
{
coordinates
}
=
this
;
let
{
width
height
}
=
this
.
currentDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
clickRadiusX
=
BASE_MARKER_SIZE
/
zoom
*
100
/
width
;
let
clickRadiusY
=
BASE_MARKER_SIZE
/
zoom
*
100
/
height
;
for
(
let
[
index
coord
]
of
coordinates
.
entries
(
)
)
{
let
[
x
y
]
=
coord
;
if
(
pageX
>
=
x
-
clickRadiusX
&
&
pageX
<
=
x
+
clickRadiusX
&
&
pageY
>
=
y
-
clickRadiusY
&
&
pageY
<
=
y
+
clickRadiusY
)
{
return
index
;
}
}
return
-
1
;
}
getPolygonClickedLine
(
pageX
pageY
)
{
let
{
coordinates
}
=
this
;
let
{
width
}
=
this
.
currentDimensions
;
let
clickWidth
=
LINE_CLICK_WIDTH
*
100
/
width
;
for
(
let
i
=
0
;
i
<
coordinates
.
length
;
i
+
+
)
{
let
[
x1
y1
]
=
coordinates
[
i
]
;
let
[
x2
y2
]
=
(
i
=
=
=
coordinates
.
length
-
1
)
?
coordinates
[
0
]
:
coordinates
[
i
+
1
]
;
let
distance
=
distanceToLine
(
x1
y1
x2
y2
pageX
pageY
)
;
if
(
distance
<
=
clickWidth
&
&
Math
.
min
(
x1
x2
)
-
clickWidth
<
=
pageX
&
&
pageX
<
=
Math
.
max
(
x1
x2
)
+
clickWidth
&
&
Math
.
min
(
y1
y2
)
-
clickWidth
<
=
pageY
&
&
pageY
<
=
Math
.
max
(
y1
y2
)
+
clickWidth
)
{
let
[
newX
newY
]
=
projection
(
x1
y1
x2
y2
pageX
pageY
)
;
this
.
_addPolygonPoint
(
i
round
(
newX
"
%
"
)
round
(
newY
"
%
"
)
)
;
return
;
}
}
}
getCirclePointAt
(
pageX
pageY
)
{
let
{
cx
cy
rx
ry
}
=
this
.
coordinates
;
let
{
width
height
}
=
this
.
currentDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
clickRadiusX
=
BASE_MARKER_SIZE
/
zoom
*
100
/
width
;
let
clickRadiusY
=
BASE_MARKER_SIZE
/
zoom
*
100
/
height
;
if
(
clickedOnPoint
(
pageX
pageY
cx
cy
clickRadiusX
clickRadiusY
)
)
{
return
"
center
"
;
}
let
clickWidthX
=
LINE_CLICK_WIDTH
*
100
/
width
;
let
clickWidthY
=
LINE_CLICK_WIDTH
*
100
/
height
;
if
(
clickedOnEllipseEdge
(
pageX
pageY
cx
cy
rx
ry
clickWidthX
clickWidthY
)
|
|
clickedOnPoint
(
pageX
pageY
cx
+
rx
cy
clickRadiusX
clickRadiusY
)
)
{
return
"
radius
"
;
}
return
"
"
;
}
getEllipsePointAt
(
pageX
pageY
)
{
let
{
cx
cy
rx
ry
}
=
this
.
coordinates
;
let
{
width
height
}
=
this
.
currentDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
clickRadiusX
=
BASE_MARKER_SIZE
/
zoom
*
100
/
width
;
let
clickRadiusY
=
BASE_MARKER_SIZE
/
zoom
*
100
/
height
;
if
(
clickedOnPoint
(
pageX
pageY
cx
cy
clickRadiusX
clickRadiusY
)
)
{
return
"
center
"
;
}
if
(
clickedOnPoint
(
pageX
pageY
cx
+
rx
cy
clickRadiusX
clickRadiusY
)
)
{
return
"
rx
"
;
}
if
(
clickedOnPoint
(
pageX
pageY
cx
cy
+
ry
clickRadiusX
clickRadiusY
)
)
{
return
"
ry
"
;
}
return
"
"
;
}
getInsetPointAt
(
pageX
pageY
)
{
let
{
top
left
right
bottom
}
=
this
.
coordinates
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
{
width
height
}
=
this
.
currentDimensions
;
let
clickWidthX
=
LINE_CLICK_WIDTH
*
100
/
width
;
let
clickWidthY
=
LINE_CLICK_WIDTH
*
100
/
height
;
let
clickRadiusX
=
BASE_MARKER_SIZE
/
zoom
*
100
/
width
;
let
clickRadiusY
=
BASE_MARKER_SIZE
/
zoom
*
100
/
height
;
let
centerX
=
(
left
+
(
100
-
right
)
)
/
2
;
let
centerY
=
(
top
+
(
100
-
bottom
)
)
/
2
;
if
(
(
pageX
>
=
left
-
clickWidthX
&
&
pageX
<
=
left
+
clickWidthX
&
&
pageY
>
=
top
&
&
pageY
<
=
100
-
bottom
)
|
|
clickedOnPoint
(
pageX
pageY
left
centerY
clickRadiusX
clickRadiusY
)
)
{
return
"
left
"
;
}
if
(
(
pageX
>
=
100
-
right
-
clickWidthX
&
&
pageX
<
=
100
-
right
+
clickWidthX
&
&
pageY
>
=
top
&
&
pageY
<
=
100
-
bottom
)
|
|
clickedOnPoint
(
pageX
pageY
100
-
right
centerY
clickRadiusX
clickRadiusY
)
)
{
return
"
right
"
;
}
if
(
(
pageY
>
=
top
-
clickWidthY
&
&
pageY
<
=
top
+
clickWidthY
&
&
pageX
>
=
left
&
&
pageX
<
=
100
-
right
)
|
|
clickedOnPoint
(
pageX
pageY
centerX
top
clickRadiusX
clickRadiusY
)
)
{
return
"
top
"
;
}
if
(
(
pageY
>
=
100
-
bottom
-
clickWidthY
&
&
pageY
<
=
100
-
bottom
+
clickWidthY
&
&
pageX
>
=
left
&
&
pageX
<
=
100
-
right
)
|
|
clickedOnPoint
(
pageX
pageY
centerX
100
-
bottom
clickRadiusX
clickRadiusY
)
)
{
return
"
bottom
"
;
}
return
"
"
;
}
_parseCSSShapeValue
(
definition
)
{
const
shapeTypes
=
[
{
name
:
"
polygon
"
prefix
:
"
polygon
(
"
coordParser
:
this
.
polygonPoints
.
bind
(
this
)
}
{
name
:
"
circle
"
prefix
:
"
circle
(
"
coordParser
:
this
.
circlePoints
.
bind
(
this
)
}
{
name
:
"
ellipse
"
prefix
:
"
ellipse
(
"
coordParser
:
this
.
ellipsePoints
.
bind
(
this
)
}
{
name
:
"
inset
"
prefix
:
"
inset
(
"
coordParser
:
this
.
insetPoints
.
bind
(
this
)
}
]
;
const
geometryTypes
=
[
"
margin
"
"
border
"
"
padding
"
"
content
"
]
;
let
referenceBox
=
this
.
property
=
=
=
"
clip
-
path
"
?
"
border
"
:
"
margin
"
;
for
(
let
geometry
of
geometryTypes
)
{
if
(
definition
.
includes
(
geometry
)
)
{
referenceBox
=
geometry
;
}
}
this
.
referenceBox
=
referenceBox
;
this
.
useStrokeBox
=
definition
.
includes
(
"
stroke
-
box
"
)
;
this
.
geometryBox
=
definition
.
substring
(
definition
.
lastIndexOf
(
"
)
"
)
+
1
)
.
trim
(
)
;
for
(
let
{
name
prefix
coordParser
}
of
shapeTypes
)
{
if
(
definition
.
includes
(
prefix
)
)
{
definition
=
definition
.
substring
(
prefix
.
length
definition
.
lastIndexOf
(
"
)
"
)
)
;
return
{
shapeType
:
name
coordinates
:
coordParser
(
definition
)
}
;
}
}
return
null
;
}
polygonPoints
(
definition
)
{
this
.
coordUnits
=
this
.
polygonRawPoints
(
)
;
if
(
!
this
.
origCoordUnits
)
{
this
.
origCoordUnits
=
this
.
coordUnits
;
}
let
splitDef
=
definition
.
split
(
"
"
)
;
if
(
splitDef
[
0
]
=
=
=
"
evenodd
"
|
|
splitDef
[
0
]
=
=
=
"
nonzero
"
)
{
splitDef
.
shift
(
)
;
}
let
minX
=
Number
.
MAX_SAFE_INTEGER
;
let
minY
=
Number
.
MAX_SAFE_INTEGER
;
let
maxX
=
Number
.
MIN_SAFE_INTEGER
;
let
maxY
=
Number
.
MIN_SAFE_INTEGER
;
let
coordinates
=
splitDef
.
map
(
coords
=
>
{
let
[
x
y
]
=
splitCoords
(
coords
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
if
(
x
<
minX
)
{
minX
=
x
;
}
if
(
y
<
minY
)
{
minY
=
y
;
}
if
(
x
>
maxX
)
{
maxX
=
x
;
}
if
(
y
>
maxY
)
{
maxY
=
y
;
}
return
[
x
y
]
;
}
)
;
this
.
boundingBox
=
{
minX
minY
maxX
maxY
}
;
if
(
!
this
.
origBoundingBox
)
{
this
.
origBoundingBox
=
this
.
boundingBox
;
}
return
coordinates
;
}
polygonRawPoints
(
)
{
let
definition
=
getDefinedShapeProperties
(
this
.
currentNode
this
.
property
)
;
if
(
definition
=
=
=
this
.
rawDefinition
&
&
this
.
coordUnits
)
{
return
this
.
coordUnits
;
}
this
.
rawDefinition
=
definition
;
definition
=
definition
.
substring
(
8
definition
.
lastIndexOf
(
"
)
"
)
)
;
let
splitDef
=
definition
.
split
(
"
"
)
;
if
(
splitDef
[
0
]
.
includes
(
"
evenodd
"
)
|
|
splitDef
[
0
]
.
includes
(
"
nonzero
"
)
)
{
this
.
fillRule
=
splitDef
[
0
]
.
trim
(
)
;
splitDef
.
shift
(
)
;
}
else
{
this
.
fillRule
=
"
"
;
}
return
splitDef
.
map
(
coords
=
>
{
return
splitCoords
(
coords
)
.
map
(
coord
=
>
{
return
coord
.
replace
(
/
\
u00a0
/
g
"
"
)
;
}
)
;
}
)
;
}
circlePoints
(
definition
)
{
this
.
coordUnits
=
this
.
circleRawPoints
(
)
;
if
(
!
this
.
origCoordUnits
)
{
this
.
origCoordUnits
=
this
.
coordUnits
;
}
let
values
=
definition
.
split
(
"
at
"
)
;
let
radius
=
values
[
0
]
;
let
{
width
height
}
=
this
.
currentDimensions
;
let
center
=
splitCoords
(
values
[
1
]
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
let
computedSize
=
Math
.
sqrt
(
(
width
*
*
2
)
+
(
height
*
*
2
)
)
/
Math
.
sqrt
(
2
)
;
if
(
radius
=
=
=
"
closest
-
side
"
)
{
radius
=
Math
.
min
(
center
[
0
]
center
[
1
]
100
-
center
[
0
]
100
-
center
[
1
]
)
;
}
else
if
(
radius
=
=
=
"
farthest
-
side
"
)
{
radius
=
Math
.
max
(
center
[
0
]
center
[
1
]
100
-
center
[
0
]
100
-
center
[
1
]
)
;
}
else
if
(
radius
.
includes
(
"
calc
(
"
)
)
{
radius
=
evalCalcExpression
(
radius
.
substring
(
5
radius
.
length
-
1
)
computedSize
)
;
}
else
{
radius
=
coordToPercent
(
radius
computedSize
)
;
}
let
ratioX
=
width
/
computedSize
;
let
ratioY
=
height
/
computedSize
;
let
radiusX
=
radius
/
ratioX
;
let
radiusY
=
radius
/
ratioY
;
this
.
boundingBox
=
{
minX
:
center
[
0
]
-
radiusX
maxX
:
center
[
0
]
+
radiusX
minY
:
center
[
1
]
-
radiusY
maxY
:
center
[
1
]
+
radiusY
}
;
if
(
!
this
.
origBoundingBox
)
{
this
.
origBoundingBox
=
this
.
boundingBox
;
}
return
{
radius
rx
:
radiusX
ry
:
radiusY
cx
:
center
[
0
]
cy
:
center
[
1
]
}
;
}
circleRawPoints
(
)
{
let
definition
=
getDefinedShapeProperties
(
this
.
currentNode
this
.
property
)
;
if
(
definition
=
=
=
this
.
rawDefinition
&
&
this
.
coordUnits
)
{
return
this
.
coordUnits
;
}
this
.
rawDefinition
=
definition
;
definition
=
definition
.
substring
(
7
definition
.
lastIndexOf
(
"
)
"
)
)
;
let
values
=
definition
.
split
(
"
at
"
)
;
let
[
cx
=
"
"
cy
=
"
"
]
=
(
values
[
1
]
)
?
splitCoords
(
values
[
1
]
)
.
map
(
coord
=
>
{
return
coord
.
replace
(
/
\
u00a0
/
g
"
"
)
;
}
)
:
[
]
;
let
radius
=
(
values
[
0
]
)
?
values
[
0
]
.
trim
(
)
:
"
closest
-
side
"
;
return
{
cx
cy
radius
}
;
}
ellipsePoints
(
definition
)
{
this
.
coordUnits
=
this
.
ellipseRawPoints
(
)
;
if
(
!
this
.
origCoordUnits
)
{
this
.
origCoordUnits
=
this
.
coordUnits
;
}
let
values
=
definition
.
split
(
"
at
"
)
;
let
center
=
splitCoords
(
values
[
1
]
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
let
radii
=
splitCoords
(
values
[
0
]
)
.
map
(
(
radius
i
)
=
>
{
if
(
radius
=
=
=
"
closest
-
side
"
)
{
return
i
%
2
=
=
=
0
?
Math
.
min
(
center
[
0
]
100
-
center
[
0
]
)
:
Math
.
min
(
center
[
1
]
100
-
center
[
1
]
)
;
}
else
if
(
radius
=
=
=
"
farthest
-
side
"
)
{
return
i
%
2
=
=
=
0
?
Math
.
max
(
center
[
0
]
100
-
center
[
0
]
)
:
Math
.
max
(
center
[
1
]
100
-
center
[
1
]
)
;
}
return
this
.
convertCoordsToPercent
(
radius
i
)
;
}
)
;
this
.
boundingBox
=
{
minX
:
center
[
0
]
-
radii
[
0
]
maxX
:
center
[
0
]
+
radii
[
0
]
minY
:
center
[
1
]
-
radii
[
1
]
maxY
:
center
[
1
]
+
radii
[
1
]
}
;
if
(
!
this
.
origBoundingBox
)
{
this
.
origBoundingBox
=
this
.
boundingBox
;
}
return
{
rx
:
radii
[
0
]
ry
:
radii
[
1
]
cx
:
center
[
0
]
cy
:
center
[
1
]
}
;
}
ellipseRawPoints
(
)
{
let
definition
=
getDefinedShapeProperties
(
this
.
currentNode
this
.
property
)
;
if
(
definition
=
=
=
this
.
rawDefinition
&
&
this
.
coordUnits
)
{
return
this
.
coordUnits
;
}
this
.
rawDefinition
=
definition
;
definition
=
definition
.
substring
(
8
definition
.
lastIndexOf
(
"
)
"
)
)
;
let
values
=
definition
.
split
(
"
at
"
)
;
let
[
rx
=
"
closest
-
side
"
ry
=
"
closest
-
side
"
]
=
(
values
[
0
]
)
?
splitCoords
(
values
[
0
]
)
.
map
(
coord
=
>
{
return
coord
.
replace
(
/
\
u00a0
/
g
"
"
)
;
}
)
:
[
]
;
let
[
cx
=
"
"
cy
=
"
"
]
=
(
values
[
1
]
)
?
splitCoords
(
values
[
1
]
)
.
map
(
coord
=
>
{
return
coord
.
replace
(
/
\
u00a0
/
g
"
"
)
;
}
)
:
[
]
;
return
{
rx
ry
cx
cy
}
;
}
insetPoints
(
definition
)
{
this
.
coordUnits
=
this
.
insetRawPoints
(
)
;
if
(
!
this
.
origCoordUnits
)
{
this
.
origCoordUnits
=
this
.
coordUnits
;
}
let
values
=
definition
.
split
(
"
round
"
)
;
let
offsets
=
splitCoords
(
values
[
0
]
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
let
top
left
right
bottom
;
if
(
offsets
.
length
=
=
=
1
)
{
top
=
left
=
right
=
bottom
=
offsets
[
0
]
;
}
else
if
(
offsets
.
length
=
=
=
2
)
{
top
=
bottom
=
offsets
[
0
]
;
left
=
right
=
offsets
[
1
]
;
}
else
if
(
offsets
.
length
=
=
=
3
)
{
top
=
offsets
[
0
]
;
left
=
right
=
offsets
[
1
]
;
bottom
=
offsets
[
2
]
;
}
else
if
(
offsets
.
length
=
=
=
4
)
{
top
=
offsets
[
0
]
;
right
=
offsets
[
1
]
;
bottom
=
offsets
[
2
]
;
left
=
offsets
[
3
]
;
}
this
.
boundingBox
=
{
minX
:
left
maxX
:
100
-
right
minY
:
top
maxY
:
100
-
bottom
}
;
if
(
!
this
.
origBoundingBox
)
{
this
.
origBoundingBox
=
this
.
boundingBox
;
}
return
{
top
left
right
bottom
}
;
}
insetRawPoints
(
)
{
let
definition
=
getDefinedShapeProperties
(
this
.
currentNode
this
.
property
)
;
if
(
definition
=
=
=
this
.
rawDefinition
&
&
this
.
coordUnits
)
{
return
this
.
coordUnits
;
}
this
.
rawDefinition
=
definition
;
definition
=
definition
.
substring
(
6
definition
.
lastIndexOf
(
"
)
"
)
)
;
let
values
=
definition
.
split
(
"
round
"
)
;
this
.
insetRound
=
values
[
1
]
;
let
offsets
=
splitCoords
(
values
[
0
]
)
.
map
(
coord
=
>
{
return
coord
.
replace
(
/
\
u00a0
/
g
"
"
)
;
}
)
;
let
top
left
right
bottom
=
0
;
if
(
offsets
.
length
=
=
=
1
)
{
top
=
left
=
right
=
bottom
=
offsets
[
0
]
;
}
else
if
(
offsets
.
length
=
=
=
2
)
{
top
=
bottom
=
offsets
[
0
]
;
left
=
right
=
offsets
[
1
]
;
}
else
if
(
offsets
.
length
=
=
=
3
)
{
top
=
offsets
[
0
]
;
left
=
right
=
offsets
[
1
]
;
bottom
=
offsets
[
2
]
;
}
else
if
(
offsets
.
length
=
=
=
4
)
{
top
=
offsets
[
0
]
;
right
=
offsets
[
1
]
;
bottom
=
offsets
[
2
]
;
left
=
offsets
[
3
]
;
}
return
{
top
left
right
bottom
}
;
}
convertCoordsToPercent
(
coord
i
)
{
let
{
width
height
}
=
this
.
currentDimensions
;
let
size
=
i
%
2
=
=
=
0
?
width
:
height
;
if
(
coord
.
includes
(
"
calc
(
"
)
)
{
return
evalCalcExpression
(
coord
.
substring
(
5
coord
.
length
-
1
)
size
)
;
}
return
coordToPercent
(
coord
size
)
;
}
destroy
(
)
{
let
{
pageListenerTarget
}
=
this
.
highlighterEnv
;
if
(
pageListenerTarget
)
{
DOM_EVENTS
.
forEach
(
type
=
>
pageListenerTarget
.
removeEventListener
(
type
this
)
)
;
}
super
.
destroy
(
this
)
;
this
.
markup
.
destroy
(
)
;
}
getElement
(
id
)
{
return
this
.
markup
.
getElement
(
this
.
ID_CLASS_PREFIX
+
id
)
;
}
areShapesHidden
(
)
{
return
this
.
getElement
(
"
ellipse
"
)
.
hasAttribute
(
"
hidden
"
)
&
&
this
.
getElement
(
"
polygon
"
)
.
hasAttribute
(
"
hidden
"
)
&
&
this
.
getElement
(
"
rect
"
)
.
hasAttribute
(
"
hidden
"
)
&
&
this
.
getElement
(
"
bounding
-
box
"
)
.
hasAttribute
(
"
hidden
"
)
;
}
_show
(
)
{
this
.
hoveredPoint
=
this
.
options
.
hoverPoint
;
this
.
transformMode
=
this
.
options
.
transformMode
;
this
.
coordinates
=
null
;
this
.
coordUnits
=
null
;
this
.
origBoundingBox
=
null
;
this
.
origCoordUnits
=
null
;
this
.
origCoordinates
=
null
;
this
.
transformedBoundingBox
=
null
;
if
(
this
.
transformMode
)
{
this
.
transformMatrix
=
identity
(
)
;
}
if
(
this
.
_hasMoved
(
)
&
&
this
.
transformMode
)
{
this
.
transformedBoundingBox
=
this
.
calculateTransformedBoundingBox
(
)
;
}
return
this
.
_update
(
)
;
}
_hasMoved
(
)
{
let
hasMoved
=
AutoRefreshHighlighter
.
prototype
.
_hasMoved
.
call
(
this
)
;
if
(
hasMoved
)
{
this
.
origBoundingBox
=
null
;
this
.
origCoordUnits
=
null
;
this
.
origCoordinates
=
null
;
if
(
this
.
transformMode
)
{
this
.
transformMatrix
=
identity
(
)
;
}
}
let
oldShapeCoordinates
=
JSON
.
stringify
(
this
.
coordinates
)
;
if
(
this
.
options
.
mode
.
startsWith
(
"
css
"
)
)
{
let
property
=
shapeModeToCssPropertyName
(
this
.
options
.
mode
)
;
this
.
property
=
property
.
replace
(
/
(
[
a
-
z
]
[
A
-
Z
]
)
/
g
g
=
>
{
return
g
[
0
]
+
"
-
"
+
g
[
1
]
.
toLowerCase
(
)
;
}
)
;
let
style
=
getComputedStyle
(
this
.
currentNode
)
[
property
]
;
if
(
!
style
|
|
style
=
=
=
"
none
"
)
{
this
.
coordinates
=
[
]
;
this
.
shapeType
=
"
none
"
;
}
else
{
let
{
coordinates
shapeType
}
=
this
.
_parseCSSShapeValue
(
style
)
;
this
.
coordinates
=
coordinates
;
if
(
!
this
.
origCoordinates
)
{
this
.
origCoordinates
=
coordinates
;
}
this
.
shapeType
=
shapeType
;
}
}
let
newShapeCoordinates
=
JSON
.
stringify
(
this
.
coordinates
)
;
hasMoved
=
hasMoved
|
|
oldShapeCoordinates
!
=
=
newShapeCoordinates
;
if
(
this
.
transformMode
&
&
hasMoved
)
{
this
.
transformedBoundingBox
=
this
.
calculateTransformedBoundingBox
(
)
;
}
return
hasMoved
;
}
_hideShapes
(
)
{
this
.
getElement
(
"
ellipse
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
polygon
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
rect
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
bounding
-
box
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
markers
"
)
.
setAttribute
(
"
d
"
"
"
)
;
this
.
getElement
(
"
markers
-
outline
"
)
.
setAttribute
(
"
d
"
"
"
)
;
this
.
getElement
(
"
rotate
-
line
"
)
.
setAttribute
(
"
d
"
"
"
)
;
this
.
getElement
(
"
quad
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
clip
-
ellipse
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
clip
-
polygon
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
clip
-
rect
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
dashed
-
polygon
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
dashed
-
ellipse
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
dashed
-
rect
"
)
.
setAttribute
(
"
hidden
"
true
)
;
}
_update
(
)
{
setIgnoreLayoutChanges
(
true
)
;
this
.
getElement
(
"
group
"
)
.
setAttribute
(
"
transform
"
"
"
)
;
let
root
=
this
.
getElement
(
"
root
"
)
;
root
.
setAttribute
(
"
hidden
"
true
)
;
let
{
top
left
width
height
}
=
this
.
currentDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
this
.
getElement
(
"
shape
-
container
"
)
.
setAttribute
(
"
style
"
top
:
{
top
}
px
;
left
:
{
left
}
px
;
width
:
{
width
}
px
;
height
:
{
height
}
px
;
)
;
this
.
_hideShapes
(
)
;
if
(
this
.
transformMode
&
&
this
.
shapeType
!
=
=
"
none
"
)
{
this
.
_updateTransformMode
(
width
height
zoom
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_updatePolygonShape
(
width
height
zoom
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_updateCircleShape
(
width
height
zoom
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_updateEllipseShape
(
width
height
zoom
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
_updateInsetShape
(
width
height
zoom
)
;
}
if
(
this
.
property
=
=
=
"
shape
-
outside
"
)
{
let
quadRect
=
this
.
getElement
(
"
quad
"
)
;
quadRect
.
removeAttribute
(
"
hidden
"
)
;
this
.
getElement
(
"
polygon
"
)
.
setAttribute
(
"
clip
-
path
"
"
url
(
#
shapes
-
quad
-
clip
-
path
)
"
)
;
this
.
getElement
(
"
ellipse
"
)
.
setAttribute
(
"
clip
-
path
"
"
url
(
#
shapes
-
quad
-
clip
-
path
)
"
)
;
this
.
getElement
(
"
rect
"
)
.
setAttribute
(
"
clip
-
path
"
"
url
(
#
shapes
-
quad
-
clip
-
path
)
"
)
;
}
else
{
this
.
getElement
(
"
polygon
"
)
.
removeAttribute
(
"
clip
-
path
"
)
;
this
.
getElement
(
"
ellipse
"
)
.
removeAttribute
(
"
clip
-
path
"
)
;
this
.
getElement
(
"
rect
"
)
.
removeAttribute
(
"
clip
-
path
"
)
;
}
let
{
width
:
winWidth
height
:
winHeight
}
=
this
.
_winDimensions
;
root
.
removeAttribute
(
"
hidden
"
)
;
root
.
setAttribute
(
"
style
"
position
:
absolute
;
width
:
{
winWidth
}
px
;
height
:
{
winHeight
}
px
;
overflow
:
hidden
;
)
;
this
.
_handleMarkerHover
(
this
.
hoveredPoint
)
;
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
window
.
document
.
documentElement
)
;
return
true
;
}
_updateTransformMode
(
width
height
zoom
)
{
let
{
nw
ne
sw
se
n
w
s
e
rotatePoint
center
}
=
this
.
transformedBoundingBox
;
let
boundingBox
=
this
.
getElement
(
"
bounding
-
box
"
)
;
let
path
=
M
{
nw
.
join
(
"
"
)
}
L
{
ne
.
join
(
"
"
)
}
L
{
se
.
join
(
"
"
)
}
L
{
sw
.
join
(
"
"
)
}
Z
;
boundingBox
.
setAttribute
(
"
d
"
path
)
;
boundingBox
.
removeAttribute
(
"
hidden
"
)
;
let
markerPoints
=
[
center
nw
ne
se
sw
]
;
if
(
this
.
shapeType
=
=
=
"
polygon
"
|
|
this
.
shapeType
=
=
=
"
ellipse
"
)
{
markerPoints
.
push
(
n
s
w
e
)
;
}
this
.
_drawMarkers
(
markerPoints
width
height
zoom
)
;
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
let
points
=
this
.
coordinates
.
map
(
point
=
>
point
.
join
(
"
"
)
)
.
join
(
"
"
)
;
let
polygonEl
=
this
.
getElement
(
"
polygon
"
)
;
polygonEl
.
setAttribute
(
"
points
"
points
)
;
polygonEl
.
removeAttribute
(
"
hidden
"
)
;
let
clipPolygon
=
this
.
getElement
(
"
clip
-
polygon
"
)
;
clipPolygon
.
setAttribute
(
"
points
"
points
)
;
clipPolygon
.
removeAttribute
(
"
hidden
"
)
;
let
dashedPolygon
=
this
.
getElement
(
"
dashed
-
polygon
"
)
;
dashedPolygon
.
setAttribute
(
"
points
"
points
)
;
dashedPolygon
.
removeAttribute
(
"
hidden
"
)
;
markerPoints
.
push
(
rotatePoint
)
;
let
rotateLine
=
M
{
center
.
join
(
"
"
)
}
L
{
rotatePoint
.
join
(
"
"
)
}
;
this
.
getElement
(
"
rotate
-
line
"
)
.
setAttribute
(
"
d
"
rotateLine
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
|
|
this
.
shapeType
=
=
=
"
ellipse
"
)
{
let
{
rx
ry
cx
cy
}
=
this
.
coordinates
;
let
ellipseEl
=
this
.
getElement
(
"
ellipse
"
)
;
ellipseEl
.
setAttribute
(
"
rx
"
rx
)
;
ellipseEl
.
setAttribute
(
"
ry
"
ry
)
;
ellipseEl
.
setAttribute
(
"
cx
"
cx
)
;
ellipseEl
.
setAttribute
(
"
cy
"
cy
)
;
ellipseEl
.
removeAttribute
(
"
hidden
"
)
;
let
clipEllipse
=
this
.
getElement
(
"
clip
-
ellipse
"
)
;
clipEllipse
.
setAttribute
(
"
rx
"
rx
)
;
clipEllipse
.
setAttribute
(
"
ry
"
ry
)
;
clipEllipse
.
setAttribute
(
"
cx
"
cx
)
;
clipEllipse
.
setAttribute
(
"
cy
"
cy
)
;
clipEllipse
.
removeAttribute
(
"
hidden
"
)
;
let
dashedEllipse
=
this
.
getElement
(
"
dashed
-
ellipse
"
)
;
dashedEllipse
.
setAttribute
(
"
rx
"
rx
)
;
dashedEllipse
.
setAttribute
(
"
ry
"
ry
)
;
dashedEllipse
.
setAttribute
(
"
cx
"
cx
)
;
dashedEllipse
.
setAttribute
(
"
cy
"
cy
)
;
dashedEllipse
.
removeAttribute
(
"
hidden
"
)
;
}
this
.
_drawMarkers
(
markerPoints
width
height
zoom
)
;
}
_updatePolygonShape
(
width
height
zoom
)
{
let
points
=
this
.
coordinates
.
map
(
point
=
>
point
.
join
(
"
"
)
)
.
join
(
"
"
)
;
let
polygonEl
=
this
.
getElement
(
"
polygon
"
)
;
polygonEl
.
setAttribute
(
"
points
"
points
)
;
polygonEl
.
removeAttribute
(
"
hidden
"
)
;
let
clipPolygon
=
this
.
getElement
(
"
clip
-
polygon
"
)
;
clipPolygon
.
setAttribute
(
"
points
"
points
)
;
clipPolygon
.
removeAttribute
(
"
hidden
"
)
;
let
dashedPolygon
=
this
.
getElement
(
"
dashed
-
polygon
"
)
;
dashedPolygon
.
setAttribute
(
"
points
"
points
)
;
dashedPolygon
.
removeAttribute
(
"
hidden
"
)
;
this
.
_drawMarkers
(
this
.
coordinates
width
height
zoom
)
;
}
_updateCircleShape
(
width
height
zoom
)
{
let
{
rx
ry
cx
cy
}
=
this
.
coordinates
;
let
ellipseEl
=
this
.
getElement
(
"
ellipse
"
)
;
ellipseEl
.
setAttribute
(
"
rx
"
rx
)
;
ellipseEl
.
setAttribute
(
"
ry
"
ry
)
;
ellipseEl
.
setAttribute
(
"
cx
"
cx
)
;
ellipseEl
.
setAttribute
(
"
cy
"
cy
)
;
ellipseEl
.
removeAttribute
(
"
hidden
"
)
;
let
clipEllipse
=
this
.
getElement
(
"
clip
-
ellipse
"
)
;
clipEllipse
.
setAttribute
(
"
rx
"
rx
)
;
clipEllipse
.
setAttribute
(
"
ry
"
ry
)
;
clipEllipse
.
setAttribute
(
"
cx
"
cx
)
;
clipEllipse
.
setAttribute
(
"
cy
"
cy
)
;
clipEllipse
.
removeAttribute
(
"
hidden
"
)
;
let
dashedEllipse
=
this
.
getElement
(
"
dashed
-
ellipse
"
)
;
dashedEllipse
.
setAttribute
(
"
rx
"
rx
)
;
dashedEllipse
.
setAttribute
(
"
ry
"
ry
)
;
dashedEllipse
.
setAttribute
(
"
cx
"
cx
)
;
dashedEllipse
.
setAttribute
(
"
cy
"
cy
)
;
dashedEllipse
.
removeAttribute
(
"
hidden
"
)
;
this
.
_drawMarkers
(
[
[
cx
cy
]
[
cx
+
rx
cy
]
]
width
height
zoom
)
;
}
_updateEllipseShape
(
width
height
zoom
)
{
let
{
rx
ry
cx
cy
}
=
this
.
coordinates
;
let
ellipseEl
=
this
.
getElement
(
"
ellipse
"
)
;
ellipseEl
.
setAttribute
(
"
rx
"
rx
)
;
ellipseEl
.
setAttribute
(
"
ry
"
ry
)
;
ellipseEl
.
setAttribute
(
"
cx
"
cx
)
;
ellipseEl
.
setAttribute
(
"
cy
"
cy
)
;
ellipseEl
.
removeAttribute
(
"
hidden
"
)
;
let
clipEllipse
=
this
.
getElement
(
"
clip
-
ellipse
"
)
;
clipEllipse
.
setAttribute
(
"
rx
"
rx
)
;
clipEllipse
.
setAttribute
(
"
ry
"
ry
)
;
clipEllipse
.
setAttribute
(
"
cx
"
cx
)
;
clipEllipse
.
setAttribute
(
"
cy
"
cy
)
;
clipEllipse
.
removeAttribute
(
"
hidden
"
)
;
let
dashedEllipse
=
this
.
getElement
(
"
dashed
-
ellipse
"
)
;
dashedEllipse
.
setAttribute
(
"
rx
"
rx
)
;
dashedEllipse
.
setAttribute
(
"
ry
"
ry
)
;
dashedEllipse
.
setAttribute
(
"
cx
"
cx
)
;
dashedEllipse
.
setAttribute
(
"
cy
"
cy
)
;
dashedEllipse
.
removeAttribute
(
"
hidden
"
)
;
let
markerCoords
=
[
[
cx
cy
]
[
cx
+
rx
cy
]
[
cx
cy
+
ry
]
]
;
this
.
_drawMarkers
(
markerCoords
width
height
zoom
)
;
}
_updateInsetShape
(
width
height
zoom
)
{
let
{
top
left
right
bottom
}
=
this
.
coordinates
;
let
rectEl
=
this
.
getElement
(
"
rect
"
)
;
rectEl
.
setAttribute
(
"
x
"
left
)
;
rectEl
.
setAttribute
(
"
y
"
top
)
;
rectEl
.
setAttribute
(
"
width
"
100
-
left
-
right
)
;
rectEl
.
setAttribute
(
"
height
"
100
-
top
-
bottom
)
;
rectEl
.
removeAttribute
(
"
hidden
"
)
;
let
clipRect
=
this
.
getElement
(
"
clip
-
rect
"
)
;
clipRect
.
setAttribute
(
"
x
"
left
)
;
clipRect
.
setAttribute
(
"
y
"
top
)
;
clipRect
.
setAttribute
(
"
width
"
100
-
left
-
right
)
;
clipRect
.
setAttribute
(
"
height
"
100
-
top
-
bottom
)
;
clipRect
.
removeAttribute
(
"
hidden
"
)
;
let
dashedRect
=
this
.
getElement
(
"
dashed
-
rect
"
)
;
dashedRect
.
setAttribute
(
"
x
"
left
)
;
dashedRect
.
setAttribute
(
"
y
"
top
)
;
dashedRect
.
setAttribute
(
"
width
"
100
-
left
-
right
)
;
dashedRect
.
setAttribute
(
"
height
"
100
-
top
-
bottom
)
;
dashedRect
.
removeAttribute
(
"
hidden
"
)
;
let
centerX
=
(
left
+
(
100
-
right
)
)
/
2
;
let
centerY
=
(
top
+
(
100
-
bottom
)
)
/
2
;
let
markerCoords
=
[
[
centerX
top
]
[
100
-
right
centerY
]
[
centerX
100
-
bottom
]
[
left
centerY
]
]
;
this
.
_drawMarkers
(
markerCoords
width
height
zoom
)
;
}
_drawMarkers
(
coords
width
height
zoom
)
{
let
markers
=
coords
.
map
(
(
[
x
y
]
)
=
>
{
return
getCirclePath
(
BASE_MARKER_SIZE
x
y
width
height
zoom
)
;
}
)
.
join
(
"
"
)
;
let
outline
=
coords
.
map
(
(
[
x
y
]
)
=
>
{
return
getCirclePath
(
BASE_MARKER_SIZE
+
2
x
y
width
height
zoom
)
;
}
)
.
join
(
"
"
)
;
this
.
getElement
(
"
markers
"
)
.
setAttribute
(
"
d
"
markers
)
;
this
.
getElement
(
"
markers
-
outline
"
)
.
setAttribute
(
"
d
"
outline
)
;
}
calculateTransformedBoundingBox
(
)
{
let
{
minX
minY
maxX
maxY
}
=
this
.
origBoundingBox
;
let
{
width
height
}
=
this
.
currentDimensions
;
let
toPixel
=
scale
(
width
/
100
height
/
100
)
;
let
toPercent
=
scale
(
100
/
width
100
/
height
)
;
let
matrix
=
multiply
(
toPercent
multiply
(
this
.
transformMatrix
toPixel
)
)
;
let
centerX
=
(
minX
+
maxX
)
/
2
;
let
centerY
=
(
minY
+
maxY
)
/
2
;
let
nw
=
apply
(
matrix
[
minX
minY
]
)
;
let
ne
=
apply
(
matrix
[
maxX
minY
]
)
;
let
sw
=
apply
(
matrix
[
minX
maxY
]
)
;
let
se
=
apply
(
matrix
[
maxX
maxY
]
)
;
let
n
=
apply
(
matrix
[
centerX
minY
]
)
;
let
s
=
apply
(
matrix
[
centerX
maxY
]
)
;
let
w
=
apply
(
matrix
[
minX
centerY
]
)
;
let
e
=
apply
(
matrix
[
maxX
centerY
]
)
;
let
center
=
apply
(
matrix
[
centerX
centerY
]
)
;
let
u
=
[
(
ne
[
0
]
-
nw
[
0
]
)
/
100
*
width
(
ne
[
1
]
-
nw
[
1
]
)
/
100
*
height
]
;
let
v
=
[
(
sw
[
0
]
-
nw
[
0
]
)
/
100
*
width
(
sw
[
1
]
-
nw
[
1
]
)
/
100
*
height
]
;
let
{
basis
invertedBasis
}
=
getBasis
(
u
v
)
;
let
rotatePointMatrix
=
changeMatrixBase
(
translate
(
0
-
ROTATE_LINE_LENGTH
)
invertedBasis
basis
)
;
rotatePointMatrix
=
multiply
(
toPercent
multiply
(
rotatePointMatrix
multiply
(
this
.
transformMatrix
toPixel
)
)
)
;
let
rotatePoint
=
apply
(
rotatePointMatrix
[
centerX
centerY
]
)
;
return
{
nw
ne
sw
se
n
s
w
e
rotatePoint
center
}
;
}
_hide
(
)
{
setIgnoreLayoutChanges
(
true
)
;
this
.
_hideShapes
(
)
;
this
.
getElement
(
"
markers
"
)
.
setAttribute
(
"
d
"
"
"
)
;
this
.
getElement
(
"
root
"
)
.
setAttribute
(
"
style
"
"
"
)
;
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
window
.
document
.
documentElement
)
;
}
onPageHide
(
{
target
}
)
{
if
(
target
.
defaultView
=
=
=
this
.
win
)
{
this
.
hide
(
)
;
}
}
getRoughDirection
(
pointName
anchor
)
{
let
scalePoint
=
pointName
.
split
(
"
-
"
)
[
1
]
;
let
anchorPos
=
this
.
transformedBoundingBox
[
anchor
]
;
let
scalePos
=
this
.
transformedBoundingBox
[
scalePoint
]
;
let
{
minX
minY
maxX
maxY
}
=
this
.
boundingBox
;
let
width
=
maxX
-
minX
;
let
height
=
maxY
-
minY
;
let
dx
=
(
scalePos
[
0
]
-
anchorPos
[
0
]
)
/
width
;
let
dy
=
(
scalePos
[
1
]
-
anchorPos
[
1
]
)
/
height
;
if
(
dx
>
=
-
0
.
33
&
&
dx
<
=
0
.
33
)
{
return
"
ns
"
;
}
else
if
(
dy
>
=
-
0
.
33
&
&
dy
<
=
0
.
33
)
{
return
"
ew
"
;
}
else
if
(
(
dx
>
0
.
33
&
&
dy
<
-
0
.
33
)
|
|
(
dx
<
-
0
.
33
&
&
dy
>
0
.
33
)
)
{
return
"
nesw
"
;
}
return
"
nwse
"
;
}
getUnitToPixelRatio
(
unit
size
)
{
let
ratio
;
const
windowHeight
=
this
.
currentNode
.
ownerGlobal
.
innerHeight
;
const
windowWidth
=
this
.
currentNode
.
ownerGlobal
.
innerWidth
;
switch
(
unit
)
{
case
"
%
"
:
ratio
=
100
/
size
;
break
;
case
"
em
"
:
ratio
=
1
/
parseFloat
(
getComputedStyle
(
this
.
currentNode
)
.
fontSize
)
;
break
;
case
"
rem
"
:
const
root
=
this
.
currentNode
.
ownerDocument
.
documentElement
;
ratio
=
1
/
parseFloat
(
getComputedStyle
(
root
)
.
fontSize
)
;
break
;
case
"
vw
"
:
ratio
=
100
/
windowWidth
;
break
;
case
"
vh
"
:
ratio
=
100
/
windowHeight
;
break
;
case
"
vmin
"
:
ratio
=
100
/
Math
.
min
(
windowHeight
windowWidth
)
;
break
;
case
"
vmax
"
:
ratio
=
100
/
Math
.
max
(
windowHeight
windowWidth
)
;
break
;
default
:
ratio
=
1
;
}
return
ratio
;
}
}
function
getDefinedShapeProperties
(
node
property
)
{
let
prop
=
"
"
;
if
(
!
node
)
{
return
prop
;
}
let
cssRules
=
getCSSStyleRules
(
node
)
;
for
(
let
i
=
0
;
i
<
cssRules
.
length
;
i
+
+
)
{
let
rule
=
cssRules
[
i
]
;
let
value
=
rule
.
style
.
getPropertyValue
(
property
)
;
if
(
value
&
&
value
!
=
=
"
auto
"
)
{
prop
=
value
;
}
}
if
(
node
.
style
)
{
let
value
=
node
.
style
.
getPropertyValue
(
property
)
;
if
(
value
&
&
value
!
=
=
"
auto
"
)
{
prop
=
value
;
}
}
return
prop
.
trim
(
)
;
}
function
splitCoords
(
coords
)
{
return
coords
.
trim
(
)
.
replace
(
/
[
\
+
\
-
\
*
\
/
]
/
g
match
=
>
{
return
\
u00a0
{
match
.
trim
(
)
}
\
u00a0
;
}
)
.
split
(
"
"
)
;
}
exports
.
splitCoords
=
splitCoords
;
function
coordToPercent
(
coord
size
)
{
if
(
coord
.
includes
(
"
%
"
)
)
{
return
parseFloat
(
coord
.
replace
(
"
%
"
"
"
)
)
;
}
else
if
(
coord
.
includes
(
"
px
"
)
)
{
let
px
=
parseFloat
(
coord
.
replace
(
"
px
"
"
"
)
)
;
return
px
*
100
/
size
;
}
return
0
;
}
exports
.
coordToPercent
=
coordToPercent
;
function
evalCalcExpression
(
expression
size
)
{
let
values
=
expression
.
split
(
"
+
"
)
.
map
(
v
=
>
v
.
trim
(
)
)
;
return
values
.
reduce
(
(
prev
curr
)
=
>
{
return
prev
+
coordToPercent
(
curr
size
)
;
}
0
)
;
}
exports
.
evalCalcExpression
=
evalCalcExpression
;
const
shapeModeToCssPropertyName
=
mode
=
>
{
let
property
=
mode
.
substring
(
3
)
;
return
property
.
substring
(
0
1
)
.
toLowerCase
(
)
+
property
.
substring
(
1
)
;
}
;
exports
.
shapeModeToCssPropertyName
=
shapeModeToCssPropertyName
;
const
getCirclePath
=
(
size
cx
cy
width
height
zoom
)
=
>
{
let
radius
=
size
*
(
100
/
Math
.
max
(
width
height
)
)
/
zoom
;
let
ratio
=
width
/
height
;
let
rx
=
(
ratio
>
1
)
?
radius
:
radius
/
ratio
;
let
ry
=
(
ratio
>
1
)
?
radius
*
ratio
:
radius
;
return
M
{
cx
-
rx
}
{
cy
}
a
{
rx
}
{
ry
}
0
1
0
{
rx
*
2
}
0
+
a
{
rx
}
{
ry
}
0
1
0
{
rx
*
-
2
}
0
;
}
;
exports
.
getCirclePath
=
getCirclePath
;
const
getObjectBoundingBox
=
(
top
left
width
height
node
)
=
>
{
let
strokeWidth
=
parseFloat
(
getComputedStyle
(
node
)
.
strokeWidth
)
;
let
delta
=
strokeWidth
/
2
;
let
tagName
=
node
.
tagName
;
if
(
tagName
!
=
=
"
rect
"
&
&
tagName
!
=
=
"
ellipse
"
&
&
tagName
!
=
=
"
circle
"
&
&
tagName
!
=
=
"
image
"
)
{
if
(
getComputedStyle
(
node
)
.
strokeLinejoin
=
=
=
"
miter
"
)
{
let
miter
=
getComputedStyle
(
node
)
.
strokeMiterlimit
;
if
(
miter
<
Math
.
SQRT2
)
{
delta
*
=
Math
.
SQRT2
;
}
else
{
delta
*
=
miter
;
}
}
else
{
delta
*
=
Math
.
SQRT2
;
}
}
return
{
top
:
top
+
delta
left
:
left
+
delta
width
:
width
-
2
*
delta
height
:
height
-
2
*
delta
}
;
}
;
const
getUnit
=
(
point
)
=
>
{
if
(
isUnitless
(
point
)
)
{
return
"
px
"
;
}
let
[
unit
]
=
point
.
match
(
/
[
^
\
d
]
+
/
)
|
|
[
"
px
"
]
;
return
unit
;
}
;
exports
.
getUnit
=
getUnit
;
const
isUnitless
=
(
point
)
=
>
{
return
!
point
|
|
!
point
.
match
(
/
[
^
\
d
]
+
/
)
|
|
(
parseFloat
(
point
)
=
=
=
0
&
&
(
parseFloat
(
point
)
.
toString
(
)
=
=
=
point
)
)
|
|
point
.
includes
(
"
(
"
)
|
|
point
=
=
=
"
closest
-
side
"
|
|
point
=
=
=
"
farthest
-
side
"
;
}
;
const
getAnchorPoint
=
(
type
)
=
>
{
let
anchor
=
type
.
split
(
"
-
"
)
[
1
]
;
if
(
anchor
.
includes
(
"
n
"
)
)
{
anchor
=
anchor
.
replace
(
"
n
"
"
s
"
)
;
}
else
if
(
anchor
.
includes
(
"
s
"
)
)
{
anchor
=
anchor
.
replace
(
"
s
"
"
n
"
)
;
}
if
(
anchor
.
includes
(
"
w
"
)
)
{
anchor
=
anchor
.
replace
(
"
w
"
"
e
"
)
;
}
else
if
(
anchor
.
includes
(
"
e
"
)
)
{
anchor
=
anchor
.
replace
(
"
e
"
"
w
"
)
;
}
if
(
anchor
=
=
=
"
e
"
|
|
anchor
=
=
=
"
w
"
)
{
anchor
=
"
n
"
+
anchor
;
}
else
if
(
anchor
=
=
=
"
n
"
|
|
anchor
=
=
=
"
s
"
)
{
anchor
=
anchor
+
"
w
"
;
}
return
anchor
;
}
;
function
getDecimalPrecision
(
unitType
)
{
switch
(
unitType
)
{
case
"
px
"
:
case
"
"
:
case
undefined
:
return
0
;
default
:
return
2
;
}
}
exports
.
getDecimalPrecision
=
getDecimalPrecision
;
function
round
(
number
unitType
)
{
return
number
.
toFixed
(
getDecimalPrecision
(
unitType
)
)
;
}
exports
.
ShapesHighlighter
=
ShapesHighlighter
;
