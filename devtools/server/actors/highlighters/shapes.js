"
use
strict
"
;
const
{
CanvasFrameAnonymousContentHelper
createSVGNode
createNode
getComputedStyle
}
=
require
(
"
.
/
utils
/
markup
"
)
;
const
{
setIgnoreLayoutChanges
getCurrentZoom
getAdjustedQuads
getFrameOffsets
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
{
AutoRefreshHighlighter
}
=
require
(
"
.
/
auto
-
refresh
"
)
;
const
{
getDistance
clickedOnEllipseEdge
distanceToLine
projection
clickedOnPoint
scalePoint
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
shapes
-
utils
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
old
-
event
-
emitter
"
)
;
const
{
getCSSStyleRules
}
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
BASE_MARKER_SIZE
=
5
;
const
LINE_CLICK_WIDTH
=
5
;
const
DOM_EVENTS
=
[
"
mousedown
"
"
mousemove
"
"
mouseup
"
"
dblclick
"
]
;
const
_dragging
=
Symbol
(
"
shapes
/
dragging
"
)
;
class
ShapesHighlighter
extends
AutoRefreshHighlighter
{
constructor
(
highlighterEnv
)
{
super
(
highlighterEnv
)
;
EventEmitter
.
decorate
(
this
)
;
this
.
ID_CLASS_PREFIX
=
"
shapes
-
"
;
this
.
referenceBox
=
"
border
"
;
this
.
useStrokeBox
=
false
;
this
.
geometryBox
=
"
"
;
this
.
hoveredPoint
=
null
;
this
.
fillRule
=
"
"
;
this
.
numInsetPoints
=
0
;
this
.
transformMode
=
false
;
this
.
markup
=
new
CanvasFrameAnonymousContentHelper
(
this
.
highlighterEnv
this
.
_buildMarkup
.
bind
(
this
)
)
;
this
.
onPageHide
=
this
.
onPageHide
.
bind
(
this
)
;
let
{
pageListenerTarget
}
=
this
.
highlighterEnv
;
DOM_EVENTS
.
forEach
(
event
=
>
pageListenerTarget
.
addEventListener
(
event
this
)
)
;
pageListenerTarget
.
addEventListener
(
"
pagehide
"
this
.
onPageHide
)
;
}
_buildMarkup
(
)
{
let
container
=
createNode
(
this
.
win
{
attributes
:
{
"
class
"
:
"
highlighter
-
container
"
}
}
)
;
let
rootWrapper
=
createNode
(
this
.
win
{
parent
:
container
attributes
:
{
"
id
"
:
"
root
"
"
class
"
:
"
root
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
mainSvg
=
createSVGNode
(
this
.
win
{
nodeType
:
"
svg
"
parent
:
rootWrapper
attributes
:
{
"
id
"
:
"
shape
-
container
"
"
class
"
:
"
shape
-
container
"
"
viewBox
"
:
"
0
0
100
100
"
"
preserveAspectRatio
"
:
"
none
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
polygon
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
polygon
"
"
class
"
:
"
polygon
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
ellipse
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
ellipse
"
"
class
"
:
"
ellipse
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
rect
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
rect
"
"
class
"
:
"
rect
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
rect
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
bounding
-
box
"
"
class
"
:
"
bounding
-
box
"
"
stroke
-
dasharray
"
:
"
5
5
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
path
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
markers
-
outline
"
"
class
"
:
"
markers
-
outline
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
path
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
markers
"
"
class
"
:
"
markers
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
path
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
marker
-
hover
"
"
class
"
:
"
marker
-
hover
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
return
container
;
}
get
currentDimensions
(
)
{
let
{
top
left
width
height
}
=
this
.
currentQuads
[
this
.
referenceBox
]
[
0
]
.
bounds
;
if
(
this
.
currentNode
.
getBBox
&
&
getComputedStyle
(
this
.
currentNode
)
.
stroke
!
=
=
"
none
"
&
&
!
this
.
useStrokeBox
)
{
return
getObjectBoundingBox
(
top
left
width
height
this
.
currentNode
)
;
}
return
{
top
left
width
height
}
;
}
get
zoomAdjustedDimensions
(
)
{
let
{
top
left
width
height
}
=
this
.
currentDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
return
{
top
:
top
/
zoom
left
:
left
/
zoom
width
:
width
/
zoom
height
:
height
/
zoom
}
;
}
get
frameDimensions
(
)
{
let
dims
=
getAdjustedQuads
(
this
.
currentNode
.
ownerGlobal
this
.
currentNode
this
.
referenceBox
)
[
0
]
.
bounds
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
if
(
this
.
currentNode
.
getBBox
&
&
getComputedStyle
(
this
.
currentNode
)
.
stroke
!
=
=
"
none
"
&
&
!
this
.
useStrokeBox
)
{
dims
=
getObjectBoundingBox
(
dims
.
top
dims
.
left
dims
.
width
dims
.
height
this
.
currentNode
)
;
}
return
{
top
:
dims
.
top
/
zoom
left
:
dims
.
left
/
zoom
width
:
dims
.
width
/
zoom
height
:
dims
.
height
/
zoom
}
;
}
handleEvent
(
event
id
)
{
if
(
this
.
areShapesHidden
(
)
)
{
return
;
}
let
{
target
type
pageX
pageY
}
=
event
;
if
(
target
.
ownerDocument
!
=
=
this
.
currentNode
.
ownerDocument
)
{
let
[
xOffset
yOffset
]
=
getFrameOffsets
(
target
.
ownerGlobal
this
.
currentNode
)
;
let
viewportLeft
=
pageX
-
event
.
clientX
;
let
viewportTop
=
pageY
-
event
.
clientY
;
pageX
-
=
viewportLeft
+
xOffset
;
pageY
-
=
viewportTop
+
yOffset
;
}
switch
(
type
)
{
case
"
pagehide
"
:
if
(
target
.
defaultView
=
=
=
this
.
win
)
{
this
.
destroy
(
)
;
}
break
;
case
"
mousedown
"
:
if
(
this
.
transformMode
)
{
this
.
_handleTransformClick
(
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_handlePolygonClick
(
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_handleCircleClick
(
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_handleEllipseClick
(
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
_handleInsetClick
(
pageX
pageY
)
;
}
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
break
;
case
"
mouseup
"
:
if
(
this
[
_dragging
]
)
{
this
[
_dragging
]
=
null
;
}
break
;
case
"
mousemove
"
:
if
(
!
this
[
_dragging
]
)
{
this
.
_handleMouseMoveNotDragging
(
pageX
pageY
)
;
return
;
}
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
let
{
point
}
=
this
[
_dragging
]
;
if
(
this
.
transformMode
)
{
this
.
_handleTransformMove
(
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_handlePolygonMove
(
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_handleCircleMove
(
point
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_handleEllipseMove
(
point
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
_handleInsetMove
(
point
pageX
pageY
)
;
}
break
;
case
"
dblclick
"
:
if
(
this
.
shapeType
=
=
=
"
polygon
"
&
&
!
this
.
transformMode
)
{
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
index
=
this
.
getPolygonPointAt
(
percentX
percentY
)
;
if
(
index
=
=
=
-
1
)
{
this
.
getPolygonClickedLine
(
percentX
percentY
)
;
return
;
}
this
.
_deletePolygonPoint
(
index
)
;
}
break
;
}
}
_handleTransformClick
(
pageX
pageY
)
{
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
type
=
this
.
getTransformPointAt
(
percentX
percentY
)
;
if
(
!
type
)
{
return
;
}
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_handlePolygonTransformClick
(
pageX
pageY
type
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_handleCircleTransformClick
(
pageX
pageY
type
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_handleEllipseTransformClick
(
pageX
pageY
type
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
_handleInsetTransformClick
(
pageX
pageY
type
)
;
}
}
_handlePolygonTransformClick
(
pageX
pageY
type
)
{
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
pointsInfo
=
this
.
coordUnits
.
map
(
(
[
x
y
]
i
)
=
>
{
let
xComputed
=
this
.
coordinates
[
i
]
[
0
]
/
100
*
width
;
let
yComputed
=
this
.
coordinates
[
i
]
[
1
]
/
100
*
height
;
let
unitX
=
getUnit
(
x
)
;
let
unitY
=
getUnit
(
y
)
;
let
valueX
=
(
isUnitless
(
x
)
)
?
xComputed
:
parseFloat
(
x
)
;
let
valueY
=
(
isUnitless
(
y
)
)
?
yComputed
:
parseFloat
(
y
)
;
let
ratioX
=
(
valueX
/
xComputed
)
|
|
1
;
let
ratioY
=
(
valueY
/
yComputed
)
|
|
1
;
return
{
unitX
unitY
valueX
valueY
ratioX
ratioY
}
;
}
)
;
this
[
_dragging
]
=
{
type
pointsInfo
x
:
pageX
y
:
pageY
bb
:
this
.
boundingBox
}
;
}
_handleCircleTransformClick
(
pageX
pageY
type
)
{
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
{
cx
cy
}
=
this
.
coordUnits
;
let
cxComputed
=
this
.
coordinates
.
cx
/
100
*
width
;
let
cyComputed
=
this
.
coordinates
.
cy
/
100
*
height
;
let
unitX
=
getUnit
(
cx
)
;
let
unitY
=
getUnit
(
cy
)
;
let
valueX
=
(
isUnitless
(
cx
)
)
?
cxComputed
:
parseFloat
(
cx
)
;
let
valueY
=
(
isUnitless
(
cy
)
)
?
cyComputed
:
parseFloat
(
cy
)
;
let
ratioX
=
(
valueX
/
cxComputed
)
|
|
1
;
let
ratioY
=
(
valueY
/
cyComputed
)
|
|
1
;
let
{
radius
}
=
this
.
coordinates
;
let
computedSize
=
Math
.
sqrt
(
(
width
*
*
2
)
+
(
height
*
*
2
)
)
/
Math
.
sqrt
(
2
)
;
radius
=
radius
/
100
*
computedSize
;
let
valueRad
=
this
.
coordUnits
.
radius
;
let
unitRad
=
getUnit
(
valueRad
)
;
valueRad
=
(
isUnitless
(
valueRad
)
)
?
radius
:
parseFloat
(
valueRad
)
;
let
ratioRad
=
(
valueRad
/
radius
)
|
|
1
;
this
[
_dragging
]
=
{
type
unitX
unitY
unitRad
valueX
valueY
ratioX
ratioY
ratioRad
x
:
pageX
y
:
pageY
bb
:
this
.
boundingBox
}
;
}
_handleEllipseTransformClick
(
pageX
pageY
type
)
{
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
{
cx
cy
}
=
this
.
coordUnits
;
let
cxComputed
=
this
.
coordinates
.
cx
/
100
*
width
;
let
cyComputed
=
this
.
coordinates
.
cy
/
100
*
height
;
let
unitX
=
getUnit
(
cx
)
;
let
unitY
=
getUnit
(
cy
)
;
let
valueX
=
(
isUnitless
(
cx
)
)
?
cxComputed
:
parseFloat
(
cx
)
;
let
valueY
=
(
isUnitless
(
cy
)
)
?
cyComputed
:
parseFloat
(
cy
)
;
let
ratioX
=
(
valueX
/
cxComputed
)
|
|
1
;
let
ratioY
=
(
valueY
/
cyComputed
)
|
|
1
;
let
{
rx
ry
}
=
this
.
coordinates
;
rx
=
rx
/
100
*
width
;
let
valueRX
=
this
.
coordUnits
.
rx
;
let
unitRX
=
getUnit
(
valueRX
)
;
valueRX
=
(
isUnitless
(
valueRX
)
)
?
rx
:
parseFloat
(
valueRX
)
;
let
ratioRX
=
(
valueRX
/
rx
)
|
|
1
;
ry
=
ry
/
100
*
height
;
let
valueRY
=
this
.
coordUnits
.
ry
;
let
unitRY
=
getUnit
(
valueRY
)
;
valueRY
=
(
isUnitless
(
valueRY
)
)
?
ry
:
parseFloat
(
valueRY
)
;
let
ratioRY
=
(
valueRY
/
ry
)
|
|
1
;
this
[
_dragging
]
=
{
type
unitX
unitY
unitRX
unitRY
valueX
valueY
ratioX
ratioY
ratioRX
ratioRY
x
:
pageX
y
:
pageY
bb
:
this
.
boundingBox
}
;
}
_handleInsetTransformClick
(
pageX
pageY
type
)
{
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
pointsInfo
=
[
"
top
"
"
right
"
"
bottom
"
"
left
"
]
.
map
(
point
=
>
{
let
value
=
this
.
coordUnits
[
point
]
;
let
size
=
(
point
=
=
=
"
left
"
|
|
point
=
=
=
"
right
"
)
?
width
:
height
;
let
computedValue
=
this
.
coordinates
[
point
]
/
100
*
size
;
let
unit
=
getUnit
(
value
)
;
value
=
(
isUnitless
(
value
)
)
?
computedValue
:
parseFloat
(
value
)
;
let
ratio
=
(
value
/
computedValue
)
|
|
1
;
return
{
point
value
unit
ratio
}
;
}
)
;
this
[
_dragging
]
=
{
type
pointsInfo
x
:
pageX
y
:
pageY
bb
:
this
.
boundingBox
}
;
}
_handleTransformMove
(
pageX
pageY
)
{
let
{
type
pointsInfo
x
y
}
=
this
[
_dragging
]
;
if
(
type
=
=
=
"
translate
"
)
{
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
let
polygonDef
=
(
this
.
fillRule
)
?
{
this
.
fillRule
}
:
"
"
;
polygonDef
+
=
pointsInfo
.
map
(
(
{
unitX
unitY
valueX
valueY
ratioX
ratioY
}
)
=
>
{
let
deltaX
=
(
pageX
-
x
)
*
ratioX
;
let
deltaY
=
(
pageY
-
y
)
*
ratioY
;
let
newX
=
{
valueX
+
deltaX
}
{
unitX
}
;
let
newY
=
{
valueY
+
deltaY
}
{
unitY
}
;
return
{
newX
}
{
newY
}
;
}
)
.
join
(
"
"
)
;
polygonDef
=
(
this
.
geometryBox
)
?
polygon
(
{
polygonDef
}
)
{
this
.
geometryBox
}
:
polygon
(
{
polygonDef
}
)
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
polygonDef
"
important
"
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_handleCircleMove
(
"
center
"
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_handleEllipseMove
(
"
center
"
pageX
pageY
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
let
newCoords
=
{
}
;
pointsInfo
.
forEach
(
(
{
point
value
unit
ratio
}
)
=
>
{
let
delta
=
(
point
=
=
=
"
top
"
|
|
point
=
=
=
"
bottom
"
)
?
pageY
-
y
:
pageX
-
x
;
let
newCoord
=
(
point
=
=
=
"
top
"
|
|
point
=
=
=
"
left
"
)
?
{
value
+
delta
*
ratio
}
{
unit
}
:
{
value
-
delta
*
ratio
}
{
unit
}
;
newCoords
[
point
]
=
newCoord
;
}
)
;
let
{
top
right
bottom
left
}
=
newCoords
;
let
round
=
this
.
insetRound
;
let
insetDef
=
(
round
)
?
inset
(
{
top
}
{
right
}
{
bottom
}
{
left
}
round
{
round
}
)
:
inset
(
{
top
}
{
right
}
{
bottom
}
{
left
}
)
;
insetDef
+
=
(
this
.
geometryBox
)
?
this
.
geometryBox
:
"
"
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
insetDef
"
important
"
)
;
}
}
else
if
(
type
.
includes
(
"
scale
"
)
)
{
let
{
bb
}
=
this
[
_dragging
]
;
let
{
minX
minY
maxX
maxY
}
=
bb
;
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
transX
=
(
type
=
=
=
"
scale
-
se
"
|
|
type
=
=
=
"
scale
-
ne
"
)
?
minX
/
100
*
width
:
maxX
/
100
*
width
;
let
transY
=
(
type
=
=
=
"
scale
-
se
"
|
|
type
=
=
=
"
scale
-
sw
"
)
?
minY
/
100
*
height
:
maxY
/
100
*
height
;
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
x
y
)
;
let
{
percentX
:
percentPageX
percentY
:
percentPageY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
distanceX
=
(
type
=
=
=
"
scale
-
se
"
|
|
type
=
=
=
"
scale
-
ne
"
)
?
percentPageX
-
percentX
:
percentX
-
percentPageX
;
let
distanceY
=
(
type
=
=
=
"
scale
-
se
"
|
|
type
=
=
=
"
scale
-
sw
"
)
?
percentPageY
-
percentY
:
percentY
-
percentPageY
;
let
scaleX
=
1
+
distanceX
/
(
maxX
-
minX
)
;
let
scaleY
=
1
+
distanceY
/
(
maxY
-
minY
)
;
let
scale
=
(
scaleX
+
scaleY
)
/
2
;
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_scalePolygon
(
pageX
pageY
transX
transY
scale
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_scaleCircle
(
pageX
pageY
transX
transY
scale
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_scaleEllipse
(
pageX
pageY
transX
transY
scale
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
_scaleInset
(
pageX
pageY
transX
transY
scale
)
;
}
}
}
_scalePolygon
(
pageX
pageY
transX
transY
scale
)
{
let
{
pointsInfo
}
=
this
[
_dragging
]
;
let
polygonDef
=
(
this
.
fillRule
)
?
{
this
.
fillRule
}
:
"
"
;
polygonDef
+
=
pointsInfo
.
map
(
point
=
>
{
let
{
unitX
unitY
valueX
valueY
ratioX
ratioY
}
=
point
;
let
[
newX
newY
]
=
scalePoint
(
valueX
valueY
transX
*
ratioX
transY
*
ratioY
scale
)
;
return
{
newX
}
{
unitX
}
{
newY
}
{
unitY
}
;
}
)
.
join
(
"
"
)
;
polygonDef
=
(
this
.
geometryBox
)
?
polygon
(
{
polygonDef
}
)
{
this
.
geometryBox
}
:
polygon
(
{
polygonDef
}
)
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
polygonDef
"
important
"
)
;
}
_scaleCircle
(
pageX
pageY
transX
transY
scale
)
{
let
{
unitX
unitY
unitRad
valueX
valueY
ratioX
ratioY
ratioRad
}
=
this
[
_dragging
]
;
let
[
newCx
newCy
]
=
scalePoint
(
valueX
valueY
transX
*
ratioX
transY
*
ratioY
scale
)
;
let
newRadius
=
{
Math
.
abs
(
(
newCx
/
ratioX
-
transX
)
*
ratioRad
)
}
{
unitRad
}
;
let
circleDef
=
(
this
.
geometryBox
)
?
circle
(
{
newRadius
}
at
{
newCx
}
{
unitX
}
{
newCy
}
{
unitY
}
{
this
.
geometryBox
}
:
circle
(
{
newRadius
}
at
{
newCx
}
{
unitX
}
{
newCy
}
{
unitY
}
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
circleDef
"
important
"
)
;
}
_scaleEllipse
(
pageX
pageY
transX
transY
scale
)
{
let
{
unitX
unitY
unitRX
unitRY
valueX
valueY
ratioX
ratioY
ratioRX
ratioRY
}
=
this
[
_dragging
]
;
let
[
newCx
newCy
]
=
scalePoint
(
valueX
valueY
transX
*
ratioX
transY
*
ratioY
scale
)
;
let
newRx
=
{
Math
.
abs
(
(
newCx
/
ratioX
-
transX
)
*
ratioRX
)
}
{
unitRX
}
;
let
newRy
=
{
Math
.
abs
(
(
newCy
/
ratioY
-
transY
)
*
ratioRY
)
}
{
unitRY
}
;
newCx
=
{
newCx
}
{
unitX
}
;
newCy
=
{
newCy
}
{
unitY
}
;
let
ellipseDef
=
(
this
.
geometryBox
)
?
ellipse
(
{
newRx
}
{
newRy
}
at
{
newCx
}
{
newCy
}
)
{
this
.
geometryBox
}
:
ellipse
(
{
newRx
}
{
newRy
}
at
{
newCx
}
{
newCy
}
)
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
ellipseDef
"
important
"
)
;
}
_scaleInset
(
pageX
pageY
transX
transY
scale
)
{
let
{
pointsInfo
}
=
this
[
_dragging
]
;
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
newCoords
=
{
}
;
pointsInfo
.
forEach
(
(
{
point
value
unit
ratio
}
)
=
>
{
let
transValue
=
(
point
=
=
=
"
left
"
|
|
point
=
=
=
"
right
"
)
?
transX
*
ratio
:
transY
*
ratio
;
if
(
point
=
=
=
"
right
"
)
{
value
=
width
*
ratio
-
value
;
let
newPoint
=
(
value
-
transValue
)
*
scale
+
transValue
;
newPoint
=
width
*
ratio
-
newPoint
;
newCoords
[
point
]
=
{
newPoint
}
{
unit
}
;
}
else
if
(
point
=
=
=
"
bottom
"
)
{
value
=
height
*
ratio
-
value
;
let
newPoint
=
(
value
-
transValue
)
*
scale
+
transValue
;
newPoint
=
height
*
ratio
-
newPoint
;
newCoords
[
point
]
=
{
newPoint
}
{
unit
}
;
}
else
{
let
newPoint
=
(
value
-
transValue
)
*
scale
+
transValue
;
newCoords
[
point
]
=
{
newPoint
}
{
unit
}
;
}
}
)
;
let
{
top
right
bottom
left
}
=
newCoords
;
let
round
=
this
.
insetRound
;
let
insetDef
=
(
round
)
?
inset
(
{
top
}
{
right
}
{
bottom
}
{
left
}
round
{
round
}
)
:
inset
(
{
top
}
{
right
}
{
bottom
}
{
left
}
)
;
insetDef
+
=
(
this
.
geometryBox
)
?
this
.
geometryBox
:
"
"
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
insetDef
"
important
"
)
;
}
_handlePolygonClick
(
pageX
pageY
)
{
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
point
=
this
.
getPolygonPointAt
(
percentX
percentY
)
;
if
(
point
=
=
=
-
1
)
{
return
;
}
let
[
x
y
]
=
this
.
coordUnits
[
point
]
;
let
xComputed
=
this
.
coordinates
[
point
]
[
0
]
/
100
*
width
;
let
yComputed
=
this
.
coordinates
[
point
]
[
1
]
/
100
*
height
;
let
unitX
=
getUnit
(
x
)
;
let
unitY
=
getUnit
(
y
)
;
let
valueX
=
(
isUnitless
(
x
)
)
?
xComputed
:
parseFloat
(
x
)
;
let
valueY
=
(
isUnitless
(
y
)
)
?
yComputed
:
parseFloat
(
y
)
;
let
ratioX
=
(
valueX
/
xComputed
)
|
|
1
;
let
ratioY
=
(
valueY
/
yComputed
)
|
|
1
;
this
[
_dragging
]
=
{
point
unitX
unitY
valueX
valueY
ratioX
ratioY
x
:
pageX
y
:
pageY
}
;
}
_handlePolygonMove
(
pageX
pageY
)
{
let
{
point
unitX
unitY
valueX
valueY
ratioX
ratioY
x
y
}
=
this
[
_dragging
]
;
let
deltaX
=
(
pageX
-
x
)
*
ratioX
;
let
deltaY
=
(
pageY
-
y
)
*
ratioY
;
let
newX
=
{
valueX
+
deltaX
}
{
unitX
}
;
let
newY
=
{
valueY
+
deltaY
}
{
unitY
}
;
let
polygonDef
=
(
this
.
fillRule
)
?
{
this
.
fillRule
}
:
"
"
;
polygonDef
+
=
this
.
coordUnits
.
map
(
(
coords
i
)
=
>
{
return
(
i
=
=
=
point
)
?
{
newX
}
{
newY
}
:
{
coords
[
0
]
}
{
coords
[
1
]
}
;
}
)
.
join
(
"
"
)
;
polygonDef
=
(
this
.
geometryBox
)
?
polygon
(
{
polygonDef
}
)
{
this
.
geometryBox
}
:
polygon
(
{
polygonDef
}
)
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
polygonDef
"
important
"
)
;
}
_addPolygonPoint
(
after
x
y
)
{
let
polygonDef
=
(
this
.
fillRule
)
?
{
this
.
fillRule
}
:
"
"
;
polygonDef
+
=
this
.
coordUnits
.
map
(
(
coords
i
)
=
>
{
return
(
i
=
=
=
after
)
?
{
coords
[
0
]
}
{
coords
[
1
]
}
{
x
}
%
{
y
}
%
:
{
coords
[
0
]
}
{
coords
[
1
]
}
;
}
)
.
join
(
"
"
)
;
polygonDef
=
(
this
.
geometryBox
)
?
polygon
(
{
polygonDef
}
)
{
this
.
geometryBox
}
:
polygon
(
{
polygonDef
}
)
;
this
.
hoveredPoint
=
after
+
1
;
this
.
_emitHoverEvent
(
this
.
hoveredPoint
)
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
polygonDef
"
important
"
)
;
}
_deletePolygonPoint
(
point
)
{
let
coordinates
=
this
.
coordUnits
.
slice
(
)
;
coordinates
.
splice
(
point
1
)
;
let
polygonDef
=
(
this
.
fillRule
)
?
{
this
.
fillRule
}
:
"
"
;
polygonDef
+
=
coordinates
.
map
(
(
coords
i
)
=
>
{
return
{
coords
[
0
]
}
{
coords
[
1
]
}
;
}
)
.
join
(
"
"
)
;
polygonDef
=
(
this
.
geometryBox
)
?
polygon
(
{
polygonDef
}
)
{
this
.
geometryBox
}
:
polygon
(
{
polygonDef
}
)
;
this
.
hoveredPoint
=
null
;
this
.
_emitHoverEvent
(
this
.
hoveredPoint
)
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
polygonDef
"
important
"
)
;
}
_handleCircleClick
(
pageX
pageY
)
{
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
point
=
this
.
getCirclePointAt
(
percentX
percentY
)
;
if
(
!
point
)
{
return
;
}
if
(
point
=
=
=
"
center
"
)
{
let
{
cx
cy
}
=
this
.
coordUnits
;
let
cxComputed
=
this
.
coordinates
.
cx
/
100
*
width
;
let
cyComputed
=
this
.
coordinates
.
cy
/
100
*
height
;
let
unitX
=
getUnit
(
cx
)
;
let
unitY
=
getUnit
(
cy
)
;
let
valueX
=
(
isUnitless
(
cx
)
)
?
cxComputed
:
parseFloat
(
cx
)
;
let
valueY
=
(
isUnitless
(
cy
)
)
?
cyComputed
:
parseFloat
(
cy
)
;
let
ratioX
=
(
valueX
/
cxComputed
)
|
|
1
;
let
ratioY
=
(
valueY
/
cyComputed
)
|
|
1
;
this
[
_dragging
]
=
{
point
unitX
unitY
valueX
valueY
ratioX
ratioY
x
:
pageX
y
:
pageY
}
;
}
else
if
(
point
=
=
=
"
radius
"
)
{
let
{
radius
}
=
this
.
coordinates
;
let
computedSize
=
Math
.
sqrt
(
(
width
*
*
2
)
+
(
height
*
*
2
)
)
/
Math
.
sqrt
(
2
)
;
radius
=
radius
/
100
*
computedSize
;
let
value
=
this
.
coordUnits
.
radius
;
let
unit
=
getUnit
(
value
)
;
value
=
(
isUnitless
(
value
)
)
?
radius
:
parseFloat
(
value
)
;
let
ratio
=
(
value
/
radius
)
|
|
1
;
this
[
_dragging
]
=
{
point
value
origRadius
:
radius
unit
ratio
}
;
}
}
_handleCircleMove
(
point
pageX
pageY
)
{
let
{
radius
cx
cy
}
=
this
.
coordUnits
;
if
(
point
=
=
=
"
center
"
)
{
let
{
unitX
unitY
valueX
valueY
ratioX
ratioY
x
y
}
=
this
[
_dragging
]
;
let
deltaX
=
(
pageX
-
x
)
*
ratioX
;
let
deltaY
=
(
pageY
-
y
)
*
ratioY
;
let
newCx
=
{
valueX
+
deltaX
}
{
unitX
}
;
let
newCy
=
{
valueY
+
deltaY
}
{
unitY
}
;
let
circleDef
=
(
this
.
geometryBox
)
?
circle
(
{
radius
}
at
{
newCx
}
{
newCy
}
)
{
this
.
geometryBox
}
:
circle
(
{
radius
}
at
{
newCx
}
{
newCy
}
)
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
circleDef
"
important
"
)
;
}
else
if
(
point
=
=
=
"
radius
"
)
{
let
{
value
unit
origRadius
ratio
}
=
this
[
_dragging
]
;
let
{
x
:
pageCx
y
:
pageCy
}
=
this
.
convertPercentToPageCoords
(
this
.
coordinates
.
cx
this
.
coordinates
.
cy
)
;
let
newRadiusPx
=
getDistance
(
pageCx
pageCy
pageX
pageY
)
;
let
delta
=
(
newRadiusPx
-
origRadius
)
*
ratio
;
let
newRadius
=
{
value
+
delta
}
{
unit
}
;
let
circleDef
=
(
this
.
geometryBox
)
?
circle
(
{
newRadius
}
at
{
cx
}
{
cy
}
{
this
.
geometryBox
}
:
circle
(
{
newRadius
}
at
{
cx
}
{
cy
}
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
circleDef
"
important
"
)
;
}
}
_handleEllipseClick
(
pageX
pageY
)
{
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
point
=
this
.
getEllipsePointAt
(
percentX
percentY
)
;
if
(
!
point
)
{
return
;
}
if
(
point
=
=
=
"
center
"
)
{
let
{
cx
cy
}
=
this
.
coordUnits
;
let
cxComputed
=
this
.
coordinates
.
cx
/
100
*
width
;
let
cyComputed
=
this
.
coordinates
.
cy
/
100
*
height
;
let
unitX
=
getUnit
(
cx
)
;
let
unitY
=
getUnit
(
cy
)
;
let
valueX
=
(
isUnitless
(
cx
)
)
?
cxComputed
:
parseFloat
(
cx
)
;
let
valueY
=
(
isUnitless
(
cy
)
)
?
cyComputed
:
parseFloat
(
cy
)
;
let
ratioX
=
(
valueX
/
cxComputed
)
|
|
1
;
let
ratioY
=
(
valueY
/
cyComputed
)
|
|
1
;
this
[
_dragging
]
=
{
point
unitX
unitY
valueX
valueY
ratioX
ratioY
x
:
pageX
y
:
pageY
}
;
}
else
if
(
point
=
=
=
"
rx
"
)
{
let
{
rx
}
=
this
.
coordinates
;
rx
=
rx
/
100
*
width
;
let
value
=
this
.
coordUnits
.
rx
;
let
unit
=
getUnit
(
value
)
;
value
=
(
isUnitless
(
value
)
)
?
rx
:
parseFloat
(
value
)
;
let
ratio
=
(
value
/
rx
)
|
|
1
;
this
[
_dragging
]
=
{
point
value
origRadius
:
rx
unit
ratio
}
;
}
else
if
(
point
=
=
=
"
ry
"
)
{
let
{
ry
}
=
this
.
coordinates
;
ry
=
ry
/
100
*
height
;
let
value
=
this
.
coordUnits
.
ry
;
let
unit
=
getUnit
(
value
)
;
value
=
(
isUnitless
(
value
)
)
?
ry
:
parseFloat
(
value
)
;
let
ratio
=
(
value
/
ry
)
|
|
1
;
this
[
_dragging
]
=
{
point
value
origRadius
:
ry
unit
ratio
}
;
}
}
_handleEllipseMove
(
point
pageX
pageY
)
{
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
{
rx
ry
cx
cy
}
=
this
.
coordUnits
;
if
(
point
=
=
=
"
center
"
)
{
let
{
unitX
unitY
valueX
valueY
ratioX
ratioY
x
y
}
=
this
[
_dragging
]
;
let
deltaX
=
(
pageX
-
x
)
*
ratioX
;
let
deltaY
=
(
pageY
-
y
)
*
ratioY
;
let
newCx
=
{
valueX
+
deltaX
}
{
unitX
}
;
let
newCy
=
{
valueY
+
deltaY
}
{
unitY
}
;
let
ellipseDef
=
(
this
.
geometryBox
)
?
ellipse
(
{
rx
}
{
ry
}
at
{
newCx
}
{
newCy
}
)
{
this
.
geometryBox
}
:
ellipse
(
{
rx
}
{
ry
}
at
{
newCx
}
{
newCy
}
)
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
ellipseDef
"
important
"
)
;
}
else
if
(
point
=
=
=
"
rx
"
)
{
let
{
value
unit
origRadius
ratio
}
=
this
[
_dragging
]
;
let
newRadiusPercent
=
Math
.
abs
(
percentX
-
this
.
coordinates
.
cx
)
;
let
{
width
}
=
this
.
zoomAdjustedDimensions
;
let
delta
=
(
(
newRadiusPercent
/
100
*
width
)
-
origRadius
)
*
ratio
;
let
newRadius
=
{
value
+
delta
}
{
unit
}
;
let
ellipseDef
=
(
this
.
geometryBox
)
?
ellipse
(
{
newRadius
}
{
ry
}
at
{
cx
}
{
cy
}
)
{
this
.
geometryBox
}
:
ellipse
(
{
newRadius
}
{
ry
}
at
{
cx
}
{
cy
}
)
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
ellipseDef
"
important
"
)
;
}
else
if
(
point
=
=
=
"
ry
"
)
{
let
{
value
unit
origRadius
ratio
}
=
this
[
_dragging
]
;
let
newRadiusPercent
=
Math
.
abs
(
percentY
-
this
.
coordinates
.
cy
)
;
let
{
height
}
=
this
.
zoomAdjustedDimensions
;
let
delta
=
(
(
newRadiusPercent
/
100
*
height
)
-
origRadius
)
*
ratio
;
let
newRadius
=
{
value
+
delta
}
{
unit
}
;
let
ellipseDef
=
(
this
.
geometryBox
)
?
ellipse
(
{
rx
}
{
newRadius
}
at
{
cx
}
{
cy
}
)
{
this
.
geometryBox
}
:
ellipse
(
{
rx
}
{
newRadius
}
at
{
cx
}
{
cy
}
)
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
ellipseDef
"
important
"
)
;
}
}
_handleInsetClick
(
pageX
pageY
)
{
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
let
point
=
this
.
getInsetPointAt
(
percentX
percentY
)
;
if
(
!
point
)
{
return
;
}
let
value
=
this
.
coordUnits
[
point
]
;
let
size
=
(
point
=
=
=
"
left
"
|
|
point
=
=
=
"
right
"
)
?
width
:
height
;
let
computedValue
=
this
.
coordinates
[
point
]
/
100
*
size
;
let
unit
=
getUnit
(
value
)
;
value
=
(
isUnitless
(
value
)
)
?
computedValue
:
parseFloat
(
value
)
;
let
ratio
=
(
value
/
computedValue
)
|
|
1
;
let
origValue
=
(
point
=
=
=
"
left
"
|
|
point
=
=
=
"
right
"
)
?
pageX
:
pageY
;
this
[
_dragging
]
=
{
point
value
origValue
unit
ratio
}
;
}
_handleInsetMove
(
point
pageX
pageY
)
{
let
{
top
left
right
bottom
}
=
this
.
coordUnits
;
let
round
=
this
.
insetRound
;
let
{
value
origValue
unit
ratio
}
=
this
[
_dragging
]
;
if
(
point
=
=
=
"
left
"
)
{
let
delta
=
(
pageX
-
origValue
)
*
ratio
;
left
=
{
value
+
delta
}
{
unit
}
;
}
else
if
(
point
=
=
=
"
right
"
)
{
let
delta
=
(
pageX
-
origValue
)
*
ratio
;
right
=
{
value
-
delta
}
{
unit
}
;
}
else
if
(
point
=
=
=
"
top
"
)
{
let
delta
=
(
pageY
-
origValue
)
*
ratio
;
top
=
{
value
+
delta
}
{
unit
}
;
}
else
if
(
point
=
=
=
"
bottom
"
)
{
let
delta
=
(
pageY
-
origValue
)
*
ratio
;
bottom
=
{
value
-
delta
}
{
unit
}
;
}
let
insetDef
=
(
round
)
?
inset
(
{
top
}
{
right
}
{
bottom
}
{
left
}
round
{
round
}
)
:
inset
(
{
top
}
{
right
}
{
bottom
}
{
left
}
)
;
insetDef
+
=
(
this
.
geometryBox
)
?
this
.
geometryBox
:
"
"
;
this
.
currentNode
.
style
.
setProperty
(
this
.
property
insetDef
"
important
"
)
;
}
_handleMouseMoveNotDragging
(
pageX
pageY
)
{
let
{
percentX
percentY
}
=
this
.
convertPageCoordsToPercent
(
pageX
pageY
)
;
if
(
this
.
transformMode
)
{
let
point
=
this
.
getTransformPointAt
(
percentX
percentY
)
;
this
.
hoveredPoint
=
point
;
this
.
_handleMarkerHover
(
point
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
let
point
=
this
.
getPolygonPointAt
(
percentX
percentY
)
;
let
oldHoveredPoint
=
this
.
hoveredPoint
;
this
.
hoveredPoint
=
(
point
!
=
=
-
1
)
?
point
:
null
;
if
(
this
.
hoveredPoint
!
=
=
oldHoveredPoint
)
{
this
.
_emitHoverEvent
(
this
.
hoveredPoint
)
;
}
this
.
_handleMarkerHover
(
point
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
let
point
=
this
.
getCirclePointAt
(
percentX
percentY
)
;
let
oldHoveredPoint
=
this
.
hoveredPoint
;
this
.
hoveredPoint
=
point
?
point
:
null
;
if
(
this
.
hoveredPoint
!
=
=
oldHoveredPoint
)
{
this
.
_emitHoverEvent
(
this
.
hoveredPoint
)
;
}
this
.
_handleMarkerHover
(
point
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
let
point
=
this
.
getEllipsePointAt
(
percentX
percentY
)
;
let
oldHoveredPoint
=
this
.
hoveredPoint
;
this
.
hoveredPoint
=
point
?
point
:
null
;
if
(
this
.
hoveredPoint
!
=
=
oldHoveredPoint
)
{
this
.
_emitHoverEvent
(
this
.
hoveredPoint
)
;
}
this
.
_handleMarkerHover
(
point
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
let
point
=
this
.
getInsetPointAt
(
percentX
percentY
)
;
let
oldHoveredPoint
=
this
.
hoveredPoint
;
this
.
hoveredPoint
=
point
?
point
:
null
;
if
(
this
.
hoveredPoint
!
=
=
oldHoveredPoint
)
{
this
.
_emitHoverEvent
(
this
.
hoveredPoint
)
;
}
this
.
_handleMarkerHover
(
point
)
;
}
}
_handleMarkerHover
(
point
)
{
this
.
getElement
(
"
marker
-
hover
"
)
.
setAttribute
(
"
hidden
"
true
)
;
if
(
point
=
=
=
null
|
|
point
=
=
=
undefined
)
{
return
;
}
if
(
this
.
transformMode
)
{
if
(
!
point
)
{
return
;
}
let
{
minX
minY
maxX
maxY
}
=
this
.
boundingBox
;
let
centerX
=
(
minX
+
maxX
)
/
2
;
let
centerY
=
(
minY
+
maxY
)
/
2
;
const
points
=
[
{
pointName
:
"
translate
"
x
:
centerX
y
:
centerY
}
{
pointName
:
"
scale
-
se
"
x
:
maxX
y
:
maxY
}
{
pointName
:
"
scale
-
ne
"
x
:
maxX
y
:
minY
}
{
pointName
:
"
scale
-
sw
"
x
:
minX
y
:
maxY
}
{
pointName
:
"
scale
-
nw
"
x
:
minX
y
:
minY
}
]
;
for
(
let
{
pointName
x
y
}
of
points
)
{
if
(
point
=
=
=
pointName
)
{
this
.
_drawHoverMarker
(
[
[
x
y
]
]
)
;
}
}
}
else
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
if
(
point
=
=
=
-
1
)
{
return
;
}
this
.
_drawHoverMarker
(
[
this
.
coordinates
[
point
]
]
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
let
{
cx
cy
rx
}
=
this
.
coordinates
;
if
(
point
=
=
=
"
radius
"
)
{
this
.
_drawHoverMarker
(
[
[
cx
+
rx
cy
]
]
)
;
}
else
if
(
point
=
=
=
"
center
"
)
{
this
.
_drawHoverMarker
(
[
[
cx
cy
]
]
)
;
}
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
if
(
point
=
=
=
"
center
"
)
{
let
{
cx
cy
}
=
this
.
coordinates
;
this
.
_drawHoverMarker
(
[
[
cx
cy
]
]
)
;
}
else
if
(
point
=
=
=
"
rx
"
)
{
let
{
cx
cy
rx
}
=
this
.
coordinates
;
this
.
_drawHoverMarker
(
[
[
cx
+
rx
cy
]
]
)
;
}
else
if
(
point
=
=
=
"
ry
"
)
{
let
{
cx
cy
ry
}
=
this
.
coordinates
;
this
.
_drawHoverMarker
(
[
[
cx
cy
+
ry
]
]
)
;
}
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
if
(
!
point
)
{
return
;
}
let
{
top
right
bottom
left
}
=
this
.
coordinates
;
let
centerX
=
(
left
+
(
100
-
right
)
)
/
2
;
let
centerY
=
(
top
+
(
100
-
bottom
)
)
/
2
;
let
points
=
point
.
split
(
"
"
)
;
let
coords
=
points
.
map
(
side
=
>
{
if
(
side
=
=
=
"
top
"
)
{
return
[
centerX
top
]
;
}
else
if
(
side
=
=
=
"
right
"
)
{
return
[
100
-
right
centerY
]
;
}
else
if
(
side
=
=
=
"
bottom
"
)
{
return
[
centerX
100
-
bottom
]
;
}
else
if
(
side
=
=
=
"
left
"
)
{
return
[
left
centerY
]
;
}
return
null
;
}
)
;
this
.
_drawHoverMarker
(
coords
)
;
}
}
_drawHoverMarker
(
points
)
{
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
path
=
points
.
map
(
(
[
x
y
]
)
=
>
{
return
getCirclePath
(
BASE_MARKER_SIZE
x
y
width
height
zoom
)
;
}
)
.
join
(
"
"
)
;
let
markerHover
=
this
.
getElement
(
"
marker
-
hover
"
)
;
markerHover
.
setAttribute
(
"
d
"
path
)
;
markerHover
.
removeAttribute
(
"
hidden
"
)
;
}
_emitHoverEvent
(
point
)
{
if
(
point
=
=
=
null
|
|
point
=
=
=
undefined
)
{
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
hover
-
off
"
}
)
;
}
else
{
this
.
emit
(
"
highlighter
-
event
"
{
type
:
"
shape
-
hover
-
on
"
point
:
point
.
toString
(
)
}
)
;
}
}
convertPageCoordsToPercent
(
pageX
pageY
)
{
let
dims
=
(
this
.
highlighterEnv
.
window
.
document
=
=
=
this
.
currentNode
.
ownerDocument
)
?
this
.
zoomAdjustedDimensions
:
this
.
frameDimensions
;
let
{
top
left
width
height
}
=
dims
;
pageX
-
=
left
;
pageY
-
=
top
;
let
percentX
=
pageX
*
100
/
width
;
let
percentY
=
pageY
*
100
/
height
;
return
{
percentX
percentY
}
;
}
convertPercentToPageCoords
(
x
y
)
{
let
{
top
left
width
height
}
=
this
.
zoomAdjustedDimensions
;
x
=
x
*
width
/
100
;
y
=
y
*
height
/
100
;
x
+
=
left
;
y
+
=
top
;
return
{
x
y
}
;
}
getTransformPointAt
(
pageX
pageY
)
{
let
{
minX
minY
maxX
maxY
}
=
this
.
boundingBox
;
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
clickRadiusX
=
BASE_MARKER_SIZE
/
zoom
*
100
/
width
;
let
clickRadiusY
=
BASE_MARKER_SIZE
/
zoom
*
100
/
height
;
let
centerX
=
(
minX
+
maxX
)
/
2
;
let
centerY
=
(
minY
+
maxY
)
/
2
;
const
points
=
[
{
point
:
"
translate
"
x
:
centerX
y
:
centerY
}
{
point
:
"
scale
-
se
"
x
:
maxX
y
:
maxY
}
{
point
:
"
scale
-
ne
"
x
:
maxX
y
:
minY
}
{
point
:
"
scale
-
sw
"
x
:
minX
y
:
maxY
}
{
point
:
"
scale
-
nw
"
x
:
minX
y
:
minY
}
]
;
for
(
let
{
point
x
y
}
of
points
)
{
if
(
pageX
>
=
x
-
clickRadiusX
&
&
pageX
<
=
x
+
clickRadiusX
&
&
pageY
>
=
y
-
clickRadiusY
&
&
pageY
<
=
y
+
clickRadiusY
)
{
return
point
;
}
}
return
"
"
;
}
getPolygonPointAt
(
pageX
pageY
)
{
let
{
coordinates
}
=
this
;
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
clickRadiusX
=
BASE_MARKER_SIZE
/
zoom
*
100
/
width
;
let
clickRadiusY
=
BASE_MARKER_SIZE
/
zoom
*
100
/
height
;
for
(
let
[
index
coord
]
of
coordinates
.
entries
(
)
)
{
let
[
x
y
]
=
coord
;
if
(
pageX
>
=
x
-
clickRadiusX
&
&
pageX
<
=
x
+
clickRadiusX
&
&
pageY
>
=
y
-
clickRadiusY
&
&
pageY
<
=
y
+
clickRadiusY
)
{
return
index
;
}
}
return
-
1
;
}
getPolygonClickedLine
(
pageX
pageY
)
{
let
{
coordinates
}
=
this
;
let
{
width
}
=
this
.
zoomAdjustedDimensions
;
let
clickWidth
=
LINE_CLICK_WIDTH
*
100
/
width
;
for
(
let
i
=
0
;
i
<
coordinates
.
length
;
i
+
+
)
{
let
[
x1
y1
]
=
coordinates
[
i
]
;
let
[
x2
y2
]
=
(
i
=
=
=
coordinates
.
length
-
1
)
?
coordinates
[
0
]
:
coordinates
[
i
+
1
]
;
let
distance
=
distanceToLine
(
x1
y1
x2
y2
pageX
pageY
)
;
if
(
distance
<
=
clickWidth
&
&
Math
.
min
(
x1
x2
)
-
clickWidth
<
=
pageX
&
&
pageX
<
=
Math
.
max
(
x1
x2
)
+
clickWidth
&
&
Math
.
min
(
y1
y2
)
-
clickWidth
<
=
pageY
&
&
pageY
<
=
Math
.
max
(
y1
y2
)
+
clickWidth
)
{
let
[
newX
newY
]
=
projection
(
x1
y1
x2
y2
pageX
pageY
)
;
this
.
_addPolygonPoint
(
i
newX
newY
)
;
return
;
}
}
}
getCirclePointAt
(
pageX
pageY
)
{
let
{
cx
cy
rx
ry
}
=
this
.
coordinates
;
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
clickRadiusX
=
BASE_MARKER_SIZE
/
zoom
*
100
/
width
;
let
clickRadiusY
=
BASE_MARKER_SIZE
/
zoom
*
100
/
height
;
if
(
clickedOnPoint
(
pageX
pageY
cx
cy
clickRadiusX
clickRadiusY
)
)
{
return
"
center
"
;
}
let
clickWidthX
=
LINE_CLICK_WIDTH
*
100
/
width
;
let
clickWidthY
=
LINE_CLICK_WIDTH
*
100
/
height
;
if
(
clickedOnEllipseEdge
(
pageX
pageY
cx
cy
rx
ry
clickWidthX
clickWidthY
)
|
|
clickedOnPoint
(
pageX
pageY
cx
+
rx
cy
clickRadiusX
clickRadiusY
)
)
{
return
"
radius
"
;
}
return
"
"
;
}
getEllipsePointAt
(
pageX
pageY
)
{
let
{
cx
cy
rx
ry
}
=
this
.
coordinates
;
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
clickRadiusX
=
BASE_MARKER_SIZE
/
zoom
*
100
/
width
;
let
clickRadiusY
=
BASE_MARKER_SIZE
/
zoom
*
100
/
height
;
if
(
clickedOnPoint
(
pageX
pageY
cx
cy
clickRadiusX
clickRadiusY
)
)
{
return
"
center
"
;
}
if
(
clickedOnPoint
(
pageX
pageY
cx
+
rx
cy
clickRadiusX
clickRadiusY
)
)
{
return
"
rx
"
;
}
if
(
clickedOnPoint
(
pageX
pageY
cx
cy
+
ry
clickRadiusX
clickRadiusY
)
)
{
return
"
ry
"
;
}
return
"
"
;
}
getInsetPointAt
(
pageX
pageY
)
{
let
{
top
left
right
bottom
}
=
this
.
coordinates
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
clickWidthX
=
LINE_CLICK_WIDTH
*
100
/
width
;
let
clickWidthY
=
LINE_CLICK_WIDTH
*
100
/
height
;
let
clickRadiusX
=
BASE_MARKER_SIZE
/
zoom
*
100
/
width
;
let
clickRadiusY
=
BASE_MARKER_SIZE
/
zoom
*
100
/
height
;
let
centerX
=
(
left
+
(
100
-
right
)
)
/
2
;
let
centerY
=
(
top
+
(
100
-
bottom
)
)
/
2
;
if
(
(
pageX
>
=
left
-
clickWidthX
&
&
pageX
<
=
left
+
clickWidthX
&
&
pageY
>
=
top
&
&
pageY
<
=
100
-
bottom
)
|
|
clickedOnPoint
(
pageX
pageY
left
centerY
clickRadiusX
clickRadiusY
)
)
{
return
"
left
"
;
}
if
(
(
pageX
>
=
100
-
right
-
clickWidthX
&
&
pageX
<
=
100
-
right
+
clickWidthX
&
&
pageY
>
=
top
&
&
pageY
<
=
100
-
bottom
)
|
|
clickedOnPoint
(
pageX
pageY
100
-
right
centerY
clickRadiusX
clickRadiusY
)
)
{
return
"
right
"
;
}
if
(
(
pageY
>
=
top
-
clickWidthY
&
&
pageY
<
=
top
+
clickWidthY
&
&
pageX
>
=
left
&
&
pageX
<
=
100
-
right
)
|
|
clickedOnPoint
(
pageX
pageY
centerX
top
clickRadiusX
clickRadiusY
)
)
{
return
"
top
"
;
}
if
(
(
pageY
>
=
100
-
bottom
-
clickWidthY
&
&
pageY
<
=
100
-
bottom
+
clickWidthY
&
&
pageX
>
=
left
&
&
pageX
<
=
100
-
right
)
|
|
clickedOnPoint
(
pageX
pageY
centerX
100
-
bottom
clickRadiusX
clickRadiusY
)
)
{
return
"
bottom
"
;
}
return
"
"
;
}
_parseCSSShapeValue
(
definition
)
{
const
shapeTypes
=
[
{
name
:
"
polygon
"
prefix
:
"
polygon
(
"
coordParser
:
this
.
polygonPoints
.
bind
(
this
)
}
{
name
:
"
circle
"
prefix
:
"
circle
(
"
coordParser
:
this
.
circlePoints
.
bind
(
this
)
}
{
name
:
"
ellipse
"
prefix
:
"
ellipse
(
"
coordParser
:
this
.
ellipsePoints
.
bind
(
this
)
}
{
name
:
"
inset
"
prefix
:
"
inset
(
"
coordParser
:
this
.
insetPoints
.
bind
(
this
)
}
]
;
const
geometryTypes
=
[
"
margin
"
"
border
"
"
padding
"
"
content
"
]
;
let
referenceBox
=
"
border
"
;
for
(
let
geometry
of
geometryTypes
)
{
if
(
definition
.
includes
(
geometry
)
)
{
referenceBox
=
geometry
;
}
}
this
.
referenceBox
=
referenceBox
;
this
.
useStrokeBox
=
definition
.
includes
(
"
stroke
-
box
"
)
;
this
.
geometryBox
=
definition
.
substring
(
definition
.
lastIndexOf
(
"
)
"
)
+
1
)
.
trim
(
)
;
for
(
let
{
name
prefix
coordParser
}
of
shapeTypes
)
{
if
(
definition
.
includes
(
prefix
)
)
{
definition
=
definition
.
substring
(
prefix
.
length
definition
.
lastIndexOf
(
"
)
"
)
)
;
return
{
shapeType
:
name
coordinates
:
coordParser
(
definition
)
}
;
}
}
return
null
;
}
polygonPoints
(
definition
)
{
this
.
coordUnits
=
this
.
polygonRawPoints
(
)
;
let
splitDef
=
definition
.
split
(
"
"
)
;
if
(
splitDef
[
0
]
=
=
=
"
evenodd
"
|
|
splitDef
[
0
]
=
=
=
"
nonzero
"
)
{
splitDef
.
shift
(
)
;
}
let
minX
=
Number
.
MAX_SAFE_INTEGER
;
let
minY
=
Number
.
MAX_SAFE_INTEGER
;
let
maxX
=
Number
.
MIN_SAFE_INTEGER
;
let
maxY
=
Number
.
MIN_SAFE_INTEGER
;
let
coordinates
=
splitDef
.
map
(
coords
=
>
{
let
[
x
y
]
=
splitCoords
(
coords
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
if
(
x
<
minX
)
{
minX
=
x
;
}
if
(
y
<
minY
)
{
minY
=
y
;
}
if
(
x
>
maxX
)
{
maxX
=
x
;
}
if
(
y
>
maxY
)
{
maxY
=
y
;
}
return
[
x
y
]
;
}
)
;
this
.
boundingBox
=
{
minX
minY
maxX
maxY
}
;
return
coordinates
;
}
polygonRawPoints
(
)
{
let
definition
=
getDefinedShapeProperties
(
this
.
currentNode
this
.
property
)
;
if
(
definition
=
=
=
this
.
rawDefinition
)
{
return
this
.
coordUnits
;
}
this
.
rawDefinition
=
definition
;
definition
=
definition
.
substring
(
8
definition
.
lastIndexOf
(
"
)
"
)
)
;
let
splitDef
=
definition
.
split
(
"
"
)
;
if
(
splitDef
[
0
]
.
includes
(
"
evenodd
"
)
|
|
splitDef
[
0
]
.
includes
(
"
nonzero
"
)
)
{
this
.
fillRule
=
splitDef
[
0
]
.
trim
(
)
;
splitDef
.
shift
(
)
;
}
else
{
this
.
fillRule
=
"
"
;
}
return
splitDef
.
map
(
coords
=
>
{
return
splitCoords
(
coords
)
.
map
(
coord
=
>
{
return
coord
.
replace
(
/
\
u00a0
/
g
"
"
)
;
}
)
;
}
)
;
}
circlePoints
(
definition
)
{
this
.
coordUnits
=
this
.
circleRawPoints
(
)
;
let
values
=
definition
.
split
(
"
at
"
)
;
let
radius
=
values
[
0
]
;
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
center
=
splitCoords
(
values
[
1
]
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
let
computedSize
=
Math
.
sqrt
(
(
width
*
*
2
)
+
(
height
*
*
2
)
)
/
Math
.
sqrt
(
2
)
;
if
(
radius
=
=
=
"
closest
-
side
"
)
{
radius
=
Math
.
min
(
center
[
0
]
center
[
1
]
100
-
center
[
0
]
100
-
center
[
1
]
)
;
}
else
if
(
radius
=
=
=
"
farthest
-
side
"
)
{
radius
=
Math
.
max
(
center
[
0
]
center
[
1
]
100
-
center
[
0
]
100
-
center
[
1
]
)
;
}
else
if
(
radius
.
includes
(
"
calc
(
"
)
)
{
radius
=
evalCalcExpression
(
radius
.
substring
(
5
radius
.
length
-
1
)
computedSize
)
;
}
else
{
radius
=
coordToPercent
(
radius
computedSize
)
;
}
let
ratioX
=
width
/
computedSize
;
let
ratioY
=
height
/
computedSize
;
let
radiusX
=
radius
/
ratioX
;
let
radiusY
=
radius
/
ratioY
;
this
.
boundingBox
=
{
minX
:
center
[
0
]
-
radiusX
maxX
:
center
[
0
]
+
radiusX
minY
:
center
[
1
]
-
radiusY
maxY
:
center
[
1
]
+
radiusY
}
;
return
{
radius
rx
:
radiusX
ry
:
radiusY
cx
:
center
[
0
]
cy
:
center
[
1
]
}
;
}
circleRawPoints
(
)
{
let
definition
=
getDefinedShapeProperties
(
this
.
currentNode
this
.
property
)
;
if
(
definition
=
=
=
this
.
rawDefinition
)
{
return
this
.
coordUnits
;
}
this
.
rawDefinition
=
definition
;
definition
=
definition
.
substring
(
7
definition
.
lastIndexOf
(
"
)
"
)
)
;
let
values
=
definition
.
split
(
"
at
"
)
;
let
[
cx
=
"
"
cy
=
"
"
]
=
(
values
[
1
]
)
?
splitCoords
(
values
[
1
]
)
.
map
(
coord
=
>
{
return
coord
.
replace
(
/
\
u00a0
/
g
"
"
)
;
}
)
:
[
]
;
let
radius
=
(
values
[
0
]
)
?
values
[
0
]
.
trim
(
)
:
"
closest
-
side
"
;
return
{
cx
cy
radius
}
;
}
ellipsePoints
(
definition
)
{
this
.
coordUnits
=
this
.
ellipseRawPoints
(
)
;
let
values
=
definition
.
split
(
"
at
"
)
;
let
center
=
splitCoords
(
values
[
1
]
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
let
radii
=
splitCoords
(
values
[
0
]
)
.
map
(
(
radius
i
)
=
>
{
if
(
radius
=
=
=
"
closest
-
side
"
)
{
return
i
%
2
=
=
=
0
?
Math
.
min
(
center
[
0
]
100
-
center
[
0
]
)
:
Math
.
min
(
center
[
1
]
100
-
center
[
1
]
)
;
}
else
if
(
radius
=
=
=
"
farthest
-
side
"
)
{
return
i
%
2
=
=
=
0
?
Math
.
max
(
center
[
0
]
100
-
center
[
0
]
)
:
Math
.
max
(
center
[
1
]
100
-
center
[
1
]
)
;
}
return
this
.
convertCoordsToPercent
(
radius
i
)
;
}
)
;
this
.
boundingBox
=
{
minX
:
center
[
0
]
-
radii
[
0
]
maxX
:
center
[
0
]
+
radii
[
0
]
minY
:
center
[
1
]
-
radii
[
1
]
maxY
:
center
[
1
]
+
radii
[
1
]
}
;
return
{
rx
:
radii
[
0
]
ry
:
radii
[
1
]
cx
:
center
[
0
]
cy
:
center
[
1
]
}
;
}
ellipseRawPoints
(
)
{
let
definition
=
getDefinedShapeProperties
(
this
.
currentNode
this
.
property
)
;
if
(
definition
=
=
=
this
.
rawDefinition
)
{
return
this
.
coordUnits
;
}
this
.
rawDefinition
=
definition
;
definition
=
definition
.
substring
(
8
definition
.
lastIndexOf
(
"
)
"
)
)
;
let
values
=
definition
.
split
(
"
at
"
)
;
let
[
rx
=
"
closest
-
side
"
ry
=
"
closest
-
side
"
]
=
(
values
[
0
]
)
?
splitCoords
(
values
[
0
]
)
.
map
(
coord
=
>
{
return
coord
.
replace
(
/
\
u00a0
/
g
"
"
)
;
}
)
:
[
]
;
let
[
cx
=
"
"
cy
=
"
"
]
=
(
values
[
1
]
)
?
splitCoords
(
values
[
1
]
)
.
map
(
coord
=
>
{
return
coord
.
replace
(
/
\
u00a0
/
g
"
"
)
;
}
)
:
[
]
;
return
{
rx
ry
cx
cy
}
;
}
insetPoints
(
definition
)
{
this
.
coordUnits
=
this
.
insetRawPoints
(
)
;
let
values
=
definition
.
split
(
"
round
"
)
;
let
offsets
=
splitCoords
(
values
[
0
]
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
let
top
left
=
0
;
let
{
width
:
right
height
:
bottom
}
=
this
.
currentDimensions
;
if
(
offsets
.
length
=
=
=
1
)
{
top
=
left
=
right
=
bottom
=
offsets
[
0
]
;
}
else
if
(
offsets
.
length
=
=
=
2
)
{
top
=
bottom
=
offsets
[
0
]
;
left
=
right
=
offsets
[
1
]
;
}
else
if
(
offsets
.
length
=
=
=
3
)
{
top
=
offsets
[
0
]
;
left
=
right
=
offsets
[
1
]
;
bottom
=
offsets
[
2
]
;
}
else
if
(
offsets
.
length
=
=
=
4
)
{
top
=
offsets
[
0
]
;
right
=
offsets
[
1
]
;
bottom
=
offsets
[
2
]
;
left
=
offsets
[
3
]
;
}
this
.
boundingBox
=
{
minX
:
left
maxX
:
100
-
right
minY
:
top
maxY
:
100
-
bottom
}
;
return
{
top
left
right
bottom
}
;
}
insetRawPoints
(
)
{
let
definition
=
getDefinedShapeProperties
(
this
.
currentNode
this
.
property
)
;
if
(
definition
=
=
=
this
.
rawDefinition
)
{
return
this
.
coordUnits
;
}
this
.
rawDefinition
=
definition
;
definition
=
definition
.
substring
(
6
definition
.
lastIndexOf
(
"
)
"
)
)
;
let
values
=
definition
.
split
(
"
round
"
)
;
this
.
insetRound
=
values
[
1
]
;
let
offsets
=
splitCoords
(
values
[
0
]
)
.
map
(
coord
=
>
{
return
coord
.
replace
(
/
\
u00a0
/
g
"
"
)
;
}
)
;
let
top
left
right
bottom
=
0
;
if
(
offsets
.
length
=
=
=
1
)
{
top
=
left
=
right
=
bottom
=
offsets
[
0
]
;
}
else
if
(
offsets
.
length
=
=
=
2
)
{
top
=
bottom
=
offsets
[
0
]
;
left
=
right
=
offsets
[
1
]
;
}
else
if
(
offsets
.
length
=
=
=
3
)
{
top
=
offsets
[
0
]
;
left
=
right
=
offsets
[
1
]
;
bottom
=
offsets
[
2
]
;
}
else
if
(
offsets
.
length
=
=
=
4
)
{
top
=
offsets
[
0
]
;
right
=
offsets
[
1
]
;
bottom
=
offsets
[
2
]
;
left
=
offsets
[
3
]
;
}
return
{
top
left
right
bottom
}
;
}
convertCoordsToPercent
(
coord
i
)
{
let
{
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
size
=
i
%
2
=
=
=
0
?
width
:
height
;
if
(
coord
.
includes
(
"
calc
(
"
)
)
{
return
evalCalcExpression
(
coord
.
substring
(
5
coord
.
length
-
1
)
size
)
;
}
return
coordToPercent
(
coord
size
)
;
}
destroy
(
)
{
let
{
pageListenerTarget
}
=
this
.
highlighterEnv
;
if
(
pageListenerTarget
)
{
DOM_EVENTS
.
forEach
(
type
=
>
pageListenerTarget
.
removeEventListener
(
type
this
)
)
;
}
super
.
destroy
(
this
)
;
this
.
markup
.
destroy
(
)
;
}
getElement
(
id
)
{
return
this
.
markup
.
getElement
(
this
.
ID_CLASS_PREFIX
+
id
)
;
}
areShapesHidden
(
)
{
return
this
.
getElement
(
"
ellipse
"
)
.
hasAttribute
(
"
hidden
"
)
&
&
this
.
getElement
(
"
polygon
"
)
.
hasAttribute
(
"
hidden
"
)
&
&
this
.
getElement
(
"
rect
"
)
.
hasAttribute
(
"
hidden
"
)
&
&
this
.
getElement
(
"
bounding
-
box
"
)
.
hasAttribute
(
"
hidden
"
)
;
}
_show
(
)
{
this
.
hoveredPoint
=
this
.
options
.
hoverPoint
;
this
.
transformMode
=
this
.
options
.
transformMode
;
return
this
.
_update
(
)
;
}
_hasMoved
(
)
{
let
hasMoved
=
AutoRefreshHighlighter
.
prototype
.
_hasMoved
.
call
(
this
)
;
let
oldShapeCoordinates
=
JSON
.
stringify
(
this
.
coordinates
)
;
if
(
this
.
options
.
mode
.
startsWith
(
"
css
"
)
)
{
let
property
=
shapeModeToCssPropertyName
(
this
.
options
.
mode
)
;
this
.
property
=
property
.
replace
(
/
(
[
a
-
z
]
[
A
-
Z
]
)
/
g
g
=
>
{
return
g
[
0
]
+
"
-
"
+
g
[
1
]
.
toLowerCase
(
)
;
}
)
;
let
style
=
getComputedStyle
(
this
.
currentNode
)
[
property
]
;
if
(
!
style
|
|
style
=
=
=
"
none
"
)
{
this
.
coordinates
=
[
]
;
this
.
shapeType
=
"
none
"
;
}
else
{
let
{
coordinates
shapeType
}
=
this
.
_parseCSSShapeValue
(
style
)
;
this
.
coordinates
=
coordinates
;
this
.
shapeType
=
shapeType
;
}
}
let
newShapeCoordinates
=
JSON
.
stringify
(
this
.
coordinates
)
;
return
hasMoved
|
|
oldShapeCoordinates
!
=
=
newShapeCoordinates
;
}
_hideShapes
(
)
{
this
.
getElement
(
"
ellipse
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
polygon
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
rect
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
bounding
-
box
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
markers
"
)
.
setAttribute
(
"
d
"
"
"
)
;
this
.
getElement
(
"
markers
-
outline
"
)
.
setAttribute
(
"
d
"
"
"
)
;
}
_update
(
)
{
setIgnoreLayoutChanges
(
true
)
;
let
root
=
this
.
getElement
(
"
root
"
)
;
root
.
setAttribute
(
"
hidden
"
true
)
;
let
{
top
left
width
height
}
=
this
.
zoomAdjustedDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
this
.
getElement
(
"
shape
-
container
"
)
.
setAttribute
(
"
style
"
top
:
{
top
}
px
;
left
:
{
left
}
px
;
width
:
{
width
}
px
;
height
:
{
height
}
px
;
)
;
this
.
_hideShapes
(
)
;
if
(
this
.
transformMode
&
&
this
.
shapeType
!
=
=
"
none
"
)
{
this
.
_updateTransformMode
(
width
height
zoom
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_updatePolygonShape
(
width
height
zoom
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_updateCircleShape
(
width
height
zoom
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_updateEllipseShape
(
width
height
zoom
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
_updateInsetShape
(
width
height
zoom
)
;
}
this
.
_handleMarkerHover
(
this
.
hoveredPoint
)
;
let
{
width
:
winWidth
height
:
winHeight
}
=
this
.
_winDimensions
;
root
.
removeAttribute
(
"
hidden
"
)
;
root
.
setAttribute
(
"
style
"
position
:
absolute
;
width
:
{
winWidth
}
px
;
height
:
{
winHeight
}
px
;
overflow
:
hidden
)
;
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
window
.
document
.
documentElement
)
;
return
true
;
}
_updateTransformMode
(
width
height
zoom
)
{
let
{
minX
minY
maxX
maxY
}
=
this
.
boundingBox
;
let
boundingBox
=
this
.
getElement
(
"
bounding
-
box
"
)
;
boundingBox
.
setAttribute
(
"
x
"
minX
)
;
boundingBox
.
setAttribute
(
"
y
"
minY
)
;
boundingBox
.
setAttribute
(
"
width
"
maxX
-
minX
)
;
boundingBox
.
setAttribute
(
"
height
"
maxY
-
minY
)
;
boundingBox
.
removeAttribute
(
"
hidden
"
)
;
let
centerX
=
(
minX
+
maxX
)
/
2
;
let
centerY
=
(
minY
+
maxY
)
/
2
;
let
markerPoints
=
[
[
centerX
centerY
]
[
minX
minY
]
[
maxX
minY
]
[
minX
maxY
]
[
maxX
maxY
]
]
;
this
.
_drawMarkers
(
markerPoints
width
height
zoom
)
;
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
let
points
=
this
.
coordinates
.
map
(
point
=
>
point
.
join
(
"
"
)
)
.
join
(
"
"
)
;
let
polygonEl
=
this
.
getElement
(
"
polygon
"
)
;
polygonEl
.
setAttribute
(
"
points
"
points
)
;
polygonEl
.
removeAttribute
(
"
hidden
"
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
|
|
this
.
shapeType
=
=
=
"
ellipse
"
)
{
let
{
rx
ry
cx
cy
}
=
this
.
coordinates
;
let
ellipseEl
=
this
.
getElement
(
"
ellipse
"
)
;
ellipseEl
.
setAttribute
(
"
rx
"
rx
)
;
ellipseEl
.
setAttribute
(
"
ry
"
ry
)
;
ellipseEl
.
setAttribute
(
"
cx
"
cx
)
;
ellipseEl
.
setAttribute
(
"
cy
"
cy
)
;
ellipseEl
.
removeAttribute
(
"
hidden
"
)
;
}
}
_updatePolygonShape
(
width
height
zoom
)
{
let
points
=
this
.
coordinates
.
map
(
point
=
>
point
.
join
(
"
"
)
)
.
join
(
"
"
)
;
let
polygonEl
=
this
.
getElement
(
"
polygon
"
)
;
polygonEl
.
setAttribute
(
"
points
"
points
)
;
polygonEl
.
removeAttribute
(
"
hidden
"
)
;
this
.
_drawMarkers
(
this
.
coordinates
width
height
zoom
)
;
}
_updateCircleShape
(
width
height
zoom
)
{
let
{
rx
ry
cx
cy
}
=
this
.
coordinates
;
let
ellipseEl
=
this
.
getElement
(
"
ellipse
"
)
;
ellipseEl
.
setAttribute
(
"
rx
"
rx
)
;
ellipseEl
.
setAttribute
(
"
ry
"
ry
)
;
ellipseEl
.
setAttribute
(
"
cx
"
cx
)
;
ellipseEl
.
setAttribute
(
"
cy
"
cy
)
;
ellipseEl
.
removeAttribute
(
"
hidden
"
)
;
this
.
_drawMarkers
(
[
[
cx
cy
]
[
cx
+
rx
cy
]
]
width
height
zoom
)
;
}
_updateEllipseShape
(
width
height
zoom
)
{
let
{
rx
ry
cx
cy
}
=
this
.
coordinates
;
let
ellipseEl
=
this
.
getElement
(
"
ellipse
"
)
;
ellipseEl
.
setAttribute
(
"
rx
"
rx
)
;
ellipseEl
.
setAttribute
(
"
ry
"
ry
)
;
ellipseEl
.
setAttribute
(
"
cx
"
cx
)
;
ellipseEl
.
setAttribute
(
"
cy
"
cy
)
;
ellipseEl
.
removeAttribute
(
"
hidden
"
)
;
let
markerCoords
=
[
[
cx
cy
]
[
cx
+
rx
cy
]
[
cx
cy
+
ry
]
]
;
this
.
_drawMarkers
(
markerCoords
width
height
zoom
)
;
}
_updateInsetShape
(
width
height
zoom
)
{
let
{
top
left
right
bottom
}
=
this
.
coordinates
;
let
rectEl
=
this
.
getElement
(
"
rect
"
)
;
rectEl
.
setAttribute
(
"
x
"
left
)
;
rectEl
.
setAttribute
(
"
y
"
top
)
;
rectEl
.
setAttribute
(
"
width
"
100
-
left
-
right
)
;
rectEl
.
setAttribute
(
"
height
"
100
-
top
-
bottom
)
;
rectEl
.
removeAttribute
(
"
hidden
"
)
;
let
centerX
=
(
left
+
(
100
-
right
)
)
/
2
;
let
centerY
=
(
top
+
(
100
-
bottom
)
)
/
2
;
let
markerCoords
=
[
[
centerX
top
]
[
100
-
right
centerY
]
[
centerX
100
-
bottom
]
[
left
centerY
]
]
;
this
.
_drawMarkers
(
markerCoords
width
height
zoom
)
;
}
_drawMarkers
(
coords
width
height
zoom
)
{
let
markers
=
coords
.
map
(
(
[
x
y
]
)
=
>
{
return
getCirclePath
(
BASE_MARKER_SIZE
x
y
width
height
zoom
)
;
}
)
.
join
(
"
"
)
;
let
outline
=
coords
.
map
(
(
[
x
y
]
)
=
>
{
return
getCirclePath
(
BASE_MARKER_SIZE
+
2
x
y
width
height
zoom
)
;
}
)
.
join
(
"
"
)
;
this
.
getElement
(
"
markers
"
)
.
setAttribute
(
"
d
"
markers
)
;
this
.
getElement
(
"
markers
-
outline
"
)
.
setAttribute
(
"
d
"
outline
)
;
}
_hide
(
)
{
setIgnoreLayoutChanges
(
true
)
;
this
.
_hideShapes
(
)
;
this
.
getElement
(
"
markers
"
)
.
setAttribute
(
"
d
"
"
"
)
;
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
window
.
document
.
documentElement
)
;
}
onPageHide
(
{
target
}
)
{
if
(
target
.
defaultView
=
=
=
this
.
win
)
{
this
.
hide
(
)
;
}
}
}
function
getDefinedShapeProperties
(
node
property
)
{
let
prop
=
"
"
;
if
(
!
node
)
{
return
prop
;
}
let
cssRules
=
getCSSStyleRules
(
node
)
;
for
(
let
i
=
0
;
i
<
cssRules
.
Count
(
)
;
i
+
+
)
{
let
rule
=
cssRules
.
GetElementAt
(
i
)
;
let
value
=
rule
.
style
.
getPropertyValue
(
property
)
;
if
(
value
&
&
value
!
=
=
"
auto
"
)
{
prop
=
value
;
}
}
if
(
node
.
style
)
{
let
value
=
node
.
style
.
getPropertyValue
(
property
)
;
if
(
value
&
&
value
!
=
=
"
auto
"
)
{
prop
=
value
;
}
}
return
prop
.
trim
(
)
;
}
function
splitCoords
(
coords
)
{
return
coords
.
trim
(
)
.
replace
(
/
[
\
+
\
-
\
*
\
/
]
/
g
match
=
>
{
return
\
u00a0
{
match
.
trim
(
)
}
\
u00a0
;
}
)
.
split
(
"
"
)
;
}
exports
.
splitCoords
=
splitCoords
;
function
coordToPercent
(
coord
size
)
{
if
(
coord
.
includes
(
"
%
"
)
)
{
return
parseFloat
(
coord
.
replace
(
"
%
"
"
"
)
)
;
}
else
if
(
coord
.
includes
(
"
px
"
)
)
{
let
px
=
parseFloat
(
coord
.
replace
(
"
px
"
"
"
)
)
;
return
px
*
100
/
size
;
}
return
0
;
}
exports
.
coordToPercent
=
coordToPercent
;
function
evalCalcExpression
(
expression
size
)
{
let
values
=
expression
.
split
(
"
+
"
)
.
map
(
v
=
>
v
.
trim
(
)
)
;
return
values
.
reduce
(
(
prev
curr
)
=
>
{
return
prev
+
coordToPercent
(
curr
size
)
;
}
0
)
;
}
exports
.
evalCalcExpression
=
evalCalcExpression
;
const
shapeModeToCssPropertyName
=
mode
=
>
{
let
property
=
mode
.
substring
(
3
)
;
return
property
.
substring
(
0
1
)
.
toLowerCase
(
)
+
property
.
substring
(
1
)
;
}
;
exports
.
shapeModeToCssPropertyName
=
shapeModeToCssPropertyName
;
const
getCirclePath
=
(
size
cx
cy
width
height
zoom
)
=
>
{
let
radius
=
size
*
(
100
/
Math
.
max
(
width
height
)
)
/
zoom
;
let
ratio
=
width
/
height
;
let
rx
=
(
ratio
>
1
)
?
radius
:
radius
/
ratio
;
let
ry
=
(
ratio
>
1
)
?
radius
*
ratio
:
radius
;
return
M
{
cx
-
rx
}
{
cy
}
a
{
rx
}
{
ry
}
0
1
0
{
rx
*
2
}
0
+
a
{
rx
}
{
ry
}
0
1
0
{
rx
*
-
2
}
0
;
}
;
exports
.
getCirclePath
=
getCirclePath
;
const
getObjectBoundingBox
=
(
top
left
width
height
node
)
=
>
{
let
strokeWidth
=
parseFloat
(
getComputedStyle
(
node
)
.
strokeWidth
)
;
let
delta
=
strokeWidth
/
2
;
let
tagName
=
node
.
tagName
;
if
(
tagName
!
=
=
"
rect
"
&
&
tagName
!
=
=
"
ellipse
"
&
&
tagName
!
=
=
"
circle
"
&
&
tagName
!
=
=
"
image
"
)
{
if
(
getComputedStyle
(
node
)
.
strokeLinejoin
=
=
=
"
miter
"
)
{
let
miter
=
getComputedStyle
(
node
)
.
strokeMiterlimit
;
if
(
miter
<
Math
.
SQRT2
)
{
delta
*
=
Math
.
SQRT2
;
}
else
{
delta
*
=
miter
;
}
}
else
{
delta
*
=
Math
.
SQRT2
;
}
}
return
{
top
:
top
+
delta
left
:
left
+
delta
width
:
width
-
2
*
delta
height
:
height
-
2
*
delta
}
;
}
;
const
getUnit
=
(
point
)
=
>
{
if
(
isUnitless
(
point
)
)
{
return
"
px
"
;
}
let
[
unit
]
=
point
.
match
(
/
[
^
\
d
]
+
/
)
|
|
[
"
px
"
]
;
return
unit
;
}
;
exports
.
getUnit
=
getUnit
;
const
isUnitless
=
(
point
)
=
>
{
return
!
point
|
|
!
point
.
match
(
/
[
^
\
d
]
+
/
)
|
|
parseFloat
(
point
)
=
=
=
0
|
|
point
.
includes
(
"
(
"
)
|
|
point
=
=
=
"
closest
-
side
"
|
|
point
=
=
=
"
farthest
-
side
"
;
}
;
exports
.
ShapesHighlighter
=
ShapesHighlighter
;
