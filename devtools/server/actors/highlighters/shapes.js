"
use
strict
"
;
const
{
CanvasFrameAnonymousContentHelper
createSVGNode
createNode
getComputedStyle
}
=
require
(
"
.
/
utils
/
markup
"
)
;
const
{
setIgnoreLayoutChanges
getCurrentZoom
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
{
AutoRefreshHighlighter
}
=
require
(
"
.
/
auto
-
refresh
"
)
;
const
BASE_MARKER_SIZE
=
10
;
class
ShapesHighlighter
extends
AutoRefreshHighlighter
{
constructor
(
highlighterEnv
)
{
super
(
highlighterEnv
)
;
this
.
ID_CLASS_PREFIX
=
"
shapes
-
"
;
this
.
referenceBox
=
"
border
"
;
this
.
useStrokeBox
=
false
;
this
.
markup
=
new
CanvasFrameAnonymousContentHelper
(
this
.
highlighterEnv
this
.
_buildMarkup
.
bind
(
this
)
)
;
}
_buildMarkup
(
)
{
let
container
=
createNode
(
this
.
win
{
attributes
:
{
"
class
"
:
"
highlighter
-
container
"
}
}
)
;
let
rootWrapper
=
createNode
(
this
.
win
{
parent
:
container
attributes
:
{
"
id
"
:
"
root
"
"
class
"
:
"
root
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
mainSvg
=
createSVGNode
(
this
.
win
{
nodeType
:
"
svg
"
parent
:
rootWrapper
attributes
:
{
"
id
"
:
"
shape
-
container
"
"
class
"
:
"
shape
-
container
"
"
viewBox
"
:
"
0
0
100
100
"
"
preserveAspectRatio
"
:
"
none
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
polygon
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
polygon
"
"
class
"
:
"
polygon
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
ellipse
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
ellipse
"
"
class
"
:
"
ellipse
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
rect
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
rect
"
"
class
"
:
"
rect
"
"
hidden
"
:
true
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
path
"
parent
:
mainSvg
attributes
:
{
"
id
"
:
"
markers
"
"
class
"
:
"
markers
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
return
container
;
}
get
currentDimensions
(
)
{
let
{
top
left
width
height
}
=
this
.
currentQuads
[
this
.
referenceBox
]
[
0
]
.
bounds
;
if
(
this
.
currentNode
.
getBBox
&
&
getComputedStyle
(
this
.
currentNode
)
.
stroke
!
=
=
"
none
"
&
&
!
this
.
useStrokeBox
)
{
return
getObjectBoundingBox
(
top
left
width
height
this
.
currentNode
)
;
}
return
{
top
left
width
height
}
;
}
_parseCSSShapeValue
(
definition
)
{
const
shapeTypes
=
[
{
name
:
"
polygon
"
prefix
:
"
polygon
(
"
coordParser
:
this
.
polygonPoints
.
bind
(
this
)
}
{
name
:
"
circle
"
prefix
:
"
circle
(
"
coordParser
:
this
.
circlePoints
.
bind
(
this
)
}
{
name
:
"
ellipse
"
prefix
:
"
ellipse
(
"
coordParser
:
this
.
ellipsePoints
.
bind
(
this
)
}
{
name
:
"
inset
"
prefix
:
"
inset
(
"
coordParser
:
this
.
insetPoints
.
bind
(
this
)
}
]
;
const
geometryTypes
=
[
"
margin
"
"
border
"
"
padding
"
"
content
"
]
;
let
referenceBox
=
"
border
"
;
for
(
let
geometry
of
geometryTypes
)
{
if
(
definition
.
includes
(
geometry
)
)
{
referenceBox
=
geometry
;
}
}
this
.
referenceBox
=
referenceBox
;
this
.
useStrokeBox
=
definition
.
includes
(
"
stroke
-
box
"
)
;
for
(
let
{
name
prefix
coordParser
}
of
shapeTypes
)
{
if
(
definition
.
includes
(
prefix
)
)
{
definition
=
definition
.
substring
(
prefix
.
length
definition
.
lastIndexOf
(
"
)
"
)
)
;
return
{
shapeType
:
name
coordinates
:
coordParser
(
definition
)
}
;
}
}
return
null
;
}
polygonPoints
(
definition
)
{
return
definition
.
split
(
"
"
)
.
map
(
coords
=
>
{
return
splitCoords
(
coords
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
}
)
;
}
circlePoints
(
definition
)
{
let
values
=
definition
.
split
(
"
at
"
)
;
let
radius
=
values
[
0
]
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
elemWidth
=
this
.
currentDimensions
.
width
/
zoom
;
let
elemHeight
=
this
.
currentDimensions
.
height
/
zoom
;
let
center
=
splitCoords
(
values
[
1
]
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
if
(
radius
=
=
=
"
closest
-
side
"
)
{
radius
=
Math
.
min
(
center
[
0
]
center
[
1
]
100
-
center
[
0
]
100
-
center
[
1
]
)
;
}
else
if
(
radius
=
=
=
"
farthest
-
side
"
)
{
radius
=
Math
.
max
(
center
[
0
]
center
[
1
]
100
-
center
[
0
]
100
-
center
[
1
]
)
;
}
else
{
radius
=
coordToPercent
(
radius
Math
.
max
(
elemWidth
elemHeight
)
)
;
}
let
computedSize
=
Math
.
sqrt
(
(
elemWidth
*
*
2
)
+
(
elemHeight
*
*
2
)
)
/
Math
.
sqrt
(
2
)
;
let
ratioX
=
elemWidth
/
computedSize
;
let
ratioY
=
elemHeight
/
computedSize
;
let
radiusX
=
radius
/
ratioX
;
let
radiusY
=
radius
/
ratioY
;
return
{
rx
:
radiusX
ry
:
radiusY
cx
:
center
[
0
]
cy
:
center
[
1
]
}
;
}
ellipsePoints
(
definition
)
{
let
values
=
definition
.
split
(
"
at
"
)
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
elemWidth
=
this
.
currentDimensions
.
width
/
zoom
;
let
elemHeight
=
this
.
currentDimensions
.
height
/
zoom
;
let
center
=
splitCoords
(
values
[
1
]
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
let
radii
=
values
[
0
]
.
trim
(
)
.
split
(
"
"
)
.
map
(
(
radius
i
)
=
>
{
let
size
=
i
%
2
=
=
=
0
?
elemWidth
:
elemHeight
;
if
(
radius
=
=
=
"
closest
-
side
"
)
{
return
i
%
2
=
=
=
0
?
Math
.
min
(
center
[
0
]
100
-
center
[
0
]
)
:
Math
.
min
(
center
[
1
]
100
-
center
[
1
]
)
;
}
else
if
(
radius
=
=
=
"
farthest
-
side
"
)
{
return
i
%
2
=
=
=
0
?
Math
.
max
(
center
[
0
]
100
-
center
[
0
]
)
:
Math
.
max
(
center
[
1
]
100
-
center
[
1
]
)
;
}
return
coordToPercent
(
radius
size
)
;
}
)
;
return
{
rx
:
radii
[
0
]
ry
:
radii
[
1
]
cx
:
center
[
0
]
cy
:
center
[
1
]
}
;
}
insetPoints
(
definition
)
{
let
values
=
definition
.
split
(
"
round
"
)
;
let
offsets
=
splitCoords
(
values
[
0
]
)
.
map
(
this
.
convertCoordsToPercent
.
bind
(
this
)
)
;
let
x
y
=
0
;
let
width
=
this
.
currentDimensions
.
width
;
let
height
=
this
.
currentDimensions
.
height
;
if
(
offsets
.
length
=
=
=
1
)
{
x
=
y
=
offsets
[
0
]
;
width
=
height
=
100
-
2
*
x
;
}
else
if
(
offsets
.
length
=
=
=
2
)
{
y
=
offsets
[
0
]
;
x
=
offsets
[
1
]
;
height
=
100
-
2
*
y
;
width
=
100
-
2
*
x
;
}
else
if
(
offsets
.
length
=
=
=
3
)
{
y
=
offsets
[
0
]
;
x
=
offsets
[
1
]
;
height
=
100
-
y
-
offsets
[
2
]
;
width
=
100
-
2
*
x
;
}
else
if
(
offsets
.
length
=
=
=
4
)
{
y
=
offsets
[
0
]
;
x
=
offsets
[
3
]
;
height
=
100
-
y
-
offsets
[
2
]
;
width
=
100
-
x
-
offsets
[
1
]
;
}
return
{
x
y
width
height
}
;
}
convertCoordsToPercent
(
coord
i
)
{
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
let
elemWidth
=
this
.
currentDimensions
.
width
/
zoom
;
let
elemHeight
=
this
.
currentDimensions
.
height
/
zoom
;
let
size
=
i
%
2
=
=
=
0
?
elemWidth
:
elemHeight
;
if
(
coord
.
includes
(
"
calc
(
"
)
)
{
return
evalCalcExpression
(
coord
.
substring
(
5
coord
.
length
-
1
)
size
)
;
}
return
coordToPercent
(
coord
size
)
;
}
destroy
(
)
{
AutoRefreshHighlighter
.
prototype
.
destroy
.
call
(
this
)
;
this
.
markup
.
destroy
(
)
;
}
getElement
(
id
)
{
return
this
.
markup
.
getElement
(
this
.
ID_CLASS_PREFIX
+
id
)
;
}
_show
(
)
{
return
this
.
_update
(
)
;
}
_hasMoved
(
)
{
let
hasMoved
=
AutoRefreshHighlighter
.
prototype
.
_hasMoved
.
call
(
this
)
;
let
oldShapeCoordinates
=
JSON
.
stringify
(
this
.
coordinates
)
;
if
(
this
.
options
.
mode
.
startsWith
(
"
css
"
)
)
{
let
property
=
shapeModeToCssPropertyName
(
this
.
options
.
mode
)
;
let
style
=
getComputedStyle
(
this
.
currentNode
)
[
property
]
;
if
(
!
style
|
|
style
=
=
=
"
none
"
)
{
this
.
coordinates
=
[
]
;
this
.
shapeType
=
"
none
"
;
}
else
{
let
{
coordinates
shapeType
}
=
this
.
_parseCSSShapeValue
(
style
)
;
this
.
coordinates
=
coordinates
;
this
.
shapeType
=
shapeType
;
}
}
let
newShapeCoordinates
=
JSON
.
stringify
(
this
.
coordinates
)
;
return
hasMoved
|
|
oldShapeCoordinates
!
=
=
newShapeCoordinates
;
}
_hideShapes
(
)
{
this
.
getElement
(
"
ellipse
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
polygon
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
rect
"
)
.
setAttribute
(
"
hidden
"
true
)
;
this
.
getElement
(
"
markers
"
)
.
setAttribute
(
"
d
"
"
"
)
;
}
_update
(
)
{
setIgnoreLayoutChanges
(
true
)
;
let
{
top
left
width
height
}
=
this
.
currentDimensions
;
let
zoom
=
getCurrentZoom
(
this
.
win
)
;
top
/
=
zoom
;
left
/
=
zoom
;
width
/
=
zoom
;
height
/
=
zoom
;
this
.
getElement
(
"
shape
-
container
"
)
.
setAttribute
(
"
style
"
top
:
{
top
}
px
;
left
:
{
left
}
px
;
width
:
{
width
}
px
;
height
:
{
height
}
px
;
)
;
this
.
_hideShapes
(
)
;
if
(
this
.
shapeType
=
=
=
"
polygon
"
)
{
this
.
_updatePolygonShape
(
width
height
zoom
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
circle
"
)
{
this
.
_updateCircleShape
(
width
height
zoom
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
ellipse
"
)
{
this
.
_updateEllipseShape
(
width
height
zoom
)
;
}
else
if
(
this
.
shapeType
=
=
=
"
inset
"
)
{
this
.
_updateInsetShape
(
)
;
}
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
window
.
document
.
documentElement
)
;
return
true
;
}
_updatePolygonShape
(
width
height
zoom
)
{
let
points
=
this
.
coordinates
.
map
(
point
=
>
point
.
join
(
"
"
)
)
.
join
(
"
"
)
;
let
polygonEl
=
this
.
getElement
(
"
polygon
"
)
;
polygonEl
.
setAttribute
(
"
points
"
points
)
;
polygonEl
.
removeAttribute
(
"
hidden
"
)
;
this
.
_drawMarkers
(
this
.
coordinates
width
height
zoom
)
;
}
_updateCircleShape
(
width
height
zoom
)
{
let
{
rx
ry
cx
cy
}
=
this
.
coordinates
;
let
ellipseEl
=
this
.
getElement
(
"
ellipse
"
)
;
ellipseEl
.
setAttribute
(
"
rx
"
rx
)
;
ellipseEl
.
setAttribute
(
"
ry
"
ry
)
;
ellipseEl
.
setAttribute
(
"
cx
"
cx
)
;
ellipseEl
.
setAttribute
(
"
cy
"
cy
)
;
ellipseEl
.
removeAttribute
(
"
hidden
"
)
;
this
.
_drawMarkers
(
[
[
cx
cy
]
]
width
height
zoom
)
;
}
_updateEllipseShape
(
width
height
zoom
)
{
let
{
rx
ry
cx
cy
}
=
this
.
coordinates
;
let
ellipseEl
=
this
.
getElement
(
"
ellipse
"
)
;
ellipseEl
.
setAttribute
(
"
rx
"
rx
)
;
ellipseEl
.
setAttribute
(
"
ry
"
ry
)
;
ellipseEl
.
setAttribute
(
"
cx
"
cx
)
;
ellipseEl
.
setAttribute
(
"
cy
"
cy
)
;
ellipseEl
.
removeAttribute
(
"
hidden
"
)
;
let
markerCoords
=
[
[
cx
cy
]
[
cx
+
rx
cy
]
[
cx
cy
+
ry
]
]
;
this
.
_drawMarkers
(
markerCoords
width
height
zoom
)
;
}
_updateInsetShape
(
)
{
let
rectEl
=
this
.
getElement
(
"
rect
"
)
;
rectEl
.
setAttribute
(
"
x
"
this
.
coordinates
.
x
)
;
rectEl
.
setAttribute
(
"
y
"
this
.
coordinates
.
y
)
;
rectEl
.
setAttribute
(
"
width
"
this
.
coordinates
.
width
)
;
rectEl
.
setAttribute
(
"
height
"
this
.
coordinates
.
height
)
;
rectEl
.
removeAttribute
(
"
hidden
"
)
;
}
_drawMarkers
(
coords
width
height
zoom
)
{
let
markers
=
coords
.
map
(
(
[
x
y
]
)
=
>
{
return
getCirclePath
(
x
y
width
height
zoom
)
;
}
)
.
join
(
"
"
)
;
this
.
getElement
(
"
markers
"
)
.
setAttribute
(
"
d
"
markers
)
;
}
_hide
(
)
{
setIgnoreLayoutChanges
(
true
)
;
this
.
_hideShapes
(
)
;
this
.
getElement
(
"
markers
"
)
.
setAttribute
(
"
d
"
"
"
)
;
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
window
.
document
.
documentElement
)
;
}
}
function
splitCoords
(
coords
)
{
return
coords
.
trim
(
)
.
replace
(
/
\
+
/
g
"
+
"
)
.
split
(
"
"
)
;
}
function
coordToPercent
(
coord
size
)
{
if
(
coord
.
includes
(
"
%
"
)
)
{
return
parseFloat
(
coord
.
replace
(
"
%
"
"
"
)
)
;
}
else
if
(
coord
.
includes
(
"
px
"
)
)
{
let
px
=
parseFloat
(
coord
.
replace
(
"
px
"
"
"
)
)
;
return
px
*
100
/
size
;
}
return
0
;
}
function
evalCalcExpression
(
expression
size
)
{
let
values
=
expression
.
split
(
"
+
"
)
.
map
(
v
=
>
v
.
trim
(
)
)
;
return
values
.
reduce
(
(
prev
curr
)
=
>
{
return
prev
+
coordToPercent
(
curr
size
)
;
}
0
)
;
}
const
shapeModeToCssPropertyName
=
mode
=
>
{
let
property
=
mode
.
substring
(
3
)
;
return
property
.
substring
(
0
1
)
.
toLowerCase
(
)
+
property
.
substring
(
1
)
;
}
;
const
getCirclePath
=
(
cx
cy
width
height
zoom
)
=
>
{
let
radius
=
BASE_MARKER_SIZE
*
(
100
/
Math
.
max
(
width
height
)
)
/
zoom
;
let
ratio
=
width
/
height
;
let
rx
=
(
ratio
>
1
)
?
radius
:
radius
/
ratio
;
let
ry
=
(
ratio
>
1
)
?
radius
*
ratio
:
radius
;
return
M
{
cx
-
rx
}
{
cy
}
a
{
rx
}
{
ry
}
0
1
0
{
rx
*
2
}
0
+
a
{
rx
}
{
ry
}
0
1
0
{
rx
*
-
2
}
0
;
}
;
const
getObjectBoundingBox
=
(
top
left
width
height
node
)
=
>
{
let
strokeWidth
=
parseFloat
(
getComputedStyle
(
node
)
.
strokeWidth
)
;
let
delta
=
strokeWidth
/
2
;
let
tagName
=
node
.
tagName
;
if
(
tagName
!
=
=
"
rect
"
&
&
tagName
!
=
=
"
ellipse
"
&
&
tagName
!
=
=
"
circle
"
&
&
tagName
!
=
=
"
image
"
)
{
if
(
getComputedStyle
(
node
)
.
strokeLinejoin
=
=
=
"
miter
"
)
{
let
miter
=
getComputedStyle
(
node
)
.
strokeMiterlimit
;
if
(
miter
<
Math
.
SQRT2
)
{
delta
*
=
Math
.
SQRT2
;
}
else
{
delta
*
=
miter
;
}
}
else
{
delta
*
=
Math
.
SQRT2
;
}
}
return
{
top
:
top
+
delta
left
:
left
+
delta
width
:
width
-
2
*
delta
height
:
height
-
2
*
delta
}
;
}
;
exports
.
ShapesHighlighter
=
ShapesHighlighter
;
exports
.
splitCoords
=
splitCoords
;
exports
.
coordToPercent
=
coordToPercent
;
exports
.
evalCalcExpression
=
evalCalcExpression
;
exports
.
shapeModeToCssPropertyName
=
shapeModeToCssPropertyName
;
exports
.
getCirclePath
=
getCirclePath
;
