"
use
strict
"
;
const
{
getCurrentZoom
getWindowDimensions
getViewportDimensions
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
layout
/
utils
.
js
"
)
;
const
lazyContainer
=
{
}
;
loader
.
lazyRequireGetter
(
lazyContainer
"
CssLogic
"
"
resource
:
/
/
devtools
/
server
/
actors
/
inspector
/
css
-
logic
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isDocumentReady
"
"
resource
:
/
/
devtools
/
server
/
actors
/
inspector
/
utils
.
js
"
true
)
;
exports
.
getComputedStyle
=
node
=
>
lazyContainer
.
CssLogic
.
getComputedStyle
(
node
)
;
exports
.
getBindingElementAndPseudo
=
node
=
>
lazyContainer
.
CssLogic
.
getBindingElementAndPseudo
(
node
)
;
exports
.
hasPseudoClassLock
=
(
.
.
.
args
)
=
>
InspectorUtils
.
hasPseudoClassLock
(
.
.
.
args
)
;
exports
.
addPseudoClassLock
=
(
.
.
.
args
)
=
>
InspectorUtils
.
addPseudoClassLock
(
.
.
.
args
)
;
exports
.
removePseudoClassLock
=
(
.
.
.
args
)
=
>
InspectorUtils
.
removePseudoClassLock
(
.
.
.
args
)
;
const
SVG_NS
=
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
STYLESHEET_URI
=
"
resource
:
/
/
devtools
-
highlighter
-
styles
/
highlighters
.
css
"
;
function
isXUL
(
window
)
{
return
window
.
document
.
documentElement
?
.
namespaceURI
=
=
=
XUL_NS
;
}
exports
.
isXUL
=
isXUL
;
function
isNodeValid
(
node
nodeType
=
Node
.
ELEMENT_NODE
)
{
if
(
!
node
|
|
Cu
.
isDeadWrapper
(
node
)
)
{
return
false
;
}
if
(
node
.
nodeType
!
=
=
nodeType
)
{
return
false
;
}
const
doc
=
node
.
nodeType
=
=
=
Node
.
DOCUMENT_NODE
?
node
:
node
.
ownerDocument
;
if
(
!
doc
|
|
!
doc
.
defaultView
)
{
return
false
;
}
if
(
!
node
.
isConnected
)
{
return
false
;
}
return
true
;
}
exports
.
isNodeValid
=
isNodeValid
;
class
CanvasFrameAnonymousContentHelper
{
constructor
(
highlighterEnv
nodeBuilder
{
waitForDocumentToLoad
=
true
}
=
{
}
)
{
this
.
#
highlighterEnv
=
highlighterEnv
;
this
.
#
nodeBuilder
=
nodeBuilder
;
this
.
#
waitForDocumentToLoad
=
!
!
waitForDocumentToLoad
;
this
.
#
highlighterEnv
.
on
(
"
window
-
ready
"
this
.
#
onWindowReady
)
;
}
#
content
;
#
initialized
;
#
highlighterEnv
;
#
nodeBuilder
;
#
waitForDocumentToLoad
;
#
listeners
=
new
Map
(
)
;
#
elements
=
new
Map
(
)
;
initialize
(
)
{
const
{
promise
:
onInitialized
resolve
}
=
Promise
.
withResolvers
(
)
;
this
.
#
initialized
=
resolve
;
const
doc
=
this
.
#
highlighterEnv
.
document
;
if
(
!
this
.
#
waitForDocumentToLoad
|
|
isDocumentReady
(
doc
)
|
|
doc
.
readyState
!
=
=
"
uninitialized
"
)
{
this
.
#
insert
(
)
;
}
return
onInitialized
;
}
destroy
(
)
{
this
.
#
remove
(
)
;
this
.
#
highlighterEnv
.
off
(
"
window
-
ready
"
this
.
#
onWindowReady
)
;
this
.
#
highlighterEnv
=
this
.
#
nodeBuilder
=
this
.
#
content
=
null
;
this
.
anonymousContentDocument
=
null
;
this
.
anonymousContentWindow
=
null
;
this
.
pageListenerTarget
=
null
;
this
.
#
removeAllListeners
(
)
;
this
.
#
elements
.
clear
(
)
;
}
async
#
insert
(
)
{
if
(
this
.
#
waitForDocumentToLoad
)
{
await
waitForContentLoaded
(
this
.
#
highlighterEnv
.
window
)
;
}
if
(
!
this
.
#
highlighterEnv
)
{
return
;
}
this
.
anonymousContentDocument
=
this
.
#
highlighterEnv
.
document
;
this
.
anonymousContentWindow
=
this
.
#
highlighterEnv
.
window
;
this
.
pageListenerTarget
=
this
.
#
highlighterEnv
.
pageListenerTarget
;
try
{
this
.
#
content
=
this
.
anonymousContentDocument
.
insertAnonymousContent
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
=
Cr
.
NS_ERROR_UNEXPECTED
&
&
this
.
anonymousContentDocument
.
readyState
=
=
=
"
interactive
"
)
{
await
new
Promise
(
resolve
=
>
{
this
.
anonymousContentDocument
.
addEventListener
(
"
readystatechange
"
resolve
{
once
:
true
}
)
;
}
)
;
this
.
#
content
=
this
.
anonymousContentDocument
.
insertAnonymousContent
(
)
;
}
else
{
throw
e
;
}
}
const
link
=
this
.
anonymousContentDocument
.
createElementNS
(
XHTML_NS
"
link
"
)
;
link
.
href
=
STYLESHEET_URI
;
link
.
rel
=
"
stylesheet
"
;
this
.
#
content
.
root
.
appendChild
(
link
)
;
this
.
#
content
.
root
.
appendChild
(
this
.
#
nodeBuilder
(
)
)
;
this
.
#
initialized
(
)
;
}
#
remove
(
)
{
try
{
this
.
anonymousContentDocument
.
removeAnonymousContent
(
this
.
#
content
)
;
}
catch
(
e
)
{
}
}
#
onWindowReady
=
(
{
isTopLevel
}
)
=
>
{
if
(
isTopLevel
)
{
this
.
#
removeAllListeners
(
)
;
this
.
#
elements
.
clear
(
)
;
this
.
#
insert
(
)
;
}
}
;
#
getNodeById
(
id
)
{
return
this
.
content
?
.
root
.
getElementById
(
id
)
;
}
getBoundingClientRect
(
id
)
{
const
node
=
this
.
#
getNodeById
(
id
)
;
if
(
!
node
)
{
return
null
;
}
return
node
.
getBoundingClientRect
(
)
;
}
getComputedStylePropertyValue
(
id
property
)
{
const
node
=
this
.
#
getNodeById
(
id
)
;
if
(
!
node
)
{
return
null
;
}
return
this
.
anonymousContentWindow
.
getComputedStyle
(
node
)
.
getPropertyValue
(
property
)
;
}
getTextContentForElement
(
id
)
{
return
this
.
#
getNodeById
(
id
)
?
.
textContent
;
}
setTextContentForElement
(
id
text
)
{
const
node
=
this
.
#
getNodeById
(
id
)
;
if
(
!
node
)
{
return
;
}
node
.
textContent
=
text
;
}
setAttributeForElement
(
id
name
value
)
{
this
.
#
getNodeById
(
id
)
?
.
setAttribute
(
name
value
)
;
}
getAttributeForElement
(
id
name
)
{
return
this
.
#
getNodeById
(
id
)
?
.
getAttribute
(
name
)
;
}
removeAttributeForElement
(
id
name
)
{
this
.
#
getNodeById
(
id
)
?
.
removeAttribute
(
name
)
;
}
hasAttributeForElement
(
id
name
)
{
return
typeof
this
.
getAttributeForElement
(
id
name
)
=
=
=
"
string
"
;
}
getCanvasContext
(
id
type
=
"
2d
"
)
{
return
this
.
#
getNodeById
(
id
)
?
.
getContext
(
type
)
;
}
addEventListenerForElement
(
id
type
handler
)
{
if
(
typeof
id
!
=
=
"
string
"
)
{
throw
new
Error
(
"
Expected
a
string
ID
in
addEventListenerForElement
but
"
+
"
got
:
"
+
id
)
;
}
if
(
!
this
.
#
listeners
.
has
(
type
)
)
{
const
target
=
this
.
pageListenerTarget
;
target
.
addEventListener
(
type
this
true
)
;
this
.
#
listeners
.
set
(
type
new
Map
(
)
)
;
}
const
listeners
=
this
.
#
listeners
.
get
(
type
)
;
listeners
.
set
(
id
handler
)
;
}
removeEventListenerForElement
(
id
type
)
{
const
listeners
=
this
.
#
listeners
.
get
(
type
)
;
if
(
!
listeners
)
{
return
;
}
listeners
.
delete
(
id
)
;
if
(
!
this
.
#
listeners
.
has
(
type
)
)
{
const
target
=
this
.
pageListenerTarget
;
target
.
removeEventListener
(
type
this
true
)
;
}
}
handleEvent
(
event
)
{
const
listeners
=
this
.
#
listeners
.
get
(
event
.
type
)
;
if
(
!
listeners
)
{
return
;
}
let
isPropagationStopped
=
false
;
const
eventProxy
=
new
Proxy
(
event
{
get
:
(
obj
name
)
=
>
{
if
(
name
=
=
=
"
originalTarget
"
)
{
return
null
;
}
else
if
(
name
=
=
=
"
stopPropagation
"
)
{
return
(
)
=
>
{
isPropagationStopped
=
true
;
}
;
}
return
obj
[
name
]
;
}
}
)
;
let
node
=
event
.
originalTarget
;
while
(
node
)
{
const
handler
=
listeners
.
get
(
node
.
id
)
;
if
(
handler
)
{
handler
(
eventProxy
node
.
id
)
;
if
(
isPropagationStopped
)
{
break
;
}
}
node
=
node
.
parentNode
;
}
}
#
removeAllListeners
(
)
{
if
(
this
.
pageListenerTarget
)
{
const
target
=
this
.
pageListenerTarget
;
for
(
const
[
type
]
of
this
.
#
listeners
)
{
target
.
removeEventListener
(
type
this
true
)
;
}
}
this
.
#
listeners
.
clear
(
)
;
}
getElement
(
id
)
{
if
(
this
.
#
elements
.
has
(
id
)
)
{
return
this
.
#
elements
.
get
(
id
)
;
}
const
element
=
{
getTextContent
:
(
)
=
>
this
.
getTextContentForElement
(
id
)
setTextContent
:
text
=
>
this
.
setTextContentForElement
(
id
text
)
setAttribute
:
(
name
val
)
=
>
this
.
setAttributeForElement
(
id
name
val
)
getAttribute
:
name
=
>
this
.
getAttributeForElement
(
id
name
)
removeAttribute
:
name
=
>
this
.
removeAttributeForElement
(
id
name
)
hasAttribute
:
name
=
>
this
.
hasAttributeForElement
(
id
name
)
getCanvasContext
:
type
=
>
this
.
getCanvasContext
(
id
type
)
addEventListener
:
(
type
handler
)
=
>
{
return
this
.
addEventListenerForElement
(
id
type
handler
)
;
}
removeEventListener
:
(
type
handler
)
=
>
{
return
this
.
removeEventListenerForElement
(
id
type
handler
)
;
}
computedStyle
:
{
getPropertyValue
:
property
=
>
this
.
getComputedStylePropertyValue
(
id
property
)
}
classList
:
this
.
#
getNodeById
(
id
)
?
.
classList
}
;
this
.
#
elements
.
set
(
id
element
)
;
return
element
;
}
get
content
(
)
{
if
(
!
this
.
#
content
|
|
Cu
.
isDeadWrapper
(
this
.
#
content
)
)
{
return
null
;
}
return
this
.
#
content
;
}
scaleRootElement
(
node
id
)
{
const
boundaryWindow
=
this
.
#
highlighterEnv
.
window
;
const
zoom
=
getCurrentZoom
(
node
)
;
const
root
=
this
.
#
getNodeById
(
id
)
;
root
.
style
.
display
=
"
none
"
;
node
.
offsetWidth
;
let
{
width
height
}
=
getWindowDimensions
(
boundaryWindow
)
;
let
value
=
"
"
;
if
(
zoom
!
=
=
1
)
{
value
=
transform
-
origin
:
top
left
;
transform
:
scale
(
{
1
/
zoom
}
)
;
;
width
*
=
zoom
;
height
*
=
zoom
;
}
value
+
=
position
:
absolute
;
width
:
{
width
}
px
;
height
:
{
height
}
px
;
overflow
:
hidden
;
;
root
.
style
=
value
;
}
createSVGNode
(
options
)
{
if
(
!
options
.
nodeType
)
{
options
.
nodeType
=
"
box
"
;
}
options
.
namespace
=
SVG_NS
;
return
this
.
createNode
(
options
)
;
}
createNode
(
options
)
{
const
type
=
options
.
nodeType
|
|
"
div
"
;
const
namespace
=
options
.
namespace
|
|
XHTML_NS
;
const
doc
=
this
.
anonymousContentDocument
;
const
node
=
doc
.
createElementNS
(
namespace
type
)
;
for
(
const
name
in
options
.
attributes
|
|
{
}
)
{
node
.
setAttribute
(
name
options
.
attributes
[
name
]
)
;
}
if
(
options
.
parent
)
{
options
.
parent
.
appendChild
(
node
)
;
}
if
(
options
.
text
)
{
node
.
append
(
options
.
text
)
;
}
return
node
;
}
}
exports
.
CanvasFrameAnonymousContentHelper
=
CanvasFrameAnonymousContentHelper
;
function
waitForContentLoaded
(
iframeOrWindow
)
{
let
loadEvent
=
"
DOMContentLoaded
"
;
if
(
iframeOrWindow
.
contentWindow
&
&
iframeOrWindow
.
ownerGlobal
!
=
=
iframeOrWindow
.
contentWindow
.
browsingContext
.
topChromeWindow
)
{
loadEvent
=
"
load
"
;
}
const
doc
=
iframeOrWindow
.
contentDocument
|
|
iframeOrWindow
.
document
;
if
(
isDocumentReady
(
doc
)
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
iframeOrWindow
.
addEventListener
(
loadEvent
resolve
{
once
:
true
}
)
;
}
)
;
}
function
moveInfobar
(
container
bounds
win
options
=
{
}
)
{
const
zoom
=
getCurrentZoom
(
win
)
;
const
viewport
=
getViewportDimensions
(
win
)
;
const
{
computedStyle
}
=
container
;
const
margin
=
2
;
const
arrowSize
=
parseFloat
(
computedStyle
.
getPropertyValue
(
"
-
-
highlighter
-
bubble
-
arrow
-
size
"
)
)
;
const
containerHeight
=
parseFloat
(
computedStyle
.
getPropertyValue
(
"
height
"
)
)
;
const
containerWidth
=
parseFloat
(
computedStyle
.
getPropertyValue
(
"
width
"
)
)
;
const
containerHalfWidth
=
containerWidth
/
2
;
const
viewportWidth
=
viewport
.
width
*
zoom
;
const
viewportHeight
=
viewport
.
height
*
zoom
;
let
{
pageXOffset
pageYOffset
}
=
win
;
pageYOffset
*
=
zoom
;
pageXOffset
*
=
zoom
;
const
topBoundary
=
margin
;
const
bottomBoundary
=
viewportHeight
-
containerHeight
-
margin
-
1
;
const
leftBoundary
=
containerHalfWidth
+
margin
;
const
rightBoundary
=
viewportWidth
-
containerHalfWidth
-
margin
;
let
top
=
bounds
.
y
-
containerHeight
-
arrowSize
;
const
bottom
=
bounds
.
bottom
+
margin
+
arrowSize
;
let
left
=
bounds
.
x
+
bounds
.
width
/
2
;
let
isOverlapTheNode
=
false
;
let
positionAttribute
=
"
top
"
;
let
position
=
"
absolute
"
;
const
canBePlacedOnTop
=
top
>
=
pageYOffset
;
const
canBePlacedOnBottom
=
bottomBoundary
+
pageYOffset
-
bottom
>
0
;
const
forcedOnTop
=
options
.
position
=
=
=
"
top
"
;
const
forcedOnBottom
=
options
.
position
=
=
=
"
bottom
"
;
if
(
(
!
canBePlacedOnTop
&
&
canBePlacedOnBottom
&
&
!
forcedOnTop
)
|
|
forcedOnBottom
)
{
top
=
bottom
;
positionAttribute
=
"
bottom
"
;
}
const
isOffscreenOnTop
=
top
<
topBoundary
+
pageYOffset
;
const
isOffscreenOnBottom
=
top
>
bottomBoundary
+
pageYOffset
;
const
isOffscreenOnLeft
=
left
<
leftBoundary
+
pageXOffset
;
const
isOffscreenOnRight
=
left
>
rightBoundary
+
pageXOffset
;
if
(
isOffscreenOnTop
)
{
top
=
topBoundary
;
isOverlapTheNode
=
true
;
}
else
if
(
isOffscreenOnBottom
)
{
top
=
bottomBoundary
;
isOverlapTheNode
=
true
;
}
else
if
(
isOffscreenOnLeft
|
|
isOffscreenOnRight
)
{
isOverlapTheNode
=
true
;
top
-
=
pageYOffset
;
}
if
(
isOverlapTheNode
)
{
left
=
Math
.
min
(
Math
.
max
(
leftBoundary
left
-
pageXOffset
)
rightBoundary
)
;
position
=
"
fixed
"
;
container
.
setAttribute
(
"
hide
-
arrow
"
"
true
"
)
;
}
else
{
position
=
"
absolute
"
;
container
.
removeAttribute
(
"
hide
-
arrow
"
)
;
}
container
.
setAttribute
(
"
style
"
position
:
{
position
}
;
transform
-
origin
:
0
0
;
transform
:
scale
(
{
1
/
zoom
}
)
translate
(
calc
(
{
left
}
px
-
50
%
)
{
top
}
px
)
)
;
container
.
setAttribute
(
"
position
"
positionAttribute
)
;
}
exports
.
moveInfobar
=
moveInfobar
;
