"
use
strict
"
;
const
{
extend
}
=
require
(
"
sdk
/
core
/
heritage
"
)
;
const
{
AutoRefreshHighlighter
}
=
require
(
"
.
/
auto
-
refresh
"
)
;
const
{
CanvasFrameAnonymousContentHelper
createNode
createSVGNode
moveInfobar
}
=
require
(
"
.
/
utils
/
markup
"
)
;
const
{
getCurrentZoom
setIgnoreLayoutChanges
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
CSS_GRID_ENABLED_PREF
=
"
layout
.
css
.
grid
.
enabled
"
;
const
ROWS
=
"
rows
"
;
const
COLUMNS
=
"
cols
"
;
const
GRID_LINES_PROPERTIES
=
{
"
edge
"
:
{
lineDash
:
[
0
0
]
strokeStyle
:
"
#
4B0082
"
}
"
explicit
"
:
{
lineDash
:
[
5
3
]
strokeStyle
:
"
#
8A2BE2
"
}
"
implicit
"
:
{
lineDash
:
[
2
2
]
strokeStyle
:
"
#
9370DB
"
}
}
;
const
GRID_GAP_PATTERN_WIDTH
=
14
;
const
GRID_GAP_PATTERN_HEIGHT
=
14
;
const
GRID_GAP_PATTERN_LINE_DASH
=
[
5
3
]
;
const
GRID_GAP_PATTERN_STROKE_STYLE
=
"
#
9370DB
"
;
const
gCachedGridPattern
=
new
Map
(
)
;
function
CssGridHighlighter
(
highlighterEnv
)
{
AutoRefreshHighlighter
.
call
(
this
highlighterEnv
)
;
this
.
markup
=
new
CanvasFrameAnonymousContentHelper
(
this
.
highlighterEnv
this
.
_buildMarkup
.
bind
(
this
)
)
;
}
CssGridHighlighter
.
prototype
=
extend
(
AutoRefreshHighlighter
.
prototype
{
typeName
:
"
CssGridHighlighter
"
ID_CLASS_PREFIX
:
"
css
-
grid
-
"
_buildMarkup
(
)
{
let
container
=
createNode
(
this
.
win
{
attributes
:
{
"
class
"
:
"
highlighter
-
container
"
}
}
)
;
createNode
(
this
.
win
{
parent
:
container
nodeType
:
"
canvas
"
attributes
:
{
"
id
"
:
"
canvas
"
"
class
"
:
"
canvas
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
svg
=
createSVGNode
(
this
.
win
{
nodeType
:
"
svg
"
parent
:
container
attributes
:
{
"
id
"
:
"
elements
"
"
width
"
:
"
100
%
"
"
height
"
:
"
100
%
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
regions
=
createSVGNode
(
this
.
win
{
nodeType
:
"
g
"
parent
:
svg
attributes
:
{
"
class
"
:
"
regions
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
path
"
parent
:
regions
attributes
:
{
"
class
"
:
"
areas
"
"
id
"
:
"
areas
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
infobarContainer
=
createNode
(
this
.
win
{
parent
:
container
attributes
:
{
"
class
"
:
"
infobar
-
container
"
"
id
"
:
"
infobar
-
container
"
"
position
"
:
"
top
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
infobar
=
createNode
(
this
.
win
{
parent
:
infobarContainer
attributes
:
{
"
class
"
:
"
infobar
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
textbox
=
createNode
(
this
.
win
{
parent
:
infobar
attributes
:
{
"
class
"
:
"
infobar
-
text
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
span
"
parent
:
textbox
attributes
:
{
"
class
"
:
"
infobar
-
areaname
"
"
id
"
:
"
infobar
-
areaname
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
span
"
parent
:
textbox
attributes
:
{
"
class
"
:
"
infobar
-
dimensions
"
"
id
"
:
"
infobar
-
dimensions
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
return
container
;
}
destroy
(
)
{
AutoRefreshHighlighter
.
prototype
.
destroy
.
call
(
this
)
;
this
.
markup
.
destroy
(
)
;
gCachedGridPattern
.
clear
(
)
;
}
getElement
(
id
)
{
return
this
.
markup
.
getElement
(
this
.
ID_CLASS_PREFIX
+
id
)
;
}
get
ctx
(
)
{
return
this
.
canvas
.
getCanvasContext
(
"
2d
"
)
;
}
get
canvas
(
)
{
return
this
.
getElement
(
"
canvas
"
)
;
}
getGridGapPattern
(
dimensionType
)
{
if
(
gCachedGridPattern
.
has
(
dimensionType
)
)
{
return
gCachedGridPattern
.
get
(
dimensionType
)
;
}
let
canvas
=
createNode
(
this
.
win
{
nodeType
:
"
canvas
"
}
)
;
canvas
.
width
=
GRID_GAP_PATTERN_WIDTH
;
canvas
.
height
=
GRID_GAP_PATTERN_HEIGHT
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
setLineDash
(
GRID_GAP_PATTERN_LINE_DASH
)
;
ctx
.
beginPath
(
)
;
ctx
.
translate
(
.
5
.
5
)
;
if
(
dimensionType
=
=
=
COLUMNS
)
{
ctx
.
moveTo
(
0
0
)
;
ctx
.
lineTo
(
GRID_GAP_PATTERN_WIDTH
GRID_GAP_PATTERN_HEIGHT
)
;
}
else
{
ctx
.
moveTo
(
GRID_GAP_PATTERN_WIDTH
0
)
;
ctx
.
lineTo
(
0
GRID_GAP_PATTERN_HEIGHT
)
;
}
ctx
.
strokeStyle
=
GRID_GAP_PATTERN_STROKE_STYLE
;
ctx
.
stroke
(
)
;
let
pattern
=
ctx
.
createPattern
(
canvas
"
repeat
"
)
;
gCachedGridPattern
.
set
(
dimensionType
pattern
)
;
return
pattern
;
}
_show
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
CSS_GRID_ENABLED_PREF
)
&
&
!
this
.
isGrid
(
)
)
{
this
.
hide
(
)
;
return
false
;
}
return
this
.
_update
(
)
;
}
showGridArea
(
areaName
)
{
this
.
renderGridArea
(
areaName
)
;
this
.
_showGridArea
(
)
;
}
showAllGridAreas
(
)
{
this
.
renderGridArea
(
)
;
this
.
_showGridArea
(
)
;
}
clearGridAreas
(
)
{
let
box
=
this
.
getElement
(
"
areas
"
)
;
box
.
setAttribute
(
"
d
"
"
"
)
;
}
isGrid
(
)
{
return
this
.
currentNode
.
getGridFragments
(
)
.
length
>
0
;
}
_hasMoved
(
)
{
let
hasMoved
=
AutoRefreshHighlighter
.
prototype
.
_hasMoved
.
call
(
this
)
;
let
oldGridData
=
stringifyGridFragments
(
this
.
gridData
)
;
this
.
gridData
=
this
.
currentNode
.
getGridFragments
(
)
;
let
newGridData
=
stringifyGridFragments
(
this
.
gridData
)
;
return
hasMoved
|
|
oldGridData
!
=
=
newGridData
;
}
_update
(
)
{
setIgnoreLayoutChanges
(
true
)
;
this
.
clearCanvas
(
)
;
this
.
clearGridAreas
(
)
;
for
(
let
i
=
0
;
i
<
this
.
gridData
.
length
;
i
+
+
)
{
let
fragment
=
this
.
gridData
[
i
]
;
let
quad
=
this
.
currentQuads
.
content
[
i
]
;
this
.
renderFragment
(
fragment
quad
)
;
}
if
(
this
.
options
.
showAllGridAreas
)
{
this
.
showAllGridAreas
(
)
;
}
else
if
(
this
.
options
.
showGridArea
)
{
this
.
showGridArea
(
this
.
options
.
showGridArea
)
;
}
this
.
_showGrid
(
)
;
setIgnoreLayoutChanges
(
false
this
.
currentNode
.
ownerDocument
.
documentElement
)
;
return
true
;
}
_updateInfobar
(
area
x1
x2
y1
y2
)
{
let
width
=
x2
-
x1
;
let
height
=
y2
-
y1
;
let
dim
=
parseFloat
(
width
.
toPrecision
(
6
)
)
+
"
\
u00D7
"
+
parseFloat
(
height
.
toPrecision
(
6
)
)
;
this
.
getElement
(
"
infobar
-
areaname
"
)
.
setTextContent
(
area
.
name
)
;
this
.
getElement
(
"
infobar
-
dimensions
"
)
.
setTextContent
(
dim
)
;
this
.
_moveInfobar
(
x1
x2
y1
y2
)
;
}
_moveInfobar
(
x1
x2
y1
y2
)
{
let
bounds
=
{
bottom
:
y2
height
:
y2
-
y1
left
:
x1
right
:
x2
top
:
y1
width
:
x2
-
x1
x
:
x1
y
:
y1
}
;
let
container
=
this
.
getElement
(
"
infobar
-
container
"
)
;
moveInfobar
(
container
bounds
this
.
win
)
;
}
clearCanvas
(
)
{
let
ratio
=
parseFloat
(
(
this
.
win
.
devicePixelRatio
|
|
1
)
.
toFixed
(
2
)
)
;
let
width
=
this
.
win
.
innerWidth
;
let
height
=
this
.
win
.
innerHeight
;
this
.
canvas
.
setAttribute
(
"
width
"
width
*
ratio
)
;
this
.
canvas
.
setAttribute
(
"
height
"
height
*
ratio
)
;
this
.
canvas
.
setAttribute
(
"
style
"
width
:
{
width
}
px
;
height
:
{
height
}
px
)
;
this
.
ctx
.
scale
(
ratio
ratio
)
;
this
.
ctx
.
clearRect
(
0
0
width
height
)
;
}
getFirstRowLinePos
(
fragment
)
{
return
fragment
.
rows
.
lines
[
0
]
.
start
;
}
getLastRowLinePos
(
fragment
)
{
return
fragment
.
rows
.
lines
[
fragment
.
rows
.
lines
.
length
-
1
]
.
start
;
}
getFirstColLinePos
(
fragment
)
{
return
fragment
.
cols
.
lines
[
0
]
.
start
;
}
getLastColLinePos
(
fragment
)
{
return
fragment
.
cols
.
lines
[
fragment
.
cols
.
lines
.
length
-
1
]
.
start
;
}
getLastEdgeLineIndex
(
tracks
)
{
let
trackIndex
=
tracks
.
length
-
1
;
while
(
trackIndex
>
=
0
&
&
tracks
[
trackIndex
]
.
type
!
=
"
explicit
"
)
{
trackIndex
-
-
;
}
return
trackIndex
+
1
;
}
renderFragment
(
fragment
quad
)
{
this
.
renderLines
(
fragment
.
cols
quad
COLUMNS
"
left
"
"
top
"
"
height
"
this
.
getFirstRowLinePos
(
fragment
)
this
.
getLastRowLinePos
(
fragment
)
)
;
this
.
renderLines
(
fragment
.
rows
quad
ROWS
"
top
"
"
left
"
"
width
"
this
.
getFirstColLinePos
(
fragment
)
this
.
getLastColLinePos
(
fragment
)
)
;
}
renderLines
(
gridDimension
{
bounds
}
dimensionType
mainSide
crossSide
mainSize
startPos
endPos
)
{
let
lineStartPos
=
(
bounds
[
crossSide
]
/
getCurrentZoom
(
this
.
win
)
)
+
startPos
;
let
lineEndPos
=
(
bounds
[
crossSide
]
/
getCurrentZoom
(
this
.
win
)
)
+
endPos
;
if
(
this
.
options
.
showInfiniteLines
)
{
lineStartPos
=
0
;
lineEndPos
=
parseInt
(
this
.
canvas
.
getAttribute
(
mainSize
)
10
)
;
}
let
lastEdgeLineIndex
=
this
.
getLastEdgeLineIndex
(
gridDimension
.
tracks
)
;
for
(
let
i
=
0
;
i
<
gridDimension
.
lines
.
length
;
i
+
+
)
{
let
line
=
gridDimension
.
lines
[
i
]
;
let
linePos
=
(
bounds
[
mainSide
]
/
getCurrentZoom
(
this
.
win
)
)
+
line
.
start
;
if
(
this
.
options
.
showGridLineNumbers
)
{
this
.
renderGridLineNumber
(
line
.
number
linePos
lineStartPos
dimensionType
)
;
}
if
(
i
=
=
0
|
|
i
=
=
lastEdgeLineIndex
)
{
this
.
renderLine
(
linePos
lineStartPos
lineEndPos
dimensionType
"
edge
"
)
;
}
else
{
this
.
renderLine
(
linePos
lineStartPos
lineEndPos
dimensionType
gridDimension
.
tracks
[
i
-
1
]
.
type
)
;
}
if
(
line
.
breadth
>
0
)
{
this
.
renderGridGap
(
linePos
lineStartPos
lineEndPos
line
.
breadth
dimensionType
)
;
this
.
renderLine
(
linePos
+
line
.
breadth
lineStartPos
lineEndPos
dimensionType
gridDimension
.
tracks
[
i
]
.
type
)
;
}
}
}
renderLine
(
linePos
startPos
endPos
dimensionType
lineType
)
{
this
.
ctx
.
save
(
)
;
this
.
ctx
.
setLineDash
(
GRID_LINES_PROPERTIES
[
lineType
]
.
lineDash
)
;
this
.
ctx
.
beginPath
(
)
;
this
.
ctx
.
translate
(
.
5
.
5
)
;
if
(
dimensionType
=
=
=
COLUMNS
)
{
this
.
ctx
.
moveTo
(
linePos
startPos
)
;
this
.
ctx
.
lineTo
(
linePos
endPos
)
;
}
else
{
this
.
ctx
.
moveTo
(
startPos
linePos
)
;
this
.
ctx
.
lineTo
(
endPos
linePos
)
;
}
this
.
ctx
.
strokeStyle
=
GRID_LINES_PROPERTIES
[
lineType
]
.
strokeStyle
;
this
.
ctx
.
stroke
(
)
;
this
.
ctx
.
restore
(
)
;
}
renderGridLineNumber
(
lineNumber
linePos
startPos
dimensionType
)
{
this
.
ctx
.
save
(
)
;
if
(
dimensionType
=
=
=
COLUMNS
)
{
this
.
ctx
.
fillText
(
lineNumber
linePos
startPos
)
;
}
else
{
let
textWidth
=
this
.
ctx
.
measureText
(
lineNumber
)
.
width
;
this
.
ctx
.
fillText
(
lineNumber
startPos
-
textWidth
linePos
)
;
}
this
.
ctx
.
restore
(
)
;
}
renderGridGap
(
linePos
startPos
endPos
breadth
dimensionType
)
{
this
.
ctx
.
save
(
)
;
this
.
ctx
.
fillStyle
=
this
.
getGridGapPattern
(
dimensionType
)
;
if
(
dimensionType
=
=
=
COLUMNS
)
{
this
.
ctx
.
fillRect
(
linePos
startPos
breadth
endPos
-
startPos
)
;
}
else
{
this
.
ctx
.
fillRect
(
startPos
linePos
endPos
-
startPos
breadth
)
;
}
this
.
ctx
.
restore
(
)
;
}
renderGridArea
(
areaName
)
{
let
paths
=
[
]
;
let
currentZoom
=
getCurrentZoom
(
this
.
win
)
;
for
(
let
i
=
0
;
i
<
this
.
gridData
.
length
;
i
+
+
)
{
let
fragment
=
this
.
gridData
[
i
]
;
let
{
bounds
}
=
this
.
currentQuads
.
content
[
i
]
;
for
(
let
area
of
fragment
.
areas
)
{
if
(
areaName
&
&
areaName
!
=
area
.
name
)
{
continue
;
}
let
rowStart
=
fragment
.
rows
.
lines
[
area
.
rowStart
-
1
]
;
let
rowEnd
=
fragment
.
rows
.
lines
[
area
.
rowEnd
-
1
]
;
let
columnStart
=
fragment
.
cols
.
lines
[
area
.
columnStart
-
1
]
;
let
columnEnd
=
fragment
.
cols
.
lines
[
area
.
columnEnd
-
1
]
;
let
x1
=
columnStart
.
start
+
columnStart
.
breadth
+
(
bounds
.
left
/
currentZoom
)
;
let
x2
=
columnEnd
.
start
+
(
bounds
.
left
/
currentZoom
)
;
let
y1
=
rowStart
.
start
+
rowStart
.
breadth
+
(
bounds
.
top
/
currentZoom
)
;
let
y2
=
rowEnd
.
start
+
(
bounds
.
top
/
currentZoom
)
;
let
path
=
"
M
"
+
x1
+
"
"
+
y1
+
"
"
+
"
L
"
+
x2
+
"
"
+
y1
+
"
"
+
"
L
"
+
x2
+
"
"
+
y2
+
"
"
+
"
L
"
+
x1
+
"
"
+
y2
;
paths
.
push
(
path
)
;
if
(
areaName
)
{
this
.
_updateInfobar
(
area
x1
x2
y1
y2
)
;
this
.
_showInfoBar
(
)
;
}
}
}
let
box
=
this
.
getElement
(
"
areas
"
)
;
box
.
setAttribute
(
"
d
"
paths
.
join
(
"
"
)
)
;
}
_hide
(
)
{
setIgnoreLayoutChanges
(
true
)
;
this
.
_hideGrid
(
)
;
this
.
_hideGridArea
(
)
;
this
.
_hideInfoBar
(
)
;
setIgnoreLayoutChanges
(
false
this
.
currentNode
.
ownerDocument
.
documentElement
)
;
}
_hideGrid
(
)
{
this
.
getElement
(
"
canvas
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
_showGrid
(
)
{
this
.
getElement
(
"
canvas
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
_hideGridArea
(
)
{
this
.
getElement
(
"
elements
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
_showGridArea
(
)
{
this
.
getElement
(
"
elements
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
_hideInfoBar
(
)
{
this
.
getElement
(
"
infobar
-
container
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
_showInfoBar
(
)
{
this
.
getElement
(
"
infobar
-
container
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
}
)
;
exports
.
CssGridHighlighter
=
CssGridHighlighter
;
function
stringifyGridFragments
(
fragments
=
[
]
)
{
return
JSON
.
stringify
(
fragments
.
map
(
getStringifiableFragment
)
)
;
}
function
getStringifiableFragment
(
fragment
)
{
return
{
cols
:
getStringifiableDimension
(
fragment
.
cols
)
rows
:
getStringifiableDimension
(
fragment
.
rows
)
}
;
}
function
getStringifiableDimension
(
dimension
)
{
return
{
lines
:
[
.
.
.
dimension
.
lines
]
.
map
(
getStringifiableLine
)
tracks
:
[
.
.
.
dimension
.
tracks
]
.
map
(
getStringifiableTrack
)
}
;
}
function
getStringifiableLine
(
{
breadth
number
start
names
}
)
{
return
{
breadth
number
start
names
}
;
}
function
getStringifiableTrack
(
{
breadth
start
state
type
}
)
{
return
{
breadth
start
state
type
}
;
}
