"
use
strict
"
;
const
{
AutoRefreshHighlighter
}
=
require
(
"
.
/
auto
-
refresh
"
)
;
const
{
CANVAS_SIZE
DEFAULT_COLOR
drawBubbleRect
drawLine
drawRect
drawRoundedRect
getBoundsFromPoints
getCurrentMatrix
getPathDescriptionFromPoints
getPointsFromDiagonal
updateCanvasElement
updateCanvasPosition
}
=
require
(
"
.
/
utils
/
canvas
"
)
;
const
{
CanvasFrameAnonymousContentHelper
createNode
createSVGNode
moveInfobar
}
=
require
(
"
.
/
utils
/
markup
"
)
;
const
{
apply
}
=
require
(
"
devtools
/
shared
/
layout
/
dom
-
matrix
-
2d
"
)
;
const
{
getCurrentZoom
getDisplayPixelRatio
setIgnoreLayoutChanges
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
{
stringifyGridFragments
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
css
-
grid
-
utils
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
LAYOUT_STRINGS_URI
=
"
devtools
/
client
/
locales
/
layout
.
properties
"
;
const
LAYOUT_L10N
=
new
LocalizationHelper
(
LAYOUT_STRINGS_URI
)
;
const
COLUMNS
=
"
cols
"
;
const
ROWS
=
"
rows
"
;
const
GRID_FONT_SIZE
=
10
;
const
GRID_FONT_FAMILY
=
"
sans
-
serif
"
;
const
GRID_AREA_NAME_FONT_SIZE
=
"
20
"
;
const
GRID_LINES_PROPERTIES
=
{
"
edge
"
:
{
lineDash
:
[
0
0
]
alpha
:
1
}
"
explicit
"
:
{
lineDash
:
[
5
3
]
alpha
:
0
.
75
}
"
implicit
"
:
{
lineDash
:
[
2
2
]
alpha
:
0
.
5
}
"
areaEdge
"
:
{
lineDash
:
[
0
0
]
alpha
:
1
lineWidth
:
3
}
}
;
const
GRID_GAP_PATTERN_WIDTH
=
14
;
const
GRID_GAP_PATTERN_HEIGHT
=
14
;
const
GRID_GAP_PATTERN_LINE_DASH
=
[
5
3
]
;
const
GRID_GAP_ALPHA
=
0
.
5
;
const
OFFSET_FROM_EDGE
=
25
;
const
gCachedGridPattern
=
new
Map
(
)
;
class
CssGridHighlighter
extends
AutoRefreshHighlighter
{
constructor
(
highlighterEnv
)
{
super
(
highlighterEnv
)
;
this
.
ID_CLASS_PREFIX
=
"
css
-
grid
-
"
;
this
.
markup
=
new
CanvasFrameAnonymousContentHelper
(
this
.
highlighterEnv
this
.
_buildMarkup
.
bind
(
this
)
)
;
this
.
onPageHide
=
this
.
onPageHide
.
bind
(
this
)
;
this
.
onWillNavigate
=
this
.
onWillNavigate
.
bind
(
this
)
;
this
.
highlighterEnv
.
on
(
"
will
-
navigate
"
this
.
onWillNavigate
)
;
let
{
pageListenerTarget
}
=
highlighterEnv
;
pageListenerTarget
.
addEventListener
(
"
pagehide
"
this
.
onPageHide
)
;
this
.
_canvasPosition
=
{
x
:
0
y
:
0
}
;
updateCanvasPosition
(
this
.
_canvasPosition
this
.
_scroll
this
.
win
this
.
_winDimensions
)
;
}
_buildMarkup
(
)
{
let
container
=
createNode
(
this
.
win
{
attributes
:
{
"
class
"
:
"
highlighter
-
container
"
}
}
)
;
let
root
=
createNode
(
this
.
win
{
parent
:
container
attributes
:
{
"
id
"
:
"
root
"
"
class
"
:
"
root
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
parent
:
root
nodeType
:
"
canvas
"
attributes
:
{
"
id
"
:
"
canvas
"
"
class
"
:
"
canvas
"
"
hidden
"
:
"
true
"
"
width
"
:
CANVAS_SIZE
"
height
"
:
CANVAS_SIZE
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
svg
=
createSVGNode
(
this
.
win
{
nodeType
:
"
svg
"
parent
:
root
attributes
:
{
"
id
"
:
"
elements
"
"
width
"
:
"
100
%
"
"
height
"
:
"
100
%
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
regions
=
createSVGNode
(
this
.
win
{
nodeType
:
"
g
"
parent
:
svg
attributes
:
{
"
class
"
:
"
regions
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
path
"
parent
:
regions
attributes
:
{
"
class
"
:
"
areas
"
"
id
"
:
"
areas
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createSVGNode
(
this
.
win
{
nodeType
:
"
path
"
parent
:
regions
attributes
:
{
"
class
"
:
"
cells
"
"
id
"
:
"
cells
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
areaInfobarContainer
=
createNode
(
this
.
win
{
parent
:
container
attributes
:
{
"
class
"
:
"
area
-
infobar
-
container
"
"
id
"
:
"
area
-
infobar
-
container
"
"
position
"
:
"
top
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
areaInfobar
=
createNode
(
this
.
win
{
parent
:
areaInfobarContainer
attributes
:
{
"
class
"
:
"
infobar
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
areaTextbox
=
createNode
(
this
.
win
{
parent
:
areaInfobar
attributes
:
{
"
class
"
:
"
infobar
-
text
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
span
"
parent
:
areaTextbox
attributes
:
{
"
class
"
:
"
area
-
infobar
-
name
"
"
id
"
:
"
area
-
infobar
-
name
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
span
"
parent
:
areaTextbox
attributes
:
{
"
class
"
:
"
area
-
infobar
-
dimensions
"
"
id
"
:
"
area
-
infobar
-
dimensions
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
cellInfobarContainer
=
createNode
(
this
.
win
{
parent
:
container
attributes
:
{
"
class
"
:
"
cell
-
infobar
-
container
"
"
id
"
:
"
cell
-
infobar
-
container
"
"
position
"
:
"
top
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
cellInfobar
=
createNode
(
this
.
win
{
parent
:
cellInfobarContainer
attributes
:
{
"
class
"
:
"
infobar
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
cellTextbox
=
createNode
(
this
.
win
{
parent
:
cellInfobar
attributes
:
{
"
class
"
:
"
infobar
-
text
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
span
"
parent
:
cellTextbox
attributes
:
{
"
class
"
:
"
cell
-
infobar
-
position
"
"
id
"
:
"
cell
-
infobar
-
position
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
span
"
parent
:
cellTextbox
attributes
:
{
"
class
"
:
"
cell
-
infobar
-
dimensions
"
"
id
"
:
"
cell
-
infobar
-
dimensions
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
lineInfobarContainer
=
createNode
(
this
.
win
{
parent
:
container
attributes
:
{
"
class
"
:
"
line
-
infobar
-
container
"
"
id
"
:
"
line
-
infobar
-
container
"
"
position
"
:
"
top
"
"
hidden
"
:
"
true
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
lineInfobar
=
createNode
(
this
.
win
{
parent
:
lineInfobarContainer
attributes
:
{
"
class
"
:
"
infobar
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
let
lineTextbox
=
createNode
(
this
.
win
{
parent
:
lineInfobar
attributes
:
{
"
class
"
:
"
infobar
-
text
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
span
"
parent
:
lineTextbox
attributes
:
{
"
class
"
:
"
line
-
infobar
-
number
"
"
id
"
:
"
line
-
infobar
-
number
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
createNode
(
this
.
win
{
nodeType
:
"
span
"
parent
:
lineTextbox
attributes
:
{
"
class
"
:
"
line
-
infobar
-
names
"
"
id
"
:
"
line
-
infobar
-
names
"
}
prefix
:
this
.
ID_CLASS_PREFIX
}
)
;
return
container
;
}
clearCache
(
)
{
gCachedGridPattern
.
clear
(
)
;
}
clearGridAreas
(
)
{
let
areas
=
this
.
getElement
(
"
areas
"
)
;
areas
.
setAttribute
(
"
d
"
"
"
)
;
}
clearGridCell
(
)
{
let
cells
=
this
.
getElement
(
"
cells
"
)
;
cells
.
setAttribute
(
"
d
"
"
"
)
;
}
destroy
(
)
{
let
{
highlighterEnv
}
=
this
;
highlighterEnv
.
off
(
"
will
-
navigate
"
this
.
onWillNavigate
)
;
let
{
pageListenerTarget
}
=
highlighterEnv
;
if
(
pageListenerTarget
)
{
pageListenerTarget
.
removeEventListener
(
"
pagehide
"
this
.
onPageHide
)
;
}
this
.
markup
.
destroy
(
)
;
this
.
clearCache
(
)
;
AutoRefreshHighlighter
.
prototype
.
destroy
.
call
(
this
)
;
}
get
canvas
(
)
{
return
this
.
getElement
(
"
canvas
"
)
;
}
get
color
(
)
{
return
this
.
options
.
color
|
|
DEFAULT_COLOR
;
}
get
ctx
(
)
{
return
this
.
canvas
.
getCanvasContext
(
"
2d
"
)
;
}
getElement
(
id
)
{
return
this
.
markup
.
getElement
(
this
.
ID_CLASS_PREFIX
+
id
)
;
}
getFirstColLinePos
(
fragment
)
{
return
fragment
.
cols
.
lines
[
0
]
.
start
;
}
getFirstRowLinePos
(
fragment
)
{
return
fragment
.
rows
.
lines
[
0
]
.
start
;
}
getGridGapPattern
(
devicePixelRatio
dimension
)
{
let
gridPatternMap
=
null
;
if
(
gCachedGridPattern
.
has
(
devicePixelRatio
)
)
{
gridPatternMap
=
gCachedGridPattern
.
get
(
devicePixelRatio
)
;
}
else
{
gridPatternMap
=
new
Map
(
)
;
}
if
(
gridPatternMap
.
has
(
dimension
)
)
{
return
gridPatternMap
.
get
(
dimension
)
;
}
let
canvas
=
createNode
(
this
.
win
{
nodeType
:
"
canvas
"
}
)
;
let
width
=
canvas
.
width
=
GRID_GAP_PATTERN_WIDTH
*
devicePixelRatio
;
let
height
=
canvas
.
height
=
GRID_GAP_PATTERN_HEIGHT
*
devicePixelRatio
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
save
(
)
;
ctx
.
setLineDash
(
GRID_GAP_PATTERN_LINE_DASH
)
;
ctx
.
beginPath
(
)
;
ctx
.
translate
(
.
5
.
5
)
;
if
(
dimension
=
=
=
COLUMNS
)
{
ctx
.
moveTo
(
0
0
)
;
ctx
.
lineTo
(
width
height
)
;
}
else
{
ctx
.
moveTo
(
width
0
)
;
ctx
.
lineTo
(
0
height
)
;
}
ctx
.
strokeStyle
=
this
.
color
;
ctx
.
globalAlpha
=
GRID_GAP_ALPHA
;
ctx
.
stroke
(
)
;
ctx
.
restore
(
)
;
let
pattern
=
ctx
.
createPattern
(
canvas
"
repeat
"
)
;
gridPatternMap
.
set
(
dimension
pattern
)
;
gCachedGridPattern
.
set
(
devicePixelRatio
gridPatternMap
)
;
return
pattern
;
}
getLastColLinePos
(
fragment
)
{
return
fragment
.
cols
.
lines
[
fragment
.
cols
.
lines
.
length
-
1
]
.
start
;
}
getLastEdgeLineIndex
(
tracks
)
{
let
trackIndex
=
tracks
.
length
-
1
;
while
(
trackIndex
>
=
0
&
&
tracks
[
trackIndex
]
.
type
!
=
"
explicit
"
)
{
trackIndex
-
-
;
}
return
trackIndex
+
1
;
}
getLastRowLinePos
(
fragment
)
{
return
fragment
.
rows
.
lines
[
fragment
.
rows
.
lines
.
length
-
1
]
.
start
;
}
_hasMoved
(
)
{
let
hasMoved
=
AutoRefreshHighlighter
.
prototype
.
_hasMoved
.
call
(
this
)
;
let
oldGridData
=
stringifyGridFragments
(
this
.
gridData
)
;
this
.
gridData
=
this
.
currentNode
.
getGridFragments
(
)
;
let
newGridData
=
stringifyGridFragments
(
this
.
gridData
)
;
return
hasMoved
|
|
oldGridData
!
=
=
newGridData
;
}
_hide
(
)
{
setIgnoreLayoutChanges
(
true
)
;
this
.
_hideGrid
(
)
;
this
.
_hideGridElements
(
)
;
this
.
_hideGridAreaInfoBar
(
)
;
this
.
_hideGridCellInfoBar
(
)
;
this
.
_hideGridLineInfoBar
(
)
;
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
document
.
documentElement
)
;
}
_hideGrid
(
)
{
this
.
getElement
(
"
canvas
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
_hideGridAreaInfoBar
(
)
{
this
.
getElement
(
"
area
-
infobar
-
container
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
_hideGridCellInfoBar
(
)
{
this
.
getElement
(
"
cell
-
infobar
-
container
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
_hideGridElements
(
)
{
this
.
getElement
(
"
elements
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
_hideGridLineInfoBar
(
)
{
this
.
getElement
(
"
line
-
infobar
-
container
"
)
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
isGrid
(
)
{
return
this
.
currentNode
.
getGridFragments
(
)
.
length
>
0
;
}
isValidFragment
(
fragment
)
{
return
fragment
.
cols
.
tracks
.
length
&
&
fragment
.
rows
.
tracks
.
length
;
}
_scrollUpdate
(
)
{
let
hasUpdated
=
updateCanvasPosition
(
this
.
_canvasPosition
this
.
_scroll
this
.
win
this
.
_winDimensions
)
;
if
(
hasUpdated
)
{
this
.
_update
(
)
;
}
}
_show
(
)
{
if
(
!
this
.
isGrid
(
)
)
{
this
.
hide
(
)
;
return
false
;
}
this
.
clearCache
(
)
;
this
.
_hide
(
)
;
return
this
.
_update
(
)
;
}
_showGrid
(
)
{
this
.
getElement
(
"
canvas
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
_showGridAreaInfoBar
(
)
{
this
.
getElement
(
"
area
-
infobar
-
container
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
_showGridCellInfoBar
(
)
{
this
.
getElement
(
"
cell
-
infobar
-
container
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
_showGridElements
(
)
{
this
.
getElement
(
"
elements
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
_showGridLineInfoBar
(
)
{
this
.
getElement
(
"
line
-
infobar
-
container
"
)
.
removeAttribute
(
"
hidden
"
)
;
}
showAllGridAreas
(
)
{
this
.
renderGridArea
(
)
;
}
showGridArea
(
areaName
)
{
this
.
renderGridArea
(
areaName
)
;
}
showGridCell
(
{
gridFragmentIndex
rowNumber
columnNumber
}
)
{
this
.
renderGridCell
(
gridFragmentIndex
rowNumber
columnNumber
)
;
}
showGridLineNames
(
{
gridFragmentIndex
lineNumber
type
}
)
{
this
.
renderGridLineNames
(
gridFragmentIndex
lineNumber
type
)
;
}
onPageHide
(
{
target
}
)
{
if
(
target
.
defaultView
=
=
=
this
.
win
)
{
this
.
hide
(
)
;
}
}
onWillNavigate
(
{
isTopLevel
}
)
{
this
.
clearCache
(
)
;
if
(
isTopLevel
)
{
this
.
hide
(
)
;
}
}
renderFragment
(
fragment
)
{
if
(
!
this
.
isValidFragment
(
fragment
)
)
{
return
;
}
this
.
renderLines
(
fragment
.
cols
COLUMNS
this
.
getFirstRowLinePos
(
fragment
)
this
.
getLastRowLinePos
(
fragment
)
)
;
this
.
renderLines
(
fragment
.
rows
ROWS
this
.
getFirstColLinePos
(
fragment
)
this
.
getLastColLinePos
(
fragment
)
)
;
if
(
this
.
options
.
showGridAreasOverlay
)
{
this
.
renderGridAreaOverlay
(
)
;
}
if
(
this
.
options
.
showGridLineNumbers
)
{
this
.
renderLineNumbers
(
fragment
.
cols
COLUMNS
this
.
getFirstRowLinePos
(
fragment
)
)
;
this
.
renderLineNumbers
(
fragment
.
rows
ROWS
this
.
getFirstColLinePos
(
fragment
)
)
;
this
.
renderNegativeLineNumbers
(
fragment
.
cols
COLUMNS
this
.
getLastRowLinePos
(
fragment
)
)
;
this
.
renderNegativeLineNumbers
(
fragment
.
rows
ROWS
this
.
getLastColLinePos
(
fragment
)
)
;
}
}
renderGridArea
(
areaName
)
{
let
{
devicePixelRatio
}
=
this
.
win
;
let
displayPixelRatio
=
getDisplayPixelRatio
(
this
.
win
)
;
let
paths
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
gridData
.
length
;
i
+
+
)
{
let
fragment
=
this
.
gridData
[
i
]
;
for
(
let
area
of
fragment
.
areas
)
{
if
(
areaName
&
&
areaName
!
=
area
.
name
)
{
continue
;
}
let
rowStart
=
fragment
.
rows
.
lines
[
area
.
rowStart
-
1
]
;
let
rowEnd
=
fragment
.
rows
.
lines
[
area
.
rowEnd
-
1
]
;
let
columnStart
=
fragment
.
cols
.
lines
[
area
.
columnStart
-
1
]
;
let
columnEnd
=
fragment
.
cols
.
lines
[
area
.
columnEnd
-
1
]
;
let
x1
=
columnStart
.
start
+
columnStart
.
breadth
;
let
y1
=
rowStart
.
start
+
rowStart
.
breadth
;
let
x2
=
columnEnd
.
start
;
let
y2
=
rowEnd
.
start
;
let
points
=
getPointsFromDiagonal
(
x1
y1
x2
y2
this
.
currentMatrix
)
;
let
svgPoints
=
points
.
map
(
point
=
>
(
{
x
:
Math
.
round
(
point
.
x
/
devicePixelRatio
)
y
:
Math
.
round
(
point
.
y
/
devicePixelRatio
)
}
)
)
;
let
bounds
=
getBoundsFromPoints
(
points
.
map
(
point
=
>
(
{
x
:
Math
.
round
(
point
.
x
/
displayPixelRatio
)
y
:
Math
.
round
(
point
.
y
/
displayPixelRatio
)
}
)
)
)
;
paths
.
push
(
getPathDescriptionFromPoints
(
svgPoints
)
)
;
if
(
areaName
)
{
this
.
_showGridAreaInfoBar
(
)
;
this
.
_updateGridAreaInfobar
(
area
bounds
)
;
}
}
}
let
areas
=
this
.
getElement
(
"
areas
"
)
;
areas
.
setAttribute
(
"
d
"
paths
.
join
(
"
"
)
)
;
}
renderGridAreaName
(
fragment
area
)
{
let
{
rowStart
rowEnd
columnStart
columnEnd
}
=
area
;
let
{
devicePixelRatio
}
=
this
.
win
;
let
displayPixelRatio
=
getDisplayPixelRatio
(
this
.
win
)
;
let
offset
=
(
displayPixelRatio
/
2
)
%
1
;
let
fontSize
=
GRID_AREA_NAME_FONT_SIZE
*
displayPixelRatio
;
let
canvasX
=
Math
.
round
(
this
.
_canvasPosition
.
x
*
devicePixelRatio
)
;
let
canvasY
=
Math
.
round
(
this
.
_canvasPosition
.
y
*
devicePixelRatio
)
;
this
.
ctx
.
save
(
)
;
this
.
ctx
.
translate
(
offset
-
canvasX
offset
-
canvasY
)
;
this
.
ctx
.
font
=
fontSize
+
"
px
"
+
GRID_FONT_FAMILY
;
this
.
ctx
.
strokeStyle
=
this
.
color
;
this
.
ctx
.
textAlign
=
"
center
"
;
this
.
ctx
.
textBaseline
=
"
middle
"
;
for
(
let
rowNumber
=
rowStart
;
rowNumber
<
rowEnd
;
rowNumber
+
+
)
{
for
(
let
columnNumber
=
columnStart
;
columnNumber
<
columnEnd
;
columnNumber
+
+
)
{
let
row
=
fragment
.
rows
.
tracks
[
rowNumber
-
1
]
;
let
column
=
fragment
.
cols
.
tracks
[
columnNumber
-
1
]
;
if
(
fontSize
>
(
column
.
breadth
*
displayPixelRatio
)
|
|
fontSize
>
(
row
.
breadth
*
displayPixelRatio
)
)
{
fontSize
=
Math
.
min
(
[
column
.
breadth
row
.
breadth
]
)
;
this
.
ctx
.
font
=
fontSize
+
"
px
"
+
GRID_FONT_FAMILY
;
}
let
textWidth
=
this
.
ctx
.
measureText
(
area
.
name
)
.
width
;
let
textHeight
=
this
.
ctx
.
measureText
(
"
m
"
)
.
width
;
let
padding
=
3
*
displayPixelRatio
;
let
boxWidth
=
textWidth
+
2
*
padding
;
let
boxHeight
=
textHeight
+
2
*
padding
;
let
x
=
column
.
start
+
column
.
breadth
/
2
;
let
y
=
row
.
start
+
row
.
breadth
/
2
;
[
x
y
]
=
apply
(
this
.
currentMatrix
[
x
y
]
)
;
let
rectXPos
=
x
-
boxWidth
/
2
;
let
rectYPos
=
y
-
boxHeight
/
2
;
this
.
ctx
.
lineWidth
=
1
*
displayPixelRatio
;
this
.
ctx
.
strokeStyle
=
this
.
color
;
this
.
ctx
.
fillStyle
=
"
white
"
;
let
radius
=
2
*
displayPixelRatio
;
drawRoundedRect
(
this
.
ctx
rectXPos
rectYPos
boxWidth
boxHeight
radius
)
;
this
.
ctx
.
fillStyle
=
this
.
color
;
this
.
ctx
.
fillText
(
area
.
name
x
y
+
padding
)
;
}
}
this
.
ctx
.
restore
(
)
;
}
renderGridAreaOverlay
(
)
{
let
padding
=
1
;
for
(
let
i
=
0
;
i
<
this
.
gridData
.
length
;
i
+
+
)
{
let
fragment
=
this
.
gridData
[
i
]
;
for
(
let
area
of
fragment
.
areas
)
{
let
{
rowStart
rowEnd
columnStart
columnEnd
type
}
=
area
;
if
(
type
=
=
=
"
implicit
"
)
{
continue
;
}
const
areaColStart
=
fragment
.
cols
.
lines
[
columnStart
-
1
]
;
const
areaColEnd
=
fragment
.
cols
.
lines
[
columnEnd
-
1
]
;
const
areaRowStart
=
fragment
.
rows
.
lines
[
rowStart
-
1
]
;
const
areaRowEnd
=
fragment
.
rows
.
lines
[
rowEnd
-
1
]
;
const
areaColStartLinePos
=
areaColStart
.
start
+
areaColStart
.
breadth
;
const
areaRowStartLinePos
=
areaRowStart
.
start
+
areaRowStart
.
breadth
;
this
.
renderLine
(
areaColStartLinePos
+
padding
areaRowStartLinePos
areaRowEnd
.
start
COLUMNS
"
areaEdge
"
)
;
this
.
renderLine
(
areaColEnd
.
start
-
padding
areaRowStartLinePos
areaRowEnd
.
start
COLUMNS
"
areaEdge
"
)
;
this
.
renderLine
(
areaRowStartLinePos
+
padding
areaColStartLinePos
areaColEnd
.
start
ROWS
"
areaEdge
"
)
;
this
.
renderLine
(
areaRowEnd
.
start
-
padding
areaColStartLinePos
areaColEnd
.
start
ROWS
"
areaEdge
"
)
;
this
.
renderGridAreaName
(
fragment
area
)
;
}
}
}
renderGridCell
(
gridFragmentIndex
rowNumber
columnNumber
)
{
let
fragment
=
this
.
gridData
[
gridFragmentIndex
]
;
if
(
!
fragment
)
{
return
;
}
let
row
=
fragment
.
rows
.
tracks
[
rowNumber
-
1
]
;
let
column
=
fragment
.
cols
.
tracks
[
columnNumber
-
1
]
;
if
(
!
row
|
|
!
column
)
{
return
;
}
let
x1
=
column
.
start
;
let
y1
=
row
.
start
;
let
x2
=
column
.
start
+
column
.
breadth
;
let
y2
=
row
.
start
+
row
.
breadth
;
let
{
devicePixelRatio
}
=
this
.
win
;
let
displayPixelRatio
=
getDisplayPixelRatio
(
this
.
win
)
;
let
points
=
getPointsFromDiagonal
(
x1
y1
x2
y2
this
.
currentMatrix
)
;
let
svgPoints
=
points
.
map
(
point
=
>
(
{
x
:
Math
.
round
(
point
.
x
/
devicePixelRatio
)
y
:
Math
.
round
(
point
.
y
/
devicePixelRatio
)
}
)
)
;
let
bounds
=
getBoundsFromPoints
(
points
.
map
(
point
=
>
(
{
x
:
Math
.
round
(
point
.
x
/
displayPixelRatio
)
y
:
Math
.
round
(
point
.
y
/
displayPixelRatio
)
}
)
)
)
;
let
cells
=
this
.
getElement
(
"
cells
"
)
;
cells
.
setAttribute
(
"
d
"
getPathDescriptionFromPoints
(
svgPoints
)
)
;
this
.
_showGridCellInfoBar
(
)
;
this
.
_updateGridCellInfobar
(
rowNumber
columnNumber
bounds
)
;
}
renderGridGap
(
linePos
startPos
endPos
breadth
dimensionType
)
{
let
{
devicePixelRatio
}
=
this
.
win
;
let
displayPixelRatio
=
getDisplayPixelRatio
(
this
.
win
)
;
let
offset
=
(
displayPixelRatio
/
2
)
%
1
;
let
canvasX
=
Math
.
round
(
this
.
_canvasPosition
.
x
*
devicePixelRatio
)
;
let
canvasY
=
Math
.
round
(
this
.
_canvasPosition
.
y
*
devicePixelRatio
)
;
linePos
=
Math
.
round
(
linePos
)
;
startPos
=
Math
.
round
(
startPos
)
;
breadth
=
Math
.
round
(
breadth
)
;
this
.
ctx
.
save
(
)
;
this
.
ctx
.
fillStyle
=
this
.
getGridGapPattern
(
devicePixelRatio
dimensionType
)
;
this
.
ctx
.
translate
(
offset
-
canvasX
offset
-
canvasY
)
;
if
(
dimensionType
=
=
=
COLUMNS
)
{
if
(
isFinite
(
endPos
)
)
{
endPos
=
Math
.
round
(
endPos
)
;
}
else
{
endPos
=
this
.
_winDimensions
.
height
;
startPos
=
-
endPos
;
}
drawRect
(
this
.
ctx
linePos
startPos
linePos
+
breadth
endPos
this
.
currentMatrix
)
;
}
else
{
if
(
isFinite
(
endPos
)
)
{
endPos
=
Math
.
round
(
endPos
)
;
}
else
{
endPos
=
this
.
_winDimensions
.
width
;
startPos
=
-
endPos
;
}
drawRect
(
this
.
ctx
startPos
linePos
endPos
linePos
+
breadth
this
.
currentMatrix
)
;
}
this
.
ctx
.
fill
(
)
;
this
.
ctx
.
restore
(
)
;
}
renderGridLineNames
(
gridFragmentIndex
lineNumber
dimensionType
)
{
let
fragment
=
this
.
gridData
[
gridFragmentIndex
]
;
if
(
!
fragment
|
|
!
lineNumber
|
|
!
dimensionType
)
{
return
;
}
const
{
names
}
=
fragment
[
dimensionType
]
.
lines
[
lineNumber
-
1
]
;
let
linePos
;
if
(
dimensionType
=
=
=
ROWS
)
{
linePos
=
fragment
.
rows
.
lines
[
lineNumber
-
1
]
;
}
else
if
(
dimensionType
=
=
=
COLUMNS
)
{
linePos
=
fragment
.
cols
.
lines
[
lineNumber
-
1
]
;
}
if
(
!
linePos
)
{
return
;
}
let
currentZoom
=
getCurrentZoom
(
this
.
win
)
;
let
{
bounds
}
=
this
.
currentQuads
.
content
[
gridFragmentIndex
]
;
const
rowYPosition
=
fragment
.
rows
.
lines
[
0
]
;
const
colXPosition
=
fragment
.
rows
.
lines
[
0
]
;
let
x
=
dimensionType
=
=
=
COLUMNS
?
linePos
.
start
+
(
bounds
.
left
/
currentZoom
)
:
colXPosition
.
start
+
(
bounds
.
left
/
currentZoom
)
;
let
y
=
dimensionType
=
=
=
ROWS
?
linePos
.
start
+
(
bounds
.
top
/
currentZoom
)
:
rowYPosition
.
start
+
(
bounds
.
top
/
currentZoom
)
;
this
.
_showGridLineInfoBar
(
)
;
this
.
_updateGridLineInfobar
(
names
.
join
(
"
"
)
lineNumber
x
y
)
;
}
renderGridLineNumber
(
lineNumber
linePos
startPos
breadth
dimensionType
stackedLineIndex
)
{
let
displayPixelRatio
=
getDisplayPixelRatio
(
this
.
win
)
;
let
{
devicePixelRatio
}
=
this
.
win
;
let
offset
=
(
displayPixelRatio
/
2
)
%
1
;
let
fontSize
=
GRID_FONT_SIZE
*
displayPixelRatio
;
let
canvasX
=
Math
.
round
(
this
.
_canvasPosition
.
x
*
devicePixelRatio
)
;
let
canvasY
=
Math
.
round
(
this
.
_canvasPosition
.
y
*
devicePixelRatio
)
;
linePos
=
Math
.
round
(
linePos
)
;
startPos
=
Math
.
round
(
startPos
)
;
breadth
=
Math
.
round
(
breadth
)
;
if
(
linePos
+
breadth
<
0
)
{
return
;
}
this
.
ctx
.
save
(
)
;
this
.
ctx
.
translate
(
offset
-
canvasX
offset
-
canvasY
)
;
this
.
ctx
.
font
=
fontSize
+
"
px
"
+
GRID_FONT_FAMILY
;
let
textHeight
=
this
.
ctx
.
measureText
(
"
m
"
)
.
width
;
let
textWidth
=
Math
.
max
(
textHeight
this
.
ctx
.
measureText
(
lineNumber
)
.
width
)
;
let
padding
=
3
*
displayPixelRatio
;
let
offsetFromEdge
=
2
*
displayPixelRatio
;
let
boxWidth
=
textWidth
+
2
*
padding
;
let
boxHeight
=
textHeight
+
2
*
padding
;
let
x
y
;
if
(
dimensionType
=
=
=
COLUMNS
)
{
x
=
linePos
+
breadth
/
2
;
y
=
startPos
;
if
(
lineNumber
>
0
)
{
y
-
=
offsetFromEdge
;
}
else
{
y
+
=
offsetFromEdge
;
}
}
else
if
(
dimensionType
=
=
=
ROWS
)
{
x
=
startPos
;
y
=
linePos
+
breadth
/
2
;
if
(
lineNumber
>
0
)
{
x
-
=
offsetFromEdge
;
}
else
{
x
+
=
offsetFromEdge
;
}
}
[
x
y
]
=
apply
(
this
.
currentMatrix
[
x
y
]
)
;
if
(
stackedLineIndex
)
{
const
xOffset
=
boxWidth
/
4
;
const
yOffset
=
boxHeight
/
4
;
if
(
lineNumber
>
0
)
{
x
-
=
xOffset
;
y
-
=
yOffset
;
}
else
{
x
+
=
xOffset
;
y
+
=
yOffset
;
}
}
this
.
ctx
.
lineWidth
=
2
*
displayPixelRatio
;
this
.
ctx
.
strokeStyle
=
this
.
color
;
this
.
ctx
.
fillStyle
=
"
white
"
;
let
radius
=
2
*
displayPixelRatio
;
let
margin
=
2
*
displayPixelRatio
;
let
arrowSize
=
8
*
displayPixelRatio
;
let
minOffsetFromEdge
=
OFFSET_FROM_EDGE
*
displayPixelRatio
;
let
minBoxSize
=
arrowSize
*
2
+
padding
;
boxWidth
=
Math
.
max
(
boxWidth
minBoxSize
)
;
boxHeight
=
Math
.
max
(
boxHeight
minBoxSize
)
;
let
{
width
height
}
=
this
.
_winDimensions
;
let
boxAlignment
;
let
textCenterPos
;
if
(
dimensionType
=
=
=
COLUMNS
)
{
if
(
lineNumber
>
0
)
{
boxAlignment
=
"
top
"
;
textCenterPos
=
(
boxHeight
+
arrowSize
+
radius
)
-
boxHeight
/
2
;
if
(
y
<
=
minOffsetFromEdge
)
{
boxAlignment
=
"
bottom
"
;
textCenterPos
=
-
(
(
boxHeight
+
arrowSize
+
radius
)
-
boxHeight
/
2
)
;
if
(
y
+
padding
<
0
|
|
y
=
=
=
padding
)
{
y
=
padding
;
}
else
{
y
+
=
arrowSize
;
}
}
drawBubbleRect
(
this
.
ctx
x
y
boxWidth
boxHeight
radius
margin
arrowSize
boxAlignment
)
;
y
-
=
textCenterPos
;
}
else
{
boxAlignment
=
"
bottom
"
;
textCenterPos
=
(
boxHeight
+
arrowSize
+
radius
)
-
boxHeight
/
2
;
if
(
y
/
displayPixelRatio
>
=
height
*
.
95
)
{
boxAlignment
=
"
top
"
;
textCenterPos
=
-
(
(
boxHeight
+
arrowSize
+
radius
)
-
boxHeight
/
2
)
;
if
(
y
+
padding
>
height
)
{
y
-
=
arrowSize
;
}
}
drawBubbleRect
(
this
.
ctx
x
y
boxWidth
boxHeight
radius
margin
arrowSize
boxAlignment
)
;
y
+
=
textCenterPos
;
}
}
if
(
dimensionType
=
=
=
ROWS
)
{
if
(
lineNumber
>
0
)
{
boxAlignment
=
"
left
"
;
textCenterPos
=
(
boxWidth
+
arrowSize
+
radius
)
-
boxWidth
/
2
;
if
(
x
<
=
minOffsetFromEdge
)
{
boxAlignment
=
"
right
"
;
textCenterPos
=
-
(
(
boxWidth
+
arrowSize
+
radius
)
-
boxWidth
/
2
)
;
if
(
x
+
padding
<
0
|
|
x
=
=
=
padding
)
{
x
=
padding
;
}
else
{
x
+
=
arrowSize
;
}
}
drawBubbleRect
(
this
.
ctx
x
y
boxWidth
boxHeight
radius
margin
arrowSize
boxAlignment
)
;
x
-
=
textCenterPos
;
}
else
{
boxAlignment
=
"
right
"
;
textCenterPos
=
(
boxWidth
+
arrowSize
+
radius
)
-
boxWidth
/
2
;
if
(
x
/
displayPixelRatio
>
=
width
*
.
95
)
{
boxAlignment
=
"
left
"
;
textCenterPos
=
-
(
(
boxWidth
+
arrowSize
+
radius
)
-
boxWidth
/
2
)
;
if
(
x
+
padding
>
width
)
{
x
-
=
arrowSize
;
}
}
drawBubbleRect
(
this
.
ctx
x
y
boxWidth
boxHeight
radius
margin
arrowSize
boxAlignment
)
;
x
+
=
textCenterPos
;
}
}
this
.
ctx
.
textAlign
=
"
center
"
;
this
.
ctx
.
textBaseline
=
"
middle
"
;
this
.
ctx
.
fillStyle
=
"
black
"
;
const
numberText
=
stackedLineIndex
?
"
"
:
lineNumber
;
this
.
ctx
.
fillText
(
numberText
x
y
)
;
this
.
ctx
.
restore
(
)
;
}
renderLine
(
linePos
startPos
endPos
dimensionType
lineType
)
{
let
{
devicePixelRatio
}
=
this
.
win
;
let
lineWidth
=
getDisplayPixelRatio
(
this
.
win
)
;
let
offset
=
(
lineWidth
/
2
)
%
1
;
let
canvasX
=
Math
.
round
(
this
.
_canvasPosition
.
x
*
devicePixelRatio
)
;
let
canvasY
=
Math
.
round
(
this
.
_canvasPosition
.
y
*
devicePixelRatio
)
;
linePos
=
Math
.
round
(
linePos
)
;
startPos
=
Math
.
round
(
startPos
)
;
endPos
=
Math
.
round
(
endPos
)
;
this
.
ctx
.
save
(
)
;
this
.
ctx
.
setLineDash
(
GRID_LINES_PROPERTIES
[
lineType
]
.
lineDash
)
;
this
.
ctx
.
beginPath
(
)
;
this
.
ctx
.
translate
(
offset
-
canvasX
offset
-
canvasY
)
;
let
lineOptions
=
{
matrix
:
this
.
currentMatrix
}
;
if
(
this
.
options
.
showInfiniteLines
)
{
lineOptions
.
extendToBoundaries
=
[
canvasX
canvasY
canvasX
+
CANVAS_SIZE
canvasY
+
CANVAS_SIZE
]
;
}
if
(
dimensionType
=
=
=
COLUMNS
)
{
drawLine
(
this
.
ctx
linePos
startPos
linePos
endPos
lineOptions
)
;
}
else
{
drawLine
(
this
.
ctx
startPos
linePos
endPos
linePos
lineOptions
)
;
}
this
.
ctx
.
strokeStyle
=
this
.
color
;
this
.
ctx
.
globalAlpha
=
GRID_LINES_PROPERTIES
[
lineType
]
.
alpha
;
if
(
GRID_LINES_PROPERTIES
[
lineType
]
.
lineWidth
)
{
this
.
ctx
.
lineWidth
=
GRID_LINES_PROPERTIES
[
lineType
]
.
lineWidth
*
devicePixelRatio
;
}
else
{
this
.
ctx
.
lineWidth
=
lineWidth
;
}
this
.
ctx
.
stroke
(
)
;
this
.
ctx
.
restore
(
)
;
}
renderLines
(
gridDimension
dimensionType
startPos
endPos
)
{
const
{
lines
tracks
}
=
gridDimension
;
const
lastEdgeLineIndex
=
this
.
getLastEdgeLineIndex
(
tracks
)
;
for
(
let
i
=
0
;
i
<
lines
.
length
;
i
+
+
)
{
let
line
=
lines
[
i
]
;
let
linePos
=
line
.
start
;
if
(
i
=
=
0
|
|
i
=
=
lastEdgeLineIndex
)
{
this
.
renderLine
(
linePos
startPos
endPos
dimensionType
"
edge
"
)
;
}
else
{
this
.
renderLine
(
linePos
startPos
endPos
dimensionType
tracks
[
i
-
1
]
.
type
)
;
}
if
(
line
.
breadth
>
0
)
{
this
.
renderGridGap
(
linePos
startPos
endPos
line
.
breadth
dimensionType
)
;
this
.
renderLine
(
linePos
+
line
.
breadth
startPos
endPos
dimensionType
tracks
[
i
]
.
type
)
;
}
}
}
renderLineNumbers
(
gridDimension
dimensionType
startPos
)
{
const
{
lines
tracks
}
=
gridDimension
;
let
stackedLines
=
[
]
;
for
(
let
i
=
0
line
;
(
line
=
lines
[
i
+
+
]
)
;
)
{
if
(
line
.
number
=
=
=
0
)
{
continue
;
}
const
gridLine
=
tracks
[
line
.
number
-
1
]
;
if
(
gridLine
)
{
const
{
breadth
}
=
gridLine
;
if
(
breadth
=
=
=
0
)
{
stackedLines
.
push
(
lines
[
i
]
.
number
)
;
if
(
stackedLines
.
length
>
0
)
{
this
.
renderGridLineNumber
(
line
.
number
line
.
start
startPos
line
.
breadth
dimensionType
1
)
;
}
continue
;
}
}
this
.
renderGridLineNumber
(
line
.
number
line
.
start
startPos
line
.
breadth
dimensionType
)
;
}
}
renderNegativeLineNumbers
(
gridDimension
dimensionType
startPos
)
{
const
{
lines
tracks
}
=
gridDimension
;
let
stackedLines
=
[
]
;
for
(
let
i
=
0
line
;
(
line
=
lines
[
i
+
+
]
)
;
)
{
let
linePos
=
line
.
start
;
let
negativeLineNumber
=
line
.
negativeNumber
;
if
(
negativeLineNumber
=
=
0
)
{
break
;
}
const
gridLine
=
tracks
[
line
.
number
-
1
]
;
if
(
gridLine
)
{
const
{
breadth
}
=
gridLine
;
if
(
breadth
=
=
=
0
)
{
stackedLines
.
push
(
negativeLineNumber
)
;
if
(
stackedLines
.
length
>
0
)
{
this
.
renderGridLineNumber
(
negativeLineNumber
linePos
startPos
line
.
breadth
dimensionType
1
)
;
}
continue
;
}
}
if
(
stackedLines
.
length
)
{
negativeLineNumber
=
stackedLines
[
0
]
;
stackedLines
=
[
]
;
}
this
.
renderGridLineNumber
(
negativeLineNumber
linePos
startPos
line
.
breadth
dimensionType
)
;
}
}
_update
(
)
{
setIgnoreLayoutChanges
(
true
)
;
let
root
=
this
.
getElement
(
"
root
"
)
;
let
cells
=
this
.
getElement
(
"
cells
"
)
;
let
areas
=
this
.
getElement
(
"
areas
"
)
;
root
.
setAttribute
(
"
style
"
"
display
:
none
"
)
;
this
.
win
.
document
.
documentElement
.
offsetWidth
;
cells
.
setAttribute
(
"
style
"
fill
:
{
this
.
color
}
)
;
areas
.
setAttribute
(
"
style
"
fill
:
{
this
.
color
}
)
;
let
{
width
height
}
=
this
.
_winDimensions
;
updateCanvasElement
(
this
.
canvas
this
.
_canvasPosition
this
.
win
.
devicePixelRatio
)
;
this
.
clearGridAreas
(
)
;
this
.
clearGridCell
(
)
;
let
{
currentMatrix
hasNodeTransformations
}
=
getCurrentMatrix
(
this
.
currentNode
this
.
win
)
;
this
.
currentMatrix
=
currentMatrix
;
this
.
hasNodeTransformations
=
hasNodeTransformations
;
for
(
let
i
=
0
;
i
<
this
.
gridData
.
length
;
i
+
+
)
{
this
.
renderFragment
(
this
.
gridData
[
i
]
)
;
}
if
(
this
.
options
.
showAllGridAreas
)
{
this
.
showAllGridAreas
(
)
;
}
else
if
(
this
.
options
.
showGridArea
)
{
this
.
showGridArea
(
this
.
options
.
showGridArea
)
;
}
if
(
this
.
options
.
showGridCell
)
{
this
.
showGridCell
(
this
.
options
.
showGridCell
)
;
}
if
(
this
.
options
.
showGridLineNames
)
{
this
.
showGridLineNames
(
this
.
options
.
showGridLineNames
)
;
}
this
.
_showGrid
(
)
;
this
.
_showGridElements
(
)
;
root
.
setAttribute
(
"
style
"
position
:
absolute
;
width
:
{
width
}
px
;
height
:
{
height
}
px
;
overflow
:
hidden
)
;
setIgnoreLayoutChanges
(
false
this
.
highlighterEnv
.
document
.
documentElement
)
;
return
true
;
}
_updateGridAreaInfobar
(
area
bounds
)
{
let
{
width
height
}
=
bounds
;
let
dim
=
parseFloat
(
width
.
toPrecision
(
6
)
)
+
"
\
u00D7
"
+
parseFloat
(
height
.
toPrecision
(
6
)
)
;
this
.
getElement
(
"
area
-
infobar
-
name
"
)
.
setTextContent
(
area
.
name
)
;
this
.
getElement
(
"
area
-
infobar
-
dimensions
"
)
.
setTextContent
(
dim
)
;
let
container
=
this
.
getElement
(
"
area
-
infobar
-
container
"
)
;
moveInfobar
(
container
bounds
this
.
win
{
position
:
"
bottom
"
hideIfOffscreen
:
true
}
)
;
}
_updateGridCellInfobar
(
rowNumber
columnNumber
bounds
)
{
let
{
width
height
}
=
bounds
;
let
dim
=
parseFloat
(
width
.
toPrecision
(
6
)
)
+
"
\
u00D7
"
+
parseFloat
(
height
.
toPrecision
(
6
)
)
;
let
position
=
LAYOUT_L10N
.
getFormatStr
(
"
layout
.
rowColumnPositions
"
rowNumber
columnNumber
)
;
this
.
getElement
(
"
cell
-
infobar
-
position
"
)
.
setTextContent
(
position
)
;
this
.
getElement
(
"
cell
-
infobar
-
dimensions
"
)
.
setTextContent
(
dim
)
;
let
container
=
this
.
getElement
(
"
cell
-
infobar
-
container
"
)
;
moveInfobar
(
container
bounds
this
.
win
{
position
:
"
top
"
hideIfOffscreen
:
true
}
)
;
}
_updateGridLineInfobar
(
gridLineNames
gridLineNumber
x
y
)
{
this
.
getElement
(
"
line
-
infobar
-
number
"
)
.
setTextContent
(
gridLineNumber
)
;
this
.
getElement
(
"
line
-
infobar
-
names
"
)
.
setTextContent
(
gridLineNames
)
;
let
container
=
this
.
getElement
(
"
line
-
infobar
-
container
"
)
;
moveInfobar
(
container
getBoundsFromPoints
(
[
{
x
y
}
{
x
y
}
{
x
y
}
{
x
y
}
]
)
this
.
win
)
;
}
}
exports
.
CssGridHighlighter
=
CssGridHighlighter
;
