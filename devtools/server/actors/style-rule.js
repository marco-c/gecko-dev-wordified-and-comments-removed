"
use
strict
"
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
getCSSLexer
}
=
require
(
"
devtools
/
shared
/
css
/
lexer
"
)
;
const
InspectorUtils
=
require
(
"
InspectorUtils
"
)
;
const
TrackChangeEmitter
=
require
(
"
devtools
/
server
/
actors
/
utils
/
track
-
change
-
emitter
"
)
;
const
{
getRuleText
getTextAtLineColumn
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
style
-
utils
"
)
;
const
{
styleRuleSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
style
-
rule
"
)
;
const
{
style
:
{
ELEMENT_STYLE
}
}
=
require
(
"
devtools
/
shared
/
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
CssLogic
"
"
devtools
/
server
/
actors
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
SharedCssLogic
"
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
CSSRuleTypeName
"
"
findCssSelector
"
"
prettifyCSS
"
]
"
devtools
/
shared
/
inspector
/
css
-
logic
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isCssPropertyKnown
"
"
devtools
/
server
/
actors
/
css
-
properties
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
isPropertyUsed
"
"
devtools
/
server
/
actors
/
utils
/
inactive
-
property
-
helper
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
parseNamedDeclarations
"
"
devtools
/
shared
/
css
/
parsing
-
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
UPDATE_PRESERVING_RULES
"
"
UPDATE_GENERAL
"
]
"
devtools
/
server
/
actors
/
style
-
sheet
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ChromeUtils
"
)
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
SUPPORTED_RULE_TYPES
=
[
CSSRule
.
STYLE_RULE
CSSRule
.
SUPPORTS_RULE
CSSRule
.
KEYFRAME_RULE
CSSRule
.
KEYFRAMES_RULE
CSSRule
.
MEDIA_RULE
]
;
const
StyleRuleActor
=
protocol
.
ActorClassWithSpec
(
styleRuleSpec
{
initialize
(
pageStyle
item
)
{
protocol
.
Actor
.
prototype
.
initialize
.
call
(
this
null
)
;
this
.
pageStyle
=
pageStyle
;
this
.
rawStyle
=
item
.
style
;
this
.
_parentSheet
=
null
;
this
.
_onStyleApplied
=
this
.
_onStyleApplied
.
bind
(
this
)
;
this
.
_declarations
=
[
]
;
this
.
_pendingDeclarationChanges
=
[
]
;
if
(
CSSRule
.
isInstance
(
item
)
)
{
this
.
type
=
item
.
type
;
this
.
rawRule
=
item
;
this
.
_computeRuleIndex
(
)
;
if
(
SUPPORTED_RULE_TYPES
.
includes
(
this
.
type
)
&
&
this
.
rawRule
.
parentStyleSheet
)
{
this
.
line
=
InspectorUtils
.
getRelativeRuleLine
(
this
.
rawRule
)
;
this
.
column
=
InspectorUtils
.
getRuleColumn
(
this
.
rawRule
)
;
this
.
_parentSheet
=
this
.
rawRule
.
parentStyleSheet
;
if
(
!
this
.
pageStyle
.
hasStyleSheetWatcherSupport
)
{
this
.
sheetActor
=
this
.
pageStyle
.
_sheetRef
(
this
.
_parentSheet
)
;
this
.
sheetActor
.
on
(
"
style
-
applied
"
this
.
_onStyleApplied
)
;
}
}
}
else
{
this
.
type
=
ELEMENT_STYLE
;
this
.
rawNode
=
item
;
this
.
rawRule
=
{
style
:
item
.
style
toString
(
)
{
return
"
[
element
rule
"
+
this
.
style
+
"
]
"
;
}
}
;
}
}
get
conn
(
)
{
return
this
.
pageStyle
.
conn
;
}
destroy
(
)
{
if
(
!
this
.
rawStyle
)
{
return
;
}
protocol
.
Actor
.
prototype
.
destroy
.
call
(
this
)
;
this
.
rawStyle
=
null
;
this
.
pageStyle
=
null
;
this
.
rawNode
=
null
;
this
.
rawRule
=
null
;
this
.
_declarations
=
null
;
if
(
this
.
sheetActor
)
{
this
.
sheetActor
.
off
(
"
style
-
applied
"
this
.
_onStyleApplied
)
;
}
}
get
marshallPool
(
)
{
return
this
.
pageStyle
;
}
get
canSetRuleText
(
)
{
return
(
this
.
type
=
=
=
ELEMENT_STYLE
|
|
(
this
.
_parentSheet
&
&
!
InspectorUtils
.
hasRulesModifiedByCSSOM
(
this
.
_parentSheet
)
&
&
this
.
_parentSheet
.
href
!
=
=
"
about
:
PreferenceStyleSheet
"
)
)
;
}
get
ancestorRules
(
)
{
const
ancestors
=
[
]
;
let
rule
=
this
.
rawRule
;
while
(
rule
.
parentRule
)
{
ancestors
.
unshift
(
this
.
pageStyle
.
_styleRef
(
rule
.
parentRule
)
)
;
rule
=
rule
.
parentRule
;
}
return
ancestors
;
}
get
metadata
(
)
{
const
data
=
{
}
;
data
.
id
=
this
.
actorID
;
data
.
ancestors
=
this
.
ancestorRules
.
map
(
rule
=
>
{
return
{
id
:
rule
.
actorID
type
:
rule
.
rawRule
.
type
typeName
:
CSSRuleTypeName
[
rule
.
rawRule
.
type
]
conditionText
:
rule
.
rawRule
.
conditionText
name
:
rule
.
rawRule
.
name
keyText
:
rule
.
rawRule
.
keyText
ruleIndex
:
rule
.
_ruleIndex
}
;
}
)
;
if
(
this
.
type
=
=
=
ELEMENT_STYLE
&
&
this
.
rawNode
)
{
try
{
data
.
selector
=
findCssSelector
(
this
.
rawNode
)
;
}
catch
(
err
)
{
}
data
.
source
=
{
type
:
"
element
"
href
:
this
.
rawNode
.
baseURI
index
:
data
.
selector
isFramed
:
this
.
rawNode
.
ownerGlobal
!
=
=
this
.
pageStyle
.
ownerWindow
}
;
const
nodeActor
=
this
.
pageStyle
.
walker
.
getNode
(
this
.
rawNode
)
;
if
(
nodeActor
)
{
data
.
source
.
id
=
nodeActor
.
actorID
;
}
data
.
ruleIndex
=
0
;
}
else
{
data
.
selector
=
this
.
type
=
=
=
CSSRule
.
KEYFRAME_RULE
?
this
.
rawRule
.
keyText
:
this
.
rawRule
.
selectorText
;
data
.
ruleIndex
=
this
.
_ruleIndex
;
if
(
this
.
pageStyle
.
hasStyleSheetWatcherSupport
)
{
const
sheet
=
this
.
_parentSheet
;
const
inspectorActor
=
this
.
pageStyle
.
inspector
;
const
resourceId
=
this
.
pageStyle
.
styleSheetsManager
.
getStyleSheetResourceId
(
sheet
)
;
const
styleSheetIndex
=
this
.
pageStyle
.
styleSheetsManager
.
getStyleSheetIndex
(
resourceId
)
;
data
.
source
=
{
type
:
sheet
.
href
?
"
stylesheet
"
:
"
inline
"
href
:
sheet
.
href
|
|
inspectorActor
.
window
.
location
.
toString
(
)
id
:
resourceId
index
:
styleSheetIndex
isFramed
:
inspectorActor
.
window
!
=
=
inspectorActor
.
window
.
top
}
;
}
else
{
data
.
source
=
{
type
:
this
.
sheetActor
.
href
?
"
stylesheet
"
:
"
inline
"
href
:
this
.
sheetActor
.
href
|
|
this
.
sheetActor
.
window
.
location
.
toString
(
)
id
:
this
.
sheetActor
.
actorID
index
:
this
.
sheetActor
.
styleSheetIndex
isFramed
:
this
.
sheetActor
.
ownerWindow
!
=
=
this
.
sheetActor
.
window
}
;
}
}
return
data
;
}
getDocument
(
sheet
)
{
if
(
!
sheet
.
associatedDocument
)
{
throw
new
Error
(
"
Failed
trying
to
get
the
document
of
an
invalid
stylesheet
"
)
;
}
return
sheet
.
associatedDocument
;
}
toString
(
)
{
return
"
[
StyleRuleActor
for
"
+
this
.
rawRule
+
"
]
"
;
}
form
(
)
{
const
form
=
{
actor
:
this
.
actorID
type
:
this
.
type
line
:
this
.
line
|
|
undefined
column
:
this
.
column
ancestorData
:
[
]
traits
:
{
canSetRuleText
:
this
.
canSetRuleText
}
}
;
for
(
const
ancestorRule
of
this
.
ancestorRules
)
{
if
(
ancestorRule
.
type
=
=
=
CSSRule
.
MEDIA_RULE
&
&
ancestorRule
.
rawRule
.
media
?
.
length
)
{
form
.
ancestorData
.
push
(
{
type
:
"
media
"
value
:
Array
.
from
(
ancestorRule
.
rawRule
.
media
)
.
join
(
"
"
)
}
)
;
}
else
if
(
ChromeUtils
.
getClassName
(
ancestorRule
.
rawRule
)
=
=
=
"
CSSLayerBlockRule
"
)
{
form
.
ancestorData
.
push
(
{
type
:
"
layer
"
value
:
ancestorRule
.
rawRule
.
name
}
)
;
}
else
if
(
ChromeUtils
.
getClassName
(
ancestorRule
.
rawRule
)
=
=
=
"
CSSContainerRule
"
)
{
form
.
ancestorData
.
push
(
{
type
:
"
container
"
containerName
:
ancestorRule
.
rawRule
.
containerName
containerQuery
:
ancestorRule
.
rawRule
.
containerQuery
}
)
;
}
}
if
(
this
.
_parentSheet
)
{
if
(
this
.
pageStyle
.
hasStyleSheetWatcherSupport
)
{
form
.
parentStyleSheet
=
this
.
pageStyle
.
styleSheetsManager
.
getStyleSheetResourceId
(
this
.
_parentSheet
)
;
}
else
{
form
.
parentStyleSheet
=
this
.
pageStyle
.
_sheetRef
(
this
.
_parentSheet
)
.
actorID
;
}
if
(
this
.
_parentSheet
.
ownerRule
&
&
this
.
_parentSheet
.
ownerRule
.
layerName
!
=
=
null
)
{
form
.
ancestorData
.
unshift
(
{
type
:
"
layer
"
value
:
this
.
_parentSheet
.
ownerRule
.
layerName
}
)
;
}
}
form
.
authoredText
=
this
.
authoredText
;
switch
(
this
.
type
)
{
case
CSSRule
.
STYLE_RULE
:
form
.
selectors
=
CssLogic
.
getSelectors
(
this
.
rawRule
)
;
form
.
cssText
=
this
.
rawStyle
.
cssText
|
|
"
"
;
break
;
case
ELEMENT_STYLE
:
const
doc
=
this
.
rawNode
.
ownerDocument
;
form
.
href
=
doc
.
location
?
doc
.
location
.
href
:
"
"
;
form
.
cssText
=
this
.
rawStyle
.
cssText
|
|
"
"
;
form
.
authoredText
=
this
.
rawNode
.
getAttribute
(
"
style
"
)
;
break
;
case
CSSRule
.
CHARSET_RULE
:
form
.
encoding
=
this
.
rawRule
.
encoding
;
break
;
case
CSSRule
.
IMPORT_RULE
:
form
.
href
=
this
.
rawRule
.
href
;
break
;
case
CSSRule
.
KEYFRAMES_RULE
:
form
.
cssText
=
this
.
rawRule
.
cssText
;
form
.
name
=
this
.
rawRule
.
name
;
break
;
case
CSSRule
.
KEYFRAME_RULE
:
form
.
cssText
=
this
.
rawStyle
.
cssText
|
|
"
"
;
form
.
keyText
=
this
.
rawRule
.
keyText
|
|
"
"
;
break
;
}
if
(
form
.
authoredText
|
|
form
.
cssText
)
{
const
cssText
=
typeof
form
.
authoredText
=
=
=
"
string
"
?
form
.
authoredText
:
form
.
cssText
;
const
declarations
=
parseNamedDeclarations
(
isCssPropertyKnown
cssText
true
)
;
const
el
=
this
.
pageStyle
.
selectedElement
;
const
style
=
this
.
pageStyle
.
cssLogic
.
computedStyle
;
const
userAgent
=
this
.
_parentSheet
&
&
SharedCssLogic
.
isAgentStylesheet
(
this
.
_parentSheet
)
;
const
chrome
=
(
(
)
=
>
{
if
(
!
this
.
_parentSheet
)
{
return
false
;
}
if
(
SharedCssLogic
.
isUserStylesheet
(
this
.
_parentSheet
)
)
{
return
true
;
}
if
(
this
.
_parentSheet
.
href
)
{
return
this
.
_parentSheet
.
href
.
startsWith
(
"
chrome
:
"
)
;
}
return
el
&
&
el
.
ownerDocument
.
documentURI
.
startsWith
(
"
chrome
:
"
)
;
}
)
(
)
;
const
quirks
=
!
userAgent
&
&
el
&
&
el
.
ownerDocument
.
compatMode
=
=
"
BackCompat
"
;
const
supportsOptions
=
{
userAgent
chrome
quirks
}
;
form
.
declarations
=
declarations
.
map
(
decl
=
>
{
decl
.
isValid
=
InspectorUtils
.
supports
(
{
decl
.
name
}
:
{
decl
.
value
}
supportsOptions
)
;
decl
.
isUsed
=
isPropertyUsed
(
el
style
this
.
rawRule
decl
.
name
)
;
decl
.
isNameValid
=
InspectorUtils
.
supports
(
{
decl
.
name
}
:
initial
supportsOptions
)
;
return
decl
;
}
)
;
this
.
_pendingDeclarationChanges
.
forEach
(
change
=
>
this
.
logDeclarationChange
(
change
declarations
this
.
_declarations
)
)
;
this
.
_pendingDeclarationChanges
=
[
]
;
this
.
_declarations
=
declarations
;
}
return
form
;
}
_notifyLocationChanged
(
line
column
)
{
this
.
emit
(
"
location
-
changed
"
line
column
)
;
}
_computeRuleIndex
(
)
{
let
rule
=
this
.
rawRule
;
const
result
=
[
]
;
while
(
rule
)
{
let
cssRules
=
[
]
;
if
(
rule
.
parentRule
)
{
cssRules
=
rule
.
parentRule
.
cssRules
;
}
else
if
(
rule
.
parentStyleSheet
)
{
cssRules
=
rule
.
parentStyleSheet
.
cssRules
;
}
let
found
=
false
;
for
(
let
i
=
0
;
i
<
cssRules
.
length
;
i
+
+
)
{
if
(
rule
=
=
=
cssRules
.
item
(
i
)
)
{
found
=
true
;
result
.
unshift
(
i
)
;
break
;
}
}
if
(
!
found
)
{
this
.
_ruleIndex
=
null
;
return
;
}
rule
=
rule
.
parentRule
;
}
this
.
_ruleIndex
=
result
;
}
_getRuleFromIndex
(
parentSheet
)
{
let
currentRule
=
null
;
for
(
const
i
of
this
.
_ruleIndex
)
{
if
(
currentRule
=
=
=
null
)
{
currentRule
=
parentSheet
.
cssRules
[
i
]
;
}
else
{
currentRule
=
currentRule
.
cssRules
.
item
(
i
)
;
}
}
return
currentRule
;
}
_onStyleApplied
(
kind
)
{
if
(
kind
=
=
=
UPDATE_GENERAL
)
{
if
(
this
.
sheetActor
)
{
this
.
sheetActor
.
off
(
"
style
-
applied
"
this
.
_onStyleApplied
)
;
}
}
else
if
(
this
.
_ruleIndex
)
{
const
oldRule
=
this
.
rawRule
;
const
oldActor
=
this
.
pageStyle
.
refMap
.
get
(
oldRule
)
;
this
.
rawRule
=
this
.
_getRuleFromIndex
(
this
.
_parentSheet
)
;
if
(
oldActor
)
{
this
.
pageStyle
.
updateStyleRef
(
oldRule
this
.
rawRule
this
)
;
}
const
line
=
InspectorUtils
.
getRelativeRuleLine
(
this
.
rawRule
)
;
const
column
=
InspectorUtils
.
getRuleColumn
(
this
.
rawRule
)
;
if
(
line
!
=
=
this
.
line
|
|
column
!
=
=
this
.
column
)
{
this
.
_notifyLocationChanged
(
line
column
)
;
}
this
.
line
=
line
;
this
.
column
=
column
;
}
}
async
getAuthoredCssText
(
skipCache
=
false
)
{
if
(
!
this
.
canSetRuleText
|
|
!
SUPPORTED_RULE_TYPES
.
includes
(
this
.
type
)
)
{
return
Promise
.
resolve
(
"
"
)
;
}
if
(
typeof
this
.
authoredText
=
=
=
"
string
"
&
&
!
skipCache
)
{
return
Promise
.
resolve
(
this
.
authoredText
)
;
}
if
(
this
.
pageStyle
.
hasStyleSheetWatcherSupport
)
{
const
resourceId
=
this
.
pageStyle
.
styleSheetsManager
.
getStyleSheetResourceId
(
this
.
_parentSheet
)
;
const
cssText
=
await
this
.
pageStyle
.
styleSheetsManager
.
getText
(
resourceId
)
;
const
{
text
}
=
getRuleText
(
cssText
this
.
line
this
.
column
)
;
this
.
authoredText
=
text
;
return
this
.
authoredText
;
}
return
this
.
sheetActor
.
getText
(
)
.
then
(
longStr
=
>
{
const
cssText
=
longStr
.
str
;
const
{
text
}
=
getRuleText
(
cssText
this
.
line
this
.
column
)
;
this
.
authoredText
=
text
;
return
this
.
authoredText
;
}
)
;
}
async
getRuleText
(
)
{
if
(
!
[
.
.
.
SUPPORTED_RULE_TYPES
ELEMENT_STYLE
]
.
includes
(
this
.
type
)
)
{
return
Promise
.
resolve
(
"
"
)
;
}
let
ruleBodyText
;
let
selectorText
;
let
text
;
if
(
this
.
type
=
=
=
ELEMENT_STYLE
)
{
ruleBodyText
=
this
.
rawNode
.
getAttribute
(
"
style
"
)
;
selectorText
=
this
.
metadata
.
selector
;
}
else
{
ruleBodyText
=
await
this
.
getAuthoredCssText
(
true
)
;
let
stylesheetText
=
null
;
if
(
this
.
pageStyle
.
hasStyleSheetWatcherSupport
)
{
const
resourceId
=
this
.
pageStyle
.
styleSheetsManager
.
getStyleSheetResourceId
(
this
.
_parentSheet
)
;
stylesheetText
=
await
this
.
pageStyle
.
styleSheetsManager
.
getText
(
resourceId
)
;
}
else
{
const
{
str
}
=
await
this
.
sheetActor
.
getText
(
)
;
stylesheetText
=
str
;
}
const
[
start
end
]
=
getSelectorOffsets
(
stylesheetText
this
.
line
this
.
column
)
;
selectorText
=
stylesheetText
.
substring
(
start
end
)
;
}
const
typeName
=
CSSRuleTypeName
[
this
.
type
]
;
if
(
typeName
)
{
text
=
{
typeName
}
{
selectorText
}
{
{
ruleBodyText
}
}
;
}
else
{
text
=
{
selectorText
}
{
{
ruleBodyText
}
}
;
}
const
{
result
}
=
prettifyCSS
(
text
)
;
return
Promise
.
resolve
(
result
)
;
}
async
setRuleText
(
newText
modifications
=
[
]
)
{
if
(
!
this
.
canSetRuleText
)
{
throw
new
Error
(
"
invalid
call
to
setRuleText
"
)
;
}
if
(
this
.
type
=
=
=
ELEMENT_STYLE
)
{
this
.
rawNode
.
setAttributeDevtools
(
"
style
"
newText
)
;
}
else
if
(
this
.
pageStyle
.
hasStyleSheetWatcherSupport
)
{
const
resourceId
=
this
.
pageStyle
.
styleSheetsManager
.
getStyleSheetResourceId
(
this
.
_parentSheet
)
;
let
cssText
=
await
this
.
pageStyle
.
styleSheetsManager
.
getText
(
resourceId
)
;
const
{
offset
text
}
=
getRuleText
(
cssText
this
.
line
this
.
column
)
;
cssText
=
cssText
.
substring
(
0
offset
)
+
newText
+
cssText
.
substring
(
offset
+
text
.
length
)
;
await
this
.
pageStyle
.
styleSheetsManager
.
setStyleSheetText
(
resourceId
cssText
{
kind
:
UPDATE_PRESERVING_RULES
}
)
;
}
else
{
const
parentStyleSheet
=
this
.
pageStyle
.
_sheetRef
(
this
.
_parentSheet
)
;
let
{
str
:
cssText
}
=
await
parentStyleSheet
.
getText
(
)
;
const
{
offset
text
}
=
getRuleText
(
cssText
this
.
line
this
.
column
)
;
cssText
=
cssText
.
substring
(
0
offset
)
+
newText
+
cssText
.
substring
(
offset
+
text
.
length
)
;
await
parentStyleSheet
.
update
(
cssText
false
UPDATE_PRESERVING_RULES
)
;
}
this
.
authoredText
=
newText
;
this
.
pageStyle
.
refreshObservedRules
(
)
;
this
.
_pendingDeclarationChanges
.
push
(
.
.
.
modifications
)
;
return
this
;
}
modifyProperties
(
modifications
)
{
let
document
;
if
(
this
.
rawNode
)
{
document
=
this
.
rawNode
.
ownerDocument
;
}
else
{
let
parentStyleSheet
=
this
.
_parentSheet
;
while
(
parentStyleSheet
.
ownerRule
)
{
parentStyleSheet
=
parentStyleSheet
.
ownerRule
.
parentStyleSheet
;
}
document
=
this
.
getDocument
(
parentStyleSheet
)
;
}
const
tempElement
=
document
.
createElementNS
(
XHTML_NS
"
div
"
)
;
for
(
const
mod
of
modifications
)
{
if
(
mod
.
type
=
=
=
"
set
"
)
{
tempElement
.
style
.
setProperty
(
mod
.
name
mod
.
value
mod
.
priority
|
|
"
"
)
;
this
.
rawStyle
.
setProperty
(
mod
.
name
tempElement
.
style
.
getPropertyValue
(
mod
.
name
)
mod
.
priority
|
|
"
"
)
;
}
else
if
(
mod
.
type
=
=
=
"
remove
"
|
|
mod
.
type
=
=
=
"
disable
"
)
{
this
.
rawStyle
.
removeProperty
(
mod
.
name
)
;
}
}
this
.
pageStyle
.
refreshObservedRules
(
)
;
this
.
_pendingDeclarationChanges
.
push
(
.
.
.
modifications
)
;
return
this
;
}
async
_addNewSelector
(
value
editAuthored
)
{
const
rule
=
this
.
rawRule
;
const
parentStyleSheet
=
this
.
_parentSheet
;
if
(
editAuthored
)
{
const
document
=
this
.
getDocument
(
this
.
_parentSheet
)
;
try
{
document
.
querySelector
(
value
)
;
}
catch
(
e
)
{
return
null
;
}
if
(
this
.
pageStyle
.
hasStyleSheetWatcherSupport
)
{
const
resourceId
=
this
.
pageStyle
.
styleSheetsManager
.
getStyleSheetResourceId
(
this
.
_parentSheet
)
;
let
authoredText
=
await
this
.
pageStyle
.
styleSheetsManager
.
getText
(
resourceId
)
;
const
[
startOffset
endOffset
]
=
getSelectorOffsets
(
authoredText
this
.
line
this
.
column
)
;
authoredText
=
authoredText
.
substring
(
0
startOffset
)
+
value
+
authoredText
.
substring
(
endOffset
)
;
await
this
.
pageStyle
.
styleSheetsManager
.
setStyleSheetText
(
resourceId
authoredText
{
kind
:
UPDATE_PRESERVING_RULES
}
)
;
}
else
{
const
sheetActor
=
this
.
pageStyle
.
_sheetRef
(
parentStyleSheet
)
;
let
{
str
:
authoredText
}
=
await
sheetActor
.
getText
(
)
;
const
[
startOffset
endOffset
]
=
getSelectorOffsets
(
authoredText
this
.
line
this
.
column
)
;
authoredText
=
authoredText
.
substring
(
0
startOffset
)
+
value
+
authoredText
.
substring
(
endOffset
)
;
await
sheetActor
.
update
(
authoredText
false
UPDATE_PRESERVING_RULES
)
;
}
}
else
{
const
cssRules
=
parentStyleSheet
.
cssRules
;
const
cssText
=
rule
.
cssText
;
const
selectorText
=
rule
.
selectorText
;
for
(
let
i
=
0
;
i
<
cssRules
.
length
;
i
+
+
)
{
if
(
rule
=
=
=
cssRules
.
item
(
i
)
)
{
try
{
const
ruleText
=
cssText
.
slice
(
selectorText
.
length
)
.
trim
(
)
;
parentStyleSheet
.
insertRule
(
value
+
"
"
+
ruleText
i
)
;
parentStyleSheet
.
deleteRule
(
i
+
1
)
;
break
;
}
catch
(
e
)
{
return
null
;
}
}
}
}
return
this
.
_getRuleFromIndex
(
parentStyleSheet
)
;
}
logDeclarationChange
(
change
newDeclarations
oldDeclarations
)
{
const
index
=
change
.
index
;
let
{
value
:
prevValue
name
:
prevName
priority
:
prevPriority
commentOffsets
}
=
oldDeclarations
[
index
]
|
|
{
}
;
const
{
value
:
currentValue
name
:
currentName
}
=
newDeclarations
[
index
]
|
|
{
}
;
const
prevDisabled
=
!
!
commentOffsets
;
prevValue
=
prevValue
&
&
prevPriority
?
{
prevValue
}
!
important
:
prevValue
;
const
data
=
this
.
metadata
;
switch
(
change
.
type
)
{
case
"
set
"
:
data
.
type
=
prevValue
?
"
declaration
-
add
"
:
"
declaration
-
update
"
;
const
changeName
=
currentName
|
|
change
.
name
;
const
name
=
change
.
newName
?
change
.
newName
:
changeName
;
const
changeValue
=
currentValue
|
|
change
.
value
;
const
newValue
=
change
.
priority
?
{
changeValue
}
!
important
:
changeValue
;
const
value
=
change
.
newName
?
prevValue
:
newValue
;
data
.
add
=
[
{
property
:
name
value
index
}
]
;
if
(
prevValue
)
{
data
.
remove
=
[
{
property
:
prevName
value
:
prevValue
index
}
]
;
}
else
{
data
.
remove
=
null
;
}
if
(
prevDisabled
&
&
!
change
.
newName
&
&
prevValue
=
=
=
newValue
)
{
data
.
remove
=
null
;
}
break
;
case
"
remove
"
:
data
.
type
=
"
declaration
-
remove
"
;
data
.
add
=
null
;
data
.
remove
=
[
{
property
:
change
.
name
value
:
prevValue
index
}
]
;
break
;
case
"
disable
"
:
data
.
type
=
"
declaration
-
disable
"
;
data
.
add
=
null
;
data
.
remove
=
[
{
property
:
change
.
name
value
:
prevValue
index
}
]
;
break
;
}
TrackChangeEmitter
.
trackChange
(
data
)
;
}
logSelectorChange
(
oldSelector
newSelector
)
{
TrackChangeEmitter
.
trackChange
(
{
.
.
.
this
.
metadata
type
:
"
selector
-
remove
"
add
:
null
remove
:
null
selector
:
oldSelector
}
)
;
TrackChangeEmitter
.
trackChange
(
{
.
.
.
this
.
metadata
type
:
"
selector
-
add
"
add
:
null
remove
:
null
selector
:
newSelector
}
)
;
}
modifySelector
(
node
value
editAuthored
=
false
)
{
if
(
this
.
type
=
=
=
ELEMENT_STYLE
|
|
this
.
rawRule
.
selectorText
=
=
=
value
)
{
return
{
ruleProps
:
null
isMatching
:
true
}
;
}
const
oldValue
=
this
.
rawRule
.
selectorText
;
let
selectorPromise
=
this
.
_addNewSelector
(
value
editAuthored
)
;
if
(
editAuthored
)
{
selectorPromise
=
selectorPromise
.
then
(
newCssRule
=
>
{
if
(
newCssRule
)
{
this
.
logSelectorChange
(
oldValue
value
)
;
const
style
=
this
.
pageStyle
.
_styleRef
(
newCssRule
)
;
return
style
.
getAuthoredCssText
(
)
.
then
(
(
)
=
>
newCssRule
)
;
}
return
newCssRule
;
}
)
;
}
return
selectorPromise
.
then
(
newCssRule
=
>
{
let
ruleProps
=
null
;
let
isMatching
=
false
;
if
(
newCssRule
)
{
const
ruleEntry
=
this
.
pageStyle
.
findEntryMatchingRule
(
node
newCssRule
)
;
if
(
ruleEntry
.
length
=
=
=
1
)
{
ruleProps
=
this
.
pageStyle
.
getAppliedProps
(
node
ruleEntry
{
matchedSelectors
:
true
}
)
;
}
else
{
ruleProps
=
this
.
pageStyle
.
getNewAppliedProps
(
node
newCssRule
)
;
}
isMatching
=
ruleProps
.
entries
.
some
(
ruleProp
=
>
!
!
ruleProp
.
matchedSelectors
.
length
)
;
}
return
{
ruleProps
isMatching
}
;
}
)
;
}
refresh
(
)
{
let
hasChanged
=
false
;
const
el
=
this
.
pageStyle
.
selectedElement
;
const
style
=
CssLogic
.
getComputedStyle
(
el
)
;
for
(
const
decl
of
this
.
_declarations
)
{
const
isUsed
=
isPropertyUsed
(
el
style
this
.
rawRule
decl
.
name
)
;
if
(
decl
.
isUsed
.
used
!
=
=
isUsed
.
used
)
{
decl
.
isUsed
=
isUsed
;
hasChanged
=
true
;
}
}
if
(
hasChanged
)
{
this
.
emit
(
"
rule
-
updated
"
this
)
;
}
}
}
)
;
exports
.
StyleRuleActor
=
StyleRuleActor
;
function
getSelectorOffsets
(
initialText
line
column
)
{
if
(
typeof
line
=
=
=
"
undefined
"
|
|
typeof
column
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
Location
information
is
missing
"
)
;
}
const
{
offset
:
textOffset
text
}
=
getTextAtLineColumn
(
initialText
line
column
)
;
const
lexer
=
getCSSLexer
(
text
)
;
let
endOffset
;
while
(
true
)
{
const
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
{
"
)
{
if
(
endOffset
=
=
=
undefined
)
{
break
;
}
return
[
textOffset
textOffset
+
endOffset
]
;
}
if
(
token
.
tokenType
!
=
=
"
comment
"
&
&
token
.
tokenType
!
=
=
"
whitespace
"
)
{
endOffset
=
token
.
endOffset
;
}
}
throw
new
Error
(
"
could
not
find
bounds
of
rule
"
)
;
}
