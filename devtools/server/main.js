"
use
strict
"
;
var
{
Ci
Cc
}
=
require
(
"
chrome
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
{
ActorPool
OriginalLocation
RegisteredActorFactory
ObservedActorFactory
}
=
require
(
"
devtools
/
server
/
actors
/
common
"
)
;
var
{
LocalDebuggerTransport
ChildDebuggerTransport
WorkerDebuggerTransport
}
=
require
(
"
devtools
/
shared
/
transport
/
transport
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
{
dumpn
}
=
DevToolsUtils
;
DevToolsUtils
.
defineLazyGetter
(
this
"
DebuggerSocket
"
(
)
=
>
{
const
{
DebuggerSocket
}
=
require
(
"
devtools
/
shared
/
security
/
socket
"
)
;
return
DebuggerSocket
;
}
)
;
DevToolsUtils
.
defineLazyGetter
(
this
"
Authentication
"
(
)
=
>
{
return
require
(
"
devtools
/
shared
/
security
/
auth
"
)
;
}
)
;
DevToolsUtils
.
defineLazyGetter
(
this
"
generateUUID
"
(
)
=
>
{
const
{
generateUUID
}
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
return
generateUUID
;
}
)
;
Object
.
defineProperty
(
this
"
Components
"
{
get
(
)
{
return
require
(
"
chrome
"
)
.
components
;
}
}
)
;
const
CONTENT_PROCESS_SERVER_STARTUP_SCRIPT
=
"
resource
:
/
/
devtools
/
server
/
startup
/
content
-
process
.
js
"
;
function
loadSubScript
(
url
)
{
try
{
Services
.
scriptloader
.
loadSubScript
(
url
this
)
;
}
catch
(
e
)
{
const
errorStr
=
"
Error
loading
:
"
+
url
+
"
:
\
n
"
+
(
e
.
fileName
?
"
at
"
+
e
.
fileName
+
"
:
"
+
e
.
lineNumber
+
"
\
n
"
:
"
"
)
+
e
+
"
-
"
+
e
.
stack
+
"
\
n
"
;
dump
(
errorStr
)
;
reportError
(
errorStr
)
;
throw
e
;
}
}
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
var
gRegisteredModules
=
Object
.
create
(
null
)
;
function
ModuleAPI
(
)
{
let
activeTabActors
=
new
Set
(
)
;
let
activeGlobalActors
=
new
Set
(
)
;
return
{
setRootActor
(
factory
)
{
DebuggerServer
.
setRootActor
(
factory
)
;
}
addGlobalActor
(
factory
name
)
{
DebuggerServer
.
addGlobalActor
(
factory
name
)
;
activeGlobalActors
.
add
(
factory
)
;
}
removeGlobalActor
(
factory
)
{
DebuggerServer
.
removeGlobalActor
(
factory
)
;
activeGlobalActors
.
delete
(
factory
)
;
}
addTabActor
(
factory
name
)
{
DebuggerServer
.
addTabActor
(
factory
name
)
;
activeTabActors
.
add
(
factory
)
;
}
removeTabActor
(
factory
)
{
DebuggerServer
.
removeTabActor
(
factory
)
;
activeTabActors
.
delete
(
factory
)
;
}
destroy
(
)
{
for
(
const
factory
of
activeTabActors
)
{
DebuggerServer
.
removeTabActor
(
factory
)
;
}
activeTabActors
=
null
;
for
(
const
factory
of
activeGlobalActors
)
{
DebuggerServer
.
removeGlobalActor
(
factory
)
;
}
activeGlobalActors
=
null
;
}
}
;
}
var
DebuggerServer
=
{
_listeners
:
[
]
_initialized
:
false
_contentProcessServerStartupScriptLoaded
:
false
globalActorFactories
:
{
}
tabActorFactories
:
{
}
LONG_STRING_LENGTH
:
10000
LONG_STRING_INITIAL_LENGTH
:
1000
LONG_STRING_READ_LENGTH
:
65
*
1024
chromeWindowType
:
"
navigator
:
browser
"
allowChromeProcess
:
false
get
rootlessServer
(
)
{
return
!
this
.
isModuleRegistered
(
"
devtools
/
server
/
actors
/
webbrowser
"
)
;
}
init
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
_connections
=
{
}
;
this
.
_nextConnID
=
0
;
this
.
_initialized
=
true
;
}
get
protocol
(
)
{
return
require
(
"
devtools
/
shared
/
protocol
"
)
;
}
get
initialized
(
)
{
return
this
.
_initialized
;
}
destroy
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
for
(
const
connID
of
Object
.
getOwnPropertyNames
(
this
.
_connections
)
)
{
this
.
_connections
[
connID
]
.
close
(
)
;
}
for
(
const
id
of
Object
.
getOwnPropertyNames
(
gRegisteredModules
)
)
{
this
.
unregisterModule
(
id
)
;
}
gRegisteredModules
=
Object
.
create
(
null
)
;
this
.
closeAllListeners
(
)
;
this
.
globalActorFactories
=
{
}
;
this
.
tabActorFactories
=
{
}
;
this
.
_initialized
=
false
;
dumpn
(
"
Debugger
server
is
shut
down
.
"
)
;
}
_checkInit
(
)
{
if
(
!
this
.
_initialized
)
{
throw
new
Error
(
"
DebuggerServer
has
not
been
initialized
.
"
)
;
}
if
(
!
this
.
rootlessServer
&
&
!
this
.
createRootActor
)
{
throw
new
Error
(
"
Use
DebuggerServer
.
addActors
(
)
to
add
a
root
actor
"
+
"
implementation
.
"
)
;
}
}
registerActors
(
{
root
browser
tab
}
)
{
if
(
browser
)
{
this
.
_addBrowserActors
(
)
;
}
if
(
root
)
{
this
.
registerModule
(
"
devtools
/
server
/
actors
/
webbrowser
"
)
;
}
if
(
tab
)
{
this
.
_addTabActors
(
)
;
}
}
registerAllActors
(
)
{
this
.
registerActors
(
{
root
:
true
browser
:
true
tab
:
true
}
)
;
}
addActors
(
url
)
{
loadSubScript
.
call
(
this
url
)
;
}
registerModule
(
id
options
)
{
if
(
id
in
gRegisteredModules
)
{
return
;
}
if
(
options
)
{
const
{
prefix
constructor
type
}
=
options
;
if
(
typeof
(
prefix
)
!
=
=
"
string
"
)
{
throw
new
Error
(
Lazy
actor
definition
for
'
{
id
}
'
requires
a
string
+
'
prefix
'
option
.
)
;
}
if
(
typeof
(
constructor
)
!
=
=
"
string
"
)
{
throw
new
Error
(
Lazy
actor
definition
for
'
{
id
}
'
requires
a
string
+
'
constructor
'
option
.
)
;
}
if
(
!
(
"
global
"
in
type
)
&
&
!
(
"
tab
"
in
type
)
)
{
throw
new
Error
(
Lazy
actor
definition
for
'
{
id
}
'
requires
a
dictionary
+
'
type
'
option
whose
attributes
can
be
'
global
'
or
'
tab
'
.
)
;
}
const
name
=
prefix
+
"
Actor
"
;
const
mod
=
{
id
:
id
prefix
:
prefix
constructorName
:
constructor
type
:
type
globalActor
:
type
.
global
tabActor
:
type
.
tab
}
;
gRegisteredModules
[
id
]
=
mod
;
if
(
mod
.
tabActor
)
{
this
.
addTabActor
(
mod
name
)
;
}
if
(
mod
.
globalActor
)
{
this
.
addGlobalActor
(
mod
name
)
;
}
}
else
{
const
moduleAPI
=
ModuleAPI
(
)
;
const
mod
=
require
(
id
)
;
mod
.
register
(
moduleAPI
)
;
gRegisteredModules
[
id
]
=
{
module
:
mod
api
:
moduleAPI
}
;
}
}
isModuleRegistered
(
id
)
{
return
(
id
in
gRegisteredModules
)
;
}
unregisterModule
(
id
)
{
const
mod
=
gRegisteredModules
[
id
]
;
if
(
!
mod
)
{
throw
new
Error
(
"
Tried
to
unregister
a
module
that
was
not
previously
registered
.
"
)
;
}
if
(
mod
.
tabActor
)
{
this
.
removeTabActor
(
mod
)
;
}
if
(
mod
.
globalActor
)
{
this
.
removeGlobalActor
(
mod
)
;
}
if
(
mod
.
module
)
{
mod
.
module
.
unregister
(
mod
.
api
)
;
mod
.
api
.
destroy
(
)
;
}
delete
gRegisteredModules
[
id
]
;
}
_addBrowserActors
(
)
{
this
.
registerModule
(
"
devtools
/
server
/
actors
/
preference
"
{
prefix
:
"
preference
"
constructor
:
"
PreferenceActor
"
type
:
{
global
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
actor
-
registry
"
{
prefix
:
"
actorRegistry
"
constructor
:
"
ActorRegistryActor
"
type
:
{
global
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
addon
/
addons
"
{
prefix
:
"
addons
"
constructor
:
"
AddonsActor
"
type
:
{
global
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
device
"
{
prefix
:
"
device
"
constructor
:
"
DeviceActor
"
type
:
{
global
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
heap
-
snapshot
-
file
"
{
prefix
:
"
heapSnapshotFile
"
constructor
:
"
HeapSnapshotFileActor
"
type
:
{
global
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
perf
"
{
prefix
:
"
perf
"
constructor
:
"
PerfActor
"
type
:
{
global
:
true
}
}
)
;
}
_addTabActors
(
)
{
this
.
registerModule
(
"
devtools
/
server
/
actors
/
webconsole
"
{
prefix
:
"
console
"
constructor
:
"
WebConsoleActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
inspector
/
inspector
"
{
prefix
:
"
inspector
"
constructor
:
"
InspectorActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
call
-
watcher
"
{
prefix
:
"
callWatcher
"
constructor
:
"
CallWatcherActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
canvas
"
{
prefix
:
"
canvas
"
constructor
:
"
CanvasActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
webgl
"
{
prefix
:
"
webgl
"
constructor
:
"
WebGLActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
webaudio
"
{
prefix
:
"
webaudio
"
constructor
:
"
WebAudioActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
stylesheets
"
{
prefix
:
"
styleSheets
"
constructor
:
"
StyleSheetsActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
storage
"
{
prefix
:
"
storage
"
constructor
:
"
StorageActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
gcli
"
{
prefix
:
"
gcli
"
constructor
:
"
GcliActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
memory
"
{
prefix
:
"
memory
"
constructor
:
"
MemoryActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
framerate
"
{
prefix
:
"
framerate
"
constructor
:
"
FramerateActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
reflow
"
{
prefix
:
"
reflow
"
constructor
:
"
ReflowActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
css
-
properties
"
{
prefix
:
"
cssProperties
"
constructor
:
"
CssPropertiesActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
csscoverage
"
{
prefix
:
"
cssUsage
"
constructor
:
"
CSSUsageActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
timeline
"
{
prefix
:
"
timeline
"
constructor
:
"
TimelineActor
"
type
:
{
tab
:
true
}
}
)
;
if
(
"
nsIProfiler
"
in
Ci
&
&
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
performance
.
new
-
panel
-
enabled
"
false
)
)
{
this
.
registerModule
(
"
devtools
/
server
/
actors
/
performance
"
{
prefix
:
"
performance
"
constructor
:
"
PerformanceActor
"
type
:
{
tab
:
true
}
}
)
;
}
this
.
registerModule
(
"
devtools
/
server
/
actors
/
animation
"
{
prefix
:
"
animations
"
constructor
:
"
AnimationsActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
promises
"
{
prefix
:
"
promises
"
constructor
:
"
PromisesActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
emulation
"
{
prefix
:
"
emulation
"
constructor
:
"
EmulationActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
addon
/
webextension
-
inspected
-
window
"
{
prefix
:
"
webExtensionInspectedWindow
"
constructor
:
"
WebExtensionInspectedWindowActor
"
type
:
{
tab
:
true
}
}
)
;
this
.
registerModule
(
"
devtools
/
server
/
actors
/
accessibility
"
{
prefix
:
"
accessibility
"
constructor
:
"
AccessibilityActor
"
type
:
{
tab
:
true
}
}
)
;
}
setAddonOptions
(
id
options
)
{
if
(
!
this
.
_initialized
)
{
return
Promise
.
resolve
(
)
;
}
const
promises
=
[
]
;
for
(
const
connID
of
Object
.
getOwnPropertyNames
(
this
.
_connections
)
)
{
promises
.
push
(
this
.
_connections
[
connID
]
.
setAddonOptions
(
id
options
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
get
listeningSockets
(
)
{
return
this
.
_listeners
.
length
;
}
createListener
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
remote
-
enabled
"
)
)
{
throw
new
Error
(
"
Can
'
t
create
listener
remote
debugging
disabled
"
)
;
}
this
.
_checkInit
(
)
;
return
DebuggerSocket
.
createListener
(
)
;
}
_addListener
(
listener
)
{
this
.
_listeners
.
push
(
listener
)
;
}
_removeListener
(
listener
)
{
this
.
_listeners
=
this
.
_listeners
.
filter
(
l
=
>
l
!
=
=
listener
)
;
}
closeAllListeners
(
)
{
if
(
!
this
.
listeningSockets
)
{
return
false
;
}
for
(
const
listener
of
this
.
_listeners
)
{
listener
.
close
(
)
;
}
return
true
;
}
connectPipe
(
prefix
)
{
this
.
_checkInit
(
)
;
const
serverTransport
=
new
LocalDebuggerTransport
(
)
;
const
clientTransport
=
new
LocalDebuggerTransport
(
serverTransport
)
;
serverTransport
.
other
=
clientTransport
;
const
connection
=
this
.
_onConnection
(
serverTransport
prefix
)
;
clientTransport
.
_serverConnection
=
connection
;
return
clientTransport
;
}
connectToParent
(
prefix
scopeOrManager
)
{
this
.
_checkInit
(
)
;
const
transport
=
isWorker
?
new
WorkerDebuggerTransport
(
scopeOrManager
prefix
)
:
new
ChildDebuggerTransport
(
scopeOrManager
prefix
)
;
return
this
.
_onConnection
(
transport
prefix
true
)
;
}
connectToContentProcess
(
connection
mm
onDestroy
)
{
return
new
Promise
(
resolve
=
>
{
const
prefix
=
connection
.
allocID
(
"
content
-
process
"
)
;
let
actor
childTransport
;
mm
.
addMessageListener
(
"
debug
:
content
-
process
-
actor
"
function
listener
(
msg
)
{
mm
.
removeMessageListener
(
"
debug
:
content
-
process
-
actor
"
listener
)
;
childTransport
=
new
ChildDebuggerTransport
(
mm
prefix
)
;
childTransport
.
hooks
=
{
onPacket
:
connection
.
send
.
bind
(
connection
)
onClosed
(
)
{
}
}
;
childTransport
.
ready
(
)
;
connection
.
setForwarding
(
prefix
childTransport
)
;
dumpn
(
Start
forwarding
for
process
with
prefix
{
prefix
}
)
;
actor
=
msg
.
json
.
actor
;
resolve
(
actor
)
;
}
)
;
if
(
!
this
.
_contentProcessServerStartupScriptLoaded
)
{
Services
.
ppmm
.
loadProcessScript
(
CONTENT_PROCESS_SERVER_STARTUP_SCRIPT
true
)
;
this
.
_contentProcessServerStartupScriptLoaded
=
true
;
}
mm
.
sendAsyncMessage
(
"
debug
:
init
-
content
-
server
"
{
prefix
:
prefix
}
)
;
function
onClose
(
)
{
Services
.
obs
.
removeObserver
(
onMessageManagerClose
"
message
-
manager
-
close
"
)
;
EventEmitter
.
off
(
connection
"
closed
"
onClose
)
;
if
(
childTransport
)
{
childTransport
.
close
(
)
;
childTransport
=
null
;
connection
.
cancelForwarding
(
prefix
)
;
try
{
mm
.
sendAsyncMessage
(
"
debug
:
content
-
process
-
destroy
"
)
;
}
catch
(
e
)
{
}
}
if
(
onDestroy
)
{
onDestroy
(
mm
)
;
}
}
const
onMessageManagerClose
=
DevToolsUtils
.
makeInfallible
(
(
subject
topic
data
)
=
>
{
if
(
subject
=
=
mm
)
{
onClose
(
)
;
connection
.
send
(
{
from
:
actor
.
actor
type
:
"
tabDetached
"
}
)
;
}
}
)
;
Services
.
obs
.
addObserver
(
onMessageManagerClose
"
message
-
manager
-
close
"
)
;
EventEmitter
.
on
(
connection
"
closed
"
onClose
)
;
}
)
;
}
connectToWorker
(
connection
dbg
id
options
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
!
dbg
.
isInitialized
)
{
dbg
.
initialize
(
"
resource
:
/
/
devtools
/
server
/
startup
/
worker
.
js
"
)
;
const
listener
=
{
onClose
:
(
)
=
>
{
dbg
.
removeListener
(
listener
)
;
}
onMessage
:
(
message
)
=
>
{
message
=
JSON
.
parse
(
message
)
;
if
(
message
.
type
!
=
=
"
rpc
"
)
{
return
;
}
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
const
method
=
{
"
fetch
"
:
DevToolsUtils
.
fetch
}
[
message
.
method
]
;
if
(
!
method
)
{
throw
Error
(
"
Unknown
method
:
"
+
message
.
method
)
;
}
return
method
.
apply
(
undefined
message
.
params
)
;
}
)
.
then
(
(
value
)
=
>
{
dbg
.
postMessage
(
JSON
.
stringify
(
{
type
:
"
rpc
"
result
:
value
error
:
null
id
:
message
.
id
}
)
)
;
}
(
reason
)
=
>
{
dbg
.
postMessage
(
JSON
.
stringify
(
{
type
:
"
rpc
"
result
:
null
error
:
reason
id
:
message
.
id
}
)
)
;
}
)
;
}
}
;
dbg
.
addListener
(
listener
)
;
}
dbg
.
postMessage
(
JSON
.
stringify
(
{
type
:
"
connect
"
id
options
}
)
)
;
const
listener
=
{
onClose
:
(
)
=
>
{
dbg
.
removeListener
(
listener
)
;
reject
(
"
closed
"
)
;
}
onMessage
:
(
message
)
=
>
{
message
=
JSON
.
parse
(
message
)
;
if
(
message
.
type
!
=
=
"
connected
"
|
|
message
.
id
!
=
=
id
)
{
return
;
}
dbg
.
removeListener
(
listener
)
;
const
transport
=
new
WorkerDebuggerTransport
(
dbg
id
)
;
transport
.
ready
(
)
;
transport
.
hooks
=
{
onClosed
:
(
)
=
>
{
if
(
!
dbg
.
isClosed
)
{
try
{
dbg
.
postMessage
(
JSON
.
stringify
(
{
type
:
"
disconnect
"
id
}
)
)
;
}
catch
(
e
)
{
}
}
connection
.
cancelForwarding
(
id
)
;
}
onPacket
:
(
packet
)
=
>
{
connection
.
send
(
packet
)
;
}
}
;
connection
.
setForwarding
(
id
transport
)
;
resolve
(
{
threadActor
:
message
.
threadActor
consoleActor
:
message
.
consoleActor
transport
:
transport
}
)
;
}
}
;
dbg
.
addListener
(
listener
)
;
}
)
;
}
get
isInChildProcess
(
)
{
return
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
;
}
setupInChild
(
{
module
setupChild
args
waitForEval
}
)
{
if
(
this
.
_childMessageManagers
.
size
=
=
0
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
done
=
>
{
if
(
typeof
(
waitForEval
)
!
=
"
boolean
"
)
{
waitForEval
=
false
;
}
let
count
=
this
.
_childMessageManagers
.
size
;
const
id
=
waitForEval
?
generateUUID
(
)
.
toString
(
)
:
null
;
this
.
_childMessageManagers
.
forEach
(
mm
=
>
{
if
(
waitForEval
)
{
const
evalListener
=
msg
=
>
{
if
(
msg
.
data
.
id
!
=
=
id
)
{
return
;
}
mm
.
removeMessageListener
(
"
debug
:
setup
-
in
-
child
-
response
"
evalListener
)
;
if
(
-
-
count
=
=
=
0
)
{
done
(
)
;
}
}
;
mm
.
addMessageListener
(
"
debug
:
setup
-
in
-
child
-
response
"
evalListener
)
;
}
mm
.
sendAsyncMessage
(
"
debug
:
setup
-
in
-
child
"
{
module
:
module
setupChild
:
setupChild
args
:
args
id
:
id
}
)
;
}
)
;
if
(
!
waitForEval
)
{
done
(
)
;
}
}
)
;
}
_childMessageManagers
:
new
Set
(
)
connectToFrame
(
connection
frame
onDestroy
{
addonId
}
=
{
}
)
{
return
new
Promise
(
resolve
=
>
{
let
mm
=
frame
.
messageManager
|
|
frame
.
frameLoader
.
messageManager
;
mm
.
loadFrameScript
(
"
resource
:
/
/
devtools
/
server
/
startup
/
frame
.
js
"
false
)
;
const
trackMessageManager
=
(
)
=
>
{
frame
.
addEventListener
(
"
DevTools
:
BrowserSwap
"
onBrowserSwap
)
;
mm
.
addMessageListener
(
"
debug
:
setup
-
in
-
parent
"
onSetupInParent
)
;
if
(
!
actor
)
{
mm
.
addMessageListener
(
"
debug
:
actor
"
onActorCreated
)
;
}
DebuggerServer
.
_childMessageManagers
.
add
(
mm
)
;
}
;
const
untrackMessageManager
=
(
)
=
>
{
frame
.
removeEventListener
(
"
DevTools
:
BrowserSwap
"
onBrowserSwap
)
;
mm
.
removeMessageListener
(
"
debug
:
setup
-
in
-
parent
"
onSetupInParent
)
;
if
(
!
actor
)
{
mm
.
removeMessageListener
(
"
debug
:
actor
"
onActorCreated
)
;
}
DebuggerServer
.
_childMessageManagers
.
delete
(
mm
)
;
}
;
let
actor
childTransport
;
const
prefix
=
connection
.
allocID
(
"
child
"
)
;
const
connPrefix
=
prefix
+
"
/
"
;
const
parentModules
=
[
]
;
const
onSetupInParent
=
function
(
msg
)
{
if
(
msg
.
json
.
prefix
!
=
connPrefix
)
{
return
false
;
}
const
{
module
setupParent
}
=
msg
.
json
;
let
m
;
try
{
m
=
require
(
module
)
;
if
(
!
(
setupParent
in
m
)
)
{
dumpn
(
ERROR
:
module
'
{
module
}
'
does
not
export
'
{
setupParent
}
'
)
;
return
false
;
}
parentModules
.
push
(
m
[
setupParent
]
(
{
mm
prefix
:
connPrefix
}
)
)
;
return
true
;
}
catch
(
e
)
{
const
errorMessage
=
"
Exception
during
actor
module
setup
running
in
the
parent
process
:
"
;
DevToolsUtils
.
reportException
(
errorMessage
+
e
)
;
dumpn
(
ERROR
:
{
errorMessage
}
\
n
\
t
module
:
'
{
module
}
'
\
n
\
t
+
setupParent
:
'
{
setupParent
}
'
\
n
{
DevToolsUtils
.
safeErrorString
(
e
)
}
)
;
return
false
;
}
}
;
const
onActorCreated
=
DevToolsUtils
.
makeInfallible
(
function
(
msg
)
{
if
(
msg
.
json
.
prefix
!
=
prefix
)
{
return
;
}
mm
.
removeMessageListener
(
"
debug
:
actor
"
onActorCreated
)
;
childTransport
=
new
ChildDebuggerTransport
(
mm
prefix
)
;
childTransport
.
hooks
=
{
onPacket
:
connection
.
send
.
bind
(
connection
)
onClosed
(
)
{
}
}
;
childTransport
.
ready
(
)
;
connection
.
setForwarding
(
prefix
childTransport
)
;
dumpn
(
Start
forwarding
for
frame
with
prefix
{
prefix
}
)
;
actor
=
msg
.
json
.
actor
;
resolve
(
actor
)
;
}
)
.
bind
(
this
)
;
const
onBrowserSwap
=
(
{
detail
:
newFrame
}
)
=
>
{
untrackMessageManager
(
)
;
frame
=
newFrame
;
mm
=
frame
.
messageManager
|
|
frame
.
frameLoader
.
messageManager
;
trackMessageManager
(
)
;
parentModules
.
forEach
(
mod
=
>
{
if
(
mod
.
onBrowserSwap
)
{
mod
.
onBrowserSwap
(
mm
)
;
}
}
)
;
if
(
childTransport
)
{
childTransport
.
swapBrowser
(
mm
)
;
}
}
;
const
destroy
=
DevToolsUtils
.
makeInfallible
(
function
(
)
{
EventEmitter
.
off
(
connection
"
closed
"
destroy
)
;
Services
.
obs
.
removeObserver
(
onMessageManagerClose
"
message
-
manager
-
close
"
)
;
parentModules
.
forEach
(
mod
=
>
{
if
(
mod
.
onDisconnected
)
{
mod
.
onDisconnected
(
)
;
}
}
)
;
DebuggerServer
.
emit
(
"
disconnected
-
from
-
child
:
"
+
connPrefix
{
mm
prefix
:
connPrefix
}
)
;
if
(
childTransport
)
{
childTransport
.
close
(
)
;
childTransport
=
null
;
connection
.
cancelForwarding
(
prefix
)
;
try
{
mm
.
sendAsyncMessage
(
"
debug
:
disconnect
"
{
prefix
}
)
;
}
catch
(
e
)
{
}
}
else
{
resolve
(
null
)
;
}
if
(
actor
)
{
connection
.
send
(
{
from
:
actor
.
actor
type
:
"
tabDetached
"
}
)
;
actor
=
null
;
}
if
(
onDestroy
)
{
onDestroy
(
mm
)
;
}
untrackMessageManager
(
)
;
}
)
;
trackMessageManager
(
)
;
const
onMessageManagerClose
=
function
(
subject
topic
data
)
{
if
(
subject
=
=
mm
)
{
destroy
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
onMessageManagerClose
"
message
-
manager
-
close
"
)
;
EventEmitter
.
on
(
connection
"
closed
"
destroy
)
;
mm
.
sendAsyncMessage
(
"
debug
:
connect
"
{
prefix
addonId
}
)
;
}
)
;
}
_onConnection
(
transport
forwardingPrefix
noRootActor
=
false
)
{
let
connID
;
if
(
forwardingPrefix
)
{
connID
=
forwardingPrefix
+
"
/
"
;
}
else
{
connID
=
"
server
"
+
loader
.
id
+
"
.
conn
"
+
this
.
_nextConnID
+
+
+
"
.
"
;
}
const
conn
=
new
DebuggerServerConnection
(
connID
transport
)
;
this
.
_connections
[
connID
]
=
conn
;
if
(
!
noRootActor
)
{
conn
.
rootActor
=
this
.
createRootActor
(
conn
)
;
if
(
forwardingPrefix
)
{
conn
.
rootActor
.
actorID
=
forwardingPrefix
+
"
/
root
"
;
}
else
{
conn
.
rootActor
.
actorID
=
"
root
"
;
}
conn
.
addActor
(
conn
.
rootActor
)
;
transport
.
send
(
conn
.
rootActor
.
sayHello
(
)
)
;
}
transport
.
ready
(
)
;
this
.
emit
(
"
connectionchange
"
"
opened
"
conn
)
;
return
conn
;
}
_connectionClosed
(
connection
)
{
delete
this
.
_connections
[
connection
.
prefix
]
;
this
.
emit
(
"
connectionchange
"
"
closed
"
connection
)
;
}
setRootActor
(
actorFactory
)
{
this
.
createRootActor
=
actorFactory
;
}
addTabActor
(
actor
name
)
{
if
(
!
name
)
{
throw
Error
(
"
addTabActor
requires
the
name
argument
"
)
;
}
if
(
[
"
title
"
"
url
"
"
actor
"
]
.
includes
(
name
)
)
{
throw
Error
(
name
+
"
is
not
allowed
"
)
;
}
if
(
DebuggerServer
.
tabActorFactories
.
hasOwnProperty
(
name
)
)
{
throw
Error
(
name
+
"
already
exists
"
)
;
}
DebuggerServer
.
tabActorFactories
[
name
]
=
new
RegisteredActorFactory
(
actor
name
)
;
}
removeTabActor
(
actorOrName
)
{
let
name
;
if
(
typeof
actorOrName
=
=
"
string
"
)
{
name
=
actorOrName
;
}
else
{
const
actor
=
actorOrName
;
for
(
const
factoryName
in
DebuggerServer
.
tabActorFactories
)
{
const
handler
=
DebuggerServer
.
tabActorFactories
[
factoryName
]
;
if
(
(
handler
.
name
&
&
handler
.
name
=
=
actor
.
name
)
|
|
(
handler
.
id
&
&
handler
.
id
=
=
actor
.
id
)
)
{
name
=
factoryName
;
break
;
}
}
}
if
(
!
name
)
{
return
;
}
delete
DebuggerServer
.
tabActorFactories
[
name
]
;
for
(
const
connID
of
Object
.
getOwnPropertyNames
(
this
.
_connections
)
)
{
if
(
this
.
_connections
[
connID
]
.
rootActor
)
{
this
.
_connections
[
connID
]
.
rootActor
.
removeActorByName
(
name
)
;
}
}
}
addGlobalActor
(
actor
name
)
{
if
(
!
name
)
{
throw
Error
(
"
addGlobalActor
requires
the
name
argument
"
)
;
}
if
(
[
"
from
"
"
tabs
"
"
selected
"
]
.
includes
(
name
)
)
{
throw
Error
(
name
+
"
is
not
allowed
"
)
;
}
if
(
DebuggerServer
.
globalActorFactories
.
hasOwnProperty
(
name
)
)
{
throw
Error
(
name
+
"
already
exists
"
)
;
}
DebuggerServer
.
globalActorFactories
[
name
]
=
new
RegisteredActorFactory
(
actor
name
)
;
}
removeGlobalActor
(
actorOrName
)
{
let
name
;
if
(
typeof
actorOrName
=
=
"
string
"
)
{
name
=
actorOrName
;
}
else
{
const
actor
=
actorOrName
;
for
(
const
factoryName
in
DebuggerServer
.
globalActorFactories
)
{
const
handler
=
DebuggerServer
.
globalActorFactories
[
factoryName
]
;
if
(
(
handler
.
name
&
&
handler
.
name
=
=
actor
.
name
)
|
|
(
handler
.
id
&
&
handler
.
id
=
=
actor
.
id
)
)
{
name
=
factoryName
;
break
;
}
}
}
if
(
!
name
)
{
return
;
}
delete
DebuggerServer
.
globalActorFactories
[
name
]
;
for
(
const
connID
of
Object
.
getOwnPropertyNames
(
this
.
_connections
)
)
{
if
(
this
.
_connections
[
connID
]
.
rootActor
)
{
this
.
_connections
[
connID
]
.
rootActor
.
removeActorByName
(
name
)
;
}
}
}
removeContentServerScript
(
)
{
Services
.
ppmm
.
removeDelayedProcessScript
(
CONTENT_PROCESS_SERVER_STARTUP_SCRIPT
)
;
try
{
Services
.
ppmm
.
broadcastAsyncMessage
(
"
debug
:
close
-
content
-
server
"
)
;
}
catch
(
e
)
{
}
}
searchAllConnectionsForActor
(
actorID
)
{
for
(
const
connID
of
Object
.
getOwnPropertyNames
(
this
.
_connections
)
)
{
const
actor
=
this
.
_connections
[
connID
]
.
getActor
(
actorID
)
;
if
(
actor
)
{
return
actor
;
}
}
return
null
;
}
}
;
DevToolsUtils
.
defineLazyGetter
(
DebuggerServer
"
Authenticators
"
(
)
=
>
{
return
Authentication
.
Authenticators
;
}
)
;
DevToolsUtils
.
defineLazyGetter
(
DebuggerServer
"
AuthenticationResult
"
(
)
=
>
{
return
Authentication
.
AuthenticationResult
;
}
)
;
EventEmitter
.
decorate
(
DebuggerServer
)
;
if
(
this
.
exports
)
{
exports
.
DebuggerServer
=
DebuggerServer
;
exports
.
ActorPool
=
ActorPool
;
exports
.
OriginalLocation
=
OriginalLocation
;
}
this
.
DebuggerServer
=
DebuggerServer
;
this
.
ActorPool
=
ActorPool
;
this
.
OriginalLocation
=
OriginalLocation
;
var
includes
=
[
"
Components
"
"
Ci
"
"
Cu
"
"
require
"
"
Services
"
"
DebuggerServer
"
"
ActorPool
"
"
DevToolsUtils
"
]
;
includes
.
forEach
(
name
=
>
{
DebuggerServer
[
name
]
=
this
[
name
]
;
}
)
;
function
DebuggerServerConnection
(
prefix
transport
)
{
this
.
_prefix
=
prefix
;
this
.
_transport
=
transport
;
this
.
_transport
.
hooks
=
this
;
this
.
_nextID
=
1
;
this
.
_actorPool
=
new
ActorPool
(
this
)
;
this
.
_extraPools
=
[
this
.
_actorPool
]
;
this
.
_actorResponses
=
new
Map
(
)
;
this
.
_forwardingPrefixes
=
new
Map
(
)
;
}
DebuggerServerConnection
.
prototype
=
{
_prefix
:
null
get
prefix
(
)
{
return
this
.
_prefix
;
}
_transport
:
null
get
transport
(
)
{
return
this
.
_transport
;
}
parentMessageManager
:
null
close
(
)
{
if
(
this
.
_transport
)
{
this
.
_transport
.
close
(
)
;
}
}
send
(
packet
)
{
this
.
transport
.
send
(
packet
)
;
}
startBulkSend
(
header
)
{
return
this
.
transport
.
startBulkSend
(
header
)
;
}
allocID
(
prefix
)
{
return
this
.
prefix
+
(
prefix
|
|
"
"
)
+
this
.
_nextID
+
+
;
}
addActorPool
(
actorPool
)
{
this
.
_extraPools
.
push
(
actorPool
)
;
}
removeActorPool
(
actorPool
noCleanup
)
{
if
(
this
.
_extraPools
=
=
=
null
)
{
return
;
}
const
index
=
this
.
_extraPools
.
lastIndexOf
(
actorPool
)
;
if
(
index
>
-
1
)
{
const
pool
=
this
.
_extraPools
.
splice
(
index
1
)
;
if
(
!
noCleanup
)
{
pool
.
forEach
(
p
=
>
p
.
destroy
(
)
)
;
}
}
}
addActor
(
actor
)
{
this
.
_actorPool
.
addActor
(
actor
)
;
}
removeActor
(
actor
)
{
this
.
_actorPool
.
removeActor
(
actor
)
;
}
unmanage
(
actor
)
{
return
this
.
removeActor
(
actor
)
;
}
getActor
(
actorID
)
{
const
pool
=
this
.
poolFor
(
actorID
)
;
if
(
pool
)
{
return
pool
.
get
(
actorID
)
;
}
if
(
actorID
=
=
=
"
root
"
)
{
return
this
.
rootActor
;
}
return
null
;
}
_getOrCreateActor
(
actorID
)
{
let
actor
=
this
.
getActor
(
actorID
)
;
if
(
!
actor
)
{
this
.
transport
.
send
(
{
from
:
actorID
?
actorID
:
"
root
"
error
:
"
noSuchActor
"
message
:
"
No
such
actor
for
ID
:
"
+
actorID
}
)
;
return
null
;
}
if
(
actor
instanceof
ObservedActorFactory
)
{
try
{
actor
=
actor
.
createActor
(
)
;
}
catch
(
error
)
{
const
prefix
=
"
Error
occurred
while
creating
actor
'
"
+
actor
.
name
;
this
.
transport
.
send
(
this
.
_unknownError
(
actorID
prefix
error
)
)
;
}
}
else
if
(
typeof
(
actor
)
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Unexpected
actor
constructor
/
function
in
ActorPool
"
+
"
for
actorID
=
"
+
actorID
+
"
.
"
)
;
}
return
actor
;
}
poolFor
(
actorID
)
{
for
(
const
pool
of
this
.
_extraPools
)
{
if
(
pool
.
has
(
actorID
)
)
{
return
pool
;
}
}
return
null
;
}
_unknownError
(
from
prefix
error
)
{
const
errorString
=
prefix
+
"
:
"
+
DevToolsUtils
.
safeErrorString
(
error
)
;
reportError
(
errorString
)
;
dumpn
(
errorString
)
;
return
{
from
error
:
"
unknownError
"
message
:
errorString
}
;
}
_queueResponse
:
function
(
from
type
responseOrPromise
)
{
const
pendingResponse
=
this
.
_actorResponses
.
get
(
from
)
|
|
Promise
.
resolve
(
null
)
;
const
responsePromise
=
pendingResponse
.
then
(
(
)
=
>
{
return
responseOrPromise
;
}
)
.
then
(
response
=
>
{
if
(
!
this
.
transport
)
{
throw
new
Error
(
Connection
closed
pending
response
from
{
from
}
+
type
{
type
}
failed
)
;
}
if
(
!
response
.
from
)
{
response
.
from
=
from
;
}
this
.
transport
.
send
(
response
)
;
}
)
.
catch
(
(
error
)
=
>
{
if
(
!
this
.
transport
)
{
throw
new
Error
(
Connection
closed
pending
error
from
{
from
}
+
type
{
type
}
failed
)
;
}
const
prefix
=
"
error
occurred
while
processing
'
"
+
type
;
this
.
transport
.
send
(
this
.
_unknownError
(
from
prefix
error
)
)
;
}
)
;
this
.
_actorResponses
.
set
(
from
responsePromise
)
;
}
setAddonOptions
(
id
options
)
{
const
addonList
=
this
.
rootActor
.
_parameters
.
addonList
;
if
(
!
addonList
)
{
return
Promise
.
resolve
(
)
;
}
return
addonList
.
getList
(
)
.
then
(
(
addonActors
)
=
>
{
for
(
const
actor
of
addonActors
)
{
if
(
actor
.
id
!
=
id
)
{
continue
;
}
actor
.
setOptions
(
options
)
;
return
;
}
}
)
;
}
setForwarding
(
prefix
transport
)
{
this
.
_forwardingPrefixes
.
set
(
prefix
transport
)
;
}
cancelForwarding
(
prefix
)
{
this
.
_forwardingPrefixes
.
delete
(
prefix
)
;
if
(
this
.
rootActor
)
{
this
.
send
(
this
.
rootActor
.
forwardingCancelled
(
prefix
)
)
;
}
}
sendActorEvent
(
actorID
eventName
event
=
{
}
)
{
event
.
from
=
actorID
;
event
.
type
=
eventName
;
this
.
send
(
event
)
;
}
onPacket
(
packet
)
{
if
(
this
.
_forwardingPrefixes
.
size
>
0
)
{
let
to
=
packet
.
to
;
let
separator
=
to
.
lastIndexOf
(
"
/
"
)
;
while
(
separator
>
=
0
)
{
to
=
to
.
substring
(
0
separator
)
;
const
forwardTo
=
this
.
_forwardingPrefixes
.
get
(
packet
.
to
.
substring
(
0
separator
)
)
;
if
(
forwardTo
)
{
forwardTo
.
send
(
packet
)
;
return
;
}
separator
=
to
.
lastIndexOf
(
"
/
"
)
;
}
}
const
actor
=
this
.
_getOrCreateActor
(
packet
.
to
)
;
if
(
!
actor
)
{
return
;
}
let
ret
=
null
;
if
(
packet
.
type
=
=
"
requestTypes
"
)
{
ret
=
{
from
:
actor
.
actorID
requestTypes
:
Object
.
keys
(
actor
.
requestTypes
)
}
;
}
else
if
(
actor
.
requestTypes
&
&
actor
.
requestTypes
[
packet
.
type
]
)
{
try
{
this
.
currentPacket
=
packet
;
ret
=
actor
.
requestTypes
[
packet
.
type
]
.
bind
(
actor
)
(
packet
this
)
;
}
catch
(
error
)
{
const
prefix
=
"
error
occurred
while
processing
'
"
+
packet
.
type
;
this
.
transport
.
send
(
this
.
_unknownError
(
actor
.
actorID
prefix
error
)
)
;
}
finally
{
this
.
currentPacket
=
undefined
;
}
}
else
{
ret
=
{
error
:
"
unrecognizedPacketType
"
message
:
(
"
Actor
"
+
actor
.
actorID
+
"
does
not
recognize
the
packet
type
"
+
packet
.
type
)
}
;
}
if
(
ret
)
{
this
.
_queueResponse
(
packet
.
to
packet
.
type
ret
)
;
}
}
onBulkPacket
(
packet
)
{
const
{
actor
:
actorKey
type
}
=
packet
;
const
actor
=
this
.
_getOrCreateActor
(
actorKey
)
;
if
(
!
actor
)
{
return
;
}
let
ret
;
if
(
actor
.
requestTypes
&
&
actor
.
requestTypes
[
type
]
)
{
try
{
ret
=
actor
.
requestTypes
[
type
]
.
call
(
actor
packet
)
;
}
catch
(
error
)
{
const
prefix
=
"
error
occurred
while
processing
bulk
packet
'
"
+
type
;
this
.
transport
.
send
(
this
.
_unknownError
(
actorKey
prefix
error
)
)
;
packet
.
done
.
reject
(
error
)
;
}
}
else
{
const
message
=
"
Actor
"
+
actorKey
+
"
does
not
recognize
the
bulk
packet
type
"
+
type
;
ret
=
{
error
:
"
unrecognizedPacketType
"
message
:
message
}
;
packet
.
done
.
reject
(
new
Error
(
message
)
)
;
}
if
(
ret
)
{
this
.
_queueResponse
(
actorKey
type
ret
)
;
}
}
onClosed
(
status
)
{
dumpn
(
"
Cleaning
up
connection
.
"
)
;
if
(
!
this
.
_actorPool
)
{
return
;
}
this
.
_actorPool
=
null
;
EventEmitter
.
emit
(
this
"
closed
"
status
)
;
this
.
_extraPools
.
forEach
(
p
=
>
p
.
destroy
(
)
)
;
this
.
_extraPools
=
null
;
this
.
rootActor
=
null
;
this
.
_transport
=
null
;
DebuggerServer
.
_connectionClosed
(
this
)
;
}
_dumpPools
(
)
{
dumpn
(
"
/
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
dumping
pools
:
"
)
;
if
(
this
.
_actorPool
)
{
dumpn
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
actorPool
actors
:
"
+
uneval
(
Object
.
keys
(
this
.
_actorPool
.
_actors
)
)
)
;
}
for
(
const
pool
of
this
.
_extraPools
)
{
if
(
pool
!
=
=
this
.
_actorPool
)
{
dumpn
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
extraPool
actors
:
"
+
uneval
(
Object
.
keys
(
pool
.
_actors
)
)
)
;
}
}
}
_dumpPool
(
pool
)
{
dumpn
(
"
/
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
dumping
pool
:
"
)
;
dumpn
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
actorPool
actors
:
"
+
uneval
(
Object
.
keys
(
pool
.
_actors
)
)
)
;
}
setupInParent
(
{
module
setupParent
}
)
{
if
(
!
this
.
parentMessageManager
)
{
return
false
;
}
const
{
sendSyncMessage
}
=
this
.
parentMessageManager
;
return
sendSyncMessage
(
"
debug
:
setup
-
in
-
parent
"
{
prefix
:
this
.
prefix
module
:
module
setupParent
:
setupParent
}
)
;
}
}
;
