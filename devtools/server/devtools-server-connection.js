"
use
strict
"
;
var
{
Pool
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
{
dumpn
}
=
DevToolsUtils
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsServer
"
"
devtools
/
server
/
devtools
-
server
"
true
)
;
function
DevToolsServerConnection
(
prefix
transport
socketListener
)
{
this
.
_prefix
=
prefix
;
this
.
_transport
=
transport
;
this
.
_transport
.
hooks
=
this
;
this
.
_nextID
=
1
;
this
.
_socketListener
=
socketListener
;
this
.
_actorPool
=
new
Pool
(
this
"
server
-
connection
"
)
;
this
.
_extraPools
=
[
this
.
_actorPool
]
;
this
.
_actorResponses
=
new
Map
(
)
;
this
.
_forwardingPrefixes
=
new
Map
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
DevToolsServerConnection
=
DevToolsServerConnection
;
DevToolsServerConnection
.
prototype
=
{
_prefix
:
null
get
prefix
(
)
{
return
this
.
_prefix
;
}
get
parentPrefix
(
)
{
this
.
prefix
.
replace
(
/
child
\
d
+
\
/
/
"
"
)
;
}
_transport
:
null
get
transport
(
)
{
return
this
.
_transport
;
}
parentMessageManager
:
null
close
(
options
)
{
if
(
this
.
_transport
)
{
this
.
_transport
.
close
(
options
)
;
}
}
send
(
packet
)
{
this
.
transport
.
send
(
packet
)
;
}
startBulkSend
(
header
)
{
return
this
.
transport
.
startBulkSend
(
header
)
;
}
allocID
(
prefix
)
{
return
this
.
prefix
+
(
prefix
|
|
"
"
)
+
this
.
_nextID
+
+
;
}
addActorPool
(
actorPool
)
{
this
.
_extraPools
.
push
(
actorPool
)
;
}
removeActorPool
(
actorPool
)
{
if
(
this
.
_extraPools
=
=
=
null
)
{
return
;
}
const
index
=
this
.
_extraPools
.
lastIndexOf
(
actorPool
)
;
if
(
index
>
-
1
)
{
this
.
_extraPools
.
splice
(
index
1
)
;
}
}
addActor
(
actor
)
{
this
.
_actorPool
.
manage
(
actor
)
;
}
removeActor
(
actor
)
{
this
.
_actorPool
.
unmanage
(
actor
)
;
}
unmanage
(
actor
)
{
return
this
.
removeActor
(
actor
)
;
}
getActor
(
actorID
)
{
const
pool
=
this
.
poolFor
(
actorID
)
;
if
(
pool
)
{
return
pool
.
getActorByID
(
actorID
)
;
}
if
(
actorID
=
=
=
"
root
"
)
{
return
this
.
rootActor
;
}
return
null
;
}
_getOrCreateActor
(
actorID
)
{
try
{
const
actor
=
this
.
getActor
(
actorID
)
;
if
(
!
actor
)
{
this
.
transport
.
send
(
{
from
:
actorID
?
actorID
:
"
root
"
error
:
"
noSuchActor
"
message
:
"
No
such
actor
for
ID
:
"
+
actorID
}
)
;
return
null
;
}
if
(
typeof
actor
!
=
=
"
object
"
)
{
throw
new
Error
(
Unexpected
actor
constructor
/
function
in
Pool
for
actorID
"
{
actorID
}
"
.
)
;
}
return
actor
;
}
catch
(
error
)
{
const
prefix
=
Error
occurred
while
creating
actor
'
{
actorID
}
;
this
.
transport
.
send
(
this
.
_unknownError
(
actorID
prefix
error
)
)
;
}
return
null
;
}
poolFor
(
actorID
)
{
for
(
const
pool
of
this
.
_extraPools
)
{
if
(
pool
.
has
(
actorID
)
)
{
return
pool
;
}
}
return
null
;
}
_unknownError
(
from
prefix
error
)
{
const
errorString
=
prefix
+
"
:
"
+
DevToolsUtils
.
safeErrorString
(
error
)
;
reportError
(
errorString
)
;
dumpn
(
errorString
)
;
return
{
from
error
:
"
unknownError
"
message
:
errorString
}
;
}
_queueResponse
:
function
(
from
type
responseOrPromise
)
{
const
pendingResponse
=
this
.
_actorResponses
.
get
(
from
)
|
|
Promise
.
resolve
(
null
)
;
const
responsePromise
=
pendingResponse
.
then
(
(
)
=
>
{
return
responseOrPromise
;
}
)
.
then
(
response
=
>
{
if
(
!
this
.
transport
)
{
throw
new
Error
(
Connection
closed
pending
response
from
'
{
from
}
'
+
type
'
{
type
}
'
failed
)
;
}
if
(
!
response
.
from
)
{
response
.
from
=
from
;
}
this
.
transport
.
send
(
response
)
;
}
)
.
catch
(
error
=
>
{
if
(
!
this
.
transport
)
{
throw
new
Error
(
Connection
closed
pending
error
from
'
{
from
}
'
+
type
'
{
type
}
'
failed
)
;
}
const
prefix
=
error
occurred
while
queuing
response
for
'
{
type
}
'
;
this
.
transport
.
send
(
this
.
_unknownError
(
from
prefix
error
)
)
;
}
)
;
this
.
_actorResponses
.
set
(
from
responsePromise
)
;
}
isAcceptedBy
(
socketListener
)
{
return
this
.
_socketListener
=
=
=
socketListener
;
}
setForwarding
(
prefix
transport
)
{
this
.
_forwardingPrefixes
.
set
(
prefix
transport
)
;
}
cancelForwarding
(
prefix
)
{
this
.
_forwardingPrefixes
.
delete
(
prefix
)
;
if
(
this
.
rootActor
)
{
this
.
send
(
this
.
rootActor
.
forwardingCancelled
(
prefix
)
)
;
}
}
sendActorEvent
(
actorID
eventName
event
=
{
}
)
{
event
.
from
=
actorID
;
event
.
type
=
eventName
;
this
.
send
(
event
)
;
}
onPacket
(
packet
)
{
if
(
this
.
_forwardingPrefixes
.
size
>
0
)
{
let
to
=
packet
.
to
;
let
separator
=
to
.
lastIndexOf
(
"
/
"
)
;
while
(
separator
>
=
0
)
{
to
=
to
.
substring
(
0
separator
)
;
const
forwardTo
=
this
.
_forwardingPrefixes
.
get
(
packet
.
to
.
substring
(
0
separator
)
)
;
if
(
forwardTo
)
{
forwardTo
.
send
(
packet
)
;
return
;
}
separator
=
to
.
lastIndexOf
(
"
/
"
)
;
}
}
const
actor
=
this
.
_getOrCreateActor
(
packet
.
to
)
;
if
(
!
actor
)
{
return
;
}
let
ret
=
null
;
if
(
packet
.
type
=
=
"
requestTypes
"
)
{
ret
=
{
from
:
actor
.
actorID
requestTypes
:
Object
.
keys
(
actor
.
requestTypes
)
}
;
}
else
if
(
actor
.
requestTypes
?
.
[
packet
.
type
]
)
{
try
{
this
.
currentPacket
=
packet
;
ret
=
actor
.
requestTypes
[
packet
.
type
]
.
bind
(
actor
)
(
packet
this
)
;
}
catch
(
error
)
{
let
errorMessage
=
error
;
if
(
error
?
.
error
&
&
error
?
.
message
)
{
errorMessage
=
"
(
{
error
.
error
}
)
{
error
.
message
}
"
;
}
const
prefix
=
error
occurred
while
processing
'
{
packet
.
type
}
'
;
this
.
transport
.
send
(
this
.
_unknownError
(
actor
.
actorID
prefix
errorMessage
)
)
;
}
finally
{
this
.
currentPacket
=
undefined
;
}
}
else
{
ret
=
{
error
:
"
unrecognizedPacketType
"
message
:
Actor
{
actor
.
actorID
}
does
not
recognize
the
packet
type
'
{
packet
.
type
}
'
}
;
}
if
(
ret
)
{
this
.
_queueResponse
(
packet
.
to
packet
.
type
ret
)
;
}
}
onBulkPacket
(
packet
)
{
const
{
actor
:
actorKey
type
}
=
packet
;
const
actor
=
this
.
_getOrCreateActor
(
actorKey
)
;
if
(
!
actor
)
{
return
;
}
let
ret
;
if
(
actor
.
requestTypes
?
.
[
type
]
)
{
try
{
ret
=
actor
.
requestTypes
[
type
]
.
call
(
actor
packet
)
;
}
catch
(
error
)
{
const
prefix
=
error
occurred
while
processing
bulk
packet
'
{
type
}
'
;
this
.
transport
.
send
(
this
.
_unknownError
(
actorKey
prefix
error
)
)
;
packet
.
done
.
reject
(
error
)
;
}
}
else
{
const
message
=
Actor
{
actorKey
}
does
not
recognize
the
bulk
packet
type
'
{
type
}
'
;
ret
=
{
error
:
"
unrecognizedPacketType
"
message
:
message
}
;
packet
.
done
.
reject
(
new
Error
(
message
)
)
;
}
if
(
ret
)
{
this
.
_queueResponse
(
actorKey
type
ret
)
;
}
}
onTransportClosed
(
status
options
)
{
dumpn
(
"
Cleaning
up
connection
.
"
)
;
if
(
!
this
.
_actorPool
)
{
return
;
}
this
.
_actorPool
=
null
;
this
.
emit
(
"
closed
"
status
this
.
prefix
)
;
const
topLevelPools
=
this
.
_extraPools
.
filter
(
p
=
>
p
.
isTopPool
(
)
)
;
topLevelPools
.
forEach
(
p
=
>
p
.
destroy
(
options
)
)
;
this
.
_extraPools
=
null
;
this
.
rootActor
=
null
;
this
.
_transport
=
null
;
DevToolsServer
.
_connectionClosed
(
this
)
;
}
dumpPool
(
pool
output
=
[
]
dumpedPools
)
{
const
actorIds
=
[
]
;
const
children
=
[
]
;
if
(
dumpedPools
.
has
(
pool
)
)
{
return
;
}
dumpedPools
.
add
(
pool
)
;
if
(
!
pool
.
__poolMap
)
{
return
;
}
for
(
const
actor
of
pool
.
poolChildren
(
)
)
{
children
.
push
(
actor
)
;
actorIds
.
push
(
actor
.
actorID
)
;
}
const
label
=
pool
.
label
|
|
pool
.
actorID
;
output
.
push
(
[
label
actorIds
]
)
;
dump
(
-
{
label
}
:
{
JSON
.
stringify
(
actorIds
)
}
\
n
)
;
children
.
forEach
(
childPool
=
>
this
.
dumpPool
(
childPool
output
dumpedPools
)
)
;
}
dumpPools
(
)
{
const
output
=
[
]
;
const
dumpedPools
=
new
Set
(
)
;
this
.
_extraPools
.
forEach
(
pool
=
>
this
.
dumpPool
(
pool
output
dumpedPools
)
)
;
return
output
;
}
setupInParent
(
{
module
setupParent
}
)
{
if
(
!
this
.
parentMessageManager
)
{
return
false
;
}
return
this
.
parentMessageManager
.
sendSyncMessage
(
"
debug
:
setup
-
in
-
parent
"
{
prefix
:
this
.
prefix
module
:
module
setupParent
:
setupParent
}
)
;
}
spawnActorInParentProcess
(
spawnedByActorID
{
module
constructor
args
}
)
{
if
(
!
this
.
parentMessageManager
)
{
return
null
;
}
const
mm
=
this
.
parentMessageManager
;
const
onResponse
=
new
Promise
(
done
=
>
{
const
listener
=
msg
=
>
{
if
(
msg
.
json
.
prefix
!
=
this
.
prefix
)
{
return
;
}
mm
.
removeMessageListener
(
"
debug
:
spawn
-
actor
-
in
-
parent
:
actor
"
listener
)
;
done
(
msg
.
json
.
actorID
)
;
}
;
mm
.
addMessageListener
(
"
debug
:
spawn
-
actor
-
in
-
parent
:
actor
"
listener
)
;
}
)
;
mm
.
sendAsyncMessage
(
"
debug
:
spawn
-
actor
-
in
-
parent
"
{
prefix
:
this
.
prefix
module
constructor
args
spawnedByActorID
}
)
;
return
onResponse
;
}
}
;
