"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DevToolsFrameChild
"
]
;
const
{
EventEmitter
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
Loader
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
TargetActorRegistry
:
"
resource
:
/
/
devtools
/
server
/
actors
/
targets
/
target
-
actor
-
registry
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
WindowGlobalLogger
:
"
resource
:
/
/
devtools
/
server
/
connectors
/
js
-
window
-
actor
/
WindowGlobalLogger
.
jsm
"
}
)
;
const
isEveryFrameTargetEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
every
-
frame
-
target
.
enabled
"
false
)
;
const
SHARED_DATA_KEY_NAME
=
"
DevTools
:
watchedPerWatcher
"
;
function
shouldNotifyWindowGlobal
(
windowGlobal
context
{
acceptTopLevelTarget
=
false
}
)
{
const
browsingContext
=
windowGlobal
.
browsingContext
;
const
window
=
Services
.
wm
.
getCurrentInnerWindowWithId
(
windowGlobal
.
innerWindowId
)
;
if
(
window
.
document
.
isInitialDocument
)
{
return
false
;
}
if
(
context
.
type
=
=
"
browser
-
element
"
&
&
browsingContext
.
browserId
!
=
context
.
browserId
)
{
return
false
;
}
if
(
!
acceptTopLevelTarget
&
&
context
.
type
=
=
"
browser
-
element
"
&
&
!
browsingContext
.
parent
)
{
return
false
;
}
if
(
!
isEveryFrameTargetEnabled
&
&
!
windowGlobal
.
isProcessRoot
)
{
return
false
;
}
return
true
;
}
const
DEBUG
=
false
;
function
logWindowGlobal
(
windowGlobal
message
)
{
if
(
!
DEBUG
)
{
return
;
}
WindowGlobalLogger
.
logWindowGlobal
(
windowGlobal
message
)
;
}
class
DevToolsFrameChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
_connections
=
new
Map
(
)
;
this
.
_onConnectionChange
=
this
.
_onConnectionChange
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
isBfcacheInParentEnabled
"
(
)
=
>
Services
.
appinfo
.
sessionHistoryInParent
&
&
Services
.
prefs
.
getBoolPref
(
"
fission
.
bfcacheInParent
"
false
)
)
;
}
instantiate
(
{
isBFCache
=
false
ignoreIfExisting
=
false
}
=
{
}
)
{
const
{
sharedData
}
=
Services
.
cpmm
;
const
sessionDataByWatcherActor
=
sharedData
.
get
(
SHARED_DATA_KEY_NAME
)
;
if
(
!
sessionDataByWatcherActor
)
{
throw
new
Error
(
"
Request
to
instantiate
the
target
(
s
)
for
the
BrowsingContext
but
sharedData
is
empty
about
watched
targets
"
)
;
}
for
(
const
[
watcherActorID
sessionData
]
of
sessionDataByWatcherActor
)
{
const
{
connectionPrefix
context
isServerTargetSwitchingEnabled
}
=
sessionData
;
const
acceptTopLevelTarget
=
isServerTargetSwitchingEnabled
|
|
(
isBFCache
&
&
this
.
isBfcacheInParentEnabled
)
;
if
(
sessionData
.
targets
.
includes
(
"
frame
"
)
&
&
shouldNotifyWindowGlobal
(
this
.
manager
context
{
acceptTopLevelTarget
}
)
)
{
const
existingTarget
=
this
.
_findTargetActor
(
{
watcherActorID
context
browsingContextId
:
this
.
manager
.
browsingContext
.
id
}
)
;
if
(
existingTarget
&
&
ignoreIfExisting
)
{
continue
;
}
if
(
existingTarget
&
&
!
existingTarget
.
createdFromJsWindowActor
&
&
!
isBFCache
)
{
continue
;
}
if
(
existingTarget
)
{
existingTarget
.
destroy
(
{
isTargetSwitching
:
true
}
)
;
}
this
.
_createTargetActor
(
{
watcherActorID
parentConnectionPrefix
:
connectionPrefix
sessionData
isDocumentCreation
:
true
}
)
;
}
}
}
_createTargetActor
(
{
watcherActorID
parentConnectionPrefix
sessionData
isDocumentCreation
fromInstantiateAlreadyAvailable
}
)
{
if
(
this
.
_connections
.
get
(
watcherActorID
)
)
{
if
(
fromInstantiateAlreadyAvailable
)
{
return
;
}
throw
new
Error
(
"
DevToolsFrameChild
_createTargetActor
was
called
more
than
once
"
+
for
the
same
Watcher
(
Actor
ID
:
"
{
watcherActorID
}
"
)
)
;
}
const
forwardingPrefix
=
parentConnectionPrefix
+
"
windowGlobal
"
+
this
.
manager
.
innerWindowId
;
logWindowGlobal
(
this
.
manager
"
Instantiate
WindowGlobalTarget
with
prefix
:
"
+
forwardingPrefix
)
;
const
browsingContext
=
this
.
manager
.
browsingContext
;
const
isTopLevelTarget
=
!
browsingContext
.
parent
&
&
browsingContext
.
browserId
=
=
sessionData
.
context
.
browserId
;
const
{
connection
targetActor
}
=
this
.
_createConnectionAndActor
(
forwardingPrefix
isTopLevelTarget
)
;
targetActor
.
createdFromJsWindowActor
=
true
;
this
.
_connections
.
set
(
watcherActorID
{
connection
actor
:
targetActor
}
)
;
this
.
sendAsyncMessage
(
"
DevToolsFrameChild
:
connectFromContent
"
{
watcherActorID
forwardingPrefix
actor
:
targetActor
.
form
(
)
}
)
;
for
(
const
type
in
sessionData
)
{
const
entries
=
sessionData
[
type
]
;
if
(
!
Array
.
isArray
(
entries
)
|
|
entries
.
length
=
=
0
)
{
continue
;
}
targetActor
.
addSessionDataEntry
(
type
entries
isDocumentCreation
)
;
}
}
_destroyTargetActor
(
watcherActorID
)
{
const
connectionInfo
=
this
.
_connections
.
get
(
watcherActorID
)
;
if
(
!
connectionInfo
)
{
throw
new
Error
(
Trying
to
destroy
a
target
actor
that
doesn
'
t
exists
or
has
already
been
destroyed
.
Watcher
Actor
ID
:
{
watcherActorID
}
)
;
}
connectionInfo
.
connection
.
close
(
)
;
this
.
_connections
.
delete
(
watcherActorID
)
;
if
(
this
.
_connections
.
size
=
=
0
)
{
this
.
didDestroy
(
)
;
}
}
_createConnectionAndActor
(
forwardingPrefix
isTopLevelTarget
)
{
this
.
useCustomLoader
=
this
.
document
.
nodePrincipal
.
isSystemPrincipal
;
if
(
!
this
.
loader
)
{
this
.
loader
=
this
.
useCustomLoader
?
new
Loader
.
DevToolsLoader
(
{
invisibleToDebugger
:
true
}
)
:
Loader
;
}
const
{
DevToolsServer
}
=
this
.
loader
.
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
const
{
WindowGlobalTargetActor
}
=
this
.
loader
.
require
(
"
devtools
/
server
/
actors
/
targets
/
window
-
global
"
)
;
DevToolsServer
.
init
(
)
;
DevToolsServer
.
registerActors
(
{
target
:
true
}
)
;
DevToolsServer
.
on
(
"
connectionchange
"
this
.
_onConnectionChange
)
;
const
connection
=
DevToolsServer
.
connectToParentWindowActor
(
this
forwardingPrefix
)
;
const
targetActor
=
new
WindowGlobalTargetActor
(
connection
{
docShell
:
this
.
docShell
followWindowGlobalLifeCycle
:
true
isTopLevelTarget
ignoreSubFrames
:
isEveryFrameTargetEnabled
}
)
;
targetActor
.
manage
(
targetActor
)
;
targetActor
.
createdFromJsWindowActor
=
true
;
return
{
connection
targetActor
}
;
}
_onConnectionChange
(
)
{
const
{
DevToolsServer
}
=
this
.
loader
.
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
if
(
DevToolsServer
.
hasConnection
(
)
|
|
DevToolsServer
.
keepAlive
)
{
return
;
}
if
(
this
.
_destroyed
)
{
return
;
}
this
.
_destroyed
=
true
;
DevToolsServer
.
off
(
"
connectionchange
"
this
.
_onConnectionChange
)
;
DevToolsServer
.
destroy
(
)
;
}
sendPacket
(
packet
prefix
)
{
this
.
sendAsyncMessage
(
"
DevToolsFrameChild
:
packet
"
{
packet
prefix
}
)
;
}
async
sendQuery
(
msg
args
)
{
try
{
const
res
=
await
super
.
sendQuery
(
msg
args
)
;
return
res
;
}
catch
(
e
)
{
console
.
error
(
"
Failed
to
sendQuery
in
DevToolsFrameChild
"
msg
)
;
console
.
error
(
e
.
toString
(
)
)
;
throw
e
;
}
}
receiveMessage
(
message
)
{
if
(
message
.
name
!
=
"
DevToolsFrameParent
:
packet
"
&
&
message
.
data
.
context
.
type
=
=
"
browser
-
element
"
)
{
const
{
browserId
}
=
message
.
data
.
context
;
if
(
this
.
manager
.
browsingContext
.
browserId
!
=
browserId
&
&
!
shouldNotifyWindowGlobal
(
this
.
manager
browserId
{
acceptTopLevelTarget
:
true
}
)
)
{
throw
new
Error
(
"
Mismatch
between
DevToolsFrameParent
and
DevToolsFrameChild
"
+
(
this
.
manager
.
browsingContext
.
browserId
=
=
browserId
?
"
window
global
shouldn
'
t
be
notified
(
shouldNotifyWindowGlobal
mismatch
)
"
:
expected
browsing
context
with
browserId
{
browserId
}
but
got
{
this
.
manager
.
browsingContext
.
browserId
}
)
)
;
}
}
switch
(
message
.
name
)
{
case
"
DevToolsFrameParent
:
instantiate
-
already
-
available
"
:
{
const
{
watcherActorID
connectionPrefix
sessionData
}
=
message
.
data
;
return
this
.
_createTargetActor
(
{
watcherActorID
parentConnectionPrefix
:
connectionPrefix
sessionData
fromInstantiateAlreadyAvailable
:
true
}
)
;
}
case
"
DevToolsFrameParent
:
destroy
"
:
{
const
{
watcherActorID
}
=
message
.
data
;
return
this
.
_destroyTargetActor
(
watcherActorID
)
;
}
case
"
DevToolsFrameParent
:
addSessionDataEntry
"
:
{
const
{
watcherActorID
context
type
entries
}
=
message
.
data
;
return
this
.
_addSessionDataEntry
(
watcherActorID
context
type
entries
)
;
}
case
"
DevToolsFrameParent
:
removeSessionDataEntry
"
:
{
const
{
watcherActorID
context
type
entries
}
=
message
.
data
;
return
this
.
_removeSessionDataEntry
(
watcherActorID
context
type
entries
)
;
}
case
"
DevToolsFrameParent
:
packet
"
:
return
this
.
emit
(
"
packet
-
received
"
message
)
;
default
:
throw
new
Error
(
"
Unsupported
message
in
DevToolsFrameParent
:
"
+
message
.
name
)
;
}
}
_findTargetActor
(
{
watcherActorID
context
browsingContextId
}
)
{
const
connectionInfo
=
this
.
_connections
.
get
(
watcherActorID
)
;
const
targetActor
=
connectionInfo
?
connectionInfo
.
actor
:
null
;
if
(
targetActor
)
{
return
targetActor
;
}
const
isMatchingBrowserElement
=
this
.
manager
.
browsingContext
.
browserId
=
=
context
.
browserId
;
const
isMatchingWebExtension
=
this
.
document
.
nodePrincipal
.
addonId
=
=
context
.
addonId
;
if
(
(
context
.
type
=
=
"
browser
-
element
"
&
&
isMatchingBrowserElement
)
|
|
(
context
.
type
=
=
"
webextension
"
&
&
isMatchingWebExtension
)
)
{
const
connectionPrefix
=
watcherActorID
.
replace
(
/
watcher
\
d
+
/
"
"
)
;
const
targetActors
=
TargetActorRegistry
.
getTargetActors
(
context
connectionPrefix
)
;
if
(
!
browsingContextId
)
{
return
targetActors
[
0
]
|
|
null
;
}
return
targetActors
.
find
(
actor
=
>
actor
.
browsingContextID
=
=
=
browsingContextId
)
;
}
return
null
;
}
_addSessionDataEntry
(
watcherActorID
context
type
entries
)
{
const
targetActor
=
this
.
_findTargetActor
(
{
watcherActorID
context
}
)
;
if
(
!
targetActor
)
{
throw
new
Error
(
No
target
actor
for
this
Watcher
Actor
ID
:
"
{
watcherActorID
}
"
/
BrowserId
:
{
context
.
browserId
}
)
;
}
return
targetActor
.
addSessionDataEntry
(
type
entries
)
;
}
_removeSessionDataEntry
(
watcherActorID
context
type
entries
)
{
const
targetActor
=
this
.
_findTargetActor
(
{
watcherActorID
context
}
)
;
if
(
targetActor
)
{
return
targetActor
.
removeSessionDataEntry
(
type
entries
)
;
}
return
null
;
}
handleEvent
(
{
type
persisted
target
}
)
{
if
(
target
!
=
this
.
document
)
{
return
;
}
if
(
type
=
=
"
DOMWindowCreated
"
)
{
this
.
instantiate
(
)
;
return
;
}
if
(
type
=
=
"
DOMDocElementInserted
"
)
{
this
.
instantiate
(
{
ignoreIfExisting
:
true
}
)
;
return
;
}
if
(
type
=
=
=
"
pageshow
"
&
&
persisted
)
{
this
.
sendAsyncMessage
(
"
DevToolsFrameChild
:
bf
-
cache
-
navigation
-
pageshow
"
)
;
this
.
instantiate
(
{
isBFCache
:
true
}
)
;
return
;
}
if
(
type
=
=
=
"
pagehide
"
&
&
persisted
)
{
this
.
sendAsyncMessage
(
"
DevToolsFrameChild
:
bf
-
cache
-
navigation
-
pagehide
"
)
;
const
{
sharedData
}
=
Services
.
cpmm
;
const
sessionDataByWatcherActor
=
sharedData
.
get
(
SHARED_DATA_KEY_NAME
)
;
if
(
!
sessionDataByWatcherActor
)
{
throw
new
Error
(
"
Request
to
instantiate
the
target
(
s
)
for
the
BrowsingContext
but
sharedData
is
empty
about
watched
targets
"
)
;
}
const
actors
=
[
]
;
let
allActorsAreDestroyed
=
true
;
for
(
const
[
watcherActorID
sessionData
]
of
sessionDataByWatcherActor
)
{
const
{
context
isServerTargetSwitchingEnabled
}
=
sessionData
;
const
existingTarget
=
this
.
_findTargetActor
(
{
watcherActorID
context
}
)
;
if
(
!
existingTarget
)
{
continue
;
}
if
(
existingTarget
.
originalWindow
.
document
!
=
target
)
{
throw
new
Error
(
"
Existing
target
actor
is
for
a
distinct
document
"
)
;
}
if
(
!
this
.
isBfcacheInParentEnabled
&
&
!
isServerTargetSwitchingEnabled
)
{
allActorsAreDestroyed
=
false
;
continue
;
}
actors
.
push
(
{
watcherActorID
form
:
existingTarget
.
form
(
)
}
)
;
existingTarget
.
destroy
(
)
;
}
if
(
actors
.
length
>
0
)
{
this
.
sendAsyncMessage
(
"
DevToolsFrameChild
:
destroy
"
{
actors
}
)
;
}
if
(
allActorsAreDestroyed
)
{
this
.
didDestroy
(
)
;
}
}
}
didDestroy
(
)
{
logWindowGlobal
(
this
.
manager
"
Destroy
WindowGlobalTarget
"
)
;
for
(
const
[
connectionInfo
]
of
this
.
_connections
)
{
connectionInfo
.
connection
.
close
(
)
;
}
this
.
_connections
.
clear
(
)
;
if
(
this
.
loader
)
{
const
{
DevToolsServer
}
=
this
.
loader
.
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
DevToolsServer
.
off
(
"
connectionchange
"
this
.
_onConnectionChange
)
;
}
if
(
this
.
useCustomLoader
)
{
this
.
loader
.
destroy
(
)
;
}
}
}
