"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DevToolsWorkerChild
"
]
;
const
{
EventEmitter
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
wdm
"
"
mozilla
.
org
/
dom
/
workers
/
workerdebuggermanager
;
1
"
"
nsIWorkerDebuggerManager
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
Loader
"
(
)
=
>
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
jsm
"
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
DevToolsUtils
"
(
)
=
>
Loader
.
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
SessionDataHelpers
:
"
resource
:
/
/
devtools
/
server
/
actors
/
watcher
/
SessionDataHelpers
.
jsm
"
}
)
;
const
SHARED_DATA_KEY_NAME
=
"
DevTools
:
watchedPerWatcher
"
;
class
DevToolsWorkerChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
_connections
=
new
Map
(
)
;
this
.
_onConnectionChange
=
this
.
_onConnectionChange
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
}
_onWorkerRegistered
(
dbg
)
{
if
(
!
this
.
_shouldHandleWorker
(
dbg
)
)
{
return
;
}
for
(
const
[
watcherActorID
{
connection
forwardingPrefix
}
]
of
this
.
_connections
)
{
this
.
_createWorkerTargetActor
(
{
dbg
connection
forwardingPrefix
watcherActorID
}
)
;
}
}
_onWorkerUnregistered
(
dbg
)
{
for
(
const
[
watcherActorID
{
workers
forwardingPrefix
}
]
of
this
.
_connections
)
{
const
unregisteredActorIndex
=
workers
.
findIndex
(
worker
=
>
{
try
{
return
worker
.
dbg
.
id
=
=
=
dbg
.
id
;
}
catch
(
e
)
{
return
false
;
}
}
)
;
if
(
unregisteredActorIndex
=
=
=
-
1
)
{
continue
;
}
const
{
workerTargetForm
transport
}
=
workers
[
unregisteredActorIndex
]
;
transport
.
close
(
)
;
try
{
this
.
sendAsyncMessage
(
"
DevToolsWorkerChild
:
workerTargetDestroyed
"
{
watcherActorID
forwardingPrefix
workerTargetForm
}
)
;
}
catch
(
e
)
{
return
;
}
workers
.
splice
(
unregisteredActorIndex
1
)
;
}
}
onDOMWindowCreated
(
)
{
const
{
sharedData
}
=
Services
.
cpmm
;
const
sessionDataByWatcherActor
=
sharedData
.
get
(
SHARED_DATA_KEY_NAME
)
;
if
(
!
sessionDataByWatcherActor
)
{
throw
new
Error
(
"
Request
to
instantiate
the
target
(
s
)
for
the
Worker
but
sharedData
is
empty
about
watched
targets
"
)
;
}
for
(
const
[
watcherActorID
sessionData
]
of
sessionDataByWatcherActor
)
{
const
{
targets
connectionPrefix
sessionContext
}
=
sessionData
;
if
(
targets
.
includes
(
"
worker
"
)
&
&
shouldNotifyWindowGlobal
(
this
.
manager
sessionContext
)
)
{
this
.
_watchWorkerTargets
(
{
watcherActorID
parentConnectionPrefix
:
connectionPrefix
sessionData
}
)
;
}
}
}
receiveMessage
(
message
)
{
if
(
message
.
name
!
=
"
DevToolsWorkerParent
:
packet
"
)
{
const
{
browserId
}
=
message
.
data
.
sessionContext
;
if
(
this
.
manager
.
browsingContext
.
browserId
!
=
browserId
&
&
!
shouldNotifyWindowGlobal
(
this
.
manager
message
.
data
.
sessionContext
)
)
{
throw
new
Error
(
"
Mismatch
between
DevToolsWorkerParent
and
DevToolsWorkerChild
"
+
(
this
.
manager
.
browsingContext
.
browserId
=
=
browserId
?
"
window
global
shouldn
'
t
be
notified
(
shouldNotifyWindowGlobal
mismatch
)
"
:
expected
browsing
context
with
ID
{
browserId
}
but
got
{
this
.
manager
.
browsingContext
.
browserId
}
)
)
;
}
}
switch
(
message
.
name
)
{
case
"
DevToolsWorkerParent
:
instantiate
-
already
-
available
"
:
{
const
{
watcherActorID
connectionPrefix
sessionData
}
=
message
.
data
;
return
this
.
_watchWorkerTargets
(
{
watcherActorID
parentConnectionPrefix
:
connectionPrefix
sessionData
}
)
;
}
case
"
DevToolsWorkerParent
:
destroy
"
:
{
const
{
watcherActorID
}
=
message
.
data
;
return
this
.
_destroyTargetActors
(
watcherActorID
)
;
}
case
"
DevToolsWorkerParent
:
addSessionDataEntry
"
:
{
const
{
watcherActorID
type
entries
}
=
message
.
data
;
return
this
.
_addSessionDataEntry
(
watcherActorID
type
entries
)
;
}
case
"
DevToolsWorkerParent
:
removeSessionDataEntry
"
:
{
const
{
watcherActorID
type
entries
}
=
message
.
data
;
return
this
.
_removeSessionDataEntry
(
watcherActorID
type
entries
)
;
}
case
"
DevToolsWorkerParent
:
packet
"
:
return
this
.
emit
(
"
packet
-
received
"
message
)
;
default
:
throw
new
Error
(
"
Unsupported
message
in
DevToolsWorkerParent
:
"
+
message
.
name
)
;
}
}
async
_watchWorkerTargets
(
{
watcherActorID
parentConnectionPrefix
sessionData
}
)
{
if
(
this
.
_connections
.
has
(
watcherActorID
)
)
{
throw
new
Error
(
"
DevToolsWorkerChild
_watchWorkerTargets
was
called
more
than
once
"
+
for
the
same
Watcher
(
Actor
ID
:
"
{
watcherActorID
}
"
)
)
;
}
if
(
!
this
.
_workerDebuggerListener
)
{
this
.
_workerDebuggerListener
=
{
onRegister
:
this
.
_onWorkerRegistered
.
bind
(
this
)
onUnregister
:
this
.
_onWorkerUnregistered
.
bind
(
this
)
}
;
wdm
.
addListener
(
this
.
_workerDebuggerListener
)
;
}
const
forwardingPrefix
=
parentConnectionPrefix
+
"
workerGlobal
"
+
this
.
manager
.
innerWindowId
;
const
connection
=
this
.
_createConnection
(
forwardingPrefix
)
;
this
.
_connections
.
set
(
watcherActorID
{
connection
workers
:
[
]
forwardingPrefix
sessionData
}
)
;
await
Promise
.
all
(
Array
.
from
(
wdm
.
getWorkerDebuggerEnumerator
(
)
)
.
filter
(
dbg
=
>
this
.
_shouldHandleWorker
(
dbg
)
)
.
map
(
dbg
=
>
this
.
_createWorkerTargetActor
(
{
dbg
connection
forwardingPrefix
watcherActorID
}
)
)
)
;
}
_createConnection
(
forwardingPrefix
)
{
const
{
DevToolsServer
}
=
Loader
.
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
DevToolsServer
.
init
(
)
;
DevToolsServer
.
registerActors
(
{
target
:
true
}
)
;
DevToolsServer
.
on
(
"
connectionchange
"
this
.
_onConnectionChange
)
;
const
connection
=
DevToolsServer
.
connectToParentWindowActor
(
this
forwardingPrefix
)
;
return
connection
;
}
_shouldHandleWorker
(
dbg
)
{
return
(
DevToolsUtils
.
isWorkerDebuggerAlive
(
dbg
)
&
&
dbg
.
type
=
=
=
Ci
.
nsIWorkerDebugger
.
TYPE_DEDICATED
&
&
dbg
.
windowIDs
.
includes
(
this
.
manager
.
innerWindowId
)
)
;
}
async
_createWorkerTargetActor
(
{
dbg
connection
forwardingPrefix
watcherActorID
}
)
{
try
{
dbg
.
setDebuggerReady
(
false
)
;
}
catch
(
e
)
{
}
const
watcherConnectionData
=
this
.
_connections
.
get
(
watcherActorID
)
;
const
{
sessionData
}
=
watcherConnectionData
;
const
workerThreadServerForwardingPrefix
=
connection
.
allocID
(
"
workerTarget
"
)
;
const
{
connectToWorker
}
=
Loader
.
require
(
"
devtools
/
server
/
connectors
/
worker
-
connector
"
)
;
const
onConnectToWorker
=
connectToWorker
(
connection
dbg
workerThreadServerForwardingPrefix
{
sessionData
}
)
;
try
{
await
onConnectToWorker
;
}
catch
(
e
)
{
if
(
!
dbg
.
isClosed
)
{
dbg
.
setDebuggerReady
(
true
)
;
}
return
;
}
const
{
workerTargetForm
transport
}
=
await
onConnectToWorker
;
try
{
this
.
sendAsyncMessage
(
"
DevToolsWorkerChild
:
workerTargetAvailable
"
{
watcherActorID
forwardingPrefix
workerTargetForm
}
)
;
}
catch
(
e
)
{
transport
.
close
(
)
;
return
;
}
watcherConnectionData
.
workers
.
push
(
{
dbg
transport
workerTargetForm
workerThreadServerForwardingPrefix
}
)
;
}
_destroyTargetActors
(
watcherActorID
)
{
const
watcherConnectionData
=
this
.
_connections
.
get
(
watcherActorID
)
;
this
.
_connections
.
delete
(
watcherActorID
)
;
if
(
!
watcherConnectionData
)
{
console
.
error
(
Trying
to
destroy
a
target
actor
that
doesn
'
t
exists
or
has
already
been
destroyed
.
Watcher
Actor
ID
:
{
watcherActorID
}
)
;
return
;
}
for
(
const
{
dbg
transport
workerThreadServerForwardingPrefix
}
of
watcherConnectionData
.
workers
)
{
try
{
if
(
DevToolsUtils
.
isWorkerDebuggerAlive
(
dbg
)
)
{
dbg
.
postMessage
(
JSON
.
stringify
(
{
type
:
"
disconnect
"
forwardingPrefix
:
workerThreadServerForwardingPrefix
}
)
)
;
}
}
catch
(
e
)
{
}
transport
.
close
(
)
;
}
watcherConnectionData
.
connection
.
close
(
)
;
}
_onConnectionChange
(
)
{
const
{
DevToolsServer
}
=
Loader
.
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
if
(
DevToolsServer
.
hasConnection
(
)
|
|
DevToolsServer
.
keepAlive
)
{
return
;
}
if
(
this
.
_destroyed
)
{
return
;
}
this
.
_destroyed
=
true
;
DevToolsServer
.
off
(
"
connectionchange
"
this
.
_onConnectionChange
)
;
DevToolsServer
.
destroy
(
)
;
}
async
sendPacket
(
packet
prefix
)
{
return
this
.
sendAsyncMessage
(
"
DevToolsWorkerChild
:
packet
"
{
packet
prefix
}
)
;
}
async
_addSessionDataEntry
(
watcherActorID
type
entries
)
{
const
watcherConnectionData
=
this
.
_connections
.
get
(
watcherActorID
)
;
if
(
!
watcherConnectionData
)
{
return
;
}
SessionDataHelpers
.
addSessionDataEntry
(
watcherConnectionData
.
sessionData
type
entries
)
;
const
promises
=
[
]
;
for
(
const
{
dbg
workerThreadServerForwardingPrefix
}
of
watcherConnectionData
.
workers
)
{
promises
.
push
(
addSessionDataEntryInWorkerTarget
(
{
dbg
workerThreadServerForwardingPrefix
type
entries
}
)
)
;
}
await
Promise
.
all
(
promises
)
;
}
_removeSessionDataEntry
(
watcherActorID
type
entries
)
{
const
watcherConnectionData
=
this
.
_connections
.
get
(
watcherActorID
)
;
if
(
!
watcherConnectionData
)
{
return
;
}
SessionDataHelpers
.
removeSessionDataEntry
(
watcherConnectionData
.
sessionData
type
entries
)
;
for
(
const
{
dbg
workerThreadServerForwardingPrefix
}
of
watcherConnectionData
.
workers
)
{
if
(
DevToolsUtils
.
isWorkerDebuggerAlive
(
dbg
)
)
{
dbg
.
postMessage
(
JSON
.
stringify
(
{
type
:
"
remove
-
session
-
data
-
entry
"
forwardingPrefix
:
workerThreadServerForwardingPrefix
dataEntryType
:
type
entries
}
)
)
;
}
}
}
handleEvent
(
{
type
}
)
{
if
(
type
=
=
"
DOMWindowCreated
"
)
{
this
.
onDOMWindowCreated
(
)
;
}
}
_removeExistingWorkerDebuggerListener
(
)
{
if
(
this
.
_workerDebuggerListener
)
{
wdm
.
removeListener
(
this
.
_workerDebuggerListener
)
;
this
.
_workerDebuggerListener
=
null
;
}
}
didDestroy
(
)
{
this
.
_removeExistingWorkerDebuggerListener
(
)
;
for
(
const
[
watcherActorID
watcherConnectionData
]
of
this
.
_connections
)
{
const
{
connection
}
=
watcherConnectionData
;
this
.
_destroyTargetActors
(
watcherActorID
)
;
connection
.
close
(
)
;
}
this
.
_connections
.
clear
(
)
;
}
}
function
shouldNotifyWindowGlobal
(
windowGlobal
sessionContext
)
{
const
browsingContext
=
windowGlobal
.
browsingContext
;
if
(
sessionContext
.
type
=
=
"
browser
-
element
"
&
&
browsingContext
.
browserId
!
=
sessionContext
.
browserId
)
{
return
false
;
}
if
(
Cu
.
isRemoteProxy
(
windowGlobal
.
window
)
)
{
return
false
;
}
return
true
;
}
function
addSessionDataEntryInWorkerTarget
(
{
dbg
workerThreadServerForwardingPrefix
type
entries
}
)
{
if
(
!
DevToolsUtils
.
isWorkerDebuggerAlive
(
dbg
)
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
const
listener
=
{
onMessage
:
message
=
>
{
message
=
JSON
.
parse
(
message
)
;
if
(
message
.
type
=
=
=
"
session
-
data
-
entry
-
added
"
)
{
resolve
(
)
;
dbg
.
removeListener
(
listener
)
;
}
}
onClose
:
(
)
=
>
resolve
(
)
}
;
dbg
.
addListener
(
listener
)
;
dbg
.
postMessage
(
JSON
.
stringify
(
{
type
:
"
add
-
session
-
data
-
entry
"
forwardingPrefix
:
workerThreadServerForwardingPrefix
dataEntryType
:
type
entries
}
)
)
;
}
)
;
}
