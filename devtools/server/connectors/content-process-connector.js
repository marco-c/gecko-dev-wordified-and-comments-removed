"
use
strict
"
;
var
Services
=
require
(
"
Services
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
{
dumpn
}
=
DevToolsUtils
;
var
{
createContentProcessSessionContext
}
=
require
(
"
devtools
/
server
/
actors
/
watcher
/
session
-
context
"
)
;
loader
.
lazyRequireGetter
(
this
"
ChildDebuggerTransport
"
"
devtools
/
shared
/
transport
/
child
-
transport
"
true
)
;
const
CONTENT_PROCESS_SERVER_STARTUP_SCRIPT
=
"
resource
:
/
/
devtools
/
server
/
startup
/
content
-
process
.
js
"
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
function
connectToContentProcess
(
connection
mm
onDestroy
)
{
return
new
Promise
(
resolve
=
>
{
const
prefix
=
connection
.
allocID
(
"
content
-
process
"
)
;
let
actor
childTransport
;
mm
.
addMessageListener
(
"
debug
:
content
-
process
-
actor
"
function
listener
(
msg
)
{
if
(
msg
.
watcherActorID
)
{
return
;
}
mm
.
removeMessageListener
(
"
debug
:
content
-
process
-
actor
"
listener
)
;
childTransport
=
new
ChildDebuggerTransport
(
mm
prefix
)
;
childTransport
.
hooks
=
{
onPacket
:
connection
.
send
.
bind
(
connection
)
}
;
childTransport
.
ready
(
)
;
connection
.
setForwarding
(
prefix
childTransport
)
;
dumpn
(
Start
forwarding
for
process
with
prefix
{
prefix
}
)
;
actor
=
msg
.
json
.
actor
;
resolve
(
actor
)
;
}
)
;
const
isContentProcessServerStartupScripLoaded
=
Services
.
ppmm
.
getDelayedProcessScripts
(
)
.
some
(
(
[
uri
]
)
=
>
uri
=
=
=
CONTENT_PROCESS_SERVER_STARTUP_SCRIPT
)
;
if
(
!
isContentProcessServerStartupScripLoaded
)
{
Services
.
ppmm
.
loadProcessScript
(
CONTENT_PROCESS_SERVER_STARTUP_SCRIPT
true
)
;
}
mm
.
sendAsyncMessage
(
"
debug
:
init
-
content
-
server
"
{
prefix
sessionContext
:
createContentProcessSessionContext
(
)
}
)
;
function
onClose
(
)
{
Services
.
obs
.
removeObserver
(
onMessageManagerClose
"
message
-
manager
-
close
"
)
;
EventEmitter
.
off
(
connection
"
closed
"
onClose
)
;
if
(
childTransport
)
{
childTransport
.
close
(
)
;
childTransport
=
null
;
connection
.
cancelForwarding
(
prefix
)
;
try
{
mm
.
sendAsyncMessage
(
"
debug
:
content
-
process
-
disconnect
"
{
prefix
}
)
;
}
catch
(
e
)
{
}
}
if
(
onDestroy
)
{
onDestroy
(
mm
)
;
}
}
const
onMessageManagerClose
=
DevToolsUtils
.
makeInfallible
(
(
subject
topic
data
)
=
>
{
if
(
subject
=
=
mm
)
{
onClose
(
)
;
}
}
)
;
Services
.
obs
.
addObserver
(
onMessageManagerClose
"
message
-
manager
-
close
"
)
;
EventEmitter
.
on
(
connection
"
closed
"
onClose
)
;
}
)
;
}
exports
.
connectToContentProcess
=
connectToContentProcess
;
