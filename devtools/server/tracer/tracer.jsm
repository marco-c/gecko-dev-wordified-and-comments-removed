"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
startTracing
"
"
stopTracing
"
"
addTracingListener
"
"
removeTracingListener
"
"
NEXT_INTERACTION_MESSAGE
"
"
DOM_MUTATIONS
"
]
;
const
NEXT_INTERACTION_MESSAGE
=
"
Waiting
for
next
user
interaction
before
tracing
(
next
mousedown
or
keydown
event
)
"
;
const
FRAME_EXIT_REASONS
=
{
TERMINATED
:
"
terminated
"
RETURN
:
"
return
"
YIELD
:
"
yield
"
AWAIT
:
"
await
"
THROW
:
"
throw
"
}
;
const
DOM_MUTATIONS
=
{
ADD
:
"
add
"
ATTRIBUTES
:
"
attributes
"
REMOVE
:
"
remove
"
}
;
const
listeners
=
new
Set
(
)
;
const
isWorker
=
globalThis
.
isWorker
|
|
globalThis
.
constructor
.
name
=
=
"
WorkerDebuggerGlobalScope
"
;
const
customLazy
=
{
get
Debugger
(
)
{
if
(
globalThis
.
Debugger
)
{
return
globalThis
.
Debugger
;
}
if
(
isWorker
)
{
return
require
(
"
Debugger
"
)
;
}
const
{
addDebuggerToGlobal
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
sys
.
mjs
"
)
;
const
systemPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
const
debuggerSandbox
=
Cu
.
Sandbox
(
systemPrincipal
)
;
addDebuggerToGlobal
(
debuggerSandbox
)
;
delete
customLazy
.
Debugger
;
customLazy
.
Debugger
=
debuggerSandbox
.
Debugger
;
return
customLazy
.
Debugger
;
}
get
DistinctCompartmentDebugger
(
)
{
const
{
addDebuggerToGlobal
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
sys
.
mjs
"
)
;
const
systemPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
const
debuggerSandbox
=
Cu
.
Sandbox
(
systemPrincipal
{
freshCompartment
:
true
}
)
;
addDebuggerToGlobal
(
debuggerSandbox
)
;
delete
customLazy
.
DistinctCompartmentDebugger
;
customLazy
.
DistinctCompartmentDebugger
=
debuggerSandbox
.
Debugger
;
return
customLazy
.
DistinctCompartmentDebugger
;
}
}
;
class
JavaScriptTracer
{
constructor
(
options
)
{
this
.
onEnterFrame
=
this
.
onEnterFrame
.
bind
(
this
)
;
if
(
!
isWorker
)
{
this
.
abortController
=
new
AbortController
(
)
;
}
this
.
tracedGlobal
=
options
.
global
|
|
Cu
.
getGlobalForObject
(
options
)
;
this
.
dbg
=
this
.
makeDebugger
(
)
;
this
.
prefix
=
options
.
prefix
?
{
options
.
prefix
}
:
:
"
"
;
this
.
pendingAwaitFrames
=
new
Set
(
)
;
this
.
loggingMethod
=
options
.
loggingMethod
;
if
(
!
this
.
loggingMethod
)
{
this
.
loggingMethod
=
isWorker
?
dump
.
bind
(
null
)
:
dump
;
}
this
.
traceDOMEvents
=
!
!
options
.
traceDOMEvents
;
if
(
options
.
traceDOMMutations
)
{
if
(
!
Array
.
isArray
(
options
.
traceDOMMutations
)
)
{
throw
new
Error
(
"
'
traceDOMMutations
'
attribute
should
be
an
array
"
)
;
}
const
acceptedValues
=
Object
.
values
(
DOM_MUTATIONS
)
;
if
(
!
options
.
traceDOMMutations
.
every
(
e
=
>
acceptedValues
.
includes
(
e
)
)
)
{
throw
new
Error
(
'
traceDOMMutations
'
only
accept
array
of
strings
whose
values
can
be
:
{
acceptedValues
}
)
;
}
this
.
traceDOMMutations
=
options
.
traceDOMMutations
;
}
this
.
traceSteps
=
!
!
options
.
traceSteps
;
this
.
traceValues
=
!
!
options
.
traceValues
;
this
.
traceFunctionReturn
=
!
!
options
.
traceFunctionReturn
;
this
.
maxDepth
=
options
.
maxDepth
;
this
.
maxRecords
=
options
.
maxRecords
;
this
.
records
=
0
;
this
.
frameId
=
0
;
if
(
options
.
traceOnNextInteraction
&
&
!
isWorker
)
{
this
.
#
waitForNextInteraction
(
)
;
}
else
{
this
.
#
startTracing
(
)
;
}
}
isTracing
=
false
;
#
waitForNextInteraction
(
)
{
this
.
nextInteractionAbortController
=
new
AbortController
(
)
;
const
listener
=
(
)
=
>
{
this
.
nextInteractionAbortController
.
abort
(
)
;
if
(
this
.
dbg
)
{
this
.
#
startTracing
(
)
;
}
}
;
const
eventOptions
=
{
signal
:
this
.
nextInteractionAbortController
.
signal
capture
:
true
}
;
const
eventHandler
=
this
.
tracedGlobal
.
docShell
.
chromeEventHandler
|
|
this
.
tracedGlobal
;
eventHandler
.
addEventListener
(
"
mousedown
"
listener
eventOptions
)
;
eventHandler
.
addEventListener
(
"
keydown
"
listener
eventOptions
)
;
let
shouldLogToStdout
=
listeners
.
size
=
=
0
;
for
(
const
l
of
listeners
)
{
if
(
typeof
l
.
onTracingPending
=
=
"
function
"
)
{
shouldLogToStdout
|
=
l
.
onTracingPending
(
)
;
}
}
if
(
shouldLogToStdout
)
{
this
.
loggingMethod
(
this
.
prefix
+
NEXT_INTERACTION_MESSAGE
+
"
\
n
"
)
;
}
}
#
startTracing
(
)
{
this
.
isTracing
=
true
;
this
.
dbg
.
onEnterFrame
=
this
.
onEnterFrame
;
if
(
this
.
traceDOMEvents
)
{
this
.
startTracingDOMEvents
(
)
;
}
if
(
this
.
traceDOMMutations
?
.
length
>
0
&
&
!
isWorker
)
{
this
.
startTracingDOMMutations
(
)
;
}
this
.
notifyToggle
(
true
)
;
}
startTracingDOMEvents
(
)
{
this
.
debuggerNotificationObserver
=
new
DebuggerNotificationObserver
(
)
;
this
.
eventListener
=
this
.
eventListener
.
bind
(
this
)
;
this
.
debuggerNotificationObserver
.
addListener
(
this
.
eventListener
)
;
this
.
debuggerNotificationObserver
.
connect
(
this
.
tracedGlobal
)
;
this
.
currentDOMEvent
=
null
;
}
stopTracingDOMEvents
(
)
{
if
(
this
.
debuggerNotificationObserver
)
{
this
.
debuggerNotificationObserver
.
removeListener
(
this
.
eventListener
)
;
this
.
debuggerNotificationObserver
.
disconnect
(
this
.
tracedGlobal
)
;
this
.
debuggerNotificationObserver
=
null
;
}
this
.
currentDOMEvent
=
null
;
}
startTracingDOMMutations
(
)
{
this
.
tracedGlobal
.
document
.
devToolsWatchingDOMMutations
=
true
;
const
eventOptions
=
{
signal
:
this
.
abortController
.
signal
capture
:
true
}
;
if
(
this
.
traceDOMMutations
.
includes
(
DOM_MUTATIONS
.
ADD
)
)
{
this
.
tracedGlobal
.
docShell
.
chromeEventHandler
.
addEventListener
(
"
devtoolschildinserted
"
this
.
#
onDOMMutation
eventOptions
)
;
}
if
(
this
.
traceDOMMutations
.
includes
(
DOM_MUTATIONS
.
ATTRIBUTES
)
)
{
this
.
tracedGlobal
.
docShell
.
chromeEventHandler
.
addEventListener
(
"
devtoolsattrmodified
"
this
.
#
onDOMMutation
eventOptions
)
;
}
if
(
this
.
traceDOMMutations
.
includes
(
DOM_MUTATIONS
.
REMOVE
)
)
{
this
.
tracedGlobal
.
docShell
.
chromeEventHandler
.
addEventListener
(
"
devtoolschildremoved
"
this
.
#
onDOMMutation
eventOptions
)
;
}
}
stopTracingDOMMutations
(
)
{
this
.
tracedGlobal
.
document
.
devToolsWatchingDOMMutations
=
false
;
}
#
onDOMMutation
=
event
=
>
{
if
(
event
.
target
.
isNativeAnonymous
)
{
return
;
}
let
type
=
"
"
;
switch
(
event
.
type
)
{
case
"
devtoolschildinserted
"
:
type
=
DOM_MUTATIONS
.
ADD
;
break
;
case
"
devtoolsattrmodified
"
:
type
=
DOM_MUTATIONS
.
ATTRIBUTES
;
break
;
case
"
devtoolschildremoved
"
:
type
=
DOM_MUTATIONS
.
REMOVE
;
break
;
default
:
throw
new
Error
(
"
Unexpected
DOM
Mutation
event
type
:
"
+
event
.
type
)
;
}
let
shouldLogToStdout
=
true
;
if
(
listeners
.
size
>
0
)
{
shouldLogToStdout
=
false
;
for
(
const
listener
of
listeners
)
{
if
(
typeof
listener
.
onTracingDOMMutation
=
=
"
function
"
)
{
shouldLogToStdout
|
=
listener
.
onTracingDOMMutation
(
{
depth
:
this
.
depth
prefix
:
this
.
prefix
type
element
:
event
.
target
caller
:
Components
.
stack
.
caller
}
)
;
}
}
}
if
(
shouldLogToStdout
)
{
const
padding
=
"
"
.
repeat
(
this
.
depth
+
1
)
;
this
.
loggingMethod
(
this
.
prefix
+
padding
+
[
DOM
Mutation
|
{
type
}
]
+
objectToString
(
event
.
target
)
+
"
\
n
"
)
;
}
}
;
eventListener
(
notification
)
{
if
(
notification
.
phase
=
=
"
pre
"
)
{
if
(
notification
.
type
=
=
"
domEvent
"
)
{
let
{
type
}
=
notification
.
event
;
if
(
!
type
)
{
type
=
this
.
dbg
.
makeGlobalObjectReference
(
notification
.
global
)
.
makeDebuggeeValue
(
notification
.
event
)
.
getProperty
(
"
type
"
)
.
return
;
}
this
.
currentDOMEvent
=
DOM
|
{
type
}
;
}
else
{
this
.
currentDOMEvent
=
notification
.
type
;
}
}
else
{
this
.
currentDOMEvent
=
null
;
}
}
stopTracing
(
reason
=
"
"
)
{
if
(
!
this
.
dbg
)
{
return
;
}
this
.
dbg
.
onEnterFrame
=
undefined
;
this
.
dbg
.
removeAllDebuggees
(
)
;
this
.
dbg
.
onNewGlobalObject
=
undefined
;
this
.
dbg
=
null
;
this
.
depth
=
0
;
if
(
this
.
nextInteractionAbortController
)
{
this
.
nextInteractionAbortController
.
abort
(
)
;
this
.
nextInteractionAbortController
=
null
;
}
if
(
this
.
traceDOMEvents
)
{
this
.
stopTracingDOMEvents
(
)
;
}
if
(
this
.
traceDOMMutations
?
.
length
>
0
&
&
!
isWorker
)
{
this
.
stopTracingDOMMutations
(
)
;
}
if
(
this
.
abortController
)
{
this
.
abortController
.
abort
(
)
;
}
this
.
tracedGlobal
=
null
;
this
.
isTracing
=
false
;
this
.
notifyToggle
(
false
reason
)
;
}
makeDebugger
(
)
{
const
{
isSystemPrincipal
}
=
typeof
Cu
=
=
"
object
"
?
Cu
.
getObjectPrincipal
(
this
.
tracedGlobal
)
:
{
}
;
const
dbg
=
isSystemPrincipal
?
new
customLazy
.
DistinctCompartmentDebugger
(
)
:
new
customLazy
.
Debugger
(
)
;
dbg
.
addDebuggee
(
this
.
tracedGlobal
)
;
return
dbg
;
}
notifyToggle
(
state
reason
)
{
let
shouldLogToStdout
=
listeners
.
size
=
=
0
;
for
(
const
listener
of
listeners
)
{
if
(
typeof
listener
.
onTracingToggled
=
=
"
function
"
)
{
shouldLogToStdout
|
=
listener
.
onTracingToggled
(
state
reason
)
;
}
}
if
(
shouldLogToStdout
)
{
if
(
state
)
{
this
.
loggingMethod
(
this
.
prefix
+
"
Start
tracing
JavaScript
\
n
"
)
;
}
else
{
if
(
reason
)
{
reason
=
(
reason
:
{
reason
}
)
;
}
this
.
loggingMethod
(
this
.
prefix
+
"
Stop
tracing
JavaScript
"
+
reason
+
"
\
n
"
)
;
}
}
}
notifyInfiniteLoop
(
)
{
let
shouldLogToStdout
=
listeners
.
size
=
=
0
;
for
(
const
listener
of
listeners
)
{
if
(
typeof
listener
.
onTracingInfiniteLoop
=
=
"
function
"
)
{
shouldLogToStdout
|
=
listener
.
onTracingInfiniteLoop
(
)
;
}
}
if
(
shouldLogToStdout
)
{
this
.
loggingMethod
(
this
.
prefix
+
"
Looks
like
an
infinite
recursion
?
We
stopped
the
JavaScript
tracer
but
code
may
still
be
running
!
\
n
"
)
;
}
}
onEnterFrame
(
frame
)
{
if
(
!
this
.
dbg
)
{
return
;
}
try
{
const
depth
=
getFrameDepth
(
frame
)
;
this
.
depth
=
depth
;
if
(
this
.
maxDepth
&
&
depth
>
=
this
.
maxDepth
)
{
return
;
}
if
(
this
.
pendingAwaitFrames
.
has
(
frame
)
)
{
this
.
pendingAwaitFrames
.
delete
(
frame
)
;
return
;
}
if
(
depth
=
=
=
0
&
&
this
.
maxRecords
)
{
if
(
this
.
records
>
=
this
.
maxRecords
)
{
this
.
stopTracing
(
"
max
-
records
"
)
;
return
;
}
this
.
records
+
+
;
}
if
(
depth
=
=
100
)
{
this
.
notifyInfiniteLoop
(
)
;
this
.
stopTracing
(
"
infinite
-
loop
"
)
;
return
;
}
const
frameId
=
this
.
frameId
+
+
;
let
shouldLogToStdout
=
true
;
if
(
listeners
.
size
>
0
)
{
shouldLogToStdout
=
false
;
const
formatedDisplayName
=
formatDisplayName
(
frame
)
;
for
(
const
listener
of
listeners
)
{
if
(
typeof
listener
.
onTracingFrame
=
=
"
function
"
)
{
shouldLogToStdout
|
=
listener
.
onTracingFrame
(
{
frameId
frame
depth
formatedDisplayName
prefix
:
this
.
prefix
currentDOMEvent
:
this
.
currentDOMEvent
}
)
;
}
}
}
if
(
shouldLogToStdout
)
{
this
.
logFrameEnteredToStdout
(
frame
depth
)
;
}
if
(
this
.
traceSteps
)
{
frame
.
onStep
=
(
)
=
>
{
const
{
isStepStart
}
=
frame
.
script
.
getOffsetMetadata
(
frame
.
offset
)
;
if
(
!
isStepStart
)
{
return
;
}
shouldLogToStdout
=
true
;
if
(
listeners
.
size
>
0
)
{
shouldLogToStdout
=
false
;
for
(
const
listener
of
listeners
)
{
if
(
typeof
listener
.
onTracingFrameStep
=
=
"
function
"
)
{
shouldLogToStdout
|
=
listener
.
onTracingFrameStep
(
{
frame
depth
prefix
:
this
.
prefix
}
)
;
}
}
}
if
(
shouldLogToStdout
)
{
this
.
logFrameStepToStdout
(
frame
depth
)
;
}
}
;
}
frame
.
onPop
=
completion
=
>
{
if
(
completion
?
.
await
)
{
this
.
pendingAwaitFrames
.
add
(
frame
)
;
return
;
}
if
(
!
this
.
traceFunctionReturn
)
{
return
;
}
let
why
=
"
"
;
let
rv
=
undefined
;
if
(
!
completion
)
{
why
=
FRAME_EXIT_REASONS
.
TERMINATED
;
}
else
if
(
"
return
"
in
completion
)
{
why
=
FRAME_EXIT_REASONS
.
RETURN
;
rv
=
completion
.
return
;
}
else
if
(
"
yield
"
in
completion
)
{
why
=
FRAME_EXIT_REASONS
.
YIELD
;
rv
=
completion
.
yield
;
}
else
if
(
"
await
"
in
completion
)
{
why
=
FRAME_EXIT_REASONS
.
AWAIT
;
}
else
{
why
=
FRAME_EXIT_REASONS
.
THROW
;
rv
=
completion
.
throw
;
}
shouldLogToStdout
=
true
;
if
(
listeners
.
size
>
0
)
{
shouldLogToStdout
=
false
;
const
formatedDisplayName
=
formatDisplayName
(
frame
)
;
for
(
const
listener
of
listeners
)
{
if
(
typeof
listener
.
onTracingFrameExit
=
=
"
function
"
)
{
shouldLogToStdout
|
=
listener
.
onTracingFrameExit
(
{
frameId
frame
depth
formatedDisplayName
prefix
:
this
.
prefix
why
rv
}
)
;
}
}
}
if
(
shouldLogToStdout
)
{
this
.
logFrameExitedToStdout
(
frame
depth
why
rv
)
;
}
}
;
}
catch
(
e
)
{
console
.
error
(
"
Exception
while
tracing
javascript
"
e
)
;
}
}
logFrameEnteredToStdout
(
frame
depth
)
{
const
padding
=
"
"
.
repeat
(
depth
+
1
)
;
if
(
this
.
currentDOMEvent
&
&
depth
=
=
0
)
{
this
.
loggingMethod
(
this
.
prefix
+
padding
+
this
.
currentDOMEvent
+
"
\
n
"
)
;
}
let
message
=
{
padding
}
[
{
frame
.
implementation
}
]
>
{
getTerminalHyperLink
(
frame
)
}
-
{
formatDisplayName
(
frame
)
}
;
if
(
this
.
traceValues
&
&
frame
.
arguments
)
{
message
+
=
"
(
"
;
for
(
let
i
=
0
l
=
frame
.
arguments
.
length
;
i
<
l
;
i
+
+
)
{
const
arg
=
frame
.
arguments
[
i
]
;
if
(
arg
?
.
unsafeDereference
)
{
if
(
arg
.
isClassConstructor
)
{
message
+
=
"
class
"
+
arg
.
name
;
}
else
{
message
+
=
objectToString
(
arg
.
unsafeDereference
(
)
)
;
}
}
else
{
message
+
=
primitiveToString
(
arg
)
;
}
if
(
i
<
l
-
1
)
{
message
+
=
"
"
;
}
}
message
+
=
"
)
"
;
}
this
.
loggingMethod
(
this
.
prefix
+
message
+
"
\
n
"
)
;
}
logFrameStepToStdout
(
frame
depth
)
{
const
padding
=
"
"
.
repeat
(
depth
+
1
)
;
const
message
=
{
padding
}
{
getTerminalHyperLink
(
frame
)
}
;
this
.
loggingMethod
(
this
.
prefix
+
message
+
"
\
n
"
)
;
}
logFrameExitedToStdout
(
frame
depth
why
rv
)
{
const
padding
=
"
"
.
repeat
(
depth
+
1
)
;
let
message
=
{
padding
}
[
{
frame
.
implementation
}
]
<
{
getTerminalHyperLink
(
frame
)
}
-
{
formatDisplayName
(
frame
)
}
{
why
}
;
if
(
this
.
traceValues
)
{
message
+
=
"
"
;
if
(
rv
?
.
unsafeDereference
)
{
if
(
rv
.
isClassConstructor
)
{
message
+
=
"
class
"
+
rv
.
name
;
}
else
{
message
+
=
objectToString
(
rv
.
unsafeDereference
(
)
)
;
}
}
else
{
message
+
=
primitiveToString
(
rv
)
;
}
}
this
.
loggingMethod
(
this
.
prefix
+
message
+
"
\
n
"
)
;
}
}
function
objectToString
(
obj
)
{
if
(
Element
.
isInstance
(
obj
)
)
{
let
message
=
<
{
obj
.
tagName
}
;
if
(
obj
.
id
)
{
message
+
=
#
{
obj
.
id
}
;
}
if
(
obj
.
className
)
{
message
+
=
.
{
obj
.
className
}
;
}
message
+
=
"
>
"
;
return
message
;
}
else
if
(
Array
.
isArray
(
obj
)
)
{
return
Array
(
{
obj
.
length
}
)
;
}
else
if
(
Event
.
isInstance
(
obj
)
)
{
return
Event
(
{
obj
.
type
}
)
target
=
{
objectToString
(
obj
.
target
)
}
;
}
else
if
(
typeof
obj
=
=
=
"
function
"
)
{
return
function
{
obj
.
name
|
|
"
anonymous
"
}
(
)
;
}
return
obj
;
}
function
primitiveToString
(
value
)
{
const
type
=
typeof
value
;
if
(
type
=
=
=
"
string
"
)
{
return
JSON
.
stringify
(
value
)
;
}
else
if
(
value
=
=
=
0
&
&
1
/
value
=
=
=
-
Infinity
)
{
return
"
-
0
"
;
}
else
if
(
type
=
=
=
"
bigint
"
)
{
return
BigInt
(
{
value
}
)
;
}
else
if
(
value
&
&
typeof
value
.
toString
=
=
=
"
function
"
)
{
return
value
.
toString
(
)
;
}
return
value
;
}
function
formatDisplayName
(
frame
)
{
if
(
frame
.
type
=
=
=
"
call
"
)
{
const
callee
=
frame
.
callee
;
return
"
"
+
(
callee
.
name
|
|
callee
.
displayName
|
|
"
anonymous
"
)
;
}
return
(
{
frame
.
type
}
)
;
}
let
activeTracer
=
null
;
function
startTracing
(
options
)
{
if
(
!
options
)
{
throw
new
Error
(
"
startTracing
excepts
an
options
object
as
first
argument
"
)
;
}
if
(
!
activeTracer
)
{
activeTracer
=
new
JavaScriptTracer
(
options
)
;
}
else
{
console
.
warn
(
"
Can
'
t
start
JavaScript
tracing
another
tracer
is
still
active
and
we
only
support
one
tracer
at
a
time
.
"
)
;
}
}
function
stopTracing
(
)
{
if
(
activeTracer
)
{
activeTracer
.
stopTracing
(
)
;
activeTracer
=
null
;
}
else
{
console
.
warn
(
"
Can
'
t
stop
JavaScript
Tracing
as
we
were
not
tracing
.
"
)
;
}
}
function
addTracingListener
(
listener
)
{
listeners
.
add
(
listener
)
;
if
(
activeTracer
?
.
isTracing
&
&
typeof
listener
.
onTracingToggled
=
=
"
function
"
)
{
listener
.
onTracingToggled
(
true
)
;
}
}
function
removeTracingListener
(
listener
)
{
listeners
.
delete
(
listener
)
;
}
function
getFrameDepth
(
frame
)
{
if
(
typeof
frame
.
depth
!
=
=
"
number
"
)
{
let
depth
=
0
;
let
f
=
frame
;
while
(
(
f
=
f
.
older
)
)
{
depth
+
+
;
}
frame
.
depth
=
depth
;
}
return
frame
.
depth
;
}
function
getTerminalHyperLink
(
frame
)
{
const
{
script
}
=
frame
;
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
frame
.
offset
)
;
const
href
=
{
script
.
source
.
url
}
:
{
lineNumber
}
:
{
columnNumber
}
;
return
\
x1B
]
8
;
;
{
href
}
\
x1B
\
\
{
href
}
\
x1B
]
8
;
;
\
x1B
\
\
;
}
if
(
typeof
module
=
=
"
object
"
)
{
module
.
exports
=
{
startTracing
stopTracing
addTracingListener
removeTracingListener
}
;
}
