"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
startTracing
"
"
stopTracing
"
"
addTracingListener
"
"
removeTracingListener
"
]
;
const
listeners
=
new
Set
(
)
;
const
customLazy
=
{
get
Debugger
(
)
{
if
(
globalThis
.
Debugger
)
{
return
globalThis
.
Debugger
;
}
const
{
addDebuggerToGlobal
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
sys
.
mjs
"
)
;
const
systemPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
const
debuggerSandbox
=
Cu
.
Sandbox
(
systemPrincipal
)
;
addDebuggerToGlobal
(
debuggerSandbox
)
;
delete
customLazy
.
Debugger
;
customLazy
.
Debugger
=
debuggerSandbox
.
Debugger
;
return
customLazy
.
Debugger
;
}
get
DistinctCompartmentDebugger
(
)
{
const
{
addDebuggerToGlobal
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
sys
.
mjs
"
)
;
const
systemPrincipal
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
const
debuggerSandbox
=
Cu
.
Sandbox
(
systemPrincipal
{
freshCompartment
:
true
}
)
;
addDebuggerToGlobal
(
debuggerSandbox
)
;
delete
customLazy
.
DistinctCompartmentDebugger
;
customLazy
.
DistinctCompartmentDebugger
=
debuggerSandbox
.
Debugger
;
return
customLazy
.
DistinctCompartmentDebugger
;
}
}
;
class
JavaScriptTracer
{
constructor
(
options
)
{
this
.
onEnterFrame
=
this
.
onEnterFrame
.
bind
(
this
)
;
const
global
=
options
.
global
|
|
Cu
.
getGlobalForObject
(
options
)
;
this
.
dbg
=
this
.
makeDebugger
(
global
)
;
this
.
depth
=
0
;
this
.
prefix
=
options
.
prefix
?
{
options
.
prefix
}
:
:
"
"
;
this
.
dbg
.
onEnterFrame
=
this
.
onEnterFrame
;
this
.
notifyToggle
(
true
)
;
}
stopTracing
(
)
{
if
(
!
this
.
isTracing
(
)
)
{
return
;
}
this
.
dbg
.
onEnterFrame
=
undefined
;
this
.
dbg
.
removeAllDebuggees
(
)
;
this
.
dbg
.
onNewGlobalObject
=
undefined
;
this
.
dbg
=
null
;
this
.
depth
=
0
;
this
.
options
=
null
;
this
.
notifyToggle
(
false
)
;
}
isTracing
(
)
{
return
!
!
this
.
dbg
;
}
makeDebugger
(
global
)
{
const
{
isSystemPrincipal
}
=
typeof
Cu
=
=
"
object
"
?
Cu
.
getObjectPrincipal
(
global
)
:
{
}
;
const
dbg
=
isSystemPrincipal
?
new
customLazy
.
DistinctCompartmentDebugger
(
)
:
new
customLazy
.
Debugger
(
)
;
dbg
.
addDebuggee
(
global
)
;
return
dbg
;
}
notifyToggle
(
state
)
{
let
shouldLogToStdout
=
listeners
.
size
=
=
0
;
for
(
const
listener
of
listeners
)
{
if
(
typeof
listener
.
onTracingToggled
=
=
"
function
"
)
{
shouldLogToStdout
|
=
listener
.
onTracingToggled
(
state
)
;
}
}
if
(
shouldLogToStdout
)
{
if
(
state
)
{
dump
(
this
.
prefix
+
"
Start
tracing
JavaScript
\
n
"
)
;
}
else
{
dump
(
this
.
prefix
+
"
Stop
tracing
JavaScript
\
n
"
)
;
}
}
}
notifyInfiniteLoop
(
)
{
let
shouldLogToStdout
=
listeners
.
size
=
=
0
;
for
(
const
listener
of
listeners
)
{
if
(
typeof
listener
.
onTracingInfiniteLoop
=
=
"
function
"
)
{
shouldLogToStdout
|
=
listener
.
onTracingInfiniteLoop
(
)
;
}
}
if
(
shouldLogToStdout
)
{
dump
(
this
.
prefix
+
"
Looks
like
an
infinite
recursion
?
We
stopped
the
JavaScript
tracer
but
code
may
still
be
running
!
\
n
"
)
;
}
}
onEnterFrame
(
frame
)
{
if
(
!
this
.
dbg
)
{
return
;
}
try
{
if
(
this
.
depth
=
=
100
)
{
this
.
notifyInfiniteLoop
(
)
;
this
.
stopTracing
(
)
;
return
;
}
const
formatedDisplayName
=
formatDisplayName
(
frame
)
;
let
shouldLogToStdout
=
true
;
if
(
listeners
.
size
>
0
)
{
shouldLogToStdout
=
false
;
for
(
const
listener
of
listeners
)
{
if
(
typeof
listener
.
onTracingFrame
=
=
"
function
"
)
{
shouldLogToStdout
|
=
listener
.
onTracingFrame
(
{
frame
depth
:
this
.
depth
formatedDisplayName
prefix
:
this
.
prefix
}
)
;
}
}
}
if
(
shouldLogToStdout
)
{
const
{
script
}
=
frame
;
const
{
lineNumber
columnNumber
}
=
script
.
getOffsetMetadata
(
frame
.
offset
)
;
const
padding
=
"
"
.
repeat
(
this
.
depth
+
1
)
;
const
href
=
{
script
.
source
.
url
}
:
{
lineNumber
}
:
{
columnNumber
}
;
const
urlLink
=
\
x1B
]
8
;
;
{
href
}
\
x1B
\
\
{
href
}
\
x1B
]
8
;
;
\
x1B
\
\
;
const
message
=
{
padding
}
[
{
frame
.
implementation
}
]
>
{
urlLink
}
-
{
formatDisplayName
(
frame
)
}
;
dump
(
this
.
prefix
+
message
+
"
\
n
"
)
;
}
this
.
depth
+
+
;
frame
.
onPop
=
(
)
=
>
{
this
.
depth
-
-
;
}
;
}
catch
(
e
)
{
console
.
error
(
"
Exception
while
tracing
javascript
"
e
)
;
}
}
}
function
formatDisplayName
(
frame
)
{
if
(
frame
.
type
=
=
=
"
call
"
)
{
const
callee
=
frame
.
callee
;
return
"
"
+
(
callee
.
name
|
|
callee
.
displayName
|
|
"
anonymous
"
)
;
}
return
(
{
frame
.
type
}
)
;
}
let
activeTracer
=
null
;
function
startTracing
(
options
)
{
if
(
!
options
)
{
throw
new
Error
(
"
startTracing
excepts
an
options
object
as
first
argument
"
)
;
}
if
(
!
activeTracer
)
{
activeTracer
=
new
JavaScriptTracer
(
options
)
;
}
else
{
console
.
warn
(
"
Can
'
t
start
JavaScript
tracing
another
tracer
is
still
active
and
we
only
support
one
tracer
at
a
time
.
"
)
;
}
}
function
stopTracing
(
)
{
if
(
activeTracer
)
{
activeTracer
.
stopTracing
(
)
;
activeTracer
=
null
;
}
else
{
console
.
warn
(
"
Can
'
t
stop
JavaScript
Tracing
as
we
were
not
tracing
.
"
)
;
}
}
function
addTracingListener
(
listener
)
{
listeners
.
add
(
listener
)
;
if
(
activeTracer
?
.
isTracing
(
)
&
&
typeof
listener
.
onTracingToggled
=
=
"
function
"
)
{
listener
.
onTracingToggled
(
true
)
;
}
}
function
removeTracingListener
(
listener
)
{
listeners
.
delete
(
listener
)
;
}
if
(
typeof
module
=
=
"
object
"
)
{
module
.
exports
=
{
startTracing
stopTracing
addTracingListener
removeTracingListener
}
;
}
