"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
JQUERY_LIVE_REGEX
=
/
return
typeof
\
w
+
.
*
.
event
\
.
triggered
[
\
s
\
S
]
*
\
.
event
\
.
(
dispatch
|
handle
)
.
*
arguments
/
;
loader
.
lazyGetter
(
this
"
eventListenerService
"
(
)
=
>
{
return
Cc
[
"
mozilla
.
org
/
eventlistenerservice
;
1
"
]
.
getService
(
Ci
.
nsIEventListenerService
)
;
}
)
;
var
parsers
=
[
{
id
:
"
jQuery
events
"
getListeners
(
node
)
{
let
global
=
node
.
ownerGlobal
.
wrappedJSObject
;
let
hasJQuery
=
global
.
jQuery
&
&
global
.
jQuery
.
fn
&
&
global
.
jQuery
.
fn
.
jquery
;
if
(
!
hasJQuery
)
{
return
undefined
;
}
let
jQuery
=
global
.
jQuery
;
let
handlers
=
[
]
;
let
data
=
jQuery
.
_data
|
|
jQuery
.
data
;
if
(
data
)
{
let
eventsObj
=
data
(
node
"
events
"
)
;
for
(
let
type
in
eventsObj
)
{
let
events
=
eventsObj
[
type
]
;
for
(
let
key
in
events
)
{
let
event
=
events
[
key
]
;
if
(
node
.
wrappedJSObject
=
=
global
.
document
&
&
event
.
selector
)
{
continue
;
}
if
(
typeof
event
=
=
=
"
object
"
|
|
typeof
event
=
=
=
"
function
"
)
{
let
eventInfo
=
{
type
handler
:
event
.
handler
|
|
event
tags
:
"
jQuery
"
hide
:
{
capturing
:
true
dom0
:
true
}
}
;
handlers
.
push
(
eventInfo
)
;
}
}
}
}
let
entry
=
jQuery
(
node
)
[
0
]
;
if
(
!
entry
)
{
return
handlers
;
}
for
(
let
type
in
entry
.
events
)
{
let
events
=
entry
.
events
[
type
]
;
for
(
let
key
in
events
)
{
let
event
=
events
[
key
]
;
if
(
node
.
wrappedJSObject
=
=
global
.
document
&
&
event
.
selector
)
{
continue
;
}
if
(
typeof
events
[
key
]
=
=
=
"
function
"
)
{
let
eventInfo
=
{
type
handler
:
events
[
key
]
tags
:
"
jQuery
"
hide
:
{
capturing
:
true
dom0
:
true
}
}
;
handlers
.
push
(
eventInfo
)
;
}
}
}
return
handlers
;
}
}
{
id
:
"
jQuery
live
events
"
hasListeners
(
node
)
{
return
jQueryLiveGetListeners
(
node
true
)
;
}
getListeners
(
node
)
{
return
jQueryLiveGetListeners
(
node
false
)
;
}
normalizeListener
(
handlerDO
)
{
function
isFunctionInProxy
(
funcDO
)
{
let
displayName
=
funcDO
.
displayName
;
if
(
displayName
&
&
displayName
.
startsWith
(
"
proxy
/
"
)
)
{
return
true
;
}
let
calleeDO
=
funcDO
.
environment
.
callee
;
if
(
!
calleeDO
)
{
return
false
;
}
let
calleeName
=
calleeDO
.
displayName
;
return
calleeName
=
=
"
proxy
"
;
}
function
getFirstFunctionVariable
(
funcDO
)
{
let
names
=
funcDO
.
environment
.
names
(
)
;
for
(
let
varName
of
names
)
{
let
varDO
=
handlerDO
.
environment
.
getVariable
(
varName
)
;
if
(
!
varDO
)
{
continue
;
}
if
(
varDO
.
class
=
=
"
Function
"
)
{
return
varDO
;
}
}
return
null
;
}
if
(
!
isFunctionInProxy
(
handlerDO
)
)
{
return
handlerDO
;
}
const
MAX_NESTED_HANDLER_COUNT
=
2
;
for
(
let
i
=
0
;
i
<
MAX_NESTED_HANDLER_COUNT
;
i
+
+
)
{
let
funcDO
=
getFirstFunctionVariable
(
handlerDO
)
;
if
(
!
funcDO
)
{
return
handlerDO
;
}
handlerDO
=
funcDO
;
if
(
isFunctionInProxy
(
handlerDO
)
)
{
continue
;
}
break
;
}
return
handlerDO
;
}
}
{
id
:
"
DOM
events
"
hasListeners
(
node
)
{
let
listeners
;
if
(
node
.
nodeName
.
toLowerCase
(
)
=
=
=
"
html
"
)
{
let
winListeners
=
eventListenerService
.
getListenerInfoFor
(
node
.
ownerGlobal
)
|
|
[
]
;
let
docElementListeners
=
eventListenerService
.
getListenerInfoFor
(
node
)
|
|
[
]
;
let
docListeners
=
eventListenerService
.
getListenerInfoFor
(
node
.
parentNode
)
|
|
[
]
;
listeners
=
[
.
.
.
winListeners
.
.
.
docElementListeners
.
.
.
docListeners
]
;
}
else
{
listeners
=
eventListenerService
.
getListenerInfoFor
(
node
)
|
|
[
]
;
}
for
(
let
listener
of
listeners
)
{
if
(
listener
.
listenerObject
&
&
listener
.
type
)
{
return
true
;
}
}
return
false
;
}
getListeners
(
node
)
{
let
handlers
=
[
]
;
let
listeners
=
eventListenerService
.
getListenerInfoFor
(
node
)
;
for
(
let
listenerObj
of
listeners
)
{
let
listener
=
listenerObj
.
listenerObject
;
if
(
!
listener
|
|
JQUERY_LIVE_REGEX
.
test
(
listener
.
toString
(
)
)
)
{
continue
;
}
let
eventInfo
=
{
capturing
:
listenerObj
.
capturing
type
:
listenerObj
.
type
handler
:
listener
}
;
handlers
.
push
(
eventInfo
)
;
}
return
handlers
;
}
}
{
id
:
"
React
events
"
hasListeners
(
node
)
{
return
reactGetListeners
(
node
true
)
;
}
getListeners
(
node
)
{
return
reactGetListeners
(
node
false
)
;
}
normalizeListener
(
handlerDO
listener
)
{
let
functionText
=
"
"
;
if
(
handlerDO
.
boundTargetFunction
)
{
handlerDO
=
handlerDO
.
boundTargetFunction
;
}
let
introScript
=
handlerDO
.
script
.
source
.
introductionScript
;
let
script
=
handlerDO
.
script
;
if
(
introScript
&
&
introScript
.
displayName
.
endsWith
(
"
/
transform
.
run
"
)
)
{
listener
.
hide
.
debugger
=
true
;
listener
.
hide
.
filename
=
true
;
if
(
!
handlerDO
.
isArrowFunction
)
{
functionText
+
=
"
function
(
"
;
}
else
{
functionText
+
=
"
(
"
;
}
functionText
+
=
handlerDO
.
parameterNames
.
join
(
"
"
)
;
functionText
+
=
"
)
{
\
n
"
;
let
scriptSource
=
script
.
source
.
text
;
functionText
+
=
scriptSource
.
substr
(
script
.
sourceStart
script
.
sourceLength
)
;
listener
.
override
.
handler
=
functionText
;
}
return
handlerDO
;
}
}
]
;
function
reactGetListeners
(
node
boolOnEventFound
)
{
function
getProps
(
)
{
for
(
let
key
in
node
)
{
if
(
key
.
startsWith
(
"
__reactInternalInstance
"
)
)
{
return
node
[
key
]
.
_currentElement
.
props
;
}
}
return
null
;
}
node
=
node
.
wrappedJSObject
|
|
node
;
let
handlers
=
[
]
;
let
props
=
getProps
(
)
;
if
(
props
)
{
for
(
let
name
in
props
)
{
if
(
name
.
startsWith
(
"
on
"
)
)
{
let
prop
=
props
[
name
]
;
let
listener
=
prop
.
__reactBoundMethod
|
|
prop
;
if
(
typeof
listener
!
=
=
"
function
"
)
{
continue
;
}
if
(
boolOnEventFound
)
{
return
true
;
}
let
handler
=
{
type
:
name
handler
:
listener
tags
:
"
React
"
hide
:
{
dom0
:
true
}
override
:
{
capturing
:
name
.
endsWith
(
"
Capture
"
)
}
}
;
handlers
.
push
(
handler
)
;
}
}
}
if
(
boolOnEventFound
)
{
return
false
;
}
return
handlers
;
}
function
jQueryLiveGetListeners
(
node
boolOnEventFound
)
{
let
global
=
node
.
ownerGlobal
.
wrappedJSObject
;
let
hasJQuery
=
global
.
jQuery
&
&
global
.
jQuery
.
fn
&
&
global
.
jQuery
.
fn
.
jquery
;
if
(
!
hasJQuery
)
{
return
undefined
;
}
let
jQuery
=
global
.
jQuery
;
let
handlers
=
[
]
;
let
data
=
jQuery
.
_data
|
|
jQuery
.
data
;
if
(
data
)
{
let
events
=
data
(
global
.
document
"
events
"
)
;
for
(
let
type
in
events
)
{
let
eventHolder
=
events
[
type
]
;
for
(
let
idx
in
eventHolder
)
{
if
(
typeof
idx
!
=
=
"
string
"
|
|
isNaN
(
parseInt
(
idx
10
)
)
)
{
continue
;
}
let
event
=
eventHolder
[
idx
]
;
let
selector
=
event
.
selector
;
if
(
!
selector
&
&
event
.
data
)
{
selector
=
event
.
data
.
selector
|
|
event
.
data
|
|
event
.
selector
;
}
if
(
!
selector
|
|
!
node
.
ownerDocument
)
{
continue
;
}
let
matches
;
try
{
matches
=
node
.
matches
&
&
node
.
matches
(
selector
)
;
}
catch
(
e
)
{
}
if
(
boolOnEventFound
&
&
matches
)
{
return
true
;
}
if
(
!
matches
)
{
continue
;
}
if
(
!
boolOnEventFound
&
&
(
typeof
event
=
=
=
"
object
"
|
|
typeof
event
=
=
=
"
function
"
)
)
{
let
eventInfo
=
{
type
:
event
.
origType
|
|
event
.
type
.
substr
(
selector
.
length
+
1
)
handler
:
event
.
handler
|
|
event
tags
:
"
jQuery
Live
"
hide
:
{
dom0
:
true
capturing
:
true
}
}
;
if
(
!
eventInfo
.
type
&
&
event
.
data
&
&
event
.
data
.
live
)
{
eventInfo
.
type
=
event
.
data
.
live
;
}
handlers
.
push
(
eventInfo
)
;
}
}
}
}
if
(
boolOnEventFound
)
{
return
false
;
}
return
handlers
;
}
this
.
EventParsers
=
function
EventParsers
(
)
{
if
(
this
.
_eventParsers
.
size
=
=
=
0
)
{
for
(
let
parserObj
of
parsers
)
{
this
.
registerEventParser
(
parserObj
)
;
}
}
}
;
exports
.
EventParsers
=
EventParsers
;
EventParsers
.
prototype
=
{
_eventParsers
:
new
Map
(
)
get
parsers
(
)
{
return
this
.
_eventParsers
;
}
registerEventParser
(
parserObj
)
{
let
parserId
=
parserObj
.
id
;
if
(
!
parserId
)
{
throw
new
Error
(
"
Cannot
register
new
event
parser
with
id
"
+
parserId
)
;
}
if
(
this
.
_eventParsers
.
has
(
parserId
)
)
{
throw
new
Error
(
"
Duplicate
event
parser
id
"
+
parserId
)
;
}
this
.
_eventParsers
.
set
(
parserId
{
getListeners
:
parserObj
.
getListeners
hasListeners
:
parserObj
.
hasListeners
normalizeListener
:
parserObj
.
normalizeListener
}
)
;
}
unregisterEventParser
(
parserId
)
{
this
.
_eventParsers
.
delete
(
parserId
)
;
}
destroy
(
)
{
for
(
let
[
id
]
of
this
.
_eventParsers
)
{
this
.
unregisterEventParser
(
id
true
)
;
}
}
}
;
