"
use
strict
"
;
var
{
Ci
}
=
require
(
"
chrome
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
{
ActorRegistry
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
actor
-
registry
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
{
dumpn
}
=
DevToolsUtils
;
loader
.
lazyRequireGetter
(
this
"
DevToolsServerConnection
"
"
devtools
/
server
/
devtools
-
server
-
connection
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Authentication
"
"
devtools
/
shared
/
security
/
auth
"
)
;
loader
.
lazyRequireGetter
(
this
"
LocalDebuggerTransport
"
"
devtools
/
shared
/
transport
/
local
-
transport
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ChildDebuggerTransport
"
"
devtools
/
shared
/
transport
/
child
-
transport
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
JsWindowActorTransport
"
"
devtools
/
shared
/
transport
/
js
-
window
-
actor
-
transport
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WorkerThreadWorkerDebuggerTransport
"
"
devtools
/
shared
/
transport
/
worker
-
transport
"
true
)
;
const
CONTENT_PROCESS_SERVER_STARTUP_SCRIPT
=
"
resource
:
/
/
devtools
/
server
/
startup
/
content
-
process
.
js
"
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
var
DevToolsServer
=
{
_listeners
:
[
]
_initialized
:
false
globalActorFactories
:
{
}
targetScopedActorFactories
:
{
}
LONG_STRING_LENGTH
:
10000
LONG_STRING_INITIAL_LENGTH
:
1000
LONG_STRING_READ_LENGTH
:
65
*
1024
chromeWindowType
:
"
navigator
:
browser
"
allowChromeProcess
:
false
keepAlive
:
false
get
rootlessServer
(
)
{
return
!
this
.
createRootActor
;
}
init
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
_connections
=
{
}
;
ActorRegistry
.
init
(
this
.
_connections
)
;
this
.
_nextConnID
=
0
;
this
.
_initialized
=
true
;
this
.
_onSocketListenerAccepted
=
this
.
_onSocketListenerAccepted
.
bind
(
this
)
;
if
(
!
isWorker
)
{
const
subject
=
{
wrappedJSObject
:
ActorRegistry
}
;
Services
.
obs
.
notifyObservers
(
subject
"
devtools
-
server
-
initialized
"
)
;
}
}
get
protocol
(
)
{
return
require
(
"
devtools
/
shared
/
protocol
"
)
;
}
get
initialized
(
)
{
return
this
.
_initialized
;
}
hasConnection
(
)
{
return
this
.
_connections
&
&
!
!
Object
.
keys
(
this
.
_connections
)
.
length
;
}
hasConnectionForPrefix
(
prefix
)
{
return
this
.
_connections
&
&
!
!
this
.
_connections
[
prefix
+
"
/
"
]
;
}
destroy
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
false
;
for
(
const
connection
of
Object
.
values
(
this
.
_connections
)
)
{
connection
.
close
(
)
;
}
ActorRegistry
.
destroy
(
)
;
this
.
closeAllSocketListeners
(
)
;
this
.
off
(
"
connectionchange
"
)
;
dumpn
(
"
DevTools
server
is
shut
down
.
"
)
;
}
_checkInit
(
)
{
if
(
!
this
.
_initialized
)
{
throw
new
Error
(
"
DevToolsServer
has
not
been
initialized
.
"
)
;
}
if
(
!
this
.
rootlessServer
&
&
!
this
.
createRootActor
)
{
throw
new
Error
(
"
Use
DevToolsServer
.
setRootActor
(
)
to
add
a
root
actor
"
+
"
implementation
.
"
)
;
}
}
registerActors
(
{
root
browser
target
}
)
{
if
(
browser
)
{
ActorRegistry
.
addBrowserActors
(
)
;
}
if
(
root
)
{
const
{
createRootActor
}
=
require
(
"
devtools
/
server
/
actors
/
webbrowser
"
)
;
this
.
setRootActor
(
createRootActor
)
;
}
if
(
target
)
{
ActorRegistry
.
addTargetScopedActors
(
)
;
}
}
registerAllActors
(
)
{
this
.
registerActors
(
{
root
:
true
browser
:
true
target
:
true
}
)
;
}
get
listeningSockets
(
)
{
return
this
.
_listeners
.
length
;
}
addSocketListener
(
listener
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
remote
-
enabled
"
)
)
{
throw
new
Error
(
"
Can
'
t
add
a
SocketListener
remote
debugging
disabled
"
)
;
}
this
.
_checkInit
(
)
;
listener
.
on
(
"
accepted
"
this
.
_onSocketListenerAccepted
)
;
this
.
_listeners
.
push
(
listener
)
;
}
removeSocketListener
(
listener
)
{
for
(
const
connID
of
Object
.
getOwnPropertyNames
(
this
.
_connections
)
)
{
const
connection
=
this
.
_connections
[
connID
]
;
if
(
connection
.
isAcceptedBy
(
listener
)
)
{
connection
.
close
(
)
;
}
}
this
.
_listeners
=
this
.
_listeners
.
filter
(
l
=
>
l
!
=
=
listener
)
;
listener
.
off
(
"
accepted
"
this
.
_onSocketListenerAccepted
)
;
}
closeAllSocketListeners
(
)
{
if
(
!
this
.
listeningSockets
)
{
return
false
;
}
for
(
const
listener
of
this
.
_listeners
)
{
listener
.
close
(
)
;
}
return
true
;
}
_onSocketListenerAccepted
(
transport
listener
)
{
this
.
_onConnection
(
transport
null
false
listener
)
;
}
connectPipe
(
prefix
)
{
this
.
_checkInit
(
)
;
const
serverTransport
=
new
LocalDebuggerTransport
(
)
;
const
clientTransport
=
new
LocalDebuggerTransport
(
serverTransport
)
;
serverTransport
.
other
=
clientTransport
;
const
connection
=
this
.
_onConnection
(
serverTransport
prefix
)
;
clientTransport
.
_serverConnection
=
connection
;
return
clientTransport
;
}
connectToParent
(
prefix
scopeOrManager
)
{
this
.
_checkInit
(
)
;
const
transport
=
isWorker
?
new
WorkerThreadWorkerDebuggerTransport
(
scopeOrManager
prefix
)
:
new
ChildDebuggerTransport
(
scopeOrManager
prefix
)
;
return
this
.
_onConnection
(
transport
prefix
true
)
;
}
connectToParentWindowActor
(
jsWindowChildActor
forwardingPrefix
)
{
this
.
_checkInit
(
)
;
const
transport
=
new
JsWindowActorTransport
(
jsWindowChildActor
forwardingPrefix
)
;
return
this
.
_onConnection
(
transport
forwardingPrefix
true
)
;
}
get
isInChildProcess
(
)
{
return
(
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
)
;
}
_onConnection
(
transport
forwardingPrefix
noRootActor
=
false
socketListener
=
null
)
{
let
connID
;
if
(
forwardingPrefix
)
{
connID
=
forwardingPrefix
+
"
/
"
;
}
else
{
connID
=
"
server
"
+
loader
.
id
+
"
.
conn
"
+
this
.
_nextConnID
+
+
+
"
.
"
;
}
const
conn
=
new
DevToolsServerConnection
(
connID
transport
socketListener
)
;
this
.
_connections
[
connID
]
=
conn
;
if
(
!
noRootActor
)
{
conn
.
rootActor
=
this
.
createRootActor
(
conn
)
;
if
(
forwardingPrefix
)
{
conn
.
rootActor
.
actorID
=
forwardingPrefix
+
"
/
root
"
;
}
else
{
conn
.
rootActor
.
actorID
=
"
root
"
;
}
conn
.
addActor
(
conn
.
rootActor
)
;
transport
.
send
(
conn
.
rootActor
.
sayHello
(
)
)
;
}
transport
.
ready
(
)
;
this
.
emit
(
"
connectionchange
"
"
opened
"
conn
)
;
return
conn
;
}
_connectionClosed
(
connection
)
{
delete
this
.
_connections
[
connection
.
prefix
]
;
this
.
emit
(
"
connectionchange
"
"
closed
"
connection
)
;
if
(
this
.
hasConnection
(
)
|
|
this
.
keepAlive
)
{
return
;
}
this
.
destroy
(
)
;
}
setRootActor
(
actorFactory
)
{
this
.
createRootActor
=
actorFactory
;
}
removeContentServerScript
(
)
{
Services
.
ppmm
.
removeDelayedProcessScript
(
CONTENT_PROCESS_SERVER_STARTUP_SCRIPT
)
;
try
{
Services
.
ppmm
.
broadcastAsyncMessage
(
"
debug
:
close
-
content
-
server
"
)
;
}
catch
(
e
)
{
}
}
searchAllConnectionsForActor
(
actorID
)
{
for
(
const
connID
of
Object
.
getOwnPropertyNames
(
this
.
_connections
)
)
{
const
actor
=
this
.
_connections
[
connID
]
.
getActor
(
actorID
)
;
if
(
actor
)
{
return
actor
;
}
}
return
null
;
}
}
;
DevToolsUtils
.
defineLazyGetter
(
DevToolsServer
"
Authenticators
"
(
)
=
>
{
return
Authentication
.
Authenticators
;
}
)
;
DevToolsUtils
.
defineLazyGetter
(
DevToolsServer
"
AuthenticationResult
"
(
)
=
>
{
return
Authentication
.
AuthenticationResult
;
}
)
;
EventEmitter
.
decorate
(
DevToolsServer
)
;
exports
.
DevToolsServer
=
DevToolsServer
;
