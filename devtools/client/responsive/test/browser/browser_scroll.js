"
use
strict
"
;
const
PAINT_LISTENER_JS_URL
=
URL_ROOT
+
"
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
tests
/
SimpleTest
/
paint_listener
.
js
"
;
const
APZ_TEST_UTILS_JS_URL
=
URL_ROOT
+
"
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
gfx
/
layers
/
apz
/
test
/
mochitest
/
apz_test_utils
.
js
"
;
const
TEST_URL
=
"
data
:
text
/
html
;
charset
=
utf
-
8
"
+
'
<
head
>
<
meta
name
=
"
viewport
"
content
=
"
width
=
100
height
=
100
"
/
>
'
+
'
<
script
src
=
"
'
+
PAINT_LISTENER_JS_URL
+
'
"
>
<
/
script
>
'
+
'
<
script
src
=
"
'
+
APZ_TEST_UTILS_JS_URL
+
'
"
>
<
/
script
>
'
+
"
<
/
head
>
"
+
'
<
div
style
=
"
background
:
blue
;
width
:
200px
;
height
:
200px
"
>
<
/
div
>
'
;
addRDMTask
(
TEST_URL
async
function
(
{
ui
manager
}
)
{
await
setViewportSize
(
ui
manager
50
50
)
;
const
browser
=
ui
.
getViewportBrowser
(
)
;
for
(
const
mv
in
[
true
false
]
)
{
await
ui
.
updateTouchSimulation
(
mv
)
;
info
(
"
Setting
focus
on
the
browser
.
"
)
;
browser
.
focus
(
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
await
content
.
wrappedJSObject
.
cancelScrollAnimation
(
content
.
document
.
scrollingElement
content
)
;
content
.
scrollTo
(
0
0
)
;
}
)
;
info
(
"
Testing
scroll
behavior
with
touch
simulation
"
+
mv
+
"
.
"
)
;
await
testScrollingOfContent
(
ui
)
;
}
}
)
;
async
function
testScrollingOfContent
(
ui
)
{
let
scroll
;
info
(
"
Checking
initial
scroll
conditions
.
"
)
;
const
viewportScroll
=
await
getViewportScroll
(
ui
)
;
is
(
viewportScroll
.
x
0
"
Content
should
load
with
scrollX
0
.
"
)
;
is
(
viewportScroll
.
y
0
"
Content
should
load
with
scrollY
0
.
"
)
;
scroll
=
waitForViewportScroll
(
ui
)
;
info
(
"
Synthesizing
an
arrow
key
down
.
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
await
scroll
;
info
(
"
Scroll
event
was
fired
after
arrow
key
down
.
"
)
;
scroll
=
waitForViewportScroll
(
ui
)
;
info
(
"
Synthesizing
an
arrow
key
right
.
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowRight
"
)
;
await
scroll
;
info
(
"
Scroll
event
was
fired
after
arrow
key
right
.
"
)
;
}
